{
  "module_name": "fw.c",
  "hash_id": "f89a1b1950d0a3b6d24cddcb1a454821fa16dc057fc2fe025f0ff72f31531db1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/fw.c",
  "human_readable_source": "\n \n#include <net/mac80211.h>\n#include <linux/netdevice.h>\n#include <linux/dmi.h>\n\n#include \"iwl-trans.h\"\n#include \"iwl-op-mode.h\"\n#include \"fw/img.h\"\n#include \"iwl-debug.h\"\n#include \"iwl-prph.h\"\n#include \"fw/acpi.h\"\n#include \"fw/pnvm.h\"\n\n#include \"mvm.h\"\n#include \"fw/dbg.h\"\n#include \"iwl-phy-db.h\"\n#include \"iwl-modparams.h\"\n#include \"iwl-nvm-parse.h\"\n#include \"time-sync.h\"\n\n#define MVM_UCODE_ALIVE_TIMEOUT\t(HZ)\n#define MVM_UCODE_CALIB_TIMEOUT\t(2 * HZ)\n\n#define IWL_TAS_US_MCC 0x5553\n#define IWL_TAS_CANADA_MCC 0x4341\n\nstruct iwl_mvm_alive_data {\n\tbool valid;\n\tu32 scd_base_addr;\n};\n\nstatic int iwl_send_tx_ant_cfg(struct iwl_mvm *mvm, u8 valid_tx_ant)\n{\n\tstruct iwl_tx_ant_cfg_cmd tx_ant_cmd = {\n\t\t.valid = cpu_to_le32(valid_tx_ant),\n\t};\n\n\tIWL_DEBUG_FW(mvm, \"select valid tx ant: %u\\n\", valid_tx_ant);\n\treturn iwl_mvm_send_cmd_pdu(mvm, TX_ANT_CONFIGURATION_CMD, 0,\n\t\t\t\t    sizeof(tx_ant_cmd), &tx_ant_cmd);\n}\n\nstatic int iwl_send_rss_cfg_cmd(struct iwl_mvm *mvm)\n{\n\tint i;\n\tstruct iwl_rss_config_cmd cmd = {\n\t\t.flags = cpu_to_le32(IWL_RSS_ENABLE),\n\t\t.hash_mask = BIT(IWL_RSS_HASH_TYPE_IPV4_TCP) |\n\t\t\t     BIT(IWL_RSS_HASH_TYPE_IPV4_UDP) |\n\t\t\t     BIT(IWL_RSS_HASH_TYPE_IPV4_PAYLOAD) |\n\t\t\t     BIT(IWL_RSS_HASH_TYPE_IPV6_TCP) |\n\t\t\t     BIT(IWL_RSS_HASH_TYPE_IPV6_UDP) |\n\t\t\t     BIT(IWL_RSS_HASH_TYPE_IPV6_PAYLOAD),\n\t};\n\n\tif (mvm->trans->num_rx_queues == 1)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(cmd.indirection_table); i++)\n\t\tcmd.indirection_table[i] =\n\t\t\t1 + (i % (mvm->trans->num_rx_queues - 1));\n\tnetdev_rss_key_fill(cmd.secret_key, sizeof(cmd.secret_key));\n\n\treturn iwl_mvm_send_cmd_pdu(mvm, RSS_CONFIG_CMD, 0, sizeof(cmd), &cmd);\n}\n\nstatic int iwl_mvm_send_dqa_cmd(struct iwl_mvm *mvm)\n{\n\tstruct iwl_dqa_enable_cmd dqa_cmd = {\n\t\t.cmd_queue = cpu_to_le32(IWL_MVM_DQA_CMD_QUEUE),\n\t};\n\tu32 cmd_id = WIDE_ID(DATA_PATH_GROUP, DQA_ENABLE_CMD);\n\tint ret;\n\n\tret = iwl_mvm_send_cmd_pdu(mvm, cmd_id, 0, sizeof(dqa_cmd), &dqa_cmd);\n\tif (ret)\n\t\tIWL_ERR(mvm, \"Failed to send DQA enabling command: %d\\n\", ret);\n\telse\n\t\tIWL_DEBUG_FW(mvm, \"Working in DQA mode\\n\");\n\n\treturn ret;\n}\n\nvoid iwl_mvm_mfu_assert_dump_notif(struct iwl_mvm *mvm,\n\t\t\t\t   struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_mfu_assert_dump_notif *mfu_dump_notif = (void *)pkt->data;\n\t__le32 *dump_data = mfu_dump_notif->data;\n\tint n_words = le32_to_cpu(mfu_dump_notif->data_size) / sizeof(__le32);\n\tint i;\n\n\tif (mfu_dump_notif->index_num == 0)\n\t\tIWL_INFO(mvm, \"MFUART assert id 0x%x occurred\\n\",\n\t\t\t le32_to_cpu(mfu_dump_notif->assert_id));\n\n\tfor (i = 0; i < n_words; i++)\n\t\tIWL_DEBUG_INFO(mvm,\n\t\t\t       \"MFUART assert dump, dword %u: 0x%08x\\n\",\n\t\t\t       le16_to_cpu(mfu_dump_notif->index_num) *\n\t\t\t       n_words + i,\n\t\t\t       le32_to_cpu(dump_data[i]));\n}\n\nstatic bool iwl_alive_fn(struct iwl_notif_wait_data *notif_wait,\n\t\t\t struct iwl_rx_packet *pkt, void *data)\n{\n\tunsigned int pkt_len = iwl_rx_packet_payload_len(pkt);\n\tstruct iwl_mvm *mvm =\n\t\tcontainer_of(notif_wait, struct iwl_mvm, notif_wait);\n\tstruct iwl_mvm_alive_data *alive_data = data;\n\tstruct iwl_umac_alive *umac;\n\tstruct iwl_lmac_alive *lmac1;\n\tstruct iwl_lmac_alive *lmac2 = NULL;\n\tu16 status;\n\tu32 lmac_error_event_table, umac_error_table;\n\tu32 version = iwl_fw_lookup_notif_ver(mvm->fw, LEGACY_GROUP,\n\t\t\t\t\t      UCODE_ALIVE_NTFY, 0);\n\tu32 i;\n\n\n\tif (version == 6) {\n\t\tstruct iwl_alive_ntf_v6 *palive;\n\n\t\tif (pkt_len < sizeof(*palive))\n\t\t\treturn false;\n\n\t\tpalive = (void *)pkt->data;\n\t\tmvm->trans->dbg.imr_data.imr_enable =\n\t\t\tle32_to_cpu(palive->imr.enabled);\n\t\tmvm->trans->dbg.imr_data.imr_size =\n\t\t\tle32_to_cpu(palive->imr.size);\n\t\tmvm->trans->dbg.imr_data.imr2sram_remainbyte =\n\t\t\tmvm->trans->dbg.imr_data.imr_size;\n\t\tmvm->trans->dbg.imr_data.imr_base_addr =\n\t\t\tpalive->imr.base_addr;\n\t\tmvm->trans->dbg.imr_data.imr_curr_addr =\n\t\t\tle64_to_cpu(mvm->trans->dbg.imr_data.imr_base_addr);\n\t\tIWL_DEBUG_FW(mvm, \"IMR Enabled: 0x0%x  size 0x0%x Address 0x%016llx\\n\",\n\t\t\t     mvm->trans->dbg.imr_data.imr_enable,\n\t\t\t     mvm->trans->dbg.imr_data.imr_size,\n\t\t\t     le64_to_cpu(mvm->trans->dbg.imr_data.imr_base_addr));\n\n\t\tif (!mvm->trans->dbg.imr_data.imr_enable) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(mvm->trans->dbg.active_regions); i++) {\n\t\t\t\tstruct iwl_ucode_tlv *reg_tlv;\n\t\t\t\tstruct iwl_fw_ini_region_tlv *reg;\n\n\t\t\t\treg_tlv = mvm->trans->dbg.active_regions[i];\n\t\t\t\tif (!reg_tlv)\n\t\t\t\t\tcontinue;\n\n\t\t\t\treg = (void *)reg_tlv->data;\n\t\t\t\t \n\t\t\t\tif (reg->type == IWL_FW_INI_REGION_DRAM_IMR) {\n\t\t\t\t\tmvm->trans->dbg.unsupported_region_msk |= BIT(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (version >= 5) {\n\t\tstruct iwl_alive_ntf_v5 *palive;\n\n\t\tif (pkt_len < sizeof(*palive))\n\t\t\treturn false;\n\n\t\tpalive = (void *)pkt->data;\n\t\tumac = &palive->umac_data;\n\t\tlmac1 = &palive->lmac_data[0];\n\t\tlmac2 = &palive->lmac_data[1];\n\t\tstatus = le16_to_cpu(palive->status);\n\n\t\tmvm->trans->sku_id[0] = le32_to_cpu(palive->sku_id.data[0]);\n\t\tmvm->trans->sku_id[1] = le32_to_cpu(palive->sku_id.data[1]);\n\t\tmvm->trans->sku_id[2] = le32_to_cpu(palive->sku_id.data[2]);\n\n\t\tIWL_DEBUG_FW(mvm, \"Got sku_id: 0x0%x 0x0%x 0x0%x\\n\",\n\t\t\t     mvm->trans->sku_id[0],\n\t\t\t     mvm->trans->sku_id[1],\n\t\t\t     mvm->trans->sku_id[2]);\n\t} else if (iwl_rx_packet_payload_len(pkt) == sizeof(struct iwl_alive_ntf_v4)) {\n\t\tstruct iwl_alive_ntf_v4 *palive;\n\n\t\tif (pkt_len < sizeof(*palive))\n\t\t\treturn false;\n\n\t\tpalive = (void *)pkt->data;\n\t\tumac = &palive->umac_data;\n\t\tlmac1 = &palive->lmac_data[0];\n\t\tlmac2 = &palive->lmac_data[1];\n\t\tstatus = le16_to_cpu(palive->status);\n\t} else if (iwl_rx_packet_payload_len(pkt) ==\n\t\t   sizeof(struct iwl_alive_ntf_v3)) {\n\t\tstruct iwl_alive_ntf_v3 *palive3;\n\n\t\tif (pkt_len < sizeof(*palive3))\n\t\t\treturn false;\n\n\t\tpalive3 = (void *)pkt->data;\n\t\tumac = &palive3->umac_data;\n\t\tlmac1 = &palive3->lmac_data;\n\t\tstatus = le16_to_cpu(palive3->status);\n\t} else {\n\t\tWARN(1, \"unsupported alive notification (size %d)\\n\",\n\t\t     iwl_rx_packet_payload_len(pkt));\n\t\t \n\t\treturn false;\n\t}\n\n\tlmac_error_event_table =\n\t\tle32_to_cpu(lmac1->dbg_ptrs.error_event_table_ptr);\n\tiwl_fw_lmac1_set_alive_err_table(mvm->trans, lmac_error_event_table);\n\n\tif (lmac2)\n\t\tmvm->trans->dbg.lmac_error_event_table[1] =\n\t\t\tle32_to_cpu(lmac2->dbg_ptrs.error_event_table_ptr);\n\n\tumac_error_table = le32_to_cpu(umac->dbg_ptrs.error_info_addr) &\n\t\t\t\t\t\t\t~FW_ADDR_CACHE_CONTROL;\n\n\tif (umac_error_table) {\n\t\tif (umac_error_table >=\n\t\t    mvm->trans->cfg->min_umac_error_event_table) {\n\t\t\tiwl_fw_umac_set_alive_err_table(mvm->trans,\n\t\t\t\t\t\t\tumac_error_table);\n\t\t} else {\n\t\t\tIWL_ERR(mvm,\n\t\t\t\t\"Not valid error log pointer 0x%08X for %s uCode\\n\",\n\t\t\t\tumac_error_table,\n\t\t\t\t(mvm->fwrt.cur_fw_img == IWL_UCODE_INIT) ?\n\t\t\t\t\"Init\" : \"RT\");\n\t\t}\n\t}\n\n\talive_data->scd_base_addr = le32_to_cpu(lmac1->dbg_ptrs.scd_base_ptr);\n\talive_data->valid = status == IWL_ALIVE_STATUS_OK;\n\n\tIWL_DEBUG_FW(mvm,\n\t\t     \"Alive ucode status 0x%04x revision 0x%01X 0x%01X\\n\",\n\t\t     status, lmac1->ver_type, lmac1->ver_subtype);\n\n\tif (lmac2)\n\t\tIWL_DEBUG_FW(mvm, \"Alive ucode CDB\\n\");\n\n\tIWL_DEBUG_FW(mvm,\n\t\t     \"UMAC version: Major - 0x%x, Minor - 0x%x\\n\",\n\t\t     le32_to_cpu(umac->umac_major),\n\t\t     le32_to_cpu(umac->umac_minor));\n\n\tiwl_fwrt_update_fw_versions(&mvm->fwrt, lmac1, umac);\n\n\treturn true;\n}\n\nstatic bool iwl_wait_init_complete(struct iwl_notif_wait_data *notif_wait,\n\t\t\t\t   struct iwl_rx_packet *pkt, void *data)\n{\n\tWARN_ON(pkt->hdr.cmd != INIT_COMPLETE_NOTIF);\n\n\treturn true;\n}\n\nstatic bool iwl_wait_phy_db_entry(struct iwl_notif_wait_data *notif_wait,\n\t\t\t\t  struct iwl_rx_packet *pkt, void *data)\n{\n\tstruct iwl_phy_db *phy_db = data;\n\n\tif (pkt->hdr.cmd != CALIB_RES_NOTIF_PHY_DB) {\n\t\tWARN_ON(pkt->hdr.cmd != INIT_COMPLETE_NOTIF);\n\t\treturn true;\n\t}\n\n\tWARN_ON(iwl_phy_db_set_section(phy_db, pkt));\n\n\treturn false;\n}\n\nstatic void iwl_mvm_print_pd_notification(struct iwl_mvm *mvm)\n{\n#define IWL_FW_PRINT_REG_INFO(reg_name) \\\n\tIWL_ERR(mvm, #reg_name \": 0x%x\\n\", iwl_read_umac_prph(trans, reg_name))\n\n\tstruct iwl_trans *trans = mvm->trans;\n\tenum iwl_device_family device_family = trans->trans_cfg->device_family;\n\n\tif (device_family < IWL_DEVICE_FAMILY_8000)\n\t\treturn;\n\n\tif (device_family <= IWL_DEVICE_FAMILY_9000)\n\t\tIWL_FW_PRINT_REG_INFO(WFPM_ARC1_PD_NOTIFICATION);\n\telse\n\t\tIWL_FW_PRINT_REG_INFO(WFPM_LMAC1_PD_NOTIFICATION);\n\n\tIWL_FW_PRINT_REG_INFO(HPM_SECONDARY_DEVICE_STATE);\n\n\t \n\tIWL_FW_PRINT_REG_INFO(WFPM_MAC_OTP_CFG7_ADDR);\n\tIWL_FW_PRINT_REG_INFO(WFPM_MAC_OTP_CFG7_DATA);\n}\n\nstatic int iwl_mvm_load_ucode_wait_alive(struct iwl_mvm *mvm,\n\t\t\t\t\t enum iwl_ucode_type ucode_type)\n{\n\tstruct iwl_notification_wait alive_wait;\n\tstruct iwl_mvm_alive_data alive_data = {};\n\tconst struct fw_img *fw;\n\tint ret;\n\tenum iwl_ucode_type old_type = mvm->fwrt.cur_fw_img;\n\tstatic const u16 alive_cmd[] = { UCODE_ALIVE_NTFY };\n\tbool run_in_rfkill =\n\t\tucode_type == IWL_UCODE_INIT || iwl_mvm_has_unified_ucode(mvm);\n\tu8 count;\n\tstruct iwl_pc_data *pc_data;\n\n\tif (ucode_type == IWL_UCODE_REGULAR &&\n\t    iwl_fw_dbg_conf_usniffer(mvm->fw, FW_DBG_START_FROM_ALIVE) &&\n\t    !(fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t  IWL_UCODE_TLV_CAPA_USNIFFER_UNIFIED)))\n\t\tfw = iwl_get_ucode_image(mvm->fw, IWL_UCODE_REGULAR_USNIFFER);\n\telse\n\t\tfw = iwl_get_ucode_image(mvm->fw, ucode_type);\n\tif (WARN_ON(!fw))\n\t\treturn -EINVAL;\n\tiwl_fw_set_current_image(&mvm->fwrt, ucode_type);\n\tclear_bit(IWL_MVM_STATUS_FIRMWARE_RUNNING, &mvm->status);\n\n\tiwl_init_notification_wait(&mvm->notif_wait, &alive_wait,\n\t\t\t\t   alive_cmd, ARRAY_SIZE(alive_cmd),\n\t\t\t\t   iwl_alive_fn, &alive_data);\n\n\t \n\tret = iwl_trans_start_fw(mvm->trans, fw, run_in_rfkill);\n\tif (ret) {\n\t\tiwl_fw_set_current_image(&mvm->fwrt, old_type);\n\t\tiwl_remove_notification(&mvm->notif_wait, &alive_wait);\n\t\treturn ret;\n\t}\n\n\t \n\tret = iwl_wait_notification(&mvm->notif_wait, &alive_wait,\n\t\t\t\t    MVM_UCODE_ALIVE_TIMEOUT);\n\n\tif (mvm->trans->trans_cfg->device_family ==\n\t    IWL_DEVICE_FAMILY_AX210) {\n\t\t \n\t\tIWL_INFO(mvm, \"WFPM_UMAC_PD_NOTIFICATION: 0x%x\\n\",\n\t\t\t iwl_read_umac_prph(mvm->trans, WFPM_ARC1_PD_NOTIFICATION));\n\t\tIWL_INFO(mvm, \"WFPM_LMAC2_PD_NOTIFICATION: 0x%x\\n\",\n\t\t\t iwl_read_umac_prph(mvm->trans, WFPM_LMAC2_PD_NOTIFICATION));\n\t\tIWL_INFO(mvm, \"WFPM_AUTH_KEY_0: 0x%x\\n\",\n\t\t\t iwl_read_umac_prph(mvm->trans, SB_MODIFY_CFG_FLAG));\n\t\tIWL_INFO(mvm, \"CNVI_SCU_SEQ_DATA_DW9: 0x%x\\n\",\n\t\t\t iwl_read_prph(mvm->trans, CNVI_SCU_SEQ_DATA_DW9));\n\t}\n\n\tif (ret) {\n\t\tstruct iwl_trans *trans = mvm->trans;\n\n\t\t \n\t\tif (trans->trans_cfg->device_family >=\n\t\t\t\t\tIWL_DEVICE_FAMILY_22000) {\n\t\t\tIWL_ERR(mvm,\n\t\t\t\t\"SecBoot CPU1 Status: 0x%x, CPU2 Status: 0x%x\\n\",\n\t\t\t\tiwl_read_umac_prph(trans, UMAG_SB_CPU_1_STATUS),\n\t\t\t\tiwl_read_umac_prph(trans,\n\t\t\t\t\t\t   UMAG_SB_CPU_2_STATUS));\n\t\t} else if (trans->trans_cfg->device_family >=\n\t\t\t   IWL_DEVICE_FAMILY_8000) {\n\t\t\tIWL_ERR(mvm,\n\t\t\t\t\"SecBoot CPU1 Status: 0x%x, CPU2 Status: 0x%x\\n\",\n\t\t\t\tiwl_read_prph(trans, SB_CPU_1_STATUS),\n\t\t\t\tiwl_read_prph(trans, SB_CPU_2_STATUS));\n\t\t}\n\n\t\tiwl_mvm_print_pd_notification(mvm);\n\n\t\t \n\t\tif (trans->trans_cfg->device_family >=\n\t\t\t\t\tIWL_DEVICE_FAMILY_22000) {\n\t\t\tpc_data = trans->dbg.pc_data;\n\t\t\tfor (count = 0; count < trans->dbg.num_pc;\n\t\t\t     count++, pc_data++)\n\t\t\t\tIWL_ERR(mvm, \"%s: 0x%x\\n\",\n\t\t\t\t\tpc_data->pc_name,\n\t\t\t\t\tpc_data->pc_address);\n\t\t} else if (trans->trans_cfg->device_family >=\n\t\t\t\t\tIWL_DEVICE_FAMILY_9000) {\n\t\t\tIWL_ERR(mvm, \"UMAC PC: 0x%x\\n\",\n\t\t\t\tiwl_read_umac_prph(trans,\n\t\t\t\t\t\t   UREG_UMAC_CURRENT_PC));\n\t\t\tIWL_ERR(mvm, \"LMAC PC: 0x%x\\n\",\n\t\t\t\tiwl_read_umac_prph(trans,\n\t\t\t\t\t\t   UREG_LMAC1_CURRENT_PC));\n\t\t\tif (iwl_mvm_is_cdb_supported(mvm))\n\t\t\t\tIWL_ERR(mvm, \"LMAC2 PC: 0x%x\\n\",\n\t\t\t\t\tiwl_read_umac_prph(trans,\n\t\t\t\t\t\tUREG_LMAC2_CURRENT_PC));\n\t\t}\n\n\t\tif (ret == -ETIMEDOUT && !mvm->pldr_sync)\n\t\t\tiwl_fw_dbg_error_collect(&mvm->fwrt,\n\t\t\t\t\t\t FW_DBG_TRIGGER_ALIVE_TIMEOUT);\n\n\t\tiwl_fw_set_current_image(&mvm->fwrt, old_type);\n\t\treturn ret;\n\t}\n\n\tif (!alive_data.valid) {\n\t\tIWL_ERR(mvm, \"Loaded ucode is not valid!\\n\");\n\t\tiwl_fw_set_current_image(&mvm->fwrt, old_type);\n\t\treturn -EIO;\n\t}\n\n\t \n\tiwl_mei_alive_notif(true);\n\n\tret = iwl_pnvm_load(mvm->trans, &mvm->notif_wait,\n\t\t\t    &mvm->fw->ucode_capa);\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"Timeout waiting for PNVM load!\\n\");\n\t\tiwl_fw_set_current_image(&mvm->fwrt, old_type);\n\t\treturn ret;\n\t}\n\n\tiwl_trans_fw_alive(mvm->trans, alive_data.scd_base_addr);\n\n\t \n\n\tmemset(&mvm->queue_info, 0, sizeof(mvm->queue_info));\n\t \n\tmvm->queue_info[IWL_MVM_DQA_CMD_QUEUE].tid_bitmap =\n\t\tBIT(IWL_MAX_TID_COUNT + 2);\n\n\tset_bit(IWL_MVM_STATUS_FIRMWARE_RUNNING, &mvm->status);\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tiwl_fw_set_dbg_rec_on(&mvm->fwrt);\n#endif\n\n\t \n\tcfg80211_bss_flush(mvm->hw->wiphy);\n\n\treturn 0;\n}\n\nstatic void iwl_mvm_phy_filter_init(struct iwl_mvm *mvm,\n\t\t\t\t    struct iwl_phy_specific_cfg *phy_filters)\n{\n#ifdef CONFIG_ACPI\n\t*phy_filters = mvm->phy_filters;\n#endif  \n}\n\n#if defined(CONFIG_ACPI) && defined(CONFIG_EFI)\nstatic int iwl_mvm_sgom_init(struct iwl_mvm *mvm)\n{\n\tu8 cmd_ver;\n\tint ret;\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = WIDE_ID(REGULATORY_AND_NVM_GROUP,\n\t\t\t      SAR_OFFSET_MAPPING_TABLE_CMD),\n\t\t.flags = 0,\n\t\t.data[0] = &mvm->fwrt.sgom_table,\n\t\t.len[0] =  sizeof(mvm->fwrt.sgom_table),\n\t\t.dataflags[0] = IWL_HCMD_DFL_NOCOPY,\n\t};\n\n\tif (!mvm->fwrt.sgom_enabled) {\n\t\tIWL_DEBUG_RADIO(mvm, \"SGOM table is disabled\\n\");\n\t\treturn 0;\n\t}\n\n\tcmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw, cmd.id,\n\t\t\t\t\tIWL_FW_CMD_VER_UNKNOWN);\n\n\tif (cmd_ver != 2) {\n\t\tIWL_DEBUG_RADIO(mvm, \"command version is unsupported. version = %d\\n\",\n\t\t\t\tcmd_ver);\n\t\treturn 0;\n\t}\n\n\tret = iwl_mvm_send_cmd(mvm, &cmd);\n\tif (ret < 0)\n\t\tIWL_ERR(mvm, \"failed to send SAR_OFFSET_MAPPING_CMD (%d)\\n\", ret);\n\n\treturn ret;\n}\n#else\n\nstatic int iwl_mvm_sgom_init(struct iwl_mvm *mvm)\n{\n\treturn 0;\n}\n#endif\n\nstatic int iwl_send_phy_cfg_cmd(struct iwl_mvm *mvm)\n{\n\tu32 cmd_id = PHY_CONFIGURATION_CMD;\n\tstruct iwl_phy_cfg_cmd_v3 phy_cfg_cmd;\n\tenum iwl_ucode_type ucode_type = mvm->fwrt.cur_fw_img;\n\tu8 cmd_ver;\n\tsize_t cmd_size;\n\n\tif (iwl_mvm_has_unified_ucode(mvm) &&\n\t    !mvm->trans->cfg->tx_with_siso_diversity)\n\t\treturn 0;\n\n\tif (mvm->trans->cfg->tx_with_siso_diversity) {\n\t\t \n\t\tphy_cfg_cmd.phy_cfg =\n\t\t\tcpu_to_le32(FW_PHY_CFG_CHAIN_SAD_ENABLED);\n\t}\n\n\t \n\tphy_cfg_cmd.phy_cfg = cpu_to_le32(iwl_mvm_get_phy_config(mvm));\n\n\t \n\tphy_cfg_cmd.phy_cfg |=\n\t\tcpu_to_le32(mvm->trans->trans_cfg->extra_phy_cfg_flags);\n\n\tphy_cfg_cmd.calib_control.event_trigger =\n\t\tmvm->fw->default_calib[ucode_type].event_trigger;\n\tphy_cfg_cmd.calib_control.flow_trigger =\n\t\tmvm->fw->default_calib[ucode_type].flow_trigger;\n\n\tcmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw, cmd_id,\n\t\t\t\t\tIWL_FW_CMD_VER_UNKNOWN);\n\tif (cmd_ver >= 3)\n\t\tiwl_mvm_phy_filter_init(mvm, &phy_cfg_cmd.phy_specific_cfg);\n\n\tIWL_DEBUG_INFO(mvm, \"Sending Phy CFG command: 0x%x\\n\",\n\t\t       phy_cfg_cmd.phy_cfg);\n\tcmd_size = (cmd_ver == 3) ? sizeof(struct iwl_phy_cfg_cmd_v3) :\n\t\t\t\t    sizeof(struct iwl_phy_cfg_cmd_v1);\n\treturn iwl_mvm_send_cmd_pdu(mvm, cmd_id, 0, cmd_size, &phy_cfg_cmd);\n}\n\nstatic int iwl_run_unified_mvm_ucode(struct iwl_mvm *mvm)\n{\n\tstruct iwl_notification_wait init_wait;\n\tstruct iwl_nvm_access_complete_cmd nvm_complete = {};\n\tstruct iwl_init_extended_cfg_cmd init_cfg = {\n\t\t.init_flags = cpu_to_le32(BIT(IWL_INIT_NVM)),\n\t};\n\tstatic const u16 init_complete[] = {\n\t\tINIT_COMPLETE_NOTIF,\n\t};\n\tint ret;\n\n\tif (mvm->trans->cfg->tx_with_siso_diversity)\n\t\tinit_cfg.init_flags |= cpu_to_le32(BIT(IWL_INIT_PHY));\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tmvm->rfkill_safe_init_done = false;\n\n\tiwl_init_notification_wait(&mvm->notif_wait,\n\t\t\t\t   &init_wait,\n\t\t\t\t   init_complete,\n\t\t\t\t   ARRAY_SIZE(init_complete),\n\t\t\t\t   iwl_wait_init_complete,\n\t\t\t\t   NULL);\n\n\tiwl_dbg_tlv_time_point(&mvm->fwrt, IWL_FW_INI_TIME_POINT_EARLY, NULL);\n\n\t \n\tret = iwl_mvm_load_ucode_wait_alive(mvm, IWL_UCODE_REGULAR);\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"Failed to start RT ucode: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\tiwl_dbg_tlv_time_point(&mvm->fwrt, IWL_FW_INI_TIME_POINT_AFTER_ALIVE,\n\t\t\t       NULL);\n\n\t \n\tret = iwl_mvm_send_cmd_pdu(mvm, WIDE_ID(SYSTEM_GROUP,\n\t\t\t\t\t\tINIT_EXTENDED_CFG_CMD),\n\t\t\t\t   CMD_SEND_IN_RFKILL,\n\t\t\t\t   sizeof(init_cfg), &init_cfg);\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"Failed to run init config command: %d\\n\",\n\t\t\tret);\n\t\tgoto error;\n\t}\n\n\t \n\tif (mvm->nvm_file_name) {\n\t\tret = iwl_read_external_nvm(mvm->trans, mvm->nvm_file_name,\n\t\t\t\t\t    mvm->nvm_sections);\n\t\tif (ret)\n\t\t\tgoto error;\n\t\tret = iwl_mvm_load_nvm_to_nic(mvm);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tif (IWL_MVM_PARSE_NVM && !mvm->nvm_data) {\n\t\tret = iwl_nvm_init(mvm);\n\t\tif (ret) {\n\t\t\tIWL_ERR(mvm, \"Failed to read NVM: %d\\n\", ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tret = iwl_mvm_send_cmd_pdu(mvm, WIDE_ID(REGULATORY_AND_NVM_GROUP,\n\t\t\t\t\t\tNVM_ACCESS_COMPLETE),\n\t\t\t\t   CMD_SEND_IN_RFKILL,\n\t\t\t\t   sizeof(nvm_complete), &nvm_complete);\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"Failed to run complete NVM access: %d\\n\",\n\t\t\tret);\n\t\tgoto error;\n\t}\n\n\tret = iwl_send_phy_cfg_cmd(mvm);\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"Failed to run PHY configuration: %d\\n\",\n\t\t\tret);\n\t\tgoto error;\n\t}\n\n\t \n\tret = iwl_wait_notification(&mvm->notif_wait, &init_wait,\n\t\t\t\t    MVM_UCODE_ALIVE_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!IWL_MVM_PARSE_NVM && !mvm->nvm_data) {\n\t\tmvm->nvm_data = iwl_get_nvm(mvm->trans, mvm->fw);\n\t\tif (IS_ERR(mvm->nvm_data)) {\n\t\t\tret = PTR_ERR(mvm->nvm_data);\n\t\t\tmvm->nvm_data = NULL;\n\t\t\tIWL_ERR(mvm, \"Failed to read NVM: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tmvm->rfkill_safe_init_done = true;\n\n\treturn 0;\n\nerror:\n\tiwl_remove_notification(&mvm->notif_wait, &init_wait);\n\treturn ret;\n}\n\nint iwl_run_init_mvm_ucode(struct iwl_mvm *mvm)\n{\n\tstruct iwl_notification_wait calib_wait;\n\tstatic const u16 init_complete[] = {\n\t\tINIT_COMPLETE_NOTIF,\n\t\tCALIB_RES_NOTIF_PHY_DB\n\t};\n\tint ret;\n\n\tif (iwl_mvm_has_unified_ucode(mvm))\n\t\treturn iwl_run_unified_mvm_ucode(mvm);\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tmvm->rfkill_safe_init_done = false;\n\n\tiwl_init_notification_wait(&mvm->notif_wait,\n\t\t\t\t   &calib_wait,\n\t\t\t\t   init_complete,\n\t\t\t\t   ARRAY_SIZE(init_complete),\n\t\t\t\t   iwl_wait_phy_db_entry,\n\t\t\t\t   mvm->phy_db);\n\n\tiwl_dbg_tlv_time_point(&mvm->fwrt, IWL_FW_INI_TIME_POINT_EARLY, NULL);\n\n\t \n\tret = iwl_mvm_load_ucode_wait_alive(mvm, IWL_UCODE_INIT);\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"Failed to start INIT ucode: %d\\n\", ret);\n\t\tgoto remove_notif;\n\t}\n\n\tif (mvm->trans->trans_cfg->device_family < IWL_DEVICE_FAMILY_8000) {\n\t\tret = iwl_mvm_send_bt_init_conf(mvm);\n\t\tif (ret)\n\t\t\tgoto remove_notif;\n\t}\n\n\t \n\tif (!mvm->nvm_data) {\n\t\tret = iwl_nvm_init(mvm);\n\t\tif (ret) {\n\t\t\tIWL_ERR(mvm, \"Failed to read NVM: %d\\n\", ret);\n\t\t\tgoto remove_notif;\n\t\t}\n\t}\n\n\t \n\tif (mvm->nvm_file_name) {\n\t\tret = iwl_mvm_load_nvm_to_nic(mvm);\n\t\tif (ret)\n\t\t\tgoto remove_notif;\n\t}\n\n\tWARN_ONCE(mvm->nvm_data->nvm_version < mvm->trans->cfg->nvm_ver,\n\t\t  \"Too old NVM version (0x%0x, required = 0x%0x)\",\n\t\t  mvm->nvm_data->nvm_version, mvm->trans->cfg->nvm_ver);\n\n\t \n\tif (iwl_mvm_is_radio_hw_killed(mvm)) {\n\t\tIWL_DEBUG_RF_KILL(mvm,\n\t\t\t\t  \"jump over all phy activities due to RF kill\\n\");\n\t\tgoto remove_notif;\n\t}\n\n\tmvm->rfkill_safe_init_done = true;\n\n\t \n\tret = iwl_send_tx_ant_cfg(mvm, iwl_mvm_get_valid_tx_ant(mvm));\n\tif (ret)\n\t\tgoto remove_notif;\n\n\tret = iwl_send_phy_cfg_cmd(mvm);\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"Failed to run INIT calibrations: %d\\n\",\n\t\t\tret);\n\t\tgoto remove_notif;\n\t}\n\n\t \n\tret = iwl_wait_notification(&mvm->notif_wait, &calib_wait,\n\t\t\t\t    MVM_UCODE_CALIB_TIMEOUT);\n\tif (!ret)\n\t\tgoto out;\n\n\tif (iwl_mvm_is_radio_hw_killed(mvm)) {\n\t\tIWL_DEBUG_RF_KILL(mvm, \"RFKILL while calibrating.\\n\");\n\t\tret = 0;\n\t} else {\n\t\tIWL_ERR(mvm, \"Failed to run INIT calibrations: %d\\n\",\n\t\t\tret);\n\t}\n\n\tgoto out;\n\nremove_notif:\n\tiwl_remove_notification(&mvm->notif_wait, &calib_wait);\nout:\n\tmvm->rfkill_safe_init_done = false;\n\tif (iwlmvm_mod_params.init_dbg && !mvm->nvm_data) {\n\t\t \n\t\tmvm->nvm_data = kzalloc(sizeof(struct iwl_nvm_data) +\n\t\t\t\t\tsizeof(struct ieee80211_channel) +\n\t\t\t\t\tsizeof(struct ieee80211_rate),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!mvm->nvm_data)\n\t\t\treturn -ENOMEM;\n\t\tmvm->nvm_data->bands[0].channels = mvm->nvm_data->channels;\n\t\tmvm->nvm_data->bands[0].n_channels = 1;\n\t\tmvm->nvm_data->bands[0].n_bitrates = 1;\n\t\tmvm->nvm_data->bands[0].bitrates =\n\t\t\t(void *)(mvm->nvm_data->channels + 1);\n\t\tmvm->nvm_data->bands[0].bitrates->hw_value = 10;\n\t}\n\n\treturn ret;\n}\n\nstatic int iwl_mvm_config_ltr(struct iwl_mvm *mvm)\n{\n\tstruct iwl_ltr_config_cmd cmd = {\n\t\t.flags = cpu_to_le32(LTR_CFG_FLAG_FEATURE_ENABLE),\n\t};\n\n\tif (!mvm->trans->ltr_enabled)\n\t\treturn 0;\n\n\treturn iwl_mvm_send_cmd_pdu(mvm, LTR_CONFIG, 0,\n\t\t\t\t    sizeof(cmd), &cmd);\n}\n\n#ifdef CONFIG_ACPI\nint iwl_mvm_sar_select_profile(struct iwl_mvm *mvm, int prof_a, int prof_b)\n{\n\tu32 cmd_id = REDUCE_TX_POWER_CMD;\n\tstruct iwl_dev_tx_power_cmd cmd = {\n\t\t.common.set_mode = cpu_to_le32(IWL_TX_POWER_MODE_SET_CHAINS),\n\t};\n\t__le16 *per_chain;\n\tint ret;\n\tu16 len = 0;\n\tu32 n_subbands;\n\tu8 cmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw, cmd_id,\n\t\t\t\t\t   IWL_FW_CMD_VER_UNKNOWN);\n\tif (cmd_ver == 7) {\n\t\tlen = sizeof(cmd.v7);\n\t\tn_subbands = IWL_NUM_SUB_BANDS_V2;\n\t\tper_chain = cmd.v7.per_chain[0][0];\n\t\tcmd.v7.flags = cpu_to_le32(mvm->fwrt.reduced_power_flags);\n\t} else if (cmd_ver == 6) {\n\t\tlen = sizeof(cmd.v6);\n\t\tn_subbands = IWL_NUM_SUB_BANDS_V2;\n\t\tper_chain = cmd.v6.per_chain[0][0];\n\t} else if (fw_has_api(&mvm->fw->ucode_capa,\n\t\t\t      IWL_UCODE_TLV_API_REDUCE_TX_POWER)) {\n\t\tlen = sizeof(cmd.v5);\n\t\tn_subbands = IWL_NUM_SUB_BANDS_V1;\n\t\tper_chain = cmd.v5.per_chain[0][0];\n\t} else if (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t       IWL_UCODE_TLV_CAPA_TX_POWER_ACK)) {\n\t\tlen = sizeof(cmd.v4);\n\t\tn_subbands = IWL_NUM_SUB_BANDS_V1;\n\t\tper_chain = cmd.v4.per_chain[0][0];\n\t} else {\n\t\tlen = sizeof(cmd.v3);\n\t\tn_subbands = IWL_NUM_SUB_BANDS_V1;\n\t\tper_chain = cmd.v3.per_chain[0][0];\n\t}\n\n\t \n\tlen += sizeof(cmd.common);\n\n\tret = iwl_sar_select_profile(&mvm->fwrt, per_chain,\n\t\t\t\t     IWL_NUM_CHAIN_TABLES,\n\t\t\t\t     n_subbands, prof_a, prof_b);\n\n\t \n\tif (ret)\n\t\treturn ret;\n\n\tiwl_mei_set_power_limit(per_chain);\n\n\tIWL_DEBUG_RADIO(mvm, \"Sending REDUCE_TX_POWER_CMD per chain\\n\");\n\treturn iwl_mvm_send_cmd_pdu(mvm, cmd_id, 0, len, &cmd);\n}\n\nint iwl_mvm_get_sar_geo_profile(struct iwl_mvm *mvm)\n{\n\tunion iwl_geo_tx_power_profiles_cmd geo_tx_cmd;\n\tstruct iwl_geo_tx_power_profiles_resp *resp;\n\tu16 len;\n\tint ret;\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = WIDE_ID(PHY_OPS_GROUP, PER_CHAIN_LIMIT_OFFSET_CMD),\n\t\t.flags = CMD_WANT_SKB,\n\t\t.data = { &geo_tx_cmd },\n\t};\n\tu8 cmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw, cmd.id,\n\t\t\t\t\t   IWL_FW_CMD_VER_UNKNOWN);\n\n\t \n\tgeo_tx_cmd.v1.ops =\n\t\tcpu_to_le32(IWL_PER_CHAIN_OFFSET_GET_CURRENT_TABLE);\n\n\tif (cmd_ver == 5)\n\t\tlen = sizeof(geo_tx_cmd.v5);\n\telse if (cmd_ver == 4)\n\t\tlen = sizeof(geo_tx_cmd.v4);\n\telse if (cmd_ver == 3)\n\t\tlen = sizeof(geo_tx_cmd.v3);\n\telse if (fw_has_api(&mvm->fwrt.fw->ucode_capa,\n\t\t\t    IWL_UCODE_TLV_API_SAR_TABLE_VER))\n\t\tlen = sizeof(geo_tx_cmd.v2);\n\telse\n\t\tlen = sizeof(geo_tx_cmd.v1);\n\n\tif (!iwl_sar_geo_support(&mvm->fwrt))\n\t\treturn -EOPNOTSUPP;\n\n\tcmd.len[0] = len;\n\n\tret = iwl_mvm_send_cmd(mvm, &cmd);\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"Failed to get geographic profile info %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tresp = (void *)cmd.resp_pkt->data;\n\tret = le32_to_cpu(resp->profile_idx);\n\n\tif (WARN_ON(ret > ACPI_NUM_GEO_PROFILES_REV3))\n\t\tret = -EIO;\n\n\tiwl_free_resp(&cmd);\n\treturn ret;\n}\n\nstatic int iwl_mvm_sar_geo_init(struct iwl_mvm *mvm)\n{\n\tu32 cmd_id = WIDE_ID(PHY_OPS_GROUP, PER_CHAIN_LIMIT_OFFSET_CMD);\n\tunion iwl_geo_tx_power_profiles_cmd cmd;\n\tu16 len;\n\tu32 n_bands;\n\tu32 n_profiles;\n\tu32 sk = 0;\n\tint ret;\n\tu8 cmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw, cmd_id,\n\t\t\t\t\t   IWL_FW_CMD_VER_UNKNOWN);\n\n\tBUILD_BUG_ON(offsetof(struct iwl_geo_tx_power_profiles_cmd_v1, ops) !=\n\t\t     offsetof(struct iwl_geo_tx_power_profiles_cmd_v2, ops) ||\n\t\t     offsetof(struct iwl_geo_tx_power_profiles_cmd_v2, ops) !=\n\t\t     offsetof(struct iwl_geo_tx_power_profiles_cmd_v3, ops) ||\n\t\t     offsetof(struct iwl_geo_tx_power_profiles_cmd_v3, ops) !=\n\t\t     offsetof(struct iwl_geo_tx_power_profiles_cmd_v4, ops) ||\n\t\t     offsetof(struct iwl_geo_tx_power_profiles_cmd_v4, ops) !=\n\t\t     offsetof(struct iwl_geo_tx_power_profiles_cmd_v5, ops));\n\n\t \n\tcmd.v1.ops = cpu_to_le32(IWL_PER_CHAIN_OFFSET_SET_TABLES);\n\n\tif (cmd_ver == 5) {\n\t\tlen = sizeof(cmd.v5);\n\t\tn_bands = ARRAY_SIZE(cmd.v5.table[0]);\n\t\tn_profiles = ACPI_NUM_GEO_PROFILES_REV3;\n\t} else if (cmd_ver == 4) {\n\t\tlen = sizeof(cmd.v4);\n\t\tn_bands = ARRAY_SIZE(cmd.v4.table[0]);\n\t\tn_profiles = ACPI_NUM_GEO_PROFILES_REV3;\n\t} else if (cmd_ver == 3) {\n\t\tlen = sizeof(cmd.v3);\n\t\tn_bands = ARRAY_SIZE(cmd.v3.table[0]);\n\t\tn_profiles = ACPI_NUM_GEO_PROFILES;\n\t} else if (fw_has_api(&mvm->fwrt.fw->ucode_capa,\n\t\t\t      IWL_UCODE_TLV_API_SAR_TABLE_VER)) {\n\t\tlen = sizeof(cmd.v2);\n\t\tn_bands = ARRAY_SIZE(cmd.v2.table[0]);\n\t\tn_profiles = ACPI_NUM_GEO_PROFILES;\n\t} else {\n\t\tlen = sizeof(cmd.v1);\n\t\tn_bands = ARRAY_SIZE(cmd.v1.table[0]);\n\t\tn_profiles = ACPI_NUM_GEO_PROFILES;\n\t}\n\n\tBUILD_BUG_ON(offsetof(struct iwl_geo_tx_power_profiles_cmd_v1, table) !=\n\t\t     offsetof(struct iwl_geo_tx_power_profiles_cmd_v2, table) ||\n\t\t     offsetof(struct iwl_geo_tx_power_profiles_cmd_v2, table) !=\n\t\t     offsetof(struct iwl_geo_tx_power_profiles_cmd_v3, table) ||\n\t\t     offsetof(struct iwl_geo_tx_power_profiles_cmd_v3, table) !=\n\t\t     offsetof(struct iwl_geo_tx_power_profiles_cmd_v4, table) ||\n\t\t     offsetof(struct iwl_geo_tx_power_profiles_cmd_v4, table) !=\n\t\t     offsetof(struct iwl_geo_tx_power_profiles_cmd_v5, table));\n\t \n\tret = iwl_sar_geo_init(&mvm->fwrt, &cmd.v1.table[0][0],\n\t\t\t       n_bands, n_profiles);\n\n\t \n\tif (ret)\n\t\treturn 0;\n\n\t \n\tif (mvm->fwrt.geo_rev == 1)\n\t\tsk = 1;\n\n\t \n\tif (cmd_ver == 5)\n\t\tcmd.v5.table_revision = cpu_to_le32(sk);\n\telse if (cmd_ver == 4)\n\t\tcmd.v4.table_revision = cpu_to_le32(sk);\n\telse if (cmd_ver == 3)\n\t\tcmd.v3.table_revision = cpu_to_le32(sk);\n\telse if (fw_has_api(&mvm->fwrt.fw->ucode_capa,\n\t\t\t    IWL_UCODE_TLV_API_SAR_TABLE_VER))\n\t\tcmd.v2.table_revision = cpu_to_le32(sk);\n\n\treturn iwl_mvm_send_cmd_pdu(mvm, cmd_id, 0, len, &cmd);\n}\n\nint iwl_mvm_ppag_send_cmd(struct iwl_mvm *mvm)\n{\n\tunion iwl_ppag_table_cmd cmd;\n\tint ret, cmd_size;\n\n\tret = iwl_read_ppag_table(&mvm->fwrt, &cmd, &cmd_size);\n\t \n\tif (ret < 0)\n\t\treturn 0;\n\n\tIWL_DEBUG_RADIO(mvm, \"Sending PER_PLATFORM_ANT_GAIN_CMD\\n\");\n\tret = iwl_mvm_send_cmd_pdu(mvm, WIDE_ID(PHY_OPS_GROUP,\n\t\t\t\t\t\tPER_PLATFORM_ANT_GAIN_CMD),\n\t\t\t\t   0, cmd_size, &cmd);\n\tif (ret < 0)\n\t\tIWL_ERR(mvm, \"failed to send PER_PLATFORM_ANT_GAIN_CMD (%d)\\n\",\n\t\t\tret);\n\n\treturn ret;\n}\n\nstatic int iwl_mvm_ppag_init(struct iwl_mvm *mvm)\n{\n\t \n\tif (!(iwl_acpi_is_ppag_approved(&mvm->fwrt)))\n\t\treturn 0;\n\n\treturn iwl_mvm_ppag_send_cmd(mvm);\n}\n\nstatic const struct dmi_system_id dmi_tas_approved_list[] = {\n\t{ .ident = \"HP\",\n\t  .matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t},\n\t},\n\t{ .ident = \"SAMSUNG\",\n\t  .matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"SAMSUNG ELECTRONICS CO., LTD\"),\n\t\t},\n\t},\n\t\t{ .ident = \"LENOVO\",\n\t  .matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t},\n\t},\n\t{ .ident = \"DELL\",\n\t  .matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t},\n\t},\n\t{ .ident = \"MSFT\",\n\t  .matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Microsoft Corporation\"),\n\t\t},\n\t},\n\t{ .ident = \"Acer\",\n\t  .matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t},\n\t},\n\t{ .ident = \"ASUS\",\n\t  .matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK COMPUTER INC.\"),\n\t\t},\n\t},\n\t{ .ident = \"MSI\",\n\t  .matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Micro-Star International Co., Ltd.\"),\n\t\t},\n\t},\n\t{ .ident = \"Honor\",\n\t  .matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HONOR\"),\n\t\t},\n\t},\n\t \n\t{}\n};\n\nbool iwl_mvm_is_vendor_in_approved_list(void)\n{\n\treturn dmi_check_system(dmi_tas_approved_list);\n}\n\nstatic bool iwl_mvm_add_to_tas_block_list(__le32 *list, __le32 *le_size, unsigned int mcc)\n{\n\tint i;\n\tu32 size = le32_to_cpu(*le_size);\n\n\t \n\tif (size >= IWL_TAS_BLOCK_LIST_MAX)\n\t\treturn false;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (list[i] == cpu_to_le32(mcc))\n\t\t\treturn true;\n\t}\n\n\tlist[size++] = cpu_to_le32(mcc);\n\t*le_size = cpu_to_le32(size);\n\treturn true;\n}\n\nstatic void iwl_mvm_tas_init(struct iwl_mvm *mvm)\n{\n\tu32 cmd_id = WIDE_ID(REGULATORY_AND_NVM_GROUP, TAS_CONFIG);\n\tint ret;\n\tunion iwl_tas_config_cmd cmd = {};\n\tint cmd_size, fw_ver;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(cmd.v3.block_list_array) <\n\t\t     APCI_WTAS_BLACK_LIST_MAX);\n\n\tif (!fw_has_capa(&mvm->fw->ucode_capa, IWL_UCODE_TLV_CAPA_TAS_CFG)) {\n\t\tIWL_DEBUG_RADIO(mvm, \"TAS not enabled in FW\\n\");\n\t\treturn;\n\t}\n\n\tfw_ver = iwl_fw_lookup_cmd_ver(mvm->fw, cmd_id,\n\t\t\t\t       IWL_FW_CMD_VER_UNKNOWN);\n\n\tret = iwl_acpi_get_tas(&mvm->fwrt, &cmd, fw_ver);\n\tif (ret < 0) {\n\t\tIWL_DEBUG_RADIO(mvm,\n\t\t\t\t\"TAS table invalid or unavailable. (%d)\\n\",\n\t\t\t\tret);\n\t\treturn;\n\t}\n\n\tif (ret == 0)\n\t\treturn;\n\n\tif (!iwl_mvm_is_vendor_in_approved_list()) {\n\t\tIWL_DEBUG_RADIO(mvm,\n\t\t\t\t\"System vendor '%s' is not in the approved list, disabling TAS in US and Canada.\\n\",\n\t\t\t\tdmi_get_system_info(DMI_SYS_VENDOR));\n\t\tif ((!iwl_mvm_add_to_tas_block_list(cmd.v4.block_list_array,\n\t\t\t\t\t\t    &cmd.v4.block_list_size,\n\t\t\t\t\t\t\tIWL_TAS_US_MCC)) ||\n\t\t    (!iwl_mvm_add_to_tas_block_list(cmd.v4.block_list_array,\n\t\t\t\t\t\t    &cmd.v4.block_list_size,\n\t\t\t\t\t\t\tIWL_TAS_CANADA_MCC))) {\n\t\t\tIWL_DEBUG_RADIO(mvm,\n\t\t\t\t\t\"Unable to add US/Canada to TAS block list, disabling TAS\\n\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tIWL_DEBUG_RADIO(mvm,\n\t\t\t\t\"System vendor '%s' is in the approved list.\\n\",\n\t\t\t\tdmi_get_system_info(DMI_SYS_VENDOR));\n\t}\n\n\t \n\tcmd_size = fw_ver < 3 ?\n\t\tsizeof(struct iwl_tas_config_cmd_v2) :\n\t\tsizeof(struct iwl_tas_config_cmd_v3);\n\n\tret = iwl_mvm_send_cmd_pdu(mvm, cmd_id, 0, cmd_size, &cmd);\n\tif (ret < 0)\n\t\tIWL_DEBUG_RADIO(mvm, \"failed to send TAS_CONFIG (%d)\\n\", ret);\n}\n\nstatic u8 iwl_mvm_eval_dsm_rfi(struct iwl_mvm *mvm)\n{\n\tu8 value;\n\tint ret = iwl_acpi_get_dsm_u8(mvm->fwrt.dev, 0, DSM_RFI_FUNC_ENABLE,\n\t\t\t\t      &iwl_rfi_guid, &value);\n\n\tif (ret < 0) {\n\t\tIWL_DEBUG_RADIO(mvm, \"Failed to get DSM RFI, ret=%d\\n\", ret);\n\n\t} else if (value >= DSM_VALUE_RFI_MAX) {\n\t\tIWL_DEBUG_RADIO(mvm, \"DSM RFI got invalid value, ret=%d\\n\",\n\t\t\t\tvalue);\n\n\t} else if (value == DSM_VALUE_RFI_ENABLE) {\n\t\tIWL_DEBUG_RADIO(mvm, \"DSM RFI is evaluated to enable\\n\");\n\t\treturn DSM_VALUE_RFI_ENABLE;\n\t}\n\n\tIWL_DEBUG_RADIO(mvm, \"DSM RFI is disabled\\n\");\n\n\t \n\treturn DSM_VALUE_RFI_DISABLE;\n}\n\nstatic void iwl_mvm_lari_cfg(struct iwl_mvm *mvm)\n{\n\tint ret;\n\tu32 value;\n\tstruct iwl_lari_config_change_cmd_v6 cmd = {};\n\n\tcmd.config_bitmap = iwl_acpi_get_lari_config_bitmap(&mvm->fwrt);\n\n\tret = iwl_acpi_get_dsm_u32(mvm->fwrt.dev, 0, DSM_FUNC_11AX_ENABLEMENT,\n\t\t\t\t   &iwl_guid, &value);\n\tif (!ret)\n\t\tcmd.oem_11ax_allow_bitmap = cpu_to_le32(value);\n\n\tret = iwl_acpi_get_dsm_u32(mvm->fwrt.dev, 0,\n\t\t\t\t   DSM_FUNC_ENABLE_UNII4_CHAN,\n\t\t\t\t   &iwl_guid, &value);\n\tif (!ret)\n\t\tcmd.oem_unii4_allow_bitmap = cpu_to_le32(value);\n\n\tret = iwl_acpi_get_dsm_u32(mvm->fwrt.dev, 0,\n\t\t\t\t   DSM_FUNC_ACTIVATE_CHANNEL,\n\t\t\t\t   &iwl_guid, &value);\n\tif (!ret)\n\t\tcmd.chan_state_active_bitmap = cpu_to_le32(value);\n\n\tret = iwl_acpi_get_dsm_u32(mvm->fwrt.dev, 0,\n\t\t\t\t   DSM_FUNC_ENABLE_6E,\n\t\t\t\t   &iwl_guid, &value);\n\tif (!ret)\n\t\tcmd.oem_uhb_allow_bitmap = cpu_to_le32(value);\n\n\tret = iwl_acpi_get_dsm_u32(mvm->fwrt.dev, 0,\n\t\t\t\t   DSM_FUNC_FORCE_DISABLE_CHANNELS,\n\t\t\t\t   &iwl_guid, &value);\n\tif (!ret)\n\t\tcmd.force_disable_channels_bitmap = cpu_to_le32(value);\n\n\tif (cmd.config_bitmap ||\n\t    cmd.oem_uhb_allow_bitmap ||\n\t    cmd.oem_11ax_allow_bitmap ||\n\t    cmd.oem_unii4_allow_bitmap ||\n\t    cmd.chan_state_active_bitmap ||\n\t    cmd.force_disable_channels_bitmap) {\n\t\tsize_t cmd_size;\n\t\tu8 cmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw,\n\t\t\t\t\t\t   WIDE_ID(REGULATORY_AND_NVM_GROUP,\n\t\t\t\t\t\t\t   LARI_CONFIG_CHANGE),\n\t\t\t\t\t\t   1);\n\t\tswitch (cmd_ver) {\n\t\tcase 6:\n\t\t\tcmd_size = sizeof(struct iwl_lari_config_change_cmd_v6);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tcmd_size = sizeof(struct iwl_lari_config_change_cmd_v5);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tcmd_size = sizeof(struct iwl_lari_config_change_cmd_v4);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcmd_size = sizeof(struct iwl_lari_config_change_cmd_v3);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcmd_size = sizeof(struct iwl_lari_config_change_cmd_v2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcmd_size = sizeof(struct iwl_lari_config_change_cmd_v1);\n\t\t\tbreak;\n\t\t}\n\n\t\tIWL_DEBUG_RADIO(mvm,\n\t\t\t\t\"sending LARI_CONFIG_CHANGE, config_bitmap=0x%x, oem_11ax_allow_bitmap=0x%x\\n\",\n\t\t\t\tle32_to_cpu(cmd.config_bitmap),\n\t\t\t\tle32_to_cpu(cmd.oem_11ax_allow_bitmap));\n\t\tIWL_DEBUG_RADIO(mvm,\n\t\t\t\t\"sending LARI_CONFIG_CHANGE, oem_unii4_allow_bitmap=0x%x, chan_state_active_bitmap=0x%x, cmd_ver=%d\\n\",\n\t\t\t\tle32_to_cpu(cmd.oem_unii4_allow_bitmap),\n\t\t\t\tle32_to_cpu(cmd.chan_state_active_bitmap),\n\t\t\t\tcmd_ver);\n\t\tIWL_DEBUG_RADIO(mvm,\n\t\t\t\t\"sending LARI_CONFIG_CHANGE, oem_uhb_allow_bitmap=0x%x, force_disable_channels_bitmap=0x%x\\n\",\n\t\t\t\tle32_to_cpu(cmd.oem_uhb_allow_bitmap),\n\t\t\t\tle32_to_cpu(cmd.force_disable_channels_bitmap));\n\t\tret = iwl_mvm_send_cmd_pdu(mvm,\n\t\t\t\t\t   WIDE_ID(REGULATORY_AND_NVM_GROUP,\n\t\t\t\t\t\t   LARI_CONFIG_CHANGE),\n\t\t\t\t\t   0, cmd_size, &cmd);\n\t\tif (ret < 0)\n\t\t\tIWL_DEBUG_RADIO(mvm,\n\t\t\t\t\t\"Failed to send LARI_CONFIG_CHANGE (%d)\\n\",\n\t\t\t\t\tret);\n\t}\n}\n\nvoid iwl_mvm_get_acpi_tables(struct iwl_mvm *mvm)\n{\n\tint ret;\n\n\t \n\tret = iwl_acpi_get_ppag_table(&mvm->fwrt);\n\tif (ret < 0) {\n\t\tIWL_DEBUG_RADIO(mvm,\n\t\t\t\t\"PPAG BIOS table invalid or unavailable. (%d)\\n\",\n\t\t\t\tret);\n\t}\n\n\t \n\tret = iwl_sar_get_wrds_table(&mvm->fwrt);\n\tif (ret < 0) {\n\t\tIWL_DEBUG_RADIO(mvm,\n\t\t\t\t\"WRDS SAR BIOS table invalid or unavailable. (%d)\\n\",\n\t\t\t\tret);\n\t\t \n\n\t\tif (!iwl_sar_get_wgds_table(&mvm->fwrt)) {\n\t\t\t \n\t\t\tIWL_ERR(mvm, \"BIOS contains WGDS but no WRDS\\n\");\n\t\t}\n\n\t} else {\n\t\tret = iwl_sar_get_ewrd_table(&mvm->fwrt);\n\t\t \n\t\tif (ret < 0)\n\t\t\tIWL_DEBUG_RADIO(mvm,\n\t\t\t\t\t\"EWRD SAR BIOS table invalid or unavailable. (%d)\\n\",\n\t\t\t\t\tret);\n\n\t\t \n\t\tif (iwl_sar_geo_support(&mvm->fwrt)) {\n\t\t\tret = iwl_sar_get_wgds_table(&mvm->fwrt);\n\t\t\tif (ret < 0)\n\t\t\t\tIWL_DEBUG_RADIO(mvm,\n\t\t\t\t\t\t\"Geo SAR BIOS table invalid or unavailable. (%d)\\n\",\n\t\t\t\t\t\tret);\n\t\t\t\t \n\t\t}\n\t}\n\n\tiwl_acpi_get_phy_filters(&mvm->fwrt, &mvm->phy_filters);\n}\n#else  \n\ninline int iwl_mvm_sar_select_profile(struct iwl_mvm *mvm,\n\t\t\t\t      int prof_a, int prof_b)\n{\n\treturn 1;\n}\n\ninline int iwl_mvm_get_sar_geo_profile(struct iwl_mvm *mvm)\n{\n\treturn -ENOENT;\n}\n\nstatic int iwl_mvm_sar_geo_init(struct iwl_mvm *mvm)\n{\n\treturn 0;\n}\n\nint iwl_mvm_ppag_send_cmd(struct iwl_mvm *mvm)\n{\n\treturn -ENOENT;\n}\n\nstatic int iwl_mvm_ppag_init(struct iwl_mvm *mvm)\n{\n\treturn 0;\n}\n\nstatic void iwl_mvm_tas_init(struct iwl_mvm *mvm)\n{\n}\n\nstatic void iwl_mvm_lari_cfg(struct iwl_mvm *mvm)\n{\n}\n\nbool iwl_mvm_is_vendor_in_approved_list(void)\n{\n\treturn false;\n}\n\nstatic u8 iwl_mvm_eval_dsm_rfi(struct iwl_mvm *mvm)\n{\n\treturn DSM_VALUE_RFI_DISABLE;\n}\n\nvoid iwl_mvm_get_acpi_tables(struct iwl_mvm *mvm)\n{\n}\n\n#endif  \n\nvoid iwl_mvm_send_recovery_cmd(struct iwl_mvm *mvm, u32 flags)\n{\n\tu32 error_log_size = mvm->fw->ucode_capa.error_log_size;\n\tint ret;\n\tu32 resp;\n\n\tstruct iwl_fw_error_recovery_cmd recovery_cmd = {\n\t\t.flags = cpu_to_le32(flags),\n\t\t.buf_size = 0,\n\t};\n\tstruct iwl_host_cmd host_cmd = {\n\t\t.id = WIDE_ID(SYSTEM_GROUP, FW_ERROR_RECOVERY_CMD),\n\t\t.flags = CMD_WANT_SKB,\n\t\t.data = {&recovery_cmd, },\n\t\t.len = {sizeof(recovery_cmd), },\n\t};\n\n\t \n\tif (!error_log_size)\n\t\treturn;\n\n\tif (flags & ERROR_RECOVERY_UPDATE_DB) {\n\t\t \n\t\tif (!mvm->error_recovery_buf)\n\t\t\treturn;\n\n\t\thost_cmd.data[1] = mvm->error_recovery_buf;\n\t\thost_cmd.len[1] =  error_log_size;\n\t\thost_cmd.dataflags[1] = IWL_HCMD_DFL_NOCOPY;\n\t\trecovery_cmd.buf_size = cpu_to_le32(error_log_size);\n\t}\n\n\tret = iwl_mvm_send_cmd(mvm, &host_cmd);\n\tkfree(mvm->error_recovery_buf);\n\tmvm->error_recovery_buf = NULL;\n\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"Failed to send recovery cmd %d\\n\", ret);\n\t\treturn;\n\t}\n\n\t \n\tif (flags & ERROR_RECOVERY_UPDATE_DB) {\n\t\tresp = le32_to_cpu(*(__le32 *)host_cmd.resp_pkt->data);\n\t\tif (resp)\n\t\t\tIWL_ERR(mvm,\n\t\t\t\t\"Failed to send recovery cmd blob was invalid %d\\n\",\n\t\t\t\tresp);\n\t}\n}\n\nstatic int iwl_mvm_sar_init(struct iwl_mvm *mvm)\n{\n\treturn iwl_mvm_sar_select_profile(mvm, 1, 1);\n}\n\nstatic int iwl_mvm_load_rt_fw(struct iwl_mvm *mvm)\n{\n\tint ret;\n\n\tif (iwl_mvm_has_unified_ucode(mvm))\n\t\treturn iwl_run_unified_mvm_ucode(mvm);\n\n\tret = iwl_run_init_mvm_ucode(mvm);\n\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"Failed to run INIT ucode: %d\\n\", ret);\n\n\t\tif (iwlmvm_mod_params.init_dbg)\n\t\t\treturn 0;\n\t\treturn ret;\n\t}\n\n\tiwl_fw_dbg_stop_sync(&mvm->fwrt);\n\tiwl_trans_stop_device(mvm->trans);\n\tret = iwl_trans_start_hw(mvm->trans);\n\tif (ret)\n\t\treturn ret;\n\n\tmvm->rfkill_safe_init_done = false;\n\tret = iwl_mvm_load_ucode_wait_alive(mvm, IWL_UCODE_REGULAR);\n\tif (ret)\n\t\treturn ret;\n\n\tmvm->rfkill_safe_init_done = true;\n\n\tiwl_dbg_tlv_time_point(&mvm->fwrt, IWL_FW_INI_TIME_POINT_AFTER_ALIVE,\n\t\t\t       NULL);\n\n\treturn iwl_init_paging(&mvm->fwrt, mvm->fwrt.cur_fw_img);\n}\n\nint iwl_mvm_up(struct iwl_mvm *mvm)\n{\n\tint ret, i;\n\tstruct ieee80211_channel *chan;\n\tstruct cfg80211_chan_def chandef;\n\tstruct ieee80211_supported_band *sband = NULL;\n\tu32 sb_cfg;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tret = iwl_trans_start_hw(mvm->trans);\n\tif (ret)\n\t\treturn ret;\n\n\tsb_cfg = iwl_read_umac_prph(mvm->trans, SB_MODIFY_CFG_FLAG);\n\tmvm->pldr_sync = !(sb_cfg & SB_CFG_RESIDES_IN_OTP_MASK);\n\tif (mvm->pldr_sync && iwl_mei_pldr_req())\n\t\treturn -EBUSY;\n\n\tret = iwl_mvm_load_rt_fw(mvm);\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"Failed to start RT ucode: %d\\n\", ret);\n\t\tif (ret != -ERFKILL && !mvm->pldr_sync)\n\t\t\tiwl_fw_dbg_error_collect(&mvm->fwrt,\n\t\t\t\t\t\t FW_DBG_TRIGGER_DRIVER);\n\t\tgoto error;\n\t}\n\n\t \n\tmvm->pldr_sync = false;\n\n\tiwl_get_shared_mem_conf(&mvm->fwrt);\n\n\tret = iwl_mvm_sf_update(mvm, NULL, false);\n\tif (ret)\n\t\tIWL_ERR(mvm, \"Failed to initialize Smart Fifo\\n\");\n\n\tif (!iwl_trans_dbg_ini_valid(mvm->trans)) {\n\t\tmvm->fwrt.dump.conf = FW_DBG_INVALID;\n\t\t \n\t\tif (mvm->fw->dbg.dest_tlv)\n\t\t\tmvm->fwrt.dump.conf = FW_DBG_START_FROM_ALIVE;\n\t\tiwl_fw_start_dbg_conf(&mvm->fwrt, FW_DBG_START_FROM_ALIVE);\n\t}\n\n\tret = iwl_send_tx_ant_cfg(mvm, iwl_mvm_get_valid_tx_ant(mvm));\n\tif (ret)\n\t\tgoto error;\n\n\tif (!iwl_mvm_has_unified_ucode(mvm)) {\n\t\t \n\t\tret = iwl_send_phy_db_data(mvm->phy_db);\n\t\tif (ret)\n\t\t\tgoto error;\n\t\tret = iwl_send_phy_cfg_cmd(mvm);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tret = iwl_mvm_send_bt_init_conf(mvm);\n\tif (ret)\n\t\tgoto error;\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_SOC_LATENCY_SUPPORT)) {\n\t\tret = iwl_set_soc_latency(&mvm->fwrt);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tiwl_mvm_lari_cfg(mvm);\n\n\t \n\tret = iwl_configure_rxq(&mvm->fwrt);\n\tif (ret)\n\t\tgoto error;\n\n\tif (iwl_mvm_has_new_rx_api(mvm)) {\n\t\tret = iwl_send_rss_cfg_cmd(mvm);\n\t\tif (ret) {\n\t\t\tIWL_ERR(mvm, \"Failed to configure RSS queues: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < mvm->fw->ucode_capa.num_stations; i++) {\n\t\tRCU_INIT_POINTER(mvm->fw_id_to_mac_id[i], NULL);\n\t\tRCU_INIT_POINTER(mvm->fw_id_to_link_sta[i], NULL);\n\t}\n\n\tfor (i = 0; i < IWL_MVM_FW_MAX_LINK_ID + 1; i++)\n\t\tRCU_INIT_POINTER(mvm->link_id_to_link_conf[i], NULL);\n\n\tmemset(&mvm->fw_link_ids_map, 0, sizeof(mvm->fw_link_ids_map));\n\n\tmvm->tdls_cs.peer.sta_id = IWL_MVM_INVALID_STA;\n\n\t \n\tmemset(&mvm->last_quota_cmd, 0xff, sizeof(mvm->last_quota_cmd));\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa, IWL_UCODE_TLV_CAPA_DQA_SUPPORT)) {\n\t\tret = iwl_mvm_send_dqa_cmd(mvm);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\t \n\tif (!iwl_mvm_has_new_station_api(mvm->fw)) {\n\t\t  \n\t\tret = iwl_mvm_add_aux_sta(mvm, MAC_INDEX_AUX);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\t \n\ti = 0;\n\twhile (!sband && i < NUM_NL80211_BANDS)\n\t\tsband = mvm->hw->wiphy->bands[i++];\n\n\tif (WARN_ON_ONCE(!sband)) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tchan = &sband->channels[0];\n\n\tcfg80211_chandef_create(&chandef, chan, NL80211_CHAN_NO_HT);\n\tfor (i = 0; i < NUM_PHY_CTX; i++) {\n\t\t \n\t\tret = iwl_mvm_phy_ctxt_add(mvm, &mvm->phy_ctxts[i],\n\t\t\t\t\t   &chandef, 1, 1);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tif (iwl_mvm_is_tt_in_fw(mvm)) {\n\t\t \n\t\tiwl_mvm_send_temp_report_ths_cmd(mvm);\n\t} else {\n\t\t \n\t\tiwl_mvm_tt_tx_backoff(mvm, 0);\n\t}\n\n#ifdef CONFIG_THERMAL\n\t \n\n\t \n\tif (iwl_mvm_is_ctdp_supported(mvm)) {\n\t\tret = iwl_mvm_ctdp_command(mvm, CTDP_CMD_OPERATION_START,\n\t\t\t\t\t   mvm->cooling_dev.cur_state);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n#endif\n\n\tif (!fw_has_capa(&mvm->fw->ucode_capa, IWL_UCODE_TLV_CAPA_SET_LTR_GEN2))\n\t\tWARN_ON(iwl_mvm_config_ltr(mvm));\n\n\tret = iwl_mvm_power_update_device(mvm);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tif (!test_bit(IWL_MVM_STATUS_HW_CTKILL, &mvm->status)) {\n\t\tret = iwl_mvm_init_mcc(mvm);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa, IWL_UCODE_TLV_CAPA_UMAC_SCAN)) {\n\t\tmvm->scan_type = IWL_SCAN_TYPE_NOT_SET;\n\t\tmvm->hb_scan_type = IWL_SCAN_TYPE_NOT_SET;\n\t\tret = iwl_mvm_config_scan(mvm);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tif (test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status)) {\n\t\tiwl_mvm_send_recovery_cmd(mvm, ERROR_RECOVERY_UPDATE_DB);\n\n\t\tif (mvm->time_sync.active)\n\t\t\tiwl_mvm_time_sync_config(mvm, mvm->time_sync.peer_addr,\n\t\t\t\t\t\t IWL_TIME_SYNC_PROTOCOL_TM |\n\t\t\t\t\t\t IWL_TIME_SYNC_PROTOCOL_FTM);\n\t}\n\n\tif (!mvm->ptp_data.ptp_clock)\n\t\tiwl_mvm_ptp_init(mvm);\n\n\tif (iwl_acpi_get_eckv(mvm->dev, &mvm->ext_clock_valid))\n\t\tIWL_DEBUG_INFO(mvm, \"ECKV table doesn't exist in BIOS\\n\");\n\n\tret = iwl_mvm_ppag_init(mvm);\n\tif (ret)\n\t\tgoto error;\n\n\tret = iwl_mvm_sar_init(mvm);\n\tif (ret == 0)\n\t\tret = iwl_mvm_sar_geo_init(mvm);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = iwl_mvm_sgom_init(mvm);\n\tif (ret)\n\t\tgoto error;\n\n\tiwl_mvm_tas_init(mvm);\n\tiwl_mvm_leds_sync(mvm);\n\n\tif (iwl_rfi_supported(mvm)) {\n\t\tif (iwl_mvm_eval_dsm_rfi(mvm) == DSM_VALUE_RFI_ENABLE)\n\t\t\tiwl_rfi_send_config_cmd(mvm, NULL);\n\t}\n\n\tiwl_mvm_mei_device_state(mvm, true);\n\n\tIWL_DEBUG_INFO(mvm, \"RT uCode started.\\n\");\n\treturn 0;\n error:\n\tif (!iwlmvm_mod_params.init_dbg || !ret)\n\t\tiwl_mvm_stop_device(mvm);\n\treturn ret;\n}\n\nint iwl_mvm_load_d3_fw(struct iwl_mvm *mvm)\n{\n\tint ret, i;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tret = iwl_trans_start_hw(mvm->trans);\n\tif (ret)\n\t\treturn ret;\n\n\tret = iwl_mvm_load_ucode_wait_alive(mvm, IWL_UCODE_WOWLAN);\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"Failed to start WoWLAN firmware: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tret = iwl_send_tx_ant_cfg(mvm, iwl_mvm_get_valid_tx_ant(mvm));\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tret = iwl_send_phy_db_data(mvm->phy_db);\n\tif (ret)\n\t\tgoto error;\n\n\tret = iwl_send_phy_cfg_cmd(mvm);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tfor (i = 0; i < mvm->fw->ucode_capa.num_stations; i++) {\n\t\tRCU_INIT_POINTER(mvm->fw_id_to_mac_id[i], NULL);\n\t\tRCU_INIT_POINTER(mvm->fw_id_to_link_sta[i], NULL);\n\t}\n\n\tif (!iwl_mvm_has_new_station_api(mvm->fw)) {\n\t\t \n\t\tret = iwl_mvm_add_aux_sta(mvm, MAC_INDEX_AUX);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\treturn 0;\n error:\n\tiwl_mvm_stop_device(mvm);\n\treturn ret;\n}\n\nvoid iwl_mvm_rx_mfuart_notif(struct iwl_mvm *mvm,\n\t\t\t     struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_mfuart_load_notif *mfuart_notif = (void *)pkt->data;\n\n\tIWL_DEBUG_INFO(mvm,\n\t\t       \"MFUART: installed ver: 0x%08x, external ver: 0x%08x, status: 0x%08x, duration: 0x%08x\\n\",\n\t\t       le32_to_cpu(mfuart_notif->installed_ver),\n\t\t       le32_to_cpu(mfuart_notif->external_ver),\n\t\t       le32_to_cpu(mfuart_notif->status),\n\t\t       le32_to_cpu(mfuart_notif->duration));\n\n\tif (iwl_rx_packet_payload_len(pkt) == sizeof(*mfuart_notif))\n\t\tIWL_DEBUG_INFO(mvm,\n\t\t\t       \"MFUART: image size: 0x%08x\\n\",\n\t\t\t       le32_to_cpu(mfuart_notif->image_size));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}