{
  "module_name": "ftm-initiator.c",
  "hash_id": "98d89fc937ae27a3635630a6a21d289f8bf5c16c5e8922c531c3d5bf729c28aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/ftm-initiator.c",
  "human_readable_source": "\n \n#include <linux/etherdevice.h>\n#include <linux/math64.h>\n#include <net/cfg80211.h>\n#include \"mvm.h\"\n#include \"iwl-io.h\"\n#include \"iwl-prph.h\"\n#include \"constants.h\"\n\nstruct iwl_mvm_loc_entry {\n\tstruct list_head list;\n\tu8 addr[ETH_ALEN];\n\tu8 lci_len, civic_len;\n\tu8 buf[];\n};\n\nstruct iwl_mvm_smooth_entry {\n\tstruct list_head list;\n\tu8 addr[ETH_ALEN];\n\ts64 rtt_avg;\n\tu64 host_time;\n};\n\nenum iwl_mvm_pasn_flags {\n\tIWL_MVM_PASN_FLAG_HAS_HLTK = BIT(0),\n};\n\nstruct iwl_mvm_ftm_pasn_entry {\n\tstruct list_head list;\n\tu8 addr[ETH_ALEN];\n\tu8 hltk[HLTK_11AZ_LEN];\n\tu8 tk[TK_11AZ_LEN];\n\tu8 cipher;\n\tu8 tx_pn[IEEE80211_CCMP_PN_LEN];\n\tu8 rx_pn[IEEE80211_CCMP_PN_LEN];\n\tu32 flags;\n};\n\nint iwl_mvm_ftm_add_pasn_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t     u8 *addr, u32 cipher, u8 *tk, u32 tk_len,\n\t\t\t     u8 *hltk, u32 hltk_len)\n{\n\tstruct iwl_mvm_ftm_pasn_entry *pasn = kzalloc(sizeof(*pasn),\n\t\t\t\t\t\t      GFP_KERNEL);\n\tu32 expected_tk_len;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (!pasn)\n\t\treturn -ENOBUFS;\n\n\tpasn->cipher = iwl_mvm_cipher_to_location_cipher(cipher);\n\n\tswitch (pasn->cipher) {\n\tcase IWL_LOCATION_CIPHER_CCMP_128:\n\tcase IWL_LOCATION_CIPHER_GCMP_128:\n\t\texpected_tk_len = WLAN_KEY_LEN_CCMP;\n\t\tbreak;\n\tcase IWL_LOCATION_CIPHER_GCMP_256:\n\t\texpected_tk_len = WLAN_KEY_LEN_GCMP_256;\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\t \n\tif (vif->cfg.assoc) {\n\t\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\t\tstruct ieee80211_bss_conf *link_conf;\n\t\tunsigned int link_id;\n\t\tstruct ieee80211_sta *sta;\n\t\tu8 sta_id;\n\n\t\trcu_read_lock();\n\t\tfor_each_vif_active_link(vif, link_conf, link_id) {\n\t\t\tif (memcmp(addr, link_conf->bssid, ETH_ALEN))\n\t\t\t\tcontinue;\n\n\t\t\tsta_id = mvmvif->link[link_id]->ap_sta_id;\n\t\t\tsta = rcu_dereference(mvm->fw_id_to_mac_id[sta_id]);\n\t\t\tif (!IS_ERR_OR_NULL(sta) && sta->mfp)\n\t\t\t\texpected_tk_len = 0;\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (tk_len != expected_tk_len ||\n\t    (hltk_len && hltk_len != sizeof(pasn->hltk))) {\n\t\tIWL_ERR(mvm, \"Invalid key length: tk_len=%u hltk_len=%u\\n\",\n\t\t\ttk_len, hltk_len);\n\t\tgoto out;\n\t}\n\n\tif (!expected_tk_len && !hltk_len) {\n\t\tIWL_ERR(mvm, \"TK and HLTK not set\\n\");\n\t\tgoto out;\n\t}\n\n\tmemcpy(pasn->addr, addr, sizeof(pasn->addr));\n\n\tif (hltk_len) {\n\t\tmemcpy(pasn->hltk, hltk, sizeof(pasn->hltk));\n\t\tpasn->flags |= IWL_MVM_PASN_FLAG_HAS_HLTK;\n\t}\n\n\tif (tk && tk_len)\n\t\tmemcpy(pasn->tk, tk, sizeof(pasn->tk));\n\n\tlist_add_tail(&pasn->list, &mvm->ftm_initiator.pasn_list);\n\treturn 0;\nout:\n\tkfree(pasn);\n\treturn -EINVAL;\n}\n\nvoid iwl_mvm_ftm_remove_pasn_sta(struct iwl_mvm *mvm, u8 *addr)\n{\n\tstruct iwl_mvm_ftm_pasn_entry *entry, *prev;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tlist_for_each_entry_safe(entry, prev, &mvm->ftm_initiator.pasn_list,\n\t\t\t\t list) {\n\t\tif (memcmp(entry->addr, addr, sizeof(entry->addr)))\n\t\t\tcontinue;\n\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t\treturn;\n\t}\n}\n\nstatic void iwl_mvm_ftm_reset(struct iwl_mvm *mvm)\n{\n\tstruct iwl_mvm_loc_entry *e, *t;\n\n\tmvm->ftm_initiator.req = NULL;\n\tmvm->ftm_initiator.req_wdev = NULL;\n\tmemset(mvm->ftm_initiator.responses, 0,\n\t       sizeof(mvm->ftm_initiator.responses));\n\n\tlist_for_each_entry_safe(e, t, &mvm->ftm_initiator.loc_list, list) {\n\t\tlist_del(&e->list);\n\t\tkfree(e);\n\t}\n}\n\nvoid iwl_mvm_ftm_restart(struct iwl_mvm *mvm)\n{\n\tstruct cfg80211_pmsr_result result = {\n\t\t.status = NL80211_PMSR_STATUS_FAILURE,\n\t\t.final = 1,\n\t\t.host_time = ktime_get_boottime_ns(),\n\t\t.type = NL80211_PMSR_TYPE_FTM,\n\t};\n\tint i;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (!mvm->ftm_initiator.req)\n\t\treturn;\n\n\tfor (i = 0; i < mvm->ftm_initiator.req->n_peers; i++) {\n\t\tmemcpy(result.addr, mvm->ftm_initiator.req->peers[i].addr,\n\t\t       ETH_ALEN);\n\t\tresult.ftm.burst_index = mvm->ftm_initiator.responses[i];\n\n\t\tcfg80211_pmsr_report(mvm->ftm_initiator.req_wdev,\n\t\t\t\t     mvm->ftm_initiator.req,\n\t\t\t\t     &result, GFP_KERNEL);\n\t}\n\n\tcfg80211_pmsr_complete(mvm->ftm_initiator.req_wdev,\n\t\t\t       mvm->ftm_initiator.req, GFP_KERNEL);\n\tiwl_mvm_ftm_reset(mvm);\n}\n\nvoid iwl_mvm_ftm_initiator_smooth_config(struct iwl_mvm *mvm)\n{\n\tINIT_LIST_HEAD(&mvm->ftm_initiator.smooth.resp);\n\n\tIWL_DEBUG_INFO(mvm,\n\t\t       \"enable=%u, alpha=%u, age_jiffies=%u, thresh=(%u:%u)\\n\",\n\t\t\tIWL_MVM_FTM_INITIATOR_ENABLE_SMOOTH,\n\t\t\tIWL_MVM_FTM_INITIATOR_SMOOTH_ALPHA,\n\t\t\tIWL_MVM_FTM_INITIATOR_SMOOTH_AGE_SEC * HZ,\n\t\t\tIWL_MVM_FTM_INITIATOR_SMOOTH_OVERSHOOT,\n\t\t\tIWL_MVM_FTM_INITIATOR_SMOOTH_UNDERSHOOT);\n}\n\nvoid iwl_mvm_ftm_initiator_smooth_stop(struct iwl_mvm *mvm)\n{\n\tstruct iwl_mvm_smooth_entry *se, *st;\n\n\tlist_for_each_entry_safe(se, st, &mvm->ftm_initiator.smooth.resp,\n\t\t\t\t list) {\n\t\tlist_del(&se->list);\n\t\tkfree(se);\n\t}\n}\n\nstatic int\niwl_ftm_range_request_status_to_err(enum iwl_tof_range_request_status s)\n{\n\tswitch (s) {\n\tcase IWL_TOF_RANGE_REQUEST_STATUS_SUCCESS:\n\t\treturn 0;\n\tcase IWL_TOF_RANGE_REQUEST_STATUS_BUSY:\n\t\treturn -EBUSY;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EIO;\n\t}\n}\n\nstatic void iwl_mvm_ftm_cmd_v5(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t       struct iwl_tof_range_req_cmd_v5 *cmd,\n\t\t\t       struct cfg80211_pmsr_request *req)\n{\n\tint i;\n\n\tcmd->request_id = req->cookie;\n\tcmd->num_of_ap = req->n_peers;\n\n\t \n\tif (!req->timeout || req->timeout > 255 * 100)\n\t\tcmd->req_timeout = 255;\n\telse\n\t\tcmd->req_timeout = DIV_ROUND_UP(req->timeout, 100);\n\n\t \n\tcmd->macaddr_random = 1;\n\tmemcpy(cmd->macaddr_template, req->mac_addr, ETH_ALEN);\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tcmd->macaddr_mask[i] = ~req->mac_addr_mask[i];\n\n\tif (vif->cfg.assoc)\n\t\tmemcpy(cmd->range_req_bssid, vif->bss_conf.bssid, ETH_ALEN);\n\telse\n\t\teth_broadcast_addr(cmd->range_req_bssid);\n}\n\nstatic void iwl_mvm_ftm_cmd_common(struct iwl_mvm *mvm,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct iwl_tof_range_req_cmd_v9 *cmd,\n\t\t\t\t   struct cfg80211_pmsr_request *req)\n{\n\tint i;\n\n\tcmd->initiator_flags =\n\t\tcpu_to_le32(IWL_TOF_INITIATOR_FLAGS_MACADDR_RANDOM |\n\t\t\t    IWL_TOF_INITIATOR_FLAGS_NON_ASAP_SUPPORT);\n\tcmd->request_id = req->cookie;\n\tcmd->num_of_ap = req->n_peers;\n\n\t \n\tif (req->timeout)\n\t\tcmd->req_timeout_ms = cpu_to_le32(req->timeout);\n\telse\n\t\tcmd->req_timeout_ms = cpu_to_le32(0xfffff);\n\n\tmemcpy(cmd->macaddr_template, req->mac_addr, ETH_ALEN);\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tcmd->macaddr_mask[i] = ~req->mac_addr_mask[i];\n\n\tif (vif->cfg.assoc) {\n\t\tmemcpy(cmd->range_req_bssid, vif->bss_conf.bssid, ETH_ALEN);\n\n\t\t \n\t\tfor (i = 0; i < req->n_peers; i++) {\n\t\t\tif (req->peers[i].report_ap_tsf) {\n\t\t\t\tstruct iwl_mvm_vif *mvmvif =\n\t\t\t\t\tiwl_mvm_vif_from_mac80211(vif);\n\n\t\t\t\tcmd->tsf_mac_id = cpu_to_le32(mvmvif->id);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t} else {\n\t\teth_broadcast_addr(cmd->range_req_bssid);\n\t}\n\n\t \n\tcmd->tsf_mac_id = cpu_to_le32(0xff);\n}\n\nstatic void iwl_mvm_ftm_cmd_v8(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t       struct iwl_tof_range_req_cmd_v8 *cmd,\n\t\t\t       struct cfg80211_pmsr_request *req)\n{\n\tiwl_mvm_ftm_cmd_common(mvm, vif, (void *)cmd, req);\n}\n\nstatic int\niwl_mvm_ftm_target_chandef_v1(struct iwl_mvm *mvm,\n\t\t\t      struct cfg80211_pmsr_request_peer *peer,\n\t\t\t      u8 *channel, u8 *bandwidth,\n\t\t\t      u8 *ctrl_ch_position)\n{\n\tu32 freq = peer->chandef.chan->center_freq;\n\n\t*channel = ieee80211_frequency_to_channel(freq);\n\n\tswitch (peer->chandef.width) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\t*bandwidth = IWL_TOF_BW_20_LEGACY;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_20:\n\t\t*bandwidth = IWL_TOF_BW_20_HT;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\t*bandwidth = IWL_TOF_BW_40;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\t*bandwidth = IWL_TOF_BW_80;\n\t\tbreak;\n\tdefault:\n\t\tIWL_ERR(mvm, \"Unsupported BW in FTM request (%d)\\n\",\n\t\t\tpeer->chandef.width);\n\t\treturn -EINVAL;\n\t}\n\n\t*ctrl_ch_position = (peer->chandef.width > NL80211_CHAN_WIDTH_20) ?\n\t\tiwl_mvm_get_ctrl_pos(&peer->chandef) : 0;\n\n\treturn 0;\n}\n\nstatic int\niwl_mvm_ftm_target_chandef_v2(struct iwl_mvm *mvm,\n\t\t\t      struct cfg80211_pmsr_request_peer *peer,\n\t\t\t      u8 *channel, u8 *format_bw,\n\t\t\t      u8 *ctrl_ch_position)\n{\n\tu32 freq = peer->chandef.chan->center_freq;\n\tu8 cmd_ver;\n\n\t*channel = ieee80211_frequency_to_channel(freq);\n\n\tswitch (peer->chandef.width) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\t*format_bw = IWL_LOCATION_FRAME_FORMAT_LEGACY;\n\t\t*format_bw |= IWL_LOCATION_BW_20MHZ << LOCATION_BW_POS;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_20:\n\t\t*format_bw = IWL_LOCATION_FRAME_FORMAT_HT;\n\t\t*format_bw |= IWL_LOCATION_BW_20MHZ << LOCATION_BW_POS;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\t*format_bw = IWL_LOCATION_FRAME_FORMAT_HT;\n\t\t*format_bw |= IWL_LOCATION_BW_40MHZ << LOCATION_BW_POS;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\t*format_bw = IWL_LOCATION_FRAME_FORMAT_VHT;\n\t\t*format_bw |= IWL_LOCATION_BW_80MHZ << LOCATION_BW_POS;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_160:\n\t\tcmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw,\n\t\t\t\t\t\tWIDE_ID(LOCATION_GROUP, TOF_RANGE_REQ_CMD),\n\t\t\t\t\t\tIWL_FW_CMD_VER_UNKNOWN);\n\n\t\tif (cmd_ver >= 13) {\n\t\t\t*format_bw = IWL_LOCATION_FRAME_FORMAT_HE;\n\t\t\t*format_bw |= IWL_LOCATION_BW_160MHZ << LOCATION_BW_POS;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tIWL_ERR(mvm, \"Unsupported BW in FTM request (%d)\\n\",\n\t\t\tpeer->chandef.width);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (peer->ftm.trigger_based || peer->ftm.non_trigger_based)\n\t\t*format_bw |= IWL_LOCATION_FRAME_FORMAT_HE;\n\n\t*ctrl_ch_position = (peer->chandef.width > NL80211_CHAN_WIDTH_20) ?\n\t\tiwl_mvm_get_ctrl_pos(&peer->chandef) : 0;\n\n\treturn 0;\n}\n\nstatic int\niwl_mvm_ftm_put_target_v2(struct iwl_mvm *mvm,\n\t\t\t  struct cfg80211_pmsr_request_peer *peer,\n\t\t\t  struct iwl_tof_range_req_ap_entry_v2 *target)\n{\n\tint ret;\n\n\tret = iwl_mvm_ftm_target_chandef_v1(mvm, peer, &target->channel_num,\n\t\t\t\t\t    &target->bandwidth,\n\t\t\t\t\t    &target->ctrl_ch_position);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(target->bssid, peer->addr, ETH_ALEN);\n\ttarget->burst_period =\n\t\tcpu_to_le16(peer->ftm.burst_period);\n\ttarget->samples_per_burst = peer->ftm.ftms_per_burst;\n\ttarget->num_of_bursts = peer->ftm.num_bursts_exp;\n\ttarget->measure_type = 0;  \n\ttarget->retries_per_sample = peer->ftm.ftmr_retries;\n\ttarget->asap_mode = peer->ftm.asap;\n\ttarget->enable_dyn_ack = IWL_MVM_FTM_INITIATOR_DYNACK;\n\n\tif (peer->ftm.request_lci)\n\t\ttarget->location_req |= IWL_TOF_LOC_LCI;\n\tif (peer->ftm.request_civicloc)\n\t\ttarget->location_req |= IWL_TOF_LOC_CIVIC;\n\n\ttarget->algo_type = IWL_MVM_FTM_INITIATOR_ALGO;\n\n\treturn 0;\n}\n\n#define FTM_PUT_FLAG(flag)\t(target->initiator_ap_flags |= \\\n\t\t\t\t cpu_to_le32(IWL_INITIATOR_AP_FLAGS_##flag))\n\nstatic void\niwl_mvm_ftm_put_target_common(struct iwl_mvm *mvm,\n\t\t\t      struct cfg80211_pmsr_request_peer *peer,\n\t\t\t      struct iwl_tof_range_req_ap_entry_v6 *target)\n{\n\tmemcpy(target->bssid, peer->addr, ETH_ALEN);\n\ttarget->burst_period =\n\t\tcpu_to_le16(peer->ftm.burst_period);\n\ttarget->samples_per_burst = peer->ftm.ftms_per_burst;\n\ttarget->num_of_bursts = peer->ftm.num_bursts_exp;\n\ttarget->ftmr_max_retries = peer->ftm.ftmr_retries;\n\ttarget->initiator_ap_flags = cpu_to_le32(0);\n\n\tif (peer->ftm.asap)\n\t\tFTM_PUT_FLAG(ASAP);\n\n\tif (peer->ftm.request_lci)\n\t\tFTM_PUT_FLAG(LCI_REQUEST);\n\n\tif (peer->ftm.request_civicloc)\n\t\tFTM_PUT_FLAG(CIVIC_REQUEST);\n\n\tif (IWL_MVM_FTM_INITIATOR_DYNACK)\n\t\tFTM_PUT_FLAG(DYN_ACK);\n\n\tif (IWL_MVM_FTM_INITIATOR_ALGO == IWL_TOF_ALGO_TYPE_LINEAR_REG)\n\t\tFTM_PUT_FLAG(ALGO_LR);\n\telse if (IWL_MVM_FTM_INITIATOR_ALGO == IWL_TOF_ALGO_TYPE_FFT)\n\t\tFTM_PUT_FLAG(ALGO_FFT);\n\n\tif (peer->ftm.trigger_based)\n\t\tFTM_PUT_FLAG(TB);\n\telse if (peer->ftm.non_trigger_based)\n\t\tFTM_PUT_FLAG(NON_TB);\n\n\tif ((peer->ftm.trigger_based || peer->ftm.non_trigger_based) &&\n\t    peer->ftm.lmr_feedback)\n\t\tFTM_PUT_FLAG(LMR_FEEDBACK);\n}\n\nstatic int\niwl_mvm_ftm_put_target_v3(struct iwl_mvm *mvm,\n\t\t\t  struct cfg80211_pmsr_request_peer *peer,\n\t\t\t  struct iwl_tof_range_req_ap_entry_v3 *target)\n{\n\tint ret;\n\n\tret = iwl_mvm_ftm_target_chandef_v1(mvm, peer, &target->channel_num,\n\t\t\t\t\t    &target->bandwidth,\n\t\t\t\t\t    &target->ctrl_ch_position);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tiwl_mvm_ftm_put_target_common(mvm, peer, (void *)target);\n\n\treturn 0;\n}\n\nstatic int\niwl_mvm_ftm_put_target_v4(struct iwl_mvm *mvm,\n\t\t\t  struct cfg80211_pmsr_request_peer *peer,\n\t\t\t  struct iwl_tof_range_req_ap_entry_v4 *target)\n{\n\tint ret;\n\n\tret = iwl_mvm_ftm_target_chandef_v2(mvm, peer, &target->channel_num,\n\t\t\t\t\t    &target->format_bw,\n\t\t\t\t\t    &target->ctrl_ch_position);\n\tif (ret)\n\t\treturn ret;\n\n\tiwl_mvm_ftm_put_target_common(mvm, peer, (void *)target);\n\n\treturn 0;\n}\n\nstatic int\niwl_mvm_ftm_put_target(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t       struct cfg80211_pmsr_request_peer *peer,\n\t\t       struct iwl_tof_range_req_ap_entry_v6 *target)\n{\n\tint ret;\n\n\tret = iwl_mvm_ftm_target_chandef_v2(mvm, peer, &target->channel_num,\n\t\t\t\t\t    &target->format_bw,\n\t\t\t\t\t    &target->ctrl_ch_position);\n\tif (ret)\n\t\treturn ret;\n\n\tiwl_mvm_ftm_put_target_common(mvm, peer, target);\n\n\tif (vif->cfg.assoc) {\n\t\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\t\tstruct ieee80211_sta *sta;\n\t\tstruct ieee80211_bss_conf *link_conf;\n\t\tunsigned int link_id;\n\n\t\trcu_read_lock();\n\t\tfor_each_vif_active_link(vif, link_conf, link_id) {\n\t\t\tif (memcmp(peer->addr, link_conf->bssid, ETH_ALEN))\n\t\t\t\tcontinue;\n\n\t\t\ttarget->sta_id = mvmvif->link[link_id]->ap_sta_id;\n\t\t\tsta = rcu_dereference(mvm->fw_id_to_mac_id[target->sta_id]);\n\t\t\tif (WARN_ON_ONCE(IS_ERR_OR_NULL(sta))) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn PTR_ERR_OR_ZERO(sta);\n\t\t\t}\n\n\t\t\tif (sta->mfp && (peer->ftm.trigger_based ||\n\t\t\t\t\t peer->ftm.non_trigger_based))\n\t\t\t\tFTM_PUT_FLAG(PMF);\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t} else {\n\t\ttarget->sta_id = IWL_MVM_INVALID_STA;\n\t}\n\n\t \n\ttarget->beacon_interval = cpu_to_le16(100);\n\treturn 0;\n}\n\nstatic int iwl_mvm_ftm_send_cmd(struct iwl_mvm *mvm, struct iwl_host_cmd *hcmd)\n{\n\tu32 status;\n\tint err = iwl_mvm_send_cmd_status(mvm, hcmd, &status);\n\n\tif (!err && status) {\n\t\tIWL_ERR(mvm, \"FTM range request command failure, status: %u\\n\",\n\t\t\tstatus);\n\t\terr = iwl_ftm_range_request_status_to_err(status);\n\t}\n\n\treturn err;\n}\n\nstatic int iwl_mvm_ftm_start_v5(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t\tstruct cfg80211_pmsr_request *req)\n{\n\tstruct iwl_tof_range_req_cmd_v5 cmd_v5;\n\tstruct iwl_host_cmd hcmd = {\n\t\t.id = WIDE_ID(LOCATION_GROUP, TOF_RANGE_REQ_CMD),\n\t\t.dataflags[0] = IWL_HCMD_DFL_DUP,\n\t\t.data[0] = &cmd_v5,\n\t\t.len[0] = sizeof(cmd_v5),\n\t};\n\tu8 i;\n\tint err;\n\n\tiwl_mvm_ftm_cmd_v5(mvm, vif, &cmd_v5, req);\n\n\tfor (i = 0; i < cmd_v5.num_of_ap; i++) {\n\t\tstruct cfg80211_pmsr_request_peer *peer = &req->peers[i];\n\n\t\terr = iwl_mvm_ftm_put_target_v2(mvm, peer, &cmd_v5.ap[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn iwl_mvm_ftm_send_cmd(mvm, &hcmd);\n}\n\nstatic int iwl_mvm_ftm_start_v7(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t\tstruct cfg80211_pmsr_request *req)\n{\n\tstruct iwl_tof_range_req_cmd_v7 cmd_v7;\n\tstruct iwl_host_cmd hcmd = {\n\t\t.id = WIDE_ID(LOCATION_GROUP, TOF_RANGE_REQ_CMD),\n\t\t.dataflags[0] = IWL_HCMD_DFL_DUP,\n\t\t.data[0] = &cmd_v7,\n\t\t.len[0] = sizeof(cmd_v7),\n\t};\n\tu8 i;\n\tint err;\n\n\t \n\tiwl_mvm_ftm_cmd_v8(mvm, vif, (void *)&cmd_v7, req);\n\n\tfor (i = 0; i < cmd_v7.num_of_ap; i++) {\n\t\tstruct cfg80211_pmsr_request_peer *peer = &req->peers[i];\n\n\t\terr = iwl_mvm_ftm_put_target_v3(mvm, peer, &cmd_v7.ap[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn iwl_mvm_ftm_send_cmd(mvm, &hcmd);\n}\n\nstatic int iwl_mvm_ftm_start_v8(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t\tstruct cfg80211_pmsr_request *req)\n{\n\tstruct iwl_tof_range_req_cmd_v8 cmd;\n\tstruct iwl_host_cmd hcmd = {\n\t\t.id = WIDE_ID(LOCATION_GROUP, TOF_RANGE_REQ_CMD),\n\t\t.dataflags[0] = IWL_HCMD_DFL_DUP,\n\t\t.data[0] = &cmd,\n\t\t.len[0] = sizeof(cmd),\n\t};\n\tu8 i;\n\tint err;\n\n\tiwl_mvm_ftm_cmd_v8(mvm, vif, (void *)&cmd, req);\n\n\tfor (i = 0; i < cmd.num_of_ap; i++) {\n\t\tstruct cfg80211_pmsr_request_peer *peer = &req->peers[i];\n\n\t\terr = iwl_mvm_ftm_put_target_v4(mvm, peer, &cmd.ap[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn iwl_mvm_ftm_send_cmd(mvm, &hcmd);\n}\n\nstatic int iwl_mvm_ftm_start_v9(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t\tstruct cfg80211_pmsr_request *req)\n{\n\tstruct iwl_tof_range_req_cmd_v9 cmd;\n\tstruct iwl_host_cmd hcmd = {\n\t\t.id = WIDE_ID(LOCATION_GROUP, TOF_RANGE_REQ_CMD),\n\t\t.dataflags[0] = IWL_HCMD_DFL_DUP,\n\t\t.data[0] = &cmd,\n\t\t.len[0] = sizeof(cmd),\n\t};\n\tu8 i;\n\tint err;\n\n\tiwl_mvm_ftm_cmd_common(mvm, vif, &cmd, req);\n\n\tfor (i = 0; i < cmd.num_of_ap; i++) {\n\t\tstruct cfg80211_pmsr_request_peer *peer = &req->peers[i];\n\t\tstruct iwl_tof_range_req_ap_entry_v6 *target = &cmd.ap[i];\n\n\t\terr = iwl_mvm_ftm_put_target(mvm, vif, peer, target);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn iwl_mvm_ftm_send_cmd(mvm, &hcmd);\n}\n\nstatic void iter(struct ieee80211_hw *hw,\n\t\t struct ieee80211_vif *vif,\n\t\t struct ieee80211_sta *sta,\n\t\t struct ieee80211_key_conf *key,\n\t\t void *data)\n{\n\tstruct iwl_tof_range_req_ap_entry_v6 *target = data;\n\n\tif (!sta || memcmp(sta->addr, target->bssid, ETH_ALEN))\n\t\treturn;\n\n\tWARN_ON(!sta->mfp);\n\n\tif (WARN_ON(key->keylen > sizeof(target->tk)))\n\t\treturn;\n\n\tmemcpy(target->tk, key->key, key->keylen);\n\ttarget->cipher = iwl_mvm_cipher_to_location_cipher(key->cipher);\n\tWARN_ON(target->cipher == IWL_LOCATION_CIPHER_INVALID);\n}\n\nstatic void\niwl_mvm_ftm_set_secured_ranging(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t\tstruct iwl_tof_range_req_ap_entry_v7 *target)\n{\n\tstruct iwl_mvm_ftm_pasn_entry *entry;\n\tu32 flags = le32_to_cpu(target->initiator_ap_flags);\n\n\tif (!(flags & (IWL_INITIATOR_AP_FLAGS_NON_TB |\n\t\t       IWL_INITIATOR_AP_FLAGS_TB)))\n\t\treturn;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tlist_for_each_entry(entry, &mvm->ftm_initiator.pasn_list, list) {\n\t\tif (memcmp(entry->addr, target->bssid, sizeof(entry->addr)))\n\t\t\tcontinue;\n\n\t\ttarget->cipher = entry->cipher;\n\n\t\tif (entry->flags & IWL_MVM_PASN_FLAG_HAS_HLTK)\n\t\t\tmemcpy(target->hltk, entry->hltk, sizeof(target->hltk));\n\t\telse\n\t\t\tmemset(target->hltk, 0, sizeof(target->hltk));\n\n\t\tif (vif->cfg.assoc &&\n\t\t    !memcmp(vif->bss_conf.bssid, target->bssid,\n\t\t\t    sizeof(target->bssid)))\n\t\t\tieee80211_iter_keys(mvm->hw, vif, iter, target);\n\t\telse\n\t\t\tmemcpy(target->tk, entry->tk, sizeof(target->tk));\n\n\t\tmemcpy(target->rx_pn, entry->rx_pn, sizeof(target->rx_pn));\n\t\tmemcpy(target->tx_pn, entry->tx_pn, sizeof(target->tx_pn));\n\n\t\ttarget->initiator_ap_flags |=\n\t\t\tcpu_to_le32(IWL_INITIATOR_AP_FLAGS_SECURED);\n\t\treturn;\n\t}\n}\n\nstatic int\niwl_mvm_ftm_put_target_v7(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t  struct cfg80211_pmsr_request_peer *peer,\n\t\t\t  struct iwl_tof_range_req_ap_entry_v7 *target)\n{\n\tint err = iwl_mvm_ftm_put_target(mvm, vif, peer, (void *)target);\n\tif (err)\n\t\treturn err;\n\n\tiwl_mvm_ftm_set_secured_ranging(mvm, vif, target);\n\treturn err;\n}\n\nstatic int iwl_mvm_ftm_start_v11(struct iwl_mvm *mvm,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct cfg80211_pmsr_request *req)\n{\n\tstruct iwl_tof_range_req_cmd_v11 cmd;\n\tstruct iwl_host_cmd hcmd = {\n\t\t.id = WIDE_ID(LOCATION_GROUP, TOF_RANGE_REQ_CMD),\n\t\t.dataflags[0] = IWL_HCMD_DFL_DUP,\n\t\t.data[0] = &cmd,\n\t\t.len[0] = sizeof(cmd),\n\t};\n\tu8 i;\n\tint err;\n\n\tiwl_mvm_ftm_cmd_common(mvm, vif, (void *)&cmd, req);\n\n\tfor (i = 0; i < cmd.num_of_ap; i++) {\n\t\tstruct cfg80211_pmsr_request_peer *peer = &req->peers[i];\n\t\tstruct iwl_tof_range_req_ap_entry_v7 *target = &cmd.ap[i];\n\n\t\terr = iwl_mvm_ftm_put_target_v7(mvm, vif, peer, target);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn iwl_mvm_ftm_send_cmd(mvm, &hcmd);\n}\n\nstatic void\niwl_mvm_ftm_set_ndp_params(struct iwl_mvm *mvm,\n\t\t\t   struct iwl_tof_range_req_ap_entry_v8 *target)\n{\n\t \n\tu32 i2r_max_sts = IWL_MVM_FTM_I2R_MAX_STS > 1 ? 1 :\n\t\tIWL_MVM_FTM_I2R_MAX_STS;\n\n\ttarget->r2i_ndp_params = IWL_MVM_FTM_R2I_MAX_REP |\n\t\t(IWL_MVM_FTM_R2I_MAX_STS << IWL_LOCATION_MAX_STS_POS);\n\ttarget->i2r_ndp_params = IWL_MVM_FTM_I2R_MAX_REP |\n\t\t(i2r_max_sts << IWL_LOCATION_MAX_STS_POS);\n\ttarget->r2i_max_total_ltf = IWL_MVM_FTM_R2I_MAX_TOTAL_LTF;\n\ttarget->i2r_max_total_ltf = IWL_MVM_FTM_I2R_MAX_TOTAL_LTF;\n}\n\nstatic int\niwl_mvm_ftm_put_target_v8(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t  struct cfg80211_pmsr_request_peer *peer,\n\t\t\t  struct iwl_tof_range_req_ap_entry_v8 *target)\n{\n\tu32 flags;\n\tint ret = iwl_mvm_ftm_put_target_v7(mvm, vif, peer, (void *)target);\n\n\tif (ret)\n\t\treturn ret;\n\n\tiwl_mvm_ftm_set_ndp_params(mvm, target);\n\n\t \n\tflags = le32_to_cpu(target->initiator_ap_flags);\n\tif ((flags & IWL_INITIATOR_AP_FLAGS_SECURED) &&\n\t    !IWL_MVM_FTM_INITIATOR_SECURE_LTF) {\n\t\tflags &= ~IWL_INITIATOR_AP_FLAGS_SECURED;\n\t\tflags |= IWL_INITIATOR_AP_FLAGS_PMF;\n\t\ttarget->initiator_ap_flags = cpu_to_le32(flags);\n\t}\n\n\treturn 0;\n}\n\nstatic int iwl_mvm_ftm_start_v12(struct iwl_mvm *mvm,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct cfg80211_pmsr_request *req)\n{\n\tstruct iwl_tof_range_req_cmd_v12 cmd;\n\tstruct iwl_host_cmd hcmd = {\n\t\t.id = WIDE_ID(LOCATION_GROUP, TOF_RANGE_REQ_CMD),\n\t\t.dataflags[0] = IWL_HCMD_DFL_DUP,\n\t\t.data[0] = &cmd,\n\t\t.len[0] = sizeof(cmd),\n\t};\n\tu8 i;\n\tint err;\n\n\tiwl_mvm_ftm_cmd_common(mvm, vif, (void *)&cmd, req);\n\n\tfor (i = 0; i < cmd.num_of_ap; i++) {\n\t\tstruct cfg80211_pmsr_request_peer *peer = &req->peers[i];\n\t\tstruct iwl_tof_range_req_ap_entry_v8 *target = &cmd.ap[i];\n\n\t\terr = iwl_mvm_ftm_put_target_v8(mvm, vif, peer, target);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn iwl_mvm_ftm_send_cmd(mvm, &hcmd);\n}\n\nstatic int iwl_mvm_ftm_start_v13(struct iwl_mvm *mvm,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct cfg80211_pmsr_request *req)\n{\n\tstruct iwl_tof_range_req_cmd_v13 cmd;\n\tstruct iwl_host_cmd hcmd = {\n\t\t.id = WIDE_ID(LOCATION_GROUP, TOF_RANGE_REQ_CMD),\n\t\t.dataflags[0] = IWL_HCMD_DFL_DUP,\n\t\t.data[0] = &cmd,\n\t\t.len[0] = sizeof(cmd),\n\t};\n\tu8 i;\n\tint err;\n\n\tiwl_mvm_ftm_cmd_common(mvm, vif, (void *)&cmd, req);\n\n\tfor (i = 0; i < cmd.num_of_ap; i++) {\n\t\tstruct cfg80211_pmsr_request_peer *peer = &req->peers[i];\n\t\tstruct iwl_tof_range_req_ap_entry_v9 *target = &cmd.ap[i];\n\n\t\terr = iwl_mvm_ftm_put_target_v8(mvm, vif, peer, (void *)target);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (peer->ftm.trigger_based || peer->ftm.non_trigger_based)\n\t\t\ttarget->bss_color = peer->ftm.bss_color;\n\n\t\tif (peer->ftm.non_trigger_based) {\n\t\t\ttarget->min_time_between_msr =\n\t\t\t\tcpu_to_le16(IWL_MVM_FTM_NON_TB_MIN_TIME_BETWEEN_MSR);\n\t\t\ttarget->burst_period =\n\t\t\t\tcpu_to_le16(IWL_MVM_FTM_NON_TB_MAX_TIME_BETWEEN_MSR);\n\t\t} else {\n\t\t\ttarget->min_time_between_msr = cpu_to_le16(0);\n\t\t}\n\n\t\ttarget->band =\n\t\t\tiwl_mvm_phy_band_from_nl80211(peer->chandef.chan->band);\n\t}\n\n\treturn iwl_mvm_ftm_send_cmd(mvm, &hcmd);\n}\n\nint iwl_mvm_ftm_start(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t      struct cfg80211_pmsr_request *req)\n{\n\tbool new_api = fw_has_api(&mvm->fw->ucode_capa,\n\t\t\t\t  IWL_UCODE_TLV_API_FTM_NEW_RANGE_REQ);\n\tint err;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (mvm->ftm_initiator.req)\n\t\treturn -EBUSY;\n\n\tif (new_api) {\n\t\tu8 cmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw,\n\t\t\t\t\t\t   WIDE_ID(LOCATION_GROUP, TOF_RANGE_REQ_CMD),\n\t\t\t\t\t\t   IWL_FW_CMD_VER_UNKNOWN);\n\n\t\tswitch (cmd_ver) {\n\t\tcase 13:\n\t\t\terr = iwl_mvm_ftm_start_v13(mvm, vif, req);\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\terr = iwl_mvm_ftm_start_v12(mvm, vif, req);\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\terr = iwl_mvm_ftm_start_v11(mvm, vif, req);\n\t\t\tbreak;\n\t\tcase 9:\n\t\tcase 10:\n\t\t\terr = iwl_mvm_ftm_start_v9(mvm, vif, req);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\terr = iwl_mvm_ftm_start_v8(mvm, vif, req);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = iwl_mvm_ftm_start_v7(mvm, vif, req);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\terr = iwl_mvm_ftm_start_v5(mvm, vif, req);\n\t}\n\n\tif (!err) {\n\t\tmvm->ftm_initiator.req = req;\n\t\tmvm->ftm_initiator.req_wdev = ieee80211_vif_to_wdev(vif);\n\t}\n\n\treturn err;\n}\n\nvoid iwl_mvm_ftm_abort(struct iwl_mvm *mvm, struct cfg80211_pmsr_request *req)\n{\n\tstruct iwl_tof_range_abort_cmd cmd = {\n\t\t.request_id = req->cookie,\n\t};\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (req != mvm->ftm_initiator.req)\n\t\treturn;\n\n\tiwl_mvm_ftm_reset(mvm);\n\n\tif (iwl_mvm_send_cmd_pdu(mvm, WIDE_ID(LOCATION_GROUP, TOF_RANGE_ABORT_CMD),\n\t\t\t\t 0, sizeof(cmd), &cmd))\n\t\tIWL_ERR(mvm, \"failed to abort FTM process\\n\");\n}\n\nstatic int iwl_mvm_ftm_find_peer(struct cfg80211_pmsr_request *req,\n\t\t\t\t const u8 *addr)\n{\n\tint i;\n\n\tfor (i = 0; i < req->n_peers; i++) {\n\t\tstruct cfg80211_pmsr_request_peer *peer = &req->peers[i];\n\n\t\tif (ether_addr_equal_unaligned(peer->addr, addr))\n\t\t\treturn i;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic u64 iwl_mvm_ftm_get_host_time(struct iwl_mvm *mvm, __le32 fw_gp2_ts)\n{\n\tu32 gp2_ts = le32_to_cpu(fw_gp2_ts);\n\tu32 curr_gp2, diff;\n\tu64 now_from_boot_ns;\n\n\tiwl_mvm_get_sync_time(mvm, CLOCK_BOOTTIME, &curr_gp2,\n\t\t\t      &now_from_boot_ns, NULL);\n\n\tif (curr_gp2 >= gp2_ts)\n\t\tdiff = curr_gp2 - gp2_ts;\n\telse\n\t\tdiff = curr_gp2 + (U32_MAX - gp2_ts + 1);\n\n\treturn now_from_boot_ns - (u64)diff * 1000;\n}\n\nstatic void iwl_mvm_ftm_get_lci_civic(struct iwl_mvm *mvm,\n\t\t\t\t      struct cfg80211_pmsr_result *res)\n{\n\tstruct iwl_mvm_loc_entry *entry;\n\n\tlist_for_each_entry(entry, &mvm->ftm_initiator.loc_list, list) {\n\t\tif (!ether_addr_equal_unaligned(res->addr, entry->addr))\n\t\t\tcontinue;\n\n\t\tif (entry->lci_len) {\n\t\t\tres->ftm.lci_len = entry->lci_len;\n\t\t\tres->ftm.lci = entry->buf;\n\t\t}\n\n\t\tif (entry->civic_len) {\n\t\t\tres->ftm.civicloc_len = entry->civic_len;\n\t\t\tres->ftm.civicloc = entry->buf + entry->lci_len;\n\t\t}\n\n\t\t \n\t\tbreak;\n\t}\n}\n\nstatic int iwl_mvm_ftm_range_resp_valid(struct iwl_mvm *mvm, u8 request_id,\n\t\t\t\t\tu8 num_of_aps)\n{\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (request_id != (u8)mvm->ftm_initiator.req->cookie) {\n\t\tIWL_ERR(mvm, \"Request ID mismatch, got %u, active %u\\n\",\n\t\t\trequest_id, (u8)mvm->ftm_initiator.req->cookie);\n\t\treturn -EINVAL;\n\t}\n\n\tif (num_of_aps > mvm->ftm_initiator.req->n_peers) {\n\t\tIWL_ERR(mvm, \"FTM range response invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void iwl_mvm_ftm_rtt_smoothing(struct iwl_mvm *mvm,\n\t\t\t\t      struct cfg80211_pmsr_result *res)\n{\n\tstruct iwl_mvm_smooth_entry *resp = NULL, *iter;\n\ts64 rtt_avg, rtt = res->ftm.rtt_avg;\n\tu32 undershoot, overshoot;\n\tu8 alpha;\n\n\tif (!IWL_MVM_FTM_INITIATOR_ENABLE_SMOOTH)\n\t\treturn;\n\n\tWARN_ON(rtt < 0);\n\n\tif (res->status != NL80211_PMSR_STATUS_SUCCESS) {\n\t\tIWL_DEBUG_INFO(mvm,\n\t\t\t       \": %pM: ignore failed measurement. Status=%u\\n\",\n\t\t\t       res->addr, res->status);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(iter, &mvm->ftm_initiator.smooth.resp, list) {\n\t\tif (!memcmp(res->addr, iter->addr, ETH_ALEN)) {\n\t\t\tresp = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!resp) {\n\t\tresp = kzalloc(sizeof(*resp), GFP_KERNEL);\n\t\tif (!resp)\n\t\t\treturn;\n\n\t\tmemcpy(resp->addr, res->addr, ETH_ALEN);\n\t\tlist_add_tail(&resp->list, &mvm->ftm_initiator.smooth.resp);\n\n\t\tresp->rtt_avg = rtt;\n\n\t\tIWL_DEBUG_INFO(mvm, \"new: %pM: rtt_avg=%lld\\n\",\n\t\t\t       resp->addr, resp->rtt_avg);\n\t\tgoto update_time;\n\t}\n\n\tif (res->host_time - resp->host_time >\n\t    IWL_MVM_FTM_INITIATOR_SMOOTH_AGE_SEC * 1000000000) {\n\t\tresp->rtt_avg = rtt;\n\n\t\tIWL_DEBUG_INFO(mvm, \"expired: %pM: rtt_avg=%lld\\n\",\n\t\t\t       resp->addr, resp->rtt_avg);\n\t\tgoto update_time;\n\t}\n\n\t \n\tundershoot = IWL_MVM_FTM_INITIATOR_SMOOTH_UNDERSHOOT;\n\tovershoot = IWL_MVM_FTM_INITIATOR_SMOOTH_OVERSHOOT;\n\talpha = IWL_MVM_FTM_INITIATOR_SMOOTH_ALPHA;\n\n\trtt_avg = div_s64(alpha * rtt + (100 - alpha) * resp->rtt_avg, 100);\n\n\tIWL_DEBUG_INFO(mvm,\n\t\t       \"%pM: prev rtt_avg=%lld, new rtt_avg=%lld, rtt=%lld\\n\",\n\t\t       resp->addr, resp->rtt_avg, rtt_avg, rtt);\n\n\t \n\tresp->rtt_avg = rtt_avg;\n\n\t \n\tif (rtt_avg > rtt && (rtt_avg - rtt) > undershoot) {\n\t\tres->ftm.rtt_avg = rtt_avg;\n\n\t\tIWL_DEBUG_INFO(mvm,\n\t\t\t       \"undershoot: val=%lld\\n\",\n\t\t\t       (rtt_avg - rtt));\n\t} else if (rtt_avg < rtt && (rtt - rtt_avg) >\n\t\t   overshoot) {\n\t\tres->ftm.rtt_avg = rtt_avg;\n\t\tIWL_DEBUG_INFO(mvm,\n\t\t\t       \"overshoot: val=%lld\\n\",\n\t\t\t       (rtt - rtt_avg));\n\t}\n\nupdate_time:\n\tresp->host_time = res->host_time;\n}\n\nstatic void iwl_mvm_debug_range_resp(struct iwl_mvm *mvm, u8 index,\n\t\t\t\t     struct cfg80211_pmsr_result *res)\n{\n\ts64 rtt_avg = div_s64(res->ftm.rtt_avg * 100, 6666);\n\n\tIWL_DEBUG_INFO(mvm, \"entry %d\\n\", index);\n\tIWL_DEBUG_INFO(mvm, \"\\tstatus: %d\\n\", res->status);\n\tIWL_DEBUG_INFO(mvm, \"\\tBSSID: %pM\\n\", res->addr);\n\tIWL_DEBUG_INFO(mvm, \"\\thost time: %llu\\n\", res->host_time);\n\tIWL_DEBUG_INFO(mvm, \"\\tburst index: %d\\n\", res->ftm.burst_index);\n\tIWL_DEBUG_INFO(mvm, \"\\tsuccess num: %u\\n\", res->ftm.num_ftmr_successes);\n\tIWL_DEBUG_INFO(mvm, \"\\trssi: %d\\n\", res->ftm.rssi_avg);\n\tIWL_DEBUG_INFO(mvm, \"\\trssi spread: %d\\n\", res->ftm.rssi_spread);\n\tIWL_DEBUG_INFO(mvm, \"\\trtt: %lld\\n\", res->ftm.rtt_avg);\n\tIWL_DEBUG_INFO(mvm, \"\\trtt var: %llu\\n\", res->ftm.rtt_variance);\n\tIWL_DEBUG_INFO(mvm, \"\\trtt spread: %llu\\n\", res->ftm.rtt_spread);\n\tIWL_DEBUG_INFO(mvm, \"\\tdistance: %lld\\n\", rtt_avg);\n}\n\nstatic void\niwl_mvm_ftm_pasn_update_pn(struct iwl_mvm *mvm,\n\t\t\t   struct iwl_tof_range_rsp_ap_entry_ntfy_v6 *fw_ap)\n{\n\tstruct iwl_mvm_ftm_pasn_entry *entry;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tlist_for_each_entry(entry, &mvm->ftm_initiator.pasn_list, list) {\n\t\tif (memcmp(fw_ap->bssid, entry->addr, sizeof(entry->addr)))\n\t\t\tcontinue;\n\n\t\tmemcpy(entry->rx_pn, fw_ap->rx_pn, sizeof(entry->rx_pn));\n\t\tmemcpy(entry->tx_pn, fw_ap->tx_pn, sizeof(entry->tx_pn));\n\t\treturn;\n\t}\n}\n\nstatic u8 iwl_mvm_ftm_get_range_resp_ver(struct iwl_mvm *mvm)\n{\n\tif (!fw_has_api(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_API_FTM_NEW_RANGE_REQ))\n\t\treturn 5;\n\n\t \n\tif (mvm->cmd_ver.range_resp >= 8)\n\t\treturn mvm->cmd_ver.range_resp;\n\telse if (fw_has_api(&mvm->fw->ucode_capa,\n\t\t\t    IWL_UCODE_TLV_API_FTM_RTT_ACCURACY))\n\t\treturn 7;\n\n\t \n\treturn 6;\n}\n\nstatic bool iwl_mvm_ftm_resp_size_validation(u8 ver, unsigned int pkt_len)\n{\n\tswitch (ver) {\n\tcase 9:\n\tcase 8:\n\t\treturn pkt_len == sizeof(struct iwl_tof_range_rsp_ntfy_v8);\n\tcase 7:\n\t\treturn pkt_len == sizeof(struct iwl_tof_range_rsp_ntfy_v7);\n\tcase 6:\n\t\treturn pkt_len == sizeof(struct iwl_tof_range_rsp_ntfy_v6);\n\tcase 5:\n\t\treturn pkt_len == sizeof(struct iwl_tof_range_rsp_ntfy_v5);\n\tdefault:\n\t\tWARN_ONCE(1, \"FTM: unsupported range response version %u\", ver);\n\t\treturn false;\n\t}\n}\n\nvoid iwl_mvm_ftm_range_resp(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tunsigned int pkt_len = iwl_rx_packet_payload_len(pkt);\n\tstruct iwl_tof_range_rsp_ntfy_v5 *fw_resp_v5 = (void *)pkt->data;\n\tstruct iwl_tof_range_rsp_ntfy_v6 *fw_resp_v6 = (void *)pkt->data;\n\tstruct iwl_tof_range_rsp_ntfy_v7 *fw_resp_v7 = (void *)pkt->data;\n\tstruct iwl_tof_range_rsp_ntfy_v8 *fw_resp_v8 = (void *)pkt->data;\n\tint i;\n\tbool new_api = fw_has_api(&mvm->fw->ucode_capa,\n\t\t\t\t  IWL_UCODE_TLV_API_FTM_NEW_RANGE_REQ);\n\tu8 num_of_aps, last_in_batch;\n\tu8 notif_ver = iwl_mvm_ftm_get_range_resp_ver(mvm);\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (!mvm->ftm_initiator.req) {\n\t\treturn;\n\t}\n\n\tif (unlikely(!iwl_mvm_ftm_resp_size_validation(notif_ver, pkt_len)))\n\t\treturn;\n\n\tif (new_api) {\n\t\tif (iwl_mvm_ftm_range_resp_valid(mvm, fw_resp_v8->request_id,\n\t\t\t\t\t\t fw_resp_v8->num_of_aps))\n\t\t\treturn;\n\n\t\tnum_of_aps = fw_resp_v8->num_of_aps;\n\t\tlast_in_batch = fw_resp_v8->last_report;\n\t} else {\n\t\tif (iwl_mvm_ftm_range_resp_valid(mvm, fw_resp_v5->request_id,\n\t\t\t\t\t\t fw_resp_v5->num_of_aps))\n\t\t\treturn;\n\n\t\tnum_of_aps = fw_resp_v5->num_of_aps;\n\t\tlast_in_batch = fw_resp_v5->last_in_batch;\n\t}\n\n\tIWL_DEBUG_INFO(mvm, \"Range response received\\n\");\n\tIWL_DEBUG_INFO(mvm, \"request id: %lld, num of entries: %u\\n\",\n\t\t       mvm->ftm_initiator.req->cookie, num_of_aps);\n\n\tfor (i = 0; i < num_of_aps && i < IWL_MVM_TOF_MAX_APS; i++) {\n\t\tstruct cfg80211_pmsr_result result = {};\n\t\tstruct iwl_tof_range_rsp_ap_entry_ntfy_v6 *fw_ap;\n\t\tint peer_idx;\n\n\t\tif (new_api) {\n\t\t\tif (notif_ver >= 8) {\n\t\t\t\tfw_ap = &fw_resp_v8->ap[i];\n\t\t\t\tiwl_mvm_ftm_pasn_update_pn(mvm, fw_ap);\n\t\t\t} else if (notif_ver == 7) {\n\t\t\t\tfw_ap = (void *)&fw_resp_v7->ap[i];\n\t\t\t} else {\n\t\t\t\tfw_ap = (void *)&fw_resp_v6->ap[i];\n\t\t\t}\n\n\t\t\tresult.final = fw_ap->last_burst;\n\t\t\tresult.ap_tsf = le32_to_cpu(fw_ap->start_tsf);\n\t\t\tresult.ap_tsf_valid = 1;\n\t\t} else {\n\t\t\t \n\t\t\tfw_ap = (void *)&fw_resp_v5->ap[i];\n\t\t\t \n\t\t\tresult.final = 0;\n\t\t}\n\n\t\tpeer_idx = iwl_mvm_ftm_find_peer(mvm->ftm_initiator.req,\n\t\t\t\t\t\t fw_ap->bssid);\n\t\tif (peer_idx < 0) {\n\t\t\tIWL_WARN(mvm,\n\t\t\t\t \"Unknown address (%pM, target #%d) in FTM response\\n\",\n\t\t\t\t fw_ap->bssid, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (fw_ap->measure_status) {\n\t\tcase IWL_TOF_ENTRY_SUCCESS:\n\t\t\tresult.status = NL80211_PMSR_STATUS_SUCCESS;\n\t\t\tbreak;\n\t\tcase IWL_TOF_ENTRY_TIMING_MEASURE_TIMEOUT:\n\t\t\tresult.status = NL80211_PMSR_STATUS_TIMEOUT;\n\t\t\tbreak;\n\t\tcase IWL_TOF_ENTRY_NO_RESPONSE:\n\t\t\tresult.status = NL80211_PMSR_STATUS_FAILURE;\n\t\t\tresult.ftm.failure_reason =\n\t\t\t\tNL80211_PMSR_FTM_FAILURE_NO_RESPONSE;\n\t\t\tbreak;\n\t\tcase IWL_TOF_ENTRY_REQUEST_REJECTED:\n\t\t\tresult.status = NL80211_PMSR_STATUS_FAILURE;\n\t\t\tresult.ftm.failure_reason =\n\t\t\t\tNL80211_PMSR_FTM_FAILURE_PEER_BUSY;\n\t\t\tresult.ftm.busy_retry_time = fw_ap->refusal_period;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tresult.status = NL80211_PMSR_STATUS_FAILURE;\n\t\t\tresult.ftm.failure_reason =\n\t\t\t\tNL80211_PMSR_FTM_FAILURE_UNSPECIFIED;\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(result.addr, fw_ap->bssid, ETH_ALEN);\n\t\tresult.host_time = iwl_mvm_ftm_get_host_time(mvm,\n\t\t\t\t\t\t\t     fw_ap->timestamp);\n\t\tresult.type = NL80211_PMSR_TYPE_FTM;\n\t\tresult.ftm.burst_index = mvm->ftm_initiator.responses[peer_idx];\n\t\tmvm->ftm_initiator.responses[peer_idx]++;\n\t\tresult.ftm.rssi_avg = fw_ap->rssi;\n\t\tresult.ftm.rssi_avg_valid = 1;\n\t\tresult.ftm.rssi_spread = fw_ap->rssi_spread;\n\t\tresult.ftm.rssi_spread_valid = 1;\n\t\tresult.ftm.rtt_avg = (s32)le32_to_cpu(fw_ap->rtt);\n\t\tresult.ftm.rtt_avg_valid = 1;\n\t\tresult.ftm.rtt_variance = le32_to_cpu(fw_ap->rtt_variance);\n\t\tresult.ftm.rtt_variance_valid = 1;\n\t\tresult.ftm.rtt_spread = le32_to_cpu(fw_ap->rtt_spread);\n\t\tresult.ftm.rtt_spread_valid = 1;\n\n\t\tiwl_mvm_ftm_get_lci_civic(mvm, &result);\n\n\t\tiwl_mvm_ftm_rtt_smoothing(mvm, &result);\n\n\t\tcfg80211_pmsr_report(mvm->ftm_initiator.req_wdev,\n\t\t\t\t     mvm->ftm_initiator.req,\n\t\t\t\t     &result, GFP_KERNEL);\n\n\t\tif (fw_has_api(&mvm->fw->ucode_capa,\n\t\t\t       IWL_UCODE_TLV_API_FTM_RTT_ACCURACY))\n\t\t\tIWL_DEBUG_INFO(mvm, \"RTT confidence: %u\\n\",\n\t\t\t\t       fw_ap->rttConfidence);\n\n\t\tiwl_mvm_debug_range_resp(mvm, i, &result);\n\t}\n\n\tif (last_in_batch) {\n\t\tcfg80211_pmsr_complete(mvm->ftm_initiator.req_wdev,\n\t\t\t\t       mvm->ftm_initiator.req,\n\t\t\t\t       GFP_KERNEL);\n\t\tiwl_mvm_ftm_reset(mvm);\n\t}\n}\n\nvoid iwl_mvm_ftm_lc_notif(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tconst struct ieee80211_mgmt *mgmt = (void *)pkt->data;\n\tsize_t len = iwl_rx_packet_payload_len(pkt);\n\tstruct iwl_mvm_loc_entry *entry;\n\tconst u8 *ies, *lci, *civic, *msr_ie;\n\tsize_t ies_len, lci_len = 0, civic_len = 0;\n\tsize_t baselen = IEEE80211_MIN_ACTION_SIZE +\n\t\t\t sizeof(mgmt->u.action.u.ftm);\n\tstatic const u8 rprt_type_lci = IEEE80211_SPCT_MSR_RPRT_TYPE_LCI;\n\tstatic const u8 rprt_type_civic = IEEE80211_SPCT_MSR_RPRT_TYPE_CIVIC;\n\n\tif (len <= baselen)\n\t\treturn;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\ties = mgmt->u.action.u.ftm.variable;\n\ties_len = len - baselen;\n\n\tmsr_ie = cfg80211_find_ie_match(WLAN_EID_MEASURE_REPORT, ies, ies_len,\n\t\t\t\t\t&rprt_type_lci, 1, 4);\n\tif (msr_ie) {\n\t\tlci = msr_ie + 2;\n\t\tlci_len = msr_ie[1];\n\t}\n\n\tmsr_ie = cfg80211_find_ie_match(WLAN_EID_MEASURE_REPORT, ies, ies_len,\n\t\t\t\t\t&rprt_type_civic, 1, 4);\n\tif (msr_ie) {\n\t\tcivic = msr_ie + 2;\n\t\tcivic_len = msr_ie[1];\n\t}\n\n\tentry = kmalloc(sizeof(*entry) + lci_len + civic_len, GFP_KERNEL);\n\tif (!entry)\n\t\treturn;\n\n\tmemcpy(entry->addr, mgmt->bssid, ETH_ALEN);\n\n\tentry->lci_len = lci_len;\n\tif (lci_len)\n\t\tmemcpy(entry->buf, lci, lci_len);\n\n\tentry->civic_len = civic_len;\n\tif (civic_len)\n\t\tmemcpy(entry->buf + lci_len, civic, civic_len);\n\n\tlist_add_tail(&entry->list, &mvm->ftm_initiator.loc_list);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}