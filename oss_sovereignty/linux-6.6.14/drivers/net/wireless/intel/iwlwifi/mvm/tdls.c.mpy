{
  "module_name": "tdls.c",
  "hash_id": "48af1efc4dd3a08e2a98d0f8711a59ca682f1edbc6b2384373eb1999e7a75687",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/tdls.c",
  "human_readable_source": "\n \n#include <linux/etherdevice.h>\n#include \"mvm.h\"\n#include \"time-event.h\"\n#include \"iwl-io.h\"\n#include \"iwl-prph.h\"\n\n#define TU_TO_US(x) (x * 1024)\n#define TU_TO_MS(x) (TU_TO_US(x) / 1000)\n\nvoid iwl_mvm_teardown_tdls_peers(struct iwl_mvm *mvm)\n{\n\tstruct ieee80211_sta *sta;\n\tstruct iwl_mvm_sta *mvmsta;\n\tint i;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tfor (i = 0; i < mvm->fw->ucode_capa.num_stations; i++) {\n\t\tsta = rcu_dereference_protected(mvm->fw_id_to_mac_id[i],\n\t\t\t\t\t\tlockdep_is_held(&mvm->mutex));\n\t\tif (!sta || IS_ERR(sta) || !sta->tdls)\n\t\t\tcontinue;\n\n\t\tmvmsta = iwl_mvm_sta_from_mac80211(sta);\n\t\tieee80211_tdls_oper_request(mvmsta->vif, sta->addr,\n\t\t\t\tNL80211_TDLS_TEARDOWN,\n\t\t\t\tWLAN_REASON_TDLS_TEARDOWN_UNSPECIFIED,\n\t\t\t\tGFP_KERNEL);\n\t}\n}\n\nint iwl_mvm_tdls_sta_count(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_sta *sta;\n\tstruct iwl_mvm_sta *mvmsta;\n\tint count = 0;\n\tint i;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tfor (i = 0; i < mvm->fw->ucode_capa.num_stations; i++) {\n\t\tsta = rcu_dereference_protected(mvm->fw_id_to_mac_id[i],\n\t\t\t\t\t\tlockdep_is_held(&mvm->mutex));\n\t\tif (!sta || IS_ERR(sta) || !sta->tdls)\n\t\t\tcontinue;\n\n\t\tif (vif) {\n\t\t\tmvmsta = iwl_mvm_sta_from_mac80211(sta);\n\t\t\tif (mvmsta->vif != vif)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nstatic void iwl_mvm_tdls_config(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tstruct iwl_rx_packet *pkt;\n\tstruct iwl_tdls_config_res *resp;\n\tstruct iwl_tdls_config_cmd tdls_cfg_cmd = {};\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = TDLS_CONFIG_CMD,\n\t\t.flags = CMD_WANT_SKB,\n\t\t.data = { &tdls_cfg_cmd, },\n\t\t.len = { sizeof(struct iwl_tdls_config_cmd), },\n\t};\n\tstruct ieee80211_sta *sta;\n\tint ret, i, cnt;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\ttdls_cfg_cmd.id_and_color =\n\t\tcpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id, mvmvif->color));\n\ttdls_cfg_cmd.tx_to_ap_tid = IWL_MVM_TDLS_FW_TID;\n\ttdls_cfg_cmd.tx_to_ap_ssn = cpu_to_le16(0);  \n\n\t \n\n\t \n\tcnt = 0;\n\tfor (i = 0; i < mvm->fw->ucode_capa.num_stations; i++) {\n\t\tsta = rcu_dereference_protected(mvm->fw_id_to_mac_id[i],\n\t\t\t\t\t\tlockdep_is_held(&mvm->mutex));\n\t\tif (IS_ERR_OR_NULL(sta) || !sta->tdls)\n\t\t\tcontinue;\n\n\t\ttdls_cfg_cmd.sta_info[cnt].sta_id = i;\n\t\ttdls_cfg_cmd.sta_info[cnt].tx_to_peer_tid =\n\t\t\t\t\t\t\tIWL_MVM_TDLS_FW_TID;\n\t\ttdls_cfg_cmd.sta_info[cnt].tx_to_peer_ssn = cpu_to_le16(0);\n\t\ttdls_cfg_cmd.sta_info[cnt].is_initiator =\n\t\t\t\tcpu_to_le32(sta->tdls_initiator ? 1 : 0);\n\n\t\tcnt++;\n\t}\n\n\ttdls_cfg_cmd.tdls_peer_count = cnt;\n\tIWL_DEBUG_TDLS(mvm, \"send TDLS config to FW for %d peers\\n\", cnt);\n\n\tret = iwl_mvm_send_cmd(mvm, &cmd);\n\tif (WARN_ON_ONCE(ret))\n\t\treturn;\n\n\tpkt = cmd.resp_pkt;\n\n\tWARN_ON_ONCE(iwl_rx_packet_payload_len(pkt) != sizeof(*resp));\n\n\t \n\n\tiwl_free_resp(&cmd);\n}\n\nvoid iwl_mvm_recalc_tdls_state(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t       bool sta_added)\n{\n\tint tdls_sta_cnt = iwl_mvm_tdls_sta_count(mvm, vif);\n\n\t \n\tif (tdls_sta_cnt == 1 && sta_added)\n\t\tiwl_mvm_power_update_mac(mvm);\n\n\t \n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_TDLS_CHANNEL_SWITCH))\n\t\tiwl_mvm_tdls_config(mvm, vif);\n\n\t \n\tif (tdls_sta_cnt == 0 && !sta_added)\n\t\tiwl_mvm_power_update_mac(mvm);\n}\n\nvoid iwl_mvm_mac_mgd_protect_tdls_discover(struct ieee80211_hw *hw,\n\t\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tu32 duration = 2 * vif->bss_conf.dtim_period * vif->bss_conf.beacon_int;\n\n\t \n\tmutex_lock(&mvm->mutex);\n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_SESSION_PROT_CMD))\n\t\tiwl_mvm_schedule_session_protection(mvm, vif, duration,\n\t\t\t\t\t\t    duration, true);\n\telse\n\t\tiwl_mvm_protect_session(mvm, vif, duration,\n\t\t\t\t\tduration, 100, true);\n\tmutex_unlock(&mvm->mutex);\n}\n\nstatic const char *\niwl_mvm_tdls_cs_state_str(enum iwl_mvm_tdls_cs_state state)\n{\n\tswitch (state) {\n\tcase IWL_MVM_TDLS_SW_IDLE:\n\t\treturn \"IDLE\";\n\tcase IWL_MVM_TDLS_SW_REQ_SENT:\n\t\treturn \"REQ SENT\";\n\tcase IWL_MVM_TDLS_SW_RESP_RCVD:\n\t\treturn \"RESP RECEIVED\";\n\tcase IWL_MVM_TDLS_SW_REQ_RCVD:\n\t\treturn \"REQ RECEIVED\";\n\tcase IWL_MVM_TDLS_SW_ACTIVE:\n\t\treturn \"ACTIVE\";\n\t}\n\n\treturn NULL;\n}\n\nstatic void iwl_mvm_tdls_update_cs_state(struct iwl_mvm *mvm,\n\t\t\t\t\t enum iwl_mvm_tdls_cs_state state)\n{\n\tif (mvm->tdls_cs.state == state)\n\t\treturn;\n\n\tIWL_DEBUG_TDLS(mvm, \"TDLS channel switch state: %s -> %s\\n\",\n\t\t       iwl_mvm_tdls_cs_state_str(mvm->tdls_cs.state),\n\t\t       iwl_mvm_tdls_cs_state_str(state));\n\tmvm->tdls_cs.state = state;\n\n\t \n\tif (state == IWL_MVM_TDLS_SW_REQ_SENT)\n\t\tmvm->tdls_cs.peer.sent_timestamp = iwl_mvm_get_systime(mvm);\n\n\tif (state == IWL_MVM_TDLS_SW_IDLE)\n\t\tmvm->tdls_cs.cur_sta_id = IWL_MVM_INVALID_STA;\n}\n\nvoid iwl_mvm_rx_tdls_notif(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_tdls_channel_switch_notif *notif = (void *)pkt->data;\n\tstruct ieee80211_sta *sta;\n\tunsigned int delay;\n\tstruct iwl_mvm_sta *mvmsta;\n\tstruct ieee80211_vif *vif;\n\tu32 sta_id = le32_to_cpu(notif->sta_id);\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\t \n\tif (!le32_to_cpu(notif->status)) {\n\t\tiwl_mvm_tdls_update_cs_state(mvm, IWL_MVM_TDLS_SW_IDLE);\n\t\treturn;\n\t}\n\n\tif (WARN_ON(sta_id >= mvm->fw->ucode_capa.num_stations))\n\t\treturn;\n\n\tsta = rcu_dereference_protected(mvm->fw_id_to_mac_id[sta_id],\n\t\t\t\t\tlockdep_is_held(&mvm->mutex));\n\t \n\tif (IS_ERR_OR_NULL(sta) || WARN_ON(!sta->tdls))\n\t\treturn;\n\n\tmvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tvif = mvmsta->vif;\n\n\t \n\tdelay = TU_TO_MS(vif->bss_conf.dtim_period * vif->bss_conf.beacon_int);\n\tmod_delayed_work(system_wq, &mvm->tdls_cs.dwork,\n\t\t\t msecs_to_jiffies(delay));\n\n\tiwl_mvm_tdls_update_cs_state(mvm, IWL_MVM_TDLS_SW_ACTIVE);\n}\n\nstatic int\niwl_mvm_tdls_check_action(struct iwl_mvm *mvm,\n\t\t\t  enum iwl_tdls_channel_switch_type type,\n\t\t\t  const u8 *peer, bool peer_initiator, u32 timestamp)\n{\n\tbool same_peer = false;\n\tint ret = 0;\n\n\t \n\tif (mvm->tdls_cs.state != IWL_MVM_TDLS_SW_IDLE &&\n\t    mvm->tdls_cs.cur_sta_id != IWL_MVM_INVALID_STA) {\n\t\tstruct ieee80211_sta *sta = rcu_dereference_protected(\n\t\t\t\tmvm->fw_id_to_mac_id[mvm->tdls_cs.cur_sta_id],\n\t\t\t\tlockdep_is_held(&mvm->mutex));\n\t\tif (!IS_ERR_OR_NULL(sta))\n\t\t\tsame_peer = ether_addr_equal(peer, sta->addr);\n\t}\n\n\tswitch (mvm->tdls_cs.state) {\n\tcase IWL_MVM_TDLS_SW_IDLE:\n\t\t \n\t\tif (type == TDLS_MOVE_CH)\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tcase IWL_MVM_TDLS_SW_REQ_SENT:\n\t\t \n\t\tif (!same_peer)\n\t\t\tret = -EBUSY;\n\t\telse if (type == TDLS_SEND_CHAN_SW_RESP_AND_MOVE_CH &&\n\t\t\t !peer_initiator)\n\t\t\t \n\t\t\tret = -EBUSY;\n\t\telse if (type == TDLS_SEND_CHAN_SW_REQ)\n\t\t\t \n\t\t\tret = -EBUSY;\n\t\telse if (timestamp <= mvm->tdls_cs.peer.sent_timestamp)\n\t\t\t \n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tcase IWL_MVM_TDLS_SW_RESP_RCVD:\n\t\t \n\t\tret = -EBUSY;\n\t\tbreak;\n\tcase IWL_MVM_TDLS_SW_REQ_RCVD:\n\t\t \n\t\tif (type == TDLS_SEND_CHAN_SW_REQ) {\n\t\t\tif (!same_peer)\n\t\t\t\tret = -EBUSY;\n\t\t\telse if (peer_initiator)  \n\t\t\t\tret = -EBUSY;\n\t\t} else if (type == TDLS_MOVE_CH) {\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase IWL_MVM_TDLS_SW_ACTIVE:\n\t\t \n\t\tif (type != TDLS_MOVE_CH || !same_peer)\n\t\t\tret = -EBUSY;\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\tIWL_DEBUG_TDLS(mvm,\n\t\t\t       \"Invalid TDLS action %d state %d peer %pM same_peer %d initiator %d\\n\",\n\t\t\t       type, mvm->tdls_cs.state, peer, same_peer,\n\t\t\t       peer_initiator);\n\n\treturn ret;\n}\n\nstatic int\niwl_mvm_tdls_config_channel_switch(struct iwl_mvm *mvm,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   enum iwl_tdls_channel_switch_type type,\n\t\t\t\t   const u8 *peer, bool peer_initiator,\n\t\t\t\t   u8 oper_class,\n\t\t\t\t   struct cfg80211_chan_def *chandef,\n\t\t\t\t   u32 timestamp, u16 switch_time,\n\t\t\t\t   u16 switch_timeout, struct sk_buff *skb,\n\t\t\t\t   u32 ch_sw_tm_ie)\n{\n\tstruct ieee80211_sta *sta;\n\tstruct iwl_mvm_sta *mvmsta;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_hdr *hdr;\n\tstruct iwl_tdls_channel_switch_cmd cmd = {0};\n\tstruct iwl_tdls_channel_switch_cmd_tail *tail =\n\t\tiwl_mvm_chan_info_cmd_tail(mvm, &cmd.ci);\n\tu16 len = sizeof(cmd) - iwl_mvm_chan_info_padding(mvm);\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tret = iwl_mvm_tdls_check_action(mvm, type, peer, peer_initiator,\n\t\t\t\t\ttimestamp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!skb || WARN_ON(skb->len > IWL_TDLS_CH_SW_FRAME_MAX_SIZE)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcmd.switch_type = type;\n\ttail->timing.frame_timestamp = cpu_to_le32(timestamp);\n\ttail->timing.switch_time = cpu_to_le32(switch_time);\n\ttail->timing.switch_timeout = cpu_to_le32(switch_timeout);\n\n\trcu_read_lock();\n\tsta = ieee80211_find_sta(vif, peer);\n\tif (!sta) {\n\t\trcu_read_unlock();\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tmvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tcmd.peer_sta_id = cpu_to_le32(mvmsta->deflink.sta_id);\n\n\tif (!chandef) {\n\t\tif (mvm->tdls_cs.state == IWL_MVM_TDLS_SW_REQ_SENT &&\n\t\t    mvm->tdls_cs.peer.chandef.chan) {\n\t\t\t \n\t\t\tchandef = &mvm->tdls_cs.peer.chandef;\n\t\t} else if (mvm->tdls_cs.state == IWL_MVM_TDLS_SW_ACTIVE &&\n\t\t\t   type == TDLS_MOVE_CH) {\n\t\t\t \n\t\t\tstruct ieee80211_chanctx_conf *chanctx =\n\t\t\t\t\trcu_dereference(vif->bss_conf.chanctx_conf);\n\n\t\t\tif (WARN_ON_ONCE(!chanctx)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tchandef = &chanctx->def;\n\t\t}\n\t}\n\n\tif (chandef)\n\t\tiwl_mvm_set_chan_info_chandef(mvm, &cmd.ci, chandef);\n\n\t \n\ttail->timing.max_offchan_duration =\n\t\t\tcpu_to_le32(TU_TO_US(vif->bss_conf.dtim_period *\n\t\t\t\t\t     vif->bss_conf.beacon_int) / 2);\n\n\t \n\ttail->frame.switch_time_offset = cpu_to_le32(ch_sw_tm_ie + 2);\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\thdr = (void *)skb->data;\n\tif (info->control.hw_key) {\n\t\tif (info->control.hw_key->cipher != WLAN_CIPHER_SUITE_CCMP) {\n\t\t\trcu_read_unlock();\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tiwl_mvm_set_tx_cmd_ccmp(info, &tail->frame.tx_cmd);\n\t}\n\n\tiwl_mvm_set_tx_cmd(mvm, skb, &tail->frame.tx_cmd, info,\n\t\t\t   mvmsta->deflink.sta_id);\n\n\tiwl_mvm_set_tx_cmd_rate(mvm, &tail->frame.tx_cmd, info, sta,\n\t\t\t\thdr->frame_control);\n\trcu_read_unlock();\n\n\tmemcpy(tail->frame.data, skb->data, skb->len);\n\n\tret = iwl_mvm_send_cmd_pdu(mvm, TDLS_CHANNEL_SWITCH_CMD, 0, len, &cmd);\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"Failed to send TDLS_CHANNEL_SWITCH cmd: %d\\n\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\n\t \n\tif (type != TDLS_MOVE_CH) {\n\t\tmvm->tdls_cs.cur_sta_id = mvmsta->deflink.sta_id;\n\t\tiwl_mvm_tdls_update_cs_state(mvm,\n\t\t\t\t\t     type == TDLS_SEND_CHAN_SW_REQ ?\n\t\t\t\t\t     IWL_MVM_TDLS_SW_REQ_SENT :\n\t\t\t\t\t     IWL_MVM_TDLS_SW_REQ_RCVD);\n\t} else {\n\t\tiwl_mvm_tdls_update_cs_state(mvm, IWL_MVM_TDLS_SW_RESP_RCVD);\n\t}\n\nout:\n\n\t \n\tif (ret)\n\t\tiwl_mvm_tdls_update_cs_state(mvm, IWL_MVM_TDLS_SW_IDLE);\n\n\treturn ret;\n}\n\nvoid iwl_mvm_tdls_ch_switch_work(struct work_struct *work)\n{\n\tstruct iwl_mvm *mvm;\n\tstruct ieee80211_sta *sta;\n\tstruct iwl_mvm_sta *mvmsta;\n\tstruct ieee80211_vif *vif;\n\tunsigned int delay;\n\tint ret;\n\n\tmvm = container_of(work, struct iwl_mvm, tdls_cs.dwork.work);\n\tmutex_lock(&mvm->mutex);\n\n\t \n\tiwl_mvm_tdls_update_cs_state(mvm, IWL_MVM_TDLS_SW_IDLE);\n\n\t \n\tif (mvm->tdls_cs.peer.sta_id == IWL_MVM_INVALID_STA)\n\t\tgoto out;\n\n\tsta = rcu_dereference_protected(\n\t\t\t\tmvm->fw_id_to_mac_id[mvm->tdls_cs.peer.sta_id],\n\t\t\t\tlockdep_is_held(&mvm->mutex));\n\t \n\tif (!sta || IS_ERR(sta) || WARN_ON(!sta->tdls))\n\t\tgoto out;\n\n\tmvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tvif = mvmsta->vif;\n\tret = iwl_mvm_tdls_config_channel_switch(mvm, vif,\n\t\t\t\t\t\t TDLS_SEND_CHAN_SW_REQ,\n\t\t\t\t\t\t sta->addr,\n\t\t\t\t\t\t mvm->tdls_cs.peer.initiator,\n\t\t\t\t\t\t mvm->tdls_cs.peer.op_class,\n\t\t\t\t\t\t &mvm->tdls_cs.peer.chandef,\n\t\t\t\t\t\t 0, 0, 0,\n\t\t\t\t\t\t mvm->tdls_cs.peer.skb,\n\t\t\t\t\t\t mvm->tdls_cs.peer.ch_sw_tm_ie);\n\tif (ret)\n\t\tIWL_ERR(mvm, \"Not sending TDLS channel switch: %d\\n\", ret);\n\n\t \n\tdelay = TU_TO_MS(vif->bss_conf.dtim_period * vif->bss_conf.beacon_int);\n\tschedule_delayed_work(&mvm->tdls_cs.dwork, msecs_to_jiffies(delay));\nout:\n\tmutex_unlock(&mvm->mutex);\n}\n\nint\niwl_mvm_tdls_channel_switch(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_sta *sta, u8 oper_class,\n\t\t\t    struct cfg80211_chan_def *chandef,\n\t\t\t    struct sk_buff *tmpl_skb, u32 ch_sw_tm_ie)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_sta *mvmsta;\n\tunsigned int delay;\n\tint ret;\n\n\tmutex_lock(&mvm->mutex);\n\n\tIWL_DEBUG_TDLS(mvm, \"TDLS channel switch with %pM ch %d width %d\\n\",\n\t\t       sta->addr, chandef->chan->center_freq, chandef->width);\n\n\t \n\tif (mvm->tdls_cs.peer.sta_id != IWL_MVM_INVALID_STA) {\n\t\tIWL_DEBUG_TDLS(mvm,\n\t\t\t       \"Existing peer. Can't start switch with %pM\\n\",\n\t\t\t       sta->addr);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = iwl_mvm_tdls_config_channel_switch(mvm, vif,\n\t\t\t\t\t\t TDLS_SEND_CHAN_SW_REQ,\n\t\t\t\t\t\t sta->addr, sta->tdls_initiator,\n\t\t\t\t\t\t oper_class, chandef, 0, 0, 0,\n\t\t\t\t\t\t tmpl_skb, ch_sw_tm_ie);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tmvm->tdls_cs.peer.skb = skb_copy(tmpl_skb, GFP_KERNEL);\n\tif (!mvm->tdls_cs.peer.skb) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tmvm->tdls_cs.peer.sta_id = mvmsta->deflink.sta_id;\n\tmvm->tdls_cs.peer.chandef = *chandef;\n\tmvm->tdls_cs.peer.initiator = sta->tdls_initiator;\n\tmvm->tdls_cs.peer.op_class = oper_class;\n\tmvm->tdls_cs.peer.ch_sw_tm_ie = ch_sw_tm_ie;\n\n\t \n\tdelay = 2 * TU_TO_MS(vif->bss_conf.dtim_period *\n\t\t\t     vif->bss_conf.beacon_int);\n\tmod_delayed_work(system_wq, &mvm->tdls_cs.dwork,\n\t\t\t msecs_to_jiffies(delay));\n\nout:\n\tmutex_unlock(&mvm->mutex);\n\treturn ret;\n}\n\nvoid iwl_mvm_tdls_cancel_channel_switch(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tstruct ieee80211_sta *sta)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct ieee80211_sta *cur_sta;\n\tbool wait_for_phy = false;\n\n\tmutex_lock(&mvm->mutex);\n\n\tIWL_DEBUG_TDLS(mvm, \"TDLS cancel channel switch with %pM\\n\", sta->addr);\n\n\t \n\tif (mvm->tdls_cs.peer.sta_id == IWL_MVM_INVALID_STA) {\n\t\tIWL_DEBUG_TDLS(mvm, \"No ch switch peer - %pM\\n\", sta->addr);\n\t\tgoto out;\n\t}\n\n\tcur_sta = rcu_dereference_protected(\n\t\t\t\tmvm->fw_id_to_mac_id[mvm->tdls_cs.peer.sta_id],\n\t\t\t\tlockdep_is_held(&mvm->mutex));\n\t \n\tif (cur_sta != sta)\n\t\tgoto out;\n\n\t \n\tif (mvm->tdls_cs.cur_sta_id == mvm->tdls_cs.peer.sta_id &&\n\t    mvm->tdls_cs.state != IWL_MVM_TDLS_SW_IDLE)\n\t\twait_for_phy = true;\n\n\tmvm->tdls_cs.peer.sta_id = IWL_MVM_INVALID_STA;\n\tdev_kfree_skb(mvm->tdls_cs.peer.skb);\n\tmvm->tdls_cs.peer.skb = NULL;\n\nout:\n\tmutex_unlock(&mvm->mutex);\n\n\t \n\tif (wait_for_phy)\n\t\tmsleep(TU_TO_MS(vif->bss_conf.dtim_period *\n\t\t\t\tvif->bss_conf.beacon_int));\n\n\t \n\tflush_delayed_work(&mvm->tdls_cs.dwork);\n\n\tIWL_DEBUG_TDLS(mvm, \"TDLS ending channel switch with %pM\\n\", sta->addr);\n}\n\nvoid\niwl_mvm_tdls_recv_channel_switch(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_tdls_ch_sw_params *params)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tenum iwl_tdls_channel_switch_type type;\n\tunsigned int delay;\n\tconst char *action_str =\n\t\tparams->action_code == WLAN_TDLS_CHANNEL_SWITCH_REQUEST ?\n\t\t\"REQ\" : \"RESP\";\n\n\tmutex_lock(&mvm->mutex);\n\n\tIWL_DEBUG_TDLS(mvm,\n\t\t       \"Received TDLS ch switch action %s from %pM status %d\\n\",\n\t\t       action_str, params->sta->addr, params->status);\n\n\t \n\tif (params->action_code == WLAN_TDLS_CHANNEL_SWITCH_RESPONSE &&\n\t    params->status != 0 &&\n\t    mvm->tdls_cs.state == IWL_MVM_TDLS_SW_REQ_SENT &&\n\t    mvm->tdls_cs.cur_sta_id != IWL_MVM_INVALID_STA) {\n\t\tstruct ieee80211_sta *cur_sta;\n\n\t\t \n\t\tcur_sta = rcu_dereference_protected(\n\t\t\t\tmvm->fw_id_to_mac_id[mvm->tdls_cs.cur_sta_id],\n\t\t\t\tlockdep_is_held(&mvm->mutex));\n\t\tif (cur_sta == params->sta) {\n\t\t\tiwl_mvm_tdls_update_cs_state(mvm,\n\t\t\t\t\t\t     IWL_MVM_TDLS_SW_IDLE);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\ttype = (params->action_code == WLAN_TDLS_CHANNEL_SWITCH_REQUEST) ?\n\t       TDLS_SEND_CHAN_SW_RESP_AND_MOVE_CH : TDLS_MOVE_CH;\n\n\tiwl_mvm_tdls_config_channel_switch(mvm, vif, type, params->sta->addr,\n\t\t\t\t\t   params->sta->tdls_initiator, 0,\n\t\t\t\t\t   params->chandef, params->timestamp,\n\t\t\t\t\t   params->switch_time,\n\t\t\t\t\t   params->switch_timeout,\n\t\t\t\t\t   params->tmpl_skb,\n\t\t\t\t\t   params->ch_sw_tm_ie);\n\nretry:\n\t \n\tdelay = vif->bss_conf.dtim_period * vif->bss_conf.beacon_int *\n\t\t1024 / 1000;\n\tmod_delayed_work(system_wq, &mvm->tdls_cs.dwork,\n\t\t\t msecs_to_jiffies(delay));\n\tmutex_unlock(&mvm->mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}