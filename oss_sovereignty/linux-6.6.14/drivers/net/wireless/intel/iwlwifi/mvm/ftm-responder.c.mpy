{
  "module_name": "ftm-responder.c",
  "hash_id": "676186e2b92a74812104db9e554771d452b25fdd0e6f82ac8b28f9a22c2a3546",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/ftm-responder.c",
  "human_readable_source": "\n \n#include <net/cfg80211.h>\n#include <linux/etherdevice.h>\n#include \"mvm.h\"\n#include \"constants.h\"\n\nstruct iwl_mvm_pasn_sta {\n\tstruct list_head list;\n\tstruct iwl_mvm_int_sta int_sta;\n\tu8 addr[ETH_ALEN];\n};\n\nstruct iwl_mvm_pasn_hltk_data {\n\tu8 *addr;\n\tu8 cipher;\n\tu8 *hltk;\n};\n\nstatic int iwl_mvm_ftm_responder_set_bw_v1(struct cfg80211_chan_def *chandef,\n\t\t\t\t\t   u8 *bw, u8 *ctrl_ch_position)\n{\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\t*bw = IWL_TOF_BW_20_LEGACY;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_20:\n\t\t*bw = IWL_TOF_BW_20_HT;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\t*bw = IWL_TOF_BW_40;\n\t\t*ctrl_ch_position = iwl_mvm_get_ctrl_pos(chandef);\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\t*bw = IWL_TOF_BW_80;\n\t\t*ctrl_ch_position = iwl_mvm_get_ctrl_pos(chandef);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int iwl_mvm_ftm_responder_set_bw_v2(struct cfg80211_chan_def *chandef,\n\t\t\t\t\t   u8 *format_bw, u8 *ctrl_ch_position,\n\t\t\t\t\t   u8 cmd_ver)\n{\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\t*format_bw = IWL_LOCATION_FRAME_FORMAT_LEGACY;\n\t\t*format_bw |= IWL_LOCATION_BW_20MHZ << LOCATION_BW_POS;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_20:\n\t\t*format_bw = IWL_LOCATION_FRAME_FORMAT_HT;\n\t\t*format_bw |= IWL_LOCATION_BW_20MHZ << LOCATION_BW_POS;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\t*format_bw = IWL_LOCATION_FRAME_FORMAT_HT;\n\t\t*format_bw |= IWL_LOCATION_BW_40MHZ << LOCATION_BW_POS;\n\t\t*ctrl_ch_position = iwl_mvm_get_ctrl_pos(chandef);\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\t*format_bw = IWL_LOCATION_FRAME_FORMAT_VHT;\n\t\t*format_bw |= IWL_LOCATION_BW_80MHZ << LOCATION_BW_POS;\n\t\t*ctrl_ch_position = iwl_mvm_get_ctrl_pos(chandef);\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_160:\n\t\tif (cmd_ver >= 9) {\n\t\t\t*format_bw = IWL_LOCATION_FRAME_FORMAT_HE;\n\t\t\t*format_bw |= IWL_LOCATION_BW_160MHZ << LOCATION_BW_POS;\n\t\t\t*ctrl_ch_position = iwl_mvm_get_ctrl_pos(chandef);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic void\niwl_mvm_ftm_responder_set_ndp(struct iwl_mvm *mvm,\n\t\t\t      struct iwl_tof_responder_config_cmd_v9 *cmd)\n{\n\t \n\tu32 r2i_max_sts = IWL_MVM_FTM_R2I_MAX_STS < 2 ?\n\t\tIWL_MVM_FTM_R2I_MAX_STS : 1;\n\n\tcmd->r2i_ndp_params = IWL_MVM_FTM_R2I_MAX_REP |\n\t\t(r2i_max_sts << IWL_RESPONDER_STS_POS) |\n\t\t(IWL_MVM_FTM_R2I_MAX_TOTAL_LTF << IWL_RESPONDER_TOTAL_LTF_POS);\n\tcmd->i2r_ndp_params = IWL_MVM_FTM_I2R_MAX_REP |\n\t\t(IWL_MVM_FTM_I2R_MAX_STS << IWL_RESPONDER_STS_POS) |\n\t\t(IWL_MVM_FTM_I2R_MAX_TOTAL_LTF << IWL_RESPONDER_TOTAL_LTF_POS);\n\tcmd->cmd_valid_fields |=\n\t\tcpu_to_le32(IWL_TOF_RESPONDER_CMD_VALID_NDP_PARAMS);\n}\n\nstatic int\niwl_mvm_ftm_responder_cmd(struct iwl_mvm *mvm,\n\t\t\t  struct ieee80211_vif *vif,\n\t\t\t  struct cfg80211_chan_def *chandef,\n\t\t\t  struct ieee80211_bss_conf *link_conf)\n{\n\tu32 cmd_id = WIDE_ID(LOCATION_GROUP, TOF_RESPONDER_CONFIG_CMD);\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\t \n\tstruct iwl_tof_responder_config_cmd_v9 cmd = {\n\t\t.channel_num = chandef->chan->hw_value,\n\t\t.cmd_valid_fields =\n\t\t\tcpu_to_le32(IWL_TOF_RESPONDER_CMD_VALID_CHAN_INFO |\n\t\t\t\t    IWL_TOF_RESPONDER_CMD_VALID_BSSID |\n\t\t\t\t    IWL_TOF_RESPONDER_CMD_VALID_STA_ID),\n\t\t.sta_id = mvmvif->link[link_conf->link_id]->bcast_sta.sta_id,\n\t};\n\tu8 cmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw, cmd_id, 6);\n\tint err;\n\tint cmd_size;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\t \n\tif (cmd_ver == 9) {\n\t\tcmd.cmd_valid_fields |=\n\t\t\tcpu_to_le32(IWL_TOF_RESPONDER_CMD_VALID_BSS_COLOR |\n\t\t\t\t    IWL_TOF_RESPONDER_CMD_VALID_MIN_MAX_TIME_BETWEEN_MSR);\n\t\tcmd.bss_color = 1;\n\t\tcmd.min_time_between_msr =\n\t\t\tcpu_to_le16(IWL_MVM_FTM_NON_TB_MIN_TIME_BETWEEN_MSR);\n\t\tcmd.max_time_between_msr =\n\t\t\tcpu_to_le16(IWL_MVM_FTM_NON_TB_MAX_TIME_BETWEEN_MSR);\n\t\tcmd_size = sizeof(struct iwl_tof_responder_config_cmd_v9);\n\t} else {\n\t\t \n\t\tcmd_size = sizeof(struct iwl_tof_responder_config_cmd_v8);\n\t}\n\n\tif (cmd_ver >= 8)\n\t\tiwl_mvm_ftm_responder_set_ndp(mvm, &cmd);\n\n\tif (cmd_ver >= 7)\n\t\terr = iwl_mvm_ftm_responder_set_bw_v2(chandef, &cmd.format_bw,\n\t\t\t\t\t\t      &cmd.ctrl_ch_position,\n\t\t\t\t\t\t      cmd_ver);\n\telse\n\t\terr = iwl_mvm_ftm_responder_set_bw_v1(chandef, &cmd.format_bw,\n\t\t\t\t\t\t      &cmd.ctrl_ch_position);\n\n\tif (err) {\n\t\tIWL_ERR(mvm, \"Failed to set responder bandwidth\\n\");\n\t\treturn err;\n\t}\n\n\tmemcpy(cmd.bssid, vif->addr, ETH_ALEN);\n\n\treturn iwl_mvm_send_cmd_pdu(mvm, cmd_id, 0, cmd_size, &cmd);\n}\n\nstatic int\niwl_mvm_ftm_responder_dyn_cfg_v2(struct iwl_mvm *mvm,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_ftm_responder_params *params)\n{\n\tstruct iwl_tof_responder_dyn_config_cmd_v2 cmd = {\n\t\t.lci_len = cpu_to_le32(params->lci_len + 2),\n\t\t.civic_len = cpu_to_le32(params->civicloc_len + 2),\n\t};\n\tu8 data[IWL_LCI_CIVIC_IE_MAX_SIZE] = {0};\n\tstruct iwl_host_cmd hcmd = {\n\t\t.id = WIDE_ID(LOCATION_GROUP, TOF_RESPONDER_DYN_CONFIG_CMD),\n\t\t.data[0] = &cmd,\n\t\t.len[0] = sizeof(cmd),\n\t\t.data[1] = &data,\n\t\t \n\t\t \n\t\t.dataflags[1] = IWL_HCMD_DFL_DUP,\n\t};\n\tu32 aligned_lci_len = ALIGN(params->lci_len + 2, 4);\n\tu32 aligned_civicloc_len = ALIGN(params->civicloc_len + 2, 4);\n\tu8 *pos = data;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (aligned_lci_len + aligned_civicloc_len > sizeof(data)) {\n\t\tIWL_ERR(mvm, \"LCI/civicloc data too big (%zd + %zd)\\n\",\n\t\t\tparams->lci_len, params->civicloc_len);\n\t\treturn -ENOBUFS;\n\t}\n\n\tpos[0] = WLAN_EID_MEASURE_REPORT;\n\tpos[1] = params->lci_len;\n\tmemcpy(pos + 2, params->lci, params->lci_len);\n\n\tpos += aligned_lci_len;\n\tpos[0] = WLAN_EID_MEASURE_REPORT;\n\tpos[1] = params->civicloc_len;\n\tmemcpy(pos + 2, params->civicloc, params->civicloc_len);\n\n\thcmd.len[1] = aligned_lci_len + aligned_civicloc_len;\n\n\treturn iwl_mvm_send_cmd(mvm, &hcmd);\n}\n\nstatic int\niwl_mvm_ftm_responder_dyn_cfg_v3(struct iwl_mvm *mvm,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_ftm_responder_params *params,\n\t\t\t\t struct iwl_mvm_pasn_hltk_data *hltk_data)\n{\n\tstruct iwl_tof_responder_dyn_config_cmd cmd;\n\tstruct iwl_host_cmd hcmd = {\n\t\t.id = WIDE_ID(LOCATION_GROUP, TOF_RESPONDER_DYN_CONFIG_CMD),\n\t\t.data[0] = &cmd,\n\t\t.len[0] = sizeof(cmd),\n\t\t \n\t\t.dataflags[0] = IWL_HCMD_DFL_DUP,\n\t};\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tcmd.valid_flags = 0;\n\n\tif (params) {\n\t\tif (params->lci_len + 2 > sizeof(cmd.lci_buf) ||\n\t\t    params->civicloc_len + 2 > sizeof(cmd.civic_buf)) {\n\t\t\tIWL_ERR(mvm,\n\t\t\t\t\"LCI/civic data too big (lci=%zd, civic=%zd)\\n\",\n\t\t\t\tparams->lci_len, params->civicloc_len);\n\t\t\treturn -ENOBUFS;\n\t\t}\n\n\t\tcmd.lci_buf[0] = WLAN_EID_MEASURE_REPORT;\n\t\tcmd.lci_buf[1] = params->lci_len;\n\t\tmemcpy(cmd.lci_buf + 2, params->lci, params->lci_len);\n\t\tcmd.lci_len = params->lci_len + 2;\n\n\t\tcmd.civic_buf[0] = WLAN_EID_MEASURE_REPORT;\n\t\tcmd.civic_buf[1] = params->civicloc_len;\n\t\tmemcpy(cmd.civic_buf + 2, params->civicloc,\n\t\t       params->civicloc_len);\n\t\tcmd.civic_len = params->civicloc_len + 2;\n\n\t\tcmd.valid_flags |= IWL_RESPONDER_DYN_CFG_VALID_LCI |\n\t\t\tIWL_RESPONDER_DYN_CFG_VALID_CIVIC;\n\t}\n\n\tif (hltk_data) {\n\t\tif (hltk_data->cipher > IWL_LOCATION_CIPHER_GCMP_256) {\n\t\t\tIWL_ERR(mvm, \"invalid cipher: %u\\n\",\n\t\t\t\thltk_data->cipher);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcmd.cipher = hltk_data->cipher;\n\t\tmemcpy(cmd.addr, hltk_data->addr, sizeof(cmd.addr));\n\t\tmemcpy(cmd.hltk_buf, hltk_data->hltk, sizeof(cmd.hltk_buf));\n\t\tcmd.valid_flags |= IWL_RESPONDER_DYN_CFG_VALID_PASN_STA;\n\t}\n\n\treturn iwl_mvm_send_cmd(mvm, &hcmd);\n}\n\nstatic int\niwl_mvm_ftm_responder_dyn_cfg_cmd(struct iwl_mvm *mvm,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_ftm_responder_params *params)\n{\n\tint ret;\n\tu8 cmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw,\n\t\t\t\t\t   WIDE_ID(LOCATION_GROUP, TOF_RESPONDER_DYN_CONFIG_CMD),\n\t\t\t\t\t   2);\n\n\tswitch (cmd_ver) {\n\tcase 2:\n\t\tret = iwl_mvm_ftm_responder_dyn_cfg_v2(mvm, vif,\n\t\t\t\t\t\t       params);\n\t\tbreak;\n\tcase 3:\n\t\tret = iwl_mvm_ftm_responder_dyn_cfg_v3(mvm, vif,\n\t\t\t\t\t\t       params, NULL);\n\t\tbreak;\n\tdefault:\n\t\tIWL_ERR(mvm, \"Unsupported DYN_CONFIG_CMD version %u\\n\",\n\t\t\tcmd_ver);\n\t\tret = -ENOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstatic void iwl_mvm_resp_del_pasn_sta(struct iwl_mvm *mvm,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct iwl_mvm_pasn_sta *sta)\n{\n\tlist_del(&sta->list);\n\n\tif (iwl_mvm_has_mld_api(mvm->fw))\n\t\tiwl_mvm_mld_rm_sta_id(mvm, sta->int_sta.sta_id);\n\telse\n\t\tiwl_mvm_rm_sta_id(mvm, vif, sta->int_sta.sta_id);\n\n\tiwl_mvm_dealloc_int_sta(mvm, &sta->int_sta);\n\tkfree(sta);\n}\n\nint iwl_mvm_ftm_respoder_add_pasn_sta(struct iwl_mvm *mvm,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      u8 *addr, u32 cipher, u8 *tk, u32 tk_len,\n\t\t\t\t      u8 *hltk, u32 hltk_len)\n{\n\tint ret;\n\tstruct iwl_mvm_pasn_sta *sta = NULL;\n\tstruct iwl_mvm_pasn_hltk_data hltk_data = {\n\t\t.addr = addr,\n\t\t.hltk = hltk,\n\t};\n\tstruct iwl_mvm_pasn_hltk_data *hltk_data_ptr = NULL;\n\n\tu8 cmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw,\n\t\t\t\t\t   WIDE_ID(LOCATION_GROUP, TOF_RESPONDER_DYN_CONFIG_CMD),\n\t\t\t\t\t   2);\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (cmd_ver < 3) {\n\t\tIWL_ERR(mvm, \"Adding PASN station not supported by FW\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif ((!hltk || !hltk_len) && (!tk || !tk_len)) {\n\t\tIWL_ERR(mvm, \"TK and HLTK not set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hltk && hltk_len) {\n\t\thltk_data.cipher = iwl_mvm_cipher_to_location_cipher(cipher);\n\t\tif (hltk_data.cipher == IWL_LOCATION_CIPHER_INVALID) {\n\t\t\tIWL_ERR(mvm, \"invalid cipher: %u\\n\", cipher);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\thltk_data_ptr = &hltk_data;\n\t}\n\n\tif (tk && tk_len) {\n\t\tsta = kzalloc(sizeof(*sta), GFP_KERNEL);\n\t\tif (!sta)\n\t\t\treturn -ENOBUFS;\n\n\t\tret = iwl_mvm_add_pasn_sta(mvm, vif, &sta->int_sta, addr,\n\t\t\t\t\t   cipher, tk, tk_len);\n\t\tif (ret) {\n\t\t\tkfree(sta);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmemcpy(sta->addr, addr, ETH_ALEN);\n\t\tlist_add_tail(&sta->list, &mvm->resp_pasn_list);\n\t}\n\n\tret = iwl_mvm_ftm_responder_dyn_cfg_v3(mvm, vif, NULL, hltk_data_ptr);\n\tif (ret && sta)\n\t\tiwl_mvm_resp_del_pasn_sta(mvm, vif, sta);\n\n\treturn ret;\n}\n\nint iwl_mvm_ftm_resp_remove_pasn_sta(struct iwl_mvm *mvm,\n\t\t\t\t     struct ieee80211_vif *vif, u8 *addr)\n{\n\tstruct iwl_mvm_pasn_sta *sta, *prev;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tlist_for_each_entry_safe(sta, prev, &mvm->resp_pasn_list, list) {\n\t\tif (!memcmp(sta->addr, addr, ETH_ALEN)) {\n\t\t\tiwl_mvm_resp_del_pasn_sta(mvm, vif, sta);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tIWL_ERR(mvm, \"FTM: PASN station %pM not found\\n\", addr);\n\treturn -EINVAL;\n}\n\nint iwl_mvm_ftm_start_responder(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_bss_conf *bss_conf)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct ieee80211_ftm_responder_params *params;\n\tstruct ieee80211_chanctx_conf ctx, *pctx;\n\tu16 *phy_ctxt_id;\n\tstruct iwl_mvm_phy_ctxt *phy_ctxt;\n\tint ret;\n\n\tparams = bss_conf->ftmr_params;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (WARN_ON_ONCE(!bss_conf->ftm_responder))\n\t\treturn -EINVAL;\n\n\tif (vif->p2p || vif->type != NL80211_IFTYPE_AP ||\n\t    !mvmvif->ap_ibss_active) {\n\t\tIWL_ERR(mvm, \"Cannot start responder, not in AP mode\\n\");\n\t\treturn -EIO;\n\t}\n\n\trcu_read_lock();\n\tpctx = rcu_dereference(bss_conf->chanctx_conf);\n\t \n\tctx = *pctx;\n\tphy_ctxt_id  = (u16 *)pctx->drv_priv;\n\trcu_read_unlock();\n\n\tphy_ctxt = &mvm->phy_ctxts[*phy_ctxt_id];\n\tret = iwl_mvm_phy_ctxt_changed(mvm, phy_ctxt, &ctx.def,\n\t\t\t\t       ctx.rx_chains_static,\n\t\t\t\t       ctx.rx_chains_dynamic);\n\tif (ret)\n\t\treturn ret;\n\n\tret = iwl_mvm_ftm_responder_cmd(mvm, vif, &ctx.def, bss_conf);\n\tif (ret)\n\t\treturn ret;\n\n\tif (params)\n\t\tret = iwl_mvm_ftm_responder_dyn_cfg_cmd(mvm, vif, params);\n\n\treturn ret;\n}\n\nvoid iwl_mvm_ftm_responder_clear(struct iwl_mvm *mvm,\n\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_pasn_sta *sta, *prev;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tlist_for_each_entry_safe(sta, prev, &mvm->resp_pasn_list, list)\n\t\tiwl_mvm_resp_del_pasn_sta(mvm, vif, sta);\n}\n\nvoid iwl_mvm_ftm_restart_responder(struct iwl_mvm *mvm,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_bss_conf *bss_conf)\n{\n\tif (!bss_conf->ftm_responder)\n\t\treturn;\n\n\tiwl_mvm_ftm_responder_clear(mvm, vif);\n\tiwl_mvm_ftm_start_responder(mvm, vif, bss_conf);\n}\n\nvoid iwl_mvm_ftm_responder_stats(struct iwl_mvm *mvm,\n\t\t\t\t struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_ftm_responder_stats *resp = (void *)pkt->data;\n\tstruct cfg80211_ftm_responder_stats *stats = &mvm->ftm_resp_stats;\n\tu32 flags = le32_to_cpu(resp->flags);\n\n\tif (resp->success_ftm == resp->ftm_per_burst)\n\t\tstats->success_num++;\n\telse if (resp->success_ftm >= 2)\n\t\tstats->partial_num++;\n\telse\n\t\tstats->failed_num++;\n\n\tif ((flags & FTM_RESP_STAT_ASAP_REQ) &&\n\t    (flags & FTM_RESP_STAT_ASAP_RESP))\n\t\tstats->asap_num++;\n\n\tif (flags & FTM_RESP_STAT_NON_ASAP_RESP)\n\t\tstats->non_asap_num++;\n\n\tstats->total_duration_ms += le32_to_cpu(resp->duration) / USEC_PER_MSEC;\n\n\tif (flags & FTM_RESP_STAT_TRIGGER_UNKNOWN)\n\t\tstats->unknown_triggers_num++;\n\n\tif (flags & FTM_RESP_STAT_DUP)\n\t\tstats->reschedule_requests_num++;\n\n\tif (flags & FTM_RESP_STAT_NON_ASAP_OUT_WIN)\n\t\tstats->out_of_window_triggers_num++;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}