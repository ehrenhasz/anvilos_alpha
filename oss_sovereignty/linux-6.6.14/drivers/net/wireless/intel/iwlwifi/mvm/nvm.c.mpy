{
  "module_name": "nvm.c",
  "hash_id": "93578f0ca75f596338188cc8f654911bf31e51200826d875683617903e86096e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/nvm.c",
  "human_readable_source": "\n \n#include <linux/firmware.h>\n#include <linux/rtnetlink.h>\n#include \"iwl-trans.h\"\n#include \"iwl-csr.h\"\n#include \"mvm.h\"\n#include \"iwl-eeprom-parse.h\"\n#include \"iwl-eeprom-read.h\"\n#include \"iwl-nvm-parse.h\"\n#include \"iwl-prph.h\"\n#include \"fw/acpi.h\"\n\n \n#define IWL_NVM_DEFAULT_CHUNK_SIZE (2 * 1024)\n\n#define NVM_WRITE_OPCODE 1\n#define NVM_READ_OPCODE 0\n\n \nenum {\n\tREAD_NVM_CHUNK_SUCCEED = 0,\n\tREAD_NVM_CHUNK_NOT_VALID_ADDRESS = 1\n};\n\n \nstatic int iwl_nvm_write_chunk(struct iwl_mvm *mvm, u16 section,\n\t\t\t       u16 offset, u16 length, const u8 *data)\n{\n\tstruct iwl_nvm_access_cmd nvm_access_cmd = {\n\t\t.offset = cpu_to_le16(offset),\n\t\t.length = cpu_to_le16(length),\n\t\t.type = cpu_to_le16(section),\n\t\t.op_code = NVM_WRITE_OPCODE,\n\t};\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = NVM_ACCESS_CMD,\n\t\t.len = { sizeof(struct iwl_nvm_access_cmd), length },\n\t\t.flags = CMD_WANT_SKB | CMD_SEND_IN_RFKILL,\n\t\t.data = { &nvm_access_cmd, data },\n\t\t \n\t\t.dataflags = { 0, IWL_HCMD_DFL_DUP },\n\t};\n\tstruct iwl_rx_packet *pkt;\n\tstruct iwl_nvm_access_resp *nvm_resp;\n\tint ret;\n\n\tret = iwl_mvm_send_cmd(mvm, &cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tpkt = cmd.resp_pkt;\n\t \n\tnvm_resp = (void *)pkt->data;\n\tif (le16_to_cpu(nvm_resp->status) != READ_NVM_CHUNK_SUCCEED) {\n\t\tIWL_ERR(mvm,\n\t\t\t\"NVM access write command failed for section %u (status = 0x%x)\\n\",\n\t\t\tsection, le16_to_cpu(nvm_resp->status));\n\t\tret = -EIO;\n\t}\n\n\tiwl_free_resp(&cmd);\n\treturn ret;\n}\n\nstatic int iwl_nvm_read_chunk(struct iwl_mvm *mvm, u16 section,\n\t\t\t      u16 offset, u16 length, u8 *data)\n{\n\tstruct iwl_nvm_access_cmd nvm_access_cmd = {\n\t\t.offset = cpu_to_le16(offset),\n\t\t.length = cpu_to_le16(length),\n\t\t.type = cpu_to_le16(section),\n\t\t.op_code = NVM_READ_OPCODE,\n\t};\n\tstruct iwl_nvm_access_resp *nvm_resp;\n\tstruct iwl_rx_packet *pkt;\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = NVM_ACCESS_CMD,\n\t\t.flags = CMD_WANT_SKB | CMD_SEND_IN_RFKILL,\n\t\t.data = { &nvm_access_cmd, },\n\t};\n\tint ret, bytes_read, offset_read;\n\tu8 *resp_data;\n\n\tcmd.len[0] = sizeof(struct iwl_nvm_access_cmd);\n\n\tret = iwl_mvm_send_cmd(mvm, &cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tpkt = cmd.resp_pkt;\n\n\t \n\tnvm_resp = (void *)pkt->data;\n\tret = le16_to_cpu(nvm_resp->status);\n\tbytes_read = le16_to_cpu(nvm_resp->length);\n\toffset_read = le16_to_cpu(nvm_resp->offset);\n\tresp_data = nvm_resp->data;\n\tif (ret) {\n\t\tif ((offset != 0) &&\n\t\t    (ret == READ_NVM_CHUNK_NOT_VALID_ADDRESS)) {\n\t\t\t \n\t\t\tIWL_DEBUG_EEPROM(mvm->trans->dev,\n\t\t\t\t\t \"NVM access command failed on offset 0x%x since that section size is multiple 2K\\n\",\n\t\t\t\t\t offset);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tIWL_DEBUG_EEPROM(mvm->trans->dev,\n\t\t\t\t\t \"NVM access command failed with status %d (device: %s)\\n\",\n\t\t\t\t\t ret, mvm->trans->name);\n\t\t\tret = -ENODATA;\n\t\t}\n\t\tgoto exit;\n\t}\n\n\tif (offset_read != offset) {\n\t\tIWL_ERR(mvm, \"NVM ACCESS response with invalid offset %d\\n\",\n\t\t\toffset_read);\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t \n\tmemcpy(data + offset, resp_data, bytes_read);\n\tret = bytes_read;\n\nexit:\n\tiwl_free_resp(&cmd);\n\treturn ret;\n}\n\nstatic int iwl_nvm_write_section(struct iwl_mvm *mvm, u16 section,\n\t\t\t\t const u8 *data, u16 length)\n{\n\tint offset = 0;\n\n\t \n\n\twhile (offset < length) {\n\t\tint chunk_size, ret;\n\n\t\tchunk_size = min(IWL_NVM_DEFAULT_CHUNK_SIZE,\n\t\t\t\t length - offset);\n\n\t\tret = iwl_nvm_write_chunk(mvm, section, offset,\n\t\t\t\t\t  chunk_size, data + offset);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\toffset += chunk_size;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int iwl_nvm_read_section(struct iwl_mvm *mvm, u16 section,\n\t\t\t\tu8 *data, u32 size_read)\n{\n\tu16 length, offset = 0;\n\tint ret;\n\n\t \n\tlength = IWL_NVM_DEFAULT_CHUNK_SIZE;\n\n\tret = length;\n\n\t \n\twhile (ret == length) {\n\t\t \n\t\tif ((size_read + offset + length) >\n\t\t    mvm->trans->trans_cfg->base_params->eeprom_size) {\n\t\t\tIWL_ERR(mvm, \"EEPROM size is too small for NVM\\n\");\n\t\t\treturn -ENOBUFS;\n\t\t}\n\n\t\tret = iwl_nvm_read_chunk(mvm, section, offset, length, data);\n\t\tif (ret < 0) {\n\t\t\tIWL_DEBUG_EEPROM(mvm->trans->dev,\n\t\t\t\t\t \"Cannot read NVM from section %d offset %d, length %d\\n\",\n\t\t\t\t\t section, offset, length);\n\t\t\treturn ret;\n\t\t}\n\t\toffset += ret;\n\t}\n\n\tiwl_nvm_fixups(mvm->trans->hw_id, section, data, offset);\n\n\tIWL_DEBUG_EEPROM(mvm->trans->dev,\n\t\t\t \"NVM section %d read completed\\n\", section);\n\treturn offset;\n}\n\nstatic struct iwl_nvm_data *\niwl_parse_nvm_sections(struct iwl_mvm *mvm)\n{\n\tstruct iwl_nvm_section *sections = mvm->nvm_sections;\n\tconst __be16 *hw;\n\tconst __le16 *sw, *calib, *regulatory, *mac_override, *phy_sku;\n\tint regulatory_type;\n\n\t \n\tif (mvm->trans->cfg->nvm_type == IWL_NVM) {\n\t\tif (!mvm->nvm_sections[NVM_SECTION_TYPE_SW].data ||\n\t\t    !mvm->nvm_sections[mvm->cfg->nvm_hw_section_num].data) {\n\t\t\tIWL_ERR(mvm, \"Can't parse empty OTP/NVM sections\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tif (mvm->trans->cfg->nvm_type == IWL_NVM_SDP)\n\t\t\tregulatory_type = NVM_SECTION_TYPE_REGULATORY_SDP;\n\t\telse\n\t\t\tregulatory_type = NVM_SECTION_TYPE_REGULATORY;\n\n\t\t \n\t\tif (!mvm->nvm_sections[NVM_SECTION_TYPE_SW].data ||\n\t\t    !mvm->nvm_sections[regulatory_type].data) {\n\t\t\tIWL_ERR(mvm,\n\t\t\t\t\"Can't parse empty family 8000 OTP/NVM sections\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\t \n\t\tif (!mvm->nvm_sections[mvm->cfg->nvm_hw_section_num].data &&\n\t\t    !mvm->nvm_sections[NVM_SECTION_TYPE_MAC_OVERRIDE].data) {\n\t\t\tIWL_ERR(mvm,\n\t\t\t\t\"Can't parse mac_address, empty sections\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tif (mvm->trans->cfg->nvm_type == IWL_NVM_EXT &&\n\t\t    !mvm->nvm_sections[NVM_SECTION_TYPE_PHY_SKU].data) {\n\t\t\tIWL_ERR(mvm,\n\t\t\t\t\"Can't parse phy_sku in B0, empty sections\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\thw = (const __be16 *)sections[mvm->cfg->nvm_hw_section_num].data;\n\tsw = (const __le16 *)sections[NVM_SECTION_TYPE_SW].data;\n\tcalib = (const __le16 *)sections[NVM_SECTION_TYPE_CALIBRATION].data;\n\tmac_override =\n\t\t(const __le16 *)sections[NVM_SECTION_TYPE_MAC_OVERRIDE].data;\n\tphy_sku = (const __le16 *)sections[NVM_SECTION_TYPE_PHY_SKU].data;\n\n\tregulatory = mvm->trans->cfg->nvm_type == IWL_NVM_SDP ?\n\t\t(const __le16 *)sections[NVM_SECTION_TYPE_REGULATORY_SDP].data :\n\t\t(const __le16 *)sections[NVM_SECTION_TYPE_REGULATORY].data;\n\n\treturn iwl_parse_nvm_data(mvm->trans, mvm->cfg, mvm->fw, hw, sw, calib,\n\t\t\t\t  regulatory, mac_override, phy_sku,\n\t\t\t\t  mvm->fw->valid_tx_ant, mvm->fw->valid_rx_ant);\n}\n\n \nint iwl_mvm_load_nvm_to_nic(struct iwl_mvm *mvm)\n{\n\tint i, ret = 0;\n\tstruct iwl_nvm_section *sections = mvm->nvm_sections;\n\n\tIWL_DEBUG_EEPROM(mvm->trans->dev, \"'Write to NVM\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(mvm->nvm_sections); i++) {\n\t\tif (!mvm->nvm_sections[i].data || !mvm->nvm_sections[i].length)\n\t\t\tcontinue;\n\t\tret = iwl_nvm_write_section(mvm, i, sections[i].data,\n\t\t\t\t\t    sections[i].length);\n\t\tif (ret < 0) {\n\t\t\tIWL_ERR(mvm, \"iwl_mvm_send_cmd failed: %d\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint iwl_nvm_init(struct iwl_mvm *mvm)\n{\n\tint ret, section;\n\tu32 size_read = 0;\n\tu8 *nvm_buffer, *temp;\n\tconst char *nvm_file_C = mvm->cfg->default_nvm_file_C_step;\n\n\tif (WARN_ON_ONCE(mvm->cfg->nvm_hw_section_num >= NVM_MAX_NUM_SECTIONS))\n\t\treturn -EINVAL;\n\n\t \n\t \n\tIWL_DEBUG_EEPROM(mvm->trans->dev, \"Read from NVM\\n\");\n\n\tnvm_buffer = kmalloc(mvm->trans->trans_cfg->base_params->eeprom_size,\n\t\t\t     GFP_KERNEL);\n\tif (!nvm_buffer)\n\t\treturn -ENOMEM;\n\tfor (section = 0; section < NVM_MAX_NUM_SECTIONS; section++) {\n\t\t \n\t\tret = iwl_nvm_read_section(mvm, section, nvm_buffer,\n\t\t\t\t\t   size_read);\n\t\tif (ret == -ENODATA) {\n\t\t\tret = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tsize_read += ret;\n\t\ttemp = kmemdup(nvm_buffer, ret, GFP_KERNEL);\n\t\tif (!temp) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tiwl_nvm_fixups(mvm->trans->hw_id, section, temp, ret);\n\n\t\tmvm->nvm_sections[section].data = temp;\n\t\tmvm->nvm_sections[section].length = ret;\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\t\tswitch (section) {\n\t\tcase NVM_SECTION_TYPE_SW:\n\t\t\tmvm->nvm_sw_blob.data = temp;\n\t\t\tmvm->nvm_sw_blob.size  = ret;\n\t\t\tbreak;\n\t\tcase NVM_SECTION_TYPE_CALIBRATION:\n\t\t\tmvm->nvm_calib_blob.data = temp;\n\t\t\tmvm->nvm_calib_blob.size  = ret;\n\t\t\tbreak;\n\t\tcase NVM_SECTION_TYPE_PRODUCTION:\n\t\t\tmvm->nvm_prod_blob.data = temp;\n\t\t\tmvm->nvm_prod_blob.size  = ret;\n\t\t\tbreak;\n\t\tcase NVM_SECTION_TYPE_PHY_SKU:\n\t\t\tmvm->nvm_phy_sku_blob.data = temp;\n\t\t\tmvm->nvm_phy_sku_blob.size  = ret;\n\t\t\tbreak;\n\t\tcase NVM_SECTION_TYPE_REGULATORY_SDP:\n\t\tcase NVM_SECTION_TYPE_REGULATORY:\n\t\t\tmvm->nvm_reg_blob.data = temp;\n\t\t\tmvm->nvm_reg_blob.size  = ret;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (section == mvm->cfg->nvm_hw_section_num) {\n\t\t\t\tmvm->nvm_hw_blob.data = temp;\n\t\t\t\tmvm->nvm_hw_blob.size = ret;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tif (!size_read)\n\t\tIWL_ERR(mvm, \"OTP is blank\\n\");\n\tkfree(nvm_buffer);\n\n\t \n\tif (mvm->nvm_file_name) {\n\t\t \n\t\tret = iwl_read_external_nvm(mvm->trans, mvm->nvm_file_name,\n\t\t\t\t\t    mvm->nvm_sections);\n\t\tif (ret) {\n\t\t\tmvm->nvm_file_name = nvm_file_C;\n\n\t\t\tif ((ret == -EFAULT || ret == -ENOENT) &&\n\t\t\t    mvm->nvm_file_name) {\n\t\t\t\t \n\t\t\t\tret = iwl_read_external_nvm(mvm->trans,\n\t\t\t\t\t\t\t    mvm->nvm_file_name,\n\t\t\t\t\t\t\t    mvm->nvm_sections);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tmvm->nvm_data = iwl_parse_nvm_sections(mvm);\n\tif (!mvm->nvm_data)\n\t\treturn -ENODATA;\n\tIWL_DEBUG_EEPROM(mvm->trans->dev, \"nvm version = %x\\n\",\n\t\t\t mvm->nvm_data->nvm_version);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstruct iwl_mcc_update_resp_v8 *\niwl_mvm_update_mcc(struct iwl_mvm *mvm, const char *alpha2,\n\t\t   enum iwl_mcc_source src_id)\n{\n\tstruct iwl_mcc_update_cmd mcc_update_cmd = {\n\t\t.mcc = cpu_to_le16(alpha2[0] << 8 | alpha2[1]),\n\t\t.source_id = (u8)src_id,\n\t};\n\tstruct iwl_mcc_update_resp_v8 *resp_cp;\n\tstruct iwl_rx_packet *pkt;\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = MCC_UPDATE_CMD,\n\t\t.flags = CMD_WANT_SKB | CMD_SEND_IN_RFKILL,\n\t\t.data = { &mcc_update_cmd },\n\t};\n\n\tint ret, resp_ver;\n\tu32 status;\n\tint resp_len, n_channels;\n\tu16 mcc;\n\n\tif (WARN_ON_ONCE(!iwl_mvm_is_lar_supported(mvm)))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tcmd.len[0] = sizeof(struct iwl_mcc_update_cmd);\n\n\tIWL_DEBUG_LAR(mvm, \"send MCC update to FW with '%c%c' src = %d\\n\",\n\t\t      alpha2[0], alpha2[1], src_id);\n\n\tret = iwl_mvm_send_cmd(mvm, &cmd);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tpkt = cmd.resp_pkt;\n\n\tresp_ver = iwl_fw_lookup_notif_ver(mvm->fw, IWL_ALWAYS_LONG_GROUP,\n\t\t\t\t\t   MCC_UPDATE_CMD, 0);\n\n\t \n\tif (resp_ver >= 8) {\n\t\tstruct iwl_mcc_update_resp_v8 *mcc_resp_v8 = (void *)pkt->data;\n\n\t\tn_channels =  __le32_to_cpu(mcc_resp_v8->n_channels);\n\t\tif (iwl_rx_packet_payload_len(pkt) !=\n\t\t    struct_size(mcc_resp_v8, channels, n_channels)) {\n\t\t\tresp_cp = ERR_PTR(-EINVAL);\n\t\t\tgoto exit;\n\t\t}\n\t\tresp_len = struct_size(resp_cp, channels, n_channels);\n\t\tresp_cp = kzalloc(resp_len, GFP_KERNEL);\n\t\tif (!resp_cp) {\n\t\t\tresp_cp = ERR_PTR(-ENOMEM);\n\t\t\tgoto exit;\n\t\t}\n\t\tresp_cp->status = mcc_resp_v8->status;\n\t\tresp_cp->mcc = mcc_resp_v8->mcc;\n\t\tresp_cp->cap = mcc_resp_v8->cap;\n\t\tresp_cp->source_id = mcc_resp_v8->source_id;\n\t\tresp_cp->time = mcc_resp_v8->time;\n\t\tresp_cp->geo_info = mcc_resp_v8->geo_info;\n\t\tresp_cp->n_channels = mcc_resp_v8->n_channels;\n\t\tmemcpy(resp_cp->channels, mcc_resp_v8->channels,\n\t\t       n_channels * sizeof(__le32));\n\t} else if (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t       IWL_UCODE_TLV_CAPA_MCC_UPDATE_11AX_SUPPORT)) {\n\t\tstruct iwl_mcc_update_resp_v4 *mcc_resp_v4 = (void *)pkt->data;\n\n\t\tn_channels =  __le32_to_cpu(mcc_resp_v4->n_channels);\n\t\tif (iwl_rx_packet_payload_len(pkt) !=\n\t\t    struct_size(mcc_resp_v4, channels, n_channels)) {\n\t\t\tresp_cp = ERR_PTR(-EINVAL);\n\t\t\tgoto exit;\n\t\t}\n\t\tresp_len = struct_size(resp_cp, channels, n_channels);\n\t\tresp_cp = kzalloc(resp_len, GFP_KERNEL);\n\t\tif (!resp_cp) {\n\t\t\tresp_cp = ERR_PTR(-ENOMEM);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tresp_cp->status = mcc_resp_v4->status;\n\t\tresp_cp->mcc = mcc_resp_v4->mcc;\n\t\tresp_cp->cap = cpu_to_le32(le16_to_cpu(mcc_resp_v4->cap));\n\t\tresp_cp->source_id = mcc_resp_v4->source_id;\n\t\tresp_cp->time = mcc_resp_v4->time;\n\t\tresp_cp->geo_info = mcc_resp_v4->geo_info;\n\t\tresp_cp->n_channels = mcc_resp_v4->n_channels;\n\t\tmemcpy(resp_cp->channels, mcc_resp_v4->channels,\n\t\t       n_channels * sizeof(__le32));\n\t} else {\n\t\tstruct iwl_mcc_update_resp_v3 *mcc_resp_v3 = (void *)pkt->data;\n\n\t\tn_channels =  __le32_to_cpu(mcc_resp_v3->n_channels);\n\t\tif (iwl_rx_packet_payload_len(pkt) !=\n\t\t    struct_size(mcc_resp_v3, channels, n_channels)) {\n\t\t\tresp_cp = ERR_PTR(-EINVAL);\n\t\t\tgoto exit;\n\t\t}\n\t\tresp_len = struct_size(resp_cp, channels, n_channels);\n\t\tresp_cp = kzalloc(resp_len, GFP_KERNEL);\n\t\tif (!resp_cp) {\n\t\t\tresp_cp = ERR_PTR(-ENOMEM);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tresp_cp->status = mcc_resp_v3->status;\n\t\tresp_cp->mcc = mcc_resp_v3->mcc;\n\t\tresp_cp->cap = cpu_to_le32(mcc_resp_v3->cap);\n\t\tresp_cp->source_id = mcc_resp_v3->source_id;\n\t\tresp_cp->time = mcc_resp_v3->time;\n\t\tresp_cp->geo_info = mcc_resp_v3->geo_info;\n\t\tresp_cp->n_channels = mcc_resp_v3->n_channels;\n\t\tmemcpy(resp_cp->channels, mcc_resp_v3->channels,\n\t\t       n_channels * sizeof(__le32));\n\t}\n\n\tstatus = le32_to_cpu(resp_cp->status);\n\n\tmcc = le16_to_cpu(resp_cp->mcc);\n\n\t \n\tif (mcc == 0) {\n\t\tmcc = 0x3030;   \n\t\tresp_cp->mcc = cpu_to_le16(mcc);\n\t}\n\n\tIWL_DEBUG_LAR(mvm,\n\t\t      \"MCC response status: 0x%x. new MCC: 0x%x ('%c%c') n_chans: %d\\n\",\n\t\t      status, mcc, mcc >> 8, mcc & 0xff, n_channels);\n\nexit:\n\tiwl_free_resp(&cmd);\n\treturn resp_cp;\n}\n\nint iwl_mvm_init_mcc(struct iwl_mvm *mvm)\n{\n\tbool tlv_lar;\n\tbool nvm_lar;\n\tint retval;\n\tstruct ieee80211_regdomain *regd;\n\tchar mcc[3];\n\n\tif (mvm->cfg->nvm_type == IWL_NVM_EXT) {\n\t\ttlv_lar = fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t\t      IWL_UCODE_TLV_CAPA_LAR_SUPPORT);\n\t\tnvm_lar = mvm->nvm_data->lar_enabled;\n\t\tif (tlv_lar != nvm_lar)\n\t\t\tIWL_INFO(mvm,\n\t\t\t\t \"Conflict between TLV & NVM regarding enabling LAR (TLV = %s NVM =%s)\\n\",\n\t\t\t\t tlv_lar ? \"enabled\" : \"disabled\",\n\t\t\t\t nvm_lar ? \"enabled\" : \"disabled\");\n\t}\n\n\tif (!iwl_mvm_is_lar_supported(mvm))\n\t\treturn 0;\n\n\t \n\tretval = iwl_mvm_init_fw_regd(mvm);\n\tif (retval != -ENOENT)\n\t\treturn retval;\n\n\t \n\tmvm->lar_regdom_set = false;\n\n\tregd = iwl_mvm_get_current_regdomain(mvm, NULL);\n\tif (IS_ERR_OR_NULL(regd))\n\t\treturn -EIO;\n\n\tif (iwl_mvm_is_wifi_mcc_supported(mvm) &&\n\t    !iwl_acpi_get_mcc(mvm->dev, mcc)) {\n\t\tkfree(regd);\n\t\tregd = iwl_mvm_get_regdomain(mvm->hw->wiphy, mcc,\n\t\t\t\t\t     MCC_SOURCE_BIOS, NULL);\n\t\tif (IS_ERR_OR_NULL(regd))\n\t\t\treturn -EIO;\n\t}\n\n\tretval = regulatory_set_wiphy_regd_sync(mvm->hw->wiphy, regd);\n\tkfree(regd);\n\treturn retval;\n}\n\nvoid iwl_mvm_rx_chub_update_mcc(struct iwl_mvm *mvm,\n\t\t\t\tstruct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_mcc_chub_notif *notif = (void *)pkt->data;\n\tenum iwl_mcc_source src;\n\tchar mcc[3];\n\tstruct ieee80211_regdomain *regd;\n\tint wgds_tbl_idx;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (iwl_mvm_is_vif_assoc(mvm) && notif->source_id == MCC_SOURCE_WIFI) {\n\t\tIWL_DEBUG_LAR(mvm, \"Ignore mcc update while associated\\n\");\n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(!iwl_mvm_is_lar_supported(mvm)))\n\t\treturn;\n\n\tmcc[0] = le16_to_cpu(notif->mcc) >> 8;\n\tmcc[1] = le16_to_cpu(notif->mcc) & 0xff;\n\tmcc[2] = '\\0';\n\tsrc = notif->source_id;\n\n\tIWL_DEBUG_LAR(mvm,\n\t\t      \"RX: received chub update mcc cmd (mcc '%s' src %d)\\n\",\n\t\t      mcc, src);\n\tregd = iwl_mvm_get_regdomain(mvm->hw->wiphy, mcc, src, NULL);\n\tif (IS_ERR_OR_NULL(regd))\n\t\treturn;\n\n\twgds_tbl_idx = iwl_mvm_get_sar_geo_profile(mvm);\n\tif (wgds_tbl_idx < 1)\n\t\tIWL_DEBUG_INFO(mvm,\n\t\t\t       \"SAR WGDS is disabled or error received (%d)\\n\",\n\t\t\t       wgds_tbl_idx);\n\telse\n\t\tIWL_DEBUG_INFO(mvm, \"SAR WGDS: geo profile %d is configured\\n\",\n\t\t\t       wgds_tbl_idx);\n\n\tregulatory_set_wiphy_regd(mvm->hw->wiphy, regd);\n\tkfree(regd);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}