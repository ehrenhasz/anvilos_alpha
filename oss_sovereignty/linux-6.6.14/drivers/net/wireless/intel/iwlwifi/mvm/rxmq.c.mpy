{
  "module_name": "rxmq.c",
  "hash_id": "80cbfc77aa2ef7455c6ff39feb7aa8f48c39a2c7d4db73ab949fa9fce9a64244",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/rxmq.c",
  "human_readable_source": "\n \n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include \"iwl-trans.h\"\n#include \"mvm.h\"\n#include \"fw-api.h\"\n#include \"time-sync.h\"\n\nstatic inline int iwl_mvm_check_pn(struct iwl_mvm *mvm, struct sk_buff *skb,\n\t\t\t\t   int queue, struct ieee80211_sta *sta)\n{\n\tstruct iwl_mvm_sta *mvmsta;\n\tstruct ieee80211_hdr *hdr = (void *)skb_mac_header(skb);\n\tstruct ieee80211_rx_status *stats = IEEE80211_SKB_RXCB(skb);\n\tstruct iwl_mvm_key_pn *ptk_pn;\n\tint res;\n\tu8 tid, keyidx;\n\tu8 pn[IEEE80211_CCMP_PN_LEN];\n\tu8 *extiv;\n\n\t \n\n\t \n\tif (!ieee80211_is_data(hdr->frame_control) ||\n\t    is_multicast_ether_addr(hdr->addr1))\n\t\treturn 0;\n\n\t \n\tif (!(stats->flag & RX_FLAG_DECRYPTED))\n\t\treturn 0;\n\n\t \n\tif (queue == 0)\n\t\treturn 0;\n\n\t \n\tif (IS_ERR_OR_NULL(sta)) {\n\t\tIWL_DEBUG_DROP(mvm,\n\t\t\t       \"expected hw-decrypted unicast frame for station\\n\");\n\t\treturn -1;\n\t}\n\n\tmvmsta = iwl_mvm_sta_from_mac80211(sta);\n\n\textiv = (u8 *)hdr + ieee80211_hdrlen(hdr->frame_control);\n\tkeyidx = extiv[3] >> 6;\n\n\tptk_pn = rcu_dereference(mvmsta->ptk_pn[keyidx]);\n\tif (!ptk_pn)\n\t\treturn -1;\n\n\tif (ieee80211_is_data_qos(hdr->frame_control))\n\t\ttid = ieee80211_get_tid(hdr);\n\telse\n\t\ttid = 0;\n\n\t \n\tif (tid >= IWL_MAX_TID_COUNT)\n\t\treturn -1;\n\n\t \n\tpn[0] = extiv[7];\n\tpn[1] = extiv[6];\n\tpn[2] = extiv[5];\n\tpn[3] = extiv[4];\n\tpn[4] = extiv[1];\n\tpn[5] = extiv[0];\n\n\tres = memcmp(pn, ptk_pn->q[queue].pn[tid], IEEE80211_CCMP_PN_LEN);\n\tif (res < 0)\n\t\treturn -1;\n\tif (!res && !(stats->flag & RX_FLAG_ALLOW_SAME_PN))\n\t\treturn -1;\n\n\tmemcpy(ptk_pn->q[queue].pn[tid], pn, IEEE80211_CCMP_PN_LEN);\n\tstats->flag |= RX_FLAG_PN_VALIDATED;\n\n\treturn 0;\n}\n\n \nstatic int iwl_mvm_create_skb(struct iwl_mvm *mvm, struct sk_buff *skb,\n\t\t\t      struct ieee80211_hdr *hdr, u16 len, u8 crypt_len,\n\t\t\t      struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_rx_mpdu_desc *desc = (void *)pkt->data;\n\tunsigned int headlen, fraglen, pad_len = 0;\n\tunsigned int hdrlen = ieee80211_hdrlen(hdr->frame_control);\n\tu8 mic_crc_len = u8_get_bits(desc->mac_flags1,\n\t\t\t\t     IWL_RX_MPDU_MFLG1_MIC_CRC_LEN_MASK) << 1;\n\n\tif (desc->mac_flags2 & IWL_RX_MPDU_MFLG2_PAD) {\n\t\tlen -= 2;\n\t\tpad_len = 2;\n\t}\n\n\t \n\tif (len > mic_crc_len && !ieee80211_hw_check(mvm->hw, RX_INCLUDES_FCS))\n\t\tlen -= mic_crc_len;\n\n\t \n\theadlen = (len <= skb_tailroom(skb)) ? len :\n\t\t\t\t\t       hdrlen + crypt_len + 8;\n\n\t \n\thdrlen += crypt_len;\n\n\tif (unlikely(headlen < hdrlen))\n\t\treturn -EINVAL;\n\n\t \n\tskb_set_mac_header(skb, skb->len);\n\tskb_put_data(skb, hdr, hdrlen);\n\tskb_put_data(skb, (u8 *)hdr + hdrlen + pad_len, headlen - hdrlen);\n\n\t \n\tif (skb->ip_summed == CHECKSUM_COMPLETE) {\n\t\tstruct {\n\t\t\tu8 hdr[6];\n\t\t\t__be16 type;\n\t\t} __packed *shdr = (void *)((u8 *)hdr + hdrlen + pad_len);\n\n\t\tif (unlikely(headlen - hdrlen < sizeof(*shdr) ||\n\t\t\t     !ether_addr_equal(shdr->hdr, rfc1042_header) ||\n\t\t\t     (shdr->type != htons(ETH_P_IP) &&\n\t\t\t      shdr->type != htons(ETH_P_ARP) &&\n\t\t\t      shdr->type != htons(ETH_P_IPV6) &&\n\t\t\t      shdr->type != htons(ETH_P_8021Q) &&\n\t\t\t      shdr->type != htons(ETH_P_PAE) &&\n\t\t\t      shdr->type != htons(ETH_P_TDLS))))\n\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\telse if (mvm->trans->trans_cfg->device_family < IWL_DEVICE_FAMILY_BZ)\n\t\t\t \n\t\t\tskb_postpush_rcsum(skb, shdr, sizeof(*shdr));\n\t}\n\n\tfraglen = len - headlen;\n\n\tif (fraglen) {\n\t\tint offset = (u8 *)hdr + headlen + pad_len -\n\t\t\t     (u8 *)rxb_addr(rxb) + rxb_offset(rxb);\n\n\t\tskb_add_rx_frag(skb, 0, rxb_steal_page(rxb), offset,\n\t\t\t\tfraglen, rxb->truesize);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void *\niwl_mvm_radiotap_put_tlv(struct sk_buff *skb, u16 type, u16 len)\n{\n\tstruct ieee80211_radiotap_tlv *tlv;\n\n\ttlv = skb_put(skb, sizeof(*tlv));\n\ttlv->type = cpu_to_le16(type);\n\ttlv->len = cpu_to_le16(len);\n\treturn skb_put_zero(skb, ALIGN(len, 4));\n}\n\nstatic void iwl_mvm_add_rtap_sniffer_config(struct iwl_mvm *mvm,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct ieee80211_rx_status *rx_status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_radiotap_vendor_content *radiotap;\n\tconst u16 vendor_data_len = sizeof(mvm->cur_aid);\n\n\tif (!mvm->cur_aid)\n\t\treturn;\n\n\tradiotap = iwl_mvm_radiotap_put_tlv(skb,\n\t\t\t\t\t    IEEE80211_RADIOTAP_VENDOR_NAMESPACE,\n\t\t\t\t\t    sizeof(*radiotap) + vendor_data_len);\n\n\t \n\tradiotap->oui[0] = 0xf6;\n\tradiotap->oui[1] = 0x54;\n\tradiotap->oui[2] = 0x25;\n\t \n\tradiotap->oui_subtype = 1;\n\tradiotap->vendor_type = 0;\n\n\t \n\tmemcpy(radiotap->data, &mvm->cur_aid, sizeof(mvm->cur_aid));\n\n\trx_status->flag |= RX_FLAG_RADIOTAP_TLV_AT_END;\n}\n\n \nstatic void iwl_mvm_pass_packet_to_mac80211(struct iwl_mvm *mvm,\n\t\t\t\t\t    struct napi_struct *napi,\n\t\t\t\t\t    struct sk_buff *skb, int queue,\n\t\t\t\t\t    struct ieee80211_sta *sta,\n\t\t\t\t\t    struct ieee80211_link_sta *link_sta)\n{\n\tif (unlikely(iwl_mvm_check_pn(mvm, skb, queue, sta))) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tif (sta && sta->valid_links && link_sta) {\n\t\tstruct ieee80211_rx_status *rx_status = IEEE80211_SKB_RXCB(skb);\n\n\t\trx_status->link_valid = 1;\n\t\trx_status->link_id = link_sta->link_id;\n\t}\n\n\tieee80211_rx_napi(mvm->hw, sta, skb, napi);\n}\n\nstatic void iwl_mvm_get_signal_strength(struct iwl_mvm *mvm,\n\t\t\t\t\tstruct ieee80211_rx_status *rx_status,\n\t\t\t\t\tu32 rate_n_flags, int energy_a,\n\t\t\t\t\tint energy_b)\n{\n\tint max_energy;\n\tu32 rate_flags = rate_n_flags;\n\n\tenergy_a = energy_a ? -energy_a : S8_MIN;\n\tenergy_b = energy_b ? -energy_b : S8_MIN;\n\tmax_energy = max(energy_a, energy_b);\n\n\tIWL_DEBUG_STATS(mvm, \"energy In A %d B %d, and max %d\\n\",\n\t\t\tenergy_a, energy_b, max_energy);\n\n\trx_status->signal = max_energy;\n\trx_status->chains =\n\t\t(rate_flags & RATE_MCS_ANT_AB_MSK) >> RATE_MCS_ANT_POS;\n\trx_status->chain_signal[0] = energy_a;\n\trx_status->chain_signal[1] = energy_b;\n}\n\nstatic int iwl_mvm_rx_mgmt_prot(struct ieee80211_sta *sta,\n\t\t\t\tstruct ieee80211_hdr *hdr,\n\t\t\t\tstruct iwl_rx_mpdu_desc *desc,\n\t\t\t\tu32 status,\n\t\t\t\tstruct ieee80211_rx_status *stats)\n{\n\tstruct iwl_mvm_sta *mvmsta;\n\tstruct iwl_mvm_vif *mvmvif;\n\tu8 keyid;\n\tstruct ieee80211_key_conf *key;\n\tu32 len = le16_to_cpu(desc->mpdu_len);\n\tconst u8 *frame = (void *)hdr;\n\n\tif ((status & IWL_RX_MPDU_STATUS_SEC_MASK) == IWL_RX_MPDU_STATUS_SEC_NONE)\n\t\treturn 0;\n\n\t \n\tif (!ieee80211_is_beacon(hdr->frame_control))\n\t\treturn 0;\n\n\t \n\tif (!(status & IWL_RX_MPDU_STATUS_KEY_VALID))\n\t\treturn -1;\n\n\t \n\tif (likely(status & IWL_RX_MPDU_STATUS_MIC_OK &&\n\t\t   !(status & IWL_RX_MPDU_STATUS_REPLAY_ERROR))) {\n\t\tstats->flag |= RX_FLAG_DECRYPTED;\n\t\treturn 0;\n\t}\n\n\tif (!sta)\n\t\treturn -1;\n\n\tmvmsta = iwl_mvm_sta_from_mac80211(sta);\n\n\tmvmvif = iwl_mvm_vif_from_mac80211(mvmsta->vif);\n\n\t \n\tkey = rcu_dereference(mvmvif->bcn_prot.keys[0]);\n\tif (!key) {\n\t\tkey = rcu_dereference(mvmvif->bcn_prot.keys[1]);\n\t\tif (!key)\n\t\t\treturn -1;\n\t}\n\n\tif (len < key->icv_len + IEEE80211_GMAC_PN_LEN + 2)\n\t\treturn -1;\n\n\t \n\tkeyid = frame[len - key->icv_len - IEEE80211_GMAC_PN_LEN - 2];\n\t \n\tif (keyid != key->keyidx) {\n\t\t \n\t\tif (keyid != 6 && keyid != 7)\n\t\t\treturn -1;\n\t\tkey = rcu_dereference(mvmvif->bcn_prot.keys[keyid - 6]);\n\t\tif (!key)\n\t\t\treturn -1;\n\t}\n\n\t \n\tif (!(status & IWL_RX_MPDU_STATUS_MIC_OK))\n\t\tieee80211_key_mic_failure(key);\n\telse if (status & IWL_RX_MPDU_STATUS_REPLAY_ERROR)\n\t\tieee80211_key_replay(key);\n\n\treturn -1;\n}\n\nstatic int iwl_mvm_rx_crypto(struct iwl_mvm *mvm, struct ieee80211_sta *sta,\n\t\t\t     struct ieee80211_hdr *hdr,\n\t\t\t     struct ieee80211_rx_status *stats, u16 phy_info,\n\t\t\t     struct iwl_rx_mpdu_desc *desc,\n\t\t\t     u32 pkt_flags, int queue, u8 *crypt_len)\n{\n\tu32 status = le32_to_cpu(desc->status);\n\n\t \n\tif (phy_info & IWL_RX_MPDU_PHY_AMPDU &&\n\t    (status & IWL_RX_MPDU_STATUS_SEC_MASK) ==\n\t    IWL_RX_MPDU_STATUS_SEC_UNKNOWN && !mvm->monitor_on)\n\t\treturn -1;\n\n\tif (unlikely(ieee80211_is_mgmt(hdr->frame_control) &&\n\t\t     !ieee80211_has_protected(hdr->frame_control)))\n\t\treturn iwl_mvm_rx_mgmt_prot(sta, hdr, desc, status, stats);\n\n\tif (!ieee80211_has_protected(hdr->frame_control) ||\n\t    (status & IWL_RX_MPDU_STATUS_SEC_MASK) ==\n\t    IWL_RX_MPDU_STATUS_SEC_NONE)\n\t\treturn 0;\n\n\t \n\n\tswitch (status & IWL_RX_MPDU_STATUS_SEC_MASK) {\n\tcase IWL_RX_MPDU_STATUS_SEC_CCM:\n\tcase IWL_RX_MPDU_STATUS_SEC_GCM:\n\t\tBUILD_BUG_ON(IEEE80211_CCMP_PN_LEN != IEEE80211_GCMP_PN_LEN);\n\t\t \n\t\tif (!(status & IWL_RX_MPDU_STATUS_MIC_OK))\n\t\t\treturn -1;\n\n\t\tstats->flag |= RX_FLAG_DECRYPTED | RX_FLAG_MIC_STRIPPED;\n\t\t*crypt_len = IEEE80211_CCMP_HDR_LEN;\n\t\treturn 0;\n\tcase IWL_RX_MPDU_STATUS_SEC_TKIP:\n\t\t \n\t\tif (!fw_has_api(&mvm->fw->ucode_capa,\n\t\t\t\tIWL_UCODE_TLV_API_DEPRECATE_TTAK) &&\n\t\t    !(status & IWL_RX_MPDU_RES_STATUS_TTAK_OK))\n\t\t\treturn 0;\n\n\t\tif (mvm->trans->trans_cfg->gen2 &&\n\t\t    !(status & RX_MPDU_RES_STATUS_MIC_OK))\n\t\t\tstats->flag |= RX_FLAG_MMIC_ERROR;\n\n\t\t*crypt_len = IEEE80211_TKIP_IV_LEN;\n\t\tfallthrough;\n\tcase IWL_RX_MPDU_STATUS_SEC_WEP:\n\t\tif (!(status & IWL_RX_MPDU_STATUS_ICV_OK))\n\t\t\treturn -1;\n\n\t\tstats->flag |= RX_FLAG_DECRYPTED;\n\t\tif ((status & IWL_RX_MPDU_STATUS_SEC_MASK) ==\n\t\t\t\tIWL_RX_MPDU_STATUS_SEC_WEP)\n\t\t\t*crypt_len = IEEE80211_WEP_IV_LEN;\n\n\t\tif (pkt_flags & FH_RSCSR_RADA_EN) {\n\t\t\tstats->flag |= RX_FLAG_ICV_STRIPPED;\n\t\t\tif (mvm->trans->trans_cfg->gen2)\n\t\t\t\tstats->flag |= RX_FLAG_MMIC_STRIPPED;\n\t\t}\n\n\t\treturn 0;\n\tcase IWL_RX_MPDU_STATUS_SEC_EXT_ENC:\n\t\tif (!(status & IWL_RX_MPDU_STATUS_MIC_OK))\n\t\t\treturn -1;\n\t\tstats->flag |= RX_FLAG_DECRYPTED;\n\t\treturn 0;\n\tcase RX_MPDU_RES_STATUS_SEC_CMAC_GMAC_ENC:\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif (!is_multicast_ether_addr(hdr->addr1) &&\n\t\t    !mvm->monitor_on && net_ratelimit())\n\t\t\tIWL_WARN(mvm, \"Unhandled alg: 0x%x\\n\", status);\n\t}\n\n\treturn 0;\n}\n\nstatic void iwl_mvm_rx_csum(struct iwl_mvm *mvm,\n\t\t\t    struct ieee80211_sta *sta,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    struct iwl_rx_packet *pkt)\n{\n\tstruct iwl_rx_mpdu_desc *desc = (void *)pkt->data;\n\n\tif (mvm->trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_AX210) {\n\t\tif (pkt->len_n_flags & cpu_to_le32(FH_RSCSR_RPA_EN)) {\n\t\t\tu16 hwsum = be16_to_cpu(desc->v3.raw_xsum);\n\n\t\t\tskb->ip_summed = CHECKSUM_COMPLETE;\n\t\t\tskb->csum = csum_unfold(~(__force __sum16)hwsum);\n\t\t}\n\t} else {\n\t\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\t\tstruct iwl_mvm_vif *mvmvif;\n\t\tu16 flags = le16_to_cpu(desc->l3l4_flags);\n\t\tu8 l3_prot = (u8)((flags & IWL_RX_L3L4_L3_PROTO_MASK) >>\n\t\t\t\t  IWL_RX_L3_PROTO_POS);\n\n\t\tmvmvif = iwl_mvm_vif_from_mac80211(mvmsta->vif);\n\n\t\tif (mvmvif->features & NETIF_F_RXCSUM &&\n\t\t    flags & IWL_RX_L3L4_TCP_UDP_CSUM_OK &&\n\t\t    (flags & IWL_RX_L3L4_IP_HDR_CSUM_OK ||\n\t\t     l3_prot == IWL_RX_L3_TYPE_IPV6 ||\n\t\t     l3_prot == IWL_RX_L3_TYPE_IPV6_FRAG))\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t}\n}\n\n \nstatic bool iwl_mvm_is_dup(struct ieee80211_sta *sta, int queue,\n\t\t\t   struct ieee80211_rx_status *rx_status,\n\t\t\t   struct ieee80211_hdr *hdr,\n\t\t\t   struct iwl_rx_mpdu_desc *desc)\n{\n\tstruct iwl_mvm_sta *mvm_sta;\n\tstruct iwl_mvm_rxq_dup_data *dup_data;\n\tu8 tid, sub_frame_idx;\n\n\tif (WARN_ON(IS_ERR_OR_NULL(sta)))\n\t\treturn false;\n\n\tmvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\tdup_data = &mvm_sta->dup_data[queue];\n\n\t \n\tif (ieee80211_is_ctl(hdr->frame_control) ||\n\t    ieee80211_is_qos_nullfunc(hdr->frame_control) ||\n\t    is_multicast_ether_addr(hdr->addr1)) {\n\t\trx_status->flag |= RX_FLAG_DUP_VALIDATED;\n\t\treturn false;\n\t}\n\n\tif (ieee80211_is_data_qos(hdr->frame_control)) {\n\t\t \n\t\ttid = ieee80211_get_tid(hdr);\n\t\tif (tid >= IWL_MAX_TID_COUNT)\n\t\t\treturn true;\n\t} else {\n\t\ttid = IWL_MAX_TID_COUNT;\n\t}\n\n\t \n\tsub_frame_idx = desc->amsdu_info &\n\t\tIWL_RX_MPDU_AMSDU_SUBFRAME_IDX_MASK;\n\n\tif (unlikely(ieee80211_has_retry(hdr->frame_control) &&\n\t\t     dup_data->last_seq[tid] == hdr->seq_ctrl &&\n\t\t     dup_data->last_sub_frame[tid] >= sub_frame_idx))\n\t\treturn true;\n\n\t \n\tif (dup_data->last_seq[tid] == hdr->seq_ctrl &&\n\t    sub_frame_idx > dup_data->last_sub_frame[tid] &&\n\t    desc->mac_flags2 & IWL_RX_MPDU_MFLG2_AMSDU)\n\t\trx_status->flag |= RX_FLAG_ALLOW_SAME_PN;\n\n\tdup_data->last_seq[tid] = hdr->seq_ctrl;\n\tdup_data->last_sub_frame[tid] = sub_frame_idx;\n\n\trx_status->flag |= RX_FLAG_DUP_VALIDATED;\n\n\treturn false;\n}\n\n \nstatic bool iwl_mvm_is_sn_less(u16 sn1, u16 sn2, u16 buffer_size)\n{\n\treturn ieee80211_sn_less(sn1, sn2) &&\n\t       !ieee80211_sn_less(sn1, sn2 - buffer_size);\n}\n\nstatic void iwl_mvm_sync_nssn(struct iwl_mvm *mvm, u8 baid, u16 nssn)\n{\n\tif (IWL_MVM_USE_NSSN_SYNC) {\n\t\tstruct iwl_mvm_nssn_sync_data notif = {\n\t\t\t.baid = baid,\n\t\t\t.nssn = nssn,\n\t\t};\n\n\t\tiwl_mvm_sync_rx_queues_internal(mvm, IWL_MVM_RXQ_NSSN_SYNC, false,\n\t\t\t\t\t\t&notif, sizeof(notif));\n\t}\n}\n\n#define RX_REORDER_BUF_TIMEOUT_MQ (HZ / 10)\n\nenum iwl_mvm_release_flags {\n\tIWL_MVM_RELEASE_SEND_RSS_SYNC = BIT(0),\n\tIWL_MVM_RELEASE_FROM_RSS_SYNC = BIT(1),\n};\n\nstatic void iwl_mvm_release_frames(struct iwl_mvm *mvm,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   struct napi_struct *napi,\n\t\t\t\t   struct iwl_mvm_baid_data *baid_data,\n\t\t\t\t   struct iwl_mvm_reorder_buffer *reorder_buf,\n\t\t\t\t   u16 nssn, u32 flags)\n{\n\tstruct iwl_mvm_reorder_buf_entry *entries =\n\t\t&baid_data->entries[reorder_buf->queue *\n\t\t\t\t    baid_data->entries_per_queue];\n\tu16 ssn = reorder_buf->head_sn;\n\n\tlockdep_assert_held(&reorder_buf->lock);\n\n\t \n\tif ((flags & IWL_MVM_RELEASE_FROM_RSS_SYNC) &&\n\t    ieee80211_sn_less(nssn, ssn))\n\t\tgoto set_timer;\n\n\t \n\tif (iwl_mvm_is_sn_less(nssn, ssn, reorder_buf->buf_size))\n\t\tgoto set_timer;\n\n\twhile (iwl_mvm_is_sn_less(ssn, nssn, reorder_buf->buf_size)) {\n\t\tint index = ssn % reorder_buf->buf_size;\n\t\tstruct sk_buff_head *skb_list = &entries[index].e.frames;\n\t\tstruct sk_buff *skb;\n\n\t\tssn = ieee80211_sn_inc(ssn);\n\t\tif ((flags & IWL_MVM_RELEASE_SEND_RSS_SYNC) &&\n\t\t    (ssn == 2048 || ssn == 0))\n\t\t\tiwl_mvm_sync_nssn(mvm, baid_data->baid, ssn);\n\n\t\t \n\t\twhile ((skb = __skb_dequeue(skb_list))) {\n\t\t\tiwl_mvm_pass_packet_to_mac80211(mvm, napi, skb,\n\t\t\t\t\t\t\treorder_buf->queue,\n\t\t\t\t\t\t\tsta, NULL  );\n\t\t\treorder_buf->num_stored--;\n\t\t}\n\t}\n\treorder_buf->head_sn = nssn;\n\nset_timer:\n\tif (reorder_buf->num_stored && !reorder_buf->removed) {\n\t\tu16 index = reorder_buf->head_sn % reorder_buf->buf_size;\n\n\t\twhile (skb_queue_empty(&entries[index].e.frames))\n\t\t\tindex = (index + 1) % reorder_buf->buf_size;\n\t\t \n\t\tmod_timer(&reorder_buf->reorder_timer,\n\t\t\t  entries[index].e.reorder_time + 1 +\n\t\t\t  RX_REORDER_BUF_TIMEOUT_MQ);\n\t} else {\n\t\tdel_timer(&reorder_buf->reorder_timer);\n\t}\n}\n\nvoid iwl_mvm_reorder_timer_expired(struct timer_list *t)\n{\n\tstruct iwl_mvm_reorder_buffer *buf = from_timer(buf, t, reorder_timer);\n\tstruct iwl_mvm_baid_data *baid_data =\n\t\tiwl_mvm_baid_data_from_reorder_buf(buf);\n\tstruct iwl_mvm_reorder_buf_entry *entries =\n\t\t&baid_data->entries[buf->queue * baid_data->entries_per_queue];\n\tint i;\n\tu16 sn = 0, index = 0;\n\tbool expired = false;\n\tbool cont = false;\n\n\tspin_lock(&buf->lock);\n\n\tif (!buf->num_stored || buf->removed) {\n\t\tspin_unlock(&buf->lock);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < buf->buf_size ; i++) {\n\t\tindex = (buf->head_sn + i) % buf->buf_size;\n\n\t\tif (skb_queue_empty(&entries[index].e.frames)) {\n\t\t\t \n\t\t\tcont = false;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!cont &&\n\t\t    !time_after(jiffies, entries[index].e.reorder_time +\n\t\t\t\t\t RX_REORDER_BUF_TIMEOUT_MQ))\n\t\t\tbreak;\n\n\t\texpired = true;\n\t\t \n\t\tcont = true;\n\t\tsn = ieee80211_sn_add(buf->head_sn, i + 1);\n\t}\n\n\tif (expired) {\n\t\tstruct ieee80211_sta *sta;\n\t\tstruct iwl_mvm_sta *mvmsta;\n\t\tu8 sta_id = ffs(baid_data->sta_mask) - 1;\n\n\t\trcu_read_lock();\n\t\tsta = rcu_dereference(buf->mvm->fw_id_to_mac_id[sta_id]);\n\t\tif (WARN_ON_ONCE(IS_ERR_OR_NULL(sta))) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto out;\n\t\t}\n\n\t\tmvmsta = iwl_mvm_sta_from_mac80211(sta);\n\n\t\t \n\t\tIWL_DEBUG_HT(buf->mvm,\n\t\t\t     \"Releasing expired frames for sta %u, sn %d\\n\",\n\t\t\t     sta_id, sn);\n\t\tiwl_mvm_event_frame_timeout_callback(buf->mvm, mvmsta->vif,\n\t\t\t\t\t\t     sta, baid_data->tid);\n\t\tiwl_mvm_release_frames(buf->mvm, sta, NULL, baid_data,\n\t\t\t\t       buf, sn, IWL_MVM_RELEASE_SEND_RSS_SYNC);\n\t\trcu_read_unlock();\n\t} else {\n\t\t \n\t\tmod_timer(&buf->reorder_timer,\n\t\t\t  entries[index].e.reorder_time +\n\t\t\t  1 + RX_REORDER_BUF_TIMEOUT_MQ);\n\t}\n\nout:\n\tspin_unlock(&buf->lock);\n}\n\nstatic void iwl_mvm_del_ba(struct iwl_mvm *mvm, int queue,\n\t\t\t   struct iwl_mvm_delba_data *data)\n{\n\tstruct iwl_mvm_baid_data *ba_data;\n\tstruct ieee80211_sta *sta;\n\tstruct iwl_mvm_reorder_buffer *reorder_buf;\n\tu8 baid = data->baid;\n\tu32 sta_id;\n\n\tif (WARN_ONCE(baid >= IWL_MAX_BAID, \"invalid BAID: %x\\n\", baid))\n\t\treturn;\n\n\trcu_read_lock();\n\n\tba_data = rcu_dereference(mvm->baid_map[baid]);\n\tif (WARN_ON_ONCE(!ba_data))\n\t\tgoto out;\n\n\t \n\tsta_id = ffs(ba_data->sta_mask) - 1;\n\tsta = rcu_dereference(mvm->fw_id_to_mac_id[sta_id]);\n\tif (WARN_ON_ONCE(IS_ERR_OR_NULL(sta)))\n\t\tgoto out;\n\n\treorder_buf = &ba_data->reorder_buf[queue];\n\n\t \n\tspin_lock_bh(&reorder_buf->lock);\n\tiwl_mvm_release_frames(mvm, sta, NULL, ba_data, reorder_buf,\n\t\t\t       ieee80211_sn_add(reorder_buf->head_sn,\n\t\t\t\t\t\treorder_buf->buf_size),\n\t\t\t       0);\n\tspin_unlock_bh(&reorder_buf->lock);\n\tdel_timer_sync(&reorder_buf->reorder_timer);\n\nout:\n\trcu_read_unlock();\n}\n\nstatic void iwl_mvm_release_frames_from_notif(struct iwl_mvm *mvm,\n\t\t\t\t\t      struct napi_struct *napi,\n\t\t\t\t\t      u8 baid, u16 nssn, int queue,\n\t\t\t\t\t      u32 flags)\n{\n\tstruct ieee80211_sta *sta;\n\tstruct iwl_mvm_reorder_buffer *reorder_buf;\n\tstruct iwl_mvm_baid_data *ba_data;\n\tu32 sta_id;\n\n\tIWL_DEBUG_HT(mvm, \"Frame release notification for BAID %u, NSSN %d\\n\",\n\t\t     baid, nssn);\n\n\tif (WARN_ON_ONCE(baid == IWL_RX_REORDER_DATA_INVALID_BAID ||\n\t\t\t baid >= ARRAY_SIZE(mvm->baid_map)))\n\t\treturn;\n\n\trcu_read_lock();\n\n\tba_data = rcu_dereference(mvm->baid_map[baid]);\n\tif (!ba_data) {\n\t\tWARN(!(flags & IWL_MVM_RELEASE_FROM_RSS_SYNC),\n\t\t     \"BAID %d not found in map\\n\", baid);\n\t\tgoto out;\n\t}\n\n\t \n\tsta_id = ffs(ba_data->sta_mask) - 1;\n\tsta = rcu_dereference(mvm->fw_id_to_mac_id[sta_id]);\n\tif (WARN_ON_ONCE(IS_ERR_OR_NULL(sta)))\n\t\tgoto out;\n\n\treorder_buf = &ba_data->reorder_buf[queue];\n\n\tspin_lock_bh(&reorder_buf->lock);\n\tiwl_mvm_release_frames(mvm, sta, napi, ba_data,\n\t\t\t       reorder_buf, nssn, flags);\n\tspin_unlock_bh(&reorder_buf->lock);\n\nout:\n\trcu_read_unlock();\n}\n\nstatic void iwl_mvm_nssn_sync(struct iwl_mvm *mvm,\n\t\t\t      struct napi_struct *napi, int queue,\n\t\t\t      const struct iwl_mvm_nssn_sync_data *data)\n{\n\tiwl_mvm_release_frames_from_notif(mvm, napi, data->baid,\n\t\t\t\t\t  data->nssn, queue,\n\t\t\t\t\t  IWL_MVM_RELEASE_FROM_RSS_SYNC);\n}\n\nvoid iwl_mvm_rx_queue_notif(struct iwl_mvm *mvm, struct napi_struct *napi,\n\t\t\t    struct iwl_rx_cmd_buffer *rxb, int queue)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_rxq_sync_notification *notif;\n\tstruct iwl_mvm_internal_rxq_notif *internal_notif;\n\tu32 len = iwl_rx_packet_payload_len(pkt);\n\n\tnotif = (void *)pkt->data;\n\tinternal_notif = (void *)notif->payload;\n\n\tif (WARN_ONCE(len < sizeof(*notif) + sizeof(*internal_notif),\n\t\t      \"invalid notification size %d (%d)\",\n\t\t      len, (int)(sizeof(*notif) + sizeof(*internal_notif))))\n\t\treturn;\n\tlen -= sizeof(*notif) + sizeof(*internal_notif);\n\n\tif (internal_notif->sync &&\n\t    mvm->queue_sync_cookie != internal_notif->cookie) {\n\t\tWARN_ONCE(1, \"Received expired RX queue sync message\\n\");\n\t\treturn;\n\t}\n\n\tswitch (internal_notif->type) {\n\tcase IWL_MVM_RXQ_EMPTY:\n\t\tWARN_ONCE(len, \"invalid empty notification size %d\", len);\n\t\tbreak;\n\tcase IWL_MVM_RXQ_NOTIF_DEL_BA:\n\t\tif (WARN_ONCE(len != sizeof(struct iwl_mvm_delba_data),\n\t\t\t      \"invalid delba notification size %d (%d)\",\n\t\t\t      len, (int)sizeof(struct iwl_mvm_delba_data)))\n\t\t\tbreak;\n\t\tiwl_mvm_del_ba(mvm, queue, (void *)internal_notif->data);\n\t\tbreak;\n\tcase IWL_MVM_RXQ_NSSN_SYNC:\n\t\tif (WARN_ONCE(len != sizeof(struct iwl_mvm_nssn_sync_data),\n\t\t\t      \"invalid nssn sync notification size %d (%d)\",\n\t\t\t      len, (int)sizeof(struct iwl_mvm_nssn_sync_data)))\n\t\t\tbreak;\n\t\tiwl_mvm_nssn_sync(mvm, napi, queue,\n\t\t\t\t  (void *)internal_notif->data);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(1, \"Invalid identifier %d\", internal_notif->type);\n\t}\n\n\tif (internal_notif->sync) {\n\t\tWARN_ONCE(!test_and_clear_bit(queue, &mvm->queue_sync_state),\n\t\t\t  \"queue sync: queue %d responded a second time!\\n\",\n\t\t\t  queue);\n\t\tif (READ_ONCE(mvm->queue_sync_state) == 0)\n\t\t\twake_up(&mvm->rx_sync_waitq);\n\t}\n}\n\nstatic void iwl_mvm_oldsn_workaround(struct iwl_mvm *mvm,\n\t\t\t\t     struct ieee80211_sta *sta, int tid,\n\t\t\t\t     struct iwl_mvm_reorder_buffer *buffer,\n\t\t\t\t     u32 reorder, u32 gp2, int queue)\n{\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\n\tif (gp2 != buffer->consec_oldsn_ampdu_gp2) {\n\t\t \n\n\t\t \n\t\tif (!buffer->consec_oldsn_prev_drop)\n\t\t\tbuffer->consec_oldsn_drops = 0;\n\n\t\t \n\t\tbuffer->consec_oldsn_ampdu_gp2 = gp2;\n\t} else if (buffer->consec_oldsn_prev_drop) {\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tif (!(reorder & IWL_RX_MPDU_REORDER_BA_OLD_SN))\n\t\treturn;\n\n\t \n\tbuffer->consec_oldsn_prev_drop = 1;\n\tbuffer->consec_oldsn_drops++;\n\n\t \n\tif (buffer->consec_oldsn_drops == IWL_MVM_AMPDU_CONSEC_DROPS_DELBA) {\n\t\tIWL_WARN(mvm,\n\t\t\t \"reached %d old SN frames from %pM on queue %d, stopping BA session on TID %d\\n\",\n\t\t\t IWL_MVM_AMPDU_CONSEC_DROPS_DELBA,\n\t\t\t sta->addr, queue, tid);\n\t\tieee80211_stop_rx_ba_session(mvmsta->vif, BIT(tid), sta->addr);\n\t\tbuffer->consec_oldsn_prev_drop = 0;\n\t\tbuffer->consec_oldsn_drops = 0;\n\t}\n}\n\n \nstatic bool iwl_mvm_reorder(struct iwl_mvm *mvm,\n\t\t\t    struct napi_struct *napi,\n\t\t\t    int queue,\n\t\t\t    struct ieee80211_sta *sta,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    struct iwl_rx_mpdu_desc *desc)\n{\n\tstruct ieee80211_rx_status *rx_status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_hdr *hdr = (void *)skb_mac_header(skb);\n\tstruct iwl_mvm_baid_data *baid_data;\n\tstruct iwl_mvm_reorder_buffer *buffer;\n\tstruct sk_buff *tail;\n\tu32 reorder = le32_to_cpu(desc->reorder_data);\n\tbool amsdu = desc->mac_flags2 & IWL_RX_MPDU_MFLG2_AMSDU;\n\tbool last_subframe =\n\t\tdesc->amsdu_info & IWL_RX_MPDU_AMSDU_LAST_SUBFRAME;\n\tu8 tid = ieee80211_get_tid(hdr);\n\tu8 sub_frame_idx = desc->amsdu_info &\n\t\t\t   IWL_RX_MPDU_AMSDU_SUBFRAME_IDX_MASK;\n\tstruct iwl_mvm_reorder_buf_entry *entries;\n\tu32 sta_mask;\n\tint index;\n\tu16 nssn, sn;\n\tu8 baid;\n\n\tbaid = (reorder & IWL_RX_MPDU_REORDER_BAID_MASK) >>\n\t\tIWL_RX_MPDU_REORDER_BAID_SHIFT;\n\n\t \n\tif (baid == IWL_RX_REORDER_DATA_INVALID_BAID)\n\t\treturn false;\n\n\t \n\tif (WARN_ONCE(IS_ERR_OR_NULL(sta),\n\t\t      \"Got valid BAID without a valid station assigned\\n\"))\n\t\treturn false;\n\n\t \n\tif (!ieee80211_is_back_req(hdr->frame_control) &&\n\t    (!ieee80211_is_data_qos(hdr->frame_control) ||\n\t     is_multicast_ether_addr(hdr->addr1)))\n\t\treturn false;\n\n\tif (unlikely(!ieee80211_is_data_present(hdr->frame_control)))\n\t\treturn false;\n\n\tbaid_data = rcu_dereference(mvm->baid_map[baid]);\n\tif (!baid_data) {\n\t\tIWL_DEBUG_RX(mvm,\n\t\t\t     \"Got valid BAID but no baid allocated, bypass the re-ordering buffer. Baid %d reorder 0x%x\\n\",\n\t\t\t      baid, reorder);\n\t\treturn false;\n\t}\n\n\trcu_read_lock();\n\tsta_mask = iwl_mvm_sta_fw_id_mask(mvm, sta, -1);\n\trcu_read_unlock();\n\n\tif (IWL_FW_CHECK(mvm,\n\t\t\t tid != baid_data->tid ||\n\t\t\t !(sta_mask & baid_data->sta_mask),\n\t\t\t \"baid 0x%x is mapped to sta_mask:0x%x tid:%d, but was received for sta_mask:0x%x tid:%d\\n\",\n\t\t\t baid, baid_data->sta_mask, baid_data->tid,\n\t\t\t sta_mask, tid))\n\t\treturn false;\n\n\tnssn = reorder & IWL_RX_MPDU_REORDER_NSSN_MASK;\n\tsn = (reorder & IWL_RX_MPDU_REORDER_SN_MASK) >>\n\t\tIWL_RX_MPDU_REORDER_SN_SHIFT;\n\n\tbuffer = &baid_data->reorder_buf[queue];\n\tentries = &baid_data->entries[queue * baid_data->entries_per_queue];\n\n\tspin_lock_bh(&buffer->lock);\n\n\tif (!buffer->valid) {\n\t\tif (reorder & IWL_RX_MPDU_REORDER_BA_OLD_SN) {\n\t\t\tspin_unlock_bh(&buffer->lock);\n\t\t\treturn false;\n\t\t}\n\t\tbuffer->valid = true;\n\t}\n\n\tif (ieee80211_is_back_req(hdr->frame_control)) {\n\t\tiwl_mvm_release_frames(mvm, sta, napi, baid_data,\n\t\t\t\t       buffer, nssn, 0);\n\t\tgoto drop;\n\t}\n\n\t \n\tif (!iwl_mvm_is_sn_less(nssn, buffer->head_sn + buffer->buf_size,\n\t\t\t\tbuffer->buf_size) ||\n\t    !ieee80211_sn_less(sn, buffer->head_sn + buffer->buf_size)) {\n\t\tu16 min_sn = ieee80211_sn_less(sn, nssn) ? sn : nssn;\n\n\t\tiwl_mvm_release_frames(mvm, sta, napi, baid_data, buffer,\n\t\t\t\t       min_sn, IWL_MVM_RELEASE_SEND_RSS_SYNC);\n\t}\n\n\tiwl_mvm_oldsn_workaround(mvm, sta, tid, buffer, reorder,\n\t\t\t\t rx_status->device_timestamp, queue);\n\n\t \n\tif (ieee80211_sn_less(sn, buffer->head_sn))\n\t\tgoto drop;\n\n\t \n\tif (!buffer->num_stored && ieee80211_sn_less(sn, nssn)) {\n\t\tif (iwl_mvm_is_sn_less(buffer->head_sn, nssn,\n\t\t\t\t       buffer->buf_size) &&\n\t\t   (!amsdu || last_subframe)) {\n\t\t\t \n\t\t\tif (sn == 2048 || sn == 0)\n\t\t\t\tiwl_mvm_sync_nssn(mvm, baid, sn);\n\t\t\tbuffer->head_sn = nssn;\n\t\t}\n\t\t \n\t\tspin_unlock_bh(&buffer->lock);\n\t\treturn false;\n\t}\n\n\t \n\tif (!buffer->num_stored && sn == buffer->head_sn) {\n\t\tif (!amsdu || last_subframe) {\n\t\t\tif (sn == 2048 || sn == 0)\n\t\t\t\tiwl_mvm_sync_nssn(mvm, baid, sn);\n\t\t\tbuffer->head_sn = ieee80211_sn_inc(buffer->head_sn);\n\t\t}\n\t\t \n\t\tspin_unlock_bh(&buffer->lock);\n\t\treturn false;\n\t}\n\n\tindex = sn % buffer->buf_size;\n\n\t \n\ttail = skb_peek_tail(&entries[index].e.frames);\n\tif (tail && !amsdu)\n\t\tgoto drop;\n\telse if (tail && (sn != buffer->last_amsdu ||\n\t\t\t  buffer->last_sub_index >= sub_frame_idx))\n\t\tgoto drop;\n\n\t \n\t__skb_queue_tail(&entries[index].e.frames, skb);\n\tbuffer->num_stored++;\n\tentries[index].e.reorder_time = jiffies;\n\n\tif (amsdu) {\n\t\tbuffer->last_amsdu = sn;\n\t\tbuffer->last_sub_index = sub_frame_idx;\n\t}\n\n\t \n\tif (!amsdu || last_subframe)\n\t\tiwl_mvm_release_frames(mvm, sta, napi, baid_data,\n\t\t\t\t       buffer, nssn,\n\t\t\t\t       IWL_MVM_RELEASE_SEND_RSS_SYNC);\n\n\tspin_unlock_bh(&buffer->lock);\n\treturn true;\n\ndrop:\n\tkfree_skb(skb);\n\tspin_unlock_bh(&buffer->lock);\n\treturn true;\n}\n\nstatic void iwl_mvm_agg_rx_received(struct iwl_mvm *mvm,\n\t\t\t\t    u32 reorder_data, u8 baid)\n{\n\tunsigned long now = jiffies;\n\tunsigned long timeout;\n\tstruct iwl_mvm_baid_data *data;\n\n\trcu_read_lock();\n\n\tdata = rcu_dereference(mvm->baid_map[baid]);\n\tif (!data) {\n\t\tIWL_DEBUG_RX(mvm,\n\t\t\t     \"Got valid BAID but no baid allocated, bypass the re-ordering buffer. Baid %d reorder 0x%x\\n\",\n\t\t\t      baid, reorder_data);\n\t\tgoto out;\n\t}\n\n\tif (!data->timeout)\n\t\tgoto out;\n\n\ttimeout = data->timeout;\n\t \n\tif (time_before(data->last_rx + TU_TO_JIFFIES(timeout), now))\n\t\t \n\t\tdata->last_rx = now;\n\nout:\n\trcu_read_unlock();\n}\n\nstatic void iwl_mvm_flip_address(u8 *addr)\n{\n\tint i;\n\tu8 mac_addr[ETH_ALEN];\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tmac_addr[i] = addr[ETH_ALEN - i - 1];\n\tether_addr_copy(addr, mac_addr);\n}\n\nstruct iwl_mvm_rx_phy_data {\n\tenum iwl_rx_phy_info_type info_type;\n\t__le32 d0, d1, d2, d3, eht_d4, d5;\n\t__le16 d4;\n\tbool with_data;\n\tbool first_subframe;\n\t__le32 rx_vec[4];\n\n\tu32 rate_n_flags;\n\tu32 gp2_on_air_rise;\n\tu16 phy_info;\n\tu8 energy_a, energy_b;\n\tu8 channel;\n};\n\nstatic void iwl_mvm_decode_he_mu_ext(struct iwl_mvm *mvm,\n\t\t\t\t     struct iwl_mvm_rx_phy_data *phy_data,\n\t\t\t\t     struct ieee80211_radiotap_he_mu *he_mu)\n{\n\tu32 phy_data2 = le32_to_cpu(phy_data->d2);\n\tu32 phy_data3 = le32_to_cpu(phy_data->d3);\n\tu16 phy_data4 = le16_to_cpu(phy_data->d4);\n\tu32 rate_n_flags = phy_data->rate_n_flags;\n\n\tif (FIELD_GET(IWL_RX_PHY_DATA4_HE_MU_EXT_CH1_CRC_OK, phy_data4)) {\n\t\the_mu->flags1 |=\n\t\t\tcpu_to_le16(IEEE80211_RADIOTAP_HE_MU_FLAGS1_CH1_RU_KNOWN |\n\t\t\t\t    IEEE80211_RADIOTAP_HE_MU_FLAGS1_CH1_CTR_26T_RU_KNOWN);\n\n\t\the_mu->flags1 |=\n\t\t\tle16_encode_bits(FIELD_GET(IWL_RX_PHY_DATA4_HE_MU_EXT_CH1_CTR_RU,\n\t\t\t\t\t\t   phy_data4),\n\t\t\t\t\t IEEE80211_RADIOTAP_HE_MU_FLAGS1_CH1_CTR_26T_RU);\n\n\t\the_mu->ru_ch1[0] = FIELD_GET(IWL_RX_PHY_DATA2_HE_MU_EXT_CH1_RU0,\n\t\t\t\t\t     phy_data2);\n\t\the_mu->ru_ch1[1] = FIELD_GET(IWL_RX_PHY_DATA3_HE_MU_EXT_CH1_RU1,\n\t\t\t\t\t     phy_data3);\n\t\the_mu->ru_ch1[2] = FIELD_GET(IWL_RX_PHY_DATA2_HE_MU_EXT_CH1_RU2,\n\t\t\t\t\t     phy_data2);\n\t\the_mu->ru_ch1[3] = FIELD_GET(IWL_RX_PHY_DATA3_HE_MU_EXT_CH1_RU3,\n\t\t\t\t\t     phy_data3);\n\t}\n\n\tif (FIELD_GET(IWL_RX_PHY_DATA4_HE_MU_EXT_CH2_CRC_OK, phy_data4) &&\n\t    (rate_n_flags & RATE_MCS_CHAN_WIDTH_MSK_V1) != RATE_MCS_CHAN_WIDTH_20) {\n\t\the_mu->flags1 |=\n\t\t\tcpu_to_le16(IEEE80211_RADIOTAP_HE_MU_FLAGS1_CH2_RU_KNOWN |\n\t\t\t\t    IEEE80211_RADIOTAP_HE_MU_FLAGS1_CH2_CTR_26T_RU_KNOWN);\n\n\t\the_mu->flags2 |=\n\t\t\tle16_encode_bits(FIELD_GET(IWL_RX_PHY_DATA4_HE_MU_EXT_CH2_CTR_RU,\n\t\t\t\t\t\t   phy_data4),\n\t\t\t\t\t IEEE80211_RADIOTAP_HE_MU_FLAGS2_CH2_CTR_26T_RU);\n\n\t\the_mu->ru_ch2[0] = FIELD_GET(IWL_RX_PHY_DATA2_HE_MU_EXT_CH2_RU0,\n\t\t\t\t\t     phy_data2);\n\t\the_mu->ru_ch2[1] = FIELD_GET(IWL_RX_PHY_DATA3_HE_MU_EXT_CH2_RU1,\n\t\t\t\t\t     phy_data3);\n\t\the_mu->ru_ch2[2] = FIELD_GET(IWL_RX_PHY_DATA2_HE_MU_EXT_CH2_RU2,\n\t\t\t\t\t     phy_data2);\n\t\the_mu->ru_ch2[3] = FIELD_GET(IWL_RX_PHY_DATA3_HE_MU_EXT_CH2_RU3,\n\t\t\t\t\t     phy_data3);\n\t}\n}\n\nstatic void\niwl_mvm_decode_he_phy_ru_alloc(struct iwl_mvm_rx_phy_data *phy_data,\n\t\t\t       struct ieee80211_radiotap_he *he,\n\t\t\t       struct ieee80211_radiotap_he_mu *he_mu,\n\t\t\t       struct ieee80211_rx_status *rx_status)\n{\n\t \n\tu8 ru = le32_get_bits(phy_data->d1, IWL_RX_PHY_DATA1_HE_RU_ALLOC_MASK);\n\tu32 rate_n_flags = phy_data->rate_n_flags;\n\tu32 he_type = rate_n_flags & RATE_MCS_HE_TYPE_MSK_V1;\n\tu8 offs = 0;\n\n\trx_status->bw = RATE_INFO_BW_HE_RU;\n\n\the->data1 |= cpu_to_le16(IEEE80211_RADIOTAP_HE_DATA1_BW_RU_ALLOC_KNOWN);\n\n\tswitch (ru) {\n\tcase 0 ... 36:\n\t\trx_status->he_ru = NL80211_RATE_INFO_HE_RU_ALLOC_26;\n\t\toffs = ru;\n\t\tbreak;\n\tcase 37 ... 52:\n\t\trx_status->he_ru = NL80211_RATE_INFO_HE_RU_ALLOC_52;\n\t\toffs = ru - 37;\n\t\tbreak;\n\tcase 53 ... 60:\n\t\trx_status->he_ru = NL80211_RATE_INFO_HE_RU_ALLOC_106;\n\t\toffs = ru - 53;\n\t\tbreak;\n\tcase 61 ... 64:\n\t\trx_status->he_ru = NL80211_RATE_INFO_HE_RU_ALLOC_242;\n\t\toffs = ru - 61;\n\t\tbreak;\n\tcase 65 ... 66:\n\t\trx_status->he_ru = NL80211_RATE_INFO_HE_RU_ALLOC_484;\n\t\toffs = ru - 65;\n\t\tbreak;\n\tcase 67:\n\t\trx_status->he_ru = NL80211_RATE_INFO_HE_RU_ALLOC_996;\n\t\tbreak;\n\tcase 68:\n\t\trx_status->he_ru = NL80211_RATE_INFO_HE_RU_ALLOC_2x996;\n\t\tbreak;\n\t}\n\the->data2 |= le16_encode_bits(offs,\n\t\t\t\t      IEEE80211_RADIOTAP_HE_DATA2_RU_OFFSET);\n\the->data2 |= cpu_to_le16(IEEE80211_RADIOTAP_HE_DATA2_PRISEC_80_KNOWN |\n\t\t\t\t IEEE80211_RADIOTAP_HE_DATA2_RU_OFFSET_KNOWN);\n\tif (phy_data->d1 & cpu_to_le32(IWL_RX_PHY_DATA1_HE_RU_ALLOC_SEC80))\n\t\the->data2 |=\n\t\t\tcpu_to_le16(IEEE80211_RADIOTAP_HE_DATA2_PRISEC_80_SEC);\n\n#define CHECK_BW(bw) \\\n\tBUILD_BUG_ON(IEEE80211_RADIOTAP_HE_MU_FLAGS2_BW_FROM_SIG_A_BW_ ## bw ## MHZ != \\\n\t\t     RATE_MCS_CHAN_WIDTH_##bw >> RATE_MCS_CHAN_WIDTH_POS); \\\n\tBUILD_BUG_ON(IEEE80211_RADIOTAP_HE_DATA6_TB_PPDU_BW_ ## bw ## MHZ != \\\n\t\t     RATE_MCS_CHAN_WIDTH_##bw >> RATE_MCS_CHAN_WIDTH_POS)\n\tCHECK_BW(20);\n\tCHECK_BW(40);\n\tCHECK_BW(80);\n\tCHECK_BW(160);\n\n\tif (he_mu)\n\t\the_mu->flags2 |=\n\t\t\tle16_encode_bits(FIELD_GET(RATE_MCS_CHAN_WIDTH_MSK_V1,\n\t\t\t\t\t\t   rate_n_flags),\n\t\t\t\t\t IEEE80211_RADIOTAP_HE_MU_FLAGS2_BW_FROM_SIG_A_BW);\n\telse if (he_type == RATE_MCS_HE_TYPE_TRIG_V1)\n\t\the->data6 |=\n\t\t\tcpu_to_le16(IEEE80211_RADIOTAP_HE_DATA6_TB_PPDU_BW_KNOWN) |\n\t\t\tle16_encode_bits(FIELD_GET(RATE_MCS_CHAN_WIDTH_MSK_V1,\n\t\t\t\t\t\t   rate_n_flags),\n\t\t\t\t\t IEEE80211_RADIOTAP_HE_DATA6_TB_PPDU_BW);\n}\n\nstatic void iwl_mvm_decode_he_phy_data(struct iwl_mvm *mvm,\n\t\t\t\t       struct iwl_mvm_rx_phy_data *phy_data,\n\t\t\t\t       struct ieee80211_radiotap_he *he,\n\t\t\t\t       struct ieee80211_radiotap_he_mu *he_mu,\n\t\t\t\t       struct ieee80211_rx_status *rx_status,\n\t\t\t\t       int queue)\n{\n\tswitch (phy_data->info_type) {\n\tcase IWL_RX_PHY_INFO_TYPE_NONE:\n\tcase IWL_RX_PHY_INFO_TYPE_CCK:\n\tcase IWL_RX_PHY_INFO_TYPE_OFDM_LGCY:\n\tcase IWL_RX_PHY_INFO_TYPE_HT:\n\tcase IWL_RX_PHY_INFO_TYPE_VHT_SU:\n\tcase IWL_RX_PHY_INFO_TYPE_VHT_MU:\n\tcase IWL_RX_PHY_INFO_TYPE_EHT_MU:\n\tcase IWL_RX_PHY_INFO_TYPE_EHT_TB:\n\tcase IWL_RX_PHY_INFO_TYPE_EHT_MU_EXT:\n\tcase IWL_RX_PHY_INFO_TYPE_EHT_TB_EXT:\n\t\treturn;\n\tcase IWL_RX_PHY_INFO_TYPE_HE_TB_EXT:\n\t\the->data1 |= cpu_to_le16(IEEE80211_RADIOTAP_HE_DATA1_SPTL_REUSE_KNOWN |\n\t\t\t\t\t IEEE80211_RADIOTAP_HE_DATA1_SPTL_REUSE2_KNOWN |\n\t\t\t\t\t IEEE80211_RADIOTAP_HE_DATA1_SPTL_REUSE3_KNOWN |\n\t\t\t\t\t IEEE80211_RADIOTAP_HE_DATA1_SPTL_REUSE4_KNOWN);\n\t\the->data4 |= le16_encode_bits(le32_get_bits(phy_data->d2,\n\t\t\t\t\t\t\t    IWL_RX_PHY_DATA2_HE_TB_EXT_SPTL_REUSE1),\n\t\t\t\t\t      IEEE80211_RADIOTAP_HE_DATA4_TB_SPTL_REUSE1);\n\t\the->data4 |= le16_encode_bits(le32_get_bits(phy_data->d2,\n\t\t\t\t\t\t\t    IWL_RX_PHY_DATA2_HE_TB_EXT_SPTL_REUSE2),\n\t\t\t\t\t      IEEE80211_RADIOTAP_HE_DATA4_TB_SPTL_REUSE2);\n\t\the->data4 |= le16_encode_bits(le32_get_bits(phy_data->d2,\n\t\t\t\t\t\t\t    IWL_RX_PHY_DATA2_HE_TB_EXT_SPTL_REUSE3),\n\t\t\t\t\t      IEEE80211_RADIOTAP_HE_DATA4_TB_SPTL_REUSE3);\n\t\the->data4 |= le16_encode_bits(le32_get_bits(phy_data->d2,\n\t\t\t\t\t\t\t    IWL_RX_PHY_DATA2_HE_TB_EXT_SPTL_REUSE4),\n\t\t\t\t\t      IEEE80211_RADIOTAP_HE_DATA4_TB_SPTL_REUSE4);\n\t\tfallthrough;\n\tcase IWL_RX_PHY_INFO_TYPE_HE_SU:\n\tcase IWL_RX_PHY_INFO_TYPE_HE_MU:\n\tcase IWL_RX_PHY_INFO_TYPE_HE_MU_EXT:\n\tcase IWL_RX_PHY_INFO_TYPE_HE_TB:\n\t\t \n\t\the->data1 |= cpu_to_le16(IEEE80211_RADIOTAP_HE_DATA1_LDPC_XSYMSEG_KNOWN |\n\t\t\t\t\t IEEE80211_RADIOTAP_HE_DATA1_DOPPLER_KNOWN |\n\t\t\t\t\t IEEE80211_RADIOTAP_HE_DATA1_BSS_COLOR_KNOWN);\n\t\the->data2 |= cpu_to_le16(IEEE80211_RADIOTAP_HE_DATA2_PRE_FEC_PAD_KNOWN |\n\t\t\t\t\t IEEE80211_RADIOTAP_HE_DATA2_PE_DISAMBIG_KNOWN |\n\t\t\t\t\t IEEE80211_RADIOTAP_HE_DATA2_TXOP_KNOWN |\n\t\t\t\t\t IEEE80211_RADIOTAP_HE_DATA2_NUM_LTF_SYMS_KNOWN);\n\t\the->data3 |= le16_encode_bits(le32_get_bits(phy_data->d0,\n\t\t\t\t\t\t\t    IWL_RX_PHY_DATA0_HE_BSS_COLOR_MASK),\n\t\t\t\t\t      IEEE80211_RADIOTAP_HE_DATA3_BSS_COLOR);\n\t\tif (phy_data->info_type != IWL_RX_PHY_INFO_TYPE_HE_TB &&\n\t\t    phy_data->info_type != IWL_RX_PHY_INFO_TYPE_HE_TB_EXT) {\n\t\t\the->data1 |= cpu_to_le16(IEEE80211_RADIOTAP_HE_DATA1_UL_DL_KNOWN);\n\t\t\the->data3 |= le16_encode_bits(le32_get_bits(phy_data->d0,\n\t\t\t\t\t\t\t    IWL_RX_PHY_DATA0_HE_UPLINK),\n\t\t\t\t\t\t      IEEE80211_RADIOTAP_HE_DATA3_UL_DL);\n\t\t}\n\t\the->data3 |= le16_encode_bits(le32_get_bits(phy_data->d0,\n\t\t\t\t\t\t\t    IWL_RX_PHY_DATA0_HE_LDPC_EXT_SYM),\n\t\t\t\t\t      IEEE80211_RADIOTAP_HE_DATA3_LDPC_XSYMSEG);\n\t\the->data5 |= le16_encode_bits(le32_get_bits(phy_data->d0,\n\t\t\t\t\t\t\t    IWL_RX_PHY_DATA0_HE_PRE_FEC_PAD_MASK),\n\t\t\t\t\t      IEEE80211_RADIOTAP_HE_DATA5_PRE_FEC_PAD);\n\t\the->data5 |= le16_encode_bits(le32_get_bits(phy_data->d0,\n\t\t\t\t\t\t\t    IWL_RX_PHY_DATA0_HE_PE_DISAMBIG),\n\t\t\t\t\t      IEEE80211_RADIOTAP_HE_DATA5_PE_DISAMBIG);\n\t\the->data5 |= le16_encode_bits(le32_get_bits(phy_data->d1,\n\t\t\t\t\t\t\t    IWL_RX_PHY_DATA1_HE_LTF_NUM_MASK),\n\t\t\t\t\t      IEEE80211_RADIOTAP_HE_DATA5_NUM_LTF_SYMS);\n\t\the->data6 |= le16_encode_bits(le32_get_bits(phy_data->d0,\n\t\t\t\t\t\t\t    IWL_RX_PHY_DATA0_HE_TXOP_DUR_MASK),\n\t\t\t\t\t      IEEE80211_RADIOTAP_HE_DATA6_TXOP);\n\t\the->data6 |= le16_encode_bits(le32_get_bits(phy_data->d0,\n\t\t\t\t\t\t\t    IWL_RX_PHY_DATA0_HE_DOPPLER),\n\t\t\t\t\t      IEEE80211_RADIOTAP_HE_DATA6_DOPPLER);\n\t\tbreak;\n\t}\n\n\tswitch (phy_data->info_type) {\n\tcase IWL_RX_PHY_INFO_TYPE_HE_MU_EXT:\n\tcase IWL_RX_PHY_INFO_TYPE_HE_MU:\n\tcase IWL_RX_PHY_INFO_TYPE_HE_SU:\n\t\the->data1 |= cpu_to_le16(IEEE80211_RADIOTAP_HE_DATA1_SPTL_REUSE_KNOWN);\n\t\the->data4 |= le16_encode_bits(le32_get_bits(phy_data->d0,\n\t\t\t\t\t\t\t    IWL_RX_PHY_DATA0_HE_SPATIAL_REUSE_MASK),\n\t\t\t\t\t      IEEE80211_RADIOTAP_HE_DATA4_SU_MU_SPTL_REUSE);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tswitch (phy_data->info_type) {\n\tcase IWL_RX_PHY_INFO_TYPE_HE_MU_EXT:\n\t\the_mu->flags1 |=\n\t\t\tle16_encode_bits(le16_get_bits(phy_data->d4,\n\t\t\t\t\t\t       IWL_RX_PHY_DATA4_HE_MU_EXT_SIGB_DCM),\n\t\t\t\t\t IEEE80211_RADIOTAP_HE_MU_FLAGS1_SIG_B_DCM);\n\t\the_mu->flags1 |=\n\t\t\tle16_encode_bits(le16_get_bits(phy_data->d4,\n\t\t\t\t\t\t       IWL_RX_PHY_DATA4_HE_MU_EXT_SIGB_MCS_MASK),\n\t\t\t\t\t IEEE80211_RADIOTAP_HE_MU_FLAGS1_SIG_B_MCS);\n\t\the_mu->flags2 |=\n\t\t\tle16_encode_bits(le16_get_bits(phy_data->d4,\n\t\t\t\t\t\t       IWL_RX_PHY_DATA4_HE_MU_EXT_PREAMBLE_PUNC_TYPE_MASK),\n\t\t\t\t\t IEEE80211_RADIOTAP_HE_MU_FLAGS2_PUNC_FROM_SIG_A_BW);\n\t\tiwl_mvm_decode_he_mu_ext(mvm, phy_data, he_mu);\n\t\tfallthrough;\n\tcase IWL_RX_PHY_INFO_TYPE_HE_MU:\n\t\the_mu->flags2 |=\n\t\t\tle16_encode_bits(le32_get_bits(phy_data->d1,\n\t\t\t\t\t\t       IWL_RX_PHY_DATA1_HE_MU_SIBG_SYM_OR_USER_NUM_MASK),\n\t\t\t\t\t IEEE80211_RADIOTAP_HE_MU_FLAGS2_SIG_B_SYMS_USERS);\n\t\the_mu->flags2 |=\n\t\t\tle16_encode_bits(le32_get_bits(phy_data->d1,\n\t\t\t\t\t\t       IWL_RX_PHY_DATA1_HE_MU_SIGB_COMPRESSION),\n\t\t\t\t\t IEEE80211_RADIOTAP_HE_MU_FLAGS2_SIG_B_COMP);\n\t\tfallthrough;\n\tcase IWL_RX_PHY_INFO_TYPE_HE_TB:\n\tcase IWL_RX_PHY_INFO_TYPE_HE_TB_EXT:\n\t\tiwl_mvm_decode_he_phy_ru_alloc(phy_data, he, he_mu, rx_status);\n\t\tbreak;\n\tcase IWL_RX_PHY_INFO_TYPE_HE_SU:\n\t\the->data1 |= cpu_to_le16(IEEE80211_RADIOTAP_HE_DATA1_BEAM_CHANGE_KNOWN);\n\t\the->data3 |= le16_encode_bits(le32_get_bits(phy_data->d0,\n\t\t\t\t\t\t\t    IWL_RX_PHY_DATA0_HE_BEAM_CHNG),\n\t\t\t\t\t      IEEE80211_RADIOTAP_HE_DATA3_BEAM_CHANGE);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n\n#define LE32_DEC_ENC(value, dec_bits, enc_bits) \\\n\tle32_encode_bits(le32_get_bits(value, dec_bits), enc_bits)\n\n#define IWL_MVM_ENC_USIG_VALUE_MASK(usig, in_value, dec_bits, enc_bits) do { \\\n\ttypeof(enc_bits) _enc_bits = enc_bits; \\\n\ttypeof(usig) _usig = usig; \\\n\t(_usig)->mask |= cpu_to_le32(_enc_bits); \\\n\t(_usig)->value |= LE32_DEC_ENC(in_value, dec_bits, _enc_bits); \\\n} while (0)\n\n#define __IWL_MVM_ENC_EHT_RU(rt_data, rt_ru, fw_data, fw_ru) \\\n\teht->data[(rt_data)] |= \\\n\t\t(cpu_to_le32 \\\n\t\t (IEEE80211_RADIOTAP_EHT_DATA ## rt_data ## _RU_ALLOC_CC_ ## rt_ru ## _KNOWN) | \\\n\t\t LE32_DEC_ENC(data ## fw_data, \\\n\t\t\t      IWL_RX_PHY_DATA ## fw_data ## _EHT_MU_EXT_RU_ALLOC_ ## fw_ru, \\\n\t\t\t      IEEE80211_RADIOTAP_EHT_DATA ## rt_data ## _RU_ALLOC_CC_ ## rt_ru))\n\n#define _IWL_MVM_ENC_EHT_RU(rt_data, rt_ru, fw_data, fw_ru)\t\\\n\t__IWL_MVM_ENC_EHT_RU(rt_data, rt_ru, fw_data, fw_ru)\n\n#define IEEE80211_RADIOTAP_RU_DATA_1_1_1\t1\n#define IEEE80211_RADIOTAP_RU_DATA_2_1_1\t2\n#define IEEE80211_RADIOTAP_RU_DATA_1_1_2\t2\n#define IEEE80211_RADIOTAP_RU_DATA_2_1_2\t2\n#define IEEE80211_RADIOTAP_RU_DATA_1_2_1\t3\n#define IEEE80211_RADIOTAP_RU_DATA_2_2_1\t3\n#define IEEE80211_RADIOTAP_RU_DATA_1_2_2\t3\n#define IEEE80211_RADIOTAP_RU_DATA_2_2_2\t4\n\n#define IWL_RX_RU_DATA_A1\t\t\t2\n#define IWL_RX_RU_DATA_A2\t\t\t2\n#define IWL_RX_RU_DATA_B1\t\t\t2\n#define IWL_RX_RU_DATA_B2\t\t\t3\n#define IWL_RX_RU_DATA_C1\t\t\t3\n#define IWL_RX_RU_DATA_C2\t\t\t3\n#define IWL_RX_RU_DATA_D1\t\t\t4\n#define IWL_RX_RU_DATA_D2\t\t\t4\n\n#define IWL_MVM_ENC_EHT_RU(rt_ru, fw_ru)\t\t\t\t\\\n\t_IWL_MVM_ENC_EHT_RU(IEEE80211_RADIOTAP_RU_DATA_ ## rt_ru,\t\\\n\t\t\t    rt_ru,\t\t\t\t\t\\\n\t\t\t    IWL_RX_RU_DATA_ ## fw_ru,\t\t\t\\\n\t\t\t    fw_ru)\n\nstatic void iwl_mvm_decode_eht_ext_mu(struct iwl_mvm *mvm,\n\t\t\t\t      struct iwl_mvm_rx_phy_data *phy_data,\n\t\t\t\t      struct ieee80211_rx_status *rx_status,\n\t\t\t\t      struct ieee80211_radiotap_eht *eht,\n\t\t\t\t      struct ieee80211_radiotap_eht_usig *usig)\n{\n\tif (phy_data->with_data) {\n\t\t__le32 data1 = phy_data->d1;\n\t\t__le32 data2 = phy_data->d2;\n\t\t__le32 data3 = phy_data->d3;\n\t\t__le32 data4 = phy_data->eht_d4;\n\t\t__le32 data5 = phy_data->d5;\n\t\tu32 phy_bw = phy_data->rate_n_flags & RATE_MCS_CHAN_WIDTH_MSK;\n\n\t\tIWL_MVM_ENC_USIG_VALUE_MASK(usig, data5,\n\t\t\t\t\t    IWL_RX_PHY_DATA5_EHT_TYPE_AND_COMP,\n\t\t\t\t\t    IEEE80211_RADIOTAP_EHT_USIG2_MU_B0_B1_PPDU_TYPE);\n\t\tIWL_MVM_ENC_USIG_VALUE_MASK(usig, data5,\n\t\t\t\t\t    IWL_RX_PHY_DATA5_EHT_MU_PUNC_CH_CODE,\n\t\t\t\t\t    IEEE80211_RADIOTAP_EHT_USIG2_MU_B3_B7_PUNCTURED_INFO);\n\t\tIWL_MVM_ENC_USIG_VALUE_MASK(usig, data4,\n\t\t\t\t\t    IWL_RX_PHY_DATA4_EHT_MU_EXT_SIGB_MCS,\n\t\t\t\t\t    IEEE80211_RADIOTAP_EHT_USIG2_MU_B9_B10_SIG_MCS);\n\t\tIWL_MVM_ENC_USIG_VALUE_MASK\n\t\t\t(usig, data1, IWL_RX_PHY_DATA1_EHT_MU_NUM_SIG_SYM_USIGA2,\n\t\t\t IEEE80211_RADIOTAP_EHT_USIG2_MU_B11_B15_EHT_SIG_SYMBOLS);\n\n\t\teht->user_info[0] |=\n\t\t\tcpu_to_le32(IEEE80211_RADIOTAP_EHT_USER_INFO_STA_ID_KNOWN) |\n\t\t\tLE32_DEC_ENC(data5, IWL_RX_PHY_DATA5_EHT_MU_STA_ID_USR,\n\t\t\t\t     IEEE80211_RADIOTAP_EHT_USER_INFO_STA_ID);\n\n\t\teht->known |= cpu_to_le32(IEEE80211_RADIOTAP_EHT_KNOWN_NR_NON_OFDMA_USERS_M);\n\t\teht->data[7] |= LE32_DEC_ENC\n\t\t\t(data5, IWL_RX_PHY_DATA5_EHT_MU_NUM_USR_NON_OFDMA,\n\t\t\t IEEE80211_RADIOTAP_EHT_DATA7_NUM_OF_NON_OFDMA_USERS);\n\n\t\t \n\n\t\tswitch (phy_bw) {\n\t\tcase RATE_MCS_CHAN_WIDTH_320:\n\t\t\t \n\t\tcase RATE_MCS_CHAN_WIDTH_160:\n\t\t\t \n\t\t\tIWL_MVM_ENC_EHT_RU(1_2_1, A2);\n\t\t\tIWL_MVM_ENC_EHT_RU(1_2_2, C2);\n\t\t\t \n\t\t\tIWL_MVM_ENC_EHT_RU(2_2_1, B2);\n\t\t\tIWL_MVM_ENC_EHT_RU(2_2_2, D2);\n\t\t\tfallthrough;\n\t\tcase RATE_MCS_CHAN_WIDTH_80:\n\t\t\t \n\t\t\tIWL_MVM_ENC_EHT_RU(1_1_2, C1);\n\t\t\t \n\t\t\tIWL_MVM_ENC_EHT_RU(2_1_2, D1);\n\t\t\tfallthrough;\n\t\tcase RATE_MCS_CHAN_WIDTH_40:\n\t\t\t \n\t\t\tIWL_MVM_ENC_EHT_RU(2_1_1, B1);\n\t\t\tfallthrough;\n\t\tcase RATE_MCS_CHAN_WIDTH_20:\n\t\t\tIWL_MVM_ENC_EHT_RU(1_1_1, A1);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t__le32 usig_a1 = phy_data->rx_vec[0];\n\t\t__le32 usig_a2 = phy_data->rx_vec[1];\n\n\t\tIWL_MVM_ENC_USIG_VALUE_MASK(usig, usig_a1,\n\t\t\t\t\t    IWL_RX_USIG_A1_DISREGARD,\n\t\t\t\t\t    IEEE80211_RADIOTAP_EHT_USIG1_MU_B20_B24_DISREGARD);\n\t\tIWL_MVM_ENC_USIG_VALUE_MASK(usig, usig_a1,\n\t\t\t\t\t    IWL_RX_USIG_A1_VALIDATE,\n\t\t\t\t\t    IEEE80211_RADIOTAP_EHT_USIG1_MU_B25_VALIDATE);\n\t\tIWL_MVM_ENC_USIG_VALUE_MASK(usig, usig_a2,\n\t\t\t\t\t    IWL_RX_USIG_A2_EHT_PPDU_TYPE,\n\t\t\t\t\t    IEEE80211_RADIOTAP_EHT_USIG2_MU_B0_B1_PPDU_TYPE);\n\t\tIWL_MVM_ENC_USIG_VALUE_MASK(usig, usig_a2,\n\t\t\t\t\t    IWL_RX_USIG_A2_EHT_USIG2_VALIDATE_B2,\n\t\t\t\t\t    IEEE80211_RADIOTAP_EHT_USIG2_MU_B2_VALIDATE);\n\t\tIWL_MVM_ENC_USIG_VALUE_MASK(usig, usig_a2,\n\t\t\t\t\t    IWL_RX_USIG_A2_EHT_PUNC_CHANNEL,\n\t\t\t\t\t    IEEE80211_RADIOTAP_EHT_USIG2_MU_B3_B7_PUNCTURED_INFO);\n\t\tIWL_MVM_ENC_USIG_VALUE_MASK(usig, usig_a2,\n\t\t\t\t\t    IWL_RX_USIG_A2_EHT_USIG2_VALIDATE_B8,\n\t\t\t\t\t    IEEE80211_RADIOTAP_EHT_USIG2_MU_B8_VALIDATE);\n\t\tIWL_MVM_ENC_USIG_VALUE_MASK(usig, usig_a2,\n\t\t\t\t\t    IWL_RX_USIG_A2_EHT_SIG_MCS,\n\t\t\t\t\t    IEEE80211_RADIOTAP_EHT_USIG2_MU_B9_B10_SIG_MCS);\n\t\tIWL_MVM_ENC_USIG_VALUE_MASK\n\t\t\t(usig, usig_a2, IWL_RX_USIG_A2_EHT_SIG_SYM_NUM,\n\t\t\t IEEE80211_RADIOTAP_EHT_USIG2_MU_B11_B15_EHT_SIG_SYMBOLS);\n\t\tIWL_MVM_ENC_USIG_VALUE_MASK(usig, usig_a2,\n\t\t\t\t\t    IWL_RX_USIG_A2_EHT_CRC_OK,\n\t\t\t\t\t    IEEE80211_RADIOTAP_EHT_USIG2_MU_B16_B19_CRC);\n\t}\n}\n\nstatic void iwl_mvm_decode_eht_ext_tb(struct iwl_mvm *mvm,\n\t\t\t\t      struct iwl_mvm_rx_phy_data *phy_data,\n\t\t\t\t      struct ieee80211_rx_status *rx_status,\n\t\t\t\t      struct ieee80211_radiotap_eht *eht,\n\t\t\t\t      struct ieee80211_radiotap_eht_usig *usig)\n{\n\tif (phy_data->with_data) {\n\t\t__le32 data5 = phy_data->d5;\n\n\t\tIWL_MVM_ENC_USIG_VALUE_MASK(usig, data5,\n\t\t\t\t\t    IWL_RX_PHY_DATA5_EHT_TYPE_AND_COMP,\n\t\t\t\t\t    IEEE80211_RADIOTAP_EHT_USIG2_TB_B0_B1_PPDU_TYPE);\n\t\tIWL_MVM_ENC_USIG_VALUE_MASK(usig, data5,\n\t\t\t\t\t    IWL_RX_PHY_DATA5_EHT_TB_SPATIAL_REUSE1,\n\t\t\t\t\t    IEEE80211_RADIOTAP_EHT_USIG2_TB_B3_B6_SPATIAL_REUSE_1);\n\n\t\tIWL_MVM_ENC_USIG_VALUE_MASK(usig, data5,\n\t\t\t\t\t    IWL_RX_PHY_DATA5_EHT_TB_SPATIAL_REUSE2,\n\t\t\t\t\t    IEEE80211_RADIOTAP_EHT_USIG2_TB_B7_B10_SPATIAL_REUSE_2);\n\t} else {\n\t\t__le32 usig_a1 = phy_data->rx_vec[0];\n\t\t__le32 usig_a2 = phy_data->rx_vec[1];\n\n\t\tIWL_MVM_ENC_USIG_VALUE_MASK(usig, usig_a1,\n\t\t\t\t\t    IWL_RX_USIG_A1_DISREGARD,\n\t\t\t\t\t    IEEE80211_RADIOTAP_EHT_USIG1_TB_B20_B25_DISREGARD);\n\t\tIWL_MVM_ENC_USIG_VALUE_MASK(usig, usig_a2,\n\t\t\t\t\t    IWL_RX_USIG_A2_EHT_PPDU_TYPE,\n\t\t\t\t\t    IEEE80211_RADIOTAP_EHT_USIG2_TB_B0_B1_PPDU_TYPE);\n\t\tIWL_MVM_ENC_USIG_VALUE_MASK(usig, usig_a2,\n\t\t\t\t\t    IWL_RX_USIG_A2_EHT_USIG2_VALIDATE_B2,\n\t\t\t\t\t    IEEE80211_RADIOTAP_EHT_USIG2_TB_B2_VALIDATE);\n\t\tIWL_MVM_ENC_USIG_VALUE_MASK(usig, usig_a2,\n\t\t\t\t\t    IWL_RX_USIG_A2_EHT_TRIG_SPATIAL_REUSE_1,\n\t\t\t\t\t    IEEE80211_RADIOTAP_EHT_USIG2_TB_B3_B6_SPATIAL_REUSE_1);\n\t\tIWL_MVM_ENC_USIG_VALUE_MASK(usig, usig_a2,\n\t\t\t\t\t    IWL_RX_USIG_A2_EHT_TRIG_SPATIAL_REUSE_2,\n\t\t\t\t\t    IEEE80211_RADIOTAP_EHT_USIG2_TB_B7_B10_SPATIAL_REUSE_2);\n\t\tIWL_MVM_ENC_USIG_VALUE_MASK(usig, usig_a2,\n\t\t\t\t\t    IWL_RX_USIG_A2_EHT_TRIG_USIG2_DISREGARD,\n\t\t\t\t\t    IEEE80211_RADIOTAP_EHT_USIG2_TB_B11_B15_DISREGARD);\n\t\tIWL_MVM_ENC_USIG_VALUE_MASK(usig, usig_a2,\n\t\t\t\t\t    IWL_RX_USIG_A2_EHT_CRC_OK,\n\t\t\t\t\t    IEEE80211_RADIOTAP_EHT_USIG2_TB_B16_B19_CRC);\n\t}\n}\n\nstatic void iwl_mvm_decode_eht_ru(struct iwl_mvm *mvm,\n\t\t\t\t  struct ieee80211_rx_status *rx_status,\n\t\t\t\t  struct ieee80211_radiotap_eht *eht)\n{\n\tu32 ru = le32_get_bits(eht->data[8],\n\t\t\t       IEEE80211_RADIOTAP_EHT_DATA8_RU_ALLOC_TB_FMT_B7_B1);\n\tenum nl80211_eht_ru_alloc nl_ru;\n\n\t \n\n\tswitch (ru) {\n\tcase 0 ... 36:\n\t\tnl_ru = NL80211_RATE_INFO_EHT_RU_ALLOC_26;\n\t\tbreak;\n\tcase 37 ... 52:\n\t\tnl_ru = NL80211_RATE_INFO_EHT_RU_ALLOC_52;\n\t\tbreak;\n\tcase 53 ... 60:\n\t\tnl_ru = NL80211_RATE_INFO_EHT_RU_ALLOC_106;\n\t\tbreak;\n\tcase 61 ... 64:\n\t\tnl_ru = NL80211_RATE_INFO_EHT_RU_ALLOC_242;\n\t\tbreak;\n\tcase 65 ... 66:\n\t\tnl_ru = NL80211_RATE_INFO_EHT_RU_ALLOC_484;\n\t\tbreak;\n\tcase 67:\n\t\tnl_ru = NL80211_RATE_INFO_EHT_RU_ALLOC_996;\n\t\tbreak;\n\tcase 68:\n\t\tnl_ru = NL80211_RATE_INFO_EHT_RU_ALLOC_2x996;\n\t\tbreak;\n\tcase 69:\n\t\tnl_ru = NL80211_RATE_INFO_EHT_RU_ALLOC_4x996;\n\t\tbreak;\n\tcase 70 ... 81:\n\t\tnl_ru = NL80211_RATE_INFO_EHT_RU_ALLOC_52P26;\n\t\tbreak;\n\tcase 82 ... 89:\n\t\tnl_ru = NL80211_RATE_INFO_EHT_RU_ALLOC_106P26;\n\t\tbreak;\n\tcase 90 ... 93:\n\t\tnl_ru = NL80211_RATE_INFO_EHT_RU_ALLOC_484P242;\n\t\tbreak;\n\tcase 94 ... 95:\n\t\tnl_ru = NL80211_RATE_INFO_EHT_RU_ALLOC_996P484;\n\t\tbreak;\n\tcase 96 ... 99:\n\t\tnl_ru = NL80211_RATE_INFO_EHT_RU_ALLOC_996P484P242;\n\t\tbreak;\n\tcase 100 ... 103:\n\t\tnl_ru = NL80211_RATE_INFO_EHT_RU_ALLOC_2x996P484;\n\t\tbreak;\n\tcase 104:\n\t\tnl_ru = NL80211_RATE_INFO_EHT_RU_ALLOC_3x996;\n\t\tbreak;\n\tcase 105 ... 106:\n\t\tnl_ru = NL80211_RATE_INFO_EHT_RU_ALLOC_3x996P484;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\trx_status->bw = RATE_INFO_BW_EHT_RU;\n\trx_status->eht.ru = nl_ru;\n}\n\nstatic void iwl_mvm_decode_eht_phy_data(struct iwl_mvm *mvm,\n\t\t\t\t\tstruct iwl_mvm_rx_phy_data *phy_data,\n\t\t\t\t\tstruct ieee80211_rx_status *rx_status,\n\t\t\t\t\tstruct ieee80211_radiotap_eht *eht,\n\t\t\t\t\tstruct ieee80211_radiotap_eht_usig *usig)\n\n{\n\t__le32 data0 = phy_data->d0;\n\t__le32 data1 = phy_data->d1;\n\t__le32 usig_a1 = phy_data->rx_vec[0];\n\tu8 info_type = phy_data->info_type;\n\n\t \n\tif (info_type < IWL_RX_PHY_INFO_TYPE_EHT_MU ||\n\t    info_type > IWL_RX_PHY_INFO_TYPE_EHT_TB_EXT)\n\t\treturn;\n\n\tusig->common |= cpu_to_le32\n\t\t(IEEE80211_RADIOTAP_EHT_USIG_COMMON_UL_DL_KNOWN |\n\t\t IEEE80211_RADIOTAP_EHT_USIG_COMMON_BSS_COLOR_KNOWN);\n\tif (phy_data->with_data) {\n\t\tusig->common |= LE32_DEC_ENC(data0,\n\t\t\t\t\t     IWL_RX_PHY_DATA0_EHT_UPLINK,\n\t\t\t\t\t     IEEE80211_RADIOTAP_EHT_USIG_COMMON_UL_DL);\n\t\tusig->common |= LE32_DEC_ENC(data0,\n\t\t\t\t\t     IWL_RX_PHY_DATA0_EHT_BSS_COLOR_MASK,\n\t\t\t\t\t     IEEE80211_RADIOTAP_EHT_USIG_COMMON_BSS_COLOR);\n\t} else {\n\t\tusig->common |= LE32_DEC_ENC(usig_a1,\n\t\t\t\t\t     IWL_RX_USIG_A1_UL_FLAG,\n\t\t\t\t\t     IEEE80211_RADIOTAP_EHT_USIG_COMMON_UL_DL);\n\t\tusig->common |= LE32_DEC_ENC(usig_a1,\n\t\t\t\t\t     IWL_RX_USIG_A1_BSS_COLOR,\n\t\t\t\t\t     IEEE80211_RADIOTAP_EHT_USIG_COMMON_BSS_COLOR);\n\t}\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_SNIFF_VALIDATE_SUPPORT)) {\n\t\tusig->common |=\n\t\t\tcpu_to_le32(IEEE80211_RADIOTAP_EHT_USIG_COMMON_VALIDATE_BITS_CHECKED);\n\t\tusig->common |=\n\t\t\tLE32_DEC_ENC(data0, IWL_RX_PHY_DATA0_EHT_VALIDATE,\n\t\t\t\t     IEEE80211_RADIOTAP_EHT_USIG_COMMON_VALIDATE_BITS_OK);\n\t}\n\n\teht->known |= cpu_to_le32(IEEE80211_RADIOTAP_EHT_KNOWN_SPATIAL_REUSE);\n\teht->data[0] |= LE32_DEC_ENC(data0,\n\t\t\t\t     IWL_RX_PHY_DATA0_ETH_SPATIAL_REUSE_MASK,\n\t\t\t\t     IEEE80211_RADIOTAP_EHT_DATA0_SPATIAL_REUSE);\n\n\t \n\teht->known |= cpu_to_le32(IEEE80211_RADIOTAP_EHT_KNOWN_RU_ALLOC_TB_FMT);\n\teht->data[8] |= LE32_DEC_ENC(data0, IWL_RX_PHY_DATA0_EHT_PS160,\n\t\t\t\t     IEEE80211_RADIOTAP_EHT_DATA8_RU_ALLOC_TB_FMT_PS_160);\n\teht->data[8] |= LE32_DEC_ENC(data1, IWL_RX_PHY_DATA1_EHT_RU_ALLOC_B0,\n\t\t\t\t     IEEE80211_RADIOTAP_EHT_DATA8_RU_ALLOC_TB_FMT_B0);\n\teht->data[8] |= LE32_DEC_ENC(data1, IWL_RX_PHY_DATA1_EHT_RU_ALLOC_B1_B7,\n\t\t\t\t     IEEE80211_RADIOTAP_EHT_DATA8_RU_ALLOC_TB_FMT_B7_B1);\n\n\tiwl_mvm_decode_eht_ru(mvm, rx_status, eht);\n\n\t \n\teht->known |= cpu_to_le32(IEEE80211_RADIOTAP_EHT_KNOWN_PRIMARY_80);\n\teht->data[1] |=\n\t\tle32_encode_bits(mvm->monitor_p80,\n\t\t\t\t IEEE80211_RADIOTAP_EHT_DATA1_PRIMARY_80);\n\n\tusig->common |= cpu_to_le32(IEEE80211_RADIOTAP_EHT_USIG_COMMON_TXOP_KNOWN);\n\tif (phy_data->with_data)\n\t\tusig->common |= LE32_DEC_ENC(data0, IWL_RX_PHY_DATA0_EHT_TXOP_DUR_MASK,\n\t\t\t\t\t     IEEE80211_RADIOTAP_EHT_USIG_COMMON_TXOP);\n\telse\n\t\tusig->common |= LE32_DEC_ENC(usig_a1, IWL_RX_USIG_A1_TXOP_DURATION,\n\t\t\t\t\t     IEEE80211_RADIOTAP_EHT_USIG_COMMON_TXOP);\n\n\teht->known |= cpu_to_le32(IEEE80211_RADIOTAP_EHT_KNOWN_LDPC_EXTRA_SYM_OM);\n\teht->data[0] |= LE32_DEC_ENC(data0, IWL_RX_PHY_DATA0_EHT_LDPC_EXT_SYM,\n\t\t\t\t     IEEE80211_RADIOTAP_EHT_DATA0_LDPC_EXTRA_SYM_OM);\n\n\teht->known |= cpu_to_le32(IEEE80211_RADIOTAP_EHT_KNOWN_PRE_PADD_FACOR_OM);\n\teht->data[0] |= LE32_DEC_ENC(data0, IWL_RX_PHY_DATA0_EHT_PRE_FEC_PAD_MASK,\n\t\t\t\t    IEEE80211_RADIOTAP_EHT_DATA0_PRE_PADD_FACOR_OM);\n\n\teht->known |= cpu_to_le32(IEEE80211_RADIOTAP_EHT_KNOWN_PE_DISAMBIGUITY_OM);\n\teht->data[0] |= LE32_DEC_ENC(data0, IWL_RX_PHY_DATA0_EHT_PE_DISAMBIG,\n\t\t\t\t     IEEE80211_RADIOTAP_EHT_DATA0_PE_DISAMBIGUITY_OM);\n\n\t \n\n\tif (!le32_get_bits(data0, IWL_RX_PHY_DATA0_EHT_SIGA_CRC_OK))\n\t\tusig->common |= cpu_to_le32(IEEE80211_RADIOTAP_EHT_USIG_COMMON_BAD_USIG_CRC);\n\n\tusig->common |= cpu_to_le32(IEEE80211_RADIOTAP_EHT_USIG_COMMON_PHY_VER_KNOWN);\n\tusig->common |= LE32_DEC_ENC(data0, IWL_RX_PHY_DATA0_EHT_PHY_VER,\n\t\t\t\t     IEEE80211_RADIOTAP_EHT_USIG_COMMON_PHY_VER);\n\n\t \n\n\teht->known |= cpu_to_le32(IEEE80211_RADIOTAP_EHT_KNOWN_EHT_LTF);\n\teht->data[0] |= LE32_DEC_ENC(data1, IWL_RX_PHY_DATA1_EHT_SIG_LTF_NUM,\n\t\t\t\t     IEEE80211_RADIOTAP_EHT_DATA0_EHT_LTF);\n\n\tif (info_type == IWL_RX_PHY_INFO_TYPE_EHT_TB_EXT ||\n\t    info_type == IWL_RX_PHY_INFO_TYPE_EHT_TB)\n\t\tiwl_mvm_decode_eht_ext_tb(mvm, phy_data, rx_status, eht, usig);\n\n\tif (info_type == IWL_RX_PHY_INFO_TYPE_EHT_MU_EXT ||\n\t    info_type == IWL_RX_PHY_INFO_TYPE_EHT_MU)\n\t\tiwl_mvm_decode_eht_ext_mu(mvm, phy_data, rx_status, eht, usig);\n}\n\nstatic void iwl_mvm_rx_eht(struct iwl_mvm *mvm, struct sk_buff *skb,\n\t\t\t   struct iwl_mvm_rx_phy_data *phy_data,\n\t\t\t   int queue)\n{\n\tstruct ieee80211_rx_status *rx_status = IEEE80211_SKB_RXCB(skb);\n\n\tstruct ieee80211_radiotap_eht *eht;\n\tstruct ieee80211_radiotap_eht_usig *usig;\n\tsize_t eht_len = sizeof(*eht);\n\n\tu32 rate_n_flags = phy_data->rate_n_flags;\n\tu32 he_type = rate_n_flags & RATE_MCS_HE_TYPE_MSK;\n\t \n\tu8 ltf = IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_UNKNOWN;\n\tu16 phy_info = phy_data->phy_info;\n\tu32 bw;\n\n\t \n\tif (phy_data->with_data)\n\t\teht_len += sizeof(u32);\n\n\teht = iwl_mvm_radiotap_put_tlv(skb, IEEE80211_RADIOTAP_EHT, eht_len);\n\n\tusig = iwl_mvm_radiotap_put_tlv(skb, IEEE80211_RADIOTAP_EHT_USIG,\n\t\t\t\t\tsizeof(*usig));\n\trx_status->flag |= RX_FLAG_RADIOTAP_TLV_AT_END;\n\tusig->common |=\n\t\tcpu_to_le32(IEEE80211_RADIOTAP_EHT_USIG_COMMON_BW_KNOWN);\n\n\t \n\tbw = FIELD_GET(RATE_MCS_CHAN_WIDTH_MSK, rate_n_flags);\n\tif (bw == RATE_MCS_CHAN_WIDTH_320_VAL)\n\t\tbw += FIELD_GET(IWL_RX_PHY_DATA0_EHT_BW320_SLOT,\n\t\t\t\tle32_to_cpu(phy_data->d0));\n\n\tusig->common |= cpu_to_le32\n\t\t(FIELD_PREP(IEEE80211_RADIOTAP_EHT_USIG_COMMON_BW, bw));\n\n\t \n\tif (!queue && !(phy_info & IWL_RX_MPDU_PHY_AMPDU)) {\n\t\trx_status->flag |= RX_FLAG_AMPDU_DETAILS;\n\t\trx_status->flag |= RX_FLAG_AMPDU_EOF_BIT_KNOWN;\n\t\tif (phy_data->d0 & cpu_to_le32(IWL_RX_PHY_DATA0_EHT_DELIM_EOF))\n\t\t\trx_status->flag |= RX_FLAG_AMPDU_EOF_BIT;\n\t}\n\n\t \n\tif (!queue && (phy_info & IWL_RX_MPDU_PHY_TSF_OVERLOAD) &&\n\t    (phy_info & IWL_RX_MPDU_PHY_AMPDU) && phy_data->first_subframe) {\n\t\trx_status->flag |= RX_FLAG_AMPDU_EOF_BIT_KNOWN;\n\t\tif (phy_data->d0 & cpu_to_le32(IWL_RX_PHY_DATA0_EHT_DELIM_EOF))\n\t\t\trx_status->flag |= RX_FLAG_AMPDU_EOF_BIT;\n\t}\n\n\tif (phy_info & IWL_RX_MPDU_PHY_TSF_OVERLOAD)\n\t\tiwl_mvm_decode_eht_phy_data(mvm, phy_data, rx_status, eht, usig);\n\n#define CHECK_TYPE(F)\t\t\t\t\t\t\t\\\n\tBUILD_BUG_ON(IEEE80211_RADIOTAP_HE_DATA1_FORMAT_ ## F !=\t\\\n\t\t     (RATE_MCS_HE_TYPE_ ## F >> RATE_MCS_HE_TYPE_POS))\n\n\tCHECK_TYPE(SU);\n\tCHECK_TYPE(EXT_SU);\n\tCHECK_TYPE(MU);\n\tCHECK_TYPE(TRIG);\n\n\tswitch (FIELD_GET(RATE_MCS_HE_GI_LTF_MSK, rate_n_flags)) {\n\tcase 0:\n\t\tif (he_type == RATE_MCS_HE_TYPE_TRIG) {\n\t\t\trx_status->eht.gi = NL80211_RATE_INFO_EHT_GI_1_6;\n\t\t\tltf = IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_1X;\n\t\t} else {\n\t\t\trx_status->eht.gi = NL80211_RATE_INFO_EHT_GI_0_8;\n\t\t\tltf = IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_2X;\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\trx_status->eht.gi = NL80211_RATE_INFO_EHT_GI_1_6;\n\t\tltf = IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_2X;\n\t\tbreak;\n\tcase 2:\n\t\tltf = IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_4X;\n\t\tif (he_type == RATE_MCS_HE_TYPE_TRIG)\n\t\t\trx_status->eht.gi = NL80211_RATE_INFO_EHT_GI_3_2;\n\t\telse\n\t\t\trx_status->eht.gi = NL80211_RATE_INFO_EHT_GI_0_8;\n\t\tbreak;\n\tcase 3:\n\t\tif (he_type != RATE_MCS_HE_TYPE_TRIG) {\n\t\t\tltf = IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_4X;\n\t\t\trx_status->eht.gi = NL80211_RATE_INFO_EHT_GI_3_2;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tif (ltf != IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_UNKNOWN) {\n\t\teht->known |= cpu_to_le32(IEEE80211_RADIOTAP_EHT_KNOWN_GI);\n\t\teht->data[0] |= cpu_to_le32\n\t\t\t(FIELD_PREP(IEEE80211_RADIOTAP_EHT_DATA0_LTF,\n\t\t\t\t    ltf) |\n\t\t\t FIELD_PREP(IEEE80211_RADIOTAP_EHT_DATA0_GI,\n\t\t\t\t    rx_status->eht.gi));\n\t}\n\n\n\tif (!phy_data->with_data) {\n\t\teht->known |= cpu_to_le32(IEEE80211_RADIOTAP_EHT_KNOWN_NSS_S |\n\t\t\t\t\t  IEEE80211_RADIOTAP_EHT_KNOWN_BEAMFORMED_S);\n\t\teht->data[7] |=\n\t\t\tle32_encode_bits(le32_get_bits(phy_data->rx_vec[2],\n\t\t\t\t\t\t       RX_NO_DATA_RX_VEC2_EHT_NSTS_MSK),\n\t\t\t\t\t IEEE80211_RADIOTAP_EHT_DATA7_NSS_S);\n\t\tif (rate_n_flags & RATE_MCS_BF_MSK)\n\t\t\teht->data[7] |=\n\t\t\t\tcpu_to_le32(IEEE80211_RADIOTAP_EHT_DATA7_BEAMFORMED_S);\n\t} else {\n\t\teht->user_info[0] |=\n\t\t\tcpu_to_le32(IEEE80211_RADIOTAP_EHT_USER_INFO_MCS_KNOWN |\n\t\t\t\t    IEEE80211_RADIOTAP_EHT_USER_INFO_CODING_KNOWN |\n\t\t\t\t    IEEE80211_RADIOTAP_EHT_USER_INFO_NSS_KNOWN_O |\n\t\t\t\t    IEEE80211_RADIOTAP_EHT_USER_INFO_BEAMFORMING_KNOWN_O |\n\t\t\t\t    IEEE80211_RADIOTAP_EHT_USER_INFO_DATA_FOR_USER);\n\n\t\tif (rate_n_flags & RATE_MCS_BF_MSK)\n\t\t\teht->user_info[0] |=\n\t\t\t\tcpu_to_le32(IEEE80211_RADIOTAP_EHT_USER_INFO_BEAMFORMING_O);\n\n\t\tif (rate_n_flags & RATE_MCS_LDPC_MSK)\n\t\t\teht->user_info[0] |=\n\t\t\t\tcpu_to_le32(IEEE80211_RADIOTAP_EHT_USER_INFO_CODING);\n\n\t\teht->user_info[0] |= cpu_to_le32\n\t\t\t(FIELD_PREP(IEEE80211_RADIOTAP_EHT_USER_INFO_MCS,\n\t\t\t\t    FIELD_GET(RATE_VHT_MCS_RATE_CODE_MSK,\n\t\t\t\t\t      rate_n_flags)) |\n\t\t\t FIELD_PREP(IEEE80211_RADIOTAP_EHT_USER_INFO_NSS_O,\n\t\t\t\t    FIELD_GET(RATE_MCS_NSS_MSK, rate_n_flags)));\n\t}\n}\n\nstatic void iwl_mvm_rx_he(struct iwl_mvm *mvm, struct sk_buff *skb,\n\t\t\t  struct iwl_mvm_rx_phy_data *phy_data,\n\t\t\t  int queue)\n{\n\tstruct ieee80211_rx_status *rx_status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_radiotap_he *he = NULL;\n\tstruct ieee80211_radiotap_he_mu *he_mu = NULL;\n\tu32 rate_n_flags = phy_data->rate_n_flags;\n\tu32 he_type = rate_n_flags & RATE_MCS_HE_TYPE_MSK;\n\tu8 ltf;\n\tstatic const struct ieee80211_radiotap_he known = {\n\t\t.data1 = cpu_to_le16(IEEE80211_RADIOTAP_HE_DATA1_DATA_MCS_KNOWN |\n\t\t\t\t     IEEE80211_RADIOTAP_HE_DATA1_DATA_DCM_KNOWN |\n\t\t\t\t     IEEE80211_RADIOTAP_HE_DATA1_STBC_KNOWN |\n\t\t\t\t     IEEE80211_RADIOTAP_HE_DATA1_CODING_KNOWN),\n\t\t.data2 = cpu_to_le16(IEEE80211_RADIOTAP_HE_DATA2_GI_KNOWN |\n\t\t\t\t     IEEE80211_RADIOTAP_HE_DATA2_TXBF_KNOWN),\n\t};\n\tstatic const struct ieee80211_radiotap_he_mu mu_known = {\n\t\t.flags1 = cpu_to_le16(IEEE80211_RADIOTAP_HE_MU_FLAGS1_SIG_B_MCS_KNOWN |\n\t\t\t\t      IEEE80211_RADIOTAP_HE_MU_FLAGS1_SIG_B_DCM_KNOWN |\n\t\t\t\t      IEEE80211_RADIOTAP_HE_MU_FLAGS1_SIG_B_SYMS_USERS_KNOWN |\n\t\t\t\t      IEEE80211_RADIOTAP_HE_MU_FLAGS1_SIG_B_COMP_KNOWN),\n\t\t.flags2 = cpu_to_le16(IEEE80211_RADIOTAP_HE_MU_FLAGS2_PUNC_FROM_SIG_A_BW_KNOWN |\n\t\t\t\t      IEEE80211_RADIOTAP_HE_MU_FLAGS2_BW_FROM_SIG_A_BW_KNOWN),\n\t};\n\tu16 phy_info = phy_data->phy_info;\n\n\the = skb_put_data(skb, &known, sizeof(known));\n\trx_status->flag |= RX_FLAG_RADIOTAP_HE;\n\n\tif (phy_data->info_type == IWL_RX_PHY_INFO_TYPE_HE_MU ||\n\t    phy_data->info_type == IWL_RX_PHY_INFO_TYPE_HE_MU_EXT) {\n\t\the_mu = skb_put_data(skb, &mu_known, sizeof(mu_known));\n\t\trx_status->flag |= RX_FLAG_RADIOTAP_HE_MU;\n\t}\n\n\t \n\tif (!queue && !(phy_info & IWL_RX_MPDU_PHY_AMPDU)) {\n\t\trx_status->flag |= RX_FLAG_AMPDU_DETAILS;\n\t\trx_status->flag |= RX_FLAG_AMPDU_EOF_BIT_KNOWN;\n\t\tif (phy_data->d0 & cpu_to_le32(IWL_RX_PHY_DATA0_HE_DELIM_EOF))\n\t\t\trx_status->flag |= RX_FLAG_AMPDU_EOF_BIT;\n\t}\n\n\tif (phy_info & IWL_RX_MPDU_PHY_TSF_OVERLOAD)\n\t\tiwl_mvm_decode_he_phy_data(mvm, phy_data, he, he_mu, rx_status,\n\t\t\t\t\t   queue);\n\n\t \n\tif (!queue && (phy_info & IWL_RX_MPDU_PHY_TSF_OVERLOAD) &&\n\t    (phy_info & IWL_RX_MPDU_PHY_AMPDU) && phy_data->first_subframe) {\n\t\trx_status->flag |= RX_FLAG_AMPDU_EOF_BIT_KNOWN;\n\t\tif (phy_data->d0 & cpu_to_le32(IWL_RX_PHY_DATA0_EHT_DELIM_EOF))\n\t\t\trx_status->flag |= RX_FLAG_AMPDU_EOF_BIT;\n\t}\n\n\tif (he_type == RATE_MCS_HE_TYPE_EXT_SU &&\n\t    rate_n_flags & RATE_MCS_HE_106T_MSK) {\n\t\trx_status->bw = RATE_INFO_BW_HE_RU;\n\t\trx_status->he_ru = NL80211_RATE_INFO_HE_RU_ALLOC_106;\n\t}\n\n\t \n\tif (he_type == RATE_MCS_HE_TYPE_SU ||\n\t    he_type == RATE_MCS_HE_TYPE_EXT_SU)\n\t\the->data1 |=\n\t\t\tcpu_to_le16(IEEE80211_RADIOTAP_HE_DATA1_BW_RU_ALLOC_KNOWN);\n\n#define CHECK_TYPE(F)\t\t\t\t\t\t\t\\\n\tBUILD_BUG_ON(IEEE80211_RADIOTAP_HE_DATA1_FORMAT_ ## F !=\t\\\n\t\t     (RATE_MCS_HE_TYPE_ ## F >> RATE_MCS_HE_TYPE_POS))\n\n\tCHECK_TYPE(SU);\n\tCHECK_TYPE(EXT_SU);\n\tCHECK_TYPE(MU);\n\tCHECK_TYPE(TRIG);\n\n\the->data1 |= cpu_to_le16(he_type >> RATE_MCS_HE_TYPE_POS);\n\n\tif (rate_n_flags & RATE_MCS_BF_MSK)\n\t\the->data5 |= cpu_to_le16(IEEE80211_RADIOTAP_HE_DATA5_TXBF);\n\n\tswitch ((rate_n_flags & RATE_MCS_HE_GI_LTF_MSK) >>\n\t\tRATE_MCS_HE_GI_LTF_POS) {\n\tcase 0:\n\t\tif (he_type == RATE_MCS_HE_TYPE_TRIG)\n\t\t\trx_status->he_gi = NL80211_RATE_INFO_HE_GI_1_6;\n\t\telse\n\t\t\trx_status->he_gi = NL80211_RATE_INFO_HE_GI_0_8;\n\t\tif (he_type == RATE_MCS_HE_TYPE_MU)\n\t\t\tltf = IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_4X;\n\t\telse\n\t\t\tltf = IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_1X;\n\t\tbreak;\n\tcase 1:\n\t\tif (he_type == RATE_MCS_HE_TYPE_TRIG)\n\t\t\trx_status->he_gi = NL80211_RATE_INFO_HE_GI_1_6;\n\t\telse\n\t\t\trx_status->he_gi = NL80211_RATE_INFO_HE_GI_0_8;\n\t\tltf = IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_2X;\n\t\tbreak;\n\tcase 2:\n\t\tif (he_type == RATE_MCS_HE_TYPE_TRIG) {\n\t\t\trx_status->he_gi = NL80211_RATE_INFO_HE_GI_3_2;\n\t\t\tltf = IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_4X;\n\t\t} else {\n\t\t\trx_status->he_gi = NL80211_RATE_INFO_HE_GI_1_6;\n\t\t\tltf = IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_2X;\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\trx_status->he_gi = NL80211_RATE_INFO_HE_GI_3_2;\n\t\tltf = IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_4X;\n\t\tbreak;\n\tcase 4:\n\t\trx_status->he_gi = NL80211_RATE_INFO_HE_GI_0_8;\n\t\tltf = IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_4X;\n\t\tbreak;\n\tdefault:\n\t\tltf = IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_UNKNOWN;\n\t}\n\n\the->data5 |= le16_encode_bits(ltf,\n\t\t\t\t      IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE);\n}\n\nstatic void iwl_mvm_decode_lsig(struct sk_buff *skb,\n\t\t\t\tstruct iwl_mvm_rx_phy_data *phy_data)\n{\n\tstruct ieee80211_rx_status *rx_status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_radiotap_lsig *lsig;\n\n\tswitch (phy_data->info_type) {\n\tcase IWL_RX_PHY_INFO_TYPE_HT:\n\tcase IWL_RX_PHY_INFO_TYPE_VHT_SU:\n\tcase IWL_RX_PHY_INFO_TYPE_VHT_MU:\n\tcase IWL_RX_PHY_INFO_TYPE_HE_TB_EXT:\n\tcase IWL_RX_PHY_INFO_TYPE_HE_SU:\n\tcase IWL_RX_PHY_INFO_TYPE_HE_MU:\n\tcase IWL_RX_PHY_INFO_TYPE_HE_MU_EXT:\n\tcase IWL_RX_PHY_INFO_TYPE_HE_TB:\n\tcase IWL_RX_PHY_INFO_TYPE_EHT_MU:\n\tcase IWL_RX_PHY_INFO_TYPE_EHT_TB:\n\tcase IWL_RX_PHY_INFO_TYPE_EHT_MU_EXT:\n\tcase IWL_RX_PHY_INFO_TYPE_EHT_TB_EXT:\n\t\tlsig = skb_put(skb, sizeof(*lsig));\n\t\tlsig->data1 = cpu_to_le16(IEEE80211_RADIOTAP_LSIG_DATA1_LENGTH_KNOWN);\n\t\tlsig->data2 = le16_encode_bits(le32_get_bits(phy_data->d1,\n\t\t\t\t\t\t\t     IWL_RX_PHY_DATA1_LSIG_LEN_MASK),\n\t\t\t\t\t       IEEE80211_RADIOTAP_LSIG_DATA2_LENGTH);\n\t\trx_status->flag |= RX_FLAG_RADIOTAP_LSIG;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic inline u8 iwl_mvm_nl80211_band_from_rx_msdu(u8 phy_band)\n{\n\tswitch (phy_band) {\n\tcase PHY_BAND_24:\n\t\treturn NL80211_BAND_2GHZ;\n\tcase PHY_BAND_5:\n\t\treturn NL80211_BAND_5GHZ;\n\tcase PHY_BAND_6:\n\t\treturn NL80211_BAND_6GHZ;\n\tdefault:\n\t\tWARN_ONCE(1, \"Unsupported phy band (%u)\\n\", phy_band);\n\t\treturn NL80211_BAND_5GHZ;\n\t}\n}\n\nstruct iwl_rx_sta_csa {\n\tbool all_sta_unblocked;\n\tstruct ieee80211_vif *vif;\n};\n\nstatic void iwl_mvm_rx_get_sta_block_tx(void *data, struct ieee80211_sta *sta)\n{\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_rx_sta_csa *rx_sta_csa = data;\n\n\tif (mvmsta->vif != rx_sta_csa->vif)\n\t\treturn;\n\n\tif (mvmsta->disable_tx)\n\t\trx_sta_csa->all_sta_unblocked = false;\n}\n\n \nstatic void iwl_mvm_rx_fill_status(struct iwl_mvm *mvm,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   struct iwl_mvm_rx_phy_data *phy_data,\n\t\t\t\t   int queue)\n{\n\tstruct ieee80211_rx_status *rx_status = IEEE80211_SKB_RXCB(skb);\n\tu32 rate_n_flags = phy_data->rate_n_flags;\n\tu8 stbc = u32_get_bits(rate_n_flags, RATE_MCS_STBC_MSK);\n\tu32 format = rate_n_flags & RATE_MCS_MOD_TYPE_MSK;\n\tbool is_sgi;\n\n\tphy_data->info_type = IWL_RX_PHY_INFO_TYPE_NONE;\n\n\tif (phy_data->phy_info & IWL_RX_MPDU_PHY_TSF_OVERLOAD)\n\t\tphy_data->info_type =\n\t\t\tle32_get_bits(phy_data->d1,\n\t\t\t\t      IWL_RX_PHY_DATA1_INFO_TYPE_MASK);\n\n\t \n\tswitch (rate_n_flags & RATE_MCS_CHAN_WIDTH_MSK) {\n\tcase RATE_MCS_CHAN_WIDTH_20:\n\t\tbreak;\n\tcase RATE_MCS_CHAN_WIDTH_40:\n\t\trx_status->bw = RATE_INFO_BW_40;\n\t\tbreak;\n\tcase RATE_MCS_CHAN_WIDTH_80:\n\t\trx_status->bw = RATE_INFO_BW_80;\n\t\tbreak;\n\tcase RATE_MCS_CHAN_WIDTH_160:\n\t\trx_status->bw = RATE_INFO_BW_160;\n\t\tbreak;\n\tcase RATE_MCS_CHAN_WIDTH_320:\n\t\trx_status->bw = RATE_INFO_BW_320;\n\t\tbreak;\n\t}\n\n\t \n\tif (format == RATE_MCS_HE_MSK)\n\t\tiwl_mvm_rx_he(mvm, skb, phy_data, queue);\n\n\tiwl_mvm_decode_lsig(skb, phy_data);\n\n\trx_status->device_timestamp = phy_data->gp2_on_air_rise;\n\trx_status->freq = ieee80211_channel_to_frequency(phy_data->channel,\n\t\t\t\t\t\t\t rx_status->band);\n\tiwl_mvm_get_signal_strength(mvm, rx_status, rate_n_flags,\n\t\t\t\t    phy_data->energy_a, phy_data->energy_b);\n\n\t \n\tif (format == RATE_MCS_EHT_MSK)\n\t\tiwl_mvm_rx_eht(mvm, skb, phy_data, queue);\n\n\tif (unlikely(mvm->monitor_on))\n\t\tiwl_mvm_add_rtap_sniffer_config(mvm, skb);\n\n\tis_sgi = format == RATE_MCS_HE_MSK ?\n\t\tiwl_he_is_sgi(rate_n_flags) :\n\t\trate_n_flags & RATE_MCS_SGI_MSK;\n\n\tif (!(format == RATE_MCS_CCK_MSK) && is_sgi)\n\t\trx_status->enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\n\tif (rate_n_flags & RATE_MCS_LDPC_MSK)\n\t\trx_status->enc_flags |= RX_ENC_FLAG_LDPC;\n\n\tswitch (format) {\n\tcase RATE_MCS_VHT_MSK:\n\t\trx_status->encoding = RX_ENC_VHT;\n\t\tbreak;\n\tcase RATE_MCS_HE_MSK:\n\t\trx_status->encoding = RX_ENC_HE;\n\t\trx_status->he_dcm =\n\t\t\t!!(rate_n_flags & RATE_HE_DUAL_CARRIER_MODE_MSK);\n\t\tbreak;\n\tcase RATE_MCS_EHT_MSK:\n\t\trx_status->encoding = RX_ENC_EHT;\n\t\tbreak;\n\t}\n\n\tswitch (format) {\n\tcase RATE_MCS_HT_MSK:\n\t\trx_status->encoding = RX_ENC_HT;\n\t\trx_status->rate_idx = RATE_HT_MCS_INDEX(rate_n_flags);\n\t\trx_status->enc_flags |= stbc << RX_ENC_FLAG_STBC_SHIFT;\n\t\tbreak;\n\tcase RATE_MCS_VHT_MSK:\n\tcase RATE_MCS_HE_MSK:\n\tcase RATE_MCS_EHT_MSK:\n\t\trx_status->nss =\n\t\t\tu32_get_bits(rate_n_flags, RATE_MCS_NSS_MSK) + 1;\n\t\trx_status->rate_idx = rate_n_flags & RATE_MCS_CODE_MSK;\n\t\trx_status->enc_flags |= stbc << RX_ENC_FLAG_STBC_SHIFT;\n\t\tbreak;\n\tdefault: {\n\t\tint rate = iwl_mvm_legacy_hw_idx_to_mac80211_idx(rate_n_flags,\n\t\t\t\t\t\t\t\t rx_status->band);\n\n\t\trx_status->rate_idx = rate;\n\n\t\tif ((rate < 0 || rate > 0xFF)) {\n\t\t\trx_status->rate_idx = 0;\n\t\t\tif (net_ratelimit())\n\t\t\t\tIWL_ERR(mvm, \"Invalid rate flags 0x%x, band %d,\\n\",\n\t\t\t\t\trate_n_flags, rx_status->band);\n\t\t}\n\n\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid iwl_mvm_rx_mpdu_mq(struct iwl_mvm *mvm, struct napi_struct *napi,\n\t\t\tstruct iwl_rx_cmd_buffer *rxb, int queue)\n{\n\tstruct ieee80211_rx_status *rx_status;\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_rx_mpdu_desc *desc = (void *)pkt->data;\n\tstruct ieee80211_hdr *hdr;\n\tu32 len;\n\tu32 pkt_len = iwl_rx_packet_payload_len(pkt);\n\tstruct ieee80211_sta *sta = NULL;\n\tstruct ieee80211_link_sta *link_sta = NULL;\n\tstruct sk_buff *skb;\n\tu8 crypt_len = 0;\n\tsize_t desc_size;\n\tstruct iwl_mvm_rx_phy_data phy_data = {};\n\tu32 format;\n\n\tif (unlikely(test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status)))\n\t\treturn;\n\n\tif (mvm->trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_AX210)\n\t\tdesc_size = sizeof(*desc);\n\telse\n\t\tdesc_size = IWL_RX_DESC_SIZE_V1;\n\n\tif (unlikely(pkt_len < desc_size)) {\n\t\tIWL_DEBUG_DROP(mvm, \"Bad REPLY_RX_MPDU_CMD size\\n\");\n\t\treturn;\n\t}\n\n\tif (mvm->trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_AX210) {\n\t\tphy_data.rate_n_flags = le32_to_cpu(desc->v3.rate_n_flags);\n\t\tphy_data.channel = desc->v3.channel;\n\t\tphy_data.gp2_on_air_rise = le32_to_cpu(desc->v3.gp2_on_air_rise);\n\t\tphy_data.energy_a = desc->v3.energy_a;\n\t\tphy_data.energy_b = desc->v3.energy_b;\n\n\t\tphy_data.d0 = desc->v3.phy_data0;\n\t\tphy_data.d1 = desc->v3.phy_data1;\n\t\tphy_data.d2 = desc->v3.phy_data2;\n\t\tphy_data.d3 = desc->v3.phy_data3;\n\t\tphy_data.eht_d4 = desc->phy_eht_data4;\n\t\tphy_data.d5 = desc->v3.phy_data5;\n\t} else {\n\t\tphy_data.rate_n_flags = le32_to_cpu(desc->v1.rate_n_flags);\n\t\tphy_data.channel = desc->v1.channel;\n\t\tphy_data.gp2_on_air_rise = le32_to_cpu(desc->v1.gp2_on_air_rise);\n\t\tphy_data.energy_a = desc->v1.energy_a;\n\t\tphy_data.energy_b = desc->v1.energy_b;\n\n\t\tphy_data.d0 = desc->v1.phy_data0;\n\t\tphy_data.d1 = desc->v1.phy_data1;\n\t\tphy_data.d2 = desc->v1.phy_data2;\n\t\tphy_data.d3 = desc->v1.phy_data3;\n\t}\n\n\tif (iwl_fw_lookup_notif_ver(mvm->fw, LEGACY_GROUP,\n\t\t\t\t    REPLY_RX_MPDU_CMD, 0) < 4) {\n\t\tphy_data.rate_n_flags = iwl_new_rate_from_v1(phy_data.rate_n_flags);\n\t\tIWL_DEBUG_DROP(mvm, \"Got old format rate, converting. New rate: 0x%x\\n\",\n\t\t\t       phy_data.rate_n_flags);\n\t}\n\n\tformat = phy_data.rate_n_flags & RATE_MCS_MOD_TYPE_MSK;\n\n\tlen = le16_to_cpu(desc->mpdu_len);\n\n\tif (unlikely(len + desc_size > pkt_len)) {\n\t\tIWL_DEBUG_DROP(mvm, \"FW lied about packet len\\n\");\n\t\treturn;\n\t}\n\n\tphy_data.with_data = true;\n\tphy_data.phy_info = le16_to_cpu(desc->phy_info);\n\tphy_data.d4 = desc->phy_data4;\n\n\thdr = (void *)(pkt->data + desc_size);\n\t \n\tskb = alloc_skb(128, GFP_ATOMIC);\n\tif (!skb) {\n\t\tIWL_ERR(mvm, \"alloc_skb failed\\n\");\n\t\treturn;\n\t}\n\n\tif (desc->mac_flags2 & IWL_RX_MPDU_MFLG2_PAD) {\n\t\t \n\t\tskb_reserve(skb, 2);\n\t}\n\n\trx_status = IEEE80211_SKB_RXCB(skb);\n\n\t \n\tif (!(desc->status & cpu_to_le32(IWL_RX_MPDU_STATUS_CRC_OK)) ||\n\t    !(desc->status & cpu_to_le32(IWL_RX_MPDU_STATUS_OVERRUN_OK))) {\n\t\tIWL_DEBUG_RX(mvm, \"Bad CRC or FIFO: 0x%08X.\\n\",\n\t\t\t     le32_to_cpu(desc->status));\n\t\trx_status->flag |= RX_FLAG_FAILED_FCS_CRC;\n\t}\n\n\t \n\tif (format == RATE_MCS_CCK_MSK &&\n\t    phy_data.phy_info & IWL_RX_MPDU_PHY_SHORT_PREAMBLE)\n\t\trx_status->enc_flags |= RX_ENC_FLAG_SHORTPRE;\n\n\tif (likely(!(phy_data.phy_info & IWL_RX_MPDU_PHY_TSF_OVERLOAD))) {\n\t\tu64 tsf_on_air_rise;\n\n\t\tif (mvm->trans->trans_cfg->device_family >=\n\t\t    IWL_DEVICE_FAMILY_AX210)\n\t\t\ttsf_on_air_rise = le64_to_cpu(desc->v3.tsf_on_air_rise);\n\t\telse\n\t\t\ttsf_on_air_rise = le64_to_cpu(desc->v1.tsf_on_air_rise);\n\n\t\trx_status->mactime = tsf_on_air_rise;\n\t\t \n\t\trx_status->flag |= RX_FLAG_MACTIME_PLCP_START;\n\t}\n\n\tif (iwl_mvm_is_band_in_rx_supported(mvm)) {\n\t\tu8 band = BAND_IN_RX_STATUS(desc->mac_phy_idx);\n\n\t\trx_status->band = iwl_mvm_nl80211_band_from_rx_msdu(band);\n\t} else {\n\t\trx_status->band = phy_data.channel > 14 ? NL80211_BAND_5GHZ :\n\t\t\tNL80211_BAND_2GHZ;\n\t}\n\n\t \n\tif (!queue && (phy_data.phy_info & IWL_RX_MPDU_PHY_AMPDU)) {\n\t\tbool toggle_bit;\n\n\t\ttoggle_bit = phy_data.phy_info & IWL_RX_MPDU_PHY_AMPDU_TOGGLE;\n\t\trx_status->flag |= RX_FLAG_AMPDU_DETAILS;\n\t\t \n\t\tif (toggle_bit != mvm->ampdu_toggle) {\n\t\t\tmvm->ampdu_ref++;\n\t\t\tif (mvm->ampdu_ref == 0)\n\t\t\t\tmvm->ampdu_ref++;\n\t\t\tmvm->ampdu_toggle = toggle_bit;\n\t\t\tphy_data.first_subframe = true;\n\t\t}\n\t\trx_status->ampdu_reference = mvm->ampdu_ref;\n\t}\n\n\trcu_read_lock();\n\n\tif (desc->status & cpu_to_le32(IWL_RX_MPDU_STATUS_SRC_STA_FOUND)) {\n\t\tu8 id = le32_get_bits(desc->status, IWL_RX_MPDU_STATUS_STA_ID);\n\n\t\tif (!WARN_ON_ONCE(id >= mvm->fw->ucode_capa.num_stations)) {\n\t\t\tsta = rcu_dereference(mvm->fw_id_to_mac_id[id]);\n\t\t\tif (IS_ERR(sta))\n\t\t\t\tsta = NULL;\n\t\t\tlink_sta = rcu_dereference(mvm->fw_id_to_link_sta[id]);\n\t\t}\n\t} else if (!is_multicast_ether_addr(hdr->addr2)) {\n\t\t \n\t\tsta = ieee80211_find_sta_by_ifaddr(mvm->hw, hdr->addr2, NULL);\n\t}\n\n\tif (iwl_mvm_rx_crypto(mvm, sta, hdr, rx_status, phy_data.phy_info, desc,\n\t\t\t      le32_to_cpu(pkt->len_n_flags), queue,\n\t\t\t      &crypt_len)) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tiwl_mvm_rx_fill_status(mvm, skb, &phy_data, queue);\n\n\tif (sta) {\n\t\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\t\tstruct ieee80211_vif *tx_blocked_vif =\n\t\t\trcu_dereference(mvm->csa_tx_blocked_vif);\n\t\tu8 baid = (u8)((le32_to_cpu(desc->reorder_data) &\n\t\t\t       IWL_RX_MPDU_REORDER_BAID_MASK) >>\n\t\t\t       IWL_RX_MPDU_REORDER_BAID_SHIFT);\n\t\tstruct iwl_fw_dbg_trigger_tlv *trig;\n\t\tstruct ieee80211_vif *vif = mvmsta->vif;\n\n\t\tif (!mvm->tcm.paused && len >= sizeof(*hdr) &&\n\t\t    !is_multicast_ether_addr(hdr->addr1) &&\n\t\t    ieee80211_is_data(hdr->frame_control) &&\n\t\t    time_after(jiffies, mvm->tcm.ts + MVM_TCM_PERIOD))\n\t\t\tschedule_delayed_work(&mvm->tcm.work, 0);\n\n\t\t \n\t\tif (unlikely(tx_blocked_vif) && tx_blocked_vif == vif) {\n\t\t\tstruct iwl_mvm_vif *mvmvif =\n\t\t\t\tiwl_mvm_vif_from_mac80211(tx_blocked_vif);\n\t\t\tstruct iwl_rx_sta_csa rx_sta_csa = {\n\t\t\t\t.all_sta_unblocked = true,\n\t\t\t\t.vif = tx_blocked_vif,\n\t\t\t};\n\n\t\t\tif (mvmvif->csa_target_freq == rx_status->freq)\n\t\t\t\tiwl_mvm_sta_modify_disable_tx_ap(mvm, sta,\n\t\t\t\t\t\t\t\t false);\n\t\t\tieee80211_iterate_stations_atomic(mvm->hw,\n\t\t\t\t\t\t\t  iwl_mvm_rx_get_sta_block_tx,\n\t\t\t\t\t\t\t  &rx_sta_csa);\n\n\t\t\tif (rx_sta_csa.all_sta_unblocked) {\n\t\t\t\tRCU_INIT_POINTER(mvm->csa_tx_blocked_vif, NULL);\n\t\t\t\t \n\t\t\t\tiwl_mvm_modify_all_sta_disable_tx(mvm, mvmvif, false);\n\t\t\t\tcancel_delayed_work(&mvm->cs_tx_unblock_dwork);\n\t\t\t}\n\t\t}\n\n\t\trs_update_last_rssi(mvm, mvmsta, rx_status);\n\n\t\ttrig = iwl_fw_dbg_trigger_on(&mvm->fwrt,\n\t\t\t\t\t     ieee80211_vif_to_wdev(vif),\n\t\t\t\t\t     FW_DBG_TRIGGER_RSSI);\n\n\t\tif (trig && ieee80211_is_beacon(hdr->frame_control)) {\n\t\t\tstruct iwl_fw_dbg_trigger_low_rssi *rssi_trig;\n\t\t\ts32 rssi;\n\n\t\t\trssi_trig = (void *)trig->data;\n\t\t\trssi = le32_to_cpu(rssi_trig->rssi);\n\n\t\t\tif (rx_status->signal < rssi)\n\t\t\t\tiwl_fw_dbg_collect_trig(&mvm->fwrt, trig,\n\t\t\t\t\t\t\tNULL);\n\t\t}\n\n\t\tif (ieee80211_is_data(hdr->frame_control))\n\t\t\tiwl_mvm_rx_csum(mvm, sta, skb, pkt);\n\n\t\tif (iwl_mvm_is_dup(sta, queue, rx_status, hdr, desc)) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif ((desc->mac_flags2 & IWL_RX_MPDU_MFLG2_AMSDU) &&\n\t\t    !WARN_ON(!ieee80211_is_data_qos(hdr->frame_control))) {\n\t\t\tu8 *qc = ieee80211_get_qos_ctl(hdr);\n\n\t\t\t*qc &= ~IEEE80211_QOS_CTL_A_MSDU_PRESENT;\n\n\t\t\tif (mvm->trans->trans_cfg->device_family ==\n\t\t\t    IWL_DEVICE_FAMILY_9000) {\n\t\t\t\tiwl_mvm_flip_address(hdr->addr3);\n\n\t\t\t\tif (ieee80211_has_a4(hdr->frame_control))\n\t\t\t\t\tiwl_mvm_flip_address(hdr->addr4);\n\t\t\t}\n\t\t}\n\t\tif (baid != IWL_RX_REORDER_DATA_INVALID_BAID) {\n\t\t\tu32 reorder_data = le32_to_cpu(desc->reorder_data);\n\n\t\t\tiwl_mvm_agg_rx_received(mvm, reorder_data, baid);\n\t\t}\n\t}\n\n\t \n\tif (!queue) {\n\t\tif (unlikely((ieee80211_is_beacon(hdr->frame_control) ||\n\t\t\t      ieee80211_is_probe_resp(hdr->frame_control)) &&\n\t\t\t     mvm->sched_scan_pass_all ==\n\t\t\t     SCHED_SCAN_PASS_ALL_ENABLED))\n\t\t\tmvm->sched_scan_pass_all = SCHED_SCAN_PASS_ALL_FOUND;\n\n\t\tif (unlikely(ieee80211_is_beacon(hdr->frame_control) ||\n\t\t\t     ieee80211_is_probe_resp(hdr->frame_control)))\n\t\t\trx_status->boottime_ns = ktime_get_boottime_ns();\n\t}\n\n\tif (iwl_mvm_create_skb(mvm, skb, hdr, len, crypt_len, rxb)) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tif (!iwl_mvm_reorder(mvm, napi, queue, sta, skb, desc) &&\n\t    likely(!iwl_mvm_time_sync_frame(mvm, skb, hdr->addr2)) &&\n\t    likely(!iwl_mvm_mei_filter_scan(mvm, skb)))\n\t\tiwl_mvm_pass_packet_to_mac80211(mvm, napi, skb, queue, sta,\n\t\t\t\t\t\tlink_sta);\nout:\n\trcu_read_unlock();\n}\n\nvoid iwl_mvm_rx_monitor_no_data(struct iwl_mvm *mvm, struct napi_struct *napi,\n\t\t\t\tstruct iwl_rx_cmd_buffer *rxb, int queue)\n{\n\tstruct ieee80211_rx_status *rx_status;\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_rx_no_data_ver_3 *desc = (void *)pkt->data;\n\tu32 rssi;\n\tu32 info_type;\n\tstruct ieee80211_sta *sta = NULL;\n\tstruct sk_buff *skb;\n\tstruct iwl_mvm_rx_phy_data phy_data;\n\tu32 format;\n\n\tif (unlikely(test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status)))\n\t\treturn;\n\n\tif (unlikely(iwl_rx_packet_payload_len(pkt) < sizeof(struct iwl_rx_no_data)))\n\t\treturn;\n\n\trssi = le32_to_cpu(desc->rssi);\n\tinfo_type = le32_to_cpu(desc->info) & RX_NO_DATA_INFO_TYPE_MSK;\n\tphy_data.d0 = desc->phy_info[0];\n\tphy_data.d1 = desc->phy_info[1];\n\tphy_data.phy_info = IWL_RX_MPDU_PHY_TSF_OVERLOAD;\n\tphy_data.gp2_on_air_rise = le32_to_cpu(desc->on_air_rise_time);\n\tphy_data.rate_n_flags = le32_to_cpu(desc->rate);\n\tphy_data.energy_a = u32_get_bits(rssi, RX_NO_DATA_CHAIN_A_MSK);\n\tphy_data.energy_b = u32_get_bits(rssi, RX_NO_DATA_CHAIN_B_MSK);\n\tphy_data.channel = u32_get_bits(rssi, RX_NO_DATA_CHANNEL_MSK);\n\tphy_data.with_data = false;\n\tphy_data.rx_vec[0] = desc->rx_vec[0];\n\tphy_data.rx_vec[1] = desc->rx_vec[1];\n\n\tif (iwl_fw_lookup_notif_ver(mvm->fw, DATA_PATH_GROUP,\n\t\t\t\t    RX_NO_DATA_NOTIF, 0) < 2) {\n\t\tIWL_DEBUG_DROP(mvm, \"Got an old rate format. Old rate: 0x%x\\n\",\n\t\t\t       phy_data.rate_n_flags);\n\t\tphy_data.rate_n_flags = iwl_new_rate_from_v1(phy_data.rate_n_flags);\n\t\tIWL_DEBUG_DROP(mvm, \" Rate after conversion to the new format: 0x%x\\n\",\n\t\t\t       phy_data.rate_n_flags);\n\t}\n\n\tformat = phy_data.rate_n_flags & RATE_MCS_MOD_TYPE_MSK;\n\n\tif (iwl_fw_lookup_notif_ver(mvm->fw, DATA_PATH_GROUP,\n\t\t\t\t    RX_NO_DATA_NOTIF, 0) >= 3) {\n\t\tif (unlikely(iwl_rx_packet_payload_len(pkt) <\n\t\t    sizeof(struct iwl_rx_no_data_ver_3)))\n\t\t \n\t\t\treturn;\n\t\tphy_data.rx_vec[2] = desc->rx_vec[2];\n\t\tphy_data.rx_vec[3] = desc->rx_vec[3];\n\t} else {\n\t\tif (format == RATE_MCS_EHT_MSK)\n\t\t\t \n\t\t\treturn;\n\t}\n\n\t \n\tskb = alloc_skb(128, GFP_ATOMIC);\n\tif (!skb) {\n\t\tIWL_ERR(mvm, \"alloc_skb failed\\n\");\n\t\treturn;\n\t}\n\n\trx_status = IEEE80211_SKB_RXCB(skb);\n\n\t \n\trx_status->flag |= RX_FLAG_NO_PSDU;\n\n\tswitch (info_type) {\n\tcase RX_NO_DATA_INFO_TYPE_NDP:\n\t\trx_status->zero_length_psdu_type =\n\t\t\tIEEE80211_RADIOTAP_ZERO_LEN_PSDU_SOUNDING;\n\t\tbreak;\n\tcase RX_NO_DATA_INFO_TYPE_MU_UNMATCHED:\n\tcase RX_NO_DATA_INFO_TYPE_TB_UNMATCHED:\n\t\trx_status->zero_length_psdu_type =\n\t\t\tIEEE80211_RADIOTAP_ZERO_LEN_PSDU_NOT_CAPTURED;\n\t\tbreak;\n\tdefault:\n\t\trx_status->zero_length_psdu_type =\n\t\t\tIEEE80211_RADIOTAP_ZERO_LEN_PSDU_VENDOR;\n\t\tbreak;\n\t}\n\n\trx_status->band = phy_data.channel > 14 ? NL80211_BAND_5GHZ :\n\t\tNL80211_BAND_2GHZ;\n\n\tiwl_mvm_rx_fill_status(mvm, skb, &phy_data, queue);\n\n\t \n\tskb_reset_mac_header(skb);\n\n\t \n\tswitch (format) {\n\tcase RATE_MCS_VHT_MSK:\n\t\trx_status->nss =\n\t\t\tle32_get_bits(desc->rx_vec[0],\n\t\t\t\t      RX_NO_DATA_RX_VEC0_VHT_NSTS_MSK) + 1;\n\t\tbreak;\n\tcase RATE_MCS_HE_MSK:\n\t\trx_status->nss =\n\t\t\tle32_get_bits(desc->rx_vec[0],\n\t\t\t\t      RX_NO_DATA_RX_VEC0_HE_NSTS_MSK) + 1;\n\t\tbreak;\n\tcase RATE_MCS_EHT_MSK:\n\t\trx_status->nss =\n\t\t\tle32_get_bits(desc->rx_vec[2],\n\t\t\t\t      RX_NO_DATA_RX_VEC2_EHT_NSTS_MSK) + 1;\n\t}\n\n\trcu_read_lock();\n\tieee80211_rx_napi(mvm->hw, sta, skb, napi);\n\trcu_read_unlock();\n}\n\nvoid iwl_mvm_rx_frame_release(struct iwl_mvm *mvm, struct napi_struct *napi,\n\t\t\t      struct iwl_rx_cmd_buffer *rxb, int queue)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_frame_release *release = (void *)pkt->data;\n\n\tif (unlikely(iwl_rx_packet_payload_len(pkt) < sizeof(*release)))\n\t\treturn;\n\n\tiwl_mvm_release_frames_from_notif(mvm, napi, release->baid,\n\t\t\t\t\t  le16_to_cpu(release->nssn),\n\t\t\t\t\t  queue, 0);\n}\n\nvoid iwl_mvm_rx_bar_frame_release(struct iwl_mvm *mvm, struct napi_struct *napi,\n\t\t\t\t  struct iwl_rx_cmd_buffer *rxb, int queue)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_bar_frame_release *release = (void *)pkt->data;\n\tunsigned int baid = le32_get_bits(release->ba_info,\n\t\t\t\t\t  IWL_BAR_FRAME_RELEASE_BAID_MASK);\n\tunsigned int nssn = le32_get_bits(release->ba_info,\n\t\t\t\t\t  IWL_BAR_FRAME_RELEASE_NSSN_MASK);\n\tunsigned int sta_id = le32_get_bits(release->sta_tid,\n\t\t\t\t\t    IWL_BAR_FRAME_RELEASE_STA_MASK);\n\tunsigned int tid = le32_get_bits(release->sta_tid,\n\t\t\t\t\t IWL_BAR_FRAME_RELEASE_TID_MASK);\n\tstruct iwl_mvm_baid_data *baid_data;\n\n\tif (unlikely(iwl_rx_packet_payload_len(pkt) < sizeof(*release)))\n\t\treturn;\n\n\tif (WARN_ON_ONCE(baid == IWL_RX_REORDER_DATA_INVALID_BAID ||\n\t\t\t baid >= ARRAY_SIZE(mvm->baid_map)))\n\t\treturn;\n\n\trcu_read_lock();\n\tbaid_data = rcu_dereference(mvm->baid_map[baid]);\n\tif (!baid_data) {\n\t\tIWL_DEBUG_RX(mvm,\n\t\t\t     \"Got valid BAID %d but not allocated, invalid BAR release!\\n\",\n\t\t\t      baid);\n\t\tgoto out;\n\t}\n\n\tif (WARN(tid != baid_data->tid || sta_id > IWL_MVM_STATION_COUNT_MAX ||\n\t\t !(baid_data->sta_mask & BIT(sta_id)),\n\t\t \"baid 0x%x is mapped to sta_mask:0x%x tid:%d, but BAR release received for sta:%d tid:%d\\n\",\n\t\t baid, baid_data->sta_mask, baid_data->tid, sta_id,\n\t\t tid))\n\t\tgoto out;\n\n\tiwl_mvm_release_frames_from_notif(mvm, napi, baid, nssn, queue, 0);\nout:\n\trcu_read_unlock();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}