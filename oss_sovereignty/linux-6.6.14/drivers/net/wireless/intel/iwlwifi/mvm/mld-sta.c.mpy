{
  "module_name": "mld-sta.c",
  "hash_id": "faa05f95811777e5fa59ec488d8b0b545fb68e5167d5854c1eb7f34da733d1b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/mld-sta.c",
  "human_readable_source": "\n \n#include \"mvm.h\"\n#include \"time-sync.h\"\n#include \"sta.h\"\n\nu32 iwl_mvm_sta_fw_id_mask(struct iwl_mvm *mvm, struct ieee80211_sta *sta,\n\t\t\t   int filter_link_id)\n{\n\tstruct iwl_mvm_sta *mvmsta;\n\tunsigned int link_id;\n\tu32 result = 0;\n\n\tif (!sta)\n\t\treturn 0;\n\n\tmvmsta = iwl_mvm_sta_from_mac80211(sta);\n\n\t \n\tif (!sta->valid_links)\n\t\treturn BIT(mvmsta->deflink.sta_id);\n\n\t \n\tfor (link_id = 0; link_id < ARRAY_SIZE(mvmsta->link); link_id++) {\n\t\tstruct iwl_mvm_link_sta *link_sta;\n\n\t\t \n\t\tif (filter_link_id >= 0 && link_id != filter_link_id)\n\t\t\tcontinue;\n\n\t\tlink_sta =\n\t\t\trcu_dereference_check(mvmsta->link[link_id],\n\t\t\t\t\t      lockdep_is_held(&mvm->mutex));\n\t\tif (!link_sta)\n\t\t\tcontinue;\n\n\t\tresult |= BIT(link_sta->sta_id);\n\t}\n\n\treturn result;\n}\n\nstatic int iwl_mvm_mld_send_sta_cmd(struct iwl_mvm *mvm,\n\t\t\t\t    struct iwl_mvm_sta_cfg_cmd *cmd)\n{\n\tint ret = iwl_mvm_send_cmd_pdu(mvm,\n\t\t\t\t       WIDE_ID(MAC_CONF_GROUP, STA_CONFIG_CMD),\n\t\t\t\t       0, sizeof(*cmd), cmd);\n\tif (ret)\n\t\tIWL_ERR(mvm, \"STA_CONFIG_CMD send failed, ret=0x%x\\n\", ret);\n\treturn ret;\n}\n\n \nstatic int iwl_mvm_mld_add_int_sta_to_fw(struct iwl_mvm *mvm,\n\t\t\t\t\t struct iwl_mvm_int_sta *sta,\n\t\t\t\t\t const u8 *addr, int link_id)\n{\n\tstruct iwl_mvm_sta_cfg_cmd cmd;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.sta_id = cpu_to_le32((u8)sta->sta_id);\n\n\tcmd.link_id = cpu_to_le32(link_id);\n\n\tcmd.station_type = cpu_to_le32(sta->type);\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_STA_EXP_MFP_SUPPORT) &&\n\t    sta->type == STATION_TYPE_BCAST_MGMT)\n\t\tcmd.mfp = cpu_to_le32(1);\n\n\tif (addr) {\n\t\tmemcpy(cmd.peer_mld_address, addr, ETH_ALEN);\n\t\tmemcpy(cmd.peer_link_address, addr, ETH_ALEN);\n\t}\n\n\treturn iwl_mvm_mld_send_sta_cmd(mvm, &cmd);\n}\n\n \nstatic int iwl_mvm_mld_rm_sta_from_fw(struct iwl_mvm *mvm, u32 sta_id)\n{\n\tstruct iwl_mvm_remove_sta_cmd rm_sta_cmd = {\n\t\t.sta_id = cpu_to_le32(sta_id),\n\t};\n\tint ret;\n\n\t \n\tif (!rcu_access_pointer(mvm->fw_id_to_mac_id[sta_id])) {\n\t\tIWL_ERR(mvm, \"Invalid station id %d\\n\", sta_id);\n\t\treturn -EINVAL;\n\t}\n\n\tret = iwl_mvm_send_cmd_pdu(mvm, WIDE_ID(MAC_CONF_GROUP, STA_REMOVE_CMD),\n\t\t\t\t   0, sizeof(rm_sta_cmd), &rm_sta_cmd);\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"Failed to remove station. Id=%d\\n\", sta_id);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int iwl_mvm_add_aux_sta_to_fw(struct iwl_mvm *mvm,\n\t\t\t\t     struct iwl_mvm_int_sta *sta,\n\t\t\t\t     u32 lmac_id)\n{\n\tint ret;\n\n\tstruct iwl_mvm_aux_sta_cmd cmd = {\n\t\t.sta_id = cpu_to_le32(sta->sta_id),\n\t\t.lmac_id = cpu_to_le32(lmac_id),\n\t};\n\n\tret = iwl_mvm_send_cmd_pdu(mvm, WIDE_ID(MAC_CONF_GROUP, AUX_STA_CMD),\n\t\t\t\t   0, sizeof(cmd), &cmd);\n\tif (ret)\n\t\tIWL_ERR(mvm, \"Failed to send AUX_STA_CMD\\n\");\n\treturn ret;\n}\n\n \nint iwl_mvm_mld_add_int_sta_with_queue(struct iwl_mvm *mvm,\n\t\t\t\t       struct iwl_mvm_int_sta *sta,\n\t\t\t\t       const u8 *addr, int link_id,\n\t\t\t\t       u16 *queue, u8 tid,\n\t\t\t\t       unsigned int *_wdg_timeout)\n{\n\tint ret, txq;\n\tunsigned int wdg_timeout = _wdg_timeout ? *_wdg_timeout :\n\t\tmvm->trans->trans_cfg->base_params->wd_timeout;\n\n\tif (WARN_ON_ONCE(sta->sta_id == IWL_MVM_INVALID_STA))\n\t\treturn -ENOSPC;\n\n\tif (sta->type == STATION_TYPE_AUX)\n\t\tret = iwl_mvm_add_aux_sta_to_fw(mvm, sta, link_id);\n\telse\n\t\tret = iwl_mvm_mld_add_int_sta_to_fw(mvm, sta, addr, link_id);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttxq = iwl_mvm_tvqm_enable_txq(mvm, NULL, sta->sta_id, tid,\n\t\t\t\t      wdg_timeout);\n\tif (txq < 0) {\n\t\tiwl_mvm_mld_rm_sta_from_fw(mvm, sta->sta_id);\n\t\treturn txq;\n\t}\n\t*queue = txq;\n\n\treturn 0;\n}\n\n \nstatic int iwl_mvm_mld_add_int_sta(struct iwl_mvm *mvm,\n\t\t\t\t   struct iwl_mvm_int_sta *int_sta, u16 *queue,\n\t\t\t\t   enum nl80211_iftype iftype,\n\t\t\t\t   enum iwl_fw_sta_type sta_type,\n\t\t\t\t   int link_id, const u8 *addr, u8 tid,\n\t\t\t\t   unsigned int *wdg_timeout)\n{\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\t \n\tret = iwl_mvm_allocate_int_sta(mvm, int_sta, 0, iftype,\n\t\t\t\t       sta_type);\n\tif (ret)\n\t\treturn ret;\n\n\tret = iwl_mvm_mld_add_int_sta_with_queue(mvm, int_sta, addr, link_id,\n\t\t\t\t\t\t queue, tid, wdg_timeout);\n\tif (ret) {\n\t\tiwl_mvm_dealloc_int_sta(mvm, int_sta);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nint iwl_mvm_mld_add_bcast_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_bss_conf *link_conf)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_vif_link_info *mvm_link =\n\t\tmvmvif->link[link_conf->link_id];\n\tstruct iwl_mvm_int_sta *bsta = &mvm_link->bcast_sta;\n\tstatic const u8 _baddr[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};\n\tconst u8 *baddr = _baddr;\n\tunsigned int wdg_timeout =\n\t\tiwl_mvm_get_wd_timeout(mvm, vif, false, false);\n\tu16 *queue;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (vif->type == NL80211_IFTYPE_ADHOC)\n\t\tbaddr = link_conf->bssid;\n\n\tif (vif->type == NL80211_IFTYPE_AP ||\n\t    vif->type == NL80211_IFTYPE_ADHOC) {\n\t\tqueue = &mvm_link->mgmt_queue;\n\t} else if (vif->type == NL80211_IFTYPE_P2P_DEVICE) {\n\t\tqueue = &mvm->p2p_dev_queue;\n\t} else {\n\t\tWARN(1, \"Missing required TXQ for adding bcast STA\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn iwl_mvm_mld_add_int_sta(mvm, bsta, queue,\n\t\t\t\t       ieee80211_vif_type_p2p(vif),\n\t\t\t\t       STATION_TYPE_BCAST_MGMT,\n\t\t\t\t       mvm_link->fw_link_id, baddr,\n\t\t\t\t       IWL_MAX_TID_COUNT, &wdg_timeout);\n}\n\n \nint iwl_mvm_mld_add_mcast_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_bss_conf *link_conf)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_vif_link_info *mvm_link =\n\t\tmvmvif->link[link_conf->link_id];\n\tstruct iwl_mvm_int_sta *msta = &mvm_link->mcast_sta;\n\tstatic const u8 _maddr[] = {0x03, 0x00, 0x00, 0x00, 0x00, 0x00};\n\tconst u8 *maddr = _maddr;\n\tunsigned int timeout = iwl_mvm_get_wd_timeout(mvm, vif, false, false);\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (WARN_ON(vif->type != NL80211_IFTYPE_AP &&\n\t\t    vif->type != NL80211_IFTYPE_ADHOC))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (vif->type == NL80211_IFTYPE_ADHOC)\n\t\tmvm_link->cab_queue = IWL_MVM_DQA_GCAST_QUEUE;\n\n\treturn iwl_mvm_mld_add_int_sta(mvm, msta, &mvm_link->cab_queue,\n\t\t\t\t       vif->type, STATION_TYPE_MCAST,\n\t\t\t\t       mvm_link->fw_link_id, maddr, 0,\n\t\t\t\t       &timeout);\n}\n\n \nint iwl_mvm_mld_add_snif_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_bss_conf *link_conf)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_vif_link_info *mvm_link =\n\t\tmvmvif->link[link_conf->link_id];\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\treturn iwl_mvm_mld_add_int_sta(mvm, &mvm->snif_sta, &mvm->snif_queue,\n\t\t\t\t       vif->type, STATION_TYPE_BCAST_MGMT,\n\t\t\t\t       mvm_link->fw_link_id, NULL,\n\t\t\t\t       IWL_MAX_TID_COUNT, NULL);\n}\n\nint iwl_mvm_mld_add_aux_sta(struct iwl_mvm *mvm, u32 lmac_id)\n{\n\tlockdep_assert_held(&mvm->mutex);\n\n\t \n\treturn iwl_mvm_mld_add_int_sta(mvm, &mvm->aux_sta, &mvm->aux_queue,\n\t\t\t\t       NL80211_IFTYPE_UNSPECIFIED,\n\t\t\t\t       STATION_TYPE_AUX, lmac_id, NULL,\n\t\t\t\t       IWL_MAX_TID_COUNT, NULL);\n}\n\nstatic int iwl_mvm_mld_disable_txq(struct iwl_mvm *mvm, u32 sta_mask,\n\t\t\t\t   u16 *queueptr, u8 tid)\n{\n\tint queue = *queueptr;\n\tint ret = 0;\n\n\tif (tid == IWL_MAX_TID_COUNT)\n\t\ttid = IWL_MGMT_TID;\n\n\tif (mvm->sta_remove_requires_queue_remove) {\n\t\tu32 cmd_id = WIDE_ID(DATA_PATH_GROUP,\n\t\t\t\t     SCD_QUEUE_CONFIG_CMD);\n\t\tstruct iwl_scd_queue_cfg_cmd remove_cmd = {\n\t\t\t.operation = cpu_to_le32(IWL_SCD_QUEUE_REMOVE),\n\t\t\t.u.remove.tid = cpu_to_le32(tid),\n\t\t\t.u.remove.sta_mask = cpu_to_le32(sta_mask),\n\t\t};\n\n\t\tret = iwl_mvm_send_cmd_pdu(mvm, cmd_id, 0,\n\t\t\t\t\t   sizeof(remove_cmd),\n\t\t\t\t\t   &remove_cmd);\n\t}\n\n\tiwl_trans_txq_free(mvm->trans, queue);\n\t*queueptr = IWL_MVM_INVALID_QUEUE;\n\n\treturn ret;\n}\n\n \nstatic int iwl_mvm_mld_rm_int_sta(struct iwl_mvm *mvm,\n\t\t\t\t  struct iwl_mvm_int_sta *int_sta,\n\t\t\t\t  bool flush, u8 tid, u16 *queuptr)\n{\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (WARN_ON_ONCE(int_sta->sta_id == IWL_MVM_INVALID_STA))\n\t\treturn -EINVAL;\n\n\tif (flush)\n\t\tiwl_mvm_flush_sta(mvm, int_sta->sta_id, int_sta->tfd_queue_msk);\n\n\tiwl_mvm_mld_disable_txq(mvm, BIT(int_sta->sta_id), queuptr, tid);\n\n\tret = iwl_mvm_mld_rm_sta_from_fw(mvm, int_sta->sta_id);\n\tif (ret)\n\t\tIWL_WARN(mvm, \"Failed sending remove station\\n\");\n\n\tiwl_mvm_dealloc_int_sta(mvm, int_sta);\n\n\treturn ret;\n}\n\nint iwl_mvm_mld_rm_bcast_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_bss_conf *link_conf)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_vif_link_info *link = mvmvif->link[link_conf->link_id];\n\tu16 *queueptr;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (WARN_ON(!link))\n\t\treturn -EIO;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tqueueptr = &link->mgmt_queue;\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tqueueptr = &mvm->p2p_dev_queue;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Can't free bcast queue on vif type %d\\n\",\n\t\t     vif->type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn iwl_mvm_mld_rm_int_sta(mvm, &link->bcast_sta,\n\t\t\t\t      true, IWL_MAX_TID_COUNT, queueptr);\n}\n\n \nint iwl_mvm_mld_rm_mcast_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_bss_conf *link_conf)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_vif_link_info *link = mvmvif->link[link_conf->link_id];\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (WARN_ON(!link))\n\t\treturn -EIO;\n\n\treturn iwl_mvm_mld_rm_int_sta(mvm, &link->mcast_sta, true, 0,\n\t\t\t\t      &link->cab_queue);\n}\n\nint iwl_mvm_mld_rm_snif_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tlockdep_assert_held(&mvm->mutex);\n\n\treturn iwl_mvm_mld_rm_int_sta(mvm, &mvm->snif_sta, false,\n\t\t\t\t      IWL_MAX_TID_COUNT, &mvm->snif_queue);\n}\n\nint iwl_mvm_mld_rm_aux_sta(struct iwl_mvm *mvm)\n{\n\tlockdep_assert_held(&mvm->mutex);\n\n\treturn iwl_mvm_mld_rm_int_sta(mvm, &mvm->aux_sta, false,\n\t\t\t\t      IWL_MAX_TID_COUNT, &mvm->aux_queue);\n}\n\n \nstatic int iwl_mvm_mld_cfg_sta(struct iwl_mvm *mvm, struct ieee80211_sta *sta,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_link_sta *link_sta,\n\t\t\t       struct ieee80211_bss_conf *link_conf,\n\t\t\t       struct iwl_mvm_link_sta *mvm_link_sta)\n{\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_mvm_vif *mvm_vif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_vif_link_info *link_info =\n\t\t\t\t\tmvm_vif->link[link_conf->link_id];\n\tstruct iwl_mvm_sta_cfg_cmd cmd = {\n\t\t.sta_id = cpu_to_le32(mvm_link_sta->sta_id),\n\t\t.station_type = cpu_to_le32(mvm_sta->sta_type),\n\t};\n\tu32 agg_size = 0, mpdu_dens = 0;\n\n\t \n\tif (WARN_ON(link_info->fw_link_id == IWL_MVM_FW_LINK_ID_INVALID))\n\t\treturn -EINVAL;\n\n\tcmd.link_id = cpu_to_le32(link_info->fw_link_id);\n\n\tmemcpy(&cmd.peer_mld_address, sta->addr, ETH_ALEN);\n\tmemcpy(&cmd.peer_link_address, link_sta->addr, ETH_ALEN);\n\n\tif (mvm_sta->sta_state >= IEEE80211_STA_ASSOC)\n\t\tcmd.assoc_id = cpu_to_le32(sta->aid);\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_STA_EXP_MFP_SUPPORT) &&\n\t    (sta->mfp || mvm_sta->sta_state < IEEE80211_STA_AUTHORIZED))\n\t\tcmd.mfp = cpu_to_le32(1);\n\n\tswitch (link_sta->rx_nss) {\n\tcase 1:\n\t\tcmd.mimo = cpu_to_le32(0);\n\t\tbreak;\n\tcase 2 ... 8:\n\t\tcmd.mimo = cpu_to_le32(1);\n\t\tbreak;\n\t}\n\n\tswitch (sta->deflink.smps_mode) {\n\tcase IEEE80211_SMPS_AUTOMATIC:\n\tcase IEEE80211_SMPS_NUM_MODES:\n\t\tWARN_ON(1);\n\t\tbreak;\n\tcase IEEE80211_SMPS_STATIC:\n\t\t \n\t\tcmd.mimo = cpu_to_le32(0);\n\t\tbreak;\n\tcase IEEE80211_SMPS_DYNAMIC:\n\t\tcmd.mimo_protection = cpu_to_le32(1);\n\t\tbreak;\n\tcase IEEE80211_SMPS_OFF:\n\t\t \n\t\tbreak;\n\t}\n\n\tmpdu_dens = iwl_mvm_get_sta_ampdu_dens(link_sta, link_conf, &agg_size);\n\tcmd.tx_ampdu_spacing = cpu_to_le32(mpdu_dens);\n\tcmd.tx_ampdu_max_size = cpu_to_le32(agg_size);\n\n\tif (sta->wme) {\n\t\tcmd.sp_length =\n\t\t\tcpu_to_le32(sta->max_sp ? sta->max_sp * 2 : 128);\n\t\tcmd.uapsd_acs = cpu_to_le32(iwl_mvm_get_sta_uapsd_acs(sta));\n\t}\n\n\tif (link_sta->he_cap.has_he) {\n\t\tcmd.trig_rnd_alloc =\n\t\t\tcpu_to_le32(link_conf->uora_exists ? 1 : 0);\n\n\t\t \n\t\tiwl_mvm_set_sta_pkt_ext(mvm, link_sta, &cmd.pkt_ext);\n\n\t\t \n\t\tcmd.htc_flags = iwl_mvm_get_sta_htc_flags(sta, link_sta);\n\n\t\tif (link_sta->he_cap.he_cap_elem.mac_cap_info[2] &\n\t\t    IEEE80211_HE_MAC_CAP2_ACK_EN)\n\t\t\tcmd.ack_enabled = cpu_to_le32(1);\n\t}\n\n\treturn iwl_mvm_mld_send_sta_cmd(mvm, &cmd);\n}\n\nstatic void iwl_mvm_mld_free_sta_link(struct iwl_mvm *mvm,\n\t\t\t\t      struct iwl_mvm_sta *mvm_sta,\n\t\t\t\t      struct iwl_mvm_link_sta *mvm_sta_link,\n\t\t\t\t      unsigned int link_id,\n\t\t\t\t      bool is_in_fw)\n{\n\tRCU_INIT_POINTER(mvm->fw_id_to_mac_id[mvm_sta_link->sta_id],\n\t\t\t is_in_fw ? ERR_PTR(-EINVAL) : NULL);\n\tRCU_INIT_POINTER(mvm->fw_id_to_link_sta[mvm_sta_link->sta_id], NULL);\n\tRCU_INIT_POINTER(mvm_sta->link[link_id], NULL);\n\n\tif (mvm_sta_link != &mvm_sta->deflink)\n\t\tkfree_rcu(mvm_sta_link, rcu_head);\n}\n\nstatic void iwl_mvm_mld_sta_rm_all_sta_links(struct iwl_mvm *mvm,\n\t\t\t\t\t     struct iwl_mvm_sta *mvm_sta)\n{\n\tunsigned int link_id;\n\n\tfor (link_id = 0; link_id < ARRAY_SIZE(mvm_sta->link); link_id++) {\n\t\tstruct iwl_mvm_link_sta *link =\n\t\t\trcu_dereference_protected(mvm_sta->link[link_id],\n\t\t\t\t\t\t  lockdep_is_held(&mvm->mutex));\n\n\t\tif (!link)\n\t\t\tcontinue;\n\n\t\tiwl_mvm_mld_free_sta_link(mvm, mvm_sta, link, link_id, false);\n\t}\n}\n\nstatic int iwl_mvm_mld_alloc_sta_link(struct iwl_mvm *mvm,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      unsigned int link_id)\n{\n\tstruct ieee80211_link_sta *link_sta =\n\t\tlink_sta_dereference_protected(sta, link_id);\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_mvm_link_sta *link;\n\tu32 sta_id = iwl_mvm_find_free_sta_id(mvm,\n\t\t\t\t\t  ieee80211_vif_type_p2p(vif));\n\n\tif (sta_id == IWL_MVM_INVALID_STA)\n\t\treturn -ENOSPC;\n\n\tif (rcu_access_pointer(sta->link[link_id]) == &sta->deflink) {\n\t\tlink = &mvm_sta->deflink;\n\t} else {\n\t\tlink = kzalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tlink->sta_id = sta_id;\n\trcu_assign_pointer(mvm_sta->link[link_id], link);\n\trcu_assign_pointer(mvm->fw_id_to_mac_id[link->sta_id], sta);\n\trcu_assign_pointer(mvm->fw_id_to_link_sta[link->sta_id],\n\t\t\t   link_sta);\n\n\treturn 0;\n}\n\n \nstatic int iwl_mvm_mld_alloc_sta_links(struct iwl_mvm *mvm,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_sta *sta)\n{\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\tunsigned int link_id;\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tfor (link_id = 0; link_id < ARRAY_SIZE(sta->link); link_id++) {\n\t\tif (!rcu_access_pointer(sta->link[link_id]) ||\n\t\t    mvm_sta->link[link_id])\n\t\t\tcontinue;\n\n\t\tret = iwl_mvm_mld_alloc_sta_link(mvm, vif, sta, link_id);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tiwl_mvm_mld_sta_rm_all_sta_links(mvm, mvm_sta);\n\treturn ret;\n}\n\nstatic void iwl_mvm_mld_set_ap_sta_id(struct ieee80211_sta *sta,\n\t\t\t\t      struct iwl_mvm_vif_link_info *vif_link,\n\t\t\t\t      struct iwl_mvm_link_sta *sta_link)\n{\n\tif (!sta->tdls) {\n\t\tWARN_ON(vif_link->ap_sta_id != IWL_MVM_INVALID_STA);\n\t\tvif_link->ap_sta_id = sta_link->sta_id;\n\t} else {\n\t\tWARN_ON(vif_link->ap_sta_id == IWL_MVM_INVALID_STA);\n\t}\n}\n\n \nstatic int iwl_mvm_alloc_sta_after_restart(struct iwl_mvm *mvm,\n\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t   struct ieee80211_sta *sta)\n{\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct ieee80211_link_sta *link_sta;\n\tunsigned int link_id;\n\t \n\tint ret = -EINVAL;\n\tint sta_id;\n\n\t \n\tfor_each_sta_active_link(vif, sta, link_sta, link_id) {\n\t\tstruct iwl_mvm_vif_link_info *mvm_link;\n\t\tstruct ieee80211_bss_conf *link_conf =\n\t\t\tlink_conf_dereference_protected(vif, link_id);\n\t\tstruct iwl_mvm_link_sta *mvm_link_sta =\n\t\t\trcu_dereference_protected(mvm_sta->link[link_id],\n\t\t\t\t\t\t  lockdep_is_held(&mvm->mutex));\n\n\t\tif (!link_conf)\n\t\t\tcontinue;\n\n\t\tmvm_link = mvmvif->link[link_conf->link_id];\n\n\t\tif (!mvm_link || !mvm_link_sta)\n\t\t\tcontinue;\n\n\t\tsta_id = mvm_link_sta->sta_id;\n\t\tret = iwl_mvm_mld_cfg_sta(mvm, sta, vif, link_sta,\n\t\t\t\t\t  link_conf, mvm_link_sta);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\trcu_assign_pointer(mvm->fw_id_to_mac_id[sta_id], sta);\n\t\trcu_assign_pointer(mvm->fw_id_to_link_sta[sta_id], link_sta);\n\t\tret = 0;\n\t}\n\n\tiwl_mvm_realloc_queues_after_restart(mvm, sta);\n\n\treturn ret;\n}\n\nint iwl_mvm_mld_add_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_sta *sta)\n{\n\tstruct iwl_mvm_vif *mvm_vif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\tunsigned long link_sta_added_to_fw = 0;\n\tstruct ieee80211_link_sta *link_sta;\n\tint ret = 0;\n\tunsigned int link_id;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (!test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status)) {\n\t\tret = iwl_mvm_mld_alloc_sta_links(mvm, vif, sta);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tspin_lock_init(&mvm_sta->lock);\n\n\t\tret = iwl_mvm_sta_init(mvm, vif, sta, IWL_MVM_INVALID_STA,\n\t\t\t\t       STATION_TYPE_PEER);\n\t} else {\n\t\tret = iwl_mvm_alloc_sta_after_restart(mvm, vif, sta);\n\t}\n\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = iwl_mvm_mld_update_sta(mvm, vif, sta);\n\n\tfor_each_sta_active_link(vif, sta, link_sta, link_id) {\n\t\tstruct ieee80211_bss_conf *link_conf =\n\t\t\tlink_conf_dereference_protected(vif, link_id);\n\t\tstruct iwl_mvm_link_sta *mvm_link_sta =\n\t\t\trcu_dereference_protected(mvm_sta->link[link_id],\n\t\t\t\t\t\t  lockdep_is_held(&mvm->mutex));\n\n\t\tif (WARN_ON(!link_conf || !mvm_link_sta)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = iwl_mvm_mld_cfg_sta(mvm, sta, vif, link_sta, link_conf,\n\t\t\t\t\t  mvm_link_sta);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tlink_sta_added_to_fw |= BIT(link_id);\n\n\t\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\t\tiwl_mvm_mld_set_ap_sta_id(sta, mvm_vif->link[link_id],\n\t\t\t\t\t\t  mvm_link_sta);\n\t}\n\n\treturn 0;\n\nerr:\n\t \n\tfor_each_set_bit(link_id, &link_sta_added_to_fw,\n\t\t\t IEEE80211_MLD_MAX_NUM_LINKS) {\n\t\tstruct iwl_mvm_link_sta *mvm_link_sta =\n\t\t\trcu_dereference_protected(mvm_sta->link[link_id],\n\t\t\t\t\t\t  lockdep_is_held(&mvm->mutex));\n\n\t\tiwl_mvm_mld_rm_sta_from_fw(mvm, mvm_link_sta->sta_id);\n\t}\n\n\t \n\tiwl_mvm_mld_sta_rm_all_sta_links(mvm, mvm_sta);\n\treturn ret;\n}\n\nint iwl_mvm_mld_update_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_sta *sta)\n{\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct ieee80211_link_sta *link_sta;\n\tunsigned int link_id;\n\tint ret = -EINVAL;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tfor_each_sta_active_link(vif, sta, link_sta, link_id) {\n\t\tstruct ieee80211_bss_conf *link_conf =\n\t\t\tlink_conf_dereference_protected(vif, link_id);\n\t\tstruct iwl_mvm_link_sta *mvm_link_sta =\n\t\t\trcu_dereference_protected(mvm_sta->link[link_id],\n\t\t\t\t\t\t  lockdep_is_held(&mvm->mutex));\n\n\t\tif (WARN_ON(!link_conf || !mvm_link_sta))\n\t\t\treturn -EINVAL;\n\n\t\tret = iwl_mvm_mld_cfg_sta(mvm, sta, vif, link_sta, link_conf,\n\t\t\t\t\t  mvm_link_sta);\n\n\t\tif (ret) {\n\t\t\tIWL_ERR(mvm, \"Failed to update sta link %d\\n\", link_id);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void iwl_mvm_mld_disable_sta_queues(struct iwl_mvm *mvm,\n\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t   struct ieee80211_sta *sta)\n{\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\tu32 sta_mask = iwl_mvm_sta_fw_id_mask(mvm, sta, -1);\n\tint i;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tfor (i = 0; i < ARRAY_SIZE(mvm_sta->tid_data); i++) {\n\t\tif (mvm_sta->tid_data[i].txq_id == IWL_MVM_INVALID_QUEUE)\n\t\t\tcontinue;\n\n\t\tiwl_mvm_mld_disable_txq(mvm, sta_mask,\n\t\t\t\t\t&mvm_sta->tid_data[i].txq_id, i);\n\t\tmvm_sta->tid_data[i].txq_id = IWL_MVM_INVALID_QUEUE;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(sta->txq); i++) {\n\t\tstruct iwl_mvm_txq *mvmtxq =\n\t\t\tiwl_mvm_txq_from_mac80211(sta->txq[i]);\n\n\t\tmvmtxq->txq_id = IWL_MVM_INVALID_QUEUE;\n\t}\n}\n\nint iwl_mvm_mld_rm_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_sta *sta)\n{\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct ieee80211_link_sta *link_sta;\n\tunsigned int link_id;\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\t \n\tfor_each_sta_active_link(vif, sta, link_sta, link_id) {\n\t\tstruct iwl_mvm_link_sta *mvm_link_sta =\n\t\t\trcu_dereference_protected(mvm_sta->link[link_id],\n\t\t\t\t\t\t  lockdep_is_held(&mvm->mutex));\n\n\t\tif (WARN_ON(!mvm_link_sta))\n\t\t\treturn -EINVAL;\n\n\t\tret = iwl_mvm_flush_sta_tids(mvm, mvm_link_sta->sta_id,\n\t\t\t\t\t     0xffff);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = iwl_mvm_wait_sta_queues_empty(mvm, mvm_sta);\n\tif (ret)\n\t\treturn ret;\n\n\tiwl_mvm_mld_disable_sta_queues(mvm, vif, sta);\n\n\tfor_each_sta_active_link(vif, sta, link_sta, link_id) {\n\t\tstruct iwl_mvm_link_sta *mvm_link_sta =\n\t\t\trcu_dereference_protected(mvm_sta->link[link_id],\n\t\t\t\t\t\t  lockdep_is_held(&mvm->mutex));\n\t\tbool stay_in_fw;\n\n\t\tstay_in_fw = iwl_mvm_sta_del(mvm, vif, sta, link_sta, &ret);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (!stay_in_fw)\n\t\t\tret = iwl_mvm_mld_rm_sta_from_fw(mvm,\n\t\t\t\t\t\t\t mvm_link_sta->sta_id);\n\n\t\tiwl_mvm_mld_free_sta_link(mvm, mvm_sta, mvm_link_sta,\n\t\t\t\t\t  link_id, stay_in_fw);\n\t}\n\n\treturn ret;\n}\n\nint iwl_mvm_mld_rm_sta_id(struct iwl_mvm *mvm, u8 sta_id)\n{\n\tint ret = iwl_mvm_mld_rm_sta_from_fw(mvm, sta_id);\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tRCU_INIT_POINTER(mvm->fw_id_to_mac_id[sta_id], NULL);\n\tRCU_INIT_POINTER(mvm->fw_id_to_link_sta[sta_id], NULL);\n\treturn ret;\n}\n\nvoid iwl_mvm_mld_sta_modify_disable_tx(struct iwl_mvm *mvm,\n\t\t\t\t       struct iwl_mvm_sta *mvmsta,\n\t\t\t\t       bool disable)\n{\n\tstruct iwl_mvm_sta_disable_tx_cmd cmd;\n\tint ret;\n\n\tcmd.sta_id = cpu_to_le32(mvmsta->deflink.sta_id);\n\tcmd.disable = cpu_to_le32(disable);\n\n\tret = iwl_mvm_send_cmd_pdu(mvm,\n\t\t\t\t   WIDE_ID(MAC_CONF_GROUP, STA_DISABLE_TX_CMD),\n\t\t\t\t   CMD_ASYNC, sizeof(cmd), &cmd);\n\tif (ret)\n\t\tIWL_ERR(mvm,\n\t\t\t\"Failed to send STA_DISABLE_TX_CMD command (%d)\\n\",\n\t\t\tret);\n}\n\nvoid iwl_mvm_mld_sta_modify_disable_tx_ap(struct iwl_mvm *mvm,\n\t\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t\t  bool disable)\n{\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\n\tspin_lock_bh(&mvm_sta->lock);\n\n\tif (mvm_sta->disable_tx == disable) {\n\t\tspin_unlock_bh(&mvm_sta->lock);\n\t\treturn;\n\t}\n\n\tiwl_mvm_mld_sta_modify_disable_tx(mvm, mvm_sta, disable);\n\n\tspin_unlock_bh(&mvm_sta->lock);\n}\n\nvoid iwl_mvm_mld_modify_all_sta_disable_tx(struct iwl_mvm *mvm,\n\t\t\t\t\t   struct iwl_mvm_vif *mvmvif,\n\t\t\t\t\t   bool disable)\n{\n\tstruct ieee80211_sta *sta;\n\tstruct iwl_mvm_sta *mvm_sta;\n\tint i;\n\n\trcu_read_lock();\n\n\t \n\tfor (i = 0; i < mvm->fw->ucode_capa.num_stations; i++) {\n\t\tsta = rcu_dereference(mvm->fw_id_to_mac_id[i]);\n\t\tif (IS_ERR_OR_NULL(sta))\n\t\t\tcontinue;\n\n\t\tmvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\t\tif (mvm_sta->mac_id_n_color !=\n\t\t    FW_CMD_ID_AND_COLOR(mvmvif->id, mvmvif->color))\n\t\t\tcontinue;\n\n\t\tiwl_mvm_mld_sta_modify_disable_tx(mvm, mvm_sta, disable);\n\t}\n\n\trcu_read_unlock();\n}\n\nstatic int iwl_mvm_mld_update_sta_queues(struct iwl_mvm *mvm,\n\t\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t\t u32 old_sta_mask,\n\t\t\t\t\t u32 new_sta_mask)\n{\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_scd_queue_cfg_cmd cmd = {\n\t\t.operation = cpu_to_le32(IWL_SCD_QUEUE_MODIFY),\n\t\t.u.modify.old_sta_mask = cpu_to_le32(old_sta_mask),\n\t\t.u.modify.new_sta_mask = cpu_to_le32(new_sta_mask),\n\t};\n\tstruct iwl_host_cmd hcmd = {\n\t\t.id = WIDE_ID(DATA_PATH_GROUP, SCD_QUEUE_CONFIG_CMD),\n\t\t.len[0] = sizeof(cmd),\n\t\t.data[0] = &cmd\n\t};\n\tint tid;\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tfor (tid = 0; tid <= IWL_MAX_TID_COUNT; tid++) {\n\t\tstruct iwl_mvm_tid_data *tid_data = &mvm_sta->tid_data[tid];\n\t\tint txq_id = tid_data->txq_id;\n\n\t\tif (txq_id == IWL_MVM_INVALID_QUEUE)\n\t\t\tcontinue;\n\n\t\tif (tid == IWL_MAX_TID_COUNT)\n\t\t\tcmd.u.modify.tid = cpu_to_le32(IWL_MGMT_TID);\n\t\telse\n\t\t\tcmd.u.modify.tid = cpu_to_le32(tid);\n\n\t\tret = iwl_mvm_send_cmd(mvm, &hcmd);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int iwl_mvm_mld_update_sta_baids(struct iwl_mvm *mvm,\n\t\t\t\t\tu32 old_sta_mask,\n\t\t\t\t\tu32 new_sta_mask)\n{\n\tstruct iwl_rx_baid_cfg_cmd cmd = {\n\t\t.action = cpu_to_le32(IWL_RX_BAID_ACTION_MODIFY),\n\t\t.modify.old_sta_id_mask = cpu_to_le32(old_sta_mask),\n\t\t.modify.new_sta_id_mask = cpu_to_le32(new_sta_mask),\n\t};\n\tu32 cmd_id = WIDE_ID(DATA_PATH_GROUP, RX_BAID_ALLOCATION_CONFIG_CMD);\n\tint baid;\n\n\tBUILD_BUG_ON(sizeof(struct iwl_rx_baid_cfg_resp) != sizeof(baid));\n\n\tfor (baid = 0; baid < ARRAY_SIZE(mvm->baid_map); baid++) {\n\t\tstruct iwl_mvm_baid_data *data;\n\t\tint ret;\n\n\t\tdata = rcu_dereference_protected(mvm->baid_map[baid],\n\t\t\t\t\t\t lockdep_is_held(&mvm->mutex));\n\t\tif (!data)\n\t\t\tcontinue;\n\n\t\tif (!(data->sta_mask & old_sta_mask))\n\t\t\tcontinue;\n\n\t\tWARN_ONCE(data->sta_mask != old_sta_mask,\n\t\t\t  \"BAID data for %d corrupted - expected 0x%x found 0x%x\\n\",\n\t\t\t  baid, old_sta_mask, data->sta_mask);\n\n\t\tcmd.modify.tid = cpu_to_le32(data->tid);\n\n\t\tret = iwl_mvm_send_cmd_pdu(mvm, cmd_id, 0, sizeof(cmd), &cmd);\n\t\tdata->sta_mask = new_sta_mask;\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int iwl_mvm_mld_update_sta_resources(struct iwl_mvm *mvm,\n\t\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t\t    struct ieee80211_sta *sta,\n\t\t\t\t\t    u32 old_sta_mask,\n\t\t\t\t\t    u32 new_sta_mask)\n{\n\tint ret;\n\n\tret = iwl_mvm_mld_update_sta_queues(mvm, sta,\n\t\t\t\t\t    old_sta_mask,\n\t\t\t\t\t    new_sta_mask);\n\tif (ret)\n\t\treturn ret;\n\n\tret = iwl_mvm_mld_update_sta_keys(mvm, vif, sta,\n\t\t\t\t\t  old_sta_mask,\n\t\t\t\t\t  new_sta_mask);\n\tif (ret)\n\t\treturn ret;\n\n\treturn iwl_mvm_mld_update_sta_baids(mvm, old_sta_mask, new_sta_mask);\n}\n\nint iwl_mvm_mld_update_sta_links(struct iwl_mvm *mvm,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t u16 old_links, u16 new_links)\n{\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_mvm_vif *mvm_vif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_link_sta *mvm_sta_link;\n\tstruct iwl_mvm_vif_link_info *mvm_vif_link;\n\tunsigned long links_to_add = ~old_links & new_links;\n\tunsigned long links_to_rem = old_links & ~new_links;\n\tunsigned long old_links_long = old_links;\n\tu32 current_sta_mask = 0, sta_mask_added = 0, sta_mask_to_rem = 0;\n\tunsigned long link_sta_added_to_fw = 0, link_sta_allocated = 0;\n\tunsigned int link_id;\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tfor_each_set_bit(link_id, &old_links_long,\n\t\t\t IEEE80211_MLD_MAX_NUM_LINKS) {\n\t\tmvm_sta_link =\n\t\t\trcu_dereference_protected(mvm_sta->link[link_id],\n\t\t\t\t\t\t  lockdep_is_held(&mvm->mutex));\n\n\t\tif (WARN_ON(!mvm_sta_link)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tcurrent_sta_mask |= BIT(mvm_sta_link->sta_id);\n\t\tif (links_to_rem & BIT(link_id))\n\t\t\tsta_mask_to_rem |= BIT(mvm_sta_link->sta_id);\n\t}\n\n\tif (sta_mask_to_rem) {\n\t\tret = iwl_mvm_mld_update_sta_resources(mvm, vif, sta,\n\t\t\t\t\t\t       current_sta_mask,\n\t\t\t\t\t\t       current_sta_mask &\n\t\t\t\t\t\t\t~sta_mask_to_rem);\n\t\tif (WARN_ON(ret))\n\t\t\tgoto err;\n\n\t\tcurrent_sta_mask &= ~sta_mask_to_rem;\n\t}\n\n\tfor_each_set_bit(link_id, &links_to_rem, IEEE80211_MLD_MAX_NUM_LINKS) {\n\t\tmvm_sta_link =\n\t\t\trcu_dereference_protected(mvm_sta->link[link_id],\n\t\t\t\t\t\t  lockdep_is_held(&mvm->mutex));\n\t\tmvm_vif_link = mvm_vif->link[link_id];\n\n\t\tif (WARN_ON(!mvm_sta_link || !mvm_vif_link)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = iwl_mvm_mld_rm_sta_from_fw(mvm, mvm_sta_link->sta_id);\n\t\tif (WARN_ON(ret))\n\t\t\tgoto err;\n\n\t\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\t\tmvm_vif_link->ap_sta_id = IWL_MVM_INVALID_STA;\n\n\t\tiwl_mvm_mld_free_sta_link(mvm, mvm_sta, mvm_sta_link, link_id,\n\t\t\t\t\t  false);\n\t}\n\n\tfor_each_set_bit(link_id, &links_to_add, IEEE80211_MLD_MAX_NUM_LINKS) {\n\t\tstruct ieee80211_bss_conf *link_conf =\n\t\t\tlink_conf_dereference_protected(vif, link_id);\n\t\tstruct ieee80211_link_sta *link_sta =\n\t\t\tlink_sta_dereference_protected(sta, link_id);\n\t\tmvm_vif_link = mvm_vif->link[link_id];\n\n\t\tif (WARN_ON(!mvm_vif_link || !link_conf || !link_sta ||\n\t\t\t    mvm_sta->link[link_id])) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = iwl_mvm_mld_alloc_sta_link(mvm, vif, sta, link_id);\n\t\tif (WARN_ON(ret))\n\t\t\tgoto err;\n\n\t\tlink_sta->agg.max_rc_amsdu_len = 1;\n\t\tieee80211_sta_recalc_aggregates(sta);\n\n\t\tmvm_sta_link =\n\t\t\trcu_dereference_protected(mvm_sta->link[link_id],\n\t\t\t\t\t\t  lockdep_is_held(&mvm->mutex));\n\n\t\tif (WARN_ON(!mvm_sta_link)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\t\tiwl_mvm_mld_set_ap_sta_id(sta, mvm_vif_link,\n\t\t\t\t\t\t  mvm_sta_link);\n\n\t\tlink_sta_allocated |= BIT(link_id);\n\n\t\tsta_mask_added |= BIT(mvm_sta_link->sta_id);\n\n\t\tret = iwl_mvm_mld_cfg_sta(mvm, sta, vif, link_sta, link_conf,\n\t\t\t\t\t  mvm_sta_link);\n\t\tif (WARN_ON(ret))\n\t\t\tgoto err;\n\n\t\tlink_sta_added_to_fw |= BIT(link_id);\n\n\t\tiwl_mvm_rs_add_sta_link(mvm, mvm_sta_link);\n\t}\n\n\tif (sta_mask_added) {\n\t\tret = iwl_mvm_mld_update_sta_resources(mvm, vif, sta,\n\t\t\t\t\t\t       current_sta_mask,\n\t\t\t\t\t\t       current_sta_mask |\n\t\t\t\t\t\t\tsta_mask_added);\n\t\tif (WARN_ON(ret))\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\t \n\tfor_each_set_bit(link_id, &link_sta_added_to_fw,\n\t\t\t IEEE80211_MLD_MAX_NUM_LINKS) {\n\t\tmvm_sta_link =\n\t\t\trcu_dereference_protected(mvm_sta->link[link_id],\n\t\t\t\t\t\t  lockdep_is_held(&mvm->mutex));\n\n\t\tiwl_mvm_mld_rm_sta_from_fw(mvm, mvm_sta_link->sta_id);\n\t}\n\n\t \n\tfor_each_set_bit(link_id, &link_sta_allocated,\n\t\t\t IEEE80211_MLD_MAX_NUM_LINKS) {\n\t\tmvm_sta_link =\n\t\t\trcu_dereference_protected(mvm_sta->link[link_id],\n\t\t\t\t\t\t  lockdep_is_held(&mvm->mutex));\n\n\t\tiwl_mvm_mld_free_sta_link(mvm, mvm_sta, mvm_sta_link, link_id,\n\t\t\t\t\t  false);\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}