{
  "module_name": "power.c",
  "hash_id": "fb84def0ac504e2e1b4eea36d28240d6f282f4a9fca9be06daa847421ee1c1b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/power.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/etherdevice.h>\n\n#include <net/mac80211.h>\n\n#include \"iwl-debug.h\"\n#include \"mvm.h\"\n#include \"iwl-modparams.h\"\n#include \"fw/api/power.h\"\n\n#define POWER_KEEP_ALIVE_PERIOD_SEC    25\n\nstatic\nint iwl_mvm_beacon_filter_send_cmd(struct iwl_mvm *mvm,\n\t\t\t\t   struct iwl_beacon_filter_cmd *cmd,\n\t\t\t\t   u32 flags)\n{\n\tu16 len;\n\n\tIWL_DEBUG_POWER(mvm, \"ba_enable_beacon_abort is: %d\\n\",\n\t\t\tle32_to_cpu(cmd->ba_enable_beacon_abort));\n\tIWL_DEBUG_POWER(mvm, \"ba_escape_timer is: %d\\n\",\n\t\t\tle32_to_cpu(cmd->ba_escape_timer));\n\tIWL_DEBUG_POWER(mvm, \"bf_debug_flag is: %d\\n\",\n\t\t\tle32_to_cpu(cmd->bf_debug_flag));\n\tIWL_DEBUG_POWER(mvm, \"bf_enable_beacon_filter is: %d\\n\",\n\t\t\tle32_to_cpu(cmd->bf_enable_beacon_filter));\n\tIWL_DEBUG_POWER(mvm, \"bf_energy_delta is: %d\\n\",\n\t\t\tle32_to_cpu(cmd->bf_energy_delta));\n\tIWL_DEBUG_POWER(mvm, \"bf_escape_timer is: %d\\n\",\n\t\t\tle32_to_cpu(cmd->bf_escape_timer));\n\tIWL_DEBUG_POWER(mvm, \"bf_roaming_energy_delta is: %d\\n\",\n\t\t\tle32_to_cpu(cmd->bf_roaming_energy_delta));\n\tIWL_DEBUG_POWER(mvm, \"bf_roaming_state is: %d\\n\",\n\t\t\tle32_to_cpu(cmd->bf_roaming_state));\n\tIWL_DEBUG_POWER(mvm, \"bf_temp_threshold is: %d\\n\",\n\t\t\tle32_to_cpu(cmd->bf_temp_threshold));\n\tIWL_DEBUG_POWER(mvm, \"bf_temp_fast_filter is: %d\\n\",\n\t\t\tle32_to_cpu(cmd->bf_temp_fast_filter));\n\tIWL_DEBUG_POWER(mvm, \"bf_temp_slow_filter is: %d\\n\",\n\t\t\tle32_to_cpu(cmd->bf_temp_slow_filter));\n\tIWL_DEBUG_POWER(mvm, \"bf_threshold_absolute_low is: %d, %d\\n\",\n\t\t\tle32_to_cpu(cmd->bf_threshold_absolute_low[0]),\n\t\t\tle32_to_cpu(cmd->bf_threshold_absolute_low[1]));\n\n\tIWL_DEBUG_POWER(mvm, \"bf_threshold_absolute_high is: %d, %d\\n\",\n\t\t\tle32_to_cpu(cmd->bf_threshold_absolute_high[0]),\n\t\t\tle32_to_cpu(cmd->bf_threshold_absolute_high[1]));\n\n\tif (fw_has_api(&mvm->fw->ucode_capa,\n\t\t       IWL_UCODE_TLV_API_BEACON_FILTER_V4))\n\t\tlen = sizeof(struct iwl_beacon_filter_cmd);\n\telse\n\t\tlen = offsetof(struct iwl_beacon_filter_cmd,\n\t\t\t       bf_threshold_absolute_low);\n\n\treturn iwl_mvm_send_cmd_pdu(mvm, REPLY_BEACON_FILTERING_CMD, flags,\n\t\t\t\t    len, cmd);\n}\n\nstatic\nvoid iwl_mvm_beacon_filter_set_cqm_params(struct iwl_mvm *mvm,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  struct iwl_beacon_filter_cmd *cmd)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tif (vif->bss_conf.cqm_rssi_thold) {\n\t\tcmd->bf_energy_delta =\n\t\t\tcpu_to_le32(vif->bss_conf.cqm_rssi_hyst);\n\t\t \n\t\tcmd->bf_roaming_state =\n\t\t\tcpu_to_le32(-vif->bss_conf.cqm_rssi_thold);\n\t}\n\tcmd->ba_enable_beacon_abort = cpu_to_le32(mvmvif->bf_data.ba_enabled);\n}\n\nstatic void iwl_mvm_power_log(struct iwl_mvm *mvm,\n\t\t\t      struct iwl_mac_power_cmd *cmd)\n{\n\tIWL_DEBUG_POWER(mvm,\n\t\t\t\"Sending power table command on mac id 0x%X for power level %d, flags = 0x%X\\n\",\n\t\t\tcmd->id_and_color, iwlmvm_mod_params.power_scheme,\n\t\t\tle16_to_cpu(cmd->flags));\n\tIWL_DEBUG_POWER(mvm, \"Keep alive = %u sec\\n\",\n\t\t\tle16_to_cpu(cmd->keep_alive_seconds));\n\n\tif (!(cmd->flags & cpu_to_le16(POWER_FLAGS_POWER_MANAGEMENT_ENA_MSK))) {\n\t\tIWL_DEBUG_POWER(mvm, \"Disable power management\\n\");\n\t\treturn;\n\t}\n\n\tIWL_DEBUG_POWER(mvm, \"Rx timeout = %u usec\\n\",\n\t\t\tle32_to_cpu(cmd->rx_data_timeout));\n\tIWL_DEBUG_POWER(mvm, \"Tx timeout = %u usec\\n\",\n\t\t\tle32_to_cpu(cmd->tx_data_timeout));\n\tif (cmd->flags & cpu_to_le16(POWER_FLAGS_SKIP_OVER_DTIM_MSK))\n\t\tIWL_DEBUG_POWER(mvm, \"DTIM periods to skip = %u\\n\",\n\t\t\t\tcmd->skip_dtim_periods);\n\tif (cmd->flags & cpu_to_le16(POWER_FLAGS_LPRX_ENA_MSK))\n\t\tIWL_DEBUG_POWER(mvm, \"LP RX RSSI threshold = %u\\n\",\n\t\t\t\tcmd->lprx_rssi_threshold);\n\tif (cmd->flags & cpu_to_le16(POWER_FLAGS_ADVANCE_PM_ENA_MSK)) {\n\t\tIWL_DEBUG_POWER(mvm, \"uAPSD enabled\\n\");\n\t\tIWL_DEBUG_POWER(mvm, \"Rx timeout (uAPSD) = %u usec\\n\",\n\t\t\t\tle32_to_cpu(cmd->rx_data_timeout_uapsd));\n\t\tIWL_DEBUG_POWER(mvm, \"Tx timeout (uAPSD) = %u usec\\n\",\n\t\t\t\tle32_to_cpu(cmd->tx_data_timeout_uapsd));\n\t\tIWL_DEBUG_POWER(mvm, \"QNDP TID = %d\\n\", cmd->qndp_tid);\n\t\tIWL_DEBUG_POWER(mvm, \"ACs flags = 0x%x\\n\", cmd->uapsd_ac_flags);\n\t\tIWL_DEBUG_POWER(mvm, \"Max SP = %d\\n\", cmd->uapsd_max_sp);\n\t}\n}\n\nstatic void iwl_mvm_power_configure_uapsd(struct iwl_mvm *mvm,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  struct iwl_mac_power_cmd *cmd)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tenum ieee80211_ac_numbers ac;\n\tbool tid_found = false;\n\n\tif (test_bit(IWL_MVM_STATUS_IN_D3, &mvm->status) ||\n\t    cmd->flags & cpu_to_le16(POWER_FLAGS_SNOOZE_ENA_MSK)) {\n\t\tcmd->rx_data_timeout_uapsd =\n\t\t\tcpu_to_le32(IWL_MVM_WOWLAN_PS_RX_DATA_TIMEOUT);\n\t\tcmd->tx_data_timeout_uapsd =\n\t\t\tcpu_to_le32(IWL_MVM_WOWLAN_PS_TX_DATA_TIMEOUT);\n\t} else {\n\t\tcmd->rx_data_timeout_uapsd =\n\t\t\tcpu_to_le32(IWL_MVM_UAPSD_RX_DATA_TIMEOUT);\n\t\tcmd->tx_data_timeout_uapsd =\n\t\t\tcpu_to_le32(IWL_MVM_UAPSD_TX_DATA_TIMEOUT);\n\t}\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\t \n\tif (mvmvif->dbgfs_pm.use_ps_poll) {\n\t\tcmd->flags |= cpu_to_le16(POWER_FLAGS_ADVANCE_PM_ENA_MSK);\n\t\treturn;\n\t}\n#endif\n\n\tfor (ac = IEEE80211_AC_VO; ac <= IEEE80211_AC_BK; ac++) {\n\t\tif (!mvmvif->deflink.queue_params[ac].uapsd)\n\t\t\tcontinue;\n\n\t\tif (!test_bit(IWL_MVM_STATUS_IN_D3, &mvm->status))\n\t\t\tcmd->flags |=\n\t\t\t\tcpu_to_le16(POWER_FLAGS_ADVANCE_PM_ENA_MSK);\n\n\t\tcmd->uapsd_ac_flags |= BIT(ac);\n\n\t\t \n\t\tif (!tid_found && !mvmvif->deflink.queue_params[ac].acm) {\n\t\t\ttid_found = true;\n\t\t\tswitch (ac) {\n\t\t\tcase IEEE80211_AC_VO:\n\t\t\t\tcmd->qndp_tid = 6;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_AC_VI:\n\t\t\t\tcmd->qndp_tid = 5;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_AC_BE:\n\t\t\t\tcmd->qndp_tid = 0;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_AC_BK:\n\t\t\t\tcmd->qndp_tid = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcmd->flags |= cpu_to_le16(POWER_FLAGS_UAPSD_MISBEHAVING_ENA_MSK);\n\n\tif (cmd->uapsd_ac_flags == (BIT(IEEE80211_AC_VO) |\n\t\t\t\t    BIT(IEEE80211_AC_VI) |\n\t\t\t\t    BIT(IEEE80211_AC_BE) |\n\t\t\t\t    BIT(IEEE80211_AC_BK))) {\n\t\tcmd->flags |= cpu_to_le16(POWER_FLAGS_SNOOZE_ENA_MSK);\n\t\tcmd->snooze_interval = cpu_to_le16(IWL_MVM_PS_SNOOZE_INTERVAL);\n\t\tcmd->snooze_window =\n\t\t\ttest_bit(IWL_MVM_STATUS_IN_D3, &mvm->status) ?\n\t\t\t\tcpu_to_le16(IWL_MVM_WOWLAN_PS_SNOOZE_WINDOW) :\n\t\t\t\tcpu_to_le16(IWL_MVM_PS_SNOOZE_WINDOW);\n\t}\n\n\tcmd->uapsd_max_sp = mvm->hw->uapsd_max_sp_len;\n\n\tif (cmd->flags & cpu_to_le16(POWER_FLAGS_SNOOZE_ENA_MSK)) {\n\t\tcmd->heavy_tx_thld_packets =\n\t\t\tIWL_MVM_PS_SNOOZE_HEAVY_TX_THLD_PACKETS;\n\t\tcmd->heavy_rx_thld_packets =\n\t\t\tIWL_MVM_PS_SNOOZE_HEAVY_RX_THLD_PACKETS;\n\t} else {\n\t\tcmd->heavy_tx_thld_packets =\n\t\t\tIWL_MVM_PS_HEAVY_TX_THLD_PACKETS;\n\t\tcmd->heavy_rx_thld_packets =\n\t\t\tIWL_MVM_PS_HEAVY_RX_THLD_PACKETS;\n\t}\n\tcmd->heavy_tx_thld_percentage =\n\t\tIWL_MVM_PS_HEAVY_TX_THLD_PERCENT;\n\tcmd->heavy_rx_thld_percentage =\n\t\tIWL_MVM_PS_HEAVY_RX_THLD_PERCENT;\n}\n\nstatic void iwl_mvm_p2p_standalone_iterator(void *_data, u8 *mac,\n\t\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tbool *is_p2p_standalone = _data;\n\n\tswitch (ieee80211_vif_type_p2p(vif)) {\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_AP:\n\t\t*is_p2p_standalone = false;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (vif->cfg.assoc)\n\t\t\t*is_p2p_standalone = false;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic bool iwl_mvm_power_allow_uapsd(struct iwl_mvm *mvm,\n\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tif (ether_addr_equal(mvmvif->uapsd_misbehaving_ap_addr,\n\t\t\t     vif->cfg.ap_addr))\n\t\treturn false;\n\n\t \n\tif (vif->p2p &&\n\t    (vif->bss_conf.p2p_noa_attr.oppps_ctwindow &\n\t    IEEE80211_P2P_OPPPS_ENABLE_BIT))\n\t\treturn false;\n\n\t \n\tif (iwl_mvm_phy_ctx_count(mvm) >= 2)\n\t\treturn false;\n\n\tif (vif->p2p) {\n\t\t \n\t\tbool is_p2p_standalone = true;\n\n\t\tif (!iwl_mvm_is_p2p_scm_uapsd_supported(mvm))\n\t\t\treturn false;\n\n\t\tieee80211_iterate_active_interfaces_atomic(mvm->hw,\n\t\t\t\t\tIEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\tiwl_mvm_p2p_standalone_iterator,\n\t\t\t\t\t&is_p2p_standalone);\n\n\t\tif (!is_p2p_standalone)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool iwl_mvm_power_is_radar(struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_bss_conf *link_conf;\n\tbool radar_detect = false;\n\tunsigned int link_id;\n\n\trcu_read_lock();\n\tfor_each_vif_active_link(vif, link_conf, link_id) {\n\t\tchanctx_conf = rcu_dereference(link_conf->chanctx_conf);\n\t\t \n\t\tif (!chanctx_conf)\n\t\t\tcontinue;\n\n\t\tradar_detect = !!(chanctx_conf->def.chan->flags &\n\t\t\t\t  IEEE80211_CHAN_RADAR);\n\t\tif (radar_detect)\n\t\t\tgoto out;\n\t}\n\nout:\n\trcu_read_unlock();\n\treturn radar_detect;\n}\n\nstatic void iwl_mvm_power_config_skip_dtim(struct iwl_mvm *mvm,\n\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t   struct iwl_mac_power_cmd *cmd)\n{\n\tint dtimper = vif->bss_conf.dtim_period ?: 1;\n\tint skip;\n\n\t \n\tcmd->skip_dtim_periods = 0;\n\tcmd->flags &= ~cpu_to_le16(POWER_FLAGS_SKIP_OVER_DTIM_MSK);\n\n\tif (iwl_mvm_power_is_radar(vif))\n\t\treturn;\n\n\tif (dtimper >= 10)\n\t\treturn;\n\n\tif (!test_bit(IWL_MVM_STATUS_IN_D3, &mvm->status)) {\n\t\tif (iwlmvm_mod_params.power_scheme != IWL_POWER_SCHEME_LP)\n\t\t\treturn;\n\t\tskip = 2;\n\t} else {\n\t\tint dtimper_tu = dtimper * vif->bss_conf.beacon_int;\n\n\t\tif (WARN_ON(!dtimper_tu))\n\t\t\treturn;\n\t\t \n\t\tskip = max_t(u8, 1, 900 / dtimper_tu);\n\t}\n\n\tcmd->skip_dtim_periods = skip;\n\tcmd->flags |= cpu_to_le16(POWER_FLAGS_SKIP_OVER_DTIM_MSK);\n}\n\nstatic void iwl_mvm_power_build_cmd(struct iwl_mvm *mvm,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct iwl_mac_power_cmd *cmd)\n{\n\tint dtimper, bi;\n\tint keep_alive;\n\tstruct iwl_mvm_vif *mvmvif __maybe_unused =\n\t\tiwl_mvm_vif_from_mac80211(vif);\n\n\tcmd->id_and_color = cpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id,\n\t\t\t\t\t\t\t    mvmvif->color));\n\tdtimper = vif->bss_conf.dtim_period;\n\tbi = vif->bss_conf.beacon_int;\n\n\t \n\tkeep_alive = DIV_ROUND_UP(ieee80211_tu_to_usec(3 * dtimper * bi),\n\t\t\t\t  USEC_PER_SEC);\n\tkeep_alive = max(keep_alive, POWER_KEEP_ALIVE_PERIOD_SEC);\n\tcmd->keep_alive_seconds = cpu_to_le16(keep_alive);\n\n\tif (mvm->ps_disabled)\n\t\treturn;\n\n\tcmd->flags |= cpu_to_le16(POWER_FLAGS_POWER_SAVE_ENA_MSK);\n\n\tif (!vif->cfg.ps || !mvmvif->pm_enabled)\n\t\treturn;\n\n\tif (iwl_mvm_vif_low_latency(mvmvif) && vif->p2p &&\n\t    (!fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t IWL_UCODE_TLV_CAPA_SHORT_PM_TIMEOUTS) ||\n\t     !IWL_MVM_P2P_LOWLATENCY_PS_ENABLE))\n\t\treturn;\n\n\tcmd->flags |= cpu_to_le16(POWER_FLAGS_POWER_MANAGEMENT_ENA_MSK);\n\n\tif (vif->bss_conf.beacon_rate &&\n\t    (vif->bss_conf.beacon_rate->bitrate == 10 ||\n\t     vif->bss_conf.beacon_rate->bitrate == 60)) {\n\t\tcmd->flags |= cpu_to_le16(POWER_FLAGS_LPRX_ENA_MSK);\n\t\tcmd->lprx_rssi_threshold = POWER_LPRX_RSSI_THRESHOLD;\n\t}\n\n\tiwl_mvm_power_config_skip_dtim(mvm, vif, cmd);\n\n\tif (test_bit(IWL_MVM_STATUS_IN_D3, &mvm->status)) {\n\t\tcmd->rx_data_timeout =\n\t\t\tcpu_to_le32(IWL_MVM_WOWLAN_PS_RX_DATA_TIMEOUT);\n\t\tcmd->tx_data_timeout =\n\t\t\tcpu_to_le32(IWL_MVM_WOWLAN_PS_TX_DATA_TIMEOUT);\n\t} else if (iwl_mvm_vif_low_latency(mvmvif) && vif->p2p &&\n\t\t   fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t       IWL_UCODE_TLV_CAPA_SHORT_PM_TIMEOUTS)) {\n\t\tcmd->tx_data_timeout =\n\t\t\tcpu_to_le32(IWL_MVM_SHORT_PS_TX_DATA_TIMEOUT);\n\t\tcmd->rx_data_timeout =\n\t\t\tcpu_to_le32(IWL_MVM_SHORT_PS_RX_DATA_TIMEOUT);\n\t} else {\n\t\tcmd->rx_data_timeout =\n\t\t\tcpu_to_le32(IWL_MVM_DEFAULT_PS_RX_DATA_TIMEOUT);\n\t\tcmd->tx_data_timeout =\n\t\t\tcpu_to_le32(IWL_MVM_DEFAULT_PS_TX_DATA_TIMEOUT);\n\t}\n\n\tif (iwl_mvm_power_allow_uapsd(mvm, vif))\n\t\tiwl_mvm_power_configure_uapsd(mvm, vif, cmd);\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tif (mvmvif->dbgfs_pm.mask & MVM_DEBUGFS_PM_KEEP_ALIVE)\n\t\tcmd->keep_alive_seconds =\n\t\t\tcpu_to_le16(mvmvif->dbgfs_pm.keep_alive_seconds);\n\tif (mvmvif->dbgfs_pm.mask & MVM_DEBUGFS_PM_SKIP_OVER_DTIM) {\n\t\tif (mvmvif->dbgfs_pm.skip_over_dtim)\n\t\t\tcmd->flags |=\n\t\t\t\tcpu_to_le16(POWER_FLAGS_SKIP_OVER_DTIM_MSK);\n\t\telse\n\t\t\tcmd->flags &=\n\t\t\t\tcpu_to_le16(~POWER_FLAGS_SKIP_OVER_DTIM_MSK);\n\t}\n\tif (mvmvif->dbgfs_pm.mask & MVM_DEBUGFS_PM_RX_DATA_TIMEOUT)\n\t\tcmd->rx_data_timeout =\n\t\t\tcpu_to_le32(mvmvif->dbgfs_pm.rx_data_timeout);\n\tif (mvmvif->dbgfs_pm.mask & MVM_DEBUGFS_PM_TX_DATA_TIMEOUT)\n\t\tcmd->tx_data_timeout =\n\t\t\tcpu_to_le32(mvmvif->dbgfs_pm.tx_data_timeout);\n\tif (mvmvif->dbgfs_pm.mask & MVM_DEBUGFS_PM_SKIP_DTIM_PERIODS)\n\t\tcmd->skip_dtim_periods = mvmvif->dbgfs_pm.skip_dtim_periods;\n\tif (mvmvif->dbgfs_pm.mask & MVM_DEBUGFS_PM_LPRX_ENA) {\n\t\tif (mvmvif->dbgfs_pm.lprx_ena)\n\t\t\tcmd->flags |= cpu_to_le16(POWER_FLAGS_LPRX_ENA_MSK);\n\t\telse\n\t\t\tcmd->flags &= cpu_to_le16(~POWER_FLAGS_LPRX_ENA_MSK);\n\t}\n\tif (mvmvif->dbgfs_pm.mask & MVM_DEBUGFS_PM_LPRX_RSSI_THRESHOLD)\n\t\tcmd->lprx_rssi_threshold = mvmvif->dbgfs_pm.lprx_rssi_threshold;\n\tif (mvmvif->dbgfs_pm.mask & MVM_DEBUGFS_PM_SNOOZE_ENABLE) {\n\t\tif (mvmvif->dbgfs_pm.snooze_ena)\n\t\t\tcmd->flags |=\n\t\t\t\tcpu_to_le16(POWER_FLAGS_SNOOZE_ENA_MSK);\n\t\telse\n\t\t\tcmd->flags &=\n\t\t\t\tcpu_to_le16(~POWER_FLAGS_SNOOZE_ENA_MSK);\n\t}\n\tif (mvmvif->dbgfs_pm.mask & MVM_DEBUGFS_PM_UAPSD_MISBEHAVING) {\n\t\tu16 flag = POWER_FLAGS_UAPSD_MISBEHAVING_ENA_MSK;\n\t\tif (mvmvif->dbgfs_pm.uapsd_misbehaving)\n\t\t\tcmd->flags |= cpu_to_le16(flag);\n\t\telse\n\t\t\tcmd->flags &= cpu_to_le16(flag);\n\t}\n#endif  \n}\n\nstatic int iwl_mvm_power_send_cmd(struct iwl_mvm *mvm,\n\t\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct iwl_mac_power_cmd cmd = {};\n\n\tiwl_mvm_power_build_cmd(mvm, vif, &cmd);\n\tiwl_mvm_power_log(mvm, &cmd);\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tmemcpy(&iwl_mvm_vif_from_mac80211(vif)->mac_pwr_cmd, &cmd, sizeof(cmd));\n#endif\n\n\treturn iwl_mvm_send_cmd_pdu(mvm, MAC_PM_POWER_TABLE, 0,\n\t\t\t\t    sizeof(cmd), &cmd);\n}\n\nint iwl_mvm_power_update_device(struct iwl_mvm *mvm)\n{\n\tstruct iwl_device_power_cmd cmd = {\n\t\t.flags = 0,\n\t};\n\n\tif (iwlmvm_mod_params.power_scheme == IWL_POWER_SCHEME_CAM)\n\t\tmvm->ps_disabled = true;\n\n\tif (!mvm->ps_disabled)\n\t\tcmd.flags |= cpu_to_le16(DEVICE_POWER_FLAGS_POWER_SAVE_ENA_MSK);\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tif (test_bit(IWL_MVM_STATUS_IN_D3, &mvm->status) ?\n\t\t\tmvm->disable_power_off_d3 : mvm->disable_power_off)\n\t\tcmd.flags &=\n\t\t\tcpu_to_le16(~DEVICE_POWER_FLAGS_POWER_SAVE_ENA_MSK);\n#endif\n\tif (mvm->ext_clock_valid)\n\t\tcmd.flags |= cpu_to_le16(DEVICE_POWER_FLAGS_32K_CLK_VALID_MSK);\n\n\tIWL_DEBUG_POWER(mvm,\n\t\t\t\"Sending device power command with flags = 0x%X\\n\",\n\t\t\tcmd.flags);\n\n\treturn iwl_mvm_send_cmd_pdu(mvm, POWER_TABLE_CMD, 0, sizeof(cmd),\n\t\t\t\t    &cmd);\n}\n\nvoid iwl_mvm_power_vif_assoc(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tif (!ether_addr_equal(mvmvif->uapsd_misbehaving_ap_addr,\n\t\t\t      vif->cfg.ap_addr))\n\t\teth_zero_addr(mvmvif->uapsd_misbehaving_ap_addr);\n}\n\nstatic void iwl_mvm_power_uapsd_misbehav_ap_iterator(void *_data, u8 *mac,\n\t\t\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tu8 *ap_sta_id = _data;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct ieee80211_bss_conf *link_conf;\n\tunsigned int link_id;\n\n\trcu_read_lock();\n\tfor_each_vif_active_link(vif, link_conf, link_id) {\n\t\tstruct iwl_mvm_vif_link_info *link_info = mvmvif->link[link_id];\n\n\t\t \n\t\tif (link_info->ap_sta_id == *ap_sta_id) {\n\t\t\tether_addr_copy(mvmvif->uapsd_misbehaving_ap_addr,\n\t\t\t\t\tvif->cfg.ap_addr);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\nvoid iwl_mvm_power_uapsd_misbehaving_ap_notif(struct iwl_mvm *mvm,\n\t\t\t\t\t      struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_uapsd_misbehaving_ap_notif *notif = (void *)pkt->data;\n\tu8 ap_sta_id = le32_to_cpu(notif->sta_id);\n\n\tieee80211_iterate_active_interfaces_atomic(\n\t\tmvm->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\tiwl_mvm_power_uapsd_misbehav_ap_iterator, &ap_sta_id);\n}\n\nstruct iwl_power_vifs {\n\tstruct iwl_mvm *mvm;\n\tstruct ieee80211_vif *bss_vif;\n\tstruct ieee80211_vif *p2p_vif;\n\tstruct ieee80211_vif *ap_vif;\n\tstruct ieee80211_vif *monitor_vif;\n\tbool p2p_active;\n\tbool bss_active;\n\tbool ap_active;\n\tbool monitor_active;\n};\n\nstatic void iwl_mvm_power_disable_pm_iterator(void *_data, u8* mac,\n\t\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tmvmvif->pm_enabled = false;\n}\n\nstatic void iwl_mvm_power_ps_disabled_iterator(void *_data, u8* mac,\n\t\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tbool *disable_ps = _data;\n\n\tif (iwl_mvm_vif_is_active(mvmvif))\n\t\t*disable_ps |= mvmvif->ps_disabled;\n}\n\nstatic void iwl_mvm_power_get_vifs_iterator(void *_data, u8 *mac,\n\t\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_power_vifs *power_iterator = _data;\n\tbool active;\n\n\tif (!mvmvif->uploaded)\n\t\treturn;\n\n\tactive = iwl_mvm_vif_is_active(mvmvif);\n\n\tswitch (ieee80211_vif_type_p2p(vif)) {\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tbreak;\n\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_AP:\n\t\t \n\t\tWARN_ON(power_iterator->ap_vif);\n\t\tpower_iterator->ap_vif = vif;\n\t\tif (active)\n\t\t\tpower_iterator->ap_active = true;\n\t\tbreak;\n\n\tcase NL80211_IFTYPE_MONITOR:\n\t\t \n\t\tWARN_ON(power_iterator->monitor_vif);\n\t\tpower_iterator->monitor_vif = vif;\n\t\tif (active)\n\t\t\tpower_iterator->monitor_active = true;\n\t\tbreak;\n\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\t \n\t\tWARN_ON(power_iterator->p2p_vif);\n\t\tpower_iterator->p2p_vif = vif;\n\t\tif (active)\n\t\t\tpower_iterator->p2p_active = true;\n\t\tbreak;\n\n\tcase NL80211_IFTYPE_STATION:\n\t\tpower_iterator->bss_vif = vif;\n\t\tif (active)\n\t\t\tpower_iterator->bss_active = true;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void iwl_mvm_power_set_pm(struct iwl_mvm *mvm,\n\t\t\t\t struct iwl_power_vifs *vifs)\n{\n\tstruct iwl_mvm_vif *bss_mvmvif = NULL;\n\tstruct iwl_mvm_vif *p2p_mvmvif = NULL;\n\tstruct iwl_mvm_vif *ap_mvmvif = NULL;\n\tbool client_same_channel = false;\n\tbool ap_same_channel = false;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\t \n\tieee80211_iterate_active_interfaces_atomic(mvm->hw,\n\t\t\t\t\tIEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\tiwl_mvm_power_disable_pm_iterator,\n\t\t\t\t\tNULL);\n\n\tif (vifs->bss_vif)\n\t\tbss_mvmvif = iwl_mvm_vif_from_mac80211(vifs->bss_vif);\n\n\tif (vifs->p2p_vif)\n\t\tp2p_mvmvif = iwl_mvm_vif_from_mac80211(vifs->p2p_vif);\n\n\tif (vifs->ap_vif)\n\t\tap_mvmvif = iwl_mvm_vif_from_mac80211(vifs->ap_vif);\n\n\t \n\tif (iwl_mvm_tdls_sta_count(mvm, NULL))\n\t\treturn;\n\n\t \n\tif (bss_mvmvif && vifs->bss_active && !vifs->p2p_active &&\n\t    !vifs->ap_active) {\n\t\tbss_mvmvif->pm_enabled = true;\n\t\treturn;\n\t}\n\n\t \n\tif (p2p_mvmvif && vifs->p2p_active && !vifs->bss_active &&\n\t    !vifs->ap_active) {\n\t\tp2p_mvmvif->pm_enabled = true;\n\t\treturn;\n\t}\n\n\tif (p2p_mvmvif && bss_mvmvif && vifs->bss_active && vifs->p2p_active)\n\t\tclient_same_channel =\n\t\t\tiwl_mvm_have_links_same_channel(bss_mvmvif, p2p_mvmvif);\n\n\tif (bss_mvmvif && ap_mvmvif && vifs->bss_active && vifs->ap_active)\n\t\tap_same_channel =\n\t\t\tiwl_mvm_have_links_same_channel(bss_mvmvif, ap_mvmvif);\n\n\t \n\tif (!(client_same_channel || ap_same_channel)) {\n\t\tif (bss_mvmvif && vifs->bss_active)\n\t\t\tbss_mvmvif->pm_enabled = true;\n\t\tif (p2p_mvmvif && vifs->p2p_active)\n\t\t\tp2p_mvmvif->pm_enabled = true;\n\t\treturn;\n\t}\n\n\t \n\tif (client_same_channel && !vifs->ap_active) {\n\t\t \n\t\tbss_mvmvif->pm_enabled = true;\n\t\tp2p_mvmvif->pm_enabled = true;\n\t}\n}\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\nint iwl_mvm_power_mac_dbgfs_read(struct iwl_mvm *mvm,\n\t\t\t\t struct ieee80211_vif *vif, char *buf,\n\t\t\t\t int bufsz)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mac_power_cmd cmd = {};\n\tint pos = 0;\n\n\tmutex_lock(&mvm->mutex);\n\tmemcpy(&cmd, &mvmvif->mac_pwr_cmd, sizeof(cmd));\n\tmutex_unlock(&mvm->mutex);\n\n\tpos += scnprintf(buf+pos, bufsz-pos, \"power_scheme = %d\\n\",\n\t\t\t iwlmvm_mod_params.power_scheme);\n\tpos += scnprintf(buf+pos, bufsz-pos, \"flags = 0x%x\\n\",\n\t\t\t le16_to_cpu(cmd.flags));\n\tpos += scnprintf(buf+pos, bufsz-pos, \"keep_alive = %d\\n\",\n\t\t\t le16_to_cpu(cmd.keep_alive_seconds));\n\n\tif (!(cmd.flags & cpu_to_le16(POWER_FLAGS_POWER_MANAGEMENT_ENA_MSK)))\n\t\treturn pos;\n\n\tpos += scnprintf(buf+pos, bufsz-pos, \"skip_over_dtim = %d\\n\",\n\t\t\t (cmd.flags &\n\t\t\t cpu_to_le16(POWER_FLAGS_SKIP_OVER_DTIM_MSK)) ? 1 : 0);\n\tpos += scnprintf(buf+pos, bufsz-pos, \"skip_dtim_periods = %d\\n\",\n\t\t\t cmd.skip_dtim_periods);\n\tif (!(cmd.flags & cpu_to_le16(POWER_FLAGS_ADVANCE_PM_ENA_MSK))) {\n\t\tpos += scnprintf(buf+pos, bufsz-pos, \"rx_data_timeout = %d\\n\",\n\t\t\t\t le32_to_cpu(cmd.rx_data_timeout));\n\t\tpos += scnprintf(buf+pos, bufsz-pos, \"tx_data_timeout = %d\\n\",\n\t\t\t\t le32_to_cpu(cmd.tx_data_timeout));\n\t}\n\tif (cmd.flags & cpu_to_le16(POWER_FLAGS_LPRX_ENA_MSK))\n\t\tpos += scnprintf(buf+pos, bufsz-pos,\n\t\t\t\t \"lprx_rssi_threshold = %d\\n\",\n\t\t\t\t cmd.lprx_rssi_threshold);\n\n\tif (!(cmd.flags & cpu_to_le16(POWER_FLAGS_ADVANCE_PM_ENA_MSK)))\n\t\treturn pos;\n\n\tpos += scnprintf(buf+pos, bufsz-pos, \"rx_data_timeout_uapsd = %d\\n\",\n\t\t\t le32_to_cpu(cmd.rx_data_timeout_uapsd));\n\tpos += scnprintf(buf+pos, bufsz-pos, \"tx_data_timeout_uapsd = %d\\n\",\n\t\t\t le32_to_cpu(cmd.tx_data_timeout_uapsd));\n\tpos += scnprintf(buf+pos, bufsz-pos, \"qndp_tid = %d\\n\", cmd.qndp_tid);\n\tpos += scnprintf(buf+pos, bufsz-pos, \"uapsd_ac_flags = 0x%x\\n\",\n\t\t\t cmd.uapsd_ac_flags);\n\tpos += scnprintf(buf+pos, bufsz-pos, \"uapsd_max_sp = %d\\n\",\n\t\t\t cmd.uapsd_max_sp);\n\tpos += scnprintf(buf+pos, bufsz-pos, \"heavy_tx_thld_packets = %d\\n\",\n\t\t\t cmd.heavy_tx_thld_packets);\n\tpos += scnprintf(buf+pos, bufsz-pos, \"heavy_rx_thld_packets = %d\\n\",\n\t\t\t cmd.heavy_rx_thld_packets);\n\tpos += scnprintf(buf+pos, bufsz-pos, \"heavy_tx_thld_percentage = %d\\n\",\n\t\t\t cmd.heavy_tx_thld_percentage);\n\tpos += scnprintf(buf+pos, bufsz-pos, \"heavy_rx_thld_percentage = %d\\n\",\n\t\t\t cmd.heavy_rx_thld_percentage);\n\tpos += scnprintf(buf+pos, bufsz-pos, \"uapsd_misbehaving_enable = %d\\n\",\n\t\t\t (cmd.flags &\n\t\t\t  cpu_to_le16(POWER_FLAGS_UAPSD_MISBEHAVING_ENA_MSK)) ?\n\t\t\t 1 : 0);\n\n\tif (!(cmd.flags & cpu_to_le16(POWER_FLAGS_SNOOZE_ENA_MSK)))\n\t\treturn pos;\n\n\tpos += scnprintf(buf+pos, bufsz-pos, \"snooze_interval = %d\\n\",\n\t\t\t cmd.snooze_interval);\n\tpos += scnprintf(buf+pos, bufsz-pos, \"snooze_window = %d\\n\",\n\t\t\t cmd.snooze_window);\n\n\treturn pos;\n}\n\nvoid\niwl_mvm_beacon_filter_debugfs_parameters(struct ieee80211_vif *vif,\n\t\t\t\t\t struct iwl_beacon_filter_cmd *cmd)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_dbgfs_bf *dbgfs_bf = &mvmvif->dbgfs_bf;\n\n\tif (dbgfs_bf->mask & MVM_DEBUGFS_BF_ENERGY_DELTA)\n\t\tcmd->bf_energy_delta = cpu_to_le32(dbgfs_bf->bf_energy_delta);\n\tif (dbgfs_bf->mask & MVM_DEBUGFS_BF_ROAMING_ENERGY_DELTA)\n\t\tcmd->bf_roaming_energy_delta =\n\t\t\t\tcpu_to_le32(dbgfs_bf->bf_roaming_energy_delta);\n\tif (dbgfs_bf->mask & MVM_DEBUGFS_BF_ROAMING_STATE)\n\t\tcmd->bf_roaming_state = cpu_to_le32(dbgfs_bf->bf_roaming_state);\n\tif (dbgfs_bf->mask & MVM_DEBUGFS_BF_TEMP_THRESHOLD)\n\t\tcmd->bf_temp_threshold =\n\t\t\t\tcpu_to_le32(dbgfs_bf->bf_temp_threshold);\n\tif (dbgfs_bf->mask & MVM_DEBUGFS_BF_TEMP_FAST_FILTER)\n\t\tcmd->bf_temp_fast_filter =\n\t\t\t\tcpu_to_le32(dbgfs_bf->bf_temp_fast_filter);\n\tif (dbgfs_bf->mask & MVM_DEBUGFS_BF_TEMP_SLOW_FILTER)\n\t\tcmd->bf_temp_slow_filter =\n\t\t\t\tcpu_to_le32(dbgfs_bf->bf_temp_slow_filter);\n\tif (dbgfs_bf->mask & MVM_DEBUGFS_BF_DEBUG_FLAG)\n\t\tcmd->bf_debug_flag = cpu_to_le32(dbgfs_bf->bf_debug_flag);\n\tif (dbgfs_bf->mask & MVM_DEBUGFS_BF_ESCAPE_TIMER)\n\t\tcmd->bf_escape_timer = cpu_to_le32(dbgfs_bf->bf_escape_timer);\n\tif (dbgfs_bf->mask & MVM_DEBUGFS_BA_ESCAPE_TIMER)\n\t\tcmd->ba_escape_timer = cpu_to_le32(dbgfs_bf->ba_escape_timer);\n\tif (dbgfs_bf->mask & MVM_DEBUGFS_BA_ENABLE_BEACON_ABORT)\n\t\tcmd->ba_enable_beacon_abort =\n\t\t\t\tcpu_to_le32(dbgfs_bf->ba_enable_beacon_abort);\n}\n#endif\n\nstatic int _iwl_mvm_enable_beacon_filter(struct iwl_mvm *mvm,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t struct iwl_beacon_filter_cmd *cmd,\n\t\t\t\t\t u32 cmd_flags)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tint ret;\n\n\tif (mvmvif != mvm->bf_allowed_vif || !vif->bss_conf.dtim_period ||\n\t    vif->type != NL80211_IFTYPE_STATION || vif->p2p)\n\t\treturn 0;\n\n\tiwl_mvm_beacon_filter_set_cqm_params(mvm, vif, cmd);\n\tiwl_mvm_beacon_filter_debugfs_parameters(vif, cmd);\n\tret = iwl_mvm_beacon_filter_send_cmd(mvm, cmd, cmd_flags);\n\n\tif (!ret)\n\t\tmvmvif->bf_data.bf_enabled = true;\n\n\treturn ret;\n}\n\nint iwl_mvm_enable_beacon_filter(struct iwl_mvm *mvm,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t u32 flags)\n{\n\tstruct iwl_beacon_filter_cmd cmd = {\n\t\tIWL_BF_CMD_CONFIG_DEFAULTS,\n\t\t.bf_enable_beacon_filter = cpu_to_le32(1),\n\t};\n\n\treturn _iwl_mvm_enable_beacon_filter(mvm, vif, &cmd, flags);\n}\n\nstatic int _iwl_mvm_disable_beacon_filter(struct iwl_mvm *mvm,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  u32 flags)\n{\n\tstruct iwl_beacon_filter_cmd cmd = {};\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tint ret;\n\n\tif (vif->type != NL80211_IFTYPE_STATION || vif->p2p)\n\t\treturn 0;\n\n\tret = iwl_mvm_beacon_filter_send_cmd(mvm, &cmd, flags);\n\n\tif (!ret)\n\t\tmvmvif->bf_data.bf_enabled = false;\n\n\treturn ret;\n}\n\nint iwl_mvm_disable_beacon_filter(struct iwl_mvm *mvm,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  u32 flags)\n{\n\treturn _iwl_mvm_disable_beacon_filter(mvm, vif, flags);\n}\n\nstatic int iwl_mvm_power_set_ps(struct iwl_mvm *mvm)\n{\n\tbool disable_ps;\n\tint ret;\n\n\t \n\tdisable_ps = (iwlmvm_mod_params.power_scheme == IWL_POWER_SCHEME_CAM);\n\t \n\tieee80211_iterate_active_interfaces_atomic(mvm->hw,\n\t\t\t\t\tIEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\tiwl_mvm_power_ps_disabled_iterator,\n\t\t\t\t\t&disable_ps);\n\n\t \n\tif (mvm->ps_disabled != disable_ps) {\n\t\tbool old_ps_disabled = mvm->ps_disabled;\n\n\t\tmvm->ps_disabled = disable_ps;\n\t\tret = iwl_mvm_power_update_device(mvm);\n\t\tif (ret) {\n\t\t\tmvm->ps_disabled = old_ps_disabled;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int iwl_mvm_power_set_ba(struct iwl_mvm *mvm,\n\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_beacon_filter_cmd cmd = {\n\t\tIWL_BF_CMD_CONFIG_DEFAULTS,\n\t\t.bf_enable_beacon_filter = cpu_to_le32(1),\n\t};\n\n\tif (!mvmvif->bf_data.bf_enabled)\n\t\treturn 0;\n\n\tif (test_bit(IWL_MVM_STATUS_IN_D3, &mvm->status))\n\t\tcmd.ba_escape_timer = cpu_to_le32(IWL_BA_ESCAPE_TIMER_D3);\n\n\tmvmvif->bf_data.ba_enabled = !(!mvmvif->pm_enabled ||\n\t\t\t\t       mvm->ps_disabled ||\n\t\t\t\t       !vif->cfg.ps ||\n\t\t\t\t       iwl_mvm_vif_low_latency(mvmvif));\n\n\treturn _iwl_mvm_enable_beacon_filter(mvm, vif, &cmd, 0);\n}\n\nint iwl_mvm_power_update_ps(struct iwl_mvm *mvm)\n{\n\tstruct iwl_power_vifs vifs = {\n\t\t.mvm = mvm,\n\t};\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\t \n\tieee80211_iterate_active_interfaces_atomic(mvm->hw,\n\t\t\t\t\tIEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\tiwl_mvm_power_get_vifs_iterator, &vifs);\n\n\tret = iwl_mvm_power_set_ps(mvm);\n\tif (ret)\n\t\treturn ret;\n\n\tif (vifs.bss_vif)\n\t\treturn iwl_mvm_power_set_ba(mvm, vifs.bss_vif);\n\n\treturn 0;\n}\n\nint iwl_mvm_power_update_mac(struct iwl_mvm *mvm)\n{\n\tstruct iwl_power_vifs vifs = {\n\t\t.mvm = mvm,\n\t};\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\t \n\tieee80211_iterate_active_interfaces_atomic(mvm->hw,\n\t\t\t\t\tIEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\tiwl_mvm_power_get_vifs_iterator, &vifs);\n\n\tiwl_mvm_power_set_pm(mvm, &vifs);\n\n\tret = iwl_mvm_power_set_ps(mvm);\n\tif (ret)\n\t\treturn ret;\n\n\tif (vifs.bss_vif) {\n\t\tret = iwl_mvm_power_send_cmd(mvm, vifs.bss_vif);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (vifs.p2p_vif) {\n\t\tret = iwl_mvm_power_send_cmd(mvm, vifs.p2p_vif);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (vifs.bss_vif)\n\t\treturn iwl_mvm_power_set_ba(mvm, vifs.bss_vif);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}