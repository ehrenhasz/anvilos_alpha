{
  "module_name": "led.c",
  "hash_id": "6b4e3015662e8086b597fa9408375296c425e8941c6b78b7e1a44f7eaf66691c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/led.c",
  "human_readable_source": "\n \n#include <linux/leds.h>\n#include \"iwl-io.h\"\n#include \"iwl-csr.h\"\n#include \"mvm.h\"\n\nstatic void iwl_mvm_send_led_fw_cmd(struct iwl_mvm *mvm, bool on)\n{\n\tstruct iwl_led_cmd led_cmd = {\n\t\t.status = cpu_to_le32(on),\n\t};\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = WIDE_ID(LONG_GROUP, LEDS_CMD),\n\t\t.len = { sizeof(led_cmd), },\n\t\t.data = { &led_cmd, },\n\t\t.flags = CMD_ASYNC,\n\t};\n\tint err;\n\n\tif (!iwl_mvm_firmware_running(mvm))\n\t\treturn;\n\n\terr = iwl_mvm_send_cmd(mvm, &cmd);\n\n\tif (err)\n\t\tIWL_WARN(mvm, \"LED command failed: %d\\n\", err);\n}\n\nstatic void iwl_mvm_led_set(struct iwl_mvm *mvm, bool on)\n{\n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_LED_CMD_SUPPORT)) {\n\t\tiwl_mvm_send_led_fw_cmd(mvm, on);\n\t\treturn;\n\t}\n\n\tiwl_write32(mvm->trans, CSR_LED_REG,\n\t\t    on ? CSR_LED_REG_TURN_ON : CSR_LED_REG_TURN_OFF);\n}\n\nstatic void iwl_led_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t   enum led_brightness brightness)\n{\n\tstruct iwl_mvm *mvm = container_of(led_cdev, struct iwl_mvm, led);\n\n\tiwl_mvm_led_set(mvm, brightness > 0);\n}\n\nint iwl_mvm_leds_init(struct iwl_mvm *mvm)\n{\n\tint mode = iwlwifi_mod_params.led_mode;\n\tint ret;\n\n\tswitch (mode) {\n\tcase IWL_LED_BLINK:\n\t\tIWL_ERR(mvm, \"Blink led mode not supported, used default\\n\");\n\t\tfallthrough;\n\tcase IWL_LED_DEFAULT:\n\tcase IWL_LED_RF_STATE:\n\t\tmode = IWL_LED_RF_STATE;\n\t\tbreak;\n\tcase IWL_LED_DISABLE:\n\t\tIWL_INFO(mvm, \"Led disabled\\n\");\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmvm->led.name = kasprintf(GFP_KERNEL, \"%s-led\",\n\t\t\t\t   wiphy_name(mvm->hw->wiphy));\n\tif (!mvm->led.name)\n\t\treturn -ENOMEM;\n\n\tmvm->led.brightness_set = iwl_led_brightness_set;\n\tmvm->led.max_brightness = 1;\n\n\tif (mode == IWL_LED_RF_STATE)\n\t\tmvm->led.default_trigger =\n\t\t\tieee80211_get_radio_led_name(mvm->hw);\n\n\tret = led_classdev_register(mvm->trans->dev, &mvm->led);\n\tif (ret) {\n\t\tkfree(mvm->led.name);\n\t\tIWL_INFO(mvm, \"Failed to enable led\\n\");\n\t\treturn ret;\n\t}\n\n\tmvm->init_status |= IWL_MVM_INIT_STATUS_LEDS_INIT_COMPLETE;\n\treturn 0;\n}\n\nvoid iwl_mvm_leds_sync(struct iwl_mvm *mvm)\n{\n\tif (!(mvm->init_status & IWL_MVM_INIT_STATUS_LEDS_INIT_COMPLETE))\n\t\treturn;\n\n\t \n\tif (mvm->trans->trans_cfg->device_family < IWL_DEVICE_FAMILY_8000)\n\t\treturn;\n\n\tiwl_mvm_led_set(mvm, mvm->led.brightness > 0);\n}\n\nvoid iwl_mvm_leds_exit(struct iwl_mvm *mvm)\n{\n\tif (!(mvm->init_status & IWL_MVM_INIT_STATUS_LEDS_INIT_COMPLETE))\n\t\treturn;\n\n\tled_classdev_unregister(&mvm->led);\n\tkfree(mvm->led.name);\n\tmvm->init_status &= ~IWL_MVM_INIT_STATUS_LEDS_INIT_COMPLETE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}