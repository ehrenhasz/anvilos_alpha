{
  "module_name": "scan.c",
  "hash_id": "960e87a9022809ae318a6743fa0cd0a59badb17faa19f6df1b05ceb64634ec82",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/scan.c",
  "human_readable_source": "\n \n#include <linux/etherdevice.h>\n#include <net/mac80211.h>\n#include <linux/crc32.h>\n\n#include \"mvm.h\"\n#include \"fw/api/scan.h\"\n#include \"iwl-io.h\"\n\n#define IWL_DENSE_EBS_SCAN_RATIO 5\n#define IWL_SPARSE_EBS_SCAN_RATIO 1\n\n#define IWL_SCAN_DWELL_ACTIVE\t\t10\n#define IWL_SCAN_DWELL_PASSIVE\t\t110\n#define IWL_SCAN_DWELL_FRAGMENTED\t44\n#define IWL_SCAN_DWELL_EXTENDED\t\t90\n#define IWL_SCAN_NUM_OF_FRAGS\t\t3\n\n \n#define IWL_SCAN_ADWELL_MAX_BUDGET_FULL_SCAN 300\n \n#define IWL_SCAN_ADWELL_MAX_BUDGET_DIRECTED_SCAN 100\n \n#define IWL_SCAN_ADWELL_DEFAULT_HB_N_APS 8\n \n#define IWL_SCAN_ADWELL_DEFAULT_LB_N_APS 2\n \n#define IWL_SCAN_ADWELL_DEFAULT_N_APS_SOCIAL 10\n \n#define IWL_SCAN_NUM_CHANNELS 112\n \n#define IWL_SCAN_ADWELL_N_APS_GO_FRIENDLY_BIT BIT(20)\n \n#define IWL_SCAN_ADWELL_N_APS_SOCIAL_CHS_BIT BIT(21)\n \n#define IWL_SCAN_ADWELL_N_APS_GO_FRIENDLY 10\n \n#define IWL_SCAN_ADWELL_N_APS_SOCIAL_CHS 2\n\n \n#define IWL_MVM_6GHZ_PASSIVE_SCAN_MIN_CHANS 4\n\n \n#define IWL_MEI_SCAN_NUM_ITER\t5U\n\nstruct iwl_mvm_scan_timing_params {\n\tu32 suspend_time;\n\tu32 max_out_time;\n};\n\nstatic struct iwl_mvm_scan_timing_params scan_timing[] = {\n\t[IWL_SCAN_TYPE_UNASSOC] = {\n\t\t.suspend_time = 0,\n\t\t.max_out_time = 0,\n\t},\n\t[IWL_SCAN_TYPE_WILD] = {\n\t\t.suspend_time = 30,\n\t\t.max_out_time = 120,\n\t},\n\t[IWL_SCAN_TYPE_MILD] = {\n\t\t.suspend_time = 120,\n\t\t.max_out_time = 120,\n\t},\n\t[IWL_SCAN_TYPE_FRAGMENTED] = {\n\t\t.suspend_time = 95,\n\t\t.max_out_time = 44,\n\t},\n\t[IWL_SCAN_TYPE_FAST_BALANCE] = {\n\t\t.suspend_time = 30,\n\t\t.max_out_time = 37,\n\t},\n};\n\nstruct iwl_mvm_scan_params {\n\t \n\tenum iwl_mvm_scan_type type;\n\tenum iwl_mvm_scan_type hb_type;\n\tu32 n_channels;\n\tu16 delay;\n\tint n_ssids;\n\tstruct cfg80211_ssid *ssids;\n\tstruct ieee80211_channel **channels;\n\tu32 flags;\n\tu8 *mac_addr;\n\tu8 *mac_addr_mask;\n\tbool no_cck;\n\tbool pass_all;\n\tint n_match_sets;\n\tstruct iwl_scan_probe_req preq;\n\tstruct cfg80211_match_set *match_sets;\n\tint n_scan_plans;\n\tstruct cfg80211_sched_scan_plan *scan_plans;\n\tbool iter_notif;\n\tstruct cfg80211_scan_6ghz_params *scan_6ghz_params;\n\tu32 n_6ghz_params;\n\tbool scan_6ghz;\n\tbool enable_6ghz_passive;\n\tbool respect_p2p_go, respect_p2p_go_hb;\n\tu8 bssid[ETH_ALEN] __aligned(2);\n};\n\nstatic inline void *iwl_mvm_get_scan_req_umac_data(struct iwl_mvm *mvm)\n{\n\tstruct iwl_scan_req_umac *cmd = mvm->scan_cmd;\n\n\tif (iwl_mvm_is_adaptive_dwell_v2_supported(mvm))\n\t\treturn (void *)&cmd->v8.data;\n\n\tif (iwl_mvm_is_adaptive_dwell_supported(mvm))\n\t\treturn (void *)&cmd->v7.data;\n\n\tif (iwl_mvm_cdb_scan_api(mvm))\n\t\treturn (void *)&cmd->v6.data;\n\n\treturn (void *)&cmd->v1.data;\n}\n\nstatic inline struct iwl_scan_umac_chan_param *\niwl_mvm_get_scan_req_umac_channel(struct iwl_mvm *mvm)\n{\n\tstruct iwl_scan_req_umac *cmd = mvm->scan_cmd;\n\n\tif (iwl_mvm_is_adaptive_dwell_v2_supported(mvm))\n\t\treturn &cmd->v8.channel;\n\n\tif (iwl_mvm_is_adaptive_dwell_supported(mvm))\n\t\treturn &cmd->v7.channel;\n\n\tif (iwl_mvm_cdb_scan_api(mvm))\n\t\treturn &cmd->v6.channel;\n\n\treturn &cmd->v1.channel;\n}\n\nstatic u8 iwl_mvm_scan_rx_ant(struct iwl_mvm *mvm)\n{\n\tif (mvm->scan_rx_ant != ANT_NONE)\n\t\treturn mvm->scan_rx_ant;\n\treturn iwl_mvm_get_valid_rx_ant(mvm);\n}\n\nstatic inline __le16 iwl_mvm_scan_rx_chain(struct iwl_mvm *mvm)\n{\n\tu16 rx_chain;\n\tu8 rx_ant;\n\n\trx_ant = iwl_mvm_scan_rx_ant(mvm);\n\trx_chain = rx_ant << PHY_RX_CHAIN_VALID_POS;\n\trx_chain |= rx_ant << PHY_RX_CHAIN_FORCE_MIMO_SEL_POS;\n\trx_chain |= rx_ant << PHY_RX_CHAIN_FORCE_SEL_POS;\n\trx_chain |= 0x1 << PHY_RX_CHAIN_DRIVER_FORCE_POS;\n\treturn cpu_to_le16(rx_chain);\n}\n\nstatic inline __le32\niwl_mvm_scan_rate_n_flags(struct iwl_mvm *mvm, enum nl80211_band band,\n\t\t\t  bool no_cck)\n{\n\tu32 tx_ant;\n\n\tiwl_mvm_toggle_tx_ant(mvm, &mvm->scan_last_antenna_idx);\n\ttx_ant = BIT(mvm->scan_last_antenna_idx) << RATE_MCS_ANT_POS;\n\n\tif (band == NL80211_BAND_2GHZ && !no_cck)\n\t\treturn cpu_to_le32(IWL_RATE_1M_PLCP | RATE_MCS_CCK_MSK_V1 |\n\t\t\t\t   tx_ant);\n\telse\n\t\treturn cpu_to_le32(IWL_RATE_6M_PLCP | tx_ant);\n}\n\nstatic enum iwl_mvm_traffic_load iwl_mvm_get_traffic_load(struct iwl_mvm *mvm)\n{\n\treturn mvm->tcm.result.global_load;\n}\n\nstatic enum iwl_mvm_traffic_load\niwl_mvm_get_traffic_load_band(struct iwl_mvm *mvm, enum nl80211_band band)\n{\n\treturn mvm->tcm.result.band_load[band];\n}\n\nstruct iwl_mvm_scan_iter_data {\n\tu32 global_cnt;\n\tstruct ieee80211_vif *current_vif;\n\tbool is_dcm_with_p2p_go;\n};\n\nstatic void iwl_mvm_scan_iterator(void *_data, u8 *mac,\n\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_scan_iter_data *data = _data;\n\tstruct iwl_mvm_vif *curr_mvmvif;\n\n\tif (vif->type != NL80211_IFTYPE_P2P_DEVICE &&\n\t    mvmvif->deflink.phy_ctxt &&\n\t    mvmvif->deflink.phy_ctxt->id < NUM_PHY_CTX)\n\t\tdata->global_cnt += 1;\n\n\tif (!data->current_vif || vif == data->current_vif)\n\t\treturn;\n\n\tcurr_mvmvif = iwl_mvm_vif_from_mac80211(data->current_vif);\n\n\tif (vif->type == NL80211_IFTYPE_AP && vif->p2p &&\n\t    mvmvif->deflink.phy_ctxt && curr_mvmvif->deflink.phy_ctxt &&\n\t    mvmvif->deflink.phy_ctxt->id != curr_mvmvif->deflink.phy_ctxt->id)\n\t\tdata->is_dcm_with_p2p_go = true;\n}\n\nstatic enum\niwl_mvm_scan_type _iwl_mvm_get_scan_type(struct iwl_mvm *mvm,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t enum iwl_mvm_traffic_load load,\n\t\t\t\t\t bool low_latency)\n{\n\tstruct iwl_mvm_scan_iter_data data = {\n\t\t.current_vif = vif,\n\t\t.is_dcm_with_p2p_go = false,\n\t\t.global_cnt = 0,\n\t};\n\n\tieee80211_iterate_active_interfaces_atomic(mvm->hw,\n\t\t\t\t\t\t   IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\t\t   iwl_mvm_scan_iterator,\n\t\t\t\t\t\t   &data);\n\n\tif (!data.global_cnt)\n\t\treturn IWL_SCAN_TYPE_UNASSOC;\n\n\tif (fw_has_api(&mvm->fw->ucode_capa,\n\t\t       IWL_UCODE_TLV_API_FRAGMENTED_SCAN)) {\n\t\tif ((load == IWL_MVM_TRAFFIC_HIGH || low_latency) &&\n\t\t    (!vif || vif->type != NL80211_IFTYPE_P2P_DEVICE))\n\t\t\treturn IWL_SCAN_TYPE_FRAGMENTED;\n\n\t\t \n\t\tif (vif && vif->type == NL80211_IFTYPE_STATION &&\n\t\t    data.is_dcm_with_p2p_go &&\n\t\t    ((vif->bss_conf.beacon_int *\n\t\t      vif->bss_conf.dtim_period) < 220))\n\t\t\treturn IWL_SCAN_TYPE_FAST_BALANCE;\n\t}\n\n\tif (load >= IWL_MVM_TRAFFIC_MEDIUM || low_latency)\n\t\treturn IWL_SCAN_TYPE_MILD;\n\n\treturn IWL_SCAN_TYPE_WILD;\n}\n\nstatic enum\niwl_mvm_scan_type iwl_mvm_get_scan_type(struct iwl_mvm *mvm,\n\t\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tenum iwl_mvm_traffic_load load;\n\tbool low_latency;\n\n\tload = iwl_mvm_get_traffic_load(mvm);\n\tlow_latency = iwl_mvm_low_latency(mvm);\n\n\treturn _iwl_mvm_get_scan_type(mvm, vif, load, low_latency);\n}\n\nstatic enum\niwl_mvm_scan_type iwl_mvm_get_scan_type_band(struct iwl_mvm *mvm,\n\t\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t\t     enum nl80211_band band)\n{\n\tenum iwl_mvm_traffic_load load;\n\tbool low_latency;\n\n\tload = iwl_mvm_get_traffic_load_band(mvm, band);\n\tlow_latency = iwl_mvm_low_latency_band(mvm, band);\n\n\treturn _iwl_mvm_get_scan_type(mvm, vif, load, low_latency);\n}\n\nstatic inline bool iwl_mvm_rrm_scan_needed(struct iwl_mvm *mvm)\n{\n\t \n\treturn fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t   IWL_UCODE_TLV_CAPA_DS_PARAM_SET_IE_SUPPORT);\n}\n\nstatic int iwl_mvm_max_scan_ie_fw_cmd_room(struct iwl_mvm *mvm)\n{\n\tint max_probe_len;\n\n\tmax_probe_len = SCAN_OFFLOAD_PROBE_REQ_SIZE;\n\n\t \n\tmax_probe_len -= 24 + 2;\n\n\t \n\tif (iwl_mvm_rrm_scan_needed(mvm))\n\t\tmax_probe_len -= 3;\n\n\treturn max_probe_len;\n}\n\nint iwl_mvm_max_scan_ie_len(struct iwl_mvm *mvm)\n{\n\tint max_ie_len = iwl_mvm_max_scan_ie_fw_cmd_room(mvm);\n\n\t \n\treturn max_ie_len;\n}\n\nvoid iwl_mvm_rx_lmac_scan_iter_complete_notif(struct iwl_mvm *mvm,\n\t\t\t\t\t      struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_lmac_scan_complete_notif *notif = (void *)pkt->data;\n\n\tIWL_DEBUG_SCAN(mvm,\n\t\t       \"Scan offload iteration complete: status=0x%x scanned channels=%d\\n\",\n\t\t       notif->status, notif->scanned_channels);\n\n\tif (mvm->sched_scan_pass_all == SCHED_SCAN_PASS_ALL_FOUND) {\n\t\tIWL_DEBUG_SCAN(mvm, \"Pass all scheduled scan results found\\n\");\n\t\tieee80211_sched_scan_results(mvm->hw);\n\t\tmvm->sched_scan_pass_all = SCHED_SCAN_PASS_ALL_ENABLED;\n\t}\n}\n\nvoid iwl_mvm_rx_scan_match_found(struct iwl_mvm *mvm,\n\t\t\t\t struct iwl_rx_cmd_buffer *rxb)\n{\n\tIWL_DEBUG_SCAN(mvm, \"Scheduled scan results\\n\");\n\tieee80211_sched_scan_results(mvm->hw);\n}\n\nstatic const char *iwl_mvm_ebs_status_str(enum iwl_scan_ebs_status status)\n{\n\tswitch (status) {\n\tcase IWL_SCAN_EBS_SUCCESS:\n\t\treturn \"successful\";\n\tcase IWL_SCAN_EBS_INACTIVE:\n\t\treturn \"inactive\";\n\tcase IWL_SCAN_EBS_FAILED:\n\tcase IWL_SCAN_EBS_CHAN_NOT_FOUND:\n\tdefault:\n\t\treturn \"failed\";\n\t}\n}\n\nvoid iwl_mvm_rx_lmac_scan_complete_notif(struct iwl_mvm *mvm,\n\t\t\t\t\t struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_periodic_scan_complete *scan_notif = (void *)pkt->data;\n\tbool aborted = (scan_notif->status == IWL_SCAN_OFFLOAD_ABORTED);\n\n\t \n\tif (WARN_ON_ONCE(fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t\t     IWL_UCODE_TLV_CAPA_UMAC_SCAN)))\n\t\treturn;\n\n\t \n\tlockdep_assert_held(&mvm->mutex);\n\n\t \n\n\tif (mvm->scan_status & IWL_MVM_SCAN_STOPPING_SCHED) {\n\t\tWARN_ON_ONCE(mvm->scan_status & IWL_MVM_SCAN_STOPPING_REGULAR);\n\n\t\tIWL_DEBUG_SCAN(mvm, \"Scheduled scan %s, EBS status %s\\n\",\n\t\t\t       aborted ? \"aborted\" : \"completed\",\n\t\t\t       iwl_mvm_ebs_status_str(scan_notif->ebs_status));\n\t\tIWL_DEBUG_SCAN(mvm,\n\t\t\t       \"Last line %d, Last iteration %d, Time after last iteration %d\\n\",\n\t\t\t       scan_notif->last_schedule_line,\n\t\t\t       scan_notif->last_schedule_iteration,\n\t\t\t       __le32_to_cpu(scan_notif->time_after_last_iter));\n\n\t\tmvm->scan_status &= ~IWL_MVM_SCAN_STOPPING_SCHED;\n\t} else if (mvm->scan_status & IWL_MVM_SCAN_STOPPING_REGULAR) {\n\t\tIWL_DEBUG_SCAN(mvm, \"Regular scan %s, EBS status %s\\n\",\n\t\t\t       aborted ? \"aborted\" : \"completed\",\n\t\t\t       iwl_mvm_ebs_status_str(scan_notif->ebs_status));\n\n\t\tmvm->scan_status &= ~IWL_MVM_SCAN_STOPPING_REGULAR;\n\t} else if (mvm->scan_status & IWL_MVM_SCAN_SCHED) {\n\t\tWARN_ON_ONCE(mvm->scan_status & IWL_MVM_SCAN_REGULAR);\n\n\t\tIWL_DEBUG_SCAN(mvm, \"Scheduled scan %s, EBS status %s\\n\",\n\t\t\t       aborted ? \"aborted\" : \"completed\",\n\t\t\t       iwl_mvm_ebs_status_str(scan_notif->ebs_status));\n\t\tIWL_DEBUG_SCAN(mvm,\n\t\t\t       \"Last line %d, Last iteration %d, Time after last iteration %d (FW)\\n\",\n\t\t\t       scan_notif->last_schedule_line,\n\t\t\t       scan_notif->last_schedule_iteration,\n\t\t\t       __le32_to_cpu(scan_notif->time_after_last_iter));\n\n\t\tmvm->scan_status &= ~IWL_MVM_SCAN_SCHED;\n\t\tieee80211_sched_scan_stopped(mvm->hw);\n\t\tmvm->sched_scan_pass_all = SCHED_SCAN_PASS_ALL_DISABLED;\n\t} else if (mvm->scan_status & IWL_MVM_SCAN_REGULAR) {\n\t\tstruct cfg80211_scan_info info = {\n\t\t\t.aborted = aborted,\n\t\t};\n\n\t\tIWL_DEBUG_SCAN(mvm, \"Regular scan %s, EBS status %s (FW)\\n\",\n\t\t\t       aborted ? \"aborted\" : \"completed\",\n\t\t\t       iwl_mvm_ebs_status_str(scan_notif->ebs_status));\n\n\t\tmvm->scan_status &= ~IWL_MVM_SCAN_REGULAR;\n\t\tieee80211_scan_completed(mvm->hw, &info);\n\t\tcancel_delayed_work(&mvm->scan_timeout_dwork);\n\t\tiwl_mvm_resume_tcm(mvm);\n\t} else {\n\t\tIWL_ERR(mvm,\n\t\t\t\"got scan complete notification but no scan is running\\n\");\n\t}\n\n\tmvm->last_ebs_successful =\n\t\t\tscan_notif->ebs_status == IWL_SCAN_EBS_SUCCESS ||\n\t\t\tscan_notif->ebs_status == IWL_SCAN_EBS_INACTIVE;\n}\n\nstatic int iwl_ssid_exist(u8 *ssid, u8 ssid_len, struct iwl_ssid_ie *ssid_list)\n{\n\tint i;\n\n\tfor (i = 0; i < PROBE_OPTION_MAX; i++) {\n\t\tif (!ssid_list[i].len)\n\t\t\tbreak;\n\t\tif (ssid_list[i].len == ssid_len &&\n\t\t    !memcmp(ssid_list->ssid, ssid, ssid_len))\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\n \nstatic void iwl_scan_build_ssids(struct iwl_mvm_scan_params *params,\n\t\t\t\t struct iwl_ssid_ie *ssids,\n\t\t\t\t u32 *ssid_bitmap)\n{\n\tint i, j;\n\tint index;\n\tu32 tmp_bitmap = 0;\n\n\t \n\tfor (i = 0, j = params->n_match_sets - 1;\n\t     j >= 0 && i < PROBE_OPTION_MAX;\n\t     i++, j--) {\n\t\t \n\t\tif (!params->match_sets[j].ssid.ssid_len)\n\t\t\tcontinue;\n\t\tssids[i].id = WLAN_EID_SSID;\n\t\tssids[i].len = params->match_sets[j].ssid.ssid_len;\n\t\tmemcpy(ssids[i].ssid, params->match_sets[j].ssid.ssid,\n\t\t       ssids[i].len);\n\t}\n\n\t \n\tfor (j = params->n_ssids - 1;\n\t     j >= 0 && i < PROBE_OPTION_MAX;\n\t     i++, j--) {\n\t\tindex = iwl_ssid_exist(params->ssids[j].ssid,\n\t\t\t\t       params->ssids[j].ssid_len,\n\t\t\t\t       ssids);\n\t\tif (index < 0) {\n\t\t\tssids[i].id = WLAN_EID_SSID;\n\t\t\tssids[i].len = params->ssids[j].ssid_len;\n\t\t\tmemcpy(ssids[i].ssid, params->ssids[j].ssid,\n\t\t\t       ssids[i].len);\n\t\t\ttmp_bitmap |= BIT(i);\n\t\t} else {\n\t\t\ttmp_bitmap |= BIT(index);\n\t\t}\n\t}\n\tif (ssid_bitmap)\n\t\t*ssid_bitmap = tmp_bitmap;\n}\n\nstatic int\niwl_mvm_config_sched_scan_profiles(struct iwl_mvm *mvm,\n\t\t\t\t   struct cfg80211_sched_scan_request *req)\n{\n\tstruct iwl_scan_offload_profile *profile;\n\tstruct iwl_scan_offload_profile_cfg_v1 *profile_cfg_v1;\n\tstruct iwl_scan_offload_blocklist *blocklist;\n\tstruct iwl_scan_offload_profile_cfg_data *data;\n\tint max_profiles = iwl_umac_scan_get_max_profiles(mvm->fw);\n\tint profile_cfg_size = sizeof(*data) +\n\t\tsizeof(*profile) * max_profiles;\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = SCAN_OFFLOAD_UPDATE_PROFILES_CMD,\n\t\t.len[1] = profile_cfg_size,\n\t\t.dataflags[0] = IWL_HCMD_DFL_NOCOPY,\n\t\t.dataflags[1] = IWL_HCMD_DFL_NOCOPY,\n\t};\n\tint blocklist_len;\n\tint i;\n\tint ret;\n\n\tif (WARN_ON(req->n_match_sets > max_profiles))\n\t\treturn -EIO;\n\n\tif (mvm->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_SHORT_BL)\n\t\tblocklist_len = IWL_SCAN_SHORT_BLACKLIST_LEN;\n\telse\n\t\tblocklist_len = IWL_SCAN_MAX_BLACKLIST_LEN;\n\n\tblocklist = kcalloc(blocklist_len, sizeof(*blocklist), GFP_KERNEL);\n\tif (!blocklist)\n\t\treturn -ENOMEM;\n\n\tprofile_cfg_v1 = kzalloc(profile_cfg_size, GFP_KERNEL);\n\tif (!profile_cfg_v1) {\n\t\tret = -ENOMEM;\n\t\tgoto free_blocklist;\n\t}\n\n\tcmd.data[0] = blocklist;\n\tcmd.len[0] = sizeof(*blocklist) * blocklist_len;\n\tcmd.data[1] = profile_cfg_v1;\n\n\t \n\tif (max_profiles == IWL_SCAN_MAX_PROFILES_V2) {\n\t\tstruct iwl_scan_offload_profile_cfg *profile_cfg =\n\t\t\t(struct iwl_scan_offload_profile_cfg *)profile_cfg_v1;\n\n\t\tdata = &profile_cfg->data;\n\t} else {\n\t\tdata = &profile_cfg_v1->data;\n\t}\n\n\t \n\tdata->num_profiles = req->n_match_sets;\n\tdata->active_clients = SCAN_CLIENT_SCHED_SCAN;\n\tdata->pass_match = SCAN_CLIENT_SCHED_SCAN;\n\tdata->match_notify = SCAN_CLIENT_SCHED_SCAN;\n\n\tif (!req->n_match_sets || !req->match_sets[0].ssid.ssid_len)\n\t\tdata->any_beacon_notify = SCAN_CLIENT_SCHED_SCAN;\n\n\tfor (i = 0; i < req->n_match_sets; i++) {\n\t\tprofile = &profile_cfg_v1->profiles[i];\n\t\tprofile->ssid_index = i;\n\t\t \n\t\tprofile->unicast_cipher = 0xff;\n\t\tprofile->auth_alg = IWL_AUTH_ALGO_UNSUPPORTED |\n\t\t\tIWL_AUTH_ALGO_NONE | IWL_AUTH_ALGO_PSK | IWL_AUTH_ALGO_8021X |\n\t\t\tIWL_AUTH_ALGO_SAE | IWL_AUTH_ALGO_8021X_SHA384 | IWL_AUTH_ALGO_OWE;\n\t\tprofile->network_type = IWL_NETWORK_TYPE_ANY;\n\t\tprofile->band_selection = IWL_SCAN_OFFLOAD_SELECT_ANY;\n\t\tprofile->client_bitmap = SCAN_CLIENT_SCHED_SCAN;\n\t}\n\n\tIWL_DEBUG_SCAN(mvm, \"Sending scheduled scan profile config\\n\");\n\n\tret = iwl_mvm_send_cmd(mvm, &cmd);\n\tkfree(profile_cfg_v1);\nfree_blocklist:\n\tkfree(blocklist);\n\n\treturn ret;\n}\n\nstatic bool iwl_mvm_scan_pass_all(struct iwl_mvm *mvm,\n\t\t\t\t  struct cfg80211_sched_scan_request *req)\n{\n\tif (req->n_match_sets && req->match_sets[0].ssid.ssid_len) {\n\t\tIWL_DEBUG_SCAN(mvm,\n\t\t\t       \"Sending scheduled scan with filtering, n_match_sets %d\\n\",\n\t\t\t       req->n_match_sets);\n\t\tmvm->sched_scan_pass_all = SCHED_SCAN_PASS_ALL_DISABLED;\n\t\treturn false;\n\t}\n\n\tIWL_DEBUG_SCAN(mvm, \"Sending Scheduled scan without filtering\\n\");\n\n\tmvm->sched_scan_pass_all = SCHED_SCAN_PASS_ALL_ENABLED;\n\treturn true;\n}\n\nstatic int iwl_mvm_lmac_scan_abort(struct iwl_mvm *mvm)\n{\n\tint ret;\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = SCAN_OFFLOAD_ABORT_CMD,\n\t};\n\tu32 status = CAN_ABORT_STATUS;\n\n\tret = iwl_mvm_send_cmd_status(mvm, &cmd, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tif (status != CAN_ABORT_STATUS) {\n\t\t \n\t\tIWL_DEBUG_SCAN(mvm, \"SCAN OFFLOAD ABORT ret %d.\\n\", status);\n\t\tret = -ENOENT;\n\t}\n\n\treturn ret;\n}\n\nstatic void iwl_mvm_scan_fill_tx_cmd(struct iwl_mvm *mvm,\n\t\t\t\t     struct iwl_scan_req_tx_cmd *tx_cmd,\n\t\t\t\t     bool no_cck)\n{\n\ttx_cmd[0].tx_flags = cpu_to_le32(TX_CMD_FLG_SEQ_CTL |\n\t\t\t\t\t TX_CMD_FLG_BT_DIS);\n\ttx_cmd[0].rate_n_flags = iwl_mvm_scan_rate_n_flags(mvm,\n\t\t\t\t\t\t\t   NL80211_BAND_2GHZ,\n\t\t\t\t\t\t\t   no_cck);\n\n\tif (!iwl_mvm_has_new_station_api(mvm->fw)) {\n\t\ttx_cmd[0].sta_id = mvm->aux_sta.sta_id;\n\t\ttx_cmd[1].sta_id = mvm->aux_sta.sta_id;\n\n\t \n\t} else {\n\t\ttx_cmd[0].sta_id = 0xff;\n\t\ttx_cmd[1].sta_id = 0xff;\n\t}\n\n\ttx_cmd[1].tx_flags = cpu_to_le32(TX_CMD_FLG_SEQ_CTL |\n\t\t\t\t\t TX_CMD_FLG_BT_DIS);\n\n\ttx_cmd[1].rate_n_flags = iwl_mvm_scan_rate_n_flags(mvm,\n\t\t\t\t\t\t\t   NL80211_BAND_5GHZ,\n\t\t\t\t\t\t\t   no_cck);\n}\n\nstatic void\niwl_mvm_lmac_scan_cfg_channels(struct iwl_mvm *mvm,\n\t\t\t       struct ieee80211_channel **channels,\n\t\t\t       int n_channels, u32 ssid_bitmap,\n\t\t\t       struct iwl_scan_req_lmac *cmd)\n{\n\tstruct iwl_scan_channel_cfg_lmac *channel_cfg = (void *)&cmd->data;\n\tint i;\n\n\tfor (i = 0; i < n_channels; i++) {\n\t\tchannel_cfg[i].channel_num =\n\t\t\tcpu_to_le16(channels[i]->hw_value);\n\t\tchannel_cfg[i].iter_count = cpu_to_le16(1);\n\t\tchannel_cfg[i].iter_interval = 0;\n\t\tchannel_cfg[i].flags =\n\t\t\tcpu_to_le32(IWL_UNIFIED_SCAN_CHANNEL_PARTIAL |\n\t\t\t\t    ssid_bitmap);\n\t}\n}\n\nstatic u8 *iwl_mvm_copy_and_insert_ds_elem(struct iwl_mvm *mvm, const u8 *ies,\n\t\t\t\t\t   size_t len, u8 *const pos)\n{\n\tstatic const u8 before_ds_params[] = {\n\t\t\tWLAN_EID_SSID,\n\t\t\tWLAN_EID_SUPP_RATES,\n\t\t\tWLAN_EID_REQUEST,\n\t\t\tWLAN_EID_EXT_SUPP_RATES,\n\t};\n\tsize_t offs;\n\tu8 *newpos = pos;\n\n\tif (!iwl_mvm_rrm_scan_needed(mvm)) {\n\t\tmemcpy(newpos, ies, len);\n\t\treturn newpos + len;\n\t}\n\n\toffs = ieee80211_ie_split(ies, len,\n\t\t\t\t  before_ds_params,\n\t\t\t\t  ARRAY_SIZE(before_ds_params),\n\t\t\t\t  0);\n\n\tmemcpy(newpos, ies, offs);\n\tnewpos += offs;\n\n\t \n\t*newpos++ = WLAN_EID_DS_PARAMS;\n\t*newpos++ = 1;\n\t*newpos++ = 0;\n\n\tmemcpy(newpos, ies + offs, len - offs);\n\tnewpos += len - offs;\n\n\treturn newpos;\n}\n\n#define WFA_TPC_IE_LEN\t9\n\nstatic void iwl_mvm_add_tpc_report_ie(u8 *pos)\n{\n\tpos[0] = WLAN_EID_VENDOR_SPECIFIC;\n\tpos[1] = WFA_TPC_IE_LEN - 2;\n\tpos[2] = (WLAN_OUI_MICROSOFT >> 16) & 0xff;\n\tpos[3] = (WLAN_OUI_MICROSOFT >> 8) & 0xff;\n\tpos[4] = WLAN_OUI_MICROSOFT & 0xff;\n\tpos[5] = WLAN_OUI_TYPE_MICROSOFT_TPC;\n\tpos[6] = 0;\n\t \n\tpos[7] = 0;\n\tpos[8] = 0;\n}\n\nstatic void\niwl_mvm_build_scan_probe(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t struct ieee80211_scan_ies *ies,\n\t\t\t struct iwl_mvm_scan_params *params)\n{\n\tstruct ieee80211_mgmt *frame = (void *)params->preq.buf;\n\tu8 *pos, *newpos;\n\tconst u8 *mac_addr = params->flags & NL80211_SCAN_FLAG_RANDOM_ADDR ?\n\t\tparams->mac_addr : NULL;\n\n\t \n\tif (mac_addr)\n\t\tget_random_mask_addr(frame->sa, mac_addr,\n\t\t\t\t     params->mac_addr_mask);\n\telse\n\t\tmemcpy(frame->sa, vif->addr, ETH_ALEN);\n\n\tframe->frame_control = cpu_to_le16(IEEE80211_STYPE_PROBE_REQ);\n\teth_broadcast_addr(frame->da);\n\tether_addr_copy(frame->bssid, params->bssid);\n\tframe->seq_ctrl = 0;\n\n\tpos = frame->u.probe_req.variable;\n\t*pos++ = WLAN_EID_SSID;\n\t*pos++ = 0;\n\n\tparams->preq.mac_header.offset = 0;\n\tparams->preq.mac_header.len = cpu_to_le16(24 + 2);\n\n\t \n\tnewpos = iwl_mvm_copy_and_insert_ds_elem(mvm,\n\t\t\t\t\t\t ies->ies[NL80211_BAND_2GHZ],\n\t\t\t\t\t\t ies->len[NL80211_BAND_2GHZ],\n\t\t\t\t\t\t pos);\n\tparams->preq.band_data[0].offset = cpu_to_le16(pos - params->preq.buf);\n\tparams->preq.band_data[0].len = cpu_to_le16(newpos - pos);\n\tpos = newpos;\n\n\tmemcpy(pos, ies->ies[NL80211_BAND_5GHZ],\n\t       ies->len[NL80211_BAND_5GHZ]);\n\tparams->preq.band_data[1].offset = cpu_to_le16(pos - params->preq.buf);\n\tparams->preq.band_data[1].len =\n\t\tcpu_to_le16(ies->len[NL80211_BAND_5GHZ]);\n\tpos += ies->len[NL80211_BAND_5GHZ];\n\n\tmemcpy(pos, ies->ies[NL80211_BAND_6GHZ],\n\t       ies->len[NL80211_BAND_6GHZ]);\n\tparams->preq.band_data[2].offset = cpu_to_le16(pos - params->preq.buf);\n\tparams->preq.band_data[2].len =\n\t\tcpu_to_le16(ies->len[NL80211_BAND_6GHZ]);\n\tpos += ies->len[NL80211_BAND_6GHZ];\n\tmemcpy(pos, ies->common_ies, ies->common_ie_len);\n\tparams->preq.common_data.offset = cpu_to_le16(pos - params->preq.buf);\n\n\tif (iwl_mvm_rrm_scan_needed(mvm) &&\n\t    !fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t IWL_UCODE_TLV_CAPA_WFA_TPC_REP_IE_SUPPORT)) {\n\t\tiwl_mvm_add_tpc_report_ie(pos + ies->common_ie_len);\n\t\tparams->preq.common_data.len = cpu_to_le16(ies->common_ie_len +\n\t\t\t\t\t\t\t   WFA_TPC_IE_LEN);\n\t} else {\n\t\tparams->preq.common_data.len = cpu_to_le16(ies->common_ie_len);\n\t}\n}\n\nstatic void iwl_mvm_scan_lmac_dwell(struct iwl_mvm *mvm,\n\t\t\t\t    struct iwl_scan_req_lmac *cmd,\n\t\t\t\t    struct iwl_mvm_scan_params *params)\n{\n\tcmd->active_dwell = IWL_SCAN_DWELL_ACTIVE;\n\tcmd->passive_dwell = IWL_SCAN_DWELL_PASSIVE;\n\tcmd->fragmented_dwell = IWL_SCAN_DWELL_FRAGMENTED;\n\tcmd->extended_dwell = IWL_SCAN_DWELL_EXTENDED;\n\tcmd->max_out_time = cpu_to_le32(scan_timing[params->type].max_out_time);\n\tcmd->suspend_time = cpu_to_le32(scan_timing[params->type].suspend_time);\n\tcmd->scan_prio = cpu_to_le32(IWL_SCAN_PRIORITY_EXT_6);\n}\n\nstatic inline bool iwl_mvm_scan_fits(struct iwl_mvm *mvm, int n_ssids,\n\t\t\t\t     struct ieee80211_scan_ies *ies,\n\t\t\t\t     int n_channels)\n{\n\treturn ((n_ssids <= PROBE_OPTION_MAX) &&\n\t\t(n_channels <= mvm->fw->ucode_capa.n_scan_channels) &\n\t\t(ies->common_ie_len +\n\t\t ies->len[NL80211_BAND_2GHZ] +\n\t\t ies->len[NL80211_BAND_5GHZ] <=\n\t\t iwl_mvm_max_scan_ie_fw_cmd_room(mvm)));\n}\n\nstatic inline bool iwl_mvm_scan_use_ebs(struct iwl_mvm *mvm,\n\t\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tconst struct iwl_ucode_capabilities *capa = &mvm->fw->ucode_capa;\n\tbool low_latency;\n\n\tif (iwl_mvm_is_cdb_supported(mvm))\n\t\tlow_latency = iwl_mvm_low_latency_band(mvm, NL80211_BAND_5GHZ);\n\telse\n\t\tlow_latency = iwl_mvm_low_latency(mvm);\n\n\t \n\treturn ((capa->flags & IWL_UCODE_TLV_FLAGS_EBS_SUPPORT) &&\n\t\tmvm->last_ebs_successful && IWL_MVM_ENABLE_EBS &&\n\t\tvif->type != NL80211_IFTYPE_P2P_DEVICE &&\n\t\t(!low_latency || iwl_mvm_is_frag_ebs_supported(mvm)));\n}\n\nstatic inline bool iwl_mvm_is_regular_scan(struct iwl_mvm_scan_params *params)\n{\n\treturn params->n_scan_plans == 1 &&\n\t\tparams->scan_plans[0].iterations == 1;\n}\n\nstatic bool iwl_mvm_is_scan_fragmented(enum iwl_mvm_scan_type type)\n{\n\treturn (type == IWL_SCAN_TYPE_FRAGMENTED ||\n\t\ttype == IWL_SCAN_TYPE_FAST_BALANCE);\n}\n\nstatic int iwl_mvm_scan_lmac_flags(struct iwl_mvm *mvm,\n\t\t\t\t   struct iwl_mvm_scan_params *params,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tint flags = 0;\n\n\tif (params->n_ssids == 0)\n\t\tflags |= IWL_MVM_LMAC_SCAN_FLAG_PASSIVE;\n\n\tif (params->n_ssids == 1 && params->ssids[0].ssid_len != 0)\n\t\tflags |= IWL_MVM_LMAC_SCAN_FLAG_PRE_CONNECTION;\n\n\tif (iwl_mvm_is_scan_fragmented(params->type))\n\t\tflags |= IWL_MVM_LMAC_SCAN_FLAG_FRAGMENTED;\n\n\tif (iwl_mvm_rrm_scan_needed(mvm) &&\n\t    fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_WFA_TPC_REP_IE_SUPPORT))\n\t\tflags |= IWL_MVM_LMAC_SCAN_FLAGS_RRM_ENABLED;\n\n\tif (params->pass_all)\n\t\tflags |= IWL_MVM_LMAC_SCAN_FLAG_PASS_ALL;\n\telse\n\t\tflags |= IWL_MVM_LMAC_SCAN_FLAG_MATCH;\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tif (mvm->scan_iter_notif_enabled)\n\t\tflags |= IWL_MVM_LMAC_SCAN_FLAG_ITER_COMPLETE;\n#endif\n\n\tif (mvm->sched_scan_pass_all == SCHED_SCAN_PASS_ALL_ENABLED)\n\t\tflags |= IWL_MVM_LMAC_SCAN_FLAG_ITER_COMPLETE;\n\n\tif (iwl_mvm_is_regular_scan(params) &&\n\t    vif->type != NL80211_IFTYPE_P2P_DEVICE &&\n\t    !iwl_mvm_is_scan_fragmented(params->type))\n\t\tflags |= IWL_MVM_LMAC_SCAN_FLAG_EXTENDED_DWELL;\n\n\treturn flags;\n}\n\nstatic void\niwl_mvm_scan_set_legacy_probe_req(struct iwl_scan_probe_req_v1 *p_req,\n\t\t\t\t  struct iwl_scan_probe_req *src_p_req)\n{\n\tint i;\n\n\tp_req->mac_header = src_p_req->mac_header;\n\tfor (i = 0; i < SCAN_NUM_BAND_PROBE_DATA_V_1; i++)\n\t\tp_req->band_data[i] = src_p_req->band_data[i];\n\tp_req->common_data = src_p_req->common_data;\n\tmemcpy(p_req->buf, src_p_req->buf, sizeof(p_req->buf));\n}\n\nstatic int iwl_mvm_scan_lmac(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t     struct iwl_mvm_scan_params *params)\n{\n\tstruct iwl_scan_req_lmac *cmd = mvm->scan_cmd;\n\tstruct iwl_scan_probe_req_v1 *preq =\n\t\t(void *)(cmd->data + sizeof(struct iwl_scan_channel_cfg_lmac) *\n\t\t\t mvm->fw->ucode_capa.n_scan_channels);\n\tu32 ssid_bitmap = 0;\n\tint i;\n\tu8 band;\n\n\tif (WARN_ON(params->n_scan_plans > IWL_MAX_SCHED_SCAN_PLANS))\n\t\treturn -EINVAL;\n\n\tiwl_mvm_scan_lmac_dwell(mvm, cmd, params);\n\n\tcmd->rx_chain_select = iwl_mvm_scan_rx_chain(mvm);\n\tcmd->iter_num = cpu_to_le32(1);\n\tcmd->n_channels = (u8)params->n_channels;\n\n\tcmd->delay = cpu_to_le32(params->delay);\n\n\tcmd->scan_flags = cpu_to_le32(iwl_mvm_scan_lmac_flags(mvm, params,\n\t\t\t\t\t\t\t      vif));\n\n\tband = iwl_mvm_phy_band_from_nl80211(params->channels[0]->band);\n\tcmd->flags = cpu_to_le32(band);\n\tcmd->filter_flags = cpu_to_le32(MAC_FILTER_ACCEPT_GRP |\n\t\t\t\t\tMAC_FILTER_IN_BEACON);\n\tiwl_mvm_scan_fill_tx_cmd(mvm, cmd->tx_cmd, params->no_cck);\n\tiwl_scan_build_ssids(params, cmd->direct_scan, &ssid_bitmap);\n\n\t \n\tssid_bitmap <<= 1;\n\n\tfor (i = 0; i < params->n_scan_plans; i++) {\n\t\tstruct cfg80211_sched_scan_plan *scan_plan =\n\t\t\t&params->scan_plans[i];\n\n\t\tcmd->schedule[i].delay =\n\t\t\tcpu_to_le16(scan_plan->interval);\n\t\tcmd->schedule[i].iterations = scan_plan->iterations;\n\t\tcmd->schedule[i].full_scan_mul = 1;\n\t}\n\n\t \n\tif (!cmd->schedule[i - 1].iterations)\n\t\tcmd->schedule[i - 1].iterations = 0xff;\n\n\tif (iwl_mvm_scan_use_ebs(mvm, vif)) {\n\t\tcmd->channel_opt[0].flags =\n\t\t\tcpu_to_le16(IWL_SCAN_CHANNEL_FLAG_EBS |\n\t\t\t\t    IWL_SCAN_CHANNEL_FLAG_EBS_ACCURATE |\n\t\t\t\t    IWL_SCAN_CHANNEL_FLAG_CACHE_ADD);\n\t\tcmd->channel_opt[0].non_ebs_ratio =\n\t\t\tcpu_to_le16(IWL_DENSE_EBS_SCAN_RATIO);\n\t\tcmd->channel_opt[1].flags =\n\t\t\tcpu_to_le16(IWL_SCAN_CHANNEL_FLAG_EBS |\n\t\t\t\t    IWL_SCAN_CHANNEL_FLAG_EBS_ACCURATE |\n\t\t\t\t    IWL_SCAN_CHANNEL_FLAG_CACHE_ADD);\n\t\tcmd->channel_opt[1].non_ebs_ratio =\n\t\t\tcpu_to_le16(IWL_SPARSE_EBS_SCAN_RATIO);\n\t}\n\n\tiwl_mvm_lmac_scan_cfg_channels(mvm, params->channels,\n\t\t\t\t       params->n_channels, ssid_bitmap, cmd);\n\n\tiwl_mvm_scan_set_legacy_probe_req(preq, &params->preq);\n\n\treturn 0;\n}\n\nstatic int rate_to_scan_rate_flag(unsigned int rate)\n{\n\tstatic const int rate_to_scan_rate[IWL_RATE_COUNT] = {\n\t\t[IWL_RATE_1M_INDEX]\t= SCAN_CONFIG_RATE_1M,\n\t\t[IWL_RATE_2M_INDEX]\t= SCAN_CONFIG_RATE_2M,\n\t\t[IWL_RATE_5M_INDEX]\t= SCAN_CONFIG_RATE_5M,\n\t\t[IWL_RATE_11M_INDEX]\t= SCAN_CONFIG_RATE_11M,\n\t\t[IWL_RATE_6M_INDEX]\t= SCAN_CONFIG_RATE_6M,\n\t\t[IWL_RATE_9M_INDEX]\t= SCAN_CONFIG_RATE_9M,\n\t\t[IWL_RATE_12M_INDEX]\t= SCAN_CONFIG_RATE_12M,\n\t\t[IWL_RATE_18M_INDEX]\t= SCAN_CONFIG_RATE_18M,\n\t\t[IWL_RATE_24M_INDEX]\t= SCAN_CONFIG_RATE_24M,\n\t\t[IWL_RATE_36M_INDEX]\t= SCAN_CONFIG_RATE_36M,\n\t\t[IWL_RATE_48M_INDEX]\t= SCAN_CONFIG_RATE_48M,\n\t\t[IWL_RATE_54M_INDEX]\t= SCAN_CONFIG_RATE_54M,\n\t};\n\n\treturn rate_to_scan_rate[rate];\n}\n\nstatic __le32 iwl_mvm_scan_config_rates(struct iwl_mvm *mvm)\n{\n\tstruct ieee80211_supported_band *band;\n\tunsigned int rates = 0;\n\tint i;\n\n\tband = &mvm->nvm_data->bands[NL80211_BAND_2GHZ];\n\tfor (i = 0; i < band->n_bitrates; i++)\n\t\trates |= rate_to_scan_rate_flag(band->bitrates[i].hw_value);\n\tband = &mvm->nvm_data->bands[NL80211_BAND_5GHZ];\n\tfor (i = 0; i < band->n_bitrates; i++)\n\t\trates |= rate_to_scan_rate_flag(band->bitrates[i].hw_value);\n\n\t \n\trates |= SCAN_CONFIG_SUPPORTED_RATE(rates);\n\n\treturn cpu_to_le32(rates);\n}\n\nstatic void iwl_mvm_fill_scan_dwell(struct iwl_mvm *mvm,\n\t\t\t\t    struct iwl_scan_dwell *dwell)\n{\n\tdwell->active = IWL_SCAN_DWELL_ACTIVE;\n\tdwell->passive = IWL_SCAN_DWELL_PASSIVE;\n\tdwell->fragmented = IWL_SCAN_DWELL_FRAGMENTED;\n\tdwell->extended = IWL_SCAN_DWELL_EXTENDED;\n}\n\nstatic void iwl_mvm_fill_channels(struct iwl_mvm *mvm, u8 *channels,\n\t\t\t\t  u32 max_channels)\n{\n\tstruct ieee80211_supported_band *band;\n\tint i, j = 0;\n\n\tband = &mvm->nvm_data->bands[NL80211_BAND_2GHZ];\n\tfor (i = 0; i < band->n_channels && j < max_channels; i++, j++)\n\t\tchannels[j] = band->channels[i].hw_value;\n\tband = &mvm->nvm_data->bands[NL80211_BAND_5GHZ];\n\tfor (i = 0; i < band->n_channels && j < max_channels; i++, j++)\n\t\tchannels[j] = band->channels[i].hw_value;\n}\n\nstatic void iwl_mvm_fill_scan_config_v1(struct iwl_mvm *mvm, void *config,\n\t\t\t\t\tu32 flags, u8 channel_flags,\n\t\t\t\t\tu32 max_channels)\n{\n\tenum iwl_mvm_scan_type type = iwl_mvm_get_scan_type(mvm, NULL);\n\tstruct iwl_scan_config_v1 *cfg = config;\n\n\tcfg->flags = cpu_to_le32(flags);\n\tcfg->tx_chains = cpu_to_le32(iwl_mvm_get_valid_tx_ant(mvm));\n\tcfg->rx_chains = cpu_to_le32(iwl_mvm_scan_rx_ant(mvm));\n\tcfg->legacy_rates = iwl_mvm_scan_config_rates(mvm);\n\tcfg->out_of_channel_time = cpu_to_le32(scan_timing[type].max_out_time);\n\tcfg->suspend_time = cpu_to_le32(scan_timing[type].suspend_time);\n\n\tiwl_mvm_fill_scan_dwell(mvm, &cfg->dwell);\n\n\tmemcpy(&cfg->mac_addr, &mvm->addresses[0].addr, ETH_ALEN);\n\n\t \n\tWARN_ON_ONCE(iwl_mvm_has_new_station_api(mvm->fw));\n\n\tcfg->bcast_sta_id = mvm->aux_sta.sta_id;\n\tcfg->channel_flags = channel_flags;\n\n\tiwl_mvm_fill_channels(mvm, cfg->channel_array, max_channels);\n}\n\nstatic void iwl_mvm_fill_scan_config_v2(struct iwl_mvm *mvm, void *config,\n\t\t\t\t\tu32 flags, u8 channel_flags,\n\t\t\t\t\tu32 max_channels)\n{\n\tstruct iwl_scan_config_v2 *cfg = config;\n\n\tcfg->flags = cpu_to_le32(flags);\n\tcfg->tx_chains = cpu_to_le32(iwl_mvm_get_valid_tx_ant(mvm));\n\tcfg->rx_chains = cpu_to_le32(iwl_mvm_scan_rx_ant(mvm));\n\tcfg->legacy_rates = iwl_mvm_scan_config_rates(mvm);\n\n\tif (iwl_mvm_is_cdb_supported(mvm)) {\n\t\tenum iwl_mvm_scan_type lb_type, hb_type;\n\n\t\tlb_type = iwl_mvm_get_scan_type_band(mvm, NULL,\n\t\t\t\t\t\t     NL80211_BAND_2GHZ);\n\t\thb_type = iwl_mvm_get_scan_type_band(mvm, NULL,\n\t\t\t\t\t\t     NL80211_BAND_5GHZ);\n\n\t\tcfg->out_of_channel_time[SCAN_LB_LMAC_IDX] =\n\t\t\tcpu_to_le32(scan_timing[lb_type].max_out_time);\n\t\tcfg->suspend_time[SCAN_LB_LMAC_IDX] =\n\t\t\tcpu_to_le32(scan_timing[lb_type].suspend_time);\n\n\t\tcfg->out_of_channel_time[SCAN_HB_LMAC_IDX] =\n\t\t\tcpu_to_le32(scan_timing[hb_type].max_out_time);\n\t\tcfg->suspend_time[SCAN_HB_LMAC_IDX] =\n\t\t\tcpu_to_le32(scan_timing[hb_type].suspend_time);\n\t} else {\n\t\tenum iwl_mvm_scan_type type =\n\t\t\tiwl_mvm_get_scan_type(mvm, NULL);\n\n\t\tcfg->out_of_channel_time[SCAN_LB_LMAC_IDX] =\n\t\t\tcpu_to_le32(scan_timing[type].max_out_time);\n\t\tcfg->suspend_time[SCAN_LB_LMAC_IDX] =\n\t\t\tcpu_to_le32(scan_timing[type].suspend_time);\n\t}\n\n\tiwl_mvm_fill_scan_dwell(mvm, &cfg->dwell);\n\n\tmemcpy(&cfg->mac_addr, &mvm->addresses[0].addr, ETH_ALEN);\n\n\t \n\tWARN_ON_ONCE(iwl_mvm_has_new_station_api(mvm->fw));\n\n\tcfg->bcast_sta_id = mvm->aux_sta.sta_id;\n\tcfg->channel_flags = channel_flags;\n\n\tiwl_mvm_fill_channels(mvm, cfg->channel_array, max_channels);\n}\n\nstatic int iwl_mvm_legacy_config_scan(struct iwl_mvm *mvm)\n{\n\tvoid *cfg;\n\tint ret, cmd_size;\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = WIDE_ID(IWL_ALWAYS_LONG_GROUP, SCAN_CFG_CMD),\n\t};\n\tenum iwl_mvm_scan_type type;\n\tenum iwl_mvm_scan_type hb_type = IWL_SCAN_TYPE_NOT_SET;\n\tint num_channels =\n\t\tmvm->nvm_data->bands[NL80211_BAND_2GHZ].n_channels +\n\t\tmvm->nvm_data->bands[NL80211_BAND_5GHZ].n_channels;\n\tu32 flags;\n\tu8 channel_flags;\n\n\tif (WARN_ON(num_channels > mvm->fw->ucode_capa.n_scan_channels))\n\t\tnum_channels = mvm->fw->ucode_capa.n_scan_channels;\n\n\tif (iwl_mvm_is_cdb_supported(mvm)) {\n\t\ttype = iwl_mvm_get_scan_type_band(mvm, NULL,\n\t\t\t\t\t\t  NL80211_BAND_2GHZ);\n\t\thb_type = iwl_mvm_get_scan_type_band(mvm, NULL,\n\t\t\t\t\t\t     NL80211_BAND_5GHZ);\n\t\tif (type == mvm->scan_type && hb_type == mvm->hb_scan_type)\n\t\t\treturn 0;\n\t} else {\n\t\ttype = iwl_mvm_get_scan_type(mvm, NULL);\n\t\tif (type == mvm->scan_type)\n\t\t\treturn 0;\n\t}\n\n\tif (iwl_mvm_cdb_scan_api(mvm))\n\t\tcmd_size = sizeof(struct iwl_scan_config_v2);\n\telse\n\t\tcmd_size = sizeof(struct iwl_scan_config_v1);\n\tcmd_size += mvm->fw->ucode_capa.n_scan_channels;\n\n\tcfg = kzalloc(cmd_size, GFP_KERNEL);\n\tif (!cfg)\n\t\treturn -ENOMEM;\n\n\tflags = SCAN_CONFIG_FLAG_ACTIVATE |\n\t\t SCAN_CONFIG_FLAG_ALLOW_CHUB_REQS |\n\t\t SCAN_CONFIG_FLAG_SET_TX_CHAINS |\n\t\t SCAN_CONFIG_FLAG_SET_RX_CHAINS |\n\t\t SCAN_CONFIG_FLAG_SET_AUX_STA_ID |\n\t\t SCAN_CONFIG_FLAG_SET_ALL_TIMES |\n\t\t SCAN_CONFIG_FLAG_SET_LEGACY_RATES |\n\t\t SCAN_CONFIG_FLAG_SET_MAC_ADDR |\n\t\t SCAN_CONFIG_FLAG_SET_CHANNEL_FLAGS |\n\t\t SCAN_CONFIG_N_CHANNELS(num_channels) |\n\t\t (iwl_mvm_is_scan_fragmented(type) ?\n\t\t  SCAN_CONFIG_FLAG_SET_FRAGMENTED :\n\t\t  SCAN_CONFIG_FLAG_CLEAR_FRAGMENTED);\n\n\tchannel_flags = IWL_CHANNEL_FLAG_EBS |\n\t\t\tIWL_CHANNEL_FLAG_ACCURATE_EBS |\n\t\t\tIWL_CHANNEL_FLAG_EBS_ADD |\n\t\t\tIWL_CHANNEL_FLAG_PRE_SCAN_PASSIVE2ACTIVE;\n\n\t \n\tif (iwl_mvm_cdb_scan_api(mvm)) {\n\t\tif (iwl_mvm_is_cdb_supported(mvm))\n\t\t\tflags |= (iwl_mvm_is_scan_fragmented(hb_type)) ?\n\t\t\t\t SCAN_CONFIG_FLAG_SET_LMAC2_FRAGMENTED :\n\t\t\t\t SCAN_CONFIG_FLAG_CLEAR_LMAC2_FRAGMENTED;\n\t\tiwl_mvm_fill_scan_config_v2(mvm, cfg, flags, channel_flags,\n\t\t\t\t\t    num_channels);\n\t} else {\n\t\tiwl_mvm_fill_scan_config_v1(mvm, cfg, flags, channel_flags,\n\t\t\t\t\t    num_channels);\n\t}\n\n\tcmd.data[0] = cfg;\n\tcmd.len[0] = cmd_size;\n\tcmd.dataflags[0] = IWL_HCMD_DFL_NOCOPY;\n\n\tIWL_DEBUG_SCAN(mvm, \"Sending UMAC scan config\\n\");\n\n\tret = iwl_mvm_send_cmd(mvm, &cmd);\n\tif (!ret) {\n\t\tmvm->scan_type = type;\n\t\tmvm->hb_scan_type = hb_type;\n\t}\n\n\tkfree(cfg);\n\treturn ret;\n}\n\nint iwl_mvm_config_scan(struct iwl_mvm *mvm)\n{\n\tstruct iwl_scan_config cfg;\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = WIDE_ID(IWL_ALWAYS_LONG_GROUP, SCAN_CFG_CMD),\n\t\t.len[0] = sizeof(cfg),\n\t\t.data[0] = &cfg,\n\t\t.dataflags[0] = IWL_HCMD_DFL_NOCOPY,\n\t};\n\n\tif (!iwl_mvm_is_reduced_config_scan_supported(mvm))\n\t\treturn iwl_mvm_legacy_config_scan(mvm);\n\n\tmemset(&cfg, 0, sizeof(cfg));\n\n\tif (!iwl_mvm_has_new_station_api(mvm->fw)) {\n\t\tcfg.bcast_sta_id = mvm->aux_sta.sta_id;\n\t} else if (iwl_fw_lookup_cmd_ver(mvm->fw, SCAN_CFG_CMD, 0) < 5) {\n\t\t \n\t\tcfg.bcast_sta_id = 0xff;\n\t}\n\n\tcfg.tx_chains = cpu_to_le32(iwl_mvm_get_valid_tx_ant(mvm));\n\tcfg.rx_chains = cpu_to_le32(iwl_mvm_scan_rx_ant(mvm));\n\n\tIWL_DEBUG_SCAN(mvm, \"Sending UMAC scan config\\n\");\n\n\treturn iwl_mvm_send_cmd(mvm, &cmd);\n}\n\nstatic int iwl_mvm_scan_uid_by_status(struct iwl_mvm *mvm, int status)\n{\n\tint i;\n\n\tfor (i = 0; i < mvm->max_scans; i++)\n\t\tif (mvm->scan_uid_status[i] == status)\n\t\t\treturn i;\n\n\treturn -ENOENT;\n}\n\nstatic void iwl_mvm_scan_umac_dwell(struct iwl_mvm *mvm,\n\t\t\t\t    struct iwl_scan_req_umac *cmd,\n\t\t\t\t    struct iwl_mvm_scan_params *params)\n{\n\tstruct iwl_mvm_scan_timing_params *timing, *hb_timing;\n\tu8 active_dwell, passive_dwell;\n\n\ttiming = &scan_timing[params->type];\n\tactive_dwell = IWL_SCAN_DWELL_ACTIVE;\n\tpassive_dwell = IWL_SCAN_DWELL_PASSIVE;\n\n\tif (iwl_mvm_is_adaptive_dwell_supported(mvm)) {\n\t\tcmd->v7.adwell_default_n_aps_social =\n\t\t\tIWL_SCAN_ADWELL_DEFAULT_N_APS_SOCIAL;\n\t\tcmd->v7.adwell_default_n_aps =\n\t\t\tIWL_SCAN_ADWELL_DEFAULT_LB_N_APS;\n\n\t\tif (iwl_mvm_is_adwell_hb_ap_num_supported(mvm))\n\t\t\tcmd->v9.adwell_default_hb_n_aps =\n\t\t\t\tIWL_SCAN_ADWELL_DEFAULT_HB_N_APS;\n\n\t\t \n\t\tif (IWL_MVM_ADWELL_MAX_BUDGET)\n\t\t\tcmd->v7.adwell_max_budget =\n\t\t\t\tcpu_to_le16(IWL_MVM_ADWELL_MAX_BUDGET);\n\t\telse if (params->ssids && params->ssids[0].ssid_len)\n\t\t\tcmd->v7.adwell_max_budget =\n\t\t\t\tcpu_to_le16(IWL_SCAN_ADWELL_MAX_BUDGET_DIRECTED_SCAN);\n\t\telse\n\t\t\tcmd->v7.adwell_max_budget =\n\t\t\t\tcpu_to_le16(IWL_SCAN_ADWELL_MAX_BUDGET_FULL_SCAN);\n\n\t\tcmd->v7.scan_priority = cpu_to_le32(IWL_SCAN_PRIORITY_EXT_6);\n\t\tcmd->v7.max_out_time[SCAN_LB_LMAC_IDX] =\n\t\t\tcpu_to_le32(timing->max_out_time);\n\t\tcmd->v7.suspend_time[SCAN_LB_LMAC_IDX] =\n\t\t\tcpu_to_le32(timing->suspend_time);\n\n\t\tif (iwl_mvm_is_cdb_supported(mvm)) {\n\t\t\thb_timing = &scan_timing[params->hb_type];\n\n\t\t\tcmd->v7.max_out_time[SCAN_HB_LMAC_IDX] =\n\t\t\t\tcpu_to_le32(hb_timing->max_out_time);\n\t\t\tcmd->v7.suspend_time[SCAN_HB_LMAC_IDX] =\n\t\t\t\tcpu_to_le32(hb_timing->suspend_time);\n\t\t}\n\n\t\tif (!iwl_mvm_is_adaptive_dwell_v2_supported(mvm)) {\n\t\t\tcmd->v7.active_dwell = active_dwell;\n\t\t\tcmd->v7.passive_dwell = passive_dwell;\n\t\t\tcmd->v7.fragmented_dwell = IWL_SCAN_DWELL_FRAGMENTED;\n\t\t} else {\n\t\t\tcmd->v8.active_dwell[SCAN_LB_LMAC_IDX] = active_dwell;\n\t\t\tcmd->v8.passive_dwell[SCAN_LB_LMAC_IDX] = passive_dwell;\n\t\t\tif (iwl_mvm_is_cdb_supported(mvm)) {\n\t\t\t\tcmd->v8.active_dwell[SCAN_HB_LMAC_IDX] =\n\t\t\t\t\tactive_dwell;\n\t\t\t\tcmd->v8.passive_dwell[SCAN_HB_LMAC_IDX] =\n\t\t\t\t\tpassive_dwell;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcmd->v1.extended_dwell = IWL_SCAN_DWELL_EXTENDED;\n\t\tcmd->v1.active_dwell = active_dwell;\n\t\tcmd->v1.passive_dwell = passive_dwell;\n\t\tcmd->v1.fragmented_dwell = IWL_SCAN_DWELL_FRAGMENTED;\n\n\t\tif (iwl_mvm_is_cdb_supported(mvm)) {\n\t\t\thb_timing = &scan_timing[params->hb_type];\n\n\t\t\tcmd->v6.max_out_time[SCAN_HB_LMAC_IDX] =\n\t\t\t\t\tcpu_to_le32(hb_timing->max_out_time);\n\t\t\tcmd->v6.suspend_time[SCAN_HB_LMAC_IDX] =\n\t\t\t\t\tcpu_to_le32(hb_timing->suspend_time);\n\t\t}\n\n\t\tif (iwl_mvm_cdb_scan_api(mvm)) {\n\t\t\tcmd->v6.scan_priority =\n\t\t\t\tcpu_to_le32(IWL_SCAN_PRIORITY_EXT_6);\n\t\t\tcmd->v6.max_out_time[SCAN_LB_LMAC_IDX] =\n\t\t\t\tcpu_to_le32(timing->max_out_time);\n\t\t\tcmd->v6.suspend_time[SCAN_LB_LMAC_IDX] =\n\t\t\t\tcpu_to_le32(timing->suspend_time);\n\t\t} else {\n\t\t\tcmd->v1.scan_priority =\n\t\t\t\tcpu_to_le32(IWL_SCAN_PRIORITY_EXT_6);\n\t\t\tcmd->v1.max_out_time =\n\t\t\t\tcpu_to_le32(timing->max_out_time);\n\t\t\tcmd->v1.suspend_time =\n\t\t\t\tcpu_to_le32(timing->suspend_time);\n\t\t}\n\t}\n\n\tif (iwl_mvm_is_regular_scan(params))\n\t\tcmd->ooc_priority = cpu_to_le32(IWL_SCAN_PRIORITY_EXT_6);\n\telse\n\t\tcmd->ooc_priority = cpu_to_le32(IWL_SCAN_PRIORITY_EXT_2);\n}\n\nstatic u32 iwl_mvm_scan_umac_ooc_priority(struct iwl_mvm_scan_params *params)\n{\n\treturn iwl_mvm_is_regular_scan(params) ?\n\t\tIWL_SCAN_PRIORITY_EXT_6 :\n\t\tIWL_SCAN_PRIORITY_EXT_2;\n}\n\nstatic void\niwl_mvm_scan_umac_dwell_v11(struct iwl_mvm *mvm,\n\t\t\t    struct iwl_scan_general_params_v11 *general_params,\n\t\t\t    struct iwl_mvm_scan_params *params)\n{\n\tstruct iwl_mvm_scan_timing_params *timing, *hb_timing;\n\tu8 active_dwell, passive_dwell;\n\n\ttiming = &scan_timing[params->type];\n\tactive_dwell = IWL_SCAN_DWELL_ACTIVE;\n\tpassive_dwell = IWL_SCAN_DWELL_PASSIVE;\n\n\tgeneral_params->adwell_default_social_chn =\n\t\tIWL_SCAN_ADWELL_DEFAULT_N_APS_SOCIAL;\n\tgeneral_params->adwell_default_2g = IWL_SCAN_ADWELL_DEFAULT_LB_N_APS;\n\tgeneral_params->adwell_default_5g = IWL_SCAN_ADWELL_DEFAULT_HB_N_APS;\n\n\t \n\tif (IWL_MVM_ADWELL_MAX_BUDGET)\n\t\tgeneral_params->adwell_max_budget =\n\t\t\tcpu_to_le16(IWL_MVM_ADWELL_MAX_BUDGET);\n\telse if (params->ssids && params->ssids[0].ssid_len)\n\t\tgeneral_params->adwell_max_budget =\n\t\t\tcpu_to_le16(IWL_SCAN_ADWELL_MAX_BUDGET_DIRECTED_SCAN);\n\telse\n\t\tgeneral_params->adwell_max_budget =\n\t\t\tcpu_to_le16(IWL_SCAN_ADWELL_MAX_BUDGET_FULL_SCAN);\n\n\tgeneral_params->scan_priority = cpu_to_le32(IWL_SCAN_PRIORITY_EXT_6);\n\tgeneral_params->max_out_of_time[SCAN_LB_LMAC_IDX] =\n\t\tcpu_to_le32(timing->max_out_time);\n\tgeneral_params->suspend_time[SCAN_LB_LMAC_IDX] =\n\t\tcpu_to_le32(timing->suspend_time);\n\n\thb_timing = &scan_timing[params->hb_type];\n\n\tgeneral_params->max_out_of_time[SCAN_HB_LMAC_IDX] =\n\t\tcpu_to_le32(hb_timing->max_out_time);\n\tgeneral_params->suspend_time[SCAN_HB_LMAC_IDX] =\n\t\tcpu_to_le32(hb_timing->suspend_time);\n\n\tgeneral_params->active_dwell[SCAN_LB_LMAC_IDX] = active_dwell;\n\tgeneral_params->passive_dwell[SCAN_LB_LMAC_IDX] = passive_dwell;\n\tgeneral_params->active_dwell[SCAN_HB_LMAC_IDX] = active_dwell;\n\tgeneral_params->passive_dwell[SCAN_HB_LMAC_IDX] = passive_dwell;\n}\n\nstruct iwl_mvm_scan_channel_segment {\n\tu8 start_idx;\n\tu8 end_idx;\n\tu8 first_channel_id;\n\tu8 last_channel_id;\n\tu8 channel_spacing_shift;\n\tu8 band;\n};\n\nstatic const struct iwl_mvm_scan_channel_segment scan_channel_segments[] = {\n\t{\n\t\t.start_idx = 0,\n\t\t.end_idx = 13,\n\t\t.first_channel_id = 1,\n\t\t.last_channel_id = 14,\n\t\t.channel_spacing_shift = 0,\n\t\t.band = PHY_BAND_24\n\t},\n\t{\n\t\t.start_idx = 14,\n\t\t.end_idx = 41,\n\t\t.first_channel_id = 36,\n\t\t.last_channel_id = 144,\n\t\t.channel_spacing_shift = 2,\n\t\t.band = PHY_BAND_5\n\t},\n\t{\n\t\t.start_idx = 42,\n\t\t.end_idx = 50,\n\t\t.first_channel_id = 149,\n\t\t.last_channel_id = 181,\n\t\t.channel_spacing_shift = 2,\n\t\t.band = PHY_BAND_5\n\t},\n\t{\n\t\t.start_idx = 51,\n\t\t.end_idx = 111,\n\t\t.first_channel_id = 1,\n\t\t.last_channel_id = 241,\n\t\t.channel_spacing_shift = 2,\n\t\t.band = PHY_BAND_6\n\t},\n};\n\nstatic int iwl_mvm_scan_ch_and_band_to_idx(u8 channel_id, u8 band)\n{\n\tint i, index;\n\n\tif (!channel_id)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(scan_channel_segments); i++) {\n\t\tconst struct iwl_mvm_scan_channel_segment *ch_segment =\n\t\t\t&scan_channel_segments[i];\n\t\tu32 ch_offset;\n\n\t\tif (ch_segment->band != band ||\n\t\t    ch_segment->first_channel_id > channel_id ||\n\t\t    ch_segment->last_channel_id < channel_id)\n\t\t\tcontinue;\n\n\t\tch_offset = (channel_id - ch_segment->first_channel_id) >>\n\t\t\tch_segment->channel_spacing_shift;\n\n\t\tindex = scan_channel_segments[i].start_idx + ch_offset;\n\t\tif (index < IWL_SCAN_NUM_CHANNELS)\n\t\t\treturn index;\n\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const u8 p2p_go_friendly_chs[] = {\n\t36, 40, 44, 48, 149, 153, 157, 161, 165,\n};\n\nstatic const u8 social_chs[] = {\n\t1, 6, 11\n};\n\nstatic void iwl_mvm_scan_ch_add_n_aps_override(enum nl80211_iftype vif_type,\n\t\t\t\t\t       u8 ch_id, u8 band, u8 *ch_bitmap,\n\t\t\t\t\t       size_t bitmap_n_entries)\n{\n\tint i;\n\n\tif (vif_type != NL80211_IFTYPE_P2P_DEVICE)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(p2p_go_friendly_chs); i++) {\n\t\tif (p2p_go_friendly_chs[i] == ch_id) {\n\t\t\tint ch_idx, bitmap_idx;\n\n\t\t\tch_idx = iwl_mvm_scan_ch_and_band_to_idx(ch_id, band);\n\t\t\tif (ch_idx < 0)\n\t\t\t\treturn;\n\n\t\t\tbitmap_idx = ch_idx / 8;\n\t\t\tif (bitmap_idx >= bitmap_n_entries)\n\t\t\t\treturn;\n\n\t\t\tch_idx = ch_idx % 8;\n\t\t\tch_bitmap[bitmap_idx] |= BIT(ch_idx);\n\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic u32 iwl_mvm_scan_ch_n_aps_flag(enum nl80211_iftype vif_type, u8 ch_id)\n{\n\tint i;\n\tu32 flags = 0;\n\n\tif (vif_type != NL80211_IFTYPE_P2P_DEVICE)\n\t\tgoto out;\n\n\tfor (i = 0; i < ARRAY_SIZE(p2p_go_friendly_chs); i++) {\n\t\tif (p2p_go_friendly_chs[i] == ch_id) {\n\t\t\tflags |= IWL_SCAN_ADWELL_N_APS_GO_FRIENDLY_BIT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (flags)\n\t\tgoto out;\n\n\tfor (i = 0; i < ARRAY_SIZE(social_chs); i++) {\n\t\tif (social_chs[i] == ch_id) {\n\t\t\tflags |= IWL_SCAN_ADWELL_N_APS_SOCIAL_CHS_BIT;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\treturn flags;\n}\n\nstatic void\niwl_mvm_umac_scan_cfg_channels(struct iwl_mvm *mvm,\n\t\t\t       struct ieee80211_channel **channels,\n\t\t\t       int n_channels, u32 flags,\n\t\t\t       struct iwl_scan_channel_cfg_umac *channel_cfg)\n{\n\tint i;\n\n\tfor (i = 0; i < n_channels; i++) {\n\t\tchannel_cfg[i].flags = cpu_to_le32(flags);\n\t\tchannel_cfg[i].v1.channel_num = channels[i]->hw_value;\n\t\tif (iwl_mvm_is_scan_ext_chan_supported(mvm)) {\n\t\t\tenum nl80211_band band = channels[i]->band;\n\n\t\t\tchannel_cfg[i].v2.band =\n\t\t\t\tiwl_mvm_phy_band_from_nl80211(band);\n\t\t\tchannel_cfg[i].v2.iter_count = 1;\n\t\t\tchannel_cfg[i].v2.iter_interval = 0;\n\t\t} else {\n\t\t\tchannel_cfg[i].v1.iter_count = 1;\n\t\t\tchannel_cfg[i].v1.iter_interval = 0;\n\t\t}\n\t}\n}\n\nstatic void\niwl_mvm_umac_scan_cfg_channels_v4(struct iwl_mvm *mvm,\n\t\t\t\t  struct ieee80211_channel **channels,\n\t\t\t\t  struct iwl_scan_channel_params_v4 *cp,\n\t\t\t\t  int n_channels, u32 flags,\n\t\t\t\t  enum nl80211_iftype vif_type)\n{\n\tu8 *bitmap = cp->adwell_ch_override_bitmap;\n\tsize_t bitmap_n_entries = ARRAY_SIZE(cp->adwell_ch_override_bitmap);\n\tint i;\n\n\tfor (i = 0; i < n_channels; i++) {\n\t\tenum nl80211_band band = channels[i]->band;\n\t\tstruct iwl_scan_channel_cfg_umac *cfg =\n\t\t\t&cp->channel_config[i];\n\n\t\tcfg->flags = cpu_to_le32(flags);\n\t\tcfg->v2.channel_num = channels[i]->hw_value;\n\t\tcfg->v2.band = iwl_mvm_phy_band_from_nl80211(band);\n\t\tcfg->v2.iter_count = 1;\n\t\tcfg->v2.iter_interval = 0;\n\n\t\tiwl_mvm_scan_ch_add_n_aps_override(vif_type,\n\t\t\t\t\t\t   cfg->v2.channel_num,\n\t\t\t\t\t\t   cfg->v2.band, bitmap,\n\t\t\t\t\t\t   bitmap_n_entries);\n\t}\n}\n\nstatic void\niwl_mvm_umac_scan_cfg_channels_v7(struct iwl_mvm *mvm,\n\t\t\t\t  struct ieee80211_channel **channels,\n\t\t\t\t  struct iwl_scan_channel_params_v7 *cp,\n\t\t\t\t  int n_channels, u32 flags,\n\t\t\t\t  enum nl80211_iftype vif_type, u32 version)\n{\n\tint i;\n\n\tfor (i = 0; i < n_channels; i++) {\n\t\tenum nl80211_band band = channels[i]->band;\n\t\tstruct iwl_scan_channel_cfg_umac *cfg = &cp->channel_config[i];\n\t\tu32 n_aps_flag =\n\t\t\tiwl_mvm_scan_ch_n_aps_flag(vif_type,\n\t\t\t\t\t\t   channels[i]->hw_value);\n\t\tu8 iwl_band = iwl_mvm_phy_band_from_nl80211(band);\n\n\t\tcfg->flags = cpu_to_le32(flags | n_aps_flag);\n\t\tcfg->v2.channel_num = channels[i]->hw_value;\n\t\tif (cfg80211_channel_is_psc(channels[i]))\n\t\t\tcfg->flags = 0;\n\t\tcfg->v2.iter_count = 1;\n\t\tcfg->v2.iter_interval = 0;\n\t\tif (version < 17)\n\t\t\tcfg->v2.band = iwl_band;\n\t\telse\n\t\t\tcfg->flags |= cpu_to_le32((iwl_band <<\n\t\t\t\t\t\t   IWL_CHAN_CFG_FLAGS_BAND_POS));\n\t}\n}\n\nstatic void\niwl_mvm_umac_scan_fill_6g_chan_list(struct iwl_mvm *mvm,\n\t\t\t\t    struct iwl_mvm_scan_params *params,\n\t\t\t\t     struct iwl_scan_probe_params_v4 *pp)\n{\n\tint j, idex_s = 0, idex_b = 0;\n\tstruct cfg80211_scan_6ghz_params *scan_6ghz_params =\n\t\tparams->scan_6ghz_params;\n\tbool hidden_supported = fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t\t\t    IWL_UCODE_TLV_CAPA_HIDDEN_6GHZ_SCAN);\n\n\tfor (j = 0; j < params->n_ssids && idex_s < SCAN_SHORT_SSID_MAX_SIZE;\n\t     j++) {\n\t\tif (!params->ssids[j].ssid_len)\n\t\t\tcontinue;\n\n\t\tpp->short_ssid[idex_s] =\n\t\t\tcpu_to_le32(~crc32_le(~0, params->ssids[j].ssid,\n\t\t\t\t\t      params->ssids[j].ssid_len));\n\n\t\tif (hidden_supported) {\n\t\t\tpp->direct_scan[idex_s].id = WLAN_EID_SSID;\n\t\t\tpp->direct_scan[idex_s].len = params->ssids[j].ssid_len;\n\t\t\tmemcpy(pp->direct_scan[idex_s].ssid, params->ssids[j].ssid,\n\t\t\t       params->ssids[j].ssid_len);\n\t\t}\n\t\tidex_s++;\n\t}\n\n\t \n\tfor (j = 0; j < params->n_6ghz_params; j++) {\n\t\tint k;\n\n\t\t \n\t\tif (scan_6ghz_params[j].short_ssid_valid) {\n\t\t\tfor (k = 0; k < idex_s; k++) {\n\t\t\t\tif (pp->short_ssid[k] ==\n\t\t\t\t    cpu_to_le32(scan_6ghz_params[j].short_ssid))\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (k == idex_s && idex_s < SCAN_SHORT_SSID_MAX_SIZE) {\n\t\t\t\tpp->short_ssid[idex_s++] =\n\t\t\t\t\tcpu_to_le32(scan_6ghz_params[j].short_ssid);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (k = 0; k < idex_b; k++) {\n\t\t\tif (!memcmp(&pp->bssid_array[k],\n\t\t\t\t    scan_6ghz_params[j].bssid, ETH_ALEN))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (k == idex_b && idex_b < SCAN_BSSID_MAX_SIZE) {\n\t\t\tmemcpy(&pp->bssid_array[idex_b++],\n\t\t\t       scan_6ghz_params[j].bssid, ETH_ALEN);\n\t\t}\n\t}\n\n\tpp->short_ssid_num = idex_s;\n\tpp->bssid_num = idex_b;\n}\n\n \nstatic u32\niwl_mvm_umac_scan_cfg_channels_v7_6g(struct iwl_mvm *mvm,\n\t\t\t\t     struct iwl_mvm_scan_params *params,\n\t\t\t\t     u32 n_channels,\n\t\t\t\t     struct iwl_scan_probe_params_v4 *pp,\n\t\t\t\t     struct iwl_scan_channel_params_v7 *cp,\n\t\t\t\t     enum nl80211_iftype vif_type,\n\t\t\t\t     u32 version)\n{\n\tint i;\n\tstruct cfg80211_scan_6ghz_params *scan_6ghz_params =\n\t\tparams->scan_6ghz_params;\n\tu32 ch_cnt;\n\n\tfor (i = 0, ch_cnt = 0; i < params->n_channels; i++) {\n\t\tstruct iwl_scan_channel_cfg_umac *cfg =\n\t\t\t&cp->channel_config[ch_cnt];\n\n\t\tu32 s_ssid_bitmap = 0, bssid_bitmap = 0, flags = 0;\n\t\tu8 j, k, s_max = 0, b_max = 0, n_used_bssid_entries;\n\t\tbool force_passive, found = false, allow_passive = true,\n\t\t     unsolicited_probe_on_chan = false, psc_no_listen = false;\n\t\ts8 psd_20 = IEEE80211_RNR_TBTT_PARAMS_PSD_RESERVED;\n\n\t\t \n\t\tif (!cfg80211_channel_is_psc(params->channels[i]) &&\n\t\t    !params->n_6ghz_params && params->n_ssids)\n\t\t\tcontinue;\n\n\t\tcfg->v1.channel_num = params->channels[i]->hw_value;\n\t\tif (version < 17)\n\t\t\tcfg->v2.band = PHY_BAND_6;\n\t\telse\n\t\t\tcfg->flags |= cpu_to_le32(PHY_BAND_6 <<\n\t\t\t\t\t\t  IWL_CHAN_CFG_FLAGS_BAND_POS);\n\n\t\tcfg->v5.iter_count = 1;\n\t\tcfg->v5.iter_interval = 0;\n\n\t\t \n\t\tn_used_bssid_entries = 3;\n\t\tfor (j = 0; j < params->n_6ghz_params; j++) {\n\t\t\ts8 tmp_psd_20;\n\n\t\t\tif (!(scan_6ghz_params[j].channel_idx == i))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\ttmp_psd_20 = scan_6ghz_params[j].psd_20;\n\t\t\tif (tmp_psd_20 !=\n\t\t\t    IEEE80211_RNR_TBTT_PARAMS_PSD_RESERVED &&\n\t\t\t    (psd_20 ==\n\t\t\t     IEEE80211_RNR_TBTT_PARAMS_PSD_RESERVED ||\n\t\t\t     psd_20 < tmp_psd_20))\n\t\t\t\tpsd_20 = tmp_psd_20;\n\n\t\t\tfound = false;\n\t\t\tunsolicited_probe_on_chan |=\n\t\t\t\tscan_6ghz_params[j].unsolicited_probe;\n\t\t\tpsc_no_listen |= scan_6ghz_params[j].psc_no_listen;\n\n\t\t\tfor (k = 0; k < pp->short_ssid_num; k++) {\n\t\t\t\tif (!scan_6ghz_params[j].unsolicited_probe &&\n\t\t\t\t    le32_to_cpu(pp->short_ssid[k]) ==\n\t\t\t\t    scan_6ghz_params[j].short_ssid) {\n\t\t\t\t\t \n\t\t\t\t\tif (s_ssid_bitmap & BIT(k)) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\t\t\t\t\tif (n_used_bssid_entries >= 3) {\n\t\t\t\t\t\ts_ssid_bitmap |= BIT(k);\n\t\t\t\t\t\ts_max++;\n\t\t\t\t\t\tn_used_bssid_entries -= 3;\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (pp->direct_scan[k].len) {\n\t\t\t\t\t\ts_ssid_bitmap |= BIT(k);\n\t\t\t\t\t\ts_max++;\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tallow_passive = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (found)\n\t\t\t\tcontinue;\n\n\t\t\tfor (k = 0; k < pp->bssid_num; k++) {\n\t\t\t\tif (!memcmp(&pp->bssid_array[k],\n\t\t\t\t\t    scan_6ghz_params[j].bssid,\n\t\t\t\t\t    ETH_ALEN)) {\n\t\t\t\t\tif (!(bssid_bitmap & BIT(k))) {\n\t\t\t\t\t\tbssid_bitmap |= BIT(k);\n\t\t\t\t\t\tb_max++;\n\t\t\t\t\t\tn_used_bssid_entries++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (cfg80211_channel_is_psc(params->channels[i]) &&\n\t\t    psc_no_listen)\n\t\t\tflags |= IWL_UHB_CHAN_CFG_FLAG_PSC_CHAN_NO_LISTEN;\n\n\t\tif (unsolicited_probe_on_chan)\n\t\t\tflags |= IWL_UHB_CHAN_CFG_FLAG_UNSOLICITED_PROBE_RES;\n\n\t\t \n\t\tif (!iwl_mvm_is_scan_fragmented(params->type)) {\n\t\t\tif (!cfg80211_channel_is_psc(params->channels[i]) ||\n\t\t\t    flags & IWL_UHB_CHAN_CFG_FLAG_PSC_CHAN_NO_LISTEN) {\n\t\t\t\tforce_passive = (s_max > 3 || b_max > 9);\n\t\t\t\tforce_passive |= (unsolicited_probe_on_chan &&\n\t\t\t\t\t\t  (s_max > 2 || b_max > 6));\n\t\t\t} else {\n\t\t\t\tforce_passive = (s_max > 2 || b_max > 6);\n\t\t\t}\n\t\t} else if (cfg80211_channel_is_psc(params->channels[i])) {\n\t\t\tforce_passive = (s_max > 1 || b_max > 3);\n\t\t} else {\n\t\t\tforce_passive = (s_max > 2 || b_max > 6);\n\t\t\tforce_passive |= (unsolicited_probe_on_chan &&\n\t\t\t\t\t  (s_max > 1 || b_max > 3));\n\t\t}\n\t\tif ((allow_passive && force_passive) ||\n\t\t    (!(bssid_bitmap | s_ssid_bitmap) &&\n\t\t     !cfg80211_channel_is_psc(params->channels[i])))\n\t\t\tflags |= IWL_UHB_CHAN_CFG_FLAG_FORCE_PASSIVE;\n\t\telse\n\t\t\tflags |= bssid_bitmap | (s_ssid_bitmap << 16);\n\n\t\tcfg->flags |= cpu_to_le32(flags);\n\t\tif (version >= 17)\n\t\t\tcfg->v5.psd_20 = psd_20;\n\n\t\tch_cnt++;\n\t}\n\n\tif (params->n_channels > ch_cnt)\n\t\tIWL_DEBUG_SCAN(mvm,\n\t\t\t       \"6GHz: reducing number channels: (%u->%u)\\n\",\n\t\t\t       params->n_channels, ch_cnt);\n\n\treturn ch_cnt;\n}\n\nstatic u8 iwl_mvm_scan_umac_chan_flags_v2(struct iwl_mvm *mvm,\n\t\t\t\t\t  struct iwl_mvm_scan_params *params,\n\t\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tu8 flags = 0;\n\n\tflags |= IWL_SCAN_CHANNEL_FLAG_ENABLE_CHAN_ORDER;\n\n\tif (iwl_mvm_scan_use_ebs(mvm, vif))\n\t\tflags |= IWL_SCAN_CHANNEL_FLAG_EBS |\n\t\t\tIWL_SCAN_CHANNEL_FLAG_EBS_ACCURATE |\n\t\t\tIWL_SCAN_CHANNEL_FLAG_CACHE_ADD;\n\n\t \n\tif ((!iwl_mvm_is_cdb_supported(mvm) &&\n\t     iwl_mvm_is_scan_fragmented(params->type)) ||\n\t    (iwl_mvm_is_cdb_supported(mvm) &&\n\t     iwl_mvm_is_scan_fragmented(params->hb_type)))\n\t\tflags |= IWL_SCAN_CHANNEL_FLAG_EBS_FRAG;\n\n\t \n\tif ((!iwl_mvm_is_cdb_supported(mvm) &&\n\t     iwl_mvm_is_scan_fragmented(params->type) && params->respect_p2p_go) ||\n\t    (iwl_mvm_is_cdb_supported(mvm) &&\n\t     iwl_mvm_is_scan_fragmented(params->hb_type) &&\n\t     params->respect_p2p_go_hb)) {\n\t\tIWL_DEBUG_SCAN(mvm, \"Respect P2P GO. Force EBS\\n\");\n\t\tflags |= IWL_SCAN_CHANNEL_FLAG_FORCE_EBS;\n\t}\n\n\treturn flags;\n}\n\nstatic void iwl_mvm_scan_6ghz_passive_scan(struct iwl_mvm *mvm,\n\t\t\t\t\t   struct iwl_mvm_scan_params *params,\n\t\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_supported_band *sband =\n\t\t&mvm->nvm_data->bands[NL80211_BAND_6GHZ];\n\tu32 n_disabled, i;\n\n\tparams->enable_6ghz_passive = false;\n\n\tif (params->scan_6ghz)\n\t\treturn;\n\n\tif (!fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t IWL_UCODE_TLV_CAPA_PASSIVE_6GHZ_SCAN)) {\n\t\tIWL_DEBUG_SCAN(mvm,\n\t\t\t       \"6GHz passive scan: Not supported by FW\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (vif->type != NL80211_IFTYPE_STATION) {\n\t\tIWL_DEBUG_SCAN(mvm,\n\t\t\t       \"6GHz passive scan: not station interface\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif ((vif->cfg.assoc ||\n\t     time_after(mvm->last_6ghz_passive_scan_jiffies +\n\t\t\t(IWL_MVM_6GHZ_PASSIVE_SCAN_TIMEOUT * HZ), jiffies)) &&\n\t    (time_before(mvm->last_reset_or_resume_time_jiffies +\n\t\t\t (IWL_MVM_6GHZ_PASSIVE_SCAN_ASSOC_TIMEOUT * HZ),\n\t\t\t jiffies))) {\n\t\tIWL_DEBUG_SCAN(mvm, \"6GHz passive scan: %s\\n\",\n\t\t\t       vif->cfg.assoc ? \"associated\" :\n\t\t\t       \"timeout did not expire\");\n\t\treturn;\n\t}\n\n\t \n\tif (params->n_channels < IWL_MVM_6GHZ_PASSIVE_SCAN_MIN_CHANS) {\n\t\tIWL_DEBUG_SCAN(mvm,\n\t\t\t       \"6GHz passive scan: not enough channels\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < params->n_ssids; i++) {\n\t\tif (!params->ssids[i].ssid_len)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (i == params->n_ssids) {\n\t\tIWL_DEBUG_SCAN(mvm,\n\t\t\t       \"6GHz passive scan: no wildcard SSID\\n\");\n\t\treturn;\n\t}\n\n\tif (!sband || !sband->n_channels) {\n\t\tIWL_DEBUG_SCAN(mvm,\n\t\t\t       \"6GHz passive scan: no 6GHz channels\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0, n_disabled = 0; i < sband->n_channels; i++) {\n\t\tif (sband->channels[i].flags & (IEEE80211_CHAN_DISABLED))\n\t\t\tn_disabled++;\n\t}\n\n\t \n\tif (n_disabled != sband->n_channels) {\n\t\tIWL_DEBUG_SCAN(mvm,\n\t\t\t       \"6GHz passive scan: 6GHz channels enabled\\n\");\n\t\treturn;\n\t}\n\n\t \n\tIWL_DEBUG_SCAN(mvm, \"6GHz passive scan: can be enabled\\n\");\n\tparams->enable_6ghz_passive = true;\n}\n\nstatic u16 iwl_mvm_scan_umac_flags_v2(struct iwl_mvm *mvm,\n\t\t\t\t      struct iwl_mvm_scan_params *params,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      int type)\n{\n\tu16 flags = 0;\n\n\t \n\tif (params->n_ssids == 0)\n\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_FORCE_PASSIVE;\n\telse if (params->n_ssids == 1 && params->ssids[0].ssid_len)\n\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_USE_ALL_RX_CHAINS;\n\n\tif (iwl_mvm_is_scan_fragmented(params->type))\n\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_FRAGMENTED_LMAC1;\n\n\tif (iwl_mvm_is_scan_fragmented(params->hb_type))\n\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_FRAGMENTED_LMAC2;\n\n\tif (params->pass_all)\n\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_PASS_ALL;\n\telse\n\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_MATCH;\n\n\tif (!iwl_mvm_is_regular_scan(params))\n\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_PERIODIC;\n\n\tif (params->iter_notif ||\n\t    mvm->sched_scan_pass_all == SCHED_SCAN_PASS_ALL_ENABLED)\n\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_NTFY_ITER_COMPLETE;\n\n\tif (IWL_MVM_ADWELL_ENABLE)\n\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_ADAPTIVE_DWELL;\n\n\tif (type == IWL_MVM_SCAN_SCHED || type == IWL_MVM_SCAN_NETDETECT)\n\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_PREEMPTIVE;\n\n\tif ((type == IWL_MVM_SCAN_SCHED || type == IWL_MVM_SCAN_NETDETECT) &&\n\t    params->flags & NL80211_SCAN_FLAG_COLOCATED_6GHZ)\n\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_TRIGGER_UHB_SCAN;\n\n\tif (params->enable_6ghz_passive)\n\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_6GHZ_PASSIVE_SCAN;\n\n\tif (iwl_mvm_is_oce_supported(mvm) &&\n\t    (params->flags & (NL80211_SCAN_FLAG_ACCEPT_BCAST_PROBE_RESP |\n\t\t\t      NL80211_SCAN_FLAG_OCE_PROBE_REQ_HIGH_TX_RATE |\n\t\t\t      NL80211_SCAN_FLAG_FILS_MAX_CHANNEL_TIME)))\n\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_OCE;\n\n\treturn flags;\n}\n\nstatic u8 iwl_mvm_scan_umac_flags2(struct iwl_mvm *mvm,\n\t\t\t\t   struct iwl_mvm_scan_params *params,\n\t\t\t\t   struct ieee80211_vif *vif, int type)\n{\n\tu8 flags = 0;\n\n\tif (iwl_mvm_is_cdb_supported(mvm)) {\n\t\tif (params->respect_p2p_go)\n\t\t\tflags |= IWL_UMAC_SCAN_GEN_PARAMS_FLAGS2_RESPECT_P2P_GO_LB;\n\t\tif (params->respect_p2p_go_hb)\n\t\t\tflags |= IWL_UMAC_SCAN_GEN_PARAMS_FLAGS2_RESPECT_P2P_GO_HB;\n\t} else {\n\t\tif (params->respect_p2p_go)\n\t\t\tflags = IWL_UMAC_SCAN_GEN_PARAMS_FLAGS2_RESPECT_P2P_GO_LB |\n\t\t\t\tIWL_UMAC_SCAN_GEN_PARAMS_FLAGS2_RESPECT_P2P_GO_HB;\n\t}\n\n\tif (params->scan_6ghz &&\n\t    fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_SCAN_DONT_TOGGLE_ANT))\n\t\tflags |= IWL_UMAC_SCAN_GEN_PARAMS_FLAGS2_DONT_TOGGLE_ANT;\n\n\treturn flags;\n}\n\nstatic u16 iwl_mvm_scan_umac_flags(struct iwl_mvm *mvm,\n\t\t\t\t   struct iwl_mvm_scan_params *params,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tu16 flags = 0;\n\n\tif (params->n_ssids == 0)\n\t\tflags = IWL_UMAC_SCAN_GEN_FLAGS_PASSIVE;\n\n\tif (params->n_ssids == 1 && params->ssids[0].ssid_len != 0)\n\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_PRE_CONNECT;\n\n\tif (iwl_mvm_is_scan_fragmented(params->type))\n\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_FRAGMENTED;\n\n\tif (iwl_mvm_is_cdb_supported(mvm) &&\n\t    iwl_mvm_is_scan_fragmented(params->hb_type))\n\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_LMAC2_FRAGMENTED;\n\n\tif (iwl_mvm_rrm_scan_needed(mvm) &&\n\t    fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_WFA_TPC_REP_IE_SUPPORT))\n\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_RRM_ENABLED;\n\n\tif (params->pass_all)\n\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_PASS_ALL;\n\telse\n\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_MATCH;\n\n\tif (!iwl_mvm_is_regular_scan(params))\n\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_PERIODIC;\n\n\tif (params->iter_notif)\n\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_ITER_COMPLETE;\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tif (mvm->scan_iter_notif_enabled)\n\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_ITER_COMPLETE;\n#endif\n\n\tif (mvm->sched_scan_pass_all == SCHED_SCAN_PASS_ALL_ENABLED)\n\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_ITER_COMPLETE;\n\n\tif (iwl_mvm_is_adaptive_dwell_supported(mvm) && IWL_MVM_ADWELL_ENABLE)\n\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_ADAPTIVE_DWELL;\n\n\t \n\tif (iwl_mvm_is_regular_scan(params) &&\n\t    vif->type != NL80211_IFTYPE_P2P_DEVICE &&\n\t    !iwl_mvm_is_scan_fragmented(params->type) &&\n\t    !iwl_mvm_is_adaptive_dwell_supported(mvm) &&\n\t    !iwl_mvm_is_oce_supported(mvm))\n\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_EXTENDED_DWELL;\n\n\tif (iwl_mvm_is_oce_supported(mvm)) {\n\t\tif ((params->flags &\n\t\t     NL80211_SCAN_FLAG_OCE_PROBE_REQ_HIGH_TX_RATE))\n\t\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_PROB_REQ_HIGH_TX_RATE;\n\t\t \n\t\tif ((params->flags &\n\t\t     NL80211_SCAN_FLAG_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION) &&\n\t\t     !WARN_ON_ONCE(!iwl_mvm_is_adaptive_dwell_supported(mvm)))\n\t\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_PROB_REQ_DEFER_SUPP;\n\t\tif ((params->flags & NL80211_SCAN_FLAG_FILS_MAX_CHANNEL_TIME))\n\t\t\tflags |= IWL_UMAC_SCAN_GEN_FLAGS_MAX_CHNL_TIME;\n\t}\n\n\treturn flags;\n}\n\nstatic int\niwl_mvm_fill_scan_sched_params(struct iwl_mvm_scan_params *params,\n\t\t\t       struct iwl_scan_umac_schedule *schedule,\n\t\t\t       __le16 *delay)\n{\n\tint i;\n\tif (WARN_ON(!params->n_scan_plans ||\n\t\t    params->n_scan_plans > IWL_MAX_SCHED_SCAN_PLANS))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < params->n_scan_plans; i++) {\n\t\tstruct cfg80211_sched_scan_plan *scan_plan =\n\t\t\t&params->scan_plans[i];\n\n\t\tschedule[i].iter_count = scan_plan->iterations;\n\t\tschedule[i].interval =\n\t\t\tcpu_to_le16(scan_plan->interval);\n\t}\n\n\t \n\tif (!schedule[params->n_scan_plans - 1].iter_count)\n\t\tschedule[params->n_scan_plans - 1].iter_count = 0xff;\n\n\t*delay = cpu_to_le16(params->delay);\n\n\treturn 0;\n}\n\nstatic int iwl_mvm_scan_umac(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t     struct iwl_mvm_scan_params *params,\n\t\t\t     int type, int uid)\n{\n\tstruct iwl_scan_req_umac *cmd = mvm->scan_cmd;\n\tstruct iwl_scan_umac_chan_param *chan_param;\n\tvoid *cmd_data = iwl_mvm_get_scan_req_umac_data(mvm);\n\tvoid *sec_part = (u8 *)cmd_data + sizeof(struct iwl_scan_channel_cfg_umac) *\n\t\tmvm->fw->ucode_capa.n_scan_channels;\n\tstruct iwl_scan_req_umac_tail_v2 *tail_v2 =\n\t\t(struct iwl_scan_req_umac_tail_v2 *)sec_part;\n\tstruct iwl_scan_req_umac_tail_v1 *tail_v1;\n\tstruct iwl_ssid_ie *direct_scan;\n\tint ret = 0;\n\tu32 ssid_bitmap = 0;\n\tu8 channel_flags = 0;\n\tu16 gen_flags;\n\tstruct iwl_mvm_vif *scan_vif = iwl_mvm_vif_from_mac80211(vif);\n\n\tchan_param = iwl_mvm_get_scan_req_umac_channel(mvm);\n\n\tiwl_mvm_scan_umac_dwell(mvm, cmd, params);\n\n\tmvm->scan_uid_status[uid] = type;\n\n\tcmd->uid = cpu_to_le32(uid);\n\tgen_flags = iwl_mvm_scan_umac_flags(mvm, params, vif);\n\tcmd->general_flags = cpu_to_le16(gen_flags);\n\tif (iwl_mvm_is_adaptive_dwell_v2_supported(mvm)) {\n\t\tif (gen_flags & IWL_UMAC_SCAN_GEN_FLAGS_FRAGMENTED)\n\t\t\tcmd->v8.num_of_fragments[SCAN_LB_LMAC_IDX] =\n\t\t\t\t\t\t\tIWL_SCAN_NUM_OF_FRAGS;\n\t\tif (gen_flags & IWL_UMAC_SCAN_GEN_FLAGS_LMAC2_FRAGMENTED)\n\t\t\tcmd->v8.num_of_fragments[SCAN_HB_LMAC_IDX] =\n\t\t\t\t\t\t\tIWL_SCAN_NUM_OF_FRAGS;\n\n\t\tcmd->v8.general_flags2 =\n\t\t\tIWL_UMAC_SCAN_GEN_FLAGS2_ALLOW_CHNL_REORDER;\n\t}\n\n\tcmd->scan_start_mac_id = scan_vif->id;\n\n\tif (type == IWL_MVM_SCAN_SCHED || type == IWL_MVM_SCAN_NETDETECT)\n\t\tcmd->flags = cpu_to_le32(IWL_UMAC_SCAN_FLAG_PREEMPTIVE);\n\n\tif (iwl_mvm_scan_use_ebs(mvm, vif)) {\n\t\tchannel_flags = IWL_SCAN_CHANNEL_FLAG_EBS |\n\t\t\t\tIWL_SCAN_CHANNEL_FLAG_EBS_ACCURATE |\n\t\t\t\tIWL_SCAN_CHANNEL_FLAG_CACHE_ADD;\n\n\t\t \n\t\tif (iwl_mvm_is_frag_ebs_supported(mvm)) {\n\t\t\tif (gen_flags &\n\t\t\t    IWL_UMAC_SCAN_GEN_FLAGS_LMAC2_FRAGMENTED ||\n\t\t\t    (!iwl_mvm_is_cdb_supported(mvm) &&\n\t\t\t     gen_flags & IWL_UMAC_SCAN_GEN_FLAGS_FRAGMENTED))\n\t\t\t\tchannel_flags |= IWL_SCAN_CHANNEL_FLAG_EBS_FRAG;\n\t\t}\n\t}\n\n\tchan_param->flags = channel_flags;\n\tchan_param->count = params->n_channels;\n\n\tret = iwl_mvm_fill_scan_sched_params(params, tail_v2->schedule,\n\t\t\t\t\t     &tail_v2->delay);\n\tif (ret) {\n\t\tmvm->scan_uid_status[uid] = 0;\n\t\treturn ret;\n\t}\n\n\tif (iwl_mvm_is_scan_ext_chan_supported(mvm)) {\n\t\ttail_v2->preq = params->preq;\n\t\tdirect_scan = tail_v2->direct_scan;\n\t} else {\n\t\ttail_v1 = (struct iwl_scan_req_umac_tail_v1 *)sec_part;\n\t\tiwl_mvm_scan_set_legacy_probe_req(&tail_v1->preq,\n\t\t\t\t\t\t  &params->preq);\n\t\tdirect_scan = tail_v1->direct_scan;\n\t}\n\tiwl_scan_build_ssids(params, direct_scan, &ssid_bitmap);\n\tiwl_mvm_umac_scan_cfg_channels(mvm, params->channels,\n\t\t\t\t       params->n_channels, ssid_bitmap,\n\t\t\t\t       cmd_data);\n\treturn 0;\n}\n\nstatic void\niwl_mvm_scan_umac_fill_general_p_v12(struct iwl_mvm *mvm,\n\t\t\t\t     struct iwl_mvm_scan_params *params,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct iwl_scan_general_params_v11 *gp,\n\t\t\t\t     u16 gen_flags, u8 gen_flags2,\n\t\t\t\t     u32 version)\n{\n\tstruct iwl_mvm_vif *scan_vif = iwl_mvm_vif_from_mac80211(vif);\n\n\tiwl_mvm_scan_umac_dwell_v11(mvm, gp, params);\n\n\tIWL_DEBUG_SCAN(mvm, \"General: flags=0x%x, flags2=0x%x\\n\",\n\t\t       gen_flags, gen_flags2);\n\n\tgp->flags = cpu_to_le16(gen_flags);\n\tgp->flags2 = gen_flags2;\n\n\tif (gen_flags & IWL_UMAC_SCAN_GEN_FLAGS_V2_FRAGMENTED_LMAC1)\n\t\tgp->num_of_fragments[SCAN_LB_LMAC_IDX] = IWL_SCAN_NUM_OF_FRAGS;\n\tif (gen_flags & IWL_UMAC_SCAN_GEN_FLAGS_V2_FRAGMENTED_LMAC2)\n\t\tgp->num_of_fragments[SCAN_HB_LMAC_IDX] = IWL_SCAN_NUM_OF_FRAGS;\n\n\tif (version < 16) {\n\t\tgp->scan_start_mac_or_link_id = scan_vif->id;\n\t} else {\n\t\tstruct iwl_mvm_vif_link_info *link_info;\n\t\tu8 link_id = 0;\n\n\t\t \n\t\tif (vif->active_links)\n\t\t\tlink_id = ffs(vif->active_links) - 1;\n\n\t\tlink_info = scan_vif->link[link_id];\n\t\tif (!WARN_ON(!link_info))\n\t\t\tgp->scan_start_mac_or_link_id = link_info->fw_link_id;\n\t}\n}\n\nstatic void\niwl_mvm_scan_umac_fill_probe_p_v3(struct iwl_mvm_scan_params *params,\n\t\t\t\t  struct iwl_scan_probe_params_v3 *pp)\n{\n\tpp->preq = params->preq;\n\tpp->ssid_num = params->n_ssids;\n\tiwl_scan_build_ssids(params, pp->direct_scan, NULL);\n}\n\nstatic void\niwl_mvm_scan_umac_fill_probe_p_v4(struct iwl_mvm_scan_params *params,\n\t\t\t\t  struct iwl_scan_probe_params_v4 *pp,\n\t\t\t\t  u32 *bitmap_ssid)\n{\n\tpp->preq = params->preq;\n\tiwl_scan_build_ssids(params, pp->direct_scan, bitmap_ssid);\n}\n\nstatic void\niwl_mvm_scan_umac_fill_ch_p_v4(struct iwl_mvm *mvm,\n\t\t\t       struct iwl_mvm_scan_params *params,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct iwl_scan_channel_params_v4 *cp,\n\t\t\t       u32 channel_cfg_flags)\n{\n\tcp->flags = iwl_mvm_scan_umac_chan_flags_v2(mvm, params, vif);\n\tcp->count = params->n_channels;\n\tcp->num_of_aps_override = IWL_SCAN_ADWELL_N_APS_GO_FRIENDLY;\n\n\tiwl_mvm_umac_scan_cfg_channels_v4(mvm, params->channels, cp,\n\t\t\t\t\t  params->n_channels,\n\t\t\t\t\t  channel_cfg_flags,\n\t\t\t\t\t  vif->type);\n}\n\nstatic void\niwl_mvm_scan_umac_fill_ch_p_v7(struct iwl_mvm *mvm,\n\t\t\t       struct iwl_mvm_scan_params *params,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct iwl_scan_channel_params_v7 *cp,\n\t\t\t       u32 channel_cfg_flags,\n\t\t\t       u32 version)\n{\n\tcp->flags = iwl_mvm_scan_umac_chan_flags_v2(mvm, params, vif);\n\tcp->count = params->n_channels;\n\tcp->n_aps_override[0] = IWL_SCAN_ADWELL_N_APS_GO_FRIENDLY;\n\tcp->n_aps_override[1] = IWL_SCAN_ADWELL_N_APS_SOCIAL_CHS;\n\n\tiwl_mvm_umac_scan_cfg_channels_v7(mvm, params->channels, cp,\n\t\t\t\t\t  params->n_channels,\n\t\t\t\t\t  channel_cfg_flags,\n\t\t\t\t\t  vif->type, version);\n\n\tif (params->enable_6ghz_passive) {\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\t&mvm->nvm_data->bands[NL80211_BAND_6GHZ];\n\t\tu32 i;\n\n\t\tfor (i = 0; i < sband->n_channels; i++) {\n\t\t\tstruct ieee80211_channel *channel =\n\t\t\t\t&sband->channels[i];\n\n\t\t\tstruct iwl_scan_channel_cfg_umac *cfg =\n\t\t\t\t&cp->channel_config[cp->count];\n\n\t\t\tif (!cfg80211_channel_is_psc(channel))\n\t\t\t\tcontinue;\n\n\t\t\tcfg->v5.channel_num = channel->hw_value;\n\t\t\tcfg->v5.iter_count = 1;\n\t\t\tcfg->v5.iter_interval = 0;\n\n\t\t\tif (version < 17) {\n\t\t\t\tcfg->flags = 0;\n\t\t\t\tcfg->v2.band = PHY_BAND_6;\n\t\t\t} else {\n\t\t\t\tcfg->flags = cpu_to_le32(PHY_BAND_6 <<\n\t\t\t\t\t\t\t IWL_CHAN_CFG_FLAGS_BAND_POS);\n\t\t\t\tcfg->v5.psd_20 =\n\t\t\t\t\tIEEE80211_RNR_TBTT_PARAMS_PSD_RESERVED;\n\t\t\t}\n\t\t\tcp->count++;\n\t\t}\n\t}\n}\n\nstatic int iwl_mvm_scan_umac_v12(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t\t struct iwl_mvm_scan_params *params, int type,\n\t\t\t\t int uid)\n{\n\tstruct iwl_scan_req_umac_v12 *cmd = mvm->scan_cmd;\n\tstruct iwl_scan_req_params_v12 *scan_p = &cmd->scan_params;\n\tint ret;\n\tu16 gen_flags;\n\n\tmvm->scan_uid_status[uid] = type;\n\n\tcmd->ooc_priority = cpu_to_le32(iwl_mvm_scan_umac_ooc_priority(params));\n\tcmd->uid = cpu_to_le32(uid);\n\n\tgen_flags = iwl_mvm_scan_umac_flags_v2(mvm, params, vif, type);\n\tiwl_mvm_scan_umac_fill_general_p_v12(mvm, params, vif,\n\t\t\t\t\t     &scan_p->general_params,\n\t\t\t\t\t     gen_flags, 0, 12);\n\n\tret = iwl_mvm_fill_scan_sched_params(params,\n\t\t\t\t\t     scan_p->periodic_params.schedule,\n\t\t\t\t\t     &scan_p->periodic_params.delay);\n\tif (ret)\n\t\treturn ret;\n\n\tiwl_mvm_scan_umac_fill_probe_p_v3(params, &scan_p->probe_params);\n\tiwl_mvm_scan_umac_fill_ch_p_v4(mvm, params, vif,\n\t\t\t\t       &scan_p->channel_params, 0);\n\n\treturn 0;\n}\n\nstatic int iwl_mvm_scan_umac_v14_and_above(struct iwl_mvm *mvm,\n\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t   struct iwl_mvm_scan_params *params,\n\t\t\t\t\t   int type, int uid, u32 version)\n{\n\tstruct iwl_scan_req_umac_v17 *cmd = mvm->scan_cmd;\n\tstruct iwl_scan_req_params_v17 *scan_p = &cmd->scan_params;\n\tstruct iwl_scan_channel_params_v7 *cp = &scan_p->channel_params;\n\tstruct iwl_scan_probe_params_v4 *pb = &scan_p->probe_params;\n\tint ret;\n\tu16 gen_flags;\n\tu8 gen_flags2;\n\tu32 bitmap_ssid = 0;\n\n\tmvm->scan_uid_status[uid] = type;\n\n\tcmd->ooc_priority = cpu_to_le32(iwl_mvm_scan_umac_ooc_priority(params));\n\tcmd->uid = cpu_to_le32(uid);\n\n\tgen_flags = iwl_mvm_scan_umac_flags_v2(mvm, params, vif, type);\n\n\tif (version >= 15)\n\t\tgen_flags2 = iwl_mvm_scan_umac_flags2(mvm, params, vif, type);\n\telse\n\t\tgen_flags2 = 0;\n\n\tiwl_mvm_scan_umac_fill_general_p_v12(mvm, params, vif,\n\t\t\t\t\t     &scan_p->general_params,\n\t\t\t\t\t     gen_flags, gen_flags2, version);\n\n\tret = iwl_mvm_fill_scan_sched_params(params,\n\t\t\t\t\t     scan_p->periodic_params.schedule,\n\t\t\t\t\t     &scan_p->periodic_params.delay);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!params->scan_6ghz) {\n\t\tiwl_mvm_scan_umac_fill_probe_p_v4(params,\n\t\t\t\t\t\t  &scan_p->probe_params,\n\t\t\t\t\t\t  &bitmap_ssid);\n\t\tiwl_mvm_scan_umac_fill_ch_p_v7(mvm, params, vif,\n\t\t\t\t\t       &scan_p->channel_params,\n\t\t\t\t\t       bitmap_ssid,\n\t\t\t\t\t       version);\n\t\treturn 0;\n\t} else {\n\t\tpb->preq = params->preq;\n\t}\n\n\tcp->flags = iwl_mvm_scan_umac_chan_flags_v2(mvm, params, vif);\n\tcp->n_aps_override[0] = IWL_SCAN_ADWELL_N_APS_GO_FRIENDLY;\n\tcp->n_aps_override[1] = IWL_SCAN_ADWELL_N_APS_SOCIAL_CHS;\n\n\tiwl_mvm_umac_scan_fill_6g_chan_list(mvm, params, pb);\n\n\tcp->count = iwl_mvm_umac_scan_cfg_channels_v7_6g(mvm, params,\n\t\t\t\t\t\t\t params->n_channels,\n\t\t\t\t\t\t\t pb, cp, vif->type,\n\t\t\t\t\t\t\t version);\n\tif (!cp->count) {\n\t\tmvm->scan_uid_status[uid] = 0;\n\t\treturn -EINVAL;\n\t}\n\n\tif (!params->n_ssids ||\n\t    (params->n_ssids == 1 && !params->ssids[0].ssid_len))\n\t\tcp->flags |= IWL_SCAN_CHANNEL_FLAG_6G_PSC_NO_FILTER;\n\n\treturn 0;\n}\n\nstatic int iwl_mvm_scan_umac_v14(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t\t struct iwl_mvm_scan_params *params, int type,\n\t\t\t\t int uid)\n{\n\treturn iwl_mvm_scan_umac_v14_and_above(mvm, vif, params, type, uid, 14);\n}\n\nstatic int iwl_mvm_scan_umac_v15(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t\t struct iwl_mvm_scan_params *params, int type,\n\t\t\t\t int uid)\n{\n\treturn iwl_mvm_scan_umac_v14_and_above(mvm, vif, params, type, uid, 15);\n}\n\nstatic int iwl_mvm_scan_umac_v16(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t\t struct iwl_mvm_scan_params *params, int type,\n\t\t\t\t int uid)\n{\n\treturn iwl_mvm_scan_umac_v14_and_above(mvm, vif, params, type, uid, 16);\n}\n\nstatic int iwl_mvm_scan_umac_v17(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t\t struct iwl_mvm_scan_params *params, int type,\n\t\t\t\t int uid)\n{\n\treturn iwl_mvm_scan_umac_v14_and_above(mvm, vif, params, type, uid, 17);\n}\n\nstatic int iwl_mvm_num_scans(struct iwl_mvm *mvm)\n{\n\treturn hweight32(mvm->scan_status & IWL_MVM_SCAN_MASK);\n}\n\nstatic int iwl_mvm_check_running_scans(struct iwl_mvm *mvm, int type)\n{\n\tbool unified_image = fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t\t\t IWL_UCODE_TLV_CAPA_CNSLDTD_D3_D0_IMG);\n\n\t \n\n\t \n\tif ((type == IWL_MVM_SCAN_SCHED || type == IWL_MVM_SCAN_NETDETECT) &&\n\t    mvm->scan_status & (IWL_MVM_SCAN_SCHED | IWL_MVM_SCAN_NETDETECT))\n\t\treturn -EBUSY;\n\n\tif (iwl_mvm_num_scans(mvm) < mvm->max_scans)\n\t\treturn 0;\n\n\t \n\tswitch (type) {\n\tcase IWL_MVM_SCAN_REGULAR:\n\t\tif (mvm->scan_status & IWL_MVM_SCAN_REGULAR_MASK)\n\t\t\treturn -EBUSY;\n\t\treturn iwl_mvm_scan_stop(mvm, IWL_MVM_SCAN_SCHED, true);\n\tcase IWL_MVM_SCAN_SCHED:\n\t\tif (mvm->scan_status & IWL_MVM_SCAN_SCHED_MASK)\n\t\t\treturn -EBUSY;\n\t\treturn iwl_mvm_scan_stop(mvm, IWL_MVM_SCAN_REGULAR, true);\n\tcase IWL_MVM_SCAN_NETDETECT:\n\t\t \n\t\tif (!unified_image)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (mvm->scan_status & IWL_MVM_SCAN_REGULAR_MASK)\n\t\t\treturn iwl_mvm_scan_stop(mvm, IWL_MVM_SCAN_REGULAR,\n\t\t\t\t\t\t true);\n\t\tif (mvm->scan_status & IWL_MVM_SCAN_SCHED_MASK)\n\t\t\treturn iwl_mvm_scan_stop(mvm, IWL_MVM_SCAN_SCHED,\n\t\t\t\t\t\t true);\n\t\t \n\t\tfallthrough;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\treturn -EIO;\n}\n\n#define SCAN_TIMEOUT 30000\n\nvoid iwl_mvm_scan_timeout_wk(struct work_struct *work)\n{\n\tstruct delayed_work *delayed_work = to_delayed_work(work);\n\tstruct iwl_mvm *mvm = container_of(delayed_work, struct iwl_mvm,\n\t\t\t\t\t   scan_timeout_dwork);\n\n\tIWL_ERR(mvm, \"regular scan timed out\\n\");\n\n\tiwl_force_nmi(mvm->trans);\n}\n\nstatic void iwl_mvm_fill_scan_type(struct iwl_mvm *mvm,\n\t\t\t\t   struct iwl_mvm_scan_params *params,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tif (iwl_mvm_is_cdb_supported(mvm)) {\n\t\tparams->type =\n\t\t\tiwl_mvm_get_scan_type_band(mvm, vif,\n\t\t\t\t\t\t   NL80211_BAND_2GHZ);\n\t\tparams->hb_type =\n\t\t\tiwl_mvm_get_scan_type_band(mvm, vif,\n\t\t\t\t\t\t   NL80211_BAND_5GHZ);\n\t} else {\n\t\tparams->type = iwl_mvm_get_scan_type(mvm, vif);\n\t}\n}\n\nstruct iwl_scan_umac_handler {\n\tu8 version;\n\tint (*handler)(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t       struct iwl_mvm_scan_params *params, int type, int uid);\n};\n\n#define IWL_SCAN_UMAC_HANDLER(_ver) {\t\t\\\n\t.version = _ver,\t\t\t\\\n\t.handler = iwl_mvm_scan_umac_v##_ver,\t\\\n}\n\nstatic const struct iwl_scan_umac_handler iwl_scan_umac_handlers[] = {\n\t \n\tIWL_SCAN_UMAC_HANDLER(17),\n\tIWL_SCAN_UMAC_HANDLER(16),\n\tIWL_SCAN_UMAC_HANDLER(15),\n\tIWL_SCAN_UMAC_HANDLER(14),\n\tIWL_SCAN_UMAC_HANDLER(12),\n};\n\nstatic void iwl_mvm_mei_scan_work(struct work_struct *wk)\n{\n\tstruct iwl_mei_scan_filter *scan_filter =\n\t\tcontainer_of(wk, struct iwl_mei_scan_filter, scan_work);\n\tstruct iwl_mvm *mvm =\n\t\tcontainer_of(scan_filter, struct iwl_mvm, mei_scan_filter);\n\tstruct iwl_mvm_csme_conn_info *info;\n\tstruct sk_buff *skb;\n\tu8 bssid[ETH_ALEN];\n\n\tmutex_lock(&mvm->mutex);\n\tinfo = iwl_mvm_get_csme_conn_info(mvm);\n\tmemcpy(bssid, info->conn_info.bssid, ETH_ALEN);\n\tmutex_unlock(&mvm->mutex);\n\n\twhile ((skb = skb_dequeue(&scan_filter->scan_res))) {\n\t\tstruct ieee80211_mgmt *mgmt = (void *)skb->data;\n\n\t\tif (!memcmp(mgmt->bssid, bssid, ETH_ALEN))\n\t\t\tieee80211_rx_irqsafe(mvm->hw, skb);\n\t\telse\n\t\t\tkfree_skb(skb);\n\t}\n}\n\nvoid iwl_mvm_mei_scan_filter_init(struct iwl_mei_scan_filter *mei_scan_filter)\n{\n\tskb_queue_head_init(&mei_scan_filter->scan_res);\n\tINIT_WORK(&mei_scan_filter->scan_work, iwl_mvm_mei_scan_work);\n}\n\n \nstatic void iwl_mvm_mei_limited_scan(struct iwl_mvm *mvm,\n\t\t\t\t     struct iwl_mvm_scan_params *params)\n{\n\tstruct iwl_mvm_csme_conn_info *info = iwl_mvm_get_csme_conn_info(mvm);\n\tstruct iwl_mei_conn_info *conn_info;\n\tstruct ieee80211_channel *chan;\n\tint scan_iters, i;\n\n\tif (!info) {\n\t\tIWL_DEBUG_SCAN(mvm, \"mei_limited_scan: no connection info\\n\");\n\t\treturn;\n\t}\n\n\tconn_info = &info->conn_info;\n\tif (!info->conn_info.lp_state || !info->conn_info.ssid_len)\n\t\treturn;\n\n\tif (!params->n_channels || !params->n_ssids)\n\t\treturn;\n\n\tmvm->mei_scan_filter.is_mei_limited_scan = true;\n\n\tchan = ieee80211_get_channel(mvm->hw->wiphy,\n\t\t\t\t     ieee80211_channel_to_frequency(conn_info->channel,\n\t\t\t\t\t\t\t\t    conn_info->band));\n\tif (!chan) {\n\t\tIWL_DEBUG_SCAN(mvm,\n\t\t\t       \"Failed to get CSME channel (chan=%u band=%u)\\n\",\n\t\t\t       conn_info->channel, conn_info->band);\n\t\treturn;\n\t}\n\n\t \n\tscan_iters = min(IWL_MEI_SCAN_NUM_ITER, params->n_channels);\n\tparams->n_channels = scan_iters;\n\tfor (i = 0; i < scan_iters; i++)\n\t\tparams->channels[i] = chan;\n\n\tIWL_DEBUG_SCAN(mvm, \"Mei scan: num iterations=%u\\n\", scan_iters);\n\n\tparams->n_ssids = 1;\n\tparams->ssids[0].ssid_len = conn_info->ssid_len;\n\tmemcpy(params->ssids[0].ssid, conn_info->ssid, conn_info->ssid_len);\n}\n\nstatic int iwl_mvm_build_scan_cmd(struct iwl_mvm *mvm,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct iwl_host_cmd *hcmd,\n\t\t\t\t  struct iwl_mvm_scan_params *params,\n\t\t\t\t  int type)\n{\n\tint uid, i, err;\n\tu8 scan_ver;\n\n\tlockdep_assert_held(&mvm->mutex);\n\tmemset(mvm->scan_cmd, 0, mvm->scan_cmd_size);\n\n\tiwl_mvm_mei_limited_scan(mvm, params);\n\n\tif (!fw_has_capa(&mvm->fw->ucode_capa, IWL_UCODE_TLV_CAPA_UMAC_SCAN)) {\n\t\thcmd->id = SCAN_OFFLOAD_REQUEST_CMD;\n\n\t\treturn iwl_mvm_scan_lmac(mvm, vif, params);\n\t}\n\n\tuid = iwl_mvm_scan_uid_by_status(mvm, 0);\n\tif (uid < 0)\n\t\treturn uid;\n\n\thcmd->id = WIDE_ID(IWL_ALWAYS_LONG_GROUP, SCAN_REQ_UMAC);\n\n\tscan_ver = iwl_fw_lookup_cmd_ver(mvm->fw, SCAN_REQ_UMAC,\n\t\t\t\t\t IWL_FW_CMD_VER_UNKNOWN);\n\n\tfor (i = 0; i < ARRAY_SIZE(iwl_scan_umac_handlers); i++) {\n\t\tconst struct iwl_scan_umac_handler *ver_handler =\n\t\t\t&iwl_scan_umac_handlers[i];\n\n\t\tif (ver_handler->version != scan_ver)\n\t\t\tcontinue;\n\n\t\treturn ver_handler->handler(mvm, vif, params, type, uid);\n\t}\n\n\terr = iwl_mvm_scan_umac(mvm, vif, params, type, uid);\n\tif (err)\n\t\treturn err;\n\n\treturn uid;\n}\n\nstruct iwl_mvm_scan_respect_p2p_go_iter_data {\n\tstruct ieee80211_vif *current_vif;\n\tbool p2p_go;\n\tenum nl80211_band band;\n};\n\nstatic void iwl_mvm_scan_respect_p2p_go_iter(void *_data, u8 *mac,\n\t\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_scan_respect_p2p_go_iter_data *data = _data;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\t \n\tif (vif == data->current_vif)\n\t\treturn;\n\n\tif (vif->type == NL80211_IFTYPE_AP && vif->p2p) {\n\t\tu32 link_id;\n\n\t\tfor (link_id = 0;\n\t\t     link_id < ARRAY_SIZE(mvmvif->link);\n\t\t     link_id++) {\n\t\t\tstruct iwl_mvm_vif_link_info *link =\n\t\t\t\tmvmvif->link[link_id];\n\n\t\t\tif (link && link->phy_ctxt->id < NUM_PHY_CTX &&\n\t\t\t    (data->band == NUM_NL80211_BANDS ||\n\t\t\t     link->phy_ctxt->channel->band == data->band)) {\n\t\t\t\tdata->p2p_go = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic bool _iwl_mvm_get_respect_p2p_go(struct iwl_mvm *mvm,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tbool low_latency,\n\t\t\t\t\tenum nl80211_band band)\n{\n\tstruct iwl_mvm_scan_respect_p2p_go_iter_data data = {\n\t\t.current_vif = vif,\n\t\t.p2p_go = false,\n\t\t.band = band,\n\t};\n\n\tif (!low_latency)\n\t\treturn false;\n\n\tieee80211_iterate_active_interfaces_atomic(mvm->hw,\n\t\t\t\t\t\t   IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\t\t   iwl_mvm_scan_respect_p2p_go_iter,\n\t\t\t\t\t\t   &data);\n\n\treturn data.p2p_go;\n}\n\nstatic bool iwl_mvm_get_respect_p2p_go_band(struct iwl_mvm *mvm,\n\t\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t\t    enum nl80211_band band)\n{\n\tbool low_latency = iwl_mvm_low_latency_band(mvm, band);\n\n\treturn _iwl_mvm_get_respect_p2p_go(mvm, vif, low_latency, band);\n}\n\nstatic bool iwl_mvm_get_respect_p2p_go(struct iwl_mvm *mvm,\n\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tbool low_latency = iwl_mvm_low_latency(mvm);\n\n\treturn _iwl_mvm_get_respect_p2p_go(mvm, vif, low_latency,\n\t\t\t\t\t   NUM_NL80211_BANDS);\n}\n\nstatic void iwl_mvm_fill_respect_p2p_go(struct iwl_mvm *mvm,\n\t\t\t\t\tstruct iwl_mvm_scan_params *params,\n\t\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tif (iwl_mvm_is_cdb_supported(mvm)) {\n\t\tparams->respect_p2p_go =\n\t\t\tiwl_mvm_get_respect_p2p_go_band(mvm, vif,\n\t\t\t\t\t\t\tNL80211_BAND_2GHZ);\n\t\tparams->respect_p2p_go_hb =\n\t\t\tiwl_mvm_get_respect_p2p_go_band(mvm, vif,\n\t\t\t\t\t\t\tNL80211_BAND_5GHZ);\n\t} else {\n\t\tparams->respect_p2p_go = iwl_mvm_get_respect_p2p_go(mvm, vif);\n\t}\n}\n\nint iwl_mvm_reg_scan_start(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t   struct cfg80211_scan_request *req,\n\t\t\t   struct ieee80211_scan_ies *ies)\n{\n\tstruct iwl_host_cmd hcmd = {\n\t\t.len = { iwl_mvm_scan_size(mvm), },\n\t\t.data = { mvm->scan_cmd, },\n\t\t.dataflags = { IWL_HCMD_DFL_NOCOPY, },\n\t};\n\tstruct iwl_mvm_scan_params params = {};\n\tint ret, uid;\n\tstruct cfg80211_sched_scan_plan scan_plan = { .iterations = 1 };\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (iwl_mvm_is_lar_supported(mvm) && !mvm->lar_regdom_set) {\n\t\tIWL_ERR(mvm, \"scan while LAR regdomain is not set\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tret = iwl_mvm_check_running_scans(mvm, IWL_MVM_SCAN_REGULAR);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (WARN_ON(!mvm->scan_cmd))\n\t\treturn -ENOMEM;\n\n\tif (!iwl_mvm_scan_fits(mvm, req->n_ssids, ies, req->n_channels))\n\t\treturn -ENOBUFS;\n\n\tparams.n_ssids = req->n_ssids;\n\tparams.flags = req->flags;\n\tparams.n_channels = req->n_channels;\n\tparams.delay = 0;\n\tparams.ssids = req->ssids;\n\tparams.channels = req->channels;\n\tparams.mac_addr = req->mac_addr;\n\tparams.mac_addr_mask = req->mac_addr_mask;\n\tparams.no_cck = req->no_cck;\n\tparams.pass_all = true;\n\tparams.n_match_sets = 0;\n\tparams.match_sets = NULL;\n\tether_addr_copy(params.bssid, req->bssid);\n\n\tparams.scan_plans = &scan_plan;\n\tparams.n_scan_plans = 1;\n\n\tparams.n_6ghz_params = req->n_6ghz_params;\n\tparams.scan_6ghz_params = req->scan_6ghz_params;\n\tparams.scan_6ghz = req->scan_6ghz;\n\tiwl_mvm_fill_scan_type(mvm, &params, vif);\n\tiwl_mvm_fill_respect_p2p_go(mvm, &params, vif);\n\n\tif (req->duration)\n\t\tparams.iter_notif = true;\n\n\tiwl_mvm_build_scan_probe(mvm, vif, ies, &params);\n\n\tiwl_mvm_scan_6ghz_passive_scan(mvm, &params, vif);\n\n\tuid = iwl_mvm_build_scan_cmd(mvm, vif, &hcmd, &params,\n\t\t\t\t     IWL_MVM_SCAN_REGULAR);\n\n\tif (uid < 0)\n\t\treturn uid;\n\n\tiwl_mvm_pause_tcm(mvm, false);\n\n\tret = iwl_mvm_send_cmd(mvm, &hcmd);\n\tif (ret) {\n\t\t \n\t\tIWL_ERR(mvm, \"Scan failed! ret %d\\n\", ret);\n\t\tiwl_mvm_resume_tcm(mvm);\n\t\tmvm->scan_uid_status[uid] = 0;\n\t\treturn ret;\n\t}\n\n\tIWL_DEBUG_SCAN(mvm, \"Scan request was sent successfully\\n\");\n\tmvm->scan_status |= IWL_MVM_SCAN_REGULAR;\n\tmvm->scan_vif = iwl_mvm_vif_from_mac80211(vif);\n\n\tif (params.enable_6ghz_passive)\n\t\tmvm->last_6ghz_passive_scan_jiffies = jiffies;\n\n\tschedule_delayed_work(&mvm->scan_timeout_dwork,\n\t\t\t      msecs_to_jiffies(SCAN_TIMEOUT));\n\n\treturn 0;\n}\n\nint iwl_mvm_sched_scan_start(struct iwl_mvm *mvm,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct cfg80211_sched_scan_request *req,\n\t\t\t     struct ieee80211_scan_ies *ies,\n\t\t\t     int type)\n{\n\tstruct iwl_host_cmd hcmd = {\n\t\t.len = { iwl_mvm_scan_size(mvm), },\n\t\t.data = { mvm->scan_cmd, },\n\t\t.dataflags = { IWL_HCMD_DFL_NOCOPY, },\n\t};\n\tstruct iwl_mvm_scan_params params = {};\n\tint ret, uid;\n\tint i, j;\n\tbool non_psc_included = false;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (iwl_mvm_is_lar_supported(mvm) && !mvm->lar_regdom_set) {\n\t\tIWL_ERR(mvm, \"sched-scan while LAR regdomain is not set\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tret = iwl_mvm_check_running_scans(mvm, type);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (WARN_ON(!mvm->scan_cmd))\n\t\treturn -ENOMEM;\n\n\n\tparams.n_ssids = req->n_ssids;\n\tparams.flags = req->flags;\n\tparams.n_channels = req->n_channels;\n\tparams.ssids = req->ssids;\n\tparams.channels = req->channels;\n\tparams.mac_addr = req->mac_addr;\n\tparams.mac_addr_mask = req->mac_addr_mask;\n\tparams.no_cck = false;\n\tparams.pass_all =  iwl_mvm_scan_pass_all(mvm, req);\n\tparams.n_match_sets = req->n_match_sets;\n\tparams.match_sets = req->match_sets;\n\teth_broadcast_addr(params.bssid);\n\tif (!req->n_scan_plans)\n\t\treturn -EINVAL;\n\n\tparams.n_scan_plans = req->n_scan_plans;\n\tparams.scan_plans = req->scan_plans;\n\n\tiwl_mvm_fill_scan_type(mvm, &params, vif);\n\tiwl_mvm_fill_respect_p2p_go(mvm, &params, vif);\n\n\t \n\tif (req->delay > U16_MAX) {\n\t\tIWL_DEBUG_SCAN(mvm,\n\t\t\t       \"delay value is > 16-bits, set to max possible\\n\");\n\t\tparams.delay = U16_MAX;\n\t} else {\n\t\tparams.delay = req->delay;\n\t}\n\n\tret = iwl_mvm_config_sched_scan_profiles(mvm, req);\n\tif (ret)\n\t\treturn ret;\n\n\tiwl_mvm_build_scan_probe(mvm, vif, ies, &params);\n\n\t \n\tfor (i = 0; i < params.n_channels; i++) {\n\t\tstruct ieee80211_channel *channel = params.channels[i];\n\n\t\tif (channel->band == NL80211_BAND_6GHZ &&\n\t\t    !cfg80211_channel_is_psc(channel)) {\n\t\t\tnon_psc_included = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (non_psc_included) {\n\t\tparams.channels = kmemdup(params.channels,\n\t\t\t\t\t  sizeof(params.channels[0]) *\n\t\t\t\t\t  params.n_channels,\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!params.channels)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = j = 0; i < params.n_channels; i++) {\n\t\t\tif (params.channels[i]->band == NL80211_BAND_6GHZ &&\n\t\t\t    !cfg80211_channel_is_psc(params.channels[i]))\n\t\t\t\tcontinue;\n\t\t\tparams.channels[j++] = params.channels[i];\n\t\t}\n\t\tparams.n_channels = j;\n\t}\n\n\tif (non_psc_included &&\n\t    !iwl_mvm_scan_fits(mvm, req->n_ssids, ies, params.n_channels)) {\n\t\tkfree(params.channels);\n\t\treturn -ENOBUFS;\n\t}\n\n\tuid = iwl_mvm_build_scan_cmd(mvm, vif, &hcmd, &params, type);\n\n\tif (non_psc_included)\n\t\tkfree(params.channels);\n\tif (uid < 0)\n\t\treturn uid;\n\n\tret = iwl_mvm_send_cmd(mvm, &hcmd);\n\tif (!ret) {\n\t\tIWL_DEBUG_SCAN(mvm,\n\t\t\t       \"Sched scan request was sent successfully\\n\");\n\t\tmvm->scan_status |= type;\n\t} else {\n\t\t \n\t\tIWL_ERR(mvm, \"Sched scan failed! ret %d\\n\", ret);\n\t\tmvm->scan_uid_status[uid] = 0;\n\t\tmvm->sched_scan_pass_all = SCHED_SCAN_PASS_ALL_DISABLED;\n\t}\n\n\treturn ret;\n}\n\nvoid iwl_mvm_rx_umac_scan_complete_notif(struct iwl_mvm *mvm,\n\t\t\t\t\t struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_umac_scan_complete *notif = (void *)pkt->data;\n\tu32 uid = __le32_to_cpu(notif->uid);\n\tbool aborted = (notif->status == IWL_SCAN_OFFLOAD_ABORTED);\n\n\tmvm->mei_scan_filter.is_mei_limited_scan = false;\n\n\tif (WARN_ON(!(mvm->scan_uid_status[uid] & mvm->scan_status)))\n\t\treturn;\n\n\t \n\tif (mvm->scan_uid_status[uid] == IWL_MVM_SCAN_REGULAR) {\n\t\tstruct cfg80211_scan_info info = {\n\t\t\t.aborted = aborted,\n\t\t\t.scan_start_tsf = mvm->scan_start,\n\t\t};\n\n\t\tmemcpy(info.tsf_bssid, mvm->scan_vif->deflink.bssid, ETH_ALEN);\n\t\tieee80211_scan_completed(mvm->hw, &info);\n\t\tmvm->scan_vif = NULL;\n\t\tcancel_delayed_work(&mvm->scan_timeout_dwork);\n\t\tiwl_mvm_resume_tcm(mvm);\n\t} else if (mvm->scan_uid_status[uid] == IWL_MVM_SCAN_SCHED) {\n\t\tieee80211_sched_scan_stopped(mvm->hw);\n\t\tmvm->sched_scan_pass_all = SCHED_SCAN_PASS_ALL_DISABLED;\n\t}\n\n\tmvm->scan_status &= ~mvm->scan_uid_status[uid];\n\tIWL_DEBUG_SCAN(mvm,\n\t\t       \"Scan completed, uid %u type %u, status %s, EBS status %s\\n\",\n\t\t       uid, mvm->scan_uid_status[uid],\n\t\t       notif->status == IWL_SCAN_OFFLOAD_COMPLETED ?\n\t\t\t\t\"completed\" : \"aborted\",\n\t\t       iwl_mvm_ebs_status_str(notif->ebs_status));\n\tIWL_DEBUG_SCAN(mvm,\n\t\t       \"Last line %d, Last iteration %d, Time from last iteration %d\\n\",\n\t\t       notif->last_schedule, notif->last_iter,\n\t\t       __le32_to_cpu(notif->time_from_last_iter));\n\n\tif (notif->ebs_status != IWL_SCAN_EBS_SUCCESS &&\n\t    notif->ebs_status != IWL_SCAN_EBS_INACTIVE)\n\t\tmvm->last_ebs_successful = false;\n\n\tmvm->scan_uid_status[uid] = 0;\n}\n\nvoid iwl_mvm_rx_umac_scan_iter_complete_notif(struct iwl_mvm *mvm,\n\t\t\t\t\t      struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_umac_scan_iter_complete_notif *notif = (void *)pkt->data;\n\n\tmvm->scan_start = le64_to_cpu(notif->start_tsf);\n\n\tIWL_DEBUG_SCAN(mvm,\n\t\t       \"UMAC Scan iteration complete: status=0x%x scanned_channels=%d\\n\",\n\t\t       notif->status, notif->scanned_channels);\n\n\tif (mvm->sched_scan_pass_all == SCHED_SCAN_PASS_ALL_FOUND) {\n\t\tIWL_DEBUG_SCAN(mvm, \"Pass all scheduled scan results found\\n\");\n\t\tieee80211_sched_scan_results(mvm->hw);\n\t\tmvm->sched_scan_pass_all = SCHED_SCAN_PASS_ALL_ENABLED;\n\t}\n\n\tIWL_DEBUG_SCAN(mvm,\n\t\t       \"UMAC Scan iteration complete: scan started at %llu (TSF)\\n\",\n\t\t       mvm->scan_start);\n}\n\nstatic int iwl_mvm_umac_scan_abort(struct iwl_mvm *mvm, int type)\n{\n\tstruct iwl_umac_scan_abort cmd = {};\n\tint uid, ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\t \n\tuid = iwl_mvm_scan_uid_by_status(mvm, type);\n\tif (WARN_ON_ONCE(uid < 0))\n\t\treturn uid;\n\n\tcmd.uid = cpu_to_le32(uid);\n\n\tIWL_DEBUG_SCAN(mvm, \"Sending scan abort, uid %u\\n\", uid);\n\n\tret = iwl_mvm_send_cmd_pdu(mvm,\n\t\t\t\t   WIDE_ID(IWL_ALWAYS_LONG_GROUP, SCAN_ABORT_UMAC),\n\t\t\t\t   0, sizeof(cmd), &cmd);\n\tif (!ret)\n\t\tmvm->scan_uid_status[uid] = type << IWL_MVM_SCAN_STOPPING_SHIFT;\n\n\treturn ret;\n}\n\nstatic int iwl_mvm_scan_stop_wait(struct iwl_mvm *mvm, int type)\n{\n\tstruct iwl_notification_wait wait_scan_done;\n\tstatic const u16 scan_done_notif[] = { SCAN_COMPLETE_UMAC,\n\t\t\t\t\t      SCAN_OFFLOAD_COMPLETE, };\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tiwl_init_notification_wait(&mvm->notif_wait, &wait_scan_done,\n\t\t\t\t   scan_done_notif,\n\t\t\t\t   ARRAY_SIZE(scan_done_notif),\n\t\t\t\t   NULL, NULL);\n\n\tIWL_DEBUG_SCAN(mvm, \"Preparing to stop scan, type %x\\n\", type);\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa, IWL_UCODE_TLV_CAPA_UMAC_SCAN))\n\t\tret = iwl_mvm_umac_scan_abort(mvm, type);\n\telse\n\t\tret = iwl_mvm_lmac_scan_abort(mvm);\n\n\tif (ret) {\n\t\tIWL_DEBUG_SCAN(mvm, \"couldn't stop scan type %d\\n\", type);\n\t\tiwl_remove_notification(&mvm->notif_wait, &wait_scan_done);\n\t\treturn ret;\n\t}\n\n\treturn iwl_wait_notification(&mvm->notif_wait, &wait_scan_done,\n\t\t\t\t     1 * HZ);\n}\n\nstatic size_t iwl_scan_req_umac_get_size(u8 scan_ver)\n{\n\tswitch (scan_ver) {\n\tcase 12:\n\t\treturn sizeof(struct iwl_scan_req_umac_v12);\n\tcase 14:\n\tcase 15:\n\tcase 16:\n\tcase 17:\n\t\treturn sizeof(struct iwl_scan_req_umac_v17);\n\t}\n\n\treturn 0;\n}\n\nsize_t iwl_mvm_scan_size(struct iwl_mvm *mvm)\n{\n\tint base_size, tail_size;\n\tu8 scan_ver = iwl_fw_lookup_cmd_ver(mvm->fw, SCAN_REQ_UMAC,\n\t\t\t\t\t    IWL_FW_CMD_VER_UNKNOWN);\n\n\tbase_size = iwl_scan_req_umac_get_size(scan_ver);\n\tif (base_size)\n\t\treturn base_size;\n\n\n\tif (iwl_mvm_is_adaptive_dwell_v2_supported(mvm))\n\t\tbase_size = IWL_SCAN_REQ_UMAC_SIZE_V8;\n\telse if (iwl_mvm_is_adaptive_dwell_supported(mvm))\n\t\tbase_size = IWL_SCAN_REQ_UMAC_SIZE_V7;\n\telse if (iwl_mvm_cdb_scan_api(mvm))\n\t\tbase_size = IWL_SCAN_REQ_UMAC_SIZE_V6;\n\telse\n\t\tbase_size = IWL_SCAN_REQ_UMAC_SIZE_V1;\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa, IWL_UCODE_TLV_CAPA_UMAC_SCAN)) {\n\t\tif (iwl_mvm_is_scan_ext_chan_supported(mvm))\n\t\t\ttail_size = sizeof(struct iwl_scan_req_umac_tail_v2);\n\t\telse\n\t\t\ttail_size = sizeof(struct iwl_scan_req_umac_tail_v1);\n\n\t\treturn base_size +\n\t\t\tsizeof(struct iwl_scan_channel_cfg_umac) *\n\t\t\t\tmvm->fw->ucode_capa.n_scan_channels +\n\t\t\ttail_size;\n\t}\n\treturn sizeof(struct iwl_scan_req_lmac) +\n\t\tsizeof(struct iwl_scan_channel_cfg_lmac) *\n\t\tmvm->fw->ucode_capa.n_scan_channels +\n\t\tsizeof(struct iwl_scan_probe_req_v1);\n}\n\n \nvoid iwl_mvm_report_scan_aborted(struct iwl_mvm *mvm)\n{\n\tif (fw_has_capa(&mvm->fw->ucode_capa, IWL_UCODE_TLV_CAPA_UMAC_SCAN)) {\n\t\tint uid, i;\n\n\t\tuid = iwl_mvm_scan_uid_by_status(mvm, IWL_MVM_SCAN_REGULAR);\n\t\tif (uid >= 0) {\n\t\t\tstruct cfg80211_scan_info info = {\n\t\t\t\t.aborted = true,\n\t\t\t};\n\n\t\t\tcancel_delayed_work(&mvm->scan_timeout_dwork);\n\n\t\t\tieee80211_scan_completed(mvm->hw, &info);\n\t\t\tmvm->scan_uid_status[uid] = 0;\n\t\t}\n\t\tuid = iwl_mvm_scan_uid_by_status(mvm, IWL_MVM_SCAN_SCHED);\n\t\tif (uid >= 0) {\n\t\t\t \n\t\t\tif (!mvm->fw_restart)\n\t\t\t\tieee80211_sched_scan_stopped(mvm->hw);\n\t\t\tmvm->sched_scan_pass_all = SCHED_SCAN_PASS_ALL_DISABLED;\n\t\t\tmvm->scan_uid_status[uid] = 0;\n\t\t}\n\t\tuid = iwl_mvm_scan_uid_by_status(mvm,\n\t\t\t\t\t\t IWL_MVM_SCAN_STOPPING_REGULAR);\n\t\tif (uid >= 0)\n\t\t\tmvm->scan_uid_status[uid] = 0;\n\n\t\tuid = iwl_mvm_scan_uid_by_status(mvm,\n\t\t\t\t\t\t IWL_MVM_SCAN_STOPPING_SCHED);\n\t\tif (uid >= 0)\n\t\t\tmvm->scan_uid_status[uid] = 0;\n\n\t\t \n\t\tfor (i = 0; i < mvm->max_scans; i++) {\n\t\t\tif (WARN_ONCE(mvm->scan_uid_status[i],\n\t\t\t\t      \"UMAC scan UID %d status was not cleaned\\n\",\n\t\t\t\t      i))\n\t\t\t\tmvm->scan_uid_status[i] = 0;\n\t\t}\n\t} else {\n\t\tif (mvm->scan_status & IWL_MVM_SCAN_REGULAR) {\n\t\t\tstruct cfg80211_scan_info info = {\n\t\t\t\t.aborted = true,\n\t\t\t};\n\n\t\t\tcancel_delayed_work(&mvm->scan_timeout_dwork);\n\t\t\tieee80211_scan_completed(mvm->hw, &info);\n\t\t}\n\n\t\t \n\t\tif ((mvm->scan_status & IWL_MVM_SCAN_SCHED) &&\n\t\t    !mvm->fw_restart) {\n\t\t\tieee80211_sched_scan_stopped(mvm->hw);\n\t\t\tmvm->sched_scan_pass_all = SCHED_SCAN_PASS_ALL_DISABLED;\n\t\t}\n\t}\n}\n\nint iwl_mvm_scan_stop(struct iwl_mvm *mvm, int type, bool notify)\n{\n\tint ret;\n\n\tif (!(mvm->scan_status & type))\n\t\treturn 0;\n\n\tif (iwl_mvm_is_radio_killed(mvm)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = iwl_mvm_scan_stop_wait(mvm, type);\n\tif (!ret)\n\t\tmvm->scan_status |= type << IWL_MVM_SCAN_STOPPING_SHIFT;\nout:\n\t \n\tmvm->scan_status &= ~type;\n\n\tif (type == IWL_MVM_SCAN_REGULAR) {\n\t\tcancel_delayed_work(&mvm->scan_timeout_dwork);\n\t\tif (notify) {\n\t\t\tstruct cfg80211_scan_info info = {\n\t\t\t\t.aborted = true,\n\t\t\t};\n\n\t\t\tieee80211_scan_completed(mvm->hw, &info);\n\t\t}\n\t} else if (notify) {\n\t\tieee80211_sched_scan_stopped(mvm->hw);\n\t\tmvm->sched_scan_pass_all = SCHED_SCAN_PASS_ALL_DISABLED;\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}