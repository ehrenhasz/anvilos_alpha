{
  "module_name": "quota.c",
  "hash_id": "9a81cf131efaec3eb47af514c716873681e6847c194816ebe5993f2aba9b6ca4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/quota.c",
  "human_readable_source": "\n \n#include <net/mac80211.h>\n#include \"fw-api.h\"\n#include \"mvm.h\"\n\n#define QUOTA_100\tIWL_MVM_MAX_QUOTA\n#define QUOTA_LOWLAT_MIN ((QUOTA_100 * IWL_MVM_LOWLAT_QUOTA_MIN_PERCENT) / 100)\n\nstruct iwl_mvm_quota_iterator_data {\n\tint n_interfaces[MAX_BINDINGS];\n\tint colors[MAX_BINDINGS];\n\tint low_latency[MAX_BINDINGS];\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tint dbgfs_min[MAX_BINDINGS];\n#endif\n\tint n_low_latency_bindings;\n\tstruct ieee80211_vif *disabled_vif;\n};\n\nstatic void iwl_mvm_quota_iterator(void *_data, u8 *mac,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_quota_iterator_data *data = _data;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tu16 id;\n\n\t \n\tif (vif == data->disabled_vif)\n\t\treturn;\n\n\tif (!mvmvif->deflink.phy_ctxt)\n\t\treturn;\n\n\t \n\tid = mvmvif->deflink.phy_ctxt->id;\n\n\t \n\tBUILD_BUG_ON(NUM_PHY_CTX > MAX_BINDINGS);\n\n\tif (WARN_ON_ONCE(id >= MAX_BINDINGS))\n\t\treturn;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (vif->cfg.assoc)\n\t\t\tbreak;\n\t\treturn;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (mvmvif->ap_ibss_active)\n\t\t\tbreak;\n\t\treturn;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (mvmvif->monitor_active)\n\t\t\tbreak;\n\t\treturn;\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\treturn;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\tif (data->colors[id] < 0)\n\t\tdata->colors[id] = mvmvif->deflink.phy_ctxt->color;\n\telse\n\t\tWARN_ON_ONCE(data->colors[id] !=\n\t\t\t     mvmvif->deflink.phy_ctxt->color);\n\n\tdata->n_interfaces[id]++;\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tif (mvmvif->dbgfs_quota_min)\n\t\tdata->dbgfs_min[id] = max(data->dbgfs_min[id],\n\t\t\t\t\t  mvmvif->dbgfs_quota_min);\n#endif\n\n\tif (iwl_mvm_vif_low_latency(mvmvif) && !data->low_latency[id]) {\n\t\tdata->n_low_latency_bindings++;\n\t\tdata->low_latency[id] = true;\n\t}\n}\n\nstatic void iwl_mvm_adjust_quota_for_noa(struct iwl_mvm *mvm,\n\t\t\t\t\t struct iwl_time_quota_cmd *cmd)\n{\n#ifdef CONFIG_NL80211_TESTMODE\n\tstruct iwl_mvm_vif *mvmvif;\n\tint i, phy_id = -1, beacon_int = 0;\n\n\tif (!mvm->noa_duration || !mvm->noa_vif)\n\t\treturn;\n\n\tmvmvif = iwl_mvm_vif_from_mac80211(mvm->noa_vif);\n\tif (!mvmvif->ap_ibss_active)\n\t\treturn;\n\n\tphy_id = mvmvif->deflink.phy_ctxt->id;\n\tbeacon_int = mvm->noa_vif->bss_conf.beacon_int;\n\n\tfor (i = 0; i < MAX_BINDINGS; i++) {\n\t\tstruct iwl_time_quota_data *data =\n\t\t\t\t\tiwl_mvm_quota_cmd_get_quota(mvm, cmd,\n\t\t\t\t\t\t\t\t    i);\n\t\tu32 id_n_c = le32_to_cpu(data->id_and_color);\n\t\tu32 id = (id_n_c & FW_CTXT_ID_MSK) >> FW_CTXT_ID_POS;\n\t\tu32 quota = le32_to_cpu(data->quota);\n\n\t\tif (id != phy_id)\n\t\t\tcontinue;\n\n\t\tquota *= (beacon_int - mvm->noa_duration);\n\t\tquota /= beacon_int;\n\n\t\tIWL_DEBUG_QUOTA(mvm, \"quota: adjust for NoA from %d to %d\\n\",\n\t\t\t\tle32_to_cpu(data->quota), quota);\n\n\t\tdata->quota = cpu_to_le32(quota);\n\t}\n#endif\n}\n\nint iwl_mvm_update_quotas(struct iwl_mvm *mvm,\n\t\t\t  bool force_update,\n\t\t\t  struct ieee80211_vif *disabled_vif)\n{\n\tstruct iwl_time_quota_cmd cmd = {};\n\tint i, idx, err, num_active_macs, quota, quota_rem, n_non_lowlat;\n\tstruct iwl_mvm_quota_iterator_data data = {\n\t\t.n_interfaces = {},\n\t\t.colors = { -1, -1, -1, -1 },\n\t\t.disabled_vif = disabled_vif,\n\t};\n\tstruct iwl_time_quota_cmd *last = &mvm->last_quota_cmd;\n\tstruct iwl_time_quota_data *qdata, *last_data;\n\tbool send = false;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_DYNAMIC_QUOTA))\n\t\treturn 0;\n\n\t \n\tif (test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status))\n\t\treturn 0;\n\n\t \n\tBUILD_BUG_ON(MAX_BINDINGS != 4);\n\n\tieee80211_iterate_active_interfaces_atomic(\n\t\tmvm->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\tiwl_mvm_quota_iterator, &data);\n\n\t \n\tnum_active_macs = 0;\n\tfor (i = 0; i < MAX_BINDINGS; i++) {\n\t\tqdata = iwl_mvm_quota_cmd_get_quota(mvm, &cmd, i);\n\t\tqdata->id_and_color = cpu_to_le32(FW_CTXT_INVALID);\n\t\tnum_active_macs += data.n_interfaces[i];\n\t}\n\n\tn_non_lowlat = num_active_macs;\n\n\tif (data.n_low_latency_bindings == 1) {\n\t\tfor (i = 0; i < MAX_BINDINGS; i++) {\n\t\t\tif (data.low_latency[i]) {\n\t\t\t\tn_non_lowlat -= data.n_interfaces[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (data.n_low_latency_bindings == 1 && n_non_lowlat) {\n\t\t \n\t\tquota = (QUOTA_100 - QUOTA_LOWLAT_MIN) / n_non_lowlat;\n\t\tquota_rem = QUOTA_100 - n_non_lowlat * quota -\n\t\t\t    QUOTA_LOWLAT_MIN;\n\t\tIWL_DEBUG_QUOTA(mvm,\n\t\t\t\t\"quota: low-latency binding active, remaining quota per other binding: %d\\n\",\n\t\t\t\tquota);\n\t} else if (num_active_macs) {\n\t\t \n\t\tquota = QUOTA_100 / num_active_macs;\n\t\tquota_rem = QUOTA_100 % num_active_macs;\n\t\tIWL_DEBUG_QUOTA(mvm,\n\t\t\t\t\"quota: splitting evenly per binding: %d\\n\",\n\t\t\t\tquota);\n\t} else {\n\t\t \n\t\tquota = 0;\n\t\tquota_rem = 0;\n\t}\n\n\tfor (idx = 0, i = 0; i < MAX_BINDINGS; i++) {\n\t\tif (data.colors[i] < 0)\n\t\t\tcontinue;\n\n\t\tqdata = iwl_mvm_quota_cmd_get_quota(mvm, &cmd, idx);\n\n\t\tqdata->id_and_color =\n\t\t\tcpu_to_le32(FW_CMD_ID_AND_COLOR(i, data.colors[i]));\n\n\t\tif (data.n_interfaces[i] <= 0)\n\t\t\tqdata->quota = cpu_to_le32(0);\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\t\telse if (data.dbgfs_min[i])\n\t\t\tqdata->quota =\n\t\t\t\tcpu_to_le32(data.dbgfs_min[i] * QUOTA_100 / 100);\n#endif\n\t\telse if (data.n_low_latency_bindings == 1 && n_non_lowlat &&\n\t\t\t data.low_latency[i])\n\t\t\t \n\t\t\tqdata->quota = cpu_to_le32(QUOTA_LOWLAT_MIN);\n\t\telse\n\t\t\tqdata->quota =\n\t\t\t\tcpu_to_le32(quota * data.n_interfaces[i]);\n\n\t\tWARN_ONCE(le32_to_cpu(qdata->quota) > QUOTA_100,\n\t\t\t  \"Binding=%d, quota=%u > max=%u\\n\",\n\t\t\t  idx, le32_to_cpu(qdata->quota), QUOTA_100);\n\n\t\tqdata->max_duration = cpu_to_le32(0);\n\n\t\tidx++;\n\t}\n\n\t \n\tfor (i = 0; i < MAX_BINDINGS; i++) {\n\t\tqdata = iwl_mvm_quota_cmd_get_quota(mvm, &cmd, i);\n\t\tif (le32_to_cpu(qdata->quota) != 0) {\n\t\t\tle32_add_cpu(&qdata->quota, quota_rem);\n\t\t\tIWL_DEBUG_QUOTA(mvm,\n\t\t\t\t\t\"quota: giving remainder of %d to binding %d\\n\",\n\t\t\t\t\tquota_rem, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tiwl_mvm_adjust_quota_for_noa(mvm, &cmd);\n\n\t \n\tfor (i = 0; i < MAX_BINDINGS; i++) {\n\t\tqdata = iwl_mvm_quota_cmd_get_quota(mvm, &cmd, i);\n\t\tlast_data = iwl_mvm_quota_cmd_get_quota(mvm, last, i);\n\t\tif (qdata->id_and_color != last_data->id_and_color)\n\t\t\tsend = true;\n\t\tif (qdata->max_duration != last_data->max_duration)\n\t\t\tsend = true;\n\t\tif (abs((int)le32_to_cpu(qdata->quota) -\n\t\t\t(int)le32_to_cpu(last_data->quota))\n\t\t\t\t\t\t> IWL_MVM_QUOTA_THRESHOLD)\n\t\t\tsend = true;\n\t\tif (qdata->id_and_color == cpu_to_le32(FW_CTXT_INVALID))\n\t\t\tcontinue;\n\t\tWARN_ONCE(qdata->quota == 0,\n\t\t\t  \"zero quota on binding %d\\n\", i);\n\t}\n\n\tif (!send && !force_update) {\n\t\t \n\t\treturn 0;\n\t}\n\n\terr = iwl_mvm_send_cmd_pdu(mvm, TIME_QUOTA_CMD, 0,\n\t\t\t\t   iwl_mvm_quota_cmd_size(mvm), &cmd);\n\n\tif (err)\n\t\tIWL_ERR(mvm, \"Failed to send quota: %d\\n\", err);\n\telse\n\t\tmvm->last_quota_cmd = cmd;\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}