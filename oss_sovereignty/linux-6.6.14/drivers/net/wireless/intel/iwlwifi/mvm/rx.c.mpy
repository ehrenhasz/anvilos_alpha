{
  "module_name": "rx.c",
  "hash_id": "c0bff14b7f17bc2205984d84c39930accb10860b6dde9fcf44f7deea6b512e68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/rx.c",
  "human_readable_source": "\n \n#include <asm/unaligned.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include \"iwl-trans.h\"\n#include \"mvm.h\"\n#include \"fw-api.h\"\n\n \nvoid iwl_mvm_rx_rx_phy_cmd(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tunsigned int pkt_len = iwl_rx_packet_payload_len(pkt);\n\n\tif (unlikely(pkt_len < sizeof(mvm->last_phy_info)))\n\t\treturn;\n\n\tmemcpy(&mvm->last_phy_info, pkt->data, sizeof(mvm->last_phy_info));\n\tmvm->ampdu_ref++;\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tif (mvm->last_phy_info.phy_flags & cpu_to_le16(RX_RES_PHY_FLAGS_AGG)) {\n\t\tspin_lock(&mvm->drv_stats_lock);\n\t\tmvm->drv_rx_stats.ampdu_count++;\n\t\tspin_unlock(&mvm->drv_stats_lock);\n\t}\n#endif\n}\n\n \nstatic void iwl_mvm_pass_packet_to_mac80211(struct iwl_mvm *mvm,\n\t\t\t\t\t    struct ieee80211_sta *sta,\n\t\t\t\t\t    struct napi_struct *napi,\n\t\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t\t    struct ieee80211_hdr *hdr, u16 len,\n\t\t\t\t\t    u8 crypt_len,\n\t\t\t\t\t    struct iwl_rx_cmd_buffer *rxb)\n{\n\tunsigned int hdrlen = ieee80211_hdrlen(hdr->frame_control);\n\tunsigned int fraglen;\n\n\t \n\tskb_reserve(skb, hdrlen & 3);\n\n\t \n\thdrlen = (len <= skb_tailroom(skb)) ? len : hdrlen + crypt_len + 8;\n\n\tskb_put_data(skb, hdr, hdrlen);\n\tfraglen = len - hdrlen;\n\n\tif (fraglen) {\n\t\tint offset = (u8 *)hdr + hdrlen -\n\t\t\t     (u8 *)rxb_addr(rxb) + rxb_offset(rxb);\n\n\t\tskb_add_rx_frag(skb, 0, rxb_steal_page(rxb), offset,\n\t\t\t\tfraglen, rxb->truesize);\n\t}\n\n\tieee80211_rx_napi(mvm->hw, sta, skb, napi);\n}\n\n \nstatic void iwl_mvm_get_signal_strength(struct iwl_mvm *mvm,\n\t\t\t\t\tstruct iwl_rx_phy_info *phy_info,\n\t\t\t\t\tstruct ieee80211_rx_status *rx_status)\n{\n\tint energy_a, energy_b, max_energy;\n\tu32 val;\n\n\tval =\n\t    le32_to_cpu(phy_info->non_cfg_phy[IWL_RX_INFO_ENERGY_ANT_ABC_IDX]);\n\tenergy_a = (val & IWL_RX_INFO_ENERGY_ANT_A_MSK) >>\n\t\t\t\t\t\tIWL_RX_INFO_ENERGY_ANT_A_POS;\n\tenergy_a = energy_a ? -energy_a : S8_MIN;\n\tenergy_b = (val & IWL_RX_INFO_ENERGY_ANT_B_MSK) >>\n\t\t\t\t\t\tIWL_RX_INFO_ENERGY_ANT_B_POS;\n\tenergy_b = energy_b ? -energy_b : S8_MIN;\n\tmax_energy = max(energy_a, energy_b);\n\n\tIWL_DEBUG_STATS(mvm, \"energy In A %d B %d  , and max %d\\n\",\n\t\t\tenergy_a, energy_b, max_energy);\n\n\trx_status->signal = max_energy;\n\trx_status->chains = (le16_to_cpu(phy_info->phy_flags) &\n\t\t\t\tRX_RES_PHY_FLAGS_ANTENNA)\n\t\t\t\t\t>> RX_RES_PHY_FLAGS_ANTENNA_POS;\n\trx_status->chain_signal[0] = energy_a;\n\trx_status->chain_signal[1] = energy_b;\n}\n\n \nstatic u32 iwl_mvm_set_mac80211_rx_flag(struct iwl_mvm *mvm,\n\t\t\t\t\tstruct ieee80211_hdr *hdr,\n\t\t\t\t\tstruct ieee80211_rx_status *stats,\n\t\t\t\t\tu32 rx_pkt_status,\n\t\t\t\t\tu8 *crypt_len)\n{\n\tif (!ieee80211_has_protected(hdr->frame_control) ||\n\t    (rx_pkt_status & RX_MPDU_RES_STATUS_SEC_ENC_MSK) ==\n\t\t\t     RX_MPDU_RES_STATUS_SEC_NO_ENC)\n\t\treturn 0;\n\n\t \n\tif ((rx_pkt_status & RX_MPDU_RES_STATUS_SEC_ENC_MSK) ==\n\t\t\t\t\tRX_MPDU_RES_STATUS_SEC_ENC_ERR)\n\t\treturn 0;\n\n\tswitch (rx_pkt_status & RX_MPDU_RES_STATUS_SEC_ENC_MSK) {\n\tcase RX_MPDU_RES_STATUS_SEC_CCM_ENC:\n\t\t \n\t\tif (!(rx_pkt_status & RX_MPDU_RES_STATUS_MIC_OK))\n\t\t\treturn -1;\n\n\t\tstats->flag |= RX_FLAG_DECRYPTED;\n\t\t*crypt_len = IEEE80211_CCMP_HDR_LEN;\n\t\treturn 0;\n\n\tcase RX_MPDU_RES_STATUS_SEC_TKIP_ENC:\n\t\t \n\t\tif (!fw_has_api(&mvm->fw->ucode_capa,\n\t\t\t\tIWL_UCODE_TLV_API_DEPRECATE_TTAK) &&\n\t\t    !(rx_pkt_status & RX_MPDU_RES_STATUS_TTAK_OK))\n\t\t\treturn 0;\n\t\t*crypt_len = IEEE80211_TKIP_IV_LEN;\n\t\tfallthrough;\n\n\tcase RX_MPDU_RES_STATUS_SEC_WEP_ENC:\n\t\tif (!(rx_pkt_status & RX_MPDU_RES_STATUS_ICV_OK))\n\t\t\treturn -1;\n\n\t\tstats->flag |= RX_FLAG_DECRYPTED;\n\t\tif ((rx_pkt_status & RX_MPDU_RES_STATUS_SEC_ENC_MSK) ==\n\t\t\t\tRX_MPDU_RES_STATUS_SEC_WEP_ENC)\n\t\t\t*crypt_len = IEEE80211_WEP_IV_LEN;\n\t\treturn 0;\n\n\tcase RX_MPDU_RES_STATUS_SEC_EXT_ENC:\n\t\tif (!(rx_pkt_status & RX_MPDU_RES_STATUS_MIC_OK))\n\t\t\treturn -1;\n\t\tstats->flag |= RX_FLAG_DECRYPTED;\n\t\treturn 0;\n\n\tdefault:\n\t\t \n\t\tif (!mvm->monitor_on)\n\t\t\tIWL_WARN(mvm, \"Unhandled alg: 0x%x\\n\", rx_pkt_status);\n\t}\n\n\treturn 0;\n}\n\nstatic void iwl_mvm_rx_handle_tcm(struct iwl_mvm *mvm,\n\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t  struct ieee80211_hdr *hdr, u32 len,\n\t\t\t\t  struct iwl_rx_phy_info *phy_info,\n\t\t\t\t  u32 rate_n_flags)\n{\n\tstruct iwl_mvm_sta *mvmsta;\n\tstruct iwl_mvm_tcm_mac *mdata;\n\tint mac;\n\tint ac = IEEE80211_AC_BE;  \n\tstruct iwl_mvm_vif *mvmvif;\n\t \n\tstatic const u8 thresh_tpt[] = {\n\t\t9, 18, 30, 42, 60, 78, 90, 96, 120, 135,\n\t};\n\tu16 thr;\n\n\tif (ieee80211_is_data_qos(hdr->frame_control)) {\n\t\tu8 tid = ieee80211_get_tid(hdr);\n\n\t\tif (tid < IWL_MAX_TID_COUNT)\n\t\t\tac = tid_to_mac80211_ac[tid];\n\t}\n\n\tmvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tmac = mvmsta->mac_id_n_color & FW_CTXT_ID_MSK;\n\n\tif (time_after(jiffies, mvm->tcm.ts + MVM_TCM_PERIOD))\n\t\tschedule_delayed_work(&mvm->tcm.work, 0);\n\tmdata = &mvm->tcm.data[mac];\n\tmdata->rx.pkts[ac]++;\n\n\t \n\tif (mdata->rx.last_ampdu_ref != mvm->ampdu_ref) {\n\t\tmdata->rx.last_ampdu_ref = mvm->ampdu_ref;\n\t\tmdata->rx.airtime += le16_to_cpu(phy_info->frame_time);\n\t}\n\n\tif (!(rate_n_flags & (RATE_MCS_HT_MSK_V1 | RATE_MCS_VHT_MSK_V1)))\n\t\treturn;\n\n\tmvmvif = iwl_mvm_vif_from_mac80211(mvmsta->vif);\n\n\tif (mdata->opened_rx_ba_sessions ||\n\t    mdata->uapsd_nonagg_detect.detected ||\n\t    (!mvmvif->deflink.queue_params[IEEE80211_AC_VO].uapsd &&\n\t     !mvmvif->deflink.queue_params[IEEE80211_AC_VI].uapsd &&\n\t     !mvmvif->deflink.queue_params[IEEE80211_AC_BE].uapsd &&\n\t     !mvmvif->deflink.queue_params[IEEE80211_AC_BK].uapsd) ||\n\t    mvmsta->deflink.sta_id != mvmvif->deflink.ap_sta_id)\n\t\treturn;\n\n\tif (rate_n_flags & RATE_MCS_HT_MSK_V1) {\n\t\tthr = thresh_tpt[rate_n_flags & RATE_HT_MCS_RATE_CODE_MSK_V1];\n\t\tthr *= 1 + ((rate_n_flags & RATE_HT_MCS_NSS_MSK_V1) >>\n\t\t\t\t\tRATE_HT_MCS_NSS_POS_V1);\n\t} else {\n\t\tif (WARN_ON((rate_n_flags & RATE_VHT_MCS_RATE_CODE_MSK) >=\n\t\t\t\tARRAY_SIZE(thresh_tpt)))\n\t\t\treturn;\n\t\tthr = thresh_tpt[rate_n_flags & RATE_VHT_MCS_RATE_CODE_MSK];\n\t\tthr *= 1 + FIELD_GET(RATE_MCS_NSS_MSK, rate_n_flags);\n\t}\n\n\tthr <<= ((rate_n_flags & RATE_MCS_CHAN_WIDTH_MSK_V1) >>\n\t\t\t\tRATE_MCS_CHAN_WIDTH_POS);\n\n\tmdata->uapsd_nonagg_detect.rx_bytes += len;\n\tewma_rate_add(&mdata->uapsd_nonagg_detect.rate, thr);\n}\n\nstatic void iwl_mvm_rx_csum(struct ieee80211_sta *sta,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    u32 status)\n{\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(mvmsta->vif);\n\n\tif (mvmvif->features & NETIF_F_RXCSUM &&\n\t    status & RX_MPDU_RES_STATUS_CSUM_DONE &&\n\t    status & RX_MPDU_RES_STATUS_CSUM_OK)\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n}\n\n \nvoid iwl_mvm_rx_rx_mpdu(struct iwl_mvm *mvm, struct napi_struct *napi,\n\t\t\tstruct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_rx_status *rx_status;\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_rx_phy_info *phy_info;\n\tstruct iwl_rx_mpdu_res_start *rx_res;\n\tstruct ieee80211_sta *sta = NULL;\n\tstruct sk_buff *skb;\n\tu32 len, pkt_len = iwl_rx_packet_payload_len(pkt);\n\tu32 rate_n_flags;\n\tu32 rx_pkt_status;\n\tu8 crypt_len = 0;\n\n\tif (unlikely(pkt_len < sizeof(*rx_res))) {\n\t\tIWL_DEBUG_DROP(mvm, \"Bad REPLY_RX_MPDU_CMD size\\n\");\n\t\treturn;\n\t}\n\n\tphy_info = &mvm->last_phy_info;\n\trx_res = (struct iwl_rx_mpdu_res_start *)pkt->data;\n\thdr = (struct ieee80211_hdr *)(pkt->data + sizeof(*rx_res));\n\tlen = le16_to_cpu(rx_res->byte_count);\n\n\tif (unlikely(len + sizeof(*rx_res) + sizeof(__le32) > pkt_len)) {\n\t\tIWL_DEBUG_DROP(mvm, \"FW lied about packet len\\n\");\n\t\treturn;\n\t}\n\n\trx_pkt_status = get_unaligned_le32((__le32 *)\n\t\t(pkt->data + sizeof(*rx_res) + len));\n\n\t \n\tskb = alloc_skb(128, GFP_ATOMIC);\n\tif (!skb) {\n\t\tIWL_ERR(mvm, \"alloc_skb failed\\n\");\n\t\treturn;\n\t}\n\n\trx_status = IEEE80211_SKB_RXCB(skb);\n\n\t \n\tif (!(rx_pkt_status & RX_MPDU_RES_STATUS_CRC_OK) ||\n\t    !(rx_pkt_status & RX_MPDU_RES_STATUS_OVERRUN_OK)) {\n\t\tIWL_DEBUG_RX(mvm, \"Bad CRC or FIFO: 0x%08X.\\n\", rx_pkt_status);\n\t\trx_status->flag |= RX_FLAG_FAILED_FCS_CRC;\n\t}\n\n\t \n\trate_n_flags = le32_to_cpu(phy_info->rate_n_flags);\n\n\t \n\trx_status->mactime = le64_to_cpu(phy_info->timestamp);\n\trx_status->device_timestamp = le32_to_cpu(phy_info->system_timestamp);\n\trx_status->band =\n\t\t(phy_info->phy_flags & cpu_to_le16(RX_RES_PHY_FLAGS_BAND_24)) ?\n\t\t\t\tNL80211_BAND_2GHZ : NL80211_BAND_5GHZ;\n\trx_status->freq =\n\t\tieee80211_channel_to_frequency(le16_to_cpu(phy_info->channel),\n\t\t\t\t\t       rx_status->band);\n\n\t \n\trx_status->flag |= RX_FLAG_MACTIME_PLCP_START;\n\n\tiwl_mvm_get_signal_strength(mvm, phy_info, rx_status);\n\n\tIWL_DEBUG_STATS_LIMIT(mvm, \"Rssi %d, TSF %llu\\n\", rx_status->signal,\n\t\t\t      (unsigned long long)rx_status->mactime);\n\n\trcu_read_lock();\n\tif (rx_pkt_status & RX_MPDU_RES_STATUS_SRC_STA_FOUND) {\n\t\tu32 id = rx_pkt_status & RX_MPDU_RES_STATUS_STA_ID_MSK;\n\n\t\tid >>= RX_MDPU_RES_STATUS_STA_ID_SHIFT;\n\n\t\tif (!WARN_ON_ONCE(id >= mvm->fw->ucode_capa.num_stations)) {\n\t\t\tsta = rcu_dereference(mvm->fw_id_to_mac_id[id]);\n\t\t\tif (IS_ERR(sta))\n\t\t\t\tsta = NULL;\n\t\t}\n\t} else if (!is_multicast_ether_addr(hdr->addr2)) {\n\t\t \n\t\tsta = ieee80211_find_sta_by_ifaddr(mvm->hw, hdr->addr2, NULL);\n\t}\n\n\tif (sta) {\n\t\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\t\tstruct ieee80211_vif *vif = mvmsta->vif;\n\t\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\t\t \n\t\tif (is_multicast_ether_addr(hdr->addr1) &&\n\t\t    vif->type == NL80211_IFTYPE_STATION &&\n\t\t    !mvmvif->authorized &&\n\t\t    ieee80211_has_protected(hdr->frame_control)) {\n\t\t\tIWL_DEBUG_DROP(mvm, \"MCAST before the vif is authorized\\n\");\n\t\t\tkfree_skb(skb);\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tif (iwl_mvm_set_mac80211_rx_flag(mvm, hdr, rx_status, rx_pkt_status,\n\t\t\t\t\t &crypt_len)) {\n\t\tIWL_DEBUG_DROP(mvm, \"Bad decryption results 0x%08x\\n\",\n\t\t\t       rx_pkt_status);\n\t\tkfree_skb(skb);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (sta) {\n\t\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\t\tstruct ieee80211_vif *tx_blocked_vif =\n\t\t\trcu_dereference(mvm->csa_tx_blocked_vif);\n\t\tstruct iwl_fw_dbg_trigger_tlv *trig;\n\t\tstruct ieee80211_vif *vif = mvmsta->vif;\n\n\t\t \n\t\tif (unlikely(tx_blocked_vif) && vif == tx_blocked_vif) {\n\t\t\tstruct iwl_mvm_vif *mvmvif =\n\t\t\t\tiwl_mvm_vif_from_mac80211(tx_blocked_vif);\n\n\t\t\tif (mvmvif->csa_target_freq == rx_status->freq)\n\t\t\t\tiwl_mvm_sta_modify_disable_tx_ap(mvm, sta,\n\t\t\t\t\t\t\t\t false);\n\t\t}\n\n\t\trs_update_last_rssi(mvm, mvmsta, rx_status);\n\n\t\ttrig = iwl_fw_dbg_trigger_on(&mvm->fwrt,\n\t\t\t\t\t     ieee80211_vif_to_wdev(vif),\n\t\t\t\t\t     FW_DBG_TRIGGER_RSSI);\n\n\t\tif (trig && ieee80211_is_beacon(hdr->frame_control)) {\n\t\t\tstruct iwl_fw_dbg_trigger_low_rssi *rssi_trig;\n\t\t\ts32 rssi;\n\n\t\t\trssi_trig = (void *)trig->data;\n\t\t\trssi = le32_to_cpu(rssi_trig->rssi);\n\n\t\t\tif (rx_status->signal < rssi)\n\t\t\t\tiwl_fw_dbg_collect_trig(&mvm->fwrt, trig,\n\t\t\t\t\t\t\tNULL);\n\t\t}\n\n\t\tif (!mvm->tcm.paused && len >= sizeof(*hdr) &&\n\t\t    !is_multicast_ether_addr(hdr->addr1) &&\n\t\t    ieee80211_is_data(hdr->frame_control))\n\t\t\tiwl_mvm_rx_handle_tcm(mvm, sta, hdr, len, phy_info,\n\t\t\t\t\t      rate_n_flags);\n\n\t\tif (ieee80211_is_data(hdr->frame_control))\n\t\t\tiwl_mvm_rx_csum(sta, skb, rx_pkt_status);\n\t}\n\trcu_read_unlock();\n\n\t \n\tif (phy_info->phy_flags & cpu_to_le16(RX_RES_PHY_FLAGS_SHORT_PREAMBLE))\n\t\trx_status->enc_flags |= RX_ENC_FLAG_SHORTPRE;\n\n\tif (phy_info->phy_flags & cpu_to_le16(RX_RES_PHY_FLAGS_AGG)) {\n\t\t \n\t\trx_status->flag |= RX_FLAG_AMPDU_DETAILS;\n\t\trx_status->ampdu_reference = mvm->ampdu_ref;\n\t}\n\n\t \n\tswitch (rate_n_flags & RATE_MCS_CHAN_WIDTH_MSK_V1) {\n\tcase RATE_MCS_CHAN_WIDTH_20:\n\t\tbreak;\n\tcase RATE_MCS_CHAN_WIDTH_40:\n\t\trx_status->bw = RATE_INFO_BW_40;\n\t\tbreak;\n\tcase RATE_MCS_CHAN_WIDTH_80:\n\t\trx_status->bw = RATE_INFO_BW_80;\n\t\tbreak;\n\tcase RATE_MCS_CHAN_WIDTH_160:\n\t\trx_status->bw = RATE_INFO_BW_160;\n\t\tbreak;\n\t}\n\tif (!(rate_n_flags & RATE_MCS_CCK_MSK_V1) &&\n\t    rate_n_flags & RATE_MCS_SGI_MSK_V1)\n\t\trx_status->enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\tif (rate_n_flags & RATE_HT_MCS_GF_MSK)\n\t\trx_status->enc_flags |= RX_ENC_FLAG_HT_GF;\n\tif (rate_n_flags & RATE_MCS_LDPC_MSK_V1)\n\t\trx_status->enc_flags |= RX_ENC_FLAG_LDPC;\n\tif (rate_n_flags & RATE_MCS_HT_MSK_V1) {\n\t\tu8 stbc = (rate_n_flags & RATE_MCS_STBC_MSK) >>\n\t\t\t\tRATE_MCS_STBC_POS;\n\t\trx_status->encoding = RX_ENC_HT;\n\t\trx_status->rate_idx = rate_n_flags & RATE_HT_MCS_INDEX_MSK_V1;\n\t\trx_status->enc_flags |= stbc << RX_ENC_FLAG_STBC_SHIFT;\n\t} else if (rate_n_flags & RATE_MCS_VHT_MSK_V1) {\n\t\tu8 stbc = (rate_n_flags & RATE_MCS_STBC_MSK) >>\n\t\t\t\tRATE_MCS_STBC_POS;\n\t\trx_status->nss =\n\t\t\tFIELD_GET(RATE_MCS_NSS_MSK, rate_n_flags) + 1;\n\t\trx_status->rate_idx = rate_n_flags & RATE_VHT_MCS_RATE_CODE_MSK;\n\t\trx_status->encoding = RX_ENC_VHT;\n\t\trx_status->enc_flags |= stbc << RX_ENC_FLAG_STBC_SHIFT;\n\t\tif (rate_n_flags & RATE_MCS_BF_MSK)\n\t\t\trx_status->enc_flags |= RX_ENC_FLAG_BF;\n\t} else {\n\t\tint rate = iwl_mvm_legacy_rate_to_mac80211_idx(rate_n_flags,\n\t\t\t\t\t\t\t       rx_status->band);\n\n\t\tif (WARN(rate < 0 || rate > 0xFF,\n\t\t\t \"Invalid rate flags 0x%x, band %d,\\n\",\n\t\t\t rate_n_flags, rx_status->band)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t\trx_status->rate_idx = rate;\n\t}\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tiwl_mvm_update_frame_stats(mvm, rate_n_flags,\n\t\t\t\t   rx_status->flag & RX_FLAG_AMPDU_DETAILS);\n#endif\n\n\tif (unlikely((ieee80211_is_beacon(hdr->frame_control) ||\n\t\t      ieee80211_is_probe_resp(hdr->frame_control)) &&\n\t\t     mvm->sched_scan_pass_all == SCHED_SCAN_PASS_ALL_ENABLED))\n\t\tmvm->sched_scan_pass_all = SCHED_SCAN_PASS_ALL_FOUND;\n\n\tif (unlikely(ieee80211_is_beacon(hdr->frame_control) ||\n\t\t     ieee80211_is_probe_resp(hdr->frame_control)))\n\t\trx_status->boottime_ns = ktime_get_boottime_ns();\n\n\tiwl_mvm_pass_packet_to_mac80211(mvm, sta, napi, skb, hdr, len,\n\t\t\t\t\tcrypt_len, rxb);\n}\n\nstruct iwl_mvm_stat_data {\n\tstruct iwl_mvm *mvm;\n\t__le32 flags;\n\t__le32 mac_id;\n\tu8 beacon_filter_average_energy;\n\t__le32 *beacon_counter;\n\tu8 *beacon_average_energy;\n};\n\nstruct iwl_mvm_stat_data_all_macs {\n\tstruct iwl_mvm *mvm;\n\t__le32 flags;\n\tstruct iwl_statistics_ntfy_per_mac *per_mac_stats;\n};\n\nstatic void iwl_mvm_update_vif_sig(struct ieee80211_vif *vif, int sig)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm *mvm = mvmvif->mvm;\n\tint thold = vif->bss_conf.cqm_rssi_thold;\n\tint hyst = vif->bss_conf.cqm_rssi_hyst;\n\tint last_event;\n\n\tif (sig == 0) {\n\t\tIWL_DEBUG_RX(mvm, \"RSSI is 0 - skip signal based decision\\n\");\n\t\treturn;\n\t}\n\n\tmvmvif->bf_data.ave_beacon_signal = sig;\n\n\t \n\tif (mvmvif->bf_data.bt_coex_min_thold !=\n\t    mvmvif->bf_data.bt_coex_max_thold) {\n\t\tlast_event = mvmvif->bf_data.last_bt_coex_event;\n\t\tif (sig > mvmvif->bf_data.bt_coex_max_thold &&\n\t\t    (last_event <= mvmvif->bf_data.bt_coex_min_thold ||\n\t\t     last_event == 0)) {\n\t\t\tmvmvif->bf_data.last_bt_coex_event = sig;\n\t\t\tIWL_DEBUG_RX(mvm, \"cqm_iterator bt coex high %d\\n\",\n\t\t\t\t     sig);\n\t\t\tiwl_mvm_bt_rssi_event(mvm, vif, RSSI_EVENT_HIGH);\n\t\t} else if (sig < mvmvif->bf_data.bt_coex_min_thold &&\n\t\t\t   (last_event >= mvmvif->bf_data.bt_coex_max_thold ||\n\t\t\t    last_event == 0)) {\n\t\t\tmvmvif->bf_data.last_bt_coex_event = sig;\n\t\t\tIWL_DEBUG_RX(mvm, \"cqm_iterator bt coex low %d\\n\",\n\t\t\t\t     sig);\n\t\t\tiwl_mvm_bt_rssi_event(mvm, vif, RSSI_EVENT_LOW);\n\t\t}\n\t}\n\n\tif (!(vif->driver_flags & IEEE80211_VIF_SUPPORTS_CQM_RSSI))\n\t\treturn;\n\n\t \n\tlast_event = mvmvif->bf_data.last_cqm_event;\n\tif (thold && sig < thold && (last_event == 0 ||\n\t\t\t\t     sig < last_event - hyst)) {\n\t\tmvmvif->bf_data.last_cqm_event = sig;\n\t\tIWL_DEBUG_RX(mvm, \"cqm_iterator cqm low %d\\n\",\n\t\t\t     sig);\n\t\tieee80211_cqm_rssi_notify(\n\t\t\tvif,\n\t\t\tNL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,\n\t\t\tsig,\n\t\t\tGFP_KERNEL);\n\t} else if (sig > thold &&\n\t\t   (last_event == 0 || sig > last_event + hyst)) {\n\t\tmvmvif->bf_data.last_cqm_event = sig;\n\t\tIWL_DEBUG_RX(mvm, \"cqm_iterator cqm high %d\\n\",\n\t\t\t     sig);\n\t\tieee80211_cqm_rssi_notify(\n\t\t\tvif,\n\t\t\tNL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,\n\t\t\tsig,\n\t\t\tGFP_KERNEL);\n\t}\n}\n\nstatic void iwl_mvm_stat_iterator(void *_data, u8 *mac,\n\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_stat_data *data = _data;\n\tint sig = -data->beacon_filter_average_energy;\n\tu16 id = le32_to_cpu(data->mac_id);\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tu16 vif_id = mvmvif->id;\n\n\t \n\tmvmvif->deflink.beacon_stats.num_beacons =\n\t\tle32_to_cpu(data->beacon_counter[vif_id]);\n\tmvmvif->deflink.beacon_stats.avg_signal =\n\t\t-data->beacon_average_energy[vif_id];\n\n\tif (mvmvif->id != id)\n\t\treturn;\n\n\tif (vif->type != NL80211_IFTYPE_STATION)\n\t\treturn;\n\n\t \n\tif (le32_to_cpu(data->flags) & IWL_STATISTICS_REPLY_FLG_CLEAR)\n\t\tmvmvif->deflink.beacon_stats.accu_num_beacons +=\n\t\t\tmvmvif->deflink.beacon_stats.num_beacons;\n\n\tiwl_mvm_update_vif_sig(vif, sig);\n}\n\nstatic void iwl_mvm_stat_iterator_all_macs(void *_data, u8 *mac,\n\t\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_stat_data_all_macs *data = _data;\n\tstruct iwl_statistics_ntfy_per_mac *mac_stats;\n\tint sig;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tu16 vif_id = mvmvif->id;\n\n\tif (WARN_ONCE(vif_id >= MAC_INDEX_AUX, \"invalid vif id: %d\", vif_id))\n\t\treturn;\n\n\tif (vif->type != NL80211_IFTYPE_STATION)\n\t\treturn;\n\n\tmac_stats = &data->per_mac_stats[vif_id];\n\n\tmvmvif->deflink.beacon_stats.num_beacons =\n\t\tle32_to_cpu(mac_stats->beacon_counter);\n\tmvmvif->deflink.beacon_stats.avg_signal =\n\t\t-le32_to_cpu(mac_stats->beacon_average_energy);\n\n\t \n\tif (le32_to_cpu(data->flags) & IWL_STATISTICS_REPLY_FLG_CLEAR)\n\t\tmvmvif->deflink.beacon_stats.accu_num_beacons +=\n\t\t\tmvmvif->deflink.beacon_stats.num_beacons;\n\n\tsig = -le32_to_cpu(mac_stats->beacon_filter_average_energy);\n\tiwl_mvm_update_vif_sig(vif, sig);\n}\n\nstatic inline void\niwl_mvm_rx_stats_check_trigger(struct iwl_mvm *mvm, struct iwl_rx_packet *pkt)\n{\n\tstruct iwl_fw_dbg_trigger_tlv *trig;\n\tstruct iwl_fw_dbg_trigger_stats *trig_stats;\n\tu32 trig_offset, trig_thold;\n\n\ttrig = iwl_fw_dbg_trigger_on(&mvm->fwrt, NULL, FW_DBG_TRIGGER_STATS);\n\tif (!trig)\n\t\treturn;\n\n\ttrig_stats = (void *)trig->data;\n\n\ttrig_offset = le32_to_cpu(trig_stats->stop_offset);\n\ttrig_thold = le32_to_cpu(trig_stats->stop_threshold);\n\n\tif (WARN_ON_ONCE(trig_offset >= iwl_rx_packet_payload_len(pkt)))\n\t\treturn;\n\n\tif (le32_to_cpup((__le32 *) (pkt->data + trig_offset)) < trig_thold)\n\t\treturn;\n\n\tiwl_fw_dbg_collect_trig(&mvm->fwrt, trig, NULL);\n}\n\nstatic void iwl_mvm_stats_energy_iter(void *_data,\n\t\t\t\t      struct ieee80211_sta *sta)\n{\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tu8 *energy = _data;\n\tu32 sta_id = mvmsta->deflink.sta_id;\n\n\tif (WARN_ONCE(sta_id >= IWL_MVM_STATION_COUNT_MAX, \"sta_id %d >= %d\",\n\t\t      sta_id, IWL_MVM_STATION_COUNT_MAX))\n\t\treturn;\n\n\tif (energy[sta_id])\n\t\tmvmsta->deflink.avg_energy = energy[sta_id];\n\n}\n\nstatic void\niwl_mvm_update_tcm_from_stats(struct iwl_mvm *mvm, __le32 *air_time_le,\n\t\t\t      __le32 *rx_bytes_le)\n{\n\tint i;\n\n\tspin_lock(&mvm->tcm.lock);\n\tfor (i = 0; i < NUM_MAC_INDEX_DRIVER; i++) {\n\t\tstruct iwl_mvm_tcm_mac *mdata = &mvm->tcm.data[i];\n\t\tu32 rx_bytes = le32_to_cpu(rx_bytes_le[i]);\n\t\tu32 airtime = le32_to_cpu(air_time_le[i]);\n\n\t\tmdata->rx.airtime += airtime;\n\t\tmdata->uapsd_nonagg_detect.rx_bytes += rx_bytes;\n\t\tif (airtime) {\n\t\t\t \n\t\t\tewma_rate_init(&mdata->uapsd_nonagg_detect.rate);\n\t\t\tewma_rate_add(&mdata->uapsd_nonagg_detect.rate,\n\t\t\t\t      rx_bytes * 8 / airtime);\n\t\t}\n\t}\n\tspin_unlock(&mvm->tcm.lock);\n}\n\nstatic void\niwl_mvm_stats_ver_15(struct iwl_mvm *mvm,\n\t\t     struct iwl_statistics_operational_ntfy *stats)\n{\n\tstruct iwl_mvm_stat_data_all_macs data = {\n\t\t.mvm = mvm,\n\t\t.flags = stats->flags,\n\t\t.per_mac_stats = stats->per_mac_stats,\n\t};\n\n\tieee80211_iterate_active_interfaces(mvm->hw,\n\t\t\t\t\t    IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\t    iwl_mvm_stat_iterator_all_macs,\n\t\t\t\t\t    &data);\n}\n\nstatic void\niwl_mvm_stats_ver_14(struct iwl_mvm *mvm,\n\t\t     struct iwl_statistics_operational_ntfy_ver_14 *stats)\n{\n\tstruct iwl_mvm_stat_data data = {\n\t\t.mvm = mvm,\n\t};\n\n\tu8 beacon_average_energy[MAC_INDEX_AUX];\n\t__le32 flags;\n\tint i;\n\n\tflags = stats->flags;\n\n\tdata.mac_id = stats->mac_id;\n\tdata.beacon_filter_average_energy =\n\t\tle32_to_cpu(stats->beacon_filter_average_energy);\n\tdata.flags = flags;\n\tdata.beacon_counter = stats->beacon_counter;\n\n\tfor (i = 0; i < ARRAY_SIZE(beacon_average_energy); i++)\n\t\tbeacon_average_energy[i] =\n\t\t\tle32_to_cpu(stats->beacon_average_energy[i]);\n\n\tdata.beacon_average_energy = beacon_average_energy;\n\n\tieee80211_iterate_active_interfaces(mvm->hw,\n\t\t\t\t\t    IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\t    iwl_mvm_stat_iterator,\n\t\t\t\t\t    &data);\n}\n\nstatic bool iwl_mvm_verify_stats_len(struct iwl_mvm *mvm,\n\t\t\t\t     struct iwl_rx_packet *pkt,\n\t\t\t\t     u32 expected_size)\n{\n\tstruct iwl_statistics_ntfy_hdr *hdr;\n\n\tif (WARN_ONCE(iwl_rx_packet_payload_len(pkt) < expected_size,\n\t\t      \"received invalid statistics size (%d)!, expected_size: %d\\n\",\n\t\t      iwl_rx_packet_payload_len(pkt), expected_size))\n\t\treturn false;\n\n\thdr = (void *)&pkt->data;\n\n\tif (WARN_ONCE((hdr->type & IWL_STATISTICS_TYPE_MSK) != FW_STATISTICS_OPERATIONAL ||\n\t\t      hdr->version !=\n\t\t      iwl_fw_lookup_notif_ver(mvm->fw, LEGACY_GROUP, STATISTICS_NOTIFICATION, 0),\n\t\t      \"received unsupported hdr type %d, version %d\\n\",\n\t\t      hdr->type, hdr->version))\n\t\treturn false;\n\n\tif (WARN_ONCE(le16_to_cpu(hdr->size) != expected_size,\n\t\t      \"received invalid statistics size in header (%d)!, expected_size: %d\\n\",\n\t\t      le16_to_cpu(hdr->size), expected_size))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void\niwl_mvm_handle_rx_statistics_tlv(struct iwl_mvm *mvm,\n\t\t\t\t struct iwl_rx_packet *pkt)\n{\n\tu8 average_energy[IWL_MVM_STATION_COUNT_MAX];\n\t__le32 air_time[MAC_INDEX_AUX];\n\t__le32 rx_bytes[MAC_INDEX_AUX];\n\t__le32 flags = 0;\n\tint i;\n\tu32 notif_ver = iwl_fw_lookup_notif_ver(mvm->fw, LEGACY_GROUP,\n\t\t\t\t\t      STATISTICS_NOTIFICATION, 0);\n\n\tif (WARN_ONCE(notif_ver > 15,\n\t\t      \"invalid statistics version id: %d\\n\", notif_ver))\n\t\treturn;\n\n\tif (notif_ver == 14) {\n\t\tstruct iwl_statistics_operational_ntfy_ver_14 *stats =\n\t\t\t(void *)pkt->data;\n\n\t\tif (!iwl_mvm_verify_stats_len(mvm, pkt, sizeof(*stats)))\n\t\t\treturn;\n\n\t\tiwl_mvm_stats_ver_14(mvm, stats);\n\n\t\tflags = stats->flags;\n\t\tmvm->radio_stats.rx_time = le64_to_cpu(stats->rx_time);\n\t\tmvm->radio_stats.tx_time = le64_to_cpu(stats->tx_time);\n\t\tmvm->radio_stats.on_time_rf = le64_to_cpu(stats->on_time_rf);\n\t\tmvm->radio_stats.on_time_scan =\n\t\t\tle64_to_cpu(stats->on_time_scan);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(average_energy); i++)\n\t\t\taverage_energy[i] = le32_to_cpu(stats->average_energy[i]);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(air_time); i++) {\n\t\t\tair_time[i] = stats->air_time[i];\n\t\t\trx_bytes[i] = stats->rx_bytes[i];\n\t\t}\n\t}\n\n\tif (notif_ver == 15) {\n\t\tstruct iwl_statistics_operational_ntfy *stats =\n\t\t\t(void *)pkt->data;\n\n\t\tif (!iwl_mvm_verify_stats_len(mvm, pkt, sizeof(*stats)))\n\t\t\treturn;\n\n\t\tiwl_mvm_stats_ver_15(mvm, stats);\n\n\t\tflags = stats->flags;\n\t\tmvm->radio_stats.rx_time = le64_to_cpu(stats->rx_time);\n\t\tmvm->radio_stats.tx_time = le64_to_cpu(stats->tx_time);\n\t\tmvm->radio_stats.on_time_rf = le64_to_cpu(stats->on_time_rf);\n\t\tmvm->radio_stats.on_time_scan =\n\t\t\tle64_to_cpu(stats->on_time_scan);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(average_energy); i++)\n\t\t\taverage_energy[i] =\n\t\t\t\tle32_to_cpu(stats->per_sta_stats[i].average_energy);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(air_time); i++) {\n\t\t\tair_time[i] = stats->per_mac_stats[i].air_time;\n\t\t\trx_bytes[i] = stats->per_mac_stats[i].rx_bytes;\n\t\t}\n\t}\n\n\tiwl_mvm_rx_stats_check_trigger(mvm, pkt);\n\n\tieee80211_iterate_stations_atomic(mvm->hw, iwl_mvm_stats_energy_iter,\n\t\t\t\t\t  average_energy);\n\t \n\tif (le32_to_cpu(flags) & IWL_STATISTICS_REPLY_FLG_CLEAR)\n\t\tiwl_mvm_update_tcm_from_stats(mvm, air_time, rx_bytes);\n}\n\nvoid iwl_mvm_handle_rx_statistics(struct iwl_mvm *mvm,\n\t\t\t\t  struct iwl_rx_packet *pkt)\n{\n\tstruct iwl_mvm_stat_data data = {\n\t\t.mvm = mvm,\n\t};\n\t__le32 *bytes, *air_time, flags;\n\tint expected_size;\n\tu8 *energy;\n\n\t \n\tif (iwl_fw_lookup_notif_ver(mvm->fw, LEGACY_GROUP,\n\t\t\t\t    STATISTICS_NOTIFICATION, 0) >= 14)\n\t\treturn iwl_mvm_handle_rx_statistics_tlv(mvm, pkt);\n\n\tif (!iwl_mvm_has_new_rx_stats_api(mvm)) {\n\t\tif (iwl_mvm_has_new_rx_api(mvm))\n\t\t\texpected_size = sizeof(struct iwl_notif_statistics_v11);\n\t\telse\n\t\t\texpected_size = sizeof(struct iwl_notif_statistics_v10);\n\t} else {\n\t\texpected_size = sizeof(struct iwl_notif_statistics);\n\t}\n\n\tif (WARN_ONCE(iwl_rx_packet_payload_len(pkt) != expected_size,\n\t\t      \"received invalid statistics size (%d)!\\n\",\n\t\t      iwl_rx_packet_payload_len(pkt)))\n\t\treturn;\n\n\tif (!iwl_mvm_has_new_rx_stats_api(mvm)) {\n\t\tstruct iwl_notif_statistics_v11 *stats = (void *)&pkt->data;\n\n\t\tdata.mac_id = stats->rx.general.mac_id;\n\t\tdata.beacon_filter_average_energy =\n\t\t\tstats->general.common.beacon_filter_average_energy;\n\n\t\tmvm->rx_stats_v3 = stats->rx;\n\n\t\tmvm->radio_stats.rx_time =\n\t\t\tle64_to_cpu(stats->general.common.rx_time);\n\t\tmvm->radio_stats.tx_time =\n\t\t\tle64_to_cpu(stats->general.common.tx_time);\n\t\tmvm->radio_stats.on_time_rf =\n\t\t\tle64_to_cpu(stats->general.common.on_time_rf);\n\t\tmvm->radio_stats.on_time_scan =\n\t\t\tle64_to_cpu(stats->general.common.on_time_scan);\n\n\t\tdata.beacon_counter = stats->general.beacon_counter;\n\t\tdata.beacon_average_energy =\n\t\t\tstats->general.beacon_average_energy;\n\t\tflags = stats->flag;\n\t} else {\n\t\tstruct iwl_notif_statistics *stats = (void *)&pkt->data;\n\n\t\tdata.mac_id = stats->rx.general.mac_id;\n\t\tdata.beacon_filter_average_energy =\n\t\t\tstats->general.common.beacon_filter_average_energy;\n\n\t\tmvm->rx_stats = stats->rx;\n\n\t\tmvm->radio_stats.rx_time =\n\t\t\tle64_to_cpu(stats->general.common.rx_time);\n\t\tmvm->radio_stats.tx_time =\n\t\t\tle64_to_cpu(stats->general.common.tx_time);\n\t\tmvm->radio_stats.on_time_rf =\n\t\t\tle64_to_cpu(stats->general.common.on_time_rf);\n\t\tmvm->radio_stats.on_time_scan =\n\t\t\tle64_to_cpu(stats->general.common.on_time_scan);\n\n\t\tdata.beacon_counter = stats->general.beacon_counter;\n\t\tdata.beacon_average_energy =\n\t\t\tstats->general.beacon_average_energy;\n\t\tflags = stats->flag;\n\t}\n\tdata.flags = flags;\n\n\tiwl_mvm_rx_stats_check_trigger(mvm, pkt);\n\n\tieee80211_iterate_active_interfaces(mvm->hw,\n\t\t\t\t\t    IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\t    iwl_mvm_stat_iterator,\n\t\t\t\t\t    &data);\n\n\tif (!iwl_mvm_has_new_rx_api(mvm))\n\t\treturn;\n\n\tif (!iwl_mvm_has_new_rx_stats_api(mvm)) {\n\t\tstruct iwl_notif_statistics_v11 *v11 = (void *)&pkt->data;\n\n\t\tenergy = (void *)&v11->load_stats.avg_energy;\n\t\tbytes = (void *)&v11->load_stats.byte_count;\n\t\tair_time = (void *)&v11->load_stats.air_time;\n\t} else {\n\t\tstruct iwl_notif_statistics *stats = (void *)&pkt->data;\n\n\t\tenergy = (void *)&stats->load_stats.avg_energy;\n\t\tbytes = (void *)&stats->load_stats.byte_count;\n\t\tair_time = (void *)&stats->load_stats.air_time;\n\t}\n\tieee80211_iterate_stations_atomic(mvm->hw, iwl_mvm_stats_energy_iter,\n\t\t\t\t\t  energy);\n\n\t \n\tif (le32_to_cpu(flags) & IWL_STATISTICS_REPLY_FLG_CLEAR)\n\t\tiwl_mvm_update_tcm_from_stats(mvm, air_time, bytes);\n\n}\n\nvoid iwl_mvm_rx_statistics(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb)\n{\n\tiwl_mvm_handle_rx_statistics(mvm, rxb_addr(rxb));\n}\n\nvoid iwl_mvm_window_status_notif(struct iwl_mvm *mvm,\n\t\t\t\t struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_ba_window_status_notif *notif = (void *)pkt->data;\n\tint i;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(notif->ra_tid) != BA_WINDOW_STREAMS_MAX);\n\tBUILD_BUG_ON(ARRAY_SIZE(notif->mpdu_rx_count) != BA_WINDOW_STREAMS_MAX);\n\tBUILD_BUG_ON(ARRAY_SIZE(notif->bitmap) != BA_WINDOW_STREAMS_MAX);\n\tBUILD_BUG_ON(ARRAY_SIZE(notif->start_seq_num) != BA_WINDOW_STREAMS_MAX);\n\n\trcu_read_lock();\n\tfor (i = 0; i < BA_WINDOW_STREAMS_MAX; i++) {\n\t\tstruct ieee80211_sta *sta;\n\t\tu8 sta_id, tid;\n\t\tu64 bitmap;\n\t\tu32 ssn;\n\t\tu16 ratid;\n\t\tu16 received_mpdu;\n\n\t\tratid = le16_to_cpu(notif->ra_tid[i]);\n\t\t \n\t\tif (!(ratid & BA_WINDOW_STATUS_VALID_MSK))\n\t\t\tcontinue;\n\n\t\treceived_mpdu = le16_to_cpu(notif->mpdu_rx_count[i]);\n\t\tif (received_mpdu == 0)\n\t\t\tcontinue;\n\n\t\ttid = ratid & BA_WINDOW_STATUS_TID_MSK;\n\t\t \n\t\tsta_id = (ratid & BA_WINDOW_STATUS_STA_ID_MSK)\n\t\t\t >> BA_WINDOW_STATUS_STA_ID_POS;\n\t\tsta = rcu_dereference(mvm->fw_id_to_mac_id[sta_id]);\n\t\tif (IS_ERR_OR_NULL(sta))\n\t\t\tcontinue;\n\t\tbitmap = le64_to_cpu(notif->bitmap[i]);\n\t\tssn = le32_to_cpu(notif->start_seq_num[i]);\n\n\t\t \n\t\tieee80211_mark_rx_ba_filtered_frames(sta, tid, ssn, bitmap,\n\t\t\t\t\t\t     received_mpdu);\n\t}\n\trcu_read_unlock();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}