{
  "module_name": "phy-ctxt.c",
  "hash_id": "fe42f6e5cef1bc0087058fa7e5e67163b71bff637205806165282d1e8dfe170d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/phy-ctxt.c",
  "human_readable_source": "\n \n#include <net/mac80211.h>\n#include \"fw-api.h\"\n#include \"mvm.h\"\n\n \nu8 iwl_mvm_get_channel_width(struct cfg80211_chan_def *chandef)\n{\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\tcase NL80211_CHAN_WIDTH_20:\n\t\treturn IWL_PHY_CHANNEL_MODE20;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\treturn IWL_PHY_CHANNEL_MODE40;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\treturn IWL_PHY_CHANNEL_MODE80;\n\tcase NL80211_CHAN_WIDTH_160:\n\t\treturn IWL_PHY_CHANNEL_MODE160;\n\tcase NL80211_CHAN_WIDTH_320:\n\t\treturn IWL_PHY_CHANNEL_MODE320;\n\tdefault:\n\t\tWARN(1, \"Invalid channel width=%u\", chandef->width);\n\t\treturn IWL_PHY_CHANNEL_MODE20;\n\t}\n}\n\n \nu8 iwl_mvm_get_ctrl_pos(struct cfg80211_chan_def *chandef)\n{\n\tint offs = chandef->chan->center_freq - chandef->center_freq1;\n\tint abs_offs = abs(offs);\n\tu8 ret;\n\n\tif (offs == 0) {\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tret = (abs_offs - 10) / 20;\n\t \n\tret = (ret & IWL_PHY_CTRL_POS_OFFS_MSK) |\n\t      ((ret & BIT(2)) << 1);\n\t \n\tret |= (offs > 0) * IWL_PHY_CTRL_POS_ABOVE;\n\n\treturn ret;\n}\n\n \nstatic void iwl_mvm_phy_ctxt_cmd_hdr(struct iwl_mvm_phy_ctxt *ctxt,\n\t\t\t\t     struct iwl_phy_context_cmd *cmd,\n\t\t\t\t     u32 action)\n{\n\tcmd->id_and_color = cpu_to_le32(FW_CMD_ID_AND_COLOR(ctxt->id,\n\t\t\t\t\t\t\t    ctxt->color));\n\tcmd->action = cpu_to_le32(action);\n}\n\nstatic void iwl_mvm_phy_ctxt_set_rxchain(struct iwl_mvm *mvm,\n\t\t\t\t\t struct iwl_mvm_phy_ctxt *ctxt,\n\t\t\t\t\t __le32 *rxchain_info,\n\t\t\t\t\t u8 chains_static,\n\t\t\t\t\t u8 chains_dynamic)\n{\n\tu8 active_cnt, idle_cnt;\n\n\t \n\tidle_cnt = chains_static;\n\tactive_cnt = chains_dynamic;\n\n\t \n\tif (active_cnt == 1 && iwl_mvm_rx_diversity_allowed(mvm, ctxt)) {\n\t\tidle_cnt = 2;\n\t\tactive_cnt = 2;\n\t}\n\n\t*rxchain_info = cpu_to_le32(iwl_mvm_get_valid_rx_ant(mvm) <<\n\t\t\t\t\tPHY_RX_CHAIN_VALID_POS);\n\t*rxchain_info |= cpu_to_le32(idle_cnt << PHY_RX_CHAIN_CNT_POS);\n\t*rxchain_info |= cpu_to_le32(active_cnt <<\n\t\t\t\t\t PHY_RX_CHAIN_MIMO_CNT_POS);\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tif (unlikely(mvm->dbgfs_rx_phyinfo))\n\t\t*rxchain_info = cpu_to_le32(mvm->dbgfs_rx_phyinfo);\n#endif\n}\n\n \nstatic void iwl_mvm_phy_ctxt_cmd_data_v1(struct iwl_mvm *mvm,\n\t\t\t\t\t struct iwl_mvm_phy_ctxt *ctxt,\n\t\t\t\t\t struct iwl_phy_context_cmd_v1 *cmd,\n\t\t\t\t\t struct cfg80211_chan_def *chandef,\n\t\t\t\t\t u8 chains_static, u8 chains_dynamic)\n{\n\tstruct iwl_phy_context_cmd_tail *tail =\n\t\tiwl_mvm_chan_info_cmd_tail(mvm, &cmd->ci);\n\n\t \n\tiwl_mvm_set_chan_info_chandef(mvm, &cmd->ci, chandef);\n\n\tiwl_mvm_phy_ctxt_set_rxchain(mvm, ctxt, &tail->rxchain_info,\n\t\t\t\t     chains_static, chains_dynamic);\n\n\ttail->txchain_info = cpu_to_le32(iwl_mvm_get_valid_tx_ant(mvm));\n}\n\n \nstatic void iwl_mvm_phy_ctxt_cmd_data(struct iwl_mvm *mvm,\n\t\t\t\t      struct iwl_mvm_phy_ctxt *ctxt,\n\t\t\t\t      struct iwl_phy_context_cmd *cmd,\n\t\t\t\t      struct cfg80211_chan_def *chandef,\n\t\t\t\t      u8 chains_static, u8 chains_dynamic)\n{\n\tcmd->lmac_id = cpu_to_le32(iwl_mvm_get_lmac_id(mvm,\n\t\t\t\t\t\t       chandef->chan->band));\n\n\t \n\tiwl_mvm_set_chan_info_chandef(mvm, &cmd->ci, chandef);\n\n\t \n\tif (iwl_fw_lookup_cmd_ver(mvm->fw, WIDE_ID(DATA_PATH_GROUP, RLC_CONFIG_CMD), 0) < 2)\n\t\tiwl_mvm_phy_ctxt_set_rxchain(mvm, ctxt, &cmd->rxchain_info,\n\t\t\t\t\t     chains_static, chains_dynamic);\n}\n\nint iwl_mvm_phy_send_rlc(struct iwl_mvm *mvm, struct iwl_mvm_phy_ctxt *ctxt,\n\t\t\t u8 chains_static, u8 chains_dynamic)\n{\n\tstruct iwl_rlc_config_cmd cmd = {\n\t\t.phy_id = cpu_to_le32(ctxt->id),\n\t};\n\n\tif (ctxt->rlc_disabled)\n\t\treturn 0;\n\n\tif (iwl_fw_lookup_cmd_ver(mvm->fw, WIDE_ID(DATA_PATH_GROUP,\n\t\t\t\t\t\t   RLC_CONFIG_CMD), 0) < 2)\n\t\treturn 0;\n\n\tBUILD_BUG_ON(IWL_RLC_CHAIN_INFO_DRIVER_FORCE !=\n\t\t     PHY_RX_CHAIN_DRIVER_FORCE_MSK);\n\tBUILD_BUG_ON(IWL_RLC_CHAIN_INFO_VALID !=\n\t\t     PHY_RX_CHAIN_VALID_MSK);\n\tBUILD_BUG_ON(IWL_RLC_CHAIN_INFO_FORCE !=\n\t\t     PHY_RX_CHAIN_FORCE_SEL_MSK);\n\tBUILD_BUG_ON(IWL_RLC_CHAIN_INFO_FORCE_MIMO !=\n\t\t     PHY_RX_CHAIN_FORCE_MIMO_SEL_MSK);\n\tBUILD_BUG_ON(IWL_RLC_CHAIN_INFO_COUNT != PHY_RX_CHAIN_CNT_MSK);\n\tBUILD_BUG_ON(IWL_RLC_CHAIN_INFO_MIMO_COUNT !=\n\t\t     PHY_RX_CHAIN_MIMO_CNT_MSK);\n\n\tiwl_mvm_phy_ctxt_set_rxchain(mvm, ctxt, &cmd.rlc.rx_chain_info,\n\t\t\t\t     chains_static, chains_dynamic);\n\n\treturn iwl_mvm_send_cmd_pdu(mvm, iwl_cmd_id(RLC_CONFIG_CMD,\n\t\t\t\t\t\t    DATA_PATH_GROUP, 2),\n\t\t\t\t    0, sizeof(cmd), &cmd);\n}\n\n \nstatic int iwl_mvm_phy_ctxt_apply(struct iwl_mvm *mvm,\n\t\t\t\t  struct iwl_mvm_phy_ctxt *ctxt,\n\t\t\t\t  struct cfg80211_chan_def *chandef,\n\t\t\t\t  u8 chains_static, u8 chains_dynamic,\n\t\t\t\t  u32 action)\n{\n\tint ret;\n\tint ver = iwl_fw_lookup_cmd_ver(mvm->fw, PHY_CONTEXT_CMD, 1);\n\n\tif (ver == 3 || ver == 4) {\n\t\tstruct iwl_phy_context_cmd cmd = {};\n\n\t\t \n\t\tiwl_mvm_phy_ctxt_cmd_hdr(ctxt, &cmd, action);\n\n\t\t \n\t\tiwl_mvm_phy_ctxt_cmd_data(mvm, ctxt, &cmd, chandef,\n\t\t\t\t\t  chains_static,\n\t\t\t\t\t  chains_dynamic);\n\n\t\tret = iwl_mvm_send_cmd_pdu(mvm, PHY_CONTEXT_CMD,\n\t\t\t\t\t   0, sizeof(cmd), &cmd);\n\t} else if (ver < 3) {\n\t\tstruct iwl_phy_context_cmd_v1 cmd = {};\n\t\tu16 len = sizeof(cmd) - iwl_mvm_chan_info_padding(mvm);\n\n\t\t \n\t\tiwl_mvm_phy_ctxt_cmd_hdr(ctxt,\n\t\t\t\t\t (struct iwl_phy_context_cmd *)&cmd,\n\t\t\t\t\t action);\n\n\t\t \n\t\tiwl_mvm_phy_ctxt_cmd_data_v1(mvm, ctxt, &cmd, chandef,\n\t\t\t\t\t     chains_static,\n\t\t\t\t\t     chains_dynamic);\n\t\tret = iwl_mvm_send_cmd_pdu(mvm, PHY_CONTEXT_CMD,\n\t\t\t\t\t   0, len, &cmd);\n\t} else {\n\t\tIWL_ERR(mvm, \"PHY ctxt cmd error ver %d not supported\\n\", ver);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"PHY ctxt cmd error. ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (action != FW_CTXT_ACTION_REMOVE)\n\t\treturn iwl_mvm_phy_send_rlc(mvm, ctxt, chains_static,\n\t\t\t\t\t    chains_dynamic);\n\n\treturn 0;\n}\n\n \nint iwl_mvm_phy_ctxt_add(struct iwl_mvm *mvm, struct iwl_mvm_phy_ctxt *ctxt,\n\t\t\t struct cfg80211_chan_def *chandef,\n\t\t\t u8 chains_static, u8 chains_dynamic)\n{\n\tWARN_ON(!test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status) &&\n\t\tctxt->ref);\n\tlockdep_assert_held(&mvm->mutex);\n\n\tctxt->channel = chandef->chan;\n\tctxt->width = chandef->width;\n\tctxt->center_freq1 = chandef->center_freq1;\n\n\treturn iwl_mvm_phy_ctxt_apply(mvm, ctxt, chandef,\n\t\t\t\t      chains_static, chains_dynamic,\n\t\t\t\t      FW_CTXT_ACTION_ADD);\n}\n\n \nvoid iwl_mvm_phy_ctxt_ref(struct iwl_mvm *mvm, struct iwl_mvm_phy_ctxt *ctxt)\n{\n\tlockdep_assert_held(&mvm->mutex);\n\tctxt->ref++;\n}\n\n \nint iwl_mvm_phy_ctxt_changed(struct iwl_mvm *mvm, struct iwl_mvm_phy_ctxt *ctxt,\n\t\t\t     struct cfg80211_chan_def *chandef,\n\t\t\t     u8 chains_static, u8 chains_dynamic)\n{\n\tenum iwl_ctxt_action action = FW_CTXT_ACTION_MODIFY;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (iwl_fw_lookup_cmd_ver(mvm->fw, WIDE_ID(DATA_PATH_GROUP, RLC_CONFIG_CMD), 0) >= 2 &&\n\t    ctxt->channel == chandef->chan &&\n\t    ctxt->width == chandef->width &&\n\t    ctxt->center_freq1 == chandef->center_freq1)\n\t\treturn iwl_mvm_phy_send_rlc(mvm, ctxt, chains_static,\n\t\t\t\t\t    chains_dynamic);\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_BINDING_CDB_SUPPORT) &&\n\t    ctxt->channel->band != chandef->chan->band) {\n\t\tint ret;\n\n\t\t \n\t\tret = iwl_mvm_phy_ctxt_apply(mvm, ctxt, chandef,\n\t\t\t\t\t     chains_static, chains_dynamic,\n\t\t\t\t\t     FW_CTXT_ACTION_REMOVE);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\taction = FW_CTXT_ACTION_ADD;\n\t}\n\n\tctxt->channel = chandef->chan;\n\tctxt->width = chandef->width;\n\tctxt->center_freq1 = chandef->center_freq1;\n\n\treturn iwl_mvm_phy_ctxt_apply(mvm, ctxt, chandef,\n\t\t\t\t      chains_static, chains_dynamic,\n\t\t\t\t      action);\n}\n\nvoid iwl_mvm_phy_ctxt_unref(struct iwl_mvm *mvm, struct iwl_mvm_phy_ctxt *ctxt)\n{\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (WARN_ON_ONCE(!ctxt))\n\t\treturn;\n\n\tctxt->ref--;\n\n\t \n\tif (ctxt->ref == 0) {\n\t\tstruct ieee80211_channel *chan = NULL;\n\t\tstruct cfg80211_chan_def chandef;\n\t\tstruct ieee80211_supported_band *sband;\n\t\tenum nl80211_band band;\n\t\tint channel;\n\n\t\tfor (band = NL80211_BAND_2GHZ; band < NUM_NL80211_BANDS; band++) {\n\t\t\tsband = mvm->hw->wiphy->bands[band];\n\n\t\t\tif (!sband)\n\t\t\t\tcontinue;\n\n\t\t\tfor (channel = 0; channel < sband->n_channels; channel++)\n\t\t\t\tif (!(sband->channels[channel].flags &\n\t\t\t\t\t\tIEEE80211_CHAN_DISABLED)) {\n\t\t\t\t\tchan = &sband->channels[channel];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tif (chan)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (WARN_ON(!chan))\n\t\t\treturn;\n\n\t\tcfg80211_chandef_create(&chandef, chan, NL80211_CHAN_NO_HT);\n\t\tiwl_mvm_phy_ctxt_changed(mvm, ctxt, &chandef, 1, 1);\n\t}\n}\n\nstatic void iwl_mvm_binding_iterator(void *_data, u8 *mac,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tunsigned long *data = _data;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tif (!mvmvif->deflink.phy_ctxt)\n\t\treturn;\n\n\tif (vif->type == NL80211_IFTYPE_STATION ||\n\t    vif->type == NL80211_IFTYPE_AP)\n\t\t__set_bit(mvmvif->deflink.phy_ctxt->id, data);\n}\n\nint iwl_mvm_phy_ctx_count(struct iwl_mvm *mvm)\n{\n\tunsigned long phy_ctxt_counter = 0;\n\n\tieee80211_iterate_active_interfaces_atomic(mvm->hw,\n\t\t\t\t\t\t   IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\t\t   iwl_mvm_binding_iterator,\n\t\t\t\t\t\t   &phy_ctxt_counter);\n\n\treturn hweight8(phy_ctxt_counter);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}