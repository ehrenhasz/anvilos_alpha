{
  "module_name": "ops.c",
  "hash_id": "a0605b8f31dc200d11b5e7c0a33d8a1a080d77bf69d6d996718c46c32352c367",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/ops.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/rtnetlink.h>\n#include <linux/vmalloc.h>\n#include <net/mac80211.h>\n\n#include \"fw/notif-wait.h\"\n#include \"iwl-trans.h\"\n#include \"iwl-op-mode.h\"\n#include \"fw/img.h\"\n#include \"iwl-debug.h\"\n#include \"iwl-drv.h\"\n#include \"iwl-modparams.h\"\n#include \"mvm.h\"\n#include \"iwl-phy-db.h\"\n#include \"iwl-eeprom-parse.h\"\n#include \"iwl-csr.h\"\n#include \"iwl-io.h\"\n#include \"iwl-prph.h\"\n#include \"rs.h\"\n#include \"fw/api/scan.h\"\n#include \"fw/api/rfi.h\"\n#include \"time-event.h\"\n#include \"fw-api.h\"\n#include \"fw/acpi.h\"\n#include \"fw/uefi.h\"\n#include \"time-sync.h\"\n\n#define DRV_DESCRIPTION\t\"The new Intel(R) wireless AGN driver for Linux\"\nMODULE_DESCRIPTION(DRV_DESCRIPTION);\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(IWLWIFI);\n\nstatic const struct iwl_op_mode_ops iwl_mvm_ops;\nstatic const struct iwl_op_mode_ops iwl_mvm_ops_mq;\n\nstruct iwl_mvm_mod_params iwlmvm_mod_params = {\n\t.power_scheme = IWL_POWER_SCHEME_BPS,\n\t \n};\n\nmodule_param_named(init_dbg, iwlmvm_mod_params.init_dbg, bool, 0444);\nMODULE_PARM_DESC(init_dbg,\n\t\t \"set to true to debug an ASSERT in INIT fw (default: false\");\nmodule_param_named(power_scheme, iwlmvm_mod_params.power_scheme, int, 0444);\nMODULE_PARM_DESC(power_scheme,\n\t\t \"power management scheme: 1-active, 2-balanced, 3-low power, default: 2\");\n\n \nstatic int __init iwl_mvm_init(void)\n{\n\tint ret;\n\n\tret = iwl_mvm_rate_control_register();\n\tif (ret) {\n\t\tpr_err(\"Unable to register rate control algorithm: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = iwl_opmode_register(\"iwlmvm\", &iwl_mvm_ops);\n\tif (ret)\n\t\tpr_err(\"Unable to register MVM op_mode: %d\\n\", ret);\n\n\treturn ret;\n}\nmodule_init(iwl_mvm_init);\n\nstatic void __exit iwl_mvm_exit(void)\n{\n\tiwl_opmode_deregister(\"iwlmvm\");\n\tiwl_mvm_rate_control_unregister();\n}\nmodule_exit(iwl_mvm_exit);\n\nstatic void iwl_mvm_nic_config(struct iwl_op_mode *op_mode)\n{\n\tstruct iwl_mvm *mvm = IWL_OP_MODE_GET_MVM(op_mode);\n\tu8 radio_cfg_type, radio_cfg_step, radio_cfg_dash;\n\tu32 reg_val;\n\tu32 phy_config = iwl_mvm_get_phy_config(mvm);\n\n\tradio_cfg_type = (phy_config & FW_PHY_CFG_RADIO_TYPE) >>\n\t\t\t FW_PHY_CFG_RADIO_TYPE_POS;\n\tradio_cfg_step = (phy_config & FW_PHY_CFG_RADIO_STEP) >>\n\t\t\t FW_PHY_CFG_RADIO_STEP_POS;\n\tradio_cfg_dash = (phy_config & FW_PHY_CFG_RADIO_DASH) >>\n\t\t\t FW_PHY_CFG_RADIO_DASH_POS;\n\n\tIWL_DEBUG_INFO(mvm, \"Radio type=0x%x-0x%x-0x%x\\n\", radio_cfg_type,\n\t\t       radio_cfg_step, radio_cfg_dash);\n\n\tif (mvm->trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_AX210)\n\t\treturn;\n\n\t \n\treg_val = CSR_HW_REV_STEP_DASH(mvm->trans->hw_rev);\n\n\t \n\treg_val |= radio_cfg_type << CSR_HW_IF_CONFIG_REG_POS_PHY_TYPE;\n\treg_val |= radio_cfg_step << CSR_HW_IF_CONFIG_REG_POS_PHY_STEP;\n\treg_val |= radio_cfg_dash << CSR_HW_IF_CONFIG_REG_POS_PHY_DASH;\n\n\tWARN_ON((radio_cfg_type << CSR_HW_IF_CONFIG_REG_POS_PHY_TYPE) &\n\t\t ~CSR_HW_IF_CONFIG_REG_MSK_PHY_TYPE);\n\n\t \n\tif (mvm->trans->trans_cfg->device_family < IWL_DEVICE_FAMILY_8000)\n\t\treg_val |= CSR_HW_IF_CONFIG_REG_BIT_RADIO_SI;\n\n\tif (iwl_fw_dbg_is_d3_debug_enabled(&mvm->fwrt))\n\t\treg_val |= CSR_HW_IF_CONFIG_REG_D3_DEBUG;\n\n\tiwl_trans_set_bits_mask(mvm->trans, CSR_HW_IF_CONFIG_REG,\n\t\t\t\tCSR_HW_IF_CONFIG_REG_MSK_MAC_STEP_DASH |\n\t\t\t\tCSR_HW_IF_CONFIG_REG_MSK_PHY_TYPE |\n\t\t\t\tCSR_HW_IF_CONFIG_REG_MSK_PHY_STEP |\n\t\t\t\tCSR_HW_IF_CONFIG_REG_MSK_PHY_DASH |\n\t\t\t\tCSR_HW_IF_CONFIG_REG_BIT_RADIO_SI |\n\t\t\t\tCSR_HW_IF_CONFIG_REG_BIT_MAC_SI   |\n\t\t\t\tCSR_HW_IF_CONFIG_REG_D3_DEBUG,\n\t\t\t\treg_val);\n\n\t \n\tif (!mvm->trans->cfg->apmg_not_supported)\n\t\tiwl_set_bits_mask_prph(mvm->trans, APMG_PS_CTRL_REG,\n\t\t\t\t       APMG_PS_CTRL_EARLY_PWR_OFF_RESET_DIS,\n\t\t\t\t       ~APMG_PS_CTRL_EARLY_PWR_OFF_RESET_DIS);\n}\n\nstatic void iwl_mvm_rx_monitor_notif(struct iwl_mvm *mvm,\n\t\t\t\t     struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_datapath_monitor_notif *notif = (void *)pkt->data;\n\tstruct ieee80211_supported_band *sband;\n\tconst struct ieee80211_sta_he_cap *he_cap;\n\tstruct ieee80211_vif *vif;\n\n\tif (notif->type != cpu_to_le32(IWL_DP_MON_NOTIF_TYPE_EXT_CCA))\n\t\treturn;\n\n\tvif = iwl_mvm_get_vif_by_macid(mvm, notif->mac_id);\n\tif (!vif || vif->type != NL80211_IFTYPE_STATION)\n\t\treturn;\n\n\tif (!vif->bss_conf.chandef.chan ||\n\t    vif->bss_conf.chandef.chan->band != NL80211_BAND_2GHZ ||\n\t    vif->bss_conf.chandef.width < NL80211_CHAN_WIDTH_40)\n\t\treturn;\n\n\tif (!vif->cfg.assoc)\n\t\treturn;\n\n\t \n\tif (mvm->cca_40mhz_workaround)\n\t\treturn;\n\n\t \n\tmvm->cca_40mhz_workaround = 2;\n\n\t \n\tsband = mvm->hw->wiphy->bands[NL80211_BAND_2GHZ];\n\n\tWARN_ON(!sband->ht_cap.ht_supported);\n\tWARN_ON(!(sband->ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40));\n\tsband->ht_cap.cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\n\the_cap = ieee80211_get_he_iftype_cap_vif(sband, vif);\n\n\tif (he_cap) {\n\t\t \n\t\tstruct ieee80211_sta_he_cap *he = (void *)(uintptr_t)he_cap;\n\n\t\tWARN_ON(!he->has_he);\n\t\tWARN_ON(!(he->he_cap_elem.phy_cap_info[0] &\n\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G));\n\t\the->he_cap_elem.phy_cap_info[0] &=\n\t\t\t~IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G;\n\t}\n\n\tieee80211_disconnect(vif, true);\n}\n\nvoid iwl_mvm_update_link_smps(struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_bss_conf *link_conf)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm *mvm = mvmvif->mvm;\n\tenum ieee80211_smps_mode mode = IEEE80211_SMPS_AUTOMATIC;\n\n\tif (!link_conf)\n\t\treturn;\n\n\tif (mvm->fw_static_smps_request &&\n\t    link_conf->chandef.width == NL80211_CHAN_WIDTH_160 &&\n\t    link_conf->he_support)\n\t\tmode = IEEE80211_SMPS_STATIC;\n\n\tiwl_mvm_update_smps(mvm, vif, IWL_MVM_SMPS_REQ_FW, mode,\n\t\t\t    link_conf->link_id);\n}\n\nstatic void iwl_mvm_intf_dual_chain_req(void *data, u8 *mac,\n\t\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct ieee80211_bss_conf *link_conf;\n\tunsigned int link_id;\n\n\trcu_read_lock();\n\n\tfor_each_vif_active_link(vif, link_conf, link_id)\n\t\tiwl_mvm_update_link_smps(vif, link_conf);\n\n\trcu_read_unlock();\n}\n\nstatic void iwl_mvm_rx_thermal_dual_chain_req(struct iwl_mvm *mvm,\n\t\t\t\t\t      struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_thermal_dual_chain_request *req = (void *)pkt->data;\n\n\t \n\tmvm->fw_static_smps_request =\n\t\treq->event == cpu_to_le32(THERMAL_DUAL_CHAIN_REQ_DISABLE);\n\tieee80211_iterate_interfaces(mvm->hw,\n\t\t\t\t     IEEE80211_IFACE_SKIP_SDATA_NOT_IN_DRIVER,\n\t\t\t\t     iwl_mvm_intf_dual_chain_req, NULL);\n}\n\n \nenum iwl_rx_handler_context {\n\tRX_HANDLER_SYNC,\n\tRX_HANDLER_ASYNC_LOCKED,\n\tRX_HANDLER_ASYNC_UNLOCKED,\n};\n\n \nstruct iwl_rx_handlers {\n\tu16 cmd_id, min_size;\n\tenum iwl_rx_handler_context context;\n\tvoid (*fn)(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb);\n};\n\n#define RX_HANDLER_NO_SIZE(_cmd_id, _fn, _context)\t\t\\\n\t{ .cmd_id = _cmd_id, .fn = _fn, .context = _context, }\n#define RX_HANDLER_GRP_NO_SIZE(_grp, _cmd, _fn, _context)\t\\\n\t{ .cmd_id = WIDE_ID(_grp, _cmd), .fn = _fn, .context = _context, }\n#define RX_HANDLER(_cmd_id, _fn, _context, _struct)\t\t\\\n\t{ .cmd_id = _cmd_id, .fn = _fn,\t\t\t\t\\\n\t  .context = _context, .min_size = sizeof(_struct), }\n#define RX_HANDLER_GRP(_grp, _cmd, _fn, _context, _struct)\t\\\n\t{ .cmd_id = WIDE_ID(_grp, _cmd), .fn = _fn,\t\t\\\n\t  .context = _context, .min_size = sizeof(_struct), }\n\n \nstatic const struct iwl_rx_handlers iwl_mvm_rx_handlers[] = {\n\tRX_HANDLER(TX_CMD, iwl_mvm_rx_tx_cmd, RX_HANDLER_SYNC,\n\t\t   struct iwl_mvm_tx_resp),\n\tRX_HANDLER(BA_NOTIF, iwl_mvm_rx_ba_notif, RX_HANDLER_SYNC,\n\t\t   struct iwl_mvm_ba_notif),\n\n\tRX_HANDLER_GRP(DATA_PATH_GROUP, TLC_MNG_UPDATE_NOTIF,\n\t\t       iwl_mvm_tlc_update_notif, RX_HANDLER_SYNC,\n\t\t       struct iwl_tlc_update_notif),\n\n\tRX_HANDLER(BT_PROFILE_NOTIFICATION, iwl_mvm_rx_bt_coex_notif,\n\t\t   RX_HANDLER_ASYNC_LOCKED, struct iwl_bt_coex_profile_notif),\n\tRX_HANDLER_NO_SIZE(BEACON_NOTIFICATION, iwl_mvm_rx_beacon_notif,\n\t\t\t   RX_HANDLER_ASYNC_LOCKED),\n\tRX_HANDLER_NO_SIZE(STATISTICS_NOTIFICATION, iwl_mvm_rx_statistics,\n\t\t\t   RX_HANDLER_ASYNC_LOCKED),\n\n\tRX_HANDLER(BA_WINDOW_STATUS_NOTIFICATION_ID,\n\t\t   iwl_mvm_window_status_notif, RX_HANDLER_SYNC,\n\t\t   struct iwl_ba_window_status_notif),\n\n\tRX_HANDLER(TIME_EVENT_NOTIFICATION, iwl_mvm_rx_time_event_notif,\n\t\t   RX_HANDLER_SYNC, struct iwl_time_event_notif),\n\tRX_HANDLER_GRP(MAC_CONF_GROUP, SESSION_PROTECTION_NOTIF,\n\t\t       iwl_mvm_rx_session_protect_notif, RX_HANDLER_SYNC,\n\t\t       struct iwl_mvm_session_prot_notif),\n\tRX_HANDLER(MCC_CHUB_UPDATE_CMD, iwl_mvm_rx_chub_update_mcc,\n\t\t   RX_HANDLER_ASYNC_LOCKED, struct iwl_mcc_chub_notif),\n\n\tRX_HANDLER(EOSP_NOTIFICATION, iwl_mvm_rx_eosp_notif, RX_HANDLER_SYNC,\n\t\t   struct iwl_mvm_eosp_notification),\n\n\tRX_HANDLER(SCAN_ITERATION_COMPLETE,\n\t\t   iwl_mvm_rx_lmac_scan_iter_complete_notif, RX_HANDLER_SYNC,\n\t\t   struct iwl_lmac_scan_complete_notif),\n\tRX_HANDLER(SCAN_OFFLOAD_COMPLETE,\n\t\t   iwl_mvm_rx_lmac_scan_complete_notif,\n\t\t   RX_HANDLER_ASYNC_LOCKED, struct iwl_periodic_scan_complete),\n\tRX_HANDLER_NO_SIZE(MATCH_FOUND_NOTIFICATION,\n\t\t\t   iwl_mvm_rx_scan_match_found,\n\t\t\t   RX_HANDLER_SYNC),\n\tRX_HANDLER(SCAN_COMPLETE_UMAC, iwl_mvm_rx_umac_scan_complete_notif,\n\t\t   RX_HANDLER_ASYNC_LOCKED, struct iwl_umac_scan_complete),\n\tRX_HANDLER(SCAN_ITERATION_COMPLETE_UMAC,\n\t\t   iwl_mvm_rx_umac_scan_iter_complete_notif, RX_HANDLER_SYNC,\n\t\t   struct iwl_umac_scan_iter_complete_notif),\n\n\tRX_HANDLER(MISSED_BEACONS_NOTIFICATION, iwl_mvm_rx_missed_beacons_notif,\n\t\t   RX_HANDLER_SYNC, struct iwl_missed_beacons_notif),\n\n\tRX_HANDLER(REPLY_ERROR, iwl_mvm_rx_fw_error, RX_HANDLER_SYNC,\n\t\t   struct iwl_error_resp),\n\tRX_HANDLER(PSM_UAPSD_AP_MISBEHAVING_NOTIFICATION,\n\t\t   iwl_mvm_power_uapsd_misbehaving_ap_notif, RX_HANDLER_SYNC,\n\t\t   struct iwl_uapsd_misbehaving_ap_notif),\n\tRX_HANDLER_NO_SIZE(DTS_MEASUREMENT_NOTIFICATION, iwl_mvm_temp_notif,\n\t\t\t   RX_HANDLER_ASYNC_LOCKED),\n\tRX_HANDLER_GRP_NO_SIZE(PHY_OPS_GROUP, DTS_MEASUREMENT_NOTIF_WIDE,\n\t\t\t       iwl_mvm_temp_notif, RX_HANDLER_ASYNC_UNLOCKED),\n\tRX_HANDLER_GRP(PHY_OPS_GROUP, CT_KILL_NOTIFICATION,\n\t\t       iwl_mvm_ct_kill_notif, RX_HANDLER_SYNC,\n\t\t       struct ct_kill_notif),\n\n\tRX_HANDLER(TDLS_CHANNEL_SWITCH_NOTIFICATION, iwl_mvm_rx_tdls_notif,\n\t\t   RX_HANDLER_ASYNC_LOCKED,\n\t\t   struct iwl_tdls_channel_switch_notif),\n\tRX_HANDLER(MFUART_LOAD_NOTIFICATION, iwl_mvm_rx_mfuart_notif,\n\t\t   RX_HANDLER_SYNC, struct iwl_mfuart_load_notif_v1),\n\tRX_HANDLER_GRP(LOCATION_GROUP, TOF_RESPONDER_STATS,\n\t\t       iwl_mvm_ftm_responder_stats, RX_HANDLER_ASYNC_LOCKED,\n\t\t       struct iwl_ftm_responder_stats),\n\n\tRX_HANDLER_GRP_NO_SIZE(LOCATION_GROUP, TOF_RANGE_RESPONSE_NOTIF,\n\t\t\t       iwl_mvm_ftm_range_resp, RX_HANDLER_ASYNC_LOCKED),\n\tRX_HANDLER_GRP_NO_SIZE(LOCATION_GROUP, TOF_LC_NOTIF,\n\t\t\t       iwl_mvm_ftm_lc_notif, RX_HANDLER_ASYNC_LOCKED),\n\n\tRX_HANDLER_GRP(DEBUG_GROUP, MFU_ASSERT_DUMP_NTF,\n\t\t       iwl_mvm_mfu_assert_dump_notif, RX_HANDLER_SYNC,\n\t\t       struct iwl_mfu_assert_dump_notif),\n\tRX_HANDLER_GRP(PROT_OFFLOAD_GROUP, STORED_BEACON_NTF,\n\t\t       iwl_mvm_rx_stored_beacon_notif, RX_HANDLER_SYNC,\n\t\t       struct iwl_stored_beacon_notif_v2),\n\tRX_HANDLER_GRP(DATA_PATH_GROUP, MU_GROUP_MGMT_NOTIF,\n\t\t       iwl_mvm_mu_mimo_grp_notif, RX_HANDLER_SYNC,\n\t\t       struct iwl_mu_group_mgmt_notif),\n\tRX_HANDLER_GRP(DATA_PATH_GROUP, STA_PM_NOTIF,\n\t\t       iwl_mvm_sta_pm_notif, RX_HANDLER_SYNC,\n\t\t       struct iwl_mvm_pm_state_notification),\n\tRX_HANDLER_GRP(MAC_CONF_GROUP, PROBE_RESPONSE_DATA_NOTIF,\n\t\t       iwl_mvm_probe_resp_data_notif,\n\t\t       RX_HANDLER_ASYNC_LOCKED,\n\t\t       struct iwl_probe_resp_data_notif),\n\tRX_HANDLER_GRP(MAC_CONF_GROUP, CHANNEL_SWITCH_START_NOTIF,\n\t\t       iwl_mvm_channel_switch_start_notif,\n\t\t       RX_HANDLER_SYNC, struct iwl_channel_switch_start_notif),\n\tRX_HANDLER_GRP(MAC_CONF_GROUP, CHANNEL_SWITCH_ERROR_NOTIF,\n\t\t       iwl_mvm_channel_switch_error_notif,\n\t\t       RX_HANDLER_ASYNC_UNLOCKED,\n\t\t       struct iwl_channel_switch_error_notif),\n\tRX_HANDLER_GRP(DATA_PATH_GROUP, MONITOR_NOTIF,\n\t\t       iwl_mvm_rx_monitor_notif, RX_HANDLER_ASYNC_LOCKED,\n\t\t       struct iwl_datapath_monitor_notif),\n\n\tRX_HANDLER_GRP(DATA_PATH_GROUP, THERMAL_DUAL_CHAIN_REQUEST,\n\t\t       iwl_mvm_rx_thermal_dual_chain_req,\n\t\t       RX_HANDLER_ASYNC_LOCKED,\n\t\t       struct iwl_thermal_dual_chain_request),\n\n\tRX_HANDLER_GRP(SYSTEM_GROUP, RFI_DEACTIVATE_NOTIF,\n\t\t       iwl_rfi_deactivate_notif_handler, RX_HANDLER_ASYNC_UNLOCKED,\n\t\t       struct iwl_rfi_deactivate_notif),\n\n\tRX_HANDLER_GRP(LEGACY_GROUP,\n\t\t       WNM_80211V_TIMING_MEASUREMENT_NOTIFICATION,\n\t\t       iwl_mvm_time_sync_msmt_event, RX_HANDLER_SYNC,\n\t\t       struct iwl_time_msmt_notify),\n\tRX_HANDLER_GRP(LEGACY_GROUP,\n\t\t       WNM_80211V_TIMING_MEASUREMENT_CONFIRM_NOTIFICATION,\n\t\t       iwl_mvm_time_sync_msmt_confirm_event, RX_HANDLER_SYNC,\n\t\t       struct iwl_time_msmt_cfm_notify),\n};\n#undef RX_HANDLER\n#undef RX_HANDLER_GRP\n\n \nstatic const struct iwl_hcmd_names iwl_mvm_legacy_names[] = {\n\tHCMD_NAME(UCODE_ALIVE_NTFY),\n\tHCMD_NAME(REPLY_ERROR),\n\tHCMD_NAME(ECHO_CMD),\n\tHCMD_NAME(INIT_COMPLETE_NOTIF),\n\tHCMD_NAME(PHY_CONTEXT_CMD),\n\tHCMD_NAME(DBG_CFG),\n\tHCMD_NAME(SCAN_CFG_CMD),\n\tHCMD_NAME(SCAN_REQ_UMAC),\n\tHCMD_NAME(SCAN_ABORT_UMAC),\n\tHCMD_NAME(SCAN_COMPLETE_UMAC),\n\tHCMD_NAME(BA_WINDOW_STATUS_NOTIFICATION_ID),\n\tHCMD_NAME(ADD_STA_KEY),\n\tHCMD_NAME(ADD_STA),\n\tHCMD_NAME(REMOVE_STA),\n\tHCMD_NAME(TX_CMD),\n\tHCMD_NAME(SCD_QUEUE_CFG),\n\tHCMD_NAME(TXPATH_FLUSH),\n\tHCMD_NAME(MGMT_MCAST_KEY),\n\tHCMD_NAME(WEP_KEY),\n\tHCMD_NAME(SHARED_MEM_CFG),\n\tHCMD_NAME(TDLS_CHANNEL_SWITCH_CMD),\n\tHCMD_NAME(MAC_CONTEXT_CMD),\n\tHCMD_NAME(TIME_EVENT_CMD),\n\tHCMD_NAME(TIME_EVENT_NOTIFICATION),\n\tHCMD_NAME(BINDING_CONTEXT_CMD),\n\tHCMD_NAME(TIME_QUOTA_CMD),\n\tHCMD_NAME(NON_QOS_TX_COUNTER_CMD),\n\tHCMD_NAME(LEDS_CMD),\n\tHCMD_NAME(LQ_CMD),\n\tHCMD_NAME(FW_PAGING_BLOCK_CMD),\n\tHCMD_NAME(SCAN_OFFLOAD_REQUEST_CMD),\n\tHCMD_NAME(SCAN_OFFLOAD_ABORT_CMD),\n\tHCMD_NAME(HOT_SPOT_CMD),\n\tHCMD_NAME(SCAN_OFFLOAD_PROFILES_QUERY_CMD),\n\tHCMD_NAME(BT_COEX_UPDATE_REDUCED_TXP),\n\tHCMD_NAME(BT_COEX_CI),\n\tHCMD_NAME(WNM_80211V_TIMING_MEASUREMENT_NOTIFICATION),\n\tHCMD_NAME(WNM_80211V_TIMING_MEASUREMENT_CONFIRM_NOTIFICATION),\n\tHCMD_NAME(PHY_CONFIGURATION_CMD),\n\tHCMD_NAME(CALIB_RES_NOTIF_PHY_DB),\n\tHCMD_NAME(PHY_DB_CMD),\n\tHCMD_NAME(SCAN_OFFLOAD_COMPLETE),\n\tHCMD_NAME(SCAN_OFFLOAD_UPDATE_PROFILES_CMD),\n\tHCMD_NAME(POWER_TABLE_CMD),\n\tHCMD_NAME(PSM_UAPSD_AP_MISBEHAVING_NOTIFICATION),\n\tHCMD_NAME(REPLY_THERMAL_MNG_BACKOFF),\n\tHCMD_NAME(NVM_ACCESS_CMD),\n\tHCMD_NAME(BEACON_NOTIFICATION),\n\tHCMD_NAME(BEACON_TEMPLATE_CMD),\n\tHCMD_NAME(TX_ANT_CONFIGURATION_CMD),\n\tHCMD_NAME(BT_CONFIG),\n\tHCMD_NAME(STATISTICS_CMD),\n\tHCMD_NAME(STATISTICS_NOTIFICATION),\n\tHCMD_NAME(EOSP_NOTIFICATION),\n\tHCMD_NAME(REDUCE_TX_POWER_CMD),\n\tHCMD_NAME(MISSED_BEACONS_NOTIFICATION),\n\tHCMD_NAME(TDLS_CONFIG_CMD),\n\tHCMD_NAME(MAC_PM_POWER_TABLE),\n\tHCMD_NAME(TDLS_CHANNEL_SWITCH_NOTIFICATION),\n\tHCMD_NAME(MFUART_LOAD_NOTIFICATION),\n\tHCMD_NAME(RSS_CONFIG_CMD),\n\tHCMD_NAME(SCAN_ITERATION_COMPLETE_UMAC),\n\tHCMD_NAME(REPLY_RX_PHY_CMD),\n\tHCMD_NAME(REPLY_RX_MPDU_CMD),\n\tHCMD_NAME(BAR_FRAME_RELEASE),\n\tHCMD_NAME(FRAME_RELEASE),\n\tHCMD_NAME(BA_NOTIF),\n\tHCMD_NAME(MCC_UPDATE_CMD),\n\tHCMD_NAME(MCC_CHUB_UPDATE_CMD),\n\tHCMD_NAME(MARKER_CMD),\n\tHCMD_NAME(BT_PROFILE_NOTIFICATION),\n\tHCMD_NAME(MCAST_FILTER_CMD),\n\tHCMD_NAME(REPLY_SF_CFG_CMD),\n\tHCMD_NAME(REPLY_BEACON_FILTERING_CMD),\n\tHCMD_NAME(D3_CONFIG_CMD),\n\tHCMD_NAME(PROT_OFFLOAD_CONFIG_CMD),\n\tHCMD_NAME(MATCH_FOUND_NOTIFICATION),\n\tHCMD_NAME(DTS_MEASUREMENT_NOTIFICATION),\n\tHCMD_NAME(WOWLAN_PATTERNS),\n\tHCMD_NAME(WOWLAN_CONFIGURATION),\n\tHCMD_NAME(WOWLAN_TSC_RSC_PARAM),\n\tHCMD_NAME(WOWLAN_TKIP_PARAM),\n\tHCMD_NAME(WOWLAN_KEK_KCK_MATERIAL),\n\tHCMD_NAME(WOWLAN_GET_STATUSES),\n\tHCMD_NAME(SCAN_ITERATION_COMPLETE),\n\tHCMD_NAME(D0I3_END_CMD),\n\tHCMD_NAME(LTR_CONFIG),\n\tHCMD_NAME(LDBG_CONFIG_CMD),\n};\n\n \nstatic const struct iwl_hcmd_names iwl_mvm_system_names[] = {\n\tHCMD_NAME(SHARED_MEM_CFG_CMD),\n\tHCMD_NAME(INIT_EXTENDED_CFG_CMD),\n\tHCMD_NAME(FW_ERROR_RECOVERY_CMD),\n\tHCMD_NAME(RFI_CONFIG_CMD),\n\tHCMD_NAME(RFI_GET_FREQ_TABLE_CMD),\n\tHCMD_NAME(SYSTEM_FEATURES_CONTROL_CMD),\n\tHCMD_NAME(RFI_DEACTIVATE_NOTIF),\n};\n\n \nstatic const struct iwl_hcmd_names iwl_mvm_mac_conf_names[] = {\n\tHCMD_NAME(CHANNEL_SWITCH_TIME_EVENT_CMD),\n\tHCMD_NAME(SESSION_PROTECTION_CMD),\n\tHCMD_NAME(MAC_CONFIG_CMD),\n\tHCMD_NAME(LINK_CONFIG_CMD),\n\tHCMD_NAME(STA_CONFIG_CMD),\n\tHCMD_NAME(AUX_STA_CMD),\n\tHCMD_NAME(STA_REMOVE_CMD),\n\tHCMD_NAME(STA_DISABLE_TX_CMD),\n\tHCMD_NAME(SESSION_PROTECTION_NOTIF),\n\tHCMD_NAME(CHANNEL_SWITCH_START_NOTIF),\n};\n\n \nstatic const struct iwl_hcmd_names iwl_mvm_phy_names[] = {\n\tHCMD_NAME(CMD_DTS_MEASUREMENT_TRIGGER_WIDE),\n\tHCMD_NAME(CTDP_CONFIG_CMD),\n\tHCMD_NAME(TEMP_REPORTING_THRESHOLDS_CMD),\n\tHCMD_NAME(PER_CHAIN_LIMIT_OFFSET_CMD),\n\tHCMD_NAME(CT_KILL_NOTIFICATION),\n\tHCMD_NAME(DTS_MEASUREMENT_NOTIF_WIDE),\n};\n\n \nstatic const struct iwl_hcmd_names iwl_mvm_data_path_names[] = {\n\tHCMD_NAME(DQA_ENABLE_CMD),\n\tHCMD_NAME(UPDATE_MU_GROUPS_CMD),\n\tHCMD_NAME(TRIGGER_RX_QUEUES_NOTIF_CMD),\n\tHCMD_NAME(STA_HE_CTXT_CMD),\n\tHCMD_NAME(RLC_CONFIG_CMD),\n\tHCMD_NAME(RFH_QUEUE_CONFIG_CMD),\n\tHCMD_NAME(TLC_MNG_CONFIG_CMD),\n\tHCMD_NAME(CHEST_COLLECTOR_FILTER_CONFIG_CMD),\n\tHCMD_NAME(SCD_QUEUE_CONFIG_CMD),\n\tHCMD_NAME(SEC_KEY_CMD),\n\tHCMD_NAME(MONITOR_NOTIF),\n\tHCMD_NAME(THERMAL_DUAL_CHAIN_REQUEST),\n\tHCMD_NAME(STA_PM_NOTIF),\n\tHCMD_NAME(MU_GROUP_MGMT_NOTIF),\n\tHCMD_NAME(RX_QUEUES_NOTIFICATION),\n};\n\n \nstatic const struct iwl_hcmd_names iwl_mvm_scan_names[] = {\n\tHCMD_NAME(OFFLOAD_MATCH_INFO_NOTIF),\n};\n\n \nstatic const struct iwl_hcmd_names iwl_mvm_location_names[] = {\n\tHCMD_NAME(TOF_RANGE_REQ_CMD),\n\tHCMD_NAME(TOF_CONFIG_CMD),\n\tHCMD_NAME(TOF_RANGE_ABORT_CMD),\n\tHCMD_NAME(TOF_RANGE_REQ_EXT_CMD),\n\tHCMD_NAME(TOF_RESPONDER_CONFIG_CMD),\n\tHCMD_NAME(TOF_RESPONDER_DYN_CONFIG_CMD),\n\tHCMD_NAME(TOF_LC_NOTIF),\n\tHCMD_NAME(TOF_RESPONDER_STATS),\n\tHCMD_NAME(TOF_MCSI_DEBUG_NOTIF),\n\tHCMD_NAME(TOF_RANGE_RESPONSE_NOTIF),\n};\n\n \nstatic const struct iwl_hcmd_names iwl_mvm_prot_offload_names[] = {\n\tHCMD_NAME(WOWLAN_WAKE_PKT_NOTIFICATION),\n\tHCMD_NAME(WOWLAN_INFO_NOTIFICATION),\n\tHCMD_NAME(D3_END_NOTIFICATION),\n\tHCMD_NAME(STORED_BEACON_NTF),\n};\n\n \nstatic const struct iwl_hcmd_names iwl_mvm_regulatory_and_nvm_names[] = {\n\tHCMD_NAME(NVM_ACCESS_COMPLETE),\n\tHCMD_NAME(NVM_GET_INFO),\n\tHCMD_NAME(TAS_CONFIG),\n};\n\nstatic const struct iwl_hcmd_arr iwl_mvm_groups[] = {\n\t[LEGACY_GROUP] = HCMD_ARR(iwl_mvm_legacy_names),\n\t[LONG_GROUP] = HCMD_ARR(iwl_mvm_legacy_names),\n\t[SYSTEM_GROUP] = HCMD_ARR(iwl_mvm_system_names),\n\t[MAC_CONF_GROUP] = HCMD_ARR(iwl_mvm_mac_conf_names),\n\t[PHY_OPS_GROUP] = HCMD_ARR(iwl_mvm_phy_names),\n\t[DATA_PATH_GROUP] = HCMD_ARR(iwl_mvm_data_path_names),\n\t[SCAN_GROUP] = HCMD_ARR(iwl_mvm_scan_names),\n\t[LOCATION_GROUP] = HCMD_ARR(iwl_mvm_location_names),\n\t[PROT_OFFLOAD_GROUP] = HCMD_ARR(iwl_mvm_prot_offload_names),\n\t[REGULATORY_AND_NVM_GROUP] =\n\t\tHCMD_ARR(iwl_mvm_regulatory_and_nvm_names),\n};\n\n \nstatic void iwl_mvm_async_handlers_wk(struct work_struct *wk);\n\nstatic u32 iwl_mvm_min_backoff(struct iwl_mvm *mvm)\n{\n\tconst struct iwl_pwr_tx_backoff *backoff = mvm->cfg->pwr_tx_backoffs;\n\tu64 dflt_pwr_limit;\n\n\tif (!backoff)\n\t\treturn 0;\n\n\tdflt_pwr_limit = iwl_acpi_get_pwr_limit(mvm->dev);\n\n\twhile (backoff->pwr) {\n\t\tif (dflt_pwr_limit >= backoff->pwr)\n\t\t\treturn backoff->backoff;\n\n\t\tbackoff++;\n\t}\n\n\treturn 0;\n}\n\nstatic void iwl_mvm_tx_unblock_dwork(struct work_struct *work)\n{\n\tstruct iwl_mvm *mvm =\n\t\tcontainer_of(work, struct iwl_mvm, cs_tx_unblock_dwork.work);\n\tstruct ieee80211_vif *tx_blocked_vif;\n\tstruct iwl_mvm_vif *mvmvif;\n\n\tmutex_lock(&mvm->mutex);\n\n\ttx_blocked_vif =\n\t\trcu_dereference_protected(mvm->csa_tx_blocked_vif,\n\t\t\t\t\t  lockdep_is_held(&mvm->mutex));\n\n\tif (!tx_blocked_vif)\n\t\tgoto unlock;\n\n\tmvmvif = iwl_mvm_vif_from_mac80211(tx_blocked_vif);\n\tiwl_mvm_modify_all_sta_disable_tx(mvm, mvmvif, false);\n\tRCU_INIT_POINTER(mvm->csa_tx_blocked_vif, NULL);\nunlock:\n\tmutex_unlock(&mvm->mutex);\n}\n\nstatic void iwl_mvm_fwrt_dump_start(void *ctx)\n{\n\tstruct iwl_mvm *mvm = ctx;\n\n\tmutex_lock(&mvm->mutex);\n}\n\nstatic void iwl_mvm_fwrt_dump_end(void *ctx)\n{\n\tstruct iwl_mvm *mvm = ctx;\n\n\tmutex_unlock(&mvm->mutex);\n}\n\nstatic bool iwl_mvm_fwrt_fw_running(void *ctx)\n{\n\treturn iwl_mvm_firmware_running(ctx);\n}\n\nstatic int iwl_mvm_fwrt_send_hcmd(void *ctx, struct iwl_host_cmd *host_cmd)\n{\n\tstruct iwl_mvm *mvm = (struct iwl_mvm *)ctx;\n\tint ret;\n\n\tmutex_lock(&mvm->mutex);\n\tret = iwl_mvm_send_cmd(mvm, host_cmd);\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret;\n}\n\nstatic bool iwl_mvm_d3_debug_enable(void *ctx)\n{\n\treturn IWL_MVM_D3_DEBUG;\n}\n\nstatic const struct iwl_fw_runtime_ops iwl_mvm_fwrt_ops = {\n\t.dump_start = iwl_mvm_fwrt_dump_start,\n\t.dump_end = iwl_mvm_fwrt_dump_end,\n\t.fw_running = iwl_mvm_fwrt_fw_running,\n\t.send_hcmd = iwl_mvm_fwrt_send_hcmd,\n\t.d3_debug_enable = iwl_mvm_d3_debug_enable,\n};\n\nstatic int iwl_mvm_start_get_nvm(struct iwl_mvm *mvm)\n{\n\tstruct iwl_trans *trans = mvm->trans;\n\tint ret;\n\n\tif (trans->csme_own) {\n\t\tif (WARN(!mvm->mei_registered,\n\t\t\t \"csme is owner, but we aren't registered to iwlmei\\n\"))\n\t\t\tgoto get_nvm_from_fw;\n\n\t\tmvm->mei_nvm_data = iwl_mei_get_nvm();\n\t\tif (mvm->mei_nvm_data) {\n\t\t\t \n\t\t\tmvm->nvm_data =\n\t\t\t\tiwl_parse_mei_nvm_data(trans, trans->cfg,\n\t\t\t\t\t\t       mvm->mei_nvm_data, mvm->fw);\n\t\t\treturn 0;\n\t\t}\n\n\t\tIWL_ERR(mvm,\n\t\t\t\"Got a NULL NVM from CSME, trying to get it from the device\\n\");\n\t}\n\nget_nvm_from_fw:\n\trtnl_lock();\n\twiphy_lock(mvm->hw->wiphy);\n\tmutex_lock(&mvm->mutex);\n\n\tret = iwl_trans_start_hw(mvm->trans);\n\tif (ret) {\n\t\tmutex_unlock(&mvm->mutex);\n\t\twiphy_unlock(mvm->hw->wiphy);\n\t\trtnl_unlock();\n\t\treturn ret;\n\t}\n\n\tret = iwl_run_init_mvm_ucode(mvm);\n\tif (ret && ret != -ERFKILL)\n\t\tiwl_fw_dbg_error_collect(&mvm->fwrt, FW_DBG_TRIGGER_DRIVER);\n\tif (!ret && iwl_mvm_is_lar_supported(mvm)) {\n\t\tmvm->hw->wiphy->regulatory_flags |= REGULATORY_WIPHY_SELF_MANAGED;\n\t\tret = iwl_mvm_init_mcc(mvm);\n\t}\n\n\tif (!iwlmvm_mod_params.init_dbg || !ret)\n\t\tiwl_mvm_stop_device(mvm);\n\n\tmutex_unlock(&mvm->mutex);\n\twiphy_unlock(mvm->hw->wiphy);\n\trtnl_unlock();\n\n\tif (ret)\n\t\tIWL_ERR(mvm, \"Failed to run INIT ucode: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int iwl_mvm_start_post_nvm(struct iwl_mvm *mvm)\n{\n\tstruct iwl_mvm_csme_conn_info *csme_conn_info __maybe_unused;\n\tint ret;\n\n\tiwl_mvm_toggle_tx_ant(mvm, &mvm->mgmt_last_antenna_idx);\n\n\tret = iwl_mvm_mac_setup_register(mvm);\n\tif (ret)\n\t\treturn ret;\n\n\tmvm->hw_registered = true;\n\n\tiwl_mvm_dbgfs_register(mvm);\n\n\twiphy_rfkill_set_hw_state_reason(mvm->hw->wiphy,\n\t\t\t\t\t mvm->mei_rfkill_blocked,\n\t\t\t\t\t RFKILL_HARD_BLOCK_NOT_OWNER);\n\n\tiwl_mvm_mei_set_sw_rfkill_state(mvm);\n\n\treturn 0;\n}\n\nstruct iwl_mvm_frob_txf_data {\n\tu8 *buf;\n\tsize_t buflen;\n};\n\nstatic void iwl_mvm_frob_txf_key_iter(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      struct ieee80211_key_conf *key,\n\t\t\t\t      void *data)\n{\n\tstruct iwl_mvm_frob_txf_data *txf = data;\n\tu8 keylen, match, matchend;\n\tu8 *keydata;\n\tsize_t i;\n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tkeydata = key->key;\n\t\tkeylen = key->keylen;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t \n\t\tmemset(txf->buf, 0xBB, txf->buflen);\n\t\treturn;\n\tdefault:\n\t\treturn;\n\t}\n\n\t \n\tmatch = 0;\n\tfor (i = 0; i < txf->buflen; i++) {\n\t\tif (txf->buf[i] != keydata[match]) {\n\t\t\tmatch = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tmatch++;\n\t\tif (match == keylen) {\n\t\t\tmemset(txf->buf + i - keylen, 0xAA, keylen);\n\t\t\tmatch = 0;\n\t\t}\n\t}\n\n\t \n\tmatchend = match;\n\tfor (i = 0; match && i < keylen - match; i++) {\n\t\tif (txf->buf[i] != keydata[match])\n\t\t\tbreak;\n\t\tmatch++;\n\t\tif (match == keylen) {\n\t\t\tmemset(txf->buf, 0xAA, i + 1);\n\t\t\tmemset(txf->buf + txf->buflen - matchend, 0xAA,\n\t\t\t       matchend);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void iwl_mvm_frob_txf(void *ctx, void *buf, size_t buflen)\n{\n\tstruct iwl_mvm_frob_txf_data txf = {\n\t\t.buf = buf,\n\t\t.buflen = buflen,\n\t};\n\tstruct iwl_mvm *mvm = ctx;\n\n\t \n\tif (iwl_mvm_has_new_tx_api(mvm))\n\t\treturn;\n\n\trcu_read_lock();\n\tieee80211_iter_keys_rcu(mvm->hw, NULL, iwl_mvm_frob_txf_key_iter, &txf);\n\trcu_read_unlock();\n}\n\nstatic void iwl_mvm_frob_hcmd(void *ctx, void *hcmd, size_t len)\n{\n\t \n\tstruct iwl_cmd_header_wide *hdr = hcmd;\n\tunsigned int frob_start = sizeof(*hdr), frob_end = 0;\n\n\tif (len < sizeof(hdr))\n\t\treturn;\n\n\t \n\tif (hdr->group_id != LONG_GROUP)\n\t\treturn;\n\n\tswitch (hdr->cmd) {\n\tcase WEP_KEY:\n\tcase WOWLAN_TKIP_PARAM:\n\tcase WOWLAN_KEK_KCK_MATERIAL:\n\tcase ADD_STA_KEY:\n\t\t \n\t\tfrob_end = INT_MAX;\n\t\tbreak;\n\tcase MGMT_MCAST_KEY:\n\t\tfrob_start = offsetof(struct iwl_mvm_mgmt_mcast_key_cmd, igtk);\n\t\tBUILD_BUG_ON(offsetof(struct iwl_mvm_mgmt_mcast_key_cmd, igtk) !=\n\t\t\t     offsetof(struct iwl_mvm_mgmt_mcast_key_cmd_v1, igtk));\n\n\t\tfrob_end = offsetofend(struct iwl_mvm_mgmt_mcast_key_cmd, igtk);\n\t\tBUILD_BUG_ON(offsetof(struct iwl_mvm_mgmt_mcast_key_cmd, igtk) <\n\t\t\t     offsetof(struct iwl_mvm_mgmt_mcast_key_cmd_v1, igtk));\n\t\tbreak;\n\t}\n\n\tif (frob_start >= frob_end)\n\t\treturn;\n\n\tif (frob_end > len)\n\t\tfrob_end = len;\n\n\tmemset((u8 *)hcmd + frob_start, 0xAA, frob_end - frob_start);\n}\n\nstatic void iwl_mvm_frob_mem(void *ctx, u32 mem_addr, void *mem, size_t buflen)\n{\n\tconst struct iwl_dump_exclude *excl;\n\tstruct iwl_mvm *mvm = ctx;\n\tint i;\n\n\tswitch (mvm->fwrt.cur_fw_img) {\n\tcase IWL_UCODE_INIT:\n\tdefault:\n\t\t \n\t\treturn;\n\tcase IWL_UCODE_REGULAR:\n\tcase IWL_UCODE_REGULAR_USNIFFER:\n\t\texcl = mvm->fw->dump_excl;\n\t\tbreak;\n\tcase IWL_UCODE_WOWLAN:\n\t\texcl = mvm->fw->dump_excl_wowlan;\n\t\tbreak;\n\t}\n\n\tBUILD_BUG_ON(sizeof(mvm->fw->dump_excl) !=\n\t\t     sizeof(mvm->fw->dump_excl_wowlan));\n\n\tfor (i = 0; i < ARRAY_SIZE(mvm->fw->dump_excl); i++) {\n\t\tu32 start, end;\n\n\t\tif (!excl[i].addr || !excl[i].size)\n\t\t\tcontinue;\n\n\t\tstart = excl[i].addr;\n\t\tend = start + excl[i].size;\n\n\t\tif (end <= mem_addr || start >= mem_addr + buflen)\n\t\t\tcontinue;\n\n\t\tif (start < mem_addr)\n\t\t\tstart = mem_addr;\n\n\t\tif (end > mem_addr + buflen)\n\t\t\tend = mem_addr + buflen;\n\n\t\tmemset((u8 *)mem + start - mem_addr, 0xAA, end - start);\n\t}\n}\n\nstatic const struct iwl_dump_sanitize_ops iwl_mvm_sanitize_ops = {\n\t.frob_txf = iwl_mvm_frob_txf,\n\t.frob_hcmd = iwl_mvm_frob_hcmd,\n\t.frob_mem = iwl_mvm_frob_mem,\n};\n\nstatic void iwl_mvm_me_conn_status(void *priv, const struct iwl_mei_conn_info *conn_info)\n{\n\tstruct iwl_mvm *mvm = priv;\n\tstruct iwl_mvm_csme_conn_info *prev_conn_info, *curr_conn_info;\n\n\t \n\tprev_conn_info = rcu_dereference_protected(mvm->csme_conn_info, true);\n\n\tcurr_conn_info = kzalloc(sizeof(*curr_conn_info), GFP_KERNEL);\n\tif (!curr_conn_info)\n\t\treturn;\n\n\tcurr_conn_info->conn_info = *conn_info;\n\n\trcu_assign_pointer(mvm->csme_conn_info, curr_conn_info);\n\n\tif (prev_conn_info)\n\t\tkfree_rcu(prev_conn_info, rcu_head);\n}\n\nstatic void iwl_mvm_mei_rfkill(void *priv, bool blocked,\n\t\t\t       bool csme_taking_ownership)\n{\n\tstruct iwl_mvm *mvm = priv;\n\n\tif (blocked && !csme_taking_ownership)\n\t\treturn;\n\n\tmvm->mei_rfkill_blocked = blocked;\n\tif (!mvm->hw_registered)\n\t\treturn;\n\n\twiphy_rfkill_set_hw_state_reason(mvm->hw->wiphy,\n\t\t\t\t\t mvm->mei_rfkill_blocked,\n\t\t\t\t\t RFKILL_HARD_BLOCK_NOT_OWNER);\n}\n\nstatic void iwl_mvm_mei_roaming_forbidden(void *priv, bool forbidden)\n{\n\tstruct iwl_mvm *mvm = priv;\n\n\tif (!mvm->hw_registered || !mvm->csme_vif)\n\t\treturn;\n\n\tiwl_mvm_send_roaming_forbidden_event(mvm, mvm->csme_vif, forbidden);\n}\n\nstatic void iwl_mvm_sap_connected_wk(struct work_struct *wk)\n{\n\tstruct iwl_mvm *mvm =\n\t\tcontainer_of(wk, struct iwl_mvm, sap_connected_wk);\n\tint ret;\n\n\tret = iwl_mvm_start_get_nvm(mvm);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = iwl_mvm_start_post_nvm(mvm);\n\tif (ret)\n\t\tgoto out_free;\n\n\treturn;\n\nout_free:\n\tIWL_ERR(mvm, \"Couldn't get started...\\n\");\n\tiwl_mei_start_unregister();\n\tiwl_mei_unregister_complete();\n\tiwl_fw_flush_dumps(&mvm->fwrt);\n\tiwl_mvm_thermal_exit(mvm);\n\tiwl_fw_runtime_free(&mvm->fwrt);\n\tiwl_phy_db_free(mvm->phy_db);\n\tkfree(mvm->scan_cmd);\n\tiwl_trans_op_mode_leave(mvm->trans);\n\tkfree(mvm->nvm_data);\n\tkfree(mvm->mei_nvm_data);\n\n\tieee80211_free_hw(mvm->hw);\n}\n\nstatic void iwl_mvm_mei_sap_connected(void *priv)\n{\n\tstruct iwl_mvm *mvm = priv;\n\n\tif (!mvm->hw_registered)\n\t\tschedule_work(&mvm->sap_connected_wk);\n}\n\nstatic void iwl_mvm_mei_nic_stolen(void *priv)\n{\n\tstruct iwl_mvm *mvm = priv;\n\n\trtnl_lock();\n\tcfg80211_shutdown_all_interfaces(mvm->hw->wiphy);\n\trtnl_unlock();\n}\n\nstatic const struct iwl_mei_ops mei_ops = {\n\t.me_conn_status = iwl_mvm_me_conn_status,\n\t.rfkill = iwl_mvm_mei_rfkill,\n\t.roaming_forbidden = iwl_mvm_mei_roaming_forbidden,\n\t.sap_connected = iwl_mvm_mei_sap_connected,\n\t.nic_stolen = iwl_mvm_mei_nic_stolen,\n};\n\nstatic struct iwl_op_mode *\niwl_op_mode_mvm_start(struct iwl_trans *trans, const struct iwl_cfg *cfg,\n\t\t      const struct iwl_fw *fw, struct dentry *dbgfs_dir)\n{\n\tstruct ieee80211_hw *hw;\n\tstruct iwl_op_mode *op_mode;\n\tstruct iwl_mvm *mvm;\n\tstruct iwl_trans_config trans_cfg = {};\n\tstatic const u8 no_reclaim_cmds[] = {\n\t\tTX_CMD,\n\t};\n\tu32 max_agg;\n\tsize_t scan_size;\n\tu32 min_backoff;\n\tstruct iwl_mvm_csme_conn_info *csme_conn_info __maybe_unused;\n\n\t \n\tBUILD_BUG_ON(ARRAY_SIZE(mvm->fw_id_to_mac_id) !=\n\t\t     IWL_MVM_STATION_COUNT_MAX);\n\n\t \n\thw = ieee80211_alloc_hw(sizeof(struct iwl_op_mode) +\n\t\t\t\tsizeof(struct iwl_mvm),\n\t\t\t\tiwl_mvm_has_mld_api(fw) ? &iwl_mvm_mld_hw_ops :\n\t\t\t\t&iwl_mvm_hw_ops);\n\tif (!hw)\n\t\treturn NULL;\n\n\tif (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_BZ)\n\t\tmax_agg = IEEE80211_MAX_AMPDU_BUF_EHT;\n\telse\n\t\tmax_agg = IEEE80211_MAX_AMPDU_BUF_HE;\n\n\thw->max_rx_aggregation_subframes = max_agg;\n\n\tif (cfg->max_tx_agg_size)\n\t\thw->max_tx_aggregation_subframes = cfg->max_tx_agg_size;\n\telse\n\t\thw->max_tx_aggregation_subframes = max_agg;\n\n\top_mode = hw->priv;\n\n\tmvm = IWL_OP_MODE_GET_MVM(op_mode);\n\tmvm->dev = trans->dev;\n\tmvm->trans = trans;\n\tmvm->cfg = cfg;\n\tmvm->fw = fw;\n\tmvm->hw = hw;\n\n\tiwl_fw_runtime_init(&mvm->fwrt, trans, fw, &iwl_mvm_fwrt_ops, mvm,\n\t\t\t    &iwl_mvm_sanitize_ops, mvm, dbgfs_dir);\n\n\tiwl_mvm_get_acpi_tables(mvm);\n\tiwl_uefi_get_sgom_table(trans, &mvm->fwrt);\n\tiwl_uefi_get_step_table(trans);\n\n\tmvm->init_status = 0;\n\n\tif (iwl_mvm_has_new_rx_api(mvm)) {\n\t\top_mode->ops = &iwl_mvm_ops_mq;\n\t\ttrans->rx_mpdu_cmd_hdr_size =\n\t\t\t(trans->trans_cfg->device_family >=\n\t\t\t IWL_DEVICE_FAMILY_AX210) ?\n\t\t\tsizeof(struct iwl_rx_mpdu_desc) :\n\t\t\tIWL_RX_DESC_SIZE_V1;\n\t} else {\n\t\top_mode->ops = &iwl_mvm_ops;\n\t\ttrans->rx_mpdu_cmd_hdr_size =\n\t\t\tsizeof(struct iwl_rx_mpdu_res_start);\n\n\t\tif (WARN_ON(trans->num_rx_queues > 1))\n\t\t\tgoto out_free;\n\t}\n\n\tmvm->fw_restart = iwlwifi_mod_params.fw_restart ? -1 : 0;\n\n\tif (iwl_mvm_has_new_tx_api(mvm)) {\n\t\t \n\t\tmvm->aux_queue = IWL_MVM_INVALID_QUEUE;\n\t\tmvm->snif_queue = IWL_MVM_INVALID_QUEUE;\n\t\tmvm->probe_queue = IWL_MVM_INVALID_QUEUE;\n\t\tmvm->p2p_dev_queue = IWL_MVM_INVALID_QUEUE;\n\t} else {\n\t\tmvm->aux_queue = IWL_MVM_DQA_AUX_QUEUE;\n\t\tmvm->snif_queue = IWL_MVM_DQA_INJECT_MONITOR_QUEUE;\n\t\tmvm->probe_queue = IWL_MVM_DQA_AP_PROBE_RESP_QUEUE;\n\t\tmvm->p2p_dev_queue = IWL_MVM_DQA_P2P_DEVICE_QUEUE;\n\t}\n\n\tmvm->sf_state = SF_UNINIT;\n\tif (iwl_mvm_has_unified_ucode(mvm))\n\t\tiwl_fw_set_current_image(&mvm->fwrt, IWL_UCODE_REGULAR);\n\telse\n\t\tiwl_fw_set_current_image(&mvm->fwrt, IWL_UCODE_INIT);\n\tmvm->drop_bcn_ap_mode = true;\n\n\tmutex_init(&mvm->mutex);\n\tspin_lock_init(&mvm->async_handlers_lock);\n\tINIT_LIST_HEAD(&mvm->time_event_list);\n\tINIT_LIST_HEAD(&mvm->aux_roc_te_list);\n\tINIT_LIST_HEAD(&mvm->async_handlers_list);\n\tspin_lock_init(&mvm->time_event_lock);\n\tINIT_LIST_HEAD(&mvm->ftm_initiator.loc_list);\n\tINIT_LIST_HEAD(&mvm->ftm_initiator.pasn_list);\n\tINIT_LIST_HEAD(&mvm->resp_pasn_list);\n\n\tINIT_WORK(&mvm->async_handlers_wk, iwl_mvm_async_handlers_wk);\n\tINIT_WORK(&mvm->roc_done_wk, iwl_mvm_roc_done_wk);\n\tINIT_WORK(&mvm->sap_connected_wk, iwl_mvm_sap_connected_wk);\n\tINIT_DELAYED_WORK(&mvm->tdls_cs.dwork, iwl_mvm_tdls_ch_switch_work);\n\tINIT_DELAYED_WORK(&mvm->scan_timeout_dwork, iwl_mvm_scan_timeout_wk);\n\tINIT_WORK(&mvm->add_stream_wk, iwl_mvm_add_new_dqa_stream_wk);\n\tINIT_LIST_HEAD(&mvm->add_stream_txqs);\n\tspin_lock_init(&mvm->add_stream_lock);\n\n\tinit_waitqueue_head(&mvm->rx_sync_waitq);\n\n\tmvm->queue_sync_state = 0;\n\n\tSET_IEEE80211_DEV(mvm->hw, mvm->trans->dev);\n\n\tspin_lock_init(&mvm->tcm.lock);\n\tINIT_DELAYED_WORK(&mvm->tcm.work, iwl_mvm_tcm_work);\n\tmvm->tcm.ts = jiffies;\n\tmvm->tcm.ll_ts = jiffies;\n\tmvm->tcm.uapsd_nonagg_ts = jiffies;\n\n\tINIT_DELAYED_WORK(&mvm->cs_tx_unblock_dwork, iwl_mvm_tx_unblock_dwork);\n\n\tmvm->cmd_ver.range_resp =\n\t\tiwl_fw_lookup_notif_ver(mvm->fw, LOCATION_GROUP,\n\t\t\t\t\tTOF_RANGE_RESPONSE_NOTIF, 5);\n\t \n\tif (WARN_ON_ONCE(mvm->cmd_ver.range_resp > 9))\n\t\tgoto out_free;\n\n\t \n\ttrans_cfg.op_mode = op_mode;\n\ttrans_cfg.no_reclaim_cmds = no_reclaim_cmds;\n\ttrans_cfg.n_no_reclaim_cmds = ARRAY_SIZE(no_reclaim_cmds);\n\n\tswitch (iwlwifi_mod_params.amsdu_size) {\n\tcase IWL_AMSDU_DEF:\n\t\ttrans_cfg.rx_buf_size = IWL_AMSDU_4K;\n\t\tbreak;\n\tcase IWL_AMSDU_4K:\n\t\ttrans_cfg.rx_buf_size = IWL_AMSDU_4K;\n\t\tbreak;\n\tcase IWL_AMSDU_8K:\n\t\ttrans_cfg.rx_buf_size = IWL_AMSDU_8K;\n\t\tbreak;\n\tcase IWL_AMSDU_12K:\n\t\ttrans_cfg.rx_buf_size = IWL_AMSDU_12K;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: Unsupported amsdu_size: %d\\n\", KBUILD_MODNAME,\n\t\t       iwlwifi_mod_params.amsdu_size);\n\t\ttrans_cfg.rx_buf_size = IWL_AMSDU_4K;\n\t}\n\n\ttrans->wide_cmd_header = true;\n\ttrans_cfg.bc_table_dword =\n\t\tmvm->trans->trans_cfg->device_family < IWL_DEVICE_FAMILY_AX210;\n\n\ttrans_cfg.command_groups = iwl_mvm_groups;\n\ttrans_cfg.command_groups_size = ARRAY_SIZE(iwl_mvm_groups);\n\n\ttrans_cfg.cmd_queue = IWL_MVM_DQA_CMD_QUEUE;\n\ttrans_cfg.cmd_fifo = IWL_MVM_TX_FIFO_CMD;\n\ttrans_cfg.scd_set_active = true;\n\n\ttrans_cfg.cb_data_offs = offsetof(struct ieee80211_tx_info,\n\t\t\t\t\t  driver_data[2]);\n\n\t \n\ttrans_cfg.cmd_q_wdg_timeout =\n\t\tiwl_mvm_get_wd_timeout(mvm, NULL, false, true);\n\n\tsnprintf(mvm->hw->wiphy->fw_version,\n\t\t sizeof(mvm->hw->wiphy->fw_version),\n\t\t \"%s\", fw->fw_version);\n\n\ttrans_cfg.fw_reset_handshake = fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t\t\t\t   IWL_UCODE_TLV_CAPA_FW_RESET_HANDSHAKE);\n\n\ttrans_cfg.queue_alloc_cmd_ver =\n\t\tiwl_fw_lookup_cmd_ver(mvm->fw,\n\t\t\t\t      WIDE_ID(DATA_PATH_GROUP,\n\t\t\t\t\t      SCD_QUEUE_CONFIG_CMD),\n\t\t\t\t      0);\n\tmvm->sta_remove_requires_queue_remove =\n\t\ttrans_cfg.queue_alloc_cmd_ver > 0;\n\n\tmvm->mld_api_is_used = iwl_mvm_has_mld_api(mvm->fw);\n\n\t \n\tiwl_trans_configure(mvm->trans, &trans_cfg);\n\n\ttrans->rx_mpdu_cmd = REPLY_RX_MPDU_CMD;\n\ttrans->dbg.dest_tlv = mvm->fw->dbg.dest_tlv;\n\ttrans->dbg.n_dest_reg = mvm->fw->dbg.n_dest_reg;\n\tmemcpy(trans->dbg.conf_tlv, mvm->fw->dbg.conf_tlv,\n\t       sizeof(trans->dbg.conf_tlv));\n\ttrans->dbg.trigger_tlv = mvm->fw->dbg.trigger_tlv;\n\n\ttrans->iml = mvm->fw->iml;\n\ttrans->iml_len = mvm->fw->iml_len;\n\n\t \n\tiwl_notification_wait_init(&mvm->notif_wait);\n\n\t \n\tmvm->phy_db = iwl_phy_db_init(trans);\n\tif (!mvm->phy_db) {\n\t\tIWL_ERR(mvm, \"Cannot init phy_db\\n\");\n\t\tgoto out_free;\n\t}\n\n\tIWL_INFO(mvm, \"Detected %s, REV=0x%X\\n\",\n\t\t mvm->trans->name, mvm->trans->hw_rev);\n\n\tif (iwlwifi_mod_params.nvm_file)\n\t\tmvm->nvm_file_name = iwlwifi_mod_params.nvm_file;\n\telse\n\t\tIWL_DEBUG_EEPROM(mvm->trans->dev,\n\t\t\t\t \"working without external nvm file\\n\");\n\n\tscan_size = iwl_mvm_scan_size(mvm);\n\n\tmvm->scan_cmd = kmalloc(scan_size, GFP_KERNEL);\n\tif (!mvm->scan_cmd)\n\t\tgoto out_free;\n\tmvm->scan_cmd_size = scan_size;\n\n\t \n\tmvm->aux_sta.sta_id = IWL_MVM_INVALID_STA;\n\tmvm->snif_sta.sta_id = IWL_MVM_INVALID_STA;\n\n\t \n\tmvm->last_ebs_successful = true;\n\n\tmin_backoff = iwl_mvm_min_backoff(mvm);\n\tiwl_mvm_thermal_initialize(mvm, min_backoff);\n\n\tif (!iwl_mvm_has_new_rx_stats_api(mvm))\n\t\tmemset(&mvm->rx_stats_v3, 0,\n\t\t       sizeof(struct mvm_statistics_rx_v3));\n\telse\n\t\tmemset(&mvm->rx_stats, 0, sizeof(struct mvm_statistics_rx));\n\n\tiwl_mvm_ftm_initiator_smooth_config(mvm);\n\n\tiwl_mvm_init_time_sync(&mvm->time_sync);\n\n\tmvm->debugfs_dir = dbgfs_dir;\n\n\tmvm->mei_registered = !iwl_mei_register(mvm, &mei_ops);\n\n\tiwl_mvm_mei_scan_filter_init(&mvm->mei_scan_filter);\n\n\tif (iwl_mvm_start_get_nvm(mvm)) {\n\t\t \n\t\tif (trans->csme_own && mvm->mei_registered)\n\t\t\treturn op_mode;\n\n\t\tgoto out_thermal_exit;\n\t}\n\n\n\tif (iwl_mvm_start_post_nvm(mvm))\n\t\tgoto out_thermal_exit;\n\n\treturn op_mode;\n\n out_thermal_exit:\n\tiwl_mvm_thermal_exit(mvm);\n\tif (mvm->mei_registered) {\n\t\tiwl_mei_start_unregister();\n\t\tiwl_mei_unregister_complete();\n\t}\n out_free:\n\tiwl_fw_flush_dumps(&mvm->fwrt);\n\tiwl_fw_runtime_free(&mvm->fwrt);\n\n\tif (iwlmvm_mod_params.init_dbg)\n\t\treturn op_mode;\n\tiwl_phy_db_free(mvm->phy_db);\n\tkfree(mvm->scan_cmd);\n\tiwl_trans_op_mode_leave(trans);\n\n\tieee80211_free_hw(mvm->hw);\n\treturn NULL;\n}\n\nvoid iwl_mvm_stop_device(struct iwl_mvm *mvm)\n{\n\tlockdep_assert_held(&mvm->mutex);\n\n\tiwl_fw_cancel_timestamp(&mvm->fwrt);\n\n\tclear_bit(IWL_MVM_STATUS_FIRMWARE_RUNNING, &mvm->status);\n\n\tiwl_fw_dbg_stop_sync(&mvm->fwrt);\n\tiwl_trans_stop_device(mvm->trans);\n\tiwl_free_fw_paging(&mvm->fwrt);\n\tiwl_fw_dump_conf_clear(&mvm->fwrt);\n\tiwl_mvm_mei_device_state(mvm, false);\n}\n\nstatic void iwl_op_mode_mvm_stop(struct iwl_op_mode *op_mode)\n{\n\tstruct iwl_mvm *mvm = IWL_OP_MODE_GET_MVM(op_mode);\n\tint i;\n\n\tif (mvm->mei_registered) {\n\t\trtnl_lock();\n\t\tiwl_mei_set_netdev(NULL);\n\t\trtnl_unlock();\n\t\tiwl_mei_start_unregister();\n\t}\n\n\t \n\tcancel_work_sync(&mvm->sap_connected_wk);\n\n\tiwl_mvm_leds_exit(mvm);\n\n\tiwl_mvm_thermal_exit(mvm);\n\n\t \n\tif (mvm->hw_registered)\n\t\tieee80211_unregister_hw(mvm->hw);\n\n\tkfree(mvm->scan_cmd);\n\tkfree(mvm->mcast_filter_cmd);\n\tmvm->mcast_filter_cmd = NULL;\n\n\tkfree(mvm->error_recovery_buf);\n\tmvm->error_recovery_buf = NULL;\n\n\tiwl_mvm_ptp_remove(mvm);\n\n\tiwl_trans_op_mode_leave(mvm->trans);\n\n\tiwl_phy_db_free(mvm->phy_db);\n\tmvm->phy_db = NULL;\n\n\tkfree(mvm->nvm_data);\n\tkfree(mvm->mei_nvm_data);\n\tkfree(rcu_access_pointer(mvm->csme_conn_info));\n\tkfree(mvm->temp_nvm_data);\n\tfor (i = 0; i < NVM_MAX_NUM_SECTIONS; i++)\n\t\tkfree(mvm->nvm_sections[i].data);\n\n\tcancel_delayed_work_sync(&mvm->tcm.work);\n\n\tiwl_fw_runtime_free(&mvm->fwrt);\n\tmutex_destroy(&mvm->mutex);\n\n\tif (mvm->mei_registered)\n\t\tiwl_mei_unregister_complete();\n\n\tieee80211_free_hw(mvm->hw);\n}\n\nstruct iwl_async_handler_entry {\n\tstruct list_head list;\n\tstruct iwl_rx_cmd_buffer rxb;\n\tenum iwl_rx_handler_context context;\n\tvoid (*fn)(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb);\n};\n\nvoid iwl_mvm_async_handlers_purge(struct iwl_mvm *mvm)\n{\n\tstruct iwl_async_handler_entry *entry, *tmp;\n\n\tspin_lock_bh(&mvm->async_handlers_lock);\n\tlist_for_each_entry_safe(entry, tmp, &mvm->async_handlers_list, list) {\n\t\tiwl_free_rxb(&entry->rxb);\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\tspin_unlock_bh(&mvm->async_handlers_lock);\n}\n\nstatic void iwl_mvm_async_handlers_wk(struct work_struct *wk)\n{\n\tstruct iwl_mvm *mvm =\n\t\tcontainer_of(wk, struct iwl_mvm, async_handlers_wk);\n\tstruct iwl_async_handler_entry *entry, *tmp;\n\tLIST_HEAD(local_list);\n\n\t \n\n\t \n\tspin_lock_bh(&mvm->async_handlers_lock);\n\tlist_splice_init(&mvm->async_handlers_list, &local_list);\n\tspin_unlock_bh(&mvm->async_handlers_lock);\n\n\tlist_for_each_entry_safe(entry, tmp, &local_list, list) {\n\t\tif (entry->context == RX_HANDLER_ASYNC_LOCKED)\n\t\t\tmutex_lock(&mvm->mutex);\n\t\tentry->fn(mvm, &entry->rxb);\n\t\tiwl_free_rxb(&entry->rxb);\n\t\tlist_del(&entry->list);\n\t\tif (entry->context == RX_HANDLER_ASYNC_LOCKED)\n\t\t\tmutex_unlock(&mvm->mutex);\n\t\tkfree(entry);\n\t}\n}\n\nstatic inline void iwl_mvm_rx_check_trigger(struct iwl_mvm *mvm,\n\t\t\t\t\t    struct iwl_rx_packet *pkt)\n{\n\tstruct iwl_fw_dbg_trigger_tlv *trig;\n\tstruct iwl_fw_dbg_trigger_cmd *cmds_trig;\n\tint i;\n\n\ttrig = iwl_fw_dbg_trigger_on(&mvm->fwrt, NULL,\n\t\t\t\t     FW_DBG_TRIGGER_FW_NOTIF);\n\tif (!trig)\n\t\treturn;\n\n\tcmds_trig = (void *)trig->data;\n\n\tfor (i = 0; i < ARRAY_SIZE(cmds_trig->cmds); i++) {\n\t\t \n\t\tif (!cmds_trig->cmds[i].cmd_id)\n\t\t\tbreak;\n\n\t\tif (cmds_trig->cmds[i].cmd_id != pkt->hdr.cmd ||\n\t\t    cmds_trig->cmds[i].group_id != pkt->hdr.group_id)\n\t\t\tcontinue;\n\n\t\tiwl_fw_dbg_collect_trig(&mvm->fwrt, trig,\n\t\t\t\t\t\"CMD 0x%02x.%02x received\",\n\t\t\t\t\tpkt->hdr.group_id, pkt->hdr.cmd);\n\t\tbreak;\n\t}\n}\n\nstatic void iwl_mvm_rx_common(struct iwl_mvm *mvm,\n\t\t\t      struct iwl_rx_cmd_buffer *rxb,\n\t\t\t      struct iwl_rx_packet *pkt)\n{\n\tunsigned int pkt_len = iwl_rx_packet_payload_len(pkt);\n\tint i;\n\tunion iwl_dbg_tlv_tp_data tp_data = { .fw_pkt = pkt };\n\n\tiwl_dbg_tlv_time_point(&mvm->fwrt,\n\t\t\t       IWL_FW_INI_TIME_POINT_FW_RSP_OR_NOTIF, &tp_data);\n\tiwl_mvm_rx_check_trigger(mvm, pkt);\n\n\t \n\tiwl_notification_wait_notify(&mvm->notif_wait, pkt);\n\n\tfor (i = 0; i < ARRAY_SIZE(iwl_mvm_rx_handlers); i++) {\n\t\tconst struct iwl_rx_handlers *rx_h = &iwl_mvm_rx_handlers[i];\n\t\tstruct iwl_async_handler_entry *entry;\n\n\t\tif (rx_h->cmd_id != WIDE_ID(pkt->hdr.group_id, pkt->hdr.cmd))\n\t\t\tcontinue;\n\n\t\tif (IWL_FW_CHECK(mvm, pkt_len < rx_h->min_size,\n\t\t\t\t \"unexpected notification 0x%04x size %d, need %d\\n\",\n\t\t\t\t rx_h->cmd_id, pkt_len, rx_h->min_size))\n\t\t\treturn;\n\n\t\tif (rx_h->context == RX_HANDLER_SYNC) {\n\t\t\trx_h->fn(mvm, rxb);\n\t\t\treturn;\n\t\t}\n\n\t\tentry = kzalloc(sizeof(*entry), GFP_ATOMIC);\n\t\t \n\t\tif (!entry)\n\t\t\treturn;\n\n\t\tentry->rxb._page = rxb_steal_page(rxb);\n\t\tentry->rxb._offset = rxb->_offset;\n\t\tentry->rxb._rx_page_order = rxb->_rx_page_order;\n\t\tentry->fn = rx_h->fn;\n\t\tentry->context = rx_h->context;\n\t\tspin_lock(&mvm->async_handlers_lock);\n\t\tlist_add_tail(&entry->list, &mvm->async_handlers_list);\n\t\tspin_unlock(&mvm->async_handlers_lock);\n\t\tschedule_work(&mvm->async_handlers_wk);\n\t\tbreak;\n\t}\n}\n\nstatic void iwl_mvm_rx(struct iwl_op_mode *op_mode,\n\t\t       struct napi_struct *napi,\n\t\t       struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_mvm *mvm = IWL_OP_MODE_GET_MVM(op_mode);\n\tu16 cmd = WIDE_ID(pkt->hdr.group_id, pkt->hdr.cmd);\n\n\tif (likely(cmd == WIDE_ID(LEGACY_GROUP, REPLY_RX_MPDU_CMD)))\n\t\tiwl_mvm_rx_rx_mpdu(mvm, napi, rxb);\n\telse if (cmd == WIDE_ID(LEGACY_GROUP, REPLY_RX_PHY_CMD))\n\t\tiwl_mvm_rx_rx_phy_cmd(mvm, rxb);\n\telse\n\t\tiwl_mvm_rx_common(mvm, rxb, pkt);\n}\n\nvoid iwl_mvm_rx_mq(struct iwl_op_mode *op_mode,\n\t\t   struct napi_struct *napi,\n\t\t   struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_mvm *mvm = IWL_OP_MODE_GET_MVM(op_mode);\n\tu16 cmd = WIDE_ID(pkt->hdr.group_id, pkt->hdr.cmd);\n\n\tif (likely(cmd == WIDE_ID(LEGACY_GROUP, REPLY_RX_MPDU_CMD)))\n\t\tiwl_mvm_rx_mpdu_mq(mvm, napi, rxb, 0);\n\telse if (unlikely(cmd == WIDE_ID(DATA_PATH_GROUP,\n\t\t\t\t\t RX_QUEUES_NOTIFICATION)))\n\t\tiwl_mvm_rx_queue_notif(mvm, napi, rxb, 0);\n\telse if (cmd == WIDE_ID(LEGACY_GROUP, FRAME_RELEASE))\n\t\tiwl_mvm_rx_frame_release(mvm, napi, rxb, 0);\n\telse if (cmd == WIDE_ID(LEGACY_GROUP, BAR_FRAME_RELEASE))\n\t\tiwl_mvm_rx_bar_frame_release(mvm, napi, rxb, 0);\n\telse if (cmd == WIDE_ID(DATA_PATH_GROUP, RX_NO_DATA_NOTIF))\n\t\tiwl_mvm_rx_monitor_no_data(mvm, napi, rxb, 0);\n\telse\n\t\tiwl_mvm_rx_common(mvm, rxb, pkt);\n}\n\nstatic void iwl_mvm_async_cb(struct iwl_op_mode *op_mode,\n\t\t\t     const struct iwl_device_cmd *cmd)\n{\n\tstruct iwl_mvm *mvm = IWL_OP_MODE_GET_MVM(op_mode);\n\n\t \n\tiwl_trans_block_txq_ptrs(mvm->trans, false);\n}\n\nstatic int iwl_mvm_is_static_queue(struct iwl_mvm *mvm, int queue)\n{\n\treturn queue == mvm->aux_queue || queue == mvm->probe_queue ||\n\t\tqueue == mvm->p2p_dev_queue || queue == mvm->snif_queue;\n}\n\nstatic void iwl_mvm_queue_state_change(struct iwl_op_mode *op_mode,\n\t\t\t\t       int hw_queue, bool start)\n{\n\tstruct iwl_mvm *mvm = IWL_OP_MODE_GET_MVM(op_mode);\n\tstruct ieee80211_sta *sta;\n\tstruct ieee80211_txq *txq;\n\tstruct iwl_mvm_txq *mvmtxq;\n\tint i;\n\tunsigned long tid_bitmap;\n\tstruct iwl_mvm_sta *mvmsta;\n\tu8 sta_id;\n\n\tsta_id = iwl_mvm_has_new_tx_api(mvm) ?\n\t\tmvm->tvqm_info[hw_queue].sta_id :\n\t\tmvm->queue_info[hw_queue].ra_sta_id;\n\n\tif (WARN_ON_ONCE(sta_id >= mvm->fw->ucode_capa.num_stations))\n\t\treturn;\n\n\trcu_read_lock();\n\n\tsta = rcu_dereference(mvm->fw_id_to_mac_id[sta_id]);\n\tif (IS_ERR_OR_NULL(sta))\n\t\tgoto out;\n\tmvmsta = iwl_mvm_sta_from_mac80211(sta);\n\n\tif (iwl_mvm_is_static_queue(mvm, hw_queue)) {\n\t\tif (!start)\n\t\t\tieee80211_stop_queues(mvm->hw);\n\t\telse if (mvmsta->sta_state != IEEE80211_STA_NOTEXIST)\n\t\t\tieee80211_wake_queues(mvm->hw);\n\n\t\tgoto out;\n\t}\n\n\tif (iwl_mvm_has_new_tx_api(mvm)) {\n\t\tint tid = mvm->tvqm_info[hw_queue].txq_tid;\n\n\t\ttid_bitmap = BIT(tid);\n\t} else {\n\t\ttid_bitmap = mvm->queue_info[hw_queue].tid_bitmap;\n\t}\n\n\tfor_each_set_bit(i, &tid_bitmap, IWL_MAX_TID_COUNT + 1) {\n\t\tint tid = i;\n\n\t\tif (tid == IWL_MAX_TID_COUNT)\n\t\t\ttid = IEEE80211_NUM_TIDS;\n\n\t\ttxq = sta->txq[tid];\n\t\tmvmtxq = iwl_mvm_txq_from_mac80211(txq);\n\t\tif (start)\n\t\t\tclear_bit(IWL_MVM_TXQ_STATE_STOP_FULL, &mvmtxq->state);\n\t\telse\n\t\t\tset_bit(IWL_MVM_TXQ_STATE_STOP_FULL, &mvmtxq->state);\n\n\t\tif (start && mvmsta->sta_state != IEEE80211_STA_NOTEXIST) {\n\t\t\tlocal_bh_disable();\n\t\t\tiwl_mvm_mac_itxq_xmit(mvm->hw, txq);\n\t\t\tlocal_bh_enable();\n\t\t}\n\t}\n\nout:\n\trcu_read_unlock();\n}\n\nstatic void iwl_mvm_stop_sw_queue(struct iwl_op_mode *op_mode, int hw_queue)\n{\n\tiwl_mvm_queue_state_change(op_mode, hw_queue, false);\n}\n\nstatic void iwl_mvm_wake_sw_queue(struct iwl_op_mode *op_mode, int hw_queue)\n{\n\tiwl_mvm_queue_state_change(op_mode, hw_queue, true);\n}\n\nstatic void iwl_mvm_set_rfkill_state(struct iwl_mvm *mvm)\n{\n\tbool state = iwl_mvm_is_radio_killed(mvm);\n\n\tif (state)\n\t\twake_up(&mvm->rx_sync_waitq);\n\n\twiphy_rfkill_set_hw_state(mvm->hw->wiphy, state);\n}\n\nvoid iwl_mvm_set_hw_ctkill_state(struct iwl_mvm *mvm, bool state)\n{\n\tif (state)\n\t\tset_bit(IWL_MVM_STATUS_HW_CTKILL, &mvm->status);\n\telse\n\t\tclear_bit(IWL_MVM_STATUS_HW_CTKILL, &mvm->status);\n\n\tiwl_mvm_set_rfkill_state(mvm);\n}\n\nstruct iwl_mvm_csme_conn_info *iwl_mvm_get_csme_conn_info(struct iwl_mvm *mvm)\n{\n\treturn rcu_dereference_protected(mvm->csme_conn_info,\n\t\t\t\t\t lockdep_is_held(&mvm->mutex));\n}\n\nstatic bool iwl_mvm_set_hw_rfkill_state(struct iwl_op_mode *op_mode, bool state)\n{\n\tstruct iwl_mvm *mvm = IWL_OP_MODE_GET_MVM(op_mode);\n\tbool rfkill_safe_init_done = READ_ONCE(mvm->rfkill_safe_init_done);\n\tbool unified = iwl_mvm_has_unified_ucode(mvm);\n\n\tif (state)\n\t\tset_bit(IWL_MVM_STATUS_HW_RFKILL, &mvm->status);\n\telse\n\t\tclear_bit(IWL_MVM_STATUS_HW_RFKILL, &mvm->status);\n\n\tiwl_mvm_set_rfkill_state(mvm);\n\n\t  \n\tif (rfkill_safe_init_done)\n\t\tiwl_abort_notification_waits(&mvm->notif_wait);\n\n\t \n\tif (unified)\n\t\treturn false;\n\n\t \n\treturn state && rfkill_safe_init_done;\n}\n\nstatic void iwl_mvm_free_skb(struct iwl_op_mode *op_mode, struct sk_buff *skb)\n{\n\tstruct iwl_mvm *mvm = IWL_OP_MODE_GET_MVM(op_mode);\n\tstruct ieee80211_tx_info *info;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tiwl_trans_free_tx_cmd(mvm->trans, info->driver_data[1]);\n\tieee80211_free_txskb(mvm->hw, skb);\n}\n\nstruct iwl_mvm_reprobe {\n\tstruct device *dev;\n\tstruct work_struct work;\n};\n\nstatic void iwl_mvm_reprobe_wk(struct work_struct *wk)\n{\n\tstruct iwl_mvm_reprobe *reprobe;\n\n\treprobe = container_of(wk, struct iwl_mvm_reprobe, work);\n\tif (device_reprobe(reprobe->dev))\n\t\tdev_err(reprobe->dev, \"reprobe failed!\\n\");\n\tput_device(reprobe->dev);\n\tkfree(reprobe);\n\tmodule_put(THIS_MODULE);\n}\n\nvoid iwl_mvm_nic_restart(struct iwl_mvm *mvm, bool fw_error)\n{\n\tiwl_abort_notification_waits(&mvm->notif_wait);\n\tiwl_dbg_tlv_del_timers(mvm->trans);\n\n\t \n\tiwl_mvm_report_scan_aborted(mvm);\n\n\t \n\tif (!mvm->fw_restart && fw_error) {\n\t\tiwl_fw_error_collect(&mvm->fwrt, false);\n\t} else if (test_bit(IWL_MVM_STATUS_STARTING,\n\t\t\t    &mvm->status)) {\n\t\tIWL_ERR(mvm, \"Starting mac, retry will be triggered anyway\\n\");\n\t} else if (test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status)) {\n\t\tstruct iwl_mvm_reprobe *reprobe;\n\n\t\tIWL_ERR(mvm,\n\t\t\t\"Firmware error during reconfiguration - reprobe!\\n\");\n\n\t\t \n\t\tif (!try_module_get(THIS_MODULE)) {\n\t\t\tIWL_ERR(mvm, \"Module is being unloaded - abort\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\treprobe = kzalloc(sizeof(*reprobe), GFP_ATOMIC);\n\t\tif (!reprobe) {\n\t\t\tmodule_put(THIS_MODULE);\n\t\t\treturn;\n\t\t}\n\t\treprobe->dev = get_device(mvm->trans->dev);\n\t\tINIT_WORK(&reprobe->work, iwl_mvm_reprobe_wk);\n\t\tschedule_work(&reprobe->work);\n\t} else if (test_bit(IWL_MVM_STATUS_HW_RESTART_REQUESTED,\n\t\t\t    &mvm->status)) {\n\t\tIWL_ERR(mvm, \"HW restart already requested, but not started\\n\");\n\t} else if (mvm->fwrt.cur_fw_img == IWL_UCODE_REGULAR &&\n\t\t   mvm->hw_registered &&\n\t\t   !test_bit(STATUS_TRANS_DEAD, &mvm->trans->status)) {\n\t\t \n\t\tset_bit(IWL_MVM_STATUS_HW_RESTART_REQUESTED, &mvm->status);\n\n\t\tif (mvm->fw->ucode_capa.error_log_size) {\n\t\t\tu32 src_size = mvm->fw->ucode_capa.error_log_size;\n\t\t\tu32 src_addr = mvm->fw->ucode_capa.error_log_addr;\n\t\t\tu8 *recover_buf = kzalloc(src_size, GFP_ATOMIC);\n\n\t\t\tif (recover_buf) {\n\t\t\t\tmvm->error_recovery_buf = recover_buf;\n\t\t\t\tiwl_trans_read_mem_bytes(mvm->trans,\n\t\t\t\t\t\t\t src_addr,\n\t\t\t\t\t\t\t recover_buf,\n\t\t\t\t\t\t\t src_size);\n\t\t\t}\n\t\t}\n\n\t\tiwl_fw_error_collect(&mvm->fwrt, false);\n\n\t\tif (fw_error && mvm->fw_restart > 0) {\n\t\t\tmvm->fw_restart--;\n\t\t\tieee80211_restart_hw(mvm->hw);\n\t\t} else if (mvm->fwrt.trans->dbg.restart_required) {\n\t\t\tIWL_DEBUG_INFO(mvm, \"FW restart requested after debug collection\\n\");\n\t\t\tmvm->fwrt.trans->dbg.restart_required = FALSE;\n\t\t\tieee80211_restart_hw(mvm->hw);\n\t\t} else if (mvm->trans->trans_cfg->device_family <= IWL_DEVICE_FAMILY_8000) {\n\t\t\tieee80211_restart_hw(mvm->hw);\n\t\t}\n\t}\n}\n\nstatic void iwl_mvm_nic_error(struct iwl_op_mode *op_mode, bool sync)\n{\n\tstruct iwl_mvm *mvm = IWL_OP_MODE_GET_MVM(op_mode);\n\n\tif (mvm->pldr_sync)\n\t\treturn;\n\n\tif (!test_bit(STATUS_TRANS_DEAD, &mvm->trans->status) &&\n\t    !test_and_clear_bit(IWL_MVM_STATUS_SUPPRESS_ERROR_LOG_ONCE,\n\t\t\t\t&mvm->status))\n\t\tiwl_mvm_dump_nic_error_log(mvm);\n\n\tif (sync) {\n\t\tiwl_fw_error_collect(&mvm->fwrt, true);\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tif (!test_bit(IWL_MVM_STATUS_FIRMWARE_RUNNING, &mvm->status))\n\t\treturn;\n\n\tiwl_mvm_nic_restart(mvm, false);\n}\n\nstatic void iwl_mvm_cmd_queue_full(struct iwl_op_mode *op_mode)\n{\n\tstruct iwl_mvm *mvm = IWL_OP_MODE_GET_MVM(op_mode);\n\n\tWARN_ON(1);\n\tiwl_mvm_nic_restart(mvm, true);\n}\n\nstatic void iwl_op_mode_mvm_time_point(struct iwl_op_mode *op_mode,\n\t\t\t\t       enum iwl_fw_ini_time_point tp_id,\n\t\t\t\t       union iwl_dbg_tlv_tp_data *tp_data)\n{\n\tstruct iwl_mvm *mvm = IWL_OP_MODE_GET_MVM(op_mode);\n\n\tiwl_dbg_tlv_time_point(&mvm->fwrt, tp_id, tp_data);\n}\n\n#define IWL_MVM_COMMON_OPS\t\t\t\t\t\\\n\t \t\t\t\\\n\t.async_cb = iwl_mvm_async_cb,\t\t\t\t\\\n\t.queue_full = iwl_mvm_stop_sw_queue,\t\t\t\\\n\t.queue_not_full = iwl_mvm_wake_sw_queue,\t\t\\\n\t.hw_rf_kill = iwl_mvm_set_hw_rfkill_state,\t\t\\\n\t.free_skb = iwl_mvm_free_skb,\t\t\t\t\\\n\t.nic_error = iwl_mvm_nic_error,\t\t\t\t\\\n\t.cmd_queue_full = iwl_mvm_cmd_queue_full,\t\t\\\n\t.nic_config = iwl_mvm_nic_config,\t\t\t\\\n\t \t\\\n\t.start = iwl_op_mode_mvm_start,\t\t\t\t\\\n\t.stop = iwl_op_mode_mvm_stop,\t\t\t\t\\\n\t.time_point = iwl_op_mode_mvm_time_point\n\nstatic const struct iwl_op_mode_ops iwl_mvm_ops = {\n\tIWL_MVM_COMMON_OPS,\n\t.rx = iwl_mvm_rx,\n};\n\nstatic void iwl_mvm_rx_mq_rss(struct iwl_op_mode *op_mode,\n\t\t\t      struct napi_struct *napi,\n\t\t\t      struct iwl_rx_cmd_buffer *rxb,\n\t\t\t      unsigned int queue)\n{\n\tstruct iwl_mvm *mvm = IWL_OP_MODE_GET_MVM(op_mode);\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tu16 cmd = WIDE_ID(pkt->hdr.group_id, pkt->hdr.cmd);\n\n\tif (unlikely(queue >= mvm->trans->num_rx_queues))\n\t\treturn;\n\n\tif (unlikely(cmd == WIDE_ID(LEGACY_GROUP, FRAME_RELEASE)))\n\t\tiwl_mvm_rx_frame_release(mvm, napi, rxb, queue);\n\telse if (unlikely(cmd == WIDE_ID(DATA_PATH_GROUP,\n\t\t\t\t\t RX_QUEUES_NOTIFICATION)))\n\t\tiwl_mvm_rx_queue_notif(mvm, napi, rxb, queue);\n\telse if (likely(cmd == WIDE_ID(LEGACY_GROUP, REPLY_RX_MPDU_CMD)))\n\t\tiwl_mvm_rx_mpdu_mq(mvm, napi, rxb, queue);\n}\n\nstatic const struct iwl_op_mode_ops iwl_mvm_ops_mq = {\n\tIWL_MVM_COMMON_OPS,\n\t.rx = iwl_mvm_rx_mq,\n\t.rx_rss = iwl_mvm_rx_mq_rss,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}