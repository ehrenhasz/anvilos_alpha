{
  "module_name": "tt.c",
  "hash_id": "31b957c150f7cdd2ec0529a0809350e1ff5c547af69df02979ff7e169d5b0230",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/tt.c",
  "human_readable_source": "\n \n#include <linux/sort.h>\n\n#include \"mvm.h\"\n\n#define IWL_MVM_TEMP_NOTIF_WAIT_TIMEOUT\tHZ\n\nvoid iwl_mvm_enter_ctkill(struct iwl_mvm *mvm)\n{\n\tstruct iwl_mvm_tt_mgmt *tt = &mvm->thermal_throttle;\n\tu32 duration = tt->params.ct_kill_duration;\n\n\tif (test_bit(IWL_MVM_STATUS_HW_CTKILL, &mvm->status))\n\t\treturn;\n\n\tIWL_ERR(mvm, \"Enter CT Kill\\n\");\n\tiwl_mvm_set_hw_ctkill_state(mvm, true);\n\n\tif (!iwl_mvm_is_tt_in_fw(mvm)) {\n\t\ttt->throttle = false;\n\t\ttt->dynamic_smps = false;\n\t}\n\n\t \n\tif (!mvm->temperature_test)\n\t\tschedule_delayed_work(&tt->ct_kill_exit,\n\t\t\t\t      round_jiffies_relative(duration * HZ));\n}\n\nstatic void iwl_mvm_exit_ctkill(struct iwl_mvm *mvm)\n{\n\tif (!test_bit(IWL_MVM_STATUS_HW_CTKILL, &mvm->status))\n\t\treturn;\n\n\tIWL_ERR(mvm, \"Exit CT Kill\\n\");\n\tiwl_mvm_set_hw_ctkill_state(mvm, false);\n}\n\nstatic void iwl_mvm_tt_temp_changed(struct iwl_mvm *mvm, u32 temp)\n{\n\t \n\tif (mvm->temperature_test)\n\t\treturn;\n\n\tif (mvm->temperature == temp)\n\t\treturn;\n\n\tmvm->temperature = temp;\n\tiwl_mvm_tt_handler(mvm);\n}\n\nstatic int iwl_mvm_temp_notif_parse(struct iwl_mvm *mvm,\n\t\t\t\t    struct iwl_rx_packet *pkt)\n{\n\tstruct iwl_dts_measurement_notif_v1 *notif_v1;\n\tint len = iwl_rx_packet_payload_len(pkt);\n\tint temp;\n\n\t \n\tif (WARN_ON_ONCE(len < sizeof(*notif_v1))) {\n\t\tIWL_ERR(mvm, \"Invalid DTS_MEASUREMENT_NOTIFICATION\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnotif_v1 = (void *)pkt->data;\n\n\ttemp = le32_to_cpu(notif_v1->temp);\n\n\t \n\tif (WARN_ON_ONCE(temp < 0))\n\t\ttemp = 0;\n\n\tIWL_DEBUG_TEMP(mvm, \"DTS_MEASUREMENT_NOTIFICATION - %d\\n\", temp);\n\n\treturn temp;\n}\n\nstatic bool iwl_mvm_temp_notif_wait(struct iwl_notif_wait_data *notif_wait,\n\t\t\t\t    struct iwl_rx_packet *pkt, void *data)\n{\n\tstruct iwl_mvm *mvm =\n\t\tcontainer_of(notif_wait, struct iwl_mvm, notif_wait);\n\tint *temp = data;\n\tint ret;\n\n\tret = iwl_mvm_temp_notif_parse(mvm, pkt);\n\tif (ret < 0)\n\t\treturn true;\n\n\t*temp = ret;\n\n\treturn true;\n}\n\nvoid iwl_mvm_temp_notif(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_dts_measurement_notif_v2 *notif_v2;\n\tint len = iwl_rx_packet_payload_len(pkt);\n\tint temp;\n\tu32 ths_crossed;\n\n\t \n\tif (test_bit(IWL_MVM_STATUS_HW_CTKILL, &mvm->status))\n\t\treturn;\n\n\ttemp = iwl_mvm_temp_notif_parse(mvm, pkt);\n\n\tif (!iwl_mvm_is_tt_in_fw(mvm)) {\n\t\tif (temp >= 0)\n\t\t\tiwl_mvm_tt_temp_changed(mvm, temp);\n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(len < sizeof(*notif_v2))) {\n\t\tIWL_ERR(mvm, \"Invalid DTS_MEASUREMENT_NOTIFICATION\\n\");\n\t\treturn;\n\t}\n\n\tnotif_v2 = (void *)pkt->data;\n\tths_crossed = le32_to_cpu(notif_v2->threshold_idx);\n\n\t \n\tif (ths_crossed == 0xFF)\n\t\treturn;\n\n\tIWL_DEBUG_TEMP(mvm, \"Temp = %d Threshold crossed = %d\\n\",\n\t\t       temp, ths_crossed);\n\n#ifdef CONFIG_THERMAL\n\tif (WARN_ON(ths_crossed >= IWL_MAX_DTS_TRIPS))\n\t\treturn;\n\n\tif (mvm->tz_device.tzone) {\n\t\tstruct iwl_mvm_thermal_device *tz_dev = &mvm->tz_device;\n\n\t\tthermal_zone_device_update(tz_dev->tzone,\n\t\t\t\t\t   THERMAL_TRIP_VIOLATED);\n\t}\n#endif  \n}\n\nvoid iwl_mvm_ct_kill_notif(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct ct_kill_notif *notif;\n\n\tnotif = (struct ct_kill_notif *)pkt->data;\n\tIWL_DEBUG_TEMP(mvm, \"CT Kill notification temperature = %d\\n\",\n\t\t       notif->temperature);\n\tif (iwl_fw_lookup_notif_ver(mvm->fw, PHY_OPS_GROUP,\n\t\t\t\t    CT_KILL_NOTIFICATION, 0) > 1)\n\t\tIWL_DEBUG_TEMP(mvm,\n\t\t\t       \"CT kill notification DTS bitmap = 0x%x, Scheme = %d\\n\",\n\t\t\t       notif->dts, notif->scheme);\n\n\tiwl_mvm_enter_ctkill(mvm);\n}\n\n \nstatic int iwl_mvm_send_temp_cmd(struct iwl_mvm *mvm, bool response, s32 *temp)\n{\n\tstruct iwl_host_cmd cmd = {};\n\tstruct iwl_dts_measurement_cmd dts_cmd = {\n\t\t.flags = cpu_to_le32(DTS_TRIGGER_CMD_FLAGS_TEMP),\n\t};\n\tstruct iwl_ext_dts_measurement_cmd ext_cmd = {\n\t\t.control_mode = cpu_to_le32(DTS_DIRECT_WITHOUT_MEASURE),\n\t};\n\tstruct iwl_dts_measurement_resp *resp;\n\tvoid *cmd_ptr;\n\tint ret;\n\tu32 cmd_flags = 0;\n\tu16 len;\n\n\t \n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_EXTENDED_DTS_MEASURE)) {\n\t\tlen = sizeof(ext_cmd);\n\t\tcmd_ptr = &ext_cmd;\n\t} else {\n\t\tlen = sizeof(dts_cmd);\n\t\tcmd_ptr = &dts_cmd;\n\t}\n\t \n\tif (response) {\n\t\tcmd_flags = CMD_WANT_SKB;\n\t\tlen = 0;\n\t}\n\n\tcmd.id =  WIDE_ID(PHY_OPS_GROUP, CMD_DTS_MEASUREMENT_TRIGGER_WIDE);\n\tcmd.len[0] = len;\n\tcmd.flags = cmd_flags;\n\tcmd.data[0] = cmd_ptr;\n\n\tIWL_DEBUG_TEMP(mvm,\n\t\t       \"Sending temperature measurement command - %s response\\n\",\n\t\t       response ? \"with\" : \"without\");\n\tret = iwl_mvm_send_cmd(mvm, &cmd);\n\n\tif (ret) {\n\t\tIWL_ERR(mvm,\n\t\t\t\"Failed to send the temperature measurement command (err=%d)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (response) {\n\t\tresp = (void *)cmd.resp_pkt->data;\n\t\t*temp = le32_to_cpu(resp->temp);\n\t\tIWL_DEBUG_TEMP(mvm,\n\t\t\t       \"Got temperature measurement response: temp=%d\\n\",\n\t\t\t       *temp);\n\t\tiwl_free_resp(&cmd);\n\t}\n\n\treturn ret;\n}\n\nint iwl_mvm_get_temp(struct iwl_mvm *mvm, s32 *temp)\n{\n\tstruct iwl_notification_wait wait_temp_notif;\n\tstatic u16 temp_notif[] = { WIDE_ID(PHY_OPS_GROUP,\n\t\t\t\t\t    DTS_MEASUREMENT_NOTIF_WIDE) };\n\tint ret;\n\tu8 cmd_ver;\n\n\t \n\tcmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw,\n\t\t\t\t\tWIDE_ID(PHY_OPS_GROUP, CMD_DTS_MEASUREMENT_TRIGGER_WIDE),\n\t\t\t\t\tIWL_FW_CMD_VER_UNKNOWN);\n\tif (cmd_ver == 1)\n\t\treturn iwl_mvm_send_temp_cmd(mvm, true, temp);\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tiwl_init_notification_wait(&mvm->notif_wait, &wait_temp_notif,\n\t\t\t\t   temp_notif, ARRAY_SIZE(temp_notif),\n\t\t\t\t   iwl_mvm_temp_notif_wait, temp);\n\n\tret = iwl_mvm_send_temp_cmd(mvm, false, temp);\n\tif (ret) {\n\t\tiwl_remove_notification(&mvm->notif_wait, &wait_temp_notif);\n\t\treturn ret;\n\t}\n\n\tret = iwl_wait_notification(&mvm->notif_wait, &wait_temp_notif,\n\t\t\t\t    IWL_MVM_TEMP_NOTIF_WAIT_TIMEOUT);\n\tif (ret)\n\t\tIWL_WARN(mvm, \"Getting the temperature timed out\\n\");\n\n\treturn ret;\n}\n\nstatic void check_exit_ctkill(struct work_struct *work)\n{\n\tstruct iwl_mvm_tt_mgmt *tt;\n\tstruct iwl_mvm *mvm;\n\tu32 duration;\n\ts32 temp;\n\tint ret;\n\n\ttt = container_of(work, struct iwl_mvm_tt_mgmt, ct_kill_exit.work);\n\tmvm = container_of(tt, struct iwl_mvm, thermal_throttle);\n\n\tif (iwl_mvm_is_tt_in_fw(mvm)) {\n\t\tiwl_mvm_exit_ctkill(mvm);\n\n\t\treturn;\n\t}\n\n\tduration = tt->params.ct_kill_duration;\n\n\tflush_work(&mvm->roc_done_wk);\n\n\tmutex_lock(&mvm->mutex);\n\n\tif (__iwl_mvm_mac_start(mvm))\n\t\tgoto reschedule;\n\n\tret = iwl_mvm_get_temp(mvm, &temp);\n\n\t__iwl_mvm_mac_stop(mvm);\n\n\tif (ret)\n\t\tgoto reschedule;\n\n\tIWL_DEBUG_TEMP(mvm, \"NIC temperature: %d\\n\", temp);\n\n\tif (temp <= tt->params.ct_kill_exit) {\n\t\tmutex_unlock(&mvm->mutex);\n\t\tiwl_mvm_exit_ctkill(mvm);\n\t\treturn;\n\t}\n\nreschedule:\n\tmutex_unlock(&mvm->mutex);\n\tschedule_delayed_work(&mvm->thermal_throttle.ct_kill_exit,\n\t\t\t      round_jiffies(duration * HZ));\n}\n\nstatic void iwl_mvm_tt_smps_iterator(void *_data, u8 *mac,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm *mvm = _data;\n\tenum ieee80211_smps_mode smps_mode;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (mvm->thermal_throttle.dynamic_smps)\n\t\tsmps_mode = IEEE80211_SMPS_DYNAMIC;\n\telse\n\t\tsmps_mode = IEEE80211_SMPS_AUTOMATIC;\n\n\tif (vif->type != NL80211_IFTYPE_STATION)\n\t\treturn;\n\n\tiwl_mvm_update_smps(mvm, vif, IWL_MVM_SMPS_REQ_TT, smps_mode, 0);\n}\n\nstatic void iwl_mvm_tt_tx_protection(struct iwl_mvm *mvm, bool enable)\n{\n\tstruct iwl_mvm_sta *mvmsta;\n\tint i, err;\n\n\tfor (i = 0; i < mvm->fw->ucode_capa.num_stations; i++) {\n\t\tmvmsta = iwl_mvm_sta_from_staid_protected(mvm, i);\n\t\tif (!mvmsta)\n\t\t\tcontinue;\n\n\t\tif (enable == mvmsta->tt_tx_protection)\n\t\t\tcontinue;\n\t\terr = iwl_mvm_tx_protection(mvm, mvmsta, enable);\n\t\tif (err) {\n\t\t\tIWL_ERR(mvm, \"Failed to %s Tx protection\\n\",\n\t\t\t\tenable ? \"enable\" : \"disable\");\n\t\t} else {\n\t\t\tIWL_DEBUG_TEMP(mvm, \"%s Tx protection\\n\",\n\t\t\t\t       enable ? \"Enable\" : \"Disable\");\n\t\t\tmvmsta->tt_tx_protection = enable;\n\t\t}\n\t}\n}\n\nvoid iwl_mvm_tt_tx_backoff(struct iwl_mvm *mvm, u32 backoff)\n{\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = REPLY_THERMAL_MNG_BACKOFF,\n\t\t.len = { sizeof(u32), },\n\t\t.data = { &backoff, },\n\t};\n\n\tbackoff = max(backoff, mvm->thermal_throttle.min_backoff);\n\n\tif (iwl_mvm_send_cmd(mvm, &cmd) == 0) {\n\t\tIWL_DEBUG_TEMP(mvm, \"Set Thermal Tx backoff to: %u\\n\",\n\t\t\t       backoff);\n\t\tmvm->thermal_throttle.tx_backoff = backoff;\n\t} else {\n\t\tIWL_ERR(mvm, \"Failed to change Thermal Tx backoff\\n\");\n\t}\n}\n\nvoid iwl_mvm_tt_handler(struct iwl_mvm *mvm)\n{\n\tstruct iwl_tt_params *params = &mvm->thermal_throttle.params;\n\tstruct iwl_mvm_tt_mgmt *tt = &mvm->thermal_throttle;\n\ts32 temperature = mvm->temperature;\n\tbool throttle_enable = false;\n\tint i;\n\tu32 tx_backoff;\n\n\tIWL_DEBUG_TEMP(mvm, \"NIC temperature: %d\\n\", mvm->temperature);\n\n\tif (params->support_ct_kill && temperature >= params->ct_kill_entry) {\n\t\tiwl_mvm_enter_ctkill(mvm);\n\t\treturn;\n\t}\n\n\tif (params->support_ct_kill &&\n\t    temperature <= params->ct_kill_exit) {\n\t\tiwl_mvm_exit_ctkill(mvm);\n\t\treturn;\n\t}\n\n\tif (params->support_dynamic_smps) {\n\t\tif (!tt->dynamic_smps &&\n\t\t    temperature >= params->dynamic_smps_entry) {\n\t\t\tIWL_DEBUG_TEMP(mvm, \"Enable dynamic SMPS\\n\");\n\t\t\ttt->dynamic_smps = true;\n\t\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\t\t\tmvm->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\tiwl_mvm_tt_smps_iterator, mvm);\n\t\t\tthrottle_enable = true;\n\t\t} else if (tt->dynamic_smps &&\n\t\t\t   temperature <= params->dynamic_smps_exit) {\n\t\t\tIWL_DEBUG_TEMP(mvm, \"Disable dynamic SMPS\\n\");\n\t\t\ttt->dynamic_smps = false;\n\t\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\t\t\tmvm->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\tiwl_mvm_tt_smps_iterator, mvm);\n\t\t}\n\t}\n\n\tif (params->support_tx_protection) {\n\t\tif (temperature >= params->tx_protection_entry) {\n\t\t\tiwl_mvm_tt_tx_protection(mvm, true);\n\t\t\tthrottle_enable = true;\n\t\t} else if (temperature <= params->tx_protection_exit) {\n\t\t\tiwl_mvm_tt_tx_protection(mvm, false);\n\t\t}\n\t}\n\n\tif (params->support_tx_backoff) {\n\t\ttx_backoff = tt->min_backoff;\n\t\tfor (i = 0; i < TT_TX_BACKOFF_SIZE; i++) {\n\t\t\tif (temperature < params->tx_backoff[i].temperature)\n\t\t\t\tbreak;\n\t\t\ttx_backoff = max(tt->min_backoff,\n\t\t\t\t\t params->tx_backoff[i].backoff);\n\t\t}\n\t\tif (tx_backoff != tt->min_backoff)\n\t\t\tthrottle_enable = true;\n\t\tif (tt->tx_backoff != tx_backoff)\n\t\t\tiwl_mvm_tt_tx_backoff(mvm, tx_backoff);\n\t}\n\n\tif (!tt->throttle && throttle_enable) {\n\t\tIWL_WARN(mvm,\n\t\t\t \"Due to high temperature thermal throttling initiated\\n\");\n\t\ttt->throttle = true;\n\t} else if (tt->throttle && !tt->dynamic_smps &&\n\t\t   tt->tx_backoff == tt->min_backoff &&\n\t\t   temperature <= params->tx_protection_exit) {\n\t\tIWL_WARN(mvm,\n\t\t\t \"Temperature is back to normal thermal throttling stopped\\n\");\n\t\ttt->throttle = false;\n\t}\n}\n\nstatic const struct iwl_tt_params iwl_mvm_default_tt_params = {\n\t.ct_kill_entry = 118,\n\t.ct_kill_exit = 96,\n\t.ct_kill_duration = 5,\n\t.dynamic_smps_entry = 114,\n\t.dynamic_smps_exit = 110,\n\t.tx_protection_entry = 114,\n\t.tx_protection_exit = 108,\n\t.tx_backoff = {\n\t\t{.temperature = 112, .backoff = 200},\n\t\t{.temperature = 113, .backoff = 600},\n\t\t{.temperature = 114, .backoff = 1200},\n\t\t{.temperature = 115, .backoff = 2000},\n\t\t{.temperature = 116, .backoff = 4000},\n\t\t{.temperature = 117, .backoff = 10000},\n\t},\n\t.support_ct_kill = true,\n\t.support_dynamic_smps = true,\n\t.support_tx_protection = true,\n\t.support_tx_backoff = true,\n};\n\n \nstatic const u32 iwl_mvm_cdev_budgets[] = {\n\t2400,\t \n\t2000,\t \n\t1800,\t \n\t1600,\t \n\t1400,\t \n\t1200,\t \n\t1000,\t \n\t900,\t \n\t800,\t \n\t700,\t \n\t650,\t \n\t600,\t \n\t550,\t \n\t500,\t \n\t450,\t \n\t400,\t \n\t350,\t \n\t300,\t \n\t250,\t \n\t200,\t \n\t150,\t \n};\n\nint iwl_mvm_ctdp_command(struct iwl_mvm *mvm, u32 op, u32 state)\n{\n\tstruct iwl_mvm_ctdp_cmd cmd = {\n\t\t.operation = cpu_to_le32(op),\n\t\t.budget = cpu_to_le32(iwl_mvm_cdev_budgets[state]),\n\t\t.window_size = 0,\n\t};\n\tint ret;\n\tu32 status;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tstatus = 0;\n\tret = iwl_mvm_send_cmd_pdu_status(mvm, WIDE_ID(PHY_OPS_GROUP,\n\t\t\t\t\t\t       CTDP_CONFIG_CMD),\n\t\t\t\t\t  sizeof(cmd), &cmd, &status);\n\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"cTDP command failed (err=%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tswitch (op) {\n\tcase CTDP_CMD_OPERATION_START:\n#ifdef CONFIG_THERMAL\n\t\tmvm->cooling_dev.cur_state = state;\n#endif  \n\t\tbreak;\n\tcase CTDP_CMD_OPERATION_REPORT:\n\t\tIWL_DEBUG_TEMP(mvm, \"cTDP avg energy in mWatt = %d\\n\", status);\n\t\t \n\t\treturn status;\n\tcase CTDP_CMD_OPERATION_STOP:\n\t\tIWL_DEBUG_TEMP(mvm, \"cTDP stopped successfully\\n\");\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_THERMAL\nstatic int compare_temps(const void *a, const void *b)\n{\n\treturn ((s16)le16_to_cpu(*(__le16 *)a) -\n\t\t(s16)le16_to_cpu(*(__le16 *)b));\n}\n#endif\n\nint iwl_mvm_send_temp_report_ths_cmd(struct iwl_mvm *mvm)\n{\n\tstruct temp_report_ths_cmd cmd = {0};\n\tint ret;\n#ifdef CONFIG_THERMAL\n\tint i, j, idx = 0;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (!mvm->tz_device.tzone)\n\t\tgoto send;\n\n\t \n\n\t \n\tfor (i = 0; i < IWL_MAX_DTS_TRIPS; i++) {\n\t\tif (mvm->tz_device.trips[i].temperature != INT_MIN) {\n\t\t\tcmd.thresholds[idx++] =\n\t\t\t\tcpu_to_le16((s16)(mvm->tz_device.trips[i].temperature / 1000));\n\t\t}\n\t}\n\tcmd.num_temps = cpu_to_le32(idx);\n\n\tif (!idx)\n\t\tgoto send;\n\n\t \n\tsort(cmd.thresholds, idx, sizeof(s16), compare_temps, NULL);\n\n\t \n\tfor (i = 0; i < idx; i++) {\n\t\tfor (j = 0; j < IWL_MAX_DTS_TRIPS; j++) {\n\t\t\tif ((int)(le16_to_cpu(cmd.thresholds[i]) * 1000) ==\n\t\t\t    mvm->tz_device.trips[j].temperature)\n\t\t\t\tmvm->tz_device.fw_trips_index[i] = j;\n\t\t}\n\t}\n\nsend:\n#endif\n\tret = iwl_mvm_send_cmd_pdu(mvm, WIDE_ID(PHY_OPS_GROUP,\n\t\t\t\t\t\tTEMP_REPORTING_THRESHOLDS_CMD),\n\t\t\t\t   0, sizeof(cmd), &cmd);\n\tif (ret)\n\t\tIWL_ERR(mvm, \"TEMP_REPORT_THS_CMD command failed (err=%d)\\n\",\n\t\t\tret);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_THERMAL\nstatic int iwl_mvm_tzone_get_temp(struct thermal_zone_device *device,\n\t\t\t\t  int *temperature)\n{\n\tstruct iwl_mvm *mvm = thermal_zone_device_priv(device);\n\tint ret;\n\tint temp;\n\n\tmutex_lock(&mvm->mutex);\n\n\tif (!iwl_mvm_firmware_running(mvm) ||\n\t    mvm->fwrt.cur_fw_img != IWL_UCODE_REGULAR) {\n\t\tret = -ENODATA;\n\t\tgoto out;\n\t}\n\n\tret = iwl_mvm_get_temp(mvm, &temp);\n\tif (ret)\n\t\tgoto out;\n\n\t*temperature = temp * 1000;\n\nout:\n\tmutex_unlock(&mvm->mutex);\n\treturn ret;\n}\n\nstatic int iwl_mvm_tzone_set_trip_temp(struct thermal_zone_device *device,\n\t\t\t\t       int trip, int temp)\n{\n\tstruct iwl_mvm *mvm = thermal_zone_device_priv(device);\n\tstruct iwl_mvm_thermal_device *tzone;\n\tint ret;\n\n\tmutex_lock(&mvm->mutex);\n\n\tif (!iwl_mvm_firmware_running(mvm) ||\n\t    mvm->fwrt.cur_fw_img != IWL_UCODE_REGULAR) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif ((temp / 1000) > S16_MAX) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttzone = &mvm->tz_device;\n\tif (!tzone) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = iwl_mvm_send_temp_report_ths_cmd(mvm);\nout:\n\tmutex_unlock(&mvm->mutex);\n\treturn ret;\n}\n\nstatic  struct thermal_zone_device_ops tzone_ops = {\n\t.get_temp = iwl_mvm_tzone_get_temp,\n\t.set_trip_temp = iwl_mvm_tzone_set_trip_temp,\n};\n\n \n#define IWL_WRITABLE_TRIPS_MSK (BIT(IWL_MAX_DTS_TRIPS) - 1)\n\nstatic void iwl_mvm_thermal_zone_register(struct iwl_mvm *mvm)\n{\n\tint i, ret;\n\tchar name[16];\n\tstatic atomic_t counter = ATOMIC_INIT(0);\n\n\tif (!iwl_mvm_is_tt_in_fw(mvm)) {\n\t\tmvm->tz_device.tzone = NULL;\n\n\t\treturn;\n\t}\n\n\tBUILD_BUG_ON(ARRAY_SIZE(name) >= THERMAL_NAME_LENGTH);\n\n\tsprintf(name, \"iwlwifi_%u\", atomic_inc_return(&counter) & 0xFF);\n\tmvm->tz_device.tzone = thermal_zone_device_register_with_trips(name,\n\t\t\t\t\t\t\tmvm->tz_device.trips,\n\t\t\t\t\t\t\tIWL_MAX_DTS_TRIPS,\n\t\t\t\t\t\t\tIWL_WRITABLE_TRIPS_MSK,\n\t\t\t\t\t\t\tmvm, &tzone_ops,\n\t\t\t\t\t\t\tNULL, 0, 0);\n\tif (IS_ERR(mvm->tz_device.tzone)) {\n\t\tIWL_DEBUG_TEMP(mvm,\n\t\t\t       \"Failed to register to thermal zone (err = %ld)\\n\",\n\t\t\t       PTR_ERR(mvm->tz_device.tzone));\n\t\tmvm->tz_device.tzone = NULL;\n\t\treturn;\n\t}\n\n\tret = thermal_zone_device_enable(mvm->tz_device.tzone);\n\tif (ret) {\n\t\tIWL_DEBUG_TEMP(mvm, \"Failed to enable thermal zone\\n\");\n\t\tthermal_zone_device_unregister(mvm->tz_device.tzone);\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0 ; i < IWL_MAX_DTS_TRIPS; i++) {\n\t\tmvm->tz_device.trips[i].temperature = INT_MIN;\n\t\tmvm->tz_device.trips[i].type = THERMAL_TRIP_PASSIVE;\n\t}\n}\n\nstatic int iwl_mvm_tcool_get_max_state(struct thermal_cooling_device *cdev,\n\t\t\t\t       unsigned long *state)\n{\n\t*state = ARRAY_SIZE(iwl_mvm_cdev_budgets) - 1;\n\n\treturn 0;\n}\n\nstatic int iwl_mvm_tcool_get_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t       unsigned long *state)\n{\n\tstruct iwl_mvm *mvm = (struct iwl_mvm *)(cdev->devdata);\n\n\t*state = mvm->cooling_dev.cur_state;\n\n\treturn 0;\n}\n\nstatic int iwl_mvm_tcool_set_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t       unsigned long new_state)\n{\n\tstruct iwl_mvm *mvm = (struct iwl_mvm *)(cdev->devdata);\n\tint ret;\n\n\tmutex_lock(&mvm->mutex);\n\n\tif (!iwl_mvm_firmware_running(mvm) ||\n\t    mvm->fwrt.cur_fw_img != IWL_UCODE_REGULAR) {\n\t\tret = -EIO;\n\t\tgoto unlock;\n\t}\n\n\tif (new_state >= ARRAY_SIZE(iwl_mvm_cdev_budgets)) {\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tret = iwl_mvm_ctdp_command(mvm, CTDP_CMD_OPERATION_START,\n\t\t\t\t   new_state);\n\nunlock:\n\tmutex_unlock(&mvm->mutex);\n\treturn ret;\n}\n\nstatic const struct thermal_cooling_device_ops tcooling_ops = {\n\t.get_max_state = iwl_mvm_tcool_get_max_state,\n\t.get_cur_state = iwl_mvm_tcool_get_cur_state,\n\t.set_cur_state = iwl_mvm_tcool_set_cur_state,\n};\n\nstatic void iwl_mvm_cooling_device_register(struct iwl_mvm *mvm)\n{\n\tchar name[] = \"iwlwifi\";\n\n\tif (!iwl_mvm_is_ctdp_supported(mvm))\n\t\treturn;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(name) >= THERMAL_NAME_LENGTH);\n\n\tmvm->cooling_dev.cdev =\n\t\tthermal_cooling_device_register(name,\n\t\t\t\t\t\tmvm,\n\t\t\t\t\t\t&tcooling_ops);\n\n\tif (IS_ERR(mvm->cooling_dev.cdev)) {\n\t\tIWL_DEBUG_TEMP(mvm,\n\t\t\t       \"Failed to register to cooling device (err = %ld)\\n\",\n\t\t\t       PTR_ERR(mvm->cooling_dev.cdev));\n\t\tmvm->cooling_dev.cdev = NULL;\n\t\treturn;\n\t}\n}\n\nstatic void iwl_mvm_thermal_zone_unregister(struct iwl_mvm *mvm)\n{\n\tif (!iwl_mvm_is_tt_in_fw(mvm) || !mvm->tz_device.tzone)\n\t\treturn;\n\n\tIWL_DEBUG_TEMP(mvm, \"Thermal zone device unregister\\n\");\n\tif (mvm->tz_device.tzone) {\n\t\tthermal_zone_device_unregister(mvm->tz_device.tzone);\n\t\tmvm->tz_device.tzone = NULL;\n\t}\n}\n\nstatic void iwl_mvm_cooling_device_unregister(struct iwl_mvm *mvm)\n{\n\tif (!iwl_mvm_is_ctdp_supported(mvm) || !mvm->cooling_dev.cdev)\n\t\treturn;\n\n\tIWL_DEBUG_TEMP(mvm, \"Cooling device unregister\\n\");\n\tif (mvm->cooling_dev.cdev) {\n\t\tthermal_cooling_device_unregister(mvm->cooling_dev.cdev);\n\t\tmvm->cooling_dev.cdev = NULL;\n\t}\n}\n#endif  \n\nvoid iwl_mvm_thermal_initialize(struct iwl_mvm *mvm, u32 min_backoff)\n{\n\tstruct iwl_mvm_tt_mgmt *tt = &mvm->thermal_throttle;\n\n\tIWL_DEBUG_TEMP(mvm, \"Initialize Thermal Throttling\\n\");\n\n\tif (mvm->cfg->thermal_params)\n\t\ttt->params = *mvm->cfg->thermal_params;\n\telse\n\t\ttt->params = iwl_mvm_default_tt_params;\n\n\ttt->throttle = false;\n\ttt->dynamic_smps = false;\n\ttt->min_backoff = min_backoff;\n\tINIT_DELAYED_WORK(&tt->ct_kill_exit, check_exit_ctkill);\n\n#ifdef CONFIG_THERMAL\n\tiwl_mvm_cooling_device_register(mvm);\n\tiwl_mvm_thermal_zone_register(mvm);\n#endif\n\tmvm->init_status |= IWL_MVM_INIT_STATUS_THERMAL_INIT_COMPLETE;\n}\n\nvoid iwl_mvm_thermal_exit(struct iwl_mvm *mvm)\n{\n\tif (!(mvm->init_status & IWL_MVM_INIT_STATUS_THERMAL_INIT_COMPLETE))\n\t\treturn;\n\n\tcancel_delayed_work_sync(&mvm->thermal_throttle.ct_kill_exit);\n\tIWL_DEBUG_TEMP(mvm, \"Exit Thermal Throttling\\n\");\n\n#ifdef CONFIG_THERMAL\n\tiwl_mvm_cooling_device_unregister(mvm);\n\tiwl_mvm_thermal_zone_unregister(mvm);\n#endif\n\tmvm->init_status &= ~IWL_MVM_INIT_STATUS_THERMAL_INIT_COMPLETE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}