{
  "module_name": "time-event.c",
  "hash_id": "e22ac1143deffc3c596dee607735b7bc14390002cd4c6e8b486cf81f9d1afe6a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/time-event.c",
  "human_readable_source": "\n \n#include <linux/jiffies.h>\n#include <net/mac80211.h>\n\n#include \"fw/notif-wait.h\"\n#include \"iwl-trans.h\"\n#include \"fw-api.h\"\n#include \"time-event.h\"\n#include \"mvm.h\"\n#include \"iwl-io.h\"\n#include \"iwl-prph.h\"\n\n \n#define IWL_MVM_ROC_TE_TYPE_NORMAL TE_P2P_DEVICE_DISCOVERABLE\n#define IWL_MVM_ROC_TE_TYPE_MGMT_TX TE_P2P_CLIENT_ASSOC\n\nvoid iwl_mvm_te_clear_data(struct iwl_mvm *mvm,\n\t\t\t   struct iwl_mvm_time_event_data *te_data)\n{\n\tlockdep_assert_held(&mvm->time_event_lock);\n\n\tif (!te_data || !te_data->vif)\n\t\treturn;\n\n\tlist_del(&te_data->list);\n\n\t \n\tINIT_LIST_HEAD(&te_data->list);\n\n\tte_data->running = false;\n\tte_data->uid = 0;\n\tte_data->id = TE_MAX;\n\tte_data->vif = NULL;\n}\n\nvoid iwl_mvm_roc_done_wk(struct work_struct *wk)\n{\n\tstruct iwl_mvm *mvm = container_of(wk, struct iwl_mvm, roc_done_wk);\n\n\t \n\tclear_bit(IWL_MVM_STATUS_ROC_RUNNING, &mvm->status);\n\n\tsynchronize_net();\n\n\t \n\n\tmutex_lock(&mvm->mutex);\n\tif (test_and_clear_bit(IWL_MVM_STATUS_NEED_FLUSH_P2P, &mvm->status)) {\n\t\tstruct iwl_mvm_vif *mvmvif;\n\n\t\t \n\n\t\tif (!WARN_ON(!mvm->p2p_device_vif)) {\n\t\t\tstruct ieee80211_vif *vif = mvm->p2p_device_vif;\n\n\t\t\tmvmvif = iwl_mvm_vif_from_mac80211(vif);\n\t\t\tiwl_mvm_flush_sta(mvm, mvmvif->deflink.bcast_sta.sta_id,\n\t\t\t\t\t  mvmvif->deflink.bcast_sta.tfd_queue_msk);\n\n\t\t\tif (mvm->mld_api_is_used) {\n\t\t\t\tiwl_mvm_mld_rm_bcast_sta(mvm, vif,\n\t\t\t\t\t\t\t &vif->bss_conf);\n\n\t\t\t\tiwl_mvm_link_changed(mvm, vif, &vif->bss_conf,\n\t\t\t\t\t\t     LINK_CONTEXT_MODIFY_ACTIVE,\n\t\t\t\t\t\t     false);\n\t\t\t} else {\n\t\t\t\tiwl_mvm_rm_p2p_bcast_sta(mvm, vif);\n\t\t\t\tiwl_mvm_binding_remove_vif(mvm, vif);\n\t\t\t}\n\n\t\t\t \n\t\t}\n\t}\n\n\t \n\tif (test_and_clear_bit(IWL_MVM_STATUS_ROC_AUX_RUNNING, &mvm->status)) {\n\t\t \n\t\tiwl_mvm_flush_sta(mvm, mvm->aux_sta.sta_id,\n\t\t\t\t  mvm->aux_sta.tfd_queue_msk);\n\n\t\tif (mvm->mld_api_is_used) {\n\t\t\tiwl_mvm_mld_rm_aux_sta(mvm);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t \n\t\tif (iwl_mvm_has_new_station_api(mvm->fw))\n\t\t\tiwl_mvm_rm_aux_sta(mvm);\n\t}\n\nout_unlock:\n\tmutex_unlock(&mvm->mutex);\n}\n\nstatic void iwl_mvm_roc_finished(struct iwl_mvm *mvm)\n{\n\t \n\tschedule_work(&mvm->roc_done_wk);\n}\n\nstatic void iwl_mvm_csa_noa_start(struct iwl_mvm *mvm)\n{\n\tstruct ieee80211_vif *csa_vif;\n\n\trcu_read_lock();\n\n\tcsa_vif = rcu_dereference(mvm->csa_vif);\n\tif (!csa_vif || !csa_vif->bss_conf.csa_active)\n\t\tgoto out_unlock;\n\n\tIWL_DEBUG_TE(mvm, \"CSA NOA started\\n\");\n\n\t \n\tif (!ieee80211_beacon_cntdwn_is_complete(csa_vif)) {\n\t\tIWL_WARN(mvm, \"CSA NOA started too early\\n\");\n\t\tgoto out_unlock;\n\t}\n\n\tieee80211_csa_finish(csa_vif);\n\n\trcu_read_unlock();\n\n\tRCU_INIT_POINTER(mvm->csa_vif, NULL);\n\n\treturn;\n\nout_unlock:\n\trcu_read_unlock();\n}\n\nstatic bool iwl_mvm_te_check_disconnect(struct iwl_mvm *mvm,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tconst char *errmsg)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tif (vif->type != NL80211_IFTYPE_STATION)\n\t\treturn false;\n\n\tif (!mvmvif->csa_bcn_pending && vif->cfg.assoc &&\n\t    vif->bss_conf.dtim_period)\n\t\treturn false;\n\tif (errmsg)\n\t\tIWL_ERR(mvm, \"%s\\n\", errmsg);\n\n\tif (mvmvif->csa_bcn_pending) {\n\t\tstruct iwl_mvm_sta *mvmsta;\n\n\t\trcu_read_lock();\n\t\tmvmsta = iwl_mvm_sta_from_staid_rcu(mvm,\n\t\t\t\t\t\t    mvmvif->deflink.ap_sta_id);\n\t\tif (!WARN_ON(!mvmsta))\n\t\t\tiwl_mvm_sta_modify_disable_tx(mvm, mvmsta, false);\n\t\trcu_read_unlock();\n\t}\n\n\tif (vif->cfg.assoc) {\n\t\t \n\t\tiwl_dbg_tlv_time_point(&mvm->fwrt,\n\t\t\t\t       IWL_FW_INI_TIME_POINT_ASSOC_FAILED,\n\t\t\t\t       NULL);\n\t}\n\n\tiwl_mvm_connection_loss(mvm, vif, errmsg);\n\treturn true;\n}\n\nstatic void\niwl_mvm_te_handle_notify_csa(struct iwl_mvm *mvm,\n\t\t\t     struct iwl_mvm_time_event_data *te_data,\n\t\t\t     struct iwl_time_event_notif *notif)\n{\n\tstruct ieee80211_vif *vif = te_data->vif;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tif (!notif->status)\n\t\tIWL_DEBUG_TE(mvm, \"CSA time event failed to start\\n\");\n\n\tswitch (te_data->vif->type) {\n\tcase NL80211_IFTYPE_AP:\n\t\tif (!notif->status)\n\t\t\tmvmvif->csa_failed = true;\n\t\tiwl_mvm_csa_noa_start(mvm);\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (!notif->status) {\n\t\t\tiwl_mvm_connection_loss(mvm, vif,\n\t\t\t\t\t\t\"CSA TE failed to start\");\n\t\t\tbreak;\n\t\t}\n\t\tiwl_mvm_csa_client_absent(mvm, te_data->vif);\n\t\tcancel_delayed_work(&mvmvif->csa_work);\n\t\tieee80211_chswitch_done(te_data->vif, true);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\t \n\tiwl_mvm_te_clear_data(mvm, te_data);\n}\n\nstatic void iwl_mvm_te_check_trigger(struct iwl_mvm *mvm,\n\t\t\t\t     struct iwl_time_event_notif *notif,\n\t\t\t\t     struct iwl_mvm_time_event_data *te_data)\n{\n\tstruct iwl_fw_dbg_trigger_tlv *trig;\n\tstruct iwl_fw_dbg_trigger_time_event *te_trig;\n\tint i;\n\n\ttrig = iwl_fw_dbg_trigger_on(&mvm->fwrt,\n\t\t\t\t     ieee80211_vif_to_wdev(te_data->vif),\n\t\t\t\t     FW_DBG_TRIGGER_TIME_EVENT);\n\tif (!trig)\n\t\treturn;\n\n\tte_trig = (void *)trig->data;\n\n\tfor (i = 0; i < ARRAY_SIZE(te_trig->time_events); i++) {\n\t\tu32 trig_te_id = le32_to_cpu(te_trig->time_events[i].id);\n\t\tu32 trig_action_bitmap =\n\t\t\tle32_to_cpu(te_trig->time_events[i].action_bitmap);\n\t\tu32 trig_status_bitmap =\n\t\t\tle32_to_cpu(te_trig->time_events[i].status_bitmap);\n\n\t\tif (trig_te_id != te_data->id ||\n\t\t    !(trig_action_bitmap & le32_to_cpu(notif->action)) ||\n\t\t    !(trig_status_bitmap & BIT(le32_to_cpu(notif->status))))\n\t\t\tcontinue;\n\n\t\tiwl_fw_dbg_collect_trig(&mvm->fwrt, trig,\n\t\t\t\t\t\"Time event %d Action 0x%x received status: %d\",\n\t\t\t\t\tte_data->id,\n\t\t\t\t\tle32_to_cpu(notif->action),\n\t\t\t\t\tle32_to_cpu(notif->status));\n\t\tbreak;\n\t}\n}\n\nstatic void iwl_mvm_p2p_roc_finished(struct iwl_mvm *mvm)\n{\n\t \n\tif (!test_and_set_bit(IWL_MVM_STATUS_NEED_FLUSH_P2P, &mvm->status))\n\t\tiwl_mvm_roc_finished(mvm);\n}\n\n \nstatic void iwl_mvm_te_handle_notif(struct iwl_mvm *mvm,\n\t\t\t\t    struct iwl_mvm_time_event_data *te_data,\n\t\t\t\t    struct iwl_time_event_notif *notif)\n{\n\tlockdep_assert_held(&mvm->time_event_lock);\n\n\tIWL_DEBUG_TE(mvm, \"Handle time event notif - UID = 0x%x action %d\\n\",\n\t\t     le32_to_cpu(notif->unique_id),\n\t\t     le32_to_cpu(notif->action));\n\n\tiwl_mvm_te_check_trigger(mvm, notif, te_data);\n\n\t \n\tif (!le32_to_cpu(notif->status)) {\n\t\tconst char *msg;\n\n\t\tif (notif->action & cpu_to_le32(TE_V2_NOTIF_HOST_EVENT_START))\n\t\t\tmsg = \"Time Event start notification failure\";\n\t\telse\n\t\t\tmsg = \"Time Event end notification failure\";\n\n\t\tIWL_DEBUG_TE(mvm, \"%s\\n\", msg);\n\n\t\tif (iwl_mvm_te_check_disconnect(mvm, te_data->vif, msg)) {\n\t\t\tiwl_mvm_te_clear_data(mvm, te_data);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (le32_to_cpu(notif->action) & TE_V2_NOTIF_HOST_EVENT_END) {\n\t\tIWL_DEBUG_TE(mvm,\n\t\t\t     \"TE ended - current time %lu, estimated end %lu\\n\",\n\t\t\t     jiffies, te_data->end_jiffies);\n\n\t\tswitch (te_data->vif->type) {\n\t\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\t\tieee80211_remain_on_channel_expired(mvm->hw);\n\t\t\tiwl_mvm_p2p_roc_finished(mvm);\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\t \n\t\t\tif (te_data->id == TE_CHANNEL_SWITCH_PERIOD) {\n\t\t\t\tIWL_DEBUG_TE(mvm,\n\t\t\t\t\t     \"No beacon heard and the CS time event is over, don't disconnect\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tiwl_mvm_te_check_disconnect(mvm, te_data->vif,\n\t\t\t\t!te_data->vif->cfg.assoc ?\n\t\t\t\t\"Not associated and the time event is over already...\" :\n\t\t\t\t\"No beacon heard and the time event is over already...\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tiwl_mvm_te_clear_data(mvm, te_data);\n\t} else if (le32_to_cpu(notif->action) & TE_V2_NOTIF_HOST_EVENT_START) {\n\t\tte_data->running = true;\n\t\tte_data->end_jiffies = TU_TO_EXP_TIME(te_data->duration);\n\n\t\tif (te_data->vif->type == NL80211_IFTYPE_P2P_DEVICE) {\n\t\t\tset_bit(IWL_MVM_STATUS_ROC_RUNNING, &mvm->status);\n\t\t\tieee80211_ready_on_channel(mvm->hw);\n\t\t} else if (te_data->id == TE_CHANNEL_SWITCH_PERIOD) {\n\t\t\tiwl_mvm_te_handle_notify_csa(mvm, te_data, notif);\n\t\t}\n\t} else {\n\t\tIWL_WARN(mvm, \"Got TE with unknown action\\n\");\n\t}\n}\n\n \nstatic int iwl_mvm_aux_roc_te_handle_notif(struct iwl_mvm *mvm,\n\t\t\t\t\t   struct iwl_time_event_notif *notif)\n{\n\tstruct iwl_mvm_time_event_data *aux_roc_te = NULL, *te_data;\n\n\tlist_for_each_entry(te_data, &mvm->aux_roc_te_list, list) {\n\t\tif (le32_to_cpu(notif->unique_id) == te_data->uid) {\n\t\t\taux_roc_te = te_data;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!aux_roc_te)  \n\t\treturn -EINVAL;\n\n\tiwl_mvm_te_check_trigger(mvm, notif, te_data);\n\n\tIWL_DEBUG_TE(mvm,\n\t\t     \"Aux ROC time event notification  - UID = 0x%x action %d (error = %d)\\n\",\n\t\t     le32_to_cpu(notif->unique_id),\n\t\t     le32_to_cpu(notif->action), le32_to_cpu(notif->status));\n\n\tif (!le32_to_cpu(notif->status) ||\n\t    le32_to_cpu(notif->action) == TE_V2_NOTIF_HOST_EVENT_END) {\n\t\t \n\t\tieee80211_remain_on_channel_expired(mvm->hw);\n\t\tiwl_mvm_roc_finished(mvm);  \n\t\tlist_del(&te_data->list);  \n\t\tte_data->running = false;\n\t\tte_data->vif = NULL;\n\t\tte_data->uid = 0;\n\t\tte_data->id = TE_MAX;\n\t} else if (le32_to_cpu(notif->action) == TE_V2_NOTIF_HOST_EVENT_START) {\n\t\tset_bit(IWL_MVM_STATUS_ROC_AUX_RUNNING, &mvm->status);\n\t\tte_data->running = true;\n\t\tieee80211_ready_on_channel(mvm->hw);  \n\t} else {\n\t\tIWL_DEBUG_TE(mvm,\n\t\t\t     \"ERROR: Unknown Aux ROC Time Event (action = %d)\\n\",\n\t\t\t     le32_to_cpu(notif->action));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nvoid iwl_mvm_rx_time_event_notif(struct iwl_mvm *mvm,\n\t\t\t\t struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_time_event_notif *notif = (void *)pkt->data;\n\tstruct iwl_mvm_time_event_data *te_data, *tmp;\n\n\tIWL_DEBUG_TE(mvm, \"Time event notification - UID = 0x%x action %d\\n\",\n\t\t     le32_to_cpu(notif->unique_id),\n\t\t     le32_to_cpu(notif->action));\n\n\tspin_lock_bh(&mvm->time_event_lock);\n\t \n\tif (!iwl_mvm_aux_roc_te_handle_notif(mvm, notif))\n\t\tgoto unlock;\n\n\tlist_for_each_entry_safe(te_data, tmp, &mvm->time_event_list, list) {\n\t\tif (le32_to_cpu(notif->unique_id) == te_data->uid)\n\t\t\tiwl_mvm_te_handle_notif(mvm, te_data, notif);\n\t}\nunlock:\n\tspin_unlock_bh(&mvm->time_event_lock);\n}\n\nstatic bool iwl_mvm_te_notif(struct iwl_notif_wait_data *notif_wait,\n\t\t\t     struct iwl_rx_packet *pkt, void *data)\n{\n\tstruct iwl_mvm *mvm =\n\t\tcontainer_of(notif_wait, struct iwl_mvm, notif_wait);\n\tstruct iwl_mvm_time_event_data *te_data = data;\n\tstruct iwl_time_event_notif *resp;\n\tint resp_len = iwl_rx_packet_payload_len(pkt);\n\n\tif (WARN_ON(pkt->hdr.cmd != TIME_EVENT_NOTIFICATION))\n\t\treturn true;\n\n\tif (WARN_ON_ONCE(resp_len != sizeof(*resp))) {\n\t\tIWL_ERR(mvm, \"Invalid TIME_EVENT_NOTIFICATION response\\n\");\n\t\treturn true;\n\t}\n\n\tresp = (void *)pkt->data;\n\n\t \n\tif (le32_to_cpu(resp->unique_id) != te_data->uid)\n\t\treturn false;\n\n\tIWL_DEBUG_TE(mvm, \"TIME_EVENT_NOTIFICATION response - UID = 0x%x\\n\",\n\t\t     te_data->uid);\n\tif (!resp->status)\n\t\tIWL_ERR(mvm,\n\t\t\t\"TIME_EVENT_NOTIFICATION received but not executed\\n\");\n\n\treturn true;\n}\n\nstatic bool iwl_mvm_time_event_response(struct iwl_notif_wait_data *notif_wait,\n\t\t\t\t\tstruct iwl_rx_packet *pkt, void *data)\n{\n\tstruct iwl_mvm *mvm =\n\t\tcontainer_of(notif_wait, struct iwl_mvm, notif_wait);\n\tstruct iwl_mvm_time_event_data *te_data = data;\n\tstruct iwl_time_event_resp *resp;\n\tint resp_len = iwl_rx_packet_payload_len(pkt);\n\n\tif (WARN_ON(pkt->hdr.cmd != TIME_EVENT_CMD))\n\t\treturn true;\n\n\tif (WARN_ON_ONCE(resp_len != sizeof(*resp))) {\n\t\tIWL_ERR(mvm, \"Invalid TIME_EVENT_CMD response\\n\");\n\t\treturn true;\n\t}\n\n\tresp = (void *)pkt->data;\n\n\t \n\tif (WARN_ON_ONCE(le32_to_cpu(resp->id) != te_data->id))\n\t\treturn false;\n\n\tte_data->uid = le32_to_cpu(resp->unique_id);\n\tIWL_DEBUG_TE(mvm, \"TIME_EVENT_CMD response - UID = 0x%x\\n\",\n\t\t     te_data->uid);\n\treturn true;\n}\n\nstatic int iwl_mvm_time_event_send_add(struct iwl_mvm *mvm,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct iwl_mvm_time_event_data *te_data,\n\t\t\t\t       struct iwl_time_event_cmd *te_cmd)\n{\n\tstatic const u16 time_event_response[] = { TIME_EVENT_CMD };\n\tstruct iwl_notification_wait wait_time_event;\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tIWL_DEBUG_TE(mvm, \"Add new TE, duration %d TU\\n\",\n\t\t     le32_to_cpu(te_cmd->duration));\n\n\tspin_lock_bh(&mvm->time_event_lock);\n\tif (WARN_ON(te_data->id != TE_MAX)) {\n\t\tspin_unlock_bh(&mvm->time_event_lock);\n\t\treturn -EIO;\n\t}\n\tte_data->vif = vif;\n\tte_data->duration = le32_to_cpu(te_cmd->duration);\n\tte_data->id = le32_to_cpu(te_cmd->id);\n\tlist_add_tail(&te_data->list, &mvm->time_event_list);\n\tspin_unlock_bh(&mvm->time_event_lock);\n\n\t \n\tiwl_init_notification_wait(&mvm->notif_wait, &wait_time_event,\n\t\t\t\t   time_event_response,\n\t\t\t\t   ARRAY_SIZE(time_event_response),\n\t\t\t\t   iwl_mvm_time_event_response, te_data);\n\n\tret = iwl_mvm_send_cmd_pdu(mvm, TIME_EVENT_CMD, 0,\n\t\t\t\t\t    sizeof(*te_cmd), te_cmd);\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"Couldn't send TIME_EVENT_CMD: %d\\n\", ret);\n\t\tiwl_remove_notification(&mvm->notif_wait, &wait_time_event);\n\t\tgoto out_clear_te;\n\t}\n\n\t \n\tret = iwl_wait_notification(&mvm->notif_wait, &wait_time_event, 1);\n\t \n\tWARN_ON_ONCE(ret);\n\n\tif (ret) {\n out_clear_te:\n\t\tspin_lock_bh(&mvm->time_event_lock);\n\t\tiwl_mvm_te_clear_data(mvm, te_data);\n\t\tspin_unlock_bh(&mvm->time_event_lock);\n\t}\n\treturn ret;\n}\n\nvoid iwl_mvm_protect_session(struct iwl_mvm *mvm,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     u32 duration, u32 min_duration,\n\t\t\t     u32 max_delay, bool wait_for_notif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_time_event_data *te_data = &mvmvif->time_event_data;\n\tconst u16 te_notif_response[] = { TIME_EVENT_NOTIFICATION };\n\tstruct iwl_notification_wait wait_te_notif;\n\tstruct iwl_time_event_cmd time_cmd = {};\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (te_data->running &&\n\t    time_after(te_data->end_jiffies, TU_TO_EXP_TIME(min_duration))) {\n\t\tIWL_DEBUG_TE(mvm, \"We have enough time in the current TE: %u\\n\",\n\t\t\t     jiffies_to_msecs(te_data->end_jiffies - jiffies));\n\t\treturn;\n\t}\n\n\tif (te_data->running) {\n\t\tIWL_DEBUG_TE(mvm, \"extend 0x%x: only %u ms left\\n\",\n\t\t\t     te_data->uid,\n\t\t\t     jiffies_to_msecs(te_data->end_jiffies - jiffies));\n\t\t \n\t\tiwl_mvm_stop_session_protection(mvm, vif);\n\t}\n\n\ttime_cmd.action = cpu_to_le32(FW_CTXT_ACTION_ADD);\n\ttime_cmd.id_and_color =\n\t\tcpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id, mvmvif->color));\n\ttime_cmd.id = cpu_to_le32(TE_BSS_STA_AGGRESSIVE_ASSOC);\n\n\ttime_cmd.apply_time = cpu_to_le32(0);\n\n\ttime_cmd.max_frags = TE_V2_FRAG_NONE;\n\ttime_cmd.max_delay = cpu_to_le32(max_delay);\n\t \n\ttime_cmd.interval = cpu_to_le32(1);\n\ttime_cmd.duration = cpu_to_le32(duration);\n\ttime_cmd.repeat = 1;\n\ttime_cmd.policy = cpu_to_le16(TE_V2_NOTIF_HOST_EVENT_START |\n\t\t\t\t      TE_V2_NOTIF_HOST_EVENT_END |\n\t\t\t\t      TE_V2_START_IMMEDIATELY);\n\n\tif (!wait_for_notif) {\n\t\tiwl_mvm_time_event_send_add(mvm, vif, te_data, &time_cmd);\n\t\treturn;\n\t}\n\n\t \n\tiwl_init_notification_wait(&mvm->notif_wait, &wait_te_notif,\n\t\t\t\t   te_notif_response,\n\t\t\t\t   ARRAY_SIZE(te_notif_response),\n\t\t\t\t   iwl_mvm_te_notif, te_data);\n\n\t \n\tif (iwl_mvm_time_event_send_add(mvm, vif, te_data, &time_cmd)) {\n\t\tIWL_ERR(mvm, \"Failed to add TE to protect session\\n\");\n\t\tiwl_remove_notification(&mvm->notif_wait, &wait_te_notif);\n\t} else if (iwl_wait_notification(&mvm->notif_wait, &wait_te_notif,\n\t\t\t\t\t TU_TO_JIFFIES(max_delay))) {\n\t\tIWL_ERR(mvm, \"Failed to protect session until TE\\n\");\n\t}\n}\n\nstatic void iwl_mvm_cancel_session_protection(struct iwl_mvm *mvm,\n\t\t\t\t\t      struct iwl_mvm_vif *mvmvif,\n\t\t\t\t\t      u32 id)\n{\n\tstruct iwl_mvm_session_prot_cmd cmd = {\n\t\t.id_and_color =\n\t\t\tcpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id,\n\t\t\t\t\t\t\tmvmvif->color)),\n\t\t.action = cpu_to_le32(FW_CTXT_ACTION_REMOVE),\n\t\t.conf_id = cpu_to_le32(id),\n\t};\n\tint ret;\n\n\tret = iwl_mvm_send_cmd_pdu(mvm,\n\t\t\t\t   WIDE_ID(MAC_CONF_GROUP, SESSION_PROTECTION_CMD),\n\t\t\t\t   0, sizeof(cmd), &cmd);\n\tif (ret)\n\t\tIWL_ERR(mvm,\n\t\t\t\"Couldn't send the SESSION_PROTECTION_CMD: %d\\n\", ret);\n}\n\nstatic bool __iwl_mvm_remove_time_event(struct iwl_mvm *mvm,\n\t\t\t\t\tstruct iwl_mvm_time_event_data *te_data,\n\t\t\t\t\tu32 *uid)\n{\n\tu32 id;\n\tstruct iwl_mvm_vif *mvmvif;\n\tenum nl80211_iftype iftype;\n\n\tif (!te_data->vif)\n\t\treturn false;\n\n\tmvmvif = iwl_mvm_vif_from_mac80211(te_data->vif);\n\tiftype = te_data->vif->type;\n\n\t \n\tspin_lock_bh(&mvm->time_event_lock);\n\n\t \n\t*uid = te_data->uid;\n\tid = te_data->id;\n\n\t \n\tiwl_mvm_te_clear_data(mvm, te_data);\n\tspin_unlock_bh(&mvm->time_event_lock);\n\n\t \n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_SESSION_PROT_CMD) &&\n\t    id != HOT_SPOT_CMD) {\n\t\tif (mvmvif && id < SESSION_PROTECT_CONF_MAX_ID) {\n\t\t\t \n\t\t\tiwl_mvm_cancel_session_protection(mvm, mvmvif, id);\n\t\t\tif (iftype == NL80211_IFTYPE_P2P_DEVICE) {\n\t\t\t\tiwl_mvm_p2p_roc_finished(mvm);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t} else {\n\t\t \n\t\tif (id == TE_MAX) {\n\t\t\tIWL_DEBUG_TE(mvm, \"TE 0x%x has already ended\\n\", *uid);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n \nstatic void iwl_mvm_remove_aux_roc_te(struct iwl_mvm *mvm,\n\t\t\t\t      struct iwl_mvm_vif *mvmvif,\n\t\t\t\t      struct iwl_mvm_time_event_data *te_data)\n{\n\tstruct iwl_hs20_roc_req aux_cmd = {};\n\tu16 len = sizeof(aux_cmd) - iwl_mvm_chan_info_padding(mvm);\n\n\tu32 uid;\n\tint ret;\n\n\tif (!__iwl_mvm_remove_time_event(mvm, te_data, &uid))\n\t\treturn;\n\n\taux_cmd.event_unique_id = cpu_to_le32(uid);\n\taux_cmd.action = cpu_to_le32(FW_CTXT_ACTION_REMOVE);\n\taux_cmd.id_and_color =\n\t\tcpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id, mvmvif->color));\n\tIWL_DEBUG_TE(mvm, \"Removing BSS AUX ROC TE 0x%x\\n\",\n\t\t     le32_to_cpu(aux_cmd.event_unique_id));\n\tret = iwl_mvm_send_cmd_pdu(mvm, HOT_SPOT_CMD, 0,\n\t\t\t\t   len, &aux_cmd);\n\n\tif (WARN_ON(ret))\n\t\treturn;\n}\n\n \nvoid iwl_mvm_remove_time_event(struct iwl_mvm *mvm,\n\t\t\t       struct iwl_mvm_vif *mvmvif,\n\t\t\t       struct iwl_mvm_time_event_data *te_data)\n{\n\tstruct iwl_time_event_cmd time_cmd = {};\n\tu32 uid;\n\tint ret;\n\n\tif (!__iwl_mvm_remove_time_event(mvm, te_data, &uid))\n\t\treturn;\n\n\t \n\ttime_cmd.id = cpu_to_le32(uid);\n\ttime_cmd.action = cpu_to_le32(FW_CTXT_ACTION_REMOVE);\n\ttime_cmd.id_and_color =\n\t\tcpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id, mvmvif->color));\n\n\tIWL_DEBUG_TE(mvm, \"Removing TE 0x%x\\n\", le32_to_cpu(time_cmd.id));\n\tret = iwl_mvm_send_cmd_pdu(mvm, TIME_EVENT_CMD, 0,\n\t\t\t\t   sizeof(time_cmd), &time_cmd);\n\tif (ret)\n\t\tIWL_ERR(mvm, \"Couldn't remove the time event\\n\");\n}\n\nvoid iwl_mvm_stop_session_protection(struct iwl_mvm *mvm,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_time_event_data *te_data = &mvmvif->time_event_data;\n\tu32 id;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tspin_lock_bh(&mvm->time_event_lock);\n\tid = te_data->id;\n\tspin_unlock_bh(&mvm->time_event_lock);\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_SESSION_PROT_CMD)) {\n\t\tif (id != SESSION_PROTECT_CONF_ASSOC) {\n\t\t\tIWL_DEBUG_TE(mvm,\n\t\t\t\t     \"don't remove session protection id=%u\\n\",\n\t\t\t\t     id);\n\t\t\treturn;\n\t\t}\n\t} else if (id != TE_BSS_STA_AGGRESSIVE_ASSOC) {\n\t\tIWL_DEBUG_TE(mvm,\n\t\t\t     \"don't remove TE with id=%u (not session protection)\\n\",\n\t\t\t     id);\n\t\treturn;\n\t}\n\n\tiwl_mvm_remove_time_event(mvm, mvmvif, te_data);\n}\n\nvoid iwl_mvm_rx_session_protect_notif(struct iwl_mvm *mvm,\n\t\t\t\t      struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_mvm_session_prot_notif *notif = (void *)pkt->data;\n\tstruct ieee80211_vif *vif;\n\tstruct iwl_mvm_vif *mvmvif;\n\n\trcu_read_lock();\n\tvif = iwl_mvm_rcu_dereference_vif_id(mvm, le32_to_cpu(notif->mac_id),\n\t\t\t\t\t     true);\n\n\tif (!vif)\n\t\tgoto out_unlock;\n\n\tmvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\t \n\tif (vif->type != NL80211_IFTYPE_P2P_DEVICE) {\n\t\tstruct iwl_mvm_time_event_data *te_data =\n\t\t\t&mvmvif->time_event_data;\n\n\t\tif (!le32_to_cpu(notif->status)) {\n\t\t\tiwl_mvm_te_check_disconnect(mvm, vif,\n\t\t\t\t\t\t    \"Session protection failure\");\n\t\t\tspin_lock_bh(&mvm->time_event_lock);\n\t\t\tiwl_mvm_te_clear_data(mvm, te_data);\n\t\t\tspin_unlock_bh(&mvm->time_event_lock);\n\t\t}\n\n\t\tif (le32_to_cpu(notif->start)) {\n\t\t\tspin_lock_bh(&mvm->time_event_lock);\n\t\t\tte_data->running = le32_to_cpu(notif->start);\n\t\t\tte_data->end_jiffies =\n\t\t\t\tTU_TO_EXP_TIME(te_data->duration);\n\t\t\tspin_unlock_bh(&mvm->time_event_lock);\n\t\t} else {\n\t\t\t \n\t\t\tiwl_mvm_te_check_disconnect(mvm, vif,\n\t\t\t\t\t\t    !vif->cfg.assoc ?\n\t\t\t\t\t\t    \"Not associated and the session protection is over already...\" :\n\t\t\t\t\t\t    \"No beacon heard and the session protection is over already...\");\n\t\t\tspin_lock_bh(&mvm->time_event_lock);\n\t\t\tiwl_mvm_te_clear_data(mvm, te_data);\n\t\t\tspin_unlock_bh(&mvm->time_event_lock);\n\t\t}\n\n\t\tgoto out_unlock;\n\t}\n\n\tif (!le32_to_cpu(notif->status) || !le32_to_cpu(notif->start)) {\n\t\t \n\t\tmvmvif->time_event_data.id = SESSION_PROTECT_CONF_MAX_ID;\n\t\tiwl_mvm_p2p_roc_finished(mvm);\n\t\tieee80211_remain_on_channel_expired(mvm->hw);\n\t} else if (le32_to_cpu(notif->start)) {\n\t\tif (WARN_ON(mvmvif->time_event_data.id !=\n\t\t\t\tle32_to_cpu(notif->conf_id)))\n\t\t\tgoto out_unlock;\n\t\tset_bit(IWL_MVM_STATUS_ROC_RUNNING, &mvm->status);\n\t\tieee80211_ready_on_channel(mvm->hw);  \n\t}\n\n out_unlock:\n\trcu_read_unlock();\n}\n\nstatic int\niwl_mvm_start_p2p_roc_session_protection(struct iwl_mvm *mvm,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t int duration,\n\t\t\t\t\t enum ieee80211_roc_type type)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_session_prot_cmd cmd = {\n\t\t.id_and_color =\n\t\t\tcpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id,\n\t\t\t\t\t\t\tmvmvif->color)),\n\t\t.action = cpu_to_le32(FW_CTXT_ACTION_ADD),\n\t\t.duration_tu = cpu_to_le32(MSEC_TO_TU(duration)),\n\t};\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\t \n\tswitch (type) {\n\tcase IEEE80211_ROC_TYPE_NORMAL:\n\t\tmvmvif->time_event_data.id =\n\t\t\tSESSION_PROTECT_CONF_P2P_DEVICE_DISCOV;\n\t\tbreak;\n\tcase IEEE80211_ROC_TYPE_MGMT_TX:\n\t\tmvmvif->time_event_data.id =\n\t\t\tSESSION_PROTECT_CONF_P2P_GO_NEGOTIATION;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(1, \"Got an invalid ROC type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcmd.conf_id = cpu_to_le32(mvmvif->time_event_data.id);\n\treturn iwl_mvm_send_cmd_pdu(mvm,\n\t\t\t\t    WIDE_ID(MAC_CONF_GROUP, SESSION_PROTECTION_CMD),\n\t\t\t\t    0, sizeof(cmd), &cmd);\n}\n\nint iwl_mvm_start_p2p_roc(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t  int duration, enum ieee80211_roc_type type)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_time_event_data *te_data = &mvmvif->time_event_data;\n\tstruct iwl_time_event_cmd time_cmd = {};\n\n\tlockdep_assert_held(&mvm->mutex);\n\tif (te_data->running) {\n\t\tIWL_WARN(mvm, \"P2P_DEVICE remain on channel already running\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_SESSION_PROT_CMD))\n\t\treturn iwl_mvm_start_p2p_roc_session_protection(mvm, vif,\n\t\t\t\t\t\t\t\tduration,\n\t\t\t\t\t\t\t\ttype);\n\n\ttime_cmd.action = cpu_to_le32(FW_CTXT_ACTION_ADD);\n\ttime_cmd.id_and_color =\n\t\tcpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id, mvmvif->color));\n\n\tswitch (type) {\n\tcase IEEE80211_ROC_TYPE_NORMAL:\n\t\ttime_cmd.id = cpu_to_le32(IWL_MVM_ROC_TE_TYPE_NORMAL);\n\t\tbreak;\n\tcase IEEE80211_ROC_TYPE_MGMT_TX:\n\t\ttime_cmd.id = cpu_to_le32(IWL_MVM_ROC_TE_TYPE_MGMT_TX);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(1, \"Got an invalid ROC type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttime_cmd.apply_time = cpu_to_le32(0);\n\ttime_cmd.interval = cpu_to_le32(1);\n\n\t \n\ttime_cmd.max_frags = min(MSEC_TO_TU(duration)/50, TE_V2_FRAG_ENDLESS);\n\ttime_cmd.max_delay = cpu_to_le32(MSEC_TO_TU(duration/2));\n\ttime_cmd.duration = cpu_to_le32(MSEC_TO_TU(duration));\n\ttime_cmd.repeat = 1;\n\ttime_cmd.policy = cpu_to_le16(TE_V2_NOTIF_HOST_EVENT_START |\n\t\t\t\t      TE_V2_NOTIF_HOST_EVENT_END |\n\t\t\t\t      TE_V2_START_IMMEDIATELY);\n\n\treturn iwl_mvm_time_event_send_add(mvm, vif, te_data, &time_cmd);\n}\n\nstatic struct iwl_mvm_time_event_data *iwl_mvm_get_roc_te(struct iwl_mvm *mvm)\n{\n\tstruct iwl_mvm_time_event_data *te_data;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tspin_lock_bh(&mvm->time_event_lock);\n\n\t \n\tlist_for_each_entry(te_data, &mvm->time_event_list, list) {\n\t\tif (te_data->vif->type == NL80211_IFTYPE_P2P_DEVICE)\n\t\t\tgoto out;\n\t}\n\n\t \n\tte_data = list_first_entry_or_null(&mvm->aux_roc_te_list,\n\t\t\t\t\t   struct iwl_mvm_time_event_data,\n\t\t\t\t\t   list);\nout:\n\tspin_unlock_bh(&mvm->time_event_lock);\n\treturn te_data;\n}\n\nvoid iwl_mvm_cleanup_roc_te(struct iwl_mvm *mvm)\n{\n\tstruct iwl_mvm_time_event_data *te_data;\n\tu32 uid;\n\n\tte_data = iwl_mvm_get_roc_te(mvm);\n\tif (te_data)\n\t\t__iwl_mvm_remove_time_event(mvm, te_data, &uid);\n}\n\nvoid iwl_mvm_stop_roc(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif;\n\tstruct iwl_mvm_time_event_data *te_data;\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_SESSION_PROT_CMD)) {\n\t\tmvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\t\tif (vif->type == NL80211_IFTYPE_P2P_DEVICE) {\n\t\t\tiwl_mvm_cancel_session_protection(mvm, mvmvif,\n\t\t\t\t\t\t\t  mvmvif->time_event_data.id);\n\t\t\tiwl_mvm_p2p_roc_finished(mvm);\n\t\t} else {\n\t\t\tiwl_mvm_remove_aux_roc_te(mvm, mvmvif,\n\t\t\t\t\t\t  &mvmvif->hs_time_event_data);\n\t\t\tiwl_mvm_roc_finished(mvm);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tte_data = iwl_mvm_get_roc_te(mvm);\n\tif (!te_data) {\n\t\tIWL_WARN(mvm, \"No remain on channel event\\n\");\n\t\treturn;\n\t}\n\n\tmvmvif = iwl_mvm_vif_from_mac80211(te_data->vif);\n\n\tif (te_data->vif->type == NL80211_IFTYPE_P2P_DEVICE) {\n\t\tiwl_mvm_remove_time_event(mvm, mvmvif, te_data);\n\t\tiwl_mvm_p2p_roc_finished(mvm);\n\t} else {\n\t\tiwl_mvm_remove_aux_roc_te(mvm, mvmvif, te_data);\n\t\tiwl_mvm_roc_finished(mvm);\n\t}\n}\n\nvoid iwl_mvm_remove_csa_period(struct iwl_mvm *mvm,\n\t\t\t       struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_time_event_data *te_data = &mvmvif->time_event_data;\n\tu32 id;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tspin_lock_bh(&mvm->time_event_lock);\n\tid = te_data->id;\n\tspin_unlock_bh(&mvm->time_event_lock);\n\n\tif (id != TE_CHANNEL_SWITCH_PERIOD)\n\t\treturn;\n\n\tiwl_mvm_remove_time_event(mvm, mvmvif, te_data);\n}\n\nint iwl_mvm_schedule_csa_period(struct iwl_mvm *mvm,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tu32 duration, u32 apply_time)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_time_event_data *te_data = &mvmvif->time_event_data;\n\tstruct iwl_time_event_cmd time_cmd = {};\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (te_data->running) {\n\t\tu32 id;\n\n\t\tspin_lock_bh(&mvm->time_event_lock);\n\t\tid = te_data->id;\n\t\tspin_unlock_bh(&mvm->time_event_lock);\n\n\t\tif (id == TE_CHANNEL_SWITCH_PERIOD) {\n\t\t\tIWL_DEBUG_TE(mvm, \"CS period is already scheduled\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\t \n\t\tiwl_mvm_remove_time_event(mvm, mvmvif, te_data);\n\t}\n\n\ttime_cmd.action = cpu_to_le32(FW_CTXT_ACTION_ADD);\n\ttime_cmd.id_and_color =\n\t\tcpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id, mvmvif->color));\n\ttime_cmd.id = cpu_to_le32(TE_CHANNEL_SWITCH_PERIOD);\n\ttime_cmd.apply_time = cpu_to_le32(apply_time);\n\ttime_cmd.max_frags = TE_V2_FRAG_NONE;\n\ttime_cmd.duration = cpu_to_le32(duration);\n\ttime_cmd.repeat = 1;\n\ttime_cmd.interval = cpu_to_le32(1);\n\ttime_cmd.policy = cpu_to_le16(TE_V2_NOTIF_HOST_EVENT_START |\n\t\t\t\t      TE_V2_ABSENCE);\n\tif (!apply_time)\n\t\ttime_cmd.policy |= cpu_to_le16(TE_V2_START_IMMEDIATELY);\n\n\treturn iwl_mvm_time_event_send_add(mvm, vif, te_data, &time_cmd);\n}\n\nstatic bool iwl_mvm_session_prot_notif(struct iwl_notif_wait_data *notif_wait,\n\t\t\t\t       struct iwl_rx_packet *pkt, void *data)\n{\n\tstruct iwl_mvm *mvm =\n\t\tcontainer_of(notif_wait, struct iwl_mvm, notif_wait);\n\tstruct iwl_mvm_session_prot_notif *resp;\n\tint resp_len = iwl_rx_packet_payload_len(pkt);\n\n\tif (WARN_ON(pkt->hdr.cmd != SESSION_PROTECTION_NOTIF ||\n\t\t    pkt->hdr.group_id != MAC_CONF_GROUP))\n\t\treturn true;\n\n\tif (WARN_ON_ONCE(resp_len != sizeof(*resp))) {\n\t\tIWL_ERR(mvm, \"Invalid SESSION_PROTECTION_NOTIF response\\n\");\n\t\treturn true;\n\t}\n\n\tresp = (void *)pkt->data;\n\n\tif (!resp->status)\n\t\tIWL_ERR(mvm,\n\t\t\t\"TIME_EVENT_NOTIFICATION received but not executed\\n\");\n\n\treturn true;\n}\n\nvoid iwl_mvm_schedule_session_protection(struct iwl_mvm *mvm,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t u32 duration, u32 min_duration,\n\t\t\t\t\t bool wait_for_notif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_time_event_data *te_data = &mvmvif->time_event_data;\n\tconst u16 notif[] = { WIDE_ID(MAC_CONF_GROUP, SESSION_PROTECTION_NOTIF) };\n\tstruct iwl_notification_wait wait_notif;\n\tstruct iwl_mvm_session_prot_cmd cmd = {\n\t\t.id_and_color =\n\t\t\tcpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id,\n\t\t\t\t\t\t\tmvmvif->color)),\n\t\t.action = cpu_to_le32(FW_CTXT_ACTION_ADD),\n\t\t.conf_id = cpu_to_le32(SESSION_PROTECT_CONF_ASSOC),\n\t\t.duration_tu = cpu_to_le32(MSEC_TO_TU(duration)),\n\t};\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tspin_lock_bh(&mvm->time_event_lock);\n\tif (te_data->running &&\n\t    time_after(te_data->end_jiffies, TU_TO_EXP_TIME(min_duration))) {\n\t\tIWL_DEBUG_TE(mvm, \"We have enough time in the current TE: %u\\n\",\n\t\t\t     jiffies_to_msecs(te_data->end_jiffies - jiffies));\n\t\tspin_unlock_bh(&mvm->time_event_lock);\n\n\t\treturn;\n\t}\n\n\tiwl_mvm_te_clear_data(mvm, te_data);\n\t \n\tte_data->id = le32_to_cpu(cmd.conf_id);\n\tte_data->duration = le32_to_cpu(cmd.duration_tu);\n\tte_data->vif = vif;\n\tspin_unlock_bh(&mvm->time_event_lock);\n\n\tIWL_DEBUG_TE(mvm, \"Add new session protection, duration %d TU\\n\",\n\t\t     le32_to_cpu(cmd.duration_tu));\n\n\tif (!wait_for_notif) {\n\t\tif (iwl_mvm_send_cmd_pdu(mvm,\n\t\t\t\t\t WIDE_ID(MAC_CONF_GROUP, SESSION_PROTECTION_CMD),\n\t\t\t\t\t 0, sizeof(cmd), &cmd)) {\n\t\t\tIWL_ERR(mvm,\n\t\t\t\t\"Couldn't send the SESSION_PROTECTION_CMD\\n\");\n\t\t\tspin_lock_bh(&mvm->time_event_lock);\n\t\t\tiwl_mvm_te_clear_data(mvm, te_data);\n\t\t\tspin_unlock_bh(&mvm->time_event_lock);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tiwl_init_notification_wait(&mvm->notif_wait, &wait_notif,\n\t\t\t\t   notif, ARRAY_SIZE(notif),\n\t\t\t\t   iwl_mvm_session_prot_notif, NULL);\n\n\tif (iwl_mvm_send_cmd_pdu(mvm,\n\t\t\t\t WIDE_ID(MAC_CONF_GROUP, SESSION_PROTECTION_CMD),\n\t\t\t\t 0, sizeof(cmd), &cmd)) {\n\t\tIWL_ERR(mvm,\n\t\t\t\"Couldn't send the SESSION_PROTECTION_CMD\\n\");\n\t\tiwl_remove_notification(&mvm->notif_wait, &wait_notif);\n\t} else if (iwl_wait_notification(&mvm->notif_wait, &wait_notif,\n\t\t\t\t\t TU_TO_JIFFIES(100))) {\n\t\tIWL_ERR(mvm,\n\t\t\t\"Failed to protect session until session protection\\n\");\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}