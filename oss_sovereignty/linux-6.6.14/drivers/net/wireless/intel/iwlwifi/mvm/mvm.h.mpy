{
  "module_name": "mvm.h",
  "hash_id": "dbc2fb7e44ac865d353e3ef29c56118b2f690fd62600f61de9ff6ac5fcf8c1b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/mvm.h",
  "human_readable_source": " \n \n#ifndef __IWL_MVM_H__\n#define __IWL_MVM_H__\n\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/leds.h>\n#include <linux/in6.h>\n\n#ifdef CONFIG_THERMAL\n#include <linux/thermal.h>\n#endif\n\n#include <linux/ptp_clock_kernel.h>\n\n#include <linux/ktime.h>\n\n#include \"iwl-op-mode.h\"\n#include \"iwl-trans.h\"\n#include \"fw/notif-wait.h\"\n#include \"iwl-eeprom-parse.h\"\n#include \"fw/file.h\"\n#include \"iwl-config.h\"\n#include \"sta.h\"\n#include \"fw-api.h\"\n#include \"constants.h\"\n#include \"fw/runtime.h\"\n#include \"fw/dbg.h\"\n#include \"fw/acpi.h\"\n#include \"mei/iwl-mei.h\"\n#include \"iwl-nvm-parse.h\"\n\n#include <linux/average.h>\n\n#define IWL_MVM_MAX_ADDRESSES\t\t5\n \n#define IWL_RSSI_OFFSET 50\n#define IWL_MVM_MISSED_BEACONS_THRESHOLD 8\n#define IWL_MVM_MISSED_BEACONS_THRESHOLD_LONG 16\n\n \n#define MSEC_TO_TU(_msec)\t(_msec*1000/1024)\n\n \n#define IWL_MVM_CHANNEL_SWITCH_TIME_GO\t\t40\n\n \n#define IWL_MVM_CHANNEL_SWITCH_TIME_CLIENT\t10\n\n \n#define IWL_MVM_CHANNEL_SWITCH_MARGIN 4\n\n \n#define IWL_MVM_CS_UNBLOCK_TX_TIMEOUT 3\n\n \n#define IWL_MVM_OFFCHANNEL_QUEUE 0\n\n \n#define IWL_MVM_FW_LINK_ID_INVALID 0xff\n\nextern const struct ieee80211_ops iwl_mvm_hw_ops;\nextern const struct ieee80211_ops iwl_mvm_mld_hw_ops;\n\n \nstruct iwl_mvm_mod_params {\n\tbool init_dbg;\n\tint power_scheme;\n};\nextern struct iwl_mvm_mod_params iwlmvm_mod_params;\n\nstruct iwl_mvm_phy_ctxt {\n\tu16 id;\n\tu16 color;\n\tu32 ref;\n\n\tenum nl80211_chan_width width;\n\n\tstruct ieee80211_channel *channel;\n\n\t \n\tu32 center_freq1;\n\tbool rlc_disabled;\n};\n\nstruct iwl_mvm_time_event_data {\n\tstruct ieee80211_vif *vif;\n\tstruct list_head list;\n\tunsigned long end_jiffies;\n\tu32 duration;\n\tbool running;\n\tu32 uid;\n\n\t \n\tu32 id;\n};\n\n  \n\n \nenum iwl_power_scheme {\n\tIWL_POWER_SCHEME_CAM = 1,\n\tIWL_POWER_SCHEME_BPS,\n\tIWL_POWER_SCHEME_LP\n};\n\n#define IWL_CONN_MAX_LISTEN_INTERVAL\t10\n#define IWL_UAPSD_MAX_SP\t\tIEEE80211_WMM_IE_STA_QOSINFO_SP_ALL\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\nenum iwl_dbgfs_pm_mask {\n\tMVM_DEBUGFS_PM_KEEP_ALIVE = BIT(0),\n\tMVM_DEBUGFS_PM_SKIP_OVER_DTIM = BIT(1),\n\tMVM_DEBUGFS_PM_SKIP_DTIM_PERIODS = BIT(2),\n\tMVM_DEBUGFS_PM_RX_DATA_TIMEOUT = BIT(3),\n\tMVM_DEBUGFS_PM_TX_DATA_TIMEOUT = BIT(4),\n\tMVM_DEBUGFS_PM_LPRX_ENA = BIT(6),\n\tMVM_DEBUGFS_PM_LPRX_RSSI_THRESHOLD = BIT(7),\n\tMVM_DEBUGFS_PM_SNOOZE_ENABLE = BIT(8),\n\tMVM_DEBUGFS_PM_UAPSD_MISBEHAVING = BIT(9),\n\tMVM_DEBUGFS_PM_USE_PS_POLL = BIT(10),\n};\n\nstruct iwl_dbgfs_pm {\n\tu16 keep_alive_seconds;\n\tu32 rx_data_timeout;\n\tu32 tx_data_timeout;\n\tbool skip_over_dtim;\n\tu8 skip_dtim_periods;\n\tbool lprx_ena;\n\tu32 lprx_rssi_threshold;\n\tbool snooze_ena;\n\tbool uapsd_misbehaving;\n\tbool use_ps_poll;\n\tint mask;\n};\n\n \n\nenum iwl_dbgfs_bf_mask {\n\tMVM_DEBUGFS_BF_ENERGY_DELTA = BIT(0),\n\tMVM_DEBUGFS_BF_ROAMING_ENERGY_DELTA = BIT(1),\n\tMVM_DEBUGFS_BF_ROAMING_STATE = BIT(2),\n\tMVM_DEBUGFS_BF_TEMP_THRESHOLD = BIT(3),\n\tMVM_DEBUGFS_BF_TEMP_FAST_FILTER = BIT(4),\n\tMVM_DEBUGFS_BF_TEMP_SLOW_FILTER = BIT(5),\n\tMVM_DEBUGFS_BF_ENABLE_BEACON_FILTER = BIT(6),\n\tMVM_DEBUGFS_BF_DEBUG_FLAG = BIT(7),\n\tMVM_DEBUGFS_BF_ESCAPE_TIMER = BIT(8),\n\tMVM_DEBUGFS_BA_ESCAPE_TIMER = BIT(9),\n\tMVM_DEBUGFS_BA_ENABLE_BEACON_ABORT = BIT(10),\n};\n\nstruct iwl_dbgfs_bf {\n\tu32 bf_energy_delta;\n\tu32 bf_roaming_energy_delta;\n\tu32 bf_roaming_state;\n\tu32 bf_temp_threshold;\n\tu32 bf_temp_fast_filter;\n\tu32 bf_temp_slow_filter;\n\tu32 bf_enable_beacon_filter;\n\tu32 bf_debug_flag;\n\tu32 bf_escape_timer;\n\tu32 ba_escape_timer;\n\tu32 ba_enable_beacon_abort;\n\tint mask;\n};\n#endif\n\nenum iwl_mvm_smps_type_request {\n\tIWL_MVM_SMPS_REQ_BT_COEX,\n\tIWL_MVM_SMPS_REQ_TT,\n\tIWL_MVM_SMPS_REQ_PROT,\n\tIWL_MVM_SMPS_REQ_FW,\n\tNUM_IWL_MVM_SMPS_REQ,\n};\n\nenum iwl_bt_force_ant_mode {\n\tBT_FORCE_ANT_DIS = 0,\n\tBT_FORCE_ANT_AUTO,\n\tBT_FORCE_ANT_BT,\n\tBT_FORCE_ANT_WIFI,\n\n\tBT_FORCE_ANT_MAX,\n};\n\n \nenum iwl_mvm_low_latency_force {\n\tLOW_LATENCY_FORCE_UNSET,\n\tLOW_LATENCY_FORCE_ON,\n\tLOW_LATENCY_FORCE_OFF,\n\tNUM_LOW_LATENCY_FORCE\n};\n\n \nenum iwl_mvm_low_latency_cause {\n\tLOW_LATENCY_TRAFFIC = BIT(0),\n\tLOW_LATENCY_DEBUGFS = BIT(1),\n\tLOW_LATENCY_VCMD = BIT(2),\n\tLOW_LATENCY_VIF_TYPE = BIT(3),\n\tLOW_LATENCY_DEBUGFS_FORCE_ENABLE = BIT(4),\n\tLOW_LATENCY_DEBUGFS_FORCE = BIT(5),\n};\n\n \nstruct iwl_mvm_vif_bf_data {\n\tbool bf_enabled;\n\tbool ba_enabled;\n\tint ave_beacon_signal;\n\tint last_cqm_event;\n\tint bt_coex_min_thold;\n\tint bt_coex_max_thold;\n\tint last_bt_coex_event;\n};\n\n \nstruct iwl_probe_resp_data {\n\tstruct rcu_head rcu_head;\n\tstruct iwl_probe_resp_data_notif notif;\n\tint noa_len;\n};\n\n \nstruct iwl_mvm_vif_link_info {\n\tu8 bssid[ETH_ALEN];\n\tu8 ap_sta_id;\n\tu8 fw_link_id;\n\n\tstruct iwl_mvm_int_sta bcast_sta;\n\tstruct iwl_mvm_int_sta mcast_sta;\n\n\tstruct {\n\t\tu32 num_beacons, accu_num_beacons;\n\t\tu8 avg_signal;\n\t} beacon_stats;\n\n\tenum ieee80211_smps_mode smps_requests[NUM_IWL_MVM_SMPS_REQ];\n\tstruct iwl_probe_resp_data __rcu *probe_resp_data;\n\n\tstruct ieee80211_key_conf *igtk;\n\n\tbool he_ru_2mhz_block;\n\tbool active;\n\tbool listen_lmac;\n\n\tu16 cab_queue;\n\t \n\tstruct iwl_mvm_phy_ctxt *phy_ctxt;\n\t \n\tstruct ieee80211_tx_queue_params queue_params[IEEE80211_NUM_ACS];\n\n\tu16 mgmt_queue;\n};\n\n \nstruct iwl_mvm_vif {\n\tstruct iwl_mvm *mvm;\n\tu16 id;\n\tu16 color;\n\n\tbool associated;\n\tu8 ap_assoc_sta_count;\n\tbool uploaded;\n\tbool ap_ibss_active;\n\tbool pm_enabled;\n\tbool monitor_active;\n\tbool esr_active;\n\n\tu8 low_latency: 6;\n\tu8 low_latency_actual: 1;\n\n\tu8 authorized:1;\n\tbool ps_disabled;\n\n\tu32 ap_beacon_time;\n\tstruct iwl_mvm_vif_bf_data bf_data;\n\n#ifdef CONFIG_PM\n\t \n\tstruct {\n\t\tu8 kck[NL80211_KCK_EXT_LEN];\n\t\tu8 kek[NL80211_KEK_EXT_LEN];\n\t\tsize_t kek_len;\n\t\tsize_t kck_len;\n\t\tu32 akm;\n\t\t__le64 replay_ctr;\n\t\tbool valid;\n\t} rekey_data;\n\n\tint tx_key_idx;\n\n\tbool seqno_valid;\n\tu16 seqno;\n#endif\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t \n\tstruct in6_addr target_ipv6_addrs[IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS_MAX];\n\tunsigned long tentative_addrs[BITS_TO_LONGS(IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS_MAX)];\n\tint num_target_ipv6_addrs;\n#endif\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tstruct dentry *dbgfs_dir;\n\tstruct dentry *dbgfs_slink;\n\tstruct iwl_dbgfs_pm dbgfs_pm;\n\tstruct iwl_dbgfs_bf dbgfs_bf;\n\tstruct iwl_mac_power_cmd mac_pwr_cmd;\n\tint dbgfs_quota_min;\n#endif\n\n\t \n\tu8 uapsd_misbehaving_ap_addr[ETH_ALEN] __aligned(2);\n\tstruct delayed_work uapsd_nonagg_detected_wk;\n\n\tbool csa_countdown;\n\tbool csa_failed;\n\tbool csa_bcn_pending;\n\tu16 csa_target_freq;\n\tu16 csa_count;\n\tu16 csa_misbehave;\n\tstruct delayed_work csa_work;\n\n\tenum iwl_tsf_id tsf_id;\n\n\tstruct iwl_mvm_time_event_data time_event_data;\n\tstruct iwl_mvm_time_event_data hs_time_event_data;\n\n\t \n\tnetdev_features_t features;\n\n\tstruct ieee80211_sta *ap_sta;\n\n\t \n\tstruct ieee80211_key_conf *ap_early_keys[4];\n\n\tstruct {\n\t\tstruct ieee80211_key_conf __rcu *keys[2];\n\t} bcn_prot;\n\n\tstruct iwl_mvm_vif_link_info deflink;\n\tstruct iwl_mvm_vif_link_info *link[IEEE80211_MLD_MAX_NUM_LINKS];\n};\n\n#define for_each_mvm_vif_valid_link(mvm_vif, link_id)\t\t\t\\\n\tfor (link_id = 0;\t\t\t\t\t\t\\\n\t     link_id < ARRAY_SIZE((mvm_vif)->link);\t\t\t\\\n\t     link_id++)\t\t\t\t\t\t\t\\\n\t\tif ((mvm_vif)->link[link_id])\n\nstatic inline struct iwl_mvm_vif *\niwl_mvm_vif_from_mac80211(struct ieee80211_vif *vif)\n{\n\treturn (void *)vif->drv_priv;\n}\n\nextern const u8 tid_to_mac80211_ac[];\n\n#define IWL_MVM_SCAN_STOPPING_SHIFT\t8\n\nenum iwl_scan_status {\n\tIWL_MVM_SCAN_REGULAR\t\t= BIT(0),\n\tIWL_MVM_SCAN_SCHED\t\t= BIT(1),\n\tIWL_MVM_SCAN_NETDETECT\t\t= BIT(2),\n\n\tIWL_MVM_SCAN_STOPPING_REGULAR\t= BIT(8),\n\tIWL_MVM_SCAN_STOPPING_SCHED\t= BIT(9),\n\tIWL_MVM_SCAN_STOPPING_NETDETECT\t= BIT(10),\n\n\tIWL_MVM_SCAN_REGULAR_MASK\t= IWL_MVM_SCAN_REGULAR |\n\t\t\t\t\t  IWL_MVM_SCAN_STOPPING_REGULAR,\n\tIWL_MVM_SCAN_SCHED_MASK\t\t= IWL_MVM_SCAN_SCHED |\n\t\t\t\t\t  IWL_MVM_SCAN_STOPPING_SCHED,\n\tIWL_MVM_SCAN_NETDETECT_MASK\t= IWL_MVM_SCAN_NETDETECT |\n\t\t\t\t\t  IWL_MVM_SCAN_STOPPING_NETDETECT,\n\n\tIWL_MVM_SCAN_STOPPING_MASK\t= 0xff << IWL_MVM_SCAN_STOPPING_SHIFT,\n\tIWL_MVM_SCAN_MASK\t\t= 0xff,\n};\n\nenum iwl_mvm_scan_type {\n\tIWL_SCAN_TYPE_NOT_SET,\n\tIWL_SCAN_TYPE_UNASSOC,\n\tIWL_SCAN_TYPE_WILD,\n\tIWL_SCAN_TYPE_MILD,\n\tIWL_SCAN_TYPE_FRAGMENTED,\n\tIWL_SCAN_TYPE_FAST_BALANCE,\n};\n\nenum iwl_mvm_sched_scan_pass_all_states {\n\tSCHED_SCAN_PASS_ALL_DISABLED,\n\tSCHED_SCAN_PASS_ALL_ENABLED,\n\tSCHED_SCAN_PASS_ALL_FOUND,\n};\n\n \nstruct iwl_mvm_tt_mgmt {\n\tstruct delayed_work ct_kill_exit;\n\tbool dynamic_smps;\n\tu32 tx_backoff;\n\tu32 min_backoff;\n\tstruct iwl_tt_params params;\n\tbool throttle;\n};\n\n#ifdef CONFIG_THERMAL\n \nstruct iwl_mvm_thermal_device {\n\tstruct thermal_trip trips[IWL_MAX_DTS_TRIPS];\n\tu8 fw_trips_index[IWL_MAX_DTS_TRIPS];\n\tstruct thermal_zone_device *tzone;\n};\n\n \nstruct iwl_mvm_cooling_device {\n\tu32 cur_state;\n\tstruct thermal_cooling_device *cdev;\n};\n#endif\n\n#define IWL_MVM_NUM_LAST_FRAMES_UCODE_RATES 8\n\nstruct iwl_mvm_frame_stats {\n\tu32 legacy_frames;\n\tu32 ht_frames;\n\tu32 vht_frames;\n\tu32 bw_20_frames;\n\tu32 bw_40_frames;\n\tu32 bw_80_frames;\n\tu32 bw_160_frames;\n\tu32 sgi_frames;\n\tu32 ngi_frames;\n\tu32 siso_frames;\n\tu32 mimo2_frames;\n\tu32 agg_frames;\n\tu32 ampdu_count;\n\tu32 success_frames;\n\tu32 fail_frames;\n\tu32 last_rates[IWL_MVM_NUM_LAST_FRAMES_UCODE_RATES];\n\tint last_frame_idx;\n};\n\n#define IWL_MVM_DEBUG_SET_TEMPERATURE_DISABLE 0xff\n#define IWL_MVM_DEBUG_SET_TEMPERATURE_MIN -100\n#define IWL_MVM_DEBUG_SET_TEMPERATURE_MAX 200\n\nenum iwl_mvm_tdls_cs_state {\n\tIWL_MVM_TDLS_SW_IDLE = 0,\n\tIWL_MVM_TDLS_SW_REQ_SENT,\n\tIWL_MVM_TDLS_SW_RESP_RCVD,\n\tIWL_MVM_TDLS_SW_REQ_RCVD,\n\tIWL_MVM_TDLS_SW_ACTIVE,\n};\n\nenum iwl_mvm_traffic_load {\n\tIWL_MVM_TRAFFIC_LOW,\n\tIWL_MVM_TRAFFIC_MEDIUM,\n\tIWL_MVM_TRAFFIC_HIGH,\n};\n\nDECLARE_EWMA(rate, 16, 16)\n\nstruct iwl_mvm_tcm_mac {\n\tstruct {\n\t\tu32 pkts[IEEE80211_NUM_ACS];\n\t\tu32 airtime;\n\t} tx;\n\tstruct {\n\t\tu32 pkts[IEEE80211_NUM_ACS];\n\t\tu32 airtime;\n\t\tu32 last_ampdu_ref;\n\t} rx;\n\tstruct {\n\t\t \n\t\tu64 rx_bytes;\n\t\tstruct ewma_rate rate;\n\t\tbool detected;\n\t} uapsd_nonagg_detect;\n\tbool opened_rx_ba_sessions;\n};\n\nstruct iwl_mvm_tcm {\n\tstruct delayed_work work;\n\tspinlock_t lock;  \n\tunsigned long ts;  \n\tunsigned long ll_ts;\n\tunsigned long uapsd_nonagg_ts;\n\tbool paused;\n\tstruct iwl_mvm_tcm_mac data[NUM_MAC_INDEX_DRIVER];\n\tstruct {\n\t\tu32 elapsed;  \n\t\tu32 airtime[NUM_MAC_INDEX_DRIVER];\n\t\tenum iwl_mvm_traffic_load load[NUM_MAC_INDEX_DRIVER];\n\t\tenum iwl_mvm_traffic_load band_load[NUM_NL80211_BANDS];\n\t\tenum iwl_mvm_traffic_load global_load;\n\t\tbool low_latency[NUM_MAC_INDEX_DRIVER];\n\t\tbool change[NUM_MAC_INDEX_DRIVER];\n\t} result;\n};\n\n \nstruct iwl_mvm_reorder_buffer {\n\tu16 head_sn;\n\tu16 num_stored;\n\tu16 buf_size;\n\tint queue;\n\tu16 last_amsdu;\n\tu8 last_sub_index;\n\tstruct timer_list reorder_timer;\n\tbool removed;\n\tbool valid;\n\tspinlock_t lock;\n\tstruct iwl_mvm *mvm;\n\tunsigned int consec_oldsn_drops;\n\tu32 consec_oldsn_ampdu_gp2;\n\tunsigned int consec_oldsn_prev_drop:1;\n} ____cacheline_aligned_in_smp;\n\n \nstruct _iwl_mvm_reorder_buf_entry {\n\tstruct sk_buff_head frames;\n\tunsigned long reorder_time;\n};\n\n \nstruct iwl_mvm_reorder_buf_entry {\n\tstruct _iwl_mvm_reorder_buf_entry e;\n}\n#ifndef __CHECKER__\n \n__aligned(roundup_pow_of_two(sizeof(struct _iwl_mvm_reorder_buf_entry)))\n#endif\n;\n\n \nstruct iwl_mvm_baid_data {\n\tstruct rcu_head rcu_head;\n\tu32 sta_mask;\n\tu8 tid;\n\tu8 baid;\n\tu16 timeout;\n\tu16 entries_per_queue;\n\tunsigned long last_rx;\n\tstruct timer_list session_timer;\n\tstruct iwl_mvm_baid_data __rcu **rcu_ptr;\n\tstruct iwl_mvm *mvm;\n\tstruct iwl_mvm_reorder_buffer reorder_buf[IWL_MAX_RX_HW_QUEUES];\n\tstruct iwl_mvm_reorder_buf_entry entries[];\n};\n\nstatic inline struct iwl_mvm_baid_data *\niwl_mvm_baid_data_from_reorder_buf(struct iwl_mvm_reorder_buffer *buf)\n{\n\treturn (void *)((u8 *)buf -\n\t\t\toffsetof(struct iwl_mvm_baid_data, reorder_buf) -\n\t\t\tsizeof(*buf) * buf->queue);\n}\n\n \nenum iwl_mvm_queue_status {\n\tIWL_MVM_QUEUE_FREE,\n\tIWL_MVM_QUEUE_RESERVED,\n\tIWL_MVM_QUEUE_READY,\n\tIWL_MVM_QUEUE_SHARED,\n};\n\n#define IWL_MVM_DQA_QUEUE_TIMEOUT\t(5 * HZ)\n#define IWL_MVM_INVALID_QUEUE\t\t0xFFFF\n\n#define IWL_MVM_NUM_CIPHERS             10\n\n\nstruct iwl_mvm_txq {\n\tstruct list_head list;\n\tu16 txq_id;\n\tatomic_t tx_request;\n#define IWL_MVM_TXQ_STATE_STOP_FULL\t0\n#define IWL_MVM_TXQ_STATE_STOP_REDIRECT\t1\n#define IWL_MVM_TXQ_STATE_READY\t\t2\n\tunsigned long state;\n};\n\nstatic inline struct iwl_mvm_txq *\niwl_mvm_txq_from_mac80211(struct ieee80211_txq *txq)\n{\n\treturn (void *)txq->drv_priv;\n}\n\nstatic inline struct iwl_mvm_txq *\niwl_mvm_txq_from_tid(struct ieee80211_sta *sta, u8 tid)\n{\n\tif (tid == IWL_MAX_TID_COUNT)\n\t\ttid = IEEE80211_NUM_TIDS;\n\n\treturn (void *)sta->txq[tid]->drv_priv;\n}\n\n \nstruct iwl_mvm_tvqm_txq_info {\n\tu8 sta_id;\n\tu8 txq_tid;\n};\n\nstruct iwl_mvm_dqa_txq_info {\n\tu8 ra_sta_id;  \n\tbool reserved;  \n\tu8 mac80211_ac;  \n\tu8 txq_tid;  \n\tu16 tid_bitmap;  \n\t \n\tunsigned long last_frame_time[IWL_MAX_TID_COUNT + 1];\n\tenum iwl_mvm_queue_status status;\n};\n\nstruct ptp_data {\n\tstruct ptp_clock *ptp_clock;\n\tstruct ptp_clock_info ptp_clock_info;\n\n\tstruct delayed_work dwork;\n\n\t \n\tu32 last_gp2;\n\n\t \n\tu32 wrap_counter;\n\n\t \n\tu32 scale_update_gp2;\n\n\t \n\tu64 scale_update_adj_time_ns;\n\n\t \n\tu64 scaled_freq;\n\n\t \n\ts64 delta;\n};\n\nstruct iwl_time_sync_data {\n\tstruct sk_buff_head frame_list;\n\tu8 peer_addr[ETH_ALEN];\n\tbool active;\n};\n\nstruct iwl_mei_scan_filter {\n\tbool is_mei_limited_scan;\n\tstruct sk_buff_head scan_res;\n\tstruct work_struct scan_work;\n};\n\nstruct iwl_mvm {\n\t \n\tstruct device *dev;\n\n\tstruct iwl_trans *trans;\n\tconst struct iwl_fw *fw;\n\tconst struct iwl_cfg *cfg;\n\tstruct iwl_phy_db *phy_db;\n\tstruct ieee80211_hw *hw;\n\n\t \n\tstruct mutex mutex;\n\tstruct list_head async_handlers_list;\n\tspinlock_t async_handlers_lock;\n\tstruct work_struct async_handlers_wk;\n\n\tstruct work_struct roc_done_wk;\n\n\tunsigned long init_status;\n\n\tunsigned long status;\n\n\tu32 queue_sync_cookie;\n\tunsigned long queue_sync_state;\n\t \n\tstruct iwl_mvm_vif *bf_allowed_vif;\n\n\tbool hw_registered;\n\tbool rfkill_safe_init_done;\n\n\tu8 cca_40mhz_workaround;\n\n\tu32 ampdu_ref;\n\tbool ampdu_toggle;\n\n\tstruct iwl_notif_wait_data notif_wait;\n\n\tunion {\n\t\tstruct mvm_statistics_rx_v3 rx_stats_v3;\n\t\tstruct mvm_statistics_rx rx_stats;\n\t};\n\n\tstruct {\n\t\tu64 rx_time;\n\t\tu64 tx_time;\n\t\tu64 on_time_rf;\n\t\tu64 on_time_scan;\n\t} radio_stats, accu_radio_stats;\n\n\tstruct list_head add_stream_txqs;\n\tunion {\n\t\tstruct iwl_mvm_dqa_txq_info queue_info[IWL_MAX_HW_QUEUES];\n\t\tstruct iwl_mvm_tvqm_txq_info tvqm_info[IWL_MAX_TVQM_QUEUES];\n\t};\n\tstruct work_struct add_stream_wk;  \n\tspinlock_t add_stream_lock;\n\n\tconst char *nvm_file_name;\n\tstruct iwl_nvm_data *nvm_data;\n\tstruct iwl_mei_nvm *mei_nvm_data;\n\tstruct iwl_mvm_csme_conn_info __rcu *csme_conn_info;\n\tbool mei_rfkill_blocked;\n\tbool mei_registered;\n\tstruct work_struct sap_connected_wk;\n\n\t \n\tstruct iwl_nvm_data *temp_nvm_data;\n\n\t \n\tstruct iwl_nvm_section nvm_sections[NVM_MAX_NUM_SECTIONS];\n\n\tstruct iwl_fw_runtime fwrt;\n\n\t \n\tstruct mac_address addresses[IWL_MVM_MAX_ADDRESSES];\n\n\t \n\tstruct iwl_rx_phy_info last_phy_info;\n\tstruct ieee80211_sta __rcu *fw_id_to_mac_id[IWL_MVM_STATION_COUNT_MAX];\n\tstruct ieee80211_link_sta __rcu *fw_id_to_link_sta[IWL_MVM_STATION_COUNT_MAX];\n\tunsigned long fw_link_ids_map;\n\tu8 rx_ba_sessions;\n\n\t \n\tu32 rts_threshold;\n\n\t \n\tunsigned int scan_status;\n\tsize_t scan_cmd_size;\n\tvoid *scan_cmd;\n\tstruct iwl_mcast_filter_cmd *mcast_filter_cmd;\n\t \n\tenum iwl_mvm_scan_type scan_type;\n\tenum iwl_mvm_scan_type hb_scan_type;\n\n\tenum iwl_mvm_sched_scan_pass_all_states sched_scan_pass_all;\n\tstruct delayed_work scan_timeout_dwork;\n\n\t \n\tunsigned int max_scans;\n\n\t \n\tu32 scan_uid_status[IWL_MVM_MAX_UMAC_SCANS];\n\n\t \n\tu64 scan_start;\n\n\t \n\tstruct iwl_mvm_vif *scan_vif;\n\n\t \n\tu8 scan_rx_ant;\n\n\t \n\tstruct iwl_mvm_int_sta aux_sta;\n\tstruct iwl_mvm_int_sta snif_sta;\n\n\tbool last_ebs_successful;\n\n\tu8 scan_last_antenna_idx;  \n\tu8 mgmt_last_antenna_idx;\n\n\t \n\tenum iwl_sf_state sf_state;\n\n\t \n\tstruct dentry *debugfs_dir;\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tu32 dbgfs_sram_offset, dbgfs_sram_len;\n\tu32 dbgfs_prph_reg_addr;\n\tbool disable_power_off;\n\tbool disable_power_off_d3;\n\tbool beacon_inject_active;\n\n\tbool scan_iter_notif_enabled;\n\n\tstruct debugfs_blob_wrapper nvm_hw_blob;\n\tstruct debugfs_blob_wrapper nvm_sw_blob;\n\tstruct debugfs_blob_wrapper nvm_calib_blob;\n\tstruct debugfs_blob_wrapper nvm_prod_blob;\n\tstruct debugfs_blob_wrapper nvm_phy_sku_blob;\n\tstruct debugfs_blob_wrapper nvm_reg_blob;\n\n\tstruct iwl_mvm_frame_stats drv_rx_stats;\n\tspinlock_t drv_stats_lock;\n\tu16 dbgfs_rx_phyinfo;\n#endif\n\n\tstruct iwl_mvm_phy_ctxt phy_ctxts[NUM_PHY_CTX];\n\n\tstruct list_head time_event_list;\n\tspinlock_t time_event_lock;\n\n\t \n\tunsigned long fw_key_table[BITS_TO_LONGS(STA_KEY_MAX_NUM)];\n\tu8 fw_key_deleted[STA_KEY_MAX_NUM];\n\n\tstruct ieee80211_vif __rcu *vif_id_to_mac[NUM_MAC_INDEX_DRIVER];\n\n\tstruct ieee80211_bss_conf __rcu *link_id_to_link_conf[IWL_MVM_FW_MAX_LINK_ID + 1];\n\n\t \n\ts8 fw_restart;\n\tu8 *error_recovery_buf;\n\n#ifdef CONFIG_IWLWIFI_LEDS\n\tstruct led_classdev led;\n#endif\n\n\tstruct ieee80211_vif *p2p_device_vif;\n\n#ifdef CONFIG_PM\n\tstruct wiphy_wowlan_support wowlan;\n\tint gtk_ivlen, gtk_icvlen, ptk_ivlen, ptk_icvlen;\n\n\t \n\tstruct ieee80211_scan_ies nd_ies;\n\tstruct cfg80211_match_set *nd_match_sets;\n\tint n_nd_match_sets;\n\tstruct ieee80211_channel **nd_channels;\n\tint n_nd_channels;\n\tbool net_detect;\n\tu8 offload_tid;\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tbool d3_wake_sysassert;\n\tbool d3_test_active;\n\tu32 d3_test_pme_ptr;\n\tstruct ieee80211_vif *keep_vif;\n\tu32 last_netdetect_scans;  \n#endif\n#endif\n\n\twait_queue_head_t rx_sync_waitq;\n\n\t \n\tstruct iwl_bt_coex_profile_notif last_bt_notif;\n\tstruct iwl_bt_coex_ci_cmd last_bt_ci_cmd;\n\n\tu8 bt_tx_prio;\n\tenum iwl_bt_force_ant_mode bt_force_ant_mode;\n\n\t \n\tstruct list_head aux_roc_te_list;\n\n\t \n\tstruct iwl_mvm_tt_mgmt thermal_throttle;\n#ifdef CONFIG_THERMAL\n\tstruct iwl_mvm_thermal_device tz_device;\n\tstruct iwl_mvm_cooling_device cooling_dev;\n#endif\n\n\ts32 temperature;\t \n\t \n\tbool temperature_test;   \n\n\tbool fw_static_smps_request;\n\n\tunsigned long bt_coex_last_tcm_ts;\n\tstruct iwl_mvm_tcm tcm;\n\n\tu8 uapsd_noagg_bssid_write_idx;\n\tstruct mac_address uapsd_noagg_bssids[IWL_MVM_UAPSD_NOAGG_BSSIDS_NUM]\n\t\t__aligned(2);\n\n\tstruct iwl_time_quota_cmd last_quota_cmd;\n\n#ifdef CONFIG_NL80211_TESTMODE\n\tu32 noa_duration;\n\tstruct ieee80211_vif *noa_vif;\n#endif\n\n\t \n\tu16 aux_queue;\n\tu16 snif_queue;\n\tu16 probe_queue;\n\tu16 p2p_dev_queue;\n\n\t \n\tu8 ps_disabled;  \n\t \n\tu32 ext_clock_valid;\n\n\t \n\tstruct ieee80211_vif *csme_vif;\n\tstruct ieee80211_vif __rcu *csa_vif;\n\tstruct ieee80211_vif __rcu *csa_tx_blocked_vif;\n\tu8 csa_tx_block_bcn_timeout;\n\n\t \n\tu32 ap_last_beacon_gp2;\n\n\t \n\tbool ibss_manager;\n\n\tbool lar_regdom_set;\n\tenum iwl_mcc_source mcc_src;\n\n\t \n\tstruct {\n\t\tstruct delayed_work dwork;\n\t\tenum iwl_mvm_tdls_cs_state state;\n\n\t\t \n\t\tu8 cur_sta_id;\n\n\t\t \n\t\tstruct {\n\t\t\tu8 sta_id;\n\t\t\tu8 op_class;\n\t\t\tbool initiator;  \n\t\t\tstruct cfg80211_chan_def chandef;\n\t\t\tstruct sk_buff *skb;  \n\t\t\tu32 ch_sw_tm_ie;\n\n\t\t\t \n\t\t\tu32 sent_timestamp;\n\t\t} peer;\n\t} tdls_cs;\n\n\n\tu32 ciphers[IWL_MVM_NUM_CIPHERS];\n\n\tstruct cfg80211_ftm_responder_stats ftm_resp_stats;\n\tstruct {\n\t\tstruct cfg80211_pmsr_request *req;\n\t\tstruct wireless_dev *req_wdev;\n\t\tstruct list_head loc_list;\n\t\tint responses[IWL_MVM_TOF_MAX_APS];\n\t\tstruct {\n\t\t\tstruct list_head resp;\n\t\t} smooth;\n\t\tstruct list_head pasn_list;\n\t} ftm_initiator;\n\n\tstruct list_head resp_pasn_list;\n\n\tstruct ptp_data ptp_data;\n\n\tstruct {\n\t\tu8 range_resp;\n\t} cmd_ver;\n\n\tstruct ieee80211_vif *nan_vif;\n\tstruct iwl_mvm_baid_data __rcu *baid_map[IWL_MAX_BAID];\n\n\t \n\tbool drop_bcn_ap_mode;\n\n\tstruct delayed_work cs_tx_unblock_dwork;\n\n\t \n\tbool monitor_on;\n\t \n\tu8 monitor_p80;\n\n\t \n\t__le16 cur_aid;\n\tu8 cur_bssid[ETH_ALEN];\n\n#ifdef CONFIG_ACPI\n\tstruct iwl_phy_specific_cfg phy_filters;\n#endif\n\n\tunsigned long last_6ghz_passive_scan_jiffies;\n\tunsigned long last_reset_or_resume_time_jiffies;\n\n\tbool sta_remove_requires_queue_remove;\n\tbool mld_api_is_used;\n\n\tbool pldr_sync;\n\n\tstruct iwl_time_sync_data time_sync;\n\n\tstruct iwl_mei_scan_filter mei_scan_filter;\n};\n\n \n#define IWL_OP_MODE_GET_MVM(_iwl_op_mode)\t\t\\\n\t((struct iwl_mvm *)(_iwl_op_mode)->op_mode_specific)\n\n#define IWL_MAC80211_GET_MVM(_hw)\t\t\t\\\n\tIWL_OP_MODE_GET_MVM((struct iwl_op_mode *)((_hw)->priv))\n\n \nenum iwl_mvm_status {\n\tIWL_MVM_STATUS_HW_RFKILL,\n\tIWL_MVM_STATUS_HW_CTKILL,\n\tIWL_MVM_STATUS_ROC_RUNNING,\n\tIWL_MVM_STATUS_HW_RESTART_REQUESTED,\n\tIWL_MVM_STATUS_IN_HW_RESTART,\n\tIWL_MVM_STATUS_ROC_AUX_RUNNING,\n\tIWL_MVM_STATUS_FIRMWARE_RUNNING,\n\tIWL_MVM_STATUS_NEED_FLUSH_P2P,\n\tIWL_MVM_STATUS_IN_D3,\n\tIWL_MVM_STATUS_SUPPRESS_ERROR_LOG_ONCE,\n\tIWL_MVM_STATUS_STARTING,\n};\n\nstruct iwl_mvm_csme_conn_info {\n\tstruct rcu_head rcu_head;\n\tstruct iwl_mei_conn_info conn_info;\n};\n\n \nenum iwl_mvm_init_status {\n\tIWL_MVM_INIT_STATUS_THERMAL_INIT_COMPLETE = BIT(0),\n\tIWL_MVM_INIT_STATUS_LEDS_INIT_COMPLETE = BIT(1),\n};\n\nstatic inline bool iwl_mvm_is_radio_killed(struct iwl_mvm *mvm)\n{\n\treturn test_bit(IWL_MVM_STATUS_HW_RFKILL, &mvm->status) ||\n\t       test_bit(IWL_MVM_STATUS_HW_CTKILL, &mvm->status);\n}\n\nstatic inline bool iwl_mvm_is_radio_hw_killed(struct iwl_mvm *mvm)\n{\n\treturn test_bit(IWL_MVM_STATUS_HW_RFKILL, &mvm->status);\n}\n\nstatic inline bool iwl_mvm_firmware_running(struct iwl_mvm *mvm)\n{\n\treturn test_bit(IWL_MVM_STATUS_FIRMWARE_RUNNING, &mvm->status);\n}\n\n \nstatic inline struct iwl_mvm_sta *\niwl_mvm_sta_from_staid_rcu(struct iwl_mvm *mvm, u8 sta_id)\n{\n\tstruct ieee80211_sta *sta;\n\n\tif (sta_id >= mvm->fw->ucode_capa.num_stations)\n\t\treturn NULL;\n\n\tsta = rcu_dereference(mvm->fw_id_to_mac_id[sta_id]);\n\n\t \n\tif (IS_ERR_OR_NULL(sta))\n\t\treturn NULL;\n\n\treturn iwl_mvm_sta_from_mac80211(sta);\n}\n\nstatic inline struct iwl_mvm_sta *\niwl_mvm_sta_from_staid_protected(struct iwl_mvm *mvm, u8 sta_id)\n{\n\tstruct ieee80211_sta *sta;\n\n\tif (sta_id >= mvm->fw->ucode_capa.num_stations)\n\t\treturn NULL;\n\n\tsta = rcu_dereference_protected(mvm->fw_id_to_mac_id[sta_id],\n\t\t\t\t\tlockdep_is_held(&mvm->mutex));\n\n\t \n\tif (IS_ERR_OR_NULL(sta))\n\t\treturn NULL;\n\n\treturn iwl_mvm_sta_from_mac80211(sta);\n}\n\nstatic inline struct ieee80211_vif *\niwl_mvm_rcu_dereference_vif_id(struct iwl_mvm *mvm, u8 vif_id, bool rcu)\n{\n\tif (WARN_ON(vif_id >= ARRAY_SIZE(mvm->vif_id_to_mac)))\n\t\treturn NULL;\n\n\tif (rcu)\n\t\treturn rcu_dereference(mvm->vif_id_to_mac[vif_id]);\n\n\treturn rcu_dereference_protected(mvm->vif_id_to_mac[vif_id],\n\t\t\t\t\t lockdep_is_held(&mvm->mutex));\n}\n\nstatic inline struct ieee80211_bss_conf *\niwl_mvm_rcu_fw_link_id_to_link_conf(struct iwl_mvm *mvm, u8 link_id, bool rcu)\n{\n\tif (WARN_ON(link_id >= ARRAY_SIZE(mvm->link_id_to_link_conf)))\n\t\treturn NULL;\n\n\tif (rcu)\n\t\treturn rcu_dereference(mvm->link_id_to_link_conf[link_id]);\n\n\treturn rcu_dereference_protected(mvm->link_id_to_link_conf[link_id],\n\t\t\t\t\t lockdep_is_held(&mvm->mutex));\n}\n\nstatic inline bool iwl_mvm_is_adaptive_dwell_supported(struct iwl_mvm *mvm)\n{\n\treturn fw_has_api(&mvm->fw->ucode_capa,\n\t\t\t  IWL_UCODE_TLV_API_ADAPTIVE_DWELL);\n}\n\nstatic inline bool iwl_mvm_is_adaptive_dwell_v2_supported(struct iwl_mvm *mvm)\n{\n\treturn fw_has_api(&mvm->fw->ucode_capa,\n\t\t\t  IWL_UCODE_TLV_API_ADAPTIVE_DWELL_V2);\n}\n\nstatic inline bool iwl_mvm_is_adwell_hb_ap_num_supported(struct iwl_mvm *mvm)\n{\n\treturn fw_has_api(&mvm->fw->ucode_capa,\n\t\t\t  IWL_UCODE_TLV_API_ADWELL_HB_DEF_N_AP);\n}\n\nstatic inline bool iwl_mvm_is_oce_supported(struct iwl_mvm *mvm)\n{\n\t \n\treturn fw_has_api(&mvm->fw->ucode_capa, IWL_UCODE_TLV_API_OCE);\n}\n\nstatic inline bool iwl_mvm_is_frag_ebs_supported(struct iwl_mvm *mvm)\n{\n\treturn fw_has_api(&mvm->fw->ucode_capa, IWL_UCODE_TLV_API_FRAG_EBS);\n}\n\nstatic inline bool iwl_mvm_is_short_beacon_notif_supported(struct iwl_mvm *mvm)\n{\n\treturn fw_has_api(&mvm->fw->ucode_capa,\n\t\t\t  IWL_UCODE_TLV_API_SHORT_BEACON_NOTIF);\n}\n\nstatic inline bool iwl_mvm_is_dqa_data_queue(struct iwl_mvm *mvm, u8 queue)\n{\n\treturn (queue >= IWL_MVM_DQA_MIN_DATA_QUEUE) &&\n\t       (queue <= IWL_MVM_DQA_MAX_DATA_QUEUE);\n}\n\nstatic inline bool iwl_mvm_is_dqa_mgmt_queue(struct iwl_mvm *mvm, u8 queue)\n{\n\treturn (queue >= IWL_MVM_DQA_MIN_MGMT_QUEUE) &&\n\t       (queue <= IWL_MVM_DQA_MAX_MGMT_QUEUE);\n}\n\nstatic inline bool iwl_mvm_is_lar_supported(struct iwl_mvm *mvm)\n{\n\tbool nvm_lar = mvm->nvm_data->lar_enabled;\n\tbool tlv_lar = fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t\t   IWL_UCODE_TLV_CAPA_LAR_SUPPORT);\n\n\t \n\tif (mvm->cfg->nvm_type == IWL_NVM_EXT)\n\t\treturn nvm_lar && tlv_lar;\n\telse\n\t\treturn tlv_lar;\n}\n\nstatic inline bool iwl_mvm_is_wifi_mcc_supported(struct iwl_mvm *mvm)\n{\n\treturn fw_has_api(&mvm->fw->ucode_capa,\n\t\t\t  IWL_UCODE_TLV_API_WIFI_MCC_UPDATE) ||\n\t       fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t   IWL_UCODE_TLV_CAPA_LAR_MULTI_MCC);\n}\n\nstatic inline bool iwl_mvm_bt_is_rrc_supported(struct iwl_mvm *mvm)\n{\n\treturn fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t   IWL_UCODE_TLV_CAPA_BT_COEX_RRC) &&\n\t\tIWL_MVM_BT_COEX_RRC;\n}\n\nstatic inline bool iwl_mvm_is_csum_supported(struct iwl_mvm *mvm)\n{\n\treturn fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t   IWL_UCODE_TLV_CAPA_CSUM_SUPPORT) &&\n\t\t!IWL_MVM_HW_CSUM_DISABLE;\n}\n\nstatic inline bool iwl_mvm_is_mplut_supported(struct iwl_mvm *mvm)\n{\n\treturn fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t   IWL_UCODE_TLV_CAPA_BT_MPLUT_SUPPORT) &&\n\t\tIWL_MVM_BT_COEX_MPLUT;\n}\n\nstatic inline\nbool iwl_mvm_is_p2p_scm_uapsd_supported(struct iwl_mvm *mvm)\n{\n\treturn fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t   IWL_UCODE_TLV_CAPA_P2P_SCM_UAPSD) &&\n\t\t!(iwlwifi_mod_params.uapsd_disable &\n\t\t  IWL_DISABLE_UAPSD_P2P_CLIENT);\n}\n\nstatic inline bool iwl_mvm_has_new_rx_api(struct iwl_mvm *mvm)\n{\n\treturn fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t   IWL_UCODE_TLV_CAPA_MULTI_QUEUE_RX_SUPPORT);\n}\n\nstatic inline bool iwl_mvm_has_mld_api(const struct iwl_fw *fw)\n{\n\treturn fw_has_capa(&fw->ucode_capa,\n\t\t\t   IWL_UCODE_TLV_CAPA_MLD_API_SUPPORT);\n}\n\nstatic inline bool iwl_mvm_has_new_station_api(const struct iwl_fw *fw)\n{\n\treturn iwl_mvm_has_mld_api(fw) ||\n\t       iwl_fw_lookup_cmd_ver(fw, ADD_STA, 0) >= 12;\n}\n\nstatic inline bool iwl_mvm_has_new_tx_api(struct iwl_mvm *mvm)\n{\n\t \n\treturn mvm->trans->trans_cfg->gen2;\n}\n\nstatic inline bool iwl_mvm_has_unified_ucode(struct iwl_mvm *mvm)\n{\n\t \n\treturn mvm->trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_22000;\n}\n\nstatic inline bool iwl_mvm_is_cdb_supported(struct iwl_mvm *mvm)\n{\n\t \n\treturn fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t   IWL_UCODE_TLV_CAPA_CDB_SUPPORT);\n}\n\nstatic inline bool iwl_mvm_cdb_scan_api(struct iwl_mvm *mvm)\n{\n\t \n\treturn mvm->trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_22000;\n}\n\nstatic inline bool iwl_mvm_is_scan_ext_chan_supported(struct iwl_mvm *mvm)\n{\n\treturn fw_has_api(&mvm->fw->ucode_capa,\n\t\t\t  IWL_UCODE_TLV_API_SCAN_EXT_CHAN_VER);\n}\n\n\nstatic inline bool iwl_mvm_is_reduced_config_scan_supported(struct iwl_mvm *mvm)\n{\n\treturn fw_has_api(&mvm->fw->ucode_capa,\n\t\t\t  IWL_UCODE_TLV_API_REDUCED_SCAN_CONFIG);\n}\n\nstatic inline bool iwl_mvm_is_band_in_rx_supported(struct iwl_mvm *mvm)\n{\n\treturn fw_has_api(&mvm->fw->ucode_capa,\n\t\t\t   IWL_UCODE_TLV_API_BAND_IN_RX_DATA);\n}\n\nstatic inline bool iwl_mvm_has_new_rx_stats_api(struct iwl_mvm *mvm)\n{\n\treturn fw_has_api(&mvm->fw->ucode_capa,\n\t\t\t  IWL_UCODE_TLV_API_NEW_RX_STATS);\n}\n\nstatic inline bool iwl_mvm_has_quota_low_latency(struct iwl_mvm *mvm)\n{\n\treturn fw_has_api(&mvm->fw->ucode_capa,\n\t\t\t  IWL_UCODE_TLV_API_QUOTA_LOW_LATENCY);\n}\n\nstatic inline bool iwl_mvm_has_tlc_offload(const struct iwl_mvm *mvm)\n{\n\treturn fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t   IWL_UCODE_TLV_CAPA_TLC_OFFLOAD);\n}\n\nstatic inline struct agg_tx_status *\niwl_mvm_get_agg_status(struct iwl_mvm *mvm, void *tx_resp)\n{\n\tif (iwl_mvm_has_new_tx_api(mvm))\n\t\treturn &((struct iwl_mvm_tx_resp *)tx_resp)->status;\n\telse\n\t\treturn ((struct iwl_mvm_tx_resp_v3 *)tx_resp)->status;\n}\n\nstatic inline bool iwl_mvm_is_tt_in_fw(struct iwl_mvm *mvm)\n{\n\t \n\treturn fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t   IWL_UCODE_TLV_CAPA_CT_KILL_BY_FW) &&\n\t       fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t   IWL_UCODE_TLV_CAPA_TEMP_THS_REPORT_SUPPORT);\n}\n\nstatic inline bool iwl_mvm_is_ctdp_supported(struct iwl_mvm *mvm)\n{\n\treturn fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t   IWL_UCODE_TLV_CAPA_CTDP_SUPPORT);\n}\n\nstatic inline bool iwl_mvm_is_esr_supported(struct iwl_trans *trans)\n{\n\tif ((CSR_HW_RFID_TYPE(trans->hw_rf_id) == IWL_CFG_RF_TYPE_FM) &&\n\t    !CSR_HW_RFID_IS_CDB(trans->hw_rf_id))\n\t\t \n\t\treturn CSR_HW_RFID_STEP(trans->hw_rf_id);\n\n\treturn false;\n}\n\nstatic inline int iwl_mvm_max_active_links(struct iwl_mvm *mvm,\n\t\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct iwl_trans *trans = mvm->fwrt.trans;\n\n\tif (vif->type == NL80211_IFTYPE_AP)\n\t\treturn mvm->fw->ucode_capa.num_beacons;\n\n\tif (iwl_mvm_is_esr_supported(trans) ||\n\t    (CSR_HW_RFID_TYPE(trans->hw_rf_id) == IWL_CFG_RF_TYPE_FM &&\n\t     CSR_HW_RFID_IS_CDB(trans->hw_rf_id)))\n\t\treturn IWL_MVM_FW_MAX_ACTIVE_LINKS_NUM;\n\n\treturn 1;\n}\n\nextern const u8 iwl_mvm_ac_to_tx_fifo[];\nextern const u8 iwl_mvm_ac_to_gen2_tx_fifo[];\n\nstatic inline u8 iwl_mvm_mac_ac_to_tx_fifo(struct iwl_mvm *mvm,\n\t\t\t\t\t   enum ieee80211_ac_numbers ac)\n{\n\treturn iwl_mvm_has_new_tx_api(mvm) ?\n\t\tiwl_mvm_ac_to_gen2_tx_fifo[ac] : iwl_mvm_ac_to_tx_fifo[ac];\n}\n\nstruct iwl_rate_info {\n\tu8 plcp;\t \n\tu8 plcp_siso;\t \n\tu8 plcp_mimo2;\t \n\tu8 plcp_mimo3;   \n\tu8 ieee;\t \n};\n\nvoid __iwl_mvm_mac_stop(struct iwl_mvm *mvm);\nint __iwl_mvm_mac_start(struct iwl_mvm *mvm);\n\n \n \nint iwl_run_init_mvm_ucode(struct iwl_mvm *mvm);\n\n \nint iwl_mvm_legacy_hw_idx_to_mac80211_idx(u32 rate_n_flags,\n\t\t\t\t\t  enum nl80211_band band);\nint iwl_mvm_legacy_rate_to_mac80211_idx(u32 rate_n_flags,\n\t\t\t\t\tenum nl80211_band band);\nvoid iwl_mvm_hwrate_to_tx_rate(u32 rate_n_flags,\n\t\t\t       enum nl80211_band band,\n\t\t\t       struct ieee80211_tx_rate *r);\nvoid iwl_mvm_hwrate_to_tx_rate_v1(u32 rate_n_flags,\n\t\t\t\t  enum nl80211_band band,\n\t\t\t\t  struct ieee80211_tx_rate *r);\nu8 iwl_mvm_mac80211_idx_to_hwrate(const struct iwl_fw *fw, int rate_idx);\nu8 iwl_mvm_mac80211_ac_to_ucode_ac(enum ieee80211_ac_numbers ac);\nbool iwl_mvm_is_nic_ack_enabled(struct iwl_mvm *mvm, struct ieee80211_vif *vif);\n\nstatic inline void iwl_mvm_dump_nic_error_log(struct iwl_mvm *mvm)\n{\n\tiwl_fwrt_dump_error_logs(&mvm->fwrt);\n}\n\nu8 first_antenna(u8 mask);\nu8 iwl_mvm_next_antenna(struct iwl_mvm *mvm, u8 valid, u8 last_idx);\nvoid iwl_mvm_get_sync_time(struct iwl_mvm *mvm, int clock_type, u32 *gp2,\n\t\t\t   u64 *boottime, ktime_t *realtime);\nu32 iwl_mvm_get_systime(struct iwl_mvm *mvm);\n\n \nint __must_check iwl_mvm_send_cmd(struct iwl_mvm *mvm,\n\t\t\t\t  struct iwl_host_cmd *cmd);\nint __must_check iwl_mvm_send_cmd_pdu(struct iwl_mvm *mvm, u32 id,\n\t\t\t\t      u32 flags, u16 len, const void *data);\nint __must_check iwl_mvm_send_cmd_status(struct iwl_mvm *mvm,\n\t\t\t\t\t struct iwl_host_cmd *cmd,\n\t\t\t\t\t u32 *status);\nint __must_check iwl_mvm_send_cmd_pdu_status(struct iwl_mvm *mvm, u32 id,\n\t\t\t\t\t     u16 len, const void *data,\n\t\t\t\t\t     u32 *status);\nint iwl_mvm_tx_skb_sta(struct iwl_mvm *mvm, struct sk_buff *skb,\n\t\t       struct ieee80211_sta *sta);\nint iwl_mvm_tx_skb_non_sta(struct iwl_mvm *mvm, struct sk_buff *skb);\nvoid iwl_mvm_set_tx_cmd(struct iwl_mvm *mvm, struct sk_buff *skb,\n\t\t\tstruct iwl_tx_cmd *tx_cmd,\n\t\t\tstruct ieee80211_tx_info *info, u8 sta_id);\nvoid iwl_mvm_set_tx_cmd_rate(struct iwl_mvm *mvm, struct iwl_tx_cmd *tx_cmd,\n\t\t\t    struct ieee80211_tx_info *info,\n\t\t\t    struct ieee80211_sta *sta, __le16 fc);\nvoid iwl_mvm_mac_itxq_xmit(struct ieee80211_hw *hw, struct ieee80211_txq *txq);\nunsigned int iwl_mvm_max_amsdu_size(struct iwl_mvm *mvm,\n\t\t\t\t    struct ieee80211_sta *sta,\n\t\t\t\t    unsigned int tid);\n\n#ifdef CONFIG_IWLWIFI_DEBUG\nconst char *iwl_mvm_get_tx_fail_reason(u32 status);\n#else\nstatic inline const char *iwl_mvm_get_tx_fail_reason(u32 status) { return \"\"; }\n#endif\nint iwl_mvm_flush_tx_path(struct iwl_mvm *mvm, u32 tfd_msk);\nint iwl_mvm_flush_sta(struct iwl_mvm *mvm, u32 sta_id, u32 tfd_queue_mask);\nint iwl_mvm_flush_sta_tids(struct iwl_mvm *mvm, u32 sta_id, u16 tids);\n\n \n__le32 iwl_mvm_get_sta_htc_flags(struct ieee80211_sta *sta,\n\t\t\t\t struct ieee80211_link_sta *link_sta);\nu8 iwl_mvm_get_sta_uapsd_acs(struct ieee80211_sta *sta);\nu32 iwl_mvm_get_sta_ampdu_dens(struct ieee80211_link_sta *link_sta,\n\t\t\t       struct ieee80211_bss_conf *link_conf,\n\t\t\t       u32 *_agg_size);\nint iwl_mvm_set_sta_pkt_ext(struct iwl_mvm *mvm,\n\t\t\t    struct ieee80211_link_sta *link_sta,\n\t\t\t    struct iwl_he_pkt_ext_v2 *pkt_ext);\n\nvoid iwl_mvm_async_handlers_purge(struct iwl_mvm *mvm);\n\nstatic inline void iwl_mvm_set_tx_cmd_ccmp(struct ieee80211_tx_info *info,\n\t\t\t\t\t   struct iwl_tx_cmd *tx_cmd)\n{\n\tstruct ieee80211_key_conf *keyconf = info->control.hw_key;\n\n\ttx_cmd->sec_ctl = TX_CMD_SEC_CCM;\n\tmemcpy(tx_cmd->key, keyconf->key, keyconf->keylen);\n}\n\nstatic inline void iwl_mvm_wait_for_async_handlers(struct iwl_mvm *mvm)\n{\n\tflush_work(&mvm->async_handlers_wk);\n}\n\n \nvoid iwl_mvm_handle_rx_statistics(struct iwl_mvm *mvm,\n\t\t\t\t  struct iwl_rx_packet *pkt);\nvoid iwl_mvm_rx_statistics(struct iwl_mvm *mvm,\n\t\t\t   struct iwl_rx_cmd_buffer *rxb);\nint iwl_mvm_request_statistics(struct iwl_mvm *mvm, bool clear);\nvoid iwl_mvm_accu_radio_stats(struct iwl_mvm *mvm);\n\n \nint iwl_nvm_init(struct iwl_mvm *mvm);\nint iwl_mvm_load_nvm_to_nic(struct iwl_mvm *mvm);\n\nstatic inline u8 iwl_mvm_get_valid_tx_ant(struct iwl_mvm *mvm)\n{\n\treturn mvm->nvm_data && mvm->nvm_data->valid_tx_ant ?\n\t       mvm->fw->valid_tx_ant & mvm->nvm_data->valid_tx_ant :\n\t       mvm->fw->valid_tx_ant;\n}\n\nstatic inline u8 iwl_mvm_get_valid_rx_ant(struct iwl_mvm *mvm)\n{\n\treturn mvm->nvm_data && mvm->nvm_data->valid_rx_ant ?\n\t       mvm->fw->valid_rx_ant & mvm->nvm_data->valid_rx_ant :\n\t       mvm->fw->valid_rx_ant;\n}\n\nstatic inline void iwl_mvm_toggle_tx_ant(struct iwl_mvm *mvm, u8 *ant)\n{\n\t*ant = iwl_mvm_next_antenna(mvm, iwl_mvm_get_valid_tx_ant(mvm), *ant);\n}\n\nstatic inline u32 iwl_mvm_get_phy_config(struct iwl_mvm *mvm)\n{\n\tu32 phy_config = ~(FW_PHY_CFG_TX_CHAIN |\n\t\t\t   FW_PHY_CFG_RX_CHAIN);\n\tu32 valid_rx_ant = iwl_mvm_get_valid_rx_ant(mvm);\n\tu32 valid_tx_ant = iwl_mvm_get_valid_tx_ant(mvm);\n\n\tphy_config |= valid_tx_ant << FW_PHY_CFG_TX_CHAIN_POS |\n\t\t      valid_rx_ant << FW_PHY_CFG_RX_CHAIN_POS;\n\n\treturn mvm->fw->phy_config & phy_config;\n}\n\nint iwl_mvm_up(struct iwl_mvm *mvm);\nint iwl_mvm_load_d3_fw(struct iwl_mvm *mvm);\n\nint iwl_mvm_mac_setup_register(struct iwl_mvm *mvm);\n\n \nvoid iwl_mvm_rx_mq(struct iwl_op_mode *op_mode,\n\t\t   struct napi_struct *napi,\n\t\t   struct iwl_rx_cmd_buffer *rxb);\nvoid iwl_mvm_rx_rx_phy_cmd(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb);\nvoid iwl_mvm_rx_rx_mpdu(struct iwl_mvm *mvm, struct napi_struct *napi,\n\t\t\tstruct iwl_rx_cmd_buffer *rxb);\nvoid iwl_mvm_rx_mpdu_mq(struct iwl_mvm *mvm, struct napi_struct *napi,\n\t\t\tstruct iwl_rx_cmd_buffer *rxb, int queue);\nvoid iwl_mvm_rx_monitor_no_data(struct iwl_mvm *mvm, struct napi_struct *napi,\n\t\t\t\tstruct iwl_rx_cmd_buffer *rxb, int queue);\nvoid iwl_mvm_rx_frame_release(struct iwl_mvm *mvm, struct napi_struct *napi,\n\t\t\t      struct iwl_rx_cmd_buffer *rxb, int queue);\nvoid iwl_mvm_rx_bar_frame_release(struct iwl_mvm *mvm, struct napi_struct *napi,\n\t\t\t\t  struct iwl_rx_cmd_buffer *rxb, int queue);\nvoid iwl_mvm_rx_queue_notif(struct iwl_mvm *mvm, struct napi_struct *napi,\n\t\t\t    struct iwl_rx_cmd_buffer *rxb, int queue);\nvoid iwl_mvm_rx_tx_cmd(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb);\nvoid iwl_mvm_mfu_assert_dump_notif(struct iwl_mvm *mvm,\n\t\t\t\t   struct iwl_rx_cmd_buffer *rxb);\nvoid iwl_mvm_send_recovery_cmd(struct iwl_mvm *mvm, u32 flags);\nvoid iwl_mvm_rx_ba_notif(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb);\nvoid iwl_mvm_rx_ant_coupling_notif(struct iwl_mvm *mvm,\n\t\t\t\t   struct iwl_rx_cmd_buffer *rxb);\nvoid iwl_mvm_rx_fw_error(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb);\nvoid iwl_mvm_rx_mfuart_notif(struct iwl_mvm *mvm,\n\t\t\t     struct iwl_rx_cmd_buffer *rxb);\nvoid iwl_mvm_rx_shared_mem_cfg_notif(struct iwl_mvm *mvm,\n\t\t\t\t     struct iwl_rx_cmd_buffer *rxb);\n\n \nstruct iwl_mvm_phy_ctxt *iwl_mvm_get_free_phy_ctxt(struct iwl_mvm *mvm);\nint iwl_mvm_phy_ctxt_add(struct iwl_mvm *mvm, struct iwl_mvm_phy_ctxt *ctxt,\n\t\t\t struct cfg80211_chan_def *chandef,\n\t\t\t u8 chains_static, u8 chains_dynamic);\nint iwl_mvm_phy_ctxt_changed(struct iwl_mvm *mvm, struct iwl_mvm_phy_ctxt *ctxt,\n\t\t\t     struct cfg80211_chan_def *chandef,\n\t\t\t     u8 chains_static, u8 chains_dynamic);\nvoid iwl_mvm_phy_ctxt_ref(struct iwl_mvm *mvm,\n\t\t\t  struct iwl_mvm_phy_ctxt *ctxt);\nvoid iwl_mvm_phy_ctxt_unref(struct iwl_mvm *mvm,\n\t\t\t    struct iwl_mvm_phy_ctxt *ctxt);\nint iwl_mvm_phy_ctx_count(struct iwl_mvm *mvm);\nu8 iwl_mvm_get_channel_width(struct cfg80211_chan_def *chandef);\nu8 iwl_mvm_get_ctrl_pos(struct cfg80211_chan_def *chandef);\nint iwl_mvm_phy_send_rlc(struct iwl_mvm *mvm, struct iwl_mvm_phy_ctxt *ctxt,\n\t\t\t u8 chains_static, u8 chains_dynamic);\n\n \n\nvoid iwl_mvm_prepare_mac_removal(struct iwl_mvm *mvm,\n\t\t\t\t struct ieee80211_vif *vif);\nvoid iwl_mvm_set_fw_basic_rates(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_bss_conf *link_conf,\n\t\t\t\t__le32 *cck_rates, __le32 *ofdm_rates);\nvoid iwl_mvm_set_fw_protection_flags(struct iwl_mvm *mvm,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_bss_conf *link_conf,\n\t\t\t\t     __le32 *protection_flags, u32 ht_flag,\n\t\t\t\t     u32 tgg_flag);\nvoid iwl_mvm_set_fw_qos_params(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_bss_conf *link_conf,\n\t\t\t       struct iwl_ac_qos *ac, __le32 *qos_flags);\nbool iwl_mvm_set_fw_mu_edca_params(struct iwl_mvm *mvm,\n\t\t\t\t   const struct iwl_mvm_vif_link_info *link_info,\n\t\t\t\t   struct iwl_he_backoff_conf *trig_based_txf);\nvoid iwl_mvm_set_fw_dtim_tbtt(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_bss_conf *link_conf,\n\t\t\t      __le64 *dtim_tsf, __le32 *dtim_time,\n\t\t\t      __le32 *assoc_beacon_arrive_time);\n__le32 iwl_mac_ctxt_p2p_dev_has_extended_disc(struct iwl_mvm *mvm,\n\t\t\t\t\t      struct ieee80211_vif *vif);\nvoid iwl_mvm_mac_ctxt_cmd_ap_set_filter_flags(struct iwl_mvm *mvm,\n\t\t\t\t\t      struct iwl_mvm_vif *mvmvif,\n\t\t\t\t\t      __le32 *filter_flags,\n\t\t\t\t\t      int accept_probe_req_flag,\n\t\t\t\t\t      int accept_beacon_flag);\nint iwl_mvm_get_mac_type(struct ieee80211_vif *vif);\n__le32 iwl_mvm_mac_ctxt_cmd_p2p_sta_get_oppps_ctwin(struct iwl_mvm *mvm,\n\t\t\t\t\t\t    struct ieee80211_vif *vif);\nu32 iwl_mvm_mac_ctxt_cmd_sta_get_twt_policy(struct iwl_mvm *mvm,\n\t\t\t\t\t    struct ieee80211_vif *vif);\nint iwl_mvm_mld_mac_ctxt_add(struct iwl_mvm *mvm, struct ieee80211_vif *vif);\nint iwl_mvm_mld_mac_ctxt_changed(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t\t bool force_assoc_off);\nint iwl_mvm_mld_mac_ctxt_remove(struct iwl_mvm *mvm, struct ieee80211_vif *vif);\nint iwl_mvm_mac_ctxt_init(struct iwl_mvm *mvm, struct ieee80211_vif *vif);\nint iwl_mvm_mac_ctxt_add(struct iwl_mvm *mvm, struct ieee80211_vif *vif);\nint iwl_mvm_mac_ctxt_changed(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t     bool force_assoc_off, const u8 *bssid_override);\nint iwl_mvm_mac_ctxt_remove(struct iwl_mvm *mvm, struct ieee80211_vif *vif);\nint iwl_mvm_mac_ctxt_beacon_changed(struct iwl_mvm *mvm,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_bss_conf *link_conf);\nint iwl_mvm_mac_ctxt_send_beacon_cmd(struct iwl_mvm *mvm,\n\t\t\t\t     struct sk_buff *beacon,\n\t\t\t\t     void *data, int len);\nu8 iwl_mvm_mac_ctxt_get_beacon_rate(struct iwl_mvm *mvm,\n\t\t\t\t    struct ieee80211_tx_info *info,\n\t\t\t\t    struct ieee80211_vif *vif);\nu8 iwl_mvm_mac_ctxt_get_lowest_rate(struct iwl_mvm *mvm,\n\t\t\t\t    struct ieee80211_tx_info *info,\n\t\t\t\t    struct ieee80211_vif *vif);\nu16 iwl_mvm_mac_ctxt_get_beacon_flags(const struct iwl_fw *fw,\n\t\t\t\t      u8 rate_idx);\nvoid iwl_mvm_mac_ctxt_set_tim(struct iwl_mvm *mvm,\n\t\t\t      __le32 *tim_index, __le32 *tim_size,\n\t\t\t      u8 *beacon, u32 frame_size);\nvoid iwl_mvm_rx_beacon_notif(struct iwl_mvm *mvm,\n\t\t\t     struct iwl_rx_cmd_buffer *rxb);\nvoid iwl_mvm_rx_missed_beacons_notif(struct iwl_mvm *mvm,\n\t\t\t\t     struct iwl_rx_cmd_buffer *rxb);\nvoid iwl_mvm_rx_stored_beacon_notif(struct iwl_mvm *mvm,\n\t\t\t\t    struct iwl_rx_cmd_buffer *rxb);\nvoid iwl_mvm_mu_mimo_grp_notif(struct iwl_mvm *mvm,\n\t\t\t       struct iwl_rx_cmd_buffer *rxb);\nvoid iwl_mvm_sta_pm_notif(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb);\nvoid iwl_mvm_window_status_notif(struct iwl_mvm *mvm,\n\t\t\t\t struct iwl_rx_cmd_buffer *rxb);\nvoid iwl_mvm_mac_ctxt_recalc_tsf_id(struct iwl_mvm *mvm,\n\t\t\t\t    struct ieee80211_vif *vif);\nvoid iwl_mvm_probe_resp_data_notif(struct iwl_mvm *mvm,\n\t\t\t\t   struct iwl_rx_cmd_buffer *rxb);\nvoid iwl_mvm_rx_missed_vap_notif(struct iwl_mvm *mvm,\n\t\t\t\t struct iwl_rx_cmd_buffer *rxb);\nvoid iwl_mvm_channel_switch_start_notif(struct iwl_mvm *mvm,\n\t\t\t\t\tstruct iwl_rx_cmd_buffer *rxb);\nvoid iwl_mvm_channel_switch_error_notif(struct iwl_mvm *mvm,\n\t\t\t\t\tstruct iwl_rx_cmd_buffer *rxb);\n \nint iwl_mvm_binding_add_vif(struct iwl_mvm *mvm, struct ieee80211_vif *vif);\nint iwl_mvm_binding_remove_vif(struct iwl_mvm *mvm, struct ieee80211_vif *vif);\nu32 iwl_mvm_get_lmac_id(struct iwl_mvm *mvm, enum nl80211_band band);\n\n \nint iwl_mvm_add_link(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t     struct ieee80211_bss_conf *link_conf);\nint iwl_mvm_link_changed(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t struct ieee80211_bss_conf *link_conf,\n\t\t\t u32 changes, bool active);\nint iwl_mvm_remove_link(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_bss_conf *link_conf);\nint iwl_mvm_disable_link(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t struct ieee80211_bss_conf *link_conf);\n\n \nbool iwl_mvm_start_ap_ibss_common(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif, int *ret);\nvoid iwl_mvm_stop_ap_ibss_common(struct iwl_mvm *mvm,\n\t\t\t\t struct ieee80211_vif *vif);\n\n \n \nstruct iwl_mvm_bss_info_changed_ops {\n\tvoid (*bss_info_changed_sta)(struct iwl_mvm *mvm,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_bss_conf *bss_conf,\n\t\t\t\t     u64 changes);\n\tvoid (*bss_info_changed_ap_ibss)(struct iwl_mvm *mvm,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t struct ieee80211_bss_conf *bss_conf,\n\t\t\t\t\t u64 changes);\n};\n\nvoid\niwl_mvm_bss_info_changed_common(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_bss_conf *bss_conf,\n\t\t\t\tconst struct iwl_mvm_bss_info_changed_ops *callbacks,\n\t\t\t\tu64 changes);\nvoid\niwl_mvm_bss_info_changed_station_common(struct iwl_mvm *mvm,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tstruct ieee80211_bss_conf *link_conf,\n\t\t\t\t\tu64 changes);\nvoid iwl_mvm_bss_info_changed_station_assoc(struct iwl_mvm *mvm,\n\t\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t\t    u64 changes);\n\n \n \nstruct iwl_mvm_roc_ops {\n\tint (*add_aux_sta_for_hs20)(struct iwl_mvm *mvm, u32 lmac_id);\n\tint (*link)(struct iwl_mvm *mvm, struct ieee80211_vif *vif);\n};\n\nint iwl_mvm_roc_common(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_channel *channel, int duration,\n\t\t       enum ieee80211_roc_type type,\n\t\t       const struct iwl_mvm_roc_ops *ops);\nint iwl_mvm_cancel_roc(struct ieee80211_hw *hw,\n\t\t       struct ieee80211_vif *vif);\n \nvoid iwl_mvm_protect_assoc(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t   u32 duration_override);\n\n \nstatic inline size_t iwl_mvm_quota_cmd_size(struct iwl_mvm *mvm)\n{\n\treturn iwl_mvm_has_quota_low_latency(mvm) ?\n\t\tsizeof(struct iwl_time_quota_cmd) :\n\t\tsizeof(struct iwl_time_quota_cmd_v1);\n}\n\nstatic inline struct iwl_time_quota_data\n*iwl_mvm_quota_cmd_get_quota(struct iwl_mvm *mvm,\n\t\t\t     struct iwl_time_quota_cmd *cmd,\n\t\t\t     int i)\n{\n\tstruct iwl_time_quota_data_v1 *quotas;\n\n\tif (iwl_mvm_has_quota_low_latency(mvm))\n\t\treturn &cmd->quotas[i];\n\n\tquotas = (struct iwl_time_quota_data_v1 *)cmd->quotas;\n\treturn (struct iwl_time_quota_data *)&quotas[i];\n}\n\nint iwl_mvm_update_quotas(struct iwl_mvm *mvm, bool force_upload,\n\t\t\t  struct ieee80211_vif *disabled_vif);\n\n \nint iwl_mvm_reg_scan_start(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t   struct cfg80211_scan_request *req,\n\t\t\t   struct ieee80211_scan_ies *ies);\nsize_t iwl_mvm_scan_size(struct iwl_mvm *mvm);\nint iwl_mvm_scan_stop(struct iwl_mvm *mvm, int type, bool notify);\nint iwl_mvm_max_scan_ie_len(struct iwl_mvm *mvm);\nvoid iwl_mvm_report_scan_aborted(struct iwl_mvm *mvm);\nvoid iwl_mvm_scan_timeout_wk(struct work_struct *work);\n\n \nvoid iwl_mvm_rx_lmac_scan_complete_notif(struct iwl_mvm *mvm,\n\t\t\t\t\t struct iwl_rx_cmd_buffer *rxb);\nvoid iwl_mvm_rx_lmac_scan_iter_complete_notif(struct iwl_mvm *mvm,\n\t\t\t\t\t      struct iwl_rx_cmd_buffer *rxb);\nint iwl_mvm_sched_scan_start(struct iwl_mvm *mvm,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct cfg80211_sched_scan_request *req,\n\t\t\t     struct ieee80211_scan_ies *ies,\n\t\t\t     int type);\nvoid iwl_mvm_rx_scan_match_found(struct iwl_mvm *mvm,\n\t\t\t\t struct iwl_rx_cmd_buffer *rxb);\n\n \nint iwl_mvm_config_scan(struct iwl_mvm *mvm);\nvoid iwl_mvm_rx_umac_scan_complete_notif(struct iwl_mvm *mvm,\n\t\t\t\t\t struct iwl_rx_cmd_buffer *rxb);\nvoid iwl_mvm_rx_umac_scan_iter_complete_notif(struct iwl_mvm *mvm,\n\t\t\t\t\t      struct iwl_rx_cmd_buffer *rxb);\n\n \n#ifdef CONFIG_IWLWIFI_DEBUGFS\nvoid iwl_mvm_dbgfs_register(struct iwl_mvm *mvm);\nvoid iwl_mvm_vif_dbgfs_register(struct iwl_mvm *mvm, struct ieee80211_vif *vif);\nvoid iwl_mvm_vif_dbgfs_clean(struct iwl_mvm *mvm, struct ieee80211_vif *vif);\n#else\nstatic inline void iwl_mvm_dbgfs_register(struct iwl_mvm *mvm)\n{\n}\nstatic inline void\niwl_mvm_vif_dbgfs_register(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n}\nstatic inline void\niwl_mvm_vif_dbgfs_clean(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n}\n#endif  \n\n \nint iwl_mvm_send_lq_cmd(struct iwl_mvm *mvm, struct iwl_lq_cmd *lq);\nvoid iwl_mvm_update_frame_stats(struct iwl_mvm *mvm, u32 rate, bool agg);\nint rs_pretty_print_rate_v1(char *buf, int bufsz, const u32 rate);\nvoid rs_update_last_rssi(struct iwl_mvm *mvm,\n\t\t\t struct iwl_mvm_sta *mvmsta,\n\t\t\t struct ieee80211_rx_status *rx_status);\n\n \nint iwl_mvm_power_update_device(struct iwl_mvm *mvm);\nint iwl_mvm_power_update_mac(struct iwl_mvm *mvm);\nint iwl_mvm_power_update_ps(struct iwl_mvm *mvm);\nint iwl_mvm_power_mac_dbgfs_read(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t\t char *buf, int bufsz);\n\nvoid iwl_mvm_power_vif_assoc(struct iwl_mvm *mvm, struct ieee80211_vif *vif);\nvoid iwl_mvm_power_uapsd_misbehaving_ap_notif(struct iwl_mvm *mvm,\n\t\t\t\t\t      struct iwl_rx_cmd_buffer *rxb);\n\n#ifdef CONFIG_IWLWIFI_LEDS\nint iwl_mvm_leds_init(struct iwl_mvm *mvm);\nvoid iwl_mvm_leds_exit(struct iwl_mvm *mvm);\nvoid iwl_mvm_leds_sync(struct iwl_mvm *mvm);\n#else\nstatic inline int iwl_mvm_leds_init(struct iwl_mvm *mvm)\n{\n\treturn 0;\n}\nstatic inline void iwl_mvm_leds_exit(struct iwl_mvm *mvm)\n{\n}\nstatic inline void iwl_mvm_leds_sync(struct iwl_mvm *mvm)\n{\n}\n#endif\n\n \nint iwl_mvm_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan);\nint iwl_mvm_resume(struct ieee80211_hw *hw);\nvoid iwl_mvm_set_wakeup(struct ieee80211_hw *hw, bool enabled);\nvoid iwl_mvm_set_rekey_data(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct cfg80211_gtk_rekey_data *data);\nvoid iwl_mvm_ipv6_addr_change(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct inet6_dev *idev);\nvoid iwl_mvm_set_default_unicast_key(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif, int idx);\nextern const struct file_operations iwl_dbgfs_d3_test_ops;\n#ifdef CONFIG_PM\nvoid iwl_mvm_set_last_nonqos_seq(struct iwl_mvm *mvm,\n\t\t\t\t struct ieee80211_vif *vif);\n#else\nstatic inline void\niwl_mvm_set_last_nonqos_seq(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n}\n#endif\nvoid iwl_mvm_set_wowlan_qos_seq(struct iwl_mvm_sta *mvm_ap_sta,\n\t\t\t\tstruct iwl_wowlan_config_cmd *cmd);\nint iwl_mvm_send_proto_offload(struct iwl_mvm *mvm,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       bool disable_offloading,\n\t\t\t       bool offload_ns,\n\t\t\t       u32 cmd_flags);\n\n \nint iwl_mvm_send_bt_init_conf(struct iwl_mvm *mvm);\nvoid iwl_mvm_rx_bt_coex_notif(struct iwl_mvm *mvm,\n\t\t\t      struct iwl_rx_cmd_buffer *rxb);\nvoid iwl_mvm_bt_rssi_event(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t   enum ieee80211_rssi_event_data);\nvoid iwl_mvm_bt_coex_vif_change(struct iwl_mvm *mvm);\nu16 iwl_mvm_coex_agg_time_limit(struct iwl_mvm *mvm,\n\t\t\t\tstruct ieee80211_sta *sta);\nbool iwl_mvm_bt_coex_is_mimo_allowed(struct iwl_mvm *mvm,\n\t\t\t\t     struct ieee80211_sta *sta);\nbool iwl_mvm_bt_coex_is_ant_avail(struct iwl_mvm *mvm, u8 ant);\nbool iwl_mvm_bt_coex_is_shared_ant_avail(struct iwl_mvm *mvm);\nbool iwl_mvm_bt_coex_is_tpc_allowed(struct iwl_mvm *mvm,\n\t\t\t\t    enum nl80211_band band);\nu8 iwl_mvm_bt_coex_get_single_ant_msk(struct iwl_mvm *mvm, u8 enabled_ants);\nu8 iwl_mvm_bt_coex_tx_prio(struct iwl_mvm *mvm, struct ieee80211_hdr *hdr,\n\t\t\t   struct ieee80211_tx_info *info, u8 ac);\n\n \n#ifdef CONFIG_IWLWIFI_DEBUGFS\nvoid\niwl_mvm_beacon_filter_debugfs_parameters(struct ieee80211_vif *vif,\n\t\t\t\t\t struct iwl_beacon_filter_cmd *cmd);\n#else\nstatic inline void\niwl_mvm_beacon_filter_debugfs_parameters(struct ieee80211_vif *vif,\n\t\t\t\t\t struct iwl_beacon_filter_cmd *cmd)\n{}\n#endif\nint iwl_mvm_enable_beacon_filter(struct iwl_mvm *mvm,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t u32 flags);\nint iwl_mvm_disable_beacon_filter(struct iwl_mvm *mvm,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  u32 flags);\n \nvoid iwl_mvm_update_smps(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t\tenum iwl_mvm_smps_type_request req_type,\n\t\t\t\tenum ieee80211_smps_mode smps_request,\n\t\t\t\tunsigned int link_id);\nvoid\niwl_mvm_update_smps_on_active_links(struct iwl_mvm *mvm,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    enum iwl_mvm_smps_type_request req_type,\n\t\t\t\t    enum ieee80211_smps_mode smps_request);\nbool iwl_mvm_rx_diversity_allowed(struct iwl_mvm *mvm,\n\t\t\t\t  struct iwl_mvm_phy_ctxt *ctxt);\nvoid iwl_mvm_update_link_smps(struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_bss_conf *link_conf);\n\n \nint iwl_mvm_update_low_latency(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t      bool low_latency,\n\t\t\t      enum iwl_mvm_low_latency_cause cause);\n \nbool iwl_mvm_low_latency(struct iwl_mvm *mvm);\nbool iwl_mvm_low_latency_band(struct iwl_mvm *mvm, enum nl80211_band band);\nvoid iwl_mvm_send_low_latency_cmd(struct iwl_mvm *mvm, bool low_latency,\n\t\t\t\t  u16 mac_id);\n\n \nstatic inline bool iwl_mvm_vif_low_latency(struct iwl_mvm_vif *mvmvif)\n{\n\t \n\treturn mvmvif->low_latency_actual;\n}\n\nstatic inline\nvoid iwl_mvm_vif_set_low_latency(struct iwl_mvm_vif *mvmvif, bool set,\n\t\t\t\t enum iwl_mvm_low_latency_cause cause)\n{\n\tu8 new_state;\n\n\tif (set)\n\t\tmvmvif->low_latency |= cause;\n\telse\n\t\tmvmvif->low_latency &= ~cause;\n\n\t \n\tif (mvmvif->low_latency & LOW_LATENCY_DEBUGFS_FORCE_ENABLE &&\n\t    cause != LOW_LATENCY_DEBUGFS_FORCE_ENABLE)\n\t\treturn;\n\n\tif (cause == LOW_LATENCY_DEBUGFS_FORCE_ENABLE && set)\n\t\t \n\t\tnew_state = !!(mvmvif->low_latency &\n\t\t\t       LOW_LATENCY_DEBUGFS_FORCE);\n\telse\n\t\t \n\t\tnew_state = !!(mvmvif->low_latency &\n\t\t\t\t  ~(LOW_LATENCY_DEBUGFS_FORCE_ENABLE |\n\t\t\t\t    LOW_LATENCY_DEBUGFS_FORCE));\n\n\tmvmvif->low_latency_actual = new_state;\n}\n\n \nstatic inline u32 iwl_mvm_flushable_queues(struct iwl_mvm *mvm)\n{\n\treturn ((BIT(mvm->trans->trans_cfg->base_params->num_of_queues) - 1) &\n\t\t~BIT(IWL_MVM_DQA_CMD_QUEUE));\n}\n\nvoid iwl_mvm_stop_device(struct iwl_mvm *mvm);\n\n \nvoid iwl_mvm_tt_tx_backoff(struct iwl_mvm *mvm, u32 backoff);\nvoid iwl_mvm_temp_notif(struct iwl_mvm *mvm,\n\t\t\tstruct iwl_rx_cmd_buffer *rxb);\nvoid iwl_mvm_tt_handler(struct iwl_mvm *mvm);\nvoid iwl_mvm_thermal_initialize(struct iwl_mvm *mvm, u32 min_backoff);\nvoid iwl_mvm_thermal_exit(struct iwl_mvm *mvm);\nvoid iwl_mvm_set_hw_ctkill_state(struct iwl_mvm *mvm, bool state);\nint iwl_mvm_get_temp(struct iwl_mvm *mvm, s32 *temp);\nvoid iwl_mvm_ct_kill_notif(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb);\nvoid iwl_mvm_enter_ctkill(struct iwl_mvm *mvm);\nint iwl_mvm_send_temp_report_ths_cmd(struct iwl_mvm *mvm);\nint iwl_mvm_ctdp_command(struct iwl_mvm *mvm, u32 op, u32 budget);\n\n#if IS_ENABLED(CONFIG_IWLMEI)\n\n \nvoid iwl_mvm_vendor_cmds_register(struct iwl_mvm *mvm);\n\n#else\n\nstatic inline void iwl_mvm_vendor_cmds_register(struct iwl_mvm *mvm) {}\n\n#endif\n\n \nstruct iwl_mcc_update_resp_v8 *\niwl_mvm_update_mcc(struct iwl_mvm *mvm, const char *alpha2,\n\t\t   enum iwl_mcc_source src_id);\nint iwl_mvm_init_mcc(struct iwl_mvm *mvm);\nvoid iwl_mvm_rx_chub_update_mcc(struct iwl_mvm *mvm,\n\t\t\t\tstruct iwl_rx_cmd_buffer *rxb);\nstruct ieee80211_regdomain *iwl_mvm_get_regdomain(struct wiphy *wiphy,\n\t\t\t\t\t\t  const char *alpha2,\n\t\t\t\t\t\t  enum iwl_mcc_source src_id,\n\t\t\t\t\t\t  bool *changed);\nstruct ieee80211_regdomain *iwl_mvm_get_current_regdomain(struct iwl_mvm *mvm,\n\t\t\t\t\t\t\t  bool *changed);\nint iwl_mvm_init_fw_regd(struct iwl_mvm *mvm);\nvoid iwl_mvm_update_changed_regdom(struct iwl_mvm *mvm);\n\n \nint iwl_mvm_sf_update(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t      bool added_vif);\n\n \nint iwl_mvm_ftm_start_responder(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_bss_conf *bss_conf);\nvoid iwl_mvm_ftm_restart_responder(struct iwl_mvm *mvm,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_bss_conf *bss_conf);\nvoid iwl_mvm_ftm_responder_stats(struct iwl_mvm *mvm,\n\t\t\t\t struct iwl_rx_cmd_buffer *rxb);\nint iwl_mvm_ftm_resp_remove_pasn_sta(struct iwl_mvm *mvm,\n\t\t\t\t     struct ieee80211_vif *vif, u8 *addr);\nint iwl_mvm_ftm_respoder_add_pasn_sta(struct iwl_mvm *mvm,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      u8 *addr, u32 cipher, u8 *tk, u32 tk_len,\n\t\t\t\t      u8 *hltk, u32 hltk_len);\nvoid iwl_mvm_ftm_responder_clear(struct iwl_mvm *mvm,\n\t\t\t\t struct ieee80211_vif *vif);\n\n \nvoid iwl_mvm_ftm_restart(struct iwl_mvm *mvm);\nvoid iwl_mvm_ftm_range_resp(struct iwl_mvm *mvm,\n\t\t\t    struct iwl_rx_cmd_buffer *rxb);\nvoid iwl_mvm_ftm_lc_notif(struct iwl_mvm *mvm,\n\t\t\t  struct iwl_rx_cmd_buffer *rxb);\nint iwl_mvm_ftm_start(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t      struct cfg80211_pmsr_request *request);\nvoid iwl_mvm_ftm_abort(struct iwl_mvm *mvm, struct cfg80211_pmsr_request *req);\nvoid iwl_mvm_ftm_initiator_smooth_config(struct iwl_mvm *mvm);\nvoid iwl_mvm_ftm_initiator_smooth_stop(struct iwl_mvm *mvm);\nint iwl_mvm_ftm_add_pasn_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t     u8 *addr, u32 cipher, u8 *tk, u32 tk_len,\n\t\t\t     u8 *hltk, u32 hltk_len);\nvoid iwl_mvm_ftm_remove_pasn_sta(struct iwl_mvm *mvm, u8 *addr);\n\n \n\n \n#define IWL_MVM_TDLS_FW_TID 4\n\nint iwl_mvm_tdls_sta_count(struct iwl_mvm *mvm, struct ieee80211_vif *vif);\nvoid iwl_mvm_teardown_tdls_peers(struct iwl_mvm *mvm);\nvoid iwl_mvm_recalc_tdls_state(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t       bool sta_added);\nvoid iwl_mvm_mac_mgd_protect_tdls_discover(struct ieee80211_hw *hw,\n\t\t\t\t\t   struct ieee80211_vif *vif);\nint iwl_mvm_tdls_channel_switch(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta, u8 oper_class,\n\t\t\t\tstruct cfg80211_chan_def *chandef,\n\t\t\t\tstruct sk_buff *tmpl_skb, u32 ch_sw_tm_ie);\nvoid iwl_mvm_tdls_recv_channel_switch(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_tdls_ch_sw_params *params);\nvoid iwl_mvm_tdls_cancel_channel_switch(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tstruct ieee80211_sta *sta);\nvoid iwl_mvm_rx_tdls_notif(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb);\nvoid iwl_mvm_tdls_ch_switch_work(struct work_struct *work);\n\nvoid iwl_mvm_sync_rx_queues_internal(struct iwl_mvm *mvm,\n\t\t\t\t     enum iwl_mvm_rxq_notif_type type,\n\t\t\t\t     bool sync,\n\t\t\t\t     const void *data, u32 size);\nvoid iwl_mvm_reorder_timer_expired(struct timer_list *t);\nstruct ieee80211_vif *iwl_mvm_get_bss_vif(struct iwl_mvm *mvm);\nstruct ieee80211_vif *iwl_mvm_get_vif_by_macid(struct iwl_mvm *mvm, u32 macid);\nbool iwl_mvm_is_vif_assoc(struct iwl_mvm *mvm);\n\n#define MVM_TCM_PERIOD_MSEC 500\n#define MVM_TCM_PERIOD (HZ * MVM_TCM_PERIOD_MSEC / 1000)\n#define MVM_LL_PERIOD (10 * HZ)\nvoid iwl_mvm_tcm_work(struct work_struct *work);\nvoid iwl_mvm_recalc_tcm(struct iwl_mvm *mvm);\nvoid iwl_mvm_pause_tcm(struct iwl_mvm *mvm, bool with_cancel);\nvoid iwl_mvm_resume_tcm(struct iwl_mvm *mvm);\nvoid iwl_mvm_tcm_add_vif(struct iwl_mvm *mvm, struct ieee80211_vif *vif);\nvoid iwl_mvm_tcm_rm_vif(struct iwl_mvm *mvm, struct ieee80211_vif *vif);\nu8 iwl_mvm_tcm_load_percentage(u32 airtime, u32 elapsed);\n\nvoid iwl_mvm_nic_restart(struct iwl_mvm *mvm, bool fw_error);\nunsigned int iwl_mvm_get_wd_timeout(struct iwl_mvm *mvm,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    bool tdls, bool cmd_q);\nvoid iwl_mvm_connection_loss(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t     const char *errmsg);\nvoid iwl_mvm_event_frame_timeout_callback(struct iwl_mvm *mvm,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  const struct ieee80211_sta *sta,\n\t\t\t\t\t  u16 tid);\nvoid iwl_mvm_mei_scan_filter_init(struct iwl_mei_scan_filter *mei_scan_filter);\n\nvoid iwl_mvm_ptp_init(struct iwl_mvm *mvm);\nvoid iwl_mvm_ptp_remove(struct iwl_mvm *mvm);\nu64 iwl_mvm_ptp_get_adj_time(struct iwl_mvm *mvm, u64 base_time);\nint iwl_mvm_sar_select_profile(struct iwl_mvm *mvm, int prof_a, int prof_b);\nint iwl_mvm_get_sar_geo_profile(struct iwl_mvm *mvm);\nint iwl_mvm_ppag_send_cmd(struct iwl_mvm *mvm);\nvoid iwl_mvm_get_acpi_tables(struct iwl_mvm *mvm);\n#ifdef CONFIG_IWLWIFI_DEBUGFS\nvoid iwl_mvm_link_sta_add_debugfs(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_link_sta *link_sta,\n\t\t\t\t  struct dentry *dir);\n#endif\n\n \nint iwl_mvm_sec_key_add(struct iwl_mvm *mvm,\n\t\t\tstruct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_sta *sta,\n\t\t\tstruct ieee80211_key_conf *keyconf);\nint iwl_mvm_sec_key_del(struct iwl_mvm *mvm,\n\t\t\tstruct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_sta *sta,\n\t\t\tstruct ieee80211_key_conf *keyconf);\nvoid iwl_mvm_sec_key_remove_ap(struct iwl_mvm *mvm,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct iwl_mvm_vif_link_info *link,\n\t\t\t       unsigned int link_id);\nint iwl_mvm_mld_update_sta_keys(struct iwl_mvm *mvm,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\tu32 old_sta_mask,\n\t\t\t\tu32 new_sta_mask);\nint iwl_mvm_mld_send_key(struct iwl_mvm *mvm, u32 sta_mask, u32 key_flags,\n\t\t\t struct ieee80211_key_conf *keyconf);\nu32 iwl_mvm_get_sec_flags(struct iwl_mvm *mvm,\n\t\t\t  struct ieee80211_vif *vif,\n\t\t\t  struct ieee80211_sta *sta,\n\t\t\t  struct ieee80211_key_conf *keyconf);\n\nbool iwl_rfi_supported(struct iwl_mvm *mvm);\nint iwl_rfi_send_config_cmd(struct iwl_mvm *mvm,\n\t\t\t    struct iwl_rfi_lut_entry *rfi_table);\nstruct iwl_rfi_freq_table_resp_cmd *iwl_rfi_get_freq_table(struct iwl_mvm *mvm);\nvoid iwl_rfi_deactivate_notif_handler(struct iwl_mvm *mvm,\n\t\t\t\t      struct iwl_rx_cmd_buffer *rxb);\n\nstatic inline u8 iwl_mvm_phy_band_from_nl80211(enum nl80211_band band)\n{\n\tswitch (band) {\n\tcase NL80211_BAND_2GHZ:\n\t\treturn PHY_BAND_24;\n\tcase NL80211_BAND_5GHZ:\n\t\treturn PHY_BAND_5;\n\tcase NL80211_BAND_6GHZ:\n\t\treturn PHY_BAND_6;\n\tdefault:\n\t\tWARN_ONCE(1, \"Unsupported band (%u)\\n\", band);\n\t\treturn PHY_BAND_5;\n\t}\n}\n\n \nvoid iwl_mvm_channel_switch_disconnect_wk(struct work_struct *wk);\nint iwl_mvm_post_channel_switch(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif);\n\n \n \nstruct iwl_mvm_switch_vif_chanctx_ops {\n\tint (*__assign_vif_chanctx)(struct iwl_mvm *mvm,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_bss_conf *link_conf,\n\t\t\t\t    struct ieee80211_chanctx_conf *ctx,\n\t\t\t\t    bool switching_chanctx);\n\tvoid (*__unassign_vif_chanctx)(struct iwl_mvm *mvm,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_bss_conf *link_conf,\n\t\t\t\t       struct ieee80211_chanctx_conf *ctx,\n\t\t\t\t       bool switching_chanctx);\n};\n\nint\niwl_mvm_switch_vif_chanctx_common(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif_chanctx_switch *vifs,\n\t\t\t\t  int n_vifs,\n\t\t\t\t  enum ieee80211_chanctx_switch_mode mode,\n\t\t\t\t  const struct iwl_mvm_switch_vif_chanctx_ops *ops);\n\n \nstatic inline bool iwl_mvm_has_ultra_hb_channel(struct iwl_mvm *mvm)\n{\n\treturn fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t   IWL_UCODE_TLV_CAPA_ULTRA_HB_CHANNELS);\n}\n\nstatic inline void *iwl_mvm_chan_info_cmd_tail(struct iwl_mvm *mvm,\n\t\t\t\t\t       struct iwl_fw_channel_info *ci)\n{\n\treturn (u8 *)ci + (iwl_mvm_has_ultra_hb_channel(mvm) ?\n\t\t\t   sizeof(struct iwl_fw_channel_info) :\n\t\t\t   sizeof(struct iwl_fw_channel_info_v1));\n}\n\nstatic inline size_t iwl_mvm_chan_info_padding(struct iwl_mvm *mvm)\n{\n\treturn iwl_mvm_has_ultra_hb_channel(mvm) ? 0 :\n\t\tsizeof(struct iwl_fw_channel_info) -\n\t\tsizeof(struct iwl_fw_channel_info_v1);\n}\n\nstatic inline void iwl_mvm_set_chan_info(struct iwl_mvm *mvm,\n\t\t\t\t\t struct iwl_fw_channel_info *ci,\n\t\t\t\t\t u32 chan, u8 band, u8 width,\n\t\t\t\t\t u8 ctrl_pos)\n{\n\tif (iwl_mvm_has_ultra_hb_channel(mvm)) {\n\t\tci->channel = cpu_to_le32(chan);\n\t\tci->band = band;\n\t\tci->width = width;\n\t\tci->ctrl_pos = ctrl_pos;\n\t} else {\n\t\tstruct iwl_fw_channel_info_v1 *ci_v1 =\n\t\t\t\t\t(struct iwl_fw_channel_info_v1 *)ci;\n\n\t\tci_v1->channel = chan;\n\t\tci_v1->band = band;\n\t\tci_v1->width = width;\n\t\tci_v1->ctrl_pos = ctrl_pos;\n\t}\n}\n\nstatic inline void\niwl_mvm_set_chan_info_chandef(struct iwl_mvm *mvm,\n\t\t\t      struct iwl_fw_channel_info *ci,\n\t\t\t      struct cfg80211_chan_def *chandef)\n{\n\tenum nl80211_band band = chandef->chan->band;\n\n\tiwl_mvm_set_chan_info(mvm, ci, chandef->chan->hw_value,\n\t\t\t      iwl_mvm_phy_band_from_nl80211(band),\n\t\t\t      iwl_mvm_get_channel_width(chandef),\n\t\t\t      iwl_mvm_get_ctrl_pos(chandef));\n}\n\nstatic inline int iwl_umac_scan_get_max_profiles(const struct iwl_fw *fw)\n{\n\tu8 ver = iwl_fw_lookup_cmd_ver(fw, SCAN_OFFLOAD_UPDATE_PROFILES_CMD,\n\t\t\t\t       IWL_FW_CMD_VER_UNKNOWN);\n\treturn (ver == IWL_FW_CMD_VER_UNKNOWN || ver < 3) ?\n\t\tIWL_SCAN_MAX_PROFILES : IWL_SCAN_MAX_PROFILES_V2;\n}\n\nstatic inline\nenum iwl_location_cipher iwl_mvm_cipher_to_location_cipher(u32 cipher)\n{\n\tswitch (cipher) {\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\treturn IWL_LOCATION_CIPHER_CCMP_128;\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\t\treturn IWL_LOCATION_CIPHER_GCMP_128;\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\treturn IWL_LOCATION_CIPHER_GCMP_256;\n\tdefault:\n\t\treturn IWL_LOCATION_CIPHER_INVALID;\n\t}\n}\n\nstruct iwl_mvm_csme_conn_info *iwl_mvm_get_csme_conn_info(struct iwl_mvm *mvm);\nstatic inline int iwl_mvm_mei_get_ownership(struct iwl_mvm *mvm)\n{\n\tif (mvm->mei_registered)\n\t\treturn iwl_mei_get_ownership();\n\treturn 0;\n}\n\nstatic inline void iwl_mvm_mei_tx_copy_to_csme(struct iwl_mvm *mvm,\n\t\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t\t       unsigned int ivlen)\n{\n\tif (mvm->mei_registered)\n\t\tiwl_mei_tx_copy_to_csme(skb, ivlen);\n}\n\nstatic inline void iwl_mvm_mei_host_disassociated(struct iwl_mvm *mvm)\n{\n\tif (mvm->mei_registered)\n\t\tiwl_mei_host_disassociated();\n}\n\nstatic inline void iwl_mvm_mei_device_state(struct iwl_mvm *mvm, bool up)\n{\n\tif (mvm->mei_registered)\n\t\tiwl_mei_device_state(up);\n}\n\nstatic inline void iwl_mvm_mei_set_sw_rfkill_state(struct iwl_mvm *mvm)\n{\n\tbool sw_rfkill =\n\t\tmvm->hw_registered ? rfkill_soft_blocked(mvm->hw->wiphy->rfkill) : false;\n\n\tif (mvm->mei_registered)\n\t\tiwl_mei_set_rfkill_state(iwl_mvm_is_radio_killed(mvm),\n\t\t\t\t\t sw_rfkill);\n}\n\nstatic inline bool iwl_mvm_mei_filter_scan(struct iwl_mvm *mvm,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct ieee80211_mgmt *mgmt = (void *)skb->data;\n\n\tif (mvm->mei_scan_filter.is_mei_limited_scan &&\n\t    (ieee80211_is_probe_resp(mgmt->frame_control) ||\n\t     ieee80211_is_beacon(mgmt->frame_control))) {\n\t\tskb_queue_tail(&mvm->mei_scan_filter.scan_res, skb);\n\t\tschedule_work(&mvm->mei_scan_filter.scan_work);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid iwl_mvm_send_roaming_forbidden_event(struct iwl_mvm *mvm,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  bool forbidden);\nbool iwl_mvm_is_vendor_in_approved_list(void);\n\n \nvoid iwl_mvm_mac_tx(struct ieee80211_hw *hw,\n\t\t    struct ieee80211_tx_control *control, struct sk_buff *skb);\nvoid iwl_mvm_mac_wake_tx_queue(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_txq *txq);\n\nint iwl_mvm_mac_ampdu_action(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_ampdu_params *params);\nint iwl_mvm_op_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant);\nint iwl_mvm_mac_start(struct ieee80211_hw *hw);\nvoid iwl_mvm_mac_reconfig_complete(struct ieee80211_hw *hw,\n\t\t\t\t   enum ieee80211_reconfig_type reconfig_type);\nvoid iwl_mvm_mac_stop(struct ieee80211_hw *hw);\nstatic inline int iwl_mvm_mac_config(struct ieee80211_hw *hw, u32 changed)\n{\n\treturn 0;\n}\n\nu64 iwl_mvm_prepare_multicast(struct ieee80211_hw *hw,\n\t\t\t      struct netdev_hw_addr_list *mc_list);\n\nvoid iwl_mvm_configure_filter(struct ieee80211_hw *hw,\n\t\t\t      unsigned int changed_flags,\n\t\t\t      unsigned int *total_flags, u64 multicast);\nint iwl_mvm_mac_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_scan_request *hw_req);\nvoid iwl_mvm_mac_cancel_hw_scan(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif);\nvoid iwl_mvm_sta_pre_rcu_remove(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta);\nvoid iwl_mvm_mac_sta_notify(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t    enum sta_notify_cmd cmd,\n\t\t\t    struct ieee80211_sta *sta);\nvoid\niwl_mvm_mac_allow_buffered_frames(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_sta *sta, u16 tids,\n\t\t\t\t  int num_frames,\n\t\t\t\t  enum ieee80211_frame_release_type reason,\n\t\t\t\t  bool more_data);\nvoid\niwl_mvm_mac_release_buffered_frames(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_sta *sta, u16 tids,\n\t\t\t\t    int num_frames,\n\t\t\t\t    enum ieee80211_frame_release_type reason,\n\t\t\t\t    bool more_data);\nint iwl_mvm_mac_set_rts_threshold(struct ieee80211_hw *hw, u32 value);\nvoid iwl_mvm_sta_rc_update(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_sta *sta, u32 changed);\nvoid iwl_mvm_mac_mgd_prepare_tx(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_prep_tx_info *info);\nvoid iwl_mvm_mac_mgd_complete_tx(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_prep_tx_info *info);\nvoid iwl_mvm_mac_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       u32 queues, bool drop);\nvoid iwl_mvm_mac_flush_sta(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_sta *sta);\nint iwl_mvm_mac_sched_scan_start(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct cfg80211_sched_scan_request *req,\n\t\t\t\t struct ieee80211_scan_ies *ies);\nint iwl_mvm_mac_sched_scan_stop(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif);\nint iwl_mvm_mac_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t\tstruct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t\tstruct ieee80211_key_conf *key);\nvoid iwl_mvm_mac_update_tkip_key(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_key_conf *keyconf,\n\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t u32 iv32, u16 *phase1key);\nint iwl_mvm_add_chanctx(struct ieee80211_hw *hw,\n\t\t\tstruct ieee80211_chanctx_conf *ctx);\nvoid iwl_mvm_remove_chanctx(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_chanctx_conf *ctx);\nvoid iwl_mvm_change_chanctx(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_chanctx_conf *ctx, u32 changed);\nint iwl_mvm_tx_last_beacon(struct ieee80211_hw *hw);\nint iwl_mvm_set_tim(struct ieee80211_hw *hw, struct ieee80211_sta *sta,\n\t\t    bool set);\nvoid iwl_mvm_channel_switch(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_channel_switch *chsw);\nint iwl_mvm_pre_channel_switch(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_channel_switch *chsw);\nvoid iwl_mvm_abort_channel_switch(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif);\nvoid iwl_mvm_channel_switch_rx_beacon(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_channel_switch *chsw);\nvoid iwl_mvm_mac_event_callback(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tconst struct ieee80211_event *event);\nvoid iwl_mvm_sync_rx_queues(struct ieee80211_hw *hw);\nint iwl_mvm_mac_testmode_cmd(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     void *data, int len);\nint iwl_mvm_mac_get_survey(struct ieee80211_hw *hw, int idx,\n\t\t\t   struct survey_info *survey);\nvoid iwl_mvm_mac_sta_statistics(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\tstruct station_info *sinfo);\nint\niwl_mvm_mac_get_ftm_responder_stats(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct cfg80211_ftm_responder_stats *stats);\nint iwl_mvm_start_pmsr(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       struct cfg80211_pmsr_request *request);\nvoid iwl_mvm_abort_pmsr(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tstruct cfg80211_pmsr_request *request);\n\nbool iwl_mvm_have_links_same_channel(struct iwl_mvm_vif *vif1,\n\t\t\t\t     struct iwl_mvm_vif *vif2);\nbool iwl_mvm_vif_is_active(struct iwl_mvm_vif *mvmvif);\nint iwl_mvm_set_tx_power(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t s16 tx_power);\nint iwl_mvm_set_hw_timestamp(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct cfg80211_set_hw_timestamp *hwts);\nint iwl_mvm_update_mu_groups(struct iwl_mvm *mvm, struct ieee80211_vif *vif);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}