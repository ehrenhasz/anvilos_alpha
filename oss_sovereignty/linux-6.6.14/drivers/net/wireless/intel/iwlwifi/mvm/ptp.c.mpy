{
  "module_name": "ptp.c",
  "hash_id": "c8c576daa711f0252336b86e5f8ede6d06d2838799c0bd9ba04c5d66e29cdca8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/ptp.c",
  "human_readable_source": "\n \n\n#include \"mvm.h\"\n#include \"iwl-debug.h\"\n#include <linux/timekeeping.h>\n#include <linux/math64.h>\n\n#define IWL_PTP_GP2_WRAP\t0x100000000ULL\n#define IWL_PTP_WRAP_TIME\t(3600 * HZ)\n\n \n#define SCALE_FACTOR\t65536000000ULL\n#define IWL_PTP_WRAP_THRESHOLD_USEC\t(5000)\n\n#define IWL_PTP_GET_CROSS_TS_NUM\t5\n\nstatic void iwl_mvm_ptp_update_new_read(struct iwl_mvm *mvm, u32 gp2)\n{\n\t \n\tif (gp2 < mvm->ptp_data.last_gp2 &&\n\t    mvm->ptp_data.last_gp2 - gp2 < IWL_PTP_WRAP_THRESHOLD_USEC) {\n\t\tIWL_DEBUG_INFO(mvm,\n\t\t\t       \"PTP: ignore old read (gp2=%u, last_gp2=%u)\\n\",\n\t\t\t       gp2, mvm->ptp_data.last_gp2);\n\t\treturn;\n\t}\n\n\tif (gp2 < mvm->ptp_data.last_gp2) {\n\t\tmvm->ptp_data.wrap_counter++;\n\t\tIWL_DEBUG_INFO(mvm,\n\t\t\t       \"PTP: wraparound detected (new counter=%u)\\n\",\n\t\t\t       mvm->ptp_data.wrap_counter);\n\t}\n\n\tmvm->ptp_data.last_gp2 = gp2;\n\tschedule_delayed_work(&mvm->ptp_data.dwork, IWL_PTP_WRAP_TIME);\n}\n\nu64 iwl_mvm_ptp_get_adj_time(struct iwl_mvm *mvm, u64 base_time_ns)\n{\n\tstruct ptp_data *data = &mvm->ptp_data;\n\tu64 last_gp2_ns = mvm->ptp_data.scale_update_gp2 * NSEC_PER_USEC;\n\tu64 res;\n\tu64 diff;\n\n\tiwl_mvm_ptp_update_new_read(mvm,\n\t\t\t\t    div64_u64(base_time_ns, NSEC_PER_USEC));\n\n\tIWL_DEBUG_INFO(mvm, \"base_time_ns=%llu, wrap_counter=%u\\n\",\n\t\t       (unsigned long long)base_time_ns, data->wrap_counter);\n\n\tbase_time_ns = base_time_ns +\n\t\t(data->wrap_counter * IWL_PTP_GP2_WRAP * NSEC_PER_USEC);\n\n\t \n\tif (base_time_ns < last_gp2_ns) {\n\t\tIWL_DEBUG_INFO(mvm, \"Time before scale update - ignore\\n\");\n\t\treturn 0;\n\t}\n\n\tdiff = base_time_ns - last_gp2_ns;\n\tIWL_DEBUG_INFO(mvm, \"diff ns=%llu\\n\", (unsigned long long)diff);\n\n\tdiff = mul_u64_u64_div_u64(diff, data->scaled_freq,\n\t\t\t\t   SCALE_FACTOR);\n\tIWL_DEBUG_INFO(mvm, \"scaled diff ns=%llu\\n\", (unsigned long long)diff);\n\n\tres = data->scale_update_adj_time_ns + data->delta + diff;\n\n\tIWL_DEBUG_INFO(mvm, \"base=%llu delta=%lld adj=%llu\\n\",\n\t\t       (unsigned long long)base_time_ns, (long long)data->delta,\n\t\t       (unsigned long long)res);\n\treturn res;\n}\n\nstatic int\niwl_mvm_get_crosstimestamp_fw(struct iwl_mvm *mvm, u32 *gp2, u64 *sys_time)\n{\n\tstruct iwl_synced_time_cmd synced_time_cmd = {\n\t\t.operation = cpu_to_le32(IWL_SYNCED_TIME_OPERATION_READ_BOTH)\n\t};\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = WIDE_ID(DATA_PATH_GROUP, WNM_PLATFORM_PTM_REQUEST_CMD),\n\t\t.flags = CMD_WANT_SKB,\n\t\t.data[0] = &synced_time_cmd,\n\t\t.len[0] = sizeof(synced_time_cmd),\n\t};\n\tstruct iwl_synced_time_rsp *resp;\n\tstruct iwl_rx_packet *pkt;\n\tint ret;\n\tu64 gp2_10ns;\n\n\tret = iwl_mvm_send_cmd(mvm, &cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tpkt = cmd.resp_pkt;\n\n\tif (iwl_rx_packet_payload_len(pkt) != sizeof(*resp)) {\n\t\tIWL_ERR(mvm, \"PTP: Invalid command response\\n\");\n\t\tiwl_free_resp(&cmd);\n\t\treturn -EIO;\n\t}\n\n\tresp = (void *)pkt->data;\n\n\tgp2_10ns = (u64)le32_to_cpu(resp->gp2_timestamp_hi) << 32 |\n\t\tle32_to_cpu(resp->gp2_timestamp_lo);\n\t*gp2 = div_u64(gp2_10ns, 100);\n\n\t*sys_time = (u64)le32_to_cpu(resp->platform_timestamp_hi) << 32 |\n\t\tle32_to_cpu(resp->platform_timestamp_lo);\n\n\treturn ret;\n}\n\nstatic void iwl_mvm_phc_get_crosstimestamp_loop(struct iwl_mvm *mvm,\n\t\t\t\t\t\tktime_t *sys_time, u32 *gp2)\n{\n\tu64 diff = 0, new_diff;\n\tu64 tmp_sys_time;\n\tu32 tmp_gp2;\n\tint i;\n\n\tfor (i = 0; i < IWL_PTP_GET_CROSS_TS_NUM; i++) {\n\t\tiwl_mvm_get_sync_time(mvm, CLOCK_REALTIME, &tmp_gp2, NULL,\n\t\t\t\t      &tmp_sys_time);\n\t\tnew_diff = tmp_sys_time - ((u64)tmp_gp2 * NSEC_PER_USEC);\n\t\tif (!diff || new_diff < diff) {\n\t\t\t*sys_time = tmp_sys_time;\n\t\t\t*gp2 = tmp_gp2;\n\t\t\tdiff = new_diff;\n\t\t\tIWL_DEBUG_INFO(mvm, \"PTP: new times: gp2=%u sys=%lld\\n\",\n\t\t\t\t       *gp2, *sys_time);\n\t\t}\n\t}\n}\n\nstatic int\niwl_mvm_phc_get_crosstimestamp(struct ptp_clock_info *ptp,\n\t\t\t       struct system_device_crosststamp *xtstamp)\n{\n\tstruct iwl_mvm *mvm = container_of(ptp, struct iwl_mvm,\n\t\t\t\t\t   ptp_data.ptp_clock_info);\n\tint ret = 0;\n\t \n\tu32 gp2;\n\t \n\ts64 gp2_ns;\n\t \n\tktime_t sys_time;\n\n\tmemset(xtstamp, 0, sizeof(struct system_device_crosststamp));\n\n\tif (!mvm->ptp_data.ptp_clock) {\n\t\tIWL_ERR(mvm, \"No PHC clock registered\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_lock(&mvm->mutex);\n\tif (fw_has_capa(&mvm->fw->ucode_capa, IWL_UCODE_TLV_CAPA_SYNCED_TIME)) {\n\t\tret = iwl_mvm_get_crosstimestamp_fw(mvm, &gp2, &sys_time);\n\n\t\tif (ret)\n\t\t\tgoto out;\n\t} else {\n\t\tiwl_mvm_phc_get_crosstimestamp_loop(mvm, &sys_time, &gp2);\n\t}\n\n\tgp2_ns = iwl_mvm_ptp_get_adj_time(mvm, (u64)gp2 * NSEC_PER_USEC);\n\n\tIWL_INFO(mvm, \"Got Sync Time: GP2:%u, last_GP2: %u, GP2_ns: %lld, sys_time: %lld\\n\",\n\t\t gp2, mvm->ptp_data.last_gp2, gp2_ns, (s64)sys_time);\n\n\t \n\txtstamp->device = (ktime_t)gp2_ns;\n\txtstamp->sys_realtime = sys_time;\n\nout:\n\tmutex_unlock(&mvm->mutex);\n\treturn ret;\n}\n\nstatic void iwl_mvm_ptp_work(struct work_struct *wk)\n{\n\tstruct iwl_mvm *mvm = container_of(wk, struct iwl_mvm,\n\t\t\t\t\t   ptp_data.dwork.work);\n\tu32 gp2;\n\n\tmutex_lock(&mvm->mutex);\n\tgp2 = iwl_mvm_get_systime(mvm);\n\tiwl_mvm_ptp_update_new_read(mvm, gp2);\n\tmutex_unlock(&mvm->mutex);\n}\n\nstatic int iwl_mvm_ptp_gettime(struct ptp_clock_info *ptp,\n\t\t\t       struct timespec64 *ts)\n{\n\tstruct iwl_mvm *mvm = container_of(ptp, struct iwl_mvm,\n\t\t\t\t\t   ptp_data.ptp_clock_info);\n\tu64 gp2;\n\tu64 ns;\n\n\tmutex_lock(&mvm->mutex);\n\tgp2 = iwl_mvm_get_systime(mvm);\n\tns = iwl_mvm_ptp_get_adj_time(mvm, gp2 * NSEC_PER_USEC);\n\tmutex_unlock(&mvm->mutex);\n\n\t*ts = ns_to_timespec64(ns);\n\treturn 0;\n}\n\nstatic int iwl_mvm_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct iwl_mvm *mvm = container_of(ptp, struct iwl_mvm,\n\t\t\t\t\t   ptp_data.ptp_clock_info);\n\tstruct ptp_data *data = container_of(ptp, struct ptp_data,\n\t\t\t\t\t     ptp_clock_info);\n\n\tmutex_lock(&mvm->mutex);\n\tdata->delta += delta;\n\tIWL_DEBUG_INFO(mvm, \"delta=%lld, new delta=%lld\\n\", (long long)delta,\n\t\t       (long long)data->delta);\n\tmutex_unlock(&mvm->mutex);\n\treturn 0;\n}\n\nstatic int iwl_mvm_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct iwl_mvm *mvm = container_of(ptp, struct iwl_mvm,\n\t\t\t\t\t   ptp_data.ptp_clock_info);\n\tstruct ptp_data *data = &mvm->ptp_data;\n\tu32 gp2;\n\n\tmutex_lock(&mvm->mutex);\n\n\t \n\tgp2 = iwl_mvm_get_systime(mvm);\n\tdata->scale_update_adj_time_ns =\n\t\tiwl_mvm_ptp_get_adj_time(mvm, gp2 * NSEC_PER_USEC);\n\tdata->scale_update_gp2 = gp2;\n\tdata->wrap_counter = 0;\n\tdata->delta = 0;\n\n\tdata->scaled_freq = SCALE_FACTOR + scaled_ppm;\n\tIWL_DEBUG_INFO(mvm, \"adjfine: scaled_ppm=%ld new=%llu\\n\",\n\t\t       scaled_ppm, (unsigned long long)data->scaled_freq);\n\n\tmutex_unlock(&mvm->mutex);\n\treturn 0;\n}\n\n \nvoid iwl_mvm_ptp_init(struct iwl_mvm *mvm)\n{\n\t \n\tif (WARN_ON(mvm->ptp_data.ptp_clock))\n\t\treturn;\n\n\tmvm->ptp_data.ptp_clock_info.owner = THIS_MODULE;\n\tmvm->ptp_data.ptp_clock_info.max_adj = 0x7fffffff;\n\tmvm->ptp_data.ptp_clock_info.getcrosststamp =\n\t\t\t\t\tiwl_mvm_phc_get_crosstimestamp;\n\tmvm->ptp_data.ptp_clock_info.adjfine = iwl_mvm_ptp_adjfine;\n\tmvm->ptp_data.ptp_clock_info.adjtime = iwl_mvm_ptp_adjtime;\n\tmvm->ptp_data.ptp_clock_info.gettime64 = iwl_mvm_ptp_gettime;\n\tmvm->ptp_data.scaled_freq = SCALE_FACTOR;\n\n\t \n\tsnprintf(mvm->ptp_data.ptp_clock_info.name,\n\t\t sizeof(mvm->ptp_data.ptp_clock_info.name),\n\t\t \"%s\", \"iwlwifi-PTP\");\n\n\tINIT_DELAYED_WORK(&mvm->ptp_data.dwork, iwl_mvm_ptp_work);\n\n\tmvm->ptp_data.ptp_clock =\n\t\tptp_clock_register(&mvm->ptp_data.ptp_clock_info, mvm->dev);\n\n\tif (IS_ERR(mvm->ptp_data.ptp_clock)) {\n\t\tIWL_ERR(mvm, \"Failed to register PHC clock (%ld)\\n\",\n\t\t\tPTR_ERR(mvm->ptp_data.ptp_clock));\n\t\tmvm->ptp_data.ptp_clock = NULL;\n\t} else if (mvm->ptp_data.ptp_clock) {\n\t\tIWL_INFO(mvm, \"Registered PHC clock: %s, with index: %d\\n\",\n\t\t\t mvm->ptp_data.ptp_clock_info.name,\n\t\t\t ptp_clock_index(mvm->ptp_data.ptp_clock));\n\t}\n}\n\n \nvoid iwl_mvm_ptp_remove(struct iwl_mvm *mvm)\n{\n\tif (mvm->ptp_data.ptp_clock) {\n\t\tIWL_INFO(mvm, \"Unregistering PHC clock: %s, with index: %d\\n\",\n\t\t\t mvm->ptp_data.ptp_clock_info.name,\n\t\t\t ptp_clock_index(mvm->ptp_data.ptp_clock));\n\n\t\tptp_clock_unregister(mvm->ptp_data.ptp_clock);\n\t\tmvm->ptp_data.ptp_clock = NULL;\n\t\tmemset(&mvm->ptp_data.ptp_clock_info, 0,\n\t\t       sizeof(mvm->ptp_data.ptp_clock_info));\n\t\tmvm->ptp_data.last_gp2 = 0;\n\t\tcancel_delayed_work_sync(&mvm->ptp_data.dwork);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}