{
  "module_name": "d3.c",
  "hash_id": "043167a30d54c666f51fff76374d7b8fb1dd5e6477d650ae2698dc8225e12b64",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/d3.c",
  "human_readable_source": "\n \n#include <linux/etherdevice.h>\n#include <linux/ip.h>\n#include <linux/fs.h>\n#include <net/cfg80211.h>\n#include <net/ipv6.h>\n#include <net/tcp.h>\n#include <net/addrconf.h>\n#include \"iwl-modparams.h\"\n#include \"fw-api.h\"\n#include \"mvm.h\"\n#include \"fw/img.h\"\n\nvoid iwl_mvm_set_rekey_data(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct cfg80211_gtk_rekey_data *data)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tmutex_lock(&mvm->mutex);\n\n\tmvmvif->rekey_data.kek_len = data->kek_len;\n\tmvmvif->rekey_data.kck_len = data->kck_len;\n\tmemcpy(mvmvif->rekey_data.kek, data->kek, data->kek_len);\n\tmemcpy(mvmvif->rekey_data.kck, data->kck, data->kck_len);\n\tmvmvif->rekey_data.akm = data->akm & 0xFF;\n\tmvmvif->rekey_data.replay_ctr =\n\t\tcpu_to_le64(be64_to_cpup((const __be64 *)data->replay_ctr));\n\tmvmvif->rekey_data.valid = true;\n\n\tmutex_unlock(&mvm->mutex);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nvoid iwl_mvm_ipv6_addr_change(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct inet6_dev *idev)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct inet6_ifaddr *ifa;\n\tint idx = 0;\n\n\tmemset(mvmvif->tentative_addrs, 0, sizeof(mvmvif->tentative_addrs));\n\n\tread_lock_bh(&idev->lock);\n\tlist_for_each_entry(ifa, &idev->addr_list, if_list) {\n\t\tmvmvif->target_ipv6_addrs[idx] = ifa->addr;\n\t\tif (ifa->flags & IFA_F_TENTATIVE)\n\t\t\t__set_bit(idx, mvmvif->tentative_addrs);\n\t\tidx++;\n\t\tif (idx >= IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS_MAX)\n\t\t\tbreak;\n\t}\n\tread_unlock_bh(&idev->lock);\n\n\tmvmvif->num_target_ipv6_addrs = idx;\n}\n#endif\n\nvoid iwl_mvm_set_default_unicast_key(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif, int idx)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tmvmvif->tx_key_idx = idx;\n}\n\nstatic void iwl_mvm_convert_p1k(u16 *p1k, __le16 *out)\n{\n\tint i;\n\n\tfor (i = 0; i < IWL_P1K_SIZE; i++)\n\t\tout[i] = cpu_to_le16(p1k[i]);\n}\n\nstatic const u8 *iwl_mvm_find_max_pn(struct ieee80211_key_conf *key,\n\t\t\t\t     struct iwl_mvm_key_pn *ptk_pn,\n\t\t\t\t     struct ieee80211_key_seq *seq,\n\t\t\t\t     int tid, int queues)\n{\n\tconst u8 *ret = seq->ccmp.pn;\n\tint i;\n\n\t \n\tieee80211_get_key_rx_seq(key, tid, seq);\n\n\t \n\tfor (i = 1; i < queues; i++) {\n\t\tconst u8 *tmp = ptk_pn->q[i].pn[tid];\n\n\t\tif (memcmp(ret, tmp, IEEE80211_CCMP_PN_LEN) <= 0)\n\t\t\tret = tmp;\n\t}\n\n\treturn ret;\n}\n\nstruct wowlan_key_reprogram_data {\n\tbool error;\n\tint wep_key_idx;\n};\n\nstatic void iwl_mvm_wowlan_program_keys(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\t\tstruct ieee80211_key_conf *key,\n\t\t\t\t\tvoid *_data)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct wowlan_key_reprogram_data *data = _data;\n\tint ret;\n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104: {  \n\t\tstruct {\n\t\t\tstruct iwl_mvm_wep_key_cmd wep_key_cmd;\n\t\t\tstruct iwl_mvm_wep_key wep_key;\n\t\t} __packed wkc = {\n\t\t\t.wep_key_cmd.mac_id_n_color =\n\t\t\t\tcpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id,\n\t\t\t\t\t\t\t\tmvmvif->color)),\n\t\t\t.wep_key_cmd.num_keys = 1,\n\t\t\t \n\t\t\t.wep_key_cmd.decryption_type = STA_KEY_FLG_WEP,\n\t\t\t.wep_key.key_index = key->keyidx,\n\t\t\t.wep_key.key_size = key->keylen,\n\t\t};\n\n\t\t \n\t\tif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)\n\t\t\tbreak;\n\n\t\tmemcpy(&wkc.wep_key.key[3], key->key, key->keylen);\n\t\tif (key->keyidx == mvmvif->tx_key_idx) {\n\t\t\t \n\t\t\twkc.wep_key.key_offset = 0;\n\t\t} else {\n\t\t\t \n\t\t\tdata->wep_key_idx++;\n\t\t\twkc.wep_key.key_offset = data->wep_key_idx;\n\t\t}\n\n\t\tmutex_lock(&mvm->mutex);\n\t\tret = iwl_mvm_send_cmd_pdu(mvm, WEP_KEY, 0, sizeof(wkc), &wkc);\n\t\tdata->error = ret != 0;\n\n\t\tmvm->ptk_ivlen = key->iv_len;\n\t\tmvm->ptk_icvlen = key->icv_len;\n\t\tmvm->gtk_ivlen = key->iv_len;\n\t\tmvm->gtk_icvlen = key->icv_len;\n\t\tmutex_unlock(&mvm->mutex);\n\n\t\t \n\t\treturn;\n\t}\n\tdefault:\n\t\tdata->error = true;\n\t\treturn;\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\t\treturn;\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\t \n\t\treturn;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\tbreak;\n\t}\n\n\tmutex_lock(&mvm->mutex);\n\t \n\tif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE) {\n\t\tmvm->ptk_ivlen = key->iv_len;\n\t\tmvm->ptk_icvlen = key->icv_len;\n\t\tret = iwl_mvm_set_sta_key(mvm, vif, sta, key, 0);\n\t} else {\n\t\t \n\t\tmvm->gtk_ivlen = key->iv_len;\n\t\tmvm->gtk_icvlen = key->icv_len;\n\t\tret = iwl_mvm_set_sta_key(mvm, vif, sta, key, 1);\n\t}\n\tmutex_unlock(&mvm->mutex);\n\tdata->error = ret != 0;\n}\n\nstruct wowlan_key_rsc_tsc_data {\n\tstruct iwl_wowlan_rsc_tsc_params_cmd_v4 *rsc_tsc;\n\tbool have_rsc_tsc;\n};\n\nstatic void iwl_mvm_wowlan_get_rsc_tsc_data(struct ieee80211_hw *hw,\n\t\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t\t    struct ieee80211_sta *sta,\n\t\t\t\t\t    struct ieee80211_key_conf *key,\n\t\t\t\t\t    void *_data)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct wowlan_key_rsc_tsc_data *data = _data;\n\tstruct aes_sc *aes_sc;\n\tstruct tkip_sc *tkip_sc, *tkip_tx_sc = NULL;\n\tstruct ieee80211_key_seq seq;\n\tint i;\n\n\tswitch (key->cipher) {\n\tdefault:\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tif (sta) {\n\t\t\tu64 pn64;\n\n\t\t\ttkip_sc =\n\t\t\t   data->rsc_tsc->params.all_tsc_rsc.tkip.unicast_rsc;\n\t\t\ttkip_tx_sc =\n\t\t\t\t&data->rsc_tsc->params.all_tsc_rsc.tkip.tsc;\n\n\t\t\tpn64 = atomic64_read(&key->tx_pn);\n\t\t\ttkip_tx_sc->iv16 = cpu_to_le16(TKIP_PN_TO_IV16(pn64));\n\t\t\ttkip_tx_sc->iv32 = cpu_to_le32(TKIP_PN_TO_IV32(pn64));\n\t\t} else {\n\t\t\ttkip_sc =\n\t\t\t  data->rsc_tsc->params.all_tsc_rsc.tkip.multicast_rsc;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < IWL_NUM_RSC; i++) {\n\t\t\tieee80211_get_key_rx_seq(key, i, &seq);\n\t\t\ttkip_sc[i].iv16 = cpu_to_le16(seq.tkip.iv16);\n\t\t\ttkip_sc[i].iv32 = cpu_to_le32(seq.tkip.iv32);\n\t\t}\n\n\t\tdata->have_rsc_tsc = true;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\tif (sta) {\n\t\t\tstruct aes_sc *aes_tx_sc;\n\t\t\tu64 pn64;\n\n\t\t\taes_sc =\n\t\t\t   data->rsc_tsc->params.all_tsc_rsc.aes.unicast_rsc;\n\t\t\taes_tx_sc =\n\t\t\t\t&data->rsc_tsc->params.all_tsc_rsc.aes.tsc;\n\n\t\t\tpn64 = atomic64_read(&key->tx_pn);\n\t\t\taes_tx_sc->pn = cpu_to_le64(pn64);\n\t\t} else {\n\t\t\taes_sc =\n\t\t\t   data->rsc_tsc->params.all_tsc_rsc.aes.multicast_rsc;\n\t\t}\n\n\t\t \n\t\tif (sta && iwl_mvm_has_new_rx_api(mvm)) {\n\t\t\tstruct iwl_mvm_sta *mvmsta;\n\t\t\tstruct iwl_mvm_key_pn *ptk_pn;\n\t\t\tconst u8 *pn;\n\n\t\t\tmvmsta = iwl_mvm_sta_from_mac80211(sta);\n\t\t\trcu_read_lock();\n\t\t\tptk_pn = rcu_dereference(mvmsta->ptk_pn[key->keyidx]);\n\t\t\tif (WARN_ON(!ptk_pn)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < IWL_MAX_TID_COUNT; i++) {\n\t\t\t\tpn = iwl_mvm_find_max_pn(key, ptk_pn, &seq, i,\n\t\t\t\t\t\tmvm->trans->num_rx_queues);\n\t\t\t\taes_sc[i].pn = cpu_to_le64((u64)pn[5] |\n\t\t\t\t\t\t\t   ((u64)pn[4] << 8) |\n\t\t\t\t\t\t\t   ((u64)pn[3] << 16) |\n\t\t\t\t\t\t\t   ((u64)pn[2] << 24) |\n\t\t\t\t\t\t\t   ((u64)pn[1] << 32) |\n\t\t\t\t\t\t\t   ((u64)pn[0] << 40));\n\t\t\t}\n\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tfor (i = 0; i < IWL_NUM_RSC; i++) {\n\t\t\t\tu8 *pn = seq.ccmp.pn;\n\n\t\t\t\tieee80211_get_key_rx_seq(key, i, &seq);\n\t\t\t\taes_sc[i].pn = cpu_to_le64((u64)pn[5] |\n\t\t\t\t\t\t\t   ((u64)pn[4] << 8) |\n\t\t\t\t\t\t\t   ((u64)pn[3] << 16) |\n\t\t\t\t\t\t\t   ((u64)pn[2] << 24) |\n\t\t\t\t\t\t\t   ((u64)pn[1] << 32) |\n\t\t\t\t\t\t\t   ((u64)pn[0] << 40));\n\t\t\t}\n\t\t}\n\t\tdata->have_rsc_tsc = true;\n\t\tbreak;\n\t}\n}\n\nstruct wowlan_key_rsc_v5_data {\n\tstruct iwl_wowlan_rsc_tsc_params_cmd *rsc;\n\tbool have_rsc;\n\tint gtks;\n\tint gtk_ids[4];\n};\n\nstatic void iwl_mvm_wowlan_get_rsc_v5_data(struct ieee80211_hw *hw,\n\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t\t   struct ieee80211_key_conf *key,\n\t\t\t\t\t   void *_data)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct wowlan_key_rsc_v5_data *data = _data;\n\tstruct ieee80211_key_seq seq;\n\t__le64 *rsc;\n\tint i;\n\n\t \n\tswitch (key->cipher) {\n\tdefault:\n\t\treturn;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\tbreak;\n\t}\n\n\tif (sta) {\n\t\trsc = data->rsc->ucast_rsc;\n\t} else {\n\t\tif (WARN_ON(data->gtks >= ARRAY_SIZE(data->gtk_ids)))\n\t\t\treturn;\n\t\tdata->gtk_ids[data->gtks] = key->keyidx;\n\t\trsc = data->rsc->mcast_rsc[data->gtks % 2];\n\t\tif (WARN_ON(key->keyidx >=\n\t\t\t\tARRAY_SIZE(data->rsc->mcast_key_id_map)))\n\t\t\treturn;\n\t\tdata->rsc->mcast_key_id_map[key->keyidx] = data->gtks % 2;\n\t\tif (data->gtks >= 2) {\n\t\t\tint prev = data->gtks - 2;\n\t\t\tint prev_idx = data->gtk_ids[prev];\n\n\t\t\tdata->rsc->mcast_key_id_map[prev_idx] =\n\t\t\t\tIWL_MCAST_KEY_MAP_INVALID;\n\t\t}\n\t\tdata->gtks++;\n\t}\n\n\tswitch (key->cipher) {\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\n\t\t \n\t\tfor (i = 0; i < IWL_MAX_TID_COUNT; i++) {\n\t\t\tieee80211_get_key_rx_seq(key, i, &seq);\n\n\t\t\trsc[i] = cpu_to_le64(((u64)seq.tkip.iv32 << 16) |\n\t\t\t\t\t     seq.tkip.iv16);\n\t\t}\n\n\t\tdata->have_rsc = true;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\t \n\t\tif (sta) {\n\t\t\tstruct iwl_mvm_sta *mvmsta;\n\t\t\tstruct iwl_mvm_key_pn *ptk_pn;\n\t\t\tconst u8 *pn;\n\n\t\t\tmvmsta = iwl_mvm_sta_from_mac80211(sta);\n\t\t\trcu_read_lock();\n\t\t\tptk_pn = rcu_dereference(mvmsta->ptk_pn[key->keyidx]);\n\t\t\tif (WARN_ON(!ptk_pn)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < IWL_MAX_TID_COUNT; i++) {\n\t\t\t\tpn = iwl_mvm_find_max_pn(key, ptk_pn, &seq, i,\n\t\t\t\t\t\tmvm->trans->num_rx_queues);\n\t\t\t\trsc[i] = cpu_to_le64((u64)pn[5] |\n\t\t\t\t\t\t     ((u64)pn[4] << 8) |\n\t\t\t\t\t\t     ((u64)pn[3] << 16) |\n\t\t\t\t\t\t     ((u64)pn[2] << 24) |\n\t\t\t\t\t\t     ((u64)pn[1] << 32) |\n\t\t\t\t\t\t     ((u64)pn[0] << 40));\n\t\t\t}\n\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tfor (i = 0; i < IWL_MAX_TID_COUNT; i++) {\n\t\t\t\tu8 *pn = seq.ccmp.pn;\n\n\t\t\t\tieee80211_get_key_rx_seq(key, i, &seq);\n\t\t\t\trsc[i] = cpu_to_le64((u64)pn[5] |\n\t\t\t\t\t\t     ((u64)pn[4] << 8) |\n\t\t\t\t\t\t     ((u64)pn[3] << 16) |\n\t\t\t\t\t\t     ((u64)pn[2] << 24) |\n\t\t\t\t\t\t     ((u64)pn[1] << 32) |\n\t\t\t\t\t\t     ((u64)pn[0] << 40));\n\t\t\t}\n\t\t}\n\t\tdata->have_rsc = true;\n\t\tbreak;\n\t}\n}\n\nstatic int iwl_mvm_wowlan_config_rsc_tsc(struct iwl_mvm *mvm,\n\t\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tint ver = iwl_fw_lookup_cmd_ver(mvm->fw, WOWLAN_TSC_RSC_PARAM,\n\t\t\t\t\tIWL_FW_CMD_VER_UNKNOWN);\n\tint ret;\n\n\tif (ver == 5) {\n\t\tstruct wowlan_key_rsc_v5_data data = {};\n\t\tint i;\n\n\t\tdata.rsc = kmalloc(sizeof(*data.rsc), GFP_KERNEL);\n\t\tif (!data.rsc)\n\t\t\treturn -ENOMEM;\n\n\t\tmemset(data.rsc, 0xff, sizeof(*data.rsc));\n\n\t\tfor (i = 0; i < ARRAY_SIZE(data.rsc->mcast_key_id_map); i++)\n\t\t\tdata.rsc->mcast_key_id_map[i] =\n\t\t\t\tIWL_MCAST_KEY_MAP_INVALID;\n\t\tdata.rsc->sta_id = cpu_to_le32(mvmvif->deflink.ap_sta_id);\n\n\t\tieee80211_iter_keys(mvm->hw, vif,\n\t\t\t\t    iwl_mvm_wowlan_get_rsc_v5_data,\n\t\t\t\t    &data);\n\n\t\tif (data.have_rsc)\n\t\t\tret = iwl_mvm_send_cmd_pdu(mvm, WOWLAN_TSC_RSC_PARAM,\n\t\t\t\t\t\t   CMD_ASYNC, sizeof(*data.rsc),\n\t\t\t\t\t\t   data.rsc);\n\t\telse\n\t\t\tret = 0;\n\t\tkfree(data.rsc);\n\t} else if (ver == 4 || ver == 2 || ver == IWL_FW_CMD_VER_UNKNOWN) {\n\t\tstruct wowlan_key_rsc_tsc_data data = {};\n\t\tint size;\n\n\t\tdata.rsc_tsc = kzalloc(sizeof(*data.rsc_tsc), GFP_KERNEL);\n\t\tif (!data.rsc_tsc)\n\t\t\treturn -ENOMEM;\n\n\t\tif (ver == 4) {\n\t\t\tsize = sizeof(*data.rsc_tsc);\n\t\t\tdata.rsc_tsc->sta_id =\n\t\t\t\tcpu_to_le32(mvmvif->deflink.ap_sta_id);\n\t\t} else {\n\t\t\t \n\t\t\tsize = sizeof(data.rsc_tsc->params);\n\t\t}\n\n\t\tieee80211_iter_keys(mvm->hw, vif,\n\t\t\t\t    iwl_mvm_wowlan_get_rsc_tsc_data,\n\t\t\t\t    &data);\n\n\t\tif (data.have_rsc_tsc)\n\t\t\tret = iwl_mvm_send_cmd_pdu(mvm, WOWLAN_TSC_RSC_PARAM,\n\t\t\t\t\t\t   CMD_ASYNC, size,\n\t\t\t\t\t\t   data.rsc_tsc);\n\t\telse\n\t\t\tret = 0;\n\t\tkfree(data.rsc_tsc);\n\t} else {\n\t\tret = 0;\n\t\tWARN_ON_ONCE(1);\n\t}\n\n\treturn ret;\n}\n\nstruct wowlan_key_tkip_data {\n\tstruct iwl_wowlan_tkip_params_cmd tkip;\n\tbool have_tkip_keys;\n};\n\nstatic void iwl_mvm_wowlan_get_tkip_data(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t\t struct ieee80211_key_conf *key,\n\t\t\t\t\t void *_data)\n{\n\tstruct wowlan_key_tkip_data *data = _data;\n\tstruct iwl_p1k_cache *rx_p1ks;\n\tu8 *rx_mic_key;\n\tstruct ieee80211_key_seq seq;\n\tu32 cur_rx_iv32 = 0;\n\tu16 p1k[IWL_P1K_SIZE];\n\tint i;\n\n\tswitch (key->cipher) {\n\tdefault:\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tif (sta) {\n\t\t\tu64 pn64;\n\n\t\t\trx_p1ks = data->tkip.rx_uni;\n\n\t\t\tpn64 = atomic64_read(&key->tx_pn);\n\n\t\t\tieee80211_get_tkip_p1k_iv(key, TKIP_PN_TO_IV32(pn64),\n\t\t\t\t\t\t  p1k);\n\t\t\tiwl_mvm_convert_p1k(p1k, data->tkip.tx.p1k);\n\n\t\t\tmemcpy(data->tkip.mic_keys.tx,\n\t\t\t       &key->key[NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY],\n\t\t\t       IWL_MIC_KEY_SIZE);\n\n\t\t\trx_mic_key = data->tkip.mic_keys.rx_unicast;\n\t\t} else {\n\t\t\trx_p1ks = data->tkip.rx_multi;\n\t\t\trx_mic_key = data->tkip.mic_keys.rx_mcast;\n\t\t}\n\n\t\tfor (i = 0; i < IWL_NUM_RSC; i++) {\n\t\t\tieee80211_get_key_rx_seq(key, i, &seq);\n\t\t\t \n\t\t\tif (seq.tkip.iv32 > cur_rx_iv32)\n\t\t\t\tcur_rx_iv32 = seq.tkip.iv32;\n\t\t}\n\n\t\tieee80211_get_tkip_rx_p1k(key, vif->bss_conf.bssid,\n\t\t\t\t\t  cur_rx_iv32, p1k);\n\t\tiwl_mvm_convert_p1k(p1k, rx_p1ks[0].p1k);\n\t\tieee80211_get_tkip_rx_p1k(key, vif->bss_conf.bssid,\n\t\t\t\t\t  cur_rx_iv32 + 1, p1k);\n\t\tiwl_mvm_convert_p1k(p1k, rx_p1ks[1].p1k);\n\n\t\tmemcpy(rx_mic_key,\n\t\t       &key->key[NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY],\n\t\t       IWL_MIC_KEY_SIZE);\n\n\t\tdata->have_tkip_keys = true;\n\t\tbreak;\n\t}\n}\n\nstruct wowlan_key_gtk_type_iter {\n\tstruct iwl_wowlan_kek_kck_material_cmd_v4 *kek_kck_cmd;\n};\n\nstatic void iwl_mvm_wowlan_gtk_type_iter(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t\t struct ieee80211_key_conf *key,\n\t\t\t\t\t void *_data)\n{\n\tstruct wowlan_key_gtk_type_iter *data = _data;\n\n\tswitch (key->cipher) {\n\tdefault:\n\t\treturn;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tif (!sta)\n\t\t\tdata->kek_kck_cmd->gtk_cipher =\n\t\t\t\tcpu_to_le32(STA_KEY_FLG_TKIP);\n\t\treturn;\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\t\tdata->kek_kck_cmd->igtk_cipher = cpu_to_le32(STA_KEY_FLG_GCMP);\n\t\treturn;\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\tdata->kek_kck_cmd->igtk_cipher = cpu_to_le32(STA_KEY_FLG_CCM);\n\t\treturn;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tif (!sta)\n\t\t\tdata->kek_kck_cmd->gtk_cipher =\n\t\t\t\tcpu_to_le32(STA_KEY_FLG_CCM);\n\t\treturn;\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\tif (!sta)\n\t\t\tdata->kek_kck_cmd->gtk_cipher =\n\t\t\t\tcpu_to_le32(STA_KEY_FLG_GCMP);\n\t\treturn;\n\t}\n}\n\nstatic int iwl_mvm_send_patterns_v1(struct iwl_mvm *mvm,\n\t\t\t\t    struct cfg80211_wowlan *wowlan)\n{\n\tstruct iwl_wowlan_patterns_cmd_v1 *pattern_cmd;\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = WOWLAN_PATTERNS,\n\t\t.dataflags[0] = IWL_HCMD_DFL_NOCOPY,\n\t};\n\tint i, err;\n\n\tif (!wowlan->n_patterns)\n\t\treturn 0;\n\n\tcmd.len[0] = struct_size(pattern_cmd, patterns, wowlan->n_patterns);\n\n\tpattern_cmd = kmalloc(cmd.len[0], GFP_KERNEL);\n\tif (!pattern_cmd)\n\t\treturn -ENOMEM;\n\n\tpattern_cmd->n_patterns = cpu_to_le32(wowlan->n_patterns);\n\n\tfor (i = 0; i < wowlan->n_patterns; i++) {\n\t\tint mask_len = DIV_ROUND_UP(wowlan->patterns[i].pattern_len, 8);\n\n\t\tmemcpy(&pattern_cmd->patterns[i].mask,\n\t\t       wowlan->patterns[i].mask, mask_len);\n\t\tmemcpy(&pattern_cmd->patterns[i].pattern,\n\t\t       wowlan->patterns[i].pattern,\n\t\t       wowlan->patterns[i].pattern_len);\n\t\tpattern_cmd->patterns[i].mask_size = mask_len;\n\t\tpattern_cmd->patterns[i].pattern_size =\n\t\t\twowlan->patterns[i].pattern_len;\n\t}\n\n\tcmd.data[0] = pattern_cmd;\n\terr = iwl_mvm_send_cmd(mvm, &cmd);\n\tkfree(pattern_cmd);\n\treturn err;\n}\n\nstatic int iwl_mvm_send_patterns(struct iwl_mvm *mvm,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct cfg80211_wowlan *wowlan)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_wowlan_patterns_cmd *pattern_cmd;\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = WOWLAN_PATTERNS,\n\t\t.dataflags[0] = IWL_HCMD_DFL_NOCOPY,\n\t};\n\tint i, err;\n\tint ver = iwl_fw_lookup_cmd_ver(mvm->fw, cmd.id,\n\t\t\t\t\tIWL_FW_CMD_VER_UNKNOWN);\n\n\tif (!wowlan->n_patterns)\n\t\treturn 0;\n\n\tcmd.len[0] = sizeof(*pattern_cmd) +\n\t\twowlan->n_patterns * sizeof(struct iwl_wowlan_pattern_v2);\n\n\tpattern_cmd = kzalloc(cmd.len[0], GFP_KERNEL);\n\tif (!pattern_cmd)\n\t\treturn -ENOMEM;\n\n\tpattern_cmd->n_patterns = wowlan->n_patterns;\n\tif (ver >= 3)\n\t\tpattern_cmd->sta_id = mvmvif->deflink.ap_sta_id;\n\n\tfor (i = 0; i < wowlan->n_patterns; i++) {\n\t\tint mask_len = DIV_ROUND_UP(wowlan->patterns[i].pattern_len, 8);\n\n\t\tpattern_cmd->patterns[i].pattern_type =\n\t\t\tWOWLAN_PATTERN_TYPE_BITMASK;\n\n\t\tmemcpy(&pattern_cmd->patterns[i].u.bitmask.mask,\n\t\t       wowlan->patterns[i].mask, mask_len);\n\t\tmemcpy(&pattern_cmd->patterns[i].u.bitmask.pattern,\n\t\t       wowlan->patterns[i].pattern,\n\t\t       wowlan->patterns[i].pattern_len);\n\t\tpattern_cmd->patterns[i].u.bitmask.mask_size = mask_len;\n\t\tpattern_cmd->patterns[i].u.bitmask.pattern_size =\n\t\t\twowlan->patterns[i].pattern_len;\n\t}\n\n\tcmd.data[0] = pattern_cmd;\n\terr = iwl_mvm_send_cmd(mvm, &cmd);\n\tkfree(pattern_cmd);\n\treturn err;\n}\n\nstatic int iwl_mvm_d3_reprogram(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *ap_sta)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct ieee80211_chanctx_conf *ctx;\n\tu8 chains_static, chains_dynamic;\n\tstruct cfg80211_chan_def chandef;\n\tint ret, i;\n\tstruct iwl_binding_cmd_v1 binding_cmd = {};\n\tstruct iwl_time_quota_cmd quota_cmd = {};\n\tstruct iwl_time_quota_data *quota;\n\tu32 status;\n\n\tif (WARN_ON_ONCE(iwl_mvm_is_cdb_supported(mvm)))\n\t\treturn -EINVAL;\n\n\t \n\tif (WARN_ON(!mvmvif->deflink.phy_ctxt))\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tctx = rcu_dereference(vif->bss_conf.chanctx_conf);\n\tif (WARN_ON(!ctx)) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\tchandef = ctx->def;\n\tchains_static = ctx->rx_chains_static;\n\tchains_dynamic = ctx->rx_chains_dynamic;\n\trcu_read_unlock();\n\n\tret = iwl_mvm_phy_ctxt_add(mvm, mvmvif->deflink.phy_ctxt, &chandef,\n\t\t\t\t   chains_static, chains_dynamic);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmvmvif->uploaded = false;\n\n\tif (WARN_ON(!vif->cfg.assoc))\n\t\treturn -EINVAL;\n\n\tret = iwl_mvm_mac_ctxt_add(mvm, vif);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tbinding_cmd.id_and_color =\n\t\tcpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->deflink.phy_ctxt->id,\n\t\t\t\t\t\tmvmvif->deflink.phy_ctxt->color));\n\tbinding_cmd.action = cpu_to_le32(FW_CTXT_ACTION_ADD);\n\tbinding_cmd.phy =\n\t\tcpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->deflink.phy_ctxt->id,\n\t\t\t\t\t\tmvmvif->deflink.phy_ctxt->color));\n\tbinding_cmd.macs[0] = cpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id,\n\t\t\t\t\t\t\t      mvmvif->color));\n\tfor (i = 1; i < MAX_MACS_IN_BINDING; i++)\n\t\tbinding_cmd.macs[i] = cpu_to_le32(FW_CTXT_INVALID);\n\n\tstatus = 0;\n\tret = iwl_mvm_send_cmd_pdu_status(mvm, BINDING_CONTEXT_CMD,\n\t\t\t\t\t  IWL_BINDING_CMD_SIZE_V1, &binding_cmd,\n\t\t\t\t\t  &status);\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"Failed to add binding: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (status) {\n\t\tIWL_ERR(mvm, \"Binding command failed: %u\\n\", status);\n\t\treturn -EIO;\n\t}\n\n\tret = iwl_mvm_sta_send_to_fw(mvm, ap_sta, false, 0);\n\tif (ret)\n\t\treturn ret;\n\trcu_assign_pointer(mvm->fw_id_to_mac_id[mvmvif->deflink.ap_sta_id],\n\t\t\t   ap_sta);\n\n\tret = iwl_mvm_mac_ctxt_changed(mvm, vif, false, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tquota = iwl_mvm_quota_cmd_get_quota(mvm, &quota_cmd, 0);\n\tquota->id_and_color =\n\t\tcpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->deflink.phy_ctxt->id,\n\t\t\t\t\t\tmvmvif->deflink.phy_ctxt->color));\n\tquota->quota = cpu_to_le32(IWL_MVM_MAX_QUOTA);\n\tquota->max_duration = cpu_to_le32(IWL_MVM_MAX_QUOTA);\n\n\tfor (i = 1; i < MAX_BINDINGS; i++) {\n\t\tquota = iwl_mvm_quota_cmd_get_quota(mvm, &quota_cmd, i);\n\t\tquota->id_and_color = cpu_to_le32(FW_CTXT_INVALID);\n\t}\n\n\tret = iwl_mvm_send_cmd_pdu(mvm, TIME_QUOTA_CMD, 0,\n\t\t\t\t   iwl_mvm_quota_cmd_size(mvm), &quota_cmd);\n\tif (ret)\n\t\tIWL_ERR(mvm, \"Failed to send quota: %d\\n\", ret);\n\n\tif (iwl_mvm_is_lar_supported(mvm) && iwl_mvm_init_fw_regd(mvm))\n\t\tIWL_ERR(mvm, \"Failed to initialize D3 LAR information\\n\");\n\n\treturn 0;\n}\n\nstatic int iwl_mvm_get_last_nonqos_seq(struct iwl_mvm *mvm,\n\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_nonqos_seq_query_cmd query_cmd = {\n\t\t.get_set_flag = cpu_to_le32(IWL_NONQOS_SEQ_GET),\n\t\t.mac_id_n_color =\n\t\t\tcpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id,\n\t\t\t\t\t\t\tmvmvif->color)),\n\t};\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = NON_QOS_TX_COUNTER_CMD,\n\t\t.flags = CMD_WANT_SKB,\n\t};\n\tint err;\n\tu32 size;\n\n\tcmd.data[0] = &query_cmd;\n\tcmd.len[0] = sizeof(query_cmd);\n\n\terr = iwl_mvm_send_cmd(mvm, &cmd);\n\tif (err)\n\t\treturn err;\n\n\tsize = iwl_rx_packet_payload_len(cmd.resp_pkt);\n\tif (size < sizeof(__le16)) {\n\t\terr = -EINVAL;\n\t} else {\n\t\terr = le16_to_cpup((__le16 *)cmd.resp_pkt->data);\n\t\t \n\t\terr = (u16) (err - 0x10);\n\t}\n\n\tiwl_free_resp(&cmd);\n\treturn err;\n}\n\nvoid iwl_mvm_set_last_nonqos_seq(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_nonqos_seq_query_cmd query_cmd = {\n\t\t.get_set_flag = cpu_to_le32(IWL_NONQOS_SEQ_SET),\n\t\t.mac_id_n_color =\n\t\t\tcpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id,\n\t\t\t\t\t\t\tmvmvif->color)),\n\t\t.value = cpu_to_le16(mvmvif->seqno),\n\t};\n\n\t \n\tif (!mvmvif->seqno_valid)\n\t\treturn;\n\n\tmvmvif->seqno_valid = false;\n\n\tif (iwl_mvm_send_cmd_pdu(mvm, NON_QOS_TX_COUNTER_CMD, 0,\n\t\t\t\t sizeof(query_cmd), &query_cmd))\n\t\tIWL_ERR(mvm, \"failed to set non-QoS seqno\\n\");\n}\n\nstatic int iwl_mvm_switch_to_d3(struct iwl_mvm *mvm)\n{\n\tiwl_mvm_scan_stop(mvm, IWL_MVM_SCAN_REGULAR, true);\n\n\tiwl_mvm_stop_device(mvm);\n\t \n\tset_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status);\n\n\t \n\tmemset(mvm->fw_key_table, 0, sizeof(mvm->fw_key_table));\n\n\tmvm->ptk_ivlen = 0;\n\tmvm->ptk_icvlen = 0;\n\tmvm->ptk_ivlen = 0;\n\tmvm->ptk_icvlen = 0;\n\n\treturn iwl_mvm_load_d3_fw(mvm);\n}\n\nstatic int\niwl_mvm_get_wowlan_config(struct iwl_mvm *mvm,\n\t\t\t  struct cfg80211_wowlan *wowlan,\n\t\t\t  struct iwl_wowlan_config_cmd *wowlan_config_cmd,\n\t\t\t  struct ieee80211_vif *vif, struct iwl_mvm_vif *mvmvif,\n\t\t\t  struct ieee80211_sta *ap_sta)\n{\n\tstruct iwl_mvm_sta *mvm_ap_sta = iwl_mvm_sta_from_mac80211(ap_sta);\n\n\t \n\n\twowlan_config_cmd->is_11n_connection =\n\t\t\t\t\tap_sta->deflink.ht_cap.ht_supported;\n\twowlan_config_cmd->flags = ENABLE_L3_FILTERING |\n\t\tENABLE_NBNS_FILTERING | ENABLE_DHCP_FILTERING;\n\n\tif (iwl_fw_lookup_cmd_ver(mvm->fw, WOWLAN_CONFIGURATION, 0) < 6) {\n\t\t \n\t\tint ret = iwl_mvm_get_last_nonqos_seq(mvm, vif);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\twowlan_config_cmd->non_qos_seq = cpu_to_le16(ret);\n\t}\n\n\tiwl_mvm_set_wowlan_qos_seq(mvm_ap_sta, wowlan_config_cmd);\n\n\tif (wowlan->disconnect)\n\t\twowlan_config_cmd->wakeup_filter |=\n\t\t\tcpu_to_le32(IWL_WOWLAN_WAKEUP_BEACON_MISS |\n\t\t\t\t    IWL_WOWLAN_WAKEUP_LINK_CHANGE);\n\tif (wowlan->magic_pkt)\n\t\twowlan_config_cmd->wakeup_filter |=\n\t\t\tcpu_to_le32(IWL_WOWLAN_WAKEUP_MAGIC_PACKET);\n\tif (wowlan->gtk_rekey_failure)\n\t\twowlan_config_cmd->wakeup_filter |=\n\t\t\tcpu_to_le32(IWL_WOWLAN_WAKEUP_GTK_REKEY_FAIL);\n\tif (wowlan->eap_identity_req)\n\t\twowlan_config_cmd->wakeup_filter |=\n\t\t\tcpu_to_le32(IWL_WOWLAN_WAKEUP_EAP_IDENT_REQ);\n\tif (wowlan->four_way_handshake)\n\t\twowlan_config_cmd->wakeup_filter |=\n\t\t\tcpu_to_le32(IWL_WOWLAN_WAKEUP_4WAY_HANDSHAKE);\n\tif (wowlan->n_patterns)\n\t\twowlan_config_cmd->wakeup_filter |=\n\t\t\tcpu_to_le32(IWL_WOWLAN_WAKEUP_PATTERN_MATCH);\n\n\tif (wowlan->rfkill_release)\n\t\twowlan_config_cmd->wakeup_filter |=\n\t\t\tcpu_to_le32(IWL_WOWLAN_WAKEUP_RF_KILL_DEASSERT);\n\n\tif (wowlan->tcp) {\n\t\t \n\t\twowlan_config_cmd->wakeup_filter |=\n\t\t\tcpu_to_le32(IWL_WOWLAN_WAKEUP_REMOTE_LINK_LOSS |\n\t\t\t\t    IWL_WOWLAN_WAKEUP_REMOTE_SIGNATURE_TABLE |\n\t\t\t\t    IWL_WOWLAN_WAKEUP_REMOTE_WAKEUP_PACKET |\n\t\t\t\t    IWL_WOWLAN_WAKEUP_LINK_CHANGE);\n\t}\n\n\tif (wowlan->any) {\n\t\twowlan_config_cmd->wakeup_filter |=\n\t\t\tcpu_to_le32(IWL_WOWLAN_WAKEUP_BEACON_MISS |\n\t\t\t\t    IWL_WOWLAN_WAKEUP_LINK_CHANGE |\n\t\t\t\t    IWL_WOWLAN_WAKEUP_RX_FRAME |\n\t\t\t\t    IWL_WOWLAN_WAKEUP_BCN_FILTERING);\n\t}\n\n\treturn 0;\n}\n\nstatic int iwl_mvm_wowlan_config_key_params(struct iwl_mvm *mvm,\n\t\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tbool unified = fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t\t   IWL_UCODE_TLV_CAPA_CNSLDTD_D3_D0_IMG);\n\tstruct wowlan_key_reprogram_data key_data = {};\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tint ret;\n\tu8 cmd_ver;\n\tsize_t cmd_size;\n\n\tif (!unified) {\n\t\t \n\t\t \n\t\tieee80211_iter_keys(mvm->hw, vif, iwl_mvm_wowlan_program_keys,\n\t\t\t\t    &key_data);\n\n\t\tif (key_data.error)\n\t\t\treturn -EIO;\n\t}\n\n\tret = iwl_mvm_wowlan_config_rsc_tsc(mvm, vif);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!fw_has_api(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_API_TKIP_MIC_KEYS)) {\n\t\tint ver = iwl_fw_lookup_cmd_ver(mvm->fw, WOWLAN_TKIP_PARAM,\n\t\t\t\t\t\tIWL_FW_CMD_VER_UNKNOWN);\n\t\tstruct wowlan_key_tkip_data tkip_data = {};\n\t\tint size;\n\n\t\tif (ver == 2) {\n\t\t\tsize = sizeof(tkip_data.tkip);\n\t\t\ttkip_data.tkip.sta_id =\n\t\t\t\tcpu_to_le32(mvmvif->deflink.ap_sta_id);\n\t\t} else if (ver == 1 || ver == IWL_FW_CMD_VER_UNKNOWN) {\n\t\t\tsize = sizeof(struct iwl_wowlan_tkip_params_cmd_ver_1);\n\t\t} else {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tieee80211_iter_keys(mvm->hw, vif, iwl_mvm_wowlan_get_tkip_data,\n\t\t\t\t    &tkip_data);\n\n\t\tif (tkip_data.have_tkip_keys) {\n\t\t\t \n\t\t\tret = iwl_mvm_send_cmd_pdu(mvm,\n\t\t\t\t\t\t   WOWLAN_TKIP_PARAM,\n\t\t\t\t\t\t   CMD_ASYNC, size,\n\t\t\t\t\t\t   &tkip_data.tkip);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (mvmvif->rekey_data.valid) {\n\t\tstruct iwl_wowlan_kek_kck_material_cmd_v4 kek_kck_cmd = {};\n\t\tstruct iwl_wowlan_kek_kck_material_cmd_v4 *_kek_kck_cmd =\n\t\t\t&kek_kck_cmd;\n\t\tstruct wowlan_key_gtk_type_iter gtk_type_data = {\n\t\t\t.kek_kck_cmd = _kek_kck_cmd,\n\t\t};\n\n\t\tcmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw,\n\t\t\t\t\t\tWOWLAN_KEK_KCK_MATERIAL,\n\t\t\t\t\t\tIWL_FW_CMD_VER_UNKNOWN);\n\t\tif (WARN_ON(cmd_ver != 2 && cmd_ver != 3 && cmd_ver != 4 &&\n\t\t\t    cmd_ver != IWL_FW_CMD_VER_UNKNOWN))\n\t\t\treturn -EINVAL;\n\n\t\tieee80211_iter_keys(mvm->hw, vif, iwl_mvm_wowlan_gtk_type_iter,\n\t\t\t\t    &gtk_type_data);\n\n\t\tmemcpy(kek_kck_cmd.kck, mvmvif->rekey_data.kck,\n\t\t       mvmvif->rekey_data.kck_len);\n\t\tkek_kck_cmd.kck_len = cpu_to_le16(mvmvif->rekey_data.kck_len);\n\t\tmemcpy(kek_kck_cmd.kek, mvmvif->rekey_data.kek,\n\t\t       mvmvif->rekey_data.kek_len);\n\t\tkek_kck_cmd.kek_len = cpu_to_le16(mvmvif->rekey_data.kek_len);\n\t\tkek_kck_cmd.replay_ctr = mvmvif->rekey_data.replay_ctr;\n\t\tkek_kck_cmd.akm = cpu_to_le32(mvmvif->rekey_data.akm);\n\t\tkek_kck_cmd.sta_id = cpu_to_le32(mvmvif->deflink.ap_sta_id);\n\n\t\tif (cmd_ver == 4) {\n\t\t\tcmd_size = sizeof(struct iwl_wowlan_kek_kck_material_cmd_v4);\n\t\t} else {\n\t\t\tif (cmd_ver == 3)\n\t\t\t\tcmd_size =\n\t\t\t\t\tsizeof(struct iwl_wowlan_kek_kck_material_cmd_v3);\n\t\t\telse\n\t\t\t\tcmd_size =\n\t\t\t\t\tsizeof(struct iwl_wowlan_kek_kck_material_cmd_v2);\n\t\t\t \n\t\t\t_kek_kck_cmd = (void *)\n\t\t\t\t((u8 *)_kek_kck_cmd + sizeof(kek_kck_cmd.sta_id));\n\t\t}\n\n\t\tIWL_DEBUG_WOWLAN(mvm, \"setting akm %d\\n\",\n\t\t\t\t mvmvif->rekey_data.akm);\n\n\t\tret = iwl_mvm_send_cmd_pdu(mvm, WOWLAN_KEK_KCK_MATERIAL,\n\t\t\t\t\t   CMD_ASYNC, cmd_size, _kek_kck_cmd);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int\niwl_mvm_wowlan_config(struct iwl_mvm *mvm,\n\t\t      struct cfg80211_wowlan *wowlan,\n\t\t      struct iwl_wowlan_config_cmd *wowlan_config_cmd,\n\t\t      struct ieee80211_vif *vif, struct iwl_mvm_vif *mvmvif,\n\t\t      struct ieee80211_sta *ap_sta)\n{\n\tint ret;\n\tbool unified_image = fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t\t\t IWL_UCODE_TLV_CAPA_CNSLDTD_D3_D0_IMG);\n\n\tmvm->offload_tid = wowlan_config_cmd->offloading_tid;\n\n\tif (!unified_image) {\n\t\tret = iwl_mvm_switch_to_d3(mvm);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = iwl_mvm_d3_reprogram(mvm, vif, ap_sta);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tmutex_unlock(&mvm->mutex);\n\tret = iwl_mvm_wowlan_config_key_params(mvm, vif);\n\tmutex_lock(&mvm->mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tret = iwl_mvm_send_cmd_pdu(mvm, WOWLAN_CONFIGURATION, 0,\n\t\t\t\t   sizeof(*wowlan_config_cmd),\n\t\t\t\t   wowlan_config_cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tif (fw_has_api(&mvm->fw->ucode_capa,\n\t\t       IWL_UCODE_TLV_API_WOWLAN_TCP_SYN_WAKE))\n\t\tret = iwl_mvm_send_patterns(mvm, vif, wowlan);\n\telse\n\t\tret = iwl_mvm_send_patterns_v1(mvm, wowlan);\n\tif (ret)\n\t\treturn ret;\n\n\treturn iwl_mvm_send_proto_offload(mvm, vif, false, true, 0);\n}\n\nstatic int\niwl_mvm_netdetect_config(struct iwl_mvm *mvm,\n\t\t\t struct cfg80211_wowlan *wowlan,\n\t\t\t struct cfg80211_sched_scan_request *nd_config,\n\t\t\t struct ieee80211_vif *vif)\n{\n\tint ret;\n\tbool unified_image = fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t\t\t IWL_UCODE_TLV_CAPA_CNSLDTD_D3_D0_IMG);\n\n\tif (!unified_image) {\n\t\tret = iwl_mvm_switch_to_d3(mvm);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\t \n\t\tret = iwl_mvm_scan_stop(mvm, IWL_MVM_SCAN_SCHED, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = iwl_mvm_sched_scan_start(mvm, vif, nd_config, &mvm->nd_ies,\n\t\t\t\t       IWL_MVM_SCAN_NETDETECT);\n\tif (ret)\n\t\treturn ret;\n\n\tif (WARN_ON(mvm->nd_match_sets || mvm->nd_channels))\n\t\treturn -EBUSY;\n\n\t \n\tif (nd_config->n_match_sets) {\n\t\tmvm->nd_match_sets = kmemdup(nd_config->match_sets,\n\t\t\t\t\t     sizeof(*nd_config->match_sets) *\n\t\t\t\t\t     nd_config->n_match_sets,\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (mvm->nd_match_sets)\n\t\t\tmvm->n_nd_match_sets = nd_config->n_match_sets;\n\t}\n\n\t \n\tmvm->nd_channels = kmemdup(nd_config->channels,\n\t\t\t\t   sizeof(*nd_config->channels) *\n\t\t\t\t   nd_config->n_channels,\n\t\t\t\t   GFP_KERNEL);\n\tif (mvm->nd_channels)\n\t\tmvm->n_nd_channels = nd_config->n_channels;\n\n\treturn 0;\n}\n\nstatic void iwl_mvm_free_nd(struct iwl_mvm *mvm)\n{\n\tkfree(mvm->nd_match_sets);\n\tmvm->nd_match_sets = NULL;\n\tmvm->n_nd_match_sets = 0;\n\tkfree(mvm->nd_channels);\n\tmvm->nd_channels = NULL;\n\tmvm->n_nd_channels = 0;\n}\n\nstatic int __iwl_mvm_suspend(struct ieee80211_hw *hw,\n\t\t\t     struct cfg80211_wowlan *wowlan,\n\t\t\t     bool test)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct ieee80211_vif *vif = NULL;\n\tstruct iwl_mvm_vif *mvmvif = NULL;\n\tstruct ieee80211_sta *ap_sta = NULL;\n\tstruct iwl_d3_manager_config d3_cfg_cmd_data = {\n\t\t \n\t\t.min_sleep_time = cpu_to_le32(10 * 1000 * 1000),\n\t};\n\tstruct iwl_host_cmd d3_cfg_cmd = {\n\t\t.id = D3_CONFIG_CMD,\n\t\t.flags = CMD_WANT_SKB | CMD_SEND_IN_D3,\n\t\t.data[0] = &d3_cfg_cmd_data,\n\t\t.len[0] = sizeof(d3_cfg_cmd_data),\n\t};\n\tint ret;\n\tint len __maybe_unused;\n\tbool unified_image = fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t\t\t IWL_UCODE_TLV_CAPA_CNSLDTD_D3_D0_IMG);\n\n\tif (!wowlan) {\n\t\t \n\t\tWARN_ON(!test);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&mvm->mutex);\n\n\tset_bit(IWL_MVM_STATUS_IN_D3, &mvm->status);\n\n\tsynchronize_net();\n\n\tvif = iwl_mvm_get_bss_vif(mvm);\n\tif (IS_ERR_OR_NULL(vif)) {\n\t\tret = 1;\n\t\tgoto out_noreset;\n\t}\n\n\tmvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tif (mvmvif->deflink.ap_sta_id == IWL_MVM_INVALID_STA) {\n\t\t \n\t\tif (!wowlan->nd_config) {\n\t\t\tret = 1;\n\t\t\tgoto out_noreset;\n\t\t}\n\n\t\tret = iwl_mvm_netdetect_config(\n\t\t\tmvm, wowlan, wowlan->nd_config, vif);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tmvm->net_detect = true;\n\t} else {\n\t\tstruct iwl_wowlan_config_cmd wowlan_config_cmd = {};\n\n\t\twowlan_config_cmd.sta_id = mvmvif->deflink.ap_sta_id;\n\n\t\tap_sta = rcu_dereference_protected(\n\t\t\tmvm->fw_id_to_mac_id[mvmvif->deflink.ap_sta_id],\n\t\t\tlockdep_is_held(&mvm->mutex));\n\t\tif (IS_ERR_OR_NULL(ap_sta)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_noreset;\n\t\t}\n\n\t\tret = iwl_mvm_get_wowlan_config(mvm, wowlan, &wowlan_config_cmd,\n\t\t\t\t\t\tvif, mvmvif, ap_sta);\n\t\tif (ret)\n\t\t\tgoto out_noreset;\n\t\tret = iwl_mvm_wowlan_config(mvm, wowlan, &wowlan_config_cmd,\n\t\t\t\t\t    vif, mvmvif, ap_sta);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tmvm->net_detect = false;\n\t}\n\n\tret = iwl_mvm_power_update_device(mvm);\n\tif (ret)\n\t\tgoto out;\n\n\tret = iwl_mvm_power_update_mac(mvm);\n\tif (ret)\n\t\tgoto out;\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tif (mvm->d3_wake_sysassert)\n\t\td3_cfg_cmd_data.wakeup_flags |=\n\t\t\tcpu_to_le32(IWL_WAKEUP_D3_CONFIG_FW_ERROR);\n#endif\n\n\t \n\tif (mvm->trans->trans_cfg->device_family < IWL_DEVICE_FAMILY_9000)\n\t\tiwl_fw_dbg_stop_restart_recording(&mvm->fwrt, NULL, true);\n\n\tmvm->trans->system_pm_mode = IWL_PLAT_PM_MODE_D3;\n\n\t \n\tret = iwl_mvm_send_cmd(mvm, &d3_cfg_cmd);\n\tif (ret)\n\t\tgoto out;\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tlen = iwl_rx_packet_payload_len(d3_cfg_cmd.resp_pkt);\n\tif (len >= sizeof(u32)) {\n\t\tmvm->d3_test_pme_ptr =\n\t\t\tle32_to_cpup((__le32 *)d3_cfg_cmd.resp_pkt->data);\n\t}\n#endif\n\tiwl_free_resp(&d3_cfg_cmd);\n\n\tclear_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status);\n\n\tret = iwl_trans_d3_suspend(mvm->trans, test, !unified_image);\n out:\n\tif (ret < 0) {\n\t\tiwl_mvm_free_nd(mvm);\n\n\t\tif (!unified_image) {\n\t\t\tif (mvm->fw_restart > 0) {\n\t\t\t\tmvm->fw_restart--;\n\t\t\t\tieee80211_restart_hw(mvm->hw);\n\t\t\t}\n\t\t}\n\n\t\tclear_bit(IWL_MVM_STATUS_IN_D3, &mvm->status);\n\t}\n out_noreset:\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret;\n}\n\nint iwl_mvm_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\tiwl_mvm_pause_tcm(mvm, true);\n\n\tiwl_fw_runtime_suspend(&mvm->fwrt);\n\n\treturn __iwl_mvm_suspend(hw, wowlan, false);\n}\n\nstruct iwl_multicast_key_data {\n\tu8 key[WOWLAN_KEY_MAX_SIZE];\n\tu8 len;\n\tu8 flags;\n\tu8 id;\n\tu8 ipn[6];\n};\n\n \nstruct iwl_wowlan_status_data {\n\tu64 replay_ctr;\n\tu32 num_of_gtk_rekeys;\n\tu32 received_beacons;\n\tu32 wakeup_reasons;\n\tu32 wake_packet_length;\n\tu32 wake_packet_bufsize;\n\tu16 pattern_number;\n\tu16 non_qos_seq_ctr;\n\tu16 qos_seq_ctr[8];\n\tu8 tid_tear_down;\n\n\tstruct {\n\t\t \n\t\tu8 key[WOWLAN_KEY_MAX_SIZE];\n\t\tu8 len;\n\t\tu8 flags;\n\t\tu8 id;\n\t} gtk[WOWLAN_GTK_KEYS_NUM];\n\n\tstruct {\n\t\t \n\t\tstruct {\n\t\t\tstruct ieee80211_key_seq seq[IWL_MAX_TID_COUNT];\n\t\t} tkip, aes;\n\n\t\t \n\t\ts8 key_id;\n\t\tbool valid;\n\t} gtk_seq[2];\n\n\tstruct {\n\t\t \n\t\tstruct {\n\t\t\tstruct ieee80211_key_seq seq[IWL_MAX_TID_COUNT];\n\t\t\tu64 tx_pn;\n\t\t} tkip, aes;\n\t} ptk;\n\n\tstruct iwl_multicast_key_data igtk;\n\n\tu8 *wake_packet;\n};\n\nstatic void iwl_mvm_report_wakeup_reasons(struct iwl_mvm *mvm,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  struct iwl_wowlan_status_data *status)\n{\n\tstruct sk_buff *pkt = NULL;\n\tstruct cfg80211_wowlan_wakeup wakeup = {\n\t\t.pattern_idx = -1,\n\t};\n\tstruct cfg80211_wowlan_wakeup *wakeup_report = &wakeup;\n\tu32 reasons = status->wakeup_reasons;\n\n\tif (reasons == IWL_WOWLAN_WAKEUP_BY_NON_WIRELESS) {\n\t\twakeup_report = NULL;\n\t\tgoto report;\n\t}\n\n\tpm_wakeup_event(mvm->dev, 0);\n\n\tif (reasons & IWL_WOWLAN_WAKEUP_BY_MAGIC_PACKET)\n\t\twakeup.magic_pkt = true;\n\n\tif (reasons & IWL_WOWLAN_WAKEUP_BY_PATTERN)\n\t\twakeup.pattern_idx =\n\t\t\tstatus->pattern_number;\n\n\tif (reasons & (IWL_WOWLAN_WAKEUP_BY_DISCONNECTION_ON_MISSED_BEACON |\n\t\t       IWL_WOWLAN_WAKEUP_BY_DISCONNECTION_ON_DEAUTH))\n\t\twakeup.disconnect = true;\n\n\tif (reasons & IWL_WOWLAN_WAKEUP_BY_GTK_REKEY_FAILURE)\n\t\twakeup.gtk_rekey_failure = true;\n\n\tif (reasons & IWL_WOWLAN_WAKEUP_BY_RFKILL_DEASSERTED)\n\t\twakeup.rfkill_release = true;\n\n\tif (reasons & IWL_WOWLAN_WAKEUP_BY_EAPOL_REQUEST)\n\t\twakeup.eap_identity_req = true;\n\n\tif (reasons & IWL_WOWLAN_WAKEUP_BY_FOUR_WAY_HANDSHAKE)\n\t\twakeup.four_way_handshake = true;\n\n\tif (reasons & IWL_WOWLAN_WAKEUP_BY_REM_WAKE_LINK_LOSS)\n\t\twakeup.tcp_connlost = true;\n\n\tif (reasons & IWL_WOWLAN_WAKEUP_BY_REM_WAKE_SIGNATURE_TABLE)\n\t\twakeup.tcp_nomoretokens = true;\n\n\tif (reasons & IWL_WOWLAN_WAKEUP_BY_REM_WAKE_WAKEUP_PACKET)\n\t\twakeup.tcp_match = true;\n\n\tif (status->wake_packet) {\n\t\tint pktsize = status->wake_packet_bufsize;\n\t\tint pktlen = status->wake_packet_length;\n\t\tconst u8 *pktdata = status->wake_packet;\n\t\tconst struct ieee80211_hdr *hdr = (const void *)pktdata;\n\t\tint truncated = pktlen - pktsize;\n\n\t\t \n\t\tif (WARN_ON_ONCE(truncated < 0))\n\t\t\ttruncated = 0;\n\n\t\tif (ieee80211_is_data(hdr->frame_control)) {\n\t\t\tint hdrlen = ieee80211_hdrlen(hdr->frame_control);\n\t\t\tint ivlen = 0, icvlen = 4;  \n\n\t\t\tpkt = alloc_skb(pktsize, GFP_KERNEL);\n\t\t\tif (!pkt)\n\t\t\t\tgoto report;\n\n\t\t\tskb_put_data(pkt, pktdata, hdrlen);\n\t\t\tpktdata += hdrlen;\n\t\t\tpktsize -= hdrlen;\n\n\t\t\tif (ieee80211_has_protected(hdr->frame_control)) {\n\t\t\t\t \n\t\t\t\tif (is_multicast_ether_addr(hdr->addr1)) {\n\t\t\t\t\tivlen = mvm->gtk_ivlen;\n\t\t\t\t\ticvlen += mvm->gtk_icvlen;\n\t\t\t\t} else {\n\t\t\t\t\tivlen = mvm->ptk_ivlen;\n\t\t\t\t\ticvlen += mvm->ptk_icvlen;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (truncated >= icvlen) {\n\t\t\t\ticvlen = 0;\n\t\t\t\ttruncated -= icvlen;\n\t\t\t} else {\n\t\t\t\ticvlen -= truncated;\n\t\t\t\ttruncated = 0;\n\t\t\t}\n\n\t\t\tpktsize -= ivlen + icvlen;\n\t\t\tpktdata += ivlen;\n\n\t\t\tskb_put_data(pkt, pktdata, pktsize);\n\n\t\t\tif (ieee80211_data_to_8023(pkt, vif->addr, vif->type))\n\t\t\t\tgoto report;\n\t\t\twakeup.packet = pkt->data;\n\t\t\twakeup.packet_present_len = pkt->len;\n\t\t\twakeup.packet_len = pkt->len - truncated;\n\t\t\twakeup.packet_80211 = false;\n\t\t} else {\n\t\t\tint fcslen = 4;\n\n\t\t\tif (truncated >= 4) {\n\t\t\t\ttruncated -= 4;\n\t\t\t\tfcslen = 0;\n\t\t\t} else {\n\t\t\t\tfcslen -= truncated;\n\t\t\t\ttruncated = 0;\n\t\t\t}\n\t\t\tpktsize -= fcslen;\n\t\t\twakeup.packet = status->wake_packet;\n\t\t\twakeup.packet_present_len = pktsize;\n\t\t\twakeup.packet_len = pktlen - truncated;\n\t\t\twakeup.packet_80211 = true;\n\t\t}\n\t}\n\n report:\n\tieee80211_report_wowlan_wakeup(vif, wakeup_report, GFP_KERNEL);\n\tkfree_skb(pkt);\n}\n\nstatic void iwl_mvm_le64_to_aes_seq(__le64 le_pn, struct ieee80211_key_seq *seq)\n{\n\tu64 pn = le64_to_cpu(le_pn);\n\n\tseq->ccmp.pn[0] = pn >> 40;\n\tseq->ccmp.pn[1] = pn >> 32;\n\tseq->ccmp.pn[2] = pn >> 24;\n\tseq->ccmp.pn[3] = pn >> 16;\n\tseq->ccmp.pn[4] = pn >> 8;\n\tseq->ccmp.pn[5] = pn;\n}\n\nstatic void iwl_mvm_aes_sc_to_seq(struct aes_sc *sc,\n\t\t\t\t  struct ieee80211_key_seq *seq)\n{\n\tiwl_mvm_le64_to_aes_seq(sc->pn, seq);\n}\n\nstatic void iwl_mvm_le64_to_tkip_seq(__le64 le_pn, struct ieee80211_key_seq *seq)\n{\n\tu64 pn = le64_to_cpu(le_pn);\n\n\tseq->tkip.iv16 = (u16)pn;\n\tseq->tkip.iv32 = (u32)(pn >> 16);\n}\n\nstatic void iwl_mvm_tkip_sc_to_seq(struct tkip_sc *sc,\n\t\t\t\t   struct ieee80211_key_seq *seq)\n{\n\tseq->tkip.iv32 = le32_to_cpu(sc->iv32);\n\tseq->tkip.iv16 = le16_to_cpu(sc->iv16);\n}\n\nstatic void iwl_mvm_set_key_rx_seq_tids(struct ieee80211_key_conf *key,\n\t\t\t\t\tstruct ieee80211_key_seq *seq)\n{\n\tint tid;\n\n\tfor (tid = 0; tid < IWL_MAX_TID_COUNT; tid++)\n\t\tieee80211_set_key_rx_seq(key, tid, &seq[tid]);\n}\n\nstatic void iwl_mvm_set_aes_ptk_rx_seq(struct iwl_mvm *mvm,\n\t\t\t\t       struct iwl_wowlan_status_data *status,\n\t\t\t\t       struct ieee80211_sta *sta,\n\t\t\t\t       struct ieee80211_key_conf *key)\n{\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_mvm_key_pn *ptk_pn;\n\tint tid;\n\n\tiwl_mvm_set_key_rx_seq_tids(key, status->ptk.aes.seq);\n\n\tif (!iwl_mvm_has_new_rx_api(mvm))\n\t\treturn;\n\n\n\trcu_read_lock();\n\tptk_pn = rcu_dereference(mvmsta->ptk_pn[key->keyidx]);\n\tif (WARN_ON(!ptk_pn)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tfor (tid = 0; tid < IWL_MAX_TID_COUNT; tid++) {\n\t\tint i;\n\n\t\tfor (i = 1; i < mvm->trans->num_rx_queues; i++)\n\t\t\tmemcpy(ptk_pn->q[i].pn[tid],\n\t\t\t       status->ptk.aes.seq[tid].ccmp.pn,\n\t\t\t       IEEE80211_CCMP_PN_LEN);\n\t}\n\trcu_read_unlock();\n}\n\nstatic void iwl_mvm_convert_key_counters(struct iwl_wowlan_status_data *status,\n\t\t\t\t\t union iwl_all_tsc_rsc *sc)\n{\n\tint i;\n\n\tBUILD_BUG_ON(IWL_MAX_TID_COUNT > IWL_MAX_TID_COUNT);\n\tBUILD_BUG_ON(IWL_MAX_TID_COUNT > IWL_NUM_RSC);\n\n\t \n\tfor (i = 0; i < IWL_MAX_TID_COUNT; i++) {\n\t\tiwl_mvm_tkip_sc_to_seq(&sc->tkip.multicast_rsc[i],\n\t\t\t\t       &status->gtk_seq[0].tkip.seq[i]);\n\t\tiwl_mvm_aes_sc_to_seq(&sc->aes.multicast_rsc[i],\n\t\t\t\t      &status->gtk_seq[0].aes.seq[i]);\n\t}\n\tstatus->gtk_seq[0].valid = true;\n\tstatus->gtk_seq[0].key_id = -1;\n\n\t \n\tstatus->ptk.tkip.tx_pn = (u64)le16_to_cpu(sc->tkip.tsc.iv16) |\n\t\t\t\t ((u64)le32_to_cpu(sc->tkip.tsc.iv32) << 16);\n\tstatus->ptk.aes.tx_pn = le64_to_cpu(sc->aes.tsc.pn);\n\n\t \n\tfor (i = 0; i < IWL_MAX_TID_COUNT; i++) {\n\t\tiwl_mvm_tkip_sc_to_seq(&sc->tkip.unicast_rsc[i],\n\t\t\t\t       &status->ptk.tkip.seq[i]);\n\t\tiwl_mvm_aes_sc_to_seq(&sc->aes.unicast_rsc[i],\n\t\t\t\t      &status->ptk.aes.seq[i]);\n\t}\n}\n\nstatic void\niwl_mvm_convert_key_counters_v5_gtk_seq(struct iwl_wowlan_status_data *status,\n\t\t\t\t\tstruct iwl_wowlan_all_rsc_tsc_v5 *sc,\n\t\t\t\t\tunsigned int idx, unsigned int key_id)\n{\n\tint tid;\n\n\tfor (tid = 0; tid < IWL_MAX_TID_COUNT; tid++) {\n\t\tiwl_mvm_le64_to_tkip_seq(sc->mcast_rsc[idx][tid],\n\t\t\t\t\t &status->gtk_seq[idx].tkip.seq[tid]);\n\t\tiwl_mvm_le64_to_aes_seq(sc->mcast_rsc[idx][tid],\n\t\t\t\t\t&status->gtk_seq[idx].aes.seq[tid]);\n\t}\n\n\tstatus->gtk_seq[idx].valid = true;\n\tstatus->gtk_seq[idx].key_id = key_id;\n}\n\nstatic void\niwl_mvm_convert_key_counters_v5(struct iwl_wowlan_status_data *status,\n\t\t\t\tstruct iwl_wowlan_all_rsc_tsc_v5 *sc)\n{\n\tint i, tid;\n\n\tBUILD_BUG_ON(IWL_MAX_TID_COUNT > IWL_MAX_TID_COUNT);\n\tBUILD_BUG_ON(IWL_MAX_TID_COUNT > IWL_NUM_RSC);\n\tBUILD_BUG_ON(ARRAY_SIZE(sc->mcast_rsc) != ARRAY_SIZE(status->gtk_seq));\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(sc->mcast_key_id_map); i++) {\n\t\tu8 entry = sc->mcast_key_id_map[i];\n\n\t\tif (entry < ARRAY_SIZE(sc->mcast_rsc))\n\t\t\tiwl_mvm_convert_key_counters_v5_gtk_seq(status, sc,\n\t\t\t\t\t\t\t\tentry, i);\n\t}\n\n\t \n\n\t \n\tfor (tid = 0; tid < IWL_MAX_TID_COUNT; tid++) {\n\t\tiwl_mvm_le64_to_tkip_seq(sc->ucast_rsc[tid],\n\t\t\t\t\t &status->ptk.tkip.seq[tid]);\n\t\tiwl_mvm_le64_to_aes_seq(sc->ucast_rsc[tid],\n\t\t\t\t\t&status->ptk.aes.seq[tid]);\n\t}\n}\n\nstatic void iwl_mvm_set_key_rx_seq_idx(struct ieee80211_key_conf *key,\n\t\t\t\t       struct iwl_wowlan_status_data *status,\n\t\t\t\t       int idx)\n{\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\tiwl_mvm_set_key_rx_seq_tids(key, status->gtk_seq[idx].aes.seq);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tiwl_mvm_set_key_rx_seq_tids(key, status->gtk_seq[idx].tkip.seq);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n}\n\nstatic void iwl_mvm_set_key_rx_seq(struct ieee80211_key_conf *key,\n\t\t\t\t   struct iwl_wowlan_status_data *status,\n\t\t\t\t   bool installed)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(status->gtk_seq); i++) {\n\t\tif (!status->gtk_seq[i].valid)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (status->gtk_seq[i].key_id == key->keyidx) {\n\t\t\ts8 new_key_id = -1;\n\n\t\t\tif (status->num_of_gtk_rekeys)\n\t\t\t\tnew_key_id = status->gtk[0].flags &\n\t\t\t\t\t\tIWL_WOWLAN_GTK_IDX_MASK;\n\n\t\t\t \n\t\t\tif (new_key_id != key->keyidx)\n\t\t\t\tiwl_mvm_set_key_rx_seq_idx(key, status, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (status->gtk_seq[i].key_id == -1 &&\n\t\t    (!status->num_of_gtk_rekeys || installed))\n\t\t\tiwl_mvm_set_key_rx_seq_idx(key, status, i);\n\t}\n}\n\nstruct iwl_mvm_d3_gtk_iter_data {\n\tstruct iwl_mvm *mvm;\n\tstruct iwl_wowlan_status_data *status;\n\tu32 gtk_cipher, igtk_cipher;\n\tbool unhandled_cipher, igtk_support;\n\tint num_keys;\n};\n\nstatic void iwl_mvm_d3_find_last_keys(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      struct ieee80211_key_conf *key,\n\t\t\t\t      void *_data)\n{\n\tstruct iwl_mvm_d3_gtk_iter_data *data = _data;\n\n\tif (data->unhandled_cipher)\n\t\treturn;\n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\t \n\t\treturn;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t \n\t\tdata->gtk_cipher = key->cipher;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\t \n\t\tif (data->igtk_support &&\n\t\t    (key->keyidx == 4 || key->keyidx == 5)) {\n\t\t\tdata->igtk_cipher = key->cipher;\n\t\t} else {\n\t\t\tdata->unhandled_cipher = true;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdata->unhandled_cipher = true;\n\t\treturn;\n\t}\n\n\tdata->num_keys++;\n}\n\nstatic void\niwl_mvm_d3_set_igtk_bigtk_ipn(const struct iwl_multicast_key_data *key,\n\t\t\t      struct ieee80211_key_seq *seq, u32 cipher)\n{\n\tswitch (cipher) {\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\tBUILD_BUG_ON(sizeof(seq->aes_gmac.pn) != sizeof(key->ipn));\n\t\tmemcpy(seq->aes_gmac.pn, key->ipn, sizeof(seq->aes_gmac.pn));\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\t\tBUILD_BUG_ON(sizeof(seq->aes_cmac.pn) != sizeof(key->ipn));\n\t\tmemcpy(seq->aes_cmac.pn, key->ipn, sizeof(seq->aes_cmac.pn));\n\t\tbreak;\n\t}\n}\n\nstatic void iwl_mvm_d3_update_keys(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   struct ieee80211_key_conf *key,\n\t\t\t\t   void *_data)\n{\n\tstruct iwl_mvm_d3_gtk_iter_data *data = _data;\n\tstruct iwl_wowlan_status_data *status = data->status;\n\ts8 keyidx;\n\n\tif (data->unhandled_cipher)\n\t\treturn;\n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\t \n\t\treturn;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\tif (sta) {\n\t\t\tatomic64_set(&key->tx_pn, status->ptk.aes.tx_pn);\n\t\t\tiwl_mvm_set_aes_ptk_rx_seq(data->mvm, status, sta, key);\n\t\t\treturn;\n\t\t}\n\t\tfallthrough;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tif (sta) {\n\t\t\tatomic64_set(&key->tx_pn, status->ptk.tkip.tx_pn);\n\t\t\tiwl_mvm_set_key_rx_seq_tids(key, status->ptk.tkip.seq);\n\t\t\treturn;\n\t\t}\n\t\tkeyidx = key->keyidx;\n\t\t \n\t\tif (status->num_of_gtk_rekeys &&\n\t\t    ((status->gtk[0].len && keyidx == status->gtk[0].id) ||\n\t\t     (status->gtk[1].len && keyidx == status->gtk[1].id))) {\n\t\t\tieee80211_remove_key(key);\n\t\t} else {\n\t\t\tiwl_mvm_set_key_rx_seq(key, data->status, false);\n\t\t}\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\tif (key->keyidx == 4 || key->keyidx == 5) {\n\t\t\t \n\t\t\tif (status->num_of_gtk_rekeys) {\n\t\t\t\tieee80211_remove_key(key);\n\t\t\t} else {\n\t\t\t\tstruct ieee80211_key_seq seq;\n\n\t\t\t\tiwl_mvm_d3_set_igtk_bigtk_ipn(&status->igtk,\n\t\t\t\t\t\t\t      &seq,\n\t\t\t\t\t\t\t      key->cipher);\n\t\t\t\tieee80211_set_key_rx_seq(key, 0, &seq);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic bool iwl_mvm_gtk_rekey(struct iwl_wowlan_status_data *status,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct iwl_mvm *mvm, u32 gtk_cipher)\n{\n\tint i;\n\tstruct ieee80211_key_conf *key;\n\tstruct {\n\t\tstruct ieee80211_key_conf conf;\n\t\tu8 key[32];\n\t} conf = {\n\t\t.conf.cipher = gtk_cipher,\n\t};\n\n\tBUILD_BUG_ON(WLAN_KEY_LEN_CCMP != WLAN_KEY_LEN_GCMP);\n\tBUILD_BUG_ON(sizeof(conf.key) < WLAN_KEY_LEN_CCMP);\n\tBUILD_BUG_ON(sizeof(conf.key) < WLAN_KEY_LEN_GCMP_256);\n\tBUILD_BUG_ON(sizeof(conf.key) < WLAN_KEY_LEN_TKIP);\n\tBUILD_BUG_ON(sizeof(conf.key) < sizeof(status->gtk[0].key));\n\n\tswitch (gtk_cipher) {\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\t\tconf.conf.keylen = WLAN_KEY_LEN_CCMP;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\tconf.conf.keylen = WLAN_KEY_LEN_GCMP_256;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tconf.conf.keylen = WLAN_KEY_LEN_TKIP;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(status->gtk); i++) {\n\t\tif (!status->gtk[i].len)\n\t\t\tcontinue;\n\n\t\tconf.conf.keyidx = status->gtk[i].id;\n\t\tIWL_DEBUG_WOWLAN(mvm,\n\t\t\t\t \"Received from FW GTK cipher %d, key index %d\\n\",\n\t\t\t\t conf.conf.cipher, conf.conf.keyidx);\n\t\tmemcpy(conf.conf.key, status->gtk[i].key,\n\t\t       sizeof(status->gtk[i].key));\n\n\t\tkey = ieee80211_gtk_rekey_add(vif, &conf.conf);\n\t\tif (IS_ERR(key))\n\t\t\treturn false;\n\t\tiwl_mvm_set_key_rx_seq_idx(key, status, i);\n\t}\n\n\treturn true;\n}\n\nstatic bool\niwl_mvm_d3_igtk_bigtk_rekey_add(struct iwl_wowlan_status_data *status,\n\t\t\t\tstruct ieee80211_vif *vif, u32 cipher,\n\t\t\t\tstruct iwl_multicast_key_data *key_data)\n{\n\tstruct ieee80211_key_conf *key_config;\n\tstruct {\n\t\tstruct ieee80211_key_conf conf;\n\t\tu8 key[WOWLAN_KEY_MAX_SIZE];\n\t} conf = {\n\t\t.conf.cipher = cipher,\n\t\t.conf.keyidx = key_data->id,\n\t};\n\tstruct ieee80211_key_seq seq;\n\n\tif (!key_data->len)\n\t\treturn true;\n\n\tiwl_mvm_d3_set_igtk_bigtk_ipn(key_data, &seq, conf.conf.cipher);\n\n\tswitch (cipher) {\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\t\tconf.conf.keylen = WLAN_KEY_LEN_BIP_GMAC_128;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\tconf.conf.keylen = WLAN_KEY_LEN_BIP_GMAC_256;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\tconf.conf.keylen = WLAN_KEY_LEN_AES_CMAC;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\t\tconf.conf.keylen = WLAN_KEY_LEN_BIP_CMAC_256;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\tBUILD_BUG_ON(sizeof(conf.key) < sizeof(key_data->key));\n\tmemcpy(conf.conf.key, key_data->key, conf.conf.keylen);\n\n\tkey_config = ieee80211_gtk_rekey_add(vif, &conf.conf);\n\tif (IS_ERR(key_config))\n\t\treturn false;\n\tieee80211_set_key_rx_seq(key_config, 0, &seq);\n\n\tif (key_config->keyidx == 4 || key_config->keyidx == 5) {\n\t\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\t\tint link_id = vif->active_links ? __ffs(vif->active_links) : 0;\n\t\tstruct iwl_mvm_vif_link_info *mvm_link =\n\t\t\tmvmvif->link[link_id];\n\n\t\tmvm_link->igtk = key_config;\n\t}\n\n\treturn true;\n}\n\nstatic int iwl_mvm_lookup_wowlan_status_ver(struct iwl_mvm *mvm)\n{\n\tu8 notif_ver;\n\n\tif (!fw_has_api(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_API_WOWLAN_KEY_MATERIAL))\n\t\treturn 6;\n\n\t \n\tnotif_ver = iwl_fw_lookup_notif_ver(mvm->fw, LONG_GROUP,\n\t\t\t\t\t    WOWLAN_GET_STATUSES, 0);\n\tif (!notif_ver)\n\t\tnotif_ver = iwl_fw_lookup_notif_ver(mvm->fw, LEGACY_GROUP,\n\t\t\t\t\t\t    WOWLAN_GET_STATUSES, 7);\n\n\treturn notif_ver;\n}\n\nstatic bool iwl_mvm_setup_connection_keep(struct iwl_mvm *mvm,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  struct iwl_wowlan_status_data *status)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_d3_gtk_iter_data gtkdata = {\n\t\t.mvm = mvm,\n\t\t.status = status,\n\t};\n\tu32 disconnection_reasons =\n\t\tIWL_WOWLAN_WAKEUP_BY_DISCONNECTION_ON_MISSED_BEACON |\n\t\tIWL_WOWLAN_WAKEUP_BY_DISCONNECTION_ON_DEAUTH;\n\n\tif (!status || !vif->bss_conf.bssid)\n\t\treturn false;\n\n\tif (status->wakeup_reasons & disconnection_reasons)\n\t\treturn false;\n\n\tif (iwl_mvm_lookup_wowlan_status_ver(mvm) > 6 ||\n\t    iwl_fw_lookup_notif_ver(mvm->fw, PROT_OFFLOAD_GROUP,\n\t\t\t\t    WOWLAN_INFO_NOTIFICATION,\n\t\t\t\t    0))\n\t\tgtkdata.igtk_support = true;\n\n\t \n\tieee80211_iter_keys(mvm->hw, vif,\n\t\t\t    iwl_mvm_d3_find_last_keys, &gtkdata);\n\t \n\tif (gtkdata.unhandled_cipher)\n\t\treturn false;\n\tif (!gtkdata.num_keys)\n\t\tgoto out;\n\n\t \n\tieee80211_iter_keys(mvm->hw, vif,\n\t\t\t    iwl_mvm_d3_update_keys, &gtkdata);\n\n\tif (status->num_of_gtk_rekeys) {\n\t\t__be64 replay_ctr = cpu_to_be64(status->replay_ctr);\n\n\t\tIWL_DEBUG_WOWLAN(mvm, \"num of GTK rekeying %d\\n\",\n\t\t\t\t status->num_of_gtk_rekeys);\n\n\t\tif (!iwl_mvm_gtk_rekey(status, vif, mvm, gtkdata.gtk_cipher))\n\t\t\treturn false;\n\n\t\tif (!iwl_mvm_d3_igtk_bigtk_rekey_add(status, vif,\n\t\t\t\t\t\t     gtkdata.igtk_cipher,\n\t\t\t\t\t\t     &status->igtk))\n\t\t\treturn false;\n\n\t\tieee80211_gtk_rekey_notify(vif, vif->bss_conf.bssid,\n\t\t\t\t\t   (void *)&replay_ctr, GFP_KERNEL);\n\t}\n\nout:\n\tif (iwl_fw_lookup_notif_ver(mvm->fw, LONG_GROUP,\n\t\t\t\t    WOWLAN_GET_STATUSES, 0) < 10) {\n\t\tmvmvif->seqno_valid = true;\n\t\t \n\t\tmvmvif->seqno = status->non_qos_seq_ctr + 0x10;\n\t}\n\n\treturn true;\n}\n\nstatic void iwl_mvm_convert_gtk_v2(struct iwl_wowlan_status_data *status,\n\t\t\t\t   struct iwl_wowlan_gtk_status_v2 *data)\n{\n\tBUILD_BUG_ON(sizeof(status->gtk[0].key) < sizeof(data->key));\n\tBUILD_BUG_ON(NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY +\n\t\t     sizeof(data->tkip_mic_key) >\n\t\t     sizeof(status->gtk[0].key));\n\n\tstatus->gtk[0].len = data->key_len;\n\tstatus->gtk[0].flags = data->key_flags;\n\n\tmemcpy(status->gtk[0].key, data->key, sizeof(data->key));\n\n\t \n\tif (status->gtk[0].len == NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY)\n\t\tmemcpy(status->gtk[0].key + NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY,\n\t\t       data->tkip_mic_key, sizeof(data->tkip_mic_key));\n}\n\nstatic void iwl_mvm_convert_gtk_v3(struct iwl_wowlan_status_data *status,\n\t\t\t\t   struct iwl_wowlan_gtk_status_v3 *data)\n{\n\tint data_idx, status_idx = 0;\n\n\tBUILD_BUG_ON(sizeof(status->gtk[0].key) < sizeof(data[0].key));\n\tBUILD_BUG_ON(NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY +\n\t\t     sizeof(data[0].tkip_mic_key) >\n\t\t     sizeof(status->gtk[0].key));\n\tBUILD_BUG_ON(ARRAY_SIZE(status->gtk) < WOWLAN_GTK_KEYS_NUM);\n\tfor (data_idx = 0; data_idx < ARRAY_SIZE(status->gtk); data_idx++) {\n\t\tif (!(data[data_idx].key_len))\n\t\t\tcontinue;\n\t\tstatus->gtk[status_idx].len = data[data_idx].key_len;\n\t\tstatus->gtk[status_idx].flags = data[data_idx].key_flags;\n\t\tstatus->gtk[status_idx].id = status->gtk[status_idx].flags &\n\t\t\t\t    IWL_WOWLAN_GTK_IDX_MASK;\n\n\t\tmemcpy(status->gtk[status_idx].key, data[data_idx].key,\n\t\t       sizeof(data[data_idx].key));\n\n\t\t \n\t\tif (status->gtk[status_idx].len ==\n\t\t    NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY)\n\t\t\tmemcpy(status->gtk[status_idx].key +\n\t\t\t       NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY,\n\t\t\t       data[data_idx].tkip_mic_key,\n\t\t\t       sizeof(data[data_idx].tkip_mic_key));\n\t\tstatus_idx++;\n\t}\n}\n\nstatic void iwl_mvm_convert_igtk(struct iwl_wowlan_status_data *status,\n\t\t\t\t struct iwl_wowlan_igtk_status *data)\n{\n\tBUILD_BUG_ON(sizeof(status->igtk.key) < sizeof(data->key));\n\n\tif (!data->key_len)\n\t\treturn;\n\n\tstatus->igtk.len = data->key_len;\n\tstatus->igtk.flags = data->key_flags;\n\tstatus->igtk.id = u32_get_bits(data->key_flags,\n\t\t\t\t       IWL_WOWLAN_IGTK_BIGTK_IDX_MASK)\n\t\t+ WOWLAN_IGTK_MIN_INDEX;\n\n\tmemcpy(status->igtk.key, data->key, sizeof(data->key));\n\tmemcpy(status->igtk.ipn, data->ipn, sizeof(data->ipn));\n}\n\nstatic void iwl_mvm_parse_wowlan_info_notif(struct iwl_mvm *mvm,\n\t\t\t\t\t    struct iwl_wowlan_info_notif *data,\n\t\t\t\t\t    struct iwl_wowlan_status_data *status,\n\t\t\t\t\t    u32 len)\n{\n\tu32 i;\n\n\tif (!data) {\n\t\tIWL_ERR(mvm, \"iwl_wowlan_info_notif data is NULL\\n\");\n\t\tstatus = NULL;\n\t\treturn;\n\t}\n\n\tif (len < sizeof(*data)) {\n\t\tIWL_ERR(mvm, \"Invalid WoWLAN info notification!\\n\");\n\t\tstatus = NULL;\n\t\treturn;\n\t}\n\n\tiwl_mvm_convert_key_counters_v5(status, &data->gtk[0].sc);\n\tiwl_mvm_convert_gtk_v3(status, data->gtk);\n\tiwl_mvm_convert_igtk(status, &data->igtk[0]);\n\n\tstatus->replay_ctr = le64_to_cpu(data->replay_ctr);\n\tstatus->pattern_number = le16_to_cpu(data->pattern_number);\n\tfor (i = 0; i < IWL_MAX_TID_COUNT; i++)\n\t\tstatus->qos_seq_ctr[i] =\n\t\t\tle16_to_cpu(data->qos_seq_ctr[i]);\n\tstatus->wakeup_reasons = le32_to_cpu(data->wakeup_reasons);\n\tstatus->num_of_gtk_rekeys =\n\t\tle32_to_cpu(data->num_of_gtk_rekeys);\n\tstatus->received_beacons = le32_to_cpu(data->received_beacons);\n\tstatus->tid_tear_down = data->tid_tear_down;\n}\n\n \n#define iwl_mvm_parse_wowlan_status_common(_ver)\t\t\t\\\nstatic struct iwl_wowlan_status_data *\t\t\t\t\t\\\niwl_mvm_parse_wowlan_status_common_ ## _ver(struct iwl_mvm *mvm,\t\\\n\t\t\t\t\t    struct iwl_wowlan_status_ ##_ver *data,\\\n\t\t\t\t\t    int len)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct iwl_wowlan_status_data *status;\t\t\t\t\\\n\tint data_size, i;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (len < sizeof(*data)) {\t\t\t\t\t\\\n\t\tIWL_ERR(mvm, \"Invalid WoWLAN status response!\\n\");\t\\\n\t\treturn NULL;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tdata_size = ALIGN(le32_to_cpu(data->wake_packet_bufsize), 4);\t\\\n\tif (len != sizeof(*data) + data_size) {\t\t\t\t\\\n\t\tIWL_ERR(mvm, \"Invalid WoWLAN status response!\\n\");\t\\\n\t\treturn NULL;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tstatus = kzalloc(sizeof(*status), GFP_KERNEL);\t\t\t\\\n\tif (!status)\t\t\t\t\t\t\t\\\n\t\treturn NULL;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\t\\\n\tstatus->replay_ctr = le64_to_cpu(data->replay_ctr);\t\t\\\n\tstatus->pattern_number = le16_to_cpu(data->pattern_number);\t\\\n\tstatus->non_qos_seq_ctr = le16_to_cpu(data->non_qos_seq_ctr);\t\\\n\tfor (i = 0; i < 8; i++)\t\t\t\t\t\t\\\n\t\tstatus->qos_seq_ctr[i] =\t\t\t\t\\\n\t\t\tle16_to_cpu(data->qos_seq_ctr[i]);\t\t\\\n\tstatus->wakeup_reasons = le32_to_cpu(data->wakeup_reasons);\t\\\n\tstatus->num_of_gtk_rekeys =\t\t\t\t\t\\\n\t\tle32_to_cpu(data->num_of_gtk_rekeys);\t\t\t\\\n\tstatus->received_beacons = le32_to_cpu(data->received_beacons);\t\\\n\tstatus->wake_packet_length =\t\t\t\t\t\\\n\t\tle32_to_cpu(data->wake_packet_length);\t\t\t\\\n\tstatus->wake_packet_bufsize =\t\t\t\t\t\\\n\t\tle32_to_cpu(data->wake_packet_bufsize);\t\t\t\\\n\tif (status->wake_packet_bufsize) {\t\t\t\t\\\n\t\tstatus->wake_packet =\t\t\t\t\t\\\n\t\t\tkmemdup(data->wake_packet,\t\t\t\\\n\t\t\t\tstatus->wake_packet_bufsize,\t\t\\\n\t\t\t\tGFP_KERNEL);\t\t\t\t\\\n\t\tif (!status->wake_packet) {\t\t\t\t\\\n\t\t\tkfree(status);\t\t\t\t\t\\\n\t\t\treturn NULL;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\tstatus->wake_packet = NULL;\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\t\t\t\\\n}\n\niwl_mvm_parse_wowlan_status_common(v6)\niwl_mvm_parse_wowlan_status_common(v7)\niwl_mvm_parse_wowlan_status_common(v9)\niwl_mvm_parse_wowlan_status_common(v12)\n\nstatic struct iwl_wowlan_status_data *\niwl_mvm_send_wowlan_get_status(struct iwl_mvm *mvm, u8 sta_id)\n{\n\tstruct iwl_wowlan_status_data *status;\n\tstruct iwl_wowlan_get_status_cmd get_status_cmd = {\n\t\t.sta_id = cpu_to_le32(sta_id),\n\t};\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = WOWLAN_GET_STATUSES,\n\t\t.flags = CMD_WANT_SKB,\n\t\t.data = { &get_status_cmd, },\n\t\t.len = { sizeof(get_status_cmd), },\n\t};\n\tint ret, len;\n\tu8 notif_ver;\n\tu8 cmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw, cmd.id,\n\t\t\t\t\t   IWL_FW_CMD_VER_UNKNOWN);\n\n\tif (cmd_ver == IWL_FW_CMD_VER_UNKNOWN)\n\t\tcmd.len[0] = 0;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tret = iwl_mvm_send_cmd(mvm, &cmd);\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"failed to query wakeup status (%d)\\n\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tlen = iwl_rx_packet_payload_len(cmd.resp_pkt);\n\n\t \n\tnotif_ver = iwl_mvm_lookup_wowlan_status_ver(mvm);\n\n\tif (notif_ver < 7) {\n\t\tstruct iwl_wowlan_status_v6 *v6 = (void *)cmd.resp_pkt->data;\n\n\t\tstatus = iwl_mvm_parse_wowlan_status_common_v6(mvm, v6, len);\n\t\tif (!status)\n\t\t\tgoto out_free_resp;\n\n\t\tBUILD_BUG_ON(sizeof(v6->gtk.decrypt_key) >\n\t\t\t     sizeof(status->gtk[0].key));\n\t\tBUILD_BUG_ON(NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY +\n\t\t\t     sizeof(v6->gtk.tkip_mic_key) >\n\t\t\t     sizeof(status->gtk[0].key));\n\n\t\t \n\t\tmemcpy(status->gtk[0].key, v6->gtk.decrypt_key,\n\t\t       sizeof(v6->gtk.decrypt_key));\n\t\tmemcpy(status->gtk[0].key + NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY,\n\t\t       v6->gtk.tkip_mic_key,\n\t\t       sizeof(v6->gtk.tkip_mic_key));\n\n\t\tiwl_mvm_convert_key_counters(status, &v6->gtk.rsc.all_tsc_rsc);\n\n\t\t \n\t\tstatus->gtk[0].len = 16;\n\n\t\t \n\t\tstatus->gtk[0].flags = v6->gtk.key_index | BIT(7);\n\t} else if (notif_ver == 7) {\n\t\tstruct iwl_wowlan_status_v7 *v7 = (void *)cmd.resp_pkt->data;\n\n\t\tstatus = iwl_mvm_parse_wowlan_status_common_v7(mvm, v7, len);\n\t\tif (!status)\n\t\t\tgoto out_free_resp;\n\n\t\tiwl_mvm_convert_key_counters(status, &v7->gtk[0].rsc.all_tsc_rsc);\n\t\tiwl_mvm_convert_gtk_v2(status, &v7->gtk[0]);\n\t\tiwl_mvm_convert_igtk(status, &v7->igtk[0]);\n\t} else if (notif_ver == 9 || notif_ver == 10 || notif_ver == 11) {\n\t\tstruct iwl_wowlan_status_v9 *v9 = (void *)cmd.resp_pkt->data;\n\n\t\t \n\t\tstatus = iwl_mvm_parse_wowlan_status_common_v9(mvm, v9, len);\n\t\tif (!status)\n\t\t\tgoto out_free_resp;\n\n\t\tiwl_mvm_convert_key_counters(status, &v9->gtk[0].rsc.all_tsc_rsc);\n\t\tiwl_mvm_convert_gtk_v2(status, &v9->gtk[0]);\n\t\tiwl_mvm_convert_igtk(status, &v9->igtk[0]);\n\n\t\tstatus->tid_tear_down = v9->tid_tear_down;\n\t} else if (notif_ver == 12) {\n\t\tstruct iwl_wowlan_status_v12 *v12 = (void *)cmd.resp_pkt->data;\n\n\t\tstatus = iwl_mvm_parse_wowlan_status_common_v12(mvm, v12, len);\n\t\tif (!status)\n\t\t\tgoto out_free_resp;\n\n\t\tiwl_mvm_convert_key_counters_v5(status, &v12->gtk[0].sc);\n\t\tiwl_mvm_convert_gtk_v3(status, v12->gtk);\n\t\tiwl_mvm_convert_igtk(status, &v12->igtk[0]);\n\n\t\tstatus->tid_tear_down = v12->tid_tear_down;\n\t} else {\n\t\tIWL_ERR(mvm,\n\t\t\t\"Firmware advertises unknown WoWLAN status response %d!\\n\",\n\t\t\tnotif_ver);\n\t\tstatus = NULL;\n\t}\n\nout_free_resp:\n\tiwl_free_resp(&cmd);\n\treturn status;\n}\n\n \nstatic bool iwl_mvm_query_wakeup_reasons(struct iwl_mvm *mvm,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t struct iwl_wowlan_status_data *status)\n{\n\tint i;\n\tbool keep;\n\tstruct iwl_mvm_sta *mvm_ap_sta;\n\n\tif (!status)\n\t\tgoto out_unlock;\n\n\tIWL_DEBUG_WOWLAN(mvm, \"wakeup reason 0x%x\\n\",\n\t\t\t status->wakeup_reasons);\n\n\t \n\tmvm_ap_sta = iwl_mvm_sta_from_staid_protected(mvm, 0);\n\tif (!mvm_ap_sta)\n\t\tgoto out_unlock;\n\n\tfor (i = 0; i < IWL_MAX_TID_COUNT; i++) {\n\t\tu16 seq = status->qos_seq_ctr[i];\n\t\t \n\t\tseq += 0x10;\n\t\tmvm_ap_sta->tid_data[i].seq_number = seq;\n\t}\n\n\tif (mvm->trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_22000) {\n\t\ti = mvm->offload_tid;\n\t\tiwl_trans_set_q_ptrs(mvm->trans,\n\t\t\t\t     mvm_ap_sta->tid_data[i].txq_id,\n\t\t\t\t     mvm_ap_sta->tid_data[i].seq_number >> 4);\n\t}\n\n\t \n\tmutex_unlock(&mvm->mutex);\n\n\tiwl_mvm_report_wakeup_reasons(mvm, vif, status);\n\n\tkeep = iwl_mvm_setup_connection_keep(mvm, vif, status);\n\n\treturn keep;\n\nout_unlock:\n\tmutex_unlock(&mvm->mutex);\n\treturn false;\n}\n\n#define ND_QUERY_BUF_LEN (sizeof(struct iwl_scan_offload_profile_match) * \\\n\t\t\t  IWL_SCAN_MAX_PROFILES)\n\nstruct iwl_mvm_nd_results {\n\tu32 matched_profiles;\n\tu8 matches[ND_QUERY_BUF_LEN];\n};\n\nstatic int\niwl_mvm_netdetect_query_results(struct iwl_mvm *mvm,\n\t\t\t\tstruct iwl_mvm_nd_results *results)\n{\n\tstruct iwl_scan_offload_match_info *query;\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = SCAN_OFFLOAD_PROFILES_QUERY_CMD,\n\t\t.flags = CMD_WANT_SKB,\n\t};\n\tint ret, len;\n\tsize_t query_len, matches_len;\n\tint max_profiles = iwl_umac_scan_get_max_profiles(mvm->fw);\n\n\tret = iwl_mvm_send_cmd(mvm, &cmd);\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"failed to query matched profiles (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (fw_has_api(&mvm->fw->ucode_capa,\n\t\t       IWL_UCODE_TLV_API_SCAN_OFFLOAD_CHANS)) {\n\t\tquery_len = sizeof(struct iwl_scan_offload_match_info);\n\t\tmatches_len = sizeof(struct iwl_scan_offload_profile_match) *\n\t\t\tmax_profiles;\n\t} else {\n\t\tquery_len = sizeof(struct iwl_scan_offload_profiles_query_v1);\n\t\tmatches_len = sizeof(struct iwl_scan_offload_profile_match_v1) *\n\t\t\tmax_profiles;\n\t}\n\n\tlen = iwl_rx_packet_payload_len(cmd.resp_pkt);\n\tif (len < query_len) {\n\t\tIWL_ERR(mvm, \"Invalid scan offload profiles query response!\\n\");\n\t\tret = -EIO;\n\t\tgoto out_free_resp;\n\t}\n\n\tquery = (void *)cmd.resp_pkt->data;\n\n\tresults->matched_profiles = le32_to_cpu(query->matched_profiles);\n\tmemcpy(results->matches, query->matches, matches_len);\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tmvm->last_netdetect_scans = le32_to_cpu(query->n_scans_done);\n#endif\n\nout_free_resp:\n\tiwl_free_resp(&cmd);\n\treturn ret;\n}\n\nstatic int iwl_mvm_query_num_match_chans(struct iwl_mvm *mvm,\n\t\t\t\t\t struct iwl_mvm_nd_results *results,\n\t\t\t\t\t int idx)\n{\n\tint n_chans = 0, i;\n\n\tif (fw_has_api(&mvm->fw->ucode_capa,\n\t\t       IWL_UCODE_TLV_API_SCAN_OFFLOAD_CHANS)) {\n\t\tstruct iwl_scan_offload_profile_match *matches =\n\t\t\t(void *)results->matches;\n\n\t\tfor (i = 0; i < SCAN_OFFLOAD_MATCHING_CHANNELS_LEN; i++)\n\t\t\tn_chans += hweight8(matches[idx].matching_channels[i]);\n\t} else {\n\t\tstruct iwl_scan_offload_profile_match_v1 *matches =\n\t\t\t(void *)results->matches;\n\n\t\tfor (i = 0; i < SCAN_OFFLOAD_MATCHING_CHANNELS_LEN_V1; i++)\n\t\t\tn_chans += hweight8(matches[idx].matching_channels[i]);\n\t}\n\n\treturn n_chans;\n}\n\nstatic void iwl_mvm_query_set_freqs(struct iwl_mvm *mvm,\n\t\t\t\t    struct iwl_mvm_nd_results *results,\n\t\t\t\t    struct cfg80211_wowlan_nd_match *match,\n\t\t\t\t    int idx)\n{\n\tint i;\n\n\tif (fw_has_api(&mvm->fw->ucode_capa,\n\t\t       IWL_UCODE_TLV_API_SCAN_OFFLOAD_CHANS)) {\n\t\tstruct iwl_scan_offload_profile_match *matches =\n\t\t\t (void *)results->matches;\n\n\t\tfor (i = 0; i < SCAN_OFFLOAD_MATCHING_CHANNELS_LEN * 8; i++)\n\t\t\tif (matches[idx].matching_channels[i / 8] & (BIT(i % 8)))\n\t\t\t\tmatch->channels[match->n_channels++] =\n\t\t\t\t\tmvm->nd_channels[i]->center_freq;\n\t} else {\n\t\tstruct iwl_scan_offload_profile_match_v1 *matches =\n\t\t\t (void *)results->matches;\n\n\t\tfor (i = 0; i < SCAN_OFFLOAD_MATCHING_CHANNELS_LEN_V1 * 8; i++)\n\t\t\tif (matches[idx].matching_channels[i / 8] & (BIT(i % 8)))\n\t\t\t\tmatch->channels[match->n_channels++] =\n\t\t\t\t\tmvm->nd_channels[i]->center_freq;\n\t}\n}\n\n \nenum iwl_d3_notif {\n\tIWL_D3_NOTIF_WOWLAN_INFO =\tBIT(0),\n\tIWL_D3_NOTIF_WOWLAN_WAKE_PKT =\tBIT(1),\n\tIWL_D3_NOTIF_PROT_OFFLOAD =\tBIT(2),\n\tIWL_D3_ND_MATCH_INFO      =     BIT(3),\n\tIWL_D3_NOTIF_D3_END_NOTIF =\tBIT(4)\n};\n\n \nstruct iwl_d3_data {\n\tstruct iwl_wowlan_status_data *status;\n\tbool test;\n\tu32 d3_end_flags;\n\tu32 notif_expected;\t \n\tu32 notif_received;\t \n\tstruct iwl_mvm_nd_results *nd_results;\n\tbool nd_results_valid;\n};\n\nstatic void iwl_mvm_query_netdetect_reasons(struct iwl_mvm *mvm,\n\t\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t\t    struct iwl_d3_data *d3_data)\n{\n\tstruct cfg80211_wowlan_nd_info *net_detect = NULL;\n\tstruct cfg80211_wowlan_wakeup wakeup = {\n\t\t.pattern_idx = -1,\n\t};\n\tstruct cfg80211_wowlan_wakeup *wakeup_report = &wakeup;\n\tunsigned long matched_profiles;\n\tu32 reasons = 0;\n\tint i, n_matches, ret;\n\n\tif (WARN_ON(!d3_data || !d3_data->status))\n\t\tgoto out;\n\n\treasons = d3_data->status->wakeup_reasons;\n\n\tif (reasons & IWL_WOWLAN_WAKEUP_BY_RFKILL_DEASSERTED)\n\t\twakeup.rfkill_release = true;\n\n\tif (reasons != IWL_WOWLAN_WAKEUP_BY_NON_WIRELESS)\n\t\tgoto out;\n\n\tif (!iwl_fw_lookup_notif_ver(mvm->fw, PROT_OFFLOAD_GROUP,\n\t\t\t\t     WOWLAN_INFO_NOTIFICATION, 0)) {\n\t\tIWL_INFO(mvm, \"Query FW for ND results\\n\");\n\t\tret = iwl_mvm_netdetect_query_results(mvm, d3_data->nd_results);\n\n\t} else {\n\t\tIWL_INFO(mvm, \"Notification based ND results\\n\");\n\t\tret = d3_data->nd_results_valid ? 0 : -1;\n\t}\n\n\tif (ret || !d3_data->nd_results->matched_profiles) {\n\t\twakeup_report = NULL;\n\t\tgoto out;\n\t}\n\n\tmatched_profiles = d3_data->nd_results->matched_profiles;\n\tif (mvm->n_nd_match_sets) {\n\t\tn_matches = hweight_long(matched_profiles);\n\t} else {\n\t\tIWL_ERR(mvm, \"no net detect match information available\\n\");\n\t\tn_matches = 0;\n\t}\n\n\tnet_detect = kzalloc(struct_size(net_detect, matches, n_matches),\n\t\t\t     GFP_KERNEL);\n\tif (!net_detect || !n_matches)\n\t\tgoto out_report_nd;\n\n\tfor_each_set_bit(i, &matched_profiles, mvm->n_nd_match_sets) {\n\t\tstruct cfg80211_wowlan_nd_match *match;\n\t\tint idx, n_channels = 0;\n\n\t\tn_channels = iwl_mvm_query_num_match_chans(mvm,\n\t\t\t\t\t\t\t   d3_data->nd_results,\n\t\t\t\t\t\t\t   i);\n\n\t\tmatch = kzalloc(struct_size(match, channels, n_channels),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!match)\n\t\t\tgoto out_report_nd;\n\n\t\tnet_detect->matches[net_detect->n_matches++] = match;\n\n\t\t \n\t\tidx = mvm->n_nd_match_sets - i - 1;\n\t\tmatch->ssid.ssid_len = mvm->nd_match_sets[idx].ssid.ssid_len;\n\t\tmemcpy(match->ssid.ssid, mvm->nd_match_sets[idx].ssid.ssid,\n\t\t       match->ssid.ssid_len);\n\n\t\tif (mvm->n_nd_channels < n_channels)\n\t\t\tcontinue;\n\n\t\tiwl_mvm_query_set_freqs(mvm, d3_data->nd_results, match, i);\n\t}\n\nout_report_nd:\n\twakeup.net_detect = net_detect;\nout:\n\tiwl_mvm_free_nd(mvm);\n\n\tmutex_unlock(&mvm->mutex);\n\tieee80211_report_wowlan_wakeup(vif, wakeup_report, GFP_KERNEL);\n\n\tif (net_detect) {\n\t\tfor (i = 0; i < net_detect->n_matches; i++)\n\t\t\tkfree(net_detect->matches[i]);\n\t\tkfree(net_detect);\n\t}\n}\n\nstatic void iwl_mvm_d3_disconnect_iter(void *data, u8 *mac,\n\t\t\t\t       struct ieee80211_vif *vif)\n{\n\t \n\tif (data == vif)\n\t\treturn;\n\n\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\tieee80211_resume_disconnect(vif);\n}\n\nstatic bool iwl_mvm_rt_status(struct iwl_trans *trans, u32 base, u32 *err_id)\n{\n\tstruct error_table_start {\n\t\t \n\t\tu32 valid;\n\t\t__le32 err_id;\n\t} err_info;\n\n\tif (!base)\n\t\treturn false;\n\n\tiwl_trans_read_mem_bytes(trans, base,\n\t\t\t\t &err_info, sizeof(err_info));\n\tif (err_info.valid && err_id)\n\t\t*err_id = le32_to_cpu(err_info.err_id);\n\n\treturn !!err_info.valid;\n}\n\nstatic bool iwl_mvm_check_rt_status(struct iwl_mvm *mvm,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tu32 err_id;\n\n\t \n\tif (iwl_mvm_rt_status(mvm->trans,\n\t\t\t      mvm->trans->dbg.lmac_error_event_table[0],\n\t\t\t      &err_id)) {\n\t\tif (err_id == RF_KILL_INDICATOR_FOR_WOWLAN) {\n\t\t\tstruct cfg80211_wowlan_wakeup wakeup = {\n\t\t\t\t.rfkill_release = true,\n\t\t\t};\n\t\t\tieee80211_report_wowlan_wakeup(vif, &wakeup,\n\t\t\t\t\t\t       GFP_KERNEL);\n\t\t}\n\t\treturn true;\n\t}\n\n\t \n\tif (iwl_mvm_rt_status(mvm->trans,\n\t\t\t      mvm->trans->dbg.lmac_error_event_table[1], NULL))\n\t\treturn true;\n\n\t \n\tif (iwl_mvm_rt_status(mvm->trans,\n\t\t\t      mvm->trans->dbg.umac_error_event_table, NULL))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic bool\niwl_mvm_choose_query_wakeup_reasons(struct iwl_mvm *mvm,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct iwl_d3_data *d3_data)\n{\n\tlockdep_assert_held(&mvm->mutex);\n\n\t \n\tif (!d3_data->status) {\n\t\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\t\tu8 sta_id = mvm->net_detect ? IWL_MVM_INVALID_STA :\n\t\t\t\t\t      mvmvif->deflink.ap_sta_id;\n\n\t\td3_data->status = iwl_mvm_send_wowlan_get_status(mvm, sta_id);\n\t}\n\n\tif (mvm->net_detect) {\n\t\tiwl_mvm_query_netdetect_reasons(mvm, vif, d3_data);\n\t} else {\n\t\tbool keep = iwl_mvm_query_wakeup_reasons(mvm, vif,\n\t\t\t\t\t\t\t d3_data->status);\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\t\tif (keep)\n\t\t\tmvm->keep_vif = vif;\n#endif\n\n\t\treturn keep;\n\t}\n\treturn false;\n}\n\n#define IWL_WOWLAN_WAKEUP_REASON_HAS_WAKEUP_PKT (IWL_WOWLAN_WAKEUP_BY_MAGIC_PACKET | \\\n\t\t\t\t\t\t IWL_WOWLAN_WAKEUP_BY_PATTERN | \\\n\t\t\t\t\t\t IWL_WAKEUP_BY_PATTERN_IPV4_TCP_SYN |\\\n\t\t\t\t\t\t IWL_WAKEUP_BY_PATTERN_IPV4_TCP_SYN_WILDCARD |\\\n\t\t\t\t\t\t IWL_WAKEUP_BY_PATTERN_IPV6_TCP_SYN |\\\n\t\t\t\t\t\t IWL_WAKEUP_BY_PATTERN_IPV6_TCP_SYN_WILDCARD)\n\nstatic int iwl_mvm_wowlan_store_wake_pkt(struct iwl_mvm *mvm,\n\t\t\t\t\t struct iwl_wowlan_wake_pkt_notif *notif,\n\t\t\t\t\t struct iwl_wowlan_status_data *status,\n\t\t\t\t\t u32 len)\n{\n\tu32 data_size, packet_len = le32_to_cpu(notif->wake_packet_length);\n\n\tif (len < sizeof(*notif)) {\n\t\tIWL_ERR(mvm, \"Invalid WoWLAN wake packet notification!\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (WARN_ON(!status)) {\n\t\tIWL_ERR(mvm, \"Got wake packet notification but wowlan status data is NULL\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (WARN_ON(!(status->wakeup_reasons &\n\t\t      IWL_WOWLAN_WAKEUP_REASON_HAS_WAKEUP_PKT))) {\n\t\tIWL_ERR(mvm, \"Got wakeup packet but wakeup reason is %x\\n\",\n\t\t\tstatus->wakeup_reasons);\n\t\treturn -EIO;\n\t}\n\n\tdata_size = len - offsetof(struct iwl_wowlan_wake_pkt_notif, wake_packet);\n\n\t \n\tif (packet_len < data_size)\n\t\tdata_size = packet_len;\n\n\tstatus->wake_packet = kmemdup(notif->wake_packet, data_size,\n\t\t\t\t      GFP_ATOMIC);\n\n\tif (!status->wake_packet)\n\t\treturn -ENOMEM;\n\n\tstatus->wake_packet_length = packet_len;\n\tstatus->wake_packet_bufsize = data_size;\n\n\treturn 0;\n}\n\nstatic void iwl_mvm_nd_match_info_handler(struct iwl_mvm *mvm,\n\t\t\t\t\t  struct iwl_d3_data *d3_data,\n\t\t\t\t\t  struct iwl_scan_offload_match_info *notif,\n\t\t\t\t\t  u32 len)\n{\n\tstruct iwl_wowlan_status_data *status = d3_data->status;\n\tstruct ieee80211_vif *vif = iwl_mvm_get_bss_vif(mvm);\n\tstruct iwl_mvm_nd_results *results = d3_data->nd_results;\n\tsize_t i, matches_len = sizeof(struct iwl_scan_offload_profile_match) *\n\t\tiwl_umac_scan_get_max_profiles(mvm->fw);\n\n\tif (IS_ERR_OR_NULL(vif))\n\t\treturn;\n\n\tif (len < sizeof(struct iwl_scan_offload_match_info)) {\n\t\tIWL_ERR(mvm, \"Invalid scan match info notification\\n\");\n\t\treturn;\n\t}\n\n\tif (!mvm->net_detect) {\n\t\tIWL_ERR(mvm, \"Unexpected scan match info notification\\n\");\n\t\treturn;\n\t}\n\n\tif (!status || status->wakeup_reasons != IWL_WOWLAN_WAKEUP_BY_NON_WIRELESS) {\n\t\tIWL_ERR(mvm,\n\t\t\t\"Ignore scan match info notification: no reason\\n\");\n\t\treturn;\n\t}\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tmvm->last_netdetect_scans = le32_to_cpu(notif->n_scans_done);\n#endif\n\n\tresults->matched_profiles = le32_to_cpu(notif->matched_profiles);\n\tIWL_INFO(mvm, \"number of matched profiles=%u\\n\",\n\t\t results->matched_profiles);\n\n\tif (results->matched_profiles) {\n\t\tmemcpy(results->matches, notif->matches, matches_len);\n\t\td3_data->nd_results_valid = TRUE;\n\t}\n\n\t \n\tmvm->scan_status = 0;\n\tfor (i = 0; i < mvm->max_scans; i++)\n\t\tmvm->scan_uid_status[i] = 0;\n}\n\nstatic bool iwl_mvm_wait_d3_notif(struct iwl_notif_wait_data *notif_wait,\n\t\t\t\t  struct iwl_rx_packet *pkt, void *data)\n{\n\tstruct iwl_mvm *mvm =\n\t\tcontainer_of(notif_wait, struct iwl_mvm, notif_wait);\n\tstruct iwl_d3_data *d3_data = data;\n\tu32 len;\n\tint ret;\n\tint wowlan_info_ver = iwl_fw_lookup_notif_ver(mvm->fw,\n\t\t\t\t\t\t      PROT_OFFLOAD_GROUP,\n\t\t\t\t\t\t      WOWLAN_INFO_NOTIFICATION,\n\t\t\t\t\t\t      IWL_FW_CMD_VER_UNKNOWN);\n\n\n\tswitch (WIDE_ID(pkt->hdr.group_id, pkt->hdr.cmd)) {\n\tcase WIDE_ID(PROT_OFFLOAD_GROUP, WOWLAN_INFO_NOTIFICATION): {\n\t\tstruct iwl_wowlan_info_notif *notif;\n\n\t\tif (d3_data->notif_received & IWL_D3_NOTIF_WOWLAN_INFO) {\n\t\t\t \n\t\t\tIWL_DEBUG_WOWLAN(mvm,\n\t\t\t\t\t \"Got additional wowlan info notification\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wowlan_info_ver < 2) {\n\t\t\tstruct iwl_wowlan_info_notif_v1 *notif_v1 = (void *)pkt->data;\n\n\t\t\tnotif = kmemdup(notif_v1, sizeof(*notif), GFP_ATOMIC);\n\t\t\tif (!notif)\n\t\t\t\treturn false;\n\n\t\t\tnotif->tid_tear_down = notif_v1->tid_tear_down;\n\t\t\tnotif->station_id = notif_v1->station_id;\n\t\t\tmemset_after(notif, 0, station_id);\n\t\t} else {\n\t\t\tnotif = (void *)pkt->data;\n\t\t}\n\n\t\td3_data->notif_received |= IWL_D3_NOTIF_WOWLAN_INFO;\n\t\tlen = iwl_rx_packet_payload_len(pkt);\n\t\tiwl_mvm_parse_wowlan_info_notif(mvm, notif, d3_data->status,\n\t\t\t\t\t\tlen);\n\n\t\tif (wowlan_info_ver < 2)\n\t\t\tkfree(notif);\n\n\t\tif (d3_data->status &&\n\t\t    d3_data->status->wakeup_reasons & IWL_WOWLAN_WAKEUP_REASON_HAS_WAKEUP_PKT)\n\t\t\t \n\t\t\td3_data->notif_expected |= IWL_D3_NOTIF_WOWLAN_WAKE_PKT;\n\n\t\tbreak;\n\t}\n\tcase WIDE_ID(PROT_OFFLOAD_GROUP, WOWLAN_WAKE_PKT_NOTIFICATION): {\n\t\tstruct iwl_wowlan_wake_pkt_notif *notif = (void *)pkt->data;\n\n\t\tif (d3_data->notif_received & IWL_D3_NOTIF_WOWLAN_WAKE_PKT) {\n\t\t\t \n\t\t\tIWL_ERR(mvm,\n\t\t\t\t\"Got additional wowlan wake packet notification\\n\");\n\t\t} else {\n\t\t\td3_data->notif_received |= IWL_D3_NOTIF_WOWLAN_WAKE_PKT;\n\t\t\tlen =  iwl_rx_packet_payload_len(pkt);\n\t\t\tret = iwl_mvm_wowlan_store_wake_pkt(mvm, notif,\n\t\t\t\t\t\t\t    d3_data->status,\n\t\t\t\t\t\t\t    len);\n\t\t\tif (ret)\n\t\t\t\tIWL_ERR(mvm,\n\t\t\t\t\t\"Can't parse WOWLAN_WAKE_PKT_NOTIFICATION\\n\");\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase WIDE_ID(SCAN_GROUP, OFFLOAD_MATCH_INFO_NOTIF): {\n\t\tstruct iwl_scan_offload_match_info *notif = (void *)pkt->data;\n\n\t\tif (d3_data->notif_received & IWL_D3_ND_MATCH_INFO) {\n\t\t\tIWL_ERR(mvm,\n\t\t\t\t\"Got additional netdetect match info\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\td3_data->notif_received |= IWL_D3_ND_MATCH_INFO;\n\n\t\t \n\t\td3_data->notif_expected |= IWL_D3_ND_MATCH_INFO;\n\n\t\tlen = iwl_rx_packet_payload_len(pkt);\n\t\tiwl_mvm_nd_match_info_handler(mvm, d3_data, notif, len);\n\t\tbreak;\n\t}\n\tcase WIDE_ID(PROT_OFFLOAD_GROUP, D3_END_NOTIFICATION): {\n\t\tstruct iwl_mvm_d3_end_notif *notif = (void *)pkt->data;\n\n\t\td3_data->d3_end_flags = __le32_to_cpu(notif->flags);\n\t\td3_data->notif_received |= IWL_D3_NOTIF_D3_END_NOTIF;\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\treturn d3_data->notif_received == d3_data->notif_expected;\n}\n\nstatic int iwl_mvm_resume_firmware(struct iwl_mvm *mvm, bool test)\n{\n\tint ret;\n\tenum iwl_d3_status d3_status;\n\tstruct iwl_host_cmd cmd = {\n\t\t\t.id = D0I3_END_CMD,\n\t\t\t.flags = CMD_WANT_SKB | CMD_SEND_IN_D3,\n\t\t};\n\tbool reset = fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t\t IWL_UCODE_TLV_CAPA_CNSLDTD_D3_D0_IMG);\n\n\tret = iwl_trans_d3_resume(mvm->trans, &d3_status, test, !reset);\n\tif (ret)\n\t\treturn ret;\n\n\tif (d3_status != IWL_D3_STATUS_ALIVE) {\n\t\tIWL_INFO(mvm, \"Device was reset during suspend\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tif (mvm->trans->trans_cfg->device_family <= IWL_DEVICE_FAMILY_22000 &&\n\t    fw_has_capa(&mvm->fw->ucode_capa, IWL_UCODE_TLV_CAPA_D0I3_END_FIRST)) {\n\t\tret = iwl_mvm_send_cmd(mvm, &cmd);\n\t\tif (ret < 0)\n\t\t\tIWL_ERR(mvm, \"Failed to send D0I3_END_CMD first (%d)\\n\",\n\t\t\t\tret);\n\t}\n\n\treturn ret;\n}\n\n#define IWL_MVM_D3_NOTIF_TIMEOUT (HZ / 5)\n\nstatic int iwl_mvm_d3_notif_wait(struct iwl_mvm *mvm,\n\t\t\t\t struct iwl_d3_data *d3_data)\n{\n\tstatic const u16 d3_resume_notif[] = {\n\t\tWIDE_ID(PROT_OFFLOAD_GROUP, WOWLAN_INFO_NOTIFICATION),\n\t\tWIDE_ID(PROT_OFFLOAD_GROUP, WOWLAN_WAKE_PKT_NOTIFICATION),\n\t\tWIDE_ID(SCAN_GROUP, OFFLOAD_MATCH_INFO_NOTIF),\n\t\tWIDE_ID(PROT_OFFLOAD_GROUP, D3_END_NOTIFICATION)\n\t};\n\tstruct iwl_notification_wait wait_d3_notif;\n\tint ret;\n\n\tiwl_init_notification_wait(&mvm->notif_wait, &wait_d3_notif,\n\t\t\t\t   d3_resume_notif, ARRAY_SIZE(d3_resume_notif),\n\t\t\t\t   iwl_mvm_wait_d3_notif, d3_data);\n\n\tret = iwl_mvm_resume_firmware(mvm, d3_data->test);\n\tif (ret) {\n\t\tiwl_remove_notification(&mvm->notif_wait, &wait_d3_notif);\n\t\treturn ret;\n\t}\n\n\treturn iwl_wait_notification(&mvm->notif_wait, &wait_d3_notif,\n\t\t\t\t     IWL_MVM_D3_NOTIF_TIMEOUT);\n}\n\nstatic inline bool iwl_mvm_d3_resume_notif_based(struct iwl_mvm *mvm)\n{\n\treturn iwl_fw_lookup_notif_ver(mvm->fw, PROT_OFFLOAD_GROUP,\n\t\t\t\t       WOWLAN_INFO_NOTIFICATION, 0) &&\n\t\tiwl_fw_lookup_notif_ver(mvm->fw, PROT_OFFLOAD_GROUP,\n\t\t\t\t\tWOWLAN_WAKE_PKT_NOTIFICATION, 0) &&\n\t\tiwl_fw_lookup_notif_ver(mvm->fw, PROT_OFFLOAD_GROUP,\n\t\t\t\t\tD3_END_NOTIFICATION, 0);\n}\n\nstatic int __iwl_mvm_resume(struct iwl_mvm *mvm, bool test)\n{\n\tstruct ieee80211_vif *vif = NULL;\n\tint ret = 1;\n\tstruct iwl_mvm_nd_results results = {};\n\tstruct iwl_d3_data d3_data = {\n\t\t.test = test,\n\t\t.notif_expected =\n\t\t\tIWL_D3_NOTIF_WOWLAN_INFO |\n\t\t\tIWL_D3_NOTIF_D3_END_NOTIF,\n\t\t.nd_results_valid = false,\n\t\t.nd_results = &results,\n\t};\n\tbool unified_image = fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t\t\t IWL_UCODE_TLV_CAPA_CNSLDTD_D3_D0_IMG);\n\tbool d0i3_first = fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t\t      IWL_UCODE_TLV_CAPA_D0I3_END_FIRST);\n\tbool resume_notif_based = iwl_mvm_d3_resume_notif_based(mvm);\n\tbool keep = false;\n\n\tmutex_lock(&mvm->mutex);\n\n\tmvm->last_reset_or_resume_time_jiffies = jiffies;\n\n\t \n\tvif = iwl_mvm_get_bss_vif(mvm);\n\tif (IS_ERR_OR_NULL(vif))\n\t\tgoto err;\n\n\tiwl_fw_dbg_read_d3_debug_data(&mvm->fwrt);\n\n\tif (iwl_mvm_check_rt_status(mvm, vif)) {\n\t\tset_bit(STATUS_FW_ERROR, &mvm->trans->status);\n\t\tiwl_mvm_dump_nic_error_log(mvm);\n\t\tiwl_dbg_tlv_time_point(&mvm->fwrt,\n\t\t\t\t       IWL_FW_INI_TIME_POINT_FW_ASSERT, NULL);\n\t\tiwl_fw_dbg_collect_desc(&mvm->fwrt, &iwl_dump_desc_assert,\n\t\t\t\t\tfalse, 0);\n\t\tret = 1;\n\t\tgoto err;\n\t}\n\n\tif (resume_notif_based) {\n\t\td3_data.status = kzalloc(sizeof(*d3_data.status), GFP_KERNEL);\n\t\tif (!d3_data.status) {\n\t\t\tIWL_ERR(mvm, \"Failed to allocate wowlan status\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = iwl_mvm_d3_notif_wait(mvm, &d3_data);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else {\n\t\tret = iwl_mvm_resume_firmware(mvm, test);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\t \n\tmvm->trans->system_pm_mode = IWL_PLAT_PM_MODE_DISABLED;\n\n\t \n\tif (d3_data.d3_end_flags & IWL_D0I3_RESET_REQUIRE)\n\t\tgoto query_wakeup_reasons;\n\n\t \n\tiwl_mvm_update_changed_regdom(mvm);\n\n\t \n\tiwl_mvm_ppag_send_cmd(mvm);\n\n\tif (!unified_image)\n\t\t \n\t\tiwl_mvm_sar_select_profile(mvm, 1, 1);\n\n\tif (mvm->net_detect && unified_image) {\n\t\t \n\t\tret = iwl_mvm_scan_stop(mvm, IWL_MVM_SCAN_NETDETECT,\n\t\t\t\t\tfalse);\n\t}\n\nquery_wakeup_reasons:\n\tkeep = iwl_mvm_choose_query_wakeup_reasons(mvm, vif, &d3_data);\n\t \n\tgoto out;\n\nerr:\n\tmutex_unlock(&mvm->mutex);\nout:\n\tif (d3_data.status)\n\t\tkfree(d3_data.status->wake_packet);\n\tkfree(d3_data.status);\n\tiwl_mvm_free_nd(mvm);\n\n\tif (!d3_data.test && !mvm->net_detect)\n\t\tieee80211_iterate_active_interfaces_mtx(mvm->hw,\n\t\t\t\t\t\t\tIEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\t\t\tiwl_mvm_d3_disconnect_iter,\n\t\t\t\t\t\t\tkeep ? vif : NULL);\n\n\tclear_bit(IWL_MVM_STATUS_IN_D3, &mvm->status);\n\n\t \n\tif (unified_image && !ret) {\n\t\t \n\t\tif (d0i3_first)\n\t\t\treturn 0;\n\n\t\tif (!iwl_fw_lookup_notif_ver(mvm->fw, PROT_OFFLOAD_GROUP,\n\t\t\t\t\t     D3_END_NOTIFICATION, 0)) {\n\t\t\tret = iwl_mvm_send_cmd_pdu(mvm, D0I3_END_CMD, 0, 0, NULL);\n\t\t\tif (!ret)\n\t\t\t\treturn 0;\n\t\t} else if (!(d3_data.d3_end_flags & IWL_D0I3_RESET_REQUIRE)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tset_bit(IWL_MVM_STATUS_HW_RESTART_REQUESTED, &mvm->status);\n\n\t \n\tmvm->trans->system_pm_mode = IWL_PLAT_PM_MODE_DISABLED;\n\n\treturn 1;\n}\n\nint iwl_mvm_resume(struct ieee80211_hw *hw)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tint ret;\n\n\tret = __iwl_mvm_resume(mvm, false);\n\n\tiwl_mvm_resume_tcm(mvm);\n\n\tiwl_fw_runtime_resume(&mvm->fwrt);\n\n\treturn ret;\n}\n\nvoid iwl_mvm_set_wakeup(struct ieee80211_hw *hw, bool enabled)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\tdevice_set_wakeup_enable(mvm->trans->dev, enabled);\n}\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\nstatic int iwl_mvm_d3_test_open(struct inode *inode, struct file *file)\n{\n\tstruct iwl_mvm *mvm = inode->i_private;\n\tint err;\n\n\tif (mvm->d3_test_active)\n\t\treturn -EBUSY;\n\n\tfile->private_data = inode->i_private;\n\n\tiwl_mvm_pause_tcm(mvm, true);\n\n\tiwl_fw_runtime_suspend(&mvm->fwrt);\n\n\t \n\trtnl_lock();\n\twiphy_lock(mvm->hw->wiphy);\n\terr = __iwl_mvm_suspend(mvm->hw, mvm->hw->wiphy->wowlan_config, true);\n\twiphy_unlock(mvm->hw->wiphy);\n\trtnl_unlock();\n\tif (err > 0)\n\t\terr = -EINVAL;\n\tif (err)\n\t\treturn err;\n\n\tmvm->d3_test_active = true;\n\tmvm->keep_vif = NULL;\n\treturn 0;\n}\n\nstatic ssize_t iwl_mvm_d3_test_read(struct file *file, char __user *user_buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm *mvm = file->private_data;\n\tu32 pme_asserted;\n\n\twhile (true) {\n\t\t \n\t\tif (mvm->d3_test_pme_ptr) {\n\t\t\tpme_asserted = iwl_trans_read_mem32(mvm->trans,\n\t\t\t\t\t\tmvm->d3_test_pme_ptr);\n\t\t\tif (pme_asserted)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (msleep_interruptible(100))\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void iwl_mvm_d3_test_disconn_work_iter(void *_data, u8 *mac,\n\t\t\t\t\t      struct ieee80211_vif *vif)\n{\n\t \n\tif (_data == vif)\n\t\treturn;\n\n\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\tieee80211_connection_loss(vif);\n}\n\nstatic int iwl_mvm_d3_test_release(struct inode *inode, struct file *file)\n{\n\tstruct iwl_mvm *mvm = inode->i_private;\n\tbool unified_image = fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t\t\t IWL_UCODE_TLV_CAPA_CNSLDTD_D3_D0_IMG);\n\n\tmvm->d3_test_active = false;\n\n\tiwl_fw_dbg_read_d3_debug_data(&mvm->fwrt);\n\n\trtnl_lock();\n\twiphy_lock(mvm->hw->wiphy);\n\t__iwl_mvm_resume(mvm, true);\n\twiphy_unlock(mvm->hw->wiphy);\n\trtnl_unlock();\n\n\tiwl_mvm_resume_tcm(mvm);\n\n\tiwl_fw_runtime_resume(&mvm->fwrt);\n\n\tiwl_abort_notification_waits(&mvm->notif_wait);\n\tif (!unified_image) {\n\t\tint remaining_time = 10;\n\n\t\tieee80211_restart_hw(mvm->hw);\n\n\t\t \n\t\twhile (test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status) &&\n\t\t       remaining_time > 0) {\n\t\t\tremaining_time--;\n\t\t\tmsleep(1000);\n\t\t}\n\n\t\tif (remaining_time == 0)\n\t\t\tIWL_ERR(mvm, \"Timed out waiting for HW restart!\\n\");\n\t}\n\n\tieee80211_iterate_active_interfaces_atomic(\n\t\tmvm->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\tiwl_mvm_d3_test_disconn_work_iter, mvm->keep_vif);\n\n\treturn 0;\n}\n\nconst struct file_operations iwl_dbgfs_d3_test_ops = {\n\t.llseek = no_llseek,\n\t.open = iwl_mvm_d3_test_open,\n\t.read = iwl_mvm_d3_test_read,\n\t.release = iwl_mvm_d3_test_release,\n};\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}