{
  "module_name": "utils.c",
  "hash_id": "8a64a886eafb6e5c6eff0824fd962b250673362e21741d79c46f53aae2536e01",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/utils.c",
  "human_readable_source": "\n \n#include <net/mac80211.h>\n\n#include \"iwl-debug.h\"\n#include \"iwl-io.h\"\n#include \"iwl-prph.h\"\n#include \"iwl-csr.h\"\n#include \"mvm.h\"\n#include \"fw/api/rs.h\"\n#include \"fw/img.h\"\n\n \nint iwl_mvm_send_cmd(struct iwl_mvm *mvm, struct iwl_host_cmd *cmd)\n{\n\tint ret;\n\n#if defined(CONFIG_IWLWIFI_DEBUGFS) && defined(CONFIG_PM_SLEEP)\n\tif (WARN_ON(mvm->d3_test_active))\n\t\treturn -EIO;\n#endif\n\n\t \n\tif (!(cmd->flags & CMD_ASYNC))\n\t\tlockdep_assert_held(&mvm->mutex);\n\n\tret = iwl_trans_send_cmd(mvm->trans, cmd);\n\n\t \n\tif (cmd->flags & CMD_WANT_SKB)\n\t\treturn ret;\n\n\t \n\tif (!ret || ret == -ERFKILL || ret == -EHOSTDOWN)\n\t\treturn 0;\n\treturn ret;\n}\n\nint iwl_mvm_send_cmd_pdu(struct iwl_mvm *mvm, u32 id,\n\t\t\t u32 flags, u16 len, const void *data)\n{\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = id,\n\t\t.len = { len, },\n\t\t.data = { data, },\n\t\t.flags = flags,\n\t};\n\n\treturn iwl_mvm_send_cmd(mvm, &cmd);\n}\n\n \nint iwl_mvm_send_cmd_status(struct iwl_mvm *mvm, struct iwl_host_cmd *cmd,\n\t\t\t    u32 *status)\n{\n\tstruct iwl_rx_packet *pkt;\n\tstruct iwl_cmd_response *resp;\n\tint ret, resp_len;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n#if defined(CONFIG_IWLWIFI_DEBUGFS) && defined(CONFIG_PM_SLEEP)\n\tif (WARN_ON(mvm->d3_test_active))\n\t\treturn -EIO;\n#endif\n\n\t \n\tif (WARN_ONCE(cmd->flags & (CMD_ASYNC | CMD_WANT_SKB),\n\t\t      \"cmd flags %x\", cmd->flags))\n\t\treturn -EINVAL;\n\n\tcmd->flags |= CMD_WANT_SKB;\n\n\tret = iwl_trans_send_cmd(mvm->trans, cmd);\n\tif (ret == -ERFKILL) {\n\t\t \n\t\treturn 0;\n\t} else if (ret) {\n\t\treturn ret;\n\t}\n\n\tpkt = cmd->resp_pkt;\n\n\tresp_len = iwl_rx_packet_payload_len(pkt);\n\tif (WARN_ON_ONCE(resp_len != sizeof(*resp))) {\n\t\tret = -EIO;\n\t\tgoto out_free_resp;\n\t}\n\n\tresp = (void *)pkt->data;\n\t*status = le32_to_cpu(resp->status);\n out_free_resp:\n\tiwl_free_resp(cmd);\n\treturn ret;\n}\n\n \nint iwl_mvm_send_cmd_pdu_status(struct iwl_mvm *mvm, u32 id, u16 len,\n\t\t\t\tconst void *data, u32 *status)\n{\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = id,\n\t\t.len = { len, },\n\t\t.data = { data, },\n\t};\n\n\treturn iwl_mvm_send_cmd_status(mvm, &cmd, status);\n}\n\nint iwl_mvm_legacy_hw_idx_to_mac80211_idx(u32 rate_n_flags,\n\t\t\t\t\t  enum nl80211_band band)\n{\n\tint format = rate_n_flags & RATE_MCS_MOD_TYPE_MSK;\n\tint rate = rate_n_flags & RATE_LEGACY_RATE_MSK;\n\tbool is_LB = band == NL80211_BAND_2GHZ;\n\n\tif (format == RATE_MCS_LEGACY_OFDM_MSK)\n\t\treturn is_LB ? rate + IWL_FIRST_OFDM_RATE :\n\t\t\trate;\n\n\t \n\treturn is_LB ? rate : -1;\n}\n\nint iwl_mvm_legacy_rate_to_mac80211_idx(u32 rate_n_flags,\n\t\t\t\t\tenum nl80211_band band)\n{\n\tint rate = rate_n_flags & RATE_LEGACY_RATE_MSK_V1;\n\tint idx;\n\tint band_offset = 0;\n\n\t \n\tif (band != NL80211_BAND_2GHZ)\n\t\tband_offset = IWL_FIRST_OFDM_RATE;\n\tfor (idx = band_offset; idx < IWL_RATE_COUNT_LEGACY; idx++)\n\t\tif (iwl_fw_rate_idx_to_plcp(idx) == rate)\n\t\t\treturn idx - band_offset;\n\n\treturn -1;\n}\n\nu8 iwl_mvm_mac80211_idx_to_hwrate(const struct iwl_fw *fw, int rate_idx)\n{\n\tif (iwl_fw_lookup_cmd_ver(fw, TX_CMD, 0) > 8)\n\t\t \n\t\treturn (rate_idx >= IWL_FIRST_OFDM_RATE ?\n\t\t\trate_idx - IWL_FIRST_OFDM_RATE :\n\t\t\trate_idx);\n\n\treturn iwl_fw_rate_idx_to_plcp(rate_idx);\n}\n\nu8 iwl_mvm_mac80211_ac_to_ucode_ac(enum ieee80211_ac_numbers ac)\n{\n\tstatic const u8 mac80211_ac_to_ucode_ac[] = {\n\t\tAC_VO,\n\t\tAC_VI,\n\t\tAC_BE,\n\t\tAC_BK\n\t};\n\n\treturn mac80211_ac_to_ucode_ac[ac];\n}\n\nvoid iwl_mvm_rx_fw_error(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_error_resp *err_resp = (void *)pkt->data;\n\n\tIWL_ERR(mvm, \"FW Error notification: type 0x%08X cmd_id 0x%02X\\n\",\n\t\tle32_to_cpu(err_resp->error_type), err_resp->cmd_id);\n\tIWL_ERR(mvm, \"FW Error notification: seq 0x%04X service 0x%08X\\n\",\n\t\tle16_to_cpu(err_resp->bad_cmd_seq_num),\n\t\tle32_to_cpu(err_resp->error_service));\n\tIWL_ERR(mvm, \"FW Error notification: timestamp 0x%016llX\\n\",\n\t\tle64_to_cpu(err_resp->timestamp));\n}\n\n \nu8 first_antenna(u8 mask)\n{\n\tBUILD_BUG_ON(ANT_A != BIT(0));  \n\tif (WARN_ON_ONCE(!mask))  \n\t\treturn BIT(0);\n\treturn BIT(ffs(mask) - 1);\n}\n\n#define MAX_ANT_NUM 2\n \nu8 iwl_mvm_next_antenna(struct iwl_mvm *mvm, u8 valid, u8 last_idx)\n{\n\tu8 ind = last_idx;\n\tint i;\n\n\tfor (i = 0; i < MAX_ANT_NUM; i++) {\n\t\tind = (ind + 1) % MAX_ANT_NUM;\n\t\tif (valid & BIT(ind))\n\t\t\treturn ind;\n\t}\n\n\tWARN_ONCE(1, \"Failed to toggle between antennas 0x%x\", valid);\n\treturn last_idx;\n}\n\n \nint iwl_mvm_send_lq_cmd(struct iwl_mvm *mvm, struct iwl_lq_cmd *lq)\n{\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = LQ_CMD,\n\t\t.len = { sizeof(struct iwl_lq_cmd), },\n\t\t.flags = CMD_ASYNC,\n\t\t.data = { lq, },\n\t};\n\n\tif (WARN_ON(lq->sta_id == IWL_MVM_INVALID_STA ||\n\t\t    iwl_mvm_has_tlc_offload(mvm)))\n\t\treturn -EINVAL;\n\n\treturn iwl_mvm_send_cmd(mvm, &cmd);\n}\n\n \nvoid iwl_mvm_update_smps(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t enum iwl_mvm_smps_type_request req_type,\n\t\t\t enum ieee80211_smps_mode smps_request,\n\t\t\t unsigned int link_id)\n{\n\tstruct iwl_mvm_vif *mvmvif;\n\tenum ieee80211_smps_mode smps_mode = IEEE80211_SMPS_AUTOMATIC;\n\tint i;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\t \n\tif (num_of_ant(iwl_mvm_get_valid_rx_ant(mvm)) == 1)\n\t\treturn;\n\n\tif (vif->type != NL80211_IFTYPE_STATION)\n\t\treturn;\n\n\tmvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tif (WARN_ON_ONCE(!mvmvif->link[link_id]))\n\t\treturn;\n\n\tmvmvif->link[link_id]->smps_requests[req_type] = smps_request;\n\tfor (i = 0; i < NUM_IWL_MVM_SMPS_REQ; i++) {\n\t\tif (mvmvif->link[link_id]->smps_requests[i] ==\n\t\t    IEEE80211_SMPS_STATIC) {\n\t\t\tsmps_mode = IEEE80211_SMPS_STATIC;\n\t\t\tbreak;\n\t\t}\n\t\tif (mvmvif->link[link_id]->smps_requests[i] ==\n\t\t    IEEE80211_SMPS_DYNAMIC)\n\t\t\tsmps_mode = IEEE80211_SMPS_DYNAMIC;\n\t}\n\n\t \n\tif (mvmvif->esr_active)\n\t\tsmps_mode = IEEE80211_SMPS_OFF;\n\n\tieee80211_request_smps(vif, link_id, smps_mode);\n}\n\nvoid iwl_mvm_update_smps_on_active_links(struct iwl_mvm *mvm,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t enum iwl_mvm_smps_type_request req_type,\n\t\t\t\t\t enum ieee80211_smps_mode smps_request)\n{\n\tstruct ieee80211_bss_conf *link_conf;\n\tunsigned int link_id;\n\n\trcu_read_lock();\n\tfor_each_vif_active_link(vif, link_conf, link_id)\n\t\tiwl_mvm_update_smps(mvm, vif, req_type, smps_request,\n\t\t\t\t    link_id);\n\trcu_read_unlock();\n}\n\nstatic bool iwl_wait_stats_complete(struct iwl_notif_wait_data *notif_wait,\n\t\t\t\t    struct iwl_rx_packet *pkt, void *data)\n{\n\tWARN_ON(pkt->hdr.cmd != STATISTICS_NOTIFICATION);\n\n\treturn true;\n}\n\nint iwl_mvm_request_statistics(struct iwl_mvm *mvm, bool clear)\n{\n\tstruct iwl_statistics_cmd scmd = {\n\t\t.flags = clear ? cpu_to_le32(IWL_STATISTICS_FLG_CLEAR) : 0,\n\t};\n\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = STATISTICS_CMD,\n\t\t.len[0] = sizeof(scmd),\n\t\t.data[0] = &scmd,\n\t};\n\tint ret;\n\n\t \n\tif (iwl_fw_lookup_notif_ver(mvm->fw, LEGACY_GROUP,\n\t\t\t\t    STATISTICS_NOTIFICATION, 0) < 15) {\n\t\tcmd.flags = CMD_WANT_SKB;\n\n\t\tret = iwl_mvm_send_cmd(mvm, &cmd);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tiwl_mvm_handle_rx_statistics(mvm, cmd.resp_pkt);\n\t\tiwl_free_resp(&cmd);\n\t} else {\n\t\tstruct iwl_notification_wait stats_wait;\n\t\tstatic const u16 stats_complete[] = {\n\t\t\tSTATISTICS_NOTIFICATION,\n\t\t};\n\n\t\tiwl_init_notification_wait(&mvm->notif_wait, &stats_wait,\n\t\t\t\t\t   stats_complete, ARRAY_SIZE(stats_complete),\n\t\t\t\t\t   iwl_wait_stats_complete, NULL);\n\n\t\tret = iwl_mvm_send_cmd(mvm, &cmd);\n\t\tif (ret) {\n\t\t\tiwl_remove_notification(&mvm->notif_wait, &stats_wait);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = iwl_wait_notification(&mvm->notif_wait, &stats_wait, HZ / 5);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (clear)\n\t\tiwl_mvm_accu_radio_stats(mvm);\n\n\treturn 0;\n}\n\nvoid iwl_mvm_accu_radio_stats(struct iwl_mvm *mvm)\n{\n\tmvm->accu_radio_stats.rx_time += mvm->radio_stats.rx_time;\n\tmvm->accu_radio_stats.tx_time += mvm->radio_stats.tx_time;\n\tmvm->accu_radio_stats.on_time_rf += mvm->radio_stats.on_time_rf;\n\tmvm->accu_radio_stats.on_time_scan += mvm->radio_stats.on_time_scan;\n}\n\nstruct iwl_mvm_diversity_iter_data {\n\tstruct iwl_mvm_phy_ctxt *ctxt;\n\tbool result;\n};\n\nstatic void iwl_mvm_diversity_iter(void *_data, u8 *mac,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_diversity_iter_data *data = _data;\n\tint i, link_id;\n\n\tfor_each_mvm_vif_valid_link(mvmvif, link_id) {\n\t\tstruct iwl_mvm_vif_link_info *link_info = mvmvif->link[link_id];\n\n\t\tif (link_info->phy_ctxt != data->ctxt)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < NUM_IWL_MVM_SMPS_REQ; i++) {\n\t\t\tif (link_info->smps_requests[i] == IEEE80211_SMPS_STATIC ||\n\t\t\t    link_info->smps_requests[i] == IEEE80211_SMPS_DYNAMIC) {\n\t\t\t\tdata->result = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool iwl_mvm_rx_diversity_allowed(struct iwl_mvm *mvm,\n\t\t\t\t  struct iwl_mvm_phy_ctxt *ctxt)\n{\n\tstruct iwl_mvm_diversity_iter_data data = {\n\t\t.ctxt = ctxt,\n\t\t.result = true,\n\t};\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (iwlmvm_mod_params.power_scheme != IWL_POWER_SCHEME_CAM)\n\t\treturn false;\n\n\tif (num_of_ant(iwl_mvm_get_valid_rx_ant(mvm)) == 1)\n\t\treturn false;\n\n\tif (mvm->cfg->rx_with_siso_diversity)\n\t\treturn false;\n\n\tieee80211_iterate_active_interfaces_atomic(\n\t\t\tmvm->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\t\tiwl_mvm_diversity_iter, &data);\n\n\treturn data.result;\n}\n\nvoid iwl_mvm_send_low_latency_cmd(struct iwl_mvm *mvm,\n\t\t\t\t  bool low_latency, u16 mac_id)\n{\n\tstruct iwl_mac_low_latency_cmd cmd = {\n\t\t.mac_id = cpu_to_le32(mac_id)\n\t};\n\n\tif (!fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t IWL_UCODE_TLV_CAPA_DYNAMIC_QUOTA))\n\t\treturn;\n\n\tif (low_latency) {\n\t\t \n\t\tcmd.low_latency_rx = 1;\n\t\tcmd.low_latency_tx = 1;\n\t}\n\n\tif (iwl_mvm_send_cmd_pdu(mvm, WIDE_ID(MAC_CONF_GROUP, LOW_LATENCY_CMD),\n\t\t\t\t 0, sizeof(cmd), &cmd))\n\t\tIWL_ERR(mvm, \"Failed to send low latency command\\n\");\n}\n\nint iwl_mvm_update_low_latency(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t       bool low_latency,\n\t\t\t       enum iwl_mvm_low_latency_cause cause)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tint res;\n\tbool prev;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tprev = iwl_mvm_vif_low_latency(mvmvif);\n\tiwl_mvm_vif_set_low_latency(mvmvif, low_latency, cause);\n\n\tlow_latency = iwl_mvm_vif_low_latency(mvmvif);\n\n\tif (low_latency == prev)\n\t\treturn 0;\n\n\tiwl_mvm_send_low_latency_cmd(mvm, low_latency, mvmvif->id);\n\n\tres = iwl_mvm_update_quotas(mvm, false, NULL);\n\tif (res)\n\t\treturn res;\n\n\tiwl_mvm_bt_coex_vif_change(mvm);\n\n\treturn iwl_mvm_power_update_mac(mvm);\n}\n\nstruct iwl_mvm_low_latency_iter {\n\tbool result;\n\tbool result_per_band[NUM_NL80211_BANDS];\n};\n\nstatic void iwl_mvm_ll_iter(void *_data, u8 *mac, struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_low_latency_iter *result = _data;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tenum nl80211_band band;\n\n\tif (iwl_mvm_vif_low_latency(mvmvif)) {\n\t\tresult->result = true;\n\n\t\tif (!mvmvif->deflink.phy_ctxt)\n\t\t\treturn;\n\n\t\tband = mvmvif->deflink.phy_ctxt->channel->band;\n\t\tresult->result_per_band[band] = true;\n\t}\n}\n\nbool iwl_mvm_low_latency(struct iwl_mvm *mvm)\n{\n\tstruct iwl_mvm_low_latency_iter data = {};\n\n\tieee80211_iterate_active_interfaces_atomic(\n\t\t\tmvm->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\t\tiwl_mvm_ll_iter, &data);\n\n\treturn data.result;\n}\n\nbool iwl_mvm_low_latency_band(struct iwl_mvm *mvm, enum nl80211_band band)\n{\n\tstruct iwl_mvm_low_latency_iter data = {};\n\n\tieee80211_iterate_active_interfaces_atomic(\n\t\t\tmvm->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\t\tiwl_mvm_ll_iter, &data);\n\n\treturn data.result_per_band[band];\n}\n\nstruct iwl_bss_iter_data {\n\tstruct ieee80211_vif *vif;\n\tbool error;\n};\n\nstatic void iwl_mvm_bss_iface_iterator(void *_data, u8 *mac,\n\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tstruct iwl_bss_iter_data *data = _data;\n\n\tif (vif->type != NL80211_IFTYPE_STATION || vif->p2p)\n\t\treturn;\n\n\tif (data->vif) {\n\t\tdata->error = true;\n\t\treturn;\n\t}\n\n\tdata->vif = vif;\n}\n\nstruct ieee80211_vif *iwl_mvm_get_bss_vif(struct iwl_mvm *mvm)\n{\n\tstruct iwl_bss_iter_data bss_iter_data = {};\n\n\tieee80211_iterate_active_interfaces_atomic(\n\t\tmvm->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\tiwl_mvm_bss_iface_iterator, &bss_iter_data);\n\n\tif (bss_iter_data.error) {\n\t\tIWL_ERR(mvm, \"More than one managed interface active!\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn bss_iter_data.vif;\n}\n\nstruct iwl_bss_find_iter_data {\n\tstruct ieee80211_vif *vif;\n\tu32 macid;\n};\n\nstatic void iwl_mvm_bss_find_iface_iterator(void *_data, u8 *mac,\n\t\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct iwl_bss_find_iter_data *data = _data;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tif (mvmvif->id == data->macid)\n\t\tdata->vif = vif;\n}\n\nstruct ieee80211_vif *iwl_mvm_get_vif_by_macid(struct iwl_mvm *mvm, u32 macid)\n{\n\tstruct iwl_bss_find_iter_data data = {\n\t\t.macid = macid,\n\t};\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tieee80211_iterate_active_interfaces_atomic(\n\t\tmvm->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\tiwl_mvm_bss_find_iface_iterator, &data);\n\n\treturn data.vif;\n}\n\nstruct iwl_sta_iter_data {\n\tbool assoc;\n};\n\nstatic void iwl_mvm_sta_iface_iterator(void *_data, u8 *mac,\n\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tstruct iwl_sta_iter_data *data = _data;\n\n\tif (vif->type != NL80211_IFTYPE_STATION)\n\t\treturn;\n\n\tif (vif->cfg.assoc)\n\t\tdata->assoc = true;\n}\n\nbool iwl_mvm_is_vif_assoc(struct iwl_mvm *mvm)\n{\n\tstruct iwl_sta_iter_data data = {\n\t\t.assoc = false,\n\t};\n\n\tieee80211_iterate_active_interfaces_atomic(mvm->hw,\n\t\t\t\t\t\t   IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\t\t   iwl_mvm_sta_iface_iterator,\n\t\t\t\t\t\t   &data);\n\treturn data.assoc;\n}\n\nunsigned int iwl_mvm_get_wd_timeout(struct iwl_mvm *mvm,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    bool tdls, bool cmd_q)\n{\n\tstruct iwl_fw_dbg_trigger_tlv *trigger;\n\tstruct iwl_fw_dbg_trigger_txq_timer *txq_timer;\n\tunsigned int default_timeout = cmd_q ?\n\t\tIWL_DEF_WD_TIMEOUT :\n\t\tmvm->trans->trans_cfg->base_params->wd_timeout;\n\n\tif (!iwl_fw_dbg_trigger_enabled(mvm->fw, FW_DBG_TRIGGER_TXQ_TIMERS)) {\n\t\t \n\t\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t\tIWL_UCODE_TLV_CAPA_STA_PM_NOTIF) &&\n\t\t    vif && vif->type == NL80211_IFTYPE_AP)\n\t\t\treturn IWL_WATCHDOG_DISABLED;\n\t\treturn default_timeout;\n\t}\n\n\ttrigger = iwl_fw_dbg_get_trigger(mvm->fw, FW_DBG_TRIGGER_TXQ_TIMERS);\n\ttxq_timer = (void *)trigger->data;\n\n\tif (tdls)\n\t\treturn le32_to_cpu(txq_timer->tdls);\n\n\tif (cmd_q)\n\t\treturn le32_to_cpu(txq_timer->command_queue);\n\n\tif (WARN_ON(!vif))\n\t\treturn default_timeout;\n\n\tswitch (ieee80211_vif_type_p2p(vif)) {\n\tcase NL80211_IFTYPE_ADHOC:\n\t\treturn le32_to_cpu(txq_timer->ibss);\n\tcase NL80211_IFTYPE_STATION:\n\t\treturn le32_to_cpu(txq_timer->bss);\n\tcase NL80211_IFTYPE_AP:\n\t\treturn le32_to_cpu(txq_timer->softap);\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\treturn le32_to_cpu(txq_timer->p2p_client);\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\treturn le32_to_cpu(txq_timer->p2p_go);\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\treturn le32_to_cpu(txq_timer->p2p_device);\n\tcase NL80211_IFTYPE_MONITOR:\n\t\treturn default_timeout;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn mvm->trans->trans_cfg->base_params->wd_timeout;\n\t}\n}\n\nvoid iwl_mvm_connection_loss(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t     const char *errmsg)\n{\n\tstruct iwl_fw_dbg_trigger_tlv *trig;\n\tstruct iwl_fw_dbg_trigger_mlme *trig_mlme;\n\n\ttrig = iwl_fw_dbg_trigger_on(&mvm->fwrt, ieee80211_vif_to_wdev(vif),\n\t\t\t\t     FW_DBG_TRIGGER_MLME);\n\tif (!trig)\n\t\tgoto out;\n\n\ttrig_mlme = (void *)trig->data;\n\n\tif (trig_mlme->stop_connection_loss &&\n\t    --trig_mlme->stop_connection_loss)\n\t\tgoto out;\n\n\tiwl_fw_dbg_collect_trig(&mvm->fwrt, trig, \"%s\", errmsg);\n\nout:\n\tieee80211_connection_loss(vif);\n}\n\nvoid iwl_mvm_event_frame_timeout_callback(struct iwl_mvm *mvm,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  const struct ieee80211_sta *sta,\n\t\t\t\t\t  u16 tid)\n{\n\tstruct iwl_fw_dbg_trigger_tlv *trig;\n\tstruct iwl_fw_dbg_trigger_ba *ba_trig;\n\n\ttrig = iwl_fw_dbg_trigger_on(&mvm->fwrt, ieee80211_vif_to_wdev(vif),\n\t\t\t\t     FW_DBG_TRIGGER_BA);\n\tif (!trig)\n\t\treturn;\n\n\tba_trig = (void *)trig->data;\n\n\tif (!(le16_to_cpu(ba_trig->frame_timeout) & BIT(tid)))\n\t\treturn;\n\n\tiwl_fw_dbg_collect_trig(&mvm->fwrt, trig,\n\t\t\t\t\"Frame from %pM timed out, tid %d\",\n\t\t\t\tsta->addr, tid);\n}\n\nu8 iwl_mvm_tcm_load_percentage(u32 airtime, u32 elapsed)\n{\n\tif (!elapsed)\n\t\treturn 0;\n\n\treturn (100 * airtime / elapsed) / USEC_PER_MSEC;\n}\n\nstatic enum iwl_mvm_traffic_load\niwl_mvm_tcm_load(struct iwl_mvm *mvm, u32 airtime, unsigned long elapsed)\n{\n\tu8 load = iwl_mvm_tcm_load_percentage(airtime, elapsed);\n\n\tif (load > IWL_MVM_TCM_LOAD_HIGH_THRESH)\n\t\treturn IWL_MVM_TRAFFIC_HIGH;\n\tif (load > IWL_MVM_TCM_LOAD_MEDIUM_THRESH)\n\t\treturn IWL_MVM_TRAFFIC_MEDIUM;\n\n\treturn IWL_MVM_TRAFFIC_LOW;\n}\n\nstatic void iwl_mvm_tcm_iter(void *_data, u8 *mac, struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm *mvm = _data;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tbool low_latency, prev = mvmvif->low_latency & LOW_LATENCY_TRAFFIC;\n\n\tif (mvmvif->id >= NUM_MAC_INDEX_DRIVER)\n\t\treturn;\n\n\tlow_latency = mvm->tcm.result.low_latency[mvmvif->id];\n\n\tif (!mvm->tcm.result.change[mvmvif->id] &&\n\t    prev == low_latency) {\n\t\tiwl_mvm_update_quotas(mvm, false, NULL);\n\t\treturn;\n\t}\n\n\tif (prev != low_latency) {\n\t\t \n\t\tiwl_mvm_update_low_latency(mvm, vif, low_latency,\n\t\t\t\t\t   LOW_LATENCY_TRAFFIC);\n\t} else {\n\t\tiwl_mvm_update_quotas(mvm, false, NULL);\n\t}\n}\n\nstatic void iwl_mvm_tcm_results(struct iwl_mvm *mvm)\n{\n\tmutex_lock(&mvm->mutex);\n\n\tieee80211_iterate_active_interfaces(\n\t\tmvm->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\tiwl_mvm_tcm_iter, mvm);\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa, IWL_UCODE_TLV_CAPA_UMAC_SCAN))\n\t\tiwl_mvm_config_scan(mvm);\n\n\tmutex_unlock(&mvm->mutex);\n}\n\nstatic void iwl_mvm_tcm_uapsd_nonagg_detected_wk(struct work_struct *wk)\n{\n\tstruct iwl_mvm *mvm;\n\tstruct iwl_mvm_vif *mvmvif;\n\tstruct ieee80211_vif *vif;\n\n\tmvmvif = container_of(wk, struct iwl_mvm_vif,\n\t\t\t      uapsd_nonagg_detected_wk.work);\n\tvif = container_of((void *)mvmvif, struct ieee80211_vif, drv_priv);\n\tmvm = mvmvif->mvm;\n\n\tif (mvm->tcm.data[mvmvif->id].opened_rx_ba_sessions)\n\t\treturn;\n\n\t \n\tmemcpy(mvm->uapsd_noagg_bssids[mvm->uapsd_noagg_bssid_write_idx].addr,\n\t       vif->bss_conf.bssid, ETH_ALEN);\n\tmvm->uapsd_noagg_bssid_write_idx++;\n\tif (mvm->uapsd_noagg_bssid_write_idx >= IWL_MVM_UAPSD_NOAGG_LIST_LEN)\n\t\tmvm->uapsd_noagg_bssid_write_idx = 0;\n\n\tiwl_mvm_connection_loss(mvm, vif,\n\t\t\t\t\"AP isn't using AMPDU with uAPSD enabled\");\n}\n\nstatic void iwl_mvm_uapsd_agg_disconnect(struct iwl_mvm *mvm,\n\t\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tif (vif->type != NL80211_IFTYPE_STATION)\n\t\treturn;\n\n\tif (!vif->cfg.assoc)\n\t\treturn;\n\n\tif (!mvmvif->deflink.queue_params[IEEE80211_AC_VO].uapsd &&\n\t    !mvmvif->deflink.queue_params[IEEE80211_AC_VI].uapsd &&\n\t    !mvmvif->deflink.queue_params[IEEE80211_AC_BE].uapsd &&\n\t    !mvmvif->deflink.queue_params[IEEE80211_AC_BK].uapsd)\n\t\treturn;\n\n\tif (mvm->tcm.data[mvmvif->id].uapsd_nonagg_detect.detected)\n\t\treturn;\n\n\tmvm->tcm.data[mvmvif->id].uapsd_nonagg_detect.detected = true;\n\tIWL_INFO(mvm,\n\t\t \"detected AP should do aggregation but isn't, likely due to U-APSD\\n\");\n\tschedule_delayed_work(&mvmvif->uapsd_nonagg_detected_wk,\n\t\t\t      15 * HZ);\n}\n\nstatic void iwl_mvm_check_uapsd_agg_expected_tpt(struct iwl_mvm *mvm,\n\t\t\t\t\t\t unsigned int elapsed,\n\t\t\t\t\t\t int mac)\n{\n\tu64 bytes = mvm->tcm.data[mac].uapsd_nonagg_detect.rx_bytes;\n\tu64 tpt;\n\tunsigned long rate;\n\tstruct ieee80211_vif *vif;\n\n\trate = ewma_rate_read(&mvm->tcm.data[mac].uapsd_nonagg_detect.rate);\n\n\tif (!rate || mvm->tcm.data[mac].opened_rx_ba_sessions ||\n\t    mvm->tcm.data[mac].uapsd_nonagg_detect.detected)\n\t\treturn;\n\n\tif (iwl_mvm_has_new_rx_api(mvm)) {\n\t\ttpt = 8 * bytes;  \n\t\tdo_div(tpt, elapsed);\n\t\trate *= 1000;  \n\t\tif (tpt < 22 * rate / 100)\n\t\t\treturn;\n\t} else {\n\t\t \n\t\ttpt = (8 * bytes);\n\t\tdo_div(tpt, elapsed * 100);\n\t\tif (tpt < rate)\n\t\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tvif = rcu_dereference(mvm->vif_id_to_mac[mac]);\n\tif (vif)\n\t\tiwl_mvm_uapsd_agg_disconnect(mvm, vif);\n\trcu_read_unlock();\n}\n\nstatic void iwl_mvm_tcm_iterator(void *_data, u8 *mac,\n\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tu32 *band = _data;\n\n\tif (!mvmvif->deflink.phy_ctxt)\n\t\treturn;\n\n\tband[mvmvif->id] = mvmvif->deflink.phy_ctxt->channel->band;\n}\n\nstatic unsigned long iwl_mvm_calc_tcm_stats(struct iwl_mvm *mvm,\n\t\t\t\t\t    unsigned long ts,\n\t\t\t\t\t    bool handle_uapsd)\n{\n\tunsigned int elapsed = jiffies_to_msecs(ts - mvm->tcm.ts);\n\tunsigned int uapsd_elapsed =\n\t\tjiffies_to_msecs(ts - mvm->tcm.uapsd_nonagg_ts);\n\tu32 total_airtime = 0;\n\tu32 band_airtime[NUM_NL80211_BANDS] = {0};\n\tu32 band[NUM_MAC_INDEX_DRIVER] = {0};\n\tint ac, mac, i;\n\tbool low_latency = false;\n\tenum iwl_mvm_traffic_load load, band_load;\n\tbool handle_ll = time_after(ts, mvm->tcm.ll_ts + MVM_LL_PERIOD);\n\n\tif (handle_ll)\n\t\tmvm->tcm.ll_ts = ts;\n\tif (handle_uapsd)\n\t\tmvm->tcm.uapsd_nonagg_ts = ts;\n\n\tmvm->tcm.result.elapsed = elapsed;\n\n\tieee80211_iterate_active_interfaces_atomic(mvm->hw,\n\t\t\t\t\t\t   IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\t\t   iwl_mvm_tcm_iterator,\n\t\t\t\t\t\t   &band);\n\n\tfor (mac = 0; mac < NUM_MAC_INDEX_DRIVER; mac++) {\n\t\tstruct iwl_mvm_tcm_mac *mdata = &mvm->tcm.data[mac];\n\t\tu32 vo_vi_pkts = 0;\n\t\tu32 airtime = mdata->rx.airtime + mdata->tx.airtime;\n\n\t\ttotal_airtime += airtime;\n\t\tband_airtime[band[mac]] += airtime;\n\n\t\tload = iwl_mvm_tcm_load(mvm, airtime, elapsed);\n\t\tmvm->tcm.result.change[mac] = load != mvm->tcm.result.load[mac];\n\t\tmvm->tcm.result.load[mac] = load;\n\t\tmvm->tcm.result.airtime[mac] = airtime;\n\n\t\tfor (ac = IEEE80211_AC_VO; ac <= IEEE80211_AC_VI; ac++)\n\t\t\tvo_vi_pkts += mdata->rx.pkts[ac] +\n\t\t\t\t      mdata->tx.pkts[ac];\n\n\t\t \n\t\tif (vo_vi_pkts > IWL_MVM_TCM_LOWLAT_ENABLE_THRESH)\n\t\t\tmvm->tcm.result.low_latency[mac] = true;\n\t\telse if (handle_ll)\n\t\t\tmvm->tcm.result.low_latency[mac] = false;\n\n\t\tif (handle_ll) {\n\t\t\t \n\t\t\tmemset(&mdata->rx.pkts, 0, sizeof(mdata->rx.pkts));\n\t\t\tmemset(&mdata->tx.pkts, 0, sizeof(mdata->tx.pkts));\n\t\t}\n\t\tlow_latency |= mvm->tcm.result.low_latency[mac];\n\n\t\tif (!mvm->tcm.result.low_latency[mac] && handle_uapsd)\n\t\t\tiwl_mvm_check_uapsd_agg_expected_tpt(mvm, uapsd_elapsed,\n\t\t\t\t\t\t\t     mac);\n\t\t \n\t\tif (handle_uapsd)\n\t\t\tmdata->uapsd_nonagg_detect.rx_bytes = 0;\n\t\tmemset(&mdata->rx.airtime, 0, sizeof(mdata->rx.airtime));\n\t\tmemset(&mdata->tx.airtime, 0, sizeof(mdata->tx.airtime));\n\t}\n\n\tload = iwl_mvm_tcm_load(mvm, total_airtime, elapsed);\n\tmvm->tcm.result.global_load = load;\n\n\tfor (i = 0; i < NUM_NL80211_BANDS; i++) {\n\t\tband_load = iwl_mvm_tcm_load(mvm, band_airtime[i], elapsed);\n\t\tmvm->tcm.result.band_load[i] = band_load;\n\t}\n\n\t \n\tif (load != IWL_MVM_TRAFFIC_LOW)\n\t\treturn MVM_TCM_PERIOD;\n\t \n\tif (low_latency)\n\t\treturn MVM_LL_PERIOD;\n\t \n\treturn 0;\n}\n\nvoid iwl_mvm_recalc_tcm(struct iwl_mvm *mvm)\n{\n\tunsigned long ts = jiffies;\n\tbool handle_uapsd =\n\t\ttime_after(ts, mvm->tcm.uapsd_nonagg_ts +\n\t\t\t       msecs_to_jiffies(IWL_MVM_UAPSD_NONAGG_PERIOD));\n\n\tspin_lock(&mvm->tcm.lock);\n\tif (mvm->tcm.paused || !time_after(ts, mvm->tcm.ts + MVM_TCM_PERIOD)) {\n\t\tspin_unlock(&mvm->tcm.lock);\n\t\treturn;\n\t}\n\tspin_unlock(&mvm->tcm.lock);\n\n\tif (handle_uapsd && iwl_mvm_has_new_rx_api(mvm)) {\n\t\tmutex_lock(&mvm->mutex);\n\t\tif (iwl_mvm_request_statistics(mvm, true))\n\t\t\thandle_uapsd = false;\n\t\tmutex_unlock(&mvm->mutex);\n\t}\n\n\tspin_lock(&mvm->tcm.lock);\n\t \n\tif (!mvm->tcm.paused && time_after(ts, mvm->tcm.ts + MVM_TCM_PERIOD)) {\n\t\t \n\t\tunsigned long work_delay = iwl_mvm_calc_tcm_stats(mvm, ts,\n\t\t\t\t\t\t\t\t  handle_uapsd);\n\n\t\t \n\t\tsmp_mb();\n\t\tmvm->tcm.ts = ts;\n\t\tif (work_delay)\n\t\t\tschedule_delayed_work(&mvm->tcm.work, work_delay);\n\t}\n\tspin_unlock(&mvm->tcm.lock);\n\n\tiwl_mvm_tcm_results(mvm);\n}\n\nvoid iwl_mvm_tcm_work(struct work_struct *work)\n{\n\tstruct delayed_work *delayed_work = to_delayed_work(work);\n\tstruct iwl_mvm *mvm = container_of(delayed_work, struct iwl_mvm,\n\t\t\t\t\t   tcm.work);\n\n\tiwl_mvm_recalc_tcm(mvm);\n}\n\nvoid iwl_mvm_pause_tcm(struct iwl_mvm *mvm, bool with_cancel)\n{\n\tspin_lock_bh(&mvm->tcm.lock);\n\tmvm->tcm.paused = true;\n\tspin_unlock_bh(&mvm->tcm.lock);\n\tif (with_cancel)\n\t\tcancel_delayed_work_sync(&mvm->tcm.work);\n}\n\nvoid iwl_mvm_resume_tcm(struct iwl_mvm *mvm)\n{\n\tint mac;\n\tbool low_latency = false;\n\n\tspin_lock_bh(&mvm->tcm.lock);\n\tmvm->tcm.ts = jiffies;\n\tmvm->tcm.ll_ts = jiffies;\n\tfor (mac = 0; mac < NUM_MAC_INDEX_DRIVER; mac++) {\n\t\tstruct iwl_mvm_tcm_mac *mdata = &mvm->tcm.data[mac];\n\n\t\tmemset(&mdata->rx.pkts, 0, sizeof(mdata->rx.pkts));\n\t\tmemset(&mdata->tx.pkts, 0, sizeof(mdata->tx.pkts));\n\t\tmemset(&mdata->rx.airtime, 0, sizeof(mdata->rx.airtime));\n\t\tmemset(&mdata->tx.airtime, 0, sizeof(mdata->tx.airtime));\n\n\t\tif (mvm->tcm.result.low_latency[mac])\n\t\t\tlow_latency = true;\n\t}\n\t \n\tsmp_mb();\n\tmvm->tcm.paused = false;\n\n\t \n\tif (mvm->tcm.result.global_load > IWL_MVM_TRAFFIC_LOW)\n\t\tschedule_delayed_work(&mvm->tcm.work, MVM_TCM_PERIOD);\n\telse if (low_latency)\n\t\tschedule_delayed_work(&mvm->tcm.work, MVM_LL_PERIOD);\n\n\tspin_unlock_bh(&mvm->tcm.lock);\n}\n\nvoid iwl_mvm_tcm_add_vif(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tINIT_DELAYED_WORK(&mvmvif->uapsd_nonagg_detected_wk,\n\t\t\t  iwl_mvm_tcm_uapsd_nonagg_detected_wk);\n}\n\nvoid iwl_mvm_tcm_rm_vif(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tcancel_delayed_work_sync(&mvmvif->uapsd_nonagg_detected_wk);\n}\n\nu32 iwl_mvm_get_systime(struct iwl_mvm *mvm)\n{\n\tu32 reg_addr = DEVICE_SYSTEM_TIME_REG;\n\n\tif (mvm->trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_22000 &&\n\t    mvm->trans->cfg->gp2_reg_addr)\n\t\treg_addr = mvm->trans->cfg->gp2_reg_addr;\n\n\treturn iwl_read_prph(mvm->trans, reg_addr);\n}\n\nvoid iwl_mvm_get_sync_time(struct iwl_mvm *mvm, int clock_type,\n\t\t\t   u32 *gp2, u64 *boottime, ktime_t *realtime)\n{\n\tbool ps_disabled;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\t \n\tps_disabled = mvm->ps_disabled;\n\tif (!ps_disabled) {\n\t\tmvm->ps_disabled = true;\n\t\tiwl_mvm_power_update_device(mvm);\n\t}\n\n\t*gp2 = iwl_mvm_get_systime(mvm);\n\n\tif (clock_type == CLOCK_BOOTTIME && boottime)\n\t\t*boottime = ktime_get_boottime_ns();\n\telse if (clock_type == CLOCK_REALTIME && realtime)\n\t\t*realtime = ktime_get_real();\n\n\tif (!ps_disabled) {\n\t\tmvm->ps_disabled = ps_disabled;\n\t\tiwl_mvm_power_update_device(mvm);\n\t}\n}\n\n \nbool iwl_mvm_have_links_same_channel(struct iwl_mvm_vif *vif1,\n\t\t\t\t     struct iwl_mvm_vif *vif2)\n{\n\tunsigned int i, j;\n\n\tfor_each_mvm_vif_valid_link(vif1, i) {\n\t\tfor_each_mvm_vif_valid_link(vif2, j) {\n\t\t\tif (vif1->link[i]->phy_ctxt == vif2->link[j]->phy_ctxt)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool iwl_mvm_vif_is_active(struct iwl_mvm_vif *mvmvif)\n{\n\tunsigned int i;\n\n\t \n\tfor_each_mvm_vif_valid_link(mvmvif, i) {\n\t\tif (mvmvif->link[i]->phy_ctxt &&\n\t\t    mvmvif->link[i]->phy_ctxt->id < NUM_PHY_CTX)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}