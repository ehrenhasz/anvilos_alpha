{
  "module_name": "mld-mac80211.c",
  "hash_id": "a7e5811f1499c39741acb08ef0c32085f906a45b2f66aa02ced54e96edefda50",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/mld-mac80211.c",
  "human_readable_source": "\n \n#include \"mvm.h\"\n\nstatic int iwl_mvm_mld_mac_add_interface(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tint ret;\n\n\tmutex_lock(&mvm->mutex);\n\n\tmvmvif->mvm = mvm;\n\n\t \n\n\t \n\tif (test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status))\n\t\tmvmvif->deflink.beacon_stats.accu_num_beacons +=\n\t\t\tmvmvif->deflink.beacon_stats.num_beacons;\n\n\t \n\tret = iwl_mvm_mac_ctxt_init(mvm, vif);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\trcu_assign_pointer(mvm->vif_id_to_mac[mvmvif->id], vif);\n\n\tmvmvif->features |= hw->netdev_features;\n\n\t \n\tmvmvif->deflink.fw_link_id = IWL_MVM_FW_LINK_ID_INVALID;\n\tmvmvif->deflink.active = 0;\n\t \n\tmvmvif->link[0] = &mvmvif->deflink;\n\n\tret = iwl_mvm_mld_mac_ctxt_add(mvm, vif);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tret = iwl_mvm_disable_beacon_filter(mvm, vif, 0);\n\tif (ret)\n\t\tgoto out_remove_mac;\n\n\tif (!mvm->bf_allowed_vif &&\n\t    vif->type == NL80211_IFTYPE_STATION && !vif->p2p) {\n\t\tmvm->bf_allowed_vif = mvmvif;\n\t\tvif->driver_flags |= IEEE80211_VIF_BEACON_FILTER |\n\t\t\t\t     IEEE80211_VIF_SUPPORTS_CQM_RSSI;\n\t}\n\n\tret = iwl_mvm_add_link(mvm, vif, &vif->bss_conf);\n\tif (ret)\n\t\tgoto out_free_bf;\n\n\t \n\tif (vif->type == NL80211_IFTYPE_P2P_DEVICE)\n\t\tmvm->p2p_device_vif = vif;\n\n\tret = iwl_mvm_power_update_mac(mvm);\n\tif (ret)\n\t\tgoto out_free_bf;\n\n\tiwl_mvm_tcm_add_vif(mvm, vif);\n\tINIT_DELAYED_WORK(&mvmvif->csa_work,\n\t\t\t  iwl_mvm_channel_switch_disconnect_wk);\n\n\tif (vif->type == NL80211_IFTYPE_MONITOR) {\n\t\tmvm->monitor_on = true;\n\t\tieee80211_hw_set(mvm->hw, RX_INCLUDES_FCS);\n\t}\n\n\tiwl_mvm_vif_dbgfs_register(mvm, vif);\n\n\tif (!test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status) &&\n\t    vif->type == NL80211_IFTYPE_STATION && !vif->p2p &&\n\t    !mvm->csme_vif && mvm->mei_registered) {\n\t\tiwl_mei_set_nic_info(vif->addr, mvm->nvm_data->hw_addr);\n\t\tiwl_mei_set_netdev(ieee80211_vif_to_wdev(vif)->netdev);\n\t\tmvm->csme_vif = vif;\n\t}\n\n\tgoto out_unlock;\n\n out_free_bf:\n\tif (mvm->bf_allowed_vif == mvmvif) {\n\t\tmvm->bf_allowed_vif = NULL;\n\t\tvif->driver_flags &= ~(IEEE80211_VIF_BEACON_FILTER |\n\t\t\t\t       IEEE80211_VIF_SUPPORTS_CQM_RSSI);\n\t}\n out_remove_mac:\n\tmvmvif->link[0] = NULL;\n\tiwl_mvm_mld_mac_ctxt_remove(mvm, vif);\n out_unlock:\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret;\n}\n\nstatic void iwl_mvm_mld_mac_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_probe_resp_data *probe_data;\n\n\tiwl_mvm_prepare_mac_removal(mvm, vif);\n\n\tif (!(vif->type == NL80211_IFTYPE_AP ||\n\t      vif->type == NL80211_IFTYPE_ADHOC))\n\t\tiwl_mvm_tcm_rm_vif(mvm, vif);\n\n\tmutex_lock(&mvm->mutex);\n\n\tif (vif == mvm->csme_vif) {\n\t\tiwl_mei_set_netdev(NULL);\n\t\tmvm->csme_vif = NULL;\n\t}\n\n\tif (mvm->bf_allowed_vif == mvmvif) {\n\t\tmvm->bf_allowed_vif = NULL;\n\t\tvif->driver_flags &= ~(IEEE80211_VIF_BEACON_FILTER |\n\t\t\t\t       IEEE80211_VIF_SUPPORTS_CQM_RSSI);\n\t}\n\n\tif (vif->bss_conf.ftm_responder)\n\t\tmemset(&mvm->ftm_resp_stats, 0, sizeof(mvm->ftm_resp_stats));\n\n\tiwl_mvm_vif_dbgfs_clean(mvm, vif);\n\n\t \n\tif (vif->type == NL80211_IFTYPE_AP ||\n\t    vif->type == NL80211_IFTYPE_ADHOC) {\n#ifdef CONFIG_NL80211_TESTMODE\n\t\tif (vif == mvm->noa_vif) {\n\t\t\tmvm->noa_vif = NULL;\n\t\t\tmvm->noa_duration = 0;\n\t\t}\n#endif\n\t}\n\n\tiwl_mvm_power_update_mac(mvm);\n\n\t \n\tif (vif->type == NL80211_IFTYPE_P2P_DEVICE) {\n\t\tif (mvmvif->deflink.phy_ctxt) {\n\t\t\tiwl_mvm_phy_ctxt_unref(mvm, mvmvif->deflink.phy_ctxt);\n\t\t\tmvmvif->deflink.phy_ctxt = NULL;\n\t\t}\n\t\tmvm->p2p_device_vif = NULL;\n\t\tiwl_mvm_remove_link(mvm, vif, &vif->bss_conf);\n\t} else {\n\t\tiwl_mvm_disable_link(mvm, vif, &vif->bss_conf);\n\t}\n\n\tiwl_mvm_mld_mac_ctxt_remove(mvm, vif);\n\n\tRCU_INIT_POINTER(mvm->vif_id_to_mac[mvmvif->id], NULL);\n\n\tprobe_data = rcu_dereference_protected(mvmvif->deflink.probe_resp_data,\n\t\t\t\t\t       lockdep_is_held(&mvm->mutex));\n\tRCU_INIT_POINTER(mvmvif->deflink.probe_resp_data, NULL);\n\tif (probe_data)\n\t\tkfree_rcu(probe_data, rcu_head);\n\n\tif (vif->type == NL80211_IFTYPE_MONITOR) {\n\t\tmvm->monitor_on = false;\n\t\t__clear_bit(IEEE80211_HW_RX_INCLUDES_FCS, mvm->hw->flags);\n\t}\n\n\tmutex_unlock(&mvm->mutex);\n}\n\nstatic unsigned int iwl_mvm_mld_count_active_links(struct ieee80211_vif *vif)\n{\n\tunsigned int n_active = 0;\n\tint i;\n\n\tfor (i = 0; i < IEEE80211_MLD_MAX_NUM_LINKS; i++) {\n\t\tstruct ieee80211_bss_conf *link_conf;\n\n\t\tlink_conf = link_conf_dereference_protected(vif, i);\n\t\tif (link_conf &&\n\t\t    rcu_access_pointer(link_conf->chanctx_conf))\n\t\t\tn_active++;\n\t}\n\n\treturn n_active;\n}\n\nstatic int iwl_mvm_esr_mode_active(struct iwl_mvm *mvm,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tint link_id, ret = 0;\n\n\tmvmvif->esr_active = true;\n\n\t \n\tvif->driver_flags |= IEEE80211_VIF_DISABLE_SMPS_OVERRIDE;\n\n\tiwl_mvm_update_smps_on_active_links(mvm, vif, IWL_MVM_SMPS_REQ_FW,\n\t\t\t\t\t    IEEE80211_SMPS_OFF);\n\n\tfor_each_mvm_vif_valid_link(mvmvif, link_id) {\n\t\tstruct iwl_mvm_vif_link_info *link = mvmvif->link[link_id];\n\n\t\tif (!link->phy_ctxt)\n\t\t\tcontinue;\n\n\t\tret = iwl_mvm_phy_send_rlc(mvm, link->phy_ctxt, 2, 2);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tlink->phy_ctxt->rlc_disabled = true;\n\t}\n\n\treturn ret;\n}\n\nstatic int\n__iwl_mvm_mld_assign_vif_chanctx(struct iwl_mvm *mvm,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_bss_conf *link_conf,\n\t\t\t\t struct ieee80211_chanctx_conf *ctx,\n\t\t\t\t bool switching_chanctx)\n{\n\tu16 *phy_ctxt_id = (u16 *)ctx->drv_priv;\n\tstruct iwl_mvm_phy_ctxt *phy_ctxt = &mvm->phy_ctxts[*phy_ctxt_id];\n\tunsigned int n_active = iwl_mvm_mld_count_active_links(vif);\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tunsigned int link_id = link_conf->link_id;\n\tint ret;\n\n\t \n\tif (!rcu_access_pointer(link_conf->chanctx_conf))\n\t\tn_active++;\n\n\tif (n_active > iwl_mvm_max_active_links(mvm, vif))\n\t\treturn -EOPNOTSUPP;\n\n\tif (WARN_ON_ONCE(!mvmvif->link[link_id]))\n\t\treturn -EINVAL;\n\n\t \n\tif (vif->type == NL80211_IFTYPE_AP) {\n\t\tret = iwl_mvm_mld_mac_ctxt_changed(mvm, vif, false);\n\t\tif (ret) {\n\t\t\tIWL_ERR(mvm, \"failed to update MAC %pM\\n\", vif->addr);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tmvmvif->link[link_id]->phy_ctxt = phy_ctxt;\n\n\tif (iwl_mvm_is_esr_supported(mvm->fwrt.trans) && n_active > 1) {\n\t\tmvmvif->link[link_id]->listen_lmac = true;\n\t\tret = iwl_mvm_esr_mode_active(mvm, vif);\n\t\tif (ret) {\n\t\t\tIWL_ERR(mvm, \"failed to activate ESR mode (%d)\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (switching_chanctx) {\n\t\t \n\t\tif (vif->type == NL80211_IFTYPE_AP)\n\t\t\tmvmvif->ap_ibss_active = true;\n\t}\n\n\t \n\tret = iwl_mvm_link_changed(mvm, vif, link_conf, 0, false);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (mvmvif->ap_sta &&\n\t    !test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status)) {\n\t\tstruct ieee80211_link_sta *link_sta;\n\n\t\trcu_read_lock();\n\t\tlink_sta = rcu_dereference(mvmvif->ap_sta->link[link_id]);\n\n\t\tif (!WARN_ON_ONCE(!link_sta))\n\t\t\tiwl_mvm_rs_rate_init(mvm, vif, mvmvif->ap_sta,\n\t\t\t\t\t     link_conf, link_sta,\n\t\t\t\t\t     phy_ctxt->channel->band);\n\t\trcu_read_unlock();\n\t}\n\n\t \n\tret = iwl_mvm_link_changed(mvm, vif, link_conf,\n\t\t\t\t   LINK_CONTEXT_MODIFY_ACTIVE |\n\t\t\t\t   LINK_CONTEXT_MODIFY_RATES_INFO,\n\t\t\t\t   true);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tiwl_mvm_power_update_mac(mvm);\n\n\tif (vif->type == NL80211_IFTYPE_MONITOR) {\n\t\tret = iwl_mvm_mld_add_snif_sta(mvm, vif, link_conf);\n\t\tif (ret)\n\t\t\tgoto deactivate;\n\t}\n\n\treturn 0;\n\ndeactivate:\n\tiwl_mvm_link_changed(mvm, vif, link_conf, LINK_CONTEXT_MODIFY_ACTIVE,\n\t\t\t     false);\nout:\n\tmvmvif->link[link_id]->phy_ctxt = NULL;\n\tiwl_mvm_power_update_mac(mvm);\n\treturn ret;\n}\n\nstatic int iwl_mvm_mld_assign_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  struct ieee80211_bss_conf *link_conf,\n\t\t\t\t\t  struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tint ret;\n\n\tmutex_lock(&mvm->mutex);\n\tret = __iwl_mvm_mld_assign_vif_chanctx(mvm, vif, link_conf, ctx, false);\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret;\n}\n\nstatic int iwl_mvm_esr_mode_inactive(struct iwl_mvm *mvm,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct ieee80211_bss_conf *link_conf;\n\tint link_id, ret = 0;\n\n\tmvmvif->esr_active = false;\n\n\tvif->driver_flags &= ~IEEE80211_VIF_DISABLE_SMPS_OVERRIDE;\n\n\tiwl_mvm_update_smps_on_active_links(mvm, vif, IWL_MVM_SMPS_REQ_FW,\n\t\t\t\t\t    IEEE80211_SMPS_AUTOMATIC);\n\n\tfor_each_vif_active_link(vif, link_conf, link_id) {\n\t\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\t\tstruct iwl_mvm_phy_ctxt *phy_ctxt;\n\t\tu8 static_chains, dynamic_chains;\n\n\t\tmvmvif->link[link_id]->listen_lmac = false;\n\n\t\trcu_read_lock();\n\n\t\tchanctx_conf = rcu_dereference(link_conf->chanctx_conf);\n\t\tphy_ctxt = mvmvif->link[link_id]->phy_ctxt;\n\n\t\tif (!chanctx_conf || !phy_ctxt) {\n\t\t\trcu_read_unlock();\n\t\t\tcontinue;\n\t\t}\n\n\t\tphy_ctxt->rlc_disabled = false;\n\t\tstatic_chains = chanctx_conf->rx_chains_static;\n\t\tdynamic_chains = chanctx_conf->rx_chains_dynamic;\n\n\t\trcu_read_unlock();\n\n\t\tret = iwl_mvm_phy_send_rlc(mvm, phy_ctxt, static_chains,\n\t\t\t\t\t   dynamic_chains);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void\n__iwl_mvm_mld_unassign_vif_chanctx(struct iwl_mvm *mvm,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_bss_conf *link_conf,\n\t\t\t\t   struct ieee80211_chanctx_conf *ctx,\n\t\t\t\t   bool switching_chanctx)\n\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tunsigned int n_active = iwl_mvm_mld_count_active_links(vif);\n\tunsigned int link_id = link_conf->link_id;\n\n\t \n\tif (WARN_ON_ONCE(!mvmvif->link[link_id]))\n\t\treturn;\n\n\tif (vif->type == NL80211_IFTYPE_AP && switching_chanctx) {\n\t\tmvmvif->csa_countdown = false;\n\n\t\t \n\t\tiwl_mvm_modify_all_sta_disable_tx(mvm, mvmvif, true);\n\n\t\t \n\t\trcu_assign_pointer(mvm->csa_tx_blocked_vif, vif);\n\n\t\tmvmvif->ap_ibss_active = false;\n\t}\n\n\tif (iwl_mvm_is_esr_supported(mvm->fwrt.trans) && n_active > 1) {\n\t\tint ret = iwl_mvm_esr_mode_inactive(mvm, vif);\n\n\t\tif (ret)\n\t\t\tIWL_ERR(mvm, \"failed to deactivate ESR mode (%d)\\n\",\n\t\t\t\tret);\n\t}\n\n\tif (vif->type == NL80211_IFTYPE_MONITOR)\n\t\tiwl_mvm_mld_rm_snif_sta(mvm, vif);\n\n\tiwl_mvm_link_changed(mvm, vif, link_conf,\n\t\t\t     LINK_CONTEXT_MODIFY_ACTIVE, false);\n\n\tif (switching_chanctx)\n\t\treturn;\n\tmvmvif->link[link_id]->phy_ctxt = NULL;\n\tiwl_mvm_power_update_mac(mvm);\n}\n\nstatic void iwl_mvm_mld_unassign_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t\t     struct ieee80211_bss_conf *link_conf,\n\t\t\t\t\t     struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\tmutex_lock(&mvm->mutex);\n\t__iwl_mvm_mld_unassign_vif_chanctx(mvm, vif, link_conf, ctx, false);\n\tmutex_unlock(&mvm->mutex);\n}\n\nstatic int iwl_mvm_mld_start_ap_ibss(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_bss_conf *link_conf)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tint ret;\n\n\tmutex_lock(&mvm->mutex);\n\t \n\tret = iwl_mvm_mac_ctxt_beacon_changed(mvm, vif, link_conf);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tret = iwl_mvm_link_changed(mvm, vif, link_conf,\n\t\t\t\t   LINK_CONTEXT_MODIFY_ALL &\n\t\t\t\t   ~LINK_CONTEXT_MODIFY_ACTIVE,\n\t\t\t\t   true);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = iwl_mvm_mld_add_mcast_sta(mvm, vif, link_conf);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tret = iwl_mvm_mld_add_bcast_sta(mvm, vif, link_conf);\n\tif (ret)\n\t\tgoto out_rm_mcast;\n\n\tif (iwl_mvm_start_ap_ibss_common(hw, vif, &ret))\n\t\tgoto out_failed;\n\n\t \n\tif (vif->p2p && mvm->p2p_device_vif)\n\t\tiwl_mvm_mld_mac_ctxt_changed(mvm, mvm->p2p_device_vif, false);\n\n\tiwl_mvm_bt_coex_vif_change(mvm);\n\n\t \n\tif (iwl_mvm_phy_ctx_count(mvm) > 1)\n\t\tiwl_mvm_teardown_tdls_peers(mvm);\n\n\tiwl_mvm_ftm_restart_responder(mvm, vif, link_conf);\n\n\tgoto out_unlock;\n\nout_failed:\n\tiwl_mvm_power_update_mac(mvm);\n\tmvmvif->ap_ibss_active = false;\n\tiwl_mvm_mld_rm_bcast_sta(mvm, vif, link_conf);\nout_rm_mcast:\n\tiwl_mvm_mld_rm_mcast_sta(mvm, vif, link_conf);\nout_unlock:\n\tmutex_unlock(&mvm->mutex);\n\treturn ret;\n}\n\nstatic int iwl_mvm_mld_start_ap(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_bss_conf *link_conf)\n{\n\treturn iwl_mvm_mld_start_ap_ibss(hw, vif, link_conf);\n}\n\nstatic int iwl_mvm_mld_start_ibss(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif)\n{\n\treturn iwl_mvm_mld_start_ap_ibss(hw, vif, &vif->bss_conf);\n}\n\nstatic void iwl_mvm_mld_stop_ap_ibss(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_bss_conf *link_conf)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\tmutex_lock(&mvm->mutex);\n\n\tiwl_mvm_stop_ap_ibss_common(mvm, vif);\n\n\t \n\tif (vif->p2p && mvm->p2p_device_vif)\n\t\tiwl_mvm_mld_mac_ctxt_changed(mvm, mvm->p2p_device_vif, false);\n\n\tiwl_mvm_ftm_responder_clear(mvm, vif);\n\n\tiwl_mvm_mld_rm_bcast_sta(mvm, vif, link_conf);\n\tiwl_mvm_mld_rm_mcast_sta(mvm, vif, link_conf);\n\n\tiwl_mvm_power_update_mac(mvm);\n\tmutex_unlock(&mvm->mutex);\n}\n\nstatic void iwl_mvm_mld_stop_ap(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_bss_conf *link_conf)\n{\n\tiwl_mvm_mld_stop_ap_ibss(hw, vif, link_conf);\n}\n\nstatic void iwl_mvm_mld_stop_ibss(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tiwl_mvm_mld_stop_ap_ibss(hw, vif, &vif->bss_conf);\n}\n\nstatic int iwl_mvm_mld_mac_sta_state(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_sta *sta,\n\t\t\t\t     enum ieee80211_sta_state old_state,\n\t\t\t\t     enum ieee80211_sta_state new_state)\n{\n\tstatic const struct iwl_mvm_sta_state_ops callbacks = {\n\t\t.add_sta = iwl_mvm_mld_add_sta,\n\t\t.update_sta = iwl_mvm_mld_update_sta,\n\t\t.rm_sta = iwl_mvm_mld_rm_sta,\n\t\t.mac_ctxt_changed = iwl_mvm_mld_mac_ctxt_changed,\n\t};\n\n\treturn iwl_mvm_mac_sta_state_common(hw, vif, sta, old_state, new_state,\n\t\t\t\t\t    &callbacks);\n}\n\nstatic void\niwl_mvm_mld_link_info_changed_station(struct iwl_mvm *mvm,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_bss_conf *link_conf,\n\t\t\t\t      u64 changes)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tbool has_he, has_eht;\n\tu32 link_changes = 0;\n\tint ret;\n\n\tif (WARN_ON_ONCE(!mvmvif->link[link_conf->link_id]))\n\t\treturn;\n\n\thas_he = link_conf->he_support && !iwlwifi_mod_params.disable_11ax;\n\thas_eht = link_conf->eht_support && !iwlwifi_mod_params.disable_11be;\n\n\t \n\tif (changes & BSS_CHANGED_QOS && vif->cfg.assoc && link_conf->qos)\n\t\tlink_changes |= LINK_CONTEXT_MODIFY_QOS_PARAMS;\n\n\tif (changes & BSS_CHANGED_ERP_SLOT)\n\t\tlink_changes |= LINK_CONTEXT_MODIFY_RATES_INFO;\n\n\tif (vif->cfg.assoc && (has_he || has_eht)) {\n\t\tIWL_DEBUG_MAC80211(mvm, \"Associated in HE mode\\n\");\n\t\tlink_changes |= LINK_CONTEXT_MODIFY_HE_PARAMS;\n\t}\n\n\t \n\tif (changes & BSS_CHANGED_EHT_PUNCTURING && vif->cfg.assoc)\n\t\tlink_changes |= LINK_CONTEXT_MODIFY_EHT_PARAMS;\n\n\tif (link_changes) {\n\t\tret = iwl_mvm_link_changed(mvm, vif, link_conf, link_changes,\n\t\t\t\t\t   true);\n\t\tif (ret)\n\t\t\tIWL_ERR(mvm, \"failed to update link\\n\");\n\t}\n\n\tret = iwl_mvm_mld_mac_ctxt_changed(mvm, vif, false);\n\tif (ret)\n\t\tIWL_ERR(mvm, \"failed to update MAC %pM\\n\", vif->addr);\n\n\tmemcpy(mvmvif->link[link_conf->link_id]->bssid, link_conf->bssid,\n\t       ETH_ALEN);\n\n\tiwl_mvm_bss_info_changed_station_common(mvm, vif, link_conf, changes);\n}\n\nstatic bool iwl_mvm_mld_vif_have_valid_ap_sta(struct iwl_mvm_vif *mvmvif)\n{\n\tint i;\n\n\tfor_each_mvm_vif_valid_link(mvmvif, i) {\n\t\tif (mvmvif->link[i]->ap_sta_id != IWL_MVM_INVALID_STA)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void iwl_mvm_mld_vif_delete_all_stas(struct iwl_mvm *mvm,\n\t\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tint i, ret;\n\n\tif (test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status))\n\t\treturn;\n\n\tfor_each_mvm_vif_valid_link(mvmvif, i) {\n\t\tstruct iwl_mvm_vif_link_info *link = mvmvif->link[i];\n\n\t\tif (!link)\n\t\t\tcontinue;\n\n\t\tiwl_mvm_sec_key_remove_ap(mvm, vif, link, i);\n\t\tret = iwl_mvm_mld_rm_sta_id(mvm, link->ap_sta_id);\n\t\tif (ret)\n\t\t\tIWL_ERR(mvm, \"failed to remove AP station\\n\");\n\n\t\tlink->ap_sta_id = IWL_MVM_INVALID_STA;\n\t}\n}\n\nstatic void iwl_mvm_mld_vif_cfg_changed_station(struct iwl_mvm *mvm,\n\t\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\t\tu64 changes)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct ieee80211_bss_conf *link_conf;\n\tbool protect = false;\n\tunsigned int i;\n\tint ret;\n\n\t \n\tif (changes == BSS_CHANGED_IDLE)\n\t\treturn;\n\n\tret = iwl_mvm_mld_mac_ctxt_changed(mvm, vif, false);\n\tif (ret)\n\t\tIWL_ERR(mvm, \"failed to update MAC %pM\\n\", vif->addr);\n\n\tmvmvif->associated = vif->cfg.assoc;\n\n\tif (changes & BSS_CHANGED_ASSOC) {\n\t\tif (vif->cfg.assoc) {\n\t\t\t \n\t\t\tiwl_mvm_request_statistics(mvm, true);\n\t\t\tiwl_mvm_sf_update(mvm, vif, false);\n\t\t\tiwl_mvm_power_vif_assoc(mvm, vif);\n\n\t\t\tfor_each_mvm_vif_valid_link(mvmvif, i) {\n\t\t\t\tmemset(&mvmvif->link[i]->beacon_stats, 0,\n\t\t\t\t       sizeof(mvmvif->link[i]->beacon_stats));\n\n\t\t\t\tif (vif->p2p) {\n\t\t\t\t\tiwl_mvm_update_smps(mvm, vif,\n\t\t\t\t\t\t\t    IWL_MVM_SMPS_REQ_PROT,\n\t\t\t\t\t\t\t    IEEE80211_SMPS_DYNAMIC, i);\n\t\t\t\t}\n\n\t\t\t\trcu_read_lock();\n\t\t\t\tlink_conf = rcu_dereference(vif->link_conf[i]);\n\t\t\t\tif (link_conf && !link_conf->dtim_period)\n\t\t\t\t\tprotect = true;\n\t\t\t\trcu_read_unlock();\n\t\t\t}\n\n\t\t\tif (!test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status) &&\n\t\t\t    protect) {\n\t\t\t\t \n\t\t\t\tiwl_mvm_protect_assoc(mvm, vif, 0);\n\t\t\t}\n\n\t\t\tiwl_mvm_sf_update(mvm, vif, false);\n\n\t\t\t \n\t\t\tiwl_mvm_power_vif_assoc(mvm, vif);\n\t\t} else if (iwl_mvm_mld_vif_have_valid_ap_sta(mvmvif)) {\n\t\t\tiwl_mvm_mei_host_disassociated(mvm);\n\n\t\t\t \n\t\t\tret = iwl_mvm_sf_update(mvm, vif, false);\n\t\t\tWARN_ONCE(ret &&\n\t\t\t\t  !test_bit(IWL_MVM_STATUS_HW_RESTART_REQUESTED,\n\t\t\t\t\t    &mvm->status),\n\t\t\t\t  \"Failed to update SF upon disassociation\\n\");\n\n\t\t\t \n\t\t\tiwl_mvm_mld_vif_delete_all_stas(mvm, vif);\n\t\t}\n\n\t\tiwl_mvm_bss_info_changed_station_assoc(mvm, vif, changes);\n\t}\n\n\tif (changes & BSS_CHANGED_PS) {\n\t\tret = iwl_mvm_power_update_mac(mvm);\n\t\tif (ret)\n\t\t\tIWL_ERR(mvm, \"failed to update power mode\\n\");\n\t}\n}\n\nstatic void\niwl_mvm_mld_link_info_changed_ap_ibss(struct iwl_mvm *mvm,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_bss_conf *link_conf,\n\t\t\t\t      u64 changes)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tu32 link_changes = LINK_CONTEXT_MODIFY_PROTECT_FLAGS |\n\t\t\t   LINK_CONTEXT_MODIFY_QOS_PARAMS;\n\n\t \n\tif (!mvmvif->ap_ibss_active)\n\t\treturn;\n\n\tif (link_conf->he_support)\n\t\tlink_changes |= LINK_CONTEXT_MODIFY_HE_PARAMS;\n\n\tif (changes & BSS_CHANGED_ERP_SLOT)\n\t\tlink_changes |= LINK_CONTEXT_MODIFY_RATES_INFO;\n\n\tif (changes & (BSS_CHANGED_ERP_CTS_PROT | BSS_CHANGED_ERP_SLOT |\n\t\t       BSS_CHANGED_HT |\n\t\t       BSS_CHANGED_BANDWIDTH | BSS_CHANGED_QOS |\n\t\t       BSS_CHANGED_HE_BSS_COLOR) &&\n\t\t       iwl_mvm_link_changed(mvm, vif, link_conf,\n\t\t\t\t\t    link_changes, true))\n\t\tIWL_ERR(mvm, \"failed to update MAC %pM\\n\", vif->addr);\n\n\t \n\tif (changes & BSS_CHANGED_BEACON &&\n\t    iwl_mvm_mac_ctxt_beacon_changed(mvm, vif, link_conf))\n\t\tIWL_WARN(mvm, \"Failed updating beacon data\\n\");\n\n\t \n\tif (changes & BSS_CHANGED_FTM_RESPONDER) {\n\t\tint ret = iwl_mvm_ftm_start_responder(mvm, vif, link_conf);\n\n\t\tif (ret)\n\t\t\tIWL_WARN(mvm, \"Failed to enable FTM responder (%d)\\n\",\n\t\t\t\t ret);\n\t}\n}\n\nstatic void iwl_mvm_mld_link_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  struct ieee80211_bss_conf *link_conf,\n\t\t\t\t\t  u64 changes)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\tmutex_lock(&mvm->mutex);\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tiwl_mvm_mld_link_info_changed_station(mvm, vif, link_conf,\n\t\t\t\t\t\t      changes);\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tiwl_mvm_mld_link_info_changed_ap_ibss(mvm, vif, link_conf,\n\t\t\t\t\t\t      changes);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (changes & BSS_CHANGED_MU_GROUPS)\n\t\t\tiwl_mvm_update_mu_groups(mvm, vif);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARN_ON_ONCE(1);\n\t}\n\n\tif (changes & BSS_CHANGED_TXPOWER) {\n\t\tIWL_DEBUG_CALIB(mvm, \"Changing TX Power to %d dBm\\n\",\n\t\t\t\tlink_conf->txpower);\n\t\tiwl_mvm_set_tx_power(mvm, vif, link_conf->txpower);\n\t}\n\n\tmutex_unlock(&mvm->mutex);\n}\n\nstatic void iwl_mvm_mld_vif_cfg_changed(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tu64 changes)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\tmutex_lock(&mvm->mutex);\n\n\tif (changes & BSS_CHANGED_IDLE && !vif->cfg.idle)\n\t\tiwl_mvm_scan_stop(mvm, IWL_MVM_SCAN_SCHED, true);\n\n\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\tiwl_mvm_mld_vif_cfg_changed_station(mvm, vif, changes);\n\n\tmutex_unlock(&mvm->mutex);\n}\n\nstatic int\niwl_mvm_mld_switch_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif_chanctx_switch *vifs,\n\t\t\t       int n_vifs,\n\t\t\t       enum ieee80211_chanctx_switch_mode mode)\n{\n\tstatic const struct iwl_mvm_switch_vif_chanctx_ops ops = {\n\t\t.__assign_vif_chanctx = __iwl_mvm_mld_assign_vif_chanctx,\n\t\t.__unassign_vif_chanctx = __iwl_mvm_mld_unassign_vif_chanctx,\n\t};\n\n\treturn iwl_mvm_switch_vif_chanctx_common(hw, vifs, n_vifs, mode, &ops);\n}\n\nstatic void iwl_mvm_mld_config_iface_filter(struct ieee80211_hw *hw,\n\t\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t\t    unsigned int filter_flags,\n\t\t\t\t\t    unsigned int changed_flags)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\t \n\tif (!(changed_flags & FIF_PROBE_REQ))\n\t\treturn;\n\n\t \n\tif (vif->type != NL80211_IFTYPE_STATION || !vif->cfg.assoc ||\n\t    !vif->p2p)\n\t\treturn;\n\n\tmutex_lock(&mvm->mutex);\n\tiwl_mvm_mld_mac_ctxt_changed(mvm, vif, false);\n\tmutex_unlock(&mvm->mutex);\n}\n\nstatic int\niwl_mvm_mld_mac_conf_tx(struct ieee80211_hw *hw,\n\t\t\tstruct ieee80211_vif *vif,\n\t\t\tunsigned int link_id, u16 ac,\n\t\t\tconst struct ieee80211_tx_queue_params *params)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_vif_link_info *mvm_link = mvmvif->link[link_id];\n\n\tif (!mvm_link)\n\t\treturn -EINVAL;\n\n\tmvm_link->queue_params[ac] = *params;\n\n\t \n\tif (vif->type == NL80211_IFTYPE_P2P_DEVICE) {\n\t\tint ret;\n\n\t\tmutex_lock(&mvm->mutex);\n\t\tret = iwl_mvm_link_changed(mvm, vif, &vif->bss_conf,\n\t\t\t\t\t   LINK_CONTEXT_MODIFY_QOS_PARAMS,\n\t\t\t\t\t   true);\n\t\tmutex_unlock(&mvm->mutex);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int iwl_mvm_mld_roc_link(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\t \n\tret = iwl_mvm_link_changed(mvm, vif, &vif->bss_conf, 0, false);\n\tif (WARN(ret, \"Failed to set PHY context ID\\n\"))\n\t\treturn ret;\n\n\tret = iwl_mvm_link_changed(mvm, vif, &vif->bss_conf,\n\t\t\t\t   LINK_CONTEXT_MODIFY_ACTIVE |\n\t\t\t\t   LINK_CONTEXT_MODIFY_RATES_INFO,\n\t\t\t\t   true);\n\n\tif (WARN(ret, \"Failed linking P2P_DEVICE\\n\"))\n\t\treturn ret;\n\n\t \n\treturn iwl_mvm_mld_add_bcast_sta(mvm, vif, &vif->bss_conf);\n}\n\nstatic int iwl_mvm_mld_roc(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_channel *channel, int duration,\n\t\t\t   enum ieee80211_roc_type type)\n{\n\tstatic const struct iwl_mvm_roc_ops ops = {\n\t\t.add_aux_sta_for_hs20 = iwl_mvm_mld_add_aux_sta,\n\t\t.link = iwl_mvm_mld_roc_link,\n\t};\n\n\treturn iwl_mvm_roc_common(hw, vif, channel, duration, type, &ops);\n}\n\nstatic int\niwl_mvm_mld_change_vif_links(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     u16 old_links, u16 new_links,\n\t\t\t     struct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS])\n{\n\tstruct iwl_mvm_vif_link_info *new_link[IEEE80211_MLD_MAX_NUM_LINKS] = {};\n\tunsigned int n_active = iwl_mvm_mld_count_active_links(vif);\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tu16 removed = old_links & ~new_links;\n\tu16 added = new_links & ~old_links;\n\tint err, i;\n\n\tif (hweight16(new_links) > 1 &&\n\t    n_active > iwl_mvm_max_active_links(mvm, vif))\n\t\treturn -EOPNOTSUPP;\n\n\tfor (i = 0; i < IEEE80211_MLD_MAX_NUM_LINKS; i++) {\n\t\tint r;\n\n\t\tif (test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status))\n\t\t\tbreak;\n\n\t\tif (!(added & BIT(i)))\n\t\t\tcontinue;\n\t\tnew_link[i] = kzalloc(sizeof(*new_link[i]), GFP_KERNEL);\n\t\tif (!new_link[i]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\n\t\tnew_link[i]->bcast_sta.sta_id = IWL_MVM_INVALID_STA;\n\t\tnew_link[i]->mcast_sta.sta_id = IWL_MVM_INVALID_STA;\n\t\tnew_link[i]->ap_sta_id = IWL_MVM_INVALID_STA;\n\t\tnew_link[i]->fw_link_id = IWL_MVM_FW_LINK_ID_INVALID;\n\n\t\tfor (r = 0; r < NUM_IWL_MVM_SMPS_REQ; r++)\n\t\t\tnew_link[i]->smps_requests[r] =\n\t\t\t\tIEEE80211_SMPS_AUTOMATIC;\n\t}\n\n\tmutex_lock(&mvm->mutex);\n\n\tif (old_links == 0) {\n\t\terr = iwl_mvm_disable_link(mvm, vif, &vif->bss_conf);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\tmvmvif->link[0] = NULL;\n\t}\n\n\tfor (i = 0; i < IEEE80211_MLD_MAX_NUM_LINKS; i++) {\n\t\tif (removed & BIT(i)) {\n\t\t\tstruct ieee80211_bss_conf *link_conf = old[i];\n\n\t\t\terr = iwl_mvm_disable_link(mvm, vif, link_conf);\n\t\t\tif (err)\n\t\t\t\tgoto out_err;\n\t\t\tkfree(mvmvif->link[i]);\n\t\t\tmvmvif->link[i] = NULL;\n\t\t} else if (added & BIT(i)) {\n\t\t\tstruct ieee80211_bss_conf *link_conf;\n\n\t\t\tlink_conf = link_conf_dereference_protected(vif, i);\n\t\t\tif (WARN_ON(!link_conf))\n\t\t\t\tcontinue;\n\n\t\t\tif (!test_bit(IWL_MVM_STATUS_IN_HW_RESTART,\n\t\t\t\t      &mvm->status))\n\t\t\t\tmvmvif->link[i] = new_link[i];\n\t\t\tnew_link[i] = NULL;\n\t\t\terr = iwl_mvm_add_link(mvm, vif, link_conf);\n\t\t\tif (err)\n\t\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\terr = 0;\n\tif (new_links == 0) {\n\t\tmvmvif->link[0] = &mvmvif->deflink;\n\t\terr = iwl_mvm_add_link(mvm, vif, &vif->bss_conf);\n\t}\n\nout_err:\n\t \n\tmutex_unlock(&mvm->mutex);\n\nfree:\n\tfor (i = 0; i < IEEE80211_MLD_MAX_NUM_LINKS; i++)\n\t\tkfree(new_link[i]);\n\treturn err;\n}\n\nstatic int\niwl_mvm_mld_change_sta_links(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_sta *sta,\n\t\t\t     u16 old_links, u16 new_links)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tint ret;\n\n\tmutex_lock(&mvm->mutex);\n\tret = iwl_mvm_mld_update_sta_links(mvm, vif, sta, old_links, new_links);\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret;\n}\n\nconst struct ieee80211_ops iwl_mvm_mld_hw_ops = {\n\t.tx = iwl_mvm_mac_tx,\n\t.wake_tx_queue = iwl_mvm_mac_wake_tx_queue,\n\t.ampdu_action = iwl_mvm_mac_ampdu_action,\n\t.get_antenna = iwl_mvm_op_get_antenna,\n\t.start = iwl_mvm_mac_start,\n\t.reconfig_complete = iwl_mvm_mac_reconfig_complete,\n\t.stop = iwl_mvm_mac_stop,\n\t.add_interface = iwl_mvm_mld_mac_add_interface,\n\t.remove_interface = iwl_mvm_mld_mac_remove_interface,\n\t.config = iwl_mvm_mac_config,\n\t.prepare_multicast = iwl_mvm_prepare_multicast,\n\t.configure_filter = iwl_mvm_configure_filter,\n\t.config_iface_filter = iwl_mvm_mld_config_iface_filter,\n\t.link_info_changed = iwl_mvm_mld_link_info_changed,\n\t.vif_cfg_changed = iwl_mvm_mld_vif_cfg_changed,\n\t.hw_scan = iwl_mvm_mac_hw_scan,\n\t.cancel_hw_scan = iwl_mvm_mac_cancel_hw_scan,\n\t.sta_pre_rcu_remove = iwl_mvm_sta_pre_rcu_remove,\n\t.sta_state = iwl_mvm_mld_mac_sta_state,\n\t.sta_notify = iwl_mvm_mac_sta_notify,\n\t.allow_buffered_frames = iwl_mvm_mac_allow_buffered_frames,\n\t.release_buffered_frames = iwl_mvm_mac_release_buffered_frames,\n\t.set_rts_threshold = iwl_mvm_mac_set_rts_threshold,\n\t.sta_rc_update = iwl_mvm_sta_rc_update,\n\t.conf_tx = iwl_mvm_mld_mac_conf_tx,\n\t.mgd_prepare_tx = iwl_mvm_mac_mgd_prepare_tx,\n\t.mgd_complete_tx = iwl_mvm_mac_mgd_complete_tx,\n\t.mgd_protect_tdls_discover = iwl_mvm_mac_mgd_protect_tdls_discover,\n\t.flush = iwl_mvm_mac_flush,\n\t.flush_sta = iwl_mvm_mac_flush_sta,\n\t.sched_scan_start = iwl_mvm_mac_sched_scan_start,\n\t.sched_scan_stop = iwl_mvm_mac_sched_scan_stop,\n\t.set_key = iwl_mvm_mac_set_key,\n\t.update_tkip_key = iwl_mvm_mac_update_tkip_key,\n\t.remain_on_channel = iwl_mvm_mld_roc,\n\t.cancel_remain_on_channel = iwl_mvm_cancel_roc,\n\t.add_chanctx = iwl_mvm_add_chanctx,\n\t.remove_chanctx = iwl_mvm_remove_chanctx,\n\t.change_chanctx = iwl_mvm_change_chanctx,\n\t.assign_vif_chanctx = iwl_mvm_mld_assign_vif_chanctx,\n\t.unassign_vif_chanctx = iwl_mvm_mld_unassign_vif_chanctx,\n\t.switch_vif_chanctx = iwl_mvm_mld_switch_vif_chanctx,\n\n\t.start_ap = iwl_mvm_mld_start_ap,\n\t.stop_ap = iwl_mvm_mld_stop_ap,\n\t.join_ibss = iwl_mvm_mld_start_ibss,\n\t.leave_ibss = iwl_mvm_mld_stop_ibss,\n\n\t.tx_last_beacon = iwl_mvm_tx_last_beacon,\n\n\t.set_tim = iwl_mvm_set_tim,\n\n\t.channel_switch = iwl_mvm_channel_switch,\n\t.pre_channel_switch = iwl_mvm_pre_channel_switch,\n\t.post_channel_switch = iwl_mvm_post_channel_switch,\n\t.abort_channel_switch = iwl_mvm_abort_channel_switch,\n\t.channel_switch_rx_beacon = iwl_mvm_channel_switch_rx_beacon,\n\n\t.tdls_channel_switch = iwl_mvm_tdls_channel_switch,\n\t.tdls_cancel_channel_switch = iwl_mvm_tdls_cancel_channel_switch,\n\t.tdls_recv_channel_switch = iwl_mvm_tdls_recv_channel_switch,\n\n\t.event_callback = iwl_mvm_mac_event_callback,\n\n\t.sync_rx_queues = iwl_mvm_sync_rx_queues,\n\n\tCFG80211_TESTMODE_CMD(iwl_mvm_mac_testmode_cmd)\n\n#ifdef CONFIG_PM_SLEEP\n\t \n\t.suspend = iwl_mvm_suspend,\n\t.resume = iwl_mvm_resume,\n\t.set_wakeup = iwl_mvm_set_wakeup,\n\t.set_rekey_data = iwl_mvm_set_rekey_data,\n#if IS_ENABLED(CONFIG_IPV6)\n\t.ipv6_addr_change = iwl_mvm_ipv6_addr_change,\n#endif\n\t.set_default_unicast_key = iwl_mvm_set_default_unicast_key,\n#endif\n\t.get_survey = iwl_mvm_mac_get_survey,\n\t.sta_statistics = iwl_mvm_mac_sta_statistics,\n\t.get_ftm_responder_stats = iwl_mvm_mac_get_ftm_responder_stats,\n\t.start_pmsr = iwl_mvm_start_pmsr,\n\t.abort_pmsr = iwl_mvm_abort_pmsr,\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\t.link_sta_add_debugfs = iwl_mvm_link_sta_add_debugfs,\n#endif\n\t.set_hw_timestamp = iwl_mvm_set_hw_timestamp,\n\n\t.change_vif_links = iwl_mvm_mld_change_vif_links,\n\t.change_sta_links = iwl_mvm_mld_change_sta_links,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}