{
  "module_name": "tx.c",
  "hash_id": "6e175891936c607798e0a35d7adcc16bd464101ea9f919a90bc6d19f7999aded",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/tx.c",
  "human_readable_source": "\n \n#include <linux/ieee80211.h>\n#include <linux/etherdevice.h>\n#include <linux/tcp.h>\n#include <net/gso.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n\n#include \"iwl-trans.h\"\n#include \"iwl-eeprom-parse.h\"\n#include \"mvm.h\"\n#include \"sta.h\"\n#include \"time-sync.h\"\n\nstatic void\niwl_mvm_bar_check_trigger(struct iwl_mvm *mvm, const u8 *addr,\n\t\t\t  u16 tid, u16 ssn)\n{\n\tstruct iwl_fw_dbg_trigger_tlv *trig;\n\tstruct iwl_fw_dbg_trigger_ba *ba_trig;\n\n\ttrig = iwl_fw_dbg_trigger_on(&mvm->fwrt, NULL, FW_DBG_TRIGGER_BA);\n\tif (!trig)\n\t\treturn;\n\n\tba_trig = (void *)trig->data;\n\n\tif (!(le16_to_cpu(ba_trig->tx_bar) & BIT(tid)))\n\t\treturn;\n\n\tiwl_fw_dbg_collect_trig(&mvm->fwrt, trig,\n\t\t\t\t\"BAR sent to %pM, tid %d, ssn %d\",\n\t\t\t\taddr, tid, ssn);\n}\n\n#define OPT_HDR(type, skb, off) \\\n\t(type *)(skb_network_header(skb) + (off))\n\nstatic u32 iwl_mvm_tx_csum(struct iwl_mvm *mvm, struct sk_buff *skb,\n\t\t\t   struct ieee80211_tx_info *info,\n\t\t\t   bool amsdu)\n{\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tu16 mh_len = ieee80211_hdrlen(hdr->frame_control);\n\tu16 offload_assist = 0;\n#if IS_ENABLED(CONFIG_INET)\n\tu8 protocol = 0;\n\n\t \n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\tgoto out;\n\n\t \n\tif (WARN_ONCE(!(mvm->hw->netdev_features & IWL_TX_CSUM_NETIF_FLAGS) ||\n\t\t      (skb->protocol != htons(ETH_P_IP) &&\n\t\t       skb->protocol != htons(ETH_P_IPV6)),\n\t\t      \"No support for requested checksum\\n\")) {\n\t\tskb_checksum_help(skb);\n\t\tgoto out;\n\t}\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\tprotocol = ip_hdr(skb)->protocol;\n\t} else {\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tstruct ipv6hdr *ipv6h =\n\t\t\t(struct ipv6hdr *)skb_network_header(skb);\n\t\tunsigned int off = sizeof(*ipv6h);\n\n\t\tprotocol = ipv6h->nexthdr;\n\t\twhile (protocol != NEXTHDR_NONE && ipv6_ext_hdr(protocol)) {\n\t\t\tstruct ipv6_opt_hdr *hp;\n\n\t\t\t \n\t\t\tif (protocol != NEXTHDR_ROUTING &&\n\t\t\t    protocol != NEXTHDR_HOP &&\n\t\t\t    protocol != NEXTHDR_DEST) {\n\t\t\t\tskb_checksum_help(skb);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\thp = OPT_HDR(struct ipv6_opt_hdr, skb, off);\n\t\t\tprotocol = hp->nexthdr;\n\t\t\toff += ipv6_optlen(hp);\n\t\t}\n\t\t \n#endif\n\t}\n\n\tif (protocol != IPPROTO_TCP && protocol != IPPROTO_UDP) {\n\t\tWARN_ON_ONCE(1);\n\t\tskb_checksum_help(skb);\n\t\tgoto out;\n\t}\n\n\t \n\toffload_assist |= BIT(TX_CMD_OFFLD_L4_EN);\n\n\t \n\toffload_assist |= (4 << TX_CMD_OFFLD_IP_HDR);\n\n\t \n\tif (skb->protocol == htons(ETH_P_IP) && amsdu) {\n\t\tip_hdr(skb)->check = 0;\n\t\toffload_assist |= BIT(TX_CMD_OFFLD_L3_EN);\n\t}\n\n\t \n\tif (protocol == IPPROTO_TCP)\n\t\ttcp_hdr(skb)->check = 0;\n\telse\n\t\tudp_hdr(skb)->check = 0;\n\nout:\n#endif\n\t \n\tif (!iwl_mvm_has_new_tx_api(mvm) && info->control.hw_key &&\n\t    info->control.hw_key->cipher != WLAN_CIPHER_SUITE_WEP40 &&\n\t    info->control.hw_key->cipher != WLAN_CIPHER_SUITE_WEP104)\n\t\tmh_len += info->control.hw_key->iv_len;\n\tmh_len /= 2;\n\toffload_assist |= mh_len << TX_CMD_OFFLD_MH_SIZE;\n\n\tif (amsdu)\n\t\toffload_assist |= BIT(TX_CMD_OFFLD_AMSDU);\n\telse if (ieee80211_hdrlen(hdr->frame_control) % 4)\n\t\t \n\t\toffload_assist |= BIT(TX_CMD_OFFLD_PAD);\n\n\treturn offload_assist;\n}\n\n \nvoid iwl_mvm_set_tx_cmd(struct iwl_mvm *mvm, struct sk_buff *skb,\n\t\t\tstruct iwl_tx_cmd *tx_cmd,\n\t\t\tstruct ieee80211_tx_info *info, u8 sta_id)\n{\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\t__le16 fc = hdr->frame_control;\n\tu32 tx_flags = le32_to_cpu(tx_cmd->tx_flags);\n\tu32 len = skb->len + FCS_LEN;\n\tbool amsdu = false;\n\tu8 ac;\n\n\tif (!(info->flags & IEEE80211_TX_CTL_NO_ACK) ||\n\t    (ieee80211_is_probe_resp(fc) &&\n\t     !is_multicast_ether_addr(hdr->addr1)))\n\t\ttx_flags |= TX_CMD_FLG_ACK;\n\telse\n\t\ttx_flags &= ~TX_CMD_FLG_ACK;\n\n\tif (ieee80211_is_probe_resp(fc))\n\t\ttx_flags |= TX_CMD_FLG_TSF;\n\n\tif (ieee80211_has_morefrags(fc))\n\t\ttx_flags |= TX_CMD_FLG_MORE_FRAG;\n\n\tif (ieee80211_is_data_qos(fc)) {\n\t\tu8 *qc = ieee80211_get_qos_ctl(hdr);\n\t\ttx_cmd->tid_tspec = qc[0] & 0xf;\n\t\ttx_flags &= ~TX_CMD_FLG_SEQ_CTL;\n\t\tamsdu = *qc & IEEE80211_QOS_CTL_A_MSDU_PRESENT;\n\t} else if (ieee80211_is_back_req(fc)) {\n\t\tstruct ieee80211_bar *bar = (void *)skb->data;\n\t\tu16 control = le16_to_cpu(bar->control);\n\t\tu16 ssn = le16_to_cpu(bar->start_seq_num);\n\n\t\ttx_flags |= TX_CMD_FLG_ACK | TX_CMD_FLG_BAR;\n\t\ttx_cmd->tid_tspec = (control &\n\t\t\t\t     IEEE80211_BAR_CTRL_TID_INFO_MASK) >>\n\t\t\tIEEE80211_BAR_CTRL_TID_INFO_SHIFT;\n\t\tWARN_ON_ONCE(tx_cmd->tid_tspec >= IWL_MAX_TID_COUNT);\n\t\tiwl_mvm_bar_check_trigger(mvm, bar->ra, tx_cmd->tid_tspec,\n\t\t\t\t\t  ssn);\n\t} else {\n\t\tif (ieee80211_is_data(fc))\n\t\t\ttx_cmd->tid_tspec = IWL_TID_NON_QOS;\n\t\telse\n\t\t\ttx_cmd->tid_tspec = IWL_MAX_TID_COUNT;\n\n\t\tif (info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ)\n\t\t\ttx_flags |= TX_CMD_FLG_SEQ_CTL;\n\t\telse\n\t\t\ttx_flags &= ~TX_CMD_FLG_SEQ_CTL;\n\t}\n\n\t \n\tif (tx_cmd->tid_tspec < IWL_MAX_TID_COUNT)\n\t\tac = tid_to_mac80211_ac[tx_cmd->tid_tspec];\n\telse\n\t\tac = tid_to_mac80211_ac[0];\n\n\ttx_flags |= iwl_mvm_bt_coex_tx_prio(mvm, hdr, info, ac) <<\n\t\t\tTX_CMD_FLG_BT_PRIO_POS;\n\n\tif (ieee80211_is_mgmt(fc)) {\n\t\tif (ieee80211_is_assoc_req(fc) || ieee80211_is_reassoc_req(fc))\n\t\t\ttx_cmd->pm_frame_timeout = cpu_to_le16(PM_FRAME_ASSOC);\n\t\telse if (ieee80211_is_action(fc))\n\t\t\ttx_cmd->pm_frame_timeout = cpu_to_le16(PM_FRAME_NONE);\n\t\telse\n\t\t\ttx_cmd->pm_frame_timeout = cpu_to_le16(PM_FRAME_MGMT);\n\n\t\t \n\t\tWARN_ON_ONCE(info->flags & IEEE80211_TX_CTL_AMPDU);\n\t} else if (info->control.flags & IEEE80211_TX_CTRL_PORT_CTRL_PROTO) {\n\t\ttx_cmd->pm_frame_timeout = cpu_to_le16(PM_FRAME_MGMT);\n\t} else {\n\t\ttx_cmd->pm_frame_timeout = cpu_to_le16(PM_FRAME_NONE);\n\t}\n\n\tif (ieee80211_is_data(fc) && len > mvm->rts_threshold &&\n\t    !is_multicast_ether_addr(hdr->addr1))\n\t\ttx_flags |= TX_CMD_FLG_PROT_REQUIRE;\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_TXPOWER_INSERTION_SUPPORT) &&\n\t    ieee80211_action_contains_tpc(skb))\n\t\ttx_flags |= TX_CMD_FLG_WRITE_TX_POWER;\n\n\ttx_cmd->tx_flags = cpu_to_le32(tx_flags);\n\t \n\ttx_cmd->len = cpu_to_le16((u16)skb->len);\n\ttx_cmd->life_time = cpu_to_le32(TX_CMD_LIFE_TIME_INFINITE);\n\ttx_cmd->sta_id = sta_id;\n\n\ttx_cmd->offload_assist =\n\t\tcpu_to_le16(iwl_mvm_tx_csum(mvm, skb, info, amsdu));\n}\n\nstatic u32 iwl_mvm_get_tx_ant(struct iwl_mvm *mvm,\n\t\t\t      struct ieee80211_tx_info *info,\n\t\t\t      struct ieee80211_sta *sta, __le16 fc)\n{\n\tif (info->band == NL80211_BAND_2GHZ &&\n\t    !iwl_mvm_bt_coex_is_shared_ant_avail(mvm))\n\t\treturn mvm->cfg->non_shared_ant << RATE_MCS_ANT_POS;\n\n\tif (sta && ieee80211_is_data(fc)) {\n\t\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\n\t\treturn BIT(mvmsta->tx_ant) << RATE_MCS_ANT_POS;\n\t}\n\n\treturn BIT(mvm->mgmt_last_antenna_idx) << RATE_MCS_ANT_POS;\n}\n\nstatic u32 iwl_mvm_get_inject_tx_rate(struct iwl_mvm *mvm,\n\t\t\t\t      struct ieee80211_tx_info *info)\n{\n\tstruct ieee80211_tx_rate *rate = &info->control.rates[0];\n\tu32 result;\n\n\t \n\n\tif (rate->flags & IEEE80211_TX_RC_VHT_MCS) {\n\t\tu8 mcs = ieee80211_rate_get_vht_mcs(rate);\n\t\tu8 nss = ieee80211_rate_get_vht_nss(rate);\n\n\t\tresult = RATE_MCS_VHT_MSK_V1;\n\t\tresult |= u32_encode_bits(mcs, RATE_VHT_MCS_RATE_CODE_MSK);\n\t\tresult |= u32_encode_bits(nss, RATE_MCS_NSS_MSK);\n\t\tif (rate->flags & IEEE80211_TX_RC_SHORT_GI)\n\t\t\tresult |= RATE_MCS_SGI_MSK_V1;\n\t\tif (rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\n\t\t\tresult |= u32_encode_bits(1, RATE_MCS_CHAN_WIDTH_MSK_V1);\n\t\telse if (rate->flags & IEEE80211_TX_RC_80_MHZ_WIDTH)\n\t\t\tresult |= u32_encode_bits(2, RATE_MCS_CHAN_WIDTH_MSK_V1);\n\t\telse if (rate->flags & IEEE80211_TX_RC_160_MHZ_WIDTH)\n\t\t\tresult |= u32_encode_bits(3, RATE_MCS_CHAN_WIDTH_MSK_V1);\n\t} else if (rate->flags & IEEE80211_TX_RC_MCS) {\n\t\tresult = RATE_MCS_HT_MSK_V1;\n\t\tresult |= u32_encode_bits(rate->idx,\n\t\t\t\t\t  RATE_HT_MCS_RATE_CODE_MSK_V1 |\n\t\t\t\t\t  RATE_HT_MCS_NSS_MSK_V1);\n\t\tif (rate->flags & IEEE80211_TX_RC_SHORT_GI)\n\t\t\tresult |= RATE_MCS_SGI_MSK_V1;\n\t\tif (rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\n\t\t\tresult |= u32_encode_bits(1, RATE_MCS_CHAN_WIDTH_MSK_V1);\n\t\tif (info->flags & IEEE80211_TX_CTL_LDPC)\n\t\t\tresult |= RATE_MCS_LDPC_MSK_V1;\n\t\tif (u32_get_bits(info->flags, IEEE80211_TX_CTL_STBC))\n\t\t\tresult |= RATE_MCS_STBC_MSK;\n\t} else {\n\t\treturn 0;\n\t}\n\n\tif (iwl_fw_lookup_notif_ver(mvm->fw, LONG_GROUP, TX_CMD, 0) > 6)\n\t\treturn iwl_new_rate_from_v1(result);\n\treturn result;\n}\n\nstatic u32 iwl_mvm_get_tx_rate(struct iwl_mvm *mvm,\n\t\t\t       struct ieee80211_tx_info *info,\n\t\t\t       struct ieee80211_sta *sta, __le16 fc)\n{\n\tint rate_idx = -1;\n\tu8 rate_plcp;\n\tu32 rate_flags = 0;\n\tbool is_cck;\n\n\tif (unlikely(info->control.flags & IEEE80211_TX_CTRL_RATE_INJECT)) {\n\t\tu32 result = iwl_mvm_get_inject_tx_rate(mvm, info);\n\n\t\tif (result)\n\t\t\treturn result;\n\t\trate_idx = info->control.rates[0].idx;\n\t} else if (!ieee80211_hw_check(mvm->hw, HAS_RATE_CONTROL)) {\n\t\t \n\n\t\t \n\t\tWARN_ONCE(info->control.rates[0].flags & IEEE80211_TX_RC_MCS &&\n\t\t\t  !ieee80211_is_data(fc),\n\t\t\t  \"Got a HT rate (flags:0x%x/mcs:%d/fc:0x%x/state:%d) for a non data frame\\n\",\n\t\t\t  info->control.rates[0].flags,\n\t\t\t  info->control.rates[0].idx,\n\t\t\t  le16_to_cpu(fc),\n\t\t\t  sta ? iwl_mvm_sta_from_mac80211(sta)->sta_state : -1);\n\n\t\trate_idx = info->control.rates[0].idx;\n\n\t\t \n\t\tif (info->band != NL80211_BAND_2GHZ ||\n\t\t    (info->flags & IEEE80211_TX_CTL_NO_CCK_RATE))\n\t\t\trate_idx += IWL_FIRST_OFDM_RATE;\n\n\t\t \n\t\tBUILD_BUG_ON(IWL_FIRST_CCK_RATE != 0);\n\t}\n\n\t \n\tif (rate_idx < 0 || rate_idx >= IWL_RATE_COUNT_LEGACY)\n\t\trate_idx = iwl_mvm_mac_ctxt_get_lowest_rate(mvm,\n\t\t\t\t\t\t\t    info,\n\t\t\t\t\t\t\t    info->control.vif);\n\n\t \n\trate_plcp = iwl_mvm_mac80211_idx_to_hwrate(mvm->fw, rate_idx);\n\tis_cck = (rate_idx >= IWL_FIRST_CCK_RATE) && (rate_idx <= IWL_LAST_CCK_RATE);\n\n\t \n\tif (iwl_fw_lookup_cmd_ver(mvm->fw, TX_CMD, 0) > 8) {\n\t\tif (!is_cck)\n\t\t\trate_flags |= RATE_MCS_LEGACY_OFDM_MSK;\n\t\telse\n\t\t\trate_flags |= RATE_MCS_CCK_MSK;\n\t} else if (is_cck) {\n\t\trate_flags |= RATE_MCS_CCK_MSK_V1;\n\t}\n\n\treturn (u32)rate_plcp | rate_flags;\n}\n\nstatic u32 iwl_mvm_get_tx_rate_n_flags(struct iwl_mvm *mvm,\n\t\t\t\t       struct ieee80211_tx_info *info,\n\t\t\t\t       struct ieee80211_sta *sta, __le16 fc)\n{\n\treturn iwl_mvm_get_tx_rate(mvm, info, sta, fc) |\n\t\tiwl_mvm_get_tx_ant(mvm, info, sta, fc);\n}\n\n \nvoid iwl_mvm_set_tx_cmd_rate(struct iwl_mvm *mvm, struct iwl_tx_cmd *tx_cmd,\n\t\t\t    struct ieee80211_tx_info *info,\n\t\t\t    struct ieee80211_sta *sta, __le16 fc)\n{\n\t \n\ttx_cmd->rts_retry_limit = IWL_RTS_DFAULT_RETRY_LIMIT;\n\n\t \n\tif (ieee80211_is_probe_resp(fc)) {\n\t\ttx_cmd->data_retry_limit = IWL_MGMT_DFAULT_RETRY_LIMIT;\n\t\ttx_cmd->rts_retry_limit =\n\t\t\tmin(tx_cmd->data_retry_limit, tx_cmd->rts_retry_limit);\n\t} else if (ieee80211_is_back_req(fc)) {\n\t\ttx_cmd->data_retry_limit = IWL_BAR_DFAULT_RETRY_LIMIT;\n\t} else {\n\t\ttx_cmd->data_retry_limit = IWL_DEFAULT_TX_RETRY;\n\t}\n\n\t \n\n\tif (likely(ieee80211_is_data(fc) && sta &&\n\t\t   !(info->control.flags & IEEE80211_TX_CTRL_RATE_INJECT))) {\n\t\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\n\t\tif (mvmsta->sta_state >= IEEE80211_STA_AUTHORIZED) {\n\t\t\ttx_cmd->initial_rate_index = 0;\n\t\t\ttx_cmd->tx_flags |= cpu_to_le32(TX_CMD_FLG_STA_RATE);\n\t\t\treturn;\n\t\t}\n\t} else if (ieee80211_is_back_req(fc)) {\n\t\ttx_cmd->tx_flags |=\n\t\t\tcpu_to_le32(TX_CMD_FLG_ACK | TX_CMD_FLG_BAR);\n\t}\n\n\t \n\ttx_cmd->rate_n_flags =\n\t\tcpu_to_le32(iwl_mvm_get_tx_rate_n_flags(mvm, info, sta, fc));\n}\n\nstatic inline void iwl_mvm_set_tx_cmd_pn(struct ieee80211_tx_info *info,\n\t\t\t\t\t u8 *crypto_hdr)\n{\n\tstruct ieee80211_key_conf *keyconf = info->control.hw_key;\n\tu64 pn;\n\n\tpn = atomic64_inc_return(&keyconf->tx_pn);\n\tcrypto_hdr[0] = pn;\n\tcrypto_hdr[2] = 0;\n\tcrypto_hdr[3] = 0x20 | (keyconf->keyidx << 6);\n\tcrypto_hdr[1] = pn >> 8;\n\tcrypto_hdr[4] = pn >> 16;\n\tcrypto_hdr[5] = pn >> 24;\n\tcrypto_hdr[6] = pn >> 32;\n\tcrypto_hdr[7] = pn >> 40;\n}\n\n \nstatic void iwl_mvm_set_tx_cmd_crypto(struct iwl_mvm *mvm,\n\t\t\t\t      struct ieee80211_tx_info *info,\n\t\t\t\t      struct iwl_tx_cmd *tx_cmd,\n\t\t\t\t      struct sk_buff *skb_frag,\n\t\t\t\t      int hdrlen)\n{\n\tstruct ieee80211_key_conf *keyconf = info->control.hw_key;\n\tu8 *crypto_hdr = skb_frag->data + hdrlen;\n\tenum iwl_tx_cmd_sec_ctrl type = TX_CMD_SEC_CCM;\n\tu64 pn;\n\n\tswitch (keyconf->cipher) {\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tiwl_mvm_set_tx_cmd_ccmp(info, tx_cmd);\n\t\tiwl_mvm_set_tx_cmd_pn(info, crypto_hdr);\n\t\tbreak;\n\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\ttx_cmd->sec_ctl = TX_CMD_SEC_TKIP;\n\t\tpn = atomic64_inc_return(&keyconf->tx_pn);\n\t\tieee80211_tkip_add_iv(crypto_hdr, keyconf, pn);\n\t\tieee80211_get_tkip_p2k(keyconf, skb_frag, tx_cmd->key);\n\t\tbreak;\n\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\ttx_cmd->sec_ctl |= TX_CMD_SEC_KEY128;\n\t\tfallthrough;\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\ttx_cmd->sec_ctl |= TX_CMD_SEC_WEP |\n\t\t\t((keyconf->keyidx << TX_CMD_SEC_WEP_KEY_IDX_POS) &\n\t\t\t  TX_CMD_SEC_WEP_KEY_IDX_MSK);\n\n\t\tmemcpy(&tx_cmd->key[3], keyconf->key, keyconf->keylen);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\ttype = TX_CMD_SEC_GCMP;\n\t\tfallthrough;\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\t \n\t\ttx_cmd->sec_ctl |= type | TX_CMD_SEC_KEY_FROM_TABLE;\n\t\ttx_cmd->key[0] = keyconf->hw_key_idx;\n\t\tiwl_mvm_set_tx_cmd_pn(info, crypto_hdr);\n\t\tbreak;\n\tdefault:\n\t\ttx_cmd->sec_ctl |= TX_CMD_SEC_EXT;\n\t}\n}\n\n \nstatic struct iwl_device_tx_cmd *\niwl_mvm_set_tx_params(struct iwl_mvm *mvm, struct sk_buff *skb,\n\t\t      struct ieee80211_tx_info *info, int hdrlen,\n\t\t      struct ieee80211_sta *sta, u8 sta_id)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct iwl_device_tx_cmd *dev_cmd;\n\tstruct iwl_tx_cmd *tx_cmd;\n\n\tdev_cmd = iwl_trans_alloc_tx_cmd(mvm->trans);\n\n\tif (unlikely(!dev_cmd))\n\t\treturn NULL;\n\n\tdev_cmd->hdr.cmd = TX_CMD;\n\n\tif (iwl_mvm_has_new_tx_api(mvm)) {\n\t\tu32 rate_n_flags = 0;\n\t\tu16 flags = 0;\n\t\tstruct iwl_mvm_sta *mvmsta = sta ?\n\t\t\tiwl_mvm_sta_from_mac80211(sta) : NULL;\n\t\tbool amsdu = false;\n\n\t\tif (ieee80211_is_data_qos(hdr->frame_control)) {\n\t\t\tu8 *qc = ieee80211_get_qos_ctl(hdr);\n\n\t\t\tamsdu = *qc & IEEE80211_QOS_CTL_A_MSDU_PRESENT;\n\t\t}\n\n\t\tif (!info->control.hw_key)\n\t\t\tflags |= IWL_TX_FLAGS_ENCRYPT_DIS;\n\n\t\t \n\t\tif (unlikely(!sta ||\n\t\t\t     info->control.flags & IEEE80211_TX_CTRL_RATE_INJECT)) {\n\t\t\tflags |= IWL_TX_FLAGS_CMD_RATE;\n\t\t\trate_n_flags =\n\t\t\t\tiwl_mvm_get_tx_rate_n_flags(mvm, info, sta,\n\t\t\t\t\t\t\t    hdr->frame_control);\n\t\t} else if (!ieee80211_is_data(hdr->frame_control) ||\n\t\t\t   mvmsta->sta_state < IEEE80211_STA_AUTHORIZED) {\n\t\t\t \n\t\t\tflags |= IWL_TX_FLAGS_HIGH_PRI;\n\t\t}\n\n\t\tif (mvm->trans->trans_cfg->device_family >=\n\t\t    IWL_DEVICE_FAMILY_AX210) {\n\t\t\tstruct iwl_tx_cmd_gen3 *cmd = (void *)dev_cmd->payload;\n\t\t\tu32 offload_assist = iwl_mvm_tx_csum(mvm, skb,\n\t\t\t\t\t\t\t     info, amsdu);\n\n\t\t\tcmd->offload_assist = cpu_to_le32(offload_assist);\n\n\t\t\t \n\t\t\tcmd->len = cpu_to_le16((u16)skb->len);\n\n\t\t\t \n\t\t\tmemcpy(cmd->hdr, hdr, hdrlen);\n\n\t\t\tcmd->flags = cpu_to_le16(flags);\n\t\t\tcmd->rate_n_flags = cpu_to_le32(rate_n_flags);\n\t\t} else {\n\t\t\tstruct iwl_tx_cmd_gen2 *cmd = (void *)dev_cmd->payload;\n\t\t\tu16 offload_assist = iwl_mvm_tx_csum(mvm, skb,\n\t\t\t\t\t\t\t     info, amsdu);\n\n\t\t\tcmd->offload_assist = cpu_to_le16(offload_assist);\n\n\t\t\t \n\t\t\tcmd->len = cpu_to_le16((u16)skb->len);\n\n\t\t\t \n\t\t\tmemcpy(cmd->hdr, hdr, hdrlen);\n\n\t\t\tcmd->flags = cpu_to_le32(flags);\n\t\t\tcmd->rate_n_flags = cpu_to_le32(rate_n_flags);\n\t\t}\n\t\tgoto out;\n\t}\n\n\ttx_cmd = (struct iwl_tx_cmd *)dev_cmd->payload;\n\n\tif (info->control.hw_key)\n\t\tiwl_mvm_set_tx_cmd_crypto(mvm, info, tx_cmd, skb, hdrlen);\n\n\tiwl_mvm_set_tx_cmd(mvm, skb, tx_cmd, info, sta_id);\n\n\tiwl_mvm_set_tx_cmd_rate(mvm, tx_cmd, info, sta, hdr->frame_control);\n\n\t \n\tmemcpy(tx_cmd->hdr, hdr, hdrlen);\n\nout:\n\treturn dev_cmd;\n}\n\nstatic void iwl_mvm_skb_prepare_status(struct sk_buff *skb,\n\t\t\t\t       struct iwl_device_tx_cmd *cmd)\n{\n\tstruct ieee80211_tx_info *skb_info = IEEE80211_SKB_CB(skb);\n\n\tmemset(&skb_info->status, 0, sizeof(skb_info->status));\n\tmemset(skb_info->driver_data, 0, sizeof(skb_info->driver_data));\n\n\tskb_info->driver_data[1] = cmd;\n}\n\nstatic int iwl_mvm_get_ctrl_vif_queue(struct iwl_mvm *mvm,\n\t\t\t\t      struct iwl_mvm_vif_link_info *link,\n\t\t\t\t      struct ieee80211_tx_info *info,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\t__le16 fc = hdr->frame_control;\n\n\tswitch (info->control.vif->type) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_ADHOC:\n\t\t \n\t\tif (ieee80211_is_mgmt(fc) &&\n\t\t    (!ieee80211_is_bufferable_mmpdu(skb) ||\n\t\t     ieee80211_is_deauth(fc) || ieee80211_is_disassoc(fc)))\n\t\t\treturn link->mgmt_queue;\n\n\t\tif (!ieee80211_has_order(fc) && !ieee80211_is_probe_req(fc) &&\n\t\t    is_multicast_ether_addr(hdr->addr1))\n\t\t\treturn link->cab_queue;\n\n\t\tWARN_ONCE(info->control.vif->type != NL80211_IFTYPE_ADHOC,\n\t\t\t  \"fc=0x%02x\", le16_to_cpu(fc));\n\t\treturn link->mgmt_queue;\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tif (ieee80211_is_mgmt(fc))\n\t\t\treturn mvm->p2p_dev_queue;\n\n\t\tWARN_ON_ONCE(1);\n\t\treturn mvm->p2p_dev_queue;\n\tdefault:\n\t\tWARN_ONCE(1, \"Not a ctrl vif, no available queue\\n\");\n\t\treturn -1;\n\t}\n}\n\nstatic void iwl_mvm_probe_resp_set_noa(struct iwl_mvm *mvm,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct iwl_mvm_vif *mvmvif =\n\t\tiwl_mvm_vif_from_mac80211(info->control.vif);\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;\n\tint base_len = (u8 *)mgmt->u.probe_resp.variable - (u8 *)mgmt;\n\tstruct iwl_probe_resp_data *resp_data;\n\tconst u8 *ie;\n\tu8 *pos;\n\tu8 match[] = {\n\t\t(WLAN_OUI_WFA >> 16) & 0xff,\n\t\t(WLAN_OUI_WFA >> 8) & 0xff,\n\t\tWLAN_OUI_WFA & 0xff,\n\t\tWLAN_OUI_TYPE_WFA_P2P,\n\t};\n\n\trcu_read_lock();\n\n\tresp_data = rcu_dereference(mvmvif->deflink.probe_resp_data);\n\tif (!resp_data)\n\t\tgoto out;\n\n\tif (!resp_data->notif.noa_active)\n\t\tgoto out;\n\n\tie = cfg80211_find_ie_match(WLAN_EID_VENDOR_SPECIFIC,\n\t\t\t\t    mgmt->u.probe_resp.variable,\n\t\t\t\t    skb->len - base_len,\n\t\t\t\t    match, 4, 2);\n\tif (!ie) {\n\t\tIWL_DEBUG_TX(mvm, \"probe resp doesn't have P2P IE\\n\");\n\t\tgoto out;\n\t}\n\n\tif (skb_tailroom(skb) < resp_data->noa_len) {\n\t\tif (pskb_expand_head(skb, 0, resp_data->noa_len, GFP_ATOMIC)) {\n\t\t\tIWL_ERR(mvm,\n\t\t\t\t\"Failed to reallocate probe resp\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tpos = skb_put(skb, resp_data->noa_len);\n\n\t*pos++ = WLAN_EID_VENDOR_SPECIFIC;\n\t \n\t*pos++ = resp_data->noa_len - 2;\n\t*pos++ = (WLAN_OUI_WFA >> 16) & 0xff;\n\t*pos++ = (WLAN_OUI_WFA >> 8) & 0xff;\n\t*pos++ = WLAN_OUI_WFA & 0xff;\n\t*pos++ = WLAN_OUI_TYPE_WFA_P2P;\n\n\tmemcpy(pos, &resp_data->notif.noa_attr,\n\t       resp_data->noa_len - sizeof(struct ieee80211_vendor_ie));\n\nout:\n\trcu_read_unlock();\n}\n\nint iwl_mvm_tx_skb_non_sta(struct iwl_mvm *mvm, struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct ieee80211_tx_info info;\n\tstruct iwl_device_tx_cmd *dev_cmd;\n\tu8 sta_id;\n\tint hdrlen = ieee80211_hdrlen(hdr->frame_control);\n\t__le16 fc = hdr->frame_control;\n\tbool offchannel = IEEE80211_SKB_CB(skb)->flags &\n\t\tIEEE80211_TX_CTL_TX_OFFCHAN;\n\tint queue = -1;\n\n\tif (IWL_MVM_NON_TRANSMITTING_AP && ieee80211_is_probe_resp(fc))\n\t\treturn -1;\n\n\tmemcpy(&info, skb->cb, sizeof(info));\n\n\tif (WARN_ON_ONCE(skb->len > IEEE80211_MAX_DATA_LEN + hdrlen))\n\t\treturn -1;\n\n\tif (WARN_ON_ONCE(info.flags & IEEE80211_TX_CTL_AMPDU))\n\t\treturn -1;\n\n\tif (info.control.vif) {\n\t\tstruct iwl_mvm_vif *mvmvif =\n\t\t\tiwl_mvm_vif_from_mac80211(info.control.vif);\n\n\t\tif (info.control.vif->type == NL80211_IFTYPE_P2P_DEVICE ||\n\t\t    info.control.vif->type == NL80211_IFTYPE_AP ||\n\t\t    info.control.vif->type == NL80211_IFTYPE_ADHOC) {\n\t\t\tu32 link_id = u32_get_bits(info.control.flags,\n\t\t\t\t\t\t   IEEE80211_TX_CTRL_MLO_LINK);\n\t\t\tstruct iwl_mvm_vif_link_info *link;\n\n\t\t\tif (link_id == IEEE80211_LINK_UNSPECIFIED) {\n\t\t\t\tif (info.control.vif->active_links)\n\t\t\t\t\tlink_id = ffs(info.control.vif->active_links) - 1;\n\t\t\t\telse\n\t\t\t\t\tlink_id = 0;\n\t\t\t}\n\n\t\t\tlink = mvmvif->link[link_id];\n\t\t\tif (WARN_ON(!link))\n\t\t\t\treturn -1;\n\n\t\t\tif (!ieee80211_is_data(hdr->frame_control))\n\t\t\t\tsta_id = link->bcast_sta.sta_id;\n\t\t\telse\n\t\t\t\tsta_id = link->mcast_sta.sta_id;\n\n\t\t\tqueue = iwl_mvm_get_ctrl_vif_queue(mvm, link, &info,\n\t\t\t\t\t\t\t   skb);\n\t\t} else if (info.control.vif->type == NL80211_IFTYPE_MONITOR) {\n\t\t\tqueue = mvm->snif_queue;\n\t\t\tsta_id = mvm->snif_sta.sta_id;\n\t\t} else if (info.control.vif->type == NL80211_IFTYPE_STATION &&\n\t\t\t   offchannel) {\n\t\t\t \n\t\t\tsta_id = mvm->aux_sta.sta_id;\n\t\t\tqueue = mvm->aux_queue;\n\t\t}\n\t}\n\n\tif (queue < 0) {\n\t\tIWL_ERR(mvm, \"No queue was found. Dropping TX\\n\");\n\t\treturn -1;\n\t}\n\n\tif (unlikely(ieee80211_is_probe_resp(fc)))\n\t\tiwl_mvm_probe_resp_set_noa(mvm, skb);\n\n\tIWL_DEBUG_TX(mvm, \"station Id %d, queue=%d\\n\", sta_id, queue);\n\n\tdev_cmd = iwl_mvm_set_tx_params(mvm, skb, &info, hdrlen, NULL, sta_id);\n\tif (!dev_cmd)\n\t\treturn -1;\n\n\t \n\tiwl_mvm_skb_prepare_status(skb, dev_cmd);\n\n\tif (iwl_trans_tx(mvm->trans, skb, dev_cmd, queue)) {\n\t\tiwl_trans_free_tx_cmd(mvm->trans, dev_cmd);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nunsigned int iwl_mvm_max_amsdu_size(struct iwl_mvm *mvm,\n\t\t\t\t    struct ieee80211_sta *sta, unsigned int tid)\n{\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tu8 ac = tid_to_mac80211_ac[tid];\n\tenum nl80211_band band;\n\tunsigned int txf;\n\tunsigned int val;\n\tint lmac;\n\n\t \n\tif (sta->deflink.he_cap.has_he && !WARN_ON(!iwl_mvm_has_new_tx_api(mvm)))\n\t\tac += 4;\n\n\ttxf = iwl_mvm_mac_ac_to_tx_fifo(mvm, ac);\n\n\t \n\tval = mvmsta->max_amsdu_len;\n\n\tif (hweight16(sta->valid_links) <= 1) {\n\t\tif (sta->valid_links) {\n\t\t\tstruct ieee80211_bss_conf *link_conf;\n\t\t\tunsigned int link = ffs(sta->valid_links) - 1;\n\n\t\t\trcu_read_lock();\n\t\t\tlink_conf = rcu_dereference(mvmsta->vif->link_conf[link]);\n\t\t\tif (WARN_ON(!link_conf))\n\t\t\t\tband = NL80211_BAND_2GHZ;\n\t\t\telse\n\t\t\t\tband = link_conf->chandef.chan->band;\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tband = mvmsta->vif->bss_conf.chandef.chan->band;\n\t\t}\n\n\t\tlmac = iwl_mvm_get_lmac_id(mvm, band);\n\t} else if (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t       IWL_UCODE_TLV_CAPA_CDB_SUPPORT)) {\n\t\t \n\t\tlmac = IWL_LMAC_5G_INDEX;\n\t\tval = min_t(unsigned int, val,\n\t\t\t    mvm->fwrt.smem_cfg.lmac[lmac].txfifo_size[txf] - 256);\n\t\tlmac = IWL_LMAC_24G_INDEX;\n\t} else {\n\t\tlmac = IWL_LMAC_24G_INDEX;\n\t}\n\n\treturn min_t(unsigned int, val,\n\t\t     mvm->fwrt.smem_cfg.lmac[lmac].txfifo_size[txf] - 256);\n}\n\n#ifdef CONFIG_INET\n\nstatic int\niwl_mvm_tx_tso_segment(struct sk_buff *skb, unsigned int num_subframes,\n\t\t       netdev_features_t netdev_flags,\n\t\t       struct sk_buff_head *mpdus_skb)\n{\n\tstruct sk_buff *tmp, *next;\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tchar cb[sizeof(skb->cb)];\n\tu16 i = 0;\n\tunsigned int tcp_payload_len;\n\tunsigned int mss = skb_shinfo(skb)->gso_size;\n\tbool ipv4 = (skb->protocol == htons(ETH_P_IP));\n\tbool qos = ieee80211_is_data_qos(hdr->frame_control);\n\tu16 ip_base_id = ipv4 ? ntohs(ip_hdr(skb)->id) : 0;\n\n\tskb_shinfo(skb)->gso_size = num_subframes * mss;\n\tmemcpy(cb, skb->cb, sizeof(cb));\n\n\tnext = skb_gso_segment(skb, netdev_flags);\n\tskb_shinfo(skb)->gso_size = mss;\n\tskb_shinfo(skb)->gso_type = ipv4 ? SKB_GSO_TCPV4 : SKB_GSO_TCPV6;\n\tif (WARN_ON_ONCE(IS_ERR(next)))\n\t\treturn -EINVAL;\n\telse if (next)\n\t\tconsume_skb(skb);\n\n\tskb_list_walk_safe(next, tmp, next) {\n\t\tmemcpy(tmp->cb, cb, sizeof(tmp->cb));\n\t\t \n\t\ttcp_payload_len = skb_tail_pointer(tmp) -\n\t\t\tskb_transport_header(tmp) -\n\t\t\ttcp_hdrlen(tmp) + tmp->data_len;\n\n\t\tif (ipv4)\n\t\t\tip_hdr(tmp)->id = htons(ip_base_id + i * num_subframes);\n\n\t\tif (tcp_payload_len > mss) {\n\t\t\tskb_shinfo(tmp)->gso_size = mss;\n\t\t\tskb_shinfo(tmp)->gso_type = ipv4 ? SKB_GSO_TCPV4 :\n\t\t\t\t\t\t\t   SKB_GSO_TCPV6;\n\t\t} else {\n\t\t\tif (qos) {\n\t\t\t\tu8 *qc;\n\n\t\t\t\tif (ipv4)\n\t\t\t\t\tip_send_check(ip_hdr(tmp));\n\n\t\t\t\tqc = ieee80211_get_qos_ctl((void *)tmp->data);\n\t\t\t\t*qc &= ~IEEE80211_QOS_CTL_A_MSDU_PRESENT;\n\t\t\t}\n\t\t\tskb_shinfo(tmp)->gso_size = 0;\n\t\t}\n\n\t\tskb_mark_not_on_list(tmp);\n\t\t__skb_queue_tail(mpdus_skb, tmp);\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic int iwl_mvm_tx_tso(struct iwl_mvm *mvm, struct sk_buff *skb,\n\t\t\t  struct ieee80211_tx_info *info,\n\t\t\t  struct ieee80211_sta *sta,\n\t\t\t  struct sk_buff_head *mpdus_skb)\n{\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tunsigned int mss = skb_shinfo(skb)->gso_size;\n\tunsigned int num_subframes, tcp_payload_len, subf_len, max_amsdu_len;\n\tu16 snap_ip_tcp, pad;\n\tnetdev_features_t netdev_flags = NETIF_F_CSUM_MASK | NETIF_F_SG;\n\tu8 tid;\n\n\tsnap_ip_tcp = 8 + skb_transport_header(skb) - skb_network_header(skb) +\n\t\ttcp_hdrlen(skb);\n\n\tif (!mvmsta->max_amsdu_len ||\n\t    !ieee80211_is_data_qos(hdr->frame_control) ||\n\t    !mvmsta->amsdu_enabled)\n\t\treturn iwl_mvm_tx_tso_segment(skb, 1, netdev_flags, mpdus_skb);\n\n\t \n\tif (skb->protocol == htons(ETH_P_IPV6) &&\n\t    ((struct ipv6hdr *)skb_network_header(skb))->nexthdr !=\n\t    IPPROTO_TCP) {\n\t\tnetdev_flags &= ~NETIF_F_CSUM_MASK;\n\t\treturn iwl_mvm_tx_tso_segment(skb, 1, netdev_flags, mpdus_skb);\n\t}\n\n\ttid = ieee80211_get_tid(hdr);\n\tif (WARN_ON_ONCE(tid >= IWL_MAX_TID_COUNT))\n\t\treturn -EINVAL;\n\n\t \n\tif ((info->flags & IEEE80211_TX_CTL_AMPDU &&\n\t     !mvmsta->tid_data[tid].amsdu_in_ampdu_allowed) ||\n\t    !(mvmsta->amsdu_enabled & BIT(tid)))\n\t\treturn iwl_mvm_tx_tso_segment(skb, 1, netdev_flags, mpdus_skb);\n\n\t \n\tmax_amsdu_len =\n\t\tmin_t(unsigned int, sta->cur->max_amsdu_len,\n\t\t      iwl_mvm_max_amsdu_size(mvm, sta, tid));\n\n\t \n\tif (info->flags & IEEE80211_TX_CTL_AMPDU &&\n\t    !sta->deflink.vht_cap.vht_supported)\n\t\tmax_amsdu_len = min_t(unsigned int, max_amsdu_len, 4095);\n\n\t \n\tsubf_len = sizeof(struct ethhdr) + snap_ip_tcp + mss;\n\tpad = (4 - subf_len) & 0x3;\n\n\t \n\tnum_subframes = (max_amsdu_len + pad) / (subf_len + pad);\n\n\tif (sta->max_amsdu_subframes &&\n\t    num_subframes > sta->max_amsdu_subframes)\n\t\tnum_subframes = sta->max_amsdu_subframes;\n\n\ttcp_payload_len = skb_tail_pointer(skb) - skb_transport_header(skb) -\n\t\ttcp_hdrlen(skb) + skb->data_len;\n\n\t \n\tif ((num_subframes * 2 + skb_shinfo(skb)->nr_frags + 1) >\n\t    mvm->trans->max_skb_frags)\n\t\tnum_subframes = 1;\n\n\tif (num_subframes > 1)\n\t\t*ieee80211_get_qos_ctl(hdr) |= IEEE80211_QOS_CTL_A_MSDU_PRESENT;\n\n\t \n\tif (num_subframes * mss >= tcp_payload_len) {\n\t\t__skb_queue_tail(mpdus_skb, skb);\n\t\treturn 0;\n\t}\n\n\t \n\treturn iwl_mvm_tx_tso_segment(skb, num_subframes, netdev_flags,\n\t\t\t\t      mpdus_skb);\n}\n#else  \nstatic int iwl_mvm_tx_tso(struct iwl_mvm *mvm, struct sk_buff *skb,\n\t\t\t  struct ieee80211_tx_info *info,\n\t\t\t  struct ieee80211_sta *sta,\n\t\t\t  struct sk_buff_head *mpdus_skb)\n{\n\t \n\tWARN_ON(1);\n\n\treturn -1;\n}\n#endif\n\n \nstatic bool iwl_mvm_txq_should_update(struct iwl_mvm *mvm, int txq_id)\n{\n\tunsigned long queue_tid_bitmap = mvm->queue_info[txq_id].tid_bitmap;\n\tunsigned long now = jiffies;\n\tint tid;\n\n\tif (WARN_ON(iwl_mvm_has_new_tx_api(mvm)))\n\t\treturn false;\n\n\tfor_each_set_bit(tid, &queue_tid_bitmap, IWL_MAX_TID_COUNT + 1) {\n\t\tif (time_before(mvm->queue_info[txq_id].last_frame_time[tid] +\n\t\t\t\tIWL_MVM_DQA_QUEUE_TIMEOUT, now))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void iwl_mvm_tx_airtime(struct iwl_mvm *mvm,\n\t\t\t       struct iwl_mvm_sta *mvmsta,\n\t\t\t       int airtime)\n{\n\tint mac = mvmsta->mac_id_n_color & FW_CTXT_ID_MSK;\n\tstruct iwl_mvm_tcm_mac *mdata;\n\n\tif (mac >= NUM_MAC_INDEX_DRIVER)\n\t\treturn;\n\n\tmdata = &mvm->tcm.data[mac];\n\n\tif (mvm->tcm.paused)\n\t\treturn;\n\n\tif (time_after(jiffies, mvm->tcm.ts + MVM_TCM_PERIOD))\n\t\tschedule_delayed_work(&mvm->tcm.work, 0);\n\n\tmdata->tx.airtime += airtime;\n}\n\nstatic int iwl_mvm_tx_pkt_queued(struct iwl_mvm *mvm,\n\t\t\t\t struct iwl_mvm_sta *mvmsta, int tid)\n{\n\tu32 ac = tid_to_mac80211_ac[tid];\n\tint mac = mvmsta->mac_id_n_color & FW_CTXT_ID_MSK;\n\tstruct iwl_mvm_tcm_mac *mdata;\n\n\tif (mac >= NUM_MAC_INDEX_DRIVER)\n\t\treturn -EINVAL;\n\n\tmdata = &mvm->tcm.data[mac];\n\n\tmdata->tx.pkts[ac]++;\n\n\treturn 0;\n}\n\n \nstatic int iwl_mvm_tx_mpdu(struct iwl_mvm *mvm, struct sk_buff *skb,\n\t\t\t   struct ieee80211_tx_info *info,\n\t\t\t   struct ieee80211_sta *sta)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct iwl_mvm_sta *mvmsta;\n\tstruct iwl_device_tx_cmd *dev_cmd;\n\t__le16 fc;\n\tu16 seq_number = 0;\n\tu8 tid = IWL_MAX_TID_COUNT;\n\tu16 txq_id;\n\tbool is_ampdu = false;\n\tint hdrlen;\n\n\tmvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tfc = hdr->frame_control;\n\thdrlen = ieee80211_hdrlen(fc);\n\n\tif (IWL_MVM_NON_TRANSMITTING_AP && ieee80211_is_probe_resp(fc))\n\t\treturn -1;\n\n\tif (WARN_ON_ONCE(!mvmsta))\n\t\treturn -1;\n\n\tif (WARN_ON_ONCE(mvmsta->deflink.sta_id == IWL_MVM_INVALID_STA))\n\t\treturn -1;\n\n\tif (unlikely(ieee80211_is_any_nullfunc(fc)) && sta->deflink.he_cap.has_he)\n\t\treturn -1;\n\n\tif (unlikely(ieee80211_is_probe_resp(fc)))\n\t\tiwl_mvm_probe_resp_set_noa(mvm, skb);\n\n\tdev_cmd = iwl_mvm_set_tx_params(mvm, skb, info, hdrlen,\n\t\t\t\t\tsta, mvmsta->deflink.sta_id);\n\tif (!dev_cmd)\n\t\tgoto drop;\n\n\t \n\tinfo->flags &= ~IEEE80211_TX_STATUS_EOSP;\n\n\tspin_lock(&mvmsta->lock);\n\n\t \n\tif (ieee80211_is_data_qos(fc) && !ieee80211_is_qos_nullfunc(fc)) {\n\t\ttid = ieee80211_get_tid(hdr);\n\t\tif (WARN_ONCE(tid >= IWL_MAX_TID_COUNT, \"Invalid TID %d\", tid))\n\t\t\tgoto drop_unlock_sta;\n\n\t\tis_ampdu = info->flags & IEEE80211_TX_CTL_AMPDU;\n\t\tif (WARN_ONCE(is_ampdu &&\n\t\t\t      mvmsta->tid_data[tid].state != IWL_AGG_ON,\n\t\t\t      \"Invalid internal agg state %d for TID %d\",\n\t\t\t       mvmsta->tid_data[tid].state, tid))\n\t\t\tgoto drop_unlock_sta;\n\n\t\tseq_number = mvmsta->tid_data[tid].seq_number;\n\t\tseq_number &= IEEE80211_SCTL_SEQ;\n\n\t\tif (!iwl_mvm_has_new_tx_api(mvm)) {\n\t\t\tstruct iwl_tx_cmd *tx_cmd = (void *)dev_cmd->payload;\n\n\t\t\thdr->seq_ctrl &= cpu_to_le16(IEEE80211_SCTL_FRAG);\n\t\t\thdr->seq_ctrl |= cpu_to_le16(seq_number);\n\t\t\t \n\t\t\ttx_cmd->hdr->seq_ctrl = hdr->seq_ctrl;\n\t\t}\n\t} else if (ieee80211_is_data(fc) && !ieee80211_is_data_qos(fc) &&\n\t\t   !ieee80211_is_nullfunc(fc)) {\n\t\ttid = IWL_TID_NON_QOS;\n\t}\n\n\ttxq_id = mvmsta->tid_data[tid].txq_id;\n\n\tWARN_ON_ONCE(info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM);\n\n\tif (WARN_ONCE(txq_id == IWL_MVM_INVALID_QUEUE, \"Invalid TXQ id\")) {\n\t\tiwl_trans_free_tx_cmd(mvm->trans, dev_cmd);\n\t\tspin_unlock(&mvmsta->lock);\n\t\treturn -1;\n\t}\n\n\tif (!iwl_mvm_has_new_tx_api(mvm)) {\n\t\t \n\t\tmvm->queue_info[txq_id].last_frame_time[tid] = jiffies;\n\n\t\t \n\t\tif (unlikely(mvm->queue_info[txq_id].status ==\n\t\t\t     IWL_MVM_QUEUE_SHARED &&\n\t\t\t     iwl_mvm_txq_should_update(mvm, txq_id)))\n\t\t\tschedule_work(&mvm->add_stream_wk);\n\t}\n\n\tIWL_DEBUG_TX(mvm, \"TX to [%d|%d] Q:%d - seq: 0x%x len %d\\n\",\n\t\t     mvmsta->deflink.sta_id, tid, txq_id,\n\t\t     IEEE80211_SEQ_TO_SN(seq_number), skb->len);\n\n\t \n\tiwl_mvm_skb_prepare_status(skb, dev_cmd);\n\n\t \n\tif (ieee80211_is_data(fc))\n\t\tiwl_mvm_mei_tx_copy_to_csme(mvm, skb,\n\t\t\t\t\t    info->control.hw_key &&\n\t\t\t\t\t    !iwl_mvm_has_new_tx_api(mvm) ?\n\t\t\t\t\t    info->control.hw_key->iv_len : 0);\n\n\tif (iwl_trans_tx(mvm->trans, skb, dev_cmd, txq_id))\n\t\tgoto drop_unlock_sta;\n\n\tif (tid < IWL_MAX_TID_COUNT && !ieee80211_has_morefrags(fc))\n\t\tmvmsta->tid_data[tid].seq_number = seq_number + 0x10;\n\n\tspin_unlock(&mvmsta->lock);\n\n\tif (iwl_mvm_tx_pkt_queued(mvm, mvmsta,\n\t\t\t\t  tid == IWL_MAX_TID_COUNT ? 0 : tid))\n\t\tgoto drop;\n\n\treturn 0;\n\ndrop_unlock_sta:\n\tiwl_trans_free_tx_cmd(mvm->trans, dev_cmd);\n\tspin_unlock(&mvmsta->lock);\ndrop:\n\tIWL_DEBUG_TX(mvm, \"TX to [%d|%d] dropped\\n\", mvmsta->deflink.sta_id,\n\t\t     tid);\n\treturn -1;\n}\n\nint iwl_mvm_tx_skb_sta(struct iwl_mvm *mvm, struct sk_buff *skb,\n\t\t       struct ieee80211_sta *sta)\n{\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct ieee80211_tx_info info;\n\tstruct sk_buff_head mpdus_skbs;\n\tunsigned int payload_len;\n\tint ret;\n\tstruct sk_buff *orig_skb = skb;\n\n\tif (WARN_ON_ONCE(!mvmsta))\n\t\treturn -1;\n\n\tif (WARN_ON_ONCE(mvmsta->deflink.sta_id == IWL_MVM_INVALID_STA))\n\t\treturn -1;\n\n\tmemcpy(&info, skb->cb, sizeof(info));\n\n\tif (!skb_is_gso(skb))\n\t\treturn iwl_mvm_tx_mpdu(mvm, skb, &info, sta);\n\n\tpayload_len = skb_tail_pointer(skb) - skb_transport_header(skb) -\n\t\ttcp_hdrlen(skb) + skb->data_len;\n\n\tif (payload_len <= skb_shinfo(skb)->gso_size)\n\t\treturn iwl_mvm_tx_mpdu(mvm, skb, &info, sta);\n\n\t__skb_queue_head_init(&mpdus_skbs);\n\n\tret = iwl_mvm_tx_tso(mvm, skb, &info, sta, &mpdus_skbs);\n\tif (ret)\n\t\treturn ret;\n\n\tWARN_ON(skb_queue_empty(&mpdus_skbs));\n\n\twhile (!skb_queue_empty(&mpdus_skbs)) {\n\t\tskb = __skb_dequeue(&mpdus_skbs);\n\n\t\tret = iwl_mvm_tx_mpdu(mvm, skb, &info, sta);\n\t\tif (ret) {\n\t\t\t \n\t\t\t__skb_queue_purge(&mpdus_skbs);\n\t\t\t \n\t\t\tif (skb == orig_skb)\n\t\t\t\tieee80211_free_txskb(mvm->hw, skb);\n\t\t\telse\n\t\t\t\tkfree_skb(skb);\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void iwl_mvm_check_ratid_empty(struct iwl_mvm *mvm,\n\t\t\t\t      struct ieee80211_sta *sta, u8 tid)\n{\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_mvm_tid_data *tid_data = &mvmsta->tid_data[tid];\n\tstruct ieee80211_vif *vif = mvmsta->vif;\n\tu16 normalized_ssn;\n\n\tlockdep_assert_held(&mvmsta->lock);\n\n\tif ((tid_data->state == IWL_AGG_ON ||\n\t     tid_data->state == IWL_EMPTYING_HW_QUEUE_DELBA) &&\n\t    iwl_mvm_tid_queued(mvm, tid_data) == 0) {\n\t\t \n\t\tieee80211_sta_set_buffered(sta, tid, false);\n\t}\n\n\t \n\tnormalized_ssn = tid_data->ssn;\n\tif (mvm->trans->trans_cfg->gen2)\n\t\tnormalized_ssn &= 0xff;\n\n\tif (normalized_ssn != tid_data->next_reclaimed)\n\t\treturn;\n\n\tswitch (tid_data->state) {\n\tcase IWL_EMPTYING_HW_QUEUE_ADDBA:\n\t\tIWL_DEBUG_TX_QUEUES(mvm,\n\t\t\t\t    \"Can continue addBA flow ssn = next_recl = %d\\n\",\n\t\t\t\t    tid_data->next_reclaimed);\n\t\ttid_data->state = IWL_AGG_STARTING;\n\t\tieee80211_start_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\t\tbreak;\n\n\tcase IWL_EMPTYING_HW_QUEUE_DELBA:\n\t\tIWL_DEBUG_TX_QUEUES(mvm,\n\t\t\t\t    \"Can continue DELBA flow ssn = next_recl = %d\\n\",\n\t\t\t\t    tid_data->next_reclaimed);\n\t\ttid_data->state = IWL_AGG_OFF;\n\t\tieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n#ifdef CONFIG_IWLWIFI_DEBUG\nconst char *iwl_mvm_get_tx_fail_reason(u32 status)\n{\n#define TX_STATUS_FAIL(x) case TX_STATUS_FAIL_ ## x: return #x\n#define TX_STATUS_POSTPONE(x) case TX_STATUS_POSTPONE_ ## x: return #x\n\n\tswitch (status & TX_STATUS_MSK) {\n\tcase TX_STATUS_SUCCESS:\n\t\treturn \"SUCCESS\";\n\tTX_STATUS_POSTPONE(DELAY);\n\tTX_STATUS_POSTPONE(FEW_BYTES);\n\tTX_STATUS_POSTPONE(BT_PRIO);\n\tTX_STATUS_POSTPONE(QUIET_PERIOD);\n\tTX_STATUS_POSTPONE(CALC_TTAK);\n\tTX_STATUS_FAIL(INTERNAL_CROSSED_RETRY);\n\tTX_STATUS_FAIL(SHORT_LIMIT);\n\tTX_STATUS_FAIL(LONG_LIMIT);\n\tTX_STATUS_FAIL(UNDERRUN);\n\tTX_STATUS_FAIL(DRAIN_FLOW);\n\tTX_STATUS_FAIL(RFKILL_FLUSH);\n\tTX_STATUS_FAIL(LIFE_EXPIRE);\n\tTX_STATUS_FAIL(DEST_PS);\n\tTX_STATUS_FAIL(HOST_ABORTED);\n\tTX_STATUS_FAIL(BT_RETRY);\n\tTX_STATUS_FAIL(STA_INVALID);\n\tTX_STATUS_FAIL(FRAG_DROPPED);\n\tTX_STATUS_FAIL(TID_DISABLE);\n\tTX_STATUS_FAIL(FIFO_FLUSHED);\n\tTX_STATUS_FAIL(SMALL_CF_POLL);\n\tTX_STATUS_FAIL(FW_DROP);\n\tTX_STATUS_FAIL(STA_COLOR_MISMATCH);\n\t}\n\n\treturn \"UNKNOWN\";\n\n#undef TX_STATUS_FAIL\n#undef TX_STATUS_POSTPONE\n}\n#endif  \n\nstatic int iwl_mvm_get_hwrate_chan_width(u32 chan_width)\n{\n\tswitch (chan_width) {\n\tcase RATE_MCS_CHAN_WIDTH_20:\n\t\treturn 0;\n\tcase RATE_MCS_CHAN_WIDTH_40:\n\t\treturn IEEE80211_TX_RC_40_MHZ_WIDTH;\n\tcase RATE_MCS_CHAN_WIDTH_80:\n\t\treturn IEEE80211_TX_RC_80_MHZ_WIDTH;\n\tcase RATE_MCS_CHAN_WIDTH_160:\n\t\treturn IEEE80211_TX_RC_160_MHZ_WIDTH;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nvoid iwl_mvm_hwrate_to_tx_rate(u32 rate_n_flags,\n\t\t\t       enum nl80211_band band,\n\t\t\t       struct ieee80211_tx_rate *r)\n{\n\tu32 format = rate_n_flags & RATE_MCS_MOD_TYPE_MSK;\n\tu32 rate = format == RATE_MCS_HT_MSK ?\n\t\tRATE_HT_MCS_INDEX(rate_n_flags) :\n\t\trate_n_flags & RATE_MCS_CODE_MSK;\n\n\tr->flags |=\n\t\tiwl_mvm_get_hwrate_chan_width(rate_n_flags &\n\t\t\t\t\t      RATE_MCS_CHAN_WIDTH_MSK);\n\n\tif (rate_n_flags & RATE_MCS_SGI_MSK)\n\t\tr->flags |= IEEE80211_TX_RC_SHORT_GI;\n\tif (format ==  RATE_MCS_HT_MSK) {\n\t\tr->flags |= IEEE80211_TX_RC_MCS;\n\t\tr->idx = rate;\n\t} else if (format ==  RATE_MCS_VHT_MSK) {\n\t\tieee80211_rate_set_vht(r, rate,\n\t\t\t\t       FIELD_GET(RATE_MCS_NSS_MSK,\n\t\t\t\t\t\t rate_n_flags) + 1);\n\t\tr->flags |= IEEE80211_TX_RC_VHT_MCS;\n\t} else if (format == RATE_MCS_HE_MSK) {\n\t\t \n\t\tr->idx = 0;\n\t} else {\n\t\tr->idx = iwl_mvm_legacy_hw_idx_to_mac80211_idx(rate_n_flags,\n\t\t\t\t\t\t\t       band);\n\t}\n}\n\nvoid iwl_mvm_hwrate_to_tx_rate_v1(u32 rate_n_flags,\n\t\t\t\t  enum nl80211_band band,\n\t\t\t\t  struct ieee80211_tx_rate *r)\n{\n\tif (rate_n_flags & RATE_HT_MCS_GF_MSK)\n\t\tr->flags |= IEEE80211_TX_RC_GREEN_FIELD;\n\n\tr->flags |=\n\t\tiwl_mvm_get_hwrate_chan_width(rate_n_flags &\n\t\t\t\t\t      RATE_MCS_CHAN_WIDTH_MSK_V1);\n\n\tif (rate_n_flags & RATE_MCS_SGI_MSK_V1)\n\t\tr->flags |= IEEE80211_TX_RC_SHORT_GI;\n\tif (rate_n_flags & RATE_MCS_HT_MSK_V1) {\n\t\tr->flags |= IEEE80211_TX_RC_MCS;\n\t\tr->idx = rate_n_flags & RATE_HT_MCS_INDEX_MSK_V1;\n\t} else if (rate_n_flags & RATE_MCS_VHT_MSK_V1) {\n\t\tieee80211_rate_set_vht(\n\t\t\tr, rate_n_flags & RATE_VHT_MCS_RATE_CODE_MSK,\n\t\t\tFIELD_GET(RATE_MCS_NSS_MSK, rate_n_flags) + 1);\n\t\tr->flags |= IEEE80211_TX_RC_VHT_MCS;\n\t} else {\n\t\tr->idx = iwl_mvm_legacy_rate_to_mac80211_idx(rate_n_flags,\n\t\t\t\t\t\t\t     band);\n\t}\n}\n\n \nstatic void iwl_mvm_hwrate_to_tx_status(const struct iwl_fw *fw,\n\t\t\t\t\tu32 rate_n_flags,\n\t\t\t\t\tstruct ieee80211_tx_info *info)\n{\n\tstruct ieee80211_tx_rate *r = &info->status.rates[0];\n\n\tif (iwl_fw_lookup_notif_ver(fw, LONG_GROUP,\n\t\t\t\t    TX_CMD, 0) <= 6)\n\t\trate_n_flags = iwl_new_rate_from_v1(rate_n_flags);\n\n\tinfo->status.antenna =\n\t\t((rate_n_flags & RATE_MCS_ANT_AB_MSK) >> RATE_MCS_ANT_POS);\n\tiwl_mvm_hwrate_to_tx_rate(rate_n_flags,\n\t\t\t\t  info->band, r);\n}\n\nstatic void iwl_mvm_tx_status_check_trigger(struct iwl_mvm *mvm,\n\t\t\t\t\t    u32 status, __le16 frame_control)\n{\n\tstruct iwl_fw_dbg_trigger_tlv *trig;\n\tstruct iwl_fw_dbg_trigger_tx_status *status_trig;\n\tint i;\n\n\tif ((status & TX_STATUS_MSK) != TX_STATUS_SUCCESS) {\n\t\tenum iwl_fw_ini_time_point tp =\n\t\t\tIWL_FW_INI_TIME_POINT_TX_FAILED;\n\n\t\tif (ieee80211_is_action(frame_control))\n\t\t\ttp = IWL_FW_INI_TIME_POINT_TX_WFD_ACTION_FRAME_FAILED;\n\n\t\tiwl_dbg_tlv_time_point(&mvm->fwrt,\n\t\t\t\t       tp, NULL);\n\t\treturn;\n\t}\n\n\ttrig = iwl_fw_dbg_trigger_on(&mvm->fwrt, NULL,\n\t\t\t\t     FW_DBG_TRIGGER_TX_STATUS);\n\tif (!trig)\n\t\treturn;\n\n\tstatus_trig = (void *)trig->data;\n\n\tfor (i = 0; i < ARRAY_SIZE(status_trig->statuses); i++) {\n\t\t \n\t\tif (!status_trig->statuses[i].status)\n\t\t\tbreak;\n\n\t\tif (status_trig->statuses[i].status != (status & TX_STATUS_MSK))\n\t\t\tcontinue;\n\n\t\tiwl_fw_dbg_collect_trig(&mvm->fwrt, trig,\n\t\t\t\t\t\"Tx status %d was received\",\n\t\t\t\t\tstatus & TX_STATUS_MSK);\n\t\tbreak;\n\t}\n}\n\n \nstatic inline u32 iwl_mvm_get_scd_ssn(struct iwl_mvm *mvm,\n\t\t\t\t      struct iwl_mvm_tx_resp *tx_resp)\n{\n\treturn le32_to_cpup((__le32 *)iwl_mvm_get_agg_status(mvm, tx_resp) +\n\t\t\t    tx_resp->frame_count) & 0xfff;\n}\n\nstatic void iwl_mvm_rx_tx_cmd_single(struct iwl_mvm *mvm,\n\t\t\t\t     struct iwl_rx_packet *pkt)\n{\n\tstruct ieee80211_sta *sta;\n\tu16 sequence = le16_to_cpu(pkt->hdr.sequence);\n\tint txq_id = SEQ_TO_QUEUE(sequence);\n\t \n\tstruct iwl_mvm_tx_resp *tx_resp = (void *)pkt->data;\n\tint sta_id = IWL_MVM_TX_RES_GET_RA(tx_resp->ra_tid);\n\tint tid = IWL_MVM_TX_RES_GET_TID(tx_resp->ra_tid);\n\tstruct agg_tx_status *agg_status =\n\t\tiwl_mvm_get_agg_status(mvm, tx_resp);\n\tu32 status = le16_to_cpu(agg_status->status);\n\tu16 ssn = iwl_mvm_get_scd_ssn(mvm, tx_resp);\n\tstruct sk_buff_head skbs;\n\tu8 skb_freed = 0;\n\tu8 lq_color;\n\tu16 next_reclaimed, seq_ctl;\n\tbool is_ndp = false;\n\n\t__skb_queue_head_init(&skbs);\n\n\tif (iwl_mvm_has_new_tx_api(mvm))\n\t\ttxq_id = le16_to_cpu(tx_resp->tx_queue);\n\n\tseq_ctl = le16_to_cpu(tx_resp->seq_ctl);\n\n\t \n\tiwl_trans_reclaim(mvm->trans, txq_id, ssn, &skbs, false);\n\n\twhile (!skb_queue_empty(&skbs)) {\n\t\tstruct sk_buff *skb = __skb_dequeue(&skbs);\n\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\t\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\t\tbool flushed = false;\n\n\t\tskb_freed++;\n\n\t\tiwl_trans_free_tx_cmd(mvm->trans, info->driver_data[1]);\n\n\t\tmemset(&info->status, 0, sizeof(info->status));\n\t\tinfo->flags &= ~(IEEE80211_TX_STAT_ACK | IEEE80211_TX_STAT_TX_FILTERED);\n\n\t\t \n\t\tswitch (status & TX_STATUS_MSK) {\n\t\tcase TX_STATUS_SUCCESS:\n\t\tcase TX_STATUS_DIRECT_DONE:\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\t\t\tbreak;\n\t\tcase TX_STATUS_FAIL_FIFO_FLUSHED:\n\t\tcase TX_STATUS_FAIL_DRAIN_FLOW:\n\t\t\tflushed = true;\n\t\t\tbreak;\n\t\tcase TX_STATUS_FAIL_DEST_PS:\n\t\t\t \n\t\t\tIWL_ERR_LIMIT(mvm,\n\t\t\t\t      \"FW reported TX filtered, status=0x%x, FC=0x%x\\n\",\n\t\t\t\t      status, le16_to_cpu(hdr->frame_control));\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_TX_FILTERED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((status & TX_STATUS_MSK) != TX_STATUS_SUCCESS &&\n\t\t    ieee80211_is_mgmt(hdr->frame_control))\n\t\t\tiwl_mvm_toggle_tx_ant(mvm, &mvm->mgmt_last_antenna_idx);\n\n\t\t \n\t\tif (skb_freed > 1)\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\n\t\tiwl_mvm_tx_status_check_trigger(mvm, status, hdr->frame_control);\n\n\t\tinfo->status.rates[0].count = tx_resp->failure_frame + 1;\n\n\t\tiwl_mvm_hwrate_to_tx_status(mvm->fw,\n\t\t\t\t\t    le32_to_cpu(tx_resp->initial_rate),\n\t\t\t\t\t    info);\n\n\t\t \n\t\tinfo->status.status_driver_data[1] =\n\t\t\t(void *)(uintptr_t)le32_to_cpu(tx_resp->initial_rate);\n\n\t\t \n\t\tif (info->flags & IEEE80211_TX_CTL_AMPDU &&\n\t\t    !(info->flags & IEEE80211_TX_STAT_ACK) &&\n\t\t    !(info->flags & IEEE80211_TX_STAT_TX_FILTERED) && !flushed)\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_AMPDU_NO_BACK;\n\t\tinfo->flags &= ~IEEE80211_TX_CTL_AMPDU;\n\n\t\t \n\t\tif (ieee80211_is_back_req(hdr->frame_control))\n\t\t\tseq_ctl = 0;\n\t\telse if (status != TX_STATUS_SUCCESS)\n\t\t\tseq_ctl = le16_to_cpu(hdr->seq_ctrl);\n\n\t\tif (unlikely(!seq_ctl)) {\n\t\t\t \n\t\t\tif (ieee80211_is_qos_nullfunc(hdr->frame_control))\n\t\t\t\tis_ndp = true;\n\t\t}\n\n\t\t \n\t\tinfo->status.tx_time =\n\t\t\tle16_to_cpu(tx_resp->wireless_media_time);\n\t\tBUILD_BUG_ON(ARRAY_SIZE(info->status.status_driver_data) < 1);\n\t\tlq_color = TX_RES_RATE_TABLE_COL_GET(tx_resp->tlc_info);\n\t\tinfo->status.status_driver_data[0] =\n\t\t\tRS_DRV_DATA_PACK(lq_color, tx_resp->reduced_tpc);\n\n\t\tif (likely(!iwl_mvm_time_sync_frame(mvm, skb, hdr->addr1)))\n\t\t\tieee80211_tx_status(mvm->hw, skb);\n\t}\n\n\t \n\tnext_reclaimed = ssn;\n\n\tIWL_DEBUG_TX_REPLY(mvm,\n\t\t\t   \"TXQ %d status %s (0x%08x)\\n\",\n\t\t\t   txq_id, iwl_mvm_get_tx_fail_reason(status), status);\n\n\tIWL_DEBUG_TX_REPLY(mvm,\n\t\t\t   \"\\t\\t\\t\\tinitial_rate 0x%x retries %d, idx=%d ssn=%d next_reclaimed=0x%x seq_ctl=0x%x\\n\",\n\t\t\t   le32_to_cpu(tx_resp->initial_rate),\n\t\t\t   tx_resp->failure_frame, SEQ_TO_INDEX(sequence),\n\t\t\t   ssn, next_reclaimed, seq_ctl);\n\n\trcu_read_lock();\n\n\tsta = rcu_dereference(mvm->fw_id_to_mac_id[sta_id]);\n\t \n\tif (WARN_ON_ONCE(!sta))\n\t\tgoto out;\n\n\tif (!IS_ERR(sta)) {\n\t\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\n\t\tiwl_mvm_tx_airtime(mvm, mvmsta,\n\t\t\t\t   le16_to_cpu(tx_resp->wireless_media_time));\n\n\t\tif ((status & TX_STATUS_MSK) != TX_STATUS_SUCCESS &&\n\t\t    mvmsta->sta_state < IEEE80211_STA_AUTHORIZED)\n\t\t\tiwl_mvm_toggle_tx_ant(mvm, &mvmsta->tx_ant);\n\n\t\tif (sta->wme && tid != IWL_MGMT_TID) {\n\t\t\tstruct iwl_mvm_tid_data *tid_data =\n\t\t\t\t&mvmsta->tid_data[tid];\n\t\t\tbool send_eosp_ndp = false;\n\n\t\t\tspin_lock_bh(&mvmsta->lock);\n\n\t\t\tif (!is_ndp) {\n\t\t\t\ttid_data->next_reclaimed = next_reclaimed;\n\t\t\t\tIWL_DEBUG_TX_REPLY(mvm,\n\t\t\t\t\t\t   \"Next reclaimed packet:%d\\n\",\n\t\t\t\t\t\t   next_reclaimed);\n\t\t\t} else {\n\t\t\t\tIWL_DEBUG_TX_REPLY(mvm,\n\t\t\t\t\t\t   \"NDP - don't update next_reclaimed\\n\");\n\t\t\t}\n\n\t\t\tiwl_mvm_check_ratid_empty(mvm, sta, tid);\n\n\t\t\tif (mvmsta->sleep_tx_count) {\n\t\t\t\tmvmsta->sleep_tx_count--;\n\t\t\t\tif (mvmsta->sleep_tx_count &&\n\t\t\t\t    !iwl_mvm_tid_queued(mvm, tid_data)) {\n\t\t\t\t\t \n\t\t\t\t\tsend_eosp_ndp = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tspin_unlock_bh(&mvmsta->lock);\n\t\t\tif (send_eosp_ndp) {\n\t\t\t\tiwl_mvm_sta_modify_sleep_tx_count(mvm, sta,\n\t\t\t\t\tIEEE80211_FRAME_RELEASE_UAPSD,\n\t\t\t\t\t1, tid, false, false);\n\t\t\t\tmvmsta->sleep_tx_count = 0;\n\t\t\t\tieee80211_send_eosp_nullfunc(sta, tid);\n\t\t\t}\n\t\t}\n\n\t\tif (mvmsta->next_status_eosp) {\n\t\t\tmvmsta->next_status_eosp = false;\n\t\t\tieee80211_sta_eosp(sta);\n\t\t}\n\t}\nout:\n\trcu_read_unlock();\n}\n\n#ifdef CONFIG_IWLWIFI_DEBUG\n#define AGG_TX_STATE_(x) case AGG_TX_STATE_ ## x: return #x\nstatic const char *iwl_get_agg_tx_status(u16 status)\n{\n\tswitch (status & AGG_TX_STATE_STATUS_MSK) {\n\tAGG_TX_STATE_(TRANSMITTED);\n\tAGG_TX_STATE_(UNDERRUN);\n\tAGG_TX_STATE_(BT_PRIO);\n\tAGG_TX_STATE_(FEW_BYTES);\n\tAGG_TX_STATE_(ABORT);\n\tAGG_TX_STATE_(TX_ON_AIR_DROP);\n\tAGG_TX_STATE_(LAST_SENT_TRY_CNT);\n\tAGG_TX_STATE_(LAST_SENT_BT_KILL);\n\tAGG_TX_STATE_(SCD_QUERY);\n\tAGG_TX_STATE_(TEST_BAD_CRC32);\n\tAGG_TX_STATE_(RESPONSE);\n\tAGG_TX_STATE_(DUMP_TX);\n\tAGG_TX_STATE_(DELAY_TX);\n\t}\n\n\treturn \"UNKNOWN\";\n}\n\nstatic void iwl_mvm_rx_tx_cmd_agg_dbg(struct iwl_mvm *mvm,\n\t\t\t\t      struct iwl_rx_packet *pkt)\n{\n\tstruct iwl_mvm_tx_resp *tx_resp = (void *)pkt->data;\n\tstruct agg_tx_status *frame_status =\n\t\tiwl_mvm_get_agg_status(mvm, tx_resp);\n\tint i;\n\tbool tirgger_timepoint = false;\n\n\tfor (i = 0; i < tx_resp->frame_count; i++) {\n\t\tu16 fstatus = le16_to_cpu(frame_status[i].status);\n\t\t \n\t\ttirgger_timepoint |= ((fstatus & AGG_TX_STATE_STATUS_MSK) !=\n\t\t\t\t      AGG_TX_STATE_TRANSMITTED);\n\t\tIWL_DEBUG_TX_REPLY(mvm,\n\t\t\t\t   \"status %s (0x%04x), try-count (%d) seq (0x%x)\\n\",\n\t\t\t\t   iwl_get_agg_tx_status(fstatus),\n\t\t\t\t   fstatus & AGG_TX_STATE_STATUS_MSK,\n\t\t\t\t   (fstatus & AGG_TX_STATE_TRY_CNT_MSK) >>\n\t\t\t\t\tAGG_TX_STATE_TRY_CNT_POS,\n\t\t\t\t   le16_to_cpu(frame_status[i].sequence));\n\t}\n\n\tif (tirgger_timepoint)\n\t\tiwl_dbg_tlv_time_point(&mvm->fwrt,\n\t\t\t\t       IWL_FW_INI_TIME_POINT_TX_FAILED, NULL);\n\n}\n#else\nstatic void iwl_mvm_rx_tx_cmd_agg_dbg(struct iwl_mvm *mvm,\n\t\t\t\t      struct iwl_rx_packet *pkt)\n{}\n#endif  \n\nstatic void iwl_mvm_rx_tx_cmd_agg(struct iwl_mvm *mvm,\n\t\t\t\t  struct iwl_rx_packet *pkt)\n{\n\tstruct iwl_mvm_tx_resp *tx_resp = (void *)pkt->data;\n\tint sta_id = IWL_MVM_TX_RES_GET_RA(tx_resp->ra_tid);\n\tint tid = IWL_MVM_TX_RES_GET_TID(tx_resp->ra_tid);\n\tu16 sequence = le16_to_cpu(pkt->hdr.sequence);\n\tstruct iwl_mvm_sta *mvmsta;\n\tint queue = SEQ_TO_QUEUE(sequence);\n\tstruct ieee80211_sta *sta;\n\n\tif (WARN_ON_ONCE(queue < IWL_MVM_DQA_MIN_DATA_QUEUE &&\n\t\t\t (queue != IWL_MVM_DQA_BSS_CLIENT_QUEUE)))\n\t\treturn;\n\n\tiwl_mvm_rx_tx_cmd_agg_dbg(mvm, pkt);\n\n\trcu_read_lock();\n\n\tmvmsta = iwl_mvm_sta_from_staid_rcu(mvm, sta_id);\n\n\tsta = rcu_dereference(mvm->fw_id_to_mac_id[sta_id]);\n\tif (WARN_ON_ONCE(IS_ERR_OR_NULL(sta) || !sta->wme)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (!WARN_ON_ONCE(!mvmsta)) {\n\t\tmvmsta->tid_data[tid].rate_n_flags =\n\t\t\tle32_to_cpu(tx_resp->initial_rate);\n\t\tmvmsta->tid_data[tid].tx_time =\n\t\t\tle16_to_cpu(tx_resp->wireless_media_time);\n\t\tmvmsta->tid_data[tid].lq_color =\n\t\t\tTX_RES_RATE_TABLE_COL_GET(tx_resp->tlc_info);\n\t\tiwl_mvm_tx_airtime(mvm, mvmsta,\n\t\t\t\t   le16_to_cpu(tx_resp->wireless_media_time));\n\t}\n\n\trcu_read_unlock();\n}\n\nvoid iwl_mvm_rx_tx_cmd(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_mvm_tx_resp *tx_resp = (void *)pkt->data;\n\n\tif (tx_resp->frame_count == 1)\n\t\tiwl_mvm_rx_tx_cmd_single(mvm, pkt);\n\telse\n\t\tiwl_mvm_rx_tx_cmd_agg(mvm, pkt);\n}\n\nstatic void iwl_mvm_tx_reclaim(struct iwl_mvm *mvm, int sta_id, int tid,\n\t\t\t       int txq, int index,\n\t\t\t       struct ieee80211_tx_info *tx_info, u32 rate,\n\t\t\t       bool is_flush)\n{\n\tstruct sk_buff_head reclaimed_skbs;\n\tstruct iwl_mvm_tid_data *tid_data = NULL;\n\tstruct ieee80211_sta *sta;\n\tstruct iwl_mvm_sta *mvmsta = NULL;\n\tstruct sk_buff *skb;\n\tint freed;\n\n\tif (WARN_ONCE(sta_id >= mvm->fw->ucode_capa.num_stations ||\n\t\t      tid > IWL_MAX_TID_COUNT,\n\t\t      \"sta_id %d tid %d\", sta_id, tid))\n\t\treturn;\n\n\trcu_read_lock();\n\n\tsta = rcu_dereference(mvm->fw_id_to_mac_id[sta_id]);\n\n\t \n\tif (WARN_ON_ONCE(!sta)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t__skb_queue_head_init(&reclaimed_skbs);\n\n\t \n\tiwl_trans_reclaim(mvm->trans, txq, index, &reclaimed_skbs, is_flush);\n\n\tskb_queue_walk(&reclaimed_skbs, skb) {\n\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\n\t\tiwl_trans_free_tx_cmd(mvm->trans, info->driver_data[1]);\n\n\t\tmemset(&info->status, 0, sizeof(info->status));\n\t\t \n\t\tif (!is_flush)\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\t\telse\n\t\t\tinfo->flags &= ~IEEE80211_TX_STAT_ACK;\n\t}\n\n\t \n\tif (IS_ERR(sta))\n\t\tgoto out;\n\n\tmvmsta = iwl_mvm_sta_from_mac80211(sta);\n\ttid_data = &mvmsta->tid_data[tid];\n\n\tif (tid_data->txq_id != txq) {\n\t\tIWL_ERR(mvm,\n\t\t\t\"invalid reclaim request: Q %d, tid %d\\n\",\n\t\t\ttid_data->txq_id, tid);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&mvmsta->lock);\n\n\ttid_data->next_reclaimed = index;\n\n\tiwl_mvm_check_ratid_empty(mvm, sta, tid);\n\n\tfreed = 0;\n\n\t \n\ttx_info->status.status_driver_data[0] =\n\t\tRS_DRV_DATA_PACK(tid_data->lq_color,\n\t\t\t\t tx_info->status.status_driver_data[0]);\n\ttx_info->status.status_driver_data[1] = (void *)(uintptr_t)rate;\n\n\tskb_queue_walk(&reclaimed_skbs, skb) {\n\t\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\n\t\tif (!is_flush) {\n\t\t\tif (ieee80211_is_data_qos(hdr->frame_control))\n\t\t\t\tfreed++;\n\t\t\telse\n\t\t\t\tWARN_ON_ONCE(tid != IWL_MAX_TID_COUNT);\n\t\t}\n\n\t\t \n\t\t \n\t\tif (freed == 1) {\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_AMPDU;\n\t\t\tmemcpy(&info->status, &tx_info->status,\n\t\t\t       sizeof(tx_info->status));\n\t\t\tiwl_mvm_hwrate_to_tx_status(mvm->fw, rate, info);\n\t\t}\n\t}\n\n\tspin_unlock_bh(&mvmsta->lock);\n\n\t \n\tif (!is_flush && skb_queue_empty(&reclaimed_skbs) &&\n\t    !iwl_mvm_has_tlc_offload(mvm)) {\n\t\tstruct ieee80211_chanctx_conf *chanctx_conf = NULL;\n\n\t\t \n\t\tif (mvmsta->vif)\n\t\t\tchanctx_conf =\n\t\t\t\trcu_dereference(mvmsta->vif->bss_conf.chanctx_conf);\n\n\t\tif (WARN_ON_ONCE(!chanctx_conf))\n\t\t\tgoto out;\n\n\t\ttx_info->band = chanctx_conf->def.chan->band;\n\t\tiwl_mvm_hwrate_to_tx_status(mvm->fw, rate, tx_info);\n\n\t\tIWL_DEBUG_TX_REPLY(mvm, \"No reclaim. Update rs directly\\n\");\n\t\tiwl_mvm_rs_tx_status(mvm, sta, tid, tx_info, false);\n\t}\n\nout:\n\trcu_read_unlock();\n\n\twhile (!skb_queue_empty(&reclaimed_skbs)) {\n\t\tskb = __skb_dequeue(&reclaimed_skbs);\n\t\tieee80211_tx_status(mvm->hw, skb);\n\t}\n}\n\nvoid iwl_mvm_rx_ba_notif(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tunsigned int pkt_len = iwl_rx_packet_payload_len(pkt);\n\tint sta_id, tid, txq, index;\n\tstruct ieee80211_tx_info ba_info = {};\n\tstruct iwl_mvm_ba_notif *ba_notif;\n\tstruct iwl_mvm_tid_data *tid_data;\n\tstruct iwl_mvm_sta *mvmsta;\n\n\tba_info.flags = IEEE80211_TX_STAT_AMPDU;\n\n\tif (iwl_mvm_has_new_tx_api(mvm)) {\n\t\tstruct iwl_mvm_compressed_ba_notif *ba_res =\n\t\t\t(void *)pkt->data;\n\t\tu8 lq_color = TX_RES_RATE_TABLE_COL_GET(ba_res->tlc_rate_info);\n\t\tu16 tfd_cnt;\n\t\tint i;\n\n\t\tif (IWL_FW_CHECK(mvm, sizeof(*ba_res) > pkt_len,\n\t\t\t\t \"short BA notification (%d)\\n\", pkt_len))\n\t\t\treturn;\n\n\t\tsta_id = ba_res->sta_id;\n\t\tba_info.status.ampdu_ack_len = (u8)le16_to_cpu(ba_res->done);\n\t\tba_info.status.ampdu_len = (u8)le16_to_cpu(ba_res->txed);\n\t\tba_info.status.tx_time =\n\t\t\t(u16)le32_to_cpu(ba_res->wireless_time);\n\t\tba_info.status.status_driver_data[0] =\n\t\t\t(void *)(uintptr_t)ba_res->reduced_txp;\n\n\t\ttfd_cnt = le16_to_cpu(ba_res->tfd_cnt);\n\t\tif (!tfd_cnt)\n\t\t\treturn;\n\n\t\tif (IWL_FW_CHECK(mvm,\n\t\t\t\t struct_size(ba_res, tfd, tfd_cnt) > pkt_len,\n\t\t\t\t \"short BA notification (tfds:%d, size:%d)\\n\",\n\t\t\t\t tfd_cnt, pkt_len))\n\t\t\treturn;\n\n\t\trcu_read_lock();\n\n\t\tmvmsta = iwl_mvm_sta_from_staid_rcu(mvm, sta_id);\n\t\t \n\n\t\t \n\t\tfor (i = 0; i < tfd_cnt; i++) {\n\t\t\tstruct iwl_mvm_compressed_ba_tfd *ba_tfd =\n\t\t\t\t&ba_res->tfd[i];\n\n\t\t\ttid = ba_tfd->tid;\n\t\t\tif (tid == IWL_MGMT_TID)\n\t\t\t\ttid = IWL_MAX_TID_COUNT;\n\n\t\t\tif (mvmsta)\n\t\t\t\tmvmsta->tid_data[i].lq_color = lq_color;\n\n\t\t\tiwl_mvm_tx_reclaim(mvm, sta_id, tid,\n\t\t\t\t\t   (int)(le16_to_cpu(ba_tfd->q_num)),\n\t\t\t\t\t   le16_to_cpu(ba_tfd->tfd_index),\n\t\t\t\t\t   &ba_info,\n\t\t\t\t\t   le32_to_cpu(ba_res->tx_rate), false);\n\t\t}\n\n\t\tif (mvmsta)\n\t\t\tiwl_mvm_tx_airtime(mvm, mvmsta,\n\t\t\t\t\t   le32_to_cpu(ba_res->wireless_time));\n\t\trcu_read_unlock();\n\n\t\tIWL_DEBUG_TX_REPLY(mvm,\n\t\t\t\t   \"BA_NOTIFICATION Received from sta_id = %d, flags %x, sent:%d, acked:%d\\n\",\n\t\t\t\t   sta_id, le32_to_cpu(ba_res->flags),\n\t\t\t\t   le16_to_cpu(ba_res->txed),\n\t\t\t\t   le16_to_cpu(ba_res->done));\n\t\treturn;\n\t}\n\n\tba_notif = (void *)pkt->data;\n\tsta_id = ba_notif->sta_id;\n\ttid = ba_notif->tid;\n\t \n\ttxq = le16_to_cpu(ba_notif->scd_flow);\n\t \n\tindex = le16_to_cpu(ba_notif->scd_ssn);\n\n\trcu_read_lock();\n\tmvmsta = iwl_mvm_sta_from_staid_rcu(mvm, sta_id);\n\tif (IWL_FW_CHECK(mvm, !mvmsta,\n\t\t\t \"invalid STA ID %d in BA notif\\n\",\n\t\t\t sta_id)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\ttid_data = &mvmsta->tid_data[tid];\n\n\tba_info.status.ampdu_ack_len = ba_notif->txed_2_done;\n\tba_info.status.ampdu_len = ba_notif->txed;\n\tba_info.status.tx_time = tid_data->tx_time;\n\tba_info.status.status_driver_data[0] =\n\t\t(void *)(uintptr_t)ba_notif->reduced_txp;\n\n\trcu_read_unlock();\n\n\tiwl_mvm_tx_reclaim(mvm, sta_id, tid, txq, index, &ba_info,\n\t\t\t   tid_data->rate_n_flags, false);\n\n\tIWL_DEBUG_TX_REPLY(mvm,\n\t\t\t   \"BA_NOTIFICATION Received from %pM, sta_id = %d\\n\",\n\t\t\t   ba_notif->sta_addr, ba_notif->sta_id);\n\n\tIWL_DEBUG_TX_REPLY(mvm,\n\t\t\t   \"TID = %d, SeqCtl = %d, bitmap = 0x%llx, scd_flow = %d, scd_ssn = %d sent:%d, acked:%d\\n\",\n\t\t\t   ba_notif->tid, le16_to_cpu(ba_notif->seq_ctl),\n\t\t\t   le64_to_cpu(ba_notif->bitmap), txq, index,\n\t\t\t   ba_notif->txed, ba_notif->txed_2_done);\n\n\tIWL_DEBUG_TX_REPLY(mvm, \"reduced txp from ba notif %d\\n\",\n\t\t\t   ba_notif->reduced_txp);\n}\n\n \nint iwl_mvm_flush_tx_path(struct iwl_mvm *mvm, u32 tfd_msk)\n{\n\tint ret;\n\tstruct iwl_tx_path_flush_cmd_v1 flush_cmd = {\n\t\t.queues_ctl = cpu_to_le32(tfd_msk),\n\t\t.flush_ctl = cpu_to_le16(DUMP_TX_FIFO_FLUSH),\n\t};\n\n\tWARN_ON(iwl_mvm_has_new_tx_api(mvm));\n\tret = iwl_mvm_send_cmd_pdu(mvm, TXPATH_FLUSH, 0,\n\t\t\t\t   sizeof(flush_cmd), &flush_cmd);\n\tif (ret)\n\t\tIWL_ERR(mvm, \"Failed to send flush command (%d)\\n\", ret);\n\treturn ret;\n}\n\nint iwl_mvm_flush_sta_tids(struct iwl_mvm *mvm, u32 sta_id, u16 tids)\n{\n\tint ret;\n\tstruct iwl_tx_path_flush_cmd_rsp *rsp;\n\tstruct iwl_tx_path_flush_cmd flush_cmd = {\n\t\t.sta_id = cpu_to_le32(sta_id),\n\t\t.tid_mask = cpu_to_le16(tids),\n\t};\n\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = TXPATH_FLUSH,\n\t\t.len = { sizeof(flush_cmd), },\n\t\t.data = { &flush_cmd, },\n\t};\n\n\tWARN_ON(!iwl_mvm_has_new_tx_api(mvm));\n\n\tif (iwl_fw_lookup_notif_ver(mvm->fw, LONG_GROUP, TXPATH_FLUSH, 0) > 0)\n\t\tcmd.flags |= CMD_WANT_SKB | CMD_SEND_IN_RFKILL;\n\n\tIWL_DEBUG_TX_QUEUES(mvm, \"flush for sta id %d tid mask 0x%x\\n\",\n\t\t\t    sta_id, tids);\n\n\tret = iwl_mvm_send_cmd(mvm, &cmd);\n\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"Failed to send flush command (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (cmd.flags & CMD_WANT_SKB) {\n\t\tint i;\n\t\tint num_flushed_queues;\n\n\t\tif (WARN_ON_ONCE(iwl_rx_packet_payload_len(cmd.resp_pkt) != sizeof(*rsp))) {\n\t\t\tret = -EIO;\n\t\t\tgoto free_rsp;\n\t\t}\n\n\t\trsp = (void *)cmd.resp_pkt->data;\n\n\t\tif (WARN_ONCE(le16_to_cpu(rsp->sta_id) != sta_id,\n\t\t\t      \"sta_id %d != rsp_sta_id %d\",\n\t\t\t      sta_id, le16_to_cpu(rsp->sta_id))) {\n\t\t\tret = -EIO;\n\t\t\tgoto free_rsp;\n\t\t}\n\n\t\tnum_flushed_queues = le16_to_cpu(rsp->num_flushed_queues);\n\t\tif (WARN_ONCE(num_flushed_queues > IWL_TX_FLUSH_QUEUE_RSP,\n\t\t\t      \"num_flushed_queues %d\", num_flushed_queues)) {\n\t\t\tret = -EIO;\n\t\t\tgoto free_rsp;\n\t\t}\n\n\t\tfor (i = 0; i < num_flushed_queues; i++) {\n\t\t\tstruct ieee80211_tx_info tx_info = {};\n\t\t\tstruct iwl_flush_queue_info *queue_info = &rsp->queues[i];\n\t\t\tint tid = le16_to_cpu(queue_info->tid);\n\t\t\tint read_before = le16_to_cpu(queue_info->read_before_flush);\n\t\t\tint read_after = le16_to_cpu(queue_info->read_after_flush);\n\t\t\tint queue_num = le16_to_cpu(queue_info->queue_num);\n\n\t\t\tif (tid == IWL_MGMT_TID)\n\t\t\t\ttid = IWL_MAX_TID_COUNT;\n\n\t\t\tIWL_DEBUG_TX_QUEUES(mvm,\n\t\t\t\t\t    \"tid %d queue_id %d read-before %d read-after %d\\n\",\n\t\t\t\t\t    tid, queue_num, read_before, read_after);\n\n\t\t\tiwl_mvm_tx_reclaim(mvm, sta_id, tid, queue_num, read_after,\n\t\t\t\t\t   &tx_info, 0, true);\n\t\t}\nfree_rsp:\n\t\tiwl_free_resp(&cmd);\n\t}\n\treturn ret;\n}\n\nint iwl_mvm_flush_sta(struct iwl_mvm *mvm, u32 sta_id, u32 tfd_queue_mask)\n{\n\tif (iwl_mvm_has_new_tx_api(mvm))\n\t\treturn iwl_mvm_flush_sta_tids(mvm, sta_id, 0xffff);\n\n\treturn iwl_mvm_flush_tx_path(mvm, tfd_queue_mask);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}