{
  "module_name": "mac-ctxt.c",
  "hash_id": "a555d20f05d3b271cb8bd6131f99ce7a4e97f7e0d8fd7647c42222ccaef0c638",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/mac-ctxt.c",
  "human_readable_source": "\n \n#include <linux/etherdevice.h>\n#include <linux/crc32.h>\n#include <net/mac80211.h>\n#include \"iwl-io.h\"\n#include \"iwl-prph.h\"\n#include \"fw-api.h\"\n#include \"mvm.h\"\n#include \"time-event.h\"\n\nconst u8 iwl_mvm_ac_to_tx_fifo[] = {\n\tIWL_MVM_TX_FIFO_VO,\n\tIWL_MVM_TX_FIFO_VI,\n\tIWL_MVM_TX_FIFO_BE,\n\tIWL_MVM_TX_FIFO_BK,\n};\n\nconst u8 iwl_mvm_ac_to_gen2_tx_fifo[] = {\n\tIWL_GEN2_EDCA_TX_FIFO_VO,\n\tIWL_GEN2_EDCA_TX_FIFO_VI,\n\tIWL_GEN2_EDCA_TX_FIFO_BE,\n\tIWL_GEN2_EDCA_TX_FIFO_BK,\n\tIWL_GEN2_TRIG_TX_FIFO_VO,\n\tIWL_GEN2_TRIG_TX_FIFO_VI,\n\tIWL_GEN2_TRIG_TX_FIFO_BE,\n\tIWL_GEN2_TRIG_TX_FIFO_BK,\n};\n\nstruct iwl_mvm_mac_iface_iterator_data {\n\tstruct iwl_mvm *mvm;\n\tstruct ieee80211_vif *vif;\n\tunsigned long available_mac_ids[BITS_TO_LONGS(NUM_MAC_INDEX_DRIVER)];\n\tunsigned long available_tsf_ids[BITS_TO_LONGS(NUM_TSF_IDS)];\n\tenum iwl_tsf_id preferred_tsf;\n\tbool found_vif;\n};\n\nstatic void iwl_mvm_mac_tsf_id_iter(void *_data, u8 *mac,\n\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_mac_iface_iterator_data *data = _data;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tu16 min_bi;\n\n\t \n\tif (vif == data->vif)\n\t\treturn;\n\n\t \n\tswitch (data->vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\t \n\t\tif (vif->type != NL80211_IFTYPE_AP ||\n\t\t    data->preferred_tsf != NUM_TSF_IDS ||\n\t\t    !test_bit(mvmvif->tsf_id, data->available_tsf_ids))\n\t\t\tbreak;\n\n\t\tmin_bi = min(data->vif->bss_conf.beacon_int,\n\t\t\t     vif->bss_conf.beacon_int);\n\n\t\tif (!min_bi)\n\t\t\tbreak;\n\n\t\tif ((data->vif->bss_conf.beacon_int -\n\t\t     vif->bss_conf.beacon_int) % min_bi == 0) {\n\t\t\tdata->preferred_tsf = mvmvif->tsf_id;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NL80211_IFTYPE_AP:\n\t\t \n\t\tif ((vif->type != NL80211_IFTYPE_AP &&\n\t\t     vif->type != NL80211_IFTYPE_STATION) ||\n\t\t    data->preferred_tsf != NUM_TSF_IDS ||\n\t\t    !test_bit(mvmvif->tsf_id, data->available_tsf_ids))\n\t\t\tbreak;\n\n\t\tmin_bi = min(data->vif->bss_conf.beacon_int,\n\t\t\t     vif->bss_conf.beacon_int);\n\n\t\tif (!min_bi)\n\t\t\tbreak;\n\n\t\tif ((data->vif->bss_conf.beacon_int -\n\t\t     vif->bss_conf.beacon_int) % min_bi == 0) {\n\t\t\tdata->preferred_tsf = mvmvif->tsf_id;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\t \n\t__clear_bit(mvmvif->tsf_id, data->available_tsf_ids);\n\n\tif (data->preferred_tsf == mvmvif->tsf_id)\n\t\tdata->preferred_tsf = NUM_TSF_IDS;\n}\n\nstatic void iwl_mvm_mac_iface_iterator(void *_data, u8 *mac,\n\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_mac_iface_iterator_data *data = _data;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\t \n\tif (vif == data->vif) {\n\t\tdata->found_vif = true;\n\t\treturn;\n\t}\n\n\t \n\t__clear_bit(mvmvif->id, data->available_mac_ids);\n\n\t \n\tiwl_mvm_mac_tsf_id_iter(_data, mac, vif);\n}\n\nvoid iwl_mvm_mac_ctxt_recalc_tsf_id(struct iwl_mvm *mvm,\n\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_mac_iface_iterator_data data = {\n\t\t.mvm = mvm,\n\t\t.vif = vif,\n\t\t.available_tsf_ids = { (1 << NUM_TSF_IDS) - 1 },\n\t\t \n\t\t.preferred_tsf = NUM_TSF_IDS,\n\t};\n\n\tieee80211_iterate_active_interfaces_atomic(\n\t\tmvm->hw, IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\tiwl_mvm_mac_tsf_id_iter, &data);\n\n\tif (data.preferred_tsf != NUM_TSF_IDS)\n\t\tmvmvif->tsf_id = data.preferred_tsf;\n\telse if (!test_bit(mvmvif->tsf_id, data.available_tsf_ids))\n\t\tmvmvif->tsf_id = find_first_bit(data.available_tsf_ids,\n\t\t\t\t\t\tNUM_TSF_IDS);\n}\n\nint iwl_mvm_mac_ctxt_init(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_mac_iface_iterator_data data = {\n\t\t.mvm = mvm,\n\t\t.vif = vif,\n\t\t.available_mac_ids = { (1 << NUM_MAC_INDEX_DRIVER) - 1 },\n\t\t.available_tsf_ids = { (1 << NUM_TSF_IDS) - 1 },\n\t\t \n\t\t.preferred_tsf = NUM_TSF_IDS,\n\t\t.found_vif = false,\n\t};\n\tint ret, i;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\t \n\n\t \n\n\t \n\tif (!mvm->mld_api_is_used) {\n\t\tswitch (vif->type) {\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\tif (!vif->p2p)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\t__clear_bit(0, data.available_mac_ids);\n\t\t}\n\t}\n\n\tieee80211_iterate_active_interfaces_atomic(\n\t\tmvm->hw, IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\tiwl_mvm_mac_iface_iterator, &data);\n\n\t \n\tif (data.found_vif)\n\t\treturn 0;\n\n\t \n\tif (WARN_ON_ONCE(test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status)))\n\t\treturn -EBUSY;\n\n\tmvmvif->id = find_first_bit(data.available_mac_ids,\n\t\t\t\t    NUM_MAC_INDEX_DRIVER);\n\tif (mvmvif->id == NUM_MAC_INDEX_DRIVER) {\n\t\tIWL_ERR(mvm, \"Failed to init MAC context - no free ID!\\n\");\n\t\tret = -EIO;\n\t\tgoto exit_fail;\n\t}\n\n\tif (data.preferred_tsf != NUM_TSF_IDS)\n\t\tmvmvif->tsf_id = data.preferred_tsf;\n\telse\n\t\tmvmvif->tsf_id = find_first_bit(data.available_tsf_ids,\n\t\t\t\t\t\tNUM_TSF_IDS);\n\tif (mvmvif->tsf_id == NUM_TSF_IDS) {\n\t\tIWL_ERR(mvm, \"Failed to init MAC context - no free TSF!\\n\");\n\t\tret = -EIO;\n\t\tgoto exit_fail;\n\t}\n\n\tmvmvif->color = 0;\n\n\tINIT_LIST_HEAD(&mvmvif->time_event_data.list);\n\tmvmvif->time_event_data.id = TE_MAX;\n\n\tmvmvif->deflink.bcast_sta.sta_id = IWL_MVM_INVALID_STA;\n\tmvmvif->deflink.mcast_sta.sta_id = IWL_MVM_INVALID_STA;\n\tmvmvif->deflink.ap_sta_id = IWL_MVM_INVALID_STA;\n\n\t \n\tif (vif->type == NL80211_IFTYPE_P2P_DEVICE)\n\t\treturn 0;\n\n\t \n\tif (vif->type == NL80211_IFTYPE_AP ||\n\t    vif->type == NL80211_IFTYPE_ADHOC) {\n\t\t \n\t\tmvmvif->deflink.cab_queue = IWL_MVM_DQA_GCAST_QUEUE;\n\t}\n\n\tfor (i = 0; i < NUM_IWL_MVM_SMPS_REQ; i++)\n\t\tmvmvif->deflink.smps_requests[i] = IEEE80211_SMPS_AUTOMATIC;\n\n\treturn 0;\n\nexit_fail:\n\tmemset(mvmvif, 0, sizeof(struct iwl_mvm_vif));\n\treturn ret;\n}\n\nstatic void iwl_mvm_ack_rates(struct iwl_mvm *mvm,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      enum nl80211_band band,\n\t\t\t      u8 *cck_rates, u8 *ofdm_rates)\n{\n\tstruct ieee80211_supported_band *sband;\n\tunsigned long basic = vif->bss_conf.basic_rates;\n\tint lowest_present_ofdm = 100;\n\tint lowest_present_cck = 100;\n\tu8 cck = 0;\n\tu8 ofdm = 0;\n\tint i;\n\n\tsband = mvm->hw->wiphy->bands[band];\n\n\tfor_each_set_bit(i, &basic, BITS_PER_LONG) {\n\t\tint hw = sband->bitrates[i].hw_value;\n\t\tif (hw >= IWL_FIRST_OFDM_RATE) {\n\t\t\tofdm |= BIT(hw - IWL_FIRST_OFDM_RATE);\n\t\t\tif (lowest_present_ofdm > hw)\n\t\t\t\tlowest_present_ofdm = hw;\n\t\t} else {\n\t\t\tBUILD_BUG_ON(IWL_FIRST_CCK_RATE != 0);\n\n\t\t\tcck |= BIT(hw);\n\t\t\tif (lowest_present_cck > hw)\n\t\t\t\tlowest_present_cck = hw;\n\t\t}\n\t}\n\n\t \n\n\tif (IWL_RATE_24M_INDEX < lowest_present_ofdm)\n\t\tofdm |= IWL_RATE_BIT_MSK(24) >> IWL_FIRST_OFDM_RATE;\n\tif (IWL_RATE_12M_INDEX < lowest_present_ofdm)\n\t\tofdm |= IWL_RATE_BIT_MSK(12) >> IWL_FIRST_OFDM_RATE;\n\t \n\tofdm |= IWL_RATE_BIT_MSK(6) >> IWL_FIRST_OFDM_RATE;\n\n\t \n\tif (IWL_RATE_11M_INDEX < lowest_present_cck)\n\t\tcck |= IWL_RATE_BIT_MSK(11) >> IWL_FIRST_CCK_RATE;\n\tif (IWL_RATE_5M_INDEX < lowest_present_cck)\n\t\tcck |= IWL_RATE_BIT_MSK(5) >> IWL_FIRST_CCK_RATE;\n\tif (IWL_RATE_2M_INDEX < lowest_present_cck)\n\t\tcck |= IWL_RATE_BIT_MSK(2) >> IWL_FIRST_CCK_RATE;\n\t \n\tcck |= IWL_RATE_BIT_MSK(1) >> IWL_FIRST_CCK_RATE;\n\n\t*cck_rates = cck;\n\t*ofdm_rates = ofdm;\n}\n\nvoid iwl_mvm_set_fw_basic_rates(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_bss_conf *link_conf,\n\t\t\t\t__le32 *cck_rates, __le32 *ofdm_rates)\n{\n\tstruct ieee80211_chanctx_conf *chanctx;\n\tu8 cck_ack_rates = 0, ofdm_ack_rates = 0;\n\n\trcu_read_lock();\n\tchanctx = rcu_dereference(link_conf->chanctx_conf);\n\tiwl_mvm_ack_rates(mvm, vif, chanctx ? chanctx->def.chan->band\n\t\t\t\t\t    : NL80211_BAND_2GHZ,\n\t\t\t  &cck_ack_rates, &ofdm_ack_rates);\n\n\trcu_read_unlock();\n\n\t*cck_rates = cpu_to_le32((u32)cck_ack_rates);\n\t*ofdm_rates = cpu_to_le32((u32)ofdm_ack_rates);\n}\n\nvoid iwl_mvm_set_fw_protection_flags(struct iwl_mvm *mvm,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_bss_conf *link_conf,\n\t\t\t\t     __le32 *protection_flags, u32 ht_flag,\n\t\t\t\t     u32 tgg_flag)\n{\n\t \n\tu8 protection_mode = link_conf->ht_operation_mode &\n\t\t\t\t IEEE80211_HT_OP_MODE_PROTECTION;\n\tbool ht_enabled = !!(link_conf->ht_operation_mode &\n\t\t\t     IEEE80211_HT_OP_MODE_PROTECTION);\n\n\tif (link_conf->use_cts_prot)\n\t\t*protection_flags |= cpu_to_le32(tgg_flag);\n\n\tIWL_DEBUG_RATE(mvm, \"use_cts_prot %d, ht_operation_mode %d\\n\",\n\t\t       link_conf->use_cts_prot,\n\t\t       link_conf->ht_operation_mode);\n\n\tif (!ht_enabled)\n\t\treturn;\n\n\tIWL_DEBUG_RATE(mvm, \"protection mode set to %d\\n\", protection_mode);\n\t \n\tswitch (protection_mode) {\n\tcase IEEE80211_HT_OP_MODE_PROTECTION_NONE:\n\t\tbreak;\n\tcase IEEE80211_HT_OP_MODE_PROTECTION_NONMEMBER:\n\tcase IEEE80211_HT_OP_MODE_PROTECTION_NONHT_MIXED:\n\t\t*protection_flags |= cpu_to_le32(ht_flag);\n\t\tbreak;\n\tcase IEEE80211_HT_OP_MODE_PROTECTION_20MHZ:\n\t\t \n\t\tif (link_conf->chandef.width > NL80211_CHAN_WIDTH_20)\n\t\t\t*protection_flags |= cpu_to_le32(ht_flag);\n\t\tbreak;\n\tdefault:\n\t\tIWL_ERR(mvm, \"Illegal protection mode %d\\n\",\n\t\t\tprotection_mode);\n\t\tbreak;\n\t}\n}\n\nvoid iwl_mvm_set_fw_qos_params(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_bss_conf *link_conf,\n\t\t\t       struct iwl_ac_qos *ac, __le32 *qos_flags)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_vif_link_info *mvm_link =\n\t\tmvmvif->link[link_conf->link_id];\n\tint i;\n\n\tif (!mvm_link)\n\t\treturn;\n\n\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\tu8 txf = iwl_mvm_mac_ac_to_tx_fifo(mvm, i);\n\t\tu8 ucode_ac = iwl_mvm_mac80211_ac_to_ucode_ac(i);\n\n\t\tac[ucode_ac].cw_min =\n\t\t\tcpu_to_le16(mvm_link->queue_params[i].cw_min);\n\t\tac[ucode_ac].cw_max =\n\t\t\tcpu_to_le16(mvm_link->queue_params[i].cw_max);\n\t\tac[ucode_ac].edca_txop =\n\t\t\tcpu_to_le16(mvm_link->queue_params[i].txop * 32);\n\t\tac[ucode_ac].aifsn = mvm_link->queue_params[i].aifs;\n\t\tac[ucode_ac].fifos_mask = BIT(txf);\n\t}\n\n\tif (link_conf->qos)\n\t\t*qos_flags |= cpu_to_le32(MAC_QOS_FLG_UPDATE_EDCA);\n\n\tif (link_conf->chandef.width != NL80211_CHAN_WIDTH_20_NOHT)\n\t\t*qos_flags |= cpu_to_le32(MAC_QOS_FLG_TGN);\n}\n\nint iwl_mvm_get_mac_type(struct ieee80211_vif *vif)\n{\n\tu32 mac_type = FW_MAC_TYPE_BSS_STA;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (vif->p2p)\n\t\t\tmac_type = FW_MAC_TYPE_P2P_STA;\n\t\telse\n\t\t\tmac_type = FW_MAC_TYPE_BSS_STA;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tmac_type = FW_MAC_TYPE_GO;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tmac_type = FW_MAC_TYPE_LISTENER;\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tmac_type = FW_MAC_TYPE_P2P_DEVICE;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tmac_type = FW_MAC_TYPE_IBSS;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\treturn mac_type;\n}\n\nstatic void iwl_mvm_mac_ctxt_cmd_common(struct iwl_mvm *mvm,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tstruct iwl_mac_ctx_cmd *cmd,\n\t\t\t\t\tconst u8 *bssid_override,\n\t\t\t\t\tu32 action)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tconst u8 *bssid = bssid_override ?: vif->bss_conf.bssid;\n\tu32 ht_flag;\n\n\tcmd->id_and_color = cpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id,\n\t\t\t\t\t\t\t    mvmvif->color));\n\tcmd->action = cpu_to_le32(action);\n\tcmd->mac_type = cpu_to_le32(iwl_mvm_get_mac_type(vif));\n\n\tcmd->tsf_id = cpu_to_le32(mvmvif->tsf_id);\n\n\tmemcpy(cmd->node_addr, vif->addr, ETH_ALEN);\n\n\tif (bssid)\n\t\tmemcpy(cmd->bssid_addr, bssid, ETH_ALEN);\n\telse\n\t\teth_broadcast_addr(cmd->bssid_addr);\n\n\tiwl_mvm_set_fw_basic_rates(mvm, vif, &vif->bss_conf, &cmd->cck_rates,\n\t\t\t\t   &cmd->ofdm_rates);\n\n\tcmd->cck_short_preamble =\n\t\tcpu_to_le32(vif->bss_conf.use_short_preamble ?\n\t\t\t    MAC_FLG_SHORT_PREAMBLE : 0);\n\tcmd->short_slot =\n\t\tcpu_to_le32(vif->bss_conf.use_short_slot ?\n\t\t\t    MAC_FLG_SHORT_SLOT : 0);\n\n\tcmd->filter_flags = 0;\n\n\tiwl_mvm_set_fw_qos_params(mvm, vif, &vif->bss_conf, cmd->ac,\n\t\t\t\t  &cmd->qos_flags);\n\n\t \n\tht_flag = MAC_PROT_FLG_HT_PROT | MAC_PROT_FLG_FAT_PROT;\n\tiwl_mvm_set_fw_protection_flags(mvm, vif, &vif->bss_conf,\n\t\t\t\t\t&cmd->protection_flags,\n\t\t\t\t\tht_flag, MAC_PROT_FLG_TGG_PROTECT);\n}\n\nstatic int iwl_mvm_mac_ctxt_send_cmd(struct iwl_mvm *mvm,\n\t\t\t\t     struct iwl_mac_ctx_cmd *cmd)\n{\n\tint ret = iwl_mvm_send_cmd_pdu(mvm, MAC_CONTEXT_CMD, 0,\n\t\t\t\t       sizeof(*cmd), cmd);\n\tif (ret)\n\t\tIWL_ERR(mvm, \"Failed to send MAC_CONTEXT_CMD (action:%d): %d\\n\",\n\t\t\tle32_to_cpu(cmd->action), ret);\n\treturn ret;\n}\n\nvoid iwl_mvm_set_fw_dtim_tbtt(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_bss_conf *link_conf,\n\t\t\t      __le64 *dtim_tsf, __le32 *dtim_time,\n\t\t\t      __le32 *assoc_beacon_arrive_time)\n{\n\tu32 dtim_offs;\n\n\t \n\tdtim_offs = link_conf->sync_dtim_count *\n\t\t\tlink_conf->beacon_int;\n\t \n\tdtim_offs *= 1024;\n\n\t*dtim_tsf =\n\t\tcpu_to_le64(link_conf->sync_tsf + dtim_offs);\n\t*dtim_time =\n\t\tcpu_to_le32(link_conf->sync_device_ts + dtim_offs);\n\t*assoc_beacon_arrive_time =\n\t\tcpu_to_le32(link_conf->sync_device_ts);\n\n\tIWL_DEBUG_INFO(mvm, \"DTIM TBTT is 0x%llx/0x%x, offset %d\\n\",\n\t\t       le64_to_cpu(*dtim_tsf),\n\t\t       le32_to_cpu(*dtim_time),\n\t\t       dtim_offs);\n}\n\n__le32 iwl_mvm_mac_ctxt_cmd_p2p_sta_get_oppps_ctwin(struct iwl_mvm *mvm,\n\t\t\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_p2p_noa_attr *noa =\n\t\t&vif->bss_conf.p2p_noa_attr;\n\n\treturn cpu_to_le32(noa->oppps_ctwindow &\n\t\t\tIEEE80211_P2P_OPPPS_CTWINDOW_MASK);\n}\n\nu32 iwl_mvm_mac_ctxt_cmd_sta_get_twt_policy(struct iwl_mvm *mvm,\n\t\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tu32 twt_policy = 0;\n\n\tif (vif->bss_conf.twt_requester && IWL_MVM_USE_TWT)\n\t\ttwt_policy |= TWT_SUPPORTED;\n\tif (vif->bss_conf.twt_protected)\n\t\ttwt_policy |= PROTECTED_TWT_SUPPORTED;\n\tif (vif->bss_conf.twt_broadcast)\n\t\ttwt_policy |= BROADCAST_TWT_SUPPORTED;\n\n\treturn twt_policy;\n}\n\nstatic int iwl_mvm_mac_ctxt_cmd_sta(struct iwl_mvm *mvm,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    u32 action, bool force_assoc_off,\n\t\t\t\t    const u8 *bssid_override)\n{\n\tstruct iwl_mac_ctx_cmd cmd = {};\n\tstruct iwl_mac_data_sta *ctxt_sta;\n\n\tWARN_ON(vif->type != NL80211_IFTYPE_STATION);\n\n\t \n\tiwl_mvm_mac_ctxt_cmd_common(mvm, vif, &cmd, bssid_override, action);\n\n\t \n\tcmd.filter_flags |= cpu_to_le32(MAC_FILTER_ACCEPT_GRP);\n\n\tif (vif->p2p) {\n\t\tcmd.p2p_sta.ctwin =\n\t\t\tiwl_mvm_mac_ctxt_cmd_p2p_sta_get_oppps_ctwin(mvm, vif);\n\n\t\tctxt_sta = &cmd.p2p_sta.sta;\n\t} else {\n\t\tctxt_sta = &cmd.sta;\n\t}\n\n\t \n\tif (vif->cfg.assoc && vif->bss_conf.dtim_period &&\n\t    !force_assoc_off) {\n\t\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\t\tiwl_mvm_set_fw_dtim_tbtt(mvm, vif, &vif->bss_conf,\n\t\t\t\t\t &ctxt_sta->dtim_tsf,\n\t\t\t\t\t &ctxt_sta->dtim_time,\n\t\t\t\t\t &ctxt_sta->assoc_beacon_arrive_time);\n\n\t\tctxt_sta->is_assoc = cpu_to_le32(1);\n\n\t\tif (!mvmvif->authorized &&\n\t\t    fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t\tIWL_UCODE_TLV_CAPA_COEX_HIGH_PRIO))\n\t\t\tctxt_sta->data_policy |=\n\t\t\t\tcpu_to_le32(COEX_HIGH_PRIORITY_ENABLE);\n\t} else {\n\t\tctxt_sta->is_assoc = cpu_to_le32(0);\n\n\t\t \n\t\tcmd.filter_flags |= cpu_to_le32(MAC_FILTER_IN_BEACON);\n\t}\n\n\tctxt_sta->bi = cpu_to_le32(vif->bss_conf.beacon_int);\n\tctxt_sta->dtim_interval = cpu_to_le32(vif->bss_conf.beacon_int *\n\t\t\t\t\t      vif->bss_conf.dtim_period);\n\n\tctxt_sta->listen_interval = cpu_to_le32(mvm->hw->conf.listen_interval);\n\tctxt_sta->assoc_id = cpu_to_le32(vif->cfg.aid);\n\n\tif (vif->probe_req_reg && vif->cfg.assoc && vif->p2p)\n\t\tcmd.filter_flags |= cpu_to_le32(MAC_FILTER_IN_PROBE_REQUEST);\n\n\tif (vif->bss_conf.he_support && !iwlwifi_mod_params.disable_11ax) {\n\t\tcmd.filter_flags |= cpu_to_le32(MAC_FILTER_IN_11AX);\n\t\tctxt_sta->data_policy |=\n\t\t\tcpu_to_le32(iwl_mvm_mac_ctxt_cmd_sta_get_twt_policy(mvm, vif));\n\t}\n\n\n\treturn iwl_mvm_mac_ctxt_send_cmd(mvm, &cmd);\n}\n\nstatic int iwl_mvm_mac_ctxt_cmd_listener(struct iwl_mvm *mvm,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t u32 action)\n{\n\tstruct iwl_mac_ctx_cmd cmd = {};\n\tu32 tfd_queue_msk = 0;\n\tint ret;\n\n\tWARN_ON(vif->type != NL80211_IFTYPE_MONITOR);\n\n\tiwl_mvm_mac_ctxt_cmd_common(mvm, vif, &cmd, NULL, action);\n\n\tcmd.filter_flags = cpu_to_le32(MAC_FILTER_IN_PROMISC |\n\t\t\t\t       MAC_FILTER_IN_CONTROL_AND_MGMT |\n\t\t\t\t       MAC_FILTER_IN_BEACON |\n\t\t\t\t       MAC_FILTER_IN_PROBE_REQUEST |\n\t\t\t\t       MAC_FILTER_IN_CRC32 |\n\t\t\t\t       MAC_FILTER_ACCEPT_GRP);\n\tieee80211_hw_set(mvm->hw, RX_INCLUDES_FCS);\n\n\t \n\tif (!iwl_mvm_has_new_tx_api(mvm))\n\t\ttfd_queue_msk = BIT(mvm->snif_queue);\n\n\t \n\tret = iwl_mvm_allocate_int_sta(mvm, &mvm->snif_sta, tfd_queue_msk,\n\t\t\t\t       vif->type, IWL_STA_GENERAL_PURPOSE);\n\tif (ret)\n\t\treturn ret;\n\n\treturn iwl_mvm_mac_ctxt_send_cmd(mvm, &cmd);\n}\n\nstatic int iwl_mvm_mac_ctxt_cmd_ibss(struct iwl_mvm *mvm,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     u32 action)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mac_ctx_cmd cmd = {};\n\n\tWARN_ON(vif->type != NL80211_IFTYPE_ADHOC);\n\n\tiwl_mvm_mac_ctxt_cmd_common(mvm, vif, &cmd, NULL, action);\n\n\tcmd.filter_flags = cpu_to_le32(MAC_FILTER_IN_BEACON |\n\t\t\t\t       MAC_FILTER_IN_PROBE_REQUEST |\n\t\t\t\t       MAC_FILTER_ACCEPT_GRP);\n\n\t \n\tcmd.ibss.bi = cpu_to_le32(vif->bss_conf.beacon_int);\n\n\t \n\tcmd.ibss.beacon_template = cpu_to_le32(mvmvif->id);\n\n\treturn iwl_mvm_mac_ctxt_send_cmd(mvm, &cmd);\n}\n\nstruct iwl_mvm_go_iterator_data {\n\tbool go_active;\n};\n\nstatic void iwl_mvm_go_iterator(void *_data, u8 *mac, struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_go_iterator_data *data = _data;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tif (vif->type == NL80211_IFTYPE_AP && vif->p2p &&\n\t    mvmvif->ap_ibss_active)\n\t\tdata->go_active = true;\n}\n\n__le32 iwl_mac_ctxt_p2p_dev_has_extended_disc(struct iwl_mvm *mvm,\n\t\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_go_iterator_data data = {};\n\n\t \n\tieee80211_iterate_active_interfaces_atomic(\n\t\tmvm->hw, IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\tiwl_mvm_go_iterator, &data);\n\n\treturn cpu_to_le32(data.go_active ? 1 : 0);\n}\n\nstatic int iwl_mvm_mac_ctxt_cmd_p2p_device(struct iwl_mvm *mvm,\n\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t   u32 action)\n{\n\tstruct iwl_mac_ctx_cmd cmd = {};\n\n\tWARN_ON(vif->type != NL80211_IFTYPE_P2P_DEVICE);\n\n\tiwl_mvm_mac_ctxt_cmd_common(mvm, vif, &cmd, NULL, action);\n\n\tcmd.p2p_dev.is_disc_extended =\n\t\tiwl_mac_ctxt_p2p_dev_has_extended_disc(mvm, vif);\n\n\t \n\tcmd.filter_flags = cpu_to_le32(MAC_FILTER_IN_PROBE_REQUEST);\n\n\treturn iwl_mvm_mac_ctxt_send_cmd(mvm, &cmd);\n}\n\nvoid iwl_mvm_mac_ctxt_set_tim(struct iwl_mvm *mvm,\n\t\t\t      __le32 *tim_index, __le32 *tim_size,\n\t\t\t      u8 *beacon, u32 frame_size)\n{\n\tu32 tim_idx;\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)beacon;\n\n\t \n\ttim_idx = mgmt->u.beacon.variable - beacon;\n\n\t \n\twhile ((tim_idx < (frame_size - 2)) &&\n\t\t\t(beacon[tim_idx] != WLAN_EID_TIM))\n\t\ttim_idx += beacon[tim_idx+1] + 2;\n\n\t \n\tif ((tim_idx < (frame_size - 1)) && (beacon[tim_idx] == WLAN_EID_TIM)) {\n\t\t*tim_index = cpu_to_le32(tim_idx);\n\t\t*tim_size = cpu_to_le32((u32)beacon[tim_idx + 1]);\n\t} else {\n\t\tIWL_WARN(mvm, \"Unable to find TIM Element in beacon\\n\");\n\t}\n}\n\nstatic u32 iwl_mvm_find_ie_offset(u8 *beacon, u8 eid, u32 frame_size)\n{\n\tstruct ieee80211_mgmt *mgmt = (void *)beacon;\n\tconst u8 *ie;\n\n\tif (WARN_ON_ONCE(frame_size <= (mgmt->u.beacon.variable - beacon)))\n\t\treturn 0;\n\n\tframe_size -= mgmt->u.beacon.variable - beacon;\n\n\tie = cfg80211_find_ie(eid, mgmt->u.beacon.variable, frame_size);\n\tif (!ie)\n\t\treturn 0;\n\n\treturn ie - beacon;\n}\n\nu8 iwl_mvm_mac_ctxt_get_lowest_rate(struct iwl_mvm *mvm,\n\t\t\t\t    struct ieee80211_tx_info *info,\n\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct ieee80211_supported_band *sband;\n\tunsigned long basic = vif->bss_conf.basic_rates;\n\tu16 lowest_cck = IWL_RATE_COUNT, lowest_ofdm = IWL_RATE_COUNT;\n\tu32 link_id = u32_get_bits(info->control.flags,\n\t\t\t\t   IEEE80211_TX_CTRL_MLO_LINK);\n\tu8 band = info->band;\n\tu8 rate;\n\tu32 i;\n\n\tif (link_id == IEEE80211_LINK_UNSPECIFIED && ieee80211_vif_is_mld(vif)) {\n\t\tfor (i = 0; i < ARRAY_SIZE(mvmvif->link); i++) {\n\t\t\tif (!mvmvif->link[i])\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tWARN_ON_ONCE(link_id != IEEE80211_LINK_UNSPECIFIED);\n\t\t\tlink_id = i;\n\t\t}\n\t}\n\n\tif (link_id < IEEE80211_LINK_UNSPECIFIED) {\n\t\tstruct ieee80211_bss_conf *link_conf;\n\n\t\trcu_read_lock();\n\t\tlink_conf = rcu_dereference(vif->link_conf[link_id]);\n\t\tif (link_conf) {\n\t\t\tbasic = link_conf->basic_rates;\n\t\t\tif (link_conf->chandef.chan)\n\t\t\t\tband = link_conf->chandef.chan->band;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tsband = mvm->hw->wiphy->bands[band];\n\tfor_each_set_bit(i, &basic, BITS_PER_LONG) {\n\t\tu16 hw = sband->bitrates[i].hw_value;\n\n\t\tif (hw >= IWL_FIRST_OFDM_RATE) {\n\t\t\tif (lowest_ofdm > hw)\n\t\t\t\tlowest_ofdm = hw;\n\t\t} else if (lowest_cck > hw) {\n\t\t\tlowest_cck = hw;\n\t\t}\n\t}\n\n\tif (band == NL80211_BAND_2GHZ && !vif->p2p &&\n\t    vif->type != NL80211_IFTYPE_P2P_DEVICE &&\n\t    !(info->flags & IEEE80211_TX_CTL_NO_CCK_RATE)) {\n\t\tif (lowest_cck != IWL_RATE_COUNT)\n\t\t\trate = lowest_cck;\n\t\telse if (lowest_ofdm != IWL_RATE_COUNT)\n\t\t\trate = lowest_ofdm;\n\t\telse\n\t\t\trate = IWL_RATE_1M_INDEX;\n\t} else if (lowest_ofdm != IWL_RATE_COUNT) {\n\t\trate = lowest_ofdm;\n\t} else {\n\t\trate = IWL_RATE_6M_INDEX;\n\t}\n\n\treturn rate;\n}\n\nu16 iwl_mvm_mac_ctxt_get_beacon_flags(const struct iwl_fw *fw, u8 rate_idx)\n{\n\tu16 flags = iwl_mvm_mac80211_idx_to_hwrate(fw, rate_idx);\n\tbool is_new_rate = iwl_fw_lookup_cmd_ver(fw, BEACON_TEMPLATE_CMD, 0) > 10;\n\n\tif (rate_idx <= IWL_FIRST_CCK_RATE)\n\t\tflags |= is_new_rate ? IWL_MAC_BEACON_CCK\n\t\t\t  : IWL_MAC_BEACON_CCK_V1;\n\n\treturn flags;\n}\n\nu8 iwl_mvm_mac_ctxt_get_beacon_rate(struct iwl_mvm *mvm,\n\t\t\t\t    struct ieee80211_tx_info *info,\n\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_supported_band *sband =\n\t\tmvm->hw->wiphy->bands[info->band];\n\tu32 legacy = vif->bss_conf.beacon_tx_rate.control[info->band].legacy;\n\n\t \n\tif (hweight32(legacy) == 1) {\n\t\tu32 rate = ffs(legacy) - 1;\n\n\t\treturn sband->bitrates[rate].hw_value;\n\t}\n\n\treturn iwl_mvm_mac_ctxt_get_lowest_rate(mvm, info, vif);\n}\n\nstatic void iwl_mvm_mac_ctxt_set_tx(struct iwl_mvm *mvm,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct sk_buff *beacon,\n\t\t\t\t    struct iwl_tx_cmd *tx)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct ieee80211_tx_info *info;\n\tu8 rate;\n\tu32 tx_flags;\n\n\tinfo = IEEE80211_SKB_CB(beacon);\n\n\t \n\ttx->len = cpu_to_le16((u16)beacon->len);\n\ttx->sta_id = mvmvif->deflink.bcast_sta.sta_id;\n\ttx->life_time = cpu_to_le32(TX_CMD_LIFE_TIME_INFINITE);\n\ttx_flags = TX_CMD_FLG_SEQ_CTL | TX_CMD_FLG_TSF;\n\ttx_flags |=\n\t\tiwl_mvm_bt_coex_tx_prio(mvm, (void *)beacon->data, info, 0) <<\n\t\t\t\t\t\tTX_CMD_FLG_BT_PRIO_POS;\n\ttx->tx_flags = cpu_to_le32(tx_flags);\n\n\tif (!fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t IWL_UCODE_TLV_CAPA_BEACON_ANT_SELECTION))\n\t\tiwl_mvm_toggle_tx_ant(mvm, &mvm->mgmt_last_antenna_idx);\n\n\ttx->rate_n_flags =\n\t\tcpu_to_le32(BIT(mvm->mgmt_last_antenna_idx) <<\n\t\t\t    RATE_MCS_ANT_POS);\n\n\trate = iwl_mvm_mac_ctxt_get_beacon_rate(mvm, info, vif);\n\n\ttx->rate_n_flags |=\n\t\tcpu_to_le32(iwl_mvm_mac80211_idx_to_hwrate(mvm->fw, rate));\n\tif (rate == IWL_FIRST_CCK_RATE)\n\t\ttx->rate_n_flags |= cpu_to_le32(RATE_MCS_CCK_MSK_V1);\n\n}\n\nint iwl_mvm_mac_ctxt_send_beacon_cmd(struct iwl_mvm *mvm,\n\t\t\t\t     struct sk_buff *beacon,\n\t\t\t\t     void *data, int len)\n{\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = BEACON_TEMPLATE_CMD,\n\t\t.flags = CMD_ASYNC,\n\t};\n\n\tcmd.len[0] = len;\n\tcmd.data[0] = data;\n\tcmd.dataflags[0] = 0;\n\tcmd.len[1] = beacon->len;\n\tcmd.data[1] = beacon->data;\n\tcmd.dataflags[1] = IWL_HCMD_DFL_DUP;\n\n\treturn iwl_mvm_send_cmd(mvm, &cmd);\n}\n\nstatic int iwl_mvm_mac_ctxt_send_beacon_v6(struct iwl_mvm *mvm,\n\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t   struct sk_buff *beacon)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mac_beacon_cmd_v6 beacon_cmd = {};\n\n\tiwl_mvm_mac_ctxt_set_tx(mvm, vif, beacon, &beacon_cmd.tx);\n\n\tbeacon_cmd.template_id = cpu_to_le32((u32)mvmvif->id);\n\n\tif (vif->type == NL80211_IFTYPE_AP)\n\t\tiwl_mvm_mac_ctxt_set_tim(mvm, &beacon_cmd.tim_idx,\n\t\t\t\t\t &beacon_cmd.tim_size,\n\t\t\t\t\t beacon->data, beacon->len);\n\n\treturn iwl_mvm_mac_ctxt_send_beacon_cmd(mvm, beacon, &beacon_cmd,\n\t\t\t\t\t\tsizeof(beacon_cmd));\n}\n\nstatic int iwl_mvm_mac_ctxt_send_beacon_v7(struct iwl_mvm *mvm,\n\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t   struct sk_buff *beacon)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mac_beacon_cmd_v7 beacon_cmd = {};\n\n\tiwl_mvm_mac_ctxt_set_tx(mvm, vif, beacon, &beacon_cmd.tx);\n\n\tbeacon_cmd.template_id = cpu_to_le32((u32)mvmvif->id);\n\n\tif (vif->type == NL80211_IFTYPE_AP)\n\t\tiwl_mvm_mac_ctxt_set_tim(mvm, &beacon_cmd.tim_idx,\n\t\t\t\t\t &beacon_cmd.tim_size,\n\t\t\t\t\t beacon->data, beacon->len);\n\n\tbeacon_cmd.csa_offset =\n\t\tcpu_to_le32(iwl_mvm_find_ie_offset(beacon->data,\n\t\t\t\t\t\t   WLAN_EID_CHANNEL_SWITCH,\n\t\t\t\t\t\t   beacon->len));\n\tbeacon_cmd.ecsa_offset =\n\t\tcpu_to_le32(iwl_mvm_find_ie_offset(beacon->data,\n\t\t\t\t\t\t   WLAN_EID_EXT_CHANSWITCH_ANN,\n\t\t\t\t\t\t   beacon->len));\n\n\treturn iwl_mvm_mac_ctxt_send_beacon_cmd(mvm, beacon, &beacon_cmd,\n\t\t\t\t\t\tsizeof(beacon_cmd));\n}\n\nstatic int iwl_mvm_mac_ctxt_send_beacon_v9(struct iwl_mvm *mvm,\n\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t   struct sk_buff *beacon,\n\t\t\t\t\t   struct ieee80211_bss_conf *link_conf)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(beacon);\n\tstruct iwl_mac_beacon_cmd beacon_cmd = {};\n\tu8 rate = iwl_mvm_mac_ctxt_get_beacon_rate(mvm, info, vif);\n\tu16 flags;\n\tstruct ieee80211_chanctx_conf *ctx;\n\tint channel;\n\tflags = iwl_mvm_mac_ctxt_get_beacon_flags(mvm->fw, rate);\n\n\t \n\trcu_read_lock();\n\tctx = rcu_dereference(link_conf->chanctx_conf);\n\tchannel = ieee80211_frequency_to_channel(ctx->def.chan->center_freq);\n\tWARN_ON(channel == 0);\n\tif (cfg80211_channel_is_psc(ctx->def.chan) &&\n\t    !IWL_MVM_DISABLE_AP_FILS) {\n\t\tflags |= iwl_fw_lookup_cmd_ver(mvm->fw, BEACON_TEMPLATE_CMD,\n\t\t\t\t\t       0) > 10 ?\n\t\t\tIWL_MAC_BEACON_FILS :\n\t\t\tIWL_MAC_BEACON_FILS_V1;\n\t\tbeacon_cmd.short_ssid =\n\t\t\tcpu_to_le32(~crc32_le(~0, vif->cfg.ssid,\n\t\t\t\t\t      vif->cfg.ssid_len));\n\t}\n\trcu_read_unlock();\n\n\tbeacon_cmd.flags = cpu_to_le16(flags);\n\tbeacon_cmd.byte_cnt = cpu_to_le16((u16)beacon->len);\n\n\tif (WARN_ON(!mvmvif->link[link_conf->link_id]))\n\t\treturn -EINVAL;\n\n\tif (iwl_fw_lookup_cmd_ver(mvm->fw, BEACON_TEMPLATE_CMD, 0) > 12)\n\t\tbeacon_cmd.link_id =\n\t\t\tcpu_to_le32(mvmvif->link[link_conf->link_id]->fw_link_id);\n\telse\n\t\tbeacon_cmd.link_id = cpu_to_le32((u32)mvmvif->id);\n\n\tif (vif->type == NL80211_IFTYPE_AP)\n\t\tiwl_mvm_mac_ctxt_set_tim(mvm, &beacon_cmd.tim_idx,\n\t\t\t\t\t &beacon_cmd.tim_size,\n\t\t\t\t\t beacon->data, beacon->len);\n\n\tbeacon_cmd.csa_offset =\n\t\tcpu_to_le32(iwl_mvm_find_ie_offset(beacon->data,\n\t\t\t\t\t\t   WLAN_EID_CHANNEL_SWITCH,\n\t\t\t\t\t\t   beacon->len));\n\tbeacon_cmd.ecsa_offset =\n\t\tcpu_to_le32(iwl_mvm_find_ie_offset(beacon->data,\n\t\t\t\t\t\t   WLAN_EID_EXT_CHANSWITCH_ANN,\n\t\t\t\t\t\t   beacon->len));\n\n\treturn iwl_mvm_mac_ctxt_send_beacon_cmd(mvm, beacon, &beacon_cmd,\n\t\t\t\t\t\tsizeof(beacon_cmd));\n}\n\nstatic int iwl_mvm_mac_ctxt_send_beacon(struct iwl_mvm *mvm,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tstruct sk_buff *beacon,\n\t\t\t\t\tstruct ieee80211_bss_conf *link_conf)\n{\n\tif (WARN_ON(!beacon))\n\t\treturn -EINVAL;\n\n\tif (IWL_MVM_NON_TRANSMITTING_AP)\n\t\treturn 0;\n\n\tif (!fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t IWL_UCODE_TLV_CAPA_CSA_AND_TBTT_OFFLOAD))\n\t\treturn iwl_mvm_mac_ctxt_send_beacon_v6(mvm, vif, beacon);\n\n\tif (fw_has_api(&mvm->fw->ucode_capa,\n\t\t       IWL_UCODE_TLV_API_NEW_BEACON_TEMPLATE))\n\t\treturn iwl_mvm_mac_ctxt_send_beacon_v9(mvm, vif, beacon,\n\t\t\t\t\t\t       link_conf);\n\n\treturn iwl_mvm_mac_ctxt_send_beacon_v7(mvm, vif, beacon);\n}\n\n \nint iwl_mvm_mac_ctxt_beacon_changed(struct iwl_mvm *mvm,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_bss_conf *link_conf)\n{\n\tstruct sk_buff *beacon;\n\tint ret;\n\n\tWARN_ON(vif->type != NL80211_IFTYPE_AP &&\n\t\tvif->type != NL80211_IFTYPE_ADHOC);\n\n\tbeacon = ieee80211_beacon_get_template(mvm->hw, vif, NULL,\n\t\t\t\t\t       link_conf->link_id);\n\tif (!beacon)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tif (mvm->beacon_inject_active) {\n\t\tdev_kfree_skb(beacon);\n\t\treturn -EBUSY;\n\t}\n#endif\n\n\tret = iwl_mvm_mac_ctxt_send_beacon(mvm, vif, beacon, link_conf);\n\tdev_kfree_skb(beacon);\n\treturn ret;\n}\n\nstruct iwl_mvm_mac_ap_iterator_data {\n\tstruct iwl_mvm *mvm;\n\tstruct ieee80211_vif *vif;\n\tu32 beacon_device_ts;\n\tu16 beacon_int;\n};\n\n \nstatic void iwl_mvm_mac_ap_iterator(void *_data, u8 *mac,\n\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_mac_ap_iterator_data *data = _data;\n\n\tif (vif->type != NL80211_IFTYPE_STATION || !vif->cfg.assoc)\n\t\treturn;\n\n\t \n\tif (vif->p2p && data->beacon_device_ts)\n\t\treturn;\n\n\tdata->beacon_device_ts = vif->bss_conf.sync_device_ts;\n\tdata->beacon_int = vif->bss_conf.beacon_int;\n}\n\n \nvoid iwl_mvm_mac_ctxt_cmd_ap_set_filter_flags(struct iwl_mvm *mvm,\n\t\t\t\t\t      struct iwl_mvm_vif *mvmvif,\n\t\t\t\t\t      __le32 *filter_flags,\n\t\t\t\t\t      int accept_probe_req_flag,\n\t\t\t\t\t      int accept_beacon_flag)\n{\n\t \n\t*filter_flags |= cpu_to_le32(accept_probe_req_flag);\n\tif (mvmvif->ap_assoc_sta_count || !mvm->drop_bcn_ap_mode) {\n\t\t*filter_flags |= cpu_to_le32(accept_beacon_flag);\n\t\tIWL_DEBUG_HC(mvm, \"Asking FW to pass beacons\\n\");\n\t} else {\n\t\tIWL_DEBUG_HC(mvm, \"No need to receive beacons\\n\");\n\t}\n}\n\n \nstatic void iwl_mvm_mac_ctxt_cmd_fill_ap(struct iwl_mvm *mvm,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t struct iwl_mac_ctx_cmd *cmd,\n\t\t\t\t\t struct iwl_mac_data_ap *ctxt_ap,\n\t\t\t\t\t bool add)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_mac_ap_iterator_data data = {\n\t\t.mvm = mvm,\n\t\t.vif = vif,\n\t\t.beacon_device_ts = 0\n\t};\n\n\t \n\tcmd->ac[IWL_MVM_TX_FIFO_VO].fifos_mask |= BIT(IWL_MVM_TX_FIFO_MCAST);\n\n\tiwl_mvm_mac_ctxt_cmd_ap_set_filter_flags(mvm, mvmvif,\n\t\t\t\t\t\t &cmd->filter_flags,\n\t\t\t\t\t\t MAC_FILTER_IN_PROBE_REQUEST,\n\t\t\t\t\t\t MAC_FILTER_IN_BEACON);\n\n\tctxt_ap->bi = cpu_to_le32(vif->bss_conf.beacon_int);\n\tctxt_ap->dtim_interval = cpu_to_le32(vif->bss_conf.beacon_int *\n\t\t\t\t\t     vif->bss_conf.dtim_period);\n\n\tif (!fw_has_api(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_API_STA_TYPE))\n\t\tctxt_ap->mcast_qid = cpu_to_le32(mvmvif->deflink.cab_queue);\n\n\t \n\tif (add) {\n\t\t \n\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\tmvm->hw, IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\tiwl_mvm_mac_ap_iterator, &data);\n\n\t\tif (data.beacon_device_ts) {\n\t\t\tu32 rand = get_random_u32_inclusive(36, 63);\n\t\t\tmvmvif->ap_beacon_time = data.beacon_device_ts +\n\t\t\t\tieee80211_tu_to_usec(data.beacon_int * rand /\n\t\t\t\t\t\t     100);\n\t\t} else {\n\t\t\tmvmvif->ap_beacon_time = iwl_mvm_get_systime(mvm);\n\t\t}\n\t}\n\n\tctxt_ap->beacon_time = cpu_to_le32(mvmvif->ap_beacon_time);\n\tctxt_ap->beacon_tsf = 0;  \n\n\t \n\tctxt_ap->beacon_template = cpu_to_le32(mvmvif->id);\n}\n\nstatic int iwl_mvm_mac_ctxt_cmd_ap(struct iwl_mvm *mvm,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   u32 action)\n{\n\tstruct iwl_mac_ctx_cmd cmd = {};\n\n\tWARN_ON(vif->type != NL80211_IFTYPE_AP || vif->p2p);\n\n\t \n\tiwl_mvm_mac_ctxt_cmd_common(mvm, vif, &cmd, NULL, action);\n\n\t \n\tiwl_mvm_mac_ctxt_cmd_fill_ap(mvm, vif, &cmd, &cmd.ap,\n\t\t\t\t     action == FW_CTXT_ACTION_ADD);\n\n\treturn iwl_mvm_mac_ctxt_send_cmd(mvm, &cmd);\n}\n\nstatic int iwl_mvm_mac_ctxt_cmd_go(struct iwl_mvm *mvm,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   u32 action)\n{\n\tstruct iwl_mac_ctx_cmd cmd = {};\n\tstruct ieee80211_p2p_noa_attr *noa = &vif->bss_conf.p2p_noa_attr;\n\n\tWARN_ON(vif->type != NL80211_IFTYPE_AP || !vif->p2p);\n\n\t \n\tiwl_mvm_mac_ctxt_cmd_common(mvm, vif, &cmd, NULL, action);\n\n\t \n\tiwl_mvm_mac_ctxt_cmd_fill_ap(mvm, vif, &cmd, &cmd.go.ap,\n\t\t\t\t     action == FW_CTXT_ACTION_ADD);\n\n\tcmd.go.ctwin = cpu_to_le32(noa->oppps_ctwindow &\n\t\t\t\t\tIEEE80211_P2P_OPPPS_CTWINDOW_MASK);\n\tcmd.go.opp_ps_enabled =\n\t\t\tcpu_to_le32(!!(noa->oppps_ctwindow &\n\t\t\t\t\tIEEE80211_P2P_OPPPS_ENABLE_BIT));\n\n\treturn iwl_mvm_mac_ctxt_send_cmd(mvm, &cmd);\n}\n\nstatic int iwl_mvm_mac_ctx_send(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t\tu32 action, bool force_assoc_off,\n\t\t\t\tconst u8 *bssid_override)\n{\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\treturn iwl_mvm_mac_ctxt_cmd_sta(mvm, vif, action,\n\t\t\t\t\t\tforce_assoc_off,\n\t\t\t\t\t\tbssid_override);\n\tcase NL80211_IFTYPE_AP:\n\t\tif (!vif->p2p)\n\t\t\treturn iwl_mvm_mac_ctxt_cmd_ap(mvm, vif, action);\n\t\telse\n\t\t\treturn iwl_mvm_mac_ctxt_cmd_go(mvm, vif, action);\n\tcase NL80211_IFTYPE_MONITOR:\n\t\treturn iwl_mvm_mac_ctxt_cmd_listener(mvm, vif, action);\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\treturn iwl_mvm_mac_ctxt_cmd_p2p_device(mvm, vif, action);\n\tcase NL80211_IFTYPE_ADHOC:\n\t\treturn iwl_mvm_mac_ctxt_cmd_ibss(mvm, vif, action);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nint iwl_mvm_mac_ctxt_add(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tint ret;\n\n\tif (WARN_ONCE(mvmvif->uploaded, \"Adding active MAC %pM/%d\\n\",\n\t\t      vif->addr, ieee80211_vif_type_p2p(vif)))\n\t\treturn -EIO;\n\n\tret = iwl_mvm_mac_ctx_send(mvm, vif, FW_CTXT_ACTION_ADD,\n\t\t\t\t   true, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tiwl_mvm_set_last_nonqos_seq(mvm, vif);\n\n\tmvmvif->uploaded = true;\n\treturn 0;\n}\n\nint iwl_mvm_mac_ctxt_changed(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t     bool force_assoc_off, const u8 *bssid_override)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tif (WARN_ONCE(!mvmvif->uploaded, \"Changing inactive MAC %pM/%d\\n\",\n\t\t      vif->addr, ieee80211_vif_type_p2p(vif)))\n\t\treturn -EIO;\n\n\treturn iwl_mvm_mac_ctx_send(mvm, vif, FW_CTXT_ACTION_MODIFY,\n\t\t\t\t    force_assoc_off, bssid_override);\n}\n\nint iwl_mvm_mac_ctxt_remove(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mac_ctx_cmd cmd;\n\tint ret;\n\n\tif (WARN_ONCE(!mvmvif->uploaded, \"Removing inactive MAC %pM/%d\\n\",\n\t\t      vif->addr, ieee80211_vif_type_p2p(vif)))\n\t\treturn -EIO;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\tcmd.id_and_color = cpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id,\n\t\t\t\t\t\t\t   mvmvif->color));\n\tcmd.action = cpu_to_le32(FW_CTXT_ACTION_REMOVE);\n\n\tret = iwl_mvm_mac_ctxt_send_cmd(mvm, &cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tmvmvif->uploaded = false;\n\n\tif (vif->type == NL80211_IFTYPE_MONITOR) {\n\t\t__clear_bit(IEEE80211_HW_RX_INCLUDES_FCS, mvm->hw->flags);\n\t\tiwl_mvm_dealloc_snif_sta(mvm);\n\t}\n\n\treturn 0;\n}\n\nstatic void iwl_mvm_csa_count_down(struct iwl_mvm *mvm,\n\t\t\t\t   struct ieee80211_vif *csa_vif, u32 gp2,\n\t\t\t\t   bool tx_success)\n{\n\tstruct iwl_mvm_vif *mvmvif =\n\t\t\tiwl_mvm_vif_from_mac80211(csa_vif);\n\n\t \n\tif (!tx_success && !mvmvif->csa_countdown)\n\t\treturn;\n\n\tmvmvif->csa_countdown = true;\n\n\tif (!ieee80211_beacon_cntdwn_is_complete(csa_vif)) {\n\t\tint c = ieee80211_beacon_update_cntdwn(csa_vif);\n\n\t\tiwl_mvm_mac_ctxt_beacon_changed(mvm, csa_vif,\n\t\t\t\t\t\t&csa_vif->bss_conf);\n\t\tif (csa_vif->p2p &&\n\t\t    !iwl_mvm_te_scheduled(&mvmvif->time_event_data) && gp2 &&\n\t\t    tx_success) {\n\t\t\tu32 rel_time = (c + 1) *\n\t\t\t\t       csa_vif->bss_conf.beacon_int -\n\t\t\t\t       IWL_MVM_CHANNEL_SWITCH_TIME_GO;\n\t\t\tu32 apply_time = gp2 + rel_time * 1024;\n\n\t\t\tiwl_mvm_schedule_csa_period(mvm, csa_vif,\n\t\t\t\t\t IWL_MVM_CHANNEL_SWITCH_TIME_GO -\n\t\t\t\t\t IWL_MVM_CHANNEL_SWITCH_MARGIN,\n\t\t\t\t\t apply_time);\n\t\t}\n\t} else if (!iwl_mvm_te_scheduled(&mvmvif->time_event_data)) {\n\t\t \n\t\tieee80211_csa_finish(csa_vif);\n\t\tRCU_INIT_POINTER(mvm->csa_vif, NULL);\n\t}\n}\n\nvoid iwl_mvm_rx_beacon_notif(struct iwl_mvm *mvm,\n\t\t\t     struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tunsigned int pkt_len = iwl_rx_packet_payload_len(pkt);\n\tstruct iwl_extended_beacon_notif *beacon = (void *)pkt->data;\n\tstruct iwl_extended_beacon_notif_v5 *beacon_v5 = (void *)pkt->data;\n\tstruct ieee80211_vif *csa_vif;\n\tstruct ieee80211_vif *tx_blocked_vif;\n\tstruct agg_tx_status *agg_status;\n\tu16 status;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tmvm->ap_last_beacon_gp2 = le32_to_cpu(beacon->gp2);\n\n\tif (!iwl_mvm_is_short_beacon_notif_supported(mvm)) {\n\t\tstruct iwl_mvm_tx_resp *beacon_notify_hdr =\n\t\t\t&beacon_v5->beacon_notify_hdr;\n\n\t\tif (unlikely(pkt_len < sizeof(*beacon_v5)))\n\t\t\treturn;\n\n\t\tmvm->ibss_manager = beacon_v5->ibss_mgr_status != 0;\n\t\tagg_status = iwl_mvm_get_agg_status(mvm, beacon_notify_hdr);\n\t\tstatus = le16_to_cpu(agg_status->status) & TX_STATUS_MSK;\n\t\tIWL_DEBUG_RX(mvm,\n\t\t\t     \"beacon status %#x retries:%d tsf:0x%016llX gp2:0x%X rate:%d\\n\",\n\t\t\t     status, beacon_notify_hdr->failure_frame,\n\t\t\t     le64_to_cpu(beacon->tsf),\n\t\t\t     mvm->ap_last_beacon_gp2,\n\t\t\t     le32_to_cpu(beacon_notify_hdr->initial_rate));\n\t} else {\n\t\tif (unlikely(pkt_len < sizeof(*beacon)))\n\t\t\treturn;\n\n\t\tmvm->ibss_manager = beacon->ibss_mgr_status != 0;\n\t\tstatus = le32_to_cpu(beacon->status) & TX_STATUS_MSK;\n\t\tIWL_DEBUG_RX(mvm,\n\t\t\t     \"beacon status %#x tsf:0x%016llX gp2:0x%X\\n\",\n\t\t\t     status, le64_to_cpu(beacon->tsf),\n\t\t\t     mvm->ap_last_beacon_gp2);\n\t}\n\n\tcsa_vif = rcu_dereference_protected(mvm->csa_vif,\n\t\t\t\t\t    lockdep_is_held(&mvm->mutex));\n\tif (unlikely(csa_vif && csa_vif->bss_conf.csa_active))\n\t\tiwl_mvm_csa_count_down(mvm, csa_vif, mvm->ap_last_beacon_gp2,\n\t\t\t\t       (status == TX_STATUS_SUCCESS));\n\n\ttx_blocked_vif = rcu_dereference_protected(mvm->csa_tx_blocked_vif,\n\t\t\t\t\t\tlockdep_is_held(&mvm->mutex));\n\tif (unlikely(tx_blocked_vif)) {\n\t\tstruct iwl_mvm_vif *mvmvif =\n\t\t\tiwl_mvm_vif_from_mac80211(tx_blocked_vif);\n\n\t\t \n\t\tif (!mvm->csa_tx_block_bcn_timeout)\n\t\t\tmvm->csa_tx_block_bcn_timeout =\n\t\t\t\tIWL_MVM_CS_UNBLOCK_TX_TIMEOUT;\n\t\telse\n\t\t\tmvm->csa_tx_block_bcn_timeout--;\n\n\t\t \n\t\tif (mvm->csa_tx_block_bcn_timeout == 0) {\n\t\t\tiwl_mvm_modify_all_sta_disable_tx(mvm, mvmvif, false);\n\t\t\tRCU_INIT_POINTER(mvm->csa_tx_blocked_vif, NULL);\n\t\t}\n\t}\n}\n\nvoid iwl_mvm_rx_missed_beacons_notif(struct iwl_mvm *mvm,\n\t\t\t\t     struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_missed_beacons_notif *mb = (void *)pkt->data;\n\tstruct iwl_fw_dbg_trigger_missed_bcon *bcon_trig;\n\tstruct iwl_fw_dbg_trigger_tlv *trigger;\n\tu32 stop_trig_missed_bcon, stop_trig_missed_bcon_since_rx;\n\tu32 rx_missed_bcon, rx_missed_bcon_since_rx;\n\tstruct ieee80211_vif *vif;\n\t \n\tu32 id = le32_to_cpu(mb->link_id);\n\tunion iwl_dbg_tlv_tp_data tp_data = { .fw_pkt = pkt };\n\tu32 mac_type;\n\tu8 notif_ver = iwl_fw_lookup_notif_ver(mvm->fw, LEGACY_GROUP,\n\t\t\t\t\t       MISSED_BEACONS_NOTIFICATION,\n\t\t\t\t\t       0);\n\n\trcu_read_lock();\n\n\t \n\tif (notif_ver < 4) {\n\t\tvif = iwl_mvm_rcu_dereference_vif_id(mvm, id, true);\n\t} else {\n\t\tstruct ieee80211_bss_conf *bss_conf =\n\t\t\tiwl_mvm_rcu_fw_link_id_to_link_conf(mvm, id, true);\n\n\t\tif (!bss_conf)\n\t\t\tgoto out;\n\n\t\tvif = bss_conf->vif;\n\t}\n\n\tIWL_DEBUG_INFO(mvm,\n\t\t       \"missed bcn %s_id=%u, consecutive=%u (%u, %u, %u)\\n\",\n\t\t       notif_ver < 4 ? \"mac\" : \"link\",\n\t\t       id,\n\t\t       le32_to_cpu(mb->consec_missed_beacons),\n\t\t       le32_to_cpu(mb->consec_missed_beacons_since_last_rx),\n\t\t       le32_to_cpu(mb->num_recvd_beacons),\n\t\t       le32_to_cpu(mb->num_expected_beacons));\n\n\tif (!vif)\n\t\tgoto out;\n\n\tmac_type = iwl_mvm_get_mac_type(vif);\n\n\tIWL_DEBUG_INFO(mvm, \"missed beacon mac_type=%u,\\n\", mac_type);\n\n\tmvm->trans->dbg.dump_file_name_ext_valid = true;\n\tsnprintf(mvm->trans->dbg.dump_file_name_ext, IWL_FW_INI_MAX_NAME,\n\t\t \"MacId_%d_MacType_%d\", id, mac_type);\n\n\trx_missed_bcon = le32_to_cpu(mb->consec_missed_beacons);\n\trx_missed_bcon_since_rx =\n\t\tle32_to_cpu(mb->consec_missed_beacons_since_last_rx);\n\t \n\tif (rx_missed_bcon > IWL_MVM_MISSED_BEACONS_THRESHOLD_LONG)\n\t\tiwl_mvm_connection_loss(mvm, vif, \"missed beacons\");\n\telse if (rx_missed_bcon_since_rx > IWL_MVM_MISSED_BEACONS_THRESHOLD)\n\t\tieee80211_beacon_loss(vif);\n\n\tiwl_dbg_tlv_time_point(&mvm->fwrt,\n\t\t\t       IWL_FW_INI_TIME_POINT_MISSED_BEACONS, &tp_data);\n\n\ttrigger = iwl_fw_dbg_trigger_on(&mvm->fwrt, ieee80211_vif_to_wdev(vif),\n\t\t\t\t\tFW_DBG_TRIGGER_MISSED_BEACONS);\n\tif (!trigger)\n\t\tgoto out;\n\n\tbcon_trig = (void *)trigger->data;\n\tstop_trig_missed_bcon = le32_to_cpu(bcon_trig->stop_consec_missed_bcon);\n\tstop_trig_missed_bcon_since_rx =\n\t\tle32_to_cpu(bcon_trig->stop_consec_missed_bcon_since_rx);\n\n\t \n\n\tif (rx_missed_bcon_since_rx >= stop_trig_missed_bcon_since_rx ||\n\t    rx_missed_bcon >= stop_trig_missed_bcon)\n\t\tiwl_fw_dbg_collect_trig(&mvm->fwrt, trigger, NULL);\n\nout:\n\trcu_read_unlock();\n}\n\nvoid iwl_mvm_rx_stored_beacon_notif(struct iwl_mvm *mvm,\n\t\t\t\t    struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tunsigned int pkt_len = iwl_rx_packet_payload_len(pkt);\n\tstruct iwl_stored_beacon_notif_common *sb = (void *)pkt->data;\n\tstruct ieee80211_rx_status rx_status;\n\tstruct sk_buff *skb;\n\tu8 *data;\n\tu32 size = le32_to_cpu(sb->byte_count);\n\tint ver = iwl_fw_lookup_cmd_ver(mvm->fw,\n\t\t\t\t\tWIDE_ID(PROT_OFFLOAD_GROUP, STORED_BEACON_NTF),\n\t\t\t\t\t0);\n\n\tif (size == 0)\n\t\treturn;\n\n\t \n\tif (ver <= 2) {\n\t\tstruct iwl_stored_beacon_notif_v2 *sb_v2 = (void *)pkt->data;\n\n\t\tif (pkt_len < struct_size(sb_v2, data, size))\n\t\t\treturn;\n\n\t\tdata = sb_v2->data;\n\t} else {\n\t\tstruct iwl_stored_beacon_notif_v3 *sb_v3 = (void *)pkt->data;\n\n\t\tif (pkt_len < struct_size(sb_v3, data, size))\n\t\t\treturn;\n\n\t\tdata = sb_v3->data;\n\t}\n\n\tskb = alloc_skb(size, GFP_ATOMIC);\n\tif (!skb) {\n\t\tIWL_ERR(mvm, \"alloc_skb failed\\n\");\n\t\treturn;\n\t}\n\n\t \n\tmemset(&rx_status, 0, sizeof(rx_status));\n\trx_status.mactime = le64_to_cpu(sb->tsf);\n\t \n\trx_status.flag |= RX_FLAG_MACTIME_PLCP_START;\n\trx_status.device_timestamp = le32_to_cpu(sb->system_time);\n\trx_status.band =\n\t\t(sb->band & cpu_to_le16(RX_RES_PHY_FLAGS_BAND_24)) ?\n\t\t\t\tNL80211_BAND_2GHZ : NL80211_BAND_5GHZ;\n\trx_status.freq =\n\t\tieee80211_channel_to_frequency(le16_to_cpu(sb->channel),\n\t\t\t\t\t       rx_status.band);\n\n\t \n\tskb_put_data(skb, data, size);\n\tmemcpy(IEEE80211_SKB_RXCB(skb), &rx_status, sizeof(rx_status));\n\n\t \n\tieee80211_rx_napi(mvm->hw, NULL, skb, NULL);\n}\n\nvoid iwl_mvm_probe_resp_data_notif(struct iwl_mvm *mvm,\n\t\t\t\t   struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_probe_resp_data_notif *notif = (void *)pkt->data;\n\tstruct iwl_probe_resp_data *old_data, *new_data;\n\tu32 id = le32_to_cpu(notif->mac_id);\n\tstruct ieee80211_vif *vif;\n\tstruct iwl_mvm_vif *mvmvif;\n\n\tIWL_DEBUG_INFO(mvm, \"Probe response data notif: noa %d, csa %d\\n\",\n\t\t       notif->noa_active, notif->csa_counter);\n\n\tvif = iwl_mvm_rcu_dereference_vif_id(mvm, id, false);\n\tif (!vif)\n\t\treturn;\n\n\tmvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tnew_data = kzalloc(sizeof(*new_data), GFP_KERNEL);\n\tif (!new_data)\n\t\treturn;\n\n\tmemcpy(&new_data->notif, notif, sizeof(new_data->notif));\n\n\t \n\tnew_data->noa_len = sizeof(struct ieee80211_vendor_ie) +\n\t\t\t    sizeof(new_data->notif.noa_attr) - 1;\n\n\t \n\tif (new_data->notif.noa_attr.len_low ==\n\t    sizeof(struct ieee80211_p2p_noa_desc) + 2)\n\t\tnew_data->noa_len -= sizeof(struct ieee80211_p2p_noa_desc);\n\n\told_data = rcu_dereference_protected(mvmvif->deflink.probe_resp_data,\n\t\t\t\t\t     lockdep_is_held(&mvmvif->mvm->mutex));\n\trcu_assign_pointer(mvmvif->deflink.probe_resp_data, new_data);\n\n\tif (old_data)\n\t\tkfree_rcu(old_data, rcu_head);\n\n\tif (notif->csa_counter != IWL_PROBE_RESP_DATA_NO_CSA &&\n\t    notif->csa_counter >= 1)\n\t\tieee80211_beacon_set_cntdwn(vif, notif->csa_counter);\n}\n\nvoid iwl_mvm_channel_switch_start_notif(struct iwl_mvm *mvm,\n\t\t\t\t\tstruct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct ieee80211_vif *csa_vif, *vif;\n\tstruct iwl_mvm_vif *mvmvif, *csa_mvmvif;\n\tu32 id_n_color, csa_id;\n\t \n\tu32 id;\n\tu8 notif_ver = iwl_fw_lookup_notif_ver(mvm->fw, MAC_CONF_GROUP,\n\t\t\t\t\t       CHANNEL_SWITCH_START_NOTIF, 0);\n\tbool csa_active;\n\n\trcu_read_lock();\n\n\tif (notif_ver < 3) {\n\t\tstruct iwl_channel_switch_start_notif_v1 *notif = (void *)pkt->data;\n\t\tu32 mac_id;\n\n\t\tid_n_color = le32_to_cpu(notif->id_and_color);\n\t\tmac_id = id_n_color & FW_CTXT_ID_MSK;\n\n\t\tvif = iwl_mvm_rcu_dereference_vif_id(mvm, mac_id, true);\n\t\tif (!vif)\n\t\t\tgoto out_unlock;\n\n\t\tid = mac_id;\n\t\tcsa_active = vif->bss_conf.csa_active;\n\t} else {\n\t\tstruct iwl_channel_switch_start_notif *notif = (void *)pkt->data;\n\t\tu32 link_id = le32_to_cpu(notif->link_id);\n\t\tstruct ieee80211_bss_conf *bss_conf =\n\t\t\tiwl_mvm_rcu_fw_link_id_to_link_conf(mvm, link_id, true);\n\n\t\tif (!bss_conf)\n\t\t\tgoto out_unlock;\n\n\t\tid = link_id;\n\t\tvif = bss_conf->vif;\n\t\tcsa_active = bss_conf->csa_active;\n\t}\n\n\tmvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tif (notif_ver >= 3)\n\t\tid_n_color = FW_CMD_ID_AND_COLOR(mvmvif->id, mvmvif->color);\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_AP:\n\t\tcsa_vif = rcu_dereference(mvm->csa_vif);\n\t\tif (WARN_ON(!csa_vif || !csa_vif->bss_conf.csa_active ||\n\t\t\t    csa_vif != vif))\n\t\t\tgoto out_unlock;\n\n\t\tcsa_mvmvif = iwl_mvm_vif_from_mac80211(csa_vif);\n\t\tcsa_id = FW_CMD_ID_AND_COLOR(csa_mvmvif->id, csa_mvmvif->color);\n\t\tif (WARN(csa_id != id_n_color,\n\t\t\t \"channel switch noa notification on unexpected vif (csa_vif=%d, notif=%d)\",\n\t\t\t csa_id, id_n_color))\n\t\t\tgoto out_unlock;\n\n\t\tIWL_DEBUG_INFO(mvm, \"Channel Switch Started Notification\\n\");\n\n\t\tschedule_delayed_work(&mvm->cs_tx_unblock_dwork,\n\t\t\t\t      msecs_to_jiffies(IWL_MVM_CS_UNBLOCK_TX_TIMEOUT *\n\t\t\t\t\t\t       csa_vif->bss_conf.beacon_int));\n\n\t\tieee80211_csa_finish(csa_vif);\n\n\t\trcu_read_unlock();\n\n\t\tRCU_INIT_POINTER(mvm->csa_vif, NULL);\n\t\treturn;\n\tcase NL80211_IFTYPE_STATION:\n\t\t \n\t\tif (iwl_fw_lookup_notif_ver(mvm->fw, MAC_CONF_GROUP,\n\t\t\t\t\t    CHANNEL_SWITCH_ERROR_NOTIF,\n\t\t\t\t\t    0) && !csa_active) {\n\t\t\tIWL_DEBUG_INFO(mvm, \"Channel Switch was canceled\\n\");\n\t\t\tiwl_mvm_cancel_channel_switch(mvm, vif, id);\n\t\t\tbreak;\n\t\t}\n\n\t\tiwl_mvm_csa_client_absent(mvm, vif);\n\t\tcancel_delayed_work(&mvmvif->csa_work);\n\t\tieee80211_chswitch_done(vif, true);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\nout_unlock:\n\trcu_read_unlock();\n}\n\nvoid iwl_mvm_channel_switch_error_notif(struct iwl_mvm *mvm,\n\t\t\t\t\tstruct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_channel_switch_error_notif *notif = (void *)pkt->data;\n\tstruct ieee80211_vif *vif;\n\tu32 id = le32_to_cpu(notif->link_id);\n\tu32 csa_err_mask = le32_to_cpu(notif->csa_err_mask);\n\n\trcu_read_lock();\n\tvif = iwl_mvm_rcu_dereference_vif_id(mvm, id, true);\n\tif (!vif) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tIWL_DEBUG_INFO(mvm, \"FW reports CSA error: id=%u, csa_err_mask=%u\\n\",\n\t\t       id, csa_err_mask);\n\tif (csa_err_mask & (CS_ERR_COUNT_ERROR |\n\t\t\t    CS_ERR_LONG_DELAY_AFTER_CS |\n\t\t\t    CS_ERR_TX_BLOCK_TIMER_EXPIRED))\n\t\tieee80211_channel_switch_disconnect(vif, true);\n\trcu_read_unlock();\n}\n\nvoid iwl_mvm_rx_missed_vap_notif(struct iwl_mvm *mvm,\n\t\t\t\t struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_missed_vap_notif *mb = (void *)pkt->data;\n\tstruct ieee80211_vif *vif;\n\tu32 id = le32_to_cpu(mb->mac_id);\n\n\tIWL_DEBUG_INFO(mvm,\n\t\t       \"missed_vap notify mac_id=%u, num_beacon_intervals_elapsed=%u, profile_periodicity=%u\\n\",\n\t\t       le32_to_cpu(mb->mac_id),\n\t\t       mb->num_beacon_intervals_elapsed,\n\t\t       mb->profile_periodicity);\n\n\trcu_read_lock();\n\n\tvif = iwl_mvm_rcu_dereference_vif_id(mvm, id, true);\n\tif (vif)\n\t\tiwl_mvm_connection_loss(mvm, vif, \"missed vap beacon\");\n\n\trcu_read_unlock();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}