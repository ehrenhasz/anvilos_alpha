{
  "module_name": "coex.c",
  "hash_id": "2f40d736943b0df7c88f51e48450b0efe5f85d8938eaff48b46ee0b4f63fe528",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/coex.c",
  "human_readable_source": "\n \n#include <linux/ieee80211.h>\n#include <linux/etherdevice.h>\n#include <net/mac80211.h>\n\n#include \"fw/api/coex.h\"\n#include \"iwl-modparams.h\"\n#include \"mvm.h\"\n#include \"iwl-debug.h\"\n\n \nstatic const __le64 iwl_ci_mask[][3] = {\n\t \n\t{cpu_to_le64(0), cpu_to_le64(0), cpu_to_le64(0)},\n\t{\n\t\tcpu_to_le64(0x0000001FFFULL),\n\t\tcpu_to_le64(0x0ULL),\n\t\tcpu_to_le64(0x00007FFFFFULL),\n\t},\n\t{\n\t\tcpu_to_le64(0x000000FFFFULL),\n\t\tcpu_to_le64(0x0ULL),\n\t\tcpu_to_le64(0x0003FFFFFFULL),\n\t},\n\t{\n\t\tcpu_to_le64(0x000003FFFCULL),\n\t\tcpu_to_le64(0x0ULL),\n\t\tcpu_to_le64(0x000FFFFFFCULL),\n\t},\n\t{\n\t\tcpu_to_le64(0x00001FFFE0ULL),\n\t\tcpu_to_le64(0x0ULL),\n\t\tcpu_to_le64(0x007FFFFFE0ULL),\n\t},\n\t{\n\t\tcpu_to_le64(0x00007FFF80ULL),\n\t\tcpu_to_le64(0x00007FFFFFULL),\n\t\tcpu_to_le64(0x01FFFFFF80ULL),\n\t},\n\t{\n\t\tcpu_to_le64(0x0003FFFC00ULL),\n\t\tcpu_to_le64(0x0003FFFFFFULL),\n\t\tcpu_to_le64(0x0FFFFFFC00ULL),\n\t},\n\t{\n\t\tcpu_to_le64(0x000FFFF000ULL),\n\t\tcpu_to_le64(0x000FFFFFFCULL),\n\t\tcpu_to_le64(0x3FFFFFF000ULL),\n\t},\n\t{\n\t\tcpu_to_le64(0x007FFF8000ULL),\n\t\tcpu_to_le64(0x007FFFFFE0ULL),\n\t\tcpu_to_le64(0xFFFFFF8000ULL),\n\t},\n\t{\n\t\tcpu_to_le64(0x01FFFE0000ULL),\n\t\tcpu_to_le64(0x01FFFFFF80ULL),\n\t\tcpu_to_le64(0xFFFFFE0000ULL),\n\t},\n\t{\n\t\tcpu_to_le64(0x0FFFF00000ULL),\n\t\tcpu_to_le64(0x0FFFFFFC00ULL),\n\t\tcpu_to_le64(0x0ULL),\n\t},\n\t{\n\t\tcpu_to_le64(0x3FFFC00000ULL),\n\t\tcpu_to_le64(0x3FFFFFF000ULL),\n\t\tcpu_to_le64(0x0)\n\t},\n\t{\n\t\tcpu_to_le64(0xFFFE000000ULL),\n\t\tcpu_to_le64(0xFFFFFF8000ULL),\n\t\tcpu_to_le64(0x0)\n\t},\n\t{\n\t\tcpu_to_le64(0xFFF8000000ULL),\n\t\tcpu_to_le64(0xFFFFFE0000ULL),\n\t\tcpu_to_le64(0x0)\n\t},\n\t{\n\t\tcpu_to_le64(0xFE00000000ULL),\n\t\tcpu_to_le64(0x0ULL),\n\t\tcpu_to_le64(0x0ULL)\n\t},\n};\n\nstatic enum iwl_bt_coex_lut_type\niwl_get_coex_type(struct iwl_mvm *mvm, const struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tenum iwl_bt_coex_lut_type ret;\n\tu16 phy_ctx_id;\n\tu32 primary_ch_phy_id, secondary_ch_phy_id;\n\n\t \n\n\trcu_read_lock();\n\n\tchanctx_conf = rcu_dereference(vif->bss_conf.chanctx_conf);\n\n\tif (!chanctx_conf ||\n\t     chanctx_conf->def.chan->band != NL80211_BAND_2GHZ) {\n\t\trcu_read_unlock();\n\t\treturn BT_COEX_INVALID_LUT;\n\t}\n\n\tret = BT_COEX_TX_DIS_LUT;\n\n\tif (mvm->cfg->bt_shared_single_ant) {\n\t\trcu_read_unlock();\n\t\treturn ret;\n\t}\n\n\tphy_ctx_id = *((u16 *)chanctx_conf->drv_priv);\n\tprimary_ch_phy_id = le32_to_cpu(mvm->last_bt_ci_cmd.primary_ch_phy_id);\n\tsecondary_ch_phy_id =\n\t\tle32_to_cpu(mvm->last_bt_ci_cmd.secondary_ch_phy_id);\n\n\tif (primary_ch_phy_id == phy_ctx_id)\n\t\tret = le32_to_cpu(mvm->last_bt_notif.primary_ch_lut);\n\telse if (secondary_ch_phy_id == phy_ctx_id)\n\t\tret = le32_to_cpu(mvm->last_bt_notif.secondary_ch_lut);\n\t \n\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nint iwl_mvm_send_bt_init_conf(struct iwl_mvm *mvm)\n{\n\tstruct iwl_bt_coex_cmd bt_cmd = {};\n\tu32 mode;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (unlikely(mvm->bt_force_ant_mode != BT_FORCE_ANT_DIS)) {\n\t\tswitch (mvm->bt_force_ant_mode) {\n\t\tcase BT_FORCE_ANT_BT:\n\t\t\tmode = BT_COEX_BT;\n\t\t\tbreak;\n\t\tcase BT_FORCE_ANT_WIFI:\n\t\t\tmode = BT_COEX_WIFI;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\tmode = 0;\n\t\t}\n\n\t\tbt_cmd.mode = cpu_to_le32(mode);\n\t\tgoto send_cmd;\n\t}\n\n\tbt_cmd.mode = cpu_to_le32(BT_COEX_NW);\n\n\tif (IWL_MVM_BT_COEX_SYNC2SCO)\n\t\tbt_cmd.enabled_modules |=\n\t\t\tcpu_to_le32(BT_COEX_SYNC2SCO_ENABLED);\n\n\tif (iwl_mvm_is_mplut_supported(mvm))\n\t\tbt_cmd.enabled_modules |= cpu_to_le32(BT_COEX_MPLUT_ENABLED);\n\n\tbt_cmd.enabled_modules |= cpu_to_le32(BT_COEX_HIGH_BAND_RET);\n\nsend_cmd:\n\tmemset(&mvm->last_bt_notif, 0, sizeof(mvm->last_bt_notif));\n\tmemset(&mvm->last_bt_ci_cmd, 0, sizeof(mvm->last_bt_ci_cmd));\n\n\treturn iwl_mvm_send_cmd_pdu(mvm, BT_CONFIG, 0, sizeof(bt_cmd), &bt_cmd);\n}\n\nstatic int iwl_mvm_bt_coex_reduced_txp(struct iwl_mvm *mvm, u8 sta_id,\n\t\t\t\t       bool enable)\n{\n\tstruct iwl_bt_coex_reduced_txp_update_cmd cmd = {};\n\tstruct iwl_mvm_sta *mvmsta;\n\tu32 value;\n\n\tmvmsta = iwl_mvm_sta_from_staid_protected(mvm, sta_id);\n\tif (!mvmsta)\n\t\treturn 0;\n\n\t \n\tif (mvmsta->bt_reduced_txpower == enable)\n\t\treturn 0;\n\n\tvalue = mvmsta->deflink.sta_id;\n\n\tif (enable)\n\t\tvalue |= BT_REDUCED_TX_POWER_BIT;\n\n\tIWL_DEBUG_COEX(mvm, \"%sable reduced Tx Power for sta %d\\n\",\n\t\t       enable ? \"en\" : \"dis\", sta_id);\n\n\tcmd.reduced_txp = cpu_to_le32(value);\n\tmvmsta->bt_reduced_txpower = enable;\n\n\treturn iwl_mvm_send_cmd_pdu(mvm, BT_COEX_UPDATE_REDUCED_TXP,\n\t\t\t\t    CMD_ASYNC, sizeof(cmd), &cmd);\n}\n\nstruct iwl_bt_iterator_data {\n\tstruct iwl_bt_coex_profile_notif *notif;\n\tstruct iwl_mvm *mvm;\n\tstruct ieee80211_chanctx_conf *primary;\n\tstruct ieee80211_chanctx_conf *secondary;\n\tbool primary_ll;\n\tu8 primary_load;\n\tu8 secondary_load;\n};\n\nstatic inline\nvoid iwl_mvm_bt_coex_enable_rssi_event(struct iwl_mvm *mvm,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       bool enable, int rssi)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tmvmvif->bf_data.last_bt_coex_event = rssi;\n\tmvmvif->bf_data.bt_coex_max_thold =\n\t\tenable ? -IWL_MVM_BT_COEX_EN_RED_TXP_THRESH : 0;\n\tmvmvif->bf_data.bt_coex_min_thold =\n\t\tenable ? -IWL_MVM_BT_COEX_DIS_RED_TXP_THRESH : 0;\n}\n\n#define MVM_COEX_TCM_PERIOD (HZ * 10)\n\nstatic void iwl_mvm_bt_coex_tcm_based_ci(struct iwl_mvm *mvm,\n\t\t\t\t\t struct iwl_bt_iterator_data *data)\n{\n\tunsigned long now = jiffies;\n\n\tif (!time_after(now, mvm->bt_coex_last_tcm_ts + MVM_COEX_TCM_PERIOD))\n\t\treturn;\n\n\tmvm->bt_coex_last_tcm_ts = now;\n\n\t \n\n\t \n\tif (data->primary_ll)\n\t\treturn;\n\n\tif (data->primary_load >= data->secondary_load)\n\t\treturn;\n\n\tswap(data->primary, data->secondary);\n}\n\nstatic void iwl_mvm_bt_notif_per_link(struct iwl_mvm *mvm,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct iwl_bt_iterator_data *data,\n\t\t\t\t      unsigned int link_id)\n{\n\t \n\tenum ieee80211_smps_mode smps_mode = IEEE80211_SMPS_AUTOMATIC;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tu32 bt_activity_grading, min_ag_for_static_smps;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct iwl_mvm_vif_link_info *link_info;\n\tstruct ieee80211_bss_conf *link_conf;\n\tint ave_rssi;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tlink_info = mvmvif->link[link_id];\n\tif (!link_info)\n\t\treturn;\n\n\tlink_conf = rcu_dereference(vif->link_conf[link_id]);\n\t \n\tif (!link_conf)\n\t\treturn;\n\n\tchanctx_conf = rcu_dereference(link_conf->chanctx_conf);\n\n\t \n\tif ((!chanctx_conf ||\n\t     chanctx_conf->def.chan->band != NL80211_BAND_2GHZ)) {\n\t\tif (vif->type == NL80211_IFTYPE_STATION) {\n\t\t\t \n\t\t\tiwl_mvm_update_smps(mvm, vif, IWL_MVM_SMPS_REQ_BT_COEX,\n\t\t\t\t\t    smps_mode, link_id);\n\t\t\tiwl_mvm_bt_coex_reduced_txp(mvm, link_info->ap_sta_id,\n\t\t\t\t\t\t    false);\n\t\t\t \n\t\t\tiwl_mvm_bt_coex_enable_rssi_event(mvm, vif, false, 0);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa, IWL_UCODE_TLV_CAPA_COEX_SCHEMA_2))\n\t\tmin_ag_for_static_smps = BT_VERY_HIGH_TRAFFIC;\n\telse\n\t\tmin_ag_for_static_smps = BT_HIGH_TRAFFIC;\n\n\tbt_activity_grading = le32_to_cpu(data->notif->bt_activity_grading);\n\tif (bt_activity_grading >= min_ag_for_static_smps)\n\t\tsmps_mode = IEEE80211_SMPS_STATIC;\n\telse if (bt_activity_grading >= BT_LOW_TRAFFIC)\n\t\tsmps_mode = IEEE80211_SMPS_DYNAMIC;\n\n\t \n\tif (!vif->cfg.assoc)\n\t\tsmps_mode = IEEE80211_SMPS_AUTOMATIC;\n\n\tif (link_info->phy_ctxt &&\n\t    (mvm->last_bt_notif.rrc_status & BIT(link_info->phy_ctxt->id)))\n\t\tsmps_mode = IEEE80211_SMPS_AUTOMATIC;\n\n\tIWL_DEBUG_COEX(data->mvm,\n\t\t       \"mac %d link %d: bt_activity_grading %d smps_req %d\\n\",\n\t\t       mvmvif->id, link_info->fw_link_id,\n\t\t       bt_activity_grading, smps_mode);\n\n\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\tiwl_mvm_update_smps(mvm, vif, IWL_MVM_SMPS_REQ_BT_COEX,\n\t\t\t\t    smps_mode, link_id);\n\n\t \n\tif (iwl_mvm_vif_low_latency(mvmvif)) {\n\t\tdata->primary_ll = true;\n\n\t\tdata->secondary = data->primary;\n\t\tdata->primary = chanctx_conf;\n\t}\n\n\tif (vif->type == NL80211_IFTYPE_AP) {\n\t\tif (!mvmvif->ap_ibss_active)\n\t\t\treturn;\n\n\t\tif (chanctx_conf == data->primary)\n\t\t\treturn;\n\n\t\tif (!data->primary_ll) {\n\t\t\t \n\t\t\tdata->secondary = data->primary;\n\t\t\tdata->primary = chanctx_conf;\n\t\t} else {\n\t\t\t \n\t\t\tdata->secondary = chanctx_conf;\n\t\t}\n\n\t\t \n\t\tif (data->primary == chanctx_conf)\n\t\t\tdata->primary_load = mvm->tcm.result.load[mvmvif->id];\n\t\telse if (data->secondary == chanctx_conf)\n\t\t\tdata->secondary_load = mvm->tcm.result.load[mvmvif->id];\n\t\treturn;\n\t}\n\n\t \n\tif (!data->primary || data->primary == chanctx_conf)\n\t\tdata->primary = chanctx_conf;\n\telse if (!data->secondary)\n\t\t \n\t\tdata->secondary = chanctx_conf;\n\n\t \n\tif (data->primary == chanctx_conf)\n\t\tdata->primary_load = mvm->tcm.result.load[mvmvif->id];\n\telse if (data->secondary == chanctx_conf)\n\t\tdata->secondary_load = mvm->tcm.result.load[mvmvif->id];\n\t \n\tif (iwl_get_coex_type(mvm, vif) == BT_COEX_LOOSE_LUT ||\n\t    mvm->cfg->bt_shared_single_ant || !vif->cfg.assoc ||\n\t    le32_to_cpu(mvm->last_bt_notif.bt_activity_grading) == BT_OFF) {\n\t\tiwl_mvm_bt_coex_reduced_txp(mvm, link_info->ap_sta_id, false);\n\t\t \n\t\tiwl_mvm_bt_coex_enable_rssi_event(mvm, vif, false, 0);\n\t\treturn;\n\t}\n\n\t \n\tave_rssi = mvmvif->bf_data.ave_beacon_signal;\n\n\t \n\tif (!ave_rssi)\n\t\tave_rssi = -100;\n\tif (ave_rssi > -IWL_MVM_BT_COEX_EN_RED_TXP_THRESH) {\n\t\tif (iwl_mvm_bt_coex_reduced_txp(mvm, link_info->ap_sta_id,\n\t\t\t\t\t\ttrue))\n\t\t\tIWL_ERR(mvm, \"Couldn't send BT_CONFIG cmd\\n\");\n\t} else if (ave_rssi < -IWL_MVM_BT_COEX_DIS_RED_TXP_THRESH) {\n\t\tif (iwl_mvm_bt_coex_reduced_txp(mvm, link_info->ap_sta_id,\n\t\t\t\t\t\tfalse))\n\t\t\tIWL_ERR(mvm, \"Couldn't send BT_CONFIG cmd\\n\");\n\t}\n\n\t \n\tiwl_mvm_bt_coex_enable_rssi_event(mvm, vif, true, ave_rssi);\n}\n\n \nstatic void iwl_mvm_bt_notif_iterator(void *_data, u8 *mac,\n\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_bt_iterator_data *data = _data;\n\tstruct iwl_mvm *mvm = data->mvm;\n\tunsigned int link_id;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tif (!mvmvif->ap_ibss_active)\n\t\t\treturn;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tfor (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++)\n\t\tiwl_mvm_bt_notif_per_link(mvm, vif, data, link_id);\n}\n\nstatic void iwl_mvm_bt_coex_notif_handle(struct iwl_mvm *mvm)\n{\n\tstruct iwl_bt_iterator_data data = {\n\t\t.mvm = mvm,\n\t\t.notif = &mvm->last_bt_notif,\n\t};\n\tstruct iwl_bt_coex_ci_cmd cmd = {};\n\tu8 ci_bw_idx;\n\n\t \n\tif (unlikely(mvm->bt_force_ant_mode != BT_FORCE_ANT_DIS))\n\t\treturn;\n\n\trcu_read_lock();\n\tieee80211_iterate_active_interfaces_atomic(\n\t\t\t\t\tmvm->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\tiwl_mvm_bt_notif_iterator, &data);\n\n\tiwl_mvm_bt_coex_tcm_based_ci(mvm, &data);\n\n\tif (data.primary) {\n\t\tstruct ieee80211_chanctx_conf *chan = data.primary;\n\t\tif (WARN_ON(!chan->def.chan)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\tif (chan->def.width < NL80211_CHAN_WIDTH_40) {\n\t\t\tci_bw_idx = 0;\n\t\t} else {\n\t\t\tif (chan->def.center_freq1 >\n\t\t\t    chan->def.chan->center_freq)\n\t\t\t\tci_bw_idx = 2;\n\t\t\telse\n\t\t\t\tci_bw_idx = 1;\n\t\t}\n\n\t\tcmd.bt_primary_ci =\n\t\t\tiwl_ci_mask[chan->def.chan->hw_value][ci_bw_idx];\n\t\tcmd.primary_ch_phy_id =\n\t\t\tcpu_to_le32(*((u16 *)data.primary->drv_priv));\n\t}\n\n\tif (data.secondary) {\n\t\tstruct ieee80211_chanctx_conf *chan = data.secondary;\n\t\tif (WARN_ON(!data.secondary->def.chan)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\tif (chan->def.width < NL80211_CHAN_WIDTH_40) {\n\t\t\tci_bw_idx = 0;\n\t\t} else {\n\t\t\tif (chan->def.center_freq1 >\n\t\t\t    chan->def.chan->center_freq)\n\t\t\t\tci_bw_idx = 2;\n\t\t\telse\n\t\t\t\tci_bw_idx = 1;\n\t\t}\n\n\t\tcmd.bt_secondary_ci =\n\t\t\tiwl_ci_mask[chan->def.chan->hw_value][ci_bw_idx];\n\t\tcmd.secondary_ch_phy_id =\n\t\t\tcpu_to_le32(*((u16 *)data.secondary->drv_priv));\n\t}\n\n\trcu_read_unlock();\n\n\t \n\tif (memcmp(&cmd, &mvm->last_bt_ci_cmd, sizeof(cmd))) {\n\t\tif (iwl_mvm_send_cmd_pdu(mvm, BT_COEX_CI, 0,\n\t\t\t\t\t sizeof(cmd), &cmd))\n\t\t\tIWL_ERR(mvm, \"Failed to send BT_CI cmd\\n\");\n\t\tmemcpy(&mvm->last_bt_ci_cmd, &cmd, sizeof(cmd));\n\t}\n}\n\nvoid iwl_mvm_rx_bt_coex_notif(struct iwl_mvm *mvm,\n\t\t\t      struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_bt_coex_profile_notif *notif = (void *)pkt->data;\n\n\tIWL_DEBUG_COEX(mvm, \"BT Coex Notification received\\n\");\n\tIWL_DEBUG_COEX(mvm, \"\\tBT ci compliance %d\\n\", notif->bt_ci_compliance);\n\tIWL_DEBUG_COEX(mvm, \"\\tBT primary_ch_lut %d\\n\",\n\t\t       le32_to_cpu(notif->primary_ch_lut));\n\tIWL_DEBUG_COEX(mvm, \"\\tBT secondary_ch_lut %d\\n\",\n\t\t       le32_to_cpu(notif->secondary_ch_lut));\n\tIWL_DEBUG_COEX(mvm, \"\\tBT activity grading %d\\n\",\n\t\t       le32_to_cpu(notif->bt_activity_grading));\n\n\t \n\tmemcpy(&mvm->last_bt_notif, notif, sizeof(mvm->last_bt_notif));\n\n\tiwl_mvm_bt_coex_notif_handle(mvm);\n}\n\nvoid iwl_mvm_bt_rssi_event(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t   enum ieee80211_rssi_event_data rssi_event)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\t \n\tif (unlikely(mvm->bt_force_ant_mode != BT_FORCE_ANT_DIS))\n\t\treturn;\n\n\t \n\tif (mvmvif->deflink.ap_sta_id == IWL_MVM_INVALID_STA)\n\t\treturn;\n\n\t \n\tif (le32_to_cpu(mvm->last_bt_notif.bt_activity_grading) == BT_OFF)\n\t\treturn;\n\n\tIWL_DEBUG_COEX(mvm, \"RSSI for %pM is now %s\\n\", vif->bss_conf.bssid,\n\t\t       rssi_event == RSSI_EVENT_HIGH ? \"HIGH\" : \"LOW\");\n\n\t \n\tif (rssi_event == RSSI_EVENT_LOW || mvm->cfg->bt_shared_single_ant ||\n\t    iwl_get_coex_type(mvm, vif) == BT_COEX_LOOSE_LUT)\n\t\tret = iwl_mvm_bt_coex_reduced_txp(mvm,\n\t\t\t\t\t\t  mvmvif->deflink.ap_sta_id,\n\t\t\t\t\t\t  false);\n\telse\n\t\tret = iwl_mvm_bt_coex_reduced_txp(mvm,\n\t\t\t\t\t\t  mvmvif->deflink.ap_sta_id,\n\t\t\t\t\t\t  true);\n\n\tif (ret)\n\t\tIWL_ERR(mvm, \"couldn't send BT_CONFIG HCMD upon RSSI event\\n\");\n}\n\n#define LINK_QUAL_AGG_TIME_LIMIT_DEF\t(4000)\n#define LINK_QUAL_AGG_TIME_LIMIT_BT_ACT\t(1200)\n\nu16 iwl_mvm_coex_agg_time_limit(struct iwl_mvm *mvm,\n\t\t\t\tstruct ieee80211_sta *sta)\n{\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(mvmsta->vif);\n\tstruct iwl_mvm_phy_ctxt *phy_ctxt = mvmvif->deflink.phy_ctxt;\n\tenum iwl_bt_coex_lut_type lut_type;\n\n\tif (mvm->last_bt_notif.ttc_status & BIT(phy_ctxt->id))\n\t\treturn LINK_QUAL_AGG_TIME_LIMIT_DEF;\n\n\tif (le32_to_cpu(mvm->last_bt_notif.bt_activity_grading) <\n\t    BT_HIGH_TRAFFIC)\n\t\treturn LINK_QUAL_AGG_TIME_LIMIT_DEF;\n\n\tlut_type = iwl_get_coex_type(mvm, mvmsta->vif);\n\n\tif (lut_type == BT_COEX_LOOSE_LUT || lut_type == BT_COEX_INVALID_LUT)\n\t\treturn LINK_QUAL_AGG_TIME_LIMIT_DEF;\n\n\t \n\treturn LINK_QUAL_AGG_TIME_LIMIT_BT_ACT;\n}\n\nbool iwl_mvm_bt_coex_is_mimo_allowed(struct iwl_mvm *mvm,\n\t\t\t\t     struct ieee80211_sta *sta)\n{\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(mvmsta->vif);\n\tstruct iwl_mvm_phy_ctxt *phy_ctxt = mvmvif->deflink.phy_ctxt;\n\tenum iwl_bt_coex_lut_type lut_type;\n\n\tif (mvm->last_bt_notif.ttc_status & BIT(phy_ctxt->id))\n\t\treturn true;\n\n\tif (le32_to_cpu(mvm->last_bt_notif.bt_activity_grading) <\n\t    BT_HIGH_TRAFFIC)\n\t\treturn true;\n\n\t \n\tlut_type = iwl_get_coex_type(mvm, mvmsta->vif);\n\treturn lut_type != BT_COEX_LOOSE_LUT;\n}\n\nbool iwl_mvm_bt_coex_is_ant_avail(struct iwl_mvm *mvm, u8 ant)\n{\n\t \n\tif (mvm->cfg->bt_shared_single_ant)\n\t\treturn true;\n\n\tif (ant & mvm->cfg->non_shared_ant)\n\t\treturn true;\n\n\treturn le32_to_cpu(mvm->last_bt_notif.bt_activity_grading) <\n\t\tBT_HIGH_TRAFFIC;\n}\n\nbool iwl_mvm_bt_coex_is_shared_ant_avail(struct iwl_mvm *mvm)\n{\n\t \n\tif (mvm->cfg->bt_shared_single_ant)\n\t\treturn true;\n\n\treturn le32_to_cpu(mvm->last_bt_notif.bt_activity_grading) < BT_HIGH_TRAFFIC;\n}\n\nbool iwl_mvm_bt_coex_is_tpc_allowed(struct iwl_mvm *mvm,\n\t\t\t\t    enum nl80211_band band)\n{\n\tu32 bt_activity = le32_to_cpu(mvm->last_bt_notif.bt_activity_grading);\n\n\tif (band != NL80211_BAND_2GHZ)\n\t\treturn false;\n\n\treturn bt_activity >= BT_LOW_TRAFFIC;\n}\n\nu8 iwl_mvm_bt_coex_get_single_ant_msk(struct iwl_mvm *mvm, u8 enabled_ants)\n{\n\tif (fw_has_capa(&mvm->fw->ucode_capa, IWL_UCODE_TLV_CAPA_COEX_SCHEMA_2) &&\n\t    (mvm->cfg->non_shared_ant & enabled_ants))\n\t\treturn mvm->cfg->non_shared_ant;\n\n\treturn first_antenna(enabled_ants);\n}\n\nu8 iwl_mvm_bt_coex_tx_prio(struct iwl_mvm *mvm, struct ieee80211_hdr *hdr,\n\t\t\t   struct ieee80211_tx_info *info, u8 ac)\n{\n\t__le16 fc = hdr->frame_control;\n\tbool mplut_enabled = iwl_mvm_is_mplut_supported(mvm);\n\n\tif (info->band != NL80211_BAND_2GHZ)\n\t\treturn 0;\n\n\tif (unlikely(mvm->bt_tx_prio))\n\t\treturn mvm->bt_tx_prio - 1;\n\n\tif (likely(ieee80211_is_data(fc))) {\n\t\tif (likely(ieee80211_is_data_qos(fc))) {\n\t\t\tswitch (ac) {\n\t\t\tcase IEEE80211_AC_BE:\n\t\t\t\treturn mplut_enabled ? 1 : 0;\n\t\t\tcase IEEE80211_AC_VI:\n\t\t\t\treturn mplut_enabled ? 2 : 3;\n\t\t\tcase IEEE80211_AC_VO:\n\t\t\t\treturn 3;\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else if (is_multicast_ether_addr(hdr->addr1)) {\n\t\t\treturn 3;\n\t\t} else\n\t\t\treturn 0;\n\t} else if (ieee80211_is_mgmt(fc)) {\n\t\treturn ieee80211_is_disassoc(fc) ? 0 : 3;\n\t} else if (ieee80211_is_ctl(fc)) {\n\t\t \n\t\treturn 3;\n\t}\n\n\treturn 0;\n}\n\nvoid iwl_mvm_bt_coex_vif_change(struct iwl_mvm *mvm)\n{\n\tiwl_mvm_bt_coex_notif_handle(mvm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}