{
  "module_name": "debugfs-vif.c",
  "hash_id": "f4063b5a579303114773147796e68c4013a474b50159e8caab7bb5c141d62f9d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/debugfs-vif.c",
  "human_readable_source": "\n \n#include \"mvm.h\"\n#include \"debugfs.h\"\n\nstatic void iwl_dbgfs_update_pm(struct iwl_mvm *mvm,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t enum iwl_dbgfs_pm_mask param, int val)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_dbgfs_pm *dbgfs_pm = &mvmvif->dbgfs_pm;\n\n\tdbgfs_pm->mask |= param;\n\n\tswitch (param) {\n\tcase MVM_DEBUGFS_PM_KEEP_ALIVE: {\n\t\tint dtimper = vif->bss_conf.dtim_period ?: 1;\n\t\tint dtimper_msec = dtimper * vif->bss_conf.beacon_int;\n\n\t\tIWL_DEBUG_POWER(mvm, \"debugfs: set keep_alive= %d sec\\n\", val);\n\t\tif (val * MSEC_PER_SEC < 3 * dtimper_msec)\n\t\t\tIWL_WARN(mvm,\n\t\t\t\t \"debugfs: keep alive period (%ld msec) is less than minimum required (%d msec)\\n\",\n\t\t\t\t val * MSEC_PER_SEC, 3 * dtimper_msec);\n\t\tdbgfs_pm->keep_alive_seconds = val;\n\t\tbreak;\n\t}\n\tcase MVM_DEBUGFS_PM_SKIP_OVER_DTIM:\n\t\tIWL_DEBUG_POWER(mvm, \"skip_over_dtim %s\\n\",\n\t\t\t\tval ? \"enabled\" : \"disabled\");\n\t\tdbgfs_pm->skip_over_dtim = val;\n\t\tbreak;\n\tcase MVM_DEBUGFS_PM_SKIP_DTIM_PERIODS:\n\t\tIWL_DEBUG_POWER(mvm, \"skip_dtim_periods=%d\\n\", val);\n\t\tdbgfs_pm->skip_dtim_periods = val;\n\t\tbreak;\n\tcase MVM_DEBUGFS_PM_RX_DATA_TIMEOUT:\n\t\tIWL_DEBUG_POWER(mvm, \"rx_data_timeout=%d\\n\", val);\n\t\tdbgfs_pm->rx_data_timeout = val;\n\t\tbreak;\n\tcase MVM_DEBUGFS_PM_TX_DATA_TIMEOUT:\n\t\tIWL_DEBUG_POWER(mvm, \"tx_data_timeout=%d\\n\", val);\n\t\tdbgfs_pm->tx_data_timeout = val;\n\t\tbreak;\n\tcase MVM_DEBUGFS_PM_LPRX_ENA:\n\t\tIWL_DEBUG_POWER(mvm, \"lprx %s\\n\", val ? \"enabled\" : \"disabled\");\n\t\tdbgfs_pm->lprx_ena = val;\n\t\tbreak;\n\tcase MVM_DEBUGFS_PM_LPRX_RSSI_THRESHOLD:\n\t\tIWL_DEBUG_POWER(mvm, \"lprx_rssi_threshold=%d\\n\", val);\n\t\tdbgfs_pm->lprx_rssi_threshold = val;\n\t\tbreak;\n\tcase MVM_DEBUGFS_PM_SNOOZE_ENABLE:\n\t\tIWL_DEBUG_POWER(mvm, \"snooze_enable=%d\\n\", val);\n\t\tdbgfs_pm->snooze_ena = val;\n\t\tbreak;\n\tcase MVM_DEBUGFS_PM_UAPSD_MISBEHAVING:\n\t\tIWL_DEBUG_POWER(mvm, \"uapsd_misbehaving_enable=%d\\n\", val);\n\t\tdbgfs_pm->uapsd_misbehaving = val;\n\t\tbreak;\n\tcase MVM_DEBUGFS_PM_USE_PS_POLL:\n\t\tIWL_DEBUG_POWER(mvm, \"use_ps_poll=%d\\n\", val);\n\t\tdbgfs_pm->use_ps_poll = val;\n\t\tbreak;\n\t}\n}\n\nstatic ssize_t iwl_dbgfs_pm_params_write(struct ieee80211_vif *vif, char *buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm *mvm = mvmvif->mvm;\n\tenum iwl_dbgfs_pm_mask param;\n\tint val, ret;\n\n\tif (!strncmp(\"keep_alive=\", buf, 11)) {\n\t\tif (sscanf(buf + 11, \"%d\", &val) != 1)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_PM_KEEP_ALIVE;\n\t} else if (!strncmp(\"skip_over_dtim=\", buf, 15)) {\n\t\tif (sscanf(buf + 15, \"%d\", &val) != 1)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_PM_SKIP_OVER_DTIM;\n\t} else if (!strncmp(\"skip_dtim_periods=\", buf, 18)) {\n\t\tif (sscanf(buf + 18, \"%d\", &val) != 1)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_PM_SKIP_DTIM_PERIODS;\n\t} else if (!strncmp(\"rx_data_timeout=\", buf, 16)) {\n\t\tif (sscanf(buf + 16, \"%d\", &val) != 1)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_PM_RX_DATA_TIMEOUT;\n\t} else if (!strncmp(\"tx_data_timeout=\", buf, 16)) {\n\t\tif (sscanf(buf + 16, \"%d\", &val) != 1)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_PM_TX_DATA_TIMEOUT;\n\t} else if (!strncmp(\"lprx=\", buf, 5)) {\n\t\tif (sscanf(buf + 5, \"%d\", &val) != 1)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_PM_LPRX_ENA;\n\t} else if (!strncmp(\"lprx_rssi_threshold=\", buf, 20)) {\n\t\tif (sscanf(buf + 20, \"%d\", &val) != 1)\n\t\t\treturn -EINVAL;\n\t\tif (val > POWER_LPRX_RSSI_THRESHOLD_MAX || val <\n\t\t    POWER_LPRX_RSSI_THRESHOLD_MIN)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_PM_LPRX_RSSI_THRESHOLD;\n\t} else if (!strncmp(\"snooze_enable=\", buf, 14)) {\n\t\tif (sscanf(buf + 14, \"%d\", &val) != 1)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_PM_SNOOZE_ENABLE;\n\t} else if (!strncmp(\"uapsd_misbehaving=\", buf, 18)) {\n\t\tif (sscanf(buf + 18, \"%d\", &val) != 1)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_PM_UAPSD_MISBEHAVING;\n\t} else if (!strncmp(\"use_ps_poll=\", buf, 12)) {\n\t\tif (sscanf(buf + 12, \"%d\", &val) != 1)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_PM_USE_PS_POLL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&mvm->mutex);\n\tiwl_dbgfs_update_pm(mvm, vif, param, val);\n\tret = iwl_mvm_power_update_mac(mvm);\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret ?: count;\n}\n\nstatic ssize_t iwl_dbgfs_tx_pwr_lmt_read(struct file *file,\n\t\t\t\t\t char __user *user_buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_vif *vif = file->private_data;\n\tchar buf[64];\n\tint bufsz = sizeof(buf);\n\tint pos;\n\n\tpos = scnprintf(buf, bufsz, \"bss limit = %d\\n\",\n\t\t\tvif->bss_conf.txpower);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\nstatic ssize_t iwl_dbgfs_pm_params_read(struct file *file,\n\t\t\t\t\tchar __user *user_buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ieee80211_vif *vif = file->private_data;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm *mvm = mvmvif->mvm;\n\tchar buf[512];\n\tint bufsz = sizeof(buf);\n\tint pos;\n\n\tpos = iwl_mvm_power_mac_dbgfs_read(mvm, vif, buf, bufsz);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\nstatic ssize_t iwl_dbgfs_mac_params_read(struct file *file,\n\t\t\t\t\t char __user *user_buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_vif *vif = file->private_data;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm *mvm = mvmvif->mvm;\n\tu8 ap_sta_id;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tchar buf[512];\n\tint bufsz = sizeof(buf);\n\tint pos = 0;\n\tint i;\n\n\tmutex_lock(&mvm->mutex);\n\n\tap_sta_id = mvmvif->deflink.ap_sta_id;\n\n\tswitch (ieee80211_vif_type_p2p(vif)) {\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tpos += scnprintf(buf+pos, bufsz-pos, \"type: ibss\\n\");\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tpos += scnprintf(buf+pos, bufsz-pos, \"type: bss\\n\");\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tpos += scnprintf(buf+pos, bufsz-pos, \"type: ap\\n\");\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tpos += scnprintf(buf+pos, bufsz-pos, \"type: p2p client\\n\");\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tpos += scnprintf(buf+pos, bufsz-pos, \"type: p2p go\\n\");\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tpos += scnprintf(buf+pos, bufsz-pos, \"type: p2p dev\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tpos += scnprintf(buf+pos, bufsz-pos, \"mac id/color: %d / %d\\n\",\n\t\t\t mvmvif->id, mvmvif->color);\n\tpos += scnprintf(buf+pos, bufsz-pos, \"bssid: %pM\\n\",\n\t\t\t vif->bss_conf.bssid);\n\tpos += scnprintf(buf+pos, bufsz-pos, \"Load: %d\\n\",\n\t\t\t mvm->tcm.result.load[mvmvif->id]);\n\tpos += scnprintf(buf+pos, bufsz-pos, \"QoS:\\n\");\n\tfor (i = 0; i < ARRAY_SIZE(mvmvif->deflink.queue_params); i++)\n\t\tpos += scnprintf(buf+pos, bufsz-pos,\n\t\t\t\t \"\\t%d: txop:%d - cw_min:%d - cw_max = %d - aifs = %d upasd = %d\\n\",\n\t\t\t\t i, mvmvif->deflink.queue_params[i].txop,\n\t\t\t\t mvmvif->deflink.queue_params[i].cw_min,\n\t\t\t\t mvmvif->deflink.queue_params[i].cw_max,\n\t\t\t\t mvmvif->deflink.queue_params[i].aifs,\n\t\t\t\t mvmvif->deflink.queue_params[i].uapsd);\n\n\tif (vif->type == NL80211_IFTYPE_STATION &&\n\t    ap_sta_id != IWL_MVM_INVALID_STA) {\n\t\tstruct iwl_mvm_sta *mvm_sta;\n\n\t\tmvm_sta = iwl_mvm_sta_from_staid_protected(mvm, ap_sta_id);\n\t\tif (mvm_sta) {\n\t\t\tpos += scnprintf(buf+pos, bufsz-pos,\n\t\t\t\t\t \"ap_sta_id %d - reduced Tx power %d\\n\",\n\t\t\t\t\t ap_sta_id,\n\t\t\t\t\t mvm_sta->bt_reduced_txpower);\n\t\t}\n\t}\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(vif->bss_conf.chanctx_conf);\n\tif (chanctx_conf)\n\t\tpos += scnprintf(buf+pos, bufsz-pos,\n\t\t\t\t \"idle rx chains %d, active rx chains: %d\\n\",\n\t\t\t\t chanctx_conf->rx_chains_static,\n\t\t\t\t chanctx_conf->rx_chains_dynamic);\n\trcu_read_unlock();\n\n\tmutex_unlock(&mvm->mutex);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\nstatic void iwl_dbgfs_update_bf(struct ieee80211_vif *vif,\n\t\t\t\tenum iwl_dbgfs_bf_mask param, int value)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_dbgfs_bf *dbgfs_bf = &mvmvif->dbgfs_bf;\n\n\tdbgfs_bf->mask |= param;\n\n\tswitch (param) {\n\tcase MVM_DEBUGFS_BF_ENERGY_DELTA:\n\t\tdbgfs_bf->bf_energy_delta = value;\n\t\tbreak;\n\tcase MVM_DEBUGFS_BF_ROAMING_ENERGY_DELTA:\n\t\tdbgfs_bf->bf_roaming_energy_delta = value;\n\t\tbreak;\n\tcase MVM_DEBUGFS_BF_ROAMING_STATE:\n\t\tdbgfs_bf->bf_roaming_state = value;\n\t\tbreak;\n\tcase MVM_DEBUGFS_BF_TEMP_THRESHOLD:\n\t\tdbgfs_bf->bf_temp_threshold = value;\n\t\tbreak;\n\tcase MVM_DEBUGFS_BF_TEMP_FAST_FILTER:\n\t\tdbgfs_bf->bf_temp_fast_filter = value;\n\t\tbreak;\n\tcase MVM_DEBUGFS_BF_TEMP_SLOW_FILTER:\n\t\tdbgfs_bf->bf_temp_slow_filter = value;\n\t\tbreak;\n\tcase MVM_DEBUGFS_BF_ENABLE_BEACON_FILTER:\n\t\tdbgfs_bf->bf_enable_beacon_filter = value;\n\t\tbreak;\n\tcase MVM_DEBUGFS_BF_DEBUG_FLAG:\n\t\tdbgfs_bf->bf_debug_flag = value;\n\t\tbreak;\n\tcase MVM_DEBUGFS_BF_ESCAPE_TIMER:\n\t\tdbgfs_bf->bf_escape_timer = value;\n\t\tbreak;\n\tcase MVM_DEBUGFS_BA_ENABLE_BEACON_ABORT:\n\t\tdbgfs_bf->ba_enable_beacon_abort = value;\n\t\tbreak;\n\tcase MVM_DEBUGFS_BA_ESCAPE_TIMER:\n\t\tdbgfs_bf->ba_escape_timer = value;\n\t\tbreak;\n\t}\n}\n\nstatic ssize_t iwl_dbgfs_bf_params_write(struct ieee80211_vif *vif, char *buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm *mvm = mvmvif->mvm;\n\tenum iwl_dbgfs_bf_mask param;\n\tint value, ret = 0;\n\n\tif (!strncmp(\"bf_energy_delta=\", buf, 16)) {\n\t\tif (sscanf(buf+16, \"%d\", &value) != 1)\n\t\t\treturn -EINVAL;\n\t\tif (value < IWL_BF_ENERGY_DELTA_MIN ||\n\t\t    value > IWL_BF_ENERGY_DELTA_MAX)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_BF_ENERGY_DELTA;\n\t} else if (!strncmp(\"bf_roaming_energy_delta=\", buf, 24)) {\n\t\tif (sscanf(buf+24, \"%d\", &value) != 1)\n\t\t\treturn -EINVAL;\n\t\tif (value < IWL_BF_ROAMING_ENERGY_DELTA_MIN ||\n\t\t    value > IWL_BF_ROAMING_ENERGY_DELTA_MAX)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_BF_ROAMING_ENERGY_DELTA;\n\t} else if (!strncmp(\"bf_roaming_state=\", buf, 17)) {\n\t\tif (sscanf(buf+17, \"%d\", &value) != 1)\n\t\t\treturn -EINVAL;\n\t\tif (value < IWL_BF_ROAMING_STATE_MIN ||\n\t\t    value > IWL_BF_ROAMING_STATE_MAX)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_BF_ROAMING_STATE;\n\t} else if (!strncmp(\"bf_temp_threshold=\", buf, 18)) {\n\t\tif (sscanf(buf+18, \"%d\", &value) != 1)\n\t\t\treturn -EINVAL;\n\t\tif (value < IWL_BF_TEMP_THRESHOLD_MIN ||\n\t\t    value > IWL_BF_TEMP_THRESHOLD_MAX)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_BF_TEMP_THRESHOLD;\n\t} else if (!strncmp(\"bf_temp_fast_filter=\", buf, 20)) {\n\t\tif (sscanf(buf+20, \"%d\", &value) != 1)\n\t\t\treturn -EINVAL;\n\t\tif (value < IWL_BF_TEMP_FAST_FILTER_MIN ||\n\t\t    value > IWL_BF_TEMP_FAST_FILTER_MAX)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_BF_TEMP_FAST_FILTER;\n\t} else if (!strncmp(\"bf_temp_slow_filter=\", buf, 20)) {\n\t\tif (sscanf(buf+20, \"%d\", &value) != 1)\n\t\t\treturn -EINVAL;\n\t\tif (value < IWL_BF_TEMP_SLOW_FILTER_MIN ||\n\t\t    value > IWL_BF_TEMP_SLOW_FILTER_MAX)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_BF_TEMP_SLOW_FILTER;\n\t} else if (!strncmp(\"bf_enable_beacon_filter=\", buf, 24)) {\n\t\tif (sscanf(buf+24, \"%d\", &value) != 1)\n\t\t\treturn -EINVAL;\n\t\tif (value < 0 || value > 1)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_BF_ENABLE_BEACON_FILTER;\n\t} else if (!strncmp(\"bf_debug_flag=\", buf, 14)) {\n\t\tif (sscanf(buf+14, \"%d\", &value) != 1)\n\t\t\treturn -EINVAL;\n\t\tif (value < 0 || value > 1)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_BF_DEBUG_FLAG;\n\t} else if (!strncmp(\"bf_escape_timer=\", buf, 16)) {\n\t\tif (sscanf(buf+16, \"%d\", &value) != 1)\n\t\t\treturn -EINVAL;\n\t\tif (value < IWL_BF_ESCAPE_TIMER_MIN ||\n\t\t    value > IWL_BF_ESCAPE_TIMER_MAX)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_BF_ESCAPE_TIMER;\n\t} else if (!strncmp(\"ba_escape_timer=\", buf, 16)) {\n\t\tif (sscanf(buf+16, \"%d\", &value) != 1)\n\t\t\treturn -EINVAL;\n\t\tif (value < IWL_BA_ESCAPE_TIMER_MIN ||\n\t\t    value > IWL_BA_ESCAPE_TIMER_MAX)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_BA_ESCAPE_TIMER;\n\t} else if (!strncmp(\"ba_enable_beacon_abort=\", buf, 23)) {\n\t\tif (sscanf(buf+23, \"%d\", &value) != 1)\n\t\t\treturn -EINVAL;\n\t\tif (value < 0 || value > 1)\n\t\t\treturn -EINVAL;\n\t\tparam = MVM_DEBUGFS_BA_ENABLE_BEACON_ABORT;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&mvm->mutex);\n\tiwl_dbgfs_update_bf(vif, param, value);\n\tif (param == MVM_DEBUGFS_BF_ENABLE_BEACON_FILTER && !value)\n\t\tret = iwl_mvm_disable_beacon_filter(mvm, vif, 0);\n\telse\n\t\tret = iwl_mvm_enable_beacon_filter(mvm, vif, 0);\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret ?: count;\n}\n\nstatic ssize_t iwl_dbgfs_bf_params_read(struct file *file,\n\t\t\t\t\tchar __user *user_buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ieee80211_vif *vif = file->private_data;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tchar buf[256];\n\tint pos = 0;\n\tconst size_t bufsz = sizeof(buf);\n\tstruct iwl_beacon_filter_cmd cmd = {\n\t\tIWL_BF_CMD_CONFIG_DEFAULTS,\n\t\t.bf_enable_beacon_filter =\n\t\t\tcpu_to_le32(IWL_BF_ENABLE_BEACON_FILTER_DEFAULT),\n\t\t.ba_enable_beacon_abort =\n\t\t\tcpu_to_le32(IWL_BA_ENABLE_BEACON_ABORT_DEFAULT),\n\t};\n\n\tiwl_mvm_beacon_filter_debugfs_parameters(vif, &cmd);\n\tif (mvmvif->bf_data.bf_enabled)\n\t\tcmd.bf_enable_beacon_filter = cpu_to_le32(1);\n\telse\n\t\tcmd.bf_enable_beacon_filter = 0;\n\n\tpos += scnprintf(buf+pos, bufsz-pos, \"bf_energy_delta = %d\\n\",\n\t\t\t le32_to_cpu(cmd.bf_energy_delta));\n\tpos += scnprintf(buf+pos, bufsz-pos, \"bf_roaming_energy_delta = %d\\n\",\n\t\t\t le32_to_cpu(cmd.bf_roaming_energy_delta));\n\tpos += scnprintf(buf+pos, bufsz-pos, \"bf_roaming_state = %d\\n\",\n\t\t\t le32_to_cpu(cmd.bf_roaming_state));\n\tpos += scnprintf(buf+pos, bufsz-pos, \"bf_temp_threshold = %d\\n\",\n\t\t\t le32_to_cpu(cmd.bf_temp_threshold));\n\tpos += scnprintf(buf+pos, bufsz-pos, \"bf_temp_fast_filter = %d\\n\",\n\t\t\t le32_to_cpu(cmd.bf_temp_fast_filter));\n\tpos += scnprintf(buf+pos, bufsz-pos, \"bf_temp_slow_filter = %d\\n\",\n\t\t\t le32_to_cpu(cmd.bf_temp_slow_filter));\n\tpos += scnprintf(buf+pos, bufsz-pos, \"bf_enable_beacon_filter = %d\\n\",\n\t\t\t le32_to_cpu(cmd.bf_enable_beacon_filter));\n\tpos += scnprintf(buf+pos, bufsz-pos, \"bf_debug_flag = %d\\n\",\n\t\t\t le32_to_cpu(cmd.bf_debug_flag));\n\tpos += scnprintf(buf+pos, bufsz-pos, \"bf_escape_timer = %d\\n\",\n\t\t\t le32_to_cpu(cmd.bf_escape_timer));\n\tpos += scnprintf(buf+pos, bufsz-pos, \"ba_escape_timer = %d\\n\",\n\t\t\t le32_to_cpu(cmd.ba_escape_timer));\n\tpos += scnprintf(buf+pos, bufsz-pos, \"ba_enable_beacon_abort = %d\\n\",\n\t\t\t le32_to_cpu(cmd.ba_enable_beacon_abort));\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\nstatic ssize_t iwl_dbgfs_os_device_timediff_read(struct file *file,\n\t\t\t\t\t\t char __user *user_buf,\n\t\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_vif *vif = file->private_data;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm *mvm = mvmvif->mvm;\n\tu32 curr_gp2;\n\tu64 curr_os;\n\ts64 diff;\n\tchar buf[64];\n\tconst size_t bufsz = sizeof(buf);\n\tint pos = 0;\n\n\tmutex_lock(&mvm->mutex);\n\tiwl_mvm_get_sync_time(mvm, CLOCK_BOOTTIME, &curr_gp2, &curr_os, NULL);\n\tmutex_unlock(&mvm->mutex);\n\n\tdo_div(curr_os, NSEC_PER_USEC);\n\tdiff = curr_os - curr_gp2;\n\tpos += scnprintf(buf + pos, bufsz - pos, \"diff=%lld\\n\", diff);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\nstatic ssize_t iwl_dbgfs_low_latency_write(struct ieee80211_vif *vif, char *buf,\n\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm *mvm = mvmvif->mvm;\n\tu8 value;\n\tint ret;\n\n\tret = kstrtou8(buf, 0, &value);\n\tif (ret)\n\t\treturn ret;\n\tif (value > 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mvm->mutex);\n\tiwl_mvm_update_low_latency(mvm, vif, value, LOW_LATENCY_DEBUGFS);\n\tmutex_unlock(&mvm->mutex);\n\n\treturn count;\n}\n\nstatic ssize_t\niwl_dbgfs_low_latency_force_write(struct ieee80211_vif *vif, char *buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm *mvm = mvmvif->mvm;\n\tu8 value;\n\tint ret;\n\n\tret = kstrtou8(buf, 0, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tif (value > NUM_LOW_LATENCY_FORCE)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mvm->mutex);\n\tif (value == LOW_LATENCY_FORCE_UNSET) {\n\t\tiwl_mvm_update_low_latency(mvm, vif, false,\n\t\t\t\t\t   LOW_LATENCY_DEBUGFS_FORCE);\n\t\tiwl_mvm_update_low_latency(mvm, vif, false,\n\t\t\t\t\t   LOW_LATENCY_DEBUGFS_FORCE_ENABLE);\n\t} else {\n\t\tiwl_mvm_update_low_latency(mvm, vif,\n\t\t\t\t\t   value == LOW_LATENCY_FORCE_ON,\n\t\t\t\t\t   LOW_LATENCY_DEBUGFS_FORCE);\n\t\tiwl_mvm_update_low_latency(mvm, vif, true,\n\t\t\t\t\t   LOW_LATENCY_DEBUGFS_FORCE_ENABLE);\n\t}\n\tmutex_unlock(&mvm->mutex);\n\treturn count;\n}\n\nstatic ssize_t iwl_dbgfs_low_latency_read(struct file *file,\n\t\t\t\t\t  char __user *user_buf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_vif *vif = file->private_data;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tchar format[] = \"traffic=%d\\ndbgfs=%d\\nvcmd=%d\\nvif_type=%d\\n\"\n\t\t\t\"dbgfs_force_enable=%d\\ndbgfs_force=%d\\nactual=%d\\n\";\n\n\t \n\tchar buf[sizeof(format) + 1] = {};\n\tint len;\n\n\tlen = scnprintf(buf, sizeof(buf) - 1, format,\n\t\t\t!!(mvmvif->low_latency & LOW_LATENCY_TRAFFIC),\n\t\t\t!!(mvmvif->low_latency & LOW_LATENCY_DEBUGFS),\n\t\t\t!!(mvmvif->low_latency & LOW_LATENCY_VCMD),\n\t\t\t!!(mvmvif->low_latency & LOW_LATENCY_VIF_TYPE),\n\t\t\t!!(mvmvif->low_latency &\n\t\t\t   LOW_LATENCY_DEBUGFS_FORCE_ENABLE),\n\t\t\t!!(mvmvif->low_latency & LOW_LATENCY_DEBUGFS_FORCE),\n\t\t\t!!(mvmvif->low_latency_actual));\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t iwl_dbgfs_uapsd_misbehaving_read(struct file *file,\n\t\t\t\t\t\tchar __user *user_buf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ieee80211_vif *vif = file->private_data;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tchar buf[20];\n\tint len;\n\n\tlen = sprintf(buf, \"%pM\\n\", mvmvif->uapsd_misbehaving_ap_addr);\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t iwl_dbgfs_uapsd_misbehaving_write(struct ieee80211_vif *vif,\n\t\t\t\t\t\t char *buf, size_t count,\n\t\t\t\t\t\t loff_t *ppos)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm *mvm = mvmvif->mvm;\n\tbool ret;\n\n\tmutex_lock(&mvm->mutex);\n\tret = mac_pton(buf, mvmvif->uapsd_misbehaving_ap_addr);\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret ? count : -EINVAL;\n}\n\nstatic ssize_t iwl_dbgfs_rx_phyinfo_write(struct ieee80211_vif *vif, char *buf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm *mvm = mvmvif->mvm;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct iwl_mvm_phy_ctxt *phy_ctxt;\n\tu16 value;\n\tint ret;\n\n\tret = kstrtou16(buf, 0, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&mvm->mutex);\n\trcu_read_lock();\n\n\tchanctx_conf = rcu_dereference(vif->bss_conf.chanctx_conf);\n\t \n\tif (!chanctx_conf) {\n\t\trcu_read_unlock();\n\t\tmutex_unlock(&mvm->mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tphy_ctxt = &mvm->phy_ctxts[*(u16 *)chanctx_conf->drv_priv];\n\trcu_read_unlock();\n\n\tmvm->dbgfs_rx_phyinfo = value;\n\n\tret = iwl_mvm_phy_ctxt_changed(mvm, phy_ctxt, &chanctx_conf->min_def,\n\t\t\t\t       chanctx_conf->rx_chains_static,\n\t\t\t\t       chanctx_conf->rx_chains_dynamic);\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret ?: count;\n}\n\nstatic ssize_t iwl_dbgfs_rx_phyinfo_read(struct file *file,\n\t\t\t\t\t char __user *user_buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_vif *vif = file->private_data;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tchar buf[8];\n\tint len;\n\n\tlen = scnprintf(buf, sizeof(buf), \"0x%04x\\n\",\n\t\t\tmvmvif->mvm->dbgfs_rx_phyinfo);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic void iwl_dbgfs_quota_check(void *data, u8 *mac,\n\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tint *ret = data;\n\n\tif (mvmvif->dbgfs_quota_min)\n\t\t*ret = -EINVAL;\n}\n\nstatic ssize_t iwl_dbgfs_quota_min_write(struct ieee80211_vif *vif, char *buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm *mvm = mvmvif->mvm;\n\tu16 value;\n\tint ret;\n\n\tret = kstrtou16(buf, 0, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tif (value > 95)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mvm->mutex);\n\n\tmvmvif->dbgfs_quota_min = 0;\n\tieee80211_iterate_interfaces(mvm->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t     iwl_dbgfs_quota_check, &ret);\n\tif (ret == 0) {\n\t\tmvmvif->dbgfs_quota_min = value;\n\t\tiwl_mvm_update_quotas(mvm, false, NULL);\n\t}\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret ?: count;\n}\n\nstatic ssize_t iwl_dbgfs_quota_min_read(struct file *file,\n\t\t\t\t\tchar __user *user_buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ieee80211_vif *vif = file->private_data;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tchar buf[10];\n\tint len;\n\n\tlen = scnprintf(buf, sizeof(buf), \"%d\\n\", mvmvif->dbgfs_quota_min);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\n#define MVM_DEBUGFS_WRITE_FILE_OPS(name, bufsz) \\\n\t_MVM_DEBUGFS_WRITE_FILE_OPS(name, bufsz, struct ieee80211_vif)\n#define MVM_DEBUGFS_READ_WRITE_FILE_OPS(name, bufsz) \\\n\t_MVM_DEBUGFS_READ_WRITE_FILE_OPS(name, bufsz, struct ieee80211_vif)\n#define MVM_DEBUGFS_ADD_FILE_VIF(name, parent, mode) do {\t\t\\\n\t\tdebugfs_create_file(#name, mode, parent, vif,\t\t\\\n\t\t\t\t    &iwl_dbgfs_##name##_ops);\t\t\\\n\t} while (0)\n\nMVM_DEBUGFS_READ_FILE_OPS(mac_params);\nMVM_DEBUGFS_READ_FILE_OPS(tx_pwr_lmt);\nMVM_DEBUGFS_READ_WRITE_FILE_OPS(pm_params, 32);\nMVM_DEBUGFS_READ_WRITE_FILE_OPS(bf_params, 256);\nMVM_DEBUGFS_READ_WRITE_FILE_OPS(low_latency, 10);\nMVM_DEBUGFS_WRITE_FILE_OPS(low_latency_force, 10);\nMVM_DEBUGFS_READ_WRITE_FILE_OPS(uapsd_misbehaving, 20);\nMVM_DEBUGFS_READ_WRITE_FILE_OPS(rx_phyinfo, 10);\nMVM_DEBUGFS_READ_WRITE_FILE_OPS(quota_min, 32);\nMVM_DEBUGFS_READ_FILE_OPS(os_device_timediff);\n\n\nvoid iwl_mvm_vif_dbgfs_register(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tstruct dentry *dbgfs_dir = vif->debugfs_dir;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tchar buf[100];\n\n\t \n\tif (!dbgfs_dir || mvmvif->dbgfs_dir)\n\t\treturn;\n\n\tmvmvif->dbgfs_dir = debugfs_create_dir(\"iwlmvm\", dbgfs_dir);\n\tif (IS_ERR_OR_NULL(mvmvif->dbgfs_dir)) {\n\t\tIWL_ERR(mvm, \"Failed to create debugfs directory under %pd\\n\",\n\t\t\tdbgfs_dir);\n\t\treturn;\n\t}\n\n\tif (iwlmvm_mod_params.power_scheme != IWL_POWER_SCHEME_CAM &&\n\t    ((vif->type == NL80211_IFTYPE_STATION && !vif->p2p) ||\n\t     (vif->type == NL80211_IFTYPE_STATION && vif->p2p)))\n\t\tMVM_DEBUGFS_ADD_FILE_VIF(pm_params, mvmvif->dbgfs_dir, 0600);\n\n\tMVM_DEBUGFS_ADD_FILE_VIF(tx_pwr_lmt, mvmvif->dbgfs_dir, 0400);\n\tMVM_DEBUGFS_ADD_FILE_VIF(mac_params, mvmvif->dbgfs_dir, 0400);\n\tMVM_DEBUGFS_ADD_FILE_VIF(low_latency, mvmvif->dbgfs_dir, 0600);\n\tMVM_DEBUGFS_ADD_FILE_VIF(low_latency_force, mvmvif->dbgfs_dir, 0600);\n\tMVM_DEBUGFS_ADD_FILE_VIF(uapsd_misbehaving, mvmvif->dbgfs_dir, 0600);\n\tMVM_DEBUGFS_ADD_FILE_VIF(rx_phyinfo, mvmvif->dbgfs_dir, 0600);\n\tMVM_DEBUGFS_ADD_FILE_VIF(quota_min, mvmvif->dbgfs_dir, 0600);\n\tMVM_DEBUGFS_ADD_FILE_VIF(os_device_timediff, mvmvif->dbgfs_dir, 0400);\n\n\tif (vif->type == NL80211_IFTYPE_STATION && !vif->p2p &&\n\t    mvmvif == mvm->bf_allowed_vif)\n\t\tMVM_DEBUGFS_ADD_FILE_VIF(bf_params, mvmvif->dbgfs_dir, 0600);\n\n\t \n\tsnprintf(buf, 100, \"../../../%pd3/%pd\",\n\t\t dbgfs_dir,\n\t\t mvmvif->dbgfs_dir);\n\n\tmvmvif->dbgfs_slink = debugfs_create_symlink(dbgfs_dir->d_name.name,\n\t\t\t\t\t\t     mvm->debugfs_dir, buf);\n}\n\nvoid iwl_mvm_vif_dbgfs_clean(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tdebugfs_remove(mvmvif->dbgfs_slink);\n\tmvmvif->dbgfs_slink = NULL;\n\n\tdebugfs_remove_recursive(mvmvif->dbgfs_dir);\n\tmvmvif->dbgfs_dir = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}