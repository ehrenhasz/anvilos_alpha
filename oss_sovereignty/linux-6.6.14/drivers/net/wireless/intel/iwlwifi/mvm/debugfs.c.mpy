{
  "module_name": "debugfs.c",
  "hash_id": "3b4a904cabacfa4e0d03e5bfe89b3bfaf1d6234bd83884c8a40d6ffd2e5a45b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/debugfs.c",
  "human_readable_source": "\n \n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/ieee80211.h>\n#include <linux/netdevice.h>\n#include <linux/dmi.h>\n\n#include \"mvm.h\"\n#include \"sta.h\"\n#include \"iwl-io.h\"\n#include \"debugfs.h\"\n#include \"iwl-modparams.h\"\n#include \"iwl-drv.h\"\n#include \"fw/error-dump.h\"\n#include \"fw/api/phy-ctxt.h\"\n\nstatic ssize_t iwl_dbgfs_ctdp_budget_read(struct file *file,\n\t\t\t\t\t  char __user *user_buf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm *mvm = file->private_data;\n\tchar buf[16];\n\tint pos, budget;\n\n\tif (!iwl_mvm_is_ctdp_supported(mvm))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!iwl_mvm_firmware_running(mvm) ||\n\t    mvm->fwrt.cur_fw_img != IWL_UCODE_REGULAR)\n\t\treturn -EIO;\n\n\tmutex_lock(&mvm->mutex);\n\tbudget = iwl_mvm_ctdp_command(mvm, CTDP_CMD_OPERATION_REPORT, 0);\n\tmutex_unlock(&mvm->mutex);\n\n\tif (budget < 0)\n\t\treturn budget;\n\n\tpos = scnprintf(buf, sizeof(buf), \"%d\\n\", budget);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\nstatic ssize_t iwl_dbgfs_stop_ctdp_write(struct iwl_mvm *mvm, char *buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tint ret;\n\n\tif (!iwl_mvm_is_ctdp_supported(mvm))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!iwl_mvm_firmware_running(mvm) ||\n\t    mvm->fwrt.cur_fw_img != IWL_UCODE_REGULAR)\n\t\treturn -EIO;\n\n\tmutex_lock(&mvm->mutex);\n\tret = iwl_mvm_ctdp_command(mvm, CTDP_CMD_OPERATION_STOP, 0);\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret ?: count;\n}\n\nstatic ssize_t iwl_dbgfs_force_ctkill_write(struct iwl_mvm *mvm, char *buf,\n\t\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tif (!iwl_mvm_firmware_running(mvm) ||\n\t    mvm->fwrt.cur_fw_img != IWL_UCODE_REGULAR)\n\t\treturn -EIO;\n\n\tiwl_mvm_enter_ctkill(mvm);\n\n\treturn count;\n}\n\nstatic ssize_t iwl_dbgfs_tx_flush_write(struct iwl_mvm *mvm, char *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tint ret;\n\tu32 flush_arg;\n\n\tif (!iwl_mvm_firmware_running(mvm) ||\n\t    mvm->fwrt.cur_fw_img != IWL_UCODE_REGULAR)\n\t\treturn -EIO;\n\n\tif (kstrtou32(buf, 0, &flush_arg))\n\t\treturn -EINVAL;\n\n\tif (iwl_mvm_has_new_tx_api(mvm)) {\n\t\tIWL_DEBUG_TX_QUEUES(mvm,\n\t\t\t\t    \"FLUSHING all tids queues on sta_id = %d\\n\",\n\t\t\t\t    flush_arg);\n\t\tmutex_lock(&mvm->mutex);\n\t\tret = iwl_mvm_flush_sta_tids(mvm, flush_arg, 0xFFFF)\n\t\t\t? : count;\n\t\tmutex_unlock(&mvm->mutex);\n\t\treturn ret;\n\t}\n\n\tIWL_DEBUG_TX_QUEUES(mvm, \"FLUSHING queues mask to flush = 0x%x\\n\",\n\t\t\t    flush_arg);\n\n\tmutex_lock(&mvm->mutex);\n\tret =  iwl_mvm_flush_tx_path(mvm, flush_arg) ? : count;\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t iwl_dbgfs_sta_drain_write(struct iwl_mvm *mvm, char *buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm_sta *mvmsta;\n\tint sta_id, drain, ret;\n\n\tif (!iwl_mvm_firmware_running(mvm) ||\n\t    mvm->fwrt.cur_fw_img != IWL_UCODE_REGULAR)\n\t\treturn -EIO;\n\n\tif (sscanf(buf, \"%d %d\", &sta_id, &drain) != 2)\n\t\treturn -EINVAL;\n\tif (sta_id < 0 || sta_id >= mvm->fw->ucode_capa.num_stations)\n\t\treturn -EINVAL;\n\tif (drain < 0 || drain > 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mvm->mutex);\n\n\tmvmsta = iwl_mvm_sta_from_staid_protected(mvm, sta_id);\n\n\tif (!mvmsta)\n\t\tret = -ENOENT;\n\telse\n\t\tret = iwl_mvm_drain_sta(mvm, mvmsta, drain) ? : count;\n\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t iwl_dbgfs_sram_read(struct file *file, char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm *mvm = file->private_data;\n\tconst struct fw_img *img;\n\tunsigned int ofs, len;\n\tsize_t ret;\n\tu8 *ptr;\n\n\tif (!iwl_mvm_firmware_running(mvm))\n\t\treturn -EINVAL;\n\n\t \n\timg = &mvm->fw->img[mvm->fwrt.cur_fw_img];\n\tofs = img->sec[IWL_UCODE_SECTION_DATA].offset;\n\tlen = img->sec[IWL_UCODE_SECTION_DATA].len;\n\n\tif (mvm->dbgfs_sram_len) {\n\t\tofs = mvm->dbgfs_sram_offset;\n\t\tlen = mvm->dbgfs_sram_len;\n\t}\n\n\tptr = kzalloc(len, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\tiwl_trans_read_mem_bytes(mvm->trans, ofs, ptr, len);\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, ptr, len);\n\n\tkfree(ptr);\n\n\treturn ret;\n}\n\nstatic ssize_t iwl_dbgfs_sram_write(struct iwl_mvm *mvm, char *buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tconst struct fw_img *img;\n\tu32 offset, len;\n\tu32 img_offset, img_len;\n\n\tif (!iwl_mvm_firmware_running(mvm))\n\t\treturn -EINVAL;\n\n\timg = &mvm->fw->img[mvm->fwrt.cur_fw_img];\n\timg_offset = img->sec[IWL_UCODE_SECTION_DATA].offset;\n\timg_len = img->sec[IWL_UCODE_SECTION_DATA].len;\n\n\tif (sscanf(buf, \"%x,%x\", &offset, &len) == 2) {\n\t\tif ((offset & 0x3) || (len & 0x3))\n\t\t\treturn -EINVAL;\n\n\t\tif (offset + len > img_offset + img_len)\n\t\t\treturn -EINVAL;\n\n\t\tmvm->dbgfs_sram_offset = offset;\n\t\tmvm->dbgfs_sram_len = len;\n\t} else {\n\t\tmvm->dbgfs_sram_offset = 0;\n\t\tmvm->dbgfs_sram_len = 0;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t iwl_dbgfs_set_nic_temperature_read(struct file *file,\n\t\t\t\t\t\t  char __user *user_buf,\n\t\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm *mvm = file->private_data;\n\tchar buf[16];\n\tint pos;\n\n\tif (!mvm->temperature_test)\n\t\tpos = scnprintf(buf, sizeof(buf), \"disabled\\n\");\n\telse\n\t\tpos = scnprintf(buf, sizeof(buf), \"%d\\n\", mvm->temperature);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\n \nstatic ssize_t iwl_dbgfs_set_nic_temperature_write(struct iwl_mvm *mvm,\n\t\t\t\t\t\t   char *buf, size_t count,\n\t\t\t\t\t\t   loff_t *ppos)\n{\n\tint temperature;\n\n\tif (!iwl_mvm_firmware_running(mvm) && !mvm->temperature_test)\n\t\treturn -EIO;\n\n\tif (kstrtoint(buf, 10, &temperature))\n\t\treturn -EINVAL;\n\t \n\tif ((temperature > IWL_MVM_DEBUG_SET_TEMPERATURE_MAX &&\n\t     temperature != IWL_MVM_DEBUG_SET_TEMPERATURE_DISABLE) ||\n\t    temperature < IWL_MVM_DEBUG_SET_TEMPERATURE_MIN)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mvm->mutex);\n\tif (temperature == IWL_MVM_DEBUG_SET_TEMPERATURE_DISABLE) {\n\t\tif (!mvm->temperature_test)\n\t\t\tgoto out;\n\n\t\tmvm->temperature_test = false;\n\t\t \n\t\tmvm->temperature = 0;\n\t} else {\n\t\tmvm->temperature_test = true;\n\t\tmvm->temperature = temperature;\n\t}\n\tIWL_DEBUG_TEMP(mvm, \"%sabling debug set temperature (temp = %d)\\n\",\n\t\t       mvm->temperature_test ? \"En\" : \"Dis\",\n\t\t       mvm->temperature);\n\t \n\tiwl_mvm_tt_handler(mvm);\n\nout:\n\tmutex_unlock(&mvm->mutex);\n\n\treturn count;\n}\n\nstatic ssize_t iwl_dbgfs_nic_temp_read(struct file *file,\n\t\t\t\t       char __user *user_buf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm *mvm = file->private_data;\n\tchar buf[16];\n\tint pos, ret;\n\ts32 temp;\n\n\tif (!iwl_mvm_firmware_running(mvm))\n\t\treturn -EIO;\n\n\tmutex_lock(&mvm->mutex);\n\tret = iwl_mvm_get_temp(mvm, &temp);\n\tmutex_unlock(&mvm->mutex);\n\n\tif (ret)\n\t\treturn -EIO;\n\n\tpos = scnprintf(buf, sizeof(buf), \"%d\\n\", temp);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\n#ifdef CONFIG_ACPI\nstatic ssize_t iwl_dbgfs_sar_geo_profile_read(struct file *file,\n\t\t\t\t\t      char __user *user_buf,\n\t\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm *mvm = file->private_data;\n\tchar buf[256];\n\tint pos = 0;\n\tint bufsz = sizeof(buf);\n\tint tbl_idx;\n\n\tif (!iwl_mvm_firmware_running(mvm))\n\t\treturn -EIO;\n\n\tmutex_lock(&mvm->mutex);\n\ttbl_idx = iwl_mvm_get_sar_geo_profile(mvm);\n\tif (tbl_idx < 0) {\n\t\tmutex_unlock(&mvm->mutex);\n\t\treturn tbl_idx;\n\t}\n\n\tif (!tbl_idx) {\n\t\tpos = scnprintf(buf, bufsz,\n\t\t\t\t\"SAR geographic profile disabled\\n\");\n\t} else {\n\t\tpos += scnprintf(buf + pos, bufsz - pos,\n\t\t\t\t \"Use geographic profile %d\\n\", tbl_idx);\n\t\tpos += scnprintf(buf + pos, bufsz - pos,\n\t\t\t\t \"2.4GHz:\\n\\tChain A offset: %u dBm\\n\\tChain B offset: %u dBm\\n\\tmax tx power: %u dBm\\n\",\n\t\t\t\t mvm->fwrt.geo_profiles[tbl_idx - 1].bands[0].chains[0],\n\t\t\t\t mvm->fwrt.geo_profiles[tbl_idx - 1].bands[0].chains[1],\n\t\t\t\t mvm->fwrt.geo_profiles[tbl_idx - 1].bands[0].max);\n\t\tpos += scnprintf(buf + pos, bufsz - pos,\n\t\t\t\t \"5.2GHz:\\n\\tChain A offset: %u dBm\\n\\tChain B offset: %u dBm\\n\\tmax tx power: %u dBm\\n\",\n\t\t\t\t mvm->fwrt.geo_profiles[tbl_idx - 1].bands[1].chains[0],\n\t\t\t\t mvm->fwrt.geo_profiles[tbl_idx - 1].bands[1].chains[1],\n\t\t\t\t mvm->fwrt.geo_profiles[tbl_idx - 1].bands[1].max);\n\t}\n\tmutex_unlock(&mvm->mutex);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\nstatic ssize_t iwl_dbgfs_wifi_6e_enable_read(struct file *file,\n\t\t\t\t\t     char __user *user_buf,\n\t\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm *mvm = file->private_data;\n\tint err, pos;\n\tchar buf[12];\n\tu32 value;\n\n\terr = iwl_acpi_get_dsm_u32(mvm->fwrt.dev, 0,\n\t\t\t\t   DSM_FUNC_ENABLE_6E,\n\t\t\t\t   &iwl_guid, &value);\n\tif (err)\n\t\treturn err;\n\n\tpos = sprintf(buf, \"0x%08x\\n\", value);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n#endif\n\nstatic ssize_t iwl_dbgfs_stations_read(struct file *file, char __user *user_buf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm *mvm = file->private_data;\n\tstruct ieee80211_sta *sta;\n\tchar buf[400];\n\tint i, pos = 0, bufsz = sizeof(buf);\n\n\tmutex_lock(&mvm->mutex);\n\n\tfor (i = 0; i < mvm->fw->ucode_capa.num_stations; i++) {\n\t\tpos += scnprintf(buf + pos, bufsz - pos, \"%.2d: \", i);\n\t\tsta = rcu_dereference_protected(mvm->fw_id_to_mac_id[i],\n\t\t\t\t\t\tlockdep_is_held(&mvm->mutex));\n\t\tif (!sta)\n\t\t\tpos += scnprintf(buf + pos, bufsz - pos, \"N/A\\n\");\n\t\telse if (IS_ERR(sta))\n\t\t\tpos += scnprintf(buf + pos, bufsz - pos, \"%ld\\n\",\n\t\t\t\t\t PTR_ERR(sta));\n\t\telse\n\t\t\tpos += scnprintf(buf + pos, bufsz - pos, \"%pM\\n\",\n\t\t\t\t\t sta->addr);\n\t}\n\n\tmutex_unlock(&mvm->mutex);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\nstatic ssize_t iwl_dbgfs_rs_data_read(struct ieee80211_link_sta *link_sta,\n\t\t\t\t      struct iwl_mvm_sta *mvmsta,\n\t\t\t\t      struct iwl_mvm *mvm,\n\t\t\t\t      struct iwl_mvm_link_sta *mvm_link_sta,\n\t\t\t\t      char __user *user_buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct iwl_lq_sta_rs_fw *lq_sta = &mvm_link_sta->lq_sta.rs_fw;\n\tstatic const size_t bufsz = 2048;\n\tchar *buff;\n\tint desc = 0;\n\tssize_t ret;\n\n\tbuff = kmalloc(bufsz, GFP_KERNEL);\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\tdesc += scnprintf(buff + desc, bufsz - desc, \"sta_id %d\\n\",\n\t\t\t  lq_sta->pers.sta_id);\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"fixed rate 0x%X\\n\",\n\t\t\t  lq_sta->pers.dbg_fixed_rate);\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"A-MPDU size limit %d\\n\",\n\t\t\t  lq_sta->pers.dbg_agg_frame_count_lim);\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"valid_tx_ant %s%s\\n\",\n\t\t(iwl_mvm_get_valid_tx_ant(mvm) & ANT_A) ? \"ANT_A,\" : \"\",\n\t\t(iwl_mvm_get_valid_tx_ant(mvm) & ANT_B) ? \"ANT_B,\" : \"\");\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"last tx rate=0x%X \",\n\t\t\t  lq_sta->last_rate_n_flags);\n\n\tdesc += rs_pretty_print_rate(buff + desc, bufsz - desc,\n\t\t\t\t     lq_sta->last_rate_n_flags);\n\tif (desc < bufsz - 1)\n\t\tbuff[desc++] = '\\n';\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buff, desc);\n\tkfree(buff);\n\treturn ret;\n}\n\nstatic ssize_t iwl_dbgfs_amsdu_len_write(struct ieee80211_link_sta *link_sta,\n\t\t\t\t\t struct iwl_mvm_sta *mvmsta,\n\t\t\t\t\t struct iwl_mvm *mvm,\n\t\t\t\t\t struct iwl_mvm_link_sta *mvm_link_sta,\n\t\t\t\t\t char *buf, size_t count,\n\t\t\t\t\t loff_t *ppos)\n{\n\tint i;\n\tu16 amsdu_len;\n\n\tif (kstrtou16(buf, 0, &amsdu_len))\n\t\treturn -EINVAL;\n\n\t \n\tif (amsdu_len && mvm_link_sta->orig_amsdu_len)\n\t\treturn -EBUSY;\n\n\tif (amsdu_len) {\n\t\tmvm_link_sta->orig_amsdu_len = link_sta->agg.max_amsdu_len;\n\t\tlink_sta->agg.max_amsdu_len = amsdu_len;\n\t\tlink_sta->agg.max_amsdu_len = amsdu_len;\n\t\tfor (i = 0; i < ARRAY_SIZE(link_sta->agg.max_tid_amsdu_len); i++)\n\t\t\tlink_sta->agg.max_tid_amsdu_len[i] = amsdu_len;\n\t} else {\n\t\tlink_sta->agg.max_amsdu_len = mvm_link_sta->orig_amsdu_len;\n\t\tmvm_link_sta->orig_amsdu_len = 0;\n\t}\n\n\tieee80211_sta_recalc_aggregates(link_sta->sta);\n\n\treturn count;\n}\n\nstatic ssize_t iwl_dbgfs_amsdu_len_read(struct ieee80211_link_sta *link_sta,\n\t\t\t\t\tstruct iwl_mvm_sta *mvmsta,\n\t\t\t\t\tstruct iwl_mvm *mvm,\n\t\t\t\t\tstruct iwl_mvm_link_sta *mvm_link_sta,\n\t\t\t\t\tchar __user *user_buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar buf[32];\n\tint pos;\n\n\tpos = scnprintf(buf, sizeof(buf), \"current %d \",\n\t\t\tlink_sta->agg.max_amsdu_len);\n\tpos += scnprintf(buf + pos, sizeof(buf) - pos, \"stored %d\\n\",\n\t\t\t mvm_link_sta->orig_amsdu_len);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\nstatic ssize_t iwl_dbgfs_disable_power_off_read(struct file *file,\n\t\t\t\t\t\tchar __user *user_buf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm *mvm = file->private_data;\n\tchar buf[64];\n\tint bufsz = sizeof(buf);\n\tint pos = 0;\n\n\tpos += scnprintf(buf+pos, bufsz-pos, \"disable_power_off_d0=%d\\n\",\n\t\t\t mvm->disable_power_off);\n\tpos += scnprintf(buf+pos, bufsz-pos, \"disable_power_off_d3=%d\\n\",\n\t\t\t mvm->disable_power_off_d3);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\nstatic ssize_t iwl_dbgfs_disable_power_off_write(struct iwl_mvm *mvm, char *buf,\n\t\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tint ret, val;\n\n\tif (!iwl_mvm_firmware_running(mvm))\n\t\treturn -EIO;\n\n\tif (!strncmp(\"disable_power_off_d0=\", buf, 21)) {\n\t\tif (sscanf(buf + 21, \"%d\", &val) != 1)\n\t\t\treturn -EINVAL;\n\t\tmvm->disable_power_off = val;\n\t} else if (!strncmp(\"disable_power_off_d3=\", buf, 21)) {\n\t\tif (sscanf(buf + 21, \"%d\", &val) != 1)\n\t\t\treturn -EINVAL;\n\t\tmvm->disable_power_off_d3 = val;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&mvm->mutex);\n\tret = iwl_mvm_power_update_device(mvm);\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret ?: count;\n}\n\nstatic\nint iwl_mvm_coex_dump_mbox(struct iwl_bt_coex_profile_notif *notif, char *buf,\n\t\t\t   int pos, int bufsz)\n{\n\tpos += scnprintf(buf+pos, bufsz-pos, \"MBOX dw0:\\n\");\n\n\tBT_MBOX_PRINT(0, LE_SLAVE_LAT, false);\n\tBT_MBOX_PRINT(0, LE_PROF1, false);\n\tBT_MBOX_PRINT(0, LE_PROF2, false);\n\tBT_MBOX_PRINT(0, LE_PROF_OTHER, false);\n\tBT_MBOX_PRINT(0, CHL_SEQ_N, false);\n\tBT_MBOX_PRINT(0, INBAND_S, false);\n\tBT_MBOX_PRINT(0, LE_MIN_RSSI, false);\n\tBT_MBOX_PRINT(0, LE_SCAN, false);\n\tBT_MBOX_PRINT(0, LE_ADV, false);\n\tBT_MBOX_PRINT(0, LE_MAX_TX_POWER, false);\n\tBT_MBOX_PRINT(0, OPEN_CON_1, true);\n\n\tpos += scnprintf(buf+pos, bufsz-pos, \"MBOX dw1:\\n\");\n\n\tBT_MBOX_PRINT(1, BR_MAX_TX_POWER, false);\n\tBT_MBOX_PRINT(1, IP_SR, false);\n\tBT_MBOX_PRINT(1, LE_MSTR, false);\n\tBT_MBOX_PRINT(1, AGGR_TRFC_LD, false);\n\tBT_MBOX_PRINT(1, MSG_TYPE, false);\n\tBT_MBOX_PRINT(1, SSN, true);\n\n\tpos += scnprintf(buf+pos, bufsz-pos, \"MBOX dw2:\\n\");\n\n\tBT_MBOX_PRINT(2, SNIFF_ACT, false);\n\tBT_MBOX_PRINT(2, PAG, false);\n\tBT_MBOX_PRINT(2, INQUIRY, false);\n\tBT_MBOX_PRINT(2, CONN, false);\n\tBT_MBOX_PRINT(2, SNIFF_INTERVAL, false);\n\tBT_MBOX_PRINT(2, DISC, false);\n\tBT_MBOX_PRINT(2, SCO_TX_ACT, false);\n\tBT_MBOX_PRINT(2, SCO_RX_ACT, false);\n\tBT_MBOX_PRINT(2, ESCO_RE_TX, false);\n\tBT_MBOX_PRINT(2, SCO_DURATION, true);\n\n\tpos += scnprintf(buf+pos, bufsz-pos, \"MBOX dw3:\\n\");\n\n\tBT_MBOX_PRINT(3, SCO_STATE, false);\n\tBT_MBOX_PRINT(3, SNIFF_STATE, false);\n\tBT_MBOX_PRINT(3, A2DP_STATE, false);\n\tBT_MBOX_PRINT(3, A2DP_SRC, false);\n\tBT_MBOX_PRINT(3, ACL_STATE, false);\n\tBT_MBOX_PRINT(3, MSTR_STATE, false);\n\tBT_MBOX_PRINT(3, OBX_STATE, false);\n\tBT_MBOX_PRINT(3, OPEN_CON_2, false);\n\tBT_MBOX_PRINT(3, TRAFFIC_LOAD, false);\n\tBT_MBOX_PRINT(3, CHL_SEQN_LSB, false);\n\tBT_MBOX_PRINT(3, INBAND_P, false);\n\tBT_MBOX_PRINT(3, MSG_TYPE_2, false);\n\tBT_MBOX_PRINT(3, SSN_2, false);\n\tBT_MBOX_PRINT(3, UPDATE_REQUEST, true);\n\n\treturn pos;\n}\n\nstatic ssize_t iwl_dbgfs_bt_notif_read(struct file *file, char __user *user_buf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm *mvm = file->private_data;\n\tstruct iwl_bt_coex_profile_notif *notif = &mvm->last_bt_notif;\n\tchar *buf;\n\tint ret, pos = 0, bufsz = sizeof(char) * 1024;\n\n\tbuf = kmalloc(bufsz, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&mvm->mutex);\n\n\tpos += iwl_mvm_coex_dump_mbox(notif, buf, pos, bufsz);\n\n\tpos += scnprintf(buf + pos, bufsz - pos, \"bt_ci_compliance = %d\\n\",\n\t\t\t notif->bt_ci_compliance);\n\tpos += scnprintf(buf + pos, bufsz - pos, \"primary_ch_lut = %d\\n\",\n\t\t\t le32_to_cpu(notif->primary_ch_lut));\n\tpos += scnprintf(buf + pos, bufsz - pos, \"secondary_ch_lut = %d\\n\",\n\t\t\t le32_to_cpu(notif->secondary_ch_lut));\n\tpos += scnprintf(buf + pos,\n\t\t\t bufsz - pos, \"bt_activity_grading = %d\\n\",\n\t\t\t le32_to_cpu(notif->bt_activity_grading));\n\tpos += scnprintf(buf + pos, bufsz - pos, \"bt_rrc = %d\\n\",\n\t\t\t notif->rrc_status & 0xF);\n\tpos += scnprintf(buf + pos, bufsz - pos, \"bt_ttc = %d\\n\",\n\t\t\t notif->ttc_status & 0xF);\n\n\tpos += scnprintf(buf + pos, bufsz - pos, \"sync_sco = %d\\n\",\n\t\t\t IWL_MVM_BT_COEX_SYNC2SCO);\n\tpos += scnprintf(buf + pos, bufsz - pos, \"mplut = %d\\n\",\n\t\t\t IWL_MVM_BT_COEX_MPLUT);\n\n\tmutex_unlock(&mvm->mutex);\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n\tkfree(buf);\n\n\treturn ret;\n}\n#undef BT_MBOX_PRINT\n\nstatic ssize_t iwl_dbgfs_bt_cmd_read(struct file *file, char __user *user_buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm *mvm = file->private_data;\n\tstruct iwl_bt_coex_ci_cmd *cmd = &mvm->last_bt_ci_cmd;\n\tchar buf[256];\n\tint bufsz = sizeof(buf);\n\tint pos = 0;\n\n\tmutex_lock(&mvm->mutex);\n\n\tpos += scnprintf(buf + pos, bufsz - pos, \"Channel inhibition CMD\\n\");\n\tpos += scnprintf(buf + pos, bufsz - pos,\n\t\t\t \"\\tPrimary Channel Bitmap 0x%016llx\\n\",\n\t\t\t le64_to_cpu(cmd->bt_primary_ci));\n\tpos += scnprintf(buf + pos, bufsz - pos,\n\t\t\t \"\\tSecondary Channel Bitmap 0x%016llx\\n\",\n\t\t\t le64_to_cpu(cmd->bt_secondary_ci));\n\n\tmutex_unlock(&mvm->mutex);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\nstatic ssize_t\niwl_dbgfs_bt_tx_prio_write(struct iwl_mvm *mvm, char *buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tu32 bt_tx_prio;\n\n\tif (sscanf(buf, \"%u\", &bt_tx_prio) != 1)\n\t\treturn -EINVAL;\n\tif (bt_tx_prio > 4)\n\t\treturn -EINVAL;\n\n\tmvm->bt_tx_prio = bt_tx_prio;\n\n\treturn count;\n}\n\nstatic ssize_t\niwl_dbgfs_bt_force_ant_write(struct iwl_mvm *mvm, char *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tstatic const char * const modes_str[BT_FORCE_ANT_MAX] = {\n\t\t[BT_FORCE_ANT_DIS] = \"dis\",\n\t\t[BT_FORCE_ANT_AUTO] = \"auto\",\n\t\t[BT_FORCE_ANT_BT] = \"bt\",\n\t\t[BT_FORCE_ANT_WIFI] = \"wifi\",\n\t};\n\tint ret, bt_force_ant_mode;\n\n\tret = match_string(modes_str, ARRAY_SIZE(modes_str), buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbt_force_ant_mode = ret;\n\tret = 0;\n\tmutex_lock(&mvm->mutex);\n\tif (mvm->bt_force_ant_mode == bt_force_ant_mode)\n\t\tgoto out;\n\n\tmvm->bt_force_ant_mode = bt_force_ant_mode;\n\tIWL_DEBUG_COEX(mvm, \"Force mode: %s\\n\",\n\t\t       modes_str[mvm->bt_force_ant_mode]);\n\n\tif (iwl_mvm_firmware_running(mvm))\n\t\tret = iwl_mvm_send_bt_init_conf(mvm);\n\telse\n\t\tret = 0;\n\nout:\n\tmutex_unlock(&mvm->mutex);\n\treturn ret ?: count;\n}\n\nstatic ssize_t iwl_dbgfs_fw_ver_read(struct file *file, char __user *user_buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm *mvm = file->private_data;\n\tchar *buff, *pos, *endpos;\n\tstatic const size_t bufsz = 1024;\n\tchar _fw_name_pre[FW_NAME_PRE_BUFSIZE];\n\tint ret;\n\n\tbuff = kmalloc(bufsz, GFP_KERNEL);\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\tpos = buff;\n\tendpos = pos + bufsz;\n\n\tpos += scnprintf(pos, endpos - pos, \"FW prefix: %s\\n\",\n\t\t\t iwl_drv_get_fwname_pre(mvm->trans, _fw_name_pre));\n\tpos += scnprintf(pos, endpos - pos, \"FW: %s\\n\",\n\t\t\t mvm->fwrt.fw->human_readable);\n\tpos += scnprintf(pos, endpos - pos, \"Device: %s\\n\",\n\t\t\t mvm->fwrt.trans->name);\n\tpos += scnprintf(pos, endpos - pos, \"Bus: %s\\n\",\n\t\t\t mvm->fwrt.dev->bus->name);\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buff, pos - buff);\n\tkfree(buff);\n\n\treturn ret;\n}\n\nstatic ssize_t iwl_dbgfs_tas_get_status_read(struct file *file,\n\t\t\t\t\t     char __user *user_buf,\n\t\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm *mvm = file->private_data;\n\tstruct iwl_mvm_tas_status_resp tas_rsp;\n\tstruct iwl_mvm_tas_status_resp *rsp = &tas_rsp;\n\tstatic const size_t bufsz = 1024;\n\tchar *buff, *pos, *endpos;\n\tconst char * const tas_dis_reason[TAS_DISABLED_REASON_MAX] = {\n\t\t[TAS_DISABLED_DUE_TO_BIOS] =\n\t\t\t\"Due To BIOS\",\n\t\t[TAS_DISABLED_DUE_TO_SAR_6DBM] =\n\t\t\t\"Due To SAR Limit Less Than 6 dBm\",\n\t\t[TAS_DISABLED_REASON_INVALID] =\n\t\t\t\"N/A\",\n\t};\n\tconst char * const tas_current_status[TAS_DYNA_STATUS_MAX] = {\n\t\t[TAS_DYNA_INACTIVE] = \"INACTIVE\",\n\t\t[TAS_DYNA_INACTIVE_MVM_MODE] =\n\t\t\t\"inactive due to mvm mode\",\n\t\t[TAS_DYNA_INACTIVE_TRIGGER_MODE] =\n\t\t\t\"inactive due to trigger mode\",\n\t\t[TAS_DYNA_INACTIVE_BLOCK_LISTED] =\n\t\t\t\"inactive due to block listed\",\n\t\t[TAS_DYNA_INACTIVE_UHB_NON_US] =\n\t\t\t\"inactive due to uhb non US\",\n\t\t[TAS_DYNA_ACTIVE] = \"ACTIVE\",\n\t};\n\tstruct iwl_host_cmd hcmd = {\n\t\t.id = WIDE_ID(DEBUG_GROUP, GET_TAS_STATUS),\n\t\t.flags = CMD_WANT_SKB,\n\t\t.len = { 0, },\n\t\t.data = { NULL, },\n\t};\n\tint ret, i, tmp;\n\tbool tas_enabled = false;\n\tunsigned long dyn_status;\n\n\tif (!iwl_mvm_firmware_running(mvm))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&mvm->mutex);\n\tret = iwl_mvm_send_cmd(mvm, &hcmd);\n\tmutex_unlock(&mvm->mutex);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbuff = kzalloc(bufsz, GFP_KERNEL);\n\tif (!buff)\n\t\treturn -ENOMEM;\n\tpos = buff;\n\tendpos = pos + bufsz;\n\n\trsp = (void *)hcmd.resp_pkt->data;\n\n\tpos += scnprintf(pos, endpos - pos, \"TAS Conclusion:\\n\");\n\tfor (i = 0; i < rsp->in_dual_radio + 1; i++) {\n\t\tif (rsp->tas_status_mac[i].band != TAS_LMAC_BAND_INVALID &&\n\t\t    rsp->tas_status_mac[i].dynamic_status & BIT(TAS_DYNA_ACTIVE)) {\n\t\t\tpos += scnprintf(pos, endpos - pos, \"\\tON for \");\n\t\t\tswitch (rsp->tas_status_mac[i].band) {\n\t\t\tcase TAS_LMAC_BAND_HB:\n\t\t\t\tpos += scnprintf(pos, endpos - pos, \"HB\\n\");\n\t\t\t\tbreak;\n\t\t\tcase TAS_LMAC_BAND_LB:\n\t\t\t\tpos += scnprintf(pos, endpos - pos, \"LB\\n\");\n\t\t\t\tbreak;\n\t\t\tcase TAS_LMAC_BAND_UHB:\n\t\t\t\tpos += scnprintf(pos, endpos - pos, \"UHB\\n\");\n\t\t\t\tbreak;\n\t\t\tcase TAS_LMAC_BAND_INVALID:\n\t\t\t\tpos += scnprintf(pos, endpos - pos,\n\t\t\t\t\t\t \"INVALID BAND\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpos += scnprintf(pos, endpos - pos,\n\t\t\t\t\t\t \"Unsupported band (%d)\\n\",\n\t\t\t\t\t\t rsp->tas_status_mac[i].band);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\ttas_enabled = true;\n\t\t}\n\t}\n\tif (!tas_enabled)\n\t\tpos += scnprintf(pos, endpos - pos, \"\\tOFF\\n\");\n\n\tpos += scnprintf(pos, endpos - pos, \"TAS Report\\n\");\n\tpos += scnprintf(pos, endpos - pos, \"TAS FW version: %d\\n\",\n\t\t\t rsp->tas_fw_version);\n\tpos += scnprintf(pos, endpos - pos, \"Is UHB enabled for USA?: %s\\n\",\n\t\t\t rsp->is_uhb_for_usa_enable ? \"True\" : \"False\");\n\tpos += scnprintf(pos, endpos - pos, \"Current MCC: 0x%x\\n\",\n\t\t\t le16_to_cpu(rsp->curr_mcc));\n\n\tpos += scnprintf(pos, endpos - pos, \"Block list entries:\");\n\tfor (i = 0; i < APCI_WTAS_BLACK_LIST_MAX; i++)\n\t\tpos += scnprintf(pos, endpos - pos, \" 0x%x\",\n\t\t\t\t le16_to_cpu(rsp->block_list[i]));\n\n\tpos += scnprintf(pos, endpos - pos, \"\\nOEM name: %s\\n\",\n\t\t\t dmi_get_system_info(DMI_SYS_VENDOR));\n\tpos += scnprintf(pos, endpos - pos, \"\\tVendor In Approved List: %s\\n\",\n\t\t\t iwl_mvm_is_vendor_in_approved_list() ? \"YES\" : \"NO\");\n\tpos += scnprintf(pos, endpos - pos,\n\t\t\t \"\\tDo TAS Support Dual Radio?: %s\\n\",\n\t\t\t rsp->in_dual_radio ? \"TRUE\" : \"FALSE\");\n\n\tfor (i = 0; i < rsp->in_dual_radio + 1; i++) {\n\t\tif (rsp->tas_status_mac[i].static_status == 0) {\n\t\t\tpos += scnprintf(pos, endpos - pos,\n\t\t\t\t\t \"Static status: disabled\\n\");\n\t\t\tpos += scnprintf(pos, endpos - pos,\n\t\t\t\t\t \"Static disabled reason: %s (0)\\n\",\n\t\t\t\t\t tas_dis_reason[0]);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpos += scnprintf(pos, endpos - pos, \"TAS status for \");\n\t\tswitch (rsp->tas_status_mac[i].band) {\n\t\tcase TAS_LMAC_BAND_HB:\n\t\t\tpos += scnprintf(pos, endpos - pos, \"High band\\n\");\n\t\t\tbreak;\n\t\tcase TAS_LMAC_BAND_LB:\n\t\t\tpos += scnprintf(pos, endpos - pos, \"Low band\\n\");\n\t\t\tbreak;\n\t\tcase TAS_LMAC_BAND_UHB:\n\t\t\tpos += scnprintf(pos, endpos - pos,\n\t\t\t\t\t \"Ultra high band\\n\");\n\t\t\tbreak;\n\t\tcase TAS_LMAC_BAND_INVALID:\n\t\t\tpos += scnprintf(pos, endpos - pos,\n\t\t\t\t\t \"INVALID band\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpos += scnprintf(pos, endpos - pos,\n\t\t\t\t\t \"Unsupported band (%d)\\n\",\n\t\t\t\t\t rsp->tas_status_mac[i].band);\n\t\t\tgoto out;\n\t\t}\n\t\tpos += scnprintf(pos, endpos - pos, \"Static status: %sabled\\n\",\n\t\t\t\t rsp->tas_status_mac[i].static_status ?\n\t\t\t\t \"En\" : \"Dis\");\n\t\tpos += scnprintf(pos, endpos - pos,\n\t\t\t\t \"\\tStatic Disabled Reason: \");\n\t\tif (rsp->tas_status_mac[i].static_dis_reason < TAS_DISABLED_REASON_MAX)\n\t\t\tpos += scnprintf(pos, endpos - pos, \"%s (%d)\\n\",\n\t\t\t\t\t tas_dis_reason[rsp->tas_status_mac[i].static_dis_reason],\n\t\t\t\t\t rsp->tas_status_mac[i].static_dis_reason);\n\t\telse\n\t\t\tpos += scnprintf(pos, endpos - pos,\n\t\t\t\t\t \"unsupported value (%d)\\n\",\n\t\t\t\t\t rsp->tas_status_mac[i].static_dis_reason);\n\n\t\tpos += scnprintf(pos, endpos - pos, \"Dynamic status:\\n\");\n\t\tdyn_status = (rsp->tas_status_mac[i].dynamic_status);\n\t\tfor_each_set_bit(tmp, &dyn_status, sizeof(dyn_status)) {\n\t\t\tif (tmp >= 0 && tmp < TAS_DYNA_STATUS_MAX)\n\t\t\t\tpos += scnprintf(pos, endpos - pos,\n\t\t\t\t\t\t \"\\t%s (%d)\\n\",\n\t\t\t\t\t\t tas_current_status[tmp], tmp);\n\t\t}\n\n\t\tpos += scnprintf(pos, endpos - pos,\n\t\t\t\t \"Is near disconnection?: %s\\n\",\n\t\t\t\t rsp->tas_status_mac[i].near_disconnection ?\n\t\t\t\t \"True\" : \"False\");\n\t\ttmp = le16_to_cpu(rsp->tas_status_mac[i].max_reg_pwr_limit);\n\t\tpos += scnprintf(pos, endpos - pos,\n\t\t\t\t \"Max. regulatory pwr limit (dBm): %d.%03d\\n\",\n\t\t\t\t tmp / 8, 125 * (tmp % 8));\n\t\ttmp = le16_to_cpu(rsp->tas_status_mac[i].sar_limit);\n\t\tpos += scnprintf(pos, endpos - pos,\n\t\t\t\t \"SAR limit (dBm): %d.%03d\\n\",\n\t\t\t\t tmp / 8, 125 * (tmp % 8));\n\t}\n\nout:\n\tret = simple_read_from_buffer(user_buf, count, ppos, buff, pos - buff);\n\tkfree(buff);\n\tiwl_free_resp(&hcmd);\n\treturn ret;\n}\n\nstatic ssize_t iwl_dbgfs_phy_integration_ver_read(struct file *file,\n\t\t\t\t\t\t  char __user *user_buf,\n\t\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm *mvm = file->private_data;\n\tchar *buf;\n\tsize_t bufsz;\n\tint pos;\n\tssize_t ret;\n\n\tbufsz = mvm->fw->phy_integration_ver_len + 2;\n\tbuf = kmalloc(bufsz, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tpos = scnprintf(buf, bufsz, \"%.*s\\n\", mvm->fw->phy_integration_ver_len,\n\t\t\tmvm->fw->phy_integration_ver);\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n\n\tkfree(buf);\n\treturn ret;\n}\n\n#define PRINT_STATS_LE32(_struct, _memb)\t\t\t\t\\\n\t\t\t pos += scnprintf(buf + pos, bufsz - pos,\t\\\n\t\t\t\t\t  fmt_table, #_memb,\t\t\\\n\t\t\t\t\t  le32_to_cpu(_struct->_memb))\n\nstatic ssize_t iwl_dbgfs_fw_rx_stats_read(struct file *file,\n\t\t\t\t\t  char __user *user_buf, size_t count,\n\t\t\t\t\t  loff_t *ppos)\n{\n\tstruct iwl_mvm *mvm = file->private_data;\n\tstatic const char *fmt_table = \"\\t%-30s %10u\\n\";\n\tstatic const char *fmt_header = \"%-32s\\n\";\n\tint pos = 0;\n\tchar *buf;\n\tint ret;\n\tsize_t bufsz;\n\n\tif (iwl_mvm_has_new_rx_stats_api(mvm))\n\t\tbufsz = ((sizeof(struct mvm_statistics_rx) /\n\t\t\t  sizeof(__le32)) * 43) + (4 * 33) + 1;\n\telse\n\t\t \n\t\tbufsz = ((sizeof(struct mvm_statistics_rx_v3) /\n\t\t\t  sizeof(__le32)) * 43) + (4 * 33) + 1;\n\n\tbuf = kzalloc(bufsz, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&mvm->mutex);\n\n\tif (iwl_mvm_firmware_running(mvm))\n\t\tiwl_mvm_request_statistics(mvm, false);\n\n\tpos += scnprintf(buf + pos, bufsz - pos, fmt_header,\n\t\t\t \"Statistics_Rx - OFDM\");\n\tif (!iwl_mvm_has_new_rx_stats_api(mvm)) {\n\t\tstruct mvm_statistics_rx_phy_v2 *ofdm = &mvm->rx_stats_v3.ofdm;\n\n\t\tPRINT_STATS_LE32(ofdm, ina_cnt);\n\t\tPRINT_STATS_LE32(ofdm, fina_cnt);\n\t\tPRINT_STATS_LE32(ofdm, plcp_err);\n\t\tPRINT_STATS_LE32(ofdm, crc32_err);\n\t\tPRINT_STATS_LE32(ofdm, overrun_err);\n\t\tPRINT_STATS_LE32(ofdm, early_overrun_err);\n\t\tPRINT_STATS_LE32(ofdm, crc32_good);\n\t\tPRINT_STATS_LE32(ofdm, false_alarm_cnt);\n\t\tPRINT_STATS_LE32(ofdm, fina_sync_err_cnt);\n\t\tPRINT_STATS_LE32(ofdm, sfd_timeout);\n\t\tPRINT_STATS_LE32(ofdm, fina_timeout);\n\t\tPRINT_STATS_LE32(ofdm, unresponded_rts);\n\t\tPRINT_STATS_LE32(ofdm, rxe_frame_lmt_overrun);\n\t\tPRINT_STATS_LE32(ofdm, sent_ack_cnt);\n\t\tPRINT_STATS_LE32(ofdm, sent_cts_cnt);\n\t\tPRINT_STATS_LE32(ofdm, sent_ba_rsp_cnt);\n\t\tPRINT_STATS_LE32(ofdm, dsp_self_kill);\n\t\tPRINT_STATS_LE32(ofdm, mh_format_err);\n\t\tPRINT_STATS_LE32(ofdm, re_acq_main_rssi_sum);\n\t\tPRINT_STATS_LE32(ofdm, reserved);\n\t} else {\n\t\tstruct mvm_statistics_rx_phy *ofdm = &mvm->rx_stats.ofdm;\n\n\t\tPRINT_STATS_LE32(ofdm, unresponded_rts);\n\t\tPRINT_STATS_LE32(ofdm, rxe_frame_lmt_overrun);\n\t\tPRINT_STATS_LE32(ofdm, sent_ba_rsp_cnt);\n\t\tPRINT_STATS_LE32(ofdm, dsp_self_kill);\n\t\tPRINT_STATS_LE32(ofdm, reserved);\n\t}\n\n\tpos += scnprintf(buf + pos, bufsz - pos, fmt_header,\n\t\t\t \"Statistics_Rx - CCK\");\n\tif (!iwl_mvm_has_new_rx_stats_api(mvm)) {\n\t\tstruct mvm_statistics_rx_phy_v2 *cck = &mvm->rx_stats_v3.cck;\n\n\t\tPRINT_STATS_LE32(cck, ina_cnt);\n\t\tPRINT_STATS_LE32(cck, fina_cnt);\n\t\tPRINT_STATS_LE32(cck, plcp_err);\n\t\tPRINT_STATS_LE32(cck, crc32_err);\n\t\tPRINT_STATS_LE32(cck, overrun_err);\n\t\tPRINT_STATS_LE32(cck, early_overrun_err);\n\t\tPRINT_STATS_LE32(cck, crc32_good);\n\t\tPRINT_STATS_LE32(cck, false_alarm_cnt);\n\t\tPRINT_STATS_LE32(cck, fina_sync_err_cnt);\n\t\tPRINT_STATS_LE32(cck, sfd_timeout);\n\t\tPRINT_STATS_LE32(cck, fina_timeout);\n\t\tPRINT_STATS_LE32(cck, unresponded_rts);\n\t\tPRINT_STATS_LE32(cck, rxe_frame_lmt_overrun);\n\t\tPRINT_STATS_LE32(cck, sent_ack_cnt);\n\t\tPRINT_STATS_LE32(cck, sent_cts_cnt);\n\t\tPRINT_STATS_LE32(cck, sent_ba_rsp_cnt);\n\t\tPRINT_STATS_LE32(cck, dsp_self_kill);\n\t\tPRINT_STATS_LE32(cck, mh_format_err);\n\t\tPRINT_STATS_LE32(cck, re_acq_main_rssi_sum);\n\t\tPRINT_STATS_LE32(cck, reserved);\n\t} else {\n\t\tstruct mvm_statistics_rx_phy *cck = &mvm->rx_stats.cck;\n\n\t\tPRINT_STATS_LE32(cck, unresponded_rts);\n\t\tPRINT_STATS_LE32(cck, rxe_frame_lmt_overrun);\n\t\tPRINT_STATS_LE32(cck, sent_ba_rsp_cnt);\n\t\tPRINT_STATS_LE32(cck, dsp_self_kill);\n\t\tPRINT_STATS_LE32(cck, reserved);\n\t}\n\n\tpos += scnprintf(buf + pos, bufsz - pos, fmt_header,\n\t\t\t \"Statistics_Rx - GENERAL\");\n\tif (!iwl_mvm_has_new_rx_stats_api(mvm)) {\n\t\tstruct mvm_statistics_rx_non_phy_v3 *general =\n\t\t\t&mvm->rx_stats_v3.general;\n\n\t\tPRINT_STATS_LE32(general, bogus_cts);\n\t\tPRINT_STATS_LE32(general, bogus_ack);\n\t\tPRINT_STATS_LE32(general, non_bssid_frames);\n\t\tPRINT_STATS_LE32(general, filtered_frames);\n\t\tPRINT_STATS_LE32(general, non_channel_beacons);\n\t\tPRINT_STATS_LE32(general, channel_beacons);\n\t\tPRINT_STATS_LE32(general, num_missed_bcon);\n\t\tPRINT_STATS_LE32(general, adc_rx_saturation_time);\n\t\tPRINT_STATS_LE32(general, ina_detection_search_time);\n\t\tPRINT_STATS_LE32(general, beacon_silence_rssi_a);\n\t\tPRINT_STATS_LE32(general, beacon_silence_rssi_b);\n\t\tPRINT_STATS_LE32(general, beacon_silence_rssi_c);\n\t\tPRINT_STATS_LE32(general, interference_data_flag);\n\t\tPRINT_STATS_LE32(general, channel_load);\n\t\tPRINT_STATS_LE32(general, dsp_false_alarms);\n\t\tPRINT_STATS_LE32(general, beacon_rssi_a);\n\t\tPRINT_STATS_LE32(general, beacon_rssi_b);\n\t\tPRINT_STATS_LE32(general, beacon_rssi_c);\n\t\tPRINT_STATS_LE32(general, beacon_energy_a);\n\t\tPRINT_STATS_LE32(general, beacon_energy_b);\n\t\tPRINT_STATS_LE32(general, beacon_energy_c);\n\t\tPRINT_STATS_LE32(general, num_bt_kills);\n\t\tPRINT_STATS_LE32(general, mac_id);\n\t\tPRINT_STATS_LE32(general, directed_data_mpdu);\n\t} else {\n\t\tstruct mvm_statistics_rx_non_phy *general =\n\t\t\t&mvm->rx_stats.general;\n\n\t\tPRINT_STATS_LE32(general, bogus_cts);\n\t\tPRINT_STATS_LE32(general, bogus_ack);\n\t\tPRINT_STATS_LE32(general, non_channel_beacons);\n\t\tPRINT_STATS_LE32(general, channel_beacons);\n\t\tPRINT_STATS_LE32(general, num_missed_bcon);\n\t\tPRINT_STATS_LE32(general, adc_rx_saturation_time);\n\t\tPRINT_STATS_LE32(general, ina_detection_search_time);\n\t\tPRINT_STATS_LE32(general, beacon_silence_rssi_a);\n\t\tPRINT_STATS_LE32(general, beacon_silence_rssi_b);\n\t\tPRINT_STATS_LE32(general, beacon_silence_rssi_c);\n\t\tPRINT_STATS_LE32(general, interference_data_flag);\n\t\tPRINT_STATS_LE32(general, channel_load);\n\t\tPRINT_STATS_LE32(general, beacon_rssi_a);\n\t\tPRINT_STATS_LE32(general, beacon_rssi_b);\n\t\tPRINT_STATS_LE32(general, beacon_rssi_c);\n\t\tPRINT_STATS_LE32(general, beacon_energy_a);\n\t\tPRINT_STATS_LE32(general, beacon_energy_b);\n\t\tPRINT_STATS_LE32(general, beacon_energy_c);\n\t\tPRINT_STATS_LE32(general, num_bt_kills);\n\t\tPRINT_STATS_LE32(general, mac_id);\n\t}\n\n\tpos += scnprintf(buf + pos, bufsz - pos, fmt_header,\n\t\t\t \"Statistics_Rx - HT\");\n\tif (!iwl_mvm_has_new_rx_stats_api(mvm)) {\n\t\tstruct mvm_statistics_rx_ht_phy_v1 *ht =\n\t\t\t&mvm->rx_stats_v3.ofdm_ht;\n\n\t\tPRINT_STATS_LE32(ht, plcp_err);\n\t\tPRINT_STATS_LE32(ht, overrun_err);\n\t\tPRINT_STATS_LE32(ht, early_overrun_err);\n\t\tPRINT_STATS_LE32(ht, crc32_good);\n\t\tPRINT_STATS_LE32(ht, crc32_err);\n\t\tPRINT_STATS_LE32(ht, mh_format_err);\n\t\tPRINT_STATS_LE32(ht, agg_crc32_good);\n\t\tPRINT_STATS_LE32(ht, agg_mpdu_cnt);\n\t\tPRINT_STATS_LE32(ht, agg_cnt);\n\t\tPRINT_STATS_LE32(ht, unsupport_mcs);\n\t} else {\n\t\tstruct mvm_statistics_rx_ht_phy *ht =\n\t\t\t&mvm->rx_stats.ofdm_ht;\n\n\t\tPRINT_STATS_LE32(ht, mh_format_err);\n\t\tPRINT_STATS_LE32(ht, agg_mpdu_cnt);\n\t\tPRINT_STATS_LE32(ht, agg_cnt);\n\t\tPRINT_STATS_LE32(ht, unsupport_mcs);\n\t}\n\n\tmutex_unlock(&mvm->mutex);\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n\tkfree(buf);\n\n\treturn ret;\n}\n#undef PRINT_STAT_LE32\n\nstatic ssize_t iwl_dbgfs_frame_stats_read(struct iwl_mvm *mvm,\n\t\t\t\t\t  char __user *user_buf, size_t count,\n\t\t\t\t\t  loff_t *ppos,\n\t\t\t\t\t  struct iwl_mvm_frame_stats *stats)\n{\n\tchar *buff, *pos, *endpos;\n\tint idx, i;\n\tint ret;\n\tstatic const size_t bufsz = 1024;\n\n\tbuff = kmalloc(bufsz, GFP_KERNEL);\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\tspin_lock_bh(&mvm->drv_stats_lock);\n\n\tpos = buff;\n\tendpos = pos + bufsz;\n\n\tpos += scnprintf(pos, endpos - pos,\n\t\t\t \"Legacy/HT/VHT\\t:\\t%d/%d/%d\\n\",\n\t\t\t stats->legacy_frames,\n\t\t\t stats->ht_frames,\n\t\t\t stats->vht_frames);\n\tpos += scnprintf(pos, endpos - pos, \"20/40/80\\t:\\t%d/%d/%d\\n\",\n\t\t\t stats->bw_20_frames,\n\t\t\t stats->bw_40_frames,\n\t\t\t stats->bw_80_frames);\n\tpos += scnprintf(pos, endpos - pos, \"NGI/SGI\\t\\t:\\t%d/%d\\n\",\n\t\t\t stats->ngi_frames,\n\t\t\t stats->sgi_frames);\n\tpos += scnprintf(pos, endpos - pos, \"SISO/MIMO2\\t:\\t%d/%d\\n\",\n\t\t\t stats->siso_frames,\n\t\t\t stats->mimo2_frames);\n\tpos += scnprintf(pos, endpos - pos, \"FAIL/SCSS\\t:\\t%d/%d\\n\",\n\t\t\t stats->fail_frames,\n\t\t\t stats->success_frames);\n\tpos += scnprintf(pos, endpos - pos, \"MPDUs agg\\t:\\t%d\\n\",\n\t\t\t stats->agg_frames);\n\tpos += scnprintf(pos, endpos - pos, \"A-MPDUs\\t\\t:\\t%d\\n\",\n\t\t\t stats->ampdu_count);\n\tpos += scnprintf(pos, endpos - pos, \"Avg MPDUs/A-MPDU:\\t%d\\n\",\n\t\t\t stats->ampdu_count > 0 ?\n\t\t\t (stats->agg_frames / stats->ampdu_count) : 0);\n\n\tpos += scnprintf(pos, endpos - pos, \"Last Rates\\n\");\n\n\tidx = stats->last_frame_idx - 1;\n\tfor (i = 0; i < ARRAY_SIZE(stats->last_rates); i++) {\n\t\tidx = (idx + 1) % ARRAY_SIZE(stats->last_rates);\n\t\tif (stats->last_rates[idx] == 0)\n\t\t\tcontinue;\n\t\tpos += scnprintf(pos, endpos - pos, \"Rate[%d]: \",\n\t\t\t\t (int)(ARRAY_SIZE(stats->last_rates) - i));\n\t\tpos += rs_pretty_print_rate_v1(pos, endpos - pos,\n\t\t\t\t\t       stats->last_rates[idx]);\n\t\tif (pos < endpos - 1)\n\t\t\t*pos++ = '\\n';\n\t}\n\tspin_unlock_bh(&mvm->drv_stats_lock);\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buff, pos - buff);\n\tkfree(buff);\n\n\treturn ret;\n}\n\nstatic ssize_t iwl_dbgfs_drv_rx_stats_read(struct file *file,\n\t\t\t\t\t   char __user *user_buf, size_t count,\n\t\t\t\t\t   loff_t *ppos)\n{\n\tstruct iwl_mvm *mvm = file->private_data;\n\n\treturn iwl_dbgfs_frame_stats_read(mvm, user_buf, count, ppos,\n\t\t\t\t\t  &mvm->drv_rx_stats);\n}\n\nstatic ssize_t iwl_dbgfs_fw_restart_write(struct iwl_mvm *mvm, char *buf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tint __maybe_unused ret;\n\n\tif (!iwl_mvm_firmware_running(mvm))\n\t\treturn -EIO;\n\n\tmutex_lock(&mvm->mutex);\n\n\t \n\tif (mvm->fw_restart >= 0)\n\t\tmvm->fw_restart++;\n\n\tif (count == 6 && !strcmp(buf, \"nolog\\n\")) {\n\t\tset_bit(IWL_MVM_STATUS_SUPPRESS_ERROR_LOG_ONCE, &mvm->status);\n\t\tset_bit(STATUS_SUPPRESS_CMD_ERROR_ONCE, &mvm->trans->status);\n\t}\n\n\t \n\tret = iwl_mvm_send_cmd_pdu(mvm,\n\t\t\t\t   WIDE_ID(LONG_GROUP, REPLY_ERROR),\n\t\t\t\t   0, 0, NULL);\n\n\tmutex_unlock(&mvm->mutex);\n\n\treturn count;\n}\n\nstatic ssize_t iwl_dbgfs_fw_nmi_write(struct iwl_mvm *mvm, char *buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tif (!iwl_mvm_firmware_running(mvm))\n\t\treturn -EIO;\n\n\tif (count == 6 && !strcmp(buf, \"nolog\\n\"))\n\t\tset_bit(IWL_MVM_STATUS_SUPPRESS_ERROR_LOG_ONCE, &mvm->status);\n\n\tiwl_force_nmi(mvm->trans);\n\n\treturn count;\n}\n\nstatic ssize_t\niwl_dbgfs_scan_ant_rxchain_read(struct file *file,\n\t\t\t\tchar __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm *mvm = file->private_data;\n\tint pos = 0;\n\tchar buf[32];\n\tconst size_t bufsz = sizeof(buf);\n\n\t \n\tpos += scnprintf(buf + pos, bufsz - pos, \"Antennas for scan: \");\n\tif (mvm->scan_rx_ant & ANT_A)\n\t\tpos += scnprintf(buf + pos, bufsz - pos, \"A\");\n\tif (mvm->scan_rx_ant & ANT_B)\n\t\tpos += scnprintf(buf + pos, bufsz - pos, \"B\");\n\tpos += scnprintf(buf + pos, bufsz - pos, \" (%x)\\n\", mvm->scan_rx_ant);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\nstatic ssize_t\niwl_dbgfs_scan_ant_rxchain_write(struct iwl_mvm *mvm, char *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tu8 scan_rx_ant;\n\n\tif (!iwl_mvm_firmware_running(mvm))\n\t\treturn -EIO;\n\n\tif (sscanf(buf, \"%hhx\", &scan_rx_ant) != 1)\n\t\treturn -EINVAL;\n\tif (scan_rx_ant > ANT_ABC)\n\t\treturn -EINVAL;\n\tif (scan_rx_ant & ~(iwl_mvm_get_valid_rx_ant(mvm)))\n\t\treturn -EINVAL;\n\n\tif (mvm->scan_rx_ant != scan_rx_ant) {\n\t\tmvm->scan_rx_ant = scan_rx_ant;\n\t\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t\tIWL_UCODE_TLV_CAPA_UMAC_SCAN))\n\t\t\tiwl_mvm_config_scan(mvm);\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t iwl_dbgfs_indirection_tbl_write(struct iwl_mvm *mvm,\n\t\t\t\t\t       char *buf, size_t count,\n\t\t\t\t\t       loff_t *ppos)\n{\n\tstruct iwl_rss_config_cmd cmd = {\n\t\t.flags = cpu_to_le32(IWL_RSS_ENABLE),\n\t\t.hash_mask = IWL_RSS_HASH_TYPE_IPV4_TCP |\n\t\t\t     IWL_RSS_HASH_TYPE_IPV4_UDP |\n\t\t\t     IWL_RSS_HASH_TYPE_IPV4_PAYLOAD |\n\t\t\t     IWL_RSS_HASH_TYPE_IPV6_TCP |\n\t\t\t     IWL_RSS_HASH_TYPE_IPV6_UDP |\n\t\t\t     IWL_RSS_HASH_TYPE_IPV6_PAYLOAD,\n\t};\n\tint ret, i, num_repeats, nbytes = count / 2;\n\n\tret = hex2bin(cmd.indirection_table, buf, nbytes);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tnum_repeats = ARRAY_SIZE(cmd.indirection_table) / nbytes;\n\tfor (i = 1; i < num_repeats; i++)\n\t\tmemcpy(&cmd.indirection_table[i * nbytes],\n\t\t       cmd.indirection_table, nbytes);\n\t \n\tmemcpy(&cmd.indirection_table[i * nbytes], cmd.indirection_table,\n\t       ARRAY_SIZE(cmd.indirection_table) % nbytes);\n\n\tnetdev_rss_key_fill(cmd.secret_key, sizeof(cmd.secret_key));\n\n\tmutex_lock(&mvm->mutex);\n\tif (iwl_mvm_firmware_running(mvm))\n\t\tret = iwl_mvm_send_cmd_pdu(mvm, RSS_CONFIG_CMD, 0,\n\t\t\t\t\t   sizeof(cmd), &cmd);\n\telse\n\t\tret = 0;\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret ?: count;\n}\n\nstatic ssize_t iwl_dbgfs_inject_packet_write(struct iwl_mvm *mvm,\n\t\t\t\t\t     char *buf, size_t count,\n\t\t\t\t\t     loff_t *ppos)\n{\n\tstruct iwl_op_mode *opmode = container_of((void *)mvm,\n\t\t\t\t\t\t  struct iwl_op_mode,\n\t\t\t\t\t\t  op_mode_specific);\n\tstruct iwl_rx_cmd_buffer rxb = {\n\t\t._rx_page_order = 0,\n\t\t.truesize = 0,  \n\t\t._offset = 0,\n\t};\n\tstruct iwl_rx_packet *pkt;\n\tint bin_len = count / 2;\n\tint ret = -EINVAL;\n\n\tif (!iwl_mvm_firmware_running(mvm))\n\t\treturn -EIO;\n\n\t \n\tif (!mvm->trans->trans_cfg->mq_rx_supported)\n\t\treturn -ENOTSUPP;\n\n\trxb._page = alloc_pages(GFP_ATOMIC, 0);\n\tif (!rxb._page)\n\t\treturn -ENOMEM;\n\tpkt = rxb_addr(&rxb);\n\n\tret = hex2bin(page_address(rxb._page), buf, bin_len);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (bin_len < sizeof(*pkt) ||\n\t    bin_len != sizeof(*pkt) + iwl_rx_packet_payload_len(pkt))\n\t\tgoto out;\n\n\tlocal_bh_disable();\n\tiwl_mvm_rx_mq(opmode, NULL, &rxb);\n\tlocal_bh_enable();\n\tret = 0;\n\nout:\n\tiwl_free_rxb(&rxb);\n\n\treturn ret ?: count;\n}\n\nstatic int _iwl_dbgfs_inject_beacon_ie(struct iwl_mvm *mvm, char *bin, int len)\n{\n\tstruct ieee80211_vif *vif;\n\tstruct iwl_mvm_vif *mvmvif;\n\tstruct sk_buff *beacon;\n\tstruct ieee80211_tx_info *info;\n\tstruct iwl_mac_beacon_cmd beacon_cmd = {};\n\tunsigned int link_id;\n\tu8 rate;\n\tint i;\n\n\tlen /= 2;\n\n\t \n\tif (len >= U8_MAX)\n\t\treturn -EINVAL;\n\n\tif (!iwl_mvm_firmware_running(mvm))\n\t\treturn -EIO;\n\n\tif (!iwl_mvm_has_new_tx_api(mvm) &&\n\t    !fw_has_api(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_API_NEW_BEACON_TEMPLATE))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mvm->mutex);\n\n\tfor (i = 0; i < NUM_MAC_INDEX_DRIVER; i++) {\n\t\tvif = iwl_mvm_rcu_dereference_vif_id(mvm, i, false);\n\t\tif (!vif)\n\t\t\tcontinue;\n\n\t\tif (vif->type == NL80211_IFTYPE_AP)\n\t\t\tbreak;\n\t}\n\n\tif (i == NUM_MAC_INDEX_DRIVER || !vif)\n\t\tgoto out_err;\n\n\tmvm->hw->extra_beacon_tailroom = len;\n\n\tbeacon = ieee80211_beacon_get_template(mvm->hw, vif, NULL, 0);\n\tif (!beacon)\n\t\tgoto out_err;\n\n\tif (len && hex2bin(skb_put_zero(beacon, len), bin, len)) {\n\t\tdev_kfree_skb(beacon);\n\t\tgoto out_err;\n\t}\n\n\tmvm->beacon_inject_active = true;\n\n\tmvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tinfo = IEEE80211_SKB_CB(beacon);\n\trate = iwl_mvm_mac_ctxt_get_beacon_rate(mvm, info, vif);\n\n\tfor_each_mvm_vif_valid_link(mvmvif, link_id) {\n\t\tbeacon_cmd.flags =\n\t\t\tcpu_to_le16(iwl_mvm_mac_ctxt_get_beacon_flags(mvm->fw,\n\t\t\t\t\t\t\t\t      rate));\n\t\tbeacon_cmd.byte_cnt = cpu_to_le16((u16)beacon->len);\n\t\tif (iwl_fw_lookup_cmd_ver(mvm->fw, BEACON_TEMPLATE_CMD, 0) > 12)\n\t\t\tbeacon_cmd.link_id =\n\t\t\t\tcpu_to_le32(mvmvif->link[link_id]->fw_link_id);\n\t\telse\n\t\t\tbeacon_cmd.link_id = cpu_to_le32((u32)mvmvif->id);\n\n\t\tiwl_mvm_mac_ctxt_set_tim(mvm, &beacon_cmd.tim_idx,\n\t\t\t\t\t &beacon_cmd.tim_size,\n\t\t\t\t\t beacon->data, beacon->len);\n\n\t\tiwl_mvm_mac_ctxt_send_beacon_cmd(mvm, beacon, &beacon_cmd,\n\t\t\t\t\t\t sizeof(beacon_cmd));\n\t}\n\tmutex_unlock(&mvm->mutex);\n\n\tdev_kfree_skb(beacon);\n\n\treturn 0;\n\nout_err:\n\tmutex_unlock(&mvm->mutex);\n\treturn -EINVAL;\n}\n\nstatic ssize_t iwl_dbgfs_inject_beacon_ie_write(struct iwl_mvm *mvm,\n\t\t\t\t\t\tchar *buf, size_t count,\n\t\t\t\t\t\tloff_t *ppos)\n{\n\tint ret = _iwl_dbgfs_inject_beacon_ie(mvm, buf, count);\n\n\tmvm->hw->extra_beacon_tailroom = 0;\n\treturn ret ?: count;\n}\n\nstatic ssize_t iwl_dbgfs_inject_beacon_ie_restore_write(struct iwl_mvm *mvm,\n\t\t\t\t\t\t\tchar *buf,\n\t\t\t\t\t\t\tsize_t count,\n\t\t\t\t\t\t\tloff_t *ppos)\n{\n\tint ret = _iwl_dbgfs_inject_beacon_ie(mvm, NULL, 0);\n\n\tmvm->hw->extra_beacon_tailroom = 0;\n\tmvm->beacon_inject_active = false;\n\treturn ret ?: count;\n}\n\nstatic ssize_t iwl_dbgfs_fw_dbg_conf_read(struct file *file,\n\t\t\t\t\t  char __user *user_buf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm *mvm = file->private_data;\n\tint conf;\n\tchar buf[8];\n\tconst size_t bufsz = sizeof(buf);\n\tint pos = 0;\n\n\tmutex_lock(&mvm->mutex);\n\tconf = mvm->fwrt.dump.conf;\n\tmutex_unlock(&mvm->mutex);\n\n\tpos += scnprintf(buf + pos, bufsz - pos, \"%d\\n\", conf);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\nstatic ssize_t iwl_dbgfs_fw_dbg_conf_write(struct iwl_mvm *mvm,\n\t\t\t\t\t   char *buf, size_t count,\n\t\t\t\t\t   loff_t *ppos)\n{\n\tunsigned int conf_id;\n\tint ret;\n\n\tif (!iwl_mvm_firmware_running(mvm))\n\t\treturn -EIO;\n\n\tret = kstrtouint(buf, 0, &conf_id);\n\tif (ret)\n\t\treturn ret;\n\n\tif (WARN_ON(conf_id >= FW_DBG_CONF_MAX))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mvm->mutex);\n\tret = iwl_fw_start_dbg_conf(&mvm->fwrt, conf_id);\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret ?: count;\n}\n\nstatic ssize_t iwl_dbgfs_fw_dbg_collect_write(struct iwl_mvm *mvm,\n\t\t\t\t\t      char *buf, size_t count,\n\t\t\t\t\t      loff_t *ppos)\n{\n\tif (count == 0)\n\t\treturn 0;\n\n\tiwl_dbg_tlv_time_point(&mvm->fwrt, IWL_FW_INI_TIME_POINT_USER_TRIGGER,\n\t\t\t       NULL);\n\n\tiwl_fw_dbg_collect(&mvm->fwrt, FW_DBG_TRIGGER_USER, buf,\n\t\t\t   (count - 1), NULL);\n\n\treturn count;\n}\n\nstatic ssize_t iwl_dbgfs_dbg_time_point_write(struct iwl_mvm *mvm,\n\t\t\t\t\t      char *buf, size_t count,\n\t\t\t\t\t      loff_t *ppos)\n{\n\tu32 timepoint;\n\n\tif (kstrtou32(buf, 0, &timepoint))\n\t\treturn -EINVAL;\n\n\tif (timepoint == IWL_FW_INI_TIME_POINT_INVALID ||\n\t    timepoint >= IWL_FW_INI_TIME_POINT_NUM)\n\t\treturn -EINVAL;\n\n\tiwl_dbg_tlv_time_point(&mvm->fwrt, timepoint, NULL);\n\n\treturn count;\n}\n\n#define MVM_DEBUGFS_WRITE_FILE_OPS(name, bufsz) \\\n\t_MVM_DEBUGFS_WRITE_FILE_OPS(name, bufsz, struct iwl_mvm)\n#define MVM_DEBUGFS_READ_WRITE_FILE_OPS(name, bufsz) \\\n\t_MVM_DEBUGFS_READ_WRITE_FILE_OPS(name, bufsz, struct iwl_mvm)\n#define MVM_DEBUGFS_ADD_FILE_ALIAS(alias, name, parent, mode) do {\t\\\n\t\tdebugfs_create_file(alias, mode, parent, mvm,\t\t\\\n\t\t\t\t    &iwl_dbgfs_##name##_ops);\t\t\\\n\t} while (0)\n#define MVM_DEBUGFS_ADD_FILE(name, parent, mode) \\\n\tMVM_DEBUGFS_ADD_FILE_ALIAS(#name, name, parent, mode)\n\nstatic ssize_t\n_iwl_dbgfs_link_sta_wrap_write(ssize_t (*real)(struct ieee80211_link_sta *,\n\t\t\t\t\t       struct iwl_mvm_sta *,\n\t\t\t\t\t       struct iwl_mvm *,\n\t\t\t\t\t       struct iwl_mvm_link_sta *,\n\t\t\t\t\t       char *,\n\t\t\t\t\t       size_t, loff_t *),\n\t\t\t   struct file *file,\n\t\t\t   char *buf, size_t buf_size, loff_t *ppos)\n{\n\tstruct ieee80211_link_sta *link_sta = file->private_data;\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(link_sta->sta);\n\tstruct iwl_mvm *mvm = iwl_mvm_vif_from_mac80211(mvmsta->vif)->mvm;\n\tstruct iwl_mvm_link_sta *mvm_link_sta;\n\tssize_t ret;\n\n\tmutex_lock(&mvm->mutex);\n\n\tmvm_link_sta = rcu_dereference_protected(mvmsta->link[link_sta->link_id],\n\t\t\t\t\t\t lockdep_is_held(&mvm->mutex));\n\tif (WARN_ON(!mvm_link_sta)) {\n\t\tmutex_unlock(&mvm->mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tret = real(link_sta, mvmsta, mvm, mvm_link_sta, buf, buf_size, ppos);\n\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t\n_iwl_dbgfs_link_sta_wrap_read(ssize_t (*real)(struct ieee80211_link_sta *,\n\t\t\t\t\t      struct iwl_mvm_sta *,\n\t\t\t\t\t      struct iwl_mvm *,\n\t\t\t\t\t      struct iwl_mvm_link_sta *,\n\t\t\t\t\t      char __user *,\n\t\t\t\t\t      size_t, loff_t *),\n\t\t\t   struct file *file,\n\t\t\t   char __user *user_buf, size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_link_sta *link_sta = file->private_data;\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(link_sta->sta);\n\tstruct iwl_mvm *mvm = iwl_mvm_vif_from_mac80211(mvmsta->vif)->mvm;\n\tstruct iwl_mvm_link_sta *mvm_link_sta;\n\tssize_t ret;\n\n\tmutex_lock(&mvm->mutex);\n\n\tmvm_link_sta = rcu_dereference_protected(mvmsta->link[link_sta->link_id],\n\t\t\t\t\t\t lockdep_is_held(&mvm->mutex));\n\tif (WARN_ON(!mvm_link_sta)) {\n\t\tmutex_unlock(&mvm->mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tret = real(link_sta, mvmsta, mvm, mvm_link_sta, user_buf, count, ppos);\n\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret;\n}\n\n#define MVM_DEBUGFS_LINK_STA_WRITE_WRAPPER(name, buflen)\t\t\\\nstatic ssize_t _iwl_dbgfs_link_sta_##name##_write(struct file *file,\t\\\n\t\t\t\t\t const char __user *user_buf,\t\\\n\t\t\t\t\t size_t count, loff_t *ppos)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tchar buf[buflen] = {};\t\t\t\t\t\t\\\n\tsize_t buf_size = min(count, sizeof(buf) -  1);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (copy_from_user(buf, user_buf, buf_size))\t\t\t\\\n\t\treturn -EFAULT;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn _iwl_dbgfs_link_sta_wrap_write(iwl_dbgfs_##name##_write,\t\\\n\t\t\t\t\t      file,\t\t\t\\\n\t\t\t\t\t      buf, buf_size, ppos);\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\n#define MVM_DEBUGFS_LINK_STA_READ_WRAPPER(name)\t\t\\\nstatic ssize_t _iwl_dbgfs_link_sta_##name##_read(struct file *file,\t\\\n\t\t\t\t\t char __user *user_buf,\t\t\\\n\t\t\t\t\t size_t count, loff_t *ppos)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn _iwl_dbgfs_link_sta_wrap_read(iwl_dbgfs_##name##_read,\t\\\n\t\t\t\t\t     file,\t\t\t\\\n\t\t\t\t\t     user_buf, count, ppos);\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\n#define MVM_DEBUGFS_WRITE_LINK_STA_FILE_OPS(name, bufsz)\t\t\\\nMVM_DEBUGFS_LINK_STA_WRITE_WRAPPER(name, bufsz)\t\t\t\t\\\nstatic const struct file_operations iwl_dbgfs_link_sta_##name##_ops = {\t\\\n\t.write = _iwl_dbgfs_link_sta_##name##_write,\t\t\t\\\n\t.open = simple_open,\t\t\t\t\t\t\\\n\t.llseek = generic_file_llseek,\t\t\t\t\t\\\n}\n\n#define MVM_DEBUGFS_READ_LINK_STA_FILE_OPS(name)\t\t\t\\\nMVM_DEBUGFS_LINK_STA_READ_WRAPPER(name)\t\t\t\t\t\\\nstatic const struct file_operations iwl_dbgfs_link_sta_##name##_ops = {\t\\\n\t.read = _iwl_dbgfs_link_sta_##name##_read,\t\t\t\\\n\t.open = simple_open,\t\t\t\t\t\t\\\n\t.llseek = generic_file_llseek,\t\t\t\t\t\\\n}\n\n#define MVM_DEBUGFS_READ_WRITE_LINK_STA_FILE_OPS(name, bufsz)\t\t\\\nMVM_DEBUGFS_LINK_STA_READ_WRAPPER(name)\t\t\t\t\t\\\nMVM_DEBUGFS_LINK_STA_WRITE_WRAPPER(name, bufsz)\t\t\t\t\\\nstatic const struct file_operations iwl_dbgfs_link_sta_##name##_ops = {\t\\\n\t.read = _iwl_dbgfs_link_sta_##name##_read,\t\t\t\\\n\t.write = _iwl_dbgfs_link_sta_##name##_write,\t\t\t\\\n\t.open = simple_open,\t\t\t\t\t\t\\\n\t.llseek = generic_file_llseek,\t\t\t\t\t\\\n}\n\n#define MVM_DEBUGFS_ADD_LINK_STA_FILE_ALIAS(alias, name, parent, mode)\t\\\n\t\tdebugfs_create_file(alias, mode, parent, link_sta,\t\\\n\t\t\t\t    &iwl_dbgfs_link_sta_##name##_ops)\n#define MVM_DEBUGFS_ADD_LINK_STA_FILE(name, parent, mode) \\\n\tMVM_DEBUGFS_ADD_LINK_STA_FILE_ALIAS(#name, name, parent, mode)\n\nstatic ssize_t\niwl_dbgfs_prph_reg_read(struct file *file,\n\t\t\tchar __user *user_buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm *mvm = file->private_data;\n\tint pos = 0;\n\tchar buf[32];\n\tconst size_t bufsz = sizeof(buf);\n\n\tif (!mvm->dbgfs_prph_reg_addr)\n\t\treturn -EINVAL;\n\n\tpos += scnprintf(buf + pos, bufsz - pos, \"Reg 0x%x: (0x%x)\\n\",\n\t\tmvm->dbgfs_prph_reg_addr,\n\t\tiwl_read_prph(mvm->trans, mvm->dbgfs_prph_reg_addr));\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\nstatic ssize_t\niwl_dbgfs_prph_reg_write(struct iwl_mvm *mvm, char *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tu8 args;\n\tu32 value;\n\n\targs = sscanf(buf, \"%i %i\", &mvm->dbgfs_prph_reg_addr, &value);\n\t \n\tif (args == 1)\n\t\tgoto out;\n\n\t \n\tif (args != 2)\n\t\treturn -EINVAL;\n\n\tiwl_write_prph(mvm->trans, mvm->dbgfs_prph_reg_addr, value);\n\nout:\n\treturn count;\n}\n\nstatic ssize_t\niwl_dbgfs_send_echo_cmd_write(struct iwl_mvm *mvm, char *buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tint ret;\n\n\tif (!iwl_mvm_firmware_running(mvm))\n\t\treturn -EIO;\n\n\tmutex_lock(&mvm->mutex);\n\tret = iwl_mvm_send_cmd_pdu(mvm, ECHO_CMD, 0, 0, NULL);\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret ?: count;\n}\n\nstruct iwl_mvm_sniffer_apply {\n\tstruct iwl_mvm *mvm;\n\tu8 *bssid;\n\tu16 aid;\n};\n\nstatic bool iwl_mvm_sniffer_apply(struct iwl_notif_wait_data *notif_data,\n\t\t\t\t  struct iwl_rx_packet *pkt, void *data)\n{\n\tstruct iwl_mvm_sniffer_apply *apply = data;\n\n\tapply->mvm->cur_aid = cpu_to_le16(apply->aid);\n\tmemcpy(apply->mvm->cur_bssid, apply->bssid,\n\t       sizeof(apply->mvm->cur_bssid));\n\n\treturn true;\n}\n\nstatic ssize_t\niwl_dbgfs_he_sniffer_params_write(struct iwl_mvm *mvm, char *buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct iwl_notification_wait wait;\n\tstruct iwl_he_monitor_cmd he_mon_cmd = {};\n\tstruct iwl_mvm_sniffer_apply apply = {\n\t\t.mvm = mvm,\n\t};\n\tu16 wait_cmds[] = {\n\t\tWIDE_ID(DATA_PATH_GROUP, HE_AIR_SNIFFER_CONFIG_CMD),\n\t};\n\tu32 aid;\n\tint ret;\n\n\tif (!iwl_mvm_firmware_running(mvm))\n\t\treturn -EIO;\n\n\tret = sscanf(buf, \"%x %2hhx:%2hhx:%2hhx:%2hhx:%2hhx:%2hhx\", &aid,\n\t\t     &he_mon_cmd.bssid[0], &he_mon_cmd.bssid[1],\n\t\t     &he_mon_cmd.bssid[2], &he_mon_cmd.bssid[3],\n\t\t     &he_mon_cmd.bssid[4], &he_mon_cmd.bssid[5]);\n\tif (ret != 7)\n\t\treturn -EINVAL;\n\n\the_mon_cmd.aid = cpu_to_le16(aid);\n\n\tapply.aid = aid;\n\tapply.bssid = (void *)he_mon_cmd.bssid;\n\n\tmutex_lock(&mvm->mutex);\n\n\t \n\tiwl_init_notification_wait(&mvm->notif_wait, &wait,\n\t\t\t\t   wait_cmds, ARRAY_SIZE(wait_cmds),\n\t\t\t\t   iwl_mvm_sniffer_apply, &apply);\n\n\tret = iwl_mvm_send_cmd_pdu(mvm,\n\t\t\t\t   WIDE_ID(DATA_PATH_GROUP, HE_AIR_SNIFFER_CONFIG_CMD),\n\t\t\t\t   0,\n\t\t\t\t   sizeof(he_mon_cmd), &he_mon_cmd);\n\n\t \n\tiwl_remove_notification(&mvm->notif_wait, &wait);\n\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret ?: count;\n}\n\nstatic ssize_t\niwl_dbgfs_he_sniffer_params_read(struct file *file, char __user *user_buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm *mvm = file->private_data;\n\tu8 buf[32];\n\tint len;\n\n\tlen = scnprintf(buf, sizeof(buf),\n\t\t\t\"%d %02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx\\n\",\n\t\t\tle16_to_cpu(mvm->cur_aid), mvm->cur_bssid[0],\n\t\t\tmvm->cur_bssid[1], mvm->cur_bssid[2], mvm->cur_bssid[3],\n\t\t\tmvm->cur_bssid[4], mvm->cur_bssid[5]);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t\niwl_dbgfs_uapsd_noagg_bssids_read(struct file *file, char __user *user_buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm *mvm = file->private_data;\n\tu8 buf[IWL_MVM_UAPSD_NOAGG_BSSIDS_NUM * ETH_ALEN * 3 + 1];\n\tunsigned int pos = 0;\n\tsize_t bufsz = sizeof(buf);\n\tint i;\n\n\tmutex_lock(&mvm->mutex);\n\n\tfor (i = 0; i < IWL_MVM_UAPSD_NOAGG_LIST_LEN; i++)\n\t\tpos += scnprintf(buf + pos, bufsz - pos, \"%pM\\n\",\n\t\t\t\t mvm->uapsd_noagg_bssids[i].addr);\n\n\tmutex_unlock(&mvm->mutex);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\nstatic ssize_t\niwl_dbgfs_ltr_config_write(struct iwl_mvm *mvm,\n\t\t\t   char *buf, size_t count, loff_t *ppos)\n{\n\tint ret;\n\tstruct iwl_ltr_config_cmd ltr_config = {0};\n\n\tif (!iwl_mvm_firmware_running(mvm))\n\t\treturn -EIO;\n\n\tif (sscanf(buf, \"%x,%x,%x,%x,%x,%x,%x\",\n\t\t   &ltr_config.flags,\n\t\t   &ltr_config.static_long,\n\t\t   &ltr_config.static_short,\n\t\t   &ltr_config.ltr_cfg_values[0],\n\t\t   &ltr_config.ltr_cfg_values[1],\n\t\t   &ltr_config.ltr_cfg_values[2],\n\t\t   &ltr_config.ltr_cfg_values[3]) != 7) {\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&mvm->mutex);\n\tret = iwl_mvm_send_cmd_pdu(mvm, LTR_CONFIG, 0, sizeof(ltr_config),\n\t\t\t\t   &ltr_config);\n\tmutex_unlock(&mvm->mutex);\n\n\tif (ret)\n\t\tIWL_ERR(mvm, \"failed to send ltr configuration cmd\\n\");\n\n\treturn ret ?: count;\n}\n\nstatic ssize_t iwl_dbgfs_rfi_freq_table_write(struct iwl_mvm *mvm, char *buf,\n\t\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tint ret = 0;\n\tu16 op_id;\n\n\tif (kstrtou16(buf, 10, &op_id))\n\t\treturn -EINVAL;\n\n\t \n\tif (!op_id) {\n\t\tmutex_lock(&mvm->mutex);\n\t\tret = iwl_rfi_send_config_cmd(mvm, NULL);\n\t\tmutex_unlock(&mvm->mutex);\n\t} else {\n\t\tret = -EOPNOTSUPP;  \n\t}\n\n\treturn ret ?: count;\n}\n\n \n#define IWL_RFI_BUF_SIZE (IWL_RFI_LUT_INSTALLED_SIZE *\\\n\t\t\t\t(5 + IWL_RFI_LUT_ENTRY_CHANNELS_NUM * (6 + 5)))\n\nstatic ssize_t iwl_dbgfs_rfi_freq_table_read(struct file *file,\n\t\t\t\t\t     char __user *user_buf,\n\t\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm *mvm = file->private_data;\n\tstruct iwl_rfi_freq_table_resp_cmd *resp;\n\tu32 status;\n\tchar buf[IWL_RFI_BUF_SIZE];\n\tint i, j, pos = 0;\n\n\tresp = iwl_rfi_get_freq_table(mvm);\n\tif (IS_ERR(resp))\n\t\treturn PTR_ERR(resp);\n\n\tstatus = le32_to_cpu(resp->status);\n\tif (status != RFI_FREQ_TABLE_OK) {\n\t\tscnprintf(buf, IWL_RFI_BUF_SIZE, \"status = %d\\n\", status);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(resp->table); i++) {\n\t\tpos += scnprintf(buf + pos, IWL_RFI_BUF_SIZE - pos, \"%d: \",\n\t\t\t\t resp->table[i].freq);\n\n\t\tfor (j = 0; j < ARRAY_SIZE(resp->table[i].channels); j++)\n\t\t\tpos += scnprintf(buf + pos, IWL_RFI_BUF_SIZE - pos,\n\t\t\t\t\t \"(%d, %d) \",\n\t\t\t\t\t resp->table[i].channels[j],\n\t\t\t\t\t resp->table[i].bands[j]);\n\t\tpos += scnprintf(buf + pos, IWL_RFI_BUF_SIZE - pos, \"\\n\");\n\t}\n\nout:\n\tkfree(resp);\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\nMVM_DEBUGFS_READ_WRITE_FILE_OPS(prph_reg, 64);\n\n \nMVM_DEBUGFS_READ_FILE_OPS(ctdp_budget);\nMVM_DEBUGFS_WRITE_FILE_OPS(stop_ctdp, 8);\nMVM_DEBUGFS_WRITE_FILE_OPS(force_ctkill, 8);\nMVM_DEBUGFS_WRITE_FILE_OPS(tx_flush, 16);\nMVM_DEBUGFS_WRITE_FILE_OPS(sta_drain, 8);\nMVM_DEBUGFS_WRITE_FILE_OPS(send_echo_cmd, 8);\nMVM_DEBUGFS_READ_WRITE_FILE_OPS(sram, 64);\nMVM_DEBUGFS_READ_WRITE_FILE_OPS(set_nic_temperature, 64);\nMVM_DEBUGFS_READ_FILE_OPS(nic_temp);\nMVM_DEBUGFS_READ_FILE_OPS(stations);\nMVM_DEBUGFS_READ_LINK_STA_FILE_OPS(rs_data);\nMVM_DEBUGFS_READ_FILE_OPS(bt_notif);\nMVM_DEBUGFS_READ_FILE_OPS(bt_cmd);\nMVM_DEBUGFS_READ_WRITE_FILE_OPS(disable_power_off, 64);\nMVM_DEBUGFS_READ_FILE_OPS(fw_rx_stats);\nMVM_DEBUGFS_READ_FILE_OPS(drv_rx_stats);\nMVM_DEBUGFS_READ_FILE_OPS(fw_ver);\nMVM_DEBUGFS_READ_FILE_OPS(phy_integration_ver);\nMVM_DEBUGFS_READ_FILE_OPS(tas_get_status);\nMVM_DEBUGFS_WRITE_FILE_OPS(fw_restart, 10);\nMVM_DEBUGFS_WRITE_FILE_OPS(fw_nmi, 10);\nMVM_DEBUGFS_WRITE_FILE_OPS(bt_tx_prio, 10);\nMVM_DEBUGFS_WRITE_FILE_OPS(bt_force_ant, 10);\nMVM_DEBUGFS_READ_WRITE_FILE_OPS(scan_ant_rxchain, 8);\nMVM_DEBUGFS_READ_WRITE_FILE_OPS(fw_dbg_conf, 8);\nMVM_DEBUGFS_WRITE_FILE_OPS(fw_dbg_collect, 64);\nMVM_DEBUGFS_WRITE_FILE_OPS(dbg_time_point, 64);\nMVM_DEBUGFS_WRITE_FILE_OPS(indirection_tbl,\n\t\t\t   (IWL_RSS_INDIRECTION_TABLE_SIZE * 2));\nMVM_DEBUGFS_WRITE_FILE_OPS(inject_packet, 512);\nMVM_DEBUGFS_WRITE_FILE_OPS(inject_beacon_ie, 512);\nMVM_DEBUGFS_WRITE_FILE_OPS(inject_beacon_ie_restore, 512);\n\nMVM_DEBUGFS_READ_FILE_OPS(uapsd_noagg_bssids);\n\n#ifdef CONFIG_ACPI\nMVM_DEBUGFS_READ_FILE_OPS(sar_geo_profile);\nMVM_DEBUGFS_READ_FILE_OPS(wifi_6e_enable);\n#endif\n\nMVM_DEBUGFS_READ_WRITE_LINK_STA_FILE_OPS(amsdu_len, 16);\n\nMVM_DEBUGFS_READ_WRITE_FILE_OPS(he_sniffer_params, 32);\n\nMVM_DEBUGFS_WRITE_FILE_OPS(ltr_config, 512);\nMVM_DEBUGFS_READ_WRITE_FILE_OPS(rfi_freq_table, 16);\n\nstatic ssize_t iwl_dbgfs_mem_read(struct file *file, char __user *user_buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm *mvm = file->private_data;\n\tstruct iwl_dbg_mem_access_cmd cmd = {};\n\tstruct iwl_dbg_mem_access_rsp *rsp;\n\tstruct iwl_host_cmd hcmd = {\n\t\t.flags = CMD_WANT_SKB | CMD_SEND_IN_RFKILL,\n\t\t.data = { &cmd, },\n\t\t.len = { sizeof(cmd) },\n\t};\n\tsize_t delta;\n\tssize_t ret, len;\n\n\tif (!iwl_mvm_firmware_running(mvm))\n\t\treturn -EIO;\n\n\thcmd.id = WIDE_ID(DEBUG_GROUP, *ppos >> 24 ? UMAC_RD_WR : LMAC_RD_WR);\n\tcmd.op = cpu_to_le32(DEBUG_MEM_OP_READ);\n\n\t \n\tdelta = *ppos & 0x3;\n\tcmd.addr = cpu_to_le32(*ppos - delta);\n\tcmd.len = cpu_to_le32(min(ALIGN(count + delta, 4) / 4,\n\t\t\t\t  (size_t)DEBUG_MEM_MAX_SIZE_DWORDS));\n\n\tmutex_lock(&mvm->mutex);\n\tret = iwl_mvm_send_cmd(mvm, &hcmd);\n\tmutex_unlock(&mvm->mutex);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (iwl_rx_packet_payload_len(hcmd.resp_pkt) < sizeof(*rsp)) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\trsp = (void *)hcmd.resp_pkt->data;\n\tif (le32_to_cpu(rsp->status) != DEBUG_MEM_STATUS_SUCCESS) {\n\t\tret = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tlen = min((size_t)le32_to_cpu(rsp->len) << 2,\n\t\t  iwl_rx_packet_payload_len(hcmd.resp_pkt) - sizeof(*rsp));\n\tlen = min(len - delta, count);\n\tif (len < 0) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tret = len - copy_to_user(user_buf, (u8 *)rsp->data + delta, len);\n\t*ppos += ret;\n\nout:\n\tiwl_free_resp(&hcmd);\n\treturn ret;\n}\n\nstatic ssize_t iwl_dbgfs_mem_write(struct file *file,\n\t\t\t\t   const char __user *user_buf, size_t count,\n\t\t\t\t   loff_t *ppos)\n{\n\tstruct iwl_mvm *mvm = file->private_data;\n\tstruct iwl_dbg_mem_access_cmd *cmd;\n\tstruct iwl_dbg_mem_access_rsp *rsp;\n\tstruct iwl_host_cmd hcmd = {};\n\tsize_t cmd_size;\n\tsize_t data_size;\n\tu32 op, len;\n\tssize_t ret;\n\n\tif (!iwl_mvm_firmware_running(mvm))\n\t\treturn -EIO;\n\n\thcmd.id = WIDE_ID(DEBUG_GROUP, *ppos >> 24 ? UMAC_RD_WR : LMAC_RD_WR);\n\n\tif (*ppos & 0x3 || count < 4) {\n\t\top = DEBUG_MEM_OP_WRITE_BYTES;\n\t\tlen = min(count, (size_t)(4 - (*ppos & 0x3)));\n\t\tdata_size = len;\n\t} else {\n\t\top = DEBUG_MEM_OP_WRITE;\n\t\tlen = min(count >> 2, (size_t)DEBUG_MEM_MAX_SIZE_DWORDS);\n\t\tdata_size = len << 2;\n\t}\n\n\tcmd_size = sizeof(*cmd) + ALIGN(data_size, 4);\n\tcmd = kzalloc(cmd_size, GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->op = cpu_to_le32(op);\n\tcmd->len = cpu_to_le32(len);\n\tcmd->addr = cpu_to_le32(*ppos);\n\tif (copy_from_user((void *)cmd->data, user_buf, data_size)) {\n\t\tkfree(cmd);\n\t\treturn -EFAULT;\n\t}\n\n\thcmd.flags = CMD_WANT_SKB | CMD_SEND_IN_RFKILL,\n\thcmd.data[0] = (void *)cmd;\n\thcmd.len[0] = cmd_size;\n\n\tmutex_lock(&mvm->mutex);\n\tret = iwl_mvm_send_cmd(mvm, &hcmd);\n\tmutex_unlock(&mvm->mutex);\n\n\tkfree(cmd);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (iwl_rx_packet_payload_len(hcmd.resp_pkt) < sizeof(*rsp)) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\trsp = (void *)hcmd.resp_pkt->data;\n\tif (rsp->status != DEBUG_MEM_STATUS_SUCCESS) {\n\t\tret = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tret = data_size;\n\t*ppos += ret;\n\nout:\n\tiwl_free_resp(&hcmd);\n\treturn ret;\n}\n\nstatic const struct file_operations iwl_dbgfs_mem_ops = {\n\t.read = iwl_dbgfs_mem_read,\n\t.write = iwl_dbgfs_mem_write,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nvoid iwl_mvm_link_sta_add_debugfs(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_link_sta *link_sta,\n\t\t\t\t  struct dentry *dir)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\tif (iwl_mvm_has_tlc_offload(mvm)) {\n\t\tMVM_DEBUGFS_ADD_LINK_STA_FILE(rs_data, dir, 0400);\n\t}\n\n\tMVM_DEBUGFS_ADD_LINK_STA_FILE(amsdu_len, dir, 0600);\n}\n\nvoid iwl_mvm_dbgfs_register(struct iwl_mvm *mvm)\n{\n\tstruct dentry *bcast_dir __maybe_unused;\n\n\tspin_lock_init(&mvm->drv_stats_lock);\n\n\tMVM_DEBUGFS_ADD_FILE(tx_flush, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(sta_drain, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(sram, mvm->debugfs_dir, 0600);\n\tMVM_DEBUGFS_ADD_FILE(set_nic_temperature, mvm->debugfs_dir, 0600);\n\tMVM_DEBUGFS_ADD_FILE(nic_temp, mvm->debugfs_dir, 0400);\n\tMVM_DEBUGFS_ADD_FILE(ctdp_budget, mvm->debugfs_dir, 0400);\n\tMVM_DEBUGFS_ADD_FILE(stop_ctdp, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(force_ctkill, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(stations, mvm->debugfs_dir, 0400);\n\tMVM_DEBUGFS_ADD_FILE(bt_notif, mvm->debugfs_dir, 0400);\n\tMVM_DEBUGFS_ADD_FILE(bt_cmd, mvm->debugfs_dir, 0400);\n\tMVM_DEBUGFS_ADD_FILE(disable_power_off, mvm->debugfs_dir, 0600);\n\tMVM_DEBUGFS_ADD_FILE(fw_ver, mvm->debugfs_dir, 0400);\n\tMVM_DEBUGFS_ADD_FILE(fw_rx_stats, mvm->debugfs_dir, 0400);\n\tMVM_DEBUGFS_ADD_FILE(drv_rx_stats, mvm->debugfs_dir, 0400);\n\tMVM_DEBUGFS_ADD_FILE(fw_restart, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(fw_nmi, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(bt_tx_prio, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(bt_force_ant, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(scan_ant_rxchain, mvm->debugfs_dir, 0600);\n\tMVM_DEBUGFS_ADD_FILE(prph_reg, mvm->debugfs_dir, 0600);\n\tMVM_DEBUGFS_ADD_FILE(fw_dbg_conf, mvm->debugfs_dir, 0600);\n\tMVM_DEBUGFS_ADD_FILE(fw_dbg_collect, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(dbg_time_point, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(send_echo_cmd, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(indirection_tbl, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(inject_packet, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(inject_beacon_ie, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(inject_beacon_ie_restore, mvm->debugfs_dir, 0200);\n\tMVM_DEBUGFS_ADD_FILE(rfi_freq_table, mvm->debugfs_dir, 0600);\n\n\tif (mvm->fw->phy_integration_ver)\n\t\tMVM_DEBUGFS_ADD_FILE(phy_integration_ver, mvm->debugfs_dir, 0400);\n\tMVM_DEBUGFS_ADD_FILE(tas_get_status, mvm->debugfs_dir, 0400);\n#ifdef CONFIG_ACPI\n\tMVM_DEBUGFS_ADD_FILE(sar_geo_profile, mvm->debugfs_dir, 0400);\n\tMVM_DEBUGFS_ADD_FILE(wifi_6e_enable, mvm->debugfs_dir, 0400);\n#endif\n\tMVM_DEBUGFS_ADD_FILE(he_sniffer_params, mvm->debugfs_dir, 0600);\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa, IWL_UCODE_TLV_CAPA_SET_LTR_GEN2))\n\t\tMVM_DEBUGFS_ADD_FILE(ltr_config, mvm->debugfs_dir, 0200);\n\n\tdebugfs_create_bool(\"enable_scan_iteration_notif\", 0600,\n\t\t\t    mvm->debugfs_dir, &mvm->scan_iter_notif_enabled);\n\tdebugfs_create_bool(\"drop_bcn_ap_mode\", 0600, mvm->debugfs_dir,\n\t\t\t    &mvm->drop_bcn_ap_mode);\n\n\tMVM_DEBUGFS_ADD_FILE(uapsd_noagg_bssids, mvm->debugfs_dir, S_IRUSR);\n\n#ifdef CONFIG_PM_SLEEP\n\tMVM_DEBUGFS_ADD_FILE(d3_test, mvm->debugfs_dir, 0400);\n\tdebugfs_create_bool(\"d3_wake_sysassert\", 0600, mvm->debugfs_dir,\n\t\t\t    &mvm->d3_wake_sysassert);\n\tdebugfs_create_u32(\"last_netdetect_scans\", 0400, mvm->debugfs_dir,\n\t\t\t   &mvm->last_netdetect_scans);\n#endif\n\n\tdebugfs_create_u8(\"ps_disabled\", 0400, mvm->debugfs_dir,\n\t\t\t  &mvm->ps_disabled);\n\tdebugfs_create_blob(\"nvm_hw\", 0400, mvm->debugfs_dir,\n\t\t\t    &mvm->nvm_hw_blob);\n\tdebugfs_create_blob(\"nvm_sw\", 0400, mvm->debugfs_dir,\n\t\t\t    &mvm->nvm_sw_blob);\n\tdebugfs_create_blob(\"nvm_calib\", 0400, mvm->debugfs_dir,\n\t\t\t    &mvm->nvm_calib_blob);\n\tdebugfs_create_blob(\"nvm_prod\", 0400, mvm->debugfs_dir,\n\t\t\t    &mvm->nvm_prod_blob);\n\tdebugfs_create_blob(\"nvm_phy_sku\", 0400, mvm->debugfs_dir,\n\t\t\t    &mvm->nvm_phy_sku_blob);\n\tdebugfs_create_blob(\"nvm_reg\", S_IRUSR,\n\t\t\t    mvm->debugfs_dir, &mvm->nvm_reg_blob);\n\n\tdebugfs_create_file(\"mem\", 0600, mvm->debugfs_dir, mvm,\n\t\t\t    &iwl_dbgfs_mem_ops);\n\n\t \n\tif (!IS_ERR(mvm->debugfs_dir)) {\n\t\tchar buf[100];\n\n\t\tsnprintf(buf, 100, \"../../%pd2\", mvm->debugfs_dir->d_parent);\n\t\tdebugfs_create_symlink(\"iwlwifi\", mvm->hw->wiphy->debugfsdir,\n\t\t\t\t       buf);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}