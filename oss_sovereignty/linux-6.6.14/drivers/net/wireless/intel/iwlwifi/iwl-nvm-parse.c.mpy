{
  "module_name": "iwl-nvm-parse.c",
  "hash_id": "5f9854133c17e0298b8ea4255d31f3e42d9893a52e518ad1dc2f90b4a1d66579",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/etherdevice.h>\n#include <linux/pci.h>\n#include <linux/firmware.h>\n\n#include \"iwl-drv.h\"\n#include \"iwl-modparams.h\"\n#include \"iwl-nvm-parse.h\"\n#include \"iwl-prph.h\"\n#include \"iwl-io.h\"\n#include \"iwl-csr.h\"\n#include \"fw/acpi.h\"\n#include \"fw/api/nvm-reg.h\"\n#include \"fw/api/commands.h\"\n#include \"fw/api/cmdhdr.h\"\n#include \"fw/img.h\"\n#include \"mei/iwl-mei.h\"\n\n \nenum nvm_offsets {\n\t \n\tSUBSYSTEM_ID = 0x0A,\n\tHW_ADDR = 0x15,\n\n\t \n\tNVM_SW_SECTION = 0x1C0,\n\tNVM_VERSION = 0,\n\tRADIO_CFG = 1,\n\tSKU = 2,\n\tN_HW_ADDRS = 3,\n\tNVM_CHANNELS = 0x1E0 - NVM_SW_SECTION,\n\n\t \n\tNVM_CALIB_SECTION = 0x2B8,\n\tXTAL_CALIB = 0x316 - NVM_CALIB_SECTION,\n\n\t \n\tNVM_CHANNELS_SDP = 0,\n};\n\nenum ext_nvm_offsets {\n\t \n\tMAC_ADDRESS_OVERRIDE_EXT_NVM = 1,\n\n\t \n\tNVM_VERSION_EXT_NVM = 0,\n\tN_HW_ADDRS_FAMILY_8000 = 3,\n\n\t \n\tRADIO_CFG_FAMILY_EXT_NVM = 0,\n\tSKU_FAMILY_8000 = 2,\n\n\t \n\tNVM_CHANNELS_EXTENDED = 0,\n\tNVM_LAR_OFFSET_OLD = 0x4C7,\n\tNVM_LAR_OFFSET = 0x507,\n\tNVM_LAR_ENABLED = 0x7,\n};\n\n \nenum nvm_sku_bits {\n\tNVM_SKU_CAP_BAND_24GHZ\t\t= BIT(0),\n\tNVM_SKU_CAP_BAND_52GHZ\t\t= BIT(1),\n\tNVM_SKU_CAP_11N_ENABLE\t\t= BIT(2),\n\tNVM_SKU_CAP_11AC_ENABLE\t\t= BIT(3),\n\tNVM_SKU_CAP_MIMO_DISABLE\t= BIT(5),\n};\n\n \nstatic const u16 iwl_nvm_channels[] = {\n\t \n\t1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,\n\t \n\t36, 40, 44, 48, 52, 56, 60, 64,\n\t100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144,\n\t149, 153, 157, 161, 165\n};\n\nstatic const u16 iwl_ext_nvm_channels[] = {\n\t \n\t1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,\n\t \n\t36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92,\n\t96, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144,\n\t149, 153, 157, 161, 165, 169, 173, 177, 181\n};\n\nstatic const u16 iwl_uhb_nvm_channels[] = {\n\t \n\t1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,\n\t \n\t36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92,\n\t96, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144,\n\t149, 153, 157, 161, 165, 169, 173, 177, 181,\n\t \n\t1, 5, 9, 13, 17, 21, 25, 29, 33, 37, 41, 45, 49, 53, 57, 61, 65, 69,\n\t73, 77, 81, 85, 89, 93, 97, 101, 105, 109, 113, 117, 121, 125, 129,\n\t133, 137, 141, 145, 149, 153, 157, 161, 165, 169, 173, 177, 181, 185,\n\t189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 233\n};\n\n#define IWL_NVM_NUM_CHANNELS\t\tARRAY_SIZE(iwl_nvm_channels)\n#define IWL_NVM_NUM_CHANNELS_EXT\tARRAY_SIZE(iwl_ext_nvm_channels)\n#define IWL_NVM_NUM_CHANNELS_UHB\tARRAY_SIZE(iwl_uhb_nvm_channels)\n#define NUM_2GHZ_CHANNELS\t\t14\n#define NUM_5GHZ_CHANNELS\t\t37\n#define FIRST_2GHZ_HT_MINUS\t\t5\n#define LAST_2GHZ_HT_PLUS\t\t9\n#define N_HW_ADDR_MASK\t\t\t0xF\n\n \nstatic struct ieee80211_rate iwl_cfg80211_rates[] = {\n\t{ .bitrate = 1 * 10, .hw_value = 0, .hw_value_short = 0, },\n\t{ .bitrate = 2 * 10, .hw_value = 1, .hw_value_short = 1,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE, },\n\t{ .bitrate = 5.5 * 10, .hw_value = 2, .hw_value_short = 2,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE, },\n\t{ .bitrate = 11 * 10, .hw_value = 3, .hw_value_short = 3,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE, },\n\t{ .bitrate = 6 * 10, .hw_value = 4, .hw_value_short = 4, },\n\t{ .bitrate = 9 * 10, .hw_value = 5, .hw_value_short = 5, },\n\t{ .bitrate = 12 * 10, .hw_value = 6, .hw_value_short = 6, },\n\t{ .bitrate = 18 * 10, .hw_value = 7, .hw_value_short = 7, },\n\t{ .bitrate = 24 * 10, .hw_value = 8, .hw_value_short = 8, },\n\t{ .bitrate = 36 * 10, .hw_value = 9, .hw_value_short = 9, },\n\t{ .bitrate = 48 * 10, .hw_value = 10, .hw_value_short = 10, },\n\t{ .bitrate = 54 * 10, .hw_value = 11, .hw_value_short = 11, },\n};\n#define RATES_24_OFFS\t0\n#define N_RATES_24\tARRAY_SIZE(iwl_cfg80211_rates)\n#define RATES_52_OFFS\t4\n#define N_RATES_52\t(N_RATES_24 - RATES_52_OFFS)\n\n \nenum iwl_nvm_channel_flags {\n\tNVM_CHANNEL_VALID\t\t= BIT(0),\n\tNVM_CHANNEL_IBSS\t\t= BIT(1),\n\tNVM_CHANNEL_ACTIVE\t\t= BIT(3),\n\tNVM_CHANNEL_RADAR\t\t= BIT(4),\n\tNVM_CHANNEL_INDOOR_ONLY\t\t= BIT(5),\n\tNVM_CHANNEL_GO_CONCURRENT\t= BIT(6),\n\tNVM_CHANNEL_UNIFORM\t\t= BIT(7),\n\tNVM_CHANNEL_20MHZ\t\t= BIT(8),\n\tNVM_CHANNEL_40MHZ\t\t= BIT(9),\n\tNVM_CHANNEL_80MHZ\t\t= BIT(10),\n\tNVM_CHANNEL_160MHZ\t\t= BIT(11),\n\tNVM_CHANNEL_DC_HIGH\t\t= BIT(12),\n};\n\n \nenum iwl_reg_capa_flags_v1 {\n\tREG_CAPA_V1_BF_CCD_LOW_BAND\t= BIT(0),\n\tREG_CAPA_V1_BF_CCD_HIGH_BAND\t= BIT(1),\n\tREG_CAPA_V1_160MHZ_ALLOWED\t= BIT(2),\n\tREG_CAPA_V1_80MHZ_ALLOWED\t= BIT(3),\n\tREG_CAPA_V1_MCS_8_ALLOWED\t= BIT(4),\n\tREG_CAPA_V1_MCS_9_ALLOWED\t= BIT(5),\n\tREG_CAPA_V1_40MHZ_FORBIDDEN\t= BIT(7),\n\tREG_CAPA_V1_DC_HIGH_ENABLED\t= BIT(9),\n\tREG_CAPA_V1_11AX_DISABLED\t= BIT(10),\n};  \n\n \nenum iwl_reg_capa_flags_v2 {\n\tREG_CAPA_V2_STRADDLE_DISABLED\t= BIT(0),\n\tREG_CAPA_V2_BF_CCD_LOW_BAND\t= BIT(1),\n\tREG_CAPA_V2_BF_CCD_HIGH_BAND\t= BIT(2),\n\tREG_CAPA_V2_160MHZ_ALLOWED\t= BIT(3),\n\tREG_CAPA_V2_80MHZ_ALLOWED\t= BIT(4),\n\tREG_CAPA_V2_MCS_8_ALLOWED\t= BIT(5),\n\tREG_CAPA_V2_MCS_9_ALLOWED\t= BIT(6),\n\tREG_CAPA_V2_WEATHER_DISABLED\t= BIT(7),\n\tREG_CAPA_V2_40MHZ_ALLOWED\t= BIT(8),\n\tREG_CAPA_V2_11AX_DISABLED\t= BIT(10),\n};  \n\n \nenum iwl_reg_capa_flags_v4 {\n\tREG_CAPA_V4_160MHZ_ALLOWED\t\t= BIT(3),\n\tREG_CAPA_V4_80MHZ_ALLOWED\t\t= BIT(4),\n\tREG_CAPA_V4_MCS_12_ALLOWED\t\t= BIT(5),\n\tREG_CAPA_V4_MCS_13_ALLOWED\t\t= BIT(6),\n\tREG_CAPA_V4_11BE_DISABLED\t\t= BIT(8),\n\tREG_CAPA_V4_11AX_DISABLED\t\t= BIT(13),\n\tREG_CAPA_V4_320MHZ_ALLOWED\t\t= BIT(16),\n};  \n\n \n#define REG_CAPA_V2_RESP_VER\t6\n\n \n#define REG_CAPA_V4_RESP_VER\t8\n\n \nstruct iwl_reg_capa {\n\tbool allow_40mhz;\n\tbool allow_80mhz;\n\tbool allow_160mhz;\n\tbool allow_320mhz;\n\tbool disable_11ax;\n\tbool disable_11be;\n};\n\nstatic inline void iwl_nvm_print_channel_flags(struct device *dev, u32 level,\n\t\t\t\t\t       int chan, u32 flags)\n{\n#define CHECK_AND_PRINT_I(x)\t\\\n\t((flags & NVM_CHANNEL_##x) ? \" \" #x : \"\")\n\n\tif (!(flags & NVM_CHANNEL_VALID)) {\n\t\tIWL_DEBUG_DEV(dev, level, \"Ch. %d: 0x%x: No traffic\\n\",\n\t\t\t      chan, flags);\n\t\treturn;\n\t}\n\n\t \n\tIWL_DEBUG_DEV(dev, level,\n\t\t      \"Ch. %d: 0x%x:%s%s%s%s%s%s%s%s%s%s%s%s\\n\",\n\t\t      chan, flags,\n\t\t      CHECK_AND_PRINT_I(VALID),\n\t\t      CHECK_AND_PRINT_I(IBSS),\n\t\t      CHECK_AND_PRINT_I(ACTIVE),\n\t\t      CHECK_AND_PRINT_I(RADAR),\n\t\t      CHECK_AND_PRINT_I(INDOOR_ONLY),\n\t\t      CHECK_AND_PRINT_I(GO_CONCURRENT),\n\t\t      CHECK_AND_PRINT_I(UNIFORM),\n\t\t      CHECK_AND_PRINT_I(20MHZ),\n\t\t      CHECK_AND_PRINT_I(40MHZ),\n\t\t      CHECK_AND_PRINT_I(80MHZ),\n\t\t      CHECK_AND_PRINT_I(160MHZ),\n\t\t      CHECK_AND_PRINT_I(DC_HIGH));\n#undef CHECK_AND_PRINT_I\n}\n\nstatic u32 iwl_get_channel_flags(u8 ch_num, int ch_idx, enum nl80211_band band,\n\t\t\t\t u32 nvm_flags, const struct iwl_cfg *cfg)\n{\n\tu32 flags = IEEE80211_CHAN_NO_HT40;\n\n\tif (band == NL80211_BAND_2GHZ && (nvm_flags & NVM_CHANNEL_40MHZ)) {\n\t\tif (ch_num <= LAST_2GHZ_HT_PLUS)\n\t\t\tflags &= ~IEEE80211_CHAN_NO_HT40PLUS;\n\t\tif (ch_num >= FIRST_2GHZ_HT_MINUS)\n\t\t\tflags &= ~IEEE80211_CHAN_NO_HT40MINUS;\n\t} else if (nvm_flags & NVM_CHANNEL_40MHZ) {\n\t\tif ((ch_idx - NUM_2GHZ_CHANNELS) % 2 == 0)\n\t\t\tflags &= ~IEEE80211_CHAN_NO_HT40PLUS;\n\t\telse\n\t\t\tflags &= ~IEEE80211_CHAN_NO_HT40MINUS;\n\t}\n\tif (!(nvm_flags & NVM_CHANNEL_80MHZ))\n\t\tflags |= IEEE80211_CHAN_NO_80MHZ;\n\tif (!(nvm_flags & NVM_CHANNEL_160MHZ))\n\t\tflags |= IEEE80211_CHAN_NO_160MHZ;\n\n\tif (!(nvm_flags & NVM_CHANNEL_IBSS))\n\t\tflags |= IEEE80211_CHAN_NO_IR;\n\n\tif (!(nvm_flags & NVM_CHANNEL_ACTIVE))\n\t\tflags |= IEEE80211_CHAN_NO_IR;\n\n\tif (nvm_flags & NVM_CHANNEL_RADAR)\n\t\tflags |= IEEE80211_CHAN_RADAR;\n\n\tif (nvm_flags & NVM_CHANNEL_INDOOR_ONLY)\n\t\tflags |= IEEE80211_CHAN_INDOOR_ONLY;\n\n\t \n\tif ((nvm_flags & NVM_CHANNEL_GO_CONCURRENT) &&\n\t    (flags & IEEE80211_CHAN_NO_IR))\n\t\tflags |= IEEE80211_CHAN_IR_CONCURRENT;\n\n\treturn flags;\n}\n\nstatic enum nl80211_band iwl_nl80211_band_from_channel_idx(int ch_idx)\n{\n\tif (ch_idx >= NUM_2GHZ_CHANNELS + NUM_5GHZ_CHANNELS) {\n\t\treturn NL80211_BAND_6GHZ;\n\t}\n\n\tif (ch_idx >= NUM_2GHZ_CHANNELS)\n\t\treturn NL80211_BAND_5GHZ;\n\treturn NL80211_BAND_2GHZ;\n}\n\nstatic int iwl_init_channel_map(struct device *dev, const struct iwl_cfg *cfg,\n\t\t\t\tstruct iwl_nvm_data *data,\n\t\t\t\tconst void * const nvm_ch_flags,\n\t\t\t\tu32 sbands_flags, bool v4)\n{\n\tint ch_idx;\n\tint n_channels = 0;\n\tstruct ieee80211_channel *channel;\n\tu32 ch_flags;\n\tint num_of_ch;\n\tconst u16 *nvm_chan;\n\n\tif (cfg->uhb_supported) {\n\t\tnum_of_ch = IWL_NVM_NUM_CHANNELS_UHB;\n\t\tnvm_chan = iwl_uhb_nvm_channels;\n\t} else if (cfg->nvm_type == IWL_NVM_EXT) {\n\t\tnum_of_ch = IWL_NVM_NUM_CHANNELS_EXT;\n\t\tnvm_chan = iwl_ext_nvm_channels;\n\t} else {\n\t\tnum_of_ch = IWL_NVM_NUM_CHANNELS;\n\t\tnvm_chan = iwl_nvm_channels;\n\t}\n\n\tfor (ch_idx = 0; ch_idx < num_of_ch; ch_idx++) {\n\t\tenum nl80211_band band =\n\t\t\tiwl_nl80211_band_from_channel_idx(ch_idx);\n\n\t\tif (v4)\n\t\t\tch_flags =\n\t\t\t\t__le32_to_cpup((const __le32 *)nvm_ch_flags + ch_idx);\n\t\telse\n\t\t\tch_flags =\n\t\t\t\t__le16_to_cpup((const __le16 *)nvm_ch_flags + ch_idx);\n\n\t\tif (band == NL80211_BAND_5GHZ &&\n\t\t    !data->sku_cap_band_52ghz_enable)\n\t\t\tcontinue;\n\n\t\t \n\t\tif ((sbands_flags & IWL_NVM_SBANDS_FLAGS_NO_WIDE_IN_5GHZ) &&\n\t\t    band == NL80211_BAND_5GHZ) {\n\t\t\tch_flags &= ~(NVM_CHANNEL_40MHZ |\n\t\t\t\t     NVM_CHANNEL_80MHZ |\n\t\t\t\t     NVM_CHANNEL_160MHZ);\n\t\t}\n\n\t\tif (ch_flags & NVM_CHANNEL_160MHZ)\n\t\t\tdata->vht160_supported = true;\n\n\t\tif (!(sbands_flags & IWL_NVM_SBANDS_FLAGS_LAR) &&\n\t\t    !(ch_flags & NVM_CHANNEL_VALID)) {\n\t\t\t \n\t\t\tiwl_nvm_print_channel_flags(dev, IWL_DL_EEPROM,\n\t\t\t\t\t\t    nvm_chan[ch_idx], ch_flags);\n\t\t\tcontinue;\n\t\t}\n\n\t\tchannel = &data->channels[n_channels];\n\t\tn_channels++;\n\n\t\tchannel->hw_value = nvm_chan[ch_idx];\n\t\tchannel->band = band;\n\t\tchannel->center_freq =\n\t\t\tieee80211_channel_to_frequency(\n\t\t\t\tchannel->hw_value, channel->band);\n\n\t\t \n\n\t\t \n\t\tchannel->max_power = IWL_DEFAULT_MAX_TX_POWER;\n\n\t\t \n\t\tif (!(sbands_flags & IWL_NVM_SBANDS_FLAGS_LAR))\n\t\t\tchannel->flags = iwl_get_channel_flags(nvm_chan[ch_idx],\n\t\t\t\t\t\t\t       ch_idx, band,\n\t\t\t\t\t\t\t       ch_flags, cfg);\n\t\telse\n\t\t\tchannel->flags = 0;\n\n\t\t \n\t\tif (cfg->uhb_supported)\n\t\t\tchannel->flags = 0;\n\t\tiwl_nvm_print_channel_flags(dev, IWL_DL_EEPROM,\n\t\t\t\t\t    channel->hw_value, ch_flags);\n\t\tIWL_DEBUG_EEPROM(dev, \"Ch. %d: %ddBm\\n\",\n\t\t\t\t channel->hw_value, channel->max_power);\n\t}\n\n\treturn n_channels;\n}\n\nstatic void iwl_init_vht_hw_capab(struct iwl_trans *trans,\n\t\t\t\t  struct iwl_nvm_data *data,\n\t\t\t\t  struct ieee80211_sta_vht_cap *vht_cap,\n\t\t\t\t  u8 tx_chains, u8 rx_chains)\n{\n\tconst struct iwl_cfg *cfg = trans->cfg;\n\tint num_rx_ants = num_of_ant(rx_chains);\n\tint num_tx_ants = num_of_ant(tx_chains);\n\n\tvht_cap->vht_supported = true;\n\n\tvht_cap->cap = IEEE80211_VHT_CAP_SHORT_GI_80 |\n\t\t       IEEE80211_VHT_CAP_RXSTBC_1 |\n\t\t       IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE |\n\t\t       3 << IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT |\n\t\t       IEEE80211_VHT_MAX_AMPDU_1024K <<\n\t\t       IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT;\n\n\tif (!trans->cfg->ht_params->stbc)\n\t\tvht_cap->cap &= ~IEEE80211_VHT_CAP_RXSTBC_MASK;\n\n\tif (data->vht160_supported)\n\t\tvht_cap->cap |= IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ |\n\t\t\t\tIEEE80211_VHT_CAP_SHORT_GI_160;\n\n\tif (cfg->vht_mu_mimo_supported)\n\t\tvht_cap->cap |= IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE;\n\n\tif (cfg->ht_params->ldpc)\n\t\tvht_cap->cap |= IEEE80211_VHT_CAP_RXLDPC;\n\n\tif (data->sku_cap_mimo_disabled) {\n\t\tnum_rx_ants = 1;\n\t\tnum_tx_ants = 1;\n\t}\n\n\tif (trans->cfg->ht_params->stbc && num_tx_ants > 1)\n\t\tvht_cap->cap |= IEEE80211_VHT_CAP_TXSTBC;\n\telse\n\t\tvht_cap->cap |= IEEE80211_VHT_CAP_TX_ANTENNA_PATTERN;\n\n\tswitch (iwlwifi_mod_params.amsdu_size) {\n\tcase IWL_AMSDU_DEF:\n\t\tif (trans->trans_cfg->mq_rx_supported)\n\t\t\tvht_cap->cap |=\n\t\t\t\tIEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454;\n\t\telse\n\t\t\tvht_cap->cap |= IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_3895;\n\t\tbreak;\n\tcase IWL_AMSDU_2K:\n\t\tif (trans->trans_cfg->mq_rx_supported)\n\t\t\tvht_cap->cap |=\n\t\t\t\tIEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454;\n\t\telse\n\t\t\tWARN(1, \"RB size of 2K is not supported by this device\\n\");\n\t\tbreak;\n\tcase IWL_AMSDU_4K:\n\t\tvht_cap->cap |= IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_3895;\n\t\tbreak;\n\tcase IWL_AMSDU_8K:\n\t\tvht_cap->cap |= IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991;\n\t\tbreak;\n\tcase IWL_AMSDU_12K:\n\t\tvht_cap->cap |= IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tvht_cap->vht_mcs.rx_mcs_map =\n\t\tcpu_to_le16(IEEE80211_VHT_MCS_SUPPORT_0_9 << 0 |\n\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 2 |\n\t\t\t    IEEE80211_VHT_MCS_NOT_SUPPORTED << 4 |\n\t\t\t    IEEE80211_VHT_MCS_NOT_SUPPORTED << 6 |\n\t\t\t    IEEE80211_VHT_MCS_NOT_SUPPORTED << 8 |\n\t\t\t    IEEE80211_VHT_MCS_NOT_SUPPORTED << 10 |\n\t\t\t    IEEE80211_VHT_MCS_NOT_SUPPORTED << 12 |\n\t\t\t    IEEE80211_VHT_MCS_NOT_SUPPORTED << 14);\n\n\tif (num_rx_ants == 1 || cfg->rx_with_siso_diversity) {\n\t\tvht_cap->cap |= IEEE80211_VHT_CAP_RX_ANTENNA_PATTERN;\n\t\t \n\t\tvht_cap->vht_mcs.rx_mcs_map |=\n\t\t\tcpu_to_le16(IEEE80211_VHT_MCS_NOT_SUPPORTED << 2);\n\t}\n\n\tvht_cap->vht_mcs.tx_mcs_map = vht_cap->vht_mcs.rx_mcs_map;\n\n\tvht_cap->vht_mcs.tx_highest |=\n\t\tcpu_to_le16(IEEE80211_VHT_EXT_NSS_BW_CAPABLE);\n}\n\nstatic const u8 iwl_vendor_caps[] = {\n\t0xdd,\t\t\t \n\t0x06,\t\t\t \n\t0x00, 0x17, 0x35,\t \n\t0x08,\t\t\t \n\t \n#define IWL_VENDOR_CAP_IMPROVED_BF_FDBK_HE\tBIT(0)\n\tIWL_VENDOR_CAP_IMPROVED_BF_FDBK_HE,\n\t0x00\n};\n\nstatic const struct ieee80211_sband_iftype_data iwl_he_eht_capa[] = {\n\t{\n\t\t.types_mask = BIT(NL80211_IFTYPE_STATION),\n\t\t.he_cap = {\n\t\t\t.has_he = true,\n\t\t\t.he_cap_elem = {\n\t\t\t\t.mac_cap_info[0] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP0_HTC_HE,\n\t\t\t\t.mac_cap_info[1] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,\n\t\t\t\t.mac_cap_info[2] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP2_32BIT_BA_BITMAP,\n\t\t\t\t.mac_cap_info[3] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP3_OMI_CONTROL |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP3_RX_CTRL_FRAME_TO_MULTIBSS,\n\t\t\t\t.mac_cap_info[4] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP4_MULTI_TID_AGG_TX_QOS_B39,\n\t\t\t\t.mac_cap_info[5] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP5_MULTI_TID_AGG_TX_QOS_B40 |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP5_MULTI_TID_AGG_TX_QOS_B41 |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP5_UL_2x996_TONE_RU |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP5_HE_DYNAMIC_SM_PS |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP5_HT_VHT_TRIG_FRAME_RX,\n\t\t\t\t.phy_cap_info[1] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD,\n\t\t\t\t.phy_cap_info[2] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ,\n\t\t\t\t.phy_cap_info[3] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_BPSK |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP3_DCM_MAX_TX_NSS_1 |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_BPSK |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP3_DCM_MAX_RX_NSS_1,\n\t\t\t\t.phy_cap_info[4] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP4_SU_BEAMFORMEE |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_ABOVE_80MHZ_8 |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_8,\n\t\t\t\t.phy_cap_info[6] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP6_TRIG_SU_BEAMFORMING_FB |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP6_TRIG_MU_BEAMFORMING_PARTIAL_BW_FB |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT,\n\t\t\t\t.phy_cap_info[7] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP7_POWER_BOOST_FACTOR_SUPP |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP7_HE_SU_MU_PPDU_4XLTF_AND_08_US_GI,\n\t\t\t\t.phy_cap_info[8] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP8_HE_ER_SU_PPDU_4XLTF_AND_08_US_GI |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP8_20MHZ_IN_40MHZ_HE_PPDU_IN_2G |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP8_20MHZ_IN_160MHZ_HE_PPDU |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP8_80MHZ_IN_160MHZ_HE_PPDU |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP8_DCM_MAX_RU_242,\n\t\t\t\t.phy_cap_info[9] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_COMP_SIGB |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_NON_COMP_SIGB |\n\t\t\t\t\t(IEEE80211_HE_PHY_CAP9_NOMINAL_PKT_PADDING_RESERVED <<\n\t\t\t\t\tIEEE80211_HE_PHY_CAP9_NOMINAL_PKT_PADDING_POS),\n\t\t\t\t.phy_cap_info[10] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP10_HE_MU_M1RU_MAX_LTF,\n\t\t\t},\n\t\t\t \n\t\t\t.he_mcs_nss_supp = {\n\t\t\t\t.rx_mcs_80 = cpu_to_le16(0xfffa),\n\t\t\t\t.tx_mcs_80 = cpu_to_le16(0xfffa),\n\t\t\t\t.rx_mcs_160 = cpu_to_le16(0xfffa),\n\t\t\t\t.tx_mcs_160 = cpu_to_le16(0xfffa),\n\t\t\t\t.rx_mcs_80p80 = cpu_to_le16(0xffff),\n\t\t\t\t.tx_mcs_80p80 = cpu_to_le16(0xffff),\n\t\t\t},\n\t\t\t \n\t\t\t.ppe_thres = {0x61, 0x1c, 0xc7, 0x71},\n\t\t},\n\t\t.eht_cap = {\n\t\t\t.has_eht = true,\n\t\t\t.eht_cap_elem = {\n\t\t\t\t.mac_cap_info[0] =\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP0_EPCS_PRIO_ACCESS |\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP0_OM_CONTROL |\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP0_TRIG_TXOP_SHARING_MODE1 |\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP0_TRIG_TXOP_SHARING_MODE2,\n\t\t\t\t.phy_cap_info[0] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_242_TONE_RU_GT20MHZ |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_NDP_4_EHT_LFT_32_GI |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_PARTIAL_BW_UL_MU_MIMO |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_SU_BEAMFORMEE |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_BEAMFORMEE_SS_80MHZ_MASK,\n\t\t\t\t.phy_cap_info[1] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP1_BEAMFORMEE_SS_80MHZ_MASK  |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP1_BEAMFORMEE_SS_160MHZ_MASK,\n\t\t\t\t.phy_cap_info[3] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_NG_16_SU_FEEDBACK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_NG_16_MU_FEEDBACK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_CODEBOOK_4_2_SU_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_CODEBOOK_7_5_MU_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_TRIG_SU_BF_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_TRIG_MU_BF_PART_BW_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_TRIG_CQI_FDBK,\n\n\t\t\t\t.phy_cap_info[4] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_PART_BW_DL_MU_MIMO |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_POWER_BOOST_FACT_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_EHT_MU_PPDU_4_EHT_LTF_08_GI,\n\t\t\t\t.phy_cap_info[5] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_NON_TRIG_CQI_FEEDBACK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_TX_LESS_242_TONE_RU_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_RX_LESS_242_TONE_RU_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_PPE_THRESHOLD_PRESENT,\n\t\t\t\t.phy_cap_info[6] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP6_MCS15_SUPP_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP6_EHT_DUP_6GHZ_SUPP,\n\t\t\t\t.phy_cap_info[8] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP8_RX_1024QAM_WIDER_BW_DL_OFDMA |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP8_RX_4096QAM_WIDER_BW_DL_OFDMA,\n\t\t\t},\n\n\t\t\t \n\t\t\t.eht_mcs_nss_supp = {\n\t\t\t\t.bw._80 = {\n\t\t\t\t\t.rx_tx_mcs9_max_nss = 0x22,\n\t\t\t\t\t.rx_tx_mcs11_max_nss = 0x22,\n\t\t\t\t\t.rx_tx_mcs13_max_nss = 0x22,\n\t\t\t\t},\n\t\t\t\t.bw._160 = {\n\t\t\t\t\t.rx_tx_mcs9_max_nss = 0x22,\n\t\t\t\t\t.rx_tx_mcs11_max_nss = 0x22,\n\t\t\t\t\t.rx_tx_mcs13_max_nss = 0x22,\n\t\t\t\t},\n\t\t\t\t.bw._320 = {\n\t\t\t\t\t.rx_tx_mcs9_max_nss = 0x22,\n\t\t\t\t\t.rx_tx_mcs11_max_nss = 0x22,\n\t\t\t\t\t.rx_tx_mcs13_max_nss = 0x22,\n\t\t\t\t},\n\t\t\t},\n\n\t\t\t \n\t\t\t.eht_ppe_thres = {0xc1, 0x0e, 0xe0 }\n\t\t},\n\t},\n\t{\n\t\t.types_mask = BIT(NL80211_IFTYPE_AP),\n\t\t.he_cap = {\n\t\t\t.has_he = true,\n\t\t\t.he_cap_elem = {\n\t\t\t\t.mac_cap_info[0] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP0_HTC_HE,\n\t\t\t\t.mac_cap_info[1] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,\n\t\t\t\t.mac_cap_info[3] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP3_OMI_CONTROL,\n\t\t\t\t.phy_cap_info[1] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD,\n\t\t\t\t.phy_cap_info[2] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US,\n\t\t\t\t.phy_cap_info[3] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_BPSK |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP3_DCM_MAX_TX_NSS_1 |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_BPSK |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP3_DCM_MAX_RX_NSS_1,\n\t\t\t\t.phy_cap_info[6] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT,\n\t\t\t\t.phy_cap_info[7] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP7_HE_SU_MU_PPDU_4XLTF_AND_08_US_GI,\n\t\t\t\t.phy_cap_info[8] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP8_HE_ER_SU_PPDU_4XLTF_AND_08_US_GI |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP8_DCM_MAX_RU_242,\n\t\t\t\t.phy_cap_info[9] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP9_NOMINAL_PKT_PADDING_RESERVED\n\t\t\t\t\t<< IEEE80211_HE_PHY_CAP9_NOMINAL_PKT_PADDING_POS,\n\t\t\t},\n\t\t\t \n\t\t\t.he_mcs_nss_supp = {\n\t\t\t\t.rx_mcs_80 = cpu_to_le16(0xfffa),\n\t\t\t\t.tx_mcs_80 = cpu_to_le16(0xfffa),\n\t\t\t\t.rx_mcs_160 = cpu_to_le16(0xfffa),\n\t\t\t\t.tx_mcs_160 = cpu_to_le16(0xfffa),\n\t\t\t\t.rx_mcs_80p80 = cpu_to_le16(0xffff),\n\t\t\t\t.tx_mcs_80p80 = cpu_to_le16(0xffff),\n\t\t\t},\n\t\t\t \n\t\t\t.ppe_thres = {0x61, 0x1c, 0xc7, 0x71},\n\t\t},\n\t\t.eht_cap = {\n\t\t\t.has_eht = true,\n\t\t\t.eht_cap_elem = {\n\t\t\t\t.mac_cap_info[0] =\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP0_EPCS_PRIO_ACCESS |\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP0_OM_CONTROL |\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP0_TRIG_TXOP_SHARING_MODE1 |\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP0_TRIG_TXOP_SHARING_MODE2,\n\t\t\t\t.phy_cap_info[0] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_242_TONE_RU_GT20MHZ |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_NDP_4_EHT_LFT_32_GI,\n\t\t\t\t.phy_cap_info[5] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_PPE_THRESHOLD_PRESENT,\n\t\t\t},\n\n\t\t\t \n\t\t\t.eht_mcs_nss_supp = {\n\t\t\t\t.bw._80 = {\n\t\t\t\t\t.rx_tx_mcs9_max_nss = 0x22,\n\t\t\t\t\t.rx_tx_mcs11_max_nss = 0x22,\n\t\t\t\t\t.rx_tx_mcs13_max_nss = 0x22,\n\t\t\t\t},\n\t\t\t\t.bw._160 = {\n\t\t\t\t\t.rx_tx_mcs9_max_nss = 0x22,\n\t\t\t\t\t.rx_tx_mcs11_max_nss = 0x22,\n\t\t\t\t\t.rx_tx_mcs13_max_nss = 0x22,\n\t\t\t\t},\n\t\t\t\t.bw._320 = {\n\t\t\t\t\t.rx_tx_mcs9_max_nss = 0x22,\n\t\t\t\t\t.rx_tx_mcs11_max_nss = 0x22,\n\t\t\t\t\t.rx_tx_mcs13_max_nss = 0x22,\n\t\t\t\t},\n\t\t\t},\n\n\t\t\t \n\t\t\t.eht_ppe_thres = {0xc1, 0x0e, 0xe0 }\n\t\t},\n\t},\n};\n\nstatic void iwl_init_he_6ghz_capa(struct iwl_trans *trans,\n\t\t\t\t  struct iwl_nvm_data *data,\n\t\t\t\t  struct ieee80211_supported_band *sband,\n\t\t\t\t  u8 tx_chains, u8 rx_chains)\n{\n\tstruct ieee80211_sta_ht_cap ht_cap;\n\tstruct ieee80211_sta_vht_cap vht_cap = {};\n\tstruct ieee80211_sband_iftype_data *iftype_data;\n\tu16 he_6ghz_capa = 0;\n\tu32 exp;\n\tint i;\n\n\tif (sband->band != NL80211_BAND_6GHZ)\n\t\treturn;\n\n\t \n\tiwl_init_ht_hw_capab(trans, data, &ht_cap, NL80211_BAND_5GHZ,\n\t\t\t     tx_chains, rx_chains);\n\tWARN_ON(!ht_cap.ht_supported);\n\tiwl_init_vht_hw_capab(trans, data, &vht_cap, tx_chains, rx_chains);\n\tWARN_ON(!vht_cap.vht_supported);\n\n\the_6ghz_capa |=\n\t\tu16_encode_bits(ht_cap.ampdu_density,\n\t\t\t\tIEEE80211_HE_6GHZ_CAP_MIN_MPDU_START);\n\texp = u32_get_bits(vht_cap.cap,\n\t\t\t   IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK);\n\the_6ghz_capa |=\n\t\tu16_encode_bits(exp, IEEE80211_HE_6GHZ_CAP_MAX_AMPDU_LEN_EXP);\n\texp = u32_get_bits(vht_cap.cap, IEEE80211_VHT_CAP_MAX_MPDU_MASK);\n\the_6ghz_capa |=\n\t\tu16_encode_bits(exp, IEEE80211_HE_6GHZ_CAP_MAX_MPDU_LEN);\n\t \n\tif (vht_cap.cap & IEEE80211_VHT_CAP_TX_ANTENNA_PATTERN)\n\t\the_6ghz_capa |= IEEE80211_HE_6GHZ_CAP_TX_ANTPAT_CONS;\n\tif (vht_cap.cap & IEEE80211_VHT_CAP_RX_ANTENNA_PATTERN)\n\t\the_6ghz_capa |= IEEE80211_HE_6GHZ_CAP_RX_ANTPAT_CONS;\n\n\tIWL_DEBUG_EEPROM(trans->dev, \"he_6ghz_capa=0x%x\\n\", he_6ghz_capa);\n\n\t \n\tiftype_data = (void *)(uintptr_t)sband->iftype_data;\n\tfor (i = 0; i < sband->n_iftype_data; i++)\n\t\tiftype_data[i].he_6ghz_capa.capa = cpu_to_le16(he_6ghz_capa);\n}\n\nstatic void\niwl_nvm_fixup_sband_iftd(struct iwl_trans *trans,\n\t\t\t struct iwl_nvm_data *data,\n\t\t\t struct ieee80211_supported_band *sband,\n\t\t\t struct ieee80211_sband_iftype_data *iftype_data,\n\t\t\t u8 tx_chains, u8 rx_chains,\n\t\t\t const struct iwl_fw *fw)\n{\n\tbool is_ap = iftype_data->types_mask & BIT(NL80211_IFTYPE_AP);\n\tbool no_320;\n\n\tno_320 = !trans->trans_cfg->integrated &&\n\t\t trans->pcie_link_speed < PCI_EXP_LNKSTA_CLS_8_0GB;\n\n\tif (!data->sku_cap_11be_enable || iwlwifi_mod_params.disable_11be)\n\t\tiftype_data->eht_cap.has_eht = false;\n\n\t \n\tif (sband->band == NL80211_BAND_6GHZ && iftype_data->eht_cap.has_eht)\n\t\tiftype_data->he_cap.he_cap_elem.mac_cap_info[3] |=\n\t\t\tIEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_2;\n\telse if (sband->band != NL80211_BAND_2GHZ)\n\t\tiftype_data->he_cap.he_cap_elem.mac_cap_info[3] |=\n\t\t\tIEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_1;\n\telse\n\t\tiftype_data->he_cap.he_cap_elem.mac_cap_info[3] |=\n\t\t\tIEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_3;\n\n\tswitch (sband->band) {\n\tcase NL80211_BAND_2GHZ:\n\t\tiftype_data->he_cap.he_cap_elem.phy_cap_info[0] |=\n\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G;\n\t\tiftype_data->eht_cap.eht_cap_elem.mac_cap_info[0] |=\n\t\t\tu8_encode_bits(IEEE80211_EHT_MAC_CAP0_MAX_MPDU_LEN_11454,\n\t\t\t\t       IEEE80211_EHT_MAC_CAP0_MAX_MPDU_LEN_MASK);\n\t\tbreak;\n\tcase NL80211_BAND_6GHZ:\n\t\tif (!no_320) {\n\t\t\tiftype_data->eht_cap.eht_cap_elem.phy_cap_info[0] |=\n\t\t\t\tIEEE80211_EHT_PHY_CAP0_320MHZ_IN_6GHZ;\n\t\t\tiftype_data->eht_cap.eht_cap_elem.phy_cap_info[1] |=\n\t\t\t\tIEEE80211_EHT_PHY_CAP1_BEAMFORMEE_SS_320MHZ_MASK;\n\t\t}\n\t\tfallthrough;\n\tcase NL80211_BAND_5GHZ:\n\t\tiftype_data->he_cap.he_cap_elem.phy_cap_info[0] |=\n\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |\n\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tif ((tx_chains & rx_chains) == ANT_AB) {\n\t\tiftype_data->he_cap.he_cap_elem.phy_cap_info[2] |=\n\t\t\tIEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ;\n\t\tiftype_data->he_cap.he_cap_elem.phy_cap_info[5] |=\n\t\t\tIEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_2 |\n\t\t\tIEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_ABOVE_80MHZ_2;\n\t\tif (!is_ap) {\n\t\t\tiftype_data->he_cap.he_cap_elem.phy_cap_info[7] |=\n\t\t\t\tIEEE80211_HE_PHY_CAP7_MAX_NC_2;\n\n\t\t\tif (iftype_data->eht_cap.has_eht) {\n\t\t\t\t \n\t\t\t\tiftype_data->eht_cap.eht_cap_elem.phy_cap_info[2] |= 0x49;\n\n\t\t\t\t \n\t\t\t\tiftype_data->eht_cap.eht_cap_elem.phy_cap_info[4] |= 0x10;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (iftype_data->eht_cap.has_eht) {\n\t\t\tstruct ieee80211_eht_mcs_nss_supp *mcs_nss =\n\t\t\t\t&iftype_data->eht_cap.eht_mcs_nss_supp;\n\n\t\t\tmemset(mcs_nss, 0x11, sizeof(*mcs_nss));\n\t\t}\n\n\t\tif (!is_ap) {\n\t\t\t \n\t\t\tiftype_data->he_cap.he_cap_elem.phy_cap_info[1] &=\n\t\t\t\t~IEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS;\n\t\t\tiftype_data->he_cap.he_cap_elem.phy_cap_info[2] &=\n\t\t\t\t~IEEE80211_HE_PHY_CAP2_MIDAMBLE_RX_TX_MAX_NSTS;\n\t\t\tiftype_data->he_cap.he_cap_elem.phy_cap_info[7] |=\n\t\t\t\tIEEE80211_HE_PHY_CAP7_MAX_NC_1;\n\t\t}\n\t}\n\n\tif (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_AX210 && !is_ap)\n\t\tiftype_data->he_cap.he_cap_elem.phy_cap_info[2] |=\n\t\t\tIEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO;\n\n\tswitch (CSR_HW_RFID_TYPE(trans->hw_rf_id)) {\n\tcase IWL_CFG_RF_TYPE_GF:\n\tcase IWL_CFG_RF_TYPE_MR:\n\tcase IWL_CFG_RF_TYPE_MS:\n\tcase IWL_CFG_RF_TYPE_FM:\n\tcase IWL_CFG_RF_TYPE_WH:\n\t\tiftype_data->he_cap.he_cap_elem.phy_cap_info[9] |=\n\t\t\tIEEE80211_HE_PHY_CAP9_TX_1024_QAM_LESS_THAN_242_TONE_RU;\n\t\tif (!is_ap)\n\t\t\tiftype_data->he_cap.he_cap_elem.phy_cap_info[9] |=\n\t\t\t\tIEEE80211_HE_PHY_CAP9_RX_1024_QAM_LESS_THAN_242_TONE_RU;\n\t\tbreak;\n\t}\n\n\tif (CSR_HW_REV_TYPE(trans->hw_rev) == IWL_CFG_MAC_TYPE_GL &&\n\t    iftype_data->eht_cap.has_eht) {\n\t\tiftype_data->eht_cap.eht_cap_elem.mac_cap_info[0] &=\n\t\t\t~(IEEE80211_EHT_MAC_CAP0_EPCS_PRIO_ACCESS |\n\t\t\t  IEEE80211_EHT_MAC_CAP0_TRIG_TXOP_SHARING_MODE1 |\n\t\t\t  IEEE80211_EHT_MAC_CAP0_TRIG_TXOP_SHARING_MODE2);\n\t\tiftype_data->eht_cap.eht_cap_elem.phy_cap_info[3] &=\n\t\t\t~(IEEE80211_EHT_PHY_CAP0_PARTIAL_BW_UL_MU_MIMO |\n\t\t\t  IEEE80211_EHT_PHY_CAP3_NG_16_SU_FEEDBACK |\n\t\t\t  IEEE80211_EHT_PHY_CAP3_NG_16_MU_FEEDBACK |\n\t\t\t  IEEE80211_EHT_PHY_CAP3_CODEBOOK_4_2_SU_FDBK |\n\t\t\t  IEEE80211_EHT_PHY_CAP3_CODEBOOK_7_5_MU_FDBK |\n\t\t\t  IEEE80211_EHT_PHY_CAP3_TRIG_MU_BF_PART_BW_FDBK |\n\t\t\t  IEEE80211_EHT_PHY_CAP3_TRIG_CQI_FDBK);\n\t\tiftype_data->eht_cap.eht_cap_elem.phy_cap_info[4] &=\n\t\t\t~(IEEE80211_EHT_PHY_CAP4_PART_BW_DL_MU_MIMO |\n\t\t\t  IEEE80211_EHT_PHY_CAP4_POWER_BOOST_FACT_SUPP);\n\t\tiftype_data->eht_cap.eht_cap_elem.phy_cap_info[5] &=\n\t\t\t~IEEE80211_EHT_PHY_CAP5_NON_TRIG_CQI_FEEDBACK;\n\t\tiftype_data->eht_cap.eht_cap_elem.phy_cap_info[6] &=\n\t\t\t~(IEEE80211_EHT_PHY_CAP6_MCS15_SUPP_MASK |\n\t\t\t  IEEE80211_EHT_PHY_CAP6_EHT_DUP_6GHZ_SUPP);\n\t\tiftype_data->eht_cap.eht_cap_elem.phy_cap_info[5] |=\n\t\t\tIEEE80211_EHT_PHY_CAP5_SUPP_EXTRA_EHT_LTF;\n\t}\n\n\tif (fw_has_capa(&fw->ucode_capa, IWL_UCODE_TLV_CAPA_BROADCAST_TWT))\n\t\tiftype_data->he_cap.he_cap_elem.mac_cap_info[2] |=\n\t\t\tIEEE80211_HE_MAC_CAP2_BCAST_TWT;\n\n\tif (trans->trans_cfg->device_family == IWL_DEVICE_FAMILY_22000 &&\n\t    !is_ap) {\n\t\tiftype_data->vendor_elems.data = iwl_vendor_caps;\n\t\tiftype_data->vendor_elems.len = ARRAY_SIZE(iwl_vendor_caps);\n\t}\n\n\tif (!trans->cfg->ht_params->stbc) {\n\t\tiftype_data->he_cap.he_cap_elem.phy_cap_info[2] &=\n\t\t\t~IEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ;\n\t\tiftype_data->he_cap.he_cap_elem.phy_cap_info[7] &=\n\t\t\t~IEEE80211_HE_PHY_CAP7_STBC_RX_ABOVE_80MHZ;\n\t}\n}\n\nstatic void iwl_init_he_hw_capab(struct iwl_trans *trans,\n\t\t\t\t struct iwl_nvm_data *data,\n\t\t\t\t struct ieee80211_supported_band *sband,\n\t\t\t\t u8 tx_chains, u8 rx_chains,\n\t\t\t\t const struct iwl_fw *fw)\n{\n\tstruct ieee80211_sband_iftype_data *iftype_data;\n\tint i;\n\n\t \n\tif (WARN_ON(sband->iftype_data))\n\t\treturn;\n\n\tBUILD_BUG_ON(sizeof(data->iftd.low) != sizeof(iwl_he_eht_capa));\n\tBUILD_BUG_ON(sizeof(data->iftd.high) != sizeof(iwl_he_eht_capa));\n\tBUILD_BUG_ON(sizeof(data->iftd.uhb) != sizeof(iwl_he_eht_capa));\n\n\tswitch (sband->band) {\n\tcase NL80211_BAND_2GHZ:\n\t\tiftype_data = data->iftd.low;\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\tiftype_data = data->iftd.high;\n\t\tbreak;\n\tcase NL80211_BAND_6GHZ:\n\t\tiftype_data = data->iftd.uhb;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tmemcpy(iftype_data, iwl_he_eht_capa, sizeof(iwl_he_eht_capa));\n\n\tsband->iftype_data = iftype_data;\n\tsband->n_iftype_data = ARRAY_SIZE(iwl_he_eht_capa);\n\n\tfor (i = 0; i < sband->n_iftype_data; i++)\n\t\tiwl_nvm_fixup_sband_iftd(trans, data, sband, &iftype_data[i],\n\t\t\t\t\t tx_chains, rx_chains, fw);\n\n\tiwl_init_he_6ghz_capa(trans, data, sband, tx_chains, rx_chains);\n}\n\nstatic void iwl_init_sbands(struct iwl_trans *trans,\n\t\t\t    struct iwl_nvm_data *data,\n\t\t\t    const void *nvm_ch_flags, u8 tx_chains,\n\t\t\t    u8 rx_chains, u32 sbands_flags, bool v4,\n\t\t\t    const struct iwl_fw *fw)\n{\n\tstruct device *dev = trans->dev;\n\tconst struct iwl_cfg *cfg = trans->cfg;\n\tint n_channels;\n\tint n_used = 0;\n\tstruct ieee80211_supported_band *sband;\n\n\tn_channels = iwl_init_channel_map(dev, cfg, data, nvm_ch_flags,\n\t\t\t\t\t  sbands_flags, v4);\n\tsband = &data->bands[NL80211_BAND_2GHZ];\n\tsband->band = NL80211_BAND_2GHZ;\n\tsband->bitrates = &iwl_cfg80211_rates[RATES_24_OFFS];\n\tsband->n_bitrates = N_RATES_24;\n\tn_used += iwl_init_sband_channels(data, sband, n_channels,\n\t\t\t\t\t  NL80211_BAND_2GHZ);\n\tiwl_init_ht_hw_capab(trans, data, &sband->ht_cap, NL80211_BAND_2GHZ,\n\t\t\t     tx_chains, rx_chains);\n\n\tif (data->sku_cap_11ax_enable && !iwlwifi_mod_params.disable_11ax)\n\t\tiwl_init_he_hw_capab(trans, data, sband, tx_chains, rx_chains,\n\t\t\t\t     fw);\n\n\tsband = &data->bands[NL80211_BAND_5GHZ];\n\tsband->band = NL80211_BAND_5GHZ;\n\tsband->bitrates = &iwl_cfg80211_rates[RATES_52_OFFS];\n\tsband->n_bitrates = N_RATES_52;\n\tn_used += iwl_init_sband_channels(data, sband, n_channels,\n\t\t\t\t\t  NL80211_BAND_5GHZ);\n\tiwl_init_ht_hw_capab(trans, data, &sband->ht_cap, NL80211_BAND_5GHZ,\n\t\t\t     tx_chains, rx_chains);\n\tif (data->sku_cap_11ac_enable && !iwlwifi_mod_params.disable_11ac)\n\t\tiwl_init_vht_hw_capab(trans, data, &sband->vht_cap,\n\t\t\t\t      tx_chains, rx_chains);\n\n\tif (data->sku_cap_11ax_enable && !iwlwifi_mod_params.disable_11ax)\n\t\tiwl_init_he_hw_capab(trans, data, sband, tx_chains, rx_chains,\n\t\t\t\t     fw);\n\n\t \n\tsband = &data->bands[NL80211_BAND_6GHZ];\n\tsband->band = NL80211_BAND_6GHZ;\n\t \n\tsband->bitrates = &iwl_cfg80211_rates[RATES_52_OFFS];\n\tsband->n_bitrates = N_RATES_52;\n\tn_used += iwl_init_sband_channels(data, sband, n_channels,\n\t\t\t\t\t  NL80211_BAND_6GHZ);\n\n\tif (data->sku_cap_11ax_enable && !iwlwifi_mod_params.disable_11ax)\n\t\tiwl_init_he_hw_capab(trans, data, sband, tx_chains, rx_chains,\n\t\t\t\t     fw);\n\telse\n\t\tsband->n_channels = 0;\n\tif (n_channels != n_used)\n\t\tIWL_ERR_DEV(dev, \"NVM: used only %d of %d channels\\n\",\n\t\t\t    n_used, n_channels);\n}\n\nstatic int iwl_get_sku(const struct iwl_cfg *cfg, const __le16 *nvm_sw,\n\t\t       const __le16 *phy_sku)\n{\n\tif (cfg->nvm_type != IWL_NVM_EXT)\n\t\treturn le16_to_cpup(nvm_sw + SKU);\n\n\treturn le32_to_cpup((const __le32 *)(phy_sku + SKU_FAMILY_8000));\n}\n\nstatic int iwl_get_nvm_version(const struct iwl_cfg *cfg, const __le16 *nvm_sw)\n{\n\tif (cfg->nvm_type != IWL_NVM_EXT)\n\t\treturn le16_to_cpup(nvm_sw + NVM_VERSION);\n\telse\n\t\treturn le32_to_cpup((const __le32 *)(nvm_sw +\n\t\t\t\t\t\t     NVM_VERSION_EXT_NVM));\n}\n\nstatic int iwl_get_radio_cfg(const struct iwl_cfg *cfg, const __le16 *nvm_sw,\n\t\t\t     const __le16 *phy_sku)\n{\n\tif (cfg->nvm_type != IWL_NVM_EXT)\n\t\treturn le16_to_cpup(nvm_sw + RADIO_CFG);\n\n\treturn le32_to_cpup((const __le32 *)(phy_sku + RADIO_CFG_FAMILY_EXT_NVM));\n\n}\n\nstatic int iwl_get_n_hw_addrs(const struct iwl_cfg *cfg, const __le16 *nvm_sw)\n{\n\tint n_hw_addr;\n\n\tif (cfg->nvm_type != IWL_NVM_EXT)\n\t\treturn le16_to_cpup(nvm_sw + N_HW_ADDRS);\n\n\tn_hw_addr = le32_to_cpup((const __le32 *)(nvm_sw + N_HW_ADDRS_FAMILY_8000));\n\n\treturn n_hw_addr & N_HW_ADDR_MASK;\n}\n\nstatic void iwl_set_radio_cfg(const struct iwl_cfg *cfg,\n\t\t\t      struct iwl_nvm_data *data,\n\t\t\t      u32 radio_cfg)\n{\n\tif (cfg->nvm_type != IWL_NVM_EXT) {\n\t\tdata->radio_cfg_type = NVM_RF_CFG_TYPE_MSK(radio_cfg);\n\t\tdata->radio_cfg_step = NVM_RF_CFG_STEP_MSK(radio_cfg);\n\t\tdata->radio_cfg_dash = NVM_RF_CFG_DASH_MSK(radio_cfg);\n\t\tdata->radio_cfg_pnum = NVM_RF_CFG_PNUM_MSK(radio_cfg);\n\t\treturn;\n\t}\n\n\t \n\tdata->radio_cfg_type = EXT_NVM_RF_CFG_TYPE_MSK(radio_cfg);\n\tdata->radio_cfg_step = EXT_NVM_RF_CFG_STEP_MSK(radio_cfg);\n\tdata->radio_cfg_dash = EXT_NVM_RF_CFG_DASH_MSK(radio_cfg);\n\tdata->radio_cfg_pnum = EXT_NVM_RF_CFG_FLAVOR_MSK(radio_cfg);\n\tdata->valid_tx_ant = EXT_NVM_RF_CFG_TX_ANT_MSK(radio_cfg);\n\tdata->valid_rx_ant = EXT_NVM_RF_CFG_RX_ANT_MSK(radio_cfg);\n}\n\nstatic void iwl_flip_hw_address(__le32 mac_addr0, __le32 mac_addr1, u8 *dest)\n{\n\tconst u8 *hw_addr;\n\n\thw_addr = (const u8 *)&mac_addr0;\n\tdest[0] = hw_addr[3];\n\tdest[1] = hw_addr[2];\n\tdest[2] = hw_addr[1];\n\tdest[3] = hw_addr[0];\n\n\thw_addr = (const u8 *)&mac_addr1;\n\tdest[4] = hw_addr[1];\n\tdest[5] = hw_addr[0];\n}\n\nstatic void iwl_set_hw_address_from_csr(struct iwl_trans *trans,\n\t\t\t\t\tstruct iwl_nvm_data *data)\n{\n\t__le32 mac_addr0 = cpu_to_le32(iwl_read32(trans,\n\t\t\t\t\t\t  CSR_MAC_ADDR0_STRAP(trans)));\n\t__le32 mac_addr1 = cpu_to_le32(iwl_read32(trans,\n\t\t\t\t\t\t  CSR_MAC_ADDR1_STRAP(trans)));\n\n\tiwl_flip_hw_address(mac_addr0, mac_addr1, data->hw_addr);\n\t \n\tif (is_valid_ether_addr(data->hw_addr))\n\t\treturn;\n\n\tmac_addr0 = cpu_to_le32(iwl_read32(trans, CSR_MAC_ADDR0_OTP(trans)));\n\tmac_addr1 = cpu_to_le32(iwl_read32(trans, CSR_MAC_ADDR1_OTP(trans)));\n\n\tiwl_flip_hw_address(mac_addr0, mac_addr1, data->hw_addr);\n}\n\nstatic void iwl_set_hw_address_family_8000(struct iwl_trans *trans,\n\t\t\t\t\t   const struct iwl_cfg *cfg,\n\t\t\t\t\t   struct iwl_nvm_data *data,\n\t\t\t\t\t   const __le16 *mac_override,\n\t\t\t\t\t   const __be16 *nvm_hw)\n{\n\tconst u8 *hw_addr;\n\n\tif (mac_override) {\n\t\tstatic const u8 reserved_mac[] = {\n\t\t\t0x02, 0xcc, 0xaa, 0xff, 0xee, 0x00\n\t\t};\n\n\t\thw_addr = (const u8 *)(mac_override +\n\t\t\t\t MAC_ADDRESS_OVERRIDE_EXT_NVM);\n\n\t\t \n\t\tmemcpy(data->hw_addr, hw_addr, ETH_ALEN);\n\n\t\t \n\t\tif (is_valid_ether_addr(data->hw_addr) &&\n\t\t    memcmp(reserved_mac, hw_addr, ETH_ALEN) != 0)\n\t\t\treturn;\n\n\t\tIWL_ERR(trans,\n\t\t\t\"mac address from nvm override section is not valid\\n\");\n\t}\n\n\tif (nvm_hw) {\n\t\t \n\t\t__le32 mac_addr0 = cpu_to_le32(iwl_trans_read_prph(trans,\n\t\t\t\t\t\tWFMP_MAC_ADDR_0));\n\t\t__le32 mac_addr1 = cpu_to_le32(iwl_trans_read_prph(trans,\n\t\t\t\t\t\tWFMP_MAC_ADDR_1));\n\n\t\tiwl_flip_hw_address(mac_addr0, mac_addr1, data->hw_addr);\n\n\t\treturn;\n\t}\n\n\tIWL_ERR(trans, \"mac address is not found\\n\");\n}\n\nstatic int iwl_set_hw_address(struct iwl_trans *trans,\n\t\t\t      const struct iwl_cfg *cfg,\n\t\t\t      struct iwl_nvm_data *data, const __be16 *nvm_hw,\n\t\t\t      const __le16 *mac_override)\n{\n\tif (cfg->mac_addr_from_csr) {\n\t\tiwl_set_hw_address_from_csr(trans, data);\n\t} else if (cfg->nvm_type != IWL_NVM_EXT) {\n\t\tconst u8 *hw_addr = (const u8 *)(nvm_hw + HW_ADDR);\n\n\t\t \n\t\tdata->hw_addr[0] = hw_addr[1];\n\t\tdata->hw_addr[1] = hw_addr[0];\n\t\tdata->hw_addr[2] = hw_addr[3];\n\t\tdata->hw_addr[3] = hw_addr[2];\n\t\tdata->hw_addr[4] = hw_addr[5];\n\t\tdata->hw_addr[5] = hw_addr[4];\n\t} else {\n\t\tiwl_set_hw_address_family_8000(trans, cfg, data,\n\t\t\t\t\t       mac_override, nvm_hw);\n\t}\n\n\tif (!is_valid_ether_addr(data->hw_addr)) {\n\t\tIWL_ERR(trans, \"no valid mac address was found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!trans->csme_own)\n\t\tIWL_INFO(trans, \"base HW address: %pM, OTP minor version: 0x%x\\n\",\n\t\t\t data->hw_addr, iwl_read_prph(trans, REG_OTP_MINOR));\n\n\treturn 0;\n}\n\nstatic bool\niwl_nvm_no_wide_in_5ghz(struct iwl_trans *trans, const struct iwl_cfg *cfg,\n\t\t\tconst __be16 *nvm_hw)\n{\n\t \n\tif (trans->trans_cfg->device_family == IWL_DEVICE_FAMILY_7000) {\n\t\t \n\t\tu16 subsystem_id = be16_to_cpup(nvm_hw + SUBSYSTEM_ID);\n\t\tu8 sku = (subsystem_id & 0x1e) >> 1;\n\n\t\tif (sku == 5 || sku == 9) {\n\t\t\tIWL_DEBUG_EEPROM(trans->dev,\n\t\t\t\t\t \"disabling wide channels in 5GHz (0x%0x %d)\\n\",\n\t\t\t\t\t subsystem_id, sku);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstruct iwl_nvm_data *\niwl_parse_mei_nvm_data(struct iwl_trans *trans, const struct iwl_cfg *cfg,\n\t\t       const struct iwl_mei_nvm *mei_nvm,\n\t\t       const struct iwl_fw *fw)\n{\n\tstruct iwl_nvm_data *data;\n\tu32 sbands_flags = 0;\n\tu8 rx_chains = fw->valid_rx_ant;\n\tu8 tx_chains = fw->valid_rx_ant;\n\n\tif (cfg->uhb_supported)\n\t\tdata = kzalloc(struct_size(data, channels,\n\t\t\t\t\t   IWL_NVM_NUM_CHANNELS_UHB),\n\t\t\t\t\t   GFP_KERNEL);\n\telse\n\t\tdata = kzalloc(struct_size(data, channels,\n\t\t\t\t\t   IWL_NVM_NUM_CHANNELS_EXT),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!data)\n\t\treturn NULL;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(mei_nvm->channels) !=\n\t\t     IWL_NVM_NUM_CHANNELS_UHB);\n\tdata->nvm_version = mei_nvm->nvm_version;\n\n\tiwl_set_radio_cfg(cfg, data, mei_nvm->radio_cfg);\n\tif (data->valid_tx_ant)\n\t\ttx_chains &= data->valid_tx_ant;\n\tif (data->valid_rx_ant)\n\t\trx_chains &= data->valid_rx_ant;\n\n\tdata->sku_cap_mimo_disabled = false;\n\tdata->sku_cap_band_24ghz_enable = true;\n\tdata->sku_cap_band_52ghz_enable = true;\n\tdata->sku_cap_11n_enable =\n\t\t!(iwlwifi_mod_params.disable_11n & IWL_DISABLE_HT_ALL);\n\tdata->sku_cap_11ac_enable = true;\n\tdata->sku_cap_11ax_enable =\n\t\tmei_nvm->caps & MEI_NVM_CAPS_11AX_SUPPORT;\n\n\tdata->lar_enabled = mei_nvm->caps & MEI_NVM_CAPS_LARI_SUPPORT;\n\n\tdata->n_hw_addrs = mei_nvm->n_hw_addrs;\n\t \n\tif (iwl_set_hw_address(trans, cfg, data, NULL, NULL)) {\n\t\tkfree(data);\n\t\treturn NULL;\n\t}\n\n\tif (data->lar_enabled &&\n\t    fw_has_capa(&fw->ucode_capa, IWL_UCODE_TLV_CAPA_LAR_SUPPORT))\n\t\tsbands_flags |= IWL_NVM_SBANDS_FLAGS_LAR;\n\n\tiwl_init_sbands(trans, data, mei_nvm->channels, tx_chains, rx_chains,\n\t\t\tsbands_flags, true, fw);\n\n\treturn data;\n}\nIWL_EXPORT_SYMBOL(iwl_parse_mei_nvm_data);\n\nstruct iwl_nvm_data *\niwl_parse_nvm_data(struct iwl_trans *trans, const struct iwl_cfg *cfg,\n\t\t   const struct iwl_fw *fw,\n\t\t   const __be16 *nvm_hw, const __le16 *nvm_sw,\n\t\t   const __le16 *nvm_calib, const __le16 *regulatory,\n\t\t   const __le16 *mac_override, const __le16 *phy_sku,\n\t\t   u8 tx_chains, u8 rx_chains)\n{\n\tstruct iwl_nvm_data *data;\n\tbool lar_enabled;\n\tu32 sku, radio_cfg;\n\tu32 sbands_flags = 0;\n\tu16 lar_config;\n\tconst __le16 *ch_section;\n\n\tif (cfg->uhb_supported)\n\t\tdata = kzalloc(struct_size(data, channels,\n\t\t\t\t\t   IWL_NVM_NUM_CHANNELS_UHB),\n\t\t\t\t\t   GFP_KERNEL);\n\telse if (cfg->nvm_type != IWL_NVM_EXT)\n\t\tdata = kzalloc(struct_size(data, channels,\n\t\t\t\t\t   IWL_NVM_NUM_CHANNELS),\n\t\t\t\t\t   GFP_KERNEL);\n\telse\n\t\tdata = kzalloc(struct_size(data, channels,\n\t\t\t\t\t   IWL_NVM_NUM_CHANNELS_EXT),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!data)\n\t\treturn NULL;\n\n\tdata->nvm_version = iwl_get_nvm_version(cfg, nvm_sw);\n\n\tradio_cfg = iwl_get_radio_cfg(cfg, nvm_sw, phy_sku);\n\tiwl_set_radio_cfg(cfg, data, radio_cfg);\n\tif (data->valid_tx_ant)\n\t\ttx_chains &= data->valid_tx_ant;\n\tif (data->valid_rx_ant)\n\t\trx_chains &= data->valid_rx_ant;\n\n\tsku = iwl_get_sku(cfg, nvm_sw, phy_sku);\n\tdata->sku_cap_band_24ghz_enable = sku & NVM_SKU_CAP_BAND_24GHZ;\n\tdata->sku_cap_band_52ghz_enable = sku & NVM_SKU_CAP_BAND_52GHZ;\n\tdata->sku_cap_11n_enable = sku & NVM_SKU_CAP_11N_ENABLE;\n\tif (iwlwifi_mod_params.disable_11n & IWL_DISABLE_HT_ALL)\n\t\tdata->sku_cap_11n_enable = false;\n\tdata->sku_cap_11ac_enable = data->sku_cap_11n_enable &&\n\t\t\t\t    (sku & NVM_SKU_CAP_11AC_ENABLE);\n\tdata->sku_cap_mimo_disabled = sku & NVM_SKU_CAP_MIMO_DISABLE;\n\n\tdata->n_hw_addrs = iwl_get_n_hw_addrs(cfg, nvm_sw);\n\n\tif (cfg->nvm_type != IWL_NVM_EXT) {\n\t\t \n\t\tif (!nvm_calib) {\n\t\t\tIWL_ERR(trans,\n\t\t\t\t\"Can't parse empty Calib NVM sections\\n\");\n\t\t\tkfree(data);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tch_section = cfg->nvm_type == IWL_NVM_SDP ?\n\t\t\t     &regulatory[NVM_CHANNELS_SDP] :\n\t\t\t     &nvm_sw[NVM_CHANNELS];\n\n\t\t \n\t\tdata->xtal_calib[0] = *(nvm_calib + XTAL_CALIB);\n\t\tdata->xtal_calib[1] = *(nvm_calib + XTAL_CALIB + 1);\n\t\tlar_enabled = true;\n\t} else {\n\t\tu16 lar_offset = data->nvm_version < 0xE39 ?\n\t\t\t\t NVM_LAR_OFFSET_OLD :\n\t\t\t\t NVM_LAR_OFFSET;\n\n\t\tlar_config = le16_to_cpup(regulatory + lar_offset);\n\t\tdata->lar_enabled = !!(lar_config &\n\t\t\t\t       NVM_LAR_ENABLED);\n\t\tlar_enabled = data->lar_enabled;\n\t\tch_section = &regulatory[NVM_CHANNELS_EXTENDED];\n\t}\n\n\t \n\tif (iwl_set_hw_address(trans, cfg, data, nvm_hw, mac_override)) {\n\t\tkfree(data);\n\t\treturn NULL;\n\t}\n\n\tif (lar_enabled &&\n\t    fw_has_capa(&fw->ucode_capa, IWL_UCODE_TLV_CAPA_LAR_SUPPORT))\n\t\tsbands_flags |= IWL_NVM_SBANDS_FLAGS_LAR;\n\n\tif (iwl_nvm_no_wide_in_5ghz(trans, cfg, nvm_hw))\n\t\tsbands_flags |= IWL_NVM_SBANDS_FLAGS_NO_WIDE_IN_5GHZ;\n\n\tiwl_init_sbands(trans, data, ch_section, tx_chains, rx_chains,\n\t\t\tsbands_flags, false, fw);\n\tdata->calib_version = 255;\n\n\treturn data;\n}\nIWL_EXPORT_SYMBOL(iwl_parse_nvm_data);\n\nstatic u32 iwl_nvm_get_regdom_bw_flags(const u16 *nvm_chan,\n\t\t\t\t       int ch_idx, u16 nvm_flags,\n\t\t\t\t       struct iwl_reg_capa reg_capa,\n\t\t\t\t       const struct iwl_cfg *cfg)\n{\n\tu32 flags = NL80211_RRF_NO_HT40;\n\n\tif (ch_idx < NUM_2GHZ_CHANNELS &&\n\t    (nvm_flags & NVM_CHANNEL_40MHZ)) {\n\t\tif (nvm_chan[ch_idx] <= LAST_2GHZ_HT_PLUS)\n\t\t\tflags &= ~NL80211_RRF_NO_HT40PLUS;\n\t\tif (nvm_chan[ch_idx] >= FIRST_2GHZ_HT_MINUS)\n\t\t\tflags &= ~NL80211_RRF_NO_HT40MINUS;\n\t} else if (nvm_flags & NVM_CHANNEL_40MHZ) {\n\t\tif ((ch_idx - NUM_2GHZ_CHANNELS) % 2 == 0)\n\t\t\tflags &= ~NL80211_RRF_NO_HT40PLUS;\n\t\telse\n\t\t\tflags &= ~NL80211_RRF_NO_HT40MINUS;\n\t}\n\n\tif (!(nvm_flags & NVM_CHANNEL_80MHZ))\n\t\tflags |= NL80211_RRF_NO_80MHZ;\n\tif (!(nvm_flags & NVM_CHANNEL_160MHZ))\n\t\tflags |= NL80211_RRF_NO_160MHZ;\n\n\tif (!(nvm_flags & NVM_CHANNEL_ACTIVE))\n\t\tflags |= NL80211_RRF_NO_IR;\n\n\tif (nvm_flags & NVM_CHANNEL_RADAR)\n\t\tflags |= NL80211_RRF_DFS;\n\n\tif (nvm_flags & NVM_CHANNEL_INDOOR_ONLY)\n\t\tflags |= NL80211_RRF_NO_OUTDOOR;\n\n\t \n\tif ((nvm_flags & NVM_CHANNEL_GO_CONCURRENT) &&\n\t    (flags & NL80211_RRF_NO_IR))\n\t\tflags |= NL80211_RRF_GO_CONCURRENT;\n\n\t \n\tif (ch_idx >= NUM_2GHZ_CHANNELS) {\n\t\tif (!reg_capa.allow_40mhz)\n\t\t\tflags |= NL80211_RRF_NO_HT40;\n\n\t\tif (!reg_capa.allow_80mhz)\n\t\t\tflags |= NL80211_RRF_NO_80MHZ;\n\n\t\tif (!reg_capa.allow_160mhz)\n\t\t\tflags |= NL80211_RRF_NO_160MHZ;\n\n\t\tif (!reg_capa.allow_320mhz)\n\t\t\tflags |= NL80211_RRF_NO_320MHZ;\n\t}\n\n\tif (reg_capa.disable_11ax)\n\t\tflags |= NL80211_RRF_NO_HE;\n\n\tif (reg_capa.disable_11be)\n\t\tflags |= NL80211_RRF_NO_EHT;\n\n\treturn flags;\n}\n\nstatic struct iwl_reg_capa iwl_get_reg_capa(u32 flags, u8 resp_ver)\n{\n\tstruct iwl_reg_capa reg_capa = {};\n\n\tif (resp_ver >= REG_CAPA_V4_RESP_VER) {\n\t\treg_capa.allow_40mhz = true;\n\t\treg_capa.allow_80mhz = flags & REG_CAPA_V4_80MHZ_ALLOWED;\n\t\treg_capa.allow_160mhz = flags & REG_CAPA_V4_160MHZ_ALLOWED;\n\t\treg_capa.allow_320mhz = flags & REG_CAPA_V4_320MHZ_ALLOWED;\n\t\treg_capa.disable_11ax = flags & REG_CAPA_V4_11AX_DISABLED;\n\t\treg_capa.disable_11be = flags & REG_CAPA_V4_11BE_DISABLED;\n\t} else if (resp_ver >= REG_CAPA_V2_RESP_VER) {\n\t\treg_capa.allow_40mhz = flags & REG_CAPA_V2_40MHZ_ALLOWED;\n\t\treg_capa.allow_80mhz = flags & REG_CAPA_V2_80MHZ_ALLOWED;\n\t\treg_capa.allow_160mhz = flags & REG_CAPA_V2_160MHZ_ALLOWED;\n\t\treg_capa.disable_11ax = flags & REG_CAPA_V2_11AX_DISABLED;\n\t} else {\n\t\treg_capa.allow_40mhz = !(flags & REG_CAPA_V1_40MHZ_FORBIDDEN);\n\t\treg_capa.allow_80mhz = flags & REG_CAPA_V1_80MHZ_ALLOWED;\n\t\treg_capa.allow_160mhz = flags & REG_CAPA_V1_160MHZ_ALLOWED;\n\t\treg_capa.disable_11ax = flags & REG_CAPA_V1_11AX_DISABLED;\n\t}\n\treturn reg_capa;\n}\n\nstruct ieee80211_regdomain *\niwl_parse_nvm_mcc_info(struct device *dev, const struct iwl_cfg *cfg,\n\t\t       int num_of_ch, __le32 *channels, u16 fw_mcc,\n\t\t       u16 geo_info, u32 cap, u8 resp_ver)\n{\n\tint ch_idx;\n\tu16 ch_flags;\n\tu32 reg_rule_flags, prev_reg_rule_flags = 0;\n\tconst u16 *nvm_chan;\n\tstruct ieee80211_regdomain *regd, *copy_rd;\n\tstruct ieee80211_reg_rule *rule;\n\tenum nl80211_band band;\n\tint center_freq, prev_center_freq = 0;\n\tint valid_rules = 0;\n\tbool new_rule;\n\tint max_num_ch;\n\tstruct iwl_reg_capa reg_capa;\n\n\tif (cfg->uhb_supported) {\n\t\tmax_num_ch = IWL_NVM_NUM_CHANNELS_UHB;\n\t\tnvm_chan = iwl_uhb_nvm_channels;\n\t} else if (cfg->nvm_type == IWL_NVM_EXT) {\n\t\tmax_num_ch = IWL_NVM_NUM_CHANNELS_EXT;\n\t\tnvm_chan = iwl_ext_nvm_channels;\n\t} else {\n\t\tmax_num_ch = IWL_NVM_NUM_CHANNELS;\n\t\tnvm_chan = iwl_nvm_channels;\n\t}\n\n\tif (num_of_ch > max_num_ch) {\n\t\tIWL_DEBUG_DEV(dev, IWL_DL_LAR,\n\t\t\t      \"Num of channels (%d) is greater than expected. Truncating to %d\\n\",\n\t\t\t      num_of_ch, max_num_ch);\n\t\tnum_of_ch = max_num_ch;\n\t}\n\n\tif (WARN_ON_ONCE(num_of_ch > NL80211_MAX_SUPP_REG_RULES))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tIWL_DEBUG_DEV(dev, IWL_DL_LAR, \"building regdom for %d channels\\n\",\n\t\t      num_of_ch);\n\n\t \n\tregd = kzalloc(struct_size(regd, reg_rules, num_of_ch), GFP_KERNEL);\n\tif (!regd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tregd->alpha2[0] = fw_mcc >> 8;\n\tregd->alpha2[1] = fw_mcc & 0xff;\n\n\t \n\treg_capa = iwl_get_reg_capa(cap, resp_ver);\n\n\tfor (ch_idx = 0; ch_idx < num_of_ch; ch_idx++) {\n\t\tch_flags = (u16)__le32_to_cpup(channels + ch_idx);\n\t\tband = iwl_nl80211_band_from_channel_idx(ch_idx);\n\t\tcenter_freq = ieee80211_channel_to_frequency(nvm_chan[ch_idx],\n\t\t\t\t\t\t\t     band);\n\t\tnew_rule = false;\n\n\t\tif (!(ch_flags & NVM_CHANNEL_VALID)) {\n\t\t\tiwl_nvm_print_channel_flags(dev, IWL_DL_LAR,\n\t\t\t\t\t\t    nvm_chan[ch_idx], ch_flags);\n\t\t\tcontinue;\n\t\t}\n\n\t\treg_rule_flags = iwl_nvm_get_regdom_bw_flags(nvm_chan, ch_idx,\n\t\t\t\t\t\t\t     ch_flags, reg_capa,\n\t\t\t\t\t\t\t     cfg);\n\n\t\t \n\t\tif (ch_idx == 0 || prev_reg_rule_flags != reg_rule_flags ||\n\t\t    center_freq - prev_center_freq > 20) {\n\t\t\tvalid_rules++;\n\t\t\tnew_rule = true;\n\t\t}\n\n\t\trule = &regd->reg_rules[valid_rules - 1];\n\n\t\tif (new_rule)\n\t\t\trule->freq_range.start_freq_khz =\n\t\t\t\t\t\tMHZ_TO_KHZ(center_freq - 10);\n\n\t\trule->freq_range.end_freq_khz = MHZ_TO_KHZ(center_freq + 10);\n\n\t\t \n\t\trule->power_rule.max_antenna_gain = DBI_TO_MBI(6);\n\t\trule->power_rule.max_eirp =\n\t\t\tDBM_TO_MBM(IWL_DEFAULT_MAX_TX_POWER);\n\n\t\trule->flags = reg_rule_flags;\n\n\t\t \n\t\trule->flags |= NL80211_RRF_AUTO_BW;\n\t\trule->freq_range.max_bandwidth_khz = 0;\n\n\t\tprev_center_freq = center_freq;\n\t\tprev_reg_rule_flags = reg_rule_flags;\n\n\t\tiwl_nvm_print_channel_flags(dev, IWL_DL_LAR,\n\t\t\t\t\t    nvm_chan[ch_idx], ch_flags);\n\n\t\tif (!(geo_info & GEO_WMM_ETSI_5GHZ_INFO) ||\n\t\t    band == NL80211_BAND_2GHZ)\n\t\t\tcontinue;\n\n\t\treg_query_regdb_wmm(regd->alpha2, center_freq, rule);\n\t}\n\n\t \n\tif (!valid_rules) {\n\t\tvalid_rules = 1;\n\t\trule = &regd->reg_rules[valid_rules - 1];\n\t\trule->freq_range.start_freq_khz = MHZ_TO_KHZ(2412);\n\t\trule->freq_range.end_freq_khz = MHZ_TO_KHZ(2413);\n\t\trule->freq_range.max_bandwidth_khz = MHZ_TO_KHZ(1);\n\t\trule->power_rule.max_antenna_gain = DBI_TO_MBI(6);\n\t\trule->power_rule.max_eirp =\n\t\t\tDBM_TO_MBM(IWL_DEFAULT_MAX_TX_POWER);\n\t}\n\n\tregd->n_reg_rules = valid_rules;\n\n\t \n\tcopy_rd = kmemdup(regd, struct_size(regd, reg_rules, valid_rules),\n\t\t\t  GFP_KERNEL);\n\tif (!copy_rd)\n\t\tcopy_rd = ERR_PTR(-ENOMEM);\n\n\tkfree(regd);\n\treturn copy_rd;\n}\nIWL_EXPORT_SYMBOL(iwl_parse_nvm_mcc_info);\n\n#define IWL_MAX_NVM_SECTION_SIZE\t0x1b58\n#define IWL_MAX_EXT_NVM_SECTION_SIZE\t0x1ffc\n#define MAX_NVM_FILE_LEN\t16384\n\nvoid iwl_nvm_fixups(u32 hw_id, unsigned int section, u8 *data,\n\t\t    unsigned int len)\n{\n#define IWL_4165_DEVICE_ID\t0x5501\n#define NVM_SKU_CAP_MIMO_DISABLE BIT(5)\n\n\tif (section == NVM_SECTION_TYPE_PHY_SKU &&\n\t    hw_id == IWL_4165_DEVICE_ID && data && len >= 5 &&\n\t    (data[4] & NVM_SKU_CAP_MIMO_DISABLE))\n\t\t \n\t\tdata[3] = ANT_B | (ANT_B << 4);\n}\nIWL_EXPORT_SYMBOL(iwl_nvm_fixups);\n\n \nint iwl_read_external_nvm(struct iwl_trans *trans,\n\t\t\t  const char *nvm_file_name,\n\t\t\t  struct iwl_nvm_section *nvm_sections)\n{\n\tint ret, section_size;\n\tu16 section_id;\n\tconst struct firmware *fw_entry;\n\tconst struct {\n\t\t__le16 word1;\n\t\t__le16 word2;\n\t\tu8 data[];\n\t} *file_sec;\n\tconst u8 *eof;\n\tu8 *temp;\n\tint max_section_size;\n\tconst __le32 *dword_buff;\n\n#define NVM_WORD1_LEN(x) (8 * (x & 0x03FF))\n#define NVM_WORD2_ID(x) (x >> 12)\n#define EXT_NVM_WORD2_LEN(x) (2 * (((x) & 0xFF) << 8 | (x) >> 8))\n#define EXT_NVM_WORD1_ID(x) ((x) >> 4)\n#define NVM_HEADER_0\t(0x2A504C54)\n#define NVM_HEADER_1\t(0x4E564D2A)\n#define NVM_HEADER_SIZE\t(4 * sizeof(u32))\n\n\tIWL_DEBUG_EEPROM(trans->dev, \"Read from external NVM\\n\");\n\n\t \n\tif (trans->cfg->nvm_type != IWL_NVM_EXT)\n\t\tmax_section_size = IWL_MAX_NVM_SECTION_SIZE;\n\telse\n\t\tmax_section_size = IWL_MAX_EXT_NVM_SECTION_SIZE;\n\n\t \n\tret = request_firmware(&fw_entry, nvm_file_name, trans->dev);\n\tif (ret) {\n\t\tIWL_ERR(trans, \"ERROR: %s isn't available %d\\n\",\n\t\t\tnvm_file_name, ret);\n\t\treturn ret;\n\t}\n\n\tIWL_INFO(trans, \"Loaded NVM file %s (%zu bytes)\\n\",\n\t\t nvm_file_name, fw_entry->size);\n\n\tif (fw_entry->size > MAX_NVM_FILE_LEN) {\n\t\tIWL_ERR(trans, \"NVM file too large\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\teof = fw_entry->data + fw_entry->size;\n\tdword_buff = (const __le32 *)fw_entry->data;\n\n\t \n\tif (fw_entry->size > NVM_HEADER_SIZE &&\n\t    dword_buff[0] == cpu_to_le32(NVM_HEADER_0) &&\n\t    dword_buff[1] == cpu_to_le32(NVM_HEADER_1)) {\n\t\tfile_sec = (const void *)(fw_entry->data + NVM_HEADER_SIZE);\n\t\tIWL_INFO(trans, \"NVM Version %08X\\n\", le32_to_cpu(dword_buff[2]));\n\t\tIWL_INFO(trans, \"NVM Manufacturing date %08X\\n\",\n\t\t\t le32_to_cpu(dword_buff[3]));\n\n\t\t \n\t\tif (trans->trans_cfg->device_family == IWL_DEVICE_FAMILY_8000 &&\n\t\t    trans->hw_rev_step == SILICON_C_STEP &&\n\t\t    le32_to_cpu(dword_buff[2]) < 0xE4A) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tfile_sec = (const void *)fw_entry->data;\n\t}\n\n\twhile (true) {\n\t\tif (file_sec->data > eof) {\n\t\t\tIWL_ERR(trans,\n\t\t\t\t\"ERROR - NVM file too short for section header\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!file_sec->word1 && !file_sec->word2) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (trans->cfg->nvm_type != IWL_NVM_EXT) {\n\t\t\tsection_size =\n\t\t\t\t2 * NVM_WORD1_LEN(le16_to_cpu(file_sec->word1));\n\t\t\tsection_id = NVM_WORD2_ID(le16_to_cpu(file_sec->word2));\n\t\t} else {\n\t\t\tsection_size = 2 * EXT_NVM_WORD2_LEN(\n\t\t\t\t\t\tle16_to_cpu(file_sec->word2));\n\t\t\tsection_id = EXT_NVM_WORD1_ID(\n\t\t\t\t\t\tle16_to_cpu(file_sec->word1));\n\t\t}\n\n\t\tif (section_size > max_section_size) {\n\t\t\tIWL_ERR(trans, \"ERROR - section too large (%d)\\n\",\n\t\t\t\tsection_size);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!section_size) {\n\t\t\tIWL_ERR(trans, \"ERROR - section empty\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (file_sec->data + section_size > eof) {\n\t\t\tIWL_ERR(trans,\n\t\t\t\t\"ERROR - NVM file too short for section (%d bytes)\\n\",\n\t\t\t\tsection_size);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (WARN(section_id >= NVM_MAX_NUM_SECTIONS,\n\t\t\t \"Invalid NVM section ID %d\\n\", section_id)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\ttemp = kmemdup(file_sec->data, section_size, GFP_KERNEL);\n\t\tif (!temp) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tiwl_nvm_fixups(trans->hw_id, section_id, temp, section_size);\n\n\t\tkfree(nvm_sections[section_id].data);\n\t\tnvm_sections[section_id].data = temp;\n\t\tnvm_sections[section_id].length = section_size;\n\n\t\t \n\t\tfile_sec = (const void *)(file_sec->data + section_size);\n\t}\nout:\n\trelease_firmware(fw_entry);\n\treturn ret;\n}\nIWL_EXPORT_SYMBOL(iwl_read_external_nvm);\n\nstruct iwl_nvm_data *iwl_get_nvm(struct iwl_trans *trans,\n\t\t\t\t const struct iwl_fw *fw)\n{\n\tstruct iwl_nvm_get_info cmd = {};\n\tstruct iwl_nvm_data *nvm;\n\tstruct iwl_host_cmd hcmd = {\n\t\t.flags = CMD_WANT_SKB | CMD_SEND_IN_RFKILL,\n\t\t.data = { &cmd, },\n\t\t.len = { sizeof(cmd) },\n\t\t.id = WIDE_ID(REGULATORY_AND_NVM_GROUP, NVM_GET_INFO)\n\t};\n\tint  ret;\n\tbool empty_otp;\n\tu32 mac_flags;\n\tu32 sbands_flags = 0;\n\t \n\tstruct iwl_nvm_get_info_rsp *rsp;\n\tstruct iwl_nvm_get_info_rsp_v3 *rsp_v3;\n\tbool v4 = fw_has_api(&fw->ucode_capa,\n\t\t\t     IWL_UCODE_TLV_API_REGULATORY_NVM_INFO);\n\tsize_t rsp_size = v4 ? sizeof(*rsp) : sizeof(*rsp_v3);\n\tvoid *channel_profile;\n\n\tret = iwl_trans_send_cmd(trans, &hcmd);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (WARN(iwl_rx_packet_payload_len(hcmd.resp_pkt) != rsp_size,\n\t\t \"Invalid payload len in NVM response from FW %d\",\n\t\t iwl_rx_packet_payload_len(hcmd.resp_pkt))) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trsp = (void *)hcmd.resp_pkt->data;\n\tempty_otp = !!(le32_to_cpu(rsp->general.flags) &\n\t\t       NVM_GENERAL_FLAGS_EMPTY_OTP);\n\tif (empty_otp)\n\t\tIWL_INFO(trans, \"OTP is empty\\n\");\n\n\tnvm = kzalloc(struct_size(nvm, channels, IWL_NUM_CHANNELS), GFP_KERNEL);\n\tif (!nvm) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tiwl_set_hw_address_from_csr(trans, nvm);\n\t \n\n\tif (!is_valid_ether_addr(nvm->hw_addr)) {\n\t\tIWL_ERR(trans, \"no valid mac address was found\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_free;\n\t}\n\n\tIWL_INFO(trans, \"base HW address: %pM\\n\", nvm->hw_addr);\n\n\t \n\tnvm->nvm_version = le16_to_cpu(rsp->general.nvm_version);\n\tnvm->n_hw_addrs = rsp->general.n_hw_addrs;\n\tif (nvm->n_hw_addrs == 0)\n\t\tIWL_WARN(trans,\n\t\t\t \"Firmware declares no reserved mac addresses. OTP is empty: %d\\n\",\n\t\t\t empty_otp);\n\n\t \n\tmac_flags = le32_to_cpu(rsp->mac_sku.mac_sku_flags);\n\tnvm->sku_cap_11ac_enable =\n\t\t!!(mac_flags & NVM_MAC_SKU_FLAGS_802_11AC_ENABLED);\n\tnvm->sku_cap_11n_enable =\n\t\t!!(mac_flags & NVM_MAC_SKU_FLAGS_802_11N_ENABLED);\n\tnvm->sku_cap_11ax_enable =\n\t\t!!(mac_flags & NVM_MAC_SKU_FLAGS_802_11AX_ENABLED);\n\tnvm->sku_cap_band_24ghz_enable =\n\t\t!!(mac_flags & NVM_MAC_SKU_FLAGS_BAND_2_4_ENABLED);\n\tnvm->sku_cap_band_52ghz_enable =\n\t\t!!(mac_flags & NVM_MAC_SKU_FLAGS_BAND_5_2_ENABLED);\n\tnvm->sku_cap_mimo_disabled =\n\t\t!!(mac_flags & NVM_MAC_SKU_FLAGS_MIMO_DISABLED);\n\tif (CSR_HW_RFID_TYPE(trans->hw_rf_id) == IWL_CFG_RF_TYPE_FM)\n\t\tnvm->sku_cap_11be_enable = true;\n\n\t \n\tnvm->valid_tx_ant = (u8)le32_to_cpu(rsp->phy_sku.tx_chains);\n\tnvm->valid_rx_ant = (u8)le32_to_cpu(rsp->phy_sku.rx_chains);\n\n\tif (le32_to_cpu(rsp->regulatory.lar_enabled) &&\n\t    fw_has_capa(&fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_LAR_SUPPORT)) {\n\t\tnvm->lar_enabled = true;\n\t\tsbands_flags |= IWL_NVM_SBANDS_FLAGS_LAR;\n\t}\n\n\trsp_v3 = (void *)rsp;\n\tchannel_profile = v4 ? (void *)rsp->regulatory.channel_profile :\n\t\t\t  (void *)rsp_v3->regulatory.channel_profile;\n\n\tiwl_init_sbands(trans, nvm,\n\t\t\tchannel_profile,\n\t\t\tnvm->valid_tx_ant & fw->valid_tx_ant,\n\t\t\tnvm->valid_rx_ant & fw->valid_rx_ant,\n\t\t\tsbands_flags, v4, fw);\n\n\tiwl_free_resp(&hcmd);\n\treturn nvm;\n\nerr_free:\n\tkfree(nvm);\nout:\n\tiwl_free_resp(&hcmd);\n\treturn ERR_PTR(ret);\n}\nIWL_EXPORT_SYMBOL(iwl_get_nvm);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}