{
  "module_name": "acpi.c",
  "hash_id": "e6b8b6b31d92078e736ce9458a91246f95e5038cd1b60cf31174674fbc793fbb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/fw/acpi.c",
  "human_readable_source": "\n \n#include <linux/uuid.h>\n#include <linux/dmi.h>\n#include \"iwl-drv.h\"\n#include \"iwl-debug.h\"\n#include \"acpi.h\"\n#include \"fw/runtime.h\"\n\nconst guid_t iwl_guid = GUID_INIT(0xF21202BF, 0x8F78, 0x4DC6,\n\t\t\t\t  0xA5, 0xB3, 0x1F, 0x73,\n\t\t\t\t  0x8E, 0x28, 0x5A, 0xDE);\nIWL_EXPORT_SYMBOL(iwl_guid);\n\nconst guid_t iwl_rfi_guid = GUID_INIT(0x7266172C, 0x220B, 0x4B29,\n\t\t\t\t      0x81, 0x4F, 0x75, 0xE4,\n\t\t\t\t      0xDD, 0x26, 0xB5, 0xFD);\nIWL_EXPORT_SYMBOL(iwl_rfi_guid);\n\nstatic const struct dmi_system_id dmi_ppag_approved_list[] = {\n\t{ .ident = \"HP\",\n\t  .matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"HP\"),\n\t\t},\n\t},\n\t{ .ident = \"SAMSUNG\",\n\t  .matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"SAMSUNG ELECTRONICS CO., LTD\"),\n\t\t},\n\t},\n\t{ .ident = \"MSFT\",\n\t  .matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Microsoft Corporation\"),\n\t\t},\n\t},\n\t{ .ident = \"ASUS\",\n\t  .matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK COMPUTER INC.\"),\n\t\t},\n\t},\n\t{ .ident = \"GOOGLE-HP\",\n\t  .matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Google\"),\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"HP\"),\n\t\t},\n\t},\n\t{ .ident = \"GOOGLE-ASUS\",\n\t  .matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Google\"),\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"ASUSTek COMPUTER INC.\"),\n\t\t},\n\t},\n\t{ .ident = \"GOOGLE-SAMSUNG\",\n\t  .matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Google\"),\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"SAMSUNG ELECTRONICS CO., LTD\"),\n\t\t},\n\t},\n\t{ .ident = \"DELL\",\n\t  .matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t},\n\t},\n\t{ .ident = \"DELL\",\n\t  .matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Alienware\"),\n\t\t},\n\t},\n\t{ .ident = \"RAZER\",\n\t  .matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Razer\"),\n\t\t},\n\t},\n\t{}\n};\n\nstatic int iwl_acpi_get_handle(struct device *dev, acpi_string method,\n\t\t\t       acpi_handle *ret_handle)\n{\n\tacpi_handle root_handle;\n\tacpi_status status;\n\n\troot_handle = ACPI_HANDLE(dev);\n\tif (!root_handle) {\n\t\tIWL_DEBUG_DEV_RADIO(dev,\n\t\t\t\t    \"ACPI: Could not retrieve root port handle\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tstatus = acpi_get_handle(root_handle, method, ret_handle);\n\tif (ACPI_FAILURE(status)) {\n\t\tIWL_DEBUG_DEV_RADIO(dev,\n\t\t\t\t    \"ACPI: %s method not found\\n\", method);\n\t\treturn -ENOENT;\n\t}\n\treturn 0;\n}\n\nstatic void *iwl_acpi_get_object(struct device *dev, acpi_string method)\n{\n\tstruct acpi_buffer buf = {ACPI_ALLOCATE_BUFFER, NULL};\n\tacpi_handle handle;\n\tacpi_status status;\n\tint ret;\n\n\tret = iwl_acpi_get_handle(dev, method, &handle);\n\tif (ret)\n\t\treturn ERR_PTR(-ENOENT);\n\n\t \n\tstatus = acpi_evaluate_object(handle, NULL, NULL, &buf);\n\tif (ACPI_FAILURE(status)) {\n\t\tIWL_DEBUG_DEV_RADIO(dev,\n\t\t\t\t    \"ACPI: %s method invocation failed (status: 0x%x)\\n\",\n\t\t\t\t    method, status);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\treturn buf.pointer;\n}\n\n \nstatic void *iwl_acpi_get_dsm_object(struct device *dev, int rev, int func,\n\t\t\t\t     union acpi_object *args,\n\t\t\t\t     const guid_t *guid)\n{\n\tunion acpi_object *obj;\n\n\tobj = acpi_evaluate_dsm(ACPI_HANDLE(dev), guid, rev, func,\n\t\t\t\targs);\n\tif (!obj) {\n\t\tIWL_DEBUG_DEV_RADIO(dev,\n\t\t\t\t    \"ACPI: DSM method invocation failed (rev: %d, func:%d)\\n\",\n\t\t\t\t    rev, func);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\treturn obj;\n}\n\n \nstatic int iwl_acpi_get_dsm_integer(struct device *dev, int rev, int func,\n\t\t\t\t    const guid_t *guid, u64 *value,\n\t\t\t\t    size_t expected_size)\n{\n\tunion acpi_object *obj;\n\tint ret = 0;\n\n\tobj = iwl_acpi_get_dsm_object(dev, rev, func, NULL, guid);\n\tif (IS_ERR(obj)) {\n\t\tIWL_DEBUG_DEV_RADIO(dev,\n\t\t\t\t    \"Failed to get  DSM object. func= %d\\n\",\n\t\t\t\t    func);\n\t\treturn -ENOENT;\n\t}\n\n\tif (obj->type == ACPI_TYPE_INTEGER) {\n\t\t*value = obj->integer.value;\n\t} else if (obj->type == ACPI_TYPE_BUFFER) {\n\t\t__le64 le_value = 0;\n\n\t\tif (WARN_ON_ONCE(expected_size > sizeof(le_value)))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (obj->buffer.length != expected_size)\n\t\t\tIWL_DEBUG_DEV_RADIO(dev,\n\t\t\t\t\t    \"ACPI: DSM invalid buffer size, padding or truncating (%d)\\n\",\n\t\t\t\t\t    obj->buffer.length);\n\n\t\t  \n\t\tmemcpy(&le_value, obj->buffer.pointer,\n\t\t       min_t(size_t, expected_size, (size_t)obj->buffer.length));\n\t\t*value = le64_to_cpu(le_value);\n\t} else {\n\t\tIWL_DEBUG_DEV_RADIO(dev,\n\t\t\t\t    \"ACPI: DSM method did not return a valid object, type=%d\\n\",\n\t\t\t\t    obj->type);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tIWL_DEBUG_DEV_RADIO(dev,\n\t\t\t    \"ACPI: DSM method evaluated: func=%d, ret=%d\\n\",\n\t\t\t    func, ret);\nout:\n\tACPI_FREE(obj);\n\treturn ret;\n}\n\n \nint iwl_acpi_get_dsm_u8(struct device *dev, int rev, int func,\n\t\t\tconst guid_t *guid, u8 *value)\n{\n\tint ret;\n\tu64 val;\n\n\tret = iwl_acpi_get_dsm_integer(dev, rev, func,\n\t\t\t\t       guid, &val, sizeof(u8));\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\t*value = (u8)val;\n\treturn 0;\n}\nIWL_EXPORT_SYMBOL(iwl_acpi_get_dsm_u8);\n\n \nint iwl_acpi_get_dsm_u32(struct device *dev, int rev, int func,\n\t\t\t const guid_t *guid, u32 *value)\n{\n\tint ret;\n\tu64 val;\n\n\tret = iwl_acpi_get_dsm_integer(dev, rev, func,\n\t\t\t\t       guid, &val, sizeof(u32));\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\t*value = (u32)val;\n\treturn 0;\n}\nIWL_EXPORT_SYMBOL(iwl_acpi_get_dsm_u32);\n\nstatic union acpi_object *\niwl_acpi_get_wifi_pkg_range(struct device *dev,\n\t\t\t    union acpi_object *data,\n\t\t\t    int min_data_size,\n\t\t\t    int max_data_size,\n\t\t\t    int *tbl_rev)\n{\n\tint i;\n\tunion acpi_object *wifi_pkg;\n\n\t \n\tif (WARN_ON_ONCE(min_data_size < 2 || min_data_size > max_data_size))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tif (data->type != ACPI_TYPE_PACKAGE ||\n\t    data->package.count < 2 ||\n\t    data->package.elements[0].type != ACPI_TYPE_INTEGER) {\n\t\tIWL_DEBUG_DEV_RADIO(dev, \"Invalid packages structure\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t*tbl_rev = data->package.elements[0].integer.value;\n\n\t \n\tfor (i = 1; i < data->package.count; i++) {\n\t\tunion acpi_object *domain;\n\n\t\twifi_pkg = &data->package.elements[i];\n\n\t\t \n\t\tif (wifi_pkg->type != ACPI_TYPE_PACKAGE ||\n\t\t    wifi_pkg->package.count < min_data_size ||\n\t\t    wifi_pkg->package.count > max_data_size)\n\t\t\tcontinue;\n\n\t\tdomain = &wifi_pkg->package.elements[0];\n\t\tif (domain->type == ACPI_TYPE_INTEGER &&\n\t\t    domain->integer.value == ACPI_WIFI_DOMAIN)\n\t\t\tgoto found;\n\t}\n\n\treturn ERR_PTR(-ENOENT);\n\nfound:\n\treturn wifi_pkg;\n}\n\nstatic union acpi_object *\niwl_acpi_get_wifi_pkg(struct device *dev,\n\t\t      union acpi_object *data,\n\t\t      int data_size, int *tbl_rev)\n{\n\treturn iwl_acpi_get_wifi_pkg_range(dev, data, data_size, data_size,\n\t\t\t\t\t   tbl_rev);\n}\n\n\nint iwl_acpi_get_tas(struct iwl_fw_runtime *fwrt,\n\t\t     union iwl_tas_config_cmd *cmd, int fw_ver)\n{\n\tunion acpi_object *wifi_pkg, *data;\n\tint ret, tbl_rev, i, block_list_size, enabled;\n\n\tdata = iwl_acpi_get_object(fwrt->dev, ACPI_WTAS_METHOD);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t \n\twifi_pkg = iwl_acpi_get_wifi_pkg(fwrt->dev, data,\n\t\t\t\t\t ACPI_WTAS_WIFI_DATA_SIZE,\n\t\t\t\t\t &tbl_rev);\n\tif (IS_ERR(wifi_pkg)) {\n\t\tret = PTR_ERR(wifi_pkg);\n\t\tgoto out_free;\n\t}\n\n\tif (tbl_rev == 1 && wifi_pkg->package.elements[1].type ==\n\t\tACPI_TYPE_INTEGER) {\n\t\tu32 tas_selection =\n\t\t\t(u32)wifi_pkg->package.elements[1].integer.value;\n\t\tu16 override_iec =\n\t\t\t(tas_selection & ACPI_WTAS_OVERRIDE_IEC_MSK) >> ACPI_WTAS_OVERRIDE_IEC_POS;\n\t\tu16 enabled_iec = (tas_selection & ACPI_WTAS_ENABLE_IEC_MSK) >>\n\t\t\tACPI_WTAS_ENABLE_IEC_POS;\n\t\tu8 usa_tas_uhb = (tas_selection & ACPI_WTAS_USA_UHB_MSK) >> ACPI_WTAS_USA_UHB_POS;\n\n\n\t\tenabled = tas_selection & ACPI_WTAS_ENABLED_MSK;\n\t\tif (fw_ver <= 3) {\n\t\t\tcmd->v3.override_tas_iec = cpu_to_le16(override_iec);\n\t\t\tcmd->v3.enable_tas_iec = cpu_to_le16(enabled_iec);\n\t\t} else {\n\t\t\tcmd->v4.usa_tas_uhb_allowed = usa_tas_uhb;\n\t\t\tcmd->v4.override_tas_iec = (u8)override_iec;\n\t\t\tcmd->v4.enable_tas_iec = (u8)enabled_iec;\n\t\t}\n\n\t} else if (tbl_rev == 0 &&\n\t\twifi_pkg->package.elements[1].type == ACPI_TYPE_INTEGER) {\n\t\tenabled = !!wifi_pkg->package.elements[1].integer.value;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tif (!enabled) {\n\t\tIWL_DEBUG_RADIO(fwrt, \"TAS not enabled\\n\");\n\t\tret = 0;\n\t\tgoto out_free;\n\t}\n\n\tIWL_DEBUG_RADIO(fwrt, \"Reading TAS table revision %d\\n\", tbl_rev);\n\tif (wifi_pkg->package.elements[2].type != ACPI_TYPE_INTEGER ||\n\t    wifi_pkg->package.elements[2].integer.value >\n\t    APCI_WTAS_BLACK_LIST_MAX) {\n\t\tIWL_DEBUG_RADIO(fwrt, \"TAS invalid array size %llu\\n\",\n\t\t\t\twifi_pkg->package.elements[2].integer.value);\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tblock_list_size = wifi_pkg->package.elements[2].integer.value;\n\tcmd->v4.block_list_size = cpu_to_le32(block_list_size);\n\n\tIWL_DEBUG_RADIO(fwrt, \"TAS array size %u\\n\", block_list_size);\n\tif (block_list_size > APCI_WTAS_BLACK_LIST_MAX) {\n\t\tIWL_DEBUG_RADIO(fwrt, \"TAS invalid array size value %u\\n\",\n\t\t\t\tblock_list_size);\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tfor (i = 0; i < block_list_size; i++) {\n\t\tu32 country;\n\n\t\tif (wifi_pkg->package.elements[3 + i].type !=\n\t\t    ACPI_TYPE_INTEGER) {\n\t\t\tIWL_DEBUG_RADIO(fwrt,\n\t\t\t\t\t\"TAS invalid array elem %d\\n\", 3 + i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tcountry = wifi_pkg->package.elements[3 + i].integer.value;\n\t\tcmd->v4.block_list_array[i] = cpu_to_le32(country);\n\t\tIWL_DEBUG_RADIO(fwrt, \"TAS block list country %d\\n\", country);\n\t}\n\n\tret = 1;\nout_free:\n\tkfree(data);\n\treturn ret;\n}\nIWL_EXPORT_SYMBOL(iwl_acpi_get_tas);\n\nint iwl_acpi_get_mcc(struct device *dev, char *mcc)\n{\n\tunion acpi_object *wifi_pkg, *data;\n\tu32 mcc_val;\n\tint ret, tbl_rev;\n\n\tdata = iwl_acpi_get_object(dev, ACPI_WRDD_METHOD);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\twifi_pkg = iwl_acpi_get_wifi_pkg(dev, data, ACPI_WRDD_WIFI_DATA_SIZE,\n\t\t\t\t\t &tbl_rev);\n\tif (IS_ERR(wifi_pkg)) {\n\t\tret = PTR_ERR(wifi_pkg);\n\t\tgoto out_free;\n\t}\n\n\tif (wifi_pkg->package.elements[1].type != ACPI_TYPE_INTEGER ||\n\t    tbl_rev != 0) {\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tmcc_val = wifi_pkg->package.elements[1].integer.value;\n\n\tmcc[0] = (mcc_val >> 8) & 0xff;\n\tmcc[1] = mcc_val & 0xff;\n\tmcc[2] = '\\0';\n\n\tret = 0;\nout_free:\n\tkfree(data);\n\treturn ret;\n}\nIWL_EXPORT_SYMBOL(iwl_acpi_get_mcc);\n\nu64 iwl_acpi_get_pwr_limit(struct device *dev)\n{\n\tunion acpi_object *data, *wifi_pkg;\n\tu64 dflt_pwr_limit;\n\tint tbl_rev;\n\n\tdata = iwl_acpi_get_object(dev, ACPI_SPLC_METHOD);\n\tif (IS_ERR(data)) {\n\t\tdflt_pwr_limit = 0;\n\t\tgoto out;\n\t}\n\n\twifi_pkg = iwl_acpi_get_wifi_pkg(dev, data,\n\t\t\t\t\t ACPI_SPLC_WIFI_DATA_SIZE, &tbl_rev);\n\tif (IS_ERR(wifi_pkg) || tbl_rev != 0 ||\n\t    wifi_pkg->package.elements[1].integer.value != ACPI_TYPE_INTEGER) {\n\t\tdflt_pwr_limit = 0;\n\t\tgoto out_free;\n\t}\n\n\tdflt_pwr_limit = wifi_pkg->package.elements[1].integer.value;\nout_free:\n\tkfree(data);\nout:\n\treturn dflt_pwr_limit;\n}\nIWL_EXPORT_SYMBOL(iwl_acpi_get_pwr_limit);\n\nint iwl_acpi_get_eckv(struct device *dev, u32 *extl_clk)\n{\n\tunion acpi_object *wifi_pkg, *data;\n\tint ret, tbl_rev;\n\n\tdata = iwl_acpi_get_object(dev, ACPI_ECKV_METHOD);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\twifi_pkg = iwl_acpi_get_wifi_pkg(dev, data, ACPI_ECKV_WIFI_DATA_SIZE,\n\t\t\t\t\t &tbl_rev);\n\tif (IS_ERR(wifi_pkg)) {\n\t\tret = PTR_ERR(wifi_pkg);\n\t\tgoto out_free;\n\t}\n\n\tif (wifi_pkg->package.elements[1].type != ACPI_TYPE_INTEGER ||\n\t    tbl_rev != 0) {\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\t*extl_clk = wifi_pkg->package.elements[1].integer.value;\n\n\tret = 0;\n\nout_free:\n\tkfree(data);\n\treturn ret;\n}\nIWL_EXPORT_SYMBOL(iwl_acpi_get_eckv);\n\nstatic int iwl_sar_set_profile(union acpi_object *table,\n\t\t\t       struct iwl_sar_profile *profile,\n\t\t\t       bool enabled, u8 num_chains, u8 num_sub_bands)\n{\n\tint i, j, idx = 0;\n\n\t \n\tfor (i = 0; i < ACPI_SAR_NUM_CHAINS_REV2; i++) {\n\t\tfor (j = 0; j < ACPI_SAR_NUM_SUB_BANDS_REV2; j++) {\n\t\t\t \n\t\t\tif (i >= num_chains || j >= num_sub_bands) {\n\t\t\t\tprofile->chains[i].subbands[j] = 0;\n\t\t\t} else {\n\t\t\t\tif (table[idx].type != ACPI_TYPE_INTEGER ||\n\t\t\t\t    table[idx].integer.value > U8_MAX)\n\t\t\t\t\treturn -EINVAL;\n\n\t\t\t\tprofile->chains[i].subbands[j] =\n\t\t\t\t\ttable[idx].integer.value;\n\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tprofile->enabled = enabled;\n\n\treturn 0;\n}\n\nstatic int iwl_sar_fill_table(struct iwl_fw_runtime *fwrt,\n\t\t\t      __le16 *per_chain, u32 n_subbands,\n\t\t\t      int prof_a, int prof_b)\n{\n\tint profs[ACPI_SAR_NUM_CHAINS_REV0] = { prof_a, prof_b };\n\tint i, j;\n\n\tfor (i = 0; i < ACPI_SAR_NUM_CHAINS_REV0; i++) {\n\t\tstruct iwl_sar_profile *prof;\n\n\t\t \n\t\tif (profs[i] == 0)\n\t\t\treturn -EPERM;\n\n\t\t \n\t\tif (profs[i] > ACPI_SAR_PROFILE_NUM)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tprof = &fwrt->sar_profiles[profs[i] - 1];\n\n\t\t \n\t\tif (!prof->enabled) {\n\t\t\tIWL_DEBUG_RADIO(fwrt, \"SAR profile %d is disabled.\\n\",\n\t\t\t\t\tprofs[i]);\n\t\t\t \n\t\t\treturn 1;\n\t\t}\n\n\t\tIWL_DEBUG_INFO(fwrt,\n\t\t\t       \"SAR EWRD: chain %d profile index %d\\n\",\n\t\t\t       i, profs[i]);\n\t\tIWL_DEBUG_RADIO(fwrt, \"  Chain[%d]:\\n\", i);\n\t\tfor (j = 0; j < n_subbands; j++) {\n\t\t\tper_chain[i * n_subbands + j] =\n\t\t\t\tcpu_to_le16(prof->chains[i].subbands[j]);\n\t\t\tIWL_DEBUG_RADIO(fwrt, \"    Band[%d] = %d * .125dBm\\n\",\n\t\t\t\t\tj, prof->chains[i].subbands[j]);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint iwl_sar_select_profile(struct iwl_fw_runtime *fwrt,\n\t\t\t   __le16 *per_chain, u32 n_tables, u32 n_subbands,\n\t\t\t   int prof_a, int prof_b)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; i < n_tables; i++) {\n\t\tret = iwl_sar_fill_table(fwrt,\n\t\t\t &per_chain[i * n_subbands * ACPI_SAR_NUM_CHAINS_REV0],\n\t\t\t n_subbands, prof_a, prof_b);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\nIWL_EXPORT_SYMBOL(iwl_sar_select_profile);\n\nint iwl_sar_get_wrds_table(struct iwl_fw_runtime *fwrt)\n{\n\tunion acpi_object *wifi_pkg, *table, *data;\n\tint ret, tbl_rev;\n\tu32 flags;\n\tu8 num_chains, num_sub_bands;\n\n\tdata = iwl_acpi_get_object(fwrt->dev, ACPI_WRDS_METHOD);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t \n\twifi_pkg = iwl_acpi_get_wifi_pkg(fwrt->dev, data,\n\t\t\t\t\t ACPI_WRDS_WIFI_DATA_SIZE_REV2,\n\t\t\t\t\t &tbl_rev);\n\tif (!IS_ERR(wifi_pkg)) {\n\t\tif (tbl_rev != 2) {\n\t\t\tret = PTR_ERR(wifi_pkg);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tnum_chains = ACPI_SAR_NUM_CHAINS_REV2;\n\t\tnum_sub_bands = ACPI_SAR_NUM_SUB_BANDS_REV2;\n\n\t\tgoto read_table;\n\t}\n\n\t \n\twifi_pkg = iwl_acpi_get_wifi_pkg(fwrt->dev, data,\n\t\t\t\t\t ACPI_WRDS_WIFI_DATA_SIZE_REV1,\n\t\t\t\t\t &tbl_rev);\n\tif (!IS_ERR(wifi_pkg)) {\n\t\tif (tbl_rev != 1) {\n\t\t\tret = PTR_ERR(wifi_pkg);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tnum_chains = ACPI_SAR_NUM_CHAINS_REV1;\n\t\tnum_sub_bands = ACPI_SAR_NUM_SUB_BANDS_REV1;\n\n\t\tgoto read_table;\n\t}\n\n\t \n\twifi_pkg = iwl_acpi_get_wifi_pkg(fwrt->dev, data,\n\t\t\t\t\t ACPI_WRDS_WIFI_DATA_SIZE_REV0,\n\t\t\t\t\t &tbl_rev);\n\tif (!IS_ERR(wifi_pkg)) {\n\t\tif (tbl_rev != 0) {\n\t\t\tret = PTR_ERR(wifi_pkg);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tnum_chains = ACPI_SAR_NUM_CHAINS_REV0;\n\t\tnum_sub_bands = ACPI_SAR_NUM_SUB_BANDS_REV0;\n\n\t\tgoto read_table;\n\t}\n\n\tret = PTR_ERR(wifi_pkg);\n\tgoto out_free;\n\nread_table:\n\tif (wifi_pkg->package.elements[1].type != ACPI_TYPE_INTEGER) {\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tIWL_DEBUG_RADIO(fwrt, \"Reading WRDS tbl_rev=%d\\n\", tbl_rev);\n\n\tflags = wifi_pkg->package.elements[1].integer.value;\n\tfwrt->reduced_power_flags = flags >> IWL_REDUCE_POWER_FLAGS_POS;\n\n\t \n\ttable = &wifi_pkg->package.elements[2];\n\n\t \n\tret = iwl_sar_set_profile(table, &fwrt->sar_profiles[0],\n\t\t\t\t  flags & IWL_SAR_ENABLE_MSK,\n\t\t\t\t  num_chains, num_sub_bands);\nout_free:\n\tkfree(data);\n\treturn ret;\n}\nIWL_EXPORT_SYMBOL(iwl_sar_get_wrds_table);\n\nint iwl_sar_get_ewrd_table(struct iwl_fw_runtime *fwrt)\n{\n\tunion acpi_object *wifi_pkg, *data;\n\tbool enabled;\n\tint i, n_profiles, tbl_rev, pos;\n\tint ret = 0;\n\tu8 num_chains, num_sub_bands;\n\n\tdata = iwl_acpi_get_object(fwrt->dev, ACPI_EWRD_METHOD);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t \n\twifi_pkg = iwl_acpi_get_wifi_pkg(fwrt->dev, data,\n\t\t\t\t\t ACPI_EWRD_WIFI_DATA_SIZE_REV2,\n\t\t\t\t\t &tbl_rev);\n\tif (!IS_ERR(wifi_pkg)) {\n\t\tif (tbl_rev != 2) {\n\t\t\tret = PTR_ERR(wifi_pkg);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tnum_chains = ACPI_SAR_NUM_CHAINS_REV2;\n\t\tnum_sub_bands = ACPI_SAR_NUM_SUB_BANDS_REV2;\n\n\t\tgoto read_table;\n\t}\n\n\t \n\twifi_pkg = iwl_acpi_get_wifi_pkg(fwrt->dev, data,\n\t\t\t\t\t ACPI_EWRD_WIFI_DATA_SIZE_REV1,\n\t\t\t\t\t &tbl_rev);\n\tif (!IS_ERR(wifi_pkg)) {\n\t\tif (tbl_rev != 1) {\n\t\t\tret = PTR_ERR(wifi_pkg);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tnum_chains = ACPI_SAR_NUM_CHAINS_REV1;\n\t\tnum_sub_bands = ACPI_SAR_NUM_SUB_BANDS_REV1;\n\n\t\tgoto read_table;\n\t}\n\n\t \n\twifi_pkg = iwl_acpi_get_wifi_pkg(fwrt->dev, data,\n\t\t\t\t\t ACPI_EWRD_WIFI_DATA_SIZE_REV0,\n\t\t\t\t\t &tbl_rev);\n\tif (!IS_ERR(wifi_pkg)) {\n\t\tif (tbl_rev != 0) {\n\t\t\tret = PTR_ERR(wifi_pkg);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tnum_chains = ACPI_SAR_NUM_CHAINS_REV0;\n\t\tnum_sub_bands = ACPI_SAR_NUM_SUB_BANDS_REV0;\n\n\t\tgoto read_table;\n\t}\n\n\tret = PTR_ERR(wifi_pkg);\n\tgoto out_free;\n\nread_table:\n\tif (wifi_pkg->package.elements[1].type != ACPI_TYPE_INTEGER ||\n\t    wifi_pkg->package.elements[2].type != ACPI_TYPE_INTEGER) {\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tenabled = !!(wifi_pkg->package.elements[1].integer.value);\n\tn_profiles = wifi_pkg->package.elements[2].integer.value;\n\n\t \n\tif (n_profiles <= 0 || n_profiles >= ACPI_SAR_PROFILE_NUM) {\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\t \n\tpos = 3;\n\n\tfor (i = 0; i < n_profiles; i++) {\n\t\t \n\t\tret = iwl_sar_set_profile(&wifi_pkg->package.elements[pos],\n\t\t\t\t\t  &fwrt->sar_profiles[i + 1], enabled,\n\t\t\t\t\t  num_chains, num_sub_bands);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tpos += num_chains * num_sub_bands;\n\t}\n\nout_free:\n\tkfree(data);\n\treturn ret;\n}\nIWL_EXPORT_SYMBOL(iwl_sar_get_ewrd_table);\n\nint iwl_sar_get_wgds_table(struct iwl_fw_runtime *fwrt)\n{\n\tunion acpi_object *wifi_pkg, *data;\n\tint i, j, k, ret, tbl_rev;\n\tu8 num_bands, num_profiles;\n\tstatic const struct {\n\t\tu8 revisions;\n\t\tu8 bands;\n\t\tu8 profiles;\n\t\tu8 min_profiles;\n\t} rev_data[] = {\n\t\t{\n\t\t\t.revisions = BIT(3),\n\t\t\t.bands = ACPI_GEO_NUM_BANDS_REV2,\n\t\t\t.profiles = ACPI_NUM_GEO_PROFILES_REV3,\n\t\t\t.min_profiles = 3,\n\t\t},\n\t\t{\n\t\t\t.revisions = BIT(2),\n\t\t\t.bands = ACPI_GEO_NUM_BANDS_REV2,\n\t\t\t.profiles = ACPI_NUM_GEO_PROFILES,\n\t\t},\n\t\t{\n\t\t\t.revisions = BIT(0) | BIT(1),\n\t\t\t.bands = ACPI_GEO_NUM_BANDS_REV0,\n\t\t\t.profiles = ACPI_NUM_GEO_PROFILES,\n\t\t},\n\t};\n\tint idx;\n\t \n\tint entry_idx = 1;\n\n\tBUILD_BUG_ON(ACPI_NUM_GEO_PROFILES_REV3 != IWL_NUM_GEO_PROFILES_V3);\n\tBUILD_BUG_ON(ACPI_NUM_GEO_PROFILES != IWL_NUM_GEO_PROFILES);\n\n\tdata = iwl_acpi_get_object(fwrt->dev, ACPI_WGDS_METHOD);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t \n\tfor (idx = 0; idx < ARRAY_SIZE(rev_data); idx++) {\n\t\t \n\t\tu32 hdr_size = 1 + !!rev_data[idx].min_profiles;\n\t\tu32 profile_size = ACPI_GEO_PER_CHAIN_SIZE *\n\t\t\t\t   rev_data[idx].bands;\n\t\tu32 max_size = hdr_size + profile_size * rev_data[idx].profiles;\n\t\tu32 min_size;\n\n\t\tif (!rev_data[idx].min_profiles)\n\t\t\tmin_size = max_size;\n\t\telse\n\t\t\tmin_size = hdr_size +\n\t\t\t\t   profile_size * rev_data[idx].min_profiles;\n\n\t\twifi_pkg = iwl_acpi_get_wifi_pkg_range(fwrt->dev, data,\n\t\t\t\t\t\t       min_size, max_size,\n\t\t\t\t\t\t       &tbl_rev);\n\t\tif (!IS_ERR(wifi_pkg)) {\n\t\t\tif (!(BIT(tbl_rev) & rev_data[idx].revisions))\n\t\t\t\tcontinue;\n\n\t\t\tnum_bands = rev_data[idx].bands;\n\t\t\tnum_profiles = rev_data[idx].profiles;\n\n\t\t\tif (rev_data[idx].min_profiles) {\n\t\t\t\t \n\t\t\t\tunion acpi_object *entry;\n\n\t\t\t\tentry = &wifi_pkg->package.elements[entry_idx];\n\t\t\t\tentry_idx++;\n\t\t\t\tif (entry->type != ACPI_TYPE_INTEGER ||\n\t\t\t\t    entry->integer.value > num_profiles) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out_free;\n\t\t\t\t}\n\t\t\t\tnum_profiles = entry->integer.value;\n\n\t\t\t\t \n\t\t\t\tif (wifi_pkg->package.count !=\n\t\t\t\t    hdr_size + profile_size * num_profiles) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out_free;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto read_table;\n\t\t}\n\t}\n\n\tif (idx < ARRAY_SIZE(rev_data))\n\t\tret = PTR_ERR(wifi_pkg);\n\telse\n\t\tret = -ENOENT;\n\tgoto out_free;\n\nread_table:\n\tfwrt->geo_rev = tbl_rev;\n\tfor (i = 0; i < num_profiles; i++) {\n\t\tfor (j = 0; j < ACPI_GEO_NUM_BANDS_REV2; j++) {\n\t\t\tunion acpi_object *entry;\n\n\t\t\t \n\t\t\tif (j >= num_bands) {\n\t\t\t\tfwrt->geo_profiles[i].bands[j].max =\n\t\t\t\t\tfwrt->geo_profiles[i].bands[1].max;\n\t\t\t} else {\n\t\t\t\tentry = &wifi_pkg->package.elements[entry_idx];\n\t\t\t\tentry_idx++;\n\t\t\t\tif (entry->type != ACPI_TYPE_INTEGER ||\n\t\t\t\t    entry->integer.value > U8_MAX) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out_free;\n\t\t\t\t}\n\n\t\t\t\tfwrt->geo_profiles[i].bands[j].max =\n\t\t\t\t\tentry->integer.value;\n\t\t\t}\n\n\t\t\tfor (k = 0; k < ACPI_GEO_NUM_CHAINS; k++) {\n\t\t\t\t \n\t\t\t\tif (j >= num_bands) {\n\t\t\t\t\tfwrt->geo_profiles[i].bands[j].chains[k] =\n\t\t\t\t\t\tfwrt->geo_profiles[i].bands[1].chains[k];\n\t\t\t\t} else {\n\t\t\t\t\tentry = &wifi_pkg->package.elements[entry_idx];\n\t\t\t\t\tentry_idx++;\n\t\t\t\t\tif (entry->type != ACPI_TYPE_INTEGER ||\n\t\t\t\t\t    entry->integer.value > U8_MAX) {\n\t\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\t\tgoto out_free;\n\t\t\t\t\t}\n\n\t\t\t\t\tfwrt->geo_profiles[i].bands[j].chains[k] =\n\t\t\t\t\t\tentry->integer.value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfwrt->geo_num_profiles = num_profiles;\n\tfwrt->geo_enabled = true;\n\tret = 0;\nout_free:\n\tkfree(data);\n\treturn ret;\n}\nIWL_EXPORT_SYMBOL(iwl_sar_get_wgds_table);\n\nbool iwl_sar_geo_support(struct iwl_fw_runtime *fwrt)\n{\n\t \n\treturn IWL_UCODE_SERIAL(fwrt->fw->ucode_ver) >= 38 ||\n\t\t(IWL_UCODE_SERIAL(fwrt->fw->ucode_ver) == 17 &&\n\t\t fwrt->trans->hw_rev != CSR_HW_REV_TYPE_3160) ||\n\t\t(IWL_UCODE_SERIAL(fwrt->fw->ucode_ver) == 29 &&\n\t\t ((fwrt->trans->hw_rev & CSR_HW_REV_TYPE_MSK) ==\n\t\t  CSR_HW_REV_TYPE_7265D));\n}\nIWL_EXPORT_SYMBOL(iwl_sar_geo_support);\n\nint iwl_sar_geo_init(struct iwl_fw_runtime *fwrt,\n\t\t     struct iwl_per_chain_offset *table,\n\t\t     u32 n_bands, u32 n_profiles)\n{\n\tint i, j;\n\n\tif (!fwrt->geo_enabled)\n\t\treturn -ENODATA;\n\n\tif (!iwl_sar_geo_support(fwrt))\n\t\treturn -EOPNOTSUPP;\n\n\tfor (i = 0; i < n_profiles; i++) {\n\t\tfor (j = 0; j < n_bands; j++) {\n\t\t\tstruct iwl_per_chain_offset *chain =\n\t\t\t\t&table[i * n_bands + j];\n\n\t\t\tchain->max_tx_power =\n\t\t\t\tcpu_to_le16(fwrt->geo_profiles[i].bands[j].max);\n\t\t\tchain->chain_a = fwrt->geo_profiles[i].bands[j].chains[0];\n\t\t\tchain->chain_b = fwrt->geo_profiles[i].bands[j].chains[1];\n\t\t\tIWL_DEBUG_RADIO(fwrt,\n\t\t\t\t\t\"SAR geographic profile[%d] Band[%d]: chain A = %d chain B = %d max_tx_power = %d\\n\",\n\t\t\t\t\ti, j,\n\t\t\t\t\tfwrt->geo_profiles[i].bands[j].chains[0],\n\t\t\t\t\tfwrt->geo_profiles[i].bands[j].chains[1],\n\t\t\t\t\tfwrt->geo_profiles[i].bands[j].max);\n\t\t}\n\t}\n\n\treturn 0;\n}\nIWL_EXPORT_SYMBOL(iwl_sar_geo_init);\n\n__le32 iwl_acpi_get_lari_config_bitmap(struct iwl_fw_runtime *fwrt)\n{\n\tint ret;\n\tu8 value;\n\t__le32 config_bitmap = 0;\n\n\t \n\tret = iwl_acpi_get_dsm_u8(fwrt->dev, 0,\n\t\t\t\t  DSM_FUNC_ENABLE_INDONESIA_5G2,\n\t\t\t\t  &iwl_guid, &value);\n\n\tif (!ret && value == DSM_VALUE_INDONESIA_ENABLE)\n\t\tconfig_bitmap |=\n\t\t\tcpu_to_le32(LARI_CONFIG_ENABLE_5G2_IN_INDONESIA_MSK);\n\n\t \n\tret = iwl_acpi_get_dsm_u8(fwrt->dev, 0,\n\t\t\t\t  DSM_FUNC_DISABLE_SRD,\n\t\t\t\t  &iwl_guid, &value);\n\tif (!ret) {\n\t\tif (value == DSM_VALUE_SRD_PASSIVE)\n\t\t\tconfig_bitmap |=\n\t\t\t\tcpu_to_le32(LARI_CONFIG_CHANGE_ETSI_TO_PASSIVE_MSK);\n\t\telse if (value == DSM_VALUE_SRD_DISABLE)\n\t\t\tconfig_bitmap |=\n\t\t\t\tcpu_to_le32(LARI_CONFIG_CHANGE_ETSI_TO_DISABLED_MSK);\n\t}\n\n\treturn config_bitmap;\n}\nIWL_EXPORT_SYMBOL(iwl_acpi_get_lari_config_bitmap);\n\nint iwl_acpi_get_ppag_table(struct iwl_fw_runtime *fwrt)\n{\n\tunion acpi_object *wifi_pkg, *data, *flags;\n\tint i, j, ret, tbl_rev, num_sub_bands = 0;\n\tint idx = 2;\n\tu8 cmd_ver;\n\n\tfwrt->ppag_flags = 0;\n\tfwrt->ppag_table_valid = false;\n\n\tdata = iwl_acpi_get_object(fwrt->dev, ACPI_PPAG_METHOD);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t \n\twifi_pkg = iwl_acpi_get_wifi_pkg(fwrt->dev, data,\n\t\t\t\tACPI_PPAG_WIFI_DATA_SIZE_V2, &tbl_rev);\n\n\tif (!IS_ERR(wifi_pkg)) {\n\t\tif (tbl_rev == 1 || tbl_rev == 2) {\n\t\t\tnum_sub_bands = IWL_NUM_SUB_BANDS_V2;\n\t\t\tIWL_DEBUG_RADIO(fwrt,\n\t\t\t\t\t\"Reading PPAG table v2 (tbl_rev=%d)\\n\",\n\t\t\t\t\ttbl_rev);\n\t\t\tgoto read_table;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\t \n\twifi_pkg = iwl_acpi_get_wifi_pkg(fwrt->dev, data,\n\t\t\tACPI_PPAG_WIFI_DATA_SIZE_V1, &tbl_rev);\n\n\tif (!IS_ERR(wifi_pkg)) {\n\t\tif (tbl_rev != 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tnum_sub_bands = IWL_NUM_SUB_BANDS_V1;\n\t\tIWL_DEBUG_RADIO(fwrt, \"Reading PPAG table v1 (tbl_rev=0)\\n\");\n\t\tgoto read_table;\n\t}\n\nread_table:\n\tfwrt->ppag_ver = tbl_rev;\n\tflags = &wifi_pkg->package.elements[1];\n\n\tif (flags->type != ACPI_TYPE_INTEGER) {\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tfwrt->ppag_flags = flags->integer.value & ACPI_PPAG_MASK;\n\tcmd_ver = iwl_fw_lookup_cmd_ver(fwrt->fw,\n\t\t\t\t\tWIDE_ID(PHY_OPS_GROUP,\n\t\t\t\t\t\tPER_PLATFORM_ANT_GAIN_CMD),\n\t\t\t\t\tIWL_FW_CMD_VER_UNKNOWN);\n\tif (cmd_ver == IWL_FW_CMD_VER_UNKNOWN) {\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tif (!fwrt->ppag_flags && cmd_ver <= 3) {\n\t\tret = 0;\n\t\tgoto out_free;\n\t}\n\n\t \n\tfor (i = 0; i < IWL_NUM_CHAIN_LIMITS; i++) {\n\t\tfor (j = 0; j < num_sub_bands; j++) {\n\t\t\tunion acpi_object *ent;\n\n\t\t\tent = &wifi_pkg->package.elements[idx++];\n\t\t\tif (ent->type != ACPI_TYPE_INTEGER) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tfwrt->ppag_chains[i].subbands[j] = ent->integer.value;\n\t\t\t \n\t\t\tif (cmd_ver >= 4)\n\t\t\t\tcontinue;\n\t\t\tif ((j == 0 &&\n\t\t\t\t(fwrt->ppag_chains[i].subbands[j] > ACPI_PPAG_MAX_LB ||\n\t\t\t\t fwrt->ppag_chains[i].subbands[j] < ACPI_PPAG_MIN_LB)) ||\n\t\t\t\t(j != 0 &&\n\t\t\t\t(fwrt->ppag_chains[i].subbands[j] > ACPI_PPAG_MAX_HB ||\n\t\t\t\tfwrt->ppag_chains[i].subbands[j] < ACPI_PPAG_MIN_HB))) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out_free;\n\t\t\t\t}\n\t\t}\n\t}\n\n\tfwrt->ppag_table_valid = true;\n\tret = 0;\n\nout_free:\n\tkfree(data);\n\treturn ret;\n}\nIWL_EXPORT_SYMBOL(iwl_acpi_get_ppag_table);\n\nint iwl_read_ppag_table(struct iwl_fw_runtime *fwrt, union iwl_ppag_table_cmd *cmd,\n\t\t\tint *cmd_size)\n{\n        u8 cmd_ver;\n        int i, j, num_sub_bands;\n        s8 *gain;\n\n\t \n\tif (CSR_HW_RFID_TYPE(fwrt->trans->hw_rf_id) ==\n\t    CSR_HW_RFID_TYPE(CSR_HW_RF_ID_TYPE_JF))\n\t\treturn -EOPNOTSUPP;\n\n        if (!fw_has_capa(&fwrt->fw->ucode_capa, IWL_UCODE_TLV_CAPA_SET_PPAG)) {\n                IWL_DEBUG_RADIO(fwrt,\n                                \"PPAG capability not supported by FW, command not sent.\\n\");\n                return -EINVAL;\n\t}\n\n\tcmd_ver = iwl_fw_lookup_cmd_ver(fwrt->fw,\n\t\t\t\t\tWIDE_ID(PHY_OPS_GROUP,\n\t\t\t\t\t\tPER_PLATFORM_ANT_GAIN_CMD),\n\t\t\t\t\tIWL_FW_CMD_VER_UNKNOWN);\n\tif (!fwrt->ppag_table_valid || (cmd_ver <= 3 && !fwrt->ppag_flags)) {\n\t\tIWL_DEBUG_RADIO(fwrt, \"PPAG not enabled, command not sent.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n         \n        cmd->v1.flags = cpu_to_le32(fwrt->ppag_flags);\n\n\tIWL_DEBUG_RADIO(fwrt, \"PPAG cmd ver is %d\\n\", cmd_ver);\n\tif (cmd_ver == 1) {\n                num_sub_bands = IWL_NUM_SUB_BANDS_V1;\n                gain = cmd->v1.gain[0];\n                *cmd_size = sizeof(cmd->v1);\n                if (fwrt->ppag_ver == 1 || fwrt->ppag_ver == 2) {\n\t\t\t \n                        IWL_DEBUG_RADIO(fwrt,\n\t\t\t\t\t\"PPAG table rev is %d, send truncated table\\n\",\n                                        fwrt->ppag_ver);\n\t\t}\n\t} else if (cmd_ver >= 2 && cmd_ver <= 4) {\n                num_sub_bands = IWL_NUM_SUB_BANDS_V2;\n                gain = cmd->v2.gain[0];\n                *cmd_size = sizeof(cmd->v2);\n                if (fwrt->ppag_ver == 0) {\n\t\t\t \n                        IWL_DEBUG_RADIO(fwrt,\n\t\t\t\t\t\"PPAG table rev is 0, send padded table\\n\");\n                }\n        } else {\n                IWL_DEBUG_RADIO(fwrt, \"Unsupported PPAG command version\\n\");\n                return -EINVAL;\n        }\n\n\t \n\tIWL_DEBUG_RADIO(fwrt,\n\t\t\t\"PPAG MODE bits were read from bios: %d\\n\",\n\t\t\tcmd->v1.flags & cpu_to_le32(ACPI_PPAG_MASK));\n\tif ((cmd_ver == 1 && !fw_has_capa(&fwrt->fw->ucode_capa,\n\t\t\t\t\t  IWL_UCODE_TLV_CAPA_PPAG_CHINA_BIOS_SUPPORT)) ||\n\t    (cmd_ver == 2 && fwrt->ppag_ver == 2)) {\n\t\tcmd->v1.flags &= cpu_to_le32(IWL_PPAG_ETSI_MASK);\n\t\tIWL_DEBUG_RADIO(fwrt, \"masking ppag China bit\\n\");\n\t} else {\n\t\tIWL_DEBUG_RADIO(fwrt, \"isn't masking ppag China bit\\n\");\n\t}\n\n\tIWL_DEBUG_RADIO(fwrt,\n\t\t\t\"PPAG MODE bits going to be sent: %d\\n\",\n\t\t\tcmd->v1.flags & cpu_to_le32(ACPI_PPAG_MASK));\n\n\tfor (i = 0; i < IWL_NUM_CHAIN_LIMITS; i++) {\n                for (j = 0; j < num_sub_bands; j++) {\n                        gain[i * num_sub_bands + j] =\n                                fwrt->ppag_chains[i].subbands[j];\n                        IWL_DEBUG_RADIO(fwrt,\n                                        \"PPAG table: chain[%d] band[%d]: gain = %d\\n\",\n                                        i, j, gain[i * num_sub_bands + j]);\n                }\n        }\n\n\treturn 0;\n}\nIWL_EXPORT_SYMBOL(iwl_read_ppag_table);\n\nbool iwl_acpi_is_ppag_approved(struct iwl_fw_runtime *fwrt)\n{\n\n\tif (!dmi_check_system(dmi_ppag_approved_list)) {\n\t\tIWL_DEBUG_RADIO(fwrt,\n\t\t\t\"System vendor '%s' is not in the approved list, disabling PPAG.\\n\",\n\t\t\tdmi_get_system_info(DMI_SYS_VENDOR));\n\t\t\tfwrt->ppag_flags = 0;\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\nIWL_EXPORT_SYMBOL(iwl_acpi_is_ppag_approved);\n\nvoid iwl_acpi_get_phy_filters(struct iwl_fw_runtime *fwrt,\n\t\t\t      struct iwl_phy_specific_cfg *filters)\n{\n\tstruct iwl_phy_specific_cfg tmp = {};\n\tunion acpi_object *wifi_pkg, *data;\n\tint tbl_rev, i;\n\n\tdata = iwl_acpi_get_object(fwrt->dev, ACPI_WPFC_METHOD);\n\tif (IS_ERR(data))\n\t\treturn;\n\n\t \n\twifi_pkg = iwl_acpi_get_wifi_pkg(fwrt->dev, data,\n\t\t\t\t\t ACPI_WPFC_WIFI_DATA_SIZE,\n\t\t\t\t\t &tbl_rev);\n\tif (IS_ERR(wifi_pkg))\n\t\tgoto out_free;\n\n\tif (tbl_rev != 0)\n\t\tgoto out_free;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(filters->filter_cfg_chains) != ACPI_WPFC_WIFI_DATA_SIZE);\n\n\tfor (i = 0; i < ARRAY_SIZE(filters->filter_cfg_chains); i++) {\n\t\tif (wifi_pkg->package.elements[i].type != ACPI_TYPE_INTEGER)\n\t\t\treturn;\n\t\ttmp.filter_cfg_chains[i] =\n\t\t\tcpu_to_le32(wifi_pkg->package.elements[i].integer.value);\n\t}\n\n\tIWL_DEBUG_RADIO(fwrt, \"Loaded WPFC filter config from ACPI\\n\");\n\t*filters = tmp;\nout_free:\n\tkfree(data);\n}\nIWL_EXPORT_SYMBOL(iwl_acpi_get_phy_filters);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}