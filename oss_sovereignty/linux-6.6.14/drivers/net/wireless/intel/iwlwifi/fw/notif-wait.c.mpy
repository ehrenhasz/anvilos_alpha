{
  "module_name": "notif-wait.c",
  "hash_id": "e87f1c2abc9afab4b7ac1aa01c40410c4043ee787ac9c7bd1295153ff391df7c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/fw/notif-wait.c",
  "human_readable_source": "\n \n#include <linux/sched.h>\n#include <linux/export.h>\n\n#include \"iwl-drv.h\"\n#include \"notif-wait.h\"\n\n\nvoid iwl_notification_wait_init(struct iwl_notif_wait_data *notif_wait)\n{\n\tspin_lock_init(&notif_wait->notif_wait_lock);\n\tINIT_LIST_HEAD(&notif_wait->notif_waits);\n\tinit_waitqueue_head(&notif_wait->notif_waitq);\n}\nIWL_EXPORT_SYMBOL(iwl_notification_wait_init);\n\nbool iwl_notification_wait(struct iwl_notif_wait_data *notif_wait,\n\t\t\t   struct iwl_rx_packet *pkt)\n{\n\tbool triggered = false;\n\n\tif (!list_empty(&notif_wait->notif_waits)) {\n\t\tstruct iwl_notification_wait *w;\n\n\t\tspin_lock_bh(&notif_wait->notif_wait_lock);\n\t\tlist_for_each_entry(w, &notif_wait->notif_waits, list) {\n\t\t\tint i;\n\t\t\tbool found = false;\n\n\t\t\t \n\t\t\tif (w->triggered || w->aborted)\n\t\t\t\tcontinue;\n\n\t\t\tfor (i = 0; i < w->n_cmds; i++) {\n\t\t\t\tu16 rec_id = WIDE_ID(pkt->hdr.group_id,\n\t\t\t\t\t\t     pkt->hdr.cmd);\n\n\t\t\t\tif (w->cmds[i] == rec_id ||\n\t\t\t\t    (!iwl_cmd_groupid(w->cmds[i]) &&\n\t\t\t\t     DEF_ID(w->cmds[i]) == rec_id)) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found)\n\t\t\t\tcontinue;\n\n\t\t\tif (!w->fn || w->fn(notif_wait, pkt, w->fn_data)) {\n\t\t\t\tw->triggered = true;\n\t\t\t\ttriggered = true;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&notif_wait->notif_wait_lock);\n\t}\n\n\treturn triggered;\n}\nIWL_EXPORT_SYMBOL(iwl_notification_wait);\n\nvoid iwl_abort_notification_waits(struct iwl_notif_wait_data *notif_wait)\n{\n\tstruct iwl_notification_wait *wait_entry;\n\n\tspin_lock_bh(&notif_wait->notif_wait_lock);\n\tlist_for_each_entry(wait_entry, &notif_wait->notif_waits, list)\n\t\twait_entry->aborted = true;\n\tspin_unlock_bh(&notif_wait->notif_wait_lock);\n\n\twake_up_all(&notif_wait->notif_waitq);\n}\nIWL_EXPORT_SYMBOL(iwl_abort_notification_waits);\n\nvoid\niwl_init_notification_wait(struct iwl_notif_wait_data *notif_wait,\n\t\t\t   struct iwl_notification_wait *wait_entry,\n\t\t\t   const u16 *cmds, int n_cmds,\n\t\t\t   bool (*fn)(struct iwl_notif_wait_data *notif_wait,\n\t\t\t\t      struct iwl_rx_packet *pkt, void *data),\n\t\t\t   void *fn_data)\n{\n\tif (WARN_ON(n_cmds > MAX_NOTIF_CMDS))\n\t\tn_cmds = MAX_NOTIF_CMDS;\n\n\twait_entry->fn = fn;\n\twait_entry->fn_data = fn_data;\n\twait_entry->n_cmds = n_cmds;\n\tmemcpy(wait_entry->cmds, cmds, n_cmds * sizeof(u16));\n\twait_entry->triggered = false;\n\twait_entry->aborted = false;\n\n\tspin_lock_bh(&notif_wait->notif_wait_lock);\n\tlist_add(&wait_entry->list, &notif_wait->notif_waits);\n\tspin_unlock_bh(&notif_wait->notif_wait_lock);\n}\nIWL_EXPORT_SYMBOL(iwl_init_notification_wait);\n\nvoid iwl_remove_notification(struct iwl_notif_wait_data *notif_wait,\n\t\t\t     struct iwl_notification_wait *wait_entry)\n{\n\tspin_lock_bh(&notif_wait->notif_wait_lock);\n\tlist_del(&wait_entry->list);\n\tspin_unlock_bh(&notif_wait->notif_wait_lock);\n}\nIWL_EXPORT_SYMBOL(iwl_remove_notification);\n\nint iwl_wait_notification(struct iwl_notif_wait_data *notif_wait,\n\t\t\t  struct iwl_notification_wait *wait_entry,\n\t\t\t  unsigned long timeout)\n{\n\tint ret;\n\n\tret = wait_event_timeout(notif_wait->notif_waitq,\n\t\t\t\t wait_entry->triggered || wait_entry->aborted,\n\t\t\t\t timeout);\n\n\tiwl_remove_notification(notif_wait, wait_entry);\n\n\tif (wait_entry->aborted)\n\t\treturn -EIO;\n\n\t \n\tif (ret <= 0)\n\t\treturn -ETIMEDOUT;\n\treturn 0;\n}\nIWL_EXPORT_SYMBOL(iwl_wait_notification);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}