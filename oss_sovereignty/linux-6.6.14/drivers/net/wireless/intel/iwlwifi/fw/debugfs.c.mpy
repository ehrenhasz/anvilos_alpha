{
  "module_name": "debugfs.c",
  "hash_id": "ee46d9590502e51f581db7c8106a204ddb9af0ead0c6aacf786d317ef735908a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/fw/debugfs.c",
  "human_readable_source": "\n \n#include \"api/commands.h\"\n#include \"debugfs.h\"\n#include \"dbg.h\"\n#include <linux/seq_file.h>\n\n#define FWRT_DEBUGFS_OPEN_WRAPPER(name, buflen, argtype)\t\t\\\nstruct dbgfs_##name##_data {\t\t\t\t\t\t\\\n\targtype *arg;\t\t\t\t\t\t\t\\\n\tbool read_done;\t\t\t\t\t\t\t\\\n\tssize_t rlen;\t\t\t\t\t\t\t\\\n\tchar rbuf[buflen];\t\t\t\t\t\t\\\n};\t\t\t\t\t\t\t\t\t\\\nstatic int _iwl_dbgfs_##name##_open(struct inode *inode,\t\t\\\n\t\t\t\t    struct file *file)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct dbgfs_##name##_data *data;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\t\t\t\\\n\tif (!data)\t\t\t\t\t\t\t\\\n\t\treturn -ENOMEM;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tdata->read_done = false;\t\t\t\t\t\\\n\tdata->arg = inode->i_private;\t\t\t\t\t\\\n\tfile->private_data = data;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\t\\\n}\n\n#define FWRT_DEBUGFS_READ_WRAPPER(name)\t\t\t\t\t\\\nstatic ssize_t _iwl_dbgfs_##name##_read(struct file *file,\t\t\\\n\t\t\t\t\tchar __user *user_buf,\t\t\\\n\t\t\t\t\tsize_t count, loff_t *ppos)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct dbgfs_##name##_data *data = file->private_data;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (!data->read_done) {\t\t\t\t\t\t\\\n\t\tdata->read_done = true;\t\t\t\t\t\\\n\t\tdata->rlen = iwl_dbgfs_##name##_read(data->arg,\t\t\\\n\t\t\t\t\t\t     sizeof(data->rbuf),\\\n\t\t\t\t\t\t     data->rbuf);\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (data->rlen < 0)\t\t\t\t\t\t\\\n\t\treturn data->rlen;\t\t\t\t\t\\\n\treturn simple_read_from_buffer(user_buf, count, ppos,\t\t\\\n\t\t\t\t       data->rbuf, data->rlen);\t\t\\\n}\n\nstatic int _iwl_dbgfs_release(struct inode *inode, struct file *file)\n{\n\tkfree(file->private_data);\n\n\treturn 0;\n}\n\n#define _FWRT_DEBUGFS_READ_FILE_OPS(name, buflen, argtype)\t\t\\\nFWRT_DEBUGFS_OPEN_WRAPPER(name, buflen, argtype)\t\t\t\\\nFWRT_DEBUGFS_READ_WRAPPER(name)\t\t\t\t\t\t\\\nstatic const struct file_operations iwl_dbgfs_##name##_ops = {\t\t\\\n\t.read = _iwl_dbgfs_##name##_read,\t\t\t\t\\\n\t.open = _iwl_dbgfs_##name##_open,\t\t\t\t\\\n\t.llseek = generic_file_llseek,\t\t\t\t\t\\\n\t.release = _iwl_dbgfs_release,\t\t\t\t\t\\\n}\n\n#define FWRT_DEBUGFS_WRITE_WRAPPER(name, buflen, argtype)\t\t\\\nstatic ssize_t _iwl_dbgfs_##name##_write(struct file *file,\t\t\\\n\t\t\t\t\t const char __user *user_buf,\t\\\n\t\t\t\t\t size_t count, loff_t *ppos)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\targtype *arg =\t\t\t\t\t\t\t\\\n\t\t((struct dbgfs_##name##_data *)file->private_data)->arg;\\\n\tchar buf[buflen] = {};\t\t\t\t\t\t\\\n\tsize_t buf_size = min(count, sizeof(buf) -  1);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (copy_from_user(buf, user_buf, buf_size))\t\t\t\\\n\t\treturn -EFAULT;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn iwl_dbgfs_##name##_write(arg, buf, buf_size);\t\t\\\n}\n\n#define _FWRT_DEBUGFS_READ_WRITE_FILE_OPS(name, buflen, argtype)\t\\\nFWRT_DEBUGFS_OPEN_WRAPPER(name, buflen, argtype)\t\t\t\\\nFWRT_DEBUGFS_WRITE_WRAPPER(name, buflen, argtype)\t\t\t\\\nFWRT_DEBUGFS_READ_WRAPPER(name)\t\t\t\t\t\t\\\nstatic const struct file_operations iwl_dbgfs_##name##_ops = {\t\t\\\n\t.write = _iwl_dbgfs_##name##_write,\t\t\t\t\\\n\t.read = _iwl_dbgfs_##name##_read,\t\t\t\t\\\n\t.open = _iwl_dbgfs_##name##_open,\t\t\t\t\\\n\t.llseek = generic_file_llseek,\t\t\t\t\t\\\n\t.release = _iwl_dbgfs_release,\t\t\t\t\t\\\n}\n\n#define _FWRT_DEBUGFS_WRITE_FILE_OPS(name, buflen, argtype)\t\t\\\nFWRT_DEBUGFS_OPEN_WRAPPER(name, buflen, argtype)\t\t\t\\\nFWRT_DEBUGFS_WRITE_WRAPPER(name, buflen, argtype)\t\t\t\\\nstatic const struct file_operations iwl_dbgfs_##name##_ops = {\t\t\\\n\t.write = _iwl_dbgfs_##name##_write,\t\t\t\t\\\n\t.open = _iwl_dbgfs_##name##_open,\t\t\t\t\\\n\t.llseek = generic_file_llseek,\t\t\t\t\t\\\n\t.release = _iwl_dbgfs_release,\t\t\t\t\t\\\n}\n\n#define FWRT_DEBUGFS_READ_FILE_OPS(name, bufsz)\t\t\t\t\\\n\t_FWRT_DEBUGFS_READ_FILE_OPS(name, bufsz, struct iwl_fw_runtime)\n\n#define FWRT_DEBUGFS_WRITE_FILE_OPS(name, bufsz)\t\t\t\\\n\t_FWRT_DEBUGFS_WRITE_FILE_OPS(name, bufsz, struct iwl_fw_runtime)\n\n#define FWRT_DEBUGFS_READ_WRITE_FILE_OPS(name, bufsz)\t\t\t\\\n\t_FWRT_DEBUGFS_READ_WRITE_FILE_OPS(name, bufsz, struct iwl_fw_runtime)\n\n#define FWRT_DEBUGFS_ADD_FILE_ALIAS(alias, name, parent, mode) do {\t\\\n\tdebugfs_create_file(alias, mode, parent, fwrt,\t\t\t\\\n\t\t\t    &iwl_dbgfs_##name##_ops);\t\t\t\\\n\t} while (0)\n#define FWRT_DEBUGFS_ADD_FILE(name, parent, mode) \\\n\tFWRT_DEBUGFS_ADD_FILE_ALIAS(#name, name, parent, mode)\n\nstatic int iwl_dbgfs_enabled_severities_write(struct iwl_fw_runtime *fwrt,\n\t\t\t\t\t      char *buf, size_t count)\n{\n\tstruct iwl_dbg_host_event_cfg_cmd event_cfg;\n\tstruct iwl_host_cmd hcmd = {\n\t\t.id = WIDE_ID(DEBUG_GROUP, HOST_EVENT_CFG),\n\t\t.flags = CMD_ASYNC,\n\t\t.data[0] = &event_cfg,\n\t\t.len[0] = sizeof(event_cfg),\n\t};\n\tu32 enabled_severities;\n\tint ret = kstrtou32(buf, 10, &enabled_severities);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tevent_cfg.enabled_severities = cpu_to_le32(enabled_severities);\n\n\tret = iwl_trans_send_cmd(fwrt->trans, &hcmd);\n\tIWL_INFO(fwrt,\n\t\t \"sent host event cfg with enabled_severities: %u, ret: %d\\n\",\n\t\t enabled_severities, ret);\n\n\treturn ret ?: count;\n}\n\nFWRT_DEBUGFS_WRITE_FILE_OPS(enabled_severities, 16);\n\nstatic void iwl_fw_timestamp_marker_wk(struct work_struct *work)\n{\n\tint ret;\n\tstruct iwl_fw_runtime *fwrt =\n\t\tcontainer_of(work, struct iwl_fw_runtime, timestamp.wk.work);\n\tunsigned long delay = fwrt->timestamp.delay;\n\n\tret = iwl_fw_send_timestamp_marker_cmd(fwrt);\n\tif (!ret && delay)\n\t\tschedule_delayed_work(&fwrt->timestamp.wk,\n\t\t\t\t      round_jiffies_relative(delay));\n\telse\n\t\tIWL_INFO(fwrt,\n\t\t\t \"stopping timestamp_marker, ret: %d, delay: %u\\n\",\n\t\t\t ret, jiffies_to_msecs(delay) / 1000);\n}\n\nvoid iwl_fw_trigger_timestamp(struct iwl_fw_runtime *fwrt, u32 delay)\n{\n\tIWL_INFO(fwrt,\n\t\t \"starting timestamp_marker trigger with delay: %us\\n\",\n\t\t delay);\n\n\tiwl_fw_cancel_timestamp(fwrt);\n\n\tfwrt->timestamp.delay = msecs_to_jiffies(delay * 1000);\n\n\tschedule_delayed_work(&fwrt->timestamp.wk,\n\t\t\t      round_jiffies_relative(fwrt->timestamp.delay));\n}\n\nstatic ssize_t iwl_dbgfs_timestamp_marker_write(struct iwl_fw_runtime *fwrt,\n\t\t\t\t\t\tchar *buf, size_t count)\n{\n\tint ret;\n\tu32 delay;\n\n\tret = kstrtou32(buf, 10, &delay);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tiwl_fw_trigger_timestamp(fwrt, delay);\n\n\treturn count;\n}\n\nstatic ssize_t iwl_dbgfs_timestamp_marker_read(struct iwl_fw_runtime *fwrt,\n\t\t\t\t\t       size_t size, char *buf)\n{\n\tu32 delay_secs = jiffies_to_msecs(fwrt->timestamp.delay) / 1000;\n\n\treturn scnprintf(buf, size, \"%d\\n\", delay_secs);\n}\n\nFWRT_DEBUGFS_READ_WRITE_FILE_OPS(timestamp_marker, 16);\n\nstruct hcmd_write_data {\n\t__be32 cmd_id;\n\t__be32 flags;\n\t__be16 length;\n\tu8 data[];\n} __packed;\n\nstatic ssize_t iwl_dbgfs_send_hcmd_write(struct iwl_fw_runtime *fwrt, char *buf,\n\t\t\t\t\t size_t count)\n{\n\tsize_t header_size = (sizeof(u32) * 2 + sizeof(u16)) * 2;\n\tsize_t data_size = (count - 1) / 2;\n\tint ret;\n\tstruct hcmd_write_data *data;\n\tstruct iwl_host_cmd hcmd = {\n\t\t.len = { 0, },\n\t\t.data = { NULL, },\n\t};\n\n\tif (fwrt->ops && fwrt->ops->fw_running &&\n\t    !fwrt->ops->fw_running(fwrt->ops_ctx))\n\t\treturn -EIO;\n\n\tif (count < header_size + 1 || count > 1024 * 4)\n\t\treturn -EINVAL;\n\n\tdata = kmalloc(data_size, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = hex2bin((u8 *)data, buf, data_size);\n\tif (ret)\n\t\tgoto out;\n\n\thcmd.id = be32_to_cpu(data->cmd_id);\n\thcmd.flags = be32_to_cpu(data->flags);\n\thcmd.len[0] = be16_to_cpu(data->length);\n\thcmd.data[0] = data->data;\n\n\tif (count != header_size + hcmd.len[0] * 2 + 1) {\n\t\tIWL_ERR(fwrt,\n\t\t\t\"host command data size does not match header length\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (fwrt->ops && fwrt->ops->send_hcmd)\n\t\tret = fwrt->ops->send_hcmd(fwrt->ops_ctx, &hcmd);\n\telse\n\t\tret = -EPERM;\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (hcmd.flags & CMD_WANT_SKB)\n\t\tiwl_free_resp(&hcmd);\nout:\n\tkfree(data);\n\treturn ret ?: count;\n}\n\nFWRT_DEBUGFS_WRITE_FILE_OPS(send_hcmd, 512);\n\nstatic ssize_t iwl_dbgfs_fw_dbg_domain_read(struct iwl_fw_runtime *fwrt,\n\t\t\t\t\t    size_t size, char *buf)\n{\n\treturn scnprintf(buf, size, \"0x%08x\\n\",\n\t\t\t fwrt->trans->dbg.domains_bitmap);\n}\n\nFWRT_DEBUGFS_READ_FILE_OPS(fw_dbg_domain, 20);\n\nstruct iwl_dbgfs_fw_info_priv {\n\tstruct iwl_fw_runtime *fwrt;\n};\n\nstruct iwl_dbgfs_fw_info_state {\n\tloff_t pos;\n};\n\nstatic void *iwl_dbgfs_fw_info_seq_next(struct seq_file *seq,\n\t\t\t\t\tvoid *v, loff_t *pos)\n{\n\tstruct iwl_dbgfs_fw_info_state *state = v;\n\tstruct iwl_dbgfs_fw_info_priv *priv = seq->private;\n\tconst struct iwl_fw *fw = priv->fwrt->fw;\n\n\t*pos = ++state->pos;\n\tif (*pos >= fw->ucode_capa.n_cmd_versions) {\n\t\tkfree(state);\n\t\treturn NULL;\n\t}\n\n\treturn state;\n}\n\nstatic void iwl_dbgfs_fw_info_seq_stop(struct seq_file *seq,\n\t\t\t\t       void *v)\n{\n\tkfree(v);\n}\n\nstatic void *iwl_dbgfs_fw_info_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct iwl_dbgfs_fw_info_priv *priv = seq->private;\n\tconst struct iwl_fw *fw = priv->fwrt->fw;\n\tstruct iwl_dbgfs_fw_info_state *state;\n\n\tif (*pos >= fw->ucode_capa.n_cmd_versions)\n\t\treturn NULL;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\tstate->pos = *pos;\n\treturn state;\n};\n\nstatic int iwl_dbgfs_fw_info_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct iwl_dbgfs_fw_info_state *state = v;\n\tstruct iwl_dbgfs_fw_info_priv *priv = seq->private;\n\tconst struct iwl_fw *fw = priv->fwrt->fw;\n\tconst struct iwl_fw_cmd_version *ver;\n\tu32 cmd_id;\n\tint has_capa;\n\n\tif (!state->pos) {\n\t\tseq_puts(seq, \"fw_capa:\\n\");\n\t\thas_capa = fw_has_capa(&fw->ucode_capa,\n\t\t\t\t       IWL_UCODE_TLV_CAPA_PPAG_CHINA_BIOS_SUPPORT) ? 1 : 0;\n\t\tseq_printf(seq,\n\t\t\t   \"    %d: %d\\n\",\n\t\t\t   IWL_UCODE_TLV_CAPA_PPAG_CHINA_BIOS_SUPPORT,\n\t\t\t   has_capa);\n\t\tseq_puts(seq, \"fw_api_ver:\\n\");\n\t}\n\n\tver = &fw->ucode_capa.cmd_versions[state->pos];\n\n\tcmd_id = WIDE_ID(ver->group, ver->cmd);\n\n\tseq_printf(seq, \"  0x%04x:\\n\", cmd_id);\n\tseq_printf(seq, \"    name: %s\\n\",\n\t\t   iwl_get_cmd_string(priv->fwrt->trans, cmd_id));\n\tseq_printf(seq, \"    cmd_ver: %d\\n\", ver->cmd_ver);\n\tseq_printf(seq, \"    notif_ver: %d\\n\", ver->notif_ver);\n\treturn 0;\n}\n\nstatic const struct seq_operations iwl_dbgfs_info_seq_ops = {\n\t.start = iwl_dbgfs_fw_info_seq_start,\n\t.next = iwl_dbgfs_fw_info_seq_next,\n\t.stop = iwl_dbgfs_fw_info_seq_stop,\n\t.show = iwl_dbgfs_fw_info_seq_show,\n};\n\nstatic int iwl_dbgfs_fw_info_open(struct inode *inode, struct file *filp)\n{\n\tstruct iwl_dbgfs_fw_info_priv *priv;\n\n\tpriv = __seq_open_private(filp, &iwl_dbgfs_info_seq_ops,\n\t\t\t\t  sizeof(*priv));\n\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->fwrt = inode->i_private;\n\treturn 0;\n}\n\nstatic const struct file_operations iwl_dbgfs_fw_info_ops = {\n\t.owner = THIS_MODULE,\n\t.open = iwl_dbgfs_fw_info_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release_private,\n};\n\nvoid iwl_fwrt_dbgfs_register(struct iwl_fw_runtime *fwrt,\n\t\t\t    struct dentry *dbgfs_dir)\n{\n\tINIT_DELAYED_WORK(&fwrt->timestamp.wk, iwl_fw_timestamp_marker_wk);\n\tFWRT_DEBUGFS_ADD_FILE(timestamp_marker, dbgfs_dir, 0200);\n\tFWRT_DEBUGFS_ADD_FILE(fw_info, dbgfs_dir, 0200);\n\tFWRT_DEBUGFS_ADD_FILE(send_hcmd, dbgfs_dir, 0200);\n\tFWRT_DEBUGFS_ADD_FILE(enabled_severities, dbgfs_dir, 0200);\n\tFWRT_DEBUGFS_ADD_FILE(fw_dbg_domain, dbgfs_dir, 0400);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}