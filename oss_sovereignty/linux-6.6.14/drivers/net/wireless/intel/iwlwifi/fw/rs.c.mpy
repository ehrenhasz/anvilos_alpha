{
  "module_name": "rs.c",
  "hash_id": "d9229f56d73a9bfc36bf2ab1de2ebebb4b1f762d82bf536e5a9b69de364a16bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/fw/rs.c",
  "human_readable_source": "\n \n\n#include <net/mac80211.h>\n#include \"fw/api/rs.h\"\n#include \"iwl-drv.h\"\n#include \"iwl-config.h\"\n\n#define IWL_DECLARE_RATE_INFO(r) \\\n\t[IWL_RATE_##r##M_INDEX] = IWL_RATE_##r##M_PLCP\n\n \nstatic const u8 fw_rate_idx_to_plcp[IWL_RATE_COUNT] = {\n\tIWL_DECLARE_RATE_INFO(1),\n\tIWL_DECLARE_RATE_INFO(2),\n\tIWL_DECLARE_RATE_INFO(5),\n\tIWL_DECLARE_RATE_INFO(11),\n\tIWL_DECLARE_RATE_INFO(6),\n\tIWL_DECLARE_RATE_INFO(9),\n\tIWL_DECLARE_RATE_INFO(12),\n\tIWL_DECLARE_RATE_INFO(18),\n\tIWL_DECLARE_RATE_INFO(24),\n\tIWL_DECLARE_RATE_INFO(36),\n\tIWL_DECLARE_RATE_INFO(48),\n\tIWL_DECLARE_RATE_INFO(54),\n};\n\n \nstatic const struct iwl_rate_mcs_info rate_mcs[IWL_RATE_COUNT] = {\n\t{  \"1\", \"BPSK DSSS\"},\n\t{  \"2\", \"QPSK DSSS\"},\n\t{\"5.5\", \"BPSK CCK\"},\n\t{ \"11\", \"QPSK CCK\"},\n\t{  \"6\", \"BPSK 1/2\"},\n\t{  \"9\", \"BPSK 1/2\"},\n\t{ \"12\", \"QPSK 1/2\"},\n\t{ \"18\", \"QPSK 3/4\"},\n\t{ \"24\", \"16QAM 1/2\"},\n\t{ \"36\", \"16QAM 3/4\"},\n\t{ \"48\", \"64QAM 2/3\"},\n\t{ \"54\", \"64QAM 3/4\"},\n\t{ \"60\", \"64QAM 5/6\"},\n};\n\nstatic const char * const ant_name[] = {\n\t[ANT_NONE] = \"None\",\n\t[ANT_A]    = \"A\",\n\t[ANT_B]    = \"B\",\n\t[ANT_AB]   = \"AB\",\n};\n\nstatic const char * const pretty_bw[] = {\n\t\"20Mhz\",\n\t\"40Mhz\",\n\t\"80Mhz\",\n\t\"160 Mhz\",\n\t\"320Mhz\",\n};\n\nu8 iwl_fw_rate_idx_to_plcp(int idx)\n{\n\treturn fw_rate_idx_to_plcp[idx];\n}\nIWL_EXPORT_SYMBOL(iwl_fw_rate_idx_to_plcp);\n\nconst struct iwl_rate_mcs_info *iwl_rate_mcs(int idx)\n{\n\treturn &rate_mcs[idx];\n}\nIWL_EXPORT_SYMBOL(iwl_rate_mcs);\n\nconst char *iwl_rs_pretty_ant(u8 ant)\n{\n\tif (ant >= ARRAY_SIZE(ant_name))\n\t\treturn \"UNKNOWN\";\n\n\treturn ant_name[ant];\n}\nIWL_EXPORT_SYMBOL(iwl_rs_pretty_ant);\n\nconst char *iwl_rs_pretty_bw(int bw)\n{\n\tif (bw >= ARRAY_SIZE(pretty_bw))\n\t\treturn \"unknown bw\";\n\n\treturn pretty_bw[bw];\n}\nIWL_EXPORT_SYMBOL(iwl_rs_pretty_bw);\n\nstatic u32 iwl_legacy_rate_to_fw_idx(u32 rate_n_flags)\n{\n\tint rate = rate_n_flags & RATE_LEGACY_RATE_MSK_V1;\n\tint idx;\n\tbool ofdm = !(rate_n_flags & RATE_MCS_CCK_MSK_V1);\n\tint offset = ofdm ? IWL_FIRST_OFDM_RATE : 0;\n\tint last = ofdm ? IWL_RATE_COUNT_LEGACY : IWL_FIRST_OFDM_RATE;\n\n\tfor (idx = offset; idx < last; idx++)\n\t\tif (iwl_fw_rate_idx_to_plcp(idx) == rate)\n\t\t\treturn idx - offset;\n\treturn IWL_RATE_INVALID;\n}\n\nu32 iwl_new_rate_from_v1(u32 rate_v1)\n{\n\tu32 rate_v2 = 0;\n\tu32 dup = 0;\n\n\tif (rate_v1 == 0)\n\t\treturn rate_v1;\n\t \n\tif (rate_v1 & RATE_MCS_HT_MSK_V1) {\n\t\tu32 nss = 0;\n\n\t\trate_v2 |= RATE_MCS_HT_MSK;\n\t\trate_v2 |=\n\t\t\trate_v1 & RATE_HT_MCS_RATE_CODE_MSK_V1;\n\t\tnss = (rate_v1 & RATE_HT_MCS_MIMO2_MSK) >>\n\t\t\tRATE_HT_MCS_NSS_POS_V1;\n\t\trate_v2 |= nss << RATE_MCS_NSS_POS;\n\t} else if (rate_v1 & RATE_MCS_VHT_MSK_V1 ||\n\t\t   rate_v1 & RATE_MCS_HE_MSK_V1) {\n\t\trate_v2 |= rate_v1 & RATE_VHT_MCS_RATE_CODE_MSK;\n\n\t\trate_v2 |= rate_v1 & RATE_MCS_NSS_MSK;\n\n\t\tif (rate_v1 & RATE_MCS_HE_MSK_V1) {\n\t\t\tu32 he_type_bits = rate_v1 & RATE_MCS_HE_TYPE_MSK_V1;\n\t\t\tu32 he_type = he_type_bits >> RATE_MCS_HE_TYPE_POS_V1;\n\t\t\tu32 he_106t = (rate_v1 & RATE_MCS_HE_106T_MSK_V1) >>\n\t\t\t\tRATE_MCS_HE_106T_POS_V1;\n\t\t\tu32 he_gi_ltf = (rate_v1 & RATE_MCS_HE_GI_LTF_MSK_V1) >>\n\t\t\t\tRATE_MCS_HE_GI_LTF_POS;\n\n\t\t\tif ((he_type_bits == RATE_MCS_HE_TYPE_SU ||\n\t\t\t     he_type_bits == RATE_MCS_HE_TYPE_EXT_SU) &&\n\t\t\t    he_gi_ltf == RATE_MCS_HE_SU_4_LTF)\n\t\t\t\t \n\t\t\t\the_gi_ltf += (rate_v1 & RATE_MCS_SGI_MSK_V1) >>\n\t\t\t\t\tRATE_MCS_SGI_POS_V1;\n\n\t\t\trate_v2 |= he_gi_ltf << RATE_MCS_HE_GI_LTF_POS;\n\t\t\trate_v2 |= he_type << RATE_MCS_HE_TYPE_POS;\n\t\t\trate_v2 |= he_106t << RATE_MCS_HE_106T_POS;\n\t\t\trate_v2 |= rate_v1 & RATE_HE_DUAL_CARRIER_MODE_MSK;\n\t\t\trate_v2 |= RATE_MCS_HE_MSK;\n\t\t} else {\n\t\t\trate_v2 |= RATE_MCS_VHT_MSK;\n\t\t}\n\t \n\t} else {\n\t\tu32 legacy_rate = iwl_legacy_rate_to_fw_idx(rate_v1);\n\n\t\tif (WARN_ON_ONCE(legacy_rate == IWL_RATE_INVALID))\n\t\t\tlegacy_rate = (rate_v1 & RATE_MCS_CCK_MSK_V1) ?\n\t\t\t\tIWL_FIRST_CCK_RATE : IWL_FIRST_OFDM_RATE;\n\n\t\trate_v2 |= legacy_rate;\n\t\tif (!(rate_v1 & RATE_MCS_CCK_MSK_V1))\n\t\t\trate_v2 |= RATE_MCS_LEGACY_OFDM_MSK;\n\t}\n\n\t \n\tif (rate_v1 & RATE_MCS_LDPC_MSK_V1)\n\t\trate_v2 |= RATE_MCS_LDPC_MSK;\n\trate_v2 |= (rate_v1 & RATE_MCS_CHAN_WIDTH_MSK_V1) |\n\t\t(rate_v1 & RATE_MCS_ANT_AB_MSK) |\n\t\t(rate_v1 & RATE_MCS_STBC_MSK) |\n\t\t(rate_v1 & RATE_MCS_BF_MSK);\n\n\tdup = (rate_v1 & RATE_MCS_DUP_MSK_V1) >> RATE_MCS_DUP_POS_V1;\n\tif (dup) {\n\t\trate_v2 |= RATE_MCS_DUP_MSK;\n\t\trate_v2 |= dup << RATE_MCS_CHAN_WIDTH_POS;\n\t}\n\n\tif ((!(rate_v1 & RATE_MCS_HE_MSK_V1)) &&\n\t    (rate_v1 & RATE_MCS_SGI_MSK_V1))\n\t\trate_v2 |= RATE_MCS_SGI_MSK;\n\n\treturn rate_v2;\n}\nIWL_EXPORT_SYMBOL(iwl_new_rate_from_v1);\n\nint rs_pretty_print_rate(char *buf, int bufsz, const u32 rate)\n{\n\tchar *type;\n\tu8 mcs = 0, nss = 0;\n\tu8 ant = (rate & RATE_MCS_ANT_AB_MSK) >> RATE_MCS_ANT_POS;\n\tu32 bw = (rate & RATE_MCS_CHAN_WIDTH_MSK) >>\n\t\tRATE_MCS_CHAN_WIDTH_POS;\n\tu32 format = rate & RATE_MCS_MOD_TYPE_MSK;\n\tbool sgi;\n\n\tif (format == RATE_MCS_CCK_MSK ||\n\t    format == RATE_MCS_LEGACY_OFDM_MSK) {\n\t\tint legacy_rate = rate & RATE_LEGACY_RATE_MSK;\n\t\tint index = format == RATE_MCS_CCK_MSK ?\n\t\t\tlegacy_rate :\n\t\t\tlegacy_rate + IWL_FIRST_OFDM_RATE;\n\n\t\treturn scnprintf(buf, bufsz, \"Legacy | ANT: %s Rate: %s Mbps\",\n\t\t\t\t iwl_rs_pretty_ant(ant),\n\t\t\t\t index == IWL_RATE_INVALID ? \"BAD\" :\n\t\t\t\t iwl_rate_mcs(index)->mbps);\n\t}\n\n\tif (format ==  RATE_MCS_VHT_MSK)\n\t\ttype = \"VHT\";\n\telse if (format ==  RATE_MCS_HT_MSK)\n\t\ttype = \"HT\";\n\telse if (format == RATE_MCS_HE_MSK)\n\t\ttype = \"HE\";\n\telse if (format == RATE_MCS_EHT_MSK)\n\t\ttype = \"EHT\";\n\telse\n\t\ttype = \"Unknown\";  \n\n\tmcs = format == RATE_MCS_HT_MSK ?\n\t\tRATE_HT_MCS_INDEX(rate) :\n\t\trate & RATE_MCS_CODE_MSK;\n\tnss = ((rate & RATE_MCS_NSS_MSK)\n\t       >> RATE_MCS_NSS_POS) + 1;\n\tsgi = format == RATE_MCS_HE_MSK ?\n\t\tiwl_he_is_sgi(rate) :\n\t\trate & RATE_MCS_SGI_MSK;\n\n\treturn scnprintf(buf, bufsz,\n\t\t\t \"0x%x: %s | ANT: %s BW: %s MCS: %d NSS: %d %s%s%s%s%s\",\n\t\t\t rate, type, iwl_rs_pretty_ant(ant), iwl_rs_pretty_bw(bw), mcs, nss,\n\t\t\t (sgi) ? \"SGI \" : \"NGI \",\n\t\t\t (rate & RATE_MCS_STBC_MSK) ? \"STBC \" : \"\",\n\t\t\t (rate & RATE_MCS_LDPC_MSK) ? \"LDPC \" : \"\",\n\t\t\t (rate & RATE_HE_DUAL_CARRIER_MODE_MSK) ? \"DCM \" : \"\",\n\t\t\t (rate & RATE_MCS_BF_MSK) ? \"BF \" : \"\");\n}\nIWL_EXPORT_SYMBOL(rs_pretty_print_rate);\n\nbool iwl_he_is_sgi(u32 rate_n_flags)\n{\n\tu32 type = rate_n_flags & RATE_MCS_HE_TYPE_MSK;\n\tu32 ltf_gi = rate_n_flags & RATE_MCS_HE_GI_LTF_MSK;\n\n\tif (type == RATE_MCS_HE_TYPE_SU ||\n\t    type == RATE_MCS_HE_TYPE_EXT_SU)\n\t\treturn ltf_gi == RATE_MCS_HE_SU_4_LTF_08_GI;\n\treturn false;\n}\nIWL_EXPORT_SYMBOL(iwl_he_is_sgi);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}