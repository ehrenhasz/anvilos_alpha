{
  "module_name": "dbg.h",
  "hash_id": "7c69d3282f0ebc5e69237d13d1ddf51fd110b80c0b3ea1a0f7bb985d541f51bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/fw/dbg.h",
  "human_readable_source": " \n \n#ifndef __iwl_fw_dbg_h__\n#define __iwl_fw_dbg_h__\n#include <linux/workqueue.h>\n#include <net/cfg80211.h>\n#include \"runtime.h\"\n#include \"iwl-prph.h\"\n#include \"iwl-io.h\"\n#include \"file.h\"\n#include \"error-dump.h\"\n#include \"api/commands.h\"\n#include \"api/dbg-tlv.h\"\n#include \"api/alive.h\"\n\n \nstruct iwl_fw_dump_desc {\n\tsize_t len;\n\t \n\tstruct iwl_fw_error_dump_trigger_desc trig_desc;\n};\n\n \nstruct iwl_fw_dbg_params {\n\tu32 in_sample;\n\tu32 out_ctrl;\n};\n\nextern const struct iwl_fw_dump_desc iwl_dump_desc_assert;\n\nint iwl_fw_dbg_collect_desc(struct iwl_fw_runtime *fwrt,\n\t\t\t    const struct iwl_fw_dump_desc *desc,\n\t\t\t    bool monitor_only, unsigned int delay);\nint iwl_fw_dbg_error_collect(struct iwl_fw_runtime *fwrt,\n\t\t\t     enum iwl_fw_dbg_trigger trig_type);\nint iwl_fw_dbg_ini_collect(struct iwl_fw_runtime *fwrt,\n\t\t\t   struct iwl_fwrt_dump_data *dump_data,\n\t\t\t   bool sync);\nint iwl_fw_dbg_collect(struct iwl_fw_runtime *fwrt,\n\t\t       enum iwl_fw_dbg_trigger trig, const char *str,\n\t\t       size_t len, struct iwl_fw_dbg_trigger_tlv *trigger);\nint iwl_fw_dbg_collect_trig(struct iwl_fw_runtime *fwrt,\n\t\t\t    struct iwl_fw_dbg_trigger_tlv *trigger,\n\t\t\t    const char *fmt, ...) __printf(3, 4);\nint iwl_fw_start_dbg_conf(struct iwl_fw_runtime *fwrt, u8 id);\n\n#define iwl_fw_dbg_trigger_enabled(fw, id) ({\t\t\t\\\n\tvoid *__dbg_trigger = (fw)->dbg.trigger_tlv[(id)];\t\\\n\tunlikely(__dbg_trigger);\t\t\t\t\\\n})\n\nstatic inline struct iwl_fw_dbg_trigger_tlv*\n_iwl_fw_dbg_get_trigger(const struct iwl_fw *fw, enum iwl_fw_dbg_trigger id)\n{\n\treturn fw->dbg.trigger_tlv[id];\n}\n\n#define iwl_fw_dbg_get_trigger(fw, id) ({\t\t\t\\\n\tBUILD_BUG_ON(!__builtin_constant_p(id));\t\t\\\n\tBUILD_BUG_ON((id) >= FW_DBG_TRIGGER_MAX);\t\t\\\n\t_iwl_fw_dbg_get_trigger((fw), (id));\t\t\t\\\n})\n\nstatic inline bool\niwl_fw_dbg_trigger_vif_match(struct iwl_fw_dbg_trigger_tlv *trig,\n\t\t\t     struct wireless_dev *wdev)\n{\n\tu32 trig_vif = le32_to_cpu(trig->vif_type);\n\n\treturn trig_vif == IWL_FW_DBG_CONF_VIF_ANY ||\n\t       wdev->iftype == trig_vif;\n}\n\nstatic inline bool\niwl_fw_dbg_trigger_stop_conf_match(struct iwl_fw_runtime *fwrt,\n\t\t\t\t   struct iwl_fw_dbg_trigger_tlv *trig)\n{\n\treturn ((trig->mode & IWL_FW_DBG_TRIGGER_STOP) &&\n\t\t(fwrt->dump.conf == FW_DBG_INVALID ||\n\t\t(BIT(fwrt->dump.conf) & le32_to_cpu(trig->stop_conf_ids))));\n}\n\nstatic inline bool\niwl_fw_dbg_no_trig_window(struct iwl_fw_runtime *fwrt, u32 id, u32 dis_usec)\n{\n\tunsigned long wind_jiff = usecs_to_jiffies(dis_usec);\n\n\t \n\tif (fwrt->dump.non_collect_ts_start[id] &&\n\t    (time_after(fwrt->dump.non_collect_ts_start[id] + wind_jiff,\n\t\t\tjiffies)))\n\t\treturn true;\n\n\tfwrt->dump.non_collect_ts_start[id] = jiffies;\n\treturn false;\n}\n\nstatic inline bool\niwl_fw_dbg_trigger_check_stop(struct iwl_fw_runtime *fwrt,\n\t\t\t      struct wireless_dev *wdev,\n\t\t\t      struct iwl_fw_dbg_trigger_tlv *trig)\n{\n\tu32 usec = le16_to_cpu(trig->trig_dis_ms) * USEC_PER_MSEC;\n\n\tif (wdev && !iwl_fw_dbg_trigger_vif_match(trig, wdev))\n\t\treturn false;\n\n\tif (iwl_fw_dbg_no_trig_window(fwrt, le32_to_cpu(trig->id), usec)) {\n\t\tIWL_WARN(fwrt, \"Trigger %d occurred while no-collect window.\\n\",\n\t\t\t trig->id);\n\t\treturn false;\n\t}\n\n\treturn iwl_fw_dbg_trigger_stop_conf_match(fwrt, trig);\n}\n\nstatic inline struct iwl_fw_dbg_trigger_tlv*\n_iwl_fw_dbg_trigger_on(struct iwl_fw_runtime *fwrt,\n\t\t       struct wireless_dev *wdev,\n\t\t       const enum iwl_fw_dbg_trigger id)\n{\n\tstruct iwl_fw_dbg_trigger_tlv *trig;\n\n\tif (iwl_trans_dbg_ini_valid(fwrt->trans))\n\t\treturn NULL;\n\n\tif (!iwl_fw_dbg_trigger_enabled(fwrt->fw, id))\n\t\treturn NULL;\n\n\ttrig = _iwl_fw_dbg_get_trigger(fwrt->fw, id);\n\n\tif (!iwl_fw_dbg_trigger_check_stop(fwrt, wdev, trig))\n\t\treturn NULL;\n\n\treturn trig;\n}\n\n#define iwl_fw_dbg_trigger_on(fwrt, wdev, id) ({\t\t\\\n\tBUILD_BUG_ON(!__builtin_constant_p(id));\t\t\\\n\tBUILD_BUG_ON((id) >= FW_DBG_TRIGGER_MAX);\t\t\\\n\t_iwl_fw_dbg_trigger_on((fwrt), (wdev), (id));\t\t\\\n})\n\nstatic inline void\n_iwl_fw_dbg_trigger_simple_stop(struct iwl_fw_runtime *fwrt,\n\t\t\t\tstruct wireless_dev *wdev,\n\t\t\t\tstruct iwl_fw_dbg_trigger_tlv *trigger)\n{\n\tif (!trigger)\n\t\treturn;\n\n\tif (!iwl_fw_dbg_trigger_check_stop(fwrt, wdev, trigger))\n\t\treturn;\n\n\tiwl_fw_dbg_collect_trig(fwrt, trigger, NULL);\n}\n\n#define iwl_fw_dbg_trigger_simple_stop(fwrt, wdev, trig)\t\\\n\t_iwl_fw_dbg_trigger_simple_stop((fwrt), (wdev),\t\t\\\n\t\t\t\t\tiwl_fw_dbg_get_trigger((fwrt)->fw,\\\n\t\t\t\t\t\t\t       (trig)))\nvoid iwl_fw_dbg_stop_restart_recording(struct iwl_fw_runtime *fwrt,\n\t\t\t\t       struct iwl_fw_dbg_params *params,\n\t\t\t\t       bool stop);\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\nstatic inline void iwl_fw_set_dbg_rec_on(struct iwl_fw_runtime *fwrt)\n{\n\tif (fwrt->cur_fw_img == IWL_UCODE_REGULAR &&\n\t    (fwrt->fw->dbg.dest_tlv ||\n\t     fwrt->trans->dbg.ini_dest != IWL_FW_INI_LOCATION_INVALID))\n\t\tfwrt->trans->dbg.rec_on = true;\n}\n#endif\n\nstatic inline void iwl_fw_dump_conf_clear(struct iwl_fw_runtime *fwrt)\n{\n\tfwrt->dump.conf = FW_DBG_INVALID;\n}\n\nvoid iwl_fw_error_dump_wk(struct work_struct *work);\n\nstatic inline bool iwl_fw_dbg_type_on(struct iwl_fw_runtime *fwrt, u32 type)\n{\n\treturn (fwrt->fw->dbg.dump_mask & BIT(type));\n}\n\nstatic inline bool iwl_fw_dbg_is_d3_debug_enabled(struct iwl_fw_runtime *fwrt)\n{\n\treturn fw_has_capa(&fwrt->fw->ucode_capa,\n\t\t\t   IWL_UCODE_TLV_CAPA_D3_DEBUG) &&\n\t\tfwrt->trans->cfg->d3_debug_data_length && fwrt->ops &&\n\t\tfwrt->ops->d3_debug_enable &&\n\t\tfwrt->ops->d3_debug_enable(fwrt->ops_ctx) &&\n\t\tiwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_D3_DEBUG_DATA);\n}\n\nstatic inline bool iwl_fw_dbg_is_paging_enabled(struct iwl_fw_runtime *fwrt)\n{\n\treturn iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_PAGING) &&\n\t\t!fwrt->trans->trans_cfg->gen2 &&\n\t\tfwrt->cur_fw_img < IWL_UCODE_TYPE_MAX &&\n\t\tfwrt->fw->img[fwrt->cur_fw_img].paging_mem_size &&\n\t\tfwrt->fw_paging_db[0].fw_paging_block;\n}\n\nvoid iwl_fw_dbg_read_d3_debug_data(struct iwl_fw_runtime *fwrt);\n\nstatic inline void iwl_fw_flush_dumps(struct iwl_fw_runtime *fwrt)\n{\n\tint i;\n\n\tiwl_dbg_tlv_del_timers(fwrt->trans);\n\tfor (i = 0; i < IWL_FW_RUNTIME_DUMP_WK_NUM; i++)\n\t\tflush_delayed_work(&fwrt->dump.wks[i].wk);\n}\n\nint iwl_fw_send_timestamp_marker_cmd(struct iwl_fw_runtime *fwrt);\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\nstatic inline void iwl_fw_cancel_timestamp(struct iwl_fw_runtime *fwrt)\n{\n\tfwrt->timestamp.delay = 0;\n\tcancel_delayed_work_sync(&fwrt->timestamp.wk);\n}\n\nvoid iwl_fw_trigger_timestamp(struct iwl_fw_runtime *fwrt, u32 delay);\n\nstatic inline void iwl_fw_suspend_timestamp(struct iwl_fw_runtime *fwrt)\n{\n\tcancel_delayed_work_sync(&fwrt->timestamp.wk);\n}\n\nstatic inline void iwl_fw_resume_timestamp(struct iwl_fw_runtime *fwrt)\n{\n\tif (!fwrt->timestamp.delay)\n\t\treturn;\n\n\tschedule_delayed_work(&fwrt->timestamp.wk,\n\t\t\t      round_jiffies_relative(fwrt->timestamp.delay));\n}\n\n#else\n\nstatic inline void iwl_fw_cancel_timestamp(struct iwl_fw_runtime *fwrt) {}\n\nstatic inline void iwl_fw_trigger_timestamp(struct iwl_fw_runtime *fwrt,\n\t\t\t\t\t    u32 delay) {}\n\nstatic inline void iwl_fw_suspend_timestamp(struct iwl_fw_runtime *fwrt) {}\n\nstatic inline void iwl_fw_resume_timestamp(struct iwl_fw_runtime *fwrt) {}\n\n#endif  \n\nvoid iwl_fw_dbg_stop_sync(struct iwl_fw_runtime *fwrt);\n\nstatic inline void iwl_fw_lmac1_set_alive_err_table(struct iwl_trans *trans,\n\t\t\t\t\t\t    u32 lmac_error_event_table)\n{\n\tif (!(trans->dbg.error_event_table_tlv_status &\n\t      IWL_ERROR_EVENT_TABLE_LMAC1) ||\n\t    WARN_ON(trans->dbg.lmac_error_event_table[0] !=\n\t\t    lmac_error_event_table))\n\t\ttrans->dbg.lmac_error_event_table[0] = lmac_error_event_table;\n}\n\nstatic inline void iwl_fw_umac_set_alive_err_table(struct iwl_trans *trans,\n\t\t\t\t\t\t   u32 umac_error_event_table)\n{\n\tif (!(trans->dbg.error_event_table_tlv_status &\n\t      IWL_ERROR_EVENT_TABLE_UMAC) ||\n\t    WARN_ON(trans->dbg.umac_error_event_table !=\n\t\t    umac_error_event_table))\n\t\ttrans->dbg.umac_error_event_table = umac_error_event_table;\n}\n\nstatic inline void iwl_fw_error_collect(struct iwl_fw_runtime *fwrt, bool sync)\n{\n\tenum iwl_fw_ini_time_point tp_id;\n\n\tif (!iwl_trans_dbg_ini_valid(fwrt->trans)) {\n\t\tiwl_fw_dbg_collect_desc(fwrt, &iwl_dump_desc_assert, false, 0);\n\t\treturn;\n\t}\n\n\tif (fwrt->trans->dbg.hw_error) {\n\t\ttp_id = IWL_FW_INI_TIME_POINT_FW_HW_ERROR;\n\t\tfwrt->trans->dbg.hw_error = false;\n\t} else {\n\t\ttp_id = IWL_FW_INI_TIME_POINT_FW_ASSERT;\n\t}\n\n\t_iwl_dbg_tlv_time_point(fwrt, tp_id, NULL, sync);\n}\n\nvoid iwl_fw_error_print_fseq_regs(struct iwl_fw_runtime *fwrt);\n\nstatic inline void iwl_fwrt_update_fw_versions(struct iwl_fw_runtime *fwrt,\n\t\t\t\t\t       struct iwl_lmac_alive *lmac,\n\t\t\t\t\t       struct iwl_umac_alive *umac)\n{\n\tif (lmac) {\n\t\tfwrt->dump.fw_ver.type = lmac->ver_type;\n\t\tfwrt->dump.fw_ver.subtype = lmac->ver_subtype;\n\t\tfwrt->dump.fw_ver.lmac_major = le32_to_cpu(lmac->ucode_major);\n\t\tfwrt->dump.fw_ver.lmac_minor = le32_to_cpu(lmac->ucode_minor);\n\t}\n\n\tif (umac) {\n\t\tfwrt->dump.fw_ver.umac_major = le32_to_cpu(umac->umac_major);\n\t\tfwrt->dump.fw_ver.umac_minor = le32_to_cpu(umac->umac_minor);\n\t}\n}\n\nvoid iwl_fwrt_dump_error_logs(struct iwl_fw_runtime *fwrt);\nvoid iwl_send_dbg_dump_complete_cmd(struct iwl_fw_runtime *fwrt,\n\t\t\t\t    u32 timepoint,\n\t\t\t\t    u32 timepoint_data);\n\n#define IWL_FW_CHECK_FAILED(_obj, _fmt, ...)\t\t\t\t\\\n\tIWL_ERR_LIMIT(_obj, _fmt, __VA_ARGS__)\n\n#define IWL_FW_CHECK(_obj, _cond, _fmt, ...)\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tbool __cond = (_cond);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tif (unlikely(__cond))\t\t\t\t\t\\\n\t\t\tIWL_FW_CHECK_FAILED(_obj, _fmt, __VA_ARGS__);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tunlikely(__cond);\t\t\t\t\t\\\n\t})\n\n#endif   \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}