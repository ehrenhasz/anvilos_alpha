{
  "module_name": "location.h",
  "hash_id": "89adc20c93b6d47527bfbca694af8a40f033b81d89e3ccc690291da631e72973",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/fw/api/location.h",
  "human_readable_source": " \n \n#ifndef __iwl_fw_api_location_h__\n#define __iwl_fw_api_location_h__\n\n \nenum iwl_location_subcmd_ids {\n\t \n\tTOF_RANGE_REQ_CMD = 0x0,\n\t \n\tTOF_CONFIG_CMD = 0x1,\n\t \n\tTOF_RANGE_ABORT_CMD = 0x2,\n\t \n\tTOF_RANGE_REQ_EXT_CMD = 0x3,\n\t \n\tTOF_RESPONDER_CONFIG_CMD = 0x4,\n\t \n\tTOF_RESPONDER_DYN_CONFIG_CMD = 0x5,\n\t \n\tCSI_HEADER_NOTIFICATION = 0xFA,\n\t \n\tCSI_CHUNKS_NOTIFICATION = 0xFB,\n\t \n\tTOF_LC_NOTIF = 0xFC,\n\t \n\tTOF_RESPONDER_STATS = 0xFD,\n\t \n\tTOF_MCSI_DEBUG_NOTIF = 0xFE,\n\t \n\tTOF_RANGE_RESPONSE_NOTIF = 0xFF,\n};\n\n \nstruct iwl_tof_config_cmd {\n\tu8 tof_disabled;\n\tu8 one_sided_disabled;\n\tu8 is_debug_mode;\n\tu8 is_buf_required;\n} __packed;\n\n \nenum iwl_tof_bandwidth {\n\tIWL_TOF_BW_20_LEGACY,\n\tIWL_TOF_BW_20_HT,\n\tIWL_TOF_BW_40,\n\tIWL_TOF_BW_80,\n\tIWL_TOF_BW_160,\n\tIWL_TOF_BW_NUM,\n};  \n\n \nenum iwl_tof_algo_type {\n\tIWL_TOF_ALGO_TYPE_MAX_LIKE\t= 0,\n\tIWL_TOF_ALGO_TYPE_LINEAR_REG\t= 1,\n\tIWL_TOF_ALGO_TYPE_FFT\t\t= 2,\n\n\t \n\tIWL_TOF_ALGO_TYPE_INVALID,\n};  \n\n \nenum iwl_tof_mcsi_enable {\n\tIWL_TOF_MCSI_DISABLED = 0,\n\tIWL_TOF_MCSI_ENABLED = 1,\n};  \n\n \nenum iwl_tof_responder_cmd_valid_field {\n\tIWL_TOF_RESPONDER_CMD_VALID_CHAN_INFO = BIT(0),\n\tIWL_TOF_RESPONDER_CMD_VALID_TOA_OFFSET = BIT(1),\n\tIWL_TOF_RESPONDER_CMD_VALID_COMMON_CALIB = BIT(2),\n\tIWL_TOF_RESPONDER_CMD_VALID_SPECIFIC_CALIB = BIT(3),\n\tIWL_TOF_RESPONDER_CMD_VALID_BSSID = BIT(4),\n\tIWL_TOF_RESPONDER_CMD_VALID_TX_ANT = BIT(5),\n\tIWL_TOF_RESPONDER_CMD_VALID_ALGO_TYPE = BIT(6),\n\tIWL_TOF_RESPONDER_CMD_VALID_NON_ASAP_SUPPORT = BIT(7),\n\tIWL_TOF_RESPONDER_CMD_VALID_STATISTICS_REPORT_SUPPORT = BIT(8),\n\tIWL_TOF_RESPONDER_CMD_VALID_MCSI_NOTIF_SUPPORT = BIT(9),\n\tIWL_TOF_RESPONDER_CMD_VALID_FAST_ALGO_SUPPORT = BIT(10),\n\tIWL_TOF_RESPONDER_CMD_VALID_RETRY_ON_ALGO_FAIL = BIT(11),\n\tIWL_TOF_RESPONDER_CMD_VALID_STA_ID = BIT(12),\n\tIWL_TOF_RESPONDER_CMD_VALID_NDP_SUPPORT = BIT(22),\n\tIWL_TOF_RESPONDER_CMD_VALID_NDP_PARAMS = BIT(23),\n\tIWL_TOF_RESPONDER_CMD_VALID_LMR_FEEDBACK = BIT(24),\n\tIWL_TOF_RESPONDER_CMD_VALID_SESSION_ID = BIT(25),\n\tIWL_TOF_RESPONDER_CMD_VALID_BSS_COLOR = BIT(26),\n\tIWL_TOF_RESPONDER_CMD_VALID_MIN_MAX_TIME_BETWEEN_MSR = BIT(27),\n};\n\n \nenum iwl_tof_responder_cfg_flags {\n\tIWL_TOF_RESPONDER_FLAGS_NON_ASAP_SUPPORT = BIT(0),\n\tIWL_TOF_RESPONDER_FLAGS_REPORT_STATISTICS = BIT(1),\n\tIWL_TOF_RESPONDER_FLAGS_REPORT_MCSI = BIT(2),\n\tIWL_TOF_RESPONDER_FLAGS_ALGO_TYPE = BIT(3) | BIT(4) | BIT(5),\n\tIWL_TOF_RESPONDER_FLAGS_TOA_OFFSET_MODE = BIT(6),\n\tIWL_TOF_RESPONDER_FLAGS_COMMON_CALIB_MODE = BIT(7),\n\tIWL_TOF_RESPONDER_FLAGS_SPECIFIC_CALIB_MODE = BIT(8),\n\tIWL_TOF_RESPONDER_FLAGS_FAST_ALGO_SUPPORT = BIT(9),\n\tIWL_TOF_RESPONDER_FLAGS_RETRY_ON_ALGO_FAIL = BIT(10),\n\tIWL_TOF_RESPONDER_FLAGS_FTM_TX_ANT = RATE_MCS_ANT_AB_MSK,\n\tIWL_TOF_RESPONDER_FLAGS_NDP_SUPPORT = BIT(24),\n\tIWL_TOF_RESPONDER_FLAGS_LMR_FEEDBACK = BIT(25),\n\tIWL_TOF_RESPONDER_FLAGS_SESSION_ID = BIT(27),\n};\n\n \nstruct iwl_tof_responder_config_cmd_v6 {\n\t__le32 cmd_valid_fields;\n\t__le32 responder_cfg_flags;\n\tu8 bandwidth;\n\tu8 rate;\n\tu8 channel_num;\n\tu8 ctrl_ch_position;\n\tu8 sta_id;\n\tu8 reserved1;\n\t__le16 toa_offset;\n\t__le16 common_calib;\n\t__le16 specific_calib;\n\tu8 bssid[ETH_ALEN];\n\t__le16 reserved2;\n} __packed;  \n\n \nstruct iwl_tof_responder_config_cmd_v7 {\n\t__le32 cmd_valid_fields;\n\t__le32 responder_cfg_flags;\n\tu8 format_bw;\n\tu8 rate;\n\tu8 channel_num;\n\tu8 ctrl_ch_position;\n\tu8 sta_id;\n\tu8 reserved1;\n\t__le16 toa_offset;\n\t__le16 common_calib;\n\t__le16 specific_calib;\n\tu8 bssid[ETH_ALEN];\n\t__le16 reserved2;\n} __packed;  \n\n#define IWL_RESPONDER_STS_POS\t3\n#define IWL_RESPONDER_TOTAL_LTF_POS\t6\n\n \nstruct iwl_tof_responder_config_cmd_v8 {\n\t__le32 cmd_valid_fields;\n\t__le32 responder_cfg_flags;\n\tu8 format_bw;\n\tu8 rate;\n\tu8 channel_num;\n\tu8 ctrl_ch_position;\n\tu8 sta_id;\n\tu8 reserved1;\n\t__le16 toa_offset;\n\t__le16 common_calib;\n\t__le16 specific_calib;\n\tu8 bssid[ETH_ALEN];\n\tu8 r2i_ndp_params;\n\tu8 i2r_ndp_params;\n} __packed;  \n\n \nstruct iwl_tof_responder_config_cmd_v9 {\n\t__le32 cmd_valid_fields;\n\t__le32 responder_cfg_flags;\n\tu8 format_bw;\n\tu8 bss_color;\n\tu8 channel_num;\n\tu8 ctrl_ch_position;\n\tu8 sta_id;\n\tu8 reserved1;\n\t__le16 toa_offset;\n\t__le16 common_calib;\n\t__le16 specific_calib;\n\tu8 bssid[ETH_ALEN];\n\tu8 r2i_ndp_params;\n\tu8 i2r_ndp_params;\n\t__le16 min_time_between_msr;\n\t__le16 max_time_between_msr;\n} __packed;  \n\n#define IWL_LCI_CIVIC_IE_MAX_SIZE\t400\n\n \nstruct iwl_tof_responder_dyn_config_cmd_v2 {\n\t__le32 lci_len;\n\t__le32 civic_len;\n\tu8 lci_civic[];\n} __packed;  \n\n#define IWL_LCI_MAX_SIZE\t160\n#define IWL_CIVIC_MAX_SIZE\t160\n#define HLTK_11AZ_LEN\t32\n\n \nenum iwl_responder_dyn_cfg_valid_flags {\n\tIWL_RESPONDER_DYN_CFG_VALID_LCI = BIT(0),\n\tIWL_RESPONDER_DYN_CFG_VALID_CIVIC = BIT(1),\n\tIWL_RESPONDER_DYN_CFG_VALID_PASN_STA = BIT(2),\n};\n\n \nstruct iwl_tof_responder_dyn_config_cmd {\n\tu8 cipher;\n\tu8 valid_flags;\n\tu8 lci_len;\n\tu8 civic_len;\n\tu8 lci_buf[IWL_LCI_MAX_SIZE];\n\tu8 civic_buf[IWL_LCI_MAX_SIZE];\n\tu8 hltk_buf[HLTK_11AZ_LEN];\n\tu8 addr[ETH_ALEN];\n\tu8 reserved[2];\n} __packed;  \n\n \nstruct iwl_tof_range_req_ext_cmd {\n\t__le16 tsf_timer_offset_msec;\n\t__le16 reserved;\n\tu8 min_delta_ftm;\n\tu8 ftm_format_and_bw20M;\n\tu8 ftm_format_and_bw40M;\n\tu8 ftm_format_and_bw80M;\n} __packed;\n\n \nenum iwl_tof_location_query {\n\tIWL_TOF_LOC_LCI = 0x01,\n\tIWL_TOF_LOC_CIVIC = 0x02,\n};\n\n  \nstruct iwl_tof_range_req_ap_entry_v2 {\n\tu8 channel_num;\n\tu8 bandwidth;\n\tu8 tsf_delta_direction;\n\tu8 ctrl_ch_position;\n\tu8 bssid[ETH_ALEN];\n\tu8 measure_type;\n\tu8 num_of_bursts;\n\t__le16 burst_period;\n\tu8 samples_per_burst;\n\tu8 retries_per_sample;\n\t__le32 tsf_delta;\n\tu8 location_req;\n\tu8 asap_mode;\n\tu8 enable_dyn_ack;\n\ts8 rssi;\n\tu8 algo_type;\n\tu8 notify_mcsi;\n\t__le16 reserved;\n} __packed;  \n\n \nenum iwl_initiator_ap_flags {\n\tIWL_INITIATOR_AP_FLAGS_ASAP = BIT(1),\n\tIWL_INITIATOR_AP_FLAGS_LCI_REQUEST = BIT(2),\n\tIWL_INITIATOR_AP_FLAGS_CIVIC_REQUEST = BIT(3),\n\tIWL_INITIATOR_AP_FLAGS_DYN_ACK = BIT(4),\n\tIWL_INITIATOR_AP_FLAGS_ALGO_LR = BIT(5),\n\tIWL_INITIATOR_AP_FLAGS_ALGO_FFT = BIT(6),\n\tIWL_INITIATOR_AP_FLAGS_MCSI_REPORT = BIT(8),\n\tIWL_INITIATOR_AP_FLAGS_NON_TB = BIT(9),\n\tIWL_INITIATOR_AP_FLAGS_TB = BIT(10),\n\tIWL_INITIATOR_AP_FLAGS_SECURED = BIT(11),\n\tIWL_INITIATOR_AP_FLAGS_LMR_FEEDBACK = BIT(12),\n\tIWL_INITIATOR_AP_FLAGS_USE_CALIB = BIT(13),\n\tIWL_INITIATOR_AP_FLAGS_PMF = BIT(14),\n\tIWL_INITIATOR_AP_FLAGS_TERMINATE_ON_LMR_FEEDBACK = BIT(15),\n};\n\n \nstruct iwl_tof_range_req_ap_entry_v3 {\n\t__le32 initiator_ap_flags;\n\tu8 channel_num;\n\tu8 bandwidth;\n\tu8 ctrl_ch_position;\n\tu8 ftmr_max_retries;\n\tu8 bssid[ETH_ALEN];\n\t__le16 burst_period;\n\tu8 samples_per_burst;\n\tu8 num_of_bursts;\n\t__le16 reserved;\n\t__le32 tsf_delta;\n} __packed;  \n\n \nenum iwl_location_frame_format {\n\tIWL_LOCATION_FRAME_FORMAT_LEGACY,\n\tIWL_LOCATION_FRAME_FORMAT_HT,\n\tIWL_LOCATION_FRAME_FORMAT_VHT,\n\tIWL_LOCATION_FRAME_FORMAT_HE,\n};\n\n \nenum iwl_location_bw {\n\tIWL_LOCATION_BW_20MHZ,\n\tIWL_LOCATION_BW_40MHZ,\n\tIWL_LOCATION_BW_80MHZ,\n\tIWL_LOCATION_BW_160MHZ,\n};\n\n#define TK_11AZ_LEN\t32\n\n#define LOCATION_BW_POS\t4\n\n \nstruct iwl_tof_range_req_ap_entry_v4 {\n\t__le32 initiator_ap_flags;\n\tu8 channel_num;\n\tu8 format_bw;\n\tu8 ctrl_ch_position;\n\tu8 ftmr_max_retries;\n\tu8 bssid[ETH_ALEN];\n\t__le16 burst_period;\n\tu8 samples_per_burst;\n\tu8 num_of_bursts;\n\t__le16 reserved;\n\tu8 hltk[HLTK_11AZ_LEN];\n\tu8 tk[TK_11AZ_LEN];\n} __packed;  \n\n \nenum iwl_location_cipher {\n\tIWL_LOCATION_CIPHER_CCMP_128,\n\tIWL_LOCATION_CIPHER_GCMP_128,\n\tIWL_LOCATION_CIPHER_GCMP_256,\n\tIWL_LOCATION_CIPHER_INVALID,\n\tIWL_LOCATION_CIPHER_MAX,\n};\n\n \nstruct iwl_tof_range_req_ap_entry_v6 {\n\t__le32 initiator_ap_flags;\n\tu8 channel_num;\n\tu8 format_bw;\n\tu8 ctrl_ch_position;\n\tu8 ftmr_max_retries;\n\tu8 bssid[ETH_ALEN];\n\t__le16 burst_period;\n\tu8 samples_per_burst;\n\tu8 num_of_bursts;\n\tu8 sta_id;\n\tu8 cipher;\n\tu8 hltk[HLTK_11AZ_LEN];\n\tu8 tk[TK_11AZ_LEN];\n\t__le16 calib[IWL_TOF_BW_NUM];\n\t__le16 beacon_interval;\n} __packed;  \n\n \nstruct iwl_tof_range_req_ap_entry_v7 {\n\t__le32 initiator_ap_flags;\n\tu8 channel_num;\n\tu8 format_bw;\n\tu8 ctrl_ch_position;\n\tu8 ftmr_max_retries;\n\tu8 bssid[ETH_ALEN];\n\t__le16 burst_period;\n\tu8 samples_per_burst;\n\tu8 num_of_bursts;\n\tu8 sta_id;\n\tu8 cipher;\n\tu8 hltk[HLTK_11AZ_LEN];\n\tu8 tk[TK_11AZ_LEN];\n\t__le16 calib[IWL_TOF_BW_NUM];\n\t__le16 beacon_interval;\n\tu8 rx_pn[IEEE80211_CCMP_PN_LEN];\n\tu8 tx_pn[IEEE80211_CCMP_PN_LEN];\n} __packed;  \n\n#define IWL_LOCATION_MAX_STS_POS\t3\n\n \nstruct iwl_tof_range_req_ap_entry_v8 {\n\t__le32 initiator_ap_flags;\n\tu8 channel_num;\n\tu8 format_bw;\n\tu8 ctrl_ch_position;\n\tu8 ftmr_max_retries;\n\tu8 bssid[ETH_ALEN];\n\t__le16 burst_period;\n\tu8 samples_per_burst;\n\tu8 num_of_bursts;\n\tu8 sta_id;\n\tu8 cipher;\n\tu8 hltk[HLTK_11AZ_LEN];\n\tu8 tk[TK_11AZ_LEN];\n\t__le16 calib[IWL_TOF_BW_NUM];\n\t__le16 beacon_interval;\n\tu8 rx_pn[IEEE80211_CCMP_PN_LEN];\n\tu8 tx_pn[IEEE80211_CCMP_PN_LEN];\n\tu8 r2i_ndp_params;\n\tu8 i2r_ndp_params;\n\tu8 r2i_max_total_ltf;\n\tu8 i2r_max_total_ltf;\n} __packed;  \n\n \nstruct iwl_tof_range_req_ap_entry_v9 {\n\t__le32 initiator_ap_flags;\n\tu8 channel_num;\n\tu8 format_bw;\n\tu8 ctrl_ch_position;\n\tu8 ftmr_max_retries;\n\tu8 bssid[ETH_ALEN];\n\t__le16 burst_period;\n\tu8 samples_per_burst;\n\tu8 num_of_bursts;\n\tu8 sta_id;\n\tu8 cipher;\n\tu8 hltk[HLTK_11AZ_LEN];\n\tu8 tk[TK_11AZ_LEN];\n\t__le16 calib[IWL_TOF_BW_NUM];\n\tu16 beacon_interval;\n\tu8 rx_pn[IEEE80211_CCMP_PN_LEN];\n\tu8 tx_pn[IEEE80211_CCMP_PN_LEN];\n\tu8 r2i_ndp_params;\n\tu8 i2r_ndp_params;\n\tu8 r2i_max_total_ltf;\n\tu8 i2r_max_total_ltf;\n\tu8 bss_color;\n\tu8 band;\n\t__le16 min_time_between_msr;\n} __packed;  \n\n \nenum iwl_tof_response_mode {\n\tIWL_MVM_TOF_RESPONSE_ASAP,\n\tIWL_MVM_TOF_RESPONSE_TIMEOUT,\n\tIWL_MVM_TOF_RESPONSE_COMPLETE,\n};\n\n \nenum iwl_tof_initiator_flags {\n\tIWL_TOF_INITIATOR_FLAGS_FAST_ALGO_DISABLED = BIT(0),\n\tIWL_TOF_INITIATOR_FLAGS_RX_CHAIN_SEL_A = BIT(1),\n\tIWL_TOF_INITIATOR_FLAGS_RX_CHAIN_SEL_B = BIT(2),\n\tIWL_TOF_INITIATOR_FLAGS_RX_CHAIN_SEL_C = BIT(3),\n\tIWL_TOF_INITIATOR_FLAGS_TX_CHAIN_SEL_A = BIT(4),\n\tIWL_TOF_INITIATOR_FLAGS_TX_CHAIN_SEL_B = BIT(5),\n\tIWL_TOF_INITIATOR_FLAGS_TX_CHAIN_SEL_C = BIT(6),\n\tIWL_TOF_INITIATOR_FLAGS_MACADDR_RANDOM = BIT(7),\n\tIWL_TOF_INITIATOR_FLAGS_SPECIFIC_CALIB = BIT(15),\n\tIWL_TOF_INITIATOR_FLAGS_COMMON_CALIB   = BIT(16),\n\tIWL_TOF_INITIATOR_FLAGS_NON_ASAP_SUPPORT = BIT(20),\n};  \n\n#define IWL_MVM_TOF_MAX_APS 5\n#define IWL_MVM_TOF_MAX_TWO_SIDED_APS 5\n\n \nstruct iwl_tof_range_req_cmd_v5 {\n\t__le32 initiator_flags;\n\tu8 request_id;\n\tu8 initiator;\n\tu8 one_sided_los_disable;\n\tu8 req_timeout;\n\tu8 report_policy;\n\tu8 reserved0;\n\tu8 num_of_ap;\n\tu8 macaddr_random;\n\tu8 range_req_bssid[ETH_ALEN];\n\tu8 macaddr_template[ETH_ALEN];\n\tu8 macaddr_mask[ETH_ALEN];\n\tu8 ftm_rx_chains;\n\tu8 ftm_tx_chains;\n\t__le16 common_calib;\n\t__le16 specific_calib;\n\tstruct iwl_tof_range_req_ap_entry_v2 ap[IWL_MVM_TOF_MAX_APS];\n} __packed;\n \n\n \nstruct iwl_tof_range_req_cmd_v7 {\n\t__le32 initiator_flags;\n\tu8 request_id;\n\tu8 num_of_ap;\n\tu8 range_req_bssid[ETH_ALEN];\n\tu8 macaddr_mask[ETH_ALEN];\n\tu8 macaddr_template[ETH_ALEN];\n\t__le32 req_timeout_ms;\n\t__le32 tsf_mac_id;\n\t__le16 common_calib;\n\t__le16 specific_calib;\n\tstruct iwl_tof_range_req_ap_entry_v3 ap[IWL_MVM_TOF_MAX_APS];\n} __packed;  \n\n \nstruct iwl_tof_range_req_cmd_v8 {\n\t__le32 initiator_flags;\n\tu8 request_id;\n\tu8 num_of_ap;\n\tu8 range_req_bssid[ETH_ALEN];\n\tu8 macaddr_mask[ETH_ALEN];\n\tu8 macaddr_template[ETH_ALEN];\n\t__le32 req_timeout_ms;\n\t__le32 tsf_mac_id;\n\t__le16 common_calib;\n\t__le16 specific_calib;\n\tstruct iwl_tof_range_req_ap_entry_v4 ap[IWL_MVM_TOF_MAX_APS];\n} __packed;  \n\n \nstruct iwl_tof_range_req_cmd_v9 {\n\t__le32 initiator_flags;\n\tu8 request_id;\n\tu8 num_of_ap;\n\tu8 range_req_bssid[ETH_ALEN];\n\tu8 macaddr_mask[ETH_ALEN];\n\tu8 macaddr_template[ETH_ALEN];\n\t__le32 req_timeout_ms;\n\t__le32 tsf_mac_id;\n\tstruct iwl_tof_range_req_ap_entry_v6 ap[IWL_MVM_TOF_MAX_APS];\n} __packed;  \n\n \nstruct iwl_tof_range_req_cmd_v11 {\n\t__le32 initiator_flags;\n\tu8 request_id;\n\tu8 num_of_ap;\n\tu8 range_req_bssid[ETH_ALEN];\n\tu8 macaddr_mask[ETH_ALEN];\n\tu8 macaddr_template[ETH_ALEN];\n\t__le32 req_timeout_ms;\n\t__le32 tsf_mac_id;\n\tstruct iwl_tof_range_req_ap_entry_v7 ap[IWL_MVM_TOF_MAX_APS];\n} __packed;  \n\n \nstruct iwl_tof_range_req_cmd_v12 {\n\t__le32 initiator_flags;\n\tu8 request_id;\n\tu8 num_of_ap;\n\tu8 range_req_bssid[ETH_ALEN];\n\tu8 macaddr_mask[ETH_ALEN];\n\tu8 macaddr_template[ETH_ALEN];\n\t__le32 req_timeout_ms;\n\t__le32 tsf_mac_id;\n\tstruct iwl_tof_range_req_ap_entry_v8 ap[IWL_MVM_TOF_MAX_APS];\n} __packed;  \n\n \nstruct iwl_tof_range_req_cmd_v13 {\n\t__le32 initiator_flags;\n\tu8 request_id;\n\tu8 num_of_ap;\n\tu8 range_req_bssid[ETH_ALEN];\n\tu8 macaddr_mask[ETH_ALEN];\n\tu8 macaddr_template[ETH_ALEN];\n\t__le32 req_timeout_ms;\n\t__le32 tsf_mac_id;\n\tstruct iwl_tof_range_req_ap_entry_v9 ap[IWL_MVM_TOF_MAX_APS];\n} __packed;  \n\n \nenum iwl_tof_range_request_status {\n\tIWL_TOF_RANGE_REQUEST_STATUS_SUCCESS,\n\tIWL_TOF_RANGE_REQUEST_STATUS_BUSY,\n};\n\n \nenum iwl_tof_entry_status {\n\tIWL_TOF_ENTRY_SUCCESS = 0,\n\tIWL_TOF_ENTRY_GENERAL_FAILURE = 1,\n\tIWL_TOF_ENTRY_NO_RESPONSE = 2,\n\tIWL_TOF_ENTRY_REQUEST_REJECTED = 3,\n\tIWL_TOF_ENTRY_NOT_SCHEDULED = 4,\n\tIWL_TOF_ENTRY_TIMING_MEASURE_TIMEOUT = 5,\n\tIWL_TOF_ENTRY_TARGET_DIFF_CH_CANNOT_CHANGE = 6,\n\tIWL_TOF_ENTRY_RANGE_NOT_SUPPORTED = 7,\n\tIWL_TOF_ENTRY_REQUEST_ABORT_UNKNOWN_REASON = 8,\n\tIWL_TOF_ENTRY_LOCATION_INVALID_T1_T4_TIME_STAMP = 9,\n\tIWL_TOF_ENTRY_11MC_PROTOCOL_FAILURE = 10,\n\tIWL_TOF_ENTRY_REQUEST_CANNOT_SCHED = 11,\n\tIWL_TOF_ENTRY_RESPONDER_CANNOT_COLABORATE = 12,\n\tIWL_TOF_ENTRY_BAD_REQUEST_ARGS = 13,\n\tIWL_TOF_ENTRY_WIFI_NOT_ENABLED = 14,\n\tIWL_TOF_ENTRY_RESPONDER_OVERRIDE_PARAMS = 15,\n};  \n\n \nstruct iwl_tof_range_rsp_ap_entry_ntfy_v3 {\n\tu8 bssid[ETH_ALEN];\n\tu8 measure_status;\n\tu8 measure_bw;\n\t__le32 rtt;\n\t__le32 rtt_variance;\n\t__le32 rtt_spread;\n\ts8 rssi;\n\tu8 rssi_spread;\n\tu8 reserved;\n\tu8 refusal_period;\n\t__le32 range;\n\t__le32 range_variance;\n\t__le32 timestamp;\n\t__le32 t2t3_initiator;\n\t__le32 t1t4_responder;\n\t__le16 common_calib;\n\t__le16 specific_calib;\n\t__le32 papd_calib_output;\n} __packed;  \n\n \nstruct iwl_tof_range_rsp_ap_entry_ntfy_v4 {\n\tu8 bssid[ETH_ALEN];\n\tu8 measure_status;\n\tu8 measure_bw;\n\t__le32 rtt;\n\t__le32 rtt_variance;\n\t__le32 rtt_spread;\n\ts8 rssi;\n\tu8 rssi_spread;\n\tu8 last_burst;\n\tu8 refusal_period;\n\t__le32 timestamp;\n\t__le32 start_tsf;\n\t__le32 rx_rate_n_flags;\n\t__le32 tx_rate_n_flags;\n\t__le32 t2t3_initiator;\n\t__le32 t1t4_responder;\n\t__le16 common_calib;\n\t__le16 specific_calib;\n\t__le32 papd_calib_output;\n} __packed;  \n\n \nstruct iwl_tof_range_rsp_ap_entry_ntfy_v5 {\n\tu8 bssid[ETH_ALEN];\n\tu8 measure_status;\n\tu8 measure_bw;\n\t__le32 rtt;\n\t__le32 rtt_variance;\n\t__le32 rtt_spread;\n\ts8 rssi;\n\tu8 rssi_spread;\n\tu8 last_burst;\n\tu8 refusal_period;\n\t__le32 timestamp;\n\t__le32 start_tsf;\n\t__le32 rx_rate_n_flags;\n\t__le32 tx_rate_n_flags;\n\t__le32 t2t3_initiator;\n\t__le32 t1t4_responder;\n\t__le16 common_calib;\n\t__le16 specific_calib;\n\t__le32 papd_calib_output;\n\tu8 rttConfidence;\n\tu8 reserved[3];\n} __packed;  \n\n \nstruct iwl_tof_range_rsp_ap_entry_ntfy_v6 {\n\tu8 bssid[ETH_ALEN];\n\tu8 measure_status;\n\tu8 measure_bw;\n\t__le32 rtt;\n\t__le32 rtt_variance;\n\t__le32 rtt_spread;\n\ts8 rssi;\n\tu8 rssi_spread;\n\tu8 last_burst;\n\tu8 refusal_period;\n\t__le32 timestamp;\n\t__le32 start_tsf;\n\t__le32 rx_rate_n_flags;\n\t__le32 tx_rate_n_flags;\n\t__le32 t2t3_initiator;\n\t__le32 t1t4_responder;\n\t__le16 common_calib;\n\t__le16 specific_calib;\n\t__le32 papd_calib_output;\n\tu8 rttConfidence;\n\tu8 reserved[3];\n\tu8 rx_pn[IEEE80211_CCMP_PN_LEN];\n\tu8 tx_pn[IEEE80211_CCMP_PN_LEN];\n} __packed;  \n\n\n \nenum iwl_tof_response_status {\n\tIWL_TOF_RESPONSE_SUCCESS = 0,\n\tIWL_TOF_RESPONSE_TIMEOUT = 1,\n\tIWL_TOF_RESPONSE_ABORTED = 4,\n\tIWL_TOF_RESPONSE_FAILED  = 5,\n};  \n\n \nstruct iwl_tof_range_rsp_ntfy_v5 {\n\tu8 request_id;\n\tu8 request_status;\n\tu8 last_in_batch;\n\tu8 num_of_aps;\n\tstruct iwl_tof_range_rsp_ap_entry_ntfy_v3 ap[IWL_MVM_TOF_MAX_APS];\n} __packed;  \n\n \nstruct iwl_tof_range_rsp_ntfy_v6 {\n\tu8 request_id;\n\tu8 num_of_aps;\n\tu8 last_report;\n\tu8 reserved;\n\tstruct iwl_tof_range_rsp_ap_entry_ntfy_v4 ap[IWL_MVM_TOF_MAX_APS];\n} __packed;  \n\n \nstruct iwl_tof_range_rsp_ntfy_v7 {\n\tu8 request_id;\n\tu8 num_of_aps;\n\tu8 last_report;\n\tu8 reserved;\n\tstruct iwl_tof_range_rsp_ap_entry_ntfy_v5 ap[IWL_MVM_TOF_MAX_APS];\n} __packed;  \n\n \nstruct iwl_tof_range_rsp_ntfy_v8 {\n\tu8 request_id;\n\tu8 num_of_aps;\n\tu8 last_report;\n\tu8 reserved;\n\tstruct iwl_tof_range_rsp_ap_entry_ntfy_v6 ap[IWL_MVM_TOF_MAX_APS];\n} __packed;  \n\n#define IWL_MVM_TOF_MCSI_BUF_SIZE  (245)\n \nstruct iwl_tof_mcsi_notif {\n\tu8 token;\n\tu8 role;\n\t__le16 reserved;\n\tu8 initiator_bssid[ETH_ALEN];\n\tu8 responder_bssid[ETH_ALEN];\n\tu8 mcsi_buffer[IWL_MVM_TOF_MCSI_BUF_SIZE * 4];\n} __packed;\n\n \nstruct iwl_tof_range_abort_cmd {\n\tu8 request_id;\n\tu8 reserved[3];\n} __packed;\n\nenum ftm_responder_stats_flags {\n\tFTM_RESP_STAT_NON_ASAP_STARTED = BIT(0),\n\tFTM_RESP_STAT_NON_ASAP_IN_WIN = BIT(1),\n\tFTM_RESP_STAT_NON_ASAP_OUT_WIN = BIT(2),\n\tFTM_RESP_STAT_TRIGGER_DUP = BIT(3),\n\tFTM_RESP_STAT_DUP = BIT(4),\n\tFTM_RESP_STAT_DUP_IN_WIN = BIT(5),\n\tFTM_RESP_STAT_DUP_OUT_WIN = BIT(6),\n\tFTM_RESP_STAT_SCHED_SUCCESS = BIT(7),\n\tFTM_RESP_STAT_ASAP_REQ = BIT(8),\n\tFTM_RESP_STAT_NON_ASAP_REQ = BIT(9),\n\tFTM_RESP_STAT_ASAP_RESP = BIT(10),\n\tFTM_RESP_STAT_NON_ASAP_RESP = BIT(11),\n\tFTM_RESP_STAT_FAIL_INITIATOR_INACTIVE = BIT(12),\n\tFTM_RESP_STAT_FAIL_INITIATOR_OUT_WIN = BIT(13),\n\tFTM_RESP_STAT_FAIL_INITIATOR_RETRY_LIM = BIT(14),\n\tFTM_RESP_STAT_FAIL_NEXT_SERVED = BIT(15),\n\tFTM_RESP_STAT_FAIL_TRIGGER_ERR = BIT(16),\n\tFTM_RESP_STAT_FAIL_GC = BIT(17),\n\tFTM_RESP_STAT_SUCCESS = BIT(18),\n\tFTM_RESP_STAT_INTEL_IE = BIT(19),\n\tFTM_RESP_STAT_INITIATOR_ACTIVE = BIT(20),\n\tFTM_RESP_STAT_MEASUREMENTS_AVAILABLE = BIT(21),\n\tFTM_RESP_STAT_TRIGGER_UNKNOWN = BIT(22),\n\tFTM_RESP_STAT_PROCESS_FAIL = BIT(23),\n\tFTM_RESP_STAT_ACK = BIT(24),\n\tFTM_RESP_STAT_NACK = BIT(25),\n\tFTM_RESP_STAT_INVALID_INITIATOR_ID = BIT(26),\n\tFTM_RESP_STAT_TIMER_MIN_DELTA = BIT(27),\n\tFTM_RESP_STAT_INITIATOR_REMOVED = BIT(28),\n\tFTM_RESP_STAT_INITIATOR_ADDED = BIT(29),\n\tFTM_RESP_STAT_ERR_LIST_FULL = BIT(30),\n\tFTM_RESP_STAT_INITIATOR_SCHED_NOW = BIT(31),\n};  \n\n \nstruct iwl_ftm_responder_stats {\n\tu8 addr[ETH_ALEN];\n\tu8 success_ftm;\n\tu8 ftm_per_burst;\n\t__le32 flags;\n\t__le32 duration;\n\t__le32 allocated_duration;\n\tu8 bw;\n\tu8 rate;\n\t__le16 reserved;\n} __packed;  \n\n#define IWL_CSI_MAX_EXPECTED_CHUNKS\t\t16\n\n#define IWL_CSI_CHUNK_CTL_NUM_MASK_VER_1\t0x0003\n#define IWL_CSI_CHUNK_CTL_IDX_MASK_VER_1\t0x000c\n\n#define IWL_CSI_CHUNK_CTL_NUM_MASK_VER_2\t0x00ff\n#define IWL_CSI_CHUNK_CTL_IDX_MASK_VER_2\t0xff00\n\nstruct iwl_csi_chunk_notification {\n\t__le32 token;\n\t__le16 seq;\n\t__le16 ctl;\n\t__le32 size;\n\tu8 data[];\n} __packed;  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}