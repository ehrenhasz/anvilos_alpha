{
  "module_name": "uefi.c",
  "hash_id": "7ae71cb08ece2df3bbe5363f19238e58847ef5152f6685a0cf80be5748c96799",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/fw/uefi.c",
  "human_readable_source": "\n \n\n#include \"iwl-drv.h\"\n#include \"pnvm.h\"\n#include \"iwl-prph.h\"\n#include \"iwl-io.h\"\n\n#include \"fw/uefi.h\"\n#include \"fw/api/alive.h\"\n#include <linux/efi.h>\n#include \"fw/runtime.h\"\n\n#define IWL_EFI_VAR_GUID EFI_GUID(0x92daaf2f, 0xc02b, 0x455b,\t\\\n\t\t\t\t  0xb2, 0xec, 0xf5, 0xa3,\t\\\n\t\t\t\t  0x59, 0x4f, 0x4a, 0xea)\n\nstruct iwl_uefi_pnvm_mem_desc {\n\t__le32 addr;\n\t__le32 size;\n\tconst u8 data[];\n} __packed;\n\nstatic void *iwl_uefi_get_variable(efi_char16_t *name, efi_guid_t *guid,\n\t\t\t\t   unsigned long *data_size)\n{\n\tefi_status_t status;\n\tvoid *data;\n\n\tif (!data_size)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!efi_rt_services_supported(EFI_RT_SUPPORTED_GET_VARIABLE))\n\t\treturn ERR_PTR(-ENODEV);\n\n\t \n\t*data_size = 0;\n\tstatus = efi.get_variable(name, guid, NULL, data_size, NULL);\n\tif (status != EFI_BUFFER_TOO_SMALL || !*data_size)\n\t\treturn ERR_PTR(-EIO);\n\n\tdata = kmalloc(*data_size, GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstatus = efi.get_variable(name, guid, NULL, data_size, data);\n\tif (status != EFI_SUCCESS) {\n\t\tkfree(data);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\treturn data;\n}\n\nvoid *iwl_uefi_get_pnvm(struct iwl_trans *trans, size_t *len)\n{\n\tunsigned long package_size;\n\tvoid *data;\n\n\t*len = 0;\n\n\tdata = iwl_uefi_get_variable(IWL_UEFI_OEM_PNVM_NAME, &IWL_EFI_VAR_GUID,\n\t\t\t\t     &package_size);\n\tif (IS_ERR(data)) {\n\t\tIWL_DEBUG_FW(trans,\n\t\t\t     \"PNVM UEFI variable not found 0x%lx (len %lu)\\n\",\n\t\t\t     PTR_ERR(data), package_size);\n\t\treturn data;\n\t}\n\n\tIWL_DEBUG_FW(trans, \"Read PNVM from UEFI with size %lu\\n\", package_size);\n\t*len = package_size;\n\n\treturn data;\n}\n\nint iwl_uefi_handle_tlv_mem_desc(struct iwl_trans *trans, const u8 *data,\n\t\t\t\t u32 tlv_len, struct iwl_pnvm_image *pnvm_data)\n{\n\tconst struct iwl_uefi_pnvm_mem_desc *desc = (const void *)data;\n\tu32 data_len;\n\n\tif (tlv_len < sizeof(*desc)) {\n\t\tIWL_DEBUG_FW(trans, \"TLV len (%d) is too small\\n\", tlv_len);\n\t\treturn -EINVAL;\n\t}\n\n\tdata_len = tlv_len - sizeof(*desc);\n\n\tIWL_DEBUG_FW(trans,\n\t\t     \"Handle IWL_UCODE_TLV_MEM_DESC, len %d data_len %d\\n\",\n\t\t     tlv_len, data_len);\n\n\tif (le32_to_cpu(desc->size) != data_len) {\n\t\tIWL_DEBUG_FW(trans, \"invalid mem desc size %d\\n\", desc->size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (pnvm_data->n_chunks == IPC_DRAM_MAP_ENTRY_NUM_MAX) {\n\t\tIWL_DEBUG_FW(trans, \"too many payloads to allocate in DRAM.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tIWL_DEBUG_FW(trans, \"Adding data (size %d)\\n\", data_len);\n\n\tpnvm_data->chunks[pnvm_data->n_chunks].data = desc->data;\n\tpnvm_data->chunks[pnvm_data->n_chunks].len = data_len;\n\tpnvm_data->n_chunks++;\n\n\treturn 0;\n}\n\nstatic int iwl_uefi_reduce_power_section(struct iwl_trans *trans,\n\t\t\t\t\t const u8 *data, size_t len,\n\t\t\t\t\t struct iwl_pnvm_image *pnvm_data)\n{\n\tconst struct iwl_ucode_tlv *tlv;\n\n\tIWL_DEBUG_FW(trans, \"Handling REDUCE_POWER section\\n\");\n\tmemset(pnvm_data, 0, sizeof(*pnvm_data));\n\n\twhile (len >= sizeof(*tlv)) {\n\t\tu32 tlv_len, tlv_type;\n\n\t\tlen -= sizeof(*tlv);\n\t\ttlv = (const void *)data;\n\n\t\ttlv_len = le32_to_cpu(tlv->length);\n\t\ttlv_type = le32_to_cpu(tlv->type);\n\n\t\tif (len < tlv_len) {\n\t\t\tIWL_ERR(trans, \"invalid TLV len: %zd/%u\\n\",\n\t\t\t\tlen, tlv_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdata += sizeof(*tlv);\n\n\t\tswitch (tlv_type) {\n\t\tcase IWL_UCODE_TLV_MEM_DESC:\n\t\t\tif (iwl_uefi_handle_tlv_mem_desc(trans, data, tlv_len,\n\t\t\t\t\t\t\t pnvm_data))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_PNVM_SKU:\n\t\t\tIWL_DEBUG_FW(trans,\n\t\t\t\t     \"New REDUCE_POWER section started, stop parsing.\\n\");\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\tIWL_DEBUG_FW(trans, \"Found TLV 0x%0x, len %d\\n\",\n\t\t\t\t     tlv_type, tlv_len);\n\t\t\tbreak;\n\t\t}\n\n\t\tlen -= ALIGN(tlv_len, 4);\n\t\tdata += ALIGN(tlv_len, 4);\n\t}\n\ndone:\n\tif (!pnvm_data->n_chunks) {\n\t\tIWL_DEBUG_FW(trans, \"Empty REDUCE_POWER, skipping.\\n\");\n\t\treturn -ENOENT;\n\t}\n\treturn 0;\n}\n\nint iwl_uefi_reduce_power_parse(struct iwl_trans *trans,\n\t\t\t\tconst u8 *data, size_t len,\n\t\t\t\tstruct iwl_pnvm_image *pnvm_data)\n{\n\tconst struct iwl_ucode_tlv *tlv;\n\n\tIWL_DEBUG_FW(trans, \"Parsing REDUCE_POWER data\\n\");\n\n\twhile (len >= sizeof(*tlv)) {\n\t\tu32 tlv_len, tlv_type;\n\n\t\tlen -= sizeof(*tlv);\n\t\ttlv = (const void *)data;\n\n\t\ttlv_len = le32_to_cpu(tlv->length);\n\t\ttlv_type = le32_to_cpu(tlv->type);\n\n\t\tif (len < tlv_len) {\n\t\t\tIWL_ERR(trans, \"invalid TLV len: %zd/%u\\n\",\n\t\t\t\tlen, tlv_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (tlv_type == IWL_UCODE_TLV_PNVM_SKU) {\n\t\t\tconst struct iwl_sku_id *sku_id =\n\t\t\t\t(const void *)(data + sizeof(*tlv));\n\n\t\t\tIWL_DEBUG_FW(trans,\n\t\t\t\t     \"Got IWL_UCODE_TLV_PNVM_SKU len %d\\n\",\n\t\t\t\t     tlv_len);\n\t\t\tIWL_DEBUG_FW(trans, \"sku_id 0x%0x 0x%0x 0x%0x\\n\",\n\t\t\t\t     le32_to_cpu(sku_id->data[0]),\n\t\t\t\t     le32_to_cpu(sku_id->data[1]),\n\t\t\t\t     le32_to_cpu(sku_id->data[2]));\n\n\t\t\tdata += sizeof(*tlv) + ALIGN(tlv_len, 4);\n\t\t\tlen -= ALIGN(tlv_len, 4);\n\n\t\t\tif (trans->sku_id[0] == le32_to_cpu(sku_id->data[0]) &&\n\t\t\t    trans->sku_id[1] == le32_to_cpu(sku_id->data[1]) &&\n\t\t\t    trans->sku_id[2] == le32_to_cpu(sku_id->data[2])) {\n\t\t\t\tint ret = iwl_uefi_reduce_power_section(trans,\n\t\t\t\t\t\t\t\t    data, len,\n\t\t\t\t\t\t\t\t    pnvm_data);\n\t\t\t\tif (!ret)\n\t\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tIWL_DEBUG_FW(trans, \"SKU ID didn't match!\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tdata += sizeof(*tlv) + ALIGN(tlv_len, 4);\n\t\t\tlen -= ALIGN(tlv_len, 4);\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n\nu8 *iwl_uefi_get_reduced_power(struct iwl_trans *trans, size_t *len)\n{\n\tstruct pnvm_sku_package *package;\n\tunsigned long package_size;\n\tu8 *data;\n\n\tpackage = iwl_uefi_get_variable(IWL_UEFI_REDUCED_POWER_NAME,\n\t\t\t\t\t&IWL_EFI_VAR_GUID, &package_size);\n\n\tif (IS_ERR(package)) {\n\t\tIWL_DEBUG_FW(trans,\n\t\t\t     \"Reduced Power UEFI variable not found 0x%lx (len %lu)\\n\",\n\t\t\t     PTR_ERR(package), package_size);\n\t\treturn ERR_CAST(package);\n\t}\n\n\tif (package_size < sizeof(*package)) {\n\t\tIWL_DEBUG_FW(trans,\n\t\t\t     \"Invalid Reduced Power UEFI variable len (%lu)\\n\",\n\t\t\t     package_size);\n\t\tkfree(package);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tIWL_DEBUG_FW(trans, \"Read reduced power from UEFI with size %lu\\n\",\n\t\t     package_size);\n\n\tIWL_DEBUG_FW(trans, \"rev %d, total_size %d, n_skus %d\\n\",\n\t\t     package->rev, package->total_size, package->n_skus);\n\n\t*len = package_size - sizeof(*package);\n\tdata = kmemdup(package->data, *len, GFP_KERNEL);\n\tif (!data) {\n\t\tkfree(package);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tkfree(package);\n\n\treturn data;\n}\n\nstatic int iwl_uefi_step_parse(struct uefi_cnv_common_step_data *common_step_data,\n\t\t\t       struct iwl_trans *trans)\n{\n\tif (common_step_data->revision != 1)\n\t\treturn -EINVAL;\n\n\ttrans->mbx_addr_0_step = (u32)common_step_data->revision |\n\t\t(u32)common_step_data->cnvi_eq_channel << 8 |\n\t\t(u32)common_step_data->cnvr_eq_channel << 16 |\n\t\t(u32)common_step_data->radio1 << 24;\n\ttrans->mbx_addr_1_step = (u32)common_step_data->radio2;\n\treturn 0;\n}\n\nvoid iwl_uefi_get_step_table(struct iwl_trans *trans)\n{\n\tstruct uefi_cnv_common_step_data *data;\n\tunsigned long package_size;\n\tint ret;\n\n\tif (trans->trans_cfg->device_family < IWL_DEVICE_FAMILY_AX210)\n\t\treturn;\n\n\tdata = iwl_uefi_get_variable(IWL_UEFI_STEP_NAME, &IWL_EFI_VAR_GUID,\n\t\t\t\t     &package_size);\n\n\tif (IS_ERR(data)) {\n\t\tIWL_DEBUG_FW(trans,\n\t\t\t     \"STEP UEFI variable not found 0x%lx\\n\",\n\t\t\t     PTR_ERR(data));\n\t\treturn;\n\t}\n\n\tif (package_size < sizeof(*data)) {\n\t\tIWL_DEBUG_FW(trans,\n\t\t\t     \"Invalid STEP table UEFI variable len (%lu)\\n\",\n\t\t\t     package_size);\n\t\tkfree(data);\n\t\treturn;\n\t}\n\n\tIWL_DEBUG_FW(trans, \"Read STEP from UEFI with size %lu\\n\",\n\t\t     package_size);\n\n\tret = iwl_uefi_step_parse(data, trans);\n\tif (ret < 0)\n\t\tIWL_DEBUG_FW(trans, \"Cannot read STEP tables. rev is invalid\\n\");\n\n\tkfree(data);\n}\nIWL_EXPORT_SYMBOL(iwl_uefi_get_step_table);\n\n#ifdef CONFIG_ACPI\nstatic int iwl_uefi_sgom_parse(struct uefi_cnv_wlan_sgom_data *sgom_data,\n\t\t\t       struct iwl_fw_runtime *fwrt)\n{\n\tint i, j;\n\n\tif (sgom_data->revision != 1)\n\t\treturn -EINVAL;\n\n\tmemcpy(fwrt->sgom_table.offset_map, sgom_data->offset_map,\n\t       sizeof(fwrt->sgom_table.offset_map));\n\n\tfor (i = 0; i < MCC_TO_SAR_OFFSET_TABLE_ROW_SIZE; i++) {\n\t\tfor (j = 0; j < MCC_TO_SAR_OFFSET_TABLE_COL_SIZE; j++) {\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tu8 value = fwrt->sgom_table.offset_map[i][j];\n\t\t\tu8 low = value & 0xF;\n\t\t\tu8 high = (value & 0xF0) >> 4;\n\n\t\t\tif (high > fwrt->geo_num_profiles)\n\t\t\t\thigh = 0;\n\t\t\tif (low > fwrt->geo_num_profiles)\n\t\t\t\tlow = 0;\n\t\t\tfwrt->sgom_table.offset_map[i][j] = (high << 4) | low;\n\t\t}\n\t}\n\n\tfwrt->sgom_enabled = true;\n\treturn 0;\n}\n\nvoid iwl_uefi_get_sgom_table(struct iwl_trans *trans,\n\t\t\t     struct iwl_fw_runtime *fwrt)\n{\n\tstruct uefi_cnv_wlan_sgom_data *data;\n\tunsigned long package_size;\n\tint ret;\n\n\tif (!fwrt->geo_enabled)\n\t\treturn;\n\n\tdata = iwl_uefi_get_variable(IWL_UEFI_SGOM_NAME, &IWL_EFI_VAR_GUID,\n\t\t\t\t     &package_size);\n\tif (IS_ERR(data)) {\n\t\tIWL_DEBUG_FW(trans,\n\t\t\t     \"SGOM UEFI variable not found 0x%lx\\n\",\n\t\t\t     PTR_ERR(data));\n\t\treturn;\n\t}\n\n\tif (package_size < sizeof(*data)) {\n\t\tIWL_DEBUG_FW(trans,\n\t\t\t     \"Invalid SGOM table UEFI variable len (%lu)\\n\",\n\t\t\t     package_size);\n\t\tkfree(data);\n\t\treturn;\n\t}\n\n\tIWL_DEBUG_FW(trans, \"Read SGOM from UEFI with size %lu\\n\",\n\t\t     package_size);\n\n\tret = iwl_uefi_sgom_parse(data, fwrt);\n\tif (ret < 0)\n\t\tIWL_DEBUG_FW(trans, \"Cannot read SGOM tables. rev is invalid\\n\");\n\n\tkfree(data);\n}\nIWL_EXPORT_SYMBOL(iwl_uefi_get_sgom_table);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}