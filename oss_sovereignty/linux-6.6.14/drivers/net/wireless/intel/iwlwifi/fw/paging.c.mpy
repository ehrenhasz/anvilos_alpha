{
  "module_name": "paging.c",
  "hash_id": "31199661d9132293d569bd8c3e1c2f5a73b9598b6b595f855220fae85ae46d24",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/fw/paging.c",
  "human_readable_source": "\n \n#include \"iwl-drv.h\"\n#include \"runtime.h\"\n#include \"fw/api/commands.h\"\n\nvoid iwl_free_fw_paging(struct iwl_fw_runtime *fwrt)\n{\n\tint i;\n\n\tif (!fwrt->fw_paging_db[0].fw_paging_block)\n\t\treturn;\n\n\tfor (i = 0; i < NUM_OF_FW_PAGING_BLOCKS; i++) {\n\t\tstruct iwl_fw_paging *paging = &fwrt->fw_paging_db[i];\n\n\t\tif (!paging->fw_paging_block) {\n\t\t\tIWL_DEBUG_FW(fwrt,\n\t\t\t\t     \"Paging: block %d already freed, continue to next page\\n\",\n\t\t\t\t     i);\n\n\t\t\tcontinue;\n\t\t}\n\t\tdma_unmap_page(fwrt->trans->dev, paging->fw_paging_phys,\n\t\t\t       paging->fw_paging_size, DMA_BIDIRECTIONAL);\n\n\t\t__free_pages(paging->fw_paging_block,\n\t\t\t     get_order(paging->fw_paging_size));\n\t\tpaging->fw_paging_block = NULL;\n\t}\n\n\tmemset(fwrt->fw_paging_db, 0, sizeof(fwrt->fw_paging_db));\n}\nIWL_EXPORT_SYMBOL(iwl_free_fw_paging);\n\nstatic int iwl_alloc_fw_paging_mem(struct iwl_fw_runtime *fwrt,\n\t\t\t\t   const struct fw_img *image)\n{\n\tstruct page *block;\n\tdma_addr_t phys = 0;\n\tint blk_idx, order, num_of_pages, size;\n\n\tif (fwrt->fw_paging_db[0].fw_paging_block)\n\t\treturn 0;\n\n\t \n\tBUILD_BUG_ON(BIT(BLOCK_2_EXP_SIZE) != PAGING_BLOCK_SIZE);\n\n\tnum_of_pages = image->paging_mem_size / FW_PAGING_SIZE;\n\tfwrt->num_of_paging_blk =\n\t\tDIV_ROUND_UP(num_of_pages, NUM_OF_PAGE_PER_GROUP);\n\tfwrt->num_of_pages_in_last_blk =\n\t\tnum_of_pages -\n\t\tNUM_OF_PAGE_PER_GROUP * (fwrt->num_of_paging_blk - 1);\n\n\tIWL_DEBUG_FW(fwrt,\n\t\t     \"Paging: allocating mem for %d paging blocks, each block holds 8 pages, last block holds %d pages\\n\",\n\t\t     fwrt->num_of_paging_blk,\n\t\t     fwrt->num_of_pages_in_last_blk);\n\n\t \n\tfor (blk_idx = 0; blk_idx < fwrt->num_of_paging_blk + 1; blk_idx++) {\n\t\t \n\t\tsize = blk_idx ? PAGING_BLOCK_SIZE : FW_PAGING_SIZE;\n\t\torder = get_order(size);\n\t\tblock = alloc_pages(GFP_KERNEL, order);\n\t\tif (!block) {\n\t\t\t \n\t\t\tiwl_free_fw_paging(fwrt);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tfwrt->fw_paging_db[blk_idx].fw_paging_block = block;\n\t\tfwrt->fw_paging_db[blk_idx].fw_paging_size = size;\n\n\t\tphys = dma_map_page(fwrt->trans->dev, block, 0,\n\t\t\t\t    PAGE_SIZE << order,\n\t\t\t\t    DMA_BIDIRECTIONAL);\n\t\tif (dma_mapping_error(fwrt->trans->dev, phys)) {\n\t\t\t \n\t\t\tiwl_free_fw_paging(fwrt);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tfwrt->fw_paging_db[blk_idx].fw_paging_phys = phys;\n\n\t\tif (!blk_idx)\n\t\t\tIWL_DEBUG_FW(fwrt,\n\t\t\t\t     \"Paging: allocated 4K(CSS) bytes (order %d) for firmware paging.\\n\",\n\t\t\t\t     order);\n\t\telse\n\t\t\tIWL_DEBUG_FW(fwrt,\n\t\t\t\t     \"Paging: allocated 32K bytes (order %d) for firmware paging.\\n\",\n\t\t\t\t     order);\n\t}\n\n\treturn 0;\n}\n\nstatic int iwl_fill_paging_mem(struct iwl_fw_runtime *fwrt,\n\t\t\t       const struct fw_img *image)\n{\n\tint sec_idx, idx, ret;\n\tu32 offset = 0;\n\n\t \n\tfor (sec_idx = 0; sec_idx < image->num_sec; sec_idx++) {\n\t\tif (image->sec[sec_idx].offset == PAGING_SEPARATOR_SECTION) {\n\t\t\tsec_idx++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (sec_idx >= image->num_sec - 1) {\n\t\tIWL_ERR(fwrt, \"Paging: Missing CSS and/or paging sections\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tIWL_DEBUG_FW(fwrt, \"Paging: load paging CSS to FW, sec = %d\\n\",\n\t\t     sec_idx);\n\n\tif (image->sec[sec_idx].len > fwrt->fw_paging_db[0].fw_paging_size) {\n\t\tIWL_ERR(fwrt, \"CSS block is larger than paging size\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tmemcpy(page_address(fwrt->fw_paging_db[0].fw_paging_block),\n\t       image->sec[sec_idx].data,\n\t       image->sec[sec_idx].len);\n\tfwrt->fw_paging_db[0].fw_offs = image->sec[sec_idx].offset;\n\tdma_sync_single_for_device(fwrt->trans->dev,\n\t\t\t\t   fwrt->fw_paging_db[0].fw_paging_phys,\n\t\t\t\t   fwrt->fw_paging_db[0].fw_paging_size,\n\t\t\t\t   DMA_BIDIRECTIONAL);\n\n\tIWL_DEBUG_FW(fwrt,\n\t\t     \"Paging: copied %d CSS bytes to first block\\n\",\n\t\t     fwrt->fw_paging_db[0].fw_paging_size);\n\n\tsec_idx++;\n\n\t \n\tfor (idx = 1; idx < fwrt->num_of_paging_blk + 1; idx++) {\n\t\tstruct iwl_fw_paging *block = &fwrt->fw_paging_db[idx];\n\t\tint remaining = image->sec[sec_idx].len - offset;\n\t\tint len = block->fw_paging_size;\n\n\t\t \n\t\tif (idx == fwrt->num_of_paging_blk) {\n\t\t\tlen = remaining;\n\t\t\tif (remaining !=\n\t\t\t    fwrt->num_of_pages_in_last_blk * FW_PAGING_SIZE) {\n\t\t\t\tIWL_ERR(fwrt,\n\t\t\t\t\t\"Paging: last block contains more data than expected %d\\n\",\n\t\t\t\t\tremaining);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else if (block->fw_paging_size > remaining) {\n\t\t\tIWL_ERR(fwrt,\n\t\t\t\t\"Paging: not enough data in other in block %d (%d)\\n\",\n\t\t\t\tidx, remaining);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tmemcpy(page_address(block->fw_paging_block),\n\t\t       (const u8 *)image->sec[sec_idx].data + offset, len);\n\t\tblock->fw_offs = image->sec[sec_idx].offset + offset;\n\t\tdma_sync_single_for_device(fwrt->trans->dev,\n\t\t\t\t\t   block->fw_paging_phys,\n\t\t\t\t\t   block->fw_paging_size,\n\t\t\t\t\t   DMA_BIDIRECTIONAL);\n\n\t\tIWL_DEBUG_FW(fwrt,\n\t\t\t     \"Paging: copied %d paging bytes to block %d\\n\",\n\t\t\t     len, idx);\n\n\t\toffset += block->fw_paging_size;\n\t}\n\n\treturn 0;\n\nerr:\n\tiwl_free_fw_paging(fwrt);\n\treturn ret;\n}\n\nstatic int iwl_save_fw_paging(struct iwl_fw_runtime *fwrt,\n\t\t\t      const struct fw_img *fw)\n{\n\tint ret;\n\n\tret = iwl_alloc_fw_paging_mem(fwrt, fw);\n\tif (ret)\n\t\treturn ret;\n\n\treturn iwl_fill_paging_mem(fwrt, fw);\n}\n\n \nstatic int iwl_send_paging_cmd(struct iwl_fw_runtime *fwrt,\n\t\t\t       const struct fw_img *fw)\n{\n\tstruct iwl_fw_paging_cmd paging_cmd = {\n\t\t.flags = cpu_to_le32(PAGING_CMD_IS_SECURED |\n\t\t\t\t     PAGING_CMD_IS_ENABLED |\n\t\t\t\t     (fwrt->num_of_pages_in_last_blk <<\n\t\t\t\t      PAGING_CMD_NUM_OF_PAGES_IN_LAST_GRP_POS)),\n\t\t.block_size = cpu_to_le32(BLOCK_2_EXP_SIZE),\n\t\t.block_num = cpu_to_le32(fwrt->num_of_paging_blk),\n\t};\n\tstruct iwl_host_cmd hcmd = {\n\t\t.id = WIDE_ID(IWL_ALWAYS_LONG_GROUP, FW_PAGING_BLOCK_CMD),\n\t\t.len = { sizeof(paging_cmd), },\n\t\t.data = { &paging_cmd, },\n\t};\n\tint blk_idx;\n\n\t \n\tfor (blk_idx = 0; blk_idx < fwrt->num_of_paging_blk + 1; blk_idx++) {\n\t\tdma_addr_t addr = fwrt->fw_paging_db[blk_idx].fw_paging_phys;\n\t\t__le32 phy_addr;\n\n\t\taddr = addr >> PAGE_2_EXP_SIZE;\n\t\tphy_addr = cpu_to_le32(addr);\n\t\tpaging_cmd.device_phy_addr[blk_idx] = phy_addr;\n\t}\n\n\treturn iwl_trans_send_cmd(fwrt->trans, &hcmd);\n}\n\nint iwl_init_paging(struct iwl_fw_runtime *fwrt, enum iwl_ucode_type type)\n{\n\tconst struct fw_img *fw = &fwrt->fw->img[type];\n\tint ret;\n\n\tif (fwrt->trans->trans_cfg->gen2)\n\t\treturn 0;\n\n\t \n\tif (!fw->paging_mem_size)\n\t\treturn 0;\n\n\tret = iwl_save_fw_paging(fwrt, fw);\n\tif (ret) {\n\t\tIWL_ERR(fwrt, \"failed to save the FW paging image\\n\");\n\t\treturn ret;\n\t}\n\n\tret = iwl_send_paging_cmd(fwrt, fw);\n\tif (ret) {\n\t\tIWL_ERR(fwrt, \"failed to send the paging cmd\\n\");\n\t\tiwl_free_fw_paging(fwrt);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nIWL_EXPORT_SYMBOL(iwl_init_paging);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}