{
  "module_name": "dump.c",
  "hash_id": "3b86249dead610c3efaf8104b29d79a585b7d3768c8cabd494600502cc78b6e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/fw/dump.c",
  "human_readable_source": "\n \n#include <linux/devcoredump.h>\n#include \"iwl-drv.h\"\n#include \"runtime.h\"\n#include \"dbg.h\"\n#include \"debugfs.h\"\n#include \"iwl-io.h\"\n#include \"iwl-prph.h\"\n#include \"iwl-csr.h\"\n#include \"pnvm.h\"\n\n#define FW_ASSERT_LMAC_FATAL\t\t\t0x70\n#define FW_ASSERT_LMAC2_FATAL\t\t\t0x72\n#define FW_ASSERT_UMAC_FATAL\t\t\t0x71\n#define UMAC_RT_NMI_LMAC2_FATAL\t\t\t0x72\n#define RT_NMI_INTERRUPT_OTHER_LMAC_FATAL\t0x73\n#define FW_ASSERT_NMI_UNKNOWN\t\t\t0x84\n\n \nstruct iwl_error_event_table {\n\tu32 valid;\t\t \n\tu32 error_id;\t\t \n\tu32 trm_hw_status0;\t \n\tu32 trm_hw_status1;\t \n\tu32 blink2;\t\t \n\tu32 ilink1;\t\t \n\tu32 ilink2;\t\t \n\tu32 data1;\t\t \n\tu32 data2;\t\t \n\tu32 data3;\t\t \n\tu32 bcon_time;\t\t \n\tu32 tsf_low;\t\t \n\tu32 tsf_hi;\t\t \n\tu32 gp1;\t\t \n\tu32 gp2;\t\t \n\tu32 fw_rev_type;\t \n\tu32 major;\t\t \n\tu32 minor;\t\t \n\tu32 hw_ver;\t\t \n\tu32 brd_ver;\t\t \n\tu32 log_pc;\t\t \n\tu32 frame_ptr;\t\t \n\tu32 stack_ptr;\t\t \n\tu32 hcmd;\t\t \n\tu32 isr0;\t\t \n\tu32 isr1;\t\t \n\tu32 isr2;\t\t \n\tu32 isr3;\t\t \n\tu32 isr4;\t\t \n\tu32 last_cmd_id;\t \n\tu32 wait_event;\t\t \n\tu32 l2p_control;\t \n\tu32 l2p_duration;\t \n\tu32 l2p_mhvalid;\t \n\tu32 l2p_addr_match;\t \n\tu32 lmpm_pmg_sel;\t \n\tu32 u_timestamp;\t \n\tu32 flow_handler;\t \n} __packed  ;\n\n \nstruct iwl_umac_error_event_table {\n\tu32 valid;\t\t \n\tu32 error_id;\t\t \n\tu32 blink1;\t\t \n\tu32 blink2;\t\t \n\tu32 ilink1;\t\t \n\tu32 ilink2;\t\t \n\tu32 data1;\t\t \n\tu32 data2;\t\t \n\tu32 data3;\t\t \n\tu32 umac_major;\n\tu32 umac_minor;\n\tu32 frame_pointer;\t \n\tu32 stack_pointer;\t \n\tu32 cmd_header;\t\t \n\tu32 nic_isr_pref;\t \n} __packed;\n\n#define ERROR_START_OFFSET  (1 * sizeof(u32))\n#define ERROR_ELEM_SIZE     (7 * sizeof(u32))\n\nstatic bool iwl_fwrt_if_errorid_other_cpu(u32 err_id)\n{\n\terr_id &= 0xFF;\n\n\tif ((err_id >= FW_ASSERT_LMAC_FATAL &&\n\t     err_id <= RT_NMI_INTERRUPT_OTHER_LMAC_FATAL) ||\n\t    err_id == FW_ASSERT_NMI_UNKNOWN)\n\t\treturn  true;\n\treturn false;\n}\n\nstatic void iwl_fwrt_dump_umac_error_log(struct iwl_fw_runtime *fwrt)\n{\n\tstruct iwl_trans *trans = fwrt->trans;\n\tstruct iwl_umac_error_event_table table = {};\n\tu32 base = fwrt->trans->dbg.umac_error_event_table;\n\tchar pnvm_name[MAX_PNVM_NAME];\n\n\tif (!base &&\n\t    !(fwrt->trans->dbg.error_event_table_tlv_status &\n\t      IWL_ERROR_EVENT_TABLE_UMAC))\n\t\treturn;\n\n\tiwl_trans_read_mem_bytes(trans, base, &table, sizeof(table));\n\n\tif (table.valid)\n\t\tfwrt->dump.umac_err_id = table.error_id;\n\n\tif (!iwl_fwrt_if_errorid_other_cpu(fwrt->dump.umac_err_id) &&\n\t    !fwrt->trans->dbg.dump_file_name_ext_valid) {\n\t\tfwrt->trans->dbg.dump_file_name_ext_valid = true;\n\t\tsnprintf(fwrt->trans->dbg.dump_file_name_ext, IWL_FW_INI_MAX_NAME,\n\t\t\t \"0x%x\", fwrt->dump.umac_err_id);\n\t}\n\n\tif (ERROR_START_OFFSET <= table.valid * ERROR_ELEM_SIZE) {\n\t\tIWL_ERR(trans, \"Start IWL Error Log Dump:\\n\");\n\t\tIWL_ERR(trans, \"Transport status: 0x%08lX, valid: %d\\n\",\n\t\t\tfwrt->trans->status, table.valid);\n\t}\n\n\tif ((table.error_id & ~FW_SYSASSERT_CPU_MASK) ==\n\t    FW_SYSASSERT_PNVM_MISSING) {\n\t\tiwl_pnvm_get_fs_name(trans, pnvm_name, sizeof(pnvm_name));\n\t\tIWL_ERR(fwrt, \"PNVM data is missing, please install %s\\n\",\n\t\t\tpnvm_name);\n\t}\n\n\tIWL_ERR(fwrt, \"0x%08X | %s\\n\", table.error_id,\n\t\tiwl_fw_lookup_assert_desc(table.error_id));\n\tIWL_ERR(fwrt, \"0x%08X | umac branchlink1\\n\", table.blink1);\n\tIWL_ERR(fwrt, \"0x%08X | umac branchlink2\\n\", table.blink2);\n\tIWL_ERR(fwrt, \"0x%08X | umac interruptlink1\\n\", table.ilink1);\n\tIWL_ERR(fwrt, \"0x%08X | umac interruptlink2\\n\", table.ilink2);\n\tIWL_ERR(fwrt, \"0x%08X | umac data1\\n\", table.data1);\n\tIWL_ERR(fwrt, \"0x%08X | umac data2\\n\", table.data2);\n\tIWL_ERR(fwrt, \"0x%08X | umac data3\\n\", table.data3);\n\tIWL_ERR(fwrt, \"0x%08X | umac major\\n\", table.umac_major);\n\tIWL_ERR(fwrt, \"0x%08X | umac minor\\n\", table.umac_minor);\n\tIWL_ERR(fwrt, \"0x%08X | frame pointer\\n\", table.frame_pointer);\n\tIWL_ERR(fwrt, \"0x%08X | stack pointer\\n\", table.stack_pointer);\n\tIWL_ERR(fwrt, \"0x%08X | last host cmd\\n\", table.cmd_header);\n\tIWL_ERR(fwrt, \"0x%08X | isr status reg\\n\", table.nic_isr_pref);\n}\n\nstatic void iwl_fwrt_dump_lmac_error_log(struct iwl_fw_runtime *fwrt, u8 lmac_num)\n{\n\tstruct iwl_trans *trans = fwrt->trans;\n\tstruct iwl_error_event_table table = {};\n\tu32 val, base = fwrt->trans->dbg.lmac_error_event_table[lmac_num];\n\n\tif (fwrt->cur_fw_img == IWL_UCODE_INIT) {\n\t\tif (!base)\n\t\t\tbase = fwrt->fw->init_errlog_ptr;\n\t} else {\n\t\tif (!base)\n\t\t\tbase = fwrt->fw->inst_errlog_ptr;\n\t}\n\n\tif (!base) {\n\t\tIWL_ERR(fwrt,\n\t\t\t\"Not valid error log pointer 0x%08X for %s uCode\\n\",\n\t\t\tbase,\n\t\t\t(fwrt->cur_fw_img == IWL_UCODE_INIT)\n\t\t\t? \"Init\" : \"RT\");\n\t\treturn;\n\t}\n\n\t \n\tval = iwl_trans_read_mem32(trans, base);\n\tif (iwl_trans_is_hw_error_value(val)) {\n\t\tint err;\n\n\t\tIWL_ERR(trans, \"HW error, resetting before reading\\n\");\n\n\t\t \n\t\terr = iwl_trans_sw_reset(trans, true);\n\t\tif (err)\n\t\t\treturn;\n\n\t\terr = iwl_finish_nic_init(trans);\n\t\tif (err)\n\t\t\treturn;\n\t}\n\n\tiwl_trans_read_mem_bytes(trans, base, &table, sizeof(table));\n\n\tif (table.valid)\n\t\tfwrt->dump.lmac_err_id[lmac_num] = table.error_id;\n\n\tif (!iwl_fwrt_if_errorid_other_cpu(fwrt->dump.lmac_err_id[lmac_num]) &&\n\t    !fwrt->trans->dbg.dump_file_name_ext_valid) {\n\t\tfwrt->trans->dbg.dump_file_name_ext_valid = true;\n\t\tsnprintf(fwrt->trans->dbg.dump_file_name_ext, IWL_FW_INI_MAX_NAME,\n\t\t\t \"0x%x\", fwrt->dump.lmac_err_id[lmac_num]);\n\t}\n\n\tif (ERROR_START_OFFSET <= table.valid * ERROR_ELEM_SIZE) {\n\t\tIWL_ERR(trans, \"Start IWL Error Log Dump:\\n\");\n\t\tIWL_ERR(trans, \"Transport status: 0x%08lX, valid: %d\\n\",\n\t\t\tfwrt->trans->status, table.valid);\n\t}\n\n\t \n\n\tIWL_ERR(fwrt, \"Loaded firmware version: %s\\n\", fwrt->fw->fw_version);\n\n\tIWL_ERR(fwrt, \"0x%08X | %-28s\\n\", table.error_id,\n\t\tiwl_fw_lookup_assert_desc(table.error_id));\n\tIWL_ERR(fwrt, \"0x%08X | trm_hw_status0\\n\", table.trm_hw_status0);\n\tIWL_ERR(fwrt, \"0x%08X | trm_hw_status1\\n\", table.trm_hw_status1);\n\tIWL_ERR(fwrt, \"0x%08X | branchlink2\\n\", table.blink2);\n\tIWL_ERR(fwrt, \"0x%08X | interruptlink1\\n\", table.ilink1);\n\tIWL_ERR(fwrt, \"0x%08X | interruptlink2\\n\", table.ilink2);\n\tIWL_ERR(fwrt, \"0x%08X | data1\\n\", table.data1);\n\tIWL_ERR(fwrt, \"0x%08X | data2\\n\", table.data2);\n\tIWL_ERR(fwrt, \"0x%08X | data3\\n\", table.data3);\n\tIWL_ERR(fwrt, \"0x%08X | beacon time\\n\", table.bcon_time);\n\tIWL_ERR(fwrt, \"0x%08X | tsf low\\n\", table.tsf_low);\n\tIWL_ERR(fwrt, \"0x%08X | tsf hi\\n\", table.tsf_hi);\n\tIWL_ERR(fwrt, \"0x%08X | time gp1\\n\", table.gp1);\n\tIWL_ERR(fwrt, \"0x%08X | time gp2\\n\", table.gp2);\n\tIWL_ERR(fwrt, \"0x%08X | uCode revision type\\n\", table.fw_rev_type);\n\tIWL_ERR(fwrt, \"0x%08X | uCode version major\\n\", table.major);\n\tIWL_ERR(fwrt, \"0x%08X | uCode version minor\\n\", table.minor);\n\tIWL_ERR(fwrt, \"0x%08X | hw version\\n\", table.hw_ver);\n\tIWL_ERR(fwrt, \"0x%08X | board version\\n\", table.brd_ver);\n\tIWL_ERR(fwrt, \"0x%08X | hcmd\\n\", table.hcmd);\n\tIWL_ERR(fwrt, \"0x%08X | isr0\\n\", table.isr0);\n\tIWL_ERR(fwrt, \"0x%08X | isr1\\n\", table.isr1);\n\tIWL_ERR(fwrt, \"0x%08X | isr2\\n\", table.isr2);\n\tIWL_ERR(fwrt, \"0x%08X | isr3\\n\", table.isr3);\n\tIWL_ERR(fwrt, \"0x%08X | isr4\\n\", table.isr4);\n\tIWL_ERR(fwrt, \"0x%08X | last cmd Id\\n\", table.last_cmd_id);\n\tIWL_ERR(fwrt, \"0x%08X | wait_event\\n\", table.wait_event);\n\tIWL_ERR(fwrt, \"0x%08X | l2p_control\\n\", table.l2p_control);\n\tIWL_ERR(fwrt, \"0x%08X | l2p_duration\\n\", table.l2p_duration);\n\tIWL_ERR(fwrt, \"0x%08X | l2p_mhvalid\\n\", table.l2p_mhvalid);\n\tIWL_ERR(fwrt, \"0x%08X | l2p_addr_match\\n\", table.l2p_addr_match);\n\tIWL_ERR(fwrt, \"0x%08X | lmpm_pmg_sel\\n\", table.lmpm_pmg_sel);\n\tIWL_ERR(fwrt, \"0x%08X | timestamp\\n\", table.u_timestamp);\n\tIWL_ERR(fwrt, \"0x%08X | flow_handler\\n\", table.flow_handler);\n}\n\n \nstruct iwl_tcm_error_event_table {\n\tu32 valid;\n\tu32 error_id;\n\tu32 blink2;\n\tu32 ilink1;\n\tu32 ilink2;\n\tu32 data1, data2, data3;\n\tu32 logpc;\n\tu32 frame_pointer;\n\tu32 stack_pointer;\n\tu32 msgid;\n\tu32 isr;\n\tu32 hw_status[5];\n\tu32 sw_status[1];\n\tu32 reserved[4];\n} __packed;  \n\nstatic void iwl_fwrt_dump_tcm_error_log(struct iwl_fw_runtime *fwrt, int idx)\n{\n\tstruct iwl_trans *trans = fwrt->trans;\n\tstruct iwl_tcm_error_event_table table = {};\n\tu32 base = fwrt->trans->dbg.tcm_error_event_table[idx];\n\tint i;\n\tu32 flag = idx ? IWL_ERROR_EVENT_TABLE_TCM2 :\n\t\t\t IWL_ERROR_EVENT_TABLE_TCM1;\n\n\tif (!base || !(fwrt->trans->dbg.error_event_table_tlv_status & flag))\n\t\treturn;\n\n\tiwl_trans_read_mem_bytes(trans, base, &table, sizeof(table));\n\n\tif (table.valid)\n\t\tfwrt->dump.tcm_err_id[idx] = table.error_id;\n\n\tif (!iwl_fwrt_if_errorid_other_cpu(fwrt->dump.tcm_err_id[idx]) &&\n\t    !fwrt->trans->dbg.dump_file_name_ext_valid) {\n\t\tfwrt->trans->dbg.dump_file_name_ext_valid = true;\n\t\tsnprintf(fwrt->trans->dbg.dump_file_name_ext, IWL_FW_INI_MAX_NAME,\n\t\t\t \"0x%x\", fwrt->dump.tcm_err_id[idx]);\n\t}\n\n\tIWL_ERR(fwrt, \"TCM%d status:\\n\", idx + 1);\n\tIWL_ERR(fwrt, \"0x%08X | error ID\\n\", table.error_id);\n\tIWL_ERR(fwrt, \"0x%08X | tcm branchlink2\\n\", table.blink2);\n\tIWL_ERR(fwrt, \"0x%08X | tcm interruptlink1\\n\", table.ilink1);\n\tIWL_ERR(fwrt, \"0x%08X | tcm interruptlink2\\n\", table.ilink2);\n\tIWL_ERR(fwrt, \"0x%08X | tcm data1\\n\", table.data1);\n\tIWL_ERR(fwrt, \"0x%08X | tcm data2\\n\", table.data2);\n\tIWL_ERR(fwrt, \"0x%08X | tcm data3\\n\", table.data3);\n\tIWL_ERR(fwrt, \"0x%08X | tcm log PC\\n\", table.logpc);\n\tIWL_ERR(fwrt, \"0x%08X | tcm frame pointer\\n\", table.frame_pointer);\n\tIWL_ERR(fwrt, \"0x%08X | tcm stack pointer\\n\", table.stack_pointer);\n\tIWL_ERR(fwrt, \"0x%08X | tcm msg ID\\n\", table.msgid);\n\tIWL_ERR(fwrt, \"0x%08X | tcm ISR status\\n\", table.isr);\n\tfor (i = 0; i < ARRAY_SIZE(table.hw_status); i++)\n\t\tIWL_ERR(fwrt, \"0x%08X | tcm HW status[%d]\\n\",\n\t\t\ttable.hw_status[i], i);\n\tfor (i = 0; i < ARRAY_SIZE(table.sw_status); i++)\n\t\tIWL_ERR(fwrt, \"0x%08X | tcm SW status[%d]\\n\",\n\t\t\ttable.sw_status[i], i);\n}\n\n \nstruct iwl_rcm_error_event_table {\n\tu32 valid;\n\tu32 error_id;\n\tu32 blink2;\n\tu32 ilink1;\n\tu32 ilink2;\n\tu32 data1, data2, data3;\n\tu32 logpc;\n\tu32 frame_pointer;\n\tu32 stack_pointer;\n\tu32 msgid;\n\tu32 isr;\n\tu32 frame_hw_status;\n\tu32 mbx_lmac_to_rcm_req;\n\tu32 mbx_rcm_to_lmac_req;\n\tu32 mh_ctl;\n\tu32 mh_addr1_lo;\n\tu32 mh_info;\n\tu32 mh_err;\n\tu32 reserved[3];\n} __packed;  \n\nstatic void iwl_fwrt_dump_rcm_error_log(struct iwl_fw_runtime *fwrt, int idx)\n{\n\tstruct iwl_trans *trans = fwrt->trans;\n\tstruct iwl_rcm_error_event_table table = {};\n\tu32 base = fwrt->trans->dbg.rcm_error_event_table[idx];\n\tu32 flag = idx ? IWL_ERROR_EVENT_TABLE_RCM2 :\n\t\t\t IWL_ERROR_EVENT_TABLE_RCM1;\n\n\tif (!base || !(fwrt->trans->dbg.error_event_table_tlv_status & flag))\n\t\treturn;\n\n\tiwl_trans_read_mem_bytes(trans, base, &table, sizeof(table));\n\n\tif (table.valid)\n\t\tfwrt->dump.rcm_err_id[idx] = table.error_id;\n\n\tif (!iwl_fwrt_if_errorid_other_cpu(fwrt->dump.rcm_err_id[idx]) &&\n\t    !fwrt->trans->dbg.dump_file_name_ext_valid) {\n\t\tfwrt->trans->dbg.dump_file_name_ext_valid = true;\n\t\tsnprintf(fwrt->trans->dbg.dump_file_name_ext, IWL_FW_INI_MAX_NAME,\n\t\t\t \"0x%x\", fwrt->dump.rcm_err_id[idx]);\n\t}\n\n\tIWL_ERR(fwrt, \"RCM%d status:\\n\", idx + 1);\n\tIWL_ERR(fwrt, \"0x%08X | error ID\\n\", table.error_id);\n\tIWL_ERR(fwrt, \"0x%08X | rcm branchlink2\\n\", table.blink2);\n\tIWL_ERR(fwrt, \"0x%08X | rcm interruptlink1\\n\", table.ilink1);\n\tIWL_ERR(fwrt, \"0x%08X | rcm interruptlink2\\n\", table.ilink2);\n\tIWL_ERR(fwrt, \"0x%08X | rcm data1\\n\", table.data1);\n\tIWL_ERR(fwrt, \"0x%08X | rcm data2\\n\", table.data2);\n\tIWL_ERR(fwrt, \"0x%08X | rcm data3\\n\", table.data3);\n\tIWL_ERR(fwrt, \"0x%08X | rcm log PC\\n\", table.logpc);\n\tIWL_ERR(fwrt, \"0x%08X | rcm frame pointer\\n\", table.frame_pointer);\n\tIWL_ERR(fwrt, \"0x%08X | rcm stack pointer\\n\", table.stack_pointer);\n\tIWL_ERR(fwrt, \"0x%08X | rcm msg ID\\n\", table.msgid);\n\tIWL_ERR(fwrt, \"0x%08X | rcm ISR status\\n\", table.isr);\n\tIWL_ERR(fwrt, \"0x%08X | frame HW status\\n\", table.frame_hw_status);\n\tIWL_ERR(fwrt, \"0x%08X | LMAC-to-RCM request mbox\\n\",\n\t\ttable.mbx_lmac_to_rcm_req);\n\tIWL_ERR(fwrt, \"0x%08X | RCM-to-LMAC request mbox\\n\",\n\t\ttable.mbx_rcm_to_lmac_req);\n\tIWL_ERR(fwrt, \"0x%08X | MAC header control\\n\", table.mh_ctl);\n\tIWL_ERR(fwrt, \"0x%08X | MAC header addr1 low\\n\", table.mh_addr1_lo);\n\tIWL_ERR(fwrt, \"0x%08X | MAC header info\\n\", table.mh_info);\n\tIWL_ERR(fwrt, \"0x%08X | MAC header error\\n\", table.mh_err);\n}\n\nstatic void iwl_fwrt_dump_iml_error_log(struct iwl_fw_runtime *fwrt)\n{\n\tstruct iwl_trans *trans = fwrt->trans;\n\tu32 error, data1;\n\n\tif (fwrt->trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_22000) {\n\t\terror = UMAG_SB_CPU_2_STATUS;\n\t\tdata1 = UMAG_SB_CPU_1_STATUS;\n\t} else if (fwrt->trans->trans_cfg->device_family >=\n\t\t   IWL_DEVICE_FAMILY_8000) {\n\t\terror = SB_CPU_2_STATUS;\n\t\tdata1 = SB_CPU_1_STATUS;\n\t} else {\n\t\treturn;\n\t}\n\n\terror = iwl_read_umac_prph(trans, error);\n\n\tIWL_ERR(trans, \"IML/ROM dump:\\n\");\n\n\tif (error & 0xFFFF0000)\n\t\tIWL_ERR(trans, \"0x%04X | IML/ROM SYSASSERT\\n\", error >> 16);\n\n\tIWL_ERR(fwrt, \"0x%08X | IML/ROM error/state\\n\", error);\n\tIWL_ERR(fwrt, \"0x%08X | IML/ROM data1\\n\",\n\t\tiwl_read_umac_prph(trans, data1));\n\n\tif (fwrt->trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_22000)\n\t\tIWL_ERR(fwrt, \"0x%08X | IML/ROM WFPM_AUTH_KEY_0\\n\",\n\t\t\tiwl_read_umac_prph(trans, SB_MODIFY_CFG_FLAG));\n}\n\n#define FSEQ_REG(x) { .addr = (x), .str = #x, }\n\nstatic void iwl_fwrt_dump_fseq_regs(struct iwl_fw_runtime *fwrt)\n{\n\tstruct iwl_trans *trans = fwrt->trans;\n\tint i;\n\tstruct {\n\t\tu32 addr;\n\t\tconst char *str;\n\t} fseq_regs[] = {\n\t\tFSEQ_REG(FSEQ_ERROR_CODE),\n\t\tFSEQ_REG(FSEQ_TOP_INIT_VERSION),\n\t\tFSEQ_REG(FSEQ_CNVIO_INIT_VERSION),\n\t\tFSEQ_REG(FSEQ_OTP_VERSION),\n\t\tFSEQ_REG(FSEQ_TOP_CONTENT_VERSION),\n\t\tFSEQ_REG(FSEQ_ALIVE_TOKEN),\n\t\tFSEQ_REG(FSEQ_CNVI_ID),\n\t\tFSEQ_REG(FSEQ_CNVR_ID),\n\t\tFSEQ_REG(CNVI_AUX_MISC_CHIP),\n\t\tFSEQ_REG(CNVR_AUX_MISC_CHIP),\n\t\tFSEQ_REG(CNVR_SCU_SD_REGS_SD_REG_DIG_DCDC_VTRIM),\n\t\tFSEQ_REG(CNVR_SCU_SD_REGS_SD_REG_ACTIVE_VDIG_MIRROR),\n\t\tFSEQ_REG(FSEQ_PREV_CNVIO_INIT_VERSION),\n\t\tFSEQ_REG(FSEQ_WIFI_FSEQ_VERSION),\n\t\tFSEQ_REG(FSEQ_BT_FSEQ_VERSION),\n\t\tFSEQ_REG(FSEQ_CLASS_TP_VERSION),\n\t};\n\n\tif (!iwl_trans_grab_nic_access(trans))\n\t\treturn;\n\n\tIWL_ERR(fwrt, \"Fseq Registers:\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(fseq_regs); i++)\n\t\tIWL_ERR(fwrt, \"0x%08X | %s\\n\",\n\t\t\tiwl_read_prph_no_grab(trans, fseq_regs[i].addr),\n\t\t\tfseq_regs[i].str);\n\n\tiwl_trans_release_nic_access(trans);\n}\n\nvoid iwl_fwrt_dump_error_logs(struct iwl_fw_runtime *fwrt)\n{\n\tstruct iwl_pc_data *pc_data;\n\tu8 count;\n\n\tif (!test_bit(STATUS_DEVICE_ENABLED, &fwrt->trans->status)) {\n\t\tIWL_ERR(fwrt,\n\t\t\t\"DEVICE_ENABLED bit is not set. Aborting dump.\\n\");\n\t\treturn;\n\t}\n\n\tiwl_fwrt_dump_lmac_error_log(fwrt, 0);\n\tif (fwrt->trans->dbg.lmac_error_event_table[1])\n\t\tiwl_fwrt_dump_lmac_error_log(fwrt, 1);\n\tiwl_fwrt_dump_umac_error_log(fwrt);\n\tiwl_fwrt_dump_tcm_error_log(fwrt, 0);\n\tiwl_fwrt_dump_rcm_error_log(fwrt, 0);\n\tif (fwrt->trans->dbg.tcm_error_event_table[1])\n\t\tiwl_fwrt_dump_tcm_error_log(fwrt, 1);\n\tif (fwrt->trans->dbg.rcm_error_event_table[1])\n\t\tiwl_fwrt_dump_rcm_error_log(fwrt, 1);\n\tiwl_fwrt_dump_iml_error_log(fwrt);\n\tiwl_fwrt_dump_fseq_regs(fwrt);\n\tif (fwrt->trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_22000) {\n\t\tpc_data = fwrt->trans->dbg.pc_data;\n\n\t\tif (!iwl_trans_grab_nic_access(fwrt->trans))\n\t\t\treturn;\n\t\tfor (count = 0; count < fwrt->trans->dbg.num_pc;\n\t\t     count++, pc_data++)\n\t\t\tIWL_ERR(fwrt, \"%s: 0x%x\\n\",\n\t\t\t\tpc_data->pc_name,\n\t\t\t\tiwl_read_prph_no_grab(fwrt->trans,\n\t\t\t\t\t\t      pc_data->pc_address));\n\t\tiwl_trans_release_nic_access(fwrt->trans);\n\t}\n\n\tif (fwrt->trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_BZ) {\n\t\tu32 scratch = iwl_read32(fwrt->trans, CSR_FUNC_SCRATCH);\n\n\t\tIWL_ERR(fwrt, \"Function Scratch status:\\n\");\n\t\tIWL_ERR(fwrt, \"0x%08X | Func Scratch\\n\", scratch);\n\t}\n}\nIWL_EXPORT_SYMBOL(iwl_fwrt_dump_error_logs);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}