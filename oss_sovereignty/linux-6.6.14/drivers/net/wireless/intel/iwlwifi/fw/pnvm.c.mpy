{
  "module_name": "pnvm.c",
  "hash_id": "a59767c747417ac7c26e457c326cffa55b65115f1ba241e5ef03208f4469ac00",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/fw/pnvm.c",
  "human_readable_source": "\n \n\n#include \"iwl-drv.h\"\n#include \"pnvm.h\"\n#include \"iwl-prph.h\"\n#include \"iwl-io.h\"\n#include \"fw/api/commands.h\"\n#include \"fw/api/nvm-reg.h\"\n#include \"fw/api/alive.h\"\n#include \"fw/uefi.h\"\n\nstruct iwl_pnvm_section {\n\t__le32 offset;\n\tconst u8 data[];\n} __packed;\n\nstatic bool iwl_pnvm_complete_fn(struct iwl_notif_wait_data *notif_wait,\n\t\t\t\t struct iwl_rx_packet *pkt, void *data)\n{\n\tstruct iwl_trans *trans = (struct iwl_trans *)data;\n\tstruct iwl_pnvm_init_complete_ntfy *pnvm_ntf = (void *)pkt->data;\n\n\tIWL_DEBUG_FW(trans,\n\t\t     \"PNVM complete notification received with status 0x%0x\\n\",\n\t\t     le32_to_cpu(pnvm_ntf->status));\n\n\treturn true;\n}\n\nstatic int iwl_pnvm_handle_section(struct iwl_trans *trans, const u8 *data,\n\t\t\t\t   size_t len,\n\t\t\t\t   struct iwl_pnvm_image *pnvm_data)\n{\n\tconst struct iwl_ucode_tlv *tlv;\n\tu32 sha1 = 0;\n\tu16 mac_type = 0, rf_id = 0;\n\tbool hw_match = false;\n\n\tIWL_DEBUG_FW(trans, \"Handling PNVM section\\n\");\n\n\tmemset(pnvm_data, 0, sizeof(*pnvm_data));\n\n\twhile (len >= sizeof(*tlv)) {\n\t\tu32 tlv_len, tlv_type;\n\n\t\tlen -= sizeof(*tlv);\n\t\ttlv = (const void *)data;\n\n\t\ttlv_len = le32_to_cpu(tlv->length);\n\t\ttlv_type = le32_to_cpu(tlv->type);\n\n\t\tif (len < tlv_len) {\n\t\t\tIWL_ERR(trans, \"invalid TLV len: %zd/%u\\n\",\n\t\t\t\tlen, tlv_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdata += sizeof(*tlv);\n\n\t\tswitch (tlv_type) {\n\t\tcase IWL_UCODE_TLV_PNVM_VERSION:\n\t\t\tif (tlv_len < sizeof(__le32)) {\n\t\t\t\tIWL_DEBUG_FW(trans,\n\t\t\t\t\t     \"Invalid size for IWL_UCODE_TLV_PNVM_VERSION (expected %zd, got %d)\\n\",\n\t\t\t\t\t     sizeof(__le32), tlv_len);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsha1 = le32_to_cpup((const __le32 *)data);\n\n\t\t\tIWL_DEBUG_FW(trans,\n\t\t\t\t     \"Got IWL_UCODE_TLV_PNVM_VERSION %0x\\n\",\n\t\t\t\t     sha1);\n\t\t\tpnvm_data->version = sha1;\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_HW_TYPE:\n\t\t\tif (tlv_len < 2 * sizeof(__le16)) {\n\t\t\t\tIWL_DEBUG_FW(trans,\n\t\t\t\t\t     \"Invalid size for IWL_UCODE_TLV_HW_TYPE (expected %zd, got %d)\\n\",\n\t\t\t\t\t     2 * sizeof(__le16), tlv_len);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (hw_match)\n\t\t\t\tbreak;\n\n\t\t\tmac_type = le16_to_cpup((const __le16 *)data);\n\t\t\trf_id = le16_to_cpup((const __le16 *)(data + sizeof(__le16)));\n\n\t\t\tIWL_DEBUG_FW(trans,\n\t\t\t\t     \"Got IWL_UCODE_TLV_HW_TYPE mac_type 0x%0x rf_id 0x%0x\\n\",\n\t\t\t\t     mac_type, rf_id);\n\n\t\t\tif (mac_type == CSR_HW_REV_TYPE(trans->hw_rev) &&\n\t\t\t    rf_id == CSR_HW_RFID_TYPE(trans->hw_rf_id))\n\t\t\t\thw_match = true;\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_SEC_RT: {\n\t\t\tconst struct iwl_pnvm_section *section = (const void *)data;\n\t\t\tu32 data_len = tlv_len - sizeof(*section);\n\n\t\t\tIWL_DEBUG_FW(trans,\n\t\t\t\t     \"Got IWL_UCODE_TLV_SEC_RT len %d\\n\",\n\t\t\t\t     tlv_len);\n\n\t\t\t \n\t\t\tif (le32_to_cpup((const __le32 *)data) == 0xddddeeee) {\n\t\t\t\tIWL_DEBUG_FW(trans, \"Ignoring separator.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (pnvm_data->n_chunks == IPC_DRAM_MAP_ENTRY_NUM_MAX) {\n\t\t\t\tIWL_DEBUG_FW(trans,\n\t\t\t\t\t     \"too many payloads to allocate in DRAM.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tIWL_DEBUG_FW(trans, \"Adding data (size %d)\\n\",\n\t\t\t\t     data_len);\n\n\t\t\tpnvm_data->chunks[pnvm_data->n_chunks].data = section->data;\n\t\t\tpnvm_data->chunks[pnvm_data->n_chunks].len = data_len;\n\t\t\tpnvm_data->n_chunks++;\n\n\t\t\tbreak;\n\t\t}\n\t\tcase IWL_UCODE_TLV_MEM_DESC:\n\t\t\tif (iwl_uefi_handle_tlv_mem_desc(trans, data, tlv_len,\n\t\t\t\t\t\t\t pnvm_data))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_PNVM_SKU:\n\t\t\tIWL_DEBUG_FW(trans,\n\t\t\t\t     \"New PNVM section started, stop parsing.\\n\");\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\tIWL_DEBUG_FW(trans, \"Found TLV 0x%0x, len %d\\n\",\n\t\t\t\t     tlv_type, tlv_len);\n\t\t\tbreak;\n\t\t}\n\n\t\tlen -= ALIGN(tlv_len, 4);\n\t\tdata += ALIGN(tlv_len, 4);\n\t}\n\ndone:\n\tif (!hw_match) {\n\t\tIWL_DEBUG_FW(trans,\n\t\t\t     \"HW mismatch, skipping PNVM section (need mac_type 0x%x rf_id 0x%x)\\n\",\n\t\t\t     CSR_HW_REV_TYPE(trans->hw_rev),\n\t\t\t     CSR_HW_RFID_TYPE(trans->hw_rf_id));\n\t\treturn -ENOENT;\n\t}\n\n\tif (!pnvm_data->n_chunks) {\n\t\tIWL_DEBUG_FW(trans, \"Empty PNVM, skipping.\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}\n\nstatic int iwl_pnvm_parse(struct iwl_trans *trans, const u8 *data,\n\t\t\t  size_t len,\n\t\t\t  struct iwl_pnvm_image *pnvm_data)\n{\n\tconst struct iwl_ucode_tlv *tlv;\n\n\tIWL_DEBUG_FW(trans, \"Parsing PNVM file\\n\");\n\n\twhile (len >= sizeof(*tlv)) {\n\t\tu32 tlv_len, tlv_type;\n\n\t\tlen -= sizeof(*tlv);\n\t\ttlv = (const void *)data;\n\n\t\ttlv_len = le32_to_cpu(tlv->length);\n\t\ttlv_type = le32_to_cpu(tlv->type);\n\n\t\tif (len < tlv_len) {\n\t\t\tIWL_ERR(trans, \"invalid TLV len: %zd/%u\\n\",\n\t\t\t\tlen, tlv_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (tlv_type == IWL_UCODE_TLV_PNVM_SKU) {\n\t\t\tconst struct iwl_sku_id *sku_id =\n\t\t\t\t(const void *)(data + sizeof(*tlv));\n\n\t\t\tIWL_DEBUG_FW(trans,\n\t\t\t\t     \"Got IWL_UCODE_TLV_PNVM_SKU len %d\\n\",\n\t\t\t\t     tlv_len);\n\t\t\tIWL_DEBUG_FW(trans, \"sku_id 0x%0x 0x%0x 0x%0x\\n\",\n\t\t\t\t     le32_to_cpu(sku_id->data[0]),\n\t\t\t\t     le32_to_cpu(sku_id->data[1]),\n\t\t\t\t     le32_to_cpu(sku_id->data[2]));\n\n\t\t\tdata += sizeof(*tlv) + ALIGN(tlv_len, 4);\n\t\t\tlen -= ALIGN(tlv_len, 4);\n\n\t\t\tif (trans->sku_id[0] == le32_to_cpu(sku_id->data[0]) &&\n\t\t\t    trans->sku_id[1] == le32_to_cpu(sku_id->data[1]) &&\n\t\t\t    trans->sku_id[2] == le32_to_cpu(sku_id->data[2])) {\n\t\t\t\tint ret;\n\n\t\t\t\tret = iwl_pnvm_handle_section(trans, data, len,\n\t\t\t\t\t\t\t      pnvm_data);\n\t\t\t\tif (!ret)\n\t\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tIWL_DEBUG_FW(trans, \"SKU ID didn't match!\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tdata += sizeof(*tlv) + ALIGN(tlv_len, 4);\n\t\t\tlen -= ALIGN(tlv_len, 4);\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int iwl_pnvm_get_from_fs(struct iwl_trans *trans, u8 **data, size_t *len)\n{\n\tconst struct firmware *pnvm;\n\tchar pnvm_name[MAX_PNVM_NAME];\n\tsize_t new_len;\n\tint ret;\n\n\tiwl_pnvm_get_fs_name(trans, pnvm_name, sizeof(pnvm_name));\n\n\tret = firmware_request_nowarn(&pnvm, pnvm_name, trans->dev);\n\tif (ret) {\n\t\tIWL_DEBUG_FW(trans, \"PNVM file %s not found %d\\n\",\n\t\t\t     pnvm_name, ret);\n\t\treturn ret;\n\t}\n\n\tnew_len = pnvm->size;\n\t*data = kmemdup(pnvm->data, pnvm->size, GFP_KERNEL);\n\trelease_firmware(pnvm);\n\n\tif (!*data)\n\t\treturn -ENOMEM;\n\n\t*len = new_len;\n\n\treturn 0;\n}\n\nstatic u8 *iwl_get_pnvm_image(struct iwl_trans *trans_p, size_t *len)\n{\n\tstruct pnvm_sku_package *package;\n\tu8 *image = NULL;\n\n\t \n\tpackage = iwl_uefi_get_pnvm(trans_p, len);\n\tif (!IS_ERR_OR_NULL(package)) {\n\t\tif (*len >= sizeof(*package)) {\n\t\t\t \n\t\t\t*len -= sizeof(*package);\n\t\t\timage = kmemdup(package->data, *len, GFP_KERNEL);\n\t\t}\n\t\t \n\t\tkfree(package);\n\t\tif (image)\n\t\t\treturn image;\n\t}\n\n\t \n\tif (iwl_pnvm_get_from_fs(trans_p, &image, len))\n\t\treturn NULL;\n\treturn image;\n}\n\nstatic void iwl_pnvm_load_pnvm_to_trans(struct iwl_trans *trans,\n\t\t\t\t\tconst struct iwl_ucode_capabilities *capa)\n{\n\tstruct iwl_pnvm_image *pnvm_data = NULL;\n\tu8 *data = NULL;\n\tsize_t length;\n\tint ret;\n\n\t \n\tif (trans->fail_to_parse_pnvm_image)\n\t\treturn;\n\n\tif (trans->pnvm_loaded)\n\t\tgoto set;\n\n\tdata = iwl_get_pnvm_image(trans, &length);\n\tif (!data) {\n\t\ttrans->fail_to_parse_pnvm_image = true;\n\t\treturn;\n\t}\n\n\tpnvm_data = kzalloc(sizeof(*pnvm_data), GFP_KERNEL);\n\tif (!pnvm_data)\n\t\tgoto free;\n\n\tret = iwl_pnvm_parse(trans, data, length, pnvm_data);\n\tif (ret) {\n\t\ttrans->fail_to_parse_pnvm_image = true;\n\t\tgoto free;\n\t}\n\n\tret = iwl_trans_load_pnvm(trans, pnvm_data, capa);\n\tif (ret)\n\t\tgoto free;\n\tIWL_INFO(trans, \"loaded PNVM version %08x\\n\", pnvm_data->version);\n\nset:\n\tiwl_trans_set_pnvm(trans, capa);\nfree:\n\tkfree(data);\n\tkfree(pnvm_data);\n}\n\nstatic void\niwl_pnvm_load_reduce_power_to_trans(struct iwl_trans *trans,\n\t\t\t\t    const struct iwl_ucode_capabilities *capa)\n{\n\tstruct iwl_pnvm_image *pnvm_data = NULL;\n\tu8 *data = NULL;\n\tsize_t length;\n\tint ret;\n\n\tif (trans->failed_to_load_reduce_power_image)\n\t\treturn;\n\n\tif (trans->reduce_power_loaded)\n\t\tgoto set;\n\n\tdata = iwl_uefi_get_reduced_power(trans, &length);\n\tif (IS_ERR(data)) {\n\t\ttrans->failed_to_load_reduce_power_image = true;\n\t\treturn;\n\t}\n\n\tpnvm_data = kzalloc(sizeof(*pnvm_data), GFP_KERNEL);\n\tif (!pnvm_data)\n\t\tgoto free;\n\n\tret = iwl_uefi_reduce_power_parse(trans, data, length, pnvm_data);\n\tif (ret) {\n\t\ttrans->failed_to_load_reduce_power_image = true;\n\t\tgoto free;\n\t}\n\n\tret = iwl_trans_load_reduce_power(trans, pnvm_data, capa);\n\tif (ret) {\n\t\tIWL_DEBUG_FW(trans,\n\t\t\t     \"Failed to load reduce power table %d\\n\",\n\t\t\t     ret);\n\t\ttrans->failed_to_load_reduce_power_image = true;\n\t\tgoto free;\n\t}\n\nset:\n\tiwl_trans_set_reduce_power(trans, capa);\nfree:\n\tkfree(data);\n\tkfree(pnvm_data);\n}\n\nint iwl_pnvm_load(struct iwl_trans *trans,\n\t\t  struct iwl_notif_wait_data *notif_wait,\n\t\t  const struct iwl_ucode_capabilities *capa)\n{\n\tstruct iwl_notification_wait pnvm_wait;\n\tstatic const u16 ntf_cmds[] = { WIDE_ID(REGULATORY_AND_NVM_GROUP,\n\t\t\t\t\t\tPNVM_INIT_COMPLETE_NTFY) };\n\n\t \n\tif (!trans->sku_id[0] && !trans->sku_id[1] && !trans->sku_id[2])\n\t\treturn 0;\n\n\tiwl_pnvm_load_pnvm_to_trans(trans, capa);\n\tiwl_pnvm_load_reduce_power_to_trans(trans, capa);\n\n\tiwl_init_notification_wait(notif_wait, &pnvm_wait,\n\t\t\t\t   ntf_cmds, ARRAY_SIZE(ntf_cmds),\n\t\t\t\t   iwl_pnvm_complete_fn, trans);\n\n\t \n\tiwl_write_umac_prph(trans, UREG_DOORBELL_TO_ISR6,\n\t\t\t    UREG_DOORBELL_TO_ISR6_PNVM);\n\n\treturn iwl_wait_notification(notif_wait, &pnvm_wait,\n\t\t\t\t     MVM_UCODE_PNVM_TIMEOUT);\n}\nIWL_EXPORT_SYMBOL(iwl_pnvm_load);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}