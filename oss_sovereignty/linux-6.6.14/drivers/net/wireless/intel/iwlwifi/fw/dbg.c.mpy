{
  "module_name": "dbg.c",
  "hash_id": "518ca4f0e384bb66a27d6b82f7adff767cd1c4c5497bcc8ebb3db60e338fddf8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/fw/dbg.c",
  "human_readable_source": "\n \n#include <linux/devcoredump.h>\n#include \"iwl-drv.h\"\n#include \"runtime.h\"\n#include \"dbg.h\"\n#include \"debugfs.h\"\n#include \"iwl-io.h\"\n#include \"iwl-prph.h\"\n#include \"iwl-csr.h\"\n#include \"iwl-fh.h\"\n \nstruct iwl_fw_dump_ptrs {\n\tstruct iwl_trans_dump_data *trans_ptr;\n\tvoid *fwrt_ptr;\n\tu32 fwrt_len;\n};\n\n#define RADIO_REG_MAX_READ 0x2ad\nstatic void iwl_read_radio_regs(struct iwl_fw_runtime *fwrt,\n\t\t\t\tstruct iwl_fw_error_dump_data **dump_data)\n{\n\tu8 *pos = (void *)(*dump_data)->data;\n\tint i;\n\n\tIWL_DEBUG_INFO(fwrt, \"WRT radio registers dump\\n\");\n\n\tif (!iwl_trans_grab_nic_access(fwrt->trans))\n\t\treturn;\n\n\t(*dump_data)->type = cpu_to_le32(IWL_FW_ERROR_DUMP_RADIO_REG);\n\t(*dump_data)->len = cpu_to_le32(RADIO_REG_MAX_READ);\n\n\tfor (i = 0; i < RADIO_REG_MAX_READ; i++) {\n\t\tu32 rd_cmd = RADIO_RSP_RD_CMD;\n\n\t\trd_cmd |= i << RADIO_RSP_ADDR_POS;\n\t\tiwl_write_prph_no_grab(fwrt->trans, RSP_RADIO_CMD, rd_cmd);\n\t\t*pos = (u8)iwl_read_prph_no_grab(fwrt->trans, RSP_RADIO_RDDAT);\n\n\t\tpos++;\n\t}\n\n\t*dump_data = iwl_fw_error_next_data(*dump_data);\n\n\tiwl_trans_release_nic_access(fwrt->trans);\n}\n\nstatic void iwl_fwrt_dump_rxf(struct iwl_fw_runtime *fwrt,\n\t\t\t      struct iwl_fw_error_dump_data **dump_data,\n\t\t\t      int size, u32 offset, int fifo_num)\n{\n\tstruct iwl_fw_error_dump_fifo *fifo_hdr;\n\tu32 *fifo_data;\n\tu32 fifo_len;\n\tint i;\n\n\tfifo_hdr = (void *)(*dump_data)->data;\n\tfifo_data = (void *)fifo_hdr->data;\n\tfifo_len = size;\n\n\t \n\tif (fifo_len == 0)\n\t\treturn;\n\n\t \n\t(*dump_data)->type = cpu_to_le32(IWL_FW_ERROR_DUMP_RXF);\n\t(*dump_data)->len = cpu_to_le32(fifo_len + sizeof(*fifo_hdr));\n\n\tfifo_hdr->fifo_num = cpu_to_le32(fifo_num);\n\tfifo_hdr->available_bytes =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tRXF_RD_D_SPACE + offset));\n\tfifo_hdr->wr_ptr =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tRXF_RD_WR_PTR + offset));\n\tfifo_hdr->rd_ptr =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tRXF_RD_RD_PTR + offset));\n\tfifo_hdr->fence_ptr =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tRXF_RD_FENCE_PTR + offset));\n\tfifo_hdr->fence_mode =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tRXF_SET_FENCE_MODE + offset));\n\n\t \n\tiwl_trans_write_prph(fwrt->trans, RXF_SET_FENCE_MODE + offset, 0x1);\n\t \n\tiwl_trans_write_prph(fwrt->trans, RXF_LD_WR2FENCE + offset, 0x1);\n\t \n\tiwl_trans_write_prph(fwrt->trans,\n\t\t\t     RXF_LD_FENCE_OFFSET_ADDR + offset, 0x0);\n\n\t \n\tfifo_len /= sizeof(u32);  \n\tfor (i = 0; i < fifo_len; i++)\n\t\tfifo_data[i] = iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\t RXF_FIFO_RD_FENCE_INC +\n\t\t\t\t\t\t offset);\n\t*dump_data = iwl_fw_error_next_data(*dump_data);\n}\n\nstatic void iwl_fwrt_dump_txf(struct iwl_fw_runtime *fwrt,\n\t\t\t      struct iwl_fw_error_dump_data **dump_data,\n\t\t\t      int size, u32 offset, int fifo_num)\n{\n\tstruct iwl_fw_error_dump_fifo *fifo_hdr;\n\tu32 *fifo_data;\n\tu32 fifo_len;\n\tint i;\n\n\tfifo_hdr = (void *)(*dump_data)->data;\n\tfifo_data = (void *)fifo_hdr->data;\n\tfifo_len = size;\n\n\t \n\tif (fifo_len == 0)\n\t\treturn;\n\n\t \n\t(*dump_data)->type = cpu_to_le32(IWL_FW_ERROR_DUMP_TXF);\n\t(*dump_data)->len = cpu_to_le32(fifo_len + sizeof(*fifo_hdr));\n\n\tfifo_hdr->fifo_num = cpu_to_le32(fifo_num);\n\tfifo_hdr->available_bytes =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tTXF_FIFO_ITEM_CNT + offset));\n\tfifo_hdr->wr_ptr =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tTXF_WR_PTR + offset));\n\tfifo_hdr->rd_ptr =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tTXF_RD_PTR + offset));\n\tfifo_hdr->fence_ptr =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tTXF_FENCE_PTR + offset));\n\tfifo_hdr->fence_mode =\n\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\tTXF_LOCK_FENCE + offset));\n\n\t \n\tiwl_trans_write_prph(fwrt->trans, TXF_READ_MODIFY_ADDR + offset,\n\t\t\t     TXF_WR_PTR + offset);\n\n\t \n\tiwl_trans_read_prph(fwrt->trans, TXF_READ_MODIFY_DATA + offset);\n\n\t \n\tfor (i = 0; i < fifo_len / sizeof(u32); i++)\n\t\tfifo_data[i] = iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\t  TXF_READ_MODIFY_DATA +\n\t\t\t\t\t\t  offset);\n\n\tif (fwrt->sanitize_ops && fwrt->sanitize_ops->frob_txf)\n\t\tfwrt->sanitize_ops->frob_txf(fwrt->sanitize_ctx,\n\t\t\t\t\t     fifo_data, fifo_len);\n\n\t*dump_data = iwl_fw_error_next_data(*dump_data);\n}\n\nstatic void iwl_fw_dump_rxf(struct iwl_fw_runtime *fwrt,\n\t\t\t    struct iwl_fw_error_dump_data **dump_data)\n{\n\tstruct iwl_fwrt_shared_mem_cfg *cfg = &fwrt->smem_cfg;\n\n\tIWL_DEBUG_INFO(fwrt, \"WRT RX FIFO dump\\n\");\n\n\tif (!iwl_trans_grab_nic_access(fwrt->trans))\n\t\treturn;\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_RXF)) {\n\t\t \n\t\tiwl_fwrt_dump_rxf(fwrt, dump_data,\n\t\t\t\t  cfg->lmac[0].rxfifo1_size, 0, 0);\n\t\t \n\t\tiwl_fwrt_dump_rxf(fwrt, dump_data, cfg->rxfifo2_size,\n\t\t\t\t  RXF_DIFF_FROM_PREV +\n\t\t\t\t  fwrt->trans->trans_cfg->umac_prph_offset, 1);\n\t\t \n\t\tif (fwrt->smem_cfg.num_lmacs > 1)\n\t\t\tiwl_fwrt_dump_rxf(fwrt, dump_data,\n\t\t\t\t\t  cfg->lmac[1].rxfifo1_size,\n\t\t\t\t\t  LMAC2_PRPH_OFFSET, 2);\n\t}\n\n\tiwl_trans_release_nic_access(fwrt->trans);\n}\n\nstatic void iwl_fw_dump_txf(struct iwl_fw_runtime *fwrt,\n\t\t\t    struct iwl_fw_error_dump_data **dump_data)\n{\n\tstruct iwl_fw_error_dump_fifo *fifo_hdr;\n\tstruct iwl_fwrt_shared_mem_cfg *cfg = &fwrt->smem_cfg;\n\tu32 *fifo_data;\n\tu32 fifo_len;\n\tint i, j;\n\n\tIWL_DEBUG_INFO(fwrt, \"WRT TX FIFO dump\\n\");\n\n\tif (!iwl_trans_grab_nic_access(fwrt->trans))\n\t\treturn;\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_TXF)) {\n\t\t \n\t\tfor (i = 0; i < fwrt->smem_cfg.num_txfifo_entries; i++) {\n\t\t\t \n\t\t\tiwl_trans_write_prph(fwrt->trans, TXF_LARC_NUM, i);\n\t\t\tiwl_fwrt_dump_txf(fwrt, dump_data,\n\t\t\t\t\t  cfg->lmac[0].txfifo_size[i], 0, i);\n\t\t}\n\n\t\t \n\t\tif (fwrt->smem_cfg.num_lmacs > 1) {\n\t\t\tfor (i = 0; i < fwrt->smem_cfg.num_txfifo_entries;\n\t\t\t     i++) {\n\t\t\t\t \n\t\t\t\tiwl_trans_write_prph(fwrt->trans,\n\t\t\t\t\t\t     TXF_LARC_NUM +\n\t\t\t\t\t\t     LMAC2_PRPH_OFFSET, i);\n\t\t\t\tiwl_fwrt_dump_txf(fwrt, dump_data,\n\t\t\t\t\t\t  cfg->lmac[1].txfifo_size[i],\n\t\t\t\t\t\t  LMAC2_PRPH_OFFSET,\n\t\t\t\t\t\t  i + cfg->num_txfifo_entries);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_INTERNAL_TXF) &&\n\t    fw_has_capa(&fwrt->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_EXTEND_SHARED_MEM_CFG)) {\n\t\t \n\t\tfor (i = 0;\n\t\t     i < ARRAY_SIZE(fwrt->smem_cfg.internal_txfifo_size);\n\t\t     i++) {\n\t\t\tfifo_hdr = (void *)(*dump_data)->data;\n\t\t\tfifo_data = (void *)fifo_hdr->data;\n\t\t\tfifo_len = fwrt->smem_cfg.internal_txfifo_size[i];\n\n\t\t\t \n\t\t\tif (fifo_len == 0)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\t(*dump_data)->type =\n\t\t\t\tcpu_to_le32(IWL_FW_ERROR_DUMP_INTERNAL_TXF);\n\t\t\t(*dump_data)->len =\n\t\t\t\tcpu_to_le32(fifo_len + sizeof(*fifo_hdr));\n\n\t\t\tfifo_hdr->fifo_num = cpu_to_le32(i);\n\n\t\t\t \n\t\t\tiwl_trans_write_prph(fwrt->trans, TXF_CPU2_NUM, i +\n\t\t\t\tfwrt->smem_cfg.num_txfifo_entries);\n\n\t\t\tfifo_hdr->available_bytes =\n\t\t\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\t\t\tTXF_CPU2_FIFO_ITEM_CNT));\n\t\t\tfifo_hdr->wr_ptr =\n\t\t\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\t\t\tTXF_CPU2_WR_PTR));\n\t\t\tfifo_hdr->rd_ptr =\n\t\t\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\t\t\tTXF_CPU2_RD_PTR));\n\t\t\tfifo_hdr->fence_ptr =\n\t\t\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\t\t\tTXF_CPU2_FENCE_PTR));\n\t\t\tfifo_hdr->fence_mode =\n\t\t\t\tcpu_to_le32(iwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\t\t\tTXF_CPU2_LOCK_FENCE));\n\n\t\t\t \n\t\t\tiwl_trans_write_prph(fwrt->trans,\n\t\t\t\t\t     TXF_CPU2_READ_MODIFY_ADDR,\n\t\t\t\t\t     TXF_CPU2_WR_PTR);\n\n\t\t\t \n\t\t\tiwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t    TXF_CPU2_READ_MODIFY_DATA);\n\n\t\t\t \n\t\t\tfifo_len /= sizeof(u32);  \n\t\t\tfor (j = 0; j < fifo_len; j++)\n\t\t\t\tfifo_data[j] =\n\t\t\t\t\tiwl_trans_read_prph(fwrt->trans,\n\t\t\t\t\t\t\t    TXF_CPU2_READ_MODIFY_DATA);\n\t\t\t*dump_data = iwl_fw_error_next_data(*dump_data);\n\t\t}\n\t}\n\n\tiwl_trans_release_nic_access(fwrt->trans);\n}\n\nstruct iwl_prph_range {\n\tu32 start, end;\n};\n\nstatic const struct iwl_prph_range iwl_prph_dump_addr_comm[] = {\n\t{ .start = 0x00a00000, .end = 0x00a00000 },\n\t{ .start = 0x00a0000c, .end = 0x00a00024 },\n\t{ .start = 0x00a0002c, .end = 0x00a0003c },\n\t{ .start = 0x00a00410, .end = 0x00a00418 },\n\t{ .start = 0x00a00420, .end = 0x00a00420 },\n\t{ .start = 0x00a00428, .end = 0x00a00428 },\n\t{ .start = 0x00a00430, .end = 0x00a0043c },\n\t{ .start = 0x00a00444, .end = 0x00a00444 },\n\t{ .start = 0x00a004c0, .end = 0x00a004cc },\n\t{ .start = 0x00a004d8, .end = 0x00a004d8 },\n\t{ .start = 0x00a004e0, .end = 0x00a004f0 },\n\t{ .start = 0x00a00840, .end = 0x00a00840 },\n\t{ .start = 0x00a00850, .end = 0x00a00858 },\n\t{ .start = 0x00a01004, .end = 0x00a01008 },\n\t{ .start = 0x00a01010, .end = 0x00a01010 },\n\t{ .start = 0x00a01018, .end = 0x00a01018 },\n\t{ .start = 0x00a01024, .end = 0x00a01024 },\n\t{ .start = 0x00a0102c, .end = 0x00a01034 },\n\t{ .start = 0x00a0103c, .end = 0x00a01040 },\n\t{ .start = 0x00a01048, .end = 0x00a01094 },\n\t{ .start = 0x00a01c00, .end = 0x00a01c20 },\n\t{ .start = 0x00a01c58, .end = 0x00a01c58 },\n\t{ .start = 0x00a01c7c, .end = 0x00a01c7c },\n\t{ .start = 0x00a01c28, .end = 0x00a01c54 },\n\t{ .start = 0x00a01c5c, .end = 0x00a01c5c },\n\t{ .start = 0x00a01c60, .end = 0x00a01cdc },\n\t{ .start = 0x00a01ce0, .end = 0x00a01d0c },\n\t{ .start = 0x00a01d18, .end = 0x00a01d20 },\n\t{ .start = 0x00a01d2c, .end = 0x00a01d30 },\n\t{ .start = 0x00a01d40, .end = 0x00a01d5c },\n\t{ .start = 0x00a01d80, .end = 0x00a01d80 },\n\t{ .start = 0x00a01d98, .end = 0x00a01d9c },\n\t{ .start = 0x00a01da8, .end = 0x00a01da8 },\n\t{ .start = 0x00a01db8, .end = 0x00a01df4 },\n\t{ .start = 0x00a01dc0, .end = 0x00a01dfc },\n\t{ .start = 0x00a01e00, .end = 0x00a01e2c },\n\t{ .start = 0x00a01e40, .end = 0x00a01e60 },\n\t{ .start = 0x00a01e68, .end = 0x00a01e6c },\n\t{ .start = 0x00a01e74, .end = 0x00a01e74 },\n\t{ .start = 0x00a01e84, .end = 0x00a01e90 },\n\t{ .start = 0x00a01e9c, .end = 0x00a01ec4 },\n\t{ .start = 0x00a01ed0, .end = 0x00a01ee0 },\n\t{ .start = 0x00a01f00, .end = 0x00a01f1c },\n\t{ .start = 0x00a01f44, .end = 0x00a01ffc },\n\t{ .start = 0x00a02000, .end = 0x00a02048 },\n\t{ .start = 0x00a02068, .end = 0x00a020f0 },\n\t{ .start = 0x00a02100, .end = 0x00a02118 },\n\t{ .start = 0x00a02140, .end = 0x00a0214c },\n\t{ .start = 0x00a02168, .end = 0x00a0218c },\n\t{ .start = 0x00a021c0, .end = 0x00a021c0 },\n\t{ .start = 0x00a02400, .end = 0x00a02410 },\n\t{ .start = 0x00a02418, .end = 0x00a02420 },\n\t{ .start = 0x00a02428, .end = 0x00a0242c },\n\t{ .start = 0x00a02434, .end = 0x00a02434 },\n\t{ .start = 0x00a02440, .end = 0x00a02460 },\n\t{ .start = 0x00a02468, .end = 0x00a024b0 },\n\t{ .start = 0x00a024c8, .end = 0x00a024cc },\n\t{ .start = 0x00a02500, .end = 0x00a02504 },\n\t{ .start = 0x00a0250c, .end = 0x00a02510 },\n\t{ .start = 0x00a02540, .end = 0x00a02554 },\n\t{ .start = 0x00a02580, .end = 0x00a025f4 },\n\t{ .start = 0x00a02600, .end = 0x00a0260c },\n\t{ .start = 0x00a02648, .end = 0x00a02650 },\n\t{ .start = 0x00a02680, .end = 0x00a02680 },\n\t{ .start = 0x00a026c0, .end = 0x00a026d0 },\n\t{ .start = 0x00a02700, .end = 0x00a0270c },\n\t{ .start = 0x00a02804, .end = 0x00a02804 },\n\t{ .start = 0x00a02818, .end = 0x00a0281c },\n\t{ .start = 0x00a02c00, .end = 0x00a02db4 },\n\t{ .start = 0x00a02df4, .end = 0x00a02fb0 },\n\t{ .start = 0x00a03000, .end = 0x00a03014 },\n\t{ .start = 0x00a0301c, .end = 0x00a0302c },\n\t{ .start = 0x00a03034, .end = 0x00a03038 },\n\t{ .start = 0x00a03040, .end = 0x00a03048 },\n\t{ .start = 0x00a03060, .end = 0x00a03068 },\n\t{ .start = 0x00a03070, .end = 0x00a03074 },\n\t{ .start = 0x00a0307c, .end = 0x00a0307c },\n\t{ .start = 0x00a03080, .end = 0x00a03084 },\n\t{ .start = 0x00a0308c, .end = 0x00a03090 },\n\t{ .start = 0x00a03098, .end = 0x00a03098 },\n\t{ .start = 0x00a030a0, .end = 0x00a030a0 },\n\t{ .start = 0x00a030a8, .end = 0x00a030b4 },\n\t{ .start = 0x00a030bc, .end = 0x00a030bc },\n\t{ .start = 0x00a030c0, .end = 0x00a0312c },\n\t{ .start = 0x00a03c00, .end = 0x00a03c5c },\n\t{ .start = 0x00a04400, .end = 0x00a04454 },\n\t{ .start = 0x00a04460, .end = 0x00a04474 },\n\t{ .start = 0x00a044c0, .end = 0x00a044ec },\n\t{ .start = 0x00a04500, .end = 0x00a04504 },\n\t{ .start = 0x00a04510, .end = 0x00a04538 },\n\t{ .start = 0x00a04540, .end = 0x00a04548 },\n\t{ .start = 0x00a04560, .end = 0x00a0457c },\n\t{ .start = 0x00a04590, .end = 0x00a04598 },\n\t{ .start = 0x00a045c0, .end = 0x00a045f4 },\n};\n\nstatic const struct iwl_prph_range iwl_prph_dump_addr_9000[] = {\n\t{ .start = 0x00a05c00, .end = 0x00a05c18 },\n\t{ .start = 0x00a05400, .end = 0x00a056e8 },\n\t{ .start = 0x00a08000, .end = 0x00a098bc },\n\t{ .start = 0x00a02400, .end = 0x00a02758 },\n\t{ .start = 0x00a04764, .end = 0x00a0476c },\n\t{ .start = 0x00a04770, .end = 0x00a04774 },\n\t{ .start = 0x00a04620, .end = 0x00a04624 },\n};\n\nstatic const struct iwl_prph_range iwl_prph_dump_addr_22000[] = {\n\t{ .start = 0x00a00000, .end = 0x00a00000 },\n\t{ .start = 0x00a0000c, .end = 0x00a00024 },\n\t{ .start = 0x00a0002c, .end = 0x00a00034 },\n\t{ .start = 0x00a0003c, .end = 0x00a0003c },\n\t{ .start = 0x00a00410, .end = 0x00a00418 },\n\t{ .start = 0x00a00420, .end = 0x00a00420 },\n\t{ .start = 0x00a00428, .end = 0x00a00428 },\n\t{ .start = 0x00a00430, .end = 0x00a0043c },\n\t{ .start = 0x00a00444, .end = 0x00a00444 },\n\t{ .start = 0x00a00840, .end = 0x00a00840 },\n\t{ .start = 0x00a00850, .end = 0x00a00858 },\n\t{ .start = 0x00a01004, .end = 0x00a01008 },\n\t{ .start = 0x00a01010, .end = 0x00a01010 },\n\t{ .start = 0x00a01018, .end = 0x00a01018 },\n\t{ .start = 0x00a01024, .end = 0x00a01024 },\n\t{ .start = 0x00a0102c, .end = 0x00a01034 },\n\t{ .start = 0x00a0103c, .end = 0x00a01040 },\n\t{ .start = 0x00a01048, .end = 0x00a01050 },\n\t{ .start = 0x00a01058, .end = 0x00a01058 },\n\t{ .start = 0x00a01060, .end = 0x00a01070 },\n\t{ .start = 0x00a0108c, .end = 0x00a0108c },\n\t{ .start = 0x00a01c20, .end = 0x00a01c28 },\n\t{ .start = 0x00a01d10, .end = 0x00a01d10 },\n\t{ .start = 0x00a01e28, .end = 0x00a01e2c },\n\t{ .start = 0x00a01e60, .end = 0x00a01e60 },\n\t{ .start = 0x00a01e80, .end = 0x00a01e80 },\n\t{ .start = 0x00a01ea0, .end = 0x00a01ea0 },\n\t{ .start = 0x00a02000, .end = 0x00a0201c },\n\t{ .start = 0x00a02024, .end = 0x00a02024 },\n\t{ .start = 0x00a02040, .end = 0x00a02048 },\n\t{ .start = 0x00a020c0, .end = 0x00a020e0 },\n\t{ .start = 0x00a02400, .end = 0x00a02404 },\n\t{ .start = 0x00a0240c, .end = 0x00a02414 },\n\t{ .start = 0x00a0241c, .end = 0x00a0243c },\n\t{ .start = 0x00a02448, .end = 0x00a024bc },\n\t{ .start = 0x00a024c4, .end = 0x00a024cc },\n\t{ .start = 0x00a02508, .end = 0x00a02508 },\n\t{ .start = 0x00a02510, .end = 0x00a02514 },\n\t{ .start = 0x00a0251c, .end = 0x00a0251c },\n\t{ .start = 0x00a0252c, .end = 0x00a0255c },\n\t{ .start = 0x00a02564, .end = 0x00a025a0 },\n\t{ .start = 0x00a025a8, .end = 0x00a025b4 },\n\t{ .start = 0x00a025c0, .end = 0x00a025c0 },\n\t{ .start = 0x00a025e8, .end = 0x00a025f4 },\n\t{ .start = 0x00a02c08, .end = 0x00a02c18 },\n\t{ .start = 0x00a02c2c, .end = 0x00a02c38 },\n\t{ .start = 0x00a02c68, .end = 0x00a02c78 },\n\t{ .start = 0x00a03000, .end = 0x00a03000 },\n\t{ .start = 0x00a03010, .end = 0x00a03014 },\n\t{ .start = 0x00a0301c, .end = 0x00a0302c },\n\t{ .start = 0x00a03034, .end = 0x00a03038 },\n\t{ .start = 0x00a03040, .end = 0x00a03044 },\n\t{ .start = 0x00a03060, .end = 0x00a03068 },\n\t{ .start = 0x00a03070, .end = 0x00a03070 },\n\t{ .start = 0x00a0307c, .end = 0x00a03084 },\n\t{ .start = 0x00a0308c, .end = 0x00a03090 },\n\t{ .start = 0x00a03098, .end = 0x00a03098 },\n\t{ .start = 0x00a030a0, .end = 0x00a030a0 },\n\t{ .start = 0x00a030a8, .end = 0x00a030b4 },\n\t{ .start = 0x00a030bc, .end = 0x00a030c0 },\n\t{ .start = 0x00a030c8, .end = 0x00a030f4 },\n\t{ .start = 0x00a03100, .end = 0x00a0312c },\n\t{ .start = 0x00a03c00, .end = 0x00a03c5c },\n\t{ .start = 0x00a04400, .end = 0x00a04454 },\n\t{ .start = 0x00a04460, .end = 0x00a04474 },\n\t{ .start = 0x00a044c0, .end = 0x00a044ec },\n\t{ .start = 0x00a04500, .end = 0x00a04504 },\n\t{ .start = 0x00a04510, .end = 0x00a04538 },\n\t{ .start = 0x00a04540, .end = 0x00a04548 },\n\t{ .start = 0x00a04560, .end = 0x00a04560 },\n\t{ .start = 0x00a04570, .end = 0x00a0457c },\n\t{ .start = 0x00a04590, .end = 0x00a04590 },\n\t{ .start = 0x00a04598, .end = 0x00a04598 },\n\t{ .start = 0x00a045c0, .end = 0x00a045f4 },\n\t{ .start = 0x00a05c18, .end = 0x00a05c1c },\n\t{ .start = 0x00a0c000, .end = 0x00a0c018 },\n\t{ .start = 0x00a0c020, .end = 0x00a0c028 },\n\t{ .start = 0x00a0c038, .end = 0x00a0c094 },\n\t{ .start = 0x00a0c0c0, .end = 0x00a0c104 },\n\t{ .start = 0x00a0c10c, .end = 0x00a0c118 },\n\t{ .start = 0x00a0c150, .end = 0x00a0c174 },\n\t{ .start = 0x00a0c17c, .end = 0x00a0c188 },\n\t{ .start = 0x00a0c190, .end = 0x00a0c198 },\n\t{ .start = 0x00a0c1a0, .end = 0x00a0c1a8 },\n\t{ .start = 0x00a0c1b0, .end = 0x00a0c1b8 },\n};\n\nstatic const struct iwl_prph_range iwl_prph_dump_addr_ax210[] = {\n\t{ .start = 0x00d03c00, .end = 0x00d03c64 },\n\t{ .start = 0x00d05c18, .end = 0x00d05c1c },\n\t{ .start = 0x00d0c000, .end = 0x00d0c174 },\n};\n\nstatic void iwl_read_prph_block(struct iwl_trans *trans, u32 start,\n\t\t\t\tu32 len_bytes, __le32 *data)\n{\n\tu32 i;\n\n\tfor (i = 0; i < len_bytes; i += 4)\n\t\t*data++ = cpu_to_le32(iwl_read_prph_no_grab(trans, start + i));\n}\n\nstatic void iwl_dump_prph(struct iwl_fw_runtime *fwrt,\n\t\t\t  const struct iwl_prph_range *iwl_prph_dump_addr,\n\t\t\t  u32 range_len, void *ptr)\n{\n\tstruct iwl_fw_error_dump_prph *prph;\n\tstruct iwl_trans *trans = fwrt->trans;\n\tstruct iwl_fw_error_dump_data **data =\n\t\t(struct iwl_fw_error_dump_data **)ptr;\n\tu32 i;\n\n\tif (!data)\n\t\treturn;\n\n\tIWL_DEBUG_INFO(trans, \"WRT PRPH dump\\n\");\n\n\tif (!iwl_trans_grab_nic_access(trans))\n\t\treturn;\n\n\tfor (i = 0; i < range_len; i++) {\n\t\t \n\t\tint num_bytes_in_chunk = iwl_prph_dump_addr[i].end -\n\t\t\t iwl_prph_dump_addr[i].start + 4;\n\n\t\t(*data)->type = cpu_to_le32(IWL_FW_ERROR_DUMP_PRPH);\n\t\t(*data)->len = cpu_to_le32(sizeof(*prph) +\n\t\t\t\t\tnum_bytes_in_chunk);\n\t\tprph = (void *)(*data)->data;\n\t\tprph->prph_start = cpu_to_le32(iwl_prph_dump_addr[i].start);\n\n\t\tiwl_read_prph_block(trans, iwl_prph_dump_addr[i].start,\n\t\t\t\t     \n\t\t\t\t    iwl_prph_dump_addr[i].end -\n\t\t\t\t    iwl_prph_dump_addr[i].start + 4,\n\t\t\t\t    (void *)prph->data);\n\n\t\t*data = iwl_fw_error_next_data(*data);\n\t}\n\n\tiwl_trans_release_nic_access(trans);\n}\n\n \nstatic struct scatterlist *alloc_sgtable(int size)\n{\n\tint alloc_size, nents, i;\n\tstruct page *new_page;\n\tstruct scatterlist *iter;\n\tstruct scatterlist *table;\n\n\tnents = DIV_ROUND_UP(size, PAGE_SIZE);\n\ttable = kcalloc(nents, sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn NULL;\n\tsg_init_table(table, nents);\n\titer = table;\n\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\tnew_page = alloc_page(GFP_KERNEL);\n\t\tif (!new_page) {\n\t\t\t \n\t\t\titer = table;\n\t\t\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\t\t\tnew_page = sg_page(iter);\n\t\t\t\tif (new_page)\n\t\t\t\t\t__free_page(new_page);\n\t\t\t}\n\t\t\tkfree(table);\n\t\t\treturn NULL;\n\t\t}\n\t\talloc_size = min_t(int, size, PAGE_SIZE);\n\t\tsize -= PAGE_SIZE;\n\t\tsg_set_page(iter, new_page, alloc_size, 0);\n\t}\n\treturn table;\n}\n\nstatic void iwl_fw_get_prph_len(struct iwl_fw_runtime *fwrt,\n\t\t\t\tconst struct iwl_prph_range *iwl_prph_dump_addr,\n\t\t\t\tu32 range_len, void *ptr)\n{\n\tu32 *prph_len = (u32 *)ptr;\n\tint i, num_bytes_in_chunk;\n\n\tif (!prph_len)\n\t\treturn;\n\n\tfor (i = 0; i < range_len; i++) {\n\t\t \n\t\tnum_bytes_in_chunk =\n\t\t\tiwl_prph_dump_addr[i].end -\n\t\t\tiwl_prph_dump_addr[i].start + 4;\n\n\t\t*prph_len += sizeof(struct iwl_fw_error_dump_data) +\n\t\t\tsizeof(struct iwl_fw_error_dump_prph) +\n\t\t\tnum_bytes_in_chunk;\n\t}\n}\n\nstatic void iwl_fw_prph_handler(struct iwl_fw_runtime *fwrt, void *ptr,\n\t\t\t\tvoid (*handler)(struct iwl_fw_runtime *,\n\t\t\t\t\t\tconst struct iwl_prph_range *,\n\t\t\t\t\t\tu32, void *))\n{\n\tu32 range_len;\n\n\tif (fwrt->trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_AX210) {\n\t\trange_len = ARRAY_SIZE(iwl_prph_dump_addr_ax210);\n\t\thandler(fwrt, iwl_prph_dump_addr_ax210, range_len, ptr);\n\t} else if (fwrt->trans->trans_cfg->device_family >=\n\t\t   IWL_DEVICE_FAMILY_22000) {\n\t\trange_len = ARRAY_SIZE(iwl_prph_dump_addr_22000);\n\t\thandler(fwrt, iwl_prph_dump_addr_22000, range_len, ptr);\n\t} else {\n\t\trange_len = ARRAY_SIZE(iwl_prph_dump_addr_comm);\n\t\thandler(fwrt, iwl_prph_dump_addr_comm, range_len, ptr);\n\n\t\tif (fwrt->trans->trans_cfg->mq_rx_supported) {\n\t\t\trange_len = ARRAY_SIZE(iwl_prph_dump_addr_9000);\n\t\t\thandler(fwrt, iwl_prph_dump_addr_9000, range_len, ptr);\n\t\t}\n\t}\n}\n\nstatic void iwl_fw_dump_mem(struct iwl_fw_runtime *fwrt,\n\t\t\t    struct iwl_fw_error_dump_data **dump_data,\n\t\t\t    u32 len, u32 ofs, u32 type)\n{\n\tstruct iwl_fw_error_dump_mem *dump_mem;\n\n\tif (!len)\n\t\treturn;\n\n\t(*dump_data)->type = cpu_to_le32(IWL_FW_ERROR_DUMP_MEM);\n\t(*dump_data)->len = cpu_to_le32(len + sizeof(*dump_mem));\n\tdump_mem = (void *)(*dump_data)->data;\n\tdump_mem->type = cpu_to_le32(type);\n\tdump_mem->offset = cpu_to_le32(ofs);\n\tiwl_trans_read_mem_bytes(fwrt->trans, ofs, dump_mem->data, len);\n\t*dump_data = iwl_fw_error_next_data(*dump_data);\n\n\tif (fwrt->sanitize_ops && fwrt->sanitize_ops->frob_mem)\n\t\tfwrt->sanitize_ops->frob_mem(fwrt->sanitize_ctx, ofs,\n\t\t\t\t\t     dump_mem->data, len);\n\n\tIWL_DEBUG_INFO(fwrt, \"WRT memory dump. Type=%u\\n\", dump_mem->type);\n}\n\n#define ADD_LEN(len, item_len, const_len) \\\n\tdo {size_t item = item_len; len += (!!item) * const_len + item; } \\\n\twhile (0)\n\nstatic int iwl_fw_rxf_len(struct iwl_fw_runtime *fwrt,\n\t\t\t  struct iwl_fwrt_shared_mem_cfg *mem_cfg)\n{\n\tsize_t hdr_len = sizeof(struct iwl_fw_error_dump_data) +\n\t\t\t sizeof(struct iwl_fw_error_dump_fifo);\n\tu32 fifo_len = 0;\n\tint i;\n\n\tif (!iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_RXF))\n\t\treturn 0;\n\n\t \n\tADD_LEN(fifo_len, mem_cfg->rxfifo2_size, hdr_len);\n\n\t \n\tif (WARN_ON(mem_cfg->num_lmacs > MAX_NUM_LMAC))\n\t\tmem_cfg->num_lmacs = MAX_NUM_LMAC;\n\n\tfor (i = 0; i < mem_cfg->num_lmacs; i++)\n\t\tADD_LEN(fifo_len, mem_cfg->lmac[i].rxfifo1_size, hdr_len);\n\n\treturn fifo_len;\n}\n\nstatic int iwl_fw_txf_len(struct iwl_fw_runtime *fwrt,\n\t\t\t  struct iwl_fwrt_shared_mem_cfg *mem_cfg)\n{\n\tsize_t hdr_len = sizeof(struct iwl_fw_error_dump_data) +\n\t\t\t sizeof(struct iwl_fw_error_dump_fifo);\n\tu32 fifo_len = 0;\n\tint i;\n\n\tif (!iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_TXF))\n\t\tgoto dump_internal_txf;\n\n\t \n\tif (WARN_ON(mem_cfg->num_lmacs > MAX_NUM_LMAC))\n\t\tmem_cfg->num_lmacs = MAX_NUM_LMAC;\n\n\tfor (i = 0; i < mem_cfg->num_lmacs; i++) {\n\t\tint j;\n\n\t\tfor (j = 0; j < mem_cfg->num_txfifo_entries; j++)\n\t\t\tADD_LEN(fifo_len, mem_cfg->lmac[i].txfifo_size[j],\n\t\t\t\thdr_len);\n\t}\n\ndump_internal_txf:\n\tif (!(iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_INTERNAL_TXF) &&\n\t      fw_has_capa(&fwrt->fw->ucode_capa,\n\t\t\t  IWL_UCODE_TLV_CAPA_EXTEND_SHARED_MEM_CFG)))\n\t\tgoto out;\n\n\tfor (i = 0; i < ARRAY_SIZE(mem_cfg->internal_txfifo_size); i++)\n\t\tADD_LEN(fifo_len, mem_cfg->internal_txfifo_size[i], hdr_len);\n\nout:\n\treturn fifo_len;\n}\n\nstatic void iwl_dump_paging(struct iwl_fw_runtime *fwrt,\n\t\t\t    struct iwl_fw_error_dump_data **data)\n{\n\tint i;\n\n\tIWL_DEBUG_INFO(fwrt, \"WRT paging dump\\n\");\n\tfor (i = 1; i < fwrt->num_of_paging_blk + 1; i++) {\n\t\tstruct iwl_fw_error_dump_paging *paging;\n\t\tstruct page *pages =\n\t\t\tfwrt->fw_paging_db[i].fw_paging_block;\n\t\tdma_addr_t addr = fwrt->fw_paging_db[i].fw_paging_phys;\n\n\t\t(*data)->type = cpu_to_le32(IWL_FW_ERROR_DUMP_PAGING);\n\t\t(*data)->len = cpu_to_le32(sizeof(*paging) +\n\t\t\t\t\t     PAGING_BLOCK_SIZE);\n\t\tpaging =  (void *)(*data)->data;\n\t\tpaging->index = cpu_to_le32(i);\n\t\tdma_sync_single_for_cpu(fwrt->trans->dev, addr,\n\t\t\t\t\tPAGING_BLOCK_SIZE,\n\t\t\t\t\tDMA_BIDIRECTIONAL);\n\t\tmemcpy(paging->data, page_address(pages),\n\t\t       PAGING_BLOCK_SIZE);\n\t\tdma_sync_single_for_device(fwrt->trans->dev, addr,\n\t\t\t\t\t   PAGING_BLOCK_SIZE,\n\t\t\t\t\t   DMA_BIDIRECTIONAL);\n\t\t(*data) = iwl_fw_error_next_data(*data);\n\n\t\tif (fwrt->sanitize_ops && fwrt->sanitize_ops->frob_mem)\n\t\t\tfwrt->sanitize_ops->frob_mem(fwrt->sanitize_ctx,\n\t\t\t\t\t\t     fwrt->fw_paging_db[i].fw_offs,\n\t\t\t\t\t\t     paging->data,\n\t\t\t\t\t\t     PAGING_BLOCK_SIZE);\n\t}\n}\n\nstatic struct iwl_fw_error_dump_file *\niwl_fw_error_dump_file(struct iwl_fw_runtime *fwrt,\n\t\t       struct iwl_fw_dump_ptrs *fw_error_dump,\n\t\t       struct iwl_fwrt_dump_data *data)\n{\n\tstruct iwl_fw_error_dump_file *dump_file;\n\tstruct iwl_fw_error_dump_data *dump_data;\n\tstruct iwl_fw_error_dump_info *dump_info;\n\tstruct iwl_fw_error_dump_smem_cfg *dump_smem_cfg;\n\tstruct iwl_fw_error_dump_trigger_desc *dump_trig;\n\tu32 sram_len, sram_ofs;\n\tconst struct iwl_fw_dbg_mem_seg_tlv *fw_mem = fwrt->fw->dbg.mem_tlv;\n\tstruct iwl_fwrt_shared_mem_cfg *mem_cfg = &fwrt->smem_cfg;\n\tu32 file_len, fifo_len = 0, prph_len = 0, radio_len = 0;\n\tu32 smem_len = fwrt->fw->dbg.n_mem_tlv ? 0 : fwrt->trans->cfg->smem_len;\n\tu32 sram2_len = fwrt->fw->dbg.n_mem_tlv ?\n\t\t\t\t0 : fwrt->trans->cfg->dccm2_len;\n\tint i;\n\n\t \n\tif (!fwrt->trans->cfg->dccm_offset || !fwrt->trans->cfg->dccm_len) {\n\t\tconst struct fw_img *img;\n\n\t\tif (fwrt->cur_fw_img >= IWL_UCODE_TYPE_MAX)\n\t\t\treturn NULL;\n\t\timg = &fwrt->fw->img[fwrt->cur_fw_img];\n\t\tsram_ofs = img->sec[IWL_UCODE_SECTION_DATA].offset;\n\t\tsram_len = img->sec[IWL_UCODE_SECTION_DATA].len;\n\t} else {\n\t\tsram_ofs = fwrt->trans->cfg->dccm_offset;\n\t\tsram_len = fwrt->trans->cfg->dccm_len;\n\t}\n\n\t \n\tif (test_bit(STATUS_FW_ERROR, &fwrt->trans->status)) {\n\t\tfifo_len = iwl_fw_rxf_len(fwrt, mem_cfg);\n\t\tfifo_len += iwl_fw_txf_len(fwrt, mem_cfg);\n\n\t\t \n\t\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_PRPH))\n\t\t\tiwl_fw_prph_handler(fwrt, &prph_len,\n\t\t\t\t\t    iwl_fw_get_prph_len);\n\n\t\tif (fwrt->trans->trans_cfg->device_family ==\n\t\t    IWL_DEVICE_FAMILY_7000 &&\n\t\t    iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_RADIO_REG))\n\t\t\tradio_len = sizeof(*dump_data) + RADIO_REG_MAX_READ;\n\t}\n\n\tfile_len = sizeof(*dump_file) + fifo_len + prph_len + radio_len;\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_DEV_FW_INFO))\n\t\tfile_len += sizeof(*dump_data) + sizeof(*dump_info);\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_MEM_CFG))\n\t\tfile_len += sizeof(*dump_data) + sizeof(*dump_smem_cfg);\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_MEM)) {\n\t\tsize_t hdr_len = sizeof(*dump_data) +\n\t\t\t\t sizeof(struct iwl_fw_error_dump_mem);\n\n\t\t \n\t\tif (!fwrt->fw->dbg.n_mem_tlv)\n\t\t\tADD_LEN(file_len, sram_len, hdr_len);\n\n\t\t \n\t\tADD_LEN(file_len, smem_len, hdr_len);\n\t\tADD_LEN(file_len, sram2_len, hdr_len);\n\n\t\tfor (i = 0; i < fwrt->fw->dbg.n_mem_tlv; i++)\n\t\t\tADD_LEN(file_len, le32_to_cpu(fw_mem[i].len), hdr_len);\n\t}\n\n\t \n\tif (iwl_fw_dbg_is_paging_enabled(fwrt))\n\t\tfile_len += fwrt->num_of_paging_blk *\n\t\t\t(sizeof(*dump_data) +\n\t\t\t sizeof(struct iwl_fw_error_dump_paging) +\n\t\t\t PAGING_BLOCK_SIZE);\n\n\tif (iwl_fw_dbg_is_d3_debug_enabled(fwrt) && fwrt->dump.d3_debug_data) {\n\t\tfile_len += sizeof(*dump_data) +\n\t\t\tfwrt->trans->cfg->d3_debug_data_length * 2;\n\t}\n\n\t \n\tif (data->monitor_only) {\n\t\tfile_len = sizeof(*dump_file) + sizeof(*dump_data) * 2 +\n\t\t\t   sizeof(*dump_info) + sizeof(*dump_smem_cfg);\n\t}\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_ERROR_INFO) &&\n\t    data->desc)\n\t\tfile_len += sizeof(*dump_data) + sizeof(*dump_trig) +\n\t\t\tdata->desc->len;\n\n\tdump_file = vzalloc(file_len);\n\tif (!dump_file)\n\t\treturn NULL;\n\n\tfw_error_dump->fwrt_ptr = dump_file;\n\n\tdump_file->barker = cpu_to_le32(IWL_FW_ERROR_DUMP_BARKER);\n\tdump_data = (void *)dump_file->data;\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_DEV_FW_INFO)) {\n\t\tdump_data->type = cpu_to_le32(IWL_FW_ERROR_DUMP_DEV_FW_INFO);\n\t\tdump_data->len = cpu_to_le32(sizeof(*dump_info));\n\t\tdump_info = (void *)dump_data->data;\n\t\tdump_info->hw_type =\n\t\t\tcpu_to_le32(CSR_HW_REV_TYPE(fwrt->trans->hw_rev));\n\t\tdump_info->hw_step =\n\t\t\tcpu_to_le32(fwrt->trans->hw_rev_step);\n\t\tmemcpy(dump_info->fw_human_readable, fwrt->fw->human_readable,\n\t\t       sizeof(dump_info->fw_human_readable));\n\t\tstrncpy(dump_info->dev_human_readable, fwrt->trans->name,\n\t\t\tsizeof(dump_info->dev_human_readable) - 1);\n\t\tstrncpy(dump_info->bus_human_readable, fwrt->dev->bus->name,\n\t\t\tsizeof(dump_info->bus_human_readable) - 1);\n\t\tdump_info->num_of_lmacs = fwrt->smem_cfg.num_lmacs;\n\t\tdump_info->lmac_err_id[0] =\n\t\t\tcpu_to_le32(fwrt->dump.lmac_err_id[0]);\n\t\tif (fwrt->smem_cfg.num_lmacs > 1)\n\t\t\tdump_info->lmac_err_id[1] =\n\t\t\t\tcpu_to_le32(fwrt->dump.lmac_err_id[1]);\n\t\tdump_info->umac_err_id = cpu_to_le32(fwrt->dump.umac_err_id);\n\n\t\tdump_data = iwl_fw_error_next_data(dump_data);\n\t}\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_MEM_CFG)) {\n\t\t \n\t\tdump_data->type = cpu_to_le32(IWL_FW_ERROR_DUMP_MEM_CFG);\n\t\tdump_data->len = cpu_to_le32(sizeof(*dump_smem_cfg));\n\t\tdump_smem_cfg = (void *)dump_data->data;\n\t\tdump_smem_cfg->num_lmacs = cpu_to_le32(mem_cfg->num_lmacs);\n\t\tdump_smem_cfg->num_txfifo_entries =\n\t\t\tcpu_to_le32(mem_cfg->num_txfifo_entries);\n\t\tfor (i = 0; i < MAX_NUM_LMAC; i++) {\n\t\t\tint j;\n\t\t\tu32 *txf_size = mem_cfg->lmac[i].txfifo_size;\n\n\t\t\tfor (j = 0; j < TX_FIFO_MAX_NUM; j++)\n\t\t\t\tdump_smem_cfg->lmac[i].txfifo_size[j] =\n\t\t\t\t\tcpu_to_le32(txf_size[j]);\n\t\t\tdump_smem_cfg->lmac[i].rxfifo1_size =\n\t\t\t\tcpu_to_le32(mem_cfg->lmac[i].rxfifo1_size);\n\t\t}\n\t\tdump_smem_cfg->rxfifo2_size =\n\t\t\tcpu_to_le32(mem_cfg->rxfifo2_size);\n\t\tdump_smem_cfg->internal_txfifo_addr =\n\t\t\tcpu_to_le32(mem_cfg->internal_txfifo_addr);\n\t\tfor (i = 0; i < TX_FIFO_INTERNAL_MAX_NUM; i++) {\n\t\t\tdump_smem_cfg->internal_txfifo_size[i] =\n\t\t\t\tcpu_to_le32(mem_cfg->internal_txfifo_size[i]);\n\t\t}\n\n\t\tdump_data = iwl_fw_error_next_data(dump_data);\n\t}\n\n\t \n\tif (fifo_len) {\n\t\tiwl_fw_dump_rxf(fwrt, &dump_data);\n\t\tiwl_fw_dump_txf(fwrt, &dump_data);\n\t}\n\n\tif (radio_len)\n\t\tiwl_read_radio_regs(fwrt, &dump_data);\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_ERROR_INFO) &&\n\t    data->desc) {\n\t\tdump_data->type = cpu_to_le32(IWL_FW_ERROR_DUMP_ERROR_INFO);\n\t\tdump_data->len = cpu_to_le32(sizeof(*dump_trig) +\n\t\t\t\t\t     data->desc->len);\n\t\tdump_trig = (void *)dump_data->data;\n\t\tmemcpy(dump_trig, &data->desc->trig_desc,\n\t\t       sizeof(*dump_trig) + data->desc->len);\n\n\t\tdump_data = iwl_fw_error_next_data(dump_data);\n\t}\n\n\t \n\tif (data->monitor_only)\n\t\tgoto out;\n\n\tif (iwl_fw_dbg_type_on(fwrt, IWL_FW_ERROR_DUMP_MEM)) {\n\t\tconst struct iwl_fw_dbg_mem_seg_tlv *fw_dbg_mem =\n\t\t\tfwrt->fw->dbg.mem_tlv;\n\n\t\tif (!fwrt->fw->dbg.n_mem_tlv)\n\t\t\tiwl_fw_dump_mem(fwrt, &dump_data, sram_len, sram_ofs,\n\t\t\t\t\tIWL_FW_ERROR_DUMP_MEM_SRAM);\n\n\t\tfor (i = 0; i < fwrt->fw->dbg.n_mem_tlv; i++) {\n\t\t\tu32 len = le32_to_cpu(fw_dbg_mem[i].len);\n\t\t\tu32 ofs = le32_to_cpu(fw_dbg_mem[i].ofs);\n\n\t\t\tiwl_fw_dump_mem(fwrt, &dump_data, len, ofs,\n\t\t\t\t\tle32_to_cpu(fw_dbg_mem[i].data_type));\n\t\t}\n\n\t\tiwl_fw_dump_mem(fwrt, &dump_data, smem_len,\n\t\t\t\tfwrt->trans->cfg->smem_offset,\n\t\t\t\tIWL_FW_ERROR_DUMP_MEM_SMEM);\n\n\t\tiwl_fw_dump_mem(fwrt, &dump_data, sram2_len,\n\t\t\t\tfwrt->trans->cfg->dccm2_offset,\n\t\t\t\tIWL_FW_ERROR_DUMP_MEM_SRAM);\n\t}\n\n\tif (iwl_fw_dbg_is_d3_debug_enabled(fwrt) && fwrt->dump.d3_debug_data) {\n\t\tu32 addr = fwrt->trans->cfg->d3_debug_data_base_addr;\n\t\tsize_t data_size = fwrt->trans->cfg->d3_debug_data_length;\n\n\t\tdump_data->type = cpu_to_le32(IWL_FW_ERROR_DUMP_D3_DEBUG_DATA);\n\t\tdump_data->len = cpu_to_le32(data_size * 2);\n\n\t\tmemcpy(dump_data->data, fwrt->dump.d3_debug_data, data_size);\n\n\t\tkfree(fwrt->dump.d3_debug_data);\n\t\tfwrt->dump.d3_debug_data = NULL;\n\n\t\tiwl_trans_read_mem_bytes(fwrt->trans, addr,\n\t\t\t\t\t dump_data->data + data_size,\n\t\t\t\t\t data_size);\n\n\t\tif (fwrt->sanitize_ops && fwrt->sanitize_ops->frob_mem)\n\t\t\tfwrt->sanitize_ops->frob_mem(fwrt->sanitize_ctx, addr,\n\t\t\t\t\t\t     dump_data->data + data_size,\n\t\t\t\t\t\t     data_size);\n\n\t\tdump_data = iwl_fw_error_next_data(dump_data);\n\t}\n\n\t \n\tif (iwl_fw_dbg_is_paging_enabled(fwrt))\n\t\tiwl_dump_paging(fwrt, &dump_data);\n\n\tif (prph_len)\n\t\tiwl_fw_prph_handler(fwrt, &dump_data, iwl_dump_prph);\n\nout:\n\tdump_file->file_len = cpu_to_le32(file_len);\n\treturn dump_file;\n}\n\n \nstruct iwl_dump_ini_region_data {\n\tstruct iwl_ucode_tlv *reg_tlv;\n\tstruct iwl_fwrt_dump_data *dump_data;\n};\n\nstatic int\niwl_dump_ini_prph_mac_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t   struct iwl_dump_ini_region_data *reg_data,\n\t\t\t   void *range_ptr, u32 range_len, int idx)\n{\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\t__le32 *val = range->data;\n\tu32 prph_val;\n\tu32 addr = le32_to_cpu(reg->addrs[idx]) +\n\t\t   le32_to_cpu(reg->dev_addr.offset);\n\tint i;\n\n\trange->internal_base_addr = cpu_to_le32(addr);\n\trange->range_data_size = reg->dev_addr.size;\n\tfor (i = 0; i < le32_to_cpu(reg->dev_addr.size); i += 4) {\n\t\tprph_val = iwl_read_prph(fwrt->trans, addr + i);\n\t\tif (iwl_trans_is_hw_error_value(prph_val))\n\t\t\treturn -EBUSY;\n\t\t*val++ = cpu_to_le32(prph_val);\n\t}\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic int\niwl_dump_ini_prph_phy_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t   struct iwl_dump_ini_region_data *reg_data,\n\t\t\t   void *range_ptr, u32 range_len, int idx)\n{\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\t__le32 *val = range->data;\n\tu32 indirect_wr_addr = WMAL_INDRCT_RD_CMD1;\n\tu32 indirect_rd_addr = WMAL_MRSPF_1;\n\tu32 prph_val;\n\tu32 addr = le32_to_cpu(reg->addrs[idx]);\n\tu32 dphy_state;\n\tu32 dphy_addr;\n\tint i;\n\n\trange->internal_base_addr = cpu_to_le32(addr);\n\trange->range_data_size = reg->dev_addr.size;\n\n\tif (fwrt->trans->trans_cfg->device_family < IWL_DEVICE_FAMILY_AX210)\n\t\tindirect_wr_addr = WMAL_INDRCT_CMD1;\n\n\tindirect_wr_addr += le32_to_cpu(reg->dev_addr.offset);\n\tindirect_rd_addr += le32_to_cpu(reg->dev_addr.offset);\n\n\tif (!iwl_trans_grab_nic_access(fwrt->trans))\n\t\treturn -EBUSY;\n\n\tdphy_addr = (reg->dev_addr.offset) ? WFPM_LMAC2_PS_CTL_RW :\n\t\t\t\t\t     WFPM_LMAC1_PS_CTL_RW;\n\tdphy_state = iwl_read_umac_prph_no_grab(fwrt->trans, dphy_addr);\n\n\tfor (i = 0; i < le32_to_cpu(reg->dev_addr.size); i += 4) {\n\t\tif (dphy_state == HBUS_TIMEOUT ||\n\t\t    (dphy_state & WFPM_PS_CTL_RW_PHYRF_PD_FSM_CURSTATE_MSK) !=\n\t\t    WFPM_PHYRF_STATE_ON) {\n\t\t\t*val++ = cpu_to_le32(WFPM_DPHY_OFF);\n\t\t\tcontinue;\n\t\t}\n\n\t\tiwl_write_prph_no_grab(fwrt->trans, indirect_wr_addr,\n\t\t\t\t       WMAL_INDRCT_CMD(addr + i));\n\t\tprph_val = iwl_read_prph_no_grab(fwrt->trans,\n\t\t\t\t\t\t indirect_rd_addr);\n\t\t*val++ = cpu_to_le32(prph_val);\n\t}\n\n\tiwl_trans_release_nic_access(fwrt->trans);\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic int iwl_dump_ini_csr_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t\t struct iwl_dump_ini_region_data *reg_data,\n\t\t\t\t void *range_ptr, u32 range_len, int idx)\n{\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\t__le32 *val = range->data;\n\tu32 addr = le32_to_cpu(reg->addrs[idx]) +\n\t\t   le32_to_cpu(reg->dev_addr.offset);\n\tint i;\n\n\trange->internal_base_addr = cpu_to_le32(addr);\n\trange->range_data_size = reg->dev_addr.size;\n\tfor (i = 0; i < le32_to_cpu(reg->dev_addr.size); i += 4)\n\t\t*val++ = cpu_to_le32(iwl_trans_read32(fwrt->trans, addr + i));\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic int iwl_dump_ini_config_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t\t    struct iwl_dump_ini_region_data *reg_data,\n\t\t\t\t    void *range_ptr, u32 range_len, int idx)\n{\n\tstruct iwl_trans *trans = fwrt->trans;\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\t__le32 *val = range->data;\n\tu32 addr = le32_to_cpu(reg->addrs[idx]) +\n\t\t   le32_to_cpu(reg->dev_addr.offset);\n\tint i;\n\n\t \n\tif (WARN_ON_ONCE(!trans->ops->read_config32))\n\t\treturn -EOPNOTSUPP;\n\n\trange->internal_base_addr = cpu_to_le32(addr);\n\trange->range_data_size = reg->dev_addr.size;\n\tfor (i = 0; i < le32_to_cpu(reg->dev_addr.size); i += 4) {\n\t\tint ret;\n\t\tu32 tmp;\n\n\t\tret = trans->ops->read_config32(trans, addr + i, &tmp);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*val++ = cpu_to_le32(tmp);\n\t}\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic int iwl_dump_ini_dev_mem_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t\t     struct iwl_dump_ini_region_data *reg_data,\n\t\t\t\t     void *range_ptr, u32 range_len, int idx)\n{\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\tu32 addr = le32_to_cpu(reg->addrs[idx]) +\n\t\t   le32_to_cpu(reg->dev_addr.offset);\n\n\trange->internal_base_addr = cpu_to_le32(addr);\n\trange->range_data_size = reg->dev_addr.size;\n\tiwl_trans_read_mem_bytes(fwrt->trans, addr, range->data,\n\t\t\t\t le32_to_cpu(reg->dev_addr.size));\n\n\tif (reg->sub_type == IWL_FW_INI_REGION_DEVICE_MEMORY_SUBTYPE_HW_SMEM &&\n\t    fwrt->sanitize_ops && fwrt->sanitize_ops->frob_txf)\n\t\tfwrt->sanitize_ops->frob_txf(fwrt->sanitize_ctx,\n\t\t\t\t\t     range->data,\n\t\t\t\t\t     le32_to_cpu(reg->dev_addr.size));\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic int _iwl_dump_ini_paging_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t\t     void *range_ptr, u32 range_len, int idx)\n{\n\tstruct page *page = fwrt->fw_paging_db[idx].fw_paging_block;\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\tdma_addr_t addr = fwrt->fw_paging_db[idx].fw_paging_phys;\n\tu32 page_size = fwrt->fw_paging_db[idx].fw_paging_size;\n\n\trange->page_num = cpu_to_le32(idx);\n\trange->range_data_size = cpu_to_le32(page_size);\n\tdma_sync_single_for_cpu(fwrt->trans->dev, addr,\tpage_size,\n\t\t\t\tDMA_BIDIRECTIONAL);\n\tmemcpy(range->data, page_address(page), page_size);\n\tdma_sync_single_for_device(fwrt->trans->dev, addr, page_size,\n\t\t\t\t   DMA_BIDIRECTIONAL);\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic int iwl_dump_ini_paging_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t\t    struct iwl_dump_ini_region_data *reg_data,\n\t\t\t\t    void *range_ptr, u32 range_len, int idx)\n{\n\tstruct iwl_fw_ini_error_dump_range *range;\n\tu32 page_size;\n\n\t \n\tidx++;\n\n\tif (!fwrt->trans->trans_cfg->gen2)\n\t\treturn _iwl_dump_ini_paging_iter(fwrt, range_ptr, range_len, idx);\n\n\trange = range_ptr;\n\tpage_size = fwrt->trans->init_dram.paging[idx].size;\n\n\trange->page_num = cpu_to_le32(idx);\n\trange->range_data_size = cpu_to_le32(page_size);\n\tmemcpy(range->data, fwrt->trans->init_dram.paging[idx].block,\n\t       page_size);\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic int\niwl_dump_ini_mon_dram_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t   struct iwl_dump_ini_region_data *reg_data,\n\t\t\t   void *range_ptr, u32 range_len, int idx)\n{\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\tstruct iwl_dram_data *frag;\n\tu32 alloc_id = le32_to_cpu(reg->dram_alloc_id);\n\n\tfrag = &fwrt->trans->dbg.fw_mon_ini[alloc_id].frags[idx];\n\n\trange->dram_base_addr = cpu_to_le64(frag->physical);\n\trange->range_data_size = cpu_to_le32(frag->size);\n\n\tmemcpy(range->data, frag->block, frag->size);\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic int iwl_dump_ini_mon_smem_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t\t      struct iwl_dump_ini_region_data *reg_data,\n\t\t\t\t      void *range_ptr, u32 range_len, int idx)\n{\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\tu32 addr = le32_to_cpu(reg->internal_buffer.base_addr);\n\n\trange->internal_base_addr = cpu_to_le32(addr);\n\trange->range_data_size = reg->internal_buffer.size;\n\tiwl_trans_read_mem_bytes(fwrt->trans, addr, range->data,\n\t\t\t\t le32_to_cpu(reg->internal_buffer.size));\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic bool iwl_ini_txf_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t     struct iwl_dump_ini_region_data *reg_data, int idx)\n{\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tstruct iwl_txf_iter_data *iter = &fwrt->dump.txf_iter_data;\n\tstruct iwl_fwrt_shared_mem_cfg *cfg = &fwrt->smem_cfg;\n\tint txf_num = cfg->num_txfifo_entries;\n\tint int_txf_num = ARRAY_SIZE(cfg->internal_txfifo_size);\n\tu32 lmac_bitmap = le32_to_cpu(reg->fifos.fid[0]);\n\n\tif (!idx) {\n\t\tif (le32_to_cpu(reg->fifos.offset) && cfg->num_lmacs == 1) {\n\t\t\tIWL_ERR(fwrt, \"WRT: Invalid lmac offset 0x%x\\n\",\n\t\t\t\tle32_to_cpu(reg->fifos.offset));\n\t\t\treturn false;\n\t\t}\n\n\t\titer->internal_txf = 0;\n\t\titer->fifo_size = 0;\n\t\titer->fifo = -1;\n\t\tif (le32_to_cpu(reg->fifos.offset))\n\t\t\titer->lmac = 1;\n\t\telse\n\t\t\titer->lmac = 0;\n\t}\n\n\tif (!iter->internal_txf) {\n\t\tfor (iter->fifo++; iter->fifo < txf_num; iter->fifo++) {\n\t\t\titer->fifo_size =\n\t\t\t\tcfg->lmac[iter->lmac].txfifo_size[iter->fifo];\n\t\t\tif (iter->fifo_size && (lmac_bitmap & BIT(iter->fifo)))\n\t\t\t\treturn true;\n\t\t}\n\t\titer->fifo--;\n\t}\n\n\titer->internal_txf = 1;\n\n\tif (!fw_has_capa(&fwrt->fw->ucode_capa,\n\t\t\t IWL_UCODE_TLV_CAPA_EXTEND_SHARED_MEM_CFG))\n\t\treturn false;\n\n\tfor (iter->fifo++; iter->fifo < int_txf_num + txf_num; iter->fifo++) {\n\t\titer->fifo_size =\n\t\t\tcfg->internal_txfifo_size[iter->fifo - txf_num];\n\t\tif (iter->fifo_size && (lmac_bitmap & BIT(iter->fifo)))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int iwl_dump_ini_txf_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t\t struct iwl_dump_ini_region_data *reg_data,\n\t\t\t\t void *range_ptr, u32 range_len, int idx)\n{\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\tstruct iwl_txf_iter_data *iter = &fwrt->dump.txf_iter_data;\n\tstruct iwl_fw_ini_error_dump_register *reg_dump = (void *)range->data;\n\tu32 offs = le32_to_cpu(reg->fifos.offset), addr;\n\tu32 registers_num = iwl_tlv_array_len(reg_data->reg_tlv, reg, addrs);\n\tu32 registers_size = registers_num * sizeof(*reg_dump);\n\t__le32 *data;\n\tint i;\n\n\tif (!iwl_ini_txf_iter(fwrt, reg_data, idx))\n\t\treturn -EIO;\n\n\tif (!iwl_trans_grab_nic_access(fwrt->trans))\n\t\treturn -EBUSY;\n\n\trange->fifo_hdr.fifo_num = cpu_to_le32(iter->fifo);\n\trange->fifo_hdr.num_of_registers = cpu_to_le32(registers_num);\n\trange->range_data_size = cpu_to_le32(iter->fifo_size + registers_size);\n\n\tiwl_write_prph_no_grab(fwrt->trans, TXF_LARC_NUM + offs, iter->fifo);\n\n\t \n\tfor (i = 0; i < registers_num; i++) {\n\t\taddr = le32_to_cpu(reg->addrs[i]) + offs;\n\n\t\treg_dump->addr = cpu_to_le32(addr);\n\t\treg_dump->data = cpu_to_le32(iwl_read_prph_no_grab(fwrt->trans,\n\t\t\t\t\t\t\t\t   addr));\n\n\t\treg_dump++;\n\t}\n\n\tif (reg->fifos.hdr_only) {\n\t\trange->range_data_size = cpu_to_le32(registers_size);\n\t\tgoto out;\n\t}\n\n\t \n\tiwl_write_prph_no_grab(fwrt->trans, TXF_READ_MODIFY_ADDR + offs,\n\t\t\t       TXF_WR_PTR + offs);\n\n\t \n\tiwl_read_prph_no_grab(fwrt->trans, TXF_READ_MODIFY_DATA + offs);\n\n\t \n\taddr = TXF_READ_MODIFY_DATA + offs;\n\tdata = (void *)reg_dump;\n\tfor (i = 0; i < iter->fifo_size; i += sizeof(*data))\n\t\t*data++ = cpu_to_le32(iwl_read_prph_no_grab(fwrt->trans, addr));\n\n\tif (fwrt->sanitize_ops && fwrt->sanitize_ops->frob_txf)\n\t\tfwrt->sanitize_ops->frob_txf(fwrt->sanitize_ctx,\n\t\t\t\t\t     reg_dump, iter->fifo_size);\n\nout:\n\tiwl_trans_release_nic_access(fwrt->trans);\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstruct iwl_ini_rxf_data {\n\tu32 fifo_num;\n\tu32 size;\n\tu32 offset;\n};\n\nstatic void iwl_ini_get_rxf_data(struct iwl_fw_runtime *fwrt,\n\t\t\t\t struct iwl_dump_ini_region_data *reg_data,\n\t\t\t\t struct iwl_ini_rxf_data *data)\n{\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tu32 fid1 = le32_to_cpu(reg->fifos.fid[0]);\n\tu32 fid2 = le32_to_cpu(reg->fifos.fid[1]);\n\tu8 fifo_idx;\n\n\tif (!data)\n\t\treturn;\n\n\tmemset(data, 0, sizeof(*data));\n\n\t \n\tif (WARN_ONCE(hweight_long(fid1) + hweight_long(fid2) != 1,\n\t\t      \"fid1=%x, fid2=%x\\n\", fid1, fid2))\n\t\treturn;\n\n\tif (fid1) {\n\t\tfifo_idx = ffs(fid1) - 1;\n\t\tif (WARN_ONCE(fifo_idx >= MAX_NUM_LMAC, \"fifo_idx=%d\\n\",\n\t\t\t      fifo_idx))\n\t\t\treturn;\n\n\t\tdata->size = fwrt->smem_cfg.lmac[fifo_idx].rxfifo1_size;\n\t\tdata->fifo_num = fifo_idx;\n\t} else {\n\t\tu8 max_idx;\n\n\t\tfifo_idx = ffs(fid2) - 1;\n\t\tif (iwl_fw_lookup_notif_ver(fwrt->fw, SYSTEM_GROUP,\n\t\t\t\t\t    SHARED_MEM_CFG_CMD, 0) <= 3)\n\t\t\tmax_idx = 0;\n\t\telse\n\t\t\tmax_idx = 1;\n\n\t\tif (WARN_ONCE(fifo_idx > max_idx,\n\t\t\t      \"invalid umac fifo idx %d\", fifo_idx))\n\t\t\treturn;\n\n\t\t \n\t\tdata->fifo_num = fifo_idx | IWL_RXF_UMAC_BIT;\n\n\t\tswitch (fifo_idx) {\n\t\tcase 0:\n\t\t\tdata->size = fwrt->smem_cfg.rxfifo2_size;\n\t\t\tdata->offset = iwl_umac_prph(fwrt->trans,\n\t\t\t\t\t\t     RXF_DIFF_FROM_PREV);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdata->size = fwrt->smem_cfg.rxfifo2_control_size;\n\t\t\tdata->offset = iwl_umac_prph(fwrt->trans,\n\t\t\t\t\t\t     RXF2C_DIFF_FROM_PREV);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int iwl_dump_ini_rxf_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t\t struct iwl_dump_ini_region_data *reg_data,\n\t\t\t\t void *range_ptr, u32 range_len, int idx)\n{\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\tstruct iwl_ini_rxf_data rxf_data;\n\tstruct iwl_fw_ini_error_dump_register *reg_dump = (void *)range->data;\n\tu32 offs = le32_to_cpu(reg->fifos.offset), addr;\n\tu32 registers_num = iwl_tlv_array_len(reg_data->reg_tlv, reg, addrs);\n\tu32 registers_size = registers_num * sizeof(*reg_dump);\n\t__le32 *data;\n\tint i;\n\n\tiwl_ini_get_rxf_data(fwrt, reg_data, &rxf_data);\n\tif (!rxf_data.size)\n\t\treturn -EIO;\n\n\tif (!iwl_trans_grab_nic_access(fwrt->trans))\n\t\treturn -EBUSY;\n\n\trange->fifo_hdr.fifo_num = cpu_to_le32(rxf_data.fifo_num);\n\trange->fifo_hdr.num_of_registers = cpu_to_le32(registers_num);\n\trange->range_data_size = cpu_to_le32(rxf_data.size + registers_size);\n\n\t \n\tfor (i = 0; i < registers_num; i++) {\n\t\taddr = le32_to_cpu(reg->addrs[i]) + offs;\n\n\t\treg_dump->addr = cpu_to_le32(addr);\n\t\treg_dump->data = cpu_to_le32(iwl_read_prph_no_grab(fwrt->trans,\n\t\t\t\t\t\t\t\t   addr));\n\n\t\treg_dump++;\n\t}\n\n\tif (reg->fifos.hdr_only) {\n\t\trange->range_data_size = cpu_to_le32(registers_size);\n\t\tgoto out;\n\t}\n\n\toffs = rxf_data.offset;\n\n\t \n\tiwl_write_prph_no_grab(fwrt->trans, RXF_SET_FENCE_MODE + offs, 0x1);\n\t \n\tiwl_write_prph_no_grab(fwrt->trans, RXF_LD_WR2FENCE + offs, 0x1);\n\t \n\tiwl_write_prph_no_grab(fwrt->trans, RXF_LD_FENCE_OFFSET_ADDR + offs,\n\t\t\t       0x0);\n\n\t \n\taddr =  RXF_FIFO_RD_FENCE_INC + offs;\n\tdata = (void *)reg_dump;\n\tfor (i = 0; i < rxf_data.size; i += sizeof(*data))\n\t\t*data++ = cpu_to_le32(iwl_read_prph_no_grab(fwrt->trans, addr));\n\nout:\n\tiwl_trans_release_nic_access(fwrt->trans);\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic int\niwl_dump_ini_err_table_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t    struct iwl_dump_ini_region_data *reg_data,\n\t\t\t    void *range_ptr, u32 range_len, int idx)\n{\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tstruct iwl_fw_ini_region_err_table *err_table = &reg->err_table;\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\tu32 addr = le32_to_cpu(err_table->base_addr) +\n\t\t   le32_to_cpu(err_table->offset);\n\n\trange->internal_base_addr = cpu_to_le32(addr);\n\trange->range_data_size = err_table->size;\n\tiwl_trans_read_mem_bytes(fwrt->trans, addr, range->data,\n\t\t\t\t le32_to_cpu(err_table->size));\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic int\niwl_dump_ini_special_mem_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t      struct iwl_dump_ini_region_data *reg_data,\n\t\t\t      void *range_ptr, u32 range_len, int idx)\n{\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tstruct iwl_fw_ini_region_special_device_memory *special_mem =\n\t\t&reg->special_mem;\n\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\tu32 addr = le32_to_cpu(special_mem->base_addr) +\n\t\t   le32_to_cpu(special_mem->offset);\n\n\trange->internal_base_addr = cpu_to_le32(addr);\n\trange->range_data_size = special_mem->size;\n\tiwl_trans_read_mem_bytes(fwrt->trans, addr, range->data,\n\t\t\t\t le32_to_cpu(special_mem->size));\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic int\niwl_dump_ini_dbgi_sram_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t    struct iwl_dump_ini_region_data *reg_data,\n\t\t\t    void *range_ptr, u32 range_len, int idx)\n{\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\t__le32 *val = range->data;\n\tu32 prph_data;\n\tint i;\n\n\tif (!iwl_trans_grab_nic_access(fwrt->trans))\n\t\treturn -EBUSY;\n\n\trange->range_data_size = reg->dev_addr.size;\n\tfor (i = 0; i < (le32_to_cpu(reg->dev_addr.size) / 4); i++) {\n\t\tprph_data = iwl_read_prph_no_grab(fwrt->trans, (i % 2) ?\n\t\t\t\t\t  DBGI_SRAM_TARGET_ACCESS_RDATA_MSB :\n\t\t\t\t\t  DBGI_SRAM_TARGET_ACCESS_RDATA_LSB);\n\t\tif (iwl_trans_is_hw_error_value(prph_data)) {\n\t\t\tiwl_trans_release_nic_access(fwrt->trans);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t*val++ = cpu_to_le32(prph_data);\n\t}\n\tiwl_trans_release_nic_access(fwrt->trans);\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic int iwl_dump_ini_fw_pkt_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t\t    struct iwl_dump_ini_region_data *reg_data,\n\t\t\t\t    void *range_ptr, u32 range_len, int idx)\n{\n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\tstruct iwl_rx_packet *pkt = reg_data->dump_data->fw_pkt;\n\tu32 pkt_len;\n\n\tif (!pkt)\n\t\treturn -EIO;\n\n\tpkt_len = iwl_rx_packet_payload_len(pkt);\n\n\tmemcpy(&range->fw_pkt_hdr, &pkt->hdr, sizeof(range->fw_pkt_hdr));\n\trange->range_data_size = cpu_to_le32(pkt_len);\n\n\tmemcpy(range->data, pkt->data, pkt_len);\n\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic int iwl_dump_ini_imr_iter(struct iwl_fw_runtime *fwrt,\n\t\t\t\t struct iwl_dump_ini_region_data *reg_data,\n\t\t\t\t void *range_ptr, u32 range_len, int idx)\n{\n\t \n\tstruct iwl_fw_ini_error_dump_range *range = range_ptr;\n\tu64 imr_curr_addr = fwrt->trans->dbg.imr_data.imr_curr_addr;\n\tu32 imr_rem_bytes = fwrt->trans->dbg.imr_data.imr2sram_remainbyte;\n\tu32 sram_addr = fwrt->trans->dbg.imr_data.sram_addr;\n\tu32 sram_size = fwrt->trans->dbg.imr_data.sram_size;\n\tu32 size_to_dump = (imr_rem_bytes > sram_size) ? sram_size : imr_rem_bytes;\n\n\trange->range_data_size = cpu_to_le32(size_to_dump);\n\tif (iwl_trans_write_imr_mem(fwrt->trans, sram_addr,\n\t\t\t\t    imr_curr_addr, size_to_dump)) {\n\t\tIWL_ERR(fwrt, \"WRT_DEBUG: IMR Memory transfer failed\\n\");\n\t\treturn -1;\n\t}\n\n\tfwrt->trans->dbg.imr_data.imr_curr_addr = imr_curr_addr + size_to_dump;\n\tfwrt->trans->dbg.imr_data.imr2sram_remainbyte -= size_to_dump;\n\n\tiwl_trans_read_mem_bytes(fwrt->trans, sram_addr, range->data,\n\t\t\t\t size_to_dump);\n\treturn sizeof(*range) + le32_to_cpu(range->range_data_size);\n}\n\nstatic void *\niwl_dump_ini_mem_fill_header(struct iwl_fw_runtime *fwrt,\n\t\t\t     struct iwl_dump_ini_region_data *reg_data,\n\t\t\t     void *data, u32 data_len)\n{\n\tstruct iwl_fw_ini_error_dump *dump = data;\n\n\tdump->header.version = cpu_to_le32(IWL_INI_DUMP_VER);\n\n\treturn dump->data;\n}\n\n \nstatic u32 mask_apply_and_normalize(u32 val, u32 mask)\n{\n\treturn (val & mask) >> (ffs(mask) - 1);\n}\n\nstatic __le32 iwl_get_mon_reg(struct iwl_fw_runtime *fwrt, u32 alloc_id,\n\t\t\t      const struct iwl_fw_mon_reg *reg_info)\n{\n\tu32 val, offs;\n\n\t \n\toffs = (alloc_id - IWL_FW_INI_ALLOCATION_ID_DBGC1) * 0x100;\n\n\tif (!reg_info || !reg_info->addr || !reg_info->mask)\n\t\treturn 0;\n\n\tval = iwl_read_prph_no_grab(fwrt->trans, reg_info->addr + offs);\n\n\treturn cpu_to_le32(mask_apply_and_normalize(val, reg_info->mask));\n}\n\nstatic void *\niwl_dump_ini_mon_fill_header(struct iwl_fw_runtime *fwrt, u32 alloc_id,\n\t\t\t     struct iwl_fw_ini_monitor_dump *data,\n\t\t\t     const struct iwl_fw_mon_regs *addrs)\n{\n\tif (!iwl_trans_grab_nic_access(fwrt->trans)) {\n\t\tIWL_ERR(fwrt, \"Failed to get monitor header\\n\");\n\t\treturn NULL;\n\t}\n\n\tdata->write_ptr = iwl_get_mon_reg(fwrt, alloc_id,\n\t\t\t\t\t  &addrs->write_ptr);\n\tif (fwrt->trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_AX210) {\n\t\tu32 wrt_ptr = le32_to_cpu(data->write_ptr);\n\n\t\tdata->write_ptr = cpu_to_le32(wrt_ptr >> 2);\n\t}\n\tdata->cycle_cnt = iwl_get_mon_reg(fwrt, alloc_id,\n\t\t\t\t\t  &addrs->cycle_cnt);\n\tdata->cur_frag = iwl_get_mon_reg(fwrt, alloc_id,\n\t\t\t\t\t &addrs->cur_frag);\n\n\tiwl_trans_release_nic_access(fwrt->trans);\n\n\tdata->header.version = cpu_to_le32(IWL_INI_DUMP_VER);\n\n\treturn data->data;\n}\n\nstatic void *\niwl_dump_ini_mon_dram_fill_header(struct iwl_fw_runtime *fwrt,\n\t\t\t\t  struct iwl_dump_ini_region_data *reg_data,\n\t\t\t\t  void *data, u32 data_len)\n{\n\tstruct iwl_fw_ini_monitor_dump *mon_dump = (void *)data;\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tu32 alloc_id = le32_to_cpu(reg->dram_alloc_id);\n\n\treturn iwl_dump_ini_mon_fill_header(fwrt, alloc_id, mon_dump,\n\t\t\t\t\t    &fwrt->trans->cfg->mon_dram_regs);\n}\n\nstatic void *\niwl_dump_ini_mon_smem_fill_header(struct iwl_fw_runtime *fwrt,\n\t\t\t\t  struct iwl_dump_ini_region_data *reg_data,\n\t\t\t\t  void *data, u32 data_len)\n{\n\tstruct iwl_fw_ini_monitor_dump *mon_dump = (void *)data;\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tu32 alloc_id = le32_to_cpu(reg->internal_buffer.alloc_id);\n\n\treturn iwl_dump_ini_mon_fill_header(fwrt, alloc_id, mon_dump,\n\t\t\t\t\t    &fwrt->trans->cfg->mon_smem_regs);\n}\n\nstatic void *\niwl_dump_ini_mon_dbgi_fill_header(struct iwl_fw_runtime *fwrt,\n\t\t\t\t  struct iwl_dump_ini_region_data *reg_data,\n\t\t\t\t  void *data, u32 data_len)\n{\n\tstruct iwl_fw_ini_monitor_dump *mon_dump = (void *)data;\n\n\treturn iwl_dump_ini_mon_fill_header(fwrt,\n\t\t\t\t\t     \n\t\t\t\t\t    IWL_FW_INI_ALLOCATION_ID_DBGC1,\n\t\t\t\t\t    mon_dump,\n\t\t\t\t\t    &fwrt->trans->cfg->mon_dbgi_regs);\n}\n\nstatic void *\niwl_dump_ini_err_table_fill_header(struct iwl_fw_runtime *fwrt,\n\t\t\t\t   struct iwl_dump_ini_region_data *reg_data,\n\t\t\t\t   void *data, u32 data_len)\n{\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tstruct iwl_fw_ini_err_table_dump *dump = data;\n\n\tdump->header.version = cpu_to_le32(IWL_INI_DUMP_VER);\n\tdump->version = reg->err_table.version;\n\n\treturn dump->data;\n}\n\nstatic void *\niwl_dump_ini_special_mem_fill_header(struct iwl_fw_runtime *fwrt,\n\t\t\t\t     struct iwl_dump_ini_region_data *reg_data,\n\t\t\t\t     void *data, u32 data_len)\n{\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tstruct iwl_fw_ini_special_device_memory *dump = data;\n\n\tdump->header.version = cpu_to_le32(IWL_INI_DUMP_VER);\n\tdump->type = reg->special_mem.type;\n\tdump->version = reg->special_mem.version;\n\n\treturn dump->data;\n}\n\nstatic void *\niwl_dump_ini_imr_fill_header(struct iwl_fw_runtime *fwrt,\n\t\t\t     struct iwl_dump_ini_region_data *reg_data,\n\t\t\t     void *data, u32 data_len)\n{\n\tstruct iwl_fw_ini_error_dump *dump = data;\n\n\tdump->header.version = cpu_to_le32(IWL_INI_DUMP_VER);\n\n\treturn dump->data;\n}\n\nstatic u32 iwl_dump_ini_mem_ranges(struct iwl_fw_runtime *fwrt,\n\t\t\t\t   struct iwl_dump_ini_region_data *reg_data)\n{\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\n\treturn iwl_tlv_array_len(reg_data->reg_tlv, reg, addrs);\n}\n\nstatic u32 iwl_dump_ini_paging_ranges(struct iwl_fw_runtime *fwrt,\n\t\t\t\t      struct iwl_dump_ini_region_data *reg_data)\n{\n\tif (fwrt->trans->trans_cfg->gen2) {\n\t\tif (fwrt->trans->init_dram.paging_cnt)\n\t\t\treturn fwrt->trans->init_dram.paging_cnt - 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\treturn fwrt->num_of_paging_blk;\n}\n\nstatic u32\niwl_dump_ini_mon_dram_ranges(struct iwl_fw_runtime *fwrt,\n\t\t\t     struct iwl_dump_ini_region_data *reg_data)\n{\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tstruct iwl_fw_mon *fw_mon;\n\tu32 ranges = 0, alloc_id = le32_to_cpu(reg->dram_alloc_id);\n\tint i;\n\n\tfw_mon = &fwrt->trans->dbg.fw_mon_ini[alloc_id];\n\n\tfor (i = 0; i < fw_mon->num_frags; i++) {\n\t\tif (!fw_mon->frags[i].size)\n\t\t\tbreak;\n\n\t\tranges++;\n\t}\n\n\treturn ranges;\n}\n\nstatic u32 iwl_dump_ini_txf_ranges(struct iwl_fw_runtime *fwrt,\n\t\t\t\t   struct iwl_dump_ini_region_data *reg_data)\n{\n\tu32 num_of_fifos = 0;\n\n\twhile (iwl_ini_txf_iter(fwrt, reg_data, num_of_fifos))\n\t\tnum_of_fifos++;\n\n\treturn num_of_fifos;\n}\n\nstatic u32 iwl_dump_ini_single_range(struct iwl_fw_runtime *fwrt,\n\t\t\t\t     struct iwl_dump_ini_region_data *reg_data)\n{\n\treturn 1;\n}\n\nstatic u32 iwl_dump_ini_imr_ranges(struct iwl_fw_runtime *fwrt,\n\t\t\t\t   struct iwl_dump_ini_region_data *reg_data)\n{\n\t \n\tu32 imr_enable = fwrt->trans->dbg.imr_data.imr_enable;\n\tu32 imr_size = fwrt->trans->dbg.imr_data.imr_size;\n\tu32 sram_size = fwrt->trans->dbg.imr_data.sram_size;\n\n\tif (imr_enable == 0 || imr_size == 0 || sram_size == 0) {\n\t\tIWL_DEBUG_INFO(fwrt,\n\t\t\t       \"WRT: Invalid imr data enable: %d, imr_size: %d, sram_size: %d\\n\",\n\t\t\t       imr_enable, imr_size, sram_size);\n\t\treturn 0;\n\t}\n\n\treturn((imr_size % sram_size) ? (imr_size / sram_size + 1) : (imr_size / sram_size));\n}\n\nstatic u32 iwl_dump_ini_mem_get_size(struct iwl_fw_runtime *fwrt,\n\t\t\t\t     struct iwl_dump_ini_region_data *reg_data)\n{\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tu32 size = le32_to_cpu(reg->dev_addr.size);\n\tu32 ranges = iwl_dump_ini_mem_ranges(fwrt, reg_data);\n\n\tif (!size || !ranges)\n\t\treturn 0;\n\n\treturn sizeof(struct iwl_fw_ini_error_dump) + ranges *\n\t\t(size + sizeof(struct iwl_fw_ini_error_dump_range));\n}\n\nstatic u32\niwl_dump_ini_paging_get_size(struct iwl_fw_runtime *fwrt,\n\t\t\t     struct iwl_dump_ini_region_data *reg_data)\n{\n\tint i;\n\tu32 range_header_len = sizeof(struct iwl_fw_ini_error_dump_range);\n\tu32 size = sizeof(struct iwl_fw_ini_error_dump);\n\n\t \n\tfor (i = 1; i <= iwl_dump_ini_paging_ranges(fwrt, reg_data); i++) {\n\t\tsize += range_header_len;\n\t\tif (fwrt->trans->trans_cfg->gen2)\n\t\t\tsize += fwrt->trans->init_dram.paging[i].size;\n\t\telse\n\t\t\tsize += fwrt->fw_paging_db[i].fw_paging_size;\n\t}\n\n\treturn size;\n}\n\nstatic u32\niwl_dump_ini_mon_dram_get_size(struct iwl_fw_runtime *fwrt,\n\t\t\t       struct iwl_dump_ini_region_data *reg_data)\n{\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tstruct iwl_fw_mon *fw_mon;\n\tu32 size = 0, alloc_id = le32_to_cpu(reg->dram_alloc_id);\n\tint i;\n\n\tfw_mon = &fwrt->trans->dbg.fw_mon_ini[alloc_id];\n\n\tfor (i = 0; i < fw_mon->num_frags; i++) {\n\t\tstruct iwl_dram_data *frag = &fw_mon->frags[i];\n\n\t\tif (!frag->size)\n\t\t\tbreak;\n\n\t\tsize += sizeof(struct iwl_fw_ini_error_dump_range) + frag->size;\n\t}\n\n\tif (size)\n\t\tsize += sizeof(struct iwl_fw_ini_monitor_dump);\n\n\treturn size;\n}\n\nstatic u32\niwl_dump_ini_mon_smem_get_size(struct iwl_fw_runtime *fwrt,\n\t\t\t       struct iwl_dump_ini_region_data *reg_data)\n{\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tu32 size;\n\n\tsize = le32_to_cpu(reg->internal_buffer.size);\n\tif (!size)\n\t\treturn 0;\n\n\tsize += sizeof(struct iwl_fw_ini_monitor_dump) +\n\t\tsizeof(struct iwl_fw_ini_error_dump_range);\n\n\treturn size;\n}\n\nstatic u32 iwl_dump_ini_mon_dbgi_get_size(struct iwl_fw_runtime *fwrt,\n\t\t\t\t\t  struct iwl_dump_ini_region_data *reg_data)\n{\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tu32 size = le32_to_cpu(reg->dev_addr.size);\n\tu32 ranges = iwl_dump_ini_mem_ranges(fwrt, reg_data);\n\n\tif (!size || !ranges)\n\t\treturn 0;\n\n\treturn sizeof(struct iwl_fw_ini_monitor_dump) + ranges *\n\t\t(size + sizeof(struct iwl_fw_ini_error_dump_range));\n}\n\nstatic u32 iwl_dump_ini_txf_get_size(struct iwl_fw_runtime *fwrt,\n\t\t\t\t     struct iwl_dump_ini_region_data *reg_data)\n{\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tstruct iwl_txf_iter_data *iter = &fwrt->dump.txf_iter_data;\n\tu32 registers_num = iwl_tlv_array_len(reg_data->reg_tlv, reg, addrs);\n\tu32 size = 0;\n\tu32 fifo_hdr = sizeof(struct iwl_fw_ini_error_dump_range) +\n\t\t       registers_num *\n\t\t       sizeof(struct iwl_fw_ini_error_dump_register);\n\n\twhile (iwl_ini_txf_iter(fwrt, reg_data, size)) {\n\t\tsize += fifo_hdr;\n\t\tif (!reg->fifos.hdr_only)\n\t\t\tsize += iter->fifo_size;\n\t}\n\n\tif (!size)\n\t\treturn 0;\n\n\treturn size + sizeof(struct iwl_fw_ini_error_dump);\n}\n\nstatic u32 iwl_dump_ini_rxf_get_size(struct iwl_fw_runtime *fwrt,\n\t\t\t\t     struct iwl_dump_ini_region_data *reg_data)\n{\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tstruct iwl_ini_rxf_data rx_data;\n\tu32 registers_num = iwl_tlv_array_len(reg_data->reg_tlv, reg, addrs);\n\tu32 size = sizeof(struct iwl_fw_ini_error_dump) +\n\t\tsizeof(struct iwl_fw_ini_error_dump_range) +\n\t\tregisters_num * sizeof(struct iwl_fw_ini_error_dump_register);\n\n\tif (reg->fifos.hdr_only)\n\t\treturn size;\n\n\tiwl_ini_get_rxf_data(fwrt, reg_data, &rx_data);\n\tsize += rx_data.size;\n\n\treturn size;\n}\n\nstatic u32\niwl_dump_ini_err_table_get_size(struct iwl_fw_runtime *fwrt,\n\t\t\t\tstruct iwl_dump_ini_region_data *reg_data)\n{\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tu32 size = le32_to_cpu(reg->err_table.size);\n\n\tif (size)\n\t\tsize += sizeof(struct iwl_fw_ini_err_table_dump) +\n\t\t\tsizeof(struct iwl_fw_ini_error_dump_range);\n\n\treturn size;\n}\n\nstatic u32\niwl_dump_ini_special_mem_get_size(struct iwl_fw_runtime *fwrt,\n\t\t\t\t  struct iwl_dump_ini_region_data *reg_data)\n{\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tu32 size = le32_to_cpu(reg->special_mem.size);\n\n\tif (size)\n\t\tsize += sizeof(struct iwl_fw_ini_special_device_memory) +\n\t\t\tsizeof(struct iwl_fw_ini_error_dump_range);\n\n\treturn size;\n}\n\nstatic u32\niwl_dump_ini_fw_pkt_get_size(struct iwl_fw_runtime *fwrt,\n\t\t\t     struct iwl_dump_ini_region_data *reg_data)\n{\n\tu32 size = 0;\n\n\tif (!reg_data->dump_data->fw_pkt)\n\t\treturn 0;\n\n\tsize += iwl_rx_packet_payload_len(reg_data->dump_data->fw_pkt);\n\tif (size)\n\t\tsize += sizeof(struct iwl_fw_ini_error_dump) +\n\t\t\tsizeof(struct iwl_fw_ini_error_dump_range);\n\n\treturn size;\n}\n\nstatic u32\niwl_dump_ini_imr_get_size(struct iwl_fw_runtime *fwrt,\n\t\t\t  struct iwl_dump_ini_region_data *reg_data)\n{\n\tu32 ranges = 0;\n\tu32 imr_enable = fwrt->trans->dbg.imr_data.imr_enable;\n\tu32 imr_size = fwrt->trans->dbg.imr_data.imr_size;\n\tu32 sram_size = fwrt->trans->dbg.imr_data.sram_size;\n\n\tif (imr_enable == 0 || imr_size == 0 || sram_size == 0) {\n\t\tIWL_DEBUG_INFO(fwrt,\n\t\t\t       \"WRT: Invalid imr data enable: %d, imr_size: %d, sram_size: %d\\n\",\n\t\t\t       imr_enable, imr_size, sram_size);\n\t\treturn 0;\n\t}\n\tranges = iwl_dump_ini_imr_ranges(fwrt, reg_data);\n\tif (!ranges) {\n\t\tIWL_ERR(fwrt, \"WRT: ranges :=%d\\n\", ranges);\n\t\treturn 0;\n\t}\n\timr_size += sizeof(struct iwl_fw_ini_error_dump) +\n\t\tranges * sizeof(struct iwl_fw_ini_error_dump_range);\n\treturn imr_size;\n}\n\n \nstruct iwl_dump_ini_mem_ops {\n\tu32 (*get_num_of_ranges)(struct iwl_fw_runtime *fwrt,\n\t\t\t\t struct iwl_dump_ini_region_data *reg_data);\n\tu32 (*get_size)(struct iwl_fw_runtime *fwrt,\n\t\t\tstruct iwl_dump_ini_region_data *reg_data);\n\tvoid *(*fill_mem_hdr)(struct iwl_fw_runtime *fwrt,\n\t\t\t      struct iwl_dump_ini_region_data *reg_data,\n\t\t\t      void *data, u32 data_len);\n\tint (*fill_range)(struct iwl_fw_runtime *fwrt,\n\t\t\t  struct iwl_dump_ini_region_data *reg_data,\n\t\t\t  void *range, u32 range_len, int idx);\n};\n\n \nstatic u32 iwl_dump_ini_mem(struct iwl_fw_runtime *fwrt, struct list_head *list,\n\t\t\t    struct iwl_dump_ini_region_data *reg_data,\n\t\t\t    const struct iwl_dump_ini_mem_ops *ops)\n{\n\tstruct iwl_fw_ini_region_tlv *reg = (void *)reg_data->reg_tlv->data;\n\tstruct iwl_fw_ini_dump_entry *entry;\n\tstruct iwl_fw_ini_error_dump_data *tlv;\n\tstruct iwl_fw_ini_error_dump_header *header;\n\tu32 type = reg->type;\n\tu32 id = le32_get_bits(reg->id, IWL_FW_INI_REGION_ID_MASK);\n\tu32 num_of_ranges, i, size;\n\tu8 *range;\n\tu32 free_size;\n\tu64 header_size;\n\tu32 dump_policy = IWL_FW_INI_DUMP_VERBOSE;\n\n\tIWL_DEBUG_FW(fwrt, \"WRT: Collecting region: dump type=%d, id=%d, type=%d\\n\",\n\t\t     dump_policy, id, type);\n\n\tif (le32_to_cpu(reg->hdr.version) >= 2) {\n\t\tu32 dp = le32_get_bits(reg->id,\n\t\t\t\t       IWL_FW_INI_REGION_DUMP_POLICY_MASK);\n\n\t\tif (dump_policy == IWL_FW_INI_DUMP_VERBOSE &&\n\t\t    !(dp & IWL_FW_INI_DEBUG_DUMP_POLICY_NO_LIMIT)) {\n\t\t\tIWL_DEBUG_FW(fwrt,\n\t\t\t\t     \"WRT: no dump - type %d and policy mismatch=%d\\n\",\n\t\t\t\t     dump_policy, dp);\n\t\t\treturn 0;\n\t\t} else if (dump_policy == IWL_FW_INI_DUMP_MEDIUM &&\n\t\t\t   !(dp & IWL_FW_IWL_DEBUG_DUMP_POLICY_MAX_LIMIT_5MB)) {\n\t\t\tIWL_DEBUG_FW(fwrt,\n\t\t\t\t     \"WRT: no dump - type %d and policy mismatch=%d\\n\",\n\t\t\t\t     dump_policy, dp);\n\t\t\treturn 0;\n\t\t} else if (dump_policy == IWL_FW_INI_DUMP_BRIEF &&\n\t\t\t   !(dp & IWL_FW_INI_DEBUG_DUMP_POLICY_MAX_LIMIT_600KB)) {\n\t\t\tIWL_DEBUG_FW(fwrt,\n\t\t\t\t     \"WRT: no dump - type %d and policy mismatch=%d\\n\",\n\t\t\t\t     dump_policy, dp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!ops->get_num_of_ranges || !ops->get_size || !ops->fill_mem_hdr ||\n\t    !ops->fill_range) {\n\t\tIWL_DEBUG_FW(fwrt, \"WRT: no ops for collecting data\\n\");\n\t\treturn 0;\n\t}\n\n\tsize = ops->get_size(fwrt, reg_data);\n\n\tif (size < sizeof(*header)) {\n\t\tIWL_DEBUG_FW(fwrt, \"WRT: size didn't include space for header\\n\");\n\t\treturn 0;\n\t}\n\n\tentry = vzalloc(sizeof(*entry) + sizeof(*tlv) + size);\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->size = sizeof(*tlv) + size;\n\n\ttlv = (void *)entry->data;\n\ttlv->type = reg->type;\n\ttlv->sub_type = reg->sub_type;\n\ttlv->sub_type_ver = reg->sub_type_ver;\n\ttlv->reserved = reg->reserved;\n\ttlv->len = cpu_to_le32(size);\n\n\tnum_of_ranges = ops->get_num_of_ranges(fwrt, reg_data);\n\n\theader = (void *)tlv->data;\n\theader->region_id = cpu_to_le32(id);\n\theader->num_of_ranges = cpu_to_le32(num_of_ranges);\n\theader->name_len = cpu_to_le32(IWL_FW_INI_MAX_NAME);\n\tmemcpy(header->name, reg->name, IWL_FW_INI_MAX_NAME);\n\n\tfree_size = size;\n\trange = ops->fill_mem_hdr(fwrt, reg_data, header, free_size);\n\tif (!range) {\n\t\tIWL_ERR(fwrt,\n\t\t\t\"WRT: Failed to fill region header: id=%d, type=%d\\n\",\n\t\t\tid, type);\n\t\tgoto out_err;\n\t}\n\n\theader_size = range - (u8 *)header;\n\n\tif (WARN(header_size > free_size,\n\t\t \"header size %llu > free_size %d\",\n\t\t header_size, free_size)) {\n\t\tIWL_ERR(fwrt,\n\t\t\t\"WRT: fill_mem_hdr used more than given free_size\\n\");\n\t\tgoto out_err;\n\t}\n\n\tfree_size -= header_size;\n\n\tfor (i = 0; i < num_of_ranges; i++) {\n\t\tint range_size = ops->fill_range(fwrt, reg_data, range,\n\t\t\t\t\t\t free_size, i);\n\n\t\tif (range_size < 0) {\n\t\t\tIWL_ERR(fwrt,\n\t\t\t\t\"WRT: Failed to dump region: id=%d, type=%d\\n\",\n\t\t\t\tid, type);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (WARN(range_size > free_size, \"range_size %d > free_size %d\",\n\t\t\t range_size, free_size)) {\n\t\t\tIWL_ERR(fwrt,\n\t\t\t\t\"WRT: fill_raged used more than given free_size\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tfree_size -= range_size;\n\t\trange = range + range_size;\n\t}\n\n\tlist_add_tail(&entry->list, list);\n\n\treturn entry->size;\n\nout_err:\n\tvfree(entry);\n\n\treturn 0;\n}\n\nstatic u32 iwl_dump_ini_info(struct iwl_fw_runtime *fwrt,\n\t\t\t     struct iwl_fw_ini_trigger_tlv *trigger,\n\t\t\t     struct list_head *list)\n{\n\tstruct iwl_fw_ini_dump_entry *entry;\n\tstruct iwl_fw_error_dump_data *tlv;\n\tstruct iwl_fw_ini_dump_info *dump;\n\tstruct iwl_dbg_tlv_node *node;\n\tstruct iwl_fw_ini_dump_cfg_name *cfg_name;\n\tu32 size = sizeof(*tlv) + sizeof(*dump);\n\tu32 num_of_cfg_names = 0;\n\tu32 hw_type;\n\n\tlist_for_each_entry(node, &fwrt->trans->dbg.debug_info_tlv_list, list) {\n\t\tsize += sizeof(*cfg_name);\n\t\tnum_of_cfg_names++;\n\t}\n\n\tentry = vzalloc(sizeof(*entry) + size);\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->size = size;\n\n\ttlv = (void *)entry->data;\n\ttlv->type = cpu_to_le32(IWL_INI_DUMP_INFO_TYPE);\n\ttlv->len = cpu_to_le32(size - sizeof(*tlv));\n\n\tdump = (void *)tlv->data;\n\n\tdump->version = cpu_to_le32(IWL_INI_DUMP_VER);\n\tdump->time_point = trigger->time_point;\n\tdump->trigger_reason = trigger->trigger_reason;\n\tdump->external_cfg_state =\n\t\tcpu_to_le32(fwrt->trans->dbg.external_ini_cfg);\n\n\tdump->ver_type = cpu_to_le32(fwrt->dump.fw_ver.type);\n\tdump->ver_subtype = cpu_to_le32(fwrt->dump.fw_ver.subtype);\n\n\tdump->hw_step = cpu_to_le32(fwrt->trans->hw_rev_step);\n\n\t \n\thw_type = CSR_HW_REV_TYPE(fwrt->trans->hw_rev);\n\tif (hw_type == IWL_AX210_HW_TYPE) {\n\t\tu32 prph_val = iwl_read_umac_prph(fwrt->trans, WFPM_OTP_CFG1_ADDR);\n\t\tu32 is_jacket = !!(prph_val & WFPM_OTP_CFG1_IS_JACKET_BIT);\n\t\tu32 is_cdb = !!(prph_val & WFPM_OTP_CFG1_IS_CDB_BIT);\n\t\tu32 masked_bits = is_jacket | (is_cdb << 1);\n\n\t\t \n\t\thw_type |= masked_bits << IWL_AX210_HW_TYPE_ADDITION_SHIFT;\n\t}\n\tdump->hw_type = cpu_to_le32(hw_type);\n\n\tdump->rf_id_flavor =\n\t\tcpu_to_le32(CSR_HW_RFID_FLAVOR(fwrt->trans->hw_rf_id));\n\tdump->rf_id_dash = cpu_to_le32(CSR_HW_RFID_DASH(fwrt->trans->hw_rf_id));\n\tdump->rf_id_step = cpu_to_le32(CSR_HW_RFID_STEP(fwrt->trans->hw_rf_id));\n\tdump->rf_id_type = cpu_to_le32(CSR_HW_RFID_TYPE(fwrt->trans->hw_rf_id));\n\n\tdump->lmac_major = cpu_to_le32(fwrt->dump.fw_ver.lmac_major);\n\tdump->lmac_minor = cpu_to_le32(fwrt->dump.fw_ver.lmac_minor);\n\tdump->umac_major = cpu_to_le32(fwrt->dump.fw_ver.umac_major);\n\tdump->umac_minor = cpu_to_le32(fwrt->dump.fw_ver.umac_minor);\n\n\tdump->fw_mon_mode = cpu_to_le32(fwrt->trans->dbg.ini_dest);\n\tdump->regions_mask = trigger->regions_mask &\n\t\t\t     ~cpu_to_le64(fwrt->trans->dbg.unsupported_region_msk);\n\n\tdump->build_tag_len = cpu_to_le32(sizeof(dump->build_tag));\n\tmemcpy(dump->build_tag, fwrt->fw->human_readable,\n\t       sizeof(dump->build_tag));\n\n\tcfg_name = dump->cfg_names;\n\tdump->num_of_cfg_names = cpu_to_le32(num_of_cfg_names);\n\tlist_for_each_entry(node, &fwrt->trans->dbg.debug_info_tlv_list, list) {\n\t\tstruct iwl_fw_ini_debug_info_tlv *debug_info =\n\t\t\t(void *)node->tlv.data;\n\n\t\tcfg_name->image_type = debug_info->image_type;\n\t\tcfg_name->cfg_name_len =\n\t\t\tcpu_to_le32(IWL_FW_INI_MAX_CFG_NAME);\n\t\tmemcpy(cfg_name->cfg_name, debug_info->debug_cfg_name,\n\t\t       sizeof(cfg_name->cfg_name));\n\t\tcfg_name++;\n\t}\n\n\t \n\tlist_add(&entry->list, list);\n\n\treturn entry->size;\n}\n\nstatic u32 iwl_dump_ini_file_name_info(struct iwl_fw_runtime *fwrt,\n\t\t\t\t       struct list_head *list)\n{\n\tstruct iwl_fw_ini_dump_entry *entry;\n\tstruct iwl_dump_file_name_info *tlv;\n\tu32 len = strnlen(fwrt->trans->dbg.dump_file_name_ext,\n\t\t\t  IWL_FW_INI_MAX_NAME);\n\n\tif (!fwrt->trans->dbg.dump_file_name_ext_valid)\n\t\treturn 0;\n\n\tentry = vzalloc(sizeof(*entry) + sizeof(*tlv) + len);\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->size = sizeof(*tlv) + len;\n\n\ttlv = (void *)entry->data;\n\ttlv->type = cpu_to_le32(IWL_INI_DUMP_NAME_TYPE);\n\ttlv->len = cpu_to_le32(len);\n\tmemcpy(tlv->data, fwrt->trans->dbg.dump_file_name_ext, len);\n\n\t \n\tlist_add_tail(&entry->list, list);\n\n\tfwrt->trans->dbg.dump_file_name_ext_valid = false;\n\n\treturn entry->size;\n}\n\nstatic const struct iwl_dump_ini_mem_ops iwl_dump_ini_region_ops[] = {\n\t[IWL_FW_INI_REGION_INVALID] = {},\n\t[IWL_FW_INI_REGION_INTERNAL_BUFFER] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_single_range,\n\t\t.get_size = iwl_dump_ini_mon_smem_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mon_smem_fill_header,\n\t\t.fill_range = iwl_dump_ini_mon_smem_iter,\n\t},\n\t[IWL_FW_INI_REGION_DRAM_BUFFER] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_mon_dram_ranges,\n\t\t.get_size = iwl_dump_ini_mon_dram_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mon_dram_fill_header,\n\t\t.fill_range = iwl_dump_ini_mon_dram_iter,\n\t},\n\t[IWL_FW_INI_REGION_TXF] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_txf_ranges,\n\t\t.get_size = iwl_dump_ini_txf_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mem_fill_header,\n\t\t.fill_range = iwl_dump_ini_txf_iter,\n\t},\n\t[IWL_FW_INI_REGION_RXF] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_single_range,\n\t\t.get_size = iwl_dump_ini_rxf_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mem_fill_header,\n\t\t.fill_range = iwl_dump_ini_rxf_iter,\n\t},\n\t[IWL_FW_INI_REGION_LMAC_ERROR_TABLE] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_single_range,\n\t\t.get_size = iwl_dump_ini_err_table_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_err_table_fill_header,\n\t\t.fill_range = iwl_dump_ini_err_table_iter,\n\t},\n\t[IWL_FW_INI_REGION_UMAC_ERROR_TABLE] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_single_range,\n\t\t.get_size = iwl_dump_ini_err_table_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_err_table_fill_header,\n\t\t.fill_range = iwl_dump_ini_err_table_iter,\n\t},\n\t[IWL_FW_INI_REGION_RSP_OR_NOTIF] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_single_range,\n\t\t.get_size = iwl_dump_ini_fw_pkt_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mem_fill_header,\n\t\t.fill_range = iwl_dump_ini_fw_pkt_iter,\n\t},\n\t[IWL_FW_INI_REGION_DEVICE_MEMORY] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_mem_ranges,\n\t\t.get_size = iwl_dump_ini_mem_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mem_fill_header,\n\t\t.fill_range = iwl_dump_ini_dev_mem_iter,\n\t},\n\t[IWL_FW_INI_REGION_PERIPHERY_MAC] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_mem_ranges,\n\t\t.get_size = iwl_dump_ini_mem_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mem_fill_header,\n\t\t.fill_range = iwl_dump_ini_prph_mac_iter,\n\t},\n\t[IWL_FW_INI_REGION_PERIPHERY_PHY] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_mem_ranges,\n\t\t.get_size = iwl_dump_ini_mem_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mem_fill_header,\n\t\t.fill_range = iwl_dump_ini_prph_phy_iter,\n\t},\n\t[IWL_FW_INI_REGION_PERIPHERY_AUX] = {},\n\t[IWL_FW_INI_REGION_PAGING] = {\n\t\t.fill_mem_hdr = iwl_dump_ini_mem_fill_header,\n\t\t.get_num_of_ranges = iwl_dump_ini_paging_ranges,\n\t\t.get_size = iwl_dump_ini_paging_get_size,\n\t\t.fill_range = iwl_dump_ini_paging_iter,\n\t},\n\t[IWL_FW_INI_REGION_CSR] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_mem_ranges,\n\t\t.get_size = iwl_dump_ini_mem_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mem_fill_header,\n\t\t.fill_range = iwl_dump_ini_csr_iter,\n\t},\n\t[IWL_FW_INI_REGION_DRAM_IMR] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_imr_ranges,\n\t\t.get_size = iwl_dump_ini_imr_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_imr_fill_header,\n\t\t.fill_range = iwl_dump_ini_imr_iter,\n\t},\n\t[IWL_FW_INI_REGION_PCI_IOSF_CONFIG] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_mem_ranges,\n\t\t.get_size = iwl_dump_ini_mem_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mem_fill_header,\n\t\t.fill_range = iwl_dump_ini_config_iter,\n\t},\n\t[IWL_FW_INI_REGION_SPECIAL_DEVICE_MEMORY] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_single_range,\n\t\t.get_size = iwl_dump_ini_special_mem_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_special_mem_fill_header,\n\t\t.fill_range = iwl_dump_ini_special_mem_iter,\n\t},\n\t[IWL_FW_INI_REGION_DBGI_SRAM] = {\n\t\t.get_num_of_ranges = iwl_dump_ini_mem_ranges,\n\t\t.get_size = iwl_dump_ini_mon_dbgi_get_size,\n\t\t.fill_mem_hdr = iwl_dump_ini_mon_dbgi_fill_header,\n\t\t.fill_range = iwl_dump_ini_dbgi_sram_iter,\n\t},\n};\n\nstatic u32 iwl_dump_ini_trigger(struct iwl_fw_runtime *fwrt,\n\t\t\t\tstruct iwl_fwrt_dump_data *dump_data,\n\t\t\t\tstruct list_head *list)\n{\n\tstruct iwl_fw_ini_trigger_tlv *trigger = dump_data->trig;\n\tenum iwl_fw_ini_time_point tp_id = le32_to_cpu(trigger->time_point);\n\tstruct iwl_dump_ini_region_data reg_data = {\n\t\t.dump_data = dump_data,\n\t};\n\tstruct iwl_dump_ini_region_data imr_reg_data = {\n\t\t.dump_data = dump_data,\n\t};\n\tint i;\n\tu32 size = 0;\n\tu64 regions_mask = le64_to_cpu(trigger->regions_mask) &\n\t\t\t   ~(fwrt->trans->dbg.unsupported_region_msk);\n\n\tBUILD_BUG_ON(sizeof(trigger->regions_mask) != sizeof(regions_mask));\n\tBUILD_BUG_ON((sizeof(trigger->regions_mask) * BITS_PER_BYTE) <\n\t\t     ARRAY_SIZE(fwrt->trans->dbg.active_regions));\n\n\tfor (i = 0; i < ARRAY_SIZE(fwrt->trans->dbg.active_regions); i++) {\n\t\tu32 reg_type;\n\t\tstruct iwl_fw_ini_region_tlv *reg;\n\n\t\tif (!(BIT_ULL(i) & regions_mask))\n\t\t\tcontinue;\n\n\t\treg_data.reg_tlv = fwrt->trans->dbg.active_regions[i];\n\t\tif (!reg_data.reg_tlv) {\n\t\t\tIWL_WARN(fwrt,\n\t\t\t\t \"WRT: Unassigned region id %d, skipping\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\treg = (void *)reg_data.reg_tlv->data;\n\t\treg_type = reg->type;\n\t\tif (reg_type >= ARRAY_SIZE(iwl_dump_ini_region_ops))\n\t\t\tcontinue;\n\n\t\tif (reg_type == IWL_FW_INI_REGION_PERIPHERY_PHY &&\n\t\t    tp_id != IWL_FW_INI_TIME_POINT_FW_ASSERT) {\n\t\t\tIWL_WARN(fwrt,\n\t\t\t\t \"WRT: trying to collect phy prph at time point: %d, skipping\\n\",\n\t\t\t\t tp_id);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (reg_type == IWL_FW_INI_REGION_DRAM_IMR) {\n\t\t\tif (tp_id == IWL_FW_INI_TIME_POINT_FW_ASSERT ||\n\t\t\t    tp_id == IWL_FW_INI_TIME_POINT_FW_HW_ERROR)\n\t\t\t\timr_reg_data.reg_tlv = fwrt->trans->dbg.active_regions[i];\n\t\t\telse\n\t\t\t\tIWL_INFO(fwrt,\n\t\t\t\t\t \"WRT: trying to collect DRAM_IMR at time point: %d, skipping\\n\",\n\t\t\t\t\t tp_id);\n\t\t \n\t\t\tcontinue;\n\t\t}\n\n\n\t\tsize += iwl_dump_ini_mem(fwrt, list, &reg_data,\n\t\t\t\t\t &iwl_dump_ini_region_ops[reg_type]);\n\t}\n\t \n\tif (imr_reg_data.reg_tlv)\n\t\tsize += iwl_dump_ini_mem(fwrt, list, &reg_data,\n\t\t\t\t\t &iwl_dump_ini_region_ops[IWL_FW_INI_REGION_DRAM_IMR]);\n\n\tif (size) {\n\t\tsize += iwl_dump_ini_file_name_info(fwrt, list);\n\t\tsize += iwl_dump_ini_info(fwrt, trigger, list);\n\t}\n\n\treturn size;\n}\n\nstatic bool iwl_fw_ini_trigger_on(struct iwl_fw_runtime *fwrt,\n\t\t\t\t  struct iwl_fw_ini_trigger_tlv *trig)\n{\n\tenum iwl_fw_ini_time_point tp_id = le32_to_cpu(trig->time_point);\n\tu32 usec = le32_to_cpu(trig->ignore_consec);\n\n\tif (!iwl_trans_dbg_ini_valid(fwrt->trans) ||\n\t    tp_id == IWL_FW_INI_TIME_POINT_INVALID ||\n\t    tp_id >= IWL_FW_INI_TIME_POINT_NUM ||\n\t    iwl_fw_dbg_no_trig_window(fwrt, tp_id, usec))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic u32 iwl_dump_ini_file_gen(struct iwl_fw_runtime *fwrt,\n\t\t\t\t struct iwl_fwrt_dump_data *dump_data,\n\t\t\t\t struct list_head *list)\n{\n\tstruct iwl_fw_ini_trigger_tlv *trigger = dump_data->trig;\n\tstruct iwl_fw_ini_dump_entry *entry;\n\tstruct iwl_fw_ini_dump_file_hdr *hdr;\n\tu32 size;\n\n\tif (!trigger || !iwl_fw_ini_trigger_on(fwrt, trigger) ||\n\t    !le64_to_cpu(trigger->regions_mask))\n\t\treturn 0;\n\n\tentry = vzalloc(sizeof(*entry) + sizeof(*hdr));\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->size = sizeof(*hdr);\n\n\tsize = iwl_dump_ini_trigger(fwrt, dump_data, list);\n\tif (!size) {\n\t\tvfree(entry);\n\t\treturn 0;\n\t}\n\n\thdr = (void *)entry->data;\n\thdr->barker = cpu_to_le32(IWL_FW_INI_ERROR_DUMP_BARKER);\n\thdr->file_len = cpu_to_le32(size + entry->size);\n\n\tlist_add(&entry->list, list);\n\n\treturn le32_to_cpu(hdr->file_len);\n}\n\nstatic inline void iwl_fw_free_dump_desc(struct iwl_fw_runtime *fwrt,\n\t\t\t\t\t const struct iwl_fw_dump_desc *desc)\n{\n\tif (desc && desc != &iwl_dump_desc_assert)\n\t\tkfree(desc);\n\n\tfwrt->dump.lmac_err_id[0] = 0;\n\tif (fwrt->smem_cfg.num_lmacs > 1)\n\t\tfwrt->dump.lmac_err_id[1] = 0;\n\tfwrt->dump.umac_err_id = 0;\n}\n\nstatic void iwl_fw_error_dump(struct iwl_fw_runtime *fwrt,\n\t\t\t      struct iwl_fwrt_dump_data *dump_data)\n{\n\tstruct iwl_fw_dump_ptrs fw_error_dump = {};\n\tstruct iwl_fw_error_dump_file *dump_file;\n\tstruct scatterlist *sg_dump_data;\n\tu32 file_len;\n\tu32 dump_mask = fwrt->fw->dbg.dump_mask;\n\n\tdump_file = iwl_fw_error_dump_file(fwrt, &fw_error_dump, dump_data);\n\tif (!dump_file)\n\t\treturn;\n\n\tif (dump_data->monitor_only)\n\t\tdump_mask &= BIT(IWL_FW_ERROR_DUMP_FW_MONITOR);\n\n\tfw_error_dump.trans_ptr = iwl_trans_dump_data(fwrt->trans, dump_mask,\n\t\t\t\t\t\t      fwrt->sanitize_ops,\n\t\t\t\t\t\t      fwrt->sanitize_ctx);\n\tfile_len = le32_to_cpu(dump_file->file_len);\n\tfw_error_dump.fwrt_len = file_len;\n\n\tif (fw_error_dump.trans_ptr) {\n\t\tfile_len += fw_error_dump.trans_ptr->len;\n\t\tdump_file->file_len = cpu_to_le32(file_len);\n\t}\n\n\tsg_dump_data = alloc_sgtable(file_len);\n\tif (sg_dump_data) {\n\t\tsg_pcopy_from_buffer(sg_dump_data,\n\t\t\t\t     sg_nents(sg_dump_data),\n\t\t\t\t     fw_error_dump.fwrt_ptr,\n\t\t\t\t     fw_error_dump.fwrt_len, 0);\n\t\tif (fw_error_dump.trans_ptr)\n\t\t\tsg_pcopy_from_buffer(sg_dump_data,\n\t\t\t\t\t     sg_nents(sg_dump_data),\n\t\t\t\t\t     fw_error_dump.trans_ptr->data,\n\t\t\t\t\t     fw_error_dump.trans_ptr->len,\n\t\t\t\t\t     fw_error_dump.fwrt_len);\n\t\tdev_coredumpsg(fwrt->trans->dev, sg_dump_data, file_len,\n\t\t\t       GFP_KERNEL);\n\t}\n\tvfree(fw_error_dump.fwrt_ptr);\n\tvfree(fw_error_dump.trans_ptr);\n}\n\nstatic void iwl_dump_ini_list_free(struct list_head *list)\n{\n\twhile (!list_empty(list)) {\n\t\tstruct iwl_fw_ini_dump_entry *entry =\n\t\t\tlist_entry(list->next, typeof(*entry), list);\n\n\t\tlist_del(&entry->list);\n\t\tvfree(entry);\n\t}\n}\n\nstatic void iwl_fw_error_dump_data_free(struct iwl_fwrt_dump_data *dump_data)\n{\n\tdump_data->trig = NULL;\n\tkfree(dump_data->fw_pkt);\n\tdump_data->fw_pkt = NULL;\n}\n\nstatic void iwl_fw_error_ini_dump(struct iwl_fw_runtime *fwrt,\n\t\t\t\t  struct iwl_fwrt_dump_data *dump_data)\n{\n\tLIST_HEAD(dump_list);\n\tstruct scatterlist *sg_dump_data;\n\tu32 file_len = iwl_dump_ini_file_gen(fwrt, dump_data, &dump_list);\n\n\tif (!file_len)\n\t\treturn;\n\n\tsg_dump_data = alloc_sgtable(file_len);\n\tif (sg_dump_data) {\n\t\tstruct iwl_fw_ini_dump_entry *entry;\n\t\tint sg_entries = sg_nents(sg_dump_data);\n\t\tu32 offs = 0;\n\n\t\tlist_for_each_entry(entry, &dump_list, list) {\n\t\t\tsg_pcopy_from_buffer(sg_dump_data, sg_entries,\n\t\t\t\t\t     entry->data, entry->size, offs);\n\t\t\toffs += entry->size;\n\t\t}\n\t\tdev_coredumpsg(fwrt->trans->dev, sg_dump_data, file_len,\n\t\t\t       GFP_KERNEL);\n\t}\n\tiwl_dump_ini_list_free(&dump_list);\n}\n\nconst struct iwl_fw_dump_desc iwl_dump_desc_assert = {\n\t.trig_desc = {\n\t\t.type = cpu_to_le32(FW_DBG_TRIGGER_FW_ASSERT),\n\t},\n};\nIWL_EXPORT_SYMBOL(iwl_dump_desc_assert);\n\nint iwl_fw_dbg_collect_desc(struct iwl_fw_runtime *fwrt,\n\t\t\t    const struct iwl_fw_dump_desc *desc,\n\t\t\t    bool monitor_only,\n\t\t\t    unsigned int delay)\n{\n\tstruct iwl_fwrt_wk_data *wk_data;\n\tunsigned long idx;\n\n\tif (iwl_trans_dbg_ini_valid(fwrt->trans)) {\n\t\tiwl_fw_free_dump_desc(fwrt, desc);\n\t\treturn 0;\n\t}\n\n\t \n\tif (fwrt->dump.active_wks == ~0UL)\n\t\treturn -EBUSY;\n\n\tidx = ffz(fwrt->dump.active_wks);\n\n\tif (idx >= IWL_FW_RUNTIME_DUMP_WK_NUM ||\n\t    test_and_set_bit(fwrt->dump.wks[idx].idx, &fwrt->dump.active_wks))\n\t\treturn -EBUSY;\n\n\twk_data = &fwrt->dump.wks[idx];\n\n\tif (WARN_ON(wk_data->dump_data.desc))\n\t\tiwl_fw_free_dump_desc(fwrt, wk_data->dump_data.desc);\n\n\twk_data->dump_data.desc = desc;\n\twk_data->dump_data.monitor_only = monitor_only;\n\n\tIWL_WARN(fwrt, \"Collecting data: trigger %d fired.\\n\",\n\t\t le32_to_cpu(desc->trig_desc.type));\n\n\tschedule_delayed_work(&wk_data->wk, usecs_to_jiffies(delay));\n\n\treturn 0;\n}\nIWL_EXPORT_SYMBOL(iwl_fw_dbg_collect_desc);\n\nint iwl_fw_dbg_error_collect(struct iwl_fw_runtime *fwrt,\n\t\t\t     enum iwl_fw_dbg_trigger trig_type)\n{\n\tif (!test_bit(STATUS_DEVICE_ENABLED, &fwrt->trans->status))\n\t\treturn -EIO;\n\n\tif (iwl_trans_dbg_ini_valid(fwrt->trans)) {\n\t\tif (trig_type != FW_DBG_TRIGGER_ALIVE_TIMEOUT &&\n\t\t    trig_type != FW_DBG_TRIGGER_DRIVER)\n\t\t\treturn -EIO;\n\n\t\tiwl_dbg_tlv_time_point(fwrt,\n\t\t\t\t       IWL_FW_INI_TIME_POINT_HOST_ALIVE_TIMEOUT,\n\t\t\t\t       NULL);\n\t} else {\n\t\tstruct iwl_fw_dump_desc *iwl_dump_error_desc;\n\t\tint ret;\n\n\t\tiwl_dump_error_desc =\n\t\t\tkmalloc(sizeof(*iwl_dump_error_desc), GFP_KERNEL);\n\n\t\tif (!iwl_dump_error_desc)\n\t\t\treturn -ENOMEM;\n\n\t\tiwl_dump_error_desc->trig_desc.type = cpu_to_le32(trig_type);\n\t\tiwl_dump_error_desc->len = 0;\n\n\t\tret = iwl_fw_dbg_collect_desc(fwrt, iwl_dump_error_desc,\n\t\t\t\t\t      false, 0);\n\t\tif (ret) {\n\t\t\tkfree(iwl_dump_error_desc);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tiwl_trans_sync_nmi(fwrt->trans);\n\n\treturn 0;\n}\nIWL_EXPORT_SYMBOL(iwl_fw_dbg_error_collect);\n\nint iwl_fw_dbg_collect(struct iwl_fw_runtime *fwrt,\n\t\t       enum iwl_fw_dbg_trigger trig,\n\t\t       const char *str, size_t len,\n\t\t       struct iwl_fw_dbg_trigger_tlv *trigger)\n{\n\tstruct iwl_fw_dump_desc *desc;\n\tunsigned int delay = 0;\n\tbool monitor_only = false;\n\n\tif (trigger) {\n\t\tu16 occurrences = le16_to_cpu(trigger->occurrences) - 1;\n\n\t\tif (!le16_to_cpu(trigger->occurrences))\n\t\t\treturn 0;\n\n\t\tif (trigger->flags & IWL_FW_DBG_FORCE_RESTART) {\n\t\t\tIWL_WARN(fwrt, \"Force restart: trigger %d fired.\\n\",\n\t\t\t\t trig);\n\t\t\tiwl_force_nmi(fwrt->trans);\n\t\t\treturn 0;\n\t\t}\n\n\t\ttrigger->occurrences = cpu_to_le16(occurrences);\n\t\tmonitor_only = trigger->mode & IWL_FW_DBG_TRIGGER_MONITOR_ONLY;\n\n\t\t \n\t\tdelay = le32_to_cpu(trigger->stop_delay) * USEC_PER_MSEC;\n\t}\n\n\tdesc = kzalloc(struct_size(desc, trig_desc.data, len), GFP_ATOMIC);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\n\tdesc->len = len;\n\tdesc->trig_desc.type = cpu_to_le32(trig);\n\tmemcpy(desc->trig_desc.data, str, len);\n\n\treturn iwl_fw_dbg_collect_desc(fwrt, desc, monitor_only, delay);\n}\nIWL_EXPORT_SYMBOL(iwl_fw_dbg_collect);\n\nint iwl_fw_dbg_collect_trig(struct iwl_fw_runtime *fwrt,\n\t\t\t    struct iwl_fw_dbg_trigger_tlv *trigger,\n\t\t\t    const char *fmt, ...)\n{\n\tint ret, len = 0;\n\tchar buf[64];\n\n\tif (iwl_trans_dbg_ini_valid(fwrt->trans))\n\t\treturn 0;\n\n\tif (fmt) {\n\t\tva_list ap;\n\n\t\tbuf[sizeof(buf) - 1] = '\\0';\n\n\t\tva_start(ap, fmt);\n\t\tvsnprintf(buf, sizeof(buf), fmt, ap);\n\t\tva_end(ap);\n\n\t\t \n\t\tif (WARN_ON_ONCE(buf[sizeof(buf) - 1]))\n\t\t\tbuf[sizeof(buf) - 1] = '\\0';\n\n\t\tlen = strlen(buf) + 1;\n\t}\n\n\tret = iwl_fw_dbg_collect(fwrt, le32_to_cpu(trigger->id), buf, len,\n\t\t\t\t trigger);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\nIWL_EXPORT_SYMBOL(iwl_fw_dbg_collect_trig);\n\nint iwl_fw_start_dbg_conf(struct iwl_fw_runtime *fwrt, u8 conf_id)\n{\n\tu8 *ptr;\n\tint ret;\n\tint i;\n\n\tif (WARN_ONCE(conf_id >= ARRAY_SIZE(fwrt->fw->dbg.conf_tlv),\n\t\t      \"Invalid configuration %d\\n\", conf_id))\n\t\treturn -EINVAL;\n\n\t \n\tif ((!fwrt->fw->dbg.conf_tlv[conf_id] ||\n\t     !fwrt->fw->dbg.conf_tlv[conf_id]->num_of_hcmds) &&\n\t    conf_id == FW_DBG_START_FROM_ALIVE)\n\t\treturn 0;\n\n\tif (!fwrt->fw->dbg.conf_tlv[conf_id])\n\t\treturn -EINVAL;\n\n\tif (fwrt->dump.conf != FW_DBG_INVALID)\n\t\tIWL_INFO(fwrt, \"FW already configured (%d) - re-configuring\\n\",\n\t\t\t fwrt->dump.conf);\n\n\t \n\tptr = (void *)&fwrt->fw->dbg.conf_tlv[conf_id]->hcmd;\n\tfor (i = 0; i < fwrt->fw->dbg.conf_tlv[conf_id]->num_of_hcmds; i++) {\n\t\tstruct iwl_fw_dbg_conf_hcmd *cmd = (void *)ptr;\n\t\tstruct iwl_host_cmd hcmd = {\n\t\t\t.id = cmd->id,\n\t\t\t.len = { le16_to_cpu(cmd->len), },\n\t\t\t.data = { cmd->data, },\n\t\t};\n\n\t\tret = iwl_trans_send_cmd(fwrt->trans, &hcmd);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tptr += sizeof(*cmd);\n\t\tptr += le16_to_cpu(cmd->len);\n\t}\n\n\tfwrt->dump.conf = conf_id;\n\n\treturn 0;\n}\nIWL_EXPORT_SYMBOL(iwl_fw_start_dbg_conf);\n\nvoid iwl_send_dbg_dump_complete_cmd(struct iwl_fw_runtime *fwrt,\n\t\t\t\t    u32 timepoint,\n\t\t\t\t    u32 timepoint_data)\n{\n\tstruct iwl_dbg_dump_complete_cmd hcmd_data;\n\tstruct iwl_host_cmd hcmd = {\n\t\t.id = WIDE_ID(DEBUG_GROUP, FW_DUMP_COMPLETE_CMD),\n\t\t.data[0] = &hcmd_data,\n\t\t.len[0] = sizeof(hcmd_data),\n\t};\n\n\tif (test_bit(STATUS_FW_ERROR, &fwrt->trans->status))\n\t\treturn;\n\n\tif (fw_has_capa(&fwrt->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_DUMP_COMPLETE_SUPPORT)) {\n\t\thcmd_data.tp = cpu_to_le32(timepoint);\n\t\thcmd_data.tp_data = cpu_to_le32(timepoint_data);\n\t\tiwl_trans_send_cmd(fwrt->trans, &hcmd);\n\t}\n}\n\n \nstatic void iwl_fw_dbg_collect_sync(struct iwl_fw_runtime *fwrt, u8 wk_idx)\n{\n\tstruct iwl_fw_dbg_params params = {0};\n\tstruct iwl_fwrt_dump_data *dump_data =\n\t\t&fwrt->dump.wks[wk_idx].dump_data;\n\tu32 policy;\n\tu32 time_point;\n\tif (!test_bit(wk_idx, &fwrt->dump.active_wks))\n\t\treturn;\n\n\tif (!dump_data->trig) {\n\t\tIWL_ERR(fwrt, \"dump trigger data is not set\\n\");\n\t\tgoto out;\n\t}\n\n\tif (!test_bit(STATUS_DEVICE_ENABLED, &fwrt->trans->status)) {\n\t\tIWL_ERR(fwrt, \"Device is not enabled - cannot dump error\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (test_bit(STATUS_TRANS_DEAD, &fwrt->trans->status)) {\n\t\tIWL_ERR(fwrt, \"Skip fw error dump since bus is dead\\n\");\n\t\tgoto out;\n\t}\n\n\tiwl_fw_dbg_stop_restart_recording(fwrt, &params, true);\n\n\tIWL_DEBUG_FW_INFO(fwrt, \"WRT: Data collection start\\n\");\n\tif (iwl_trans_dbg_ini_valid(fwrt->trans))\n\t\tiwl_fw_error_ini_dump(fwrt, &fwrt->dump.wks[wk_idx].dump_data);\n\telse\n\t\tiwl_fw_error_dump(fwrt, &fwrt->dump.wks[wk_idx].dump_data);\n\tIWL_DEBUG_FW_INFO(fwrt, \"WRT: Data collection done\\n\");\n\n\tiwl_fw_dbg_stop_restart_recording(fwrt, &params, false);\n\n\tpolicy = le32_to_cpu(dump_data->trig->apply_policy);\n\ttime_point = le32_to_cpu(dump_data->trig->time_point);\n\n\tif (policy & IWL_FW_INI_APPLY_POLICY_DUMP_COMPLETE_CMD) {\n\t\tIWL_DEBUG_FW_INFO(fwrt, \"WRT: sending dump complete\\n\");\n\t\tiwl_send_dbg_dump_complete_cmd(fwrt, time_point, 0);\n\t}\n\tif (fwrt->trans->dbg.last_tp_resetfw == IWL_FW_INI_RESET_FW_MODE_STOP_FW_ONLY)\n\t\tiwl_force_nmi(fwrt->trans);\n\nout:\n\tif (iwl_trans_dbg_ini_valid(fwrt->trans)) {\n\t\tiwl_fw_error_dump_data_free(dump_data);\n\t} else {\n\t\tiwl_fw_free_dump_desc(fwrt, dump_data->desc);\n\t\tdump_data->desc = NULL;\n\t}\n\n\tclear_bit(wk_idx, &fwrt->dump.active_wks);\n}\n\nint iwl_fw_dbg_ini_collect(struct iwl_fw_runtime *fwrt,\n\t\t\t   struct iwl_fwrt_dump_data *dump_data,\n\t\t\t   bool sync)\n{\n\tstruct iwl_fw_ini_trigger_tlv *trig = dump_data->trig;\n\tenum iwl_fw_ini_time_point tp_id = le32_to_cpu(trig->time_point);\n\tu32 occur, delay;\n\tunsigned long idx;\n\n\tif (!iwl_fw_ini_trigger_on(fwrt, trig)) {\n\t\tIWL_WARN(fwrt, \"WRT: Trigger %d is not active, aborting dump\\n\",\n\t\t\t tp_id);\n\t\treturn -EINVAL;\n\t}\n\n\tdelay = le32_to_cpu(trig->dump_delay);\n\toccur = le32_to_cpu(trig->occurrences);\n\tif (!occur)\n\t\treturn 0;\n\n\ttrig->occurrences = cpu_to_le32(--occur);\n\n\t \n\tif (fwrt->dump.active_wks == ~0UL)\n\t\treturn -EBUSY;\n\n\tidx = ffz(fwrt->dump.active_wks);\n\n\tif (idx >= IWL_FW_RUNTIME_DUMP_WK_NUM ||\n\t    test_and_set_bit(fwrt->dump.wks[idx].idx, &fwrt->dump.active_wks))\n\t\treturn -EBUSY;\n\n\tfwrt->dump.wks[idx].dump_data = *dump_data;\n\n\tif (sync)\n\t\tdelay = 0;\n\n\tIWL_WARN(fwrt,\n\t\t \"WRT: Collecting data: ini trigger %d fired (delay=%dms).\\n\",\n\t\t tp_id, (u32)(delay / USEC_PER_MSEC));\n\n\tif (sync)\n\t\tiwl_fw_dbg_collect_sync(fwrt, idx);\n\telse\n\t\tschedule_delayed_work(&fwrt->dump.wks[idx].wk, usecs_to_jiffies(delay));\n\n\treturn 0;\n}\n\nvoid iwl_fw_error_dump_wk(struct work_struct *work)\n{\n\tstruct iwl_fwrt_wk_data *wks =\n\t\tcontainer_of(work, typeof(*wks), wk.work);\n\tstruct iwl_fw_runtime *fwrt =\n\t\tcontainer_of(wks, typeof(*fwrt), dump.wks[wks->idx]);\n\n\t \n\tif (fwrt->ops && fwrt->ops->dump_start)\n\t\tfwrt->ops->dump_start(fwrt->ops_ctx);\n\n\tiwl_fw_dbg_collect_sync(fwrt, wks->idx);\n\n\tif (fwrt->ops && fwrt->ops->dump_end)\n\t\tfwrt->ops->dump_end(fwrt->ops_ctx);\n}\n\nvoid iwl_fw_dbg_read_d3_debug_data(struct iwl_fw_runtime *fwrt)\n{\n\tconst struct iwl_cfg *cfg = fwrt->trans->cfg;\n\n\tif (!iwl_fw_dbg_is_d3_debug_enabled(fwrt))\n\t\treturn;\n\n\tif (!fwrt->dump.d3_debug_data) {\n\t\tfwrt->dump.d3_debug_data = kmalloc(cfg->d3_debug_data_length,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!fwrt->dump.d3_debug_data) {\n\t\t\tIWL_ERR(fwrt,\n\t\t\t\t\"failed to allocate memory for D3 debug data\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tiwl_trans_read_mem_bytes(fwrt->trans, cfg->d3_debug_data_base_addr,\n\t\t\t\t fwrt->dump.d3_debug_data,\n\t\t\t\t cfg->d3_debug_data_length);\n\n\tif (fwrt->sanitize_ops && fwrt->sanitize_ops->frob_mem)\n\t\tfwrt->sanitize_ops->frob_mem(fwrt->sanitize_ctx,\n\t\t\t\t\t     cfg->d3_debug_data_base_addr,\n\t\t\t\t\t     fwrt->dump.d3_debug_data,\n\t\t\t\t\t     cfg->d3_debug_data_length);\n}\nIWL_EXPORT_SYMBOL(iwl_fw_dbg_read_d3_debug_data);\n\nvoid iwl_fw_dbg_stop_sync(struct iwl_fw_runtime *fwrt)\n{\n\tint i;\n\n\tiwl_dbg_tlv_del_timers(fwrt->trans);\n\tfor (i = 0; i < IWL_FW_RUNTIME_DUMP_WK_NUM; i++)\n\t\tiwl_fw_dbg_collect_sync(fwrt, i);\n\n\tiwl_fw_dbg_stop_restart_recording(fwrt, NULL, true);\n}\nIWL_EXPORT_SYMBOL(iwl_fw_dbg_stop_sync);\n\nstatic int iwl_fw_dbg_suspend_resume_hcmd(struct iwl_trans *trans, bool suspend)\n{\n\tstruct iwl_dbg_suspend_resume_cmd cmd = {\n\t\t.operation = suspend ?\n\t\t\tcpu_to_le32(DBGC_SUSPEND_CMD) :\n\t\t\tcpu_to_le32(DBGC_RESUME_CMD),\n\t};\n\tstruct iwl_host_cmd hcmd = {\n\t\t.id = WIDE_ID(DEBUG_GROUP, DBGC_SUSPEND_RESUME),\n\t\t.data[0] = &cmd,\n\t\t.len[0] = sizeof(cmd),\n\t};\n\n\treturn iwl_trans_send_cmd(trans, &hcmd);\n}\n\nstatic void iwl_fw_dbg_stop_recording(struct iwl_trans *trans,\n\t\t\t\t      struct iwl_fw_dbg_params *params)\n{\n\tif (trans->trans_cfg->device_family == IWL_DEVICE_FAMILY_7000) {\n\t\tiwl_set_bits_prph(trans, MON_BUFF_SAMPLE_CTL, 0x100);\n\t\treturn;\n\t}\n\n\tif (params) {\n\t\tparams->in_sample = iwl_read_umac_prph(trans, DBGC_IN_SAMPLE);\n\t\tparams->out_ctrl = iwl_read_umac_prph(trans, DBGC_OUT_CTRL);\n\t}\n\n\tiwl_write_umac_prph(trans, DBGC_IN_SAMPLE, 0);\n\t \n\tusleep_range(700, 1000);\n\tiwl_write_umac_prph(trans, DBGC_OUT_CTRL, 0);\n}\n\nstatic int iwl_fw_dbg_restart_recording(struct iwl_trans *trans,\n\t\t\t\t\tstruct iwl_fw_dbg_params *params)\n{\n\tif (!params)\n\t\treturn -EIO;\n\n\tif (trans->trans_cfg->device_family == IWL_DEVICE_FAMILY_7000) {\n\t\tiwl_clear_bits_prph(trans, MON_BUFF_SAMPLE_CTL, 0x100);\n\t\tiwl_clear_bits_prph(trans, MON_BUFF_SAMPLE_CTL, 0x1);\n\t\tiwl_set_bits_prph(trans, MON_BUFF_SAMPLE_CTL, 0x1);\n\t} else {\n\t\tiwl_write_umac_prph(trans, DBGC_IN_SAMPLE, params->in_sample);\n\t\tiwl_write_umac_prph(trans, DBGC_OUT_CTRL, params->out_ctrl);\n\t}\n\n\treturn 0;\n}\n\nint iwl_fw_send_timestamp_marker_cmd(struct iwl_fw_runtime *fwrt)\n{\n\tstruct iwl_mvm_marker marker = {\n\t\t.dw_len = sizeof(struct iwl_mvm_marker) / 4,\n\t\t.marker_id = MARKER_ID_SYNC_CLOCK,\n\t};\n\tstruct iwl_host_cmd hcmd = {\n\t\t.flags = CMD_ASYNC,\n\t\t.id = WIDE_ID(LONG_GROUP, MARKER_CMD),\n\t\t.dataflags = {},\n\t};\n\tstruct iwl_mvm_marker_rsp *resp;\n\tint cmd_ver = iwl_fw_lookup_cmd_ver(fwrt->fw,\n\t\t\t\t\t    WIDE_ID(LONG_GROUP, MARKER_CMD),\n\t\t\t\t\t    IWL_FW_CMD_VER_UNKNOWN);\n\tint ret;\n\n\tif (cmd_ver == 1) {\n\t\t \n\t\tmarker.timestamp = cpu_to_le64(fwrt->timestamp.seq++);\n\t} else if (cmd_ver == 2) {\n\t\tmarker.timestamp = cpu_to_le64(ktime_get_boottime_ns());\n\t} else {\n\t\tIWL_DEBUG_INFO(fwrt,\n\t\t\t       \"Invalid version of Marker CMD. Ver = %d\\n\",\n\t\t\t       cmd_ver);\n\t\treturn -EINVAL;\n\t}\n\n\thcmd.data[0] = &marker;\n\thcmd.len[0] = sizeof(marker);\n\n\tret = iwl_trans_send_cmd(fwrt->trans, &hcmd);\n\n\tif (cmd_ver > 1 && hcmd.resp_pkt) {\n\t\tresp = (void *)hcmd.resp_pkt->data;\n\t\tIWL_DEBUG_INFO(fwrt, \"FW GP2 time: %u\\n\",\n\t\t\t       le32_to_cpu(resp->gp2));\n\t}\n\n\treturn ret;\n}\n\nvoid iwl_fw_dbg_stop_restart_recording(struct iwl_fw_runtime *fwrt,\n\t\t\t\t       struct iwl_fw_dbg_params *params,\n\t\t\t\t       bool stop)\n{\n\tint ret __maybe_unused = 0;\n\n\tif (test_bit(STATUS_FW_ERROR, &fwrt->trans->status))\n\t\treturn;\n\n\tif (fw_has_capa(&fwrt->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_DBG_SUSPEND_RESUME_CMD_SUPP)) {\n\t\tif (stop)\n\t\t\tiwl_fw_send_timestamp_marker_cmd(fwrt);\n\t\tret = iwl_fw_dbg_suspend_resume_hcmd(fwrt->trans, stop);\n\t} else if (stop) {\n\t\tiwl_fw_dbg_stop_recording(fwrt->trans, params);\n\t} else {\n\t\tret = iwl_fw_dbg_restart_recording(fwrt->trans, params);\n\t}\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tif (!ret) {\n\t\tif (stop)\n\t\t\tfwrt->trans->dbg.rec_on = false;\n\t\telse\n\t\t\tiwl_fw_set_dbg_rec_on(fwrt);\n\t}\n#endif\n}\nIWL_EXPORT_SYMBOL(iwl_fw_dbg_stop_restart_recording);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}