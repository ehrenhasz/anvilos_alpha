{
  "module_name": "iwl-eeprom-read.c",
  "hash_id": "e10d1b709e6d554d18398719623ee2f6ef87c2ad77c62c0f1f383a38b5aa7719",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/iwl-eeprom-read.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\n#include \"iwl-drv.h\"\n#include \"iwl-debug.h\"\n#include \"iwl-eeprom-read.h\"\n#include \"iwl-io.h\"\n#include \"iwl-prph.h\"\n#include \"iwl-csr.h\"\n\n \n#define IWL_EEPROM_ACCESS_TIMEOUT\t5000  \n\n \n#define IWL_EEPROM_SEM_TIMEOUT\t\t10    \n#define IWL_EEPROM_SEM_RETRY_LIMIT\t1000  \n\n\nstatic int iwl_eeprom_acquire_semaphore(struct iwl_trans *trans)\n{\n\tu16 count;\n\tint ret;\n\n\tfor (count = 0; count < IWL_EEPROM_SEM_RETRY_LIMIT; count++) {\n\t\t \n\t\tiwl_set_bit(trans, CSR_HW_IF_CONFIG_REG,\n\t\t\t    CSR_HW_IF_CONFIG_REG_BIT_EEPROM_OWN_SEM);\n\n\t\t \n\t\tret = iwl_poll_bit(trans, CSR_HW_IF_CONFIG_REG,\n\t\t\t\tCSR_HW_IF_CONFIG_REG_BIT_EEPROM_OWN_SEM,\n\t\t\t\tCSR_HW_IF_CONFIG_REG_BIT_EEPROM_OWN_SEM,\n\t\t\t\tIWL_EEPROM_SEM_TIMEOUT);\n\t\tif (ret >= 0) {\n\t\t\tIWL_DEBUG_EEPROM(trans->dev,\n\t\t\t\t\t \"Acquired semaphore after %d tries.\\n\",\n\t\t\t\t\t count+1);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void iwl_eeprom_release_semaphore(struct iwl_trans *trans)\n{\n\tiwl_clear_bit(trans, CSR_HW_IF_CONFIG_REG,\n\t\t      CSR_HW_IF_CONFIG_REG_BIT_EEPROM_OWN_SEM);\n}\n\nstatic int iwl_eeprom_verify_signature(struct iwl_trans *trans, bool nvm_is_otp)\n{\n\tu32 gp = iwl_read32(trans, CSR_EEPROM_GP) & CSR_EEPROM_GP_VALID_MSK;\n\n\tIWL_DEBUG_EEPROM(trans->dev, \"EEPROM signature=0x%08x\\n\", gp);\n\n\tswitch (gp) {\n\tcase CSR_EEPROM_GP_BAD_SIG_EEP_GOOD_SIG_OTP:\n\t\tif (!nvm_is_otp) {\n\t\t\tIWL_ERR(trans, \"EEPROM with bad signature: 0x%08x\\n\",\n\t\t\t\tgp);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\treturn 0;\n\tcase CSR_EEPROM_GP_GOOD_SIG_EEP_LESS_THAN_4K:\n\tcase CSR_EEPROM_GP_GOOD_SIG_EEP_MORE_THAN_4K:\n\t\tif (nvm_is_otp) {\n\t\t\tIWL_ERR(trans, \"OTP with bad signature: 0x%08x\\n\", gp);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\treturn 0;\n\tcase CSR_EEPROM_GP_BAD_SIGNATURE_BOTH_EEP_AND_OTP:\n\tdefault:\n\t\tIWL_ERR(trans,\n\t\t\t\"bad EEPROM/OTP signature, type=%s, EEPROM_GP=0x%08x\\n\",\n\t\t\tnvm_is_otp ? \"OTP\" : \"EEPROM\", gp);\n\t\treturn -ENOENT;\n\t}\n}\n\n \n\nstatic void iwl_set_otp_access_absolute(struct iwl_trans *trans)\n{\n\tiwl_read32(trans, CSR_OTP_GP_REG);\n\n\tiwl_clear_bit(trans, CSR_OTP_GP_REG,\n\t\t      CSR_OTP_GP_REG_OTP_ACCESS_MODE);\n}\n\nstatic int iwl_nvm_is_otp(struct iwl_trans *trans)\n{\n\tu32 otpgp;\n\n\t \n\tswitch (trans->hw_rev & CSR_HW_REV_TYPE_MSK) {\n\tcase CSR_HW_REV_TYPE_NONE:\n\t\tIWL_ERR(trans, \"Unknown hardware type\\n\");\n\t\treturn -EIO;\n\tcase CSR_HW_REV_TYPE_5300:\n\tcase CSR_HW_REV_TYPE_5350:\n\tcase CSR_HW_REV_TYPE_5100:\n\tcase CSR_HW_REV_TYPE_5150:\n\t\treturn 0;\n\tdefault:\n\t\totpgp = iwl_read32(trans, CSR_OTP_GP_REG);\n\t\tif (otpgp & CSR_OTP_GP_REG_DEVICE_SELECT)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n}\n\nstatic int iwl_init_otp_access(struct iwl_trans *trans)\n{\n\tint ret;\n\n\tret = iwl_finish_nic_init(trans);\n\tif (ret)\n\t\treturn ret;\n\n\tiwl_set_bits_prph(trans, APMG_PS_CTRL_REG,\n\t\t\t  APMG_PS_CTRL_VAL_RESET_REQ);\n\tudelay(5);\n\tiwl_clear_bits_prph(trans, APMG_PS_CTRL_REG,\n\t\t\t    APMG_PS_CTRL_VAL_RESET_REQ);\n\n\t \n\tif (trans->trans_cfg->base_params->shadow_ram_support)\n\t\tiwl_set_bit(trans, CSR_DBG_LINK_PWR_MGMT_REG,\n\t\t\t    CSR_RESET_LINK_PWR_MGMT_DISABLED);\n\n\treturn 0;\n}\n\nstatic int iwl_read_otp_word(struct iwl_trans *trans, u16 addr,\n\t\t\t     __le16 *eeprom_data)\n{\n\tint ret = 0;\n\tu32 r;\n\tu32 otpgp;\n\n\tiwl_write32(trans, CSR_EEPROM_REG,\n\t\t    CSR_EEPROM_REG_MSK_ADDR & (addr << 1));\n\tret = iwl_poll_bit(trans, CSR_EEPROM_REG,\n\t\t\t\t CSR_EEPROM_REG_READ_VALID_MSK,\n\t\t\t\t CSR_EEPROM_REG_READ_VALID_MSK,\n\t\t\t\t IWL_EEPROM_ACCESS_TIMEOUT);\n\tif (ret < 0) {\n\t\tIWL_ERR(trans, \"Time out reading OTP[%d]\\n\", addr);\n\t\treturn ret;\n\t}\n\tr = iwl_read32(trans, CSR_EEPROM_REG);\n\t \n\totpgp = iwl_read32(trans, CSR_OTP_GP_REG);\n\tif (otpgp & CSR_OTP_GP_REG_ECC_UNCORR_STATUS_MSK) {\n\t\t \n\t\t \n\t\tiwl_set_bit(trans, CSR_OTP_GP_REG,\n\t\t\t    CSR_OTP_GP_REG_ECC_UNCORR_STATUS_MSK);\n\t\tIWL_ERR(trans, \"Uncorrectable OTP ECC error, abort OTP read\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (otpgp & CSR_OTP_GP_REG_ECC_CORR_STATUS_MSK) {\n\t\t \n\t\t \n\t\tiwl_set_bit(trans, CSR_OTP_GP_REG,\n\t\t\t    CSR_OTP_GP_REG_ECC_CORR_STATUS_MSK);\n\t\tIWL_ERR(trans, \"Correctable OTP ECC error, continue read\\n\");\n\t}\n\t*eeprom_data = cpu_to_le16(r >> 16);\n\treturn 0;\n}\n\n \nstatic bool iwl_is_otp_empty(struct iwl_trans *trans)\n{\n\tu16 next_link_addr = 0;\n\t__le16 link_value;\n\tbool is_empty = false;\n\n\t \n\tif (!iwl_read_otp_word(trans, next_link_addr, &link_value)) {\n\t\tif (!link_value) {\n\t\t\tIWL_ERR(trans, \"OTP is empty\\n\");\n\t\t\tis_empty = true;\n\t\t}\n\t} else {\n\t\tIWL_ERR(trans, \"Unable to read first block of OTP list.\\n\");\n\t\tis_empty = true;\n\t}\n\n\treturn is_empty;\n}\n\n\n \nstatic int iwl_find_otp_image(struct iwl_trans *trans,\n\t\t\t\t\tu16 *validblockaddr)\n{\n\tu16 next_link_addr = 0, valid_addr;\n\t__le16 link_value = 0;\n\tint usedblocks = 0;\n\n\t \n\tiwl_set_otp_access_absolute(trans);\n\n\t \n\tif (iwl_is_otp_empty(trans))\n\t\treturn -EINVAL;\n\n\t \n\tdo {\n\t\t \n\t\tvalid_addr = next_link_addr;\n\t\tnext_link_addr = le16_to_cpu(link_value) * sizeof(u16);\n\t\tIWL_DEBUG_EEPROM(trans->dev, \"OTP blocks %d addr 0x%x\\n\",\n\t\t\t\t usedblocks, next_link_addr);\n\t\tif (iwl_read_otp_word(trans, next_link_addr, &link_value))\n\t\t\treturn -EINVAL;\n\t\tif (!link_value) {\n\t\t\t \n\t\t\t*validblockaddr = valid_addr;\n\t\t\t \n\t\t\t*validblockaddr += 2;\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tusedblocks++;\n\t} while (usedblocks <= trans->trans_cfg->base_params->max_ll_items);\n\n\t \n\tIWL_DEBUG_EEPROM(trans->dev, \"OTP has no valid blocks\\n\");\n\treturn -EINVAL;\n}\n\n \nint iwl_read_eeprom(struct iwl_trans *trans, u8 **eeprom, size_t *eeprom_size)\n{\n\t__le16 *e;\n\tu32 gp = iwl_read32(trans, CSR_EEPROM_GP);\n\tint sz;\n\tint ret;\n\tu16 addr;\n\tu16 validblockaddr = 0;\n\tu16 cache_addr = 0;\n\tint nvm_is_otp;\n\n\tif (!eeprom || !eeprom_size)\n\t\treturn -EINVAL;\n\n\tnvm_is_otp = iwl_nvm_is_otp(trans);\n\tif (nvm_is_otp < 0)\n\t\treturn nvm_is_otp;\n\n\tsz = trans->trans_cfg->base_params->eeprom_size;\n\tIWL_DEBUG_EEPROM(trans->dev, \"NVM size = %d\\n\", sz);\n\n\te = kmalloc(sz, GFP_KERNEL);\n\tif (!e)\n\t\treturn -ENOMEM;\n\n\tret = iwl_eeprom_verify_signature(trans, nvm_is_otp);\n\tif (ret < 0) {\n\t\tIWL_ERR(trans, \"EEPROM not found, EEPROM_GP=0x%08x\\n\", gp);\n\t\tgoto err_free;\n\t}\n\n\t \n\tret = iwl_eeprom_acquire_semaphore(trans);\n\tif (ret < 0) {\n\t\tIWL_ERR(trans, \"Failed to acquire EEPROM semaphore.\\n\");\n\t\tgoto err_free;\n\t}\n\n\tif (nvm_is_otp) {\n\t\tret = iwl_init_otp_access(trans);\n\t\tif (ret) {\n\t\t\tIWL_ERR(trans, \"Failed to initialize OTP access.\\n\");\n\t\t\tgoto err_unlock;\n\t\t}\n\n\t\tiwl_write32(trans, CSR_EEPROM_GP,\n\t\t\t    iwl_read32(trans, CSR_EEPROM_GP) &\n\t\t\t    ~CSR_EEPROM_GP_IF_OWNER_MSK);\n\n\t\tiwl_set_bit(trans, CSR_OTP_GP_REG,\n\t\t\t    CSR_OTP_GP_REG_ECC_CORR_STATUS_MSK |\n\t\t\t    CSR_OTP_GP_REG_ECC_UNCORR_STATUS_MSK);\n\t\t \n\t\tif (!trans->trans_cfg->base_params->shadow_ram_support) {\n\t\t\tret = iwl_find_otp_image(trans, &validblockaddr);\n\t\t\tif (ret)\n\t\t\t\tgoto err_unlock;\n\t\t}\n\t\tfor (addr = validblockaddr; addr < validblockaddr + sz;\n\t\t     addr += sizeof(u16)) {\n\t\t\t__le16 eeprom_data;\n\n\t\t\tret = iwl_read_otp_word(trans, addr, &eeprom_data);\n\t\t\tif (ret)\n\t\t\t\tgoto err_unlock;\n\t\t\te[cache_addr / 2] = eeprom_data;\n\t\t\tcache_addr += sizeof(u16);\n\t\t}\n\t} else {\n\t\t \n\t\tfor (addr = 0; addr < sz; addr += sizeof(u16)) {\n\t\t\tu32 r;\n\n\t\t\tiwl_write32(trans, CSR_EEPROM_REG,\n\t\t\t\t    CSR_EEPROM_REG_MSK_ADDR & (addr << 1));\n\n\t\t\tret = iwl_poll_bit(trans, CSR_EEPROM_REG,\n\t\t\t\t\t   CSR_EEPROM_REG_READ_VALID_MSK,\n\t\t\t\t\t   CSR_EEPROM_REG_READ_VALID_MSK,\n\t\t\t\t\t   IWL_EEPROM_ACCESS_TIMEOUT);\n\t\t\tif (ret < 0) {\n\t\t\t\tIWL_ERR(trans,\n\t\t\t\t\t\"Time out reading EEPROM[%d]\\n\", addr);\n\t\t\t\tgoto err_unlock;\n\t\t\t}\n\t\t\tr = iwl_read32(trans, CSR_EEPROM_REG);\n\t\t\te[addr / 2] = cpu_to_le16(r >> 16);\n\t\t}\n\t}\n\n\tIWL_DEBUG_EEPROM(trans->dev, \"NVM Type: %s\\n\",\n\t\t\t nvm_is_otp ? \"OTP\" : \"EEPROM\");\n\n\tiwl_eeprom_release_semaphore(trans);\n\n\t*eeprom_size = sz;\n\t*eeprom = (u8 *)e;\n\treturn 0;\n\n err_unlock:\n\tiwl_eeprom_release_semaphore(trans);\n err_free:\n\tkfree(e);\n\n\treturn ret;\n}\nIWL_EXPORT_SYMBOL(iwl_read_eeprom);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}