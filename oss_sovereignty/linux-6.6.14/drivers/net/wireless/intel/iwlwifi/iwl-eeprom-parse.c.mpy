{
  "module_name": "iwl-eeprom-parse.c",
  "hash_id": "27e5a9425a5b349b7a523e054a13748b3fc3b0a435a60e373446d6597cddd8c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/iwl-eeprom-parse.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include \"iwl-drv.h\"\n#include \"iwl-modparams.h\"\n#include \"iwl-eeprom-parse.h\"\n\n#if IS_ENABLED(CONFIG_IWLDVM)\n \n\n \n#define ADDRESS_MSK                 0x0000FFFF\n#define INDIRECT_TYPE_MSK           0x000F0000\n#define INDIRECT_HOST               0x00010000\n#define INDIRECT_GENERAL            0x00020000\n#define INDIRECT_REGULATORY         0x00030000\n#define INDIRECT_CALIBRATION        0x00040000\n#define INDIRECT_PROCESS_ADJST      0x00050000\n#define INDIRECT_OTHERS             0x00060000\n#define INDIRECT_TXP_LIMIT          0x00070000\n#define INDIRECT_TXP_LIMIT_SIZE     0x00080000\n#define INDIRECT_ADDRESS            0x00100000\n\n \n#define EEPROM_LINK_HOST             (2*0x64)\n#define EEPROM_LINK_GENERAL          (2*0x65)\n#define EEPROM_LINK_REGULATORY       (2*0x66)\n#define EEPROM_LINK_CALIBRATION      (2*0x67)\n#define EEPROM_LINK_PROCESS_ADJST    (2*0x68)\n#define EEPROM_LINK_OTHERS           (2*0x69)\n#define EEPROM_LINK_TXP_LIMIT        (2*0x6a)\n#define EEPROM_LINK_TXP_LIMIT_SIZE   (2*0x6b)\n\n \n#define EEPROM_DEVICE_ID                    (2*0x08)\t \n#define EEPROM_SUBSYSTEM_ID\t\t    (2*0x0A)\t \n#define EEPROM_MAC_ADDRESS                  (2*0x15)\t \n#define EEPROM_BOARD_REVISION               (2*0x35)\t \n#define EEPROM_BOARD_PBA_NUMBER             (2*0x3B+1)\t \n#define EEPROM_VERSION                      (2*0x44)\t \n#define EEPROM_SKU_CAP                      (2*0x45)\t \n#define EEPROM_OEM_MODE                     (2*0x46)\t \n#define EEPROM_RADIO_CONFIG                 (2*0x48)\t \n#define EEPROM_NUM_MAC_ADDRESS              (2*0x4C)\t \n\n \nstruct iwl_eeprom_calib_hdr {\n\tu8 version;\n\tu8 pa_type;\n\t__le16 voltage;\n} __packed;\n\n#define EEPROM_CALIB_ALL\t(INDIRECT_ADDRESS | INDIRECT_CALIBRATION)\n#define EEPROM_XTAL\t\t((2*0x128) | EEPROM_CALIB_ALL)\n\n \n#define EEPROM_KELVIN_TEMPERATURE\t((2*0x12A) | EEPROM_CALIB_ALL)\n#define EEPROM_RAW_TEMPERATURE\t\t((2*0x12B) | EEPROM_CALIB_ALL)\n\n \nenum eeprom_sku_bits {\n\tEEPROM_SKU_CAP_BAND_24GHZ\t= BIT(4),\n\tEEPROM_SKU_CAP_BAND_52GHZ\t= BIT(5),\n\tEEPROM_SKU_CAP_11N_ENABLE\t= BIT(6),\n\tEEPROM_SKU_CAP_AMT_ENABLE\t= BIT(7),\n\tEEPROM_SKU_CAP_IPAN_ENABLE\t= BIT(8)\n};\n\n \n#define EEPROM_RF_CFG_TYPE_MSK(x)   (x & 0x3)          \n#define EEPROM_RF_CFG_STEP_MSK(x)   ((x >> 2)  & 0x3)  \n#define EEPROM_RF_CFG_DASH_MSK(x)   ((x >> 4)  & 0x3)  \n#define EEPROM_RF_CFG_PNUM_MSK(x)   ((x >> 6)  & 0x3)  \n#define EEPROM_RF_CFG_TX_ANT_MSK(x) ((x >> 8)  & 0xF)  \n#define EEPROM_RF_CFG_RX_ANT_MSK(x) ((x >> 12) & 0xF)  \n\n\n \nstatic const u8 iwl_eeprom_band_1[14] = {  \n\t1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14\n};\n\nstatic const u8 iwl_eeprom_band_2[] = {\t \n\t183, 184, 185, 187, 188, 189, 192, 196, 7, 8, 11, 12, 16\n};\n\nstatic const u8 iwl_eeprom_band_3[] = {\t \n\t34, 36, 38, 40, 42, 44, 46, 48, 52, 56, 60, 64\n};\n\nstatic const u8 iwl_eeprom_band_4[] = {\t \n\t100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140\n};\n\nstatic const u8 iwl_eeprom_band_5[] = {\t \n\t145, 149, 153, 157, 161, 165\n};\n\nstatic const u8 iwl_eeprom_band_6[] = {\t \n\t1, 2, 3, 4, 5, 6, 7\n};\n\nstatic const u8 iwl_eeprom_band_7[] = {\t \n\t36, 44, 52, 60, 100, 108, 116, 124, 132, 149, 157\n};\n\n#define IWL_NUM_CHANNELS\t(ARRAY_SIZE(iwl_eeprom_band_1) + \\\n\t\t\t\t ARRAY_SIZE(iwl_eeprom_band_2) + \\\n\t\t\t\t ARRAY_SIZE(iwl_eeprom_band_3) + \\\n\t\t\t\t ARRAY_SIZE(iwl_eeprom_band_4) + \\\n\t\t\t\t ARRAY_SIZE(iwl_eeprom_band_5))\n\n \nstatic struct ieee80211_rate iwl_cfg80211_rates[] = {\n\t{ .bitrate = 1 * 10, .hw_value = 0, .hw_value_short = 0, },\n\t{ .bitrate = 2 * 10, .hw_value = 1, .hw_value_short = 1,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE, },\n\t{ .bitrate = 5.5 * 10, .hw_value = 2, .hw_value_short = 2,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE, },\n\t{ .bitrate = 11 * 10, .hw_value = 3, .hw_value_short = 3,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE, },\n\t{ .bitrate = 6 * 10, .hw_value = 4, .hw_value_short = 4, },\n\t{ .bitrate = 9 * 10, .hw_value = 5, .hw_value_short = 5, },\n\t{ .bitrate = 12 * 10, .hw_value = 6, .hw_value_short = 6, },\n\t{ .bitrate = 18 * 10, .hw_value = 7, .hw_value_short = 7, },\n\t{ .bitrate = 24 * 10, .hw_value = 8, .hw_value_short = 8, },\n\t{ .bitrate = 36 * 10, .hw_value = 9, .hw_value_short = 9, },\n\t{ .bitrate = 48 * 10, .hw_value = 10, .hw_value_short = 10, },\n\t{ .bitrate = 54 * 10, .hw_value = 11, .hw_value_short = 11, },\n};\n#define RATES_24_OFFS\t0\n#define N_RATES_24\tARRAY_SIZE(iwl_cfg80211_rates)\n#define RATES_52_OFFS\t4\n#define N_RATES_52\t(N_RATES_24 - RATES_52_OFFS)\n\n \n\nstatic u16 iwl_eeprom_query16(const u8 *eeprom, size_t eeprom_size, int offset)\n{\n\tif (WARN_ON(offset + sizeof(u16) > eeprom_size))\n\t\treturn 0;\n\treturn le16_to_cpup((__le16 *)(eeprom + offset));\n}\n\nstatic u32 eeprom_indirect_address(const u8 *eeprom, size_t eeprom_size,\n\t\t\t\t   u32 address)\n{\n\tu16 offset = 0;\n\n\tif ((address & INDIRECT_ADDRESS) == 0)\n\t\treturn address;\n\n\tswitch (address & INDIRECT_TYPE_MSK) {\n\tcase INDIRECT_HOST:\n\t\toffset = iwl_eeprom_query16(eeprom, eeprom_size,\n\t\t\t\t\t    EEPROM_LINK_HOST);\n\t\tbreak;\n\tcase INDIRECT_GENERAL:\n\t\toffset = iwl_eeprom_query16(eeprom, eeprom_size,\n\t\t\t\t\t    EEPROM_LINK_GENERAL);\n\t\tbreak;\n\tcase INDIRECT_REGULATORY:\n\t\toffset = iwl_eeprom_query16(eeprom, eeprom_size,\n\t\t\t\t\t    EEPROM_LINK_REGULATORY);\n\t\tbreak;\n\tcase INDIRECT_TXP_LIMIT:\n\t\toffset = iwl_eeprom_query16(eeprom, eeprom_size,\n\t\t\t\t\t    EEPROM_LINK_TXP_LIMIT);\n\t\tbreak;\n\tcase INDIRECT_TXP_LIMIT_SIZE:\n\t\toffset = iwl_eeprom_query16(eeprom, eeprom_size,\n\t\t\t\t\t    EEPROM_LINK_TXP_LIMIT_SIZE);\n\t\tbreak;\n\tcase INDIRECT_CALIBRATION:\n\t\toffset = iwl_eeprom_query16(eeprom, eeprom_size,\n\t\t\t\t\t    EEPROM_LINK_CALIBRATION);\n\t\tbreak;\n\tcase INDIRECT_PROCESS_ADJST:\n\t\toffset = iwl_eeprom_query16(eeprom, eeprom_size,\n\t\t\t\t\t    EEPROM_LINK_PROCESS_ADJST);\n\t\tbreak;\n\tcase INDIRECT_OTHERS:\n\t\toffset = iwl_eeprom_query16(eeprom, eeprom_size,\n\t\t\t\t\t    EEPROM_LINK_OTHERS);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\t \n\treturn (address & ADDRESS_MSK) + (offset << 1);\n}\n\nstatic const u8 *iwl_eeprom_query_addr(const u8 *eeprom, size_t eeprom_size,\n\t\t\t\t       u32 offset)\n{\n\tu32 address = eeprom_indirect_address(eeprom, eeprom_size, offset);\n\n\tif (WARN_ON(address >= eeprom_size))\n\t\treturn NULL;\n\n\treturn &eeprom[address];\n}\n\nstatic int iwl_eeprom_read_calib(const u8 *eeprom, size_t eeprom_size,\n\t\t\t\t struct iwl_nvm_data *data)\n{\n\tstruct iwl_eeprom_calib_hdr *hdr;\n\n\thdr = (void *)iwl_eeprom_query_addr(eeprom, eeprom_size,\n\t\t\t\t\t    EEPROM_CALIB_ALL);\n\tif (!hdr)\n\t\treturn -ENODATA;\n\tdata->calib_version = hdr->version;\n\tdata->calib_voltage = hdr->voltage;\n\n\treturn 0;\n}\n\n \nenum iwl_eeprom_channel_flags {\n\tEEPROM_CHANNEL_VALID = BIT(0),\n\tEEPROM_CHANNEL_IBSS = BIT(1),\n\tEEPROM_CHANNEL_ACTIVE = BIT(3),\n\tEEPROM_CHANNEL_RADAR = BIT(4),\n\tEEPROM_CHANNEL_WIDE = BIT(5),\n\tEEPROM_CHANNEL_DFS = BIT(7),\n};\n\n \nstruct iwl_eeprom_channel {\n\tu8 flags;\n\ts8 max_power_avg;\n} __packed;\n\n\nenum iwl_eeprom_enhanced_txpwr_flags {\n\tIWL_EEPROM_ENH_TXP_FL_VALID = BIT(0),\n\tIWL_EEPROM_ENH_TXP_FL_BAND_52G = BIT(1),\n\tIWL_EEPROM_ENH_TXP_FL_OFDM = BIT(2),\n\tIWL_EEPROM_ENH_TXP_FL_40MHZ = BIT(3),\n\tIWL_EEPROM_ENH_TXP_FL_HT_AP = BIT(4),\n\tIWL_EEPROM_ENH_TXP_FL_RES1 = BIT(5),\n\tIWL_EEPROM_ENH_TXP_FL_RES2 = BIT(6),\n\tIWL_EEPROM_ENH_TXP_FL_COMMON_TYPE = BIT(7),\n};\n\n \nstruct iwl_eeprom_enhanced_txpwr {\n\tu8 flags;\n\tu8 channel;\n\ts8 chain_a_max;\n\ts8 chain_b_max;\n\ts8 chain_c_max;\n\tu8 delta_20_in_40;\n\ts8 mimo2_max;\n\ts8 mimo3_max;\n} __packed;\n\nstatic s8 iwl_get_max_txpwr_half_dbm(const struct iwl_nvm_data *data,\n\t\t\t\t     struct iwl_eeprom_enhanced_txpwr *txp)\n{\n\ts8 result = 0;  \n\n\t \n\tif (data->valid_tx_ant & ANT_A && txp->chain_a_max > result)\n\t\tresult = txp->chain_a_max;\n\n\tif (data->valid_tx_ant & ANT_B && txp->chain_b_max > result)\n\t\tresult = txp->chain_b_max;\n\n\tif (data->valid_tx_ant & ANT_C && txp->chain_c_max > result)\n\t\tresult = txp->chain_c_max;\n\n\tif ((data->valid_tx_ant == ANT_AB ||\n\t     data->valid_tx_ant == ANT_BC ||\n\t     data->valid_tx_ant == ANT_AC) && txp->mimo2_max > result)\n\t\tresult = txp->mimo2_max;\n\n\tif (data->valid_tx_ant == ANT_ABC && txp->mimo3_max > result)\n\t\tresult = txp->mimo3_max;\n\n\treturn result;\n}\n\n#define EEPROM_TXP_OFFS\t(0x00 | INDIRECT_ADDRESS | INDIRECT_TXP_LIMIT)\n#define EEPROM_TXP_ENTRY_LEN sizeof(struct iwl_eeprom_enhanced_txpwr)\n#define EEPROM_TXP_SZ_OFFS (0x00 | INDIRECT_ADDRESS | INDIRECT_TXP_LIMIT_SIZE)\n\n#define TXP_CHECK_AND_PRINT(x) \\\n\t((txp->flags & IWL_EEPROM_ENH_TXP_FL_##x) ? # x \" \" : \"\")\n\nstatic void\niwl_eeprom_enh_txp_read_element(struct iwl_nvm_data *data,\n\t\t\t\tstruct iwl_eeprom_enhanced_txpwr *txp,\n\t\t\t\tint n_channels, s8 max_txpower_avg)\n{\n\tint ch_idx;\n\tenum nl80211_band band;\n\n\tband = txp->flags & IWL_EEPROM_ENH_TXP_FL_BAND_52G ?\n\t\tNL80211_BAND_5GHZ : NL80211_BAND_2GHZ;\n\n\tfor (ch_idx = 0; ch_idx < n_channels; ch_idx++) {\n\t\tstruct ieee80211_channel *chan = &data->channels[ch_idx];\n\n\t\t \n\t\tif (txp->channel != 0 && chan->hw_value != txp->channel)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (band != chan->band)\n\t\t\tcontinue;\n\n\t\tif (chan->max_power < max_txpower_avg &&\n\t\t    !(txp->flags & IWL_EEPROM_ENH_TXP_FL_40MHZ))\n\t\t\tchan->max_power = max_txpower_avg;\n\t}\n}\n\nstatic void iwl_eeprom_enhanced_txpower(struct device *dev,\n\t\t\t\t\tstruct iwl_nvm_data *data,\n\t\t\t\t\tconst u8 *eeprom, size_t eeprom_size,\n\t\t\t\t\tint n_channels)\n{\n\tstruct iwl_eeprom_enhanced_txpwr *txp_array, *txp;\n\tint idx, entries;\n\t__le16 *txp_len;\n\ts8 max_txp_avg_halfdbm;\n\n\tBUILD_BUG_ON(sizeof(struct iwl_eeprom_enhanced_txpwr) != 8);\n\n\t \n\ttxp_len = (__le16 *)iwl_eeprom_query_addr(eeprom, eeprom_size,\n\t\t\t\t\t\t  EEPROM_TXP_SZ_OFFS);\n\tentries = le16_to_cpup(txp_len) * 2 / EEPROM_TXP_ENTRY_LEN;\n\n\ttxp_array = (void *)iwl_eeprom_query_addr(eeprom, eeprom_size,\n\t\t\t\t\t\t  EEPROM_TXP_OFFS);\n\n\tfor (idx = 0; idx < entries; idx++) {\n\t\ttxp = &txp_array[idx];\n\t\t \n\t\tif (!(txp->flags & IWL_EEPROM_ENH_TXP_FL_VALID))\n\t\t\tcontinue;\n\n\t\tIWL_DEBUG_EEPROM(dev, \"%s %d:\\t %s%s%s%s%s%s%s%s (0x%02x)\\n\",\n\t\t\t\t (txp->channel && (txp->flags &\n\t\t\t\t\tIWL_EEPROM_ENH_TXP_FL_COMMON_TYPE)) ?\n\t\t\t\t\t\"Common \" : (txp->channel) ?\n\t\t\t\t\t\"Channel\" : \"Common\",\n\t\t\t\t (txp->channel),\n\t\t\t\t TXP_CHECK_AND_PRINT(VALID),\n\t\t\t\t TXP_CHECK_AND_PRINT(BAND_52G),\n\t\t\t\t TXP_CHECK_AND_PRINT(OFDM),\n\t\t\t\t TXP_CHECK_AND_PRINT(40MHZ),\n\t\t\t\t TXP_CHECK_AND_PRINT(HT_AP),\n\t\t\t\t TXP_CHECK_AND_PRINT(RES1),\n\t\t\t\t TXP_CHECK_AND_PRINT(RES2),\n\t\t\t\t TXP_CHECK_AND_PRINT(COMMON_TYPE),\n\t\t\t\t txp->flags);\n\t\tIWL_DEBUG_EEPROM(dev,\n\t\t\t\t \"\\t\\t chain_A: %d chain_B: %d chain_C: %d\\n\",\n\t\t\t\t txp->chain_a_max, txp->chain_b_max,\n\t\t\t\t txp->chain_c_max);\n\t\tIWL_DEBUG_EEPROM(dev,\n\t\t\t\t \"\\t\\t MIMO2: %d MIMO3: %d High 20_on_40: 0x%02x Low 20_on_40: 0x%02x\\n\",\n\t\t\t\t txp->mimo2_max, txp->mimo3_max,\n\t\t\t\t ((txp->delta_20_in_40 & 0xf0) >> 4),\n\t\t\t\t (txp->delta_20_in_40 & 0x0f));\n\n\t\tmax_txp_avg_halfdbm = iwl_get_max_txpwr_half_dbm(data, txp);\n\n\t\tiwl_eeprom_enh_txp_read_element(data, txp, n_channels,\n\t\t\t\tDIV_ROUND_UP(max_txp_avg_halfdbm, 2));\n\n\t\tif (max_txp_avg_halfdbm > data->max_tx_pwr_half_dbm)\n\t\t\tdata->max_tx_pwr_half_dbm = max_txp_avg_halfdbm;\n\t}\n}\n\nstatic void iwl_init_band_reference(const struct iwl_cfg *cfg,\n\t\t\t\t    const u8 *eeprom, size_t eeprom_size,\n\t\t\t\t    int eeprom_band, int *eeprom_ch_count,\n\t\t\t\t    const struct iwl_eeprom_channel **ch_info,\n\t\t\t\t    const u8 **eeprom_ch_array)\n{\n\tu32 offset = cfg->eeprom_params->regulatory_bands[eeprom_band - 1];\n\n\toffset |= INDIRECT_ADDRESS | INDIRECT_REGULATORY;\n\n\t*ch_info = (void *)iwl_eeprom_query_addr(eeprom, eeprom_size, offset);\n\n\tswitch (eeprom_band) {\n\tcase 1:\t\t \n\t\t*eeprom_ch_count = ARRAY_SIZE(iwl_eeprom_band_1);\n\t\t*eeprom_ch_array = iwl_eeprom_band_1;\n\t\tbreak;\n\tcase 2:\t\t \n\t\t*eeprom_ch_count = ARRAY_SIZE(iwl_eeprom_band_2);\n\t\t*eeprom_ch_array = iwl_eeprom_band_2;\n\t\tbreak;\n\tcase 3:\t\t \n\t\t*eeprom_ch_count = ARRAY_SIZE(iwl_eeprom_band_3);\n\t\t*eeprom_ch_array = iwl_eeprom_band_3;\n\t\tbreak;\n\tcase 4:\t\t \n\t\t*eeprom_ch_count = ARRAY_SIZE(iwl_eeprom_band_4);\n\t\t*eeprom_ch_array = iwl_eeprom_band_4;\n\t\tbreak;\n\tcase 5:\t\t \n\t\t*eeprom_ch_count = ARRAY_SIZE(iwl_eeprom_band_5);\n\t\t*eeprom_ch_array = iwl_eeprom_band_5;\n\t\tbreak;\n\tcase 6:\t\t \n\t\t*eeprom_ch_count = ARRAY_SIZE(iwl_eeprom_band_6);\n\t\t*eeprom_ch_array = iwl_eeprom_band_6;\n\t\tbreak;\n\tcase 7:\t\t \n\t\t*eeprom_ch_count = ARRAY_SIZE(iwl_eeprom_band_7);\n\t\t*eeprom_ch_array = iwl_eeprom_band_7;\n\t\tbreak;\n\tdefault:\n\t\t*eeprom_ch_count = 0;\n\t\t*eeprom_ch_array = NULL;\n\t\tWARN_ON(1);\n\t}\n}\n\n#define CHECK_AND_PRINT(x) \\\n\t((eeprom_ch->flags & EEPROM_CHANNEL_##x) ? # x \" \" : \"\")\n\nstatic void iwl_mod_ht40_chan_info(struct device *dev,\n\t\t\t\t   struct iwl_nvm_data *data, int n_channels,\n\t\t\t\t   enum nl80211_band band, u16 channel,\n\t\t\t\t   const struct iwl_eeprom_channel *eeprom_ch,\n\t\t\t\t   u8 clear_ht40_extension_channel)\n{\n\tstruct ieee80211_channel *chan = NULL;\n\tint i;\n\n\tfor (i = 0; i < n_channels; i++) {\n\t\tif (data->channels[i].band != band)\n\t\t\tcontinue;\n\t\tif (data->channels[i].hw_value != channel)\n\t\t\tcontinue;\n\t\tchan = &data->channels[i];\n\t\tbreak;\n\t}\n\n\tif (!chan)\n\t\treturn;\n\n\tIWL_DEBUG_EEPROM(dev,\n\t\t\t \"HT40 Ch. %d [%sGHz] %s%s%s%s%s(0x%02x %ddBm): Ad-Hoc %ssupported\\n\",\n\t\t\t channel,\n\t\t\t band == NL80211_BAND_5GHZ ? \"5.2\" : \"2.4\",\n\t\t\t CHECK_AND_PRINT(IBSS),\n\t\t\t CHECK_AND_PRINT(ACTIVE),\n\t\t\t CHECK_AND_PRINT(RADAR),\n\t\t\t CHECK_AND_PRINT(WIDE),\n\t\t\t CHECK_AND_PRINT(DFS),\n\t\t\t eeprom_ch->flags,\n\t\t\t eeprom_ch->max_power_avg,\n\t\t\t ((eeprom_ch->flags & EEPROM_CHANNEL_IBSS) &&\n\t\t\t  !(eeprom_ch->flags & EEPROM_CHANNEL_RADAR)) ? \"\"\n\t\t\t\t\t\t\t\t      : \"not \");\n\n\tif (eeprom_ch->flags & EEPROM_CHANNEL_VALID)\n\t\tchan->flags &= ~clear_ht40_extension_channel;\n}\n\n#define CHECK_AND_PRINT_I(x)\t\\\n\t((eeprom_ch_info[ch_idx].flags & EEPROM_CHANNEL_##x) ? # x \" \" : \"\")\n\nstatic int iwl_init_channel_map(struct device *dev, const struct iwl_cfg *cfg,\n\t\t\t\tstruct iwl_nvm_data *data,\n\t\t\t\tconst u8 *eeprom, size_t eeprom_size)\n{\n\tint band, ch_idx;\n\tconst struct iwl_eeprom_channel *eeprom_ch_info;\n\tconst u8 *eeprom_ch_array;\n\tint eeprom_ch_count;\n\tint n_channels = 0;\n\n\t \n\tfor (band = 1; band <= 5; band++) {\n\t\tstruct ieee80211_channel *channel;\n\n\t\tiwl_init_band_reference(cfg, eeprom, eeprom_size, band,\n\t\t\t\t\t&eeprom_ch_count, &eeprom_ch_info,\n\t\t\t\t\t&eeprom_ch_array);\n\n\t\t \n\t\tfor (ch_idx = 0; ch_idx < eeprom_ch_count; ch_idx++) {\n\t\t\tconst struct iwl_eeprom_channel *eeprom_ch;\n\n\t\t\teeprom_ch = &eeprom_ch_info[ch_idx];\n\n\t\t\tif (!(eeprom_ch->flags & EEPROM_CHANNEL_VALID)) {\n\t\t\t\tIWL_DEBUG_EEPROM(dev,\n\t\t\t\t\t\t \"Ch. %d Flags %x [%sGHz] - No traffic\\n\",\n\t\t\t\t\t\t eeprom_ch_array[ch_idx],\n\t\t\t\t\t\t eeprom_ch_info[ch_idx].flags,\n\t\t\t\t\t\t (band != 1) ? \"5.2\" : \"2.4\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchannel = &data->channels[n_channels];\n\t\t\tn_channels++;\n\n\t\t\tchannel->hw_value = eeprom_ch_array[ch_idx];\n\t\t\tchannel->band = (band == 1) ? NL80211_BAND_2GHZ\n\t\t\t\t\t\t    : NL80211_BAND_5GHZ;\n\t\t\tchannel->center_freq =\n\t\t\t\tieee80211_channel_to_frequency(\n\t\t\t\t\tchannel->hw_value, channel->band);\n\n\t\t\t \n\t\t\tchannel->flags = IEEE80211_CHAN_NO_HT40;\n\n\t\t\tif (!(eeprom_ch->flags & EEPROM_CHANNEL_IBSS))\n\t\t\t\tchannel->flags |= IEEE80211_CHAN_NO_IR;\n\n\t\t\tif (!(eeprom_ch->flags & EEPROM_CHANNEL_ACTIVE))\n\t\t\t\tchannel->flags |= IEEE80211_CHAN_NO_IR;\n\n\t\t\tif (eeprom_ch->flags & EEPROM_CHANNEL_RADAR)\n\t\t\t\tchannel->flags |= IEEE80211_CHAN_RADAR;\n\n\t\t\t \n\t\t\tchannel->max_power =\n\t\t\t\teeprom_ch_info[ch_idx].max_power_avg;\n\t\t\tIWL_DEBUG_EEPROM(dev,\n\t\t\t\t\t \"Ch. %d [%sGHz] %s%s%s%s%s%s(0x%02x %ddBm): Ad-Hoc %ssupported\\n\",\n\t\t\t\t\t channel->hw_value,\n\t\t\t\t\t (band != 1) ? \"5.2\" : \"2.4\",\n\t\t\t\t\t CHECK_AND_PRINT_I(VALID),\n\t\t\t\t\t CHECK_AND_PRINT_I(IBSS),\n\t\t\t\t\t CHECK_AND_PRINT_I(ACTIVE),\n\t\t\t\t\t CHECK_AND_PRINT_I(RADAR),\n\t\t\t\t\t CHECK_AND_PRINT_I(WIDE),\n\t\t\t\t\t CHECK_AND_PRINT_I(DFS),\n\t\t\t\t\t eeprom_ch_info[ch_idx].flags,\n\t\t\t\t\t eeprom_ch_info[ch_idx].max_power_avg,\n\t\t\t\t\t ((eeprom_ch_info[ch_idx].flags &\n\t\t\t\t\t\t\tEEPROM_CHANNEL_IBSS) &&\n\t\t\t\t\t  !(eeprom_ch_info[ch_idx].flags &\n\t\t\t\t\t\t\tEEPROM_CHANNEL_RADAR))\n\t\t\t\t\t\t? \"\" : \"not \");\n\t\t}\n\t}\n\n\tif (cfg->eeprom_params->enhanced_txpower) {\n\t\t \n\t\tiwl_eeprom_enhanced_txpower(dev, data, eeprom, eeprom_size,\n\t\t\t\t\t    n_channels);\n\t} else {\n\t\t \n\t\tint i;\n\n\t\tdata->max_tx_pwr_half_dbm = -128;\n\n\t\tfor (i = 0; i < n_channels; i++)\n\t\t\tdata->max_tx_pwr_half_dbm =\n\t\t\t\tmax_t(s8, data->max_tx_pwr_half_dbm,\n\t\t\t\t      data->channels[i].max_power * 2);\n\t}\n\n\t \n\tif (cfg->eeprom_params->regulatory_bands[5] ==\n\t\t\t\tEEPROM_REGULATORY_BAND_NO_HT40 &&\n\t    cfg->eeprom_params->regulatory_bands[6] ==\n\t\t\t\tEEPROM_REGULATORY_BAND_NO_HT40)\n\t\treturn n_channels;\n\n\t \n\tfor (band = 6; band <= 7; band++) {\n\t\tenum nl80211_band ieeeband;\n\n\t\tiwl_init_band_reference(cfg, eeprom, eeprom_size, band,\n\t\t\t\t\t&eeprom_ch_count, &eeprom_ch_info,\n\t\t\t\t\t&eeprom_ch_array);\n\n\t\t \n\t\tieeeband = (band == 6) ? NL80211_BAND_2GHZ\n\t\t\t\t       : NL80211_BAND_5GHZ;\n\n\t\t \n\t\tfor (ch_idx = 0; ch_idx < eeprom_ch_count; ch_idx++) {\n\t\t\t \n\t\t\tiwl_mod_ht40_chan_info(dev, data, n_channels, ieeeband,\n\t\t\t\t\t       eeprom_ch_array[ch_idx],\n\t\t\t\t\t       &eeprom_ch_info[ch_idx],\n\t\t\t\t\t       IEEE80211_CHAN_NO_HT40PLUS);\n\n\t\t\t \n\t\t\tiwl_mod_ht40_chan_info(dev, data, n_channels, ieeeband,\n\t\t\t\t\t       eeprom_ch_array[ch_idx] + 4,\n\t\t\t\t\t       &eeprom_ch_info[ch_idx],\n\t\t\t\t\t       IEEE80211_CHAN_NO_HT40MINUS);\n\t\t}\n\t}\n\n\treturn n_channels;\n}\n#endif\n\nint iwl_init_sband_channels(struct iwl_nvm_data *data,\n\t\t\t    struct ieee80211_supported_band *sband,\n\t\t\t    int n_channels, enum nl80211_band band)\n{\n\tstruct ieee80211_channel *chan = &data->channels[0];\n\tint n = 0, idx = 0;\n\n\twhile (idx < n_channels && chan->band != band)\n\t\tchan = &data->channels[++idx];\n\n\tsband->channels = &data->channels[idx];\n\n\twhile (idx < n_channels && chan->band == band) {\n\t\tchan = &data->channels[++idx];\n\t\tn++;\n\t}\n\n\tsband->n_channels = n;\n\n\treturn n;\n}\n\n#define MAX_BIT_RATE_40_MHZ\t150  \n#define MAX_BIT_RATE_20_MHZ\t72  \n\nvoid iwl_init_ht_hw_capab(struct iwl_trans *trans,\n\t\t\t  struct iwl_nvm_data *data,\n\t\t\t  struct ieee80211_sta_ht_cap *ht_info,\n\t\t\t  enum nl80211_band band,\n\t\t\t  u8 tx_chains, u8 rx_chains)\n{\n\tconst struct iwl_cfg *cfg = trans->cfg;\n\tint max_bit_rate = 0;\n\n\ttx_chains = hweight8(tx_chains);\n\tif (cfg->rx_with_siso_diversity)\n\t\trx_chains = 1;\n\telse\n\t\trx_chains = hweight8(rx_chains);\n\n\tif (!(data->sku_cap_11n_enable) ||\n\t    (iwlwifi_mod_params.disable_11n & IWL_DISABLE_HT_ALL) ||\n\t    !cfg->ht_params) {\n\t\tht_info->ht_supported = false;\n\t\treturn;\n\t}\n\n\tif (data->sku_cap_mimo_disabled)\n\t\trx_chains = 1;\n\n\tht_info->ht_supported = true;\n\tht_info->cap = IEEE80211_HT_CAP_DSSSCCK40;\n\n\tif (cfg->ht_params->stbc) {\n\t\tht_info->cap |= (1 << IEEE80211_HT_CAP_RX_STBC_SHIFT);\n\n\t\tif (tx_chains > 1)\n\t\t\tht_info->cap |= IEEE80211_HT_CAP_TX_STBC;\n\t}\n\n\tif (cfg->ht_params->ldpc)\n\t\tht_info->cap |= IEEE80211_HT_CAP_LDPC_CODING;\n\n\tif (trans->trans_cfg->mq_rx_supported ||\n\t    iwlwifi_mod_params.amsdu_size >= IWL_AMSDU_8K)\n\t\tht_info->cap |= IEEE80211_HT_CAP_MAX_AMSDU;\n\n\tht_info->ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;\n\tht_info->ampdu_density = IEEE80211_HT_MPDU_DENSITY_4;\n\n\tht_info->mcs.rx_mask[0] = 0xFF;\n\tif (rx_chains >= 2)\n\t\tht_info->mcs.rx_mask[1] = 0xFF;\n\tif (rx_chains >= 3)\n\t\tht_info->mcs.rx_mask[2] = 0xFF;\n\n\tif (cfg->ht_params->ht_greenfield_support)\n\t\tht_info->cap |= IEEE80211_HT_CAP_GRN_FLD;\n\tht_info->cap |= IEEE80211_HT_CAP_SGI_20;\n\n\tmax_bit_rate = MAX_BIT_RATE_20_MHZ;\n\n\tif (cfg->ht_params->ht40_bands & BIT(band)) {\n\t\tht_info->cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t\tht_info->cap |= IEEE80211_HT_CAP_SGI_40;\n\t\tmax_bit_rate = MAX_BIT_RATE_40_MHZ;\n\t}\n\n\t \n\tmax_bit_rate *= rx_chains;\n\tWARN_ON(max_bit_rate & ~IEEE80211_HT_MCS_RX_HIGHEST_MASK);\n\tht_info->mcs.rx_highest = cpu_to_le16(max_bit_rate);\n\n\t \n\tht_info->mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\n\tif (tx_chains != rx_chains) {\n\t\tht_info->mcs.tx_params |= IEEE80211_HT_MCS_TX_RX_DIFF;\n\t\tht_info->mcs.tx_params |= ((tx_chains - 1) <<\n\t\t\t\tIEEE80211_HT_MCS_TX_MAX_STREAMS_SHIFT);\n\t}\n}\n\n#if IS_ENABLED(CONFIG_IWLDVM)\nstatic void iwl_init_sbands(struct iwl_trans *trans, const struct iwl_cfg *cfg,\n\t\t\t    struct iwl_nvm_data *data,\n\t\t\t    const u8 *eeprom, size_t eeprom_size)\n{\n\tstruct device *dev = trans->dev;\n\tint n_channels = iwl_init_channel_map(dev, cfg, data,\n\t\t\t\t\t      eeprom, eeprom_size);\n\tint n_used = 0;\n\tstruct ieee80211_supported_band *sband;\n\n\tsband = &data->bands[NL80211_BAND_2GHZ];\n\tsband->band = NL80211_BAND_2GHZ;\n\tsband->bitrates = &iwl_cfg80211_rates[RATES_24_OFFS];\n\tsband->n_bitrates = N_RATES_24;\n\tn_used += iwl_init_sband_channels(data, sband, n_channels,\n\t\t\t\t\t  NL80211_BAND_2GHZ);\n\tiwl_init_ht_hw_capab(trans, data, &sband->ht_cap, NL80211_BAND_2GHZ,\n\t\t\t     data->valid_tx_ant, data->valid_rx_ant);\n\n\tsband = &data->bands[NL80211_BAND_5GHZ];\n\tsband->band = NL80211_BAND_5GHZ;\n\tsband->bitrates = &iwl_cfg80211_rates[RATES_52_OFFS];\n\tsband->n_bitrates = N_RATES_52;\n\tn_used += iwl_init_sband_channels(data, sband, n_channels,\n\t\t\t\t\t  NL80211_BAND_5GHZ);\n\tiwl_init_ht_hw_capab(trans, data, &sband->ht_cap, NL80211_BAND_5GHZ,\n\t\t\t     data->valid_tx_ant, data->valid_rx_ant);\n\n\tif (n_channels != n_used)\n\t\tIWL_ERR_DEV(dev, \"EEPROM: used only %d of %d channels\\n\",\n\t\t\t    n_used, n_channels);\n}\n\n \n\nstruct iwl_nvm_data *\niwl_parse_eeprom_data(struct iwl_trans *trans, const struct iwl_cfg *cfg,\n\t\t      const u8 *eeprom, size_t eeprom_size)\n{\n\tstruct iwl_nvm_data *data;\n\tstruct device *dev = trans->dev;\n\tconst void *tmp;\n\tu16 radio_cfg, sku;\n\n\tif (WARN_ON(!cfg || !cfg->eeprom_params))\n\t\treturn NULL;\n\n\tdata = kzalloc(struct_size(data, channels, IWL_NUM_CHANNELS),\n\t\t       GFP_KERNEL);\n\tif (!data)\n\t\treturn NULL;\n\n\t \n\ttmp = iwl_eeprom_query_addr(eeprom, eeprom_size, EEPROM_MAC_ADDRESS);\n\tif (!tmp)\n\t\tgoto err_free;\n\tmemcpy(data->hw_addr, tmp, ETH_ALEN);\n\tdata->n_hw_addrs = iwl_eeprom_query16(eeprom, eeprom_size,\n\t\t\t\t\t      EEPROM_NUM_MAC_ADDRESS);\n\n\tif (iwl_eeprom_read_calib(eeprom, eeprom_size, data))\n\t\tgoto err_free;\n\n\ttmp = iwl_eeprom_query_addr(eeprom, eeprom_size, EEPROM_XTAL);\n\tif (!tmp)\n\t\tgoto err_free;\n\tmemcpy(data->xtal_calib, tmp, sizeof(data->xtal_calib));\n\n\ttmp = iwl_eeprom_query_addr(eeprom, eeprom_size,\n\t\t\t\t    EEPROM_RAW_TEMPERATURE);\n\tif (!tmp)\n\t\tgoto err_free;\n\tdata->raw_temperature = *(__le16 *)tmp;\n\n\ttmp = iwl_eeprom_query_addr(eeprom, eeprom_size,\n\t\t\t\t    EEPROM_KELVIN_TEMPERATURE);\n\tif (!tmp)\n\t\tgoto err_free;\n\tdata->kelvin_temperature = *(__le16 *)tmp;\n\tdata->kelvin_voltage = *((__le16 *)tmp + 1);\n\n\tradio_cfg = iwl_eeprom_query16(eeprom, eeprom_size,\n\t\t\t\t\t     EEPROM_RADIO_CONFIG);\n\tdata->radio_cfg_dash = EEPROM_RF_CFG_DASH_MSK(radio_cfg);\n\tdata->radio_cfg_pnum = EEPROM_RF_CFG_PNUM_MSK(radio_cfg);\n\tdata->radio_cfg_step = EEPROM_RF_CFG_STEP_MSK(radio_cfg);\n\tdata->radio_cfg_type = EEPROM_RF_CFG_TYPE_MSK(radio_cfg);\n\tdata->valid_rx_ant = EEPROM_RF_CFG_RX_ANT_MSK(radio_cfg);\n\tdata->valid_tx_ant = EEPROM_RF_CFG_TX_ANT_MSK(radio_cfg);\n\n\tsku = iwl_eeprom_query16(eeprom, eeprom_size,\n\t\t\t\t EEPROM_SKU_CAP);\n\tdata->sku_cap_11n_enable = sku & EEPROM_SKU_CAP_11N_ENABLE;\n\tdata->sku_cap_amt_enable = sku & EEPROM_SKU_CAP_AMT_ENABLE;\n\tdata->sku_cap_band_24ghz_enable = sku & EEPROM_SKU_CAP_BAND_24GHZ;\n\tdata->sku_cap_band_52ghz_enable = sku & EEPROM_SKU_CAP_BAND_52GHZ;\n\tdata->sku_cap_ipan_enable = sku & EEPROM_SKU_CAP_IPAN_ENABLE;\n\tif (iwlwifi_mod_params.disable_11n & IWL_DISABLE_HT_ALL)\n\t\tdata->sku_cap_11n_enable = false;\n\n\tdata->nvm_version = iwl_eeprom_query16(eeprom, eeprom_size,\n\t\t\t\t\t       EEPROM_VERSION);\n\n\t \n\tif (cfg->valid_tx_ant)\n\t\tdata->valid_tx_ant = cfg->valid_tx_ant;\n\tif (cfg->valid_rx_ant)\n\t\tdata->valid_rx_ant = cfg->valid_rx_ant;\n\n\tif (!data->valid_tx_ant || !data->valid_rx_ant) {\n\t\tIWL_ERR_DEV(dev, \"invalid antennas (0x%x, 0x%x)\\n\",\n\t\t\t    data->valid_tx_ant, data->valid_rx_ant);\n\t\tgoto err_free;\n\t}\n\n\tiwl_init_sbands(trans, cfg, data, eeprom, eeprom_size);\n\n\treturn data;\n err_free:\n\tkfree(data);\n\treturn NULL;\n}\nIWL_EXPORT_SYMBOL(iwl_parse_eeprom_data);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}