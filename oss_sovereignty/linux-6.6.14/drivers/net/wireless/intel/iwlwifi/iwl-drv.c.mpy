{
  "module_name": "iwl-drv.c",
  "hash_id": "a505c9afb47753a67ece9b2905d5de5cbc64c476111a3b3624cae0a1cfad0315",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/iwl-drv.c",
  "human_readable_source": "\n \n#include <linux/completion.h>\n#include <linux/dma-mapping.h>\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n\n#include \"iwl-drv.h\"\n#include \"iwl-csr.h\"\n#include \"iwl-debug.h\"\n#include \"iwl-trans.h\"\n#include \"iwl-op-mode.h\"\n#include \"iwl-agn-hw.h\"\n#include \"fw/img.h\"\n#include \"iwl-dbg-tlv.h\"\n#include \"iwl-config.h\"\n#include \"iwl-modparams.h\"\n#include \"fw/api/alive.h\"\n#include \"fw/api/mac.h\"\n\n \n\n#define DRV_DESCRIPTION\t\"Intel(R) Wireless WiFi driver for Linux\"\nMODULE_DESCRIPTION(DRV_DESCRIPTION);\nMODULE_LICENSE(\"GPL\");\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\nstatic struct dentry *iwl_dbgfs_root;\n#endif\n\n \nstruct iwl_drv {\n\tstruct list_head list;\n\tstruct iwl_fw fw;\n\n\tstruct iwl_op_mode *op_mode;\n\tstruct iwl_trans *trans;\n\tstruct device *dev;\n\n\tint fw_index;                    \n\tchar firmware_name[64];          \n\n\tstruct completion request_firmware_complete;\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tstruct dentry *dbgfs_drv;\n\tstruct dentry *dbgfs_trans;\n\tstruct dentry *dbgfs_op_mode;\n#endif\n};\n\nenum {\n\tDVM_OP_MODE,\n\tMVM_OP_MODE,\n};\n\n \nstatic DEFINE_MUTEX(iwlwifi_opmode_table_mtx);\nstatic struct iwlwifi_opmode_table {\n\tconst char *name;\t\t\t \n\tconst struct iwl_op_mode_ops *ops;\t \n\tstruct list_head drv;\t\t \n} iwlwifi_opmode_table[] = {\t\t \n\t[DVM_OP_MODE] = { .name = \"iwldvm\", .ops = NULL },\n\t[MVM_OP_MODE] = { .name = \"iwlmvm\", .ops = NULL },\n};\n\n#define IWL_DEFAULT_SCAN_CHANNELS 40\n\n \nstruct fw_sec {\n\tconst void *data;\t\t \n\tsize_t size;\t\t\t \n\tu32 offset;\t\t\t \n};\n\nstatic void iwl_free_fw_desc(struct iwl_drv *drv, struct fw_desc *desc)\n{\n\tvfree(desc->data);\n\tdesc->data = NULL;\n\tdesc->len = 0;\n}\n\nstatic void iwl_free_fw_img(struct iwl_drv *drv, struct fw_img *img)\n{\n\tint i;\n\tfor (i = 0; i < img->num_sec; i++)\n\t\tiwl_free_fw_desc(drv, &img->sec[i]);\n\tkfree(img->sec);\n}\n\nstatic void iwl_dealloc_ucode(struct iwl_drv *drv)\n{\n\tint i;\n\n\tkfree(drv->fw.dbg.dest_tlv);\n\tfor (i = 0; i < ARRAY_SIZE(drv->fw.dbg.conf_tlv); i++)\n\t\tkfree(drv->fw.dbg.conf_tlv[i]);\n\tfor (i = 0; i < ARRAY_SIZE(drv->fw.dbg.trigger_tlv); i++)\n\t\tkfree(drv->fw.dbg.trigger_tlv[i]);\n\tkfree(drv->fw.dbg.mem_tlv);\n\tkfree(drv->fw.iml);\n\tkfree(drv->fw.ucode_capa.cmd_versions);\n\tkfree(drv->fw.phy_integration_ver);\n\tkfree(drv->trans->dbg.pc_data);\n\n\tfor (i = 0; i < IWL_UCODE_TYPE_MAX; i++)\n\t\tiwl_free_fw_img(drv, drv->fw.img + i);\n\n\t \n\tmemset(&drv->fw, 0, sizeof(drv->fw));\n}\n\nstatic int iwl_alloc_fw_desc(struct iwl_drv *drv, struct fw_desc *desc,\n\t\t\t     struct fw_sec *sec)\n{\n\tvoid *data;\n\n\tdesc->data = NULL;\n\n\tif (!sec || !sec->size)\n\t\treturn -EINVAL;\n\n\tdata = vmalloc(sec->size);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdesc->len = sec->size;\n\tdesc->offset = sec->offset;\n\tmemcpy(data, sec->data, desc->len);\n\tdesc->data = data;\n\n\treturn 0;\n}\n\nstatic inline char iwl_drv_get_step(int step)\n{\n\tif (step == SILICON_Z_STEP)\n\t\treturn 'z';\n\treturn 'a' + step;\n}\n\nconst char *iwl_drv_get_fwname_pre(struct iwl_trans *trans, char *buf)\n{\n\tchar mac_step, rf_step;\n\tconst char *rf, *cdb;\n\n\tif (trans->cfg->fw_name_pre)\n\t\treturn trans->cfg->fw_name_pre;\n\n\tif (WARN_ON(!trans->cfg->fw_name_mac))\n\t\treturn \"unconfigured\";\n\n\tmac_step = iwl_drv_get_step(trans->hw_rev_step);\n\n\tswitch (CSR_HW_RFID_TYPE(trans->hw_rf_id)) {\n\tcase IWL_CFG_RF_TYPE_HR1:\n\tcase IWL_CFG_RF_TYPE_HR2:\n\t\trf = \"hr\";\n\t\tbreak;\n\tcase IWL_CFG_RF_TYPE_GF:\n\t\trf = \"gf\";\n\t\tbreak;\n\tcase IWL_CFG_RF_TYPE_MR:\n\t\trf = \"mr\";\n\t\tbreak;\n\tcase IWL_CFG_RF_TYPE_MS:\n\t\trf = \"ms\";\n\t\tbreak;\n\tcase IWL_CFG_RF_TYPE_FM:\n\t\trf = \"fm\";\n\t\tbreak;\n\tcase IWL_CFG_RF_TYPE_WH:\n\t\trf = \"wh\";\n\t\tbreak;\n\tdefault:\n\t\treturn \"unknown-rf\";\n\t}\n\n\tcdb = CSR_HW_RFID_IS_CDB(trans->hw_rf_id) ? \"4\" : \"\";\n\n\trf_step = iwl_drv_get_step(CSR_HW_RFID_STEP(trans->hw_rf_id));\n\n\tscnprintf(buf, FW_NAME_PRE_BUFSIZE,\n\t\t  \"iwlwifi-%s-%c0-%s%s-%c0\",\n\t\t  trans->cfg->fw_name_mac, mac_step,\n\t\t  rf, cdb, rf_step);\n\n\treturn buf;\n}\nIWL_EXPORT_SYMBOL(iwl_drv_get_fwname_pre);\n\nstatic void iwl_req_fw_callback(const struct firmware *ucode_raw,\n\t\t\t\tvoid *context);\n\nstatic int iwl_request_firmware(struct iwl_drv *drv, bool first)\n{\n\tconst struct iwl_cfg *cfg = drv->trans->cfg;\n\tchar _fw_name_pre[FW_NAME_PRE_BUFSIZE];\n\tconst char *fw_name_pre;\n\n\tif (drv->trans->trans_cfg->device_family == IWL_DEVICE_FAMILY_9000 &&\n\t    (drv->trans->hw_rev_step != SILICON_B_STEP &&\n\t     drv->trans->hw_rev_step != SILICON_C_STEP)) {\n\t\tIWL_ERR(drv,\n\t\t\t\"Only HW steps B and C are currently supported (0x%0x)\\n\",\n\t\t\tdrv->trans->hw_rev);\n\t\treturn -EINVAL;\n\t}\n\n\tfw_name_pre = iwl_drv_get_fwname_pre(drv->trans, _fw_name_pre);\n\n\tif (first)\n\t\tdrv->fw_index = cfg->ucode_api_max;\n\telse\n\t\tdrv->fw_index--;\n\n\tif (drv->fw_index < cfg->ucode_api_min) {\n\t\tIWL_ERR(drv, \"no suitable firmware found!\\n\");\n\n\t\tif (cfg->ucode_api_min == cfg->ucode_api_max) {\n\t\t\tIWL_ERR(drv, \"%s-%d is required\\n\", fw_name_pre,\n\t\t\t\tcfg->ucode_api_max);\n\t\t} else {\n\t\t\tIWL_ERR(drv, \"minimum version required: %s-%d\\n\",\n\t\t\t\tfw_name_pre, cfg->ucode_api_min);\n\t\t\tIWL_ERR(drv, \"maximum version supported: %s-%d\\n\",\n\t\t\t\tfw_name_pre, cfg->ucode_api_max);\n\t\t}\n\n\t\tIWL_ERR(drv,\n\t\t\t\"check git://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tsnprintf(drv->firmware_name, sizeof(drv->firmware_name), \"%s-%d.ucode\",\n\t\t fw_name_pre, drv->fw_index);\n\n\tIWL_DEBUG_FW_INFO(drv, \"attempting to load firmware '%s'\\n\",\n\t\t\t  drv->firmware_name);\n\n\treturn request_firmware_nowait(THIS_MODULE, 1, drv->firmware_name,\n\t\t\t\t       drv->trans->dev,\n\t\t\t\t       GFP_KERNEL, drv, iwl_req_fw_callback);\n}\n\nstruct fw_img_parsing {\n\tstruct fw_sec *sec;\n\tint sec_counter;\n};\n\n \nstruct fw_sec_parsing {\n\t__le32 offset;\n\tconst u8 data[];\n} __packed;\n\n \nstruct iwl_tlv_calib_data {\n\t__le32 ucode_type;\n\tstruct iwl_tlv_calib_ctrl calib;\n} __packed;\n\nstruct iwl_firmware_pieces {\n\tstruct fw_img_parsing img[IWL_UCODE_TYPE_MAX];\n\n\tu32 init_evtlog_ptr, init_evtlog_size, init_errlog_ptr;\n\tu32 inst_evtlog_ptr, inst_evtlog_size, inst_errlog_ptr;\n\n\t \n\tbool dbg_dest_tlv_init;\n\tconst u8 *dbg_dest_ver;\n\tunion {\n\t\tconst struct iwl_fw_dbg_dest_tlv *dbg_dest_tlv;\n\t\tconst struct iwl_fw_dbg_dest_tlv_v1 *dbg_dest_tlv_v1;\n\t};\n\tconst struct iwl_fw_dbg_conf_tlv *dbg_conf_tlv[FW_DBG_CONF_MAX];\n\tsize_t dbg_conf_tlv_len[FW_DBG_CONF_MAX];\n\tconst struct iwl_fw_dbg_trigger_tlv *dbg_trigger_tlv[FW_DBG_TRIGGER_MAX];\n\tsize_t dbg_trigger_tlv_len[FW_DBG_TRIGGER_MAX];\n\tstruct iwl_fw_dbg_mem_seg_tlv *dbg_mem_tlv;\n\tsize_t n_mem_tlv;\n};\n\n \nstatic struct fw_sec *get_sec(struct iwl_firmware_pieces *pieces,\n\t\t\t      enum iwl_ucode_type type,\n\t\t\t      int  sec)\n{\n\treturn &pieces->img[type].sec[sec];\n}\n\nstatic void alloc_sec_data(struct iwl_firmware_pieces *pieces,\n\t\t\t   enum iwl_ucode_type type,\n\t\t\t   int sec)\n{\n\tstruct fw_img_parsing *img = &pieces->img[type];\n\tstruct fw_sec *sec_memory;\n\tint size = sec + 1;\n\tsize_t alloc_size = sizeof(*img->sec) * size;\n\n\tif (img->sec && img->sec_counter >= size)\n\t\treturn;\n\n\tsec_memory = krealloc(img->sec, alloc_size, GFP_KERNEL);\n\tif (!sec_memory)\n\t\treturn;\n\n\timg->sec = sec_memory;\n\timg->sec_counter = size;\n}\n\nstatic void set_sec_data(struct iwl_firmware_pieces *pieces,\n\t\t\t enum iwl_ucode_type type,\n\t\t\t int sec,\n\t\t\t const void *data)\n{\n\talloc_sec_data(pieces, type, sec);\n\n\tpieces->img[type].sec[sec].data = data;\n}\n\nstatic void set_sec_size(struct iwl_firmware_pieces *pieces,\n\t\t\t enum iwl_ucode_type type,\n\t\t\t int sec,\n\t\t\t size_t size)\n{\n\talloc_sec_data(pieces, type, sec);\n\n\tpieces->img[type].sec[sec].size = size;\n}\n\nstatic size_t get_sec_size(struct iwl_firmware_pieces *pieces,\n\t\t\t   enum iwl_ucode_type type,\n\t\t\t   int sec)\n{\n\treturn pieces->img[type].sec[sec].size;\n}\n\nstatic void set_sec_offset(struct iwl_firmware_pieces *pieces,\n\t\t\t   enum iwl_ucode_type type,\n\t\t\t   int sec,\n\t\t\t   u32 offset)\n{\n\talloc_sec_data(pieces, type, sec);\n\n\tpieces->img[type].sec[sec].offset = offset;\n}\n\n \nstatic int iwl_store_ucode_sec(struct iwl_firmware_pieces *pieces,\n\t\t\t       const void *data, enum iwl_ucode_type type,\n\t\t\t       int size)\n{\n\tstruct fw_img_parsing *img;\n\tstruct fw_sec *sec;\n\tconst struct fw_sec_parsing *sec_parse;\n\tsize_t alloc_size;\n\n\tif (WARN_ON(!pieces || !data || type >= IWL_UCODE_TYPE_MAX))\n\t\treturn -1;\n\n\tsec_parse = (const struct fw_sec_parsing *)data;\n\n\timg = &pieces->img[type];\n\n\talloc_size = sizeof(*img->sec) * (img->sec_counter + 1);\n\tsec = krealloc(img->sec, alloc_size, GFP_KERNEL);\n\tif (!sec)\n\t\treturn -ENOMEM;\n\timg->sec = sec;\n\n\tsec = &img->sec[img->sec_counter];\n\n\tsec->offset = le32_to_cpu(sec_parse->offset);\n\tsec->data = sec_parse->data;\n\tsec->size = size - sizeof(sec_parse->offset);\n\n\t++img->sec_counter;\n\n\treturn 0;\n}\n\nstatic int iwl_set_default_calib(struct iwl_drv *drv, const u8 *data)\n{\n\tconst struct iwl_tlv_calib_data *def_calib =\n\t\t\t\t\t(const struct iwl_tlv_calib_data *)data;\n\tu32 ucode_type = le32_to_cpu(def_calib->ucode_type);\n\tif (ucode_type >= IWL_UCODE_TYPE_MAX) {\n\t\tIWL_ERR(drv, \"Wrong ucode_type %u for default calibration.\\n\",\n\t\t\tucode_type);\n\t\treturn -EINVAL;\n\t}\n\tdrv->fw.default_calib[ucode_type].flow_trigger =\n\t\tdef_calib->calib.flow_trigger;\n\tdrv->fw.default_calib[ucode_type].event_trigger =\n\t\tdef_calib->calib.event_trigger;\n\n\treturn 0;\n}\n\nstatic void iwl_set_ucode_api_flags(struct iwl_drv *drv, const u8 *data,\n\t\t\t\t    struct iwl_ucode_capabilities *capa)\n{\n\tconst struct iwl_ucode_api *ucode_api = (const void *)data;\n\tu32 api_index = le32_to_cpu(ucode_api->api_index);\n\tu32 api_flags = le32_to_cpu(ucode_api->api_flags);\n\tint i;\n\n\tif (api_index >= DIV_ROUND_UP(NUM_IWL_UCODE_TLV_API, 32)) {\n\t\tIWL_WARN(drv,\n\t\t\t \"api flags index %d larger than supported by driver\\n\",\n\t\t\t api_index);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 32; i++) {\n\t\tif (api_flags & BIT(i))\n\t\t\t__set_bit(i + 32 * api_index, capa->_api);\n\t}\n}\n\nstatic void iwl_set_ucode_capabilities(struct iwl_drv *drv, const u8 *data,\n\t\t\t\t       struct iwl_ucode_capabilities *capa)\n{\n\tconst struct iwl_ucode_capa *ucode_capa = (const void *)data;\n\tu32 api_index = le32_to_cpu(ucode_capa->api_index);\n\tu32 api_flags = le32_to_cpu(ucode_capa->api_capa);\n\tint i;\n\n\tif (api_index >= DIV_ROUND_UP(NUM_IWL_UCODE_TLV_CAPA, 32)) {\n\t\tIWL_WARN(drv,\n\t\t\t \"capa flags index %d larger than supported by driver\\n\",\n\t\t\t api_index);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 32; i++) {\n\t\tif (api_flags & BIT(i))\n\t\t\t__set_bit(i + 32 * api_index, capa->_capa);\n\t}\n}\n\nstatic const char *iwl_reduced_fw_name(struct iwl_drv *drv)\n{\n\tconst char *name = drv->firmware_name;\n\n\tif (strncmp(name, \"iwlwifi-\", 8) == 0)\n\t\tname += 8;\n\n\treturn name;\n}\n\nstatic int iwl_parse_v1_v2_firmware(struct iwl_drv *drv,\n\t\t\t\t    const struct firmware *ucode_raw,\n\t\t\t\t    struct iwl_firmware_pieces *pieces)\n{\n\tconst struct iwl_ucode_header *ucode = (const void *)ucode_raw->data;\n\tu32 api_ver, hdr_size, build;\n\tchar buildstr[25];\n\tconst u8 *src;\n\n\tdrv->fw.ucode_ver = le32_to_cpu(ucode->ver);\n\tapi_ver = IWL_UCODE_API(drv->fw.ucode_ver);\n\n\tswitch (api_ver) {\n\tdefault:\n\t\thdr_size = 28;\n\t\tif (ucode_raw->size < hdr_size) {\n\t\t\tIWL_ERR(drv, \"File size too small!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbuild = le32_to_cpu(ucode->u.v2.build);\n\t\tset_sec_size(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_INST,\n\t\t\t     le32_to_cpu(ucode->u.v2.inst_size));\n\t\tset_sec_size(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_DATA,\n\t\t\t     le32_to_cpu(ucode->u.v2.data_size));\n\t\tset_sec_size(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_INST,\n\t\t\t     le32_to_cpu(ucode->u.v2.init_size));\n\t\tset_sec_size(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_DATA,\n\t\t\t     le32_to_cpu(ucode->u.v2.init_data_size));\n\t\tsrc = ucode->u.v2.data;\n\t\tbreak;\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\t\thdr_size = 24;\n\t\tif (ucode_raw->size < hdr_size) {\n\t\t\tIWL_ERR(drv, \"File size too small!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbuild = 0;\n\t\tset_sec_size(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_INST,\n\t\t\t     le32_to_cpu(ucode->u.v1.inst_size));\n\t\tset_sec_size(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_DATA,\n\t\t\t     le32_to_cpu(ucode->u.v1.data_size));\n\t\tset_sec_size(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_INST,\n\t\t\t     le32_to_cpu(ucode->u.v1.init_size));\n\t\tset_sec_size(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_DATA,\n\t\t\t     le32_to_cpu(ucode->u.v1.init_data_size));\n\t\tsrc = ucode->u.v1.data;\n\t\tbreak;\n\t}\n\n\tif (build)\n\t\tsprintf(buildstr, \" build %u\", build);\n\telse\n\t\tbuildstr[0] = '\\0';\n\n\tsnprintf(drv->fw.fw_version,\n\t\t sizeof(drv->fw.fw_version),\n\t\t \"%u.%u.%u.%u%s %s\",\n\t\t IWL_UCODE_MAJOR(drv->fw.ucode_ver),\n\t\t IWL_UCODE_MINOR(drv->fw.ucode_ver),\n\t\t IWL_UCODE_API(drv->fw.ucode_ver),\n\t\t IWL_UCODE_SERIAL(drv->fw.ucode_ver),\n\t\t buildstr, iwl_reduced_fw_name(drv));\n\n\t \n\n\tif (ucode_raw->size != hdr_size +\n\t    get_sec_size(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_INST) +\n\t    get_sec_size(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_DATA) +\n\t    get_sec_size(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_INST) +\n\t    get_sec_size(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_DATA)) {\n\n\t\tIWL_ERR(drv,\n\t\t\t\"uCode file size %d does not match expected size\\n\",\n\t\t\t(int)ucode_raw->size);\n\t\treturn -EINVAL;\n\t}\n\n\n\tset_sec_data(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_INST, src);\n\tsrc += get_sec_size(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_INST);\n\tset_sec_offset(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_INST,\n\t\t       IWLAGN_RTC_INST_LOWER_BOUND);\n\tset_sec_data(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_DATA, src);\n\tsrc += get_sec_size(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_DATA);\n\tset_sec_offset(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_DATA,\n\t\t       IWLAGN_RTC_DATA_LOWER_BOUND);\n\tset_sec_data(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_INST, src);\n\tsrc += get_sec_size(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_INST);\n\tset_sec_offset(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_INST,\n\t\t       IWLAGN_RTC_INST_LOWER_BOUND);\n\tset_sec_data(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_DATA, src);\n\tsrc += get_sec_size(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_DATA);\n\tset_sec_offset(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_DATA,\n\t\t       IWLAGN_RTC_DATA_LOWER_BOUND);\n\treturn 0;\n}\n\nstatic void iwl_drv_set_dump_exclude(struct iwl_drv *drv,\n\t\t\t\t     enum iwl_ucode_tlv_type tlv_type,\n\t\t\t\t     const void *tlv_data, u32 tlv_len)\n{\n\tconst struct iwl_fw_dump_exclude *fw = tlv_data;\n\tstruct iwl_dump_exclude *excl;\n\n\tif (tlv_len < sizeof(*fw))\n\t\treturn;\n\n\tif (tlv_type == IWL_UCODE_TLV_SEC_TABLE_ADDR) {\n\t\texcl = &drv->fw.dump_excl[0];\n\n\t\t \n\t\tif (excl->addr)\n\t\t\texcl = &drv->fw.dump_excl_wowlan[0];\n\t} else if (fw_has_capa(&drv->fw.ucode_capa,\n\t\t\t       IWL_UCODE_TLV_CAPA_CNSLDTD_D3_D0_IMG)) {\n\t\t \n\t\texcl = &drv->fw.dump_excl[0];\n\t} else {\n\t\t \n\t\texcl = &drv->fw.dump_excl_wowlan[0];\n\t}\n\n\tif (excl->addr)\n\t\texcl++;\n\n\tif (excl->addr) {\n\t\tIWL_DEBUG_FW_INFO(drv, \"found too many excludes in fw file\\n\");\n\t\treturn;\n\t}\n\n\texcl->addr = le32_to_cpu(fw->addr) & ~FW_ADDR_CACHE_CONTROL;\n\texcl->size = le32_to_cpu(fw->size);\n}\n\nstatic void iwl_parse_dbg_tlv_assert_tables(struct iwl_drv *drv,\n\t\t\t\t\t    const struct iwl_ucode_tlv *tlv)\n{\n\tconst struct iwl_fw_ini_region_tlv *region;\n\tu32 length = le32_to_cpu(tlv->length);\n\tu32 addr;\n\n\tif (length < offsetof(typeof(*region), special_mem) +\n\t\t     sizeof(region->special_mem))\n\t\treturn;\n\n\tregion = (const void *)tlv->data;\n\taddr = le32_to_cpu(region->special_mem.base_addr);\n\taddr += le32_to_cpu(region->special_mem.offset);\n\taddr &= ~FW_ADDR_CACHE_CONTROL;\n\n\tif (region->type != IWL_FW_INI_REGION_SPECIAL_DEVICE_MEMORY)\n\t\treturn;\n\n\tswitch (region->sub_type) {\n\tcase IWL_FW_INI_REGION_DEVICE_MEMORY_SUBTYPE_UMAC_ERROR_TABLE:\n\t\tdrv->trans->dbg.umac_error_event_table = addr;\n\t\tdrv->trans->dbg.error_event_table_tlv_status |=\n\t\t\tIWL_ERROR_EVENT_TABLE_UMAC;\n\t\tbreak;\n\tcase IWL_FW_INI_REGION_DEVICE_MEMORY_SUBTYPE_LMAC_1_ERROR_TABLE:\n\t\tdrv->trans->dbg.lmac_error_event_table[0] = addr;\n\t\tdrv->trans->dbg.error_event_table_tlv_status |=\n\t\t\tIWL_ERROR_EVENT_TABLE_LMAC1;\n\t\tbreak;\n\tcase IWL_FW_INI_REGION_DEVICE_MEMORY_SUBTYPE_LMAC_2_ERROR_TABLE:\n\t\tdrv->trans->dbg.lmac_error_event_table[1] = addr;\n\t\tdrv->trans->dbg.error_event_table_tlv_status |=\n\t\t\tIWL_ERROR_EVENT_TABLE_LMAC2;\n\t\tbreak;\n\tcase IWL_FW_INI_REGION_DEVICE_MEMORY_SUBTYPE_TCM_1_ERROR_TABLE:\n\t\tdrv->trans->dbg.tcm_error_event_table[0] = addr;\n\t\tdrv->trans->dbg.error_event_table_tlv_status |=\n\t\t\tIWL_ERROR_EVENT_TABLE_TCM1;\n\t\tbreak;\n\tcase IWL_FW_INI_REGION_DEVICE_MEMORY_SUBTYPE_TCM_2_ERROR_TABLE:\n\t\tdrv->trans->dbg.tcm_error_event_table[1] = addr;\n\t\tdrv->trans->dbg.error_event_table_tlv_status |=\n\t\t\tIWL_ERROR_EVENT_TABLE_TCM2;\n\t\tbreak;\n\tcase IWL_FW_INI_REGION_DEVICE_MEMORY_SUBTYPE_RCM_1_ERROR_TABLE:\n\t\tdrv->trans->dbg.rcm_error_event_table[0] = addr;\n\t\tdrv->trans->dbg.error_event_table_tlv_status |=\n\t\t\tIWL_ERROR_EVENT_TABLE_RCM1;\n\t\tbreak;\n\tcase IWL_FW_INI_REGION_DEVICE_MEMORY_SUBTYPE_RCM_2_ERROR_TABLE:\n\t\tdrv->trans->dbg.rcm_error_event_table[1] = addr;\n\t\tdrv->trans->dbg.error_event_table_tlv_status |=\n\t\t\tIWL_ERROR_EVENT_TABLE_RCM2;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int iwl_parse_tlv_firmware(struct iwl_drv *drv,\n\t\t\t\tconst struct firmware *ucode_raw,\n\t\t\t\tstruct iwl_firmware_pieces *pieces,\n\t\t\t\tstruct iwl_ucode_capabilities *capa,\n\t\t\t\tbool *usniffer_images)\n{\n\tconst struct iwl_tlv_ucode_header *ucode = (const void *)ucode_raw->data;\n\tconst struct iwl_ucode_tlv *tlv;\n\tsize_t len = ucode_raw->size;\n\tconst u8 *data;\n\tu32 tlv_len;\n\tu32 usniffer_img;\n\tenum iwl_ucode_tlv_type tlv_type;\n\tconst u8 *tlv_data;\n\tchar buildstr[25];\n\tu32 build, paging_mem_size;\n\tint num_of_cpus;\n\tbool usniffer_req = false;\n\n\tif (len < sizeof(*ucode)) {\n\t\tIWL_ERR(drv, \"uCode has invalid length: %zd\\n\", len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ucode->magic != cpu_to_le32(IWL_TLV_UCODE_MAGIC)) {\n\t\tIWL_ERR(drv, \"invalid uCode magic: 0X%x\\n\",\n\t\t\tle32_to_cpu(ucode->magic));\n\t\treturn -EINVAL;\n\t}\n\n\tdrv->fw.ucode_ver = le32_to_cpu(ucode->ver);\n\tmemcpy(drv->fw.human_readable, ucode->human_readable,\n\t       sizeof(drv->fw.human_readable));\n\tbuild = le32_to_cpu(ucode->build);\n\n\tif (build)\n\t\tsprintf(buildstr, \" build %u\", build);\n\telse\n\t\tbuildstr[0] = '\\0';\n\n\tsnprintf(drv->fw.fw_version,\n\t\t sizeof(drv->fw.fw_version),\n\t\t \"%u.%u.%u.%u%s %s\",\n\t\t IWL_UCODE_MAJOR(drv->fw.ucode_ver),\n\t\t IWL_UCODE_MINOR(drv->fw.ucode_ver),\n\t\t IWL_UCODE_API(drv->fw.ucode_ver),\n\t\t IWL_UCODE_SERIAL(drv->fw.ucode_ver),\n\t\t buildstr, iwl_reduced_fw_name(drv));\n\n\tdata = ucode->data;\n\n\tlen -= sizeof(*ucode);\n\n\twhile (len >= sizeof(*tlv)) {\n\t\tlen -= sizeof(*tlv);\n\n\t\ttlv = (const void *)data;\n\t\ttlv_len = le32_to_cpu(tlv->length);\n\t\ttlv_type = le32_to_cpu(tlv->type);\n\t\ttlv_data = tlv->data;\n\n\t\tif (len < tlv_len) {\n\t\t\tIWL_ERR(drv, \"invalid TLV len: %zd/%u\\n\",\n\t\t\t\tlen, tlv_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlen -= ALIGN(tlv_len, 4);\n\t\tdata += sizeof(*tlv) + ALIGN(tlv_len, 4);\n\n\t\tswitch (tlv_type) {\n\t\tcase IWL_UCODE_TLV_INST:\n\t\t\tset_sec_data(pieces, IWL_UCODE_REGULAR,\n\t\t\t\t     IWL_UCODE_SECTION_INST, tlv_data);\n\t\t\tset_sec_size(pieces, IWL_UCODE_REGULAR,\n\t\t\t\t     IWL_UCODE_SECTION_INST, tlv_len);\n\t\t\tset_sec_offset(pieces, IWL_UCODE_REGULAR,\n\t\t\t\t       IWL_UCODE_SECTION_INST,\n\t\t\t\t       IWLAGN_RTC_INST_LOWER_BOUND);\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_DATA:\n\t\t\tset_sec_data(pieces, IWL_UCODE_REGULAR,\n\t\t\t\t     IWL_UCODE_SECTION_DATA, tlv_data);\n\t\t\tset_sec_size(pieces, IWL_UCODE_REGULAR,\n\t\t\t\t     IWL_UCODE_SECTION_DATA, tlv_len);\n\t\t\tset_sec_offset(pieces, IWL_UCODE_REGULAR,\n\t\t\t\t       IWL_UCODE_SECTION_DATA,\n\t\t\t\t       IWLAGN_RTC_DATA_LOWER_BOUND);\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_INIT:\n\t\t\tset_sec_data(pieces, IWL_UCODE_INIT,\n\t\t\t\t     IWL_UCODE_SECTION_INST, tlv_data);\n\t\t\tset_sec_size(pieces, IWL_UCODE_INIT,\n\t\t\t\t     IWL_UCODE_SECTION_INST, tlv_len);\n\t\t\tset_sec_offset(pieces, IWL_UCODE_INIT,\n\t\t\t\t       IWL_UCODE_SECTION_INST,\n\t\t\t\t       IWLAGN_RTC_INST_LOWER_BOUND);\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_INIT_DATA:\n\t\t\tset_sec_data(pieces, IWL_UCODE_INIT,\n\t\t\t\t     IWL_UCODE_SECTION_DATA, tlv_data);\n\t\t\tset_sec_size(pieces, IWL_UCODE_INIT,\n\t\t\t\t     IWL_UCODE_SECTION_DATA, tlv_len);\n\t\t\tset_sec_offset(pieces, IWL_UCODE_INIT,\n\t\t\t\t       IWL_UCODE_SECTION_DATA,\n\t\t\t\t       IWLAGN_RTC_DATA_LOWER_BOUND);\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_BOOT:\n\t\t\tIWL_ERR(drv, \"Found unexpected BOOT ucode\\n\");\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_PROBE_MAX_LEN:\n\t\t\tif (tlv_len != sizeof(u32))\n\t\t\t\tgoto invalid_tlv_len;\n\t\t\tcapa->max_probe_length =\n\t\t\t\t\tle32_to_cpup((const __le32 *)tlv_data);\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_PAN:\n\t\t\tif (tlv_len)\n\t\t\t\tgoto invalid_tlv_len;\n\t\t\tcapa->flags |= IWL_UCODE_TLV_FLAGS_PAN;\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_FLAGS:\n\t\t\t \n\t\t\tif (tlv_len < sizeof(u32))\n\t\t\t\tgoto invalid_tlv_len;\n\t\t\t \n\t\t\tif (tlv_len % sizeof(u32))\n\t\t\t\tgoto invalid_tlv_len;\n\t\t\t \n\t\t\tcapa->flags = le32_to_cpup((const __le32 *)tlv_data);\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_API_CHANGES_SET:\n\t\t\tif (tlv_len != sizeof(struct iwl_ucode_api))\n\t\t\t\tgoto invalid_tlv_len;\n\t\t\tiwl_set_ucode_api_flags(drv, tlv_data, capa);\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_ENABLED_CAPABILITIES:\n\t\t\tif (tlv_len != sizeof(struct iwl_ucode_capa))\n\t\t\t\tgoto invalid_tlv_len;\n\t\t\tiwl_set_ucode_capabilities(drv, tlv_data, capa);\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_INIT_EVTLOG_PTR:\n\t\t\tif (tlv_len != sizeof(u32))\n\t\t\t\tgoto invalid_tlv_len;\n\t\t\tpieces->init_evtlog_ptr =\n\t\t\t\t\tle32_to_cpup((const __le32 *)tlv_data);\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_INIT_EVTLOG_SIZE:\n\t\t\tif (tlv_len != sizeof(u32))\n\t\t\t\tgoto invalid_tlv_len;\n\t\t\tpieces->init_evtlog_size =\n\t\t\t\t\tle32_to_cpup((const __le32 *)tlv_data);\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_INIT_ERRLOG_PTR:\n\t\t\tif (tlv_len != sizeof(u32))\n\t\t\t\tgoto invalid_tlv_len;\n\t\t\tpieces->init_errlog_ptr =\n\t\t\t\t\tle32_to_cpup((const __le32 *)tlv_data);\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_RUNT_EVTLOG_PTR:\n\t\t\tif (tlv_len != sizeof(u32))\n\t\t\t\tgoto invalid_tlv_len;\n\t\t\tpieces->inst_evtlog_ptr =\n\t\t\t\t\tle32_to_cpup((const __le32 *)tlv_data);\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_RUNT_EVTLOG_SIZE:\n\t\t\tif (tlv_len != sizeof(u32))\n\t\t\t\tgoto invalid_tlv_len;\n\t\t\tpieces->inst_evtlog_size =\n\t\t\t\t\tle32_to_cpup((const __le32 *)tlv_data);\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_RUNT_ERRLOG_PTR:\n\t\t\tif (tlv_len != sizeof(u32))\n\t\t\t\tgoto invalid_tlv_len;\n\t\t\tpieces->inst_errlog_ptr =\n\t\t\t\t\tle32_to_cpup((const __le32 *)tlv_data);\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_ENHANCE_SENS_TBL:\n\t\t\tif (tlv_len)\n\t\t\t\tgoto invalid_tlv_len;\n\t\t\tdrv->fw.enhance_sensitivity_table = true;\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_WOWLAN_INST:\n\t\t\tset_sec_data(pieces, IWL_UCODE_WOWLAN,\n\t\t\t\t     IWL_UCODE_SECTION_INST, tlv_data);\n\t\t\tset_sec_size(pieces, IWL_UCODE_WOWLAN,\n\t\t\t\t     IWL_UCODE_SECTION_INST, tlv_len);\n\t\t\tset_sec_offset(pieces, IWL_UCODE_WOWLAN,\n\t\t\t\t       IWL_UCODE_SECTION_INST,\n\t\t\t\t       IWLAGN_RTC_INST_LOWER_BOUND);\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_WOWLAN_DATA:\n\t\t\tset_sec_data(pieces, IWL_UCODE_WOWLAN,\n\t\t\t\t     IWL_UCODE_SECTION_DATA, tlv_data);\n\t\t\tset_sec_size(pieces, IWL_UCODE_WOWLAN,\n\t\t\t\t     IWL_UCODE_SECTION_DATA, tlv_len);\n\t\t\tset_sec_offset(pieces, IWL_UCODE_WOWLAN,\n\t\t\t\t       IWL_UCODE_SECTION_DATA,\n\t\t\t\t       IWLAGN_RTC_DATA_LOWER_BOUND);\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_PHY_CALIBRATION_SIZE:\n\t\t\tif (tlv_len != sizeof(u32))\n\t\t\t\tgoto invalid_tlv_len;\n\t\t\tcapa->standard_phy_calibration_size =\n\t\t\t\t\tle32_to_cpup((const __le32 *)tlv_data);\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_SEC_RT:\n\t\t\tiwl_store_ucode_sec(pieces, tlv_data, IWL_UCODE_REGULAR,\n\t\t\t\t\t    tlv_len);\n\t\t\tdrv->fw.type = IWL_FW_MVM;\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_SEC_INIT:\n\t\t\tiwl_store_ucode_sec(pieces, tlv_data, IWL_UCODE_INIT,\n\t\t\t\t\t    tlv_len);\n\t\t\tdrv->fw.type = IWL_FW_MVM;\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_SEC_WOWLAN:\n\t\t\tiwl_store_ucode_sec(pieces, tlv_data, IWL_UCODE_WOWLAN,\n\t\t\t\t\t    tlv_len);\n\t\t\tdrv->fw.type = IWL_FW_MVM;\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_DEF_CALIB:\n\t\t\tif (tlv_len != sizeof(struct iwl_tlv_calib_data))\n\t\t\t\tgoto invalid_tlv_len;\n\t\t\tif (iwl_set_default_calib(drv, tlv_data))\n\t\t\t\tgoto tlv_error;\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_PHY_SKU:\n\t\t\tif (tlv_len != sizeof(u32))\n\t\t\t\tgoto invalid_tlv_len;\n\t\t\tdrv->fw.phy_config = le32_to_cpup((const __le32 *)tlv_data);\n\t\t\tdrv->fw.valid_tx_ant = (drv->fw.phy_config &\n\t\t\t\t\t\tFW_PHY_CFG_TX_CHAIN) >>\n\t\t\t\t\t\tFW_PHY_CFG_TX_CHAIN_POS;\n\t\t\tdrv->fw.valid_rx_ant = (drv->fw.phy_config &\n\t\t\t\t\t\tFW_PHY_CFG_RX_CHAIN) >>\n\t\t\t\t\t\tFW_PHY_CFG_RX_CHAIN_POS;\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_SECURE_SEC_RT:\n\t\t\tiwl_store_ucode_sec(pieces, tlv_data, IWL_UCODE_REGULAR,\n\t\t\t\t\t    tlv_len);\n\t\t\tdrv->fw.type = IWL_FW_MVM;\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_SECURE_SEC_INIT:\n\t\t\tiwl_store_ucode_sec(pieces, tlv_data, IWL_UCODE_INIT,\n\t\t\t\t\t    tlv_len);\n\t\t\tdrv->fw.type = IWL_FW_MVM;\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_SECURE_SEC_WOWLAN:\n\t\t\tiwl_store_ucode_sec(pieces, tlv_data, IWL_UCODE_WOWLAN,\n\t\t\t\t\t    tlv_len);\n\t\t\tdrv->fw.type = IWL_FW_MVM;\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_NUM_OF_CPU:\n\t\t\tif (tlv_len != sizeof(u32))\n\t\t\t\tgoto invalid_tlv_len;\n\t\t\tnum_of_cpus =\n\t\t\t\tle32_to_cpup((const __le32 *)tlv_data);\n\n\t\t\tif (num_of_cpus == 2) {\n\t\t\t\tdrv->fw.img[IWL_UCODE_REGULAR].is_dual_cpus =\n\t\t\t\t\ttrue;\n\t\t\t\tdrv->fw.img[IWL_UCODE_INIT].is_dual_cpus =\n\t\t\t\t\ttrue;\n\t\t\t\tdrv->fw.img[IWL_UCODE_WOWLAN].is_dual_cpus =\n\t\t\t\t\ttrue;\n\t\t\t} else if ((num_of_cpus > 2) || (num_of_cpus < 1)) {\n\t\t\t\tIWL_ERR(drv, \"Driver support up to 2 CPUs\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_N_SCAN_CHANNELS:\n\t\t\tif (tlv_len != sizeof(u32))\n\t\t\t\tgoto invalid_tlv_len;\n\t\t\tcapa->n_scan_channels =\n\t\t\t\tle32_to_cpup((const __le32 *)tlv_data);\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_FW_VERSION: {\n\t\t\tconst __le32 *ptr = (const void *)tlv_data;\n\t\t\tu32 major, minor;\n\t\t\tu8 local_comp;\n\n\t\t\tif (tlv_len != sizeof(u32) * 3)\n\t\t\t\tgoto invalid_tlv_len;\n\n\t\t\tmajor = le32_to_cpup(ptr++);\n\t\t\tminor = le32_to_cpup(ptr++);\n\t\t\tlocal_comp = le32_to_cpup(ptr);\n\n\t\t\tif (major >= 35)\n\t\t\t\tsnprintf(drv->fw.fw_version,\n\t\t\t\t\t sizeof(drv->fw.fw_version),\n\t\t\t\t\t\"%u.%08x.%u %s\", major, minor,\n\t\t\t\t\tlocal_comp, iwl_reduced_fw_name(drv));\n\t\t\telse\n\t\t\t\tsnprintf(drv->fw.fw_version,\n\t\t\t\t\t sizeof(drv->fw.fw_version),\n\t\t\t\t\t\"%u.%u.%u %s\", major, minor,\n\t\t\t\t\tlocal_comp, iwl_reduced_fw_name(drv));\n\t\t\tbreak;\n\t\t\t}\n\t\tcase IWL_UCODE_TLV_FW_DBG_DEST: {\n\t\t\tconst struct iwl_fw_dbg_dest_tlv *dest = NULL;\n\t\t\tconst struct iwl_fw_dbg_dest_tlv_v1 *dest_v1 = NULL;\n\t\t\tu8 mon_mode;\n\n\t\t\tpieces->dbg_dest_ver = (const u8 *)tlv_data;\n\t\t\tif (*pieces->dbg_dest_ver == 1) {\n\t\t\t\tdest = (const void *)tlv_data;\n\t\t\t} else if (*pieces->dbg_dest_ver == 0) {\n\t\t\t\tdest_v1 = (const void *)tlv_data;\n\t\t\t} else {\n\t\t\t\tIWL_ERR(drv,\n\t\t\t\t\t\"The version is %d, and it is invalid\\n\",\n\t\t\t\t\t*pieces->dbg_dest_ver);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (pieces->dbg_dest_tlv_init) {\n\t\t\t\tIWL_ERR(drv,\n\t\t\t\t\t\"dbg destination ignored, already exists\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpieces->dbg_dest_tlv_init = true;\n\n\t\t\tif (dest_v1) {\n\t\t\t\tpieces->dbg_dest_tlv_v1 = dest_v1;\n\t\t\t\tmon_mode = dest_v1->monitor_mode;\n\t\t\t} else {\n\t\t\t\tpieces->dbg_dest_tlv = dest;\n\t\t\t\tmon_mode = dest->monitor_mode;\n\t\t\t}\n\n\t\t\tIWL_INFO(drv, \"Found debug destination: %s\\n\",\n\t\t\t\t get_fw_dbg_mode_string(mon_mode));\n\n\t\t\tdrv->fw.dbg.n_dest_reg = (dest_v1) ?\n\t\t\t\ttlv_len -\n\t\t\t\toffsetof(struct iwl_fw_dbg_dest_tlv_v1,\n\t\t\t\t\t reg_ops) :\n\t\t\t\ttlv_len -\n\t\t\t\toffsetof(struct iwl_fw_dbg_dest_tlv,\n\t\t\t\t\t reg_ops);\n\n\t\t\tdrv->fw.dbg.n_dest_reg /=\n\t\t\t\tsizeof(drv->fw.dbg.dest_tlv->reg_ops[0]);\n\n\t\t\tbreak;\n\t\t\t}\n\t\tcase IWL_UCODE_TLV_FW_DBG_CONF: {\n\t\t\tconst struct iwl_fw_dbg_conf_tlv *conf =\n\t\t\t\t(const void *)tlv_data;\n\n\t\t\tif (!pieces->dbg_dest_tlv_init) {\n\t\t\t\tIWL_ERR(drv,\n\t\t\t\t\t\"Ignore dbg config %d - no destination configured\\n\",\n\t\t\t\t\tconf->id);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (conf->id >= ARRAY_SIZE(drv->fw.dbg.conf_tlv)) {\n\t\t\t\tIWL_ERR(drv,\n\t\t\t\t\t\"Skip unknown configuration: %d\\n\",\n\t\t\t\t\tconf->id);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (pieces->dbg_conf_tlv[conf->id]) {\n\t\t\t\tIWL_ERR(drv,\n\t\t\t\t\t\"Ignore duplicate dbg config %d\\n\",\n\t\t\t\t\tconf->id);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (conf->usniffer)\n\t\t\t\tusniffer_req = true;\n\n\t\t\tIWL_INFO(drv, \"Found debug configuration: %d\\n\",\n\t\t\t\t conf->id);\n\n\t\t\tpieces->dbg_conf_tlv[conf->id] = conf;\n\t\t\tpieces->dbg_conf_tlv_len[conf->id] = tlv_len;\n\t\t\tbreak;\n\t\t\t}\n\t\tcase IWL_UCODE_TLV_FW_DBG_TRIGGER: {\n\t\t\tconst struct iwl_fw_dbg_trigger_tlv *trigger =\n\t\t\t\t(const void *)tlv_data;\n\t\t\tu32 trigger_id = le32_to_cpu(trigger->id);\n\n\t\t\tif (trigger_id >= ARRAY_SIZE(drv->fw.dbg.trigger_tlv)) {\n\t\t\t\tIWL_ERR(drv,\n\t\t\t\t\t\"Skip unknown trigger: %u\\n\",\n\t\t\t\t\ttrigger->id);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (pieces->dbg_trigger_tlv[trigger_id]) {\n\t\t\t\tIWL_ERR(drv,\n\t\t\t\t\t\"Ignore duplicate dbg trigger %u\\n\",\n\t\t\t\t\ttrigger->id);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tIWL_INFO(drv, \"Found debug trigger: %u\\n\", trigger->id);\n\n\t\t\tpieces->dbg_trigger_tlv[trigger_id] = trigger;\n\t\t\tpieces->dbg_trigger_tlv_len[trigger_id] = tlv_len;\n\t\t\tbreak;\n\t\t\t}\n\t\tcase IWL_UCODE_TLV_FW_DBG_DUMP_LST: {\n\t\t\tif (tlv_len != sizeof(u32)) {\n\t\t\t\tIWL_ERR(drv,\n\t\t\t\t\t\"dbg lst mask size incorrect, skip\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdrv->fw.dbg.dump_mask =\n\t\t\t\tle32_to_cpup((const __le32 *)tlv_data);\n\t\t\tbreak;\n\t\t\t}\n\t\tcase IWL_UCODE_TLV_SEC_RT_USNIFFER:\n\t\t\t*usniffer_images = true;\n\t\t\tiwl_store_ucode_sec(pieces, tlv_data,\n\t\t\t\t\t    IWL_UCODE_REGULAR_USNIFFER,\n\t\t\t\t\t    tlv_len);\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_PAGING:\n\t\t\tif (tlv_len != sizeof(u32))\n\t\t\t\tgoto invalid_tlv_len;\n\t\t\tpaging_mem_size = le32_to_cpup((const __le32 *)tlv_data);\n\n\t\t\tIWL_DEBUG_FW(drv,\n\t\t\t\t     \"Paging: paging enabled (size = %u bytes)\\n\",\n\t\t\t\t     paging_mem_size);\n\n\t\t\tif (paging_mem_size > MAX_PAGING_IMAGE_SIZE) {\n\t\t\t\tIWL_ERR(drv,\n\t\t\t\t\t\"Paging: driver supports up to %lu bytes for paging image\\n\",\n\t\t\t\t\tMAX_PAGING_IMAGE_SIZE);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (paging_mem_size & (FW_PAGING_SIZE - 1)) {\n\t\t\t\tIWL_ERR(drv,\n\t\t\t\t\t\"Paging: image isn't multiple %lu\\n\",\n\t\t\t\t\tFW_PAGING_SIZE);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tdrv->fw.img[IWL_UCODE_REGULAR].paging_mem_size =\n\t\t\t\tpaging_mem_size;\n\t\t\tusniffer_img = IWL_UCODE_REGULAR_USNIFFER;\n\t\t\tdrv->fw.img[usniffer_img].paging_mem_size =\n\t\t\t\tpaging_mem_size;\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_FW_GSCAN_CAPA:\n\t\t\t \n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_FW_MEM_SEG: {\n\t\t\tconst struct iwl_fw_dbg_mem_seg_tlv *dbg_mem =\n\t\t\t\t(const void *)tlv_data;\n\t\t\tsize_t size;\n\t\t\tstruct iwl_fw_dbg_mem_seg_tlv *n;\n\n\t\t\tif (tlv_len != (sizeof(*dbg_mem)))\n\t\t\t\tgoto invalid_tlv_len;\n\n\t\t\tIWL_DEBUG_INFO(drv, \"Found debug memory segment: %u\\n\",\n\t\t\t\t       dbg_mem->data_type);\n\n\t\t\tsize = sizeof(*pieces->dbg_mem_tlv) *\n\t\t\t       (pieces->n_mem_tlv + 1);\n\t\t\tn = krealloc(pieces->dbg_mem_tlv, size, GFP_KERNEL);\n\t\t\tif (!n)\n\t\t\t\treturn -ENOMEM;\n\t\t\tpieces->dbg_mem_tlv = n;\n\t\t\tpieces->dbg_mem_tlv[pieces->n_mem_tlv] = *dbg_mem;\n\t\t\tpieces->n_mem_tlv++;\n\t\t\tbreak;\n\t\t\t}\n\t\tcase IWL_UCODE_TLV_IML: {\n\t\t\tdrv->fw.iml_len = tlv_len;\n\t\t\tdrv->fw.iml = kmemdup(tlv_data, tlv_len, GFP_KERNEL);\n\t\t\tif (!drv->fw.iml)\n\t\t\t\treturn -ENOMEM;\n\t\t\tbreak;\n\t\t\t}\n\t\tcase IWL_UCODE_TLV_FW_RECOVERY_INFO: {\n\t\t\tconst struct {\n\t\t\t\t__le32 buf_addr;\n\t\t\t\t__le32 buf_size;\n\t\t\t} *recov_info = (const void *)tlv_data;\n\n\t\t\tif (tlv_len != sizeof(*recov_info))\n\t\t\t\tgoto invalid_tlv_len;\n\t\t\tcapa->error_log_addr =\n\t\t\t\tle32_to_cpu(recov_info->buf_addr);\n\t\t\tcapa->error_log_size =\n\t\t\t\tle32_to_cpu(recov_info->buf_size);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_FW_FSEQ_VERSION: {\n\t\t\tconst struct {\n\t\t\t\tu8 version[32];\n\t\t\t\tu8 sha1[20];\n\t\t\t} *fseq_ver = (const void *)tlv_data;\n\n\t\t\tif (tlv_len != sizeof(*fseq_ver))\n\t\t\t\tgoto invalid_tlv_len;\n\t\t\tIWL_INFO(drv, \"TLV_FW_FSEQ_VERSION: %s\\n\",\n\t\t\t\t fseq_ver->version);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_FW_NUM_STATIONS:\n\t\t\tif (tlv_len != sizeof(u32))\n\t\t\t\tgoto invalid_tlv_len;\n\t\t\tif (le32_to_cpup((const __le32 *)tlv_data) >\n\t\t\t    IWL_MVM_STATION_COUNT_MAX) {\n\t\t\t\tIWL_ERR(drv,\n\t\t\t\t\t\"%d is an invalid number of station\\n\",\n\t\t\t\t\tle32_to_cpup((const __le32 *)tlv_data));\n\t\t\t\tgoto tlv_error;\n\t\t\t}\n\t\t\tcapa->num_stations =\n\t\t\t\tle32_to_cpup((const __le32 *)tlv_data);\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_FW_NUM_BEACONS:\n\t\t\tif (tlv_len != sizeof(u32))\n\t\t\t\tgoto invalid_tlv_len;\n\t\t\tcapa->num_beacons =\n\t\t\t\tle32_to_cpup((const __le32 *)tlv_data);\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_UMAC_DEBUG_ADDRS: {\n\t\t\tconst struct iwl_umac_debug_addrs *dbg_ptrs =\n\t\t\t\t(const void *)tlv_data;\n\n\t\t\tif (tlv_len != sizeof(*dbg_ptrs))\n\t\t\t\tgoto invalid_tlv_len;\n\t\t\tif (drv->trans->trans_cfg->device_family <\n\t\t\t    IWL_DEVICE_FAMILY_22000)\n\t\t\t\tbreak;\n\t\t\tdrv->trans->dbg.umac_error_event_table =\n\t\t\t\tle32_to_cpu(dbg_ptrs->error_info_addr) &\n\t\t\t\t~FW_ADDR_CACHE_CONTROL;\n\t\t\tdrv->trans->dbg.error_event_table_tlv_status |=\n\t\t\t\tIWL_ERROR_EVENT_TABLE_UMAC;\n\t\t\tbreak;\n\t\t\t}\n\t\tcase IWL_UCODE_TLV_LMAC_DEBUG_ADDRS: {\n\t\t\tconst struct iwl_lmac_debug_addrs *dbg_ptrs =\n\t\t\t\t(const void *)tlv_data;\n\n\t\t\tif (tlv_len != sizeof(*dbg_ptrs))\n\t\t\t\tgoto invalid_tlv_len;\n\t\t\tif (drv->trans->trans_cfg->device_family <\n\t\t\t    IWL_DEVICE_FAMILY_22000)\n\t\t\t\tbreak;\n\t\t\tdrv->trans->dbg.lmac_error_event_table[0] =\n\t\t\t\tle32_to_cpu(dbg_ptrs->error_event_table_ptr) &\n\t\t\t\t~FW_ADDR_CACHE_CONTROL;\n\t\t\tdrv->trans->dbg.error_event_table_tlv_status |=\n\t\t\t\tIWL_ERROR_EVENT_TABLE_LMAC1;\n\t\t\tbreak;\n\t\t\t}\n\t\tcase IWL_UCODE_TLV_TYPE_REGIONS:\n\t\t\tiwl_parse_dbg_tlv_assert_tables(drv, tlv);\n\t\t\tfallthrough;\n\t\tcase IWL_UCODE_TLV_TYPE_DEBUG_INFO:\n\t\tcase IWL_UCODE_TLV_TYPE_BUFFER_ALLOCATION:\n\t\tcase IWL_UCODE_TLV_TYPE_HCMD:\n\t\tcase IWL_UCODE_TLV_TYPE_TRIGGERS:\n\t\tcase IWL_UCODE_TLV_TYPE_CONF_SET:\n\t\t\tif (iwlwifi_mod_params.enable_ini)\n\t\t\t\tiwl_dbg_tlv_alloc(drv->trans, tlv, false);\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_CMD_VERSIONS:\n\t\t\tif (tlv_len % sizeof(struct iwl_fw_cmd_version)) {\n\t\t\t\tIWL_ERR(drv,\n\t\t\t\t\t\"Invalid length for command versions: %u\\n\",\n\t\t\t\t\ttlv_len);\n\t\t\t\ttlv_len /= sizeof(struct iwl_fw_cmd_version);\n\t\t\t\ttlv_len *= sizeof(struct iwl_fw_cmd_version);\n\t\t\t}\n\t\t\tif (WARN_ON(capa->cmd_versions))\n\t\t\t\treturn -EINVAL;\n\t\t\tcapa->cmd_versions = kmemdup(tlv_data, tlv_len,\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\t\tif (!capa->cmd_versions)\n\t\t\t\treturn -ENOMEM;\n\t\t\tcapa->n_cmd_versions =\n\t\t\t\ttlv_len / sizeof(struct iwl_fw_cmd_version);\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_PHY_INTEGRATION_VERSION:\n\t\t\tif (drv->fw.phy_integration_ver) {\n\t\t\t\tIWL_ERR(drv,\n\t\t\t\t\t\"phy integration str ignored, already exists\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdrv->fw.phy_integration_ver =\n\t\t\t\tkmemdup(tlv_data, tlv_len, GFP_KERNEL);\n\t\t\tif (!drv->fw.phy_integration_ver)\n\t\t\t\treturn -ENOMEM;\n\t\t\tdrv->fw.phy_integration_ver_len = tlv_len;\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_SEC_TABLE_ADDR:\n\t\tcase IWL_UCODE_TLV_D3_KEK_KCK_ADDR:\n\t\t\tiwl_drv_set_dump_exclude(drv, tlv_type,\n\t\t\t\t\t\t tlv_data, tlv_len);\n\t\t\tbreak;\n\t\tcase IWL_UCODE_TLV_CURRENT_PC:\n\t\t\tif (tlv_len < sizeof(struct iwl_pc_data))\n\t\t\t\tgoto invalid_tlv_len;\n\t\t\tdrv->trans->dbg.num_pc =\n\t\t\t\ttlv_len / sizeof(struct iwl_pc_data);\n\t\t\tdrv->trans->dbg.pc_data =\n\t\t\t\tkmemdup(tlv_data, tlv_len, GFP_KERNEL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tIWL_DEBUG_INFO(drv, \"unknown TLV: %d\\n\", tlv_type);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!fw_has_capa(capa, IWL_UCODE_TLV_CAPA_USNIFFER_UNIFIED) &&\n\t    usniffer_req && !*usniffer_images) {\n\t\tIWL_ERR(drv,\n\t\t\t\"user selected to work with usniffer but usniffer image isn't available in ucode package\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (len) {\n\t\tIWL_ERR(drv, \"invalid TLV after parsing: %zd\\n\", len);\n\t\tiwl_print_hex_dump(drv, IWL_DL_FW, data, len);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n\n invalid_tlv_len:\n\tIWL_ERR(drv, \"TLV %d has invalid size: %u\\n\", tlv_type, tlv_len);\n tlv_error:\n\tiwl_print_hex_dump(drv, IWL_DL_FW, tlv_data, tlv_len);\n\n\treturn -EINVAL;\n}\n\nstatic int iwl_alloc_ucode(struct iwl_drv *drv,\n\t\t\t   struct iwl_firmware_pieces *pieces,\n\t\t\t   enum iwl_ucode_type type)\n{\n\tint i;\n\tstruct fw_desc *sec;\n\n\tsec = kcalloc(pieces->img[type].sec_counter, sizeof(*sec), GFP_KERNEL);\n\tif (!sec)\n\t\treturn -ENOMEM;\n\tdrv->fw.img[type].sec = sec;\n\tdrv->fw.img[type].num_sec = pieces->img[type].sec_counter;\n\n\tfor (i = 0; i < pieces->img[type].sec_counter; i++)\n\t\tif (iwl_alloc_fw_desc(drv, &sec[i], get_sec(pieces, type, i)))\n\t\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int validate_sec_sizes(struct iwl_drv *drv,\n\t\t\t      struct iwl_firmware_pieces *pieces,\n\t\t\t      const struct iwl_cfg *cfg)\n{\n\tIWL_DEBUG_INFO(drv, \"f/w package hdr runtime inst size = %zd\\n\",\n\t\tget_sec_size(pieces, IWL_UCODE_REGULAR,\n\t\t\t     IWL_UCODE_SECTION_INST));\n\tIWL_DEBUG_INFO(drv, \"f/w package hdr runtime data size = %zd\\n\",\n\t\tget_sec_size(pieces, IWL_UCODE_REGULAR,\n\t\t\t     IWL_UCODE_SECTION_DATA));\n\tIWL_DEBUG_INFO(drv, \"f/w package hdr init inst size = %zd\\n\",\n\t\tget_sec_size(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_INST));\n\tIWL_DEBUG_INFO(drv, \"f/w package hdr init data size = %zd\\n\",\n\t\tget_sec_size(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_DATA));\n\n\t \n\tif (get_sec_size(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_INST) >\n\t    cfg->max_inst_size) {\n\t\tIWL_ERR(drv, \"uCode instr len %zd too large to fit in\\n\",\n\t\t\tget_sec_size(pieces, IWL_UCODE_REGULAR,\n\t\t\t\t     IWL_UCODE_SECTION_INST));\n\t\treturn -1;\n\t}\n\n\tif (get_sec_size(pieces, IWL_UCODE_REGULAR, IWL_UCODE_SECTION_DATA) >\n\t    cfg->max_data_size) {\n\t\tIWL_ERR(drv, \"uCode data len %zd too large to fit in\\n\",\n\t\t\tget_sec_size(pieces, IWL_UCODE_REGULAR,\n\t\t\t\t     IWL_UCODE_SECTION_DATA));\n\t\treturn -1;\n\t}\n\n\tif (get_sec_size(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_INST) >\n\t     cfg->max_inst_size) {\n\t\tIWL_ERR(drv, \"uCode init instr len %zd too large to fit in\\n\",\n\t\t\tget_sec_size(pieces, IWL_UCODE_INIT,\n\t\t\t\t     IWL_UCODE_SECTION_INST));\n\t\treturn -1;\n\t}\n\n\tif (get_sec_size(pieces, IWL_UCODE_INIT, IWL_UCODE_SECTION_DATA) >\n\t    cfg->max_data_size) {\n\t\tIWL_ERR(drv, \"uCode init data len %zd too large to fit in\\n\",\n\t\t\tget_sec_size(pieces, IWL_UCODE_REGULAR,\n\t\t\t\t     IWL_UCODE_SECTION_DATA));\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic struct iwl_op_mode *\n_iwl_op_mode_start(struct iwl_drv *drv, struct iwlwifi_opmode_table *op)\n{\n\tconst struct iwl_op_mode_ops *ops = op->ops;\n\tstruct dentry *dbgfs_dir = NULL;\n\tstruct iwl_op_mode *op_mode = NULL;\n\tint retry, max_retry = !!iwlwifi_mod_params.fw_restart * IWL_MAX_INIT_RETRY;\n\n\tfor (retry = 0; retry <= max_retry; retry++) {\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\t\tdrv->dbgfs_op_mode = debugfs_create_dir(op->name,\n\t\t\t\t\t\t\tdrv->dbgfs_drv);\n\t\tdbgfs_dir = drv->dbgfs_op_mode;\n#endif\n\n\t\top_mode = ops->start(drv->trans, drv->trans->cfg,\n\t\t\t\t     &drv->fw, dbgfs_dir);\n\n\t\tif (op_mode)\n\t\t\treturn op_mode;\n\n\t\tIWL_ERR(drv, \"retry init count %d\\n\", retry);\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\t\tdebugfs_remove_recursive(drv->dbgfs_op_mode);\n\t\tdrv->dbgfs_op_mode = NULL;\n#endif\n\t}\n\n\treturn NULL;\n}\n\nstatic void _iwl_op_mode_stop(struct iwl_drv *drv)\n{\n\t \n\tif (drv->op_mode) {\n\t\tiwl_op_mode_stop(drv->op_mode);\n\t\tdrv->op_mode = NULL;\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\t\tdebugfs_remove_recursive(drv->dbgfs_op_mode);\n\t\tdrv->dbgfs_op_mode = NULL;\n#endif\n\t}\n}\n\n \nstatic void iwl_req_fw_callback(const struct firmware *ucode_raw, void *context)\n{\n\tstruct iwl_drv *drv = context;\n\tstruct iwl_fw *fw = &drv->fw;\n\tconst struct iwl_ucode_header *ucode;\n\tstruct iwlwifi_opmode_table *op;\n\tint err;\n\tstruct iwl_firmware_pieces *pieces;\n\tconst unsigned int api_max = drv->trans->cfg->ucode_api_max;\n\tconst unsigned int api_min = drv->trans->cfg->ucode_api_min;\n\tsize_t trigger_tlv_sz[FW_DBG_TRIGGER_MAX];\n\tu32 api_ver;\n\tint i;\n\tbool load_module = false;\n\tbool usniffer_images = false;\n\tbool failure = true;\n\n\tfw->ucode_capa.max_probe_length = IWL_DEFAULT_MAX_PROBE_LENGTH;\n\tfw->ucode_capa.standard_phy_calibration_size =\n\t\t\tIWL_DEFAULT_STANDARD_PHY_CALIBRATE_TBL_SIZE;\n\tfw->ucode_capa.n_scan_channels = IWL_DEFAULT_SCAN_CHANNELS;\n\tfw->ucode_capa.num_stations = IWL_MVM_STATION_COUNT_MAX;\n\tfw->ucode_capa.num_beacons = 1;\n\t \n\tfw->dbg.dump_mask = 0xffffffff;\n\n\tpieces = kzalloc(sizeof(*pieces), GFP_KERNEL);\n\tif (!pieces)\n\t\tgoto out_free_fw;\n\n\tif (!ucode_raw)\n\t\tgoto try_again;\n\n\tIWL_DEBUG_FW_INFO(drv, \"Loaded firmware file '%s' (%zd bytes).\\n\",\n\t\t\t  drv->firmware_name, ucode_raw->size);\n\n\t \n\tif (ucode_raw->size < 4) {\n\t\tIWL_ERR(drv, \"File size way too small!\\n\");\n\t\tgoto try_again;\n\t}\n\n\t \n\tucode = (const struct iwl_ucode_header *)ucode_raw->data;\n\n\tif (ucode->ver)\n\t\terr = iwl_parse_v1_v2_firmware(drv, ucode_raw, pieces);\n\telse\n\t\terr = iwl_parse_tlv_firmware(drv, ucode_raw, pieces,\n\t\t\t\t\t     &fw->ucode_capa, &usniffer_images);\n\n\tif (err)\n\t\tgoto try_again;\n\n\tif (fw_has_api(&drv->fw.ucode_capa, IWL_UCODE_TLV_API_NEW_VERSION))\n\t\tapi_ver = drv->fw.ucode_ver;\n\telse\n\t\tapi_ver = IWL_UCODE_API(drv->fw.ucode_ver);\n\n\t \n\tif (api_ver < api_min || api_ver > api_max) {\n\t\tIWL_ERR(drv,\n\t\t\t\"Driver unable to support your firmware API. \"\n\t\t\t\"Driver supports v%u, firmware is v%u.\\n\",\n\t\t\tapi_max, api_ver);\n\t\tgoto try_again;\n\t}\n\n\t \n\tif (fw->type == IWL_FW_DVM && validate_sec_sizes(drv, pieces,\n\t\t\t\t\t\t\t drv->trans->cfg))\n\t\tgoto try_again;\n\n\t \n\n\t \n\tfor (i = 0; i < IWL_UCODE_TYPE_MAX; i++)\n\t\tif (iwl_alloc_ucode(drv, pieces, i))\n\t\t\tgoto out_free_fw;\n\n\tif (pieces->dbg_dest_tlv_init) {\n\t\tsize_t dbg_dest_size = sizeof(*drv->fw.dbg.dest_tlv) +\n\t\t\tsizeof(drv->fw.dbg.dest_tlv->reg_ops[0]) *\n\t\t\tdrv->fw.dbg.n_dest_reg;\n\n\t\tdrv->fw.dbg.dest_tlv = kmalloc(dbg_dest_size, GFP_KERNEL);\n\n\t\tif (!drv->fw.dbg.dest_tlv)\n\t\t\tgoto out_free_fw;\n\n\t\tif (*pieces->dbg_dest_ver == 0) {\n\t\t\tmemcpy(drv->fw.dbg.dest_tlv, pieces->dbg_dest_tlv_v1,\n\t\t\t       dbg_dest_size);\n\t\t} else {\n\t\t\tstruct iwl_fw_dbg_dest_tlv_v1 *dest_tlv =\n\t\t\t\tdrv->fw.dbg.dest_tlv;\n\n\t\t\tdest_tlv->version = pieces->dbg_dest_tlv->version;\n\t\t\tdest_tlv->monitor_mode =\n\t\t\t\tpieces->dbg_dest_tlv->monitor_mode;\n\t\t\tdest_tlv->size_power =\n\t\t\t\tpieces->dbg_dest_tlv->size_power;\n\t\t\tdest_tlv->wrap_count =\n\t\t\t\tpieces->dbg_dest_tlv->wrap_count;\n\t\t\tdest_tlv->write_ptr_reg =\n\t\t\t\tpieces->dbg_dest_tlv->write_ptr_reg;\n\t\t\tdest_tlv->base_shift =\n\t\t\t\tpieces->dbg_dest_tlv->base_shift;\n\t\t\tmemcpy(dest_tlv->reg_ops,\n\t\t\t       pieces->dbg_dest_tlv->reg_ops,\n\t\t\t       sizeof(drv->fw.dbg.dest_tlv->reg_ops[0]) *\n\t\t\t       drv->fw.dbg.n_dest_reg);\n\n\t\t\t \n\t\t\tdest_tlv->base_reg = pieces->dbg_dest_tlv->cfg_reg;\n\t\t\tdest_tlv->end_shift =\n\t\t\t\tpieces->dbg_dest_tlv->size_shift;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(drv->fw.dbg.conf_tlv); i++) {\n\t\tif (pieces->dbg_conf_tlv[i]) {\n\t\t\tdrv->fw.dbg.conf_tlv[i] =\n\t\t\t\tkmemdup(pieces->dbg_conf_tlv[i],\n\t\t\t\t\tpieces->dbg_conf_tlv_len[i],\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!drv->fw.dbg.conf_tlv[i])\n\t\t\t\tgoto out_free_fw;\n\t\t}\n\t}\n\n\tmemset(&trigger_tlv_sz, 0xff, sizeof(trigger_tlv_sz));\n\n\ttrigger_tlv_sz[FW_DBG_TRIGGER_MISSED_BEACONS] =\n\t\tsizeof(struct iwl_fw_dbg_trigger_missed_bcon);\n\ttrigger_tlv_sz[FW_DBG_TRIGGER_CHANNEL_SWITCH] = 0;\n\ttrigger_tlv_sz[FW_DBG_TRIGGER_FW_NOTIF] =\n\t\tsizeof(struct iwl_fw_dbg_trigger_cmd);\n\ttrigger_tlv_sz[FW_DBG_TRIGGER_MLME] =\n\t\tsizeof(struct iwl_fw_dbg_trigger_mlme);\n\ttrigger_tlv_sz[FW_DBG_TRIGGER_STATS] =\n\t\tsizeof(struct iwl_fw_dbg_trigger_stats);\n\ttrigger_tlv_sz[FW_DBG_TRIGGER_RSSI] =\n\t\tsizeof(struct iwl_fw_dbg_trigger_low_rssi);\n\ttrigger_tlv_sz[FW_DBG_TRIGGER_TXQ_TIMERS] =\n\t\tsizeof(struct iwl_fw_dbg_trigger_txq_timer);\n\ttrigger_tlv_sz[FW_DBG_TRIGGER_TIME_EVENT] =\n\t\tsizeof(struct iwl_fw_dbg_trigger_time_event);\n\ttrigger_tlv_sz[FW_DBG_TRIGGER_BA] =\n\t\tsizeof(struct iwl_fw_dbg_trigger_ba);\n\ttrigger_tlv_sz[FW_DBG_TRIGGER_TDLS] =\n\t\tsizeof(struct iwl_fw_dbg_trigger_tdls);\n\n\tfor (i = 0; i < ARRAY_SIZE(drv->fw.dbg.trigger_tlv); i++) {\n\t\tif (pieces->dbg_trigger_tlv[i]) {\n\t\t\t \n\t\t\tif (WARN_ON(pieces->dbg_trigger_tlv_len[i] <\n\t\t\t\t    (trigger_tlv_sz[i] +\n\t\t\t\t     sizeof(struct iwl_fw_dbg_trigger_tlv))))\n\t\t\t\tgoto out_free_fw;\n\t\t\tdrv->fw.dbg.trigger_tlv_len[i] =\n\t\t\t\tpieces->dbg_trigger_tlv_len[i];\n\t\t\tdrv->fw.dbg.trigger_tlv[i] =\n\t\t\t\tkmemdup(pieces->dbg_trigger_tlv[i],\n\t\t\t\t\tdrv->fw.dbg.trigger_tlv_len[i],\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!drv->fw.dbg.trigger_tlv[i])\n\t\t\t\tgoto out_free_fw;\n\t\t}\n\t}\n\n\t \n\n\tdrv->fw.dbg.mem_tlv = pieces->dbg_mem_tlv;\n\tpieces->dbg_mem_tlv = NULL;\n\tdrv->fw.dbg.n_mem_tlv = pieces->n_mem_tlv;\n\n\t \n\tfw->init_evtlog_ptr = pieces->init_evtlog_ptr;\n\tif (pieces->init_evtlog_size)\n\t\tfw->init_evtlog_size = (pieces->init_evtlog_size - 16)/12;\n\telse\n\t\tfw->init_evtlog_size =\n\t\t\tdrv->trans->trans_cfg->base_params->max_event_log_size;\n\tfw->init_errlog_ptr = pieces->init_errlog_ptr;\n\tfw->inst_evtlog_ptr = pieces->inst_evtlog_ptr;\n\tif (pieces->inst_evtlog_size)\n\t\tfw->inst_evtlog_size = (pieces->inst_evtlog_size - 16)/12;\n\telse\n\t\tfw->inst_evtlog_size =\n\t\t\tdrv->trans->trans_cfg->base_params->max_event_log_size;\n\tfw->inst_errlog_ptr = pieces->inst_errlog_ptr;\n\n\t \n\tif (fw->ucode_capa.standard_phy_calibration_size >\n\t    IWL_MAX_PHY_CALIBRATE_TBL_SIZE)\n\t\tfw->ucode_capa.standard_phy_calibration_size =\n\t\t\tIWL_MAX_STANDARD_PHY_CALIBRATE_TBL_SIZE;\n\n\t \n\trelease_firmware(ucode_raw);\n\n\tiwl_dbg_tlv_load_bin(drv->trans->dev, drv->trans);\n\n\tmutex_lock(&iwlwifi_opmode_table_mtx);\n\tswitch (fw->type) {\n\tcase IWL_FW_DVM:\n\t\top = &iwlwifi_opmode_table[DVM_OP_MODE];\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Invalid fw type %d\\n\", fw->type);\n\t\tfallthrough;\n\tcase IWL_FW_MVM:\n\t\top = &iwlwifi_opmode_table[MVM_OP_MODE];\n\t\tbreak;\n\t}\n\n\tIWL_INFO(drv, \"loaded firmware version %s op_mode %s\\n\",\n\t\t drv->fw.fw_version, op->name);\n\n\t \n\tlist_add_tail(&drv->list, &op->drv);\n\n\tif (op->ops) {\n\t\tdrv->op_mode = _iwl_op_mode_start(drv, op);\n\n\t\tif (!drv->op_mode) {\n\t\t\tmutex_unlock(&iwlwifi_opmode_table_mtx);\n\t\t\tgoto out_unbind;\n\t\t}\n\t} else {\n\t\tload_module = true;\n\t}\n\tmutex_unlock(&iwlwifi_opmode_table_mtx);\n\n\t \n\tcomplete(&drv->request_firmware_complete);\n\n\t \n\tif (load_module)\n\t\trequest_module(\"%s\", op->name);\n\tfailure = false;\n\tgoto free;\n\n try_again:\n\t \n\trelease_firmware(ucode_raw);\n\tif (iwl_request_firmware(drv, false))\n\t\tgoto out_unbind;\n\tgoto free;\n\n out_free_fw:\n\trelease_firmware(ucode_raw);\n out_unbind:\n\tcomplete(&drv->request_firmware_complete);\n\tdevice_release_driver(drv->trans->dev);\n\t \n\tfailure = false;\n free:\n\tif (failure)\n\t\tiwl_dealloc_ucode(drv);\n\n\tif (pieces) {\n\t\tfor (i = 0; i < ARRAY_SIZE(pieces->img); i++)\n\t\t\tkfree(pieces->img[i].sec);\n\t\tkfree(pieces->dbg_mem_tlv);\n\t\tkfree(pieces);\n\t}\n}\n\nstruct iwl_drv *iwl_drv_start(struct iwl_trans *trans)\n{\n\tstruct iwl_drv *drv;\n\tint ret;\n\n\tdrv = kzalloc(sizeof(*drv), GFP_KERNEL);\n\tif (!drv) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tdrv->trans = trans;\n\tdrv->dev = trans->dev;\n\n\tinit_completion(&drv->request_firmware_complete);\n\tINIT_LIST_HEAD(&drv->list);\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\t \n\tdrv->dbgfs_drv = debugfs_create_dir(dev_name(trans->dev),\n\t\t\t\t\t    iwl_dbgfs_root);\n\n\t \n\tdrv->trans->dbgfs_dir = debugfs_create_dir(\"trans\", drv->dbgfs_drv);\n#endif\n\n\tdrv->trans->dbg.domains_bitmap = IWL_TRANS_FW_DBG_DOMAIN(drv->trans);\n\tif (iwlwifi_mod_params.enable_ini != ENABLE_INI) {\n\t\t \n\t\tdrv->trans->dbg.domains_bitmap &= 0xffff;\n\t\tif (iwlwifi_mod_params.enable_ini != IWL_FW_INI_PRESET_DISABLE) {\n\t\t\tif (iwlwifi_mod_params.enable_ini > ENABLE_INI) {\n\t\t\t\tIWL_ERR(trans,\n\t\t\t\t\t\"invalid enable_ini module parameter value: max = %d, using 0 instead\\n\",\n\t\t\t\t\tENABLE_INI);\n\t\t\t\tiwlwifi_mod_params.enable_ini = 0;\n\t\t\t}\n\t\t\tdrv->trans->dbg.domains_bitmap =\n\t\t\t\tBIT(IWL_FW_DBG_DOMAIN_POS + iwlwifi_mod_params.enable_ini);\n\t\t}\n\t}\n\n\tret = iwl_request_firmware(drv, true);\n\tif (ret) {\n\t\tIWL_ERR(trans, \"Couldn't request the fw\\n\");\n\t\tgoto err_fw;\n\t}\n\n\treturn drv;\n\nerr_fw:\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tdebugfs_remove_recursive(drv->dbgfs_drv);\n\tiwl_dbg_tlv_free(drv->trans);\n#endif\n\tkfree(drv);\nerr:\n\treturn ERR_PTR(ret);\n}\n\nvoid iwl_drv_stop(struct iwl_drv *drv)\n{\n\twait_for_completion(&drv->request_firmware_complete);\n\n\t_iwl_op_mode_stop(drv);\n\n\tiwl_dealloc_ucode(drv);\n\n\tmutex_lock(&iwlwifi_opmode_table_mtx);\n\t \n\tif (!list_empty(&drv->list))\n\t\tlist_del(&drv->list);\n\tmutex_unlock(&iwlwifi_opmode_table_mtx);\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tdrv->trans->ops->debugfs_cleanup(drv->trans);\n\n\tdebugfs_remove_recursive(drv->dbgfs_drv);\n#endif\n\n\tiwl_dbg_tlv_free(drv->trans);\n\n\tkfree(drv);\n}\n\n \nstruct iwl_mod_params iwlwifi_mod_params = {\n\t.fw_restart = true,\n\t.bt_coex_active = true,\n\t.power_level = IWL_POWER_INDEX_1,\n\t.uapsd_disable = IWL_DISABLE_UAPSD_BSS | IWL_DISABLE_UAPSD_P2P_CLIENT,\n\t.enable_ini = ENABLE_INI,\n\t \n};\nIWL_EXPORT_SYMBOL(iwlwifi_mod_params);\n\nint iwl_opmode_register(const char *name, const struct iwl_op_mode_ops *ops)\n{\n\tint i;\n\tstruct iwl_drv *drv;\n\tstruct iwlwifi_opmode_table *op;\n\n\tmutex_lock(&iwlwifi_opmode_table_mtx);\n\tfor (i = 0; i < ARRAY_SIZE(iwlwifi_opmode_table); i++) {\n\t\top = &iwlwifi_opmode_table[i];\n\t\tif (strcmp(op->name, name))\n\t\t\tcontinue;\n\t\top->ops = ops;\n\t\t \n\t\tlist_for_each_entry(drv, &op->drv, list)\n\t\t\tdrv->op_mode = _iwl_op_mode_start(drv, op);\n\n\t\tmutex_unlock(&iwlwifi_opmode_table_mtx);\n\t\treturn 0;\n\t}\n\tmutex_unlock(&iwlwifi_opmode_table_mtx);\n\treturn -EIO;\n}\nIWL_EXPORT_SYMBOL(iwl_opmode_register);\n\nvoid iwl_opmode_deregister(const char *name)\n{\n\tint i;\n\tstruct iwl_drv *drv;\n\n\tmutex_lock(&iwlwifi_opmode_table_mtx);\n\tfor (i = 0; i < ARRAY_SIZE(iwlwifi_opmode_table); i++) {\n\t\tif (strcmp(iwlwifi_opmode_table[i].name, name))\n\t\t\tcontinue;\n\t\tiwlwifi_opmode_table[i].ops = NULL;\n\n\t\t \n\t\tlist_for_each_entry(drv, &iwlwifi_opmode_table[i].drv, list)\n\t\t\t_iwl_op_mode_stop(drv);\n\n\t\tmutex_unlock(&iwlwifi_opmode_table_mtx);\n\t\treturn;\n\t}\n\tmutex_unlock(&iwlwifi_opmode_table_mtx);\n}\nIWL_EXPORT_SYMBOL(iwl_opmode_deregister);\n\nstatic int __init iwl_drv_init(void)\n{\n\tint i, err;\n\n\tfor (i = 0; i < ARRAY_SIZE(iwlwifi_opmode_table); i++)\n\t\tINIT_LIST_HEAD(&iwlwifi_opmode_table[i].drv);\n\n\tpr_info(DRV_DESCRIPTION \"\\n\");\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\t \n\tiwl_dbgfs_root = debugfs_create_dir(DRV_NAME, NULL);\n#endif\n\n\terr = iwl_pci_register_driver();\n\tif (err)\n\t\tgoto cleanup_debugfs;\n\n\treturn 0;\n\ncleanup_debugfs:\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tdebugfs_remove_recursive(iwl_dbgfs_root);\n#endif\n\treturn err;\n}\nmodule_init(iwl_drv_init);\n\nstatic void __exit iwl_drv_exit(void)\n{\n\tiwl_pci_unregister_driver();\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tdebugfs_remove_recursive(iwl_dbgfs_root);\n#endif\n}\nmodule_exit(iwl_drv_exit);\n\n#ifdef CONFIG_IWLWIFI_DEBUG\nmodule_param_named(debug, iwlwifi_mod_params.debug_level, uint, 0644);\nMODULE_PARM_DESC(debug, \"debug output mask\");\n#endif\n\nmodule_param_named(swcrypto, iwlwifi_mod_params.swcrypto, int, 0444);\nMODULE_PARM_DESC(swcrypto, \"using crypto in software (default 0 [hardware])\");\nmodule_param_named(11n_disable, iwlwifi_mod_params.disable_11n, uint, 0444);\nMODULE_PARM_DESC(11n_disable,\n\t\"disable 11n functionality, bitmap: 1: full, 2: disable agg TX, 4: disable agg RX, 8 enable agg TX\");\nmodule_param_named(amsdu_size, iwlwifi_mod_params.amsdu_size, int, 0444);\nMODULE_PARM_DESC(amsdu_size,\n\t\t \"amsdu size 0: 12K for multi Rx queue devices, 2K for AX210 devices, \"\n\t\t \"4K for other devices 1:4K 2:8K 3:12K (16K buffers) 4: 2K (default 0)\");\nmodule_param_named(fw_restart, iwlwifi_mod_params.fw_restart, bool, 0444);\nMODULE_PARM_DESC(fw_restart, \"restart firmware in case of error (default true)\");\n\nmodule_param_named(nvm_file, iwlwifi_mod_params.nvm_file, charp, 0444);\nMODULE_PARM_DESC(nvm_file, \"NVM file name\");\n\nmodule_param_named(uapsd_disable, iwlwifi_mod_params.uapsd_disable, uint, 0644);\nMODULE_PARM_DESC(uapsd_disable,\n\t\t \"disable U-APSD functionality bitmap 1: BSS 2: P2P Client (default: 3)\");\n\nmodule_param_named(enable_ini, iwlwifi_mod_params.enable_ini, uint, 0444);\nMODULE_PARM_DESC(enable_ini,\n\t\t \"0:disable, 1-15:FW_DBG_PRESET Values, 16:enabled without preset value defined,\"\n\t\t \"Debug INI TLV FW debug infrastructure (default: 16)\");\n\n \nmodule_param_named(bt_coex_active, iwlwifi_mod_params.bt_coex_active,\n\t\t   bool, 0444);\nMODULE_PARM_DESC(bt_coex_active, \"enable wifi/bt co-exist (default: enable)\");\n\nmodule_param_named(led_mode, iwlwifi_mod_params.led_mode, int, 0444);\nMODULE_PARM_DESC(led_mode, \"0=system default, \"\n\t\t\"1=On(RF On)/Off(RF Off), 2=blinking, 3=Off (default: 0)\");\n\nmodule_param_named(power_save, iwlwifi_mod_params.power_save, bool, 0444);\nMODULE_PARM_DESC(power_save,\n\t\t \"enable WiFi power management (default: disable)\");\n\nmodule_param_named(power_level, iwlwifi_mod_params.power_level, int, 0444);\nMODULE_PARM_DESC(power_level,\n\t\t \"default power save level (range from 1 - 5, default: 1)\");\n\nmodule_param_named(disable_11ac, iwlwifi_mod_params.disable_11ac, bool, 0444);\nMODULE_PARM_DESC(disable_11ac, \"Disable VHT capabilities (default: false)\");\n\nmodule_param_named(remove_when_gone,\n\t\t   iwlwifi_mod_params.remove_when_gone, bool,\n\t\t   0444);\nMODULE_PARM_DESC(remove_when_gone,\n\t\t \"Remove dev from PCIe bus if it is deemed inaccessible (default: false)\");\n\nmodule_param_named(disable_11ax, iwlwifi_mod_params.disable_11ax, bool,\n\t\t   S_IRUGO);\nMODULE_PARM_DESC(disable_11ax, \"Disable HE capabilities (default: false)\");\n\nmodule_param_named(disable_11be, iwlwifi_mod_params.disable_11be, bool, 0444);\nMODULE_PARM_DESC(disable_11be, \"Disable EHT capabilities (default: false)\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}