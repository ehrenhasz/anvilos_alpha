{
  "module_name": "tx.c",
  "hash_id": "7d429921a6564a45ecd11577817006868dec8c92e9d585019e5f27b3f2beda8c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/dvm/tx.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/ieee80211.h>\n#include \"iwl-io.h\"\n#include \"iwl-trans.h\"\n#include \"iwl-agn-hw.h\"\n#include \"dev.h\"\n#include \"agn.h\"\n\nstatic const u8 tid_to_ac[] = {\n\tIEEE80211_AC_BE,\n\tIEEE80211_AC_BK,\n\tIEEE80211_AC_BK,\n\tIEEE80211_AC_BE,\n\tIEEE80211_AC_VI,\n\tIEEE80211_AC_VI,\n\tIEEE80211_AC_VO,\n\tIEEE80211_AC_VO,\n};\n\nstatic void iwlagn_tx_cmd_protection(struct iwl_priv *priv,\n\t\t\t\t     struct ieee80211_tx_info *info,\n\t\t\t\t     __le16 fc, __le32 *tx_flags)\n{\n\tif (info->control.rates[0].flags & IEEE80211_TX_RC_USE_RTS_CTS ||\n\t    info->control.rates[0].flags & IEEE80211_TX_RC_USE_CTS_PROTECT ||\n\t    info->flags & IEEE80211_TX_CTL_AMPDU)\n\t\t*tx_flags |= TX_CMD_FLG_PROT_REQUIRE_MSK;\n}\n\n \nstatic void iwlagn_tx_cmd_build_basic(struct iwl_priv *priv,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      struct iwl_tx_cmd *tx_cmd,\n\t\t\t\t      struct ieee80211_tx_info *info,\n\t\t\t\t      struct ieee80211_hdr *hdr, u8 sta_id)\n{\n\t__le16 fc = hdr->frame_control;\n\t__le32 tx_flags = tx_cmd->tx_flags;\n\n\ttx_cmd->stop_time.life_time = TX_CMD_LIFE_TIME_INFINITE;\n\n\tif (!(info->flags & IEEE80211_TX_CTL_NO_ACK))\n\t\ttx_flags |= TX_CMD_FLG_ACK_MSK;\n\telse\n\t\ttx_flags &= ~TX_CMD_FLG_ACK_MSK;\n\n\tif (ieee80211_is_probe_resp(fc))\n\t\ttx_flags |= TX_CMD_FLG_TSF_MSK;\n\telse if (ieee80211_is_back_req(fc))\n\t\ttx_flags |= TX_CMD_FLG_ACK_MSK | TX_CMD_FLG_IMM_BA_RSP_MASK;\n\telse if (info->band == NL80211_BAND_2GHZ &&\n\t\t priv->lib->bt_params &&\n\t\t priv->lib->bt_params->advanced_bt_coexist &&\n\t\t (ieee80211_is_auth(fc) || ieee80211_is_assoc_req(fc) ||\n\t\t ieee80211_is_reassoc_req(fc) ||\n\t\t info->control.flags & IEEE80211_TX_CTRL_PORT_CTRL_PROTO))\n\t\ttx_flags |= TX_CMD_FLG_IGNORE_BT;\n\n\n\ttx_cmd->sta_id = sta_id;\n\tif (ieee80211_has_morefrags(fc))\n\t\ttx_flags |= TX_CMD_FLG_MORE_FRAG_MSK;\n\n\tif (ieee80211_is_data_qos(fc)) {\n\t\tu8 *qc = ieee80211_get_qos_ctl(hdr);\n\t\ttx_cmd->tid_tspec = qc[0] & 0xf;\n\t\ttx_flags &= ~TX_CMD_FLG_SEQ_CTL_MSK;\n\t} else {\n\t\ttx_cmd->tid_tspec = IWL_TID_NON_QOS;\n\t\tif (info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ)\n\t\t\ttx_flags |= TX_CMD_FLG_SEQ_CTL_MSK;\n\t\telse\n\t\t\ttx_flags &= ~TX_CMD_FLG_SEQ_CTL_MSK;\n\t}\n\n\tiwlagn_tx_cmd_protection(priv, info, fc, &tx_flags);\n\n\ttx_flags &= ~(TX_CMD_FLG_ANT_SEL_MSK);\n\tif (ieee80211_is_mgmt(fc)) {\n\t\tif (ieee80211_is_assoc_req(fc) || ieee80211_is_reassoc_req(fc))\n\t\t\ttx_cmd->timeout.pm_frame_timeout = cpu_to_le16(3);\n\t\telse\n\t\t\ttx_cmd->timeout.pm_frame_timeout = cpu_to_le16(2);\n\t} else {\n\t\ttx_cmd->timeout.pm_frame_timeout = 0;\n\t}\n\n\ttx_cmd->driver_txop = 0;\n\ttx_cmd->tx_flags = tx_flags;\n\ttx_cmd->next_frame_len = 0;\n}\n\nstatic void iwlagn_tx_cmd_build_rate(struct iwl_priv *priv,\n\t\t\t\t     struct iwl_tx_cmd *tx_cmd,\n\t\t\t\t     struct ieee80211_tx_info *info,\n\t\t\t\t     struct ieee80211_sta *sta,\n\t\t\t\t     __le16 fc)\n{\n\tu32 rate_flags;\n\tint rate_idx;\n\tu8 rts_retry_limit;\n\tu8 data_retry_limit;\n\tu8 rate_plcp;\n\n\tif (priv->wowlan) {\n\t\trts_retry_limit = IWLAGN_LOW_RETRY_LIMIT;\n\t\tdata_retry_limit = IWLAGN_LOW_RETRY_LIMIT;\n\t} else {\n\t\t \n\t\trts_retry_limit = IWLAGN_RTS_DFAULT_RETRY_LIMIT;\n\n\t\t \n\t\tif (ieee80211_is_probe_resp(fc)) {\n\t\t\tdata_retry_limit = IWLAGN_MGMT_DFAULT_RETRY_LIMIT;\n\t\t\trts_retry_limit =\n\t\t\t\tmin(data_retry_limit, rts_retry_limit);\n\t\t} else if (ieee80211_is_back_req(fc))\n\t\t\tdata_retry_limit = IWLAGN_BAR_DFAULT_RETRY_LIMIT;\n\t\telse\n\t\t\tdata_retry_limit = IWLAGN_DEFAULT_TX_RETRY;\n\t}\n\n\ttx_cmd->data_retry_limit = data_retry_limit;\n\ttx_cmd->rts_retry_limit = rts_retry_limit;\n\n\t \n\tif (ieee80211_is_data(fc)) {\n\t\ttx_cmd->initial_rate_index = 0;\n\t\ttx_cmd->tx_flags |= TX_CMD_FLG_STA_RATE_MSK;\n\t\treturn;\n\t} else if (ieee80211_is_back_req(fc))\n\t\ttx_cmd->tx_flags |= TX_CMD_FLG_STA_RATE_MSK;\n\n\t \n\trate_idx = info->control.rates[0].idx;\n\tif (info->control.rates[0].flags & IEEE80211_TX_RC_MCS ||\n\t\t\t(rate_idx < 0) || (rate_idx > IWL_RATE_COUNT_LEGACY))\n\t\trate_idx = rate_lowest_index(\n\t\t\t\t&priv->nvm_data->bands[info->band], sta);\n\t \n\tif (info->band == NL80211_BAND_5GHZ)\n\t\trate_idx += IWL_FIRST_OFDM_RATE;\n\t \n\trate_plcp = iwl_rates[rate_idx].plcp;\n\t \n\trate_flags = 0;\n\n\t \n\tif ((rate_idx >= IWL_FIRST_CCK_RATE) && (rate_idx <= IWL_LAST_CCK_RATE))\n\t\trate_flags |= RATE_MCS_CCK_MSK;\n\n\t \n\tif (priv->lib->bt_params &&\n\t    priv->lib->bt_params->advanced_bt_coexist &&\n\t    priv->bt_full_concurrent) {\n\t\t \n\t\tpriv->mgmt_tx_ant = iwl_toggle_tx_ant(priv, priv->mgmt_tx_ant,\n\t\t\t\tfirst_antenna(priv->nvm_data->valid_tx_ant));\n\t} else\n\t\tpriv->mgmt_tx_ant = iwl_toggle_tx_ant(\n\t\t\t\t\tpriv, priv->mgmt_tx_ant,\n\t\t\t\t\tpriv->nvm_data->valid_tx_ant);\n\trate_flags |= iwl_ant_idx_to_flags(priv->mgmt_tx_ant);\n\n\t \n\ttx_cmd->rate_n_flags = iwl_hw_set_rate_n_flags(rate_plcp, rate_flags);\n}\n\nstatic void iwlagn_tx_cmd_build_hwcrypto(struct iwl_priv *priv,\n\t\t\t\t\t struct ieee80211_tx_info *info,\n\t\t\t\t\t struct iwl_tx_cmd *tx_cmd,\n\t\t\t\t\t struct sk_buff *skb_frag)\n{\n\tstruct ieee80211_key_conf *keyconf = info->control.hw_key;\n\n\tswitch (keyconf->cipher) {\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\ttx_cmd->sec_ctl = TX_CMD_SEC_CCM;\n\t\tmemcpy(tx_cmd->key, keyconf->key, keyconf->keylen);\n\t\tif (info->flags & IEEE80211_TX_CTL_AMPDU)\n\t\t\ttx_cmd->tx_flags |= TX_CMD_FLG_AGG_CCMP_MSK;\n\t\tbreak;\n\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\ttx_cmd->sec_ctl = TX_CMD_SEC_TKIP;\n\t\tieee80211_get_tkip_p2k(keyconf, skb_frag, tx_cmd->key);\n\t\tbreak;\n\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\ttx_cmd->sec_ctl |= TX_CMD_SEC_KEY128;\n\t\tfallthrough;\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\ttx_cmd->sec_ctl |= (TX_CMD_SEC_WEP |\n\t\t\t(keyconf->keyidx & TX_CMD_SEC_MSK) << TX_CMD_SEC_SHIFT);\n\n\t\tmemcpy(&tx_cmd->key[3], keyconf->key, keyconf->keylen);\n\n\t\tIWL_DEBUG_TX(priv, \"Configuring packet for WEP encryption \"\n\t\t\t     \"with key %d\\n\", keyconf->keyidx);\n\t\tbreak;\n\n\tdefault:\n\t\tIWL_ERR(priv, \"Unknown encode cipher %x\\n\", keyconf->cipher);\n\t\tbreak;\n\t}\n}\n\n \nstatic int iwl_sta_id_or_broadcast(struct iwl_rxon_context *context,\n\t\t\t\t   struct ieee80211_sta *sta)\n{\n\tint sta_id;\n\n\tif (!sta)\n\t\treturn context->bcast_sta_id;\n\n\tsta_id = iwl_sta_id(sta);\n\n\t \n\tWARN_ON(sta_id == IWL_INVALID_STATION);\n\n\treturn sta_id;\n}\n\n \nint iwlagn_tx_skb(struct iwl_priv *priv,\n\t\t  struct ieee80211_sta *sta,\n\t\t  struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct iwl_station_priv *sta_priv = NULL;\n\tstruct iwl_rxon_context *ctx = &priv->contexts[IWL_RXON_CTX_BSS];\n\tstruct iwl_device_tx_cmd *dev_cmd;\n\tstruct iwl_tx_cmd *tx_cmd;\n\t__le16 fc;\n\tu8 hdr_len;\n\tu16 len, seq_number = 0;\n\tu8 sta_id, tid = IWL_MAX_TID_COUNT;\n\tbool is_agg = false, is_data_qos = false;\n\tint txq_id;\n\n\tif (info->control.vif)\n\t\tctx = iwl_rxon_ctx_from_vif(info->control.vif);\n\n\tif (iwl_is_rfkill(priv)) {\n\t\tIWL_DEBUG_DROP(priv, \"Dropping - RF KILL\\n\");\n\t\tgoto drop_unlock_priv;\n\t}\n\n\tfc = hdr->frame_control;\n\n#ifdef CONFIG_IWLWIFI_DEBUG\n\tif (ieee80211_is_auth(fc))\n\t\tIWL_DEBUG_TX(priv, \"Sending AUTH frame\\n\");\n\telse if (ieee80211_is_assoc_req(fc))\n\t\tIWL_DEBUG_TX(priv, \"Sending ASSOC frame\\n\");\n\telse if (ieee80211_is_reassoc_req(fc))\n\t\tIWL_DEBUG_TX(priv, \"Sending REASSOC frame\\n\");\n#endif\n\n\tif (unlikely(ieee80211_is_probe_resp(fc))) {\n\t\tstruct iwl_wipan_noa_data *noa_data =\n\t\t\trcu_dereference(priv->noa_data);\n\n\t\tif (noa_data &&\n\t\t    pskb_expand_head(skb, 0, noa_data->length,\n\t\t\t\t     GFP_ATOMIC) == 0) {\n\t\t\tskb_put_data(skb, noa_data->data, noa_data->length);\n\t\t\thdr = (struct ieee80211_hdr *)skb->data;\n\t\t}\n\t}\n\n\thdr_len = ieee80211_hdrlen(fc);\n\n\t \n\tif (!ieee80211_is_data(fc))\n\t\tsta_id = ctx->bcast_sta_id;\n\telse {\n\t\t \n\t\tsta_id = iwl_sta_id_or_broadcast(ctx, sta);\n\t\tif (sta_id == IWL_INVALID_STATION) {\n\t\t\tIWL_DEBUG_DROP(priv, \"Dropping - INVALID STATION: %pM\\n\",\n\t\t\t\t       hdr->addr1);\n\t\t\tgoto drop_unlock_priv;\n\t\t}\n\t}\n\n\tif (sta)\n\t\tsta_priv = (void *)sta->drv_priv;\n\n\tif (sta_priv && sta_priv->asleep &&\n\t    (info->flags & IEEE80211_TX_CTL_NO_PS_BUFFER)) {\n\t\t \n\t\tiwl_sta_modify_sleep_tx_count(priv, sta_id, 1);\n\t}\n\n\tdev_cmd = iwl_trans_alloc_tx_cmd(priv->trans);\n\n\tif (unlikely(!dev_cmd))\n\t\tgoto drop_unlock_priv;\n\n\tdev_cmd->hdr.cmd = REPLY_TX;\n\ttx_cmd = (struct iwl_tx_cmd *) dev_cmd->payload;\n\n\t \n\tlen = (u16)skb->len;\n\ttx_cmd->len = cpu_to_le16(len);\n\n\tif (info->control.hw_key)\n\t\tiwlagn_tx_cmd_build_hwcrypto(priv, info, tx_cmd, skb);\n\n\t \n\tiwlagn_tx_cmd_build_basic(priv, skb, tx_cmd, info, hdr, sta_id);\n\n\tiwlagn_tx_cmd_build_rate(priv, tx_cmd, info, sta, fc);\n\n\tmemset(&info->status, 0, sizeof(info->status));\n\tmemset(info->driver_data, 0, sizeof(info->driver_data));\n\n\tinfo->driver_data[0] = ctx;\n\tinfo->driver_data[1] = dev_cmd;\n\t \n\n\tspin_lock(&priv->sta_lock);\n\n\tif (ieee80211_is_data_qos(fc) && !ieee80211_is_qos_nullfunc(fc)) {\n\t\tu8 *qc = NULL;\n\t\tstruct iwl_tid_data *tid_data;\n\t\tqc = ieee80211_get_qos_ctl(hdr);\n\t\ttid = qc[0] & IEEE80211_QOS_CTL_TID_MASK;\n\t\tif (WARN_ON_ONCE(tid >= IWL_MAX_TID_COUNT))\n\t\t\tgoto drop_unlock_sta;\n\t\ttid_data = &priv->tid_data[sta_id][tid];\n\n\t\t \n\t\tif (info->flags & IEEE80211_TX_CTL_AMPDU &&\n\t\t    tid_data->agg.state != IWL_AGG_ON) {\n\t\t\tIWL_ERR(priv,\n\t\t\t\t\"TX_CTL_AMPDU while not in AGG: Tx flags = 0x%08x, agg.state = %d\\n\",\n\t\t\t\tinfo->flags, tid_data->agg.state);\n\t\t\tIWL_ERR(priv, \"sta_id = %d, tid = %d seq_num = %d\\n\",\n\t\t\t\tsta_id, tid,\n\t\t\t\tIEEE80211_SEQ_TO_SN(tid_data->seq_number));\n\t\t\tgoto drop_unlock_sta;\n\t\t}\n\n\t\t \n\t\tif (WARN_ONCE(tid_data->agg.state != IWL_AGG_ON &&\n\t\t\t      tid_data->agg.state != IWL_AGG_OFF,\n\t\t\t      \"Tx while agg.state = %d\\n\", tid_data->agg.state))\n\t\t\tgoto drop_unlock_sta;\n\n\t\tseq_number = tid_data->seq_number;\n\t\tseq_number &= IEEE80211_SCTL_SEQ;\n\t\thdr->seq_ctrl &= cpu_to_le16(IEEE80211_SCTL_FRAG);\n\t\thdr->seq_ctrl |= cpu_to_le16(seq_number);\n\t\tseq_number += 0x10;\n\n\t\tif (info->flags & IEEE80211_TX_CTL_AMPDU)\n\t\t\tis_agg = true;\n\t\tis_data_qos = true;\n\t}\n\n\t \n\tmemcpy(tx_cmd->hdr, hdr, hdr_len);\n\n\ttxq_id = info->hw_queue;\n\n\tif (is_agg)\n\t\ttxq_id = priv->tid_data[sta_id][tid].agg.txq_id;\n\telse if (info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM) {\n\t\t \n\t\thdr->frame_control |=\n\t\t\tcpu_to_le16(IEEE80211_FCTL_MOREDATA);\n\t}\n\n\tWARN_ON_ONCE(is_agg &&\n\t\t     priv->queue_to_mac80211[txq_id] != info->hw_queue);\n\n\tIWL_DEBUG_TX(priv, \"TX to [%d|%d] Q:%d - seq: 0x%x\\n\", sta_id, tid,\n\t\t     txq_id, seq_number);\n\n\tif (iwl_trans_tx(priv->trans, skb, dev_cmd, txq_id))\n\t\tgoto drop_unlock_sta;\n\n\tif (is_data_qos && !ieee80211_has_morefrags(fc))\n\t\tpriv->tid_data[sta_id][tid].seq_number = seq_number;\n\n\tspin_unlock(&priv->sta_lock);\n\n\t \n\tif (sta_priv && sta_priv->client && !is_agg)\n\t\tatomic_inc(&sta_priv->pending_frames);\n\n\treturn 0;\n\ndrop_unlock_sta:\n\tif (dev_cmd)\n\t\tiwl_trans_free_tx_cmd(priv->trans, dev_cmd);\n\tspin_unlock(&priv->sta_lock);\ndrop_unlock_priv:\n\treturn -1;\n}\n\nstatic int iwlagn_alloc_agg_txq(struct iwl_priv *priv, int mq)\n{\n\tint q;\n\n\tfor (q = IWLAGN_FIRST_AMPDU_QUEUE;\n\t     q < priv->trans->trans_cfg->base_params->num_of_queues; q++) {\n\t\tif (!test_and_set_bit(q, priv->agg_q_alloc)) {\n\t\t\tpriv->queue_to_mac80211[q] = mq;\n\t\t\treturn q;\n\t\t}\n\t}\n\n\treturn -ENOSPC;\n}\n\nstatic void iwlagn_dealloc_agg_txq(struct iwl_priv *priv, int q)\n{\n\tclear_bit(q, priv->agg_q_alloc);\n\tpriv->queue_to_mac80211[q] = IWL_INVALID_MAC80211_QUEUE;\n}\n\nint iwlagn_tx_agg_stop(struct iwl_priv *priv, struct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_sta *sta, u16 tid)\n{\n\tstruct iwl_tid_data *tid_data;\n\tint sta_id, txq_id;\n\tenum iwl_agg_state agg_state;\n\n\tsta_id = iwl_sta_id(sta);\n\n\tif (sta_id == IWL_INVALID_STATION) {\n\t\tIWL_ERR(priv, \"Invalid station for AGG tid %d\\n\", tid);\n\t\treturn -ENXIO;\n\t}\n\n\tspin_lock_bh(&priv->sta_lock);\n\n\ttid_data = &priv->tid_data[sta_id][tid];\n\ttxq_id = tid_data->agg.txq_id;\n\n\tswitch (tid_data->agg.state) {\n\tcase IWL_EMPTYING_HW_QUEUE_ADDBA:\n\t\t \n\t\tIWL_DEBUG_HT(priv, \"AGG stop before setup done\\n\");\n\t\tgoto turn_off;\n\tcase IWL_AGG_STARTING:\n\t\t \n\t\tIWL_DEBUG_HT(priv, \"AGG stop before AGG became operational\\n\");\n\t\tgoto turn_off;\n\tcase IWL_AGG_ON:\n\t\tbreak;\n\tdefault:\n\t\tIWL_WARN(priv,\n\t\t\t \"Stopping AGG while state not ON or starting for %d on %d (%d)\\n\",\n\t\t\t sta_id, tid, tid_data->agg.state);\n\t\tspin_unlock_bh(&priv->sta_lock);\n\t\treturn 0;\n\t}\n\n\ttid_data->agg.ssn = IEEE80211_SEQ_TO_SN(tid_data->seq_number);\n\n\t \n\tif (!test_bit(txq_id, priv->agg_q_alloc)) {\n\t\tIWL_DEBUG_TX_QUEUES(priv,\n\t\t\t\"stopping AGG on STA/TID %d/%d but hwq %d not used\\n\",\n\t\t\tsta_id, tid, txq_id);\n\t} else if (tid_data->agg.ssn != tid_data->next_reclaimed) {\n\t\tIWL_DEBUG_TX_QUEUES(priv,\n\t\t\t\t    \"Can't proceed: ssn %d, next_recl = %d\\n\",\n\t\t\t\t    tid_data->agg.ssn,\n\t\t\t\t    tid_data->next_reclaimed);\n\t\ttid_data->agg.state = IWL_EMPTYING_HW_QUEUE_DELBA;\n\t\tspin_unlock_bh(&priv->sta_lock);\n\t\treturn 0;\n\t}\n\n\tIWL_DEBUG_TX_QUEUES(priv, \"Can proceed: ssn = next_recl = %d\\n\",\n\t\t\t    tid_data->agg.ssn);\nturn_off:\n\tagg_state = tid_data->agg.state;\n\ttid_data->agg.state = IWL_AGG_OFF;\n\n\tspin_unlock_bh(&priv->sta_lock);\n\n\tif (test_bit(txq_id, priv->agg_q_alloc)) {\n\t\t \n\t\tif (agg_state == IWL_AGG_ON)\n\t\t\tiwl_trans_txq_disable(priv->trans, txq_id, true);\n\t\telse\n\t\t\tIWL_DEBUG_TX_QUEUES(priv, \"Don't disable tx agg: %d\\n\",\n\t\t\t\t\t    agg_state);\n\t\tiwlagn_dealloc_agg_txq(priv, txq_id);\n\t}\n\n\tieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\n\treturn 0;\n}\n\nint iwlagn_tx_agg_start(struct iwl_priv *priv, struct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_sta *sta, u16 tid, u16 *ssn)\n{\n\tstruct iwl_rxon_context *ctx = iwl_rxon_ctx_from_vif(vif);\n\tstruct iwl_tid_data *tid_data;\n\tint sta_id, txq_id, ret;\n\n\tIWL_DEBUG_HT(priv, \"TX AGG request on ra = %pM tid = %d\\n\",\n\t\t     sta->addr, tid);\n\n\tsta_id = iwl_sta_id(sta);\n\tif (sta_id == IWL_INVALID_STATION) {\n\t\tIWL_ERR(priv, \"Start AGG on invalid station\\n\");\n\t\treturn -ENXIO;\n\t}\n\tif (unlikely(tid >= IWL_MAX_TID_COUNT))\n\t\treturn -EINVAL;\n\n\tif (priv->tid_data[sta_id][tid].agg.state != IWL_AGG_OFF) {\n\t\tIWL_ERR(priv, \"Start AGG when state is not IWL_AGG_OFF !\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\ttxq_id = iwlagn_alloc_agg_txq(priv, ctx->ac_to_queue[tid_to_ac[tid]]);\n\tif (txq_id < 0) {\n\t\tIWL_DEBUG_TX_QUEUES(priv,\n\t\t\t\"No free aggregation queue for %pM/%d\\n\",\n\t\t\tsta->addr, tid);\n\t\treturn txq_id;\n\t}\n\n\tret = iwl_sta_tx_modify_enable_tid(priv, sta_id, tid);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_bh(&priv->sta_lock);\n\ttid_data = &priv->tid_data[sta_id][tid];\n\ttid_data->agg.ssn = IEEE80211_SEQ_TO_SN(tid_data->seq_number);\n\ttid_data->agg.txq_id = txq_id;\n\n\t*ssn = tid_data->agg.ssn;\n\n\tif (*ssn == tid_data->next_reclaimed) {\n\t\tIWL_DEBUG_TX_QUEUES(priv, \"Can proceed: ssn = next_recl = %d\\n\",\n\t\t\t\t    tid_data->agg.ssn);\n\t\ttid_data->agg.state = IWL_AGG_STARTING;\n\t\tret = IEEE80211_AMPDU_TX_START_IMMEDIATE;\n\t} else {\n\t\tIWL_DEBUG_TX_QUEUES(priv, \"Can't proceed: ssn %d, \"\n\t\t\t\t    \"next_reclaimed = %d\\n\",\n\t\t\t\t    tid_data->agg.ssn,\n\t\t\t\t    tid_data->next_reclaimed);\n\t\ttid_data->agg.state = IWL_EMPTYING_HW_QUEUE_ADDBA;\n\t}\n\tspin_unlock_bh(&priv->sta_lock);\n\n\treturn ret;\n}\n\nint iwlagn_tx_agg_flush(struct iwl_priv *priv, struct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_sta *sta, u16 tid)\n{\n\tstruct iwl_tid_data *tid_data;\n\tenum iwl_agg_state agg_state;\n\tint sta_id, txq_id;\n\tsta_id = iwl_sta_id(sta);\n\n\t \n\tspin_lock_bh(&priv->sta_lock);\n\n\ttid_data = &priv->tid_data[sta_id][tid];\n\ttxq_id = tid_data->agg.txq_id;\n\tagg_state = tid_data->agg.state;\n\tIWL_DEBUG_TX_QUEUES(priv, \"Flush AGG: sta %d tid %d q %d state %d\\n\",\n\t\t\t    sta_id, tid, txq_id, tid_data->agg.state);\n\n\ttid_data->agg.state = IWL_AGG_OFF;\n\n\tspin_unlock_bh(&priv->sta_lock);\n\n\tif (iwlagn_txfifo_flush(priv, BIT(txq_id)))\n\t\tIWL_ERR(priv, \"Couldn't flush the AGG queue\\n\");\n\n\tif (test_bit(txq_id, priv->agg_q_alloc)) {\n\t\t \n\t\tif (agg_state == IWL_AGG_ON)\n\t\t\tiwl_trans_txq_disable(priv->trans, txq_id, true);\n\t\telse\n\t\t\tIWL_DEBUG_TX_QUEUES(priv, \"Don't disable tx agg: %d\\n\",\n\t\t\t\t\t    agg_state);\n\t\tiwlagn_dealloc_agg_txq(priv, txq_id);\n\t}\n\n\treturn 0;\n}\n\nint iwlagn_tx_agg_oper(struct iwl_priv *priv, struct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_sta *sta, u16 tid, u8 buf_size)\n{\n\tstruct iwl_station_priv *sta_priv = (void *) sta->drv_priv;\n\tstruct iwl_rxon_context *ctx = iwl_rxon_ctx_from_vif(vif);\n\tint q, fifo;\n\tu16 ssn;\n\n\tbuf_size = min_t(int, buf_size, LINK_QUAL_AGG_FRAME_LIMIT_DEF);\n\n\tspin_lock_bh(&priv->sta_lock);\n\tssn = priv->tid_data[sta_priv->sta_id][tid].agg.ssn;\n\tq = priv->tid_data[sta_priv->sta_id][tid].agg.txq_id;\n\tpriv->tid_data[sta_priv->sta_id][tid].agg.state = IWL_AGG_ON;\n\tspin_unlock_bh(&priv->sta_lock);\n\n\tfifo = ctx->ac_to_fifo[tid_to_ac[tid]];\n\n\tiwl_trans_txq_enable(priv->trans, q, fifo, sta_priv->sta_id, tid,\n\t\t\t     buf_size, ssn, 0);\n\n\t \n\tif (sta_priv->max_agg_bufsize == 0)\n\t\tsta_priv->max_agg_bufsize =\n\t\t\tLINK_QUAL_AGG_FRAME_LIMIT_DEF;\n\n\t \n\tsta_priv->max_agg_bufsize =\n\t\tmin(sta_priv->max_agg_bufsize, buf_size);\n\n\tif (priv->hw_params.use_rts_for_aggregation) {\n\t\t \n\n\t\tsta_priv->lq_sta.lq.general_params.flags |=\n\t\t\tLINK_QUAL_FLAGS_SET_STA_TLC_RTS_MSK;\n\t}\n\tpriv->agg_tids_count++;\n\tIWL_DEBUG_HT(priv, \"priv->agg_tids_count = %u\\n\",\n\t\t     priv->agg_tids_count);\n\n\tsta_priv->lq_sta.lq.agg_params.agg_frame_cnt_limit =\n\t\tsta_priv->max_agg_bufsize;\n\n\tIWL_DEBUG_HT(priv, \"Tx aggregation enabled on ra = %pM tid = %d\\n\",\n\t\t sta->addr, tid);\n\n\treturn iwl_send_lq_cmd(priv, ctx,\n\t\t\t&sta_priv->lq_sta.lq, CMD_ASYNC, false);\n}\n\nstatic void iwlagn_check_ratid_empty(struct iwl_priv *priv, int sta_id, u8 tid)\n{\n\tstruct iwl_tid_data *tid_data = &priv->tid_data[sta_id][tid];\n\tenum iwl_rxon_context_id ctx;\n\tstruct ieee80211_vif *vif;\n\tu8 *addr;\n\n\tlockdep_assert_held(&priv->sta_lock);\n\n\taddr = priv->stations[sta_id].sta.sta.addr;\n\tctx = priv->stations[sta_id].ctxid;\n\tvif = priv->contexts[ctx].vif;\n\n\tswitch (priv->tid_data[sta_id][tid].agg.state) {\n\tcase IWL_EMPTYING_HW_QUEUE_DELBA:\n\t\t \n\t\tif (tid_data->agg.ssn == tid_data->next_reclaimed) {\n\t\t\tIWL_DEBUG_TX_QUEUES(priv,\n\t\t\t\t\"Can continue DELBA flow ssn = next_recl = %d\\n\",\n\t\t\t\ttid_data->next_reclaimed);\n\t\t\tiwl_trans_txq_disable(priv->trans,\n\t\t\t\t\t      tid_data->agg.txq_id, true);\n\t\t\tiwlagn_dealloc_agg_txq(priv, tid_data->agg.txq_id);\n\t\t\ttid_data->agg.state = IWL_AGG_OFF;\n\t\t\tieee80211_stop_tx_ba_cb_irqsafe(vif, addr, tid);\n\t\t}\n\t\tbreak;\n\tcase IWL_EMPTYING_HW_QUEUE_ADDBA:\n\t\t \n\t\tif (tid_data->agg.ssn == tid_data->next_reclaimed) {\n\t\t\tIWL_DEBUG_TX_QUEUES(priv,\n\t\t\t\t\"Can continue ADDBA flow ssn = next_recl = %d\\n\",\n\t\t\t\ttid_data->next_reclaimed);\n\t\t\ttid_data->agg.state = IWL_AGG_STARTING;\n\t\t\tieee80211_start_tx_ba_cb_irqsafe(vif, addr, tid);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void iwlagn_non_agg_tx_status(struct iwl_priv *priv,\n\t\t\t\t     struct iwl_rxon_context *ctx,\n\t\t\t\t     const u8 *addr1)\n{\n\tstruct ieee80211_sta *sta;\n\tstruct iwl_station_priv *sta_priv;\n\n\trcu_read_lock();\n\tsta = ieee80211_find_sta(ctx->vif, addr1);\n\tif (sta) {\n\t\tsta_priv = (void *)sta->drv_priv;\n\t\t \n\t\tif (sta_priv->client &&\n\t\t    atomic_dec_return(&sta_priv->pending_frames) == 0)\n\t\t\tieee80211_sta_block_awake(priv->hw, sta, false);\n\t}\n\trcu_read_unlock();\n}\n\n \nstatic void iwlagn_hwrate_to_tx_control(struct iwl_priv *priv, u32 rate_n_flags,\n\t\t\t\t  struct ieee80211_tx_info *info)\n{\n\tstruct ieee80211_tx_rate *r = &info->status.rates[0];\n\n\tinfo->status.antenna =\n\t\t((rate_n_flags & RATE_MCS_ANT_ABC_MSK) >> RATE_MCS_ANT_POS);\n\tif (rate_n_flags & RATE_MCS_HT_MSK)\n\t\tr->flags |= IEEE80211_TX_RC_MCS;\n\tif (rate_n_flags & RATE_MCS_GF_MSK)\n\t\tr->flags |= IEEE80211_TX_RC_GREEN_FIELD;\n\tif (rate_n_flags & RATE_MCS_HT40_MSK)\n\t\tr->flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\n\tif (rate_n_flags & RATE_MCS_DUP_MSK)\n\t\tr->flags |= IEEE80211_TX_RC_DUP_DATA;\n\tif (rate_n_flags & RATE_MCS_SGI_MSK)\n\t\tr->flags |= IEEE80211_TX_RC_SHORT_GI;\n\tr->idx = iwlagn_hwrate_to_mac80211_idx(rate_n_flags, info->band);\n}\n\n#ifdef CONFIG_IWLWIFI_DEBUG\nconst char *iwl_get_tx_fail_reason(u32 status)\n{\n#define TX_STATUS_FAIL(x) case TX_STATUS_FAIL_ ## x: return #x\n#define TX_STATUS_POSTPONE(x) case TX_STATUS_POSTPONE_ ## x: return #x\n\n\tswitch (status & TX_STATUS_MSK) {\n\tcase TX_STATUS_SUCCESS:\n\t\treturn \"SUCCESS\";\n\tTX_STATUS_POSTPONE(DELAY);\n\tTX_STATUS_POSTPONE(FEW_BYTES);\n\tTX_STATUS_POSTPONE(BT_PRIO);\n\tTX_STATUS_POSTPONE(QUIET_PERIOD);\n\tTX_STATUS_POSTPONE(CALC_TTAK);\n\tTX_STATUS_FAIL(INTERNAL_CROSSED_RETRY);\n\tTX_STATUS_FAIL(SHORT_LIMIT);\n\tTX_STATUS_FAIL(LONG_LIMIT);\n\tTX_STATUS_FAIL(FIFO_UNDERRUN);\n\tTX_STATUS_FAIL(DRAIN_FLOW);\n\tTX_STATUS_FAIL(RFKILL_FLUSH);\n\tTX_STATUS_FAIL(LIFE_EXPIRE);\n\tTX_STATUS_FAIL(DEST_PS);\n\tTX_STATUS_FAIL(HOST_ABORTED);\n\tTX_STATUS_FAIL(BT_RETRY);\n\tTX_STATUS_FAIL(STA_INVALID);\n\tTX_STATUS_FAIL(FRAG_DROPPED);\n\tTX_STATUS_FAIL(TID_DISABLE);\n\tTX_STATUS_FAIL(FIFO_FLUSHED);\n\tTX_STATUS_FAIL(INSUFFICIENT_CF_POLL);\n\tTX_STATUS_FAIL(PASSIVE_NO_RX);\n\tTX_STATUS_FAIL(NO_BEACON_ON_RADAR);\n\t}\n\n\treturn \"UNKNOWN\";\n\n#undef TX_STATUS_FAIL\n#undef TX_STATUS_POSTPONE\n}\n#endif  \n\nstatic void iwlagn_count_agg_tx_err_status(struct iwl_priv *priv, u16 status)\n{\n\tstatus &= AGG_TX_STATUS_MSK;\n\n\tswitch (status) {\n\tcase AGG_TX_STATE_UNDERRUN_MSK:\n\t\tpriv->reply_agg_tx_stats.underrun++;\n\t\tbreak;\n\tcase AGG_TX_STATE_BT_PRIO_MSK:\n\t\tpriv->reply_agg_tx_stats.bt_prio++;\n\t\tbreak;\n\tcase AGG_TX_STATE_FEW_BYTES_MSK:\n\t\tpriv->reply_agg_tx_stats.few_bytes++;\n\t\tbreak;\n\tcase AGG_TX_STATE_ABORT_MSK:\n\t\tpriv->reply_agg_tx_stats.abort++;\n\t\tbreak;\n\tcase AGG_TX_STATE_LAST_SENT_TTL_MSK:\n\t\tpriv->reply_agg_tx_stats.last_sent_ttl++;\n\t\tbreak;\n\tcase AGG_TX_STATE_LAST_SENT_TRY_CNT_MSK:\n\t\tpriv->reply_agg_tx_stats.last_sent_try++;\n\t\tbreak;\n\tcase AGG_TX_STATE_LAST_SENT_BT_KILL_MSK:\n\t\tpriv->reply_agg_tx_stats.last_sent_bt_kill++;\n\t\tbreak;\n\tcase AGG_TX_STATE_SCD_QUERY_MSK:\n\t\tpriv->reply_agg_tx_stats.scd_query++;\n\t\tbreak;\n\tcase AGG_TX_STATE_TEST_BAD_CRC32_MSK:\n\t\tpriv->reply_agg_tx_stats.bad_crc32++;\n\t\tbreak;\n\tcase AGG_TX_STATE_RESPONSE_MSK:\n\t\tpriv->reply_agg_tx_stats.response++;\n\t\tbreak;\n\tcase AGG_TX_STATE_DUMP_TX_MSK:\n\t\tpriv->reply_agg_tx_stats.dump_tx++;\n\t\tbreak;\n\tcase AGG_TX_STATE_DELAY_TX_MSK:\n\t\tpriv->reply_agg_tx_stats.delay_tx++;\n\t\tbreak;\n\tdefault:\n\t\tpriv->reply_agg_tx_stats.unknown++;\n\t\tbreak;\n\t}\n}\n\nstatic inline u32 iwlagn_get_scd_ssn(struct iwlagn_tx_resp *tx_resp)\n{\n\treturn le32_to_cpup((__le32 *)&tx_resp->status +\n\t\t\t    tx_resp->frame_count) & IEEE80211_MAX_SN;\n}\n\nstatic void iwl_rx_reply_tx_agg(struct iwl_priv *priv,\n\t\t\t\tstruct iwlagn_tx_resp *tx_resp)\n{\n\tstruct agg_tx_status *frame_status = &tx_resp->status;\n\tint tid = (tx_resp->ra_tid & IWLAGN_TX_RES_TID_MSK) >>\n\t\tIWLAGN_TX_RES_TID_POS;\n\tint sta_id = (tx_resp->ra_tid & IWLAGN_TX_RES_RA_MSK) >>\n\t\tIWLAGN_TX_RES_RA_POS;\n\tstruct iwl_ht_agg *agg = &priv->tid_data[sta_id][tid].agg;\n\tu32 status = le16_to_cpu(tx_resp->status.status);\n\tint i;\n\n\tWARN_ON(tid == IWL_TID_NON_QOS);\n\n\tif (agg->wait_for_ba)\n\t\tIWL_DEBUG_TX_REPLY(priv,\n\t\t\t\"got tx response w/o block-ack\\n\");\n\n\tagg->rate_n_flags = le32_to_cpu(tx_resp->rate_n_flags);\n\tagg->wait_for_ba = (tx_resp->frame_count > 1);\n\n\t \n\tif (tx_resp->bt_kill_count && tx_resp->frame_count == 1 &&\n\t    priv->lib->bt_params &&\n\t    priv->lib->bt_params->advanced_bt_coexist) {\n\t\tIWL_DEBUG_COEX(priv, \"receive reply tx w/ bt_kill\\n\");\n\t}\n\n\tif (tx_resp->frame_count == 1)\n\t\treturn;\n\n\tIWL_DEBUG_TX_REPLY(priv, \"TXQ %d initial_rate 0x%x ssn %d frm_cnt %d\\n\",\n\t\t\t   agg->txq_id,\n\t\t\t   le32_to_cpu(tx_resp->rate_n_flags),\n\t\t\t   iwlagn_get_scd_ssn(tx_resp), tx_resp->frame_count);\n\n\t \n\tfor (i = 0; i < tx_resp->frame_count; i++) {\n\t\tu16 fstatus = le16_to_cpu(frame_status[i].status);\n\t\tu8 retry_cnt = (fstatus & AGG_TX_TRY_MSK) >> AGG_TX_TRY_POS;\n\n\t\tif (status & AGG_TX_STATUS_MSK)\n\t\t\tiwlagn_count_agg_tx_err_status(priv, fstatus);\n\n\t\tif (status & (AGG_TX_STATE_FEW_BYTES_MSK |\n\t\t\t      AGG_TX_STATE_ABORT_MSK))\n\t\t\tcontinue;\n\n\t\tif (status & AGG_TX_STATUS_MSK || retry_cnt > 1)\n\t\t\tIWL_DEBUG_TX_REPLY(priv,\n\t\t\t\t\t   \"%d: status %s (0x%04x), try-count (0x%01x)\\n\",\n\t\t\t\t\t   i,\n\t\t\t\t\t   iwl_get_agg_tx_fail_reason(fstatus),\n\t\t\t\t\t   fstatus & AGG_TX_STATUS_MSK,\n\t\t\t\t\t   retry_cnt);\n\t}\n}\n\n#ifdef CONFIG_IWLWIFI_DEBUG\n#define AGG_TX_STATE_FAIL(x) case AGG_TX_STATE_ ## x: return #x\n\nconst char *iwl_get_agg_tx_fail_reason(u16 status)\n{\n\tstatus &= AGG_TX_STATUS_MSK;\n\tswitch (status) {\n\tcase AGG_TX_STATE_TRANSMITTED:\n\t\treturn \"SUCCESS\";\n\t\tAGG_TX_STATE_FAIL(UNDERRUN_MSK);\n\t\tAGG_TX_STATE_FAIL(BT_PRIO_MSK);\n\t\tAGG_TX_STATE_FAIL(FEW_BYTES_MSK);\n\t\tAGG_TX_STATE_FAIL(ABORT_MSK);\n\t\tAGG_TX_STATE_FAIL(LAST_SENT_TTL_MSK);\n\t\tAGG_TX_STATE_FAIL(LAST_SENT_TRY_CNT_MSK);\n\t\tAGG_TX_STATE_FAIL(LAST_SENT_BT_KILL_MSK);\n\t\tAGG_TX_STATE_FAIL(SCD_QUERY_MSK);\n\t\tAGG_TX_STATE_FAIL(TEST_BAD_CRC32_MSK);\n\t\tAGG_TX_STATE_FAIL(RESPONSE_MSK);\n\t\tAGG_TX_STATE_FAIL(DUMP_TX_MSK);\n\t\tAGG_TX_STATE_FAIL(DELAY_TX_MSK);\n\t}\n\n\treturn \"UNKNOWN\";\n}\n#endif  \n\nstatic void iwlagn_count_tx_err_status(struct iwl_priv *priv, u16 status)\n{\n\tstatus &= TX_STATUS_MSK;\n\n\tswitch (status) {\n\tcase TX_STATUS_POSTPONE_DELAY:\n\t\tpriv->reply_tx_stats.pp_delay++;\n\t\tbreak;\n\tcase TX_STATUS_POSTPONE_FEW_BYTES:\n\t\tpriv->reply_tx_stats.pp_few_bytes++;\n\t\tbreak;\n\tcase TX_STATUS_POSTPONE_BT_PRIO:\n\t\tpriv->reply_tx_stats.pp_bt_prio++;\n\t\tbreak;\n\tcase TX_STATUS_POSTPONE_QUIET_PERIOD:\n\t\tpriv->reply_tx_stats.pp_quiet_period++;\n\t\tbreak;\n\tcase TX_STATUS_POSTPONE_CALC_TTAK:\n\t\tpriv->reply_tx_stats.pp_calc_ttak++;\n\t\tbreak;\n\tcase TX_STATUS_FAIL_INTERNAL_CROSSED_RETRY:\n\t\tpriv->reply_tx_stats.int_crossed_retry++;\n\t\tbreak;\n\tcase TX_STATUS_FAIL_SHORT_LIMIT:\n\t\tpriv->reply_tx_stats.short_limit++;\n\t\tbreak;\n\tcase TX_STATUS_FAIL_LONG_LIMIT:\n\t\tpriv->reply_tx_stats.long_limit++;\n\t\tbreak;\n\tcase TX_STATUS_FAIL_FIFO_UNDERRUN:\n\t\tpriv->reply_tx_stats.fifo_underrun++;\n\t\tbreak;\n\tcase TX_STATUS_FAIL_DRAIN_FLOW:\n\t\tpriv->reply_tx_stats.drain_flow++;\n\t\tbreak;\n\tcase TX_STATUS_FAIL_RFKILL_FLUSH:\n\t\tpriv->reply_tx_stats.rfkill_flush++;\n\t\tbreak;\n\tcase TX_STATUS_FAIL_LIFE_EXPIRE:\n\t\tpriv->reply_tx_stats.life_expire++;\n\t\tbreak;\n\tcase TX_STATUS_FAIL_DEST_PS:\n\t\tpriv->reply_tx_stats.dest_ps++;\n\t\tbreak;\n\tcase TX_STATUS_FAIL_HOST_ABORTED:\n\t\tpriv->reply_tx_stats.host_abort++;\n\t\tbreak;\n\tcase TX_STATUS_FAIL_BT_RETRY:\n\t\tpriv->reply_tx_stats.bt_retry++;\n\t\tbreak;\n\tcase TX_STATUS_FAIL_STA_INVALID:\n\t\tpriv->reply_tx_stats.sta_invalid++;\n\t\tbreak;\n\tcase TX_STATUS_FAIL_FRAG_DROPPED:\n\t\tpriv->reply_tx_stats.frag_drop++;\n\t\tbreak;\n\tcase TX_STATUS_FAIL_TID_DISABLE:\n\t\tpriv->reply_tx_stats.tid_disable++;\n\t\tbreak;\n\tcase TX_STATUS_FAIL_FIFO_FLUSHED:\n\t\tpriv->reply_tx_stats.fifo_flush++;\n\t\tbreak;\n\tcase TX_STATUS_FAIL_INSUFFICIENT_CF_POLL:\n\t\tpriv->reply_tx_stats.insuff_cf_poll++;\n\t\tbreak;\n\tcase TX_STATUS_FAIL_PASSIVE_NO_RX:\n\t\tpriv->reply_tx_stats.fail_hw_drop++;\n\t\tbreak;\n\tcase TX_STATUS_FAIL_NO_BEACON_ON_RADAR:\n\t\tpriv->reply_tx_stats.sta_color_mismatch++;\n\t\tbreak;\n\tdefault:\n\t\tpriv->reply_tx_stats.unknown++;\n\t\tbreak;\n\t}\n}\n\nstatic void iwlagn_set_tx_status(struct iwl_priv *priv,\n\t\t\t\t struct ieee80211_tx_info *info,\n\t\t\t\t struct iwlagn_tx_resp *tx_resp)\n{\n\tu16 status = le16_to_cpu(tx_resp->status.status);\n\n\tinfo->flags &= ~IEEE80211_TX_CTL_AMPDU;\n\n\tinfo->status.rates[0].count = tx_resp->failure_frame + 1;\n\tinfo->flags |= iwl_tx_status_to_mac80211(status);\n\tiwlagn_hwrate_to_tx_control(priv, le32_to_cpu(tx_resp->rate_n_flags),\n\t\t\t\t    info);\n\tif (!iwl_is_tx_success(status))\n\t\tiwlagn_count_tx_err_status(priv, status);\n}\n\nstatic void iwl_check_abort_status(struct iwl_priv *priv,\n\t\t\t    u8 frame_count, u32 status)\n{\n\tif (frame_count == 1 && status == TX_STATUS_FAIL_RFKILL_FLUSH) {\n\t\tIWL_ERR(priv, \"Tx flush command to flush out all frames\\n\");\n\t\tif (!test_bit(STATUS_EXIT_PENDING, &priv->status))\n\t\t\tqueue_work(priv->workqueue, &priv->tx_flush);\n\t}\n}\n\nvoid iwlagn_rx_reply_tx(struct iwl_priv *priv, struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tu16 sequence = le16_to_cpu(pkt->hdr.sequence);\n\tint txq_id = SEQ_TO_QUEUE(sequence);\n\tint cmd_index __maybe_unused = SEQ_TO_INDEX(sequence);\n\tstruct iwlagn_tx_resp *tx_resp = (void *)pkt->data;\n\tstruct ieee80211_hdr *hdr;\n\tu32 status = le16_to_cpu(tx_resp->status.status);\n\tu16 ssn = iwlagn_get_scd_ssn(tx_resp);\n\tint tid;\n\tint sta_id;\n\tint freed;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff_head skbs;\n\tstruct sk_buff *skb;\n\tstruct iwl_rxon_context *ctx;\n\tbool is_agg = (txq_id >= IWLAGN_FIRST_AMPDU_QUEUE);\n\n\ttid = (tx_resp->ra_tid & IWLAGN_TX_RES_TID_MSK) >>\n\t\tIWLAGN_TX_RES_TID_POS;\n\tsta_id = (tx_resp->ra_tid & IWLAGN_TX_RES_RA_MSK) >>\n\t\tIWLAGN_TX_RES_RA_POS;\n\n\tspin_lock_bh(&priv->sta_lock);\n\n\tif (is_agg) {\n\t\tWARN_ON_ONCE(sta_id >= IWLAGN_STATION_COUNT ||\n\t\t\t     tid >= IWL_MAX_TID_COUNT);\n\t\tif (txq_id != priv->tid_data[sta_id][tid].agg.txq_id)\n\t\t\tIWL_ERR(priv, \"txq_id mismatch: %d %d\\n\", txq_id,\n\t\t\t\tpriv->tid_data[sta_id][tid].agg.txq_id);\n\t\tiwl_rx_reply_tx_agg(priv, tx_resp);\n\t}\n\n\t__skb_queue_head_init(&skbs);\n\n\tif (tx_resp->frame_count == 1) {\n\t\tu16 next_reclaimed = le16_to_cpu(tx_resp->seq_ctl);\n\t\tnext_reclaimed = IEEE80211_SEQ_TO_SN(next_reclaimed + 0x10);\n\n\t\tif (is_agg) {\n\t\t\t \n\t\t\tnext_reclaimed = ssn;\n\t\t}\n\n\t\tif (tid != IWL_TID_NON_QOS) {\n\t\t\tpriv->tid_data[sta_id][tid].next_reclaimed =\n\t\t\t\tnext_reclaimed;\n\t\t\tIWL_DEBUG_TX_REPLY(priv, \"Next reclaimed packet:%d\\n\",\n\t\t\t\t\t\t  next_reclaimed);\n\t\t\tiwlagn_check_ratid_empty(priv, sta_id, tid);\n\t\t}\n\n\t\tiwl_trans_reclaim(priv->trans, txq_id, ssn, &skbs, false);\n\n\t\tfreed = 0;\n\n\t\t \n\t\tskb_queue_walk(&skbs, skb) {\n\t\t\thdr = (struct ieee80211_hdr *)skb->data;\n\n\t\t\tif (!ieee80211_is_data_qos(hdr->frame_control))\n\t\t\t\tpriv->last_seq_ctl = tx_resp->seq_ctl;\n\n\t\t\tinfo = IEEE80211_SKB_CB(skb);\n\t\t\tctx = info->driver_data[0];\n\t\t\tiwl_trans_free_tx_cmd(priv->trans,\n\t\t\t\t\t      info->driver_data[1]);\n\n\t\t\tmemset(&info->status, 0, sizeof(info->status));\n\n\t\t\tif (status == TX_STATUS_FAIL_PASSIVE_NO_RX &&\n\t\t\t    ctx->vif &&\n\t\t\t    ctx->vif->type == NL80211_IFTYPE_STATION) {\n\t\t\t\t \n\t\t\t\tpriv->passive_no_rx = true;\n\t\t\t\tIWL_DEBUG_TX_QUEUES(priv,\n\t\t\t\t\t\"stop all queues: passive channel\\n\");\n\t\t\t\tieee80211_stop_queues(priv->hw);\n\n\t\t\t\tIWL_DEBUG_TX_REPLY(priv,\n\t\t\t\t\t   \"TXQ %d status %s (0x%08x) \"\n\t\t\t\t\t   \"rate_n_flags 0x%x retries %d\\n\",\n\t\t\t\t\t   txq_id,\n\t\t\t\t\t   iwl_get_tx_fail_reason(status),\n\t\t\t\t\t   status,\n\t\t\t\t\t   le32_to_cpu(tx_resp->rate_n_flags),\n\t\t\t\t\t   tx_resp->failure_frame);\n\n\t\t\t\tIWL_DEBUG_TX_REPLY(priv,\n\t\t\t\t\t   \"FrameCnt = %d, idx=%d\\n\",\n\t\t\t\t\t   tx_resp->frame_count, cmd_index);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (is_agg && !iwl_is_tx_success(status))\n\t\t\t\tinfo->flags |= IEEE80211_TX_STAT_AMPDU_NO_BACK;\n\t\t\tiwlagn_set_tx_status(priv, IEEE80211_SKB_CB(skb),\n\t\t\t\t     tx_resp);\n\t\t\tif (!is_agg)\n\t\t\t\tiwlagn_non_agg_tx_status(priv, ctx, hdr->addr1);\n\n\t\t\tfreed++;\n\t\t}\n\n\t\tif (tid != IWL_TID_NON_QOS) {\n\t\t\tpriv->tid_data[sta_id][tid].next_reclaimed =\n\t\t\t\tnext_reclaimed;\n\t\t\tIWL_DEBUG_TX_REPLY(priv, \"Next reclaimed packet:%d\\n\",\n\t\t\t\t\t   next_reclaimed);\n\t\t}\n\n\t\tif (!is_agg && freed != 1)\n\t\t\tIWL_ERR(priv, \"Q: %d, freed %d\\n\", txq_id, freed);\n\n\t\tIWL_DEBUG_TX_REPLY(priv, \"TXQ %d status %s (0x%08x)\\n\", txq_id,\n\t\t\t\t   iwl_get_tx_fail_reason(status), status);\n\n\t\tIWL_DEBUG_TX_REPLY(priv,\n\t\t\t\t   \"\\t\\t\\t\\tinitial_rate 0x%x retries %d, idx=%d ssn=%d seq_ctl=0x%x\\n\",\n\t\t\t\t   le32_to_cpu(tx_resp->rate_n_flags),\n\t\t\t\t   tx_resp->failure_frame,\n\t\t\t\t   SEQ_TO_INDEX(sequence), ssn,\n\t\t\t\t   le16_to_cpu(tx_resp->seq_ctl));\n\t}\n\n\tiwl_check_abort_status(priv, tx_resp->frame_count, status);\n\tspin_unlock_bh(&priv->sta_lock);\n\n\twhile (!skb_queue_empty(&skbs)) {\n\t\tskb = __skb_dequeue(&skbs);\n\t\tieee80211_tx_status(priv->hw, skb);\n\t}\n}\n\n \nvoid iwlagn_rx_reply_compressed_ba(struct iwl_priv *priv,\n\t\t\t\t   struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_compressed_ba_resp *ba_resp = (void *)pkt->data;\n\tstruct iwl_ht_agg *agg;\n\tstruct sk_buff_head reclaimed_skbs;\n\tstruct sk_buff *skb;\n\tint sta_id;\n\tint tid;\n\tint freed;\n\n\t \n\tu16 scd_flow = le16_to_cpu(ba_resp->scd_flow);\n\n\t \n\tu16 ba_resp_scd_ssn = le16_to_cpu(ba_resp->scd_ssn);\n\n\tif (scd_flow >= priv->trans->trans_cfg->base_params->num_of_queues) {\n\t\tIWL_ERR(priv,\n\t\t\t\"BUG_ON scd_flow is bigger than number of queues\\n\");\n\t\treturn;\n\t}\n\n\tsta_id = ba_resp->sta_id;\n\ttid = ba_resp->tid;\n\tagg = &priv->tid_data[sta_id][tid].agg;\n\n\tspin_lock_bh(&priv->sta_lock);\n\n\tif (unlikely(!agg->wait_for_ba)) {\n\t\tif (unlikely(ba_resp->bitmap))\n\t\t\tIWL_ERR(priv, \"Received BA when not expected\\n\");\n\t\tspin_unlock_bh(&priv->sta_lock);\n\t\treturn;\n\t}\n\n\tif (unlikely(scd_flow != agg->txq_id)) {\n\t\t \n\t\tIWL_DEBUG_TX_QUEUES(priv,\n\t\t\t\t    \"Bad queue mapping txq_id=%d, agg_txq[sta:%d,tid:%d]=%d\\n\",\n\t\t\t\t    scd_flow, sta_id, tid, agg->txq_id);\n\t\tspin_unlock_bh(&priv->sta_lock);\n\t\treturn;\n\t}\n\n\t__skb_queue_head_init(&reclaimed_skbs);\n\n\t \n\tiwl_trans_reclaim(priv->trans, scd_flow, ba_resp_scd_ssn,\n\t\t\t  &reclaimed_skbs, false);\n\n\tIWL_DEBUG_TX_REPLY(priv, \"REPLY_COMPRESSED_BA [%d] Received from %pM, \"\n\t\t\t   \"sta_id = %d\\n\",\n\t\t\t   agg->wait_for_ba,\n\t\t\t   (u8 *) &ba_resp->sta_addr_lo32,\n\t\t\t   ba_resp->sta_id);\n\tIWL_DEBUG_TX_REPLY(priv, \"TID = %d, SeqCtl = %d, bitmap = 0x%llx, \"\n\t\t\t   \"scd_flow = %d, scd_ssn = %d sent:%d, acked:%d\\n\",\n\t\t\t   ba_resp->tid, le16_to_cpu(ba_resp->seq_ctl),\n\t\t\t   (unsigned long long)le64_to_cpu(ba_resp->bitmap),\n\t\t\t   scd_flow, ba_resp_scd_ssn, ba_resp->txed,\n\t\t\t   ba_resp->txed_2_done);\n\n\t \n\tagg->wait_for_ba = false;\n\n\t \n\tif (ba_resp->txed_2_done > ba_resp->txed) {\n\t\tIWL_DEBUG_TX_REPLY(priv,\n\t\t\t\"bogus sent(%d) and ack(%d) count\\n\",\n\t\t\tba_resp->txed, ba_resp->txed_2_done);\n\t\t \n\t\tba_resp->txed = ba_resp->txed_2_done;\n\t}\n\n\tpriv->tid_data[sta_id][tid].next_reclaimed = ba_resp_scd_ssn;\n\n\tiwlagn_check_ratid_empty(priv, sta_id, tid);\n\tfreed = 0;\n\n\tskb_queue_walk(&reclaimed_skbs, skb) {\n\t\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\n\t\tif (ieee80211_is_data_qos(hdr->frame_control))\n\t\t\tfreed++;\n\t\telse\n\t\t\tWARN_ON_ONCE(1);\n\n\t\tiwl_trans_free_tx_cmd(priv->trans, info->driver_data[1]);\n\n\t\tmemset(&info->status, 0, sizeof(info->status));\n\t\t \n\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\n\t\tif (freed == 1) {\n\t\t\t \n\t\t\t \n\t\t\tinfo = IEEE80211_SKB_CB(skb);\n\t\t\tmemset(&info->status, 0, sizeof(info->status));\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_AMPDU;\n\t\t\tinfo->status.ampdu_ack_len = ba_resp->txed_2_done;\n\t\t\tinfo->status.ampdu_len = ba_resp->txed;\n\t\t\tiwlagn_hwrate_to_tx_control(priv, agg->rate_n_flags,\n\t\t\t\t\t\t    info);\n\t\t}\n\t}\n\n\tspin_unlock_bh(&priv->sta_lock);\n\n\twhile (!skb_queue_empty(&reclaimed_skbs)) {\n\t\tskb = __skb_dequeue(&reclaimed_skbs);\n\t\tieee80211_tx_status(priv->hw, skb);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}