{
  "module_name": "rs.c",
  "hash_id": "8424412e3f0e0df9903f950554a2bad9e3bf68e2dc37d8b42cc8cae57b95122d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/dvm/rs.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <net/mac80211.h>\n\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/delay.h>\n\n#include <linux/workqueue.h>\n\n#include \"dev.h\"\n#include \"agn.h\"\n\n#define RS_NAME \"iwl-agn-rs\"\n\n#define NUM_TRY_BEFORE_ANT_TOGGLE 1\n#define IWL_NUMBER_TRY      1\n#define IWL_HT_NUMBER_TRY   3\n\n#define IWL_RATE_MAX_WINDOW\t\t62\t \n#define IWL_RATE_MIN_FAILURE_TH\t\t6\t \n#define IWL_RATE_MIN_SUCCESS_TH\t\t8\t \n\n \n#define IWL_MISSED_RATE_MAX\t\t15\n \n#define IWL_RATE_SCALE_FLUSH_INTVL   (3*HZ)\n\nstatic u8 rs_ht_to_legacy[] = {\n\tIWL_RATE_6M_INDEX, IWL_RATE_6M_INDEX,\n\tIWL_RATE_6M_INDEX, IWL_RATE_6M_INDEX,\n\tIWL_RATE_6M_INDEX,\n\tIWL_RATE_6M_INDEX, IWL_RATE_9M_INDEX,\n\tIWL_RATE_12M_INDEX, IWL_RATE_18M_INDEX,\n\tIWL_RATE_24M_INDEX, IWL_RATE_36M_INDEX,\n\tIWL_RATE_48M_INDEX, IWL_RATE_54M_INDEX\n};\n\nstatic const u8 ant_toggle_lookup[] = {\n\t  ANT_NONE,\n\t  ANT_B,\n\t  ANT_C,\n\t  ANT_BC,\n\t  ANT_A,\n\t  ANT_AB,\n\t  ANT_AC,\n\t  ANT_ABC,\n};\n\n#define IWL_DECLARE_RATE_INFO(r, s, ip, in, rp, rn, pp, np)    \\\n\t[IWL_RATE_##r##M_INDEX] = { IWL_RATE_##r##M_PLCP,      \\\n\t\t\t\t    IWL_RATE_SISO_##s##M_PLCP, \\\n\t\t\t\t    IWL_RATE_MIMO2_##s##M_PLCP,\\\n\t\t\t\t    IWL_RATE_MIMO3_##s##M_PLCP,\\\n\t\t\t\t    IWL_RATE_##r##M_IEEE,      \\\n\t\t\t\t    IWL_RATE_##ip##M_INDEX,    \\\n\t\t\t\t    IWL_RATE_##in##M_INDEX,    \\\n\t\t\t\t    IWL_RATE_##rp##M_INDEX,    \\\n\t\t\t\t    IWL_RATE_##rn##M_INDEX,    \\\n\t\t\t\t    IWL_RATE_##pp##M_INDEX,    \\\n\t\t\t\t    IWL_RATE_##np##M_INDEX }\n\n \nconst struct iwl_rate_info iwl_rates[IWL_RATE_COUNT] = {\n\tIWL_DECLARE_RATE_INFO(1, INV, INV, 2, INV, 2, INV, 2),     \n\tIWL_DECLARE_RATE_INFO(2, INV, 1, 5, 1, 5, 1, 5),           \n\tIWL_DECLARE_RATE_INFO(5, INV, 2, 6, 2, 11, 2, 11),         \n\tIWL_DECLARE_RATE_INFO(11, INV, 9, 12, 9, 12, 5, 18),       \n\tIWL_DECLARE_RATE_INFO(6, 6, 5, 9, 5, 11, 5, 11),         \n\tIWL_DECLARE_RATE_INFO(9, 6, 6, 11, 6, 11, 5, 11),        \n\tIWL_DECLARE_RATE_INFO(12, 12, 11, 18, 11, 18, 11, 18),    \n\tIWL_DECLARE_RATE_INFO(18, 18, 12, 24, 12, 24, 11, 24),    \n\tIWL_DECLARE_RATE_INFO(24, 24, 18, 36, 18, 36, 18, 36),    \n\tIWL_DECLARE_RATE_INFO(36, 36, 24, 48, 24, 48, 24, 48),    \n\tIWL_DECLARE_RATE_INFO(48, 48, 36, 54, 36, 54, 36, 54),    \n\tIWL_DECLARE_RATE_INFO(54, 54, 48, INV, 48, INV, 48, INV), \n\tIWL_DECLARE_RATE_INFO(60, 60, 48, INV, 48, INV, 48, INV), \n\t \n};\n\nstatic inline u8 rs_extract_rate(u32 rate_n_flags)\n{\n\treturn (u8)(rate_n_flags & RATE_MCS_RATE_MSK);\n}\n\nstatic int iwl_hwrate_to_plcp_idx(u32 rate_n_flags)\n{\n\tint idx = 0;\n\n\t \n\tif (rate_n_flags & RATE_MCS_HT_MSK) {\n\t\tidx = rs_extract_rate(rate_n_flags);\n\n\t\tif (idx >= IWL_RATE_MIMO3_6M_PLCP)\n\t\t\tidx = idx - IWL_RATE_MIMO3_6M_PLCP;\n\t\telse if (idx >= IWL_RATE_MIMO2_6M_PLCP)\n\t\t\tidx = idx - IWL_RATE_MIMO2_6M_PLCP;\n\n\t\tidx += IWL_FIRST_OFDM_RATE;\n\t\t \n\t\tif (idx >= IWL_RATE_9M_INDEX)\n\t\t\tidx += 1;\n\t\tif ((idx >= IWL_FIRST_OFDM_RATE) && (idx <= IWL_LAST_OFDM_RATE))\n\t\t\treturn idx;\n\n\t \n\t} else {\n\t\tfor (idx = 0; idx < ARRAY_SIZE(iwl_rates); idx++)\n\t\t\tif (iwl_rates[idx].plcp ==\n\t\t\t\t\trs_extract_rate(rate_n_flags))\n\t\t\t\treturn idx;\n\t}\n\n\treturn IWL_RATE_INVALID;\n}\n\nstatic void rs_rate_scale_perform(struct iwl_priv *priv,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   struct iwl_lq_sta *lq_sta);\nstatic void rs_fill_link_cmd(struct iwl_priv *priv,\n\t\t\t     struct iwl_lq_sta *lq_sta, u32 rate_n_flags);\nstatic void rs_stay_in_table(struct iwl_lq_sta *lq_sta, bool force_search);\n\n\n#ifdef CONFIG_MAC80211_DEBUGFS\nstatic void rs_dbgfs_set_mcs(struct iwl_lq_sta *lq_sta,\n\t\t\t     u32 *rate_n_flags, int index);\n#else\nstatic void rs_dbgfs_set_mcs(struct iwl_lq_sta *lq_sta,\n\t\t\t     u32 *rate_n_flags, int index)\n{}\n#endif\n\n \n\nstatic const u16 expected_tpt_legacy[IWL_RATE_COUNT] = {\n\t7, 13, 35, 58, 40, 57, 72, 98, 121, 154, 177, 186, 0\n};\n\nstatic const u16 expected_tpt_siso20MHz[4][IWL_RATE_COUNT] = {\n\t{0, 0, 0, 0, 42, 0,  76, 102, 124, 159, 183, 193, 202},  \n\t{0, 0, 0, 0, 46, 0,  82, 110, 132, 168, 192, 202, 210},  \n\t{0, 0, 0, 0, 47, 0,  91, 133, 171, 242, 305, 334, 362},  \n\t{0, 0, 0, 0, 52, 0, 101, 145, 187, 264, 330, 361, 390},  \n};\n\nstatic const u16 expected_tpt_siso40MHz[4][IWL_RATE_COUNT] = {\n\t{0, 0, 0, 0,  77, 0, 127, 160, 184, 220, 242, 250, 257},  \n\t{0, 0, 0, 0,  83, 0, 135, 169, 193, 229, 250, 257, 264},  \n\t{0, 0, 0, 0,  94, 0, 177, 249, 313, 423, 512, 550, 586},  \n\t{0, 0, 0, 0, 104, 0, 193, 270, 338, 454, 545, 584, 620},  \n};\n\nstatic const u16 expected_tpt_mimo2_20MHz[4][IWL_RATE_COUNT] = {\n\t{0, 0, 0, 0,  74, 0, 123, 155, 179, 214, 236, 244, 251},  \n\t{0, 0, 0, 0,  81, 0, 131, 164, 188, 223, 243, 251, 257},  \n\t{0, 0, 0, 0,  89, 0, 167, 235, 296, 402, 488, 526, 560},  \n\t{0, 0, 0, 0,  97, 0, 182, 255, 320, 431, 520, 558, 593},  \n};\n\nstatic const u16 expected_tpt_mimo2_40MHz[4][IWL_RATE_COUNT] = {\n\t{0, 0, 0, 0, 123, 0, 182, 214, 235, 264, 279, 285, 289},  \n\t{0, 0, 0, 0, 131, 0, 191, 222, 242, 270, 284, 289, 293},  \n\t{0, 0, 0, 0, 171, 0, 305, 410, 496, 634, 731, 771, 805},  \n\t{0, 0, 0, 0, 186, 0, 329, 439, 527, 667, 764, 803, 838},  \n};\n\nstatic const u16 expected_tpt_mimo3_20MHz[4][IWL_RATE_COUNT] = {\n\t{0, 0, 0, 0,  99, 0, 153, 186, 208, 239, 256, 263, 268},  \n\t{0, 0, 0, 0, 106, 0, 162, 194, 215, 246, 262, 268, 273},  \n\t{0, 0, 0, 0, 134, 0, 249, 346, 431, 574, 685, 732, 775},  \n\t{0, 0, 0, 0, 148, 0, 272, 376, 465, 614, 727, 775, 818},  \n};\n\nstatic const u16 expected_tpt_mimo3_40MHz[4][IWL_RATE_COUNT] = {\n\t{0, 0, 0, 0, 152, 0, 211, 239, 255, 279,  290,  294,  297},  \n\t{0, 0, 0, 0, 160, 0, 219, 245, 261, 284,  294,  297,  300},  \n\t{0, 0, 0, 0, 254, 0, 443, 584, 695, 868,  984, 1030, 1070},  \n\t{0, 0, 0, 0, 277, 0, 478, 624, 737, 911, 1026, 1070, 1109},  \n};\n\n#define MCS_INDEX_PER_STREAM\t(8)\n\nstatic void rs_rate_scale_clear_window(struct iwl_rate_scale_data *window)\n{\n\twindow->data = 0;\n\twindow->success_counter = 0;\n\twindow->success_ratio = IWL_INVALID_VALUE;\n\twindow->counter = 0;\n\twindow->average_tpt = IWL_INVALID_VALUE;\n\twindow->stamp = 0;\n}\n\nstatic inline u8 rs_is_valid_ant(u8 valid_antenna, u8 ant_type)\n{\n\treturn (ant_type & valid_antenna) == ant_type;\n}\n\n \nstatic void rs_tl_rm_old_stats(struct iwl_traffic_load *tl, u32 curr_time)\n{\n\t \n\tu32 oldest_time = curr_time - TID_MAX_TIME_DIFF;\n\n\twhile (tl->queue_count &&\n\t       (tl->time_stamp < oldest_time)) {\n\t\ttl->total -= tl->packet_count[tl->head];\n\t\ttl->packet_count[tl->head] = 0;\n\t\ttl->time_stamp += TID_QUEUE_CELL_SPACING;\n\t\ttl->queue_count--;\n\t\ttl->head++;\n\t\tif (tl->head >= TID_QUEUE_MAX_SIZE)\n\t\t\ttl->head = 0;\n\t}\n}\n\n \nstatic u8 rs_tl_add_packet(struct iwl_lq_sta *lq_data,\n\t\t\t   struct ieee80211_hdr *hdr)\n{\n\tu32 curr_time = jiffies_to_msecs(jiffies);\n\tu32 time_diff;\n\ts32 index;\n\tstruct iwl_traffic_load *tl = NULL;\n\tu8 tid;\n\n\tif (ieee80211_is_data_qos(hdr->frame_control)) {\n\t\tu8 *qc = ieee80211_get_qos_ctl(hdr);\n\t\ttid = qc[0] & 0xf;\n\t} else\n\t\treturn IWL_MAX_TID_COUNT;\n\n\tif (unlikely(tid >= IWL_MAX_TID_COUNT))\n\t\treturn IWL_MAX_TID_COUNT;\n\n\ttl = &lq_data->load[tid];\n\n\tcurr_time -= curr_time % TID_ROUND_VALUE;\n\n\t \n\tif (!(tl->queue_count)) {\n\t\ttl->total = 1;\n\t\ttl->time_stamp = curr_time;\n\t\ttl->queue_count = 1;\n\t\ttl->head = 0;\n\t\ttl->packet_count[0] = 1;\n\t\treturn IWL_MAX_TID_COUNT;\n\t}\n\n\ttime_diff = TIME_WRAP_AROUND(tl->time_stamp, curr_time);\n\tindex = time_diff / TID_QUEUE_CELL_SPACING;\n\n\t \n\t \n\tif (index >= TID_QUEUE_MAX_SIZE)\n\t\trs_tl_rm_old_stats(tl, curr_time);\n\n\tindex = (tl->head + index) % TID_QUEUE_MAX_SIZE;\n\ttl->packet_count[index] = tl->packet_count[index] + 1;\n\ttl->total = tl->total + 1;\n\n\tif ((index + 1) > tl->queue_count)\n\t\ttl->queue_count = index + 1;\n\n\treturn tid;\n}\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n \nstatic void rs_program_fix_rate(struct iwl_priv *priv,\n\t\t\t\tstruct iwl_lq_sta *lq_sta)\n{\n\tstruct iwl_station_priv *sta_priv =\n\t\tcontainer_of(lq_sta, struct iwl_station_priv, lq_sta);\n\tstruct iwl_rxon_context *ctx = sta_priv->ctx;\n\n\tlq_sta->active_legacy_rate = 0x0FFF;\t \n\tlq_sta->active_siso_rate   = 0x1FD0;\t \n\tlq_sta->active_mimo2_rate  = 0x1FD0;\t \n\tlq_sta->active_mimo3_rate  = 0x1FD0;\t \n\n\tIWL_DEBUG_RATE(priv, \"sta_id %d rate 0x%X\\n\",\n\t\tlq_sta->lq.sta_id, lq_sta->dbg_fixed_rate);\n\n\tif (lq_sta->dbg_fixed_rate) {\n\t\trs_fill_link_cmd(NULL, lq_sta, lq_sta->dbg_fixed_rate);\n\t\tiwl_send_lq_cmd(lq_sta->drv, ctx, &lq_sta->lq, CMD_ASYNC,\n\t\t\t\tfalse);\n\t}\n}\n#endif\n\n \nstatic void rs_tl_get_load(struct iwl_lq_sta *lq_data, u8 tid)\n{\n\tu32 curr_time = jiffies_to_msecs(jiffies);\n\tu32 time_diff;\n\ts32 index;\n\tstruct iwl_traffic_load *tl = NULL;\n\n\tif (tid >= IWL_MAX_TID_COUNT)\n\t\treturn;\n\n\ttl = &(lq_data->load[tid]);\n\n\tcurr_time -= curr_time % TID_ROUND_VALUE;\n\n\tif (!(tl->queue_count))\n\t\treturn;\n\n\ttime_diff = TIME_WRAP_AROUND(tl->time_stamp, curr_time);\n\tindex = time_diff / TID_QUEUE_CELL_SPACING;\n\n\t \n\t \n\tif (index >= TID_QUEUE_MAX_SIZE)\n\t\trs_tl_rm_old_stats(tl, curr_time);\n}\n\nstatic int rs_tl_turn_on_agg_for_tid(struct iwl_priv *priv,\n\t\t\t\t      struct iwl_lq_sta *lq_data, u8 tid,\n\t\t\t\t      struct ieee80211_sta *sta)\n{\n\tint ret = -EAGAIN;\n\n\t \n\tif (priv->bt_traffic_load >= IWL_BT_COEX_TRAFFIC_LOAD_HIGH) {\n\t\tIWL_DEBUG_COEX(priv,\n\t\t\t       \"BT traffic (%d), no aggregation allowed\\n\",\n\t\t\t       priv->bt_traffic_load);\n\t\treturn ret;\n\t}\n\n\trs_tl_get_load(lq_data, tid);\n\n\tIWL_DEBUG_HT(priv, \"Starting Tx agg: STA: %pM tid: %d\\n\",\n\t\t\tsta->addr, tid);\n\tret = ieee80211_start_tx_ba_session(sta, tid, 5000);\n\tif (ret == -EAGAIN) {\n\t\t \n\t\tIWL_ERR(priv, \"Fail start Tx agg on tid: %d\\n\",\n\t\t\ttid);\n\t\tieee80211_stop_tx_ba_session(sta, tid);\n\t}\n\treturn ret;\n}\n\nstatic void rs_tl_turn_on_agg(struct iwl_priv *priv, u8 tid,\n\t\t\t      struct iwl_lq_sta *lq_data,\n\t\t\t      struct ieee80211_sta *sta)\n{\n\tif (tid < IWL_MAX_TID_COUNT)\n\t\trs_tl_turn_on_agg_for_tid(priv, lq_data, tid, sta);\n\telse\n\t\tIWL_ERR(priv, \"tid exceeds max TID count: %d/%d\\n\",\n\t\t\ttid, IWL_MAX_TID_COUNT);\n}\n\nstatic inline int get_num_of_ant_from_rate(u32 rate_n_flags)\n{\n\treturn !!(rate_n_flags & RATE_MCS_ANT_A_MSK) +\n\t       !!(rate_n_flags & RATE_MCS_ANT_B_MSK) +\n\t       !!(rate_n_flags & RATE_MCS_ANT_C_MSK);\n}\n\n \nstatic s32 get_expected_tpt(struct iwl_scale_tbl_info *tbl, int rs_index)\n{\n\tif (tbl->expected_tpt)\n\t\treturn tbl->expected_tpt[rs_index];\n\treturn 0;\n}\n\n \nstatic int rs_collect_tx_data(struct iwl_scale_tbl_info *tbl,\n\t\t\t      int scale_index, int attempts, int successes)\n{\n\tstruct iwl_rate_scale_data *window = NULL;\n\tstatic const u64 mask = (((u64)1) << (IWL_RATE_MAX_WINDOW - 1));\n\ts32 fail_count, tpt;\n\n\tif (scale_index < 0 || scale_index >= IWL_RATE_COUNT)\n\t\treturn -EINVAL;\n\n\t \n\twindow = &(tbl->win[scale_index]);\n\n\t \n\ttpt = get_expected_tpt(tbl, scale_index);\n\n\t \n\twhile (attempts > 0) {\n\t\tif (window->counter >= IWL_RATE_MAX_WINDOW) {\n\n\t\t\t \n\t\t\twindow->counter = IWL_RATE_MAX_WINDOW - 1;\n\n\t\t\tif (window->data & mask) {\n\t\t\t\twindow->data &= ~mask;\n\t\t\t\twindow->success_counter--;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\twindow->counter++;\n\n\t\t \n\t\twindow->data <<= 1;\n\n\t\t \n\t\tif (successes > 0) {\n\t\t\twindow->success_counter++;\n\t\t\twindow->data |= 0x1;\n\t\t\tsuccesses--;\n\t\t}\n\n\t\tattempts--;\n\t}\n\n\t \n\tif (window->counter > 0)\n\t\twindow->success_ratio = 128 * (100 * window->success_counter)\n\t\t\t\t\t/ window->counter;\n\telse\n\t\twindow->success_ratio = IWL_INVALID_VALUE;\n\n\tfail_count = window->counter - window->success_counter;\n\n\t \n\tif ((fail_count >= IWL_RATE_MIN_FAILURE_TH) ||\n\t    (window->success_counter >= IWL_RATE_MIN_SUCCESS_TH))\n\t\twindow->average_tpt = (window->success_ratio * tpt + 64) / 128;\n\telse\n\t\twindow->average_tpt = IWL_INVALID_VALUE;\n\n\t \n\twindow->stamp = jiffies;\n\n\treturn 0;\n}\n\n \n \nstatic u32 rate_n_flags_from_tbl(struct iwl_priv *priv,\n\t\t\t\t struct iwl_scale_tbl_info *tbl,\n\t\t\t\t int index, u8 use_green)\n{\n\tu32 rate_n_flags = 0;\n\n\tif (is_legacy(tbl->lq_type)) {\n\t\trate_n_flags = iwl_rates[index].plcp;\n\t\tif (index >= IWL_FIRST_CCK_RATE && index <= IWL_LAST_CCK_RATE)\n\t\t\trate_n_flags |= RATE_MCS_CCK_MSK;\n\n\t} else if (is_Ht(tbl->lq_type)) {\n\t\tif (index > IWL_LAST_OFDM_RATE) {\n\t\t\tIWL_ERR(priv, \"Invalid HT rate index %d\\n\", index);\n\t\t\tindex = IWL_LAST_OFDM_RATE;\n\t\t}\n\t\trate_n_flags = RATE_MCS_HT_MSK;\n\n\t\tif (is_siso(tbl->lq_type))\n\t\t\trate_n_flags |=\tiwl_rates[index].plcp_siso;\n\t\telse if (is_mimo2(tbl->lq_type))\n\t\t\trate_n_flags |=\tiwl_rates[index].plcp_mimo2;\n\t\telse\n\t\t\trate_n_flags |=\tiwl_rates[index].plcp_mimo3;\n\t} else {\n\t\tIWL_ERR(priv, \"Invalid tbl->lq_type %d\\n\", tbl->lq_type);\n\t}\n\n\trate_n_flags |= ((tbl->ant_type << RATE_MCS_ANT_POS) &\n\t\t\t\t\t\t     RATE_MCS_ANT_ABC_MSK);\n\n\tif (is_Ht(tbl->lq_type)) {\n\t\tif (tbl->is_ht40) {\n\t\t\tif (tbl->is_dup)\n\t\t\t\trate_n_flags |= RATE_MCS_DUP_MSK;\n\t\t\telse\n\t\t\t\trate_n_flags |= RATE_MCS_HT40_MSK;\n\t\t}\n\t\tif (tbl->is_SGI)\n\t\t\trate_n_flags |= RATE_MCS_SGI_MSK;\n\n\t\tif (use_green) {\n\t\t\trate_n_flags |= RATE_MCS_GF_MSK;\n\t\t\tif (is_siso(tbl->lq_type) && tbl->is_SGI) {\n\t\t\t\trate_n_flags &= ~RATE_MCS_SGI_MSK;\n\t\t\t\tIWL_ERR(priv, \"GF was set with SGI:SISO\\n\");\n\t\t\t}\n\t\t}\n\t}\n\treturn rate_n_flags;\n}\n\n \nstatic int rs_get_tbl_info_from_mcs(const u32 rate_n_flags,\n\t\t\t\t    enum nl80211_band band,\n\t\t\t\t    struct iwl_scale_tbl_info *tbl,\n\t\t\t\t    int *rate_idx)\n{\n\tu32 ant_msk = (rate_n_flags & RATE_MCS_ANT_ABC_MSK);\n\tu8 num_of_ant = get_num_of_ant_from_rate(rate_n_flags);\n\tu8 mcs;\n\n\tmemset(tbl, 0, sizeof(struct iwl_scale_tbl_info));\n\t*rate_idx = iwl_hwrate_to_plcp_idx(rate_n_flags);\n\n\tif (*rate_idx  == IWL_RATE_INVALID) {\n\t\t*rate_idx = -1;\n\t\treturn -EINVAL;\n\t}\n\ttbl->is_SGI = 0;\t \n\ttbl->is_ht40 = 0;\n\ttbl->is_dup = 0;\n\ttbl->ant_type = (ant_msk >> RATE_MCS_ANT_POS);\n\ttbl->lq_type = LQ_NONE;\n\ttbl->max_search = IWL_MAX_SEARCH;\n\n\t \n\tif (!(rate_n_flags & RATE_MCS_HT_MSK)) {\n\t\tif (num_of_ant == 1) {\n\t\t\tif (band == NL80211_BAND_5GHZ)\n\t\t\t\ttbl->lq_type = LQ_A;\n\t\t\telse\n\t\t\t\ttbl->lq_type = LQ_G;\n\t\t}\n\t \n\t} else {\n\t\tif (rate_n_flags & RATE_MCS_SGI_MSK)\n\t\t\ttbl->is_SGI = 1;\n\n\t\tif ((rate_n_flags & RATE_MCS_HT40_MSK) ||\n\t\t    (rate_n_flags & RATE_MCS_DUP_MSK))\n\t\t\ttbl->is_ht40 = 1;\n\n\t\tif (rate_n_flags & RATE_MCS_DUP_MSK)\n\t\t\ttbl->is_dup = 1;\n\n\t\tmcs = rs_extract_rate(rate_n_flags);\n\n\t\t \n\t\tif (mcs <= IWL_RATE_SISO_60M_PLCP) {\n\t\t\tif (num_of_ant == 1)\n\t\t\t\ttbl->lq_type = LQ_SISO;  \n\t\t \n\t\t} else if (mcs <= IWL_RATE_MIMO2_60M_PLCP) {\n\t\t\tif (num_of_ant == 2)\n\t\t\t\ttbl->lq_type = LQ_MIMO2;\n\t\t \n\t\t} else {\n\t\t\tif (num_of_ant == 3) {\n\t\t\t\ttbl->max_search = IWL_MAX_11N_MIMO3_SEARCH;\n\t\t\t\ttbl->lq_type = LQ_MIMO3;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n \nstatic int rs_toggle_antenna(u32 valid_ant, u32 *rate_n_flags,\n\t\t\t     struct iwl_scale_tbl_info *tbl)\n{\n\tu8 new_ant_type;\n\n\tif (!tbl->ant_type || tbl->ant_type > ANT_ABC)\n\t\treturn 0;\n\n\tif (!rs_is_valid_ant(valid_ant, tbl->ant_type))\n\t\treturn 0;\n\n\tnew_ant_type = ant_toggle_lookup[tbl->ant_type];\n\n\twhile ((new_ant_type != tbl->ant_type) &&\n\t       !rs_is_valid_ant(valid_ant, new_ant_type))\n\t\tnew_ant_type = ant_toggle_lookup[new_ant_type];\n\n\tif (new_ant_type == tbl->ant_type)\n\t\treturn 0;\n\n\ttbl->ant_type = new_ant_type;\n\t*rate_n_flags &= ~RATE_MCS_ANT_ABC_MSK;\n\t*rate_n_flags |= new_ant_type << RATE_MCS_ANT_POS;\n\treturn 1;\n}\n\n \nstatic bool rs_use_green(struct ieee80211_sta *sta)\n{\n\t \n\treturn false;\n}\n\n \nstatic u16 rs_get_supported_rates(struct iwl_lq_sta *lq_sta,\n\t\t\t\t  struct ieee80211_hdr *hdr,\n\t\t\t\t  enum iwl_table_type rate_type)\n{\n\tif (is_legacy(rate_type)) {\n\t\treturn lq_sta->active_legacy_rate;\n\t} else {\n\t\tif (is_siso(rate_type))\n\t\t\treturn lq_sta->active_siso_rate;\n\t\telse if (is_mimo2(rate_type))\n\t\t\treturn lq_sta->active_mimo2_rate;\n\t\telse\n\t\t\treturn lq_sta->active_mimo3_rate;\n\t}\n}\n\nstatic u16 rs_get_adjacent_rate(struct iwl_priv *priv, u8 index, u16 rate_mask,\n\t\t\t\tint rate_type)\n{\n\tu8 high = IWL_RATE_INVALID;\n\tu8 low = IWL_RATE_INVALID;\n\n\t \n\tif (is_a_band(rate_type) || !is_legacy(rate_type)) {\n\t\tint i;\n\t\tu32 mask;\n\n\t\t \n\t\ti = index - 1;\n\t\tif (i >= 0)\n\t\t\tmask = BIT(i);\n\n\t\tfor (; i >= 0; i--, mask >>= 1) {\n\t\t\tif (rate_mask & mask) {\n\t\t\t\tlow = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\ti = index + 1;\n\t\tfor (mask = (1 << i); i < IWL_RATE_COUNT; i++, mask <<= 1) {\n\t\t\tif (rate_mask & mask) {\n\t\t\t\thigh = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn (high << 8) | low;\n\t}\n\n\tlow = index;\n\twhile (low != IWL_RATE_INVALID) {\n\t\tlow = iwl_rates[low].prev_rs;\n\t\tif (low == IWL_RATE_INVALID)\n\t\t\tbreak;\n\t\tif (rate_mask & (1 << low))\n\t\t\tbreak;\n\t\tIWL_DEBUG_RATE(priv, \"Skipping masked lower rate: %d\\n\", low);\n\t}\n\n\thigh = index;\n\twhile (high != IWL_RATE_INVALID) {\n\t\thigh = iwl_rates[high].next_rs;\n\t\tif (high == IWL_RATE_INVALID)\n\t\t\tbreak;\n\t\tif (rate_mask & (1 << high))\n\t\t\tbreak;\n\t\tIWL_DEBUG_RATE(priv, \"Skipping masked higher rate: %d\\n\", high);\n\t}\n\n\treturn (high << 8) | low;\n}\n\nstatic u32 rs_get_lower_rate(struct iwl_lq_sta *lq_sta,\n\t\t\t     struct iwl_scale_tbl_info *tbl,\n\t\t\t     u8 scale_index, u8 ht_possible)\n{\n\ts32 low;\n\tu16 rate_mask;\n\tu16 high_low;\n\tu8 switch_to_legacy = 0;\n\tu8 is_green = lq_sta->is_green;\n\tstruct iwl_priv *priv = lq_sta->drv;\n\n\t \n\tif (!is_legacy(tbl->lq_type) && (!ht_possible || !scale_index)) {\n\t\tswitch_to_legacy = 1;\n\t\tscale_index = rs_ht_to_legacy[scale_index];\n\t\tif (lq_sta->band == NL80211_BAND_5GHZ)\n\t\t\ttbl->lq_type = LQ_A;\n\t\telse\n\t\t\ttbl->lq_type = LQ_G;\n\n\t\tif (num_of_ant(tbl->ant_type) > 1)\n\t\t\ttbl->ant_type =\n\t\t\t    first_antenna(priv->nvm_data->valid_tx_ant);\n\n\t\ttbl->is_ht40 = 0;\n\t\ttbl->is_SGI = 0;\n\t\ttbl->max_search = IWL_MAX_SEARCH;\n\t}\n\n\trate_mask = rs_get_supported_rates(lq_sta, NULL, tbl->lq_type);\n\n\t \n\tif (is_legacy(tbl->lq_type)) {\n\t\t \n\t\tif (lq_sta->band == NL80211_BAND_5GHZ)\n\t\t\trate_mask  = (u16)(rate_mask &\n\t\t\t   (lq_sta->supp_rates << IWL_FIRST_OFDM_RATE));\n\t\telse\n\t\t\trate_mask = (u16)(rate_mask & lq_sta->supp_rates);\n\t}\n\n\t \n\tif (switch_to_legacy && (rate_mask & (1 << scale_index))) {\n\t\tlow = scale_index;\n\t\tgoto out;\n\t}\n\n\thigh_low = rs_get_adjacent_rate(lq_sta->drv, scale_index, rate_mask,\n\t\t\t\t\ttbl->lq_type);\n\tlow = high_low & 0xff;\n\n\tif (low == IWL_RATE_INVALID)\n\t\tlow = scale_index;\n\nout:\n\treturn rate_n_flags_from_tbl(lq_sta->drv, tbl, low, is_green);\n}\n\n \nstatic bool table_type_matches(struct iwl_scale_tbl_info *a,\n\t\t\t       struct iwl_scale_tbl_info *b)\n{\n\treturn (a->lq_type == b->lq_type) && (a->ant_type == b->ant_type) &&\n\t\t(a->is_SGI == b->is_SGI);\n}\n\nstatic void rs_bt_update_lq(struct iwl_priv *priv, struct iwl_rxon_context *ctx,\n\t\t\t    struct iwl_lq_sta *lq_sta)\n{\n\tstruct iwl_scale_tbl_info *tbl;\n\tbool full_concurrent = priv->bt_full_concurrent;\n\n\tif ((priv->bt_traffic_load != priv->last_bt_traffic_load) ||\n\t    (priv->bt_full_concurrent != full_concurrent)) {\n\t\tpriv->bt_full_concurrent = full_concurrent;\n\t\tpriv->last_bt_traffic_load = priv->bt_traffic_load;\n\n\t\t \n\t\ttbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\n\t\trs_fill_link_cmd(priv, lq_sta, tbl->current_rate);\n\t\tiwl_send_lq_cmd(priv, ctx, &lq_sta->lq, CMD_ASYNC, false);\n\n\t\tqueue_work(priv->workqueue, &priv->bt_full_concurrency);\n\t}\n}\n\n \nstatic void rs_tx_status(void *priv_r, struct ieee80211_supported_band *sband,\n\t\t\t struct ieee80211_sta *sta, void *priv_sta,\n\t\t\t struct sk_buff *skb)\n{\n\tint legacy_success;\n\tint retries;\n\tint rs_index, mac_index, i;\n\tstruct iwl_lq_sta *lq_sta = priv_sta;\n\tstruct iwl_link_quality_cmd *table;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct iwl_op_mode *op_mode = (struct iwl_op_mode *)priv_r;\n\tstruct iwl_priv *priv = IWL_OP_MODE_GET_DVM(op_mode);\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tenum mac80211_rate_control_flags mac_flags;\n\tu32 tx_rate;\n\tstruct iwl_scale_tbl_info tbl_type;\n\tstruct iwl_scale_tbl_info *curr_tbl, *other_tbl, *tmp_tbl;\n\tstruct iwl_station_priv *sta_priv = (void *)sta->drv_priv;\n\tstruct iwl_rxon_context *ctx = sta_priv->ctx;\n\n\tIWL_DEBUG_RATE_LIMIT(priv, \"get frame ack response, update rate scale window\\n\");\n\n\t \n\tif (!lq_sta) {\n\t\tIWL_DEBUG_RATE(priv, \"Station rate scaling not created yet.\\n\");\n\t\treturn;\n\t} else if (!lq_sta->drv) {\n\t\tIWL_DEBUG_RATE(priv, \"Rate scaling not initialized yet.\\n\");\n\t\treturn;\n\t}\n\n\tif (!ieee80211_is_data(hdr->frame_control) ||\n\t    info->flags & IEEE80211_TX_CTL_NO_ACK)\n\t\treturn;\n\n\t \n\tif ((info->flags & IEEE80211_TX_CTL_AMPDU) &&\n\t    !(info->flags & IEEE80211_TX_STAT_AMPDU))\n\t\treturn;\n\n\t \n\ttable = &lq_sta->lq;\n\ttx_rate = le32_to_cpu(table->rs_table[0].rate_n_flags);\n\trs_get_tbl_info_from_mcs(tx_rate, priv->band, &tbl_type, &rs_index);\n\tif (priv->band == NL80211_BAND_5GHZ)\n\t\trs_index -= IWL_FIRST_OFDM_RATE;\n\tmac_flags = info->status.rates[0].flags;\n\tmac_index = info->status.rates[0].idx;\n\t \n\tif (mac_flags & IEEE80211_TX_RC_MCS) {\n\t\tmac_index &= RATE_MCS_CODE_MSK;\t \n\t\tif (mac_index >= (IWL_RATE_9M_INDEX - IWL_FIRST_OFDM_RATE))\n\t\t\tmac_index++;\n\t\t \n\t\tif (priv->band == NL80211_BAND_2GHZ)\n\t\t\tmac_index += IWL_FIRST_OFDM_RATE;\n\t}\n\t \n\tif ((mac_index < 0) ||\n\t    (tbl_type.is_SGI != !!(mac_flags & IEEE80211_TX_RC_SHORT_GI)) ||\n\t    (tbl_type.is_ht40 != !!(mac_flags & IEEE80211_TX_RC_40_MHZ_WIDTH)) ||\n\t    (tbl_type.is_dup != !!(mac_flags & IEEE80211_TX_RC_DUP_DATA)) ||\n\t    (tbl_type.ant_type != info->status.antenna) ||\n\t    (!!(tx_rate & RATE_MCS_HT_MSK) != !!(mac_flags & IEEE80211_TX_RC_MCS)) ||\n\t    (!!(tx_rate & RATE_MCS_GF_MSK) != !!(mac_flags & IEEE80211_TX_RC_GREEN_FIELD)) ||\n\t    (rs_index != mac_index)) {\n\t\tIWL_DEBUG_RATE(priv, \"initial rate %d does not match %d (0x%x)\\n\", mac_index, rs_index, tx_rate);\n\t\t \n\t\tlq_sta->missed_rate_counter++;\n\t\tif (lq_sta->missed_rate_counter > IWL_MISSED_RATE_MAX) {\n\t\t\tlq_sta->missed_rate_counter = 0;\n\t\t\tiwl_send_lq_cmd(priv, ctx, &lq_sta->lq, CMD_ASYNC, false);\n\t\t}\n\t\t \n\t\treturn;\n\t} else\n\t\t \n\t\tlq_sta->missed_rate_counter = 0;\n\n\t \n\tif (table_type_matches(&tbl_type,\n\t\t\t\t&(lq_sta->lq_info[lq_sta->active_tbl]))) {\n\t\tcurr_tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\n\t\tother_tbl = &(lq_sta->lq_info[1 - lq_sta->active_tbl]);\n\t} else if (table_type_matches(&tbl_type,\n\t\t\t\t&lq_sta->lq_info[1 - lq_sta->active_tbl])) {\n\t\tcurr_tbl = &(lq_sta->lq_info[1 - lq_sta->active_tbl]);\n\t\tother_tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\n\t} else {\n\t\tIWL_DEBUG_RATE(priv, \"Neither active nor search matches tx rate\\n\");\n\t\ttmp_tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\n\t\tIWL_DEBUG_RATE(priv, \"active- lq:%x, ant:%x, SGI:%d\\n\",\n\t\t\ttmp_tbl->lq_type, tmp_tbl->ant_type, tmp_tbl->is_SGI);\n\t\ttmp_tbl = &(lq_sta->lq_info[1 - lq_sta->active_tbl]);\n\t\tIWL_DEBUG_RATE(priv, \"search- lq:%x, ant:%x, SGI:%d\\n\",\n\t\t\ttmp_tbl->lq_type, tmp_tbl->ant_type, tmp_tbl->is_SGI);\n\t\tIWL_DEBUG_RATE(priv, \"actual- lq:%x, ant:%x, SGI:%d\\n\",\n\t\t\ttbl_type.lq_type, tbl_type.ant_type, tbl_type.is_SGI);\n\t\t \n\t\trs_stay_in_table(lq_sta, true);\n\t\tgoto done;\n\t}\n\n\t \n\tif (info->flags & IEEE80211_TX_STAT_AMPDU) {\n\t\ttx_rate = le32_to_cpu(table->rs_table[0].rate_n_flags);\n\t\trs_get_tbl_info_from_mcs(tx_rate, priv->band, &tbl_type,\n\t\t\t\t&rs_index);\n\t\trs_collect_tx_data(curr_tbl, rs_index,\n\t\t\t\t   info->status.ampdu_len,\n\t\t\t\t   info->status.ampdu_ack_len);\n\n\t\t \n\t\tif (lq_sta->stay_in_tbl) {\n\t\t\tlq_sta->total_success += info->status.ampdu_ack_len;\n\t\t\tlq_sta->total_failed += (info->status.ampdu_len -\n\t\t\t\t\tinfo->status.ampdu_ack_len);\n\t\t}\n\t} else {\n\t \n\t\tretries = info->status.rates[0].count - 1;\n\t\t \n\t\tretries = min(retries, 15);\n\n\t\t \n\t\tlegacy_success = !!(info->flags & IEEE80211_TX_STAT_ACK);\n\t\t \n\t\tfor (i = 0; i <= retries; ++i) {\n\t\t\ttx_rate = le32_to_cpu(table->rs_table[i].rate_n_flags);\n\t\t\trs_get_tbl_info_from_mcs(tx_rate, priv->band,\n\t\t\t\t\t&tbl_type, &rs_index);\n\t\t\t \n\t\t\tif (table_type_matches(&tbl_type, curr_tbl))\n\t\t\t\ttmp_tbl = curr_tbl;\n\t\t\telse if (table_type_matches(&tbl_type, other_tbl))\n\t\t\t\ttmp_tbl = other_tbl;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t\trs_collect_tx_data(tmp_tbl, rs_index, 1,\n\t\t\t\t\t   i < retries ? 0 : legacy_success);\n\t\t}\n\n\t\t \n\t\tif (lq_sta->stay_in_tbl) {\n\t\t\tlq_sta->total_success += legacy_success;\n\t\t\tlq_sta->total_failed += retries + (1 - legacy_success);\n\t\t}\n\t}\n\t \n\tlq_sta->last_rate_n_flags = tx_rate;\ndone:\n\t \n\tif (sta && sta->deflink.supp_rates[sband->band])\n\t\trs_rate_scale_perform(priv, skb, sta, lq_sta);\n\n\tif (priv->lib->bt_params && priv->lib->bt_params->advanced_bt_coexist)\n\t\trs_bt_update_lq(priv, ctx, lq_sta);\n}\n\n \nstatic void rs_set_stay_in_table(struct iwl_priv *priv, u8 is_legacy,\n\t\t\t\t struct iwl_lq_sta *lq_sta)\n{\n\tIWL_DEBUG_RATE(priv, \"we are staying in the same table\\n\");\n\tlq_sta->stay_in_tbl = 1;\t \n\tif (is_legacy) {\n\t\tlq_sta->table_count_limit = IWL_LEGACY_TABLE_COUNT;\n\t\tlq_sta->max_failure_limit = IWL_LEGACY_FAILURE_LIMIT;\n\t\tlq_sta->max_success_limit = IWL_LEGACY_SUCCESS_LIMIT;\n\t} else {\n\t\tlq_sta->table_count_limit = IWL_NONE_LEGACY_TABLE_COUNT;\n\t\tlq_sta->max_failure_limit = IWL_NONE_LEGACY_FAILURE_LIMIT;\n\t\tlq_sta->max_success_limit = IWL_NONE_LEGACY_SUCCESS_LIMIT;\n\t}\n\tlq_sta->table_count = 0;\n\tlq_sta->total_failed = 0;\n\tlq_sta->total_success = 0;\n\tlq_sta->flush_timer = jiffies;\n\tlq_sta->action_counter = 0;\n}\n\n \nstatic void rs_set_expected_tpt_table(struct iwl_lq_sta *lq_sta,\n\t\t\t\t      struct iwl_scale_tbl_info *tbl)\n{\n\t \n\tconst u16 (*ht_tbl_pointer)[IWL_RATE_COUNT];\n\n\t \n\tif (WARN_ON_ONCE(!is_legacy(tbl->lq_type) && !is_Ht(tbl->lq_type))) {\n\t\ttbl->expected_tpt = expected_tpt_legacy;\n\t\treturn;\n\t}\n\n\t \n\tif (is_legacy(tbl->lq_type)) {\n\t\ttbl->expected_tpt = expected_tpt_legacy;\n\t\treturn;\n\t}\n\n\t \n\tif (is_siso(tbl->lq_type) && (!tbl->is_ht40 || lq_sta->is_dup))\n\t\tht_tbl_pointer = expected_tpt_siso20MHz;\n\telse if (is_siso(tbl->lq_type))\n\t\tht_tbl_pointer = expected_tpt_siso40MHz;\n\telse if (is_mimo2(tbl->lq_type) && (!tbl->is_ht40 || lq_sta->is_dup))\n\t\tht_tbl_pointer = expected_tpt_mimo2_20MHz;\n\telse if (is_mimo2(tbl->lq_type))\n\t\tht_tbl_pointer = expected_tpt_mimo2_40MHz;\n\telse if (is_mimo3(tbl->lq_type) && (!tbl->is_ht40 || lq_sta->is_dup))\n\t\tht_tbl_pointer = expected_tpt_mimo3_20MHz;\n\telse  \n\t\tht_tbl_pointer = expected_tpt_mimo3_40MHz;\n\n\tif (!tbl->is_SGI && !lq_sta->is_agg)\t\t \n\t\ttbl->expected_tpt = ht_tbl_pointer[0];\n\telse if (tbl->is_SGI && !lq_sta->is_agg)\t \n\t\ttbl->expected_tpt = ht_tbl_pointer[1];\n\telse if (!tbl->is_SGI && lq_sta->is_agg)\t \n\t\ttbl->expected_tpt = ht_tbl_pointer[2];\n\telse\t\t\t\t\t\t \n\t\ttbl->expected_tpt = ht_tbl_pointer[3];\n}\n\n \nstatic s32 rs_get_best_rate(struct iwl_priv *priv,\n\t\t\t    struct iwl_lq_sta *lq_sta,\n\t\t\t    struct iwl_scale_tbl_info *tbl,\t \n\t\t\t    u16 rate_mask, s8 index)\n{\n\t \n\tstruct iwl_scale_tbl_info *active_tbl =\n\t    &(lq_sta->lq_info[lq_sta->active_tbl]);\n\ts32 active_sr = active_tbl->win[index].success_ratio;\n\ts32 active_tpt = active_tbl->expected_tpt[index];\n\t \n\tconst u16 *tpt_tbl = tbl->expected_tpt;\n\n\ts32 new_rate, high, low, start_hi;\n\tu16 high_low;\n\ts8 rate = index;\n\n\tnew_rate = high = low = start_hi = IWL_RATE_INVALID;\n\n\tfor (; ;) {\n\t\thigh_low = rs_get_adjacent_rate(priv, rate, rate_mask,\n\t\t\t\t\t\ttbl->lq_type);\n\n\t\tlow = high_low & 0xff;\n\t\thigh = (high_low >> 8) & 0xff;\n\n\t\t \n\t\tif ((((100 * tpt_tbl[rate]) > lq_sta->last_tpt) &&\n\t\t     ((active_sr > IWL_RATE_DECREASE_TH) &&\n\t\t      (active_sr <= IWL_RATE_HIGH_TH) &&\n\t\t      (tpt_tbl[rate] <= active_tpt))) ||\n\t\t    ((active_sr >= IWL_RATE_SCALE_SWITCH) &&\n\t\t     (tpt_tbl[rate] > active_tpt))) {\n\n\t\t\t \n\t\t\tif (start_hi != IWL_RATE_INVALID) {\n\t\t\t\tnew_rate = start_hi;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnew_rate = rate;\n\n\t\t\t \n\t\t\tif (low != IWL_RATE_INVALID)\n\t\t\t\trate = low;\n\n\t\t\t \n\t\t\telse\n\t\t\t\tbreak;\n\n\t\t \n\t\t} else {\n\t\t\t \n\t\t\tif (new_rate != IWL_RATE_INVALID)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\telse if (high != IWL_RATE_INVALID) {\n\t\t\t\tstart_hi = high;\n\t\t\t\trate = high;\n\n\t\t\t \n\t\t\t} else {\n\t\t\t\tnew_rate = rate;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn new_rate;\n}\n\n \nstatic int rs_switch_to_mimo2(struct iwl_priv *priv,\n\t\t\t     struct iwl_lq_sta *lq_sta,\n\t\t\t     struct ieee80211_conf *conf,\n\t\t\t     struct ieee80211_sta *sta,\n\t\t\t     struct iwl_scale_tbl_info *tbl, int index)\n{\n\tu16 rate_mask;\n\ts32 rate;\n\ts8 is_green = lq_sta->is_green;\n\tstruct iwl_station_priv *sta_priv = (void *)sta->drv_priv;\n\tstruct iwl_rxon_context *ctx = sta_priv->ctx;\n\n\tif (!conf_is_ht(conf) || !sta->deflink.ht_cap.ht_supported)\n\t\treturn -1;\n\n\tif (sta->deflink.smps_mode == IEEE80211_SMPS_STATIC)\n\t\treturn -1;\n\n\t \n\tif (priv->hw_params.tx_chains_num < 2)\n\t\treturn -1;\n\n\tIWL_DEBUG_RATE(priv, \"LQ: try to switch to MIMO2\\n\");\n\n\ttbl->lq_type = LQ_MIMO2;\n\ttbl->is_dup = lq_sta->is_dup;\n\ttbl->action = 0;\n\ttbl->max_search = IWL_MAX_SEARCH;\n\trate_mask = lq_sta->active_mimo2_rate;\n\n\tif (iwl_is_ht40_tx_allowed(priv, ctx, sta))\n\t\ttbl->is_ht40 = 1;\n\telse\n\t\ttbl->is_ht40 = 0;\n\n\trs_set_expected_tpt_table(lq_sta, tbl);\n\n\trate = rs_get_best_rate(priv, lq_sta, tbl, rate_mask, index);\n\n\tIWL_DEBUG_RATE(priv, \"LQ: MIMO2 best rate %d mask %X\\n\", rate, rate_mask);\n\tif ((rate == IWL_RATE_INVALID) || !((1 << rate) & rate_mask)) {\n\t\tIWL_DEBUG_RATE(priv, \"Can't switch with index %d rate mask %x\\n\",\n\t\t\t\t\t\trate, rate_mask);\n\t\treturn -1;\n\t}\n\ttbl->current_rate = rate_n_flags_from_tbl(priv, tbl, rate, is_green);\n\n\tIWL_DEBUG_RATE(priv, \"LQ: Switch to new mcs %X index is green %X\\n\",\n\t\t     tbl->current_rate, is_green);\n\treturn 0;\n}\n\n \nstatic int rs_switch_to_mimo3(struct iwl_priv *priv,\n\t\t\t     struct iwl_lq_sta *lq_sta,\n\t\t\t     struct ieee80211_conf *conf,\n\t\t\t     struct ieee80211_sta *sta,\n\t\t\t     struct iwl_scale_tbl_info *tbl, int index)\n{\n\tu16 rate_mask;\n\ts32 rate;\n\ts8 is_green = lq_sta->is_green;\n\tstruct iwl_station_priv *sta_priv = (void *)sta->drv_priv;\n\tstruct iwl_rxon_context *ctx = sta_priv->ctx;\n\n\tif (!conf_is_ht(conf) || !sta->deflink.ht_cap.ht_supported)\n\t\treturn -1;\n\n\tif (sta->deflink.smps_mode == IEEE80211_SMPS_STATIC)\n\t\treturn -1;\n\n\t \n\tif (priv->hw_params.tx_chains_num < 3)\n\t\treturn -1;\n\n\tIWL_DEBUG_RATE(priv, \"LQ: try to switch to MIMO3\\n\");\n\n\ttbl->lq_type = LQ_MIMO3;\n\ttbl->is_dup = lq_sta->is_dup;\n\ttbl->action = 0;\n\ttbl->max_search = IWL_MAX_11N_MIMO3_SEARCH;\n\trate_mask = lq_sta->active_mimo3_rate;\n\n\tif (iwl_is_ht40_tx_allowed(priv, ctx, sta))\n\t\ttbl->is_ht40 = 1;\n\telse\n\t\ttbl->is_ht40 = 0;\n\n\trs_set_expected_tpt_table(lq_sta, tbl);\n\n\trate = rs_get_best_rate(priv, lq_sta, tbl, rate_mask, index);\n\n\tIWL_DEBUG_RATE(priv, \"LQ: MIMO3 best rate %d mask %X\\n\",\n\t\trate, rate_mask);\n\tif ((rate == IWL_RATE_INVALID) || !((1 << rate) & rate_mask)) {\n\t\tIWL_DEBUG_RATE(priv, \"Can't switch with index %d rate mask %x\\n\",\n\t\t\t\t\t\trate, rate_mask);\n\t\treturn -1;\n\t}\n\ttbl->current_rate = rate_n_flags_from_tbl(priv, tbl, rate, is_green);\n\n\tIWL_DEBUG_RATE(priv, \"LQ: Switch to new mcs %X index is green %X\\n\",\n\t\t     tbl->current_rate, is_green);\n\treturn 0;\n}\n\n \nstatic int rs_switch_to_siso(struct iwl_priv *priv,\n\t\t\t     struct iwl_lq_sta *lq_sta,\n\t\t\t     struct ieee80211_conf *conf,\n\t\t\t     struct ieee80211_sta *sta,\n\t\t\t     struct iwl_scale_tbl_info *tbl, int index)\n{\n\tu16 rate_mask;\n\tu8 is_green = lq_sta->is_green;\n\ts32 rate;\n\tstruct iwl_station_priv *sta_priv = (void *)sta->drv_priv;\n\tstruct iwl_rxon_context *ctx = sta_priv->ctx;\n\n\tif (!conf_is_ht(conf) || !sta->deflink.ht_cap.ht_supported)\n\t\treturn -1;\n\n\tIWL_DEBUG_RATE(priv, \"LQ: try to switch to SISO\\n\");\n\n\ttbl->is_dup = lq_sta->is_dup;\n\ttbl->lq_type = LQ_SISO;\n\ttbl->action = 0;\n\ttbl->max_search = IWL_MAX_SEARCH;\n\trate_mask = lq_sta->active_siso_rate;\n\n\tif (iwl_is_ht40_tx_allowed(priv, ctx, sta))\n\t\ttbl->is_ht40 = 1;\n\telse\n\t\ttbl->is_ht40 = 0;\n\n\tif (is_green)\n\t\ttbl->is_SGI = 0;  \n\n\trs_set_expected_tpt_table(lq_sta, tbl);\n\trate = rs_get_best_rate(priv, lq_sta, tbl, rate_mask, index);\n\n\tIWL_DEBUG_RATE(priv, \"LQ: get best rate %d mask %X\\n\", rate, rate_mask);\n\tif ((rate == IWL_RATE_INVALID) || !((1 << rate) & rate_mask)) {\n\t\tIWL_DEBUG_RATE(priv, \"can not switch with index %d rate mask %x\\n\",\n\t\t\t     rate, rate_mask);\n\t\treturn -1;\n\t}\n\ttbl->current_rate = rate_n_flags_from_tbl(priv, tbl, rate, is_green);\n\tIWL_DEBUG_RATE(priv, \"LQ: Switch to new mcs %X index is green %X\\n\",\n\t\t     tbl->current_rate, is_green);\n\treturn 0;\n}\n\n \nstatic void rs_move_legacy_other(struct iwl_priv *priv,\n\t\t\t\t struct iwl_lq_sta *lq_sta,\n\t\t\t\t struct ieee80211_conf *conf,\n\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t int index)\n{\n\tstruct iwl_scale_tbl_info *tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\n\tstruct iwl_scale_tbl_info *search_tbl =\n\t\t\t\t&(lq_sta->lq_info[(1 - lq_sta->active_tbl)]);\n\tstruct iwl_rate_scale_data *window = &(tbl->win[index]);\n\tu32 sz = (sizeof(struct iwl_scale_tbl_info) -\n\t\t  (sizeof(struct iwl_rate_scale_data) * IWL_RATE_COUNT));\n\tu8 start_action;\n\tu8 valid_tx_ant = priv->nvm_data->valid_tx_ant;\n\tu8 tx_chains_num = priv->hw_params.tx_chains_num;\n\tint ret = 0;\n\tu8 update_search_tbl_counter = 0;\n\n\tswitch (priv->bt_traffic_load) {\n\tcase IWL_BT_COEX_TRAFFIC_LOAD_NONE:\n\t\t \n\t\tbreak;\n\tcase IWL_BT_COEX_TRAFFIC_LOAD_LOW:\n\t\t \n\t\tif (tbl->action == IWL_LEGACY_SWITCH_ANTENNA2)\n\t\t\ttbl->action = IWL_LEGACY_SWITCH_SISO;\n\t\tbreak;\n\tcase IWL_BT_COEX_TRAFFIC_LOAD_HIGH:\n\tcase IWL_BT_COEX_TRAFFIC_LOAD_CONTINUOUS:\n\t\t \n\t\tvalid_tx_ant =\n\t\t\tfirst_antenna(priv->nvm_data->valid_tx_ant);\n\t\tif (tbl->action >= IWL_LEGACY_SWITCH_ANTENNA2 &&\n\t\t    tbl->action != IWL_LEGACY_SWITCH_SISO)\n\t\t\ttbl->action = IWL_LEGACY_SWITCH_SISO;\n\t\tbreak;\n\tdefault:\n\t\tIWL_ERR(priv, \"Invalid BT load %d\\n\", priv->bt_traffic_load);\n\t\tbreak;\n\t}\n\n\tif (!iwl_ht_enabled(priv))\n\t\t \n\t\ttbl->action = IWL_LEGACY_SWITCH_ANTENNA1;\n\telse if (iwl_tx_ant_restriction(priv) == IWL_ANT_OK_SINGLE &&\n\t\t   tbl->action > IWL_LEGACY_SWITCH_SISO)\n\t\ttbl->action = IWL_LEGACY_SWITCH_SISO;\n\n\t \n\tif (priv->bt_full_concurrent) {\n\t\tif (!iwl_ht_enabled(priv))\n\t\t\ttbl->action = IWL_LEGACY_SWITCH_ANTENNA1;\n\t\telse if (tbl->action >= IWL_LEGACY_SWITCH_ANTENNA2)\n\t\t\ttbl->action = IWL_LEGACY_SWITCH_SISO;\n\t\tvalid_tx_ant =\n\t\t\tfirst_antenna(priv->nvm_data->valid_tx_ant);\n\t}\n\n\tstart_action = tbl->action;\n\tfor (; ;) {\n\t\tlq_sta->action_counter++;\n\t\tswitch (tbl->action) {\n\t\tcase IWL_LEGACY_SWITCH_ANTENNA1:\n\t\tcase IWL_LEGACY_SWITCH_ANTENNA2:\n\t\t\tIWL_DEBUG_RATE(priv, \"LQ: Legacy toggle Antenna\\n\");\n\n\t\t\tif ((tbl->action == IWL_LEGACY_SWITCH_ANTENNA1 &&\n\t\t\t\t\t\t\ttx_chains_num <= 1) ||\n\t\t\t    (tbl->action == IWL_LEGACY_SWITCH_ANTENNA2 &&\n\t\t\t\t\t\t\ttx_chains_num <= 2))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (window->success_ratio >= IWL_RS_GOOD_RATIO &&\n\t\t\t    !priv->bt_full_concurrent &&\n\t\t\t    priv->bt_traffic_load ==\n\t\t\t\t\tIWL_BT_COEX_TRAFFIC_LOAD_NONE)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tmemcpy(search_tbl, tbl, sz);\n\n\t\t\tif (rs_toggle_antenna(valid_tx_ant,\n\t\t\t\t&search_tbl->current_rate, search_tbl)) {\n\t\t\t\tupdate_search_tbl_counter = 1;\n\t\t\t\trs_set_expected_tpt_table(lq_sta, search_tbl);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IWL_LEGACY_SWITCH_SISO:\n\t\t\tIWL_DEBUG_RATE(priv, \"LQ: Legacy switch to SISO\\n\");\n\n\t\t\t \n\t\t\tmemcpy(search_tbl, tbl, sz);\n\t\t\tsearch_tbl->is_SGI = 0;\n\t\t\tret = rs_switch_to_siso(priv, lq_sta, conf, sta,\n\t\t\t\t\t\t search_tbl, index);\n\t\t\tif (!ret) {\n\t\t\t\tlq_sta->action_counter = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase IWL_LEGACY_SWITCH_MIMO2_AB:\n\t\tcase IWL_LEGACY_SWITCH_MIMO2_AC:\n\t\tcase IWL_LEGACY_SWITCH_MIMO2_BC:\n\t\t\tIWL_DEBUG_RATE(priv, \"LQ: Legacy switch to MIMO2\\n\");\n\n\t\t\t \n\t\t\tmemcpy(search_tbl, tbl, sz);\n\t\t\tsearch_tbl->is_SGI = 0;\n\n\t\t\tif (tbl->action == IWL_LEGACY_SWITCH_MIMO2_AB)\n\t\t\t\tsearch_tbl->ant_type = ANT_AB;\n\t\t\telse if (tbl->action == IWL_LEGACY_SWITCH_MIMO2_AC)\n\t\t\t\tsearch_tbl->ant_type = ANT_AC;\n\t\t\telse\n\t\t\t\tsearch_tbl->ant_type = ANT_BC;\n\n\t\t\tif (!rs_is_valid_ant(valid_tx_ant, search_tbl->ant_type))\n\t\t\t\tbreak;\n\n\t\t\tret = rs_switch_to_mimo2(priv, lq_sta, conf, sta,\n\t\t\t\t\t\t search_tbl, index);\n\t\t\tif (!ret) {\n\t\t\t\tlq_sta->action_counter = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IWL_LEGACY_SWITCH_MIMO3_ABC:\n\t\t\tIWL_DEBUG_RATE(priv, \"LQ: Legacy switch to MIMO3\\n\");\n\n\t\t\t \n\t\t\tmemcpy(search_tbl, tbl, sz);\n\t\t\tsearch_tbl->is_SGI = 0;\n\n\t\t\tsearch_tbl->ant_type = ANT_ABC;\n\n\t\t\tif (!rs_is_valid_ant(valid_tx_ant, search_tbl->ant_type))\n\t\t\t\tbreak;\n\n\t\t\tret = rs_switch_to_mimo3(priv, lq_sta, conf, sta,\n\t\t\t\t\t\t search_tbl, index);\n\t\t\tif (!ret) {\n\t\t\t\tlq_sta->action_counter = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\ttbl->action++;\n\t\tif (tbl->action > IWL_LEGACY_SWITCH_MIMO3_ABC)\n\t\t\ttbl->action = IWL_LEGACY_SWITCH_ANTENNA1;\n\n\t\tif (tbl->action == start_action)\n\t\t\tbreak;\n\n\t}\n\tsearch_tbl->lq_type = LQ_NONE;\n\treturn;\n\nout:\n\tlq_sta->search_better_tbl = 1;\n\ttbl->action++;\n\tif (tbl->action > IWL_LEGACY_SWITCH_MIMO3_ABC)\n\t\ttbl->action = IWL_LEGACY_SWITCH_ANTENNA1;\n\tif (update_search_tbl_counter)\n\t\tsearch_tbl->action = tbl->action;\n}\n\n \nstatic void rs_move_siso_to_other(struct iwl_priv *priv,\n\t\t\t\t  struct iwl_lq_sta *lq_sta,\n\t\t\t\t  struct ieee80211_conf *conf,\n\t\t\t\t  struct ieee80211_sta *sta, int index)\n{\n\tu8 is_green = lq_sta->is_green;\n\tstruct iwl_scale_tbl_info *tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\n\tstruct iwl_scale_tbl_info *search_tbl =\n\t\t\t\t&(lq_sta->lq_info[(1 - lq_sta->active_tbl)]);\n\tstruct iwl_rate_scale_data *window = &(tbl->win[index]);\n\tstruct ieee80211_sta_ht_cap *ht_cap = &sta->deflink.ht_cap;\n\tu32 sz = (sizeof(struct iwl_scale_tbl_info) -\n\t\t  (sizeof(struct iwl_rate_scale_data) * IWL_RATE_COUNT));\n\tu8 start_action;\n\tu8 valid_tx_ant = priv->nvm_data->valid_tx_ant;\n\tu8 tx_chains_num = priv->hw_params.tx_chains_num;\n\tu8 update_search_tbl_counter = 0;\n\tint ret;\n\n\tswitch (priv->bt_traffic_load) {\n\tcase IWL_BT_COEX_TRAFFIC_LOAD_NONE:\n\t\t \n\t\tbreak;\n\tcase IWL_BT_COEX_TRAFFIC_LOAD_LOW:\n\t\t \n\t\tif (tbl->action == IWL_SISO_SWITCH_ANTENNA2)\n\t\t\ttbl->action = IWL_SISO_SWITCH_MIMO2_AB;\n\t\tbreak;\n\tcase IWL_BT_COEX_TRAFFIC_LOAD_HIGH:\n\tcase IWL_BT_COEX_TRAFFIC_LOAD_CONTINUOUS:\n\t\t \n\t\tvalid_tx_ant =\n\t\t\tfirst_antenna(priv->nvm_data->valid_tx_ant);\n\t\tif (tbl->action != IWL_SISO_SWITCH_ANTENNA1)\n\t\t\ttbl->action = IWL_SISO_SWITCH_ANTENNA1;\n\t\tbreak;\n\tdefault:\n\t\tIWL_ERR(priv, \"Invalid BT load %d\\n\", priv->bt_traffic_load);\n\t\tbreak;\n\t}\n\n\tif (iwl_tx_ant_restriction(priv) == IWL_ANT_OK_SINGLE &&\n\t    tbl->action > IWL_SISO_SWITCH_ANTENNA2) {\n\t\t \n\t\ttbl->action = IWL_SISO_SWITCH_ANTENNA1;\n\t}\n\n\t \n\tif (priv->bt_full_concurrent) {\n\t\tvalid_tx_ant =\n\t\t\tfirst_antenna(priv->nvm_data->valid_tx_ant);\n\t\tif (tbl->action >= IWL_LEGACY_SWITCH_ANTENNA2)\n\t\t\ttbl->action = IWL_SISO_SWITCH_ANTENNA1;\n\t}\n\n\tstart_action = tbl->action;\n\tfor (;;) {\n\t\tlq_sta->action_counter++;\n\t\tswitch (tbl->action) {\n\t\tcase IWL_SISO_SWITCH_ANTENNA1:\n\t\tcase IWL_SISO_SWITCH_ANTENNA2:\n\t\t\tIWL_DEBUG_RATE(priv, \"LQ: SISO toggle Antenna\\n\");\n\t\t\tif ((tbl->action == IWL_SISO_SWITCH_ANTENNA1 &&\n\t\t\t\t\t\ttx_chains_num <= 1) ||\n\t\t\t    (tbl->action == IWL_SISO_SWITCH_ANTENNA2 &&\n\t\t\t\t\t\ttx_chains_num <= 2))\n\t\t\t\tbreak;\n\n\t\t\tif (window->success_ratio >= IWL_RS_GOOD_RATIO &&\n\t\t\t    !priv->bt_full_concurrent &&\n\t\t\t    priv->bt_traffic_load ==\n\t\t\t\t\tIWL_BT_COEX_TRAFFIC_LOAD_NONE)\n\t\t\t\tbreak;\n\n\t\t\tmemcpy(search_tbl, tbl, sz);\n\t\t\tif (rs_toggle_antenna(valid_tx_ant,\n\t\t\t\t       &search_tbl->current_rate, search_tbl)) {\n\t\t\t\tupdate_search_tbl_counter = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IWL_SISO_SWITCH_MIMO2_AB:\n\t\tcase IWL_SISO_SWITCH_MIMO2_AC:\n\t\tcase IWL_SISO_SWITCH_MIMO2_BC:\n\t\t\tIWL_DEBUG_RATE(priv, \"LQ: SISO switch to MIMO2\\n\");\n\t\t\tmemcpy(search_tbl, tbl, sz);\n\t\t\tsearch_tbl->is_SGI = 0;\n\n\t\t\tif (tbl->action == IWL_SISO_SWITCH_MIMO2_AB)\n\t\t\t\tsearch_tbl->ant_type = ANT_AB;\n\t\t\telse if (tbl->action == IWL_SISO_SWITCH_MIMO2_AC)\n\t\t\t\tsearch_tbl->ant_type = ANT_AC;\n\t\t\telse\n\t\t\t\tsearch_tbl->ant_type = ANT_BC;\n\n\t\t\tif (!rs_is_valid_ant(valid_tx_ant, search_tbl->ant_type))\n\t\t\t\tbreak;\n\n\t\t\tret = rs_switch_to_mimo2(priv, lq_sta, conf, sta,\n\t\t\t\t\t\t search_tbl, index);\n\t\t\tif (!ret)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase IWL_SISO_SWITCH_GI:\n\t\t\tif (!tbl->is_ht40 && !(ht_cap->cap &\n\t\t\t\t\t\tIEEE80211_HT_CAP_SGI_20))\n\t\t\t\tbreak;\n\t\t\tif (tbl->is_ht40 && !(ht_cap->cap &\n\t\t\t\t\t\tIEEE80211_HT_CAP_SGI_40))\n\t\t\t\tbreak;\n\n\t\t\tIWL_DEBUG_RATE(priv, \"LQ: SISO toggle SGI/NGI\\n\");\n\n\t\t\tmemcpy(search_tbl, tbl, sz);\n\t\t\tif (is_green) {\n\t\t\t\tif (!tbl->is_SGI)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\tIWL_ERR(priv,\n\t\t\t\t\t\t\"SGI was set in GF+SISO\\n\");\n\t\t\t}\n\t\t\tsearch_tbl->is_SGI = !tbl->is_SGI;\n\t\t\trs_set_expected_tpt_table(lq_sta, search_tbl);\n\t\t\tif (tbl->is_SGI) {\n\t\t\t\ts32 tpt = lq_sta->last_tpt / 100;\n\t\t\t\tif (tpt >= search_tbl->expected_tpt[index])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsearch_tbl->current_rate =\n\t\t\t\trate_n_flags_from_tbl(priv, search_tbl,\n\t\t\t\t\t\t      index, is_green);\n\t\t\tupdate_search_tbl_counter = 1;\n\t\t\tgoto out;\n\t\tcase IWL_SISO_SWITCH_MIMO3_ABC:\n\t\t\tIWL_DEBUG_RATE(priv, \"LQ: SISO switch to MIMO3\\n\");\n\t\t\tmemcpy(search_tbl, tbl, sz);\n\t\t\tsearch_tbl->is_SGI = 0;\n\t\t\tsearch_tbl->ant_type = ANT_ABC;\n\n\t\t\tif (!rs_is_valid_ant(valid_tx_ant, search_tbl->ant_type))\n\t\t\t\tbreak;\n\n\t\t\tret = rs_switch_to_mimo3(priv, lq_sta, conf, sta,\n\t\t\t\t\t\t search_tbl, index);\n\t\t\tif (!ret)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\t}\n\t\ttbl->action++;\n\t\tif (tbl->action > IWL_LEGACY_SWITCH_MIMO3_ABC)\n\t\t\ttbl->action = IWL_SISO_SWITCH_ANTENNA1;\n\n\t\tif (tbl->action == start_action)\n\t\t\tbreak;\n\t}\n\tsearch_tbl->lq_type = LQ_NONE;\n\treturn;\n\n out:\n\tlq_sta->search_better_tbl = 1;\n\ttbl->action++;\n\tif (tbl->action > IWL_SISO_SWITCH_MIMO3_ABC)\n\t\ttbl->action = IWL_SISO_SWITCH_ANTENNA1;\n\tif (update_search_tbl_counter)\n\t\tsearch_tbl->action = tbl->action;\n}\n\n \nstatic void rs_move_mimo2_to_other(struct iwl_priv *priv,\n\t\t\t\t   struct iwl_lq_sta *lq_sta,\n\t\t\t\t   struct ieee80211_conf *conf,\n\t\t\t\t   struct ieee80211_sta *sta, int index)\n{\n\ts8 is_green = lq_sta->is_green;\n\tstruct iwl_scale_tbl_info *tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\n\tstruct iwl_scale_tbl_info *search_tbl =\n\t\t\t\t&(lq_sta->lq_info[(1 - lq_sta->active_tbl)]);\n\tstruct iwl_rate_scale_data *window = &(tbl->win[index]);\n\tstruct ieee80211_sta_ht_cap *ht_cap = &sta->deflink.ht_cap;\n\tu32 sz = (sizeof(struct iwl_scale_tbl_info) -\n\t\t  (sizeof(struct iwl_rate_scale_data) * IWL_RATE_COUNT));\n\tu8 start_action;\n\tu8 valid_tx_ant = priv->nvm_data->valid_tx_ant;\n\tu8 tx_chains_num = priv->hw_params.tx_chains_num;\n\tu8 update_search_tbl_counter = 0;\n\tint ret;\n\n\tswitch (priv->bt_traffic_load) {\n\tcase IWL_BT_COEX_TRAFFIC_LOAD_NONE:\n\t\t \n\t\tbreak;\n\tcase IWL_BT_COEX_TRAFFIC_LOAD_HIGH:\n\tcase IWL_BT_COEX_TRAFFIC_LOAD_CONTINUOUS:\n\t\t \n\t\tif (tbl->action != IWL_MIMO2_SWITCH_SISO_A)\n\t\t\ttbl->action = IWL_MIMO2_SWITCH_SISO_A;\n\t\tbreak;\n\tcase IWL_BT_COEX_TRAFFIC_LOAD_LOW:\n\t\t \n\t\tif (tbl->action == IWL_MIMO2_SWITCH_SISO_B ||\n\t\t    tbl->action == IWL_MIMO2_SWITCH_SISO_C)\n\t\t\ttbl->action = IWL_MIMO2_SWITCH_SISO_A;\n\t\tbreak;\n\tdefault:\n\t\tIWL_ERR(priv, \"Invalid BT load %d\\n\", priv->bt_traffic_load);\n\t\tbreak;\n\t}\n\n\tif ((iwl_tx_ant_restriction(priv) == IWL_ANT_OK_SINGLE) &&\n\t    (tbl->action < IWL_MIMO2_SWITCH_SISO_A ||\n\t     tbl->action > IWL_MIMO2_SWITCH_SISO_C)) {\n\t\t \n\t\ttbl->action = IWL_MIMO2_SWITCH_SISO_A;\n\t}\n\n\t \n\tif (priv->bt_full_concurrent &&\n\t    (tbl->action < IWL_MIMO2_SWITCH_SISO_A ||\n\t     tbl->action > IWL_MIMO2_SWITCH_SISO_C))\n\t\ttbl->action = IWL_MIMO2_SWITCH_SISO_A;\n\n\tstart_action = tbl->action;\n\tfor (;;) {\n\t\tlq_sta->action_counter++;\n\t\tswitch (tbl->action) {\n\t\tcase IWL_MIMO2_SWITCH_ANTENNA1:\n\t\tcase IWL_MIMO2_SWITCH_ANTENNA2:\n\t\t\tIWL_DEBUG_RATE(priv, \"LQ: MIMO2 toggle Antennas\\n\");\n\n\t\t\tif (tx_chains_num <= 2)\n\t\t\t\tbreak;\n\n\t\t\tif (window->success_ratio >= IWL_RS_GOOD_RATIO)\n\t\t\t\tbreak;\n\n\t\t\tmemcpy(search_tbl, tbl, sz);\n\t\t\tif (rs_toggle_antenna(valid_tx_ant,\n\t\t\t\t       &search_tbl->current_rate, search_tbl)) {\n\t\t\t\tupdate_search_tbl_counter = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IWL_MIMO2_SWITCH_SISO_A:\n\t\tcase IWL_MIMO2_SWITCH_SISO_B:\n\t\tcase IWL_MIMO2_SWITCH_SISO_C:\n\t\t\tIWL_DEBUG_RATE(priv, \"LQ: MIMO2 switch to SISO\\n\");\n\n\t\t\t \n\t\t\tmemcpy(search_tbl, tbl, sz);\n\n\t\t\tif (tbl->action == IWL_MIMO2_SWITCH_SISO_A)\n\t\t\t\tsearch_tbl->ant_type = ANT_A;\n\t\t\telse if (tbl->action == IWL_MIMO2_SWITCH_SISO_B)\n\t\t\t\tsearch_tbl->ant_type = ANT_B;\n\t\t\telse\n\t\t\t\tsearch_tbl->ant_type = ANT_C;\n\n\t\t\tif (!rs_is_valid_ant(valid_tx_ant, search_tbl->ant_type))\n\t\t\t\tbreak;\n\n\t\t\tret = rs_switch_to_siso(priv, lq_sta, conf, sta,\n\t\t\t\t\t\t search_tbl, index);\n\t\t\tif (!ret)\n\t\t\t\tgoto out;\n\n\t\t\tbreak;\n\n\t\tcase IWL_MIMO2_SWITCH_GI:\n\t\t\tif (!tbl->is_ht40 && !(ht_cap->cap &\n\t\t\t\t\t\tIEEE80211_HT_CAP_SGI_20))\n\t\t\t\tbreak;\n\t\t\tif (tbl->is_ht40 && !(ht_cap->cap &\n\t\t\t\t\t\tIEEE80211_HT_CAP_SGI_40))\n\t\t\t\tbreak;\n\n\t\t\tIWL_DEBUG_RATE(priv, \"LQ: MIMO2 toggle SGI/NGI\\n\");\n\n\t\t\t \n\t\t\tmemcpy(search_tbl, tbl, sz);\n\t\t\tsearch_tbl->is_SGI = !tbl->is_SGI;\n\t\t\trs_set_expected_tpt_table(lq_sta, search_tbl);\n\t\t\t \n\t\t\tif (tbl->is_SGI) {\n\t\t\t\ts32 tpt = lq_sta->last_tpt / 100;\n\t\t\t\tif (tpt >= search_tbl->expected_tpt[index])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsearch_tbl->current_rate =\n\t\t\t\trate_n_flags_from_tbl(priv, search_tbl,\n\t\t\t\t\t\t      index, is_green);\n\t\t\tupdate_search_tbl_counter = 1;\n\t\t\tgoto out;\n\n\t\tcase IWL_MIMO2_SWITCH_MIMO3_ABC:\n\t\t\tIWL_DEBUG_RATE(priv, \"LQ: MIMO2 switch to MIMO3\\n\");\n\t\t\tmemcpy(search_tbl, tbl, sz);\n\t\t\tsearch_tbl->is_SGI = 0;\n\t\t\tsearch_tbl->ant_type = ANT_ABC;\n\n\t\t\tif (!rs_is_valid_ant(valid_tx_ant, search_tbl->ant_type))\n\t\t\t\tbreak;\n\n\t\t\tret = rs_switch_to_mimo3(priv, lq_sta, conf, sta,\n\t\t\t\t\t\t search_tbl, index);\n\t\t\tif (!ret)\n\t\t\t\tgoto out;\n\n\t\t\tbreak;\n\t\t}\n\t\ttbl->action++;\n\t\tif (tbl->action > IWL_MIMO2_SWITCH_MIMO3_ABC)\n\t\t\ttbl->action = IWL_MIMO2_SWITCH_ANTENNA1;\n\n\t\tif (tbl->action == start_action)\n\t\t\tbreak;\n\t}\n\tsearch_tbl->lq_type = LQ_NONE;\n\treturn;\n out:\n\tlq_sta->search_better_tbl = 1;\n\ttbl->action++;\n\tif (tbl->action > IWL_MIMO2_SWITCH_MIMO3_ABC)\n\t\ttbl->action = IWL_MIMO2_SWITCH_ANTENNA1;\n\tif (update_search_tbl_counter)\n\t\tsearch_tbl->action = tbl->action;\n\n}\n\n \nstatic void rs_move_mimo3_to_other(struct iwl_priv *priv,\n\t\t\t\t   struct iwl_lq_sta *lq_sta,\n\t\t\t\t   struct ieee80211_conf *conf,\n\t\t\t\t   struct ieee80211_sta *sta, int index)\n{\n\ts8 is_green = lq_sta->is_green;\n\tstruct iwl_scale_tbl_info *tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\n\tstruct iwl_scale_tbl_info *search_tbl =\n\t\t\t\t&(lq_sta->lq_info[(1 - lq_sta->active_tbl)]);\n\tstruct iwl_rate_scale_data *window = &(tbl->win[index]);\n\tstruct ieee80211_sta_ht_cap *ht_cap = &sta->deflink.ht_cap;\n\tu32 sz = (sizeof(struct iwl_scale_tbl_info) -\n\t\t  (sizeof(struct iwl_rate_scale_data) * IWL_RATE_COUNT));\n\tu8 start_action;\n\tu8 valid_tx_ant = priv->nvm_data->valid_tx_ant;\n\tu8 tx_chains_num = priv->hw_params.tx_chains_num;\n\tint ret;\n\tu8 update_search_tbl_counter = 0;\n\n\tswitch (priv->bt_traffic_load) {\n\tcase IWL_BT_COEX_TRAFFIC_LOAD_NONE:\n\t\t \n\t\tbreak;\n\tcase IWL_BT_COEX_TRAFFIC_LOAD_HIGH:\n\tcase IWL_BT_COEX_TRAFFIC_LOAD_CONTINUOUS:\n\t\t \n\t\tif (tbl->action != IWL_MIMO3_SWITCH_SISO_A)\n\t\t\ttbl->action = IWL_MIMO3_SWITCH_SISO_A;\n\t\tbreak;\n\tcase IWL_BT_COEX_TRAFFIC_LOAD_LOW:\n\t\t \n\t\tif (tbl->action == IWL_MIMO3_SWITCH_SISO_B ||\n\t\t    tbl->action == IWL_MIMO3_SWITCH_SISO_C)\n\t\t\ttbl->action = IWL_MIMO3_SWITCH_SISO_A;\n\t\tbreak;\n\tdefault:\n\t\tIWL_ERR(priv, \"Invalid BT load %d\\n\", priv->bt_traffic_load);\n\t\tbreak;\n\t}\n\n\tif ((iwl_tx_ant_restriction(priv) == IWL_ANT_OK_SINGLE) &&\n\t    (tbl->action < IWL_MIMO3_SWITCH_SISO_A ||\n\t     tbl->action > IWL_MIMO3_SWITCH_SISO_C)) {\n\t\t \n\t\ttbl->action = IWL_MIMO3_SWITCH_SISO_A;\n\t}\n\n\t \n\tif (priv->bt_full_concurrent &&\n\t    (tbl->action < IWL_MIMO3_SWITCH_SISO_A ||\n\t     tbl->action > IWL_MIMO3_SWITCH_SISO_C))\n\t\ttbl->action = IWL_MIMO3_SWITCH_SISO_A;\n\n\tstart_action = tbl->action;\n\tfor (;;) {\n\t\tlq_sta->action_counter++;\n\t\tswitch (tbl->action) {\n\t\tcase IWL_MIMO3_SWITCH_ANTENNA1:\n\t\tcase IWL_MIMO3_SWITCH_ANTENNA2:\n\t\t\tIWL_DEBUG_RATE(priv, \"LQ: MIMO3 toggle Antennas\\n\");\n\n\t\t\tif (tx_chains_num <= 3)\n\t\t\t\tbreak;\n\n\t\t\tif (window->success_ratio >= IWL_RS_GOOD_RATIO)\n\t\t\t\tbreak;\n\n\t\t\tmemcpy(search_tbl, tbl, sz);\n\t\t\tif (rs_toggle_antenna(valid_tx_ant,\n\t\t\t\t       &search_tbl->current_rate, search_tbl))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase IWL_MIMO3_SWITCH_SISO_A:\n\t\tcase IWL_MIMO3_SWITCH_SISO_B:\n\t\tcase IWL_MIMO3_SWITCH_SISO_C:\n\t\t\tIWL_DEBUG_RATE(priv, \"LQ: MIMO3 switch to SISO\\n\");\n\n\t\t\t \n\t\t\tmemcpy(search_tbl, tbl, sz);\n\n\t\t\tif (tbl->action == IWL_MIMO3_SWITCH_SISO_A)\n\t\t\t\tsearch_tbl->ant_type = ANT_A;\n\t\t\telse if (tbl->action == IWL_MIMO3_SWITCH_SISO_B)\n\t\t\t\tsearch_tbl->ant_type = ANT_B;\n\t\t\telse\n\t\t\t\tsearch_tbl->ant_type = ANT_C;\n\n\t\t\tif (!rs_is_valid_ant(valid_tx_ant, search_tbl->ant_type))\n\t\t\t\tbreak;\n\n\t\t\tret = rs_switch_to_siso(priv, lq_sta, conf, sta,\n\t\t\t\t\t\t search_tbl, index);\n\t\t\tif (!ret)\n\t\t\t\tgoto out;\n\n\t\t\tbreak;\n\n\t\tcase IWL_MIMO3_SWITCH_MIMO2_AB:\n\t\tcase IWL_MIMO3_SWITCH_MIMO2_AC:\n\t\tcase IWL_MIMO3_SWITCH_MIMO2_BC:\n\t\t\tIWL_DEBUG_RATE(priv, \"LQ: MIMO3 switch to MIMO2\\n\");\n\n\t\t\tmemcpy(search_tbl, tbl, sz);\n\t\t\tsearch_tbl->is_SGI = 0;\n\t\t\tif (tbl->action == IWL_MIMO3_SWITCH_MIMO2_AB)\n\t\t\t\tsearch_tbl->ant_type = ANT_AB;\n\t\t\telse if (tbl->action == IWL_MIMO3_SWITCH_MIMO2_AC)\n\t\t\t\tsearch_tbl->ant_type = ANT_AC;\n\t\t\telse\n\t\t\t\tsearch_tbl->ant_type = ANT_BC;\n\n\t\t\tif (!rs_is_valid_ant(valid_tx_ant, search_tbl->ant_type))\n\t\t\t\tbreak;\n\n\t\t\tret = rs_switch_to_mimo2(priv, lq_sta, conf, sta,\n\t\t\t\t\t\t search_tbl, index);\n\t\t\tif (!ret)\n\t\t\t\tgoto out;\n\n\t\t\tbreak;\n\n\t\tcase IWL_MIMO3_SWITCH_GI:\n\t\t\tif (!tbl->is_ht40 && !(ht_cap->cap &\n\t\t\t\t\t\tIEEE80211_HT_CAP_SGI_20))\n\t\t\t\tbreak;\n\t\t\tif (tbl->is_ht40 && !(ht_cap->cap &\n\t\t\t\t\t\tIEEE80211_HT_CAP_SGI_40))\n\t\t\t\tbreak;\n\n\t\t\tIWL_DEBUG_RATE(priv, \"LQ: MIMO3 toggle SGI/NGI\\n\");\n\n\t\t\t \n\t\t\tmemcpy(search_tbl, tbl, sz);\n\t\t\tsearch_tbl->is_SGI = !tbl->is_SGI;\n\t\t\trs_set_expected_tpt_table(lq_sta, search_tbl);\n\t\t\t \n\t\t\tif (tbl->is_SGI) {\n\t\t\t\ts32 tpt = lq_sta->last_tpt / 100;\n\t\t\t\tif (tpt >= search_tbl->expected_tpt[index])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsearch_tbl->current_rate =\n\t\t\t\trate_n_flags_from_tbl(priv, search_tbl,\n\t\t\t\t\t\t      index, is_green);\n\t\t\tupdate_search_tbl_counter = 1;\n\t\t\tgoto out;\n\t\t}\n\t\ttbl->action++;\n\t\tif (tbl->action > IWL_MIMO3_SWITCH_GI)\n\t\t\ttbl->action = IWL_MIMO3_SWITCH_ANTENNA1;\n\n\t\tif (tbl->action == start_action)\n\t\t\tbreak;\n\t}\n\tsearch_tbl->lq_type = LQ_NONE;\n\treturn;\n out:\n\tlq_sta->search_better_tbl = 1;\n\ttbl->action++;\n\tif (tbl->action > IWL_MIMO3_SWITCH_GI)\n\t\ttbl->action = IWL_MIMO3_SWITCH_ANTENNA1;\n\tif (update_search_tbl_counter)\n\t\tsearch_tbl->action = tbl->action;\n}\n\n \nstatic void rs_stay_in_table(struct iwl_lq_sta *lq_sta, bool force_search)\n{\n\tstruct iwl_scale_tbl_info *tbl;\n\tint i;\n\tint active_tbl;\n\tint flush_interval_passed = 0;\n\tstruct iwl_priv *priv;\n\n\tpriv = lq_sta->drv;\n\tactive_tbl = lq_sta->active_tbl;\n\n\ttbl = &(lq_sta->lq_info[active_tbl]);\n\n\t \n\tif (lq_sta->stay_in_tbl) {\n\n\t\t \n\t\tif (lq_sta->flush_timer)\n\t\t\tflush_interval_passed =\n\t\t\ttime_after(jiffies,\n\t\t\t\t\t(unsigned long)(lq_sta->flush_timer +\n\t\t\t\t\tIWL_RATE_SCALE_FLUSH_INTVL));\n\n\t\t \n\t\tif (force_search ||\n\t\t    (lq_sta->total_failed > lq_sta->max_failure_limit) ||\n\t\t    (lq_sta->total_success > lq_sta->max_success_limit) ||\n\t\t    ((!lq_sta->search_better_tbl) && (lq_sta->flush_timer)\n\t\t     && (flush_interval_passed))) {\n\t\t\tIWL_DEBUG_RATE(priv, \"LQ: stay is expired %d %d %d\\n\",\n\t\t\t\t     lq_sta->total_failed,\n\t\t\t\t     lq_sta->total_success,\n\t\t\t\t     flush_interval_passed);\n\n\t\t\t \n\t\t\tlq_sta->stay_in_tbl = 0;\t \n\t\t\tlq_sta->total_failed = 0;\n\t\t\tlq_sta->total_success = 0;\n\t\t\tlq_sta->flush_timer = 0;\n\n\t\t \n\t\t} else {\n\t\t\tlq_sta->table_count++;\n\t\t\tif (lq_sta->table_count >=\n\t\t\t    lq_sta->table_count_limit) {\n\t\t\t\tlq_sta->table_count = 0;\n\n\t\t\t\tIWL_DEBUG_RATE(priv, \"LQ: stay in table clear win\\n\");\n\t\t\t\tfor (i = 0; i < IWL_RATE_COUNT; i++)\n\t\t\t\t\trs_rate_scale_clear_window(\n\t\t\t\t\t\t&(tbl->win[i]));\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!lq_sta->stay_in_tbl) {\n\t\t\tfor (i = 0; i < IWL_RATE_COUNT; i++)\n\t\t\t\trs_rate_scale_clear_window(&(tbl->win[i]));\n\t\t}\n\t}\n}\n\n \nstatic void rs_update_rate_tbl(struct iwl_priv *priv,\n\t\t\t       struct iwl_rxon_context *ctx,\n\t\t\t       struct iwl_lq_sta *lq_sta,\n\t\t\t       struct iwl_scale_tbl_info *tbl,\n\t\t\t       int index, u8 is_green)\n{\n\tu32 rate;\n\n\t \n\trate = rate_n_flags_from_tbl(priv, tbl, index, is_green);\n\trs_fill_link_cmd(priv, lq_sta, rate);\n\tiwl_send_lq_cmd(priv, ctx, &lq_sta->lq, CMD_ASYNC, false);\n}\n\n \nstatic void rs_rate_scale_perform(struct iwl_priv *priv,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t  struct iwl_lq_sta *lq_sta)\n{\n\tstruct ieee80211_hw *hw = priv->hw;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tint low = IWL_RATE_INVALID;\n\tint high = IWL_RATE_INVALID;\n\tint index;\n\tint i;\n\tstruct iwl_rate_scale_data *window = NULL;\n\tint current_tpt = IWL_INVALID_VALUE;\n\tint low_tpt = IWL_INVALID_VALUE;\n\tint high_tpt = IWL_INVALID_VALUE;\n\tu32 fail_count;\n\ts8 scale_action = 0;\n\tu16 rate_mask;\n\tu8 update_lq = 0;\n\tstruct iwl_scale_tbl_info *tbl, *tbl1;\n\tu16 rate_scale_index_msk = 0;\n\tu8 is_green = 0;\n\tu8 active_tbl = 0;\n\tu8 done_search = 0;\n\tu16 high_low;\n\ts32 sr;\n\tu8 tid = IWL_MAX_TID_COUNT;\n\tstruct iwl_tid_data *tid_data;\n\tstruct iwl_station_priv *sta_priv = (void *)sta->drv_priv;\n\tstruct iwl_rxon_context *ctx = sta_priv->ctx;\n\n\tIWL_DEBUG_RATE(priv, \"rate scale calculate new rate for skb\\n\");\n\n\t \n\t \n\tif (!ieee80211_is_data(hdr->frame_control) ||\n\t    info->flags & IEEE80211_TX_CTL_NO_ACK)\n\t\treturn;\n\n\tlq_sta->supp_rates = sta->deflink.supp_rates[lq_sta->band];\n\n\ttid = rs_tl_add_packet(lq_sta, hdr);\n\tif ((tid != IWL_MAX_TID_COUNT) &&\n\t    (lq_sta->tx_agg_tid_en & (1 << tid))) {\n\t\ttid_data = &priv->tid_data[lq_sta->lq.sta_id][tid];\n\t\tif (tid_data->agg.state == IWL_AGG_OFF)\n\t\t\tlq_sta->is_agg = 0;\n\t\telse\n\t\t\tlq_sta->is_agg = 1;\n\t} else\n\t\tlq_sta->is_agg = 0;\n\n\t \n\tif (!lq_sta->search_better_tbl)\n\t\tactive_tbl = lq_sta->active_tbl;\n\telse\n\t\tactive_tbl = 1 - lq_sta->active_tbl;\n\n\ttbl = &(lq_sta->lq_info[active_tbl]);\n\tif (is_legacy(tbl->lq_type))\n\t\tlq_sta->is_green = 0;\n\telse\n\t\tlq_sta->is_green = rs_use_green(sta);\n\tis_green = lq_sta->is_green;\n\n\t \n\tindex = lq_sta->last_txrate_idx;\n\n\tIWL_DEBUG_RATE(priv, \"Rate scale index %d for type %d\\n\", index,\n\t\t       tbl->lq_type);\n\n\t \n\trate_mask = rs_get_supported_rates(lq_sta, hdr, tbl->lq_type);\n\n\tIWL_DEBUG_RATE(priv, \"mask 0x%04X\\n\", rate_mask);\n\n\t \n\tif (is_legacy(tbl->lq_type)) {\n\t\tif (lq_sta->band == NL80211_BAND_5GHZ)\n\t\t\t \n\t\t\trate_scale_index_msk = (u16) (rate_mask &\n\t\t\t\t(lq_sta->supp_rates << IWL_FIRST_OFDM_RATE));\n\t\telse\n\t\t\trate_scale_index_msk = (u16) (rate_mask &\n\t\t\t\t\t\t      lq_sta->supp_rates);\n\n\t} else\n\t\trate_scale_index_msk = rate_mask;\n\n\tif (!rate_scale_index_msk)\n\t\trate_scale_index_msk = rate_mask;\n\n\tif (!((1 << index) & rate_scale_index_msk)) {\n\t\tIWL_ERR(priv, \"Current Rate is not valid\\n\");\n\t\tif (lq_sta->search_better_tbl) {\n\t\t\t \n\t\t\ttbl->lq_type = LQ_NONE;\n\t\t\tlq_sta->search_better_tbl = 0;\n\t\t\ttbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\n\t\t\t \n\t\t\tindex = iwl_hwrate_to_plcp_idx(tbl->current_rate);\n\t\t\trs_update_rate_tbl(priv, ctx, lq_sta, tbl,\n\t\t\t\t\t   index, is_green);\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tif (!tbl->expected_tpt) {\n\t\tIWL_ERR(priv, \"tbl->expected_tpt is NULL\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif ((lq_sta->max_rate_idx != -1) &&\n\t    (lq_sta->max_rate_idx < index)) {\n\t\tindex = lq_sta->max_rate_idx;\n\t\tupdate_lq = 1;\n\t\twindow = &(tbl->win[index]);\n\t\tgoto lq_update;\n\t}\n\n\twindow = &(tbl->win[index]);\n\n\t \n\tfail_count = window->counter - window->success_counter;\n\tif ((fail_count < IWL_RATE_MIN_FAILURE_TH) &&\n\t\t\t(window->success_counter < IWL_RATE_MIN_SUCCESS_TH)) {\n\t\tIWL_DEBUG_RATE(priv, \"LQ: still below TH. succ=%d total=%d \"\n\t\t\t       \"for index %d\\n\",\n\t\t\t       window->success_counter, window->counter, index);\n\n\t\t \n\t\twindow->average_tpt = IWL_INVALID_VALUE;\n\n\t\t \n\t\trs_stay_in_table(lq_sta, false);\n\n\t\tgoto out;\n\t}\n\t \n\tif (window->average_tpt != ((window->success_ratio *\n\t\t\ttbl->expected_tpt[index] + 64) / 128)) {\n\t\tIWL_ERR(priv, \"expected_tpt should have been calculated by now\\n\");\n\t\twindow->average_tpt = ((window->success_ratio *\n\t\t\t\t\ttbl->expected_tpt[index] + 64) / 128);\n\t}\n\n\t \n\tif (lq_sta->search_better_tbl &&\n\t    (iwl_tx_ant_restriction(priv) == IWL_ANT_OK_MULTI)) {\n\t\t \n\t\tif (window->average_tpt > lq_sta->last_tpt) {\n\n\t\t\tIWL_DEBUG_RATE(priv, \"LQ: SWITCHING TO NEW TABLE \"\n\t\t\t\t\t\"suc=%d cur-tpt=%d old-tpt=%d\\n\",\n\t\t\t\t\twindow->success_ratio,\n\t\t\t\t\twindow->average_tpt,\n\t\t\t\t\tlq_sta->last_tpt);\n\n\t\t\tif (!is_legacy(tbl->lq_type))\n\t\t\t\tlq_sta->enable_counter = 1;\n\n\t\t\t \n\t\t\tlq_sta->active_tbl = active_tbl;\n\t\t\tcurrent_tpt = window->average_tpt;\n\n\t\t \n\t\t} else {\n\n\t\t\tIWL_DEBUG_RATE(priv, \"LQ: GOING BACK TO THE OLD TABLE \"\n\t\t\t\t\t\"suc=%d cur-tpt=%d old-tpt=%d\\n\",\n\t\t\t\t\twindow->success_ratio,\n\t\t\t\t\twindow->average_tpt,\n\t\t\t\t\tlq_sta->last_tpt);\n\n\t\t\t \n\t\t\ttbl->lq_type = LQ_NONE;\n\n\t\t\t \n\t\t\tactive_tbl = lq_sta->active_tbl;\n\t\t\ttbl = &(lq_sta->lq_info[active_tbl]);\n\n\t\t\t \n\t\t\tindex = iwl_hwrate_to_plcp_idx(tbl->current_rate);\n\t\t\tcurrent_tpt = lq_sta->last_tpt;\n\n\t\t\t \n\t\t\tupdate_lq = 1;\n\t\t}\n\n\t\t \n\t\tlq_sta->search_better_tbl = 0;\n\t\tdone_search = 1;\t \n\t\tgoto lq_update;\n\t}\n\n\t \n\thigh_low = rs_get_adjacent_rate(priv, index, rate_scale_index_msk,\n\t\t\t\t\ttbl->lq_type);\n\tlow = high_low & 0xff;\n\thigh = (high_low >> 8) & 0xff;\n\n\t \n\tif ((lq_sta->max_rate_idx != -1) &&\n\t    (lq_sta->max_rate_idx < high))\n\t\thigh = IWL_RATE_INVALID;\n\n\tsr = window->success_ratio;\n\n\t \n\tcurrent_tpt = window->average_tpt;\n\tif (low != IWL_RATE_INVALID)\n\t\tlow_tpt = tbl->win[low].average_tpt;\n\tif (high != IWL_RATE_INVALID)\n\t\thigh_tpt = tbl->win[high].average_tpt;\n\n\tscale_action = 0;\n\n\t \n\tif ((sr <= IWL_RATE_DECREASE_TH) || (current_tpt == 0)) {\n\t\tIWL_DEBUG_RATE(priv, \"decrease rate because of low success_ratio\\n\");\n\t\tscale_action = -1;\n\n\t \n\t} else if ((low_tpt == IWL_INVALID_VALUE) &&\n\t\t   (high_tpt == IWL_INVALID_VALUE)) {\n\n\t\tif (high != IWL_RATE_INVALID && sr >= IWL_RATE_INCREASE_TH)\n\t\t\tscale_action = 1;\n\t\telse if (low != IWL_RATE_INVALID)\n\t\t\tscale_action = 0;\n\t}\n\n\t \n\telse if ((low_tpt != IWL_INVALID_VALUE) &&\n\t\t (high_tpt != IWL_INVALID_VALUE) &&\n\t\t (low_tpt < current_tpt) &&\n\t\t (high_tpt < current_tpt))\n\t\tscale_action = 0;\n\n\t \n\telse {\n\t\t \n\t\tif (high_tpt != IWL_INVALID_VALUE) {\n\t\t\t \n\t\t\tif (high_tpt > current_tpt &&\n\t\t\t\t\tsr >= IWL_RATE_INCREASE_TH) {\n\t\t\t\tscale_action = 1;\n\t\t\t} else {\n\t\t\t\tscale_action = 0;\n\t\t\t}\n\n\t\t \n\t\t} else if (low_tpt != IWL_INVALID_VALUE) {\n\t\t\t \n\t\t\tif (low_tpt > current_tpt) {\n\t\t\t\tIWL_DEBUG_RATE(priv,\n\t\t\t\t    \"decrease rate because of low tpt\\n\");\n\t\t\t\tscale_action = -1;\n\t\t\t} else if (sr >= IWL_RATE_INCREASE_TH) {\n\t\t\t\tscale_action = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif ((scale_action == -1) && (low != IWL_RATE_INVALID) &&\n\t\t    ((sr > IWL_RATE_HIGH_TH) ||\n\t\t     (current_tpt > (100 * tbl->expected_tpt[low]))))\n\t\tscale_action = 0;\n\tif (!iwl_ht_enabled(priv) && !is_legacy(tbl->lq_type))\n\t\tscale_action = -1;\n\tif (iwl_tx_ant_restriction(priv) != IWL_ANT_OK_MULTI &&\n\t\t(is_mimo2(tbl->lq_type) || is_mimo3(tbl->lq_type)))\n\t\tscale_action = -1;\n\n\tif ((priv->bt_traffic_load >= IWL_BT_COEX_TRAFFIC_LOAD_HIGH) &&\n\t     (is_mimo2(tbl->lq_type) || is_mimo3(tbl->lq_type))) {\n\t\tif (lq_sta->last_bt_traffic > priv->bt_traffic_load) {\n\t\t\t \n\t\t} else if (lq_sta->last_bt_traffic <= priv->bt_traffic_load) {\n\t\t\tscale_action = -1;\n\t\t}\n\t}\n\tlq_sta->last_bt_traffic = priv->bt_traffic_load;\n\n\tif ((priv->bt_traffic_load >= IWL_BT_COEX_TRAFFIC_LOAD_HIGH) &&\n\t     (is_mimo2(tbl->lq_type) || is_mimo3(tbl->lq_type))) {\n\t\t \n\t\trs_stay_in_table(lq_sta, true);\n\t\tgoto lq_update;\n\t}\n\n\tswitch (scale_action) {\n\tcase -1:\n\t\t \n\t\tif (low != IWL_RATE_INVALID) {\n\t\t\tupdate_lq = 1;\n\t\t\tindex = low;\n\t\t}\n\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tif (high != IWL_RATE_INVALID) {\n\t\t\tupdate_lq = 1;\n\t\t\tindex = high;\n\t\t}\n\n\t\tbreak;\n\tcase 0:\n\t\t \n\tdefault:\n\t\tbreak;\n\t}\n\n\tIWL_DEBUG_RATE(priv, \"choose rate scale index %d action %d low %d \"\n\t\t    \"high %d type %d\\n\",\n\t\t     index, scale_action, low, high, tbl->lq_type);\n\nlq_update:\n\t \n\tif (update_lq)\n\t\trs_update_rate_tbl(priv, ctx, lq_sta, tbl, index, is_green);\n\n\tif (iwl_tx_ant_restriction(priv) == IWL_ANT_OK_MULTI) {\n\t\t \n\t  rs_stay_in_table(lq_sta, false);\n\t}\n\t \n\tif (!update_lq && !done_search && !lq_sta->stay_in_tbl && window->counter) {\n\t\t \n\t\tlq_sta->last_tpt = current_tpt;\n\n\t\t \n\t\tif (is_legacy(tbl->lq_type))\n\t\t\trs_move_legacy_other(priv, lq_sta, conf, sta, index);\n\t\telse if (is_siso(tbl->lq_type))\n\t\t\trs_move_siso_to_other(priv, lq_sta, conf, sta, index);\n\t\telse if (is_mimo2(tbl->lq_type))\n\t\t\trs_move_mimo2_to_other(priv, lq_sta, conf, sta, index);\n\t\telse\n\t\t\trs_move_mimo3_to_other(priv, lq_sta, conf, sta, index);\n\n\t\t \n\t\tif (lq_sta->search_better_tbl) {\n\t\t\t \n\t\t\ttbl = &(lq_sta->lq_info[(1 - lq_sta->active_tbl)]);\n\t\t\tfor (i = 0; i < IWL_RATE_COUNT; i++)\n\t\t\t\trs_rate_scale_clear_window(&(tbl->win[i]));\n\n\t\t\t \n\t\t\tindex = iwl_hwrate_to_plcp_idx(tbl->current_rate);\n\n\t\t\tIWL_DEBUG_RATE(priv, \"Switch current  mcs: %X index: %d\\n\",\n\t\t\t\t     tbl->current_rate, index);\n\t\t\trs_fill_link_cmd(priv, lq_sta, tbl->current_rate);\n\t\t\tiwl_send_lq_cmd(priv, ctx, &lq_sta->lq, CMD_ASYNC, false);\n\t\t} else\n\t\t\tdone_search = 1;\n\t}\n\n\tif (done_search && !lq_sta->stay_in_tbl) {\n\t\t \n\t\ttbl1 = &(lq_sta->lq_info[lq_sta->active_tbl]);\n\t\tif (is_legacy(tbl1->lq_type) && !conf_is_ht(conf) &&\n\t\t    lq_sta->action_counter > tbl1->max_search) {\n\t\t\tIWL_DEBUG_RATE(priv, \"LQ: STAY in legacy table\\n\");\n\t\t\trs_set_stay_in_table(priv, 1, lq_sta);\n\t\t}\n\n\t\t \n\t\tif (lq_sta->enable_counter &&\n\t\t    (lq_sta->action_counter >= tbl1->max_search) &&\n\t\t    iwl_ht_enabled(priv)) {\n\t\t\tif ((lq_sta->last_tpt > IWL_AGG_TPT_THREHOLD) &&\n\t\t\t    (lq_sta->tx_agg_tid_en & (1 << tid)) &&\n\t\t\t    (tid != IWL_MAX_TID_COUNT)) {\n\t\t\t\tu8 sta_id = lq_sta->lq.sta_id;\n\t\t\t\ttid_data = &priv->tid_data[sta_id][tid];\n\t\t\t\tif (tid_data->agg.state == IWL_AGG_OFF) {\n\t\t\t\t\tIWL_DEBUG_RATE(priv,\n\t\t\t\t\t\t       \"try to aggregate tid %d\\n\",\n\t\t\t\t\t\t       tid);\n\t\t\t\t\trs_tl_turn_on_agg(priv, tid,\n\t\t\t\t\t\t\t  lq_sta, sta);\n\t\t\t\t}\n\t\t\t}\n\t\t\trs_set_stay_in_table(priv, 0, lq_sta);\n\t\t}\n\t}\n\nout:\n\ttbl->current_rate = rate_n_flags_from_tbl(priv, tbl, index, is_green);\n\tlq_sta->last_txrate_idx = index;\n}\n\n \nstatic void rs_initialize_lq(struct iwl_priv *priv,\n\t\t\t     struct ieee80211_sta *sta,\n\t\t\t     struct iwl_lq_sta *lq_sta)\n{\n\tstruct iwl_scale_tbl_info *tbl;\n\tint rate_idx;\n\tint i;\n\tu32 rate;\n\tu8 use_green = rs_use_green(sta);\n\tu8 active_tbl = 0;\n\tu8 valid_tx_ant;\n\tstruct iwl_station_priv *sta_priv;\n\tstruct iwl_rxon_context *ctx;\n\n\tif (!sta || !lq_sta)\n\t\treturn;\n\n\tsta_priv = (void *)sta->drv_priv;\n\tctx = sta_priv->ctx;\n\n\ti = lq_sta->last_txrate_idx;\n\n\tvalid_tx_ant = priv->nvm_data->valid_tx_ant;\n\n\tif (!lq_sta->search_better_tbl)\n\t\tactive_tbl = lq_sta->active_tbl;\n\telse\n\t\tactive_tbl = 1 - lq_sta->active_tbl;\n\n\ttbl = &(lq_sta->lq_info[active_tbl]);\n\n\tif ((i < 0) || (i >= IWL_RATE_COUNT))\n\t\ti = 0;\n\n\trate = iwl_rates[i].plcp;\n\ttbl->ant_type = first_antenna(valid_tx_ant);\n\trate |= tbl->ant_type << RATE_MCS_ANT_POS;\n\n\tif (i >= IWL_FIRST_CCK_RATE && i <= IWL_LAST_CCK_RATE)\n\t\trate |= RATE_MCS_CCK_MSK;\n\n\trs_get_tbl_info_from_mcs(rate, priv->band, tbl, &rate_idx);\n\tif (!rs_is_valid_ant(valid_tx_ant, tbl->ant_type))\n\t    rs_toggle_antenna(valid_tx_ant, &rate, tbl);\n\n\trate = rate_n_flags_from_tbl(priv, tbl, rate_idx, use_green);\n\ttbl->current_rate = rate;\n\trs_set_expected_tpt_table(lq_sta, tbl);\n\trs_fill_link_cmd(NULL, lq_sta, rate);\n\tpriv->stations[lq_sta->lq.sta_id].lq = &lq_sta->lq;\n\tiwl_send_lq_cmd(priv, ctx, &lq_sta->lq, 0, true);\n}\n\nstatic void rs_get_rate(void *priv_r, struct ieee80211_sta *sta, void *priv_sta,\n\t\t\tstruct ieee80211_tx_rate_control *txrc)\n{\n\n\tstruct sk_buff *skb = txrc->skb;\n\tstruct ieee80211_supported_band *sband = txrc->sband;\n\tstruct iwl_op_mode *op_mode __maybe_unused =\n\t\t\t(struct iwl_op_mode *)priv_r;\n\tstruct iwl_priv *priv __maybe_unused = IWL_OP_MODE_GET_DVM(op_mode);\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct iwl_lq_sta *lq_sta = priv_sta;\n\tint rate_idx;\n\n\tIWL_DEBUG_RATE_LIMIT(priv, \"rate scale calculate new rate for skb\\n\");\n\n\t \n\tif (lq_sta) {\n\t\tlq_sta->max_rate_idx = fls(txrc->rate_idx_mask) - 1;\n\t\tif ((sband->band == NL80211_BAND_5GHZ) &&\n\t\t    (lq_sta->max_rate_idx != -1))\n\t\t\tlq_sta->max_rate_idx += IWL_FIRST_OFDM_RATE;\n\t\tif ((lq_sta->max_rate_idx < 0) ||\n\t\t    (lq_sta->max_rate_idx >= IWL_RATE_COUNT))\n\t\t\tlq_sta->max_rate_idx = -1;\n\t}\n\n\t \n\tif (lq_sta && !lq_sta->drv) {\n\t\tIWL_DEBUG_RATE(priv, \"Rate scaling not initialized yet.\\n\");\n\t\tpriv_sta = NULL;\n\t}\n\n\trate_idx  = lq_sta->last_txrate_idx;\n\n\tif (lq_sta->last_rate_n_flags & RATE_MCS_HT_MSK) {\n\t\trate_idx -= IWL_FIRST_OFDM_RATE;\n\t\t \n\t\trate_idx = (rate_idx > 0) ? (rate_idx - 1) : 0;\n\t\tif (rs_extract_rate(lq_sta->last_rate_n_flags) >=\n\t\t    IWL_RATE_MIMO3_6M_PLCP)\n\t\t\trate_idx = rate_idx + (2 * MCS_INDEX_PER_STREAM);\n\t\telse if (rs_extract_rate(lq_sta->last_rate_n_flags) >=\n\t\t\t IWL_RATE_MIMO2_6M_PLCP)\n\t\t\trate_idx = rate_idx + MCS_INDEX_PER_STREAM;\n\t\tinfo->control.rates[0].flags = IEEE80211_TX_RC_MCS;\n\t\tif (lq_sta->last_rate_n_flags & RATE_MCS_SGI_MSK)\n\t\t\tinfo->control.rates[0].flags |= IEEE80211_TX_RC_SHORT_GI;\n\t\tif (lq_sta->last_rate_n_flags & RATE_MCS_DUP_MSK)\n\t\t\tinfo->control.rates[0].flags |= IEEE80211_TX_RC_DUP_DATA;\n\t\tif (lq_sta->last_rate_n_flags & RATE_MCS_HT40_MSK)\n\t\t\tinfo->control.rates[0].flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\n\t\tif (lq_sta->last_rate_n_flags & RATE_MCS_GF_MSK)\n\t\t\tinfo->control.rates[0].flags |= IEEE80211_TX_RC_GREEN_FIELD;\n\t} else {\n\t\t \n\t\tif ((rate_idx < 0) || (rate_idx >= IWL_RATE_COUNT_LEGACY) ||\n\t\t\t\t((sband->band == NL80211_BAND_5GHZ) &&\n\t\t\t\t (rate_idx < IWL_FIRST_OFDM_RATE)))\n\t\t\trate_idx = rate_lowest_index(sband, sta);\n\t\t \n\t\telse if (sband->band == NL80211_BAND_5GHZ)\n\t\t\trate_idx -= IWL_FIRST_OFDM_RATE;\n\t\tinfo->control.rates[0].flags = 0;\n\t}\n\tinfo->control.rates[0].idx = rate_idx;\n\tinfo->control.rates[0].count = 1;\n}\n\nstatic void *rs_alloc_sta(void *priv_rate, struct ieee80211_sta *sta,\n\t\t\t  gfp_t gfp)\n{\n\tstruct iwl_station_priv *sta_priv = (struct iwl_station_priv *) sta->drv_priv;\n\tstruct iwl_op_mode *op_mode __maybe_unused =\n\t\t\t(struct iwl_op_mode *)priv_rate;\n\tstruct iwl_priv *priv __maybe_unused = IWL_OP_MODE_GET_DVM(op_mode);\n\n\tIWL_DEBUG_RATE(priv, \"create station rate scale window\\n\");\n\n\treturn &sta_priv->lq_sta;\n}\n\n \nvoid iwl_rs_rate_init(struct iwl_priv *priv, struct ieee80211_sta *sta, u8 sta_id)\n{\n\tint i, j;\n\tstruct ieee80211_hw *hw = priv->hw;\n\tstruct ieee80211_conf *conf = &priv->hw->conf;\n\tstruct ieee80211_sta_ht_cap *ht_cap = &sta->deflink.ht_cap;\n\tstruct iwl_station_priv *sta_priv;\n\tstruct iwl_lq_sta *lq_sta;\n\tstruct ieee80211_supported_band *sband;\n\tunsigned long supp;  \n\n\tsta_priv = (struct iwl_station_priv *) sta->drv_priv;\n\tlq_sta = &sta_priv->lq_sta;\n\tsband = hw->wiphy->bands[conf->chandef.chan->band];\n\n\n\tlq_sta->lq.sta_id = sta_id;\n\n\tfor (j = 0; j < LQ_SIZE; j++)\n\t\tfor (i = 0; i < IWL_RATE_COUNT; i++)\n\t\t\trs_rate_scale_clear_window(&lq_sta->lq_info[j].win[i]);\n\n\tlq_sta->flush_timer = 0;\n\tlq_sta->supp_rates = sta->deflink.supp_rates[sband->band];\n\n\tIWL_DEBUG_RATE(priv, \"LQ: *** rate scale station global init for station %d ***\\n\",\n\t\t       sta_id);\n\t \n\n\tlq_sta->is_dup = 0;\n\tlq_sta->max_rate_idx = -1;\n\tlq_sta->missed_rate_counter = IWL_MISSED_RATE_MAX;\n\tlq_sta->is_green = rs_use_green(sta);\n\tlq_sta->band = sband->band;\n\t \n\tsupp = sta->deflink.supp_rates[sband->band];\n\tlq_sta->active_legacy_rate = 0;\n\tfor_each_set_bit(i, &supp, BITS_PER_LONG)\n\t\tlq_sta->active_legacy_rate |= BIT(sband->bitrates[i].hw_value);\n\n\t \n\tlq_sta->active_siso_rate = ht_cap->mcs.rx_mask[0] << 1;\n\tlq_sta->active_siso_rate |= ht_cap->mcs.rx_mask[0] & 0x1;\n\tlq_sta->active_siso_rate &= ~((u16)0x2);\n\tlq_sta->active_siso_rate <<= IWL_FIRST_OFDM_RATE;\n\n\t \n\tlq_sta->active_mimo2_rate = ht_cap->mcs.rx_mask[1] << 1;\n\tlq_sta->active_mimo2_rate |= ht_cap->mcs.rx_mask[1] & 0x1;\n\tlq_sta->active_mimo2_rate &= ~((u16)0x2);\n\tlq_sta->active_mimo2_rate <<= IWL_FIRST_OFDM_RATE;\n\n\tlq_sta->active_mimo3_rate = ht_cap->mcs.rx_mask[2] << 1;\n\tlq_sta->active_mimo3_rate |= ht_cap->mcs.rx_mask[2] & 0x1;\n\tlq_sta->active_mimo3_rate &= ~((u16)0x2);\n\tlq_sta->active_mimo3_rate <<= IWL_FIRST_OFDM_RATE;\n\n\tIWL_DEBUG_RATE(priv, \"SISO-RATE=%X MIMO2-RATE=%X MIMO3-RATE=%X\\n\",\n\t\t     lq_sta->active_siso_rate,\n\t\t     lq_sta->active_mimo2_rate,\n\t\t     lq_sta->active_mimo3_rate);\n\n\t \n\tlq_sta->lq.general_params.single_stream_ant_msk =\n\t\tfirst_antenna(priv->nvm_data->valid_tx_ant);\n\tlq_sta->lq.general_params.dual_stream_ant_msk =\n\t\tpriv->nvm_data->valid_tx_ant &\n\t\t~first_antenna(priv->nvm_data->valid_tx_ant);\n\tif (!lq_sta->lq.general_params.dual_stream_ant_msk) {\n\t\tlq_sta->lq.general_params.dual_stream_ant_msk = ANT_AB;\n\t} else if (num_of_ant(priv->nvm_data->valid_tx_ant) == 2) {\n\t\tlq_sta->lq.general_params.dual_stream_ant_msk =\n\t\t\tpriv->nvm_data->valid_tx_ant;\n\t}\n\n\t \n\tlq_sta->tx_agg_tid_en = IWL_AGG_ALL_TID;\n\tlq_sta->drv = priv;\n\n\t \n\tlq_sta->last_txrate_idx = rate_lowest_index(sband, sta);\n\tif (sband->band == NL80211_BAND_5GHZ)\n\t\tlq_sta->last_txrate_idx += IWL_FIRST_OFDM_RATE;\n\tlq_sta->is_agg = 0;\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tlq_sta->dbg_fixed_rate = 0;\n#endif\n\n\trs_initialize_lq(priv, sta, lq_sta);\n}\n\nstatic void rs_fill_link_cmd(struct iwl_priv *priv,\n\t\t\t     struct iwl_lq_sta *lq_sta, u32 new_rate)\n{\n\tstruct iwl_scale_tbl_info tbl_type;\n\tint index = 0;\n\tint rate_idx;\n\tint repeat_rate = 0;\n\tu8 ant_toggle_cnt = 0;\n\tu8 use_ht_possible = 1;\n\tu8 valid_tx_ant = 0;\n\tstruct iwl_station_priv *sta_priv =\n\t\tcontainer_of(lq_sta, struct iwl_station_priv, lq_sta);\n\tstruct iwl_link_quality_cmd *lq_cmd = &lq_sta->lq;\n\n\t \n\trs_dbgfs_set_mcs(lq_sta, &new_rate, index);\n\n\t \n\trs_get_tbl_info_from_mcs(new_rate, lq_sta->band,\n\t\t\t\t  &tbl_type, &rate_idx);\n\n\tif (priv && priv->bt_full_concurrent) {\n\t\t \n\t\ttbl_type.ant_type =\n\t\t\tfirst_antenna(priv->nvm_data->valid_tx_ant);\n\t}\n\n\t \n\tif (is_legacy(tbl_type.lq_type)) {\n\t\tant_toggle_cnt = 1;\n\t\trepeat_rate = IWL_NUMBER_TRY;\n\t} else {\n\t\trepeat_rate = min(IWL_HT_NUMBER_TRY,\n\t\t\t\t  LINK_QUAL_AGG_DISABLE_START_DEF - 1);\n\t}\n\n\tlq_cmd->general_params.mimo_delimiter =\n\t\t\tis_mimo(tbl_type.lq_type) ? 1 : 0;\n\n\t \n\tlq_cmd->rs_table[index].rate_n_flags = cpu_to_le32(new_rate);\n\n\tif (num_of_ant(tbl_type.ant_type) == 1) {\n\t\tlq_cmd->general_params.single_stream_ant_msk =\n\t\t\t\t\t\ttbl_type.ant_type;\n\t} else if (num_of_ant(tbl_type.ant_type) == 2) {\n\t\tlq_cmd->general_params.dual_stream_ant_msk =\n\t\t\t\t\t\ttbl_type.ant_type;\n\t}  \n\n\tindex++;\n\trepeat_rate--;\n\tif (priv) {\n\t\tif (priv->bt_full_concurrent)\n\t\t\tvalid_tx_ant = ANT_A;\n\t\telse\n\t\t\tvalid_tx_ant = priv->nvm_data->valid_tx_ant;\n\t}\n\n\t \n\twhile (index < LINK_QUAL_MAX_RETRY_NUM) {\n\t\t \n\t\twhile (repeat_rate > 0 && (index < LINK_QUAL_MAX_RETRY_NUM)) {\n\t\t\tif (is_legacy(tbl_type.lq_type)) {\n\t\t\t\tif (ant_toggle_cnt < NUM_TRY_BEFORE_ANT_TOGGLE)\n\t\t\t\t\tant_toggle_cnt++;\n\t\t\t\telse if (priv &&\n\t\t\t\t\t rs_toggle_antenna(valid_tx_ant,\n\t\t\t\t\t\t\t&new_rate, &tbl_type))\n\t\t\t\t\tant_toggle_cnt = 1;\n\t\t\t}\n\n\t\t\t \n\t\t\trs_dbgfs_set_mcs(lq_sta, &new_rate, index);\n\n\t\t\t \n\t\t\tlq_cmd->rs_table[index].rate_n_flags =\n\t\t\t\t\tcpu_to_le32(new_rate);\n\t\t\trepeat_rate--;\n\t\t\tindex++;\n\t\t}\n\n\t\trs_get_tbl_info_from_mcs(new_rate, lq_sta->band, &tbl_type,\n\t\t\t\t\t\t&rate_idx);\n\n\t\tif (priv && priv->bt_full_concurrent) {\n\t\t\t \n\t\t\ttbl_type.ant_type =\n\t\t\t    first_antenna(priv->nvm_data->valid_tx_ant);\n\t\t}\n\n\t\t \n\t\tif (is_mimo(tbl_type.lq_type))\n\t\t\tlq_cmd->general_params.mimo_delimiter = index;\n\n\t\t \n\t\tnew_rate = rs_get_lower_rate(lq_sta, &tbl_type, rate_idx,\n\t\t\t\t\t     use_ht_possible);\n\n\t\t \n\t\tif (is_legacy(tbl_type.lq_type)) {\n\t\t\tif (ant_toggle_cnt < NUM_TRY_BEFORE_ANT_TOGGLE)\n\t\t\t\tant_toggle_cnt++;\n\t\t\telse if (priv &&\n\t\t\t\t rs_toggle_antenna(valid_tx_ant,\n\t\t\t\t\t\t   &new_rate, &tbl_type))\n\t\t\t\tant_toggle_cnt = 1;\n\n\t\t\trepeat_rate = IWL_NUMBER_TRY;\n\t\t} else {\n\t\t\trepeat_rate = IWL_HT_NUMBER_TRY;\n\t\t}\n\n\t\t \n\t\tuse_ht_possible = 0;\n\n\t\t \n\t\trs_dbgfs_set_mcs(lq_sta, &new_rate, index);\n\n\t\t \n\t\tlq_cmd->rs_table[index].rate_n_flags = cpu_to_le32(new_rate);\n\n\t\tindex++;\n\t\trepeat_rate--;\n\t}\n\n\tlq_cmd->agg_params.agg_frame_cnt_limit =\n\t\tsta_priv->max_agg_bufsize ?: LINK_QUAL_AGG_FRAME_LIMIT_DEF;\n\tlq_cmd->agg_params.agg_dis_start_th = LINK_QUAL_AGG_DISABLE_START_DEF;\n\n\tlq_cmd->agg_params.agg_time_limit =\n\t\tcpu_to_le16(LINK_QUAL_AGG_TIME_LIMIT_DEF);\n\t \n\tif (priv && priv->lib->bt_params &&\n\t    priv->lib->bt_params->agg_time_limit &&\n\t    priv->bt_traffic_load >= IWL_BT_COEX_TRAFFIC_LOAD_HIGH)\n\t\tlq_cmd->agg_params.agg_time_limit =\n\t\t\tcpu_to_le16(priv->lib->bt_params->agg_time_limit);\n}\n\nstatic void *rs_alloc(struct ieee80211_hw *hw)\n{\n\treturn hw->priv;\n}\n \nstatic void rs_free(void *priv_rate)\n{\n\treturn;\n}\n\nstatic void rs_free_sta(void *priv_r, struct ieee80211_sta *sta,\n\t\t\tvoid *priv_sta)\n{\n\tstruct iwl_op_mode *op_mode __maybe_unused = priv_r;\n\tstruct iwl_priv *priv __maybe_unused = IWL_OP_MODE_GET_DVM(op_mode);\n\n\tIWL_DEBUG_RATE(priv, \"enter\\n\");\n\tIWL_DEBUG_RATE(priv, \"leave\\n\");\n}\n\n#ifdef CONFIG_MAC80211_DEBUGFS\nstatic void rs_dbgfs_set_mcs(struct iwl_lq_sta *lq_sta,\n\t\t\t     u32 *rate_n_flags, int index)\n{\n\tstruct iwl_priv *priv;\n\tu8 valid_tx_ant;\n\tu8 ant_sel_tx;\n\n\tpriv = lq_sta->drv;\n\tvalid_tx_ant = priv->nvm_data->valid_tx_ant;\n\tif (lq_sta->dbg_fixed_rate) {\n\t\tant_sel_tx =\n\t\t  ((lq_sta->dbg_fixed_rate & RATE_MCS_ANT_ABC_MSK)\n\t\t  >> RATE_MCS_ANT_POS);\n\t\tif ((valid_tx_ant & ant_sel_tx) == ant_sel_tx) {\n\t\t\t*rate_n_flags = lq_sta->dbg_fixed_rate;\n\t\t\tIWL_DEBUG_RATE(priv, \"Fixed rate ON\\n\");\n\t\t} else {\n\t\t\tlq_sta->dbg_fixed_rate = 0;\n\t\t\tIWL_ERR(priv,\n\t\t\t    \"Invalid antenna selection 0x%X, Valid is 0x%X\\n\",\n\t\t\t    ant_sel_tx, valid_tx_ant);\n\t\t\tIWL_DEBUG_RATE(priv, \"Fixed rate OFF\\n\");\n\t\t}\n\t} else {\n\t\tIWL_DEBUG_RATE(priv, \"Fixed rate OFF\\n\");\n\t}\n}\n\nstatic ssize_t rs_sta_dbgfs_scale_table_write(struct file *file,\n\t\t\tconst char __user *user_buf, size_t count, loff_t *ppos)\n{\n\tstruct iwl_lq_sta *lq_sta = file->private_data;\n\tstruct iwl_priv *priv;\n\tchar buf[64];\n\tsize_t buf_size;\n\tu32 parsed_rate;\n\n\n\tpriv = lq_sta->drv;\n\tmemset(buf, 0, sizeof(buf));\n\tbuf_size = min(count, sizeof(buf) -  1);\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\n\tif (sscanf(buf, \"%x\", &parsed_rate) == 1)\n\t\tlq_sta->dbg_fixed_rate = parsed_rate;\n\telse\n\t\tlq_sta->dbg_fixed_rate = 0;\n\n\trs_program_fix_rate(priv, lq_sta);\n\n\treturn count;\n}\n\nstatic ssize_t rs_sta_dbgfs_scale_table_read(struct file *file,\n\t\t\tchar __user *user_buf, size_t count, loff_t *ppos)\n{\n\tchar *buff;\n\tint desc = 0;\n\tint i = 0;\n\tint index = 0;\n\tssize_t ret;\n\n\t \n\tstatic const struct iwl_rate_mcs_info iwl_rate_mcs[IWL_RATE_COUNT] = {\n\t\t{  \"1\", \"BPSK DSSS\"},\n\t\t{  \"2\", \"QPSK DSSS\"},\n\t\t{\"5.5\", \"BPSK CCK\"},\n\t\t{ \"11\", \"QPSK CCK\"},\n\t\t{  \"6\", \"BPSK 1/2\"},\n\t\t{  \"9\", \"BPSK 1/2\"},\n\t\t{ \"12\", \"QPSK 1/2\"},\n\t\t{ \"18\", \"QPSK 3/4\"},\n\t\t{ \"24\", \"16QAM 1/2\"},\n\t\t{ \"36\", \"16QAM 3/4\"},\n\t\t{ \"48\", \"64QAM 2/3\"},\n\t\t{ \"54\", \"64QAM 3/4\"},\n\t\t{ \"60\", \"64QAM 5/6\"},\n\t};\n\n\tstruct iwl_lq_sta *lq_sta = file->private_data;\n\tstruct iwl_priv *priv;\n\tstruct iwl_scale_tbl_info *tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\n\n\tpriv = lq_sta->drv;\n\tbuff = kmalloc(1024, GFP_KERNEL);\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\tdesc += sprintf(buff+desc, \"sta_id %d\\n\", lq_sta->lq.sta_id);\n\tdesc += sprintf(buff+desc, \"failed=%d success=%d rate=0%X\\n\",\n\t\t\tlq_sta->total_failed, lq_sta->total_success,\n\t\t\tlq_sta->active_legacy_rate);\n\tdesc += sprintf(buff+desc, \"fixed rate 0x%X\\n\",\n\t\t\tlq_sta->dbg_fixed_rate);\n\tdesc += sprintf(buff+desc, \"valid_tx_ant %s%s%s\\n\",\n\t    (priv->nvm_data->valid_tx_ant & ANT_A) ? \"ANT_A,\" : \"\",\n\t    (priv->nvm_data->valid_tx_ant & ANT_B) ? \"ANT_B,\" : \"\",\n\t    (priv->nvm_data->valid_tx_ant & ANT_C) ? \"ANT_C\" : \"\");\n\tdesc += sprintf(buff+desc, \"lq type %s\\n\",\n\t   (is_legacy(tbl->lq_type)) ? \"legacy\" : \"HT\");\n\tif (is_Ht(tbl->lq_type)) {\n\t\tdesc += sprintf(buff + desc, \" %s\",\n\t\t   (is_siso(tbl->lq_type)) ? \"SISO\" :\n\t\t   ((is_mimo2(tbl->lq_type)) ? \"MIMO2\" : \"MIMO3\"));\n\t\tdesc += sprintf(buff + desc, \" %s\",\n\t\t   (tbl->is_ht40) ? \"40MHz\" : \"20MHz\");\n\t\tdesc += sprintf(buff + desc, \" %s %s %s\\n\",\n\t\t   (tbl->is_SGI) ? \"SGI\" : \"\",\n\t\t   (lq_sta->is_green) ? \"GF enabled\" : \"\",\n\t\t   (lq_sta->is_agg) ? \"AGG on\" : \"\");\n\t}\n\tdesc += sprintf(buff+desc, \"last tx rate=0x%X\\n\",\n\t\tlq_sta->last_rate_n_flags);\n\tdesc += sprintf(buff+desc, \"general:\"\n\t\t\"flags=0x%X mimo-d=%d s-ant0x%x d-ant=0x%x\\n\",\n\t\tlq_sta->lq.general_params.flags,\n\t\tlq_sta->lq.general_params.mimo_delimiter,\n\t\tlq_sta->lq.general_params.single_stream_ant_msk,\n\t\tlq_sta->lq.general_params.dual_stream_ant_msk);\n\n\tdesc += sprintf(buff+desc, \"agg:\"\n\t\t\t\"time_limit=%d dist_start_th=%d frame_cnt_limit=%d\\n\",\n\t\t\tle16_to_cpu(lq_sta->lq.agg_params.agg_time_limit),\n\t\t\tlq_sta->lq.agg_params.agg_dis_start_th,\n\t\t\tlq_sta->lq.agg_params.agg_frame_cnt_limit);\n\n\tdesc += sprintf(buff+desc,\n\t\t\t\"Start idx [0]=0x%x [1]=0x%x [2]=0x%x [3]=0x%x\\n\",\n\t\t\tlq_sta->lq.general_params.start_rate_index[0],\n\t\t\tlq_sta->lq.general_params.start_rate_index[1],\n\t\t\tlq_sta->lq.general_params.start_rate_index[2],\n\t\t\tlq_sta->lq.general_params.start_rate_index[3]);\n\n\tfor (i = 0; i < LINK_QUAL_MAX_RETRY_NUM; i++) {\n\t\tindex = iwl_hwrate_to_plcp_idx(\n\t\t\tle32_to_cpu(lq_sta->lq.rs_table[i].rate_n_flags));\n\t\tif (index == IWL_RATE_INVALID) {\n\t\t\tdesc += sprintf(buff + desc, \" rate[%d] 0x%X invalid rate\\n\",\n\t\t\t\ti, le32_to_cpu(lq_sta->lq.rs_table[i].rate_n_flags));\n\t\t} else if (is_legacy(tbl->lq_type)) {\n\t\t\tdesc += sprintf(buff+desc, \" rate[%d] 0x%X %smbps\\n\",\n\t\t\t\ti, le32_to_cpu(lq_sta->lq.rs_table[i].rate_n_flags),\n\t\t\t\tiwl_rate_mcs[index].mbps);\n\t\t} else {\n\t\t\tdesc += sprintf(buff+desc, \" rate[%d] 0x%X %smbps (%s)\\n\",\n\t\t\t\ti, le32_to_cpu(lq_sta->lq.rs_table[i].rate_n_flags),\n\t\t\t\tiwl_rate_mcs[index].mbps, iwl_rate_mcs[index].mcs);\n\t\t}\n\t}\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buff, desc);\n\tkfree(buff);\n\treturn ret;\n}\n\nstatic const struct file_operations rs_sta_dbgfs_scale_table_ops = {\n\t.write = rs_sta_dbgfs_scale_table_write,\n\t.read = rs_sta_dbgfs_scale_table_read,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\nstatic ssize_t rs_sta_dbgfs_stats_table_read(struct file *file,\n\t\t\tchar __user *user_buf, size_t count, loff_t *ppos)\n{\n\tchar *buff;\n\tint desc = 0;\n\tint i, j;\n\tssize_t ret;\n\n\tstruct iwl_lq_sta *lq_sta = file->private_data;\n\n\tbuff = kmalloc(1024, GFP_KERNEL);\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < LQ_SIZE; i++) {\n\t\tdesc += sprintf(buff+desc,\n\t\t\t\t\"%s type=%d SGI=%d HT40=%d DUP=%d GF=%d\\n\"\n\t\t\t\t\"rate=0x%X\\n\",\n\t\t\t\tlq_sta->active_tbl == i ? \"*\" : \"x\",\n\t\t\t\tlq_sta->lq_info[i].lq_type,\n\t\t\t\tlq_sta->lq_info[i].is_SGI,\n\t\t\t\tlq_sta->lq_info[i].is_ht40,\n\t\t\t\tlq_sta->lq_info[i].is_dup,\n\t\t\t\tlq_sta->is_green,\n\t\t\t\tlq_sta->lq_info[i].current_rate);\n\t\tfor (j = 0; j < IWL_RATE_COUNT; j++) {\n\t\t\tdesc += sprintf(buff+desc,\n\t\t\t\t\"counter=%d success=%d %%=%d\\n\",\n\t\t\t\tlq_sta->lq_info[i].win[j].counter,\n\t\t\t\tlq_sta->lq_info[i].win[j].success_counter,\n\t\t\t\tlq_sta->lq_info[i].win[j].success_ratio);\n\t\t}\n\t}\n\tret = simple_read_from_buffer(user_buf, count, ppos, buff, desc);\n\tkfree(buff);\n\treturn ret;\n}\n\nstatic const struct file_operations rs_sta_dbgfs_stats_table_ops = {\n\t.read = rs_sta_dbgfs_stats_table_read,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t rs_sta_dbgfs_rate_scale_data_read(struct file *file,\n\t\t\tchar __user *user_buf, size_t count, loff_t *ppos)\n{\n\tstruct iwl_lq_sta *lq_sta = file->private_data;\n\tstruct iwl_scale_tbl_info *tbl = &lq_sta->lq_info[lq_sta->active_tbl];\n\tchar buff[120];\n\tint desc = 0;\n\n\tif (is_Ht(tbl->lq_type))\n\t\tdesc += sprintf(buff+desc,\n\t\t\t\t\"Bit Rate= %d Mb/s\\n\",\n\t\t\t\ttbl->expected_tpt[lq_sta->last_txrate_idx]);\n\telse\n\t\tdesc += sprintf(buff+desc,\n\t\t\t\t\"Bit Rate= %d Mb/s\\n\",\n\t\t\t\tiwl_rates[lq_sta->last_txrate_idx].ieee >> 1);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buff, desc);\n}\n\nstatic const struct file_operations rs_sta_dbgfs_rate_scale_data_ops = {\n\t.read = rs_sta_dbgfs_rate_scale_data_read,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic void rs_add_debugfs(void *priv, void *priv_sta,\n\t\t\t\t\tstruct dentry *dir)\n{\n\tstruct iwl_lq_sta *lq_sta = priv_sta;\n\n\tdebugfs_create_file(\"rate_scale_table\", 0600, dir, lq_sta,\n\t\t\t    &rs_sta_dbgfs_scale_table_ops);\n\tdebugfs_create_file(\"rate_stats_table\", 0400, dir, lq_sta,\n\t\t\t    &rs_sta_dbgfs_stats_table_ops);\n\tdebugfs_create_file(\"rate_scale_data\", 0400, dir, lq_sta,\n\t\t\t    &rs_sta_dbgfs_rate_scale_data_ops);\n\tdebugfs_create_u8(\"tx_agg_tid_enable\", 0600, dir,\n\t\t\t  &lq_sta->tx_agg_tid_en);\n\n}\n#endif\n\n \nstatic void rs_rate_init_stub(void *priv_r, struct ieee80211_supported_band *sband,\n\t\t\t      struct cfg80211_chan_def *chandef,\n\t\t\t      struct ieee80211_sta *sta, void *priv_sta)\n{\n}\n\nstatic const struct rate_control_ops rs_ops = {\n\t.name = RS_NAME,\n\t.tx_status = rs_tx_status,\n\t.get_rate = rs_get_rate,\n\t.rate_init = rs_rate_init_stub,\n\t.alloc = rs_alloc,\n\t.free = rs_free,\n\t.alloc_sta = rs_alloc_sta,\n\t.free_sta = rs_free_sta,\n#ifdef CONFIG_MAC80211_DEBUGFS\n\t.add_sta_debugfs = rs_add_debugfs,\n#endif\n};\n\nint iwlagn_rate_control_register(void)\n{\n\treturn ieee80211_rate_control_register(&rs_ops);\n}\n\nvoid iwlagn_rate_control_unregister(void)\n{\n\tieee80211_rate_control_unregister(&rs_ops);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}