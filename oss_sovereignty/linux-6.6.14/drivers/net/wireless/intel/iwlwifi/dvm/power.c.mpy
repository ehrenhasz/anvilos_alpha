{
  "module_name": "power.c",
  "hash_id": "1ab547ec03914f5b4e0ea1423b2e5dc649f7a310fc5efa53574b09bfe08d5b85",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/dvm/power.c",
  "human_readable_source": "\n \n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <net/mac80211.h>\n#include \"iwl-io.h\"\n#include \"iwl-debug.h\"\n#include \"iwl-trans.h\"\n#include \"iwl-modparams.h\"\n#include \"dev.h\"\n#include \"agn.h\"\n#include \"commands.h\"\n#include \"power.h\"\n\nstatic bool force_cam = true;\nmodule_param(force_cam, bool, 0644);\nMODULE_PARM_DESC(force_cam, \"force continuously aware mode (no power saving at all)\");\n\n \n\n \n\nstruct iwl_power_vec_entry {\n\tstruct iwl_powertable_cmd cmd;\n\tu8 no_dtim;\t \n};\n\n#define IWL_DTIM_RANGE_0_MAX\t2\n#define IWL_DTIM_RANGE_1_MAX\t10\n\n#define NOSLP cpu_to_le16(0), 0, 0\n#define SLP IWL_POWER_DRIVER_ALLOW_SLEEP_MSK, 0, 0\n#define ASLP (IWL_POWER_POWER_SAVE_ENA_MSK |\t\\\n\t\tIWL_POWER_POWER_MANAGEMENT_ENA_MSK | \\\n\t\tIWL_POWER_ADVANCE_PM_ENA_MSK)\n#define ASLP_TOUT(T) cpu_to_le32(T)\n#define TU_TO_USEC 1024\n#define SLP_TOUT(T) cpu_to_le32((T) * TU_TO_USEC)\n#define SLP_VEC(X0, X1, X2, X3, X4) {cpu_to_le32(X0), \\\n\t\t\t\t     cpu_to_le32(X1), \\\n\t\t\t\t     cpu_to_le32(X2), \\\n\t\t\t\t     cpu_to_le32(X3), \\\n\t\t\t\t     cpu_to_le32(X4)}\n \n \n \nstatic const struct iwl_power_vec_entry range_0[IWL_POWER_NUM] = {\n\t{{SLP, SLP_TOUT(200), SLP_TOUT(500), SLP_VEC(1, 1, 2, 2, 0xFF)}, 0},\n\t{{SLP, SLP_TOUT(200), SLP_TOUT(300), SLP_VEC(1, 2, 2, 2, 0xFF)}, 0},\n\t{{SLP, SLP_TOUT(50), SLP_TOUT(100), SLP_VEC(2, 2, 2, 2, 0xFF)}, 0},\n\t{{SLP, SLP_TOUT(50), SLP_TOUT(25), SLP_VEC(2, 2, 4, 4, 0xFF)}, 1},\n\t{{SLP, SLP_TOUT(25), SLP_TOUT(25), SLP_VEC(2, 2, 4, 6, 0xFF)}, 2}\n};\n\n\n \n \nstatic const struct iwl_power_vec_entry range_1[IWL_POWER_NUM] = {\n\t{{SLP, SLP_TOUT(200), SLP_TOUT(500), SLP_VEC(1, 2, 3, 4, 4)}, 0},\n\t{{SLP, SLP_TOUT(200), SLP_TOUT(300), SLP_VEC(1, 2, 3, 4, 7)}, 0},\n\t{{SLP, SLP_TOUT(50), SLP_TOUT(100), SLP_VEC(2, 4, 6, 7, 9)}, 0},\n\t{{SLP, SLP_TOUT(50), SLP_TOUT(25), SLP_VEC(2, 4, 6, 9, 10)}, 1},\n\t{{SLP, SLP_TOUT(25), SLP_TOUT(25), SLP_VEC(2, 4, 6, 10, 10)}, 2}\n};\n\n \n \nstatic const struct iwl_power_vec_entry range_2[IWL_POWER_NUM] = {\n\t{{SLP, SLP_TOUT(200), SLP_TOUT(500), SLP_VEC(1, 2, 3, 4, 0xFF)}, 0},\n\t{{SLP, SLP_TOUT(200), SLP_TOUT(300), SLP_VEC(2, 4, 6, 7, 0xFF)}, 0},\n\t{{SLP, SLP_TOUT(50), SLP_TOUT(100), SLP_VEC(2, 7, 9, 9, 0xFF)}, 0},\n\t{{SLP, SLP_TOUT(50), SLP_TOUT(25), SLP_VEC(2, 7, 9, 9, 0xFF)}, 0},\n\t{{SLP, SLP_TOUT(25), SLP_TOUT(25), SLP_VEC(4, 7, 10, 10, 0xFF)}, 0}\n};\n\n \n \nstatic const struct iwl_power_vec_entry apm_range_0[IWL_POWER_NUM] = {\n\t{{ASLP, 0, 0, ASLP_TOUT(50), ASLP_TOUT(50),\n\t\tSLP_VEC(1, 2, 4, 6, 0xFF), 0}, 0},\n\t{{ASLP, 0, 0, ASLP_TOUT(50), ASLP_TOUT(50),\n\t\tSLP_VEC(1, 2, 4, 6, 0xFF), 0}, 0},\n\t{{ASLP, 0, 0, ASLP_TOUT(50), ASLP_TOUT(50),\n\t\tSLP_VEC(1, 2, 4, 6, 0xFF), 0}, 0},\n\t{{ASLP, 0, 0, ASLP_TOUT(50), ASLP_TOUT(50),\n\t\tSLP_VEC(1, 2, 4, 6, 0xFF), 0}, 0},\n\t{{ASLP, 0, 0, ASLP_TOUT(50), ASLP_TOUT(50),\n\t\tSLP_VEC(1, 2, 6, 8, 0xFF), ASLP_TOUT(2)}, 2}\n};\n\n\n \n \nstatic const struct iwl_power_vec_entry apm_range_1[IWL_POWER_NUM] = {\n\t{{ASLP, 0, 0, ASLP_TOUT(50), ASLP_TOUT(50),\n\t\tSLP_VEC(1, 2, 4, 6, 0xFF), 0}, 0},\n\t{{ASLP, 0, 0, ASLP_TOUT(50), ASLP_TOUT(50),\n\t\tSLP_VEC(1, 2, 4, 6, 0xFF), 0}, 0},\n\t{{ASLP, 0, 0, ASLP_TOUT(50), ASLP_TOUT(50),\n\t\tSLP_VEC(1, 2, 4, 6, 0xFF), 0}, 0},\n\t{{ASLP, 0, 0, ASLP_TOUT(50), ASLP_TOUT(50),\n\t\tSLP_VEC(1, 2, 4, 6, 0xFF), 0}, 0},\n\t{{ASLP, 0, 0, ASLP_TOUT(50), ASLP_TOUT(50),\n\t\tSLP_VEC(1, 2, 6, 8, 0xFF), 0}, 2}\n};\n\n \n \nstatic const struct iwl_power_vec_entry apm_range_2[IWL_POWER_NUM] = {\n\t{{ASLP, 0, 0, ASLP_TOUT(50), ASLP_TOUT(50),\n\t\tSLP_VEC(1, 2, 4, 6, 0xFF), 0}, 0},\n\t{{ASLP, 0, 0, ASLP_TOUT(50), ASLP_TOUT(50),\n\t\tSLP_VEC(1, 2, 4, 6, 0xFF), 0}, 0},\n\t{{ASLP, 0, 0, ASLP_TOUT(50), ASLP_TOUT(50),\n\t\tSLP_VEC(1, 2, 4, 6, 0xFF), 0}, 0},\n\t{{ASLP, 0, 0, ASLP_TOUT(50), ASLP_TOUT(50),\n\t\tSLP_VEC(1, 2, 4, 6, 0xFF), 0}, 0},\n\t{{ASLP, 0, 0, ASLP_TOUT(50), ASLP_TOUT(50),\n\t\tSLP_VEC(1, 2, 6, 8, 0xFF), ASLP_TOUT(2)}, 2}\n};\n\nstatic void iwl_static_sleep_cmd(struct iwl_priv *priv,\n\t\t\t\t struct iwl_powertable_cmd *cmd,\n\t\t\t\t enum iwl_power_level lvl, int period)\n{\n\tconst struct iwl_power_vec_entry *table;\n\tint max_sleep[IWL_POWER_VEC_SIZE] = { 0 };\n\tint i;\n\tu8 skip;\n\tu32 slp_itrvl;\n\n\tif (priv->lib->adv_pm) {\n\t\ttable = apm_range_2;\n\t\tif (period <= IWL_DTIM_RANGE_1_MAX)\n\t\t\ttable = apm_range_1;\n\t\tif (period <= IWL_DTIM_RANGE_0_MAX)\n\t\t\ttable = apm_range_0;\n\t} else {\n\t\ttable = range_2;\n\t\tif (period <= IWL_DTIM_RANGE_1_MAX)\n\t\t\ttable = range_1;\n\t\tif (period <= IWL_DTIM_RANGE_0_MAX)\n\t\t\ttable = range_0;\n\t}\n\n\tif (WARN_ON(lvl < 0 || lvl >= IWL_POWER_NUM))\n\t\tmemset(cmd, 0, sizeof(*cmd));\n\telse\n\t\t*cmd = table[lvl].cmd;\n\n\tif (period == 0) {\n\t\tskip = 0;\n\t\tperiod = 1;\n\t\tfor (i = 0; i < IWL_POWER_VEC_SIZE; i++)\n\t\t\tmax_sleep[i] =  1;\n\n\t} else {\n\t\tskip = table[lvl].no_dtim;\n\t\tfor (i = 0; i < IWL_POWER_VEC_SIZE; i++)\n\t\t\tmax_sleep[i] = le32_to_cpu(cmd->sleep_interval[i]);\n\t\tmax_sleep[IWL_POWER_VEC_SIZE - 1] = skip + 1;\n\t}\n\n\tslp_itrvl = le32_to_cpu(cmd->sleep_interval[IWL_POWER_VEC_SIZE - 1]);\n\t \n\tif (slp_itrvl == 0xFF)\n\t\tcmd->sleep_interval[IWL_POWER_VEC_SIZE - 1] =\n\t\t\tcpu_to_le32(period * (skip + 1));\n\n\tslp_itrvl = le32_to_cpu(cmd->sleep_interval[IWL_POWER_VEC_SIZE - 1]);\n\tif (slp_itrvl > period)\n\t\tcmd->sleep_interval[IWL_POWER_VEC_SIZE - 1] =\n\t\t\tcpu_to_le32((slp_itrvl / period) * period);\n\n\tif (skip)\n\t\tcmd->flags |= IWL_POWER_SLEEP_OVER_DTIM_MSK;\n\telse\n\t\tcmd->flags &= ~IWL_POWER_SLEEP_OVER_DTIM_MSK;\n\n\tif (priv->trans->trans_cfg->base_params->shadow_reg_enable)\n\t\tcmd->flags |= IWL_POWER_SHADOW_REG_ENA;\n\telse\n\t\tcmd->flags &= ~IWL_POWER_SHADOW_REG_ENA;\n\n\tif (iwl_advanced_bt_coexist(priv)) {\n\t\tif (!priv->lib->bt_params->bt_sco_disable)\n\t\t\tcmd->flags |= IWL_POWER_BT_SCO_ENA;\n\t\telse\n\t\t\tcmd->flags &= ~IWL_POWER_BT_SCO_ENA;\n\t}\n\n\n\tslp_itrvl = le32_to_cpu(cmd->sleep_interval[IWL_POWER_VEC_SIZE - 1]);\n\tif (slp_itrvl > IWL_CONN_MAX_LISTEN_INTERVAL)\n\t\tcmd->sleep_interval[IWL_POWER_VEC_SIZE - 1] =\n\t\t\tcpu_to_le32(IWL_CONN_MAX_LISTEN_INTERVAL);\n\n\t \n\tfor (i = IWL_POWER_VEC_SIZE - 1; i >= 0 ; i--) {\n\t\tif (le32_to_cpu(cmd->sleep_interval[i]) >\n\t\t    (max_sleep[i] * period))\n\t\t\tcmd->sleep_interval[i] =\n\t\t\t\tcpu_to_le32(max_sleep[i] * period);\n\t\tif (i != (IWL_POWER_VEC_SIZE - 1)) {\n\t\t\tif (le32_to_cpu(cmd->sleep_interval[i]) >\n\t\t\t    le32_to_cpu(cmd->sleep_interval[i+1]))\n\t\t\t\tcmd->sleep_interval[i] =\n\t\t\t\t\tcmd->sleep_interval[i+1];\n\t\t}\n\t}\n\n\tif (priv->power_data.bus_pm)\n\t\tcmd->flags |= IWL_POWER_PCI_PM_MSK;\n\telse\n\t\tcmd->flags &= ~IWL_POWER_PCI_PM_MSK;\n\n\tIWL_DEBUG_POWER(priv, \"numSkipDtim = %u, dtimPeriod = %d\\n\",\n\t\t\tskip, period);\n\t \n\tIWL_DEBUG_POWER(priv, \"Sleep command for index %d\\n\", lvl + 1);\n}\n\nstatic void iwl_power_sleep_cam_cmd(struct iwl_priv *priv,\n\t\t\t\t    struct iwl_powertable_cmd *cmd)\n{\n\tmemset(cmd, 0, sizeof(*cmd));\n\n\tif (priv->power_data.bus_pm)\n\t\tcmd->flags |= IWL_POWER_PCI_PM_MSK;\n\n\tIWL_DEBUG_POWER(priv, \"Sleep command for CAM\\n\");\n}\n\nstatic int iwl_set_power(struct iwl_priv *priv, struct iwl_powertable_cmd *cmd)\n{\n\tIWL_DEBUG_POWER(priv, \"Sending power/sleep command\\n\");\n\tIWL_DEBUG_POWER(priv, \"Flags value = 0x%08X\\n\", cmd->flags);\n\tIWL_DEBUG_POWER(priv, \"Tx timeout = %u\\n\", le32_to_cpu(cmd->tx_data_timeout));\n\tIWL_DEBUG_POWER(priv, \"Rx timeout = %u\\n\", le32_to_cpu(cmd->rx_data_timeout));\n\tIWL_DEBUG_POWER(priv, \"Sleep interval vector = { %d , %d , %d , %d , %d }\\n\",\n\t\t\tle32_to_cpu(cmd->sleep_interval[0]),\n\t\t\tle32_to_cpu(cmd->sleep_interval[1]),\n\t\t\tle32_to_cpu(cmd->sleep_interval[2]),\n\t\t\tle32_to_cpu(cmd->sleep_interval[3]),\n\t\t\tle32_to_cpu(cmd->sleep_interval[4]));\n\n\treturn iwl_dvm_send_cmd_pdu(priv, POWER_TABLE_CMD, 0,\n\t\t\t\tsizeof(struct iwl_powertable_cmd), cmd);\n}\n\nstatic void iwl_power_build_cmd(struct iwl_priv *priv,\n\t\t\t\tstruct iwl_powertable_cmd *cmd)\n{\n\tbool enabled = priv->hw->conf.flags & IEEE80211_CONF_PS;\n\tint dtimper;\n\n\tif (force_cam) {\n\t\tiwl_power_sleep_cam_cmd(priv, cmd);\n\t\treturn;\n\t}\n\n\tdtimper = priv->hw->conf.ps_dtim_period ?: 1;\n\n\tif (priv->wowlan)\n\t\tiwl_static_sleep_cmd(priv, cmd, IWL_POWER_INDEX_5, dtimper);\n\telse if (!priv->lib->no_idle_support &&\n\t\t priv->hw->conf.flags & IEEE80211_CONF_IDLE)\n\t\tiwl_static_sleep_cmd(priv, cmd, IWL_POWER_INDEX_5, 20);\n\telse if (iwl_tt_is_low_power_state(priv)) {\n\t\t \n\t\tiwl_static_sleep_cmd(priv, cmd,\n\t\t    iwl_tt_current_power_mode(priv), dtimper);\n\t} else if (!enabled)\n\t\tiwl_power_sleep_cam_cmd(priv, cmd);\n\telse if (priv->power_data.debug_sleep_level_override >= 0)\n\t\tiwl_static_sleep_cmd(priv, cmd,\n\t\t\t\t     priv->power_data.debug_sleep_level_override,\n\t\t\t\t     dtimper);\n\telse {\n\t\t \n\t\tif (iwlwifi_mod_params.power_level > IWL_POWER_INDEX_1 &&\n\t\t    iwlwifi_mod_params.power_level <= IWL_POWER_NUM)\n\t\t\tiwl_static_sleep_cmd(priv, cmd,\n\t\t\t\tiwlwifi_mod_params.power_level - 1, dtimper);\n\t\telse\n\t\t\tiwl_static_sleep_cmd(priv, cmd,\n\t\t\t\tIWL_POWER_INDEX_1, dtimper);\n\t}\n}\n\nint iwl_power_set_mode(struct iwl_priv *priv, struct iwl_powertable_cmd *cmd,\n\t\t       bool force)\n{\n\tint ret;\n\tbool update_chains;\n\n\tlockdep_assert_held(&priv->mutex);\n\n\t \n\tupdate_chains = priv->chain_noise_data.state == IWL_CHAIN_NOISE_DONE ||\n\t\t\tpriv->chain_noise_data.state == IWL_CHAIN_NOISE_ALIVE;\n\n\tif (!memcmp(&priv->power_data.sleep_cmd, cmd, sizeof(*cmd)) && !force)\n\t\treturn 0;\n\n\tif (!iwl_is_ready_rf(priv))\n\t\treturn -EIO;\n\n\t \n\tmemcpy(&priv->power_data.sleep_cmd_next, cmd, sizeof(*cmd));\n\tif (test_bit(STATUS_SCANNING, &priv->status) && !force) {\n\t\tIWL_DEBUG_INFO(priv, \"Defer power set mode while scanning\\n\");\n\t\treturn 0;\n\t}\n\n\tif (cmd->flags & IWL_POWER_DRIVER_ALLOW_SLEEP_MSK)\n\t\tiwl_dvm_set_pmi(priv, true);\n\n\tret = iwl_set_power(priv, cmd);\n\tif (!ret) {\n\t\tif (!(cmd->flags & IWL_POWER_DRIVER_ALLOW_SLEEP_MSK))\n\t\t\tiwl_dvm_set_pmi(priv, false);\n\n\t\tif (update_chains)\n\t\t\tiwl_update_chain_flags(priv);\n\t\telse\n\t\t\tIWL_DEBUG_POWER(priv,\n\t\t\t\t\t\"Cannot update the power, chain noise \"\n\t\t\t\t\t\"calibration running: %d\\n\",\n\t\t\t\t\tpriv->chain_noise_data.state);\n\n\t\tmemcpy(&priv->power_data.sleep_cmd, cmd, sizeof(*cmd));\n\t} else\n\t\tIWL_ERR(priv, \"set power fail, ret = %d\\n\", ret);\n\n\treturn ret;\n}\n\nint iwl_power_update_mode(struct iwl_priv *priv, bool force)\n{\n\tstruct iwl_powertable_cmd cmd;\n\n\tiwl_power_build_cmd(priv, &cmd);\n\treturn iwl_power_set_mode(priv, &cmd, force);\n}\n\n \nvoid iwl_power_initialize(struct iwl_priv *priv)\n{\n\tpriv->power_data.bus_pm = priv->trans->pm_support;\n\n\tpriv->power_data.debug_sleep_level_override = -1;\n\n\tmemset(&priv->power_data.sleep_cmd, 0,\n\t\tsizeof(priv->power_data.sleep_cmd));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}