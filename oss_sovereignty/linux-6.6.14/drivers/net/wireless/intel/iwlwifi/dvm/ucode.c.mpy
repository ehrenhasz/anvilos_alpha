{
  "module_name": "ucode.c",
  "hash_id": "0cf65041c25808cb28c38fd668f13cd96b146d84b851834ba7c07741b7528273",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/dvm/ucode.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n\n#include \"iwl-io.h\"\n#include \"iwl-agn-hw.h\"\n#include \"iwl-trans.h\"\n#include \"iwl-fh.h\"\n#include \"iwl-op-mode.h\"\n\n#include \"dev.h\"\n#include \"agn.h\"\n#include \"calib.h\"\n\n \n\n \nstatic int iwl_set_Xtal_calib(struct iwl_priv *priv)\n{\n\tstruct iwl_calib_xtal_freq_cmd cmd;\n\t__le16 *xtal_calib = priv->nvm_data->xtal_calib;\n\n\tiwl_set_calib_hdr(&cmd.hdr, IWL_PHY_CALIBRATE_CRYSTAL_FRQ_CMD);\n\tcmd.cap_pin1 = le16_to_cpu(xtal_calib[0]);\n\tcmd.cap_pin2 = le16_to_cpu(xtal_calib[1]);\n\treturn iwl_calib_set(priv, (void *)&cmd, sizeof(cmd));\n}\n\nstatic int iwl_set_temperature_offset_calib(struct iwl_priv *priv)\n{\n\tstruct iwl_calib_temperature_offset_cmd cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tiwl_set_calib_hdr(&cmd.hdr, IWL_PHY_CALIBRATE_TEMP_OFFSET_CMD);\n\tcmd.radio_sensor_offset = priv->nvm_data->raw_temperature;\n\tif (!(cmd.radio_sensor_offset))\n\t\tcmd.radio_sensor_offset = DEFAULT_RADIO_SENSOR_OFFSET;\n\n\tIWL_DEBUG_CALIB(priv, \"Radio sensor offset: %d\\n\",\n\t\t\tle16_to_cpu(cmd.radio_sensor_offset));\n\treturn iwl_calib_set(priv, (void *)&cmd, sizeof(cmd));\n}\n\nstatic int iwl_set_temperature_offset_calib_v2(struct iwl_priv *priv)\n{\n\tstruct iwl_calib_temperature_offset_v2_cmd cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tiwl_set_calib_hdr(&cmd.hdr, IWL_PHY_CALIBRATE_TEMP_OFFSET_CMD);\n\tcmd.radio_sensor_offset_high = priv->nvm_data->kelvin_temperature;\n\tcmd.radio_sensor_offset_low = priv->nvm_data->raw_temperature;\n\tif (!cmd.radio_sensor_offset_low) {\n\t\tIWL_DEBUG_CALIB(priv, \"no info in EEPROM, use default\\n\");\n\t\tcmd.radio_sensor_offset_low = DEFAULT_RADIO_SENSOR_OFFSET;\n\t\tcmd.radio_sensor_offset_high = DEFAULT_RADIO_SENSOR_OFFSET;\n\t}\n\tcmd.burntVoltageRef = priv->nvm_data->calib_voltage;\n\n\tIWL_DEBUG_CALIB(priv, \"Radio sensor offset high: %d\\n\",\n\t\t\tle16_to_cpu(cmd.radio_sensor_offset_high));\n\tIWL_DEBUG_CALIB(priv, \"Radio sensor offset low: %d\\n\",\n\t\t\tle16_to_cpu(cmd.radio_sensor_offset_low));\n\tIWL_DEBUG_CALIB(priv, \"Voltage Ref: %d\\n\",\n\t\t\tle16_to_cpu(cmd.burntVoltageRef));\n\n\treturn iwl_calib_set(priv, (void *)&cmd, sizeof(cmd));\n}\n\nstatic int iwl_send_calib_cfg(struct iwl_priv *priv)\n{\n\tstruct iwl_calib_cfg_cmd calib_cfg_cmd;\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = CALIBRATION_CFG_CMD,\n\t\t.len = { sizeof(struct iwl_calib_cfg_cmd), },\n\t\t.data = { &calib_cfg_cmd, },\n\t};\n\n\tmemset(&calib_cfg_cmd, 0, sizeof(calib_cfg_cmd));\n\tcalib_cfg_cmd.ucd_calib_cfg.once.is_enable = IWL_CALIB_INIT_CFG_ALL;\n\tcalib_cfg_cmd.ucd_calib_cfg.once.start = IWL_CALIB_INIT_CFG_ALL;\n\tcalib_cfg_cmd.ucd_calib_cfg.once.send_res = IWL_CALIB_INIT_CFG_ALL;\n\tcalib_cfg_cmd.ucd_calib_cfg.flags =\n\t\tIWL_CALIB_CFG_FLAG_SEND_COMPLETE_NTFY_MSK;\n\n\treturn iwl_dvm_send_cmd(priv, &cmd);\n}\n\nint iwl_init_alive_start(struct iwl_priv *priv)\n{\n\tint ret;\n\n\tif (priv->lib->bt_params &&\n\t    priv->lib->bt_params->advanced_bt_coexist) {\n\t\t \n\t\tret = iwl_send_bt_env(priv, IWL_BT_COEX_ENV_OPEN,\n\t\t\tBT_COEX_PRIO_TBL_EVT_INIT_CALIB2);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t}\n\n\tret = iwl_send_calib_cfg(priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (priv->lib->need_temp_offset_calib) {\n\t\tif (priv->lib->temp_offset_v2)\n\t\t\treturn iwl_set_temperature_offset_calib_v2(priv);\n\t\telse\n\t\t\treturn iwl_set_temperature_offset_calib(priv);\n\t}\n\n\treturn 0;\n}\n\nstatic int iwl_send_wimax_coex(struct iwl_priv *priv)\n{\n\tstruct iwl_wimax_coex_cmd coex_cmd;\n\n\t \n\tmemset(&coex_cmd, 0, sizeof(coex_cmd));\n\n\treturn iwl_dvm_send_cmd_pdu(priv,\n\t\t\t\tCOEX_PRIORITY_TABLE_CMD, 0,\n\t\t\t\tsizeof(coex_cmd), &coex_cmd);\n}\n\nstatic const u8 iwl_bt_prio_tbl[BT_COEX_PRIO_TBL_EVT_MAX] = {\n\t((BT_COEX_PRIO_TBL_PRIO_BYPASS << IWL_BT_COEX_PRIO_TBL_PRIO_POS) |\n\t\t(0 << IWL_BT_COEX_PRIO_TBL_SHARED_ANTENNA_POS)),\n\t((BT_COEX_PRIO_TBL_PRIO_BYPASS << IWL_BT_COEX_PRIO_TBL_PRIO_POS) |\n\t\t(1 << IWL_BT_COEX_PRIO_TBL_SHARED_ANTENNA_POS)),\n\t((BT_COEX_PRIO_TBL_PRIO_LOW << IWL_BT_COEX_PRIO_TBL_PRIO_POS) |\n\t\t(0 << IWL_BT_COEX_PRIO_TBL_SHARED_ANTENNA_POS)),\n\t((BT_COEX_PRIO_TBL_PRIO_LOW << IWL_BT_COEX_PRIO_TBL_PRIO_POS) |\n\t\t(1 << IWL_BT_COEX_PRIO_TBL_SHARED_ANTENNA_POS)),\n\t((BT_COEX_PRIO_TBL_PRIO_HIGH << IWL_BT_COEX_PRIO_TBL_PRIO_POS) |\n\t\t(0 << IWL_BT_COEX_PRIO_TBL_SHARED_ANTENNA_POS)),\n\t((BT_COEX_PRIO_TBL_PRIO_HIGH << IWL_BT_COEX_PRIO_TBL_PRIO_POS) |\n\t\t(1 << IWL_BT_COEX_PRIO_TBL_SHARED_ANTENNA_POS)),\n\t((BT_COEX_PRIO_TBL_PRIO_BYPASS << IWL_BT_COEX_PRIO_TBL_PRIO_POS) |\n\t\t(0 << IWL_BT_COEX_PRIO_TBL_SHARED_ANTENNA_POS)),\n\t((BT_COEX_PRIO_TBL_PRIO_COEX_OFF << IWL_BT_COEX_PRIO_TBL_PRIO_POS) |\n\t\t(0 << IWL_BT_COEX_PRIO_TBL_SHARED_ANTENNA_POS)),\n\t((BT_COEX_PRIO_TBL_PRIO_COEX_ON << IWL_BT_COEX_PRIO_TBL_PRIO_POS) |\n\t\t(0 << IWL_BT_COEX_PRIO_TBL_SHARED_ANTENNA_POS)),\n\t0, 0, 0, 0, 0, 0, 0\n};\n\nvoid iwl_send_prio_tbl(struct iwl_priv *priv)\n{\n\tstruct iwl_bt_coex_prio_table_cmd prio_tbl_cmd;\n\n\tmemcpy(prio_tbl_cmd.prio_tbl, iwl_bt_prio_tbl,\n\t\tsizeof(iwl_bt_prio_tbl));\n\tif (iwl_dvm_send_cmd_pdu(priv,\n\t\t\t\tREPLY_BT_COEX_PRIO_TABLE, 0,\n\t\t\t\tsizeof(prio_tbl_cmd), &prio_tbl_cmd))\n\t\tIWL_ERR(priv, \"failed to send BT prio tbl command\\n\");\n}\n\nint iwl_send_bt_env(struct iwl_priv *priv, u8 action, u8 type)\n{\n\tstruct iwl_bt_coex_prot_env_cmd env_cmd;\n\tint ret;\n\n\tenv_cmd.action = action;\n\tenv_cmd.type = type;\n\tret = iwl_dvm_send_cmd_pdu(priv,\n\t\t\t       REPLY_BT_COEX_PROT_ENV, 0,\n\t\t\t       sizeof(env_cmd), &env_cmd);\n\tif (ret)\n\t\tIWL_ERR(priv, \"failed to send BT env command\\n\");\n\treturn ret;\n}\n\nstatic const u8 iwlagn_default_queue_to_tx_fifo[] = {\n\tIWL_TX_FIFO_VO,\n\tIWL_TX_FIFO_VI,\n\tIWL_TX_FIFO_BE,\n\tIWL_TX_FIFO_BK,\n};\n\nstatic const u8 iwlagn_ipan_queue_to_tx_fifo[] = {\n\tIWL_TX_FIFO_VO,\n\tIWL_TX_FIFO_VI,\n\tIWL_TX_FIFO_BE,\n\tIWL_TX_FIFO_BK,\n\tIWL_TX_FIFO_BK_IPAN,\n\tIWL_TX_FIFO_BE_IPAN,\n\tIWL_TX_FIFO_VI_IPAN,\n\tIWL_TX_FIFO_VO_IPAN,\n\tIWL_TX_FIFO_BE_IPAN,\n\tIWL_TX_FIFO_UNUSED,\n\tIWL_TX_FIFO_AUX,\n};\n\nstatic int iwl_alive_notify(struct iwl_priv *priv)\n{\n\tconst u8 *queue_to_txf;\n\tu8 n_queues;\n\tint ret;\n\tint i;\n\n\tiwl_trans_fw_alive(priv->trans, 0);\n\n\tif (priv->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_PAN &&\n\t    priv->nvm_data->sku_cap_ipan_enable) {\n\t\tn_queues = ARRAY_SIZE(iwlagn_ipan_queue_to_tx_fifo);\n\t\tqueue_to_txf = iwlagn_ipan_queue_to_tx_fifo;\n\t} else {\n\t\tn_queues = ARRAY_SIZE(iwlagn_default_queue_to_tx_fifo);\n\t\tqueue_to_txf = iwlagn_default_queue_to_tx_fifo;\n\t}\n\n\tfor (i = 0; i < n_queues; i++)\n\t\tif (queue_to_txf[i] != IWL_TX_FIFO_UNUSED)\n\t\t\tiwl_trans_ac_txq_enable(priv->trans, i,\n\t\t\t\t\t\tqueue_to_txf[i], 0);\n\n\tpriv->passive_no_rx = false;\n\tpriv->transport_queue_stop = 0;\n\n\tret = iwl_send_wimax_coex(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!priv->lib->no_xtal_calib) {\n\t\tret = iwl_set_Xtal_calib(priv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn iwl_send_calib_results(priv);\n}\n\nstruct iwl_alive_data {\n\tbool valid;\n\tu8 subtype;\n};\n\nstatic bool iwl_alive_fn(struct iwl_notif_wait_data *notif_wait,\n\t\t\t struct iwl_rx_packet *pkt, void *data)\n{\n\tstruct iwl_priv *priv =\n\t\tcontainer_of(notif_wait, struct iwl_priv, notif_wait);\n\tstruct iwl_alive_data *alive_data = data;\n\tstruct iwl_alive_resp *palive;\n\n\tpalive = (void *)pkt->data;\n\n\tIWL_DEBUG_FW(priv, \"Alive ucode status 0x%08X revision \"\n\t\t       \"0x%01X 0x%01X\\n\",\n\t\t       palive->is_valid, palive->ver_type,\n\t\t       palive->ver_subtype);\n\n\tpriv->device_pointers.error_event_table =\n\t\tle32_to_cpu(palive->error_event_table_ptr);\n\tpriv->device_pointers.log_event_table =\n\t\tle32_to_cpu(palive->log_event_table_ptr);\n\n\talive_data->subtype = palive->ver_subtype;\n\talive_data->valid = palive->is_valid == UCODE_VALID_OK;\n\n\treturn true;\n}\n\n#define UCODE_ALIVE_TIMEOUT\tHZ\n#define UCODE_CALIB_TIMEOUT\t(2*HZ)\n\nint iwl_load_ucode_wait_alive(struct iwl_priv *priv,\n\t\t\t\t enum iwl_ucode_type ucode_type)\n{\n\tstruct iwl_notification_wait alive_wait;\n\tstruct iwl_alive_data alive_data;\n\tconst struct fw_img *fw;\n\tint ret;\n\tenum iwl_ucode_type old_type;\n\tstatic const u16 alive_cmd[] = { REPLY_ALIVE };\n\n\tfw = iwl_get_ucode_image(priv->fw, ucode_type);\n\tif (WARN_ON(!fw))\n\t\treturn -EINVAL;\n\n\told_type = priv->cur_ucode;\n\tpriv->cur_ucode = ucode_type;\n\tpriv->ucode_loaded = false;\n\n\tiwl_init_notification_wait(&priv->notif_wait, &alive_wait,\n\t\t\t\t   alive_cmd, ARRAY_SIZE(alive_cmd),\n\t\t\t\t   iwl_alive_fn, &alive_data);\n\n\tret = iwl_trans_start_fw(priv->trans, fw, false);\n\tif (ret) {\n\t\tpriv->cur_ucode = old_type;\n\t\tiwl_remove_notification(&priv->notif_wait, &alive_wait);\n\t\treturn ret;\n\t}\n\n\t \n\tret = iwl_wait_notification(&priv->notif_wait, &alive_wait,\n\t\t\t\t\tUCODE_ALIVE_TIMEOUT);\n\tif (ret) {\n\t\tpriv->cur_ucode = old_type;\n\t\treturn ret;\n\t}\n\n\tif (!alive_data.valid) {\n\t\tIWL_ERR(priv, \"Loaded ucode is not valid!\\n\");\n\t\tpriv->cur_ucode = old_type;\n\t\treturn -EIO;\n\t}\n\n\tpriv->ucode_loaded = true;\n\n\tif (ucode_type != IWL_UCODE_WOWLAN) {\n\t\t \n\t\tmsleep(5);\n\t}\n\n\tret = iwl_alive_notify(priv);\n\tif (ret) {\n\t\tIWL_WARN(priv,\n\t\t\t\"Could not complete ALIVE transition: %d\\n\", ret);\n\t\tpriv->cur_ucode = old_type;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic bool iwlagn_wait_calib(struct iwl_notif_wait_data *notif_wait,\n\t\t\t      struct iwl_rx_packet *pkt, void *data)\n{\n\tstruct iwl_priv *priv = data;\n\tstruct iwl_calib_cmd *cmd;\n\n\tif (pkt->hdr.cmd != CALIBRATION_RES_NOTIFICATION) {\n\t\tWARN_ON(pkt->hdr.cmd != CALIBRATION_COMPLETE_NOTIFICATION);\n\t\treturn true;\n\t}\n\n\tcmd = (struct iwl_calib_cmd *)pkt->data;\n\n\tif (iwl_calib_set(priv, cmd, iwl_rx_packet_payload_len(pkt)))\n\t\tIWL_ERR(priv, \"Failed to record calibration data %d\\n\",\n\t\t\tcmd->hdr.op_code);\n\n\treturn false;\n}\n\nint iwl_run_init_ucode(struct iwl_priv *priv)\n{\n\tstruct iwl_notification_wait calib_wait;\n\tstatic const u16 calib_complete[] = {\n\t\tCALIBRATION_RES_NOTIFICATION,\n\t\tCALIBRATION_COMPLETE_NOTIFICATION\n\t};\n\tint ret;\n\n\tlockdep_assert_held(&priv->mutex);\n\n\t \n\tif (!priv->fw->img[IWL_UCODE_INIT].num_sec)\n\t\treturn 0;\n\n\tiwl_init_notification_wait(&priv->notif_wait, &calib_wait,\n\t\t\t\t   calib_complete, ARRAY_SIZE(calib_complete),\n\t\t\t\t   iwlagn_wait_calib, priv);\n\n\t \n\tret = iwl_load_ucode_wait_alive(priv, IWL_UCODE_INIT);\n\tif (ret)\n\t\tgoto error;\n\n\tret = iwl_init_alive_start(priv);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tret = iwl_wait_notification(&priv->notif_wait, &calib_wait,\n\t\t\t\t\tUCODE_CALIB_TIMEOUT);\n\n\tgoto out;\n\n error:\n\tiwl_remove_notification(&priv->notif_wait, &calib_wait);\n out:\n\t \n\tiwl_trans_stop_device(priv->trans);\n\tpriv->ucode_loaded = false;\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}