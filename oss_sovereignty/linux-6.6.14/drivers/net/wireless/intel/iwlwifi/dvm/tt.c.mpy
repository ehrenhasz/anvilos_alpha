{
  "module_name": "tt.c",
  "hash_id": "2463dff2a936a82ea058cee99151a2199442f60431e18e8fdf345aaf6ab0ea63",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/dvm/tt.c",
  "human_readable_source": "\n \n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <net/mac80211.h>\n#include \"iwl-io.h\"\n#include \"iwl-modparams.h\"\n#include \"iwl-debug.h\"\n#include \"agn.h\"\n#include \"dev.h\"\n#include \"commands.h\"\n#include \"tt.h\"\n\n \nstatic const struct iwl_tt_trans tt_range_0[IWL_TI_STATE_MAX - 1] = {\n\t{IWL_TI_0, IWL_ABSOLUTE_ZERO, 104},\n\t{IWL_TI_1, 105, CT_KILL_THRESHOLD - 1},\n\t{IWL_TI_CT_KILL, CT_KILL_THRESHOLD, IWL_ABSOLUTE_MAX}\n};\nstatic const struct iwl_tt_trans tt_range_1[IWL_TI_STATE_MAX - 1] = {\n\t{IWL_TI_0, IWL_ABSOLUTE_ZERO, 95},\n\t{IWL_TI_2, 110, CT_KILL_THRESHOLD - 1},\n\t{IWL_TI_CT_KILL, CT_KILL_THRESHOLD, IWL_ABSOLUTE_MAX}\n};\nstatic const struct iwl_tt_trans tt_range_2[IWL_TI_STATE_MAX - 1] = {\n\t{IWL_TI_1, IWL_ABSOLUTE_ZERO, 100},\n\t{IWL_TI_CT_KILL, CT_KILL_THRESHOLD, IWL_ABSOLUTE_MAX},\n\t{IWL_TI_CT_KILL, CT_KILL_THRESHOLD, IWL_ABSOLUTE_MAX}\n};\nstatic const struct iwl_tt_trans tt_range_3[IWL_TI_STATE_MAX - 1] = {\n\t{IWL_TI_0, IWL_ABSOLUTE_ZERO, CT_KILL_EXIT_THRESHOLD},\n\t{IWL_TI_CT_KILL, CT_KILL_EXIT_THRESHOLD + 1, IWL_ABSOLUTE_MAX},\n\t{IWL_TI_CT_KILL, CT_KILL_EXIT_THRESHOLD + 1, IWL_ABSOLUTE_MAX}\n};\n\n \nstatic const struct iwl_tt_restriction restriction_range[IWL_TI_STATE_MAX] = {\n\t{IWL_ANT_OK_MULTI, IWL_ANT_OK_MULTI, true },\n\t{IWL_ANT_OK_SINGLE, IWL_ANT_OK_MULTI, true },\n\t{IWL_ANT_OK_SINGLE, IWL_ANT_OK_SINGLE, false },\n\t{IWL_ANT_OK_NONE, IWL_ANT_OK_NONE, false }\n};\n\nbool iwl_tt_is_low_power_state(struct iwl_priv *priv)\n{\n\tstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;\n\n\tif (tt->state >= IWL_TI_1)\n\t\treturn true;\n\treturn false;\n}\n\nu8 iwl_tt_current_power_mode(struct iwl_priv *priv)\n{\n\tstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;\n\n\treturn tt->tt_power_mode;\n}\n\nbool iwl_ht_enabled(struct iwl_priv *priv)\n{\n\tstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;\n\tstruct iwl_tt_restriction *restriction;\n\n\tif (!priv->thermal_throttle.advanced_tt)\n\t\treturn true;\n\trestriction = tt->restriction + tt->state;\n\treturn restriction->is_ht;\n}\n\nstatic bool iwl_within_ct_kill_margin(struct iwl_priv *priv)\n{\n\ts32 temp = priv->temperature;  \n\tbool within_margin = false;\n\n\tif (!priv->thermal_throttle.advanced_tt)\n\t\twithin_margin = ((temp + IWL_TT_CT_KILL_MARGIN) >=\n\t\t\t\tCT_KILL_THRESHOLD_LEGACY) ? true : false;\n\telse\n\t\twithin_margin = ((temp + IWL_TT_CT_KILL_MARGIN) >=\n\t\t\t\tCT_KILL_THRESHOLD) ? true : false;\n\treturn within_margin;\n}\n\nbool iwl_check_for_ct_kill(struct iwl_priv *priv)\n{\n\tbool is_ct_kill = false;\n\n\tif (iwl_within_ct_kill_margin(priv)) {\n\t\tiwl_tt_enter_ct_kill(priv);\n\t\tis_ct_kill = true;\n\t}\n\treturn is_ct_kill;\n}\n\nenum iwl_antenna_ok iwl_tx_ant_restriction(struct iwl_priv *priv)\n{\n\tstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;\n\tstruct iwl_tt_restriction *restriction;\n\n\tif (!priv->thermal_throttle.advanced_tt)\n\t\treturn IWL_ANT_OK_MULTI;\n\trestriction = tt->restriction + tt->state;\n\treturn restriction->tx_stream;\n}\n\nenum iwl_antenna_ok iwl_rx_ant_restriction(struct iwl_priv *priv)\n{\n\tstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;\n\tstruct iwl_tt_restriction *restriction;\n\n\tif (!priv->thermal_throttle.advanced_tt)\n\t\treturn IWL_ANT_OK_MULTI;\n\trestriction = tt->restriction + tt->state;\n\treturn restriction->rx_stream;\n}\n\n#define CT_KILL_EXIT_DURATION (5)\t \n#define CT_KILL_WAITING_DURATION (300)\t \n\n \nstatic void iwl_tt_check_exit_ct_kill(struct timer_list *t)\n{\n\tstruct iwl_priv *priv = from_timer(priv, t,\n\t\t\t\t\t   thermal_throttle.ct_kill_exit_tm);\n\tstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;\n\n\tif (test_bit(STATUS_EXIT_PENDING, &priv->status))\n\t\treturn;\n\n\tif (tt->state == IWL_TI_CT_KILL) {\n\t\tif (priv->thermal_throttle.ct_kill_toggle) {\n\t\t\tiwl_write32(priv->trans, CSR_UCODE_DRV_GP1_CLR,\n\t\t\t\t    CSR_UCODE_DRV_GP1_REG_BIT_CT_KILL_EXIT);\n\t\t\tpriv->thermal_throttle.ct_kill_toggle = false;\n\t\t} else {\n\t\t\tiwl_write32(priv->trans, CSR_UCODE_DRV_GP1_SET,\n\t\t\t\t    CSR_UCODE_DRV_GP1_REG_BIT_CT_KILL_EXIT);\n\t\t\tpriv->thermal_throttle.ct_kill_toggle = true;\n\t\t}\n\t\tiwl_read32(priv->trans, CSR_UCODE_DRV_GP1);\n\t\tif (iwl_trans_grab_nic_access(priv->trans))\n\t\t\tiwl_trans_release_nic_access(priv->trans);\n\n\t\t \n\t\tIWL_DEBUG_TEMP(priv, \"schedule ct_kill exit timer\\n\");\n\t\tmod_timer(&priv->thermal_throttle.ct_kill_exit_tm,\n\t\t\t  jiffies + CT_KILL_EXIT_DURATION * HZ);\n\t}\n}\n\nstatic void iwl_perform_ct_kill_task(struct iwl_priv *priv,\n\t\t\t   bool stop)\n{\n\tif (stop) {\n\t\tIWL_DEBUG_TEMP(priv, \"Stop all queues\\n\");\n\t\tif (priv->mac80211_registered)\n\t\t\tieee80211_stop_queues(priv->hw);\n\t\tIWL_DEBUG_TEMP(priv,\n\t\t\t\t\"Schedule 5 seconds CT_KILL Timer\\n\");\n\t\tmod_timer(&priv->thermal_throttle.ct_kill_exit_tm,\n\t\t\t  jiffies + CT_KILL_EXIT_DURATION * HZ);\n\t} else {\n\t\tIWL_DEBUG_TEMP(priv, \"Wake all queues\\n\");\n\t\tif (priv->mac80211_registered)\n\t\t\tieee80211_wake_queues(priv->hw);\n\t}\n}\n\nstatic void iwl_tt_ready_for_ct_kill(struct timer_list *t)\n{\n\tstruct iwl_priv *priv = from_timer(priv, t,\n\t\t\t\t\t   thermal_throttle.ct_kill_waiting_tm);\n\tstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;\n\n\tif (test_bit(STATUS_EXIT_PENDING, &priv->status))\n\t\treturn;\n\n\t \n\tif (tt->state != IWL_TI_CT_KILL) {\n\t\tIWL_DEBUG_TEMP(priv, \"entering CT_KILL state when \"\n\t\t\t\t\"temperature timer expired\\n\");\n\t\ttt->state = IWL_TI_CT_KILL;\n\t\tset_bit(STATUS_CT_KILL, &priv->status);\n\t\tiwl_perform_ct_kill_task(priv, true);\n\t}\n}\n\nstatic void iwl_prepare_ct_kill_task(struct iwl_priv *priv)\n{\n\tIWL_DEBUG_TEMP(priv, \"Prepare to enter IWL_TI_CT_KILL\\n\");\n\t \n\tiwl_send_statistics_request(priv, 0, false);\n\t \n\tmod_timer(&priv->thermal_throttle.ct_kill_waiting_tm,\n\t\t jiffies + msecs_to_jiffies(CT_KILL_WAITING_DURATION));\n}\n\n#define IWL_MINIMAL_POWER_THRESHOLD\t\t(CT_KILL_THRESHOLD_LEGACY)\n#define IWL_REDUCED_PERFORMANCE_THRESHOLD_2\t(100)\n#define IWL_REDUCED_PERFORMANCE_THRESHOLD_1\t(90)\n\n \nstatic void iwl_legacy_tt_handler(struct iwl_priv *priv, s32 temp, bool force)\n{\n\tstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;\n\tenum iwl_tt_state old_state;\n\n#ifdef CONFIG_IWLWIFI_DEBUG\n\tif ((tt->tt_previous_temp) &&\n\t    (temp > tt->tt_previous_temp) &&\n\t    ((temp - tt->tt_previous_temp) >\n\t    IWL_TT_INCREASE_MARGIN)) {\n\t\tIWL_DEBUG_TEMP(priv,\n\t\t\t\"Temperature increase %d degree Celsius\\n\",\n\t\t\t(temp - tt->tt_previous_temp));\n\t}\n#endif\n\told_state = tt->state;\n\t \n\tif (temp >= IWL_MINIMAL_POWER_THRESHOLD)\n\t\ttt->state = IWL_TI_CT_KILL;\n\telse if (temp >= IWL_REDUCED_PERFORMANCE_THRESHOLD_2)\n\t\ttt->state = IWL_TI_2;\n\telse if (temp >= IWL_REDUCED_PERFORMANCE_THRESHOLD_1)\n\t\ttt->state = IWL_TI_1;\n\telse\n\t\ttt->state = IWL_TI_0;\n\n#ifdef CONFIG_IWLWIFI_DEBUG\n\ttt->tt_previous_temp = temp;\n#endif\n\t \n\tdel_timer_sync(&priv->thermal_throttle.ct_kill_waiting_tm);\n\tif (tt->state != old_state) {\n\t\tswitch (tt->state) {\n\t\tcase IWL_TI_0:\n\t\t\t \n\t\t\tbreak;\n\t\tcase IWL_TI_1:\n\t\t\ttt->tt_power_mode = IWL_POWER_INDEX_3;\n\t\t\tbreak;\n\t\tcase IWL_TI_2:\n\t\t\ttt->tt_power_mode = IWL_POWER_INDEX_4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttt->tt_power_mode = IWL_POWER_INDEX_5;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_lock(&priv->mutex);\n\t\tif (old_state == IWL_TI_CT_KILL)\n\t\t\tclear_bit(STATUS_CT_KILL, &priv->status);\n\t\tif (tt->state != IWL_TI_CT_KILL &&\n\t\t    iwl_power_update_mode(priv, true)) {\n\t\t\t \n\t\t\tif (old_state == IWL_TI_CT_KILL)\n\t\t\t\tset_bit(STATUS_CT_KILL, &priv->status);\n\t\t\ttt->state = old_state;\n\t\t\tIWL_ERR(priv, \"Cannot update power mode, \"\n\t\t\t\t\t\"TT state not updated\\n\");\n\t\t} else {\n\t\t\tif (tt->state == IWL_TI_CT_KILL) {\n\t\t\t\tif (force) {\n\t\t\t\t\tset_bit(STATUS_CT_KILL, &priv->status);\n\t\t\t\t\tiwl_perform_ct_kill_task(priv, true);\n\t\t\t\t} else {\n\t\t\t\t\tiwl_prepare_ct_kill_task(priv);\n\t\t\t\t\ttt->state = old_state;\n\t\t\t\t}\n\t\t\t} else if (old_state == IWL_TI_CT_KILL) {\n\t\t\t\tiwl_perform_ct_kill_task(priv, false);\n\t\t\t}\n\t\t\tIWL_DEBUG_TEMP(priv, \"Temperature state changed %u\\n\",\n\t\t\t\t\ttt->state);\n\t\t\tIWL_DEBUG_TEMP(priv, \"Power Index change to %u\\n\",\n\t\t\t\t\ttt->tt_power_mode);\n\t\t}\n\t\tmutex_unlock(&priv->mutex);\n\t}\n}\n\n \nstatic void iwl_advance_tt_handler(struct iwl_priv *priv, s32 temp, bool force)\n{\n\tstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;\n\tint i;\n\tbool changed = false;\n\tenum iwl_tt_state old_state;\n\tstruct iwl_tt_trans *transaction;\n\n\told_state = tt->state;\n\tfor (i = 0; i < IWL_TI_STATE_MAX - 1; i++) {\n\t\t \n\t\ttransaction = tt->transaction +\n\t\t\t((old_state * (IWL_TI_STATE_MAX - 1)) + i);\n\t\tif (temp >= transaction->tt_low &&\n\t\t    temp <= transaction->tt_high) {\n#ifdef CONFIG_IWLWIFI_DEBUG\n\t\t\tif ((tt->tt_previous_temp) &&\n\t\t\t    (temp > tt->tt_previous_temp) &&\n\t\t\t    ((temp - tt->tt_previous_temp) >\n\t\t\t    IWL_TT_INCREASE_MARGIN)) {\n\t\t\t\tIWL_DEBUG_TEMP(priv,\n\t\t\t\t\t\"Temperature increase %d \"\n\t\t\t\t\t\"degree Celsius\\n\",\n\t\t\t\t\t(temp - tt->tt_previous_temp));\n\t\t\t}\n\t\t\ttt->tt_previous_temp = temp;\n#endif\n\t\t\tif (old_state !=\n\t\t\t    transaction->next_state) {\n\t\t\t\tchanged = true;\n\t\t\t\ttt->state =\n\t\t\t\t\ttransaction->next_state;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tdel_timer_sync(&priv->thermal_throttle.ct_kill_waiting_tm);\n\tif (changed) {\n\t\tif (tt->state >= IWL_TI_1) {\n\t\t\t \n\t\t\ttt->tt_power_mode = IWL_POWER_INDEX_5;\n\n\t\t\tif (!iwl_ht_enabled(priv)) {\n\t\t\t\tstruct iwl_rxon_context *ctx;\n\n\t\t\t\tfor_each_context(priv, ctx) {\n\t\t\t\t\tstruct iwl_rxon_cmd *rxon;\n\n\t\t\t\t\trxon = &ctx->staging;\n\n\t\t\t\t\t \n\t\t\t\t\trxon->flags &= ~(\n\t\t\t\t\t\tRXON_FLG_CHANNEL_MODE_MSK |\n\t\t\t\t\t\tRXON_FLG_CTRL_CHANNEL_LOC_HI_MSK |\n\t\t\t\t\t\tRXON_FLG_HT40_PROT_MSK |\n\t\t\t\t\t\tRXON_FLG_HT_PROT_MSK);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tiwl_set_rxon_ht(priv, &priv->current_ht_config);\n\t\t\t}\n\n\t\t} else {\n\t\t\t \n\n\t\t\t \n\t\t\tiwl_set_rxon_ht(priv, &priv->current_ht_config);\n\t\t}\n\t\tmutex_lock(&priv->mutex);\n\t\tif (old_state == IWL_TI_CT_KILL)\n\t\t\tclear_bit(STATUS_CT_KILL, &priv->status);\n\t\tif (tt->state != IWL_TI_CT_KILL &&\n\t\t    iwl_power_update_mode(priv, true)) {\n\t\t\t \n\t\t\tIWL_ERR(priv, \"Cannot update power mode, \"\n\t\t\t\t\t\"TT state not updated\\n\");\n\t\t\tif (old_state == IWL_TI_CT_KILL)\n\t\t\t\tset_bit(STATUS_CT_KILL, &priv->status);\n\t\t\ttt->state = old_state;\n\t\t} else {\n\t\t\tIWL_DEBUG_TEMP(priv,\n\t\t\t\t\t\"Thermal Throttling to new state: %u\\n\",\n\t\t\t\t\ttt->state);\n\t\t\tif (old_state != IWL_TI_CT_KILL &&\n\t\t\t    tt->state == IWL_TI_CT_KILL) {\n\t\t\t\tif (force) {\n\t\t\t\t\tIWL_DEBUG_TEMP(priv,\n\t\t\t\t\t\t\"Enter IWL_TI_CT_KILL\\n\");\n\t\t\t\t\tset_bit(STATUS_CT_KILL, &priv->status);\n\t\t\t\t\tiwl_perform_ct_kill_task(priv, true);\n\t\t\t\t} else {\n\t\t\t\t\ttt->state = old_state;\n\t\t\t\t\tiwl_prepare_ct_kill_task(priv);\n\t\t\t\t}\n\t\t\t} else if (old_state == IWL_TI_CT_KILL &&\n\t\t\t\t  tt->state != IWL_TI_CT_KILL) {\n\t\t\t\tIWL_DEBUG_TEMP(priv, \"Exit IWL_TI_CT_KILL\\n\");\n\t\t\t\tiwl_perform_ct_kill_task(priv, false);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&priv->mutex);\n\t}\n}\n\n \nstatic void iwl_bg_ct_enter(struct work_struct *work)\n{\n\tstruct iwl_priv *priv = container_of(work, struct iwl_priv, ct_enter);\n\tstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;\n\n\tif (test_bit(STATUS_EXIT_PENDING, &priv->status))\n\t\treturn;\n\n\tif (!iwl_is_ready(priv))\n\t\treturn;\n\n\tif (tt->state != IWL_TI_CT_KILL) {\n\t\tIWL_ERR(priv, \"Device reached critical temperature \"\n\t\t\t      \"- ucode going to sleep!\\n\");\n\t\tif (!priv->thermal_throttle.advanced_tt)\n\t\t\tiwl_legacy_tt_handler(priv,\n\t\t\t\t\t      IWL_MINIMAL_POWER_THRESHOLD,\n\t\t\t\t\t      true);\n\t\telse\n\t\t\tiwl_advance_tt_handler(priv,\n\t\t\t\t\t       CT_KILL_THRESHOLD + 1, true);\n\t}\n}\n\n \nstatic void iwl_bg_ct_exit(struct work_struct *work)\n{\n\tstruct iwl_priv *priv = container_of(work, struct iwl_priv, ct_exit);\n\tstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;\n\n\tif (test_bit(STATUS_EXIT_PENDING, &priv->status))\n\t\treturn;\n\n\tif (!iwl_is_ready(priv))\n\t\treturn;\n\n\t \n\tdel_timer_sync(&priv->thermal_throttle.ct_kill_exit_tm);\n\n\tif (tt->state == IWL_TI_CT_KILL) {\n\t\tIWL_ERR(priv,\n\t\t\t\"Device temperature below critical\"\n\t\t\t\"- ucode awake!\\n\");\n\t\t \n\t\tpriv->temperature = 0;\n\t\tif (!priv->thermal_throttle.advanced_tt)\n\t\t\tiwl_legacy_tt_handler(priv,\n\t\t\t\t      IWL_REDUCED_PERFORMANCE_THRESHOLD_2,\n\t\t\t\t      true);\n\t\telse\n\t\t\tiwl_advance_tt_handler(priv, CT_KILL_EXIT_THRESHOLD,\n\t\t\t\t\t       true);\n\t}\n}\n\nvoid iwl_tt_enter_ct_kill(struct iwl_priv *priv)\n{\n\tif (test_bit(STATUS_EXIT_PENDING, &priv->status))\n\t\treturn;\n\n\tIWL_DEBUG_TEMP(priv, \"Queueing critical temperature enter.\\n\");\n\tqueue_work(priv->workqueue, &priv->ct_enter);\n}\n\nvoid iwl_tt_exit_ct_kill(struct iwl_priv *priv)\n{\n\tif (test_bit(STATUS_EXIT_PENDING, &priv->status))\n\t\treturn;\n\n\tIWL_DEBUG_TEMP(priv, \"Queueing critical temperature exit.\\n\");\n\tqueue_work(priv->workqueue, &priv->ct_exit);\n}\n\nstatic void iwl_bg_tt_work(struct work_struct *work)\n{\n\tstruct iwl_priv *priv = container_of(work, struct iwl_priv, tt_work);\n\ts32 temp = priv->temperature;  \n\n\tif (test_bit(STATUS_EXIT_PENDING, &priv->status))\n\t\treturn;\n\n\tif (!priv->thermal_throttle.advanced_tt)\n\t\tiwl_legacy_tt_handler(priv, temp, false);\n\telse\n\t\tiwl_advance_tt_handler(priv, temp, false);\n}\n\nvoid iwl_tt_handler(struct iwl_priv *priv)\n{\n\tif (test_bit(STATUS_EXIT_PENDING, &priv->status))\n\t\treturn;\n\n\tIWL_DEBUG_TEMP(priv, \"Queueing thermal throttling work.\\n\");\n\tqueue_work(priv->workqueue, &priv->tt_work);\n}\n\n \nvoid iwl_tt_initialize(struct iwl_priv *priv)\n{\n\tstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;\n\tint size = sizeof(struct iwl_tt_trans) * (IWL_TI_STATE_MAX - 1);\n\tstruct iwl_tt_trans *transaction;\n\n\tIWL_DEBUG_TEMP(priv, \"Initialize Thermal Throttling\\n\");\n\n\tmemset(tt, 0, sizeof(struct iwl_tt_mgmt));\n\n\ttt->state = IWL_TI_0;\n\ttimer_setup(&priv->thermal_throttle.ct_kill_exit_tm,\n\t\t    iwl_tt_check_exit_ct_kill, 0);\n\ttimer_setup(&priv->thermal_throttle.ct_kill_waiting_tm,\n\t\t    iwl_tt_ready_for_ct_kill, 0);\n\t \n\tINIT_WORK(&priv->tt_work, iwl_bg_tt_work);\n\tINIT_WORK(&priv->ct_enter, iwl_bg_ct_enter);\n\tINIT_WORK(&priv->ct_exit, iwl_bg_ct_exit);\n\n\tif (priv->lib->adv_thermal_throttle) {\n\t\tIWL_DEBUG_TEMP(priv, \"Advanced Thermal Throttling\\n\");\n\t\ttt->restriction = kcalloc(IWL_TI_STATE_MAX,\n\t\t\t\t\t  sizeof(struct iwl_tt_restriction),\n\t\t\t\t\t  GFP_KERNEL);\n\t\ttt->transaction = kcalloc(IWL_TI_STATE_MAX *\n\t\t\t\t\t  (IWL_TI_STATE_MAX - 1),\n\t\t\t\t\t  sizeof(struct iwl_tt_trans),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!tt->restriction || !tt->transaction) {\n\t\t\tIWL_ERR(priv, \"Fallback to Legacy Throttling\\n\");\n\t\t\tpriv->thermal_throttle.advanced_tt = false;\n\t\t\tkfree(tt->restriction);\n\t\t\ttt->restriction = NULL;\n\t\t\tkfree(tt->transaction);\n\t\t\ttt->transaction = NULL;\n\t\t} else {\n\t\t\ttransaction = tt->transaction +\n\t\t\t\t(IWL_TI_0 * (IWL_TI_STATE_MAX - 1));\n\t\t\tmemcpy(transaction, &tt_range_0[0], size);\n\t\t\ttransaction = tt->transaction +\n\t\t\t\t(IWL_TI_1 * (IWL_TI_STATE_MAX - 1));\n\t\t\tmemcpy(transaction, &tt_range_1[0], size);\n\t\t\ttransaction = tt->transaction +\n\t\t\t\t(IWL_TI_2 * (IWL_TI_STATE_MAX - 1));\n\t\t\tmemcpy(transaction, &tt_range_2[0], size);\n\t\t\ttransaction = tt->transaction +\n\t\t\t\t(IWL_TI_CT_KILL * (IWL_TI_STATE_MAX - 1));\n\t\t\tmemcpy(transaction, &tt_range_3[0], size);\n\t\t\tsize = sizeof(struct iwl_tt_restriction) *\n\t\t\t\tIWL_TI_STATE_MAX;\n\t\t\tmemcpy(tt->restriction,\n\t\t\t\t&restriction_range[0], size);\n\t\t\tpriv->thermal_throttle.advanced_tt = true;\n\t\t}\n\t} else {\n\t\tIWL_DEBUG_TEMP(priv, \"Legacy Thermal Throttling\\n\");\n\t\tpriv->thermal_throttle.advanced_tt = false;\n\t}\n}\n\n \nvoid iwl_tt_exit(struct iwl_priv *priv)\n{\n\tstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;\n\n\t \n\tdel_timer_sync(&priv->thermal_throttle.ct_kill_exit_tm);\n\t \n\tdel_timer_sync(&priv->thermal_throttle.ct_kill_waiting_tm);\n\tcancel_work_sync(&priv->tt_work);\n\tcancel_work_sync(&priv->ct_enter);\n\tcancel_work_sync(&priv->ct_exit);\n\n\tif (priv->thermal_throttle.advanced_tt) {\n\t\t \n\t\tkfree(tt->restriction);\n\t\ttt->restriction = NULL;\n\t\tkfree(tt->transaction);\n\t\ttt->transaction = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}