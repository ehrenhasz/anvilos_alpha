{
  "module_name": "scan.c",
  "hash_id": "e46c2ad27473036bb87c554b9cbe0ff4f9856f0d79755f801cc0f694442e3834",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/dvm/scan.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/etherdevice.h>\n#include <net/mac80211.h>\n\n#include \"dev.h\"\n#include \"agn.h\"\n\n \n#define IWL_ACTIVE_DWELL_TIME_24    (30)        \n#define IWL_ACTIVE_DWELL_TIME_52    (20)\n\n#define IWL_ACTIVE_DWELL_FACTOR_24GHZ (3)\n#define IWL_ACTIVE_DWELL_FACTOR_52GHZ (2)\n\n \n#define IWL_PASSIVE_DWELL_TIME_24   (20)        \n#define IWL_PASSIVE_DWELL_TIME_52   (10)\n#define IWL_PASSIVE_DWELL_BASE      (100)\n#define IWL_CHANNEL_TUNE_TIME       5\n#define MAX_SCAN_CHANNEL\t    50\n\n \n#define IWL_RADIO_RESET_DWELL_TIME\t5\n\nstatic int iwl_send_scan_abort(struct iwl_priv *priv)\n{\n\tint ret;\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = REPLY_SCAN_ABORT_CMD,\n\t\t.flags = CMD_WANT_SKB,\n\t};\n\t__le32 *status;\n\n\t \n\tif (!test_bit(STATUS_READY, &priv->status) ||\n\t    !test_bit(STATUS_SCAN_HW, &priv->status) ||\n\t    test_bit(STATUS_FW_ERROR, &priv->status))\n\t\treturn -EIO;\n\n\tret = iwl_dvm_send_cmd(priv, &cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tstatus = (void *)cmd.resp_pkt->data;\n\tif (*status != CAN_ABORT_STATUS) {\n\t\t \n\t\tIWL_DEBUG_SCAN(priv, \"SCAN_ABORT ret %d.\\n\",\n\t\t\t       le32_to_cpu(*status));\n\t\tret = -EIO;\n\t}\n\n\tiwl_free_resp(&cmd);\n\treturn ret;\n}\n\nstatic void iwl_complete_scan(struct iwl_priv *priv, bool aborted)\n{\n\tstruct cfg80211_scan_info info = {\n\t\t.aborted = aborted,\n\t};\n\n\t \n\tif (priv->scan_request) {\n\t\tIWL_DEBUG_SCAN(priv, \"Complete scan in mac80211\\n\");\n\t\tieee80211_scan_completed(priv->hw, &info);\n\t}\n\n\tpriv->scan_type = IWL_SCAN_NORMAL;\n\tpriv->scan_vif = NULL;\n\tpriv->scan_request = NULL;\n}\n\nstatic void iwl_process_scan_complete(struct iwl_priv *priv)\n{\n\tbool aborted;\n\n\tlockdep_assert_held(&priv->mutex);\n\n\tif (!test_and_clear_bit(STATUS_SCAN_COMPLETE, &priv->status))\n\t\treturn;\n\n\tIWL_DEBUG_SCAN(priv, \"Completed scan.\\n\");\n\n\tcancel_delayed_work(&priv->scan_check);\n\n\taborted = test_and_clear_bit(STATUS_SCAN_ABORTING, &priv->status);\n\tif (aborted)\n\t\tIWL_DEBUG_SCAN(priv, \"Aborted scan completed.\\n\");\n\n\tif (!test_and_clear_bit(STATUS_SCANNING, &priv->status)) {\n\t\tIWL_DEBUG_SCAN(priv, \"Scan already completed.\\n\");\n\t\tgoto out_settings;\n\t}\n\n\tif (priv->scan_type != IWL_SCAN_NORMAL && !aborted) {\n\t\tint err;\n\n\t\t \n\t\tif (priv->scan_request == NULL)\n\t\t\tgoto out_complete;\n\n\t\t \n\t\terr = iwl_scan_initiate(priv, priv->scan_vif, IWL_SCAN_NORMAL,\n\t\t\t\t\tpriv->scan_request->channels[0]->band);\n\t\tif (err) {\n\t\t\tIWL_DEBUG_SCAN(priv,\n\t\t\t\t\"failed to initiate pending scan: %d\\n\", err);\n\t\t\taborted = true;\n\t\t\tgoto out_complete;\n\t\t}\n\n\t\treturn;\n\t}\n\nout_complete:\n\tiwl_complete_scan(priv, aborted);\n\nout_settings:\n\t \n\tif (!iwl_is_ready_rf(priv))\n\t\treturn;\n\n\tiwlagn_post_scan(priv);\n}\n\nvoid iwl_force_scan_end(struct iwl_priv *priv)\n{\n\tlockdep_assert_held(&priv->mutex);\n\n\tif (!test_bit(STATUS_SCANNING, &priv->status)) {\n\t\tIWL_DEBUG_SCAN(priv, \"Forcing scan end while not scanning\\n\");\n\t\treturn;\n\t}\n\n\tIWL_DEBUG_SCAN(priv, \"Forcing scan end\\n\");\n\tclear_bit(STATUS_SCANNING, &priv->status);\n\tclear_bit(STATUS_SCAN_HW, &priv->status);\n\tclear_bit(STATUS_SCAN_ABORTING, &priv->status);\n\tclear_bit(STATUS_SCAN_COMPLETE, &priv->status);\n\tiwl_complete_scan(priv, true);\n}\n\nstatic void iwl_do_scan_abort(struct iwl_priv *priv)\n{\n\tint ret;\n\n\tlockdep_assert_held(&priv->mutex);\n\n\tif (!test_bit(STATUS_SCANNING, &priv->status)) {\n\t\tIWL_DEBUG_SCAN(priv, \"Not performing scan to abort\\n\");\n\t\treturn;\n\t}\n\n\tif (test_and_set_bit(STATUS_SCAN_ABORTING, &priv->status)) {\n\t\tIWL_DEBUG_SCAN(priv, \"Scan abort in progress\\n\");\n\t\treturn;\n\t}\n\n\tret = iwl_send_scan_abort(priv);\n\tif (ret) {\n\t\tIWL_DEBUG_SCAN(priv, \"Send scan abort failed %d\\n\", ret);\n\t\tiwl_force_scan_end(priv);\n\t} else\n\t\tIWL_DEBUG_SCAN(priv, \"Successfully send scan abort\\n\");\n}\n\n \nint iwl_scan_cancel(struct iwl_priv *priv)\n{\n\tIWL_DEBUG_SCAN(priv, \"Queuing abort scan\\n\");\n\tqueue_work(priv->workqueue, &priv->abort_scan);\n\treturn 0;\n}\n\n \nvoid iwl_scan_cancel_timeout(struct iwl_priv *priv, unsigned long ms)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(ms);\n\n\tlockdep_assert_held(&priv->mutex);\n\n\tIWL_DEBUG_SCAN(priv, \"Scan cancel timeout\\n\");\n\n\tiwl_do_scan_abort(priv);\n\n\twhile (time_before_eq(jiffies, timeout)) {\n\t\tif (!test_bit(STATUS_SCAN_HW, &priv->status))\n\t\t\tgoto finished;\n\t\tmsleep(20);\n\t}\n\n\treturn;\n\n finished:\n\t \n\tiwl_process_scan_complete(priv);\n}\n\n \nstatic void iwl_rx_reply_scan(struct iwl_priv *priv,\n\t\t\t      struct iwl_rx_cmd_buffer *rxb)\n{\n#ifdef CONFIG_IWLWIFI_DEBUG\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_scanreq_notification *notif = (void *)pkt->data;\n\n\tIWL_DEBUG_SCAN(priv, \"Scan request status = 0x%x\\n\", notif->status);\n#endif\n}\n\n \nstatic void iwl_rx_scan_start_notif(struct iwl_priv *priv,\n\t\t\t\t    struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_scanstart_notification *notif = (void *)pkt->data;\n\n\tpriv->scan_start_tsf = le32_to_cpu(notif->tsf_low);\n\tIWL_DEBUG_SCAN(priv, \"Scan start: \"\n\t\t       \"%d [802.11%s] \"\n\t\t       \"(TSF: 0x%08X:%08X) - %d (beacon timer %u)\\n\",\n\t\t       notif->channel,\n\t\t       notif->band ? \"bg\" : \"a\",\n\t\t       le32_to_cpu(notif->tsf_high),\n\t\t       le32_to_cpu(notif->tsf_low),\n\t\t       notif->status, notif->beacon_timer);\n}\n\n \nstatic void iwl_rx_scan_results_notif(struct iwl_priv *priv,\n\t\t\t\t      struct iwl_rx_cmd_buffer *rxb)\n{\n#ifdef CONFIG_IWLWIFI_DEBUG\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_scanresults_notification *notif = (void *)pkt->data;\n\n\tIWL_DEBUG_SCAN(priv, \"Scan ch.res: \"\n\t\t       \"%d [802.11%s] \"\n\t\t       \"probe status: %u:%u \"\n\t\t       \"(TSF: 0x%08X:%08X) - %d \"\n\t\t       \"elapsed=%lu usec\\n\",\n\t\t       notif->channel,\n\t\t       notif->band ? \"bg\" : \"a\",\n\t\t       notif->probe_status, notif->num_probe_not_sent,\n\t\t       le32_to_cpu(notif->tsf_high),\n\t\t       le32_to_cpu(notif->tsf_low),\n\t\t       le32_to_cpu(notif->statistics[0]),\n\t\t       le32_to_cpu(notif->tsf_low) - priv->scan_start_tsf);\n#endif\n}\n\n \nstatic void iwl_rx_scan_complete_notif(struct iwl_priv *priv,\n\t\t\t\t       struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_scancomplete_notification *scan_notif = (void *)pkt->data;\n\n\tIWL_DEBUG_SCAN(priv, \"Scan complete: %d channels (TSF 0x%08X:%08X) - %d\\n\",\n\t\t       scan_notif->scanned_channels,\n\t\t       scan_notif->tsf_low,\n\t\t       scan_notif->tsf_high, scan_notif->status);\n\n\tIWL_DEBUG_SCAN(priv, \"Scan on %sGHz took %dms\\n\",\n\t\t       (priv->scan_band == NL80211_BAND_2GHZ) ? \"2.4\" : \"5.2\",\n\t\t       jiffies_to_msecs(jiffies - priv->scan_start));\n\n\t \n\tset_bit(STATUS_SCAN_COMPLETE, &priv->status);\n\tclear_bit(STATUS_SCAN_HW, &priv->status);\n\tqueue_work(priv->workqueue, &priv->scan_completed);\n\n\tif (priv->iw_mode != NL80211_IFTYPE_ADHOC &&\n\t    iwl_advanced_bt_coexist(priv) &&\n\t    priv->bt_status != scan_notif->bt_status) {\n\t\tif (scan_notif->bt_status) {\n\t\t\t \n\t\t\tif (!priv->bt_ch_announce)\n\t\t\t\tpriv->bt_traffic_load =\n\t\t\t\t\tIWL_BT_COEX_TRAFFIC_LOAD_HIGH;\n\t\t\t \n\t\t} else {\n\t\t\t \n\t\t\tpriv->bt_traffic_load =\n\t\t\t\tIWL_BT_COEX_TRAFFIC_LOAD_NONE;\n\t\t}\n\t\tpriv->bt_status = scan_notif->bt_status;\n\t\tqueue_work(priv->workqueue,\n\t\t\t   &priv->bt_traffic_change_work);\n\t}\n}\n\nvoid iwl_setup_rx_scan_handlers(struct iwl_priv *priv)\n{\n\t \n\tpriv->rx_handlers[REPLY_SCAN_CMD] = iwl_rx_reply_scan;\n\tpriv->rx_handlers[SCAN_START_NOTIFICATION] = iwl_rx_scan_start_notif;\n\tpriv->rx_handlers[SCAN_RESULTS_NOTIFICATION] =\n\t\t\t\t\tiwl_rx_scan_results_notif;\n\tpriv->rx_handlers[SCAN_COMPLETE_NOTIFICATION] =\n\t\t\t\t\tiwl_rx_scan_complete_notif;\n}\n\nstatic u16 iwl_get_active_dwell_time(struct iwl_priv *priv,\n\t\t\t\t     enum nl80211_band band, u8 n_probes)\n{\n\tif (band == NL80211_BAND_5GHZ)\n\t\treturn IWL_ACTIVE_DWELL_TIME_52 +\n\t\t\tIWL_ACTIVE_DWELL_FACTOR_52GHZ * (n_probes + 1);\n\telse\n\t\treturn IWL_ACTIVE_DWELL_TIME_24 +\n\t\t\tIWL_ACTIVE_DWELL_FACTOR_24GHZ * (n_probes + 1);\n}\n\nstatic u16 iwl_limit_dwell(struct iwl_priv *priv, u16 dwell_time)\n{\n\tstruct iwl_rxon_context *ctx;\n\tint limits[NUM_IWL_RXON_CTX] = {};\n\tint n_active = 0;\n\tu16 limit;\n\n\tBUILD_BUG_ON(NUM_IWL_RXON_CTX != 2);\n\n\t \n\tfor_each_context(priv, ctx) {\n\t\tswitch (ctx->staging.dev_type) {\n\t\tcase RXON_DEV_TYPE_P2P:\n\t\t\t \n\t\t\tcontinue;\n\t\tcase RXON_DEV_TYPE_ESS:\n\t\tdefault:\n\t\t\t \n\t\t\tif (!iwl_is_associated_ctx(ctx))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase RXON_DEV_TYPE_CP:\n\t\tcase RXON_DEV_TYPE_2STA:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tlimits[n_active++] = ctx->beacon_int ?: IWL_PASSIVE_DWELL_BASE;\n\t}\n\n\tswitch (n_active) {\n\tcase 0:\n\t\treturn dwell_time;\n\tcase 2:\n\t\tlimit = (limits[1] * 98) / 100 - IWL_CHANNEL_TUNE_TIME * 2;\n\t\tlimit /= 2;\n\t\tdwell_time = min(limit, dwell_time);\n\t\tfallthrough;\n\tcase 1:\n\t\tlimit = (limits[0] * 98) / 100 - IWL_CHANNEL_TUNE_TIME * 2;\n\t\tlimit /= n_active;\n\t\treturn min(limit, dwell_time);\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn dwell_time;\n\t}\n}\n\nstatic u16 iwl_get_passive_dwell_time(struct iwl_priv *priv,\n\t\t\t\t      enum nl80211_band band)\n{\n\tu16 passive = (band == NL80211_BAND_2GHZ) ?\n\t    IWL_PASSIVE_DWELL_BASE + IWL_PASSIVE_DWELL_TIME_24 :\n\t    IWL_PASSIVE_DWELL_BASE + IWL_PASSIVE_DWELL_TIME_52;\n\n\treturn iwl_limit_dwell(priv, passive);\n}\n\n \nstatic u8 iwl_get_single_channel_number(struct iwl_priv *priv,\n\t\t\t\t\tenum nl80211_band band)\n{\n\tstruct ieee80211_supported_band *sband = priv->hw->wiphy->bands[band];\n\tstruct iwl_rxon_context *ctx;\n\tint i;\n\n\tfor (i = 0; i < sband->n_channels; i++) {\n\t\tbool busy = false;\n\n\t\tfor_each_context(priv, ctx) {\n\t\t\tbusy = sband->channels[i].hw_value ==\n\t\t\t\tle16_to_cpu(ctx->staging.channel);\n\t\t\tif (busy)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (busy)\n\t\t\tcontinue;\n\n\t\tif (!(sband->channels[i].flags & IEEE80211_CHAN_DISABLED))\n\t\t\treturn sband->channels[i].hw_value;\n\t}\n\n\treturn 0;\n}\n\nstatic int iwl_get_channel_for_reset_scan(struct iwl_priv *priv,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  enum nl80211_band band,\n\t\t\t\t\t  struct iwl_scan_channel *scan_ch)\n{\n\tconst struct ieee80211_supported_band *sband;\n\tu16 channel;\n\n\tsband = iwl_get_hw_mode(priv, band);\n\tif (!sband) {\n\t\tIWL_ERR(priv, \"invalid band\\n\");\n\t\treturn 0;\n\t}\n\n\tchannel = iwl_get_single_channel_number(priv, band);\n\tif (channel) {\n\t\tscan_ch->channel = cpu_to_le16(channel);\n\t\tscan_ch->type = SCAN_CHANNEL_TYPE_PASSIVE;\n\t\tscan_ch->active_dwell =\n\t\t\tcpu_to_le16(IWL_RADIO_RESET_DWELL_TIME);\n\t\tscan_ch->passive_dwell =\n\t\t\tcpu_to_le16(IWL_RADIO_RESET_DWELL_TIME);\n\t\t \n\t\tscan_ch->dsp_atten = 110;\n\t\tif (band == NL80211_BAND_5GHZ)\n\t\t\tscan_ch->tx_gain = ((1 << 5) | (3 << 3)) | 3;\n\t\telse\n\t\t\tscan_ch->tx_gain = ((1 << 5) | (5 << 3));\n\t\treturn 1;\n\t}\n\n\tIWL_ERR(priv, \"no valid channel found\\n\");\n\treturn 0;\n}\n\nstatic int iwl_get_channels_for_scan(struct iwl_priv *priv,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     enum nl80211_band band,\n\t\t\t\t     u8 is_active, u8 n_probes,\n\t\t\t\t     struct iwl_scan_channel *scan_ch)\n{\n\tstruct ieee80211_channel *chan;\n\tconst struct ieee80211_supported_band *sband;\n\tu16 passive_dwell = 0;\n\tu16 active_dwell = 0;\n\tint added, i;\n\tu16 channel;\n\n\tsband = iwl_get_hw_mode(priv, band);\n\tif (!sband)\n\t\treturn 0;\n\n\tactive_dwell = iwl_get_active_dwell_time(priv, band, n_probes);\n\tpassive_dwell = iwl_get_passive_dwell_time(priv, band);\n\n\tif (passive_dwell <= active_dwell)\n\t\tpassive_dwell = active_dwell + 1;\n\n\tfor (i = 0, added = 0; i < priv->scan_request->n_channels; i++) {\n\t\tchan = priv->scan_request->channels[i];\n\n\t\tif (chan->band != band)\n\t\t\tcontinue;\n\n\t\tchannel = chan->hw_value;\n\t\tscan_ch->channel = cpu_to_le16(channel);\n\n\t\tif (!is_active || (chan->flags & IEEE80211_CHAN_NO_IR))\n\t\t\tscan_ch->type = SCAN_CHANNEL_TYPE_PASSIVE;\n\t\telse\n\t\t\tscan_ch->type = SCAN_CHANNEL_TYPE_ACTIVE;\n\n\t\tif (n_probes)\n\t\t\tscan_ch->type |= IWL_SCAN_PROBE_MASK(n_probes);\n\n\t\tscan_ch->active_dwell = cpu_to_le16(active_dwell);\n\t\tscan_ch->passive_dwell = cpu_to_le16(passive_dwell);\n\n\t\t \n\t\tscan_ch->dsp_atten = 110;\n\n\t\t \n\t\tif (band == NL80211_BAND_5GHZ)\n\t\t\tscan_ch->tx_gain = ((1 << 5) | (3 << 3)) | 3;\n\t\telse\n\t\t\tscan_ch->tx_gain = ((1 << 5) | (5 << 3));\n\n\t\tIWL_DEBUG_SCAN(priv, \"Scanning ch=%d prob=0x%X [%s %d]\\n\",\n\t\t\t       channel, le32_to_cpu(scan_ch->type),\n\t\t\t       (scan_ch->type & SCAN_CHANNEL_TYPE_ACTIVE) ?\n\t\t\t\t\"ACTIVE\" : \"PASSIVE\",\n\t\t\t       (scan_ch->type & SCAN_CHANNEL_TYPE_ACTIVE) ?\n\t\t\t       active_dwell : passive_dwell);\n\n\t\tscan_ch++;\n\t\tadded++;\n\t}\n\n\tIWL_DEBUG_SCAN(priv, \"total channels to scan %d\\n\", added);\n\treturn added;\n}\n\n \nstatic u16 iwl_fill_probe_req(struct ieee80211_mgmt *frame, const u8 *ta,\n\t\t\t      const u8 *ies, int ie_len, const u8 *ssid,\n\t\t\t      u8 ssid_len, int left)\n{\n\tint len = 0;\n\tu8 *pos = NULL;\n\n\t \n\tleft -= 24;\n\tif (left < 0)\n\t\treturn 0;\n\n\tframe->frame_control = cpu_to_le16(IEEE80211_STYPE_PROBE_REQ);\n\teth_broadcast_addr(frame->da);\n\tmemcpy(frame->sa, ta, ETH_ALEN);\n\teth_broadcast_addr(frame->bssid);\n\tframe->seq_ctrl = 0;\n\n\tlen += 24;\n\n\t \n\tpos = &frame->u.probe_req.variable[0];\n\n\t \n\tleft -= ssid_len + 2;\n\tif (left < 0)\n\t\treturn 0;\n\t*pos++ = WLAN_EID_SSID;\n\t*pos++ = ssid_len;\n\tif (ssid && ssid_len) {\n\t\tmemcpy(pos, ssid, ssid_len);\n\t\tpos += ssid_len;\n\t}\n\n\tlen += ssid_len + 2;\n\n\tif (WARN_ON(left < ie_len))\n\t\treturn len;\n\n\tif (ies && ie_len) {\n\t\tmemcpy(pos, ies, ie_len);\n\t\tlen += ie_len;\n\t}\n\n\treturn (u16)len;\n}\n\nstatic int iwlagn_request_scan(struct iwl_priv *priv, struct ieee80211_vif *vif)\n{\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = REPLY_SCAN_CMD,\n\t\t.len = { sizeof(struct iwl_scan_cmd), },\n\t};\n\tstruct iwl_scan_cmd *scan;\n\tstruct iwl_rxon_context *ctx = &priv->contexts[IWL_RXON_CTX_BSS];\n\tu32 rate_flags = 0;\n\tu16 cmd_len = 0;\n\tu16 rx_chain = 0;\n\tenum nl80211_band band;\n\tu8 n_probes = 0;\n\tu8 rx_ant = priv->nvm_data->valid_rx_ant;\n\tu8 rate;\n\tbool is_active = false;\n\tint  chan_mod;\n\tu8 active_chains;\n\tu8 scan_tx_antennas = priv->nvm_data->valid_tx_ant;\n\tint ret;\n\tsize_t scan_cmd_size = sizeof(struct iwl_scan_cmd) +\n\t\t\t    MAX_SCAN_CHANNEL * sizeof(struct iwl_scan_channel) +\n\t\t\t    priv->fw->ucode_capa.max_probe_length;\n\tconst u8 *ssid = NULL;\n\tu8 ssid_len = 0;\n\n\tif (WARN_ON(priv->scan_type == IWL_SCAN_NORMAL &&\n\t\t    (!priv->scan_request ||\n\t\t     priv->scan_request->n_channels > MAX_SCAN_CHANNEL)))\n\t\treturn -EINVAL;\n\n\tlockdep_assert_held(&priv->mutex);\n\n\tif (vif)\n\t\tctx = iwl_rxon_ctx_from_vif(vif);\n\n\tif (!priv->scan_cmd) {\n\t\tpriv->scan_cmd = kmalloc(scan_cmd_size, GFP_KERNEL);\n\t\tif (!priv->scan_cmd) {\n\t\t\tIWL_DEBUG_SCAN(priv,\n\t\t\t\t       \"fail to allocate memory for scan\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpriv->scan_cmd_size = scan_cmd_size;\n\t}\n\tif (priv->scan_cmd_size < scan_cmd_size) {\n\t\tIWL_DEBUG_SCAN(priv,\n\t\t\t       \"memory needed for scan grew unexpectedly\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tscan = priv->scan_cmd;\n\tmemset(scan, 0, priv->scan_cmd_size);\n\n\tscan->quiet_plcp_th = IWL_PLCP_QUIET_THRESH;\n\tscan->quiet_time = IWL_ACTIVE_QUIET_TIME;\n\n\tif (iwl_is_any_associated(priv)) {\n\t\tu16 interval = 0;\n\t\tu32 extra;\n\t\tu32 suspend_time = 100;\n\t\tu32 scan_suspend_time = 100;\n\n\t\tIWL_DEBUG_INFO(priv, \"Scanning while associated...\\n\");\n\t\tswitch (priv->scan_type) {\n\t\tcase IWL_SCAN_RADIO_RESET:\n\t\t\tinterval = 0;\n\t\t\tbreak;\n\t\tcase IWL_SCAN_NORMAL:\n\t\t\tinterval = vif->bss_conf.beacon_int;\n\t\t\tbreak;\n\t\t}\n\n\t\tscan->suspend_time = 0;\n\t\tscan->max_out_time = cpu_to_le32(200 * 1024);\n\t\tif (!interval)\n\t\t\tinterval = suspend_time;\n\n\t\textra = (suspend_time / interval) << 22;\n\t\tscan_suspend_time = (extra |\n\t\t    ((suspend_time % interval) * 1024));\n\t\tscan->suspend_time = cpu_to_le32(scan_suspend_time);\n\t\tIWL_DEBUG_SCAN(priv, \"suspend_time 0x%X beacon interval %d\\n\",\n\t\t\t       scan_suspend_time, interval);\n\t}\n\n\tswitch (priv->scan_type) {\n\tcase IWL_SCAN_RADIO_RESET:\n\t\tIWL_DEBUG_SCAN(priv, \"Start internal passive scan.\\n\");\n\t\t \n\t\tscan->quiet_time = cpu_to_le16(IWL_RADIO_RESET_DWELL_TIME);\n\t\tbreak;\n\tcase IWL_SCAN_NORMAL:\n\t\tif (priv->scan_request->n_ssids) {\n\t\t\tint i, p = 0;\n\t\t\tIWL_DEBUG_SCAN(priv, \"Kicking off active scan\\n\");\n\t\t\t \n\t\t\tssid_len = priv->scan_request->ssids[0].ssid_len;\n\t\t\tssid = priv->scan_request->ssids[0].ssid;\n\n\t\t\t \n\t\t\tfor (i = priv->scan_request->n_ssids - 1; i >= 1; i--) {\n\t\t\t\tscan->direct_scan[p].id = WLAN_EID_SSID;\n\t\t\t\tscan->direct_scan[p].len =\n\t\t\t\t\tpriv->scan_request->ssids[i].ssid_len;\n\t\t\t\tmemcpy(scan->direct_scan[p].ssid,\n\t\t\t\t       priv->scan_request->ssids[i].ssid,\n\t\t\t\t       priv->scan_request->ssids[i].ssid_len);\n\t\t\t\tn_probes++;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tis_active = true;\n\t\t} else\n\t\t\tIWL_DEBUG_SCAN(priv, \"Start passive scan.\\n\");\n\t\tbreak;\n\t}\n\n\tscan->tx_cmd.tx_flags = TX_CMD_FLG_SEQ_CTL_MSK;\n\tscan->tx_cmd.sta_id = ctx->bcast_sta_id;\n\tscan->tx_cmd.stop_time.life_time = TX_CMD_LIFE_TIME_INFINITE;\n\n\tswitch (priv->scan_band) {\n\tcase NL80211_BAND_2GHZ:\n\t\tscan->flags = RXON_FLG_BAND_24G_MSK | RXON_FLG_AUTO_DETECT_MSK;\n\t\tchan_mod = le32_to_cpu(\n\t\t\tpriv->contexts[IWL_RXON_CTX_BSS].active.flags &\n\t\t\t\t\t\tRXON_FLG_CHANNEL_MODE_MSK)\n\t\t\t\t       >> RXON_FLG_CHANNEL_MODE_POS;\n\t\tif ((priv->scan_request && priv->scan_request->no_cck) ||\n\t\t    chan_mod == CHANNEL_MODE_PURE_40) {\n\t\t\trate = IWL_RATE_6M_PLCP;\n\t\t} else {\n\t\t\trate = IWL_RATE_1M_PLCP;\n\t\t\trate_flags = RATE_MCS_CCK_MSK;\n\t\t}\n\t\t \n\t\tif (priv->lib->bt_params &&\n\t\t    priv->lib->bt_params->advanced_bt_coexist)\n\t\t\tscan->tx_cmd.tx_flags |= TX_CMD_FLG_IGNORE_BT;\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\trate = IWL_RATE_6M_PLCP;\n\t\tbreak;\n\tdefault:\n\t\tIWL_WARN(priv, \"Invalid scan band\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (priv->new_scan_threshold_behaviour)\n\t\tscan->good_CRC_th = is_active ? IWL_GOOD_CRC_TH_DEFAULT :\n\t\t\t\t\t\tIWL_GOOD_CRC_TH_DISABLED;\n\telse\n\t\tscan->good_CRC_th = is_active ? IWL_GOOD_CRC_TH_DEFAULT :\n\t\t\t\t\t\tIWL_GOOD_CRC_TH_NEVER;\n\n\tband = priv->scan_band;\n\n\tif (band == NL80211_BAND_2GHZ &&\n\t    priv->lib->bt_params &&\n\t    priv->lib->bt_params->advanced_bt_coexist) {\n\t\t \n\t\tscan_tx_antennas = first_antenna(scan_tx_antennas);\n\t}\n\n\tpriv->scan_tx_ant[band] = iwl_toggle_tx_ant(priv,\n\t\t\t\t\t\t    priv->scan_tx_ant[band],\n\t\t\t\t\t\t    scan_tx_antennas);\n\trate_flags |= iwl_ant_idx_to_flags(priv->scan_tx_ant[band]);\n\tscan->tx_cmd.rate_n_flags = iwl_hw_set_rate_n_flags(rate, rate_flags);\n\n\t \n\tif (test_bit(STATUS_POWER_PMI, &priv->status) &&\n\t    !(priv->hw->conf.flags & IEEE80211_CONF_IDLE)) {\n\t\t \n\t\tactive_chains = rx_ant &\n\t\t\t\t((u8)(priv->chain_noise_data.active_chains));\n\t\tif (!active_chains)\n\t\t\tactive_chains = rx_ant;\n\n\t\tIWL_DEBUG_SCAN(priv, \"chain_noise_data.active_chains: %u\\n\",\n\t\t\t\tpriv->chain_noise_data.active_chains);\n\n\t\trx_ant = first_antenna(active_chains);\n\t}\n\tif (priv->lib->bt_params &&\n\t    priv->lib->bt_params->advanced_bt_coexist &&\n\t    priv->bt_full_concurrent) {\n\t\t \n\t\trx_ant = first_antenna(rx_ant);\n\t}\n\n\t \n\trx_chain |=\n\t\tpriv->nvm_data->valid_rx_ant << RXON_RX_CHAIN_VALID_POS;\n\trx_chain |= rx_ant << RXON_RX_CHAIN_FORCE_MIMO_SEL_POS;\n\trx_chain |= rx_ant << RXON_RX_CHAIN_FORCE_SEL_POS;\n\trx_chain |= 0x1 << RXON_RX_CHAIN_DRIVER_FORCE_POS;\n\tscan->rx_chain = cpu_to_le16(rx_chain);\n\tswitch (priv->scan_type) {\n\tcase IWL_SCAN_NORMAL:\n\t\tcmd_len = iwl_fill_probe_req(\n\t\t\t\t\t(struct ieee80211_mgmt *)scan->data,\n\t\t\t\t\tvif->addr,\n\t\t\t\t\tpriv->scan_request->ie,\n\t\t\t\t\tpriv->scan_request->ie_len,\n\t\t\t\t\tssid, ssid_len,\n\t\t\t\t\tscan_cmd_size - sizeof(*scan));\n\t\tbreak;\n\tcase IWL_SCAN_RADIO_RESET:\n\t\t \n\t\tcmd_len = iwl_fill_probe_req(\n\t\t\t\t\t(struct ieee80211_mgmt *)scan->data,\n\t\t\t\t\tiwl_bcast_addr, NULL, 0,\n\t\t\t\t\tNULL, 0,\n\t\t\t\t\tscan_cmd_size - sizeof(*scan));\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tscan->tx_cmd.len = cpu_to_le16(cmd_len);\n\n\tscan->filter_flags |= (RXON_FILTER_ACCEPT_GRP_MSK |\n\t\t\t       RXON_FILTER_BCON_AWARE_MSK);\n\n\tswitch (priv->scan_type) {\n\tcase IWL_SCAN_RADIO_RESET:\n\t\tscan->channel_count =\n\t\t\tiwl_get_channel_for_reset_scan(priv, vif, band,\n\t\t\t\t(void *)&scan->data[cmd_len]);\n\t\tbreak;\n\tcase IWL_SCAN_NORMAL:\n\t\tscan->channel_count =\n\t\t\tiwl_get_channels_for_scan(priv, vif, band,\n\t\t\t\tis_active, n_probes,\n\t\t\t\t(void *)&scan->data[cmd_len]);\n\t\tbreak;\n\t}\n\n\tif (scan->channel_count == 0) {\n\t\tIWL_DEBUG_SCAN(priv, \"channel count %d\\n\", scan->channel_count);\n\t\treturn -EIO;\n\t}\n\n\tcmd.len[0] += le16_to_cpu(scan->tx_cmd.len) +\n\t    scan->channel_count * sizeof(struct iwl_scan_channel);\n\tcmd.data[0] = scan;\n\tcmd.dataflags[0] = IWL_HCMD_DFL_NOCOPY;\n\tscan->len = cpu_to_le16(cmd.len[0]);\n\n\t \n\tset_bit(STATUS_SCAN_HW, &priv->status);\n\n\tret = iwlagn_set_pan_params(priv);\n\tif (ret) {\n\t\tclear_bit(STATUS_SCAN_HW, &priv->status);\n\t\treturn ret;\n\t}\n\n\tret = iwl_dvm_send_cmd(priv, &cmd);\n\tif (ret) {\n\t\tclear_bit(STATUS_SCAN_HW, &priv->status);\n\t\tiwlagn_set_pan_params(priv);\n\t}\n\n\treturn ret;\n}\n\nvoid iwl_init_scan_params(struct iwl_priv *priv)\n{\n\tu8 ant_idx = fls(priv->nvm_data->valid_tx_ant) - 1;\n\tif (!priv->scan_tx_ant[NL80211_BAND_5GHZ])\n\t\tpriv->scan_tx_ant[NL80211_BAND_5GHZ] = ant_idx;\n\tif (!priv->scan_tx_ant[NL80211_BAND_2GHZ])\n\t\tpriv->scan_tx_ant[NL80211_BAND_2GHZ] = ant_idx;\n}\n\nint __must_check iwl_scan_initiate(struct iwl_priv *priv,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   enum iwl_scan_type scan_type,\n\t\t\t\t   enum nl80211_band band)\n{\n\tint ret;\n\n\tlockdep_assert_held(&priv->mutex);\n\n\tcancel_delayed_work(&priv->scan_check);\n\n\tif (!iwl_is_ready_rf(priv)) {\n\t\tIWL_WARN(priv, \"Request scan called when driver not ready.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (test_bit(STATUS_SCAN_HW, &priv->status)) {\n\t\tIWL_DEBUG_SCAN(priv,\n\t\t\t\"Multiple concurrent scan requests in parallel.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (test_bit(STATUS_SCAN_ABORTING, &priv->status)) {\n\t\tIWL_DEBUG_SCAN(priv, \"Scan request while abort pending.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tIWL_DEBUG_SCAN(priv, \"Starting %sscan...\\n\",\n\t\t\tscan_type == IWL_SCAN_NORMAL ? \"\" :\n\t\t\t\"internal short \");\n\n\tset_bit(STATUS_SCANNING, &priv->status);\n\tpriv->scan_type = scan_type;\n\tpriv->scan_start = jiffies;\n\tpriv->scan_band = band;\n\n\tret = iwlagn_request_scan(priv, vif);\n\tif (ret) {\n\t\tclear_bit(STATUS_SCANNING, &priv->status);\n\t\tpriv->scan_type = IWL_SCAN_NORMAL;\n\t\treturn ret;\n\t}\n\n\tqueue_delayed_work(priv->workqueue, &priv->scan_check,\n\t\t\t   IWL_SCAN_CHECK_WATCHDOG);\n\n\treturn 0;\n}\n\n\n \nvoid iwl_internal_short_hw_scan(struct iwl_priv *priv)\n{\n\tqueue_work(priv->workqueue, &priv->start_internal_scan);\n}\n\nstatic void iwl_bg_start_internal_scan(struct work_struct *work)\n{\n\tstruct iwl_priv *priv =\n\t\tcontainer_of(work, struct iwl_priv, start_internal_scan);\n\n\tIWL_DEBUG_SCAN(priv, \"Start internal scan\\n\");\n\n\tmutex_lock(&priv->mutex);\n\n\tif (priv->scan_type == IWL_SCAN_RADIO_RESET) {\n\t\tIWL_DEBUG_SCAN(priv, \"Internal scan already in progress\\n\");\n\t\tgoto unlock;\n\t}\n\n\tif (test_bit(STATUS_SCANNING, &priv->status)) {\n\t\tIWL_DEBUG_SCAN(priv, \"Scan already in progress.\\n\");\n\t\tgoto unlock;\n\t}\n\n\tif (iwl_scan_initiate(priv, NULL, IWL_SCAN_RADIO_RESET, priv->band))\n\t\tIWL_DEBUG_SCAN(priv, \"failed to start internal short scan\\n\");\n unlock:\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void iwl_bg_scan_check(struct work_struct *data)\n{\n\tstruct iwl_priv *priv =\n\t    container_of(data, struct iwl_priv, scan_check.work);\n\n\tIWL_DEBUG_SCAN(priv, \"Scan check work\\n\");\n\n\t \n\tmutex_lock(&priv->mutex);\n\tiwl_force_scan_end(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void iwl_bg_abort_scan(struct work_struct *work)\n{\n\tstruct iwl_priv *priv = container_of(work, struct iwl_priv, abort_scan);\n\n\tIWL_DEBUG_SCAN(priv, \"Abort scan work\\n\");\n\n\t \n\tmutex_lock(&priv->mutex);\n\tiwl_scan_cancel_timeout(priv, 200);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void iwl_bg_scan_completed(struct work_struct *work)\n{\n\tstruct iwl_priv *priv =\n\t\tcontainer_of(work, struct iwl_priv, scan_completed);\n\n\tmutex_lock(&priv->mutex);\n\tiwl_process_scan_complete(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nvoid iwl_setup_scan_deferred_work(struct iwl_priv *priv)\n{\n\tINIT_WORK(&priv->scan_completed, iwl_bg_scan_completed);\n\tINIT_WORK(&priv->abort_scan, iwl_bg_abort_scan);\n\tINIT_WORK(&priv->start_internal_scan, iwl_bg_start_internal_scan);\n\tINIT_DELAYED_WORK(&priv->scan_check, iwl_bg_scan_check);\n}\n\nvoid iwl_cancel_scan_deferred_work(struct iwl_priv *priv)\n{\n\tcancel_work_sync(&priv->start_internal_scan);\n\tcancel_work_sync(&priv->abort_scan);\n\tcancel_work_sync(&priv->scan_completed);\n\n\tif (cancel_delayed_work_sync(&priv->scan_check)) {\n\t\tmutex_lock(&priv->mutex);\n\t\tiwl_force_scan_end(priv);\n\t\tmutex_unlock(&priv->mutex);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}