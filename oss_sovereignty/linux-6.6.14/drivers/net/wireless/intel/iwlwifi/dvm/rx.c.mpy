{
  "module_name": "rx.c",
  "hash_id": "44fc396d35bae2cda126fc766bf2f2a414d9fe4fdf0bae979ccb32221a3fa919",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/dvm/rx.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <net/mac80211.h>\n#include <asm/unaligned.h>\n\n#include \"iwl-trans.h\"\n#include \"iwl-io.h\"\n#include \"dev.h\"\n#include \"calib.h\"\n#include \"agn.h\"\n\n \n\nstatic void iwlagn_rx_reply_error(struct iwl_priv *priv,\n\t\t\t\t  struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_error_resp *err_resp = (void *)pkt->data;\n\n\tIWL_ERR(priv, \"Error Reply type 0x%08X cmd REPLY_ERROR (0x%02X) \"\n\t\t\"seq 0x%04X ser 0x%08X\\n\",\n\t\tle32_to_cpu(err_resp->error_type),\n\t\terr_resp->cmd_id,\n\t\tle16_to_cpu(err_resp->bad_cmd_seq_num),\n\t\tle32_to_cpu(err_resp->error_info));\n}\n\nstatic void iwlagn_rx_csa(struct iwl_priv *priv, struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_csa_notification *csa = (void *)pkt->data;\n\t \n\tstruct iwl_rxon_context *ctx = &priv->contexts[IWL_RXON_CTX_BSS];\n\tstruct iwl_rxon_cmd *rxon = (void *)&ctx->active;\n\n\tif (!test_bit(STATUS_CHANNEL_SWITCH_PENDING, &priv->status))\n\t\treturn;\n\n\tif (!le32_to_cpu(csa->status) && csa->channel == priv->switch_channel) {\n\t\trxon->channel = csa->channel;\n\t\tctx->staging.channel = csa->channel;\n\t\tIWL_DEBUG_11H(priv, \"CSA notif: channel %d\\n\",\n\t\t\t      le16_to_cpu(csa->channel));\n\t\tiwl_chswitch_done(priv, true);\n\t} else {\n\t\tIWL_ERR(priv, \"CSA notif (fail) : channel %d\\n\",\n\t\t\tle16_to_cpu(csa->channel));\n\t\tiwl_chswitch_done(priv, false);\n\t}\n}\n\n\nstatic void iwlagn_rx_spectrum_measure_notif(struct iwl_priv *priv,\n\t\t\t\t\t     struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_spectrum_notification *report = (void *)pkt->data;\n\n\tif (!report->state) {\n\t\tIWL_DEBUG_11H(priv,\n\t\t\t\"Spectrum Measure Notification: Start\\n\");\n\t\treturn;\n\t}\n\n\tmemcpy(&priv->measure_report, report, sizeof(*report));\n\tpriv->measurement_status |= MEASUREMENT_READY;\n}\n\nstatic void iwlagn_rx_pm_sleep_notif(struct iwl_priv *priv,\n\t\t\t\t     struct iwl_rx_cmd_buffer *rxb)\n{\n#ifdef CONFIG_IWLWIFI_DEBUG\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_sleep_notification *sleep = (void *)pkt->data;\n\tIWL_DEBUG_RX(priv, \"sleep mode: %d, src: %d\\n\",\n\t\t     sleep->pm_sleep_mode, sleep->pm_wakeup_src);\n#endif\n}\n\nstatic void iwlagn_rx_pm_debug_statistics_notif(struct iwl_priv *priv,\n\t\t\t\t\t\tstruct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tu32 __maybe_unused len = iwl_rx_packet_len(pkt);\n\tIWL_DEBUG_RADIO(priv, \"Dumping %d bytes of unhandled \"\n\t\t\t\"notification for PM_DEBUG_STATISTIC_NOTIFIC:\\n\", len);\n\tiwl_print_hex_dump(priv, IWL_DL_RADIO, pkt->data, len);\n}\n\nstatic void iwlagn_rx_beacon_notif(struct iwl_priv *priv,\n\t\t\t\t   struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwlagn_beacon_notif *beacon = (void *)pkt->data;\n#ifdef CONFIG_IWLWIFI_DEBUG\n\tu16 status = le16_to_cpu(beacon->beacon_notify_hdr.status.status);\n\tu8 rate = iwl_hw_get_rate(beacon->beacon_notify_hdr.rate_n_flags);\n\n\tIWL_DEBUG_RX(priv, \"beacon status %#x, retries:%d ibssmgr:%d \"\n\t\t\"tsf:0x%.8x%.8x rate:%d\\n\",\n\t\tstatus & TX_STATUS_MSK,\n\t\tbeacon->beacon_notify_hdr.failure_frame,\n\t\tle32_to_cpu(beacon->ibss_mgr_status),\n\t\tle32_to_cpu(beacon->high_tsf),\n\t\tle32_to_cpu(beacon->low_tsf), rate);\n#endif\n\n\tpriv->ibss_manager = le32_to_cpu(beacon->ibss_mgr_status);\n}\n\n \nstatic bool iwlagn_good_plcp_health(struct iwl_priv *priv,\n\t\t\t\t struct statistics_rx_phy *cur_ofdm,\n\t\t\t\t struct statistics_rx_ht_phy *cur_ofdm_ht,\n\t\t\t\t unsigned int msecs)\n{\n\tint delta;\n\tint threshold = priv->plcp_delta_threshold;\n\n\tif (threshold == IWL_MAX_PLCP_ERR_THRESHOLD_DISABLE) {\n\t\tIWL_DEBUG_RADIO(priv, \"plcp_err check disabled\\n\");\n\t\treturn true;\n\t}\n\n\tdelta = le32_to_cpu(cur_ofdm->plcp_err) -\n\t\tle32_to_cpu(priv->statistics.rx_ofdm.plcp_err) +\n\t\tle32_to_cpu(cur_ofdm_ht->plcp_err) -\n\t\tle32_to_cpu(priv->statistics.rx_ofdm_ht.plcp_err);\n\n\t \n\tif (delta <= 0)\n\t\treturn true;\n\n\tif ((delta * 100 / msecs) > threshold) {\n\t\tIWL_DEBUG_RADIO(priv,\n\t\t\t\t\"plcp health threshold %u delta %d msecs %u\\n\",\n\t\t\t\tthreshold, delta, msecs);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nint iwl_force_rf_reset(struct iwl_priv *priv, bool external)\n{\n\tstruct iwl_rf_reset *rf_reset;\n\n\tif (test_bit(STATUS_EXIT_PENDING, &priv->status))\n\t\treturn -EAGAIN;\n\n\tif (!iwl_is_any_associated(priv)) {\n\t\tIWL_DEBUG_SCAN(priv, \"force reset rejected: not associated\\n\");\n\t\treturn -ENOLINK;\n\t}\n\n\trf_reset = &priv->rf_reset;\n\trf_reset->reset_request_count++;\n\tif (!external && rf_reset->last_reset_jiffies &&\n\t    time_after(rf_reset->last_reset_jiffies +\n\t\t       IWL_DELAY_NEXT_FORCE_RF_RESET, jiffies)) {\n\t\tIWL_DEBUG_INFO(priv, \"RF reset rejected\\n\");\n\t\trf_reset->reset_reject_count++;\n\t\treturn -EAGAIN;\n\t}\n\trf_reset->reset_success_count++;\n\trf_reset->last_reset_jiffies = jiffies;\n\n\t \n\tIWL_DEBUG_INFO(priv, \"perform radio reset.\\n\");\n\tiwl_internal_short_hw_scan(priv);\n\treturn 0;\n}\n\n\nstatic void iwlagn_recover_from_statistics(struct iwl_priv *priv,\n\t\t\t\tstruct statistics_rx_phy *cur_ofdm,\n\t\t\t\tstruct statistics_rx_ht_phy *cur_ofdm_ht,\n\t\t\t\tstruct statistics_tx *tx,\n\t\t\t\tunsigned long stamp)\n{\n\tunsigned int msecs;\n\n\tif (test_bit(STATUS_EXIT_PENDING, &priv->status))\n\t\treturn;\n\n\tmsecs = jiffies_to_msecs(stamp - priv->rx_statistics_jiffies);\n\n\t \n\tif (!iwl_is_any_associated(priv))\n\t\treturn;\n\n\t \n\tif (msecs < 99)\n\t\treturn;\n\n\tif (!iwlagn_good_plcp_health(priv, cur_ofdm, cur_ofdm_ht, msecs))\n\t\tiwl_force_rf_reset(priv, false);\n}\n\n \nstatic void iwlagn_rx_calc_noise(struct iwl_priv *priv)\n{\n\tstruct statistics_rx_non_phy *rx_info;\n\tint num_active_rx = 0;\n\tint total_silence = 0;\n\tint bcn_silence_a, bcn_silence_b, bcn_silence_c;\n\tint last_rx_noise;\n\n\trx_info = &priv->statistics.rx_non_phy;\n\n\tbcn_silence_a =\n\t\tle32_to_cpu(rx_info->beacon_silence_rssi_a) & IN_BAND_FILTER;\n\tbcn_silence_b =\n\t\tle32_to_cpu(rx_info->beacon_silence_rssi_b) & IN_BAND_FILTER;\n\tbcn_silence_c =\n\t\tle32_to_cpu(rx_info->beacon_silence_rssi_c) & IN_BAND_FILTER;\n\n\tif (bcn_silence_a) {\n\t\ttotal_silence += bcn_silence_a;\n\t\tnum_active_rx++;\n\t}\n\tif (bcn_silence_b) {\n\t\ttotal_silence += bcn_silence_b;\n\t\tnum_active_rx++;\n\t}\n\tif (bcn_silence_c) {\n\t\ttotal_silence += bcn_silence_c;\n\t\tnum_active_rx++;\n\t}\n\n\t \n\tif (num_active_rx)\n\t\tlast_rx_noise = (total_silence / num_active_rx) - 107;\n\telse\n\t\tlast_rx_noise = IWL_NOISE_MEAS_NOT_AVAILABLE;\n\n\tIWL_DEBUG_CALIB(priv, \"inband silence a %u, b %u, c %u, dBm %d\\n\",\n\t\t\tbcn_silence_a, bcn_silence_b, bcn_silence_c,\n\t\t\tlast_rx_noise);\n}\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n \nstatic void accum_stats(__le32 *prev, __le32 *cur, __le32 *delta,\n\t\t\t__le32 *max_delta, __le32 *accum, int size)\n{\n\tint i;\n\n\tfor (i = 0;\n\t     i < size / sizeof(__le32);\n\t     i++, prev++, cur++, delta++, max_delta++, accum++) {\n\t\tif (le32_to_cpu(*cur) > le32_to_cpu(*prev)) {\n\t\t\t*delta = cpu_to_le32(\n\t\t\t\tle32_to_cpu(*cur) - le32_to_cpu(*prev));\n\t\t\tle32_add_cpu(accum, le32_to_cpu(*delta));\n\t\t\tif (le32_to_cpu(*delta) > le32_to_cpu(*max_delta))\n\t\t\t\t*max_delta = *delta;\n\t\t}\n\t}\n}\n\nstatic void\niwlagn_accumulative_statistics(struct iwl_priv *priv,\n\t\t\t    struct statistics_general_common *common,\n\t\t\t    struct statistics_rx_non_phy *rx_non_phy,\n\t\t\t    struct statistics_rx_phy *rx_ofdm,\n\t\t\t    struct statistics_rx_ht_phy *rx_ofdm_ht,\n\t\t\t    struct statistics_rx_phy *rx_cck,\n\t\t\t    struct statistics_tx *tx,\n\t\t\t    struct statistics_bt_activity *bt_activity)\n{\n#define ACCUM(_name)\t\\\n\taccum_stats((__le32 *)&priv->statistics._name,\t\t\\\n\t\t    (__le32 *)_name,\t\t\t\t\\\n\t\t    (__le32 *)&priv->delta_stats._name,\t\t\\\n\t\t    (__le32 *)&priv->max_delta_stats._name,\t\\\n\t\t    (__le32 *)&priv->accum_stats._name,\t\t\\\n\t\t    sizeof(*_name))\n\n\tACCUM(common);\n\tACCUM(rx_non_phy);\n\tACCUM(rx_ofdm);\n\tACCUM(rx_ofdm_ht);\n\tACCUM(rx_cck);\n\tACCUM(tx);\n\tif (bt_activity)\n\t\tACCUM(bt_activity);\n#undef ACCUM\n}\n#else\nstatic inline void\niwlagn_accumulative_statistics(struct iwl_priv *priv,\n\t\t\t    struct statistics_general_common *common,\n\t\t\t    struct statistics_rx_non_phy *rx_non_phy,\n\t\t\t    struct statistics_rx_phy *rx_ofdm,\n\t\t\t    struct statistics_rx_ht_phy *rx_ofdm_ht,\n\t\t\t    struct statistics_rx_phy *rx_cck,\n\t\t\t    struct statistics_tx *tx,\n\t\t\t    struct statistics_bt_activity *bt_activity)\n{\n}\n#endif\n\nstatic void iwlagn_rx_statistics(struct iwl_priv *priv,\n\t\t\t\t struct iwl_rx_cmd_buffer *rxb)\n{\n\tunsigned long stamp = jiffies;\n\tconst int reg_recalib_period = 60;\n\tint change;\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tu32 len = iwl_rx_packet_payload_len(pkt);\n\t__le32 *flag;\n\tstruct statistics_general_common *common;\n\tstruct statistics_rx_non_phy *rx_non_phy;\n\tstruct statistics_rx_phy *rx_ofdm;\n\tstruct statistics_rx_ht_phy *rx_ofdm_ht;\n\tstruct statistics_rx_phy *rx_cck;\n\tstruct statistics_tx *tx;\n\tstruct statistics_bt_activity *bt_activity;\n\n\tIWL_DEBUG_RX(priv, \"Statistics notification received (%d bytes).\\n\",\n\t\t     len);\n\n\tspin_lock(&priv->statistics.lock);\n\n\tif (len == sizeof(struct iwl_bt_notif_statistics)) {\n\t\tstruct iwl_bt_notif_statistics *stats;\n\t\tstats = (void *)&pkt->data;\n\t\tflag = &stats->flag;\n\t\tcommon = &stats->general.common;\n\t\trx_non_phy = &stats->rx.general.common;\n\t\trx_ofdm = &stats->rx.ofdm;\n\t\trx_ofdm_ht = &stats->rx.ofdm_ht;\n\t\trx_cck = &stats->rx.cck;\n\t\ttx = &stats->tx;\n\t\tbt_activity = &stats->general.activity;\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\t\t \n\t\tpriv->statistics.num_bt_kills = stats->rx.general.num_bt_kills;\n\t\tle32_add_cpu(&priv->statistics.accum_num_bt_kills,\n\t\t\t     le32_to_cpu(stats->rx.general.num_bt_kills));\n#endif\n\t} else if (len == sizeof(struct iwl_notif_statistics)) {\n\t\tstruct iwl_notif_statistics *stats;\n\t\tstats = (void *)&pkt->data;\n\t\tflag = &stats->flag;\n\t\tcommon = &stats->general.common;\n\t\trx_non_phy = &stats->rx.general;\n\t\trx_ofdm = &stats->rx.ofdm;\n\t\trx_ofdm_ht = &stats->rx.ofdm_ht;\n\t\trx_cck = &stats->rx.cck;\n\t\ttx = &stats->tx;\n\t\tbt_activity = NULL;\n\t} else {\n\t\tWARN_ONCE(1, \"len %d doesn't match BT (%zu) or normal (%zu)\\n\",\n\t\t\t  len, sizeof(struct iwl_bt_notif_statistics),\n\t\t\t  sizeof(struct iwl_notif_statistics));\n\t\tspin_unlock(&priv->statistics.lock);\n\t\treturn;\n\t}\n\n\tchange = common->temperature != priv->statistics.common.temperature ||\n\t\t (*flag & STATISTICS_REPLY_FLG_HT40_MODE_MSK) !=\n\t\t (priv->statistics.flag & STATISTICS_REPLY_FLG_HT40_MODE_MSK);\n\n\tiwlagn_accumulative_statistics(priv, common, rx_non_phy, rx_ofdm,\n\t\t\t\t    rx_ofdm_ht, rx_cck, tx, bt_activity);\n\n\tiwlagn_recover_from_statistics(priv, rx_ofdm, rx_ofdm_ht, tx, stamp);\n\n\tpriv->statistics.flag = *flag;\n\tmemcpy(&priv->statistics.common, common, sizeof(*common));\n\tmemcpy(&priv->statistics.rx_non_phy, rx_non_phy, sizeof(*rx_non_phy));\n\tmemcpy(&priv->statistics.rx_ofdm, rx_ofdm, sizeof(*rx_ofdm));\n\tmemcpy(&priv->statistics.rx_ofdm_ht, rx_ofdm_ht, sizeof(*rx_ofdm_ht));\n\tmemcpy(&priv->statistics.rx_cck, rx_cck, sizeof(*rx_cck));\n\tmemcpy(&priv->statistics.tx, tx, sizeof(*tx));\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tif (bt_activity)\n\t\tmemcpy(&priv->statistics.bt_activity, bt_activity,\n\t\t\tsizeof(*bt_activity));\n#endif\n\n\tpriv->rx_statistics_jiffies = stamp;\n\n\tset_bit(STATUS_STATISTICS, &priv->status);\n\n\t \n\tmod_timer(&priv->statistics_periodic, jiffies +\n\t\t  msecs_to_jiffies(reg_recalib_period * 1000));\n\n\tif (unlikely(!test_bit(STATUS_SCANNING, &priv->status)) &&\n\t    (pkt->hdr.cmd == STATISTICS_NOTIFICATION)) {\n\t\tiwlagn_rx_calc_noise(priv);\n\t\tqueue_work(priv->workqueue, &priv->run_time_calib_work);\n\t}\n\tif (priv->lib->temperature && change)\n\t\tpriv->lib->temperature(priv);\n\n\tspin_unlock(&priv->statistics.lock);\n}\n\nstatic void iwlagn_rx_reply_statistics(struct iwl_priv *priv,\n\t\t\t\t       struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_notif_statistics *stats = (void *)pkt->data;\n\n\tif (le32_to_cpu(stats->flag) & UCODE_STATISTICS_CLEAR_MSK) {\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\t\tmemset(&priv->accum_stats, 0,\n\t\t\tsizeof(priv->accum_stats));\n\t\tmemset(&priv->delta_stats, 0,\n\t\t\tsizeof(priv->delta_stats));\n\t\tmemset(&priv->max_delta_stats, 0,\n\t\t\tsizeof(priv->max_delta_stats));\n#endif\n\t\tIWL_DEBUG_RX(priv, \"Statistics have been cleared\\n\");\n\t}\n\n\tiwlagn_rx_statistics(priv, rxb);\n}\n\n \nstatic void iwlagn_rx_card_state_notif(struct iwl_priv *priv,\n\t\t\t\t       struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_card_state_notif *card_state_notif = (void *)pkt->data;\n\tu32 flags = le32_to_cpu(card_state_notif->flags);\n\tunsigned long status = priv->status;\n\n\tIWL_DEBUG_RF_KILL(priv, \"Card state received: HW:%s SW:%s CT:%s\\n\",\n\t\t\t  (flags & HW_CARD_DISABLED) ? \"Kill\" : \"On\",\n\t\t\t  (flags & SW_CARD_DISABLED) ? \"Kill\" : \"On\",\n\t\t\t  (flags & CT_CARD_DISABLED) ?\n\t\t\t  \"Reached\" : \"Not reached\");\n\n\tif (flags & (SW_CARD_DISABLED | HW_CARD_DISABLED |\n\t\t     CT_CARD_DISABLED)) {\n\n\t\tiwl_write32(priv->trans, CSR_UCODE_DRV_GP1_SET,\n\t\t\t    CSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED);\n\n\t\tiwl_write_direct32(priv->trans, HBUS_TARG_MBX_C,\n\t\t\t\t\tHBUS_TARG_MBX_C_REG_BIT_CMD_BLOCKED);\n\n\t\tif (!(flags & RXON_CARD_DISABLED)) {\n\t\t\tiwl_write32(priv->trans, CSR_UCODE_DRV_GP1_CLR,\n\t\t\t\t    CSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED);\n\t\t\tiwl_write_direct32(priv->trans, HBUS_TARG_MBX_C,\n\t\t\t\t\tHBUS_TARG_MBX_C_REG_BIT_CMD_BLOCKED);\n\t\t}\n\t\tif (flags & CT_CARD_DISABLED)\n\t\t\tiwl_tt_enter_ct_kill(priv);\n\t}\n\tif (!(flags & CT_CARD_DISABLED))\n\t\tiwl_tt_exit_ct_kill(priv);\n\n\tif (flags & HW_CARD_DISABLED)\n\t\tset_bit(STATUS_RF_KILL_HW, &priv->status);\n\telse\n\t\tclear_bit(STATUS_RF_KILL_HW, &priv->status);\n\n\n\tif (!(flags & RXON_CARD_DISABLED))\n\t\tiwl_scan_cancel(priv);\n\n\tif ((test_bit(STATUS_RF_KILL_HW, &status) !=\n\t     test_bit(STATUS_RF_KILL_HW, &priv->status)))\n\t\twiphy_rfkill_set_hw_state(priv->hw->wiphy,\n\t\t\ttest_bit(STATUS_RF_KILL_HW, &priv->status));\n}\n\nstatic void iwlagn_rx_missed_beacon_notif(struct iwl_priv *priv,\n\t\t\t\t\t  struct iwl_rx_cmd_buffer *rxb)\n\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_missed_beacon_notif *missed_beacon = (void *)pkt->data;\n\n\tif (le32_to_cpu(missed_beacon->consecutive_missed_beacons) >\n\t    priv->missed_beacon_threshold) {\n\t\tIWL_DEBUG_CALIB(priv,\n\t\t    \"missed bcn cnsq %d totl %d rcd %d expctd %d\\n\",\n\t\t    le32_to_cpu(missed_beacon->consecutive_missed_beacons),\n\t\t    le32_to_cpu(missed_beacon->total_missed_becons),\n\t\t    le32_to_cpu(missed_beacon->num_recvd_beacons),\n\t\t    le32_to_cpu(missed_beacon->num_expected_beacons));\n\t\tif (!test_bit(STATUS_SCANNING, &priv->status))\n\t\t\tiwl_init_sensitivity(priv);\n\t}\n}\n\n \nstatic void iwlagn_rx_reply_rx_phy(struct iwl_priv *priv,\n\t\t\t\t   struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\n\tpriv->last_phy_res_valid = true;\n\tpriv->ampdu_ref++;\n\tmemcpy(&priv->last_phy_res, pkt->data,\n\t       sizeof(struct iwl_rx_phy_res));\n}\n\n \nstatic int iwlagn_set_decrypted_flag(struct iwl_priv *priv,\n\t\t\t\t  struct ieee80211_hdr *hdr,\n\t\t\t\t  u32 decrypt_res,\n\t\t\t\t  struct ieee80211_rx_status *stats)\n{\n\tu16 fc = le16_to_cpu(hdr->frame_control);\n\n\t \n\tif (priv->contexts[IWL_RXON_CTX_BSS].active.filter_flags &\n\t\t\t\t\t\tRXON_FILTER_DIS_DECRYPT_MSK)\n\t\treturn 0;\n\n\tif (!(fc & IEEE80211_FCTL_PROTECTED))\n\t\treturn 0;\n\n\tIWL_DEBUG_RX(priv, \"decrypt_res:0x%x\\n\", decrypt_res);\n\tswitch (decrypt_res & RX_RES_STATUS_SEC_TYPE_MSK) {\n\tcase RX_RES_STATUS_SEC_TYPE_TKIP:\n\t\t \n\t\tif ((decrypt_res & RX_RES_STATUS_DECRYPT_TYPE_MSK) ==\n\t\t    RX_RES_STATUS_BAD_KEY_TTAK)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase RX_RES_STATUS_SEC_TYPE_WEP:\n\t\tif ((decrypt_res & RX_RES_STATUS_DECRYPT_TYPE_MSK) ==\n\t\t    RX_RES_STATUS_BAD_ICV_MIC) {\n\t\t\t \n\t\t\tIWL_DEBUG_RX(priv, \"Packet destroyed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tfallthrough;\n\tcase RX_RES_STATUS_SEC_TYPE_CCMP:\n\t\tif ((decrypt_res & RX_RES_STATUS_DECRYPT_TYPE_MSK) ==\n\t\t    RX_RES_STATUS_DECRYPT_OK) {\n\t\t\tIWL_DEBUG_RX(priv, \"hw decrypt successfully!!!\\n\");\n\t\t\tstats->flag |= RX_FLAG_DECRYPTED;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void iwlagn_pass_packet_to_mac80211(struct iwl_priv *priv,\n\t\t\t\t\tstruct ieee80211_hdr *hdr,\n\t\t\t\t\tu16 len,\n\t\t\t\t\tu32 ampdu_status,\n\t\t\t\t\tstruct iwl_rx_cmd_buffer *rxb,\n\t\t\t\t\tstruct ieee80211_rx_status *stats)\n{\n\tstruct sk_buff *skb;\n\t__le16 fc = hdr->frame_control;\n\tstruct iwl_rxon_context *ctx;\n\tunsigned int hdrlen, fraglen;\n\n\t \n\tif (unlikely(!priv->is_open)) {\n\t\tIWL_DEBUG_DROP_LIMIT(priv,\n\t\t    \"Dropping packet while interface is not open.\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (!iwlwifi_mod_params.swcrypto &&\n\t    iwlagn_set_decrypted_flag(priv, hdr, ampdu_status, stats))\n\t\treturn;\n\n\t \n\tskb = alloc_skb(128, GFP_ATOMIC);\n\tif (!skb) {\n\t\tIWL_ERR(priv, \"alloc_skb failed\\n\");\n\t\treturn;\n\t}\n\t \n\thdrlen = (len <= skb_tailroom(skb)) ? len : sizeof(*hdr);\n\n\tskb_put_data(skb, hdr, hdrlen);\n\tfraglen = len - hdrlen;\n\n\tif (fraglen) {\n\t\tint offset = (void *)hdr + hdrlen -\n\t\t\t     rxb_addr(rxb) + rxb_offset(rxb);\n\n\t\tskb_add_rx_frag(skb, 0, rxb_steal_page(rxb), offset,\n\t\t\t\tfraglen, rxb->truesize);\n\t}\n\n\t \n\tif (unlikely(ieee80211_is_beacon(fc) && priv->passive_no_rx)) {\n\t\tfor_each_context(priv, ctx) {\n\t\t\tif (!ether_addr_equal(hdr->addr3,\n\t\t\t\t\t      ctx->active.bssid_addr))\n\t\t\t\tcontinue;\n\t\t\tiwlagn_lift_passive_no_rx(priv);\n\t\t}\n\t}\n\n\tmemcpy(IEEE80211_SKB_RXCB(skb), stats, sizeof(*stats));\n\n\tieee80211_rx_napi(priv->hw, NULL, skb, priv->napi);\n}\n\nstatic u32 iwlagn_translate_rx_status(struct iwl_priv *priv, u32 decrypt_in)\n{\n\tu32 decrypt_out = 0;\n\n\tif ((decrypt_in & RX_RES_STATUS_STATION_FOUND) ==\n\t\t\t\t\tRX_RES_STATUS_STATION_FOUND)\n\t\tdecrypt_out |= (RX_RES_STATUS_STATION_FOUND |\n\t\t\t\tRX_RES_STATUS_NO_STATION_INFO_MISMATCH);\n\n\tdecrypt_out |= (decrypt_in & RX_RES_STATUS_SEC_TYPE_MSK);\n\n\t \n\tif ((decrypt_in & RX_RES_STATUS_SEC_TYPE_MSK) ==\n\t\t\t\t\tRX_RES_STATUS_SEC_TYPE_NONE)\n\t\treturn decrypt_out;\n\n\t \n\tif ((decrypt_in & RX_RES_STATUS_SEC_TYPE_MSK) ==\n\t\t\t\t\tRX_RES_STATUS_SEC_TYPE_ERR)\n\t\treturn decrypt_out;\n\n\t \n\tif ((decrypt_in & RX_MPDU_RES_STATUS_DEC_DONE_MSK) !=\n\t\t\t\t\tRX_MPDU_RES_STATUS_DEC_DONE_MSK)\n\t\treturn decrypt_out;\n\n\tswitch (decrypt_in & RX_RES_STATUS_SEC_TYPE_MSK) {\n\n\tcase RX_RES_STATUS_SEC_TYPE_CCMP:\n\t\t \n\t\tif (!(decrypt_in & RX_MPDU_RES_STATUS_MIC_OK))\n\t\t\t \n\t\t\tdecrypt_out |= RX_RES_STATUS_BAD_ICV_MIC;\n\t\telse\n\t\t\tdecrypt_out |= RX_RES_STATUS_DECRYPT_OK;\n\n\t\tbreak;\n\n\tcase RX_RES_STATUS_SEC_TYPE_TKIP:\n\t\tif (!(decrypt_in & RX_MPDU_RES_STATUS_TTAK_OK)) {\n\t\t\t \n\t\t\tdecrypt_out |= RX_RES_STATUS_BAD_KEY_TTAK;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tif (!(decrypt_in & RX_MPDU_RES_STATUS_ICV_OK))\n\t\t\tdecrypt_out |= RX_RES_STATUS_BAD_ICV_MIC;\n\t\telse\n\t\t\tdecrypt_out |= RX_RES_STATUS_DECRYPT_OK;\n\t\tbreak;\n\t}\n\n\tIWL_DEBUG_RX(priv, \"decrypt_in:0x%x  decrypt_out = 0x%x\\n\",\n\t\t\t\t\tdecrypt_in, decrypt_out);\n\n\treturn decrypt_out;\n}\n\n \nstatic int iwlagn_calc_rssi(struct iwl_priv *priv,\n\t\t\t     struct iwl_rx_phy_res *rx_resp)\n{\n\t \n\tstruct iwlagn_non_cfg_phy *ncphy =\n\t\t(struct iwlagn_non_cfg_phy *)rx_resp->non_cfg_phy_buf;\n\tu32 val, rssi_a, rssi_b, rssi_c, max_rssi;\n\tu8 agc;\n\n\tval  = le32_to_cpu(ncphy->non_cfg_phy[IWLAGN_RX_RES_AGC_IDX]);\n\tagc = (val & IWLAGN_OFDM_AGC_MSK) >> IWLAGN_OFDM_AGC_BIT_POS;\n\n\t \n\tval = le32_to_cpu(ncphy->non_cfg_phy[IWLAGN_RX_RES_RSSI_AB_IDX]);\n\trssi_a = (val & IWLAGN_OFDM_RSSI_INBAND_A_BITMSK) >>\n\t\tIWLAGN_OFDM_RSSI_A_BIT_POS;\n\trssi_b = (val & IWLAGN_OFDM_RSSI_INBAND_B_BITMSK) >>\n\t\tIWLAGN_OFDM_RSSI_B_BIT_POS;\n\tval = le32_to_cpu(ncphy->non_cfg_phy[IWLAGN_RX_RES_RSSI_C_IDX]);\n\trssi_c = (val & IWLAGN_OFDM_RSSI_INBAND_C_BITMSK) >>\n\t\tIWLAGN_OFDM_RSSI_C_BIT_POS;\n\n\tmax_rssi = max_t(u32, rssi_a, rssi_b);\n\tmax_rssi = max_t(u32, max_rssi, rssi_c);\n\n\tIWL_DEBUG_STATS(priv, \"Rssi In A %d B %d C %d Max %d AGC dB %d\\n\",\n\t\trssi_a, rssi_b, rssi_c, max_rssi, agc);\n\n\t \n\treturn max_rssi - agc - IWLAGN_RSSI_OFFSET;\n}\n\n \nstatic void iwlagn_rx_reply_rx(struct iwl_priv *priv,\n\t\t\t       struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct ieee80211_hdr *header;\n\tstruct ieee80211_rx_status rx_status = {};\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_rx_phy_res *phy_res;\n\t__le32 rx_pkt_status;\n\tstruct iwl_rx_mpdu_res_start *amsdu;\n\tu32 len, pkt_len = iwl_rx_packet_len(pkt);\n\tu32 ampdu_status;\n\tu32 rate_n_flags;\n\n\tif (!priv->last_phy_res_valid) {\n\t\tIWL_ERR(priv, \"MPDU frame without cached PHY data\\n\");\n\t\treturn;\n\t}\n\n\tif (unlikely(pkt_len < sizeof(*amsdu))) {\n\t\tIWL_DEBUG_DROP(priv, \"Bad REPLY_RX_MPDU_CMD size\\n\");\n\t\treturn;\n\t}\n\n\tphy_res = &priv->last_phy_res;\n\tamsdu = (struct iwl_rx_mpdu_res_start *)pkt->data;\n\theader = (struct ieee80211_hdr *)(pkt->data + sizeof(*amsdu));\n\tlen = le16_to_cpu(amsdu->byte_count);\n\n\tif (unlikely(len + sizeof(*amsdu) + sizeof(__le32) > pkt_len)) {\n\t\tIWL_DEBUG_DROP(priv, \"FW lied about packet len\\n\");\n\t\treturn;\n\t}\n\n\trx_pkt_status = *(__le32 *)(pkt->data + sizeof(*amsdu) + len);\n\tampdu_status = iwlagn_translate_rx_status(priv,\n\t\t\t\t\t\t  le32_to_cpu(rx_pkt_status));\n\n\tif ((unlikely(phy_res->cfg_phy_cnt > 20))) {\n\t\tIWL_DEBUG_DROP(priv, \"dsp size out of range [0,20]: %d\\n\",\n\t\t\t\tphy_res->cfg_phy_cnt);\n\t\treturn;\n\t}\n\n\tif (!(rx_pkt_status & RX_RES_STATUS_NO_CRC32_ERROR) ||\n\t    !(rx_pkt_status & RX_RES_STATUS_NO_RXE_OVERFLOW)) {\n\t\tIWL_DEBUG_RX(priv, \"Bad CRC or FIFO: 0x%08X.\\n\",\n\t\t\t\tle32_to_cpu(rx_pkt_status));\n\t\treturn;\n\t}\n\n\t \n\trate_n_flags = le32_to_cpu(phy_res->rate_n_flags);\n\n\t \n\trx_status.mactime = le64_to_cpu(phy_res->timestamp);\n\trx_status.band = (phy_res->phy_flags & RX_RES_PHY_FLAGS_BAND_24_MSK) ?\n\t\t\t\tNL80211_BAND_2GHZ : NL80211_BAND_5GHZ;\n\trx_status.freq =\n\t\tieee80211_channel_to_frequency(le16_to_cpu(phy_res->channel),\n\t\t\t\t\t       rx_status.band);\n\trx_status.rate_idx =\n\t\tiwlagn_hwrate_to_mac80211_idx(rate_n_flags, rx_status.band);\n\trx_status.flag = 0;\n\n\t \n\t \n\n\tpriv->ucode_beacon_time = le32_to_cpu(phy_res->beacon_time_stamp);\n\n\t \n\trx_status.signal = iwlagn_calc_rssi(priv, phy_res);\n\n\tIWL_DEBUG_STATS_LIMIT(priv, \"Rssi %d, TSF %llu\\n\",\n\t\trx_status.signal, (unsigned long long)rx_status.mactime);\n\n\t \n\trx_status.antenna =\n\t\t(le16_to_cpu(phy_res->phy_flags) & RX_RES_PHY_FLAGS_ANTENNA_MSK)\n\t\t>> RX_RES_PHY_FLAGS_ANTENNA_POS;\n\n\t \n\tif (phy_res->phy_flags & RX_RES_PHY_FLAGS_SHORT_PREAMBLE_MSK)\n\t\trx_status.enc_flags |= RX_ENC_FLAG_SHORTPRE;\n\n\tif (phy_res->phy_flags & RX_RES_PHY_FLAGS_AGG_MSK) {\n\t\t \n\t\trx_status.flag |= RX_FLAG_AMPDU_DETAILS;\n\t\trx_status.ampdu_reference = priv->ampdu_ref;\n\t}\n\n\t \n\tif (rate_n_flags & RATE_MCS_HT_MSK)\n\t\trx_status.encoding = RX_ENC_HT;\n\tif (rate_n_flags & RATE_MCS_HT40_MSK)\n\t\trx_status.bw = RATE_INFO_BW_40;\n\telse\n\t\trx_status.bw = RATE_INFO_BW_20;\n\tif (rate_n_flags & RATE_MCS_SGI_MSK)\n\t\trx_status.enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\tif (rate_n_flags & RATE_MCS_GF_MSK)\n\t\trx_status.enc_flags |= RX_ENC_FLAG_HT_GF;\n\n\tiwlagn_pass_packet_to_mac80211(priv, header, len, ampdu_status,\n\t\t\t\t    rxb, &rx_status);\n}\n\nstatic void iwlagn_rx_noa_notification(struct iwl_priv *priv,\n\t\t\t\t       struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_wipan_noa_data *new_data, *old_data;\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_wipan_noa_notification *noa_notif = (void *)pkt->data;\n\n\t \n\told_data = rcu_dereference_protected(priv->noa_data, true);\n\n\tif (noa_notif->noa_active) {\n\t\tu32 len = le16_to_cpu(noa_notif->noa_attribute.length);\n\t\tu32 copylen = len;\n\n\t\t \n\t\tlen += 1 + 1 + 3 + 1;\n\t\t \n\t\tlen += 1 + 2;\n\t\tcopylen += 1 + 2;\n\n\t\tnew_data = kmalloc(struct_size(new_data, data, len), GFP_ATOMIC);\n\t\tif (new_data) {\n\t\t\tnew_data->length = len;\n\t\t\tnew_data->data[0] = WLAN_EID_VENDOR_SPECIFIC;\n\t\t\tnew_data->data[1] = len - 2;  \n\t\t\tnew_data->data[2] = (WLAN_OUI_WFA >> 16) & 0xff;\n\t\t\tnew_data->data[3] = (WLAN_OUI_WFA >> 8) & 0xff;\n\t\t\tnew_data->data[4] = (WLAN_OUI_WFA >> 0) & 0xff;\n\t\t\tnew_data->data[5] = WLAN_OUI_TYPE_WFA_P2P;\n\t\t\tmemcpy(&new_data->data[6], &noa_notif->noa_attribute,\n\t\t\t       copylen);\n\t\t}\n\t} else\n\t\tnew_data = NULL;\n\n\trcu_assign_pointer(priv->noa_data, new_data);\n\n\tif (old_data)\n\t\tkfree_rcu(old_data, rcu_head);\n}\n\n \nvoid iwl_setup_rx_handlers(struct iwl_priv *priv)\n{\n\tvoid (**handlers)(struct iwl_priv *priv, struct iwl_rx_cmd_buffer *rxb);\n\n\thandlers = priv->rx_handlers;\n\n\thandlers[REPLY_ERROR]\t\t\t= iwlagn_rx_reply_error;\n\thandlers[CHANNEL_SWITCH_NOTIFICATION]\t= iwlagn_rx_csa;\n\thandlers[SPECTRUM_MEASURE_NOTIFICATION]\t=\n\t\tiwlagn_rx_spectrum_measure_notif;\n\thandlers[PM_SLEEP_NOTIFICATION]\t\t= iwlagn_rx_pm_sleep_notif;\n\thandlers[PM_DEBUG_STATISTIC_NOTIFIC]\t=\n\t\tiwlagn_rx_pm_debug_statistics_notif;\n\thandlers[BEACON_NOTIFICATION]\t\t= iwlagn_rx_beacon_notif;\n\thandlers[REPLY_ADD_STA]\t\t\t= iwl_add_sta_callback;\n\n\thandlers[REPLY_WIPAN_NOA_NOTIFICATION]\t= iwlagn_rx_noa_notification;\n\n\t \n\thandlers[REPLY_STATISTICS_CMD]\t\t= iwlagn_rx_reply_statistics;\n\thandlers[STATISTICS_NOTIFICATION]\t= iwlagn_rx_statistics;\n\n\tiwl_setup_rx_scan_handlers(priv);\n\n\thandlers[CARD_STATE_NOTIFICATION]\t= iwlagn_rx_card_state_notif;\n\thandlers[MISSED_BEACONS_NOTIFICATION]\t=\n\t\tiwlagn_rx_missed_beacon_notif;\n\n\t \n\thandlers[REPLY_RX_PHY_CMD]\t\t= iwlagn_rx_reply_rx_phy;\n\thandlers[REPLY_RX_MPDU_CMD]\t\t= iwlagn_rx_reply_rx;\n\n\t \n\thandlers[REPLY_COMPRESSED_BA]\t\t=\n\t\tiwlagn_rx_reply_compressed_ba;\n\n\tpriv->rx_handlers[REPLY_TX] = iwlagn_rx_reply_tx;\n\n\t \n\tiwl_notification_wait_init(&priv->notif_wait);\n\n\t \n\tif (priv->lib->bt_params)\n\t\tiwlagn_bt_rx_handler_setup(priv);\n}\n\nvoid iwl_rx_dispatch(struct iwl_op_mode *op_mode, struct napi_struct *napi,\n\t\t     struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_priv *priv = IWL_OP_MODE_GET_DVM(op_mode);\n\n\t \n\tiwl_notification_wait_notify(&priv->notif_wait, pkt);\n\n\t \n\tif (priv->rx_handlers[pkt->hdr.cmd]) {\n\t\tpriv->rx_handlers_stats[pkt->hdr.cmd]++;\n\t\tpriv->rx_handlers[pkt->hdr.cmd](priv, rxb);\n\t} else {\n\t\t \n\t\tIWL_DEBUG_RX(priv, \"No handler needed for %s, 0x%02x\\n\",\n\t\t\t     iwl_get_cmd_string(priv->trans,\n\t\t\t\t\t\tWIDE_ID(0, pkt->hdr.cmd)),\n\t\t\t     pkt->hdr.cmd);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}