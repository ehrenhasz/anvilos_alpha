{
  "module_name": "main.c",
  "hash_id": "cef5ca2668a40d53455136ca1e1539db37de09112284fa0b0756d080cfcf077a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/dvm/main.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/if_arp.h>\n\n#include <net/mac80211.h>\n\n#include <asm/div64.h>\n\n#include \"iwl-eeprom-read.h\"\n#include \"iwl-eeprom-parse.h\"\n#include \"iwl-io.h\"\n#include \"iwl-trans.h\"\n#include \"iwl-op-mode.h\"\n#include \"iwl-drv.h\"\n#include \"iwl-modparams.h\"\n#include \"iwl-prph.h\"\n\n#include \"dev.h\"\n#include \"calib.h\"\n#include \"agn.h\"\n\n\n \n\n#define DRV_DESCRIPTION\t\"Intel(R) Wireless WiFi Link AGN driver for Linux\"\nMODULE_DESCRIPTION(DRV_DESCRIPTION);\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(IWLWIFI);\n\n \nstatic const struct iwl_hcmd_names iwl_dvm_cmd_names[] = {\n\tHCMD_NAME(REPLY_ALIVE),\n\tHCMD_NAME(REPLY_ERROR),\n\tHCMD_NAME(REPLY_ECHO),\n\tHCMD_NAME(REPLY_RXON),\n\tHCMD_NAME(REPLY_RXON_ASSOC),\n\tHCMD_NAME(REPLY_QOS_PARAM),\n\tHCMD_NAME(REPLY_RXON_TIMING),\n\tHCMD_NAME(REPLY_ADD_STA),\n\tHCMD_NAME(REPLY_REMOVE_STA),\n\tHCMD_NAME(REPLY_REMOVE_ALL_STA),\n\tHCMD_NAME(REPLY_TX),\n\tHCMD_NAME(REPLY_TXFIFO_FLUSH),\n\tHCMD_NAME(REPLY_WEPKEY),\n\tHCMD_NAME(REPLY_LEDS_CMD),\n\tHCMD_NAME(REPLY_TX_LINK_QUALITY_CMD),\n\tHCMD_NAME(COEX_PRIORITY_TABLE_CMD),\n\tHCMD_NAME(COEX_MEDIUM_NOTIFICATION),\n\tHCMD_NAME(COEX_EVENT_CMD),\n\tHCMD_NAME(TEMPERATURE_NOTIFICATION),\n\tHCMD_NAME(CALIBRATION_CFG_CMD),\n\tHCMD_NAME(CALIBRATION_RES_NOTIFICATION),\n\tHCMD_NAME(CALIBRATION_COMPLETE_NOTIFICATION),\n\tHCMD_NAME(REPLY_QUIET_CMD),\n\tHCMD_NAME(REPLY_CHANNEL_SWITCH),\n\tHCMD_NAME(CHANNEL_SWITCH_NOTIFICATION),\n\tHCMD_NAME(REPLY_SPECTRUM_MEASUREMENT_CMD),\n\tHCMD_NAME(SPECTRUM_MEASURE_NOTIFICATION),\n\tHCMD_NAME(POWER_TABLE_CMD),\n\tHCMD_NAME(PM_SLEEP_NOTIFICATION),\n\tHCMD_NAME(PM_DEBUG_STATISTIC_NOTIFIC),\n\tHCMD_NAME(REPLY_SCAN_CMD),\n\tHCMD_NAME(REPLY_SCAN_ABORT_CMD),\n\tHCMD_NAME(SCAN_START_NOTIFICATION),\n\tHCMD_NAME(SCAN_RESULTS_NOTIFICATION),\n\tHCMD_NAME(SCAN_COMPLETE_NOTIFICATION),\n\tHCMD_NAME(BEACON_NOTIFICATION),\n\tHCMD_NAME(REPLY_TX_BEACON),\n\tHCMD_NAME(WHO_IS_AWAKE_NOTIFICATION),\n\tHCMD_NAME(REPLY_TX_POWER_DBM_CMD),\n\tHCMD_NAME(QUIET_NOTIFICATION),\n\tHCMD_NAME(REPLY_TX_PWR_TABLE_CMD),\n\tHCMD_NAME(REPLY_TX_POWER_DBM_CMD_V1),\n\tHCMD_NAME(TX_ANT_CONFIGURATION_CMD),\n\tHCMD_NAME(MEASURE_ABORT_NOTIFICATION),\n\tHCMD_NAME(REPLY_BT_CONFIG),\n\tHCMD_NAME(REPLY_STATISTICS_CMD),\n\tHCMD_NAME(STATISTICS_NOTIFICATION),\n\tHCMD_NAME(REPLY_CARD_STATE_CMD),\n\tHCMD_NAME(CARD_STATE_NOTIFICATION),\n\tHCMD_NAME(MISSED_BEACONS_NOTIFICATION),\n\tHCMD_NAME(REPLY_CT_KILL_CONFIG_CMD),\n\tHCMD_NAME(SENSITIVITY_CMD),\n\tHCMD_NAME(REPLY_PHY_CALIBRATION_CMD),\n\tHCMD_NAME(REPLY_WIPAN_PARAMS),\n\tHCMD_NAME(REPLY_WIPAN_RXON),\n\tHCMD_NAME(REPLY_WIPAN_RXON_TIMING),\n\tHCMD_NAME(REPLY_WIPAN_RXON_ASSOC),\n\tHCMD_NAME(REPLY_WIPAN_QOS_PARAM),\n\tHCMD_NAME(REPLY_WIPAN_WEPKEY),\n\tHCMD_NAME(REPLY_WIPAN_P2P_CHANNEL_SWITCH),\n\tHCMD_NAME(REPLY_WIPAN_NOA_NOTIFICATION),\n\tHCMD_NAME(REPLY_WIPAN_DEACTIVATION_COMPLETE),\n\tHCMD_NAME(REPLY_RX_PHY_CMD),\n\tHCMD_NAME(REPLY_RX_MPDU_CMD),\n\tHCMD_NAME(REPLY_RX),\n\tHCMD_NAME(REPLY_COMPRESSED_BA),\n\tHCMD_NAME(REPLY_BT_COEX_PRIO_TABLE),\n\tHCMD_NAME(REPLY_BT_COEX_PROT_ENV),\n\tHCMD_NAME(REPLY_BT_COEX_PROFILE_NOTIF),\n\tHCMD_NAME(REPLY_D3_CONFIG),\n\tHCMD_NAME(REPLY_WOWLAN_PATTERNS),\n\tHCMD_NAME(REPLY_WOWLAN_WAKEUP_FILTER),\n\tHCMD_NAME(REPLY_WOWLAN_TSC_RSC_PARAMS),\n\tHCMD_NAME(REPLY_WOWLAN_TKIP_PARAMS),\n\tHCMD_NAME(REPLY_WOWLAN_KEK_KCK_MATERIAL),\n\tHCMD_NAME(REPLY_WOWLAN_GET_STATUS),\n};\n\nstatic const struct iwl_hcmd_arr iwl_dvm_groups[] = {\n\t[0x0] = HCMD_ARR(iwl_dvm_cmd_names),\n};\n\nstatic const struct iwl_op_mode_ops iwl_dvm_ops;\n\nvoid iwl_update_chain_flags(struct iwl_priv *priv)\n{\n\tstruct iwl_rxon_context *ctx;\n\n\tfor_each_context(priv, ctx) {\n\t\tiwlagn_set_rxon_chain(priv, ctx);\n\t\tif (ctx->active.rx_chain != ctx->staging.rx_chain)\n\t\t\tiwlagn_commit_rxon(priv, ctx);\n\t}\n}\n\n \nstatic void iwl_set_beacon_tim(struct iwl_priv *priv,\n\t\t\t       struct iwl_tx_beacon_cmd *tx_beacon_cmd,\n\t\t\t       u8 *beacon, u32 frame_size)\n{\n\tu16 tim_idx;\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)beacon;\n\n\t \n\ttim_idx = mgmt->u.beacon.variable - beacon;\n\n\t \n\twhile ((tim_idx < (frame_size - 2)) &&\n\t\t\t(beacon[tim_idx] != WLAN_EID_TIM))\n\t\ttim_idx += beacon[tim_idx+1] + 2;\n\n\t \n\tif ((tim_idx < (frame_size - 1)) && (beacon[tim_idx] == WLAN_EID_TIM)) {\n\t\ttx_beacon_cmd->tim_idx = cpu_to_le16(tim_idx);\n\t\ttx_beacon_cmd->tim_size = beacon[tim_idx+1];\n\t} else\n\t\tIWL_WARN(priv, \"Unable to find TIM Element in beacon\\n\");\n}\n\nint iwlagn_send_beacon_cmd(struct iwl_priv *priv)\n{\n\tstruct iwl_tx_beacon_cmd *tx_beacon_cmd;\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = REPLY_TX_BEACON,\n\t};\n\tstruct ieee80211_tx_info *info;\n\tu32 frame_size;\n\tu32 rate_flags;\n\tu32 rate;\n\n\t \n\n\tlockdep_assert_held(&priv->mutex);\n\n\tif (!priv->beacon_ctx) {\n\t\tIWL_ERR(priv, \"trying to build beacon w/o beacon context!\\n\");\n\t\treturn 0;\n\t}\n\n\tif (WARN_ON(!priv->beacon_skb))\n\t\treturn -EINVAL;\n\n\t \n\tif (!priv->beacon_cmd)\n\t\tpriv->beacon_cmd = kzalloc(sizeof(*tx_beacon_cmd), GFP_KERNEL);\n\ttx_beacon_cmd = priv->beacon_cmd;\n\tif (!tx_beacon_cmd)\n\t\treturn -ENOMEM;\n\n\tframe_size = priv->beacon_skb->len;\n\n\t \n\ttx_beacon_cmd->tx.len = cpu_to_le16((u16)frame_size);\n\ttx_beacon_cmd->tx.sta_id = priv->beacon_ctx->bcast_sta_id;\n\ttx_beacon_cmd->tx.stop_time.life_time = TX_CMD_LIFE_TIME_INFINITE;\n\ttx_beacon_cmd->tx.tx_flags = TX_CMD_FLG_SEQ_CTL_MSK |\n\t\tTX_CMD_FLG_TSF_MSK | TX_CMD_FLG_STA_RATE_MSK;\n\n\t \n\tiwl_set_beacon_tim(priv, tx_beacon_cmd, priv->beacon_skb->data,\n\t\t\t   frame_size);\n\n\t \n\tinfo = IEEE80211_SKB_CB(priv->beacon_skb);\n\n\t \n\tif (info->control.rates[0].idx < 0 ||\n\t    info->control.rates[0].flags & IEEE80211_TX_RC_MCS)\n\t\trate = 0;\n\telse\n\t\trate = info->control.rates[0].idx;\n\n\tpriv->mgmt_tx_ant = iwl_toggle_tx_ant(priv, priv->mgmt_tx_ant,\n\t\t\t\t\t      priv->nvm_data->valid_tx_ant);\n\trate_flags = iwl_ant_idx_to_flags(priv->mgmt_tx_ant);\n\n\t \n\tif (info->band == NL80211_BAND_5GHZ)\n\t\trate += IWL_FIRST_OFDM_RATE;\n\telse if (rate >= IWL_FIRST_CCK_RATE && rate <= IWL_LAST_CCK_RATE)\n\t\trate_flags |= RATE_MCS_CCK_MSK;\n\n\ttx_beacon_cmd->tx.rate_n_flags =\n\t\t\tiwl_hw_set_rate_n_flags(rate, rate_flags);\n\n\t \n\tcmd.len[0] = sizeof(*tx_beacon_cmd);\n\tcmd.data[0] = tx_beacon_cmd;\n\tcmd.dataflags[0] = IWL_HCMD_DFL_NOCOPY;\n\tcmd.len[1] = frame_size;\n\tcmd.data[1] = priv->beacon_skb->data;\n\tcmd.dataflags[1] = IWL_HCMD_DFL_NOCOPY;\n\n\treturn iwl_dvm_send_cmd(priv, &cmd);\n}\n\nstatic void iwl_bg_beacon_update(struct work_struct *work)\n{\n\tstruct iwl_priv *priv =\n\t\tcontainer_of(work, struct iwl_priv, beacon_update);\n\tstruct sk_buff *beacon;\n\n\tmutex_lock(&priv->mutex);\n\tif (!priv->beacon_ctx) {\n\t\tIWL_ERR(priv, \"updating beacon w/o beacon context!\\n\");\n\t\tgoto out;\n\t}\n\n\tif (priv->beacon_ctx->vif->type != NL80211_IFTYPE_AP) {\n\t\t \n\t\tgoto out;\n\t}\n\n\t \n\tbeacon = ieee80211_beacon_get(priv->hw, priv->beacon_ctx->vif, 0);\n\tif (!beacon) {\n\t\tIWL_ERR(priv, \"update beacon failed -- keeping old\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tdev_kfree_skb(priv->beacon_skb);\n\n\tpriv->beacon_skb = beacon;\n\n\tiwlagn_send_beacon_cmd(priv);\n out:\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void iwl_bg_bt_runtime_config(struct work_struct *work)\n{\n\tstruct iwl_priv *priv =\n\t\tcontainer_of(work, struct iwl_priv, bt_runtime_config);\n\n\tmutex_lock(&priv->mutex);\n\tif (test_bit(STATUS_EXIT_PENDING, &priv->status))\n\t\tgoto out;\n\n\t \n\tif (!iwl_is_ready_rf(priv))\n\t\tgoto out;\n\n\tiwlagn_send_advance_bt_config(priv);\nout:\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void iwl_bg_bt_full_concurrency(struct work_struct *work)\n{\n\tstruct iwl_priv *priv =\n\t\tcontainer_of(work, struct iwl_priv, bt_full_concurrency);\n\tstruct iwl_rxon_context *ctx;\n\n\tmutex_lock(&priv->mutex);\n\n\tif (test_bit(STATUS_EXIT_PENDING, &priv->status))\n\t\tgoto out;\n\n\t \n\tif (!iwl_is_ready_rf(priv))\n\t\tgoto out;\n\n\tIWL_DEBUG_INFO(priv, \"BT coex in %s mode\\n\",\n\t\t       priv->bt_full_concurrent ?\n\t\t       \"full concurrency\" : \"3-wire\");\n\n\t \n\tfor_each_context(priv, ctx) {\n\t\tiwlagn_set_rxon_chain(priv, ctx);\n\t\tiwlagn_commit_rxon(priv, ctx);\n\t}\n\n\tiwlagn_send_advance_bt_config(priv);\nout:\n\tmutex_unlock(&priv->mutex);\n}\n\nint iwl_send_statistics_request(struct iwl_priv *priv, u8 flags, bool clear)\n{\n\tstruct iwl_statistics_cmd statistics_cmd = {\n\t\t.configuration_flags =\n\t\t\tclear ? IWL_STATS_CONF_CLEAR_STATS : 0,\n\t};\n\n\tif (flags & CMD_ASYNC)\n\t\treturn iwl_dvm_send_cmd_pdu(priv, REPLY_STATISTICS_CMD,\n\t\t\t\t\tCMD_ASYNC,\n\t\t\t\t\tsizeof(struct iwl_statistics_cmd),\n\t\t\t\t\t&statistics_cmd);\n\telse\n\t\treturn iwl_dvm_send_cmd_pdu(priv, REPLY_STATISTICS_CMD, 0,\n\t\t\t\t\tsizeof(struct iwl_statistics_cmd),\n\t\t\t\t\t&statistics_cmd);\n}\n\n \nstatic void iwl_bg_statistics_periodic(struct timer_list *t)\n{\n\tstruct iwl_priv *priv = from_timer(priv, t, statistics_periodic);\n\n\tif (test_bit(STATUS_EXIT_PENDING, &priv->status))\n\t\treturn;\n\n\t \n\tif (!iwl_is_ready_rf(priv))\n\t\treturn;\n\n\tiwl_send_statistics_request(priv, CMD_ASYNC, false);\n}\n\n\nstatic void iwl_print_cont_event_trace(struct iwl_priv *priv, u32 base,\n\t\t\t\t\tu32 start_idx, u32 num_events,\n\t\t\t\t\tu32 capacity, u32 mode)\n{\n\tu32 i;\n\tu32 ptr;         \n\tu32 ev, time, data;  \n\n\tif (mode == 0)\n\t\tptr = base + (4 * sizeof(u32)) + (start_idx * 2 * sizeof(u32));\n\telse\n\t\tptr = base + (4 * sizeof(u32)) + (start_idx * 3 * sizeof(u32));\n\n\t \n\tif (!iwl_trans_grab_nic_access(priv->trans))\n\t\treturn;\n\n\t \n\tiwl_write32(priv->trans, HBUS_TARG_MEM_RADDR, ptr);\n\n\t \n\tif (WARN_ON(num_events > capacity - start_idx))\n\t\tnum_events = capacity - start_idx;\n\n\t \n\tfor (i = 0; i < num_events; i++) {\n\t\tev = iwl_read32(priv->trans, HBUS_TARG_MEM_RDAT);\n\t\ttime = iwl_read32(priv->trans, HBUS_TARG_MEM_RDAT);\n\t\tif (mode == 0) {\n\t\t\ttrace_iwlwifi_dev_ucode_cont_event(\n\t\t\t\t\tpriv->trans->dev, 0, time, ev);\n\t\t} else {\n\t\t\tdata = iwl_read32(priv->trans, HBUS_TARG_MEM_RDAT);\n\t\t\ttrace_iwlwifi_dev_ucode_cont_event(\n\t\t\t\t\tpriv->trans->dev, time, data, ev);\n\t\t}\n\t}\n\t \n\tiwl_trans_release_nic_access(priv->trans);\n}\n\nstatic void iwl_continuous_event_trace(struct iwl_priv *priv)\n{\n\tu32 capacity;    \n\tstruct {\n\t\tu32 capacity;\n\t\tu32 mode;\n\t\tu32 wrap_counter;\n\t\tu32 write_counter;\n\t} __packed read;\n\tu32 base;        \n\tu32 mode;        \n\tu32 num_wraps;   \n\tu32 next_entry;  \n\n\tbase = priv->device_pointers.log_event_table;\n\tif (iwlagn_hw_valid_rtc_data_addr(base)) {\n\t\tiwl_trans_read_mem_bytes(priv->trans, base,\n\t\t\t\t\t &read, sizeof(read));\n\t\tcapacity = read.capacity;\n\t\tmode = read.mode;\n\t\tnum_wraps = read.wrap_counter;\n\t\tnext_entry = read.write_counter;\n\t} else\n\t\treturn;\n\n\t \n\tif (unlikely(next_entry == capacity))\n\t\tnext_entry = 0;\n\t \n\tif (unlikely(next_entry < priv->event_log.next_entry &&\n\t\t     num_wraps == priv->event_log.num_wraps))\n\t\tnum_wraps++;\n\n\tif (num_wraps == priv->event_log.num_wraps) {\n\t\tiwl_print_cont_event_trace(\n\t\t\tpriv, base, priv->event_log.next_entry,\n\t\t\tnext_entry - priv->event_log.next_entry,\n\t\t\tcapacity, mode);\n\n\t\tpriv->event_log.non_wraps_count++;\n\t} else {\n\t\tif (num_wraps - priv->event_log.num_wraps > 1)\n\t\t\tpriv->event_log.wraps_more_count++;\n\t\telse\n\t\t\tpriv->event_log.wraps_once_count++;\n\n\t\ttrace_iwlwifi_dev_ucode_wrap_event(priv->trans->dev,\n\t\t\t\tnum_wraps - priv->event_log.num_wraps,\n\t\t\t\tnext_entry, priv->event_log.next_entry);\n\n\t\tif (next_entry < priv->event_log.next_entry) {\n\t\t\tiwl_print_cont_event_trace(\n\t\t\t\tpriv, base, priv->event_log.next_entry,\n\t\t\t\tcapacity - priv->event_log.next_entry,\n\t\t\t\tcapacity, mode);\n\n\t\t\tiwl_print_cont_event_trace(\n\t\t\t\tpriv, base, 0, next_entry, capacity, mode);\n\t\t} else {\n\t\t\tiwl_print_cont_event_trace(\n\t\t\t\tpriv, base, next_entry,\n\t\t\t\tcapacity - next_entry,\n\t\t\t\tcapacity, mode);\n\n\t\t\tiwl_print_cont_event_trace(\n\t\t\t\tpriv, base, 0, next_entry, capacity, mode);\n\t\t}\n\t}\n\n\tpriv->event_log.num_wraps = num_wraps;\n\tpriv->event_log.next_entry = next_entry;\n}\n\n \nstatic void iwl_bg_ucode_trace(struct timer_list *t)\n{\n\tstruct iwl_priv *priv = from_timer(priv, t, ucode_trace);\n\n\tif (test_bit(STATUS_EXIT_PENDING, &priv->status))\n\t\treturn;\n\n\tif (priv->event_log.ucode_trace) {\n\t\tiwl_continuous_event_trace(priv);\n\t\t \n\t\tmod_timer(&priv->ucode_trace,\n\t\t\t jiffies + msecs_to_jiffies(UCODE_TRACE_PERIOD));\n\t}\n}\n\nstatic void iwl_bg_tx_flush(struct work_struct *work)\n{\n\tstruct iwl_priv *priv =\n\t\tcontainer_of(work, struct iwl_priv, tx_flush);\n\n\tif (test_bit(STATUS_EXIT_PENDING, &priv->status))\n\t\treturn;\n\n\t \n\tif (!iwl_is_ready_rf(priv))\n\t\treturn;\n\n\tIWL_DEBUG_INFO(priv, \"device request: flush all tx frames\\n\");\n\tiwlagn_dev_txfifo_flush(priv);\n}\n\n \n\nstatic const u8 iwlagn_bss_ac_to_fifo[] = {\n\tIWL_TX_FIFO_VO,\n\tIWL_TX_FIFO_VI,\n\tIWL_TX_FIFO_BE,\n\tIWL_TX_FIFO_BK,\n};\n\nstatic const u8 iwlagn_bss_ac_to_queue[] = {\n\t0, 1, 2, 3,\n};\n\nstatic const u8 iwlagn_pan_ac_to_fifo[] = {\n\tIWL_TX_FIFO_VO_IPAN,\n\tIWL_TX_FIFO_VI_IPAN,\n\tIWL_TX_FIFO_BE_IPAN,\n\tIWL_TX_FIFO_BK_IPAN,\n};\n\nstatic const u8 iwlagn_pan_ac_to_queue[] = {\n\t7, 6, 5, 4,\n};\n\nstatic void iwl_init_context(struct iwl_priv *priv, u32 ucode_flags)\n{\n\tint i;\n\n\t \n\tpriv->valid_contexts = BIT(IWL_RXON_CTX_BSS);\n\tif (ucode_flags & IWL_UCODE_TLV_FLAGS_PAN)\n\t\tpriv->valid_contexts |= BIT(IWL_RXON_CTX_PAN);\n\n\tfor (i = 0; i < NUM_IWL_RXON_CTX; i++)\n\t\tpriv->contexts[i].ctxid = i;\n\n\tpriv->contexts[IWL_RXON_CTX_BSS].always_active = true;\n\tpriv->contexts[IWL_RXON_CTX_BSS].is_active = true;\n\tpriv->contexts[IWL_RXON_CTX_BSS].rxon_cmd = REPLY_RXON;\n\tpriv->contexts[IWL_RXON_CTX_BSS].rxon_timing_cmd = REPLY_RXON_TIMING;\n\tpriv->contexts[IWL_RXON_CTX_BSS].rxon_assoc_cmd = REPLY_RXON_ASSOC;\n\tpriv->contexts[IWL_RXON_CTX_BSS].qos_cmd = REPLY_QOS_PARAM;\n\tpriv->contexts[IWL_RXON_CTX_BSS].ap_sta_id = IWL_AP_ID;\n\tpriv->contexts[IWL_RXON_CTX_BSS].wep_key_cmd = REPLY_WEPKEY;\n\tpriv->contexts[IWL_RXON_CTX_BSS].bcast_sta_id = IWLAGN_BROADCAST_ID;\n\tpriv->contexts[IWL_RXON_CTX_BSS].exclusive_interface_modes =\n\t\tBIT(NL80211_IFTYPE_ADHOC) | BIT(NL80211_IFTYPE_MONITOR);\n\tpriv->contexts[IWL_RXON_CTX_BSS].interface_modes =\n\t\tBIT(NL80211_IFTYPE_STATION);\n\tpriv->contexts[IWL_RXON_CTX_BSS].ap_devtype = RXON_DEV_TYPE_AP;\n\tpriv->contexts[IWL_RXON_CTX_BSS].ibss_devtype = RXON_DEV_TYPE_IBSS;\n\tpriv->contexts[IWL_RXON_CTX_BSS].station_devtype = RXON_DEV_TYPE_ESS;\n\tpriv->contexts[IWL_RXON_CTX_BSS].unused_devtype = RXON_DEV_TYPE_ESS;\n\tmemcpy(priv->contexts[IWL_RXON_CTX_BSS].ac_to_queue,\n\t       iwlagn_bss_ac_to_queue, sizeof(iwlagn_bss_ac_to_queue));\n\tmemcpy(priv->contexts[IWL_RXON_CTX_BSS].ac_to_fifo,\n\t       iwlagn_bss_ac_to_fifo, sizeof(iwlagn_bss_ac_to_fifo));\n\n\tpriv->contexts[IWL_RXON_CTX_PAN].rxon_cmd = REPLY_WIPAN_RXON;\n\tpriv->contexts[IWL_RXON_CTX_PAN].rxon_timing_cmd =\n\t\tREPLY_WIPAN_RXON_TIMING;\n\tpriv->contexts[IWL_RXON_CTX_PAN].rxon_assoc_cmd =\n\t\tREPLY_WIPAN_RXON_ASSOC;\n\tpriv->contexts[IWL_RXON_CTX_PAN].qos_cmd = REPLY_WIPAN_QOS_PARAM;\n\tpriv->contexts[IWL_RXON_CTX_PAN].ap_sta_id = IWL_AP_ID_PAN;\n\tpriv->contexts[IWL_RXON_CTX_PAN].wep_key_cmd = REPLY_WIPAN_WEPKEY;\n\tpriv->contexts[IWL_RXON_CTX_PAN].bcast_sta_id = IWLAGN_PAN_BCAST_ID;\n\tpriv->contexts[IWL_RXON_CTX_PAN].station_flags = STA_FLG_PAN_STATION;\n\tpriv->contexts[IWL_RXON_CTX_PAN].interface_modes =\n\t\tBIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_AP);\n\n\tpriv->contexts[IWL_RXON_CTX_PAN].ap_devtype = RXON_DEV_TYPE_CP;\n\tpriv->contexts[IWL_RXON_CTX_PAN].station_devtype = RXON_DEV_TYPE_2STA;\n\tpriv->contexts[IWL_RXON_CTX_PAN].unused_devtype = RXON_DEV_TYPE_P2P;\n\tmemcpy(priv->contexts[IWL_RXON_CTX_PAN].ac_to_queue,\n\t       iwlagn_pan_ac_to_queue, sizeof(iwlagn_pan_ac_to_queue));\n\tmemcpy(priv->contexts[IWL_RXON_CTX_PAN].ac_to_fifo,\n\t       iwlagn_pan_ac_to_fifo, sizeof(iwlagn_pan_ac_to_fifo));\n\tpriv->contexts[IWL_RXON_CTX_PAN].mcast_queue = IWL_IPAN_MCAST_QUEUE;\n\n\tBUILD_BUG_ON(NUM_IWL_RXON_CTX != 2);\n}\n\nstatic void iwl_rf_kill_ct_config(struct iwl_priv *priv)\n{\n\tstruct iwl_ct_kill_config cmd;\n\tstruct iwl_ct_kill_throttling_config adv_cmd;\n\tint ret = 0;\n\n\tiwl_write32(priv->trans, CSR_UCODE_DRV_GP1_CLR,\n\t\t    CSR_UCODE_DRV_GP1_REG_BIT_CT_KILL_EXIT);\n\n\tpriv->thermal_throttle.ct_kill_toggle = false;\n\n\tif (priv->lib->support_ct_kill_exit) {\n\t\tadv_cmd.critical_temperature_enter =\n\t\t\tcpu_to_le32(priv->hw_params.ct_kill_threshold);\n\t\tadv_cmd.critical_temperature_exit =\n\t\t\tcpu_to_le32(priv->hw_params.ct_kill_exit_threshold);\n\n\t\tret = iwl_dvm_send_cmd_pdu(priv,\n\t\t\t\t       REPLY_CT_KILL_CONFIG_CMD,\n\t\t\t\t       0, sizeof(adv_cmd), &adv_cmd);\n\t\tif (ret)\n\t\t\tIWL_ERR(priv, \"REPLY_CT_KILL_CONFIG_CMD failed\\n\");\n\t\telse\n\t\t\tIWL_DEBUG_INFO(priv, \"REPLY_CT_KILL_CONFIG_CMD \"\n\t\t\t\t\"succeeded, critical temperature enter is %d,\"\n\t\t\t\t\"exit is %d\\n\",\n\t\t\t\tpriv->hw_params.ct_kill_threshold,\n\t\t\t\tpriv->hw_params.ct_kill_exit_threshold);\n\t} else {\n\t\tcmd.critical_temperature_R =\n\t\t\tcpu_to_le32(priv->hw_params.ct_kill_threshold);\n\n\t\tret = iwl_dvm_send_cmd_pdu(priv,\n\t\t\t\t       REPLY_CT_KILL_CONFIG_CMD,\n\t\t\t\t       0, sizeof(cmd), &cmd);\n\t\tif (ret)\n\t\t\tIWL_ERR(priv, \"REPLY_CT_KILL_CONFIG_CMD failed\\n\");\n\t\telse\n\t\t\tIWL_DEBUG_INFO(priv, \"REPLY_CT_KILL_CONFIG_CMD \"\n\t\t\t\t\"succeeded, \"\n\t\t\t\t\"critical temperature is %d\\n\",\n\t\t\t\tpriv->hw_params.ct_kill_threshold);\n\t}\n}\n\nstatic int iwlagn_send_calib_cfg_rt(struct iwl_priv *priv, u32 cfg)\n{\n\tstruct iwl_calib_cfg_cmd calib_cfg_cmd;\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = CALIBRATION_CFG_CMD,\n\t\t.len = { sizeof(struct iwl_calib_cfg_cmd), },\n\t\t.data = { &calib_cfg_cmd, },\n\t};\n\n\tmemset(&calib_cfg_cmd, 0, sizeof(calib_cfg_cmd));\n\tcalib_cfg_cmd.ucd_calib_cfg.once.is_enable = IWL_CALIB_RT_CFG_ALL;\n\tcalib_cfg_cmd.ucd_calib_cfg.once.start = cpu_to_le32(cfg);\n\n\treturn iwl_dvm_send_cmd(priv, &cmd);\n}\n\n\nstatic int iwlagn_send_tx_ant_config(struct iwl_priv *priv, u8 valid_tx_ant)\n{\n\tstruct iwl_tx_ant_config_cmd tx_ant_cmd = {\n\t  .valid = cpu_to_le32(valid_tx_ant),\n\t};\n\n\tif (IWL_UCODE_API(priv->fw->ucode_ver) > 1) {\n\t\tIWL_DEBUG_HC(priv, \"select valid tx ant: %u\\n\", valid_tx_ant);\n\t\treturn iwl_dvm_send_cmd_pdu(priv, TX_ANT_CONFIGURATION_CMD, 0,\n\t\t\t\t\tsizeof(struct iwl_tx_ant_config_cmd),\n\t\t\t\t\t&tx_ant_cmd);\n\t} else {\n\t\tIWL_DEBUG_HC(priv, \"TX_ANT_CONFIGURATION_CMD not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void iwl_send_bt_config(struct iwl_priv *priv)\n{\n\tstruct iwl_bt_cmd bt_cmd = {\n\t\t.lead_time = BT_LEAD_TIME_DEF,\n\t\t.max_kill = BT_MAX_KILL_DEF,\n\t\t.kill_ack_mask = 0,\n\t\t.kill_cts_mask = 0,\n\t};\n\n\tif (!iwlwifi_mod_params.bt_coex_active)\n\t\tbt_cmd.flags = BT_COEX_DISABLE;\n\telse\n\t\tbt_cmd.flags = BT_COEX_ENABLE;\n\n\tpriv->bt_enable_flag = bt_cmd.flags;\n\tIWL_DEBUG_INFO(priv, \"BT coex %s\\n\",\n\t\t(bt_cmd.flags == BT_COEX_DISABLE) ? \"disable\" : \"active\");\n\n\tif (iwl_dvm_send_cmd_pdu(priv, REPLY_BT_CONFIG,\n\t\t\t     0, sizeof(struct iwl_bt_cmd), &bt_cmd))\n\t\tIWL_ERR(priv, \"failed to send BT Coex Config\\n\");\n}\n\n \nint iwl_alive_start(struct iwl_priv *priv)\n{\n\tint ret = 0;\n\tstruct iwl_rxon_context *ctx = &priv->contexts[IWL_RXON_CTX_BSS];\n\n\tIWL_DEBUG_INFO(priv, \"Runtime Alive received.\\n\");\n\n\t \n\tset_bit(STATUS_ALIVE, &priv->status);\n\n\tif (iwl_is_rfkill(priv))\n\t\treturn -ERFKILL;\n\n\tif (priv->event_log.ucode_trace) {\n\t\t \n\t\tmod_timer(&priv->ucode_trace, jiffies);\n\t}\n\n\t \n\tif (priv->lib->bt_params &&\n\t    priv->lib->bt_params->advanced_bt_coexist) {\n\t\t \n\t\tif (priv->lib->bt_params->bt_sco_disable)\n\t\t\tpriv->bt_enable_pspoll = false;\n\t\telse\n\t\t\tpriv->bt_enable_pspoll = true;\n\n\t\tpriv->bt_valid = IWLAGN_BT_ALL_VALID_MSK;\n\t\tpriv->kill_ack_mask = IWLAGN_BT_KILL_ACK_MASK_DEFAULT;\n\t\tpriv->kill_cts_mask = IWLAGN_BT_KILL_CTS_MASK_DEFAULT;\n\t\tiwlagn_send_advance_bt_config(priv);\n\t\tpriv->bt_valid = IWLAGN_BT_VALID_ENABLE_FLAGS;\n\t\tpriv->cur_rssi_ctx = NULL;\n\n\t\tiwl_send_prio_tbl(priv);\n\n\t\t \n\t\tret = iwl_send_bt_env(priv, IWL_BT_COEX_ENV_OPEN,\n\t\t\t\t\t BT_COEX_PRIO_TBL_EVT_INIT_CALIB2);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = iwl_send_bt_env(priv, IWL_BT_COEX_ENV_CLOSE,\n\t\t\t\t\t BT_COEX_PRIO_TBL_EVT_INIT_CALIB2);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (priv->lib->bt_params) {\n\t\t \n\t\tiwl_send_bt_config(priv);\n\t}\n\n\t \n\tiwlagn_send_calib_cfg_rt(priv, IWL_CALIB_CFG_DC_IDX);\n\n\tieee80211_wake_queues(priv->hw);\n\n\t \n\tiwlagn_send_tx_ant_config(priv, priv->nvm_data->valid_tx_ant);\n\n\tif (iwl_is_associated_ctx(ctx) && !priv->wowlan) {\n\t\tstruct iwl_rxon_cmd *active_rxon =\n\t\t\t\t(struct iwl_rxon_cmd *)&ctx->active;\n\t\t \n\t\tctx->staging.filter_flags |= RXON_FILTER_ASSOC_MSK;\n\t\tactive_rxon->filter_flags &= ~RXON_FILTER_ASSOC_MSK;\n\t} else {\n\t\tstruct iwl_rxon_context *tmp;\n\t\t \n\t\tfor_each_context(priv, tmp)\n\t\t\tiwl_connection_init_rx_config(priv, tmp);\n\n\t\tiwlagn_set_rxon_chain(priv, ctx);\n\t}\n\n\tif (!priv->wowlan) {\n\t\t \n\t\tiwl_reset_run_time_calib(priv);\n\t}\n\n\tset_bit(STATUS_READY, &priv->status);\n\n\t \n\tret = iwlagn_commit_rxon(priv, ctx);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tiwl_rf_kill_ct_config(priv);\n\n\tIWL_DEBUG_INFO(priv, \"ALIVE processing complete.\\n\");\n\n\treturn iwl_power_update_mode(priv, true);\n}\n\n \nstatic void iwl_clear_driver_stations(struct iwl_priv *priv)\n{\n\tstruct iwl_rxon_context *ctx;\n\n\tspin_lock_bh(&priv->sta_lock);\n\tmemset(priv->stations, 0, sizeof(priv->stations));\n\tpriv->num_stations = 0;\n\n\tpriv->ucode_key_table = 0;\n\n\tfor_each_context(priv, ctx) {\n\t\t \n\t\tmemset(ctx->wep_keys, 0, sizeof(ctx->wep_keys));\n\t\tctx->key_mapping_keys = 0;\n\t}\n\n\tspin_unlock_bh(&priv->sta_lock);\n}\n\nvoid iwl_down(struct iwl_priv *priv)\n{\n\tint exit_pending;\n\n\tIWL_DEBUG_INFO(priv, DRV_NAME \" is going down\\n\");\n\n\tlockdep_assert_held(&priv->mutex);\n\n\tiwl_scan_cancel_timeout(priv, 200);\n\n\texit_pending =\n\t\ttest_and_set_bit(STATUS_EXIT_PENDING, &priv->status);\n\n\tiwl_clear_ucode_stations(priv, NULL);\n\tiwl_dealloc_bcast_stations(priv);\n\tiwl_clear_driver_stations(priv);\n\n\t \n\tpriv->bt_status = 0;\n\tpriv->cur_rssi_ctx = NULL;\n\tpriv->bt_is_sco = 0;\n\tif (priv->lib->bt_params)\n\t\tpriv->bt_traffic_load =\n\t\t\t priv->lib->bt_params->bt_init_traffic_load;\n\telse\n\t\tpriv->bt_traffic_load = 0;\n\tpriv->bt_full_concurrent = false;\n\tpriv->bt_ci_compliance = 0;\n\n\t \n\tif (!exit_pending)\n\t\tclear_bit(STATUS_EXIT_PENDING, &priv->status);\n\n\tif (priv->mac80211_registered)\n\t\tieee80211_stop_queues(priv->hw);\n\n\tpriv->ucode_loaded = false;\n\tiwl_trans_stop_device(priv->trans);\n\n\t \n\tatomic_set(&priv->num_aux_in_flight, 0);\n\n\t \n\tpriv->status &= test_bit(STATUS_RF_KILL_HW, &priv->status) <<\n\t\t\t\tSTATUS_RF_KILL_HW |\n\t\t\ttest_bit(STATUS_FW_ERROR, &priv->status) <<\n\t\t\t\tSTATUS_FW_ERROR |\n\t\t\ttest_bit(STATUS_EXIT_PENDING, &priv->status) <<\n\t\t\t\tSTATUS_EXIT_PENDING;\n\n\tdev_kfree_skb(priv->beacon_skb);\n\tpriv->beacon_skb = NULL;\n}\n\n \n\nstatic void iwl_bg_run_time_calib_work(struct work_struct *work)\n{\n\tstruct iwl_priv *priv = container_of(work, struct iwl_priv,\n\t\t\trun_time_calib_work);\n\n\tmutex_lock(&priv->mutex);\n\n\tif (test_bit(STATUS_EXIT_PENDING, &priv->status) ||\n\t    test_bit(STATUS_SCANNING, &priv->status)) {\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn;\n\t}\n\n\tif (priv->start_calib) {\n\t\tiwl_chain_noise_calibration(priv);\n\t\tiwl_sensitivity_calibration(priv);\n\t}\n\n\tmutex_unlock(&priv->mutex);\n}\n\nvoid iwlagn_prepare_restart(struct iwl_priv *priv)\n{\n\tbool bt_full_concurrent;\n\tu8 bt_ci_compliance;\n\tu8 bt_load;\n\tu8 bt_status;\n\tbool bt_is_sco;\n\tint i;\n\n\tlockdep_assert_held(&priv->mutex);\n\n\tpriv->is_open = 0;\n\n\t \n\tbt_full_concurrent = priv->bt_full_concurrent;\n\tbt_ci_compliance = priv->bt_ci_compliance;\n\tbt_load = priv->bt_traffic_load;\n\tbt_status = priv->bt_status;\n\tbt_is_sco = priv->bt_is_sco;\n\n\tiwl_down(priv);\n\n\tpriv->bt_full_concurrent = bt_full_concurrent;\n\tpriv->bt_ci_compliance = bt_ci_compliance;\n\tpriv->bt_traffic_load = bt_load;\n\tpriv->bt_status = bt_status;\n\tpriv->bt_is_sco = bt_is_sco;\n\n\t \n\tfor (i = IWLAGN_FIRST_AMPDU_QUEUE; i < IWL_MAX_HW_QUEUES; i++)\n\t\tpriv->queue_to_mac80211[i] = IWL_INVALID_MAC80211_QUEUE;\n\t \n\tfor (i = 0; i < IWL_MAX_HW_QUEUES; i++)\n\t\tatomic_set(&priv->queue_stop_count[i], 0);\n\n\tmemset(priv->agg_q_alloc, 0, sizeof(priv->agg_q_alloc));\n}\n\nstatic void iwl_bg_restart(struct work_struct *data)\n{\n\tstruct iwl_priv *priv = container_of(data, struct iwl_priv, restart);\n\n\tif (test_bit(STATUS_EXIT_PENDING, &priv->status))\n\t\treturn;\n\n\tif (test_and_clear_bit(STATUS_FW_ERROR, &priv->status)) {\n\t\tmutex_lock(&priv->mutex);\n\t\tiwlagn_prepare_restart(priv);\n\t\tmutex_unlock(&priv->mutex);\n\t\tiwl_cancel_deferred_work(priv);\n\t\tif (priv->mac80211_registered)\n\t\t\tieee80211_restart_hw(priv->hw);\n\t\telse\n\t\t\tIWL_ERR(priv,\n\t\t\t\t\"Cannot request restart before registering with mac80211\\n\");\n\t} else {\n\t\tWARN_ON(1);\n\t}\n}\n\n \n\nstatic void iwl_setup_deferred_work(struct iwl_priv *priv)\n{\n\tpriv->workqueue = alloc_ordered_workqueue(DRV_NAME, 0);\n\n\tINIT_WORK(&priv->restart, iwl_bg_restart);\n\tINIT_WORK(&priv->beacon_update, iwl_bg_beacon_update);\n\tINIT_WORK(&priv->run_time_calib_work, iwl_bg_run_time_calib_work);\n\tINIT_WORK(&priv->tx_flush, iwl_bg_tx_flush);\n\tINIT_WORK(&priv->bt_full_concurrency, iwl_bg_bt_full_concurrency);\n\tINIT_WORK(&priv->bt_runtime_config, iwl_bg_bt_runtime_config);\n\n\tiwl_setup_scan_deferred_work(priv);\n\n\tif (priv->lib->bt_params)\n\t\tiwlagn_bt_setup_deferred_work(priv);\n\n\ttimer_setup(&priv->statistics_periodic, iwl_bg_statistics_periodic, 0);\n\n\ttimer_setup(&priv->ucode_trace, iwl_bg_ucode_trace, 0);\n}\n\nvoid iwl_cancel_deferred_work(struct iwl_priv *priv)\n{\n\tif (priv->lib->bt_params)\n\t\tiwlagn_bt_cancel_deferred_work(priv);\n\n\tcancel_work_sync(&priv->run_time_calib_work);\n\tcancel_work_sync(&priv->beacon_update);\n\n\tiwl_cancel_scan_deferred_work(priv);\n\n\tcancel_work_sync(&priv->bt_full_concurrency);\n\tcancel_work_sync(&priv->bt_runtime_config);\n\n\tdel_timer_sync(&priv->statistics_periodic);\n\tdel_timer_sync(&priv->ucode_trace);\n}\n\nstatic int iwl_init_drv(struct iwl_priv *priv)\n{\n\tspin_lock_init(&priv->sta_lock);\n\n\tmutex_init(&priv->mutex);\n\n\tINIT_LIST_HEAD(&priv->calib_results);\n\n\tpriv->band = NL80211_BAND_2GHZ;\n\n\tpriv->plcp_delta_threshold = priv->lib->plcp_delta_threshold;\n\n\tpriv->iw_mode = NL80211_IFTYPE_STATION;\n\tpriv->current_ht_config.smps = IEEE80211_SMPS_STATIC;\n\tpriv->missed_beacon_threshold = IWL_MISSED_BEACON_THRESHOLD_DEF;\n\tpriv->agg_tids_count = 0;\n\n\tpriv->rx_statistics_jiffies = jiffies;\n\n\t \n\tiwlagn_set_rxon_chain(priv, &priv->contexts[IWL_RXON_CTX_BSS]);\n\n\tiwl_init_scan_params(priv);\n\n\t \n\tif (priv->lib->bt_params &&\n\t    priv->lib->bt_params->advanced_bt_coexist) {\n\t\tpriv->kill_ack_mask = IWLAGN_BT_KILL_ACK_MASK_DEFAULT;\n\t\tpriv->kill_cts_mask = IWLAGN_BT_KILL_CTS_MASK_DEFAULT;\n\t\tpriv->bt_valid = IWLAGN_BT_ALL_VALID_MSK;\n\t\tpriv->bt_on_thresh = BT_ON_THRESHOLD_DEF;\n\t\tpriv->bt_duration = BT_DURATION_LIMIT_DEF;\n\t\tpriv->dynamic_frag_thresh = BT_FRAG_THRESHOLD_DEF;\n\t}\n\n\treturn 0;\n}\n\nstatic void iwl_uninit_drv(struct iwl_priv *priv)\n{\n\tkfree(priv->scan_cmd);\n\tkfree(priv->beacon_cmd);\n\tkfree(rcu_dereference_raw(priv->noa_data));\n\tiwl_calib_free_results(priv);\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tkfree(priv->wowlan_sram);\n#endif\n}\n\nstatic void iwl_set_hw_params(struct iwl_priv *priv)\n{\n\tif (priv->cfg->ht_params)\n\t\tpriv->hw_params.use_rts_for_aggregation =\n\t\t\tpriv->cfg->ht_params->use_rts_for_aggregation;\n\n\t \n\tpriv->lib->set_hw_params(priv);\n}\n\n\n\n \nstatic void iwl_option_config(struct iwl_priv *priv)\n{\n#ifdef CONFIG_IWLWIFI_DEBUG\n\tIWL_INFO(priv, \"CONFIG_IWLWIFI_DEBUG enabled\\n\");\n#else\n\tIWL_INFO(priv, \"CONFIG_IWLWIFI_DEBUG disabled\\n\");\n#endif\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tIWL_INFO(priv, \"CONFIG_IWLWIFI_DEBUGFS enabled\\n\");\n#else\n\tIWL_INFO(priv, \"CONFIG_IWLWIFI_DEBUGFS disabled\\n\");\n#endif\n\n#ifdef CONFIG_IWLWIFI_DEVICE_TRACING\n\tIWL_INFO(priv, \"CONFIG_IWLWIFI_DEVICE_TRACING enabled\\n\");\n#else\n\tIWL_INFO(priv, \"CONFIG_IWLWIFI_DEVICE_TRACING disabled\\n\");\n#endif\n}\n\nstatic int iwl_eeprom_init_hw_params(struct iwl_priv *priv)\n{\n\tstruct iwl_nvm_data *data = priv->nvm_data;\n\n\tif (data->sku_cap_11n_enable &&\n\t    !priv->cfg->ht_params) {\n\t\tIWL_ERR(priv, \"Invalid 11n configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!data->sku_cap_11n_enable && !data->sku_cap_band_24ghz_enable &&\n\t    !data->sku_cap_band_52ghz_enable) {\n\t\tIWL_ERR(priv, \"Invalid device sku\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tIWL_DEBUG_INFO(priv,\n\t\t       \"Device SKU: 24GHz %s %s, 52GHz %s %s, 11.n %s %s\\n\",\n\t\t       data->sku_cap_band_24ghz_enable ? \"\" : \"NOT\", \"enabled\",\n\t\t       data->sku_cap_band_52ghz_enable ? \"\" : \"NOT\", \"enabled\",\n\t\t       data->sku_cap_11n_enable ? \"\" : \"NOT\", \"enabled\");\n\n\tpriv->hw_params.tx_chains_num =\n\t\tnum_of_ant(data->valid_tx_ant);\n\tif (priv->cfg->rx_with_siso_diversity)\n\t\tpriv->hw_params.rx_chains_num = 1;\n\telse\n\t\tpriv->hw_params.rx_chains_num =\n\t\t\tnum_of_ant(data->valid_rx_ant);\n\n\tIWL_DEBUG_INFO(priv, \"Valid Tx ant: 0x%X, Valid Rx ant: 0x%X\\n\",\n\t\t       data->valid_tx_ant,\n\t\t       data->valid_rx_ant);\n\n\treturn 0;\n}\n\nstatic int iwl_nvm_check_version(struct iwl_nvm_data *data,\n\t\t\t\t struct iwl_trans *trans)\n{\n\tif (data->nvm_version >= trans->cfg->nvm_ver ||\n\t    data->calib_version >= trans->cfg->nvm_calib_ver) {\n\t\tIWL_DEBUG_INFO(trans, \"device EEPROM VER=0x%x, CALIB=0x%x\\n\",\n\t\t\t       data->nvm_version, data->calib_version);\n\t\treturn 0;\n\t}\n\n\tIWL_ERR(trans,\n\t\t\"Unsupported (too old) EEPROM VER=0x%x < 0x%x CALIB=0x%x < 0x%x\\n\",\n\t\tdata->nvm_version, trans->cfg->nvm_ver,\n\t\tdata->calib_version,  trans->cfg->nvm_calib_ver);\n\treturn -EINVAL;\n}\n\nstatic struct iwl_op_mode *iwl_op_mode_dvm_start(struct iwl_trans *trans,\n\t\t\t\t\t\t const struct iwl_cfg *cfg,\n\t\t\t\t\t\t const struct iwl_fw *fw,\n\t\t\t\t\t\t struct dentry *dbgfs_dir)\n{\n\tstruct iwl_priv *priv;\n\tstruct ieee80211_hw *hw;\n\tstruct iwl_op_mode *op_mode;\n\tu16 num_mac;\n\tu32 ucode_flags;\n\tstruct iwl_trans_config trans_cfg = {};\n\tstatic const u8 no_reclaim_cmds[] = {\n\t\tREPLY_RX_PHY_CMD,\n\t\tREPLY_RX_MPDU_CMD,\n\t\tREPLY_COMPRESSED_BA,\n\t\tSTATISTICS_NOTIFICATION,\n\t\tREPLY_TX,\n\t};\n\tint i;\n\n\t \n\thw = iwl_alloc_all();\n\tif (!hw) {\n\t\tpr_err(\"%s: Cannot allocate network device\\n\", trans->name);\n\t\tgoto out;\n\t}\n\n\top_mode = hw->priv;\n\top_mode->ops = &iwl_dvm_ops;\n\tpriv = IWL_OP_MODE_GET_DVM(op_mode);\n\tpriv->trans = trans;\n\tpriv->dev = trans->dev;\n\tpriv->cfg = cfg;\n\tpriv->fw = fw;\n\n\tswitch (priv->trans->trans_cfg->device_family) {\n\tcase IWL_DEVICE_FAMILY_1000:\n\tcase IWL_DEVICE_FAMILY_100:\n\t\tpriv->lib = &iwl_dvm_1000_cfg;\n\t\tbreak;\n\tcase IWL_DEVICE_FAMILY_2000:\n\t\tpriv->lib = &iwl_dvm_2000_cfg;\n\t\tbreak;\n\tcase IWL_DEVICE_FAMILY_105:\n\t\tpriv->lib = &iwl_dvm_105_cfg;\n\t\tbreak;\n\tcase IWL_DEVICE_FAMILY_2030:\n\tcase IWL_DEVICE_FAMILY_135:\n\t\tpriv->lib = &iwl_dvm_2030_cfg;\n\t\tbreak;\n\tcase IWL_DEVICE_FAMILY_5000:\n\t\tpriv->lib = &iwl_dvm_5000_cfg;\n\t\tbreak;\n\tcase IWL_DEVICE_FAMILY_5150:\n\t\tpriv->lib = &iwl_dvm_5150_cfg;\n\t\tbreak;\n\tcase IWL_DEVICE_FAMILY_6000:\n\tcase IWL_DEVICE_FAMILY_6000i:\n\t\tpriv->lib = &iwl_dvm_6000_cfg;\n\t\tbreak;\n\tcase IWL_DEVICE_FAMILY_6005:\n\t\tpriv->lib = &iwl_dvm_6005_cfg;\n\t\tbreak;\n\tcase IWL_DEVICE_FAMILY_6050:\n\tcase IWL_DEVICE_FAMILY_6150:\n\t\tpriv->lib = &iwl_dvm_6050_cfg;\n\t\tbreak;\n\tcase IWL_DEVICE_FAMILY_6030:\n\t\tpriv->lib = &iwl_dvm_6030_cfg;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (WARN_ON(!priv->lib))\n\t\tgoto out_free_hw;\n\n\t \n\ttrans_cfg.op_mode = op_mode;\n\ttrans_cfg.no_reclaim_cmds = no_reclaim_cmds;\n\ttrans_cfg.n_no_reclaim_cmds = ARRAY_SIZE(no_reclaim_cmds);\n\n\tswitch (iwlwifi_mod_params.amsdu_size) {\n\tcase IWL_AMSDU_DEF:\n\tcase IWL_AMSDU_4K:\n\t\ttrans_cfg.rx_buf_size = IWL_AMSDU_4K;\n\t\tbreak;\n\tcase IWL_AMSDU_8K:\n\t\ttrans_cfg.rx_buf_size = IWL_AMSDU_8K;\n\t\tbreak;\n\tcase IWL_AMSDU_12K:\n\tdefault:\n\t\ttrans_cfg.rx_buf_size = IWL_AMSDU_4K;\n\t\tpr_err(\"Unsupported amsdu_size: %d\\n\",\n\t\t       iwlwifi_mod_params.amsdu_size);\n\t}\n\n\ttrans_cfg.cmd_q_wdg_timeout = IWL_WATCHDOG_DISABLED;\n\n\ttrans_cfg.command_groups = iwl_dvm_groups;\n\ttrans_cfg.command_groups_size = ARRAY_SIZE(iwl_dvm_groups);\n\n\ttrans_cfg.cmd_fifo = IWLAGN_CMD_FIFO_NUM;\n\ttrans_cfg.cb_data_offs = offsetof(struct ieee80211_tx_info,\n\t\t\t\t\t  driver_data[2]);\n\n\tWARN_ON(sizeof(priv->transport_queue_stop) * BITS_PER_BYTE <\n\t\tpriv->trans->trans_cfg->base_params->num_of_queues);\n\n\tucode_flags = fw->ucode_capa.flags;\n\n\tif (ucode_flags & IWL_UCODE_TLV_FLAGS_PAN) {\n\t\tpriv->sta_key_max_num = STA_KEY_MAX_NUM_PAN;\n\t\ttrans_cfg.cmd_queue = IWL_IPAN_CMD_QUEUE_NUM;\n\t} else {\n\t\tpriv->sta_key_max_num = STA_KEY_MAX_NUM;\n\t\ttrans_cfg.cmd_queue = IWL_DEFAULT_CMD_QUEUE_NUM;\n\t}\n\n\t \n\tiwl_trans_configure(priv->trans, &trans_cfg);\n\n\ttrans->rx_mpdu_cmd = REPLY_RX_MPDU_CMD;\n\ttrans->rx_mpdu_cmd_hdr_size = sizeof(struct iwl_rx_mpdu_res_start);\n\ttrans->command_groups = trans_cfg.command_groups;\n\ttrans->command_groups_size = trans_cfg.command_groups_size;\n\n\t \n\n\tSET_IEEE80211_DEV(priv->hw, priv->trans->dev);\n\n\tiwl_option_config(priv);\n\n\tIWL_DEBUG_INFO(priv, \"*** LOAD DRIVER ***\\n\");\n\n\t \n\tpriv->bt_ch_announce = true;\n\tIWL_DEBUG_INFO(priv, \"BT channel inhibition is %s\\n\",\n\t\t       (priv->bt_ch_announce) ? \"On\" : \"Off\");\n\n\t \n\tspin_lock_init(&priv->statistics.lock);\n\n\t \n\tIWL_INFO(priv, \"Detected %s, REV=0x%X\\n\",\n\t\tpriv->trans->name, priv->trans->hw_rev);\n\n\tif (iwl_trans_start_hw(priv->trans))\n\t\tgoto out_free_hw;\n\n\t \n\tif (iwl_read_eeprom(priv->trans, &priv->eeprom_blob,\n\t\t\t    &priv->eeprom_blob_size)) {\n\t\tIWL_ERR(priv, \"Unable to init EEPROM\\n\");\n\t\tgoto out_free_hw;\n\t}\n\n\t \n\tiwl_trans_stop_device(priv->trans);\n\n\tpriv->nvm_data = iwl_parse_eeprom_data(priv->trans, priv->cfg,\n\t\t\t\t\t       priv->eeprom_blob,\n\t\t\t\t\t       priv->eeprom_blob_size);\n\tif (!priv->nvm_data)\n\t\tgoto out_free_eeprom_blob;\n\n\tif (iwl_nvm_check_version(priv->nvm_data, priv->trans))\n\t\tgoto out_free_eeprom;\n\n\tif (iwl_eeprom_init_hw_params(priv))\n\t\tgoto out_free_eeprom;\n\n\t \n\tmemcpy(priv->addresses[0].addr, priv->nvm_data->hw_addr, ETH_ALEN);\n\tIWL_DEBUG_INFO(priv, \"MAC address: %pM\\n\", priv->addresses[0].addr);\n\tpriv->hw->wiphy->addresses = priv->addresses;\n\tpriv->hw->wiphy->n_addresses = 1;\n\tnum_mac = priv->nvm_data->n_hw_addrs;\n\tif (num_mac > 1) {\n\t\tmemcpy(priv->addresses[1].addr, priv->addresses[0].addr,\n\t\t       ETH_ALEN);\n\t\tpriv->addresses[1].addr[5]++;\n\t\tpriv->hw->wiphy->n_addresses++;\n\t}\n\n\t \n\tiwl_set_hw_params(priv);\n\n\tif (!(priv->nvm_data->sku_cap_ipan_enable)) {\n\t\tIWL_DEBUG_INFO(priv, \"Your EEPROM disabled PAN\\n\");\n\t\tucode_flags &= ~IWL_UCODE_TLV_FLAGS_PAN;\n\t\t \n\t\tpriv->sta_key_max_num = STA_KEY_MAX_NUM;\n\t\ttrans_cfg.cmd_queue = IWL_DEFAULT_CMD_QUEUE_NUM;\n\n\t\t \n\t\tiwl_trans_configure(priv->trans, &trans_cfg);\n\t}\n\n\t \n\tfor (i = 0; i < IWL_MAX_HW_QUEUES; i++) {\n\t\tpriv->queue_to_mac80211[i] = IWL_INVALID_MAC80211_QUEUE;\n\t\tif (i < IWLAGN_FIRST_AMPDU_QUEUE &&\n\t\t    i != IWL_DEFAULT_CMD_QUEUE_NUM &&\n\t\t    i != IWL_IPAN_CMD_QUEUE_NUM)\n\t\t\tpriv->queue_to_mac80211[i] = i;\n\t\tatomic_set(&priv->queue_stop_count[i], 0);\n\t}\n\n\tif (iwl_init_drv(priv))\n\t\tgoto out_free_eeprom;\n\n\t \n\n\t \n\tiwl_setup_deferred_work(priv);\n\tiwl_setup_rx_handlers(priv);\n\n\tiwl_power_initialize(priv);\n\tiwl_tt_initialize(priv);\n\n\tsnprintf(priv->hw->wiphy->fw_version,\n\t\t sizeof(priv->hw->wiphy->fw_version),\n\t\t \"%s\", fw->fw_version);\n\n\tpriv->new_scan_threshold_behaviour =\n\t\t!!(ucode_flags & IWL_UCODE_TLV_FLAGS_NEWSCAN);\n\n\tpriv->phy_calib_chain_noise_reset_cmd =\n\t\tfw->ucode_capa.standard_phy_calibration_size;\n\tpriv->phy_calib_chain_noise_gain_cmd =\n\t\tfw->ucode_capa.standard_phy_calibration_size + 1;\n\n\t \n\tiwl_init_context(priv, ucode_flags);\n\n\t \n\tif (iwlagn_mac_setup_register(priv, &fw->ucode_capa))\n\t\tgoto out_destroy_workqueue;\n\n\tiwl_dbgfs_register(priv, dbgfs_dir);\n\n\treturn op_mode;\n\nout_destroy_workqueue:\n\tiwl_tt_exit(priv);\n\tiwl_cancel_deferred_work(priv);\n\tdestroy_workqueue(priv->workqueue);\n\tpriv->workqueue = NULL;\n\tiwl_uninit_drv(priv);\nout_free_eeprom_blob:\n\tkfree(priv->eeprom_blob);\nout_free_eeprom:\n\tkfree(priv->nvm_data);\nout_free_hw:\n\tieee80211_free_hw(priv->hw);\nout:\n\top_mode = NULL;\n\treturn op_mode;\n}\n\nstatic void iwl_op_mode_dvm_stop(struct iwl_op_mode *op_mode)\n{\n\tstruct iwl_priv *priv = IWL_OP_MODE_GET_DVM(op_mode);\n\n\tIWL_DEBUG_INFO(priv, \"*** UNLOAD DRIVER ***\\n\");\n\n\tiwlagn_mac_unregister(priv);\n\n\tiwl_tt_exit(priv);\n\n\tkfree(priv->eeprom_blob);\n\tkfree(priv->nvm_data);\n\n\t \n\n\t \n\tdestroy_workqueue(priv->workqueue);\n\tpriv->workqueue = NULL;\n\n\tiwl_uninit_drv(priv);\n\n\tdev_kfree_skb(priv->beacon_skb);\n\n\tiwl_trans_op_mode_leave(priv->trans);\n\tieee80211_free_hw(priv->hw);\n}\n\nstatic const char * const desc_lookup_text[] = {\n\t\"OK\",\n\t\"FAIL\",\n\t\"BAD_PARAM\",\n\t\"BAD_CHECKSUM\",\n\t\"NMI_INTERRUPT_WDG\",\n\t\"SYSASSERT\",\n\t\"FATAL_ERROR\",\n\t\"BAD_COMMAND\",\n\t\"HW_ERROR_TUNE_LOCK\",\n\t\"HW_ERROR_TEMPERATURE\",\n\t\"ILLEGAL_CHAN_FREQ\",\n\t\"VCC_NOT_STABLE\",\n\t\"FH_ERROR\",\n\t\"NMI_INTERRUPT_HOST\",\n\t\"NMI_INTERRUPT_ACTION_PT\",\n\t\"NMI_INTERRUPT_UNKNOWN\",\n\t\"UCODE_VERSION_MISMATCH\",\n\t\"HW_ERROR_ABS_LOCK\",\n\t\"HW_ERROR_CAL_LOCK_FAIL\",\n\t\"NMI_INTERRUPT_INST_ACTION_PT\",\n\t\"NMI_INTERRUPT_DATA_ACTION_PT\",\n\t\"NMI_TRM_HW_ER\",\n\t\"NMI_INTERRUPT_TRM\",\n\t\"NMI_INTERRUPT_BREAK_POINT\",\n\t\"DEBUG_0\",\n\t\"DEBUG_1\",\n\t\"DEBUG_2\",\n\t\"DEBUG_3\",\n};\n\nstatic struct { char *name; u8 num; } advanced_lookup[] = {\n\t{ \"NMI_INTERRUPT_WDG\", 0x34 },\n\t{ \"SYSASSERT\", 0x35 },\n\t{ \"UCODE_VERSION_MISMATCH\", 0x37 },\n\t{ \"BAD_COMMAND\", 0x38 },\n\t{ \"NMI_INTERRUPT_DATA_ACTION_PT\", 0x3C },\n\t{ \"FATAL_ERROR\", 0x3D },\n\t{ \"NMI_TRM_HW_ERR\", 0x46 },\n\t{ \"NMI_INTERRUPT_TRM\", 0x4C },\n\t{ \"NMI_INTERRUPT_BREAK_POINT\", 0x54 },\n\t{ \"NMI_INTERRUPT_WDG_RXF_FULL\", 0x5C },\n\t{ \"NMI_INTERRUPT_WDG_NO_RBD_RXF_FULL\", 0x64 },\n\t{ \"NMI_INTERRUPT_HOST\", 0x66 },\n\t{ \"NMI_INTERRUPT_ACTION_PT\", 0x7C },\n\t{ \"NMI_INTERRUPT_UNKNOWN\", 0x84 },\n\t{ \"NMI_INTERRUPT_INST_ACTION_PT\", 0x86 },\n\t{ \"ADVANCED_SYSASSERT\", 0 },\n};\n\nstatic const char *desc_lookup(u32 num)\n{\n\tint i;\n\tint max = ARRAY_SIZE(desc_lookup_text);\n\n\tif (num < max)\n\t\treturn desc_lookup_text[num];\n\n\tmax = ARRAY_SIZE(advanced_lookup) - 1;\n\tfor (i = 0; i < max; i++) {\n\t\tif (advanced_lookup[i].num == num)\n\t\t\tbreak;\n\t}\n\treturn advanced_lookup[i].name;\n}\n\n#define ERROR_START_OFFSET  (1 * sizeof(u32))\n#define ERROR_ELEM_SIZE     (7 * sizeof(u32))\n\nstatic void iwl_dump_nic_error_log(struct iwl_priv *priv)\n{\n\tstruct iwl_trans *trans = priv->trans;\n\tu32 base;\n\tstruct iwl_error_event_table table;\n\n\tbase = priv->device_pointers.error_event_table;\n\tif (priv->cur_ucode == IWL_UCODE_INIT) {\n\t\tif (!base)\n\t\t\tbase = priv->fw->init_errlog_ptr;\n\t} else {\n\t\tif (!base)\n\t\t\tbase = priv->fw->inst_errlog_ptr;\n\t}\n\n\tif (!iwlagn_hw_valid_rtc_data_addr(base)) {\n\t\tIWL_ERR(priv,\n\t\t\t\"Not valid error log pointer 0x%08X for %s uCode\\n\",\n\t\t\tbase,\n\t\t\t(priv->cur_ucode == IWL_UCODE_INIT)\n\t\t\t\t\t? \"Init\" : \"RT\");\n\t\treturn;\n\t}\n\n\t \n\tiwl_trans_read_mem_bytes(trans, base, &table, sizeof(table));\n\n\tif (ERROR_START_OFFSET <= table.valid * ERROR_ELEM_SIZE) {\n\t\tIWL_ERR(trans, \"Start IWL Error Log Dump:\\n\");\n\t\tIWL_ERR(trans, \"Status: 0x%08lX, count: %d\\n\",\n\t\t\tpriv->status, table.valid);\n\t}\n\n\tIWL_ERR(priv, \"0x%08X | %-28s\\n\", table.error_id,\n\t\tdesc_lookup(table.error_id));\n\tIWL_ERR(priv, \"0x%08X | uPc\\n\", table.pc);\n\tIWL_ERR(priv, \"0x%08X | branchlink1\\n\", table.blink1);\n\tIWL_ERR(priv, \"0x%08X | branchlink2\\n\", table.blink2);\n\tIWL_ERR(priv, \"0x%08X | interruptlink1\\n\", table.ilink1);\n\tIWL_ERR(priv, \"0x%08X | interruptlink2\\n\", table.ilink2);\n\tIWL_ERR(priv, \"0x%08X | data1\\n\", table.data1);\n\tIWL_ERR(priv, \"0x%08X | data2\\n\", table.data2);\n\tIWL_ERR(priv, \"0x%08X | line\\n\", table.line);\n\tIWL_ERR(priv, \"0x%08X | beacon time\\n\", table.bcon_time);\n\tIWL_ERR(priv, \"0x%08X | tsf low\\n\", table.tsf_low);\n\tIWL_ERR(priv, \"0x%08X | tsf hi\\n\", table.tsf_hi);\n\tIWL_ERR(priv, \"0x%08X | time gp1\\n\", table.gp1);\n\tIWL_ERR(priv, \"0x%08X | time gp2\\n\", table.gp2);\n\tIWL_ERR(priv, \"0x%08X | time gp3\\n\", table.gp3);\n\tIWL_ERR(priv, \"0x%08X | uCode version\\n\", table.ucode_ver);\n\tIWL_ERR(priv, \"0x%08X | hw version\\n\", table.hw_ver);\n\tIWL_ERR(priv, \"0x%08X | board version\\n\", table.brd_ver);\n\tIWL_ERR(priv, \"0x%08X | hcmd\\n\", table.hcmd);\n\tIWL_ERR(priv, \"0x%08X | isr0\\n\", table.isr0);\n\tIWL_ERR(priv, \"0x%08X | isr1\\n\", table.isr1);\n\tIWL_ERR(priv, \"0x%08X | isr2\\n\", table.isr2);\n\tIWL_ERR(priv, \"0x%08X | isr3\\n\", table.isr3);\n\tIWL_ERR(priv, \"0x%08X | isr4\\n\", table.isr4);\n\tIWL_ERR(priv, \"0x%08X | isr_pref\\n\", table.isr_pref);\n\tIWL_ERR(priv, \"0x%08X | wait_event\\n\", table.wait_event);\n\tIWL_ERR(priv, \"0x%08X | l2p_control\\n\", table.l2p_control);\n\tIWL_ERR(priv, \"0x%08X | l2p_duration\\n\", table.l2p_duration);\n\tIWL_ERR(priv, \"0x%08X | l2p_mhvalid\\n\", table.l2p_mhvalid);\n\tIWL_ERR(priv, \"0x%08X | l2p_addr_match\\n\", table.l2p_addr_match);\n\tIWL_ERR(priv, \"0x%08X | lmpm_pmg_sel\\n\", table.lmpm_pmg_sel);\n\tIWL_ERR(priv, \"0x%08X | timestamp\\n\", table.u_timestamp);\n\tIWL_ERR(priv, \"0x%08X | flow_handler\\n\", table.flow_handler);\n}\n\n#define EVENT_START_OFFSET  (4 * sizeof(u32))\n\n \nstatic int iwl_print_event_log(struct iwl_priv *priv, u32 start_idx,\n\t\t\t       u32 num_events, u32 mode,\n\t\t\t       int pos, char **buf, size_t bufsz)\n{\n\tu32 i;\n\tu32 base;        \n\tu32 event_size;  \n\tu32 ptr;         \n\tu32 ev, time, data;  \n\n\tstruct iwl_trans *trans = priv->trans;\n\n\tif (num_events == 0)\n\t\treturn pos;\n\n\tbase = priv->device_pointers.log_event_table;\n\tif (priv->cur_ucode == IWL_UCODE_INIT) {\n\t\tif (!base)\n\t\t\tbase = priv->fw->init_evtlog_ptr;\n\t} else {\n\t\tif (!base)\n\t\t\tbase = priv->fw->inst_evtlog_ptr;\n\t}\n\n\tif (mode == 0)\n\t\tevent_size = 2 * sizeof(u32);\n\telse\n\t\tevent_size = 3 * sizeof(u32);\n\n\tptr = base + EVENT_START_OFFSET + (start_idx * event_size);\n\n\t \n\tif (!iwl_trans_grab_nic_access(trans))\n\t\treturn pos;\n\n\t \n\tiwl_write32(trans, HBUS_TARG_MEM_RADDR, ptr);\n\n\t \n\tfor (i = 0; i < num_events; i++) {\n\t\tev = iwl_read32(trans, HBUS_TARG_MEM_RDAT);\n\t\ttime = iwl_read32(trans, HBUS_TARG_MEM_RDAT);\n\t\tif (mode == 0) {\n\t\t\t \n\t\t\tif (bufsz) {\n\t\t\t\tpos += scnprintf(*buf + pos, bufsz - pos,\n\t\t\t\t\t\t\"EVT_LOG:0x%08x:%04u\\n\",\n\t\t\t\t\t\ttime, ev);\n\t\t\t} else {\n\t\t\t\ttrace_iwlwifi_dev_ucode_event(trans->dev, 0,\n\t\t\t\t\ttime, ev);\n\t\t\t\tIWL_ERR(priv, \"EVT_LOG:0x%08x:%04u\\n\",\n\t\t\t\t\ttime, ev);\n\t\t\t}\n\t\t} else {\n\t\t\tdata = iwl_read32(trans, HBUS_TARG_MEM_RDAT);\n\t\t\tif (bufsz) {\n\t\t\t\tpos += scnprintf(*buf + pos, bufsz - pos,\n\t\t\t\t\t\t\"EVT_LOGT:%010u:0x%08x:%04u\\n\",\n\t\t\t\t\t\t time, data, ev);\n\t\t\t} else {\n\t\t\t\tIWL_ERR(priv, \"EVT_LOGT:%010u:0x%08x:%04u\\n\",\n\t\t\t\t\ttime, data, ev);\n\t\t\t\ttrace_iwlwifi_dev_ucode_event(trans->dev, time,\n\t\t\t\t\tdata, ev);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tiwl_trans_release_nic_access(trans);\n\treturn pos;\n}\n\n \nstatic int iwl_print_last_event_logs(struct iwl_priv *priv, u32 capacity,\n\t\t\t\t    u32 num_wraps, u32 next_entry,\n\t\t\t\t    u32 size, u32 mode,\n\t\t\t\t    int pos, char **buf, size_t bufsz)\n{\n\t \n\tif (num_wraps) {\n\t\tif (next_entry < size) {\n\t\t\tpos = iwl_print_event_log(priv,\n\t\t\t\t\t\tcapacity - (size - next_entry),\n\t\t\t\t\t\tsize - next_entry, mode,\n\t\t\t\t\t\tpos, buf, bufsz);\n\t\t\tpos = iwl_print_event_log(priv, 0,\n\t\t\t\t\t\t  next_entry, mode,\n\t\t\t\t\t\t  pos, buf, bufsz);\n\t\t} else\n\t\t\tpos = iwl_print_event_log(priv, next_entry - size,\n\t\t\t\t\t\t  size, mode, pos, buf, bufsz);\n\t} else {\n\t\tif (next_entry < size) {\n\t\t\tpos = iwl_print_event_log(priv, 0, next_entry,\n\t\t\t\t\t\t  mode, pos, buf, bufsz);\n\t\t} else {\n\t\t\tpos = iwl_print_event_log(priv, next_entry - size,\n\t\t\t\t\t\t  size, mode, pos, buf, bufsz);\n\t\t}\n\t}\n\treturn pos;\n}\n\n#define DEFAULT_DUMP_EVENT_LOG_ENTRIES (20)\n\nint iwl_dump_nic_event_log(struct iwl_priv *priv, bool full_log,\n\t\t\t    char **buf)\n{\n\tu32 base;        \n\tu32 capacity;    \n\tu32 mode;        \n\tu32 num_wraps;   \n\tu32 next_entry;  \n\tu32 size;        \n\tu32 logsize;\n\tint pos = 0;\n\tsize_t bufsz = 0;\n\tstruct iwl_trans *trans = priv->trans;\n\n\tbase = priv->device_pointers.log_event_table;\n\tif (priv->cur_ucode == IWL_UCODE_INIT) {\n\t\tlogsize = priv->fw->init_evtlog_size;\n\t\tif (!base)\n\t\t\tbase = priv->fw->init_evtlog_ptr;\n\t} else {\n\t\tlogsize = priv->fw->inst_evtlog_size;\n\t\tif (!base)\n\t\t\tbase = priv->fw->inst_evtlog_ptr;\n\t}\n\n\tif (!iwlagn_hw_valid_rtc_data_addr(base)) {\n\t\tIWL_ERR(priv,\n\t\t\t\"Invalid event log pointer 0x%08X for %s uCode\\n\",\n\t\t\tbase,\n\t\t\t(priv->cur_ucode == IWL_UCODE_INIT)\n\t\t\t\t\t? \"Init\" : \"RT\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcapacity = iwl_trans_read_mem32(trans, base);\n\tmode = iwl_trans_read_mem32(trans, base + (1 * sizeof(u32)));\n\tnum_wraps = iwl_trans_read_mem32(trans, base + (2 * sizeof(u32)));\n\tnext_entry = iwl_trans_read_mem32(trans, base + (3 * sizeof(u32)));\n\n\tif (capacity > logsize) {\n\t\tIWL_ERR(priv, \"Log capacity %d is bogus, limit to %d \"\n\t\t\t\"entries\\n\", capacity, logsize);\n\t\tcapacity = logsize;\n\t}\n\n\tif (next_entry > logsize) {\n\t\tIWL_ERR(priv, \"Log write index %d is bogus, limit to %d\\n\",\n\t\t\tnext_entry, logsize);\n\t\tnext_entry = logsize;\n\t}\n\n\tsize = num_wraps ? capacity : next_entry;\n\n\t \n\tif (size == 0) {\n\t\tIWL_ERR(trans, \"Start IWL Event Log Dump: nothing in log\\n\");\n\t\treturn pos;\n\t}\n\n\tif (!(iwl_have_debug_level(IWL_DL_FW)) && !full_log)\n\t\tsize = (size > DEFAULT_DUMP_EVENT_LOG_ENTRIES)\n\t\t\t? DEFAULT_DUMP_EVENT_LOG_ENTRIES : size;\n\tIWL_ERR(priv, \"Start IWL Event Log Dump: display last %u entries\\n\",\n\t\tsize);\n\n#ifdef CONFIG_IWLWIFI_DEBUG\n\tif (buf) {\n\t\tif (full_log)\n\t\t\tbufsz = capacity * 48;\n\t\telse\n\t\t\tbufsz = size * 48;\n\t\t*buf = kmalloc(bufsz, GFP_KERNEL);\n\t\tif (!*buf)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (iwl_have_debug_level(IWL_DL_FW) || full_log) {\n\t\t \n\t\tif (num_wraps)\n\t\t\tpos = iwl_print_event_log(priv, next_entry,\n\t\t\t\t\t\tcapacity - next_entry, mode,\n\t\t\t\t\t\tpos, buf, bufsz);\n\t\t \n\t\tpos = iwl_print_event_log(priv, 0,\n\t\t\t\t\t  next_entry, mode, pos, buf, bufsz);\n\t} else\n\t\tpos = iwl_print_last_event_logs(priv, capacity, num_wraps,\n\t\t\t\t\t\tnext_entry, size, mode,\n\t\t\t\t\t\tpos, buf, bufsz);\n#else\n\tpos = iwl_print_last_event_logs(priv, capacity, num_wraps,\n\t\t\t\t\tnext_entry, size, mode,\n\t\t\t\t\tpos, buf, bufsz);\n#endif\n\treturn pos;\n}\n\nstatic void iwlagn_fw_error(struct iwl_priv *priv, bool ondemand)\n{\n\tunsigned int reload_msec;\n\tunsigned long reload_jiffies;\n\n\tif (iwl_have_debug_level(IWL_DL_FW))\n\t\tiwl_print_rx_config_cmd(priv, IWL_RXON_CTX_BSS);\n\n\t \n\tpriv->ucode_loaded = false;\n\n\t \n\tset_bit(STATUS_FW_ERROR, &priv->status);\n\n\tiwl_abort_notification_waits(&priv->notif_wait);\n\n\t \n\tclear_bit(STATUS_READY, &priv->status);\n\n\tif (!ondemand) {\n\t\t \n\t\treload_jiffies = jiffies;\n\t\treload_msec = jiffies_to_msecs((long) reload_jiffies -\n\t\t\t\t\t(long) priv->reload_jiffies);\n\t\tpriv->reload_jiffies = reload_jiffies;\n\t\tif (reload_msec <= IWL_MIN_RELOAD_DURATION) {\n\t\t\tpriv->reload_count++;\n\t\t\tif (priv->reload_count >= IWL_MAX_CONTINUE_RELOAD_CNT) {\n\t\t\t\tIWL_ERR(priv, \"BUG_ON, Stop restarting\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else\n\t\t\tpriv->reload_count = 0;\n\t}\n\n\tif (!test_bit(STATUS_EXIT_PENDING, &priv->status)) {\n\t\tif (iwlwifi_mod_params.fw_restart) {\n\t\t\tIWL_DEBUG_FW(priv,\n\t\t\t\t     \"Restarting adapter due to uCode error.\\n\");\n\t\t\tqueue_work(priv->workqueue, &priv->restart);\n\t\t} else\n\t\t\tIWL_DEBUG_FW(priv,\n\t\t\t\t     \"Detected FW error, but not restarting\\n\");\n\t}\n}\n\nstatic void iwl_nic_error(struct iwl_op_mode *op_mode, bool sync)\n{\n\tstruct iwl_priv *priv = IWL_OP_MODE_GET_DVM(op_mode);\n\n\tIWL_ERR(priv, \"Loaded firmware version: %s\\n\",\n\t\tpriv->fw->fw_version);\n\n\tiwl_dump_nic_error_log(priv);\n\tiwl_dump_nic_event_log(priv, false, NULL);\n\n\tiwlagn_fw_error(priv, false);\n}\n\nstatic void iwl_cmd_queue_full(struct iwl_op_mode *op_mode)\n{\n\tstruct iwl_priv *priv = IWL_OP_MODE_GET_DVM(op_mode);\n\n\tif (!iwl_check_for_ct_kill(priv)) {\n\t\tIWL_ERR(priv, \"Restarting adapter queue is full\\n\");\n\t\tiwlagn_fw_error(priv, false);\n\t}\n}\n\n#define EEPROM_RF_CONFIG_TYPE_MAX      0x3\n\nstatic void iwl_nic_config(struct iwl_op_mode *op_mode)\n{\n\tstruct iwl_priv *priv = IWL_OP_MODE_GET_DVM(op_mode);\n\n\t \n\tiwl_trans_set_bits_mask(priv->trans, CSR_HW_IF_CONFIG_REG,\n\t\t\t\tCSR_HW_IF_CONFIG_REG_MSK_MAC_STEP_DASH,\n\t\t\t\tCSR_HW_REV_STEP_DASH(priv->trans->hw_rev));\n\n\t \n\tif (priv->nvm_data->radio_cfg_type <= EEPROM_RF_CONFIG_TYPE_MAX) {\n\t\tu32 reg_val =\n\t\t\tpriv->nvm_data->radio_cfg_type <<\n\t\t\t\tCSR_HW_IF_CONFIG_REG_POS_PHY_TYPE |\n\t\t\tpriv->nvm_data->radio_cfg_step <<\n\t\t\t\tCSR_HW_IF_CONFIG_REG_POS_PHY_STEP |\n\t\t\tpriv->nvm_data->radio_cfg_dash <<\n\t\t\t\tCSR_HW_IF_CONFIG_REG_POS_PHY_DASH;\n\n\t\tiwl_trans_set_bits_mask(priv->trans, CSR_HW_IF_CONFIG_REG,\n\t\t\t\t\tCSR_HW_IF_CONFIG_REG_MSK_PHY_TYPE |\n\t\t\t\t\tCSR_HW_IF_CONFIG_REG_MSK_PHY_STEP |\n\t\t\t\t\tCSR_HW_IF_CONFIG_REG_MSK_PHY_DASH,\n\t\t\t\t\treg_val);\n\n\t\tIWL_INFO(priv, \"Radio type=0x%x-0x%x-0x%x\\n\",\n\t\t\t priv->nvm_data->radio_cfg_type,\n\t\t\t priv->nvm_data->radio_cfg_step,\n\t\t\t priv->nvm_data->radio_cfg_dash);\n\t} else {\n\t\tWARN_ON(1);\n\t}\n\n\t \n\tiwl_set_bit(priv->trans, CSR_HW_IF_CONFIG_REG,\n\t\t    CSR_HW_IF_CONFIG_REG_BIT_RADIO_SI |\n\t\t    CSR_HW_IF_CONFIG_REG_BIT_MAC_SI);\n\n\t \n\tiwl_set_bits_mask_prph(priv->trans, APMG_PS_CTRL_REG,\n\t\t\t       APMG_PS_CTRL_EARLY_PWR_OFF_RESET_DIS,\n\t\t\t       ~APMG_PS_CTRL_EARLY_PWR_OFF_RESET_DIS);\n\n\tif (priv->lib->nic_config)\n\t\tpriv->lib->nic_config(priv);\n}\n\nstatic void iwl_wimax_active(struct iwl_op_mode *op_mode)\n{\n\tstruct iwl_priv *priv = IWL_OP_MODE_GET_DVM(op_mode);\n\n\tclear_bit(STATUS_READY, &priv->status);\n\tIWL_ERR(priv, \"RF is used by WiMAX\\n\");\n}\n\nstatic void iwl_stop_sw_queue(struct iwl_op_mode *op_mode, int queue)\n{\n\tstruct iwl_priv *priv = IWL_OP_MODE_GET_DVM(op_mode);\n\tint mq = priv->queue_to_mac80211[queue];\n\n\tif (WARN_ON_ONCE(mq == IWL_INVALID_MAC80211_QUEUE))\n\t\treturn;\n\n\tif (atomic_inc_return(&priv->queue_stop_count[mq]) > 1) {\n\t\tIWL_DEBUG_TX_QUEUES(priv,\n\t\t\t\"queue %d (mac80211 %d) already stopped\\n\",\n\t\t\tqueue, mq);\n\t\treturn;\n\t}\n\n\tset_bit(mq, &priv->transport_queue_stop);\n\tieee80211_stop_queue(priv->hw, mq);\n}\n\nstatic void iwl_wake_sw_queue(struct iwl_op_mode *op_mode, int queue)\n{\n\tstruct iwl_priv *priv = IWL_OP_MODE_GET_DVM(op_mode);\n\tint mq = priv->queue_to_mac80211[queue];\n\n\tif (WARN_ON_ONCE(mq == IWL_INVALID_MAC80211_QUEUE))\n\t\treturn;\n\n\tif (atomic_dec_return(&priv->queue_stop_count[mq]) > 0) {\n\t\tIWL_DEBUG_TX_QUEUES(priv,\n\t\t\t\"queue %d (mac80211 %d) already awake\\n\",\n\t\t\tqueue, mq);\n\t\treturn;\n\t}\n\n\tclear_bit(mq, &priv->transport_queue_stop);\n\n\tif (!priv->passive_no_rx)\n\t\tieee80211_wake_queue(priv->hw, mq);\n}\n\nvoid iwlagn_lift_passive_no_rx(struct iwl_priv *priv)\n{\n\tint mq;\n\n\tif (!priv->passive_no_rx)\n\t\treturn;\n\n\tfor (mq = 0; mq < IWLAGN_FIRST_AMPDU_QUEUE; mq++) {\n\t\tif (!test_bit(mq, &priv->transport_queue_stop)) {\n\t\t\tIWL_DEBUG_TX_QUEUES(priv, \"Wake queue %d\\n\", mq);\n\t\t\tieee80211_wake_queue(priv->hw, mq);\n\t\t} else {\n\t\t\tIWL_DEBUG_TX_QUEUES(priv, \"Don't wake queue %d\\n\", mq);\n\t\t}\n\t}\n\n\tpriv->passive_no_rx = false;\n}\n\nstatic void iwl_free_skb(struct iwl_op_mode *op_mode, struct sk_buff *skb)\n{\n\tstruct iwl_priv *priv = IWL_OP_MODE_GET_DVM(op_mode);\n\tstruct ieee80211_tx_info *info;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tiwl_trans_free_tx_cmd(priv->trans, info->driver_data[1]);\n\tieee80211_free_txskb(priv->hw, skb);\n}\n\nstatic bool iwl_set_hw_rfkill_state(struct iwl_op_mode *op_mode, bool state)\n{\n\tstruct iwl_priv *priv = IWL_OP_MODE_GET_DVM(op_mode);\n\n\tif (state)\n\t\tset_bit(STATUS_RF_KILL_HW, &priv->status);\n\telse\n\t\tclear_bit(STATUS_RF_KILL_HW, &priv->status);\n\n\twiphy_rfkill_set_hw_state(priv->hw->wiphy, state);\n\n\treturn false;\n}\n\nstatic const struct iwl_op_mode_ops iwl_dvm_ops = {\n\t.start = iwl_op_mode_dvm_start,\n\t.stop = iwl_op_mode_dvm_stop,\n\t.rx = iwl_rx_dispatch,\n\t.queue_full = iwl_stop_sw_queue,\n\t.queue_not_full = iwl_wake_sw_queue,\n\t.hw_rf_kill = iwl_set_hw_rfkill_state,\n\t.free_skb = iwl_free_skb,\n\t.nic_error = iwl_nic_error,\n\t.cmd_queue_full = iwl_cmd_queue_full,\n\t.nic_config = iwl_nic_config,\n\t.wimax_active = iwl_wimax_active,\n};\n\n \nstatic int __init iwl_init(void)\n{\n\n\tint ret;\n\n\tret = iwlagn_rate_control_register();\n\tif (ret) {\n\t\tpr_err(\"Unable to register rate control algorithm: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = iwl_opmode_register(\"iwldvm\", &iwl_dvm_ops);\n\tif (ret) {\n\t\tpr_err(\"Unable to register op_mode: %d\\n\", ret);\n\t\tiwlagn_rate_control_unregister();\n\t}\n\n\treturn ret;\n}\nmodule_init(iwl_init);\n\nstatic void __exit iwl_exit(void)\n{\n\tiwl_opmode_deregister(\"iwldvm\");\n\tiwlagn_rate_control_unregister();\n}\nmodule_exit(iwl_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}