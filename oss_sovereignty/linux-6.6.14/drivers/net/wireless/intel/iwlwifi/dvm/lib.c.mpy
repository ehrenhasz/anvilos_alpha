{
  "module_name": "lib.c",
  "hash_id": "d3b0b72e47e47b568d5ade684b90f9aa20c825c1e5e35f342726871f8567dcd3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/dvm/lib.c",
  "human_readable_source": "\n \n#include <linux/etherdevice.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <net/mac80211.h>\n\n#include \"iwl-io.h\"\n#include \"iwl-agn-hw.h\"\n#include \"iwl-trans.h\"\n#include \"iwl-modparams.h\"\n\n#include \"dev.h\"\n#include \"agn.h\"\n\nint iwlagn_hw_valid_rtc_data_addr(u32 addr)\n{\n\treturn (addr >= IWLAGN_RTC_DATA_LOWER_BOUND) &&\n\t\t(addr < IWLAGN_RTC_DATA_UPPER_BOUND);\n}\n\nint iwlagn_send_tx_power(struct iwl_priv *priv)\n{\n\tstruct iwlagn_tx_power_dbm_cmd tx_power_cmd;\n\tu8 tx_ant_cfg_cmd;\n\n\tif (WARN_ONCE(test_bit(STATUS_SCAN_HW, &priv->status),\n\t\t      \"TX Power requested while scanning!\\n\"))\n\t\treturn -EAGAIN;\n\n\t \n\ttx_power_cmd.global_lmt = (s8)(2 * priv->tx_power_user_lmt);\n\n\tif (tx_power_cmd.global_lmt > priv->nvm_data->max_tx_pwr_half_dbm) {\n\t\t \n\t\ttx_power_cmd.global_lmt =\n\t\t\tpriv->nvm_data->max_tx_pwr_half_dbm;\n\t}\n\ttx_power_cmd.flags = IWLAGN_TX_POWER_NO_CLOSED;\n\ttx_power_cmd.srv_chan_lmt = IWLAGN_TX_POWER_AUTO;\n\n\tif (IWL_UCODE_API(priv->fw->ucode_ver) == 1)\n\t\ttx_ant_cfg_cmd = REPLY_TX_POWER_DBM_CMD_V1;\n\telse\n\t\ttx_ant_cfg_cmd = REPLY_TX_POWER_DBM_CMD;\n\n\treturn iwl_dvm_send_cmd_pdu(priv, tx_ant_cfg_cmd, 0,\n\t\t\tsizeof(tx_power_cmd), &tx_power_cmd);\n}\n\nvoid iwlagn_temperature(struct iwl_priv *priv)\n{\n\tlockdep_assert_held(&priv->statistics.lock);\n\n\t \n\tpriv->temperature = le32_to_cpu(priv->statistics.common.temperature);\n\tiwl_tt_handler(priv);\n}\n\nint iwlagn_hwrate_to_mac80211_idx(u32 rate_n_flags, enum nl80211_band band)\n{\n\tint idx = 0;\n\tint band_offset = 0;\n\n\t \n\tif (rate_n_flags & RATE_MCS_HT_MSK) {\n\t\tidx = (rate_n_flags & 0xff);\n\t\treturn idx;\n\t \n\t} else {\n\t\tif (band == NL80211_BAND_5GHZ)\n\t\t\tband_offset = IWL_FIRST_OFDM_RATE;\n\t\tfor (idx = band_offset; idx < IWL_RATE_COUNT_LEGACY; idx++)\n\t\t\tif (iwl_rates[idx].plcp == (rate_n_flags & 0xFF))\n\t\t\t\treturn idx - band_offset;\n\t}\n\n\treturn -1;\n}\n\nint iwlagn_manage_ibss_station(struct iwl_priv *priv,\n\t\t\t       struct ieee80211_vif *vif, bool add)\n{\n\tstruct iwl_vif_priv *vif_priv = (void *)vif->drv_priv;\n\n\tif (add)\n\t\treturn iwlagn_add_bssid_station(priv, vif_priv->ctx,\n\t\t\t\t\t\tvif->bss_conf.bssid,\n\t\t\t\t\t\t&vif_priv->ibss_bssid_sta_id);\n\treturn iwl_remove_station(priv, vif_priv->ibss_bssid_sta_id,\n\t\t\t\t  vif->bss_conf.bssid);\n}\n\n \nint iwlagn_txfifo_flush(struct iwl_priv *priv, u32 scd_q_msk)\n{\n\tstruct iwl_txfifo_flush_cmd_v3 flush_cmd_v3 = {\n\t\t.flush_control = cpu_to_le16(IWL_DROP_ALL),\n\t};\n\tstruct iwl_txfifo_flush_cmd_v2 flush_cmd_v2 = {\n\t\t.flush_control = cpu_to_le16(IWL_DROP_ALL),\n\t};\n\n\tu32 queue_control = IWL_SCD_VO_MSK | IWL_SCD_VI_MSK |\n\t\t\t    IWL_SCD_BE_MSK | IWL_SCD_BK_MSK | IWL_SCD_MGMT_MSK;\n\n\tif ((priv->valid_contexts != BIT(IWL_RXON_CTX_BSS)))\n\t\tqueue_control |= IWL_PAN_SCD_VO_MSK | IWL_PAN_SCD_VI_MSK |\n\t\t\t\t IWL_PAN_SCD_BE_MSK | IWL_PAN_SCD_BK_MSK |\n\t\t\t\t IWL_PAN_SCD_MGMT_MSK |\n\t\t\t\t IWL_PAN_SCD_MULTICAST_MSK;\n\n\tif (priv->nvm_data->sku_cap_11n_enable)\n\t\tqueue_control |= IWL_AGG_TX_QUEUE_MSK;\n\n\tif (scd_q_msk)\n\t\tqueue_control = scd_q_msk;\n\n\tIWL_DEBUG_INFO(priv, \"queue control: 0x%x\\n\", queue_control);\n\tflush_cmd_v3.queue_control = cpu_to_le32(queue_control);\n\tflush_cmd_v2.queue_control = cpu_to_le16((u16)queue_control);\n\n\tif (IWL_UCODE_API(priv->fw->ucode_ver) > 2)\n\t\treturn iwl_dvm_send_cmd_pdu(priv, REPLY_TXFIFO_FLUSH, 0,\n\t\t\t\t\t    sizeof(flush_cmd_v3),\n\t\t\t\t\t    &flush_cmd_v3);\n\treturn iwl_dvm_send_cmd_pdu(priv, REPLY_TXFIFO_FLUSH, 0,\n\t\t\t\t    sizeof(flush_cmd_v2), &flush_cmd_v2);\n}\n\nvoid iwlagn_dev_txfifo_flush(struct iwl_priv *priv)\n{\n\tmutex_lock(&priv->mutex);\n\tieee80211_stop_queues(priv->hw);\n\tif (iwlagn_txfifo_flush(priv, 0)) {\n\t\tIWL_ERR(priv, \"flush request fail\\n\");\n\t\tgoto done;\n\t}\n\tIWL_DEBUG_INFO(priv, \"wait transmit/flush all frames\\n\");\n\tiwl_trans_wait_tx_queues_empty(priv->trans, 0xffffffff);\ndone:\n\tieee80211_wake_queues(priv->hw);\n\tmutex_unlock(&priv->mutex);\n}\n\n \n \nstatic const __le32 iwlagn_def_3w_lookup[IWLAGN_BT_DECISION_LUT_SIZE] = {\n\tcpu_to_le32(0xaaaaaaaa),\n\tcpu_to_le32(0xaaaaaaaa),\n\tcpu_to_le32(0xaeaaaaaa),\n\tcpu_to_le32(0xaaaaaaaa),\n\tcpu_to_le32(0xcc00ff28),\n\tcpu_to_le32(0x0000aaaa),\n\tcpu_to_le32(0xcc00aaaa),\n\tcpu_to_le32(0x0000aaaa),\n\tcpu_to_le32(0xc0004000),\n\tcpu_to_le32(0x00004000),\n\tcpu_to_le32(0xf0005000),\n\tcpu_to_le32(0xf0005000),\n};\n\n \nstatic const __le32 iwlagn_concurrent_lookup[IWLAGN_BT_DECISION_LUT_SIZE] = {\n\tcpu_to_le32(0xaaaaaaaa),\n\tcpu_to_le32(0xaaaaaaaa),\n\tcpu_to_le32(0xaaaaaaaa),\n\tcpu_to_le32(0xaaaaaaaa),\n\tcpu_to_le32(0xaaaaaaaa),\n\tcpu_to_le32(0xaaaaaaaa),\n\tcpu_to_le32(0xaaaaaaaa),\n\tcpu_to_le32(0xaaaaaaaa),\n\tcpu_to_le32(0x00000000),\n\tcpu_to_le32(0x00000000),\n\tcpu_to_le32(0x00000000),\n\tcpu_to_le32(0x00000000),\n};\n\nvoid iwlagn_send_advance_bt_config(struct iwl_priv *priv)\n{\n\tstruct iwl_basic_bt_cmd basic = {\n\t\t.max_kill = IWLAGN_BT_MAX_KILL_DEFAULT,\n\t\t.bt3_timer_t7_value = IWLAGN_BT3_T7_DEFAULT,\n\t\t.bt3_prio_sample_time = IWLAGN_BT3_PRIO_SAMPLE_DEFAULT,\n\t\t.bt3_timer_t2_value = IWLAGN_BT3_T2_DEFAULT,\n\t};\n\tstruct iwl_bt_cmd_v1 bt_cmd_v1;\n\tstruct iwl_bt_cmd_v2 bt_cmd_v2;\n\tint ret;\n\n\tBUILD_BUG_ON(sizeof(iwlagn_def_3w_lookup) !=\n\t\t\tsizeof(basic.bt3_lookup_table));\n\n\tif (priv->lib->bt_params) {\n\t\t \n\t\tif (priv->lib->bt_params->bt_session_2) {\n\t\t\tbt_cmd_v2.prio_boost = cpu_to_le32(\n\t\t\t\tpriv->lib->bt_params->bt_prio_boost);\n\t\t\tbt_cmd_v2.tx_prio_boost = 0;\n\t\t\tbt_cmd_v2.rx_prio_boost = 0;\n\t\t} else {\n\t\t\t \n\t\t\tWARN_ON(priv->lib->bt_params->bt_prio_boost & ~0xFF);\n\t\t\tbt_cmd_v1.prio_boost =\n\t\t\t\tpriv->lib->bt_params->bt_prio_boost;\n\t\t\tbt_cmd_v1.tx_prio_boost = 0;\n\t\t\tbt_cmd_v1.rx_prio_boost = 0;\n\t\t}\n\t} else {\n\t\tIWL_ERR(priv, \"failed to construct BT Coex Config\\n\");\n\t\treturn;\n\t}\n\n\t \n\tbasic.kill_ack_mask = priv->kill_ack_mask;\n\tbasic.kill_cts_mask = priv->kill_cts_mask;\n\tif (priv->reduced_txpower)\n\t\tbasic.reduce_txpower = IWLAGN_BT_REDUCED_TX_PWR;\n\tbasic.valid = priv->bt_valid;\n\n\t \n\tif (!iwlwifi_mod_params.bt_coex_active ||\n\t    priv->iw_mode == NL80211_IFTYPE_ADHOC) {\n\t\tbasic.flags = IWLAGN_BT_FLAG_COEX_MODE_DISABLED;\n\t} else {\n\t\tbasic.flags = IWLAGN_BT_FLAG_COEX_MODE_3W <<\n\t\t\t\t\tIWLAGN_BT_FLAG_COEX_MODE_SHIFT;\n\n\t\tif (!priv->bt_enable_pspoll)\n\t\t\tbasic.flags |= IWLAGN_BT_FLAG_SYNC_2_BT_DISABLE;\n\t\telse\n\t\t\tbasic.flags &= ~IWLAGN_BT_FLAG_SYNC_2_BT_DISABLE;\n\n\t\tif (priv->bt_ch_announce)\n\t\t\tbasic.flags |= IWLAGN_BT_FLAG_CHANNEL_INHIBITION;\n\t\tIWL_DEBUG_COEX(priv, \"BT coex flag: 0X%x\\n\", basic.flags);\n\t}\n\tpriv->bt_enable_flag = basic.flags;\n\tif (priv->bt_full_concurrent)\n\t\tmemcpy(basic.bt3_lookup_table, iwlagn_concurrent_lookup,\n\t\t\tsizeof(iwlagn_concurrent_lookup));\n\telse\n\t\tmemcpy(basic.bt3_lookup_table, iwlagn_def_3w_lookup,\n\t\t\tsizeof(iwlagn_def_3w_lookup));\n\n\tIWL_DEBUG_COEX(priv, \"BT coex %s in %s mode\\n\",\n\t\t       basic.flags ? \"active\" : \"disabled\",\n\t\t       priv->bt_full_concurrent ?\n\t\t       \"full concurrency\" : \"3-wire\");\n\n\tif (priv->lib->bt_params->bt_session_2) {\n\t\tmemcpy(&bt_cmd_v2.basic, &basic,\n\t\t\tsizeof(basic));\n\t\tret = iwl_dvm_send_cmd_pdu(priv, REPLY_BT_CONFIG,\n\t\t\t0, sizeof(bt_cmd_v2), &bt_cmd_v2);\n\t} else {\n\t\tmemcpy(&bt_cmd_v1.basic, &basic,\n\t\t\tsizeof(basic));\n\t\tret = iwl_dvm_send_cmd_pdu(priv, REPLY_BT_CONFIG,\n\t\t\t0, sizeof(bt_cmd_v1), &bt_cmd_v1);\n\t}\n\tif (ret)\n\t\tIWL_ERR(priv, \"failed to send BT Coex Config\\n\");\n\n}\n\nvoid iwlagn_bt_adjust_rssi_monitor(struct iwl_priv *priv, bool rssi_ena)\n{\n\tstruct iwl_rxon_context *ctx, *found_ctx = NULL;\n\tbool found_ap = false;\n\n\tlockdep_assert_held(&priv->mutex);\n\n\t \n\tif (rssi_ena) {\n\t\tfor_each_context(priv, ctx) {\n\t\t\tif (ctx->vif && ctx->vif->type == NL80211_IFTYPE_AP &&\n\t\t\t    iwl_is_associated_ctx(ctx)) {\n\t\t\t\tfound_ap = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (!rssi_ena || found_ap) {\n\t\tif (priv->cur_rssi_ctx) {\n\t\t\tctx = priv->cur_rssi_ctx;\n\t\t\tieee80211_disable_rssi_reports(ctx->vif);\n\t\t\tpriv->cur_rssi_ctx = NULL;\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tfor_each_context(priv, ctx) {\n\t\tif (ctx->vif && ctx->vif->type == NL80211_IFTYPE_STATION &&\n\t\t    iwl_is_associated_ctx(ctx)) {\n\t\t\tfound_ctx = ctx;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (found_ctx == priv->cur_rssi_ctx)\n\t\treturn;\n\n\t \n\tif (priv->cur_rssi_ctx) {\n\t\tctx = priv->cur_rssi_ctx;\n\t\tif (ctx->vif)\n\t\t\tieee80211_disable_rssi_reports(ctx->vif);\n\t}\n\n\tpriv->cur_rssi_ctx = found_ctx;\n\n\tif (!found_ctx)\n\t\treturn;\n\n\tieee80211_enable_rssi_reports(found_ctx->vif,\n\t\t\tIWLAGN_BT_PSP_MIN_RSSI_THRESHOLD,\n\t\t\tIWLAGN_BT_PSP_MAX_RSSI_THRESHOLD);\n}\n\nstatic bool iwlagn_bt_traffic_is_sco(struct iwl_bt_uart_msg *uart_msg)\n{\n\treturn (BT_UART_MSG_FRAME3SCOESCO_MSK & uart_msg->frame3) >>\n\t\tBT_UART_MSG_FRAME3SCOESCO_POS;\n}\n\nstatic void iwlagn_bt_traffic_change_work(struct work_struct *work)\n{\n\tstruct iwl_priv *priv =\n\t\tcontainer_of(work, struct iwl_priv, bt_traffic_change_work);\n\tstruct iwl_rxon_context *ctx;\n\tint smps_request = -1;\n\n\tif (priv->bt_enable_flag == IWLAGN_BT_FLAG_COEX_MODE_DISABLED) {\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tIWL_DEBUG_COEX(priv, \"BT traffic load changes: %d\\n\",\n\t\t       priv->bt_traffic_load);\n\n\tswitch (priv->bt_traffic_load) {\n\tcase IWL_BT_COEX_TRAFFIC_LOAD_NONE:\n\t\tif (priv->bt_status)\n\t\t\tsmps_request = IEEE80211_SMPS_DYNAMIC;\n\t\telse\n\t\t\tsmps_request = IEEE80211_SMPS_AUTOMATIC;\n\t\tbreak;\n\tcase IWL_BT_COEX_TRAFFIC_LOAD_LOW:\n\t\tsmps_request = IEEE80211_SMPS_DYNAMIC;\n\t\tbreak;\n\tcase IWL_BT_COEX_TRAFFIC_LOAD_HIGH:\n\tcase IWL_BT_COEX_TRAFFIC_LOAD_CONTINUOUS:\n\t\tsmps_request = IEEE80211_SMPS_STATIC;\n\t\tbreak;\n\tdefault:\n\t\tIWL_ERR(priv, \"Invalid BT traffic load: %d\\n\",\n\t\t\tpriv->bt_traffic_load);\n\t\tbreak;\n\t}\n\n\tmutex_lock(&priv->mutex);\n\n\t \n\tif (test_bit(STATUS_SCAN_HW, &priv->status))\n\t\tgoto out;\n\n\tiwl_update_chain_flags(priv);\n\n\tif (smps_request != -1) {\n\t\tpriv->current_ht_config.smps = smps_request;\n\t\tfor_each_context(priv, ctx) {\n\t\t\tif (ctx->vif && ctx->vif->type == NL80211_IFTYPE_STATION)\n\t\t\t\tieee80211_request_smps(ctx->vif, 0, smps_request);\n\t\t}\n\t}\n\n\t \n\tiwlagn_bt_coex_rssi_monitor(priv);\nout:\n\tmutex_unlock(&priv->mutex);\n}\n\n \nvoid iwlagn_bt_coex_rssi_monitor(struct iwl_priv *priv)\n{\n\tif (priv->bt_is_sco &&\n\t    priv->bt_traffic_load == IWL_BT_COEX_TRAFFIC_LOAD_CONTINUOUS)\n\t\tiwlagn_bt_adjust_rssi_monitor(priv, true);\n\telse\n\t\tiwlagn_bt_adjust_rssi_monitor(priv, false);\n}\n\nstatic void iwlagn_print_uartmsg(struct iwl_priv *priv,\n\t\t\t\tstruct iwl_bt_uart_msg *uart_msg)\n{\n\tIWL_DEBUG_COEX(priv, \"Message Type = 0x%X, SSN = 0x%X, \"\n\t\t\t\"Update Req = 0x%X\\n\",\n\t\t(BT_UART_MSG_FRAME1MSGTYPE_MSK & uart_msg->frame1) >>\n\t\t\tBT_UART_MSG_FRAME1MSGTYPE_POS,\n\t\t(BT_UART_MSG_FRAME1SSN_MSK & uart_msg->frame1) >>\n\t\t\tBT_UART_MSG_FRAME1SSN_POS,\n\t\t(BT_UART_MSG_FRAME1UPDATEREQ_MSK & uart_msg->frame1) >>\n\t\t\tBT_UART_MSG_FRAME1UPDATEREQ_POS);\n\n\tIWL_DEBUG_COEX(priv, \"Open connections = 0x%X, Traffic load = 0x%X, \"\n\t\t\t\"Chl_SeqN = 0x%X, In band = 0x%X\\n\",\n\t\t(BT_UART_MSG_FRAME2OPENCONNECTIONS_MSK & uart_msg->frame2) >>\n\t\t\tBT_UART_MSG_FRAME2OPENCONNECTIONS_POS,\n\t\t(BT_UART_MSG_FRAME2TRAFFICLOAD_MSK & uart_msg->frame2) >>\n\t\t\tBT_UART_MSG_FRAME2TRAFFICLOAD_POS,\n\t\t(BT_UART_MSG_FRAME2CHLSEQN_MSK & uart_msg->frame2) >>\n\t\t\tBT_UART_MSG_FRAME2CHLSEQN_POS,\n\t\t(BT_UART_MSG_FRAME2INBAND_MSK & uart_msg->frame2) >>\n\t\t\tBT_UART_MSG_FRAME2INBAND_POS);\n\n\tIWL_DEBUG_COEX(priv, \"SCO/eSCO = 0x%X, Sniff = 0x%X, A2DP = 0x%X, \"\n\t\t\t\"ACL = 0x%X, Master = 0x%X, OBEX = 0x%X\\n\",\n\t\t(BT_UART_MSG_FRAME3SCOESCO_MSK & uart_msg->frame3) >>\n\t\t\tBT_UART_MSG_FRAME3SCOESCO_POS,\n\t\t(BT_UART_MSG_FRAME3SNIFF_MSK & uart_msg->frame3) >>\n\t\t\tBT_UART_MSG_FRAME3SNIFF_POS,\n\t\t(BT_UART_MSG_FRAME3A2DP_MSK & uart_msg->frame3) >>\n\t\t\tBT_UART_MSG_FRAME3A2DP_POS,\n\t\t(BT_UART_MSG_FRAME3ACL_MSK & uart_msg->frame3) >>\n\t\t\tBT_UART_MSG_FRAME3ACL_POS,\n\t\t(BT_UART_MSG_FRAME3MASTER_MSK & uart_msg->frame3) >>\n\t\t\tBT_UART_MSG_FRAME3MASTER_POS,\n\t\t(BT_UART_MSG_FRAME3OBEX_MSK & uart_msg->frame3) >>\n\t\t\tBT_UART_MSG_FRAME3OBEX_POS);\n\n\tIWL_DEBUG_COEX(priv, \"Idle duration = 0x%X\\n\",\n\t\t(BT_UART_MSG_FRAME4IDLEDURATION_MSK & uart_msg->frame4) >>\n\t\t\tBT_UART_MSG_FRAME4IDLEDURATION_POS);\n\n\tIWL_DEBUG_COEX(priv, \"Tx Activity = 0x%X, Rx Activity = 0x%X, \"\n\t\t\t\"eSCO Retransmissions = 0x%X\\n\",\n\t\t(BT_UART_MSG_FRAME5TXACTIVITY_MSK & uart_msg->frame5) >>\n\t\t\tBT_UART_MSG_FRAME5TXACTIVITY_POS,\n\t\t(BT_UART_MSG_FRAME5RXACTIVITY_MSK & uart_msg->frame5) >>\n\t\t\tBT_UART_MSG_FRAME5RXACTIVITY_POS,\n\t\t(BT_UART_MSG_FRAME5ESCORETRANSMIT_MSK & uart_msg->frame5) >>\n\t\t\tBT_UART_MSG_FRAME5ESCORETRANSMIT_POS);\n\n\tIWL_DEBUG_COEX(priv, \"Sniff Interval = 0x%X, Discoverable = 0x%X\\n\",\n\t\t(BT_UART_MSG_FRAME6SNIFFINTERVAL_MSK & uart_msg->frame6) >>\n\t\t\tBT_UART_MSG_FRAME6SNIFFINTERVAL_POS,\n\t\t(BT_UART_MSG_FRAME6DISCOVERABLE_MSK & uart_msg->frame6) >>\n\t\t\tBT_UART_MSG_FRAME6DISCOVERABLE_POS);\n\n\tIWL_DEBUG_COEX(priv, \"Sniff Activity = 0x%X, Page = \"\n\t\t\t\"0x%X, Inquiry = 0x%X, Connectable = 0x%X\\n\",\n\t\t(BT_UART_MSG_FRAME7SNIFFACTIVITY_MSK & uart_msg->frame7) >>\n\t\t\tBT_UART_MSG_FRAME7SNIFFACTIVITY_POS,\n\t\t(BT_UART_MSG_FRAME7PAGE_MSK & uart_msg->frame7) >>\n\t\t\tBT_UART_MSG_FRAME7PAGE_POS,\n\t\t(BT_UART_MSG_FRAME7INQUIRY_MSK & uart_msg->frame7) >>\n\t\t\tBT_UART_MSG_FRAME7INQUIRY_POS,\n\t\t(BT_UART_MSG_FRAME7CONNECTABLE_MSK & uart_msg->frame7) >>\n\t\t\tBT_UART_MSG_FRAME7CONNECTABLE_POS);\n}\n\nstatic bool iwlagn_set_kill_msk(struct iwl_priv *priv,\n\t\t\t\tstruct iwl_bt_uart_msg *uart_msg)\n{\n\tbool need_update = false;\n\tu8 kill_msk = IWL_BT_KILL_REDUCE;\n\tstatic const __le32 bt_kill_ack_msg[3] = {\n\t\tIWLAGN_BT_KILL_ACK_MASK_DEFAULT,\n\t\tIWLAGN_BT_KILL_ACK_CTS_MASK_SCO,\n\t\tIWLAGN_BT_KILL_ACK_CTS_MASK_REDUCE};\n\tstatic const __le32 bt_kill_cts_msg[3] = {\n\t\tIWLAGN_BT_KILL_CTS_MASK_DEFAULT,\n\t\tIWLAGN_BT_KILL_ACK_CTS_MASK_SCO,\n\t\tIWLAGN_BT_KILL_ACK_CTS_MASK_REDUCE};\n\n\tif (!priv->reduced_txpower)\n\t\tkill_msk = (BT_UART_MSG_FRAME3SCOESCO_MSK & uart_msg->frame3)\n\t\t\t? IWL_BT_KILL_OVERRIDE : IWL_BT_KILL_DEFAULT;\n\tif (priv->kill_ack_mask != bt_kill_ack_msg[kill_msk] ||\n\t    priv->kill_cts_mask != bt_kill_cts_msg[kill_msk]) {\n\t\tpriv->bt_valid |= IWLAGN_BT_VALID_KILL_ACK_MASK;\n\t\tpriv->kill_ack_mask = bt_kill_ack_msg[kill_msk];\n\t\tpriv->bt_valid |= IWLAGN_BT_VALID_KILL_CTS_MASK;\n\t\tpriv->kill_cts_mask = bt_kill_cts_msg[kill_msk];\n\t\tneed_update = true;\n\t}\n\treturn need_update;\n}\n\n \nstatic bool iwlagn_fill_txpower_mode(struct iwl_priv *priv,\n\t\t\t\tstruct iwl_bt_uart_msg *uart_msg)\n{\n\tbool need_update = false;\n\tstruct iwl_rxon_context *ctx = &priv->contexts[IWL_RXON_CTX_BSS];\n\tint ave_rssi;\n\n\tif (!ctx->vif || (ctx->vif->type != NL80211_IFTYPE_STATION)) {\n\t\tIWL_DEBUG_INFO(priv, \"BSS ctx not active or not in sta mode\\n\");\n\t\treturn false;\n\t}\n\n\tave_rssi = ieee80211_ave_rssi(ctx->vif);\n\tif (!ave_rssi) {\n\t\t \n\t\tIWL_DEBUG_COEX(priv, \"no rssi data available\\n\");\n\t\treturn need_update;\n\t}\n\tif (!priv->reduced_txpower &&\n\t    !iwl_is_associated(priv, IWL_RXON_CTX_PAN) &&\n\t    (ave_rssi > BT_ENABLE_REDUCED_TXPOWER_THRESHOLD) &&\n\t    (uart_msg->frame3 & (BT_UART_MSG_FRAME3ACL_MSK |\n\t    BT_UART_MSG_FRAME3OBEX_MSK)) &&\n\t    !(uart_msg->frame3 & (BT_UART_MSG_FRAME3SCOESCO_MSK |\n\t    BT_UART_MSG_FRAME3SNIFF_MSK | BT_UART_MSG_FRAME3A2DP_MSK))) {\n\t\t \n\t\tpriv->reduced_txpower = true;\n\t\tpriv->bt_valid |= IWLAGN_BT_VALID_REDUCED_TX_PWR;\n\t\tneed_update = true;\n\t} else if (priv->reduced_txpower &&\n\t\t   (iwl_is_associated(priv, IWL_RXON_CTX_PAN) ||\n\t\t   (ave_rssi < BT_DISABLE_REDUCED_TXPOWER_THRESHOLD) ||\n\t\t   (uart_msg->frame3 & (BT_UART_MSG_FRAME3SCOESCO_MSK |\n\t\t   BT_UART_MSG_FRAME3SNIFF_MSK | BT_UART_MSG_FRAME3A2DP_MSK)) ||\n\t\t   !(uart_msg->frame3 & (BT_UART_MSG_FRAME3ACL_MSK |\n\t\t   BT_UART_MSG_FRAME3OBEX_MSK)))) {\n\t\t \n\t\tpriv->reduced_txpower = false;\n\t\tpriv->bt_valid |= IWLAGN_BT_VALID_REDUCED_TX_PWR;\n\t\tneed_update = true;\n\t}\n\n\treturn need_update;\n}\n\nstatic void iwlagn_bt_coex_profile_notif(struct iwl_priv *priv,\n\t\t\t\t\t struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_bt_coex_profile_notif *coex = (void *)pkt->data;\n\tstruct iwl_bt_uart_msg *uart_msg = &coex->last_bt_uart_msg;\n\n\tif (priv->bt_enable_flag == IWLAGN_BT_FLAG_COEX_MODE_DISABLED) {\n\t\t \n\t\treturn;\n\t}\n\n\tIWL_DEBUG_COEX(priv, \"BT Coex notification:\\n\");\n\tIWL_DEBUG_COEX(priv, \"    status: %d\\n\", coex->bt_status);\n\tIWL_DEBUG_COEX(priv, \"    traffic load: %d\\n\", coex->bt_traffic_load);\n\tIWL_DEBUG_COEX(priv, \"    CI compliance: %d\\n\",\n\t\t\tcoex->bt_ci_compliance);\n\tiwlagn_print_uartmsg(priv, uart_msg);\n\n\tpriv->last_bt_traffic_load = priv->bt_traffic_load;\n\tpriv->bt_is_sco = iwlagn_bt_traffic_is_sco(uart_msg);\n\n\tif (priv->iw_mode != NL80211_IFTYPE_ADHOC) {\n\t\tif (priv->bt_status != coex->bt_status ||\n\t\t    priv->last_bt_traffic_load != coex->bt_traffic_load) {\n\t\t\tif (coex->bt_status) {\n\t\t\t\t \n\t\t\t\tif (!priv->bt_ch_announce)\n\t\t\t\t\tpriv->bt_traffic_load =\n\t\t\t\t\t\tIWL_BT_COEX_TRAFFIC_LOAD_HIGH;\n\t\t\t\telse\n\t\t\t\t\tpriv->bt_traffic_load =\n\t\t\t\t\t\tcoex->bt_traffic_load;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tpriv->bt_traffic_load =\n\t\t\t\t\tIWL_BT_COEX_TRAFFIC_LOAD_NONE;\n\t\t\t}\n\t\t\tpriv->bt_status = coex->bt_status;\n\t\t\tqueue_work(priv->workqueue,\n\t\t\t\t   &priv->bt_traffic_change_work);\n\t\t}\n\t}\n\n\t \n\t \n\tif (iwlagn_fill_txpower_mode(priv, uart_msg) ||\n\t    iwlagn_set_kill_msk(priv, uart_msg))\n\t\tqueue_work(priv->workqueue, &priv->bt_runtime_config);\n\n\n\t \n\n\tpriv->bt_ci_compliance = coex->bt_ci_compliance;\n}\n\nvoid iwlagn_bt_rx_handler_setup(struct iwl_priv *priv)\n{\n\tpriv->rx_handlers[REPLY_BT_COEX_PROFILE_NOTIF] =\n\t\tiwlagn_bt_coex_profile_notif;\n}\n\nvoid iwlagn_bt_setup_deferred_work(struct iwl_priv *priv)\n{\n\tINIT_WORK(&priv->bt_traffic_change_work,\n\t\t  iwlagn_bt_traffic_change_work);\n}\n\nvoid iwlagn_bt_cancel_deferred_work(struct iwl_priv *priv)\n{\n\tcancel_work_sync(&priv->bt_traffic_change_work);\n}\n\nstatic bool is_single_rx_stream(struct iwl_priv *priv)\n{\n\treturn priv->current_ht_config.smps == IEEE80211_SMPS_STATIC ||\n\t       priv->current_ht_config.single_chain_sufficient;\n}\n\n#define IWL_NUM_RX_CHAINS_MULTIPLE\t3\n#define IWL_NUM_RX_CHAINS_SINGLE\t2\n#define IWL_NUM_IDLE_CHAINS_DUAL\t2\n#define IWL_NUM_IDLE_CHAINS_SINGLE\t1\n\n \nstatic int iwl_get_active_rx_chain_count(struct iwl_priv *priv)\n{\n\tif (priv->lib->bt_params &&\n\t    priv->lib->bt_params->advanced_bt_coexist &&\n\t    (priv->bt_full_concurrent ||\n\t     priv->bt_traffic_load >= IWL_BT_COEX_TRAFFIC_LOAD_HIGH)) {\n\t\t \n\t\treturn IWL_NUM_RX_CHAINS_SINGLE;\n\t}\n\t \n\tif (is_single_rx_stream(priv))\n\t\treturn IWL_NUM_RX_CHAINS_SINGLE;\n\telse\n\t\treturn IWL_NUM_RX_CHAINS_MULTIPLE;\n}\n\n \nstatic int iwl_get_idle_rx_chain_count(struct iwl_priv *priv, int active_cnt)\n{\n\t \n\tswitch (priv->current_ht_config.smps) {\n\tcase IEEE80211_SMPS_STATIC:\n\tcase IEEE80211_SMPS_DYNAMIC:\n\t\treturn IWL_NUM_IDLE_CHAINS_SINGLE;\n\tcase IEEE80211_SMPS_AUTOMATIC:\n\tcase IEEE80211_SMPS_OFF:\n\t\treturn active_cnt;\n\tdefault:\n\t\tWARN(1, \"invalid SMPS mode %d\",\n\t\t     priv->current_ht_config.smps);\n\t\treturn active_cnt;\n\t}\n}\n\n \nstatic u8 iwl_count_chain_bitmap(u32 chain_bitmap)\n{\n\tu8 res;\n\tres = (chain_bitmap & BIT(0)) >> 0;\n\tres += (chain_bitmap & BIT(1)) >> 1;\n\tres += (chain_bitmap & BIT(2)) >> 2;\n\tres += (chain_bitmap & BIT(3)) >> 3;\n\treturn res;\n}\n\n \nvoid iwlagn_set_rxon_chain(struct iwl_priv *priv, struct iwl_rxon_context *ctx)\n{\n\tbool is_single = is_single_rx_stream(priv);\n\tbool is_cam = !test_bit(STATUS_POWER_PMI, &priv->status);\n\tu8 idle_rx_cnt, active_rx_cnt, valid_rx_cnt;\n\tu32 active_chains;\n\tu16 rx_chain;\n\n\t \n\tif (priv->chain_noise_data.active_chains)\n\t\tactive_chains = priv->chain_noise_data.active_chains;\n\telse\n\t\tactive_chains = priv->nvm_data->valid_rx_ant;\n\n\tif (priv->lib->bt_params &&\n\t    priv->lib->bt_params->advanced_bt_coexist &&\n\t    (priv->bt_full_concurrent ||\n\t     priv->bt_traffic_load >= IWL_BT_COEX_TRAFFIC_LOAD_HIGH)) {\n\t\t \n\t\tactive_chains = first_antenna(active_chains);\n\t}\n\n\trx_chain = active_chains << RXON_RX_CHAIN_VALID_POS;\n\n\t \n\tactive_rx_cnt = iwl_get_active_rx_chain_count(priv);\n\tidle_rx_cnt = iwl_get_idle_rx_chain_count(priv, active_rx_cnt);\n\n\n\t \n\tvalid_rx_cnt = iwl_count_chain_bitmap(active_chains);\n\tif (valid_rx_cnt < active_rx_cnt)\n\t\tactive_rx_cnt = valid_rx_cnt;\n\n\tif (valid_rx_cnt < idle_rx_cnt)\n\t\tidle_rx_cnt = valid_rx_cnt;\n\n\trx_chain |= active_rx_cnt << RXON_RX_CHAIN_MIMO_CNT_POS;\n\trx_chain |= idle_rx_cnt  << RXON_RX_CHAIN_CNT_POS;\n\n\tctx->staging.rx_chain = cpu_to_le16(rx_chain);\n\n\tif (!is_single && (active_rx_cnt >= IWL_NUM_RX_CHAINS_SINGLE) && is_cam)\n\t\tctx->staging.rx_chain |= RXON_RX_CHAIN_MIMO_FORCE_MSK;\n\telse\n\t\tctx->staging.rx_chain &= ~RXON_RX_CHAIN_MIMO_FORCE_MSK;\n\n\tIWL_DEBUG_ASSOC(priv, \"rx_chain=0x%X active=%d idle=%d\\n\",\n\t\t\tctx->staging.rx_chain,\n\t\t\tactive_rx_cnt, idle_rx_cnt);\n\n\tWARN_ON(active_rx_cnt == 0 || idle_rx_cnt == 0 ||\n\t\tactive_rx_cnt < idle_rx_cnt);\n}\n\nu8 iwl_toggle_tx_ant(struct iwl_priv *priv, u8 ant, u8 valid)\n{\n\tint i;\n\tu8 ind = ant;\n\n\tif (priv->band == NL80211_BAND_2GHZ &&\n\t    priv->bt_traffic_load >= IWL_BT_COEX_TRAFFIC_LOAD_HIGH)\n\t\treturn 0;\n\n\tfor (i = 0; i < RATE_ANT_NUM - 1; i++) {\n\t\tind = (ind + 1) < RATE_ANT_NUM ?  ind + 1 : 0;\n\t\tif (valid & BIT(ind))\n\t\t\treturn ind;\n\t}\n\treturn ant;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic void iwlagn_convert_p1k(u16 *p1k, __le16 *out)\n{\n\tint i;\n\n\tfor (i = 0; i < IWLAGN_P1K_SIZE; i++)\n\t\tout[i] = cpu_to_le16(p1k[i]);\n}\n\nstruct wowlan_key_data {\n\tstruct iwl_rxon_context *ctx;\n\tstruct iwlagn_wowlan_rsc_tsc_params_cmd *rsc_tsc;\n\tstruct iwlagn_wowlan_tkip_params_cmd *tkip;\n\tconst u8 *bssid;\n\tbool error, use_rsc_tsc, use_tkip;\n};\n\n\nstatic void iwlagn_wowlan_program_keys(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_sta *sta,\n\t\t\t       struct ieee80211_key_conf *key,\n\t\t\t       void *_data)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\tstruct wowlan_key_data *data = _data;\n\tstruct iwl_rxon_context *ctx = data->ctx;\n\tstruct aes_sc *aes_sc, *aes_tx_sc = NULL;\n\tstruct tkip_sc *tkip_sc, *tkip_tx_sc = NULL;\n\tstruct iwlagn_p1k_cache *rx_p1ks;\n\tu8 *rx_mic_key;\n\tstruct ieee80211_key_seq seq;\n\tu32 cur_rx_iv32 = 0;\n\tu16 p1k[IWLAGN_P1K_SIZE];\n\tint ret, i;\n\n\tmutex_lock(&priv->mutex);\n\n\tif ((key->cipher == WLAN_CIPHER_SUITE_WEP40 ||\n\t     key->cipher == WLAN_CIPHER_SUITE_WEP104) &&\n\t     !sta && !ctx->key_mapping_keys)\n\t\tret = iwl_set_default_wep_key(priv, ctx, key);\n\telse\n\t\tret = iwl_set_dynamic_key(priv, ctx, key, sta);\n\n\tif (ret) {\n\t\tIWL_ERR(priv, \"Error setting key during suspend!\\n\");\n\t\tdata->error = true;\n\t}\n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tif (sta) {\n\t\t\tu64 pn64;\n\n\t\t\ttkip_sc = data->rsc_tsc->all_tsc_rsc.tkip.unicast_rsc;\n\t\t\ttkip_tx_sc = &data->rsc_tsc->all_tsc_rsc.tkip.tsc;\n\n\t\t\trx_p1ks = data->tkip->rx_uni;\n\n\t\t\tpn64 = atomic64_read(&key->tx_pn);\n\t\t\ttkip_tx_sc->iv16 = cpu_to_le16(TKIP_PN_TO_IV16(pn64));\n\t\t\ttkip_tx_sc->iv32 = cpu_to_le32(TKIP_PN_TO_IV32(pn64));\n\n\t\t\tieee80211_get_tkip_p1k_iv(key, seq.tkip.iv32, p1k);\n\t\t\tiwlagn_convert_p1k(p1k, data->tkip->tx.p1k);\n\n\t\t\tmemcpy(data->tkip->mic_keys.tx,\n\t\t\t       &key->key[NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY],\n\t\t\t       IWLAGN_MIC_KEY_SIZE);\n\n\t\t\trx_mic_key = data->tkip->mic_keys.rx_unicast;\n\t\t} else {\n\t\t\ttkip_sc =\n\t\t\t\tdata->rsc_tsc->all_tsc_rsc.tkip.multicast_rsc;\n\t\t\trx_p1ks = data->tkip->rx_multi;\n\t\t\trx_mic_key = data->tkip->mic_keys.rx_mcast;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < IWLAGN_NUM_RSC; i++) {\n\t\t\tieee80211_get_key_rx_seq(key, i, &seq);\n\t\t\ttkip_sc[i].iv16 = cpu_to_le16(seq.tkip.iv16);\n\t\t\ttkip_sc[i].iv32 = cpu_to_le32(seq.tkip.iv32);\n\t\t\t \n\t\t\tif (seq.tkip.iv32 > cur_rx_iv32)\n\t\t\t\tcur_rx_iv32 = seq.tkip.iv32;\n\t\t}\n\n\t\tieee80211_get_tkip_rx_p1k(key, data->bssid, cur_rx_iv32, p1k);\n\t\tiwlagn_convert_p1k(p1k, rx_p1ks[0].p1k);\n\t\tieee80211_get_tkip_rx_p1k(key, data->bssid,\n\t\t\t\t\t  cur_rx_iv32 + 1, p1k);\n\t\tiwlagn_convert_p1k(p1k, rx_p1ks[1].p1k);\n\n\t\tmemcpy(rx_mic_key,\n\t\t       &key->key[NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY],\n\t\t       IWLAGN_MIC_KEY_SIZE);\n\n\t\tdata->use_tkip = true;\n\t\tdata->use_rsc_tsc = true;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tif (sta) {\n\t\t\tu64 pn64;\n\n\t\t\taes_sc = data->rsc_tsc->all_tsc_rsc.aes.unicast_rsc;\n\t\t\taes_tx_sc = &data->rsc_tsc->all_tsc_rsc.aes.tsc;\n\n\t\t\tpn64 = atomic64_read(&key->tx_pn);\n\t\t\taes_tx_sc->pn = cpu_to_le64(pn64);\n\t\t} else\n\t\t\taes_sc = data->rsc_tsc->all_tsc_rsc.aes.multicast_rsc;\n\n\t\t \n\t\tfor (i = 0; i < IWLAGN_NUM_RSC; i++) {\n\t\t\tu8 *pn = seq.ccmp.pn;\n\n\t\t\tieee80211_get_key_rx_seq(key, i, &seq);\n\t\t\taes_sc[i].pn = cpu_to_le64(\n\t\t\t\t\t(u64)pn[5] |\n\t\t\t\t\t((u64)pn[4] << 8) |\n\t\t\t\t\t((u64)pn[3] << 16) |\n\t\t\t\t\t((u64)pn[2] << 24) |\n\t\t\t\t\t((u64)pn[1] << 32) |\n\t\t\t\t\t((u64)pn[0] << 40));\n\t\t}\n\t\tdata->use_rsc_tsc = true;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&priv->mutex);\n}\n\nint iwlagn_send_patterns(struct iwl_priv *priv,\n\t\t\tstruct cfg80211_wowlan *wowlan)\n{\n\tstruct iwlagn_wowlan_patterns_cmd *pattern_cmd;\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = REPLY_WOWLAN_PATTERNS,\n\t\t.dataflags[0] = IWL_HCMD_DFL_NOCOPY,\n\t};\n\tint i, err;\n\n\tif (!wowlan->n_patterns)\n\t\treturn 0;\n\n\tcmd.len[0] = struct_size(pattern_cmd, patterns, wowlan->n_patterns);\n\n\tpattern_cmd = kmalloc(cmd.len[0], GFP_KERNEL);\n\tif (!pattern_cmd)\n\t\treturn -ENOMEM;\n\n\tpattern_cmd->n_patterns = cpu_to_le32(wowlan->n_patterns);\n\n\tfor (i = 0; i < wowlan->n_patterns; i++) {\n\t\tint mask_len = DIV_ROUND_UP(wowlan->patterns[i].pattern_len, 8);\n\n\t\tmemcpy(&pattern_cmd->patterns[i].mask,\n\t\t\twowlan->patterns[i].mask, mask_len);\n\t\tmemcpy(&pattern_cmd->patterns[i].pattern,\n\t\t\twowlan->patterns[i].pattern,\n\t\t\twowlan->patterns[i].pattern_len);\n\t\tpattern_cmd->patterns[i].mask_size = mask_len;\n\t\tpattern_cmd->patterns[i].pattern_size =\n\t\t\twowlan->patterns[i].pattern_len;\n\t}\n\n\tcmd.data[0] = pattern_cmd;\n\terr = iwl_dvm_send_cmd(priv, &cmd);\n\tkfree(pattern_cmd);\n\treturn err;\n}\n\nint iwlagn_suspend(struct iwl_priv *priv, struct cfg80211_wowlan *wowlan)\n{\n\tstruct iwlagn_wowlan_wakeup_filter_cmd wakeup_filter_cmd;\n\tstruct iwl_rxon_cmd rxon;\n\tstruct iwl_rxon_context *ctx = &priv->contexts[IWL_RXON_CTX_BSS];\n\tstruct iwlagn_wowlan_kek_kck_material_cmd kek_kck_cmd;\n\tstruct iwlagn_wowlan_tkip_params_cmd tkip_cmd = {};\n\tstruct iwlagn_d3_config_cmd d3_cfg_cmd = {\n\t\t \n\t\t.min_sleep_time = cpu_to_le32(10 * 1000 * 1000),\n\t};\n\tstruct wowlan_key_data key_data = {\n\t\t.ctx = ctx,\n\t\t.bssid = ctx->active.bssid_addr,\n\t\t.use_rsc_tsc = false,\n\t\t.tkip = &tkip_cmd,\n\t\t.use_tkip = false,\n\t};\n\tint ret, i;\n\tu16 seq;\n\n\tkey_data.rsc_tsc = kzalloc(sizeof(*key_data.rsc_tsc), GFP_KERNEL);\n\tif (!key_data.rsc_tsc)\n\t\treturn -ENOMEM;\n\n\tmemset(&wakeup_filter_cmd, 0, sizeof(wakeup_filter_cmd));\n\n\t \n\tseq = le16_to_cpu(priv->last_seq_ctl) & IEEE80211_SCTL_SEQ;\n\twakeup_filter_cmd.non_qos_seq = cpu_to_le16(seq);\n\n\t \n\tfor (i = 0; i < IWL_MAX_TID_COUNT; i++) {\n\t\tseq = priv->tid_data[IWL_AP_ID][i].seq_number;\n\t\tseq -= 0x10;\n\t\twakeup_filter_cmd.qos_seq[i] = cpu_to_le16(seq);\n\t}\n\n\tif (wowlan->disconnect)\n\t\twakeup_filter_cmd.enabled |=\n\t\t\tcpu_to_le32(IWLAGN_WOWLAN_WAKEUP_BEACON_MISS |\n\t\t\t\t    IWLAGN_WOWLAN_WAKEUP_LINK_CHANGE);\n\tif (wowlan->magic_pkt)\n\t\twakeup_filter_cmd.enabled |=\n\t\t\tcpu_to_le32(IWLAGN_WOWLAN_WAKEUP_MAGIC_PACKET);\n\tif (wowlan->gtk_rekey_failure)\n\t\twakeup_filter_cmd.enabled |=\n\t\t\tcpu_to_le32(IWLAGN_WOWLAN_WAKEUP_GTK_REKEY_FAIL);\n\tif (wowlan->eap_identity_req)\n\t\twakeup_filter_cmd.enabled |=\n\t\t\tcpu_to_le32(IWLAGN_WOWLAN_WAKEUP_EAP_IDENT_REQ);\n\tif (wowlan->four_way_handshake)\n\t\twakeup_filter_cmd.enabled |=\n\t\t\tcpu_to_le32(IWLAGN_WOWLAN_WAKEUP_4WAY_HANDSHAKE);\n\tif (wowlan->n_patterns)\n\t\twakeup_filter_cmd.enabled |=\n\t\t\tcpu_to_le32(IWLAGN_WOWLAN_WAKEUP_PATTERN_MATCH);\n\n\tif (wowlan->rfkill_release)\n\t\td3_cfg_cmd.wakeup_flags |=\n\t\t\tcpu_to_le32(IWLAGN_D3_WAKEUP_RFKILL);\n\n\tiwl_scan_cancel_timeout(priv, 200);\n\n\tmemcpy(&rxon, &ctx->active, sizeof(rxon));\n\n\tpriv->ucode_loaded = false;\n\tiwl_trans_stop_device(priv->trans);\n\tret = iwl_trans_start_hw(priv->trans);\n\tif (ret)\n\t\tgoto out;\n\n\tpriv->wowlan = true;\n\n\tret = iwl_load_ucode_wait_alive(priv, IWL_UCODE_WOWLAN);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = iwl_alive_start(priv);\n\tif (ret)\n\t\tgoto out;\n\n\tmemcpy(&ctx->staging, &rxon, sizeof(rxon));\n\tret = iwlagn_commit_rxon(priv, ctx);\n\tif (ret)\n\t\tgoto out;\n\n\tret = iwl_power_update_mode(priv, true);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!iwlwifi_mod_params.swcrypto) {\n\t\t \n\t\tpriv->ucode_key_table = 0;\n\t\tctx->key_mapping_keys = 0;\n\n\t\t \n\t\tmutex_unlock(&priv->mutex);\n\t\tieee80211_iter_keys(priv->hw, ctx->vif,\n\t\t\t\t    iwlagn_wowlan_program_keys,\n\t\t\t\t    &key_data);\n\t\tmutex_lock(&priv->mutex);\n\t\tif (key_data.error) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (key_data.use_rsc_tsc) {\n\t\t\tstruct iwl_host_cmd rsc_tsc_cmd = {\n\t\t\t\t.id = REPLY_WOWLAN_TSC_RSC_PARAMS,\n\t\t\t\t.data[0] = key_data.rsc_tsc,\n\t\t\t\t.dataflags[0] = IWL_HCMD_DFL_NOCOPY,\n\t\t\t\t.len[0] = sizeof(*key_data.rsc_tsc),\n\t\t\t};\n\n\t\t\tret = iwl_dvm_send_cmd(priv, &rsc_tsc_cmd);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (key_data.use_tkip) {\n\t\t\tret = iwl_dvm_send_cmd_pdu(priv,\n\t\t\t\t\t\t REPLY_WOWLAN_TKIP_PARAMS,\n\t\t\t\t\t\t 0, sizeof(tkip_cmd),\n\t\t\t\t\t\t &tkip_cmd);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (priv->have_rekey_data) {\n\t\t\tmemset(&kek_kck_cmd, 0, sizeof(kek_kck_cmd));\n\t\t\tmemcpy(kek_kck_cmd.kck, priv->kck, NL80211_KCK_LEN);\n\t\t\tkek_kck_cmd.kck_len = cpu_to_le16(NL80211_KCK_LEN);\n\t\t\tmemcpy(kek_kck_cmd.kek, priv->kek, NL80211_KEK_LEN);\n\t\t\tkek_kck_cmd.kek_len = cpu_to_le16(NL80211_KEK_LEN);\n\t\t\tkek_kck_cmd.replay_ctr = priv->replay_ctr;\n\n\t\t\tret = iwl_dvm_send_cmd_pdu(priv,\n\t\t\t\t\t\t REPLY_WOWLAN_KEK_KCK_MATERIAL,\n\t\t\t\t\t\t 0, sizeof(kek_kck_cmd),\n\t\t\t\t\t\t &kek_kck_cmd);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = iwl_dvm_send_cmd_pdu(priv, REPLY_D3_CONFIG, 0,\n\t\t\t\t     sizeof(d3_cfg_cmd), &d3_cfg_cmd);\n\tif (ret)\n\t\tgoto out;\n\n\tret = iwl_dvm_send_cmd_pdu(priv, REPLY_WOWLAN_WAKEUP_FILTER,\n\t\t\t\t 0, sizeof(wakeup_filter_cmd),\n\t\t\t\t &wakeup_filter_cmd);\n\tif (ret)\n\t\tgoto out;\n\n\tret = iwlagn_send_patterns(priv, wowlan);\n out:\n\tkfree(key_data.rsc_tsc);\n\treturn ret;\n}\n#endif\n\nint iwl_dvm_send_cmd(struct iwl_priv *priv, struct iwl_host_cmd *cmd)\n{\n\tif (iwl_is_rfkill(priv) || iwl_is_ctkill(priv)) {\n\t\tIWL_WARN(priv, \"Not sending command - %s KILL\\n\",\n\t\t\t iwl_is_rfkill(priv) ? \"RF\" : \"CT\");\n\t\treturn -EIO;\n\t}\n\n\tif (test_bit(STATUS_FW_ERROR, &priv->status)) {\n\t\tIWL_ERR(priv, \"Command %s failed: FW Error\\n\",\n\t\t\tiwl_get_cmd_string(priv->trans, cmd->id));\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (!priv->ucode_loaded) {\n\t\tIWL_ERR(priv, \"Fw not loaded - dropping CMD: %x\\n\", cmd->id);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (!(cmd->flags & CMD_ASYNC))\n\t\tlockdep_assert_held(&priv->mutex);\n\n\treturn iwl_trans_send_cmd(priv->trans, cmd);\n}\n\nint iwl_dvm_send_cmd_pdu(struct iwl_priv *priv, u8 id,\n\t\t\t u32 flags, u16 len, const void *data)\n{\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = id,\n\t\t.len = { len, },\n\t\t.data = { data, },\n\t\t.flags = flags,\n\t};\n\n\treturn iwl_dvm_send_cmd(priv, &cmd);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}