{
  "module_name": "rxon.c",
  "hash_id": "5be4598e2f6b08ab81dd74c54afaef8545f12c6eaf96bd37a69ad757a4e27651",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/dvm/rxon.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include \"iwl-trans.h\"\n#include \"iwl-modparams.h\"\n#include \"dev.h\"\n#include \"agn.h\"\n#include \"calib.h\"\n\n \nvoid iwl_connection_init_rx_config(struct iwl_priv *priv,\n\t\t\t\t   struct iwl_rxon_context *ctx)\n{\n\tmemset(&ctx->staging, 0, sizeof(ctx->staging));\n\n\tif (!ctx->vif) {\n\t\tctx->staging.dev_type = ctx->unused_devtype;\n\t} else\n\tswitch (ctx->vif->type) {\n\tcase NL80211_IFTYPE_AP:\n\t\tctx->staging.dev_type = ctx->ap_devtype;\n\t\tbreak;\n\n\tcase NL80211_IFTYPE_STATION:\n\t\tctx->staging.dev_type = ctx->station_devtype;\n\t\tctx->staging.filter_flags = RXON_FILTER_ACCEPT_GRP_MSK;\n\t\tbreak;\n\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tctx->staging.dev_type = ctx->ibss_devtype;\n\t\tctx->staging.flags = RXON_FLG_SHORT_PREAMBLE_MSK;\n\t\tctx->staging.filter_flags = RXON_FILTER_BCON_AWARE_MSK |\n\t\t\t\t\t\t  RXON_FILTER_ACCEPT_GRP_MSK;\n\t\tbreak;\n\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tctx->staging.dev_type = RXON_DEV_TYPE_SNIFFER;\n\t\tbreak;\n\n\tdefault:\n\t\tIWL_ERR(priv, \"Unsupported interface type %d\\n\",\n\t\t\tctx->vif->type);\n\t\tbreak;\n\t}\n\n#if 0\n\t \n\tif (!hw_to_local(priv->hw)->short_preamble)\n\t\tctx->staging.flags &= ~RXON_FLG_SHORT_PREAMBLE_MSK;\n\telse\n\t\tctx->staging.flags |= RXON_FLG_SHORT_PREAMBLE_MSK;\n#endif\n\n\tctx->staging.channel =\n\t\tcpu_to_le16(priv->hw->conf.chandef.chan->hw_value);\n\tpriv->band = priv->hw->conf.chandef.chan->band;\n\n\tiwl_set_flags_for_band(priv, ctx, priv->band, ctx->vif);\n\n\t \n\tctx->staging.flags &= ~(RXON_FLG_CHANNEL_MODE_MIXED |\n\t\t\t\t\tRXON_FLG_CHANNEL_MODE_PURE_40);\n\tif (ctx->vif)\n\t\tmemcpy(ctx->staging.node_addr, ctx->vif->addr, ETH_ALEN);\n\n\tctx->staging.ofdm_ht_single_stream_basic_rates = 0xff;\n\tctx->staging.ofdm_ht_dual_stream_basic_rates = 0xff;\n\tctx->staging.ofdm_ht_triple_stream_basic_rates = 0xff;\n}\n\nstatic int iwlagn_disable_bss(struct iwl_priv *priv,\n\t\t\t      struct iwl_rxon_context *ctx,\n\t\t\t      struct iwl_rxon_cmd *send)\n{\n\t__le32 old_filter = send->filter_flags;\n\tint ret;\n\n\tsend->filter_flags &= ~RXON_FILTER_ASSOC_MSK;\n\tret = iwl_dvm_send_cmd_pdu(priv, ctx->rxon_cmd,\n\t\t\t\t0, sizeof(*send), send);\n\n\tsend->filter_flags = old_filter;\n\n\tif (ret)\n\t\tIWL_DEBUG_QUIET_RFKILL(priv,\n\t\t\t\"Error clearing ASSOC_MSK on BSS (%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int iwlagn_disable_pan(struct iwl_priv *priv,\n\t\t\t      struct iwl_rxon_context *ctx,\n\t\t\t      struct iwl_rxon_cmd *send)\n{\n\tstruct iwl_notification_wait disable_wait;\n\t__le32 old_filter = send->filter_flags;\n\tu8 old_dev_type = send->dev_type;\n\tint ret;\n\tstatic const u16 deactivate_cmd[] = {\n\t\tREPLY_WIPAN_DEACTIVATION_COMPLETE\n\t};\n\n\tiwl_init_notification_wait(&priv->notif_wait, &disable_wait,\n\t\t\t\t   deactivate_cmd, ARRAY_SIZE(deactivate_cmd),\n\t\t\t\t   NULL, NULL);\n\n\tsend->filter_flags &= ~RXON_FILTER_ASSOC_MSK;\n\tsend->dev_type = RXON_DEV_TYPE_P2P;\n\tret = iwl_dvm_send_cmd_pdu(priv, ctx->rxon_cmd,\n\t\t\t\t0, sizeof(*send), send);\n\n\tsend->filter_flags = old_filter;\n\tsend->dev_type = old_dev_type;\n\n\tif (ret) {\n\t\tIWL_ERR(priv, \"Error disabling PAN (%d)\\n\", ret);\n\t\tiwl_remove_notification(&priv->notif_wait, &disable_wait);\n\t} else {\n\t\tret = iwl_wait_notification(&priv->notif_wait,\n\t\t\t\t\t    &disable_wait, HZ);\n\t\tif (ret)\n\t\t\tIWL_ERR(priv, \"Timed out waiting for PAN disable\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic int iwlagn_disconn_pan(struct iwl_priv *priv,\n\t\t\t      struct iwl_rxon_context *ctx,\n\t\t\t      struct iwl_rxon_cmd *send)\n{\n\t__le32 old_filter = send->filter_flags;\n\tint ret;\n\n\tsend->filter_flags &= ~RXON_FILTER_ASSOC_MSK;\n\tret = iwl_dvm_send_cmd_pdu(priv, ctx->rxon_cmd, 0,\n\t\t\t\tsizeof(*send), send);\n\n\tsend->filter_flags = old_filter;\n\n\treturn ret;\n}\n\nstatic void iwlagn_update_qos(struct iwl_priv *priv,\n\t\t\t      struct iwl_rxon_context *ctx)\n{\n\tint ret;\n\n\tif (!ctx->is_active)\n\t\treturn;\n\n\tctx->qos_data.def_qos_parm.qos_flags = 0;\n\n\tif (ctx->qos_data.qos_active)\n\t\tctx->qos_data.def_qos_parm.qos_flags |=\n\t\t\tQOS_PARAM_FLG_UPDATE_EDCA_MSK;\n\n\tif (ctx->ht.enabled)\n\t\tctx->qos_data.def_qos_parm.qos_flags |= QOS_PARAM_FLG_TGN_MSK;\n\n\tIWL_DEBUG_INFO(priv, \"send QoS cmd with Qos active=%d FLAGS=0x%X\\n\",\n\t\t      ctx->qos_data.qos_active,\n\t\t      ctx->qos_data.def_qos_parm.qos_flags);\n\n\tret = iwl_dvm_send_cmd_pdu(priv, ctx->qos_cmd, 0,\n\t\t\t       sizeof(struct iwl_qosparam_cmd),\n\t\t\t       &ctx->qos_data.def_qos_parm);\n\tif (ret)\n\t\tIWL_DEBUG_QUIET_RFKILL(priv, \"Failed to update QoS\\n\");\n}\n\nstatic int iwlagn_update_beacon(struct iwl_priv *priv,\n\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tlockdep_assert_held(&priv->mutex);\n\n\tdev_kfree_skb(priv->beacon_skb);\n\tpriv->beacon_skb = ieee80211_beacon_get(priv->hw, vif, 0);\n\tif (!priv->beacon_skb)\n\t\treturn -ENOMEM;\n\treturn iwlagn_send_beacon_cmd(priv);\n}\n\nstatic int iwlagn_send_rxon_assoc(struct iwl_priv *priv,\n\t\t\t\t  struct iwl_rxon_context *ctx)\n{\n\tint ret = 0;\n\tstruct iwl_rxon_assoc_cmd rxon_assoc;\n\tconst struct iwl_rxon_cmd *rxon1 = &ctx->staging;\n\tconst struct iwl_rxon_cmd *rxon2 = &ctx->active;\n\n\tif ((rxon1->flags == rxon2->flags) &&\n\t    (rxon1->filter_flags == rxon2->filter_flags) &&\n\t    (rxon1->cck_basic_rates == rxon2->cck_basic_rates) &&\n\t    (rxon1->ofdm_ht_single_stream_basic_rates ==\n\t     rxon2->ofdm_ht_single_stream_basic_rates) &&\n\t    (rxon1->ofdm_ht_dual_stream_basic_rates ==\n\t     rxon2->ofdm_ht_dual_stream_basic_rates) &&\n\t    (rxon1->ofdm_ht_triple_stream_basic_rates ==\n\t     rxon2->ofdm_ht_triple_stream_basic_rates) &&\n\t    (rxon1->acquisition_data == rxon2->acquisition_data) &&\n\t    (rxon1->rx_chain == rxon2->rx_chain) &&\n\t    (rxon1->ofdm_basic_rates == rxon2->ofdm_basic_rates)) {\n\t\tIWL_DEBUG_INFO(priv, \"Using current RXON_ASSOC.  Not resending.\\n\");\n\t\treturn 0;\n\t}\n\n\trxon_assoc.flags = ctx->staging.flags;\n\trxon_assoc.filter_flags = ctx->staging.filter_flags;\n\trxon_assoc.ofdm_basic_rates = ctx->staging.ofdm_basic_rates;\n\trxon_assoc.cck_basic_rates = ctx->staging.cck_basic_rates;\n\trxon_assoc.reserved1 = 0;\n\trxon_assoc.reserved2 = 0;\n\trxon_assoc.reserved3 = 0;\n\trxon_assoc.ofdm_ht_single_stream_basic_rates =\n\t    ctx->staging.ofdm_ht_single_stream_basic_rates;\n\trxon_assoc.ofdm_ht_dual_stream_basic_rates =\n\t    ctx->staging.ofdm_ht_dual_stream_basic_rates;\n\trxon_assoc.rx_chain_select_flags = ctx->staging.rx_chain;\n\trxon_assoc.ofdm_ht_triple_stream_basic_rates =\n\t\t ctx->staging.ofdm_ht_triple_stream_basic_rates;\n\trxon_assoc.acquisition_data = ctx->staging.acquisition_data;\n\n\tret = iwl_dvm_send_cmd_pdu(priv, ctx->rxon_assoc_cmd,\n\t\t\t\tCMD_ASYNC, sizeof(rxon_assoc), &rxon_assoc);\n\treturn ret;\n}\n\nstatic u16 iwl_adjust_beacon_interval(u16 beacon_val, u16 max_beacon_val)\n{\n\tu16 new_val;\n\tu16 beacon_factor;\n\n\t \n\tif (!beacon_val)\n\t\treturn DEFAULT_BEACON_INTERVAL;\n\n\t \n\n\tbeacon_factor = (beacon_val + max_beacon_val) / max_beacon_val;\n\tnew_val = beacon_val / beacon_factor;\n\n\tif (!new_val)\n\t\tnew_val = max_beacon_val;\n\n\treturn new_val;\n}\n\nstatic int iwl_send_rxon_timing(struct iwl_priv *priv,\n\t\t\t\tstruct iwl_rxon_context *ctx)\n{\n\tu64 tsf;\n\ts32 interval_tm, rem;\n\tstruct ieee80211_conf *conf = NULL;\n\tu16 beacon_int;\n\tstruct ieee80211_vif *vif = ctx->vif;\n\n\tconf = &priv->hw->conf;\n\n\tlockdep_assert_held(&priv->mutex);\n\n\tmemset(&ctx->timing, 0, sizeof(struct iwl_rxon_time_cmd));\n\n\tctx->timing.timestamp = cpu_to_le64(priv->timestamp);\n\tctx->timing.listen_interval = cpu_to_le16(conf->listen_interval);\n\n\tbeacon_int = vif ? vif->bss_conf.beacon_int : 0;\n\n\t \n\tctx->timing.atim_window = 0;\n\n\tif (ctx->ctxid == IWL_RXON_CTX_PAN &&\n\t    (!ctx->vif || ctx->vif->type != NL80211_IFTYPE_STATION) &&\n\t    iwl_is_associated(priv, IWL_RXON_CTX_BSS) &&\n\t    priv->contexts[IWL_RXON_CTX_BSS].vif &&\n\t    priv->contexts[IWL_RXON_CTX_BSS].vif->bss_conf.beacon_int) {\n\t\tctx->timing.beacon_interval =\n\t\t\tpriv->contexts[IWL_RXON_CTX_BSS].timing.beacon_interval;\n\t\tbeacon_int = le16_to_cpu(ctx->timing.beacon_interval);\n\t} else if (ctx->ctxid == IWL_RXON_CTX_BSS &&\n\t\t   iwl_is_associated(priv, IWL_RXON_CTX_PAN) &&\n\t\t   priv->contexts[IWL_RXON_CTX_PAN].vif &&\n\t\t   priv->contexts[IWL_RXON_CTX_PAN].vif->bss_conf.beacon_int &&\n\t\t   (!iwl_is_associated_ctx(ctx) || !ctx->vif ||\n\t\t    !ctx->vif->bss_conf.beacon_int)) {\n\t\tctx->timing.beacon_interval =\n\t\t\tpriv->contexts[IWL_RXON_CTX_PAN].timing.beacon_interval;\n\t\tbeacon_int = le16_to_cpu(ctx->timing.beacon_interval);\n\t} else {\n\t\tbeacon_int = iwl_adjust_beacon_interval(beacon_int,\n\t\t\tIWL_MAX_UCODE_BEACON_INTERVAL * TIME_UNIT);\n\t\tctx->timing.beacon_interval = cpu_to_le16(beacon_int);\n\t}\n\n\tctx->beacon_int = beacon_int;\n\n\ttsf = priv->timestamp;  \n\tinterval_tm = beacon_int * TIME_UNIT;\n\trem = do_div(tsf, interval_tm);\n\tctx->timing.beacon_init_val = cpu_to_le32(interval_tm - rem);\n\n\tctx->timing.dtim_period = vif ? (vif->bss_conf.dtim_period ?: 1) : 1;\n\n\tIWL_DEBUG_ASSOC(priv,\n\t\t\t\"beacon interval %d beacon timer %d beacon tim %d\\n\",\n\t\t\tle16_to_cpu(ctx->timing.beacon_interval),\n\t\t\tle32_to_cpu(ctx->timing.beacon_init_val),\n\t\t\tle16_to_cpu(ctx->timing.atim_window));\n\n\treturn iwl_dvm_send_cmd_pdu(priv, ctx->rxon_timing_cmd,\n\t\t\t\t0, sizeof(ctx->timing), &ctx->timing);\n}\n\nstatic int iwlagn_rxon_disconn(struct iwl_priv *priv,\n\t\t\t       struct iwl_rxon_context *ctx)\n{\n\tint ret;\n\tstruct iwl_rxon_cmd *active = (void *)&ctx->active;\n\n\tif (ctx->ctxid == IWL_RXON_CTX_BSS) {\n\t\tret = iwlagn_disable_bss(priv, ctx, &ctx->staging);\n\t} else {\n\t\tret = iwlagn_disable_pan(priv, ctx, &ctx->staging);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (ctx->vif) {\n\t\t\tret = iwl_send_rxon_timing(priv, ctx);\n\t\t\tif (ret) {\n\t\t\t\tIWL_ERR(priv, \"Failed to send timing (%d)!\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tret = iwlagn_disconn_pan(priv, ctx, &ctx->staging);\n\t\t}\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tiwl_clear_ucode_stations(priv, ctx);\n\t \n\tiwl_update_bcast_station(priv, ctx);\n\tiwl_restore_stations(priv, ctx);\n\tret = iwl_restore_default_wep_keys(priv, ctx);\n\tif (ret) {\n\t\tIWL_ERR(priv, \"Failed to restore WEP keys (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmemcpy(active, &ctx->staging, sizeof(*active));\n\treturn 0;\n}\n\nstatic int iwl_set_tx_power(struct iwl_priv *priv, s8 tx_power, bool force)\n{\n\tint ret;\n\ts8 prev_tx_power;\n\tbool defer;\n\tstruct iwl_rxon_context *ctx = &priv->contexts[IWL_RXON_CTX_BSS];\n\n\tif (priv->calib_disabled & IWL_TX_POWER_CALIB_DISABLED)\n\t\treturn 0;\n\n\tlockdep_assert_held(&priv->mutex);\n\n\tif (priv->tx_power_user_lmt == tx_power && !force)\n\t\treturn 0;\n\n\tif (tx_power < IWLAGN_TX_POWER_TARGET_POWER_MIN) {\n\t\tIWL_WARN(priv,\n\t\t\t \"Requested user TXPOWER %d below lower limit %d.\\n\",\n\t\t\t tx_power,\n\t\t\t IWLAGN_TX_POWER_TARGET_POWER_MIN);\n\t\treturn -EINVAL;\n\t}\n\n\tif (tx_power > DIV_ROUND_UP(priv->nvm_data->max_tx_pwr_half_dbm, 2)) {\n\t\tIWL_WARN(priv,\n\t\t\t\"Requested user TXPOWER %d above upper limit %d.\\n\",\n\t\t\t tx_power, priv->nvm_data->max_tx_pwr_half_dbm);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!iwl_is_ready_rf(priv))\n\t\treturn -EIO;\n\n\t \n\tpriv->tx_power_next = tx_power;\n\n\t \n\tdefer = test_bit(STATUS_SCANNING, &priv->status) ||\n\t\tmemcmp(&ctx->active, &ctx->staging, sizeof(ctx->staging));\n\tif (defer && !force) {\n\t\tIWL_DEBUG_INFO(priv, \"Deferring tx power set\\n\");\n\t\treturn 0;\n\t}\n\n\tprev_tx_power = priv->tx_power_user_lmt;\n\tpriv->tx_power_user_lmt = tx_power;\n\n\tret = iwlagn_send_tx_power(priv);\n\n\t \n\tif (ret) {\n\t\tpriv->tx_power_user_lmt = prev_tx_power;\n\t\tpriv->tx_power_next = prev_tx_power;\n\t}\n\treturn ret;\n}\n\nstatic int iwlagn_rxon_connect(struct iwl_priv *priv,\n\t\t\t       struct iwl_rxon_context *ctx)\n{\n\tint ret;\n\tstruct iwl_rxon_cmd *active = (void *)&ctx->active;\n\n\t \n\tif (ctx->ctxid == IWL_RXON_CTX_BSS) {\n\t\tret = iwl_send_rxon_timing(priv, ctx);\n\t\tif (ret) {\n\t\t\tIWL_ERR(priv, \"Failed to send timing (%d)!\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\t \n\tiwlagn_update_qos(priv, ctx);\n\n\t \n\tif (ctx->vif && (ctx->vif->type == NL80211_IFTYPE_AP)) {\n\t\tret = iwlagn_update_beacon(priv, ctx->vif);\n\t\tif (ret) {\n\t\t\tIWL_ERR(priv,\n\t\t\t\t\"Error sending required beacon (%d)!\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpriv->start_calib = 0;\n\t \n\tret = iwl_dvm_send_cmd_pdu(priv, ctx->rxon_cmd, 0,\n\t\t      sizeof(struct iwl_rxon_cmd), &ctx->staging);\n\tif (ret) {\n\t\tIWL_ERR(priv, \"Error setting new RXON (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tmemcpy(active, &ctx->staging, sizeof(*active));\n\n\t \n\tif (ctx->vif && (ctx->vif->type == NL80211_IFTYPE_ADHOC))\n\t\tif (iwlagn_update_beacon(priv, ctx->vif))\n\t\t\tIWL_ERR(priv, \"Error sending IBSS beacon\\n\");\n\tiwl_init_sensitivity(priv);\n\n\t \n\tret = iwl_set_tx_power(priv, priv->tx_power_next, true);\n\tif (ret) {\n\t\tIWL_ERR(priv, \"Error sending TX power (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint iwlagn_set_pan_params(struct iwl_priv *priv)\n{\n\tstruct iwl_wipan_params_cmd cmd;\n\tstruct iwl_rxon_context *ctx_bss, *ctx_pan;\n\tint slot0 = 300, slot1 = 0;\n\tint ret;\n\n\tif (priv->valid_contexts == BIT(IWL_RXON_CTX_BSS))\n\t\treturn 0;\n\n\tBUILD_BUG_ON(NUM_IWL_RXON_CTX != 2);\n\n\tlockdep_assert_held(&priv->mutex);\n\n\tctx_bss = &priv->contexts[IWL_RXON_CTX_BSS];\n\tctx_pan = &priv->contexts[IWL_RXON_CTX_PAN];\n\n\t \n\tif (!ctx_pan->is_active)\n\t\treturn 0;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\t \n\tcmd.num_slots = 2;\n\n\tcmd.slots[0].type = 0;  \n\tcmd.slots[1].type = 1;  \n\n\tif (ctx_bss->vif && ctx_pan->vif) {\n\t\tint bcnint = ctx_pan->beacon_int;\n\t\tint dtim = ctx_pan->vif->bss_conf.dtim_period ?: 1;\n\n\t\t \n\t\tcmd.flags |= cpu_to_le16(IWL_WIPAN_PARAMS_FLG_SLOTTED_MODE);\n\n\t\tif (ctx_pan->vif->type == NL80211_IFTYPE_AP &&\n\t\t    bcnint &&\n\t\t    bcnint != ctx_bss->beacon_int) {\n\t\t\tIWL_ERR(priv,\n\t\t\t\t\"beacon intervals don't match (%d, %d)\\n\",\n\t\t\t\tctx_bss->beacon_int, ctx_pan->beacon_int);\n\t\t} else\n\t\t\tbcnint = max_t(int, bcnint,\n\t\t\t\t       ctx_bss->beacon_int);\n\t\tif (!bcnint)\n\t\t\tbcnint = DEFAULT_BEACON_INTERVAL;\n\t\tslot0 = bcnint / 2;\n\t\tslot1 = bcnint - slot0;\n\n\t\tif (test_bit(STATUS_SCAN_HW, &priv->status) ||\n\t\t    (!ctx_bss->vif->cfg.idle &&\n\t\t     !ctx_bss->vif->cfg.assoc)) {\n\t\t\tslot0 = dtim * bcnint * 3 - IWL_MIN_SLOT_TIME;\n\t\t\tslot1 = IWL_MIN_SLOT_TIME;\n\t\t} else if (!ctx_pan->vif->cfg.idle &&\n\t\t\t   !ctx_pan->vif->cfg.assoc) {\n\t\t\tslot1 = dtim * bcnint * 3 - IWL_MIN_SLOT_TIME;\n\t\t\tslot0 = IWL_MIN_SLOT_TIME;\n\t\t}\n\t} else if (ctx_pan->vif) {\n\t\tslot0 = 0;\n\t\tslot1 = max_t(int, 1, ctx_pan->vif->bss_conf.dtim_period) *\n\t\t\t\t\tctx_pan->beacon_int;\n\t\tslot1 = max_t(int, DEFAULT_BEACON_INTERVAL, slot1);\n\n\t\tif (test_bit(STATUS_SCAN_HW, &priv->status)) {\n\t\t\tslot0 = slot1 * 3 - IWL_MIN_SLOT_TIME;\n\t\t\tslot1 = IWL_MIN_SLOT_TIME;\n\t\t}\n\t}\n\n\tcmd.slots[0].width = cpu_to_le16(slot0);\n\tcmd.slots[1].width = cpu_to_le16(slot1);\n\n\tret = iwl_dvm_send_cmd_pdu(priv, REPLY_WIPAN_PARAMS, 0,\n\t\t\tsizeof(cmd), &cmd);\n\tif (ret)\n\t\tIWL_ERR(priv, \"Error setting PAN parameters (%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void _iwl_set_rxon_ht(struct iwl_priv *priv,\n\t\t\t     struct iwl_ht_config *ht_conf,\n\t\t\t     struct iwl_rxon_context *ctx)\n{\n\tstruct iwl_rxon_cmd *rxon = &ctx->staging;\n\n\tif (!ctx->ht.enabled) {\n\t\trxon->flags &= ~(RXON_FLG_CHANNEL_MODE_MSK |\n\t\t\tRXON_FLG_CTRL_CHANNEL_LOC_HI_MSK |\n\t\t\tRXON_FLG_HT40_PROT_MSK |\n\t\t\tRXON_FLG_HT_PROT_MSK);\n\t\treturn;\n\t}\n\n\t \n\trxon->flags |= cpu_to_le32(ctx->ht.protection <<\n\t\t\t\t   RXON_FLG_HT_OPERATING_MODE_POS);\n\n\t \n\t \n\trxon->flags &= ~(RXON_FLG_CHANNEL_MODE_MSK |\n\t\t\t RXON_FLG_CTRL_CHANNEL_LOC_HI_MSK);\n\tif (iwl_is_ht40_tx_allowed(priv, ctx, NULL)) {\n\t\t \n\t\tif (ctx->ht.protection ==\n\t\t    IEEE80211_HT_OP_MODE_PROTECTION_20MHZ) {\n\t\t\trxon->flags |= RXON_FLG_CHANNEL_MODE_PURE_40;\n\t\t\t \n\t\t\tswitch (ctx->ht.extension_chan_offset) {\n\t\t\tcase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\n\t\t\t\trxon->flags &=\n\t\t\t\t\t~RXON_FLG_CTRL_CHANNEL_LOC_HI_MSK;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\n\t\t\t\trxon->flags |=\n\t\t\t\t\tRXON_FLG_CTRL_CHANNEL_LOC_HI_MSK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tswitch (ctx->ht.extension_chan_offset) {\n\t\t\tcase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\n\t\t\t\trxon->flags &=\n\t\t\t\t\t~(RXON_FLG_CTRL_CHANNEL_LOC_HI_MSK);\n\t\t\t\trxon->flags |= RXON_FLG_CHANNEL_MODE_MIXED;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\n\t\t\t\trxon->flags |= RXON_FLG_CTRL_CHANNEL_LOC_HI_MSK;\n\t\t\t\trxon->flags |= RXON_FLG_CHANNEL_MODE_MIXED;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_HT_PARAM_CHA_SEC_NONE:\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tIWL_ERR(priv,\n\t\t\t\t\t\"invalid extension channel offset\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trxon->flags |= RXON_FLG_CHANNEL_MODE_LEGACY;\n\t}\n\n\tiwlagn_set_rxon_chain(priv, ctx);\n\n\tIWL_DEBUG_ASSOC(priv, \"rxon flags 0x%X operation mode :0x%X \"\n\t\t\t\"extension channel offset 0x%x\\n\",\n\t\t\tle32_to_cpu(rxon->flags), ctx->ht.protection,\n\t\t\tctx->ht.extension_chan_offset);\n}\n\nvoid iwl_set_rxon_ht(struct iwl_priv *priv, struct iwl_ht_config *ht_conf)\n{\n\tstruct iwl_rxon_context *ctx;\n\n\tfor_each_context(priv, ctx)\n\t\t_iwl_set_rxon_ht(priv, ht_conf, ctx);\n}\n\n \nvoid iwl_set_rxon_channel(struct iwl_priv *priv, struct ieee80211_channel *ch,\n\t\t\t struct iwl_rxon_context *ctx)\n{\n\tenum nl80211_band band = ch->band;\n\tu16 channel = ch->hw_value;\n\n\tif ((le16_to_cpu(ctx->staging.channel) == channel) &&\n\t    (priv->band == band))\n\t\treturn;\n\n\tctx->staging.channel = cpu_to_le16(channel);\n\tif (band == NL80211_BAND_5GHZ)\n\t\tctx->staging.flags &= ~RXON_FLG_BAND_24G_MSK;\n\telse\n\t\tctx->staging.flags |= RXON_FLG_BAND_24G_MSK;\n\n\tpriv->band = band;\n\n\tIWL_DEBUG_INFO(priv, \"Staging channel set to %d [%d]\\n\", channel, band);\n\n}\n\nvoid iwl_set_flags_for_band(struct iwl_priv *priv,\n\t\t\t    struct iwl_rxon_context *ctx,\n\t\t\t    enum nl80211_band band,\n\t\t\t    struct ieee80211_vif *vif)\n{\n\tif (band == NL80211_BAND_5GHZ) {\n\t\tctx->staging.flags &=\n\t\t    ~(RXON_FLG_BAND_24G_MSK | RXON_FLG_AUTO_DETECT_MSK\n\t\t      | RXON_FLG_CCK_MSK);\n\t\tctx->staging.flags |= RXON_FLG_SHORT_SLOT_MSK;\n\t} else {\n\t\t \n\t\tif (vif && vif->bss_conf.use_short_slot)\n\t\t\tctx->staging.flags |= RXON_FLG_SHORT_SLOT_MSK;\n\t\telse\n\t\t\tctx->staging.flags &= ~RXON_FLG_SHORT_SLOT_MSK;\n\n\t\tctx->staging.flags |= RXON_FLG_BAND_24G_MSK;\n\t\tctx->staging.flags |= RXON_FLG_AUTO_DETECT_MSK;\n\t\tctx->staging.flags &= ~RXON_FLG_CCK_MSK;\n\t}\n}\n\nstatic void iwl_set_rxon_hwcrypto(struct iwl_priv *priv,\n\t\t\t\t  struct iwl_rxon_context *ctx, int hw_decrypt)\n{\n\tstruct iwl_rxon_cmd *rxon = &ctx->staging;\n\n\tif (hw_decrypt)\n\t\trxon->filter_flags &= ~RXON_FILTER_DIS_DECRYPT_MSK;\n\telse\n\t\trxon->filter_flags |= RXON_FILTER_DIS_DECRYPT_MSK;\n\n}\n\n \nstatic int iwl_check_rxon_cmd(struct iwl_priv *priv,\n\t\t\t      struct iwl_rxon_context *ctx)\n{\n\tstruct iwl_rxon_cmd *rxon = &ctx->staging;\n\tu32 errors = 0;\n\n\tif (rxon->flags & RXON_FLG_BAND_24G_MSK) {\n\t\tif (rxon->flags & RXON_FLG_TGJ_NARROW_BAND_MSK) {\n\t\t\tIWL_WARN(priv, \"check 2.4G: wrong narrow\\n\");\n\t\t\terrors |= BIT(0);\n\t\t}\n\t\tif (rxon->flags & RXON_FLG_RADAR_DETECT_MSK) {\n\t\t\tIWL_WARN(priv, \"check 2.4G: wrong radar\\n\");\n\t\t\terrors |= BIT(1);\n\t\t}\n\t} else {\n\t\tif (!(rxon->flags & RXON_FLG_SHORT_SLOT_MSK)) {\n\t\t\tIWL_WARN(priv, \"check 5.2G: not short slot!\\n\");\n\t\t\terrors |= BIT(2);\n\t\t}\n\t\tif (rxon->flags & RXON_FLG_CCK_MSK) {\n\t\t\tIWL_WARN(priv, \"check 5.2G: CCK!\\n\");\n\t\t\terrors |= BIT(3);\n\t\t}\n\t}\n\tif ((rxon->node_addr[0] | rxon->bssid_addr[0]) & 0x1) {\n\t\tIWL_WARN(priv, \"mac/bssid mcast!\\n\");\n\t\terrors |= BIT(4);\n\t}\n\n\t \n\tif ((rxon->ofdm_basic_rates & IWL_RATE_6M_MASK) == 0 &&\n\t    (rxon->cck_basic_rates & IWL_RATE_1M_MASK) == 0) {\n\t\tIWL_WARN(priv, \"neither 1 nor 6 are basic\\n\");\n\t\terrors |= BIT(5);\n\t}\n\n\tif (le16_to_cpu(rxon->assoc_id) > 2007) {\n\t\tIWL_WARN(priv, \"aid > 2007\\n\");\n\t\terrors |= BIT(6);\n\t}\n\n\tif ((rxon->flags & (RXON_FLG_CCK_MSK | RXON_FLG_SHORT_SLOT_MSK))\n\t\t\t== (RXON_FLG_CCK_MSK | RXON_FLG_SHORT_SLOT_MSK)) {\n\t\tIWL_WARN(priv, \"CCK and short slot\\n\");\n\t\terrors |= BIT(7);\n\t}\n\n\tif ((rxon->flags & (RXON_FLG_CCK_MSK | RXON_FLG_AUTO_DETECT_MSK))\n\t\t\t== (RXON_FLG_CCK_MSK | RXON_FLG_AUTO_DETECT_MSK)) {\n\t\tIWL_WARN(priv, \"CCK and auto detect\\n\");\n\t\terrors |= BIT(8);\n\t}\n\n\tif ((rxon->flags & (RXON_FLG_AUTO_DETECT_MSK |\n\t\t\t    RXON_FLG_TGG_PROTECT_MSK)) ==\n\t\t\t    RXON_FLG_TGG_PROTECT_MSK) {\n\t\tIWL_WARN(priv, \"TGg but no auto-detect\\n\");\n\t\terrors |= BIT(9);\n\t}\n\n\tif (rxon->channel == 0) {\n\t\tIWL_WARN(priv, \"zero channel is invalid\\n\");\n\t\terrors |= BIT(10);\n\t}\n\n\tWARN(errors, \"Invalid RXON (%#x), channel %d\",\n\t     errors, le16_to_cpu(rxon->channel));\n\n\treturn errors ? -EINVAL : 0;\n}\n\n \nstatic int iwl_full_rxon_required(struct iwl_priv *priv,\n\t\t\t\t  struct iwl_rxon_context *ctx)\n{\n\tconst struct iwl_rxon_cmd *staging = &ctx->staging;\n\tconst struct iwl_rxon_cmd *active = &ctx->active;\n\n#define CHK(cond)\t\t\t\t\t\t\t\\\n\tif ((cond)) {\t\t\t\t\t\t\t\\\n\t\tIWL_DEBUG_INFO(priv, \"need full RXON - \" #cond \"\\n\");\t\\\n\t\treturn 1;\t\t\t\t\t\t\\\n\t}\n\n#define CHK_NEQ(c1, c2)\t\t\t\t\t\t\\\n\tif ((c1) != (c2)) {\t\t\t\t\t\\\n\t\tIWL_DEBUG_INFO(priv, \"need full RXON - \"\t\\\n\t\t\t       #c1 \" != \" #c2 \" - %d != %d\\n\",\t\\\n\t\t\t       (c1), (c2));\t\t\t\\\n\t\treturn 1;\t\t\t\t\t\\\n\t}\n\n\t \n\tCHK(!iwl_is_associated_ctx(ctx));\n\tCHK(!ether_addr_equal(staging->bssid_addr, active->bssid_addr));\n\tCHK(!ether_addr_equal(staging->node_addr, active->node_addr));\n\tCHK(!ether_addr_equal(staging->wlap_bssid_addr,\n\t\t\t      active->wlap_bssid_addr));\n\tCHK_NEQ(staging->dev_type, active->dev_type);\n\tCHK_NEQ(staging->channel, active->channel);\n\tCHK_NEQ(staging->air_propagation, active->air_propagation);\n\tCHK_NEQ(staging->ofdm_ht_single_stream_basic_rates,\n\t\tactive->ofdm_ht_single_stream_basic_rates);\n\tCHK_NEQ(staging->ofdm_ht_dual_stream_basic_rates,\n\t\tactive->ofdm_ht_dual_stream_basic_rates);\n\tCHK_NEQ(staging->ofdm_ht_triple_stream_basic_rates,\n\t\tactive->ofdm_ht_triple_stream_basic_rates);\n\tCHK_NEQ(staging->assoc_id, active->assoc_id);\n\n\t \n\n\t \n\tCHK_NEQ(staging->flags & RXON_FLG_BAND_24G_MSK,\n\t\tactive->flags & RXON_FLG_BAND_24G_MSK);\n\n\t \n\tCHK_NEQ(staging->filter_flags & RXON_FILTER_ASSOC_MSK,\n\t\tactive->filter_flags & RXON_FILTER_ASSOC_MSK);\n\n#undef CHK\n#undef CHK_NEQ\n\n\treturn 0;\n}\n\n#ifdef CONFIG_IWLWIFI_DEBUG\nvoid iwl_print_rx_config_cmd(struct iwl_priv *priv,\n\t\t\t     enum iwl_rxon_context_id ctxid)\n{\n\tstruct iwl_rxon_context *ctx = &priv->contexts[ctxid];\n\tstruct iwl_rxon_cmd *rxon = &ctx->staging;\n\n\tIWL_DEBUG_RADIO(priv, \"RX CONFIG:\\n\");\n\tiwl_print_hex_dump(priv, IWL_DL_RADIO, (u8 *) rxon, sizeof(*rxon));\n\tIWL_DEBUG_RADIO(priv, \"u16 channel: 0x%x\\n\",\n\t\t\tle16_to_cpu(rxon->channel));\n\tIWL_DEBUG_RADIO(priv, \"u32 flags: 0x%08X\\n\",\n\t\t\tle32_to_cpu(rxon->flags));\n\tIWL_DEBUG_RADIO(priv, \"u32 filter_flags: 0x%08x\\n\",\n\t\t\tle32_to_cpu(rxon->filter_flags));\n\tIWL_DEBUG_RADIO(priv, \"u8 dev_type: 0x%x\\n\", rxon->dev_type);\n\tIWL_DEBUG_RADIO(priv, \"u8 ofdm_basic_rates: 0x%02x\\n\",\n\t\t\trxon->ofdm_basic_rates);\n\tIWL_DEBUG_RADIO(priv, \"u8 cck_basic_rates: 0x%02x\\n\",\n\t\t\trxon->cck_basic_rates);\n\tIWL_DEBUG_RADIO(priv, \"u8[6] node_addr: %pM\\n\", rxon->node_addr);\n\tIWL_DEBUG_RADIO(priv, \"u8[6] bssid_addr: %pM\\n\", rxon->bssid_addr);\n\tIWL_DEBUG_RADIO(priv, \"u16 assoc_id: 0x%x\\n\",\n\t\t\tle16_to_cpu(rxon->assoc_id));\n}\n#endif\n\nstatic void iwl_calc_basic_rates(struct iwl_priv *priv,\n\t\t\t\t struct iwl_rxon_context *ctx)\n{\n\tint lowest_present_ofdm = 100;\n\tint lowest_present_cck = 100;\n\tu8 cck = 0;\n\tu8 ofdm = 0;\n\n\tif (ctx->vif) {\n\t\tstruct ieee80211_supported_band *sband;\n\t\tunsigned long basic = ctx->vif->bss_conf.basic_rates;\n\t\tint i;\n\n\t\tsband = priv->hw->wiphy->bands[priv->hw->conf.chandef.chan->band];\n\n\t\tfor_each_set_bit(i, &basic, BITS_PER_LONG) {\n\t\t\tint hw = sband->bitrates[i].hw_value;\n\t\t\tif (hw >= IWL_FIRST_OFDM_RATE) {\n\t\t\t\tofdm |= BIT(hw - IWL_FIRST_OFDM_RATE);\n\t\t\t\tif (lowest_present_ofdm > hw)\n\t\t\t\t\tlowest_present_ofdm = hw;\n\t\t\t} else {\n\t\t\t\tBUILD_BUG_ON(IWL_FIRST_CCK_RATE != 0);\n\n\t\t\t\tcck |= BIT(hw);\n\t\t\t\tif (lowest_present_cck > hw)\n\t\t\t\t\tlowest_present_cck = hw;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\n\tif (IWL_RATE_24M_INDEX < lowest_present_ofdm)\n\t\tofdm |= IWL_RATE_24M_MASK >> IWL_FIRST_OFDM_RATE;\n\tif (IWL_RATE_12M_INDEX < lowest_present_ofdm)\n\t\tofdm |= IWL_RATE_12M_MASK >> IWL_FIRST_OFDM_RATE;\n\t \n\tofdm |= IWL_RATE_6M_MASK >> IWL_FIRST_OFDM_RATE;\n\n\t \n\tif (IWL_RATE_11M_INDEX < lowest_present_cck)\n\t\tcck |= IWL_RATE_11M_MASK >> IWL_FIRST_CCK_RATE;\n\tif (IWL_RATE_5M_INDEX < lowest_present_cck)\n\t\tcck |= IWL_RATE_5M_MASK >> IWL_FIRST_CCK_RATE;\n\tif (IWL_RATE_2M_INDEX < lowest_present_cck)\n\t\tcck |= IWL_RATE_2M_MASK >> IWL_FIRST_CCK_RATE;\n\t \n\tcck |= IWL_RATE_1M_MASK >> IWL_FIRST_CCK_RATE;\n\n\tIWL_DEBUG_RATE(priv, \"Set basic rates cck:0x%.2x ofdm:0x%.2x\\n\",\n\t\t       cck, ofdm);\n\n\t \n\tctx->staging.cck_basic_rates = cck;\n\tctx->staging.ofdm_basic_rates = ofdm;\n}\n\n \nint iwlagn_commit_rxon(struct iwl_priv *priv, struct iwl_rxon_context *ctx)\n{\n\t \n\tstruct iwl_rxon_cmd *active = (void *)&ctx->active;\n\tbool new_assoc = !!(ctx->staging.filter_flags & RXON_FILTER_ASSOC_MSK);\n\tint ret;\n\n\tlockdep_assert_held(&priv->mutex);\n\n\tif (!iwl_is_alive(priv))\n\t\treturn -EBUSY;\n\n\t \n\tBUILD_BUG_ON(NUM_IWL_RXON_CTX != 2);\n\n\tif (!ctx->is_active)\n\t\treturn 0;\n\n\t \n\tctx->staging.flags |= RXON_FLG_TSF2HOST_MSK;\n\n\t \n\tiwl_calc_basic_rates(priv, ctx);\n\n\t \n\tif (!priv->hw_params.use_rts_for_aggregation)\n\t\tctx->staging.flags |= RXON_FLG_SELF_CTS_EN;\n\n\tif ((ctx->vif && ctx->vif->bss_conf.use_short_slot) ||\n\t    !(ctx->staging.flags & RXON_FLG_BAND_24G_MSK))\n\t\tctx->staging.flags |= RXON_FLG_SHORT_SLOT_MSK;\n\telse\n\t\tctx->staging.flags &= ~RXON_FLG_SHORT_SLOT_MSK;\n\n\tiwl_print_rx_config_cmd(priv, ctx->ctxid);\n\tret = iwl_check_rxon_cmd(priv, ctx);\n\tif (ret) {\n\t\tIWL_ERR(priv, \"Invalid RXON configuration. Not committing.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (test_bit(STATUS_CHANNEL_SWITCH_PENDING, &priv->status) &&\n\t    (priv->switch_channel != ctx->staging.channel)) {\n\t\tIWL_DEBUG_11H(priv, \"abort channel switch on %d\\n\",\n\t\t\t      le16_to_cpu(priv->switch_channel));\n\t\tiwl_chswitch_done(priv, false);\n\t}\n\n\t \n\tif (!iwl_full_rxon_required(priv, ctx)) {\n\t\tret = iwlagn_send_rxon_assoc(priv, ctx);\n\t\tif (ret) {\n\t\t\tIWL_ERR(priv, \"Error setting RXON_ASSOC (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmemcpy(active, &ctx->staging, sizeof(*active));\n\t\t \n\t\tiwl_set_tx_power(priv, priv->tx_power_next, false);\n\n\t\t \n\t\tiwl_power_update_mode(priv, true);\n\n\t\treturn 0;\n\t}\n\n\tiwl_set_rxon_hwcrypto(priv, ctx, !iwlwifi_mod_params.swcrypto);\n\n\tIWL_DEBUG_INFO(priv,\n\t\t       \"Going to commit RXON\\n\"\n\t\t       \"  * with%s RXON_FILTER_ASSOC_MSK\\n\"\n\t\t       \"  * channel = %d\\n\"\n\t\t       \"  * bssid = %pM\\n\",\n\t\t       (new_assoc ? \"\" : \"out\"),\n\t\t       le16_to_cpu(ctx->staging.channel),\n\t\t       ctx->staging.bssid_addr);\n\n\t \n\tret = iwlagn_rxon_disconn(priv, ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tret = iwlagn_set_pan_params(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tif (new_assoc)\n\t\treturn iwlagn_rxon_connect(priv, ctx);\n\n\treturn 0;\n}\n\nvoid iwlagn_config_ht40(struct ieee80211_conf *conf,\n\t\t\tstruct iwl_rxon_context *ctx)\n{\n\tif (conf_is_ht40_minus(conf)) {\n\t\tctx->ht.extension_chan_offset =\n\t\t\tIEEE80211_HT_PARAM_CHA_SEC_BELOW;\n\t\tctx->ht.is_40mhz = true;\n\t} else if (conf_is_ht40_plus(conf)) {\n\t\tctx->ht.extension_chan_offset =\n\t\t\tIEEE80211_HT_PARAM_CHA_SEC_ABOVE;\n\t\tctx->ht.is_40mhz = true;\n\t} else {\n\t\tctx->ht.extension_chan_offset =\n\t\t\tIEEE80211_HT_PARAM_CHA_SEC_NONE;\n\t\tctx->ht.is_40mhz = false;\n\t}\n}\n\nint iwlagn_mac_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\tstruct iwl_rxon_context *ctx;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tstruct ieee80211_channel *channel = conf->chandef.chan;\n\tint ret = 0;\n\n\tIWL_DEBUG_MAC80211(priv, \"enter: changed %#x\\n\", changed);\n\n\tmutex_lock(&priv->mutex);\n\n\tif (unlikely(test_bit(STATUS_SCANNING, &priv->status))) {\n\t\tIWL_DEBUG_MAC80211(priv, \"leave - scanning\\n\");\n\t\tgoto out;\n\t}\n\n\tif (!iwl_is_ready(priv)) {\n\t\tIWL_DEBUG_MAC80211(priv, \"leave - not ready\\n\");\n\t\tgoto out;\n\t}\n\n\tif (changed & (IEEE80211_CONF_CHANGE_SMPS |\n\t\t       IEEE80211_CONF_CHANGE_CHANNEL)) {\n\t\t \n\t\tpriv->current_ht_config.smps = conf->smps_mode;\n\n\t\t \n\t\tfor_each_context(priv, ctx)\n\t\t\tiwlagn_set_rxon_chain(priv, ctx);\n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_CHANNEL) {\n\t\tfor_each_context(priv, ctx) {\n\t\t\t \n\t\t\tif (ctx->ht.enabled != conf_is_ht(conf))\n\t\t\t\tctx->ht.enabled = conf_is_ht(conf);\n\n\t\t\tif (ctx->ht.enabled) {\n\t\t\t\t \n\t\t\t\tif (!ctx->ht.is_40mhz ||\n\t\t\t\t\t\t!iwl_is_associated_ctx(ctx))\n\t\t\t\t\tiwlagn_config_ht40(conf, ctx);\n\t\t\t} else\n\t\t\t\tctx->ht.is_40mhz = false;\n\n\t\t\t \n\t\t\tctx->ht.protection = IEEE80211_HT_OP_MODE_PROTECTION_NONE;\n\n\t\t\t \n\t\t\tif (le16_to_cpu(ctx->staging.channel) !=\n\t\t\t    channel->hw_value)\n\t\t\t\tctx->staging.flags = 0;\n\n\t\t\tiwl_set_rxon_channel(priv, channel, ctx);\n\t\t\tiwl_set_rxon_ht(priv, &priv->current_ht_config);\n\n\t\t\tiwl_set_flags_for_band(priv, ctx, channel->band,\n\t\t\t\t\t       ctx->vif);\n\t\t}\n\n\t\tiwl_update_bcast_stations(priv);\n\t}\n\n\tif (changed & (IEEE80211_CONF_CHANGE_PS |\n\t\t\tIEEE80211_CONF_CHANGE_IDLE)) {\n\t\tret = iwl_power_update_mode(priv, false);\n\t\tif (ret)\n\t\t\tIWL_DEBUG_MAC80211(priv, \"Error setting sleep level\\n\");\n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_POWER) {\n\t\tIWL_DEBUG_MAC80211(priv, \"TX Power old=%d new=%d\\n\",\n\t\t\tpriv->tx_power_user_lmt, conf->power_level);\n\n\t\tiwl_set_tx_power(priv, conf->power_level, false);\n\t}\n\n\tfor_each_context(priv, ctx) {\n\t\tif (!memcmp(&ctx->staging, &ctx->active, sizeof(ctx->staging)))\n\t\t\tcontinue;\n\t\tiwlagn_commit_rxon(priv, ctx);\n\t}\n out:\n\tmutex_unlock(&priv->mutex);\n\tIWL_DEBUG_MAC80211(priv, \"leave\\n\");\n\n\treturn ret;\n}\n\nstatic void iwlagn_check_needed_chains(struct iwl_priv *priv,\n\t\t\t\t       struct iwl_rxon_context *ctx,\n\t\t\t\t       struct ieee80211_bss_conf *bss_conf)\n{\n\tstruct ieee80211_vif *vif = ctx->vif;\n\tstruct iwl_rxon_context *tmp;\n\tstruct ieee80211_sta *sta;\n\tstruct iwl_ht_config *ht_conf = &priv->current_ht_config;\n\tstruct ieee80211_sta_ht_cap *ht_cap;\n\tbool need_multiple;\n\n\tlockdep_assert_held(&priv->mutex);\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\trcu_read_lock();\n\t\tsta = ieee80211_find_sta(vif, bss_conf->bssid);\n\t\tif (!sta) {\n\t\t\t \n\t\t\tneed_multiple = false;\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\n\t\tht_cap = &sta->deflink.ht_cap;\n\n\t\tneed_multiple = true;\n\n\t\t \n\t\tif (ht_cap->mcs.rx_mask[1] == 0 &&\n\t\t    ht_cap->mcs.rx_mask[2] == 0) {\n\t\t\tneed_multiple = false;\n\t\t} else if (!(ht_cap->mcs.tx_params &\n\t\t\t\t\t\tIEEE80211_HT_MCS_TX_DEFINED)) {\n\t\t\t \n\t\t\tneed_multiple = false;\n\t\t} else if (ht_cap->mcs.tx_params &\n\t\t\t\t\t\tIEEE80211_HT_MCS_TX_RX_DIFF) {\n\t\t\tint maxstreams;\n\n\t\t\t \n\n\t\t\tmaxstreams = (ht_cap->mcs.tx_params &\n\t\t\t\t IEEE80211_HT_MCS_TX_MAX_STREAMS_MASK);\n\t\t\tmaxstreams >>=\n\t\t\t\tIEEE80211_HT_MCS_TX_MAX_STREAMS_SHIFT;\n\t\t\tmaxstreams += 1;\n\n\t\t\tif (maxstreams <= 1)\n\t\t\t\tneed_multiple = false;\n\t\t}\n\n\t\trcu_read_unlock();\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\t \n\t\tneed_multiple = false;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tneed_multiple = true;\n\t\tbreak;\n\t}\n\n\tctx->ht_need_multiple_chains = need_multiple;\n\n\tif (!need_multiple) {\n\t\t \n\t\tfor_each_context(priv, tmp) {\n\t\t\tif (!tmp->vif)\n\t\t\t\tcontinue;\n\t\t\tif (tmp->ht_need_multiple_chains) {\n\t\t\t\tneed_multiple = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tht_conf->single_chain_sufficient = !need_multiple;\n}\n\nstatic void iwlagn_chain_noise_reset(struct iwl_priv *priv)\n{\n\tstruct iwl_chain_noise_data *data = &priv->chain_noise_data;\n\tint ret;\n\n\tif (priv->calib_disabled & IWL_CHAIN_NOISE_CALIB_DISABLED)\n\t\treturn;\n\n\tif ((data->state == IWL_CHAIN_NOISE_ALIVE) &&\n\t    iwl_is_any_associated(priv)) {\n\t\tstruct iwl_calib_chain_noise_reset_cmd cmd;\n\n\t\t \n\t\tdata->chain_noise_a = 0;\n\t\tdata->chain_noise_b = 0;\n\t\tdata->chain_noise_c = 0;\n\t\tdata->chain_signal_a = 0;\n\t\tdata->chain_signal_b = 0;\n\t\tdata->chain_signal_c = 0;\n\t\tdata->beacon_count = 0;\n\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tiwl_set_calib_hdr(&cmd.hdr,\n\t\t\tpriv->phy_calib_chain_noise_reset_cmd);\n\t\tret = iwl_dvm_send_cmd_pdu(priv,\n\t\t\t\t\tREPLY_PHY_CALIBRATION_CMD,\n\t\t\t\t\t0, sizeof(cmd), &cmd);\n\t\tif (ret)\n\t\t\tIWL_ERR(priv,\n\t\t\t\t\"Could not send REPLY_PHY_CALIBRATION_CMD\\n\");\n\t\tdata->state = IWL_CHAIN_NOISE_ACCUMULATE;\n\t\tIWL_DEBUG_CALIB(priv, \"Run chain_noise_calibrate\\n\");\n\t}\n}\n\nvoid iwlagn_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_bss_conf *bss_conf,\n\t\t\t     u64 changes)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\tstruct iwl_rxon_context *ctx = iwl_rxon_ctx_from_vif(vif);\n\tint ret;\n\tbool force = false;\n\n\tmutex_lock(&priv->mutex);\n\n\tif (changes & BSS_CHANGED_IDLE && vif->cfg.idle) {\n\t\t \n\t\tiwlagn_lift_passive_no_rx(priv);\n\t}\n\n\tif (unlikely(!iwl_is_ready(priv))) {\n\t\tIWL_DEBUG_MAC80211(priv, \"leave - not ready\\n\");\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn;\n        }\n\n\tif (unlikely(!ctx->vif)) {\n\t\tIWL_DEBUG_MAC80211(priv, \"leave - vif is NULL\\n\");\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn;\n\t}\n\n\tif (changes & BSS_CHANGED_BEACON_INT)\n\t\tforce = true;\n\n\tif (changes & BSS_CHANGED_QOS) {\n\t\tctx->qos_data.qos_active = bss_conf->qos;\n\t\tiwlagn_update_qos(priv, ctx);\n\t}\n\n\tctx->staging.assoc_id = cpu_to_le16(vif->cfg.aid);\n\tif (vif->bss_conf.use_short_preamble)\n\t\tctx->staging.flags |= RXON_FLG_SHORT_PREAMBLE_MSK;\n\telse\n\t\tctx->staging.flags &= ~RXON_FLG_SHORT_PREAMBLE_MSK;\n\n\tif (changes & BSS_CHANGED_ASSOC) {\n\t\tif (vif->cfg.assoc) {\n\t\t\tpriv->timestamp = bss_conf->sync_tsf;\n\t\t\tctx->staging.filter_flags |= RXON_FILTER_ASSOC_MSK;\n\t\t} else {\n\t\t\tctx->staging.filter_flags &= ~RXON_FILTER_ASSOC_MSK;\n\n\t\t\tif (ctx->ctxid == IWL_RXON_CTX_BSS)\n\t\t\t\tpriv->have_rekey_data = false;\n\t\t}\n\n\t\tiwlagn_bt_coex_rssi_monitor(priv);\n\t}\n\n\tif (ctx->ht.enabled) {\n\t\tctx->ht.protection = bss_conf->ht_operation_mode &\n\t\t\t\t\tIEEE80211_HT_OP_MODE_PROTECTION;\n\t\tctx->ht.non_gf_sta_present = !!(bss_conf->ht_operation_mode &\n\t\t\t\t\tIEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\n\t\tiwlagn_check_needed_chains(priv, ctx, bss_conf);\n\t\tiwl_set_rxon_ht(priv, &priv->current_ht_config);\n\t}\n\n\tiwlagn_set_rxon_chain(priv, ctx);\n\n\tif (bss_conf->use_cts_prot && (priv->band != NL80211_BAND_5GHZ))\n\t\tctx->staging.flags |= RXON_FLG_TGG_PROTECT_MSK;\n\telse\n\t\tctx->staging.flags &= ~RXON_FLG_TGG_PROTECT_MSK;\n\n\tif (bss_conf->use_cts_prot)\n\t\tctx->staging.flags |= RXON_FLG_SELF_CTS_EN;\n\telse\n\t\tctx->staging.flags &= ~RXON_FLG_SELF_CTS_EN;\n\n\tmemcpy(ctx->staging.bssid_addr, bss_conf->bssid, ETH_ALEN);\n\n\tif (vif->type == NL80211_IFTYPE_AP ||\n\t    vif->type == NL80211_IFTYPE_ADHOC) {\n\t\tif (vif->bss_conf.enable_beacon) {\n\t\t\tctx->staging.filter_flags |= RXON_FILTER_ASSOC_MSK;\n\t\t\tpriv->beacon_ctx = ctx;\n\t\t} else {\n\t\t\tctx->staging.filter_flags &= ~RXON_FILTER_ASSOC_MSK;\n\t\t\tpriv->beacon_ctx = NULL;\n\t\t}\n\t}\n\n\t \n\n\tif (vif->type == NL80211_IFTYPE_STATION) {\n\t\tif (!vif->cfg.assoc)\n\t\t\tctx->staging.filter_flags |= RXON_FILTER_BCON_AWARE_MSK;\n\t\telse\n\t\t\tctx->staging.filter_flags &=\n\t\t\t\t\t\t    ~RXON_FILTER_BCON_AWARE_MSK;\n\t}\n\n\tif (force || memcmp(&ctx->staging, &ctx->active, sizeof(ctx->staging)))\n\t\tiwlagn_commit_rxon(priv, ctx);\n\n\tif (changes & BSS_CHANGED_ASSOC && vif->cfg.assoc) {\n\t\t \n\t\tif (priv->chain_noise_data.state == IWL_CHAIN_NOISE_DONE)\n\t\t\tiwl_power_update_mode(priv, false);\n\n\t\t \n\t\tiwlagn_chain_noise_reset(priv);\n\t\tpriv->start_calib = 1;\n\t}\n\n\tif (changes & BSS_CHANGED_IBSS) {\n\t\tret = iwlagn_manage_ibss_station(priv, vif,\n\t\t\t\t\t\t vif->cfg.ibss_joined);\n\t\tif (ret)\n\t\t\tIWL_ERR(priv, \"failed to %s IBSS station %pM\\n\",\n\t\t\t\tvif->cfg.ibss_joined ? \"add\" : \"remove\",\n\t\t\t\tbss_conf->bssid);\n\t}\n\n\tif (changes & BSS_CHANGED_BEACON && priv->beacon_ctx == ctx) {\n\t\tif (iwlagn_update_beacon(priv, vif))\n\t\t\tIWL_ERR(priv, \"Error updating beacon\\n\");\n\t}\n\n\tmutex_unlock(&priv->mutex);\n}\n\nvoid iwlagn_post_scan(struct iwl_priv *priv)\n{\n\tstruct iwl_rxon_context *ctx;\n\n\t \n\tiwl_power_set_mode(priv, &priv->power_data.sleep_cmd_next, false);\n\tiwl_set_tx_power(priv, priv->tx_power_next, false);\n\n\t \n\tfor_each_context(priv, ctx)\n\t\tif (memcmp(&ctx->staging, &ctx->active, sizeof(ctx->staging)))\n\t\t\tiwlagn_commit_rxon(priv, ctx);\n\n\tiwlagn_set_pan_params(priv);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}