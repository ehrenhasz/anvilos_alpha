{
  "module_name": "devices.c",
  "hash_id": "d9afe0374b83cdba2289df0ffd9cb81cdfebedc8890726b16dcb95dd3e763140",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/dvm/devices.c",
  "human_readable_source": "\n \n\n#include <linux/units.h>\n\n \n#include \"iwl-io.h\"\n#include \"iwl-prph.h\"\n#include \"iwl-eeprom-parse.h\"\n\n#include \"agn.h\"\n#include \"dev.h\"\n#include \"commands.h\"\n\n\n \n\n \nstatic void iwl1000_set_ct_threshold(struct iwl_priv *priv)\n{\n\t \n\tpriv->hw_params.ct_kill_threshold = CT_KILL_THRESHOLD_LEGACY;\n\tpriv->hw_params.ct_kill_exit_threshold = CT_KILL_EXIT_THRESHOLD;\n}\n\n \nstatic void iwl1000_nic_config(struct iwl_priv *priv)\n{\n\t \n\t \n\tiwl_set_bits_mask_prph(priv->trans, APMG_DIGITAL_SVR_REG,\n\t\t\t\tAPMG_SVR_DIGITAL_VOLTAGE_1_32,\n\t\t\t\t~APMG_SVR_VOLTAGE_CONFIG_BIT_MSK);\n}\n\n \nstatic inline u32 iwl_beacon_time_mask_low(struct iwl_priv *priv,\n\t\t\t\t\t   u16 tsf_bits)\n{\n\treturn (1 << tsf_bits) - 1;\n}\n\n \nstatic inline u32 iwl_beacon_time_mask_high(struct iwl_priv *priv,\n\t\t\t\t\t    u16 tsf_bits)\n{\n\treturn ((1 << (32 - tsf_bits)) - 1) << tsf_bits;\n}\n\n \nstatic u32 iwl_usecs_to_beacons(struct iwl_priv *priv, u32 usec,\n\t\t\t\tu32 beacon_interval)\n{\n\tu32 quot;\n\tu32 rem;\n\tu32 interval = beacon_interval * TIME_UNIT;\n\n\tif (!interval || !usec)\n\t\treturn 0;\n\n\tquot = (usec / interval) &\n\t\t(iwl_beacon_time_mask_high(priv, IWLAGN_EXT_BEACON_TIME_POS) >>\n\t\tIWLAGN_EXT_BEACON_TIME_POS);\n\trem = (usec % interval) & iwl_beacon_time_mask_low(priv,\n\t\t\t\t   IWLAGN_EXT_BEACON_TIME_POS);\n\n\treturn (quot << IWLAGN_EXT_BEACON_TIME_POS) + rem;\n}\n\n \nstatic __le32 iwl_add_beacon_time(struct iwl_priv *priv, u32 base,\n\t\t\t   u32 addon, u32 beacon_interval)\n{\n\tu32 base_low = base & iwl_beacon_time_mask_low(priv,\n\t\t\t\tIWLAGN_EXT_BEACON_TIME_POS);\n\tu32 addon_low = addon & iwl_beacon_time_mask_low(priv,\n\t\t\t\tIWLAGN_EXT_BEACON_TIME_POS);\n\tu32 interval = beacon_interval * TIME_UNIT;\n\tu32 res = (base & iwl_beacon_time_mask_high(priv,\n\t\t\t\tIWLAGN_EXT_BEACON_TIME_POS)) +\n\t\t\t\t(addon & iwl_beacon_time_mask_high(priv,\n\t\t\t\tIWLAGN_EXT_BEACON_TIME_POS));\n\n\tif (base_low > addon_low)\n\t\tres += base_low - addon_low;\n\telse if (base_low < addon_low) {\n\t\tres += interval + base_low - addon_low;\n\t\tres += (1 << IWLAGN_EXT_BEACON_TIME_POS);\n\t} else\n\t\tres += (1 << IWLAGN_EXT_BEACON_TIME_POS);\n\n\treturn cpu_to_le32(res);\n}\n\nstatic const struct iwl_sensitivity_ranges iwl1000_sensitivity = {\n\t.min_nrg_cck = 95,\n\t.auto_corr_min_ofdm = 90,\n\t.auto_corr_min_ofdm_mrc = 170,\n\t.auto_corr_min_ofdm_x1 = 120,\n\t.auto_corr_min_ofdm_mrc_x1 = 240,\n\n\t.auto_corr_max_ofdm = 120,\n\t.auto_corr_max_ofdm_mrc = 210,\n\t.auto_corr_max_ofdm_x1 = 155,\n\t.auto_corr_max_ofdm_mrc_x1 = 290,\n\n\t.auto_corr_min_cck = 125,\n\t.auto_corr_max_cck = 200,\n\t.auto_corr_min_cck_mrc = 170,\n\t.auto_corr_max_cck_mrc = 400,\n\t.nrg_th_cck = 95,\n\t.nrg_th_ofdm = 95,\n\n\t.barker_corr_th_min = 190,\n\t.barker_corr_th_min_mrc = 390,\n\t.nrg_th_cca = 62,\n};\n\nstatic void iwl1000_hw_set_hw_params(struct iwl_priv *priv)\n{\n\tiwl1000_set_ct_threshold(priv);\n\n\t \n\tpriv->hw_params.sens = &iwl1000_sensitivity;\n}\n\nconst struct iwl_dvm_cfg iwl_dvm_1000_cfg = {\n\t.set_hw_params = iwl1000_hw_set_hw_params,\n\t.nic_config = iwl1000_nic_config,\n\t.temperature = iwlagn_temperature,\n\t.support_ct_kill_exit = true,\n\t.plcp_delta_threshold = IWL_MAX_PLCP_ERR_EXT_LONG_THRESHOLD_DEF,\n\t.chain_noise_scale = 1000,\n};\n\n\n \n\nstatic void iwl2000_set_ct_threshold(struct iwl_priv *priv)\n{\n\t \n\tpriv->hw_params.ct_kill_threshold = CT_KILL_THRESHOLD;\n\tpriv->hw_params.ct_kill_exit_threshold = CT_KILL_EXIT_THRESHOLD;\n}\n\n \nstatic void iwl2000_nic_config(struct iwl_priv *priv)\n{\n\tiwl_set_bit(priv->trans, CSR_GP_DRIVER_REG,\n\t\t    CSR_GP_DRIVER_REG_BIT_RADIO_IQ_INVER);\n}\n\nstatic const struct iwl_sensitivity_ranges iwl2000_sensitivity = {\n\t.min_nrg_cck = 97,\n\t.auto_corr_min_ofdm = 80,\n\t.auto_corr_min_ofdm_mrc = 128,\n\t.auto_corr_min_ofdm_x1 = 105,\n\t.auto_corr_min_ofdm_mrc_x1 = 192,\n\n\t.auto_corr_max_ofdm = 145,\n\t.auto_corr_max_ofdm_mrc = 232,\n\t.auto_corr_max_ofdm_x1 = 110,\n\t.auto_corr_max_ofdm_mrc_x1 = 232,\n\n\t.auto_corr_min_cck = 125,\n\t.auto_corr_max_cck = 175,\n\t.auto_corr_min_cck_mrc = 160,\n\t.auto_corr_max_cck_mrc = 310,\n\t.nrg_th_cck = 97,\n\t.nrg_th_ofdm = 100,\n\n\t.barker_corr_th_min = 190,\n\t.barker_corr_th_min_mrc = 390,\n\t.nrg_th_cca = 62,\n};\n\nstatic void iwl2000_hw_set_hw_params(struct iwl_priv *priv)\n{\n\tiwl2000_set_ct_threshold(priv);\n\n\t \n\tpriv->hw_params.sens = &iwl2000_sensitivity;\n}\n\nconst struct iwl_dvm_cfg iwl_dvm_2000_cfg = {\n\t.set_hw_params = iwl2000_hw_set_hw_params,\n\t.nic_config = iwl2000_nic_config,\n\t.temperature = iwlagn_temperature,\n\t.adv_thermal_throttle = true,\n\t.support_ct_kill_exit = true,\n\t.plcp_delta_threshold = IWL_MAX_PLCP_ERR_THRESHOLD_DEF,\n\t.chain_noise_scale = 1000,\n\t.hd_v2 = true,\n\t.need_temp_offset_calib = true,\n\t.temp_offset_v2 = true,\n};\n\nconst struct iwl_dvm_cfg iwl_dvm_105_cfg = {\n\t.set_hw_params = iwl2000_hw_set_hw_params,\n\t.nic_config = iwl2000_nic_config,\n\t.temperature = iwlagn_temperature,\n\t.adv_thermal_throttle = true,\n\t.support_ct_kill_exit = true,\n\t.plcp_delta_threshold = IWL_MAX_PLCP_ERR_THRESHOLD_DEF,\n\t.chain_noise_scale = 1000,\n\t.hd_v2 = true,\n\t.need_temp_offset_calib = true,\n\t.temp_offset_v2 = true,\n\t.adv_pm = true,\n};\n\nstatic const struct iwl_dvm_bt_params iwl2030_bt_params = {\n\t \n\t.advanced_bt_coexist = true,\n\t.agg_time_limit = BT_AGG_THRESHOLD_DEF,\n\t.bt_init_traffic_load = IWL_BT_COEX_TRAFFIC_LOAD_NONE,\n\t.bt_prio_boost = IWLAGN_BT_PRIO_BOOST_DEFAULT32,\n\t.bt_sco_disable = true,\n\t.bt_session_2 = true,\n};\n\nconst struct iwl_dvm_cfg iwl_dvm_2030_cfg = {\n\t.set_hw_params = iwl2000_hw_set_hw_params,\n\t.nic_config = iwl2000_nic_config,\n\t.temperature = iwlagn_temperature,\n\t.adv_thermal_throttle = true,\n\t.support_ct_kill_exit = true,\n\t.plcp_delta_threshold = IWL_MAX_PLCP_ERR_THRESHOLD_DEF,\n\t.chain_noise_scale = 1000,\n\t.hd_v2 = true,\n\t.bt_params = &iwl2030_bt_params,\n\t.need_temp_offset_calib = true,\n\t.temp_offset_v2 = true,\n\t.adv_pm = true,\n};\n\n \n\n \nstatic const struct iwl_sensitivity_ranges iwl5000_sensitivity = {\n\t.min_nrg_cck = 100,\n\t.auto_corr_min_ofdm = 90,\n\t.auto_corr_min_ofdm_mrc = 170,\n\t.auto_corr_min_ofdm_x1 = 105,\n\t.auto_corr_min_ofdm_mrc_x1 = 220,\n\n\t.auto_corr_max_ofdm = 120,\n\t.auto_corr_max_ofdm_mrc = 210,\n\t.auto_corr_max_ofdm_x1 = 120,\n\t.auto_corr_max_ofdm_mrc_x1 = 240,\n\n\t.auto_corr_min_cck = 125,\n\t.auto_corr_max_cck = 200,\n\t.auto_corr_min_cck_mrc = 200,\n\t.auto_corr_max_cck_mrc = 400,\n\t.nrg_th_cck = 100,\n\t.nrg_th_ofdm = 100,\n\n\t.barker_corr_th_min = 190,\n\t.barker_corr_th_min_mrc = 390,\n\t.nrg_th_cca = 62,\n};\n\nstatic const struct iwl_sensitivity_ranges iwl5150_sensitivity = {\n\t.min_nrg_cck = 95,\n\t.auto_corr_min_ofdm = 90,\n\t.auto_corr_min_ofdm_mrc = 170,\n\t.auto_corr_min_ofdm_x1 = 105,\n\t.auto_corr_min_ofdm_mrc_x1 = 220,\n\n\t.auto_corr_max_ofdm = 120,\n\t.auto_corr_max_ofdm_mrc = 210,\n\t \n\t.auto_corr_max_ofdm_x1 = 105,\n\t.auto_corr_max_ofdm_mrc_x1 = 220,\n\n\t.auto_corr_min_cck = 125,\n\t.auto_corr_max_cck = 200,\n\t.auto_corr_min_cck_mrc = 170,\n\t.auto_corr_max_cck_mrc = 400,\n\t.nrg_th_cck = 95,\n\t.nrg_th_ofdm = 95,\n\n\t.barker_corr_th_min = 190,\n\t.barker_corr_th_min_mrc = 390,\n\t.nrg_th_cca = 62,\n};\n\n#define IWL_5150_VOLTAGE_TO_TEMPERATURE_COEFF\t(-5)\n\nstatic s32 iwl_temp_calib_to_offset(struct iwl_priv *priv)\n{\n\tu16 temperature, voltage;\n\n\ttemperature = le16_to_cpu(priv->nvm_data->kelvin_temperature);\n\tvoltage = le16_to_cpu(priv->nvm_data->kelvin_voltage);\n\n\t \n\treturn (s32)(temperature -\n\t\t\tvoltage / IWL_5150_VOLTAGE_TO_TEMPERATURE_COEFF);\n}\n\nstatic void iwl5150_set_ct_threshold(struct iwl_priv *priv)\n{\n\tconst s32 volt2temp_coef = IWL_5150_VOLTAGE_TO_TEMPERATURE_COEFF;\n\ts32 threshold = (s32)celsius_to_kelvin(CT_KILL_THRESHOLD_LEGACY) -\n\t\t\tiwl_temp_calib_to_offset(priv);\n\n\tpriv->hw_params.ct_kill_threshold = threshold * volt2temp_coef;\n}\n\nstatic void iwl5000_set_ct_threshold(struct iwl_priv *priv)\n{\n\t \n\tpriv->hw_params.ct_kill_threshold = CT_KILL_THRESHOLD_LEGACY;\n}\n\nstatic void iwl5000_hw_set_hw_params(struct iwl_priv *priv)\n{\n\tiwl5000_set_ct_threshold(priv);\n\n\t \n\tpriv->hw_params.sens = &iwl5000_sensitivity;\n}\n\nstatic void iwl5150_hw_set_hw_params(struct iwl_priv *priv)\n{\n\tiwl5150_set_ct_threshold(priv);\n\n\t \n\tpriv->hw_params.sens = &iwl5150_sensitivity;\n}\n\nstatic void iwl5150_temperature(struct iwl_priv *priv)\n{\n\tu32 vt = 0;\n\ts32 offset =  iwl_temp_calib_to_offset(priv);\n\n\tvt = le32_to_cpu(priv->statistics.common.temperature);\n\tvt = vt / IWL_5150_VOLTAGE_TO_TEMPERATURE_COEFF + offset;\n\t \n\tpriv->temperature = kelvin_to_celsius(vt);\n\tiwl_tt_handler(priv);\n}\n\nstatic int iwl5000_hw_channel_switch(struct iwl_priv *priv,\n\t\t\t\t     struct ieee80211_channel_switch *ch_switch)\n{\n\t \n\tstruct iwl_rxon_context *ctx = &priv->contexts[IWL_RXON_CTX_BSS];\n\tstruct iwl5000_channel_switch_cmd cmd;\n\tu32 switch_time_in_usec, ucode_switch_time;\n\tu16 ch;\n\tu32 tsf_low;\n\tu8 switch_count;\n\tu16 beacon_interval = le16_to_cpu(ctx->timing.beacon_interval);\n\tstruct ieee80211_vif *vif = ctx->vif;\n\tstruct iwl_host_cmd hcmd = {\n\t\t.id = REPLY_CHANNEL_SWITCH,\n\t\t.len = { sizeof(cmd), },\n\t\t.data = { &cmd, },\n\t};\n\n\tcmd.band = priv->band == NL80211_BAND_2GHZ;\n\tch = ch_switch->chandef.chan->hw_value;\n\tIWL_DEBUG_11H(priv, \"channel switch from %d to %d\\n\",\n\t\t      ctx->active.channel, ch);\n\tcmd.channel = cpu_to_le16(ch);\n\tcmd.rxon_flags = ctx->staging.flags;\n\tcmd.rxon_filter_flags = ctx->staging.filter_flags;\n\tswitch_count = ch_switch->count;\n\ttsf_low = ch_switch->timestamp & 0x0ffffffff;\n\t \n\tif ((priv->ucode_beacon_time > tsf_low) && beacon_interval) {\n\t\tif (switch_count > ((priv->ucode_beacon_time - tsf_low) /\n\t\t    beacon_interval)) {\n\t\t\tswitch_count -= (priv->ucode_beacon_time -\n\t\t\t\ttsf_low) / beacon_interval;\n\t\t} else\n\t\t\tswitch_count = 0;\n\t}\n\tif (switch_count <= 1)\n\t\tcmd.switch_time = cpu_to_le32(priv->ucode_beacon_time);\n\telse {\n\t\tswitch_time_in_usec =\n\t\t\tvif->bss_conf.beacon_int * switch_count * TIME_UNIT;\n\t\tucode_switch_time = iwl_usecs_to_beacons(priv,\n\t\t\t\t\t\t\t switch_time_in_usec,\n\t\t\t\t\t\t\t beacon_interval);\n\t\tcmd.switch_time = iwl_add_beacon_time(priv,\n\t\t\t\t\t\t      priv->ucode_beacon_time,\n\t\t\t\t\t\t      ucode_switch_time,\n\t\t\t\t\t\t      beacon_interval);\n\t}\n\tIWL_DEBUG_11H(priv, \"uCode time for the switch is 0x%x\\n\",\n\t\t      cmd.switch_time);\n\tcmd.expect_beacon =\n\t\tch_switch->chandef.chan->flags & IEEE80211_CHAN_RADAR;\n\n\treturn iwl_dvm_send_cmd(priv, &hcmd);\n}\n\nconst struct iwl_dvm_cfg iwl_dvm_5000_cfg = {\n\t.set_hw_params = iwl5000_hw_set_hw_params,\n\t.set_channel_switch = iwl5000_hw_channel_switch,\n\t.temperature = iwlagn_temperature,\n\t.plcp_delta_threshold = IWL_MAX_PLCP_ERR_LONG_THRESHOLD_DEF,\n\t.chain_noise_scale = 1000,\n\t.no_idle_support = true,\n};\n\nconst struct iwl_dvm_cfg iwl_dvm_5150_cfg = {\n\t.set_hw_params = iwl5150_hw_set_hw_params,\n\t.set_channel_switch = iwl5000_hw_channel_switch,\n\t.temperature = iwl5150_temperature,\n\t.plcp_delta_threshold = IWL_MAX_PLCP_ERR_LONG_THRESHOLD_DEF,\n\t.chain_noise_scale = 1000,\n\t.no_idle_support = true,\n\t.no_xtal_calib = true,\n};\n\n\n\n \n\nstatic void iwl6000_set_ct_threshold(struct iwl_priv *priv)\n{\n\t \n\tpriv->hw_params.ct_kill_threshold = CT_KILL_THRESHOLD;\n\tpriv->hw_params.ct_kill_exit_threshold = CT_KILL_EXIT_THRESHOLD;\n}\n\n \nstatic void iwl6000_nic_config(struct iwl_priv *priv)\n{\n\tswitch (priv->trans->trans_cfg->device_family) {\n\tcase IWL_DEVICE_FAMILY_6005:\n\tcase IWL_DEVICE_FAMILY_6030:\n\tcase IWL_DEVICE_FAMILY_6000:\n\t\tbreak;\n\tcase IWL_DEVICE_FAMILY_6000i:\n\t\t \n\t\tiwl_write32(priv->trans, CSR_GP_DRIVER_REG,\n\t\t\t     CSR_GP_DRIVER_REG_BIT_RADIO_SKU_2x2_IPA);\n\t\tbreak;\n\tcase IWL_DEVICE_FAMILY_6050:\n\t\t \n\t\tif (priv->nvm_data->calib_version >= 6)\n\t\t\tiwl_set_bit(priv->trans, CSR_GP_DRIVER_REG,\n\t\t\t\t\tCSR_GP_DRIVER_REG_BIT_CALIB_VERSION6);\n\t\tbreak;\n\tcase IWL_DEVICE_FAMILY_6150:\n\t\t \n\t\tif (priv->nvm_data->calib_version >= 6)\n\t\t\tiwl_set_bit(priv->trans, CSR_GP_DRIVER_REG,\n\t\t\t\t\tCSR_GP_DRIVER_REG_BIT_CALIB_VERSION6);\n\t\tiwl_set_bit(priv->trans, CSR_GP_DRIVER_REG,\n\t\t\t    CSR_GP_DRIVER_REG_BIT_6050_1x2);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n}\n\nstatic const struct iwl_sensitivity_ranges iwl6000_sensitivity = {\n\t.min_nrg_cck = 110,\n\t.auto_corr_min_ofdm = 80,\n\t.auto_corr_min_ofdm_mrc = 128,\n\t.auto_corr_min_ofdm_x1 = 105,\n\t.auto_corr_min_ofdm_mrc_x1 = 192,\n\n\t.auto_corr_max_ofdm = 145,\n\t.auto_corr_max_ofdm_mrc = 232,\n\t.auto_corr_max_ofdm_x1 = 110,\n\t.auto_corr_max_ofdm_mrc_x1 = 232,\n\n\t.auto_corr_min_cck = 125,\n\t.auto_corr_max_cck = 175,\n\t.auto_corr_min_cck_mrc = 160,\n\t.auto_corr_max_cck_mrc = 310,\n\t.nrg_th_cck = 110,\n\t.nrg_th_ofdm = 110,\n\n\t.barker_corr_th_min = 190,\n\t.barker_corr_th_min_mrc = 336,\n\t.nrg_th_cca = 62,\n};\n\nstatic void iwl6000_hw_set_hw_params(struct iwl_priv *priv)\n{\n\tiwl6000_set_ct_threshold(priv);\n\n\t \n\tpriv->hw_params.sens = &iwl6000_sensitivity;\n\n}\n\nstatic int iwl6000_hw_channel_switch(struct iwl_priv *priv,\n\t\t\t\t     struct ieee80211_channel_switch *ch_switch)\n{\n\t \n\tstruct iwl_rxon_context *ctx = &priv->contexts[IWL_RXON_CTX_BSS];\n\tstruct iwl6000_channel_switch_cmd *cmd;\n\tu32 switch_time_in_usec, ucode_switch_time;\n\tu16 ch;\n\tu32 tsf_low;\n\tu8 switch_count;\n\tu16 beacon_interval = le16_to_cpu(ctx->timing.beacon_interval);\n\tstruct ieee80211_vif *vif = ctx->vif;\n\tstruct iwl_host_cmd hcmd = {\n\t\t.id = REPLY_CHANNEL_SWITCH,\n\t\t.len = { sizeof(*cmd), },\n\t\t.dataflags[0] = IWL_HCMD_DFL_NOCOPY,\n\t};\n\tint err;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\thcmd.data[0] = cmd;\n\n\tcmd->band = priv->band == NL80211_BAND_2GHZ;\n\tch = ch_switch->chandef.chan->hw_value;\n\tIWL_DEBUG_11H(priv, \"channel switch from %u to %u\\n\",\n\t\t      ctx->active.channel, ch);\n\tcmd->channel = cpu_to_le16(ch);\n\tcmd->rxon_flags = ctx->staging.flags;\n\tcmd->rxon_filter_flags = ctx->staging.filter_flags;\n\tswitch_count = ch_switch->count;\n\ttsf_low = ch_switch->timestamp & 0x0ffffffff;\n\t \n\tif ((priv->ucode_beacon_time > tsf_low) && beacon_interval) {\n\t\tif (switch_count > ((priv->ucode_beacon_time - tsf_low) /\n\t\t    beacon_interval)) {\n\t\t\tswitch_count -= (priv->ucode_beacon_time -\n\t\t\t\ttsf_low) / beacon_interval;\n\t\t} else\n\t\t\tswitch_count = 0;\n\t}\n\tif (switch_count <= 1)\n\t\tcmd->switch_time = cpu_to_le32(priv->ucode_beacon_time);\n\telse {\n\t\tswitch_time_in_usec =\n\t\t\tvif->bss_conf.beacon_int * switch_count * TIME_UNIT;\n\t\tucode_switch_time = iwl_usecs_to_beacons(priv,\n\t\t\t\t\t\t\t switch_time_in_usec,\n\t\t\t\t\t\t\t beacon_interval);\n\t\tcmd->switch_time = iwl_add_beacon_time(priv,\n\t\t\t\t\t\t       priv->ucode_beacon_time,\n\t\t\t\t\t\t       ucode_switch_time,\n\t\t\t\t\t\t       beacon_interval);\n\t}\n\tIWL_DEBUG_11H(priv, \"uCode time for the switch is 0x%x\\n\",\n\t\t      cmd->switch_time);\n\tcmd->expect_beacon =\n\t\tch_switch->chandef.chan->flags & IEEE80211_CHAN_RADAR;\n\n\terr = iwl_dvm_send_cmd(priv, &hcmd);\n\tkfree(cmd);\n\treturn err;\n}\n\nconst struct iwl_dvm_cfg iwl_dvm_6000_cfg = {\n\t.set_hw_params = iwl6000_hw_set_hw_params,\n\t.set_channel_switch = iwl6000_hw_channel_switch,\n\t.nic_config = iwl6000_nic_config,\n\t.temperature = iwlagn_temperature,\n\t.adv_thermal_throttle = true,\n\t.support_ct_kill_exit = true,\n\t.plcp_delta_threshold = IWL_MAX_PLCP_ERR_THRESHOLD_DEF,\n\t.chain_noise_scale = 1000,\n};\n\nconst struct iwl_dvm_cfg iwl_dvm_6005_cfg = {\n\t.set_hw_params = iwl6000_hw_set_hw_params,\n\t.set_channel_switch = iwl6000_hw_channel_switch,\n\t.nic_config = iwl6000_nic_config,\n\t.temperature = iwlagn_temperature,\n\t.adv_thermal_throttle = true,\n\t.support_ct_kill_exit = true,\n\t.plcp_delta_threshold = IWL_MAX_PLCP_ERR_THRESHOLD_DEF,\n\t.chain_noise_scale = 1000,\n\t.need_temp_offset_calib = true,\n};\n\nconst struct iwl_dvm_cfg iwl_dvm_6050_cfg = {\n\t.set_hw_params = iwl6000_hw_set_hw_params,\n\t.set_channel_switch = iwl6000_hw_channel_switch,\n\t.nic_config = iwl6000_nic_config,\n\t.temperature = iwlagn_temperature,\n\t.adv_thermal_throttle = true,\n\t.support_ct_kill_exit = true,\n\t.plcp_delta_threshold = IWL_MAX_PLCP_ERR_THRESHOLD_DEF,\n\t.chain_noise_scale = 1500,\n};\n\nstatic const struct iwl_dvm_bt_params iwl6000_bt_params = {\n\t \n\t.advanced_bt_coexist = true,\n\t.agg_time_limit = BT_AGG_THRESHOLD_DEF,\n\t.bt_init_traffic_load = IWL_BT_COEX_TRAFFIC_LOAD_NONE,\n\t.bt_prio_boost = IWLAGN_BT_PRIO_BOOST_DEFAULT,\n\t.bt_sco_disable = true,\n};\n\nconst struct iwl_dvm_cfg iwl_dvm_6030_cfg = {\n\t.set_hw_params = iwl6000_hw_set_hw_params,\n\t.set_channel_switch = iwl6000_hw_channel_switch,\n\t.nic_config = iwl6000_nic_config,\n\t.temperature = iwlagn_temperature,\n\t.adv_thermal_throttle = true,\n\t.support_ct_kill_exit = true,\n\t.plcp_delta_threshold = IWL_MAX_PLCP_ERR_THRESHOLD_DEF,\n\t.chain_noise_scale = 1000,\n\t.bt_params = &iwl6000_bt_params,\n\t.need_temp_offset_calib = true,\n\t.adv_pm = true,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}