{
  "module_name": "led.c",
  "hash_id": "fa913ef73fd65881ba5bc84e87c8fc3b758a9c3a2d7f4ecc28c7c1960c88124b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/dvm/led.c",
  "human_readable_source": "\n \n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <net/mac80211.h>\n#include <linux/etherdevice.h>\n#include <asm/unaligned.h>\n#include \"iwl-io.h\"\n#include \"iwl-trans.h\"\n#include \"iwl-modparams.h\"\n#include \"dev.h\"\n#include \"agn.h\"\n\n \nstatic const struct ieee80211_tpt_blink iwl_blink[] = {\n\t{ .throughput = 0, .blink_time = 334 },\n\t{ .throughput = 1 * 1024 - 1, .blink_time = 260 },\n\t{ .throughput = 5 * 1024 - 1, .blink_time = 220 },\n\t{ .throughput = 10 * 1024 - 1, .blink_time = 190 },\n\t{ .throughput = 20 * 1024 - 1, .blink_time = 170 },\n\t{ .throughput = 50 * 1024 - 1, .blink_time = 150 },\n\t{ .throughput = 70 * 1024 - 1, .blink_time = 130 },\n\t{ .throughput = 100 * 1024 - 1, .blink_time = 110 },\n\t{ .throughput = 200 * 1024 - 1, .blink_time = 80 },\n\t{ .throughput = 300 * 1024 - 1, .blink_time = 50 },\n};\n\n \nvoid iwlagn_led_enable(struct iwl_priv *priv)\n{\n\tiwl_write32(priv->trans, CSR_LED_REG, CSR_LED_REG_TURN_ON);\n}\n\n \nstatic inline u8 iwl_blink_compensation(struct iwl_priv *priv,\n\t\t\t\t    u8 time, u16 compensation)\n{\n\tif (!compensation) {\n\t\tIWL_ERR(priv, \"undefined blink compensation: \"\n\t\t\t\"use pre-defined blinking time\\n\");\n\t\treturn time;\n\t}\n\n\treturn (u8)((time * compensation) >> 6);\n}\n\nstatic int iwl_send_led_cmd(struct iwl_priv *priv, struct iwl_led_cmd *led_cmd)\n{\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = REPLY_LEDS_CMD,\n\t\t.len = { sizeof(struct iwl_led_cmd), },\n\t\t.data = { led_cmd, },\n\t\t.flags = CMD_ASYNC,\n\t};\n\tu32 reg;\n\n\treg = iwl_read32(priv->trans, CSR_LED_REG);\n\tif (reg != (reg & CSR_LED_BSM_CTRL_MSK))\n\t\tiwl_write32(priv->trans, CSR_LED_REG,\n\t\t\t    reg & CSR_LED_BSM_CTRL_MSK);\n\n\treturn iwl_dvm_send_cmd(priv, &cmd);\n}\n\n \nstatic int iwl_led_cmd(struct iwl_priv *priv,\n\t\t       unsigned long on,\n\t\t       unsigned long off)\n{\n\tstruct iwl_led_cmd led_cmd = {\n\t\t.id = IWL_LED_LINK,\n\t\t.interval = IWL_DEF_LED_INTRVL\n\t};\n\tint ret;\n\n\tif (!test_bit(STATUS_READY, &priv->status))\n\t\treturn -EBUSY;\n\n\tif (priv->blink_on == on && priv->blink_off == off)\n\t\treturn 0;\n\n\tif (off == 0) {\n\t\t \n\t\ton = IWL_LED_SOLID;\n\t}\n\n\tled_cmd.on = iwl_blink_compensation(priv, on,\n\t\t\t\tpriv->trans->trans_cfg->base_params->led_compensation);\n\tled_cmd.off = iwl_blink_compensation(priv, off,\n\t\t\t\tpriv->trans->trans_cfg->base_params->led_compensation);\n\n\tret = iwl_send_led_cmd(priv, &led_cmd);\n\tif (!ret) {\n\t\tpriv->blink_on = on;\n\t\tpriv->blink_off = off;\n\t}\n\treturn ret;\n}\n\nstatic void iwl_led_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t   enum led_brightness brightness)\n{\n\tstruct iwl_priv *priv = container_of(led_cdev, struct iwl_priv, led);\n\tunsigned long on = 0;\n\tunsigned long off = 0;\n\n\tif (brightness > 0)\n\t\ton = IWL_LED_SOLID;\n\telse\n\t\toff = IWL_LED_SOLID;\n\n\tiwl_led_cmd(priv, on, off);\n}\n\nstatic int iwl_led_blink_set(struct led_classdev *led_cdev,\n\t\t\t     unsigned long *delay_on,\n\t\t\t     unsigned long *delay_off)\n{\n\tstruct iwl_priv *priv = container_of(led_cdev, struct iwl_priv, led);\n\n\treturn iwl_led_cmd(priv, *delay_on, *delay_off);\n}\n\nvoid iwl_leds_init(struct iwl_priv *priv)\n{\n\tint mode = iwlwifi_mod_params.led_mode;\n\tint ret;\n\n\tif (mode == IWL_LED_DISABLE) {\n\t\tIWL_INFO(priv, \"Led disabled\\n\");\n\t\treturn;\n\t}\n\tif (mode == IWL_LED_DEFAULT)\n\t\tmode = priv->cfg->led_mode;\n\n\tpriv->led.name = kasprintf(GFP_KERNEL, \"%s-led\",\n\t\t\t\t   wiphy_name(priv->hw->wiphy));\n\tif (!priv->led.name)\n\t\treturn;\n\n\tpriv->led.brightness_set = iwl_led_brightness_set;\n\tpriv->led.blink_set = iwl_led_blink_set;\n\tpriv->led.max_brightness = 1;\n\n\tswitch (mode) {\n\tcase IWL_LED_DEFAULT:\n\t\tWARN_ON(1);\n\t\tbreak;\n\tcase IWL_LED_BLINK:\n\t\tpriv->led.default_trigger =\n\t\t\tieee80211_create_tpt_led_trigger(priv->hw,\n\t\t\t\t\tIEEE80211_TPT_LEDTRIG_FL_CONNECTED,\n\t\t\t\t\tiwl_blink, ARRAY_SIZE(iwl_blink));\n\t\tbreak;\n\tcase IWL_LED_RF_STATE:\n\t\tpriv->led.default_trigger =\n\t\t\tieee80211_get_radio_led_name(priv->hw);\n\t\tbreak;\n\t}\n\n\tret = led_classdev_register(priv->trans->dev, &priv->led);\n\tif (ret) {\n\t\tkfree(priv->led.name);\n\t\treturn;\n\t}\n\n\tpriv->led_registered = true;\n}\n\nvoid iwl_leds_exit(struct iwl_priv *priv)\n{\n\tif (!priv->led_registered)\n\t\treturn;\n\n\tled_classdev_unregister(&priv->led);\n\tkfree(priv->led.name);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}