{
  "module_name": "calib.c",
  "hash_id": "9b2c53e8b0cd7775ddfdfd1ce653006855c4639c7aeea37ffefe94c7facbf744",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/dvm/calib.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include <net/mac80211.h>\n\n#include \"iwl-trans.h\"\n\n#include \"dev.h\"\n#include \"calib.h\"\n#include \"agn.h\"\n\n \n\n \nstruct iwl_calib_result {\n\tstruct list_head list;\n\tsize_t cmd_len;\n\tstruct iwl_calib_cmd cmd;\n};\n\nstruct statistics_general_data {\n\tu32 beacon_silence_rssi_a;\n\tu32 beacon_silence_rssi_b;\n\tu32 beacon_silence_rssi_c;\n\tu32 beacon_energy_a;\n\tu32 beacon_energy_b;\n\tu32 beacon_energy_c;\n};\n\nint iwl_send_calib_results(struct iwl_priv *priv)\n{\n\tstruct iwl_host_cmd hcmd = {\n\t\t.id = REPLY_PHY_CALIBRATION_CMD,\n\t};\n\tstruct iwl_calib_result *res;\n\n\tlist_for_each_entry(res, &priv->calib_results, list) {\n\t\tint ret;\n\n\t\thcmd.len[0] = res->cmd_len;\n\t\thcmd.data[0] = &res->cmd;\n\t\thcmd.dataflags[0] = IWL_HCMD_DFL_NOCOPY;\n\t\tret = iwl_dvm_send_cmd(priv, &hcmd);\n\t\tif (ret) {\n\t\t\tIWL_ERR(priv, \"Error %d on calib cmd %d\\n\",\n\t\t\t\tret, res->cmd.hdr.op_code);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint iwl_calib_set(struct iwl_priv *priv,\n\t\t  const struct iwl_calib_cmd *cmd, size_t len)\n{\n\tstruct iwl_calib_result *res, *tmp;\n\n\tif (check_sub_overflow(len, sizeof(*cmd), &len))\n\t\treturn -ENOMEM;\n\n\tres = kmalloc(struct_size(res, cmd.data, len), GFP_ATOMIC);\n\tif (!res)\n\t\treturn -ENOMEM;\n\tres->cmd = *cmd;\n\tmemcpy(res->cmd.data, cmd->data, len);\n\tres->cmd_len = struct_size(cmd, data, len);\n\n\tlist_for_each_entry(tmp, &priv->calib_results, list) {\n\t\tif (tmp->cmd.hdr.op_code == res->cmd.hdr.op_code) {\n\t\t\tlist_replace(&tmp->list, &res->list);\n\t\t\tkfree(tmp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tlist_add_tail(&res->list, &priv->calib_results);\n\n\treturn 0;\n}\n\nvoid iwl_calib_free_results(struct iwl_priv *priv)\n{\n\tstruct iwl_calib_result *res, *tmp;\n\n\tlist_for_each_entry_safe(res, tmp, &priv->calib_results, list) {\n\t\tlist_del(&res->list);\n\t\tkfree(res);\n\t}\n}\n\n \n\n \nstatic int iwl_sens_energy_cck(struct iwl_priv *priv,\n\t\t\t\t   u32 norm_fa,\n\t\t\t\t   u32 rx_enable_time,\n\t\t\t\t   struct statistics_general_data *rx_info)\n{\n\tu32 max_nrg_cck = 0;\n\tint i = 0;\n\tu8 max_silence_rssi = 0;\n\tu32 silence_ref = 0;\n\tu8 silence_rssi_a = 0;\n\tu8 silence_rssi_b = 0;\n\tu8 silence_rssi_c = 0;\n\tu32 val;\n\n\t \n\tu32 false_alarms = norm_fa * 200 * 1024;\n\tu32 max_false_alarms = MAX_FA_CCK * rx_enable_time;\n\tu32 min_false_alarms = MIN_FA_CCK * rx_enable_time;\n\tstruct iwl_sensitivity_data *data = NULL;\n\tconst struct iwl_sensitivity_ranges *ranges = priv->hw_params.sens;\n\n\tdata = &(priv->sensitivity_data);\n\n\tdata->nrg_auto_corr_silence_diff = 0;\n\n\t \n\tsilence_rssi_a = (u8)((rx_info->beacon_silence_rssi_a &\n\t\t\t    ALL_BAND_FILTER) >> 8);\n\tsilence_rssi_b = (u8)((rx_info->beacon_silence_rssi_b &\n\t\t\t    ALL_BAND_FILTER) >> 8);\n\tsilence_rssi_c = (u8)((rx_info->beacon_silence_rssi_c &\n\t\t\t    ALL_BAND_FILTER) >> 8);\n\n\tval = max(silence_rssi_b, silence_rssi_c);\n\tmax_silence_rssi = max(silence_rssi_a, (u8) val);\n\n\t \n\tdata->nrg_silence_rssi[data->nrg_silence_idx] = max_silence_rssi;\n\tdata->nrg_silence_idx++;\n\tif (data->nrg_silence_idx >= NRG_NUM_PREV_STAT_L)\n\t\tdata->nrg_silence_idx = 0;\n\n\t \n\tfor (i = 0; i < NRG_NUM_PREV_STAT_L; i++) {\n\t\tval = data->nrg_silence_rssi[i];\n\t\tsilence_ref = max(silence_ref, val);\n\t}\n\tIWL_DEBUG_CALIB(priv, \"silence a %u, b %u, c %u, 20-bcn max %u\\n\",\n\t\t\tsilence_rssi_a, silence_rssi_b, silence_rssi_c,\n\t\t\tsilence_ref);\n\n\t \n\ti = data->nrg_energy_idx;\n\tval = min(rx_info->beacon_energy_b, rx_info->beacon_energy_c);\n\tdata->nrg_value[i] = min(rx_info->beacon_energy_a, val);\n\n\tdata->nrg_energy_idx++;\n\tif (data->nrg_energy_idx >= 10)\n\t\tdata->nrg_energy_idx = 0;\n\n\t \n\tmax_nrg_cck = data->nrg_value[0];\n\tfor (i = 1; i < 10; i++)\n\t\tmax_nrg_cck = (u32) max(max_nrg_cck, (data->nrg_value[i]));\n\tmax_nrg_cck += 6;\n\n\tIWL_DEBUG_CALIB(priv, \"rx energy a %u, b %u, c %u, 10-bcn max/min %u\\n\",\n\t\t\trx_info->beacon_energy_a, rx_info->beacon_energy_b,\n\t\t\trx_info->beacon_energy_c, max_nrg_cck - 6);\n\n\t \n\tif (false_alarms < min_false_alarms)\n\t\tdata->num_in_cck_no_fa++;\n\telse\n\t\tdata->num_in_cck_no_fa = 0;\n\tIWL_DEBUG_CALIB(priv, \"consecutive bcns with few false alarms = %u\\n\",\n\t\t\tdata->num_in_cck_no_fa);\n\n\t \n\tif ((false_alarms > max_false_alarms) &&\n\t\t(data->auto_corr_cck > AUTO_CORR_MAX_TH_CCK)) {\n\t\tIWL_DEBUG_CALIB(priv, \"norm FA %u > max FA %u\\n\",\n\t\t     false_alarms, max_false_alarms);\n\t\tIWL_DEBUG_CALIB(priv, \"... reducing sensitivity\\n\");\n\t\tdata->nrg_curr_state = IWL_FA_TOO_MANY;\n\t\t \n\t\tdata->nrg_silence_ref = silence_ref;\n\n\t\t \n\t\tdata->nrg_th_cck = data->nrg_th_cck - NRG_STEP_CCK;\n\t \n\t} else if (false_alarms < min_false_alarms) {\n\t\tdata->nrg_curr_state = IWL_FA_TOO_FEW;\n\n\t\t \n\t\tdata->nrg_auto_corr_silence_diff = (s32)data->nrg_silence_ref -\n\t\t\t\t\t\t   (s32)silence_ref;\n\n\t\tIWL_DEBUG_CALIB(priv, \"norm FA %u < min FA %u, silence diff %d\\n\",\n\t\t\t false_alarms, min_false_alarms,\n\t\t\t data->nrg_auto_corr_silence_diff);\n\n\t\t \n\t\tif ((data->nrg_prev_state != IWL_FA_TOO_MANY) &&\n\t\t\t((data->nrg_auto_corr_silence_diff > NRG_DIFF) ||\n\t\t\t(data->num_in_cck_no_fa > MAX_NUMBER_CCK_NO_FA))) {\n\n\t\t\tIWL_DEBUG_CALIB(priv, \"... increasing sensitivity\\n\");\n\t\t\t \n\t\t\tval = data->nrg_th_cck + NRG_STEP_CCK;\n\t\t\tdata->nrg_th_cck = min((u32)ranges->min_nrg_cck, val);\n\t\t} else {\n\t\t\tIWL_DEBUG_CALIB(priv, \"... but not changing sensitivity\\n\");\n\t\t}\n\n\t \n\t} else {\n\t\tIWL_DEBUG_CALIB(priv, \" FA in safe zone\\n\");\n\t\tdata->nrg_curr_state = IWL_FA_GOOD_RANGE;\n\n\t\t \n\t\tdata->nrg_silence_ref = silence_ref;\n\n\t\t \n\t\tif (data->nrg_prev_state == IWL_FA_TOO_MANY) {\n\t\t\tIWL_DEBUG_CALIB(priv, \"... increasing margin\\n\");\n\t\t\tif (data->nrg_th_cck > (max_nrg_cck + NRG_MARGIN))\n\t\t\t\tdata->nrg_th_cck -= NRG_MARGIN;\n\t\t\telse\n\t\t\t\tdata->nrg_th_cck = max_nrg_cck;\n\t\t}\n\t}\n\n\t \n\tdata->nrg_th_cck = max(max_nrg_cck, data->nrg_th_cck);\n\tIWL_DEBUG_CALIB(priv, \"new nrg_th_cck %u\\n\", data->nrg_th_cck);\n\n\tdata->nrg_prev_state = data->nrg_curr_state;\n\n\t \n\tif (false_alarms > min_false_alarms) {\n\n\t\t \n\t\tif (data->auto_corr_cck < AUTO_CORR_MAX_TH_CCK)\n\t\t\tdata->auto_corr_cck = AUTO_CORR_MAX_TH_CCK + 1;\n\t\telse {\n\t\t\tval = data->auto_corr_cck + AUTO_CORR_STEP_CCK;\n\t\t\tdata->auto_corr_cck =\n\t\t\t\tmin((u32)ranges->auto_corr_max_cck, val);\n\t\t}\n\t\tval = data->auto_corr_cck_mrc + AUTO_CORR_STEP_CCK;\n\t\tdata->auto_corr_cck_mrc =\n\t\t\tmin((u32)ranges->auto_corr_max_cck_mrc, val);\n\t} else if ((false_alarms < min_false_alarms) &&\n\t   ((data->nrg_auto_corr_silence_diff > NRG_DIFF) ||\n\t   (data->num_in_cck_no_fa > MAX_NUMBER_CCK_NO_FA))) {\n\n\t\t \n\t\tval = data->auto_corr_cck - AUTO_CORR_STEP_CCK;\n\t\tdata->auto_corr_cck =\n\t\t\tmax((u32)ranges->auto_corr_min_cck, val);\n\t\tval = data->auto_corr_cck_mrc - AUTO_CORR_STEP_CCK;\n\t\tdata->auto_corr_cck_mrc =\n\t\t\tmax((u32)ranges->auto_corr_min_cck_mrc, val);\n\t}\n\n\treturn 0;\n}\n\n\nstatic int iwl_sens_auto_corr_ofdm(struct iwl_priv *priv,\n\t\t\t\t       u32 norm_fa,\n\t\t\t\t       u32 rx_enable_time)\n{\n\tu32 val;\n\tu32 false_alarms = norm_fa * 200 * 1024;\n\tu32 max_false_alarms = MAX_FA_OFDM * rx_enable_time;\n\tu32 min_false_alarms = MIN_FA_OFDM * rx_enable_time;\n\tstruct iwl_sensitivity_data *data = NULL;\n\tconst struct iwl_sensitivity_ranges *ranges = priv->hw_params.sens;\n\n\tdata = &(priv->sensitivity_data);\n\n\t \n\tif (false_alarms > max_false_alarms) {\n\n\t\tIWL_DEBUG_CALIB(priv, \"norm FA %u > max FA %u)\\n\",\n\t\t\t     false_alarms, max_false_alarms);\n\n\t\tval = data->auto_corr_ofdm + AUTO_CORR_STEP_OFDM;\n\t\tdata->auto_corr_ofdm =\n\t\t\tmin((u32)ranges->auto_corr_max_ofdm, val);\n\n\t\tval = data->auto_corr_ofdm_mrc + AUTO_CORR_STEP_OFDM;\n\t\tdata->auto_corr_ofdm_mrc =\n\t\t\tmin((u32)ranges->auto_corr_max_ofdm_mrc, val);\n\n\t\tval = data->auto_corr_ofdm_x1 + AUTO_CORR_STEP_OFDM;\n\t\tdata->auto_corr_ofdm_x1 =\n\t\t\tmin((u32)ranges->auto_corr_max_ofdm_x1, val);\n\n\t\tval = data->auto_corr_ofdm_mrc_x1 + AUTO_CORR_STEP_OFDM;\n\t\tdata->auto_corr_ofdm_mrc_x1 =\n\t\t\tmin((u32)ranges->auto_corr_max_ofdm_mrc_x1, val);\n\t}\n\n\t \n\telse if (false_alarms < min_false_alarms) {\n\n\t\tIWL_DEBUG_CALIB(priv, \"norm FA %u < min FA %u\\n\",\n\t\t\t     false_alarms, min_false_alarms);\n\n\t\tval = data->auto_corr_ofdm - AUTO_CORR_STEP_OFDM;\n\t\tdata->auto_corr_ofdm =\n\t\t\tmax((u32)ranges->auto_corr_min_ofdm, val);\n\n\t\tval = data->auto_corr_ofdm_mrc - AUTO_CORR_STEP_OFDM;\n\t\tdata->auto_corr_ofdm_mrc =\n\t\t\tmax((u32)ranges->auto_corr_min_ofdm_mrc, val);\n\n\t\tval = data->auto_corr_ofdm_x1 - AUTO_CORR_STEP_OFDM;\n\t\tdata->auto_corr_ofdm_x1 =\n\t\t\tmax((u32)ranges->auto_corr_min_ofdm_x1, val);\n\n\t\tval = data->auto_corr_ofdm_mrc_x1 - AUTO_CORR_STEP_OFDM;\n\t\tdata->auto_corr_ofdm_mrc_x1 =\n\t\t\tmax((u32)ranges->auto_corr_min_ofdm_mrc_x1, val);\n\t} else {\n\t\tIWL_DEBUG_CALIB(priv, \"min FA %u < norm FA %u < max FA %u OK\\n\",\n\t\t\t min_false_alarms, false_alarms, max_false_alarms);\n\t}\n\treturn 0;\n}\n\nstatic void iwl_prepare_legacy_sensitivity_tbl(struct iwl_priv *priv,\n\t\t\t\tstruct iwl_sensitivity_data *data,\n\t\t\t\t__le16 *tbl)\n{\n\ttbl[HD_AUTO_CORR32_X4_TH_ADD_MIN_INDEX] =\n\t\t\t\tcpu_to_le16((u16)data->auto_corr_ofdm);\n\ttbl[HD_AUTO_CORR32_X4_TH_ADD_MIN_MRC_INDEX] =\n\t\t\t\tcpu_to_le16((u16)data->auto_corr_ofdm_mrc);\n\ttbl[HD_AUTO_CORR32_X1_TH_ADD_MIN_INDEX] =\n\t\t\t\tcpu_to_le16((u16)data->auto_corr_ofdm_x1);\n\ttbl[HD_AUTO_CORR32_X1_TH_ADD_MIN_MRC_INDEX] =\n\t\t\t\tcpu_to_le16((u16)data->auto_corr_ofdm_mrc_x1);\n\n\ttbl[HD_AUTO_CORR40_X4_TH_ADD_MIN_INDEX] =\n\t\t\t\tcpu_to_le16((u16)data->auto_corr_cck);\n\ttbl[HD_AUTO_CORR40_X4_TH_ADD_MIN_MRC_INDEX] =\n\t\t\t\tcpu_to_le16((u16)data->auto_corr_cck_mrc);\n\n\ttbl[HD_MIN_ENERGY_CCK_DET_INDEX] =\n\t\t\t\tcpu_to_le16((u16)data->nrg_th_cck);\n\ttbl[HD_MIN_ENERGY_OFDM_DET_INDEX] =\n\t\t\t\tcpu_to_le16((u16)data->nrg_th_ofdm);\n\n\ttbl[HD_BARKER_CORR_TH_ADD_MIN_INDEX] =\n\t\t\t\tcpu_to_le16(data->barker_corr_th_min);\n\ttbl[HD_BARKER_CORR_TH_ADD_MIN_MRC_INDEX] =\n\t\t\t\tcpu_to_le16(data->barker_corr_th_min_mrc);\n\ttbl[HD_OFDM_ENERGY_TH_IN_INDEX] =\n\t\t\t\tcpu_to_le16(data->nrg_th_cca);\n\n\tIWL_DEBUG_CALIB(priv, \"ofdm: ac %u mrc %u x1 %u mrc_x1 %u thresh %u\\n\",\n\t\t\tdata->auto_corr_ofdm, data->auto_corr_ofdm_mrc,\n\t\t\tdata->auto_corr_ofdm_x1, data->auto_corr_ofdm_mrc_x1,\n\t\t\tdata->nrg_th_ofdm);\n\n\tIWL_DEBUG_CALIB(priv, \"cck: ac %u mrc %u thresh %u\\n\",\n\t\t\tdata->auto_corr_cck, data->auto_corr_cck_mrc,\n\t\t\tdata->nrg_th_cck);\n}\n\n \nstatic int iwl_sensitivity_write(struct iwl_priv *priv)\n{\n\tstruct iwl_sensitivity_cmd cmd;\n\tstruct iwl_sensitivity_data *data = NULL;\n\tstruct iwl_host_cmd cmd_out = {\n\t\t.id = SENSITIVITY_CMD,\n\t\t.len = { sizeof(struct iwl_sensitivity_cmd), },\n\t\t.flags = CMD_ASYNC,\n\t\t.data = { &cmd, },\n\t};\n\n\tdata = &(priv->sensitivity_data);\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\tiwl_prepare_legacy_sensitivity_tbl(priv, data, &cmd.table[0]);\n\n\t \n\tcmd.control = SENSITIVITY_CMD_CONTROL_WORK_TABLE;\n\n\t \n\tif (!memcmp(&cmd.table[0], &(priv->sensitivity_tbl[0]),\n\t\t    sizeof(u16)*HD_TABLE_SIZE)) {\n\t\tIWL_DEBUG_CALIB(priv, \"No change in SENSITIVITY_CMD\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tmemcpy(&(priv->sensitivity_tbl[0]), &(cmd.table[0]),\n\t       sizeof(u16)*HD_TABLE_SIZE);\n\n\treturn iwl_dvm_send_cmd(priv, &cmd_out);\n}\n\n \nstatic int iwl_enhance_sensitivity_write(struct iwl_priv *priv)\n{\n\tstruct iwl_enhance_sensitivity_cmd cmd;\n\tstruct iwl_sensitivity_data *data = NULL;\n\tstruct iwl_host_cmd cmd_out = {\n\t\t.id = SENSITIVITY_CMD,\n\t\t.len = { sizeof(struct iwl_enhance_sensitivity_cmd), },\n\t\t.flags = CMD_ASYNC,\n\t\t.data = { &cmd, },\n\t};\n\n\tdata = &(priv->sensitivity_data);\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\tiwl_prepare_legacy_sensitivity_tbl(priv, data, &cmd.enhance_table[0]);\n\n\tif (priv->lib->hd_v2) {\n\t\tcmd.enhance_table[HD_INA_NON_SQUARE_DET_OFDM_INDEX] =\n\t\t\tHD_INA_NON_SQUARE_DET_OFDM_DATA_V2;\n\t\tcmd.enhance_table[HD_INA_NON_SQUARE_DET_CCK_INDEX] =\n\t\t\tHD_INA_NON_SQUARE_DET_CCK_DATA_V2;\n\t\tcmd.enhance_table[HD_CORR_11_INSTEAD_OF_CORR_9_EN_INDEX] =\n\t\t\tHD_CORR_11_INSTEAD_OF_CORR_9_EN_DATA_V2;\n\t\tcmd.enhance_table[HD_OFDM_NON_SQUARE_DET_SLOPE_MRC_INDEX] =\n\t\t\tHD_OFDM_NON_SQUARE_DET_SLOPE_MRC_DATA_V2;\n\t\tcmd.enhance_table[HD_OFDM_NON_SQUARE_DET_INTERCEPT_MRC_INDEX] =\n\t\t\tHD_OFDM_NON_SQUARE_DET_INTERCEPT_MRC_DATA_V2;\n\t\tcmd.enhance_table[HD_OFDM_NON_SQUARE_DET_SLOPE_INDEX] =\n\t\t\tHD_OFDM_NON_SQUARE_DET_SLOPE_DATA_V2;\n\t\tcmd.enhance_table[HD_OFDM_NON_SQUARE_DET_INTERCEPT_INDEX] =\n\t\t\tHD_OFDM_NON_SQUARE_DET_INTERCEPT_DATA_V2;\n\t\tcmd.enhance_table[HD_CCK_NON_SQUARE_DET_SLOPE_MRC_INDEX] =\n\t\t\tHD_CCK_NON_SQUARE_DET_SLOPE_MRC_DATA_V2;\n\t\tcmd.enhance_table[HD_CCK_NON_SQUARE_DET_INTERCEPT_MRC_INDEX] =\n\t\t\tHD_CCK_NON_SQUARE_DET_INTERCEPT_MRC_DATA_V2;\n\t\tcmd.enhance_table[HD_CCK_NON_SQUARE_DET_SLOPE_INDEX] =\n\t\t\tHD_CCK_NON_SQUARE_DET_SLOPE_DATA_V2;\n\t\tcmd.enhance_table[HD_CCK_NON_SQUARE_DET_INTERCEPT_INDEX] =\n\t\t\tHD_CCK_NON_SQUARE_DET_INTERCEPT_DATA_V2;\n\t} else {\n\t\tcmd.enhance_table[HD_INA_NON_SQUARE_DET_OFDM_INDEX] =\n\t\t\tHD_INA_NON_SQUARE_DET_OFDM_DATA_V1;\n\t\tcmd.enhance_table[HD_INA_NON_SQUARE_DET_CCK_INDEX] =\n\t\t\tHD_INA_NON_SQUARE_DET_CCK_DATA_V1;\n\t\tcmd.enhance_table[HD_CORR_11_INSTEAD_OF_CORR_9_EN_INDEX] =\n\t\t\tHD_CORR_11_INSTEAD_OF_CORR_9_EN_DATA_V1;\n\t\tcmd.enhance_table[HD_OFDM_NON_SQUARE_DET_SLOPE_MRC_INDEX] =\n\t\t\tHD_OFDM_NON_SQUARE_DET_SLOPE_MRC_DATA_V1;\n\t\tcmd.enhance_table[HD_OFDM_NON_SQUARE_DET_INTERCEPT_MRC_INDEX] =\n\t\t\tHD_OFDM_NON_SQUARE_DET_INTERCEPT_MRC_DATA_V1;\n\t\tcmd.enhance_table[HD_OFDM_NON_SQUARE_DET_SLOPE_INDEX] =\n\t\t\tHD_OFDM_NON_SQUARE_DET_SLOPE_DATA_V1;\n\t\tcmd.enhance_table[HD_OFDM_NON_SQUARE_DET_INTERCEPT_INDEX] =\n\t\t\tHD_OFDM_NON_SQUARE_DET_INTERCEPT_DATA_V1;\n\t\tcmd.enhance_table[HD_CCK_NON_SQUARE_DET_SLOPE_MRC_INDEX] =\n\t\t\tHD_CCK_NON_SQUARE_DET_SLOPE_MRC_DATA_V1;\n\t\tcmd.enhance_table[HD_CCK_NON_SQUARE_DET_INTERCEPT_MRC_INDEX] =\n\t\t\tHD_CCK_NON_SQUARE_DET_INTERCEPT_MRC_DATA_V1;\n\t\tcmd.enhance_table[HD_CCK_NON_SQUARE_DET_SLOPE_INDEX] =\n\t\t\tHD_CCK_NON_SQUARE_DET_SLOPE_DATA_V1;\n\t\tcmd.enhance_table[HD_CCK_NON_SQUARE_DET_INTERCEPT_INDEX] =\n\t\t\tHD_CCK_NON_SQUARE_DET_INTERCEPT_DATA_V1;\n\t}\n\n\t \n\tcmd.control = SENSITIVITY_CMD_CONTROL_WORK_TABLE;\n\n\t \n\tif (!memcmp(&cmd.enhance_table[0], &(priv->sensitivity_tbl[0]),\n\t\t    sizeof(u16)*HD_TABLE_SIZE) &&\n\t    !memcmp(&cmd.enhance_table[HD_INA_NON_SQUARE_DET_OFDM_INDEX],\n\t\t    &(priv->enhance_sensitivity_tbl[0]),\n\t\t    sizeof(u16)*ENHANCE_HD_TABLE_ENTRIES)) {\n\t\tIWL_DEBUG_CALIB(priv, \"No change in SENSITIVITY_CMD\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tmemcpy(&(priv->sensitivity_tbl[0]), &(cmd.enhance_table[0]),\n\t       sizeof(u16)*HD_TABLE_SIZE);\n\tmemcpy(&(priv->enhance_sensitivity_tbl[0]),\n\t       &(cmd.enhance_table[HD_INA_NON_SQUARE_DET_OFDM_INDEX]),\n\t       sizeof(u16)*ENHANCE_HD_TABLE_ENTRIES);\n\n\treturn iwl_dvm_send_cmd(priv, &cmd_out);\n}\n\nvoid iwl_init_sensitivity(struct iwl_priv *priv)\n{\n\tint ret = 0;\n\tint i;\n\tstruct iwl_sensitivity_data *data = NULL;\n\tconst struct iwl_sensitivity_ranges *ranges = priv->hw_params.sens;\n\n\tif (priv->calib_disabled & IWL_SENSITIVITY_CALIB_DISABLED)\n\t\treturn;\n\n\tIWL_DEBUG_CALIB(priv, \"Start iwl_init_sensitivity\\n\");\n\n\t \n\tdata = &(priv->sensitivity_data);\n\n\tif (ranges == NULL)\n\t\treturn;\n\n\tmemset(data, 0, sizeof(struct iwl_sensitivity_data));\n\n\tdata->num_in_cck_no_fa = 0;\n\tdata->nrg_curr_state = IWL_FA_TOO_MANY;\n\tdata->nrg_prev_state = IWL_FA_TOO_MANY;\n\tdata->nrg_silence_ref = 0;\n\tdata->nrg_silence_idx = 0;\n\tdata->nrg_energy_idx = 0;\n\n\tfor (i = 0; i < 10; i++)\n\t\tdata->nrg_value[i] = 0;\n\n\tfor (i = 0; i < NRG_NUM_PREV_STAT_L; i++)\n\t\tdata->nrg_silence_rssi[i] = 0;\n\n\tdata->auto_corr_ofdm =  ranges->auto_corr_min_ofdm;\n\tdata->auto_corr_ofdm_mrc = ranges->auto_corr_min_ofdm_mrc;\n\tdata->auto_corr_ofdm_x1  = ranges->auto_corr_min_ofdm_x1;\n\tdata->auto_corr_ofdm_mrc_x1 = ranges->auto_corr_min_ofdm_mrc_x1;\n\tdata->auto_corr_cck = AUTO_CORR_CCK_MIN_VAL_DEF;\n\tdata->auto_corr_cck_mrc = ranges->auto_corr_min_cck_mrc;\n\tdata->nrg_th_cck = ranges->nrg_th_cck;\n\tdata->nrg_th_ofdm = ranges->nrg_th_ofdm;\n\tdata->barker_corr_th_min = ranges->barker_corr_th_min;\n\tdata->barker_corr_th_min_mrc = ranges->barker_corr_th_min_mrc;\n\tdata->nrg_th_cca = ranges->nrg_th_cca;\n\n\tdata->last_bad_plcp_cnt_ofdm = 0;\n\tdata->last_fa_cnt_ofdm = 0;\n\tdata->last_bad_plcp_cnt_cck = 0;\n\tdata->last_fa_cnt_cck = 0;\n\n\tif (priv->fw->enhance_sensitivity_table)\n\t\tret |= iwl_enhance_sensitivity_write(priv);\n\telse\n\t\tret |= iwl_sensitivity_write(priv);\n\tIWL_DEBUG_CALIB(priv, \"<<return 0x%X\\n\", ret);\n}\n\nvoid iwl_sensitivity_calibration(struct iwl_priv *priv)\n{\n\tu32 rx_enable_time;\n\tu32 fa_cck;\n\tu32 fa_ofdm;\n\tu32 bad_plcp_cck;\n\tu32 bad_plcp_ofdm;\n\tu32 norm_fa_ofdm;\n\tu32 norm_fa_cck;\n\tstruct iwl_sensitivity_data *data = NULL;\n\tstruct statistics_rx_non_phy *rx_info;\n\tstruct statistics_rx_phy *ofdm, *cck;\n\tstruct statistics_general_data statis;\n\n\tif (priv->calib_disabled & IWL_SENSITIVITY_CALIB_DISABLED)\n\t\treturn;\n\n\tdata = &(priv->sensitivity_data);\n\n\tif (!iwl_is_any_associated(priv)) {\n\t\tIWL_DEBUG_CALIB(priv, \"<< - not associated\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&priv->statistics.lock);\n\trx_info = &priv->statistics.rx_non_phy;\n\tofdm = &priv->statistics.rx_ofdm;\n\tcck = &priv->statistics.rx_cck;\n\tif (rx_info->interference_data_flag != INTERFERENCE_DATA_AVAILABLE) {\n\t\tIWL_DEBUG_CALIB(priv, \"<< invalid data.\\n\");\n\t\tspin_unlock_bh(&priv->statistics.lock);\n\t\treturn;\n\t}\n\n\t \n\trx_enable_time = le32_to_cpu(rx_info->channel_load);\n\tfa_cck = le32_to_cpu(cck->false_alarm_cnt);\n\tfa_ofdm = le32_to_cpu(ofdm->false_alarm_cnt);\n\tbad_plcp_cck = le32_to_cpu(cck->plcp_err);\n\tbad_plcp_ofdm = le32_to_cpu(ofdm->plcp_err);\n\n\tstatis.beacon_silence_rssi_a =\n\t\t\tle32_to_cpu(rx_info->beacon_silence_rssi_a);\n\tstatis.beacon_silence_rssi_b =\n\t\t\tle32_to_cpu(rx_info->beacon_silence_rssi_b);\n\tstatis.beacon_silence_rssi_c =\n\t\t\tle32_to_cpu(rx_info->beacon_silence_rssi_c);\n\tstatis.beacon_energy_a =\n\t\t\tle32_to_cpu(rx_info->beacon_energy_a);\n\tstatis.beacon_energy_b =\n\t\t\tle32_to_cpu(rx_info->beacon_energy_b);\n\tstatis.beacon_energy_c =\n\t\t\tle32_to_cpu(rx_info->beacon_energy_c);\n\n\tspin_unlock_bh(&priv->statistics.lock);\n\n\tIWL_DEBUG_CALIB(priv, \"rx_enable_time = %u usecs\\n\", rx_enable_time);\n\n\tif (!rx_enable_time) {\n\t\tIWL_DEBUG_CALIB(priv, \"<< RX Enable Time == 0!\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (data->last_bad_plcp_cnt_cck > bad_plcp_cck)\n\t\tdata->last_bad_plcp_cnt_cck = bad_plcp_cck;\n\telse {\n\t\tbad_plcp_cck -= data->last_bad_plcp_cnt_cck;\n\t\tdata->last_bad_plcp_cnt_cck += bad_plcp_cck;\n\t}\n\n\tif (data->last_bad_plcp_cnt_ofdm > bad_plcp_ofdm)\n\t\tdata->last_bad_plcp_cnt_ofdm = bad_plcp_ofdm;\n\telse {\n\t\tbad_plcp_ofdm -= data->last_bad_plcp_cnt_ofdm;\n\t\tdata->last_bad_plcp_cnt_ofdm += bad_plcp_ofdm;\n\t}\n\n\tif (data->last_fa_cnt_ofdm > fa_ofdm)\n\t\tdata->last_fa_cnt_ofdm = fa_ofdm;\n\telse {\n\t\tfa_ofdm -= data->last_fa_cnt_ofdm;\n\t\tdata->last_fa_cnt_ofdm += fa_ofdm;\n\t}\n\n\tif (data->last_fa_cnt_cck > fa_cck)\n\t\tdata->last_fa_cnt_cck = fa_cck;\n\telse {\n\t\tfa_cck -= data->last_fa_cnt_cck;\n\t\tdata->last_fa_cnt_cck += fa_cck;\n\t}\n\n\t \n\tnorm_fa_ofdm = fa_ofdm + bad_plcp_ofdm;\n\tnorm_fa_cck = fa_cck + bad_plcp_cck;\n\n\tIWL_DEBUG_CALIB(priv, \"cck: fa %u badp %u  ofdm: fa %u badp %u\\n\", fa_cck,\n\t\t\tbad_plcp_cck, fa_ofdm, bad_plcp_ofdm);\n\n\tiwl_sens_auto_corr_ofdm(priv, norm_fa_ofdm, rx_enable_time);\n\tiwl_sens_energy_cck(priv, norm_fa_cck, rx_enable_time, &statis);\n\tif (priv->fw->enhance_sensitivity_table)\n\t\tiwl_enhance_sensitivity_write(priv);\n\telse\n\t\tiwl_sensitivity_write(priv);\n}\n\nstatic inline u8 find_first_chain(u8 mask)\n{\n\tif (mask & ANT_A)\n\t\treturn CHAIN_A;\n\tif (mask & ANT_B)\n\t\treturn CHAIN_B;\n\treturn CHAIN_C;\n}\n\n \nstatic void iwl_find_disconn_antenna(struct iwl_priv *priv, u32* average_sig,\n\t\t\t\t     struct iwl_chain_noise_data *data)\n{\n\tu32 active_chains = 0;\n\tu32 max_average_sig;\n\tu16 max_average_sig_antenna_i;\n\tu8 num_tx_chains;\n\tu8 first_chain;\n\tu16 i = 0;\n\n\taverage_sig[0] = data->chain_signal_a / IWL_CAL_NUM_BEACONS;\n\taverage_sig[1] = data->chain_signal_b / IWL_CAL_NUM_BEACONS;\n\taverage_sig[2] = data->chain_signal_c / IWL_CAL_NUM_BEACONS;\n\n\tif (average_sig[0] >= average_sig[1]) {\n\t\tmax_average_sig = average_sig[0];\n\t\tmax_average_sig_antenna_i = 0;\n\t\tactive_chains = (1 << max_average_sig_antenna_i);\n\t} else {\n\t\tmax_average_sig = average_sig[1];\n\t\tmax_average_sig_antenna_i = 1;\n\t\tactive_chains = (1 << max_average_sig_antenna_i);\n\t}\n\n\tif (average_sig[2] >= max_average_sig) {\n\t\tmax_average_sig = average_sig[2];\n\t\tmax_average_sig_antenna_i = 2;\n\t\tactive_chains = (1 << max_average_sig_antenna_i);\n\t}\n\n\tIWL_DEBUG_CALIB(priv, \"average_sig: a %d b %d c %d\\n\",\n\t\t     average_sig[0], average_sig[1], average_sig[2]);\n\tIWL_DEBUG_CALIB(priv, \"max_average_sig = %d, antenna %d\\n\",\n\t\t     max_average_sig, max_average_sig_antenna_i);\n\n\t \n\tfor (i = 0; i < NUM_RX_CHAINS; i++) {\n\t\tif (i != max_average_sig_antenna_i) {\n\t\t\ts32 rssi_delta = (max_average_sig - average_sig[i]);\n\n\t\t\t \n\t\t\tif (rssi_delta > MAXIMUM_ALLOWED_PATHLOSS)\n\t\t\t\tdata->disconn_array[i] = 1;\n\t\t\telse\n\t\t\t\tactive_chains |= (1 << i);\n\t\t\tIWL_DEBUG_CALIB(priv, \"i = %d  rssiDelta = %d  \"\n\t\t\t     \"disconn_array[i] = %d\\n\",\n\t\t\t     i, rssi_delta, data->disconn_array[i]);\n\t\t}\n\t}\n\n\t \n\tactive_chains &= priv->nvm_data->valid_rx_ant;\n\n\tnum_tx_chains = 0;\n\tfor (i = 0; i < NUM_RX_CHAINS; i++) {\n\t\t \n\t\tu8 ant_msk = (1 << i);\n\t\tif (!(priv->nvm_data->valid_tx_ant & ant_msk))\n\t\t\tcontinue;\n\n\t\tnum_tx_chains++;\n\t\tif (data->disconn_array[i] == 0)\n\t\t\t \n\t\t\tbreak;\n\t\tif (num_tx_chains == priv->hw_params.tx_chains_num &&\n\t\t    data->disconn_array[i]) {\n\t\t\t \n\t\t\tfirst_chain =\n\t\t\t\tfind_first_chain(priv->nvm_data->valid_tx_ant);\n\t\t\tdata->disconn_array[first_chain] = 0;\n\t\t\tactive_chains |= BIT(first_chain);\n\t\t\tIWL_DEBUG_CALIB(priv,\n\t\t\t\t\t\"All Tx chains are disconnected W/A - declare %d as connected\\n\",\n\t\t\t\t\tfirst_chain);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (active_chains != priv->nvm_data->valid_rx_ant &&\n\t    active_chains != priv->chain_noise_data.active_chains)\n\t\tIWL_DEBUG_CALIB(priv,\n\t\t\t\t\"Detected that not all antennas are connected! \"\n\t\t\t\t\"Connected: %#x, valid: %#x.\\n\",\n\t\t\t\tactive_chains,\n\t\t\t\tpriv->nvm_data->valid_rx_ant);\n\n\t \n\tdata->active_chains = active_chains;\n\tIWL_DEBUG_CALIB(priv, \"active_chains (bitwise) = 0x%x\\n\",\n\t\t\tactive_chains);\n}\n\nstatic void iwlagn_gain_computation(struct iwl_priv *priv,\n\t\t\t\t    u32 average_noise[NUM_RX_CHAINS],\n\t\t\t\t    u8 default_chain)\n{\n\tint i;\n\ts32 delta_g;\n\tstruct iwl_chain_noise_data *data = &priv->chain_noise_data;\n\n\t \n\tfor (i = default_chain + 1; i < NUM_RX_CHAINS; i++) {\n\t\tif ((data->disconn_array[i])) {\n\t\t\tdata->delta_gain_code[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdelta_g = (priv->lib->chain_noise_scale *\n\t\t\t((s32)average_noise[default_chain] -\n\t\t\t(s32)average_noise[i])) / 1500;\n\n\t\t \n\t\tdata->delta_gain_code[i] =\n\t\t\tmin(abs(delta_g), CHAIN_NOISE_MAX_DELTA_GAIN_CODE);\n\n\t\tif (delta_g < 0)\n\t\t\t \n\t\t\tdata->delta_gain_code[i] |= (1 << 2);\n\t}\n\n\tIWL_DEBUG_CALIB(priv, \"Delta gains: ANT_B = %d  ANT_C = %d\\n\",\n\t\t\tdata->delta_gain_code[1], data->delta_gain_code[2]);\n\n\tif (!data->radio_write) {\n\t\tstruct iwl_calib_chain_noise_gain_cmd cmd;\n\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\n\t\tiwl_set_calib_hdr(&cmd.hdr,\n\t\t\tpriv->phy_calib_chain_noise_gain_cmd);\n\t\tcmd.delta_gain_1 = data->delta_gain_code[1];\n\t\tcmd.delta_gain_2 = data->delta_gain_code[2];\n\t\tiwl_dvm_send_cmd_pdu(priv, REPLY_PHY_CALIBRATION_CMD,\n\t\t\tCMD_ASYNC, sizeof(cmd), &cmd);\n\n\t\tdata->radio_write = 1;\n\t\tdata->state = IWL_CHAIN_NOISE_CALIBRATED;\n\t}\n}\n\n \nvoid iwl_chain_noise_calibration(struct iwl_priv *priv)\n{\n\tstruct iwl_chain_noise_data *data = NULL;\n\n\tu32 chain_noise_a;\n\tu32 chain_noise_b;\n\tu32 chain_noise_c;\n\tu32 chain_sig_a;\n\tu32 chain_sig_b;\n\tu32 chain_sig_c;\n\tu32 average_sig[NUM_RX_CHAINS] = {INITIALIZATION_VALUE};\n\tu32 average_noise[NUM_RX_CHAINS] = {INITIALIZATION_VALUE};\n\tu32 min_average_noise = MIN_AVERAGE_NOISE_MAX_VALUE;\n\tu16 min_average_noise_antenna_i = INITIALIZATION_VALUE;\n\tu16 i = 0;\n\tu16 rxon_chnum = INITIALIZATION_VALUE;\n\tu16 stat_chnum = INITIALIZATION_VALUE;\n\tu8 rxon_band24;\n\tu8 stat_band24;\n\tstruct statistics_rx_non_phy *rx_info;\n\n\t \n\tstruct iwl_rxon_context *ctx = &priv->contexts[IWL_RXON_CTX_BSS];\n\n\tif (priv->calib_disabled & IWL_CHAIN_NOISE_CALIB_DISABLED)\n\t\treturn;\n\n\tdata = &(priv->chain_noise_data);\n\n\t \n\tif (data->state != IWL_CHAIN_NOISE_ACCUMULATE) {\n\t\tif (data->state == IWL_CHAIN_NOISE_ALIVE)\n\t\t\tIWL_DEBUG_CALIB(priv, \"Wait for noise calib reset\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&priv->statistics.lock);\n\n\trx_info = &priv->statistics.rx_non_phy;\n\n\tif (rx_info->interference_data_flag != INTERFERENCE_DATA_AVAILABLE) {\n\t\tIWL_DEBUG_CALIB(priv, \" << Interference data unavailable\\n\");\n\t\tspin_unlock_bh(&priv->statistics.lock);\n\t\treturn;\n\t}\n\n\trxon_band24 = !!(ctx->staging.flags & RXON_FLG_BAND_24G_MSK);\n\trxon_chnum = le16_to_cpu(ctx->staging.channel);\n\tstat_band24 =\n\t\t!!(priv->statistics.flag & STATISTICS_REPLY_FLG_BAND_24G_MSK);\n\tstat_chnum = le32_to_cpu(priv->statistics.flag) >> 16;\n\n\t \n\tif ((rxon_chnum != stat_chnum) || (rxon_band24 != stat_band24)) {\n\t\tIWL_DEBUG_CALIB(priv, \"Stats not from chan=%d, band24=%d\\n\",\n\t\t\t\trxon_chnum, rxon_band24);\n\t\tspin_unlock_bh(&priv->statistics.lock);\n\t\treturn;\n\t}\n\n\t \n\tchain_noise_a = le32_to_cpu(rx_info->beacon_silence_rssi_a) &\n\t\t\t\tIN_BAND_FILTER;\n\tchain_noise_b = le32_to_cpu(rx_info->beacon_silence_rssi_b) &\n\t\t\t\tIN_BAND_FILTER;\n\tchain_noise_c = le32_to_cpu(rx_info->beacon_silence_rssi_c) &\n\t\t\t\tIN_BAND_FILTER;\n\n\tchain_sig_a = le32_to_cpu(rx_info->beacon_rssi_a) & IN_BAND_FILTER;\n\tchain_sig_b = le32_to_cpu(rx_info->beacon_rssi_b) & IN_BAND_FILTER;\n\tchain_sig_c = le32_to_cpu(rx_info->beacon_rssi_c) & IN_BAND_FILTER;\n\n\tspin_unlock_bh(&priv->statistics.lock);\n\n\tdata->beacon_count++;\n\n\tdata->chain_noise_a = (chain_noise_a + data->chain_noise_a);\n\tdata->chain_noise_b = (chain_noise_b + data->chain_noise_b);\n\tdata->chain_noise_c = (chain_noise_c + data->chain_noise_c);\n\n\tdata->chain_signal_a = (chain_sig_a + data->chain_signal_a);\n\tdata->chain_signal_b = (chain_sig_b + data->chain_signal_b);\n\tdata->chain_signal_c = (chain_sig_c + data->chain_signal_c);\n\n\tIWL_DEBUG_CALIB(priv, \"chan=%d, band24=%d, beacon=%d\\n\",\n\t\t\trxon_chnum, rxon_band24, data->beacon_count);\n\tIWL_DEBUG_CALIB(priv, \"chain_sig: a %d b %d c %d\\n\",\n\t\t\tchain_sig_a, chain_sig_b, chain_sig_c);\n\tIWL_DEBUG_CALIB(priv, \"chain_noise: a %d b %d c %d\\n\",\n\t\t\tchain_noise_a, chain_noise_b, chain_noise_c);\n\n\t \n\tif (data->beacon_count != IWL_CAL_NUM_BEACONS)\n\t\treturn;\n\n\t \n\tif (priv->lib->bt_params &&\n\t    priv->lib->bt_params->advanced_bt_coexist) {\n\t\t \n\t\tdata->active_chains = priv->nvm_data->valid_rx_ant;\n\t\tfor (i = 0; i < NUM_RX_CHAINS; i++)\n\t\t\tif (!(data->active_chains & (1<<i)))\n\t\t\t\tdata->disconn_array[i] = 1;\n\t} else\n\t\tiwl_find_disconn_antenna(priv, average_sig, data);\n\n\t \n\taverage_noise[0] = data->chain_noise_a / IWL_CAL_NUM_BEACONS;\n\taverage_noise[1] = data->chain_noise_b / IWL_CAL_NUM_BEACONS;\n\taverage_noise[2] = data->chain_noise_c / IWL_CAL_NUM_BEACONS;\n\n\tfor (i = 0; i < NUM_RX_CHAINS; i++) {\n\t\tif (!(data->disconn_array[i]) &&\n\t\t   (average_noise[i] <= min_average_noise)) {\n\t\t\t \n\t\t\tmin_average_noise = average_noise[i];\n\t\t\tmin_average_noise_antenna_i = i;\n\t\t}\n\t}\n\n\tIWL_DEBUG_CALIB(priv, \"average_noise: a %d b %d c %d\\n\",\n\t\t\taverage_noise[0], average_noise[1],\n\t\t\taverage_noise[2]);\n\n\tIWL_DEBUG_CALIB(priv, \"min_average_noise = %d, antenna %d\\n\",\n\t\t\tmin_average_noise, min_average_noise_antenna_i);\n\n\tiwlagn_gain_computation(\n\t\tpriv, average_noise,\n\t\tfind_first_chain(priv->nvm_data->valid_rx_ant));\n\n\t \n\tiwl_update_chain_flags(priv);\n\n\tdata->state = IWL_CHAIN_NOISE_DONE;\n\tiwl_power_update_mode(priv, false);\n}\n\nvoid iwl_reset_run_time_calib(struct iwl_priv *priv)\n{\n\tint i;\n\tmemset(&(priv->sensitivity_data), 0,\n\t       sizeof(struct iwl_sensitivity_data));\n\tmemset(&(priv->chain_noise_data), 0,\n\t       sizeof(struct iwl_chain_noise_data));\n\tfor (i = 0; i < NUM_RX_CHAINS; i++)\n\t\tpriv->chain_noise_data.delta_gain_code[i] =\n\t\t\t\tCHAIN_NOISE_DELTA_GAIN_INIT_VAL;\n\n\t \n\tiwl_send_statistics_request(priv, CMD_ASYNC, true);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}