{
  "module_name": "mac80211.c",
  "hash_id": "667c36c5c9fa0083ffc93a1b396d061c66f2e8588ea3d10f0b00de38bf5b8bb6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/dvm/mac80211.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/if_arp.h>\n\n#include <net/ieee80211_radiotap.h>\n#include <net/mac80211.h>\n\n#include <asm/div64.h>\n\n#include \"iwl-io.h\"\n#include \"iwl-trans.h\"\n#include \"iwl-op-mode.h\"\n#include \"iwl-modparams.h\"\n\n#include \"dev.h\"\n#include \"calib.h\"\n#include \"agn.h\"\n\n \n\nstatic const struct ieee80211_iface_limit iwlagn_sta_ap_limits[] = {\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_STATION),\n\t},\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_AP),\n\t},\n};\n\nstatic const struct ieee80211_iface_limit iwlagn_2sta_limits[] = {\n\t{\n\t\t.max = 2,\n\t\t.types = BIT(NL80211_IFTYPE_STATION),\n\t},\n};\n\nstatic const struct ieee80211_iface_combination\niwlagn_iface_combinations_dualmode[] = {\n\t{ .num_different_channels = 1,\n\t  .max_interfaces = 2,\n\t  .beacon_int_infra_match = true,\n\t  .limits = iwlagn_sta_ap_limits,\n\t  .n_limits = ARRAY_SIZE(iwlagn_sta_ap_limits),\n\t},\n\t{ .num_different_channels = 1,\n\t  .max_interfaces = 2,\n\t  .limits = iwlagn_2sta_limits,\n\t  .n_limits = ARRAY_SIZE(iwlagn_2sta_limits),\n\t},\n};\n\n \nint iwlagn_mac_setup_register(struct iwl_priv *priv,\n\t\t\t      const struct iwl_ucode_capabilities *capa)\n{\n\tint ret;\n\tstruct ieee80211_hw *hw = priv->hw;\n\tstruct iwl_rxon_context *ctx;\n\n\thw->rate_control_algorithm = \"iwl-agn-rs\";\n\n\t \n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\tieee80211_hw_set(hw, AMPDU_AGGREGATION);\n\tieee80211_hw_set(hw, NEED_DTIM_BEFORE_ASSOC);\n\tieee80211_hw_set(hw, SPECTRUM_MGMT);\n\tieee80211_hw_set(hw, REPORTS_TX_ACK_STATUS);\n\tieee80211_hw_set(hw, QUEUE_CONTROL);\n\tieee80211_hw_set(hw, SUPPORTS_PS);\n\tieee80211_hw_set(hw, SUPPORTS_DYNAMIC_PS);\n\tieee80211_hw_set(hw, SUPPORT_FAST_XMIT);\n\tieee80211_hw_set(hw, WANT_MONITOR_VIF);\n\n\tif (priv->trans->max_skb_frags)\n\t\thw->netdev_features = NETIF_F_HIGHDMA | NETIF_F_SG;\n\n\thw->offchannel_tx_hw_queue = IWL_AUX_QUEUE;\n\thw->radiotap_mcs_details |= IEEE80211_RADIOTAP_MCS_HAVE_FMT;\n\n\t \n\n\tif (priv->nvm_data->sku_cap_11n_enable)\n\t\thw->wiphy->features |= NL80211_FEATURE_DYNAMIC_SMPS |\n\t\t\t\t       NL80211_FEATURE_STATIC_SMPS;\n\n\t \n\tif (priv->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_MFP &&\n\t    !iwlwifi_mod_params.swcrypto)\n\t\tieee80211_hw_set(hw, MFP_CAPABLE);\n\n\thw->sta_data_size = sizeof(struct iwl_station_priv);\n\thw->vif_data_size = sizeof(struct iwl_vif_priv);\n\n\tfor_each_context(priv, ctx) {\n\t\thw->wiphy->interface_modes |= ctx->interface_modes;\n\t\thw->wiphy->interface_modes |= ctx->exclusive_interface_modes;\n\t}\n\n\tBUILD_BUG_ON(NUM_IWL_RXON_CTX != 2);\n\n\tif (hw->wiphy->interface_modes & BIT(NL80211_IFTYPE_AP)) {\n\t\thw->wiphy->iface_combinations =\n\t\t\tiwlagn_iface_combinations_dualmode;\n\t\thw->wiphy->n_iface_combinations =\n\t\t\tARRAY_SIZE(iwlagn_iface_combinations_dualmode);\n\t}\n\n\thw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;\n\thw->wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG |\n\t\t\t\t       REGULATORY_DISABLE_BEACON_HINTS;\n\n#ifdef CONFIG_PM_SLEEP\n\tif (priv->fw->img[IWL_UCODE_WOWLAN].num_sec &&\n\t    priv->trans->ops->d3_suspend &&\n\t    priv->trans->ops->d3_resume &&\n\t    device_can_wakeup(priv->trans->dev)) {\n\t\tpriv->wowlan_support.flags = WIPHY_WOWLAN_MAGIC_PKT |\n\t\t\t\t\t     WIPHY_WOWLAN_DISCONNECT |\n\t\t\t\t\t     WIPHY_WOWLAN_EAP_IDENTITY_REQ |\n\t\t\t\t\t     WIPHY_WOWLAN_RFKILL_RELEASE;\n\t\tif (!iwlwifi_mod_params.swcrypto)\n\t\t\tpriv->wowlan_support.flags |=\n\t\t\t\tWIPHY_WOWLAN_SUPPORTS_GTK_REKEY |\n\t\t\t\tWIPHY_WOWLAN_GTK_REKEY_FAILURE;\n\n\t\tpriv->wowlan_support.n_patterns = IWLAGN_WOWLAN_MAX_PATTERNS;\n\t\tpriv->wowlan_support.pattern_min_len =\n\t\t\t\t\tIWLAGN_WOWLAN_MIN_PATTERN_LEN;\n\t\tpriv->wowlan_support.pattern_max_len =\n\t\t\t\t\tIWLAGN_WOWLAN_MAX_PATTERN_LEN;\n\t\thw->wiphy->wowlan = &priv->wowlan_support;\n\t}\n#endif\n\n\tif (iwlwifi_mod_params.power_save)\n\t\thw->wiphy->flags |= WIPHY_FLAG_PS_ON_BY_DEFAULT;\n\telse\n\t\thw->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;\n\n\thw->wiphy->max_scan_ssids = PROBE_OPTION_MAX;\n\t \n\thw->wiphy->max_scan_ie_len = capa->max_probe_length - 24 - 34;\n\n\t \n\thw->queues = IWLAGN_FIRST_AMPDU_QUEUE;\n\n\thw->max_listen_interval = IWL_CONN_MAX_LISTEN_INTERVAL;\n\n\tif (priv->nvm_data->bands[NL80211_BAND_2GHZ].n_channels)\n\t\tpriv->hw->wiphy->bands[NL80211_BAND_2GHZ] =\n\t\t\t&priv->nvm_data->bands[NL80211_BAND_2GHZ];\n\tif (priv->nvm_data->bands[NL80211_BAND_5GHZ].n_channels)\n\t\tpriv->hw->wiphy->bands[NL80211_BAND_5GHZ] =\n\t\t\t&priv->nvm_data->bands[NL80211_BAND_5GHZ];\n\n\thw->wiphy->hw_version = priv->trans->hw_id;\n\n\tiwl_leds_init(priv);\n\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_EXT_KEY_ID);\n\n\tret = ieee80211_register_hw(priv->hw);\n\tif (ret) {\n\t\tIWL_ERR(priv, \"Failed to register hw (error %d)\\n\", ret);\n\t\tiwl_leds_exit(priv);\n\t\treturn ret;\n\t}\n\tpriv->mac80211_registered = 1;\n\n\treturn 0;\n}\n\nvoid iwlagn_mac_unregister(struct iwl_priv *priv)\n{\n\tif (!priv->mac80211_registered)\n\t\treturn;\n\tiwl_leds_exit(priv);\n\tieee80211_unregister_hw(priv->hw);\n\tpriv->mac80211_registered = 0;\n}\n\nstatic int __iwl_up(struct iwl_priv *priv)\n{\n\tstruct iwl_rxon_context *ctx;\n\tint ret;\n\n\tlockdep_assert_held(&priv->mutex);\n\n\tif (test_bit(STATUS_EXIT_PENDING, &priv->status)) {\n\t\tIWL_WARN(priv, \"Exit pending; will not bring the NIC up\\n\");\n\t\treturn -EIO;\n\t}\n\n\tfor_each_context(priv, ctx) {\n\t\tret = iwlagn_alloc_bcast_station(priv, ctx);\n\t\tif (ret) {\n\t\t\tiwl_dealloc_bcast_stations(priv);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = iwl_trans_start_hw(priv->trans);\n\tif (ret) {\n\t\tIWL_ERR(priv, \"Failed to start HW: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tret = iwl_run_init_ucode(priv);\n\tif (ret) {\n\t\tIWL_ERR(priv, \"Failed to run INIT ucode: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tret = iwl_trans_start_hw(priv->trans);\n\tif (ret) {\n\t\tIWL_ERR(priv, \"Failed to start HW: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tret = iwl_load_ucode_wait_alive(priv, IWL_UCODE_REGULAR);\n\tif (ret) {\n\t\tIWL_ERR(priv, \"Failed to start RT ucode: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tret = iwl_alive_start(priv);\n\tif (ret)\n\t\tgoto error;\n\treturn 0;\n\n error:\n\tset_bit(STATUS_EXIT_PENDING, &priv->status);\n\tiwl_down(priv);\n\tclear_bit(STATUS_EXIT_PENDING, &priv->status);\n\n\tIWL_ERR(priv, \"Unable to initialize device.\\n\");\n\treturn ret;\n}\n\nstatic int iwlagn_mac_start(struct ieee80211_hw *hw)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\tint ret;\n\n\tIWL_DEBUG_MAC80211(priv, \"enter\\n\");\n\n\t \n\tmutex_lock(&priv->mutex);\n\tret = __iwl_up(priv);\n\tmutex_unlock(&priv->mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tIWL_DEBUG_INFO(priv, \"Start UP work done.\\n\");\n\n\t \n\tif (WARN_ON(!test_bit(STATUS_READY, &priv->status)))\n\t\tret = -EIO;\n\n\tiwlagn_led_enable(priv);\n\n\tpriv->is_open = 1;\n\tIWL_DEBUG_MAC80211(priv, \"leave\\n\");\n\treturn ret;\n}\n\nstatic void iwlagn_mac_stop(struct ieee80211_hw *hw)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\n\tIWL_DEBUG_MAC80211(priv, \"enter\\n\");\n\n\tif (!priv->is_open)\n\t\treturn;\n\n\tpriv->is_open = 0;\n\n\tmutex_lock(&priv->mutex);\n\tiwl_down(priv);\n\tmutex_unlock(&priv->mutex);\n\n\tiwl_cancel_deferred_work(priv);\n\n\tflush_workqueue(priv->workqueue);\n\n\tIWL_DEBUG_MAC80211(priv, \"leave\\n\");\n}\n\nstatic void iwlagn_mac_set_rekey_data(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct cfg80211_gtk_rekey_data *data)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\n\tif (iwlwifi_mod_params.swcrypto)\n\t\treturn;\n\n\tIWL_DEBUG_MAC80211(priv, \"enter\\n\");\n\tmutex_lock(&priv->mutex);\n\n\tif (priv->contexts[IWL_RXON_CTX_BSS].vif != vif)\n\t\tgoto out;\n\n\tmemcpy(priv->kek, data->kek, NL80211_KEK_LEN);\n\tmemcpy(priv->kck, data->kck, NL80211_KCK_LEN);\n\tpriv->replay_ctr =\n\t\tcpu_to_le64(be64_to_cpup((__be64 *)&data->replay_ctr));\n\tpriv->have_rekey_data = true;\n\n out:\n\tmutex_unlock(&priv->mutex);\n\tIWL_DEBUG_MAC80211(priv, \"leave\\n\");\n}\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int iwlagn_mac_suspend(struct ieee80211_hw *hw,\n\t\t\t      struct cfg80211_wowlan *wowlan)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\tstruct iwl_rxon_context *ctx = &priv->contexts[IWL_RXON_CTX_BSS];\n\tint ret;\n\n\tif (WARN_ON(!wowlan))\n\t\treturn -EINVAL;\n\n\tIWL_DEBUG_MAC80211(priv, \"enter\\n\");\n\tmutex_lock(&priv->mutex);\n\n\t \n\tif (!ctx->vif || ctx->vif->type != NL80211_IFTYPE_STATION ||\n\t    !iwl_is_associated_ctx(ctx)) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tret = iwlagn_suspend(priv, wowlan);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tiwl_write32(priv->trans, CSR_UCODE_DRV_GP1_SET,\n\t\t    CSR_UCODE_DRV_GP1_BIT_D3_CFG_COMPLETE);\n\n\tiwl_trans_d3_suspend(priv->trans, false, true);\n\n\tgoto out;\n\n error:\n\tpriv->wowlan = false;\n\tiwlagn_prepare_restart(priv);\n\tieee80211_restart_hw(priv->hw);\n out:\n\tmutex_unlock(&priv->mutex);\n\tIWL_DEBUG_MAC80211(priv, \"leave\\n\");\n\n\treturn ret;\n}\n\nstruct iwl_resume_data {\n\tstruct iwl_priv *priv;\n\tstruct iwlagn_wowlan_status *cmd;\n\tbool valid;\n};\n\nstatic bool iwl_resume_status_fn(struct iwl_notif_wait_data *notif_wait,\n\t\t\t\t struct iwl_rx_packet *pkt, void *data)\n{\n\tstruct iwl_resume_data *resume_data = data;\n\tstruct iwl_priv *priv = resume_data->priv;\n\n\tif (iwl_rx_packet_payload_len(pkt) != sizeof(*resume_data->cmd)) {\n\t\tIWL_ERR(priv, \"rx wrong size data\\n\");\n\t\treturn true;\n\t}\n\tmemcpy(resume_data->cmd, pkt->data, sizeof(*resume_data->cmd));\n\tresume_data->valid = true;\n\n\treturn true;\n}\n\nstatic int iwlagn_mac_resume(struct ieee80211_hw *hw)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\tstruct iwl_rxon_context *ctx = &priv->contexts[IWL_RXON_CTX_BSS];\n\tstruct ieee80211_vif *vif;\n\tu32 base;\n\tint ret;\n\tenum iwl_d3_status d3_status;\n\tstruct error_table_start {\n\t\t \n\t\tu32 valid;\n\t\tu32 error_id;\n\t} err_info;\n\tstruct iwl_notification_wait status_wait;\n\tstatic const u16 status_cmd[] = {\n\t\tREPLY_WOWLAN_GET_STATUS,\n\t};\n\tstruct iwlagn_wowlan_status status_data = {};\n\tstruct iwl_resume_data resume_data = {\n\t\t.priv = priv,\n\t\t.cmd = &status_data,\n\t\t.valid = false,\n\t};\n\tstruct cfg80211_wowlan_wakeup wakeup = {\n\t\t.pattern_idx = -1,\n\t};\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tconst struct fw_img *img;\n#endif\n\n\tIWL_DEBUG_MAC80211(priv, \"enter\\n\");\n\tmutex_lock(&priv->mutex);\n\n\t \n\tvif = ctx->vif;\n\n\tret = iwl_trans_d3_resume(priv->trans, &d3_status, false, true);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tif (d3_status != IWL_D3_STATUS_ALIVE) {\n\t\tIWL_INFO(priv, \"Device was reset during suspend\\n\");\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tiwl_write32(priv->trans, CSR_UCODE_DRV_GP1_CLR,\n\t\t    CSR_UCODE_DRV_GP1_BIT_D3_CFG_COMPLETE);\n\n\tbase = priv->device_pointers.error_event_table;\n\tif (!iwlagn_hw_valid_rtc_data_addr(base)) {\n\t\tIWL_WARN(priv, \"Invalid error table during resume!\\n\");\n\t\tgoto out_unlock;\n\t}\n\n\tiwl_trans_read_mem_bytes(priv->trans, base,\n\t\t\t\t &err_info, sizeof(err_info));\n\n\tif (err_info.valid) {\n\t\tIWL_INFO(priv, \"error table is valid (%d, 0x%x)\\n\",\n\t\t\t err_info.valid, err_info.error_id);\n\t\tif (err_info.error_id == RF_KILL_INDICATOR_FOR_WOWLAN) {\n\t\t\twakeup.rfkill_release = true;\n\t\t\tieee80211_report_wowlan_wakeup(vif, &wakeup,\n\t\t\t\t\t\t       GFP_KERNEL);\n\t\t}\n\t\tgoto out_unlock;\n\t}\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\timg = &priv->fw->img[IWL_UCODE_WOWLAN];\n\tif (!priv->wowlan_sram)\n\t\tpriv->wowlan_sram =\n\t\t\tkzalloc(img->sec[IWL_UCODE_SECTION_DATA].len,\n\t\t\t\tGFP_KERNEL);\n\n\tif (priv->wowlan_sram)\n\t\tiwl_trans_read_mem(priv->trans, 0x800000,\n\t\t\t\t   priv->wowlan_sram,\n\t\t\t\t   img->sec[IWL_UCODE_SECTION_DATA].len / 4);\n#endif\n\n\t \n\n\tiwl_init_notification_wait(&priv->notif_wait, &status_wait, status_cmd,\n\t\t\t\t   ARRAY_SIZE(status_cmd), iwl_resume_status_fn,\n\t\t\t\t   &resume_data);\n\n\tiwl_dvm_send_cmd_pdu(priv, REPLY_WOWLAN_GET_STATUS, CMD_ASYNC, 0, NULL);\n\tiwl_dvm_send_cmd_pdu(priv, REPLY_ECHO, CMD_ASYNC, 0, NULL);\n\t \n\n\tret = iwl_wait_notification(&priv->notif_wait, &status_wait, HZ/5);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tif (resume_data.valid && priv->contexts[IWL_RXON_CTX_BSS].vif) {\n\t\tu32 reasons = le32_to_cpu(status_data.wakeup_reason);\n\t\tstruct cfg80211_wowlan_wakeup *wakeup_report;\n\n\t\tIWL_INFO(priv, \"WoWLAN wakeup reason(s): 0x%.8x\\n\", reasons);\n\n\t\tif (reasons) {\n\t\t\tif (reasons & IWLAGN_WOWLAN_WAKEUP_MAGIC_PACKET)\n\t\t\t\twakeup.magic_pkt = true;\n\t\t\tif (reasons & IWLAGN_WOWLAN_WAKEUP_PATTERN_MATCH)\n\t\t\t\twakeup.pattern_idx = status_data.pattern_number;\n\t\t\tif (reasons & (IWLAGN_WOWLAN_WAKEUP_BEACON_MISS |\n\t\t\t\t       IWLAGN_WOWLAN_WAKEUP_LINK_CHANGE))\n\t\t\t\twakeup.disconnect = true;\n\t\t\tif (reasons & IWLAGN_WOWLAN_WAKEUP_GTK_REKEY_FAIL)\n\t\t\t\twakeup.gtk_rekey_failure = true;\n\t\t\tif (reasons & IWLAGN_WOWLAN_WAKEUP_EAP_IDENT_REQ)\n\t\t\t\twakeup.eap_identity_req = true;\n\t\t\tif (reasons & IWLAGN_WOWLAN_WAKEUP_4WAY_HANDSHAKE)\n\t\t\t\twakeup.four_way_handshake = true;\n\t\t\twakeup_report = &wakeup;\n\t\t} else {\n\t\t\twakeup_report = NULL;\n\t\t}\n\n\t\tieee80211_report_wowlan_wakeup(vif, wakeup_report, GFP_KERNEL);\n\t}\n\n\tpriv->wowlan = false;\n\n\tiwlagn_prepare_restart(priv);\n\n\tmemset((void *)&ctx->active, 0, sizeof(ctx->active));\n\tiwl_connection_init_rx_config(priv, ctx);\n\tiwlagn_set_rxon_chain(priv, ctx);\n\n out_unlock:\n\tmutex_unlock(&priv->mutex);\n\tIWL_DEBUG_MAC80211(priv, \"leave\\n\");\n\n\tieee80211_resume_disconnect(vif);\n\n\treturn 1;\n}\n\nstatic void iwlagn_mac_set_wakeup(struct ieee80211_hw *hw, bool enabled)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\n\tdevice_set_wakeup_enable(priv->trans->dev, enabled);\n}\n#endif\n\nstatic void iwlagn_mac_tx(struct ieee80211_hw *hw,\n\t\t\t  struct ieee80211_tx_control *control,\n\t\t\t  struct sk_buff *skb)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\n\tif (iwlagn_tx_skb(priv, control->sta, skb))\n\t\tieee80211_free_txskb(hw, skb);\n}\n\nstatic void iwlagn_mac_update_tkip_key(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_key_conf *keyconf,\n\t\t\t\t       struct ieee80211_sta *sta,\n\t\t\t\t       u32 iv32, u16 *phase1key)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\n\tiwl_update_tkip_key(priv, vif, keyconf, sta, iv32, phase1key);\n}\n\nstatic int iwlagn_mac_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_sta *sta,\n\t\t\t      struct ieee80211_key_conf *key)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\tstruct iwl_vif_priv *vif_priv = (void *)vif->drv_priv;\n\tstruct iwl_rxon_context *ctx = vif_priv->ctx;\n\tint ret;\n\tbool is_default_wep_key = false;\n\n\tIWL_DEBUG_MAC80211(priv, \"enter\\n\");\n\n\tif (iwlwifi_mod_params.swcrypto) {\n\t\tIWL_DEBUG_MAC80211(priv, \"leave - hwcrypto disabled\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;\n\t\tfallthrough;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (vif->type == NL80211_IFTYPE_ADHOC &&\n\t    !(key->flags & IEEE80211_KEY_FLAG_PAIRWISE)) {\n\t\tkey->hw_key_idx = WEP_INVALID_OFFSET;\n\t\treturn 0;\n\t}\n\n\t \n\tif (cmd == DISABLE_KEY && key->hw_key_idx == WEP_INVALID_OFFSET)\n\t\treturn 0;\n\n\tmutex_lock(&priv->mutex);\n\tiwl_scan_cancel_timeout(priv, 100);\n\n\tBUILD_BUG_ON(WEP_INVALID_OFFSET == IWLAGN_HW_KEY_DEFAULT);\n\n\t \n\tif ((key->cipher == WLAN_CIPHER_SUITE_WEP40 ||\n\t     key->cipher == WLAN_CIPHER_SUITE_WEP104) && !sta) {\n\t\tif (cmd == SET_KEY)\n\t\t\tis_default_wep_key = !ctx->key_mapping_keys;\n\t\telse\n\t\t\tis_default_wep_key =\n\t\t\t\tkey->hw_key_idx == IWLAGN_HW_KEY_DEFAULT;\n\t}\n\n\n\tswitch (cmd) {\n\tcase SET_KEY:\n\t\tif (is_default_wep_key) {\n\t\t\tret = iwl_set_default_wep_key(priv, vif_priv->ctx, key);\n\t\t\tbreak;\n\t\t}\n\t\tret = iwl_set_dynamic_key(priv, vif_priv->ctx, key, sta);\n\t\tif (ret) {\n\t\t\t \n\t\t\tret = 0;\n\t\t\tkey->hw_key_idx = WEP_INVALID_OFFSET;\n\t\t}\n\n\t\tIWL_DEBUG_MAC80211(priv, \"enable hwcrypto key\\n\");\n\t\tbreak;\n\tcase DISABLE_KEY:\n\t\tif (is_default_wep_key)\n\t\t\tret = iwl_remove_default_wep_key(priv, ctx, key);\n\t\telse\n\t\t\tret = iwl_remove_dynamic_key(priv, ctx, key, sta);\n\n\t\tIWL_DEBUG_MAC80211(priv, \"disable hwcrypto key\\n\");\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&priv->mutex);\n\tIWL_DEBUG_MAC80211(priv, \"leave\\n\");\n\n\treturn ret;\n}\n\nstatic int iwlagn_mac_ampdu_action(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_ampdu_params *params)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\tint ret = -EINVAL;\n\tstruct ieee80211_sta *sta = params->sta;\n\tenum ieee80211_ampdu_mlme_action action = params->action;\n\tu16 tid = params->tid;\n\tu16 *ssn = &params->ssn;\n\tu8 buf_size = params->buf_size;\n\tstruct iwl_station_priv *sta_priv = (void *) sta->drv_priv;\n\n\tIWL_DEBUG_HT(priv, \"A-MPDU action on addr %pM tid %d\\n\",\n\t\t     sta->addr, tid);\n\n\tif (!(priv->nvm_data->sku_cap_11n_enable))\n\t\treturn -EACCES;\n\n\tIWL_DEBUG_MAC80211(priv, \"enter\\n\");\n\tmutex_lock(&priv->mutex);\n\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_RX_START:\n\t\tif (!iwl_enable_rx_ampdu())\n\t\t\tbreak;\n\t\tIWL_DEBUG_HT(priv, \"start Rx\\n\");\n\t\tret = iwl_sta_rx_agg_start(priv, sta, tid, *ssn);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\tIWL_DEBUG_HT(priv, \"stop Rx\\n\");\n\t\tret = iwl_sta_rx_agg_stop(priv, sta, tid);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_START:\n\t\tif (!priv->trans->ops->txq_enable)\n\t\t\tbreak;\n\t\tif (!iwl_enable_tx_ampdu())\n\t\t\tbreak;\n\t\tIWL_DEBUG_HT(priv, \"start Tx\\n\");\n\t\tret = iwlagn_tx_agg_start(priv, vif, sta, tid, ssn);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\t\tIWL_DEBUG_HT(priv, \"Flush Tx\\n\");\n\t\tret = iwlagn_tx_agg_flush(priv, vif, sta, tid);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\t\tIWL_DEBUG_HT(priv, \"stop Tx\\n\");\n\t\tret = iwlagn_tx_agg_stop(priv, vif, sta, tid);\n\t\tif ((ret == 0) && (priv->agg_tids_count > 0)) {\n\t\t\tpriv->agg_tids_count--;\n\t\t\tIWL_DEBUG_HT(priv, \"priv->agg_tids_count = %u\\n\",\n\t\t\t\t     priv->agg_tids_count);\n\t\t}\n\t\tif (!priv->agg_tids_count &&\n\t\t    priv->hw_params.use_rts_for_aggregation) {\n\t\t\t \n\t\t\tsta_priv->lq_sta.lq.general_params.flags &=\n\t\t\t\t~LINK_QUAL_FLAGS_SET_STA_TLC_RTS_MSK;\n\t\t\tiwl_send_lq_cmd(priv, iwl_rxon_ctx_from_vif(vif),\n\t\t\t\t\t&sta_priv->lq_sta.lq, CMD_ASYNC, false);\n\t\t}\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\tret = iwlagn_tx_agg_oper(priv, vif, sta, tid, buf_size);\n\t\tbreak;\n\t}\n\tmutex_unlock(&priv->mutex);\n\tIWL_DEBUG_MAC80211(priv, \"leave\\n\");\n\treturn ret;\n}\n\nstatic int iwlagn_mac_sta_add(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_sta *sta)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\tstruct iwl_station_priv *sta_priv = (void *)sta->drv_priv;\n\tstruct iwl_vif_priv *vif_priv = (void *)vif->drv_priv;\n\tbool is_ap = vif->type == NL80211_IFTYPE_STATION;\n\tint ret;\n\tu8 sta_id;\n\n\tIWL_DEBUG_INFO(priv, \"proceeding to add station %pM\\n\",\n\t\t\tsta->addr);\n\tsta_priv->sta_id = IWL_INVALID_STATION;\n\n\tatomic_set(&sta_priv->pending_frames, 0);\n\tif (vif->type == NL80211_IFTYPE_AP)\n\t\tsta_priv->client = true;\n\n\tret = iwl_add_station_common(priv, vif_priv->ctx, sta->addr,\n\t\t\t\t     is_ap, sta, &sta_id);\n\tif (ret) {\n\t\tIWL_ERR(priv, \"Unable to add station %pM (%d)\\n\",\n\t\t\tsta->addr, ret);\n\t\t \n\t\treturn ret;\n\t}\n\n\tsta_priv->sta_id = sta_id;\n\n\treturn 0;\n}\n\nstatic int iwlagn_mac_sta_remove(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_sta *sta)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\tstruct iwl_station_priv *sta_priv = (void *)sta->drv_priv;\n\tint ret;\n\n\tIWL_DEBUG_INFO(priv, \"proceeding to remove station %pM\\n\", sta->addr);\n\n\tif (vif->type == NL80211_IFTYPE_STATION) {\n\t\t \n\t\tret = 0;\n\t\tiwl_deactivate_station(priv, sta_priv->sta_id, sta->addr);\n\t} else {\n\t\tret = iwl_remove_station(priv, sta_priv->sta_id, sta->addr);\n\t\tif (ret)\n\t\t\tIWL_DEBUG_QUIET_RFKILL(priv,\n\t\t\t\t\"Error removing station %pM\\n\", sta->addr);\n\t}\n\treturn ret;\n}\n\nstatic int iwlagn_mac_sta_state(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\tenum ieee80211_sta_state old_state,\n\t\t\t\tenum ieee80211_sta_state new_state)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\tstruct iwl_vif_priv *vif_priv = (void *)vif->drv_priv;\n\tenum {\n\t\tNONE, ADD, REMOVE, HT_RATE_INIT, ADD_RATE_INIT,\n\t} op = NONE;\n\tint ret;\n\n\tIWL_DEBUG_MAC80211(priv, \"station %pM state change %d->%d\\n\",\n\t\t\t   sta->addr, old_state, new_state);\n\n\tmutex_lock(&priv->mutex);\n\tif (vif->type == NL80211_IFTYPE_STATION) {\n\t\tif (old_state == IEEE80211_STA_NOTEXIST &&\n\t\t    new_state == IEEE80211_STA_NONE)\n\t\t\top = ADD;\n\t\telse if (old_state == IEEE80211_STA_NONE &&\n\t\t\t new_state == IEEE80211_STA_NOTEXIST)\n\t\t\top = REMOVE;\n\t\telse if (old_state == IEEE80211_STA_AUTH &&\n\t\t\t new_state == IEEE80211_STA_ASSOC)\n\t\t\top = HT_RATE_INIT;\n\t} else {\n\t\tif (old_state == IEEE80211_STA_AUTH &&\n\t\t    new_state == IEEE80211_STA_ASSOC)\n\t\t\top = ADD_RATE_INIT;\n\t\telse if (old_state == IEEE80211_STA_ASSOC &&\n\t\t\t new_state == IEEE80211_STA_AUTH)\n\t\t\top = REMOVE;\n\t}\n\n\tswitch (op) {\n\tcase ADD:\n\t\tret = iwlagn_mac_sta_add(hw, vif, sta);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t \n\t\tspin_lock_bh(&priv->sta_lock);\n\t\tpriv->stations[iwl_sta_id(sta)].used &=\n\t\t\t~IWL_STA_UCODE_INPROGRESS;\n\t\tspin_unlock_bh(&priv->sta_lock);\n\t\tbreak;\n\tcase REMOVE:\n\t\tret = iwlagn_mac_sta_remove(hw, vif, sta);\n\t\tbreak;\n\tcase ADD_RATE_INIT:\n\t\tret = iwlagn_mac_sta_add(hw, vif, sta);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t \n\t\tIWL_DEBUG_INFO(priv,\n\t\t\t       \"Initializing rate scaling for station %pM\\n\",\n\t\t\t       sta->addr);\n\t\tiwl_rs_rate_init(priv, sta, iwl_sta_id(sta));\n\t\tret = 0;\n\t\tbreak;\n\tcase HT_RATE_INIT:\n\t\t \n\t\tret = iwl_sta_update_ht(priv, vif_priv->ctx, sta);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tIWL_DEBUG_INFO(priv,\n\t\t\t       \"Initializing rate scaling for station %pM\\n\",\n\t\t\t       sta->addr);\n\t\tiwl_rs_rate_init(priv, sta, iwl_sta_id(sta));\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\t \n\tif (iwl_is_rfkill(priv))\n\t\tret = 0;\n\n\tmutex_unlock(&priv->mutex);\n\tIWL_DEBUG_MAC80211(priv, \"leave\\n\");\n\n\treturn ret;\n}\n\nstatic void iwlagn_mac_channel_switch(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_channel_switch *ch_switch)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tstruct ieee80211_channel *channel = ch_switch->chandef.chan;\n\tstruct iwl_ht_config *ht_conf = &priv->current_ht_config;\n\t \n\tstruct iwl_rxon_context *ctx = &priv->contexts[IWL_RXON_CTX_BSS];\n\tu16 ch;\n\n\tIWL_DEBUG_MAC80211(priv, \"enter\\n\");\n\n\tmutex_lock(&priv->mutex);\n\n\tif (iwl_is_rfkill(priv))\n\t\tgoto out;\n\n\tif (test_bit(STATUS_EXIT_PENDING, &priv->status) ||\n\t    test_bit(STATUS_SCANNING, &priv->status) ||\n\t    test_bit(STATUS_CHANNEL_SWITCH_PENDING, &priv->status))\n\t\tgoto out;\n\n\tif (!iwl_is_associated_ctx(ctx))\n\t\tgoto out;\n\n\tif (!priv->lib->set_channel_switch)\n\t\tgoto out;\n\n\tch = channel->hw_value;\n\tif (le16_to_cpu(ctx->active.channel) == ch)\n\t\tgoto out;\n\n\tpriv->current_ht_config.smps = conf->smps_mode;\n\n\t \n\tswitch (cfg80211_get_chandef_type(&ch_switch->chandef)) {\n\tcase NL80211_CHAN_NO_HT:\n\tcase NL80211_CHAN_HT20:\n\t\tctx->ht.is_40mhz = false;\n\t\tctx->ht.extension_chan_offset = IEEE80211_HT_PARAM_CHA_SEC_NONE;\n\t\tbreak;\n\tcase NL80211_CHAN_HT40MINUS:\n\t\tctx->ht.extension_chan_offset = IEEE80211_HT_PARAM_CHA_SEC_BELOW;\n\t\tctx->ht.is_40mhz = true;\n\t\tbreak;\n\tcase NL80211_CHAN_HT40PLUS:\n\t\tctx->ht.extension_chan_offset = IEEE80211_HT_PARAM_CHA_SEC_ABOVE;\n\t\tctx->ht.is_40mhz = true;\n\t\tbreak;\n\t}\n\n\tif ((le16_to_cpu(ctx->staging.channel) != ch))\n\t\tctx->staging.flags = 0;\n\n\tiwl_set_rxon_channel(priv, channel, ctx);\n\tiwl_set_rxon_ht(priv, ht_conf);\n\tiwl_set_flags_for_band(priv, ctx, channel->band, ctx->vif);\n\n\t \n\tset_bit(STATUS_CHANNEL_SWITCH_PENDING, &priv->status);\n\tpriv->switch_channel = cpu_to_le16(ch);\n\tif (priv->lib->set_channel_switch(priv, ch_switch)) {\n\t\tclear_bit(STATUS_CHANNEL_SWITCH_PENDING, &priv->status);\n\t\tpriv->switch_channel = 0;\n\t\tieee80211_chswitch_done(ctx->vif, false);\n\t}\n\nout:\n\tmutex_unlock(&priv->mutex);\n\tIWL_DEBUG_MAC80211(priv, \"leave\\n\");\n}\n\nvoid iwl_chswitch_done(struct iwl_priv *priv, bool is_success)\n{\n\t \n\tstruct iwl_rxon_context *ctx = &priv->contexts[IWL_RXON_CTX_BSS];\n\n\tif (test_bit(STATUS_EXIT_PENDING, &priv->status))\n\t\treturn;\n\n\tif (!test_and_clear_bit(STATUS_CHANNEL_SWITCH_PENDING, &priv->status))\n\t\treturn;\n\n\tif (ctx->vif)\n\t\tieee80211_chswitch_done(ctx->vif, is_success);\n}\n\nstatic void iwlagn_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t    unsigned int changed_flags,\n\t\t\t\t    unsigned int *total_flags,\n\t\t\t\t    u64 multicast)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\t__le32 filter_or = 0, filter_nand = 0;\n\tstruct iwl_rxon_context *ctx;\n\n#define CHK(test, flag)\tdo { \\\n\tif (*total_flags & (test))\t\t\\\n\t\tfilter_or |= (flag);\t\t\\\n\telse\t\t\t\t\t\\\n\t\tfilter_nand |= (flag);\t\t\\\n\t} while (0)\n\n\tIWL_DEBUG_MAC80211(priv, \"Enter: changed: 0x%x, total: 0x%x\\n\",\n\t\t\tchanged_flags, *total_flags);\n\n\tCHK(FIF_OTHER_BSS, RXON_FILTER_PROMISC_MSK);\n\t \n\tCHK(FIF_CONTROL, RXON_FILTER_CTL2HOST_MSK | RXON_FILTER_PROMISC_MSK);\n\tCHK(FIF_BCN_PRBRESP_PROMISC, RXON_FILTER_BCON_AWARE_MSK);\n\n#undef CHK\n\n\tmutex_lock(&priv->mutex);\n\n\tfor_each_context(priv, ctx) {\n\t\tctx->staging.filter_flags &= ~filter_nand;\n\t\tctx->staging.filter_flags |= filter_or;\n\n\t\t \n\t}\n\n\tmutex_unlock(&priv->mutex);\n\n\t \n\t*total_flags &= FIF_OTHER_BSS | FIF_ALLMULTI |\n\t\t\tFIF_BCN_PRBRESP_PROMISC | FIF_CONTROL;\n}\n\nstatic void iwlagn_mac_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t     u32 queues, bool drop)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\tu32 scd_queues;\n\n\tmutex_lock(&priv->mutex);\n\tIWL_DEBUG_MAC80211(priv, \"enter\\n\");\n\n\tif (test_bit(STATUS_EXIT_PENDING, &priv->status)) {\n\t\tIWL_DEBUG_TX(priv, \"Aborting flush due to device shutdown\\n\");\n\t\tgoto done;\n\t}\n\tif (iwl_is_rfkill(priv)) {\n\t\tIWL_DEBUG_TX(priv, \"Aborting flush due to RF Kill\\n\");\n\t\tgoto done;\n\t}\n\n\tscd_queues = BIT(priv->trans->trans_cfg->base_params->num_of_queues) - 1;\n\tscd_queues &= ~(BIT(IWL_IPAN_CMD_QUEUE_NUM) |\n\t\t\tBIT(IWL_DEFAULT_CMD_QUEUE_NUM));\n\n\tif (drop) {\n\t\tIWL_DEBUG_TX_QUEUES(priv, \"Flushing SCD queues: 0x%x\\n\",\n\t\t\t\t    scd_queues);\n\t\tif (iwlagn_txfifo_flush(priv, scd_queues)) {\n\t\t\tIWL_ERR(priv, \"flush request fail\\n\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tIWL_DEBUG_TX_QUEUES(priv, \"wait transmit/flush all frames\\n\");\n\tiwl_trans_wait_tx_queues_empty(priv->trans, scd_queues);\ndone:\n\tmutex_unlock(&priv->mutex);\n\tIWL_DEBUG_MAC80211(priv, \"leave\\n\");\n}\n\nstatic void iwlagn_mac_event_callback(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      const struct ieee80211_event *event)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\n\tif (event->type != RSSI_EVENT)\n\t\treturn;\n\n\tIWL_DEBUG_MAC80211(priv, \"enter\\n\");\n\n\tif (priv->lib->bt_params &&\n\t    priv->lib->bt_params->advanced_bt_coexist) {\n\t\tif (event->u.rssi.data == RSSI_EVENT_LOW)\n\t\t\tpriv->bt_enable_pspoll = true;\n\t\telse if (event->u.rssi.data == RSSI_EVENT_HIGH)\n\t\t\tpriv->bt_enable_pspoll = false;\n\n\t\tqueue_work(priv->workqueue, &priv->bt_runtime_config);\n\t} else {\n\t\tIWL_DEBUG_MAC80211(priv, \"Advanced BT coex disabled,\"\n\t\t\t\t\"ignoring RSSI callback\\n\");\n\t}\n\n\tIWL_DEBUG_MAC80211(priv, \"leave\\n\");\n}\n\nstatic int iwlagn_mac_set_tim(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_sta *sta, bool set)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\n\tqueue_work(priv->workqueue, &priv->beacon_update);\n\n\treturn 0;\n}\n\nstatic int iwlagn_mac_conf_tx(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      unsigned int link_id, u16 queue,\n\t\t\t      const struct ieee80211_tx_queue_params *params)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\tstruct iwl_vif_priv *vif_priv = (void *)vif->drv_priv;\n\tstruct iwl_rxon_context *ctx = vif_priv->ctx;\n\tint q;\n\n\tif (WARN_ON(!ctx))\n\t\treturn -EINVAL;\n\n\tIWL_DEBUG_MAC80211(priv, \"enter\\n\");\n\n\tif (!iwl_is_ready_rf(priv)) {\n\t\tIWL_DEBUG_MAC80211(priv, \"leave - RF not ready\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (queue >= AC_NUM) {\n\t\tIWL_DEBUG_MAC80211(priv, \"leave - queue >= AC_NUM %d\\n\", queue);\n\t\treturn 0;\n\t}\n\n\tq = AC_NUM - 1 - queue;\n\n\tmutex_lock(&priv->mutex);\n\n\tctx->qos_data.def_qos_parm.ac[q].cw_min =\n\t\tcpu_to_le16(params->cw_min);\n\tctx->qos_data.def_qos_parm.ac[q].cw_max =\n\t\tcpu_to_le16(params->cw_max);\n\tctx->qos_data.def_qos_parm.ac[q].aifsn = params->aifs;\n\tctx->qos_data.def_qos_parm.ac[q].edca_txop =\n\t\t\tcpu_to_le16((params->txop * 32));\n\n\tctx->qos_data.def_qos_parm.ac[q].reserved1 = 0;\n\n\tmutex_unlock(&priv->mutex);\n\n\tIWL_DEBUG_MAC80211(priv, \"leave\\n\");\n\treturn 0;\n}\n\nstatic int iwlagn_mac_tx_last_beacon(struct ieee80211_hw *hw)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\n\treturn priv->ibss_manager == IWL_IBSS_MANAGER;\n}\n\nstatic int iwl_set_mode(struct iwl_priv *priv, struct iwl_rxon_context *ctx)\n{\n\tiwl_connection_init_rx_config(priv, ctx);\n\n\tiwlagn_set_rxon_chain(priv, ctx);\n\n\treturn iwlagn_commit_rxon(priv, ctx);\n}\n\nstatic int iwl_setup_interface(struct iwl_priv *priv,\n\t\t\t       struct iwl_rxon_context *ctx)\n{\n\tstruct ieee80211_vif *vif = ctx->vif;\n\tint err, ac;\n\n\tlockdep_assert_held(&priv->mutex);\n\n\t \n\tpriv->iw_mode = vif->type;\n\n\tctx->is_active = true;\n\n\terr = iwl_set_mode(priv, ctx);\n\tif (err) {\n\t\tif (!ctx->always_active)\n\t\t\tctx->is_active = false;\n\t\treturn err;\n\t}\n\n\tif (priv->lib->bt_params && priv->lib->bt_params->advanced_bt_coexist &&\n\t    vif->type == NL80211_IFTYPE_ADHOC) {\n\t\t \n\t\tpriv->bt_traffic_load = IWL_BT_COEX_TRAFFIC_LOAD_HIGH;\n\t}\n\n\t \n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\n\t\tvif->hw_queue[ac] = ctx->ac_to_queue[ac];\n\n\tif (vif->type == NL80211_IFTYPE_AP)\n\t\tvif->cab_queue = ctx->mcast_queue;\n\telse\n\t\tvif->cab_queue = IEEE80211_INVAL_HW_QUEUE;\n\n\treturn 0;\n}\n\nstatic int iwlagn_mac_add_interface(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\tstruct iwl_vif_priv *vif_priv = (void *)vif->drv_priv;\n\tstruct iwl_rxon_context *tmp, *ctx = NULL;\n\tint err;\n\tenum nl80211_iftype viftype = ieee80211_vif_type_p2p(vif);\n\tbool reset = false;\n\n\tIWL_DEBUG_MAC80211(priv, \"enter: type %d, addr %pM\\n\",\n\t\t\t   viftype, vif->addr);\n\n\tmutex_lock(&priv->mutex);\n\n\tif (!iwl_is_ready_rf(priv)) {\n\t\tIWL_WARN(priv, \"Try to add interface when device not ready\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor_each_context(priv, tmp) {\n\t\tu32 possible_modes =\n\t\t\ttmp->interface_modes | tmp->exclusive_interface_modes;\n\n\t\tif (tmp->vif) {\n\t\t\t \n\t\t\tif (tmp->vif == vif) {\n\t\t\t\treset = true;\n\t\t\t\tctx = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (tmp->exclusive_interface_modes &\n\t\t\t\t\t\tBIT(tmp->vif->type)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(possible_modes & BIT(viftype)))\n\t\t\tcontinue;\n\n\t\t \n\t\tctx = tmp;\n\t\tbreak;\n\t}\n\n\tif (!ctx) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tvif_priv->ctx = ctx;\n\tctx->vif = vif;\n\n\t \n\tif (vif->type == NL80211_IFTYPE_MONITOR)\n\t\tieee80211_hw_set(priv->hw, RX_INCLUDES_FCS);\n\telse\n\t\t__clear_bit(IEEE80211_HW_RX_INCLUDES_FCS, priv->hw->flags);\n\n\terr = iwl_setup_interface(priv, ctx);\n\tif (!err || reset)\n\t\tgoto out;\n\n\tctx->vif = NULL;\n\tpriv->iw_mode = NL80211_IFTYPE_STATION;\n out:\n\tmutex_unlock(&priv->mutex);\n\n\tIWL_DEBUG_MAC80211(priv, \"leave\\n\");\n\treturn err;\n}\n\nstatic void iwl_teardown_interface(struct iwl_priv *priv,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   bool mode_change)\n{\n\tstruct iwl_rxon_context *ctx = iwl_rxon_ctx_from_vif(vif);\n\n\tlockdep_assert_held(&priv->mutex);\n\n\tif (priv->scan_vif == vif) {\n\t\tiwl_scan_cancel_timeout(priv, 200);\n\t\tiwl_force_scan_end(priv);\n\t}\n\n\tif (!mode_change) {\n\t\tiwl_set_mode(priv, ctx);\n\t\tif (!ctx->always_active)\n\t\t\tctx->is_active = false;\n\t}\n\n\t \n\tif (vif->type == NL80211_IFTYPE_ADHOC)\n\t\tpriv->bt_traffic_load = priv->last_bt_traffic_load;\n}\n\nstatic void iwlagn_mac_remove_interface(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\tstruct iwl_rxon_context *ctx = iwl_rxon_ctx_from_vif(vif);\n\n\tIWL_DEBUG_MAC80211(priv, \"enter\\n\");\n\n\tmutex_lock(&priv->mutex);\n\n\tWARN_ON(ctx->vif != vif);\n\tctx->vif = NULL;\n\n\tiwl_teardown_interface(priv, vif, false);\n\n\tmutex_unlock(&priv->mutex);\n\n\tIWL_DEBUG_MAC80211(priv, \"leave\\n\");\n\n}\n\nstatic int iwlagn_mac_change_interface(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       enum nl80211_iftype newtype, bool newp2p)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\tstruct iwl_rxon_context *ctx, *tmp;\n\tenum nl80211_iftype newviftype = newtype;\n\tu32 interface_modes;\n\tint err;\n\n\tIWL_DEBUG_MAC80211(priv, \"enter\\n\");\n\n\tnewtype = ieee80211_iftype_p2p(newtype, newp2p);\n\n\tmutex_lock(&priv->mutex);\n\n\tctx = iwl_rxon_ctx_from_vif(vif);\n\n\t \n\tif (ctx->ctxid != IWL_RXON_CTX_BSS) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (!ctx->vif || !iwl_is_ready_rf(priv)) {\n\t\t \n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tinterface_modes = ctx->interface_modes | ctx->exclusive_interface_modes;\n\tif (!(interface_modes & BIT(newtype))) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (ctx->exclusive_interface_modes & BIT(newtype)) {\n\t\tfor_each_context(priv, tmp) {\n\t\t\tif (ctx == tmp)\n\t\t\t\tcontinue;\n\n\t\t\tif (!tmp->is_active)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\terr = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tiwl_teardown_interface(priv, vif, true);\n\tvif->type = newviftype;\n\tvif->p2p = newp2p;\n\terr = iwl_setup_interface(priv, ctx);\n\tWARN_ON(err);\n\t \n\terr = 0;\n\n out:\n\tmutex_unlock(&priv->mutex);\n\tIWL_DEBUG_MAC80211(priv, \"leave\\n\");\n\n\treturn err;\n}\n\nstatic int iwlagn_mac_hw_scan(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_scan_request *hw_req)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\tstruct cfg80211_scan_request *req = &hw_req->req;\n\tint ret;\n\n\tIWL_DEBUG_MAC80211(priv, \"enter\\n\");\n\n\tif (req->n_channels == 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->mutex);\n\n\t \n\tif (priv->scan_type != IWL_SCAN_NORMAL) {\n\t\tIWL_DEBUG_SCAN(priv,\n\t\t\t       \"SCAN request during internal scan - defer\\n\");\n\t\tpriv->scan_request = req;\n\t\tpriv->scan_vif = vif;\n\t\tret = 0;\n\t} else {\n\t\tpriv->scan_request = req;\n\t\tpriv->scan_vif = vif;\n\t\t \n\t\tret = iwl_scan_initiate(priv, vif, IWL_SCAN_NORMAL,\n\t\t\t\t\treq->channels[0]->band);\n\t\tif (ret) {\n\t\t\tpriv->scan_request = NULL;\n\t\t\tpriv->scan_vif = NULL;\n\t\t}\n\t}\n\n\tIWL_DEBUG_MAC80211(priv, \"leave\\n\");\n\n\tmutex_unlock(&priv->mutex);\n\n\treturn ret;\n}\n\nstatic void iwl_sta_modify_ps_wake(struct iwl_priv *priv, int sta_id)\n{\n\tstruct iwl_addsta_cmd cmd = {\n\t\t.mode = STA_CONTROL_MODIFY_MSK,\n\t\t.station_flags_msk = STA_FLG_PWR_SAVE_MSK,\n\t\t.sta.sta_id = sta_id,\n\t};\n\n\tiwl_send_add_sta(priv, &cmd, CMD_ASYNC);\n}\n\nstatic void iwlagn_mac_sta_notify(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  enum sta_notify_cmd cmd,\n\t\t\t\t  struct ieee80211_sta *sta)\n{\n\tstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\n\tstruct iwl_station_priv *sta_priv = (void *)sta->drv_priv;\n\tint sta_id;\n\n\tIWL_DEBUG_MAC80211(priv, \"enter\\n\");\n\n\tswitch (cmd) {\n\tcase STA_NOTIFY_SLEEP:\n\t\tWARN_ON(!sta_priv->client);\n\t\tsta_priv->asleep = true;\n\t\tif (atomic_read(&sta_priv->pending_frames) > 0)\n\t\t\tieee80211_sta_block_awake(hw, sta, true);\n\t\tbreak;\n\tcase STA_NOTIFY_AWAKE:\n\t\tWARN_ON(!sta_priv->client);\n\t\tif (!sta_priv->asleep)\n\t\t\tbreak;\n\t\tsta_priv->asleep = false;\n\t\tsta_id = iwl_sta_id(sta);\n\t\tif (sta_id != IWL_INVALID_STATION)\n\t\t\tiwl_sta_modify_ps_wake(priv, sta_id);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tIWL_DEBUG_MAC80211(priv, \"leave\\n\");\n}\n\nconst struct ieee80211_ops iwlagn_hw_ops = {\n\t.tx = iwlagn_mac_tx,\n\t.wake_tx_queue = ieee80211_handle_wake_tx_queue,\n\t.start = iwlagn_mac_start,\n\t.stop = iwlagn_mac_stop,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend = iwlagn_mac_suspend,\n\t.resume = iwlagn_mac_resume,\n\t.set_wakeup = iwlagn_mac_set_wakeup,\n#endif\n\t.add_interface = iwlagn_mac_add_interface,\n\t.remove_interface = iwlagn_mac_remove_interface,\n\t.change_interface = iwlagn_mac_change_interface,\n\t.config = iwlagn_mac_config,\n\t.configure_filter = iwlagn_configure_filter,\n\t.set_key = iwlagn_mac_set_key,\n\t.update_tkip_key = iwlagn_mac_update_tkip_key,\n\t.set_rekey_data = iwlagn_mac_set_rekey_data,\n\t.conf_tx = iwlagn_mac_conf_tx,\n\t.bss_info_changed = iwlagn_bss_info_changed,\n\t.ampdu_action = iwlagn_mac_ampdu_action,\n\t.hw_scan = iwlagn_mac_hw_scan,\n\t.sta_notify = iwlagn_mac_sta_notify,\n\t.sta_state = iwlagn_mac_sta_state,\n\t.channel_switch = iwlagn_mac_channel_switch,\n\t.flush = iwlagn_mac_flush,\n\t.tx_last_beacon = iwlagn_mac_tx_last_beacon,\n\t.event_callback = iwlagn_mac_event_callback,\n\t.set_tim = iwlagn_mac_set_tim,\n};\n\n \nstruct ieee80211_hw *iwl_alloc_all(void)\n{\n\tstruct iwl_priv *priv;\n\tstruct iwl_op_mode *op_mode;\n\t \n\tstruct ieee80211_hw *hw;\n\n\thw = ieee80211_alloc_hw(sizeof(struct iwl_priv) +\n\t\t\t\tsizeof(struct iwl_op_mode), &iwlagn_hw_ops);\n\tif (!hw)\n\t\tgoto out;\n\n\top_mode = hw->priv;\n\tpriv = IWL_OP_MODE_GET_DVM(op_mode);\n\tpriv->hw = hw;\n\nout:\n\treturn hw;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}