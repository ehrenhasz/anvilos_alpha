{
  "module_name": "iwl-io.c",
  "hash_id": "6178334c9061c463362ffb5a9dddcf9f8062ce543ce3c90aaaa3fa7043afa5da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/iwl-io.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/export.h>\n\n#include \"iwl-drv.h\"\n#include \"iwl-io.h\"\n#include \"iwl-csr.h\"\n#include \"iwl-debug.h\"\n#include \"iwl-prph.h\"\n#include \"iwl-fh.h\"\n\nvoid iwl_write8(struct iwl_trans *trans, u32 ofs, u8 val)\n{\n\ttrace_iwlwifi_dev_iowrite8(trans->dev, ofs, val);\n\tiwl_trans_write8(trans, ofs, val);\n}\nIWL_EXPORT_SYMBOL(iwl_write8);\n\nvoid iwl_write32(struct iwl_trans *trans, u32 ofs, u32 val)\n{\n\ttrace_iwlwifi_dev_iowrite32(trans->dev, ofs, val);\n\tiwl_trans_write32(trans, ofs, val);\n}\nIWL_EXPORT_SYMBOL(iwl_write32);\n\nvoid iwl_write64(struct iwl_trans *trans, u64 ofs, u64 val)\n{\n\ttrace_iwlwifi_dev_iowrite64(trans->dev, ofs, val);\n\tiwl_trans_write32(trans, ofs, lower_32_bits(val));\n\tiwl_trans_write32(trans, ofs + 4, upper_32_bits(val));\n}\nIWL_EXPORT_SYMBOL(iwl_write64);\n\nu32 iwl_read32(struct iwl_trans *trans, u32 ofs)\n{\n\tu32 val = iwl_trans_read32(trans, ofs);\n\n\ttrace_iwlwifi_dev_ioread32(trans->dev, ofs, val);\n\treturn val;\n}\nIWL_EXPORT_SYMBOL(iwl_read32);\n\n#define IWL_POLL_INTERVAL 10\t \n\nint iwl_poll_bit(struct iwl_trans *trans, u32 addr,\n\t\t u32 bits, u32 mask, int timeout)\n{\n\tint t = 0;\n\n\tdo {\n\t\tif ((iwl_read32(trans, addr) & mask) == (bits & mask))\n\t\t\treturn t;\n\t\tudelay(IWL_POLL_INTERVAL);\n\t\tt += IWL_POLL_INTERVAL;\n\t} while (t < timeout);\n\n\treturn -ETIMEDOUT;\n}\nIWL_EXPORT_SYMBOL(iwl_poll_bit);\n\nu32 iwl_read_direct32(struct iwl_trans *trans, u32 reg)\n{\n\tif (iwl_trans_grab_nic_access(trans)) {\n\t\tu32 value = iwl_read32(trans, reg);\n\n\t\tiwl_trans_release_nic_access(trans);\n\t\treturn value;\n\t}\n\n\t \n\treturn 0x5a5a5a5a;\n}\nIWL_EXPORT_SYMBOL(iwl_read_direct32);\n\nvoid iwl_write_direct32(struct iwl_trans *trans, u32 reg, u32 value)\n{\n\tif (iwl_trans_grab_nic_access(trans)) {\n\t\tiwl_write32(trans, reg, value);\n\t\tiwl_trans_release_nic_access(trans);\n\t}\n}\nIWL_EXPORT_SYMBOL(iwl_write_direct32);\n\nvoid iwl_write_direct64(struct iwl_trans *trans, u64 reg, u64 value)\n{\n\tif (iwl_trans_grab_nic_access(trans)) {\n\t\tiwl_write64(trans, reg, value);\n\t\tiwl_trans_release_nic_access(trans);\n\t}\n}\nIWL_EXPORT_SYMBOL(iwl_write_direct64);\n\nint iwl_poll_direct_bit(struct iwl_trans *trans, u32 addr, u32 mask,\n\t\t\tint timeout)\n{\n\tint t = 0;\n\n\tdo {\n\t\tif ((iwl_read_direct32(trans, addr) & mask) == mask)\n\t\t\treturn t;\n\t\tudelay(IWL_POLL_INTERVAL);\n\t\tt += IWL_POLL_INTERVAL;\n\t} while (t < timeout);\n\n\treturn -ETIMEDOUT;\n}\nIWL_EXPORT_SYMBOL(iwl_poll_direct_bit);\n\nu32 iwl_read_prph_no_grab(struct iwl_trans *trans, u32 ofs)\n{\n\tu32 val = iwl_trans_read_prph(trans, ofs);\n\ttrace_iwlwifi_dev_ioread_prph32(trans->dev, ofs, val);\n\treturn val;\n}\nIWL_EXPORT_SYMBOL(iwl_read_prph_no_grab);\n\nvoid iwl_write_prph_no_grab(struct iwl_trans *trans, u32 ofs, u32 val)\n{\n\ttrace_iwlwifi_dev_iowrite_prph32(trans->dev, ofs, val);\n\tiwl_trans_write_prph(trans, ofs, val);\n}\nIWL_EXPORT_SYMBOL(iwl_write_prph_no_grab);\n\nvoid iwl_write_prph64_no_grab(struct iwl_trans *trans, u64 ofs, u64 val)\n{\n\ttrace_iwlwifi_dev_iowrite_prph64(trans->dev, ofs, val);\n\tiwl_write_prph_no_grab(trans, ofs, val & 0xffffffff);\n\tiwl_write_prph_no_grab(trans, ofs + 4, val >> 32);\n}\nIWL_EXPORT_SYMBOL(iwl_write_prph64_no_grab);\n\nu32 iwl_read_prph(struct iwl_trans *trans, u32 ofs)\n{\n\tif (iwl_trans_grab_nic_access(trans)) {\n\t\tu32 val = iwl_read_prph_no_grab(trans, ofs);\n\n\t\tiwl_trans_release_nic_access(trans);\n\n\t\treturn val;\n\t}\n\n\t \n\treturn 0x5a5a5a5a;\n}\nIWL_EXPORT_SYMBOL(iwl_read_prph);\n\nvoid iwl_write_prph_delay(struct iwl_trans *trans, u32 ofs, u32 val, u32 delay_ms)\n{\n\tif (iwl_trans_grab_nic_access(trans)) {\n\t\tmdelay(delay_ms);\n\t\tiwl_write_prph_no_grab(trans, ofs, val);\n\t\tiwl_trans_release_nic_access(trans);\n\t}\n}\nIWL_EXPORT_SYMBOL(iwl_write_prph_delay);\n\nint iwl_poll_prph_bit(struct iwl_trans *trans, u32 addr,\n\t\t      u32 bits, u32 mask, int timeout)\n{\n\tint t = 0;\n\n\tdo {\n\t\tif ((iwl_read_prph(trans, addr) & mask) == (bits & mask))\n\t\t\treturn t;\n\t\tudelay(IWL_POLL_INTERVAL);\n\t\tt += IWL_POLL_INTERVAL;\n\t} while (t < timeout);\n\n\treturn -ETIMEDOUT;\n}\n\nvoid iwl_set_bits_prph(struct iwl_trans *trans, u32 ofs, u32 mask)\n{\n\tif (iwl_trans_grab_nic_access(trans)) {\n\t\tiwl_write_prph_no_grab(trans, ofs,\n\t\t\t\t       iwl_read_prph_no_grab(trans, ofs) |\n\t\t\t\t       mask);\n\t\tiwl_trans_release_nic_access(trans);\n\t}\n}\nIWL_EXPORT_SYMBOL(iwl_set_bits_prph);\n\nvoid iwl_set_bits_mask_prph(struct iwl_trans *trans, u32 ofs,\n\t\t\t    u32 bits, u32 mask)\n{\n\tif (iwl_trans_grab_nic_access(trans)) {\n\t\tiwl_write_prph_no_grab(trans, ofs,\n\t\t\t\t       (iwl_read_prph_no_grab(trans, ofs) &\n\t\t\t\t\tmask) | bits);\n\t\tiwl_trans_release_nic_access(trans);\n\t}\n}\nIWL_EXPORT_SYMBOL(iwl_set_bits_mask_prph);\n\nvoid iwl_clear_bits_prph(struct iwl_trans *trans, u32 ofs, u32 mask)\n{\n\tu32 val;\n\n\tif (iwl_trans_grab_nic_access(trans)) {\n\t\tval = iwl_read_prph_no_grab(trans, ofs);\n\t\tiwl_write_prph_no_grab(trans, ofs, (val & ~mask));\n\t\tiwl_trans_release_nic_access(trans);\n\t}\n}\nIWL_EXPORT_SYMBOL(iwl_clear_bits_prph);\n\nvoid iwl_force_nmi(struct iwl_trans *trans)\n{\n\tif (trans->trans_cfg->device_family < IWL_DEVICE_FAMILY_9000)\n\t\tiwl_write_prph_delay(trans, DEVICE_SET_NMI_REG,\n\t\t\t\t     DEVICE_SET_NMI_VAL_DRV, 1);\n\telse if (trans->trans_cfg->device_family < IWL_DEVICE_FAMILY_AX210)\n\t\tiwl_write_umac_prph(trans, UREG_NIC_SET_NMI_DRIVER,\n\t\t\t\tUREG_NIC_SET_NMI_DRIVER_NMI_FROM_DRIVER);\n\telse if (trans->trans_cfg->device_family < IWL_DEVICE_FAMILY_BZ)\n\t\tiwl_write_umac_prph(trans, UREG_DOORBELL_TO_ISR6,\n\t\t\t\t    UREG_DOORBELL_TO_ISR6_NMI_BIT);\n\telse\n\t\tiwl_write32(trans, CSR_DOORBELL_VECTOR,\n\t\t\t    UREG_DOORBELL_TO_ISR6_NMI_BIT);\n}\nIWL_EXPORT_SYMBOL(iwl_force_nmi);\n\nstatic const char *get_rfh_string(int cmd)\n{\n#define IWL_CMD(x) case x: return #x\n#define IWL_CMD_MQ(arg, reg, q) { if (arg == reg(q)) return #reg; }\n\n\tint i;\n\n\tfor (i = 0; i < IWL_MAX_RX_HW_QUEUES; i++) {\n\t\tIWL_CMD_MQ(cmd, RFH_Q_FRBDCB_BA_LSB, i);\n\t\tIWL_CMD_MQ(cmd, RFH_Q_FRBDCB_WIDX, i);\n\t\tIWL_CMD_MQ(cmd, RFH_Q_FRBDCB_RIDX, i);\n\t\tIWL_CMD_MQ(cmd, RFH_Q_URBD_STTS_WPTR_LSB, i);\n\t}\n\n\tswitch (cmd) {\n\tIWL_CMD(RFH_RXF_DMA_CFG);\n\tIWL_CMD(RFH_GEN_CFG);\n\tIWL_CMD(RFH_GEN_STATUS);\n\tIWL_CMD(FH_TSSR_TX_STATUS_REG);\n\tIWL_CMD(FH_TSSR_TX_ERROR_REG);\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n#undef IWL_CMD_MQ\n}\n\nstruct reg {\n\tu32 addr;\n\tbool is64;\n};\n\nstatic int iwl_dump_rfh(struct iwl_trans *trans, char **buf)\n{\n\tint i, q;\n\tint num_q = trans->num_rx_queues;\n\tstatic const u32 rfh_tbl[] = {\n\t\tRFH_RXF_DMA_CFG,\n\t\tRFH_GEN_CFG,\n\t\tRFH_GEN_STATUS,\n\t\tFH_TSSR_TX_STATUS_REG,\n\t\tFH_TSSR_TX_ERROR_REG,\n\t};\n\tstatic const struct reg rfh_mq_tbl[] = {\n\t\t{ RFH_Q0_FRBDCB_BA_LSB, true },\n\t\t{ RFH_Q0_FRBDCB_WIDX, false },\n\t\t{ RFH_Q0_FRBDCB_RIDX, false },\n\t\t{ RFH_Q0_URBD_STTS_WPTR_LSB, true },\n\t};\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tif (buf) {\n\t\tint pos = 0;\n\t\t \n\t\tsize_t bufsz = ARRAY_SIZE(rfh_tbl) * 53 +\n\t\t\t       ARRAY_SIZE(rfh_mq_tbl) * 53 * num_q + 40;\n\n\t\t*buf = kmalloc(bufsz, GFP_KERNEL);\n\t\tif (!*buf)\n\t\t\treturn -ENOMEM;\n\n\t\tpos += scnprintf(*buf + pos, bufsz - pos,\n\t\t\t\t\"RFH register values:\\n\");\n\n\t\tfor (i = 0; i < ARRAY_SIZE(rfh_tbl); i++)\n\t\t\tpos += scnprintf(*buf + pos, bufsz - pos,\n\t\t\t\t\"%40s: 0X%08x\\n\",\n\t\t\t\tget_rfh_string(rfh_tbl[i]),\n\t\t\t\tiwl_read_prph(trans, rfh_tbl[i]));\n\n\t\tfor (i = 0; i < ARRAY_SIZE(rfh_mq_tbl); i++)\n\t\t\tfor (q = 0; q < num_q; q++) {\n\t\t\t\tu32 addr = rfh_mq_tbl[i].addr;\n\n\t\t\t\taddr += q * (rfh_mq_tbl[i].is64 ? 8 : 4);\n\t\t\t\tpos += scnprintf(*buf + pos, bufsz - pos,\n\t\t\t\t\t\"%34s(q %2d): 0X%08x\\n\",\n\t\t\t\t\tget_rfh_string(addr), q,\n\t\t\t\t\tiwl_read_prph(trans, addr));\n\t\t\t}\n\n\t\treturn pos;\n\t}\n#endif\n\n\tIWL_ERR(trans, \"RFH register values:\\n\");\n\tfor (i = 0; i < ARRAY_SIZE(rfh_tbl); i++)\n\t\tIWL_ERR(trans, \"  %34s: 0X%08x\\n\",\n\t\t\tget_rfh_string(rfh_tbl[i]),\n\t\t\tiwl_read_prph(trans, rfh_tbl[i]));\n\n\tfor (i = 0; i < ARRAY_SIZE(rfh_mq_tbl); i++)\n\t\tfor (q = 0; q < num_q; q++) {\n\t\t\tu32 addr = rfh_mq_tbl[i].addr;\n\n\t\t\taddr += q * (rfh_mq_tbl[i].is64 ? 8 : 4);\n\t\t\tIWL_ERR(trans, \"  %34s(q %d): 0X%08x\\n\",\n\t\t\t\tget_rfh_string(addr), q,\n\t\t\t\tiwl_read_prph(trans, addr));\n\t\t}\n\n\treturn 0;\n}\n\nstatic const char *get_fh_string(int cmd)\n{\n\tswitch (cmd) {\n\tIWL_CMD(FH_RSCSR_CHNL0_STTS_WPTR_REG);\n\tIWL_CMD(FH_RSCSR_CHNL0_RBDCB_BASE_REG);\n\tIWL_CMD(FH_RSCSR_CHNL0_WPTR);\n\tIWL_CMD(FH_MEM_RCSR_CHNL0_CONFIG_REG);\n\tIWL_CMD(FH_MEM_RSSR_SHARED_CTRL_REG);\n\tIWL_CMD(FH_MEM_RSSR_RX_STATUS_REG);\n\tIWL_CMD(FH_MEM_RSSR_RX_ENABLE_ERR_IRQ2DRV);\n\tIWL_CMD(FH_TSSR_TX_STATUS_REG);\n\tIWL_CMD(FH_TSSR_TX_ERROR_REG);\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n#undef IWL_CMD\n}\n\nint iwl_dump_fh(struct iwl_trans *trans, char **buf)\n{\n\tint i;\n\tstatic const u32 fh_tbl[] = {\n\t\tFH_RSCSR_CHNL0_STTS_WPTR_REG,\n\t\tFH_RSCSR_CHNL0_RBDCB_BASE_REG,\n\t\tFH_RSCSR_CHNL0_WPTR,\n\t\tFH_MEM_RCSR_CHNL0_CONFIG_REG,\n\t\tFH_MEM_RSSR_SHARED_CTRL_REG,\n\t\tFH_MEM_RSSR_RX_STATUS_REG,\n\t\tFH_MEM_RSSR_RX_ENABLE_ERR_IRQ2DRV,\n\t\tFH_TSSR_TX_STATUS_REG,\n\t\tFH_TSSR_TX_ERROR_REG\n\t};\n\n\tif (trans->trans_cfg->mq_rx_supported)\n\t\treturn iwl_dump_rfh(trans, buf);\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tif (buf) {\n\t\tint pos = 0;\n\t\tsize_t bufsz = ARRAY_SIZE(fh_tbl) * 48 + 40;\n\n\t\t*buf = kmalloc(bufsz, GFP_KERNEL);\n\t\tif (!*buf)\n\t\t\treturn -ENOMEM;\n\n\t\tpos += scnprintf(*buf + pos, bufsz - pos,\n\t\t\t\t\"FH register values:\\n\");\n\n\t\tfor (i = 0; i < ARRAY_SIZE(fh_tbl); i++)\n\t\t\tpos += scnprintf(*buf + pos, bufsz - pos,\n\t\t\t\t\"  %34s: 0X%08x\\n\",\n\t\t\t\tget_fh_string(fh_tbl[i]),\n\t\t\t\tiwl_read_direct32(trans, fh_tbl[i]));\n\n\t\treturn pos;\n\t}\n#endif\n\n\tIWL_ERR(trans, \"FH register values:\\n\");\n\tfor (i = 0; i <  ARRAY_SIZE(fh_tbl); i++)\n\t\tIWL_ERR(trans, \"  %34s: 0X%08x\\n\",\n\t\t\tget_fh_string(fh_tbl[i]),\n\t\t\tiwl_read_direct32(trans, fh_tbl[i]));\n\n\treturn 0;\n}\n\n#define IWL_HOST_MON_BLOCK_PEMON\t0x00\n#define IWL_HOST_MON_BLOCK_HIPM\t\t0x22\n\n#define IWL_HOST_MON_BLOCK_PEMON_VEC0\t0x00\n#define IWL_HOST_MON_BLOCK_PEMON_VEC1\t0x01\n#define IWL_HOST_MON_BLOCK_PEMON_WFPM\t0x06\n\nstatic void iwl_dump_host_monitor_block(struct iwl_trans *trans,\n\t\t\t\t\tu32 block, u32 vec, u32 iter)\n{\n\tint i;\n\n\tIWL_ERR(trans, \"Host monitor block 0x%x vector 0x%x\\n\", block, vec);\n\tiwl_write32(trans, CSR_MONITOR_CFG_REG, (block << 8) | vec);\n\tfor (i = 0; i < iter; i++)\n\t\tIWL_ERR(trans, \"    value [iter %d]: 0x%08x\\n\",\n\t\t\ti, iwl_read32(trans, CSR_MONITOR_STATUS_REG));\n}\n\nstatic void iwl_dump_host_monitor(struct iwl_trans *trans)\n{\n\tswitch (trans->trans_cfg->device_family) {\n\tcase IWL_DEVICE_FAMILY_22000:\n\tcase IWL_DEVICE_FAMILY_AX210:\n\t\tIWL_ERR(trans, \"CSR_RESET = 0x%x\\n\",\n\t\t\tiwl_read32(trans, CSR_RESET));\n\t\tiwl_dump_host_monitor_block(trans, IWL_HOST_MON_BLOCK_PEMON,\n\t\t\t\t\t    IWL_HOST_MON_BLOCK_PEMON_VEC0, 15);\n\t\tiwl_dump_host_monitor_block(trans, IWL_HOST_MON_BLOCK_PEMON,\n\t\t\t\t\t    IWL_HOST_MON_BLOCK_PEMON_VEC1, 15);\n\t\tiwl_dump_host_monitor_block(trans, IWL_HOST_MON_BLOCK_PEMON,\n\t\t\t\t\t    IWL_HOST_MON_BLOCK_PEMON_WFPM, 15);\n\t\tiwl_dump_host_monitor_block(trans, IWL_HOST_MON_BLOCK_HIPM,\n\t\t\t\t\t    IWL_HOST_MON_BLOCK_PEMON_VEC0, 1);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn;\n\t}\n}\n\nint iwl_finish_nic_init(struct iwl_trans *trans)\n{\n\tconst struct iwl_cfg_trans_params *cfg_trans = trans->trans_cfg;\n\tu32 poll_ready;\n\tint err;\n\n\tif (cfg_trans->bisr_workaround) {\n\t\t \n\t\tmdelay(2);\n\t}\n\n\t \n\tif (cfg_trans->device_family >= IWL_DEVICE_FAMILY_BZ) {\n\t\tiwl_set_bit(trans, CSR_GP_CNTRL,\n\t\t\t    CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY |\n\t\t\t    CSR_GP_CNTRL_REG_FLAG_MAC_INIT);\n\t\tpoll_ready = CSR_GP_CNTRL_REG_FLAG_MAC_STATUS;\n\t} else {\n\t\tiwl_set_bit(trans, CSR_GP_CNTRL,\n\t\t\t    CSR_GP_CNTRL_REG_FLAG_INIT_DONE);\n\t\tpoll_ready = CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY;\n\t}\n\n\tif (cfg_trans->device_family == IWL_DEVICE_FAMILY_8000)\n\t\tudelay(2);\n\n\t \n\terr = iwl_poll_bit(trans, CSR_GP_CNTRL, poll_ready, poll_ready, 25000);\n\tif (err < 0) {\n\t\tIWL_DEBUG_INFO(trans, \"Failed to wake NIC\\n\");\n\n\t\tiwl_dump_host_monitor(trans);\n\t}\n\n\tif (cfg_trans->bisr_workaround) {\n\t\t \n\t\tudelay(200);\n\t}\n\n\treturn err < 0 ? err : 0;\n}\nIWL_EXPORT_SYMBOL(iwl_finish_nic_init);\n\nvoid iwl_trans_sync_nmi_with_addr(struct iwl_trans *trans, u32 inta_addr,\n\t\t\t\t  u32 sw_err_bit)\n{\n\tunsigned long timeout = jiffies + IWL_TRANS_NMI_TIMEOUT;\n\tbool interrupts_enabled = test_bit(STATUS_INT_ENABLED, &trans->status);\n\n\t \n\tif (interrupts_enabled)\n\t\tiwl_trans_interrupts(trans, false);\n\n\tiwl_force_nmi(trans);\n\twhile (time_after(timeout, jiffies)) {\n\t\tu32 inta_hw = iwl_read32(trans, inta_addr);\n\n\t\t \n\t\tif (inta_hw & sw_err_bit) {\n\t\t\t \n\t\t\tiwl_write32(trans, inta_addr, inta_hw & sw_err_bit);\n\t\t\tbreak;\n\t\t}\n\n\t\tmdelay(1);\n\t}\n\n\t \n\tif (interrupts_enabled)\n\t\tiwl_trans_interrupts(trans, true);\n\n\tiwl_trans_fw_error(trans, false);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}