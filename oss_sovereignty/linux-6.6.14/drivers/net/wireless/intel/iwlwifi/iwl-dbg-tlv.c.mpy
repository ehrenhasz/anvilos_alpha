{
  "module_name": "iwl-dbg-tlv.c",
  "hash_id": "ce9bf45f78be147e280efe51463129d6a3492382b56c3c386b829c68f74ca201",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/iwl-dbg-tlv.c",
  "human_readable_source": "\n \n#include <linux/firmware.h>\n#include \"iwl-drv.h\"\n#include \"iwl-trans.h\"\n#include \"iwl-dbg-tlv.h\"\n#include \"fw/dbg.h\"\n#include \"fw/runtime.h\"\n\n \nenum iwl_dbg_tlv_type {\n\tIWL_DBG_TLV_TYPE_DEBUG_INFO =\n\t\tIWL_UCODE_TLV_TYPE_DEBUG_INFO - IWL_UCODE_TLV_DEBUG_BASE,\n\tIWL_DBG_TLV_TYPE_BUF_ALLOC,\n\tIWL_DBG_TLV_TYPE_HCMD,\n\tIWL_DBG_TLV_TYPE_REGION,\n\tIWL_DBG_TLV_TYPE_TRIGGER,\n\tIWL_DBG_TLV_TYPE_CONF_SET,\n\tIWL_DBG_TLV_TYPE_NUM,\n};\n\n \nstruct iwl_dbg_tlv_ver_data {\n\tint min_ver;\n\tint max_ver;\n};\n\n \nstruct iwl_dbg_tlv_timer_node {\n\tstruct list_head list;\n\tstruct timer_list timer;\n\tstruct iwl_fw_runtime *fwrt;\n\tstruct iwl_ucode_tlv *tlv;\n};\n\nstatic const struct iwl_dbg_tlv_ver_data\ndbg_ver_table[IWL_DBG_TLV_TYPE_NUM] = {\n\t[IWL_DBG_TLV_TYPE_DEBUG_INFO]\t= {.min_ver = 1, .max_ver = 1,},\n\t[IWL_DBG_TLV_TYPE_BUF_ALLOC]\t= {.min_ver = 1, .max_ver = 1,},\n\t[IWL_DBG_TLV_TYPE_HCMD]\t\t= {.min_ver = 1, .max_ver = 1,},\n\t[IWL_DBG_TLV_TYPE_REGION]\t= {.min_ver = 1, .max_ver = 3,},\n\t[IWL_DBG_TLV_TYPE_TRIGGER]\t= {.min_ver = 1, .max_ver = 1,},\n\t[IWL_DBG_TLV_TYPE_CONF_SET]\t= {.min_ver = 1, .max_ver = 1,},\n};\n\nstatic int iwl_dbg_tlv_add(const struct iwl_ucode_tlv *tlv,\n\t\t\t   struct list_head *list)\n{\n\tu32 len = le32_to_cpu(tlv->length);\n\tstruct iwl_dbg_tlv_node *node;\n\n\tnode = kzalloc(sizeof(*node) + len, GFP_KERNEL);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&node->tlv, tlv, sizeof(node->tlv));\n\tmemcpy(node->tlv.data, tlv->data, len);\n\tlist_add_tail(&node->list, list);\n\n\treturn 0;\n}\n\nstatic bool iwl_dbg_tlv_ver_support(const struct iwl_ucode_tlv *tlv)\n{\n\tconst struct iwl_fw_ini_header *hdr = (const void *)&tlv->data[0];\n\tu32 type = le32_to_cpu(tlv->type);\n\tu32 tlv_idx = type - IWL_UCODE_TLV_DEBUG_BASE;\n\tu32 ver = le32_to_cpu(hdr->version);\n\n\tif (ver < dbg_ver_table[tlv_idx].min_ver ||\n\t    ver > dbg_ver_table[tlv_idx].max_ver)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int iwl_dbg_tlv_alloc_debug_info(struct iwl_trans *trans,\n\t\t\t\t\tconst struct iwl_ucode_tlv *tlv)\n{\n\tconst struct iwl_fw_ini_debug_info_tlv *debug_info = (const void *)tlv->data;\n\n\tif (le32_to_cpu(tlv->length) != sizeof(*debug_info))\n\t\treturn -EINVAL;\n\n\tIWL_DEBUG_FW(trans, \"WRT: Loading debug cfg: %s\\n\",\n\t\t     debug_info->debug_cfg_name);\n\n\treturn iwl_dbg_tlv_add(tlv, &trans->dbg.debug_info_tlv_list);\n}\n\nstatic int iwl_dbg_tlv_alloc_buf_alloc(struct iwl_trans *trans,\n\t\t\t\t       const struct iwl_ucode_tlv *tlv)\n{\n\tconst struct iwl_fw_ini_allocation_tlv *alloc = (const void *)tlv->data;\n\tu32 buf_location;\n\tu32 alloc_id;\n\n\tif (le32_to_cpu(tlv->length) != sizeof(*alloc))\n\t\treturn -EINVAL;\n\n\tbuf_location = le32_to_cpu(alloc->buf_location);\n\talloc_id = le32_to_cpu(alloc->alloc_id);\n\n\tif (buf_location == IWL_FW_INI_LOCATION_INVALID ||\n\t    buf_location >= IWL_FW_INI_LOCATION_NUM)\n\t\tgoto err;\n\n\tif (alloc_id == IWL_FW_INI_ALLOCATION_INVALID ||\n\t    alloc_id >= IWL_FW_INI_ALLOCATION_NUM)\n\t\tgoto err;\n\n\tif (buf_location == IWL_FW_INI_LOCATION_NPK_PATH &&\n\t    alloc_id != IWL_FW_INI_ALLOCATION_ID_DBGC1)\n\t\tgoto err;\n\n\tif (buf_location == IWL_FW_INI_LOCATION_SRAM_PATH &&\n\t    alloc_id != IWL_FW_INI_ALLOCATION_ID_DBGC1)\n\t\tgoto err;\n\n\tif (buf_location == IWL_FW_INI_LOCATION_DRAM_PATH &&\n\t    alloc->req_size == 0) {\n\t\tIWL_ERR(trans, \"WRT: Invalid DRAM buffer allocation requested size (0)\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttrans->dbg.fw_mon_cfg[alloc_id] = *alloc;\n\n\treturn 0;\nerr:\n\tIWL_ERR(trans,\n\t\t\"WRT: Invalid allocation id %u and/or location id %u for allocation TLV\\n\",\n\t\talloc_id, buf_location);\n\treturn -EINVAL;\n}\n\nstatic int iwl_dbg_tlv_alloc_hcmd(struct iwl_trans *trans,\n\t\t\t\t  const struct iwl_ucode_tlv *tlv)\n{\n\tconst struct iwl_fw_ini_hcmd_tlv *hcmd = (const void *)tlv->data;\n\tu32 tp = le32_to_cpu(hcmd->time_point);\n\n\tif (le32_to_cpu(tlv->length) <= sizeof(*hcmd))\n\t\treturn -EINVAL;\n\n\t \n\tif (tp == IWL_FW_INI_TIME_POINT_INVALID ||\n\t    tp >= IWL_FW_INI_TIME_POINT_NUM ||\n\t    tp == IWL_FW_INI_TIME_POINT_EARLY) {\n\t\tIWL_ERR(trans,\n\t\t\t\"WRT: Invalid time point %u for host command TLV\\n\",\n\t\t\ttp);\n\t\treturn -EINVAL;\n\t}\n\n\treturn iwl_dbg_tlv_add(tlv, &trans->dbg.time_point[tp].hcmd_list);\n}\n\nstatic int iwl_dbg_tlv_alloc_region(struct iwl_trans *trans,\n\t\t\t\t    const struct iwl_ucode_tlv *tlv)\n{\n\tconst struct iwl_fw_ini_region_tlv *reg = (const void *)tlv->data;\n\tstruct iwl_ucode_tlv **active_reg;\n\tu32 id = le32_to_cpu(reg->id);\n\tu8 type = reg->type;\n\tu32 tlv_len = sizeof(*tlv) + le32_to_cpu(tlv->length);\n\n\t \n\tif (le32_to_cpu(reg->hdr.version) >= 2)\n\t\tid &= IWL_FW_INI_REGION_ID_MASK;\n\n\tif (le32_to_cpu(tlv->length) < sizeof(*reg))\n\t\treturn -EINVAL;\n\n\t \n\tIWL_DEBUG_FW(trans, \"WRT: parsing region: %.*s\\n\",\n\t\t     IWL_FW_INI_MAX_NAME, reg->name);\n\n\tif (id >= IWL_FW_INI_MAX_REGION_ID) {\n\t\tIWL_ERR(trans, \"WRT: Invalid region id %u\\n\", id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (type <= IWL_FW_INI_REGION_INVALID ||\n\t    type >= IWL_FW_INI_REGION_NUM) {\n\t\tIWL_ERR(trans, \"WRT: Invalid region type %u\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (type == IWL_FW_INI_REGION_PCI_IOSF_CONFIG &&\n\t    !trans->ops->read_config32) {\n\t\tIWL_ERR(trans, \"WRT: Unsupported region type %u\\n\", type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (type == IWL_FW_INI_REGION_INTERNAL_BUFFER) {\n\t\ttrans->dbg.imr_data.sram_addr =\n\t\t\tle32_to_cpu(reg->internal_buffer.base_addr);\n\t\ttrans->dbg.imr_data.sram_size =\n\t\t\tle32_to_cpu(reg->internal_buffer.size);\n\t}\n\n\n\tactive_reg = &trans->dbg.active_regions[id];\n\tif (*active_reg) {\n\t\tIWL_WARN(trans, \"WRT: Overriding region id %u\\n\", id);\n\n\t\tkfree(*active_reg);\n\t}\n\n\t*active_reg = kmemdup(tlv, tlv_len, GFP_KERNEL);\n\tif (!*active_reg)\n\t\treturn -ENOMEM;\n\n\tIWL_DEBUG_FW(trans, \"WRT: Enabling region id %u type %u\\n\", id, type);\n\n\treturn 0;\n}\n\nstatic int iwl_dbg_tlv_alloc_trigger(struct iwl_trans *trans,\n\t\t\t\t     const struct iwl_ucode_tlv *tlv)\n{\n\tconst struct iwl_fw_ini_trigger_tlv *trig = (const void *)tlv->data;\n\tstruct iwl_fw_ini_trigger_tlv *dup_trig;\n\tu32 tp = le32_to_cpu(trig->time_point);\n\tu32 rf = le32_to_cpu(trig->reset_fw);\n\tstruct iwl_ucode_tlv *dup = NULL;\n\tint ret;\n\n\tif (le32_to_cpu(tlv->length) < sizeof(*trig))\n\t\treturn -EINVAL;\n\n\tif (tp <= IWL_FW_INI_TIME_POINT_INVALID ||\n\t    tp >= IWL_FW_INI_TIME_POINT_NUM) {\n\t\tIWL_ERR(trans,\n\t\t\t\"WRT: Invalid time point %u for trigger TLV\\n\",\n\t\t\ttp);\n\t\treturn -EINVAL;\n\t}\n\n\tIWL_DEBUG_FW(trans,\n\t\t     \"WRT: time point %u for trigger TLV with reset_fw %u\\n\",\n\t\t     tp, rf);\n\ttrans->dbg.last_tp_resetfw = 0xFF;\n\tif (!le32_to_cpu(trig->occurrences)) {\n\t\tdup = kmemdup(tlv, sizeof(*tlv) + le32_to_cpu(tlv->length),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!dup)\n\t\t\treturn -ENOMEM;\n\t\tdup_trig = (void *)dup->data;\n\t\tdup_trig->occurrences = cpu_to_le32(-1);\n\t\ttlv = dup;\n\t}\n\n\tret = iwl_dbg_tlv_add(tlv, &trans->dbg.time_point[tp].trig_list);\n\tkfree(dup);\n\n\treturn ret;\n}\n\nstatic int iwl_dbg_tlv_config_set(struct iwl_trans *trans,\n\t\t\t\t  const struct iwl_ucode_tlv *tlv)\n{\n\tconst struct iwl_fw_ini_conf_set_tlv *conf_set = (const void *)tlv->data;\n\tu32 tp = le32_to_cpu(conf_set->time_point);\n\tu32 type = le32_to_cpu(conf_set->set_type);\n\n\tif (tp <= IWL_FW_INI_TIME_POINT_INVALID ||\n\t    tp >= IWL_FW_INI_TIME_POINT_NUM) {\n\t\tIWL_DEBUG_FW(trans,\n\t\t\t     \"WRT: Invalid time point %u for config set TLV\\n\", tp);\n\t\treturn -EINVAL;\n\t}\n\n\tif (type <= IWL_FW_INI_CONFIG_SET_TYPE_INVALID ||\n\t    type >= IWL_FW_INI_CONFIG_SET_TYPE_MAX_NUM) {\n\t\tIWL_DEBUG_FW(trans,\n\t\t\t     \"WRT: Invalid config set type %u for config set TLV\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn iwl_dbg_tlv_add(tlv, &trans->dbg.time_point[tp].config_list);\n}\n\nstatic int (*dbg_tlv_alloc[])(struct iwl_trans *trans,\n\t\t\t      const struct iwl_ucode_tlv *tlv) = {\n\t[IWL_DBG_TLV_TYPE_DEBUG_INFO]\t= iwl_dbg_tlv_alloc_debug_info,\n\t[IWL_DBG_TLV_TYPE_BUF_ALLOC]\t= iwl_dbg_tlv_alloc_buf_alloc,\n\t[IWL_DBG_TLV_TYPE_HCMD]\t\t= iwl_dbg_tlv_alloc_hcmd,\n\t[IWL_DBG_TLV_TYPE_REGION]\t= iwl_dbg_tlv_alloc_region,\n\t[IWL_DBG_TLV_TYPE_TRIGGER]\t= iwl_dbg_tlv_alloc_trigger,\n\t[IWL_DBG_TLV_TYPE_CONF_SET]\t= iwl_dbg_tlv_config_set,\n};\n\nvoid iwl_dbg_tlv_alloc(struct iwl_trans *trans, const struct iwl_ucode_tlv *tlv,\n\t\t       bool ext)\n{\n\tenum iwl_ini_cfg_state *cfg_state = ext ?\n\t\t&trans->dbg.external_ini_cfg : &trans->dbg.internal_ini_cfg;\n\tconst struct iwl_fw_ini_header *hdr = (const void *)&tlv->data[0];\n\tu32 type;\n\tu32 tlv_idx;\n\tu32 domain;\n\tint ret;\n\n\tif (le32_to_cpu(tlv->length) < sizeof(*hdr))\n\t\treturn;\n\n\ttype = le32_to_cpu(tlv->type);\n\ttlv_idx = type - IWL_UCODE_TLV_DEBUG_BASE;\n\tdomain = le32_to_cpu(hdr->domain);\n\n\tif (domain != IWL_FW_INI_DOMAIN_ALWAYS_ON &&\n\t    !(domain & trans->dbg.domains_bitmap)) {\n\t\tIWL_DEBUG_FW(trans,\n\t\t\t     \"WRT: Skipping TLV with disabled domain 0x%0x (0x%0x)\\n\",\n\t\t\t     domain, trans->dbg.domains_bitmap);\n\t\treturn;\n\t}\n\n\tif (tlv_idx >= ARRAY_SIZE(dbg_tlv_alloc) || !dbg_tlv_alloc[tlv_idx]) {\n\t\tIWL_ERR(trans, \"WRT: Unsupported TLV type 0x%x\\n\", type);\n\t\tgoto out_err;\n\t}\n\n\tif (!iwl_dbg_tlv_ver_support(tlv)) {\n\t\tIWL_ERR(trans, \"WRT: Unsupported TLV 0x%x version %u\\n\", type,\n\t\t\tle32_to_cpu(hdr->version));\n\t\tgoto out_err;\n\t}\n\n\tret = dbg_tlv_alloc[tlv_idx](trans, tlv);\n\tif (ret) {\n\t\tIWL_WARN(trans,\n\t\t\t \"WRT: Failed to allocate TLV 0x%x, ret %d, (ext=%d)\\n\",\n\t\t\t type, ret, ext);\n\t\tgoto out_err;\n\t}\n\n\tif (*cfg_state == IWL_INI_CFG_STATE_NOT_LOADED)\n\t\t*cfg_state = IWL_INI_CFG_STATE_LOADED;\n\n\treturn;\n\nout_err:\n\t*cfg_state = IWL_INI_CFG_STATE_CORRUPTED;\n}\n\nvoid iwl_dbg_tlv_del_timers(struct iwl_trans *trans)\n{\n\tstruct list_head *timer_list = &trans->dbg.periodic_trig_list;\n\tstruct iwl_dbg_tlv_timer_node *node, *tmp;\n\n\tlist_for_each_entry_safe(node, tmp, timer_list, list) {\n\t\ttimer_shutdown_sync(&node->timer);\n\t\tlist_del(&node->list);\n\t\tkfree(node);\n\t}\n}\nIWL_EXPORT_SYMBOL(iwl_dbg_tlv_del_timers);\n\nstatic void iwl_dbg_tlv_fragments_free(struct iwl_trans *trans,\n\t\t\t\t       enum iwl_fw_ini_allocation_id alloc_id)\n{\n\tstruct iwl_fw_mon *fw_mon;\n\tint i;\n\n\tif (alloc_id <= IWL_FW_INI_ALLOCATION_INVALID ||\n\t    alloc_id >= IWL_FW_INI_ALLOCATION_NUM)\n\t\treturn;\n\n\tfw_mon = &trans->dbg.fw_mon_ini[alloc_id];\n\n\tfor (i = 0; i < fw_mon->num_frags; i++) {\n\t\tstruct iwl_dram_data *frag = &fw_mon->frags[i];\n\n\t\tdma_free_coherent(trans->dev, frag->size, frag->block,\n\t\t\t\t  frag->physical);\n\n\t\tfrag->physical = 0;\n\t\tfrag->block = NULL;\n\t\tfrag->size = 0;\n\t}\n\n\tkfree(fw_mon->frags);\n\tfw_mon->frags = NULL;\n\tfw_mon->num_frags = 0;\n}\n\nvoid iwl_dbg_tlv_free(struct iwl_trans *trans)\n{\n\tstruct iwl_dbg_tlv_node *tlv_node, *tlv_node_tmp;\n\tint i;\n\n\tiwl_dbg_tlv_del_timers(trans);\n\n\tfor (i = 0; i < ARRAY_SIZE(trans->dbg.active_regions); i++) {\n\t\tstruct iwl_ucode_tlv **active_reg =\n\t\t\t&trans->dbg.active_regions[i];\n\n\t\tkfree(*active_reg);\n\t\t*active_reg = NULL;\n\t}\n\n\tlist_for_each_entry_safe(tlv_node, tlv_node_tmp,\n\t\t\t\t &trans->dbg.debug_info_tlv_list, list) {\n\t\tlist_del(&tlv_node->list);\n\t\tkfree(tlv_node);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(trans->dbg.time_point); i++) {\n\t\tstruct iwl_dbg_tlv_time_point_data *tp =\n\t\t\t&trans->dbg.time_point[i];\n\n\t\tlist_for_each_entry_safe(tlv_node, tlv_node_tmp, &tp->trig_list,\n\t\t\t\t\t list) {\n\t\t\tlist_del(&tlv_node->list);\n\t\t\tkfree(tlv_node);\n\t\t}\n\n\t\tlist_for_each_entry_safe(tlv_node, tlv_node_tmp, &tp->hcmd_list,\n\t\t\t\t\t list) {\n\t\t\tlist_del(&tlv_node->list);\n\t\t\tkfree(tlv_node);\n\t\t}\n\n\t\tlist_for_each_entry_safe(tlv_node, tlv_node_tmp,\n\t\t\t\t\t &tp->active_trig_list, list) {\n\t\t\tlist_del(&tlv_node->list);\n\t\t\tkfree(tlv_node);\n\t\t}\n\n\t\tlist_for_each_entry_safe(tlv_node, tlv_node_tmp,\n\t\t\t\t\t &tp->config_list, list) {\n\t\t\tlist_del(&tlv_node->list);\n\t\t\tkfree(tlv_node);\n\t\t}\n\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(trans->dbg.fw_mon_ini); i++)\n\t\tiwl_dbg_tlv_fragments_free(trans, i);\n}\n\nstatic int iwl_dbg_tlv_parse_bin(struct iwl_trans *trans, const u8 *data,\n\t\t\t\t size_t len)\n{\n\tconst struct iwl_ucode_tlv *tlv;\n\tu32 tlv_len;\n\n\twhile (len >= sizeof(*tlv)) {\n\t\tlen -= sizeof(*tlv);\n\t\ttlv = (const void *)data;\n\n\t\ttlv_len = le32_to_cpu(tlv->length);\n\n\t\tif (len < tlv_len) {\n\t\t\tIWL_ERR(trans, \"invalid TLV len: %zd/%u\\n\",\n\t\t\t\tlen, tlv_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlen -= ALIGN(tlv_len, 4);\n\t\tdata += sizeof(*tlv) + ALIGN(tlv_len, 4);\n\n\t\tiwl_dbg_tlv_alloc(trans, tlv, true);\n\t}\n\n\treturn 0;\n}\n\nvoid iwl_dbg_tlv_load_bin(struct device *dev, struct iwl_trans *trans)\n{\n\tconst struct firmware *fw;\n\tconst char *yoyo_bin = \"iwl-debug-yoyo.bin\";\n\tint res;\n\n\tif (!iwlwifi_mod_params.enable_ini ||\n\t    trans->trans_cfg->device_family <= IWL_DEVICE_FAMILY_8000)\n\t\treturn;\n\n\tres = firmware_request_nowarn(&fw, yoyo_bin, dev);\n\tIWL_DEBUG_FW(trans, \"%s %s\\n\", res ? \"didn't load\" : \"loaded\", yoyo_bin);\n\n\tif (res)\n\t\treturn;\n\n\tiwl_dbg_tlv_parse_bin(trans, fw->data, fw->size);\n\n\trelease_firmware(fw);\n}\n\nvoid iwl_dbg_tlv_init(struct iwl_trans *trans)\n{\n\tint i;\n\n\tINIT_LIST_HEAD(&trans->dbg.debug_info_tlv_list);\n\tINIT_LIST_HEAD(&trans->dbg.periodic_trig_list);\n\n\tfor (i = 0; i < ARRAY_SIZE(trans->dbg.time_point); i++) {\n\t\tstruct iwl_dbg_tlv_time_point_data *tp =\n\t\t\t&trans->dbg.time_point[i];\n\n\t\tINIT_LIST_HEAD(&tp->trig_list);\n\t\tINIT_LIST_HEAD(&tp->hcmd_list);\n\t\tINIT_LIST_HEAD(&tp->active_trig_list);\n\t\tINIT_LIST_HEAD(&tp->config_list);\n\t}\n}\n\nstatic int iwl_dbg_tlv_alloc_fragment(struct iwl_fw_runtime *fwrt,\n\t\t\t\t      struct iwl_dram_data *frag, u32 pages)\n{\n\tvoid *block = NULL;\n\tdma_addr_t physical;\n\n\tif (!frag || frag->size || !pages)\n\t\treturn -EIO;\n\n\t \n\twhile (pages > 1) {\n\t\tblock = dma_alloc_coherent(fwrt->dev, pages * PAGE_SIZE,\n\t\t\t\t\t   &physical,\n\t\t\t\t\t   GFP_KERNEL | __GFP_NOWARN);\n\t\tif (block)\n\t\t\tbreak;\n\n\t\tIWL_WARN(fwrt, \"WRT: Failed to allocate fragment size %lu\\n\",\n\t\t\t pages * PAGE_SIZE);\n\n\t\tpages = DIV_ROUND_UP(pages, 2);\n\t}\n\n\tif (!block)\n\t\treturn -ENOMEM;\n\n\tfrag->physical = physical;\n\tfrag->block = block;\n\tfrag->size = pages * PAGE_SIZE;\n\n\treturn pages;\n}\n\nstatic int iwl_dbg_tlv_alloc_fragments(struct iwl_fw_runtime *fwrt,\n\t\t\t\t       enum iwl_fw_ini_allocation_id alloc_id)\n{\n\tstruct iwl_fw_mon *fw_mon;\n\tstruct iwl_fw_ini_allocation_tlv *fw_mon_cfg;\n\tu32 num_frags, remain_pages, frag_pages;\n\tint i;\n\n\tif (alloc_id < IWL_FW_INI_ALLOCATION_INVALID ||\n\t    alloc_id >= IWL_FW_INI_ALLOCATION_NUM)\n\t\treturn -EIO;\n\n\tfw_mon_cfg = &fwrt->trans->dbg.fw_mon_cfg[alloc_id];\n\tfw_mon = &fwrt->trans->dbg.fw_mon_ini[alloc_id];\n\n\tif (fw_mon->num_frags) {\n\t\tfor (i = 0; i < fw_mon->num_frags; i++)\n\t\t\tmemset(fw_mon->frags[i].block, 0,\n\t\t\t       fw_mon->frags[i].size);\n\t\treturn 0;\n\t}\n\n\tif (fw_mon_cfg->buf_location !=\n\t    cpu_to_le32(IWL_FW_INI_LOCATION_DRAM_PATH))\n\t\treturn 0;\n\n\tnum_frags = le32_to_cpu(fw_mon_cfg->max_frags_num);\n\tif (fwrt->trans->trans_cfg->device_family < IWL_DEVICE_FAMILY_AX210) {\n\t\tif (alloc_id != IWL_FW_INI_ALLOCATION_ID_DBGC1)\n\t\t\treturn -EIO;\n\t\tnum_frags = 1;\n\t} else if (fwrt->trans->trans_cfg->device_family < IWL_DEVICE_FAMILY_BZ &&\n\t\t\t   alloc_id > IWL_FW_INI_ALLOCATION_ID_DBGC3) {\n\t\treturn -EIO;\n\t}\n\n\tremain_pages = DIV_ROUND_UP(le32_to_cpu(fw_mon_cfg->req_size),\n\t\t\t\t    PAGE_SIZE);\n\tnum_frags = min_t(u32, num_frags, BUF_ALLOC_MAX_NUM_FRAGS);\n\tnum_frags = min_t(u32, num_frags, remain_pages);\n\tfrag_pages = DIV_ROUND_UP(remain_pages, num_frags);\n\n\tfw_mon->frags = kcalloc(num_frags, sizeof(*fw_mon->frags), GFP_KERNEL);\n\tif (!fw_mon->frags)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_frags; i++) {\n\t\tint pages = min_t(u32, frag_pages, remain_pages);\n\n\t\tIWL_DEBUG_FW(fwrt,\n\t\t\t     \"WRT: Allocating DRAM buffer (alloc_id=%u, fragment=%u, size=0x%lx)\\n\",\n\t\t\t     alloc_id, i, pages * PAGE_SIZE);\n\n\t\tpages = iwl_dbg_tlv_alloc_fragment(fwrt, &fw_mon->frags[i],\n\t\t\t\t\t\t   pages);\n\t\tif (pages < 0) {\n\t\t\tu32 alloc_size = le32_to_cpu(fw_mon_cfg->req_size) -\n\t\t\t\t(remain_pages * PAGE_SIZE);\n\n\t\t\tif (alloc_size < le32_to_cpu(fw_mon_cfg->min_size)) {\n\t\t\t\tiwl_dbg_tlv_fragments_free(fwrt->trans,\n\t\t\t\t\t\t\t   alloc_id);\n\t\t\t\treturn pages;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tremain_pages -= pages;\n\t\tfw_mon->num_frags++;\n\t}\n\n\treturn 0;\n}\n\nstatic int iwl_dbg_tlv_apply_buffer(struct iwl_fw_runtime *fwrt,\n\t\t\t\t    enum iwl_fw_ini_allocation_id alloc_id)\n{\n\tstruct iwl_fw_mon *fw_mon;\n\tu32 remain_frags, num_commands;\n\tint i, fw_mon_idx = 0;\n\n\tif (!fw_has_capa(&fwrt->fw->ucode_capa,\n\t\t\t IWL_UCODE_TLV_CAPA_DBG_BUF_ALLOC_CMD_SUPP))\n\t\treturn 0;\n\n\tif (alloc_id < IWL_FW_INI_ALLOCATION_INVALID ||\n\t    alloc_id >= IWL_FW_INI_ALLOCATION_NUM)\n\t\treturn -EIO;\n\n\tif (le32_to_cpu(fwrt->trans->dbg.fw_mon_cfg[alloc_id].buf_location) !=\n\t    IWL_FW_INI_LOCATION_DRAM_PATH)\n\t\treturn 0;\n\n\tfw_mon = &fwrt->trans->dbg.fw_mon_ini[alloc_id];\n\n\t \n\tif (alloc_id == IWL_FW_INI_ALLOCATION_ID_DBGC1)\n\t\tfw_mon_idx++;\n\n\tremain_frags = fw_mon->num_frags - fw_mon_idx;\n\tif (!remain_frags)\n\t\treturn 0;\n\n\tnum_commands = DIV_ROUND_UP(remain_frags, BUF_ALLOC_MAX_NUM_FRAGS);\n\n\tIWL_DEBUG_FW(fwrt, \"WRT: Applying DRAM destination (alloc_id=%u)\\n\",\n\t\t     alloc_id);\n\n\tfor (i = 0; i < num_commands; i++) {\n\t\tu32 num_frags = min_t(u32, remain_frags,\n\t\t\t\t      BUF_ALLOC_MAX_NUM_FRAGS);\n\t\tstruct iwl_buf_alloc_cmd data = {\n\t\t\t.alloc_id = cpu_to_le32(alloc_id),\n\t\t\t.num_frags = cpu_to_le32(num_frags),\n\t\t\t.buf_location =\n\t\t\t\tcpu_to_le32(IWL_FW_INI_LOCATION_DRAM_PATH),\n\t\t};\n\t\tstruct iwl_host_cmd hcmd = {\n\t\t\t.id = WIDE_ID(DEBUG_GROUP, BUFFER_ALLOCATION),\n\t\t\t.data[0] = &data,\n\t\t\t.len[0] = sizeof(data),\n\t\t\t.flags = CMD_SEND_IN_RFKILL,\n\t\t};\n\t\tint ret, j;\n\n\t\tfor (j = 0; j < num_frags; j++) {\n\t\t\tstruct iwl_buf_alloc_frag *frag = &data.frags[j];\n\t\t\tstruct iwl_dram_data *fw_mon_frag =\n\t\t\t\t&fw_mon->frags[fw_mon_idx++];\n\n\t\t\tfrag->addr = cpu_to_le64(fw_mon_frag->physical);\n\t\t\tfrag->size = cpu_to_le32(fw_mon_frag->size);\n\t\t}\n\t\tret = iwl_trans_send_cmd(fwrt->trans, &hcmd);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tremain_frags -= num_frags;\n\t}\n\n\treturn 0;\n}\n\nstatic void iwl_dbg_tlv_apply_buffers(struct iwl_fw_runtime *fwrt)\n{\n\tint ret, i;\n\n\tif (fw_has_capa(&fwrt->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_DRAM_FRAG_SUPPORT))\n\t\treturn;\n\n\tfor (i = 0; i < IWL_FW_INI_ALLOCATION_NUM; i++) {\n\t\tret = iwl_dbg_tlv_apply_buffer(fwrt, i);\n\t\tif (ret)\n\t\t\tIWL_WARN(fwrt,\n\t\t\t\t \"WRT: Failed to apply DRAM buffer for allocation id %d, ret=%d\\n\",\n\t\t\t\t i, ret);\n\t}\n}\n\nstatic int iwl_dbg_tlv_update_dram(struct iwl_fw_runtime *fwrt,\n\t\t\t\t   enum iwl_fw_ini_allocation_id alloc_id,\n\t\t\t\t   struct iwl_dram_info *dram_info)\n{\n\tstruct iwl_fw_mon *fw_mon;\n\tu32 remain_frags, num_frags;\n\tint j, fw_mon_idx = 0;\n\tstruct iwl_buf_alloc_cmd *data;\n\n\tif (le32_to_cpu(fwrt->trans->dbg.fw_mon_cfg[alloc_id].buf_location) !=\n\t\t\tIWL_FW_INI_LOCATION_DRAM_PATH) {\n\t\tIWL_DEBUG_FW(fwrt, \"WRT: alloc_id %u location is not in DRAM_PATH\\n\",\n\t\t\t     alloc_id);\n\t\treturn -1;\n\t}\n\n\tfw_mon = &fwrt->trans->dbg.fw_mon_ini[alloc_id];\n\n\t \n\tif (alloc_id == IWL_FW_INI_ALLOCATION_ID_DBGC1)\n\t\tfw_mon_idx++;\n\n\tremain_frags = fw_mon->num_frags - fw_mon_idx;\n\tif (!remain_frags)\n\t\treturn -1;\n\n\tnum_frags = min_t(u32, remain_frags, BUF_ALLOC_MAX_NUM_FRAGS);\n\tdata = &dram_info->dram_frags[alloc_id - 1];\n\tdata->alloc_id = cpu_to_le32(alloc_id);\n\tdata->num_frags = cpu_to_le32(num_frags);\n\tdata->buf_location = cpu_to_le32(IWL_FW_INI_LOCATION_DRAM_PATH);\n\n\tIWL_DEBUG_FW(fwrt, \"WRT: DRAM buffer details alloc_id=%u, num_frags=%u\\n\",\n\t\t     cpu_to_le32(alloc_id), cpu_to_le32(num_frags));\n\n\tfor (j = 0; j < num_frags; j++) {\n\t\tstruct iwl_buf_alloc_frag *frag = &data->frags[j];\n\t\tstruct iwl_dram_data *fw_mon_frag = &fw_mon->frags[fw_mon_idx++];\n\n\t\tfrag->addr = cpu_to_le64(fw_mon_frag->physical);\n\t\tfrag->size = cpu_to_le32(fw_mon_frag->size);\n\t\tIWL_DEBUG_FW(fwrt, \"WRT: DRAM fragment details\\n\");\n\t\tIWL_DEBUG_FW(fwrt, \"frag=%u, addr=0x%016llx, size=0x%x)\\n\",\n\t\t\t     j, cpu_to_le64(fw_mon_frag->physical),\n\t\t\t     cpu_to_le32(fw_mon_frag->size));\n\t}\n\treturn 0;\n}\n\nstatic void iwl_dbg_tlv_update_drams(struct iwl_fw_runtime *fwrt)\n{\n\tint ret, i;\n\tbool dram_alloc = false;\n\tstruct iwl_dram_data *frags =\n\t\t&fwrt->trans->dbg.fw_mon_ini[IWL_FW_INI_ALLOCATION_ID_DBGC1].frags[0];\n\tstruct iwl_dram_info *dram_info;\n\n\tif (!frags || !frags->block)\n\t\treturn;\n\n\tdram_info = frags->block;\n\n\tif (!fw_has_capa(&fwrt->fw->ucode_capa,\n\t\t\t IWL_UCODE_TLV_CAPA_DRAM_FRAG_SUPPORT))\n\t\treturn;\n\n\tmemset(dram_info, 0, sizeof(*dram_info));\n\n\tfor (i = IWL_FW_INI_ALLOCATION_ID_DBGC1;\n\t     i < IWL_FW_INI_ALLOCATION_NUM; i++) {\n\t\tif (fwrt->trans->dbg.fw_mon_cfg[i].buf_location ==\n\t\t\t\tIWL_FW_INI_LOCATION_INVALID)\n\t\t\tcontinue;\n\n\t\tret = iwl_dbg_tlv_update_dram(fwrt, i, dram_info);\n\t\tif (!ret)\n\t\t\tdram_alloc = true;\n\t\telse\n\t\t\tIWL_INFO(fwrt,\n\t\t\t\t \"WRT: Failed to set DRAM buffer for alloc id %d, ret=%d\\n\",\n\t\t\t\t i, ret);\n\t}\n\n\tif (dram_alloc) {\n\t\tdram_info->first_word = cpu_to_le32(DRAM_INFO_FIRST_MAGIC_WORD);\n\t\tdram_info->second_word = cpu_to_le32(DRAM_INFO_SECOND_MAGIC_WORD);\n\t}\n}\n\nstatic void iwl_dbg_tlv_send_hcmds(struct iwl_fw_runtime *fwrt,\n\t\t\t\t   struct list_head *hcmd_list)\n{\n\tstruct iwl_dbg_tlv_node *node;\n\n\tlist_for_each_entry(node, hcmd_list, list) {\n\t\tstruct iwl_fw_ini_hcmd_tlv *hcmd = (void *)node->tlv.data;\n\t\tstruct iwl_fw_ini_hcmd *hcmd_data = &hcmd->hcmd;\n\t\tu16 hcmd_len = le32_to_cpu(node->tlv.length) - sizeof(*hcmd);\n\t\tstruct iwl_host_cmd cmd = {\n\t\t\t.id = WIDE_ID(hcmd_data->group, hcmd_data->id),\n\t\t\t.len = { hcmd_len, },\n\t\t\t.data = { hcmd_data->data, },\n\t\t};\n\n\t\tiwl_trans_send_cmd(fwrt->trans, &cmd);\n\t}\n}\n\nstatic void iwl_dbg_tlv_apply_config(struct iwl_fw_runtime *fwrt,\n\t\t\t\t     struct list_head *conf_list)\n{\n\tstruct iwl_dbg_tlv_node *node;\n\n\tlist_for_each_entry(node, conf_list, list) {\n\t\tstruct iwl_fw_ini_conf_set_tlv *config_list = (void *)node->tlv.data;\n\t\tu32 count, address, value;\n\t\tu32 len = (le32_to_cpu(node->tlv.length) - sizeof(*config_list)) / 8;\n\t\tu32 type = le32_to_cpu(config_list->set_type);\n\t\tu32 offset = le32_to_cpu(config_list->addr_offset);\n\n\t\tswitch (type) {\n\t\tcase IWL_FW_INI_CONFIG_SET_TYPE_DEVICE_PERIPHERY_MAC: {\n\t\t\tif (!iwl_trans_grab_nic_access(fwrt->trans)) {\n\t\t\t\tIWL_DEBUG_FW(fwrt, \"WRT: failed to get nic access\\n\");\n\t\t\t\tIWL_DEBUG_FW(fwrt, \"WRT: skipping MAC PERIPHERY config\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tIWL_DEBUG_FW(fwrt, \"WRT:  MAC PERIPHERY config len: len %u\\n\", len);\n\t\t\tfor (count = 0; count < len; count++) {\n\t\t\t\taddress = le32_to_cpu(config_list->addr_val[count].address);\n\t\t\t\tvalue = le32_to_cpu(config_list->addr_val[count].value);\n\t\t\t\tiwl_trans_write_prph(fwrt->trans, address + offset, value);\n\t\t\t}\n\t\t\tiwl_trans_release_nic_access(fwrt->trans);\n\t\tbreak;\n\t\t}\n\t\tcase IWL_FW_INI_CONFIG_SET_TYPE_DEVICE_MEMORY: {\n\t\t\tfor (count = 0; count < len; count++) {\n\t\t\t\taddress = le32_to_cpu(config_list->addr_val[count].address);\n\t\t\t\tvalue = le32_to_cpu(config_list->addr_val[count].value);\n\t\t\t\tiwl_trans_write_mem32(fwrt->trans, address + offset, value);\n\t\t\t\tIWL_DEBUG_FW(fwrt, \"WRT: DEV_MEM: count %u, add: %u val: %u\\n\",\n\t\t\t\t\t     count, address, value);\n\t\t\t}\n\t\tbreak;\n\t\t}\n\t\tcase IWL_FW_INI_CONFIG_SET_TYPE_CSR: {\n\t\t\tfor (count = 0; count < len; count++) {\n\t\t\t\taddress = le32_to_cpu(config_list->addr_val[count].address);\n\t\t\t\tvalue = le32_to_cpu(config_list->addr_val[count].value);\n\t\t\t\tiwl_write32(fwrt->trans, address + offset, value);\n\t\t\t\tIWL_DEBUG_FW(fwrt, \"WRT: CSR: count %u, add: %u val: %u\\n\",\n\t\t\t\t\t     count, address, value);\n\t\t\t}\n\t\tbreak;\n\t\t}\n\t\tcase IWL_FW_INI_CONFIG_SET_TYPE_DBGC_DRAM_ADDR: {\n\t\t\tstruct iwl_dbgc1_info dram_info = {};\n\t\t\tstruct iwl_dram_data *frags = &fwrt->trans->dbg.fw_mon_ini[1].frags[0];\n\t\t\t__le64 dram_base_addr;\n\t\t\t__le32 dram_size;\n\t\t\tu64 dram_addr;\n\t\t\tu32 ret;\n\n\t\t\tif (!frags)\n\t\t\t\tbreak;\n\n\t\t\tdram_base_addr = cpu_to_le64(frags->physical);\n\t\t\tdram_size = cpu_to_le32(frags->size);\n\t\t\tdram_addr = le64_to_cpu(dram_base_addr);\n\n\t\t\tIWL_DEBUG_FW(fwrt, \"WRT: dram_base_addr 0x%016llx, dram_size 0x%x\\n\",\n\t\t\t\t     dram_base_addr, dram_size);\n\t\t\tIWL_DEBUG_FW(fwrt, \"WRT: config_list->addr_offset: %u\\n\",\n\t\t\t\t     le32_to_cpu(config_list->addr_offset));\n\t\t\tfor (count = 0; count < len; count++) {\n\t\t\t\taddress = le32_to_cpu(config_list->addr_val[count].address);\n\t\t\t\tdram_info.dbgc1_add_lsb =\n\t\t\t\t\tcpu_to_le32((dram_addr & 0x00000000FFFFFFFFULL) + 0x400);\n\t\t\t\tdram_info.dbgc1_add_msb =\n\t\t\t\t\tcpu_to_le32((dram_addr & 0xFFFFFFFF00000000ULL) >> 32);\n\t\t\t\tdram_info.dbgc1_size = cpu_to_le32(le32_to_cpu(dram_size) - 0x400);\n\t\t\t\tret = iwl_trans_write_mem(fwrt->trans,\n\t\t\t\t\t\t\t  address + offset, &dram_info, 4);\n\t\t\t\tif (ret) {\n\t\t\t\t\tIWL_ERR(fwrt, \"Failed to write dram_info to HW_SMEM\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase IWL_FW_INI_CONFIG_SET_TYPE_PERIPH_SCRATCH_HWM: {\n\t\t\tu32 debug_token_config =\n\t\t\t\tle32_to_cpu(config_list->addr_val[0].value);\n\n\t\t\tIWL_DEBUG_FW(fwrt, \"WRT: Setting HWM debug token config: %u\\n\",\n\t\t\t\t     debug_token_config);\n\t\t\tfwrt->trans->dbg.ucode_preset = debug_token_config;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void iwl_dbg_tlv_periodic_trig_handler(struct timer_list *t)\n{\n\tstruct iwl_dbg_tlv_timer_node *timer_node =\n\t\tfrom_timer(timer_node, t, timer);\n\tstruct iwl_fwrt_dump_data dump_data = {\n\t\t.trig = (void *)timer_node->tlv->data,\n\t};\n\tint ret;\n\n\tret = iwl_fw_dbg_ini_collect(timer_node->fwrt, &dump_data, false);\n\tif (!ret || ret == -EBUSY) {\n\t\tu32 occur = le32_to_cpu(dump_data.trig->occurrences);\n\t\tu32 collect_interval = le32_to_cpu(dump_data.trig->data[0]);\n\n\t\tif (!occur)\n\t\t\treturn;\n\n\t\tmod_timer(t, jiffies + msecs_to_jiffies(collect_interval));\n\t}\n}\n\nstatic void iwl_dbg_tlv_set_periodic_trigs(struct iwl_fw_runtime *fwrt)\n{\n\tstruct iwl_dbg_tlv_node *node;\n\tstruct list_head *trig_list =\n\t\t&fwrt->trans->dbg.time_point[IWL_FW_INI_TIME_POINT_PERIODIC].active_trig_list;\n\n\tlist_for_each_entry(node, trig_list, list) {\n\t\tstruct iwl_fw_ini_trigger_tlv *trig = (void *)node->tlv.data;\n\t\tstruct iwl_dbg_tlv_timer_node *timer_node;\n\t\tu32 occur = le32_to_cpu(trig->occurrences), collect_interval;\n\t\tu32 min_interval = 100;\n\n\t\tif (!occur)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (le32_to_cpu(node->tlv.length) <\n\t\t    sizeof(*trig) + sizeof(__le32)) {\n\t\t\tIWL_ERR(fwrt,\n\t\t\t\t\"WRT: Invalid periodic trigger data was not given\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (le32_to_cpu(trig->data[0]) < min_interval) {\n\t\t\tIWL_WARN(fwrt,\n\t\t\t\t \"WRT: Override min interval from %u to %u msec\\n\",\n\t\t\t\t le32_to_cpu(trig->data[0]), min_interval);\n\t\t\ttrig->data[0] = cpu_to_le32(min_interval);\n\t\t}\n\n\t\tcollect_interval = le32_to_cpu(trig->data[0]);\n\n\t\ttimer_node = kzalloc(sizeof(*timer_node), GFP_KERNEL);\n\t\tif (!timer_node) {\n\t\t\tIWL_ERR(fwrt,\n\t\t\t\t\"WRT: Failed to allocate periodic trigger\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\ttimer_node->fwrt = fwrt;\n\t\ttimer_node->tlv = &node->tlv;\n\t\ttimer_setup(&timer_node->timer,\n\t\t\t    iwl_dbg_tlv_periodic_trig_handler, 0);\n\n\t\tlist_add_tail(&timer_node->list,\n\t\t\t      &fwrt->trans->dbg.periodic_trig_list);\n\n\t\tIWL_DEBUG_FW(fwrt, \"WRT: Enabling periodic trigger\\n\");\n\n\t\tmod_timer(&timer_node->timer,\n\t\t\t  jiffies + msecs_to_jiffies(collect_interval));\n\t}\n}\n\nstatic bool is_trig_data_contained(const struct iwl_ucode_tlv *new,\n\t\t\t\t   const struct iwl_ucode_tlv *old)\n{\n\tconst struct iwl_fw_ini_trigger_tlv *new_trig = (const void *)new->data;\n\tconst struct iwl_fw_ini_trigger_tlv *old_trig = (const void *)old->data;\n\tconst __le32 *new_data = new_trig->data, *old_data = old_trig->data;\n\tu32 new_dwords_num = iwl_tlv_array_len(new, new_trig, data);\n\tu32 old_dwords_num = iwl_tlv_array_len(old, old_trig, data);\n\tint i, j;\n\n\tfor (i = 0; i < new_dwords_num; i++) {\n\t\tbool match = false;\n\n\t\tfor (j = 0; j < old_dwords_num; j++) {\n\t\t\tif (new_data[i] == old_data[j]) {\n\t\t\t\tmatch = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!match)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int iwl_dbg_tlv_override_trig_node(struct iwl_fw_runtime *fwrt,\n\t\t\t\t\t  struct iwl_ucode_tlv *trig_tlv,\n\t\t\t\t\t  struct iwl_dbg_tlv_node *node)\n{\n\tstruct iwl_ucode_tlv *node_tlv = &node->tlv;\n\tstruct iwl_fw_ini_trigger_tlv *node_trig = (void *)node_tlv->data;\n\tstruct iwl_fw_ini_trigger_tlv *trig = (void *)trig_tlv->data;\n\tu32 policy = le32_to_cpu(trig->apply_policy);\n\tu32 size = le32_to_cpu(trig_tlv->length);\n\tu32 trig_data_len = size - sizeof(*trig);\n\tu32 offset = 0;\n\n\tif (!(policy & IWL_FW_INI_APPLY_POLICY_OVERRIDE_DATA)) {\n\t\tu32 data_len = le32_to_cpu(node_tlv->length) -\n\t\t\tsizeof(*node_trig);\n\n\t\tIWL_DEBUG_FW(fwrt,\n\t\t\t     \"WRT: Appending trigger data (time point %u)\\n\",\n\t\t\t     le32_to_cpu(trig->time_point));\n\n\t\toffset += data_len;\n\t\tsize += data_len;\n\t} else {\n\t\tIWL_DEBUG_FW(fwrt,\n\t\t\t     \"WRT: Overriding trigger data (time point %u)\\n\",\n\t\t\t     le32_to_cpu(trig->time_point));\n\t}\n\n\tif (size != le32_to_cpu(node_tlv->length)) {\n\t\tstruct list_head *prev = node->list.prev;\n\t\tstruct iwl_dbg_tlv_node *tmp;\n\n\t\tlist_del(&node->list);\n\n\t\ttmp = krealloc(node, sizeof(*node) + size, GFP_KERNEL);\n\t\tif (!tmp) {\n\t\t\tIWL_WARN(fwrt,\n\t\t\t\t \"WRT: No memory to override trigger (time point %u)\\n\",\n\t\t\t\t le32_to_cpu(trig->time_point));\n\n\t\t\tlist_add(&node->list, prev);\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tlist_add(&tmp->list, prev);\n\t\tnode_tlv = &tmp->tlv;\n\t\tnode_trig = (void *)node_tlv->data;\n\t}\n\n\tmemcpy(node_trig->data + offset, trig->data, trig_data_len);\n\tnode_tlv->length = cpu_to_le32(size);\n\n\tif (policy & IWL_FW_INI_APPLY_POLICY_OVERRIDE_CFG) {\n\t\tIWL_DEBUG_FW(fwrt,\n\t\t\t     \"WRT: Overriding trigger configuration (time point %u)\\n\",\n\t\t\t     le32_to_cpu(trig->time_point));\n\n\t\t \n\t\tmemcpy(node_trig, trig, sizeof(__le32) * 11);\n\t}\n\n\tif (policy & IWL_FW_INI_APPLY_POLICY_OVERRIDE_REGIONS) {\n\t\tIWL_DEBUG_FW(fwrt,\n\t\t\t     \"WRT: Overriding trigger regions (time point %u)\\n\",\n\t\t\t     le32_to_cpu(trig->time_point));\n\n\t\tnode_trig->regions_mask = trig->regions_mask;\n\t} else {\n\t\tIWL_DEBUG_FW(fwrt,\n\t\t\t     \"WRT: Appending trigger regions (time point %u)\\n\",\n\t\t\t     le32_to_cpu(trig->time_point));\n\n\t\tnode_trig->regions_mask |= trig->regions_mask;\n\t}\n\n\treturn 0;\n}\n\nstatic int\niwl_dbg_tlv_add_active_trigger(struct iwl_fw_runtime *fwrt,\n\t\t\t       struct list_head *trig_list,\n\t\t\t       struct iwl_ucode_tlv *trig_tlv)\n{\n\tstruct iwl_fw_ini_trigger_tlv *trig = (void *)trig_tlv->data;\n\tstruct iwl_dbg_tlv_node *node, *match = NULL;\n\tu32 policy = le32_to_cpu(trig->apply_policy);\n\n\tlist_for_each_entry(node, trig_list, list) {\n\t\tif (!(policy & IWL_FW_INI_APPLY_POLICY_MATCH_TIME_POINT))\n\t\t\tbreak;\n\n\t\tif (!(policy & IWL_FW_INI_APPLY_POLICY_MATCH_DATA) ||\n\t\t    is_trig_data_contained(trig_tlv, &node->tlv)) {\n\t\t\tmatch = node;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!match) {\n\t\tIWL_DEBUG_FW(fwrt, \"WRT: Enabling trigger (time point %u)\\n\",\n\t\t\t     le32_to_cpu(trig->time_point));\n\t\treturn iwl_dbg_tlv_add(trig_tlv, trig_list);\n\t}\n\n\treturn iwl_dbg_tlv_override_trig_node(fwrt, trig_tlv, match);\n}\n\nstatic void\niwl_dbg_tlv_gen_active_trig_list(struct iwl_fw_runtime *fwrt,\n\t\t\t\t struct iwl_dbg_tlv_time_point_data *tp)\n{\n\tstruct iwl_dbg_tlv_node *node;\n\tstruct list_head *trig_list = &tp->trig_list;\n\tstruct list_head *active_trig_list = &tp->active_trig_list;\n\n\tlist_for_each_entry(node, trig_list, list) {\n\t\tstruct iwl_ucode_tlv *tlv = &node->tlv;\n\n\t\tiwl_dbg_tlv_add_active_trigger(fwrt, active_trig_list, tlv);\n\t}\n}\n\nstatic bool iwl_dbg_tlv_check_fw_pkt(struct iwl_fw_runtime *fwrt,\n\t\t\t\t     struct iwl_fwrt_dump_data *dump_data,\n\t\t\t\t     union iwl_dbg_tlv_tp_data *tp_data,\n\t\t\t\t     u32 trig_data)\n{\n\tstruct iwl_rx_packet *pkt = tp_data->fw_pkt;\n\tstruct iwl_cmd_header *wanted_hdr = (void *)&trig_data;\n\n\tif (pkt && (pkt->hdr.cmd == wanted_hdr->cmd &&\n\t\t    pkt->hdr.group_id == wanted_hdr->group_id)) {\n\t\tstruct iwl_rx_packet *fw_pkt =\n\t\t\tkmemdup(pkt,\n\t\t\t\tsizeof(*pkt) + iwl_rx_packet_payload_len(pkt),\n\t\t\t\tGFP_ATOMIC);\n\n\t\tif (!fw_pkt)\n\t\t\treturn false;\n\n\t\tdump_data->fw_pkt = fw_pkt;\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int\niwl_dbg_tlv_tp_trigger(struct iwl_fw_runtime *fwrt, bool sync,\n\t\t       struct list_head *active_trig_list,\n\t\t       union iwl_dbg_tlv_tp_data *tp_data,\n\t\t       bool (*data_check)(struct iwl_fw_runtime *fwrt,\n\t\t\t\t\t  struct iwl_fwrt_dump_data *dump_data,\n\t\t\t\t\t  union iwl_dbg_tlv_tp_data *tp_data,\n\t\t\t\t\t  u32 trig_data))\n{\n\tstruct iwl_dbg_tlv_node *node;\n\n\tlist_for_each_entry(node, active_trig_list, list) {\n\t\tstruct iwl_fwrt_dump_data dump_data = {\n\t\t\t.trig = (void *)node->tlv.data,\n\t\t};\n\t\tu32 num_data = iwl_tlv_array_len(&node->tlv, dump_data.trig,\n\t\t\t\t\t\t data);\n\t\tint ret, i;\n\t\tu32 tp = le32_to_cpu(dump_data.trig->time_point);\n\n\n\t\tif (!num_data) {\n\t\t\tret = iwl_fw_dbg_ini_collect(fwrt, &dump_data, sync);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tfor (i = 0; i < num_data; i++) {\n\t\t\tif (!data_check ||\n\t\t\t    data_check(fwrt, &dump_data, tp_data,\n\t\t\t\t       le32_to_cpu(dump_data.trig->data[i]))) {\n\t\t\t\tret = iwl_fw_dbg_ini_collect(fwrt, &dump_data, sync);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfwrt->trans->dbg.restart_required = FALSE;\n\t\tIWL_DEBUG_FW(fwrt, \"WRT: tp %d, reset_fw %d\\n\",\n\t\t\t     tp, dump_data.trig->reset_fw);\n\t\tIWL_DEBUG_FW(fwrt,\n\t\t\t     \"WRT: restart_required %d, last_tp_resetfw %d\\n\",\n\t\t\t     fwrt->trans->dbg.restart_required,\n\t\t\t     fwrt->trans->dbg.last_tp_resetfw);\n\n\t\tif (fwrt->trans->trans_cfg->device_family ==\n\t\t    IWL_DEVICE_FAMILY_9000) {\n\t\t\tfwrt->trans->dbg.restart_required = TRUE;\n\t\t} else if (tp == IWL_FW_INI_TIME_POINT_FW_ASSERT &&\n\t\t\t   fwrt->trans->dbg.last_tp_resetfw ==\n\t\t\t   IWL_FW_INI_RESET_FW_MODE_STOP_FW_ONLY) {\n\t\t\tfwrt->trans->dbg.restart_required = FALSE;\n\t\t\tfwrt->trans->dbg.last_tp_resetfw = 0xFF;\n\t\t\tIWL_DEBUG_FW(fwrt, \"WRT: FW_ASSERT due to reset_fw_mode-no restart\\n\");\n\t\t} else if (le32_to_cpu(dump_data.trig->reset_fw) ==\n\t\t\t   IWL_FW_INI_RESET_FW_MODE_STOP_AND_RELOAD_FW) {\n\t\t\tIWL_DEBUG_FW(fwrt, \"WRT: stop and reload firmware\\n\");\n\t\t\tfwrt->trans->dbg.restart_required = TRUE;\n\t\t} else if (le32_to_cpu(dump_data.trig->reset_fw) ==\n\t\t\t   IWL_FW_INI_RESET_FW_MODE_STOP_FW_ONLY) {\n\t\t\tIWL_DEBUG_FW(fwrt,\n\t\t\t\t     \"WRT: stop only and no reload firmware\\n\");\n\t\t\tfwrt->trans->dbg.restart_required = FALSE;\n\t\t\tfwrt->trans->dbg.last_tp_resetfw =\n\t\t\t\tle32_to_cpu(dump_data.trig->reset_fw);\n\t\t} else if (le32_to_cpu(dump_data.trig->reset_fw) ==\n\t\t\t   IWL_FW_INI_RESET_FW_MODE_NOTHING) {\n\t\t\tIWL_DEBUG_FW(fwrt,\n\t\t\t\t     \"WRT: nothing need to be done after debug collection\\n\");\n\t\t} else {\n\t\t\tIWL_ERR(fwrt, \"WRT: wrong resetfw %d\\n\",\n\t\t\t\tle32_to_cpu(dump_data.trig->reset_fw));\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void iwl_dbg_tlv_init_cfg(struct iwl_fw_runtime *fwrt)\n{\n\tenum iwl_fw_ini_buffer_location *ini_dest = &fwrt->trans->dbg.ini_dest;\n\tint ret, i;\n\tu32 failed_alloc = 0;\n\n\tif (*ini_dest == IWL_FW_INI_LOCATION_INVALID) {\n\t\tIWL_DEBUG_FW(fwrt,\n\t\t\t     \"WRT: Generating active triggers list, domain 0x%x\\n\",\n\t\t\t     fwrt->trans->dbg.domains_bitmap);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(fwrt->trans->dbg.time_point); i++) {\n\t\t\tstruct iwl_dbg_tlv_time_point_data *tp =\n\t\t\t\t&fwrt->trans->dbg.time_point[i];\n\n\t\t\tiwl_dbg_tlv_gen_active_trig_list(fwrt, tp);\n\t\t}\n\t} else if (*ini_dest != IWL_FW_INI_LOCATION_DRAM_PATH) {\n\t\t \n\t\treturn;\n\t}\n\n\t*ini_dest = IWL_FW_INI_LOCATION_INVALID;\n\tfor (i = 0; i < IWL_FW_INI_ALLOCATION_NUM; i++) {\n\t\tstruct iwl_fw_ini_allocation_tlv *fw_mon_cfg =\n\t\t\t&fwrt->trans->dbg.fw_mon_cfg[i];\n\t\tu32 dest = le32_to_cpu(fw_mon_cfg->buf_location);\n\n\t\tif (dest == IWL_FW_INI_LOCATION_INVALID) {\n\t\t\tfailed_alloc |= BIT(i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (*ini_dest == IWL_FW_INI_LOCATION_INVALID)\n\t\t\t*ini_dest = dest;\n\n\t\tif (dest != *ini_dest)\n\t\t\tcontinue;\n\n\t\tret = iwl_dbg_tlv_alloc_fragments(fwrt, i);\n\n\t\tif (ret) {\n\t\t\tIWL_WARN(fwrt,\n\t\t\t\t \"WRT: Failed to allocate DRAM buffer for allocation id %d, ret=%d\\n\",\n\t\t\t\t i, ret);\n\t\t\tfailed_alloc |= BIT(i);\n\t\t}\n\t}\n\n\tif (!failed_alloc)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(fwrt->trans->dbg.active_regions) && failed_alloc; i++) {\n\t\tstruct iwl_fw_ini_region_tlv *reg;\n\t\tstruct iwl_ucode_tlv **active_reg =\n\t\t\t&fwrt->trans->dbg.active_regions[i];\n\t\tu32 reg_type;\n\n\t\tif (!*active_reg) {\n\t\t\tfwrt->trans->dbg.unsupported_region_msk |= BIT(i);\n\t\t\tcontinue;\n\t\t}\n\n\t\treg = (void *)(*active_reg)->data;\n\t\treg_type = reg->type;\n\n\t\tif (reg_type != IWL_FW_INI_REGION_DRAM_BUFFER ||\n\t\t    !(BIT(le32_to_cpu(reg->dram_alloc_id)) & failed_alloc))\n\t\t\tcontinue;\n\n\t\tIWL_DEBUG_FW(fwrt,\n\t\t\t     \"WRT: removing allocation id %d from region id %d\\n\",\n\t\t\t     le32_to_cpu(reg->dram_alloc_id), i);\n\n\t\tfailed_alloc &= ~BIT(le32_to_cpu(reg->dram_alloc_id));\n\t\tfwrt->trans->dbg.unsupported_region_msk |= BIT(i);\n\n\t\tkfree(*active_reg);\n\t\t*active_reg = NULL;\n\t}\n}\n\nvoid _iwl_dbg_tlv_time_point(struct iwl_fw_runtime *fwrt,\n\t\t\t     enum iwl_fw_ini_time_point tp_id,\n\t\t\t     union iwl_dbg_tlv_tp_data *tp_data,\n\t\t\t     bool sync)\n{\n\tstruct list_head *hcmd_list, *trig_list, *conf_list;\n\n\tif (!iwl_trans_dbg_ini_valid(fwrt->trans) ||\n\t    tp_id == IWL_FW_INI_TIME_POINT_INVALID ||\n\t    tp_id >= IWL_FW_INI_TIME_POINT_NUM)\n\t\treturn;\n\n\thcmd_list = &fwrt->trans->dbg.time_point[tp_id].hcmd_list;\n\ttrig_list = &fwrt->trans->dbg.time_point[tp_id].active_trig_list;\n\tconf_list = &fwrt->trans->dbg.time_point[tp_id].config_list;\n\n\tswitch (tp_id) {\n\tcase IWL_FW_INI_TIME_POINT_EARLY:\n\t\tiwl_dbg_tlv_init_cfg(fwrt);\n\t\tiwl_dbg_tlv_apply_config(fwrt, conf_list);\n\t\tiwl_dbg_tlv_update_drams(fwrt);\n\t\tiwl_dbg_tlv_tp_trigger(fwrt, sync, trig_list, tp_data, NULL);\n\t\tbreak;\n\tcase IWL_FW_INI_TIME_POINT_AFTER_ALIVE:\n\t\tiwl_dbg_tlv_apply_buffers(fwrt);\n\t\tiwl_dbg_tlv_send_hcmds(fwrt, hcmd_list);\n\t\tiwl_dbg_tlv_apply_config(fwrt, conf_list);\n\t\tiwl_dbg_tlv_tp_trigger(fwrt, sync, trig_list, tp_data, NULL);\n\t\tbreak;\n\tcase IWL_FW_INI_TIME_POINT_PERIODIC:\n\t\tiwl_dbg_tlv_set_periodic_trigs(fwrt);\n\t\tiwl_dbg_tlv_send_hcmds(fwrt, hcmd_list);\n\t\tbreak;\n\tcase IWL_FW_INI_TIME_POINT_FW_RSP_OR_NOTIF:\n\tcase IWL_FW_INI_TIME_POINT_MISSED_BEACONS:\n\tcase IWL_FW_INI_TIME_POINT_FW_DHC_NOTIFICATION:\n\t\tiwl_dbg_tlv_send_hcmds(fwrt, hcmd_list);\n\t\tiwl_dbg_tlv_apply_config(fwrt, conf_list);\n\t\tiwl_dbg_tlv_tp_trigger(fwrt, sync, trig_list, tp_data,\n\t\t\t\t       iwl_dbg_tlv_check_fw_pkt);\n\t\tbreak;\n\tdefault:\n\t\tiwl_dbg_tlv_send_hcmds(fwrt, hcmd_list);\n\t\tiwl_dbg_tlv_apply_config(fwrt, conf_list);\n\t\tiwl_dbg_tlv_tp_trigger(fwrt, sync, trig_list, tp_data, NULL);\n\t\tbreak;\n\t}\n}\nIWL_EXPORT_SYMBOL(_iwl_dbg_tlv_time_point);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}