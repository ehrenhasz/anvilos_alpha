{
  "module_name": "main.c",
  "hash_id": "26cec4077d45771cb8330c0d85a2bcd087d2bb347844e43dd9506715ea9dbc4c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mei/main.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/netdevice.h>\n#include <linux/ieee80211.h>\n#include <linux/rtnetlink.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/mei_cl_bus.h>\n#include <linux/rcupdate.h>\n#include <linux/debugfs.h>\n#include <linux/skbuff.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\n#include <net/cfg80211.h>\n\n#include \"internal.h\"\n#include \"iwl-mei.h\"\n#include \"trace.h\"\n#include \"trace-data.h\"\n#include \"sap.h\"\n\nMODULE_DESCRIPTION(\"The Intel(R) wireless / CSME firmware interface\");\nMODULE_LICENSE(\"GPL\");\n\n#define MEI_WLAN_UUID UUID_LE(0x13280904, 0x7792, 0x4fcb, \\\n\t\t\t      0xa1, 0xaa, 0x5e, 0x70, 0xcb, 0xb1, 0xe8, 0x65)\n\n \n#define MEI_OWNERSHIP_RETAKE_TIMEOUT_MS\tmsecs_to_jiffies(60000)\n\n \nstatic struct mei_cl_device *iwl_mei_global_cldev;\nstatic DEFINE_MUTEX(iwl_mei_mutex);\nstatic unsigned long iwl_mei_status;\n\nenum iwl_mei_status_bits {\n\tIWL_MEI_STATUS_SAP_CONNECTED,\n};\n\nbool iwl_mei_is_connected(void)\n{\n\treturn test_bit(IWL_MEI_STATUS_SAP_CONNECTED, &iwl_mei_status);\n}\nEXPORT_SYMBOL_GPL(iwl_mei_is_connected);\n\n#define SAP_VERSION\t3\n#define SAP_CONTROL_BLOCK_ID 0x21504153  \n\nstruct iwl_sap_q_ctrl_blk {\n\t__le32 wr_ptr;\n\t__le32 rd_ptr;\n\t__le32 size;\n};\n\nenum iwl_sap_q_idx {\n\tSAP_QUEUE_IDX_NOTIF = 0,\n\tSAP_QUEUE_IDX_DATA,\n\tSAP_QUEUE_IDX_MAX,\n};\n\nstruct iwl_sap_dir {\n\t__le32 reserved;\n\tstruct iwl_sap_q_ctrl_blk q_ctrl_blk[SAP_QUEUE_IDX_MAX];\n};\n\nenum iwl_sap_dir_idx {\n\tSAP_DIRECTION_HOST_TO_ME = 0,\n\tSAP_DIRECTION_ME_TO_HOST,\n\tSAP_DIRECTION_MAX,\n};\n\nstruct iwl_sap_shared_mem_ctrl_blk {\n\t__le32 sap_id;\n\t__le32 size;\n\tstruct iwl_sap_dir dir[SAP_DIRECTION_MAX];\n};\n\n \n\n#define SAP_H2M_DATA_Q_SZ\t48256\n#define SAP_M2H_DATA_Q_SZ\t24128\n#define SAP_H2M_NOTIF_Q_SZ\t2240\n#define SAP_M2H_NOTIF_Q_SZ\t62720\n\n#define _IWL_MEI_SAP_SHARED_MEM_SZ \\\n\t(sizeof(struct iwl_sap_shared_mem_ctrl_blk) + \\\n\t SAP_H2M_DATA_Q_SZ + SAP_H2M_NOTIF_Q_SZ + \\\n\t SAP_M2H_DATA_Q_SZ + SAP_M2H_NOTIF_Q_SZ + 4)\n\n#define IWL_MEI_SAP_SHARED_MEM_SZ \\\n\t(roundup(_IWL_MEI_SAP_SHARED_MEM_SZ, PAGE_SIZE))\n\nstruct iwl_mei_shared_mem_ptrs {\n\tstruct iwl_sap_shared_mem_ctrl_blk *ctrl;\n\tvoid *q_head[SAP_DIRECTION_MAX][SAP_QUEUE_IDX_MAX];\n\tsize_t q_size[SAP_DIRECTION_MAX][SAP_QUEUE_IDX_MAX];\n};\n\nstruct iwl_mei_filters {\n\tstruct rcu_head rcu_head;\n\tstruct iwl_sap_oob_filters filters;\n};\n\n \nstruct iwl_mei {\n\twait_queue_head_t get_nvm_wq;\n\tstruct work_struct send_csa_msg_wk;\n\twait_queue_head_t get_ownership_wq;\n\tstruct iwl_mei_shared_mem_ptrs shared_mem;\n\tstruct mei_cl_device *cldev;\n\tstruct iwl_mei_nvm *nvm;\n\tstruct iwl_mei_filters __rcu *filters;\n\tbool got_ownership;\n\tbool amt_enabled;\n\tbool csa_throttled;\n\tbool csme_taking_ownership;\n\tbool link_prot_state;\n\tbool device_down;\n\tstruct delayed_work csa_throttle_end_wk;\n\twait_queue_head_t pldr_wq;\n\tbool pldr_active;\n\tspinlock_t data_q_lock;\n\tstruct work_struct netdev_work;\n\tstruct delayed_work ownership_dwork;\n\n\tatomic_t sap_seq_no;\n\tatomic_t seq_no;\n\n\tstruct dentry *dbgfs_dir;\n};\n\n \nstruct iwl_mei_cache {\n\tconst struct iwl_mei_ops *ops;\n\tstruct net_device __rcu *netdev;\n\tconst struct iwl_sap_notif_connection_info *conn_info;\n\tconst __le16 *power_limit;\n\tu32 rf_kill;\n\tu16 mcc;\n\tu8 mac_address[6];\n\tu8 nvm_address[6];\n\tvoid *priv;\n};\n\nstatic struct iwl_mei_cache iwl_mei_cache = {\n\t.rf_kill = SAP_HW_RFKILL_DEASSERTED | SAP_SW_RFKILL_DEASSERTED\n};\n\nstatic void iwl_mei_free_shared_mem(struct mei_cl_device *cldev)\n{\n\tstruct iwl_mei *mei = mei_cldev_get_drvdata(cldev);\n\n\tif (mei_cldev_dma_unmap(cldev))\n\t\tdev_err(&cldev->dev, \"Couldn't unmap the shared mem properly\\n\");\n\tmemset(&mei->shared_mem, 0, sizeof(mei->shared_mem));\n}\n\n#define HBM_DMA_BUF_ID_WLAN 1\n\nstatic int iwl_mei_alloc_shared_mem(struct mei_cl_device *cldev)\n{\n\tstruct iwl_mei *mei = mei_cldev_get_drvdata(cldev);\n\tstruct iwl_mei_shared_mem_ptrs *mem = &mei->shared_mem;\n\n\tmem->ctrl = mei_cldev_dma_map(cldev, HBM_DMA_BUF_ID_WLAN,\n\t\t\t\t       IWL_MEI_SAP_SHARED_MEM_SZ);\n\n\tif (IS_ERR(mem->ctrl)) {\n\t\tint ret = PTR_ERR(mem->ctrl);\n\n\t\tmem->ctrl = NULL;\n\n\t\treturn ret;\n\t}\n\n\tmemset(mem->ctrl, 0, IWL_MEI_SAP_SHARED_MEM_SZ);\n\n\treturn 0;\n}\n\nstatic void iwl_mei_init_shared_mem(struct iwl_mei *mei)\n{\n\tstruct iwl_mei_shared_mem_ptrs *mem = &mei->shared_mem;\n\tstruct iwl_sap_dir *h2m;\n\tstruct iwl_sap_dir *m2h;\n\tint dir, queue;\n\tu8 *q_head;\n\n\tmem->ctrl->sap_id = cpu_to_le32(SAP_CONTROL_BLOCK_ID);\n\n\tmem->ctrl->size = cpu_to_le32(sizeof(*mem->ctrl));\n\n\th2m = &mem->ctrl->dir[SAP_DIRECTION_HOST_TO_ME];\n\tm2h = &mem->ctrl->dir[SAP_DIRECTION_ME_TO_HOST];\n\n\th2m->q_ctrl_blk[SAP_QUEUE_IDX_DATA].size =\n\t\tcpu_to_le32(SAP_H2M_DATA_Q_SZ);\n\th2m->q_ctrl_blk[SAP_QUEUE_IDX_NOTIF].size =\n\t\tcpu_to_le32(SAP_H2M_NOTIF_Q_SZ);\n\tm2h->q_ctrl_blk[SAP_QUEUE_IDX_DATA].size =\n\t\tcpu_to_le32(SAP_M2H_DATA_Q_SZ);\n\tm2h->q_ctrl_blk[SAP_QUEUE_IDX_NOTIF].size =\n\t\tcpu_to_le32(SAP_M2H_NOTIF_Q_SZ);\n\n\t \n\tq_head = (void *)(mem->ctrl + 1);\n\n\t \n\tfor (dir = 0; dir < SAP_DIRECTION_MAX; dir++) {\n\t\tfor (queue = 0; queue < SAP_QUEUE_IDX_MAX; queue++) {\n\t\t\tmem->q_head[dir][queue] = q_head;\n\t\t\tq_head +=\n\t\t\t\tle32_to_cpu(mem->ctrl->dir[dir].q_ctrl_blk[queue].size);\n\t\t\tmem->q_size[dir][queue] =\n\t\t\t\tle32_to_cpu(mem->ctrl->dir[dir].q_ctrl_blk[queue].size);\n\t\t}\n\t}\n\n\t*(__le32 *)q_head = cpu_to_le32(SAP_CONTROL_BLOCK_ID);\n}\n\nstatic ssize_t iwl_mei_write_cyclic_buf(struct mei_cl_device *cldev,\n\t\t\t\t\tstruct iwl_sap_q_ctrl_blk *notif_q,\n\t\t\t\t\tu8 *q_head,\n\t\t\t\t\tconst struct iwl_sap_hdr *hdr,\n\t\t\t\t\tu32 q_sz)\n{\n\tu32 rd = le32_to_cpu(READ_ONCE(notif_q->rd_ptr));\n\tu32 wr = le32_to_cpu(READ_ONCE(notif_q->wr_ptr));\n\tsize_t room_in_buf;\n\tsize_t tx_sz = sizeof(*hdr) + le16_to_cpu(hdr->len);\n\n\tif (rd > q_sz || wr > q_sz) {\n\t\tdev_err(&cldev->dev,\n\t\t\t\"Pointers are past the end of the buffer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\troom_in_buf = wr >= rd ? q_sz - wr + rd : rd - wr;\n\n\t \n\tif (room_in_buf < tx_sz) {\n\t\tdev_err(&cldev->dev,\n\t\t\t\"Not enough room in the buffer\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tif (wr + tx_sz <= q_sz) {\n\t\tmemcpy(q_head + wr, hdr, tx_sz);\n\t} else {\n\t\tmemcpy(q_head + wr, hdr, q_sz - wr);\n\t\tmemcpy(q_head, (const u8 *)hdr + q_sz - wr, tx_sz - (q_sz - wr));\n\t}\n\n\tWRITE_ONCE(notif_q->wr_ptr, cpu_to_le32((wr + tx_sz) % q_sz));\n\treturn 0;\n}\n\nstatic bool iwl_mei_host_to_me_data_pending(const struct iwl_mei *mei)\n{\n\tstruct iwl_sap_q_ctrl_blk *notif_q;\n\tstruct iwl_sap_dir *dir;\n\n\tdir = &mei->shared_mem.ctrl->dir[SAP_DIRECTION_HOST_TO_ME];\n\tnotif_q = &dir->q_ctrl_blk[SAP_QUEUE_IDX_DATA];\n\n\tif (READ_ONCE(notif_q->wr_ptr) != READ_ONCE(notif_q->rd_ptr))\n\t\treturn true;\n\n\tnotif_q = &dir->q_ctrl_blk[SAP_QUEUE_IDX_NOTIF];\n\treturn READ_ONCE(notif_q->wr_ptr) != READ_ONCE(notif_q->rd_ptr);\n}\n\nstatic int iwl_mei_send_check_shared_area(struct mei_cl_device *cldev)\n{\n\tstruct iwl_mei *mei = mei_cldev_get_drvdata(cldev);\n\tstruct iwl_sap_me_msg_start msg = {\n\t\t.hdr.type = cpu_to_le32(SAP_ME_MSG_CHECK_SHARED_AREA),\n\t\t.hdr.seq_num = cpu_to_le32(atomic_inc_return(&mei->seq_no)),\n\t};\n\tint ret;\n\n\tlockdep_assert_held(&iwl_mei_mutex);\n\n\tif (mei->csa_throttled)\n\t\treturn 0;\n\n\ttrace_iwlmei_me_msg(&msg.hdr, true);\n\tret = mei_cldev_send(cldev, (void *)&msg, sizeof(msg));\n\tif (ret != sizeof(msg)) {\n\t\tdev_err(&cldev->dev,\n\t\t\t\"failed to send the SAP_ME_MSG_CHECK_SHARED_AREA message %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tmei->csa_throttled = true;\n\n\tschedule_delayed_work(&mei->csa_throttle_end_wk,\n\t\t\t      msecs_to_jiffies(100));\n\n\treturn 0;\n}\n\nstatic void iwl_mei_csa_throttle_end_wk(struct work_struct *wk)\n{\n\tstruct iwl_mei *mei =\n\t\tcontainer_of(wk, struct iwl_mei, csa_throttle_end_wk.work);\n\n\tmutex_lock(&iwl_mei_mutex);\n\n\tmei->csa_throttled = false;\n\n\tif (iwl_mei_host_to_me_data_pending(mei))\n\t\tiwl_mei_send_check_shared_area(mei->cldev);\n\n\tmutex_unlock(&iwl_mei_mutex);\n}\n\nstatic int iwl_mei_send_sap_msg_payload(struct mei_cl_device *cldev,\n\t\t\t\t\tstruct iwl_sap_hdr *hdr)\n{\n\tstruct iwl_mei *mei = mei_cldev_get_drvdata(cldev);\n\tstruct iwl_sap_q_ctrl_blk *notif_q;\n\tstruct iwl_sap_dir *dir;\n\tvoid *q_head;\n\tu32 q_sz;\n\tint ret;\n\n\tlockdep_assert_held(&iwl_mei_mutex);\n\n\tif (!mei->shared_mem.ctrl) {\n\t\tdev_err(&cldev->dev,\n\t\t\t\"No shared memory, can't send any SAP message\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!iwl_mei_is_connected()) {\n\t\tdev_err(&cldev->dev,\n\t\t\t\"Can't send a SAP message if we're not connected\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\thdr->seq_num = cpu_to_le32(atomic_inc_return(&mei->sap_seq_no));\n\tdev_dbg(&cldev->dev, \"Sending %d\\n\", hdr->type);\n\n\tdir = &mei->shared_mem.ctrl->dir[SAP_DIRECTION_HOST_TO_ME];\n\tnotif_q = &dir->q_ctrl_blk[SAP_QUEUE_IDX_NOTIF];\n\tq_head = mei->shared_mem.q_head[SAP_DIRECTION_HOST_TO_ME][SAP_QUEUE_IDX_NOTIF];\n\tq_sz = mei->shared_mem.q_size[SAP_DIRECTION_HOST_TO_ME][SAP_QUEUE_IDX_NOTIF];\n\tret = iwl_mei_write_cyclic_buf(q_head, notif_q, q_head, hdr, q_sz);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttrace_iwlmei_sap_cmd(hdr, true);\n\n\treturn iwl_mei_send_check_shared_area(cldev);\n}\n\nvoid iwl_mei_add_data_to_ring(struct sk_buff *skb, bool cb_tx)\n{\n\tstruct iwl_sap_q_ctrl_blk *notif_q;\n\tstruct iwl_sap_dir *dir;\n\tstruct iwl_mei *mei;\n\tsize_t room_in_buf;\n\tsize_t tx_sz;\n\tsize_t hdr_sz;\n\tu32 q_sz;\n\tu32 rd;\n\tu32 wr;\n\tu8 *q_head;\n\n\tif (!iwl_mei_global_cldev)\n\t\treturn;\n\n\tmei = mei_cldev_get_drvdata(iwl_mei_global_cldev);\n\n\t \n\tspin_lock_bh(&mei->data_q_lock);\n\n\tif (!iwl_mei_is_connected()) {\n\t\tspin_unlock_bh(&mei->data_q_lock);\n\t\treturn;\n\t}\n\n\t \n\tdir = &mei->shared_mem.ctrl->dir[SAP_DIRECTION_HOST_TO_ME];\n\tnotif_q = &dir->q_ctrl_blk[SAP_QUEUE_IDX_DATA];\n\tq_head = mei->shared_mem.q_head[SAP_DIRECTION_HOST_TO_ME][SAP_QUEUE_IDX_DATA];\n\tq_sz = mei->shared_mem.q_size[SAP_DIRECTION_HOST_TO_ME][SAP_QUEUE_IDX_DATA];\n\n\trd = le32_to_cpu(READ_ONCE(notif_q->rd_ptr));\n\twr = le32_to_cpu(READ_ONCE(notif_q->wr_ptr));\n\thdr_sz = cb_tx ? sizeof(struct iwl_sap_cb_data) :\n\t\t\t sizeof(struct iwl_sap_hdr);\n\ttx_sz = skb->len + hdr_sz;\n\n\tif (rd > q_sz || wr > q_sz) {\n\t\tdev_err(&mei->cldev->dev,\n\t\t\t\"can't write the data: pointers are past the end of the buffer\\n\");\n\t\tgoto out;\n\t}\n\n\troom_in_buf = wr >= rd ? q_sz - wr + rd : rd - wr;\n\n\t \n\tif (room_in_buf < tx_sz) {\n\t\tdev_err(&mei->cldev->dev,\n\t\t\t\"Not enough room in the buffer for this data\\n\");\n\t\tgoto out;\n\t}\n\n\tif (skb_headroom(skb) < hdr_sz) {\n\t\tdev_err(&mei->cldev->dev,\n\t\t\t\"Not enough headroom in the skb to write the SAP header\\n\");\n\t\tgoto out;\n\t}\n\n\tif (cb_tx) {\n\t\tstruct iwl_sap_cb_data *cb_hdr = skb_push(skb, sizeof(*cb_hdr));\n\n\t\tmemset(cb_hdr, 0, sizeof(*cb_hdr));\n\t\tcb_hdr->hdr.type = cpu_to_le16(SAP_MSG_CB_DATA_PACKET);\n\t\tcb_hdr->hdr.len = cpu_to_le16(skb->len - sizeof(cb_hdr->hdr));\n\t\tcb_hdr->hdr.seq_num = cpu_to_le32(atomic_inc_return(&mei->sap_seq_no));\n\t\tcb_hdr->to_me_filt_status = cpu_to_le32(BIT(CB_TX_DHCP_FILT_IDX));\n\t\tcb_hdr->data_len = cpu_to_le32(skb->len - sizeof(*cb_hdr));\n\t\ttrace_iwlmei_sap_data(skb, IWL_SAP_TX_DHCP);\n\t} else {\n\t\tstruct iwl_sap_hdr *hdr = skb_push(skb, sizeof(*hdr));\n\n\t\thdr->type = cpu_to_le16(SAP_MSG_DATA_PACKET);\n\t\thdr->len = cpu_to_le16(skb->len - sizeof(*hdr));\n\t\thdr->seq_num = cpu_to_le32(atomic_inc_return(&mei->sap_seq_no));\n\t\ttrace_iwlmei_sap_data(skb, IWL_SAP_TX_DATA_FROM_AIR);\n\t}\n\n\tif (wr + tx_sz <= q_sz) {\n\t\tskb_copy_bits(skb, 0, q_head + wr, tx_sz);\n\t} else {\n\t\tskb_copy_bits(skb, 0, q_head + wr, q_sz - wr);\n\t\tskb_copy_bits(skb, q_sz - wr, q_head, tx_sz - (q_sz - wr));\n\t}\n\n\tWRITE_ONCE(notif_q->wr_ptr, cpu_to_le32((wr + tx_sz) % q_sz));\n\nout:\n\tspin_unlock_bh(&mei->data_q_lock);\n}\n\nstatic int\niwl_mei_send_sap_msg(struct mei_cl_device *cldev, u16 type)\n{\n\tstruct iwl_sap_hdr msg = {\n\t\t.type = cpu_to_le16(type),\n\t};\n\n\treturn iwl_mei_send_sap_msg_payload(cldev, &msg);\n}\n\nstatic void iwl_mei_send_csa_msg_wk(struct work_struct *wk)\n{\n\tstruct iwl_mei *mei =\n\t\tcontainer_of(wk, struct iwl_mei, send_csa_msg_wk);\n\n\tif (!iwl_mei_is_connected())\n\t\treturn;\n\n\tmutex_lock(&iwl_mei_mutex);\n\n\tiwl_mei_send_check_shared_area(mei->cldev);\n\n\tmutex_unlock(&iwl_mei_mutex);\n}\n\n \nstatic rx_handler_result_t iwl_mei_rx_handler(struct sk_buff **pskb)\n{\n\tstruct sk_buff *skb = *pskb;\n\tstruct iwl_mei *mei =\n\t\trcu_dereference(skb->dev->rx_handler_data);\n\tstruct iwl_mei_filters *filters = rcu_dereference(mei->filters);\n\tbool rx_for_csme = false;\n\trx_handler_result_t res;\n\n\t \n\tif (!iwl_mei_is_connected()) {\n\t\tdev_err(&mei->cldev->dev,\n\t\t\t\"Got an Rx packet, but we're not connected to SAP?\\n\");\n\t\treturn RX_HANDLER_PASS;\n\t}\n\n\tif (filters)\n\t\tres = iwl_mei_rx_filter(skb, &filters->filters, &rx_for_csme);\n\telse\n\t\tres = RX_HANDLER_PASS;\n\n\t \n\tif (rx_for_csme)\n\t\tschedule_work(&mei->send_csa_msg_wk);\n\n\tif (res != RX_HANDLER_PASS) {\n\t\ttrace_iwlmei_sap_data(skb, IWL_SAP_RX_DATA_DROPPED_FROM_AIR);\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn res;\n}\n\nstatic void iwl_mei_netdev_work(struct work_struct *wk)\n{\n\tstruct iwl_mei *mei =\n\t\tcontainer_of(wk, struct iwl_mei, netdev_work);\n\tstruct net_device *netdev;\n\n\t \n\trtnl_lock();\n\tmutex_lock(&iwl_mei_mutex);\n\n\tnetdev = rcu_dereference_protected(iwl_mei_cache.netdev,\n\t\t\t\t\t   lockdep_is_held(&iwl_mei_mutex));\n\tif (netdev) {\n\t\tif (mei->amt_enabled)\n\t\t\tnetdev_rx_handler_register(netdev, iwl_mei_rx_handler,\n\t\t\t\t\t\t   mei);\n\t\telse\n\t\t\tnetdev_rx_handler_unregister(netdev);\n\t}\n\n\tmutex_unlock(&iwl_mei_mutex);\n\trtnl_unlock();\n}\n\nstatic void\niwl_mei_handle_rx_start_ok(struct mei_cl_device *cldev,\n\t\t\t   const struct iwl_sap_me_msg_start_ok *rsp,\n\t\t\t   ssize_t len)\n{\n\tif (len != sizeof(*rsp)) {\n\t\tdev_err(&cldev->dev,\n\t\t\t\"got invalid SAP_ME_MSG_START_OK from CSME firmware\\n\");\n\t\tdev_err(&cldev->dev,\n\t\t\t\"size is incorrect: %zd instead of %zu\\n\",\n\t\t\tlen, sizeof(*rsp));\n\t\treturn;\n\t}\n\n\tif (rsp->supported_version != SAP_VERSION) {\n\t\tdev_err(&cldev->dev,\n\t\t\t\"didn't get the expected version: got %d\\n\",\n\t\t\trsp->supported_version);\n\t\treturn;\n\t}\n\n\tmutex_lock(&iwl_mei_mutex);\n\tset_bit(IWL_MEI_STATUS_SAP_CONNECTED, &iwl_mei_status);\n\t \n\tmutex_unlock(&iwl_mei_mutex);\n}\n\nstatic void iwl_mei_handle_csme_filters(struct mei_cl_device *cldev,\n\t\t\t\t\tconst struct iwl_sap_csme_filters *filters)\n{\n\tstruct iwl_mei *mei = mei_cldev_get_drvdata(iwl_mei_global_cldev);\n\tstruct iwl_mei_filters *new_filters;\n\tstruct iwl_mei_filters *old_filters;\n\n\told_filters =\n\t\trcu_dereference_protected(mei->filters,\n\t\t\t\t\t  lockdep_is_held(&iwl_mei_mutex));\n\n\tnew_filters = kzalloc(sizeof(*new_filters), GFP_KERNEL);\n\tif (!new_filters)\n\t\treturn;\n\n\t \n\tnew_filters->filters = filters->filters;\n\n\trcu_assign_pointer(mei->filters, new_filters);\n\n\tif (old_filters)\n\t\tkfree_rcu(old_filters, rcu_head);\n}\n\nstatic void\niwl_mei_handle_conn_status(struct mei_cl_device *cldev,\n\t\t\t   const struct iwl_sap_notif_conn_status *status)\n{\n\tstruct iwl_mei *mei = mei_cldev_get_drvdata(cldev);\n\tstruct iwl_mei_conn_info conn_info = {\n\t\t.lp_state = le32_to_cpu(status->link_prot_state),\n\t\t.ssid_len = le32_to_cpu(status->conn_info.ssid_len),\n\t\t.channel = status->conn_info.channel,\n\t\t.band = status->conn_info.band,\n\t\t.auth_mode = le32_to_cpu(status->conn_info.auth_mode),\n\t\t.pairwise_cipher = le32_to_cpu(status->conn_info.pairwise_cipher),\n\t};\n\n\tif (!iwl_mei_cache.ops ||\n\t    conn_info.ssid_len > ARRAY_SIZE(conn_info.ssid))\n\t\treturn;\n\n\tmemcpy(conn_info.ssid, status->conn_info.ssid, conn_info.ssid_len);\n\tether_addr_copy(conn_info.bssid, status->conn_info.bssid);\n\n\tiwl_mei_cache.ops->me_conn_status(iwl_mei_cache.priv, &conn_info);\n\n\tmei->link_prot_state = status->link_prot_state;\n\n\t \n\tif (mei->got_ownership)\n\t\tiwl_mei_cache.ops->roaming_forbidden(iwl_mei_cache.priv,\n\t\t\t\t\t\t     status->link_prot_state);\n\telse\n\t\tiwl_mei_cache.ops->rfkill(iwl_mei_cache.priv,\n\t\t\t\t\t  status->link_prot_state, false);\n}\n\nstatic void iwl_mei_set_init_conf(struct iwl_mei *mei)\n{\n\tstruct iwl_sap_notif_host_link_up link_msg = {\n\t\t.hdr.type = cpu_to_le16(SAP_MSG_NOTIF_HOST_LINK_UP),\n\t\t.hdr.len = cpu_to_le16(sizeof(link_msg) - sizeof(link_msg.hdr)),\n\t};\n\tstruct iwl_sap_notif_country_code mcc_msg = {\n\t\t.hdr.type = cpu_to_le16(SAP_MSG_NOTIF_COUNTRY_CODE),\n\t\t.hdr.len = cpu_to_le16(sizeof(mcc_msg) - sizeof(mcc_msg.hdr)),\n\t\t.mcc = cpu_to_le16(iwl_mei_cache.mcc),\n\t};\n\tstruct iwl_sap_notif_sar_limits sar_msg = {\n\t\t.hdr.type = cpu_to_le16(SAP_MSG_NOTIF_SAR_LIMITS),\n\t\t.hdr.len = cpu_to_le16(sizeof(sar_msg) - sizeof(sar_msg.hdr)),\n\t};\n\tstruct iwl_sap_notif_host_nic_info nic_info_msg = {\n\t\t.hdr.type = cpu_to_le16(SAP_MSG_NOTIF_NIC_INFO),\n\t\t.hdr.len = cpu_to_le16(sizeof(nic_info_msg) - sizeof(nic_info_msg.hdr)),\n\t};\n\tstruct iwl_sap_msg_dw rfkill_msg = {\n\t\t.hdr.type = cpu_to_le16(SAP_MSG_NOTIF_RADIO_STATE),\n\t\t.hdr.len = cpu_to_le16(sizeof(rfkill_msg) - sizeof(rfkill_msg.hdr)),\n\t\t.val = cpu_to_le32(iwl_mei_cache.rf_kill),\n\t};\n\n\t \n\tif (iwl_mei_cache.ops) {\n\t\tiwl_mei_send_sap_msg(mei->cldev,\n\t\t\t\t     SAP_MSG_NOTIF_WIFIDR_UP);\n\t\tiwl_mei_cache.ops->sap_connected(iwl_mei_cache.priv);\n\t}\n\n\tiwl_mei_send_sap_msg(mei->cldev, SAP_MSG_NOTIF_WHO_OWNS_NIC);\n\n\tif (iwl_mei_cache.conn_info) {\n\t\tlink_msg.conn_info = *iwl_mei_cache.conn_info;\n\t\tiwl_mei_send_sap_msg_payload(mei->cldev, &link_msg.hdr);\n\t}\n\n\tiwl_mei_send_sap_msg_payload(mei->cldev, &mcc_msg.hdr);\n\n\tif (iwl_mei_cache.power_limit) {\n\t\tmemcpy(sar_msg.sar_chain_info_table, iwl_mei_cache.power_limit,\n\t\t       sizeof(sar_msg.sar_chain_info_table));\n\t\tiwl_mei_send_sap_msg_payload(mei->cldev, &sar_msg.hdr);\n\t}\n\n\tif (is_valid_ether_addr(iwl_mei_cache.mac_address)) {\n\t\tether_addr_copy(nic_info_msg.mac_address,\n\t\t\t\tiwl_mei_cache.mac_address);\n\t\tether_addr_copy(nic_info_msg.nvm_address,\n\t\t\t\tiwl_mei_cache.nvm_address);\n\t\tiwl_mei_send_sap_msg_payload(mei->cldev, &nic_info_msg.hdr);\n\t}\n\n\tiwl_mei_send_sap_msg_payload(mei->cldev, &rfkill_msg.hdr);\n}\n\nstatic void iwl_mei_handle_amt_state(struct mei_cl_device *cldev,\n\t\t\t\t     const struct iwl_sap_msg_dw *dw)\n{\n\tstruct iwl_mei *mei = mei_cldev_get_drvdata(cldev);\n\n\tmutex_lock(&iwl_mei_mutex);\n\n\tif (mei->amt_enabled == !!le32_to_cpu(dw->val))\n\t\tgoto out;\n\n\tmei->amt_enabled = dw->val;\n\n\tif (mei->amt_enabled)\n\t\tiwl_mei_set_init_conf(mei);\n\telse if (iwl_mei_cache.ops)\n\t\tiwl_mei_cache.ops->rfkill(iwl_mei_cache.priv, false, false);\n\n\tschedule_work(&mei->netdev_work);\n\nout:\n\tmutex_unlock(&iwl_mei_mutex);\n}\n\nstatic void iwl_mei_handle_nic_owner(struct mei_cl_device *cldev,\n\t\t\t\t     const struct iwl_sap_msg_dw *dw)\n{\n\tstruct iwl_mei *mei = mei_cldev_get_drvdata(cldev);\n\n\tmei->got_ownership = dw->val != cpu_to_le32(SAP_NIC_OWNER_ME);\n}\n\nstatic void iwl_mei_handle_can_release_ownership(struct mei_cl_device *cldev,\n\t\t\t\t\t\t const void *payload)\n{\n\t \n\tif (iwl_mei_cache.ops)\n\t\tiwl_mei_send_sap_msg(cldev,\n\t\t\t\t     SAP_MSG_NOTIF_HOST_ASKS_FOR_NIC_OWNERSHIP);\n}\n\nstatic void iwl_mei_handle_csme_taking_ownership(struct mei_cl_device *cldev,\n\t\t\t\t\t\t const void *payload)\n{\n\tstruct iwl_mei *mei = mei_cldev_get_drvdata(cldev);\n\n\tdev_info(&cldev->dev, \"CSME takes ownership\\n\");\n\n\tmei->got_ownership = false;\n\n\tif (iwl_mei_cache.ops && !mei->device_down) {\n\t\t \n\t\tmei->csme_taking_ownership = true;\n\n\t\tiwl_mei_cache.ops->rfkill(iwl_mei_cache.priv, true, true);\n\t} else {\n\t\tiwl_mei_send_sap_msg(cldev,\n\t\t\t\t     SAP_MSG_NOTIF_CSME_OWNERSHIP_CONFIRMED);\n\t\tschedule_delayed_work(&mei->ownership_dwork,\n\t\t\t\t      MEI_OWNERSHIP_RETAKE_TIMEOUT_MS);\n\t}\n}\n\nstatic void iwl_mei_handle_nvm(struct mei_cl_device *cldev,\n\t\t\t       const struct iwl_sap_nvm *sap_nvm)\n{\n\tstruct iwl_mei *mei = mei_cldev_get_drvdata(cldev);\n\tconst struct iwl_mei_nvm *mei_nvm = (const void *)sap_nvm;\n\tint i;\n\n\tkfree(mei->nvm);\n\tmei->nvm = kzalloc(sizeof(*mei_nvm), GFP_KERNEL);\n\tif (!mei->nvm)\n\t\treturn;\n\n\tether_addr_copy(mei->nvm->hw_addr, sap_nvm->hw_addr);\n\tmei->nvm->n_hw_addrs = sap_nvm->n_hw_addrs;\n\tmei->nvm->radio_cfg = le32_to_cpu(sap_nvm->radio_cfg);\n\tmei->nvm->caps = le32_to_cpu(sap_nvm->caps);\n\tmei->nvm->nvm_version = le32_to_cpu(sap_nvm->nvm_version);\n\n\tfor (i = 0; i < ARRAY_SIZE(mei->nvm->channels); i++)\n\t\tmei->nvm->channels[i] = le32_to_cpu(sap_nvm->channels[i]);\n\n\twake_up_all(&mei->get_nvm_wq);\n}\n\nstatic void iwl_mei_handle_rx_host_own_req(struct mei_cl_device *cldev,\n\t\t\t\t\t   const struct iwl_sap_msg_dw *dw)\n{\n\tstruct iwl_mei *mei = mei_cldev_get_drvdata(cldev);\n\n\t \n\tif (!dw->val) {\n\t\tdev_info(&cldev->dev, \"Ownership req denied\\n\");\n\t\treturn;\n\t}\n\n\tmei->got_ownership = true;\n\twake_up_all(&mei->get_ownership_wq);\n\n\tiwl_mei_send_sap_msg(cldev,\n\t\t\t     SAP_MSG_NOTIF_HOST_OWNERSHIP_CONFIRMED);\n\n\t \n\tif (iwl_mei_cache.ops)\n\t\tiwl_mei_cache.ops->rfkill(iwl_mei_cache.priv, false, false);\n}\n\nstatic void iwl_mei_handle_pldr_ack(struct mei_cl_device *cldev,\n\t\t\t\t    const struct iwl_sap_pldr_ack_data *ack)\n{\n\tstruct iwl_mei *mei = mei_cldev_get_drvdata(cldev);\n\n\tmei->pldr_active = le32_to_cpu(ack->status) == SAP_PLDR_STATUS_SUCCESS;\n\twake_up_all(&mei->pldr_wq);\n}\n\nstatic void iwl_mei_handle_ping(struct mei_cl_device *cldev,\n\t\t\t\tconst struct iwl_sap_hdr *hdr)\n{\n\tiwl_mei_send_sap_msg(cldev, SAP_MSG_NOTIF_PONG);\n}\n\nstatic void iwl_mei_handle_sap_msg(struct mei_cl_device *cldev,\n\t\t\t\t   const struct iwl_sap_hdr *hdr)\n{\n\tu16 len = le16_to_cpu(hdr->len) + sizeof(*hdr);\n\tu16 type = le16_to_cpu(hdr->type);\n\n\tdev_dbg(&cldev->dev,\n\t\t\"Got a new SAP message: type %d, len %d, seq %d\\n\",\n\t\tle16_to_cpu(hdr->type), len,\n\t\tle32_to_cpu(hdr->seq_num));\n\n#define SAP_MSG_HANDLER(_cmd, _handler, _sz)\t\t\t\t\\\n\tcase SAP_MSG_NOTIF_ ## _cmd:\t\t\t\t\t\\\n\t\tif (len < _sz) {\t\t\t\t\t\\\n\t\t\tdev_err(&cldev->dev,\t\t\t\t\\\n\t\t\t\t\"Bad size for %d: %u < %u\\n\",\t\t\\\n\t\t\t\tle16_to_cpu(hdr->type),\t\t\t\\\n\t\t\t\t(unsigned int)len,\t\t\t\\\n\t\t\t\t(unsigned int)_sz);\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tmutex_lock(&iwl_mei_mutex);\t\t\t\t\\\n\t\t_handler(cldev, (const void *)hdr);\t\t\t\\\n\t\tmutex_unlock(&iwl_mei_mutex);\t\t\t\t\\\n\t\tbreak\n\n#define SAP_MSG_HANDLER_NO_LOCK(_cmd, _handler, _sz)\t\t\t\\\n\tcase SAP_MSG_NOTIF_ ## _cmd:\t\t\t\t\t\\\n\t\tif (len < _sz) {\t\t\t\t\t\\\n\t\t\tdev_err(&cldev->dev,\t\t\t\t\\\n\t\t\t\t\"Bad size for %d: %u < %u\\n\",\t\t\\\n\t\t\t\tle16_to_cpu(hdr->type),\t\t\t\\\n\t\t\t\t(unsigned int)len,\t\t\t\\\n\t\t\t\t(unsigned int)_sz);\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\t_handler(cldev, (const void *)hdr);\t\t\t\\\n\t\tbreak\n\n#define SAP_MSG_HANDLER_NO_HANDLER(_cmd, _sz)\t\t\t\t\\\n\tcase SAP_MSG_NOTIF_ ## _cmd:\t\t\t\t\t\\\n\t\tif (len < _sz) {\t\t\t\t\t\\\n\t\t\tdev_err(&cldev->dev,\t\t\t\t\\\n\t\t\t\t\"Bad size for %d: %u < %u\\n\",\t\t\\\n\t\t\t\tle16_to_cpu(hdr->type),\t\t\t\\\n\t\t\t\t(unsigned int)len,\t\t\t\\\n\t\t\t\t(unsigned int)_sz);\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tbreak\n\n\tswitch (type) {\n\tSAP_MSG_HANDLER(PING, iwl_mei_handle_ping, 0);\n\tSAP_MSG_HANDLER(CSME_FILTERS,\n\t\t\tiwl_mei_handle_csme_filters,\n\t\t\tsizeof(struct iwl_sap_csme_filters));\n\tSAP_MSG_HANDLER(CSME_CONN_STATUS,\n\t\t\tiwl_mei_handle_conn_status,\n\t\t\tsizeof(struct iwl_sap_notif_conn_status));\n\tSAP_MSG_HANDLER_NO_LOCK(AMT_STATE,\n\t\t\t\tiwl_mei_handle_amt_state,\n\t\t\t\tsizeof(struct iwl_sap_msg_dw));\n\tSAP_MSG_HANDLER_NO_HANDLER(PONG, 0);\n\tSAP_MSG_HANDLER(NVM, iwl_mei_handle_nvm,\n\t\t\tsizeof(struct iwl_sap_nvm));\n\tSAP_MSG_HANDLER(CSME_REPLY_TO_HOST_OWNERSHIP_REQ,\n\t\t\tiwl_mei_handle_rx_host_own_req,\n\t\t\tsizeof(struct iwl_sap_msg_dw));\n\tSAP_MSG_HANDLER(NIC_OWNER, iwl_mei_handle_nic_owner,\n\t\t\tsizeof(struct iwl_sap_msg_dw));\n\tSAP_MSG_HANDLER(CSME_CAN_RELEASE_OWNERSHIP,\n\t\t\tiwl_mei_handle_can_release_ownership, 0);\n\tSAP_MSG_HANDLER(CSME_TAKING_OWNERSHIP,\n\t\t\tiwl_mei_handle_csme_taking_ownership, 0);\n\tSAP_MSG_HANDLER(PLDR_ACK, iwl_mei_handle_pldr_ack,\n\t\t\tsizeof(struct iwl_sap_pldr_ack_data));\n\tdefault:\n\t \n\tdev_dbg(&cldev->dev, \"Unsupported message: type %d, len %d\\n\",\n\t\tle16_to_cpu(hdr->type), len);\n\t}\n\n#undef SAP_MSG_HANDLER\n#undef SAP_MSG_HANDLER_NO_LOCK\n}\n\nstatic void iwl_mei_read_from_q(const u8 *q_head, u32 q_sz,\n\t\t\t\tu32 *_rd, u32 wr,\n\t\t\t\tvoid *_buf, u32 len)\n{\n\tu8 *buf = _buf;\n\tu32 rd = *_rd;\n\n\tif (rd + len <= q_sz) {\n\t\tmemcpy(buf, q_head + rd, len);\n\t\trd += len;\n\t} else {\n\t\tmemcpy(buf, q_head + rd, q_sz - rd);\n\t\tmemcpy(buf + q_sz - rd, q_head, len - (q_sz - rd));\n\t\trd = len - (q_sz - rd);\n\t}\n\n\t*_rd = rd;\n}\n\n#define QOS_HDR_IV_SNAP_LEN (sizeof(struct ieee80211_qos_hdr) +      \\\n\t\t\t     IEEE80211_TKIP_IV_LEN +                 \\\n\t\t\t     sizeof(rfc1042_header) + ETH_TLEN)\n\nstatic void iwl_mei_handle_sap_data(struct mei_cl_device *cldev,\n\t\t\t\t    const u8 *q_head, u32 q_sz,\n\t\t\t\t    u32 rd, u32 wr, ssize_t valid_rx_sz,\n\t\t\t\t    struct sk_buff_head *tx_skbs)\n{\n\tstruct iwl_sap_hdr hdr;\n\tstruct net_device *netdev =\n\t\trcu_dereference_protected(iwl_mei_cache.netdev,\n\t\t\t\t\t  lockdep_is_held(&iwl_mei_mutex));\n\n\tif (!netdev)\n\t\treturn;\n\n\twhile (valid_rx_sz >= sizeof(hdr)) {\n\t\tstruct ethhdr *ethhdr;\n\t\tunsigned char *data;\n\t\tstruct sk_buff *skb;\n\t\tu16 len;\n\n\t\tiwl_mei_read_from_q(q_head, q_sz, &rd, wr, &hdr, sizeof(hdr));\n\t\tvalid_rx_sz -= sizeof(hdr);\n\t\tlen = le16_to_cpu(hdr.len);\n\n\t\tif (valid_rx_sz < len) {\n\t\t\tdev_err(&cldev->dev,\n\t\t\t\t\"Data queue is corrupted: valid data len %zd, len %d\\n\",\n\t\t\t\tvalid_rx_sz, len);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (len < sizeof(*ethhdr)) {\n\t\t\tdev_err(&cldev->dev,\n\t\t\t\t\"Data len is smaller than an ethernet header? len = %d\\n\",\n\t\t\t\tlen);\n\t\t}\n\n\t\tvalid_rx_sz -= len;\n\n\t\tif (le16_to_cpu(hdr.type) != SAP_MSG_DATA_PACKET) {\n\t\t\tdev_err(&cldev->dev, \"Unsupported Rx data: type %d, len %d\\n\",\n\t\t\t\tle16_to_cpu(hdr.type), len);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tskb = netdev_alloc_skb(netdev, len + QOS_HDR_IV_SNAP_LEN);\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\tskb_reserve(skb, QOS_HDR_IV_SNAP_LEN);\n\t\tethhdr = skb_push(skb, sizeof(*ethhdr));\n\n\t\tiwl_mei_read_from_q(q_head, q_sz, &rd, wr,\n\t\t\t\t    ethhdr, sizeof(*ethhdr));\n\t\tlen -= sizeof(*ethhdr);\n\n\t\tskb_reset_mac_header(skb);\n\t\tskb_reset_network_header(skb);\n\t\tskb->protocol = ethhdr->h_proto;\n\n\t\tdata = skb_put(skb, len);\n\t\tiwl_mei_read_from_q(q_head, q_sz, &rd, wr, data, len);\n\n\t\t \n\t\t__skb_queue_tail(tx_skbs, skb);\n\t}\n}\n\nstatic void iwl_mei_handle_sap_rx_cmd(struct mei_cl_device *cldev,\n\t\t\t\t      const u8 *q_head, u32 q_sz,\n\t\t\t\t      u32 rd, u32 wr, ssize_t valid_rx_sz)\n{\n\tstruct page *p = alloc_page(GFP_KERNEL);\n\tstruct iwl_sap_hdr *hdr;\n\n\tif (!p)\n\t\treturn;\n\n\thdr = page_address(p);\n\n\twhile (valid_rx_sz >= sizeof(*hdr)) {\n\t\tu16 len;\n\n\t\tiwl_mei_read_from_q(q_head, q_sz, &rd, wr, hdr, sizeof(*hdr));\n\t\tvalid_rx_sz -= sizeof(*hdr);\n\t\tlen = le16_to_cpu(hdr->len);\n\n\t\tif (valid_rx_sz < len)\n\t\t\tbreak;\n\n\t\tiwl_mei_read_from_q(q_head, q_sz, &rd, wr, hdr + 1, len);\n\n\t\ttrace_iwlmei_sap_cmd(hdr, false);\n\t\tiwl_mei_handle_sap_msg(cldev, hdr);\n\t\tvalid_rx_sz -= len;\n\t}\n\n\t \n\tif (valid_rx_sz)\n\t\tdev_err(&cldev->dev,\n\t\t\t\"More data in the buffer although we read it all\\n\");\n\n\t__free_page(p);\n}\n\nstatic void iwl_mei_handle_sap_rx(struct mei_cl_device *cldev,\n\t\t\t\t  struct iwl_sap_q_ctrl_blk *notif_q,\n\t\t\t\t  const u8 *q_head,\n\t\t\t\t  struct sk_buff_head *skbs,\n\t\t\t\t  u32 q_sz)\n{\n\tu32 rd = le32_to_cpu(READ_ONCE(notif_q->rd_ptr));\n\tu32 wr = le32_to_cpu(READ_ONCE(notif_q->wr_ptr));\n\tssize_t valid_rx_sz;\n\n\tif (rd > q_sz || wr > q_sz) {\n\t\tdev_err(&cldev->dev,\n\t\t\t\"Pointers are past the buffer limit\\n\");\n\t\treturn;\n\t}\n\n\tif (rd == wr)\n\t\treturn;\n\n\tvalid_rx_sz = wr > rd ? wr - rd : q_sz - rd + wr;\n\n\tif (skbs)\n\t\tiwl_mei_handle_sap_data(cldev, q_head, q_sz, rd, wr,\n\t\t\t\t\tvalid_rx_sz, skbs);\n\telse\n\t\tiwl_mei_handle_sap_rx_cmd(cldev, q_head, q_sz, rd, wr,\n\t\t\t\t\t  valid_rx_sz);\n\n\t \n\tWRITE_ONCE(notif_q->rd_ptr, cpu_to_le32(wr));\n}\n\nstatic void iwl_mei_handle_check_shared_area(struct mei_cl_device *cldev)\n{\n\tstruct iwl_mei *mei = mei_cldev_get_drvdata(cldev);\n\tstruct iwl_sap_q_ctrl_blk *notif_q;\n\tstruct sk_buff_head tx_skbs;\n\tstruct iwl_sap_dir *dir;\n\tvoid *q_head;\n\tu32 q_sz;\n\n\tif (!mei->shared_mem.ctrl)\n\t\treturn;\n\n\tdir = &mei->shared_mem.ctrl->dir[SAP_DIRECTION_ME_TO_HOST];\n\tnotif_q = &dir->q_ctrl_blk[SAP_QUEUE_IDX_NOTIF];\n\tq_head = mei->shared_mem.q_head[SAP_DIRECTION_ME_TO_HOST][SAP_QUEUE_IDX_NOTIF];\n\tq_sz = mei->shared_mem.q_size[SAP_DIRECTION_ME_TO_HOST][SAP_QUEUE_IDX_NOTIF];\n\n\t \n\tiwl_mei_handle_sap_rx(cldev, notif_q, q_head, NULL, q_sz);\n\n\tmutex_lock(&iwl_mei_mutex);\n\tdir = &mei->shared_mem.ctrl->dir[SAP_DIRECTION_ME_TO_HOST];\n\tnotif_q = &dir->q_ctrl_blk[SAP_QUEUE_IDX_DATA];\n\tq_head = mei->shared_mem.q_head[SAP_DIRECTION_ME_TO_HOST][SAP_QUEUE_IDX_DATA];\n\tq_sz = mei->shared_mem.q_size[SAP_DIRECTION_ME_TO_HOST][SAP_QUEUE_IDX_DATA];\n\n\t__skb_queue_head_init(&tx_skbs);\n\n\tiwl_mei_handle_sap_rx(cldev, notif_q, q_head, &tx_skbs, q_sz);\n\n\tif (skb_queue_empty(&tx_skbs)) {\n\t\tmutex_unlock(&iwl_mei_mutex);\n\t\treturn;\n\t}\n\n\t \n\trcu_read_lock();\n\n\tmutex_unlock(&iwl_mei_mutex);\n\n\tif (!rcu_access_pointer(iwl_mei_cache.netdev)) {\n\t\tdev_err(&cldev->dev, \"Can't Tx without a netdev\\n\");\n\t\tskb_queue_purge(&tx_skbs);\n\t\tgoto out;\n\t}\n\n\twhile (!skb_queue_empty(&tx_skbs)) {\n\t\tstruct sk_buff *skb = __skb_dequeue(&tx_skbs);\n\n\t\ttrace_iwlmei_sap_data(skb, IWL_SAP_RX_DATA_TO_AIR);\n\t\tdev_queue_xmit(skb);\n\t}\n\nout:\n\trcu_read_unlock();\n}\n\nstatic void iwl_mei_rx(struct mei_cl_device *cldev)\n{\n\tstruct iwl_sap_me_msg_hdr *hdr;\n\tu8 msg[100];\n\tssize_t ret;\n\n\tret = mei_cldev_recv(cldev, (u8 *)&msg, sizeof(msg));\n\tif (ret < 0) {\n\t\tdev_err(&cldev->dev, \"failed to receive data: %zd\\n\", ret);\n\t\treturn;\n\t}\n\n\tif (ret == 0) {\n\t\tdev_err(&cldev->dev, \"got an empty response\\n\");\n\t\treturn;\n\t}\n\n\thdr = (void *)msg;\n\ttrace_iwlmei_me_msg(hdr, false);\n\n\tswitch (le32_to_cpu(hdr->type)) {\n\tcase SAP_ME_MSG_START_OK:\n\t\tBUILD_BUG_ON(sizeof(struct iwl_sap_me_msg_start_ok) >\n\t\t\t     sizeof(msg));\n\n\t\tiwl_mei_handle_rx_start_ok(cldev, (void *)msg, ret);\n\t\tbreak;\n\tcase SAP_ME_MSG_CHECK_SHARED_AREA:\n\t\tiwl_mei_handle_check_shared_area(cldev);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&cldev->dev, \"got a RX notification: %d\\n\",\n\t\t\tle32_to_cpu(hdr->type));\n\t\tbreak;\n\t}\n}\n\nstatic int iwl_mei_send_start(struct mei_cl_device *cldev)\n{\n\tstruct iwl_mei *mei = mei_cldev_get_drvdata(cldev);\n\tstruct iwl_sap_me_msg_start msg = {\n\t\t.hdr.type = cpu_to_le32(SAP_ME_MSG_START),\n\t\t.hdr.seq_num = cpu_to_le32(atomic_inc_return(&mei->seq_no)),\n\t\t.hdr.len = cpu_to_le32(sizeof(msg)),\n\t\t.supported_versions[0] = SAP_VERSION,\n\t\t.init_data_seq_num = cpu_to_le16(0x100),\n\t\t.init_notif_seq_num = cpu_to_le16(0x800),\n\t};\n\tint ret;\n\n\ttrace_iwlmei_me_msg(&msg.hdr, true);\n\tret = mei_cldev_send(cldev, (void *)&msg, sizeof(msg));\n\tif (ret != sizeof(msg)) {\n\t\tdev_err(&cldev->dev,\n\t\t\t\"failed to send the SAP_ME_MSG_START message %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int iwl_mei_enable(struct mei_cl_device *cldev)\n{\n\tint ret;\n\n\tret = mei_cldev_enable(cldev);\n\tif (ret < 0) {\n\t\tdev_err(&cldev->dev, \"failed to enable the device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = mei_cldev_register_rx_cb(cldev, iwl_mei_rx);\n\tif (ret) {\n\t\tdev_err(&cldev->dev,\n\t\t\t\"failed to register to the rx cb: %d\\n\", ret);\n\t\tmei_cldev_disable(cldev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstruct iwl_mei_nvm *iwl_mei_get_nvm(void)\n{\n\tstruct iwl_mei_nvm *nvm = NULL;\n\tstruct iwl_mei *mei;\n\tint ret;\n\n\tmutex_lock(&iwl_mei_mutex);\n\n\tif (!iwl_mei_is_connected())\n\t\tgoto out;\n\n\tmei = mei_cldev_get_drvdata(iwl_mei_global_cldev);\n\n\tif (!mei)\n\t\tgoto out;\n\n\tret = iwl_mei_send_sap_msg(iwl_mei_global_cldev,\n\t\t\t\t   SAP_MSG_NOTIF_GET_NVM);\n\tif (ret)\n\t\tgoto out;\n\n\tmutex_unlock(&iwl_mei_mutex);\n\n\tret = wait_event_timeout(mei->get_nvm_wq, mei->nvm, 2 * HZ);\n\tif (!ret)\n\t\treturn NULL;\n\n\tmutex_lock(&iwl_mei_mutex);\n\n\tif (!iwl_mei_is_connected())\n\t\tgoto out;\n\n\tmei = mei_cldev_get_drvdata(iwl_mei_global_cldev);\n\n\tif (!mei)\n\t\tgoto out;\n\n\tif (mei->nvm)\n\t\tnvm = kmemdup(mei->nvm, sizeof(*mei->nvm), GFP_KERNEL);\n\nout:\n\tmutex_unlock(&iwl_mei_mutex);\n\treturn nvm;\n}\nEXPORT_SYMBOL_GPL(iwl_mei_get_nvm);\n\n#define IWL_MEI_PLDR_NUM_RETRIES\t3\n\nint iwl_mei_pldr_req(void)\n{\n\tstruct iwl_mei *mei;\n\tint ret;\n\tstruct iwl_sap_pldr_data msg = {\n\t\t.hdr.type = cpu_to_le16(SAP_MSG_NOTIF_PLDR),\n\t\t.hdr.len = cpu_to_le16(sizeof(msg) - sizeof(msg.hdr)),\n\t};\n\tint i;\n\n\tmutex_lock(&iwl_mei_mutex);\n\n\t \n\tif (!iwl_mei_is_connected()) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tmei = mei_cldev_get_drvdata(iwl_mei_global_cldev);\n\n\tif (!mei) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (!mei->amt_enabled) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < IWL_MEI_PLDR_NUM_RETRIES; i++) {\n\t\tret = iwl_mei_send_sap_msg_payload(mei->cldev, &msg.hdr);\n\t\tmutex_unlock(&iwl_mei_mutex);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = wait_event_timeout(mei->pldr_wq, mei->pldr_active, HZ / 2);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t \n\t\tmutex_lock(&iwl_mei_mutex);\n\t}\n\n\tif (ret)\n\t\treturn 0;\n\n\tret = -ETIMEDOUT;\nout:\n\tmutex_unlock(&iwl_mei_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(iwl_mei_pldr_req);\n\nint iwl_mei_get_ownership(void)\n{\n\tstruct iwl_mei *mei;\n\tint ret;\n\n\tmutex_lock(&iwl_mei_mutex);\n\n\t \n\tif (!iwl_mei_is_connected()) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tmei = mei_cldev_get_drvdata(iwl_mei_global_cldev);\n\n\tif (!mei) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (!mei->amt_enabled) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (mei->got_ownership) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = iwl_mei_send_sap_msg(mei->cldev,\n\t\t\t\t   SAP_MSG_NOTIF_HOST_ASKS_FOR_NIC_OWNERSHIP);\n\tif (ret)\n\t\tgoto out;\n\n\tmutex_unlock(&iwl_mei_mutex);\n\n\tret = wait_event_timeout(mei->get_ownership_wq,\n\t\t\t\t mei->got_ownership, HZ / 2);\n\tif (!ret) {\n\t\tschedule_delayed_work(&mei->ownership_dwork,\n\t\t\t\t      MEI_OWNERSHIP_RETAKE_TIMEOUT_MS);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\nout:\n\tmutex_unlock(&iwl_mei_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(iwl_mei_get_ownership);\n\nvoid iwl_mei_alive_notif(bool success)\n{\n\tstruct iwl_mei *mei;\n\tstruct iwl_sap_pldr_end_data msg = {\n\t\t.hdr.type = cpu_to_le16(SAP_MSG_NOTIF_PLDR_END),\n\t\t.hdr.len = cpu_to_le16(sizeof(msg) - sizeof(msg.hdr)),\n\t\t.status = success ? cpu_to_le32(SAP_PLDR_STATUS_SUCCESS) :\n\t\t\tcpu_to_le32(SAP_PLDR_STATUS_FAILURE),\n\t};\n\n\tmutex_lock(&iwl_mei_mutex);\n\n\tif (!iwl_mei_is_connected())\n\t\tgoto out;\n\n\tmei = mei_cldev_get_drvdata(iwl_mei_global_cldev);\n\tif (!mei || !mei->pldr_active)\n\t\tgoto out;\n\n\tmei->pldr_active = false;\n\n\tiwl_mei_send_sap_msg_payload(mei->cldev, &msg.hdr);\nout:\n\tmutex_unlock(&iwl_mei_mutex);\n}\nEXPORT_SYMBOL_GPL(iwl_mei_alive_notif);\n\nvoid iwl_mei_host_associated(const struct iwl_mei_conn_info *conn_info,\n\t\t\t     const struct iwl_mei_colloc_info *colloc_info)\n{\n\tstruct iwl_sap_notif_host_link_up msg = {\n\t\t.hdr.type = cpu_to_le16(SAP_MSG_NOTIF_HOST_LINK_UP),\n\t\t.hdr.len = cpu_to_le16(sizeof(msg) - sizeof(msg.hdr)),\n\t\t.conn_info = {\n\t\t\t.ssid_len = cpu_to_le32(conn_info->ssid_len),\n\t\t\t.channel = conn_info->channel,\n\t\t\t.band = conn_info->band,\n\t\t\t.pairwise_cipher = cpu_to_le32(conn_info->pairwise_cipher),\n\t\t\t.auth_mode = cpu_to_le32(conn_info->auth_mode),\n\t\t},\n\t};\n\tstruct iwl_mei *mei;\n\n\tif (conn_info->ssid_len > ARRAY_SIZE(msg.conn_info.ssid))\n\t\treturn;\n\n\tmemcpy(msg.conn_info.ssid, conn_info->ssid, conn_info->ssid_len);\n\tmemcpy(msg.conn_info.bssid, conn_info->bssid, ETH_ALEN);\n\n\tif (colloc_info) {\n\t\tmsg.colloc_channel = colloc_info->channel;\n\t\tmsg.colloc_band = colloc_info->channel <= 14 ? 0 : 1;\n\t\tmemcpy(msg.colloc_bssid, colloc_info->bssid, ETH_ALEN);\n\t}\n\n\tmutex_lock(&iwl_mei_mutex);\n\n\tif (!iwl_mei_is_connected())\n\t\tgoto out;\n\n\tmei = mei_cldev_get_drvdata(iwl_mei_global_cldev);\n\n\tif (!mei || !mei->amt_enabled)\n\t\tgoto out;\n\n\tiwl_mei_send_sap_msg_payload(mei->cldev, &msg.hdr);\n\nout:\n\tkfree(iwl_mei_cache.conn_info);\n\tiwl_mei_cache.conn_info =\n\t\tkmemdup(&msg.conn_info, sizeof(msg.conn_info), GFP_KERNEL);\n\tmutex_unlock(&iwl_mei_mutex);\n}\nEXPORT_SYMBOL_GPL(iwl_mei_host_associated);\n\nvoid iwl_mei_host_disassociated(void)\n{\n\tstruct iwl_mei *mei;\n\tstruct iwl_sap_notif_host_link_down msg = {\n\t\t.hdr.type = cpu_to_le16(SAP_MSG_NOTIF_HOST_LINK_DOWN),\n\t\t.hdr.len = cpu_to_le16(sizeof(msg) - sizeof(msg.hdr)),\n\t\t.type = HOST_LINK_DOWN_TYPE_TEMPORARY,\n\t};\n\n\tmutex_lock(&iwl_mei_mutex);\n\n\tif (!iwl_mei_is_connected())\n\t\tgoto out;\n\n\tmei = mei_cldev_get_drvdata(iwl_mei_global_cldev);\n\n\tif (!mei || !mei->amt_enabled)\n\t\tgoto out;\n\n\tiwl_mei_send_sap_msg_payload(mei->cldev, &msg.hdr);\n\nout:\n\tkfree(iwl_mei_cache.conn_info);\n\tiwl_mei_cache.conn_info = NULL;\n\tmutex_unlock(&iwl_mei_mutex);\n}\nEXPORT_SYMBOL_GPL(iwl_mei_host_disassociated);\n\nvoid iwl_mei_set_rfkill_state(bool hw_rfkill, bool sw_rfkill)\n{\n\tstruct iwl_mei *mei;\n\tu32 rfkill_state = 0;\n\tstruct iwl_sap_msg_dw msg = {\n\t\t.hdr.type = cpu_to_le16(SAP_MSG_NOTIF_RADIO_STATE),\n\t\t.hdr.len = cpu_to_le16(sizeof(msg) - sizeof(msg.hdr)),\n\t};\n\n\tif (!sw_rfkill)\n\t\trfkill_state |= SAP_SW_RFKILL_DEASSERTED;\n\n\tif (!hw_rfkill)\n\t\trfkill_state |= SAP_HW_RFKILL_DEASSERTED;\n\n\tmutex_lock(&iwl_mei_mutex);\n\n\tif (!iwl_mei_is_connected())\n\t\tgoto out;\n\n\tmsg.val = cpu_to_le32(rfkill_state);\n\n\tmei = mei_cldev_get_drvdata(iwl_mei_global_cldev);\n\n\tif (!mei || !mei->amt_enabled)\n\t\tgoto out;\n\n\tiwl_mei_send_sap_msg_payload(mei->cldev, &msg.hdr);\n\nout:\n\tiwl_mei_cache.rf_kill = rfkill_state;\n\tmutex_unlock(&iwl_mei_mutex);\n}\nEXPORT_SYMBOL_GPL(iwl_mei_set_rfkill_state);\n\nvoid iwl_mei_set_nic_info(const u8 *mac_address, const u8 *nvm_address)\n{\n\tstruct iwl_mei *mei;\n\tstruct iwl_sap_notif_host_nic_info msg = {\n\t\t.hdr.type = cpu_to_le16(SAP_MSG_NOTIF_NIC_INFO),\n\t\t.hdr.len = cpu_to_le16(sizeof(msg) - sizeof(msg.hdr)),\n\t};\n\n\tmutex_lock(&iwl_mei_mutex);\n\n\tif (!iwl_mei_is_connected())\n\t\tgoto out;\n\n\tether_addr_copy(msg.mac_address, mac_address);\n\tether_addr_copy(msg.nvm_address, nvm_address);\n\n\tmei = mei_cldev_get_drvdata(iwl_mei_global_cldev);\n\n\tif (!mei || !mei->amt_enabled)\n\t\tgoto out;\n\n\tiwl_mei_send_sap_msg_payload(mei->cldev, &msg.hdr);\n\nout:\n\tether_addr_copy(iwl_mei_cache.mac_address, mac_address);\n\tether_addr_copy(iwl_mei_cache.nvm_address, nvm_address);\n\tmutex_unlock(&iwl_mei_mutex);\n}\nEXPORT_SYMBOL_GPL(iwl_mei_set_nic_info);\n\nvoid iwl_mei_set_country_code(u16 mcc)\n{\n\tstruct iwl_mei *mei;\n\tstruct iwl_sap_notif_country_code msg = {\n\t\t.hdr.type = cpu_to_le16(SAP_MSG_NOTIF_COUNTRY_CODE),\n\t\t.hdr.len = cpu_to_le16(sizeof(msg) - sizeof(msg.hdr)),\n\t\t.mcc = cpu_to_le16(mcc),\n\t};\n\n\tmutex_lock(&iwl_mei_mutex);\n\n\tif (!iwl_mei_is_connected())\n\t\tgoto out;\n\n\tmei = mei_cldev_get_drvdata(iwl_mei_global_cldev);\n\n\tif (!mei || !mei->amt_enabled)\n\t\tgoto out;\n\n\tiwl_mei_send_sap_msg_payload(mei->cldev, &msg.hdr);\n\nout:\n\tiwl_mei_cache.mcc = mcc;\n\tmutex_unlock(&iwl_mei_mutex);\n}\nEXPORT_SYMBOL_GPL(iwl_mei_set_country_code);\n\nvoid iwl_mei_set_power_limit(const __le16 *power_limit)\n{\n\tstruct iwl_mei *mei;\n\tstruct iwl_sap_notif_sar_limits msg = {\n\t\t.hdr.type = cpu_to_le16(SAP_MSG_NOTIF_SAR_LIMITS),\n\t\t.hdr.len = cpu_to_le16(sizeof(msg) - sizeof(msg.hdr)),\n\t};\n\n\tmutex_lock(&iwl_mei_mutex);\n\n\tif (!iwl_mei_is_connected())\n\t\tgoto out;\n\n\tmei = mei_cldev_get_drvdata(iwl_mei_global_cldev);\n\n\tif (!mei || !mei->amt_enabled)\n\t\tgoto out;\n\n\tmemcpy(msg.sar_chain_info_table, power_limit, sizeof(msg.sar_chain_info_table));\n\n\tiwl_mei_send_sap_msg_payload(mei->cldev, &msg.hdr);\n\nout:\n\tkfree(iwl_mei_cache.power_limit);\n\tiwl_mei_cache.power_limit = kmemdup(power_limit,\n\t\t\t\t\t    sizeof(msg.sar_chain_info_table), GFP_KERNEL);\n\tmutex_unlock(&iwl_mei_mutex);\n}\nEXPORT_SYMBOL_GPL(iwl_mei_set_power_limit);\n\nvoid iwl_mei_set_netdev(struct net_device *netdev)\n{\n\tstruct iwl_mei *mei;\n\n\tmutex_lock(&iwl_mei_mutex);\n\n\tif (!iwl_mei_is_connected()) {\n\t\trcu_assign_pointer(iwl_mei_cache.netdev, netdev);\n\t\tgoto out;\n\t}\n\n\tmei = mei_cldev_get_drvdata(iwl_mei_global_cldev);\n\n\tif (!mei)\n\t\tgoto out;\n\n\tif (!netdev) {\n\t\tstruct net_device *dev =\n\t\t\trcu_dereference_protected(iwl_mei_cache.netdev,\n\t\t\t\t\t\t  lockdep_is_held(&iwl_mei_mutex));\n\n\t\tif (!dev)\n\t\t\tgoto out;\n\n\t\tnetdev_rx_handler_unregister(dev);\n\t}\n\n\trcu_assign_pointer(iwl_mei_cache.netdev, netdev);\n\n\tif (netdev && mei->amt_enabled)\n\t\tnetdev_rx_handler_register(netdev, iwl_mei_rx_handler, mei);\n\nout:\n\tmutex_unlock(&iwl_mei_mutex);\n}\nEXPORT_SYMBOL_GPL(iwl_mei_set_netdev);\n\nvoid iwl_mei_device_state(bool up)\n{\n\tstruct iwl_mei *mei;\n\n\tmutex_lock(&iwl_mei_mutex);\n\n\tif (!iwl_mei_is_connected())\n\t\tgoto out;\n\n\tmei = mei_cldev_get_drvdata(iwl_mei_global_cldev);\n\n\tif (!mei)\n\t\tgoto out;\n\n\tmei->device_down = !up;\n\n\tif (up || !mei->csme_taking_ownership)\n\t\tgoto out;\n\n\tiwl_mei_send_sap_msg(mei->cldev,\n\t\t\t     SAP_MSG_NOTIF_CSME_OWNERSHIP_CONFIRMED);\n\tmei->csme_taking_ownership = false;\n\tschedule_delayed_work(&mei->ownership_dwork,\n\t\t\t      MEI_OWNERSHIP_RETAKE_TIMEOUT_MS);\nout:\n\tmutex_unlock(&iwl_mei_mutex);\n}\nEXPORT_SYMBOL_GPL(iwl_mei_device_state);\n\nint iwl_mei_register(void *priv, const struct iwl_mei_ops *ops)\n{\n\tint ret;\n\n\t \n\tif (!priv)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&iwl_mei_mutex);\n\n\t \n\tif (iwl_mei_cache.priv || iwl_mei_cache.ops) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tiwl_mei_cache.priv = priv;\n\tiwl_mei_cache.ops = ops;\n\n\tif (iwl_mei_global_cldev) {\n\t\tstruct iwl_mei *mei =\n\t\t\tmei_cldev_get_drvdata(iwl_mei_global_cldev);\n\n\t\t \n\t\tif (iwl_mei_is_connected()) {\n\t\t\tif (mei->amt_enabled)\n\t\t\t\tiwl_mei_send_sap_msg(mei->cldev,\n\t\t\t\t\t\t     SAP_MSG_NOTIF_WIFIDR_UP);\n\t\t\tops->rfkill(priv, mei->link_prot_state, false);\n\t\t}\n\t}\n\tret = 0;\n\nout:\n\tmutex_unlock(&iwl_mei_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(iwl_mei_register);\n\nvoid iwl_mei_start_unregister(void)\n{\n\tmutex_lock(&iwl_mei_mutex);\n\n\t \n\tif (rcu_access_pointer(iwl_mei_cache.netdev))\n\t\tpr_err(\"Still had a netdev pointer set upon unregister\\n\");\n\n\tkfree(iwl_mei_cache.conn_info);\n\tiwl_mei_cache.conn_info = NULL;\n\tkfree(iwl_mei_cache.power_limit);\n\tiwl_mei_cache.power_limit = NULL;\n\tiwl_mei_cache.ops = NULL;\n\t \n\n\tmutex_unlock(&iwl_mei_mutex);\n}\nEXPORT_SYMBOL_GPL(iwl_mei_start_unregister);\n\nvoid iwl_mei_unregister_complete(void)\n{\n\tmutex_lock(&iwl_mei_mutex);\n\n\tiwl_mei_cache.priv = NULL;\n\n\tif (iwl_mei_global_cldev) {\n\t\tstruct iwl_mei *mei =\n\t\t\tmei_cldev_get_drvdata(iwl_mei_global_cldev);\n\n\t\tif (mei->amt_enabled)\n\t\t\tiwl_mei_send_sap_msg(mei->cldev,\n\t\t\t\t\t     SAP_MSG_NOTIF_WIFIDR_DOWN);\n\t\tmei->got_ownership = false;\n\t}\n\n\tmutex_unlock(&iwl_mei_mutex);\n}\nEXPORT_SYMBOL_GPL(iwl_mei_unregister_complete);\n\n#if IS_ENABLED(CONFIG_DEBUG_FS)\n\nstatic ssize_t\niwl_mei_dbgfs_send_start_message_write(struct file *file,\n\t\t\t\t       const char __user *user_buf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tint ret;\n\n\tmutex_lock(&iwl_mei_mutex);\n\n\tif (!iwl_mei_global_cldev) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tret = iwl_mei_send_start(iwl_mei_global_cldev);\n\nout:\n\tmutex_unlock(&iwl_mei_mutex);\n\treturn ret ?: count;\n}\n\nstatic const struct file_operations iwl_mei_dbgfs_send_start_message_ops = {\n\t.write = iwl_mei_dbgfs_send_start_message_write,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t iwl_mei_dbgfs_req_ownership_write(struct file *file,\n\t\t\t\t\t\t const char __user *user_buf,\n\t\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tiwl_mei_get_ownership();\n\n\treturn count;\n}\n\nstatic const struct file_operations iwl_mei_dbgfs_req_ownership_ops = {\n\t.write = iwl_mei_dbgfs_req_ownership_write,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic void iwl_mei_dbgfs_register(struct iwl_mei *mei)\n{\n\tmei->dbgfs_dir = debugfs_create_dir(KBUILD_MODNAME, NULL);\n\n\tif (!mei->dbgfs_dir)\n\t\treturn;\n\n\tdebugfs_create_ulong(\"status\", S_IRUSR,\n\t\t\t     mei->dbgfs_dir, &iwl_mei_status);\n\tdebugfs_create_file(\"send_start_message\", S_IWUSR, mei->dbgfs_dir,\n\t\t\t    mei, &iwl_mei_dbgfs_send_start_message_ops);\n\tdebugfs_create_file(\"req_ownership\", S_IWUSR, mei->dbgfs_dir,\n\t\t\t    mei, &iwl_mei_dbgfs_req_ownership_ops);\n}\n\nstatic void iwl_mei_dbgfs_unregister(struct iwl_mei *mei)\n{\n\tdebugfs_remove_recursive(mei->dbgfs_dir);\n\tmei->dbgfs_dir = NULL;\n}\n\n#else\n\nstatic void iwl_mei_dbgfs_register(struct iwl_mei *mei) {}\nstatic void iwl_mei_dbgfs_unregister(struct iwl_mei *mei) {}\n\n#endif  \n\nstatic void iwl_mei_ownership_dwork(struct work_struct *wk)\n{\n\tiwl_mei_get_ownership();\n}\n\n#define ALLOC_SHARED_MEM_RETRY_MAX_NUM\t3\n\n \nstatic int iwl_mei_probe(struct mei_cl_device *cldev,\n\t\t\t const struct mei_cl_device_id *id)\n{\n\tint alloc_retry = ALLOC_SHARED_MEM_RETRY_MAX_NUM;\n\tstruct iwl_mei *mei;\n\tint ret;\n\n\tmei = devm_kzalloc(&cldev->dev, sizeof(*mei), GFP_KERNEL);\n\tif (!mei)\n\t\treturn -ENOMEM;\n\n\tinit_waitqueue_head(&mei->get_nvm_wq);\n\tINIT_WORK(&mei->send_csa_msg_wk, iwl_mei_send_csa_msg_wk);\n\tINIT_DELAYED_WORK(&mei->csa_throttle_end_wk,\n\t\t\t  iwl_mei_csa_throttle_end_wk);\n\tinit_waitqueue_head(&mei->get_ownership_wq);\n\tinit_waitqueue_head(&mei->pldr_wq);\n\tspin_lock_init(&mei->data_q_lock);\n\tINIT_WORK(&mei->netdev_work, iwl_mei_netdev_work);\n\tINIT_DELAYED_WORK(&mei->ownership_dwork, iwl_mei_ownership_dwork);\n\n\tmei_cldev_set_drvdata(cldev, mei);\n\tmei->cldev = cldev;\n\tmei->device_down = true;\n\n\tdo {\n\t\tret = iwl_mei_alloc_shared_mem(cldev);\n\t\tif (!ret)\n\t\t\tbreak;\n\t\t \n\n\t\tdev_dbg(&cldev->dev,\n\t\t\t\"Couldn't allocate the shared memory: %d, attempt %d / %d\\n\",\n\t\t\tret, alloc_retry, ALLOC_SHARED_MEM_RETRY_MAX_NUM);\n\t\tmsleep(100);\n\t\talloc_retry--;\n\t} while (alloc_retry);\n\n\tif (ret) {\n\t\tdev_err(&cldev->dev, \"Couldn't allocate the shared memory: %d\\n\",\n\t\t\tret);\n\t\tgoto free;\n\t}\n\n\tiwl_mei_init_shared_mem(mei);\n\n\tret = iwl_mei_enable(cldev);\n\tif (ret)\n\t\tgoto free_shared_mem;\n\n\tiwl_mei_dbgfs_register(mei);\n\n\t \n\tmutex_lock(&iwl_mei_mutex);\n\tret = iwl_mei_send_start(cldev);\n\tmutex_unlock(&iwl_mei_mutex);\n\tif (ret)\n\t\tgoto debugfs_unregister;\n\n\t \n\tiwl_mei_global_cldev = cldev;\n\n\treturn 0;\n\ndebugfs_unregister:\n\tiwl_mei_dbgfs_unregister(mei);\n\tmei_cldev_disable(cldev);\nfree_shared_mem:\n\tiwl_mei_free_shared_mem(cldev);\nfree:\n\tmei_cldev_set_drvdata(cldev, NULL);\n\tdevm_kfree(&cldev->dev, mei);\n\n\treturn ret;\n}\n\n#define SEND_SAP_MAX_WAIT_ITERATION 10\n#define IWLMEI_DEVICE_DOWN_WAIT_ITERATION 50\n\nstatic void iwl_mei_remove(struct mei_cl_device *cldev)\n{\n\tstruct iwl_mei *mei = mei_cldev_get_drvdata(cldev);\n\tint i;\n\n\t \n\tif (mei_cldev_enabled(cldev) && iwl_mei_cache.ops) {\n\t\tunsigned int iter = IWLMEI_DEVICE_DOWN_WAIT_ITERATION;\n\t\tbool down = false;\n\n\t\t \n\t\twhile (!down && iter--) {\n\t\t\tmdelay(1);\n\n\t\t\tmutex_lock(&iwl_mei_mutex);\n\t\t\tdown = mei->device_down;\n\t\t\tmutex_unlock(&iwl_mei_mutex);\n\t\t}\n\n\t\tif (!down)\n\t\t\tiwl_mei_cache.ops->nic_stolen(iwl_mei_cache.priv);\n\t}\n\n\tif (rcu_access_pointer(iwl_mei_cache.netdev)) {\n\t\tstruct net_device *dev;\n\n\t\t \n\t\trtnl_lock();\n\t\tmutex_lock(&iwl_mei_mutex);\n\n\t\t \n\t\tdev = rcu_dereference_protected(iwl_mei_cache.netdev,\n\t\t\t\t\t\tlockdep_is_held(&iwl_mei_mutex));\n\n\t\tnetdev_rx_handler_unregister(dev);\n\t\tmutex_unlock(&iwl_mei_mutex);\n\t\trtnl_unlock();\n\t}\n\n\tmutex_lock(&iwl_mei_mutex);\n\n\t \n\tmei->csa_throttled = false;\n\tiwl_mei_send_sap_msg(mei->cldev,\n\t\t\t     SAP_MSG_NOTIF_HOST_GOES_DOWN);\n\n\tfor (i = 0; i < SEND_SAP_MAX_WAIT_ITERATION; i++) {\n\t\tif (!iwl_mei_host_to_me_data_pending(mei))\n\t\t\tbreak;\n\n\t\tmsleep(20);\n\t}\n\n\t \n\tif (i == SEND_SAP_MAX_WAIT_ITERATION)\n\t\tdev_err(&mei->cldev->dev,\n\t\t\t\"Couldn't get ACK from CSME on HOST_GOES_DOWN message\\n\");\n\n\tmutex_unlock(&iwl_mei_mutex);\n\n\t \n\tspin_lock_bh(&mei->data_q_lock);\n\tclear_bit(IWL_MEI_STATUS_SAP_CONNECTED, &iwl_mei_status);\n\tspin_unlock_bh(&mei->data_q_lock);\n\n\tif (iwl_mei_cache.ops)\n\t\tiwl_mei_cache.ops->rfkill(iwl_mei_cache.priv, false, false);\n\n\t \n\tmei_cldev_disable(cldev);\n\n\t \n\tcancel_work_sync(&mei->send_csa_msg_wk);\n\tcancel_delayed_work_sync(&mei->csa_throttle_end_wk);\n\tcancel_work_sync(&mei->netdev_work);\n\tcancel_delayed_work_sync(&mei->ownership_dwork);\n\n\t \n\twake_up_all(&mei->get_ownership_wq);\n\twake_up_all(&mei->pldr_wq);\n\n\tmutex_lock(&iwl_mei_mutex);\n\n\tiwl_mei_global_cldev = NULL;\n\n\twake_up_all(&mei->get_nvm_wq);\n\n\tiwl_mei_free_shared_mem(cldev);\n\n\tiwl_mei_dbgfs_unregister(mei);\n\n\tmei_cldev_set_drvdata(cldev, NULL);\n\n\tkfree(mei->nvm);\n\n\tkfree(rcu_access_pointer(mei->filters));\n\n\tdevm_kfree(&cldev->dev, mei);\n\n\tmutex_unlock(&iwl_mei_mutex);\n}\n\nstatic const struct mei_cl_device_id iwl_mei_tbl[] = {\n\t{\n\t\t.name = KBUILD_MODNAME,\n\t\t.uuid = MEI_WLAN_UUID,\n\t\t.version = MEI_CL_VERSION_ANY,\n\t},\n\n\t \n\t{ }\n};\n\n \n\nstatic struct mei_cl_driver iwl_mei_cl_driver = {\n\t.id_table = iwl_mei_tbl,\n\t.name = KBUILD_MODNAME,\n\t.probe = iwl_mei_probe,\n\t.remove = iwl_mei_remove,\n};\n\nmodule_mei_cl_driver(iwl_mei_cl_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}