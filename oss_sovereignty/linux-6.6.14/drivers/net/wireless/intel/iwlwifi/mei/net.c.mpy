{
  "module_name": "net.c",
  "hash_id": "81ab668369f215eeb4c3ca7a5fa19b1e05e18f1b28da2d8803fa89f7b3459d90",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mei/net.c",
  "human_readable_source": "\n \n\n#include <uapi/linux/if_ether.h>\n#include <uapi/linux/if_arp.h>\n#include <uapi/linux/icmp.h>\n\n#include <linux/etherdevice.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/ieee80211.h>\n\n#include <net/cfg80211.h>\n#include <net/ip.h>\n\n#include <linux/if_arp.h>\n#include <linux/icmp.h>\n#include <linux/udp.h>\n#include <linux/ip.h>\n#include <linux/mm.h>\n\n#include \"internal.h\"\n#include \"sap.h\"\n#include \"iwl-mei.h\"\n\n \nstatic bool iwl_mei_rx_filter_eth(const struct ethhdr *ethhdr,\n\t\t\t\t  const struct iwl_sap_oob_filters *filters,\n\t\t\t\t  bool *pass_to_csme,\n\t\t\t\t  rx_handler_result_t *rx_handler_res)\n{\n\tconst struct iwl_sap_eth_filter *filt;\n\n\t \n\tif (!is_multicast_ether_addr(ethhdr->h_dest) ||\n\t    is_broadcast_ether_addr(ethhdr->h_dest))\n\t\treturn false;\n\n\tfor (filt = &filters->eth_filters[0];\n\t     filt < &filters->eth_filters[0] + ARRAY_SIZE(filters->eth_filters);\n\t     filt++) {\n\t\t \n\t\tif (!(filt->flags & SAP_ETH_FILTER_ENABLED))\n\t\t\tbreak;\n\n\t\tif (compare_ether_header(filt->mac_address, ethhdr->h_dest))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (filt->flags & SAP_ETH_FILTER_COPY)\n\t\t\t*rx_handler_res = RX_HANDLER_PASS;\n\t\telse\n\t\t\t*rx_handler_res = RX_HANDLER_CONSUMED;\n\n\t\t \n\t\tif (filt->flags & SAP_ETH_FILTER_STOP) {\n\t\t\t*pass_to_csme = true;\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t  \n\t*pass_to_csme  = false;\n\n\treturn true;\n}\n\n \nstatic bool iwl_mei_rx_filter_arp(struct sk_buff *skb,\n\t\t\t\t  const struct iwl_sap_oob_filters *filters,\n\t\t\t\t  rx_handler_result_t *rx_handler_res)\n{\n\tconst struct iwl_sap_ipv4_filter *filt = &filters->ipv4_filter;\n\tconst struct arphdr *arp;\n\tconst __be32 *target_ip;\n\tu32 flags = le32_to_cpu(filt->flags);\n\n\tif (!pskb_may_pull(skb, arp_hdr_len(skb->dev)))\n\t\treturn false;\n\n\tarp = arp_hdr(skb);\n\n\t \n\tif (arp->ar_hrd != htons(ARPHRD_ETHER) ||\n\t    arp->ar_pro != htons(ETH_P_IP))\n\t\treturn false;\n\n\t \n\ttarget_ip = (const void *)((const u8 *)(arp + 1) +\n\t\t\t\t   ETH_ALEN + sizeof(__be32) + ETH_ALEN);\n\n\t \n\tif (arp->ar_op == htons(ARPOP_REQUEST) &&\n\t    (filt->flags & cpu_to_le32(SAP_IPV4_FILTER_ARP_REQ_PASS)) &&\n\t    (filt->ipv4_addr == 0 || filt->ipv4_addr == *target_ip)) {\n\t\tif (flags & SAP_IPV4_FILTER_ARP_REQ_COPY)\n\t\t\t*rx_handler_res = RX_HANDLER_PASS;\n\t\telse\n\t\t\t*rx_handler_res = RX_HANDLER_CONSUMED;\n\n\t\treturn true;\n\t}\n\n\t \n\tif (flags & SAP_IPV4_FILTER_ARP_RESP_PASS &&\n\t    arp->ar_op == htons(ARPOP_REPLY)) {\n\t\tif (flags & SAP_IPV4_FILTER_ARP_RESP_COPY)\n\t\t\t*rx_handler_res = RX_HANDLER_PASS;\n\t\telse\n\t\t\t*rx_handler_res = RX_HANDLER_CONSUMED;\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool\niwl_mei_rx_filter_tcp_udp(struct sk_buff *skb, bool  ip_match,\n\t\t\t  const struct iwl_sap_oob_filters *filters,\n\t\t\t  rx_handler_result_t *rx_handler_res)\n{\n\tconst struct iwl_sap_flex_filter *filt;\n\n\tfor (filt = &filters->flex_filters[0];\n\t     filt < &filters->flex_filters[0] + ARRAY_SIZE(filters->flex_filters);\n\t     filt++) {\n\t\tif (!(filt->flags & SAP_FLEX_FILTER_ENABLED))\n\t\t\tbreak;\n\n\t\t \n\t\tif ((filt->flags &\n\t\t     (SAP_FLEX_FILTER_IPV4 | SAP_FLEX_FILTER_IPV6)) &&\n\t\t    !ip_match)\n\t\t\tcontinue;\n\n\t\tif ((filt->flags & SAP_FLEX_FILTER_UDP) &&\n\t\t    ip_hdr(skb)->protocol != IPPROTO_UDP)\n\t\t\tcontinue;\n\n\t\tif ((filt->flags & SAP_FLEX_FILTER_TCP) &&\n\t\t    ip_hdr(skb)->protocol != IPPROTO_TCP)\n\t\t\tcontinue;\n\n\t\t \n\t\tif ((filt->src_port && filt->src_port != udp_hdr(skb)->source) ||\n\t\t    (filt->dst_port && filt->dst_port != udp_hdr(skb)->dest))\n\t\t\tcontinue;\n\n\t\tif (filt->flags & SAP_FLEX_FILTER_COPY)\n\t\t\t*rx_handler_res = RX_HANDLER_PASS;\n\t\telse\n\t\t\t*rx_handler_res = RX_HANDLER_CONSUMED;\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool iwl_mei_rx_filter_ipv4(struct sk_buff *skb,\n\t\t\t\t   const struct iwl_sap_oob_filters *filters,\n\t\t\t\t   rx_handler_result_t *rx_handler_res)\n{\n\tconst struct iwl_sap_ipv4_filter *filt = &filters->ipv4_filter;\n\tconst struct iphdr *iphdr;\n\tunsigned int iphdrlen;\n\tbool match;\n\n\tif (!pskb_may_pull(skb, skb_network_offset(skb) + sizeof(*iphdr)) ||\n\t    !pskb_may_pull(skb, skb_network_offset(skb) + ip_hdrlen(skb)))\n\t\treturn false;\n\n\tiphdrlen = ip_hdrlen(skb);\n\tiphdr = ip_hdr(skb);\n\tmatch = !filters->ipv4_filter.ipv4_addr ||\n\t\tfilters->ipv4_filter.ipv4_addr == iphdr->daddr;\n\n\tskb_set_transport_header(skb, skb_network_offset(skb) + iphdrlen);\n\n\tswitch (ip_hdr(skb)->protocol) {\n\tcase IPPROTO_UDP:\n\tcase IPPROTO_TCP:\n\t\t \n\t\tif (!pskb_may_pull(skb, skb_transport_offset(skb) +\n\t\t\t\t   sizeof(struct udphdr)))\n\t\t\treturn false;\n\n\t\treturn iwl_mei_rx_filter_tcp_udp(skb, match,\n\t\t\t\t\t\t filters, rx_handler_res);\n\n\tcase IPPROTO_ICMP: {\n\t\tstruct icmphdr *icmp;\n\n\t\tif (!pskb_may_pull(skb, skb_transport_offset(skb) + sizeof(*icmp)))\n\t\t\treturn false;\n\n\t\ticmp = icmp_hdr(skb);\n\n\t\t \n\t\tif ((filt->flags & cpu_to_le32(SAP_IPV4_FILTER_ICMP_PASS)) &&\n\t\t    match && (icmp->type != ICMP_ECHO || icmp->code != 0)) {\n\t\t\tif (filt->flags & cpu_to_le32(SAP_IPV4_FILTER_ICMP_COPY))\n\t\t\t\t*rx_handler_res = RX_HANDLER_PASS;\n\t\t\telse\n\t\t\t\t*rx_handler_res = RX_HANDLER_CONSUMED;\n\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\t\t}\n\tcase IPPROTO_ICMPV6:\n\t\t \n\t\tif ((filters->icmpv6_flags & cpu_to_le32(SAP_ICMPV6_FILTER_ENABLED) &&\n\t\t     match)) {\n\t\t\tif (filters->icmpv6_flags &\n\t\t\t    cpu_to_le32(SAP_ICMPV6_FILTER_COPY))\n\t\t\t\t*rx_handler_res = RX_HANDLER_PASS;\n\t\t\telse\n\t\t\t\t*rx_handler_res = RX_HANDLER_CONSUMED;\n\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn false;\n}\n\nstatic bool iwl_mei_rx_filter_ipv6(struct sk_buff *skb,\n\t\t\t\t   const struct iwl_sap_oob_filters *filters,\n\t\t\t\t   rx_handler_result_t *rx_handler_res)\n{\n\t*rx_handler_res = RX_HANDLER_PASS;\n\n\t \n\n\treturn false;\n}\n\nstatic rx_handler_result_t\niwl_mei_rx_pass_to_csme(struct sk_buff *skb,\n\t\t\tconst struct iwl_sap_oob_filters *filters,\n\t\t\tbool *pass_to_csme)\n{\n\tconst struct ethhdr *ethhdr = (void *)skb_mac_header(skb);\n\trx_handler_result_t rx_handler_res = RX_HANDLER_PASS;\n\tbool (*filt_handler)(struct sk_buff *skb,\n\t\t\t     const struct iwl_sap_oob_filters *filters,\n\t\t\t     rx_handler_result_t *rx_handler_res);\n\n\t \n\tskb_reset_network_header(skb);\n\n\t \n\tif (!skb_mac_offset(skb))\n\t\treturn RX_HANDLER_PASS;\n\n\tif (skb_headroom(skb) < sizeof(*ethhdr))\n\t\treturn RX_HANDLER_PASS;\n\n\tif (iwl_mei_rx_filter_eth(ethhdr, filters,\n\t\t\t\t  pass_to_csme, &rx_handler_res))\n\t\treturn rx_handler_res;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tfilt_handler = iwl_mei_rx_filter_ipv4;\n\t\tbreak;\n\tcase htons(ETH_P_ARP):\n\t\tfilt_handler = iwl_mei_rx_filter_arp;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tfilt_handler = iwl_mei_rx_filter_ipv6;\n\t\tbreak;\n\tdefault:\n\t\t*pass_to_csme = false;\n\t\treturn rx_handler_res;\n\t}\n\n\t*pass_to_csme = filt_handler(skb, filters, &rx_handler_res);\n\n\treturn rx_handler_res;\n}\n\nrx_handler_result_t iwl_mei_rx_filter(struct sk_buff *orig_skb,\n\t\t\t\t      const struct iwl_sap_oob_filters *filters,\n\t\t\t\t      bool *pass_to_csme)\n{\n\trx_handler_result_t ret;\n\tstruct sk_buff *skb;\n\n\tret = iwl_mei_rx_pass_to_csme(orig_skb, filters, pass_to_csme);\n\n\tif (!*pass_to_csme)\n\t\treturn RX_HANDLER_PASS;\n\n\tif (ret == RX_HANDLER_PASS) {\n\t\tskb = skb_copy(orig_skb, GFP_ATOMIC);\n\n\t\tif (!skb)\n\t\t\treturn RX_HANDLER_PASS;\n\t} else {\n\t\tskb = orig_skb;\n\t}\n\n\t \n\tskb_push(skb, skb->data - skb_mac_header(skb));\n\n\t \n\tiwl_mei_add_data_to_ring(skb, false);\n\n\t \n\tif (ret == RX_HANDLER_PASS)\n\t\tdev_kfree_skb(skb);\n\n\treturn ret;\n}\n\n#define DHCP_SERVER_PORT 67\n#define DHCP_CLIENT_PORT 68\nvoid iwl_mei_tx_copy_to_csme(struct sk_buff *origskb, unsigned int ivlen)\n{\n\tstruct ieee80211_hdr *hdr;\n\tstruct sk_buff *skb;\n\tstruct ethhdr ethhdr;\n\tstruct ethhdr *eth;\n\n\t \n\tif (origskb->protocol != htons(ETH_P_IP) ||\n\t    ip_hdr(origskb)->protocol != IPPROTO_UDP ||\n\t    udp_hdr(origskb)->source != htons(DHCP_CLIENT_PORT) ||\n\t    udp_hdr(origskb)->dest != htons(DHCP_SERVER_PORT))\n\t\treturn;\n\n\t \n\tskb = skb_copy(origskb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tskb->protocol = origskb->protocol;\n\n\thdr = (void *)skb->data;\n\n\tmemcpy(ethhdr.h_dest, ieee80211_get_DA(hdr), ETH_ALEN);\n\tmemcpy(ethhdr.h_source, ieee80211_get_SA(hdr), ETH_ALEN);\n\n\t \n\tpskb_pull(skb, ieee80211_hdrlen(hdr->frame_control) + ivlen + 6);\n\teth = skb_push(skb, sizeof(ethhdr.h_dest) + sizeof(ethhdr.h_source));\n\tmemcpy(eth, &ethhdr, sizeof(ethhdr.h_dest) + sizeof(ethhdr.h_source));\n\n\tiwl_mei_add_data_to_ring(skb, true);\n\n\tdev_kfree_skb(skb);\n}\nEXPORT_SYMBOL_GPL(iwl_mei_tx_copy_to_csme);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}