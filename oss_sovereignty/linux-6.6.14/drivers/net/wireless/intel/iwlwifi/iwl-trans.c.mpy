{
  "module_name": "iwl-trans.c",
  "hash_id": "a136dd16aeb95030f1745906a4ed4776ad724ae2ecc66a9bb0b85601a2d2fa4c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/iwl-trans.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/bsearch.h>\n\n#include \"fw/api/tx.h\"\n#include \"iwl-trans.h\"\n#include \"iwl-drv.h\"\n#include \"iwl-fh.h\"\n#include \"queue/tx.h\"\n#include <linux/dmapool.h>\n#include \"fw/api/commands.h\"\n\nstruct iwl_trans *iwl_trans_alloc(unsigned int priv_size,\n\t\t\t\t  struct device *dev,\n\t\t\t\t  const struct iwl_trans_ops *ops,\n\t\t\t\t  const struct iwl_cfg_trans_params *cfg_trans)\n{\n\tstruct iwl_trans *trans;\n#ifdef CONFIG_LOCKDEP\n\tstatic struct lock_class_key __key;\n#endif\n\n\ttrans = devm_kzalloc(dev, sizeof(*trans) + priv_size, GFP_KERNEL);\n\tif (!trans)\n\t\treturn NULL;\n\n\ttrans->trans_cfg = cfg_trans;\n\n#ifdef CONFIG_LOCKDEP\n\tlockdep_init_map(&trans->sync_cmd_lockdep_map, \"sync_cmd_lockdep_map\",\n\t\t\t &__key, 0);\n#endif\n\n\ttrans->dev = dev;\n\ttrans->ops = ops;\n\ttrans->num_rx_queues = 1;\n\n\tWARN_ON(!ops->wait_txq_empty && !ops->wait_tx_queues_empty);\n\n\tif (trans->trans_cfg->gen2) {\n\t\ttrans->txqs.tfd.addr_size = 64;\n\t\ttrans->txqs.tfd.max_tbs = IWL_TFH_NUM_TBS;\n\t\ttrans->txqs.tfd.size = sizeof(struct iwl_tfh_tfd);\n\t} else {\n\t\ttrans->txqs.tfd.addr_size = 36;\n\t\ttrans->txqs.tfd.max_tbs = IWL_NUM_OF_TBS;\n\t\ttrans->txqs.tfd.size = sizeof(struct iwl_tfd);\n\t}\n\ttrans->max_skb_frags = IWL_TRANS_MAX_FRAGS(trans);\n\n\treturn trans;\n}\n\nint iwl_trans_init(struct iwl_trans *trans)\n{\n\tint txcmd_size, txcmd_align;\n\n\tif (!trans->trans_cfg->gen2) {\n\t\ttxcmd_size = sizeof(struct iwl_tx_cmd);\n\t\ttxcmd_align = sizeof(void *);\n\t} else if (trans->trans_cfg->device_family < IWL_DEVICE_FAMILY_AX210) {\n\t\ttxcmd_size = sizeof(struct iwl_tx_cmd_gen2);\n\t\ttxcmd_align = 64;\n\t} else {\n\t\ttxcmd_size = sizeof(struct iwl_tx_cmd_gen3);\n\t\ttxcmd_align = 128;\n\t}\n\n\ttxcmd_size += sizeof(struct iwl_cmd_header);\n\ttxcmd_size += 36;  \n\n\t \n\tif (WARN_ON(trans->trans_cfg->gen2 && txcmd_size >= txcmd_align))\n\t\treturn -EINVAL;\n\n\tif (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_BZ)\n\t\ttrans->txqs.bc_tbl_size =\n\t\t\tsizeof(struct iwl_gen3_bc_tbl_entry) * TFD_QUEUE_BC_SIZE_GEN3_BZ;\n\telse if (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_AX210)\n\t\ttrans->txqs.bc_tbl_size =\n\t\t\tsizeof(struct iwl_gen3_bc_tbl_entry) * TFD_QUEUE_BC_SIZE_GEN3_AX210;\n\telse\n\t\ttrans->txqs.bc_tbl_size = sizeof(struct iwlagn_scd_bc_tbl);\n\t \n\tif (trans->trans_cfg->gen2) {\n\t\ttrans->txqs.bc_pool = dmam_pool_create(\"iwlwifi:bc\", trans->dev,\n\t\t\t\t\t\t       trans->txqs.bc_tbl_size,\n\t\t\t\t\t\t       256, 0);\n\t\tif (!trans->txqs.bc_pool)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tWARN_ON(trans->txqs.tfd.addr_size !=\n\t\t(trans->trans_cfg->gen2 ? 64 : 36));\n\n\tsnprintf(trans->dev_cmd_pool_name, sizeof(trans->dev_cmd_pool_name),\n\t\t \"iwl_cmd_pool:%s\", dev_name(trans->dev));\n\ttrans->dev_cmd_pool =\n\t\tkmem_cache_create(trans->dev_cmd_pool_name,\n\t\t\t\t  txcmd_size, txcmd_align,\n\t\t\t\t  SLAB_HWCACHE_ALIGN, NULL);\n\tif (!trans->dev_cmd_pool)\n\t\treturn -ENOMEM;\n\n\ttrans->txqs.tso_hdr_page = alloc_percpu(struct iwl_tso_hdr_page);\n\tif (!trans->txqs.tso_hdr_page) {\n\t\tkmem_cache_destroy(trans->dev_cmd_pool);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tinit_waitqueue_head(&trans->wait_command_queue);\n\n\treturn 0;\n}\n\nvoid iwl_trans_free(struct iwl_trans *trans)\n{\n\tint i;\n\n\tif (trans->txqs.tso_hdr_page) {\n\t\tfor_each_possible_cpu(i) {\n\t\t\tstruct iwl_tso_hdr_page *p =\n\t\t\t\tper_cpu_ptr(trans->txqs.tso_hdr_page, i);\n\n\t\t\tif (p && p->page)\n\t\t\t\t__free_page(p->page);\n\t\t}\n\n\t\tfree_percpu(trans->txqs.tso_hdr_page);\n\t}\n\n\tkmem_cache_destroy(trans->dev_cmd_pool);\n}\n\nint iwl_trans_send_cmd(struct iwl_trans *trans, struct iwl_host_cmd *cmd)\n{\n\tint ret;\n\n\tif (unlikely(!(cmd->flags & CMD_SEND_IN_RFKILL) &&\n\t\t     test_bit(STATUS_RFKILL_OPMODE, &trans->status)))\n\t\treturn -ERFKILL;\n\n\t \n\tif (unlikely(trans->system_pm_mode == IWL_PLAT_PM_MODE_D3 &&\n\t\t     !(cmd->flags & CMD_SEND_IN_D3)))\n\t\treturn -EHOSTDOWN;\n\n\tif (unlikely(test_bit(STATUS_FW_ERROR, &trans->status)))\n\t\treturn -EIO;\n\n\tif (unlikely(trans->state != IWL_TRANS_FW_ALIVE)) {\n\t\tIWL_ERR(trans, \"%s bad state = %d\\n\", __func__, trans->state);\n\t\treturn -EIO;\n\t}\n\n\tif (WARN_ON((cmd->flags & CMD_WANT_ASYNC_CALLBACK) &&\n\t\t    !(cmd->flags & CMD_ASYNC)))\n\t\treturn -EINVAL;\n\n\tif (!(cmd->flags & CMD_ASYNC))\n\t\tlock_map_acquire_read(&trans->sync_cmd_lockdep_map);\n\n\tif (trans->wide_cmd_header && !iwl_cmd_groupid(cmd->id)) {\n\t\tif (cmd->id != REPLY_ERROR)\n\t\t\tcmd->id = DEF_ID(cmd->id);\n\t}\n\n\tret = iwl_trans_txq_send_hcmd(trans, cmd);\n\n\tif (!(cmd->flags & CMD_ASYNC))\n\t\tlock_map_release(&trans->sync_cmd_lockdep_map);\n\n\tif (WARN_ON((cmd->flags & CMD_WANT_SKB) && !ret && !cmd->resp_pkt))\n\t\treturn -EIO;\n\n\treturn ret;\n}\nIWL_EXPORT_SYMBOL(iwl_trans_send_cmd);\n\n \nstatic int iwl_hcmd_names_cmp(const void *key, const void *elt)\n{\n\tconst struct iwl_hcmd_names *name = elt;\n\tconst u8 *cmd1 = key;\n\tu8 cmd2 = name->cmd_id;\n\n\treturn (*cmd1 - cmd2);\n}\n\nconst char *iwl_get_cmd_string(struct iwl_trans *trans, u32 id)\n{\n\tu8 grp, cmd;\n\tstruct iwl_hcmd_names *ret;\n\tconst struct iwl_hcmd_arr *arr;\n\tsize_t size = sizeof(struct iwl_hcmd_names);\n\n\tgrp = iwl_cmd_groupid(id);\n\tcmd = iwl_cmd_opcode(id);\n\n\tif (!trans->command_groups || grp >= trans->command_groups_size ||\n\t    !trans->command_groups[grp].arr)\n\t\treturn \"UNKNOWN\";\n\n\tarr = &trans->command_groups[grp];\n\tret = bsearch(&cmd, arr->arr, arr->size, size, iwl_hcmd_names_cmp);\n\tif (!ret)\n\t\treturn \"UNKNOWN\";\n\treturn ret->cmd_name;\n}\nIWL_EXPORT_SYMBOL(iwl_get_cmd_string);\n\nint iwl_cmd_groups_verify_sorted(const struct iwl_trans_config *trans)\n{\n\tint i, j;\n\tconst struct iwl_hcmd_arr *arr;\n\n\tfor (i = 0; i < trans->command_groups_size; i++) {\n\t\tarr = &trans->command_groups[i];\n\t\tif (!arr->arr)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < arr->size - 1; j++)\n\t\t\tif (arr->arr[j].cmd_id > arr->arr[j + 1].cmd_id)\n\t\t\t\treturn -1;\n\t}\n\treturn 0;\n}\nIWL_EXPORT_SYMBOL(iwl_cmd_groups_verify_sorted);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}