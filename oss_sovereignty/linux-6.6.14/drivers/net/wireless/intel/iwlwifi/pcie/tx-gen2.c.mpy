{
  "module_name": "tx-gen2.c",
  "hash_id": "2aec4221dc37bef59bd1cc5f5e35d2216f01c7575c907df977fdfa92431855be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/pcie/tx-gen2.c",
  "human_readable_source": "\n \n#include <net/tso.h>\n#include <linux/tcp.h>\n\n#include \"iwl-debug.h\"\n#include \"iwl-csr.h\"\n#include \"iwl-io.h\"\n#include \"internal.h\"\n#include \"fw/api/tx.h\"\n#include \"queue/tx.h\"\n\n \n\n \nint iwl_pcie_gen2_enqueue_hcmd(struct iwl_trans *trans,\n\t\t\t       struct iwl_host_cmd *cmd)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tstruct iwl_txq *txq = trans->txqs.txq[trans->txqs.cmd.q_id];\n\tstruct iwl_device_cmd *out_cmd;\n\tstruct iwl_cmd_meta *out_meta;\n\tvoid *dup_buf = NULL;\n\tdma_addr_t phys_addr;\n\tint i, cmd_pos, idx;\n\tu16 copy_size, cmd_size, tb0_size;\n\tbool had_nocopy = false;\n\tu8 group_id = iwl_cmd_groupid(cmd->id);\n\tconst u8 *cmddata[IWL_MAX_CMD_TBS_PER_TFD];\n\tu16 cmdlen[IWL_MAX_CMD_TBS_PER_TFD];\n\tstruct iwl_tfh_tfd *tfd;\n\tunsigned long flags;\n\n\tcopy_size = sizeof(struct iwl_cmd_header_wide);\n\tcmd_size = sizeof(struct iwl_cmd_header_wide);\n\n\tfor (i = 0; i < IWL_MAX_CMD_TBS_PER_TFD; i++) {\n\t\tcmddata[i] = cmd->data[i];\n\t\tcmdlen[i] = cmd->len[i];\n\n\t\tif (!cmd->len[i])\n\t\t\tcontinue;\n\n\t\t \n\t\tif (copy_size < IWL_FIRST_TB_SIZE) {\n\t\t\tint copy = IWL_FIRST_TB_SIZE - copy_size;\n\n\t\t\tif (copy > cmdlen[i])\n\t\t\t\tcopy = cmdlen[i];\n\t\t\tcmdlen[i] -= copy;\n\t\t\tcmddata[i] += copy;\n\t\t\tcopy_size += copy;\n\t\t}\n\n\t\tif (cmd->dataflags[i] & IWL_HCMD_DFL_NOCOPY) {\n\t\t\thad_nocopy = true;\n\t\t\tif (WARN_ON(cmd->dataflags[i] & IWL_HCMD_DFL_DUP)) {\n\t\t\t\tidx = -EINVAL;\n\t\t\t\tgoto free_dup_buf;\n\t\t\t}\n\t\t} else if (cmd->dataflags[i] & IWL_HCMD_DFL_DUP) {\n\t\t\t \n\t\t\thad_nocopy = true;\n\n\t\t\t \n\t\t\tif (WARN_ON(dup_buf)) {\n\t\t\t\tidx = -EINVAL;\n\t\t\t\tgoto free_dup_buf;\n\t\t\t}\n\n\t\t\tdup_buf = kmemdup(cmddata[i], cmdlen[i],\n\t\t\t\t\t  GFP_ATOMIC);\n\t\t\tif (!dup_buf)\n\t\t\t\treturn -ENOMEM;\n\t\t} else {\n\t\t\t \n\t\t\tif (WARN_ON(had_nocopy)) {\n\t\t\t\tidx = -EINVAL;\n\t\t\t\tgoto free_dup_buf;\n\t\t\t}\n\t\t\tcopy_size += cmdlen[i];\n\t\t}\n\t\tcmd_size += cmd->len[i];\n\t}\n\n\t \n\tif (WARN(copy_size > TFD_MAX_PAYLOAD_SIZE,\n\t\t \"Command %s (%#x) is too large (%d bytes)\\n\",\n\t\t iwl_get_cmd_string(trans, cmd->id), cmd->id, copy_size)) {\n\t\tidx = -EINVAL;\n\t\tgoto free_dup_buf;\n\t}\n\n\tspin_lock_irqsave(&txq->lock, flags);\n\n\tidx = iwl_txq_get_cmd_index(txq, txq->write_ptr);\n\ttfd = iwl_txq_get_tfd(trans, txq, txq->write_ptr);\n\tmemset(tfd, 0, sizeof(*tfd));\n\n\tif (iwl_txq_space(trans, txq) < ((cmd->flags & CMD_ASYNC) ? 2 : 1)) {\n\t\tspin_unlock_irqrestore(&txq->lock, flags);\n\n\t\tIWL_ERR(trans, \"No space in command queue\\n\");\n\t\tiwl_op_mode_cmd_queue_full(trans->op_mode);\n\t\tidx = -ENOSPC;\n\t\tgoto free_dup_buf;\n\t}\n\n\tout_cmd = txq->entries[idx].cmd;\n\tout_meta = &txq->entries[idx].meta;\n\n\t \n\tmemset(out_meta, 0, sizeof(*out_meta));\n\tif (cmd->flags & CMD_WANT_SKB)\n\t\tout_meta->source = cmd;\n\n\t \n\tout_cmd->hdr_wide.cmd = iwl_cmd_opcode(cmd->id);\n\tout_cmd->hdr_wide.group_id = group_id;\n\tout_cmd->hdr_wide.version = iwl_cmd_version(cmd->id);\n\tout_cmd->hdr_wide.length =\n\t\tcpu_to_le16(cmd_size - sizeof(struct iwl_cmd_header_wide));\n\tout_cmd->hdr_wide.reserved = 0;\n\tout_cmd->hdr_wide.sequence =\n\t\tcpu_to_le16(QUEUE_TO_SEQ(trans->txqs.cmd.q_id) |\n\t\t\t\t\t INDEX_TO_SEQ(txq->write_ptr));\n\n\tcmd_pos = sizeof(struct iwl_cmd_header_wide);\n\tcopy_size = sizeof(struct iwl_cmd_header_wide);\n\n\t \n\tfor (i = 0; i < IWL_MAX_CMD_TBS_PER_TFD; i++) {\n\t\tint copy;\n\n\t\tif (!cmd->len[i])\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!(cmd->dataflags[i] & (IWL_HCMD_DFL_NOCOPY |\n\t\t\t\t\t   IWL_HCMD_DFL_DUP))) {\n\t\t\tcopy = cmd->len[i];\n\n\t\t\tmemcpy((u8 *)out_cmd + cmd_pos, cmd->data[i], copy);\n\t\t\tcmd_pos += copy;\n\t\t\tcopy_size += copy;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tcopy = min_t(int, TFD_MAX_PAYLOAD_SIZE - cmd_pos, cmd->len[i]);\n\n\t\tmemcpy((u8 *)out_cmd + cmd_pos, cmd->data[i], copy);\n\t\tcmd_pos += copy;\n\n\t\t \n\t\tif (copy_size < IWL_FIRST_TB_SIZE) {\n\t\t\tcopy = IWL_FIRST_TB_SIZE - copy_size;\n\n\t\t\tif (copy > cmd->len[i])\n\t\t\t\tcopy = cmd->len[i];\n\t\t\tcopy_size += copy;\n\t\t}\n\t}\n\n\tIWL_DEBUG_HC(trans,\n\t\t     \"Sending command %s (%.2x.%.2x), seq: 0x%04X, %d bytes at %d[%d]:%d\\n\",\n\t\t     iwl_get_cmd_string(trans, cmd->id), group_id,\n\t\t     out_cmd->hdr.cmd, le16_to_cpu(out_cmd->hdr.sequence),\n\t\t     cmd_size, txq->write_ptr, idx, trans->txqs.cmd.q_id);\n\n\t \n\ttb0_size = min_t(int, copy_size, IWL_FIRST_TB_SIZE);\n\tmemcpy(&txq->first_tb_bufs[idx], out_cmd, tb0_size);\n\tiwl_txq_gen2_set_tb(trans, tfd, iwl_txq_get_first_tb_dma(txq, idx),\n\t\t\t    tb0_size);\n\n\t \n\tif (copy_size > tb0_size) {\n\t\tphys_addr = dma_map_single(trans->dev,\n\t\t\t\t\t   (u8 *)out_cmd + tb0_size,\n\t\t\t\t\t   copy_size - tb0_size,\n\t\t\t\t\t   DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(trans->dev, phys_addr)) {\n\t\t\tidx = -ENOMEM;\n\t\t\tiwl_txq_gen2_tfd_unmap(trans, out_meta, tfd);\n\t\t\tgoto out;\n\t\t}\n\t\tiwl_txq_gen2_set_tb(trans, tfd, phys_addr,\n\t\t\t\t    copy_size - tb0_size);\n\t}\n\n\t \n\tfor (i = 0; i < IWL_MAX_CMD_TBS_PER_TFD; i++) {\n\t\tvoid *data = (void *)(uintptr_t)cmddata[i];\n\n\t\tif (!cmdlen[i])\n\t\t\tcontinue;\n\t\tif (!(cmd->dataflags[i] & (IWL_HCMD_DFL_NOCOPY |\n\t\t\t\t\t   IWL_HCMD_DFL_DUP)))\n\t\t\tcontinue;\n\t\tif (cmd->dataflags[i] & IWL_HCMD_DFL_DUP)\n\t\t\tdata = dup_buf;\n\t\tphys_addr = dma_map_single(trans->dev, data,\n\t\t\t\t\t   cmdlen[i], DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(trans->dev, phys_addr)) {\n\t\t\tidx = -ENOMEM;\n\t\t\tiwl_txq_gen2_tfd_unmap(trans, out_meta, tfd);\n\t\t\tgoto out;\n\t\t}\n\t\tiwl_txq_gen2_set_tb(trans, tfd, phys_addr, cmdlen[i]);\n\t}\n\n\tBUILD_BUG_ON(IWL_TFH_NUM_TBS > sizeof(out_meta->tbs) * BITS_PER_BYTE);\n\tout_meta->flags = cmd->flags;\n\tif (WARN_ON_ONCE(txq->entries[idx].free_buf))\n\t\tkfree_sensitive(txq->entries[idx].free_buf);\n\ttxq->entries[idx].free_buf = dup_buf;\n\n\ttrace_iwlwifi_dev_hcmd(trans->dev, cmd, cmd_size, &out_cmd->hdr_wide);\n\n\t \n\tif (txq->read_ptr == txq->write_ptr && txq->wd_timeout)\n\t\tmod_timer(&txq->stuck_timer, jiffies + txq->wd_timeout);\n\n\tspin_lock(&trans_pcie->reg_lock);\n\t \n\ttxq->write_ptr = iwl_txq_inc_wrap(trans, txq->write_ptr);\n\tiwl_txq_inc_wr_ptr(trans, txq);\n\tspin_unlock(&trans_pcie->reg_lock);\n\nout:\n\tspin_unlock_irqrestore(&txq->lock, flags);\nfree_dup_buf:\n\tif (idx < 0)\n\t\tkfree(dup_buf);\n\treturn idx;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}