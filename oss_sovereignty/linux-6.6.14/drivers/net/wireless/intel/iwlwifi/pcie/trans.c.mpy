{
  "module_name": "trans.c",
  "hash_id": "f083c884bdea2694886648cb7ba66361ea5ede92e7294cfd4fce66c2b5f7bcdd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/pcie/trans.c",
  "human_readable_source": "\n \n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/bitops.h>\n#include <linux/gfp.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/seq_file.h>\n\n#include \"iwl-drv.h\"\n#include \"iwl-trans.h\"\n#include \"iwl-csr.h\"\n#include \"iwl-prph.h\"\n#include \"iwl-scd.h\"\n#include \"iwl-agn-hw.h\"\n#include \"fw/error-dump.h\"\n#include \"fw/dbg.h\"\n#include \"fw/api/tx.h\"\n#include \"mei/iwl-mei.h\"\n#include \"internal.h\"\n#include \"iwl-fh.h\"\n#include \"iwl-context-info-gen3.h\"\n\n \n#define IWL_FW_MEM_EXTENDED_START\t0x40000\n#define IWL_FW_MEM_EXTENDED_END\t\t0x57FFF\n\nvoid iwl_trans_pcie_dump_regs(struct iwl_trans *trans)\n{\n#define PCI_DUMP_SIZE\t\t352\n#define PCI_MEM_DUMP_SIZE\t64\n#define PCI_PARENT_DUMP_SIZE\t524\n#define PREFIX_LEN\t\t32\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tstruct pci_dev *pdev = trans_pcie->pci_dev;\n\tu32 i, pos, alloc_size, *ptr, *buf;\n\tchar *prefix;\n\n\tif (trans_pcie->pcie_dbg_dumped_once)\n\t\treturn;\n\n\t \n\tBUILD_BUG_ON(PCI_DUMP_SIZE > 4096 || PCI_DUMP_SIZE & 0x3);\n\tBUILD_BUG_ON(PCI_MEM_DUMP_SIZE > 4096 || PCI_MEM_DUMP_SIZE & 0x3);\n\tBUILD_BUG_ON(PCI_PARENT_DUMP_SIZE > 4096 || PCI_PARENT_DUMP_SIZE & 0x3);\n\n\t \n\talloc_size = PCI_ERR_ROOT_ERR_SRC +  4 + PREFIX_LEN;\n\talloc_size = max_t(u32, alloc_size, PCI_DUMP_SIZE + PREFIX_LEN);\n\talloc_size = max_t(u32, alloc_size, PCI_MEM_DUMP_SIZE + PREFIX_LEN);\n\talloc_size = max_t(u32, alloc_size, PCI_PARENT_DUMP_SIZE + PREFIX_LEN);\n\n\tbuf = kmalloc(alloc_size, GFP_ATOMIC);\n\tif (!buf)\n\t\treturn;\n\tprefix = (char *)buf + alloc_size - PREFIX_LEN;\n\n\tIWL_ERR(trans, \"iwlwifi transaction failed, dumping registers\\n\");\n\n\t \n\tsprintf(prefix, \"iwlwifi %s: \", pci_name(pdev));\n\tIWL_ERR(trans, \"iwlwifi device config registers:\\n\");\n\tfor (i = 0, ptr = buf; i < PCI_DUMP_SIZE; i += 4, ptr++)\n\t\tif (pci_read_config_dword(pdev, i, ptr))\n\t\t\tgoto err_read;\n\tprint_hex_dump(KERN_ERR, prefix, DUMP_PREFIX_OFFSET, 32, 4, buf, i, 0);\n\n\tIWL_ERR(trans, \"iwlwifi device memory mapped registers:\\n\");\n\tfor (i = 0, ptr = buf; i < PCI_MEM_DUMP_SIZE; i += 4, ptr++)\n\t\t*ptr = iwl_read32(trans, i);\n\tprint_hex_dump(KERN_ERR, prefix, DUMP_PREFIX_OFFSET, 32, 4, buf, i, 0);\n\n\tpos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_ERR);\n\tif (pos) {\n\t\tIWL_ERR(trans, \"iwlwifi device AER capability structure:\\n\");\n\t\tfor (i = 0, ptr = buf; i < PCI_ERR_ROOT_COMMAND; i += 4, ptr++)\n\t\t\tif (pci_read_config_dword(pdev, pos + i, ptr))\n\t\t\t\tgoto err_read;\n\t\tprint_hex_dump(KERN_ERR, prefix, DUMP_PREFIX_OFFSET,\n\t\t\t       32, 4, buf, i, 0);\n\t}\n\n\t \n\tif (!pdev->bus->self)\n\t\tgoto out;\n\n\tpdev = pdev->bus->self;\n\tsprintf(prefix, \"iwlwifi %s: \", pci_name(pdev));\n\n\tIWL_ERR(trans, \"iwlwifi parent port (%s) config registers:\\n\",\n\t\tpci_name(pdev));\n\tfor (i = 0, ptr = buf; i < PCI_PARENT_DUMP_SIZE; i += 4, ptr++)\n\t\tif (pci_read_config_dword(pdev, i, ptr))\n\t\t\tgoto err_read;\n\tprint_hex_dump(KERN_ERR, prefix, DUMP_PREFIX_OFFSET, 32, 4, buf, i, 0);\n\n\t \n\tpos = 0;\n\tpdev = pcie_find_root_port(pdev);\n\tif (pdev)\n\t\tpos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_ERR);\n\tif (pos) {\n\t\tIWL_ERR(trans, \"iwlwifi root port (%s) AER cap structure:\\n\",\n\t\t\tpci_name(pdev));\n\t\tsprintf(prefix, \"iwlwifi %s: \", pci_name(pdev));\n\t\tfor (i = 0, ptr = buf; i <= PCI_ERR_ROOT_ERR_SRC; i += 4, ptr++)\n\t\t\tif (pci_read_config_dword(pdev, pos + i, ptr))\n\t\t\t\tgoto err_read;\n\t\tprint_hex_dump(KERN_ERR, prefix, DUMP_PREFIX_OFFSET, 32,\n\t\t\t       4, buf, i, 0);\n\t}\n\tgoto out;\n\nerr_read:\n\tprint_hex_dump(KERN_ERR, prefix, DUMP_PREFIX_OFFSET, 32, 4, buf, i, 0);\n\tIWL_ERR(trans, \"Read failed at 0x%X\\n\", i);\nout:\n\ttrans_pcie->pcie_dbg_dumped_once = 1;\n\tkfree(buf);\n}\n\nstatic int iwl_trans_pcie_sw_reset(struct iwl_trans *trans,\n\t\t\t\t   bool retake_ownership)\n{\n\t \n\tif (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_BZ) {\n\t\tiwl_set_bit(trans, CSR_GP_CNTRL,\n\t\t\t    CSR_GP_CNTRL_REG_FLAG_SW_RESET);\n\t\tusleep_range(10000, 20000);\n\t} else {\n\t\tiwl_set_bit(trans, CSR_RESET,\n\t\t\t    CSR_RESET_REG_FLAG_SW_RESET);\n\t\tusleep_range(5000, 6000);\n\t}\n\n\tif (retake_ownership)\n\t\treturn iwl_pcie_prepare_card_hw(trans);\n\n\treturn 0;\n}\n\nstatic void iwl_pcie_free_fw_monitor(struct iwl_trans *trans)\n{\n\tstruct iwl_dram_data *fw_mon = &trans->dbg.fw_mon;\n\n\tif (!fw_mon->size)\n\t\treturn;\n\n\tdma_free_coherent(trans->dev, fw_mon->size, fw_mon->block,\n\t\t\t  fw_mon->physical);\n\n\tfw_mon->block = NULL;\n\tfw_mon->physical = 0;\n\tfw_mon->size = 0;\n}\n\nstatic void iwl_pcie_alloc_fw_monitor_block(struct iwl_trans *trans,\n\t\t\t\t\t    u8 max_power)\n{\n\tstruct iwl_dram_data *fw_mon = &trans->dbg.fw_mon;\n\tvoid *block = NULL;\n\tdma_addr_t physical = 0;\n\tu32 size = 0;\n\tu8 power;\n\n\tif (fw_mon->size) {\n\t\tmemset(fw_mon->block, 0, fw_mon->size);\n\t\treturn;\n\t}\n\n\t \n\tfor (power = max_power; power >= 11; power--) {\n\t\tsize = BIT(power);\n\t\tblock = dma_alloc_coherent(trans->dev, size, &physical,\n\t\t\t\t\t   GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!block)\n\t\t\tcontinue;\n\n\t\tIWL_INFO(trans,\n\t\t\t \"Allocated 0x%08x bytes for firmware monitor.\\n\",\n\t\t\t size);\n\t\tbreak;\n\t}\n\n\tif (WARN_ON_ONCE(!block))\n\t\treturn;\n\n\tif (power != max_power)\n\t\tIWL_ERR(trans,\n\t\t\t\"Sorry - debug buffer is only %luK while you requested %luK\\n\",\n\t\t\t(unsigned long)BIT(power - 10),\n\t\t\t(unsigned long)BIT(max_power - 10));\n\n\tfw_mon->block = block;\n\tfw_mon->physical = physical;\n\tfw_mon->size = size;\n}\n\nvoid iwl_pcie_alloc_fw_monitor(struct iwl_trans *trans, u8 max_power)\n{\n\tif (!max_power) {\n\t\t \n\t\tmax_power = 26;\n\t} else {\n\t\tmax_power += 11;\n\t}\n\n\tif (WARN(max_power > 26,\n\t\t \"External buffer size for monitor is too big %d, check the FW TLV\\n\",\n\t\t max_power))\n\t\treturn;\n\n\tiwl_pcie_alloc_fw_monitor_block(trans, max_power);\n}\n\nstatic u32 iwl_trans_pcie_read_shr(struct iwl_trans *trans, u32 reg)\n{\n\tiwl_write32(trans, HEEP_CTRL_WRD_PCIEX_CTRL_REG,\n\t\t    ((reg & 0x0000ffff) | (2 << 28)));\n\treturn iwl_read32(trans, HEEP_CTRL_WRD_PCIEX_DATA_REG);\n}\n\nstatic void iwl_trans_pcie_write_shr(struct iwl_trans *trans, u32 reg, u32 val)\n{\n\tiwl_write32(trans, HEEP_CTRL_WRD_PCIEX_DATA_REG, val);\n\tiwl_write32(trans, HEEP_CTRL_WRD_PCIEX_CTRL_REG,\n\t\t    ((reg & 0x0000ffff) | (3 << 28)));\n}\n\nstatic void iwl_pcie_set_pwr(struct iwl_trans *trans, bool vaux)\n{\n\tif (trans->cfg->apmg_not_supported)\n\t\treturn;\n\n\tif (vaux && pci_pme_capable(to_pci_dev(trans->dev), PCI_D3cold))\n\t\tiwl_set_bits_mask_prph(trans, APMG_PS_CTRL_REG,\n\t\t\t\t       APMG_PS_CTRL_VAL_PWR_SRC_VAUX,\n\t\t\t\t       ~APMG_PS_CTRL_MSK_PWR_SRC);\n\telse\n\t\tiwl_set_bits_mask_prph(trans, APMG_PS_CTRL_REG,\n\t\t\t\t       APMG_PS_CTRL_VAL_PWR_SRC_VMAIN,\n\t\t\t\t       ~APMG_PS_CTRL_MSK_PWR_SRC);\n}\n\n \n#define PCI_CFG_RETRY_TIMEOUT\t0x041\n\nvoid iwl_pcie_apm_config(struct iwl_trans *trans)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tu16 lctl;\n\tu16 cap;\n\n\t \n\tiwl_set_bit(trans, CSR_GIO_REG, CSR_GIO_REG_VAL_L0S_DISABLED);\n\n\tpcie_capability_read_word(trans_pcie->pci_dev, PCI_EXP_LNKCTL, &lctl);\n\ttrans->pm_support = !(lctl & PCI_EXP_LNKCTL_ASPM_L0S);\n\n\tpcie_capability_read_word(trans_pcie->pci_dev, PCI_EXP_DEVCTL2, &cap);\n\ttrans->ltr_enabled = cap & PCI_EXP_DEVCTL2_LTR_EN;\n\tIWL_DEBUG_POWER(trans, \"L1 %sabled - LTR %sabled\\n\",\n\t\t\t(lctl & PCI_EXP_LNKCTL_ASPM_L1) ? \"En\" : \"Dis\",\n\t\t\ttrans->ltr_enabled ? \"En\" : \"Dis\");\n}\n\n \nstatic int iwl_pcie_apm_init(struct iwl_trans *trans)\n{\n\tint ret;\n\n\tIWL_DEBUG_INFO(trans, \"Init card's basic functions\\n\");\n\n\t \n\n\t \n\tif (trans->trans_cfg->device_family < IWL_DEVICE_FAMILY_8000)\n\t\tiwl_set_bit(trans, CSR_GIO_CHICKEN_BITS,\n\t\t\t    CSR_GIO_CHICKEN_BITS_REG_BIT_DIS_L0S_EXIT_TIMER);\n\n\t \n\tiwl_set_bit(trans, CSR_GIO_CHICKEN_BITS,\n\t\t    CSR_GIO_CHICKEN_BITS_REG_BIT_L1A_NO_L0S_RX);\n\n\t \n\tiwl_set_bit(trans, CSR_DBG_HPET_MEM_REG, CSR_DBG_HPET_MEM_REG_VAL);\n\n\t \n\tiwl_set_bit(trans, CSR_HW_IF_CONFIG_REG,\n\t\t    CSR_HW_IF_CONFIG_REG_BIT_HAP_WAKE_L1A);\n\n\tiwl_pcie_apm_config(trans);\n\n\t \n\tif (trans->trans_cfg->base_params->pll_cfg)\n\t\tiwl_set_bit(trans, CSR_ANA_PLL_CFG, CSR50_ANA_PLL_CFG_VAL);\n\n\tret = iwl_finish_nic_init(trans);\n\tif (ret)\n\t\treturn ret;\n\n\tif (trans->cfg->host_interrupt_operation_mode) {\n\t\t \n\t\tiwl_read_prph(trans, OSC_CLK);\n\t\tiwl_read_prph(trans, OSC_CLK);\n\t\tiwl_set_bits_prph(trans, OSC_CLK, OSC_CLK_FORCE_CONTROL);\n\t\tiwl_read_prph(trans, OSC_CLK);\n\t\tiwl_read_prph(trans, OSC_CLK);\n\t}\n\n\t \n\tif (!trans->cfg->apmg_not_supported) {\n\t\tiwl_write_prph(trans, APMG_CLK_EN_REG,\n\t\t\t       APMG_CLK_VAL_DMA_CLK_RQT);\n\t\tudelay(20);\n\n\t\t \n\t\tiwl_set_bits_prph(trans, APMG_PCIDEV_STT_REG,\n\t\t\t\t  APMG_PCIDEV_STT_VAL_L1_ACT_DIS);\n\n\t\t \n\t\tiwl_write_prph(trans, APMG_RTC_INT_STT_REG,\n\t\t\t       APMG_RTC_INT_STT_RFKILL);\n\t}\n\n\tset_bit(STATUS_DEVICE_ENABLED, &trans->status);\n\n\treturn 0;\n}\n\n \nstatic void iwl_pcie_apm_lp_xtal_enable(struct iwl_trans *trans)\n{\n\tint ret;\n\tu32 apmg_gp1_reg;\n\tu32 apmg_xtal_cfg_reg;\n\tu32 dl_cfg_reg;\n\n\t \n\t__iwl_trans_pcie_set_bit(trans, CSR_GP_CNTRL,\n\t\t\t\t CSR_GP_CNTRL_REG_FLAG_XTAL_ON);\n\n\tret = iwl_trans_pcie_sw_reset(trans, true);\n\n\tif (!ret)\n\t\tret = iwl_finish_nic_init(trans);\n\n\tif (WARN_ON(ret)) {\n\t\t \n\t\t__iwl_trans_pcie_clear_bit(trans, CSR_GP_CNTRL,\n\t\t\t\t\t   CSR_GP_CNTRL_REG_FLAG_XTAL_ON);\n\t\treturn;\n\t}\n\n\t \n\tiwl_clear_bits_prph(trans, APMG_PCIDEV_STT_REG,\n\t\t\t\t    APMG_PCIDEV_STT_VAL_PERSIST_DIS);\n\n\t \n\tapmg_xtal_cfg_reg = iwl_trans_pcie_read_shr(trans,\n\t\t\t\t\t\t    SHR_APMG_XTAL_CFG_REG);\n\tiwl_trans_pcie_write_shr(trans, SHR_APMG_XTAL_CFG_REG,\n\t\t\t\t apmg_xtal_cfg_reg |\n\t\t\t\t SHR_APMG_XTAL_CFG_XTAL_ON_REQ);\n\n\tret = iwl_trans_pcie_sw_reset(trans, true);\n\tif (ret)\n\t\tIWL_ERR(trans,\n\t\t\t\"iwl_pcie_apm_lp_xtal_enable: failed to retake NIC ownership\\n\");\n\n\t \n\tapmg_gp1_reg = iwl_trans_pcie_read_shr(trans, SHR_APMG_GP1_REG);\n\tiwl_trans_pcie_write_shr(trans, SHR_APMG_GP1_REG, apmg_gp1_reg |\n\t\t\t\t SHR_APMG_GP1_WF_XTAL_LP_EN |\n\t\t\t\t SHR_APMG_GP1_CHICKEN_BIT_SELECT);\n\n\t \n\tdl_cfg_reg = iwl_trans_pcie_read_shr(trans, SHR_APMG_DL_CFG_REG);\n\tiwl_trans_pcie_write_shr(trans, SHR_APMG_DL_CFG_REG, dl_cfg_reg &\n\t\t\t\t ~SHR_APMG_DL_CFG_DL_CLOCK_POWER_UP);\n\n\t \n\tiwl_set_bit(trans, CSR_HW_IF_CONFIG_REG,\n\t\t    CSR_HW_IF_CONFIG_REG_PERSIST_MODE);\n\n\t \n\tiwl_clear_bit(trans, CSR_GP_CNTRL, CSR_GP_CNTRL_REG_FLAG_INIT_DONE);\n\n\t \n\t__iwl_trans_pcie_set_bit(trans, CSR_MONITOR_CFG_REG,\n\t\t\t\t CSR_MONITOR_XTAL_RESOURCES);\n\n\t \n\t__iwl_trans_pcie_clear_bit(trans, CSR_GP_CNTRL,\n\t\t\t\t   CSR_GP_CNTRL_REG_FLAG_XTAL_ON);\n\tudelay(10);\n\n\t \n\tiwl_trans_pcie_write_shr(trans, SHR_APMG_XTAL_CFG_REG,\n\t\t\t\t apmg_xtal_cfg_reg &\n\t\t\t\t ~SHR_APMG_XTAL_CFG_XTAL_ON_REQ);\n}\n\nvoid iwl_pcie_apm_stop_master(struct iwl_trans *trans)\n{\n\tint ret;\n\n\t \n\n\tif (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_BZ) {\n\t\tiwl_set_bit(trans, CSR_GP_CNTRL,\n\t\t\t    CSR_GP_CNTRL_REG_FLAG_BUS_MASTER_DISABLE_REQ);\n\n\t\tret = iwl_poll_bit(trans, CSR_GP_CNTRL,\n\t\t\t\t   CSR_GP_CNTRL_REG_FLAG_BUS_MASTER_DISABLE_STATUS,\n\t\t\t\t   CSR_GP_CNTRL_REG_FLAG_BUS_MASTER_DISABLE_STATUS,\n\t\t\t\t   100);\n\t\tusleep_range(10000, 20000);\n\t} else {\n\t\tiwl_set_bit(trans, CSR_RESET, CSR_RESET_REG_FLAG_STOP_MASTER);\n\n\t\tret = iwl_poll_bit(trans, CSR_RESET,\n\t\t\t\t   CSR_RESET_REG_FLAG_MASTER_DISABLED,\n\t\t\t\t   CSR_RESET_REG_FLAG_MASTER_DISABLED, 100);\n\t}\n\n\tif (ret < 0)\n\t\tIWL_WARN(trans, \"Master Disable Timed Out, 100 usec\\n\");\n\n\tIWL_DEBUG_INFO(trans, \"stop master\\n\");\n}\n\nstatic void iwl_pcie_apm_stop(struct iwl_trans *trans, bool op_mode_leave)\n{\n\tIWL_DEBUG_INFO(trans, \"Stop card, put in low power state\\n\");\n\n\tif (op_mode_leave) {\n\t\tif (!test_bit(STATUS_DEVICE_ENABLED, &trans->status))\n\t\t\tiwl_pcie_apm_init(trans);\n\n\t\t \n\t\tif (trans->trans_cfg->device_family == IWL_DEVICE_FAMILY_7000)\n\t\t\tiwl_set_bits_prph(trans, APMG_PCIDEV_STT_REG,\n\t\t\t\t\t  APMG_PCIDEV_STT_VAL_WAKE_ME);\n\t\telse if (trans->trans_cfg->device_family >=\n\t\t\t IWL_DEVICE_FAMILY_8000) {\n\t\t\tiwl_set_bit(trans, CSR_DBG_LINK_PWR_MGMT_REG,\n\t\t\t\t    CSR_RESET_LINK_PWR_MGMT_DISABLED);\n\t\t\tiwl_set_bit(trans, CSR_HW_IF_CONFIG_REG,\n\t\t\t\t    CSR_HW_IF_CONFIG_REG_PREPARE |\n\t\t\t\t    CSR_HW_IF_CONFIG_REG_ENABLE_PME);\n\t\t\tmdelay(1);\n\t\t\tiwl_clear_bit(trans, CSR_DBG_LINK_PWR_MGMT_REG,\n\t\t\t\t      CSR_RESET_LINK_PWR_MGMT_DISABLED);\n\t\t}\n\t\tmdelay(5);\n\t}\n\n\tclear_bit(STATUS_DEVICE_ENABLED, &trans->status);\n\n\t \n\tiwl_pcie_apm_stop_master(trans);\n\n\tif (trans->cfg->lp_xtal_workaround) {\n\t\tiwl_pcie_apm_lp_xtal_enable(trans);\n\t\treturn;\n\t}\n\n\tiwl_trans_pcie_sw_reset(trans, false);\n\n\t \n\tiwl_clear_bit(trans, CSR_GP_CNTRL, CSR_GP_CNTRL_REG_FLAG_INIT_DONE);\n}\n\nstatic int iwl_pcie_nic_init(struct iwl_trans *trans)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tint ret;\n\n\t \n\tspin_lock_bh(&trans_pcie->irq_lock);\n\tret = iwl_pcie_apm_init(trans);\n\tspin_unlock_bh(&trans_pcie->irq_lock);\n\n\tif (ret)\n\t\treturn ret;\n\n\tiwl_pcie_set_pwr(trans, false);\n\n\tiwl_op_mode_nic_config(trans->op_mode);\n\n\t \n\tret = iwl_pcie_rx_init(trans);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (iwl_pcie_tx_init(trans)) {\n\t\tiwl_pcie_rx_free(trans);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (trans->trans_cfg->base_params->shadow_reg_enable) {\n\t\t \n\t\tiwl_set_bit(trans, CSR_MAC_SHADOW_REG_CTRL, 0x800FFFFF);\n\t\tIWL_DEBUG_INFO(trans, \"Enabling shadow registers in device\\n\");\n\t}\n\n\treturn 0;\n}\n\n#define HW_READY_TIMEOUT (50)\n\n \nstatic int iwl_pcie_set_hw_ready(struct iwl_trans *trans)\n{\n\tint ret;\n\n\tiwl_set_bit(trans, CSR_HW_IF_CONFIG_REG,\n\t\t    CSR_HW_IF_CONFIG_REG_BIT_NIC_READY);\n\n\t \n\tret = iwl_poll_bit(trans, CSR_HW_IF_CONFIG_REG,\n\t\t\t   CSR_HW_IF_CONFIG_REG_BIT_NIC_READY,\n\t\t\t   CSR_HW_IF_CONFIG_REG_BIT_NIC_READY,\n\t\t\t   HW_READY_TIMEOUT);\n\n\tif (ret >= 0)\n\t\tiwl_set_bit(trans, CSR_MBOX_SET_REG, CSR_MBOX_SET_REG_OS_ALIVE);\n\n\tIWL_DEBUG_INFO(trans, \"hardware%s ready\\n\", ret < 0 ? \" not\" : \"\");\n\treturn ret;\n}\n\n \nint iwl_pcie_prepare_card_hw(struct iwl_trans *trans)\n{\n\tint ret;\n\tint iter;\n\n\tIWL_DEBUG_INFO(trans, \"iwl_trans_prepare_card_hw enter\\n\");\n\n\tret = iwl_pcie_set_hw_ready(trans);\n\t \n\tif (ret >= 0) {\n\t\ttrans->csme_own = false;\n\t\treturn 0;\n\t}\n\n\tiwl_set_bit(trans, CSR_DBG_LINK_PWR_MGMT_REG,\n\t\t    CSR_RESET_LINK_PWR_MGMT_DISABLED);\n\tusleep_range(1000, 2000);\n\n\tfor (iter = 0; iter < 10; iter++) {\n\t\tint t = 0;\n\n\t\t \n\t\tiwl_set_bit(trans, CSR_HW_IF_CONFIG_REG,\n\t\t\t    CSR_HW_IF_CONFIG_REG_PREPARE);\n\n\t\tdo {\n\t\t\tret = iwl_pcie_set_hw_ready(trans);\n\t\t\tif (ret >= 0) {\n\t\t\t\ttrans->csme_own = false;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (iwl_mei_is_connected()) {\n\t\t\t\tIWL_DEBUG_INFO(trans,\n\t\t\t\t\t       \"Couldn't prepare the card but SAP is connected\\n\");\n\t\t\t\ttrans->csme_own = true;\n\t\t\t\tif (trans->trans_cfg->device_family !=\n\t\t\t\t    IWL_DEVICE_FAMILY_9000)\n\t\t\t\t\tIWL_ERR(trans,\n\t\t\t\t\t\t\"SAP not supported for this NIC family\\n\");\n\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\n\t\t\tusleep_range(200, 1000);\n\t\t\tt += 200;\n\t\t} while (t < 150000);\n\t\tmsleep(25);\n\t}\n\n\tIWL_ERR(trans, \"Couldn't prepare the card\\n\");\n\n\treturn ret;\n}\n\n \nstatic void iwl_pcie_load_firmware_chunk_fh(struct iwl_trans *trans,\n\t\t\t\t\t    u32 dst_addr, dma_addr_t phy_addr,\n\t\t\t\t\t    u32 byte_cnt)\n{\n\tiwl_write32(trans, FH_TCSR_CHNL_TX_CONFIG_REG(FH_SRVC_CHNL),\n\t\t    FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_PAUSE);\n\n\tiwl_write32(trans, FH_SRVC_CHNL_SRAM_ADDR_REG(FH_SRVC_CHNL),\n\t\t    dst_addr);\n\n\tiwl_write32(trans, FH_TFDIB_CTRL0_REG(FH_SRVC_CHNL),\n\t\t    phy_addr & FH_MEM_TFDIB_DRAM_ADDR_LSB_MSK);\n\n\tiwl_write32(trans, FH_TFDIB_CTRL1_REG(FH_SRVC_CHNL),\n\t\t    (iwl_get_dma_hi_addr(phy_addr)\n\t\t\t<< FH_MEM_TFDIB_REG1_ADDR_BITSHIFT) | byte_cnt);\n\n\tiwl_write32(trans, FH_TCSR_CHNL_TX_BUF_STS_REG(FH_SRVC_CHNL),\n\t\t    BIT(FH_TCSR_CHNL_TX_BUF_STS_REG_POS_TB_NUM) |\n\t\t    BIT(FH_TCSR_CHNL_TX_BUF_STS_REG_POS_TB_IDX) |\n\t\t    FH_TCSR_CHNL_TX_BUF_STS_REG_VAL_TFDB_VALID);\n\n\tiwl_write32(trans, FH_TCSR_CHNL_TX_CONFIG_REG(FH_SRVC_CHNL),\n\t\t    FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_ENABLE |\n\t\t    FH_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_DISABLE |\n\t\t    FH_TCSR_TX_CONFIG_REG_VAL_CIRQ_HOST_ENDTFD);\n}\n\nstatic int iwl_pcie_load_firmware_chunk(struct iwl_trans *trans,\n\t\t\t\t\tu32 dst_addr, dma_addr_t phy_addr,\n\t\t\t\t\tu32 byte_cnt)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tint ret;\n\n\ttrans_pcie->ucode_write_complete = false;\n\n\tif (!iwl_trans_grab_nic_access(trans))\n\t\treturn -EIO;\n\n\tiwl_pcie_load_firmware_chunk_fh(trans, dst_addr, phy_addr,\n\t\t\t\t\tbyte_cnt);\n\tiwl_trans_release_nic_access(trans);\n\n\tret = wait_event_timeout(trans_pcie->ucode_write_waitq,\n\t\t\t\t trans_pcie->ucode_write_complete, 5 * HZ);\n\tif (!ret) {\n\t\tIWL_ERR(trans, \"Failed to load firmware chunk!\\n\");\n\t\tiwl_trans_pcie_dump_regs(trans);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int iwl_pcie_load_section(struct iwl_trans *trans, u8 section_num,\n\t\t\t    const struct fw_desc *section)\n{\n\tu8 *v_addr;\n\tdma_addr_t p_addr;\n\tu32 offset, chunk_sz = min_t(u32, FH_MEM_TB_MAX_LENGTH, section->len);\n\tint ret = 0;\n\n\tIWL_DEBUG_FW(trans, \"[%d] uCode section being loaded...\\n\",\n\t\t     section_num);\n\n\tv_addr = dma_alloc_coherent(trans->dev, chunk_sz, &p_addr,\n\t\t\t\t    GFP_KERNEL | __GFP_NOWARN);\n\tif (!v_addr) {\n\t\tIWL_DEBUG_INFO(trans, \"Falling back to small chunks of DMA\\n\");\n\t\tchunk_sz = PAGE_SIZE;\n\t\tv_addr = dma_alloc_coherent(trans->dev, chunk_sz,\n\t\t\t\t\t    &p_addr, GFP_KERNEL);\n\t\tif (!v_addr)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tfor (offset = 0; offset < section->len; offset += chunk_sz) {\n\t\tu32 copy_size, dst_addr;\n\t\tbool extended_addr = false;\n\n\t\tcopy_size = min_t(u32, chunk_sz, section->len - offset);\n\t\tdst_addr = section->offset + offset;\n\n\t\tif (dst_addr >= IWL_FW_MEM_EXTENDED_START &&\n\t\t    dst_addr <= IWL_FW_MEM_EXTENDED_END)\n\t\t\textended_addr = true;\n\n\t\tif (extended_addr)\n\t\t\tiwl_set_bits_prph(trans, LMPM_CHICK,\n\t\t\t\t\t  LMPM_CHICK_EXTENDED_ADDR_SPACE);\n\n\t\tmemcpy(v_addr, (const u8 *)section->data + offset, copy_size);\n\t\tret = iwl_pcie_load_firmware_chunk(trans, dst_addr, p_addr,\n\t\t\t\t\t\t   copy_size);\n\n\t\tif (extended_addr)\n\t\t\tiwl_clear_bits_prph(trans, LMPM_CHICK,\n\t\t\t\t\t    LMPM_CHICK_EXTENDED_ADDR_SPACE);\n\n\t\tif (ret) {\n\t\t\tIWL_ERR(trans,\n\t\t\t\t\"Could not load the [%d] uCode section\\n\",\n\t\t\t\tsection_num);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdma_free_coherent(trans->dev, chunk_sz, v_addr, p_addr);\n\treturn ret;\n}\n\nstatic int iwl_pcie_load_cpu_sections_8000(struct iwl_trans *trans,\n\t\t\t\t\t   const struct fw_img *image,\n\t\t\t\t\t   int cpu,\n\t\t\t\t\t   int *first_ucode_section)\n{\n\tint shift_param;\n\tint i, ret = 0, sec_num = 0x1;\n\tu32 val, last_read_idx = 0;\n\n\tif (cpu == 1) {\n\t\tshift_param = 0;\n\t\t*first_ucode_section = 0;\n\t} else {\n\t\tshift_param = 16;\n\t\t(*first_ucode_section)++;\n\t}\n\n\tfor (i = *first_ucode_section; i < image->num_sec; i++) {\n\t\tlast_read_idx = i;\n\n\t\t \n\t\tif (!image->sec[i].data ||\n\t\t    image->sec[i].offset == CPU1_CPU2_SEPARATOR_SECTION ||\n\t\t    image->sec[i].offset == PAGING_SEPARATOR_SECTION) {\n\t\t\tIWL_DEBUG_FW(trans,\n\t\t\t\t     \"Break since Data not valid or Empty section, sec = %d\\n\",\n\t\t\t\t     i);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = iwl_pcie_load_section(trans, i, &image->sec[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tval = iwl_read_direct32(trans, FH_UCODE_LOAD_STATUS);\n\t\tval = val | (sec_num << shift_param);\n\t\tiwl_write_direct32(trans, FH_UCODE_LOAD_STATUS, val);\n\n\t\tsec_num = (sec_num << 1) | 0x1;\n\t}\n\n\t*first_ucode_section = last_read_idx;\n\n\tiwl_enable_interrupts(trans);\n\n\tif (trans->trans_cfg->gen2) {\n\t\tif (cpu == 1)\n\t\t\tiwl_write_prph(trans, UREG_UCODE_LOAD_STATUS,\n\t\t\t\t       0xFFFF);\n\t\telse\n\t\t\tiwl_write_prph(trans, UREG_UCODE_LOAD_STATUS,\n\t\t\t\t       0xFFFFFFFF);\n\t} else {\n\t\tif (cpu == 1)\n\t\t\tiwl_write_direct32(trans, FH_UCODE_LOAD_STATUS,\n\t\t\t\t\t   0xFFFF);\n\t\telse\n\t\t\tiwl_write_direct32(trans, FH_UCODE_LOAD_STATUS,\n\t\t\t\t\t   0xFFFFFFFF);\n\t}\n\n\treturn 0;\n}\n\nstatic int iwl_pcie_load_cpu_sections(struct iwl_trans *trans,\n\t\t\t\t      const struct fw_img *image,\n\t\t\t\t      int cpu,\n\t\t\t\t      int *first_ucode_section)\n{\n\tint i, ret = 0;\n\tu32 last_read_idx = 0;\n\n\tif (cpu == 1)\n\t\t*first_ucode_section = 0;\n\telse\n\t\t(*first_ucode_section)++;\n\n\tfor (i = *first_ucode_section; i < image->num_sec; i++) {\n\t\tlast_read_idx = i;\n\n\t\t \n\t\tif (!image->sec[i].data ||\n\t\t    image->sec[i].offset == CPU1_CPU2_SEPARATOR_SECTION ||\n\t\t    image->sec[i].offset == PAGING_SEPARATOR_SECTION) {\n\t\t\tIWL_DEBUG_FW(trans,\n\t\t\t\t     \"Break since Data not valid or Empty section, sec = %d\\n\",\n\t\t\t\t     i);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = iwl_pcie_load_section(trans, i, &image->sec[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t*first_ucode_section = last_read_idx;\n\n\treturn 0;\n}\n\nstatic void iwl_pcie_apply_destination_ini(struct iwl_trans *trans)\n{\n\tenum iwl_fw_ini_allocation_id alloc_id = IWL_FW_INI_ALLOCATION_ID_DBGC1;\n\tstruct iwl_fw_ini_allocation_tlv *fw_mon_cfg =\n\t\t&trans->dbg.fw_mon_cfg[alloc_id];\n\tstruct iwl_dram_data *frag;\n\n\tif (!iwl_trans_dbg_ini_valid(trans))\n\t\treturn;\n\n\tif (le32_to_cpu(fw_mon_cfg->buf_location) ==\n\t    IWL_FW_INI_LOCATION_SRAM_PATH) {\n\t\tIWL_DEBUG_FW(trans, \"WRT: Applying SMEM buffer destination\\n\");\n\t\t \n\t\tiwl_set_bit(trans, CSR_HW_IF_CONFIG_REG,\n\t\t\t    CSR_HW_IF_CONFIG_REG_BIT_MONITOR_SRAM);\n\n\t\treturn;\n\t}\n\n\tif (le32_to_cpu(fw_mon_cfg->buf_location) !=\n\t    IWL_FW_INI_LOCATION_DRAM_PATH ||\n\t    !trans->dbg.fw_mon_ini[alloc_id].num_frags)\n\t\treturn;\n\n\tfrag = &trans->dbg.fw_mon_ini[alloc_id].frags[0];\n\n\tIWL_DEBUG_FW(trans, \"WRT: Applying DRAM destination (alloc_id=%u)\\n\",\n\t\t     alloc_id);\n\n\tiwl_write_umac_prph(trans, MON_BUFF_BASE_ADDR_VER2,\n\t\t\t    frag->physical >> MON_BUFF_SHIFT_VER2);\n\tiwl_write_umac_prph(trans, MON_BUFF_END_ADDR_VER2,\n\t\t\t    (frag->physical + frag->size - 256) >>\n\t\t\t    MON_BUFF_SHIFT_VER2);\n}\n\nvoid iwl_pcie_apply_destination(struct iwl_trans *trans)\n{\n\tconst struct iwl_fw_dbg_dest_tlv_v1 *dest = trans->dbg.dest_tlv;\n\tconst struct iwl_dram_data *fw_mon = &trans->dbg.fw_mon;\n\tint i;\n\n\tif (iwl_trans_dbg_ini_valid(trans)) {\n\t\tiwl_pcie_apply_destination_ini(trans);\n\t\treturn;\n\t}\n\n\tIWL_INFO(trans, \"Applying debug destination %s\\n\",\n\t\t get_fw_dbg_mode_string(dest->monitor_mode));\n\n\tif (dest->monitor_mode == EXTERNAL_MODE)\n\t\tiwl_pcie_alloc_fw_monitor(trans, dest->size_power);\n\telse\n\t\tIWL_WARN(trans, \"PCI should have external buffer debug\\n\");\n\n\tfor (i = 0; i < trans->dbg.n_dest_reg; i++) {\n\t\tu32 addr = le32_to_cpu(dest->reg_ops[i].addr);\n\t\tu32 val = le32_to_cpu(dest->reg_ops[i].val);\n\n\t\tswitch (dest->reg_ops[i].op) {\n\t\tcase CSR_ASSIGN:\n\t\t\tiwl_write32(trans, addr, val);\n\t\t\tbreak;\n\t\tcase CSR_SETBIT:\n\t\t\tiwl_set_bit(trans, addr, BIT(val));\n\t\t\tbreak;\n\t\tcase CSR_CLEARBIT:\n\t\t\tiwl_clear_bit(trans, addr, BIT(val));\n\t\t\tbreak;\n\t\tcase PRPH_ASSIGN:\n\t\t\tiwl_write_prph(trans, addr, val);\n\t\t\tbreak;\n\t\tcase PRPH_SETBIT:\n\t\t\tiwl_set_bits_prph(trans, addr, BIT(val));\n\t\t\tbreak;\n\t\tcase PRPH_CLEARBIT:\n\t\t\tiwl_clear_bits_prph(trans, addr, BIT(val));\n\t\t\tbreak;\n\t\tcase PRPH_BLOCKBIT:\n\t\t\tif (iwl_read_prph(trans, addr) & BIT(val)) {\n\t\t\t\tIWL_ERR(trans,\n\t\t\t\t\t\"BIT(%u) in address 0x%x is 1, stopping FW configuration\\n\",\n\t\t\t\t\tval, addr);\n\t\t\t\tgoto monitor;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tIWL_ERR(trans, \"FW debug - unknown OP %d\\n\",\n\t\t\t\tdest->reg_ops[i].op);\n\t\t\tbreak;\n\t\t}\n\t}\n\nmonitor:\n\tif (dest->monitor_mode == EXTERNAL_MODE && fw_mon->size) {\n\t\tiwl_write_prph(trans, le32_to_cpu(dest->base_reg),\n\t\t\t       fw_mon->physical >> dest->base_shift);\n\t\tif (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_8000)\n\t\t\tiwl_write_prph(trans, le32_to_cpu(dest->end_reg),\n\t\t\t\t       (fw_mon->physical + fw_mon->size -\n\t\t\t\t\t256) >> dest->end_shift);\n\t\telse\n\t\t\tiwl_write_prph(trans, le32_to_cpu(dest->end_reg),\n\t\t\t\t       (fw_mon->physical + fw_mon->size) >>\n\t\t\t\t       dest->end_shift);\n\t}\n}\n\nstatic int iwl_pcie_load_given_ucode(struct iwl_trans *trans,\n\t\t\t\tconst struct fw_img *image)\n{\n\tint ret = 0;\n\tint first_ucode_section;\n\n\tIWL_DEBUG_FW(trans, \"working with %s CPU\\n\",\n\t\t     image->is_dual_cpus ? \"Dual\" : \"Single\");\n\n\t \n\tret = iwl_pcie_load_cpu_sections(trans, image, 1, &first_ucode_section);\n\tif (ret)\n\t\treturn ret;\n\n\tif (image->is_dual_cpus) {\n\t\t \n\t\tiwl_write_prph(trans,\n\t\t\t       LMPM_SECURE_UCODE_LOAD_CPU2_HDR_ADDR,\n\t\t\t       LMPM_SECURE_CPU2_HDR_MEM_SPACE);\n\n\t\t \n\t\tret = iwl_pcie_load_cpu_sections(trans, image, 2,\n\t\t\t\t\t\t &first_ucode_section);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (iwl_pcie_dbg_on(trans))\n\t\tiwl_pcie_apply_destination(trans);\n\n\tiwl_enable_interrupts(trans);\n\n\t \n\tiwl_write32(trans, CSR_RESET, 0);\n\n\treturn 0;\n}\n\nstatic int iwl_pcie_load_given_ucode_8000(struct iwl_trans *trans,\n\t\t\t\t\t  const struct fw_img *image)\n{\n\tint ret = 0;\n\tint first_ucode_section;\n\n\tIWL_DEBUG_FW(trans, \"working with %s CPU\\n\",\n\t\t     image->is_dual_cpus ? \"Dual\" : \"Single\");\n\n\tif (iwl_pcie_dbg_on(trans))\n\t\tiwl_pcie_apply_destination(trans);\n\n\tIWL_DEBUG_POWER(trans, \"Original WFPM value = 0x%08X\\n\",\n\t\t\tiwl_read_prph(trans, WFPM_GP2));\n\n\t \n\tiwl_write_prph(trans, WFPM_GP2, 0x01010101);\n\n\t \n\t \n\tiwl_write_prph(trans, RELEASE_CPU_RESET, RELEASE_CPU_RESET_BIT);\n\n\t \n\tret = iwl_pcie_load_cpu_sections_8000(trans, image, 1,\n\t\t\t\t\t      &first_ucode_section);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn iwl_pcie_load_cpu_sections_8000(trans, image, 2,\n\t\t\t\t\t       &first_ucode_section);\n}\n\nbool iwl_pcie_check_hw_rf_kill(struct iwl_trans *trans)\n{\n\tstruct iwl_trans_pcie *trans_pcie =  IWL_TRANS_GET_PCIE_TRANS(trans);\n\tbool hw_rfkill = iwl_is_rfkill_set(trans);\n\tbool prev = test_bit(STATUS_RFKILL_OPMODE, &trans->status);\n\tbool report;\n\n\tif (hw_rfkill) {\n\t\tset_bit(STATUS_RFKILL_HW, &trans->status);\n\t\tset_bit(STATUS_RFKILL_OPMODE, &trans->status);\n\t} else {\n\t\tclear_bit(STATUS_RFKILL_HW, &trans->status);\n\t\tif (trans_pcie->opmode_down)\n\t\t\tclear_bit(STATUS_RFKILL_OPMODE, &trans->status);\n\t}\n\n\treport = test_bit(STATUS_RFKILL_OPMODE, &trans->status);\n\n\tif (prev != report)\n\t\tiwl_trans_pcie_rf_kill(trans, report, false);\n\n\treturn hw_rfkill;\n}\n\nstruct iwl_causes_list {\n\tu16 mask_reg;\n\tu8 bit;\n\tu8 addr;\n};\n\n#define IWL_CAUSE(reg, mask)\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.mask_reg = reg,\t\t\t\t\t\\\n\t\t.bit = ilog2(mask),\t\t\t\t\t\\\n\t\t.addr = ilog2(mask) +\t\t\t\t\t\\\n\t\t\t((reg) == CSR_MSIX_FH_INT_MASK_AD ? -16 :\t\\\n\t\t\t (reg) == CSR_MSIX_HW_INT_MASK_AD ? 16 :\t\\\n\t\t\t 0xffff),\t \t\\\n\t}\n\nstatic const struct iwl_causes_list causes_list_common[] = {\n\tIWL_CAUSE(CSR_MSIX_FH_INT_MASK_AD, MSIX_FH_INT_CAUSES_D2S_CH0_NUM),\n\tIWL_CAUSE(CSR_MSIX_FH_INT_MASK_AD, MSIX_FH_INT_CAUSES_D2S_CH1_NUM),\n\tIWL_CAUSE(CSR_MSIX_FH_INT_MASK_AD, MSIX_FH_INT_CAUSES_S2D),\n\tIWL_CAUSE(CSR_MSIX_FH_INT_MASK_AD, MSIX_FH_INT_CAUSES_FH_ERR),\n\tIWL_CAUSE(CSR_MSIX_HW_INT_MASK_AD, MSIX_HW_INT_CAUSES_REG_ALIVE),\n\tIWL_CAUSE(CSR_MSIX_HW_INT_MASK_AD, MSIX_HW_INT_CAUSES_REG_WAKEUP),\n\tIWL_CAUSE(CSR_MSIX_HW_INT_MASK_AD, MSIX_HW_INT_CAUSES_REG_RESET_DONE),\n\tIWL_CAUSE(CSR_MSIX_HW_INT_MASK_AD, MSIX_HW_INT_CAUSES_REG_CT_KILL),\n\tIWL_CAUSE(CSR_MSIX_HW_INT_MASK_AD, MSIX_HW_INT_CAUSES_REG_RF_KILL),\n\tIWL_CAUSE(CSR_MSIX_HW_INT_MASK_AD, MSIX_HW_INT_CAUSES_REG_PERIODIC),\n\tIWL_CAUSE(CSR_MSIX_HW_INT_MASK_AD, MSIX_HW_INT_CAUSES_REG_SCD),\n\tIWL_CAUSE(CSR_MSIX_HW_INT_MASK_AD, MSIX_HW_INT_CAUSES_REG_FH_TX),\n\tIWL_CAUSE(CSR_MSIX_HW_INT_MASK_AD, MSIX_HW_INT_CAUSES_REG_HW_ERR),\n\tIWL_CAUSE(CSR_MSIX_HW_INT_MASK_AD, MSIX_HW_INT_CAUSES_REG_HAP),\n};\n\nstatic const struct iwl_causes_list causes_list_pre_bz[] = {\n\tIWL_CAUSE(CSR_MSIX_HW_INT_MASK_AD, MSIX_HW_INT_CAUSES_REG_SW_ERR),\n};\n\nstatic const struct iwl_causes_list causes_list_bz[] = {\n\tIWL_CAUSE(CSR_MSIX_HW_INT_MASK_AD, MSIX_HW_INT_CAUSES_REG_SW_ERR_BZ),\n};\n\nstatic void iwl_pcie_map_list(struct iwl_trans *trans,\n\t\t\t      const struct iwl_causes_list *causes,\n\t\t\t      int arr_size, int val)\n{\n\tint i;\n\n\tfor (i = 0; i < arr_size; i++) {\n\t\tiwl_write8(trans, CSR_MSIX_IVAR(causes[i].addr), val);\n\t\tiwl_clear_bit(trans, causes[i].mask_reg,\n\t\t\t      BIT(causes[i].bit));\n\t}\n}\n\nstatic void iwl_pcie_map_non_rx_causes(struct iwl_trans *trans)\n{\n\tstruct iwl_trans_pcie *trans_pcie =  IWL_TRANS_GET_PCIE_TRANS(trans);\n\tint val = trans_pcie->def_irq | MSIX_NON_AUTO_CLEAR_CAUSE;\n\t \n\tiwl_pcie_map_list(trans, causes_list_common,\n\t\t\t  ARRAY_SIZE(causes_list_common), val);\n\tif (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_BZ)\n\t\tiwl_pcie_map_list(trans, causes_list_bz,\n\t\t\t\t  ARRAY_SIZE(causes_list_bz), val);\n\telse\n\t\tiwl_pcie_map_list(trans, causes_list_pre_bz,\n\t\t\t\t  ARRAY_SIZE(causes_list_pre_bz), val);\n}\n\nstatic void iwl_pcie_map_rx_causes(struct iwl_trans *trans)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tu32 offset =\n\t\ttrans_pcie->shared_vec_mask & IWL_SHARED_IRQ_FIRST_RSS ? 1 : 0;\n\tu32 val, idx;\n\n\t \n\tval = BIT(MSIX_FH_INT_CAUSES_Q(0));\n\tfor (idx = 1; idx < trans->num_rx_queues; idx++) {\n\t\tiwl_write8(trans, CSR_MSIX_RX_IVAR(idx),\n\t\t\t   MSIX_FH_INT_CAUSES_Q(idx - offset));\n\t\tval |= BIT(MSIX_FH_INT_CAUSES_Q(idx));\n\t}\n\tiwl_write32(trans, CSR_MSIX_FH_INT_MASK_AD, ~val);\n\n\tval = MSIX_FH_INT_CAUSES_Q(0);\n\tif (trans_pcie->shared_vec_mask & IWL_SHARED_IRQ_NON_RX)\n\t\tval |= MSIX_NON_AUTO_CLEAR_CAUSE;\n\tiwl_write8(trans, CSR_MSIX_RX_IVAR(0), val);\n\n\tif (trans_pcie->shared_vec_mask & IWL_SHARED_IRQ_FIRST_RSS)\n\t\tiwl_write8(trans, CSR_MSIX_RX_IVAR(1), val);\n}\n\nvoid iwl_pcie_conf_msix_hw(struct iwl_trans_pcie *trans_pcie)\n{\n\tstruct iwl_trans *trans = trans_pcie->trans;\n\n\tif (!trans_pcie->msix_enabled) {\n\t\tif (trans->trans_cfg->mq_rx_supported &&\n\t\t    test_bit(STATUS_DEVICE_ENABLED, &trans->status))\n\t\t\tiwl_write_umac_prph(trans, UREG_CHICK,\n\t\t\t\t\t    UREG_CHICK_MSI_ENABLE);\n\t\treturn;\n\t}\n\t \n\tif (test_bit(STATUS_DEVICE_ENABLED, &trans->status))\n\t\tiwl_write_umac_prph(trans, UREG_CHICK, UREG_CHICK_MSIX_ENABLE);\n\n\t \n\tiwl_pcie_map_rx_causes(trans);\n\n\tiwl_pcie_map_non_rx_causes(trans);\n}\n\nstatic void iwl_pcie_init_msix(struct iwl_trans_pcie *trans_pcie)\n{\n\tstruct iwl_trans *trans = trans_pcie->trans;\n\n\tiwl_pcie_conf_msix_hw(trans_pcie);\n\n\tif (!trans_pcie->msix_enabled)\n\t\treturn;\n\n\ttrans_pcie->fh_init_mask = ~iwl_read32(trans, CSR_MSIX_FH_INT_MASK_AD);\n\ttrans_pcie->fh_mask = trans_pcie->fh_init_mask;\n\ttrans_pcie->hw_init_mask = ~iwl_read32(trans, CSR_MSIX_HW_INT_MASK_AD);\n\ttrans_pcie->hw_mask = trans_pcie->hw_init_mask;\n}\n\nstatic void _iwl_trans_pcie_stop_device(struct iwl_trans *trans, bool from_irq)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\n\tlockdep_assert_held(&trans_pcie->mutex);\n\n\tif (trans_pcie->is_down)\n\t\treturn;\n\n\ttrans_pcie->is_down = true;\n\n\t \n\tiwl_disable_interrupts(trans);\n\n\t \n\tiwl_pcie_disable_ict(trans);\n\n\t \n\tif (test_and_clear_bit(STATUS_DEVICE_ENABLED, &trans->status)) {\n\t\tIWL_DEBUG_INFO(trans,\n\t\t\t       \"DEVICE_ENABLED bit was set and is now cleared\\n\");\n\t\tif (!from_irq)\n\t\t\tiwl_pcie_synchronize_irqs(trans);\n\t\tiwl_pcie_rx_napi_sync(trans);\n\t\tiwl_pcie_tx_stop(trans);\n\t\tiwl_pcie_rx_stop(trans);\n\n\t\t \n\t\tif (!trans->cfg->apmg_not_supported) {\n\t\t\tiwl_write_prph(trans, APMG_CLK_DIS_REG,\n\t\t\t\t       APMG_CLK_VAL_DMA_CLK_RQT);\n\t\t\tudelay(5);\n\t\t}\n\t}\n\n\t \n\tif (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_BZ)\n\t\tiwl_clear_bit(trans, CSR_GP_CNTRL,\n\t\t\t      CSR_GP_CNTRL_REG_FLAG_BZ_MAC_ACCESS_REQ);\n\telse\n\t\tiwl_clear_bit(trans, CSR_GP_CNTRL,\n\t\t\t      CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);\n\n\t \n\tiwl_pcie_apm_stop(trans, false);\n\n\t \n\tiwl_trans_pcie_sw_reset(trans, true);\n\n\t \n\tiwl_pcie_conf_msix_hw(trans_pcie);\n\n\t \n\tiwl_disable_interrupts(trans);\n\n\t \n\tclear_bit(STATUS_SYNC_HCMD_ACTIVE, &trans->status);\n\tclear_bit(STATUS_INT_ENABLED, &trans->status);\n\tclear_bit(STATUS_TPOWER_PMI, &trans->status);\n\n\t \n\tiwl_enable_rfkill_int(trans);\n}\n\nvoid iwl_pcie_synchronize_irqs(struct iwl_trans *trans)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\n\tif (trans_pcie->msix_enabled) {\n\t\tint i;\n\n\t\tfor (i = 0; i < trans_pcie->alloc_vecs; i++)\n\t\t\tsynchronize_irq(trans_pcie->msix_entries[i].vector);\n\t} else {\n\t\tsynchronize_irq(trans_pcie->pci_dev->irq);\n\t}\n}\n\nstatic int iwl_trans_pcie_start_fw(struct iwl_trans *trans,\n\t\t\t\t   const struct fw_img *fw, bool run_in_rfkill)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tbool hw_rfkill;\n\tint ret;\n\n\t \n\tif (iwl_pcie_prepare_card_hw(trans)) {\n\t\tIWL_WARN(trans, \"Exit HW not ready\\n\");\n\t\treturn -EIO;\n\t}\n\n\tiwl_enable_rfkill_int(trans);\n\n\tiwl_write32(trans, CSR_INT, 0xFFFFFFFF);\n\n\t \n\tiwl_disable_interrupts(trans);\n\n\t \n\tiwl_pcie_synchronize_irqs(trans);\n\n\tmutex_lock(&trans_pcie->mutex);\n\n\t \n\thw_rfkill = iwl_pcie_check_hw_rf_kill(trans);\n\tif (hw_rfkill && !run_in_rfkill) {\n\t\tret = -ERFKILL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (trans_pcie->is_down) {\n\t\tIWL_WARN(trans,\n\t\t\t \"Can't start_fw since the HW hasn't been started\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tiwl_write32(trans, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_SW_BIT_RFKILL);\n\tiwl_write32(trans, CSR_UCODE_DRV_GP1_CLR,\n\t\t    CSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED);\n\n\t \n\tiwl_write32(trans, CSR_INT, 0xFFFFFFFF);\n\n\tret = iwl_pcie_nic_init(trans);\n\tif (ret) {\n\t\tIWL_ERR(trans, \"Unable to init nic\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tiwl_enable_fw_load_int(trans);\n\n\t \n\tiwl_write32(trans, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_SW_BIT_RFKILL);\n\tiwl_write32(trans, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_SW_BIT_RFKILL);\n\n\t \n\tif (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_8000)\n\t\tret = iwl_pcie_load_given_ucode_8000(trans, fw);\n\telse\n\t\tret = iwl_pcie_load_given_ucode(trans, fw);\n\n\t \n\thw_rfkill = iwl_pcie_check_hw_rf_kill(trans);\n\tif (hw_rfkill && !run_in_rfkill)\n\t\tret = -ERFKILL;\n\nout:\n\tmutex_unlock(&trans_pcie->mutex);\n\treturn ret;\n}\n\nstatic void iwl_trans_pcie_fw_alive(struct iwl_trans *trans, u32 scd_addr)\n{\n\tiwl_pcie_reset_ict(trans);\n\tiwl_pcie_tx_start(trans, scd_addr);\n}\n\nvoid iwl_trans_pcie_handle_stop_rfkill(struct iwl_trans *trans,\n\t\t\t\t       bool was_in_rfkill)\n{\n\tbool hw_rfkill;\n\n\t \n\thw_rfkill = iwl_is_rfkill_set(trans);\n\tif (hw_rfkill) {\n\t\tset_bit(STATUS_RFKILL_HW, &trans->status);\n\t\tset_bit(STATUS_RFKILL_OPMODE, &trans->status);\n\t} else {\n\t\tclear_bit(STATUS_RFKILL_HW, &trans->status);\n\t\tclear_bit(STATUS_RFKILL_OPMODE, &trans->status);\n\t}\n\tif (hw_rfkill != was_in_rfkill)\n\t\tiwl_trans_pcie_rf_kill(trans, hw_rfkill, false);\n}\n\nstatic void iwl_trans_pcie_stop_device(struct iwl_trans *trans)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tbool was_in_rfkill;\n\n\tiwl_op_mode_time_point(trans->op_mode,\n\t\t\t       IWL_FW_INI_TIME_POINT_HOST_DEVICE_DISABLE,\n\t\t\t       NULL);\n\n\tmutex_lock(&trans_pcie->mutex);\n\ttrans_pcie->opmode_down = true;\n\twas_in_rfkill = test_bit(STATUS_RFKILL_OPMODE, &trans->status);\n\t_iwl_trans_pcie_stop_device(trans, false);\n\tiwl_trans_pcie_handle_stop_rfkill(trans, was_in_rfkill);\n\tmutex_unlock(&trans_pcie->mutex);\n}\n\nvoid iwl_trans_pcie_rf_kill(struct iwl_trans *trans, bool state, bool from_irq)\n{\n\tstruct iwl_trans_pcie __maybe_unused *trans_pcie =\n\t\tIWL_TRANS_GET_PCIE_TRANS(trans);\n\n\tlockdep_assert_held(&trans_pcie->mutex);\n\n\tIWL_WARN(trans, \"reporting RF_KILL (radio %s)\\n\",\n\t\t state ? \"disabled\" : \"enabled\");\n\tif (iwl_op_mode_hw_rf_kill(trans->op_mode, state)) {\n\t\tif (trans->trans_cfg->gen2)\n\t\t\t_iwl_trans_pcie_gen2_stop_device(trans);\n\t\telse\n\t\t\t_iwl_trans_pcie_stop_device(trans, from_irq);\n\t}\n}\n\nvoid iwl_pcie_d3_complete_suspend(struct iwl_trans *trans,\n\t\t\t\t  bool test, bool reset)\n{\n\tiwl_disable_interrupts(trans);\n\n\t \n\tif (test)\n\t\treturn;\n\n\tiwl_pcie_disable_ict(trans);\n\n\tiwl_pcie_synchronize_irqs(trans);\n\n\tiwl_clear_bit(trans, CSR_GP_CNTRL,\n\t\t      CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);\n\tiwl_clear_bit(trans, CSR_GP_CNTRL, CSR_GP_CNTRL_REG_FLAG_INIT_DONE);\n\n\tif (reset) {\n\t\t \n\t\tiwl_trans_pcie_tx_reset(trans);\n\t}\n\n\tiwl_pcie_set_pwr(trans, true);\n}\n\nstatic int iwl_pcie_d3_handshake(struct iwl_trans *trans, bool suspend)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tint ret;\n\n\tif (trans->trans_cfg->device_family == IWL_DEVICE_FAMILY_AX210)\n\t\tiwl_write_umac_prph(trans, UREG_DOORBELL_TO_ISR6,\n\t\t\t\t    suspend ? UREG_DOORBELL_TO_ISR6_SUSPEND :\n\t\t\t\t\t      UREG_DOORBELL_TO_ISR6_RESUME);\n\telse if (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_BZ)\n\t\tiwl_write32(trans, CSR_IPC_SLEEP_CONTROL,\n\t\t\t    suspend ? CSR_IPC_SLEEP_CONTROL_SUSPEND :\n\t\t\t\t      CSR_IPC_SLEEP_CONTROL_RESUME);\n\telse\n\t\treturn 0;\n\n\tret = wait_event_timeout(trans_pcie->sx_waitq,\n\t\t\t\t trans_pcie->sx_complete, 2 * HZ);\n\n\t \n\ttrans_pcie->sx_complete = false;\n\n\tif (!ret) {\n\t\tIWL_ERR(trans, \"Timeout %s D3\\n\",\n\t\t\tsuspend ? \"entering\" : \"exiting\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int iwl_trans_pcie_d3_suspend(struct iwl_trans *trans, bool test,\n\t\t\t\t     bool reset)\n{\n\tint ret;\n\n\tif (!reset)\n\t\t \n\t\tiwl_set_bit(trans, CSR_HW_IF_CONFIG_REG,\n\t\t\t    CSR_HW_IF_CONFIG_REG_PERSIST_MODE);\n\n\tret = iwl_pcie_d3_handshake(trans, true);\n\tif (ret)\n\t\treturn ret;\n\n\tiwl_pcie_d3_complete_suspend(trans, test, reset);\n\n\treturn 0;\n}\n\nstatic int iwl_trans_pcie_d3_resume(struct iwl_trans *trans,\n\t\t\t\t    enum iwl_d3_status *status,\n\t\t\t\t    bool test,  bool reset)\n{\n\tstruct iwl_trans_pcie *trans_pcie =  IWL_TRANS_GET_PCIE_TRANS(trans);\n\tu32 val;\n\tint ret;\n\n\tif (test) {\n\t\tiwl_enable_interrupts(trans);\n\t\t*status = IWL_D3_STATUS_ALIVE;\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tiwl_set_bit(trans, CSR_GP_CNTRL,\n\t\t    CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);\n\n\tret = iwl_finish_nic_init(trans);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tiwl_pcie_conf_msix_hw(trans_pcie);\n\tif (!trans_pcie->msix_enabled)\n\t\tiwl_pcie_reset_ict(trans);\n\tiwl_enable_interrupts(trans);\n\n\tiwl_pcie_set_pwr(trans, false);\n\n\tif (!reset) {\n\t\tiwl_clear_bit(trans, CSR_GP_CNTRL,\n\t\t\t      CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);\n\t} else {\n\t\tiwl_trans_pcie_tx_reset(trans);\n\n\t\tret = iwl_pcie_rx_init(trans);\n\t\tif (ret) {\n\t\t\tIWL_ERR(trans,\n\t\t\t\t\"Failed to resume the device (RX reset)\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tIWL_DEBUG_POWER(trans, \"WFPM value upon resume = 0x%08X\\n\",\n\t\t\tiwl_read_umac_prph(trans, WFPM_GP2));\n\n\tval = iwl_read32(trans, CSR_RESET);\n\tif (val & CSR_RESET_REG_FLAG_NEVO_RESET)\n\t\t*status = IWL_D3_STATUS_RESET;\n\telse\n\t\t*status = IWL_D3_STATUS_ALIVE;\n\nout:\n\tif (*status == IWL_D3_STATUS_ALIVE)\n\t\tret = iwl_pcie_d3_handshake(trans, false);\n\n\treturn ret;\n}\n\nstatic void\niwl_pcie_set_interrupt_capa(struct pci_dev *pdev,\n\t\t\t    struct iwl_trans *trans,\n\t\t\t    const struct iwl_cfg_trans_params *cfg_trans)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tint max_irqs, num_irqs, i, ret;\n\tu16 pci_cmd;\n\tu32 max_rx_queues = IWL_MAX_RX_HW_QUEUES;\n\n\tif (!cfg_trans->mq_rx_supported)\n\t\tgoto enable_msi;\n\n\tif (cfg_trans->device_family <= IWL_DEVICE_FAMILY_9000)\n\t\tmax_rx_queues = IWL_9000_MAX_RX_HW_QUEUES;\n\n\tmax_irqs = min_t(u32, num_online_cpus() + 2, max_rx_queues);\n\tfor (i = 0; i < max_irqs; i++)\n\t\ttrans_pcie->msix_entries[i].entry = i;\n\n\tnum_irqs = pci_enable_msix_range(pdev, trans_pcie->msix_entries,\n\t\t\t\t\t MSIX_MIN_INTERRUPT_VECTORS,\n\t\t\t\t\t max_irqs);\n\tif (num_irqs < 0) {\n\t\tIWL_DEBUG_INFO(trans,\n\t\t\t       \"Failed to enable msi-x mode (ret %d). Moving to msi mode.\\n\",\n\t\t\t       num_irqs);\n\t\tgoto enable_msi;\n\t}\n\ttrans_pcie->def_irq = (num_irqs == max_irqs) ? num_irqs - 1 : 0;\n\n\tIWL_DEBUG_INFO(trans,\n\t\t       \"MSI-X enabled. %d interrupt vectors were allocated\\n\",\n\t\t       num_irqs);\n\n\t \n\tif (num_irqs <= max_irqs - 2) {\n\t\ttrans_pcie->trans->num_rx_queues = num_irqs + 1;\n\t\ttrans_pcie->shared_vec_mask = IWL_SHARED_IRQ_NON_RX |\n\t\t\tIWL_SHARED_IRQ_FIRST_RSS;\n\t} else if (num_irqs == max_irqs - 1) {\n\t\ttrans_pcie->trans->num_rx_queues = num_irqs;\n\t\ttrans_pcie->shared_vec_mask = IWL_SHARED_IRQ_NON_RX;\n\t} else {\n\t\ttrans_pcie->trans->num_rx_queues = num_irqs - 1;\n\t}\n\n\tIWL_DEBUG_INFO(trans,\n\t\t       \"MSI-X enabled with rx queues %d, vec mask 0x%x\\n\",\n\t\t       trans_pcie->trans->num_rx_queues, trans_pcie->shared_vec_mask);\n\n\tWARN_ON(trans_pcie->trans->num_rx_queues > IWL_MAX_RX_HW_QUEUES);\n\n\ttrans_pcie->alloc_vecs = num_irqs;\n\ttrans_pcie->msix_enabled = true;\n\treturn;\n\nenable_msi:\n\tret = pci_enable_msi(pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"pci_enable_msi failed - %d\\n\", ret);\n\t\t \n\t\tpci_read_config_word(pdev, PCI_COMMAND, &pci_cmd);\n\t\tif (pci_cmd & PCI_COMMAND_INTX_DISABLE) {\n\t\t\tpci_cmd &= ~PCI_COMMAND_INTX_DISABLE;\n\t\t\tpci_write_config_word(pdev, PCI_COMMAND, pci_cmd);\n\t\t}\n\t}\n}\n\nstatic void iwl_pcie_irq_set_affinity(struct iwl_trans *trans)\n{\n\tint iter_rx_q, i, ret, cpu, offset;\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\n\ti = trans_pcie->shared_vec_mask & IWL_SHARED_IRQ_FIRST_RSS ? 0 : 1;\n\titer_rx_q = trans_pcie->trans->num_rx_queues - 1 + i;\n\toffset = 1 + i;\n\tfor (; i < iter_rx_q ; i++) {\n\t\t \n\t\tcpu = cpumask_next(i - offset, cpu_online_mask);\n\t\tcpumask_set_cpu(cpu, &trans_pcie->affinity_mask[i]);\n\t\tret = irq_set_affinity_hint(trans_pcie->msix_entries[i].vector,\n\t\t\t\t\t    &trans_pcie->affinity_mask[i]);\n\t\tif (ret)\n\t\t\tIWL_ERR(trans_pcie->trans,\n\t\t\t\t\"Failed to set affinity mask for IRQ %d\\n\",\n\t\t\t\ttrans_pcie->msix_entries[i].vector);\n\t}\n}\n\nstatic int iwl_pcie_init_msix_handler(struct pci_dev *pdev,\n\t\t\t\t      struct iwl_trans_pcie *trans_pcie)\n{\n\tint i;\n\n\tfor (i = 0; i < trans_pcie->alloc_vecs; i++) {\n\t\tint ret;\n\t\tstruct msix_entry *msix_entry;\n\t\tconst char *qname = queue_name(&pdev->dev, trans_pcie, i);\n\n\t\tif (!qname)\n\t\t\treturn -ENOMEM;\n\n\t\tmsix_entry = &trans_pcie->msix_entries[i];\n\t\tret = devm_request_threaded_irq(&pdev->dev,\n\t\t\t\t\t\tmsix_entry->vector,\n\t\t\t\t\t\tiwl_pcie_msix_isr,\n\t\t\t\t\t\t(i == trans_pcie->def_irq) ?\n\t\t\t\t\t\tiwl_pcie_irq_msix_handler :\n\t\t\t\t\t\tiwl_pcie_irq_rx_msix_handler,\n\t\t\t\t\t\tIRQF_SHARED,\n\t\t\t\t\t\tqname,\n\t\t\t\t\t\tmsix_entry);\n\t\tif (ret) {\n\t\t\tIWL_ERR(trans_pcie->trans,\n\t\t\t\t\"Error allocating IRQ %d\\n\", i);\n\n\t\t\treturn ret;\n\t\t}\n\t}\n\tiwl_pcie_irq_set_affinity(trans_pcie->trans);\n\n\treturn 0;\n}\n\nstatic int iwl_trans_pcie_clear_persistence_bit(struct iwl_trans *trans)\n{\n\tu32 hpm, wprot;\n\n\tswitch (trans->trans_cfg->device_family) {\n\tcase IWL_DEVICE_FAMILY_9000:\n\t\twprot = PREG_PRPH_WPROT_9000;\n\t\tbreak;\n\tcase IWL_DEVICE_FAMILY_22000:\n\t\twprot = PREG_PRPH_WPROT_22000;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\thpm = iwl_read_umac_prph_no_grab(trans, HPM_DEBUG);\n\tif (!iwl_trans_is_hw_error_value(hpm) && (hpm & PERSISTENCE_BIT)) {\n\t\tu32 wprot_val = iwl_read_umac_prph_no_grab(trans, wprot);\n\n\t\tif (wprot_val & PREG_WFPM_ACCESS) {\n\t\t\tIWL_ERR(trans,\n\t\t\t\t\"Error, can not clear persistence bit\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tiwl_write_umac_prph_no_grab(trans, HPM_DEBUG,\n\t\t\t\t\t    hpm & ~PERSISTENCE_BIT);\n\t}\n\n\treturn 0;\n}\n\nstatic int iwl_pcie_gen2_force_power_gating(struct iwl_trans *trans)\n{\n\tint ret;\n\n\tret = iwl_finish_nic_init(trans);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tiwl_set_bits_prph(trans, HPM_HIPM_GEN_CFG,\n\t\t\t  HPM_HIPM_GEN_CFG_CR_FORCE_ACTIVE);\n\tudelay(20);\n\tiwl_set_bits_prph(trans, HPM_HIPM_GEN_CFG,\n\t\t\t  HPM_HIPM_GEN_CFG_CR_PG_EN |\n\t\t\t  HPM_HIPM_GEN_CFG_CR_SLP_EN);\n\tudelay(20);\n\tiwl_clear_bits_prph(trans, HPM_HIPM_GEN_CFG,\n\t\t\t    HPM_HIPM_GEN_CFG_CR_FORCE_ACTIVE);\n\n\treturn iwl_trans_pcie_sw_reset(trans, true);\n}\n\nstatic int _iwl_trans_pcie_start_hw(struct iwl_trans *trans)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tint err;\n\n\tlockdep_assert_held(&trans_pcie->mutex);\n\n\terr = iwl_pcie_prepare_card_hw(trans);\n\tif (err) {\n\t\tIWL_ERR(trans, \"Error while preparing HW: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = iwl_trans_pcie_clear_persistence_bit(trans);\n\tif (err)\n\t\treturn err;\n\n\terr = iwl_trans_pcie_sw_reset(trans, true);\n\tif (err)\n\t\treturn err;\n\n\tif (trans->trans_cfg->device_family == IWL_DEVICE_FAMILY_22000 &&\n\t    trans->trans_cfg->integrated) {\n\t\terr = iwl_pcie_gen2_force_power_gating(trans);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = iwl_pcie_apm_init(trans);\n\tif (err)\n\t\treturn err;\n\n\tiwl_pcie_init_msix(trans_pcie);\n\n\t \n\tiwl_enable_rfkill_int(trans);\n\n\ttrans_pcie->opmode_down = false;\n\n\t \n\ttrans_pcie->is_down = false;\n\n\t \n\tiwl_pcie_check_hw_rf_kill(trans);\n\n\treturn 0;\n}\n\nstatic int iwl_trans_pcie_start_hw(struct iwl_trans *trans)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tint ret;\n\n\tmutex_lock(&trans_pcie->mutex);\n\tret = _iwl_trans_pcie_start_hw(trans);\n\tmutex_unlock(&trans_pcie->mutex);\n\n\treturn ret;\n}\n\nstatic void iwl_trans_pcie_op_mode_leave(struct iwl_trans *trans)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\n\tmutex_lock(&trans_pcie->mutex);\n\n\t \n\tiwl_disable_interrupts(trans);\n\n\tiwl_pcie_apm_stop(trans, true);\n\n\tiwl_disable_interrupts(trans);\n\n\tiwl_pcie_disable_ict(trans);\n\n\tmutex_unlock(&trans_pcie->mutex);\n\n\tiwl_pcie_synchronize_irqs(trans);\n}\n\nstatic void iwl_trans_pcie_write8(struct iwl_trans *trans, u32 ofs, u8 val)\n{\n\twriteb(val, IWL_TRANS_GET_PCIE_TRANS(trans)->hw_base + ofs);\n}\n\nstatic void iwl_trans_pcie_write32(struct iwl_trans *trans, u32 ofs, u32 val)\n{\n\twritel(val, IWL_TRANS_GET_PCIE_TRANS(trans)->hw_base + ofs);\n}\n\nstatic u32 iwl_trans_pcie_read32(struct iwl_trans *trans, u32 ofs)\n{\n\treturn readl(IWL_TRANS_GET_PCIE_TRANS(trans)->hw_base + ofs);\n}\n\nstatic u32 iwl_trans_pcie_prph_msk(struct iwl_trans *trans)\n{\n\tif (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_AX210)\n\t\treturn 0x00FFFFFF;\n\telse\n\t\treturn 0x000FFFFF;\n}\n\nstatic u32 iwl_trans_pcie_read_prph(struct iwl_trans *trans, u32 reg)\n{\n\tu32 mask = iwl_trans_pcie_prph_msk(trans);\n\n\tiwl_trans_pcie_write32(trans, HBUS_TARG_PRPH_RADDR,\n\t\t\t       ((reg & mask) | (3 << 24)));\n\treturn iwl_trans_pcie_read32(trans, HBUS_TARG_PRPH_RDAT);\n}\n\nstatic void iwl_trans_pcie_write_prph(struct iwl_trans *trans, u32 addr,\n\t\t\t\t      u32 val)\n{\n\tu32 mask = iwl_trans_pcie_prph_msk(trans);\n\n\tiwl_trans_pcie_write32(trans, HBUS_TARG_PRPH_WADDR,\n\t\t\t       ((addr & mask) | (3 << 24)));\n\tiwl_trans_pcie_write32(trans, HBUS_TARG_PRPH_WDAT, val);\n}\n\nstatic void iwl_trans_pcie_configure(struct iwl_trans *trans,\n\t\t\t\t     const struct iwl_trans_config *trans_cfg)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\n\t \n\tiwl_pcie_free_rbs_pool(trans);\n\n\ttrans->txqs.cmd.q_id = trans_cfg->cmd_queue;\n\ttrans->txqs.cmd.fifo = trans_cfg->cmd_fifo;\n\ttrans->txqs.cmd.wdg_timeout = trans_cfg->cmd_q_wdg_timeout;\n\ttrans->txqs.page_offs = trans_cfg->cb_data_offs;\n\ttrans->txqs.dev_cmd_offs = trans_cfg->cb_data_offs + sizeof(void *);\n\ttrans->txqs.queue_alloc_cmd_ver = trans_cfg->queue_alloc_cmd_ver;\n\n\tif (WARN_ON(trans_cfg->n_no_reclaim_cmds > MAX_NO_RECLAIM_CMDS))\n\t\ttrans_pcie->n_no_reclaim_cmds = 0;\n\telse\n\t\ttrans_pcie->n_no_reclaim_cmds = trans_cfg->n_no_reclaim_cmds;\n\tif (trans_pcie->n_no_reclaim_cmds)\n\t\tmemcpy(trans_pcie->no_reclaim_cmds, trans_cfg->no_reclaim_cmds,\n\t\t       trans_pcie->n_no_reclaim_cmds * sizeof(u8));\n\n\ttrans_pcie->rx_buf_size = trans_cfg->rx_buf_size;\n\ttrans_pcie->rx_page_order =\n\t\tiwl_trans_get_rb_size_order(trans_pcie->rx_buf_size);\n\ttrans_pcie->rx_buf_bytes =\n\t\tiwl_trans_get_rb_size(trans_pcie->rx_buf_size);\n\ttrans_pcie->supported_dma_mask = DMA_BIT_MASK(12);\n\tif (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_AX210)\n\t\ttrans_pcie->supported_dma_mask = DMA_BIT_MASK(11);\n\n\ttrans->txqs.bc_table_dword = trans_cfg->bc_table_dword;\n\ttrans_pcie->scd_set_active = trans_cfg->scd_set_active;\n\n\ttrans->command_groups = trans_cfg->command_groups;\n\ttrans->command_groups_size = trans_cfg->command_groups_size;\n\n\t \n\tif (trans_pcie->napi_dev.reg_state != NETREG_DUMMY)\n\t\tinit_dummy_netdev(&trans_pcie->napi_dev);\n\n\ttrans_pcie->fw_reset_handshake = trans_cfg->fw_reset_handshake;\n}\n\nvoid iwl_trans_pcie_free_pnvm_dram_regions(struct iwl_dram_regions *dram_regions,\n\t\t\t\t\t   struct device *dev)\n{\n\tu8 i;\n\tstruct iwl_dram_data *desc_dram = &dram_regions->prph_scratch_mem_desc;\n\n\t \n\tfor (i = 0; i < dram_regions->n_regions; i++) {\n\t\tdma_free_coherent(dev, dram_regions->drams[i].size,\n\t\t\t\t  dram_regions->drams[i].block,\n\t\t\t\t  dram_regions->drams[i].physical);\n\t}\n\tdram_regions->n_regions = 0;\n\n\t \n\tif (desc_dram->block) {\n\t\tdma_free_coherent(dev, desc_dram->size,\n\t\t\t\t  desc_dram->block,\n\t\t\t\t  desc_dram->physical);\n\t}\n\tmemset(desc_dram, 0, sizeof(*desc_dram));\n}\n\nstatic void iwl_pcie_free_invalid_tx_cmd(struct iwl_trans *trans)\n{\n\tiwl_pcie_free_dma_ptr(trans, &trans->invalid_tx_cmd);\n}\n\nstatic int iwl_pcie_alloc_invalid_tx_cmd(struct iwl_trans *trans)\n{\n\tstruct iwl_cmd_header_wide bad_cmd = {\n\t\t.cmd = INVALID_WR_PTR_CMD,\n\t\t.group_id = DEBUG_GROUP,\n\t\t.sequence = cpu_to_le16(0xffff),\n\t\t.length = cpu_to_le16(0),\n\t\t.version = 0,\n\t};\n\tint ret;\n\n\tret = iwl_pcie_alloc_dma_ptr(trans, &trans->invalid_tx_cmd,\n\t\t\t\t     sizeof(bad_cmd));\n\tif (ret)\n\t\treturn ret;\n\tmemcpy(trans->invalid_tx_cmd.addr, &bad_cmd, sizeof(bad_cmd));\n\treturn 0;\n}\n\nvoid iwl_trans_pcie_free(struct iwl_trans *trans)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tint i;\n\n\tiwl_pcie_synchronize_irqs(trans);\n\n\tif (trans->trans_cfg->gen2)\n\t\tiwl_txq_gen2_tx_free(trans);\n\telse\n\t\tiwl_pcie_tx_free(trans);\n\tiwl_pcie_rx_free(trans);\n\n\tif (trans_pcie->rba.alloc_wq) {\n\t\tdestroy_workqueue(trans_pcie->rba.alloc_wq);\n\t\ttrans_pcie->rba.alloc_wq = NULL;\n\t}\n\n\tif (trans_pcie->msix_enabled) {\n\t\tfor (i = 0; i < trans_pcie->alloc_vecs; i++) {\n\t\t\tirq_set_affinity_hint(\n\t\t\t\ttrans_pcie->msix_entries[i].vector,\n\t\t\t\tNULL);\n\t\t}\n\n\t\ttrans_pcie->msix_enabled = false;\n\t} else {\n\t\tiwl_pcie_free_ict(trans);\n\t}\n\n\tiwl_pcie_free_invalid_tx_cmd(trans);\n\n\tiwl_pcie_free_fw_monitor(trans);\n\n\tiwl_trans_pcie_free_pnvm_dram_regions(&trans_pcie->pnvm_data,\n\t\t\t\t\t      trans->dev);\n\tiwl_trans_pcie_free_pnvm_dram_regions(&trans_pcie->reduced_tables_data,\n\t\t\t\t\t      trans->dev);\n\n\tmutex_destroy(&trans_pcie->mutex);\n\tiwl_trans_free(trans);\n}\n\nstatic void iwl_trans_pcie_set_pmi(struct iwl_trans *trans, bool state)\n{\n\tif (state)\n\t\tset_bit(STATUS_TPOWER_PMI, &trans->status);\n\telse\n\t\tclear_bit(STATUS_TPOWER_PMI, &trans->status);\n}\n\nstruct iwl_trans_pcie_removal {\n\tstruct pci_dev *pdev;\n\tstruct work_struct work;\n\tbool rescan;\n};\n\nstatic void iwl_trans_pcie_removal_wk(struct work_struct *wk)\n{\n\tstruct iwl_trans_pcie_removal *removal =\n\t\tcontainer_of(wk, struct iwl_trans_pcie_removal, work);\n\tstruct pci_dev *pdev = removal->pdev;\n\tstatic char *prop[] = {\"EVENT=INACCESSIBLE\", NULL};\n\tstruct pci_bus *bus = pdev->bus;\n\n\tdev_err(&pdev->dev, \"Device gone - attempting removal\\n\");\n\tkobject_uevent_env(&pdev->dev.kobj, KOBJ_CHANGE, prop);\n\tpci_lock_rescan_remove();\n\tpci_dev_put(pdev);\n\tpci_stop_and_remove_bus_device(pdev);\n\tif (removal->rescan)\n\t\tpci_rescan_bus(bus->parent);\n\tpci_unlock_rescan_remove();\n\n\tkfree(removal);\n\tmodule_put(THIS_MODULE);\n}\n\nvoid iwl_trans_pcie_remove(struct iwl_trans *trans, bool rescan)\n{\n\tstruct iwl_trans_pcie_removal *removal;\n\n\tif (test_bit(STATUS_TRANS_DEAD, &trans->status))\n\t\treturn;\n\n\tIWL_ERR(trans, \"Device gone - scheduling removal!\\n\");\n\n\t \n\tif (!try_module_get(THIS_MODULE)) {\n\t\tIWL_ERR(trans,\n\t\t\t\"Module is being unloaded - abort\\n\");\n\t\treturn;\n\t}\n\n\tremoval = kzalloc(sizeof(*removal), GFP_ATOMIC);\n\tif (!removal) {\n\t\tmodule_put(THIS_MODULE);\n\t\treturn;\n\t}\n\t \n\tset_bit(STATUS_TRANS_DEAD, &trans->status);\n\n\tremoval->pdev = to_pci_dev(trans->dev);\n\tremoval->rescan = rescan;\n\tINIT_WORK(&removal->work, iwl_trans_pcie_removal_wk);\n\tpci_dev_get(removal->pdev);\n\tschedule_work(&removal->work);\n}\nEXPORT_SYMBOL(iwl_trans_pcie_remove);\n\n \nbool __iwl_trans_pcie_grab_nic_access(struct iwl_trans *trans)\n{\n\tint ret;\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tu32 write = CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ;\n\tu32 mask = CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY |\n\t\t   CSR_GP_CNTRL_REG_FLAG_GOING_TO_SLEEP;\n\tu32 poll = CSR_GP_CNTRL_REG_VAL_MAC_ACCESS_EN;\n\n\tspin_lock(&trans_pcie->reg_lock);\n\n\tif (trans_pcie->cmd_hold_nic_awake)\n\t\tgoto out;\n\n\tif (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_BZ) {\n\t\twrite = CSR_GP_CNTRL_REG_FLAG_BZ_MAC_ACCESS_REQ;\n\t\tmask = CSR_GP_CNTRL_REG_FLAG_MAC_STATUS;\n\t\tpoll = CSR_GP_CNTRL_REG_FLAG_MAC_STATUS;\n\t}\n\n\t \n\t__iwl_trans_pcie_set_bit(trans, CSR_GP_CNTRL, write);\n\tif (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_8000)\n\t\tudelay(2);\n\n\t \n\tret = iwl_poll_bit(trans, CSR_GP_CNTRL, poll, mask, 15000);\n\tif (unlikely(ret < 0)) {\n\t\tu32 cntrl = iwl_read32(trans, CSR_GP_CNTRL);\n\n\t\tWARN_ONCE(1,\n\t\t\t  \"Timeout waiting for hardware access (CSR_GP_CNTRL 0x%08x)\\n\",\n\t\t\t  cntrl);\n\n\t\tiwl_trans_pcie_dump_regs(trans);\n\n\t\tif (iwlwifi_mod_params.remove_when_gone && cntrl == ~0U)\n\t\t\tiwl_trans_pcie_remove(trans, false);\n\t\telse\n\t\t\tiwl_write32(trans, CSR_RESET,\n\t\t\t\t    CSR_RESET_REG_FLAG_FORCE_NMI);\n\n\t\tspin_unlock(&trans_pcie->reg_lock);\n\t\treturn false;\n\t}\n\nout:\n\t \n\t__release(&trans_pcie->reg_lock);\n\treturn true;\n}\n\nstatic bool iwl_trans_pcie_grab_nic_access(struct iwl_trans *trans)\n{\n\tbool ret;\n\n\tlocal_bh_disable();\n\tret = __iwl_trans_pcie_grab_nic_access(trans);\n\tif (ret) {\n\t\t \n\t\treturn ret;\n\t}\n\tlocal_bh_enable();\n\treturn false;\n}\n\nstatic void iwl_trans_pcie_release_nic_access(struct iwl_trans *trans)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\n\tlockdep_assert_held(&trans_pcie->reg_lock);\n\n\t \n\t__acquire(&trans_pcie->reg_lock);\n\n\tif (trans_pcie->cmd_hold_nic_awake)\n\t\tgoto out;\n\tif (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_BZ)\n\t\t__iwl_trans_pcie_clear_bit(trans, CSR_GP_CNTRL,\n\t\t\t\t\t   CSR_GP_CNTRL_REG_FLAG_BZ_MAC_ACCESS_REQ);\n\telse\n\t\t__iwl_trans_pcie_clear_bit(trans, CSR_GP_CNTRL,\n\t\t\t\t\t   CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);\n\t \nout:\n\tspin_unlock_bh(&trans_pcie->reg_lock);\n}\n\nstatic int iwl_trans_pcie_read_mem(struct iwl_trans *trans, u32 addr,\n\t\t\t\t   void *buf, int dwords)\n{\n\tint offs = 0;\n\tu32 *vals = buf;\n\n\twhile (offs < dwords) {\n\t\t \n\t\tunsigned long end = jiffies + HZ / 2;\n\t\tbool resched = false;\n\n\t\tif (iwl_trans_grab_nic_access(trans)) {\n\t\t\tiwl_write32(trans, HBUS_TARG_MEM_RADDR,\n\t\t\t\t    addr + 4 * offs);\n\n\t\t\twhile (offs < dwords) {\n\t\t\t\tvals[offs] = iwl_read32(trans,\n\t\t\t\t\t\t\tHBUS_TARG_MEM_RDAT);\n\t\t\t\toffs++;\n\n\t\t\t\tif (time_after(jiffies, end)) {\n\t\t\t\t\tresched = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tiwl_trans_release_nic_access(trans);\n\n\t\t\tif (resched)\n\t\t\t\tcond_resched();\n\t\t} else {\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int iwl_trans_pcie_write_mem(struct iwl_trans *trans, u32 addr,\n\t\t\t\t    const void *buf, int dwords)\n{\n\tint offs, ret = 0;\n\tconst u32 *vals = buf;\n\n\tif (iwl_trans_grab_nic_access(trans)) {\n\t\tiwl_write32(trans, HBUS_TARG_MEM_WADDR, addr);\n\t\tfor (offs = 0; offs < dwords; offs++)\n\t\t\tiwl_write32(trans, HBUS_TARG_MEM_WDAT,\n\t\t\t\t    vals ? vals[offs] : 0);\n\t\tiwl_trans_release_nic_access(trans);\n\t} else {\n\t\tret = -EBUSY;\n\t}\n\treturn ret;\n}\n\nstatic int iwl_trans_pcie_read_config32(struct iwl_trans *trans, u32 ofs,\n\t\t\t\t\tu32 *val)\n{\n\treturn pci_read_config_dword(IWL_TRANS_GET_PCIE_TRANS(trans)->pci_dev,\n\t\t\t\t     ofs, val);\n}\n\nstatic void iwl_trans_pcie_block_txq_ptrs(struct iwl_trans *trans, bool block)\n{\n\tint i;\n\n\tfor (i = 0; i < trans->trans_cfg->base_params->num_of_queues; i++) {\n\t\tstruct iwl_txq *txq = trans->txqs.txq[i];\n\n\t\tif (i == trans->txqs.cmd.q_id)\n\t\t\tcontinue;\n\n\t\tspin_lock_bh(&txq->lock);\n\n\t\tif (!block && !(WARN_ON_ONCE(!txq->block))) {\n\t\t\ttxq->block--;\n\t\t\tif (!txq->block) {\n\t\t\t\tiwl_write32(trans, HBUS_TARG_WRPTR,\n\t\t\t\t\t    txq->write_ptr | (i << 8));\n\t\t\t}\n\t\t} else if (block) {\n\t\t\ttxq->block++;\n\t\t}\n\n\t\tspin_unlock_bh(&txq->lock);\n\t}\n}\n\n#define IWL_FLUSH_WAIT_MS\t2000\n\nstatic int iwl_trans_pcie_rxq_dma_data(struct iwl_trans *trans, int queue,\n\t\t\t\t       struct iwl_trans_rxq_dma_data *data)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\n\tif (queue >= trans->num_rx_queues || !trans_pcie->rxq)\n\t\treturn -EINVAL;\n\n\tdata->fr_bd_cb = trans_pcie->rxq[queue].bd_dma;\n\tdata->urbd_stts_wrptr = trans_pcie->rxq[queue].rb_stts_dma;\n\tdata->ur_bd_cb = trans_pcie->rxq[queue].used_bd_dma;\n\tdata->fr_bd_wid = 0;\n\n\treturn 0;\n}\n\nstatic int iwl_trans_pcie_wait_txq_empty(struct iwl_trans *trans, int txq_idx)\n{\n\tstruct iwl_txq *txq;\n\tunsigned long now = jiffies;\n\tbool overflow_tx;\n\tu8 wr_ptr;\n\n\t \n\tif (test_bit(STATUS_TRANS_DEAD, &trans->status))\n\t\treturn -ENODEV;\n\n\tif (!test_bit(txq_idx, trans->txqs.queue_used))\n\t\treturn -EINVAL;\n\n\tIWL_DEBUG_TX_QUEUES(trans, \"Emptying queue %d...\\n\", txq_idx);\n\ttxq = trans->txqs.txq[txq_idx];\n\n\tspin_lock_bh(&txq->lock);\n\toverflow_tx = txq->overflow_tx ||\n\t\t      !skb_queue_empty(&txq->overflow_q);\n\tspin_unlock_bh(&txq->lock);\n\n\twr_ptr = READ_ONCE(txq->write_ptr);\n\n\twhile ((txq->read_ptr != READ_ONCE(txq->write_ptr) ||\n\t\toverflow_tx) &&\n\t       !time_after(jiffies,\n\t\t\t   now + msecs_to_jiffies(IWL_FLUSH_WAIT_MS))) {\n\t\tu8 write_ptr = READ_ONCE(txq->write_ptr);\n\n\t\t \n\t\tif (WARN_ONCE(wr_ptr != write_ptr && !overflow_tx,\n\t\t\t      \"WR pointer moved while flushing %d -> %d\\n\",\n\t\t\t      wr_ptr, write_ptr))\n\t\t\treturn -ETIMEDOUT;\n\t\twr_ptr = write_ptr;\n\n\t\tusleep_range(1000, 2000);\n\n\t\tspin_lock_bh(&txq->lock);\n\t\toverflow_tx = txq->overflow_tx ||\n\t\t\t      !skb_queue_empty(&txq->overflow_q);\n\t\tspin_unlock_bh(&txq->lock);\n\t}\n\n\tif (txq->read_ptr != txq->write_ptr) {\n\t\tIWL_ERR(trans,\n\t\t\t\"fail to flush all tx fifo queues Q %d\\n\", txq_idx);\n\t\tiwl_txq_log_scd_error(trans, txq);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tIWL_DEBUG_TX_QUEUES(trans, \"Queue %d is now empty.\\n\", txq_idx);\n\n\treturn 0;\n}\n\nstatic int iwl_trans_pcie_wait_txqs_empty(struct iwl_trans *trans, u32 txq_bm)\n{\n\tint cnt;\n\tint ret = 0;\n\n\t \n\tfor (cnt = 0;\n\t     cnt < trans->trans_cfg->base_params->num_of_queues;\n\t     cnt++) {\n\n\t\tif (cnt == trans->txqs.cmd.q_id)\n\t\t\tcontinue;\n\t\tif (!test_bit(cnt, trans->txqs.queue_used))\n\t\t\tcontinue;\n\t\tif (!(BIT(cnt) & txq_bm))\n\t\t\tcontinue;\n\n\t\tret = iwl_trans_pcie_wait_txq_empty(trans, cnt);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void iwl_trans_pcie_set_bits_mask(struct iwl_trans *trans, u32 reg,\n\t\t\t\t\t u32 mask, u32 value)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\n\tspin_lock_bh(&trans_pcie->reg_lock);\n\t__iwl_trans_pcie_set_bits_mask(trans, reg, mask, value);\n\tspin_unlock_bh(&trans_pcie->reg_lock);\n}\n\nstatic const char *get_csr_string(int cmd)\n{\n#define IWL_CMD(x) case x: return #x\n\tswitch (cmd) {\n\tIWL_CMD(CSR_HW_IF_CONFIG_REG);\n\tIWL_CMD(CSR_INT_COALESCING);\n\tIWL_CMD(CSR_INT);\n\tIWL_CMD(CSR_INT_MASK);\n\tIWL_CMD(CSR_FH_INT_STATUS);\n\tIWL_CMD(CSR_GPIO_IN);\n\tIWL_CMD(CSR_RESET);\n\tIWL_CMD(CSR_GP_CNTRL);\n\tIWL_CMD(CSR_HW_REV);\n\tIWL_CMD(CSR_EEPROM_REG);\n\tIWL_CMD(CSR_EEPROM_GP);\n\tIWL_CMD(CSR_OTP_GP_REG);\n\tIWL_CMD(CSR_GIO_REG);\n\tIWL_CMD(CSR_GP_UCODE_REG);\n\tIWL_CMD(CSR_GP_DRIVER_REG);\n\tIWL_CMD(CSR_UCODE_DRV_GP1);\n\tIWL_CMD(CSR_UCODE_DRV_GP2);\n\tIWL_CMD(CSR_LED_REG);\n\tIWL_CMD(CSR_DRAM_INT_TBL_REG);\n\tIWL_CMD(CSR_GIO_CHICKEN_BITS);\n\tIWL_CMD(CSR_ANA_PLL_CFG);\n\tIWL_CMD(CSR_HW_REV_WA_REG);\n\tIWL_CMD(CSR_MONITOR_STATUS_REG);\n\tIWL_CMD(CSR_DBG_HPET_MEM_REG);\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n#undef IWL_CMD\n}\n\nvoid iwl_pcie_dump_csr(struct iwl_trans *trans)\n{\n\tint i;\n\tstatic const u32 csr_tbl[] = {\n\t\tCSR_HW_IF_CONFIG_REG,\n\t\tCSR_INT_COALESCING,\n\t\tCSR_INT,\n\t\tCSR_INT_MASK,\n\t\tCSR_FH_INT_STATUS,\n\t\tCSR_GPIO_IN,\n\t\tCSR_RESET,\n\t\tCSR_GP_CNTRL,\n\t\tCSR_HW_REV,\n\t\tCSR_EEPROM_REG,\n\t\tCSR_EEPROM_GP,\n\t\tCSR_OTP_GP_REG,\n\t\tCSR_GIO_REG,\n\t\tCSR_GP_UCODE_REG,\n\t\tCSR_GP_DRIVER_REG,\n\t\tCSR_UCODE_DRV_GP1,\n\t\tCSR_UCODE_DRV_GP2,\n\t\tCSR_LED_REG,\n\t\tCSR_DRAM_INT_TBL_REG,\n\t\tCSR_GIO_CHICKEN_BITS,\n\t\tCSR_ANA_PLL_CFG,\n\t\tCSR_MONITOR_STATUS_REG,\n\t\tCSR_HW_REV_WA_REG,\n\t\tCSR_DBG_HPET_MEM_REG\n\t};\n\tIWL_ERR(trans, \"CSR values:\\n\");\n\tIWL_ERR(trans, \"(2nd byte of CSR_INT_COALESCING is \"\n\t\t\"CSR_INT_PERIODIC_REG)\\n\");\n\tfor (i = 0; i <  ARRAY_SIZE(csr_tbl); i++) {\n\t\tIWL_ERR(trans, \"  %25s: 0X%08x\\n\",\n\t\t\tget_csr_string(csr_tbl[i]),\n\t\t\tiwl_read32(trans, csr_tbl[i]));\n\t}\n}\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n \n#define DEBUGFS_ADD_FILE(name, parent, mode) do {\t\t\t\\\n\tdebugfs_create_file(#name, mode, parent, trans,\t\t\t\\\n\t\t\t    &iwl_dbgfs_##name##_ops);\t\t\t\\\n} while (0)\n\n \n#define DEBUGFS_READ_FILE_OPS(name)\t\t\t\t\t\\\nstatic const struct file_operations iwl_dbgfs_##name##_ops = {\t\t\\\n\t.read = iwl_dbgfs_##name##_read,\t\t\t\t\\\n\t.open = simple_open,\t\t\t\t\t\t\\\n\t.llseek = generic_file_llseek,\t\t\t\t\t\\\n};\n\n#define DEBUGFS_WRITE_FILE_OPS(name)                                    \\\nstatic const struct file_operations iwl_dbgfs_##name##_ops = {          \\\n\t.write = iwl_dbgfs_##name##_write,                              \\\n\t.open = simple_open,\t\t\t\t\t\t\\\n\t.llseek = generic_file_llseek,\t\t\t\t\t\\\n};\n\n#define DEBUGFS_READ_WRITE_FILE_OPS(name)\t\t\t\t\\\nstatic const struct file_operations iwl_dbgfs_##name##_ops = {\t\t\\\n\t.write = iwl_dbgfs_##name##_write,\t\t\t\t\\\n\t.read = iwl_dbgfs_##name##_read,\t\t\t\t\\\n\t.open = simple_open,\t\t\t\t\t\t\\\n\t.llseek = generic_file_llseek,\t\t\t\t\t\\\n};\n\nstruct iwl_dbgfs_tx_queue_priv {\n\tstruct iwl_trans *trans;\n};\n\nstruct iwl_dbgfs_tx_queue_state {\n\tloff_t pos;\n};\n\nstatic void *iwl_dbgfs_tx_queue_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct iwl_dbgfs_tx_queue_priv *priv = seq->private;\n\tstruct iwl_dbgfs_tx_queue_state *state;\n\n\tif (*pos >= priv->trans->trans_cfg->base_params->num_of_queues)\n\t\treturn NULL;\n\n\tstate = kmalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\tstate->pos = *pos;\n\treturn state;\n}\n\nstatic void *iwl_dbgfs_tx_queue_seq_next(struct seq_file *seq,\n\t\t\t\t\t void *v, loff_t *pos)\n{\n\tstruct iwl_dbgfs_tx_queue_priv *priv = seq->private;\n\tstruct iwl_dbgfs_tx_queue_state *state = v;\n\n\t*pos = ++state->pos;\n\n\tif (*pos >= priv->trans->trans_cfg->base_params->num_of_queues)\n\t\treturn NULL;\n\n\treturn state;\n}\n\nstatic void iwl_dbgfs_tx_queue_seq_stop(struct seq_file *seq, void *v)\n{\n\tkfree(v);\n}\n\nstatic int iwl_dbgfs_tx_queue_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct iwl_dbgfs_tx_queue_priv *priv = seq->private;\n\tstruct iwl_dbgfs_tx_queue_state *state = v;\n\tstruct iwl_trans *trans = priv->trans;\n\tstruct iwl_txq *txq = trans->txqs.txq[state->pos];\n\n\tseq_printf(seq, \"hwq %.3u: used=%d stopped=%d \",\n\t\t   (unsigned int)state->pos,\n\t\t   !!test_bit(state->pos, trans->txqs.queue_used),\n\t\t   !!test_bit(state->pos, trans->txqs.queue_stopped));\n\tif (txq)\n\t\tseq_printf(seq,\n\t\t\t   \"read=%u write=%u need_update=%d frozen=%d n_window=%d ampdu=%d\",\n\t\t\t   txq->read_ptr, txq->write_ptr,\n\t\t\t   txq->need_update, txq->frozen,\n\t\t\t   txq->n_window, txq->ampdu);\n\telse\n\t\tseq_puts(seq, \"(unallocated)\");\n\n\tif (state->pos == trans->txqs.cmd.q_id)\n\t\tseq_puts(seq, \" (HCMD)\");\n\tseq_puts(seq, \"\\n\");\n\n\treturn 0;\n}\n\nstatic const struct seq_operations iwl_dbgfs_tx_queue_seq_ops = {\n\t.start = iwl_dbgfs_tx_queue_seq_start,\n\t.next = iwl_dbgfs_tx_queue_seq_next,\n\t.stop = iwl_dbgfs_tx_queue_seq_stop,\n\t.show = iwl_dbgfs_tx_queue_seq_show,\n};\n\nstatic int iwl_dbgfs_tx_queue_open(struct inode *inode, struct file *filp)\n{\n\tstruct iwl_dbgfs_tx_queue_priv *priv;\n\n\tpriv = __seq_open_private(filp, &iwl_dbgfs_tx_queue_seq_ops,\n\t\t\t\t  sizeof(*priv));\n\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->trans = inode->i_private;\n\treturn 0;\n}\n\nstatic ssize_t iwl_dbgfs_rx_queue_read(struct file *file,\n\t\t\t\t       char __user *user_buf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct iwl_trans *trans = file->private_data;\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tchar *buf;\n\tint pos = 0, i, ret;\n\tsize_t bufsz;\n\n\tbufsz = sizeof(char) * 121 * trans->num_rx_queues;\n\n\tif (!trans_pcie->rxq)\n\t\treturn -EAGAIN;\n\n\tbuf = kzalloc(bufsz, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < trans->num_rx_queues && pos < bufsz; i++) {\n\t\tstruct iwl_rxq *rxq = &trans_pcie->rxq[i];\n\n\t\tpos += scnprintf(buf + pos, bufsz - pos, \"queue#: %2d\\n\",\n\t\t\t\t i);\n\t\tpos += scnprintf(buf + pos, bufsz - pos, \"\\tread: %u\\n\",\n\t\t\t\t rxq->read);\n\t\tpos += scnprintf(buf + pos, bufsz - pos, \"\\twrite: %u\\n\",\n\t\t\t\t rxq->write);\n\t\tpos += scnprintf(buf + pos, bufsz - pos, \"\\twrite_actual: %u\\n\",\n\t\t\t\t rxq->write_actual);\n\t\tpos += scnprintf(buf + pos, bufsz - pos, \"\\tneed_update: %2d\\n\",\n\t\t\t\t rxq->need_update);\n\t\tpos += scnprintf(buf + pos, bufsz - pos, \"\\tfree_count: %u\\n\",\n\t\t\t\t rxq->free_count);\n\t\tif (rxq->rb_stts) {\n\t\t\tu32 r =\t__le16_to_cpu(iwl_get_closed_rb_stts(trans,\n\t\t\t\t\t\t\t\t     rxq));\n\t\t\tpos += scnprintf(buf + pos, bufsz - pos,\n\t\t\t\t\t \"\\tclosed_rb_num: %u\\n\",\n\t\t\t\t\t r & 0x0FFF);\n\t\t} else {\n\t\t\tpos += scnprintf(buf + pos, bufsz - pos,\n\t\t\t\t\t \"\\tclosed_rb_num: Not Allocated\\n\");\n\t\t}\n\t}\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic ssize_t iwl_dbgfs_interrupt_read(struct file *file,\n\t\t\t\t\tchar __user *user_buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct iwl_trans *trans = file->private_data;\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tstruct isr_statistics *isr_stats = &trans_pcie->isr_stats;\n\n\tint pos = 0;\n\tchar *buf;\n\tint bufsz = 24 * 64;  \n\tssize_t ret;\n\n\tbuf = kzalloc(bufsz, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tpos += scnprintf(buf + pos, bufsz - pos,\n\t\t\t\"Interrupt Statistics Report:\\n\");\n\n\tpos += scnprintf(buf + pos, bufsz - pos, \"HW Error:\\t\\t\\t %u\\n\",\n\t\tisr_stats->hw);\n\tpos += scnprintf(buf + pos, bufsz - pos, \"SW Error:\\t\\t\\t %u\\n\",\n\t\tisr_stats->sw);\n\tif (isr_stats->sw || isr_stats->hw) {\n\t\tpos += scnprintf(buf + pos, bufsz - pos,\n\t\t\t\"\\tLast Restarting Code:  0x%X\\n\",\n\t\t\tisr_stats->err_code);\n\t}\n#ifdef CONFIG_IWLWIFI_DEBUG\n\tpos += scnprintf(buf + pos, bufsz - pos, \"Frame transmitted:\\t\\t %u\\n\",\n\t\tisr_stats->sch);\n\tpos += scnprintf(buf + pos, bufsz - pos, \"Alive interrupt:\\t\\t %u\\n\",\n\t\tisr_stats->alive);\n#endif\n\tpos += scnprintf(buf + pos, bufsz - pos,\n\t\t\"HW RF KILL switch toggled:\\t %u\\n\", isr_stats->rfkill);\n\n\tpos += scnprintf(buf + pos, bufsz - pos, \"CT KILL:\\t\\t\\t %u\\n\",\n\t\tisr_stats->ctkill);\n\n\tpos += scnprintf(buf + pos, bufsz - pos, \"Wakeup Interrupt:\\t\\t %u\\n\",\n\t\tisr_stats->wakeup);\n\n\tpos += scnprintf(buf + pos, bufsz - pos,\n\t\t\"Rx command responses:\\t\\t %u\\n\", isr_stats->rx);\n\n\tpos += scnprintf(buf + pos, bufsz - pos, \"Tx/FH interrupt:\\t\\t %u\\n\",\n\t\tisr_stats->tx);\n\n\tpos += scnprintf(buf + pos, bufsz - pos, \"Unexpected INTA:\\t\\t %u\\n\",\n\t\tisr_stats->unhandled);\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic ssize_t iwl_dbgfs_interrupt_write(struct file *file,\n\t\t\t\t\t const char __user *user_buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct iwl_trans *trans = file->private_data;\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tstruct isr_statistics *isr_stats = &trans_pcie->isr_stats;\n\tu32 reset_flag;\n\tint ret;\n\n\tret = kstrtou32_from_user(user_buf, count, 16, &reset_flag);\n\tif (ret)\n\t\treturn ret;\n\tif (reset_flag == 0)\n\t\tmemset(isr_stats, 0, sizeof(*isr_stats));\n\n\treturn count;\n}\n\nstatic ssize_t iwl_dbgfs_csr_write(struct file *file,\n\t\t\t\t   const char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct iwl_trans *trans = file->private_data;\n\n\tiwl_pcie_dump_csr(trans);\n\n\treturn count;\n}\n\nstatic ssize_t iwl_dbgfs_fh_reg_read(struct file *file,\n\t\t\t\t     char __user *user_buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct iwl_trans *trans = file->private_data;\n\tchar *buf = NULL;\n\tssize_t ret;\n\n\tret = iwl_dump_fh(trans, &buf);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!buf)\n\t\treturn -EINVAL;\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic ssize_t iwl_dbgfs_rfkill_read(struct file *file,\n\t\t\t\t     char __user *user_buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct iwl_trans *trans = file->private_data;\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tchar buf[100];\n\tint pos;\n\n\tpos = scnprintf(buf, sizeof(buf), \"debug: %d\\nhw: %d\\n\",\n\t\t\ttrans_pcie->debug_rfkill,\n\t\t\t!(iwl_read32(trans, CSR_GP_CNTRL) &\n\t\t\t\tCSR_GP_CNTRL_REG_FLAG_HW_RF_KILL_SW));\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\nstatic ssize_t iwl_dbgfs_rfkill_write(struct file *file,\n\t\t\t\t      const char __user *user_buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct iwl_trans *trans = file->private_data;\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tbool new_value;\n\tint ret;\n\n\tret = kstrtobool_from_user(user_buf, count, &new_value);\n\tif (ret)\n\t\treturn ret;\n\tif (new_value == trans_pcie->debug_rfkill)\n\t\treturn count;\n\tIWL_WARN(trans, \"changing debug rfkill %d->%d\\n\",\n\t\t trans_pcie->debug_rfkill, new_value);\n\ttrans_pcie->debug_rfkill = new_value;\n\tiwl_pcie_handle_rfkill_irq(trans, false);\n\n\treturn count;\n}\n\nstatic int iwl_dbgfs_monitor_data_open(struct inode *inode,\n\t\t\t\t       struct file *file)\n{\n\tstruct iwl_trans *trans = inode->i_private;\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\n\tif (!trans->dbg.dest_tlv ||\n\t    trans->dbg.dest_tlv->monitor_mode != EXTERNAL_MODE) {\n\t\tIWL_ERR(trans, \"Debug destination is not set to DRAM\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (trans_pcie->fw_mon_data.state != IWL_FW_MON_DBGFS_STATE_CLOSED)\n\t\treturn -EBUSY;\n\n\ttrans_pcie->fw_mon_data.state = IWL_FW_MON_DBGFS_STATE_OPEN;\n\treturn simple_open(inode, file);\n}\n\nstatic int iwl_dbgfs_monitor_data_release(struct inode *inode,\n\t\t\t\t\t  struct file *file)\n{\n\tstruct iwl_trans_pcie *trans_pcie =\n\t\tIWL_TRANS_GET_PCIE_TRANS(inode->i_private);\n\n\tif (trans_pcie->fw_mon_data.state == IWL_FW_MON_DBGFS_STATE_OPEN)\n\t\ttrans_pcie->fw_mon_data.state = IWL_FW_MON_DBGFS_STATE_CLOSED;\n\treturn 0;\n}\n\nstatic bool iwl_write_to_user_buf(char __user *user_buf, ssize_t count,\n\t\t\t\t  void *buf, ssize_t *size,\n\t\t\t\t  ssize_t *bytes_copied)\n{\n\tssize_t buf_size_left = count - *bytes_copied;\n\n\tbuf_size_left = buf_size_left - (buf_size_left % sizeof(u32));\n\tif (*size > buf_size_left)\n\t\t*size = buf_size_left;\n\n\t*size -= copy_to_user(user_buf, buf, *size);\n\t*bytes_copied += *size;\n\n\tif (buf_size_left == *size)\n\t\treturn true;\n\treturn false;\n}\n\nstatic ssize_t iwl_dbgfs_monitor_data_read(struct file *file,\n\t\t\t\t\t   char __user *user_buf,\n\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct iwl_trans *trans = file->private_data;\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tu8 *cpu_addr = (void *)trans->dbg.fw_mon.block, *curr_buf;\n\tstruct cont_rec *data = &trans_pcie->fw_mon_data;\n\tu32 write_ptr_addr, wrap_cnt_addr, write_ptr, wrap_cnt;\n\tssize_t size, bytes_copied = 0;\n\tbool b_full;\n\n\tif (trans->dbg.dest_tlv) {\n\t\twrite_ptr_addr =\n\t\t\tle32_to_cpu(trans->dbg.dest_tlv->write_ptr_reg);\n\t\twrap_cnt_addr = le32_to_cpu(trans->dbg.dest_tlv->wrap_count);\n\t} else {\n\t\twrite_ptr_addr = MON_BUFF_WRPTR;\n\t\twrap_cnt_addr = MON_BUFF_CYCLE_CNT;\n\t}\n\n\tif (unlikely(!trans->dbg.rec_on))\n\t\treturn 0;\n\n\tmutex_lock(&data->mutex);\n\tif (data->state ==\n\t    IWL_FW_MON_DBGFS_STATE_DISABLED) {\n\t\tmutex_unlock(&data->mutex);\n\t\treturn 0;\n\t}\n\n\t \n\twrite_ptr = iwl_read_prph(trans, write_ptr_addr) * sizeof(u32);\n\twrap_cnt = iwl_read_prph(trans, wrap_cnt_addr);\n\n\tif (data->prev_wrap_cnt == wrap_cnt) {\n\t\tsize = write_ptr - data->prev_wr_ptr;\n\t\tcurr_buf = cpu_addr + data->prev_wr_ptr;\n\t\tb_full = iwl_write_to_user_buf(user_buf, count,\n\t\t\t\t\t       curr_buf, &size,\n\t\t\t\t\t       &bytes_copied);\n\t\tdata->prev_wr_ptr += size;\n\n\t} else if (data->prev_wrap_cnt == wrap_cnt - 1 &&\n\t\t   write_ptr < data->prev_wr_ptr) {\n\t\tsize = trans->dbg.fw_mon.size - data->prev_wr_ptr;\n\t\tcurr_buf = cpu_addr + data->prev_wr_ptr;\n\t\tb_full = iwl_write_to_user_buf(user_buf, count,\n\t\t\t\t\t       curr_buf, &size,\n\t\t\t\t\t       &bytes_copied);\n\t\tdata->prev_wr_ptr += size;\n\n\t\tif (!b_full) {\n\t\t\tsize = write_ptr;\n\t\t\tb_full = iwl_write_to_user_buf(user_buf, count,\n\t\t\t\t\t\t       cpu_addr, &size,\n\t\t\t\t\t\t       &bytes_copied);\n\t\t\tdata->prev_wr_ptr = size;\n\t\t\tdata->prev_wrap_cnt++;\n\t\t}\n\t} else {\n\t\tif (data->prev_wrap_cnt == wrap_cnt - 1 &&\n\t\t    write_ptr > data->prev_wr_ptr)\n\t\t\tIWL_WARN(trans,\n\t\t\t\t \"write pointer passed previous write pointer, start copying from the beginning\\n\");\n\t\telse if (!unlikely(data->prev_wrap_cnt == 0 &&\n\t\t\t\t   data->prev_wr_ptr == 0))\n\t\t\tIWL_WARN(trans,\n\t\t\t\t \"monitor data is out of sync, start copying from the beginning\\n\");\n\n\t\tsize = write_ptr;\n\t\tb_full = iwl_write_to_user_buf(user_buf, count,\n\t\t\t\t\t       cpu_addr, &size,\n\t\t\t\t\t       &bytes_copied);\n\t\tdata->prev_wr_ptr = size;\n\t\tdata->prev_wrap_cnt = wrap_cnt;\n\t}\n\n\tmutex_unlock(&data->mutex);\n\n\treturn bytes_copied;\n}\n\nstatic ssize_t iwl_dbgfs_rf_read(struct file *file,\n\t\t\t\t char __user *user_buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct iwl_trans *trans = file->private_data;\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\n\tif (!trans_pcie->rf_name[0])\n\t\treturn -ENODEV;\n\n\treturn simple_read_from_buffer(user_buf, count, ppos,\n\t\t\t\t       trans_pcie->rf_name,\n\t\t\t\t       strlen(trans_pcie->rf_name));\n}\n\nDEBUGFS_READ_WRITE_FILE_OPS(interrupt);\nDEBUGFS_READ_FILE_OPS(fh_reg);\nDEBUGFS_READ_FILE_OPS(rx_queue);\nDEBUGFS_WRITE_FILE_OPS(csr);\nDEBUGFS_READ_WRITE_FILE_OPS(rfkill);\nDEBUGFS_READ_FILE_OPS(rf);\n\nstatic const struct file_operations iwl_dbgfs_tx_queue_ops = {\n\t.owner = THIS_MODULE,\n\t.open = iwl_dbgfs_tx_queue_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release_private,\n};\n\nstatic const struct file_operations iwl_dbgfs_monitor_data_ops = {\n\t.read = iwl_dbgfs_monitor_data_read,\n\t.open = iwl_dbgfs_monitor_data_open,\n\t.release = iwl_dbgfs_monitor_data_release,\n};\n\n \nvoid iwl_trans_pcie_dbgfs_register(struct iwl_trans *trans)\n{\n\tstruct dentry *dir = trans->dbgfs_dir;\n\n\tDEBUGFS_ADD_FILE(rx_queue, dir, 0400);\n\tDEBUGFS_ADD_FILE(tx_queue, dir, 0400);\n\tDEBUGFS_ADD_FILE(interrupt, dir, 0600);\n\tDEBUGFS_ADD_FILE(csr, dir, 0200);\n\tDEBUGFS_ADD_FILE(fh_reg, dir, 0400);\n\tDEBUGFS_ADD_FILE(rfkill, dir, 0600);\n\tDEBUGFS_ADD_FILE(monitor_data, dir, 0400);\n\tDEBUGFS_ADD_FILE(rf, dir, 0400);\n}\n\nstatic void iwl_trans_pcie_debugfs_cleanup(struct iwl_trans *trans)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tstruct cont_rec *data = &trans_pcie->fw_mon_data;\n\n\tmutex_lock(&data->mutex);\n\tdata->state = IWL_FW_MON_DBGFS_STATE_DISABLED;\n\tmutex_unlock(&data->mutex);\n}\n#endif  \n\nstatic u32 iwl_trans_pcie_get_cmdlen(struct iwl_trans *trans, void *tfd)\n{\n\tu32 cmdlen = 0;\n\tint i;\n\n\tfor (i = 0; i < trans->txqs.tfd.max_tbs; i++)\n\t\tcmdlen += iwl_txq_gen1_tfd_tb_get_len(trans, tfd, i);\n\n\treturn cmdlen;\n}\n\nstatic u32 iwl_trans_pcie_dump_rbs(struct iwl_trans *trans,\n\t\t\t\t   struct iwl_fw_error_dump_data **data,\n\t\t\t\t   int allocated_rb_nums)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tint max_len = trans_pcie->rx_buf_bytes;\n\t \n\tstruct iwl_rxq *rxq = &trans_pcie->rxq[0];\n\tu32 i, r, j, rb_len = 0;\n\n\tspin_lock_bh(&rxq->lock);\n\n\tr = le16_to_cpu(iwl_get_closed_rb_stts(trans, rxq)) & 0x0FFF;\n\n\tfor (i = rxq->read, j = 0;\n\t     i != r && j < allocated_rb_nums;\n\t     i = (i + 1) & RX_QUEUE_MASK, j++) {\n\t\tstruct iwl_rx_mem_buffer *rxb = rxq->queue[i];\n\t\tstruct iwl_fw_error_dump_rb *rb;\n\n\t\tdma_sync_single_for_cpu(trans->dev, rxb->page_dma,\n\t\t\t\t\tmax_len, DMA_FROM_DEVICE);\n\n\t\trb_len += sizeof(**data) + sizeof(*rb) + max_len;\n\n\t\t(*data)->type = cpu_to_le32(IWL_FW_ERROR_DUMP_RB);\n\t\t(*data)->len = cpu_to_le32(sizeof(*rb) + max_len);\n\t\trb = (void *)(*data)->data;\n\t\trb->index = cpu_to_le32(i);\n\t\tmemcpy(rb->data, page_address(rxb->page), max_len);\n\n\t\t*data = iwl_fw_error_next_data(*data);\n\t}\n\n\tspin_unlock_bh(&rxq->lock);\n\n\treturn rb_len;\n}\n#define IWL_CSR_TO_DUMP (0x250)\n\nstatic u32 iwl_trans_pcie_dump_csr(struct iwl_trans *trans,\n\t\t\t\t   struct iwl_fw_error_dump_data **data)\n{\n\tu32 csr_len = sizeof(**data) + IWL_CSR_TO_DUMP;\n\t__le32 *val;\n\tint i;\n\n\t(*data)->type = cpu_to_le32(IWL_FW_ERROR_DUMP_CSR);\n\t(*data)->len = cpu_to_le32(IWL_CSR_TO_DUMP);\n\tval = (void *)(*data)->data;\n\n\tfor (i = 0; i < IWL_CSR_TO_DUMP; i += 4)\n\t\t*val++ = cpu_to_le32(iwl_trans_pcie_read32(trans, i));\n\n\t*data = iwl_fw_error_next_data(*data);\n\n\treturn csr_len;\n}\n\nstatic u32 iwl_trans_pcie_fh_regs_dump(struct iwl_trans *trans,\n\t\t\t\t       struct iwl_fw_error_dump_data **data)\n{\n\tu32 fh_regs_len = FH_MEM_UPPER_BOUND - FH_MEM_LOWER_BOUND;\n\t__le32 *val;\n\tint i;\n\n\tif (!iwl_trans_grab_nic_access(trans))\n\t\treturn 0;\n\n\t(*data)->type = cpu_to_le32(IWL_FW_ERROR_DUMP_FH_REGS);\n\t(*data)->len = cpu_to_le32(fh_regs_len);\n\tval = (void *)(*data)->data;\n\n\tif (!trans->trans_cfg->gen2)\n\t\tfor (i = FH_MEM_LOWER_BOUND; i < FH_MEM_UPPER_BOUND;\n\t\t     i += sizeof(u32))\n\t\t\t*val++ = cpu_to_le32(iwl_trans_pcie_read32(trans, i));\n\telse\n\t\tfor (i = iwl_umac_prph(trans, FH_MEM_LOWER_BOUND_GEN2);\n\t\t     i < iwl_umac_prph(trans, FH_MEM_UPPER_BOUND_GEN2);\n\t\t     i += sizeof(u32))\n\t\t\t*val++ = cpu_to_le32(iwl_trans_pcie_read_prph(trans,\n\t\t\t\t\t\t\t\t      i));\n\n\tiwl_trans_release_nic_access(trans);\n\n\t*data = iwl_fw_error_next_data(*data);\n\n\treturn sizeof(**data) + fh_regs_len;\n}\n\nstatic u32\niwl_trans_pci_dump_marbh_monitor(struct iwl_trans *trans,\n\t\t\t\t struct iwl_fw_error_dump_fw_mon *fw_mon_data,\n\t\t\t\t u32 monitor_len)\n{\n\tu32 buf_size_in_dwords = (monitor_len >> 2);\n\tu32 *buffer = (u32 *)fw_mon_data->data;\n\tu32 i;\n\n\tif (!iwl_trans_grab_nic_access(trans))\n\t\treturn 0;\n\n\tiwl_write_umac_prph_no_grab(trans, MON_DMARB_RD_CTL_ADDR, 0x1);\n\tfor (i = 0; i < buf_size_in_dwords; i++)\n\t\tbuffer[i] = iwl_read_umac_prph_no_grab(trans,\n\t\t\t\t\t\t       MON_DMARB_RD_DATA_ADDR);\n\tiwl_write_umac_prph_no_grab(trans, MON_DMARB_RD_CTL_ADDR, 0x0);\n\n\tiwl_trans_release_nic_access(trans);\n\n\treturn monitor_len;\n}\n\nstatic void\niwl_trans_pcie_dump_pointers(struct iwl_trans *trans,\n\t\t\t     struct iwl_fw_error_dump_fw_mon *fw_mon_data)\n{\n\tu32 base, base_high, write_ptr, write_ptr_val, wrap_cnt;\n\n\tif (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_AX210) {\n\t\tbase = DBGC_CUR_DBGBUF_BASE_ADDR_LSB;\n\t\tbase_high = DBGC_CUR_DBGBUF_BASE_ADDR_MSB;\n\t\twrite_ptr = DBGC_CUR_DBGBUF_STATUS;\n\t\twrap_cnt = DBGC_DBGBUF_WRAP_AROUND;\n\t} else if (trans->dbg.dest_tlv) {\n\t\twrite_ptr = le32_to_cpu(trans->dbg.dest_tlv->write_ptr_reg);\n\t\twrap_cnt = le32_to_cpu(trans->dbg.dest_tlv->wrap_count);\n\t\tbase = le32_to_cpu(trans->dbg.dest_tlv->base_reg);\n\t} else {\n\t\tbase = MON_BUFF_BASE_ADDR;\n\t\twrite_ptr = MON_BUFF_WRPTR;\n\t\twrap_cnt = MON_BUFF_CYCLE_CNT;\n\t}\n\n\twrite_ptr_val = iwl_read_prph(trans, write_ptr);\n\tfw_mon_data->fw_mon_cycle_cnt =\n\t\tcpu_to_le32(iwl_read_prph(trans, wrap_cnt));\n\tfw_mon_data->fw_mon_base_ptr =\n\t\tcpu_to_le32(iwl_read_prph(trans, base));\n\tif (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_AX210) {\n\t\tfw_mon_data->fw_mon_base_high_ptr =\n\t\t\tcpu_to_le32(iwl_read_prph(trans, base_high));\n\t\twrite_ptr_val &= DBGC_CUR_DBGBUF_STATUS_OFFSET_MSK;\n\t\t \n\t\twrite_ptr_val >>= 2;\n\t}\n\tfw_mon_data->fw_mon_wr_ptr = cpu_to_le32(write_ptr_val);\n}\n\nstatic u32\niwl_trans_pcie_dump_monitor(struct iwl_trans *trans,\n\t\t\t    struct iwl_fw_error_dump_data **data,\n\t\t\t    u32 monitor_len)\n{\n\tstruct iwl_dram_data *fw_mon = &trans->dbg.fw_mon;\n\tu32 len = 0;\n\n\tif (trans->dbg.dest_tlv ||\n\t    (fw_mon->size &&\n\t     (trans->trans_cfg->device_family == IWL_DEVICE_FAMILY_7000 ||\n\t      trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_AX210))) {\n\t\tstruct iwl_fw_error_dump_fw_mon *fw_mon_data;\n\n\t\t(*data)->type = cpu_to_le32(IWL_FW_ERROR_DUMP_FW_MONITOR);\n\t\tfw_mon_data = (void *)(*data)->data;\n\n\t\tiwl_trans_pcie_dump_pointers(trans, fw_mon_data);\n\n\t\tlen += sizeof(**data) + sizeof(*fw_mon_data);\n\t\tif (fw_mon->size) {\n\t\t\tmemcpy(fw_mon_data->data, fw_mon->block, fw_mon->size);\n\t\t\tmonitor_len = fw_mon->size;\n\t\t} else if (trans->dbg.dest_tlv->monitor_mode == SMEM_MODE) {\n\t\t\tu32 base = le32_to_cpu(fw_mon_data->fw_mon_base_ptr);\n\t\t\t \n\t\t\tif (trans->dbg.dest_tlv->version) {\n\t\t\t\tbase = (iwl_read_prph(trans, base) &\n\t\t\t\t\tIWL_LDBG_M2S_BUF_BA_MSK) <<\n\t\t\t\t       trans->dbg.dest_tlv->base_shift;\n\t\t\t\tbase *= IWL_M2S_UNIT_SIZE;\n\t\t\t\tbase += trans->cfg->smem_offset;\n\t\t\t} else {\n\t\t\t\tbase = iwl_read_prph(trans, base) <<\n\t\t\t\t       trans->dbg.dest_tlv->base_shift;\n\t\t\t}\n\n\t\t\tiwl_trans_read_mem(trans, base, fw_mon_data->data,\n\t\t\t\t\t   monitor_len / sizeof(u32));\n\t\t} else if (trans->dbg.dest_tlv->monitor_mode == MARBH_MODE) {\n\t\t\tmonitor_len =\n\t\t\t\tiwl_trans_pci_dump_marbh_monitor(trans,\n\t\t\t\t\t\t\t\t fw_mon_data,\n\t\t\t\t\t\t\t\t monitor_len);\n\t\t} else {\n\t\t\t \n\t\t\tmonitor_len = 0;\n\t\t}\n\n\t\tlen += monitor_len;\n\t\t(*data)->len = cpu_to_le32(monitor_len + sizeof(*fw_mon_data));\n\t}\n\n\treturn len;\n}\n\nstatic int iwl_trans_get_fw_monitor_len(struct iwl_trans *trans, u32 *len)\n{\n\tif (trans->dbg.fw_mon.size) {\n\t\t*len += sizeof(struct iwl_fw_error_dump_data) +\n\t\t\tsizeof(struct iwl_fw_error_dump_fw_mon) +\n\t\t\ttrans->dbg.fw_mon.size;\n\t\treturn trans->dbg.fw_mon.size;\n\t} else if (trans->dbg.dest_tlv) {\n\t\tu32 base, end, cfg_reg, monitor_len;\n\n\t\tif (trans->dbg.dest_tlv->version == 1) {\n\t\t\tcfg_reg = le32_to_cpu(trans->dbg.dest_tlv->base_reg);\n\t\t\tcfg_reg = iwl_read_prph(trans, cfg_reg);\n\t\t\tbase = (cfg_reg & IWL_LDBG_M2S_BUF_BA_MSK) <<\n\t\t\t\ttrans->dbg.dest_tlv->base_shift;\n\t\t\tbase *= IWL_M2S_UNIT_SIZE;\n\t\t\tbase += trans->cfg->smem_offset;\n\n\t\t\tmonitor_len =\n\t\t\t\t(cfg_reg & IWL_LDBG_M2S_BUF_SIZE_MSK) >>\n\t\t\t\ttrans->dbg.dest_tlv->end_shift;\n\t\t\tmonitor_len *= IWL_M2S_UNIT_SIZE;\n\t\t} else {\n\t\t\tbase = le32_to_cpu(trans->dbg.dest_tlv->base_reg);\n\t\t\tend = le32_to_cpu(trans->dbg.dest_tlv->end_reg);\n\n\t\t\tbase = iwl_read_prph(trans, base) <<\n\t\t\t       trans->dbg.dest_tlv->base_shift;\n\t\t\tend = iwl_read_prph(trans, end) <<\n\t\t\t      trans->dbg.dest_tlv->end_shift;\n\n\t\t\t \n\t\t\tif (trans->trans_cfg->device_family >=\n\t\t\t    IWL_DEVICE_FAMILY_8000 ||\n\t\t\t    trans->dbg.dest_tlv->monitor_mode == MARBH_MODE)\n\t\t\t\tend += (1 << trans->dbg.dest_tlv->end_shift);\n\t\t\tmonitor_len = end - base;\n\t\t}\n\t\t*len += sizeof(struct iwl_fw_error_dump_data) +\n\t\t\tsizeof(struct iwl_fw_error_dump_fw_mon) +\n\t\t\tmonitor_len;\n\t\treturn monitor_len;\n\t}\n\treturn 0;\n}\n\nstatic struct iwl_trans_dump_data *\niwl_trans_pcie_dump_data(struct iwl_trans *trans,\n\t\t\t u32 dump_mask,\n\t\t\t const struct iwl_dump_sanitize_ops *sanitize_ops,\n\t\t\t void *sanitize_ctx)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tstruct iwl_fw_error_dump_data *data;\n\tstruct iwl_txq *cmdq = trans->txqs.txq[trans->txqs.cmd.q_id];\n\tstruct iwl_fw_error_dump_txcmd *txcmd;\n\tstruct iwl_trans_dump_data *dump_data;\n\tu32 len, num_rbs = 0, monitor_len = 0;\n\tint i, ptr;\n\tbool dump_rbs = test_bit(STATUS_FW_ERROR, &trans->status) &&\n\t\t\t!trans->trans_cfg->mq_rx_supported &&\n\t\t\tdump_mask & BIT(IWL_FW_ERROR_DUMP_RB);\n\n\tif (!dump_mask)\n\t\treturn NULL;\n\n\t \n\tlen = sizeof(*dump_data);\n\n\t \n\tif (dump_mask & BIT(IWL_FW_ERROR_DUMP_TXCMD) && cmdq)\n\t\tlen += sizeof(*data) +\n\t\t\tcmdq->n_window * (sizeof(*txcmd) +\n\t\t\t\t\t  TFD_MAX_PAYLOAD_SIZE);\n\n\t \n\tif (dump_mask & BIT(IWL_FW_ERROR_DUMP_FW_MONITOR))\n\t\tmonitor_len = iwl_trans_get_fw_monitor_len(trans, &len);\n\n\t \n\tif (dump_mask & BIT(IWL_FW_ERROR_DUMP_CSR))\n\t\tlen += sizeof(*data) + IWL_CSR_TO_DUMP;\n\n\t \n\tif (dump_mask & BIT(IWL_FW_ERROR_DUMP_FH_REGS)) {\n\t\tif (trans->trans_cfg->gen2)\n\t\t\tlen += sizeof(*data) +\n\t\t\t       (iwl_umac_prph(trans, FH_MEM_UPPER_BOUND_GEN2) -\n\t\t\t\tiwl_umac_prph(trans, FH_MEM_LOWER_BOUND_GEN2));\n\t\telse\n\t\t\tlen += sizeof(*data) +\n\t\t\t       (FH_MEM_UPPER_BOUND -\n\t\t\t\tFH_MEM_LOWER_BOUND);\n\t}\n\n\tif (dump_rbs) {\n\t\t \n\t\tstruct iwl_rxq *rxq = &trans_pcie->rxq[0];\n\t\t \n\t\tnum_rbs =\n\t\t\tle16_to_cpu(iwl_get_closed_rb_stts(trans, rxq))\n\t\t\t& 0x0FFF;\n\t\tnum_rbs = (num_rbs - rxq->read) & RX_QUEUE_MASK;\n\t\tlen += num_rbs * (sizeof(*data) +\n\t\t\t\t  sizeof(struct iwl_fw_error_dump_rb) +\n\t\t\t\t  (PAGE_SIZE << trans_pcie->rx_page_order));\n\t}\n\n\t \n\tif (trans->trans_cfg->gen2 && dump_mask & BIT(IWL_FW_ERROR_DUMP_PAGING))\n\t\tfor (i = 0; i < trans->init_dram.paging_cnt; i++)\n\t\t\tlen += sizeof(*data) +\n\t\t\t       sizeof(struct iwl_fw_error_dump_paging) +\n\t\t\t       trans->init_dram.paging[i].size;\n\n\tdump_data = vzalloc(len);\n\tif (!dump_data)\n\t\treturn NULL;\n\n\tlen = 0;\n\tdata = (void *)dump_data->data;\n\n\tif (dump_mask & BIT(IWL_FW_ERROR_DUMP_TXCMD) && cmdq) {\n\t\tu16 tfd_size = trans->txqs.tfd.size;\n\n\t\tdata->type = cpu_to_le32(IWL_FW_ERROR_DUMP_TXCMD);\n\t\ttxcmd = (void *)data->data;\n\t\tspin_lock_bh(&cmdq->lock);\n\t\tptr = cmdq->write_ptr;\n\t\tfor (i = 0; i < cmdq->n_window; i++) {\n\t\t\tu8 idx = iwl_txq_get_cmd_index(cmdq, ptr);\n\t\t\tu8 tfdidx;\n\t\t\tu32 caplen, cmdlen;\n\n\t\t\tif (trans->trans_cfg->gen2)\n\t\t\t\ttfdidx = idx;\n\t\t\telse\n\t\t\t\ttfdidx = ptr;\n\n\t\t\tcmdlen = iwl_trans_pcie_get_cmdlen(trans,\n\t\t\t\t\t\t\t   (u8 *)cmdq->tfds +\n\t\t\t\t\t\t\t   tfd_size * tfdidx);\n\t\t\tcaplen = min_t(u32, TFD_MAX_PAYLOAD_SIZE, cmdlen);\n\n\t\t\tif (cmdlen) {\n\t\t\t\tlen += sizeof(*txcmd) + caplen;\n\t\t\t\ttxcmd->cmdlen = cpu_to_le32(cmdlen);\n\t\t\t\ttxcmd->caplen = cpu_to_le32(caplen);\n\t\t\t\tmemcpy(txcmd->data, cmdq->entries[idx].cmd,\n\t\t\t\t       caplen);\n\t\t\t\tif (sanitize_ops && sanitize_ops->frob_hcmd)\n\t\t\t\t\tsanitize_ops->frob_hcmd(sanitize_ctx,\n\t\t\t\t\t\t\t\ttxcmd->data,\n\t\t\t\t\t\t\t\tcaplen);\n\t\t\t\ttxcmd = (void *)((u8 *)txcmd->data + caplen);\n\t\t\t}\n\n\t\t\tptr = iwl_txq_dec_wrap(trans, ptr);\n\t\t}\n\t\tspin_unlock_bh(&cmdq->lock);\n\n\t\tdata->len = cpu_to_le32(len);\n\t\tlen += sizeof(*data);\n\t\tdata = iwl_fw_error_next_data(data);\n\t}\n\n\tif (dump_mask & BIT(IWL_FW_ERROR_DUMP_CSR))\n\t\tlen += iwl_trans_pcie_dump_csr(trans, &data);\n\tif (dump_mask & BIT(IWL_FW_ERROR_DUMP_FH_REGS))\n\t\tlen += iwl_trans_pcie_fh_regs_dump(trans, &data);\n\tif (dump_rbs)\n\t\tlen += iwl_trans_pcie_dump_rbs(trans, &data, num_rbs);\n\n\t \n\tif (trans->trans_cfg->gen2 &&\n\t    dump_mask & BIT(IWL_FW_ERROR_DUMP_PAGING)) {\n\t\tfor (i = 0; i < trans->init_dram.paging_cnt; i++) {\n\t\t\tstruct iwl_fw_error_dump_paging *paging;\n\t\t\tu32 page_len = trans->init_dram.paging[i].size;\n\n\t\t\tdata->type = cpu_to_le32(IWL_FW_ERROR_DUMP_PAGING);\n\t\t\tdata->len = cpu_to_le32(sizeof(*paging) + page_len);\n\t\t\tpaging = (void *)data->data;\n\t\t\tpaging->index = cpu_to_le32(i);\n\t\t\tmemcpy(paging->data,\n\t\t\t       trans->init_dram.paging[i].block, page_len);\n\t\t\tdata = iwl_fw_error_next_data(data);\n\n\t\t\tlen += sizeof(*data) + sizeof(*paging) + page_len;\n\t\t}\n\t}\n\tif (dump_mask & BIT(IWL_FW_ERROR_DUMP_FW_MONITOR))\n\t\tlen += iwl_trans_pcie_dump_monitor(trans, &data, monitor_len);\n\n\tdump_data->len = len;\n\n\treturn dump_data;\n}\n\nstatic void iwl_trans_pci_interrupts(struct iwl_trans *trans, bool enable)\n{\n\tif (enable)\n\t\tiwl_enable_interrupts(trans);\n\telse\n\t\tiwl_disable_interrupts(trans);\n}\n\nstatic void iwl_trans_pcie_sync_nmi(struct iwl_trans *trans)\n{\n\tu32 inta_addr, sw_err_bit;\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\n\tif (trans_pcie->msix_enabled) {\n\t\tinta_addr = CSR_MSIX_HW_INT_CAUSES_AD;\n\t\tif (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_BZ)\n\t\t\tsw_err_bit = MSIX_HW_INT_CAUSES_REG_SW_ERR_BZ;\n\t\telse\n\t\t\tsw_err_bit = MSIX_HW_INT_CAUSES_REG_SW_ERR;\n\t} else {\n\t\tinta_addr = CSR_INT;\n\t\tsw_err_bit = CSR_INT_BIT_SW_ERR;\n\t}\n\n\tiwl_trans_sync_nmi_with_addr(trans, inta_addr, sw_err_bit);\n}\n\n#define IWL_TRANS_COMMON_OPS\t\t\t\t\t\t\\\n\t.op_mode_leave = iwl_trans_pcie_op_mode_leave,\t\t\t\\\n\t.write8 = iwl_trans_pcie_write8,\t\t\t\t\\\n\t.write32 = iwl_trans_pcie_write32,\t\t\t\t\\\n\t.read32 = iwl_trans_pcie_read32,\t\t\t\t\\\n\t.read_prph = iwl_trans_pcie_read_prph,\t\t\t\t\\\n\t.write_prph = iwl_trans_pcie_write_prph,\t\t\t\\\n\t.read_mem = iwl_trans_pcie_read_mem,\t\t\t\t\\\n\t.write_mem = iwl_trans_pcie_write_mem,\t\t\t\t\\\n\t.read_config32 = iwl_trans_pcie_read_config32,\t\t\t\\\n\t.configure = iwl_trans_pcie_configure,\t\t\t\t\\\n\t.set_pmi = iwl_trans_pcie_set_pmi,\t\t\t\t\\\n\t.sw_reset = iwl_trans_pcie_sw_reset,\t\t\t\t\\\n\t.grab_nic_access = iwl_trans_pcie_grab_nic_access,\t\t\\\n\t.release_nic_access = iwl_trans_pcie_release_nic_access,\t\\\n\t.set_bits_mask = iwl_trans_pcie_set_bits_mask,\t\t\t\\\n\t.dump_data = iwl_trans_pcie_dump_data,\t\t\t\t\\\n\t.d3_suspend = iwl_trans_pcie_d3_suspend,\t\t\t\\\n\t.d3_resume = iwl_trans_pcie_d3_resume,\t\t\t\t\\\n\t.interrupts = iwl_trans_pci_interrupts,\t\t\t\t\\\n\t.sync_nmi = iwl_trans_pcie_sync_nmi,\t\t\t\t\\\n\t.imr_dma_data = iwl_trans_pcie_copy_imr\t\t\t\t\\\n\nstatic const struct iwl_trans_ops trans_ops_pcie = {\n\tIWL_TRANS_COMMON_OPS,\n\t.start_hw = iwl_trans_pcie_start_hw,\n\t.fw_alive = iwl_trans_pcie_fw_alive,\n\t.start_fw = iwl_trans_pcie_start_fw,\n\t.stop_device = iwl_trans_pcie_stop_device,\n\n\t.send_cmd = iwl_pcie_enqueue_hcmd,\n\n\t.tx = iwl_trans_pcie_tx,\n\t.reclaim = iwl_txq_reclaim,\n\n\t.txq_disable = iwl_trans_pcie_txq_disable,\n\t.txq_enable = iwl_trans_pcie_txq_enable,\n\n\t.txq_set_shared_mode = iwl_trans_pcie_txq_set_shared_mode,\n\n\t.wait_tx_queues_empty = iwl_trans_pcie_wait_txqs_empty,\n\n\t.freeze_txq_timer = iwl_trans_txq_freeze_timer,\n\t.block_txq_ptrs = iwl_trans_pcie_block_txq_ptrs,\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\t.debugfs_cleanup = iwl_trans_pcie_debugfs_cleanup,\n#endif\n};\n\nstatic const struct iwl_trans_ops trans_ops_pcie_gen2 = {\n\tIWL_TRANS_COMMON_OPS,\n\t.start_hw = iwl_trans_pcie_start_hw,\n\t.fw_alive = iwl_trans_pcie_gen2_fw_alive,\n\t.start_fw = iwl_trans_pcie_gen2_start_fw,\n\t.stop_device = iwl_trans_pcie_gen2_stop_device,\n\n\t.send_cmd = iwl_pcie_gen2_enqueue_hcmd,\n\n\t.tx = iwl_txq_gen2_tx,\n\t.reclaim = iwl_txq_reclaim,\n\n\t.set_q_ptrs = iwl_txq_set_q_ptrs,\n\n\t.txq_alloc = iwl_txq_dyn_alloc,\n\t.txq_free = iwl_txq_dyn_free,\n\t.wait_txq_empty = iwl_trans_pcie_wait_txq_empty,\n\t.rxq_dma_data = iwl_trans_pcie_rxq_dma_data,\n\t.load_pnvm = iwl_trans_pcie_ctx_info_gen3_load_pnvm,\n\t.set_pnvm = iwl_trans_pcie_ctx_info_gen3_set_pnvm,\n\t.load_reduce_power = iwl_trans_pcie_ctx_info_gen3_load_reduce_power,\n\t.set_reduce_power = iwl_trans_pcie_ctx_info_gen3_set_reduce_power,\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\t.debugfs_cleanup = iwl_trans_pcie_debugfs_cleanup,\n#endif\n};\n\nstruct iwl_trans *iwl_trans_pcie_alloc(struct pci_dev *pdev,\n\t\t\t       const struct pci_device_id *ent,\n\t\t\t       const struct iwl_cfg_trans_params *cfg_trans)\n{\n\tstruct iwl_trans_pcie *trans_pcie;\n\tstruct iwl_trans *trans;\n\tint ret, addr_size;\n\tconst struct iwl_trans_ops *ops = &trans_ops_pcie_gen2;\n\tvoid __iomem * const *table;\n\n\tif (!cfg_trans->gen2)\n\t\tops = &trans_ops_pcie;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\ttrans = iwl_trans_alloc(sizeof(struct iwl_trans_pcie), &pdev->dev, ops,\n\t\t\t\tcfg_trans);\n\tif (!trans)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttrans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\n\ttrans_pcie->trans = trans;\n\ttrans_pcie->opmode_down = true;\n\tspin_lock_init(&trans_pcie->irq_lock);\n\tspin_lock_init(&trans_pcie->reg_lock);\n\tspin_lock_init(&trans_pcie->alloc_page_lock);\n\tmutex_init(&trans_pcie->mutex);\n\tinit_waitqueue_head(&trans_pcie->ucode_write_waitq);\n\tinit_waitqueue_head(&trans_pcie->fw_reset_waitq);\n\tinit_waitqueue_head(&trans_pcie->imr_waitq);\n\n\ttrans_pcie->rba.alloc_wq = alloc_workqueue(\"rb_allocator\",\n\t\t\t\t\t\t   WQ_HIGHPRI | WQ_UNBOUND, 0);\n\tif (!trans_pcie->rba.alloc_wq) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_trans;\n\t}\n\tINIT_WORK(&trans_pcie->rba.rx_alloc, iwl_pcie_rx_allocator_work);\n\n\ttrans_pcie->debug_rfkill = -1;\n\n\tif (!cfg_trans->base_params->pcie_l1_allowed) {\n\t\t \n\t\tpci_disable_link_state(pdev, PCIE_LINK_STATE_L0S |\n\t\t\t\t       PCIE_LINK_STATE_L1 |\n\t\t\t\t       PCIE_LINK_STATE_CLKPM);\n\t}\n\n\tpci_set_master(pdev);\n\n\taddr_size = trans->txqs.tfd.addr_size;\n\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(addr_size));\n\tif (ret) {\n\t\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\t\t \n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"No suitable DMA available\\n\");\n\t\t\tgoto out_no_pci;\n\t\t}\n\t}\n\n\tret = pcim_iomap_regions_request_all(pdev, BIT(0), DRV_NAME);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"pcim_iomap_regions_request_all failed\\n\");\n\t\tgoto out_no_pci;\n\t}\n\n\ttable = pcim_iomap_table(pdev);\n\tif (!table) {\n\t\tdev_err(&pdev->dev, \"pcim_iomap_table failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_no_pci;\n\t}\n\n\ttrans_pcie->hw_base = table[0];\n\tif (!trans_pcie->hw_base) {\n\t\tdev_err(&pdev->dev, \"couldn't find IO mem in first BAR\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_no_pci;\n\t}\n\n\t \n\tpci_write_config_byte(pdev, PCI_CFG_RETRY_TIMEOUT, 0x00);\n\n\ttrans_pcie->pci_dev = pdev;\n\tiwl_disable_interrupts(trans);\n\n\ttrans->hw_rev = iwl_read32(trans, CSR_HW_REV);\n\tif (trans->hw_rev == 0xffffffff) {\n\t\tdev_err(&pdev->dev, \"HW_REV=0xFFFFFFFF, PCI issues?\\n\");\n\t\tret = -EIO;\n\t\tgoto out_no_pci;\n\t}\n\n\t \n\tif (cfg_trans->device_family >= IWL_DEVICE_FAMILY_8000)\n\t\ttrans->hw_rev_step = trans->hw_rev & 0xF;\n\telse\n\t\ttrans->hw_rev_step = (trans->hw_rev & 0xC) >> 2;\n\n\tIWL_DEBUG_INFO(trans, \"HW REV: 0x%0x\\n\", trans->hw_rev);\n\n\tiwl_pcie_set_interrupt_capa(pdev, trans, cfg_trans);\n\ttrans->hw_id = (pdev->device << 16) + pdev->subsystem_device;\n\tsnprintf(trans->hw_id_str, sizeof(trans->hw_id_str),\n\t\t \"PCI ID: 0x%04X:0x%04X\", pdev->device, pdev->subsystem_device);\n\n\tinit_waitqueue_head(&trans_pcie->sx_waitq);\n\n\tret = iwl_pcie_alloc_invalid_tx_cmd(trans);\n\tif (ret)\n\t\tgoto out_no_pci;\n\n\tif (trans_pcie->msix_enabled) {\n\t\tret = iwl_pcie_init_msix_handler(pdev, trans_pcie);\n\t\tif (ret)\n\t\t\tgoto out_no_pci;\n\t } else {\n\t\tret = iwl_pcie_alloc_ict(trans);\n\t\tif (ret)\n\t\t\tgoto out_no_pci;\n\n\t\tret = devm_request_threaded_irq(&pdev->dev, pdev->irq,\n\t\t\t\t\t\tiwl_pcie_isr,\n\t\t\t\t\t\tiwl_pcie_irq_handler,\n\t\t\t\t\t\tIRQF_SHARED, DRV_NAME, trans);\n\t\tif (ret) {\n\t\t\tIWL_ERR(trans, \"Error allocating IRQ %d\\n\", pdev->irq);\n\t\t\tgoto out_free_ict;\n\t\t}\n\t }\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\ttrans_pcie->fw_mon_data.state = IWL_FW_MON_DBGFS_STATE_CLOSED;\n\tmutex_init(&trans_pcie->fw_mon_data.mutex);\n#endif\n\n\tiwl_dbg_tlv_init(trans);\n\n\treturn trans;\n\nout_free_ict:\n\tiwl_pcie_free_ict(trans);\nout_no_pci:\n\tdestroy_workqueue(trans_pcie->rba.alloc_wq);\nout_free_trans:\n\tiwl_trans_free(trans);\n\treturn ERR_PTR(ret);\n}\n\nvoid iwl_trans_pcie_copy_imr_fh(struct iwl_trans *trans,\n\t\t\t\tu32 dst_addr, u64 src_addr, u32 byte_cnt)\n{\n\tiwl_write_prph(trans, IMR_UREG_CHICK,\n\t\t       iwl_read_prph(trans, IMR_UREG_CHICK) |\n\t\t       IMR_UREG_CHICK_HALT_UMAC_PERMANENTLY_MSK);\n\tiwl_write_prph(trans, IMR_TFH_SRV_DMA_CHNL0_SRAM_ADDR, dst_addr);\n\tiwl_write_prph(trans, IMR_TFH_SRV_DMA_CHNL0_DRAM_ADDR_LSB,\n\t\t       (u32)(src_addr & 0xFFFFFFFF));\n\tiwl_write_prph(trans, IMR_TFH_SRV_DMA_CHNL0_DRAM_ADDR_MSB,\n\t\t       iwl_get_dma_hi_addr(src_addr));\n\tiwl_write_prph(trans, IMR_TFH_SRV_DMA_CHNL0_BC, byte_cnt);\n\tiwl_write_prph(trans, IMR_TFH_SRV_DMA_CHNL0_CTRL,\n\t\t       IMR_TFH_SRV_DMA_CHNL0_CTRL_D2S_IRQ_TARGET_POS |\n\t\t       IMR_TFH_SRV_DMA_CHNL0_CTRL_D2S_DMA_EN_POS |\n\t\t       IMR_TFH_SRV_DMA_CHNL0_CTRL_D2S_RS_MSK);\n}\n\nint iwl_trans_pcie_copy_imr(struct iwl_trans *trans,\n\t\t\t    u32 dst_addr, u64 src_addr, u32 byte_cnt)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tint ret = -1;\n\n\ttrans_pcie->imr_status = IMR_D2S_REQUESTED;\n\tiwl_trans_pcie_copy_imr_fh(trans, dst_addr, src_addr, byte_cnt);\n\tret = wait_event_timeout(trans_pcie->imr_waitq,\n\t\t\t\t trans_pcie->imr_status !=\n\t\t\t\t IMR_D2S_REQUESTED, 5 * HZ);\n\tif (!ret || trans_pcie->imr_status == IMR_D2S_ERROR) {\n\t\tIWL_ERR(trans, \"Failed to copy IMR Memory chunk!\\n\");\n\t\tiwl_trans_pcie_dump_regs(trans);\n\t\treturn -ETIMEDOUT;\n\t}\n\ttrans_pcie->imr_status = IMR_D2S_IDLE;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}