{
  "module_name": "trans-gen2.c",
  "hash_id": "fefe913daec0185a54990033cc7b2533732a24499b8f1fa5a0446415f4ff301f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/pcie/trans-gen2.c",
  "human_readable_source": "\n \n#include \"iwl-trans.h\"\n#include \"iwl-prph.h\"\n#include \"iwl-context-info.h\"\n#include \"iwl-context-info-gen3.h\"\n#include \"internal.h\"\n#include \"fw/dbg.h\"\n\n#define FW_RESET_TIMEOUT (HZ / 5)\n\n \nint iwl_pcie_gen2_apm_init(struct iwl_trans *trans)\n{\n\tint ret = 0;\n\n\tIWL_DEBUG_INFO(trans, \"Init card's basic functions\\n\");\n\n\t \n\n\t \n\tiwl_set_bit(trans, CSR_GIO_CHICKEN_BITS,\n\t\t    CSR_GIO_CHICKEN_BITS_REG_BIT_L1A_NO_L0S_RX);\n\n\t \n\tiwl_set_bit(trans, CSR_DBG_HPET_MEM_REG, CSR_DBG_HPET_MEM_REG_VAL);\n\n\t \n\tiwl_set_bit(trans, CSR_HW_IF_CONFIG_REG,\n\t\t    CSR_HW_IF_CONFIG_REG_BIT_HAP_WAKE_L1A);\n\n\tiwl_pcie_apm_config(trans);\n\n\tret = iwl_finish_nic_init(trans);\n\tif (ret)\n\t\treturn ret;\n\n\tset_bit(STATUS_DEVICE_ENABLED, &trans->status);\n\n\treturn 0;\n}\n\nstatic void iwl_pcie_gen2_apm_stop(struct iwl_trans *trans, bool op_mode_leave)\n{\n\tIWL_DEBUG_INFO(trans, \"Stop card, put in low power state\\n\");\n\n\tif (op_mode_leave) {\n\t\tif (!test_bit(STATUS_DEVICE_ENABLED, &trans->status))\n\t\t\tiwl_pcie_gen2_apm_init(trans);\n\n\t\t \n\t\tiwl_set_bit(trans, CSR_DBG_LINK_PWR_MGMT_REG,\n\t\t\t    CSR_RESET_LINK_PWR_MGMT_DISABLED);\n\t\tiwl_set_bit(trans, CSR_HW_IF_CONFIG_REG,\n\t\t\t    CSR_HW_IF_CONFIG_REG_PREPARE |\n\t\t\t    CSR_HW_IF_CONFIG_REG_ENABLE_PME);\n\t\tmdelay(1);\n\t\tiwl_clear_bit(trans, CSR_DBG_LINK_PWR_MGMT_REG,\n\t\t\t      CSR_RESET_LINK_PWR_MGMT_DISABLED);\n\t\tmdelay(5);\n\t}\n\n\tclear_bit(STATUS_DEVICE_ENABLED, &trans->status);\n\n\t \n\tiwl_pcie_apm_stop_master(trans);\n\n\tiwl_trans_sw_reset(trans, false);\n\n\t \n\tif (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_BZ)\n\t\tiwl_clear_bit(trans, CSR_GP_CNTRL,\n\t\t\t      CSR_GP_CNTRL_REG_FLAG_MAC_INIT);\n\telse\n\t\tiwl_clear_bit(trans, CSR_GP_CNTRL,\n\t\t\t      CSR_GP_CNTRL_REG_FLAG_INIT_DONE);\n}\n\nstatic void iwl_trans_pcie_fw_reset_handshake(struct iwl_trans *trans)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tint ret;\n\n\ttrans_pcie->fw_reset_state = FW_RESET_REQUESTED;\n\n\tif (trans->trans_cfg->device_family < IWL_DEVICE_FAMILY_AX210)\n\t\tiwl_write_umac_prph(trans, UREG_NIC_SET_NMI_DRIVER,\n\t\t\t\t    UREG_NIC_SET_NMI_DRIVER_RESET_HANDSHAKE);\n\telse if (trans->trans_cfg->device_family == IWL_DEVICE_FAMILY_AX210)\n\t\tiwl_write_umac_prph(trans, UREG_DOORBELL_TO_ISR6,\n\t\t\t\t    UREG_DOORBELL_TO_ISR6_RESET_HANDSHAKE);\n\telse\n\t\tiwl_write32(trans, CSR_DOORBELL_VECTOR,\n\t\t\t    UREG_DOORBELL_TO_ISR6_RESET_HANDSHAKE);\n\n\t \n\tret = wait_event_timeout(trans_pcie->fw_reset_waitq,\n\t\t\t\t trans_pcie->fw_reset_state != FW_RESET_REQUESTED,\n\t\t\t\t FW_RESET_TIMEOUT);\n\tif (!ret || trans_pcie->fw_reset_state == FW_RESET_ERROR) {\n\t\tu32 inta_hw = iwl_read32(trans, CSR_MSIX_HW_INT_CAUSES_AD);\n\n\t\tIWL_ERR(trans,\n\t\t\t\"timeout waiting for FW reset ACK (inta_hw=0x%x)\\n\",\n\t\t\tinta_hw);\n\n\t\tif (!(inta_hw & MSIX_HW_INT_CAUSES_REG_RESET_DONE))\n\t\t\tiwl_trans_fw_error(trans, true);\n\t}\n\n\ttrans_pcie->fw_reset_state = FW_RESET_IDLE;\n}\n\nvoid _iwl_trans_pcie_gen2_stop_device(struct iwl_trans *trans)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\n\tlockdep_assert_held(&trans_pcie->mutex);\n\n\tif (trans_pcie->is_down)\n\t\treturn;\n\n\tif (trans->state >= IWL_TRANS_FW_STARTED)\n\t\tif (trans_pcie->fw_reset_handshake)\n\t\t\tiwl_trans_pcie_fw_reset_handshake(trans);\n\n\ttrans_pcie->is_down = true;\n\n\t \n\tiwl_disable_interrupts(trans);\n\n\t \n\tiwl_pcie_disable_ict(trans);\n\n\t \n\tif (test_and_clear_bit(STATUS_DEVICE_ENABLED, &trans->status)) {\n\t\tIWL_DEBUG_INFO(trans,\n\t\t\t       \"DEVICE_ENABLED bit was set and is now cleared\\n\");\n\t\tiwl_pcie_synchronize_irqs(trans);\n\t\tiwl_pcie_rx_napi_sync(trans);\n\t\tiwl_txq_gen2_tx_free(trans);\n\t\tiwl_pcie_rx_stop(trans);\n\t}\n\n\tiwl_pcie_ctxt_info_free_paging(trans);\n\tif (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_AX210)\n\t\tiwl_pcie_ctxt_info_gen3_free(trans, false);\n\telse\n\t\tiwl_pcie_ctxt_info_free(trans);\n\n\t \n\tiwl_pcie_gen2_apm_stop(trans, false);\n\n\t \n\tiwl_trans_sw_reset(trans, true);\n\n\t \n\tiwl_pcie_conf_msix_hw(trans_pcie);\n\n\t \n\tiwl_disable_interrupts(trans);\n\n\t \n\tclear_bit(STATUS_SYNC_HCMD_ACTIVE, &trans->status);\n\tclear_bit(STATUS_INT_ENABLED, &trans->status);\n\tclear_bit(STATUS_TPOWER_PMI, &trans->status);\n\n\t \n\tiwl_enable_rfkill_int(trans);\n}\n\nvoid iwl_trans_pcie_gen2_stop_device(struct iwl_trans *trans)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tbool was_in_rfkill;\n\n\tiwl_op_mode_time_point(trans->op_mode,\n\t\t\t       IWL_FW_INI_TIME_POINT_HOST_DEVICE_DISABLE,\n\t\t\t       NULL);\n\n\tmutex_lock(&trans_pcie->mutex);\n\ttrans_pcie->opmode_down = true;\n\twas_in_rfkill = test_bit(STATUS_RFKILL_OPMODE, &trans->status);\n\t_iwl_trans_pcie_gen2_stop_device(trans);\n\tiwl_trans_pcie_handle_stop_rfkill(trans, was_in_rfkill);\n\tmutex_unlock(&trans_pcie->mutex);\n}\n\nstatic int iwl_pcie_gen2_nic_init(struct iwl_trans *trans)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tint queue_size = max_t(u32, IWL_CMD_QUEUE_SIZE,\n\t\t\t       trans->cfg->min_txq_size);\n\n\t \n\tspin_lock_bh(&trans_pcie->irq_lock);\n\tiwl_pcie_gen2_apm_init(trans);\n\tspin_unlock_bh(&trans_pcie->irq_lock);\n\n\tiwl_op_mode_nic_config(trans->op_mode);\n\n\t \n\tif (iwl_pcie_gen2_rx_init(trans))\n\t\treturn -ENOMEM;\n\n\t \n\tif (iwl_txq_gen2_init(trans, trans->txqs.cmd.q_id, queue_size))\n\t\treturn -ENOMEM;\n\n\t \n\tiwl_set_bit(trans, CSR_MAC_SHADOW_REG_CTRL, 0x800FFFFF);\n\tIWL_DEBUG_INFO(trans, \"Enabling shadow registers in device\\n\");\n\n\treturn 0;\n}\n\nstatic void iwl_pcie_get_rf_name(struct iwl_trans *trans)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tchar *buf = trans_pcie->rf_name;\n\tsize_t buflen = sizeof(trans_pcie->rf_name);\n\tsize_t pos;\n\tu32 version;\n\n\tif (buf[0])\n\t\treturn;\n\n\tswitch (CSR_HW_RFID_TYPE(trans->hw_rf_id)) {\n\tcase CSR_HW_RFID_TYPE(CSR_HW_RF_ID_TYPE_JF):\n\t\tpos = scnprintf(buf, buflen, \"JF\");\n\t\tbreak;\n\tcase CSR_HW_RFID_TYPE(CSR_HW_RF_ID_TYPE_GF):\n\t\tpos = scnprintf(buf, buflen, \"GF\");\n\t\tbreak;\n\tcase CSR_HW_RFID_TYPE(CSR_HW_RF_ID_TYPE_GF4):\n\t\tpos = scnprintf(buf, buflen, \"GF4\");\n\t\tbreak;\n\tcase CSR_HW_RFID_TYPE(CSR_HW_RF_ID_TYPE_HR):\n\t\tpos = scnprintf(buf, buflen, \"HR\");\n\t\tbreak;\n\tcase CSR_HW_RFID_TYPE(CSR_HW_RF_ID_TYPE_HR1):\n\t\tpos = scnprintf(buf, buflen, \"HR1\");\n\t\tbreak;\n\tcase CSR_HW_RFID_TYPE(CSR_HW_RF_ID_TYPE_HRCDB):\n\t\tpos = scnprintf(buf, buflen, \"HRCDB\");\n\t\tbreak;\n\tcase CSR_HW_RFID_TYPE(CSR_HW_RF_ID_TYPE_MS):\n\t\tpos = scnprintf(buf, buflen, \"MS\");\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tswitch (CSR_HW_RFID_TYPE(trans->hw_rf_id)) {\n\tcase CSR_HW_RFID_TYPE(CSR_HW_RF_ID_TYPE_HR):\n\tcase CSR_HW_RFID_TYPE(CSR_HW_RF_ID_TYPE_HR1):\n\tcase CSR_HW_RFID_TYPE(CSR_HW_RF_ID_TYPE_HRCDB):\n\t\tversion = iwl_read_prph(trans, CNVI_MBOX_C);\n\t\tswitch (version) {\n\t\tcase 0x20000:\n\t\t\tpos += scnprintf(buf + pos, buflen - pos, \" B3\");\n\t\t\tbreak;\n\t\tcase 0x120000:\n\t\t\tpos += scnprintf(buf + pos, buflen - pos, \" B5\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpos += scnprintf(buf + pos, buflen - pos,\n\t\t\t\t\t \" (0x%x)\", version);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tpos += scnprintf(buf + pos, buflen - pos, \", rfid=0x%x\",\n\t\t\t trans->hw_rf_id);\n\n\tIWL_INFO(trans, \"Detected RF %s\\n\", buf);\n\n\t \n\tpos += scnprintf(buf + pos, buflen - pos, \"\\n\");\n}\n\nvoid iwl_trans_pcie_gen2_fw_alive(struct iwl_trans *trans, u32 scd_addr)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\n\tiwl_pcie_reset_ict(trans);\n\n\t \n\tmemset(trans->txqs.queue_stopped, 0,\n\t       sizeof(trans->txqs.queue_stopped));\n\tmemset(trans->txqs.queue_used, 0, sizeof(trans->txqs.queue_used));\n\n\t \n\tif (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_AX210)\n\t\tiwl_pcie_ctxt_info_gen3_free(trans, true);\n\telse\n\t\tiwl_pcie_ctxt_info_free(trans);\n\n\t \n\tiwl_enable_interrupts(trans);\n\tmutex_lock(&trans_pcie->mutex);\n\tiwl_pcie_check_hw_rf_kill(trans);\n\n\tiwl_pcie_get_rf_name(trans);\n\tmutex_unlock(&trans_pcie->mutex);\n}\n\nstatic bool iwl_pcie_set_ltr(struct iwl_trans *trans)\n{\n\tu32 ltr_val = CSR_LTR_LONG_VAL_AD_NO_SNOOP_REQ |\n\t\t      u32_encode_bits(CSR_LTR_LONG_VAL_AD_SCALE_USEC,\n\t\t\t\t      CSR_LTR_LONG_VAL_AD_NO_SNOOP_SCALE) |\n\t\t      u32_encode_bits(250,\n\t\t\t\t      CSR_LTR_LONG_VAL_AD_NO_SNOOP_VAL) |\n\t\t      CSR_LTR_LONG_VAL_AD_SNOOP_REQ |\n\t\t      u32_encode_bits(CSR_LTR_LONG_VAL_AD_SCALE_USEC,\n\t\t\t\t      CSR_LTR_LONG_VAL_AD_SNOOP_SCALE) |\n\t\t      u32_encode_bits(250, CSR_LTR_LONG_VAL_AD_SNOOP_VAL);\n\n\t \n\tif ((trans->trans_cfg->device_family == IWL_DEVICE_FAMILY_AX210 ||\n\t     trans->trans_cfg->device_family == IWL_DEVICE_FAMILY_22000) &&\n\t    !trans->trans_cfg->integrated) {\n\t\tiwl_write32(trans, CSR_LTR_LONG_VAL_AD, ltr_val);\n\t\treturn true;\n\t}\n\n\tif (trans->trans_cfg->integrated &&\n\t    trans->trans_cfg->device_family == IWL_DEVICE_FAMILY_22000) {\n\t\tiwl_write_prph(trans, HPM_MAC_LTR_CSR, HPM_MAC_LRT_ENABLE_ALL);\n\t\tiwl_write_prph(trans, HPM_UMAC_LTR, ltr_val);\n\t\treturn true;\n\t}\n\n\tif (trans->trans_cfg->device_family == IWL_DEVICE_FAMILY_AX210) {\n\t\t \n\t\tiwl_write32(trans, CSR_MSIX_HW_INT_CAUSES_AD,\n\t\t\t    MSIX_HW_INT_CAUSES_REG_IML);\n\t\t \n\t\treturn false;\n\t}\n\n\t \n\treturn true;\n}\n\nstatic void iwl_pcie_spin_for_iml(struct iwl_trans *trans)\n{\n \n#define IML_WAIT_TIMEOUT\t(HZ / 10)\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tunsigned long end_time = jiffies + IML_WAIT_TIMEOUT;\n\tu32 value, loops = 0;\n\tbool irq = false;\n\n\tif (WARN_ON(!trans_pcie->iml))\n\t\treturn;\n\n\tvalue = iwl_read32(trans, CSR_LTR_LAST_MSG);\n\tIWL_DEBUG_INFO(trans, \"Polling for IML load - CSR_LTR_LAST_MSG=0x%x\\n\",\n\t\t       value);\n\n\twhile (time_before(jiffies, end_time)) {\n\t\tif (iwl_read32(trans, CSR_MSIX_HW_INT_CAUSES_AD) &\n\t\t\t\tMSIX_HW_INT_CAUSES_REG_IML) {\n\t\t\tirq = true;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tvalue = iwl_read32(trans, CSR_LTR_LAST_MSG);\n\t\tloops++;\n\t}\n\n\tIWL_DEBUG_INFO(trans,\n\t\t       \"Polled for IML load: irq=%d, loops=%d, CSR_LTR_LAST_MSG=0x%x\\n\",\n\t\t       irq, loops, value);\n\n\t \n}\n\nint iwl_trans_pcie_gen2_start_fw(struct iwl_trans *trans,\n\t\t\t\t const struct fw_img *fw, bool run_in_rfkill)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tbool hw_rfkill, keep_ram_busy;\n\tint ret;\n\n\t \n\tif (iwl_pcie_prepare_card_hw(trans)) {\n\t\tIWL_WARN(trans, \"Exit HW not ready\\n\");\n\t\treturn -EIO;\n\t}\n\n\tiwl_enable_rfkill_int(trans);\n\n\tiwl_write32(trans, CSR_INT, 0xFFFFFFFF);\n\n\t \n\tiwl_disable_interrupts(trans);\n\n\t \n\tiwl_pcie_synchronize_irqs(trans);\n\n\tmutex_lock(&trans_pcie->mutex);\n\n\t \n\thw_rfkill = iwl_pcie_check_hw_rf_kill(trans);\n\tif (hw_rfkill && !run_in_rfkill) {\n\t\tret = -ERFKILL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (trans_pcie->is_down) {\n\t\tIWL_WARN(trans,\n\t\t\t \"Can't start_fw since the HW hasn't been started\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tiwl_write32(trans, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_SW_BIT_RFKILL);\n\tiwl_write32(trans, CSR_UCODE_DRV_GP1_CLR,\n\t\t    CSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED);\n\n\t \n\tiwl_write32(trans, CSR_INT, 0xFFFFFFFF);\n\n\tret = iwl_pcie_gen2_nic_init(trans);\n\tif (ret) {\n\t\tIWL_ERR(trans, \"Unable to init nic\\n\");\n\t\tgoto out;\n\t}\n\n\tif (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_AX210)\n\t\tret = iwl_pcie_ctxt_info_gen3_init(trans, fw);\n\telse\n\t\tret = iwl_pcie_ctxt_info_init(trans, fw);\n\tif (ret)\n\t\tgoto out;\n\n\tkeep_ram_busy = !iwl_pcie_set_ltr(trans);\n\n\tif (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_BZ) {\n\t\tiwl_write32(trans, CSR_FUNC_SCRATCH, CSR_FUNC_SCRATCH_INIT_VALUE);\n\t\tiwl_set_bit(trans, CSR_GP_CNTRL,\n\t\t\t    CSR_GP_CNTRL_REG_FLAG_ROM_START);\n\t} else if (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_AX210) {\n\t\tiwl_write_umac_prph(trans, UREG_CPU_INIT_RUN, 1);\n\t} else {\n\t\tiwl_write_prph(trans, UREG_CPU_INIT_RUN, 1);\n\t}\n\n\tif (keep_ram_busy)\n\t\tiwl_pcie_spin_for_iml(trans);\n\n\t \n\thw_rfkill = iwl_pcie_check_hw_rf_kill(trans);\n\tif (hw_rfkill && !run_in_rfkill)\n\t\tret = -ERFKILL;\n\nout:\n\tmutex_unlock(&trans_pcie->mutex);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}