{
  "module_name": "4965-calib.c",
  "hash_id": "1b6d6c89cfc3fc5f631c1d9793b7fa9e496a0a84ba74f55cb45ac942bf846634",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlegacy/4965-calib.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n#include <net/mac80211.h>\n\n#include \"common.h\"\n#include \"4965.h\"\n\n \n\nstruct stats_general_data {\n\tu32 beacon_silence_rssi_a;\n\tu32 beacon_silence_rssi_b;\n\tu32 beacon_silence_rssi_c;\n\tu32 beacon_energy_a;\n\tu32 beacon_energy_b;\n\tu32 beacon_energy_c;\n};\n\n \n\n \nstatic int\nil4965_sens_energy_cck(struct il_priv *il, u32 norm_fa, u32 rx_enable_time,\n\t\t       struct stats_general_data *rx_info)\n{\n\tu32 max_nrg_cck = 0;\n\tint i = 0;\n\tu8 max_silence_rssi = 0;\n\tu32 silence_ref = 0;\n\tu8 silence_rssi_a = 0;\n\tu8 silence_rssi_b = 0;\n\tu8 silence_rssi_c = 0;\n\tu32 val;\n\n\t \n\tu32 false_alarms = norm_fa * 200 * 1024;\n\tu32 max_false_alarms = MAX_FA_CCK * rx_enable_time;\n\tu32 min_false_alarms = MIN_FA_CCK * rx_enable_time;\n\tstruct il_sensitivity_data *data = NULL;\n\tconst struct il_sensitivity_ranges *ranges = il->hw_params.sens;\n\n\tdata = &(il->sensitivity_data);\n\n\tdata->nrg_auto_corr_silence_diff = 0;\n\n\t \n\tsilence_rssi_a =\n\t    (u8) ((rx_info->beacon_silence_rssi_a & ALL_BAND_FILTER) >> 8);\n\tsilence_rssi_b =\n\t    (u8) ((rx_info->beacon_silence_rssi_b & ALL_BAND_FILTER) >> 8);\n\tsilence_rssi_c =\n\t    (u8) ((rx_info->beacon_silence_rssi_c & ALL_BAND_FILTER) >> 8);\n\n\tval = max(silence_rssi_b, silence_rssi_c);\n\tmax_silence_rssi = max(silence_rssi_a, (u8) val);\n\n\t \n\tdata->nrg_silence_rssi[data->nrg_silence_idx] = max_silence_rssi;\n\tdata->nrg_silence_idx++;\n\tif (data->nrg_silence_idx >= NRG_NUM_PREV_STAT_L)\n\t\tdata->nrg_silence_idx = 0;\n\n\t \n\tfor (i = 0; i < NRG_NUM_PREV_STAT_L; i++) {\n\t\tval = data->nrg_silence_rssi[i];\n\t\tsilence_ref = max(silence_ref, val);\n\t}\n\tD_CALIB(\"silence a %u, b %u, c %u, 20-bcn max %u\\n\", silence_rssi_a,\n\t\tsilence_rssi_b, silence_rssi_c, silence_ref);\n\n\t \n\ti = data->nrg_energy_idx;\n\tval = min(rx_info->beacon_energy_b, rx_info->beacon_energy_c);\n\tdata->nrg_value[i] = min(rx_info->beacon_energy_a, val);\n\n\tdata->nrg_energy_idx++;\n\tif (data->nrg_energy_idx >= 10)\n\t\tdata->nrg_energy_idx = 0;\n\n\t \n\tmax_nrg_cck = data->nrg_value[0];\n\tfor (i = 1; i < 10; i++)\n\t\tmax_nrg_cck = (u32) max(max_nrg_cck, (data->nrg_value[i]));\n\tmax_nrg_cck += 6;\n\n\tD_CALIB(\"rx energy a %u, b %u, c %u, 10-bcn max/min %u\\n\",\n\t\trx_info->beacon_energy_a, rx_info->beacon_energy_b,\n\t\trx_info->beacon_energy_c, max_nrg_cck - 6);\n\n\t \n\tif (false_alarms < min_false_alarms)\n\t\tdata->num_in_cck_no_fa++;\n\telse\n\t\tdata->num_in_cck_no_fa = 0;\n\tD_CALIB(\"consecutive bcns with few false alarms = %u\\n\",\n\t\tdata->num_in_cck_no_fa);\n\n\t \n\tif (false_alarms > max_false_alarms &&\n\t    data->auto_corr_cck > AUTO_CORR_MAX_TH_CCK) {\n\t\tD_CALIB(\"norm FA %u > max FA %u\\n\", false_alarms,\n\t\t\tmax_false_alarms);\n\t\tD_CALIB(\"... reducing sensitivity\\n\");\n\t\tdata->nrg_curr_state = IL_FA_TOO_MANY;\n\t\t \n\t\tdata->nrg_silence_ref = silence_ref;\n\n\t\t \n\t\tdata->nrg_th_cck = data->nrg_th_cck - NRG_STEP_CCK;\n\t\t \n\t} else if (false_alarms < min_false_alarms) {\n\t\tdata->nrg_curr_state = IL_FA_TOO_FEW;\n\n\t\t \n\t\tdata->nrg_auto_corr_silence_diff =\n\t\t    (s32) data->nrg_silence_ref - (s32) silence_ref;\n\n\t\tD_CALIB(\"norm FA %u < min FA %u, silence diff %d\\n\",\n\t\t\tfalse_alarms, min_false_alarms,\n\t\t\tdata->nrg_auto_corr_silence_diff);\n\n\t\t \n\t\tif (data->nrg_prev_state != IL_FA_TOO_MANY &&\n\t\t    (data->nrg_auto_corr_silence_diff > NRG_DIFF ||\n\t\t     data->num_in_cck_no_fa > MAX_NUMBER_CCK_NO_FA)) {\n\n\t\t\tD_CALIB(\"... increasing sensitivity\\n\");\n\t\t\t \n\t\t\tval = data->nrg_th_cck + NRG_STEP_CCK;\n\t\t\tdata->nrg_th_cck = min((u32) ranges->min_nrg_cck, val);\n\t\t} else {\n\t\t\tD_CALIB(\"... but not changing sensitivity\\n\");\n\t\t}\n\n\t\t \n\t} else {\n\t\tD_CALIB(\" FA in safe zone\\n\");\n\t\tdata->nrg_curr_state = IL_FA_GOOD_RANGE;\n\n\t\t \n\t\tdata->nrg_silence_ref = silence_ref;\n\n\t\t \n\t\tif (IL_FA_TOO_MANY == data->nrg_prev_state) {\n\t\t\tD_CALIB(\"... increasing margin\\n\");\n\t\t\tif (data->nrg_th_cck > (max_nrg_cck + NRG_MARGIN))\n\t\t\t\tdata->nrg_th_cck -= NRG_MARGIN;\n\t\t\telse\n\t\t\t\tdata->nrg_th_cck = max_nrg_cck;\n\t\t}\n\t}\n\n\t \n\tdata->nrg_th_cck = max(max_nrg_cck, data->nrg_th_cck);\n\tD_CALIB(\"new nrg_th_cck %u\\n\", data->nrg_th_cck);\n\n\tdata->nrg_prev_state = data->nrg_curr_state;\n\n\t \n\tif (false_alarms > min_false_alarms) {\n\n\t\t \n\t\tif (data->auto_corr_cck < AUTO_CORR_MAX_TH_CCK)\n\t\t\tdata->auto_corr_cck = AUTO_CORR_MAX_TH_CCK + 1;\n\t\telse {\n\t\t\tval = data->auto_corr_cck + AUTO_CORR_STEP_CCK;\n\t\t\tdata->auto_corr_cck =\n\t\t\t    min((u32) ranges->auto_corr_max_cck, val);\n\t\t}\n\t\tval = data->auto_corr_cck_mrc + AUTO_CORR_STEP_CCK;\n\t\tdata->auto_corr_cck_mrc =\n\t\t    min((u32) ranges->auto_corr_max_cck_mrc, val);\n\t} else if (false_alarms < min_false_alarms &&\n\t\t   (data->nrg_auto_corr_silence_diff > NRG_DIFF ||\n\t\t    data->num_in_cck_no_fa > MAX_NUMBER_CCK_NO_FA)) {\n\n\t\t \n\t\tval = data->auto_corr_cck - AUTO_CORR_STEP_CCK;\n\t\tdata->auto_corr_cck = max((u32) ranges->auto_corr_min_cck, val);\n\t\tval = data->auto_corr_cck_mrc - AUTO_CORR_STEP_CCK;\n\t\tdata->auto_corr_cck_mrc =\n\t\t    max((u32) ranges->auto_corr_min_cck_mrc, val);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nil4965_sens_auto_corr_ofdm(struct il_priv *il, u32 norm_fa, u32 rx_enable_time)\n{\n\tu32 val;\n\tu32 false_alarms = norm_fa * 200 * 1024;\n\tu32 max_false_alarms = MAX_FA_OFDM * rx_enable_time;\n\tu32 min_false_alarms = MIN_FA_OFDM * rx_enable_time;\n\tstruct il_sensitivity_data *data = NULL;\n\tconst struct il_sensitivity_ranges *ranges = il->hw_params.sens;\n\n\tdata = &(il->sensitivity_data);\n\n\t \n\tif (false_alarms > max_false_alarms) {\n\n\t\tD_CALIB(\"norm FA %u > max FA %u)\\n\", false_alarms,\n\t\t\tmax_false_alarms);\n\n\t\tval = data->auto_corr_ofdm + AUTO_CORR_STEP_OFDM;\n\t\tdata->auto_corr_ofdm =\n\t\t    min((u32) ranges->auto_corr_max_ofdm, val);\n\n\t\tval = data->auto_corr_ofdm_mrc + AUTO_CORR_STEP_OFDM;\n\t\tdata->auto_corr_ofdm_mrc =\n\t\t    min((u32) ranges->auto_corr_max_ofdm_mrc, val);\n\n\t\tval = data->auto_corr_ofdm_x1 + AUTO_CORR_STEP_OFDM;\n\t\tdata->auto_corr_ofdm_x1 =\n\t\t    min((u32) ranges->auto_corr_max_ofdm_x1, val);\n\n\t\tval = data->auto_corr_ofdm_mrc_x1 + AUTO_CORR_STEP_OFDM;\n\t\tdata->auto_corr_ofdm_mrc_x1 =\n\t\t    min((u32) ranges->auto_corr_max_ofdm_mrc_x1, val);\n\t}\n\n\t \n\telse if (false_alarms < min_false_alarms) {\n\n\t\tD_CALIB(\"norm FA %u < min FA %u\\n\", false_alarms,\n\t\t\tmin_false_alarms);\n\n\t\tval = data->auto_corr_ofdm - AUTO_CORR_STEP_OFDM;\n\t\tdata->auto_corr_ofdm =\n\t\t    max((u32) ranges->auto_corr_min_ofdm, val);\n\n\t\tval = data->auto_corr_ofdm_mrc - AUTO_CORR_STEP_OFDM;\n\t\tdata->auto_corr_ofdm_mrc =\n\t\t    max((u32) ranges->auto_corr_min_ofdm_mrc, val);\n\n\t\tval = data->auto_corr_ofdm_x1 - AUTO_CORR_STEP_OFDM;\n\t\tdata->auto_corr_ofdm_x1 =\n\t\t    max((u32) ranges->auto_corr_min_ofdm_x1, val);\n\n\t\tval = data->auto_corr_ofdm_mrc_x1 - AUTO_CORR_STEP_OFDM;\n\t\tdata->auto_corr_ofdm_mrc_x1 =\n\t\t    max((u32) ranges->auto_corr_min_ofdm_mrc_x1, val);\n\t} else {\n\t\tD_CALIB(\"min FA %u < norm FA %u < max FA %u OK\\n\",\n\t\t\tmin_false_alarms, false_alarms, max_false_alarms);\n\t}\n\treturn 0;\n}\n\nstatic void\nil4965_prepare_legacy_sensitivity_tbl(struct il_priv *il,\n\t\t\t\t      struct il_sensitivity_data *data,\n\t\t\t\t      __le16 *tbl)\n{\n\ttbl[HD_AUTO_CORR32_X4_TH_ADD_MIN_IDX] =\n\t    cpu_to_le16((u16) data->auto_corr_ofdm);\n\ttbl[HD_AUTO_CORR32_X4_TH_ADD_MIN_MRC_IDX] =\n\t    cpu_to_le16((u16) data->auto_corr_ofdm_mrc);\n\ttbl[HD_AUTO_CORR32_X1_TH_ADD_MIN_IDX] =\n\t    cpu_to_le16((u16) data->auto_corr_ofdm_x1);\n\ttbl[HD_AUTO_CORR32_X1_TH_ADD_MIN_MRC_IDX] =\n\t    cpu_to_le16((u16) data->auto_corr_ofdm_mrc_x1);\n\n\ttbl[HD_AUTO_CORR40_X4_TH_ADD_MIN_IDX] =\n\t    cpu_to_le16((u16) data->auto_corr_cck);\n\ttbl[HD_AUTO_CORR40_X4_TH_ADD_MIN_MRC_IDX] =\n\t    cpu_to_le16((u16) data->auto_corr_cck_mrc);\n\n\ttbl[HD_MIN_ENERGY_CCK_DET_IDX] = cpu_to_le16((u16) data->nrg_th_cck);\n\ttbl[HD_MIN_ENERGY_OFDM_DET_IDX] = cpu_to_le16((u16) data->nrg_th_ofdm);\n\n\ttbl[HD_BARKER_CORR_TH_ADD_MIN_IDX] =\n\t    cpu_to_le16(data->barker_corr_th_min);\n\ttbl[HD_BARKER_CORR_TH_ADD_MIN_MRC_IDX] =\n\t    cpu_to_le16(data->barker_corr_th_min_mrc);\n\ttbl[HD_OFDM_ENERGY_TH_IN_IDX] = cpu_to_le16(data->nrg_th_cca);\n\n\tD_CALIB(\"ofdm: ac %u mrc %u x1 %u mrc_x1 %u thresh %u\\n\",\n\t\tdata->auto_corr_ofdm, data->auto_corr_ofdm_mrc,\n\t\tdata->auto_corr_ofdm_x1, data->auto_corr_ofdm_mrc_x1,\n\t\tdata->nrg_th_ofdm);\n\n\tD_CALIB(\"cck: ac %u mrc %u thresh %u\\n\", data->auto_corr_cck,\n\t\tdata->auto_corr_cck_mrc, data->nrg_th_cck);\n}\n\n \nstatic int\nil4965_sensitivity_write(struct il_priv *il)\n{\n\tstruct il_sensitivity_cmd cmd;\n\tstruct il_sensitivity_data *data = NULL;\n\tstruct il_host_cmd cmd_out = {\n\t\t.id = C_SENSITIVITY,\n\t\t.len = sizeof(struct il_sensitivity_cmd),\n\t\t.flags = CMD_ASYNC,\n\t\t.data = &cmd,\n\t};\n\n\tdata = &(il->sensitivity_data);\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\til4965_prepare_legacy_sensitivity_tbl(il, data, &cmd.table[0]);\n\n\t \n\tcmd.control = C_SENSITIVITY_CONTROL_WORK_TBL;\n\n\t \n\tif (!memcmp\n\t    (&cmd.table[0], &(il->sensitivity_tbl[0]),\n\t     sizeof(u16) * HD_TBL_SIZE)) {\n\t\tD_CALIB(\"No change in C_SENSITIVITY\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tmemcpy(&(il->sensitivity_tbl[0]), &(cmd.table[0]),\n\t       sizeof(u16) * HD_TBL_SIZE);\n\n\treturn il_send_cmd(il, &cmd_out);\n}\n\nvoid\nil4965_init_sensitivity(struct il_priv *il)\n{\n\tint ret = 0;\n\tint i;\n\tstruct il_sensitivity_data *data = NULL;\n\tconst struct il_sensitivity_ranges *ranges = il->hw_params.sens;\n\n\tif (il->disable_sens_cal)\n\t\treturn;\n\n\tD_CALIB(\"Start il4965_init_sensitivity\\n\");\n\n\t \n\tdata = &(il->sensitivity_data);\n\n\tif (ranges == NULL)\n\t\treturn;\n\n\tmemset(data, 0, sizeof(struct il_sensitivity_data));\n\n\tdata->num_in_cck_no_fa = 0;\n\tdata->nrg_curr_state = IL_FA_TOO_MANY;\n\tdata->nrg_prev_state = IL_FA_TOO_MANY;\n\tdata->nrg_silence_ref = 0;\n\tdata->nrg_silence_idx = 0;\n\tdata->nrg_energy_idx = 0;\n\n\tfor (i = 0; i < 10; i++)\n\t\tdata->nrg_value[i] = 0;\n\n\tfor (i = 0; i < NRG_NUM_PREV_STAT_L; i++)\n\t\tdata->nrg_silence_rssi[i] = 0;\n\n\tdata->auto_corr_ofdm = ranges->auto_corr_min_ofdm;\n\tdata->auto_corr_ofdm_mrc = ranges->auto_corr_min_ofdm_mrc;\n\tdata->auto_corr_ofdm_x1 = ranges->auto_corr_min_ofdm_x1;\n\tdata->auto_corr_ofdm_mrc_x1 = ranges->auto_corr_min_ofdm_mrc_x1;\n\tdata->auto_corr_cck = AUTO_CORR_CCK_MIN_VAL_DEF;\n\tdata->auto_corr_cck_mrc = ranges->auto_corr_min_cck_mrc;\n\tdata->nrg_th_cck = ranges->nrg_th_cck;\n\tdata->nrg_th_ofdm = ranges->nrg_th_ofdm;\n\tdata->barker_corr_th_min = ranges->barker_corr_th_min;\n\tdata->barker_corr_th_min_mrc = ranges->barker_corr_th_min_mrc;\n\tdata->nrg_th_cca = ranges->nrg_th_cca;\n\n\tdata->last_bad_plcp_cnt_ofdm = 0;\n\tdata->last_fa_cnt_ofdm = 0;\n\tdata->last_bad_plcp_cnt_cck = 0;\n\tdata->last_fa_cnt_cck = 0;\n\n\tret |= il4965_sensitivity_write(il);\n\tD_CALIB(\"<<return 0x%X\\n\", ret);\n}\n\nvoid\nil4965_sensitivity_calibration(struct il_priv *il, void *resp)\n{\n\tu32 rx_enable_time;\n\tu32 fa_cck;\n\tu32 fa_ofdm;\n\tu32 bad_plcp_cck;\n\tu32 bad_plcp_ofdm;\n\tu32 norm_fa_ofdm;\n\tu32 norm_fa_cck;\n\tstruct il_sensitivity_data *data = NULL;\n\tstruct stats_rx_non_phy *rx_info;\n\tstruct stats_rx_phy *ofdm, *cck;\n\tunsigned long flags;\n\tstruct stats_general_data statis;\n\n\tif (il->disable_sens_cal)\n\t\treturn;\n\n\tdata = &(il->sensitivity_data);\n\n\tif (!il_is_any_associated(il)) {\n\t\tD_CALIB(\"<< - not associated\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&il->lock, flags);\n\n\trx_info = &(((struct il_notif_stats *)resp)->rx.general);\n\tofdm = &(((struct il_notif_stats *)resp)->rx.ofdm);\n\tcck = &(((struct il_notif_stats *)resp)->rx.cck);\n\n\tif (rx_info->interference_data_flag != INTERFERENCE_DATA_AVAILABLE) {\n\t\tD_CALIB(\"<< invalid data.\\n\");\n\t\tspin_unlock_irqrestore(&il->lock, flags);\n\t\treturn;\n\t}\n\n\t \n\trx_enable_time = le32_to_cpu(rx_info->channel_load);\n\tfa_cck = le32_to_cpu(cck->false_alarm_cnt);\n\tfa_ofdm = le32_to_cpu(ofdm->false_alarm_cnt);\n\tbad_plcp_cck = le32_to_cpu(cck->plcp_err);\n\tbad_plcp_ofdm = le32_to_cpu(ofdm->plcp_err);\n\n\tstatis.beacon_silence_rssi_a =\n\t    le32_to_cpu(rx_info->beacon_silence_rssi_a);\n\tstatis.beacon_silence_rssi_b =\n\t    le32_to_cpu(rx_info->beacon_silence_rssi_b);\n\tstatis.beacon_silence_rssi_c =\n\t    le32_to_cpu(rx_info->beacon_silence_rssi_c);\n\tstatis.beacon_energy_a = le32_to_cpu(rx_info->beacon_energy_a);\n\tstatis.beacon_energy_b = le32_to_cpu(rx_info->beacon_energy_b);\n\tstatis.beacon_energy_c = le32_to_cpu(rx_info->beacon_energy_c);\n\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\tD_CALIB(\"rx_enable_time = %u usecs\\n\", rx_enable_time);\n\n\tif (!rx_enable_time) {\n\t\tD_CALIB(\"<< RX Enable Time == 0!\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (data->last_bad_plcp_cnt_cck > bad_plcp_cck)\n\t\tdata->last_bad_plcp_cnt_cck = bad_plcp_cck;\n\telse {\n\t\tbad_plcp_cck -= data->last_bad_plcp_cnt_cck;\n\t\tdata->last_bad_plcp_cnt_cck += bad_plcp_cck;\n\t}\n\n\tif (data->last_bad_plcp_cnt_ofdm > bad_plcp_ofdm)\n\t\tdata->last_bad_plcp_cnt_ofdm = bad_plcp_ofdm;\n\telse {\n\t\tbad_plcp_ofdm -= data->last_bad_plcp_cnt_ofdm;\n\t\tdata->last_bad_plcp_cnt_ofdm += bad_plcp_ofdm;\n\t}\n\n\tif (data->last_fa_cnt_ofdm > fa_ofdm)\n\t\tdata->last_fa_cnt_ofdm = fa_ofdm;\n\telse {\n\t\tfa_ofdm -= data->last_fa_cnt_ofdm;\n\t\tdata->last_fa_cnt_ofdm += fa_ofdm;\n\t}\n\n\tif (data->last_fa_cnt_cck > fa_cck)\n\t\tdata->last_fa_cnt_cck = fa_cck;\n\telse {\n\t\tfa_cck -= data->last_fa_cnt_cck;\n\t\tdata->last_fa_cnt_cck += fa_cck;\n\t}\n\n\t \n\tnorm_fa_ofdm = fa_ofdm + bad_plcp_ofdm;\n\tnorm_fa_cck = fa_cck + bad_plcp_cck;\n\n\tD_CALIB(\"cck: fa %u badp %u  ofdm: fa %u badp %u\\n\", fa_cck,\n\t\tbad_plcp_cck, fa_ofdm, bad_plcp_ofdm);\n\n\til4965_sens_auto_corr_ofdm(il, norm_fa_ofdm, rx_enable_time);\n\til4965_sens_energy_cck(il, norm_fa_cck, rx_enable_time, &statis);\n\n\til4965_sensitivity_write(il);\n}\n\nstatic inline u8\nil4965_find_first_chain(u8 mask)\n{\n\tif (mask & ANT_A)\n\t\treturn CHAIN_A;\n\tif (mask & ANT_B)\n\t\treturn CHAIN_B;\n\treturn CHAIN_C;\n}\n\n \nstatic void\nil4965_find_disconn_antenna(struct il_priv *il, u32 * average_sig,\n\t\t\t    struct il_chain_noise_data *data)\n{\n\tu32 active_chains = 0;\n\tu32 max_average_sig;\n\tu16 max_average_sig_antenna_i;\n\tu8 num_tx_chains;\n\tu8 first_chain;\n\tu16 i = 0;\n\n\taverage_sig[0] =\n\t    data->chain_signal_a /\n\t    il->cfg->chain_noise_num_beacons;\n\taverage_sig[1] =\n\t    data->chain_signal_b /\n\t    il->cfg->chain_noise_num_beacons;\n\taverage_sig[2] =\n\t    data->chain_signal_c /\n\t    il->cfg->chain_noise_num_beacons;\n\n\tif (average_sig[0] >= average_sig[1]) {\n\t\tmax_average_sig = average_sig[0];\n\t\tmax_average_sig_antenna_i = 0;\n\t\tactive_chains = (1 << max_average_sig_antenna_i);\n\t} else {\n\t\tmax_average_sig = average_sig[1];\n\t\tmax_average_sig_antenna_i = 1;\n\t\tactive_chains = (1 << max_average_sig_antenna_i);\n\t}\n\n\tif (average_sig[2] >= max_average_sig) {\n\t\tmax_average_sig = average_sig[2];\n\t\tmax_average_sig_antenna_i = 2;\n\t\tactive_chains = (1 << max_average_sig_antenna_i);\n\t}\n\n\tD_CALIB(\"average_sig: a %d b %d c %d\\n\", average_sig[0], average_sig[1],\n\t\taverage_sig[2]);\n\tD_CALIB(\"max_average_sig = %d, antenna %d\\n\", max_average_sig,\n\t\tmax_average_sig_antenna_i);\n\n\t \n\tfor (i = 0; i < NUM_RX_CHAINS; i++) {\n\t\tif (i != max_average_sig_antenna_i) {\n\t\t\ts32 rssi_delta = (max_average_sig - average_sig[i]);\n\n\t\t\t \n\t\t\tif (rssi_delta > MAXIMUM_ALLOWED_PATHLOSS)\n\t\t\t\tdata->disconn_array[i] = 1;\n\t\t\telse\n\t\t\t\tactive_chains |= (1 << i);\n\t\t\tD_CALIB(\"i = %d  rssiDelta = %d  \"\n\t\t\t\t\"disconn_array[i] = %d\\n\", i, rssi_delta,\n\t\t\t\tdata->disconn_array[i]);\n\t\t}\n\t}\n\n\t \n\tactive_chains &= il->hw_params.valid_rx_ant;\n\n\tnum_tx_chains = 0;\n\tfor (i = 0; i < NUM_RX_CHAINS; i++) {\n\t\t \n\t\tu8 ant_msk = (1 << i);\n\t\tif (!(il->hw_params.valid_tx_ant & ant_msk))\n\t\t\tcontinue;\n\n\t\tnum_tx_chains++;\n\t\tif (data->disconn_array[i] == 0)\n\t\t\t \n\t\t\tbreak;\n\t\tif (num_tx_chains == il->hw_params.tx_chains_num &&\n\t\t    data->disconn_array[i]) {\n\t\t\t \n\t\t\tfirst_chain =\n\t\t\t    il4965_find_first_chain(il->cfg->valid_tx_ant);\n\t\t\tdata->disconn_array[first_chain] = 0;\n\t\t\tactive_chains |= BIT(first_chain);\n\t\t\tD_CALIB(\"All Tx chains are disconnected\"\n\t\t\t\t\"- declare %d as connected\\n\", first_chain);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (active_chains != il->hw_params.valid_rx_ant &&\n\t    active_chains != il->chain_noise_data.active_chains)\n\t\tD_CALIB(\"Detected that not all antennas are connected! \"\n\t\t\t\"Connected: %#x, valid: %#x.\\n\", active_chains,\n\t\t\til->hw_params.valid_rx_ant);\n\n\t \n\tdata->active_chains = active_chains;\n\tD_CALIB(\"active_chains (bitwise) = 0x%x\\n\", active_chains);\n}\n\nstatic void\nil4965_gain_computation(struct il_priv *il, u32 * average_noise,\n\t\t\tu16 min_average_noise_antenna_i, u32 min_average_noise,\n\t\t\tu8 default_chain)\n{\n\tint i, ret;\n\tstruct il_chain_noise_data *data = &il->chain_noise_data;\n\n\tdata->delta_gain_code[min_average_noise_antenna_i] = 0;\n\n\tfor (i = default_chain; i < NUM_RX_CHAINS; i++) {\n\t\ts32 delta_g = 0;\n\n\t\tif (!data->disconn_array[i] &&\n\t\t    data->delta_gain_code[i] ==\n\t\t    CHAIN_NOISE_DELTA_GAIN_INIT_VAL) {\n\t\t\tdelta_g = average_noise[i] - min_average_noise;\n\t\t\tdata->delta_gain_code[i] = (u8) ((delta_g * 10) / 15);\n\t\t\tdata->delta_gain_code[i] =\n\t\t\t    min(data->delta_gain_code[i],\n\t\t\t\t(u8) CHAIN_NOISE_MAX_DELTA_GAIN_CODE);\n\n\t\t\tdata->delta_gain_code[i] =\n\t\t\t    (data->delta_gain_code[i] | (1 << 2));\n\t\t} else {\n\t\t\tdata->delta_gain_code[i] = 0;\n\t\t}\n\t}\n\tD_CALIB(\"delta_gain_codes: a %d b %d c %d\\n\", data->delta_gain_code[0],\n\t\tdata->delta_gain_code[1], data->delta_gain_code[2]);\n\n\t \n\tif (!data->radio_write) {\n\t\tstruct il_calib_diff_gain_cmd cmd;\n\t\tdata->radio_write = 1;\n\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tcmd.hdr.op_code = IL_PHY_CALIBRATE_DIFF_GAIN_CMD;\n\t\tcmd.diff_gain_a = data->delta_gain_code[0];\n\t\tcmd.diff_gain_b = data->delta_gain_code[1];\n\t\tcmd.diff_gain_c = data->delta_gain_code[2];\n\t\tret = il_send_cmd_pdu(il, C_PHY_CALIBRATION, sizeof(cmd), &cmd);\n\t\tif (ret)\n\t\t\tD_CALIB(\"fail sending cmd \" \"C_PHY_CALIBRATION\\n\");\n\n\t\t \n\n\t\t \n\t\tdata->state = IL_CHAIN_NOISE_CALIBRATED;\n\t}\n}\n\n \nvoid\nil4965_chain_noise_calibration(struct il_priv *il, void *stat_resp)\n{\n\tstruct il_chain_noise_data *data = NULL;\n\n\tu32 chain_noise_a;\n\tu32 chain_noise_b;\n\tu32 chain_noise_c;\n\tu32 chain_sig_a;\n\tu32 chain_sig_b;\n\tu32 chain_sig_c;\n\tu32 average_sig[NUM_RX_CHAINS] = { INITIALIZATION_VALUE };\n\tu32 average_noise[NUM_RX_CHAINS] = { INITIALIZATION_VALUE };\n\tu32 min_average_noise = MIN_AVERAGE_NOISE_MAX_VALUE;\n\tu16 min_average_noise_antenna_i = INITIALIZATION_VALUE;\n\tu16 i = 0;\n\tu16 rxon_chnum = INITIALIZATION_VALUE;\n\tu16 stat_chnum = INITIALIZATION_VALUE;\n\tu8 rxon_band24;\n\tu8 stat_band24;\n\tunsigned long flags;\n\tstruct stats_rx_non_phy *rx_info;\n\n\tif (il->disable_chain_noise_cal)\n\t\treturn;\n\n\tdata = &(il->chain_noise_data);\n\n\t \n\tif (data->state != IL_CHAIN_NOISE_ACCUMULATE) {\n\t\tif (data->state == IL_CHAIN_NOISE_ALIVE)\n\t\t\tD_CALIB(\"Wait for noise calib reset\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&il->lock, flags);\n\n\trx_info = &(((struct il_notif_stats *)stat_resp)->rx.general);\n\n\tif (rx_info->interference_data_flag != INTERFERENCE_DATA_AVAILABLE) {\n\t\tD_CALIB(\" << Interference data unavailable\\n\");\n\t\tspin_unlock_irqrestore(&il->lock, flags);\n\t\treturn;\n\t}\n\n\trxon_band24 = !!(il->staging.flags & RXON_FLG_BAND_24G_MSK);\n\trxon_chnum = le16_to_cpu(il->staging.channel);\n\n\tstat_band24 =\n\t    !!(((struct il_notif_stats *)stat_resp)->\n\t       flag & STATS_REPLY_FLG_BAND_24G_MSK);\n\tstat_chnum =\n\t    le32_to_cpu(((struct il_notif_stats *)stat_resp)->flag) >> 16;\n\n\t \n\tif (rxon_chnum != stat_chnum || rxon_band24 != stat_band24) {\n\t\tD_CALIB(\"Stats not from chan=%d, band24=%d\\n\", rxon_chnum,\n\t\t\trxon_band24);\n\t\tspin_unlock_irqrestore(&il->lock, flags);\n\t\treturn;\n\t}\n\n\t \n\tchain_noise_a =\n\t    le32_to_cpu(rx_info->beacon_silence_rssi_a) & IN_BAND_FILTER;\n\tchain_noise_b =\n\t    le32_to_cpu(rx_info->beacon_silence_rssi_b) & IN_BAND_FILTER;\n\tchain_noise_c =\n\t    le32_to_cpu(rx_info->beacon_silence_rssi_c) & IN_BAND_FILTER;\n\n\tchain_sig_a = le32_to_cpu(rx_info->beacon_rssi_a) & IN_BAND_FILTER;\n\tchain_sig_b = le32_to_cpu(rx_info->beacon_rssi_b) & IN_BAND_FILTER;\n\tchain_sig_c = le32_to_cpu(rx_info->beacon_rssi_c) & IN_BAND_FILTER;\n\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\tdata->beacon_count++;\n\n\tdata->chain_noise_a = (chain_noise_a + data->chain_noise_a);\n\tdata->chain_noise_b = (chain_noise_b + data->chain_noise_b);\n\tdata->chain_noise_c = (chain_noise_c + data->chain_noise_c);\n\n\tdata->chain_signal_a = (chain_sig_a + data->chain_signal_a);\n\tdata->chain_signal_b = (chain_sig_b + data->chain_signal_b);\n\tdata->chain_signal_c = (chain_sig_c + data->chain_signal_c);\n\n\tD_CALIB(\"chan=%d, band24=%d, beacon=%d\\n\", rxon_chnum, rxon_band24,\n\t\tdata->beacon_count);\n\tD_CALIB(\"chain_sig: a %d b %d c %d\\n\", chain_sig_a, chain_sig_b,\n\t\tchain_sig_c);\n\tD_CALIB(\"chain_noise: a %d b %d c %d\\n\", chain_noise_a, chain_noise_b,\n\t\tchain_noise_c);\n\n\t \n\tif (data->beacon_count != il->cfg->chain_noise_num_beacons)\n\t\treturn;\n\n\t \n\til4965_find_disconn_antenna(il, average_sig, data);\n\n\t \n\taverage_noise[0] =\n\t    data->chain_noise_a / il->cfg->chain_noise_num_beacons;\n\taverage_noise[1] =\n\t    data->chain_noise_b / il->cfg->chain_noise_num_beacons;\n\taverage_noise[2] =\n\t    data->chain_noise_c / il->cfg->chain_noise_num_beacons;\n\n\tfor (i = 0; i < NUM_RX_CHAINS; i++) {\n\t\tif (!data->disconn_array[i] &&\n\t\t    average_noise[i] <= min_average_noise) {\n\t\t\t \n\t\t\tmin_average_noise = average_noise[i];\n\t\t\tmin_average_noise_antenna_i = i;\n\t\t}\n\t}\n\n\tD_CALIB(\"average_noise: a %d b %d c %d\\n\", average_noise[0],\n\t\taverage_noise[1], average_noise[2]);\n\n\tD_CALIB(\"min_average_noise = %d, antenna %d\\n\", min_average_noise,\n\t\tmin_average_noise_antenna_i);\n\n\til4965_gain_computation(il, average_noise, min_average_noise_antenna_i,\n\t\t\t\tmin_average_noise,\n\t\t\t\til4965_find_first_chain(il->cfg->valid_rx_ant));\n\n\t \n\tif (il->ops->update_chain_flags)\n\t\til->ops->update_chain_flags(il);\n\n\tdata->state = IL_CHAIN_NOISE_DONE;\n\til_power_update_mode(il, false);\n}\n\nvoid\nil4965_reset_run_time_calib(struct il_priv *il)\n{\n\tint i;\n\tmemset(&(il->sensitivity_data), 0, sizeof(struct il_sensitivity_data));\n\tmemset(&(il->chain_noise_data), 0, sizeof(struct il_chain_noise_data));\n\tfor (i = 0; i < NUM_RX_CHAINS; i++)\n\t\til->chain_noise_data.delta_gain_code[i] =\n\t\t    CHAIN_NOISE_DELTA_GAIN_INIT_VAL;\n\n\t \n\til_send_stats_request(il, CMD_ASYNC, true);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}