{
  "module_name": "4965.c",
  "hash_id": "6f9569cfe00d48d6fc15ef7a81881832e7297a7958f8696d1dbe76d6254e019d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlegacy/4965.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/units.h>\n#include <net/mac80211.h>\n#include <linux/etherdevice.h>\n#include <asm/unaligned.h>\n\n#include \"common.h\"\n#include \"4965.h\"\n\n \nstatic int\nil4965_verify_inst_sparse(struct il_priv *il, __le32 * image, u32 len)\n{\n\tu32 val;\n\tint ret = 0;\n\tu32 errcnt = 0;\n\tu32 i;\n\n\tD_INFO(\"ucode inst image size is %u\\n\", len);\n\n\tfor (i = 0; i < len; i += 100, image += 100 / sizeof(u32)) {\n\t\t \n\t\t \n\t\til_wr(il, HBUS_TARG_MEM_RADDR, i + IL4965_RTC_INST_LOWER_BOUND);\n\t\tval = _il_rd(il, HBUS_TARG_MEM_RDAT);\n\t\tif (val != le32_to_cpu(*image)) {\n\t\t\tret = -EIO;\n\t\t\terrcnt++;\n\t\t\tif (errcnt >= 3)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int\nil4965_verify_inst_full(struct il_priv *il, __le32 * image, u32 len)\n{\n\tu32 val;\n\tu32 save_len = len;\n\tint ret = 0;\n\tu32 errcnt;\n\n\tD_INFO(\"ucode inst image size is %u\\n\", len);\n\n\til_wr(il, HBUS_TARG_MEM_RADDR, IL4965_RTC_INST_LOWER_BOUND);\n\n\terrcnt = 0;\n\tfor (; len > 0; len -= sizeof(u32), image++) {\n\t\t \n\t\t \n\t\tval = _il_rd(il, HBUS_TARG_MEM_RDAT);\n\t\tif (val != le32_to_cpu(*image)) {\n\t\t\tIL_ERR(\"uCode INST section is invalid at \"\n\t\t\t       \"offset 0x%x, is 0x%x, s/b 0x%x\\n\",\n\t\t\t       save_len - len, val, le32_to_cpu(*image));\n\t\t\tret = -EIO;\n\t\t\terrcnt++;\n\t\t\tif (errcnt >= 20)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!errcnt)\n\t\tD_INFO(\"ucode image in INSTRUCTION memory is good\\n\");\n\n\treturn ret;\n}\n\n \nint\nil4965_verify_ucode(struct il_priv *il)\n{\n\t__le32 *image;\n\tu32 len;\n\tint ret;\n\n\t \n\timage = (__le32 *) il->ucode_boot.v_addr;\n\tlen = il->ucode_boot.len;\n\tret = il4965_verify_inst_sparse(il, image, len);\n\tif (!ret) {\n\t\tD_INFO(\"Bootstrap uCode is good in inst SRAM\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\timage = (__le32 *) il->ucode_init.v_addr;\n\tlen = il->ucode_init.len;\n\tret = il4965_verify_inst_sparse(il, image, len);\n\tif (!ret) {\n\t\tD_INFO(\"Initialize uCode is good in inst SRAM\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\timage = (__le32 *) il->ucode_code.v_addr;\n\tlen = il->ucode_code.len;\n\tret = il4965_verify_inst_sparse(il, image, len);\n\tif (!ret) {\n\t\tD_INFO(\"Runtime uCode is good in inst SRAM\\n\");\n\t\treturn 0;\n\t}\n\n\tIL_ERR(\"NO VALID UCODE IMAGE IN INSTRUCTION SRAM!!\\n\");\n\n\t \n\timage = (__le32 *) il->ucode_boot.v_addr;\n\tlen = il->ucode_boot.len;\n\tret = il4965_verify_inst_full(il, image, len);\n\n\treturn ret;\n}\n\n \n\n \nint\nil4965_eeprom_acquire_semaphore(struct il_priv *il)\n{\n\tu16 count;\n\tint ret;\n\n\tfor (count = 0; count < EEPROM_SEM_RETRY_LIMIT; count++) {\n\t\t \n\t\til_set_bit(il, CSR_HW_IF_CONFIG_REG,\n\t\t\t   CSR_HW_IF_CONFIG_REG_BIT_EEPROM_OWN_SEM);\n\n\t\t \n\t\tret =\n\t\t    _il_poll_bit(il, CSR_HW_IF_CONFIG_REG,\n\t\t\t\t CSR_HW_IF_CONFIG_REG_BIT_EEPROM_OWN_SEM,\n\t\t\t\t CSR_HW_IF_CONFIG_REG_BIT_EEPROM_OWN_SEM,\n\t\t\t\t EEPROM_SEM_TIMEOUT);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nvoid\nil4965_eeprom_release_semaphore(struct il_priv *il)\n{\n\til_clear_bit(il, CSR_HW_IF_CONFIG_REG,\n\t\t     CSR_HW_IF_CONFIG_REG_BIT_EEPROM_OWN_SEM);\n\n}\n\nint\nil4965_eeprom_check_version(struct il_priv *il)\n{\n\tu16 eeprom_ver;\n\tu16 calib_ver;\n\n\teeprom_ver = il_eeprom_query16(il, EEPROM_VERSION);\n\tcalib_ver = il_eeprom_query16(il, EEPROM_4965_CALIB_VERSION_OFFSET);\n\n\tif (eeprom_ver < il->cfg->eeprom_ver ||\n\t    calib_ver < il->cfg->eeprom_calib_ver)\n\t\tgoto err;\n\n\tIL_INFO(\"device EEPROM VER=0x%x, CALIB=0x%x\\n\", eeprom_ver, calib_ver);\n\n\treturn 0;\nerr:\n\tIL_ERR(\"Unsupported (too old) EEPROM VER=0x%x < 0x%x \"\n\t       \"CALIB=0x%x < 0x%x\\n\", eeprom_ver, il->cfg->eeprom_ver,\n\t       calib_ver, il->cfg->eeprom_calib_ver);\n\treturn -EINVAL;\n\n}\n\nvoid\nil4965_eeprom_get_mac(const struct il_priv *il, u8 * mac)\n{\n\tconst u8 *addr = il_eeprom_query_addr(il,\n\t\t\t\t\t      EEPROM_MAC_ADDRESS);\n\tmemcpy(mac, addr, ETH_ALEN);\n}\n\n \nstatic int\nil4965_send_led_cmd(struct il_priv *il, struct il_led_cmd *led_cmd)\n{\n\tstruct il_host_cmd cmd = {\n\t\t.id = C_LEDS,\n\t\t.len = sizeof(struct il_led_cmd),\n\t\t.data = led_cmd,\n\t\t.flags = CMD_ASYNC,\n\t\t.callback = NULL,\n\t};\n\tu32 reg;\n\n\treg = _il_rd(il, CSR_LED_REG);\n\tif (reg != (reg & CSR_LED_BSM_CTRL_MSK))\n\t\t_il_wr(il, CSR_LED_REG, reg & CSR_LED_BSM_CTRL_MSK);\n\n\treturn il_send_cmd(il, &cmd);\n}\n\n \nvoid\nil4965_led_enable(struct il_priv *il)\n{\n\t_il_wr(il, CSR_LED_REG, CSR_LED_REG_TRUN_ON);\n}\n\nstatic int il4965_send_tx_power(struct il_priv *il);\nstatic int il4965_hw_get_temperature(struct il_priv *il);\n\n \n#define IL4965_UCODE_API_MAX 2\n\n \n#define IL4965_UCODE_API_MIN 2\n\n#define IL4965_FW_PRE \"iwlwifi-4965-\"\n#define _IL4965_MODULE_FIRMWARE(api) IL4965_FW_PRE #api \".ucode\"\n#define IL4965_MODULE_FIRMWARE(api) _IL4965_MODULE_FIRMWARE(api)\n\n \nstatic int\nil4965_verify_bsm(struct il_priv *il)\n{\n\t__le32 *image = il->ucode_boot.v_addr;\n\tu32 len = il->ucode_boot.len;\n\tu32 reg;\n\tu32 val;\n\n\tD_INFO(\"Begin verify bsm\\n\");\n\n\t \n\tval = il_rd_prph(il, BSM_WR_DWCOUNT_REG);\n\tfor (reg = BSM_SRAM_LOWER_BOUND; reg < BSM_SRAM_LOWER_BOUND + len;\n\t     reg += sizeof(u32), image++) {\n\t\tval = il_rd_prph(il, reg);\n\t\tif (val != le32_to_cpu(*image)) {\n\t\t\tIL_ERR(\"BSM uCode verification failed at \"\n\t\t\t       \"addr 0x%08X+%u (of %u), is 0x%x, s/b 0x%x\\n\",\n\t\t\t       BSM_SRAM_LOWER_BOUND, reg - BSM_SRAM_LOWER_BOUND,\n\t\t\t       len, val, le32_to_cpu(*image));\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tD_INFO(\"BSM bootstrap uCode image OK\\n\");\n\n\treturn 0;\n}\n\n \nstatic int\nil4965_load_bsm(struct il_priv *il)\n{\n\t__le32 *image = il->ucode_boot.v_addr;\n\tu32 len = il->ucode_boot.len;\n\tdma_addr_t pinst;\n\tdma_addr_t pdata;\n\tu32 inst_len;\n\tu32 data_len;\n\tint i;\n\tu32 done;\n\tu32 reg_offset;\n\tint ret;\n\n\tD_INFO(\"Begin load bsm\\n\");\n\n\til->ucode_type = UCODE_RT;\n\n\t \n\tif (len > IL49_MAX_BSM_SIZE)\n\t\treturn -EINVAL;\n\n\t \n\tpinst = il->ucode_init.p_addr >> 4;\n\tpdata = il->ucode_init_data.p_addr >> 4;\n\tinst_len = il->ucode_init.len;\n\tdata_len = il->ucode_init_data.len;\n\n\til_wr_prph(il, BSM_DRAM_INST_PTR_REG, pinst);\n\til_wr_prph(il, BSM_DRAM_DATA_PTR_REG, pdata);\n\til_wr_prph(il, BSM_DRAM_INST_BYTECOUNT_REG, inst_len);\n\til_wr_prph(il, BSM_DRAM_DATA_BYTECOUNT_REG, data_len);\n\n\t \n\tfor (reg_offset = BSM_SRAM_LOWER_BOUND;\n\t     reg_offset < BSM_SRAM_LOWER_BOUND + len;\n\t     reg_offset += sizeof(u32), image++)\n\t\t_il_wr_prph(il, reg_offset, le32_to_cpu(*image));\n\n\tret = il4965_verify_bsm(il);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\til_wr_prph(il, BSM_WR_MEM_SRC_REG, 0x0);\n\til_wr_prph(il, BSM_WR_MEM_DST_REG, IL49_RTC_INST_LOWER_BOUND);\n\til_wr_prph(il, BSM_WR_DWCOUNT_REG, len / sizeof(u32));\n\n\t \n\til_wr_prph(il, BSM_WR_CTRL_REG, BSM_WR_CTRL_REG_BIT_START);\n\n\t \n\tfor (i = 0; i < 100; i++) {\n\t\tdone = il_rd_prph(il, BSM_WR_CTRL_REG);\n\t\tif (!(done & BSM_WR_CTRL_REG_BIT_START))\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\tif (i < 100)\n\t\tD_INFO(\"BSM write complete, poll %d iterations\\n\", i);\n\telse {\n\t\tIL_ERR(\"BSM write did not complete!\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\til_wr_prph(il, BSM_WR_CTRL_REG, BSM_WR_CTRL_REG_BIT_START_EN);\n\n\treturn 0;\n}\n\n \nstatic int\nil4965_set_ucode_ptrs(struct il_priv *il)\n{\n\tdma_addr_t pinst;\n\tdma_addr_t pdata;\n\n\t \n\tpinst = il->ucode_code.p_addr >> 4;\n\tpdata = il->ucode_data_backup.p_addr >> 4;\n\n\t \n\til_wr_prph(il, BSM_DRAM_INST_PTR_REG, pinst);\n\til_wr_prph(il, BSM_DRAM_DATA_PTR_REG, pdata);\n\til_wr_prph(il, BSM_DRAM_DATA_BYTECOUNT_REG, il->ucode_data.len);\n\n\t \n\til_wr_prph(il, BSM_DRAM_INST_BYTECOUNT_REG,\n\t\t   il->ucode_code.len | BSM_DRAM_INST_LOAD);\n\tD_INFO(\"Runtime uCode pointers are set.\\n\");\n\n\treturn 0;\n}\n\n \nstatic void\nil4965_init_alive_start(struct il_priv *il)\n{\n\t \n\tif (il4965_verify_ucode(il)) {\n\t\t \n\t\tD_INFO(\"Bad \\\"initialize\\\" uCode load.\\n\");\n\t\tgoto restart;\n\t}\n\n\t \n\til->temperature = il4965_hw_get_temperature(il);\n\n\t \n\tD_INFO(\"Initialization Alive received.\\n\");\n\tif (il4965_set_ucode_ptrs(il)) {\n\t\t \n\t\tD_INFO(\"Couldn't set up uCode pointers.\\n\");\n\t\tgoto restart;\n\t}\n\treturn;\n\nrestart:\n\tqueue_work(il->workqueue, &il->restart);\n}\n\nstatic bool\niw4965_is_ht40_channel(__le32 rxon_flags)\n{\n\tint chan_mod =\n\t    le32_to_cpu(rxon_flags & RXON_FLG_CHANNEL_MODE_MSK) >>\n\t    RXON_FLG_CHANNEL_MODE_POS;\n\treturn (chan_mod == CHANNEL_MODE_PURE_40 ||\n\t\tchan_mod == CHANNEL_MODE_MIXED);\n}\n\nvoid\nil4965_nic_config(struct il_priv *il)\n{\n\tunsigned long flags;\n\tu16 radio_cfg;\n\n\tspin_lock_irqsave(&il->lock, flags);\n\n\tradio_cfg = il_eeprom_query16(il, EEPROM_RADIO_CONFIG);\n\n\t \n\tif (EEPROM_RF_CFG_TYPE_MSK(radio_cfg) == EEPROM_4965_RF_CFG_TYPE_MAX)\n\t\til_set_bit(il, CSR_HW_IF_CONFIG_REG,\n\t\t\t   EEPROM_RF_CFG_TYPE_MSK(radio_cfg) |\n\t\t\t   EEPROM_RF_CFG_STEP_MSK(radio_cfg) |\n\t\t\t   EEPROM_RF_CFG_DASH_MSK(radio_cfg));\n\n\t \n\til_set_bit(il, CSR_HW_IF_CONFIG_REG,\n\t\t   CSR_HW_IF_CONFIG_REG_BIT_RADIO_SI |\n\t\t   CSR_HW_IF_CONFIG_REG_BIT_MAC_SI);\n\n\til->calib_info =\n\t    (struct il_eeprom_calib_info *)\n\t    il_eeprom_query_addr(il, EEPROM_4965_CALIB_TXPOWER_OFFSET);\n\n\tspin_unlock_irqrestore(&il->lock, flags);\n}\n\n \nstatic void\nil4965_chain_noise_reset(struct il_priv *il)\n{\n\tstruct il_chain_noise_data *data = &(il->chain_noise_data);\n\n\tif (data->state == IL_CHAIN_NOISE_ALIVE && il_is_any_associated(il)) {\n\t\tstruct il_calib_diff_gain_cmd cmd;\n\n\t\t \n\t\tdata->chain_noise_a = 0;\n\t\tdata->chain_noise_b = 0;\n\t\tdata->chain_noise_c = 0;\n\t\tdata->chain_signal_a = 0;\n\t\tdata->chain_signal_b = 0;\n\t\tdata->chain_signal_c = 0;\n\t\tdata->beacon_count = 0;\n\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tcmd.hdr.op_code = IL_PHY_CALIBRATE_DIFF_GAIN_CMD;\n\t\tcmd.diff_gain_a = 0;\n\t\tcmd.diff_gain_b = 0;\n\t\tcmd.diff_gain_c = 0;\n\t\tif (il_send_cmd_pdu(il, C_PHY_CALIBRATION, sizeof(cmd), &cmd))\n\t\t\tIL_ERR(\"Could not send C_PHY_CALIBRATION\\n\");\n\t\tdata->state = IL_CHAIN_NOISE_ACCUMULATE;\n\t\tD_CALIB(\"Run chain_noise_calibrate\\n\");\n\t}\n}\n\nstatic s32\nil4965_math_div_round(s32 num, s32 denom, s32 * res)\n{\n\ts32 sign = 1;\n\n\tif (num < 0) {\n\t\tsign = -sign;\n\t\tnum = -num;\n\t}\n\tif (denom < 0) {\n\t\tsign = -sign;\n\t\tdenom = -denom;\n\t}\n\t*res = ((num * 2 + denom) / (denom * 2)) * sign;\n\n\treturn 1;\n}\n\n \nstatic s32\nil4965_get_voltage_compensation(s32 eeprom_voltage, s32 current_voltage)\n{\n\ts32 comp = 0;\n\n\tif (TX_POWER_IL_ILLEGAL_VOLTAGE == eeprom_voltage ||\n\t    TX_POWER_IL_ILLEGAL_VOLTAGE == current_voltage)\n\t\treturn 0;\n\n\til4965_math_div_round(current_voltage - eeprom_voltage,\n\t\t\t      TX_POWER_IL_VOLTAGE_CODES_PER_03V, &comp);\n\n\tif (current_voltage > eeprom_voltage)\n\t\tcomp *= 2;\n\tif ((comp < -2) || (comp > 2))\n\t\tcomp = 0;\n\n\treturn comp;\n}\n\nstatic s32\nil4965_get_tx_atten_grp(u16 channel)\n{\n\tif (channel >= CALIB_IL_TX_ATTEN_GR5_FCH &&\n\t    channel <= CALIB_IL_TX_ATTEN_GR5_LCH)\n\t\treturn CALIB_CH_GROUP_5;\n\n\tif (channel >= CALIB_IL_TX_ATTEN_GR1_FCH &&\n\t    channel <= CALIB_IL_TX_ATTEN_GR1_LCH)\n\t\treturn CALIB_CH_GROUP_1;\n\n\tif (channel >= CALIB_IL_TX_ATTEN_GR2_FCH &&\n\t    channel <= CALIB_IL_TX_ATTEN_GR2_LCH)\n\t\treturn CALIB_CH_GROUP_2;\n\n\tif (channel >= CALIB_IL_TX_ATTEN_GR3_FCH &&\n\t    channel <= CALIB_IL_TX_ATTEN_GR3_LCH)\n\t\treturn CALIB_CH_GROUP_3;\n\n\tif (channel >= CALIB_IL_TX_ATTEN_GR4_FCH &&\n\t    channel <= CALIB_IL_TX_ATTEN_GR4_LCH)\n\t\treturn CALIB_CH_GROUP_4;\n\n\treturn -EINVAL;\n}\n\nstatic u32\nil4965_get_sub_band(const struct il_priv *il, u32 channel)\n{\n\ts32 b = -1;\n\n\tfor (b = 0; b < EEPROM_TX_POWER_BANDS; b++) {\n\t\tif (il->calib_info->band_info[b].ch_from == 0)\n\t\t\tcontinue;\n\n\t\tif (channel >= il->calib_info->band_info[b].ch_from &&\n\t\t    channel <= il->calib_info->band_info[b].ch_to)\n\t\t\tbreak;\n\t}\n\n\treturn b;\n}\n\nstatic s32\nil4965_interpolate_value(s32 x, s32 x1, s32 y1, s32 x2, s32 y2)\n{\n\ts32 val;\n\n\tif (x2 == x1)\n\t\treturn y1;\n\telse {\n\t\til4965_math_div_round((x2 - x) * (y1 - y2), (x2 - x1), &val);\n\t\treturn val + y2;\n\t}\n}\n\n \nstatic int\nil4965_interpolate_chan(struct il_priv *il, u32 channel,\n\t\t\tstruct il_eeprom_calib_ch_info *chan_info)\n{\n\ts32 s = -1;\n\tu32 c;\n\tu32 m;\n\tconst struct il_eeprom_calib_measure *m1;\n\tconst struct il_eeprom_calib_measure *m2;\n\tstruct il_eeprom_calib_measure *omeas;\n\tu32 ch_i1;\n\tu32 ch_i2;\n\n\ts = il4965_get_sub_band(il, channel);\n\tif (s >= EEPROM_TX_POWER_BANDS) {\n\t\tIL_ERR(\"Tx Power can not find channel %d\\n\", channel);\n\t\treturn -1;\n\t}\n\n\tch_i1 = il->calib_info->band_info[s].ch1.ch_num;\n\tch_i2 = il->calib_info->band_info[s].ch2.ch_num;\n\tchan_info->ch_num = (u8) channel;\n\n\tD_TXPOWER(\"channel %d subband %d factory cal ch %d & %d\\n\", channel, s,\n\t\t  ch_i1, ch_i2);\n\n\tfor (c = 0; c < EEPROM_TX_POWER_TX_CHAINS; c++) {\n\t\tfor (m = 0; m < EEPROM_TX_POWER_MEASUREMENTS; m++) {\n\t\t\tm1 = &(il->calib_info->band_info[s].ch1.\n\t\t\t       measurements[c][m]);\n\t\t\tm2 = &(il->calib_info->band_info[s].ch2.\n\t\t\t       measurements[c][m]);\n\t\t\tomeas = &(chan_info->measurements[c][m]);\n\n\t\t\tomeas->actual_pow =\n\t\t\t    (u8) il4965_interpolate_value(channel, ch_i1,\n\t\t\t\t\t\t\t  m1->actual_pow, ch_i2,\n\t\t\t\t\t\t\t  m2->actual_pow);\n\t\t\tomeas->gain_idx =\n\t\t\t    (u8) il4965_interpolate_value(channel, ch_i1,\n\t\t\t\t\t\t\t  m1->gain_idx, ch_i2,\n\t\t\t\t\t\t\t  m2->gain_idx);\n\t\t\tomeas->temperature =\n\t\t\t    (u8) il4965_interpolate_value(channel, ch_i1,\n\t\t\t\t\t\t\t  m1->temperature,\n\t\t\t\t\t\t\t  ch_i2,\n\t\t\t\t\t\t\t  m2->temperature);\n\t\t\tomeas->pa_det =\n\t\t\t    (s8) il4965_interpolate_value(channel, ch_i1,\n\t\t\t\t\t\t\t  m1->pa_det, ch_i2,\n\t\t\t\t\t\t\t  m2->pa_det);\n\n\t\t\tD_TXPOWER(\"chain %d meas %d AP1=%d AP2=%d AP=%d\\n\", c,\n\t\t\t\t  m, m1->actual_pow, m2->actual_pow,\n\t\t\t\t  omeas->actual_pow);\n\t\t\tD_TXPOWER(\"chain %d meas %d NI1=%d NI2=%d NI=%d\\n\", c,\n\t\t\t\t  m, m1->gain_idx, m2->gain_idx,\n\t\t\t\t  omeas->gain_idx);\n\t\t\tD_TXPOWER(\"chain %d meas %d PA1=%d PA2=%d PA=%d\\n\", c,\n\t\t\t\t  m, m1->pa_det, m2->pa_det, omeas->pa_det);\n\t\t\tD_TXPOWER(\"chain %d meas %d  T1=%d  T2=%d  T=%d\\n\", c,\n\t\t\t\t  m, m1->temperature, m2->temperature,\n\t\t\t\t  omeas->temperature);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic s32 back_off_table[] = {\n\t10, 10, 10, 10, 10, 15, 17, 20,\t \n\t10, 10, 10, 10, 10, 15, 17, 20,\t \n\t10, 10, 10, 10, 10, 15, 17, 20,\t \n\t10, 10, 10, 10, 10, 15, 17, 20,\t \n\t10\t\t\t \n};\n\n \nstatic struct il4965_txpower_comp_entry {\n\ts32 degrees_per_05db_a;\n\ts32 degrees_per_05db_a_denom;\n} tx_power_cmp_tble[CALIB_CH_GROUP_MAX] = {\n\t{\n\t9, 2},\t\t\t \n\t{\n\t4, 1},\t\t\t \n\t{\n\t4, 1},\t\t\t \n\t{\n\t4, 1},\t\t\t \n\t{\n\t3, 1}\t\t\t \n};\n\nstatic s32\nget_min_power_idx(s32 rate_power_idx, u32 band)\n{\n\tif (!band) {\n\t\tif ((rate_power_idx & 7) <= 4)\n\t\t\treturn MIN_TX_GAIN_IDX_52GHZ_EXT;\n\t}\n\treturn MIN_TX_GAIN_IDX;\n}\n\nstruct gain_entry {\n\tu8 dsp;\n\tu8 radio;\n};\n\nstatic const struct gain_entry gain_table[2][108] = {\n\t \n\t{\n\t {123, 0x3F},\t\t \n\t {117, 0x3F},\n\t {110, 0x3F},\n\t {104, 0x3F},\n\t {98, 0x3F},\n\t {110, 0x3E},\n\t {104, 0x3E},\n\t {98, 0x3E},\n\t {110, 0x3D},\n\t {104, 0x3D},\n\t {98, 0x3D},\n\t {110, 0x3C},\n\t {104, 0x3C},\n\t {98, 0x3C},\n\t {110, 0x3B},\n\t {104, 0x3B},\n\t {98, 0x3B},\n\t {110, 0x3A},\n\t {104, 0x3A},\n\t {98, 0x3A},\n\t {110, 0x39},\n\t {104, 0x39},\n\t {98, 0x39},\n\t {110, 0x38},\n\t {104, 0x38},\n\t {98, 0x38},\n\t {110, 0x37},\n\t {104, 0x37},\n\t {98, 0x37},\n\t {110, 0x36},\n\t {104, 0x36},\n\t {98, 0x36},\n\t {110, 0x35},\n\t {104, 0x35},\n\t {98, 0x35},\n\t {110, 0x34},\n\t {104, 0x34},\n\t {98, 0x34},\n\t {110, 0x33},\n\t {104, 0x33},\n\t {98, 0x33},\n\t {110, 0x32},\n\t {104, 0x32},\n\t {98, 0x32},\n\t {110, 0x31},\n\t {104, 0x31},\n\t {98, 0x31},\n\t {110, 0x30},\n\t {104, 0x30},\n\t {98, 0x30},\n\t {110, 0x25},\n\t {104, 0x25},\n\t {98, 0x25},\n\t {110, 0x24},\n\t {104, 0x24},\n\t {98, 0x24},\n\t {110, 0x23},\n\t {104, 0x23},\n\t {98, 0x23},\n\t {110, 0x22},\n\t {104, 0x18},\n\t {98, 0x18},\n\t {110, 0x17},\n\t {104, 0x17},\n\t {98, 0x17},\n\t {110, 0x16},\n\t {104, 0x16},\n\t {98, 0x16},\n\t {110, 0x15},\n\t {104, 0x15},\n\t {98, 0x15},\n\t {110, 0x14},\n\t {104, 0x14},\n\t {98, 0x14},\n\t {110, 0x13},\n\t {104, 0x13},\n\t {98, 0x13},\n\t {110, 0x12},\n\t {104, 0x08},\n\t {98, 0x08},\n\t {110, 0x07},\n\t {104, 0x07},\n\t {98, 0x07},\n\t {110, 0x06},\n\t {104, 0x06},\n\t {98, 0x06},\n\t {110, 0x05},\n\t {104, 0x05},\n\t {98, 0x05},\n\t {110, 0x04},\n\t {104, 0x04},\n\t {98, 0x04},\n\t {110, 0x03},\n\t {104, 0x03},\n\t {98, 0x03},\n\t {110, 0x02},\n\t {104, 0x02},\n\t {98, 0x02},\n\t {110, 0x01},\n\t {104, 0x01},\n\t {98, 0x01},\n\t {110, 0x00},\n\t {104, 0x00},\n\t {98, 0x00},\n\t {93, 0x00},\n\t {88, 0x00},\n\t {83, 0x00},\n\t {78, 0x00},\n\t },\n\t \n\t{\n\t {110, 0x3f},\t\t \n\t {104, 0x3f},\n\t {98, 0x3f},\n\t {110, 0x3e},\n\t {104, 0x3e},\n\t {98, 0x3e},\n\t {110, 0x3d},\n\t {104, 0x3d},\n\t {98, 0x3d},\n\t {110, 0x3c},\n\t {104, 0x3c},\n\t {98, 0x3c},\n\t {110, 0x3b},\n\t {104, 0x3b},\n\t {98, 0x3b},\n\t {110, 0x3a},\n\t {104, 0x3a},\n\t {98, 0x3a},\n\t {110, 0x39},\n\t {104, 0x39},\n\t {98, 0x39},\n\t {110, 0x38},\n\t {104, 0x38},\n\t {98, 0x38},\n\t {110, 0x37},\n\t {104, 0x37},\n\t {98, 0x37},\n\t {110, 0x36},\n\t {104, 0x36},\n\t {98, 0x36},\n\t {110, 0x35},\n\t {104, 0x35},\n\t {98, 0x35},\n\t {110, 0x34},\n\t {104, 0x34},\n\t {98, 0x34},\n\t {110, 0x33},\n\t {104, 0x33},\n\t {98, 0x33},\n\t {110, 0x32},\n\t {104, 0x32},\n\t {98, 0x32},\n\t {110, 0x31},\n\t {104, 0x31},\n\t {98, 0x31},\n\t {110, 0x30},\n\t {104, 0x30},\n\t {98, 0x30},\n\t {110, 0x6},\n\t {104, 0x6},\n\t {98, 0x6},\n\t {110, 0x5},\n\t {104, 0x5},\n\t {98, 0x5},\n\t {110, 0x4},\n\t {104, 0x4},\n\t {98, 0x4},\n\t {110, 0x3},\n\t {104, 0x3},\n\t {98, 0x3},\n\t {110, 0x2},\n\t {104, 0x2},\n\t {98, 0x2},\n\t {110, 0x1},\n\t {104, 0x1},\n\t {98, 0x1},\n\t {110, 0x0},\n\t {104, 0x0},\n\t {98, 0x0},\n\t {97, 0},\n\t {96, 0},\n\t {95, 0},\n\t {94, 0},\n\t {93, 0},\n\t {92, 0},\n\t {91, 0},\n\t {90, 0},\n\t {89, 0},\n\t {88, 0},\n\t {87, 0},\n\t {86, 0},\n\t {85, 0},\n\t {84, 0},\n\t {83, 0},\n\t {82, 0},\n\t {81, 0},\n\t {80, 0},\n\t {79, 0},\n\t {78, 0},\n\t {77, 0},\n\t {76, 0},\n\t {75, 0},\n\t {74, 0},\n\t {73, 0},\n\t {72, 0},\n\t {71, 0},\n\t {70, 0},\n\t {69, 0},\n\t {68, 0},\n\t {67, 0},\n\t {66, 0},\n\t {65, 0},\n\t {64, 0},\n\t {63, 0},\n\t {62, 0},\n\t {61, 0},\n\t {60, 0},\n\t {59, 0},\n\t }\n};\n\nstatic int\nil4965_fill_txpower_tbl(struct il_priv *il, u8 band, u16 channel, u8 is_ht40,\n\t\t\tu8 ctrl_chan_high,\n\t\t\tstruct il4965_tx_power_db *tx_power_tbl)\n{\n\tu8 saturation_power;\n\ts32 target_power;\n\ts32 user_target_power;\n\ts32 power_limit;\n\ts32 current_temp;\n\ts32 reg_limit;\n\ts32 current_regulatory;\n\ts32 txatten_grp = CALIB_CH_GROUP_MAX;\n\tint i;\n\tint c;\n\tconst struct il_channel_info *ch_info = NULL;\n\tstruct il_eeprom_calib_ch_info ch_eeprom_info;\n\tconst struct il_eeprom_calib_measure *measurement;\n\ts16 voltage;\n\ts32 init_voltage;\n\ts32 voltage_compensation;\n\ts32 degrees_per_05db_num;\n\ts32 degrees_per_05db_denom;\n\ts32 factory_temp;\n\ts32 temperature_comp[2];\n\ts32 factory_gain_idx[2];\n\ts32 factory_actual_pwr[2];\n\ts32 power_idx;\n\n\t \n\tuser_target_power = 2 * il->tx_power_user_lmt;\n\n\t \n\tD_TXPOWER(\"chan %d band %d is_ht40 %d\\n\", channel, band, is_ht40);\n\n\tch_info = il_get_channel_info(il, il->band, channel);\n\n\tif (!il_is_channel_valid(ch_info))\n\t\treturn -EINVAL;\n\n\t \n\ttxatten_grp = il4965_get_tx_atten_grp(channel);\n\tif (txatten_grp < 0) {\n\t\tIL_ERR(\"Can't find txatten group for channel %d.\\n\", channel);\n\t\treturn txatten_grp;\n\t}\n\n\tD_TXPOWER(\"channel %d belongs to txatten group %d\\n\", channel,\n\t\t  txatten_grp);\n\n\tif (is_ht40) {\n\t\tif (ctrl_chan_high)\n\t\t\tchannel -= 2;\n\t\telse\n\t\t\tchannel += 2;\n\t}\n\n\t \n\tif (band)\n\t\tsaturation_power = il->calib_info->saturation_power24;\n\telse\n\t\tsaturation_power = il->calib_info->saturation_power52;\n\n\tif (saturation_power < IL_TX_POWER_SATURATION_MIN ||\n\t    saturation_power > IL_TX_POWER_SATURATION_MAX) {\n\t\tif (band)\n\t\t\tsaturation_power = IL_TX_POWER_DEFAULT_SATURATION_24;\n\t\telse\n\t\t\tsaturation_power = IL_TX_POWER_DEFAULT_SATURATION_52;\n\t}\n\n\t \n\tif (is_ht40)\n\t\treg_limit = ch_info->ht40_max_power_avg * 2;\n\telse\n\t\treg_limit = ch_info->max_power_avg * 2;\n\n\tif ((reg_limit < IL_TX_POWER_REGULATORY_MIN) ||\n\t    (reg_limit > IL_TX_POWER_REGULATORY_MAX)) {\n\t\tif (band)\n\t\t\treg_limit = IL_TX_POWER_DEFAULT_REGULATORY_24;\n\t\telse\n\t\t\treg_limit = IL_TX_POWER_DEFAULT_REGULATORY_52;\n\t}\n\n\t \n\til4965_interpolate_chan(il, channel, &ch_eeprom_info);\n\n\t \n\tvoltage = le16_to_cpu(il->calib_info->voltage);\n\tinit_voltage = (s32) le32_to_cpu(il->card_alive_init.voltage);\n\tvoltage_compensation =\n\t    il4965_get_voltage_compensation(voltage, init_voltage);\n\n\tD_TXPOWER(\"curr volt %d eeprom volt %d volt comp %d\\n\", init_voltage,\n\t\t  voltage, voltage_compensation);\n\n\t \n\tcurrent_temp = max(il->temperature, IL_TX_POWER_TEMPERATURE_MIN);\n\tcurrent_temp = min(il->temperature, IL_TX_POWER_TEMPERATURE_MAX);\n\tcurrent_temp = kelvin_to_celsius(current_temp);\n\n\t \n\tdegrees_per_05db_num =\n\t    tx_power_cmp_tble[txatten_grp].degrees_per_05db_a;\n\tdegrees_per_05db_denom =\n\t    tx_power_cmp_tble[txatten_grp].degrees_per_05db_a_denom;\n\n\t \n\tfor (c = 0; c < 2; c++) {\n\t\tmeasurement = &ch_eeprom_info.measurements[c][1];\n\n\t\t \n\t\tfactory_temp = measurement->temperature;\n\t\til4965_math_div_round((current_temp -\n\t\t\t\t       factory_temp) * degrees_per_05db_denom,\n\t\t\t\t      degrees_per_05db_num,\n\t\t\t\t      &temperature_comp[c]);\n\n\t\tfactory_gain_idx[c] = measurement->gain_idx;\n\t\tfactory_actual_pwr[c] = measurement->actual_pow;\n\n\t\tD_TXPOWER(\"chain = %d\\n\", c);\n\t\tD_TXPOWER(\"fctry tmp %d, \" \"curr tmp %d, comp %d steps\\n\",\n\t\t\t  factory_temp, current_temp, temperature_comp[c]);\n\n\t\tD_TXPOWER(\"fctry idx %d, fctry pwr %d\\n\", factory_gain_idx[c],\n\t\t\t  factory_actual_pwr[c]);\n\t}\n\n\t \n\tfor (i = 0; i < POWER_TBL_NUM_ENTRIES; i++) {\n\t\tu8 is_mimo_rate;\n\t\tunion il4965_tx_power_dual_stream tx_power;\n\n\t\t \n\t\tif (i & 0x8) {\n\t\t\tcurrent_regulatory =\n\t\t\t    reg_limit -\n\t\t\t    IL_TX_POWER_MIMO_REGULATORY_COMPENSATION;\n\t\t\tis_mimo_rate = 1;\n\t\t} else {\n\t\t\tcurrent_regulatory = reg_limit;\n\t\t\tis_mimo_rate = 0;\n\t\t}\n\n\t\t \n\t\tpower_limit = saturation_power - back_off_table[i];\n\t\tif (power_limit > current_regulatory)\n\t\t\tpower_limit = current_regulatory;\n\n\t\t \n\t\ttarget_power = user_target_power;\n\t\tif (target_power > power_limit)\n\t\t\ttarget_power = power_limit;\n\n\t\tD_TXPOWER(\"rate %d sat %d reg %d usr %d tgt %d\\n\", i,\n\t\t\t  saturation_power - back_off_table[i],\n\t\t\t  current_regulatory, user_target_power, target_power);\n\n\t\t \n\t\tfor (c = 0; c < 2; c++) {\n\t\t\ts32 atten_value;\n\n\t\t\tif (is_mimo_rate)\n\t\t\t\tatten_value =\n\t\t\t\t    (s32) le32_to_cpu(il->card_alive_init.\n\t\t\t\t\t\t      tx_atten[txatten_grp][c]);\n\t\t\telse\n\t\t\t\tatten_value = 0;\n\n\t\t\t \n\t\t\tpower_idx =\n\t\t\t    (u8) (factory_gain_idx[c] -\n\t\t\t\t  (target_power - factory_actual_pwr[c]) -\n\t\t\t\t  temperature_comp[c] - voltage_compensation +\n\t\t\t\t  atten_value);\n\n \n\n\t\t\tif (power_idx < get_min_power_idx(i, band))\n\t\t\t\tpower_idx = get_min_power_idx(i, band);\n\n\t\t\t \n\t\t\tif (!band)\n\t\t\t\tpower_idx += 9;\n\n\t\t\t \n\t\t\tif (i == POWER_TBL_CCK_ENTRY)\n\t\t\t\tpower_idx +=\n\t\t\t\t    IL_TX_POWER_CCK_COMPENSATION_C_STEP;\n\n\t\t\t \n\t\t\tif (power_idx > 107) {\n\t\t\t\tIL_WARN(\"txpower idx %d > 107\\n\", power_idx);\n\t\t\t\tpower_idx = 107;\n\t\t\t}\n\t\t\tif (power_idx < 0) {\n\t\t\t\tIL_WARN(\"txpower idx %d < 0\\n\", power_idx);\n\t\t\t\tpower_idx = 0;\n\t\t\t}\n\n\t\t\t \n\t\t\ttx_power.s.radio_tx_gain[c] =\n\t\t\t    gain_table[band][power_idx].radio;\n\t\t\ttx_power.s.dsp_predis_atten[c] =\n\t\t\t    gain_table[band][power_idx].dsp;\n\n\t\t\tD_TXPOWER(\"chain %d mimo %d idx %d \"\n\t\t\t\t  \"gain 0x%02x dsp %d\\n\", c, atten_value,\n\t\t\t\t  power_idx, tx_power.s.radio_tx_gain[c],\n\t\t\t\t  tx_power.s.dsp_predis_atten[c]);\n\t\t}\t\t \n\n\t\ttx_power_tbl->power_tbl[i].dw = cpu_to_le32(tx_power.dw);\n\n\t}\t\t\t \n\n\treturn 0;\n}\n\n \nstatic int\nil4965_send_tx_power(struct il_priv *il)\n{\n\tstruct il4965_txpowertable_cmd cmd = { 0 };\n\tint ret;\n\tu8 band = 0;\n\tbool is_ht40 = false;\n\tu8 ctrl_chan_high = 0;\n\n\tif (WARN_ONCE\n\t    (test_bit(S_SCAN_HW, &il->status),\n\t     \"TX Power requested while scanning!\\n\"))\n\t\treturn -EAGAIN;\n\n\tband = il->band == NL80211_BAND_2GHZ;\n\n\tis_ht40 = iw4965_is_ht40_channel(il->active.flags);\n\n\tif (is_ht40 && (il->active.flags & RXON_FLG_CTRL_CHANNEL_LOC_HI_MSK))\n\t\tctrl_chan_high = 1;\n\n\tcmd.band = band;\n\tcmd.channel = il->active.channel;\n\n\tret =\n\t    il4965_fill_txpower_tbl(il, band, le16_to_cpu(il->active.channel),\n\t\t\t\t    is_ht40, ctrl_chan_high, &cmd.tx_power);\n\tif (ret)\n\t\tgoto out;\n\n\tret = il_send_cmd_pdu(il, C_TX_PWR_TBL, sizeof(cmd), &cmd);\n\nout:\n\treturn ret;\n}\n\nstatic int\nil4965_send_rxon_assoc(struct il_priv *il)\n{\n\tint ret = 0;\n\tstruct il4965_rxon_assoc_cmd rxon_assoc;\n\tconst struct il_rxon_cmd *rxon1 = &il->staging;\n\tconst struct il_rxon_cmd *rxon2 = &il->active;\n\n\tlockdep_assert_held(&il->mutex);\n\n\tif (rxon1->flags == rxon2->flags &&\n\t    rxon1->filter_flags == rxon2->filter_flags &&\n\t    rxon1->cck_basic_rates == rxon2->cck_basic_rates &&\n\t    rxon1->ofdm_ht_single_stream_basic_rates ==\n\t    rxon2->ofdm_ht_single_stream_basic_rates &&\n\t    rxon1->ofdm_ht_dual_stream_basic_rates ==\n\t    rxon2->ofdm_ht_dual_stream_basic_rates &&\n\t    rxon1->rx_chain == rxon2->rx_chain &&\n\t    rxon1->ofdm_basic_rates == rxon2->ofdm_basic_rates) {\n\t\tD_INFO(\"Using current RXON_ASSOC.  Not resending.\\n\");\n\t\treturn 0;\n\t}\n\n\trxon_assoc.flags = il->staging.flags;\n\trxon_assoc.filter_flags = il->staging.filter_flags;\n\trxon_assoc.ofdm_basic_rates = il->staging.ofdm_basic_rates;\n\trxon_assoc.cck_basic_rates = il->staging.cck_basic_rates;\n\trxon_assoc.reserved = 0;\n\trxon_assoc.ofdm_ht_single_stream_basic_rates =\n\t    il->staging.ofdm_ht_single_stream_basic_rates;\n\trxon_assoc.ofdm_ht_dual_stream_basic_rates =\n\t    il->staging.ofdm_ht_dual_stream_basic_rates;\n\trxon_assoc.rx_chain_select_flags = il->staging.rx_chain;\n\n\tret =\n\t    il_send_cmd_pdu_async(il, C_RXON_ASSOC, sizeof(rxon_assoc),\n\t\t\t\t  &rxon_assoc, NULL);\n\n\treturn ret;\n}\n\nstatic int\nil4965_commit_rxon(struct il_priv *il)\n{\n\t \n\tstruct il_rxon_cmd *active_rxon = (void *)&il->active;\n\tint ret;\n\tbool new_assoc = !!(il->staging.filter_flags & RXON_FILTER_ASSOC_MSK);\n\n\tif (!il_is_alive(il))\n\t\treturn -EBUSY;\n\n\t \n\til->staging.flags |= RXON_FLG_TSF2HOST_MSK;\n\n\tret = il_check_rxon_cmd(il);\n\tif (ret) {\n\t\tIL_ERR(\"Invalid RXON configuration.  Not committing.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (test_bit(S_CHANNEL_SWITCH_PENDING, &il->status) &&\n\t    il->switch_channel != il->staging.channel) {\n\t\tD_11H(\"abort channel switch on %d\\n\",\n\t\t      le16_to_cpu(il->switch_channel));\n\t\til_chswitch_done(il, false);\n\t}\n\n\t \n\tif (!il_full_rxon_required(il)) {\n\t\tret = il_send_rxon_assoc(il);\n\t\tif (ret) {\n\t\t\tIL_ERR(\"Error setting RXON_ASSOC (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmemcpy(active_rxon, &il->staging, sizeof(*active_rxon));\n\t\til_print_rx_config_cmd(il);\n\t\t \n\t\til_set_tx_power(il, il->tx_power_next, false);\n\t\treturn 0;\n\t}\n\n\t \n\tif (il_is_associated(il) && new_assoc) {\n\t\tD_INFO(\"Toggling associated bit on current RXON\\n\");\n\t\tactive_rxon->filter_flags &= ~RXON_FILTER_ASSOC_MSK;\n\n\t\tret =\n\t\t    il_send_cmd_pdu(il, C_RXON,\n\t\t\t\t    sizeof(struct il_rxon_cmd), active_rxon);\n\n\t\t \n\t\tif (ret) {\n\t\t\tactive_rxon->filter_flags |= RXON_FILTER_ASSOC_MSK;\n\t\t\tIL_ERR(\"Error clearing ASSOC_MSK (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\til_clear_ucode_stations(il);\n\t\til_restore_stations(il);\n\t\tret = il4965_restore_default_wep_keys(il);\n\t\tif (ret) {\n\t\t\tIL_ERR(\"Failed to restore WEP keys (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tD_INFO(\"Sending RXON\\n\" \"* with%s RXON_FILTER_ASSOC_MSK\\n\"\n\t       \"* channel = %d\\n\" \"* bssid = %pM\\n\", (new_assoc ? \"\" : \"out\"),\n\t       le16_to_cpu(il->staging.channel), il->staging.bssid_addr);\n\n\til_set_rxon_hwcrypto(il, !il->cfg->mod_params->sw_crypto);\n\n\t \n\tif (!new_assoc) {\n\t\tret =\n\t\t    il_send_cmd_pdu(il, C_RXON,\n\t\t\t\t    sizeof(struct il_rxon_cmd), &il->staging);\n\t\tif (ret) {\n\t\t\tIL_ERR(\"Error setting new RXON (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tD_INFO(\"Return from !new_assoc RXON.\\n\");\n\t\tmemcpy(active_rxon, &il->staging, sizeof(*active_rxon));\n\t\til_clear_ucode_stations(il);\n\t\til_restore_stations(il);\n\t\tret = il4965_restore_default_wep_keys(il);\n\t\tif (ret) {\n\t\t\tIL_ERR(\"Failed to restore WEP keys (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif (new_assoc) {\n\t\til->start_calib = 0;\n\t\t \n\t\tret =\n\t\t    il_send_cmd_pdu(il, C_RXON,\n\t\t\t\t    sizeof(struct il_rxon_cmd), &il->staging);\n\t\tif (ret) {\n\t\t\tIL_ERR(\"Error setting new RXON (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tmemcpy(active_rxon, &il->staging, sizeof(*active_rxon));\n\t}\n\til_print_rx_config_cmd(il);\n\n\til4965_init_sensitivity(il);\n\n\t \n\tret = il_set_tx_power(il, il->tx_power_next, true);\n\tif (ret) {\n\t\tIL_ERR(\"Error sending TX power (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nil4965_hw_channel_switch(struct il_priv *il,\n\t\t\t struct ieee80211_channel_switch *ch_switch)\n{\n\tint rc;\n\tu8 band = 0;\n\tbool is_ht40 = false;\n\tu8 ctrl_chan_high = 0;\n\tstruct il4965_channel_switch_cmd cmd;\n\tconst struct il_channel_info *ch_info;\n\tu32 switch_time_in_usec, ucode_switch_time;\n\tu16 ch;\n\tu32 tsf_low;\n\tu8 switch_count;\n\tu16 beacon_interval = le16_to_cpu(il->timing.beacon_interval);\n\tstruct ieee80211_vif *vif = il->vif;\n\tband = (il->band == NL80211_BAND_2GHZ);\n\n\tif (WARN_ON_ONCE(vif == NULL))\n\t\treturn -EIO;\n\n\tis_ht40 = iw4965_is_ht40_channel(il->staging.flags);\n\n\tif (is_ht40 && (il->staging.flags & RXON_FLG_CTRL_CHANNEL_LOC_HI_MSK))\n\t\tctrl_chan_high = 1;\n\n\tcmd.band = band;\n\tcmd.expect_beacon = 0;\n\tch = ch_switch->chandef.chan->hw_value;\n\tcmd.channel = cpu_to_le16(ch);\n\tcmd.rxon_flags = il->staging.flags;\n\tcmd.rxon_filter_flags = il->staging.filter_flags;\n\tswitch_count = ch_switch->count;\n\ttsf_low = ch_switch->timestamp & 0x0ffffffff;\n\t \n\tif (il->ucode_beacon_time > tsf_low && beacon_interval) {\n\t\tif (switch_count >\n\t\t    ((il->ucode_beacon_time - tsf_low) / beacon_interval)) {\n\t\t\tswitch_count -=\n\t\t\t    (il->ucode_beacon_time - tsf_low) / beacon_interval;\n\t\t} else\n\t\t\tswitch_count = 0;\n\t}\n\tif (switch_count <= 1)\n\t\tcmd.switch_time = cpu_to_le32(il->ucode_beacon_time);\n\telse {\n\t\tswitch_time_in_usec =\n\t\t    vif->bss_conf.beacon_int * switch_count * TIME_UNIT;\n\t\tucode_switch_time =\n\t\t    il_usecs_to_beacons(il, switch_time_in_usec,\n\t\t\t\t\tbeacon_interval);\n\t\tcmd.switch_time =\n\t\t    il_add_beacon_time(il, il->ucode_beacon_time,\n\t\t\t\t       ucode_switch_time, beacon_interval);\n\t}\n\tD_11H(\"uCode time for the switch is 0x%x\\n\", cmd.switch_time);\n\tch_info = il_get_channel_info(il, il->band, ch);\n\tif (ch_info)\n\t\tcmd.expect_beacon = il_is_channel_radar(ch_info);\n\telse {\n\t\tIL_ERR(\"invalid channel switch from %u to %u\\n\",\n\t\t       il->active.channel, ch);\n\t\treturn -EFAULT;\n\t}\n\n\trc = il4965_fill_txpower_tbl(il, band, ch, is_ht40, ctrl_chan_high,\n\t\t\t\t     &cmd.tx_power);\n\tif (rc) {\n\t\tD_11H(\"error:%d  fill txpower_tbl\\n\", rc);\n\t\treturn rc;\n\t}\n\n\treturn il_send_cmd_pdu(il, C_CHANNEL_SWITCH, sizeof(cmd), &cmd);\n}\n\n \nstatic void\nil4965_txq_update_byte_cnt_tbl(struct il_priv *il, struct il_tx_queue *txq,\n\t\t\t       u16 byte_cnt)\n{\n\tstruct il4965_scd_bc_tbl *scd_bc_tbl = il->scd_bc_tbls.addr;\n\tint txq_id = txq->q.id;\n\tint write_ptr = txq->q.write_ptr;\n\tint len = byte_cnt + IL_TX_CRC_SIZE + IL_TX_DELIMITER_SIZE;\n\t__le16 bc_ent;\n\n\tWARN_ON(len > 0xFFF || write_ptr >= TFD_QUEUE_SIZE_MAX);\n\n\tbc_ent = cpu_to_le16(len & 0xFFF);\n\t \n\tscd_bc_tbl[txq_id].tfd_offset[write_ptr] = bc_ent;\n\n\t \n\tif (write_ptr < TFD_QUEUE_SIZE_BC_DUP)\n\t\tscd_bc_tbl[txq_id].tfd_offset[TFD_QUEUE_SIZE_MAX + write_ptr] =\n\t\t    bc_ent;\n}\n\n \nstatic int\nil4965_hw_get_temperature(struct il_priv *il)\n{\n\ts32 temperature;\n\ts32 vt;\n\ts32 R1, R2, R3;\n\tu32 R4;\n\n\tif (test_bit(S_TEMPERATURE, &il->status) &&\n\t    (il->_4965.stats.flag & STATS_REPLY_FLG_HT40_MODE_MSK)) {\n\t\tD_TEMP(\"Running HT40 temperature calibration\\n\");\n\t\tR1 = (s32) le32_to_cpu(il->card_alive_init.therm_r1[1]);\n\t\tR2 = (s32) le32_to_cpu(il->card_alive_init.therm_r2[1]);\n\t\tR3 = (s32) le32_to_cpu(il->card_alive_init.therm_r3[1]);\n\t\tR4 = le32_to_cpu(il->card_alive_init.therm_r4[1]);\n\t} else {\n\t\tD_TEMP(\"Running temperature calibration\\n\");\n\t\tR1 = (s32) le32_to_cpu(il->card_alive_init.therm_r1[0]);\n\t\tR2 = (s32) le32_to_cpu(il->card_alive_init.therm_r2[0]);\n\t\tR3 = (s32) le32_to_cpu(il->card_alive_init.therm_r3[0]);\n\t\tR4 = le32_to_cpu(il->card_alive_init.therm_r4[0]);\n\t}\n\n\t \n\tif (!test_bit(S_TEMPERATURE, &il->status))\n\t\tvt = sign_extend32(R4, 23);\n\telse\n\t\tvt = sign_extend32(le32_to_cpu\n\t\t\t\t   (il->_4965.stats.general.common.temperature),\n\t\t\t\t   23);\n\n\tD_TEMP(\"Calib values R[1-3]: %d %d %d R4: %d\\n\", R1, R2, R3, vt);\n\n\tif (R3 == R1) {\n\t\tIL_ERR(\"Calibration conflict R1 == R3\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\ttemperature = TEMPERATURE_CALIB_A_VAL * (vt - R2);\n\ttemperature /= (R3 - R1);\n\ttemperature =\n\t    (temperature * 97) / 100 + TEMPERATURE_CALIB_KELVIN_OFFSET;\n\n\tD_TEMP(\"Calibrated temperature: %dK, %ldC\\n\", temperature,\n\t       kelvin_to_celsius(temperature));\n\n\treturn temperature;\n}\n\n \n#define IL_TEMPERATURE_THRESHOLD   3\n\n \nstatic int\nil4965_is_temp_calib_needed(struct il_priv *il)\n{\n\tint temp_diff;\n\n\tif (!test_bit(S_STATS, &il->status)) {\n\t\tD_TEMP(\"Temperature not updated -- no stats.\\n\");\n\t\treturn 0;\n\t}\n\n\ttemp_diff = il->temperature - il->last_temperature;\n\n\t \n\tif (temp_diff < 0) {\n\t\tD_POWER(\"Getting cooler, delta %d\\n\", temp_diff);\n\t\ttemp_diff = -temp_diff;\n\t} else if (temp_diff == 0)\n\t\tD_POWER(\"Temperature unchanged\\n\");\n\telse\n\t\tD_POWER(\"Getting warmer, delta %d\\n\", temp_diff);\n\n\tif (temp_diff < IL_TEMPERATURE_THRESHOLD) {\n\t\tD_POWER(\" => thermal txpower calib not needed\\n\");\n\t\treturn 0;\n\t}\n\n\tD_POWER(\" => thermal txpower calib needed\\n\");\n\n\treturn 1;\n}\n\nvoid\nil4965_temperature_calib(struct il_priv *il)\n{\n\ts32 temp;\n\n\ttemp = il4965_hw_get_temperature(il);\n\tif (IL_TX_POWER_TEMPERATURE_OUT_OF_RANGE(temp))\n\t\treturn;\n\n\tif (il->temperature != temp) {\n\t\tif (il->temperature)\n\t\t\tD_TEMP(\"Temperature changed \" \"from %ldC to %ldC\\n\",\n\t\t\t       kelvin_to_celsius(il->temperature),\n\t\t\t       kelvin_to_celsius(temp));\n\t\telse\n\t\t\tD_TEMP(\"Temperature \" \"initialized to %ldC\\n\",\n\t\t\t       kelvin_to_celsius(temp));\n\t}\n\n\til->temperature = temp;\n\tset_bit(S_TEMPERATURE, &il->status);\n\n\tif (!il->disable_tx_power_cal &&\n\t    unlikely(!test_bit(S_SCANNING, &il->status)) &&\n\t    il4965_is_temp_calib_needed(il))\n\t\tqueue_work(il->workqueue, &il->txpower_work);\n}\n\nstatic u16\nil4965_get_hcmd_size(u8 cmd_id, u16 len)\n{\n\tswitch (cmd_id) {\n\tcase C_RXON:\n\t\treturn (u16) sizeof(struct il4965_rxon_cmd);\n\tdefault:\n\t\treturn len;\n\t}\n}\n\nstatic u16\nil4965_build_addsta_hcmd(const struct il_addsta_cmd *cmd, u8 * data)\n{\n\tstruct il4965_addsta_cmd *addsta = (struct il4965_addsta_cmd *)data;\n\taddsta->mode = cmd->mode;\n\tmemcpy(&addsta->sta, &cmd->sta, sizeof(struct sta_id_modify));\n\tmemcpy(&addsta->key, &cmd->key, sizeof(struct il4965_keyinfo));\n\taddsta->station_flags = cmd->station_flags;\n\taddsta->station_flags_msk = cmd->station_flags_msk;\n\taddsta->tid_disable_tx = cmd->tid_disable_tx;\n\taddsta->add_immediate_ba_tid = cmd->add_immediate_ba_tid;\n\taddsta->remove_immediate_ba_tid = cmd->remove_immediate_ba_tid;\n\taddsta->add_immediate_ba_ssn = cmd->add_immediate_ba_ssn;\n\taddsta->sleep_tx_count = cmd->sleep_tx_count;\n\taddsta->reserved1 = cpu_to_le16(0);\n\taddsta->reserved2 = cpu_to_le16(0);\n\n\treturn (u16) sizeof(struct il4965_addsta_cmd);\n}\n\nstatic void\nil4965_post_scan(struct il_priv *il)\n{\n\t \n\tif (memcmp(&il->staging, &il->active, sizeof(il->staging)))\n\t\til_commit_rxon(il);\n}\n\nstatic void\nil4965_post_associate(struct il_priv *il)\n{\n\tstruct ieee80211_vif *vif = il->vif;\n\tint ret = 0;\n\n\tif (!vif || !il->is_open)\n\t\treturn;\n\n\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\treturn;\n\n\til_scan_cancel_timeout(il, 200);\n\n\til->staging.filter_flags &= ~RXON_FILTER_ASSOC_MSK;\n\til_commit_rxon(il);\n\n\tret = il_send_rxon_timing(il);\n\tif (ret)\n\t\tIL_WARN(\"RXON timing - \" \"Attempting to continue.\\n\");\n\n\til->staging.filter_flags |= RXON_FILTER_ASSOC_MSK;\n\n\til_set_rxon_ht(il, &il->current_ht_config);\n\n\tif (il->ops->set_rxon_chain)\n\t\til->ops->set_rxon_chain(il);\n\n\til->staging.assoc_id = cpu_to_le16(vif->cfg.aid);\n\n\tD_ASSOC(\"assoc id %d beacon interval %d\\n\", vif->cfg.aid,\n\t\tvif->bss_conf.beacon_int);\n\n\tif (vif->bss_conf.use_short_preamble)\n\t\til->staging.flags |= RXON_FLG_SHORT_PREAMBLE_MSK;\n\telse\n\t\til->staging.flags &= ~RXON_FLG_SHORT_PREAMBLE_MSK;\n\n\tif (il->staging.flags & RXON_FLG_BAND_24G_MSK) {\n\t\tif (vif->bss_conf.use_short_slot)\n\t\t\til->staging.flags |= RXON_FLG_SHORT_SLOT_MSK;\n\t\telse\n\t\t\til->staging.flags &= ~RXON_FLG_SHORT_SLOT_MSK;\n\t}\n\n\til_commit_rxon(il);\n\n\tD_ASSOC(\"Associated as %d to: %pM\\n\", vif->cfg.aid,\n\t\til->active.bssid_addr);\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\til4965_send_beacon_cmd(il);\n\t\tbreak;\n\tdefault:\n\t\tIL_ERR(\"%s Should not be called in %d mode\\n\", __func__,\n\t\t       vif->type);\n\t\tbreak;\n\t}\n\n\t \n\tif (il->chain_noise_data.state == IL_CHAIN_NOISE_DONE)\n\t\til_power_update_mode(il, false);\n\n\t \n\til4965_chain_noise_reset(il);\n\til->start_calib = 1;\n}\n\nstatic void\nil4965_config_ap(struct il_priv *il)\n{\n\tstruct ieee80211_vif *vif = il->vif;\n\tint ret = 0;\n\n\tlockdep_assert_held(&il->mutex);\n\n\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\treturn;\n\n\t \n\tif (!il_is_associated(il)) {\n\n\t\t \n\t\til->staging.filter_flags &= ~RXON_FILTER_ASSOC_MSK;\n\t\til_commit_rxon(il);\n\n\t\t \n\t\tret = il_send_rxon_timing(il);\n\t\tif (ret)\n\t\t\tIL_WARN(\"RXON timing failed - \"\n\t\t\t\t\"Attempting to continue.\\n\");\n\n\t\t \n\t\til->chain_noise_data.active_chains = il->hw_params.valid_rx_ant;\n\t\til_set_rxon_ht(il, &il->current_ht_config);\n\t\tif (il->ops->set_rxon_chain)\n\t\t\til->ops->set_rxon_chain(il);\n\n\t\til->staging.assoc_id = 0;\n\n\t\tif (vif->bss_conf.use_short_preamble)\n\t\t\til->staging.flags |= RXON_FLG_SHORT_PREAMBLE_MSK;\n\t\telse\n\t\t\til->staging.flags &= ~RXON_FLG_SHORT_PREAMBLE_MSK;\n\n\t\tif (il->staging.flags & RXON_FLG_BAND_24G_MSK) {\n\t\t\tif (vif->bss_conf.use_short_slot)\n\t\t\t\til->staging.flags |= RXON_FLG_SHORT_SLOT_MSK;\n\t\t\telse\n\t\t\t\til->staging.flags &= ~RXON_FLG_SHORT_SLOT_MSK;\n\t\t}\n\t\t \n\t\til4965_send_beacon_cmd(il);\n\t\t \n\t\til->staging.filter_flags |= RXON_FILTER_ASSOC_MSK;\n\t\til_commit_rxon(il);\n\t}\n\til4965_send_beacon_cmd(il);\n}\n\nconst struct il_ops il4965_ops = {\n\t.txq_update_byte_cnt_tbl = il4965_txq_update_byte_cnt_tbl,\n\t.txq_attach_buf_to_tfd = il4965_hw_txq_attach_buf_to_tfd,\n\t.txq_free_tfd = il4965_hw_txq_free_tfd,\n\t.txq_init = il4965_hw_tx_queue_init,\n\t.is_valid_rtc_data_addr = il4965_hw_valid_rtc_data_addr,\n\t.init_alive_start = il4965_init_alive_start,\n\t.load_ucode = il4965_load_bsm,\n\t.dump_nic_error_log = il4965_dump_nic_error_log,\n\t.dump_fh = il4965_dump_fh,\n\t.set_channel_switch = il4965_hw_channel_switch,\n\t.apm_init = il_apm_init,\n\t.send_tx_power = il4965_send_tx_power,\n\t.update_chain_flags = il4965_update_chain_flags,\n\t.eeprom_acquire_semaphore = il4965_eeprom_acquire_semaphore,\n\t.eeprom_release_semaphore = il4965_eeprom_release_semaphore,\n\n\t.rxon_assoc = il4965_send_rxon_assoc,\n\t.commit_rxon = il4965_commit_rxon,\n\t.set_rxon_chain = il4965_set_rxon_chain,\n\n\t.get_hcmd_size = il4965_get_hcmd_size,\n\t.build_addsta_hcmd = il4965_build_addsta_hcmd,\n\t.request_scan = il4965_request_scan,\n\t.post_scan = il4965_post_scan,\n\n\t.post_associate = il4965_post_associate,\n\t.config_ap = il4965_config_ap,\n\t.manage_ibss_station = il4965_manage_ibss_station,\n\t.update_bcast_stations = il4965_update_bcast_stations,\n\n\t.send_led_cmd = il4965_send_led_cmd,\n};\n\nstruct il_cfg il4965_cfg = {\n\t.name = \"Intel(R) Wireless WiFi Link 4965AGN\",\n\t.fw_name_pre = IL4965_FW_PRE,\n\t.ucode_api_max = IL4965_UCODE_API_MAX,\n\t.ucode_api_min = IL4965_UCODE_API_MIN,\n\t.sku = IL_SKU_A | IL_SKU_G | IL_SKU_N,\n\t.valid_tx_ant = ANT_AB,\n\t.valid_rx_ant = ANT_ABC,\n\t.eeprom_ver = EEPROM_4965_EEPROM_VERSION,\n\t.eeprom_calib_ver = EEPROM_4965_TX_POWER_VERSION,\n\t.mod_params = &il4965_mod_params,\n\t.led_mode = IL_LED_BLINK,\n\t \n\t.scan_rx_antennas[NL80211_BAND_5GHZ] = ANT_BC,\n\n\t.eeprom_size = IL4965_EEPROM_IMG_SIZE,\n\t.num_of_queues = IL49_NUM_QUEUES,\n\t.num_of_ampdu_queues = IL49_NUM_AMPDU_QUEUES,\n\t.pll_cfg_val = 0,\n\t.set_l0s = true,\n\t.use_bsm = true,\n\t.led_compensation = 61,\n\t.chain_noise_num_beacons = IL4965_CAL_NUM_BEACONS,\n\t.wd_timeout = IL_DEF_WD_TIMEOUT,\n\t.temperature_kelvin = true,\n\t.ucode_tracing = true,\n\t.sensitivity_calib_by_driver = true,\n\t.chain_noise_calib_by_driver = true,\n\n\t.regulatory_bands = {\n\t\tEEPROM_REGULATORY_BAND_1_CHANNELS,\n\t\tEEPROM_REGULATORY_BAND_2_CHANNELS,\n\t\tEEPROM_REGULATORY_BAND_3_CHANNELS,\n\t\tEEPROM_REGULATORY_BAND_4_CHANNELS,\n\t\tEEPROM_REGULATORY_BAND_5_CHANNELS,\n\t\tEEPROM_4965_REGULATORY_BAND_24_HT40_CHANNELS,\n\t\tEEPROM_4965_REGULATORY_BAND_52_HT40_CHANNELS\n\t},\n\n};\n\n \nMODULE_FIRMWARE(IL4965_MODULE_FIRMWARE(IL4965_UCODE_API_MAX));\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}