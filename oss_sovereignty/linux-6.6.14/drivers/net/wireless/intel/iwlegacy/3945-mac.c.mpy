{
  "module_name": "3945-mac.c",
  "hash_id": "2e72510c07ecbfb3cbcb7a6e20bb229cd7cfd655c26e94e8320fadd7940f182c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlegacy/3945-mac.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/firmware.h>\n#include <linux/etherdevice.h>\n#include <linux/if_arp.h>\n\n#include <net/ieee80211_radiotap.h>\n#include <net/mac80211.h>\n\n#include <asm/div64.h>\n\n#define DRV_NAME\t\"iwl3945\"\n\n#include \"commands.h\"\n#include \"common.h\"\n#include \"3945.h\"\n#include \"iwl-spectrum.h\"\n\n \n\n#define DRV_DESCRIPTION\t\\\n\"Intel(R) PRO/Wireless 3945ABG/BG Network Connection driver for Linux\"\n\n#ifdef CONFIG_IWLEGACY_DEBUG\n#define VD \"d\"\n#else\n#define VD\n#endif\n\n \n#define DRV_VERSION  IWLWIFI_VERSION VD \"s\"\n#define DRV_COPYRIGHT\t\"Copyright(c) 2003-2011 Intel Corporation\"\n#define DRV_AUTHOR     \"<ilw@linux.intel.com>\"\n\nMODULE_DESCRIPTION(DRV_DESCRIPTION);\nMODULE_VERSION(DRV_VERSION);\nMODULE_AUTHOR(DRV_COPYRIGHT \" \" DRV_AUTHOR);\nMODULE_LICENSE(\"GPL\");\n\n  \nstruct il_mod_params il3945_mod_params = {\n\t.sw_crypto = 1,\n\t.restart_fw = 1,\n\t.disable_hw_scan = 1,\n\t \n};\n\n \n__le32\nil3945_get_antenna_flags(const struct il_priv *il)\n{\n\tstruct il3945_eeprom *eeprom = (struct il3945_eeprom *)il->eeprom;\n\n\tswitch (il3945_mod_params.antenna) {\n\tcase IL_ANTENNA_DIVERSITY:\n\t\treturn 0;\n\n\tcase IL_ANTENNA_MAIN:\n\t\tif (eeprom->antenna_switch_type)\n\t\t\treturn RXON_FLG_DIS_DIV_MSK | RXON_FLG_ANT_B_MSK;\n\t\treturn RXON_FLG_DIS_DIV_MSK | RXON_FLG_ANT_A_MSK;\n\n\tcase IL_ANTENNA_AUX:\n\t\tif (eeprom->antenna_switch_type)\n\t\t\treturn RXON_FLG_DIS_DIV_MSK | RXON_FLG_ANT_A_MSK;\n\t\treturn RXON_FLG_DIS_DIV_MSK | RXON_FLG_ANT_B_MSK;\n\t}\n\n\t \n\tIL_ERR(\"Bad antenna selector value (0x%x)\\n\",\n\t       il3945_mod_params.antenna);\n\n\treturn 0;\t\t \n}\n\nstatic int\nil3945_set_ccmp_dynamic_key_info(struct il_priv *il,\n\t\t\t\t struct ieee80211_key_conf *keyconf, u8 sta_id)\n{\n\tunsigned long flags;\n\t__le16 key_flags = 0;\n\tint ret;\n\n\tkey_flags |= (STA_KEY_FLG_CCMP | STA_KEY_FLG_MAP_KEY_MSK);\n\tkey_flags |= cpu_to_le16(keyconf->keyidx << STA_KEY_FLG_KEYID_POS);\n\n\tif (sta_id == il->hw_params.bcast_id)\n\t\tkey_flags |= STA_KEY_MULTICAST_MSK;\n\n\tkeyconf->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\n\tkeyconf->hw_key_idx = keyconf->keyidx;\n\tkey_flags &= ~STA_KEY_FLG_INVALID;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\til->stations[sta_id].keyinfo.cipher = keyconf->cipher;\n\til->stations[sta_id].keyinfo.keylen = keyconf->keylen;\n\tmemcpy(il->stations[sta_id].keyinfo.key, keyconf->key, keyconf->keylen);\n\n\tmemcpy(il->stations[sta_id].sta.key.key, keyconf->key, keyconf->keylen);\n\n\tif ((il->stations[sta_id].sta.key.\n\t     key_flags & STA_KEY_FLG_ENCRYPT_MSK) == STA_KEY_FLG_NO_ENC)\n\t\til->stations[sta_id].sta.key.key_offset =\n\t\t    il_get_free_ucode_key_idx(il);\n\t \n\n\tWARN(il->stations[sta_id].sta.key.key_offset == WEP_INVALID_OFFSET,\n\t     \"no space for a new key\");\n\n\til->stations[sta_id].sta.key.key_flags = key_flags;\n\til->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_KEY_MASK;\n\til->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\n\tD_INFO(\"hwcrypto: modify ucode station key info\\n\");\n\n\tret = il_send_add_sta(il, &il->stations[sta_id].sta, CMD_ASYNC);\n\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\treturn ret;\n}\n\nstatic int\nil3945_set_tkip_dynamic_key_info(struct il_priv *il,\n\t\t\t\t struct ieee80211_key_conf *keyconf, u8 sta_id)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int\nil3945_set_wep_dynamic_key_info(struct il_priv *il,\n\t\t\t\tstruct ieee80211_key_conf *keyconf, u8 sta_id)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int\nil3945_clear_sta_key_info(struct il_priv *il, u8 sta_id)\n{\n\tunsigned long flags;\n\tstruct il_addsta_cmd sta_cmd;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\tmemset(&il->stations[sta_id].keyinfo, 0, sizeof(struct il_hw_key));\n\tmemset(&il->stations[sta_id].sta.key, 0, sizeof(struct il4965_keyinfo));\n\til->stations[sta_id].sta.key.key_flags = STA_KEY_FLG_NO_ENC;\n\til->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_KEY_MASK;\n\til->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\tmemcpy(&sta_cmd, &il->stations[sta_id].sta,\n\t       sizeof(struct il_addsta_cmd));\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\tD_INFO(\"hwcrypto: clear ucode station key info\\n\");\n\treturn il_send_add_sta(il, &sta_cmd, CMD_SYNC);\n}\n\nstatic int\nil3945_set_dynamic_key(struct il_priv *il, struct ieee80211_key_conf *keyconf,\n\t\t       u8 sta_id)\n{\n\tint ret = 0;\n\n\tkeyconf->hw_key_idx = HW_KEY_DYNAMIC;\n\n\tswitch (keyconf->cipher) {\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tret = il3945_set_ccmp_dynamic_key_info(il, keyconf, sta_id);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tret = il3945_set_tkip_dynamic_key_info(il, keyconf, sta_id);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tret = il3945_set_wep_dynamic_key_info(il, keyconf, sta_id);\n\t\tbreak;\n\tdefault:\n\t\tIL_ERR(\"Unknown alg: %s alg=%x\\n\", __func__, keyconf->cipher);\n\t\tret = -EINVAL;\n\t}\n\n\tD_WEP(\"Set dynamic key: alg=%x len=%d idx=%d sta=%d ret=%d\\n\",\n\t      keyconf->cipher, keyconf->keylen, keyconf->keyidx, sta_id, ret);\n\n\treturn ret;\n}\n\nstatic int\nil3945_remove_static_key(struct il_priv *il)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int\nil3945_set_static_key(struct il_priv *il, struct ieee80211_key_conf *key)\n{\n\tif (key->cipher == WLAN_CIPHER_SUITE_WEP40 ||\n\t    key->cipher == WLAN_CIPHER_SUITE_WEP104)\n\t\treturn -EOPNOTSUPP;\n\n\tIL_ERR(\"Static key invalid: cipher %x\\n\", key->cipher);\n\treturn -EINVAL;\n}\n\nstatic void\nil3945_clear_free_frames(struct il_priv *il)\n{\n\tstruct list_head *element;\n\n\tD_INFO(\"%d frames on pre-allocated heap on clear.\\n\", il->frames_count);\n\n\twhile (!list_empty(&il->free_frames)) {\n\t\telement = il->free_frames.next;\n\t\tlist_del(element);\n\t\tkfree(list_entry(element, struct il3945_frame, list));\n\t\til->frames_count--;\n\t}\n\n\tif (il->frames_count) {\n\t\tIL_WARN(\"%d frames still in use.  Did we lose one?\\n\",\n\t\t\til->frames_count);\n\t\til->frames_count = 0;\n\t}\n}\n\nstatic struct il3945_frame *\nil3945_get_free_frame(struct il_priv *il)\n{\n\tstruct il3945_frame *frame;\n\tstruct list_head *element;\n\tif (list_empty(&il->free_frames)) {\n\t\tframe = kzalloc(sizeof(*frame), GFP_KERNEL);\n\t\tif (!frame) {\n\t\t\tIL_ERR(\"Could not allocate frame!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\til->frames_count++;\n\t\treturn frame;\n\t}\n\n\telement = il->free_frames.next;\n\tlist_del(element);\n\treturn list_entry(element, struct il3945_frame, list);\n}\n\nstatic void\nil3945_free_frame(struct il_priv *il, struct il3945_frame *frame)\n{\n\tmemset(frame, 0, sizeof(*frame));\n\tlist_add(&frame->list, &il->free_frames);\n}\n\nunsigned int\nil3945_fill_beacon_frame(struct il_priv *il, struct ieee80211_hdr *hdr,\n\t\t\t int left)\n{\n\n\tif (!il_is_associated(il) || !il->beacon_skb)\n\t\treturn 0;\n\n\tif (il->beacon_skb->len > left)\n\t\treturn 0;\n\n\tmemcpy(hdr, il->beacon_skb->data, il->beacon_skb->len);\n\n\treturn il->beacon_skb->len;\n}\n\nstatic int\nil3945_send_beacon_cmd(struct il_priv *il)\n{\n\tstruct il3945_frame *frame;\n\tunsigned int frame_size;\n\tint rc;\n\tu8 rate;\n\n\tframe = il3945_get_free_frame(il);\n\n\tif (!frame) {\n\t\tIL_ERR(\"Could not obtain free frame buffer for beacon \"\n\t\t       \"command.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trate = il_get_lowest_plcp(il);\n\n\tframe_size = il3945_hw_get_beacon_cmd(il, frame, rate);\n\n\trc = il_send_cmd_pdu(il, C_TX_BEACON, frame_size, &frame->u.cmd[0]);\n\n\til3945_free_frame(il, frame);\n\n\treturn rc;\n}\n\nstatic void\nil3945_unset_hw_params(struct il_priv *il)\n{\n\tif (il->_3945.shared_virt)\n\t\tdma_free_coherent(&il->pci_dev->dev,\n\t\t\t\t  sizeof(struct il3945_shared),\n\t\t\t\t  il->_3945.shared_virt, il->_3945.shared_phys);\n}\n\nstatic void\nil3945_build_tx_cmd_hwcrypto(struct il_priv *il, struct ieee80211_tx_info *info,\n\t\t\t     struct il_device_cmd *cmd,\n\t\t\t     struct sk_buff *skb_frag, int sta_id)\n{\n\tstruct il3945_tx_cmd *tx_cmd = (struct il3945_tx_cmd *)cmd->cmd.payload;\n\tstruct il_hw_key *keyinfo = &il->stations[sta_id].keyinfo;\n\n\ttx_cmd->sec_ctl = 0;\n\n\tswitch (keyinfo->cipher) {\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\ttx_cmd->sec_ctl = TX_CMD_SEC_CCM;\n\t\tmemcpy(tx_cmd->key, keyinfo->key, keyinfo->keylen);\n\t\tD_TX(\"tx_cmd with AES hwcrypto\\n\");\n\t\tbreak;\n\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tbreak;\n\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\ttx_cmd->sec_ctl |= TX_CMD_SEC_KEY128;\n\t\tfallthrough;\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\ttx_cmd->sec_ctl |=\n\t\t    TX_CMD_SEC_WEP | (info->control.hw_key->\n\t\t\t\t      hw_key_idx & TX_CMD_SEC_MSK) <<\n\t\t    TX_CMD_SEC_SHIFT;\n\n\t\tmemcpy(&tx_cmd->key[3], keyinfo->key, keyinfo->keylen);\n\n\t\tD_TX(\"Configuring packet for WEP encryption \" \"with key %d\\n\",\n\t\t     info->control.hw_key->hw_key_idx);\n\t\tbreak;\n\n\tdefault:\n\t\tIL_ERR(\"Unknown encode cipher %x\\n\", keyinfo->cipher);\n\t\tbreak;\n\t}\n}\n\n \nstatic void\nil3945_build_tx_cmd_basic(struct il_priv *il, struct il_device_cmd *cmd,\n\t\t\t  struct ieee80211_tx_info *info,\n\t\t\t  struct ieee80211_hdr *hdr, u8 std_id)\n{\n\tstruct il3945_tx_cmd *tx_cmd = (struct il3945_tx_cmd *)cmd->cmd.payload;\n\t__le32 tx_flags = tx_cmd->tx_flags;\n\t__le16 fc = hdr->frame_control;\n\n\ttx_cmd->stop_time.life_time = TX_CMD_LIFE_TIME_INFINITE;\n\tif (!(info->flags & IEEE80211_TX_CTL_NO_ACK)) {\n\t\ttx_flags |= TX_CMD_FLG_ACK_MSK;\n\t\tif (ieee80211_is_mgmt(fc))\n\t\t\ttx_flags |= TX_CMD_FLG_SEQ_CTL_MSK;\n\t\tif (ieee80211_is_probe_resp(fc) &&\n\t\t    !(le16_to_cpu(hdr->seq_ctrl) & 0xf))\n\t\t\ttx_flags |= TX_CMD_FLG_TSF_MSK;\n\t} else {\n\t\ttx_flags &= (~TX_CMD_FLG_ACK_MSK);\n\t\ttx_flags |= TX_CMD_FLG_SEQ_CTL_MSK;\n\t}\n\n\ttx_cmd->sta_id = std_id;\n\tif (ieee80211_has_morefrags(fc))\n\t\ttx_flags |= TX_CMD_FLG_MORE_FRAG_MSK;\n\n\tif (ieee80211_is_data_qos(fc)) {\n\t\tu8 *qc = ieee80211_get_qos_ctl(hdr);\n\t\ttx_cmd->tid_tspec = qc[0] & 0xf;\n\t\ttx_flags &= ~TX_CMD_FLG_SEQ_CTL_MSK;\n\t} else {\n\t\ttx_flags |= TX_CMD_FLG_SEQ_CTL_MSK;\n\t}\n\n\til_tx_cmd_protection(il, info, fc, &tx_flags);\n\n\ttx_flags &= ~(TX_CMD_FLG_ANT_SEL_MSK);\n\tif (ieee80211_is_mgmt(fc)) {\n\t\tif (ieee80211_is_assoc_req(fc) || ieee80211_is_reassoc_req(fc))\n\t\t\ttx_cmd->timeout.pm_frame_timeout = cpu_to_le16(3);\n\t\telse\n\t\t\ttx_cmd->timeout.pm_frame_timeout = cpu_to_le16(2);\n\t} else {\n\t\ttx_cmd->timeout.pm_frame_timeout = 0;\n\t}\n\n\ttx_cmd->driver_txop = 0;\n\ttx_cmd->tx_flags = tx_flags;\n\ttx_cmd->next_frame_len = 0;\n}\n\n \nstatic int\nil3945_tx_skb(struct il_priv *il,\n\t      struct ieee80211_sta *sta,\n\t      struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct il3945_tx_cmd *tx_cmd;\n\tstruct il_tx_queue *txq = NULL;\n\tstruct il_queue *q = NULL;\n\tstruct il_device_cmd *out_cmd;\n\tstruct il_cmd_meta *out_meta;\n\tdma_addr_t phys_addr;\n\tdma_addr_t txcmd_phys;\n\tint txq_id = skb_get_queue_mapping(skb);\n\tu16 len, idx, hdr_len;\n\tu16 firstlen, secondlen;\n\tu8 sta_id;\n\tu8 tid = 0;\n\t__le16 fc;\n\tu8 wait_write_ptr = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&il->lock, flags);\n\tif (il_is_rfkill(il)) {\n\t\tD_DROP(\"Dropping - RF KILL\\n\");\n\t\tgoto drop_unlock;\n\t}\n\n\tif ((ieee80211_get_tx_rate(il->hw, info)->hw_value & 0xFF) ==\n\t    IL_INVALID_RATE) {\n\t\tIL_ERR(\"ERROR: No TX rate available.\\n\");\n\t\tgoto drop_unlock;\n\t}\n\n\tfc = hdr->frame_control;\n\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tif (ieee80211_is_auth(fc))\n\t\tD_TX(\"Sending AUTH frame\\n\");\n\telse if (ieee80211_is_assoc_req(fc))\n\t\tD_TX(\"Sending ASSOC frame\\n\");\n\telse if (ieee80211_is_reassoc_req(fc))\n\t\tD_TX(\"Sending REASSOC frame\\n\");\n#endif\n\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\thdr_len = ieee80211_hdrlen(fc);\n\n\t \n\tsta_id = il_sta_id_or_broadcast(il, sta);\n\tif (sta_id == IL_INVALID_STATION) {\n\t\tD_DROP(\"Dropping - INVALID STATION: %pM\\n\", hdr->addr1);\n\t\tgoto drop;\n\t}\n\n\tD_RATE(\"station Id %d\\n\", sta_id);\n\n\tif (ieee80211_is_data_qos(fc)) {\n\t\tu8 *qc = ieee80211_get_qos_ctl(hdr);\n\t\ttid = qc[0] & IEEE80211_QOS_CTL_TID_MASK;\n\t\tif (unlikely(tid >= MAX_TID_COUNT))\n\t\t\tgoto drop;\n\t}\n\n\t \n\ttxq = &il->txq[txq_id];\n\tq = &txq->q;\n\n\tif ((il_queue_space(q) < q->high_mark))\n\t\tgoto drop;\n\n\tspin_lock_irqsave(&il->lock, flags);\n\n\tidx = il_get_cmd_idx(q, q->write_ptr, 0);\n\n\ttxq->skbs[q->write_ptr] = skb;\n\n\t \n\tout_cmd = txq->cmd[idx];\n\tout_meta = &txq->meta[idx];\n\ttx_cmd = (struct il3945_tx_cmd *)out_cmd->cmd.payload;\n\tmemset(&out_cmd->hdr, 0, sizeof(out_cmd->hdr));\n\tmemset(tx_cmd, 0, sizeof(*tx_cmd));\n\n\t \n\tout_cmd->hdr.cmd = C_TX;\n\tout_cmd->hdr.sequence =\n\t    cpu_to_le16((u16)\n\t\t\t(QUEUE_TO_SEQ(txq_id) | IDX_TO_SEQ(q->write_ptr)));\n\n\t \n\tmemcpy(tx_cmd->hdr, hdr, hdr_len);\n\n\tif (info->control.hw_key)\n\t\til3945_build_tx_cmd_hwcrypto(il, info, out_cmd, skb, sta_id);\n\n\t \n\til3945_build_tx_cmd_basic(il, out_cmd, info, hdr, sta_id);\n\n\til3945_hw_build_tx_cmd_rate(il, out_cmd, info, hdr, sta_id);\n\n\t \n\ttx_cmd->len = cpu_to_le16((u16) skb->len);\n\n\ttx_cmd->tx_flags &= ~TX_CMD_FLG_ANT_A_MSK;\n\ttx_cmd->tx_flags &= ~TX_CMD_FLG_ANT_B_MSK;\n\n\t \n\tlen =\n\t    sizeof(struct il3945_tx_cmd) + sizeof(struct il_cmd_header) +\n\t    hdr_len;\n\tfirstlen = (len + 3) & ~3;\n\n\t \n\ttxcmd_phys = dma_map_single(&il->pci_dev->dev, &out_cmd->hdr, firstlen,\n\t\t\t\t    DMA_TO_DEVICE);\n\tif (unlikely(dma_mapping_error(&il->pci_dev->dev, txcmd_phys)))\n\t\tgoto drop_unlock;\n\n\t \n\tsecondlen = skb->len - hdr_len;\n\tif (secondlen > 0) {\n\t\tphys_addr = dma_map_single(&il->pci_dev->dev, skb->data + hdr_len,\n\t\t\t\t\t   secondlen, DMA_TO_DEVICE);\n\t\tif (unlikely(dma_mapping_error(&il->pci_dev->dev, phys_addr)))\n\t\t\tgoto drop_unlock;\n\t}\n\n\t \n\til->ops->txq_attach_buf_to_tfd(il, txq, txcmd_phys, firstlen, 1, 0);\n\tdma_unmap_addr_set(out_meta, mapping, txcmd_phys);\n\tdma_unmap_len_set(out_meta, len, firstlen);\n\tif (secondlen > 0)\n\t\til->ops->txq_attach_buf_to_tfd(il, txq, phys_addr, secondlen, 0,\n\t\t\t\t\t       U32_PAD(secondlen));\n\n\tif (!ieee80211_has_morefrags(hdr->frame_control)) {\n\t\ttxq->need_update = 1;\n\t} else {\n\t\twait_write_ptr = 1;\n\t\ttxq->need_update = 0;\n\t}\n\n\til_update_stats(il, true, fc, skb->len);\n\n\tD_TX(\"sequence nr = 0X%x\\n\", le16_to_cpu(out_cmd->hdr.sequence));\n\tD_TX(\"tx_flags = 0X%x\\n\", le32_to_cpu(tx_cmd->tx_flags));\n\til_print_hex_dump(il, IL_DL_TX, tx_cmd, sizeof(*tx_cmd));\n\til_print_hex_dump(il, IL_DL_TX, (u8 *) tx_cmd->hdr,\n\t\t\t  ieee80211_hdrlen(fc));\n\n\t \n\tq->write_ptr = il_queue_inc_wrap(q->write_ptr, q->n_bd);\n\til_txq_update_write_ptr(il, txq);\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\tif (il_queue_space(q) < q->high_mark && il->mac80211_registered) {\n\t\tif (wait_write_ptr) {\n\t\t\tspin_lock_irqsave(&il->lock, flags);\n\t\t\ttxq->need_update = 1;\n\t\t\til_txq_update_write_ptr(il, txq);\n\t\t\tspin_unlock_irqrestore(&il->lock, flags);\n\t\t}\n\n\t\til_stop_queue(il, txq);\n\t}\n\n\treturn 0;\n\ndrop_unlock:\n\tspin_unlock_irqrestore(&il->lock, flags);\ndrop:\n\treturn -1;\n}\n\nstatic int\nil3945_get_measurement(struct il_priv *il,\n\t\t       struct ieee80211_measurement_params *params, u8 type)\n{\n\tstruct il_spectrum_cmd spectrum;\n\tstruct il_rx_pkt *pkt;\n\tstruct il_host_cmd cmd = {\n\t\t.id = C_SPECTRUM_MEASUREMENT,\n\t\t.data = (void *)&spectrum,\n\t\t.flags = CMD_WANT_SKB,\n\t};\n\tu32 add_time = le64_to_cpu(params->start_time);\n\tint rc;\n\tint spectrum_resp_status;\n\tint duration = le16_to_cpu(params->duration);\n\n\tif (il_is_associated(il))\n\t\tadd_time =\n\t\t    il_usecs_to_beacons(il,\n\t\t\t\t\tle64_to_cpu(params->start_time) -\n\t\t\t\t\til->_3945.last_tsf,\n\t\t\t\t\tle16_to_cpu(il->timing.beacon_interval));\n\n\tmemset(&spectrum, 0, sizeof(spectrum));\n\n\tspectrum.channel_count = cpu_to_le16(1);\n\tspectrum.flags =\n\t    RXON_FLG_TSF2HOST_MSK | RXON_FLG_ANT_A_MSK | RXON_FLG_DIS_DIV_MSK;\n\tspectrum.filter_flags = MEASUREMENT_FILTER_FLAG;\n\tcmd.len = sizeof(spectrum);\n\tspectrum.len = cpu_to_le16(cmd.len - sizeof(spectrum.len));\n\n\tif (il_is_associated(il))\n\t\tspectrum.start_time =\n\t\t    il_add_beacon_time(il, il->_3945.last_beacon_time, add_time,\n\t\t\t\t       le16_to_cpu(il->timing.beacon_interval));\n\telse\n\t\tspectrum.start_time = 0;\n\n\tspectrum.channels[0].duration = cpu_to_le32(duration * TIME_UNIT);\n\tspectrum.channels[0].channel = params->channel;\n\tspectrum.channels[0].type = type;\n\tif (il->active.flags & RXON_FLG_BAND_24G_MSK)\n\t\tspectrum.flags |=\n\t\t    RXON_FLG_BAND_24G_MSK | RXON_FLG_AUTO_DETECT_MSK |\n\t\t    RXON_FLG_TGG_PROTECT_MSK;\n\n\trc = il_send_cmd_sync(il, &cmd);\n\tif (rc)\n\t\treturn rc;\n\n\tpkt = (struct il_rx_pkt *)cmd.reply_page;\n\tif (pkt->hdr.flags & IL_CMD_FAILED_MSK) {\n\t\tIL_ERR(\"Bad return from N_RX_ON_ASSOC command\\n\");\n\t\trc = -EIO;\n\t}\n\n\tspectrum_resp_status = le16_to_cpu(pkt->u.spectrum.status);\n\tswitch (spectrum_resp_status) {\n\tcase 0:\t\t \n\t\tif (pkt->u.spectrum.id != 0xff) {\n\t\t\tD_INFO(\"Replaced existing measurement: %d\\n\",\n\t\t\t       pkt->u.spectrum.id);\n\t\t\til->measurement_status &= ~MEASUREMENT_READY;\n\t\t}\n\t\til->measurement_status |= MEASUREMENT_ACTIVE;\n\t\trc = 0;\n\t\tbreak;\n\n\tcase 1:\t\t \n\t\trc = -EAGAIN;\n\t\tbreak;\n\t}\n\n\til_free_pages(il, cmd.reply_page);\n\n\treturn rc;\n}\n\nstatic void\nil3945_hdl_alive(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tstruct il_alive_resp *palive;\n\tstruct delayed_work *pwork;\n\n\tpalive = &pkt->u.alive_frame;\n\n\tD_INFO(\"Alive ucode status 0x%08X revision \" \"0x%01X 0x%01X\\n\",\n\t       palive->is_valid, palive->ver_type, palive->ver_subtype);\n\n\tif (palive->ver_subtype == INITIALIZE_SUBTYPE) {\n\t\tD_INFO(\"Initialization Alive received.\\n\");\n\t\tmemcpy(&il->card_alive_init, &pkt->u.alive_frame,\n\t\t       sizeof(struct il_alive_resp));\n\t\tpwork = &il->init_alive_start;\n\t} else {\n\t\tD_INFO(\"Runtime Alive received.\\n\");\n\t\tmemcpy(&il->card_alive, &pkt->u.alive_frame,\n\t\t       sizeof(struct il_alive_resp));\n\t\tpwork = &il->alive_start;\n\t\til3945_disable_events(il);\n\t}\n\n\t \n\tif (palive->is_valid == UCODE_VALID_OK)\n\t\tqueue_delayed_work(il->workqueue, pwork, msecs_to_jiffies(5));\n\telse\n\t\tIL_WARN(\"uCode did not respond OK.\\n\");\n}\n\nstatic void\nil3945_hdl_add_sta(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\n\tD_RX(\"Received C_ADD_STA: 0x%02X\\n\", pkt->u.status);\n}\n\nstatic void\nil3945_hdl_beacon(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tstruct il3945_beacon_notif *beacon = &(pkt->u.beacon_status);\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tu8 rate = beacon->beacon_notify_hdr.rate;\n\n\tD_RX(\"beacon status %x retries %d iss %d \" \"tsf %d %d rate %d\\n\",\n\t     le32_to_cpu(beacon->beacon_notify_hdr.status) & TX_STATUS_MSK,\n\t     beacon->beacon_notify_hdr.failure_frame,\n\t     le32_to_cpu(beacon->ibss_mgr_status),\n\t     le32_to_cpu(beacon->high_tsf), le32_to_cpu(beacon->low_tsf), rate);\n#endif\n\n\til->ibss_manager = le32_to_cpu(beacon->ibss_mgr_status);\n\n}\n\n \nstatic void\nil3945_hdl_card_state(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tu32 flags = le32_to_cpu(pkt->u.card_state_notif.flags);\n\tunsigned long status = il->status;\n\n\tIL_WARN(\"Card state received: HW:%s SW:%s\\n\",\n\t\t(flags & HW_CARD_DISABLED) ? \"Kill\" : \"On\",\n\t\t(flags & SW_CARD_DISABLED) ? \"Kill\" : \"On\");\n\n\t_il_wr(il, CSR_UCODE_DRV_GP1_SET, CSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED);\n\n\tif (flags & HW_CARD_DISABLED)\n\t\tset_bit(S_RFKILL, &il->status);\n\telse\n\t\tclear_bit(S_RFKILL, &il->status);\n\n\til_scan_cancel(il);\n\n\tif ((test_bit(S_RFKILL, &status) !=\n\t     test_bit(S_RFKILL, &il->status)))\n\t\twiphy_rfkill_set_hw_state(il->hw->wiphy,\n\t\t\t\t\t  test_bit(S_RFKILL, &il->status));\n\telse\n\t\twake_up(&il->wait_command_queue);\n}\n\n \nstatic void\nil3945_setup_handlers(struct il_priv *il)\n{\n\til->handlers[N_ALIVE] = il3945_hdl_alive;\n\til->handlers[C_ADD_STA] = il3945_hdl_add_sta;\n\til->handlers[N_ERROR] = il_hdl_error;\n\til->handlers[N_CHANNEL_SWITCH] = il_hdl_csa;\n\til->handlers[N_SPECTRUM_MEASUREMENT] = il_hdl_spectrum_measurement;\n\til->handlers[N_PM_SLEEP] = il_hdl_pm_sleep;\n\til->handlers[N_PM_DEBUG_STATS] = il_hdl_pm_debug_stats;\n\til->handlers[N_BEACON] = il3945_hdl_beacon;\n\n\t \n\til->handlers[C_STATS] = il3945_hdl_c_stats;\n\til->handlers[N_STATS] = il3945_hdl_stats;\n\n\til_setup_rx_scan_handlers(il);\n\til->handlers[N_CARD_STATE] = il3945_hdl_card_state;\n\n\t \n\til3945_hw_handler_setup(il);\n}\n\n \n \n\n \nstatic inline __le32\nil3945_dma_addr2rbd_ptr(struct il_priv *il, dma_addr_t dma_addr)\n{\n\treturn cpu_to_le32((u32) dma_addr);\n}\n\n \nstatic void\nil3945_rx_queue_restock(struct il_priv *il)\n{\n\tstruct il_rx_queue *rxq = &il->rxq;\n\tstruct list_head *element;\n\tstruct il_rx_buf *rxb;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rxq->lock, flags);\n\twhile (il_rx_queue_space(rxq) > 0 && rxq->free_count) {\n\t\t \n\t\telement = rxq->rx_free.next;\n\t\trxb = list_entry(element, struct il_rx_buf, list);\n\t\tlist_del(element);\n\n\t\t \n\t\trxq->bd[rxq->write] =\n\t\t    il3945_dma_addr2rbd_ptr(il, rxb->page_dma);\n\t\trxq->queue[rxq->write] = rxb;\n\t\trxq->write = (rxq->write + 1) & RX_QUEUE_MASK;\n\t\trxq->free_count--;\n\t}\n\tspin_unlock_irqrestore(&rxq->lock, flags);\n\t \n\tif (rxq->free_count <= RX_LOW_WATERMARK)\n\t\tqueue_work(il->workqueue, &il->rx_replenish);\n\n\t \n\tif (rxq->write_actual != (rxq->write & ~0x7) ||\n\t    abs(rxq->write - rxq->read) > 7) {\n\t\tspin_lock_irqsave(&rxq->lock, flags);\n\t\trxq->need_update = 1;\n\t\tspin_unlock_irqrestore(&rxq->lock, flags);\n\t\til_rx_queue_update_write_ptr(il, rxq);\n\t}\n}\n\n \nstatic void\nil3945_rx_allocate(struct il_priv *il, gfp_t priority)\n{\n\tstruct il_rx_queue *rxq = &il->rxq;\n\tstruct list_head *element;\n\tstruct il_rx_buf *rxb;\n\tstruct page *page;\n\tdma_addr_t page_dma;\n\tunsigned long flags;\n\tgfp_t gfp_mask = priority;\n\n\twhile (1) {\n\t\tspin_lock_irqsave(&rxq->lock, flags);\n\t\tif (list_empty(&rxq->rx_used)) {\n\t\t\tspin_unlock_irqrestore(&rxq->lock, flags);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock_irqrestore(&rxq->lock, flags);\n\n\t\tif (rxq->free_count > RX_LOW_WATERMARK)\n\t\t\tgfp_mask |= __GFP_NOWARN;\n\n\t\tif (il->hw_params.rx_page_order > 0)\n\t\t\tgfp_mask |= __GFP_COMP;\n\n\t\t \n\t\tpage = alloc_pages(gfp_mask, il->hw_params.rx_page_order);\n\t\tif (!page) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tD_INFO(\"Failed to allocate SKB buffer.\\n\");\n\t\t\tif (rxq->free_count <= RX_LOW_WATERMARK &&\n\t\t\t    net_ratelimit())\n\t\t\t\tIL_ERR(\"Failed to allocate SKB buffer with %0x.\"\n\t\t\t\t       \"Only %u free buffers remaining.\\n\",\n\t\t\t\t       priority, rxq->free_count);\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tpage_dma =\n\t\t    dma_map_page(&il->pci_dev->dev, page, 0,\n\t\t\t\t PAGE_SIZE << il->hw_params.rx_page_order,\n\t\t\t\t DMA_FROM_DEVICE);\n\n\t\tif (unlikely(dma_mapping_error(&il->pci_dev->dev, page_dma))) {\n\t\t\t__free_pages(page, il->hw_params.rx_page_order);\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_lock_irqsave(&rxq->lock, flags);\n\n\t\tif (list_empty(&rxq->rx_used)) {\n\t\t\tspin_unlock_irqrestore(&rxq->lock, flags);\n\t\t\tdma_unmap_page(&il->pci_dev->dev, page_dma,\n\t\t\t\t       PAGE_SIZE << il->hw_params.rx_page_order,\n\t\t\t\t       DMA_FROM_DEVICE);\n\t\t\t__free_pages(page, il->hw_params.rx_page_order);\n\t\t\treturn;\n\t\t}\n\n\t\telement = rxq->rx_used.next;\n\t\trxb = list_entry(element, struct il_rx_buf, list);\n\t\tlist_del(element);\n\n\t\trxb->page = page;\n\t\trxb->page_dma = page_dma;\n\t\tlist_add_tail(&rxb->list, &rxq->rx_free);\n\t\trxq->free_count++;\n\t\til->alloc_rxb_page++;\n\n\t\tspin_unlock_irqrestore(&rxq->lock, flags);\n\t}\n}\n\nvoid\nil3945_rx_queue_reset(struct il_priv *il, struct il_rx_queue *rxq)\n{\n\tunsigned long flags;\n\tint i;\n\tspin_lock_irqsave(&rxq->lock, flags);\n\tINIT_LIST_HEAD(&rxq->rx_free);\n\tINIT_LIST_HEAD(&rxq->rx_used);\n\t \n\tfor (i = 0; i < RX_FREE_BUFFERS + RX_QUEUE_SIZE; i++) {\n\t\t \n\t\tif (rxq->pool[i].page != NULL) {\n\t\t\tdma_unmap_page(&il->pci_dev->dev,\n\t\t\t\t       rxq->pool[i].page_dma,\n\t\t\t\t       PAGE_SIZE << il->hw_params.rx_page_order,\n\t\t\t\t       DMA_FROM_DEVICE);\n\t\t\t__il_free_pages(il, rxq->pool[i].page);\n\t\t\trxq->pool[i].page = NULL;\n\t\t}\n\t\tlist_add_tail(&rxq->pool[i].list, &rxq->rx_used);\n\t}\n\n\t \n\trxq->read = rxq->write = 0;\n\trxq->write_actual = 0;\n\trxq->free_count = 0;\n\tspin_unlock_irqrestore(&rxq->lock, flags);\n}\n\nvoid\nil3945_rx_replenish(void *data)\n{\n\tstruct il_priv *il = data;\n\tunsigned long flags;\n\n\til3945_rx_allocate(il, GFP_KERNEL);\n\n\tspin_lock_irqsave(&il->lock, flags);\n\til3945_rx_queue_restock(il);\n\tspin_unlock_irqrestore(&il->lock, flags);\n}\n\nstatic void\nil3945_rx_replenish_now(struct il_priv *il)\n{\n\til3945_rx_allocate(il, GFP_ATOMIC);\n\n\til3945_rx_queue_restock(il);\n}\n\n \nstatic void\nil3945_rx_queue_free(struct il_priv *il, struct il_rx_queue *rxq)\n{\n\tint i;\n\tfor (i = 0; i < RX_QUEUE_SIZE + RX_FREE_BUFFERS; i++) {\n\t\tif (rxq->pool[i].page != NULL) {\n\t\t\tdma_unmap_page(&il->pci_dev->dev,\n\t\t\t\t       rxq->pool[i].page_dma,\n\t\t\t\t       PAGE_SIZE << il->hw_params.rx_page_order,\n\t\t\t\t       DMA_FROM_DEVICE);\n\t\t\t__il_free_pages(il, rxq->pool[i].page);\n\t\t\trxq->pool[i].page = NULL;\n\t\t}\n\t}\n\n\tdma_free_coherent(&il->pci_dev->dev, 4 * RX_QUEUE_SIZE, rxq->bd,\n\t\t\t  rxq->bd_dma);\n\tdma_free_coherent(&il->pci_dev->dev, sizeof(struct il_rb_status),\n\t\t\t  rxq->rb_stts, rxq->rb_stts_dma);\n\trxq->bd = NULL;\n\trxq->rb_stts = NULL;\n}\n\n \nstatic u8 ratio2dB[100] = {\n \n\t0, 0, 6, 10, 12, 14, 16, 17, 18, 19,\t \n\t20, 21, 22, 22, 23, 23, 24, 25, 26, 26,\t \n\t26, 26, 26, 27, 27, 28, 28, 28, 29, 29,\t \n\t29, 30, 30, 30, 31, 31, 31, 31, 32, 32,\t \n\t32, 32, 32, 33, 33, 33, 33, 33, 34, 34,\t \n\t34, 34, 34, 34, 35, 35, 35, 35, 35, 35,\t \n\t36, 36, 36, 36, 36, 36, 36, 37, 37, 37,\t \n\t37, 37, 37, 37, 37, 38, 38, 38, 38, 38,\t \n\t38, 38, 38, 38, 38, 39, 39, 39, 39, 39,\t \n\t39, 39, 39, 39, 39, 40, 40, 40, 40, 40\t \n};\n\n \nint\nil3945_calc_db_from_ratio(int sig_ratio)\n{\n\t \n\tif (sig_ratio >= 1000)\n\t\treturn 60;\n\n\t \n\tif (sig_ratio >= 100)\n\t\treturn 20 + (int)ratio2dB[sig_ratio / 10];\n\n\t \n\tif (sig_ratio < 1)\n\t\treturn 0;\n\n\t \n\treturn (int)ratio2dB[sig_ratio];\n}\n\n \nstatic void\nil3945_rx_handle(struct il_priv *il)\n{\n\tstruct il_rx_buf *rxb;\n\tstruct il_rx_pkt *pkt;\n\tstruct il_rx_queue *rxq = &il->rxq;\n\tu32 r, i;\n\tint reclaim;\n\tunsigned long flags;\n\tu8 fill_rx = 0;\n\tu32 count = 8;\n\tint total_empty = 0;\n\n\t \n\tr = le16_to_cpu(rxq->rb_stts->closed_rb_num) & 0x0FFF;\n\ti = rxq->read;\n\n\t \n\ttotal_empty = r - rxq->write_actual;\n\tif (total_empty < 0)\n\t\ttotal_empty += RX_QUEUE_SIZE;\n\n\tif (total_empty > (RX_QUEUE_SIZE / 2))\n\t\tfill_rx = 1;\n\t \n\tif (i == r)\n\t\tD_RX(\"r = %d, i = %d\\n\", r, i);\n\n\twhile (i != r) {\n\t\trxb = rxq->queue[i];\n\n\t\t \n\t\tBUG_ON(rxb == NULL);\n\n\t\trxq->queue[i] = NULL;\n\n\t\tdma_unmap_page(&il->pci_dev->dev, rxb->page_dma,\n\t\t\t       PAGE_SIZE << il->hw_params.rx_page_order,\n\t\t\t       DMA_FROM_DEVICE);\n\t\tpkt = rxb_addr(rxb);\n\t\treclaim = il_need_reclaim(il, pkt);\n\n\t\t \n\t\tif (il->handlers[pkt->hdr.cmd]) {\n\t\t\tD_RX(\"r = %d, i = %d, %s, 0x%02x\\n\", r, i,\n\t\t\t     il_get_cmd_string(pkt->hdr.cmd), pkt->hdr.cmd);\n\t\t\til->isr_stats.handlers[pkt->hdr.cmd]++;\n\t\t\til->handlers[pkt->hdr.cmd] (il, rxb);\n\t\t} else {\n\t\t\t \n\t\t\tD_RX(\"r %d i %d No handler needed for %s, 0x%02x\\n\", r,\n\t\t\t     i, il_get_cmd_string(pkt->hdr.cmd), pkt->hdr.cmd);\n\t\t}\n\n\t\t \n\n\t\tif (reclaim) {\n\t\t\t \n\t\t\tif (rxb->page)\n\t\t\t\til_tx_cmd_complete(il, rxb);\n\t\t\telse\n\t\t\t\tIL_WARN(\"Claim null rxb?\\n\");\n\t\t}\n\n\t\t \n\t\tspin_lock_irqsave(&rxq->lock, flags);\n\t\tif (rxb->page != NULL) {\n\t\t\trxb->page_dma =\n\t\t\t    dma_map_page(&il->pci_dev->dev, rxb->page, 0,\n\t\t\t\t\t PAGE_SIZE << il->hw_params.rx_page_order,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tif (unlikely(dma_mapping_error(&il->pci_dev->dev,\n\t\t\t\t\t\t       rxb->page_dma))) {\n\t\t\t\t__il_free_pages(il, rxb->page);\n\t\t\t\trxb->page = NULL;\n\t\t\t\tlist_add_tail(&rxb->list, &rxq->rx_used);\n\t\t\t} else {\n\t\t\t\tlist_add_tail(&rxb->list, &rxq->rx_free);\n\t\t\t\trxq->free_count++;\n\t\t\t}\n\t\t} else\n\t\t\tlist_add_tail(&rxb->list, &rxq->rx_used);\n\n\t\tspin_unlock_irqrestore(&rxq->lock, flags);\n\n\t\ti = (i + 1) & RX_QUEUE_MASK;\n\t\t \n\t\tif (fill_rx) {\n\t\t\tcount++;\n\t\t\tif (count >= 8) {\n\t\t\t\trxq->read = i;\n\t\t\t\til3945_rx_replenish_now(il);\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\trxq->read = i;\n\tif (fill_rx)\n\t\til3945_rx_replenish_now(il);\n\telse\n\t\til3945_rx_queue_restock(il);\n}\n\n \nstatic inline void\nil3945_synchronize_irq(struct il_priv *il)\n{\n\t \n\tsynchronize_irq(il->pci_dev->irq);\n\ttasklet_kill(&il->irq_tasklet);\n}\n\nstatic const char *\nil3945_desc_lookup(int i)\n{\n\tswitch (i) {\n\tcase 1:\n\t\treturn \"FAIL\";\n\tcase 2:\n\t\treturn \"BAD_PARAM\";\n\tcase 3:\n\t\treturn \"BAD_CHECKSUM\";\n\tcase 4:\n\t\treturn \"NMI_INTERRUPT\";\n\tcase 5:\n\t\treturn \"SYSASSERT\";\n\tcase 6:\n\t\treturn \"FATAL_ERROR\";\n\t}\n\n\treturn \"UNKNOWN\";\n}\n\n#define ERROR_START_OFFSET  (1 * sizeof(u32))\n#define ERROR_ELEM_SIZE     (7 * sizeof(u32))\n\nvoid\nil3945_dump_nic_error_log(struct il_priv *il)\n{\n\tu32 i;\n\tu32 desc, time, count, base, data1;\n\tu32 blink1, blink2, ilink1, ilink2;\n\n\tbase = le32_to_cpu(il->card_alive.error_event_table_ptr);\n\n\tif (!il3945_hw_valid_rtc_data_addr(base)) {\n\t\tIL_ERR(\"Not valid error log pointer 0x%08X\\n\", base);\n\t\treturn;\n\t}\n\n\tcount = il_read_targ_mem(il, base);\n\n\tif (ERROR_START_OFFSET <= count * ERROR_ELEM_SIZE) {\n\t\tIL_ERR(\"Start IWL Error Log Dump:\\n\");\n\t\tIL_ERR(\"Status: 0x%08lX, count: %d\\n\", il->status, count);\n\t}\n\n\tIL_ERR(\"Desc       Time       asrtPC  blink2 \"\n\t       \"ilink1  nmiPC   Line\\n\");\n\tfor (i = ERROR_START_OFFSET;\n\t     i < (count * ERROR_ELEM_SIZE) + ERROR_START_OFFSET;\n\t     i += ERROR_ELEM_SIZE) {\n\t\tdesc = il_read_targ_mem(il, base + i);\n\t\ttime = il_read_targ_mem(il, base + i + 1 * sizeof(u32));\n\t\tblink1 = il_read_targ_mem(il, base + i + 2 * sizeof(u32));\n\t\tblink2 = il_read_targ_mem(il, base + i + 3 * sizeof(u32));\n\t\tilink1 = il_read_targ_mem(il, base + i + 4 * sizeof(u32));\n\t\tilink2 = il_read_targ_mem(il, base + i + 5 * sizeof(u32));\n\t\tdata1 = il_read_targ_mem(il, base + i + 6 * sizeof(u32));\n\n\t\tIL_ERR(\"%-13s (0x%X) %010u 0x%05X 0x%05X 0x%05X 0x%05X %u\\n\\n\",\n\t\t       il3945_desc_lookup(desc), desc, time, blink1, blink2,\n\t\t       ilink1, ilink2, data1);\n\t}\n}\n\nstatic void\nil3945_irq_tasklet(struct tasklet_struct *t)\n{\n\tstruct il_priv *il = from_tasklet(il, t, irq_tasklet);\n\tu32 inta, handled = 0;\n\tu32 inta_fh;\n\tunsigned long flags;\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tu32 inta_mask;\n#endif\n\n\tspin_lock_irqsave(&il->lock, flags);\n\n\t \n\tinta = _il_rd(il, CSR_INT);\n\t_il_wr(il, CSR_INT, inta);\n\n\t \n\tinta_fh = _il_rd(il, CSR_FH_INT_STATUS);\n\t_il_wr(il, CSR_FH_INT_STATUS, inta_fh);\n\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tif (il_get_debug_level(il) & IL_DL_ISR) {\n\t\t \n\t\tinta_mask = _il_rd(il, CSR_INT_MASK);\n\t\tD_ISR(\"inta 0x%08x, enabled 0x%08x, fh 0x%08x\\n\", inta,\n\t\t      inta_mask, inta_fh);\n\t}\n#endif\n\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\t \n\tif (inta_fh & CSR39_FH_INT_RX_MASK)\n\t\tinta |= CSR_INT_BIT_FH_RX;\n\tif (inta_fh & CSR39_FH_INT_TX_MASK)\n\t\tinta |= CSR_INT_BIT_FH_TX;\n\n\t \n\tif (inta & CSR_INT_BIT_HW_ERR) {\n\t\tIL_ERR(\"Hardware error detected.  Restarting.\\n\");\n\n\t\t \n\t\til_disable_interrupts(il);\n\n\t\til->isr_stats.hw++;\n\t\til_irq_handle_error(il);\n\n\t\thandled |= CSR_INT_BIT_HW_ERR;\n\n\t\treturn;\n\t}\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tif (il_get_debug_level(il) & (IL_DL_ISR)) {\n\t\t \n\t\tif (inta & CSR_INT_BIT_SCD) {\n\t\t\tD_ISR(\"Scheduler finished to transmit \"\n\t\t\t      \"the frame/frames.\\n\");\n\t\t\til->isr_stats.sch++;\n\t\t}\n\n\t\t \n\t\tif (inta & CSR_INT_BIT_ALIVE) {\n\t\t\tD_ISR(\"Alive interrupt\\n\");\n\t\t\til->isr_stats.alive++;\n\t\t}\n\t}\n#endif\n\t \n\tinta &= ~(CSR_INT_BIT_SCD | CSR_INT_BIT_ALIVE);\n\n\t \n\tif (inta & CSR_INT_BIT_SW_ERR) {\n\t\tIL_ERR(\"Microcode SW error detected. \" \"Restarting 0x%X.\\n\",\n\t\t       inta);\n\t\til->isr_stats.sw++;\n\t\til_irq_handle_error(il);\n\t\thandled |= CSR_INT_BIT_SW_ERR;\n\t}\n\n\t \n\tif (inta & CSR_INT_BIT_WAKEUP) {\n\t\tD_ISR(\"Wakeup interrupt\\n\");\n\t\til_rx_queue_update_write_ptr(il, &il->rxq);\n\n\t\tspin_lock_irqsave(&il->lock, flags);\n\t\til_txq_update_write_ptr(il, &il->txq[0]);\n\t\til_txq_update_write_ptr(il, &il->txq[1]);\n\t\til_txq_update_write_ptr(il, &il->txq[2]);\n\t\til_txq_update_write_ptr(il, &il->txq[3]);\n\t\til_txq_update_write_ptr(il, &il->txq[4]);\n\t\tspin_unlock_irqrestore(&il->lock, flags);\n\n\t\til->isr_stats.wakeup++;\n\t\thandled |= CSR_INT_BIT_WAKEUP;\n\t}\n\n\t \n\tif (inta & (CSR_INT_BIT_FH_RX | CSR_INT_BIT_SW_RX)) {\n\t\til3945_rx_handle(il);\n\t\til->isr_stats.rx++;\n\t\thandled |= (CSR_INT_BIT_FH_RX | CSR_INT_BIT_SW_RX);\n\t}\n\n\tif (inta & CSR_INT_BIT_FH_TX) {\n\t\tD_ISR(\"Tx interrupt\\n\");\n\t\til->isr_stats.tx++;\n\n\t\t_il_wr(il, CSR_FH_INT_STATUS, (1 << 6));\n\t\til_wr(il, FH39_TCSR_CREDIT(FH39_SRVC_CHNL), 0x0);\n\t\thandled |= CSR_INT_BIT_FH_TX;\n\t}\n\n\tif (inta & ~handled) {\n\t\tIL_ERR(\"Unhandled INTA bits 0x%08x\\n\", inta & ~handled);\n\t\til->isr_stats.unhandled++;\n\t}\n\n\tif (inta & ~il->inta_mask) {\n\t\tIL_WARN(\"Disabled INTA bits 0x%08x were pending\\n\",\n\t\t\tinta & ~il->inta_mask);\n\t\tIL_WARN(\"   with inta_fh = 0x%08x\\n\", inta_fh);\n\t}\n\n\t \n\t \n\tif (test_bit(S_INT_ENABLED, &il->status))\n\t\til_enable_interrupts(il);\n\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tif (il_get_debug_level(il) & (IL_DL_ISR)) {\n\t\tinta = _il_rd(il, CSR_INT);\n\t\tinta_mask = _il_rd(il, CSR_INT_MASK);\n\t\tinta_fh = _il_rd(il, CSR_FH_INT_STATUS);\n\t\tD_ISR(\"End inta 0x%08x, enabled 0x%08x, fh 0x%08x, \"\n\t\t      \"flags 0x%08lx\\n\", inta, inta_mask, inta_fh, flags);\n\t}\n#endif\n}\n\nstatic int\nil3945_get_channels_for_scan(struct il_priv *il, enum nl80211_band band,\n\t\t\t     u8 is_active, u8 n_probes,\n\t\t\t     struct il3945_scan_channel *scan_ch,\n\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_channel *chan;\n\tconst struct ieee80211_supported_band *sband;\n\tconst struct il_channel_info *ch_info;\n\tu16 passive_dwell = 0;\n\tu16 active_dwell = 0;\n\tint added, i;\n\n\tsband = il_get_hw_mode(il, band);\n\tif (!sband)\n\t\treturn 0;\n\n\tactive_dwell = il_get_active_dwell_time(il, band, n_probes);\n\tpassive_dwell = il_get_passive_dwell_time(il, band, vif);\n\n\tif (passive_dwell <= active_dwell)\n\t\tpassive_dwell = active_dwell + 1;\n\n\tfor (i = 0, added = 0; i < il->scan_request->n_channels; i++) {\n\t\tchan = il->scan_request->channels[i];\n\n\t\tif (chan->band != band)\n\t\t\tcontinue;\n\n\t\tscan_ch->channel = chan->hw_value;\n\n\t\tch_info = il_get_channel_info(il, band, scan_ch->channel);\n\t\tif (!il_is_channel_valid(ch_info)) {\n\t\t\tD_SCAN(\"Channel %d is INVALID for this band.\\n\",\n\t\t\t       scan_ch->channel);\n\t\t\tcontinue;\n\t\t}\n\n\t\tscan_ch->active_dwell = cpu_to_le16(active_dwell);\n\t\tscan_ch->passive_dwell = cpu_to_le16(passive_dwell);\n\t\t \n\t\tif (!is_active || il_is_channel_passive(ch_info) ||\n\t\t    (chan->flags & IEEE80211_CHAN_NO_IR)) {\n\t\t\tscan_ch->type = 0;\t \n\t\t\tif (IL_UCODE_API(il->ucode_ver) == 1)\n\t\t\t\tscan_ch->active_dwell =\n\t\t\t\t    cpu_to_le16(passive_dwell - 1);\n\t\t} else {\n\t\t\tscan_ch->type = 1;\t \n\t\t}\n\n\t\t \n\t\tif (IL_UCODE_API(il->ucode_ver) >= 2) {\n\t\t\tif (n_probes)\n\t\t\t\tscan_ch->type |= IL39_SCAN_PROBE_MASK(n_probes);\n\t\t} else {\n\t\t\t \n\t\t\tif ((scan_ch->type & 1) && n_probes)\n\t\t\t\tscan_ch->type |= IL39_SCAN_PROBE_MASK(n_probes);\n\t\t}\n\n\t\t \n\t\tscan_ch->tpc.dsp_atten = 110;\n\t\t \n\n\t\t \n\t\tif (band == NL80211_BAND_5GHZ)\n\t\t\tscan_ch->tpc.tx_gain = ((1 << 5) | (3 << 3)) | 3;\n\t\telse {\n\t\t\tscan_ch->tpc.tx_gain = ((1 << 5) | (5 << 3));\n\t\t\t \n\t\t}\n\n\t\tD_SCAN(\"Scanning %d [%s %d]\\n\", scan_ch->channel,\n\t\t       (scan_ch->type & 1) ? \"ACTIVE\" : \"PASSIVE\",\n\t\t       (scan_ch->type & 1) ? active_dwell : passive_dwell);\n\n\t\tscan_ch++;\n\t\tadded++;\n\t}\n\n\tD_SCAN(\"total channels to scan %d\\n\", added);\n\treturn added;\n}\n\nstatic void\nil3945_init_hw_rates(struct il_priv *il, struct ieee80211_rate *rates)\n{\n\tint i;\n\n\tfor (i = 0; i < RATE_COUNT_LEGACY; i++) {\n\t\trates[i].bitrate = il3945_rates[i].ieee * 5;\n\t\trates[i].hw_value = i;\t \n\t\trates[i].hw_value_short = i;\n\t\trates[i].flags = 0;\n\t\tif (i > IL39_LAST_OFDM_RATE || i < IL_FIRST_OFDM_RATE) {\n\t\t\t \n\t\t\trates[i].flags |=\n\t\t\t    (il3945_rates[i].plcp ==\n\t\t\t     10) ? 0 : IEEE80211_RATE_SHORT_PREAMBLE;\n\t\t}\n\t}\n}\n\n \n\nstatic void\nil3945_dealloc_ucode_pci(struct il_priv *il)\n{\n\til_free_fw_desc(il->pci_dev, &il->ucode_code);\n\til_free_fw_desc(il->pci_dev, &il->ucode_data);\n\til_free_fw_desc(il->pci_dev, &il->ucode_data_backup);\n\til_free_fw_desc(il->pci_dev, &il->ucode_init);\n\til_free_fw_desc(il->pci_dev, &il->ucode_init_data);\n\til_free_fw_desc(il->pci_dev, &il->ucode_boot);\n}\n\n \nstatic int\nil3945_verify_inst_full(struct il_priv *il, __le32 * image, u32 len)\n{\n\tu32 val;\n\tu32 save_len = len;\n\tint rc = 0;\n\tu32 errcnt;\n\n\tD_INFO(\"ucode inst image size is %u\\n\", len);\n\n\til_wr(il, HBUS_TARG_MEM_RADDR, IL39_RTC_INST_LOWER_BOUND);\n\n\terrcnt = 0;\n\tfor (; len > 0; len -= sizeof(u32), image++) {\n\t\t \n\t\t \n\t\tval = _il_rd(il, HBUS_TARG_MEM_RDAT);\n\t\tif (val != le32_to_cpu(*image)) {\n\t\t\tIL_ERR(\"uCode INST section is invalid at \"\n\t\t\t       \"offset 0x%x, is 0x%x, s/b 0x%x\\n\",\n\t\t\t       save_len - len, val, le32_to_cpu(*image));\n\t\t\trc = -EIO;\n\t\t\terrcnt++;\n\t\t\tif (errcnt >= 20)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!errcnt)\n\t\tD_INFO(\"ucode image in INSTRUCTION memory is good\\n\");\n\n\treturn rc;\n}\n\n \nstatic int\nil3945_verify_inst_sparse(struct il_priv *il, __le32 * image, u32 len)\n{\n\tu32 val;\n\tint rc = 0;\n\tu32 errcnt = 0;\n\tu32 i;\n\n\tD_INFO(\"ucode inst image size is %u\\n\", len);\n\n\tfor (i = 0; i < len; i += 100, image += 100 / sizeof(u32)) {\n\t\t \n\t\t \n\t\til_wr(il, HBUS_TARG_MEM_RADDR, i + IL39_RTC_INST_LOWER_BOUND);\n\t\tval = _il_rd(il, HBUS_TARG_MEM_RDAT);\n\t\tif (val != le32_to_cpu(*image)) {\n#if 0\t\t\t\t \n\t\t\tIL_ERR(\"uCode INST section is invalid at \"\n\t\t\t       \"offset 0x%x, is 0x%x, s/b 0x%x\\n\", i, val,\n\t\t\t       *image);\n#endif\n\t\t\trc = -EIO;\n\t\t\terrcnt++;\n\t\t\tif (errcnt >= 3)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n \nstatic int\nil3945_verify_ucode(struct il_priv *il)\n{\n\t__le32 *image;\n\tu32 len;\n\tint rc = 0;\n\n\t \n\timage = (__le32 *) il->ucode_boot.v_addr;\n\tlen = il->ucode_boot.len;\n\trc = il3945_verify_inst_sparse(il, image, len);\n\tif (rc == 0) {\n\t\tD_INFO(\"Bootstrap uCode is good in inst SRAM\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\timage = (__le32 *) il->ucode_init.v_addr;\n\tlen = il->ucode_init.len;\n\trc = il3945_verify_inst_sparse(il, image, len);\n\tif (rc == 0) {\n\t\tD_INFO(\"Initialize uCode is good in inst SRAM\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\timage = (__le32 *) il->ucode_code.v_addr;\n\tlen = il->ucode_code.len;\n\trc = il3945_verify_inst_sparse(il, image, len);\n\tif (rc == 0) {\n\t\tD_INFO(\"Runtime uCode is good in inst SRAM\\n\");\n\t\treturn 0;\n\t}\n\n\tIL_ERR(\"NO VALID UCODE IMAGE IN INSTRUCTION SRAM!!\\n\");\n\n\t \n\timage = (__le32 *) il->ucode_boot.v_addr;\n\tlen = il->ucode_boot.len;\n\trc = il3945_verify_inst_full(il, image, len);\n\n\treturn rc;\n}\n\nstatic void\nil3945_nic_start(struct il_priv *il)\n{\n\t \n\t_il_wr(il, CSR_RESET, 0);\n}\n\n#define IL3945_UCODE_GET(item)\t\t\t\t\t\t\\\nstatic u32 il3945_ucode_get_##item(const struct il_ucode_header *ucode)\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn le32_to_cpu(ucode->v1.item);\t\t\t\t\\\n}\n\nstatic u32\nil3945_ucode_get_header_size(u32 api_ver)\n{\n\treturn 24;\n}\n\nstatic u8 *\nil3945_ucode_get_data(const struct il_ucode_header *ucode)\n{\n\treturn (u8 *) ucode->v1.data;\n}\n\nIL3945_UCODE_GET(inst_size);\nIL3945_UCODE_GET(data_size);\nIL3945_UCODE_GET(init_size);\nIL3945_UCODE_GET(init_data_size);\nIL3945_UCODE_GET(boot_size);\n\n \nstatic int\nil3945_read_ucode(struct il_priv *il)\n{\n\tconst struct il_ucode_header *ucode;\n\tint ret = -EINVAL, idx;\n\tconst struct firmware *ucode_raw;\n\t \n\tconst char *name_pre = il->cfg->fw_name_pre;\n\tconst unsigned int api_max = il->cfg->ucode_api_max;\n\tconst unsigned int api_min = il->cfg->ucode_api_min;\n\tchar buf[25];\n\tu8 *src;\n\tsize_t len;\n\tu32 api_ver, inst_size, data_size, init_size, init_data_size, boot_size;\n\n\t \n\tfor (idx = api_max; idx >= api_min; idx--) {\n\t\tsprintf(buf, \"%s%u%s\", name_pre, idx, \".ucode\");\n\t\tret = request_firmware(&ucode_raw, buf, &il->pci_dev->dev);\n\t\tif (ret < 0) {\n\t\t\tIL_ERR(\"%s firmware file req failed: %d\\n\", buf, ret);\n\t\t\tif (ret == -ENOENT)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tgoto error;\n\t\t} else {\n\t\t\tif (idx < api_max)\n\t\t\t\tIL_ERR(\"Loaded firmware %s, \"\n\t\t\t\t       \"which is deprecated. \"\n\t\t\t\t       \" Please use API v%u instead.\\n\", buf,\n\t\t\t\t       api_max);\n\t\t\tD_INFO(\"Got firmware '%s' file \"\n\t\t\t       \"(%zd bytes) from disk\\n\", buf, ucode_raw->size);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\tif (ucode_raw->size < il3945_ucode_get_header_size(1)) {\n\t\tIL_ERR(\"File size way too small!\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_release;\n\t}\n\n\t \n\tucode = (struct il_ucode_header *)ucode_raw->data;\n\n\til->ucode_ver = le32_to_cpu(ucode->ver);\n\tapi_ver = IL_UCODE_API(il->ucode_ver);\n\tinst_size = il3945_ucode_get_inst_size(ucode);\n\tdata_size = il3945_ucode_get_data_size(ucode);\n\tinit_size = il3945_ucode_get_init_size(ucode);\n\tinit_data_size = il3945_ucode_get_init_data_size(ucode);\n\tboot_size = il3945_ucode_get_boot_size(ucode);\n\tsrc = il3945_ucode_get_data(ucode);\n\n\t \n\n\tif (api_ver < api_min || api_ver > api_max) {\n\t\tIL_ERR(\"Driver unable to support your firmware API. \"\n\t\t       \"Driver supports v%u, firmware is v%u.\\n\", api_max,\n\t\t       api_ver);\n\t\til->ucode_ver = 0;\n\t\tret = -EINVAL;\n\t\tgoto err_release;\n\t}\n\tif (api_ver != api_max)\n\t\tIL_ERR(\"Firmware has old API version. Expected %u, \"\n\t\t       \"got %u. New firmware can be obtained \"\n\t\t       \"from http://www.intellinuxwireless.org.\\n\", api_max,\n\t\t       api_ver);\n\n\tIL_INFO(\"loaded firmware version %u.%u.%u.%u\\n\",\n\t\tIL_UCODE_MAJOR(il->ucode_ver), IL_UCODE_MINOR(il->ucode_ver),\n\t\tIL_UCODE_API(il->ucode_ver), IL_UCODE_SERIAL(il->ucode_ver));\n\n\tsnprintf(il->hw->wiphy->fw_version, sizeof(il->hw->wiphy->fw_version),\n\t\t \"%u.%u.%u.%u\", IL_UCODE_MAJOR(il->ucode_ver),\n\t\t IL_UCODE_MINOR(il->ucode_ver), IL_UCODE_API(il->ucode_ver),\n\t\t IL_UCODE_SERIAL(il->ucode_ver));\n\n\tD_INFO(\"f/w package hdr ucode version raw = 0x%x\\n\", il->ucode_ver);\n\tD_INFO(\"f/w package hdr runtime inst size = %u\\n\", inst_size);\n\tD_INFO(\"f/w package hdr runtime data size = %u\\n\", data_size);\n\tD_INFO(\"f/w package hdr init inst size = %u\\n\", init_size);\n\tD_INFO(\"f/w package hdr init data size = %u\\n\", init_data_size);\n\tD_INFO(\"f/w package hdr boot inst size = %u\\n\", boot_size);\n\n\t \n\tif (ucode_raw->size !=\n\t    il3945_ucode_get_header_size(api_ver) + inst_size + data_size +\n\t    init_size + init_data_size + boot_size) {\n\n\t\tD_INFO(\"uCode file size %zd does not match expected size\\n\",\n\t\t       ucode_raw->size);\n\t\tret = -EINVAL;\n\t\tgoto err_release;\n\t}\n\n\t \n\tif (inst_size > IL39_MAX_INST_SIZE) {\n\t\tD_INFO(\"uCode instr len %d too large to fit in\\n\", inst_size);\n\t\tret = -EINVAL;\n\t\tgoto err_release;\n\t}\n\n\tif (data_size > IL39_MAX_DATA_SIZE) {\n\t\tD_INFO(\"uCode data len %d too large to fit in\\n\", data_size);\n\t\tret = -EINVAL;\n\t\tgoto err_release;\n\t}\n\tif (init_size > IL39_MAX_INST_SIZE) {\n\t\tD_INFO(\"uCode init instr len %d too large to fit in\\n\",\n\t\t       init_size);\n\t\tret = -EINVAL;\n\t\tgoto err_release;\n\t}\n\tif (init_data_size > IL39_MAX_DATA_SIZE) {\n\t\tD_INFO(\"uCode init data len %d too large to fit in\\n\",\n\t\t       init_data_size);\n\t\tret = -EINVAL;\n\t\tgoto err_release;\n\t}\n\tif (boot_size > IL39_MAX_BSM_SIZE) {\n\t\tD_INFO(\"uCode boot instr len %d too large to fit in\\n\",\n\t\t       boot_size);\n\t\tret = -EINVAL;\n\t\tgoto err_release;\n\t}\n\n\t \n\n\t \n\til->ucode_code.len = inst_size;\n\til_alloc_fw_desc(il->pci_dev, &il->ucode_code);\n\n\til->ucode_data.len = data_size;\n\til_alloc_fw_desc(il->pci_dev, &il->ucode_data);\n\n\til->ucode_data_backup.len = data_size;\n\til_alloc_fw_desc(il->pci_dev, &il->ucode_data_backup);\n\n\tif (!il->ucode_code.v_addr || !il->ucode_data.v_addr ||\n\t    !il->ucode_data_backup.v_addr)\n\t\tgoto err_pci_alloc;\n\n\t \n\tif (init_size && init_data_size) {\n\t\til->ucode_init.len = init_size;\n\t\til_alloc_fw_desc(il->pci_dev, &il->ucode_init);\n\n\t\til->ucode_init_data.len = init_data_size;\n\t\til_alloc_fw_desc(il->pci_dev, &il->ucode_init_data);\n\n\t\tif (!il->ucode_init.v_addr || !il->ucode_init_data.v_addr)\n\t\t\tgoto err_pci_alloc;\n\t}\n\n\t \n\tif (boot_size) {\n\t\til->ucode_boot.len = boot_size;\n\t\til_alloc_fw_desc(il->pci_dev, &il->ucode_boot);\n\n\t\tif (!il->ucode_boot.v_addr)\n\t\t\tgoto err_pci_alloc;\n\t}\n\n\t \n\n\t \n\tlen = inst_size;\n\tD_INFO(\"Copying (but not loading) uCode instr len %zd\\n\", len);\n\tmemcpy(il->ucode_code.v_addr, src, len);\n\tsrc += len;\n\n\tD_INFO(\"uCode instr buf vaddr = 0x%p, paddr = 0x%08x\\n\",\n\t       il->ucode_code.v_addr, (u32) il->ucode_code.p_addr);\n\n\t \n\tlen = data_size;\n\tD_INFO(\"Copying (but not loading) uCode data len %zd\\n\", len);\n\tmemcpy(il->ucode_data.v_addr, src, len);\n\tmemcpy(il->ucode_data_backup.v_addr, src, len);\n\tsrc += len;\n\n\t \n\tif (init_size) {\n\t\tlen = init_size;\n\t\tD_INFO(\"Copying (but not loading) init instr len %zd\\n\", len);\n\t\tmemcpy(il->ucode_init.v_addr, src, len);\n\t\tsrc += len;\n\t}\n\n\t \n\tif (init_data_size) {\n\t\tlen = init_data_size;\n\t\tD_INFO(\"Copying (but not loading) init data len %zd\\n\", len);\n\t\tmemcpy(il->ucode_init_data.v_addr, src, len);\n\t\tsrc += len;\n\t}\n\n\t \n\tlen = boot_size;\n\tD_INFO(\"Copying (but not loading) boot instr len %zd\\n\", len);\n\tmemcpy(il->ucode_boot.v_addr, src, len);\n\n\t \n\trelease_firmware(ucode_raw);\n\treturn 0;\n\nerr_pci_alloc:\n\tIL_ERR(\"failed to allocate pci memory\\n\");\n\tret = -ENOMEM;\n\til3945_dealloc_ucode_pci(il);\n\nerr_release:\n\trelease_firmware(ucode_raw);\n\nerror:\n\treturn ret;\n}\n\n \nstatic int\nil3945_set_ucode_ptrs(struct il_priv *il)\n{\n\tdma_addr_t pinst;\n\tdma_addr_t pdata;\n\n\t \n\tpinst = il->ucode_code.p_addr;\n\tpdata = il->ucode_data_backup.p_addr;\n\n\t \n\til_wr_prph(il, BSM_DRAM_INST_PTR_REG, pinst);\n\til_wr_prph(il, BSM_DRAM_DATA_PTR_REG, pdata);\n\til_wr_prph(il, BSM_DRAM_DATA_BYTECOUNT_REG, il->ucode_data.len);\n\n\t \n\til_wr_prph(il, BSM_DRAM_INST_BYTECOUNT_REG,\n\t\t   il->ucode_code.len | BSM_DRAM_INST_LOAD);\n\n\tD_INFO(\"Runtime uCode pointers are set.\\n\");\n\n\treturn 0;\n}\n\n \nstatic void\nil3945_init_alive_start(struct il_priv *il)\n{\n\t \n\tif (il->card_alive_init.is_valid != UCODE_VALID_OK) {\n\t\t \n\t\tD_INFO(\"Initialize Alive failed.\\n\");\n\t\tgoto restart;\n\t}\n\n\t \n\tif (il3945_verify_ucode(il)) {\n\t\t \n\t\tD_INFO(\"Bad \\\"initialize\\\" uCode load.\\n\");\n\t\tgoto restart;\n\t}\n\n\t \n\tD_INFO(\"Initialization Alive received.\\n\");\n\tif (il3945_set_ucode_ptrs(il)) {\n\t\t \n\t\tD_INFO(\"Couldn't set up uCode pointers.\\n\");\n\t\tgoto restart;\n\t}\n\treturn;\n\nrestart:\n\tqueue_work(il->workqueue, &il->restart);\n}\n\n \nstatic void\nil3945_alive_start(struct il_priv *il)\n{\n\tint thermal_spin = 0;\n\tu32 rfkill;\n\n\tD_INFO(\"Runtime Alive received.\\n\");\n\n\tif (il->card_alive.is_valid != UCODE_VALID_OK) {\n\t\t \n\t\tD_INFO(\"Alive failed.\\n\");\n\t\tgoto restart;\n\t}\n\n\t \n\tif (il3945_verify_ucode(il)) {\n\t\t \n\t\tD_INFO(\"Bad runtime uCode load.\\n\");\n\t\tgoto restart;\n\t}\n\n\trfkill = il_rd_prph(il, APMG_RFKILL_REG);\n\tD_INFO(\"RFKILL status: 0x%x\\n\", rfkill);\n\n\tif (rfkill & 0x1) {\n\t\tclear_bit(S_RFKILL, &il->status);\n\t\t \n\t\twhile (il3945_hw_get_temperature(il) == 0) {\n\t\t\tthermal_spin++;\n\t\t\tudelay(10);\n\t\t}\n\n\t\tif (thermal_spin)\n\t\t\tD_INFO(\"Thermal calibration took %dus\\n\",\n\t\t\t       thermal_spin * 10);\n\t} else\n\t\tset_bit(S_RFKILL, &il->status);\n\n\t \n\tset_bit(S_ALIVE, &il->status);\n\n\t \n\til_setup_watchdog(il);\n\n\tif (il_is_rfkill(il))\n\t\treturn;\n\n\tieee80211_wake_queues(il->hw);\n\n\til->active_rate = RATES_MASK_3945;\n\n\til_power_update_mode(il, true);\n\n\tif (il_is_associated(il)) {\n\t\tstruct il3945_rxon_cmd *active_rxon =\n\t\t    (struct il3945_rxon_cmd *)(&il->active);\n\n\t\til->staging.filter_flags |= RXON_FILTER_ASSOC_MSK;\n\t\tactive_rxon->filter_flags &= ~RXON_FILTER_ASSOC_MSK;\n\t} else {\n\t\t \n\t\til_connection_init_rx_config(il);\n\t}\n\n\t \n\til_send_bt_config(il);\n\n\tset_bit(S_READY, &il->status);\n\n\t \n\til3945_commit_rxon(il);\n\n\til3945_reg_txpower_periodic(il);\n\n\tD_INFO(\"ALIVE processing complete.\\n\");\n\twake_up(&il->wait_command_queue);\n\n\treturn;\n\nrestart:\n\tqueue_work(il->workqueue, &il->restart);\n}\n\nstatic void il3945_cancel_deferred_work(struct il_priv *il);\n\nstatic void\n__il3945_down(struct il_priv *il)\n{\n\tunsigned long flags;\n\tint exit_pending;\n\n\tD_INFO(DRV_NAME \" is going down\\n\");\n\n\til_scan_cancel_timeout(il, 200);\n\n\texit_pending = test_and_set_bit(S_EXIT_PENDING, &il->status);\n\n\t \n\tdel_timer_sync(&il->watchdog);\n\n\t \n\til_clear_ucode_stations(il);\n\til_dealloc_bcast_stations(il);\n\til_clear_driver_stations(il);\n\n\t \n\twake_up_all(&il->wait_command_queue);\n\n\t \n\tif (!exit_pending)\n\t\tclear_bit(S_EXIT_PENDING, &il->status);\n\n\t \n\t_il_wr(il, CSR_RESET, CSR_RESET_REG_FLAG_NEVO_RESET);\n\n\t \n\tspin_lock_irqsave(&il->lock, flags);\n\til_disable_interrupts(il);\n\tspin_unlock_irqrestore(&il->lock, flags);\n\til3945_synchronize_irq(il);\n\n\tif (il->mac80211_registered)\n\t\tieee80211_stop_queues(il->hw);\n\n\t \n\tif (!il_is_init(il)) {\n\t\til->status =\n\t\t    test_bit(S_RFKILL, &il->status) << S_RFKILL |\n\t\t    test_bit(S_GEO_CONFIGURED, &il->status) << S_GEO_CONFIGURED |\n\t\t    test_bit(S_EXIT_PENDING, &il->status) << S_EXIT_PENDING;\n\t\tgoto exit;\n\t}\n\n\t \n\til->status &=\n\t    test_bit(S_RFKILL, &il->status) << S_RFKILL |\n\t    test_bit(S_GEO_CONFIGURED, &il->status) << S_GEO_CONFIGURED |\n\t    test_bit(S_FW_ERROR, &il->status) << S_FW_ERROR |\n\t    test_bit(S_EXIT_PENDING, &il->status) << S_EXIT_PENDING;\n\n\t \n\tspin_lock_irq(&il->reg_lock);\n\t \n\n\til3945_hw_txq_ctx_stop(il);\n\til3945_hw_rxq_stop(il);\n\t \n\t_il_wr_prph(il, APMG_CLK_DIS_REG, APMG_CLK_VAL_DMA_CLK_RQT);\n\tudelay(5);\n\t \n\t_il_apm_stop(il);\n\n\tspin_unlock_irq(&il->reg_lock);\n\n\til3945_hw_txq_ctx_free(il);\nexit:\n\tmemset(&il->card_alive, 0, sizeof(struct il_alive_resp));\n\tdev_kfree_skb(il->beacon_skb);\n\til->beacon_skb = NULL;\n\n\t \n\til3945_clear_free_frames(il);\n}\n\nstatic void\nil3945_down(struct il_priv *il)\n{\n\tmutex_lock(&il->mutex);\n\t__il3945_down(il);\n\tmutex_unlock(&il->mutex);\n\n\til3945_cancel_deferred_work(il);\n}\n\n#define MAX_HW_RESTARTS 5\n\nstatic int\nil3945_alloc_bcast_station(struct il_priv *il)\n{\n\tunsigned long flags;\n\tu8 sta_id;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\tsta_id = il_prep_station(il, il_bcast_addr, false, NULL);\n\tif (sta_id == IL_INVALID_STATION) {\n\t\tIL_ERR(\"Unable to prepare broadcast station\\n\");\n\t\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\t\treturn -EINVAL;\n\t}\n\n\til->stations[sta_id].used |= IL_STA_DRIVER_ACTIVE;\n\til->stations[sta_id].used |= IL_STA_BCAST;\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\treturn 0;\n}\n\nstatic int\n__il3945_up(struct il_priv *il)\n{\n\tint rc, i;\n\n\trc = il3945_alloc_bcast_station(il);\n\tif (rc)\n\t\treturn rc;\n\n\tif (test_bit(S_EXIT_PENDING, &il->status)) {\n\t\tIL_WARN(\"Exit pending; will not bring the NIC up\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (!il->ucode_data_backup.v_addr || !il->ucode_data.v_addr) {\n\t\tIL_ERR(\"ucode not available for device bring up\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (_il_rd(il, CSR_GP_CNTRL) & CSR_GP_CNTRL_REG_FLAG_HW_RF_KILL_SW)\n\t\tclear_bit(S_RFKILL, &il->status);\n\telse {\n\t\tset_bit(S_RFKILL, &il->status);\n\t\treturn -ERFKILL;\n\t}\n\n\t_il_wr(il, CSR_INT, 0xFFFFFFFF);\n\n\trc = il3945_hw_nic_init(il);\n\tif (rc) {\n\t\tIL_ERR(\"Unable to int nic\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\t_il_wr(il, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_SW_BIT_RFKILL);\n\t_il_wr(il, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED);\n\n\t \n\t_il_wr(il, CSR_INT, 0xFFFFFFFF);\n\til_enable_interrupts(il);\n\n\t \n\t_il_wr(il, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_SW_BIT_RFKILL);\n\t_il_wr(il, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_SW_BIT_RFKILL);\n\n\t \n\tmemcpy(il->ucode_data_backup.v_addr, il->ucode_data.v_addr,\n\t       il->ucode_data.len);\n\n\t \n\tif (test_bit(S_RFKILL, &il->status))\n\t\treturn 0;\n\n\tfor (i = 0; i < MAX_HW_RESTARTS; i++) {\n\n\t\t \n\t\trc = il->ops->load_ucode(il);\n\n\t\tif (rc) {\n\t\t\tIL_ERR(\"Unable to set up bootstrap uCode: %d\\n\", rc);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\til3945_nic_start(il);\n\n\t\tD_INFO(DRV_NAME \" is coming up\\n\");\n\n\t\treturn 0;\n\t}\n\n\tset_bit(S_EXIT_PENDING, &il->status);\n\t__il3945_down(il);\n\tclear_bit(S_EXIT_PENDING, &il->status);\n\n\t \n\tIL_ERR(\"Unable to initialize device after %d attempts.\\n\", i);\n\treturn -EIO;\n}\n\n \n\nstatic void\nil3945_bg_init_alive_start(struct work_struct *data)\n{\n\tstruct il_priv *il =\n\t    container_of(data, struct il_priv, init_alive_start.work);\n\n\tmutex_lock(&il->mutex);\n\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\tgoto out;\n\n\til3945_init_alive_start(il);\nout:\n\tmutex_unlock(&il->mutex);\n}\n\nstatic void\nil3945_bg_alive_start(struct work_struct *data)\n{\n\tstruct il_priv *il =\n\t    container_of(data, struct il_priv, alive_start.work);\n\n\tmutex_lock(&il->mutex);\n\tif (test_bit(S_EXIT_PENDING, &il->status) || il->txq == NULL)\n\t\tgoto out;\n\n\til3945_alive_start(il);\nout:\n\tmutex_unlock(&il->mutex);\n}\n\n \nstatic void\nil3945_rfkill_poll(struct work_struct *data)\n{\n\tstruct il_priv *il =\n\t    container_of(data, struct il_priv, _3945.rfkill_poll.work);\n\tbool old_rfkill = test_bit(S_RFKILL, &il->status);\n\tbool new_rfkill =\n\t    !(_il_rd(il, CSR_GP_CNTRL) & CSR_GP_CNTRL_REG_FLAG_HW_RF_KILL_SW);\n\n\tif (new_rfkill != old_rfkill) {\n\t\tif (new_rfkill)\n\t\t\tset_bit(S_RFKILL, &il->status);\n\t\telse\n\t\t\tclear_bit(S_RFKILL, &il->status);\n\n\t\twiphy_rfkill_set_hw_state(il->hw->wiphy, new_rfkill);\n\n\t\tD_RF_KILL(\"RF_KILL bit toggled to %s.\\n\",\n\t\t\t  new_rfkill ? \"disable radio\" : \"enable radio\");\n\t}\n\n\t \n\tqueue_delayed_work(il->workqueue, &il->_3945.rfkill_poll,\n\t\t\t   round_jiffies_relative(2 * HZ));\n\n}\n\nint\nil3945_request_scan(struct il_priv *il, struct ieee80211_vif *vif)\n{\n\tstruct il_host_cmd cmd = {\n\t\t.id = C_SCAN,\n\t\t.len = sizeof(struct il3945_scan_cmd),\n\t\t.flags = CMD_SIZE_HUGE,\n\t};\n\tstruct il3945_scan_cmd *scan;\n\tu8 n_probes = 0;\n\tenum nl80211_band band;\n\tbool is_active = false;\n\tint ret;\n\tu16 len;\n\n\tlockdep_assert_held(&il->mutex);\n\n\tif (!il->scan_cmd) {\n\t\til->scan_cmd =\n\t\t    kmalloc(sizeof(struct il3945_scan_cmd) + IL_MAX_SCAN_SIZE,\n\t\t\t    GFP_KERNEL);\n\t\tif (!il->scan_cmd) {\n\t\t\tD_SCAN(\"Fail to allocate scan memory\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tscan = il->scan_cmd;\n\tmemset(scan, 0, sizeof(struct il3945_scan_cmd) + IL_MAX_SCAN_SIZE);\n\n\tscan->quiet_plcp_th = IL_PLCP_QUIET_THRESH;\n\tscan->quiet_time = IL_ACTIVE_QUIET_TIME;\n\n\tif (il_is_associated(il)) {\n\t\tu16 interval;\n\t\tu32 extra;\n\t\tu32 suspend_time = 100;\n\t\tu32 scan_suspend_time = 100;\n\n\t\tD_INFO(\"Scanning while associated...\\n\");\n\n\t\tinterval = vif->bss_conf.beacon_int;\n\n\t\tscan->suspend_time = 0;\n\t\tscan->max_out_time = cpu_to_le32(200 * 1024);\n\t\tif (!interval)\n\t\t\tinterval = suspend_time;\n\t\t \n\n\t\textra = (suspend_time / interval) << 24;\n\t\tscan_suspend_time =\n\t\t    0xFF0FFFFF & (extra | ((suspend_time % interval) * 1024));\n\n\t\tscan->suspend_time = cpu_to_le32(scan_suspend_time);\n\t\tD_SCAN(\"suspend_time 0x%X beacon interval %d\\n\",\n\t\t       scan_suspend_time, interval);\n\t}\n\n\tif (il->scan_request->n_ssids) {\n\t\tint i, p = 0;\n\t\tD_SCAN(\"Kicking off active scan\\n\");\n\t\tfor (i = 0; i < il->scan_request->n_ssids; i++) {\n\t\t\t \n\t\t\tif (!il->scan_request->ssids[i].ssid_len)\n\t\t\t\tcontinue;\n\t\t\tscan->direct_scan[p].id = WLAN_EID_SSID;\n\t\t\tscan->direct_scan[p].len =\n\t\t\t    il->scan_request->ssids[i].ssid_len;\n\t\t\tmemcpy(scan->direct_scan[p].ssid,\n\t\t\t       il->scan_request->ssids[i].ssid,\n\t\t\t       il->scan_request->ssids[i].ssid_len);\n\t\t\tn_probes++;\n\t\t\tp++;\n\t\t}\n\t\tis_active = true;\n\t} else\n\t\tD_SCAN(\"Kicking off passive scan.\\n\");\n\n\t \n\tscan->tx_cmd.tx_flags = TX_CMD_FLG_SEQ_CTL_MSK;\n\tscan->tx_cmd.sta_id = il->hw_params.bcast_id;\n\tscan->tx_cmd.stop_time.life_time = TX_CMD_LIFE_TIME_INFINITE;\n\n\t \n\n\tswitch (il->scan_band) {\n\tcase NL80211_BAND_2GHZ:\n\t\tscan->flags = RXON_FLG_BAND_24G_MSK | RXON_FLG_AUTO_DETECT_MSK;\n\t\tscan->tx_cmd.rate = RATE_1M_PLCP;\n\t\tband = NL80211_BAND_2GHZ;\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\tscan->tx_cmd.rate = RATE_6M_PLCP;\n\t\tband = NL80211_BAND_5GHZ;\n\t\tbreak;\n\tdefault:\n\t\tIL_WARN(\"Invalid scan band\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tscan->good_CRC_th =\n\t    is_active ? IL_GOOD_CRC_TH_DEFAULT : IL_GOOD_CRC_TH_NEVER;\n\n\tlen =\n\t    il_fill_probe_req(il, (struct ieee80211_mgmt *)scan->data,\n\t\t\t      vif->addr, il->scan_request->ie,\n\t\t\t      il->scan_request->ie_len,\n\t\t\t      IL_MAX_SCAN_SIZE - sizeof(*scan));\n\tscan->tx_cmd.len = cpu_to_le16(len);\n\n\t \n\tscan->flags |= il3945_get_antenna_flags(il);\n\n\tscan->channel_count =\n\t    il3945_get_channels_for_scan(il, band, is_active, n_probes,\n\t\t\t\t\t (void *)&scan->data[len], vif);\n\tif (scan->channel_count == 0) {\n\t\tD_SCAN(\"channel count %d\\n\", scan->channel_count);\n\t\treturn -EIO;\n\t}\n\n\tcmd.len +=\n\t    le16_to_cpu(scan->tx_cmd.len) +\n\t    scan->channel_count * sizeof(struct il3945_scan_channel);\n\tcmd.data = scan;\n\tscan->len = cpu_to_le16(cmd.len);\n\n\tset_bit(S_SCAN_HW, &il->status);\n\tret = il_send_cmd_sync(il, &cmd);\n\tif (ret)\n\t\tclear_bit(S_SCAN_HW, &il->status);\n\treturn ret;\n}\n\nvoid\nil3945_post_scan(struct il_priv *il)\n{\n\t \n\tif (memcmp(&il->staging, &il->active, sizeof(il->staging)))\n\t\til3945_commit_rxon(il);\n}\n\nstatic void\nil3945_bg_restart(struct work_struct *data)\n{\n\tstruct il_priv *il = container_of(data, struct il_priv, restart);\n\n\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\treturn;\n\n\tif (test_and_clear_bit(S_FW_ERROR, &il->status)) {\n\t\tmutex_lock(&il->mutex);\n\t\til->is_open = 0;\n\t\tmutex_unlock(&il->mutex);\n\t\til3945_down(il);\n\t\tieee80211_restart_hw(il->hw);\n\t} else {\n\t\til3945_down(il);\n\n\t\tmutex_lock(&il->mutex);\n\t\tif (test_bit(S_EXIT_PENDING, &il->status)) {\n\t\t\tmutex_unlock(&il->mutex);\n\t\t\treturn;\n\t\t}\n\n\t\t__il3945_up(il);\n\t\tmutex_unlock(&il->mutex);\n\t}\n}\n\nstatic void\nil3945_bg_rx_replenish(struct work_struct *data)\n{\n\tstruct il_priv *il = container_of(data, struct il_priv, rx_replenish);\n\n\tmutex_lock(&il->mutex);\n\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\tgoto out;\n\n\til3945_rx_replenish(il);\nout:\n\tmutex_unlock(&il->mutex);\n}\n\nvoid\nil3945_post_associate(struct il_priv *il)\n{\n\tint rc = 0;\n\n\tif (!il->vif || !il->is_open)\n\t\treturn;\n\n\tD_ASSOC(\"Associated as %d to: %pM\\n\", il->vif->cfg.aid,\n\t\til->active.bssid_addr);\n\n\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\treturn;\n\n\til_scan_cancel_timeout(il, 200);\n\n\til->staging.filter_flags &= ~RXON_FILTER_ASSOC_MSK;\n\til3945_commit_rxon(il);\n\n\trc = il_send_rxon_timing(il);\n\tif (rc)\n\t\tIL_WARN(\"C_RXON_TIMING failed - \" \"Attempting to continue.\\n\");\n\n\til->staging.filter_flags |= RXON_FILTER_ASSOC_MSK;\n\n\til->staging.assoc_id = cpu_to_le16(il->vif->cfg.aid);\n\n\tD_ASSOC(\"assoc id %d beacon interval %d\\n\", il->vif->cfg.aid,\n\t\til->vif->bss_conf.beacon_int);\n\n\tif (il->vif->bss_conf.use_short_preamble)\n\t\til->staging.flags |= RXON_FLG_SHORT_PREAMBLE_MSK;\n\telse\n\t\til->staging.flags &= ~RXON_FLG_SHORT_PREAMBLE_MSK;\n\n\tif (il->staging.flags & RXON_FLG_BAND_24G_MSK) {\n\t\tif (il->vif->bss_conf.use_short_slot)\n\t\t\til->staging.flags |= RXON_FLG_SHORT_SLOT_MSK;\n\t\telse\n\t\t\til->staging.flags &= ~RXON_FLG_SHORT_SLOT_MSK;\n\t}\n\n\til3945_commit_rxon(il);\n\n\tswitch (il->vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\til3945_rate_scale_init(il->hw, IL_AP_ID);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\til3945_send_beacon_cmd(il);\n\t\tbreak;\n\tdefault:\n\t\tIL_ERR(\"%s Should not be called in %d mode\\n\", __func__,\n\t\t      il->vif->type);\n\t\tbreak;\n\t}\n}\n\n \n\n#define UCODE_READY_TIMEOUT\t(2 * HZ)\n\nstatic int\nil3945_mac_start(struct ieee80211_hw *hw)\n{\n\tstruct il_priv *il = hw->priv;\n\tint ret;\n\n\t \n\tmutex_lock(&il->mutex);\n\tD_MAC80211(\"enter\\n\");\n\n\t \n\n\tif (!il->ucode_code.len) {\n\t\tret = il3945_read_ucode(il);\n\t\tif (ret) {\n\t\t\tIL_ERR(\"Could not read microcode: %d\\n\", ret);\n\t\t\tmutex_unlock(&il->mutex);\n\t\t\tgoto out_release_irq;\n\t\t}\n\t}\n\n\tret = __il3945_up(il);\n\n\tmutex_unlock(&il->mutex);\n\n\tif (ret)\n\t\tgoto out_release_irq;\n\n\tD_INFO(\"Start UP work.\\n\");\n\n\t \n\tret = wait_event_timeout(il->wait_command_queue,\n\t\t\t\t test_bit(S_READY, &il->status),\n\t\t\t\t UCODE_READY_TIMEOUT);\n\tif (!ret) {\n\t\tif (!test_bit(S_READY, &il->status)) {\n\t\t\tIL_ERR(\"Wait for START_ALIVE timeout after %dms.\\n\",\n\t\t\t       jiffies_to_msecs(UCODE_READY_TIMEOUT));\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto out_release_irq;\n\t\t}\n\t}\n\n\t \n\tcancel_delayed_work(&il->_3945.rfkill_poll);\n\n\til->is_open = 1;\n\tD_MAC80211(\"leave\\n\");\n\treturn 0;\n\nout_release_irq:\n\til->is_open = 0;\n\tD_MAC80211(\"leave - failed\\n\");\n\treturn ret;\n}\n\nstatic void\nil3945_mac_stop(struct ieee80211_hw *hw)\n{\n\tstruct il_priv *il = hw->priv;\n\n\tD_MAC80211(\"enter\\n\");\n\n\tif (!il->is_open) {\n\t\tD_MAC80211(\"leave - skip\\n\");\n\t\treturn;\n\t}\n\n\til->is_open = 0;\n\n\til3945_down(il);\n\n\tflush_workqueue(il->workqueue);\n\n\t \n\tqueue_delayed_work(il->workqueue, &il->_3945.rfkill_poll,\n\t\t\t   round_jiffies_relative(2 * HZ));\n\n\tD_MAC80211(\"leave\\n\");\n}\n\nstatic void\nil3945_mac_tx(struct ieee80211_hw *hw,\n\t       struct ieee80211_tx_control *control,\n\t       struct sk_buff *skb)\n{\n\tstruct il_priv *il = hw->priv;\n\n\tD_MAC80211(\"enter\\n\");\n\n\tD_TX(\"dev->xmit(%d bytes) at rate 0x%02x\\n\", skb->len,\n\t     ieee80211_get_tx_rate(hw, IEEE80211_SKB_CB(skb))->bitrate);\n\n\tif (il3945_tx_skb(il, control->sta, skb))\n\t\tdev_kfree_skb_any(skb);\n\n\tD_MAC80211(\"leave\\n\");\n}\n\nvoid\nil3945_config_ap(struct il_priv *il)\n{\n\tstruct ieee80211_vif *vif = il->vif;\n\tint rc = 0;\n\n\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\treturn;\n\n\t \n\tif (!(il_is_associated(il))) {\n\n\t\t \n\t\til->staging.filter_flags &= ~RXON_FILTER_ASSOC_MSK;\n\t\til3945_commit_rxon(il);\n\n\t\t \n\t\trc = il_send_rxon_timing(il);\n\t\tif (rc)\n\t\t\tIL_WARN(\"C_RXON_TIMING failed - \"\n\t\t\t\t\"Attempting to continue.\\n\");\n\n\t\til->staging.assoc_id = 0;\n\n\t\tif (vif->bss_conf.use_short_preamble)\n\t\t\til->staging.flags |= RXON_FLG_SHORT_PREAMBLE_MSK;\n\t\telse\n\t\t\til->staging.flags &= ~RXON_FLG_SHORT_PREAMBLE_MSK;\n\n\t\tif (il->staging.flags & RXON_FLG_BAND_24G_MSK) {\n\t\t\tif (vif->bss_conf.use_short_slot)\n\t\t\t\til->staging.flags |= RXON_FLG_SHORT_SLOT_MSK;\n\t\t\telse\n\t\t\t\til->staging.flags &= ~RXON_FLG_SHORT_SLOT_MSK;\n\t\t}\n\t\t \n\t\til->staging.filter_flags |= RXON_FILTER_ASSOC_MSK;\n\t\til3945_commit_rxon(il);\n\t}\n\til3945_send_beacon_cmd(il);\n}\n\nstatic int\nil3945_mac_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t   struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t   struct ieee80211_key_conf *key)\n{\n\tstruct il_priv *il = hw->priv;\n\tint ret = 0;\n\tu8 sta_id = IL_INVALID_STATION;\n\tu8 static_key;\n\n\tD_MAC80211(\"enter\\n\");\n\n\tif (il3945_mod_params.sw_crypto) {\n\t\tD_MAC80211(\"leave - hwcrypto disabled\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (vif->type == NL80211_IFTYPE_ADHOC &&\n\t    !(key->flags & IEEE80211_KEY_FLAG_PAIRWISE)) {\n\t\tD_MAC80211(\"leave - IBSS RSN\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tstatic_key = !il_is_associated(il);\n\n\tif (!static_key) {\n\t\tsta_id = il_sta_id_or_broadcast(il, sta);\n\t\tif (sta_id == IL_INVALID_STATION) {\n\t\t\tD_MAC80211(\"leave - station not found\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tmutex_lock(&il->mutex);\n\til_scan_cancel_timeout(il, 100);\n\n\tswitch (cmd) {\n\tcase SET_KEY:\n\t\tif (static_key)\n\t\t\tret = il3945_set_static_key(il, key);\n\t\telse\n\t\t\tret = il3945_set_dynamic_key(il, key, sta_id);\n\t\tD_MAC80211(\"enable hwcrypto key\\n\");\n\t\tbreak;\n\tcase DISABLE_KEY:\n\t\tif (static_key)\n\t\t\tret = il3945_remove_static_key(il);\n\t\telse\n\t\t\tret = il3945_clear_sta_key_info(il, sta_id);\n\t\tD_MAC80211(\"disable hwcrypto key\\n\");\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tD_MAC80211(\"leave ret %d\\n\", ret);\n\tmutex_unlock(&il->mutex);\n\n\treturn ret;\n}\n\nstatic int\nil3945_mac_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t   struct ieee80211_sta *sta)\n{\n\tstruct il_priv *il = hw->priv;\n\tstruct il3945_sta_priv *sta_priv = (void *)sta->drv_priv;\n\tint ret;\n\tbool is_ap = vif->type == NL80211_IFTYPE_STATION;\n\tu8 sta_id;\n\n\tmutex_lock(&il->mutex);\n\tD_INFO(\"station %pM\\n\", sta->addr);\n\tsta_priv->common.sta_id = IL_INVALID_STATION;\n\n\tret = il_add_station_common(il, sta->addr, is_ap, sta, &sta_id);\n\tif (ret) {\n\t\tIL_ERR(\"Unable to add station %pM (%d)\\n\", sta->addr, ret);\n\t\t \n\t\tmutex_unlock(&il->mutex);\n\t\treturn ret;\n\t}\n\n\tsta_priv->common.sta_id = sta_id;\n\n\t \n\tD_INFO(\"Initializing rate scaling for station %pM\\n\", sta->addr);\n\til3945_rs_rate_init(il, sta, sta_id);\n\tmutex_unlock(&il->mutex);\n\n\treturn 0;\n}\n\nstatic void\nil3945_configure_filter(struct ieee80211_hw *hw, unsigned int changed_flags,\n\t\t\tunsigned int *total_flags, u64 multicast)\n{\n\tstruct il_priv *il = hw->priv;\n\t__le32 filter_or = 0, filter_nand = 0;\n\n#define CHK(test, flag)\tdo { \\\n\tif (*total_flags & (test))\t\t\\\n\t\tfilter_or |= (flag);\t\t\\\n\telse\t\t\t\t\t\\\n\t\tfilter_nand |= (flag);\t\t\\\n\t} while (0)\n\n\tD_MAC80211(\"Enter: changed: 0x%x, total: 0x%x\\n\", changed_flags,\n\t\t   *total_flags);\n\n\tCHK(FIF_OTHER_BSS, RXON_FILTER_PROMISC_MSK);\n\tCHK(FIF_CONTROL, RXON_FILTER_CTL2HOST_MSK);\n\tCHK(FIF_BCN_PRBRESP_PROMISC, RXON_FILTER_BCON_AWARE_MSK);\n\n#undef CHK\n\n\tmutex_lock(&il->mutex);\n\n\til->staging.filter_flags &= ~filter_nand;\n\til->staging.filter_flags |= filter_or;\n\n\t \n\n\tmutex_unlock(&il->mutex);\n\n\t \n\t*total_flags &=\n\t    FIF_OTHER_BSS | FIF_ALLMULTI |\n\t    FIF_BCN_PRBRESP_PROMISC | FIF_CONTROL;\n}\n\n \n\n#ifdef CONFIG_IWLEGACY_DEBUG\n\n \nstatic ssize_t\nil3945_show_debug_level(struct device *d, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct il_priv *il = dev_get_drvdata(d);\n\treturn sprintf(buf, \"0x%08X\\n\", il_get_debug_level(il));\n}\n\nstatic ssize_t\nil3945_store_debug_level(struct device *d, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct il_priv *il = dev_get_drvdata(d);\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &val);\n\tif (ret)\n\t\tIL_INFO(\"%s is not in hex or decimal form.\\n\", buf);\n\telse\n\t\til->debug_level = val;\n\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(debug_level, 0644, il3945_show_debug_level,\n\t\t   il3945_store_debug_level);\n\n#endif  \n\nstatic ssize_t\nil3945_show_temperature(struct device *d, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct il_priv *il = dev_get_drvdata(d);\n\n\tif (!il_is_alive(il))\n\t\treturn -EAGAIN;\n\n\treturn sprintf(buf, \"%d\\n\", il3945_hw_get_temperature(il));\n}\n\nstatic DEVICE_ATTR(temperature, 0444, il3945_show_temperature, NULL);\n\nstatic ssize_t\nil3945_show_tx_power(struct device *d, struct device_attribute *attr, char *buf)\n{\n\tstruct il_priv *il = dev_get_drvdata(d);\n\treturn sprintf(buf, \"%d\\n\", il->tx_power_user_lmt);\n}\n\nstatic ssize_t\nil3945_store_tx_power(struct device *d, struct device_attribute *attr,\n\t\t      const char *buf, size_t count)\n{\n\tstruct il_priv *il = dev_get_drvdata(d);\n\tchar *p = (char *)buf;\n\tu32 val;\n\n\tval = simple_strtoul(p, &p, 10);\n\tif (p == buf)\n\t\tIL_INFO(\": %s is not in decimal form.\\n\", buf);\n\telse\n\t\til3945_hw_reg_set_txpower(il, val);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(tx_power, 0644, il3945_show_tx_power, il3945_store_tx_power);\n\nstatic ssize_t\nil3945_show_flags(struct device *d, struct device_attribute *attr, char *buf)\n{\n\tstruct il_priv *il = dev_get_drvdata(d);\n\n\treturn sprintf(buf, \"0x%04X\\n\", il->active.flags);\n}\n\nstatic ssize_t\nil3945_store_flags(struct device *d, struct device_attribute *attr,\n\t\t   const char *buf, size_t count)\n{\n\tstruct il_priv *il = dev_get_drvdata(d);\n\tu32 flags = simple_strtoul(buf, NULL, 0);\n\n\tmutex_lock(&il->mutex);\n\tif (le32_to_cpu(il->staging.flags) != flags) {\n\t\t \n\t\tif (il_scan_cancel_timeout(il, 100))\n\t\t\tIL_WARN(\"Could not cancel scan.\\n\");\n\t\telse {\n\t\t\tD_INFO(\"Committing rxon.flags = 0x%04X\\n\", flags);\n\t\t\til->staging.flags = cpu_to_le32(flags);\n\t\t\til3945_commit_rxon(il);\n\t\t}\n\t}\n\tmutex_unlock(&il->mutex);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(flags, 0644, il3945_show_flags, il3945_store_flags);\n\nstatic ssize_t\nil3945_show_filter_flags(struct device *d, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct il_priv *il = dev_get_drvdata(d);\n\n\treturn sprintf(buf, \"0x%04X\\n\", le32_to_cpu(il->active.filter_flags));\n}\n\nstatic ssize_t\nil3945_store_filter_flags(struct device *d, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct il_priv *il = dev_get_drvdata(d);\n\tu32 filter_flags = simple_strtoul(buf, NULL, 0);\n\n\tmutex_lock(&il->mutex);\n\tif (le32_to_cpu(il->staging.filter_flags) != filter_flags) {\n\t\t \n\t\tif (il_scan_cancel_timeout(il, 100))\n\t\t\tIL_WARN(\"Could not cancel scan.\\n\");\n\t\telse {\n\t\t\tD_INFO(\"Committing rxon.filter_flags = \" \"0x%04X\\n\",\n\t\t\t       filter_flags);\n\t\t\til->staging.filter_flags = cpu_to_le32(filter_flags);\n\t\t\til3945_commit_rxon(il);\n\t\t}\n\t}\n\tmutex_unlock(&il->mutex);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(filter_flags, 0644, il3945_show_filter_flags,\n\t\t   il3945_store_filter_flags);\n\nstatic ssize_t\nil3945_show_measurement(struct device *d, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct il_priv *il = dev_get_drvdata(d);\n\tstruct il_spectrum_notification measure_report;\n\tu32 size = sizeof(measure_report), len = 0, ofs = 0;\n\tu8 *data = (u8 *) &measure_report;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&il->lock, flags);\n\tif (!(il->measurement_status & MEASUREMENT_READY)) {\n\t\tspin_unlock_irqrestore(&il->lock, flags);\n\t\treturn 0;\n\t}\n\tmemcpy(&measure_report, &il->measure_report, size);\n\til->measurement_status = 0;\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\twhile (size && PAGE_SIZE - len) {\n\t\thex_dump_to_buffer(data + ofs, size, 16, 1, buf + len,\n\t\t\t\t   PAGE_SIZE - len, true);\n\t\tlen = strlen(buf);\n\t\tif (PAGE_SIZE - len)\n\t\t\tbuf[len++] = '\\n';\n\n\t\tofs += 16;\n\t\tsize -= min(size, 16U);\n\t}\n\n\treturn len;\n}\n\nstatic ssize_t\nil3945_store_measurement(struct device *d, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct il_priv *il = dev_get_drvdata(d);\n\tstruct ieee80211_measurement_params params = {\n\t\t.channel = le16_to_cpu(il->active.channel),\n\t\t.start_time = cpu_to_le64(il->_3945.last_tsf),\n\t\t.duration = cpu_to_le16(1),\n\t};\n\tu8 type = IL_MEASURE_BASIC;\n\tu8 buffer[32];\n\tu8 channel;\n\n\tif (count) {\n\t\tchar *p = buffer;\n\t\tstrscpy(buffer, buf, sizeof(buffer));\n\t\tchannel = simple_strtoul(p, NULL, 0);\n\t\tif (channel)\n\t\t\tparams.channel = channel;\n\n\t\tp = buffer;\n\t\twhile (*p && *p != ' ')\n\t\t\tp++;\n\t\tif (*p)\n\t\t\ttype = simple_strtoul(p + 1, NULL, 0);\n\t}\n\n\tD_INFO(\"Invoking measurement of type %d on \" \"channel %d (for '%s')\\n\",\n\t       type, params.channel, buf);\n\til3945_get_measurement(il, &params, type);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(measurement, 0600, il3945_show_measurement,\n\t\t   il3945_store_measurement);\n\nstatic ssize_t\nil3945_store_retry_rate(struct device *d, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct il_priv *il = dev_get_drvdata(d);\n\n\til->retry_rate = simple_strtoul(buf, NULL, 0);\n\tif (il->retry_rate <= 0)\n\t\til->retry_rate = 1;\n\n\treturn count;\n}\n\nstatic ssize_t\nil3945_show_retry_rate(struct device *d, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tstruct il_priv *il = dev_get_drvdata(d);\n\treturn sprintf(buf, \"%d\", il->retry_rate);\n}\n\nstatic DEVICE_ATTR(retry_rate, 0600, il3945_show_retry_rate,\n\t\t   il3945_store_retry_rate);\n\nstatic ssize_t\nil3945_show_channels(struct device *d, struct device_attribute *attr, char *buf)\n{\n\t \n\treturn 0;\n}\n\nstatic DEVICE_ATTR(channels, 0400, il3945_show_channels, NULL);\n\nstatic ssize_t\nil3945_show_antenna(struct device *d, struct device_attribute *attr, char *buf)\n{\n\tstruct il_priv *il = dev_get_drvdata(d);\n\n\tif (!il_is_alive(il))\n\t\treturn -EAGAIN;\n\n\treturn sprintf(buf, \"%d\\n\", il3945_mod_params.antenna);\n}\n\nstatic ssize_t\nil3945_store_antenna(struct device *d, struct device_attribute *attr,\n\t\t     const char *buf, size_t count)\n{\n\tstruct il_priv *il __maybe_unused = dev_get_drvdata(d);\n\tint ant;\n\n\tif (count == 0)\n\t\treturn 0;\n\n\tif (sscanf(buf, \"%1i\", &ant) != 1) {\n\t\tD_INFO(\"not in hex or decimal form.\\n\");\n\t\treturn count;\n\t}\n\n\tif (ant >= 0 && ant <= 2) {\n\t\tD_INFO(\"Setting antenna select to %d.\\n\", ant);\n\t\til3945_mod_params.antenna = (enum il3945_antenna)ant;\n\t} else\n\t\tD_INFO(\"Bad antenna select value %d.\\n\", ant);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(antenna, 0644, il3945_show_antenna, il3945_store_antenna);\n\nstatic ssize_t\nil3945_show_status(struct device *d, struct device_attribute *attr, char *buf)\n{\n\tstruct il_priv *il = dev_get_drvdata(d);\n\tif (!il_is_alive(il))\n\t\treturn -EAGAIN;\n\treturn sprintf(buf, \"0x%08x\\n\", (int)il->status);\n}\n\nstatic DEVICE_ATTR(status, 0444, il3945_show_status, NULL);\n\nstatic ssize_t\nil3945_dump_error_log(struct device *d, struct device_attribute *attr,\n\t\t      const char *buf, size_t count)\n{\n\tstruct il_priv *il = dev_get_drvdata(d);\n\tchar *p = (char *)buf;\n\n\tif (p[0] == '1')\n\t\til3945_dump_nic_error_log(il);\n\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(dump_errors, 0200, NULL, il3945_dump_error_log);\n\n \n\nstatic int\nil3945_setup_deferred_work(struct il_priv *il)\n{\n\til->workqueue = create_singlethread_workqueue(DRV_NAME);\n\tif (!il->workqueue)\n\t\treturn -ENOMEM;\n\n\tinit_waitqueue_head(&il->wait_command_queue);\n\n\tINIT_WORK(&il->restart, il3945_bg_restart);\n\tINIT_WORK(&il->rx_replenish, il3945_bg_rx_replenish);\n\tINIT_DELAYED_WORK(&il->init_alive_start, il3945_bg_init_alive_start);\n\tINIT_DELAYED_WORK(&il->alive_start, il3945_bg_alive_start);\n\tINIT_DELAYED_WORK(&il->_3945.rfkill_poll, il3945_rfkill_poll);\n\n\til_setup_scan_deferred_work(il);\n\n\til3945_hw_setup_deferred_work(il);\n\n\ttimer_setup(&il->watchdog, il_bg_watchdog, 0);\n\n\ttasklet_setup(&il->irq_tasklet, il3945_irq_tasklet);\n\n\treturn 0;\n}\n\nstatic void\nil3945_cancel_deferred_work(struct il_priv *il)\n{\n\til3945_hw_cancel_deferred_work(il);\n\n\tcancel_delayed_work_sync(&il->init_alive_start);\n\tcancel_delayed_work(&il->alive_start);\n\n\til_cancel_scan_deferred_work(il);\n}\n\nstatic struct attribute *il3945_sysfs_entries[] = {\n\t&dev_attr_antenna.attr,\n\t&dev_attr_channels.attr,\n\t&dev_attr_dump_errors.attr,\n\t&dev_attr_flags.attr,\n\t&dev_attr_filter_flags.attr,\n\t&dev_attr_measurement.attr,\n\t&dev_attr_retry_rate.attr,\n\t&dev_attr_status.attr,\n\t&dev_attr_temperature.attr,\n\t&dev_attr_tx_power.attr,\n#ifdef CONFIG_IWLEGACY_DEBUG\n\t&dev_attr_debug_level.attr,\n#endif\n\tNULL\n};\n\nstatic const struct attribute_group il3945_attribute_group = {\n\t.name = NULL,\t\t \n\t.attrs = il3945_sysfs_entries,\n};\n\nstatic struct ieee80211_ops il3945_mac_ops __ro_after_init = {\n\t.tx = il3945_mac_tx,\n\t.wake_tx_queue = ieee80211_handle_wake_tx_queue,\n\t.start = il3945_mac_start,\n\t.stop = il3945_mac_stop,\n\t.add_interface = il_mac_add_interface,\n\t.remove_interface = il_mac_remove_interface,\n\t.change_interface = il_mac_change_interface,\n\t.config = il_mac_config,\n\t.configure_filter = il3945_configure_filter,\n\t.set_key = il3945_mac_set_key,\n\t.conf_tx = il_mac_conf_tx,\n\t.reset_tsf = il_mac_reset_tsf,\n\t.bss_info_changed = il_mac_bss_info_changed,\n\t.hw_scan = il_mac_hw_scan,\n\t.sta_add = il3945_mac_sta_add,\n\t.sta_remove = il_mac_sta_remove,\n\t.tx_last_beacon = il_mac_tx_last_beacon,\n\t.flush = il_mac_flush,\n};\n\nstatic int\nil3945_init_drv(struct il_priv *il)\n{\n\tint ret;\n\tstruct il3945_eeprom *eeprom = (struct il3945_eeprom *)il->eeprom;\n\n\til->retry_rate = 1;\n\til->beacon_skb = NULL;\n\n\tspin_lock_init(&il->sta_lock);\n\tspin_lock_init(&il->hcmd_lock);\n\n\tINIT_LIST_HEAD(&il->free_frames);\n\n\tmutex_init(&il->mutex);\n\n\til->ieee_channels = NULL;\n\til->ieee_rates = NULL;\n\til->band = NL80211_BAND_2GHZ;\n\n\til->iw_mode = NL80211_IFTYPE_STATION;\n\til->missed_beacon_threshold = IL_MISSED_BEACON_THRESHOLD_DEF;\n\n\t \n\til->force_reset.reset_duration = IL_DELAY_NEXT_FORCE_FW_RELOAD;\n\n\tif (eeprom->version < EEPROM_3945_EEPROM_VERSION) {\n\t\tIL_WARN(\"Unsupported EEPROM version: 0x%04X\\n\",\n\t\t\teeprom->version);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tret = il_init_channel_map(il);\n\tif (ret) {\n\t\tIL_ERR(\"initializing regulatory failed: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\t \n\tif (il3945_txpower_set_from_eeprom(il)) {\n\t\tret = -EIO;\n\t\tgoto err_free_channel_map;\n\t}\n\n\tret = il_init_geos(il);\n\tif (ret) {\n\t\tIL_ERR(\"initializing geos failed: %d\\n\", ret);\n\t\tgoto err_free_channel_map;\n\t}\n\til3945_init_hw_rates(il, il->ieee_rates);\n\n\treturn 0;\n\nerr_free_channel_map:\n\til_free_channel_map(il);\nerr:\n\treturn ret;\n}\n\n#define IL3945_MAX_PROBE_REQUEST\t200\n\nstatic int\nil3945_setup_mac(struct il_priv *il)\n{\n\tint ret;\n\tstruct ieee80211_hw *hw = il->hw;\n\n\thw->rate_control_algorithm = \"iwl-3945-rs\";\n\thw->sta_data_size = sizeof(struct il3945_sta_priv);\n\thw->vif_data_size = sizeof(struct il_vif_priv);\n\n\t \n\tieee80211_hw_set(hw, SUPPORTS_DYNAMIC_PS);\n\tieee80211_hw_set(hw, SUPPORTS_PS);\n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\tieee80211_hw_set(hw, SPECTRUM_MGMT);\n\n\thw->wiphy->interface_modes =\n\t    BIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_ADHOC);\n\n\thw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;\n\thw->wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG |\n\t\t\t\t       REGULATORY_DISABLE_BEACON_HINTS;\n\n\thw->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;\n\n\thw->wiphy->max_scan_ssids = PROBE_OPTION_MAX_3945;\n\t \n\thw->wiphy->max_scan_ie_len = IL3945_MAX_PROBE_REQUEST - 24 - 2;\n\n\t \n\thw->queues = 4;\n\n\tif (il->bands[NL80211_BAND_2GHZ].n_channels)\n\t\til->hw->wiphy->bands[NL80211_BAND_2GHZ] =\n\t\t    &il->bands[NL80211_BAND_2GHZ];\n\n\tif (il->bands[NL80211_BAND_5GHZ].n_channels)\n\t\til->hw->wiphy->bands[NL80211_BAND_5GHZ] =\n\t\t    &il->bands[NL80211_BAND_5GHZ];\n\n\til_leds_init(il);\n\n\twiphy_ext_feature_set(il->hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\tret = ieee80211_register_hw(il->hw);\n\tif (ret) {\n\t\tIL_ERR(\"Failed to register hw (error %d)\\n\", ret);\n\t\treturn ret;\n\t}\n\til->mac80211_registered = 1;\n\n\treturn 0;\n}\n\nstatic int\nil3945_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint err = 0;\n\tstruct il_priv *il;\n\tstruct ieee80211_hw *hw;\n\tstruct il_cfg *cfg = (struct il_cfg *)(ent->driver_data);\n\tstruct il3945_eeprom *eeprom;\n\tunsigned long flags;\n\n\t \n\n\thw = ieee80211_alloc_hw(sizeof(struct il_priv), &il3945_mac_ops);\n\tif (!hw) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\til = hw->priv;\n\til->hw = hw;\n\tSET_IEEE80211_DEV(hw, &pdev->dev);\n\n\til->cmd_queue = IL39_CMD_QUEUE_NUM;\n\n\tD_INFO(\"*** LOAD DRIVER ***\\n\");\n\til->cfg = cfg;\n\til->ops = &il3945_ops;\n#ifdef CONFIG_IWLEGACY_DEBUGFS\n\til->debugfs_ops = &il3945_debugfs_ops;\n#endif\n\til->pci_dev = pdev;\n\til->inta_mask = CSR_INI_SET_MASK;\n\n\t \n\tpci_disable_link_state(pdev,\n\t\t\t       PCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1 |\n\t\t\t       PCIE_LINK_STATE_CLKPM);\n\n\tif (pci_enable_device(pdev)) {\n\t\terr = -ENODEV;\n\t\tgoto out_ieee80211_free_hw;\n\t}\n\n\tpci_set_master(pdev);\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (err) {\n\t\tIL_WARN(\"No suitable DMA available.\\n\");\n\t\tgoto out_pci_disable_device;\n\t}\n\n\tpci_set_drvdata(pdev, il);\n\terr = pci_request_regions(pdev, DRV_NAME);\n\tif (err)\n\t\tgoto out_pci_disable_device;\n\n\t \n\til->hw_base = pci_ioremap_bar(pdev, 0);\n\tif (!il->hw_base) {\n\t\terr = -ENODEV;\n\t\tgoto out_pci_release_regions;\n\t}\n\n\tD_INFO(\"pci_resource_len = 0x%08llx\\n\",\n\t       (unsigned long long)pci_resource_len(pdev, 0));\n\tD_INFO(\"pci_resource_base = %p\\n\", il->hw_base);\n\n\t \n\tpci_write_config_byte(pdev, 0x41, 0x00);\n\n\t \n\tspin_lock_init(&il->reg_lock);\n\tspin_lock_init(&il->lock);\n\n\t \n\t_il_wr(il, CSR_RESET, CSR_RESET_REG_FLAG_NEVO_RESET);\n\n\t \n\n\t \n\terr = il_eeprom_init(il);\n\tif (err) {\n\t\tIL_ERR(\"Unable to init EEPROM\\n\");\n\t\tgoto out_iounmap;\n\t}\n\t \n\teeprom = (struct il3945_eeprom *)il->eeprom;\n\tD_INFO(\"MAC address: %pM\\n\", eeprom->mac_address);\n\tSET_IEEE80211_PERM_ADDR(il->hw, eeprom->mac_address);\n\n\t \n\t \n\terr = il3945_hw_set_hw_params(il);\n\tif (err) {\n\t\tIL_ERR(\"failed to set hw settings\\n\");\n\t\tgoto out_eeprom_free;\n\t}\n\n\t \n\n\terr = il3945_init_drv(il);\n\tif (err) {\n\t\tIL_ERR(\"initializing driver failed\\n\");\n\t\tgoto out_unset_hw_params;\n\t}\n\n\tIL_INFO(\"Detected Intel Wireless WiFi Link %s\\n\", il->cfg->name);\n\n\t \n\n\tspin_lock_irqsave(&il->lock, flags);\n\til_disable_interrupts(il);\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\tpci_enable_msi(il->pci_dev);\n\n\terr = request_irq(il->pci_dev->irq, il_isr, IRQF_SHARED, DRV_NAME, il);\n\tif (err) {\n\t\tIL_ERR(\"Error allocating IRQ %d\\n\", il->pci_dev->irq);\n\t\tgoto out_disable_msi;\n\t}\n\n\terr = sysfs_create_group(&pdev->dev.kobj, &il3945_attribute_group);\n\tif (err) {\n\t\tIL_ERR(\"failed to create sysfs device attributes\\n\");\n\t\tgoto out_release_irq;\n\t}\n\n\til_set_rxon_channel(il, &il->bands[NL80211_BAND_2GHZ].channels[5]);\n\terr = il3945_setup_deferred_work(il);\n\tif (err)\n\t\tgoto out_remove_sysfs;\n\n\til3945_setup_handlers(il);\n\til_power_initialize(il);\n\n\t \n\n\til_enable_interrupts(il);\n\n\terr = il3945_setup_mac(il);\n\tif (err)\n\t\tgoto out_destroy_workqueue;\n\n\til_dbgfs_register(il, DRV_NAME);\n\n\t \n\tqueue_delayed_work(il->workqueue, &il->_3945.rfkill_poll, 2 * HZ);\n\n\treturn 0;\n\nout_destroy_workqueue:\n\tdestroy_workqueue(il->workqueue);\n\til->workqueue = NULL;\nout_remove_sysfs:\n\tsysfs_remove_group(&pdev->dev.kobj, &il3945_attribute_group);\nout_release_irq:\n\tfree_irq(il->pci_dev->irq, il);\nout_disable_msi:\n\tpci_disable_msi(il->pci_dev);\n\til_free_geos(il);\n\til_free_channel_map(il);\nout_unset_hw_params:\n\til3945_unset_hw_params(il);\nout_eeprom_free:\n\til_eeprom_free(il);\nout_iounmap:\n\tiounmap(il->hw_base);\nout_pci_release_regions:\n\tpci_release_regions(pdev);\nout_pci_disable_device:\n\tpci_disable_device(pdev);\nout_ieee80211_free_hw:\n\tieee80211_free_hw(il->hw);\nout:\n\treturn err;\n}\n\nstatic void\nil3945_pci_remove(struct pci_dev *pdev)\n{\n\tstruct il_priv *il = pci_get_drvdata(pdev);\n\tunsigned long flags;\n\n\tif (!il)\n\t\treturn;\n\n\tD_INFO(\"*** UNLOAD DRIVER ***\\n\");\n\n\til_dbgfs_unregister(il);\n\n\tset_bit(S_EXIT_PENDING, &il->status);\n\n\til_leds_exit(il);\n\n\tif (il->mac80211_registered) {\n\t\tieee80211_unregister_hw(il->hw);\n\t\til->mac80211_registered = 0;\n\t} else {\n\t\til3945_down(il);\n\t}\n\n\t \n\til_apm_stop(il);\n\n\t \n\tspin_lock_irqsave(&il->lock, flags);\n\til_disable_interrupts(il);\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\til3945_synchronize_irq(il);\n\n\tsysfs_remove_group(&pdev->dev.kobj, &il3945_attribute_group);\n\n\tcancel_delayed_work_sync(&il->_3945.rfkill_poll);\n\n\til3945_dealloc_ucode_pci(il);\n\n\tif (il->rxq.bd)\n\t\til3945_rx_queue_free(il, &il->rxq);\n\til3945_hw_txq_ctx_free(il);\n\n\til3945_unset_hw_params(il);\n\n\t \n\n\t \n\tdestroy_workqueue(il->workqueue);\n\til->workqueue = NULL;\n\n\tfree_irq(pdev->irq, il);\n\tpci_disable_msi(pdev);\n\n\tiounmap(il->hw_base);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\n\til_free_channel_map(il);\n\til_free_geos(il);\n\tkfree(il->scan_cmd);\n\tdev_kfree_skb(il->beacon_skb);\n\tieee80211_free_hw(il->hw);\n}\n\n \n\nstatic struct pci_driver il3945_driver = {\n\t.name = DRV_NAME,\n\t.id_table = il3945_hw_card_ids,\n\t.probe = il3945_pci_probe,\n\t.remove = il3945_pci_remove,\n\t.driver.pm = IL_LEGACY_PM_OPS,\n};\n\nstatic int __init\nil3945_init(void)\n{\n\n\tint ret;\n\tpr_info(DRV_DESCRIPTION \", \" DRV_VERSION \"\\n\");\n\tpr_info(DRV_COPYRIGHT \"\\n\");\n\n\t \n\tif (il3945_mod_params.disable_hw_scan) {\n\t\tpr_info(\"hw_scan is disabled\\n\");\n\t\til3945_mac_ops.hw_scan = NULL;\n\t}\n\n\tret = il3945_rate_control_register();\n\tif (ret) {\n\t\tpr_err(\"Unable to register rate control algorithm: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = pci_register_driver(&il3945_driver);\n\tif (ret) {\n\t\tpr_err(\"Unable to initialize PCI module\\n\");\n\t\tgoto error_register;\n\t}\n\n\treturn ret;\n\nerror_register:\n\til3945_rate_control_unregister();\n\treturn ret;\n}\n\nstatic void __exit\nil3945_exit(void)\n{\n\tpci_unregister_driver(&il3945_driver);\n\til3945_rate_control_unregister();\n}\n\nMODULE_FIRMWARE(IL3945_MODULE_FIRMWARE(IL3945_UCODE_API_MAX));\n\nmodule_param_named(antenna, il3945_mod_params.antenna, int, 0444);\nMODULE_PARM_DESC(antenna, \"select antenna (1=Main, 2=Aux, default 0 [both])\");\nmodule_param_named(swcrypto, il3945_mod_params.sw_crypto, int, 0444);\nMODULE_PARM_DESC(swcrypto, \"using software crypto (default 1 [software])\");\nmodule_param_named(disable_hw_scan, il3945_mod_params.disable_hw_scan, int,\n\t\t   0444);\nMODULE_PARM_DESC(disable_hw_scan, \"disable hardware scanning (default 1)\");\n#ifdef CONFIG_IWLEGACY_DEBUG\nmodule_param_named(debug, il_debug_level, uint, 0644);\nMODULE_PARM_DESC(debug, \"debug output mask\");\n#endif\nmodule_param_named(fw_restart, il3945_mod_params.restart_fw, int, 0444);\nMODULE_PARM_DESC(fw_restart, \"restart firmware in case of error\");\n\nmodule_exit(il3945_exit);\nmodule_init(il3945_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}