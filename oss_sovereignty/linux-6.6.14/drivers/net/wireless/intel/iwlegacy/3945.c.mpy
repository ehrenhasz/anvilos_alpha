{
  "module_name": "3945.c",
  "hash_id": "4400200e7bc62b05ef7efa6afcfac045a84b56d1abac1cb427196aa4fcbf161b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlegacy/3945.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/firmware.h>\n#include <linux/etherdevice.h>\n#include <asm/unaligned.h>\n#include <net/mac80211.h>\n\n#include \"common.h\"\n#include \"3945.h\"\n\n \nstatic int\nil3945_send_led_cmd(struct il_priv *il, struct il_led_cmd *led_cmd)\n{\n\tstruct il_host_cmd cmd = {\n\t\t.id = C_LEDS,\n\t\t.len = sizeof(struct il_led_cmd),\n\t\t.data = led_cmd,\n\t\t.flags = CMD_ASYNC,\n\t\t.callback = NULL,\n\t};\n\n\treturn il_send_cmd(il, &cmd);\n}\n\n#define IL_DECLARE_RATE_INFO(r, ip, in, rp, rn, pp, np)    \\\n\t[RATE_##r##M_IDX] = { RATE_##r##M_PLCP,   \\\n\t\t\t\t    RATE_##r##M_IEEE,   \\\n\t\t\t\t    RATE_##ip##M_IDX, \\\n\t\t\t\t    RATE_##in##M_IDX, \\\n\t\t\t\t    RATE_##rp##M_IDX, \\\n\t\t\t\t    RATE_##rn##M_IDX, \\\n\t\t\t\t    RATE_##pp##M_IDX, \\\n\t\t\t\t    RATE_##np##M_IDX, \\\n\t\t\t\t    RATE_##r##M_IDX_TBL, \\\n\t\t\t\t    RATE_##ip##M_IDX_TBL }\n\n \nconst struct il3945_rate_info il3945_rates[RATE_COUNT_3945] = {\n\tIL_DECLARE_RATE_INFO(1, INV, 2, INV, 2, INV, 2),\t \n\tIL_DECLARE_RATE_INFO(2, 1, 5, 1, 5, 1, 5),\t \n\tIL_DECLARE_RATE_INFO(5, 2, 6, 2, 11, 2, 11),\t \n\tIL_DECLARE_RATE_INFO(11, 9, 12, 5, 12, 5, 18),\t \n\tIL_DECLARE_RATE_INFO(6, 5, 9, 5, 11, 5, 11),\t \n\tIL_DECLARE_RATE_INFO(9, 6, 11, 5, 11, 5, 11),\t \n\tIL_DECLARE_RATE_INFO(12, 11, 18, 11, 18, 11, 18),\t \n\tIL_DECLARE_RATE_INFO(18, 12, 24, 12, 24, 11, 24),\t \n\tIL_DECLARE_RATE_INFO(24, 18, 36, 18, 36, 18, 36),\t \n\tIL_DECLARE_RATE_INFO(36, 24, 48, 24, 48, 24, 48),\t \n\tIL_DECLARE_RATE_INFO(48, 36, 54, 36, 54, 36, 54),\t \n\tIL_DECLARE_RATE_INFO(54, 48, INV, 48, INV, 48, INV),\t \n};\n\nstatic inline u8\nil3945_get_prev_ieee_rate(u8 rate_idx)\n{\n\tu8 rate = il3945_rates[rate_idx].prev_ieee;\n\n\tif (rate == RATE_INVALID)\n\t\trate = rate_idx;\n\treturn rate;\n}\n\n \n#define IL_EVT_DISABLE (0)\n#define IL_EVT_DISABLE_SIZE (1532/32)\n\n \nvoid\nil3945_disable_events(struct il_priv *il)\n{\n\tint i;\n\tu32 base;\t\t \n\tu32 disable_ptr;\t \n\tu32 array_size;\t\t \n\tstatic const u32 evt_disable[IL_EVT_DISABLE_SIZE] = {\n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t\t0x00000000,\t \n\t};\n\n\tbase = le32_to_cpu(il->card_alive.log_event_table_ptr);\n\tif (!il3945_hw_valid_rtc_data_addr(base)) {\n\t\tIL_ERR(\"Invalid event log pointer 0x%08X\\n\", base);\n\t\treturn;\n\t}\n\n\tdisable_ptr = il_read_targ_mem(il, base + (4 * sizeof(u32)));\n\tarray_size = il_read_targ_mem(il, base + (5 * sizeof(u32)));\n\n\tif (IL_EVT_DISABLE && array_size == IL_EVT_DISABLE_SIZE) {\n\t\tD_INFO(\"Disabling selected uCode log events at 0x%x\\n\",\n\t\t       disable_ptr);\n\t\tfor (i = 0; i < IL_EVT_DISABLE_SIZE; i++)\n\t\t\til_write_targ_mem(il, disable_ptr + (i * sizeof(u32)),\n\t\t\t\t\t  evt_disable[i]);\n\n\t} else {\n\t\tD_INFO(\"Selected uCode log events may be disabled\\n\");\n\t\tD_INFO(\"  by writing \\\"1\\\"s into disable bitmap\\n\");\n\t\tD_INFO(\"  in SRAM at 0x%x, size %d u32s\\n\", disable_ptr,\n\t\t       array_size);\n\t}\n\n}\n\nstatic int\nil3945_hwrate_to_plcp_idx(u8 plcp)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < RATE_COUNT_3945; idx++)\n\t\tif (il3945_rates[idx].plcp == plcp)\n\t\t\treturn idx;\n\treturn -1;\n}\n\n#ifdef CONFIG_IWLEGACY_DEBUG\n#define TX_STATUS_ENTRY(x) case TX_3945_STATUS_FAIL_ ## x: return #x\n\nstatic const char *\nil3945_get_tx_fail_reason(u32 status)\n{\n\tswitch (status & TX_STATUS_MSK) {\n\tcase TX_3945_STATUS_SUCCESS:\n\t\treturn \"SUCCESS\";\n\t\tTX_STATUS_ENTRY(SHORT_LIMIT);\n\t\tTX_STATUS_ENTRY(LONG_LIMIT);\n\t\tTX_STATUS_ENTRY(FIFO_UNDERRUN);\n\t\tTX_STATUS_ENTRY(MGMNT_ABORT);\n\t\tTX_STATUS_ENTRY(NEXT_FRAG);\n\t\tTX_STATUS_ENTRY(LIFE_EXPIRE);\n\t\tTX_STATUS_ENTRY(DEST_PS);\n\t\tTX_STATUS_ENTRY(ABORTED);\n\t\tTX_STATUS_ENTRY(BT_RETRY);\n\t\tTX_STATUS_ENTRY(STA_INVALID);\n\t\tTX_STATUS_ENTRY(FRAG_DROPPED);\n\t\tTX_STATUS_ENTRY(TID_DISABLE);\n\t\tTX_STATUS_ENTRY(FRAME_FLUSHED);\n\t\tTX_STATUS_ENTRY(INSUFFICIENT_CF_POLL);\n\t\tTX_STATUS_ENTRY(TX_LOCKED);\n\t\tTX_STATUS_ENTRY(NO_BEACON_ON_RADAR);\n\t}\n\n\treturn \"UNKNOWN\";\n}\n#else\nstatic inline const char *\nil3945_get_tx_fail_reason(u32 status)\n{\n\treturn \"\";\n}\n#endif\n\n \nint\nil3945_rs_next_rate(struct il_priv *il, int rate)\n{\n\tint next_rate = il3945_get_prev_ieee_rate(rate);\n\n\tswitch (il->band) {\n\tcase NL80211_BAND_5GHZ:\n\t\tif (rate == RATE_12M_IDX)\n\t\t\tnext_rate = RATE_9M_IDX;\n\t\telse if (rate == RATE_6M_IDX)\n\t\t\tnext_rate = RATE_6M_IDX;\n\t\tbreak;\n\tcase NL80211_BAND_2GHZ:\n\t\tif (!(il->_3945.sta_supp_rates & IL_OFDM_RATES_MASK) &&\n\t\t    il_is_associated(il)) {\n\t\t\tif (rate == RATE_11M_IDX)\n\t\t\t\tnext_rate = RATE_5M_IDX;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn next_rate;\n}\n\n \nstatic void\nil3945_tx_queue_reclaim(struct il_priv *il, int txq_id, int idx)\n{\n\tstruct il_tx_queue *txq = &il->txq[txq_id];\n\tstruct il_queue *q = &txq->q;\n\tstruct sk_buff *skb;\n\n\tBUG_ON(txq_id == IL39_CMD_QUEUE_NUM);\n\n\tfor (idx = il_queue_inc_wrap(idx, q->n_bd); q->read_ptr != idx;\n\t     q->read_ptr = il_queue_inc_wrap(q->read_ptr, q->n_bd)) {\n\n\t\tskb = txq->skbs[txq->q.read_ptr];\n\t\tieee80211_tx_status_irqsafe(il->hw, skb);\n\t\ttxq->skbs[txq->q.read_ptr] = NULL;\n\t\til->ops->txq_free_tfd(il, txq);\n\t}\n\n\tif (il_queue_space(q) > q->low_mark && txq_id >= 0 &&\n\t    txq_id != IL39_CMD_QUEUE_NUM && il->mac80211_registered)\n\t\til_wake_queue(il, txq);\n}\n\n \nstatic void\nil3945_hdl_tx(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tu16 sequence = le16_to_cpu(pkt->hdr.sequence);\n\tint txq_id = SEQ_TO_QUEUE(sequence);\n\tint idx = SEQ_TO_IDX(sequence);\n\tstruct il_tx_queue *txq = &il->txq[txq_id];\n\tstruct ieee80211_tx_info *info;\n\tstruct il3945_tx_resp *tx_resp = (void *)&pkt->u.raw[0];\n\tu32 status = le32_to_cpu(tx_resp->status);\n\tint rate_idx;\n\tint fail;\n\n\tif (idx >= txq->q.n_bd || il_queue_used(&txq->q, idx) == 0) {\n\t\tIL_ERR(\"Read idx for DMA queue txq_id (%d) idx %d \"\n\t\t       \"is out of range [0-%d] %d %d\\n\", txq_id, idx,\n\t\t       txq->q.n_bd, txq->q.write_ptr, txq->q.read_ptr);\n\t\treturn;\n\t}\n\n\t \n\tif (unlikely((status & TX_STATUS_MSK) == TX_STATUS_FAIL_PASSIVE_NO_RX) &&\n\t    il->iw_mode == NL80211_IFTYPE_STATION) {\n\t\til_stop_queues_by_reason(il, IL_STOP_REASON_PASSIVE);\n\t\tD_INFO(\"Stopped queues - RX waiting on passive channel\\n\");\n\t}\n\n\ttxq->time_stamp = jiffies;\n\tinfo = IEEE80211_SKB_CB(txq->skbs[txq->q.read_ptr]);\n\tieee80211_tx_info_clear_status(info);\n\n\t \n\trate_idx = il3945_hwrate_to_plcp_idx(tx_resp->rate);\n\tif (info->band == NL80211_BAND_5GHZ)\n\t\trate_idx -= IL_FIRST_OFDM_RATE;\n\n\tfail = tx_resp->failure_frame;\n\n\tinfo->status.rates[0].idx = rate_idx;\n\tinfo->status.rates[0].count = fail + 1;\t \n\n\t \n\tinfo->flags |=\n\t    ((status & TX_STATUS_MSK) ==\n\t     TX_STATUS_SUCCESS) ? IEEE80211_TX_STAT_ACK : 0;\n\n\tD_TX(\"Tx queue %d Status %s (0x%08x) plcp rate %d retries %d\\n\", txq_id,\n\t     il3945_get_tx_fail_reason(status), status, tx_resp->rate,\n\t     tx_resp->failure_frame);\n\n\tD_TX_REPLY(\"Tx queue reclaim %d\\n\", idx);\n\til3945_tx_queue_reclaim(il, txq_id, idx);\n\n\tif (status & TX_ABORT_REQUIRED_MSK)\n\t\tIL_ERR(\"TODO:  Implement Tx ABORT REQUIRED!!!\\n\");\n}\n\n \n#ifdef CONFIG_IWLEGACY_DEBUGFS\nstatic void\nil3945_accumulative_stats(struct il_priv *il, __le32 * stats)\n{\n\tint i;\n\t__le32 *prev_stats;\n\tu32 *accum_stats;\n\tu32 *delta, *max_delta;\n\n\tprev_stats = (__le32 *) &il->_3945.stats;\n\taccum_stats = (u32 *) &il->_3945.accum_stats;\n\tdelta = (u32 *) &il->_3945.delta_stats;\n\tmax_delta = (u32 *) &il->_3945.max_delta;\n\n\tfor (i = sizeof(__le32); i < sizeof(struct il3945_notif_stats);\n\t     i +=\n\t     sizeof(__le32), stats++, prev_stats++, delta++, max_delta++,\n\t     accum_stats++) {\n\t\tif (le32_to_cpu(*stats) > le32_to_cpu(*prev_stats)) {\n\t\t\t*delta =\n\t\t\t    (le32_to_cpu(*stats) - le32_to_cpu(*prev_stats));\n\t\t\t*accum_stats += *delta;\n\t\t\tif (*delta > *max_delta)\n\t\t\t\t*max_delta = *delta;\n\t\t}\n\t}\n\n\t \n\til->_3945.accum_stats.general.temperature =\n\t    il->_3945.stats.general.temperature;\n\til->_3945.accum_stats.general.ttl_timestamp =\n\t    il->_3945.stats.general.ttl_timestamp;\n}\n#endif\n\nvoid\nil3945_hdl_stats(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\n\tD_RX(\"Statistics notification received (%d vs %d).\\n\",\n\t     (int)sizeof(struct il3945_notif_stats),\n\t     le32_to_cpu(pkt->len_n_flags) & IL_RX_FRAME_SIZE_MSK);\n#ifdef CONFIG_IWLEGACY_DEBUGFS\n\til3945_accumulative_stats(il, (__le32 *) &pkt->u.raw);\n#endif\n\n\tmemcpy(&il->_3945.stats, pkt->u.raw, sizeof(il->_3945.stats));\n}\n\nvoid\nil3945_hdl_c_stats(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\t__le32 *flag = (__le32 *) &pkt->u.raw;\n\n\tif (le32_to_cpu(*flag) & UCODE_STATS_CLEAR_MSK) {\n#ifdef CONFIG_IWLEGACY_DEBUGFS\n\t\tmemset(&il->_3945.accum_stats, 0,\n\t\t       sizeof(struct il3945_notif_stats));\n\t\tmemset(&il->_3945.delta_stats, 0,\n\t\t       sizeof(struct il3945_notif_stats));\n\t\tmemset(&il->_3945.max_delta, 0,\n\t\t       sizeof(struct il3945_notif_stats));\n#endif\n\t\tD_RX(\"Statistics have been cleared\\n\");\n\t}\n\til3945_hdl_stats(il, rxb);\n}\n\n \n\n \nstatic int\nil3945_is_network_packet(struct il_priv *il, struct ieee80211_hdr *header)\n{\n\t \n\tswitch (il->iw_mode) {\n\tcase NL80211_IFTYPE_ADHOC:\t \n\t\t \n\t\treturn ether_addr_equal_64bits(header->addr3, il->bssid);\n\tcase NL80211_IFTYPE_STATION:\t \n\t\t \n\t\treturn ether_addr_equal_64bits(header->addr2, il->bssid);\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\n#define SMALL_PACKET_SIZE 256\n\nstatic void\nil3945_pass_packet_to_mac80211(struct il_priv *il, struct il_rx_buf *rxb,\n\t\t\t       struct ieee80211_rx_status *stats)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)IL_RX_DATA(pkt);\n\tstruct il3945_rx_frame_hdr *rx_hdr = IL_RX_HDR(pkt);\n\tstruct il3945_rx_frame_end *rx_end = IL_RX_END(pkt);\n\tu32 len = le16_to_cpu(rx_hdr->len);\n\tstruct sk_buff *skb;\n\t__le16 fc = hdr->frame_control;\n\tu32 fraglen = PAGE_SIZE << il->hw_params.rx_page_order;\n\n\t \n\tif (unlikely(len + IL39_RX_FRAME_SIZE > fraglen)) {\n\t\tD_DROP(\"Corruption detected!\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (unlikely(!il->is_open)) {\n\t\tD_DROP(\"Dropping packet while interface is not open.\\n\");\n\t\treturn;\n\t}\n\n\tif (unlikely(test_bit(IL_STOP_REASON_PASSIVE, &il->stop_reason))) {\n\t\til_wake_queues_by_reason(il, IL_STOP_REASON_PASSIVE);\n\t\tD_INFO(\"Woke queues - frame received on passive channel\\n\");\n\t}\n\n\tskb = dev_alloc_skb(SMALL_PACKET_SIZE);\n\tif (!skb) {\n\t\tIL_ERR(\"dev_alloc_skb failed\\n\");\n\t\treturn;\n\t}\n\n\tif (!il3945_mod_params.sw_crypto)\n\t\til_set_decrypted_flag(il, (struct ieee80211_hdr *)pkt,\n\t\t\t\t      le32_to_cpu(rx_end->status), stats);\n\n\t \n\tif (len <= SMALL_PACKET_SIZE) {\n\t\tskb_put_data(skb, rx_hdr->payload, len);\n\t} else {\n\t\tskb_add_rx_frag(skb, 0, rxb->page,\n\t\t\t\t(void *)rx_hdr->payload - (void *)pkt, len,\n\t\t\t\tfraglen);\n\t\til->alloc_rxb_page--;\n\t\trxb->page = NULL;\n\t}\n\til_update_stats(il, false, fc, len);\n\tmemcpy(IEEE80211_SKB_RXCB(skb), stats, sizeof(*stats));\n\n\tieee80211_rx(il->hw, skb);\n}\n\n#define IL_DELAY_NEXT_SCAN_AFTER_ASSOC (HZ*6)\n\nstatic void\nil3945_hdl_rx(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct ieee80211_hdr *header;\n\tstruct ieee80211_rx_status rx_status = {};\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tstruct il3945_rx_frame_stats *rx_stats = IL_RX_STATS(pkt);\n\tstruct il3945_rx_frame_hdr *rx_hdr = IL_RX_HDR(pkt);\n\tstruct il3945_rx_frame_end *rx_end = IL_RX_END(pkt);\n\tu16 rx_stats_sig_avg __maybe_unused = le16_to_cpu(rx_stats->sig_avg);\n\tu16 rx_stats_noise_diff __maybe_unused =\n\t    le16_to_cpu(rx_stats->noise_diff);\n\tu8 network_packet;\n\n\trx_status.flag = 0;\n\trx_status.mactime = le64_to_cpu(rx_end->timestamp);\n\trx_status.band =\n\t    (rx_hdr->\n\t     phy_flags & RX_RES_PHY_FLAGS_BAND_24_MSK) ? NL80211_BAND_2GHZ :\n\t    NL80211_BAND_5GHZ;\n\trx_status.freq =\n\t    ieee80211_channel_to_frequency(le16_to_cpu(rx_hdr->channel),\n\t\t\t\t\t   rx_status.band);\n\n\trx_status.rate_idx = il3945_hwrate_to_plcp_idx(rx_hdr->rate);\n\tif (rx_status.band == NL80211_BAND_5GHZ)\n\t\trx_status.rate_idx -= IL_FIRST_OFDM_RATE;\n\n\trx_status.antenna =\n\t    (le16_to_cpu(rx_hdr->phy_flags) & RX_RES_PHY_FLAGS_ANTENNA_MSK) >>\n\t    4;\n\n\t \n\tif (rx_hdr->phy_flags & RX_RES_PHY_FLAGS_SHORT_PREAMBLE_MSK)\n\t\trx_status.enc_flags |= RX_ENC_FLAG_SHORTPRE;\n\n\tif ((unlikely(rx_stats->phy_count > 20))) {\n\t\tD_DROP(\"dsp size out of range [0,20]: %d\\n\",\n\t\t       rx_stats->phy_count);\n\t\treturn;\n\t}\n\n\tif (!(rx_end->status & RX_RES_STATUS_NO_CRC32_ERROR) ||\n\t    !(rx_end->status & RX_RES_STATUS_NO_RXE_OVERFLOW)) {\n\t\tD_RX(\"Bad CRC or FIFO: 0x%08X.\\n\", rx_end->status);\n\t\treturn;\n\t}\n\n\t \n\trx_status.signal = rx_stats->rssi - IL39_RSSI_OFFSET;\n\n\tD_STATS(\"Rssi %d sig_avg %d noise_diff %d\\n\", rx_status.signal,\n\t\trx_stats_sig_avg, rx_stats_noise_diff);\n\n\theader = (struct ieee80211_hdr *)IL_RX_DATA(pkt);\n\n\tnetwork_packet = il3945_is_network_packet(il, header);\n\n\tD_STATS(\"[%c] %d RSSI:%d Signal:%u, Rate:%u\\n\",\n\t\tnetwork_packet ? '*' : ' ', le16_to_cpu(rx_hdr->channel),\n\t\trx_status.signal, rx_status.signal, rx_status.rate_idx);\n\n\tif (network_packet) {\n\t\til->_3945.last_beacon_time =\n\t\t    le32_to_cpu(rx_end->beacon_timestamp);\n\t\til->_3945.last_tsf = le64_to_cpu(rx_end->timestamp);\n\t\til->_3945.last_rx_rssi = rx_status.signal;\n\t}\n\n\til3945_pass_packet_to_mac80211(il, rxb, &rx_status);\n}\n\nint\nil3945_hw_txq_attach_buf_to_tfd(struct il_priv *il, struct il_tx_queue *txq,\n\t\t\t\tdma_addr_t addr, u16 len, u8 reset, u8 pad)\n{\n\tint count;\n\tstruct il_queue *q;\n\tstruct il3945_tfd *tfd, *tfd_tmp;\n\n\tq = &txq->q;\n\ttfd_tmp = (struct il3945_tfd *)txq->tfds;\n\ttfd = &tfd_tmp[q->write_ptr];\n\n\tif (reset)\n\t\tmemset(tfd, 0, sizeof(*tfd));\n\n\tcount = TFD_CTL_COUNT_GET(le32_to_cpu(tfd->control_flags));\n\n\tif (count >= NUM_TFD_CHUNKS || count < 0) {\n\t\tIL_ERR(\"Error can not send more than %d chunks\\n\",\n\t\t       NUM_TFD_CHUNKS);\n\t\treturn -EINVAL;\n\t}\n\n\ttfd->tbs[count].addr = cpu_to_le32(addr);\n\ttfd->tbs[count].len = cpu_to_le32(len);\n\n\tcount++;\n\n\ttfd->control_flags =\n\t    cpu_to_le32(TFD_CTL_COUNT_SET(count) | TFD_CTL_PAD_SET(pad));\n\n\treturn 0;\n}\n\n \nvoid\nil3945_hw_txq_free_tfd(struct il_priv *il, struct il_tx_queue *txq)\n{\n\tstruct il3945_tfd *tfd_tmp = (struct il3945_tfd *)txq->tfds;\n\tint idx = txq->q.read_ptr;\n\tstruct il3945_tfd *tfd = &tfd_tmp[idx];\n\tstruct pci_dev *dev = il->pci_dev;\n\tint i;\n\tint counter;\n\n\t \n\tcounter = TFD_CTL_COUNT_GET(le32_to_cpu(tfd->control_flags));\n\tif (counter > NUM_TFD_CHUNKS) {\n\t\tIL_ERR(\"Too many chunks: %i\\n\", counter);\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tif (counter)\n\t\tdma_unmap_single(&dev->dev,\n\t\t\t\t dma_unmap_addr(&txq->meta[idx], mapping),\n\t\t\t\t dma_unmap_len(&txq->meta[idx], len),\n\t\t\t\t DMA_TO_DEVICE);\n\n\t \n\n\tfor (i = 1; i < counter; i++)\n\t\tdma_unmap_single(&dev->dev, le32_to_cpu(tfd->tbs[i].addr),\n\t\t\t\t le32_to_cpu(tfd->tbs[i].len), DMA_TO_DEVICE);\n\n\t \n\tif (txq->skbs) {\n\t\tstruct sk_buff *skb = txq->skbs[txq->q.read_ptr];\n\n\t\t \n\t\tif (skb) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\ttxq->skbs[txq->q.read_ptr] = NULL;\n\t\t}\n\t}\n}\n\n \nvoid\nil3945_hw_build_tx_cmd_rate(struct il_priv *il, struct il_device_cmd *cmd,\n\t\t\t    struct ieee80211_tx_info *info,\n\t\t\t    struct ieee80211_hdr *hdr, int sta_id)\n{\n\tu16 hw_value = ieee80211_get_tx_rate(il->hw, info)->hw_value;\n\tu16 rate_idx = min(hw_value & 0xffff, RATE_COUNT_3945 - 1);\n\tu16 rate_mask;\n\tint rate;\n\tconst u8 rts_retry_limit = 7;\n\tu8 data_retry_limit;\n\t__le32 tx_flags;\n\t__le16 fc = hdr->frame_control;\n\tstruct il3945_tx_cmd *tx_cmd = (struct il3945_tx_cmd *)cmd->cmd.payload;\n\n\trate = il3945_rates[rate_idx].plcp;\n\ttx_flags = tx_cmd->tx_flags;\n\n\t \n\trate_mask = RATES_MASK_3945;\n\n\t \n\tif (ieee80211_is_probe_resp(fc))\n\t\tdata_retry_limit = 3;\n\telse\n\t\tdata_retry_limit = IL_DEFAULT_TX_RETRY;\n\ttx_cmd->data_retry_limit = data_retry_limit;\n\t \n\ttx_cmd->rts_retry_limit = min(data_retry_limit, rts_retry_limit);\n\n\ttx_cmd->rate = rate;\n\ttx_cmd->tx_flags = tx_flags;\n\n\t \n\ttx_cmd->supp_rates[0] =\n\t    ((rate_mask & IL_OFDM_RATES_MASK) >> IL_FIRST_OFDM_RATE) & 0xFF;\n\n\t \n\ttx_cmd->supp_rates[1] = (rate_mask & 0xF);\n\n\tD_RATE(\"Tx sta id: %d, rate: %d (plcp), flags: 0x%4X \"\n\t       \"cck/ofdm mask: 0x%x/0x%x\\n\", sta_id, tx_cmd->rate,\n\t       le32_to_cpu(tx_cmd->tx_flags), tx_cmd->supp_rates[1],\n\t       tx_cmd->supp_rates[0]);\n}\n\nstatic u8\nil3945_sync_sta(struct il_priv *il, int sta_id, u16 tx_rate)\n{\n\tunsigned long flags_spin;\n\tstruct il_station_entry *station;\n\n\tif (sta_id == IL_INVALID_STATION)\n\t\treturn IL_INVALID_STATION;\n\n\tspin_lock_irqsave(&il->sta_lock, flags_spin);\n\tstation = &il->stations[sta_id];\n\n\tstation->sta.sta.modify_mask = STA_MODIFY_TX_RATE_MSK;\n\tstation->sta.rate_n_flags = cpu_to_le16(tx_rate);\n\tstation->sta.mode = STA_CONTROL_MODIFY_MSK;\n\til_send_add_sta(il, &station->sta, CMD_ASYNC);\n\tspin_unlock_irqrestore(&il->sta_lock, flags_spin);\n\n\tD_RATE(\"SCALE sync station %d to rate %d\\n\", sta_id, tx_rate);\n\treturn sta_id;\n}\n\nstatic void\nil3945_set_pwr_vmain(struct il_priv *il)\n{\n \n\n\til_set_bits_mask_prph(il, APMG_PS_CTRL_REG,\n\t\t\t      APMG_PS_CTRL_VAL_PWR_SRC_VMAIN,\n\t\t\t      ~APMG_PS_CTRL_MSK_PWR_SRC);\n\n\t_il_poll_bit(il, CSR_GPIO_IN, CSR_GPIO_IN_VAL_VMAIN_PWR_SRC,\n\t\t     CSR_GPIO_IN_BIT_AUX_POWER, 5000);\n}\n\nstatic int\nil3945_rx_init(struct il_priv *il, struct il_rx_queue *rxq)\n{\n\til_wr(il, FH39_RCSR_RBD_BASE(0), rxq->bd_dma);\n\til_wr(il, FH39_RCSR_RPTR_ADDR(0), rxq->rb_stts_dma);\n\til_wr(il, FH39_RCSR_WPTR(0), 0);\n\til_wr(il, FH39_RCSR_CONFIG(0),\n\t      FH39_RCSR_RX_CONFIG_REG_VAL_DMA_CHNL_EN_ENABLE |\n\t      FH39_RCSR_RX_CONFIG_REG_VAL_RDRBD_EN_ENABLE |\n\t      FH39_RCSR_RX_CONFIG_REG_BIT_WR_STTS_EN |\n\t      FH39_RCSR_RX_CONFIG_REG_VAL_MAX_FRAG_SIZE_128 | (RX_QUEUE_SIZE_LOG\n\t\t\t\t\t\t\t       <<\n\t\t\t\t\t\t\t       FH39_RCSR_RX_CONFIG_REG_POS_RBDC_SIZE)\n\t      | FH39_RCSR_RX_CONFIG_REG_VAL_IRQ_DEST_INT_HOST | (1 <<\n\t\t\t\t\t\t\t\t FH39_RCSR_RX_CONFIG_REG_POS_IRQ_RBTH)\n\t      | FH39_RCSR_RX_CONFIG_REG_VAL_MSG_MODE_FH);\n\n\t \n\til_rd(il, FH39_RSSR_CTRL);\n\n\treturn 0;\n}\n\nstatic int\nil3945_tx_reset(struct il_priv *il)\n{\n\t \n\til_wr_prph(il, ALM_SCD_MODE_REG, 0x2);\n\n\t \n\til_wr_prph(il, ALM_SCD_ARASTAT_REG, 0x01);\n\n\t \n\til_wr_prph(il, ALM_SCD_TXFACT_REG, 0x3f);\n\n\til_wr_prph(il, ALM_SCD_SBYP_MODE_1_REG, 0x010000);\n\til_wr_prph(il, ALM_SCD_SBYP_MODE_2_REG, 0x030002);\n\til_wr_prph(il, ALM_SCD_TXF4MF_REG, 0x000004);\n\til_wr_prph(il, ALM_SCD_TXF5MF_REG, 0x000005);\n\n\til_wr(il, FH39_TSSR_CBB_BASE, il->_3945.shared_phys);\n\n\til_wr(il, FH39_TSSR_MSG_CONFIG,\n\t      FH39_TSSR_TX_MSG_CONFIG_REG_VAL_SNOOP_RD_TXPD_ON |\n\t      FH39_TSSR_TX_MSG_CONFIG_REG_VAL_ORDER_RD_TXPD_ON |\n\t      FH39_TSSR_TX_MSG_CONFIG_REG_VAL_MAX_FRAG_SIZE_128B |\n\t      FH39_TSSR_TX_MSG_CONFIG_REG_VAL_SNOOP_RD_TFD_ON |\n\t      FH39_TSSR_TX_MSG_CONFIG_REG_VAL_ORDER_RD_CBB_ON |\n\t      FH39_TSSR_TX_MSG_CONFIG_REG_VAL_ORDER_RSP_WAIT_TH |\n\t      FH39_TSSR_TX_MSG_CONFIG_REG_VAL_RSP_WAIT_TH);\n\n\treturn 0;\n}\n\n \nstatic int\nil3945_txq_ctx_reset(struct il_priv *il)\n{\n\tint rc, txq_id;\n\n\til3945_hw_txq_ctx_free(il);\n\n\t \n\trc = il_alloc_txq_mem(il);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = il3945_tx_reset(il);\n\tif (rc)\n\t\tgoto error;\n\n\t \n\tfor (txq_id = 0; txq_id < il->hw_params.max_txq_num; txq_id++) {\n\t\trc = il_tx_queue_init(il, txq_id);\n\t\tif (rc) {\n\t\t\tIL_ERR(\"Tx %d queue init failed\\n\", txq_id);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn rc;\n\nerror:\n\til3945_hw_txq_ctx_free(il);\n\treturn rc;\n}\n\n \nstatic int\nil3945_apm_init(struct il_priv *il)\n{\n\tint ret = il_apm_init(il);\n\n\t \n\til_wr_prph(il, APMG_RTC_INT_MSK_REG, 0x0);\n\til_wr_prph(il, APMG_RTC_INT_STT_REG, 0xFFFFFFFF);\n\n\t \n\til_set_bits_prph(il, APMG_PS_CTRL_REG, APMG_PS_CTRL_VAL_RESET_REQ);\n\tudelay(5);\n\til_clear_bits_prph(il, APMG_PS_CTRL_REG, APMG_PS_CTRL_VAL_RESET_REQ);\n\n\treturn ret;\n}\n\nstatic void\nil3945_nic_config(struct il_priv *il)\n{\n\tstruct il3945_eeprom *eeprom = (struct il3945_eeprom *)il->eeprom;\n\tunsigned long flags;\n\tu8 rev_id = il->pci_dev->revision;\n\n\tspin_lock_irqsave(&il->lock, flags);\n\n\t \n\tD_INFO(\"HW Revision ID = 0x%X\\n\", rev_id);\n\n\tif (rev_id & PCI_CFG_REV_ID_BIT_RTP)\n\t\tD_INFO(\"RTP type\\n\");\n\telse if (rev_id & PCI_CFG_REV_ID_BIT_BASIC_SKU) {\n\t\tD_INFO(\"3945 RADIO-MB type\\n\");\n\t\til_set_bit(il, CSR_HW_IF_CONFIG_REG,\n\t\t\t   CSR39_HW_IF_CONFIG_REG_BIT_3945_MB);\n\t} else {\n\t\tD_INFO(\"3945 RADIO-MM type\\n\");\n\t\til_set_bit(il, CSR_HW_IF_CONFIG_REG,\n\t\t\t   CSR39_HW_IF_CONFIG_REG_BIT_3945_MM);\n\t}\n\n\tif (EEPROM_SKU_CAP_OP_MODE_MRC == eeprom->sku_cap) {\n\t\tD_INFO(\"SKU OP mode is mrc\\n\");\n\t\til_set_bit(il, CSR_HW_IF_CONFIG_REG,\n\t\t\t   CSR39_HW_IF_CONFIG_REG_BIT_SKU_MRC);\n\t} else\n\t\tD_INFO(\"SKU OP mode is basic\\n\");\n\n\tif ((eeprom->board_revision & 0xF0) == 0xD0) {\n\t\tD_INFO(\"3945ABG revision is 0x%X\\n\", eeprom->board_revision);\n\t\til_set_bit(il, CSR_HW_IF_CONFIG_REG,\n\t\t\t   CSR39_HW_IF_CONFIG_REG_BIT_BOARD_TYPE);\n\t} else {\n\t\tD_INFO(\"3945ABG revision is 0x%X\\n\", eeprom->board_revision);\n\t\til_clear_bit(il, CSR_HW_IF_CONFIG_REG,\n\t\t\t     CSR39_HW_IF_CONFIG_REG_BIT_BOARD_TYPE);\n\t}\n\n\tif (eeprom->almgor_m_version <= 1) {\n\t\til_set_bit(il, CSR_HW_IF_CONFIG_REG,\n\t\t\t   CSR39_HW_IF_CONFIG_REG_BITS_SILICON_TYPE_A);\n\t\tD_INFO(\"Card M type A version is 0x%X\\n\",\n\t\t       eeprom->almgor_m_version);\n\t} else {\n\t\tD_INFO(\"Card M type B version is 0x%X\\n\",\n\t\t       eeprom->almgor_m_version);\n\t\til_set_bit(il, CSR_HW_IF_CONFIG_REG,\n\t\t\t   CSR39_HW_IF_CONFIG_REG_BITS_SILICON_TYPE_B);\n\t}\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\tif (eeprom->sku_cap & EEPROM_SKU_CAP_SW_RF_KILL_ENABLE)\n\t\tD_RF_KILL(\"SW RF KILL supported in EEPROM.\\n\");\n\n\tif (eeprom->sku_cap & EEPROM_SKU_CAP_HW_RF_KILL_ENABLE)\n\t\tD_RF_KILL(\"HW RF KILL supported in EEPROM.\\n\");\n}\n\nint\nil3945_hw_nic_init(struct il_priv *il)\n{\n\tint rc;\n\tunsigned long flags;\n\tstruct il_rx_queue *rxq = &il->rxq;\n\n\tspin_lock_irqsave(&il->lock, flags);\n\til3945_apm_init(il);\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\til3945_set_pwr_vmain(il);\n\til3945_nic_config(il);\n\n\t \n\tif (!rxq->bd) {\n\t\trc = il_rx_queue_alloc(il);\n\t\tif (rc) {\n\t\t\tIL_ERR(\"Unable to initialize Rx queue\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else\n\t\til3945_rx_queue_reset(il, rxq);\n\n\til3945_rx_replenish(il);\n\n\til3945_rx_init(il, rxq);\n\n\t \n\n\til_wr(il, FH39_RCSR_WPTR(0), rxq->write & ~7);\n\n\trc = il3945_txq_ctx_reset(il);\n\tif (rc)\n\t\treturn rc;\n\n\tset_bit(S_INIT, &il->status);\n\n\treturn 0;\n}\n\n \nvoid\nil3945_hw_txq_ctx_free(struct il_priv *il)\n{\n\tint txq_id;\n\n\t \n\tif (il->txq) {\n\t\tfor (txq_id = 0; txq_id < il->hw_params.max_txq_num; txq_id++)\n\t\t\tif (txq_id == IL39_CMD_QUEUE_NUM)\n\t\t\t\til_cmd_queue_free(il);\n\t\t\telse\n\t\t\t\til_tx_queue_free(il, txq_id);\n\t}\n\n\t \n\til_free_txq_mem(il);\n}\n\nvoid\nil3945_hw_txq_ctx_stop(struct il_priv *il)\n{\n\tint txq_id;\n\n\t \n\t_il_wr_prph(il, ALM_SCD_MODE_REG, 0);\n\t_il_wr_prph(il, ALM_SCD_TXFACT_REG, 0);\n\n\t \n\tfor (txq_id = 0; txq_id < il->hw_params.max_txq_num; txq_id++) {\n\t\t_il_wr(il, FH39_TCSR_CONFIG(txq_id), 0x0);\n\t\t_il_poll_bit(il, FH39_TSSR_TX_STATUS,\n\t\t\t     FH39_TSSR_TX_STATUS_REG_MSK_CHNL_IDLE(txq_id),\n\t\t\t     FH39_TSSR_TX_STATUS_REG_MSK_CHNL_IDLE(txq_id),\n\t\t\t     1000);\n\t}\n}\n\n \nstatic int\nil3945_hw_reg_adjust_power_by_temp(int new_reading, int old_reading)\n{\n\treturn (new_reading - old_reading) * (-11) / 100;\n}\n\n \nstatic inline int\nil3945_hw_reg_temp_out_of_range(int temperature)\n{\n\treturn (temperature < -260 || temperature > 25) ? 1 : 0;\n}\n\nint\nil3945_hw_get_temperature(struct il_priv *il)\n{\n\treturn _il_rd(il, CSR_UCODE_DRV_GP2);\n}\n\n \nstatic int\nil3945_hw_reg_txpower_get_temperature(struct il_priv *il)\n{\n\tstruct il3945_eeprom *eeprom = (struct il3945_eeprom *)il->eeprom;\n\tint temperature;\n\n\ttemperature = il3945_hw_get_temperature(il);\n\n\t \n\tD_INFO(\"Temperature: %d\\n\", temperature + IL_TEMP_CONVERT);\n\n\t \n\tif (il3945_hw_reg_temp_out_of_range(temperature)) {\n\t\tIL_ERR(\"Error bad temperature value  %d\\n\", temperature);\n\n\t\t \n\t\tif (il->last_temperature > 100)\n\t\t\ttemperature = eeprom->groups[2].temperature;\n\t\telse\t\t \n\t\t\ttemperature = il->last_temperature;\n\t}\n\n\treturn temperature;\t \n}\n\n \n#define IL_TEMPERATURE_LIMIT_TIMER   6\n\n \nstatic int\nil3945_is_temp_calib_needed(struct il_priv *il)\n{\n\tint temp_diff;\n\n\til->temperature = il3945_hw_reg_txpower_get_temperature(il);\n\ttemp_diff = il->temperature - il->last_temperature;\n\n\t \n\tif (temp_diff < 0) {\n\t\tD_POWER(\"Getting cooler, delta %d,\\n\", temp_diff);\n\t\ttemp_diff = -temp_diff;\n\t} else if (temp_diff == 0)\n\t\tD_POWER(\"Same temp,\\n\");\n\telse\n\t\tD_POWER(\"Getting warmer, delta %d,\\n\", temp_diff);\n\n\t \n\tif (temp_diff < IL_TEMPERATURE_LIMIT_TIMER) {\n\t\tD_POWER(\"Timed thermal calib not needed\\n\");\n\t\treturn 0;\n\t}\n\n\tD_POWER(\"Timed thermal calib needed\\n\");\n\n\t \n\til->last_temperature = il->temperature;\n\treturn 1;\n}\n\n#define IL_MAX_GAIN_ENTRIES 78\n#define IL_CCK_FROM_OFDM_POWER_DIFF  -5\n#define IL_CCK_FROM_OFDM_IDX_DIFF (10)\n\n \nstatic struct il3945_tx_power power_gain_table[2][IL_MAX_GAIN_ENTRIES] = {\n\t{\n\t {251, 127},\t\t \n\t {251, 127},\n\t {251, 127},\n\t {251, 127},\n\t {251, 125},\n\t {251, 110},\n\t {251, 105},\n\t {251, 98},\n\t {187, 125},\n\t {187, 115},\n\t {187, 108},\n\t {187, 99},\n\t {243, 119},\n\t {243, 111},\n\t {243, 105},\n\t {243, 97},\n\t {243, 92},\n\t {211, 106},\n\t {211, 100},\n\t {179, 120},\n\t {179, 113},\n\t {179, 107},\n\t {147, 125},\n\t {147, 119},\n\t {147, 112},\n\t {147, 106},\n\t {147, 101},\n\t {147, 97},\n\t {147, 91},\n\t {115, 107},\n\t {235, 121},\n\t {235, 115},\n\t {235, 109},\n\t {203, 127},\n\t {203, 121},\n\t {203, 115},\n\t {203, 108},\n\t {203, 102},\n\t {203, 96},\n\t {203, 92},\n\t {171, 110},\n\t {171, 104},\n\t {171, 98},\n\t {139, 116},\n\t {227, 125},\n\t {227, 119},\n\t {227, 113},\n\t {227, 107},\n\t {227, 101},\n\t {227, 96},\n\t {195, 113},\n\t {195, 106},\n\t {195, 102},\n\t {195, 95},\n\t {163, 113},\n\t {163, 106},\n\t {163, 102},\n\t {163, 95},\n\t {131, 113},\n\t {131, 106},\n\t {131, 102},\n\t {131, 95},\n\t {99, 113},\n\t {99, 106},\n\t {99, 102},\n\t {99, 95},\n\t {67, 113},\n\t {67, 106},\n\t {67, 102},\n\t {67, 95},\n\t {35, 113},\n\t {35, 106},\n\t {35, 102},\n\t {35, 95},\n\t {3, 113},\n\t {3, 106},\n\t {3, 102},\n\t {3, 95}\t\t \n\t},\n\t{\n\t {251, 127},\t\t \n\t {251, 120},\n\t {251, 114},\n\t {219, 119},\n\t {219, 101},\n\t {187, 113},\n\t {187, 102},\n\t {155, 114},\n\t {155, 103},\n\t {123, 117},\n\t {123, 107},\n\t {123, 99},\n\t {123, 92},\n\t {91, 108},\n\t {59, 125},\n\t {59, 118},\n\t {59, 109},\n\t {59, 102},\n\t {59, 96},\n\t {59, 90},\n\t {27, 104},\n\t {27, 98},\n\t {27, 92},\n\t {115, 118},\n\t {115, 111},\n\t {115, 104},\n\t {83, 126},\n\t {83, 121},\n\t {83, 113},\n\t {83, 105},\n\t {83, 99},\n\t {51, 118},\n\t {51, 111},\n\t {51, 104},\n\t {51, 98},\n\t {19, 116},\n\t {19, 109},\n\t {19, 102},\n\t {19, 98},\n\t {19, 93},\n\t {171, 113},\n\t {171, 107},\n\t {171, 99},\n\t {139, 120},\n\t {139, 113},\n\t {139, 107},\n\t {139, 99},\n\t {107, 120},\n\t {107, 113},\n\t {107, 107},\n\t {107, 99},\n\t {75, 120},\n\t {75, 113},\n\t {75, 107},\n\t {75, 99},\n\t {43, 120},\n\t {43, 113},\n\t {43, 107},\n\t {43, 99},\n\t {11, 120},\n\t {11, 113},\n\t {11, 107},\n\t {11, 99},\n\t {131, 107},\n\t {131, 99},\n\t {99, 120},\n\t {99, 113},\n\t {99, 107},\n\t {99, 99},\n\t {67, 120},\n\t {67, 113},\n\t {67, 107},\n\t {67, 99},\n\t {35, 120},\n\t {35, 113},\n\t {35, 107},\n\t {35, 99},\n\t {3, 120}\t\t \n\t}\n};\n\nstatic inline u8\nil3945_hw_reg_fix_power_idx(int idx)\n{\n\tif (idx < 0)\n\t\treturn 0;\n\tif (idx >= IL_MAX_GAIN_ENTRIES)\n\t\treturn IL_MAX_GAIN_ENTRIES - 1;\n\treturn (u8) idx;\n}\n\n \n#define REG_RECALIB_PERIOD (60)\n\n \nstatic void\nil3945_hw_reg_set_scan_power(struct il_priv *il, u32 scan_tbl_idx, s32 rate_idx,\n\t\t\t     const s8 *clip_pwrs,\n\t\t\t     struct il_channel_info *ch_info, int band_idx)\n{\n\tstruct il3945_scan_power_info *scan_power_info;\n\ts8 power;\n\tu8 power_idx;\n\n\tscan_power_info = &ch_info->scan_pwr_info[scan_tbl_idx];\n\n\t \n\tpower = min(ch_info->scan_power, clip_pwrs[RATE_6M_IDX_TBL]);\n\n\tpower = min(power, il->tx_power_user_lmt);\n\tscan_power_info->requested_power = power;\n\n\t \n\tpower_idx =\n\t    ch_info->power_info[rate_idx].power_table_idx - (power -\n\t\t\t\t\t\t\t     ch_info->\n\t\t\t\t\t\t\t     power_info\n\t\t\t\t\t\t\t     [RATE_6M_IDX_TBL].\n\t\t\t\t\t\t\t     requested_power) *\n\t    2;\n\n\t \n\n\t \n\tpower_idx = il3945_hw_reg_fix_power_idx(power_idx);\n\n\tscan_power_info->power_table_idx = power_idx;\n\tscan_power_info->tpc.tx_gain =\n\t    power_gain_table[band_idx][power_idx].tx_gain;\n\tscan_power_info->tpc.dsp_atten =\n\t    power_gain_table[band_idx][power_idx].dsp_atten;\n}\n\n \nstatic int\nil3945_send_tx_power(struct il_priv *il)\n{\n\tint rate_idx, i;\n\tconst struct il_channel_info *ch_info = NULL;\n\tstruct il3945_txpowertable_cmd txpower = {\n\t\t.channel = il->active.channel,\n\t};\n\tu16 chan;\n\n\tif (WARN_ONCE\n\t    (test_bit(S_SCAN_HW, &il->status),\n\t     \"TX Power requested while scanning!\\n\"))\n\t\treturn -EAGAIN;\n\n\tchan = le16_to_cpu(il->active.channel);\n\n\ttxpower.band = (il->band == NL80211_BAND_5GHZ) ? 0 : 1;\n\tch_info = il_get_channel_info(il, il->band, chan);\n\tif (!ch_info) {\n\t\tIL_ERR(\"Failed to get channel info for channel %d [%d]\\n\", chan,\n\t\t       il->band);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!il_is_channel_valid(ch_info)) {\n\t\tD_POWER(\"Not calling TX_PWR_TBL_CMD on \" \"non-Tx channel.\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\t \n\tfor (rate_idx = IL_FIRST_OFDM_RATE, i = 0;\n\t     rate_idx <= IL39_LAST_OFDM_RATE; rate_idx++, i++) {\n\n\t\ttxpower.power[i].tpc = ch_info->power_info[i].tpc;\n\t\ttxpower.power[i].rate = il3945_rates[rate_idx].plcp;\n\n\t\tD_POWER(\"ch %d:%d rf %d dsp %3d rate code 0x%02x\\n\",\n\t\t\tle16_to_cpu(txpower.channel), txpower.band,\n\t\t\ttxpower.power[i].tpc.tx_gain,\n\t\t\ttxpower.power[i].tpc.dsp_atten, txpower.power[i].rate);\n\t}\n\t \n\tfor (rate_idx = IL_FIRST_CCK_RATE; rate_idx <= IL_LAST_CCK_RATE;\n\t     rate_idx++, i++) {\n\t\ttxpower.power[i].tpc = ch_info->power_info[i].tpc;\n\t\ttxpower.power[i].rate = il3945_rates[rate_idx].plcp;\n\n\t\tD_POWER(\"ch %d:%d rf %d dsp %3d rate code 0x%02x\\n\",\n\t\t\tle16_to_cpu(txpower.channel), txpower.band,\n\t\t\ttxpower.power[i].tpc.tx_gain,\n\t\t\ttxpower.power[i].tpc.dsp_atten, txpower.power[i].rate);\n\t}\n\n\treturn il_send_cmd_pdu(il, C_TX_PWR_TBL,\n\t\t\t       sizeof(struct il3945_txpowertable_cmd),\n\t\t\t       &txpower);\n\n}\n\n \nstatic int\nil3945_hw_reg_set_new_power(struct il_priv *il, struct il_channel_info *ch_info)\n{\n\tstruct il3945_channel_power_info *power_info;\n\tint power_changed = 0;\n\tint i;\n\tconst s8 *clip_pwrs;\n\tint power;\n\n\t \n\tclip_pwrs = il->_3945.clip_groups[ch_info->group_idx].clip_powers;\n\n\t \n\tpower_info = ch_info->power_info;\n\n\t \n\tfor (i = RATE_6M_IDX_TBL; i <= RATE_54M_IDX_TBL; i++, ++power_info) {\n\t\tint delta_idx;\n\n\t\t \n\t\tpower = min(ch_info->curr_txpow, clip_pwrs[i]);\n\t\tif (power == power_info->requested_power)\n\t\t\tcontinue;\n\n\t\t \n\t\tdelta_idx = (power - power_info->requested_power) * 2;\n\t\tpower_info->base_power_idx -= delta_idx;\n\n\t\t \n\t\tpower_info->requested_power = power;\n\n\t\tpower_changed = 1;\n\t}\n\n\t \n\tif (power_changed) {\n\t\tpower =\n\t\t    ch_info->power_info[RATE_12M_IDX_TBL].requested_power +\n\t\t    IL_CCK_FROM_OFDM_POWER_DIFF;\n\n\t\t \n\t\tfor (i = RATE_1M_IDX_TBL; i <= RATE_11M_IDX_TBL; i++) {\n\t\t\tpower_info->requested_power = power;\n\t\t\tpower_info->base_power_idx =\n\t\t\t    ch_info->power_info[RATE_12M_IDX_TBL].\n\t\t\t    base_power_idx + IL_CCK_FROM_OFDM_IDX_DIFF;\n\t\t\t++power_info;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nil3945_hw_reg_get_ch_txpower_limit(struct il_channel_info *ch_info)\n{\n\ts8 max_power;\n\n#if 0\n\t \n\tif (ch_info->tgd_data.max_power != 0)\n\t\tmax_power =\n\t\t    min(ch_info->tgd_data.max_power,\n\t\t\tch_info->eeprom.max_power_avg);\n\n\t \n\telse\n#endif\n\t\tmax_power = ch_info->eeprom.max_power_avg;\n\n\treturn min(max_power, ch_info->max_power_avg);\n}\n\n \nstatic int\nil3945_hw_reg_comp_txpower_temp(struct il_priv *il)\n{\n\tstruct il_channel_info *ch_info = NULL;\n\tstruct il3945_eeprom *eeprom = (struct il3945_eeprom *)il->eeprom;\n\tint delta_idx;\n\tconst s8 *clip_pwrs;\t \n\tu8 a_band;\n\tu8 rate_idx;\n\tu8 scan_tbl_idx;\n\tu8 i;\n\tint ref_temp;\n\tint temperature = il->temperature;\n\n\tif (il->disable_tx_power_cal || test_bit(S_SCANNING, &il->status)) {\n\t\t \n\t\treturn 0;\n\t}\n\t \n\tfor (i = 0; i < il->channel_count; i++) {\n\t\tch_info = &il->channel_info[i];\n\t\ta_band = il_is_channel_a_band(ch_info);\n\n\t\t \n\t\tref_temp = (s16) eeprom->groups[ch_info->group_idx].temperature;\n\n\t\t \n\t\tdelta_idx =\n\t\t    il3945_hw_reg_adjust_power_by_temp(temperature, ref_temp);\n\n\t\t \n\t\tfor (rate_idx = 0; rate_idx < RATE_COUNT_3945; rate_idx++) {\n\t\t\tint power_idx =\n\t\t\t    ch_info->power_info[rate_idx].base_power_idx;\n\n\t\t\t \n\t\t\tpower_idx += delta_idx;\n\n\t\t\t \n\t\t\tpower_idx = il3945_hw_reg_fix_power_idx(power_idx);\n\t\t\tch_info->power_info[rate_idx].power_table_idx =\n\t\t\t    (u8) power_idx;\n\t\t\tch_info->power_info[rate_idx].tpc =\n\t\t\t    power_gain_table[a_band][power_idx];\n\t\t}\n\n\t\t \n\t\tclip_pwrs =\n\t\t    il->_3945.clip_groups[ch_info->group_idx].clip_powers;\n\n\t\t \n\t\tfor (scan_tbl_idx = 0; scan_tbl_idx < IL_NUM_SCAN_RATES;\n\t\t     scan_tbl_idx++) {\n\t\t\ts32 actual_idx =\n\t\t\t    (scan_tbl_idx ==\n\t\t\t     0) ? RATE_1M_IDX_TBL : RATE_6M_IDX_TBL;\n\t\t\til3945_hw_reg_set_scan_power(il, scan_tbl_idx,\n\t\t\t\t\t\t     actual_idx, clip_pwrs,\n\t\t\t\t\t\t     ch_info, a_band);\n\t\t}\n\t}\n\n\t \n\treturn il->ops->send_tx_power(il);\n}\n\nint\nil3945_hw_reg_set_txpower(struct il_priv *il, s8 power)\n{\n\tstruct il_channel_info *ch_info;\n\ts8 max_power;\n\tu8 i;\n\n\tif (il->tx_power_user_lmt == power) {\n\t\tD_POWER(\"Requested Tx power same as current \" \"limit: %ddBm.\\n\",\n\t\t\tpower);\n\t\treturn 0;\n\t}\n\n\tD_POWER(\"Setting upper limit clamp to %ddBm.\\n\", power);\n\til->tx_power_user_lmt = power;\n\n\t \n\n\tfor (i = 0; i < il->channel_count; i++) {\n\t\tch_info = &il->channel_info[i];\n\n\t\t \n\t\tmax_power = il3945_hw_reg_get_ch_txpower_limit(ch_info);\n\t\tmax_power = min(power, max_power);\n\t\tif (max_power != ch_info->curr_txpow) {\n\t\t\tch_info->curr_txpow = max_power;\n\n\t\t\t \n\t\t\til3945_hw_reg_set_new_power(il, ch_info);\n\t\t}\n\t}\n\n\t \n\til3945_is_temp_calib_needed(il);\n\til3945_hw_reg_comp_txpower_temp(il);\n\n\treturn 0;\n}\n\nstatic int\nil3945_send_rxon_assoc(struct il_priv *il)\n{\n\tint rc = 0;\n\tstruct il_rx_pkt *pkt;\n\tstruct il3945_rxon_assoc_cmd rxon_assoc;\n\tstruct il_host_cmd cmd = {\n\t\t.id = C_RXON_ASSOC,\n\t\t.len = sizeof(rxon_assoc),\n\t\t.flags = CMD_WANT_SKB,\n\t\t.data = &rxon_assoc,\n\t};\n\tconst struct il_rxon_cmd *rxon1 = &il->staging;\n\tconst struct il_rxon_cmd *rxon2 = &il->active;\n\n\tif (rxon1->flags == rxon2->flags &&\n\t    rxon1->filter_flags == rxon2->filter_flags &&\n\t    rxon1->cck_basic_rates == rxon2->cck_basic_rates &&\n\t    rxon1->ofdm_basic_rates == rxon2->ofdm_basic_rates) {\n\t\tD_INFO(\"Using current RXON_ASSOC.  Not resending.\\n\");\n\t\treturn 0;\n\t}\n\n\trxon_assoc.flags = il->staging.flags;\n\trxon_assoc.filter_flags = il->staging.filter_flags;\n\trxon_assoc.ofdm_basic_rates = il->staging.ofdm_basic_rates;\n\trxon_assoc.cck_basic_rates = il->staging.cck_basic_rates;\n\trxon_assoc.reserved = 0;\n\n\trc = il_send_cmd_sync(il, &cmd);\n\tif (rc)\n\t\treturn rc;\n\n\tpkt = (struct il_rx_pkt *)cmd.reply_page;\n\tif (pkt->hdr.flags & IL_CMD_FAILED_MSK) {\n\t\tIL_ERR(\"Bad return from C_RXON_ASSOC command\\n\");\n\t\trc = -EIO;\n\t}\n\n\til_free_pages(il, cmd.reply_page);\n\n\treturn rc;\n}\n\n \nint\nil3945_commit_rxon(struct il_priv *il)\n{\n\t \n\tstruct il3945_rxon_cmd *active_rxon = (void *)&il->active;\n\tstruct il3945_rxon_cmd *staging_rxon = (void *)&il->staging;\n\tint rc = 0;\n\tbool new_assoc = !!(staging_rxon->filter_flags & RXON_FILTER_ASSOC_MSK);\n\n\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\treturn -EINVAL;\n\n\tif (!il_is_alive(il))\n\t\treturn -1;\n\n\t \n\tstaging_rxon->flags |= RXON_FLG_TSF2HOST_MSK;\n\n\t \n\tstaging_rxon->flags &= ~(RXON_FLG_DIS_DIV_MSK | RXON_FLG_ANT_SEL_MSK);\n\tstaging_rxon->flags |= il3945_get_antenna_flags(il);\n\n\trc = il_check_rxon_cmd(il);\n\tif (rc) {\n\t\tIL_ERR(\"Invalid RXON configuration.  Not committing.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!il_full_rxon_required(il)) {\n\t\trc = il_send_rxon_assoc(il);\n\t\tif (rc) {\n\t\t\tIL_ERR(\"Error setting RXON_ASSOC \"\n\t\t\t       \"configuration (%d).\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\tmemcpy(active_rxon, staging_rxon, sizeof(*active_rxon));\n\t\t \n\t\til_set_tx_power(il, il->tx_power_next, false);\n\t\treturn 0;\n\t}\n\n\t \n\tif (il_is_associated(il) && new_assoc) {\n\t\tD_INFO(\"Toggling associated bit on current RXON\\n\");\n\t\tactive_rxon->filter_flags &= ~RXON_FILTER_ASSOC_MSK;\n\n\t\t \n\t\tactive_rxon->reserved4 = 0;\n\t\tactive_rxon->reserved5 = 0;\n\t\trc = il_send_cmd_pdu(il, C_RXON, sizeof(struct il3945_rxon_cmd),\n\t\t\t\t     &il->active);\n\n\t\t \n\t\tif (rc) {\n\t\t\tactive_rxon->filter_flags |= RXON_FILTER_ASSOC_MSK;\n\t\t\tIL_ERR(\"Error clearing ASSOC_MSK on current \"\n\t\t\t       \"configuration (%d).\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t\til_clear_ucode_stations(il);\n\t\til_restore_stations(il);\n\t}\n\n\tD_INFO(\"Sending RXON\\n\" \"* with%s RXON_FILTER_ASSOC_MSK\\n\"\n\t       \"* channel = %d\\n\" \"* bssid = %pM\\n\", (new_assoc ? \"\" : \"out\"),\n\t       le16_to_cpu(staging_rxon->channel), staging_rxon->bssid_addr);\n\n\t \n\tstaging_rxon->reserved4 = 0;\n\tstaging_rxon->reserved5 = 0;\n\n\til_set_rxon_hwcrypto(il, !il3945_mod_params.sw_crypto);\n\n\t \n\trc = il_send_cmd_pdu(il, C_RXON, sizeof(struct il3945_rxon_cmd),\n\t\t\t     staging_rxon);\n\tif (rc) {\n\t\tIL_ERR(\"Error setting new configuration (%d).\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tmemcpy(active_rxon, staging_rxon, sizeof(*active_rxon));\n\n\tif (!new_assoc) {\n\t\til_clear_ucode_stations(il);\n\t\til_restore_stations(il);\n\t}\n\n\t \n\trc = il_set_tx_power(il, il->tx_power_next, true);\n\tif (rc) {\n\t\tIL_ERR(\"Error setting Tx power (%d).\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t \n\trc = il3945_init_hw_rate_table(il);\n\tif (rc) {\n\t\tIL_ERR(\"Error setting HW rate table: %02X\\n\", rc);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nvoid\nil3945_reg_txpower_periodic(struct il_priv *il)\n{\n\t \n\tif (!il3945_is_temp_calib_needed(il))\n\t\tgoto reschedule;\n\n\t \n\til3945_hw_reg_comp_txpower_temp(il);\n\nreschedule:\n\tqueue_delayed_work(il->workqueue, &il->_3945.thermal_periodic,\n\t\t\t   REG_RECALIB_PERIOD * HZ);\n}\n\nstatic void\nil3945_bg_reg_txpower_periodic(struct work_struct *work)\n{\n\tstruct il_priv *il = container_of(work, struct il_priv,\n\t\t\t\t\t  _3945.thermal_periodic.work);\n\n\tmutex_lock(&il->mutex);\n\tif (test_bit(S_EXIT_PENDING, &il->status) || il->txq == NULL)\n\t\tgoto out;\n\n\til3945_reg_txpower_periodic(il);\nout:\n\tmutex_unlock(&il->mutex);\n}\n\n \nstatic u16\nil3945_hw_reg_get_ch_grp_idx(struct il_priv *il,\n\t\t\t     const struct il_channel_info *ch_info)\n{\n\tstruct il3945_eeprom *eeprom = (struct il3945_eeprom *)il->eeprom;\n\tstruct il3945_eeprom_txpower_group *ch_grp = &eeprom->groups[0];\n\tu8 group;\n\tu16 group_idx = 0;\t \n\tu8 grp_channel;\n\n\t \n\tif (il_is_channel_a_band(ch_info)) {\n\t\tfor (group = 1; group < 5; group++) {\n\t\t\tgrp_channel = ch_grp[group].group_channel;\n\t\t\tif (ch_info->channel <= grp_channel) {\n\t\t\t\tgroup_idx = group;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (group == 5)\n\t\t\tgroup_idx = 4;\n\t} else\n\t\tgroup_idx = 0;\t \n\n\tD_POWER(\"Chnl %d mapped to grp %d\\n\", ch_info->channel, group_idx);\n\treturn group_idx;\n}\n\n \nstatic int\nil3945_hw_reg_get_matched_power_idx(struct il_priv *il, s8 requested_power,\n\t\t\t\t    s32 setting_idx, s32 *new_idx)\n{\n\tconst struct il3945_eeprom_txpower_group *chnl_grp = NULL;\n\tstruct il3945_eeprom *eeprom = (struct il3945_eeprom *)il->eeprom;\n\ts32 idx0, idx1;\n\ts32 power = 2 * requested_power;\n\ts32 i;\n\tconst struct il3945_eeprom_txpower_sample *samples;\n\ts32 gains0, gains1;\n\ts32 res;\n\ts32 denominator;\n\n\tchnl_grp = &eeprom->groups[setting_idx];\n\tsamples = chnl_grp->samples;\n\tfor (i = 0; i < 5; i++) {\n\t\tif (power == samples[i].power) {\n\t\t\t*new_idx = samples[i].gain_idx;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (power > samples[1].power) {\n\t\tidx0 = 0;\n\t\tidx1 = 1;\n\t} else if (power > samples[2].power) {\n\t\tidx0 = 1;\n\t\tidx1 = 2;\n\t} else if (power > samples[3].power) {\n\t\tidx0 = 2;\n\t\tidx1 = 3;\n\t} else {\n\t\tidx0 = 3;\n\t\tidx1 = 4;\n\t}\n\n\tdenominator = (s32) samples[idx1].power - (s32) samples[idx0].power;\n\tif (denominator == 0)\n\t\treturn -EINVAL;\n\tgains0 = (s32) samples[idx0].gain_idx * (1 << 19);\n\tgains1 = (s32) samples[idx1].gain_idx * (1 << 19);\n\tres =\n\t    gains0 + (gains1 - gains0) * ((s32) power -\n\t\t\t\t\t  (s32) samples[idx0].power) /\n\t    denominator + (1 << 18);\n\t*new_idx = res >> 19;\n\treturn 0;\n}\n\nstatic void\nil3945_hw_reg_init_channel_groups(struct il_priv *il)\n{\n\tu32 i;\n\ts32 rate_idx;\n\tstruct il3945_eeprom *eeprom = (struct il3945_eeprom *)il->eeprom;\n\tconst struct il3945_eeprom_txpower_group *group;\n\n\tD_POWER(\"Initializing factory calib info from EEPROM\\n\");\n\n\tfor (i = 0; i < IL_NUM_TX_CALIB_GROUPS; i++) {\n\t\ts8 *clip_pwrs;\t \n\t\ts8 satur_pwr;\t \n\t\tgroup = &eeprom->groups[i];\n\n\t\t \n\t\tif (group->saturation_power < 40) {\n\t\t\tIL_WARN(\"Error: saturation power is %d, \"\n\t\t\t\t\"less than minimum expected 40\\n\",\n\t\t\t\tgroup->saturation_power);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\t \n\t\tclip_pwrs = (s8 *) il->_3945.clip_groups[i].clip_powers;\n\n\t\t \n\t\tsatur_pwr = (s8) (group->saturation_power >> 1);\n\n\t\t \n\t\tfor (rate_idx = 0; rate_idx < RATE_COUNT_3945;\n\t\t     rate_idx++, clip_pwrs++) {\n\t\t\tswitch (rate_idx) {\n\t\t\tcase RATE_36M_IDX_TBL:\n\t\t\t\tif (i == 0)\t \n\t\t\t\t\t*clip_pwrs = satur_pwr;\n\t\t\t\telse\t \n\t\t\t\t\t*clip_pwrs = satur_pwr - 5;\n\t\t\t\tbreak;\n\t\t\tcase RATE_48M_IDX_TBL:\n\t\t\t\tif (i == 0)\n\t\t\t\t\t*clip_pwrs = satur_pwr - 7;\n\t\t\t\telse\n\t\t\t\t\t*clip_pwrs = satur_pwr - 10;\n\t\t\t\tbreak;\n\t\t\tcase RATE_54M_IDX_TBL:\n\t\t\t\tif (i == 0)\n\t\t\t\t\t*clip_pwrs = satur_pwr - 9;\n\t\t\t\telse\n\t\t\t\t\t*clip_pwrs = satur_pwr - 12;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*clip_pwrs = satur_pwr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nint\nil3945_txpower_set_from_eeprom(struct il_priv *il)\n{\n\tstruct il_channel_info *ch_info = NULL;\n\tstruct il3945_channel_power_info *pwr_info;\n\tstruct il3945_eeprom *eeprom = (struct il3945_eeprom *)il->eeprom;\n\tint delta_idx;\n\tu8 rate_idx;\n\tu8 scan_tbl_idx;\n\tconst s8 *clip_pwrs;\t \n\tu8 gain, dsp_atten;\n\ts8 power;\n\tu8 pwr_idx, base_pwr_idx, a_band;\n\tu8 i;\n\tint temperature;\n\n\t \n\ttemperature = il3945_hw_reg_txpower_get_temperature(il);\n\til->last_temperature = temperature;\n\n\til3945_hw_reg_init_channel_groups(il);\n\n\t \n\tfor (i = 0, ch_info = il->channel_info; i < il->channel_count;\n\t     i++, ch_info++) {\n\t\ta_band = il_is_channel_a_band(ch_info);\n\t\tif (!il_is_channel_valid(ch_info))\n\t\t\tcontinue;\n\n\t\t \n\t\tch_info->group_idx = il3945_hw_reg_get_ch_grp_idx(il, ch_info);\n\n\t\t \n\t\tclip_pwrs =\n\t\t    il->_3945.clip_groups[ch_info->group_idx].clip_powers;\n\n\t\t \n\t\tdelta_idx =\n\t\t    il3945_hw_reg_adjust_power_by_temp(temperature,\n\t\t\t\t\t\t       eeprom->groups[ch_info->\n\t\t\t\t\t\t\t\t      group_idx].\n\t\t\t\t\t\t       temperature);\n\n\t\tD_POWER(\"Delta idx for channel %d: %d [%d]\\n\", ch_info->channel,\n\t\t\tdelta_idx, temperature + IL_TEMP_CONVERT);\n\n\t\t \n\t\tfor (rate_idx = 0; rate_idx < IL_OFDM_RATES; rate_idx++) {\n\t\t\ts32 power_idx;\n\t\t\tint rc;\n\n\t\t\t \n\t\t\ts8 pwr = min(ch_info->max_power_avg,\n\t\t\t\t     clip_pwrs[rate_idx]);\n\n\t\t\tpwr_info = &ch_info->power_info[rate_idx];\n\n\t\t\t \n\t\t\trc = il3945_hw_reg_get_matched_power_idx(il, pwr,\n\t\t\t\t\t\t\t\t ch_info->\n\t\t\t\t\t\t\t\t group_idx,\n\t\t\t\t\t\t\t\t &power_idx);\n\t\t\tif (rc) {\n\t\t\t\tIL_ERR(\"Invalid power idx\\n\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tpwr_info->base_power_idx = (u8) power_idx;\n\n\t\t\t \n\t\t\tpower_idx += delta_idx;\n\n\t\t\t \n\t\t\tpower_idx = il3945_hw_reg_fix_power_idx(power_idx);\n\n\t\t\t \n\t\t\tpwr_info->requested_power = pwr;\n\t\t\tpwr_info->power_table_idx = (u8) power_idx;\n\t\t\tpwr_info->tpc.tx_gain =\n\t\t\t    power_gain_table[a_band][power_idx].tx_gain;\n\t\t\tpwr_info->tpc.dsp_atten =\n\t\t\t    power_gain_table[a_band][power_idx].dsp_atten;\n\t\t}\n\n\t\t \n\t\tpwr_info = &ch_info->power_info[RATE_12M_IDX_TBL];\n\t\tpower = pwr_info->requested_power + IL_CCK_FROM_OFDM_POWER_DIFF;\n\t\tpwr_idx = pwr_info->power_table_idx + IL_CCK_FROM_OFDM_IDX_DIFF;\n\t\tbase_pwr_idx =\n\t\t    pwr_info->base_power_idx + IL_CCK_FROM_OFDM_IDX_DIFF;\n\n\t\t \n\t\tpwr_idx = il3945_hw_reg_fix_power_idx(pwr_idx);\n\t\tgain = power_gain_table[a_band][pwr_idx].tx_gain;\n\t\tdsp_atten = power_gain_table[a_band][pwr_idx].dsp_atten;\n\n\t\t \n\t\tfor (rate_idx = 0; rate_idx < IL_CCK_RATES; rate_idx++) {\n\t\t\tpwr_info =\n\t\t\t    &ch_info->power_info[rate_idx + IL_OFDM_RATES];\n\t\t\tpwr_info->requested_power = power;\n\t\t\tpwr_info->power_table_idx = pwr_idx;\n\t\t\tpwr_info->base_power_idx = base_pwr_idx;\n\t\t\tpwr_info->tpc.tx_gain = gain;\n\t\t\tpwr_info->tpc.dsp_atten = dsp_atten;\n\t\t}\n\n\t\t \n\t\tfor (scan_tbl_idx = 0; scan_tbl_idx < IL_NUM_SCAN_RATES;\n\t\t     scan_tbl_idx++) {\n\t\t\ts32 actual_idx =\n\t\t\t    (scan_tbl_idx ==\n\t\t\t     0) ? RATE_1M_IDX_TBL : RATE_6M_IDX_TBL;\n\t\t\til3945_hw_reg_set_scan_power(il, scan_tbl_idx,\n\t\t\t\t\t\t     actual_idx, clip_pwrs,\n\t\t\t\t\t\t     ch_info, a_band);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint\nil3945_hw_rxq_stop(struct il_priv *il)\n{\n\tint ret;\n\n\t_il_wr(il, FH39_RCSR_CONFIG(0), 0);\n\tret = _il_poll_bit(il, FH39_RSSR_STATUS,\n\t\t\t   FH39_RSSR_CHNL0_RX_STATUS_CHNL_IDLE,\n\t\t\t   FH39_RSSR_CHNL0_RX_STATUS_CHNL_IDLE,\n\t\t\t   1000);\n\tif (ret < 0)\n\t\tIL_ERR(\"Can't stop Rx DMA.\\n\");\n\n\treturn 0;\n}\n\nint\nil3945_hw_tx_queue_init(struct il_priv *il, struct il_tx_queue *txq)\n{\n\tint txq_id = txq->q.id;\n\n\tstruct il3945_shared *shared_data = il->_3945.shared_virt;\n\n\tshared_data->tx_base_ptr[txq_id] = cpu_to_le32((u32) txq->q.dma_addr);\n\n\til_wr(il, FH39_CBCC_CTRL(txq_id), 0);\n\til_wr(il, FH39_CBCC_BASE(txq_id), 0);\n\n\til_wr(il, FH39_TCSR_CONFIG(txq_id),\n\t      FH39_TCSR_TX_CONFIG_REG_VAL_CIRQ_RTC_NOINT |\n\t      FH39_TCSR_TX_CONFIG_REG_VAL_MSG_MODE_TXF |\n\t      FH39_TCSR_TX_CONFIG_REG_VAL_CIRQ_HOST_IFTFD |\n\t      FH39_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_ENABLE_VAL |\n\t      FH39_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_ENABLE);\n\n\t \n\t_il_rd(il, FH39_TSSR_CBB_BASE);\n\n\treturn 0;\n}\n\n \nstatic u16\nil3945_get_hcmd_size(u8 cmd_id, u16 len)\n{\n\tswitch (cmd_id) {\n\tcase C_RXON:\n\t\treturn sizeof(struct il3945_rxon_cmd);\n\tcase C_POWER_TBL:\n\t\treturn sizeof(struct il3945_powertable_cmd);\n\tdefault:\n\t\treturn len;\n\t}\n}\n\nstatic u16\nil3945_build_addsta_hcmd(const struct il_addsta_cmd *cmd, u8 * data)\n{\n\tstruct il3945_addsta_cmd *addsta = (struct il3945_addsta_cmd *)data;\n\taddsta->mode = cmd->mode;\n\tmemcpy(&addsta->sta, &cmd->sta, sizeof(struct sta_id_modify));\n\tmemcpy(&addsta->key, &cmd->key, sizeof(struct il4965_keyinfo));\n\taddsta->station_flags = cmd->station_flags;\n\taddsta->station_flags_msk = cmd->station_flags_msk;\n\taddsta->tid_disable_tx = cpu_to_le16(0);\n\taddsta->rate_n_flags = cmd->rate_n_flags;\n\taddsta->add_immediate_ba_tid = cmd->add_immediate_ba_tid;\n\taddsta->remove_immediate_ba_tid = cmd->remove_immediate_ba_tid;\n\taddsta->add_immediate_ba_ssn = cmd->add_immediate_ba_ssn;\n\n\treturn (u16) sizeof(struct il3945_addsta_cmd);\n}\n\nstatic int\nil3945_add_bssid_station(struct il_priv *il, const u8 * addr, u8 * sta_id_r)\n{\n\tint ret;\n\tu8 sta_id;\n\tunsigned long flags;\n\n\tif (sta_id_r)\n\t\t*sta_id_r = IL_INVALID_STATION;\n\n\tret = il_add_station_common(il, addr, 0, NULL, &sta_id);\n\tif (ret) {\n\t\tIL_ERR(\"Unable to add station %pM\\n\", addr);\n\t\treturn ret;\n\t}\n\n\tif (sta_id_r)\n\t\t*sta_id_r = sta_id;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\til->stations[sta_id].used |= IL_STA_LOCAL;\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\treturn 0;\n}\n\nstatic int\nil3945_manage_ibss_station(struct il_priv *il, struct ieee80211_vif *vif,\n\t\t\t   bool add)\n{\n\tstruct il_vif_priv *vif_priv = (void *)vif->drv_priv;\n\tint ret;\n\n\tif (add) {\n\t\tret =\n\t\t    il3945_add_bssid_station(il, vif->bss_conf.bssid,\n\t\t\t\t\t     &vif_priv->ibss_bssid_sta_id);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\til3945_sync_sta(il, vif_priv->ibss_bssid_sta_id,\n\t\t\t\t(il->band ==\n\t\t\t\t NL80211_BAND_5GHZ) ? RATE_6M_PLCP :\n\t\t\t\tRATE_1M_PLCP);\n\t\til3945_rate_scale_init(il->hw, vif_priv->ibss_bssid_sta_id);\n\n\t\treturn 0;\n\t}\n\n\treturn il_remove_station(il, vif_priv->ibss_bssid_sta_id,\n\t\t\t\t vif->bss_conf.bssid);\n}\n\n \nint\nil3945_init_hw_rate_table(struct il_priv *il)\n{\n\tint rc, i, idx, prev_idx;\n\tstruct il3945_rate_scaling_cmd rate_cmd = {\n\t\t.reserved = {0, 0, 0},\n\t};\n\tstruct il3945_rate_scaling_info *table = rate_cmd.table;\n\n\tfor (i = 0; i < ARRAY_SIZE(il3945_rates); i++) {\n\t\tidx = il3945_rates[i].table_rs_idx;\n\n\t\ttable[idx].rate_n_flags = cpu_to_le16(il3945_rates[i].plcp);\n\t\ttable[idx].try_cnt = il->retry_rate;\n\t\tprev_idx = il3945_get_prev_ieee_rate(i);\n\t\ttable[idx].next_rate_idx = il3945_rates[prev_idx].table_rs_idx;\n\t}\n\n\tswitch (il->band) {\n\tcase NL80211_BAND_5GHZ:\n\t\tD_RATE(\"Select A mode rate scale\\n\");\n\t\t \n\t\tfor (i = RATE_1M_IDX_TBL; i <= RATE_11M_IDX_TBL; i++)\n\t\t\ttable[i].next_rate_idx =\n\t\t\t    il3945_rates[IL_FIRST_OFDM_RATE].table_rs_idx;\n\n\t\t \n\t\ttable[RATE_12M_IDX_TBL].next_rate_idx = RATE_9M_IDX_TBL;\n\n\t\t \n\t\ttable[RATE_6M_IDX_TBL].next_rate_idx =\n\t\t    il3945_rates[IL_FIRST_OFDM_RATE].table_rs_idx;\n\t\tbreak;\n\n\tcase NL80211_BAND_2GHZ:\n\t\tD_RATE(\"Select B/G mode rate scale\\n\");\n\t\t \n\n\t\tif (!(il->_3945.sta_supp_rates & IL_OFDM_RATES_MASK) &&\n\t\t    il_is_associated(il)) {\n\n\t\t\tidx = IL_FIRST_CCK_RATE;\n\t\t\tfor (i = RATE_6M_IDX_TBL; i <= RATE_54M_IDX_TBL; i++)\n\t\t\t\ttable[i].next_rate_idx =\n\t\t\t\t    il3945_rates[idx].table_rs_idx;\n\n\t\t\tidx = RATE_11M_IDX_TBL;\n\t\t\t \n\t\t\ttable[idx].next_rate_idx = RATE_5M_IDX_TBL;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\t \n\trate_cmd.table_id = 0;\n\trc = il_send_cmd_pdu(il, C_RATE_SCALE, sizeof(rate_cmd), &rate_cmd);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trate_cmd.table_id = 1;\n\treturn il_send_cmd_pdu(il, C_RATE_SCALE, sizeof(rate_cmd), &rate_cmd);\n}\n\n \nint\nil3945_hw_set_hw_params(struct il_priv *il)\n{\n\tmemset((void *)&il->hw_params, 0, sizeof(struct il_hw_params));\n\n\til->_3945.shared_virt =\n\t    dma_alloc_coherent(&il->pci_dev->dev, sizeof(struct il3945_shared),\n\t\t\t       &il->_3945.shared_phys, GFP_KERNEL);\n\tif (!il->_3945.shared_virt)\n\t\treturn -ENOMEM;\n\n\til->hw_params.bcast_id = IL3945_BROADCAST_ID;\n\n\t \n\til->hw_params.max_txq_num = il->cfg->num_of_queues;\n\n\til->hw_params.tfd_size = sizeof(struct il3945_tfd);\n\til->hw_params.rx_page_order = get_order(IL_RX_BUF_SIZE_3K);\n\til->hw_params.max_rxq_size = RX_QUEUE_SIZE;\n\til->hw_params.max_rxq_log = RX_QUEUE_SIZE_LOG;\n\til->hw_params.max_stations = IL3945_STATION_COUNT;\n\n\til->sta_key_max_num = STA_KEY_MAX_NUM;\n\n\til->hw_params.rx_wrt_ptr_reg = FH39_RSCSR_CHNL0_WPTR;\n\til->hw_params.max_beacon_itrvl = IL39_MAX_UCODE_BEACON_INTERVAL;\n\til->hw_params.beacon_time_tsf_bits = IL3945_EXT_BEACON_TIME_POS;\n\n\treturn 0;\n}\n\nunsigned int\nil3945_hw_get_beacon_cmd(struct il_priv *il, struct il3945_frame *frame,\n\t\t\t u8 rate)\n{\n\tstruct il3945_tx_beacon_cmd *tx_beacon_cmd;\n\tunsigned int frame_size;\n\n\ttx_beacon_cmd = (struct il3945_tx_beacon_cmd *)&frame->u;\n\tmemset(tx_beacon_cmd, 0, sizeof(*tx_beacon_cmd));\n\n\ttx_beacon_cmd->tx.sta_id = il->hw_params.bcast_id;\n\ttx_beacon_cmd->tx.stop_time.life_time = TX_CMD_LIFE_TIME_INFINITE;\n\n\tframe_size =\n\t    il3945_fill_beacon_frame(il, tx_beacon_cmd->frame,\n\t\t\t\t     sizeof(frame->u) - sizeof(*tx_beacon_cmd));\n\n\tBUG_ON(frame_size > MAX_MPDU_SIZE);\n\ttx_beacon_cmd->tx.len = cpu_to_le16((u16) frame_size);\n\n\ttx_beacon_cmd->tx.rate = rate;\n\ttx_beacon_cmd->tx.tx_flags =\n\t    (TX_CMD_FLG_SEQ_CTL_MSK | TX_CMD_FLG_TSF_MSK);\n\n\t \n\ttx_beacon_cmd->tx.supp_rates[0] =\n\t    (IL_OFDM_BASIC_RATES_MASK >> IL_FIRST_OFDM_RATE) & 0xFF;\n\n\ttx_beacon_cmd->tx.supp_rates[1] = (IL_CCK_BASIC_RATES_MASK & 0xF);\n\n\treturn sizeof(struct il3945_tx_beacon_cmd) + frame_size;\n}\n\nvoid\nil3945_hw_handler_setup(struct il_priv *il)\n{\n\til->handlers[C_TX] = il3945_hdl_tx;\n\til->handlers[N_3945_RX] = il3945_hdl_rx;\n}\n\nvoid\nil3945_hw_setup_deferred_work(struct il_priv *il)\n{\n\tINIT_DELAYED_WORK(&il->_3945.thermal_periodic,\n\t\t\t  il3945_bg_reg_txpower_periodic);\n}\n\nvoid\nil3945_hw_cancel_deferred_work(struct il_priv *il)\n{\n\tcancel_delayed_work(&il->_3945.thermal_periodic);\n}\n\n \nstatic int\nil3945_verify_bsm(struct il_priv *il)\n{\n\t__le32 *image = il->ucode_boot.v_addr;\n\tu32 len = il->ucode_boot.len;\n\tu32 reg;\n\tu32 val;\n\n\tD_INFO(\"Begin verify bsm\\n\");\n\n\t \n\tval = il_rd_prph(il, BSM_WR_DWCOUNT_REG);\n\tfor (reg = BSM_SRAM_LOWER_BOUND; reg < BSM_SRAM_LOWER_BOUND + len;\n\t     reg += sizeof(u32), image++) {\n\t\tval = il_rd_prph(il, reg);\n\t\tif (val != le32_to_cpu(*image)) {\n\t\t\tIL_ERR(\"BSM uCode verification failed at \"\n\t\t\t       \"addr 0x%08X+%u (of %u), is 0x%x, s/b 0x%x\\n\",\n\t\t\t       BSM_SRAM_LOWER_BOUND, reg - BSM_SRAM_LOWER_BOUND,\n\t\t\t       len, val, le32_to_cpu(*image));\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tD_INFO(\"BSM bootstrap uCode image OK\\n\");\n\n\treturn 0;\n}\n\n \n\n \nstatic int\nil3945_eeprom_acquire_semaphore(struct il_priv *il)\n{\n\t_il_clear_bit(il, CSR_EEPROM_GP, CSR_EEPROM_GP_IF_OWNER_MSK);\n\treturn 0;\n}\n\nstatic void\nil3945_eeprom_release_semaphore(struct il_priv *il)\n{\n\treturn;\n}\n\n  \nstatic int\nil3945_load_bsm(struct il_priv *il)\n{\n\t__le32 *image = il->ucode_boot.v_addr;\n\tu32 len = il->ucode_boot.len;\n\tdma_addr_t pinst;\n\tdma_addr_t pdata;\n\tu32 inst_len;\n\tu32 data_len;\n\tint rc;\n\tint i;\n\tu32 done;\n\tu32 reg_offset;\n\n\tD_INFO(\"Begin load bsm\\n\");\n\n\t \n\tif (len > IL39_MAX_BSM_SIZE)\n\t\treturn -EINVAL;\n\n\t \n\tpinst = il->ucode_init.p_addr;\n\tpdata = il->ucode_init_data.p_addr;\n\tinst_len = il->ucode_init.len;\n\tdata_len = il->ucode_init_data.len;\n\n\til_wr_prph(il, BSM_DRAM_INST_PTR_REG, pinst);\n\til_wr_prph(il, BSM_DRAM_DATA_PTR_REG, pdata);\n\til_wr_prph(il, BSM_DRAM_INST_BYTECOUNT_REG, inst_len);\n\til_wr_prph(il, BSM_DRAM_DATA_BYTECOUNT_REG, data_len);\n\n\t \n\tfor (reg_offset = BSM_SRAM_LOWER_BOUND;\n\t     reg_offset < BSM_SRAM_LOWER_BOUND + len;\n\t     reg_offset += sizeof(u32), image++)\n\t\t_il_wr_prph(il, reg_offset, le32_to_cpu(*image));\n\n\trc = il3945_verify_bsm(il);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\til_wr_prph(il, BSM_WR_MEM_SRC_REG, 0x0);\n\til_wr_prph(il, BSM_WR_MEM_DST_REG, IL39_RTC_INST_LOWER_BOUND);\n\til_wr_prph(il, BSM_WR_DWCOUNT_REG, len / sizeof(u32));\n\n\t \n\til_wr_prph(il, BSM_WR_CTRL_REG, BSM_WR_CTRL_REG_BIT_START);\n\n\t \n\tfor (i = 0; i < 100; i++) {\n\t\tdone = il_rd_prph(il, BSM_WR_CTRL_REG);\n\t\tif (!(done & BSM_WR_CTRL_REG_BIT_START))\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\tif (i < 100)\n\t\tD_INFO(\"BSM write complete, poll %d iterations\\n\", i);\n\telse {\n\t\tIL_ERR(\"BSM write did not complete!\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\til_wr_prph(il, BSM_WR_CTRL_REG, BSM_WR_CTRL_REG_BIT_START_EN);\n\n\treturn 0;\n}\n\nconst struct il_ops il3945_ops = {\n\t.txq_attach_buf_to_tfd = il3945_hw_txq_attach_buf_to_tfd,\n\t.txq_free_tfd = il3945_hw_txq_free_tfd,\n\t.txq_init = il3945_hw_tx_queue_init,\n\t.load_ucode = il3945_load_bsm,\n\t.dump_nic_error_log = il3945_dump_nic_error_log,\n\t.apm_init = il3945_apm_init,\n\t.send_tx_power = il3945_send_tx_power,\n\t.is_valid_rtc_data_addr = il3945_hw_valid_rtc_data_addr,\n\t.eeprom_acquire_semaphore = il3945_eeprom_acquire_semaphore,\n\t.eeprom_release_semaphore = il3945_eeprom_release_semaphore,\n\n\t.rxon_assoc = il3945_send_rxon_assoc,\n\t.commit_rxon = il3945_commit_rxon,\n\n\t.get_hcmd_size = il3945_get_hcmd_size,\n\t.build_addsta_hcmd = il3945_build_addsta_hcmd,\n\t.request_scan = il3945_request_scan,\n\t.post_scan = il3945_post_scan,\n\n\t.post_associate = il3945_post_associate,\n\t.config_ap = il3945_config_ap,\n\t.manage_ibss_station = il3945_manage_ibss_station,\n\n\t.send_led_cmd = il3945_send_led_cmd,\n};\n\nstatic const struct il_cfg il3945_bg_cfg = {\n\t.name = \"3945BG\",\n\t.fw_name_pre = IL3945_FW_PRE,\n\t.ucode_api_max = IL3945_UCODE_API_MAX,\n\t.ucode_api_min = IL3945_UCODE_API_MIN,\n\t.sku = IL_SKU_G,\n\t.eeprom_ver = EEPROM_3945_EEPROM_VERSION,\n\t.mod_params = &il3945_mod_params,\n\t.led_mode = IL_LED_BLINK,\n\n\t.eeprom_size = IL3945_EEPROM_IMG_SIZE,\n\t.num_of_queues = IL39_NUM_QUEUES,\n\t.pll_cfg_val = CSR39_ANA_PLL_CFG_VAL,\n\t.set_l0s = false,\n\t.use_bsm = true,\n\t.led_compensation = 64,\n\t.wd_timeout = IL_DEF_WD_TIMEOUT,\n\n\t.regulatory_bands = {\n\t\tEEPROM_REGULATORY_BAND_1_CHANNELS,\n\t\tEEPROM_REGULATORY_BAND_2_CHANNELS,\n\t\tEEPROM_REGULATORY_BAND_3_CHANNELS,\n\t\tEEPROM_REGULATORY_BAND_4_CHANNELS,\n\t\tEEPROM_REGULATORY_BAND_5_CHANNELS,\n\t\tEEPROM_REGULATORY_BAND_NO_HT40,\n\t\tEEPROM_REGULATORY_BAND_NO_HT40,\n\t},\n};\n\nstatic const struct il_cfg il3945_abg_cfg = {\n\t.name = \"3945ABG\",\n\t.fw_name_pre = IL3945_FW_PRE,\n\t.ucode_api_max = IL3945_UCODE_API_MAX,\n\t.ucode_api_min = IL3945_UCODE_API_MIN,\n\t.sku = IL_SKU_A | IL_SKU_G,\n\t.eeprom_ver = EEPROM_3945_EEPROM_VERSION,\n\t.mod_params = &il3945_mod_params,\n\t.led_mode = IL_LED_BLINK,\n\n\t.eeprom_size = IL3945_EEPROM_IMG_SIZE,\n\t.num_of_queues = IL39_NUM_QUEUES,\n\t.pll_cfg_val = CSR39_ANA_PLL_CFG_VAL,\n\t.set_l0s = false,\n\t.use_bsm = true,\n\t.led_compensation = 64,\n\t.wd_timeout = IL_DEF_WD_TIMEOUT,\n\n\t.regulatory_bands = {\n\t\tEEPROM_REGULATORY_BAND_1_CHANNELS,\n\t\tEEPROM_REGULATORY_BAND_2_CHANNELS,\n\t\tEEPROM_REGULATORY_BAND_3_CHANNELS,\n\t\tEEPROM_REGULATORY_BAND_4_CHANNELS,\n\t\tEEPROM_REGULATORY_BAND_5_CHANNELS,\n\t\tEEPROM_REGULATORY_BAND_NO_HT40,\n\t\tEEPROM_REGULATORY_BAND_NO_HT40,\n\t},\n};\n\nconst struct pci_device_id il3945_hw_card_ids[] = {\n\t{IL_PCI_DEVICE(0x4222, 0x1005, il3945_bg_cfg)},\n\t{IL_PCI_DEVICE(0x4222, 0x1034, il3945_bg_cfg)},\n\t{IL_PCI_DEVICE(0x4222, 0x1044, il3945_bg_cfg)},\n\t{IL_PCI_DEVICE(0x4227, 0x1014, il3945_bg_cfg)},\n\t{IL_PCI_DEVICE(0x4222, PCI_ANY_ID, il3945_abg_cfg)},\n\t{IL_PCI_DEVICE(0x4227, PCI_ANY_ID, il3945_abg_cfg)},\n\t{0}\n};\n\nMODULE_DEVICE_TABLE(pci, il3945_hw_card_ids);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}