{
  "module_name": "4965-rs.c",
  "hash_id": "4fde171483655532a2e0b45c9db012466d72e624eadb8694f4fd7a4f5b805cea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlegacy/4965-rs.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <net/mac80211.h>\n\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/delay.h>\n\n#include <linux/workqueue.h>\n\n#include \"common.h\"\n#include \"4965.h\"\n\n#define IL4965_RS_NAME \"iwl-4965-rs\"\n\n#define NUM_TRY_BEFORE_ANT_TOGGLE 1\n#define IL_NUMBER_TRY      1\n#define IL_HT_NUMBER_TRY   3\n\n#define RATE_MAX_WINDOW\t\t62\t \n#define RATE_MIN_FAILURE_TH\t\t6\t \n#define RATE_MIN_SUCCESS_TH\t\t8\t \n\n \n#define IL_MISSED_RATE_MAX\t\t15\n \n#define RATE_SCALE_FLUSH_INTVL   (3*HZ)\n\nstatic u8 rs_ht_to_legacy[] = {\n\tRATE_6M_IDX, RATE_6M_IDX,\n\tRATE_6M_IDX, RATE_6M_IDX,\n\tRATE_6M_IDX,\n\tRATE_6M_IDX, RATE_9M_IDX,\n\tRATE_12M_IDX, RATE_18M_IDX,\n\tRATE_24M_IDX, RATE_36M_IDX,\n\tRATE_48M_IDX, RATE_54M_IDX\n};\n\nstatic const u8 ant_toggle_lookup[] = {\n\t  ANT_NONE,\n\t  ANT_B,\n\t  ANT_C,\n\t  ANT_BC,\n\t  ANT_A,\n\t  ANT_AB,\n\t  ANT_AC,\n\t  ANT_ABC,\n};\n\n#define IL_DECLARE_RATE_INFO(r, s, ip, in, rp, rn, pp, np)    \\\n\t[RATE_##r##M_IDX] = { RATE_##r##M_PLCP,      \\\n\t\t\t\t    RATE_SISO_##s##M_PLCP, \\\n\t\t\t\t    RATE_MIMO2_##s##M_PLCP,\\\n\t\t\t\t    RATE_##r##M_IEEE,      \\\n\t\t\t\t    RATE_##ip##M_IDX,    \\\n\t\t\t\t    RATE_##in##M_IDX,    \\\n\t\t\t\t    RATE_##rp##M_IDX,    \\\n\t\t\t\t    RATE_##rn##M_IDX,    \\\n\t\t\t\t    RATE_##pp##M_IDX,    \\\n\t\t\t\t    RATE_##np##M_IDX }\n\n \nconst struct il_rate_info il_rates[RATE_COUNT] = {\n\tIL_DECLARE_RATE_INFO(1, INV, INV, 2, INV, 2, INV, 2),\t \n\tIL_DECLARE_RATE_INFO(2, INV, 1, 5, 1, 5, 1, 5),\t\t \n\tIL_DECLARE_RATE_INFO(5, INV, 2, 6, 2, 11, 2, 11),\t \n\tIL_DECLARE_RATE_INFO(11, INV, 9, 12, 9, 12, 5, 18),\t \n\tIL_DECLARE_RATE_INFO(6, 6, 5, 9, 5, 11, 5, 11),\t\t \n\tIL_DECLARE_RATE_INFO(9, 6, 6, 11, 6, 11, 5, 11),\t \n\tIL_DECLARE_RATE_INFO(12, 12, 11, 18, 11, 18, 11, 18),\t \n\tIL_DECLARE_RATE_INFO(18, 18, 12, 24, 12, 24, 11, 24),\t \n\tIL_DECLARE_RATE_INFO(24, 24, 18, 36, 18, 36, 18, 36),\t \n\tIL_DECLARE_RATE_INFO(36, 36, 24, 48, 24, 48, 24, 48),\t \n\tIL_DECLARE_RATE_INFO(48, 48, 36, 54, 36, 54, 36, 54),\t \n\tIL_DECLARE_RATE_INFO(54, 54, 48, INV, 48, INV, 48, INV), \n\tIL_DECLARE_RATE_INFO(60, 60, 48, INV, 48, INV, 48, INV), \n};\n\nstatic int\nil4965_hwrate_to_plcp_idx(u32 rate_n_flags)\n{\n\tint idx = 0;\n\n\t \n\tif (rate_n_flags & RATE_MCS_HT_MSK) {\n\t\tidx = (rate_n_flags & 0xff);\n\n\t\tif (idx >= RATE_MIMO2_6M_PLCP)\n\t\t\tidx = idx - RATE_MIMO2_6M_PLCP;\n\n\t\tidx += IL_FIRST_OFDM_RATE;\n\t\t \n\t\tif (idx >= RATE_9M_IDX)\n\t\t\tidx += 1;\n\t\tif (idx >= IL_FIRST_OFDM_RATE && idx <= IL_LAST_OFDM_RATE)\n\t\t\treturn idx;\n\n\t\t \n\t} else {\n\t\tfor (idx = 0; idx < ARRAY_SIZE(il_rates); idx++)\n\t\t\tif (il_rates[idx].plcp == (rate_n_flags & 0xFF))\n\t\t\t\treturn idx;\n\t}\n\n\treturn -1;\n}\n\nstatic void il4965_rs_rate_scale_perform(struct il_priv *il,\n\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t\t struct il_lq_sta *lq_sta);\nstatic void il4965_rs_fill_link_cmd(struct il_priv *il,\n\t\t\t\t    struct il_lq_sta *lq_sta, u32 rate_n_flags);\nstatic void il4965_rs_stay_in_table(struct il_lq_sta *lq_sta,\n\t\t\t\t    bool force_search);\n\n#ifdef CONFIG_MAC80211_DEBUGFS\nstatic void il4965_rs_dbgfs_set_mcs(struct il_lq_sta *lq_sta,\n\t\t\t\t    u32 *rate_n_flags, int idx);\n#else\nstatic void\nil4965_rs_dbgfs_set_mcs(struct il_lq_sta *lq_sta, u32 * rate_n_flags, int idx)\n{\n}\n#endif\n\n \n\nstatic s32 expected_tpt_legacy[RATE_COUNT] = {\n\t7, 13, 35, 58, 40, 57, 72, 98, 121, 154, 177, 186, 0\n};\n\nstatic s32 expected_tpt_siso20MHz[4][RATE_COUNT] = {\n\t{0, 0, 0, 0, 42, 0, 76, 102, 124, 158, 183, 193, 202},\t \n\t{0, 0, 0, 0, 46, 0, 82, 110, 132, 167, 192, 202, 210},\t \n\t{0, 0, 0, 0, 48, 0, 93, 135, 176, 251, 319, 351, 381},\t \n\t{0, 0, 0, 0, 53, 0, 102, 149, 193, 275, 348, 381, 413},\t \n};\n\nstatic s32 expected_tpt_siso40MHz[4][RATE_COUNT] = {\n\t{0, 0, 0, 0, 77, 0, 127, 160, 184, 220, 242, 250, 257},\t \n\t{0, 0, 0, 0, 83, 0, 135, 169, 193, 229, 250, 257, 264},\t \n\t{0, 0, 0, 0, 96, 0, 182, 259, 328, 451, 553, 598, 640},\t \n\t{0, 0, 0, 0, 106, 0, 199, 282, 357, 487, 593, 640, 683},\t \n};\n\nstatic s32 expected_tpt_mimo2_20MHz[4][RATE_COUNT] = {\n\t{0, 0, 0, 0, 74, 0, 123, 155, 179, 213, 235, 243, 250},\t \n\t{0, 0, 0, 0, 81, 0, 131, 164, 187, 221, 242, 250, 256},\t \n\t{0, 0, 0, 0, 92, 0, 175, 250, 317, 436, 534, 578, 619},\t \n\t{0, 0, 0, 0, 102, 0, 192, 273, 344, 470, 573, 619, 660},\t \n};\n\nstatic s32 expected_tpt_mimo2_40MHz[4][RATE_COUNT] = {\n\t{0, 0, 0, 0, 123, 0, 182, 214, 235, 264, 279, 285, 289},\t \n\t{0, 0, 0, 0, 131, 0, 191, 222, 242, 270, 284, 289, 293},\t \n\t{0, 0, 0, 0, 180, 0, 327, 446, 545, 708, 828, 878, 922},\t \n\t{0, 0, 0, 0, 197, 0, 355, 481, 584, 752, 872, 922, 966},\t \n};\n\n \nstatic const struct il_rate_mcs_info il_rate_mcs[RATE_COUNT] = {\n\t{\"1\", \"BPSK DSSS\"},\n\t{\"2\", \"QPSK DSSS\"},\n\t{\"5.5\", \"BPSK CCK\"},\n\t{\"11\", \"QPSK CCK\"},\n\t{\"6\", \"BPSK 1/2\"},\n\t{\"9\", \"BPSK 1/2\"},\n\t{\"12\", \"QPSK 1/2\"},\n\t{\"18\", \"QPSK 3/4\"},\n\t{\"24\", \"16QAM 1/2\"},\n\t{\"36\", \"16QAM 3/4\"},\n\t{\"48\", \"64QAM 2/3\"},\n\t{\"54\", \"64QAM 3/4\"},\n\t{\"60\", \"64QAM 5/6\"},\n};\n\n#define MCS_IDX_PER_STREAM\t(8)\n\nstatic inline u8\nil4965_rs_extract_rate(u32 rate_n_flags)\n{\n\treturn (u8) (rate_n_flags & 0xFF);\n}\n\nstatic void\nil4965_rs_rate_scale_clear_win(struct il_rate_scale_data *win)\n{\n\twin->data = 0;\n\twin->success_counter = 0;\n\twin->success_ratio = IL_INVALID_VALUE;\n\twin->counter = 0;\n\twin->average_tpt = IL_INVALID_VALUE;\n\twin->stamp = 0;\n}\n\nstatic inline u8\nil4965_rs_is_valid_ant(u8 valid_antenna, u8 ant_type)\n{\n\treturn (ant_type & valid_antenna) == ant_type;\n}\n\n \nstatic void\nil4965_rs_tl_rm_old_stats(struct il_traffic_load *tl, u32 curr_time)\n{\n\t \n\tu32 oldest_time = curr_time - TID_MAX_TIME_DIFF;\n\n\twhile (tl->queue_count && tl->time_stamp < oldest_time) {\n\t\ttl->total -= tl->packet_count[tl->head];\n\t\ttl->packet_count[tl->head] = 0;\n\t\ttl->time_stamp += TID_QUEUE_CELL_SPACING;\n\t\ttl->queue_count--;\n\t\ttl->head++;\n\t\tif (tl->head >= TID_QUEUE_MAX_SIZE)\n\t\t\ttl->head = 0;\n\t}\n}\n\n \nstatic u8\nil4965_rs_tl_add_packet(struct il_lq_sta *lq_data, struct ieee80211_hdr *hdr)\n{\n\tu32 curr_time = jiffies_to_msecs(jiffies);\n\tu32 time_diff;\n\ts32 idx;\n\tstruct il_traffic_load *tl = NULL;\n\tu8 tid;\n\n\tif (ieee80211_is_data_qos(hdr->frame_control)) {\n\t\tu8 *qc = ieee80211_get_qos_ctl(hdr);\n\t\ttid = qc[0] & 0xf;\n\t} else\n\t\treturn MAX_TID_COUNT;\n\n\tif (unlikely(tid >= TID_MAX_LOAD_COUNT))\n\t\treturn MAX_TID_COUNT;\n\n\ttl = &lq_data->load[tid];\n\n\tcurr_time -= curr_time % TID_ROUND_VALUE;\n\n\t \n\tif (!(tl->queue_count)) {\n\t\ttl->total = 1;\n\t\ttl->time_stamp = curr_time;\n\t\ttl->queue_count = 1;\n\t\ttl->head = 0;\n\t\ttl->packet_count[0] = 1;\n\t\treturn MAX_TID_COUNT;\n\t}\n\n\ttime_diff = TIME_WRAP_AROUND(tl->time_stamp, curr_time);\n\tidx = time_diff / TID_QUEUE_CELL_SPACING;\n\n\t \n\t \n\tif (idx >= TID_QUEUE_MAX_SIZE)\n\t\til4965_rs_tl_rm_old_stats(tl, curr_time);\n\n\tidx = (tl->head + idx) % TID_QUEUE_MAX_SIZE;\n\ttl->packet_count[idx] = tl->packet_count[idx] + 1;\n\ttl->total = tl->total + 1;\n\n\tif ((idx + 1) > tl->queue_count)\n\t\ttl->queue_count = idx + 1;\n\n\treturn tid;\n}\n\n \nstatic u32\nil4965_rs_tl_get_load(struct il_lq_sta *lq_data, u8 tid)\n{\n\tu32 curr_time = jiffies_to_msecs(jiffies);\n\tu32 time_diff;\n\ts32 idx;\n\tstruct il_traffic_load *tl = NULL;\n\n\tif (tid >= TID_MAX_LOAD_COUNT)\n\t\treturn 0;\n\n\ttl = &(lq_data->load[tid]);\n\n\tcurr_time -= curr_time % TID_ROUND_VALUE;\n\n\tif (!(tl->queue_count))\n\t\treturn 0;\n\n\ttime_diff = TIME_WRAP_AROUND(tl->time_stamp, curr_time);\n\tidx = time_diff / TID_QUEUE_CELL_SPACING;\n\n\t \n\t \n\tif (idx >= TID_QUEUE_MAX_SIZE)\n\t\til4965_rs_tl_rm_old_stats(tl, curr_time);\n\n\treturn tl->total;\n}\n\nstatic int\nil4965_rs_tl_turn_on_agg_for_tid(struct il_priv *il, struct il_lq_sta *lq_data,\n\t\t\t\t u8 tid, struct ieee80211_sta *sta)\n{\n\tint ret = -EAGAIN;\n\tu32 load;\n\n\tload = il4965_rs_tl_get_load(lq_data, tid);\n\n\tif (load > IL_AGG_LOAD_THRESHOLD) {\n\t\tD_HT(\"Starting Tx agg: STA: %pM tid: %d\\n\", sta->addr, tid);\n\t\tret = ieee80211_start_tx_ba_session(sta, tid, 5000);\n\t\tif (ret == -EAGAIN) {\n\t\t\t \n\t\t\tIL_ERR(\"Fail start Tx agg on tid: %d\\n\", tid);\n\t\t\tieee80211_stop_tx_ba_session(sta, tid);\n\t\t}\n\t} else\n\t\tD_HT(\"Aggregation not enabled for tid %d because load = %u\\n\",\n\t\t     tid, load);\n\n\treturn ret;\n}\n\nstatic void\nil4965_rs_tl_turn_on_agg(struct il_priv *il, u8 tid, struct il_lq_sta *lq_data,\n\t\t\t struct ieee80211_sta *sta)\n{\n\tif (tid < TID_MAX_LOAD_COUNT)\n\t\til4965_rs_tl_turn_on_agg_for_tid(il, lq_data, tid, sta);\n\telse\n\t\tIL_ERR(\"tid exceeds max load count: %d/%d\\n\", tid,\n\t\t       TID_MAX_LOAD_COUNT);\n}\n\nstatic inline int\nil4965_get_il4965_num_of_ant_from_rate(u32 rate_n_flags)\n{\n\treturn !!(rate_n_flags & RATE_MCS_ANT_A_MSK) +\n\t    !!(rate_n_flags & RATE_MCS_ANT_B_MSK) +\n\t    !!(rate_n_flags & RATE_MCS_ANT_C_MSK);\n}\n\n \nstatic s32\nil4965_get_expected_tpt(struct il_scale_tbl_info *tbl, int rs_idx)\n{\n\tif (tbl->expected_tpt)\n\t\treturn tbl->expected_tpt[rs_idx];\n\treturn 0;\n}\n\n \nstatic int\nil4965_rs_collect_tx_data(struct il_scale_tbl_info *tbl, int scale_idx,\n\t\t\t  int attempts, int successes)\n{\n\tstruct il_rate_scale_data *win = NULL;\n\tstatic const u64 mask = (((u64) 1) << (RATE_MAX_WINDOW - 1));\n\ts32 fail_count, tpt;\n\n\tif (scale_idx < 0 || scale_idx >= RATE_COUNT)\n\t\treturn -EINVAL;\n\n\t \n\twin = &(tbl->win[scale_idx]);\n\n\t \n\ttpt = il4965_get_expected_tpt(tbl, scale_idx);\n\n\t \n\twhile (attempts > 0) {\n\t\tif (win->counter >= RATE_MAX_WINDOW) {\n\n\t\t\t \n\t\t\twin->counter = RATE_MAX_WINDOW - 1;\n\n\t\t\tif (win->data & mask) {\n\t\t\t\twin->data &= ~mask;\n\t\t\t\twin->success_counter--;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\twin->counter++;\n\n\t\t \n\t\twin->data <<= 1;\n\n\t\t \n\t\tif (successes > 0) {\n\t\t\twin->success_counter++;\n\t\t\twin->data |= 0x1;\n\t\t\tsuccesses--;\n\t\t}\n\n\t\tattempts--;\n\t}\n\n\t \n\tif (win->counter > 0)\n\t\twin->success_ratio =\n\t\t    128 * (100 * win->success_counter) / win->counter;\n\telse\n\t\twin->success_ratio = IL_INVALID_VALUE;\n\n\tfail_count = win->counter - win->success_counter;\n\n\t \n\tif (fail_count >= RATE_MIN_FAILURE_TH ||\n\t    win->success_counter >= RATE_MIN_SUCCESS_TH)\n\t\twin->average_tpt = (win->success_ratio * tpt + 64) / 128;\n\telse\n\t\twin->average_tpt = IL_INVALID_VALUE;\n\n\t \n\twin->stamp = jiffies;\n\n\treturn 0;\n}\n\n \nstatic u32\nil4965_rate_n_flags_from_tbl(struct il_priv *il, struct il_scale_tbl_info *tbl,\n\t\t\t     int idx, u8 use_green)\n{\n\tu32 rate_n_flags = 0;\n\n\tif (is_legacy(tbl->lq_type)) {\n\t\trate_n_flags = il_rates[idx].plcp;\n\t\tif (idx >= IL_FIRST_CCK_RATE && idx <= IL_LAST_CCK_RATE)\n\t\t\trate_n_flags |= RATE_MCS_CCK_MSK;\n\n\t} else if (is_Ht(tbl->lq_type)) {\n\t\tif (idx > IL_LAST_OFDM_RATE) {\n\t\t\tIL_ERR(\"Invalid HT rate idx %d\\n\", idx);\n\t\t\tidx = IL_LAST_OFDM_RATE;\n\t\t}\n\t\trate_n_flags = RATE_MCS_HT_MSK;\n\n\t\tif (is_siso(tbl->lq_type))\n\t\t\trate_n_flags |= il_rates[idx].plcp_siso;\n\t\telse\n\t\t\trate_n_flags |= il_rates[idx].plcp_mimo2;\n\t} else {\n\t\tIL_ERR(\"Invalid tbl->lq_type %d\\n\", tbl->lq_type);\n\t}\n\n\trate_n_flags |=\n\t    ((tbl->ant_type << RATE_MCS_ANT_POS) & RATE_MCS_ANT_ABC_MSK);\n\n\tif (is_Ht(tbl->lq_type)) {\n\t\tif (tbl->is_ht40) {\n\t\t\tif (tbl->is_dup)\n\t\t\t\trate_n_flags |= RATE_MCS_DUP_MSK;\n\t\t\telse\n\t\t\t\trate_n_flags |= RATE_MCS_HT40_MSK;\n\t\t}\n\t\tif (tbl->is_SGI)\n\t\t\trate_n_flags |= RATE_MCS_SGI_MSK;\n\n\t\tif (use_green) {\n\t\t\trate_n_flags |= RATE_MCS_GF_MSK;\n\t\t\tif (is_siso(tbl->lq_type) && tbl->is_SGI) {\n\t\t\t\trate_n_flags &= ~RATE_MCS_SGI_MSK;\n\t\t\t\tIL_ERR(\"GF was set with SGI:SISO\\n\");\n\t\t\t}\n\t\t}\n\t}\n\treturn rate_n_flags;\n}\n\n \nstatic int\nil4965_rs_get_tbl_info_from_mcs(const u32 rate_n_flags,\n\t\t\t\tenum nl80211_band band,\n\t\t\t\tstruct il_scale_tbl_info *tbl, int *rate_idx)\n{\n\tu32 ant_msk = (rate_n_flags & RATE_MCS_ANT_ABC_MSK);\n\tu8 il4965_num_of_ant =\n\t    il4965_get_il4965_num_of_ant_from_rate(rate_n_flags);\n\tu8 mcs;\n\n\tmemset(tbl, 0, sizeof(struct il_scale_tbl_info));\n\t*rate_idx = il4965_hwrate_to_plcp_idx(rate_n_flags);\n\n\tif (*rate_idx == RATE_INVALID) {\n\t\t*rate_idx = -1;\n\t\treturn -EINVAL;\n\t}\n\ttbl->is_SGI = 0;\t \n\ttbl->is_ht40 = 0;\n\ttbl->is_dup = 0;\n\ttbl->ant_type = (ant_msk >> RATE_MCS_ANT_POS);\n\ttbl->lq_type = LQ_NONE;\n\ttbl->max_search = IL_MAX_SEARCH;\n\n\t \n\tif (!(rate_n_flags & RATE_MCS_HT_MSK)) {\n\t\tif (il4965_num_of_ant == 1) {\n\t\t\tif (band == NL80211_BAND_5GHZ)\n\t\t\t\ttbl->lq_type = LQ_A;\n\t\t\telse\n\t\t\t\ttbl->lq_type = LQ_G;\n\t\t}\n\t\t \n\t} else {\n\t\tif (rate_n_flags & RATE_MCS_SGI_MSK)\n\t\t\ttbl->is_SGI = 1;\n\n\t\tif ((rate_n_flags & RATE_MCS_HT40_MSK) ||\n\t\t    (rate_n_flags & RATE_MCS_DUP_MSK))\n\t\t\ttbl->is_ht40 = 1;\n\n\t\tif (rate_n_flags & RATE_MCS_DUP_MSK)\n\t\t\ttbl->is_dup = 1;\n\n\t\tmcs = il4965_rs_extract_rate(rate_n_flags);\n\n\t\t \n\t\tif (mcs <= RATE_SISO_60M_PLCP) {\n\t\t\tif (il4965_num_of_ant == 1)\n\t\t\t\ttbl->lq_type = LQ_SISO;\t \n\t\t\t \n\t\t} else {\n\t\t\tif (il4965_num_of_ant == 2)\n\t\t\t\ttbl->lq_type = LQ_MIMO2;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n \nstatic int\nil4965_rs_toggle_antenna(u32 valid_ant, u32 *rate_n_flags,\n\t\t\t struct il_scale_tbl_info *tbl)\n{\n\tu8 new_ant_type;\n\n\tif (!tbl->ant_type || tbl->ant_type > ANT_ABC)\n\t\treturn 0;\n\n\tif (!il4965_rs_is_valid_ant(valid_ant, tbl->ant_type))\n\t\treturn 0;\n\n\tnew_ant_type = ant_toggle_lookup[tbl->ant_type];\n\n\twhile (new_ant_type != tbl->ant_type &&\n\t       !il4965_rs_is_valid_ant(valid_ant, new_ant_type))\n\t\tnew_ant_type = ant_toggle_lookup[new_ant_type];\n\n\tif (new_ant_type == tbl->ant_type)\n\t\treturn 0;\n\n\ttbl->ant_type = new_ant_type;\n\t*rate_n_flags &= ~RATE_MCS_ANT_ABC_MSK;\n\t*rate_n_flags |= new_ant_type << RATE_MCS_ANT_POS;\n\treturn 1;\n}\n\n \nstatic bool\nil4965_rs_use_green(struct il_priv *il, struct ieee80211_sta *sta)\n{\n\treturn (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_GRN_FLD) &&\n\t       !il->ht.non_gf_sta_present;\n}\n\n \nstatic u16\nil4965_rs_get_supported_rates(struct il_lq_sta *lq_sta,\n\t\t\t      struct ieee80211_hdr *hdr,\n\t\t\t      enum il_table_type rate_type)\n{\n\tif (is_legacy(rate_type)) {\n\t\treturn lq_sta->active_legacy_rate;\n\t} else {\n\t\tif (is_siso(rate_type))\n\t\t\treturn lq_sta->active_siso_rate;\n\t\telse\n\t\t\treturn lq_sta->active_mimo2_rate;\n\t}\n}\n\nstatic u16\nil4965_rs_get_adjacent_rate(struct il_priv *il, u8 idx, u16 rate_mask,\n\t\t\t    int rate_type)\n{\n\tu8 high = RATE_INVALID;\n\tu8 low = RATE_INVALID;\n\n\t \n\tif (is_a_band(rate_type) || !is_legacy(rate_type)) {\n\t\tint i;\n\t\tu32 mask;\n\n\t\t \n\t\ti = idx - 1;\n\t\tfor (mask = (1 << i); i >= 0; i--, mask >>= 1) {\n\t\t\tif (rate_mask & mask) {\n\t\t\t\tlow = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\ti = idx + 1;\n\t\tfor (mask = (1 << i); i < RATE_COUNT; i++, mask <<= 1) {\n\t\t\tif (rate_mask & mask) {\n\t\t\t\thigh = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn (high << 8) | low;\n\t}\n\n\tlow = idx;\n\twhile (low != RATE_INVALID) {\n\t\tlow = il_rates[low].prev_rs;\n\t\tif (low == RATE_INVALID)\n\t\t\tbreak;\n\t\tif (rate_mask & (1 << low))\n\t\t\tbreak;\n\t\tD_RATE(\"Skipping masked lower rate: %d\\n\", low);\n\t}\n\n\thigh = idx;\n\twhile (high != RATE_INVALID) {\n\t\thigh = il_rates[high].next_rs;\n\t\tif (high == RATE_INVALID)\n\t\t\tbreak;\n\t\tif (rate_mask & (1 << high))\n\t\t\tbreak;\n\t\tD_RATE(\"Skipping masked higher rate: %d\\n\", high);\n\t}\n\n\treturn (high << 8) | low;\n}\n\nstatic u32\nil4965_rs_get_lower_rate(struct il_lq_sta *lq_sta,\n\t\t\t struct il_scale_tbl_info *tbl, u8 scale_idx,\n\t\t\t u8 ht_possible)\n{\n\ts32 low;\n\tu16 rate_mask;\n\tu16 high_low;\n\tu8 switch_to_legacy = 0;\n\tu8 is_green = lq_sta->is_green;\n\tstruct il_priv *il = lq_sta->drv;\n\n\t \n\tif (!is_legacy(tbl->lq_type) && (!ht_possible || !scale_idx)) {\n\t\tswitch_to_legacy = 1;\n\t\tscale_idx = rs_ht_to_legacy[scale_idx];\n\t\tif (lq_sta->band == NL80211_BAND_5GHZ)\n\t\t\ttbl->lq_type = LQ_A;\n\t\telse\n\t\t\ttbl->lq_type = LQ_G;\n\n\t\tif (il4965_num_of_ant(tbl->ant_type) > 1)\n\t\t\ttbl->ant_type =\n\t\t\t    il4965_first_antenna(il->hw_params.valid_tx_ant);\n\n\t\ttbl->is_ht40 = 0;\n\t\ttbl->is_SGI = 0;\n\t\ttbl->max_search = IL_MAX_SEARCH;\n\t}\n\n\trate_mask = il4965_rs_get_supported_rates(lq_sta, NULL, tbl->lq_type);\n\n\t \n\tif (is_legacy(tbl->lq_type)) {\n\t\t \n\t\tif (lq_sta->band == NL80211_BAND_5GHZ)\n\t\t\trate_mask =\n\t\t\t    (u16) (rate_mask &\n\t\t\t\t   (lq_sta->supp_rates << IL_FIRST_OFDM_RATE));\n\t\telse\n\t\t\trate_mask = (u16) (rate_mask & lq_sta->supp_rates);\n\t}\n\n\t \n\tif (switch_to_legacy && (rate_mask & (1 << scale_idx))) {\n\t\tlow = scale_idx;\n\t\tgoto out;\n\t}\n\n\thigh_low =\n\t    il4965_rs_get_adjacent_rate(lq_sta->drv, scale_idx, rate_mask,\n\t\t\t\t\ttbl->lq_type);\n\tlow = high_low & 0xff;\n\n\tif (low == RATE_INVALID)\n\t\tlow = scale_idx;\n\nout:\n\treturn il4965_rate_n_flags_from_tbl(lq_sta->drv, tbl, low, is_green);\n}\n\n \nstatic bool\nil4965_table_type_matches(struct il_scale_tbl_info *a,\n\t\t\t  struct il_scale_tbl_info *b)\n{\n\treturn (a->lq_type == b->lq_type && a->ant_type == b->ant_type &&\n\t\ta->is_SGI == b->is_SGI);\n}\n\n \nstatic void\nil4965_rs_tx_status(void *il_r, struct ieee80211_supported_band *sband,\n\t\t    struct ieee80211_sta *sta, void *il_sta,\n\t\t    struct sk_buff *skb)\n{\n\tint legacy_success;\n\tint retries;\n\tint rs_idx, mac_idx, i;\n\tstruct il_lq_sta *lq_sta = il_sta;\n\tstruct il_link_quality_cmd *table;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct il_priv *il = (struct il_priv *)il_r;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tenum mac80211_rate_control_flags mac_flags;\n\tu32 tx_rate;\n\tstruct il_scale_tbl_info tbl_type;\n\tstruct il_scale_tbl_info *curr_tbl, *other_tbl, *tmp_tbl;\n\n\tD_RATE(\"get frame ack response, update rate scale win\\n\");\n\n\t \n\tif (!lq_sta) {\n\t\tD_RATE(\"Station rate scaling not created yet.\\n\");\n\t\treturn;\n\t} else if (!lq_sta->drv) {\n\t\tD_RATE(\"Rate scaling not initialized yet.\\n\");\n\t\treturn;\n\t}\n\n\tif (!ieee80211_is_data(hdr->frame_control) ||\n\t    (info->flags & IEEE80211_TX_CTL_NO_ACK))\n\t\treturn;\n\n\t \n\tif ((info->flags & IEEE80211_TX_CTL_AMPDU) &&\n\t    !(info->flags & IEEE80211_TX_STAT_AMPDU))\n\t\treturn;\n\n\t \n\ttable = &lq_sta->lq;\n\ttx_rate = le32_to_cpu(table->rs_table[0].rate_n_flags);\n\til4965_rs_get_tbl_info_from_mcs(tx_rate, il->band, &tbl_type, &rs_idx);\n\tif (il->band == NL80211_BAND_5GHZ)\n\t\trs_idx -= IL_FIRST_OFDM_RATE;\n\tmac_flags = info->status.rates[0].flags;\n\tmac_idx = info->status.rates[0].idx;\n\t \n\tif (mac_flags & IEEE80211_TX_RC_MCS) {\n\t\tmac_idx &= RATE_MCS_CODE_MSK;\t \n\t\tif (mac_idx >= (RATE_9M_IDX - IL_FIRST_OFDM_RATE))\n\t\t\tmac_idx++;\n\t\t \n\t\tif (il->band == NL80211_BAND_2GHZ)\n\t\t\tmac_idx += IL_FIRST_OFDM_RATE;\n\t}\n\t \n\tif (mac_idx < 0 ||\n\t    tbl_type.is_SGI != !!(mac_flags & IEEE80211_TX_RC_SHORT_GI) ||\n\t    tbl_type.is_ht40 != !!(mac_flags & IEEE80211_TX_RC_40_MHZ_WIDTH) ||\n\t    tbl_type.is_dup != !!(mac_flags & IEEE80211_TX_RC_DUP_DATA) ||\n\t    tbl_type.ant_type != info->status.antenna ||\n\t    !!(tx_rate & RATE_MCS_HT_MSK) != !!(mac_flags & IEEE80211_TX_RC_MCS)\n\t    || !!(tx_rate & RATE_MCS_GF_MSK) !=\n\t    !!(mac_flags & IEEE80211_TX_RC_GREEN_FIELD) || rs_idx != mac_idx) {\n\t\tD_RATE(\"initial rate %d does not match %d (0x%x)\\n\", mac_idx,\n\t\t       rs_idx, tx_rate);\n\t\t \n\t\tlq_sta->missed_rate_counter++;\n\t\tif (lq_sta->missed_rate_counter > IL_MISSED_RATE_MAX) {\n\t\t\tlq_sta->missed_rate_counter = 0;\n\t\t\til_send_lq_cmd(il, &lq_sta->lq, CMD_ASYNC, false);\n\t\t}\n\t\t \n\t\treturn;\n\t} else\n\t\t \n\t\tlq_sta->missed_rate_counter = 0;\n\n\t \n\tif (il4965_table_type_matches\n\t    (&tbl_type, &(lq_sta->lq_info[lq_sta->active_tbl]))) {\n\t\tcurr_tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\n\t\tother_tbl = &(lq_sta->lq_info[1 - lq_sta->active_tbl]);\n\t} else\n\t    if (il4965_table_type_matches\n\t\t(&tbl_type, &lq_sta->lq_info[1 - lq_sta->active_tbl])) {\n\t\tcurr_tbl = &(lq_sta->lq_info[1 - lq_sta->active_tbl]);\n\t\tother_tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\n\t} else {\n\t\tD_RATE(\"Neither active nor search matches tx rate\\n\");\n\t\ttmp_tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\n\t\tD_RATE(\"active- lq:%x, ant:%x, SGI:%d\\n\", tmp_tbl->lq_type,\n\t\t       tmp_tbl->ant_type, tmp_tbl->is_SGI);\n\t\ttmp_tbl = &(lq_sta->lq_info[1 - lq_sta->active_tbl]);\n\t\tD_RATE(\"search- lq:%x, ant:%x, SGI:%d\\n\", tmp_tbl->lq_type,\n\t\t       tmp_tbl->ant_type, tmp_tbl->is_SGI);\n\t\tD_RATE(\"actual- lq:%x, ant:%x, SGI:%d\\n\", tbl_type.lq_type,\n\t\t       tbl_type.ant_type, tbl_type.is_SGI);\n\t\t \n\t\til4965_rs_stay_in_table(lq_sta, true);\n\t\tgoto done;\n\t}\n\n\t \n\tif (info->flags & IEEE80211_TX_STAT_AMPDU) {\n\t\ttx_rate = le32_to_cpu(table->rs_table[0].rate_n_flags);\n\t\til4965_rs_get_tbl_info_from_mcs(tx_rate, il->band, &tbl_type,\n\t\t\t\t\t\t&rs_idx);\n\t\til4965_rs_collect_tx_data(curr_tbl, rs_idx,\n\t\t\t\t\t  info->status.ampdu_len,\n\t\t\t\t\t  info->status.ampdu_ack_len);\n\n\t\t \n\t\tif (lq_sta->stay_in_tbl) {\n\t\t\tlq_sta->total_success += info->status.ampdu_ack_len;\n\t\t\tlq_sta->total_failed +=\n\t\t\t    (info->status.ampdu_len -\n\t\t\t     info->status.ampdu_ack_len);\n\t\t}\n\t} else {\n\t\t \n\t\tretries = info->status.rates[0].count - 1;\n\t\t \n\t\tretries = min(retries, 15);\n\n\t\t \n\t\tlegacy_success = !!(info->flags & IEEE80211_TX_STAT_ACK);\n\t\t \n\t\tfor (i = 0; i <= retries; ++i) {\n\t\t\ttx_rate = le32_to_cpu(table->rs_table[i].rate_n_flags);\n\t\t\til4965_rs_get_tbl_info_from_mcs(tx_rate, il->band,\n\t\t\t\t\t\t\t&tbl_type, &rs_idx);\n\t\t\t \n\t\t\tif (il4965_table_type_matches(&tbl_type, curr_tbl))\n\t\t\t\ttmp_tbl = curr_tbl;\n\t\t\telse if (il4965_table_type_matches\n\t\t\t\t (&tbl_type, other_tbl))\n\t\t\t\ttmp_tbl = other_tbl;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t\til4965_rs_collect_tx_data(tmp_tbl, rs_idx, 1,\n\t\t\t\t\t\t  i <\n\t\t\t\t\t\t  retries ? 0 : legacy_success);\n\t\t}\n\n\t\t \n\t\tif (lq_sta->stay_in_tbl) {\n\t\t\tlq_sta->total_success += legacy_success;\n\t\t\tlq_sta->total_failed += retries + (1 - legacy_success);\n\t\t}\n\t}\n\t \n\tlq_sta->last_rate_n_flags = tx_rate;\ndone:\n\t \n\tif (sta->deflink.supp_rates[sband->band])\n\t\til4965_rs_rate_scale_perform(il, skb, sta, lq_sta);\n}\n\n \nstatic void\nil4965_rs_set_stay_in_table(struct il_priv *il, u8 is_legacy,\n\t\t\t    struct il_lq_sta *lq_sta)\n{\n\tD_RATE(\"we are staying in the same table\\n\");\n\tlq_sta->stay_in_tbl = 1;\t \n\tif (is_legacy) {\n\t\tlq_sta->table_count_limit = IL_LEGACY_TBL_COUNT;\n\t\tlq_sta->max_failure_limit = IL_LEGACY_FAILURE_LIMIT;\n\t\tlq_sta->max_success_limit = IL_LEGACY_SUCCESS_LIMIT;\n\t} else {\n\t\tlq_sta->table_count_limit = IL_NONE_LEGACY_TBL_COUNT;\n\t\tlq_sta->max_failure_limit = IL_NONE_LEGACY_FAILURE_LIMIT;\n\t\tlq_sta->max_success_limit = IL_NONE_LEGACY_SUCCESS_LIMIT;\n\t}\n\tlq_sta->table_count = 0;\n\tlq_sta->total_failed = 0;\n\tlq_sta->total_success = 0;\n\tlq_sta->flush_timer = jiffies;\n\tlq_sta->action_counter = 0;\n}\n\n \nstatic void\nil4965_rs_set_expected_tpt_table(struct il_lq_sta *lq_sta,\n\t\t\t\t struct il_scale_tbl_info *tbl)\n{\n\t \n\ts32(*ht_tbl_pointer)[RATE_COUNT];\n\n\t \n\tif (WARN_ON_ONCE(!is_legacy(tbl->lq_type) && !is_Ht(tbl->lq_type))) {\n\t\ttbl->expected_tpt = expected_tpt_legacy;\n\t\treturn;\n\t}\n\n\t \n\tif (is_legacy(tbl->lq_type)) {\n\t\ttbl->expected_tpt = expected_tpt_legacy;\n\t\treturn;\n\t}\n\n\t \n\tif (is_siso(tbl->lq_type) && (!tbl->is_ht40 || lq_sta->is_dup))\n\t\tht_tbl_pointer = expected_tpt_siso20MHz;\n\telse if (is_siso(tbl->lq_type))\n\t\tht_tbl_pointer = expected_tpt_siso40MHz;\n\telse if (is_mimo2(tbl->lq_type) && (!tbl->is_ht40 || lq_sta->is_dup))\n\t\tht_tbl_pointer = expected_tpt_mimo2_20MHz;\n\telse\t\t\t \n\t\tht_tbl_pointer = expected_tpt_mimo2_40MHz;\n\n\tif (!tbl->is_SGI && !lq_sta->is_agg)\t \n\t\ttbl->expected_tpt = ht_tbl_pointer[0];\n\telse if (tbl->is_SGI && !lq_sta->is_agg)\t \n\t\ttbl->expected_tpt = ht_tbl_pointer[1];\n\telse if (!tbl->is_SGI && lq_sta->is_agg)\t \n\t\ttbl->expected_tpt = ht_tbl_pointer[2];\n\telse\t\t\t \n\t\ttbl->expected_tpt = ht_tbl_pointer[3];\n}\n\n \nstatic s32\nil4965_rs_get_best_rate(struct il_priv *il, struct il_lq_sta *lq_sta,\n\t\t\tstruct il_scale_tbl_info *tbl,\t \n\t\t\tu16 rate_mask, s8 idx)\n{\n\t \n\tstruct il_scale_tbl_info *active_tbl =\n\t    &(lq_sta->lq_info[lq_sta->active_tbl]);\n\ts32 active_sr = active_tbl->win[idx].success_ratio;\n\ts32 active_tpt = active_tbl->expected_tpt[idx];\n\n\t \n\ts32 *tpt_tbl = tbl->expected_tpt;\n\n\ts32 new_rate, high, low, start_hi;\n\tu16 high_low;\n\ts8 rate = idx;\n\n\tnew_rate = high = low = start_hi = RATE_INVALID;\n\n\tfor (;;) {\n\t\thigh_low =\n\t\t    il4965_rs_get_adjacent_rate(il, rate, rate_mask,\n\t\t\t\t\t\ttbl->lq_type);\n\n\t\tlow = high_low & 0xff;\n\t\thigh = (high_low >> 8) & 0xff;\n\n\t\t \n\t\tif ((100 * tpt_tbl[rate] > lq_sta->last_tpt &&\n\t\t     (active_sr > RATE_DECREASE_TH && active_sr <= RATE_HIGH_TH\n\t\t      && tpt_tbl[rate] <= active_tpt)) ||\n\t\t    (active_sr >= RATE_SCALE_SWITCH &&\n\t\t     tpt_tbl[rate] > active_tpt)) {\n\n\t\t\t \n\t\t\tif (start_hi != RATE_INVALID) {\n\t\t\t\tnew_rate = start_hi;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnew_rate = rate;\n\n\t\t\t \n\t\t\tif (low != RATE_INVALID)\n\t\t\t\trate = low;\n\n\t\t\t \n\t\t\telse\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t} else {\n\t\t\t \n\t\t\tif (new_rate != RATE_INVALID)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\telse if (high != RATE_INVALID) {\n\t\t\t\tstart_hi = high;\n\t\t\t\trate = high;\n\n\t\t\t\t \n\t\t\t} else {\n\t\t\t\tnew_rate = rate;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn new_rate;\n}\n\n \nstatic int\nil4965_rs_switch_to_mimo2(struct il_priv *il, struct il_lq_sta *lq_sta,\n\t\t\t  struct ieee80211_conf *conf,\n\t\t\t  struct ieee80211_sta *sta,\n\t\t\t  struct il_scale_tbl_info *tbl, int idx)\n{\n\tu16 rate_mask;\n\ts32 rate;\n\ts8 is_green = lq_sta->is_green;\n\n\tif (!conf_is_ht(conf) || !sta->deflink.ht_cap.ht_supported)\n\t\treturn -1;\n\n\tif (sta->deflink.smps_mode == IEEE80211_SMPS_STATIC)\n\t\treturn -1;\n\n\t \n\tif (il->hw_params.tx_chains_num < 2)\n\t\treturn -1;\n\n\tD_RATE(\"LQ: try to switch to MIMO2\\n\");\n\n\ttbl->lq_type = LQ_MIMO2;\n\ttbl->is_dup = lq_sta->is_dup;\n\ttbl->action = 0;\n\ttbl->max_search = IL_MAX_SEARCH;\n\trate_mask = lq_sta->active_mimo2_rate;\n\n\tif (il_is_ht40_tx_allowed(il, &sta->deflink.ht_cap))\n\t\ttbl->is_ht40 = 1;\n\telse\n\t\ttbl->is_ht40 = 0;\n\n\til4965_rs_set_expected_tpt_table(lq_sta, tbl);\n\n\trate = il4965_rs_get_best_rate(il, lq_sta, tbl, rate_mask, idx);\n\n\tD_RATE(\"LQ: MIMO2 best rate %d mask %X\\n\", rate, rate_mask);\n\tif (rate == RATE_INVALID || !((1 << rate) & rate_mask)) {\n\t\tD_RATE(\"Can't switch with idx %d rate mask %x\\n\", rate,\n\t\t       rate_mask);\n\t\treturn -1;\n\t}\n\ttbl->current_rate =\n\t    il4965_rate_n_flags_from_tbl(il, tbl, rate, is_green);\n\n\tD_RATE(\"LQ: Switch to new mcs %X idx is green %X\\n\", tbl->current_rate,\n\t       is_green);\n\treturn 0;\n}\n\n \nstatic int\nil4965_rs_switch_to_siso(struct il_priv *il, struct il_lq_sta *lq_sta,\n\t\t\t struct ieee80211_conf *conf, struct ieee80211_sta *sta,\n\t\t\t struct il_scale_tbl_info *tbl, int idx)\n{\n\tu16 rate_mask;\n\tu8 is_green = lq_sta->is_green;\n\ts32 rate;\n\n\tif (!conf_is_ht(conf) || !sta->deflink.ht_cap.ht_supported)\n\t\treturn -1;\n\n\tD_RATE(\"LQ: try to switch to SISO\\n\");\n\n\ttbl->is_dup = lq_sta->is_dup;\n\ttbl->lq_type = LQ_SISO;\n\ttbl->action = 0;\n\ttbl->max_search = IL_MAX_SEARCH;\n\trate_mask = lq_sta->active_siso_rate;\n\n\tif (il_is_ht40_tx_allowed(il, &sta->deflink.ht_cap))\n\t\ttbl->is_ht40 = 1;\n\telse\n\t\ttbl->is_ht40 = 0;\n\n\tif (is_green)\n\t\ttbl->is_SGI = 0;\t \n\n\til4965_rs_set_expected_tpt_table(lq_sta, tbl);\n\trate = il4965_rs_get_best_rate(il, lq_sta, tbl, rate_mask, idx);\n\n\tD_RATE(\"LQ: get best rate %d mask %X\\n\", rate, rate_mask);\n\tif (rate == RATE_INVALID || !((1 << rate) & rate_mask)) {\n\t\tD_RATE(\"can not switch with idx %d rate mask %x\\n\", rate,\n\t\t       rate_mask);\n\t\treturn -1;\n\t}\n\ttbl->current_rate =\n\t    il4965_rate_n_flags_from_tbl(il, tbl, rate, is_green);\n\tD_RATE(\"LQ: Switch to new mcs %X idx is green %X\\n\", tbl->current_rate,\n\t       is_green);\n\treturn 0;\n}\n\n \nstatic int\nil4965_rs_move_legacy_other(struct il_priv *il, struct il_lq_sta *lq_sta,\n\t\t\t    struct ieee80211_conf *conf,\n\t\t\t    struct ieee80211_sta *sta, int idx)\n{\n\tstruct il_scale_tbl_info *tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\n\tstruct il_scale_tbl_info *search_tbl =\n\t    &(lq_sta->lq_info[(1 - lq_sta->active_tbl)]);\n\tstruct il_rate_scale_data *win = &(tbl->win[idx]);\n\tu32 sz =\n\t    (sizeof(struct il_scale_tbl_info) -\n\t     (sizeof(struct il_rate_scale_data) * RATE_COUNT));\n\tu8 start_action;\n\tu8 valid_tx_ant = il->hw_params.valid_tx_ant;\n\tu8 tx_chains_num = il->hw_params.tx_chains_num;\n\tint ret = 0;\n\tu8 update_search_tbl_counter = 0;\n\n\ttbl->action = IL_LEGACY_SWITCH_SISO;\n\n\tstart_action = tbl->action;\n\tfor (;;) {\n\t\tlq_sta->action_counter++;\n\t\tswitch (tbl->action) {\n\t\tcase IL_LEGACY_SWITCH_ANTENNA1:\n\t\tcase IL_LEGACY_SWITCH_ANTENNA2:\n\t\t\tD_RATE(\"LQ: Legacy toggle Antenna\\n\");\n\n\t\t\tif ((tbl->action == IL_LEGACY_SWITCH_ANTENNA1 &&\n\t\t\t     tx_chains_num <= 1) ||\n\t\t\t    (tbl->action == IL_LEGACY_SWITCH_ANTENNA2 &&\n\t\t\t     tx_chains_num <= 2))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (win->success_ratio >= IL_RS_GOOD_RATIO)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tmemcpy(search_tbl, tbl, sz);\n\n\t\t\tif (il4965_rs_toggle_antenna\n\t\t\t    (valid_tx_ant, &search_tbl->current_rate,\n\t\t\t     search_tbl)) {\n\t\t\t\tupdate_search_tbl_counter = 1;\n\t\t\t\til4965_rs_set_expected_tpt_table(lq_sta,\n\t\t\t\t\t\t\t\t search_tbl);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IL_LEGACY_SWITCH_SISO:\n\t\t\tD_RATE(\"LQ: Legacy switch to SISO\\n\");\n\n\t\t\t \n\t\t\tmemcpy(search_tbl, tbl, sz);\n\t\t\tsearch_tbl->is_SGI = 0;\n\t\t\tret =\n\t\t\t    il4965_rs_switch_to_siso(il, lq_sta, conf, sta,\n\t\t\t\t\t\t     search_tbl, idx);\n\t\t\tif (!ret) {\n\t\t\t\tlq_sta->action_counter = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase IL_LEGACY_SWITCH_MIMO2_AB:\n\t\tcase IL_LEGACY_SWITCH_MIMO2_AC:\n\t\tcase IL_LEGACY_SWITCH_MIMO2_BC:\n\t\t\tD_RATE(\"LQ: Legacy switch to MIMO2\\n\");\n\n\t\t\t \n\t\t\tmemcpy(search_tbl, tbl, sz);\n\t\t\tsearch_tbl->is_SGI = 0;\n\n\t\t\tif (tbl->action == IL_LEGACY_SWITCH_MIMO2_AB)\n\t\t\t\tsearch_tbl->ant_type = ANT_AB;\n\t\t\telse if (tbl->action == IL_LEGACY_SWITCH_MIMO2_AC)\n\t\t\t\tsearch_tbl->ant_type = ANT_AC;\n\t\t\telse\n\t\t\t\tsearch_tbl->ant_type = ANT_BC;\n\n\t\t\tif (!il4965_rs_is_valid_ant\n\t\t\t    (valid_tx_ant, search_tbl->ant_type))\n\t\t\t\tbreak;\n\n\t\t\tret =\n\t\t\t    il4965_rs_switch_to_mimo2(il, lq_sta, conf, sta,\n\t\t\t\t\t\t      search_tbl, idx);\n\t\t\tif (!ret) {\n\t\t\t\tlq_sta->action_counter = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\ttbl->action++;\n\t\tif (tbl->action > IL_LEGACY_SWITCH_MIMO2_BC)\n\t\t\ttbl->action = IL_LEGACY_SWITCH_ANTENNA1;\n\n\t\tif (tbl->action == start_action)\n\t\t\tbreak;\n\n\t}\n\tsearch_tbl->lq_type = LQ_NONE;\n\treturn 0;\n\nout:\n\tlq_sta->search_better_tbl = 1;\n\ttbl->action++;\n\tif (tbl->action > IL_LEGACY_SWITCH_MIMO2_BC)\n\t\ttbl->action = IL_LEGACY_SWITCH_ANTENNA1;\n\tif (update_search_tbl_counter)\n\t\tsearch_tbl->action = tbl->action;\n\treturn 0;\n\n}\n\n \nstatic int\nil4965_rs_move_siso_to_other(struct il_priv *il, struct il_lq_sta *lq_sta,\n\t\t\t     struct ieee80211_conf *conf,\n\t\t\t     struct ieee80211_sta *sta, int idx)\n{\n\tu8 is_green = lq_sta->is_green;\n\tstruct il_scale_tbl_info *tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\n\tstruct il_scale_tbl_info *search_tbl =\n\t    &(lq_sta->lq_info[(1 - lq_sta->active_tbl)]);\n\tstruct il_rate_scale_data *win = &(tbl->win[idx]);\n\tstruct ieee80211_sta_ht_cap *ht_cap = &sta->deflink.ht_cap;\n\tu32 sz =\n\t    (sizeof(struct il_scale_tbl_info) -\n\t     (sizeof(struct il_rate_scale_data) * RATE_COUNT));\n\tu8 start_action;\n\tu8 valid_tx_ant = il->hw_params.valid_tx_ant;\n\tu8 tx_chains_num = il->hw_params.tx_chains_num;\n\tu8 update_search_tbl_counter = 0;\n\tint ret;\n\n\tstart_action = tbl->action;\n\n\tfor (;;) {\n\t\tlq_sta->action_counter++;\n\t\tswitch (tbl->action) {\n\t\tcase IL_SISO_SWITCH_ANTENNA1:\n\t\tcase IL_SISO_SWITCH_ANTENNA2:\n\t\t\tD_RATE(\"LQ: SISO toggle Antenna\\n\");\n\t\t\tif ((tbl->action == IL_SISO_SWITCH_ANTENNA1 &&\n\t\t\t     tx_chains_num <= 1) ||\n\t\t\t    (tbl->action == IL_SISO_SWITCH_ANTENNA2 &&\n\t\t\t     tx_chains_num <= 2))\n\t\t\t\tbreak;\n\n\t\t\tif (win->success_ratio >= IL_RS_GOOD_RATIO)\n\t\t\t\tbreak;\n\n\t\t\tmemcpy(search_tbl, tbl, sz);\n\t\t\tif (il4965_rs_toggle_antenna\n\t\t\t    (valid_tx_ant, &search_tbl->current_rate,\n\t\t\t     search_tbl)) {\n\t\t\t\tupdate_search_tbl_counter = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IL_SISO_SWITCH_MIMO2_AB:\n\t\tcase IL_SISO_SWITCH_MIMO2_AC:\n\t\tcase IL_SISO_SWITCH_MIMO2_BC:\n\t\t\tD_RATE(\"LQ: SISO switch to MIMO2\\n\");\n\t\t\tmemcpy(search_tbl, tbl, sz);\n\t\t\tsearch_tbl->is_SGI = 0;\n\n\t\t\tif (tbl->action == IL_SISO_SWITCH_MIMO2_AB)\n\t\t\t\tsearch_tbl->ant_type = ANT_AB;\n\t\t\telse if (tbl->action == IL_SISO_SWITCH_MIMO2_AC)\n\t\t\t\tsearch_tbl->ant_type = ANT_AC;\n\t\t\telse\n\t\t\t\tsearch_tbl->ant_type = ANT_BC;\n\n\t\t\tif (!il4965_rs_is_valid_ant\n\t\t\t    (valid_tx_ant, search_tbl->ant_type))\n\t\t\t\tbreak;\n\n\t\t\tret =\n\t\t\t    il4965_rs_switch_to_mimo2(il, lq_sta, conf, sta,\n\t\t\t\t\t\t      search_tbl, idx);\n\t\t\tif (!ret)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase IL_SISO_SWITCH_GI:\n\t\t\tif (!tbl->is_ht40 &&\n\t\t\t    !(ht_cap->cap & IEEE80211_HT_CAP_SGI_20))\n\t\t\t\tbreak;\n\t\t\tif (tbl->is_ht40 &&\n\t\t\t    !(ht_cap->cap & IEEE80211_HT_CAP_SGI_40))\n\t\t\t\tbreak;\n\n\t\t\tD_RATE(\"LQ: SISO toggle SGI/NGI\\n\");\n\n\t\t\tmemcpy(search_tbl, tbl, sz);\n\t\t\tif (is_green) {\n\t\t\t\tif (!tbl->is_SGI)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\tIL_ERR(\"SGI was set in GF+SISO\\n\");\n\t\t\t}\n\t\t\tsearch_tbl->is_SGI = !tbl->is_SGI;\n\t\t\til4965_rs_set_expected_tpt_table(lq_sta, search_tbl);\n\t\t\tif (tbl->is_SGI) {\n\t\t\t\ts32 tpt = lq_sta->last_tpt / 100;\n\t\t\t\tif (tpt >= search_tbl->expected_tpt[idx])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsearch_tbl->current_rate =\n\t\t\t    il4965_rate_n_flags_from_tbl(il, search_tbl, idx,\n\t\t\t\t\t\t\t is_green);\n\t\t\tupdate_search_tbl_counter = 1;\n\t\t\tgoto out;\n\t\t}\n\t\ttbl->action++;\n\t\tif (tbl->action > IL_SISO_SWITCH_GI)\n\t\t\ttbl->action = IL_SISO_SWITCH_ANTENNA1;\n\n\t\tif (tbl->action == start_action)\n\t\t\tbreak;\n\t}\n\tsearch_tbl->lq_type = LQ_NONE;\n\treturn 0;\n\nout:\n\tlq_sta->search_better_tbl = 1;\n\ttbl->action++;\n\tif (tbl->action > IL_SISO_SWITCH_GI)\n\t\ttbl->action = IL_SISO_SWITCH_ANTENNA1;\n\tif (update_search_tbl_counter)\n\t\tsearch_tbl->action = tbl->action;\n\n\treturn 0;\n}\n\n \nstatic int\nil4965_rs_move_mimo2_to_other(struct il_priv *il, struct il_lq_sta *lq_sta,\n\t\t\t      struct ieee80211_conf *conf,\n\t\t\t      struct ieee80211_sta *sta, int idx)\n{\n\ts8 is_green = lq_sta->is_green;\n\tstruct il_scale_tbl_info *tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\n\tstruct il_scale_tbl_info *search_tbl =\n\t    &(lq_sta->lq_info[(1 - lq_sta->active_tbl)]);\n\tstruct il_rate_scale_data *win = &(tbl->win[idx]);\n\tstruct ieee80211_sta_ht_cap *ht_cap = &sta->deflink.ht_cap;\n\tu32 sz =\n\t    (sizeof(struct il_scale_tbl_info) -\n\t     (sizeof(struct il_rate_scale_data) * RATE_COUNT));\n\tu8 start_action;\n\tu8 valid_tx_ant = il->hw_params.valid_tx_ant;\n\tu8 tx_chains_num = il->hw_params.tx_chains_num;\n\tu8 update_search_tbl_counter = 0;\n\tint ret;\n\n\tstart_action = tbl->action;\n\tfor (;;) {\n\t\tlq_sta->action_counter++;\n\t\tswitch (tbl->action) {\n\t\tcase IL_MIMO2_SWITCH_ANTENNA1:\n\t\tcase IL_MIMO2_SWITCH_ANTENNA2:\n\t\t\tD_RATE(\"LQ: MIMO2 toggle Antennas\\n\");\n\n\t\t\tif (tx_chains_num <= 2)\n\t\t\t\tbreak;\n\n\t\t\tif (win->success_ratio >= IL_RS_GOOD_RATIO)\n\t\t\t\tbreak;\n\n\t\t\tmemcpy(search_tbl, tbl, sz);\n\t\t\tif (il4965_rs_toggle_antenna\n\t\t\t    (valid_tx_ant, &search_tbl->current_rate,\n\t\t\t     search_tbl)) {\n\t\t\t\tupdate_search_tbl_counter = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IL_MIMO2_SWITCH_SISO_A:\n\t\tcase IL_MIMO2_SWITCH_SISO_B:\n\t\tcase IL_MIMO2_SWITCH_SISO_C:\n\t\t\tD_RATE(\"LQ: MIMO2 switch to SISO\\n\");\n\n\t\t\t \n\t\t\tmemcpy(search_tbl, tbl, sz);\n\n\t\t\tif (tbl->action == IL_MIMO2_SWITCH_SISO_A)\n\t\t\t\tsearch_tbl->ant_type = ANT_A;\n\t\t\telse if (tbl->action == IL_MIMO2_SWITCH_SISO_B)\n\t\t\t\tsearch_tbl->ant_type = ANT_B;\n\t\t\telse\n\t\t\t\tsearch_tbl->ant_type = ANT_C;\n\n\t\t\tif (!il4965_rs_is_valid_ant\n\t\t\t    (valid_tx_ant, search_tbl->ant_type))\n\t\t\t\tbreak;\n\n\t\t\tret =\n\t\t\t    il4965_rs_switch_to_siso(il, lq_sta, conf, sta,\n\t\t\t\t\t\t     search_tbl, idx);\n\t\t\tif (!ret)\n\t\t\t\tgoto out;\n\n\t\t\tbreak;\n\n\t\tcase IL_MIMO2_SWITCH_GI:\n\t\t\tif (!tbl->is_ht40 &&\n\t\t\t    !(ht_cap->cap & IEEE80211_HT_CAP_SGI_20))\n\t\t\t\tbreak;\n\t\t\tif (tbl->is_ht40 &&\n\t\t\t    !(ht_cap->cap & IEEE80211_HT_CAP_SGI_40))\n\t\t\t\tbreak;\n\n\t\t\tD_RATE(\"LQ: MIMO2 toggle SGI/NGI\\n\");\n\n\t\t\t \n\t\t\tmemcpy(search_tbl, tbl, sz);\n\t\t\tsearch_tbl->is_SGI = !tbl->is_SGI;\n\t\t\til4965_rs_set_expected_tpt_table(lq_sta, search_tbl);\n\t\t\t \n\t\t\tif (tbl->is_SGI) {\n\t\t\t\ts32 tpt = lq_sta->last_tpt / 100;\n\t\t\t\tif (tpt >= search_tbl->expected_tpt[idx])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsearch_tbl->current_rate =\n\t\t\t    il4965_rate_n_flags_from_tbl(il, search_tbl, idx,\n\t\t\t\t\t\t\t is_green);\n\t\t\tupdate_search_tbl_counter = 1;\n\t\t\tgoto out;\n\n\t\t}\n\t\ttbl->action++;\n\t\tif (tbl->action > IL_MIMO2_SWITCH_GI)\n\t\t\ttbl->action = IL_MIMO2_SWITCH_ANTENNA1;\n\n\t\tif (tbl->action == start_action)\n\t\t\tbreak;\n\t}\n\tsearch_tbl->lq_type = LQ_NONE;\n\treturn 0;\nout:\n\tlq_sta->search_better_tbl = 1;\n\ttbl->action++;\n\tif (tbl->action > IL_MIMO2_SWITCH_GI)\n\t\ttbl->action = IL_MIMO2_SWITCH_ANTENNA1;\n\tif (update_search_tbl_counter)\n\t\tsearch_tbl->action = tbl->action;\n\n\treturn 0;\n\n}\n\n \nstatic void\nil4965_rs_stay_in_table(struct il_lq_sta *lq_sta, bool force_search)\n{\n\tstruct il_scale_tbl_info *tbl;\n\tint i;\n\tint active_tbl;\n\tint flush_interval_passed = 0;\n\tstruct il_priv *il;\n\n\til = lq_sta->drv;\n\tactive_tbl = lq_sta->active_tbl;\n\n\ttbl = &(lq_sta->lq_info[active_tbl]);\n\n\t \n\tif (lq_sta->stay_in_tbl) {\n\n\t\t \n\t\tif (lq_sta->flush_timer)\n\t\t\tflush_interval_passed =\n\t\t\t    time_after(jiffies,\n\t\t\t\t       (unsigned long)(lq_sta->flush_timer +\n\t\t\t\t\t\t       RATE_SCALE_FLUSH_INTVL));\n\n\t\t \n\t\tif (force_search ||\n\t\t    lq_sta->total_failed > lq_sta->max_failure_limit ||\n\t\t    lq_sta->total_success > lq_sta->max_success_limit ||\n\t\t    (!lq_sta->search_better_tbl && lq_sta->flush_timer &&\n\t\t     flush_interval_passed)) {\n\t\t\tD_RATE(\"LQ: stay is expired %d %d %d\\n\",\n\t\t\t       lq_sta->total_failed, lq_sta->total_success,\n\t\t\t       flush_interval_passed);\n\n\t\t\t \n\t\t\tlq_sta->stay_in_tbl = 0;\t \n\t\t\tlq_sta->total_failed = 0;\n\t\t\tlq_sta->total_success = 0;\n\t\t\tlq_sta->flush_timer = 0;\n\n\t\t\t \n\t\t} else {\n\t\t\tlq_sta->table_count++;\n\t\t\tif (lq_sta->table_count >= lq_sta->table_count_limit) {\n\t\t\t\tlq_sta->table_count = 0;\n\n\t\t\t\tD_RATE(\"LQ: stay in table clear win\\n\");\n\t\t\t\tfor (i = 0; i < RATE_COUNT; i++)\n\t\t\t\t\til4965_rs_rate_scale_clear_win(&\n\t\t\t\t\t\t\t\t       (tbl->\n\t\t\t\t\t\t\t\t\twin\n\t\t\t\t\t\t\t\t\t[i]));\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!lq_sta->stay_in_tbl) {\n\t\t\tfor (i = 0; i < RATE_COUNT; i++)\n\t\t\t\til4965_rs_rate_scale_clear_win(&(tbl->win[i]));\n\t\t}\n\t}\n}\n\n \nstatic void\nil4965_rs_update_rate_tbl(struct il_priv *il, struct il_lq_sta *lq_sta,\n\t\t\t  struct il_scale_tbl_info *tbl, int idx, u8 is_green)\n{\n\tu32 rate;\n\n\t \n\trate = il4965_rate_n_flags_from_tbl(il, tbl, idx, is_green);\n\til4965_rs_fill_link_cmd(il, lq_sta, rate);\n\til_send_lq_cmd(il, &lq_sta->lq, CMD_ASYNC, false);\n}\n\n \nstatic void\nil4965_rs_rate_scale_perform(struct il_priv *il, struct sk_buff *skb,\n\t\t\t     struct ieee80211_sta *sta,\n\t\t\t     struct il_lq_sta *lq_sta)\n{\n\tstruct ieee80211_hw *hw = il->hw;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tint low = RATE_INVALID;\n\tint high = RATE_INVALID;\n\tint idx;\n\tint i;\n\tstruct il_rate_scale_data *win = NULL;\n\tint current_tpt = IL_INVALID_VALUE;\n\tint low_tpt = IL_INVALID_VALUE;\n\tint high_tpt = IL_INVALID_VALUE;\n\tu32 fail_count;\n\ts8 scale_action = 0;\n\tu16 rate_mask;\n\tu8 update_lq = 0;\n\tstruct il_scale_tbl_info *tbl, *tbl1;\n\tu16 rate_scale_idx_msk = 0;\n\tu8 is_green = 0;\n\tu8 active_tbl = 0;\n\tu8 done_search = 0;\n\tu16 high_low;\n\ts32 sr;\n\tu8 tid;\n\tstruct il_tid_data *tid_data;\n\n\tD_RATE(\"rate scale calculate new rate for skb\\n\");\n\n\t \n\t \n\tif (!ieee80211_is_data(hdr->frame_control) ||\n\t    (info->flags & IEEE80211_TX_CTL_NO_ACK))\n\t\treturn;\n\n\tlq_sta->supp_rates = sta->deflink.supp_rates[lq_sta->band];\n\n\ttid = il4965_rs_tl_add_packet(lq_sta, hdr);\n\tif (tid != MAX_TID_COUNT && (lq_sta->tx_agg_tid_en & (1 << tid))) {\n\t\ttid_data = &il->stations[lq_sta->lq.sta_id].tid[tid];\n\t\tif (tid_data->agg.state == IL_AGG_OFF)\n\t\t\tlq_sta->is_agg = 0;\n\t\telse\n\t\t\tlq_sta->is_agg = 1;\n\t} else\n\t\tlq_sta->is_agg = 0;\n\n\t \n\tif (!lq_sta->search_better_tbl)\n\t\tactive_tbl = lq_sta->active_tbl;\n\telse\n\t\tactive_tbl = 1 - lq_sta->active_tbl;\n\n\ttbl = &(lq_sta->lq_info[active_tbl]);\n\tif (is_legacy(tbl->lq_type))\n\t\tlq_sta->is_green = 0;\n\telse\n\t\tlq_sta->is_green = il4965_rs_use_green(il, sta);\n\tis_green = lq_sta->is_green;\n\n\t \n\tidx = lq_sta->last_txrate_idx;\n\n\tD_RATE(\"Rate scale idx %d for type %d\\n\", idx, tbl->lq_type);\n\n\t \n\trate_mask = il4965_rs_get_supported_rates(lq_sta, hdr, tbl->lq_type);\n\n\tD_RATE(\"mask 0x%04X\\n\", rate_mask);\n\n\t \n\tif (is_legacy(tbl->lq_type)) {\n\t\tif (lq_sta->band == NL80211_BAND_5GHZ)\n\t\t\t \n\t\t\trate_scale_idx_msk =\n\t\t\t    (u16) (rate_mask &\n\t\t\t\t   (lq_sta->supp_rates << IL_FIRST_OFDM_RATE));\n\t\telse\n\t\t\trate_scale_idx_msk =\n\t\t\t    (u16) (rate_mask & lq_sta->supp_rates);\n\n\t} else\n\t\trate_scale_idx_msk = rate_mask;\n\n\tif (!rate_scale_idx_msk)\n\t\trate_scale_idx_msk = rate_mask;\n\n\tif (!((1 << idx) & rate_scale_idx_msk)) {\n\t\tIL_ERR(\"Current Rate is not valid\\n\");\n\t\tif (lq_sta->search_better_tbl) {\n\t\t\t \n\t\t\ttbl->lq_type = LQ_NONE;\n\t\t\tlq_sta->search_better_tbl = 0;\n\t\t\ttbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\n\t\t\t \n\t\t\tidx = il4965_hwrate_to_plcp_idx(tbl->current_rate);\n\t\t\til4965_rs_update_rate_tbl(il, lq_sta, tbl, idx,\n\t\t\t\t\t\t      is_green);\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tif (!tbl->expected_tpt) {\n\t\tIL_ERR(\"tbl->expected_tpt is NULL\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (lq_sta->max_rate_idx != -1 && lq_sta->max_rate_idx < idx) {\n\t\tidx = lq_sta->max_rate_idx;\n\t\tupdate_lq = 1;\n\t\twin = &(tbl->win[idx]);\n\t\tgoto lq_update;\n\t}\n\n\twin = &(tbl->win[idx]);\n\n\t \n\tfail_count = win->counter - win->success_counter;\n\tif (fail_count < RATE_MIN_FAILURE_TH &&\n\t    win->success_counter < RATE_MIN_SUCCESS_TH) {\n\t\tD_RATE(\"LQ: still below TH. succ=%d total=%d \" \"for idx %d\\n\",\n\t\t       win->success_counter, win->counter, idx);\n\n\t\t \n\t\twin->average_tpt = IL_INVALID_VALUE;\n\n\t\t \n\t\til4965_rs_stay_in_table(lq_sta, false);\n\n\t\tgoto out;\n\t}\n\t \n\tif (win->average_tpt !=\n\t    ((win->success_ratio * tbl->expected_tpt[idx] + 64) / 128)) {\n\t\tIL_ERR(\"expected_tpt should have been calculated by now\\n\");\n\t\twin->average_tpt =\n\t\t    ((win->success_ratio * tbl->expected_tpt[idx] + 64) / 128);\n\t}\n\n\t \n\tif (lq_sta->search_better_tbl) {\n\t\t \n\t\tif (win->average_tpt > lq_sta->last_tpt) {\n\n\t\t\tD_RATE(\"LQ: SWITCHING TO NEW TBL \"\n\t\t\t       \"suc=%d cur-tpt=%d old-tpt=%d\\n\",\n\t\t\t       win->success_ratio, win->average_tpt,\n\t\t\t       lq_sta->last_tpt);\n\n\t\t\tif (!is_legacy(tbl->lq_type))\n\t\t\t\tlq_sta->enable_counter = 1;\n\n\t\t\t \n\t\t\tlq_sta->active_tbl = active_tbl;\n\t\t\tcurrent_tpt = win->average_tpt;\n\n\t\t\t \n\t\t} else {\n\n\t\t\tD_RATE(\"LQ: GOING BACK TO THE OLD TBL \"\n\t\t\t       \"suc=%d cur-tpt=%d old-tpt=%d\\n\",\n\t\t\t       win->success_ratio, win->average_tpt,\n\t\t\t       lq_sta->last_tpt);\n\n\t\t\t \n\t\t\ttbl->lq_type = LQ_NONE;\n\n\t\t\t \n\t\t\tactive_tbl = lq_sta->active_tbl;\n\t\t\ttbl = &(lq_sta->lq_info[active_tbl]);\n\n\t\t\t \n\t\t\tidx = il4965_hwrate_to_plcp_idx(tbl->current_rate);\n\t\t\tcurrent_tpt = lq_sta->last_tpt;\n\n\t\t\t \n\t\t\tupdate_lq = 1;\n\t\t}\n\n\t\t \n\t\tlq_sta->search_better_tbl = 0;\n\t\tdone_search = 1;\t \n\t\tgoto lq_update;\n\t}\n\n\t \n\thigh_low =\n\t    il4965_rs_get_adjacent_rate(il, idx, rate_scale_idx_msk,\n\t\t\t\t\ttbl->lq_type);\n\tlow = high_low & 0xff;\n\thigh = (high_low >> 8) & 0xff;\n\n\t \n\tif (lq_sta->max_rate_idx != -1 && lq_sta->max_rate_idx < high)\n\t\thigh = RATE_INVALID;\n\n\tsr = win->success_ratio;\n\n\t \n\tcurrent_tpt = win->average_tpt;\n\tif (low != RATE_INVALID)\n\t\tlow_tpt = tbl->win[low].average_tpt;\n\tif (high != RATE_INVALID)\n\t\thigh_tpt = tbl->win[high].average_tpt;\n\n\tscale_action = 0;\n\n\t \n\tif (sr <= RATE_DECREASE_TH || current_tpt == 0) {\n\t\tD_RATE(\"decrease rate because of low success_ratio\\n\");\n\t\tscale_action = -1;\n\n\t\t \n\t} else if (low_tpt == IL_INVALID_VALUE && high_tpt == IL_INVALID_VALUE) {\n\n\t\tif (high != RATE_INVALID && sr >= RATE_INCREASE_TH)\n\t\t\tscale_action = 1;\n\t\telse if (low != RATE_INVALID)\n\t\t\tscale_action = 0;\n\t}\n\n\t \n\telse if (low_tpt != IL_INVALID_VALUE && high_tpt != IL_INVALID_VALUE &&\n\t\t low_tpt < current_tpt && high_tpt < current_tpt)\n\t\tscale_action = 0;\n\n\t \n\telse {\n\t\t \n\t\tif (high_tpt != IL_INVALID_VALUE) {\n\t\t\t \n\t\t\tif (high_tpt > current_tpt && sr >= RATE_INCREASE_TH)\n\t\t\t\tscale_action = 1;\n\t\t\telse\n\t\t\t\tscale_action = 0;\n\n\t\t\t \n\t\t} else if (low_tpt != IL_INVALID_VALUE) {\n\t\t\t \n\t\t\tif (low_tpt > current_tpt) {\n\t\t\t\tD_RATE(\"decrease rate because of low tpt\\n\");\n\t\t\t\tscale_action = -1;\n\t\t\t} else if (sr >= RATE_INCREASE_TH) {\n\t\t\t\tscale_action = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (scale_action == -1 && low != RATE_INVALID &&\n\t    (sr > RATE_HIGH_TH || current_tpt > 100 * tbl->expected_tpt[low]))\n\t\tscale_action = 0;\n\n\tswitch (scale_action) {\n\tcase -1:\n\t\t \n\t\tif (low != RATE_INVALID) {\n\t\t\tupdate_lq = 1;\n\t\t\tidx = low;\n\t\t}\n\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tif (high != RATE_INVALID) {\n\t\t\tupdate_lq = 1;\n\t\t\tidx = high;\n\t\t}\n\n\t\tbreak;\n\tcase 0:\n\t\t \n\tdefault:\n\t\tbreak;\n\t}\n\n\tD_RATE(\"choose rate scale idx %d action %d low %d \" \"high %d type %d\\n\",\n\t       idx, scale_action, low, high, tbl->lq_type);\n\nlq_update:\n\t \n\tif (update_lq)\n\t\til4965_rs_update_rate_tbl(il, lq_sta, tbl, idx, is_green);\n\n\t \n\til4965_rs_stay_in_table(lq_sta, false);\n\n\t \n\tif (!update_lq && !done_search && !lq_sta->stay_in_tbl && win->counter) {\n\t\t \n\t\tlq_sta->last_tpt = current_tpt;\n\n\t\t \n\t\tif (is_legacy(tbl->lq_type))\n\t\t\til4965_rs_move_legacy_other(il, lq_sta, conf, sta, idx);\n\t\telse if (is_siso(tbl->lq_type))\n\t\t\til4965_rs_move_siso_to_other(il, lq_sta, conf, sta,\n\t\t\t\t\t\t     idx);\n\t\telse\t\t \n\t\t\til4965_rs_move_mimo2_to_other(il, lq_sta, conf, sta,\n\t\t\t\t\t\t      idx);\n\n\t\t \n\t\tif (lq_sta->search_better_tbl) {\n\t\t\t \n\t\t\ttbl = &(lq_sta->lq_info[(1 - lq_sta->active_tbl)]);\n\t\t\tfor (i = 0; i < RATE_COUNT; i++)\n\t\t\t\til4965_rs_rate_scale_clear_win(&(tbl->win[i]));\n\n\t\t\t \n\t\t\tidx = il4965_hwrate_to_plcp_idx(tbl->current_rate);\n\n\t\t\tD_RATE(\"Switch current  mcs: %X idx: %d\\n\",\n\t\t\t       tbl->current_rate, idx);\n\t\t\til4965_rs_fill_link_cmd(il, lq_sta, tbl->current_rate);\n\t\t\til_send_lq_cmd(il, &lq_sta->lq, CMD_ASYNC, false);\n\t\t} else\n\t\t\tdone_search = 1;\n\t}\n\n\tif (done_search && !lq_sta->stay_in_tbl) {\n\t\t \n\t\ttbl1 = &(lq_sta->lq_info[lq_sta->active_tbl]);\n\t\tif (is_legacy(tbl1->lq_type) && !conf_is_ht(conf) &&\n\t\t    lq_sta->action_counter > tbl1->max_search) {\n\t\t\tD_RATE(\"LQ: STAY in legacy table\\n\");\n\t\t\til4965_rs_set_stay_in_table(il, 1, lq_sta);\n\t\t}\n\n\t\t \n\t\tif (lq_sta->enable_counter &&\n\t\t    lq_sta->action_counter >= tbl1->max_search) {\n\t\t\tif (lq_sta->last_tpt > IL_AGG_TPT_THREHOLD &&\n\t\t\t    (lq_sta->tx_agg_tid_en & (1 << tid)) &&\n\t\t\t    tid != MAX_TID_COUNT) {\n\t\t\t\ttid_data =\n\t\t\t\t    &il->stations[lq_sta->lq.sta_id].tid[tid];\n\t\t\t\tif (tid_data->agg.state == IL_AGG_OFF) {\n\t\t\t\t\tD_RATE(\"try to aggregate tid %d\\n\",\n\t\t\t\t\t       tid);\n\t\t\t\t\til4965_rs_tl_turn_on_agg(il, tid,\n\t\t\t\t\t\t\t\t lq_sta, sta);\n\t\t\t\t}\n\t\t\t}\n\t\t\til4965_rs_set_stay_in_table(il, 0, lq_sta);\n\t\t}\n\t}\n\nout:\n\ttbl->current_rate =\n\t    il4965_rate_n_flags_from_tbl(il, tbl, idx, is_green);\n\ti = idx;\n\tlq_sta->last_txrate_idx = i;\n}\n\n \nstatic void\nil4965_rs_initialize_lq(struct il_priv *il, struct ieee80211_conf *conf,\n\t\t\tstruct ieee80211_sta *sta, struct il_lq_sta *lq_sta)\n{\n\tstruct il_scale_tbl_info *tbl;\n\tint rate_idx;\n\tint i;\n\tu32 rate;\n\tu8 use_green;\n\tu8 active_tbl = 0;\n\tu8 valid_tx_ant;\n\n\tif (!sta || !lq_sta)\n\t\treturn;\n\n\tuse_green = il4965_rs_use_green(il, sta);\n\n\ti = lq_sta->last_txrate_idx;\n\n\tvalid_tx_ant = il->hw_params.valid_tx_ant;\n\n\tif (!lq_sta->search_better_tbl)\n\t\tactive_tbl = lq_sta->active_tbl;\n\telse\n\t\tactive_tbl = 1 - lq_sta->active_tbl;\n\n\ttbl = &(lq_sta->lq_info[active_tbl]);\n\n\tif (i < 0 || i >= RATE_COUNT)\n\t\ti = 0;\n\n\trate = il_rates[i].plcp;\n\ttbl->ant_type = il4965_first_antenna(valid_tx_ant);\n\trate |= tbl->ant_type << RATE_MCS_ANT_POS;\n\n\tif (i >= IL_FIRST_CCK_RATE && i <= IL_LAST_CCK_RATE)\n\t\trate |= RATE_MCS_CCK_MSK;\n\n\til4965_rs_get_tbl_info_from_mcs(rate, il->band, tbl, &rate_idx);\n\tif (!il4965_rs_is_valid_ant(valid_tx_ant, tbl->ant_type))\n\t\til4965_rs_toggle_antenna(valid_tx_ant, &rate, tbl);\n\n\trate = il4965_rate_n_flags_from_tbl(il, tbl, rate_idx, use_green);\n\ttbl->current_rate = rate;\n\til4965_rs_set_expected_tpt_table(lq_sta, tbl);\n\til4965_rs_fill_link_cmd(NULL, lq_sta, rate);\n\til->stations[lq_sta->lq.sta_id].lq = &lq_sta->lq;\n\til_send_lq_cmd(il, &lq_sta->lq, CMD_SYNC, true);\n}\n\nstatic void\nil4965_rs_get_rate(void *il_r, struct ieee80211_sta *sta, void *il_sta,\n\t\t   struct ieee80211_tx_rate_control *txrc)\n{\n\n\tstruct sk_buff *skb = txrc->skb;\n\tstruct ieee80211_supported_band *sband = txrc->sband;\n\tstruct il_priv *il __maybe_unused = (struct il_priv *)il_r;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct il_lq_sta *lq_sta = il_sta;\n\tint rate_idx;\n\n\tD_RATE(\"rate scale calculate new rate for skb\\n\");\n\n\t \n\tif (lq_sta) {\n\t\tlq_sta->max_rate_idx = fls(txrc->rate_idx_mask) - 1;\n\t\tif (sband->band == NL80211_BAND_5GHZ &&\n\t\t    lq_sta->max_rate_idx != -1)\n\t\t\tlq_sta->max_rate_idx += IL_FIRST_OFDM_RATE;\n\t\tif (lq_sta->max_rate_idx < 0 ||\n\t\t    lq_sta->max_rate_idx >= RATE_COUNT)\n\t\t\tlq_sta->max_rate_idx = -1;\n\t}\n\n\t \n\tif (lq_sta && !lq_sta->drv) {\n\t\tD_RATE(\"Rate scaling not initialized yet.\\n\");\n\t\til_sta = NULL;\n\t}\n\n\tif (!lq_sta)\n\t\treturn;\n\n\trate_idx = lq_sta->last_txrate_idx;\n\n\tif (lq_sta->last_rate_n_flags & RATE_MCS_HT_MSK) {\n\t\trate_idx -= IL_FIRST_OFDM_RATE;\n\t\t \n\t\trate_idx = (rate_idx > 0) ? (rate_idx - 1) : 0;\n\t\tif (il4965_rs_extract_rate(lq_sta->last_rate_n_flags) >=\n\t\t    RATE_MIMO2_6M_PLCP)\n\t\t\trate_idx = rate_idx + MCS_IDX_PER_STREAM;\n\t\tinfo->control.rates[0].flags = IEEE80211_TX_RC_MCS;\n\t\tif (lq_sta->last_rate_n_flags & RATE_MCS_SGI_MSK)\n\t\t\tinfo->control.rates[0].flags |=\n\t\t\t    IEEE80211_TX_RC_SHORT_GI;\n\t\tif (lq_sta->last_rate_n_flags & RATE_MCS_DUP_MSK)\n\t\t\tinfo->control.rates[0].flags |=\n\t\t\t    IEEE80211_TX_RC_DUP_DATA;\n\t\tif (lq_sta->last_rate_n_flags & RATE_MCS_HT40_MSK)\n\t\t\tinfo->control.rates[0].flags |=\n\t\t\t    IEEE80211_TX_RC_40_MHZ_WIDTH;\n\t\tif (lq_sta->last_rate_n_flags & RATE_MCS_GF_MSK)\n\t\t\tinfo->control.rates[0].flags |=\n\t\t\t    IEEE80211_TX_RC_GREEN_FIELD;\n\t} else {\n\t\t \n\t\tif (rate_idx < 0 || rate_idx >= RATE_COUNT_LEGACY ||\n\t\t    (sband->band == NL80211_BAND_5GHZ &&\n\t\t     rate_idx < IL_FIRST_OFDM_RATE))\n\t\t\trate_idx = rate_lowest_index(sband, sta);\n\t\t \n\t\telse if (sband->band == NL80211_BAND_5GHZ)\n\t\t\trate_idx -= IL_FIRST_OFDM_RATE;\n\t\tinfo->control.rates[0].flags = 0;\n\t}\n\tinfo->control.rates[0].idx = rate_idx;\n\tinfo->control.rates[0].count = 1;\n}\n\nstatic void *\nil4965_rs_alloc_sta(void *il_rate, struct ieee80211_sta *sta, gfp_t gfp)\n{\n\tstruct il_station_priv *sta_priv =\n\t    (struct il_station_priv *)sta->drv_priv;\n\tstruct il_priv *il;\n\n\til = (struct il_priv *)il_rate;\n\tD_RATE(\"create station rate scale win\\n\");\n\n\treturn &sta_priv->lq_sta;\n}\n\n \nvoid\nil4965_rs_rate_init(struct il_priv *il, struct ieee80211_sta *sta, u8 sta_id)\n{\n\tint i, j;\n\tstruct ieee80211_hw *hw = il->hw;\n\tstruct ieee80211_conf *conf = &il->hw->conf;\n\tstruct ieee80211_sta_ht_cap *ht_cap = &sta->deflink.ht_cap;\n\tstruct il_station_priv *sta_priv;\n\tstruct il_lq_sta *lq_sta;\n\tstruct ieee80211_supported_band *sband;\n\n\tsta_priv = (struct il_station_priv *)sta->drv_priv;\n\tlq_sta = &sta_priv->lq_sta;\n\tsband = hw->wiphy->bands[conf->chandef.chan->band];\n\n\tlq_sta->lq.sta_id = sta_id;\n\n\tfor (j = 0; j < LQ_SIZE; j++)\n\t\tfor (i = 0; i < RATE_COUNT; i++)\n\t\t\til4965_rs_rate_scale_clear_win(&lq_sta->lq_info[j].\n\t\t\t\t\t\t       win[i]);\n\n\tlq_sta->flush_timer = 0;\n\tlq_sta->supp_rates = sta->deflink.supp_rates[sband->band];\n\tfor (j = 0; j < LQ_SIZE; j++)\n\t\tfor (i = 0; i < RATE_COUNT; i++)\n\t\t\til4965_rs_rate_scale_clear_win(&lq_sta->lq_info[j].\n\t\t\t\t\t\t       win[i]);\n\n\tD_RATE(\"LQ:\" \"*** rate scale station global init for station %d ***\\n\",\n\t       sta_id);\n\t \n\n\tlq_sta->is_dup = 0;\n\tlq_sta->max_rate_idx = -1;\n\tlq_sta->missed_rate_counter = IL_MISSED_RATE_MAX;\n\tlq_sta->is_green = il4965_rs_use_green(il, sta);\n\tlq_sta->active_legacy_rate = il->active_rate & ~(0x1000);\n\tlq_sta->band = il->band;\n\t \n\tlq_sta->active_siso_rate = ht_cap->mcs.rx_mask[0] << 1;\n\tlq_sta->active_siso_rate |= ht_cap->mcs.rx_mask[0] & 0x1;\n\tlq_sta->active_siso_rate &= ~((u16) 0x2);\n\tlq_sta->active_siso_rate <<= IL_FIRST_OFDM_RATE;\n\n\t \n\tlq_sta->active_mimo2_rate = ht_cap->mcs.rx_mask[1] << 1;\n\tlq_sta->active_mimo2_rate |= ht_cap->mcs.rx_mask[1] & 0x1;\n\tlq_sta->active_mimo2_rate &= ~((u16) 0x2);\n\tlq_sta->active_mimo2_rate <<= IL_FIRST_OFDM_RATE;\n\n\t \n\tlq_sta->lq.general_params.single_stream_ant_msk =\n\t    il4965_first_antenna(il->hw_params.valid_tx_ant);\n\tlq_sta->lq.general_params.dual_stream_ant_msk =\n\t    il->hw_params.valid_tx_ant & ~il4965_first_antenna(il->hw_params.\n\t\t\t\t\t\t\t       valid_tx_ant);\n\tif (!lq_sta->lq.general_params.dual_stream_ant_msk) {\n\t\tlq_sta->lq.general_params.dual_stream_ant_msk = ANT_AB;\n\t} else if (il4965_num_of_ant(il->hw_params.valid_tx_ant) == 2) {\n\t\tlq_sta->lq.general_params.dual_stream_ant_msk =\n\t\t    il->hw_params.valid_tx_ant;\n\t}\n\n\t \n\tlq_sta->tx_agg_tid_en = IL_AGG_ALL_TID;\n\tlq_sta->drv = il;\n\n\t \n\tlq_sta->last_txrate_idx = rate_lowest_index(sband, sta);\n\tif (sband->band == NL80211_BAND_5GHZ)\n\t\tlq_sta->last_txrate_idx += IL_FIRST_OFDM_RATE;\n\tlq_sta->is_agg = 0;\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tlq_sta->dbg_fixed_rate = 0;\n#endif\n\n\til4965_rs_initialize_lq(il, conf, sta, lq_sta);\n}\n\nstatic void\nil4965_rs_fill_link_cmd(struct il_priv *il, struct il_lq_sta *lq_sta,\n\t\t\tu32 new_rate)\n{\n\tstruct il_scale_tbl_info tbl_type;\n\tint idx = 0;\n\tint rate_idx;\n\tint repeat_rate = 0;\n\tu8 ant_toggle_cnt = 0;\n\tu8 use_ht_possible = 1;\n\tu8 valid_tx_ant = 0;\n\tstruct il_link_quality_cmd *lq_cmd = &lq_sta->lq;\n\n\t \n\til4965_rs_dbgfs_set_mcs(lq_sta, &new_rate, idx);\n\n\t \n\til4965_rs_get_tbl_info_from_mcs(new_rate, lq_sta->band, &tbl_type,\n\t\t\t\t\t&rate_idx);\n\n\t \n\tif (is_legacy(tbl_type.lq_type)) {\n\t\tant_toggle_cnt = 1;\n\t\trepeat_rate = IL_NUMBER_TRY;\n\t} else {\n\t\trepeat_rate = IL_HT_NUMBER_TRY;\n\t}\n\n\tlq_cmd->general_params.mimo_delimiter =\n\t    is_mimo(tbl_type.lq_type) ? 1 : 0;\n\n\t \n\tlq_cmd->rs_table[idx].rate_n_flags = cpu_to_le32(new_rate);\n\n\tif (il4965_num_of_ant(tbl_type.ant_type) == 1) {\n\t\tlq_cmd->general_params.single_stream_ant_msk =\n\t\t    tbl_type.ant_type;\n\t} else if (il4965_num_of_ant(tbl_type.ant_type) == 2) {\n\t\tlq_cmd->general_params.dual_stream_ant_msk = tbl_type.ant_type;\n\t}\n\t \n\tidx++;\n\trepeat_rate--;\n\tif (il)\n\t\tvalid_tx_ant = il->hw_params.valid_tx_ant;\n\n\t \n\twhile (idx < LINK_QUAL_MAX_RETRY_NUM) {\n\t\t \n\t\twhile (repeat_rate > 0 && idx < (LINK_QUAL_MAX_RETRY_NUM - 1)) {\n\t\t\tif (is_legacy(tbl_type.lq_type)) {\n\t\t\t\tif (ant_toggle_cnt < NUM_TRY_BEFORE_ANT_TOGGLE)\n\t\t\t\t\tant_toggle_cnt++;\n\t\t\t\telse if (il &&\n\t\t\t\t\t il4965_rs_toggle_antenna(valid_tx_ant,\n\t\t\t\t\t\t\t\t  &new_rate,\n\t\t\t\t\t\t\t\t  &tbl_type))\n\t\t\t\t\tant_toggle_cnt = 1;\n\t\t\t}\n\n\t\t\t \n\t\t\til4965_rs_dbgfs_set_mcs(lq_sta, &new_rate, idx);\n\n\t\t\t \n\t\t\tlq_cmd->rs_table[idx].rate_n_flags =\n\t\t\t    cpu_to_le32(new_rate);\n\t\t\trepeat_rate--;\n\t\t\tidx++;\n\t\t}\n\n\t\til4965_rs_get_tbl_info_from_mcs(new_rate, lq_sta->band,\n\t\t\t\t\t\t&tbl_type, &rate_idx);\n\n\t\t \n\t\tif (is_mimo(tbl_type.lq_type))\n\t\t\tlq_cmd->general_params.mimo_delimiter = idx;\n\n\t\t \n\t\tnew_rate =\n\t\t    il4965_rs_get_lower_rate(lq_sta, &tbl_type, rate_idx,\n\t\t\t\t\t     use_ht_possible);\n\n\t\t \n\t\tif (is_legacy(tbl_type.lq_type)) {\n\t\t\tif (ant_toggle_cnt < NUM_TRY_BEFORE_ANT_TOGGLE)\n\t\t\t\tant_toggle_cnt++;\n\t\t\telse if (il &&\n\t\t\t\t il4965_rs_toggle_antenna(valid_tx_ant,\n\t\t\t\t\t\t\t  &new_rate, &tbl_type))\n\t\t\t\tant_toggle_cnt = 1;\n\n\t\t\trepeat_rate = IL_NUMBER_TRY;\n\t\t} else {\n\t\t\trepeat_rate = IL_HT_NUMBER_TRY;\n\t\t}\n\n\t\t \n\t\tuse_ht_possible = 0;\n\n\t\t \n\t\til4965_rs_dbgfs_set_mcs(lq_sta, &new_rate, idx);\n\n\t\t \n\t\tlq_cmd->rs_table[idx].rate_n_flags = cpu_to_le32(new_rate);\n\n\t\tidx++;\n\t\trepeat_rate--;\n\t}\n\n\tlq_cmd->agg_params.agg_frame_cnt_limit = LINK_QUAL_AGG_FRAME_LIMIT_DEF;\n\tlq_cmd->agg_params.agg_dis_start_th = LINK_QUAL_AGG_DISABLE_START_DEF;\n\n\tlq_cmd->agg_params.agg_time_limit =\n\t    cpu_to_le16(LINK_QUAL_AGG_TIME_LIMIT_DEF);\n}\n\nstatic void *\nil4965_rs_alloc(struct ieee80211_hw *hw)\n{\n\treturn hw->priv;\n}\n\n \nstatic void\nil4965_rs_free(void *il_rate)\n{\n\treturn;\n}\n\nstatic void\nil4965_rs_free_sta(void *il_r, struct ieee80211_sta *sta, void *il_sta)\n{\n\tstruct il_priv *il __maybe_unused = il_r;\n\n\tD_RATE(\"enter\\n\");\n\tD_RATE(\"leave\\n\");\n}\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\nstatic void\nil4965_rs_dbgfs_set_mcs(struct il_lq_sta *lq_sta, u32 * rate_n_flags, int idx)\n{\n\tstruct il_priv *il;\n\tu8 valid_tx_ant;\n\tu8 ant_sel_tx;\n\n\til = lq_sta->drv;\n\tvalid_tx_ant = il->hw_params.valid_tx_ant;\n\tif (lq_sta->dbg_fixed_rate) {\n\t\tant_sel_tx =\n\t\t    ((lq_sta->\n\t\t      dbg_fixed_rate & RATE_MCS_ANT_ABC_MSK) >>\n\t\t     RATE_MCS_ANT_POS);\n\t\tif ((valid_tx_ant & ant_sel_tx) == ant_sel_tx) {\n\t\t\t*rate_n_flags = lq_sta->dbg_fixed_rate;\n\t\t\tD_RATE(\"Fixed rate ON\\n\");\n\t\t} else {\n\t\t\tlq_sta->dbg_fixed_rate = 0;\n\t\t\tIL_ERR\n\t\t\t    (\"Invalid antenna selection 0x%X, Valid is 0x%X\\n\",\n\t\t\t     ant_sel_tx, valid_tx_ant);\n\t\t\tD_RATE(\"Fixed rate OFF\\n\");\n\t\t}\n\t} else {\n\t\tD_RATE(\"Fixed rate OFF\\n\");\n\t}\n}\n\nstatic ssize_t\nil4965_rs_sta_dbgfs_scale_table_write(struct file *file,\n\t\t\t\t      const char __user *user_buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct il_lq_sta *lq_sta = file->private_data;\n\tstruct il_priv *il;\n\tchar buf[64];\n\tsize_t buf_size;\n\tu32 parsed_rate;\n\n\til = lq_sta->drv;\n\tmemset(buf, 0, sizeof(buf));\n\tbuf_size = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\n\tif (sscanf(buf, \"%x\", &parsed_rate) == 1)\n\t\tlq_sta->dbg_fixed_rate = parsed_rate;\n\telse\n\t\tlq_sta->dbg_fixed_rate = 0;\n\n\tlq_sta->active_legacy_rate = 0x0FFF;\t \n\tlq_sta->active_siso_rate = 0x1FD0;\t \n\tlq_sta->active_mimo2_rate = 0x1FD0;\t \n\n\tD_RATE(\"sta_id %d rate 0x%X\\n\", lq_sta->lq.sta_id,\n\t       lq_sta->dbg_fixed_rate);\n\n\tif (lq_sta->dbg_fixed_rate) {\n\t\til4965_rs_fill_link_cmd(NULL, lq_sta, lq_sta->dbg_fixed_rate);\n\t\til_send_lq_cmd(lq_sta->drv, &lq_sta->lq, CMD_ASYNC, false);\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t\nil4965_rs_sta_dbgfs_scale_table_read(struct file *file, char __user *user_buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tchar *buff;\n\tint desc = 0;\n\tint i = 0;\n\tint idx = 0;\n\tssize_t ret;\n\n\tstruct il_lq_sta *lq_sta = file->private_data;\n\tstruct il_priv *il;\n\tstruct il_scale_tbl_info *tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\n\n\til = lq_sta->drv;\n\tbuff = kmalloc(1024, GFP_KERNEL);\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\tdesc += sprintf(buff + desc, \"sta_id %d\\n\", lq_sta->lq.sta_id);\n\tdesc +=\n\t    sprintf(buff + desc, \"failed=%d success=%d rate=0%X\\n\",\n\t\t    lq_sta->total_failed, lq_sta->total_success,\n\t\t    lq_sta->active_legacy_rate);\n\tdesc +=\n\t    sprintf(buff + desc, \"fixed rate 0x%X\\n\", lq_sta->dbg_fixed_rate);\n\tdesc +=\n\t    sprintf(buff + desc, \"valid_tx_ant %s%s%s\\n\",\n\t\t    (il->hw_params.valid_tx_ant & ANT_A) ? \"ANT_A,\" : \"\",\n\t\t    (il->hw_params.valid_tx_ant & ANT_B) ? \"ANT_B,\" : \"\",\n\t\t    (il->hw_params.valid_tx_ant & ANT_C) ? \"ANT_C\" : \"\");\n\tdesc +=\n\t    sprintf(buff + desc, \"lq type %s\\n\",\n\t\t    (is_legacy(tbl->lq_type)) ? \"legacy\" : \"HT\");\n\tif (is_Ht(tbl->lq_type)) {\n\t\tdesc +=\n\t\t    sprintf(buff + desc, \" %s\",\n\t\t\t    (is_siso(tbl->lq_type)) ? \"SISO\" : \"MIMO2\");\n\t\tdesc +=\n\t\t    sprintf(buff + desc, \" %s\",\n\t\t\t    (tbl->is_ht40) ? \"40MHz\" : \"20MHz\");\n\t\tdesc +=\n\t\t    sprintf(buff + desc, \" %s %s %s\\n\",\n\t\t\t    (tbl->is_SGI) ? \"SGI\" : \"\",\n\t\t\t    (lq_sta->is_green) ? \"GF enabled\" : \"\",\n\t\t\t    (lq_sta->is_agg) ? \"AGG on\" : \"\");\n\t}\n\tdesc +=\n\t    sprintf(buff + desc, \"last tx rate=0x%X\\n\",\n\t\t    lq_sta->last_rate_n_flags);\n\tdesc +=\n\t    sprintf(buff + desc,\n\t\t    \"general:\" \"flags=0x%X mimo-d=%d s-ant0x%x d-ant=0x%x\\n\",\n\t\t    lq_sta->lq.general_params.flags,\n\t\t    lq_sta->lq.general_params.mimo_delimiter,\n\t\t    lq_sta->lq.general_params.single_stream_ant_msk,\n\t\t    lq_sta->lq.general_params.dual_stream_ant_msk);\n\n\tdesc +=\n\t    sprintf(buff + desc,\n\t\t    \"agg:\"\n\t\t    \"time_limit=%d dist_start_th=%d frame_cnt_limit=%d\\n\",\n\t\t    le16_to_cpu(lq_sta->lq.agg_params.agg_time_limit),\n\t\t    lq_sta->lq.agg_params.agg_dis_start_th,\n\t\t    lq_sta->lq.agg_params.agg_frame_cnt_limit);\n\n\tdesc +=\n\t    sprintf(buff + desc,\n\t\t    \"Start idx [0]=0x%x [1]=0x%x [2]=0x%x [3]=0x%x\\n\",\n\t\t    lq_sta->lq.general_params.start_rate_idx[0],\n\t\t    lq_sta->lq.general_params.start_rate_idx[1],\n\t\t    lq_sta->lq.general_params.start_rate_idx[2],\n\t\t    lq_sta->lq.general_params.start_rate_idx[3]);\n\n\tfor (i = 0; i < LINK_QUAL_MAX_RETRY_NUM; i++) {\n\t\tidx =\n\t\t    il4965_hwrate_to_plcp_idx(le32_to_cpu\n\t\t\t\t\t      (lq_sta->lq.rs_table[i].\n\t\t\t\t\t       rate_n_flags));\n\t\tif (is_legacy(tbl->lq_type)) {\n\t\t\tdesc +=\n\t\t\t    sprintf(buff + desc, \" rate[%d] 0x%X %smbps\\n\", i,\n\t\t\t\t    le32_to_cpu(lq_sta->lq.rs_table[i].\n\t\t\t\t\t\trate_n_flags),\n\t\t\t\t    il_rate_mcs[idx].mbps);\n\t\t} else {\n\t\t\tdesc +=\n\t\t\t    sprintf(buff + desc, \" rate[%d] 0x%X %smbps (%s)\\n\",\n\t\t\t\t    i,\n\t\t\t\t    le32_to_cpu(lq_sta->lq.rs_table[i].\n\t\t\t\t\t\trate_n_flags),\n\t\t\t\t    il_rate_mcs[idx].mbps,\n\t\t\t\t    il_rate_mcs[idx].mcs);\n\t\t}\n\t}\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buff, desc);\n\tkfree(buff);\n\treturn ret;\n}\n\nstatic const struct file_operations rs_sta_dbgfs_scale_table_ops = {\n\t.write = il4965_rs_sta_dbgfs_scale_table_write,\n\t.read = il4965_rs_sta_dbgfs_scale_table_read,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t\nil4965_rs_sta_dbgfs_stats_table_read(struct file *file, char __user *user_buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tchar *buff;\n\tint desc = 0;\n\tint i, j;\n\tssize_t ret;\n\n\tstruct il_lq_sta *lq_sta = file->private_data;\n\n\tbuff = kmalloc(1024, GFP_KERNEL);\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < LQ_SIZE; i++) {\n\t\tdesc +=\n\t\t    sprintf(buff + desc,\n\t\t\t    \"%s type=%d SGI=%d HT40=%d DUP=%d GF=%d\\n\"\n\t\t\t    \"rate=0x%X\\n\", lq_sta->active_tbl == i ? \"*\" : \"x\",\n\t\t\t    lq_sta->lq_info[i].lq_type,\n\t\t\t    lq_sta->lq_info[i].is_SGI,\n\t\t\t    lq_sta->lq_info[i].is_ht40,\n\t\t\t    lq_sta->lq_info[i].is_dup, lq_sta->is_green,\n\t\t\t    lq_sta->lq_info[i].current_rate);\n\t\tfor (j = 0; j < RATE_COUNT; j++) {\n\t\t\tdesc +=\n\t\t\t    sprintf(buff + desc,\n\t\t\t\t    \"counter=%d success=%d %%=%d\\n\",\n\t\t\t\t    lq_sta->lq_info[i].win[j].counter,\n\t\t\t\t    lq_sta->lq_info[i].win[j].success_counter,\n\t\t\t\t    lq_sta->lq_info[i].win[j].success_ratio);\n\t\t}\n\t}\n\tret = simple_read_from_buffer(user_buf, count, ppos, buff, desc);\n\tkfree(buff);\n\treturn ret;\n}\n\nstatic const struct file_operations rs_sta_dbgfs_stats_table_ops = {\n\t.read = il4965_rs_sta_dbgfs_stats_table_read,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t\nil4965_rs_sta_dbgfs_rate_scale_data_read(struct file *file,\n\t\t\t\t\t char __user *user_buf, size_t count,\n\t\t\t\t\t loff_t *ppos)\n{\n\tchar buff[120];\n\tint desc = 0;\n\tstruct il_lq_sta *lq_sta = file->private_data;\n\tstruct il_scale_tbl_info *tbl = &lq_sta->lq_info[lq_sta->active_tbl];\n\n\tif (is_Ht(tbl->lq_type))\n\t\tdesc +=\n\t\t    sprintf(buff + desc, \"Bit Rate= %d Mb/s\\n\",\n\t\t\t    tbl->expected_tpt[lq_sta->last_txrate_idx]);\n\telse\n\t\tdesc +=\n\t\t    sprintf(buff + desc, \"Bit Rate= %d Mb/s\\n\",\n\t\t\t    il_rates[lq_sta->last_txrate_idx].ieee >> 1);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buff, desc);\n}\n\nstatic const struct file_operations rs_sta_dbgfs_rate_scale_data_ops = {\n\t.read = il4965_rs_sta_dbgfs_rate_scale_data_read,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic void\nil4965_rs_add_debugfs(void *il, void *il_sta, struct dentry *dir)\n{\n\tstruct il_lq_sta *lq_sta = il_sta;\n\n\tdebugfs_create_file(\"rate_scale_table\", 0600, dir, lq_sta,\n\t\t\t    &rs_sta_dbgfs_scale_table_ops);\n\tdebugfs_create_file(\"rate_stats_table\", 0400, dir, lq_sta,\n\t\t\t    &rs_sta_dbgfs_stats_table_ops);\n\tdebugfs_create_file(\"rate_scale_data\", 0400, dir, lq_sta,\n\t\t\t    &rs_sta_dbgfs_rate_scale_data_ops);\n\tdebugfs_create_u8(\"tx_agg_tid_enable\", 0600, dir,\n\t\t\t  &lq_sta->tx_agg_tid_en);\n}\n#endif\n\n \nstatic void\nil4965_rs_rate_init_stub(void *il_r, struct ieee80211_supported_band *sband,\n\t\t\t struct cfg80211_chan_def *chandef,\n\t\t\t struct ieee80211_sta *sta, void *il_sta)\n{\n}\n\nstatic const struct rate_control_ops rs_4965_ops = {\n\t.name = IL4965_RS_NAME,\n\t.tx_status = il4965_rs_tx_status,\n\t.get_rate = il4965_rs_get_rate,\n\t.rate_init = il4965_rs_rate_init_stub,\n\t.alloc = il4965_rs_alloc,\n\t.free = il4965_rs_free,\n\t.alloc_sta = il4965_rs_alloc_sta,\n\t.free_sta = il4965_rs_free_sta,\n#ifdef CONFIG_MAC80211_DEBUGFS\n\t.add_sta_debugfs = il4965_rs_add_debugfs,\n#endif\n};\n\nint\nil4965_rate_control_register(void)\n{\n\treturn ieee80211_rate_control_register(&rs_4965_ops);\n}\n\nvoid\nil4965_rate_control_unregister(void)\n{\n\tieee80211_rate_control_unregister(&rs_4965_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}