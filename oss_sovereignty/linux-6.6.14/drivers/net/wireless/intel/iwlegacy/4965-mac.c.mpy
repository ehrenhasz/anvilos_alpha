{
  "module_name": "4965-mac.c",
  "hash_id": "ee4a1fbeeb86773c6abe0a07aa68d8e82776986120c65d37d6d1fe9cb46eddd0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlegacy/4965-mac.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/firmware.h>\n#include <linux/etherdevice.h>\n#include <linux/if_arp.h>\n#include <linux/units.h>\n\n#include <net/mac80211.h>\n\n#include <asm/div64.h>\n\n#define DRV_NAME        \"iwl4965\"\n\n#include \"common.h\"\n#include \"4965.h\"\n\n \n\n \n#define DRV_DESCRIPTION\t\"Intel(R) Wireless WiFi 4965 driver for Linux\"\n\n#ifdef CONFIG_IWLEGACY_DEBUG\n#define VD \"d\"\n#else\n#define VD\n#endif\n\n#define DRV_VERSION     IWLWIFI_VERSION VD\n\nMODULE_DESCRIPTION(DRV_DESCRIPTION);\nMODULE_VERSION(DRV_VERSION);\nMODULE_AUTHOR(DRV_COPYRIGHT \" \" DRV_AUTHOR);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"iwl4965\");\n\nvoid\nil4965_check_abort_status(struct il_priv *il, u8 frame_count, u32 status)\n{\n\tif (frame_count == 1 && status == TX_STATUS_FAIL_RFKILL_FLUSH) {\n\t\tIL_ERR(\"Tx flush command to flush out all frames\\n\");\n\t\tif (!test_bit(S_EXIT_PENDING, &il->status))\n\t\t\tqueue_work(il->workqueue, &il->tx_flush);\n\t}\n}\n\n \nstruct il_mod_params il4965_mod_params = {\n\t.restart_fw = 1,\n\t \n};\n\nvoid\nil4965_rx_queue_reset(struct il_priv *il, struct il_rx_queue *rxq)\n{\n\tunsigned long flags;\n\tint i;\n\tspin_lock_irqsave(&rxq->lock, flags);\n\tINIT_LIST_HEAD(&rxq->rx_free);\n\tINIT_LIST_HEAD(&rxq->rx_used);\n\t \n\tfor (i = 0; i < RX_FREE_BUFFERS + RX_QUEUE_SIZE; i++) {\n\t\t \n\t\tif (rxq->pool[i].page != NULL) {\n\t\t\tdma_unmap_page(&il->pci_dev->dev,\n\t\t\t\t       rxq->pool[i].page_dma,\n\t\t\t\t       PAGE_SIZE << il->hw_params.rx_page_order,\n\t\t\t\t       DMA_FROM_DEVICE);\n\t\t\t__il_free_pages(il, rxq->pool[i].page);\n\t\t\trxq->pool[i].page = NULL;\n\t\t}\n\t\tlist_add_tail(&rxq->pool[i].list, &rxq->rx_used);\n\t}\n\n\tfor (i = 0; i < RX_QUEUE_SIZE; i++)\n\t\trxq->queue[i] = NULL;\n\n\t \n\trxq->read = rxq->write = 0;\n\trxq->write_actual = 0;\n\trxq->free_count = 0;\n\tspin_unlock_irqrestore(&rxq->lock, flags);\n}\n\nint\nil4965_rx_init(struct il_priv *il, struct il_rx_queue *rxq)\n{\n\tu32 rb_size;\n\tconst u32 rfdnlog = RX_QUEUE_SIZE_LOG;\t \n\tu32 rb_timeout = 0;\n\n\tif (il->cfg->mod_params->amsdu_size_8K)\n\t\trb_size = FH49_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_8K;\n\telse\n\t\trb_size = FH49_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_4K;\n\n\t \n\til_wr(il, FH49_MEM_RCSR_CHNL0_CONFIG_REG, 0);\n\n\t \n\til_wr(il, FH49_RSCSR_CHNL0_RBDCB_WPTR_REG, 0);\n\n\t \n\til_wr(il, FH49_RSCSR_CHNL0_RBDCB_BASE_REG, (u32) (rxq->bd_dma >> 8));\n\n\t \n\til_wr(il, FH49_RSCSR_CHNL0_STTS_WPTR_REG, rxq->rb_stts_dma >> 4);\n\n\t \n\til_wr(il, FH49_MEM_RCSR_CHNL0_CONFIG_REG,\n\t      FH49_RCSR_RX_CONFIG_CHNL_EN_ENABLE_VAL |\n\t      FH49_RCSR_CHNL0_RX_CONFIG_IRQ_DEST_INT_HOST_VAL |\n\t      FH49_RCSR_CHNL0_RX_CONFIG_SINGLE_FRAME_MSK |\n\t      rb_size |\n\t      (rb_timeout << FH49_RCSR_RX_CONFIG_REG_IRQ_RBTH_POS) |\n\t      (rfdnlog << FH49_RCSR_RX_CONFIG_RBDCB_SIZE_POS));\n\n\t \n\til_write8(il, CSR_INT_COALESCING, IL_HOST_INT_TIMEOUT_DEF);\n\n\treturn 0;\n}\n\nstatic void\nil4965_set_pwr_vmain(struct il_priv *il)\n{\n \n\n\til_set_bits_mask_prph(il, APMG_PS_CTRL_REG,\n\t\t\t      APMG_PS_CTRL_VAL_PWR_SRC_VMAIN,\n\t\t\t      ~APMG_PS_CTRL_MSK_PWR_SRC);\n}\n\nint\nil4965_hw_nic_init(struct il_priv *il)\n{\n\tunsigned long flags;\n\tstruct il_rx_queue *rxq = &il->rxq;\n\tint ret;\n\n\tspin_lock_irqsave(&il->lock, flags);\n\til_apm_init(il);\n\t \n\til_write8(il, CSR_INT_COALESCING, IL_HOST_INT_CALIB_TIMEOUT_DEF);\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\til4965_set_pwr_vmain(il);\n\til4965_nic_config(il);\n\n\t \n\tif (!rxq->bd) {\n\t\tret = il_rx_queue_alloc(il);\n\t\tif (ret) {\n\t\t\tIL_ERR(\"Unable to initialize Rx queue\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else\n\t\til4965_rx_queue_reset(il, rxq);\n\n\til4965_rx_replenish(il);\n\n\til4965_rx_init(il, rxq);\n\n\tspin_lock_irqsave(&il->lock, flags);\n\n\trxq->need_update = 1;\n\til_rx_queue_update_write_ptr(il, rxq);\n\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\t \n\tif (!il->txq) {\n\t\tret = il4965_txq_ctx_alloc(il);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else\n\t\til4965_txq_ctx_reset(il);\n\n\tset_bit(S_INIT, &il->status);\n\n\treturn 0;\n}\n\n \nstatic inline __le32\nil4965_dma_addr2rbd_ptr(struct il_priv *il, dma_addr_t dma_addr)\n{\n\treturn cpu_to_le32((u32) (dma_addr >> 8));\n}\n\n \nvoid\nil4965_rx_queue_restock(struct il_priv *il)\n{\n\tstruct il_rx_queue *rxq = &il->rxq;\n\tstruct list_head *element;\n\tstruct il_rx_buf *rxb;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rxq->lock, flags);\n\twhile (il_rx_queue_space(rxq) > 0 && rxq->free_count) {\n\t\t \n\t\trxb = rxq->queue[rxq->write];\n\t\tBUG_ON(rxb && rxb->page);\n\n\t\t \n\t\telement = rxq->rx_free.next;\n\t\trxb = list_entry(element, struct il_rx_buf, list);\n\t\tlist_del(element);\n\n\t\t \n\t\trxq->bd[rxq->write] =\n\t\t    il4965_dma_addr2rbd_ptr(il, rxb->page_dma);\n\t\trxq->queue[rxq->write] = rxb;\n\t\trxq->write = (rxq->write + 1) & RX_QUEUE_MASK;\n\t\trxq->free_count--;\n\t}\n\tspin_unlock_irqrestore(&rxq->lock, flags);\n\t \n\tif (rxq->free_count <= RX_LOW_WATERMARK)\n\t\tqueue_work(il->workqueue, &il->rx_replenish);\n\n\t \n\tif (rxq->write_actual != (rxq->write & ~0x7)) {\n\t\tspin_lock_irqsave(&rxq->lock, flags);\n\t\trxq->need_update = 1;\n\t\tspin_unlock_irqrestore(&rxq->lock, flags);\n\t\til_rx_queue_update_write_ptr(il, rxq);\n\t}\n}\n\n \nstatic void\nil4965_rx_allocate(struct il_priv *il, gfp_t priority)\n{\n\tstruct il_rx_queue *rxq = &il->rxq;\n\tstruct list_head *element;\n\tstruct il_rx_buf *rxb;\n\tstruct page *page;\n\tdma_addr_t page_dma;\n\tunsigned long flags;\n\tgfp_t gfp_mask = priority;\n\n\twhile (1) {\n\t\tspin_lock_irqsave(&rxq->lock, flags);\n\t\tif (list_empty(&rxq->rx_used)) {\n\t\t\tspin_unlock_irqrestore(&rxq->lock, flags);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock_irqrestore(&rxq->lock, flags);\n\n\t\tif (rxq->free_count > RX_LOW_WATERMARK)\n\t\t\tgfp_mask |= __GFP_NOWARN;\n\n\t\tif (il->hw_params.rx_page_order > 0)\n\t\t\tgfp_mask |= __GFP_COMP;\n\n\t\t \n\t\tpage = alloc_pages(gfp_mask, il->hw_params.rx_page_order);\n\t\tif (!page) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tD_INFO(\"alloc_pages failed, \" \"order: %d\\n\",\n\t\t\t\t       il->hw_params.rx_page_order);\n\n\t\t\tif (rxq->free_count <= RX_LOW_WATERMARK &&\n\t\t\t    net_ratelimit())\n\t\t\t\tIL_ERR(\"Failed to alloc_pages with %s. \"\n\t\t\t\t       \"Only %u free buffers remaining.\\n\",\n\t\t\t\t       priority ==\n\t\t\t\t       GFP_ATOMIC ? \"GFP_ATOMIC\" : \"GFP_KERNEL\",\n\t\t\t\t       rxq->free_count);\n\t\t\t \n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tpage_dma = dma_map_page(&il->pci_dev->dev, page, 0,\n\t\t\t\t\tPAGE_SIZE << il->hw_params.rx_page_order,\n\t\t\t\t\tDMA_FROM_DEVICE);\n\t\tif (unlikely(dma_mapping_error(&il->pci_dev->dev, page_dma))) {\n\t\t\t__free_pages(page, il->hw_params.rx_page_order);\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_lock_irqsave(&rxq->lock, flags);\n\n\t\tif (list_empty(&rxq->rx_used)) {\n\t\t\tspin_unlock_irqrestore(&rxq->lock, flags);\n\t\t\tdma_unmap_page(&il->pci_dev->dev, page_dma,\n\t\t\t\t       PAGE_SIZE << il->hw_params.rx_page_order,\n\t\t\t\t       DMA_FROM_DEVICE);\n\t\t\t__free_pages(page, il->hw_params.rx_page_order);\n\t\t\treturn;\n\t\t}\n\n\t\telement = rxq->rx_used.next;\n\t\trxb = list_entry(element, struct il_rx_buf, list);\n\t\tlist_del(element);\n\n\t\tBUG_ON(rxb->page);\n\n\t\trxb->page = page;\n\t\trxb->page_dma = page_dma;\n\t\tlist_add_tail(&rxb->list, &rxq->rx_free);\n\t\trxq->free_count++;\n\t\til->alloc_rxb_page++;\n\n\t\tspin_unlock_irqrestore(&rxq->lock, flags);\n\t}\n}\n\nvoid\nil4965_rx_replenish(struct il_priv *il)\n{\n\tunsigned long flags;\n\n\til4965_rx_allocate(il, GFP_KERNEL);\n\n\tspin_lock_irqsave(&il->lock, flags);\n\til4965_rx_queue_restock(il);\n\tspin_unlock_irqrestore(&il->lock, flags);\n}\n\nvoid\nil4965_rx_replenish_now(struct il_priv *il)\n{\n\til4965_rx_allocate(il, GFP_ATOMIC);\n\n\til4965_rx_queue_restock(il);\n}\n\n \nvoid\nil4965_rx_queue_free(struct il_priv *il, struct il_rx_queue *rxq)\n{\n\tint i;\n\tfor (i = 0; i < RX_QUEUE_SIZE + RX_FREE_BUFFERS; i++) {\n\t\tif (rxq->pool[i].page != NULL) {\n\t\t\tdma_unmap_page(&il->pci_dev->dev,\n\t\t\t\t       rxq->pool[i].page_dma,\n\t\t\t\t       PAGE_SIZE << il->hw_params.rx_page_order,\n\t\t\t\t       DMA_FROM_DEVICE);\n\t\t\t__il_free_pages(il, rxq->pool[i].page);\n\t\t\trxq->pool[i].page = NULL;\n\t\t}\n\t}\n\n\tdma_free_coherent(&il->pci_dev->dev, 4 * RX_QUEUE_SIZE, rxq->bd,\n\t\t\t  rxq->bd_dma);\n\tdma_free_coherent(&il->pci_dev->dev, sizeof(struct il_rb_status),\n\t\t\t  rxq->rb_stts, rxq->rb_stts_dma);\n\trxq->bd = NULL;\n\trxq->rb_stts = NULL;\n}\n\nint\nil4965_rxq_stop(struct il_priv *il)\n{\n\tint ret;\n\n\t_il_wr(il, FH49_MEM_RCSR_CHNL0_CONFIG_REG, 0);\n\tret = _il_poll_bit(il, FH49_MEM_RSSR_RX_STATUS_REG,\n\t\t\t   FH49_RSSR_CHNL0_RX_STATUS_CHNL_IDLE,\n\t\t\t   FH49_RSSR_CHNL0_RX_STATUS_CHNL_IDLE,\n\t\t\t   1000);\n\tif (ret < 0)\n\t\tIL_ERR(\"Can't stop Rx DMA.\\n\");\n\n\treturn 0;\n}\n\nint\nil4965_hwrate_to_mac80211_idx(u32 rate_n_flags, enum nl80211_band band)\n{\n\tint idx = 0;\n\tint band_offset = 0;\n\n\t \n\tif (rate_n_flags & RATE_MCS_HT_MSK) {\n\t\tidx = (rate_n_flags & 0xff);\n\t\treturn idx;\n\t\t \n\t} else {\n\t\tif (band == NL80211_BAND_5GHZ)\n\t\t\tband_offset = IL_FIRST_OFDM_RATE;\n\t\tfor (idx = band_offset; idx < RATE_COUNT_LEGACY; idx++)\n\t\t\tif (il_rates[idx].plcp == (rate_n_flags & 0xFF))\n\t\t\t\treturn idx - band_offset;\n\t}\n\n\treturn -1;\n}\n\nstatic int\nil4965_calc_rssi(struct il_priv *il, struct il_rx_phy_res *rx_resp)\n{\n\t \n\tstruct il4965_rx_non_cfg_phy *ncphy =\n\t    (struct il4965_rx_non_cfg_phy *)rx_resp->non_cfg_phy_buf;\n\tu32 agc =\n\t    (le16_to_cpu(ncphy->agc_info) & IL49_AGC_DB_MASK) >>\n\t    IL49_AGC_DB_POS;\n\n\tu32 valid_antennae =\n\t    (le16_to_cpu(rx_resp->phy_flags) & IL49_RX_PHY_FLAGS_ANTENNAE_MASK)\n\t    >> IL49_RX_PHY_FLAGS_ANTENNAE_OFFSET;\n\tu8 max_rssi = 0;\n\tu32 i;\n\n\t \n\tfor (i = 0; i < 3; i++)\n\t\tif (valid_antennae & (1 << i))\n\t\t\tmax_rssi = max(ncphy->rssi_info[i << 1], max_rssi);\n\n\tD_STATS(\"Rssi In A %d B %d C %d Max %d AGC dB %d\\n\",\n\t\tncphy->rssi_info[0], ncphy->rssi_info[2], ncphy->rssi_info[4],\n\t\tmax_rssi, agc);\n\n\t \n\treturn max_rssi - agc - IL4965_RSSI_OFFSET;\n}\n\nstatic u32\nil4965_translate_rx_status(struct il_priv *il, u32 decrypt_in)\n{\n\tu32 decrypt_out = 0;\n\n\tif ((decrypt_in & RX_RES_STATUS_STATION_FOUND) ==\n\t    RX_RES_STATUS_STATION_FOUND)\n\t\tdecrypt_out |=\n\t\t    (RX_RES_STATUS_STATION_FOUND |\n\t\t     RX_RES_STATUS_NO_STATION_INFO_MISMATCH);\n\n\tdecrypt_out |= (decrypt_in & RX_RES_STATUS_SEC_TYPE_MSK);\n\n\t \n\tif ((decrypt_in & RX_RES_STATUS_SEC_TYPE_MSK) ==\n\t    RX_RES_STATUS_SEC_TYPE_NONE)\n\t\treturn decrypt_out;\n\n\t \n\tif ((decrypt_in & RX_RES_STATUS_SEC_TYPE_MSK) ==\n\t    RX_RES_STATUS_SEC_TYPE_ERR)\n\t\treturn decrypt_out;\n\n\t \n\tif ((decrypt_in & RX_MPDU_RES_STATUS_DEC_DONE_MSK) !=\n\t    RX_MPDU_RES_STATUS_DEC_DONE_MSK)\n\t\treturn decrypt_out;\n\n\tswitch (decrypt_in & RX_RES_STATUS_SEC_TYPE_MSK) {\n\n\tcase RX_RES_STATUS_SEC_TYPE_CCMP:\n\t\t \n\t\tif (!(decrypt_in & RX_MPDU_RES_STATUS_MIC_OK))\n\t\t\t \n\t\t\tdecrypt_out |= RX_RES_STATUS_BAD_ICV_MIC;\n\t\telse\n\t\t\tdecrypt_out |= RX_RES_STATUS_DECRYPT_OK;\n\n\t\tbreak;\n\n\tcase RX_RES_STATUS_SEC_TYPE_TKIP:\n\t\tif (!(decrypt_in & RX_MPDU_RES_STATUS_TTAK_OK)) {\n\t\t\t \n\t\t\tdecrypt_out |= RX_RES_STATUS_BAD_KEY_TTAK;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\t \n\tdefault:\n\t\tif (!(decrypt_in & RX_MPDU_RES_STATUS_ICV_OK))\n\t\t\tdecrypt_out |= RX_RES_STATUS_BAD_ICV_MIC;\n\t\telse\n\t\t\tdecrypt_out |= RX_RES_STATUS_DECRYPT_OK;\n\t\tbreak;\n\t}\n\n\tD_RX(\"decrypt_in:0x%x  decrypt_out = 0x%x\\n\", decrypt_in, decrypt_out);\n\n\treturn decrypt_out;\n}\n\n#define SMALL_PACKET_SIZE 256\n\nstatic void\nil4965_pass_packet_to_mac80211(struct il_priv *il, struct ieee80211_hdr *hdr,\n\t\t\t       u32 len, u32 ampdu_status, struct il_rx_buf *rxb,\n\t\t\t       struct ieee80211_rx_status *stats)\n{\n\tstruct sk_buff *skb;\n\t__le16 fc = hdr->frame_control;\n\n\t \n\tif (unlikely(!il->is_open)) {\n\t\tD_DROP(\"Dropping packet while interface is not open.\\n\");\n\t\treturn;\n\t}\n\n\tif (unlikely(test_bit(IL_STOP_REASON_PASSIVE, &il->stop_reason))) {\n\t\til_wake_queues_by_reason(il, IL_STOP_REASON_PASSIVE);\n\t\tD_INFO(\"Woke queues - frame received on passive channel\\n\");\n\t}\n\n\t \n\tif (!il->cfg->mod_params->sw_crypto &&\n\t    il_set_decrypted_flag(il, hdr, ampdu_status, stats))\n\t\treturn;\n\n\tskb = dev_alloc_skb(SMALL_PACKET_SIZE);\n\tif (!skb) {\n\t\tIL_ERR(\"dev_alloc_skb failed\\n\");\n\t\treturn;\n\t}\n\n\tif (len <= SMALL_PACKET_SIZE) {\n\t\tskb_put_data(skb, hdr, len);\n\t} else {\n\t\tskb_add_rx_frag(skb, 0, rxb->page, (void *)hdr - rxb_addr(rxb),\n\t\t\t\tlen, PAGE_SIZE << il->hw_params.rx_page_order);\n\t\til->alloc_rxb_page--;\n\t\trxb->page = NULL;\n\t}\n\n\til_update_stats(il, false, fc, len);\n\tmemcpy(IEEE80211_SKB_RXCB(skb), stats, sizeof(*stats));\n\n\tieee80211_rx(il->hw, skb);\n}\n\n \nstatic void\nil4965_hdl_rx(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct ieee80211_hdr *header;\n\tstruct ieee80211_rx_status rx_status = {};\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tstruct il_rx_phy_res *phy_res;\n\t__le32 rx_pkt_status;\n\tstruct il_rx_mpdu_res_start *amsdu;\n\tu32 len;\n\tu32 ampdu_status;\n\tu32 rate_n_flags;\n\n\t \n\tif (pkt->hdr.cmd == N_RX) {\n\t\tphy_res = (struct il_rx_phy_res *)pkt->u.raw;\n\t\theader =\n\t\t    (struct ieee80211_hdr *)(pkt->u.raw + sizeof(*phy_res) +\n\t\t\t\t\t     phy_res->cfg_phy_cnt);\n\n\t\tlen = le16_to_cpu(phy_res->byte_count);\n\t\trx_pkt_status =\n\t\t    *(__le32 *) (pkt->u.raw + sizeof(*phy_res) +\n\t\t\t\t phy_res->cfg_phy_cnt + len);\n\t\tampdu_status = le32_to_cpu(rx_pkt_status);\n\t} else {\n\t\tif (!il->_4965.last_phy_res_valid) {\n\t\t\tIL_ERR(\"MPDU frame without cached PHY data\\n\");\n\t\t\treturn;\n\t\t}\n\t\tphy_res = &il->_4965.last_phy_res;\n\t\tamsdu = (struct il_rx_mpdu_res_start *)pkt->u.raw;\n\t\theader = (struct ieee80211_hdr *)(pkt->u.raw + sizeof(*amsdu));\n\t\tlen = le16_to_cpu(amsdu->byte_count);\n\t\trx_pkt_status = *(__le32 *) (pkt->u.raw + sizeof(*amsdu) + len);\n\t\tampdu_status =\n\t\t    il4965_translate_rx_status(il, le32_to_cpu(rx_pkt_status));\n\t}\n\n\tif ((unlikely(phy_res->cfg_phy_cnt > 20))) {\n\t\tD_DROP(\"dsp size out of range [0,20]: %d\\n\",\n\t\t       phy_res->cfg_phy_cnt);\n\t\treturn;\n\t}\n\n\tif (!(rx_pkt_status & RX_RES_STATUS_NO_CRC32_ERROR) ||\n\t    !(rx_pkt_status & RX_RES_STATUS_NO_RXE_OVERFLOW)) {\n\t\tD_RX(\"Bad CRC or FIFO: 0x%08X.\\n\", le32_to_cpu(rx_pkt_status));\n\t\treturn;\n\t}\n\n\t \n\trate_n_flags = le32_to_cpu(phy_res->rate_n_flags);\n\n\t \n\trx_status.mactime = le64_to_cpu(phy_res->timestamp);\n\trx_status.band =\n\t    (phy_res->\n\t     phy_flags & RX_RES_PHY_FLAGS_BAND_24_MSK) ? NL80211_BAND_2GHZ :\n\t    NL80211_BAND_5GHZ;\n\trx_status.freq =\n\t    ieee80211_channel_to_frequency(le16_to_cpu(phy_res->channel),\n\t\t\t\t\t   rx_status.band);\n\trx_status.rate_idx =\n\t    il4965_hwrate_to_mac80211_idx(rate_n_flags, rx_status.band);\n\trx_status.flag = 0;\n\n\t \n\t \n\n\til->ucode_beacon_time = le32_to_cpu(phy_res->beacon_time_stamp);\n\n\t \n\trx_status.signal = il4965_calc_rssi(il, phy_res);\n\n\tD_STATS(\"Rssi %d, TSF %llu\\n\", rx_status.signal,\n\t\t(unsigned long long)rx_status.mactime);\n\n\t \n\trx_status.antenna =\n\t    (le16_to_cpu(phy_res->phy_flags) & RX_RES_PHY_FLAGS_ANTENNA_MSK) >>\n\t    RX_RES_PHY_FLAGS_ANTENNA_POS;\n\n\t \n\tif (phy_res->phy_flags & RX_RES_PHY_FLAGS_SHORT_PREAMBLE_MSK)\n\t\trx_status.enc_flags |= RX_ENC_FLAG_SHORTPRE;\n\n\t \n\tif (rate_n_flags & RATE_MCS_HT_MSK)\n\t\trx_status.encoding = RX_ENC_HT;\n\tif (rate_n_flags & RATE_MCS_HT40_MSK)\n\t\trx_status.bw = RATE_INFO_BW_40;\n\telse\n\t\trx_status.bw = RATE_INFO_BW_20;\n\tif (rate_n_flags & RATE_MCS_SGI_MSK)\n\t\trx_status.enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\n\tif (phy_res->phy_flags & RX_RES_PHY_FLAGS_AGG_MSK) {\n\t\t \n\n\t\trx_status.flag |= RX_FLAG_AMPDU_DETAILS;\n\t\trx_status.ampdu_reference = il->_4965.ampdu_ref;\n\t}\n\n\til4965_pass_packet_to_mac80211(il, header, len, ampdu_status, rxb,\n\t\t\t\t       &rx_status);\n}\n\n \nstatic void\nil4965_hdl_rx_phy(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\til->_4965.last_phy_res_valid = true;\n\til->_4965.ampdu_ref++;\n\tmemcpy(&il->_4965.last_phy_res, pkt->u.raw,\n\t       sizeof(struct il_rx_phy_res));\n}\n\nstatic int\nil4965_get_channels_for_scan(struct il_priv *il, struct ieee80211_vif *vif,\n\t\t\t     enum nl80211_band band, u8 is_active,\n\t\t\t     u8 n_probes, struct il_scan_channel *scan_ch)\n{\n\tstruct ieee80211_channel *chan;\n\tconst struct ieee80211_supported_band *sband;\n\tconst struct il_channel_info *ch_info;\n\tu16 passive_dwell = 0;\n\tu16 active_dwell = 0;\n\tint added, i;\n\tu16 channel;\n\n\tsband = il_get_hw_mode(il, band);\n\tif (!sband)\n\t\treturn 0;\n\n\tactive_dwell = il_get_active_dwell_time(il, band, n_probes);\n\tpassive_dwell = il_get_passive_dwell_time(il, band, vif);\n\n\tif (passive_dwell <= active_dwell)\n\t\tpassive_dwell = active_dwell + 1;\n\n\tfor (i = 0, added = 0; i < il->scan_request->n_channels; i++) {\n\t\tchan = il->scan_request->channels[i];\n\n\t\tif (chan->band != band)\n\t\t\tcontinue;\n\n\t\tchannel = chan->hw_value;\n\t\tscan_ch->channel = cpu_to_le16(channel);\n\n\t\tch_info = il_get_channel_info(il, band, channel);\n\t\tif (!il_is_channel_valid(ch_info)) {\n\t\t\tD_SCAN(\"Channel %d is INVALID for this band.\\n\",\n\t\t\t       channel);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!is_active || il_is_channel_passive(ch_info) ||\n\t\t    (chan->flags & IEEE80211_CHAN_NO_IR))\n\t\t\tscan_ch->type = SCAN_CHANNEL_TYPE_PASSIVE;\n\t\telse\n\t\t\tscan_ch->type = SCAN_CHANNEL_TYPE_ACTIVE;\n\n\t\tif (n_probes)\n\t\t\tscan_ch->type |= IL_SCAN_PROBE_MASK(n_probes);\n\n\t\tscan_ch->active_dwell = cpu_to_le16(active_dwell);\n\t\tscan_ch->passive_dwell = cpu_to_le16(passive_dwell);\n\n\t\t \n\t\tscan_ch->dsp_atten = 110;\n\n\t\t \n\t\tif (band == NL80211_BAND_5GHZ)\n\t\t\tscan_ch->tx_gain = ((1 << 5) | (3 << 3)) | 3;\n\t\telse\n\t\t\tscan_ch->tx_gain = ((1 << 5) | (5 << 3));\n\n\t\tD_SCAN(\"Scanning ch=%d prob=0x%X [%s %d]\\n\", channel,\n\t\t       le32_to_cpu(scan_ch->type),\n\t\t       (scan_ch->\n\t\t\ttype & SCAN_CHANNEL_TYPE_ACTIVE) ? \"ACTIVE\" : \"PASSIVE\",\n\t\t       (scan_ch->\n\t\t\ttype & SCAN_CHANNEL_TYPE_ACTIVE) ? active_dwell :\n\t\t       passive_dwell);\n\n\t\tscan_ch++;\n\t\tadded++;\n\t}\n\n\tD_SCAN(\"total channels to scan %d\\n\", added);\n\treturn added;\n}\n\nstatic void\nil4965_toggle_tx_ant(struct il_priv *il, u8 *ant, u8 valid)\n{\n\tint i;\n\tu8 ind = *ant;\n\n\tfor (i = 0; i < RATE_ANT_NUM - 1; i++) {\n\t\tind = (ind + 1) < RATE_ANT_NUM ? ind + 1 : 0;\n\t\tif (valid & BIT(ind)) {\n\t\t\t*ant = ind;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint\nil4965_request_scan(struct il_priv *il, struct ieee80211_vif *vif)\n{\n\tstruct il_host_cmd cmd = {\n\t\t.id = C_SCAN,\n\t\t.len = sizeof(struct il_scan_cmd),\n\t\t.flags = CMD_SIZE_HUGE,\n\t};\n\tstruct il_scan_cmd *scan;\n\tu32 rate_flags = 0;\n\tu16 cmd_len;\n\tu16 rx_chain = 0;\n\tenum nl80211_band band;\n\tu8 n_probes = 0;\n\tu8 rx_ant = il->hw_params.valid_rx_ant;\n\tu8 rate;\n\tbool is_active = false;\n\tint chan_mod;\n\tu8 active_chains;\n\tu8 scan_tx_antennas = il->hw_params.valid_tx_ant;\n\tint ret;\n\n\tlockdep_assert_held(&il->mutex);\n\n\tif (!il->scan_cmd) {\n\t\til->scan_cmd =\n\t\t    kmalloc(sizeof(struct il_scan_cmd) + IL_MAX_SCAN_SIZE,\n\t\t\t    GFP_KERNEL);\n\t\tif (!il->scan_cmd) {\n\t\t\tD_SCAN(\"fail to allocate memory for scan\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tscan = il->scan_cmd;\n\tmemset(scan, 0, sizeof(struct il_scan_cmd) + IL_MAX_SCAN_SIZE);\n\n\tscan->quiet_plcp_th = IL_PLCP_QUIET_THRESH;\n\tscan->quiet_time = IL_ACTIVE_QUIET_TIME;\n\n\tif (il_is_any_associated(il)) {\n\t\tu16 interval;\n\t\tu32 extra;\n\t\tu32 suspend_time = 100;\n\t\tu32 scan_suspend_time = 100;\n\n\t\tD_INFO(\"Scanning while associated...\\n\");\n\t\tinterval = vif->bss_conf.beacon_int;\n\n\t\tscan->suspend_time = 0;\n\t\tscan->max_out_time = cpu_to_le32(200 * 1024);\n\t\tif (!interval)\n\t\t\tinterval = suspend_time;\n\n\t\textra = (suspend_time / interval) << 22;\n\t\tscan_suspend_time =\n\t\t    (extra | ((suspend_time % interval) * 1024));\n\t\tscan->suspend_time = cpu_to_le32(scan_suspend_time);\n\t\tD_SCAN(\"suspend_time 0x%X beacon interval %d\\n\",\n\t\t       scan_suspend_time, interval);\n\t}\n\n\tif (il->scan_request->n_ssids) {\n\t\tint i, p = 0;\n\t\tD_SCAN(\"Kicking off active scan\\n\");\n\t\tfor (i = 0; i < il->scan_request->n_ssids; i++) {\n\t\t\t \n\t\t\tif (!il->scan_request->ssids[i].ssid_len)\n\t\t\t\tcontinue;\n\t\t\tscan->direct_scan[p].id = WLAN_EID_SSID;\n\t\t\tscan->direct_scan[p].len =\n\t\t\t    il->scan_request->ssids[i].ssid_len;\n\t\t\tmemcpy(scan->direct_scan[p].ssid,\n\t\t\t       il->scan_request->ssids[i].ssid,\n\t\t\t       il->scan_request->ssids[i].ssid_len);\n\t\t\tn_probes++;\n\t\t\tp++;\n\t\t}\n\t\tis_active = true;\n\t} else\n\t\tD_SCAN(\"Start passive scan.\\n\");\n\n\tscan->tx_cmd.tx_flags = TX_CMD_FLG_SEQ_CTL_MSK;\n\tscan->tx_cmd.sta_id = il->hw_params.bcast_id;\n\tscan->tx_cmd.stop_time.life_time = TX_CMD_LIFE_TIME_INFINITE;\n\n\tswitch (il->scan_band) {\n\tcase NL80211_BAND_2GHZ:\n\t\tscan->flags = RXON_FLG_BAND_24G_MSK | RXON_FLG_AUTO_DETECT_MSK;\n\t\tchan_mod =\n\t\t    le32_to_cpu(il->active.flags & RXON_FLG_CHANNEL_MODE_MSK) >>\n\t\t    RXON_FLG_CHANNEL_MODE_POS;\n\t\tif (chan_mod == CHANNEL_MODE_PURE_40) {\n\t\t\trate = RATE_6M_PLCP;\n\t\t} else {\n\t\t\trate = RATE_1M_PLCP;\n\t\t\trate_flags = RATE_MCS_CCK_MSK;\n\t\t}\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\trate = RATE_6M_PLCP;\n\t\tbreak;\n\tdefault:\n\t\tIL_WARN(\"Invalid scan band\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tscan->good_CRC_th =\n\t    is_active ? IL_GOOD_CRC_TH_DEFAULT : IL_GOOD_CRC_TH_NEVER;\n\n\tband = il->scan_band;\n\n\tif (il->cfg->scan_rx_antennas[band])\n\t\trx_ant = il->cfg->scan_rx_antennas[band];\n\n\til4965_toggle_tx_ant(il, &il->scan_tx_ant[band], scan_tx_antennas);\n\trate_flags |= BIT(il->scan_tx_ant[band]) << RATE_MCS_ANT_POS;\n\tscan->tx_cmd.rate_n_flags = cpu_to_le32(rate | rate_flags);\n\n\t \n\tif (test_bit(S_POWER_PMI, &il->status)) {\n\t\t \n\t\tactive_chains =\n\t\t    rx_ant & ((u8) (il->chain_noise_data.active_chains));\n\t\tif (!active_chains)\n\t\t\tactive_chains = rx_ant;\n\n\t\tD_SCAN(\"chain_noise_data.active_chains: %u\\n\",\n\t\t       il->chain_noise_data.active_chains);\n\n\t\trx_ant = il4965_first_antenna(active_chains);\n\t}\n\n\t \n\trx_chain |= il->hw_params.valid_rx_ant << RXON_RX_CHAIN_VALID_POS;\n\trx_chain |= rx_ant << RXON_RX_CHAIN_FORCE_MIMO_SEL_POS;\n\trx_chain |= rx_ant << RXON_RX_CHAIN_FORCE_SEL_POS;\n\trx_chain |= 0x1 << RXON_RX_CHAIN_DRIVER_FORCE_POS;\n\tscan->rx_chain = cpu_to_le16(rx_chain);\n\n\tcmd_len =\n\t    il_fill_probe_req(il, (struct ieee80211_mgmt *)scan->data,\n\t\t\t      vif->addr, il->scan_request->ie,\n\t\t\t      il->scan_request->ie_len,\n\t\t\t      IL_MAX_SCAN_SIZE - sizeof(*scan));\n\tscan->tx_cmd.len = cpu_to_le16(cmd_len);\n\n\tscan->filter_flags |=\n\t    (RXON_FILTER_ACCEPT_GRP_MSK | RXON_FILTER_BCON_AWARE_MSK);\n\n\tscan->channel_count =\n\t    il4965_get_channels_for_scan(il, vif, band, is_active, n_probes,\n\t\t\t\t\t (void *)&scan->data[cmd_len]);\n\tif (scan->channel_count == 0) {\n\t\tD_SCAN(\"channel count %d\\n\", scan->channel_count);\n\t\treturn -EIO;\n\t}\n\n\tcmd.len +=\n\t    le16_to_cpu(scan->tx_cmd.len) +\n\t    scan->channel_count * sizeof(struct il_scan_channel);\n\tcmd.data = scan;\n\tscan->len = cpu_to_le16(cmd.len);\n\n\tset_bit(S_SCAN_HW, &il->status);\n\n\tret = il_send_cmd_sync(il, &cmd);\n\tif (ret)\n\t\tclear_bit(S_SCAN_HW, &il->status);\n\n\treturn ret;\n}\n\nint\nil4965_manage_ibss_station(struct il_priv *il, struct ieee80211_vif *vif,\n\t\t\t   bool add)\n{\n\tstruct il_vif_priv *vif_priv = (void *)vif->drv_priv;\n\n\tif (add)\n\t\treturn il4965_add_bssid_station(il, vif->bss_conf.bssid,\n\t\t\t\t\t\t&vif_priv->ibss_bssid_sta_id);\n\treturn il_remove_station(il, vif_priv->ibss_bssid_sta_id,\n\t\t\t\t vif->bss_conf.bssid);\n}\n\nvoid\nil4965_free_tfds_in_queue(struct il_priv *il, int sta_id, int tid, int freed)\n{\n\tlockdep_assert_held(&il->sta_lock);\n\n\tif (il->stations[sta_id].tid[tid].tfds_in_queue >= freed)\n\t\til->stations[sta_id].tid[tid].tfds_in_queue -= freed;\n\telse {\n\t\tD_TX(\"free more than tfds_in_queue (%u:%d)\\n\",\n\t\t     il->stations[sta_id].tid[tid].tfds_in_queue, freed);\n\t\til->stations[sta_id].tid[tid].tfds_in_queue = 0;\n\t}\n}\n\n#define IL_TX_QUEUE_MSK\t0xfffff\n\nstatic bool\nil4965_is_single_rx_stream(struct il_priv *il)\n{\n\treturn il->current_ht_config.smps == IEEE80211_SMPS_STATIC ||\n\t    il->current_ht_config.single_chain_sufficient;\n}\n\n#define IL_NUM_RX_CHAINS_MULTIPLE\t3\n#define IL_NUM_RX_CHAINS_SINGLE\t2\n#define IL_NUM_IDLE_CHAINS_DUAL\t2\n#define IL_NUM_IDLE_CHAINS_SINGLE\t1\n\n \nstatic int\nil4965_get_active_rx_chain_count(struct il_priv *il)\n{\n\t \n\tif (il4965_is_single_rx_stream(il))\n\t\treturn IL_NUM_RX_CHAINS_SINGLE;\n\telse\n\t\treturn IL_NUM_RX_CHAINS_MULTIPLE;\n}\n\n \nstatic int\nil4965_get_idle_rx_chain_count(struct il_priv *il, int active_cnt)\n{\n\t \n\tswitch (il->current_ht_config.smps) {\n\tcase IEEE80211_SMPS_STATIC:\n\tcase IEEE80211_SMPS_DYNAMIC:\n\t\treturn IL_NUM_IDLE_CHAINS_SINGLE;\n\tcase IEEE80211_SMPS_OFF:\n\t\treturn active_cnt;\n\tdefault:\n\t\tWARN(1, \"invalid SMPS mode %d\", il->current_ht_config.smps);\n\t\treturn active_cnt;\n\t}\n}\n\n \nstatic u8\nil4965_count_chain_bitmap(u32 chain_bitmap)\n{\n\tu8 res;\n\tres = (chain_bitmap & BIT(0)) >> 0;\n\tres += (chain_bitmap & BIT(1)) >> 1;\n\tres += (chain_bitmap & BIT(2)) >> 2;\n\tres += (chain_bitmap & BIT(3)) >> 3;\n\treturn res;\n}\n\n \nvoid\nil4965_set_rxon_chain(struct il_priv *il)\n{\n\tbool is_single = il4965_is_single_rx_stream(il);\n\tbool is_cam = !test_bit(S_POWER_PMI, &il->status);\n\tu8 idle_rx_cnt, active_rx_cnt, valid_rx_cnt;\n\tu32 active_chains;\n\tu16 rx_chain;\n\n\t \n\tif (il->chain_noise_data.active_chains)\n\t\tactive_chains = il->chain_noise_data.active_chains;\n\telse\n\t\tactive_chains = il->hw_params.valid_rx_ant;\n\n\trx_chain = active_chains << RXON_RX_CHAIN_VALID_POS;\n\n\t \n\tactive_rx_cnt = il4965_get_active_rx_chain_count(il);\n\tidle_rx_cnt = il4965_get_idle_rx_chain_count(il, active_rx_cnt);\n\n\t \n\tvalid_rx_cnt = il4965_count_chain_bitmap(active_chains);\n\tif (valid_rx_cnt < active_rx_cnt)\n\t\tactive_rx_cnt = valid_rx_cnt;\n\n\tif (valid_rx_cnt < idle_rx_cnt)\n\t\tidle_rx_cnt = valid_rx_cnt;\n\n\trx_chain |= active_rx_cnt << RXON_RX_CHAIN_MIMO_CNT_POS;\n\trx_chain |= idle_rx_cnt << RXON_RX_CHAIN_CNT_POS;\n\n\til->staging.rx_chain = cpu_to_le16(rx_chain);\n\n\tif (!is_single && active_rx_cnt >= IL_NUM_RX_CHAINS_SINGLE && is_cam)\n\t\til->staging.rx_chain |= RXON_RX_CHAIN_MIMO_FORCE_MSK;\n\telse\n\t\til->staging.rx_chain &= ~RXON_RX_CHAIN_MIMO_FORCE_MSK;\n\n\tD_ASSOC(\"rx_chain=0x%X active=%d idle=%d\\n\", il->staging.rx_chain,\n\t\tactive_rx_cnt, idle_rx_cnt);\n\n\tWARN_ON(active_rx_cnt == 0 || idle_rx_cnt == 0 ||\n\t\tactive_rx_cnt < idle_rx_cnt);\n}\n\nstatic const char *\nil4965_get_fh_string(int cmd)\n{\n\tswitch (cmd) {\n\t\tIL_CMD(FH49_RSCSR_CHNL0_STTS_WPTR_REG);\n\t\tIL_CMD(FH49_RSCSR_CHNL0_RBDCB_BASE_REG);\n\t\tIL_CMD(FH49_RSCSR_CHNL0_WPTR);\n\t\tIL_CMD(FH49_MEM_RCSR_CHNL0_CONFIG_REG);\n\t\tIL_CMD(FH49_MEM_RSSR_SHARED_CTRL_REG);\n\t\tIL_CMD(FH49_MEM_RSSR_RX_STATUS_REG);\n\t\tIL_CMD(FH49_MEM_RSSR_RX_ENABLE_ERR_IRQ2DRV);\n\t\tIL_CMD(FH49_TSSR_TX_STATUS_REG);\n\t\tIL_CMD(FH49_TSSR_TX_ERROR_REG);\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n}\n\nint\nil4965_dump_fh(struct il_priv *il, char **buf, bool display)\n{\n\tint i;\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tint pos = 0;\n\tsize_t bufsz = 0;\n#endif\n\tstatic const u32 fh_tbl[] = {\n\t\tFH49_RSCSR_CHNL0_STTS_WPTR_REG,\n\t\tFH49_RSCSR_CHNL0_RBDCB_BASE_REG,\n\t\tFH49_RSCSR_CHNL0_WPTR,\n\t\tFH49_MEM_RCSR_CHNL0_CONFIG_REG,\n\t\tFH49_MEM_RSSR_SHARED_CTRL_REG,\n\t\tFH49_MEM_RSSR_RX_STATUS_REG,\n\t\tFH49_MEM_RSSR_RX_ENABLE_ERR_IRQ2DRV,\n\t\tFH49_TSSR_TX_STATUS_REG,\n\t\tFH49_TSSR_TX_ERROR_REG\n\t};\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tif (display) {\n\t\tbufsz = ARRAY_SIZE(fh_tbl) * 48 + 40;\n\t\t*buf = kmalloc(bufsz, GFP_KERNEL);\n\t\tif (!*buf)\n\t\t\treturn -ENOMEM;\n\t\tpos +=\n\t\t    scnprintf(*buf + pos, bufsz - pos, \"FH register values:\\n\");\n\t\tfor (i = 0; i < ARRAY_SIZE(fh_tbl); i++) {\n\t\t\tpos +=\n\t\t\t    scnprintf(*buf + pos, bufsz - pos,\n\t\t\t\t      \"  %34s: 0X%08x\\n\",\n\t\t\t\t      il4965_get_fh_string(fh_tbl[i]),\n\t\t\t\t      il_rd(il, fh_tbl[i]));\n\t\t}\n\t\treturn pos;\n\t}\n#endif\n\tIL_ERR(\"FH register values:\\n\");\n\tfor (i = 0; i < ARRAY_SIZE(fh_tbl); i++) {\n\t\tIL_ERR(\"  %34s: 0X%08x\\n\", il4965_get_fh_string(fh_tbl[i]),\n\t\t       il_rd(il, fh_tbl[i]));\n\t}\n\treturn 0;\n}\n\nstatic void\nil4965_hdl_missed_beacon(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tstruct il_missed_beacon_notif *missed_beacon;\n\n\tmissed_beacon = &pkt->u.missed_beacon;\n\tif (le32_to_cpu(missed_beacon->consecutive_missed_beacons) >\n\t    il->missed_beacon_threshold) {\n\t\tD_CALIB(\"missed bcn cnsq %d totl %d rcd %d expctd %d\\n\",\n\t\t\tle32_to_cpu(missed_beacon->consecutive_missed_beacons),\n\t\t\tle32_to_cpu(missed_beacon->total_missed_becons),\n\t\t\tle32_to_cpu(missed_beacon->num_recvd_beacons),\n\t\t\tle32_to_cpu(missed_beacon->num_expected_beacons));\n\t\tif (!test_bit(S_SCANNING, &il->status))\n\t\t\til4965_init_sensitivity(il);\n\t}\n}\n\n \nstatic void\nil4965_rx_calc_noise(struct il_priv *il)\n{\n\tstruct stats_rx_non_phy *rx_info;\n\tint num_active_rx = 0;\n\tint total_silence = 0;\n\tint bcn_silence_a, bcn_silence_b, bcn_silence_c;\n\tint last_rx_noise;\n\n\trx_info = &(il->_4965.stats.rx.general);\n\tbcn_silence_a =\n\t    le32_to_cpu(rx_info->beacon_silence_rssi_a) & IN_BAND_FILTER;\n\tbcn_silence_b =\n\t    le32_to_cpu(rx_info->beacon_silence_rssi_b) & IN_BAND_FILTER;\n\tbcn_silence_c =\n\t    le32_to_cpu(rx_info->beacon_silence_rssi_c) & IN_BAND_FILTER;\n\n\tif (bcn_silence_a) {\n\t\ttotal_silence += bcn_silence_a;\n\t\tnum_active_rx++;\n\t}\n\tif (bcn_silence_b) {\n\t\ttotal_silence += bcn_silence_b;\n\t\tnum_active_rx++;\n\t}\n\tif (bcn_silence_c) {\n\t\ttotal_silence += bcn_silence_c;\n\t\tnum_active_rx++;\n\t}\n\n\t \n\tif (num_active_rx)\n\t\tlast_rx_noise = (total_silence / num_active_rx) - 107;\n\telse\n\t\tlast_rx_noise = IL_NOISE_MEAS_NOT_AVAILABLE;\n\n\tD_CALIB(\"inband silence a %u, b %u, c %u, dBm %d\\n\", bcn_silence_a,\n\t\tbcn_silence_b, bcn_silence_c, last_rx_noise);\n}\n\n#ifdef CONFIG_IWLEGACY_DEBUGFS\n \nstatic void\nil4965_accumulative_stats(struct il_priv *il, __le32 * stats)\n{\n\tint i, size;\n\t__le32 *prev_stats;\n\tu32 *accum_stats;\n\tu32 *delta, *max_delta;\n\tstruct stats_general_common *general, *accum_general;\n\n\tprev_stats = (__le32 *) &il->_4965.stats;\n\taccum_stats = (u32 *) &il->_4965.accum_stats;\n\tsize = sizeof(struct il_notif_stats);\n\tgeneral = &il->_4965.stats.general.common;\n\taccum_general = &il->_4965.accum_stats.general.common;\n\tdelta = (u32 *) &il->_4965.delta_stats;\n\tmax_delta = (u32 *) &il->_4965.max_delta;\n\n\tfor (i = sizeof(__le32); i < size;\n\t     i +=\n\t     sizeof(__le32), stats++, prev_stats++, delta++, max_delta++,\n\t     accum_stats++) {\n\t\tif (le32_to_cpu(*stats) > le32_to_cpu(*prev_stats)) {\n\t\t\t*delta =\n\t\t\t    (le32_to_cpu(*stats) - le32_to_cpu(*prev_stats));\n\t\t\t*accum_stats += *delta;\n\t\t\tif (*delta > *max_delta)\n\t\t\t\t*max_delta = *delta;\n\t\t}\n\t}\n\n\t \n\taccum_general->temperature = general->temperature;\n\taccum_general->ttl_timestamp = general->ttl_timestamp;\n}\n#endif\n\nstatic void\nil4965_hdl_stats(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tconst int recalib_seconds = 60;\n\tbool change;\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\n\tD_RX(\"Statistics notification received (%d vs %d).\\n\",\n\t     (int)sizeof(struct il_notif_stats),\n\t     le32_to_cpu(pkt->len_n_flags) & IL_RX_FRAME_SIZE_MSK);\n\n\tchange =\n\t    ((il->_4965.stats.general.common.temperature !=\n\t      pkt->u.stats.general.common.temperature) ||\n\t     ((il->_4965.stats.flag & STATS_REPLY_FLG_HT40_MODE_MSK) !=\n\t      (pkt->u.stats.flag & STATS_REPLY_FLG_HT40_MODE_MSK)));\n#ifdef CONFIG_IWLEGACY_DEBUGFS\n\til4965_accumulative_stats(il, (__le32 *) &pkt->u.stats);\n#endif\n\n\t \n\tmemcpy(&il->_4965.stats, &pkt->u.stats, sizeof(il->_4965.stats));\n\n\tset_bit(S_STATS, &il->status);\n\n\t \n\tmod_timer(&il->stats_periodic,\n\t\t  jiffies + msecs_to_jiffies(recalib_seconds * 1000));\n\n\tif (unlikely(!test_bit(S_SCANNING, &il->status)) &&\n\t    (pkt->hdr.cmd == N_STATS)) {\n\t\til4965_rx_calc_noise(il);\n\t\tqueue_work(il->workqueue, &il->run_time_calib_work);\n\t}\n\n\tif (change)\n\t\til4965_temperature_calib(il);\n}\n\nstatic void\nil4965_hdl_c_stats(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\n\tif (le32_to_cpu(pkt->u.stats.flag) & UCODE_STATS_CLEAR_MSK) {\n#ifdef CONFIG_IWLEGACY_DEBUGFS\n\t\tmemset(&il->_4965.accum_stats, 0,\n\t\t       sizeof(struct il_notif_stats));\n\t\tmemset(&il->_4965.delta_stats, 0,\n\t\t       sizeof(struct il_notif_stats));\n\t\tmemset(&il->_4965.max_delta, 0, sizeof(struct il_notif_stats));\n#endif\n\t\tD_RX(\"Statistics have been cleared\\n\");\n\t}\n\til4965_hdl_stats(il, rxb);\n}\n\n\n \n\nstatic const u8 tid_to_ac[] = {\n\tIEEE80211_AC_BE,\n\tIEEE80211_AC_BK,\n\tIEEE80211_AC_BK,\n\tIEEE80211_AC_BE,\n\tIEEE80211_AC_VI,\n\tIEEE80211_AC_VI,\n\tIEEE80211_AC_VO,\n\tIEEE80211_AC_VO\n};\n\nstatic inline int\nil4965_get_ac_from_tid(u16 tid)\n{\n\tif (likely(tid < ARRAY_SIZE(tid_to_ac)))\n\t\treturn tid_to_ac[tid];\n\n\t \n\treturn -EINVAL;\n}\n\nstatic inline int\nil4965_get_fifo_from_tid(u16 tid)\n{\n\tstatic const u8 ac_to_fifo[] = {\n\t\tIL_TX_FIFO_VO,\n\t\tIL_TX_FIFO_VI,\n\t\tIL_TX_FIFO_BE,\n\t\tIL_TX_FIFO_BK,\n\t};\n\n\tif (likely(tid < ARRAY_SIZE(tid_to_ac)))\n\t\treturn ac_to_fifo[tid_to_ac[tid]];\n\n\t \n\treturn -EINVAL;\n}\n\n \nstatic void\nil4965_tx_cmd_build_basic(struct il_priv *il, struct sk_buff *skb,\n\t\t\t  struct il_tx_cmd *tx_cmd,\n\t\t\t  struct ieee80211_tx_info *info,\n\t\t\t  struct ieee80211_hdr *hdr, u8 std_id)\n{\n\t__le16 fc = hdr->frame_control;\n\t__le32 tx_flags = tx_cmd->tx_flags;\n\n\ttx_cmd->stop_time.life_time = TX_CMD_LIFE_TIME_INFINITE;\n\tif (!(info->flags & IEEE80211_TX_CTL_NO_ACK)) {\n\t\ttx_flags |= TX_CMD_FLG_ACK_MSK;\n\t\tif (ieee80211_is_mgmt(fc))\n\t\t\ttx_flags |= TX_CMD_FLG_SEQ_CTL_MSK;\n\t\tif (ieee80211_is_probe_resp(fc) &&\n\t\t    !(le16_to_cpu(hdr->seq_ctrl) & 0xf))\n\t\t\ttx_flags |= TX_CMD_FLG_TSF_MSK;\n\t} else {\n\t\ttx_flags &= (~TX_CMD_FLG_ACK_MSK);\n\t\ttx_flags |= TX_CMD_FLG_SEQ_CTL_MSK;\n\t}\n\n\tif (ieee80211_is_back_req(fc))\n\t\ttx_flags |= TX_CMD_FLG_ACK_MSK | TX_CMD_FLG_IMM_BA_RSP_MASK;\n\n\ttx_cmd->sta_id = std_id;\n\tif (ieee80211_has_morefrags(fc))\n\t\ttx_flags |= TX_CMD_FLG_MORE_FRAG_MSK;\n\n\tif (ieee80211_is_data_qos(fc)) {\n\t\tu8 *qc = ieee80211_get_qos_ctl(hdr);\n\t\ttx_cmd->tid_tspec = qc[0] & 0xf;\n\t\ttx_flags &= ~TX_CMD_FLG_SEQ_CTL_MSK;\n\t} else {\n\t\ttx_flags |= TX_CMD_FLG_SEQ_CTL_MSK;\n\t}\n\n\til_tx_cmd_protection(il, info, fc, &tx_flags);\n\n\ttx_flags &= ~(TX_CMD_FLG_ANT_SEL_MSK);\n\tif (ieee80211_is_mgmt(fc)) {\n\t\tif (ieee80211_is_assoc_req(fc) || ieee80211_is_reassoc_req(fc))\n\t\t\ttx_cmd->timeout.pm_frame_timeout = cpu_to_le16(3);\n\t\telse\n\t\t\ttx_cmd->timeout.pm_frame_timeout = cpu_to_le16(2);\n\t} else {\n\t\ttx_cmd->timeout.pm_frame_timeout = 0;\n\t}\n\n\ttx_cmd->driver_txop = 0;\n\ttx_cmd->tx_flags = tx_flags;\n\ttx_cmd->next_frame_len = 0;\n}\n\nstatic void\nil4965_tx_cmd_build_rate(struct il_priv *il,\n\t\t\t struct il_tx_cmd *tx_cmd,\n\t\t\t struct ieee80211_tx_info *info,\n\t\t\t struct ieee80211_sta *sta,\n\t\t\t __le16 fc)\n{\n\tconst u8 rts_retry_limit = 60;\n\tu32 rate_flags;\n\tint rate_idx;\n\tu8 data_retry_limit;\n\tu8 rate_plcp;\n\n\t \n\tif (ieee80211_is_probe_resp(fc))\n\t\tdata_retry_limit = 3;\n\telse\n\t\tdata_retry_limit = IL4965_DEFAULT_TX_RETRY;\n\ttx_cmd->data_retry_limit = data_retry_limit;\n\t \n\ttx_cmd->rts_retry_limit = min(data_retry_limit, rts_retry_limit);\n\n\t \n\tif (ieee80211_is_data(fc)) {\n\t\ttx_cmd->initial_rate_idx = 0;\n\t\ttx_cmd->tx_flags |= TX_CMD_FLG_STA_RATE_MSK;\n\t\treturn;\n\t}\n\n\t \n\trate_idx = info->control.rates[0].idx;\n\tif ((info->control.rates[0].flags & IEEE80211_TX_RC_MCS) || rate_idx < 0\n\t    || rate_idx > RATE_COUNT_LEGACY)\n\t\trate_idx = rate_lowest_index(&il->bands[info->band], sta);\n\t \n\tif (info->band == NL80211_BAND_5GHZ)\n\t\trate_idx += IL_FIRST_OFDM_RATE;\n\t \n\trate_plcp = il_rates[rate_idx].plcp;\n\t \n\trate_flags = 0;\n\n\t \n\tif (rate_idx >= IL_FIRST_CCK_RATE && rate_idx <= IL_LAST_CCK_RATE)\n\t\trate_flags |= RATE_MCS_CCK_MSK;\n\n\t \n\til4965_toggle_tx_ant(il, &il->mgmt_tx_ant, il->hw_params.valid_tx_ant);\n\trate_flags |= BIT(il->mgmt_tx_ant) << RATE_MCS_ANT_POS;\n\n\t \n\ttx_cmd->rate_n_flags = cpu_to_le32(rate_plcp | rate_flags);\n}\n\nstatic void\nil4965_tx_cmd_build_hwcrypto(struct il_priv *il, struct ieee80211_tx_info *info,\n\t\t\t     struct il_tx_cmd *tx_cmd, struct sk_buff *skb_frag,\n\t\t\t     int sta_id)\n{\n\tstruct ieee80211_key_conf *keyconf = info->control.hw_key;\n\n\tswitch (keyconf->cipher) {\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\ttx_cmd->sec_ctl = TX_CMD_SEC_CCM;\n\t\tmemcpy(tx_cmd->key, keyconf->key, keyconf->keylen);\n\t\tif (info->flags & IEEE80211_TX_CTL_AMPDU)\n\t\t\ttx_cmd->tx_flags |= TX_CMD_FLG_AGG_CCMP_MSK;\n\t\tD_TX(\"tx_cmd with AES hwcrypto\\n\");\n\t\tbreak;\n\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\ttx_cmd->sec_ctl = TX_CMD_SEC_TKIP;\n\t\tieee80211_get_tkip_p2k(keyconf, skb_frag, tx_cmd->key);\n\t\tD_TX(\"tx_cmd with tkip hwcrypto\\n\");\n\t\tbreak;\n\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\ttx_cmd->sec_ctl |= TX_CMD_SEC_KEY128;\n\t\tfallthrough;\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\ttx_cmd->sec_ctl |=\n\t\t    (TX_CMD_SEC_WEP | (keyconf->keyidx & TX_CMD_SEC_MSK) <<\n\t\t     TX_CMD_SEC_SHIFT);\n\n\t\tmemcpy(&tx_cmd->key[3], keyconf->key, keyconf->keylen);\n\n\t\tD_TX(\"Configuring packet for WEP encryption \" \"with key %d\\n\",\n\t\t     keyconf->keyidx);\n\t\tbreak;\n\n\tdefault:\n\t\tIL_ERR(\"Unknown encode cipher %x\\n\", keyconf->cipher);\n\t\tbreak;\n\t}\n}\n\n \nint\nil4965_tx_skb(struct il_priv *il,\n\t      struct ieee80211_sta *sta,\n\t      struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct il_station_priv *sta_priv = NULL;\n\tstruct il_tx_queue *txq;\n\tstruct il_queue *q;\n\tstruct il_device_cmd *out_cmd;\n\tstruct il_cmd_meta *out_meta;\n\tstruct il_tx_cmd *tx_cmd;\n\tint txq_id;\n\tdma_addr_t phys_addr;\n\tdma_addr_t txcmd_phys;\n\tdma_addr_t scratch_phys;\n\tu16 len, firstlen, secondlen;\n\tu16 seq_number = 0;\n\t__le16 fc;\n\tu8 hdr_len;\n\tu8 sta_id;\n\tu8 wait_write_ptr = 0;\n\tu8 tid = 0;\n\tu8 *qc = NULL;\n\tunsigned long flags;\n\tbool is_agg = false;\n\n\tspin_lock_irqsave(&il->lock, flags);\n\tif (il_is_rfkill(il)) {\n\t\tD_DROP(\"Dropping - RF KILL\\n\");\n\t\tgoto drop_unlock;\n\t}\n\n\tfc = hdr->frame_control;\n\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tif (ieee80211_is_auth(fc))\n\t\tD_TX(\"Sending AUTH frame\\n\");\n\telse if (ieee80211_is_assoc_req(fc))\n\t\tD_TX(\"Sending ASSOC frame\\n\");\n\telse if (ieee80211_is_reassoc_req(fc))\n\t\tD_TX(\"Sending REASSOC frame\\n\");\n#endif\n\n\thdr_len = ieee80211_hdrlen(fc);\n\n\t \n\tif (!ieee80211_is_data(fc))\n\t\tsta_id = il->hw_params.bcast_id;\n\telse {\n\t\t \n\t\tsta_id = il_sta_id_or_broadcast(il, sta);\n\n\t\tif (sta_id == IL_INVALID_STATION) {\n\t\t\tD_DROP(\"Dropping - INVALID STATION: %pM\\n\", hdr->addr1);\n\t\t\tgoto drop_unlock;\n\t\t}\n\t}\n\n\tD_TX(\"station Id %d\\n\", sta_id);\n\n\tif (sta)\n\t\tsta_priv = (void *)sta->drv_priv;\n\n\tif (sta_priv && sta_priv->asleep &&\n\t    (info->flags & IEEE80211_TX_CTL_NO_PS_BUFFER)) {\n\t\t \n\t\til4965_sta_modify_sleep_tx_count(il, sta_id, 1);\n\t}\n\n\t \n\tWARN_ON_ONCE(info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM);\n\n\t \n\ttxq_id = skb_get_queue_mapping(skb);\n\n\t \n\tspin_lock(&il->sta_lock);\n\n\tif (ieee80211_is_data_qos(fc)) {\n\t\tqc = ieee80211_get_qos_ctl(hdr);\n\t\ttid = qc[0] & IEEE80211_QOS_CTL_TID_MASK;\n\t\tif (WARN_ON_ONCE(tid >= MAX_TID_COUNT)) {\n\t\t\tspin_unlock(&il->sta_lock);\n\t\t\tgoto drop_unlock;\n\t\t}\n\t\tseq_number = il->stations[sta_id].tid[tid].seq_number;\n\t\tseq_number &= IEEE80211_SCTL_SEQ;\n\t\thdr->seq_ctrl =\n\t\t    hdr->seq_ctrl & cpu_to_le16(IEEE80211_SCTL_FRAG);\n\t\thdr->seq_ctrl |= cpu_to_le16(seq_number);\n\t\tseq_number += 0x10;\n\t\t \n\t\tif (info->flags & IEEE80211_TX_CTL_AMPDU &&\n\t\t    il->stations[sta_id].tid[tid].agg.state == IL_AGG_ON) {\n\t\t\ttxq_id = il->stations[sta_id].tid[tid].agg.txq_id;\n\t\t\tis_agg = true;\n\t\t}\n\t}\n\n\ttxq = &il->txq[txq_id];\n\tq = &txq->q;\n\n\tif (unlikely(il_queue_space(q) < q->high_mark)) {\n\t\tspin_unlock(&il->sta_lock);\n\t\tgoto drop_unlock;\n\t}\n\n\tif (ieee80211_is_data_qos(fc)) {\n\t\til->stations[sta_id].tid[tid].tfds_in_queue++;\n\t\tif (!ieee80211_has_morefrags(fc))\n\t\t\til->stations[sta_id].tid[tid].seq_number = seq_number;\n\t}\n\n\tspin_unlock(&il->sta_lock);\n\n\ttxq->skbs[q->write_ptr] = skb;\n\n\t \n\tout_cmd = txq->cmd[q->write_ptr];\n\tout_meta = &txq->meta[q->write_ptr];\n\ttx_cmd = &out_cmd->cmd.tx;\n\tmemset(&out_cmd->hdr, 0, sizeof(out_cmd->hdr));\n\tmemset(tx_cmd, 0, sizeof(struct il_tx_cmd));\n\n\t \n\tout_cmd->hdr.cmd = C_TX;\n\tout_cmd->hdr.sequence =\n\t    cpu_to_le16((u16)\n\t\t\t(QUEUE_TO_SEQ(txq_id) | IDX_TO_SEQ(q->write_ptr)));\n\n\t \n\tmemcpy(tx_cmd->hdr, hdr, hdr_len);\n\n\t \n\ttx_cmd->len = cpu_to_le16((u16) skb->len);\n\n\tif (info->control.hw_key)\n\t\til4965_tx_cmd_build_hwcrypto(il, info, tx_cmd, skb, sta_id);\n\n\t \n\til4965_tx_cmd_build_basic(il, skb, tx_cmd, info, hdr, sta_id);\n\n\til4965_tx_cmd_build_rate(il, tx_cmd, info, sta, fc);\n\n\t \n\tlen = sizeof(struct il_tx_cmd) + sizeof(struct il_cmd_header) + hdr_len;\n\tfirstlen = (len + 3) & ~3;\n\n\t \n\tif (firstlen != len)\n\t\ttx_cmd->tx_flags |= TX_CMD_FLG_MH_PAD_MSK;\n\n\t \n\ttxcmd_phys = dma_map_single(&il->pci_dev->dev, &out_cmd->hdr, firstlen,\n\t\t\t\t    DMA_BIDIRECTIONAL);\n\tif (unlikely(dma_mapping_error(&il->pci_dev->dev, txcmd_phys)))\n\t\tgoto drop_unlock;\n\n\t \n\tsecondlen = skb->len - hdr_len;\n\tif (secondlen > 0) {\n\t\tphys_addr = dma_map_single(&il->pci_dev->dev, skb->data + hdr_len,\n\t\t\t\t\t   secondlen, DMA_TO_DEVICE);\n\t\tif (unlikely(dma_mapping_error(&il->pci_dev->dev, phys_addr)))\n\t\t\tgoto drop_unlock;\n\t}\n\n\t \n\til->ops->txq_attach_buf_to_tfd(il, txq, txcmd_phys, firstlen, 1, 0);\n\tdma_unmap_addr_set(out_meta, mapping, txcmd_phys);\n\tdma_unmap_len_set(out_meta, len, firstlen);\n\tif (secondlen)\n\t\til->ops->txq_attach_buf_to_tfd(il, txq, phys_addr, secondlen,\n\t\t\t\t\t       0, 0);\n\n\tif (!ieee80211_has_morefrags(hdr->frame_control)) {\n\t\ttxq->need_update = 1;\n\t} else {\n\t\twait_write_ptr = 1;\n\t\ttxq->need_update = 0;\n\t}\n\n\tscratch_phys =\n\t    txcmd_phys + sizeof(struct il_cmd_header) +\n\t    offsetof(struct il_tx_cmd, scratch);\n\n\t \n\tdma_sync_single_for_cpu(&il->pci_dev->dev, txcmd_phys, firstlen,\n\t\t\t\tDMA_BIDIRECTIONAL);\n\ttx_cmd->dram_lsb_ptr = cpu_to_le32(scratch_phys);\n\ttx_cmd->dram_msb_ptr = il_get_dma_hi_addr(scratch_phys);\n\n\til_update_stats(il, true, fc, skb->len);\n\n\tD_TX(\"sequence nr = 0X%x\\n\", le16_to_cpu(out_cmd->hdr.sequence));\n\tD_TX(\"tx_flags = 0X%x\\n\", le32_to_cpu(tx_cmd->tx_flags));\n\til_print_hex_dump(il, IL_DL_TX, (u8 *) tx_cmd, sizeof(*tx_cmd));\n\til_print_hex_dump(il, IL_DL_TX, (u8 *) tx_cmd->hdr, hdr_len);\n\n\t \n\tif (info->flags & IEEE80211_TX_CTL_AMPDU)\n\t\til->ops->txq_update_byte_cnt_tbl(il, txq, le16_to_cpu(tx_cmd->len));\n\n\tdma_sync_single_for_device(&il->pci_dev->dev, txcmd_phys, firstlen,\n\t\t\t\t   DMA_BIDIRECTIONAL);\n\n\t \n\tq->write_ptr = il_queue_inc_wrap(q->write_ptr, q->n_bd);\n\til_txq_update_write_ptr(il, txq);\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\t \n\n\t \n\tif (sta_priv && sta_priv->client && !is_agg)\n\t\tatomic_inc(&sta_priv->pending_frames);\n\n\tif (il_queue_space(q) < q->high_mark && il->mac80211_registered) {\n\t\tif (wait_write_ptr) {\n\t\t\tspin_lock_irqsave(&il->lock, flags);\n\t\t\ttxq->need_update = 1;\n\t\t\til_txq_update_write_ptr(il, txq);\n\t\t\tspin_unlock_irqrestore(&il->lock, flags);\n\t\t} else {\n\t\t\til_stop_queue(il, txq);\n\t\t}\n\t}\n\n\treturn 0;\n\ndrop_unlock:\n\tspin_unlock_irqrestore(&il->lock, flags);\n\treturn -1;\n}\n\nstatic inline int\nil4965_alloc_dma_ptr(struct il_priv *il, struct il_dma_ptr *ptr, size_t size)\n{\n\tptr->addr = dma_alloc_coherent(&il->pci_dev->dev, size, &ptr->dma,\n\t\t\t\t       GFP_KERNEL);\n\tif (!ptr->addr)\n\t\treturn -ENOMEM;\n\tptr->size = size;\n\treturn 0;\n}\n\nstatic inline void\nil4965_free_dma_ptr(struct il_priv *il, struct il_dma_ptr *ptr)\n{\n\tif (unlikely(!ptr->addr))\n\t\treturn;\n\n\tdma_free_coherent(&il->pci_dev->dev, ptr->size, ptr->addr, ptr->dma);\n\tmemset(ptr, 0, sizeof(*ptr));\n}\n\n \nvoid\nil4965_hw_txq_ctx_free(struct il_priv *il)\n{\n\tint txq_id;\n\n\t \n\tif (il->txq) {\n\t\tfor (txq_id = 0; txq_id < il->hw_params.max_txq_num; txq_id++)\n\t\t\tif (txq_id == il->cmd_queue)\n\t\t\t\til_cmd_queue_free(il);\n\t\t\telse\n\t\t\t\til_tx_queue_free(il, txq_id);\n\t}\n\til4965_free_dma_ptr(il, &il->kw);\n\n\til4965_free_dma_ptr(il, &il->scd_bc_tbls);\n\n\t \n\til_free_txq_mem(il);\n}\n\n \nint\nil4965_txq_ctx_alloc(struct il_priv *il)\n{\n\tint ret, txq_id;\n\tunsigned long flags;\n\n\t \n\til4965_hw_txq_ctx_free(il);\n\n\tret =\n\t    il4965_alloc_dma_ptr(il, &il->scd_bc_tbls,\n\t\t\t\t il->hw_params.scd_bc_tbls_size);\n\tif (ret) {\n\t\tIL_ERR(\"Scheduler BC Table allocation failed\\n\");\n\t\tgoto error_bc_tbls;\n\t}\n\t \n\tret = il4965_alloc_dma_ptr(il, &il->kw, IL_KW_SIZE);\n\tif (ret) {\n\t\tIL_ERR(\"Keep Warm allocation failed\\n\");\n\t\tgoto error_kw;\n\t}\n\n\t \n\tret = il_alloc_txq_mem(il);\n\tif (ret)\n\t\tgoto error;\n\n\tspin_lock_irqsave(&il->lock, flags);\n\n\t \n\til4965_txq_set_sched(il, 0);\n\n\t \n\til_wr(il, FH49_KW_MEM_ADDR_REG, il->kw.dma >> 4);\n\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\t \n\tfor (txq_id = 0; txq_id < il->hw_params.max_txq_num; txq_id++) {\n\t\tret = il_tx_queue_init(il, txq_id);\n\t\tif (ret) {\n\t\t\tIL_ERR(\"Tx %d queue init failed\\n\", txq_id);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn ret;\n\nerror:\n\til4965_hw_txq_ctx_free(il);\n\til4965_free_dma_ptr(il, &il->kw);\nerror_kw:\n\til4965_free_dma_ptr(il, &il->scd_bc_tbls);\nerror_bc_tbls:\n\treturn ret;\n}\n\nvoid\nil4965_txq_ctx_reset(struct il_priv *il)\n{\n\tint txq_id;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&il->lock, flags);\n\n\t \n\til4965_txq_set_sched(il, 0);\n\t \n\til_wr(il, FH49_KW_MEM_ADDR_REG, il->kw.dma >> 4);\n\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\t \n\tfor (txq_id = 0; txq_id < il->hw_params.max_txq_num; txq_id++)\n\t\til_tx_queue_reset(il, txq_id);\n}\n\nstatic void\nil4965_txq_ctx_unmap(struct il_priv *il)\n{\n\tint txq_id;\n\n\tif (!il->txq)\n\t\treturn;\n\n\t \n\tfor (txq_id = 0; txq_id < il->hw_params.max_txq_num; txq_id++)\n\t\tif (txq_id == il->cmd_queue)\n\t\t\til_cmd_queue_unmap(il);\n\t\telse\n\t\t\til_tx_queue_unmap(il, txq_id);\n}\n\n \nvoid\nil4965_txq_ctx_stop(struct il_priv *il)\n{\n\tint ch, ret;\n\n\t_il_wr_prph(il, IL49_SCD_TXFACT, 0);\n\n\t \n\tfor (ch = 0; ch < il->hw_params.dma_chnl_num; ch++) {\n\t\t_il_wr(il, FH49_TCSR_CHNL_TX_CONFIG_REG(ch), 0x0);\n\t\tret =\n\t\t    _il_poll_bit(il, FH49_TSSR_TX_STATUS_REG,\n\t\t\t\t FH49_TSSR_TX_STATUS_REG_MSK_CHNL_IDLE(ch),\n\t\t\t\t FH49_TSSR_TX_STATUS_REG_MSK_CHNL_IDLE(ch),\n\t\t\t\t 1000);\n\t\tif (ret < 0)\n\t\t\tIL_ERR(\"Timeout stopping DMA channel %d [0x%08x]\",\n\t\t\t       ch, _il_rd(il, FH49_TSSR_TX_STATUS_REG));\n\t}\n}\n\n \nstatic int\nil4965_txq_ctx_activate_free(struct il_priv *il)\n{\n\tint txq_id;\n\n\tfor (txq_id = 0; txq_id < il->hw_params.max_txq_num; txq_id++)\n\t\tif (!test_and_set_bit(txq_id, &il->txq_ctx_active_msk))\n\t\t\treturn txq_id;\n\treturn -1;\n}\n\n \nstatic void\nil4965_tx_queue_stop_scheduler(struct il_priv *il, u16 txq_id)\n{\n\t \n\til_wr_prph(il, IL49_SCD_QUEUE_STATUS_BITS(txq_id),\n\t\t   (0 << IL49_SCD_QUEUE_STTS_REG_POS_ACTIVE) |\n\t\t   (1 << IL49_SCD_QUEUE_STTS_REG_POS_SCD_ACT_EN));\n}\n\n \nstatic int\nil4965_tx_queue_set_q2ratid(struct il_priv *il, u16 ra_tid, u16 txq_id)\n{\n\tu32 tbl_dw_addr;\n\tu32 tbl_dw;\n\tu16 scd_q2ratid;\n\n\tscd_q2ratid = ra_tid & IL_SCD_QUEUE_RA_TID_MAP_RATID_MSK;\n\n\ttbl_dw_addr =\n\t    il->scd_base_addr + IL49_SCD_TRANSLATE_TBL_OFFSET_QUEUE(txq_id);\n\n\ttbl_dw = il_read_targ_mem(il, tbl_dw_addr);\n\n\tif (txq_id & 0x1)\n\t\ttbl_dw = (scd_q2ratid << 16) | (tbl_dw & 0x0000FFFF);\n\telse\n\t\ttbl_dw = scd_q2ratid | (tbl_dw & 0xFFFF0000);\n\n\til_write_targ_mem(il, tbl_dw_addr, tbl_dw);\n\n\treturn 0;\n}\n\n \nstatic int\nil4965_txq_agg_enable(struct il_priv *il, int txq_id, int tx_fifo, int sta_id,\n\t\t      int tid, u16 ssn_idx)\n{\n\tunsigned long flags;\n\tu16 ra_tid;\n\tint ret;\n\n\tif ((IL49_FIRST_AMPDU_QUEUE > txq_id) ||\n\t    (IL49_FIRST_AMPDU_QUEUE +\n\t     il->cfg->num_of_ampdu_queues <= txq_id)) {\n\t\tIL_WARN(\"queue number out of range: %d, must be %d to %d\\n\",\n\t\t\ttxq_id, IL49_FIRST_AMPDU_QUEUE,\n\t\t\tIL49_FIRST_AMPDU_QUEUE +\n\t\t\til->cfg->num_of_ampdu_queues - 1);\n\t\treturn -EINVAL;\n\t}\n\n\tra_tid = BUILD_RAxTID(sta_id, tid);\n\n\t \n\tret = il4965_sta_tx_modify_enable_tid(il, sta_id, tid);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&il->lock, flags);\n\n\t \n\til4965_tx_queue_stop_scheduler(il, txq_id);\n\n\t \n\til4965_tx_queue_set_q2ratid(il, ra_tid, txq_id);\n\n\t \n\til_set_bits_prph(il, IL49_SCD_QUEUECHAIN_SEL, (1 << txq_id));\n\n\t \n\til->txq[txq_id].q.read_ptr = (ssn_idx & 0xff);\n\til->txq[txq_id].q.write_ptr = (ssn_idx & 0xff);\n\til4965_set_wr_ptrs(il, txq_id, ssn_idx);\n\n\t \n\til_write_targ_mem(il,\n\t\t\t  il->scd_base_addr +\n\t\t\t  IL49_SCD_CONTEXT_QUEUE_OFFSET(txq_id),\n\t\t\t  (SCD_WIN_SIZE << IL49_SCD_QUEUE_CTX_REG1_WIN_SIZE_POS)\n\t\t\t  & IL49_SCD_QUEUE_CTX_REG1_WIN_SIZE_MSK);\n\n\til_write_targ_mem(il,\n\t\t\t  il->scd_base_addr +\n\t\t\t  IL49_SCD_CONTEXT_QUEUE_OFFSET(txq_id) + sizeof(u32),\n\t\t\t  (SCD_FRAME_LIMIT <<\n\t\t\t   IL49_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_POS) &\n\t\t\t  IL49_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_MSK);\n\n\til_set_bits_prph(il, IL49_SCD_INTERRUPT_MASK, (1 << txq_id));\n\n\t \n\til4965_tx_queue_set_status(il, &il->txq[txq_id], tx_fifo, 1);\n\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\treturn 0;\n}\n\nint\nil4965_tx_agg_start(struct il_priv *il, struct ieee80211_vif *vif,\n\t\t    struct ieee80211_sta *sta, u16 tid, u16 * ssn)\n{\n\tint sta_id;\n\tint tx_fifo;\n\tint txq_id;\n\tint ret;\n\tunsigned long flags;\n\tstruct il_tid_data *tid_data;\n\n\t \n\ttx_fifo = il4965_get_fifo_from_tid(tid);\n\tif (unlikely(tx_fifo < 0))\n\t\treturn tx_fifo;\n\n\tD_HT(\"%s on ra = %pM tid = %d\\n\", __func__, sta->addr, tid);\n\n\tsta_id = il_sta_id(sta);\n\tif (sta_id == IL_INVALID_STATION) {\n\t\tIL_ERR(\"Start AGG on invalid station\\n\");\n\t\treturn -ENXIO;\n\t}\n\tif (unlikely(tid >= MAX_TID_COUNT))\n\t\treturn -EINVAL;\n\n\tif (il->stations[sta_id].tid[tid].agg.state != IL_AGG_OFF) {\n\t\tIL_ERR(\"Start AGG when state is not IL_AGG_OFF !\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\ttxq_id = il4965_txq_ctx_activate_free(il);\n\tif (txq_id == -1) {\n\t\tIL_ERR(\"No free aggregation queue available\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\ttid_data = &il->stations[sta_id].tid[tid];\n\t*ssn = IEEE80211_SEQ_TO_SN(tid_data->seq_number);\n\ttid_data->agg.txq_id = txq_id;\n\til_set_swq_id(&il->txq[txq_id], il4965_get_ac_from_tid(tid), txq_id);\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\tret = il4965_txq_agg_enable(il, txq_id, tx_fifo, sta_id, tid, *ssn);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\ttid_data = &il->stations[sta_id].tid[tid];\n\tif (tid_data->tfds_in_queue == 0) {\n\t\tD_HT(\"HW queue is empty\\n\");\n\t\ttid_data->agg.state = IL_AGG_ON;\n\t\tret = IEEE80211_AMPDU_TX_START_IMMEDIATE;\n\t} else {\n\t\tD_HT(\"HW queue is NOT empty: %d packets in HW queue\\n\",\n\t\t     tid_data->tfds_in_queue);\n\t\ttid_data->agg.state = IL_EMPTYING_HW_QUEUE_ADDBA;\n\t}\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\treturn ret;\n}\n\n \nstatic int\nil4965_txq_agg_disable(struct il_priv *il, u16 txq_id, u16 ssn_idx, u8 tx_fifo)\n{\n\tif ((IL49_FIRST_AMPDU_QUEUE > txq_id) ||\n\t    (IL49_FIRST_AMPDU_QUEUE +\n\t     il->cfg->num_of_ampdu_queues <= txq_id)) {\n\t\tIL_WARN(\"queue number out of range: %d, must be %d to %d\\n\",\n\t\t\ttxq_id, IL49_FIRST_AMPDU_QUEUE,\n\t\t\tIL49_FIRST_AMPDU_QUEUE +\n\t\t\til->cfg->num_of_ampdu_queues - 1);\n\t\treturn -EINVAL;\n\t}\n\n\til4965_tx_queue_stop_scheduler(il, txq_id);\n\n\til_clear_bits_prph(il, IL49_SCD_QUEUECHAIN_SEL, (1 << txq_id));\n\n\til->txq[txq_id].q.read_ptr = (ssn_idx & 0xff);\n\til->txq[txq_id].q.write_ptr = (ssn_idx & 0xff);\n\t \n\til4965_set_wr_ptrs(il, txq_id, ssn_idx);\n\n\til_clear_bits_prph(il, IL49_SCD_INTERRUPT_MASK, (1 << txq_id));\n\til_txq_ctx_deactivate(il, txq_id);\n\til4965_tx_queue_set_status(il, &il->txq[txq_id], tx_fifo, 0);\n\n\treturn 0;\n}\n\nint\nil4965_tx_agg_stop(struct il_priv *il, struct ieee80211_vif *vif,\n\t\t   struct ieee80211_sta *sta, u16 tid)\n{\n\tint tx_fifo_id, txq_id, sta_id, ssn;\n\tstruct il_tid_data *tid_data;\n\tint write_ptr, read_ptr;\n\tunsigned long flags;\n\n\t \n\ttx_fifo_id = il4965_get_fifo_from_tid(tid);\n\tif (unlikely(tx_fifo_id < 0))\n\t\treturn tx_fifo_id;\n\n\tsta_id = il_sta_id(sta);\n\n\tif (sta_id == IL_INVALID_STATION) {\n\t\tIL_ERR(\"Invalid station for AGG tid %d\\n\", tid);\n\t\treturn -ENXIO;\n\t}\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\n\ttid_data = &il->stations[sta_id].tid[tid];\n\tssn = (tid_data->seq_number & IEEE80211_SCTL_SEQ) >> 4;\n\ttxq_id = tid_data->agg.txq_id;\n\n\tswitch (il->stations[sta_id].tid[tid].agg.state) {\n\tcase IL_EMPTYING_HW_QUEUE_ADDBA:\n\t\t \n\t\tD_HT(\"AGG stop before setup done\\n\");\n\t\tgoto turn_off;\n\tcase IL_AGG_ON:\n\t\tbreak;\n\tdefault:\n\t\tIL_WARN(\"Stopping AGG while state not ON or starting\\n\");\n\t}\n\n\twrite_ptr = il->txq[txq_id].q.write_ptr;\n\tread_ptr = il->txq[txq_id].q.read_ptr;\n\n\t \n\tif (write_ptr != read_ptr) {\n\t\tD_HT(\"Stopping a non empty AGG HW QUEUE\\n\");\n\t\til->stations[sta_id].tid[tid].agg.state =\n\t\t    IL_EMPTYING_HW_QUEUE_DELBA;\n\t\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\t\treturn 0;\n\t}\n\n\tD_HT(\"HW queue is empty\\n\");\nturn_off:\n\til->stations[sta_id].tid[tid].agg.state = IL_AGG_OFF;\n\n\t \n\tspin_unlock(&il->sta_lock);\n\tspin_lock(&il->lock);\n\n\t \n\til4965_txq_agg_disable(il, txq_id, ssn, tx_fifo_id);\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\tieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\n\treturn 0;\n}\n\nint\nil4965_txq_check_empty(struct il_priv *il, int sta_id, u8 tid, int txq_id)\n{\n\tstruct il_queue *q = &il->txq[txq_id].q;\n\tu8 *addr = il->stations[sta_id].sta.sta.addr;\n\tstruct il_tid_data *tid_data = &il->stations[sta_id].tid[tid];\n\n\tlockdep_assert_held(&il->sta_lock);\n\n\tswitch (il->stations[sta_id].tid[tid].agg.state) {\n\tcase IL_EMPTYING_HW_QUEUE_DELBA:\n\t\t \n\t\t \n\t\tif (txq_id == tid_data->agg.txq_id &&\n\t\t    q->read_ptr == q->write_ptr) {\n\t\t\tu16 ssn = IEEE80211_SEQ_TO_SN(tid_data->seq_number);\n\t\t\tint tx_fifo = il4965_get_fifo_from_tid(tid);\n\t\t\tD_HT(\"HW queue empty: continue DELBA flow\\n\");\n\t\t\til4965_txq_agg_disable(il, txq_id, ssn, tx_fifo);\n\t\t\ttid_data->agg.state = IL_AGG_OFF;\n\t\t\tieee80211_stop_tx_ba_cb_irqsafe(il->vif, addr, tid);\n\t\t}\n\t\tbreak;\n\tcase IL_EMPTYING_HW_QUEUE_ADDBA:\n\t\t \n\t\tif (tid_data->tfds_in_queue == 0) {\n\t\t\tD_HT(\"HW queue empty: continue ADDBA flow\\n\");\n\t\t\ttid_data->agg.state = IL_AGG_ON;\n\t\t\tieee80211_start_tx_ba_cb_irqsafe(il->vif, addr, tid);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nil4965_non_agg_tx_status(struct il_priv *il, const u8 *addr1)\n{\n\tstruct ieee80211_sta *sta;\n\tstruct il_station_priv *sta_priv;\n\n\trcu_read_lock();\n\tsta = ieee80211_find_sta(il->vif, addr1);\n\tif (sta) {\n\t\tsta_priv = (void *)sta->drv_priv;\n\t\t \n\t\tif (sta_priv->client &&\n\t\t    atomic_dec_return(&sta_priv->pending_frames) == 0)\n\t\t\tieee80211_sta_block_awake(il->hw, sta, false);\n\t}\n\trcu_read_unlock();\n}\n\nstatic void\nil4965_tx_status(struct il_priv *il, struct sk_buff *skb, bool is_agg)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\n\tif (!is_agg)\n\t\til4965_non_agg_tx_status(il, hdr->addr1);\n\n\tieee80211_tx_status_irqsafe(il->hw, skb);\n}\n\nint\nil4965_tx_queue_reclaim(struct il_priv *il, int txq_id, int idx)\n{\n\tstruct il_tx_queue *txq = &il->txq[txq_id];\n\tstruct il_queue *q = &txq->q;\n\tint nfreed = 0;\n\tstruct ieee80211_hdr *hdr;\n\tstruct sk_buff *skb;\n\n\tif (idx >= q->n_bd || il_queue_used(q, idx) == 0) {\n\t\tIL_ERR(\"Read idx for DMA queue txq id (%d), idx %d, \"\n\t\t       \"is out of range [0-%d] %d %d.\\n\", txq_id, idx, q->n_bd,\n\t\t       q->write_ptr, q->read_ptr);\n\t\treturn 0;\n\t}\n\n\tfor (idx = il_queue_inc_wrap(idx, q->n_bd); q->read_ptr != idx;\n\t     q->read_ptr = il_queue_inc_wrap(q->read_ptr, q->n_bd)) {\n\n\t\tskb = txq->skbs[txq->q.read_ptr];\n\n\t\tif (WARN_ON_ONCE(skb == NULL))\n\t\t\tcontinue;\n\n\t\thdr = (struct ieee80211_hdr *) skb->data;\n\t\tif (ieee80211_is_data_qos(hdr->frame_control))\n\t\t\tnfreed++;\n\n\t\til4965_tx_status(il, skb, txq_id >= IL4965_FIRST_AMPDU_QUEUE);\n\n\t\ttxq->skbs[txq->q.read_ptr] = NULL;\n\t\til->ops->txq_free_tfd(il, txq);\n\t}\n\treturn nfreed;\n}\n\n \nstatic int\nil4965_tx_status_reply_compressed_ba(struct il_priv *il, struct il_ht_agg *agg,\n\t\t\t\t     struct il_compressed_ba_resp *ba_resp)\n{\n\tint i, sh, ack;\n\tu16 seq_ctl = le16_to_cpu(ba_resp->seq_ctl);\n\tu16 scd_flow = le16_to_cpu(ba_resp->scd_flow);\n\tint successes = 0;\n\tstruct ieee80211_tx_info *info;\n\tu64 bitmap, sent_bitmap;\n\n\tif (unlikely(!agg->wait_for_ba)) {\n\t\tif (unlikely(ba_resp->bitmap))\n\t\t\tIL_ERR(\"Received BA when not expected\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tagg->wait_for_ba = 0;\n\tD_TX_REPLY(\"BA %d %d\\n\", agg->start_idx, ba_resp->seq_ctl);\n\n\t \n\tsh = agg->start_idx - SEQ_TO_IDX(seq_ctl >> 4);\n\tif (sh < 0)\t\t \n\t\tsh += 0x100;\n\n\tif (agg->frame_count > (64 - sh)) {\n\t\tD_TX_REPLY(\"more frames than bitmap size\");\n\t\treturn -1;\n\t}\n\n\t \n\tbitmap = le64_to_cpu(ba_resp->bitmap) >> sh;\n\n\t \n\tsent_bitmap = bitmap & agg->bitmap;\n\n\t \n\ti = 0;\n\twhile (sent_bitmap) {\n\t\tack = sent_bitmap & 1ULL;\n\t\tsuccesses += ack;\n\t\tD_TX_REPLY(\"%s ON i=%d idx=%d raw=%d\\n\", ack ? \"ACK\" : \"NACK\",\n\t\t\t   i, (agg->start_idx + i) & 0xff, agg->start_idx + i);\n\t\tsent_bitmap >>= 1;\n\t\t++i;\n\t}\n\n\tD_TX_REPLY(\"Bitmap %llx\\n\", (unsigned long long)bitmap);\n\n\tinfo = IEEE80211_SKB_CB(il->txq[scd_flow].skbs[agg->start_idx]);\n\tmemset(&info->status, 0, sizeof(info->status));\n\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\tinfo->flags |= IEEE80211_TX_STAT_AMPDU;\n\tinfo->status.ampdu_ack_len = successes;\n\tinfo->status.ampdu_len = agg->frame_count;\n\til4965_hwrate_to_tx_control(il, agg->rate_n_flags, info);\n\n\treturn 0;\n}\n\nstatic inline bool\nil4965_is_tx_success(u32 status)\n{\n\tstatus &= TX_STATUS_MSK;\n\treturn (status == TX_STATUS_SUCCESS || status == TX_STATUS_DIRECT_DONE);\n}\n\nstatic u8\nil4965_find_station(struct il_priv *il, const u8 *addr)\n{\n\tint i;\n\tint start = 0;\n\tint ret = IL_INVALID_STATION;\n\tunsigned long flags;\n\n\tif (il->iw_mode == NL80211_IFTYPE_ADHOC)\n\t\tstart = IL_STA_ID;\n\n\tif (is_broadcast_ether_addr(addr))\n\t\treturn il->hw_params.bcast_id;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\tfor (i = start; i < il->hw_params.max_stations; i++)\n\t\tif (il->stations[i].used &&\n\t\t    ether_addr_equal(il->stations[i].sta.sta.addr, addr)) {\n\t\t\tret = i;\n\t\t\tgoto out;\n\t\t}\n\n\tD_ASSOC(\"can not find STA %pM total %d\\n\", addr, il->num_stations);\n\nout:\n\t \n\tif (ret != IL_INVALID_STATION &&\n\t    (!(il->stations[ret].used & IL_STA_UCODE_ACTIVE) ||\n\t      (il->stations[ret].used & IL_STA_UCODE_INPROGRESS))) {\n\t\tIL_ERR(\"Requested station info for sta %d before ready.\\n\",\n\t\t       ret);\n\t\tret = IL_INVALID_STATION;\n\t}\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\treturn ret;\n}\n\nstatic int\nil4965_get_ra_sta_id(struct il_priv *il, struct ieee80211_hdr *hdr)\n{\n\tif (il->iw_mode == NL80211_IFTYPE_STATION)\n\t\treturn IL_AP_ID;\n\telse {\n\t\tu8 *da = ieee80211_get_DA(hdr);\n\n\t\treturn il4965_find_station(il, da);\n\t}\n}\n\nstatic inline u32\nil4965_get_scd_ssn(struct il4965_tx_resp *tx_resp)\n{\n\treturn le32_to_cpup(&tx_resp->u.status +\n\t\t\t    tx_resp->frame_count) & IEEE80211_MAX_SN;\n}\n\nstatic inline u32\nil4965_tx_status_to_mac80211(u32 status)\n{\n\tstatus &= TX_STATUS_MSK;\n\n\tswitch (status) {\n\tcase TX_STATUS_SUCCESS:\n\tcase TX_STATUS_DIRECT_DONE:\n\t\treturn IEEE80211_TX_STAT_ACK;\n\tcase TX_STATUS_FAIL_DEST_PS:\n\t\treturn IEEE80211_TX_STAT_TX_FILTERED;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic int\nil4965_tx_status_reply_tx(struct il_priv *il, struct il_ht_agg *agg,\n\t\t\t  struct il4965_tx_resp *tx_resp, int txq_id,\n\t\t\t  u16 start_idx)\n{\n\tu16 status;\n\tstruct agg_tx_status *frame_status = tx_resp->u.agg_status;\n\tstruct ieee80211_tx_info *info = NULL;\n\tstruct ieee80211_hdr *hdr = NULL;\n\tu32 rate_n_flags = le32_to_cpu(tx_resp->rate_n_flags);\n\tint i, sh, idx;\n\tu16 seq;\n\tif (agg->wait_for_ba)\n\t\tD_TX_REPLY(\"got tx response w/o block-ack\\n\");\n\n\tagg->frame_count = tx_resp->frame_count;\n\tagg->start_idx = start_idx;\n\tagg->rate_n_flags = rate_n_flags;\n\tagg->bitmap = 0;\n\n\t \n\tif (agg->frame_count == 1) {\n\t\t \n\t\tstatus = le16_to_cpu(frame_status[0].status);\n\t\tidx = start_idx;\n\n\t\tD_TX_REPLY(\"FrameCnt = %d, StartIdx=%d idx=%d\\n\",\n\t\t\t   agg->frame_count, agg->start_idx, idx);\n\n\t\tinfo = IEEE80211_SKB_CB(il->txq[txq_id].skbs[idx]);\n\t\tinfo->status.rates[0].count = tx_resp->failure_frame + 1;\n\t\tinfo->flags &= ~IEEE80211_TX_CTL_AMPDU;\n\t\tinfo->flags |= il4965_tx_status_to_mac80211(status);\n\t\til4965_hwrate_to_tx_control(il, rate_n_flags, info);\n\n\t\tD_TX_REPLY(\"1 Frame 0x%x failure :%d\\n\", status & 0xff,\n\t\t\t   tx_resp->failure_frame);\n\t\tD_TX_REPLY(\"Rate Info rate_n_flags=%x\\n\", rate_n_flags);\n\n\t\tagg->wait_for_ba = 0;\n\t} else {\n\t\t \n\t\tu64 bitmap = 0;\n\t\tint start = agg->start_idx;\n\t\tstruct sk_buff *skb;\n\n\t\t \n\t\tfor (i = 0; i < agg->frame_count; i++) {\n\t\t\tu16 sc;\n\t\t\tstatus = le16_to_cpu(frame_status[i].status);\n\t\t\tseq = le16_to_cpu(frame_status[i].sequence);\n\t\t\tidx = SEQ_TO_IDX(seq);\n\t\t\ttxq_id = SEQ_TO_QUEUE(seq);\n\n\t\t\tif (status &\n\t\t\t    (AGG_TX_STATE_FEW_BYTES_MSK |\n\t\t\t     AGG_TX_STATE_ABORT_MSK))\n\t\t\t\tcontinue;\n\n\t\t\tD_TX_REPLY(\"FrameCnt = %d, txq_id=%d idx=%d\\n\",\n\t\t\t\t   agg->frame_count, txq_id, idx);\n\n\t\t\tskb = il->txq[txq_id].skbs[idx];\n\t\t\tif (WARN_ON_ONCE(skb == NULL))\n\t\t\t\treturn -1;\n\t\t\thdr = (struct ieee80211_hdr *) skb->data;\n\n\t\t\tsc = le16_to_cpu(hdr->seq_ctrl);\n\t\t\tif (idx != (IEEE80211_SEQ_TO_SN(sc) & 0xff)) {\n\t\t\t\tIL_ERR(\"BUG_ON idx doesn't match seq control\"\n\t\t\t\t       \" idx=%d, seq_idx=%d, seq=%d\\n\", idx,\n\t\t\t\t       IEEE80211_SEQ_TO_SN(sc), hdr->seq_ctrl);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tD_TX_REPLY(\"AGG Frame i=%d idx %d seq=%d\\n\", i, idx,\n\t\t\t\t   IEEE80211_SEQ_TO_SN(sc));\n\n\t\t\tsh = idx - start;\n\t\t\tif (sh > 64) {\n\t\t\t\tsh = (start - idx) + 0xff;\n\t\t\t\tbitmap = bitmap << sh;\n\t\t\t\tsh = 0;\n\t\t\t\tstart = idx;\n\t\t\t} else if (sh < -64)\n\t\t\t\tsh = 0xff - (start - idx);\n\t\t\telse if (sh < 0) {\n\t\t\t\tsh = start - idx;\n\t\t\t\tstart = idx;\n\t\t\t\tbitmap = bitmap << sh;\n\t\t\t\tsh = 0;\n\t\t\t}\n\t\t\tbitmap |= 1ULL << sh;\n\t\t\tD_TX_REPLY(\"start=%d bitmap=0x%llx\\n\", start,\n\t\t\t\t   (unsigned long long)bitmap);\n\t\t}\n\n\t\tagg->bitmap = bitmap;\n\t\tagg->start_idx = start;\n\t\tD_TX_REPLY(\"Frames %d start_idx=%d bitmap=0x%llx\\n\",\n\t\t\t   agg->frame_count, agg->start_idx,\n\t\t\t   (unsigned long long)agg->bitmap);\n\n\t\tif (bitmap)\n\t\t\tagg->wait_for_ba = 1;\n\t}\n\treturn 0;\n}\n\n \nstatic void\nil4965_hdl_tx(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tu16 sequence = le16_to_cpu(pkt->hdr.sequence);\n\tint txq_id = SEQ_TO_QUEUE(sequence);\n\tint idx = SEQ_TO_IDX(sequence);\n\tstruct il_tx_queue *txq = &il->txq[txq_id];\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_tx_info *info;\n\tstruct il4965_tx_resp *tx_resp = (void *)&pkt->u.raw[0];\n\tu32 status = le32_to_cpu(tx_resp->u.status);\n\tint tid;\n\tint sta_id;\n\tint freed;\n\tu8 *qc = NULL;\n\tunsigned long flags;\n\n\tif (idx >= txq->q.n_bd || il_queue_used(&txq->q, idx) == 0) {\n\t\tIL_ERR(\"Read idx for DMA queue txq_id (%d) idx %d \"\n\t\t       \"is out of range [0-%d] %d %d\\n\", txq_id, idx,\n\t\t       txq->q.n_bd, txq->q.write_ptr, txq->q.read_ptr);\n\t\treturn;\n\t}\n\n\ttxq->time_stamp = jiffies;\n\n\tskb = txq->skbs[txq->q.read_ptr];\n\tinfo = IEEE80211_SKB_CB(skb);\n\tmemset(&info->status, 0, sizeof(info->status));\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\tif (ieee80211_is_data_qos(hdr->frame_control)) {\n\t\tqc = ieee80211_get_qos_ctl(hdr);\n\t\ttid = qc[0] & 0xf;\n\t}\n\n\tsta_id = il4965_get_ra_sta_id(il, hdr);\n\tif (txq->sched_retry && unlikely(sta_id == IL_INVALID_STATION)) {\n\t\tIL_ERR(\"Station not known\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (unlikely((status & TX_STATUS_MSK) == TX_STATUS_FAIL_PASSIVE_NO_RX) &&\n\t    il->iw_mode == NL80211_IFTYPE_STATION) {\n\t\til_stop_queues_by_reason(il, IL_STOP_REASON_PASSIVE);\n\t\tD_INFO(\"Stopped queues - RX waiting on passive channel\\n\");\n\t}\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\tif (txq->sched_retry) {\n\t\tconst u32 scd_ssn = il4965_get_scd_ssn(tx_resp);\n\t\tstruct il_ht_agg *agg;\n\n\t\tif (WARN_ON(!qc))\n\t\t\tgoto out;\n\n\t\tagg = &il->stations[sta_id].tid[tid].agg;\n\n\t\til4965_tx_status_reply_tx(il, agg, tx_resp, txq_id, idx);\n\n\t\t \n\t\tif (tx_resp->frame_count == 1 &&\n\t\t    !il4965_is_tx_success(status))\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_AMPDU_NO_BACK;\n\n\t\tif (txq->q.read_ptr != (scd_ssn & 0xff)) {\n\t\t\tidx = il_queue_dec_wrap(scd_ssn & 0xff, txq->q.n_bd);\n\t\t\tD_TX_REPLY(\"Retry scheduler reclaim scd_ssn \"\n\t\t\t\t   \"%d idx %d\\n\", scd_ssn, idx);\n\t\t\tfreed = il4965_tx_queue_reclaim(il, txq_id, idx);\n\t\t\til4965_free_tfds_in_queue(il, sta_id, tid, freed);\n\n\t\t\tif (il->mac80211_registered &&\n\t\t\t    il_queue_space(&txq->q) > txq->q.low_mark &&\n\t\t\t    agg->state != IL_EMPTYING_HW_QUEUE_DELBA)\n\t\t\t\til_wake_queue(il, txq);\n\t\t}\n\t} else {\n\t\tinfo->status.rates[0].count = tx_resp->failure_frame + 1;\n\t\tinfo->flags |= il4965_tx_status_to_mac80211(status);\n\t\til4965_hwrate_to_tx_control(il,\n\t\t\t\t\t    le32_to_cpu(tx_resp->rate_n_flags),\n\t\t\t\t\t    info);\n\n\t\tD_TX_REPLY(\"TXQ %d status %s (0x%08x) \"\n\t\t\t   \"rate_n_flags 0x%x retries %d\\n\", txq_id,\n\t\t\t   il4965_get_tx_fail_reason(status), status,\n\t\t\t   le32_to_cpu(tx_resp->rate_n_flags),\n\t\t\t   tx_resp->failure_frame);\n\n\t\tfreed = il4965_tx_queue_reclaim(il, txq_id, idx);\n\t\tif (qc && likely(sta_id != IL_INVALID_STATION))\n\t\t\til4965_free_tfds_in_queue(il, sta_id, tid, freed);\n\t\telse if (sta_id == IL_INVALID_STATION)\n\t\t\tD_TX_REPLY(\"Station not known\\n\");\n\n\t\tif (il->mac80211_registered &&\n\t\t    il_queue_space(&txq->q) > txq->q.low_mark)\n\t\t\til_wake_queue(il, txq);\n\t}\nout:\n\tif (qc && likely(sta_id != IL_INVALID_STATION))\n\t\til4965_txq_check_empty(il, sta_id, tid, txq_id);\n\n\til4965_check_abort_status(il, tx_resp->frame_count, status);\n\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n}\n\n \nvoid\nil4965_hwrate_to_tx_control(struct il_priv *il, u32 rate_n_flags,\n\t\t\t    struct ieee80211_tx_info *info)\n{\n\tstruct ieee80211_tx_rate *r = &info->status.rates[0];\n\n\tinfo->status.antenna =\n\t    ((rate_n_flags & RATE_MCS_ANT_ABC_MSK) >> RATE_MCS_ANT_POS);\n\tif (rate_n_flags & RATE_MCS_HT_MSK)\n\t\tr->flags |= IEEE80211_TX_RC_MCS;\n\tif (rate_n_flags & RATE_MCS_GF_MSK)\n\t\tr->flags |= IEEE80211_TX_RC_GREEN_FIELD;\n\tif (rate_n_flags & RATE_MCS_HT40_MSK)\n\t\tr->flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\n\tif (rate_n_flags & RATE_MCS_DUP_MSK)\n\t\tr->flags |= IEEE80211_TX_RC_DUP_DATA;\n\tif (rate_n_flags & RATE_MCS_SGI_MSK)\n\t\tr->flags |= IEEE80211_TX_RC_SHORT_GI;\n\tr->idx = il4965_hwrate_to_mac80211_idx(rate_n_flags, info->band);\n}\n\n \nstatic void\nil4965_hdl_compressed_ba(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tstruct il_compressed_ba_resp *ba_resp = &pkt->u.compressed_ba;\n\tstruct il_tx_queue *txq = NULL;\n\tstruct il_ht_agg *agg;\n\tint idx;\n\tint sta_id;\n\tint tid;\n\tunsigned long flags;\n\n\t \n\tu16 scd_flow = le16_to_cpu(ba_resp->scd_flow);\n\n\t \n\tu16 ba_resp_scd_ssn = le16_to_cpu(ba_resp->scd_ssn);\n\n\tif (scd_flow >= il->hw_params.max_txq_num) {\n\t\tIL_ERR(\"BUG_ON scd_flow is bigger than number of queues\\n\");\n\t\treturn;\n\t}\n\n\ttxq = &il->txq[scd_flow];\n\tsta_id = ba_resp->sta_id;\n\ttid = ba_resp->tid;\n\tagg = &il->stations[sta_id].tid[tid].agg;\n\tif (unlikely(agg->txq_id != scd_flow)) {\n\t\t \n\t\tD_TX_REPLY(\"BA scd_flow %d does not match txq_id %d\\n\",\n\t\t\t   scd_flow, agg->txq_id);\n\t\treturn;\n\t}\n\n\t \n\tidx = il_queue_dec_wrap(ba_resp_scd_ssn & 0xff, txq->q.n_bd);\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\n\tD_TX_REPLY(\"N_COMPRESSED_BA [%d] Received from %pM, \" \"sta_id = %d\\n\",\n\t\t   agg->wait_for_ba, (u8 *) &ba_resp->sta_addr_lo32,\n\t\t   ba_resp->sta_id);\n\tD_TX_REPLY(\"TID = %d, SeqCtl = %d, bitmap = 0x%llx,\" \"scd_flow = \"\n\t\t   \"%d, scd_ssn = %d\\n\", ba_resp->tid, ba_resp->seq_ctl,\n\t\t   (unsigned long long)le64_to_cpu(ba_resp->bitmap),\n\t\t   ba_resp->scd_flow, ba_resp->scd_ssn);\n\tD_TX_REPLY(\"DAT start_idx = %d, bitmap = 0x%llx\\n\", agg->start_idx,\n\t\t   (unsigned long long)agg->bitmap);\n\n\t \n\til4965_tx_status_reply_compressed_ba(il, agg, ba_resp);\n\n\t \n\tif (txq->q.read_ptr != (ba_resp_scd_ssn & 0xff)) {\n\t\t \n\t\tint freed = il4965_tx_queue_reclaim(il, scd_flow, idx);\n\t\til4965_free_tfds_in_queue(il, sta_id, tid, freed);\n\n\t\tif (il_queue_space(&txq->q) > txq->q.low_mark &&\n\t\t    il->mac80211_registered &&\n\t\t    agg->state != IL_EMPTYING_HW_QUEUE_DELBA)\n\t\t\til_wake_queue(il, txq);\n\n\t\til4965_txq_check_empty(il, sta_id, tid, scd_flow);\n\t}\n\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n}\n\n#ifdef CONFIG_IWLEGACY_DEBUG\nconst char *\nil4965_get_tx_fail_reason(u32 status)\n{\n#define TX_STATUS_FAIL(x) case TX_STATUS_FAIL_ ## x: return #x\n#define TX_STATUS_POSTPONE(x) case TX_STATUS_POSTPONE_ ## x: return #x\n\n\tswitch (status & TX_STATUS_MSK) {\n\tcase TX_STATUS_SUCCESS:\n\t\treturn \"SUCCESS\";\n\t\tTX_STATUS_POSTPONE(DELAY);\n\t\tTX_STATUS_POSTPONE(FEW_BYTES);\n\t\tTX_STATUS_POSTPONE(QUIET_PERIOD);\n\t\tTX_STATUS_POSTPONE(CALC_TTAK);\n\t\tTX_STATUS_FAIL(INTERNAL_CROSSED_RETRY);\n\t\tTX_STATUS_FAIL(SHORT_LIMIT);\n\t\tTX_STATUS_FAIL(LONG_LIMIT);\n\t\tTX_STATUS_FAIL(FIFO_UNDERRUN);\n\t\tTX_STATUS_FAIL(DRAIN_FLOW);\n\t\tTX_STATUS_FAIL(RFKILL_FLUSH);\n\t\tTX_STATUS_FAIL(LIFE_EXPIRE);\n\t\tTX_STATUS_FAIL(DEST_PS);\n\t\tTX_STATUS_FAIL(HOST_ABORTED);\n\t\tTX_STATUS_FAIL(BT_RETRY);\n\t\tTX_STATUS_FAIL(STA_INVALID);\n\t\tTX_STATUS_FAIL(FRAG_DROPPED);\n\t\tTX_STATUS_FAIL(TID_DISABLE);\n\t\tTX_STATUS_FAIL(FIFO_FLUSHED);\n\t\tTX_STATUS_FAIL(INSUFFICIENT_CF_POLL);\n\t\tTX_STATUS_FAIL(PASSIVE_NO_RX);\n\t\tTX_STATUS_FAIL(NO_BEACON_ON_RADAR);\n\t}\n\n\treturn \"UNKNOWN\";\n\n#undef TX_STATUS_FAIL\n#undef TX_STATUS_POSTPONE\n}\n#endif  \n\nstatic struct il_link_quality_cmd *\nil4965_sta_alloc_lq(struct il_priv *il, u8 sta_id)\n{\n\tint i, r;\n\tstruct il_link_quality_cmd *link_cmd;\n\tu32 rate_flags = 0;\n\t__le32 rate_n_flags;\n\n\tlink_cmd = kzalloc(sizeof(struct il_link_quality_cmd), GFP_KERNEL);\n\tif (!link_cmd) {\n\t\tIL_ERR(\"Unable to allocate memory for LQ cmd.\\n\");\n\t\treturn NULL;\n\t}\n\t \n\tif (il->band == NL80211_BAND_5GHZ)\n\t\tr = RATE_6M_IDX;\n\telse\n\t\tr = RATE_1M_IDX;\n\n\tif (r >= IL_FIRST_CCK_RATE && r <= IL_LAST_CCK_RATE)\n\t\trate_flags |= RATE_MCS_CCK_MSK;\n\n\trate_flags |=\n\t    il4965_first_antenna(il->hw_params.\n\t\t\t\t valid_tx_ant) << RATE_MCS_ANT_POS;\n\trate_n_flags = cpu_to_le32(il_rates[r].plcp | rate_flags);\n\tfor (i = 0; i < LINK_QUAL_MAX_RETRY_NUM; i++)\n\t\tlink_cmd->rs_table[i].rate_n_flags = rate_n_flags;\n\n\tlink_cmd->general_params.single_stream_ant_msk =\n\t    il4965_first_antenna(il->hw_params.valid_tx_ant);\n\n\tlink_cmd->general_params.dual_stream_ant_msk =\n\t    il->hw_params.valid_tx_ant & ~il4965_first_antenna(il->hw_params.\n\t\t\t\t\t\t\t       valid_tx_ant);\n\tif (!link_cmd->general_params.dual_stream_ant_msk) {\n\t\tlink_cmd->general_params.dual_stream_ant_msk = ANT_AB;\n\t} else if (il4965_num_of_ant(il->hw_params.valid_tx_ant) == 2) {\n\t\tlink_cmd->general_params.dual_stream_ant_msk =\n\t\t    il->hw_params.valid_tx_ant;\n\t}\n\n\tlink_cmd->agg_params.agg_dis_start_th = LINK_QUAL_AGG_DISABLE_START_DEF;\n\tlink_cmd->agg_params.agg_time_limit =\n\t    cpu_to_le16(LINK_QUAL_AGG_TIME_LIMIT_DEF);\n\n\tlink_cmd->sta_id = sta_id;\n\n\treturn link_cmd;\n}\n\n \nint\nil4965_add_bssid_station(struct il_priv *il, const u8 *addr, u8 *sta_id_r)\n{\n\tint ret;\n\tu8 sta_id;\n\tstruct il_link_quality_cmd *link_cmd;\n\tunsigned long flags;\n\n\tif (sta_id_r)\n\t\t*sta_id_r = IL_INVALID_STATION;\n\n\tret = il_add_station_common(il, addr, 0, NULL, &sta_id);\n\tif (ret) {\n\t\tIL_ERR(\"Unable to add station %pM\\n\", addr);\n\t\treturn ret;\n\t}\n\n\tif (sta_id_r)\n\t\t*sta_id_r = sta_id;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\til->stations[sta_id].used |= IL_STA_LOCAL;\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\t \n\tlink_cmd = il4965_sta_alloc_lq(il, sta_id);\n\tif (!link_cmd) {\n\t\tIL_ERR(\"Unable to initialize rate scaling for station %pM.\\n\",\n\t\t       addr);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = il_send_lq_cmd(il, link_cmd, CMD_SYNC, true);\n\tif (ret)\n\t\tIL_ERR(\"Link quality command failed (%d)\\n\", ret);\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\til->stations[sta_id].lq = link_cmd;\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\treturn 0;\n}\n\nstatic int\nil4965_static_wepkey_cmd(struct il_priv *il, bool send_if_empty)\n{\n\tint i;\n\tu8 buff[sizeof(struct il_wep_cmd) +\n\t\tsizeof(struct il_wep_key) * WEP_KEYS_MAX];\n\tstruct il_wep_cmd *wep_cmd = (struct il_wep_cmd *)buff;\n\tsize_t cmd_size = sizeof(struct il_wep_cmd);\n\tstruct il_host_cmd cmd = {\n\t\t.id = C_WEPKEY,\n\t\t.data = wep_cmd,\n\t\t.flags = CMD_SYNC,\n\t};\n\tbool not_empty = false;\n\n\tmight_sleep();\n\n\tmemset(wep_cmd, 0,\n\t       cmd_size + (sizeof(struct il_wep_key) * WEP_KEYS_MAX));\n\n\tfor (i = 0; i < WEP_KEYS_MAX; i++) {\n\t\tu8 key_size = il->_4965.wep_keys[i].key_size;\n\n\t\twep_cmd->key[i].key_idx = i;\n\t\tif (key_size) {\n\t\t\twep_cmd->key[i].key_offset = i;\n\t\t\tnot_empty = true;\n\t\t} else\n\t\t\twep_cmd->key[i].key_offset = WEP_INVALID_OFFSET;\n\n\t\twep_cmd->key[i].key_size = key_size;\n\t\tmemcpy(&wep_cmd->key[i].key[3], il->_4965.wep_keys[i].key, key_size);\n\t}\n\n\twep_cmd->global_key_type = WEP_KEY_WEP_TYPE;\n\twep_cmd->num_keys = WEP_KEYS_MAX;\n\n\tcmd_size += sizeof(struct il_wep_key) * WEP_KEYS_MAX;\n\tcmd.len = cmd_size;\n\n\tif (not_empty || send_if_empty)\n\t\treturn il_send_cmd(il, &cmd);\n\telse\n\t\treturn 0;\n}\n\nint\nil4965_restore_default_wep_keys(struct il_priv *il)\n{\n\tlockdep_assert_held(&il->mutex);\n\n\treturn il4965_static_wepkey_cmd(il, false);\n}\n\nint\nil4965_remove_default_wep_key(struct il_priv *il,\n\t\t\t      struct ieee80211_key_conf *keyconf)\n{\n\tint ret;\n\tint idx = keyconf->keyidx;\n\n\tlockdep_assert_held(&il->mutex);\n\n\tD_WEP(\"Removing default WEP key: idx=%d\\n\", idx);\n\n\tmemset(&il->_4965.wep_keys[idx], 0, sizeof(struct il_wep_key));\n\tif (il_is_rfkill(il)) {\n\t\tD_WEP(\"Not sending C_WEPKEY command due to RFKILL.\\n\");\n\t\t \n\t\treturn 0;\n\t}\n\tret = il4965_static_wepkey_cmd(il, 1);\n\tD_WEP(\"Remove default WEP key: idx=%d ret=%d\\n\", idx, ret);\n\n\treturn ret;\n}\n\nint\nil4965_set_default_wep_key(struct il_priv *il,\n\t\t\t   struct ieee80211_key_conf *keyconf)\n{\n\tint ret;\n\tint len = keyconf->keylen;\n\tint idx = keyconf->keyidx;\n\n\tlockdep_assert_held(&il->mutex);\n\n\tif (len != WEP_KEY_LEN_128 && len != WEP_KEY_LEN_64) {\n\t\tD_WEP(\"Bad WEP key length %d\\n\", keyconf->keylen);\n\t\treturn -EINVAL;\n\t}\n\n\tkeyconf->flags &= ~IEEE80211_KEY_FLAG_GENERATE_IV;\n\tkeyconf->hw_key_idx = HW_KEY_DEFAULT;\n\til->stations[IL_AP_ID].keyinfo.cipher = keyconf->cipher;\n\n\til->_4965.wep_keys[idx].key_size = len;\n\tmemcpy(&il->_4965.wep_keys[idx].key, &keyconf->key, len);\n\n\tret = il4965_static_wepkey_cmd(il, false);\n\n\tD_WEP(\"Set default WEP key: len=%d idx=%d ret=%d\\n\", len, idx, ret);\n\treturn ret;\n}\n\nstatic int\nil4965_set_wep_dynamic_key_info(struct il_priv *il,\n\t\t\t\tstruct ieee80211_key_conf *keyconf, u8 sta_id)\n{\n\tunsigned long flags;\n\t__le16 key_flags = 0;\n\tstruct il_addsta_cmd sta_cmd;\n\n\tlockdep_assert_held(&il->mutex);\n\n\tkeyconf->flags &= ~IEEE80211_KEY_FLAG_GENERATE_IV;\n\n\tkey_flags |= (STA_KEY_FLG_WEP | STA_KEY_FLG_MAP_KEY_MSK);\n\tkey_flags |= cpu_to_le16(keyconf->keyidx << STA_KEY_FLG_KEYID_POS);\n\tkey_flags &= ~STA_KEY_FLG_INVALID;\n\n\tif (keyconf->keylen == WEP_KEY_LEN_128)\n\t\tkey_flags |= STA_KEY_FLG_KEY_SIZE_MSK;\n\n\tif (sta_id == il->hw_params.bcast_id)\n\t\tkey_flags |= STA_KEY_MULTICAST_MSK;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\n\til->stations[sta_id].keyinfo.cipher = keyconf->cipher;\n\til->stations[sta_id].keyinfo.keylen = keyconf->keylen;\n\til->stations[sta_id].keyinfo.keyidx = keyconf->keyidx;\n\n\tmemcpy(il->stations[sta_id].keyinfo.key, keyconf->key, keyconf->keylen);\n\n\tmemcpy(&il->stations[sta_id].sta.key.key[3], keyconf->key,\n\t       keyconf->keylen);\n\n\tif ((il->stations[sta_id].sta.key.\n\t     key_flags & STA_KEY_FLG_ENCRYPT_MSK) == STA_KEY_FLG_NO_ENC)\n\t\til->stations[sta_id].sta.key.key_offset =\n\t\t    il_get_free_ucode_key_idx(il);\n\t \n\n\tWARN(il->stations[sta_id].sta.key.key_offset == WEP_INVALID_OFFSET,\n\t     \"no space for a new key\");\n\n\til->stations[sta_id].sta.key.key_flags = key_flags;\n\til->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_KEY_MASK;\n\til->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\n\tmemcpy(&sta_cmd, &il->stations[sta_id].sta,\n\t       sizeof(struct il_addsta_cmd));\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\treturn il_send_add_sta(il, &sta_cmd, CMD_SYNC);\n}\n\nstatic int\nil4965_set_ccmp_dynamic_key_info(struct il_priv *il,\n\t\t\t\t struct ieee80211_key_conf *keyconf, u8 sta_id)\n{\n\tunsigned long flags;\n\t__le16 key_flags = 0;\n\tstruct il_addsta_cmd sta_cmd;\n\n\tlockdep_assert_held(&il->mutex);\n\n\tkey_flags |= (STA_KEY_FLG_CCMP | STA_KEY_FLG_MAP_KEY_MSK);\n\tkey_flags |= cpu_to_le16(keyconf->keyidx << STA_KEY_FLG_KEYID_POS);\n\tkey_flags &= ~STA_KEY_FLG_INVALID;\n\n\tif (sta_id == il->hw_params.bcast_id)\n\t\tkey_flags |= STA_KEY_MULTICAST_MSK;\n\n\tkeyconf->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\til->stations[sta_id].keyinfo.cipher = keyconf->cipher;\n\til->stations[sta_id].keyinfo.keylen = keyconf->keylen;\n\n\tmemcpy(il->stations[sta_id].keyinfo.key, keyconf->key, keyconf->keylen);\n\n\tmemcpy(il->stations[sta_id].sta.key.key, keyconf->key, keyconf->keylen);\n\n\tif ((il->stations[sta_id].sta.key.\n\t     key_flags & STA_KEY_FLG_ENCRYPT_MSK) == STA_KEY_FLG_NO_ENC)\n\t\til->stations[sta_id].sta.key.key_offset =\n\t\t    il_get_free_ucode_key_idx(il);\n\t \n\n\tWARN(il->stations[sta_id].sta.key.key_offset == WEP_INVALID_OFFSET,\n\t     \"no space for a new key\");\n\n\til->stations[sta_id].sta.key.key_flags = key_flags;\n\til->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_KEY_MASK;\n\til->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\n\tmemcpy(&sta_cmd, &il->stations[sta_id].sta,\n\t       sizeof(struct il_addsta_cmd));\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\treturn il_send_add_sta(il, &sta_cmd, CMD_SYNC);\n}\n\nstatic int\nil4965_set_tkip_dynamic_key_info(struct il_priv *il,\n\t\t\t\t struct ieee80211_key_conf *keyconf, u8 sta_id)\n{\n\tunsigned long flags;\n\t__le16 key_flags = 0;\n\n\tkey_flags |= (STA_KEY_FLG_TKIP | STA_KEY_FLG_MAP_KEY_MSK);\n\tkey_flags |= cpu_to_le16(keyconf->keyidx << STA_KEY_FLG_KEYID_POS);\n\tkey_flags &= ~STA_KEY_FLG_INVALID;\n\n\tif (sta_id == il->hw_params.bcast_id)\n\t\tkey_flags |= STA_KEY_MULTICAST_MSK;\n\n\tkeyconf->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\n\tkeyconf->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\n\til->stations[sta_id].keyinfo.cipher = keyconf->cipher;\n\til->stations[sta_id].keyinfo.keylen = 16;\n\n\tif ((il->stations[sta_id].sta.key.\n\t     key_flags & STA_KEY_FLG_ENCRYPT_MSK) == STA_KEY_FLG_NO_ENC)\n\t\til->stations[sta_id].sta.key.key_offset =\n\t\t    il_get_free_ucode_key_idx(il);\n\t \n\n\tWARN(il->stations[sta_id].sta.key.key_offset == WEP_INVALID_OFFSET,\n\t     \"no space for a new key\");\n\n\til->stations[sta_id].sta.key.key_flags = key_flags;\n\n\t \n\tmemcpy(il->stations[sta_id].keyinfo.key, keyconf->key, 16);\n\n\tmemcpy(il->stations[sta_id].sta.key.key, keyconf->key, 16);\n\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\treturn 0;\n}\n\nvoid\nil4965_update_tkip_key(struct il_priv *il, struct ieee80211_key_conf *keyconf,\n\t\t       struct ieee80211_sta *sta, u32 iv32, u16 *phase1key)\n{\n\tu8 sta_id;\n\tunsigned long flags;\n\tint i;\n\n\tif (il_scan_cancel(il)) {\n\t\t \n\t\treturn;\n\t}\n\n\tsta_id = il_sta_id_or_broadcast(il, sta);\n\tif (sta_id == IL_INVALID_STATION)\n\t\treturn;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\n\til->stations[sta_id].sta.key.tkip_rx_tsc_byte2 = (u8) iv32;\n\n\tfor (i = 0; i < 5; i++)\n\t\til->stations[sta_id].sta.key.tkip_rx_ttak[i] =\n\t\t    cpu_to_le16(phase1key[i]);\n\n\til->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_KEY_MASK;\n\til->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\n\til_send_add_sta(il, &il->stations[sta_id].sta, CMD_ASYNC);\n\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n}\n\nint\nil4965_remove_dynamic_key(struct il_priv *il,\n\t\t\t  struct ieee80211_key_conf *keyconf, u8 sta_id)\n{\n\tunsigned long flags;\n\tu16 key_flags;\n\tu8 keyidx;\n\tstruct il_addsta_cmd sta_cmd;\n\n\tlockdep_assert_held(&il->mutex);\n\n\til->_4965.key_mapping_keys--;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\tkey_flags = le16_to_cpu(il->stations[sta_id].sta.key.key_flags);\n\tkeyidx = (key_flags >> STA_KEY_FLG_KEYID_POS) & 0x3;\n\n\tD_WEP(\"Remove dynamic key: idx=%d sta=%d\\n\", keyconf->keyidx, sta_id);\n\n\tif (keyconf->keyidx != keyidx) {\n\t\t \n\t\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\t\treturn 0;\n\t}\n\n\tif (il->stations[sta_id].sta.key.key_flags & STA_KEY_FLG_INVALID) {\n\t\tIL_WARN(\"Removing wrong key %d 0x%x\\n\", keyconf->keyidx,\n\t\t\tkey_flags);\n\t\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\t\treturn 0;\n\t}\n\n\tif (!test_and_clear_bit\n\t    (il->stations[sta_id].sta.key.key_offset, &il->ucode_key_table))\n\t\tIL_ERR(\"idx %d not used in uCode key table.\\n\",\n\t\t       il->stations[sta_id].sta.key.key_offset);\n\tmemset(&il->stations[sta_id].keyinfo, 0, sizeof(struct il_hw_key));\n\tmemset(&il->stations[sta_id].sta.key, 0, sizeof(struct il4965_keyinfo));\n\til->stations[sta_id].sta.key.key_flags =\n\t    STA_KEY_FLG_NO_ENC | STA_KEY_FLG_INVALID;\n\til->stations[sta_id].sta.key.key_offset = keyconf->hw_key_idx;\n\til->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_KEY_MASK;\n\til->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\n\tif (il_is_rfkill(il)) {\n\t\tD_WEP\n\t\t    (\"Not sending C_ADD_STA command because RFKILL enabled.\\n\");\n\t\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\t\treturn 0;\n\t}\n\tmemcpy(&sta_cmd, &il->stations[sta_id].sta,\n\t       sizeof(struct il_addsta_cmd));\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\treturn il_send_add_sta(il, &sta_cmd, CMD_SYNC);\n}\n\nint\nil4965_set_dynamic_key(struct il_priv *il, struct ieee80211_key_conf *keyconf,\n\t\t       u8 sta_id)\n{\n\tint ret;\n\n\tlockdep_assert_held(&il->mutex);\n\n\til->_4965.key_mapping_keys++;\n\tkeyconf->hw_key_idx = HW_KEY_DYNAMIC;\n\n\tswitch (keyconf->cipher) {\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tret =\n\t\t    il4965_set_ccmp_dynamic_key_info(il, keyconf, sta_id);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tret =\n\t\t    il4965_set_tkip_dynamic_key_info(il, keyconf, sta_id);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tret = il4965_set_wep_dynamic_key_info(il, keyconf, sta_id);\n\t\tbreak;\n\tdefault:\n\t\tIL_ERR(\"Unknown alg: %s cipher = %x\\n\", __func__,\n\t\t       keyconf->cipher);\n\t\tret = -EINVAL;\n\t}\n\n\tD_WEP(\"Set dynamic key: cipher=%x len=%d idx=%d sta=%d ret=%d\\n\",\n\t      keyconf->cipher, keyconf->keylen, keyconf->keyidx, sta_id, ret);\n\n\treturn ret;\n}\n\n \nint\nil4965_alloc_bcast_station(struct il_priv *il)\n{\n\tstruct il_link_quality_cmd *link_cmd;\n\tunsigned long flags;\n\tu8 sta_id;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\tsta_id = il_prep_station(il, il_bcast_addr, false, NULL);\n\tif (sta_id == IL_INVALID_STATION) {\n\t\tIL_ERR(\"Unable to prepare broadcast station\\n\");\n\t\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\t\treturn -EINVAL;\n\t}\n\n\til->stations[sta_id].used |= IL_STA_DRIVER_ACTIVE;\n\til->stations[sta_id].used |= IL_STA_BCAST;\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\tlink_cmd = il4965_sta_alloc_lq(il, sta_id);\n\tif (!link_cmd) {\n\t\tIL_ERR\n\t\t    (\"Unable to initialize rate scaling for bcast station.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\til->stations[sta_id].lq = link_cmd;\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int\nil4965_update_bcast_station(struct il_priv *il)\n{\n\tunsigned long flags;\n\tstruct il_link_quality_cmd *link_cmd;\n\tu8 sta_id = il->hw_params.bcast_id;\n\n\tlink_cmd = il4965_sta_alloc_lq(il, sta_id);\n\tif (!link_cmd) {\n\t\tIL_ERR(\"Unable to initialize rate scaling for bcast sta.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\tif (il->stations[sta_id].lq)\n\t\tkfree(il->stations[sta_id].lq);\n\telse\n\t\tD_INFO(\"Bcast sta rate scaling has not been initialized.\\n\");\n\til->stations[sta_id].lq = link_cmd;\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\treturn 0;\n}\n\nint\nil4965_update_bcast_stations(struct il_priv *il)\n{\n\treturn il4965_update_bcast_station(il);\n}\n\n \nint\nil4965_sta_tx_modify_enable_tid(struct il_priv *il, int sta_id, int tid)\n{\n\tunsigned long flags;\n\tstruct il_addsta_cmd sta_cmd;\n\n\tlockdep_assert_held(&il->mutex);\n\n\t \n\tspin_lock_irqsave(&il->sta_lock, flags);\n\til->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_TID_DISABLE_TX;\n\til->stations[sta_id].sta.tid_disable_tx &= cpu_to_le16(~(1 << tid));\n\til->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\tmemcpy(&sta_cmd, &il->stations[sta_id].sta,\n\t       sizeof(struct il_addsta_cmd));\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\treturn il_send_add_sta(il, &sta_cmd, CMD_SYNC);\n}\n\nint\nil4965_sta_rx_agg_start(struct il_priv *il, struct ieee80211_sta *sta, int tid,\n\t\t\tu16 ssn)\n{\n\tunsigned long flags;\n\tint sta_id;\n\tstruct il_addsta_cmd sta_cmd;\n\n\tlockdep_assert_held(&il->mutex);\n\n\tsta_id = il_sta_id(sta);\n\tif (sta_id == IL_INVALID_STATION)\n\t\treturn -ENXIO;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\til->stations[sta_id].sta.station_flags_msk = 0;\n\til->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_ADDBA_TID_MSK;\n\til->stations[sta_id].sta.add_immediate_ba_tid = (u8) tid;\n\til->stations[sta_id].sta.add_immediate_ba_ssn = cpu_to_le16(ssn);\n\til->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\tmemcpy(&sta_cmd, &il->stations[sta_id].sta,\n\t       sizeof(struct il_addsta_cmd));\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\treturn il_send_add_sta(il, &sta_cmd, CMD_SYNC);\n}\n\nint\nil4965_sta_rx_agg_stop(struct il_priv *il, struct ieee80211_sta *sta, int tid)\n{\n\tunsigned long flags;\n\tint sta_id;\n\tstruct il_addsta_cmd sta_cmd;\n\n\tlockdep_assert_held(&il->mutex);\n\n\tsta_id = il_sta_id(sta);\n\tif (sta_id == IL_INVALID_STATION) {\n\t\tIL_ERR(\"Invalid station for AGG tid %d\\n\", tid);\n\t\treturn -ENXIO;\n\t}\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\til->stations[sta_id].sta.station_flags_msk = 0;\n\til->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_DELBA_TID_MSK;\n\til->stations[sta_id].sta.remove_immediate_ba_tid = (u8) tid;\n\til->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\tmemcpy(&sta_cmd, &il->stations[sta_id].sta,\n\t       sizeof(struct il_addsta_cmd));\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\treturn il_send_add_sta(il, &sta_cmd, CMD_SYNC);\n}\n\nvoid\nil4965_sta_modify_sleep_tx_count(struct il_priv *il, int sta_id, int cnt)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\til->stations[sta_id].sta.station_flags |= STA_FLG_PWR_SAVE_MSK;\n\til->stations[sta_id].sta.station_flags_msk = STA_FLG_PWR_SAVE_MSK;\n\til->stations[sta_id].sta.sta.modify_mask =\n\t    STA_MODIFY_SLEEP_TX_COUNT_MSK;\n\til->stations[sta_id].sta.sleep_tx_count = cpu_to_le16(cnt);\n\til->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\til_send_add_sta(il, &il->stations[sta_id].sta, CMD_ASYNC);\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n}\n\nvoid\nil4965_update_chain_flags(struct il_priv *il)\n{\n\tif (il->ops->set_rxon_chain) {\n\t\til->ops->set_rxon_chain(il);\n\t\tif (il->active.rx_chain != il->staging.rx_chain)\n\t\t\til_commit_rxon(il);\n\t}\n}\n\nstatic void\nil4965_clear_free_frames(struct il_priv *il)\n{\n\tstruct list_head *element;\n\n\tD_INFO(\"%d frames on pre-allocated heap on clear.\\n\", il->frames_count);\n\n\twhile (!list_empty(&il->free_frames)) {\n\t\telement = il->free_frames.next;\n\t\tlist_del(element);\n\t\tkfree(list_entry(element, struct il_frame, list));\n\t\til->frames_count--;\n\t}\n\n\tif (il->frames_count) {\n\t\tIL_WARN(\"%d frames still in use.  Did we lose one?\\n\",\n\t\t\til->frames_count);\n\t\til->frames_count = 0;\n\t}\n}\n\nstatic struct il_frame *\nil4965_get_free_frame(struct il_priv *il)\n{\n\tstruct il_frame *frame;\n\tstruct list_head *element;\n\tif (list_empty(&il->free_frames)) {\n\t\tframe = kzalloc(sizeof(*frame), GFP_KERNEL);\n\t\tif (!frame) {\n\t\t\tIL_ERR(\"Could not allocate frame!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\til->frames_count++;\n\t\treturn frame;\n\t}\n\n\telement = il->free_frames.next;\n\tlist_del(element);\n\treturn list_entry(element, struct il_frame, list);\n}\n\nstatic void\nil4965_free_frame(struct il_priv *il, struct il_frame *frame)\n{\n\tmemset(frame, 0, sizeof(*frame));\n\tlist_add(&frame->list, &il->free_frames);\n}\n\nstatic u32\nil4965_fill_beacon_frame(struct il_priv *il, struct ieee80211_hdr *hdr,\n\t\t\t int left)\n{\n\tlockdep_assert_held(&il->mutex);\n\n\tif (!il->beacon_skb)\n\t\treturn 0;\n\n\tif (il->beacon_skb->len > left)\n\t\treturn 0;\n\n\tmemcpy(hdr, il->beacon_skb->data, il->beacon_skb->len);\n\n\treturn il->beacon_skb->len;\n}\n\n \nstatic void\nil4965_set_beacon_tim(struct il_priv *il,\n\t\t      struct il_tx_beacon_cmd *tx_beacon_cmd, u8 * beacon,\n\t\t      u32 frame_size)\n{\n\tu16 tim_idx;\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)beacon;\n\n\t \n\ttim_idx = mgmt->u.beacon.variable - beacon;\n\n\t \n\twhile ((tim_idx < (frame_size - 2)) &&\n\t       (beacon[tim_idx] != WLAN_EID_TIM))\n\t\ttim_idx += beacon[tim_idx + 1] + 2;\n\n\t \n\tif ((tim_idx < (frame_size - 1)) && (beacon[tim_idx] == WLAN_EID_TIM)) {\n\t\ttx_beacon_cmd->tim_idx = cpu_to_le16(tim_idx);\n\t\ttx_beacon_cmd->tim_size = beacon[tim_idx + 1];\n\t} else\n\t\tIL_WARN(\"Unable to find TIM Element in beacon\\n\");\n}\n\nstatic unsigned int\nil4965_hw_get_beacon_cmd(struct il_priv *il, struct il_frame *frame)\n{\n\tstruct il_tx_beacon_cmd *tx_beacon_cmd;\n\tu32 frame_size;\n\tu32 rate_flags;\n\tu32 rate;\n\t \n\n\tlockdep_assert_held(&il->mutex);\n\n\tif (!il->beacon_enabled) {\n\t\tIL_ERR(\"Trying to build beacon without beaconing enabled\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\ttx_beacon_cmd = &frame->u.beacon;\n\tmemset(tx_beacon_cmd, 0, sizeof(*tx_beacon_cmd));\n\n\t \n\tframe_size =\n\t    il4965_fill_beacon_frame(il, tx_beacon_cmd->frame,\n\t\t\t\t     sizeof(frame->u) - sizeof(*tx_beacon_cmd));\n\tif (WARN_ON_ONCE(frame_size > MAX_MPDU_SIZE))\n\t\treturn 0;\n\tif (!frame_size)\n\t\treturn 0;\n\n\t \n\ttx_beacon_cmd->tx.len = cpu_to_le16((u16) frame_size);\n\ttx_beacon_cmd->tx.sta_id = il->hw_params.bcast_id;\n\ttx_beacon_cmd->tx.stop_time.life_time = TX_CMD_LIFE_TIME_INFINITE;\n\ttx_beacon_cmd->tx.tx_flags =\n\t    TX_CMD_FLG_SEQ_CTL_MSK | TX_CMD_FLG_TSF_MSK |\n\t    TX_CMD_FLG_STA_RATE_MSK;\n\n\t \n\til4965_set_beacon_tim(il, tx_beacon_cmd, (u8 *) tx_beacon_cmd->frame,\n\t\t\t      frame_size);\n\n\t \n\trate = il_get_lowest_plcp(il);\n\til4965_toggle_tx_ant(il, &il->mgmt_tx_ant, il->hw_params.valid_tx_ant);\n\trate_flags = BIT(il->mgmt_tx_ant) << RATE_MCS_ANT_POS;\n\tif ((rate >= IL_FIRST_CCK_RATE) && (rate <= IL_LAST_CCK_RATE))\n\t\trate_flags |= RATE_MCS_CCK_MSK;\n\ttx_beacon_cmd->tx.rate_n_flags = cpu_to_le32(rate | rate_flags);\n\n\treturn sizeof(*tx_beacon_cmd) + frame_size;\n}\n\nint\nil4965_send_beacon_cmd(struct il_priv *il)\n{\n\tstruct il_frame *frame;\n\tunsigned int frame_size;\n\tint rc;\n\n\tframe = il4965_get_free_frame(il);\n\tif (!frame) {\n\t\tIL_ERR(\"Could not obtain free frame buffer for beacon \"\n\t\t       \"command.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tframe_size = il4965_hw_get_beacon_cmd(il, frame);\n\tif (!frame_size) {\n\t\tIL_ERR(\"Error configuring the beacon command\\n\");\n\t\til4965_free_frame(il, frame);\n\t\treturn -EINVAL;\n\t}\n\n\trc = il_send_cmd_pdu(il, C_TX_BEACON, frame_size, &frame->u.cmd[0]);\n\n\til4965_free_frame(il, frame);\n\n\treturn rc;\n}\n\nstatic inline dma_addr_t\nil4965_tfd_tb_get_addr(struct il_tfd *tfd, u8 idx)\n{\n\tstruct il_tfd_tb *tb = &tfd->tbs[idx];\n\n\tdma_addr_t addr = get_unaligned_le32(&tb->lo);\n\tif (sizeof(dma_addr_t) > sizeof(u32))\n\t\taddr |=\n\t\t    ((dma_addr_t) (le16_to_cpu(tb->hi_n_len) & 0xF) << 16) <<\n\t\t    16;\n\n\treturn addr;\n}\n\nstatic inline u16\nil4965_tfd_tb_get_len(struct il_tfd *tfd, u8 idx)\n{\n\tstruct il_tfd_tb *tb = &tfd->tbs[idx];\n\n\treturn le16_to_cpu(tb->hi_n_len) >> 4;\n}\n\nstatic inline void\nil4965_tfd_set_tb(struct il_tfd *tfd, u8 idx, dma_addr_t addr, u16 len)\n{\n\tstruct il_tfd_tb *tb = &tfd->tbs[idx];\n\tu16 hi_n_len = len << 4;\n\n\tput_unaligned_le32(addr, &tb->lo);\n\tif (sizeof(dma_addr_t) > sizeof(u32))\n\t\thi_n_len |= ((addr >> 16) >> 16) & 0xF;\n\n\ttb->hi_n_len = cpu_to_le16(hi_n_len);\n\n\ttfd->num_tbs = idx + 1;\n}\n\nstatic inline u8\nil4965_tfd_get_num_tbs(struct il_tfd *tfd)\n{\n\treturn tfd->num_tbs & 0x1f;\n}\n\n \nvoid\nil4965_hw_txq_free_tfd(struct il_priv *il, struct il_tx_queue *txq)\n{\n\tstruct il_tfd *tfd_tmp = (struct il_tfd *)txq->tfds;\n\tstruct il_tfd *tfd;\n\tstruct pci_dev *dev = il->pci_dev;\n\tint idx = txq->q.read_ptr;\n\tint i;\n\tint num_tbs;\n\n\ttfd = &tfd_tmp[idx];\n\n\t \n\tnum_tbs = il4965_tfd_get_num_tbs(tfd);\n\n\tif (num_tbs >= IL_NUM_OF_TBS) {\n\t\tIL_ERR(\"Too many chunks: %i\\n\", num_tbs);\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tif (num_tbs)\n\t\tdma_unmap_single(&dev->dev,\n\t\t\t\t dma_unmap_addr(&txq->meta[idx], mapping),\n\t\t\t\t dma_unmap_len(&txq->meta[idx], len),\n\t\t\t\t DMA_BIDIRECTIONAL);\n\n\t \n\tfor (i = 1; i < num_tbs; i++)\n\t\tdma_unmap_single(&dev->dev, il4965_tfd_tb_get_addr(tfd, i),\n\t\t\t\t il4965_tfd_tb_get_len(tfd, i), DMA_TO_DEVICE);\n\n\t \n\tif (txq->skbs) {\n\t\tstruct sk_buff *skb = txq->skbs[txq->q.read_ptr];\n\n\t\t \n\t\tif (skb) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\ttxq->skbs[txq->q.read_ptr] = NULL;\n\t\t}\n\t}\n}\n\nint\nil4965_hw_txq_attach_buf_to_tfd(struct il_priv *il, struct il_tx_queue *txq,\n\t\t\t\tdma_addr_t addr, u16 len, u8 reset, u8 pad)\n{\n\tstruct il_queue *q;\n\tstruct il_tfd *tfd, *tfd_tmp;\n\tu32 num_tbs;\n\n\tq = &txq->q;\n\ttfd_tmp = (struct il_tfd *)txq->tfds;\n\ttfd = &tfd_tmp[q->write_ptr];\n\n\tif (reset)\n\t\tmemset(tfd, 0, sizeof(*tfd));\n\n\tnum_tbs = il4965_tfd_get_num_tbs(tfd);\n\n\t \n\tif (num_tbs >= IL_NUM_OF_TBS) {\n\t\tIL_ERR(\"Error can not send more than %d chunks\\n\",\n\t\t       IL_NUM_OF_TBS);\n\t\treturn -EINVAL;\n\t}\n\n\tBUG_ON(addr & ~DMA_BIT_MASK(36));\n\tif (unlikely(addr & ~IL_TX_DMA_MASK))\n\t\tIL_ERR(\"Unaligned address = %llx\\n\", (unsigned long long)addr);\n\n\til4965_tfd_set_tb(tfd, num_tbs, addr, len);\n\n\treturn 0;\n}\n\n \nint\nil4965_hw_tx_queue_init(struct il_priv *il, struct il_tx_queue *txq)\n{\n\tint txq_id = txq->q.id;\n\n\t \n\til_wr(il, FH49_MEM_CBBC_QUEUE(txq_id), txq->q.dma_addr >> 8);\n\n\treturn 0;\n}\n\n \nstatic void\nil4965_hdl_alive(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tstruct il_alive_resp *palive;\n\tstruct delayed_work *pwork;\n\n\tpalive = &pkt->u.alive_frame;\n\n\tD_INFO(\"Alive ucode status 0x%08X revision \" \"0x%01X 0x%01X\\n\",\n\t       palive->is_valid, palive->ver_type, palive->ver_subtype);\n\n\tif (palive->ver_subtype == INITIALIZE_SUBTYPE) {\n\t\tD_INFO(\"Initialization Alive received.\\n\");\n\t\tmemcpy(&il->card_alive_init, &pkt->u.raw,\n\t\t       sizeof(struct il_init_alive_resp));\n\t\tpwork = &il->init_alive_start;\n\t} else {\n\t\tD_INFO(\"Runtime Alive received.\\n\");\n\t\tmemcpy(&il->card_alive, &pkt->u.alive_frame,\n\t\t       sizeof(struct il_alive_resp));\n\t\tpwork = &il->alive_start;\n\t}\n\n\t \n\tif (palive->is_valid == UCODE_VALID_OK)\n\t\tqueue_delayed_work(il->workqueue, pwork, msecs_to_jiffies(5));\n\telse\n\t\tIL_WARN(\"uCode did not respond OK.\\n\");\n}\n\n \nstatic void\nil4965_bg_stats_periodic(struct timer_list *t)\n{\n\tstruct il_priv *il = from_timer(il, t, stats_periodic);\n\n\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\treturn;\n\n\t \n\tif (!il_is_ready_rf(il))\n\t\treturn;\n\n\til_send_stats_request(il, CMD_ASYNC, false);\n}\n\nstatic void\nil4965_hdl_beacon(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tstruct il4965_beacon_notif *beacon =\n\t    (struct il4965_beacon_notif *)pkt->u.raw;\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tu8 rate = il4965_hw_get_rate(beacon->beacon_notify_hdr.rate_n_flags);\n\n\tD_RX(\"beacon status %x retries %d iss %d tsf:0x%.8x%.8x rate %d\\n\",\n\t     le32_to_cpu(beacon->beacon_notify_hdr.u.status) & TX_STATUS_MSK,\n\t     beacon->beacon_notify_hdr.failure_frame,\n\t     le32_to_cpu(beacon->ibss_mgr_status),\n\t     le32_to_cpu(beacon->high_tsf), le32_to_cpu(beacon->low_tsf), rate);\n#endif\n\til->ibss_manager = le32_to_cpu(beacon->ibss_mgr_status);\n}\n\nstatic void\nil4965_perform_ct_kill_task(struct il_priv *il)\n{\n\tunsigned long flags;\n\n\tD_POWER(\"Stop all queues\\n\");\n\n\tif (il->mac80211_registered)\n\t\tieee80211_stop_queues(il->hw);\n\n\t_il_wr(il, CSR_UCODE_DRV_GP1_SET,\n\t       CSR_UCODE_DRV_GP1_REG_BIT_CT_KILL_EXIT);\n\t_il_rd(il, CSR_UCODE_DRV_GP1);\n\n\tspin_lock_irqsave(&il->reg_lock, flags);\n\tif (likely(_il_grab_nic_access(il)))\n\t\t_il_release_nic_access(il);\n\tspin_unlock_irqrestore(&il->reg_lock, flags);\n}\n\n \nstatic void\nil4965_hdl_card_state(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tu32 flags = le32_to_cpu(pkt->u.card_state_notif.flags);\n\tunsigned long status = il->status;\n\n\tD_RF_KILL(\"Card state received: HW:%s SW:%s CT:%s\\n\",\n\t\t  (flags & HW_CARD_DISABLED) ? \"Kill\" : \"On\",\n\t\t  (flags & SW_CARD_DISABLED) ? \"Kill\" : \"On\",\n\t\t  (flags & CT_CARD_DISABLED) ? \"Reached\" : \"Not reached\");\n\n\tif (flags & (SW_CARD_DISABLED | HW_CARD_DISABLED | CT_CARD_DISABLED)) {\n\n\t\t_il_wr(il, CSR_UCODE_DRV_GP1_SET,\n\t\t       CSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED);\n\n\t\til_wr(il, HBUS_TARG_MBX_C, HBUS_TARG_MBX_C_REG_BIT_CMD_BLOCKED);\n\n\t\tif (!(flags & RXON_CARD_DISABLED)) {\n\t\t\t_il_wr(il, CSR_UCODE_DRV_GP1_CLR,\n\t\t\t       CSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED);\n\t\t\til_wr(il, HBUS_TARG_MBX_C,\n\t\t\t      HBUS_TARG_MBX_C_REG_BIT_CMD_BLOCKED);\n\t\t}\n\t}\n\n\tif (flags & CT_CARD_DISABLED)\n\t\til4965_perform_ct_kill_task(il);\n\n\tif (flags & HW_CARD_DISABLED)\n\t\tset_bit(S_RFKILL, &il->status);\n\telse\n\t\tclear_bit(S_RFKILL, &il->status);\n\n\tif (!(flags & RXON_CARD_DISABLED))\n\t\til_scan_cancel(il);\n\n\tif ((test_bit(S_RFKILL, &status) !=\n\t     test_bit(S_RFKILL, &il->status)))\n\t\twiphy_rfkill_set_hw_state(il->hw->wiphy,\n\t\t\t\t\t  test_bit(S_RFKILL, &il->status));\n\telse\n\t\twake_up(&il->wait_command_queue);\n}\n\n \nstatic void\nil4965_setup_handlers(struct il_priv *il)\n{\n\til->handlers[N_ALIVE] = il4965_hdl_alive;\n\til->handlers[N_ERROR] = il_hdl_error;\n\til->handlers[N_CHANNEL_SWITCH] = il_hdl_csa;\n\til->handlers[N_SPECTRUM_MEASUREMENT] = il_hdl_spectrum_measurement;\n\til->handlers[N_PM_SLEEP] = il_hdl_pm_sleep;\n\til->handlers[N_PM_DEBUG_STATS] = il_hdl_pm_debug_stats;\n\til->handlers[N_BEACON] = il4965_hdl_beacon;\n\n\t \n\til->handlers[C_STATS] = il4965_hdl_c_stats;\n\til->handlers[N_STATS] = il4965_hdl_stats;\n\n\til_setup_rx_scan_handlers(il);\n\n\t \n\til->handlers[N_CARD_STATE] = il4965_hdl_card_state;\n\n\til->handlers[N_MISSED_BEACONS] = il4965_hdl_missed_beacon;\n\t \n\til->handlers[N_RX_PHY] = il4965_hdl_rx_phy;\n\til->handlers[N_RX_MPDU] = il4965_hdl_rx;\n\til->handlers[N_RX] = il4965_hdl_rx;\n\t \n\til->handlers[N_COMPRESSED_BA] = il4965_hdl_compressed_ba;\n\t \n\til->handlers[C_TX] = il4965_hdl_tx;\n}\n\n \nvoid\nil4965_rx_handle(struct il_priv *il)\n{\n\tstruct il_rx_buf *rxb;\n\tstruct il_rx_pkt *pkt;\n\tstruct il_rx_queue *rxq = &il->rxq;\n\tu32 r, i;\n\tint reclaim;\n\tunsigned long flags;\n\tu8 fill_rx = 0;\n\tu32 count = 8;\n\tint total_empty;\n\n\t \n\tr = le16_to_cpu(rxq->rb_stts->closed_rb_num) & 0x0FFF;\n\ti = rxq->read;\n\n\t \n\tif (i == r)\n\t\tD_RX(\"r = %d, i = %d\\n\", r, i);\n\n\t \n\ttotal_empty = r - rxq->write_actual;\n\tif (total_empty < 0)\n\t\ttotal_empty += RX_QUEUE_SIZE;\n\n\tif (total_empty > (RX_QUEUE_SIZE / 2))\n\t\tfill_rx = 1;\n\n\twhile (i != r) {\n\t\tint len;\n\n\t\trxb = rxq->queue[i];\n\n\t\t \n\t\tBUG_ON(rxb == NULL);\n\n\t\trxq->queue[i] = NULL;\n\n\t\tdma_unmap_page(&il->pci_dev->dev, rxb->page_dma,\n\t\t\t       PAGE_SIZE << il->hw_params.rx_page_order,\n\t\t\t       DMA_FROM_DEVICE);\n\t\tpkt = rxb_addr(rxb);\n\n\t\tlen = le32_to_cpu(pkt->len_n_flags) & IL_RX_FRAME_SIZE_MSK;\n\t\tlen += sizeof(u32);\t \n\n\t\treclaim = il_need_reclaim(il, pkt);\n\n\t\t \n\t\tif (il->handlers[pkt->hdr.cmd]) {\n\t\t\tD_RX(\"r = %d, i = %d, %s, 0x%02x\\n\", r, i,\n\t\t\t     il_get_cmd_string(pkt->hdr.cmd), pkt->hdr.cmd);\n\t\t\til->isr_stats.handlers[pkt->hdr.cmd]++;\n\t\t\til->handlers[pkt->hdr.cmd] (il, rxb);\n\t\t} else {\n\t\t\t \n\t\t\tD_RX(\"r %d i %d No handler needed for %s, 0x%02x\\n\", r,\n\t\t\t     i, il_get_cmd_string(pkt->hdr.cmd), pkt->hdr.cmd);\n\t\t}\n\n\t\t \n\n\t\tif (reclaim) {\n\t\t\t \n\t\t\tif (rxb->page)\n\t\t\t\til_tx_cmd_complete(il, rxb);\n\t\t\telse\n\t\t\t\tIL_WARN(\"Claim null rxb?\\n\");\n\t\t}\n\n\t\t \n\t\tspin_lock_irqsave(&rxq->lock, flags);\n\t\tif (rxb->page != NULL) {\n\t\t\trxb->page_dma =\n\t\t\t    dma_map_page(&il->pci_dev->dev, rxb->page, 0,\n\t\t\t\t\t PAGE_SIZE << il->hw_params.rx_page_order,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\n\t\t\tif (unlikely(dma_mapping_error(&il->pci_dev->dev,\n\t\t\t\t\t\t       rxb->page_dma))) {\n\t\t\t\t__il_free_pages(il, rxb->page);\n\t\t\t\trxb->page = NULL;\n\t\t\t\tlist_add_tail(&rxb->list, &rxq->rx_used);\n\t\t\t} else {\n\t\t\t\tlist_add_tail(&rxb->list, &rxq->rx_free);\n\t\t\t\trxq->free_count++;\n\t\t\t}\n\t\t} else\n\t\t\tlist_add_tail(&rxb->list, &rxq->rx_used);\n\n\t\tspin_unlock_irqrestore(&rxq->lock, flags);\n\n\t\ti = (i + 1) & RX_QUEUE_MASK;\n\t\t \n\t\tif (fill_rx) {\n\t\t\tcount++;\n\t\t\tif (count >= 8) {\n\t\t\t\trxq->read = i;\n\t\t\t\til4965_rx_replenish_now(il);\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\trxq->read = i;\n\tif (fill_rx)\n\t\til4965_rx_replenish_now(il);\n\telse\n\t\til4965_rx_queue_restock(il);\n}\n\n \nstatic inline void\nil4965_synchronize_irq(struct il_priv *il)\n{\n\t \n\tsynchronize_irq(il->pci_dev->irq);\n\ttasklet_kill(&il->irq_tasklet);\n}\n\nstatic void\nil4965_irq_tasklet(struct tasklet_struct *t)\n{\n\tstruct il_priv *il = from_tasklet(il, t, irq_tasklet);\n\tu32 inta, handled = 0;\n\tu32 inta_fh;\n\tunsigned long flags;\n\tu32 i;\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tu32 inta_mask;\n#endif\n\n\tspin_lock_irqsave(&il->lock, flags);\n\n\t \n\tinta = _il_rd(il, CSR_INT);\n\t_il_wr(il, CSR_INT, inta);\n\n\t \n\tinta_fh = _il_rd(il, CSR_FH_INT_STATUS);\n\t_il_wr(il, CSR_FH_INT_STATUS, inta_fh);\n\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tif (il_get_debug_level(il) & IL_DL_ISR) {\n\t\t \n\t\tinta_mask = _il_rd(il, CSR_INT_MASK);\n\t\tD_ISR(\"inta 0x%08x, enabled 0x%08x, fh 0x%08x\\n\", inta,\n\t\t      inta_mask, inta_fh);\n\t}\n#endif\n\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\t \n\tif (inta_fh & CSR49_FH_INT_RX_MASK)\n\t\tinta |= CSR_INT_BIT_FH_RX;\n\tif (inta_fh & CSR49_FH_INT_TX_MASK)\n\t\tinta |= CSR_INT_BIT_FH_TX;\n\n\t \n\tif (inta & CSR_INT_BIT_HW_ERR) {\n\t\tIL_ERR(\"Hardware error detected.  Restarting.\\n\");\n\n\t\t \n\t\til_disable_interrupts(il);\n\n\t\til->isr_stats.hw++;\n\t\til_irq_handle_error(il);\n\n\t\thandled |= CSR_INT_BIT_HW_ERR;\n\n\t\treturn;\n\t}\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tif (il_get_debug_level(il) & (IL_DL_ISR)) {\n\t\t \n\t\tif (inta & CSR_INT_BIT_SCD) {\n\t\t\tD_ISR(\"Scheduler finished to transmit \"\n\t\t\t      \"the frame/frames.\\n\");\n\t\t\til->isr_stats.sch++;\n\t\t}\n\n\t\t \n\t\tif (inta & CSR_INT_BIT_ALIVE) {\n\t\t\tD_ISR(\"Alive interrupt\\n\");\n\t\t\til->isr_stats.alive++;\n\t\t}\n\t}\n#endif\n\t \n\tinta &= ~(CSR_INT_BIT_SCD | CSR_INT_BIT_ALIVE);\n\n\t \n\tif (inta & CSR_INT_BIT_RF_KILL) {\n\t\tint hw_rf_kill = 0;\n\n\t\tif (!(_il_rd(il, CSR_GP_CNTRL) & CSR_GP_CNTRL_REG_FLAG_HW_RF_KILL_SW))\n\t\t\thw_rf_kill = 1;\n\n\t\tIL_WARN(\"RF_KILL bit toggled to %s.\\n\",\n\t\t\thw_rf_kill ? \"disable radio\" : \"enable radio\");\n\n\t\til->isr_stats.rfkill++;\n\n\t\t \n\t\tif (hw_rf_kill) {\n\t\t\tset_bit(S_RFKILL, &il->status);\n\t\t} else {\n\t\t\tclear_bit(S_RFKILL, &il->status);\n\t\t\til_force_reset(il, true);\n\t\t}\n\t\twiphy_rfkill_set_hw_state(il->hw->wiphy, hw_rf_kill);\n\n\t\thandled |= CSR_INT_BIT_RF_KILL;\n\t}\n\n\t \n\tif (inta & CSR_INT_BIT_CT_KILL) {\n\t\tIL_ERR(\"Microcode CT kill error detected.\\n\");\n\t\til->isr_stats.ctkill++;\n\t\thandled |= CSR_INT_BIT_CT_KILL;\n\t}\n\n\t \n\tif (inta & CSR_INT_BIT_SW_ERR) {\n\t\tIL_ERR(\"Microcode SW error detected. \" \" Restarting 0x%X.\\n\",\n\t\t       inta);\n\t\til->isr_stats.sw++;\n\t\til_irq_handle_error(il);\n\t\thandled |= CSR_INT_BIT_SW_ERR;\n\t}\n\n\t \n\tif (inta & CSR_INT_BIT_WAKEUP) {\n\t\tD_ISR(\"Wakeup interrupt\\n\");\n\t\til_rx_queue_update_write_ptr(il, &il->rxq);\n\t\tfor (i = 0; i < il->hw_params.max_txq_num; i++)\n\t\t\til_txq_update_write_ptr(il, &il->txq[i]);\n\t\til->isr_stats.wakeup++;\n\t\thandled |= CSR_INT_BIT_WAKEUP;\n\t}\n\n\t \n\tif (inta & (CSR_INT_BIT_FH_RX | CSR_INT_BIT_SW_RX)) {\n\t\til4965_rx_handle(il);\n\t\til->isr_stats.rx++;\n\t\thandled |= (CSR_INT_BIT_FH_RX | CSR_INT_BIT_SW_RX);\n\t}\n\n\t \n\tif (inta & CSR_INT_BIT_FH_TX) {\n\t\tD_ISR(\"uCode load interrupt\\n\");\n\t\til->isr_stats.tx++;\n\t\thandled |= CSR_INT_BIT_FH_TX;\n\t\t \n\t\til->ucode_write_complete = 1;\n\t\twake_up(&il->wait_command_queue);\n\t}\n\n\tif (inta & ~handled) {\n\t\tIL_ERR(\"Unhandled INTA bits 0x%08x\\n\", inta & ~handled);\n\t\til->isr_stats.unhandled++;\n\t}\n\n\tif (inta & ~(il->inta_mask)) {\n\t\tIL_WARN(\"Disabled INTA bits 0x%08x were pending\\n\",\n\t\t\tinta & ~il->inta_mask);\n\t\tIL_WARN(\"   with FH49_INT = 0x%08x\\n\", inta_fh);\n\t}\n\n\t \n\t \n\tif (test_bit(S_INT_ENABLED, &il->status))\n\t\til_enable_interrupts(il);\n\t \n\telse if (handled & CSR_INT_BIT_RF_KILL)\n\t\til_enable_rfkill_int(il);\n\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tif (il_get_debug_level(il) & (IL_DL_ISR)) {\n\t\tinta = _il_rd(il, CSR_INT);\n\t\tinta_mask = _il_rd(il, CSR_INT_MASK);\n\t\tinta_fh = _il_rd(il, CSR_FH_INT_STATUS);\n\t\tD_ISR(\"End inta 0x%08x, enabled 0x%08x, fh 0x%08x, \"\n\t\t      \"flags 0x%08lx\\n\", inta, inta_mask, inta_fh, flags);\n\t}\n#endif\n}\n\n \n\n#ifdef CONFIG_IWLEGACY_DEBUG\n\n \nstatic ssize_t\nil4965_show_debug_level(struct device *d, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct il_priv *il = dev_get_drvdata(d);\n\treturn sprintf(buf, \"0x%08X\\n\", il_get_debug_level(il));\n}\n\nstatic ssize_t\nil4965_store_debug_level(struct device *d, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct il_priv *il = dev_get_drvdata(d);\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &val);\n\tif (ret)\n\t\tIL_ERR(\"%s is not in hex or decimal form.\\n\", buf);\n\telse\n\t\til->debug_level = val;\n\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(debug_level, 0644, il4965_show_debug_level,\n\t\t   il4965_store_debug_level);\n\n#endif  \n\nstatic ssize_t\nil4965_show_temperature(struct device *d, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct il_priv *il = dev_get_drvdata(d);\n\n\tif (!il_is_alive(il))\n\t\treturn -EAGAIN;\n\n\treturn sprintf(buf, \"%d\\n\", il->temperature);\n}\n\nstatic DEVICE_ATTR(temperature, 0444, il4965_show_temperature, NULL);\n\nstatic ssize_t\nil4965_show_tx_power(struct device *d, struct device_attribute *attr, char *buf)\n{\n\tstruct il_priv *il = dev_get_drvdata(d);\n\n\tif (!il_is_ready_rf(il))\n\t\treturn sprintf(buf, \"off\\n\");\n\telse\n\t\treturn sprintf(buf, \"%d\\n\", il->tx_power_user_lmt);\n}\n\nstatic ssize_t\nil4965_store_tx_power(struct device *d, struct device_attribute *attr,\n\t\t      const char *buf, size_t count)\n{\n\tstruct il_priv *il = dev_get_drvdata(d);\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret)\n\t\tIL_INFO(\"%s is not in decimal form.\\n\", buf);\n\telse {\n\t\tret = il_set_tx_power(il, val, false);\n\t\tif (ret)\n\t\t\tIL_ERR(\"failed setting tx power (0x%08x).\\n\", ret);\n\t\telse\n\t\t\tret = count;\n\t}\n\treturn ret;\n}\n\nstatic DEVICE_ATTR(tx_power, 0644, il4965_show_tx_power,\n\t\t   il4965_store_tx_power);\n\nstatic struct attribute *il_sysfs_entries[] = {\n\t&dev_attr_temperature.attr,\n\t&dev_attr_tx_power.attr,\n#ifdef CONFIG_IWLEGACY_DEBUG\n\t&dev_attr_debug_level.attr,\n#endif\n\tNULL\n};\n\nstatic const struct attribute_group il_attribute_group = {\n\t.name = NULL,\t\t \n\t.attrs = il_sysfs_entries,\n};\n\n \n\nstatic void\nil4965_dealloc_ucode_pci(struct il_priv *il)\n{\n\til_free_fw_desc(il->pci_dev, &il->ucode_code);\n\til_free_fw_desc(il->pci_dev, &il->ucode_data);\n\til_free_fw_desc(il->pci_dev, &il->ucode_data_backup);\n\til_free_fw_desc(il->pci_dev, &il->ucode_init);\n\til_free_fw_desc(il->pci_dev, &il->ucode_init_data);\n\til_free_fw_desc(il->pci_dev, &il->ucode_boot);\n}\n\nstatic void\nil4965_nic_start(struct il_priv *il)\n{\n\t \n\t_il_wr(il, CSR_RESET, 0);\n}\n\nstatic void il4965_ucode_callback(const struct firmware *ucode_raw,\n\t\t\t\t  void *context);\nstatic int il4965_mac_setup_register(struct il_priv *il, u32 max_probe_length);\n\nstatic int __must_check\nil4965_request_firmware(struct il_priv *il, bool first)\n{\n\tconst char *name_pre = il->cfg->fw_name_pre;\n\tchar tag[8];\n\n\tif (first) {\n\t\til->fw_idx = il->cfg->ucode_api_max;\n\t\tsprintf(tag, \"%d\", il->fw_idx);\n\t} else {\n\t\til->fw_idx--;\n\t\tsprintf(tag, \"%d\", il->fw_idx);\n\t}\n\n\tif (il->fw_idx < il->cfg->ucode_api_min) {\n\t\tIL_ERR(\"no suitable firmware found!\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tsprintf(il->firmware_name, \"%s%s%s\", name_pre, tag, \".ucode\");\n\n\tD_INFO(\"attempting to load firmware '%s'\\n\", il->firmware_name);\n\n\treturn request_firmware_nowait(THIS_MODULE, 1, il->firmware_name,\n\t\t\t\t       &il->pci_dev->dev, GFP_KERNEL, il,\n\t\t\t\t       il4965_ucode_callback);\n}\n\nstruct il4965_firmware_pieces {\n\tconst void *inst, *data, *init, *init_data, *boot;\n\tsize_t inst_size, data_size, init_size, init_data_size, boot_size;\n};\n\nstatic int\nil4965_load_firmware(struct il_priv *il, const struct firmware *ucode_raw,\n\t\t     struct il4965_firmware_pieces *pieces)\n{\n\tstruct il_ucode_header *ucode = (void *)ucode_raw->data;\n\tu32 api_ver, hdr_size;\n\tconst u8 *src;\n\n\til->ucode_ver = le32_to_cpu(ucode->ver);\n\tapi_ver = IL_UCODE_API(il->ucode_ver);\n\n\tswitch (api_ver) {\n\tdefault:\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\t\thdr_size = 24;\n\t\tif (ucode_raw->size < hdr_size) {\n\t\t\tIL_ERR(\"File size too small!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpieces->inst_size = le32_to_cpu(ucode->v1.inst_size);\n\t\tpieces->data_size = le32_to_cpu(ucode->v1.data_size);\n\t\tpieces->init_size = le32_to_cpu(ucode->v1.init_size);\n\t\tpieces->init_data_size = le32_to_cpu(ucode->v1.init_data_size);\n\t\tpieces->boot_size = le32_to_cpu(ucode->v1.boot_size);\n\t\tsrc = ucode->v1.data;\n\t\tbreak;\n\t}\n\n\t \n\tif (ucode_raw->size !=\n\t    hdr_size + pieces->inst_size + pieces->data_size +\n\t    pieces->init_size + pieces->init_data_size + pieces->boot_size) {\n\n\t\tIL_ERR(\"uCode file size %d does not match expected size\\n\",\n\t\t       (int)ucode_raw->size);\n\t\treturn -EINVAL;\n\t}\n\n\tpieces->inst = src;\n\tsrc += pieces->inst_size;\n\tpieces->data = src;\n\tsrc += pieces->data_size;\n\tpieces->init = src;\n\tsrc += pieces->init_size;\n\tpieces->init_data = src;\n\tsrc += pieces->init_data_size;\n\tpieces->boot = src;\n\tsrc += pieces->boot_size;\n\n\treturn 0;\n}\n\n \nstatic void\nil4965_ucode_callback(const struct firmware *ucode_raw, void *context)\n{\n\tstruct il_priv *il = context;\n\tint err;\n\tstruct il4965_firmware_pieces pieces;\n\tconst unsigned int api_max = il->cfg->ucode_api_max;\n\tconst unsigned int api_min = il->cfg->ucode_api_min;\n\tu32 api_ver;\n\n\tu32 max_probe_length = 200;\n\tu32 standard_phy_calibration_size =\n\t    IL_DEFAULT_STANDARD_PHY_CALIBRATE_TBL_SIZE;\n\n\tmemset(&pieces, 0, sizeof(pieces));\n\n\tif (!ucode_raw) {\n\t\tif (il->fw_idx <= il->cfg->ucode_api_max)\n\t\t\tIL_ERR(\"request for firmware file '%s' failed.\\n\",\n\t\t\t       il->firmware_name);\n\t\tgoto try_again;\n\t}\n\n\tD_INFO(\"Loaded firmware file '%s' (%zd bytes).\\n\", il->firmware_name,\n\t       ucode_raw->size);\n\n\t \n\tif (ucode_raw->size < 4) {\n\t\tIL_ERR(\"File size way too small!\\n\");\n\t\tgoto try_again;\n\t}\n\n\t \n\terr = il4965_load_firmware(il, ucode_raw, &pieces);\n\n\tif (err)\n\t\tgoto try_again;\n\n\tapi_ver = IL_UCODE_API(il->ucode_ver);\n\n\t \n\tif (api_ver < api_min || api_ver > api_max) {\n\t\tIL_ERR(\"Driver unable to support your firmware API. \"\n\t\t       \"Driver supports v%u, firmware is v%u.\\n\", api_max,\n\t\t       api_ver);\n\t\tgoto try_again;\n\t}\n\n\tif (api_ver != api_max)\n\t\tIL_ERR(\"Firmware has old API version. Expected v%u, \"\n\t\t       \"got v%u. New firmware can be obtained \"\n\t\t       \"from http://www.intellinuxwireless.org.\\n\", api_max,\n\t\t       api_ver);\n\n\tIL_INFO(\"loaded firmware version %u.%u.%u.%u\\n\",\n\t\tIL_UCODE_MAJOR(il->ucode_ver), IL_UCODE_MINOR(il->ucode_ver),\n\t\tIL_UCODE_API(il->ucode_ver), IL_UCODE_SERIAL(il->ucode_ver));\n\n\tsnprintf(il->hw->wiphy->fw_version, sizeof(il->hw->wiphy->fw_version),\n\t\t \"%u.%u.%u.%u\", IL_UCODE_MAJOR(il->ucode_ver),\n\t\t IL_UCODE_MINOR(il->ucode_ver), IL_UCODE_API(il->ucode_ver),\n\t\t IL_UCODE_SERIAL(il->ucode_ver));\n\n\t \n\n\tD_INFO(\"f/w package hdr ucode version raw = 0x%x\\n\", il->ucode_ver);\n\tD_INFO(\"f/w package hdr runtime inst size = %zd\\n\", pieces.inst_size);\n\tD_INFO(\"f/w package hdr runtime data size = %zd\\n\", pieces.data_size);\n\tD_INFO(\"f/w package hdr init inst size = %zd\\n\", pieces.init_size);\n\tD_INFO(\"f/w package hdr init data size = %zd\\n\", pieces.init_data_size);\n\tD_INFO(\"f/w package hdr boot inst size = %zd\\n\", pieces.boot_size);\n\n\t \n\tif (pieces.inst_size > il->hw_params.max_inst_size) {\n\t\tIL_ERR(\"uCode instr len %zd too large to fit in\\n\",\n\t\t       pieces.inst_size);\n\t\tgoto try_again;\n\t}\n\n\tif (pieces.data_size > il->hw_params.max_data_size) {\n\t\tIL_ERR(\"uCode data len %zd too large to fit in\\n\",\n\t\t       pieces.data_size);\n\t\tgoto try_again;\n\t}\n\n\tif (pieces.init_size > il->hw_params.max_inst_size) {\n\t\tIL_ERR(\"uCode init instr len %zd too large to fit in\\n\",\n\t\t       pieces.init_size);\n\t\tgoto try_again;\n\t}\n\n\tif (pieces.init_data_size > il->hw_params.max_data_size) {\n\t\tIL_ERR(\"uCode init data len %zd too large to fit in\\n\",\n\t\t       pieces.init_data_size);\n\t\tgoto try_again;\n\t}\n\n\tif (pieces.boot_size > il->hw_params.max_bsm_size) {\n\t\tIL_ERR(\"uCode boot instr len %zd too large to fit in\\n\",\n\t\t       pieces.boot_size);\n\t\tgoto try_again;\n\t}\n\n\t \n\n\t \n\til->ucode_code.len = pieces.inst_size;\n\til_alloc_fw_desc(il->pci_dev, &il->ucode_code);\n\n\til->ucode_data.len = pieces.data_size;\n\til_alloc_fw_desc(il->pci_dev, &il->ucode_data);\n\n\til->ucode_data_backup.len = pieces.data_size;\n\til_alloc_fw_desc(il->pci_dev, &il->ucode_data_backup);\n\n\tif (!il->ucode_code.v_addr || !il->ucode_data.v_addr ||\n\t    !il->ucode_data_backup.v_addr)\n\t\tgoto err_pci_alloc;\n\n\t \n\tif (pieces.init_size && pieces.init_data_size) {\n\t\til->ucode_init.len = pieces.init_size;\n\t\til_alloc_fw_desc(il->pci_dev, &il->ucode_init);\n\n\t\til->ucode_init_data.len = pieces.init_data_size;\n\t\til_alloc_fw_desc(il->pci_dev, &il->ucode_init_data);\n\n\t\tif (!il->ucode_init.v_addr || !il->ucode_init_data.v_addr)\n\t\t\tgoto err_pci_alloc;\n\t}\n\n\t \n\tif (pieces.boot_size) {\n\t\til->ucode_boot.len = pieces.boot_size;\n\t\til_alloc_fw_desc(il->pci_dev, &il->ucode_boot);\n\n\t\tif (!il->ucode_boot.v_addr)\n\t\t\tgoto err_pci_alloc;\n\t}\n\n\t \n\n\til->sta_key_max_num = STA_KEY_MAX_NUM;\n\n\t \n\n\t \n\tD_INFO(\"Copying (but not loading) uCode instr len %zd\\n\",\n\t       pieces.inst_size);\n\tmemcpy(il->ucode_code.v_addr, pieces.inst, pieces.inst_size);\n\n\tD_INFO(\"uCode instr buf vaddr = 0x%p, paddr = 0x%08x\\n\",\n\t       il->ucode_code.v_addr, (u32) il->ucode_code.p_addr);\n\n\t \n\tD_INFO(\"Copying (but not loading) uCode data len %zd\\n\",\n\t       pieces.data_size);\n\tmemcpy(il->ucode_data.v_addr, pieces.data, pieces.data_size);\n\tmemcpy(il->ucode_data_backup.v_addr, pieces.data, pieces.data_size);\n\n\t \n\tif (pieces.init_size) {\n\t\tD_INFO(\"Copying (but not loading) init instr len %zd\\n\",\n\t\t       pieces.init_size);\n\t\tmemcpy(il->ucode_init.v_addr, pieces.init, pieces.init_size);\n\t}\n\n\t \n\tif (pieces.init_data_size) {\n\t\tD_INFO(\"Copying (but not loading) init data len %zd\\n\",\n\t\t       pieces.init_data_size);\n\t\tmemcpy(il->ucode_init_data.v_addr, pieces.init_data,\n\t\t       pieces.init_data_size);\n\t}\n\n\t \n\tD_INFO(\"Copying (but not loading) boot instr len %zd\\n\",\n\t       pieces.boot_size);\n\tmemcpy(il->ucode_boot.v_addr, pieces.boot, pieces.boot_size);\n\n\t \n\til->_4965.phy_calib_chain_noise_reset_cmd =\n\t    standard_phy_calibration_size;\n\til->_4965.phy_calib_chain_noise_gain_cmd =\n\t    standard_phy_calibration_size + 1;\n\n\t \n\terr = il4965_mac_setup_register(il, max_probe_length);\n\tif (err)\n\t\tgoto out_unbind;\n\n\til_dbgfs_register(il, DRV_NAME);\n\n\terr = sysfs_create_group(&il->pci_dev->dev.kobj, &il_attribute_group);\n\tif (err) {\n\t\tIL_ERR(\"failed to create sysfs device attributes\\n\");\n\t\tgoto out_unbind;\n\t}\n\n\t \n\trelease_firmware(ucode_raw);\n\tcomplete(&il->_4965.firmware_loading_complete);\n\treturn;\n\ntry_again:\n\t \n\tif (il4965_request_firmware(il, false))\n\t\tgoto out_unbind;\n\trelease_firmware(ucode_raw);\n\treturn;\n\nerr_pci_alloc:\n\tIL_ERR(\"failed to allocate pci memory\\n\");\n\til4965_dealloc_ucode_pci(il);\nout_unbind:\n\tcomplete(&il->_4965.firmware_loading_complete);\n\tdevice_release_driver(&il->pci_dev->dev);\n\trelease_firmware(ucode_raw);\n}\n\nstatic const char *const desc_lookup_text[] = {\n\t\"OK\",\n\t\"FAIL\",\n\t\"BAD_PARAM\",\n\t\"BAD_CHECKSUM\",\n\t\"NMI_INTERRUPT_WDG\",\n\t\"SYSASSERT\",\n\t\"FATAL_ERROR\",\n\t\"BAD_COMMAND\",\n\t\"HW_ERROR_TUNE_LOCK\",\n\t\"HW_ERROR_TEMPERATURE\",\n\t\"ILLEGAL_CHAN_FREQ\",\n\t\"VCC_NOT_STBL\",\n\t\"FH49_ERROR\",\n\t\"NMI_INTERRUPT_HOST\",\n\t\"NMI_INTERRUPT_ACTION_PT\",\n\t\"NMI_INTERRUPT_UNKNOWN\",\n\t\"UCODE_VERSION_MISMATCH\",\n\t\"HW_ERROR_ABS_LOCK\",\n\t\"HW_ERROR_CAL_LOCK_FAIL\",\n\t\"NMI_INTERRUPT_INST_ACTION_PT\",\n\t\"NMI_INTERRUPT_DATA_ACTION_PT\",\n\t\"NMI_TRM_HW_ER\",\n\t\"NMI_INTERRUPT_TRM\",\n\t\"NMI_INTERRUPT_BREAK_POINT\",\n\t\"DEBUG_0\",\n\t\"DEBUG_1\",\n\t\"DEBUG_2\",\n\t\"DEBUG_3\",\n};\n\nstatic struct {\n\tchar *name;\n\tu8 num;\n} advanced_lookup[] = {\n\t{\n\t\"NMI_INTERRUPT_WDG\", 0x34}, {\n\t\"SYSASSERT\", 0x35}, {\n\t\"UCODE_VERSION_MISMATCH\", 0x37}, {\n\t\"BAD_COMMAND\", 0x38}, {\n\t\"NMI_INTERRUPT_DATA_ACTION_PT\", 0x3C}, {\n\t\"FATAL_ERROR\", 0x3D}, {\n\t\"NMI_TRM_HW_ERR\", 0x46}, {\n\t\"NMI_INTERRUPT_TRM\", 0x4C}, {\n\t\"NMI_INTERRUPT_BREAK_POINT\", 0x54}, {\n\t\"NMI_INTERRUPT_WDG_RXF_FULL\", 0x5C}, {\n\t\"NMI_INTERRUPT_WDG_NO_RBD_RXF_FULL\", 0x64}, {\n\t\"NMI_INTERRUPT_HOST\", 0x66}, {\n\t\"NMI_INTERRUPT_ACTION_PT\", 0x7C}, {\n\t\"NMI_INTERRUPT_UNKNOWN\", 0x84}, {\n\t\"NMI_INTERRUPT_INST_ACTION_PT\", 0x86}, {\n\"ADVANCED_SYSASSERT\", 0},};\n\nstatic const char *\nil4965_desc_lookup(u32 num)\n{\n\tint i;\n\tint max = ARRAY_SIZE(desc_lookup_text);\n\n\tif (num < max)\n\t\treturn desc_lookup_text[num];\n\n\tmax = ARRAY_SIZE(advanced_lookup) - 1;\n\tfor (i = 0; i < max; i++) {\n\t\tif (advanced_lookup[i].num == num)\n\t\t\tbreak;\n\t}\n\treturn advanced_lookup[i].name;\n}\n\n#define ERROR_START_OFFSET  (1 * sizeof(u32))\n#define ERROR_ELEM_SIZE     (7 * sizeof(u32))\n\nvoid\nil4965_dump_nic_error_log(struct il_priv *il)\n{\n\tu32 data2, line;\n\tu32 desc, time, count, base, data1;\n\tu32 blink1, blink2, ilink1, ilink2;\n\tu32 pc, hcmd;\n\n\tif (il->ucode_type == UCODE_INIT)\n\t\tbase = le32_to_cpu(il->card_alive_init.error_event_table_ptr);\n\telse\n\t\tbase = le32_to_cpu(il->card_alive.error_event_table_ptr);\n\n\tif (!il->ops->is_valid_rtc_data_addr(base)) {\n\t\tIL_ERR(\"Not valid error log pointer 0x%08X for %s uCode\\n\",\n\t\t       base, (il->ucode_type == UCODE_INIT) ? \"Init\" : \"RT\");\n\t\treturn;\n\t}\n\n\tcount = il_read_targ_mem(il, base);\n\n\tif (ERROR_START_OFFSET <= count * ERROR_ELEM_SIZE) {\n\t\tIL_ERR(\"Start IWL Error Log Dump:\\n\");\n\t\tIL_ERR(\"Status: 0x%08lX, count: %d\\n\", il->status, count);\n\t}\n\n\tdesc = il_read_targ_mem(il, base + 1 * sizeof(u32));\n\til->isr_stats.err_code = desc;\n\tpc = il_read_targ_mem(il, base + 2 * sizeof(u32));\n\tblink1 = il_read_targ_mem(il, base + 3 * sizeof(u32));\n\tblink2 = il_read_targ_mem(il, base + 4 * sizeof(u32));\n\tilink1 = il_read_targ_mem(il, base + 5 * sizeof(u32));\n\tilink2 = il_read_targ_mem(il, base + 6 * sizeof(u32));\n\tdata1 = il_read_targ_mem(il, base + 7 * sizeof(u32));\n\tdata2 = il_read_targ_mem(il, base + 8 * sizeof(u32));\n\tline = il_read_targ_mem(il, base + 9 * sizeof(u32));\n\ttime = il_read_targ_mem(il, base + 11 * sizeof(u32));\n\thcmd = il_read_targ_mem(il, base + 22 * sizeof(u32));\n\n\tIL_ERR(\"Desc                                  Time       \"\n\t       \"data1      data2      line\\n\");\n\tIL_ERR(\"%-28s (0x%04X) %010u 0x%08X 0x%08X %u\\n\",\n\t       il4965_desc_lookup(desc), desc, time, data1, data2, line);\n\tIL_ERR(\"pc      blink1  blink2  ilink1  ilink2  hcmd\\n\");\n\tIL_ERR(\"0x%05X 0x%05X 0x%05X 0x%05X 0x%05X 0x%05X\\n\", pc, blink1,\n\t       blink2, ilink1, ilink2, hcmd);\n}\n\nstatic void\nil4965_rf_kill_ct_config(struct il_priv *il)\n{\n\tstruct il_ct_kill_config cmd;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&il->lock, flags);\n\t_il_wr(il, CSR_UCODE_DRV_GP1_CLR,\n\t       CSR_UCODE_DRV_GP1_REG_BIT_CT_KILL_EXIT);\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\tcmd.critical_temperature_R =\n\t    cpu_to_le32(il->hw_params.ct_kill_threshold);\n\n\tret = il_send_cmd_pdu(il, C_CT_KILL_CONFIG, sizeof(cmd), &cmd);\n\tif (ret)\n\t\tIL_ERR(\"C_CT_KILL_CONFIG failed\\n\");\n\telse\n\t\tD_INFO(\"C_CT_KILL_CONFIG \" \"succeeded, \"\n\t\t       \"critical temperature is %d\\n\",\n\t\t       il->hw_params.ct_kill_threshold);\n}\n\nstatic const s8 default_queue_to_tx_fifo[] = {\n\tIL_TX_FIFO_VO,\n\tIL_TX_FIFO_VI,\n\tIL_TX_FIFO_BE,\n\tIL_TX_FIFO_BK,\n\tIL49_CMD_FIFO_NUM,\n\tIL_TX_FIFO_UNUSED,\n\tIL_TX_FIFO_UNUSED,\n};\n\n#define IL_MASK(lo, hi) ((1 << (hi)) | ((1 << (hi)) - (1 << (lo))))\n\nstatic int\nil4965_alive_notify(struct il_priv *il)\n{\n\tu32 a;\n\tunsigned long flags;\n\tint i, chan;\n\tu32 reg_val;\n\n\tspin_lock_irqsave(&il->lock, flags);\n\n\t \n\til->scd_base_addr = il_rd_prph(il, IL49_SCD_SRAM_BASE_ADDR);\n\ta = il->scd_base_addr + IL49_SCD_CONTEXT_DATA_OFFSET;\n\tfor (; a < il->scd_base_addr + IL49_SCD_TX_STTS_BITMAP_OFFSET; a += 4)\n\t\til_write_targ_mem(il, a, 0);\n\tfor (; a < il->scd_base_addr + IL49_SCD_TRANSLATE_TBL_OFFSET; a += 4)\n\t\til_write_targ_mem(il, a, 0);\n\tfor (;\n\t     a <\n\t     il->scd_base_addr +\n\t     IL49_SCD_TRANSLATE_TBL_OFFSET_QUEUE(il->hw_params.max_txq_num);\n\t     a += 4)\n\t\til_write_targ_mem(il, a, 0);\n\n\t \n\til_wr_prph(il, IL49_SCD_DRAM_BASE_ADDR, il->scd_bc_tbls.dma >> 10);\n\n\t \n\tfor (chan = 0; chan < FH49_TCSR_CHNL_NUM; chan++)\n\t\til_wr(il, FH49_TCSR_CHNL_TX_CONFIG_REG(chan),\n\t\t      FH49_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_ENABLE |\n\t\t      FH49_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_ENABLE);\n\n\t \n\treg_val = il_rd(il, FH49_TX_CHICKEN_BITS_REG);\n\til_wr(il, FH49_TX_CHICKEN_BITS_REG,\n\t      reg_val | FH49_TX_CHICKEN_BITS_SCD_AUTO_RETRY_EN);\n\n\t \n\til_wr_prph(il, IL49_SCD_QUEUECHAIN_SEL, 0);\n\n\t \n\tfor (i = 0; i < il->hw_params.max_txq_num; i++) {\n\n\t\t \n\t\til_wr_prph(il, IL49_SCD_QUEUE_RDPTR(i), 0);\n\t\til_wr(il, HBUS_TARG_WRPTR, 0 | (i << 8));\n\n\t\t \n\t\til_write_targ_mem(il,\n\t\t\t\t  il->scd_base_addr +\n\t\t\t\t  IL49_SCD_CONTEXT_QUEUE_OFFSET(i),\n\t\t\t\t  (SCD_WIN_SIZE <<\n\t\t\t\t   IL49_SCD_QUEUE_CTX_REG1_WIN_SIZE_POS) &\n\t\t\t\t  IL49_SCD_QUEUE_CTX_REG1_WIN_SIZE_MSK);\n\n\t\t \n\t\til_write_targ_mem(il,\n\t\t\t\t  il->scd_base_addr +\n\t\t\t\t  IL49_SCD_CONTEXT_QUEUE_OFFSET(i) +\n\t\t\t\t  sizeof(u32),\n\t\t\t\t  (SCD_FRAME_LIMIT <<\n\t\t\t\t   IL49_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_POS) &\n\t\t\t\t  IL49_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_MSK);\n\n\t}\n\til_wr_prph(il, IL49_SCD_INTERRUPT_MASK,\n\t\t   (1 << il->hw_params.max_txq_num) - 1);\n\n\t \n\til4965_txq_set_sched(il, IL_MASK(0, 6));\n\n\til4965_set_wr_ptrs(il, IL_DEFAULT_CMD_QUEUE_NUM, 0);\n\n\t \n\tmemset(&il->queue_stopped[0], 0, sizeof(il->queue_stopped));\n\tfor (i = 0; i < 4; i++)\n\t\tatomic_set(&il->queue_stop_count[i], 0);\n\n\t \n\til->txq_ctx_active_msk = 0;\n\t \n\tBUILD_BUG_ON(ARRAY_SIZE(default_queue_to_tx_fifo) != 7);\n\n\tfor (i = 0; i < ARRAY_SIZE(default_queue_to_tx_fifo); i++) {\n\t\tint ac = default_queue_to_tx_fifo[i];\n\n\t\til_txq_ctx_activate(il, i);\n\n\t\tif (ac == IL_TX_FIFO_UNUSED)\n\t\t\tcontinue;\n\n\t\til4965_tx_queue_set_status(il, &il->txq[i], ac, 0);\n\t}\n\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic void\nil4965_alive_start(struct il_priv *il)\n{\n\tint ret = 0;\n\n\tD_INFO(\"Runtime Alive received.\\n\");\n\n\tif (il->card_alive.is_valid != UCODE_VALID_OK) {\n\t\t \n\t\tD_INFO(\"Alive failed.\\n\");\n\t\tgoto restart;\n\t}\n\n\t \n\tif (il4965_verify_ucode(il)) {\n\t\t \n\t\tD_INFO(\"Bad runtime uCode load.\\n\");\n\t\tgoto restart;\n\t}\n\n\tret = il4965_alive_notify(il);\n\tif (ret) {\n\t\tIL_WARN(\"Could not complete ALIVE transition [ntf]: %d\\n\", ret);\n\t\tgoto restart;\n\t}\n\n\t \n\tset_bit(S_ALIVE, &il->status);\n\n\t \n\til_setup_watchdog(il);\n\n\tif (il_is_rfkill(il))\n\t\treturn;\n\n\tieee80211_wake_queues(il->hw);\n\n\til->active_rate = RATES_MASK;\n\n\til_power_update_mode(il, true);\n\tD_INFO(\"Updated power mode\\n\");\n\n\tif (il_is_associated(il)) {\n\t\tstruct il_rxon_cmd *active_rxon =\n\t\t    (struct il_rxon_cmd *)&il->active;\n\t\t \n\t\til->staging.filter_flags |= RXON_FILTER_ASSOC_MSK;\n\t\tactive_rxon->filter_flags &= ~RXON_FILTER_ASSOC_MSK;\n\t} else {\n\t\t \n\t\til_connection_init_rx_config(il);\n\n\t\tif (il->ops->set_rxon_chain)\n\t\t\til->ops->set_rxon_chain(il);\n\t}\n\n\t \n\til_send_bt_config(il);\n\n\til4965_reset_run_time_calib(il);\n\n\tset_bit(S_READY, &il->status);\n\n\t \n\til_commit_rxon(il);\n\n\t \n\til4965_rf_kill_ct_config(il);\n\n\tD_INFO(\"ALIVE processing complete.\\n\");\n\twake_up(&il->wait_command_queue);\n\n\treturn;\n\nrestart:\n\tqueue_work(il->workqueue, &il->restart);\n}\n\nstatic void il4965_cancel_deferred_work(struct il_priv *il);\n\nstatic void\n__il4965_down(struct il_priv *il)\n{\n\tunsigned long flags;\n\tint exit_pending;\n\n\tD_INFO(DRV_NAME \" is going down\\n\");\n\n\til_scan_cancel_timeout(il, 200);\n\n\texit_pending = test_and_set_bit(S_EXIT_PENDING, &il->status);\n\n\t \n\tdel_timer_sync(&il->watchdog);\n\n\til_clear_ucode_stations(il);\n\n\t \n\tspin_lock_irq(&il->sta_lock);\n\t \n\tmemset(il->_4965.wep_keys, 0, sizeof(il->_4965.wep_keys));\n\til->_4965.key_mapping_keys = 0;\n\tspin_unlock_irq(&il->sta_lock);\n\n\til_dealloc_bcast_stations(il);\n\til_clear_driver_stations(il);\n\n\t \n\twake_up_all(&il->wait_command_queue);\n\n\t \n\tif (!exit_pending)\n\t\tclear_bit(S_EXIT_PENDING, &il->status);\n\n\t \n\t_il_wr(il, CSR_RESET, CSR_RESET_REG_FLAG_NEVO_RESET);\n\n\t \n\tspin_lock_irqsave(&il->lock, flags);\n\til_disable_interrupts(il);\n\tspin_unlock_irqrestore(&il->lock, flags);\n\til4965_synchronize_irq(il);\n\n\tif (il->mac80211_registered)\n\t\tieee80211_stop_queues(il->hw);\n\n\t \n\tif (!il_is_init(il)) {\n\t\til->status =\n\t\t    test_bit(S_RFKILL, &il->status) << S_RFKILL |\n\t\t    test_bit(S_GEO_CONFIGURED, &il->status) << S_GEO_CONFIGURED |\n\t\t    test_bit(S_EXIT_PENDING, &il->status) << S_EXIT_PENDING;\n\t\tgoto exit;\n\t}\n\n\t \n\til->status &=\n\t    test_bit(S_RFKILL, &il->status) << S_RFKILL |\n\t    test_bit(S_GEO_CONFIGURED, &il->status) << S_GEO_CONFIGURED |\n\t    test_bit(S_FW_ERROR, &il->status) << S_FW_ERROR |\n\t    test_bit(S_EXIT_PENDING, &il->status) << S_EXIT_PENDING;\n\n\t \n\tspin_lock_irq(&il->reg_lock);\n\t \n\n\til4965_txq_ctx_stop(il);\n\til4965_rxq_stop(il);\n\t \n\t_il_wr_prph(il, APMG_CLK_DIS_REG, APMG_CLK_VAL_DMA_CLK_RQT);\n\tudelay(5);\n\t \n\t_il_clear_bit(il, CSR_GP_CNTRL, CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);\n\t \n\t_il_apm_stop(il);\n\n\tspin_unlock_irq(&il->reg_lock);\n\n\til4965_txq_ctx_unmap(il);\nexit:\n\tmemset(&il->card_alive, 0, sizeof(struct il_alive_resp));\n\n\tdev_kfree_skb(il->beacon_skb);\n\til->beacon_skb = NULL;\n\n\t \n\til4965_clear_free_frames(il);\n}\n\nstatic void\nil4965_down(struct il_priv *il)\n{\n\tmutex_lock(&il->mutex);\n\t__il4965_down(il);\n\tmutex_unlock(&il->mutex);\n\n\til4965_cancel_deferred_work(il);\n}\n\n\nstatic void\nil4965_set_hw_ready(struct il_priv *il)\n{\n\tint ret;\n\n\til_set_bit(il, CSR_HW_IF_CONFIG_REG,\n\t\t   CSR_HW_IF_CONFIG_REG_BIT_NIC_READY);\n\n\t \n\tret = _il_poll_bit(il, CSR_HW_IF_CONFIG_REG,\n\t\t\t   CSR_HW_IF_CONFIG_REG_BIT_NIC_READY,\n\t\t\t   CSR_HW_IF_CONFIG_REG_BIT_NIC_READY,\n\t\t\t   100);\n\tif (ret >= 0)\n\t\til->hw_ready = true;\n\n\tD_INFO(\"hardware %s ready\\n\", (il->hw_ready) ? \"\" : \"not\");\n}\n\nstatic void\nil4965_prepare_card_hw(struct il_priv *il)\n{\n\tint ret;\n\n\til->hw_ready = false;\n\n\til4965_set_hw_ready(il);\n\tif (il->hw_ready)\n\t\treturn;\n\n\t \n\til_set_bit(il, CSR_HW_IF_CONFIG_REG, CSR_HW_IF_CONFIG_REG_PREPARE);\n\n\tret =\n\t    _il_poll_bit(il, CSR_HW_IF_CONFIG_REG,\n\t\t\t ~CSR_HW_IF_CONFIG_REG_BIT_NIC_PREPARE_DONE,\n\t\t\t CSR_HW_IF_CONFIG_REG_BIT_NIC_PREPARE_DONE, 150000);\n\n\t \n\tif (ret != -ETIMEDOUT)\n\t\til4965_set_hw_ready(il);\n}\n\n#define MAX_HW_RESTARTS 5\n\nstatic int\n__il4965_up(struct il_priv *il)\n{\n\tint i;\n\tint ret;\n\n\tif (test_bit(S_EXIT_PENDING, &il->status)) {\n\t\tIL_WARN(\"Exit pending; will not bring the NIC up\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (!il->ucode_data_backup.v_addr || !il->ucode_data.v_addr) {\n\t\tIL_ERR(\"ucode not available for device bringup\\n\");\n\t\treturn -EIO;\n\t}\n\n\tret = il4965_alloc_bcast_station(il);\n\tif (ret) {\n\t\til_dealloc_bcast_stations(il);\n\t\treturn ret;\n\t}\n\n\til4965_prepare_card_hw(il);\n\tif (!il->hw_ready) {\n\t\til_dealloc_bcast_stations(il);\n\t\tIL_ERR(\"HW not ready\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (_il_rd(il, CSR_GP_CNTRL) & CSR_GP_CNTRL_REG_FLAG_HW_RF_KILL_SW)\n\t\tclear_bit(S_RFKILL, &il->status);\n\telse {\n\t\tset_bit(S_RFKILL, &il->status);\n\t\twiphy_rfkill_set_hw_state(il->hw->wiphy, true);\n\n\t\til_dealloc_bcast_stations(il);\n\t\til_enable_rfkill_int(il);\n\t\tIL_WARN(\"Radio disabled by HW RF Kill switch\\n\");\n\t\treturn 0;\n\t}\n\n\t_il_wr(il, CSR_INT, 0xFFFFFFFF);\n\n\t \n\til->cmd_queue = IL_DEFAULT_CMD_QUEUE_NUM;\n\n\tret = il4965_hw_nic_init(il);\n\tif (ret) {\n\t\tIL_ERR(\"Unable to init nic\\n\");\n\t\til_dealloc_bcast_stations(il);\n\t\treturn ret;\n\t}\n\n\t \n\t_il_wr(il, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_SW_BIT_RFKILL);\n\t_il_wr(il, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED);\n\n\t \n\t_il_wr(il, CSR_INT, 0xFFFFFFFF);\n\til_enable_interrupts(il);\n\n\t \n\t_il_wr(il, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_SW_BIT_RFKILL);\n\t_il_wr(il, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_SW_BIT_RFKILL);\n\n\t \n\tmemcpy(il->ucode_data_backup.v_addr, il->ucode_data.v_addr,\n\t       il->ucode_data.len);\n\n\tfor (i = 0; i < MAX_HW_RESTARTS; i++) {\n\n\t\t \n\t\tret = il->ops->load_ucode(il);\n\n\t\tif (ret) {\n\t\t\tIL_ERR(\"Unable to set up bootstrap uCode: %d\\n\", ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\til4965_nic_start(il);\n\n\t\tD_INFO(DRV_NAME \" is coming up\\n\");\n\n\t\treturn 0;\n\t}\n\n\tset_bit(S_EXIT_PENDING, &il->status);\n\t__il4965_down(il);\n\tclear_bit(S_EXIT_PENDING, &il->status);\n\n\t \n\tIL_ERR(\"Unable to initialize device after %d attempts.\\n\", i);\n\treturn -EIO;\n}\n\n \n\nstatic void\nil4965_bg_init_alive_start(struct work_struct *data)\n{\n\tstruct il_priv *il =\n\t    container_of(data, struct il_priv, init_alive_start.work);\n\n\tmutex_lock(&il->mutex);\n\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\tgoto out;\n\n\til->ops->init_alive_start(il);\nout:\n\tmutex_unlock(&il->mutex);\n}\n\nstatic void\nil4965_bg_alive_start(struct work_struct *data)\n{\n\tstruct il_priv *il =\n\t    container_of(data, struct il_priv, alive_start.work);\n\n\tmutex_lock(&il->mutex);\n\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\tgoto out;\n\n\til4965_alive_start(il);\nout:\n\tmutex_unlock(&il->mutex);\n}\n\nstatic void\nil4965_bg_run_time_calib_work(struct work_struct *work)\n{\n\tstruct il_priv *il = container_of(work, struct il_priv,\n\t\t\t\t\t  run_time_calib_work);\n\n\tmutex_lock(&il->mutex);\n\n\tif (test_bit(S_EXIT_PENDING, &il->status) ||\n\t    test_bit(S_SCANNING, &il->status)) {\n\t\tmutex_unlock(&il->mutex);\n\t\treturn;\n\t}\n\n\tif (il->start_calib) {\n\t\til4965_chain_noise_calibration(il, (void *)&il->_4965.stats);\n\t\til4965_sensitivity_calibration(il, (void *)&il->_4965.stats);\n\t}\n\n\tmutex_unlock(&il->mutex);\n}\n\nstatic void\nil4965_bg_restart(struct work_struct *data)\n{\n\tstruct il_priv *il = container_of(data, struct il_priv, restart);\n\n\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\treturn;\n\n\tif (test_and_clear_bit(S_FW_ERROR, &il->status)) {\n\t\tmutex_lock(&il->mutex);\n\t\til->is_open = 0;\n\n\t\t__il4965_down(il);\n\n\t\tmutex_unlock(&il->mutex);\n\t\til4965_cancel_deferred_work(il);\n\t\tieee80211_restart_hw(il->hw);\n\t} else {\n\t\til4965_down(il);\n\n\t\tmutex_lock(&il->mutex);\n\t\tif (test_bit(S_EXIT_PENDING, &il->status)) {\n\t\t\tmutex_unlock(&il->mutex);\n\t\t\treturn;\n\t\t}\n\n\t\t__il4965_up(il);\n\t\tmutex_unlock(&il->mutex);\n\t}\n}\n\nstatic void\nil4965_bg_rx_replenish(struct work_struct *data)\n{\n\tstruct il_priv *il = container_of(data, struct il_priv, rx_replenish);\n\n\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\treturn;\n\n\tmutex_lock(&il->mutex);\n\til4965_rx_replenish(il);\n\tmutex_unlock(&il->mutex);\n}\n\n \n\n#define UCODE_READY_TIMEOUT\t(4 * HZ)\n\n \nstatic int\nil4965_mac_setup_register(struct il_priv *il, u32 max_probe_length)\n{\n\tint ret;\n\tstruct ieee80211_hw *hw = il->hw;\n\n\thw->rate_control_algorithm = \"iwl-4965-rs\";\n\n\t \n\tieee80211_hw_set(hw, SUPPORTS_DYNAMIC_PS);\n\tieee80211_hw_set(hw, SUPPORTS_PS);\n\tieee80211_hw_set(hw, REPORTS_TX_ACK_STATUS);\n\tieee80211_hw_set(hw, SPECTRUM_MGMT);\n\tieee80211_hw_set(hw, NEED_DTIM_BEFORE_ASSOC);\n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\tieee80211_hw_set(hw, AMPDU_AGGREGATION);\n\tif (il->cfg->sku & IL_SKU_N)\n\t\thw->wiphy->features |= NL80211_FEATURE_DYNAMIC_SMPS |\n\t\t\t\t       NL80211_FEATURE_STATIC_SMPS;\n\n\thw->sta_data_size = sizeof(struct il_station_priv);\n\thw->vif_data_size = sizeof(struct il_vif_priv);\n\n\thw->wiphy->interface_modes =\n\t    BIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_ADHOC);\n\n\thw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;\n\thw->wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG |\n\t\t\t\t       REGULATORY_DISABLE_BEACON_HINTS;\n\n\t \n\thw->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;\n\n\thw->wiphy->max_scan_ssids = PROBE_OPTION_MAX;\n\t \n\thw->wiphy->max_scan_ie_len = max_probe_length - 24 - 2;\n\n\t \n\thw->queues = 4;\n\n\thw->max_listen_interval = IL_CONN_MAX_LISTEN_INTERVAL;\n\n\tif (il->bands[NL80211_BAND_2GHZ].n_channels)\n\t\til->hw->wiphy->bands[NL80211_BAND_2GHZ] =\n\t\t    &il->bands[NL80211_BAND_2GHZ];\n\tif (il->bands[NL80211_BAND_5GHZ].n_channels)\n\t\til->hw->wiphy->bands[NL80211_BAND_5GHZ] =\n\t\t    &il->bands[NL80211_BAND_5GHZ];\n\n\til_leds_init(il);\n\n\twiphy_ext_feature_set(il->hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\tret = ieee80211_register_hw(il->hw);\n\tif (ret) {\n\t\tIL_ERR(\"Failed to register hw (error %d)\\n\", ret);\n\t\treturn ret;\n\t}\n\til->mac80211_registered = 1;\n\n\treturn 0;\n}\n\nint\nil4965_mac_start(struct ieee80211_hw *hw)\n{\n\tstruct il_priv *il = hw->priv;\n\tint ret;\n\n\tD_MAC80211(\"enter\\n\");\n\n\t \n\tmutex_lock(&il->mutex);\n\tret = __il4965_up(il);\n\tmutex_unlock(&il->mutex);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (il_is_rfkill(il))\n\t\tgoto out;\n\n\tD_INFO(\"Start UP work done.\\n\");\n\n\t \n\tret = wait_event_timeout(il->wait_command_queue,\n\t\t\t\t test_bit(S_READY, &il->status),\n\t\t\t\t UCODE_READY_TIMEOUT);\n\tif (!ret) {\n\t\tif (!test_bit(S_READY, &il->status)) {\n\t\t\tIL_ERR(\"START_ALIVE timeout after %dms.\\n\",\n\t\t\t\tjiffies_to_msecs(UCODE_READY_TIMEOUT));\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\til4965_led_enable(il);\n\nout:\n\til->is_open = 1;\n\tD_MAC80211(\"leave\\n\");\n\treturn 0;\n}\n\nvoid\nil4965_mac_stop(struct ieee80211_hw *hw)\n{\n\tstruct il_priv *il = hw->priv;\n\n\tD_MAC80211(\"enter\\n\");\n\n\tif (!il->is_open)\n\t\treturn;\n\n\til->is_open = 0;\n\n\til4965_down(il);\n\n\tflush_workqueue(il->workqueue);\n\n\t \n\t_il_wr(il, CSR_INT, 0xFFFFFFFF);\n\til_enable_rfkill_int(il);\n\n\tD_MAC80211(\"leave\\n\");\n}\n\nvoid\nil4965_mac_tx(struct ieee80211_hw *hw,\n\t      struct ieee80211_tx_control *control,\n\t      struct sk_buff *skb)\n{\n\tstruct il_priv *il = hw->priv;\n\n\tD_MACDUMP(\"enter\\n\");\n\n\tD_TX(\"dev->xmit(%d bytes) at rate 0x%02x\\n\", skb->len,\n\t     ieee80211_get_tx_rate(hw, IEEE80211_SKB_CB(skb))->bitrate);\n\n\tif (il4965_tx_skb(il, control->sta, skb))\n\t\tdev_kfree_skb_any(skb);\n\n\tD_MACDUMP(\"leave\\n\");\n}\n\nvoid\nil4965_mac_update_tkip_key(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_key_conf *keyconf,\n\t\t\t   struct ieee80211_sta *sta, u32 iv32, u16 * phase1key)\n{\n\tstruct il_priv *il = hw->priv;\n\n\tD_MAC80211(\"enter\\n\");\n\n\til4965_update_tkip_key(il, keyconf, sta, iv32, phase1key);\n\n\tD_MAC80211(\"leave\\n\");\n}\n\nint\nil4965_mac_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t   struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t   struct ieee80211_key_conf *key)\n{\n\tstruct il_priv *il = hw->priv;\n\tint ret;\n\tu8 sta_id;\n\tbool is_default_wep_key = false;\n\n\tD_MAC80211(\"enter\\n\");\n\n\tif (il->cfg->mod_params->sw_crypto) {\n\t\tD_MAC80211(\"leave - hwcrypto disabled\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (vif->type == NL80211_IFTYPE_ADHOC &&\n\t    !(key->flags & IEEE80211_KEY_FLAG_PAIRWISE)) {\n\t\tD_MAC80211(\"leave - ad-hoc group key\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tsta_id = il_sta_id_or_broadcast(il, sta);\n\tif (sta_id == IL_INVALID_STATION)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&il->mutex);\n\til_scan_cancel_timeout(il, 100);\n\n\t \n\tif ((key->cipher == WLAN_CIPHER_SUITE_WEP40 ||\n\t     key->cipher == WLAN_CIPHER_SUITE_WEP104) && !sta) {\n\t\tif (cmd == SET_KEY)\n\t\t\tis_default_wep_key = !il->_4965.key_mapping_keys;\n\t\telse\n\t\t\tis_default_wep_key =\n\t\t\t    (key->hw_key_idx == HW_KEY_DEFAULT);\n\t}\n\n\tswitch (cmd) {\n\tcase SET_KEY:\n\t\tif (is_default_wep_key)\n\t\t\tret = il4965_set_default_wep_key(il, key);\n\t\telse\n\t\t\tret = il4965_set_dynamic_key(il, key, sta_id);\n\n\t\tD_MAC80211(\"enable hwcrypto key\\n\");\n\t\tbreak;\n\tcase DISABLE_KEY:\n\t\tif (is_default_wep_key)\n\t\t\tret = il4965_remove_default_wep_key(il, key);\n\t\telse\n\t\t\tret = il4965_remove_dynamic_key(il, key, sta_id);\n\n\t\tD_MAC80211(\"disable hwcrypto key\\n\");\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&il->mutex);\n\tD_MAC80211(\"leave\\n\");\n\n\treturn ret;\n}\n\nint\nil4965_mac_ampdu_action(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_ampdu_params *params)\n{\n\tstruct il_priv *il = hw->priv;\n\tint ret = -EINVAL;\n\tstruct ieee80211_sta *sta = params->sta;\n\tenum ieee80211_ampdu_mlme_action action = params->action;\n\tu16 tid = params->tid;\n\tu16 *ssn = &params->ssn;\n\n\tD_HT(\"A-MPDU action on addr %pM tid %d\\n\", sta->addr, tid);\n\n\tif (!(il->cfg->sku & IL_SKU_N))\n\t\treturn -EACCES;\n\n\tmutex_lock(&il->mutex);\n\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_RX_START:\n\t\tD_HT(\"start Rx\\n\");\n\t\tret = il4965_sta_rx_agg_start(il, sta, tid, *ssn);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\tD_HT(\"stop Rx\\n\");\n\t\tret = il4965_sta_rx_agg_stop(il, sta, tid);\n\t\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\t\tret = 0;\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_START:\n\t\tD_HT(\"start Tx\\n\");\n\t\tret = il4965_tx_agg_start(il, vif, sta, tid, ssn);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\t\tD_HT(\"stop Tx\\n\");\n\t\tret = il4965_tx_agg_stop(il, vif, sta, tid);\n\t\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\t\tret = 0;\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\tret = 0;\n\t\tbreak;\n\t}\n\tmutex_unlock(&il->mutex);\n\n\treturn ret;\n}\n\nint\nil4965_mac_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t   struct ieee80211_sta *sta)\n{\n\tstruct il_priv *il = hw->priv;\n\tstruct il_station_priv *sta_priv = (void *)sta->drv_priv;\n\tbool is_ap = vif->type == NL80211_IFTYPE_STATION;\n\tint ret;\n\tu8 sta_id;\n\n\tD_INFO(\"received request to add station %pM\\n\", sta->addr);\n\tmutex_lock(&il->mutex);\n\tD_INFO(\"proceeding to add station %pM\\n\", sta->addr);\n\tsta_priv->common.sta_id = IL_INVALID_STATION;\n\n\tatomic_set(&sta_priv->pending_frames, 0);\n\n\tret =\n\t    il_add_station_common(il, sta->addr, is_ap, sta, &sta_id);\n\tif (ret) {\n\t\tIL_ERR(\"Unable to add station %pM (%d)\\n\", sta->addr, ret);\n\t\t \n\t\tmutex_unlock(&il->mutex);\n\t\treturn ret;\n\t}\n\n\tsta_priv->common.sta_id = sta_id;\n\n\t \n\tD_INFO(\"Initializing rate scaling for station %pM\\n\", sta->addr);\n\til4965_rs_rate_init(il, sta, sta_id);\n\tmutex_unlock(&il->mutex);\n\n\treturn 0;\n}\n\nvoid\nil4965_mac_channel_switch(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t  struct ieee80211_channel_switch *ch_switch)\n{\n\tstruct il_priv *il = hw->priv;\n\tconst struct il_channel_info *ch_info;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tstruct ieee80211_channel *channel = ch_switch->chandef.chan;\n\tstruct il_ht_config *ht_conf = &il->current_ht_config;\n\tu16 ch;\n\n\tD_MAC80211(\"enter\\n\");\n\n\tmutex_lock(&il->mutex);\n\n\tif (il_is_rfkill(il))\n\t\tgoto out;\n\n\tif (test_bit(S_EXIT_PENDING, &il->status) ||\n\t    test_bit(S_SCANNING, &il->status) ||\n\t    test_bit(S_CHANNEL_SWITCH_PENDING, &il->status))\n\t\tgoto out;\n\n\tif (!il_is_associated(il))\n\t\tgoto out;\n\n\tif (!il->ops->set_channel_switch)\n\t\tgoto out;\n\n\tch = channel->hw_value;\n\tif (le16_to_cpu(il->active.channel) == ch)\n\t\tgoto out;\n\n\tch_info = il_get_channel_info(il, channel->band, ch);\n\tif (!il_is_channel_valid(ch_info)) {\n\t\tD_MAC80211(\"invalid channel\\n\");\n\t\tgoto out;\n\t}\n\n\tspin_lock_irq(&il->lock);\n\n\til->current_ht_config.smps = conf->smps_mode;\n\n\t \n\tswitch (cfg80211_get_chandef_type(&ch_switch->chandef)) {\n\tcase NL80211_CHAN_NO_HT:\n\tcase NL80211_CHAN_HT20:\n\t\til->ht.is_40mhz = false;\n\t\til->ht.extension_chan_offset = IEEE80211_HT_PARAM_CHA_SEC_NONE;\n\t\tbreak;\n\tcase NL80211_CHAN_HT40MINUS:\n\t\til->ht.extension_chan_offset = IEEE80211_HT_PARAM_CHA_SEC_BELOW;\n\t\til->ht.is_40mhz = true;\n\t\tbreak;\n\tcase NL80211_CHAN_HT40PLUS:\n\t\til->ht.extension_chan_offset = IEEE80211_HT_PARAM_CHA_SEC_ABOVE;\n\t\til->ht.is_40mhz = true;\n\t\tbreak;\n\t}\n\n\tif ((le16_to_cpu(il->staging.channel) != ch))\n\t\til->staging.flags = 0;\n\n\til_set_rxon_channel(il, channel);\n\til_set_rxon_ht(il, ht_conf);\n\til_set_flags_for_band(il, channel->band, il->vif);\n\n\tspin_unlock_irq(&il->lock);\n\n\til_set_rate(il);\n\t \n\tset_bit(S_CHANNEL_SWITCH_PENDING, &il->status);\n\til->switch_channel = cpu_to_le16(ch);\n\tif (il->ops->set_channel_switch(il, ch_switch)) {\n\t\tclear_bit(S_CHANNEL_SWITCH_PENDING, &il->status);\n\t\til->switch_channel = 0;\n\t\tieee80211_chswitch_done(il->vif, false);\n\t}\n\nout:\n\tmutex_unlock(&il->mutex);\n\tD_MAC80211(\"leave\\n\");\n}\n\nvoid\nil4965_configure_filter(struct ieee80211_hw *hw, unsigned int changed_flags,\n\t\t\tunsigned int *total_flags, u64 multicast)\n{\n\tstruct il_priv *il = hw->priv;\n\t__le32 filter_or = 0, filter_nand = 0;\n\n#define CHK(test, flag)\tdo { \\\n\tif (*total_flags & (test))\t\t\\\n\t\tfilter_or |= (flag);\t\t\\\n\telse\t\t\t\t\t\\\n\t\tfilter_nand |= (flag);\t\t\\\n\t} while (0)\n\n\tD_MAC80211(\"Enter: changed: 0x%x, total: 0x%x\\n\", changed_flags,\n\t\t   *total_flags);\n\n\tCHK(FIF_OTHER_BSS, RXON_FILTER_PROMISC_MSK);\n\t \n\tCHK(FIF_CONTROL, RXON_FILTER_CTL2HOST_MSK | RXON_FILTER_PROMISC_MSK);\n\tCHK(FIF_BCN_PRBRESP_PROMISC, RXON_FILTER_BCON_AWARE_MSK);\n\n#undef CHK\n\n\tmutex_lock(&il->mutex);\n\n\til->staging.filter_flags &= ~filter_nand;\n\til->staging.filter_flags |= filter_or;\n\n\t \n\n\tmutex_unlock(&il->mutex);\n\n\t \n\t*total_flags &=\n\t    FIF_OTHER_BSS | FIF_ALLMULTI |\n\t    FIF_BCN_PRBRESP_PROMISC | FIF_CONTROL;\n}\n\n \n\nstatic void\nil4965_bg_txpower_work(struct work_struct *work)\n{\n\tstruct il_priv *il = container_of(work, struct il_priv,\n\t\t\t\t\t  txpower_work);\n\n\tmutex_lock(&il->mutex);\n\n\t \n\tif (test_bit(S_EXIT_PENDING, &il->status) ||\n\t    test_bit(S_SCANNING, &il->status))\n\t\tgoto out;\n\n\t \n\til->ops->send_tx_power(il);\n\n\t \n\til->last_temperature = il->temperature;\nout:\n\tmutex_unlock(&il->mutex);\n}\n\nstatic int\nil4965_setup_deferred_work(struct il_priv *il)\n{\n\til->workqueue = create_singlethread_workqueue(DRV_NAME);\n\tif (!il->workqueue)\n\t\treturn -ENOMEM;\n\n\tinit_waitqueue_head(&il->wait_command_queue);\n\n\tINIT_WORK(&il->restart, il4965_bg_restart);\n\tINIT_WORK(&il->rx_replenish, il4965_bg_rx_replenish);\n\tINIT_WORK(&il->run_time_calib_work, il4965_bg_run_time_calib_work);\n\tINIT_DELAYED_WORK(&il->init_alive_start, il4965_bg_init_alive_start);\n\tINIT_DELAYED_WORK(&il->alive_start, il4965_bg_alive_start);\n\n\til_setup_scan_deferred_work(il);\n\n\tINIT_WORK(&il->txpower_work, il4965_bg_txpower_work);\n\n\ttimer_setup(&il->stats_periodic, il4965_bg_stats_periodic, 0);\n\n\ttimer_setup(&il->watchdog, il_bg_watchdog, 0);\n\n\ttasklet_setup(&il->irq_tasklet, il4965_irq_tasklet);\n\n\treturn 0;\n}\n\nstatic void\nil4965_cancel_deferred_work(struct il_priv *il)\n{\n\tcancel_work_sync(&il->txpower_work);\n\tcancel_delayed_work_sync(&il->init_alive_start);\n\tcancel_delayed_work(&il->alive_start);\n\tcancel_work_sync(&il->run_time_calib_work);\n\n\til_cancel_scan_deferred_work(il);\n\n\tdel_timer_sync(&il->stats_periodic);\n}\n\nstatic void\nil4965_init_hw_rates(struct il_priv *il, struct ieee80211_rate *rates)\n{\n\tint i;\n\n\tfor (i = 0; i < RATE_COUNT_LEGACY; i++) {\n\t\trates[i].bitrate = il_rates[i].ieee * 5;\n\t\trates[i].hw_value = i;\t \n\t\trates[i].hw_value_short = i;\n\t\trates[i].flags = 0;\n\t\tif ((i >= IL_FIRST_CCK_RATE) && (i <= IL_LAST_CCK_RATE)) {\n\t\t\t \n\t\t\trates[i].flags |=\n\t\t\t    (il_rates[i].plcp ==\n\t\t\t     RATE_1M_PLCP) ? 0 : IEEE80211_RATE_SHORT_PREAMBLE;\n\t\t}\n\t}\n}\n\n \nvoid\nil4965_set_wr_ptrs(struct il_priv *il, int txq_id, u32 idx)\n{\n\til_wr(il, HBUS_TARG_WRPTR, (idx & 0xff) | (txq_id << 8));\n\til_wr_prph(il, IL49_SCD_QUEUE_RDPTR(txq_id), idx);\n}\n\nvoid\nil4965_tx_queue_set_status(struct il_priv *il, struct il_tx_queue *txq,\n\t\t\t   int tx_fifo_id, int scd_retry)\n{\n\tint txq_id = txq->q.id;\n\n\t \n\tint active = test_bit(txq_id, &il->txq_ctx_active_msk) ? 1 : 0;\n\n\t \n\til_wr_prph(il, IL49_SCD_QUEUE_STATUS_BITS(txq_id),\n\t\t   (active << IL49_SCD_QUEUE_STTS_REG_POS_ACTIVE) |\n\t\t   (tx_fifo_id << IL49_SCD_QUEUE_STTS_REG_POS_TXF) |\n\t\t   (scd_retry << IL49_SCD_QUEUE_STTS_REG_POS_WSL) |\n\t\t   (scd_retry << IL49_SCD_QUEUE_STTS_REG_POS_SCD_ACK) |\n\t\t   IL49_SCD_QUEUE_STTS_REG_MSK);\n\n\ttxq->sched_retry = scd_retry;\n\n\tD_INFO(\"%s %s Queue %d on AC %d\\n\", active ? \"Activate\" : \"Deactivate\",\n\t       scd_retry ? \"BA\" : \"AC\", txq_id, tx_fifo_id);\n}\n\nstatic const struct ieee80211_ops il4965_mac_ops = {\n\t.tx = il4965_mac_tx,\n\t.wake_tx_queue = ieee80211_handle_wake_tx_queue,\n\t.start = il4965_mac_start,\n\t.stop = il4965_mac_stop,\n\t.add_interface = il_mac_add_interface,\n\t.remove_interface = il_mac_remove_interface,\n\t.change_interface = il_mac_change_interface,\n\t.config = il_mac_config,\n\t.configure_filter = il4965_configure_filter,\n\t.set_key = il4965_mac_set_key,\n\t.update_tkip_key = il4965_mac_update_tkip_key,\n\t.conf_tx = il_mac_conf_tx,\n\t.reset_tsf = il_mac_reset_tsf,\n\t.bss_info_changed = il_mac_bss_info_changed,\n\t.ampdu_action = il4965_mac_ampdu_action,\n\t.hw_scan = il_mac_hw_scan,\n\t.sta_add = il4965_mac_sta_add,\n\t.sta_remove = il_mac_sta_remove,\n\t.channel_switch = il4965_mac_channel_switch,\n\t.tx_last_beacon = il_mac_tx_last_beacon,\n\t.flush = il_mac_flush,\n};\n\nstatic int\nil4965_init_drv(struct il_priv *il)\n{\n\tint ret;\n\n\tspin_lock_init(&il->sta_lock);\n\tspin_lock_init(&il->hcmd_lock);\n\n\tINIT_LIST_HEAD(&il->free_frames);\n\n\tmutex_init(&il->mutex);\n\n\til->ieee_channels = NULL;\n\til->ieee_rates = NULL;\n\til->band = NL80211_BAND_2GHZ;\n\n\til->iw_mode = NL80211_IFTYPE_STATION;\n\til->current_ht_config.smps = IEEE80211_SMPS_STATIC;\n\til->missed_beacon_threshold = IL_MISSED_BEACON_THRESHOLD_DEF;\n\n\t \n\til->force_reset.reset_duration = IL_DELAY_NEXT_FORCE_FW_RELOAD;\n\n\t \n\tif (il->ops->set_rxon_chain)\n\t\til->ops->set_rxon_chain(il);\n\n\til_init_scan_params(il);\n\n\tret = il_init_channel_map(il);\n\tif (ret) {\n\t\tIL_ERR(\"initializing regulatory failed: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = il_init_geos(il);\n\tif (ret) {\n\t\tIL_ERR(\"initializing geos failed: %d\\n\", ret);\n\t\tgoto err_free_channel_map;\n\t}\n\til4965_init_hw_rates(il, il->ieee_rates);\n\n\treturn 0;\n\nerr_free_channel_map:\n\til_free_channel_map(il);\nerr:\n\treturn ret;\n}\n\nstatic void\nil4965_uninit_drv(struct il_priv *il)\n{\n\til_free_geos(il);\n\til_free_channel_map(il);\n\tkfree(il->scan_cmd);\n}\n\nstatic void\nil4965_hw_detect(struct il_priv *il)\n{\n\til->hw_rev = _il_rd(il, CSR_HW_REV);\n\til->hw_wa_rev = _il_rd(il, CSR_HW_REV_WA_REG);\n\til->rev_id = il->pci_dev->revision;\n\tD_INFO(\"HW Revision ID = 0x%X\\n\", il->rev_id);\n}\n\nstatic const struct il_sensitivity_ranges il4965_sensitivity = {\n\t.min_nrg_cck = 97,\n\t.max_nrg_cck = 0,\t \n\n\t.auto_corr_min_ofdm = 85,\n\t.auto_corr_min_ofdm_mrc = 170,\n\t.auto_corr_min_ofdm_x1 = 105,\n\t.auto_corr_min_ofdm_mrc_x1 = 220,\n\n\t.auto_corr_max_ofdm = 120,\n\t.auto_corr_max_ofdm_mrc = 210,\n\t.auto_corr_max_ofdm_x1 = 140,\n\t.auto_corr_max_ofdm_mrc_x1 = 270,\n\n\t.auto_corr_min_cck = 125,\n\t.auto_corr_max_cck = 200,\n\t.auto_corr_min_cck_mrc = 200,\n\t.auto_corr_max_cck_mrc = 400,\n\n\t.nrg_th_cck = 100,\n\t.nrg_th_ofdm = 100,\n\n\t.barker_corr_th_min = 190,\n\t.barker_corr_th_min_mrc = 390,\n\t.nrg_th_cca = 62,\n};\n\nstatic void\nil4965_set_hw_params(struct il_priv *il)\n{\n\til->hw_params.bcast_id = IL4965_BROADCAST_ID;\n\til->hw_params.max_rxq_size = RX_QUEUE_SIZE;\n\til->hw_params.max_rxq_log = RX_QUEUE_SIZE_LOG;\n\tif (il->cfg->mod_params->amsdu_size_8K)\n\t\til->hw_params.rx_page_order = get_order(IL_RX_BUF_SIZE_8K);\n\telse\n\t\til->hw_params.rx_page_order = get_order(IL_RX_BUF_SIZE_4K);\n\n\til->hw_params.max_beacon_itrvl = IL_MAX_UCODE_BEACON_INTERVAL;\n\n\tif (il->cfg->mod_params->disable_11n)\n\t\til->cfg->sku &= ~IL_SKU_N;\n\n\tif (il->cfg->mod_params->num_of_queues >= IL_MIN_NUM_QUEUES &&\n\t    il->cfg->mod_params->num_of_queues <= IL49_NUM_QUEUES)\n\t\til->cfg->num_of_queues =\n\t\t    il->cfg->mod_params->num_of_queues;\n\n\til->hw_params.max_txq_num = il->cfg->num_of_queues;\n\til->hw_params.dma_chnl_num = FH49_TCSR_CHNL_NUM;\n\til->hw_params.scd_bc_tbls_size =\n\t    il->cfg->num_of_queues *\n\t    sizeof(struct il4965_scd_bc_tbl);\n\n\til->hw_params.tfd_size = sizeof(struct il_tfd);\n\til->hw_params.max_stations = IL4965_STATION_COUNT;\n\til->hw_params.max_data_size = IL49_RTC_DATA_SIZE;\n\til->hw_params.max_inst_size = IL49_RTC_INST_SIZE;\n\til->hw_params.max_bsm_size = BSM_SRAM_SIZE;\n\til->hw_params.ht40_channel = BIT(NL80211_BAND_5GHZ);\n\n\til->hw_params.rx_wrt_ptr_reg = FH49_RSCSR_CHNL0_WPTR;\n\n\til->hw_params.tx_chains_num = il4965_num_of_ant(il->cfg->valid_tx_ant);\n\til->hw_params.rx_chains_num = il4965_num_of_ant(il->cfg->valid_rx_ant);\n\til->hw_params.valid_tx_ant = il->cfg->valid_tx_ant;\n\til->hw_params.valid_rx_ant = il->cfg->valid_rx_ant;\n\n\til->hw_params.ct_kill_threshold =\n\t   celsius_to_kelvin(CT_KILL_THRESHOLD_LEGACY);\n\n\til->hw_params.sens = &il4965_sensitivity;\n\til->hw_params.beacon_time_tsf_bits = IL4965_EXT_BEACON_TIME_POS;\n}\n\nstatic int\nil4965_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint err = 0;\n\tstruct il_priv *il;\n\tstruct ieee80211_hw *hw;\n\tstruct il_cfg *cfg = (struct il_cfg *)(ent->driver_data);\n\tunsigned long flags;\n\tu16 pci_cmd;\n\n\t \n\n\thw = ieee80211_alloc_hw(sizeof(struct il_priv), &il4965_mac_ops);\n\tif (!hw) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\til = hw->priv;\n\til->hw = hw;\n\tSET_IEEE80211_DEV(hw, &pdev->dev);\n\n\tD_INFO(\"*** LOAD DRIVER ***\\n\");\n\til->cfg = cfg;\n\til->ops = &il4965_ops;\n#ifdef CONFIG_IWLEGACY_DEBUGFS\n\til->debugfs_ops = &il4965_debugfs_ops;\n#endif\n\til->pci_dev = pdev;\n\til->inta_mask = CSR_INI_SET_MASK;\n\n\t \n\tpci_disable_link_state(pdev,\n\t\t\t       PCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1 |\n\t\t\t       PCIE_LINK_STATE_CLKPM);\n\n\tif (pci_enable_device(pdev)) {\n\t\terr = -ENODEV;\n\t\tgoto out_ieee80211_free_hw;\n\t}\n\n\tpci_set_master(pdev);\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(36));\n\tif (err) {\n\t\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\t\t \n\t\tif (err) {\n\t\t\tIL_WARN(\"No suitable DMA available.\\n\");\n\t\t\tgoto out_pci_disable_device;\n\t\t}\n\t}\n\n\terr = pci_request_regions(pdev, DRV_NAME);\n\tif (err)\n\t\tgoto out_pci_disable_device;\n\n\tpci_set_drvdata(pdev, il);\n\n\t \n\til->hw_base = pci_ioremap_bar(pdev, 0);\n\tif (!il->hw_base) {\n\t\terr = -ENODEV;\n\t\tgoto out_pci_release_regions;\n\t}\n\n\tD_INFO(\"pci_resource_len = 0x%08llx\\n\",\n\t       (unsigned long long)pci_resource_len(pdev, 0));\n\tD_INFO(\"pci_resource_base = %p\\n\", il->hw_base);\n\n\t \n\tspin_lock_init(&il->reg_lock);\n\tspin_lock_init(&il->lock);\n\n\t \n\t_il_wr(il, CSR_RESET, CSR_RESET_REG_FLAG_NEVO_RESET);\n\n\til4965_hw_detect(il);\n\tIL_INFO(\"Detected %s, REV=0x%X\\n\", il->cfg->name, il->hw_rev);\n\n\t \n\tpci_write_config_byte(pdev, PCI_CFG_RETRY_TIMEOUT, 0x00);\n\n\til4965_prepare_card_hw(il);\n\tif (!il->hw_ready) {\n\t\tIL_WARN(\"Failed, HW not ready\\n\");\n\t\terr = -EIO;\n\t\tgoto out_iounmap;\n\t}\n\n\t \n\t \n\terr = il_eeprom_init(il);\n\tif (err) {\n\t\tIL_ERR(\"Unable to init EEPROM\\n\");\n\t\tgoto out_iounmap;\n\t}\n\terr = il4965_eeprom_check_version(il);\n\tif (err)\n\t\tgoto out_free_eeprom;\n\n\t \n\til4965_eeprom_get_mac(il, il->addresses[0].addr);\n\tD_INFO(\"MAC address: %pM\\n\", il->addresses[0].addr);\n\til->hw->wiphy->addresses = il->addresses;\n\til->hw->wiphy->n_addresses = 1;\n\n\t \n\til4965_set_hw_params(il);\n\n\t \n\n\terr = il4965_init_drv(il);\n\tif (err)\n\t\tgoto out_free_eeprom;\n\t \n\n\t \n\tspin_lock_irqsave(&il->lock, flags);\n\til_disable_interrupts(il);\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\tpci_enable_msi(il->pci_dev);\n\n\terr = request_irq(il->pci_dev->irq, il_isr, IRQF_SHARED, DRV_NAME, il);\n\tif (err) {\n\t\tIL_ERR(\"Error allocating IRQ %d\\n\", il->pci_dev->irq);\n\t\tgoto out_disable_msi;\n\t}\n\n\terr = il4965_setup_deferred_work(il);\n\tif (err)\n\t\tgoto out_free_irq;\n\n\til4965_setup_handlers(il);\n\n\t \n\n\t \n\tpci_read_config_word(il->pci_dev, PCI_COMMAND, &pci_cmd);\n\tif (pci_cmd & PCI_COMMAND_INTX_DISABLE) {\n\t\tpci_cmd &= ~PCI_COMMAND_INTX_DISABLE;\n\t\tpci_write_config_word(il->pci_dev, PCI_COMMAND, pci_cmd);\n\t}\n\n\til_enable_rfkill_int(il);\n\n\t \n\tif (_il_rd(il, CSR_GP_CNTRL) & CSR_GP_CNTRL_REG_FLAG_HW_RF_KILL_SW)\n\t\tclear_bit(S_RFKILL, &il->status);\n\telse\n\t\tset_bit(S_RFKILL, &il->status);\n\n\twiphy_rfkill_set_hw_state(il->hw->wiphy,\n\t\t\t\t  test_bit(S_RFKILL, &il->status));\n\n\til_power_initialize(il);\n\n\tinit_completion(&il->_4965.firmware_loading_complete);\n\n\terr = il4965_request_firmware(il, true);\n\tif (err)\n\t\tgoto out_destroy_workqueue;\n\n\treturn 0;\n\nout_destroy_workqueue:\n\tdestroy_workqueue(il->workqueue);\n\til->workqueue = NULL;\nout_free_irq:\n\tfree_irq(il->pci_dev->irq, il);\nout_disable_msi:\n\tpci_disable_msi(il->pci_dev);\n\til4965_uninit_drv(il);\nout_free_eeprom:\n\til_eeprom_free(il);\nout_iounmap:\n\tiounmap(il->hw_base);\nout_pci_release_regions:\n\tpci_release_regions(pdev);\nout_pci_disable_device:\n\tpci_disable_device(pdev);\nout_ieee80211_free_hw:\n\tieee80211_free_hw(il->hw);\nout:\n\treturn err;\n}\n\nstatic void\nil4965_pci_remove(struct pci_dev *pdev)\n{\n\tstruct il_priv *il = pci_get_drvdata(pdev);\n\tunsigned long flags;\n\n\tif (!il)\n\t\treturn;\n\n\twait_for_completion(&il->_4965.firmware_loading_complete);\n\n\tD_INFO(\"*** UNLOAD DRIVER ***\\n\");\n\n\til_dbgfs_unregister(il);\n\tsysfs_remove_group(&pdev->dev.kobj, &il_attribute_group);\n\n\t \n\tset_bit(S_EXIT_PENDING, &il->status);\n\n\til_leds_exit(il);\n\n\tif (il->mac80211_registered) {\n\t\tieee80211_unregister_hw(il->hw);\n\t\til->mac80211_registered = 0;\n\t} else {\n\t\til4965_down(il);\n\t}\n\n\t \n\til_apm_stop(il);\n\n\t \n\tspin_lock_irqsave(&il->lock, flags);\n\til_disable_interrupts(il);\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\til4965_synchronize_irq(il);\n\n\til4965_dealloc_ucode_pci(il);\n\n\tif (il->rxq.bd)\n\t\til4965_rx_queue_free(il, &il->rxq);\n\til4965_hw_txq_ctx_free(il);\n\n\til_eeprom_free(il);\n\n\t \n\n\t \n\tdestroy_workqueue(il->workqueue);\n\til->workqueue = NULL;\n\n\tfree_irq(il->pci_dev->irq, il);\n\tpci_disable_msi(il->pci_dev);\n\tiounmap(il->hw_base);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\n\til4965_uninit_drv(il);\n\n\tdev_kfree_skb(il->beacon_skb);\n\n\tieee80211_free_hw(il->hw);\n}\n\n \nvoid\nil4965_txq_set_sched(struct il_priv *il, u32 mask)\n{\n\til_wr_prph(il, IL49_SCD_TXFACT, mask);\n}\n\n \n\n \nstatic const struct pci_device_id il4965_hw_card_ids[] = {\n\t{IL_PCI_DEVICE(0x4229, PCI_ANY_ID, il4965_cfg)},\n\t{IL_PCI_DEVICE(0x4230, PCI_ANY_ID, il4965_cfg)},\n\t{0}\n};\nMODULE_DEVICE_TABLE(pci, il4965_hw_card_ids);\n\nstatic struct pci_driver il4965_driver = {\n\t.name = DRV_NAME,\n\t.id_table = il4965_hw_card_ids,\n\t.probe = il4965_pci_probe,\n\t.remove = il4965_pci_remove,\n\t.driver.pm = IL_LEGACY_PM_OPS,\n};\n\nstatic int __init\nil4965_init(void)\n{\n\n\tint ret;\n\tpr_info(DRV_DESCRIPTION \", \" DRV_VERSION \"\\n\");\n\tpr_info(DRV_COPYRIGHT \"\\n\");\n\n\tret = il4965_rate_control_register();\n\tif (ret) {\n\t\tpr_err(\"Unable to register rate control algorithm: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = pci_register_driver(&il4965_driver);\n\tif (ret) {\n\t\tpr_err(\"Unable to initialize PCI module\\n\");\n\t\tgoto error_register;\n\t}\n\n\treturn ret;\n\nerror_register:\n\til4965_rate_control_unregister();\n\treturn ret;\n}\n\nstatic void __exit\nil4965_exit(void)\n{\n\tpci_unregister_driver(&il4965_driver);\n\til4965_rate_control_unregister();\n}\n\nmodule_exit(il4965_exit);\nmodule_init(il4965_init);\n\n#ifdef CONFIG_IWLEGACY_DEBUG\nmodule_param_named(debug, il_debug_level, uint, 0644);\nMODULE_PARM_DESC(debug, \"debug output mask\");\n#endif\n\nmodule_param_named(swcrypto, il4965_mod_params.sw_crypto, int, 0444);\nMODULE_PARM_DESC(swcrypto, \"using crypto in software (default 0 [hardware])\");\nmodule_param_named(queues_num, il4965_mod_params.num_of_queues, int, 0444);\nMODULE_PARM_DESC(queues_num, \"number of hw queues.\");\nmodule_param_named(11n_disable, il4965_mod_params.disable_11n, int, 0444);\nMODULE_PARM_DESC(11n_disable, \"disable 11n functionality\");\nmodule_param_named(amsdu_size_8K, il4965_mod_params.amsdu_size_8K, int, 0444);\nMODULE_PARM_DESC(amsdu_size_8K, \"enable 8K amsdu size (default 0 [disabled])\");\nmodule_param_named(fw_restart, il4965_mod_params.restart_fw, int, 0444);\nMODULE_PARM_DESC(fw_restart, \"restart firmware in case of error\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}