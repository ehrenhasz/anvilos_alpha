{
  "module_name": "common.h",
  "hash_id": "89264090ffb56e73da810d16f5f8773eaaca352d932288242fd9015095656ebe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlegacy/common.h",
  "human_readable_source": " \n \n#ifndef __il_core_h__\n#define __il_core_h__\n\n#include <linux/interrupt.h>\n#include <linux/pci.h>\t\t \n#include <linux/kernel.h>\n#include <linux/leds.h>\n#include <linux/wait.h>\n#include <linux/io.h>\n#include <net/mac80211.h>\n#include <net/ieee80211_radiotap.h>\n\n#include \"commands.h\"\n#include \"csr.h\"\n#include \"prph.h\"\n\nstruct il_host_cmd;\nstruct il_cmd;\nstruct il_tx_queue;\n\n#define IL_ERR(f, a...) dev_err(&il->pci_dev->dev, f, ## a)\n#define IL_WARN(f, a...) dev_warn(&il->pci_dev->dev, f, ## a)\n#define IL_WARN_ONCE(f, a...) dev_warn_once(&il->pci_dev->dev, f, ## a)\n#define IL_INFO(f, a...) dev_info(&il->pci_dev->dev, f, ## a)\n\n#define RX_QUEUE_SIZE                         256\n#define RX_QUEUE_MASK                         255\n#define RX_QUEUE_SIZE_LOG                     8\n\n \n#define RX_FREE_BUFFERS 64\n#define RX_LOW_WATERMARK 8\n\n#define U32_PAD(n)\t\t((4-(n))&0x3)\n\n \n#define CT_KILL_THRESHOLD_LEGACY   110\t \n\n \n#define IL_NOISE_MEAS_NOT_AVAILABLE (-127)\n\n \n#define DEFAULT_RTS_THRESHOLD     2347U\n#define MIN_RTS_THRESHOLD         0U\n#define MAX_RTS_THRESHOLD         2347U\n#define MAX_MSDU_SIZE\t\t  2304U\n#define MAX_MPDU_SIZE\t\t  2346U\n#define DEFAULT_BEACON_INTERVAL   100U\n#define\tDEFAULT_SHORT_RETRY_LIMIT 7U\n#define\tDEFAULT_LONG_RETRY_LIMIT  4U\n\nstruct il_rx_buf {\n\tdma_addr_t page_dma;\n\tstruct page *page;\n\tstruct list_head list;\n};\n\n#define rxb_addr(r) page_address(r->page)\n\n \nstruct il_device_cmd;\n\nstruct il_cmd_meta {\n\t \n\tstruct il_host_cmd *source;\n\t \n\tvoid (*callback) (struct il_priv *il, struct il_device_cmd *cmd,\n\t\t\t  struct il_rx_pkt *pkt);\n\n\t \n\tu32 flags;\n\n\t DEFINE_DMA_UNMAP_ADDR(mapping);\n\t DEFINE_DMA_UNMAP_LEN(len);\n};\n\n \nstruct il_queue {\n\tint n_bd;\t\t \n\tint write_ptr;\t\t \n\tint read_ptr;\t\t \n\t \n\tdma_addr_t dma_addr;\t \n\tint n_win;\t\t \n\tu32 id;\n\tint low_mark;\t\t \n\tint high_mark;\t\t \n};\n\n \n#define TFD_TX_CMD_SLOTS 256\n#define TFD_CMD_SLOTS 32\n\nstruct il_tx_queue {\n\tstruct il_queue q;\n\tvoid *tfds;\n\tstruct il_device_cmd **cmd;\n\tstruct il_cmd_meta *meta;\n\tstruct sk_buff **skbs;\n\tunsigned long time_stamp;\n\tu8 need_update;\n\tu8 sched_retry;\n\tu8 active;\n\tu8 swq_id;\n};\n\n \n#define IL_EEPROM_ACCESS_TIMEOUT\t5000\t \n\n#define IL_EEPROM_SEM_TIMEOUT\t\t10\t \n#define IL_EEPROM_SEM_RETRY_LIMIT\t1000\t \n\n \n#define IL_NUM_TX_CALIB_GROUPS 5\nenum {\n\tEEPROM_CHANNEL_VALID = (1 << 0),\t \n\tEEPROM_CHANNEL_IBSS = (1 << 1),\t \n\t \n\tEEPROM_CHANNEL_ACTIVE = (1 << 3),\t \n\tEEPROM_CHANNEL_RADAR = (1 << 4),\t \n\tEEPROM_CHANNEL_WIDE = (1 << 5),\t \n\t \n\tEEPROM_CHANNEL_DFS = (1 << 7),\t \n};\n\n \n \n#define EEPROM_SKU_CAP_SW_RF_KILL_ENABLE                (1 << 0)\n#define EEPROM_SKU_CAP_HW_RF_KILL_ENABLE                (1 << 1)\n\n \nstruct il_eeprom_channel {\n\tu8 flags;\t\t \n\ts8 max_power_avg;\t \n} __packed;\n\n \n#define EEPROM_3945_EEPROM_VERSION\t(0x2f)\n\n \n#define EEPROM_TX_POWER_TX_CHAINS      (2)\n\n \n#define EEPROM_TX_POWER_BANDS          (8)\n\n \n#define EEPROM_TX_POWER_MEASUREMENTS   (3)\n\n \n \n#define EEPROM_4965_TX_POWER_VERSION    (5)\n#define EEPROM_4965_EEPROM_VERSION\t(0x2f)\n#define EEPROM_4965_CALIB_VERSION_OFFSET       (2*0xB6)\t \n#define EEPROM_4965_CALIB_TXPOWER_OFFSET       (2*0xE8)\t \n#define EEPROM_4965_BOARD_REVISION             (2*0x4F)\t \n#define EEPROM_4965_BOARD_PBA                  (2*0x56+1)\t \n\n \nextern const u8 il_eeprom_band_1[14];\n\n \nstruct il_eeprom_calib_measure {\n\tu8 temperature;\t\t \n\tu8 gain_idx;\t\t \n\tu8 actual_pow;\t\t \n\ts8 pa_det;\t\t \n} __packed;\n\n \nstruct il_eeprom_calib_ch_info {\n\tu8 ch_num;\n\tstruct il_eeprom_calib_measure\n\t    measurements[EEPROM_TX_POWER_TX_CHAINS]\n\t    [EEPROM_TX_POWER_MEASUREMENTS];\n} __packed;\n\n \nstruct il_eeprom_calib_subband_info {\n\tu8 ch_from;\t\t \n\tu8 ch_to;\t\t \n\tstruct il_eeprom_calib_ch_info ch1;\n\tstruct il_eeprom_calib_ch_info ch2;\n} __packed;\n\n \nstruct il_eeprom_calib_info {\n\tu8 saturation_power24;\t \n\tu8 saturation_power52;\t \n\t__le16 voltage;\t\t \n\tstruct il_eeprom_calib_subband_info band_info[EEPROM_TX_POWER_BANDS];\n} __packed;\n\n \n#define EEPROM_DEVICE_ID                    (2*0x08)\t \n#define EEPROM_MAC_ADDRESS                  (2*0x15)\t \n#define EEPROM_BOARD_REVISION               (2*0x35)\t \n#define EEPROM_BOARD_PBA_NUMBER             (2*0x3B+1)\t \n#define EEPROM_VERSION                      (2*0x44)\t \n#define EEPROM_SKU_CAP                      (2*0x45)\t \n#define EEPROM_OEM_MODE                     (2*0x46)\t \n#define EEPROM_WOWLAN_MODE                  (2*0x47)\t \n#define EEPROM_RADIO_CONFIG                 (2*0x48)\t \n#define EEPROM_NUM_MAC_ADDRESS              (2*0x4C)\t \n\n \n#define EEPROM_RF_CFG_TYPE_MSK(x)   (x & 0x3)\t \n#define EEPROM_RF_CFG_STEP_MSK(x)   ((x >> 2)  & 0x3)\t \n#define EEPROM_RF_CFG_DASH_MSK(x)   ((x >> 4)  & 0x3)\t \n#define EEPROM_RF_CFG_PNUM_MSK(x)   ((x >> 6)  & 0x3)\t \n#define EEPROM_RF_CFG_TX_ANT_MSK(x) ((x >> 8)  & 0xF)\t \n#define EEPROM_RF_CFG_RX_ANT_MSK(x) ((x >> 12) & 0xF)\t \n\n#define EEPROM_3945_RF_CFG_TYPE_MAX  0x0\n#define EEPROM_4965_RF_CFG_TYPE_MAX  0x1\n\n \n#define EEPROM_REGULATORY_SKU_ID            (2*0x60)\t \n#define EEPROM_REGULATORY_BAND_1            (2*0x62)\t \n#define EEPROM_REGULATORY_BAND_1_CHANNELS   (2*0x63)\t \n\n \n#define EEPROM_REGULATORY_BAND_2            (2*0x71)\t \n#define EEPROM_REGULATORY_BAND_2_CHANNELS   (2*0x72)\t \n\n \n#define EEPROM_REGULATORY_BAND_3            (2*0x7F)\t \n#define EEPROM_REGULATORY_BAND_3_CHANNELS   (2*0x80)\t \n\n \n#define EEPROM_REGULATORY_BAND_4            (2*0x8C)\t \n#define EEPROM_REGULATORY_BAND_4_CHANNELS   (2*0x8D)\t \n\n \n#define EEPROM_REGULATORY_BAND_5            (2*0x98)\t \n#define EEPROM_REGULATORY_BAND_5_CHANNELS   (2*0x99)\t \n\n \n#define EEPROM_4965_REGULATORY_BAND_24_HT40_CHANNELS (2*0xA0)\t \n\n \n#define EEPROM_4965_REGULATORY_BAND_52_HT40_CHANNELS (2*0xA8)\t \n\n#define EEPROM_REGULATORY_BAND_NO_HT40\t\t\t(0)\n\nint il_eeprom_init(struct il_priv *il);\nvoid il_eeprom_free(struct il_priv *il);\nconst u8 *il_eeprom_query_addr(const struct il_priv *il, size_t offset);\nu16 il_eeprom_query16(const struct il_priv *il, size_t offset);\nint il_init_channel_map(struct il_priv *il);\nvoid il_free_channel_map(struct il_priv *il);\nconst struct il_channel_info *il_get_channel_info(const struct il_priv *il,\n\t\t\t\t\t\t  enum nl80211_band band,\n\t\t\t\t\t\t  u16 channel);\n\n#define IL_NUM_SCAN_RATES         (2)\n\nstruct il4965_channel_tgd_info {\n\tu8 type;\n\ts8 max_power;\n};\n\nstruct il4965_channel_tgh_info {\n\ts64 last_radar_time;\n};\n\n#define IL4965_MAX_RATE (33)\n\nstruct il3945_clip_group {\n\t \n\tconst s8 clip_powers[IL_MAX_RATES];\n};\n\n \nstruct il3945_channel_power_info {\n\tstruct il3945_tx_power tpc;\t \n\ts8 power_table_idx;\t \n\ts8 base_power_idx;\t \n\ts8 requested_power;\t \n};\n\n \nstruct il3945_scan_power_info {\n\tstruct il3945_tx_power tpc;\t \n\ts8 power_table_idx;\t \n\ts8 requested_power;\t \n};\n\n \nstruct il_channel_info {\n\tstruct il4965_channel_tgd_info tgd;\n\tstruct il4965_channel_tgh_info tgh;\n\tstruct il_eeprom_channel eeprom;\t \n\tstruct il_eeprom_channel ht40_eeprom;\t \n\n\tu8 channel;\t\t \n\tu8 flags;\t\t \n\ts8 max_power_avg;\t \n\ts8 curr_txpow;\t\t \n\ts8 min_power;\t\t \n\ts8 scan_power;\t\t \n\n\tu8 group_idx;\t\t \n\tu8 band_idx;\t\t \n\tenum nl80211_band band;\n\n\t \n\ts8 ht40_max_power_avg;\t \n\tu8 ht40_flags;\t\t \n\tu8 ht40_extension_channel;\t \n\n\t \n\tstruct il3945_channel_power_info power_info[IL4965_MAX_RATE];\n\n\t \n\tstruct il3945_scan_power_info scan_pwr_info[IL_NUM_SCAN_RATES];\n};\n\n#define IL_TX_FIFO_BK\t\t0\t \n#define IL_TX_FIFO_BE\t\t1\n#define IL_TX_FIFO_VI\t\t2\t \n#define IL_TX_FIFO_VO\t\t3\n#define IL_TX_FIFO_UNUSED\t-1\n\n \n#define IL_MIN_NUM_QUEUES\t10\n\n#define IL_DEFAULT_CMD_QUEUE_NUM\t4\n\n#define IEEE80211_DATA_LEN              2304\n#define IEEE80211_4ADDR_LEN             30\n#define IEEE80211_HLEN                  (IEEE80211_4ADDR_LEN)\n#define IEEE80211_FRAME_LEN             (IEEE80211_DATA_LEN + IEEE80211_HLEN)\n\nstruct il_frame {\n\tunion {\n\t\tstruct ieee80211_hdr frame;\n\t\tstruct il_tx_beacon_cmd beacon;\n\t\tu8 raw[IEEE80211_FRAME_LEN];\n\t\tu8 cmd[360];\n\t} u;\n\tstruct list_head list;\n};\n\nenum {\n\tCMD_SYNC = 0,\n\tCMD_SIZE_NORMAL = 0,\n\tCMD_NO_SKB = 0,\n\tCMD_SIZE_HUGE = (1 << 0),\n\tCMD_ASYNC = (1 << 1),\n\tCMD_WANT_SKB = (1 << 2),\n\tCMD_MAPPED = (1 << 3),\n};\n\n#define DEF_CMD_PAYLOAD_SIZE 320\n\n \nstruct il_device_cmd {\n\tstruct il_cmd_header hdr;\t \n\tunion {\n\t\tu32 flags;\n\t\tu8 val8;\n\t\tu16 val16;\n\t\tu32 val32;\n\t\tstruct il_tx_cmd tx;\n\t\tu8 payload[DEF_CMD_PAYLOAD_SIZE];\n\t} __packed cmd;\n} __packed;\n\n#define TFD_MAX_PAYLOAD_SIZE (sizeof(struct il_device_cmd))\n\nstruct il_host_cmd {\n\tconst void *data;\n\tunsigned long reply_page;\n\tvoid (*callback) (struct il_priv *il, struct il_device_cmd *cmd,\n\t\t\t  struct il_rx_pkt *pkt);\n\tu32 flags;\n\tu16 len;\n\tu8 id;\n};\n\n#define SUP_RATE_11A_MAX_NUM_CHANNELS  8\n#define SUP_RATE_11B_MAX_NUM_CHANNELS  4\n#define SUP_RATE_11G_MAX_NUM_CHANNELS  12\n\n \nstruct il_rx_queue {\n\t__le32 *bd;\n\tdma_addr_t bd_dma;\n\tstruct il_rx_buf pool[RX_QUEUE_SIZE + RX_FREE_BUFFERS];\n\tstruct il_rx_buf *queue[RX_QUEUE_SIZE];\n\tu32 read;\n\tu32 write;\n\tu32 free_count;\n\tu32 write_actual;\n\tstruct list_head rx_free;\n\tstruct list_head rx_used;\n\tint need_update;\n\tstruct il_rb_status *rb_stts;\n\tdma_addr_t rb_stts_dma;\n\tspinlock_t lock;\n};\n\n#define IL_SUPPORTED_RATES_IE_LEN         8\n\n#define MAX_TID_COUNT        9\n\n#define IL_INVALID_RATE     0xFF\n#define IL_INVALID_VALUE    -1\n\n \nstruct il_ht_agg {\n\tu16 txq_id;\n\tu16 frame_count;\n\tu16 wait_for_ba;\n\tu16 start_idx;\n\tu64 bitmap;\n\tu32 rate_n_flags;\n#define IL_AGG_OFF 0\n#define IL_AGG_ON 1\n#define IL_EMPTYING_HW_QUEUE_ADDBA 2\n#define IL_EMPTYING_HW_QUEUE_DELBA 3\n\tu8 state;\n};\n\nstruct il_tid_data {\n\tu16 seq_number;\t\t \n\tu16 tfds_in_queue;\n\tstruct il_ht_agg agg;\n};\n\nstruct il_hw_key {\n\tu32 cipher;\n\tint keylen;\n\tu8 keyidx;\n\tu8 key[32];\n};\n\nunion il_ht_rate_supp {\n\tu16 rates;\n\tstruct {\n\t\tu8 siso_rate;\n\t\tu8 mimo_rate;\n\t};\n};\n\n#define CFG_HT_RX_AMPDU_FACTOR_8K   (0x0)\n#define CFG_HT_RX_AMPDU_FACTOR_16K  (0x1)\n#define CFG_HT_RX_AMPDU_FACTOR_32K  (0x2)\n#define CFG_HT_RX_AMPDU_FACTOR_64K  (0x3)\n#define CFG_HT_RX_AMPDU_FACTOR_DEF  CFG_HT_RX_AMPDU_FACTOR_64K\n#define CFG_HT_RX_AMPDU_FACTOR_MAX  CFG_HT_RX_AMPDU_FACTOR_64K\n#define CFG_HT_RX_AMPDU_FACTOR_MIN  CFG_HT_RX_AMPDU_FACTOR_8K\n\n \n#define CFG_HT_MPDU_DENSITY_2USEC   (0x4)\n#define CFG_HT_MPDU_DENSITY_4USEC   (0x5)\n#define CFG_HT_MPDU_DENSITY_8USEC   (0x6)\n#define CFG_HT_MPDU_DENSITY_16USEC  (0x7)\n#define CFG_HT_MPDU_DENSITY_DEF CFG_HT_MPDU_DENSITY_4USEC\n#define CFG_HT_MPDU_DENSITY_MAX CFG_HT_MPDU_DENSITY_16USEC\n#define CFG_HT_MPDU_DENSITY_MIN     (0x1)\n\nstruct il_ht_config {\n\tbool single_chain_sufficient;\n\tenum ieee80211_smps_mode smps;\t \n};\n\n \nstruct il_qos_info {\n\tint qos_active;\n\tstruct il_qosparam_cmd def_qos_parm;\n};\n\n \nstruct il_station_entry {\n\tstruct il_addsta_cmd sta;\n\tstruct il_tid_data tid[MAX_TID_COUNT];\n\tu8 used;\n\tstruct il_hw_key keyinfo;\n\tstruct il_link_quality_cmd *lq;\n};\n\nstruct il_station_priv_common {\n\tu8 sta_id;\n};\n\n \nstruct il_vif_priv {\n\tu8 ibss_bssid_sta_id;\n};\n\n \nstruct fw_desc {\n\tvoid *v_addr;\t\t \n\tdma_addr_t p_addr;\t \n\tu32 len;\t\t \n};\n\n \nstruct il_ucode_header {\n\t__le32 ver;\t\t \n\tstruct {\n\t\t__le32 inst_size;\t \n\t\t__le32 data_size;\t \n\t\t__le32 init_size;\t \n\t\t__le32 init_data_size;\t \n\t\t__le32 boot_size;\t \n\t\tu8 data[0];\t \n\t} v1;\n};\n\nstruct il4965_ibss_seq {\n\tu8 mac[ETH_ALEN];\n\tu16 seq_num;\n\tu16 frag_num;\n\tunsigned long packet_time;\n\tstruct list_head list;\n};\n\nstruct il_sensitivity_ranges {\n\tu16 min_nrg_cck;\n\tu16 max_nrg_cck;\n\n\tu16 nrg_th_cck;\n\tu16 nrg_th_ofdm;\n\n\tu16 auto_corr_min_ofdm;\n\tu16 auto_corr_min_ofdm_mrc;\n\tu16 auto_corr_min_ofdm_x1;\n\tu16 auto_corr_min_ofdm_mrc_x1;\n\n\tu16 auto_corr_max_ofdm;\n\tu16 auto_corr_max_ofdm_mrc;\n\tu16 auto_corr_max_ofdm_x1;\n\tu16 auto_corr_max_ofdm_mrc_x1;\n\n\tu16 auto_corr_max_cck;\n\tu16 auto_corr_max_cck_mrc;\n\tu16 auto_corr_min_cck;\n\tu16 auto_corr_min_cck_mrc;\n\n\tu16 barker_corr_th_min;\n\tu16 barker_corr_th_min_mrc;\n\tu16 nrg_th_cca;\n};\n\n \nstruct il_hw_params {\n\tu8 bcast_id;\n\tu8 max_txq_num;\n\tu8 dma_chnl_num;\n\tu16 scd_bc_tbls_size;\n\tu32 tfd_size;\n\tu8 tx_chains_num;\n\tu8 rx_chains_num;\n\tu8 valid_tx_ant;\n\tu8 valid_rx_ant;\n\tu16 max_rxq_size;\n\tu16 max_rxq_log;\n\tu32 rx_page_order;\n\tu32 rx_wrt_ptr_reg;\n\tu8 max_stations;\n\tu8 ht40_channel;\n\tu8 max_beacon_itrvl;\t \n\tu32 max_inst_size;\n\tu32 max_data_size;\n\tu32 max_bsm_size;\n\tu32 ct_kill_threshold;\t \n\tu16 beacon_time_tsf_bits;\n\tconst struct il_sensitivity_ranges *sens;\n};\n\n \nvoid il4965_update_chain_flags(struct il_priv *il);\nextern const u8 il_bcast_addr[ETH_ALEN];\nint il_queue_space(const struct il_queue *q);\nstatic inline int\nil_queue_used(const struct il_queue *q, int i)\n{\n\treturn q->write_ptr >= q->read_ptr ? (i >= q->read_ptr &&\n\t\t\t\t\t      i < q->write_ptr) : !(i <\n\t\t\t\t\t\t\t\t    q->read_ptr\n\t\t\t\t\t\t\t\t    && i >=\n\t\t\t\t\t\t\t\t    q->\n\t\t\t\t\t\t\t\t    write_ptr);\n}\n\nstatic inline u8\nil_get_cmd_idx(struct il_queue *q, u32 idx, int is_huge)\n{\n\t \n\tif (is_huge)\n\t\treturn q->n_win;\t \n\n\t \n\treturn idx & (q->n_win - 1);\n}\n\nstruct il_dma_ptr {\n\tdma_addr_t dma;\n\tvoid *addr;\n\tsize_t size;\n};\n\n#define IL_OPERATION_MODE_AUTO     0\n#define IL_OPERATION_MODE_HT_ONLY  1\n#define IL_OPERATION_MODE_MIXED    2\n#define IL_OPERATION_MODE_20MHZ    3\n\n#define IL_TX_CRC_SIZE 4\n#define IL_TX_DELIMITER_SIZE 4\n\n#define TX_POWER_IL_ILLEGAL_VOLTAGE -10000\n\n \n#define INITIALIZATION_VALUE\t\t0xFFFF\n#define IL4965_CAL_NUM_BEACONS\t\t20\n#define IL_CAL_NUM_BEACONS\t\t16\n#define MAXIMUM_ALLOWED_PATHLOSS\t15\n\n#define CHAIN_NOISE_MAX_DELTA_GAIN_CODE 3\n\n#define MAX_FA_OFDM  50\n#define MIN_FA_OFDM  5\n#define MAX_FA_CCK   50\n#define MIN_FA_CCK   5\n\n#define AUTO_CORR_STEP_OFDM       1\n\n#define AUTO_CORR_STEP_CCK     3\n#define AUTO_CORR_MAX_TH_CCK   160\n\n#define NRG_DIFF               2\n#define NRG_STEP_CCK           2\n#define NRG_MARGIN             8\n#define MAX_NUMBER_CCK_NO_FA 100\n\n#define AUTO_CORR_CCK_MIN_VAL_DEF    (125)\n\n#define CHAIN_A             0\n#define CHAIN_B             1\n#define CHAIN_C             2\n#define CHAIN_NOISE_DELTA_GAIN_INIT_VAL 4\n#define ALL_BAND_FILTER\t\t\t0xFF00\n#define IN_BAND_FILTER\t\t\t0xFF\n#define MIN_AVERAGE_NOISE_MAX_VALUE\t0xFFFFFFFF\n\n#define NRG_NUM_PREV_STAT_L     20\n#define NUM_RX_CHAINS           3\n\nenum il4965_false_alarm_state {\n\tIL_FA_TOO_MANY = 0,\n\tIL_FA_TOO_FEW = 1,\n\tIL_FA_GOOD_RANGE = 2,\n};\n\nenum il4965_chain_noise_state {\n\tIL_CHAIN_NOISE_ALIVE = 0,\t \n\tIL_CHAIN_NOISE_ACCUMULATE,\n\tIL_CHAIN_NOISE_CALIBRATED,\n\tIL_CHAIN_NOISE_DONE,\n};\n\nenum ucode_type {\n\tUCODE_NONE = 0,\n\tUCODE_INIT,\n\tUCODE_RT\n};\n\n \nstruct il_sensitivity_data {\n\tu32 auto_corr_ofdm;\n\tu32 auto_corr_ofdm_mrc;\n\tu32 auto_corr_ofdm_x1;\n\tu32 auto_corr_ofdm_mrc_x1;\n\tu32 auto_corr_cck;\n\tu32 auto_corr_cck_mrc;\n\n\tu32 last_bad_plcp_cnt_ofdm;\n\tu32 last_fa_cnt_ofdm;\n\tu32 last_bad_plcp_cnt_cck;\n\tu32 last_fa_cnt_cck;\n\n\tu32 nrg_curr_state;\n\tu32 nrg_prev_state;\n\tu32 nrg_value[10];\n\tu8 nrg_silence_rssi[NRG_NUM_PREV_STAT_L];\n\tu32 nrg_silence_ref;\n\tu32 nrg_energy_idx;\n\tu32 nrg_silence_idx;\n\tu32 nrg_th_cck;\n\ts32 nrg_auto_corr_silence_diff;\n\tu32 num_in_cck_no_fa;\n\tu32 nrg_th_ofdm;\n\n\tu16 barker_corr_th_min;\n\tu16 barker_corr_th_min_mrc;\n\tu16 nrg_th_cca;\n};\n\n \nstruct il_chain_noise_data {\n\tu32 active_chains;\n\tu32 chain_noise_a;\n\tu32 chain_noise_b;\n\tu32 chain_noise_c;\n\tu32 chain_signal_a;\n\tu32 chain_signal_b;\n\tu32 chain_signal_c;\n\tu16 beacon_count;\n\tu8 disconn_array[NUM_RX_CHAINS];\n\tu8 delta_gain_code[NUM_RX_CHAINS];\n\tu8 radio_write;\n\tu8 state;\n};\n\n#define\tEEPROM_SEM_TIMEOUT 10\t \n#define EEPROM_SEM_RETRY_LIMIT 1000\t \n\n#define IL_TRAFFIC_ENTRIES\t(256)\n#define IL_TRAFFIC_ENTRY_SIZE  (64)\n\nenum {\n\tMEASUREMENT_READY = (1 << 0),\n\tMEASUREMENT_ACTIVE = (1 << 1),\n};\n\n \nstruct isr_stats {\n\tu32 hw;\n\tu32 sw;\n\tu32 err_code;\n\tu32 sch;\n\tu32 alive;\n\tu32 rfkill;\n\tu32 ctkill;\n\tu32 wakeup;\n\tu32 rx;\n\tu32 handlers[IL_CN_MAX];\n\tu32 tx;\n\tu32 unhandled;\n};\n\n \nenum il_mgmt_stats {\n\tMANAGEMENT_ASSOC_REQ = 0,\n\tMANAGEMENT_ASSOC_RESP,\n\tMANAGEMENT_REASSOC_REQ,\n\tMANAGEMENT_REASSOC_RESP,\n\tMANAGEMENT_PROBE_REQ,\n\tMANAGEMENT_PROBE_RESP,\n\tMANAGEMENT_BEACON,\n\tMANAGEMENT_ATIM,\n\tMANAGEMENT_DISASSOC,\n\tMANAGEMENT_AUTH,\n\tMANAGEMENT_DEAUTH,\n\tMANAGEMENT_ACTION,\n\tMANAGEMENT_MAX,\n};\n \nenum il_ctrl_stats {\n\tCONTROL_BACK_REQ = 0,\n\tCONTROL_BACK,\n\tCONTROL_PSPOLL,\n\tCONTROL_RTS,\n\tCONTROL_CTS,\n\tCONTROL_ACK,\n\tCONTROL_CFEND,\n\tCONTROL_CFENDACK,\n\tCONTROL_MAX,\n};\n\nstruct traffic_stats {\n#ifdef CONFIG_IWLEGACY_DEBUGFS\n\tu32 mgmt[MANAGEMENT_MAX];\n\tu32 ctrl[CONTROL_MAX];\n\tu32 data_cnt;\n\tu64 data_bytes;\n#endif\n};\n\n \n#define IL_HOST_INT_TIMEOUT_MAX\t(0xFF)\n#define IL_HOST_INT_TIMEOUT_DEF\t(0x40)\n#define IL_HOST_INT_TIMEOUT_MIN\t(0x0)\n#define IL_HOST_INT_CALIB_TIMEOUT_MAX\t(0xFF)\n#define IL_HOST_INT_CALIB_TIMEOUT_DEF\t(0x10)\n#define IL_HOST_INT_CALIB_TIMEOUT_MIN\t(0x0)\n\n#define IL_DELAY_NEXT_FORCE_FW_RELOAD (HZ*5)\n\n \n#define IL_DEF_WD_TIMEOUT\t(2000)\n#define IL_LONG_WD_TIMEOUT\t(10000)\n#define IL_MAX_WD_TIMEOUT\t(120000)\n\nstruct il_force_reset {\n\tint reset_request_count;\n\tint reset_success_count;\n\tint reset_reject_count;\n\tunsigned long reset_duration;\n\tunsigned long last_force_reset_jiffies;\n};\n\n \n \n#define IL3945_EXT_BEACON_TIME_POS\t24\n \n#define IL4965_EXT_BEACON_TIME_POS\t22\n\nstruct il_rxon_context {\n\tstruct ieee80211_vif *vif;\n};\n\nstruct il_power_mgr {\n\tstruct il_powertable_cmd sleep_cmd;\n\tstruct il_powertable_cmd sleep_cmd_next;\n\tint debug_sleep_level_override;\n\tbool pci_pm;\n\tbool ps_disabled;\n};\n\nstruct il_priv {\n\tstruct ieee80211_hw *hw;\n\tstruct ieee80211_channel *ieee_channels;\n\tstruct ieee80211_rate *ieee_rates;\n\n\tstruct il_cfg *cfg;\n\tconst struct il_ops *ops;\n#ifdef CONFIG_IWLEGACY_DEBUGFS\n\tconst struct il_debugfs_ops *debugfs_ops;\n#endif\n\n\t \n\tstruct list_head free_frames;\n\tint frames_count;\n\n\tenum nl80211_band band;\n\tint alloc_rxb_page;\n\n\tvoid (*handlers[IL_CN_MAX]) (struct il_priv *il,\n\t\t\t\t     struct il_rx_buf *rxb);\n\n\tstruct ieee80211_supported_band bands[NUM_NL80211_BANDS];\n\n\t \n\tstruct il_spectrum_notification measure_report;\n\tu8 measurement_status;\n\n\t \n\tu32 ucode_beacon_time;\n\tint missed_beacon_threshold;\n\n\t \n\tu32 ibss_manager;\n\n\t \n\tstruct il_force_reset force_reset;\n\n\t \n\tstruct il_channel_info *channel_info;\t \n\tu8 channel_count;\t \n\n\t \n\ts32 temperature;\t \n\ts32 last_temperature;\n\n\t \n\tunsigned long scan_start;\n\tunsigned long scan_start_tsf;\n\tvoid *scan_cmd;\n\tenum nl80211_band scan_band;\n\tstruct cfg80211_scan_request *scan_request;\n\tstruct ieee80211_vif *scan_vif;\n\tu8 scan_tx_ant[NUM_NL80211_BANDS];\n\tu8 mgmt_tx_ant;\n\n\t \n\tspinlock_t lock;\t \n\tspinlock_t hcmd_lock;\t \n\tspinlock_t reg_lock;\t \n\tstruct mutex mutex;\n\n\t \n\tstruct pci_dev *pci_dev;\n\n\t \n\tvoid __iomem *hw_base;\n\tu32 hw_rev;\n\tu32 hw_wa_rev;\n\tu8 rev_id;\n\n\t \n\tu8 cmd_queue;\n\n\t \n\tu8 sta_key_max_num;\n\n\t \n\tstruct mac_address addresses[1];\n\n\t \n\tint fw_idx;\t\t \n\tu32 ucode_ver;\t\t \n\tstruct fw_desc ucode_code;\t \n\tstruct fw_desc ucode_data;\t \n\tstruct fw_desc ucode_data_backup;\t \n\tstruct fw_desc ucode_init;\t \n\tstruct fw_desc ucode_init_data;\t \n\tstruct fw_desc ucode_boot;\t \n\tenum ucode_type ucode_type;\n\tu8 ucode_write_complete;\t \n\tchar firmware_name[25];\n\n\tstruct ieee80211_vif *vif;\n\n\tstruct il_qos_info qos_data;\n\n\tstruct {\n\t\tbool enabled;\n\t\tbool is_40mhz;\n\t\tbool non_gf_sta_present;\n\t\tu8 protection;\n\t\tu8 extension_chan_offset;\n\t} ht;\n\n\t \n\tconst struct il_rxon_cmd active;\n\tstruct il_rxon_cmd staging;\n\n\tstruct il_rxon_time_cmd timing;\n\n\t__le16 switch_channel;\n\n\t \n\tstruct il_init_alive_resp card_alive_init;\n\tstruct il_alive_resp card_alive;\n\n\tu16 active_rate;\n\n\tu8 start_calib;\n\tstruct il_sensitivity_data sensitivity_data;\n\tstruct il_chain_noise_data chain_noise_data;\n\t__le16 sensitivity_tbl[HD_TBL_SIZE];\n\n\tstruct il_ht_config current_ht_config;\n\n\t \n\tu8 retry_rate;\n\n\twait_queue_head_t wait_command_queue;\n\n\tint activity_timer_active;\n\n\t \n\tstruct il_rx_queue rxq;\n\tstruct il_tx_queue *txq;\n\tunsigned long txq_ctx_active_msk;\n\tstruct il_dma_ptr kw;\t \n\tstruct il_dma_ptr scd_bc_tbls;\n\n\tu32 scd_base_addr;\t \n\n\tunsigned long status;\n\n\t \n\tstruct traffic_stats tx_stats;\n\tstruct traffic_stats rx_stats;\n\n\t \n\tstruct isr_stats isr_stats;\n\n\tstruct il_power_mgr power_data;\n\n\t \n\tu8 bssid[ETH_ALEN];\t \n\n\t \n\n\t \n\tspinlock_t sta_lock;\n\tint num_stations;\n\tstruct il_station_entry stations[IL_STATION_COUNT];\n\tunsigned long ucode_key_table;\n\n\t \n#define IL_MAX_HW_QUEUES\t32\n\tunsigned long queue_stopped[BITS_TO_LONGS(IL_MAX_HW_QUEUES)];\n#define IL_STOP_REASON_PASSIVE\t0\n\tunsigned long stop_reason;\n\t \n\tatomic_t queue_stop_count[4];\n\n\t \n\tu8 is_open;\n\n\tu8 mac80211_registered;\n\n\t \n\tu8 *eeprom;\n\tstruct il_eeprom_calib_info *calib_info;\n\n\tenum nl80211_iftype iw_mode;\n\n\t \n\tu64 timestamp;\n\n\tunion {\n#if IS_ENABLED(CONFIG_IWL3945)\n\t\tstruct {\n\t\t\tvoid *shared_virt;\n\t\t\tdma_addr_t shared_phys;\n\n\t\t\tstruct delayed_work thermal_periodic;\n\t\t\tstruct delayed_work rfkill_poll;\n\n\t\t\tstruct il3945_notif_stats stats;\n#ifdef CONFIG_IWLEGACY_DEBUGFS\n\t\t\tstruct il3945_notif_stats accum_stats;\n\t\t\tstruct il3945_notif_stats delta_stats;\n\t\t\tstruct il3945_notif_stats max_delta;\n#endif\n\n\t\t\tu32 sta_supp_rates;\n\t\t\tint last_rx_rssi;\t \n\n\t\t\t \n\t\t\tu32 last_beacon_time;\n\t\t\tu64 last_tsf;\n\n\t\t\t \n\t\t\tconst struct il3945_clip_group clip_groups[5];\n\n\t\t} _3945;\n#endif\n#if IS_ENABLED(CONFIG_IWL4965)\n\t\tstruct {\n\t\t\tstruct il_rx_phy_res last_phy_res;\n\t\t\tbool last_phy_res_valid;\n\t\t\tu32 ampdu_ref;\n\n\t\t\tstruct completion firmware_loading_complete;\n\n\t\t\t \n\t\t\tu8 phy_calib_chain_noise_reset_cmd;\n\t\t\tu8 phy_calib_chain_noise_gain_cmd;\n\n\t\t\tu8 key_mapping_keys;\n\t\t\tstruct il_wep_key wep_keys[WEP_KEYS_MAX];\n\n\t\t\tstruct il_notif_stats stats;\n#ifdef CONFIG_IWLEGACY_DEBUGFS\n\t\t\tstruct il_notif_stats accum_stats;\n\t\t\tstruct il_notif_stats delta_stats;\n\t\t\tstruct il_notif_stats max_delta;\n#endif\n\n\t\t} _4965;\n#endif\n\t};\n\n\tstruct il_hw_params hw_params;\n\n\tu32 inta_mask;\n\n\tstruct workqueue_struct *workqueue;\n\n\tstruct work_struct restart;\n\tstruct work_struct scan_completed;\n\tstruct work_struct rx_replenish;\n\tstruct work_struct abort_scan;\n\n\tbool beacon_enabled;\n\tstruct sk_buff *beacon_skb;\n\n\tstruct work_struct tx_flush;\n\n\tstruct tasklet_struct irq_tasklet;\n\n\tstruct delayed_work init_alive_start;\n\tstruct delayed_work alive_start;\n\tstruct delayed_work scan_check;\n\n\t \n\ts8 tx_power_user_lmt;\n\ts8 tx_power_device_lmt;\n\ts8 tx_power_next;\n\n#ifdef CONFIG_IWLEGACY_DEBUG\n\t \n\tu32 debug_level;\t \n#endif\t\t\t\t \n#ifdef CONFIG_IWLEGACY_DEBUGFS\n\t \n\tu16 tx_traffic_idx;\n\tu16 rx_traffic_idx;\n\tu8 *tx_traffic;\n\tu8 *rx_traffic;\n\tstruct dentry *debugfs_dir;\n\tu32 dbgfs_sram_offset, dbgfs_sram_len;\n\tbool disable_ht40;\n#endif\t\t\t\t \n\n\tstruct work_struct txpower_work;\n\tbool disable_sens_cal;\n\tbool disable_chain_noise_cal;\n\tbool disable_tx_power_cal;\n\tstruct work_struct run_time_calib_work;\n\tstruct timer_list stats_periodic;\n\tstruct timer_list watchdog;\n\tbool hw_ready;\n\n\tstruct led_classdev led;\n\tunsigned long blink_on, blink_off;\n\tbool led_registered;\n};\t\t\t\t \n\nstatic inline void\nil_txq_ctx_activate(struct il_priv *il, int txq_id)\n{\n\tset_bit(txq_id, &il->txq_ctx_active_msk);\n}\n\nstatic inline void\nil_txq_ctx_deactivate(struct il_priv *il, int txq_id)\n{\n\tclear_bit(txq_id, &il->txq_ctx_active_msk);\n}\n\nstatic inline int\nil_is_associated(struct il_priv *il)\n{\n\treturn (il->active.filter_flags & RXON_FILTER_ASSOC_MSK) ? 1 : 0;\n}\n\nstatic inline int\nil_is_any_associated(struct il_priv *il)\n{\n\treturn il_is_associated(il);\n}\n\nstatic inline int\nil_is_channel_valid(const struct il_channel_info *ch_info)\n{\n\tif (ch_info == NULL)\n\t\treturn 0;\n\treturn (ch_info->flags & EEPROM_CHANNEL_VALID) ? 1 : 0;\n}\n\nstatic inline int\nil_is_channel_radar(const struct il_channel_info *ch_info)\n{\n\treturn (ch_info->flags & EEPROM_CHANNEL_RADAR) ? 1 : 0;\n}\n\nstatic inline u8\nil_is_channel_a_band(const struct il_channel_info *ch_info)\n{\n\treturn ch_info->band == NL80211_BAND_5GHZ;\n}\n\nstatic inline int\nil_is_channel_passive(const struct il_channel_info *ch)\n{\n\treturn (!(ch->flags & EEPROM_CHANNEL_ACTIVE)) ? 1 : 0;\n}\n\nstatic inline int\nil_is_channel_ibss(const struct il_channel_info *ch)\n{\n\treturn (ch->flags & EEPROM_CHANNEL_IBSS) ? 1 : 0;\n}\n\nstatic inline void\n__il_free_pages(struct il_priv *il, struct page *page)\n{\n\t__free_pages(page, il->hw_params.rx_page_order);\n\til->alloc_rxb_page--;\n}\n\nstatic inline void\nil_free_pages(struct il_priv *il, unsigned long page)\n{\n\tfree_pages(page, il->hw_params.rx_page_order);\n\til->alloc_rxb_page--;\n}\n\n#define IWLWIFI_VERSION \"in-tree:\"\n#define DRV_COPYRIGHT\t\"Copyright(c) 2003-2011 Intel Corporation\"\n#define DRV_AUTHOR     \"<ilw@linux.intel.com>\"\n\n#define IL_PCI_DEVICE(dev, subdev, cfg) \\\n\t.vendor = PCI_VENDOR_ID_INTEL,  .device = (dev), \\\n\t.subvendor = PCI_ANY_ID, .subdevice = (subdev), \\\n\t.driver_data = (kernel_ulong_t)&(cfg)\n\n#define TIME_UNIT\t\t1024\n\n#define IL_SKU_G       0x1\n#define IL_SKU_A       0x2\n#define IL_SKU_N       0x8\n\n#define IL_CMD(x) case x: return #x\n\n \n#define IL_RX_BUF_SIZE_3K (3 * 1000)\t \n#define IL_RX_BUF_SIZE_4K (4 * 1024)\n#define IL_RX_BUF_SIZE_8K (8 * 1024)\n\n#ifdef CONFIG_IWLEGACY_DEBUGFS\nstruct il_debugfs_ops {\n\tssize_t(*rx_stats_read) (struct file *file, char __user *user_buf,\n\t\t\t\t size_t count, loff_t *ppos);\n\tssize_t(*tx_stats_read) (struct file *file, char __user *user_buf,\n\t\t\t\t size_t count, loff_t *ppos);\n\tssize_t(*general_stats_read) (struct file *file,\n\t\t\t\t      char __user *user_buf, size_t count,\n\t\t\t\t      loff_t *ppos);\n};\n#endif\n\nstruct il_ops {\n\t \n\tvoid (*txq_update_byte_cnt_tbl) (struct il_priv *il,\n\t\t\t\t\t struct il_tx_queue *txq,\n\t\t\t\t\t u16 byte_cnt);\n\tint (*txq_attach_buf_to_tfd) (struct il_priv *il,\n\t\t\t\t      struct il_tx_queue *txq, dma_addr_t addr,\n\t\t\t\t      u16 len, u8 reset, u8 pad);\n\tvoid (*txq_free_tfd) (struct il_priv *il, struct il_tx_queue *txq);\n\tint (*txq_init) (struct il_priv *il, struct il_tx_queue *txq);\n\t \n\tvoid (*init_alive_start) (struct il_priv *il);\n\t \n\tint (*is_valid_rtc_data_addr) (u32 addr);\n\t \n\tint (*load_ucode) (struct il_priv *il);\n\n\tvoid (*dump_nic_error_log) (struct il_priv *il);\n\tint (*dump_fh) (struct il_priv *il, char **buf, bool display);\n\tint (*set_channel_switch) (struct il_priv *il,\n\t\t\t\t   struct ieee80211_channel_switch *ch_switch);\n\t \n\tint (*apm_init) (struct il_priv *il);\n\n\t \n\tint (*send_tx_power) (struct il_priv *il);\n\tvoid (*update_chain_flags) (struct il_priv *il);\n\n\t \n\tint (*eeprom_acquire_semaphore) (struct il_priv *il);\n\tvoid (*eeprom_release_semaphore) (struct il_priv *il);\n\n\tint (*rxon_assoc) (struct il_priv *il);\n\tint (*commit_rxon) (struct il_priv *il);\n\tvoid (*set_rxon_chain) (struct il_priv *il);\n\n\tu16(*get_hcmd_size) (u8 cmd_id, u16 len);\n\tu16(*build_addsta_hcmd) (const struct il_addsta_cmd *cmd, u8 *data);\n\n\tint (*request_scan) (struct il_priv *il, struct ieee80211_vif *vif);\n\tvoid (*post_scan) (struct il_priv *il);\n\tvoid (*post_associate) (struct il_priv *il);\n\tvoid (*config_ap) (struct il_priv *il);\n\t \n\tint (*update_bcast_stations) (struct il_priv *il);\n\tint (*manage_ibss_station) (struct il_priv *il,\n\t\t\t\t    struct ieee80211_vif *vif, bool add);\n\n\tint (*send_led_cmd) (struct il_priv *il, struct il_led_cmd *led_cmd);\n};\n\nstruct il_mod_params {\n\tint sw_crypto;\t\t \n\tint disable_hw_scan;\t \n\tint num_of_queues;\t \n\tint disable_11n;\t \n\tint amsdu_size_8K;\t \n\tint antenna;\t\t \n\tint restart_fw;\t\t \n};\n\n#define IL_LED_SOLID 11\n#define IL_DEF_LED_INTRVL cpu_to_le32(1000)\n\n#define IL_LED_ACTIVITY       (0<<1)\n#define IL_LED_LINK           (1<<1)\n\n \nenum il_led_mode {\n\tIL_LED_DEFAULT,\n\tIL_LED_RF_STATE,\n\tIL_LED_BLINK,\n};\n\nvoid il_leds_init(struct il_priv *il);\nvoid il_leds_exit(struct il_priv *il);\n\n \nstruct il_cfg {\n\t \n\tconst char *name;\n\tconst char *fw_name_pre;\n\tconst unsigned int ucode_api_max;\n\tconst unsigned int ucode_api_min;\n\tu8 valid_tx_ant;\n\tu8 valid_rx_ant;\n\tunsigned int sku;\n\tu16 eeprom_ver;\n\tu16 eeprom_calib_ver;\n\t \n\tconst struct il_mod_params *mod_params;\n\t \n\tstruct il_base_params *base_params;\n\t \n\tu8 scan_rx_antennas[NUM_NL80211_BANDS];\n\tenum il_led_mode led_mode;\n\n\tint eeprom_size;\n\tint num_of_queues;\t\t \n\tint num_of_ampdu_queues;\t \n\t \n\tu32 pll_cfg_val;\n\tbool set_l0s;\n\tbool use_bsm;\n\n\tu16 led_compensation;\n\tint chain_noise_num_beacons;\n\tunsigned int wd_timeout;\n\tbool temperature_kelvin;\n\tconst bool ucode_tracing;\n\tconst bool sensitivity_calib_by_driver;\n\tconst bool chain_noise_calib_by_driver;\n\n\tconst u32 regulatory_bands[7];\n};\n\n \n\nint il_mac_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t   unsigned int link_id, u16 queue,\n\t\t   const struct ieee80211_tx_queue_params *params);\nint il_mac_tx_last_beacon(struct ieee80211_hw *hw);\n\nvoid il_set_rxon_hwcrypto(struct il_priv *il, int hw_decrypt);\nint il_check_rxon_cmd(struct il_priv *il);\nint il_full_rxon_required(struct il_priv *il);\nint il_set_rxon_channel(struct il_priv *il, struct ieee80211_channel *ch);\nvoid il_set_flags_for_band(struct il_priv *il, enum nl80211_band band,\n\t\t\t   struct ieee80211_vif *vif);\nu8 il_get_single_channel_number(struct il_priv *il, enum nl80211_band band);\nvoid il_set_rxon_ht(struct il_priv *il, struct il_ht_config *ht_conf);\nbool il_is_ht40_tx_allowed(struct il_priv *il,\n\t\t\t   struct ieee80211_sta_ht_cap *ht_cap);\nvoid il_connection_init_rx_config(struct il_priv *il);\nvoid il_set_rate(struct il_priv *il);\nint il_set_decrypted_flag(struct il_priv *il, struct ieee80211_hdr *hdr,\n\t\t\t  u32 decrypt_res, struct ieee80211_rx_status *stats);\nvoid il_irq_handle_error(struct il_priv *il);\nint il_mac_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\nvoid il_mac_remove_interface(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif);\nint il_mac_change_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t    enum nl80211_iftype newtype, bool newp2p);\nvoid il_mac_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t  u32 queues, bool drop);\nint il_alloc_txq_mem(struct il_priv *il);\nvoid il_free_txq_mem(struct il_priv *il);\n\n#ifdef CONFIG_IWLEGACY_DEBUGFS\nvoid il_update_stats(struct il_priv *il, bool is_tx, __le16 fc, u16 len);\n#else\nstatic inline void\nil_update_stats(struct il_priv *il, bool is_tx, __le16 fc, u16 len)\n{\n}\n#endif\n\n \nvoid il_hdl_pm_sleep(struct il_priv *il, struct il_rx_buf *rxb);\nvoid il_hdl_pm_debug_stats(struct il_priv *il, struct il_rx_buf *rxb);\nvoid il_hdl_error(struct il_priv *il, struct il_rx_buf *rxb);\nvoid il_hdl_csa(struct il_priv *il, struct il_rx_buf *rxb);\n\n \nvoid il_cmd_queue_unmap(struct il_priv *il);\nvoid il_cmd_queue_free(struct il_priv *il);\nint il_rx_queue_alloc(struct il_priv *il);\nvoid il_rx_queue_update_write_ptr(struct il_priv *il, struct il_rx_queue *q);\nint il_rx_queue_space(const struct il_rx_queue *q);\nvoid il_tx_cmd_complete(struct il_priv *il, struct il_rx_buf *rxb);\n\nvoid il_hdl_spectrum_measurement(struct il_priv *il, struct il_rx_buf *rxb);\nvoid il_recover_from_stats(struct il_priv *il, struct il_rx_pkt *pkt);\nvoid il_chswitch_done(struct il_priv *il, bool is_success);\n\n \nvoid il_txq_update_write_ptr(struct il_priv *il, struct il_tx_queue *txq);\nint il_tx_queue_init(struct il_priv *il, u32 txq_id);\nvoid il_tx_queue_reset(struct il_priv *il, u32 txq_id);\nvoid il_tx_queue_unmap(struct il_priv *il, int txq_id);\nvoid il_tx_queue_free(struct il_priv *il, int txq_id);\nvoid il_setup_watchdog(struct il_priv *il);\n \nint il_set_tx_power(struct il_priv *il, s8 tx_power, bool force);\n\n \n\nu8 il_get_lowest_plcp(struct il_priv *il);\n\n \nvoid il_init_scan_params(struct il_priv *il);\nint il_scan_cancel(struct il_priv *il);\nint il_scan_cancel_timeout(struct il_priv *il, unsigned long ms);\nvoid il_force_scan_end(struct il_priv *il);\nint il_mac_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t   struct ieee80211_scan_request *hw_req);\nvoid il_internal_short_hw_scan(struct il_priv *il);\nint il_force_reset(struct il_priv *il, bool external);\nu16 il_fill_probe_req(struct il_priv *il, struct ieee80211_mgmt *frame,\n\t\t      const u8 *ta, const u8 *ie, int ie_len, int left);\nvoid il_setup_rx_scan_handlers(struct il_priv *il);\nu16 il_get_active_dwell_time(struct il_priv *il, enum nl80211_band band,\n\t\t\t     u8 n_probes);\nu16 il_get_passive_dwell_time(struct il_priv *il, enum nl80211_band band,\n\t\t\t      struct ieee80211_vif *vif);\nvoid il_setup_scan_deferred_work(struct il_priv *il);\nvoid il_cancel_scan_deferred_work(struct il_priv *il);\n\n \n#define IL_ACTIVE_QUIET_TIME       cpu_to_le16(10)\t \n#define IL_PLCP_QUIET_THRESH       cpu_to_le16(1)\t \n\n#define IL_SCAN_CHECK_WATCHDOG\t\t(HZ * 7)\n\n \n\nconst char *il_get_cmd_string(u8 cmd);\nint __must_check il_send_cmd_sync(struct il_priv *il, struct il_host_cmd *cmd);\nint il_send_cmd(struct il_priv *il, struct il_host_cmd *cmd);\nint __must_check il_send_cmd_pdu(struct il_priv *il, u8 id, u16 len,\n\t\t\t\t const void *data);\nint il_send_cmd_pdu_async(struct il_priv *il, u8 id, u16 len, const void *data,\n\t\t\t  void (*callback) (struct il_priv *il,\n\t\t\t\t\t    struct il_device_cmd *cmd,\n\t\t\t\t\t    struct il_rx_pkt *pkt));\n\nint il_enqueue_hcmd(struct il_priv *il, struct il_host_cmd *cmd);\n\n \n\nvoid il_bg_watchdog(struct timer_list *t);\nu32 il_usecs_to_beacons(struct il_priv *il, u32 usec, u32 beacon_interval);\n__le32 il_add_beacon_time(struct il_priv *il, u32 base, u32 addon,\n\t\t\t  u32 beacon_interval);\n\n#ifdef CONFIG_PM_SLEEP\nextern const struct dev_pm_ops il_pm_ops;\n\n#define IL_LEGACY_PM_OPS\t(&il_pm_ops)\n\n#else  \n\n#define IL_LEGACY_PM_OPS\tNULL\n\n#endif  \n\n \nvoid il4965_dump_nic_error_log(struct il_priv *il);\n#ifdef CONFIG_IWLEGACY_DEBUG\nvoid il_print_rx_config_cmd(struct il_priv *il);\n#else\nstatic inline void\nil_print_rx_config_cmd(struct il_priv *il)\n{\n}\n#endif\n\nvoid il_clear_isr_stats(struct il_priv *il);\n\n \nint il_init_geos(struct il_priv *il);\nvoid il_free_geos(struct il_priv *il);\n\n \n\n#define S_HCMD_ACTIVE\t0\t \n \n#define S_INT_ENABLED\t2\n#define S_RFKILL\t3\n#define S_CT_KILL\t\t4\n#define S_INIT\t\t5\n#define S_ALIVE\t\t6\n#define S_READY\t\t7\n#define S_TEMPERATURE\t8\n#define S_GEO_CONFIGURED\t9\n#define S_EXIT_PENDING\t10\n#define S_STATS\t\t12\n#define S_SCANNING\t\t13\n#define S_SCAN_ABORTING\t14\n#define S_SCAN_HW\t\t15\n#define S_POWER_PMI\t16\n#define S_FW_ERROR\t\t17\n#define S_CHANNEL_SWITCH_PENDING 18\n\nstatic inline int\nil_is_ready(struct il_priv *il)\n{\n\t \n\treturn test_bit(S_READY, &il->status) &&\n\t    test_bit(S_GEO_CONFIGURED, &il->status) &&\n\t    !test_bit(S_EXIT_PENDING, &il->status);\n}\n\nstatic inline int\nil_is_alive(struct il_priv *il)\n{\n\treturn test_bit(S_ALIVE, &il->status);\n}\n\nstatic inline int\nil_is_init(struct il_priv *il)\n{\n\treturn test_bit(S_INIT, &il->status);\n}\n\nstatic inline int\nil_is_rfkill(struct il_priv *il)\n{\n\treturn test_bit(S_RFKILL, &il->status);\n}\n\nstatic inline int\nil_is_ctkill(struct il_priv *il)\n{\n\treturn test_bit(S_CT_KILL, &il->status);\n}\n\nstatic inline int\nil_is_ready_rf(struct il_priv *il)\n{\n\n\tif (il_is_rfkill(il))\n\t\treturn 0;\n\n\treturn il_is_ready(il);\n}\n\nvoid il_send_bt_config(struct il_priv *il);\nint il_send_stats_request(struct il_priv *il, u8 flags, bool clear);\nvoid il_apm_stop(struct il_priv *il);\nvoid _il_apm_stop(struct il_priv *il);\n\nint il_apm_init(struct il_priv *il);\n\nint il_send_rxon_timing(struct il_priv *il);\n\nstatic inline int\nil_send_rxon_assoc(struct il_priv *il)\n{\n\treturn il->ops->rxon_assoc(il);\n}\n\nstatic inline int\nil_commit_rxon(struct il_priv *il)\n{\n\treturn il->ops->commit_rxon(il);\n}\n\nstatic inline const struct ieee80211_supported_band *\nil_get_hw_mode(struct il_priv *il, enum nl80211_band band)\n{\n\treturn il->hw->wiphy->bands[band];\n}\n\n \nint il_mac_config(struct ieee80211_hw *hw, u32 changed);\nvoid il_mac_reset_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\nvoid il_mac_bss_info_changed(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_bss_conf *bss_conf, u64 changes);\nvoid il_tx_cmd_protection(struct il_priv *il, struct ieee80211_tx_info *info,\n\t\t\t  __le16 fc, __le32 *tx_flags);\n\nirqreturn_t il_isr(int irq, void *data);\n\nvoid il_set_bit(struct il_priv *p, u32 r, u32 m);\nvoid il_clear_bit(struct il_priv *p, u32 r, u32 m);\nbool _il_grab_nic_access(struct il_priv *il);\nint _il_poll_bit(struct il_priv *il, u32 addr, u32 bits, u32 mask, int timeout);\nint il_poll_bit(struct il_priv *il, u32 addr, u32 mask, int timeout);\nu32 il_rd_prph(struct il_priv *il, u32 reg);\nvoid il_wr_prph(struct il_priv *il, u32 addr, u32 val);\nu32 il_read_targ_mem(struct il_priv *il, u32 addr);\nvoid il_write_targ_mem(struct il_priv *il, u32 addr, u32 val);\n\nstatic inline bool il_need_reclaim(struct il_priv *il, struct il_rx_pkt *pkt)\n{\n\t \n\treturn !(pkt->hdr.sequence & SEQ_RX_FRAME) &&\n\t       pkt->hdr.cmd != N_STATS && pkt->hdr.cmd != C_TX &&\n\t       pkt->hdr.cmd != N_RX_PHY && pkt->hdr.cmd != N_RX &&\n\t       pkt->hdr.cmd != N_RX_MPDU && pkt->hdr.cmd != N_COMPRESSED_BA;\n}\n\nstatic inline void\n_il_write8(struct il_priv *il, u32 ofs, u8 val)\n{\n\twriteb(val, il->hw_base + ofs);\n}\n#define il_write8(il, ofs, val) _il_write8(il, ofs, val)\n\nstatic inline void\n_il_wr(struct il_priv *il, u32 ofs, u32 val)\n{\n\twritel(val, il->hw_base + ofs);\n}\n\nstatic inline u32\n_il_rd(struct il_priv *il, u32 ofs)\n{\n\treturn readl(il->hw_base + ofs);\n}\n\nstatic inline void\n_il_clear_bit(struct il_priv *il, u32 reg, u32 mask)\n{\n\t_il_wr(il, reg, _il_rd(il, reg) & ~mask);\n}\n\nstatic inline void\n_il_set_bit(struct il_priv *il, u32 reg, u32 mask)\n{\n\t_il_wr(il, reg, _il_rd(il, reg) | mask);\n}\n\nstatic inline void\n_il_release_nic_access(struct il_priv *il)\n{\n\t_il_clear_bit(il, CSR_GP_CNTRL, CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);\n}\n\nstatic inline u32\nil_rd(struct il_priv *il, u32 reg)\n{\n\tu32 value;\n\tunsigned long reg_flags;\n\n\tspin_lock_irqsave(&il->reg_lock, reg_flags);\n\t_il_grab_nic_access(il);\n\tvalue = _il_rd(il, reg);\n\t_il_release_nic_access(il);\n\tspin_unlock_irqrestore(&il->reg_lock, reg_flags);\n\treturn value;\n}\n\nstatic inline void\nil_wr(struct il_priv *il, u32 reg, u32 value)\n{\n\tunsigned long reg_flags;\n\n\tspin_lock_irqsave(&il->reg_lock, reg_flags);\n\tif (likely(_il_grab_nic_access(il))) {\n\t\t_il_wr(il, reg, value);\n\t\t_il_release_nic_access(il);\n\t}\n\tspin_unlock_irqrestore(&il->reg_lock, reg_flags);\n}\n\nstatic inline u32\n_il_rd_prph(struct il_priv *il, u32 reg)\n{\n\t_il_wr(il, HBUS_TARG_PRPH_RADDR, reg | (3 << 24));\n\treturn _il_rd(il, HBUS_TARG_PRPH_RDAT);\n}\n\nstatic inline void\n_il_wr_prph(struct il_priv *il, u32 addr, u32 val)\n{\n\t_il_wr(il, HBUS_TARG_PRPH_WADDR, ((addr & 0x0000FFFF) | (3 << 24)));\n\t_il_wr(il, HBUS_TARG_PRPH_WDAT, val);\n}\n\nstatic inline void\nil_set_bits_prph(struct il_priv *il, u32 reg, u32 mask)\n{\n\tunsigned long reg_flags;\n\n\tspin_lock_irqsave(&il->reg_lock, reg_flags);\n\tif (likely(_il_grab_nic_access(il))) {\n\t\t_il_wr_prph(il, reg, (_il_rd_prph(il, reg) | mask));\n\t\t_il_release_nic_access(il);\n\t}\n\tspin_unlock_irqrestore(&il->reg_lock, reg_flags);\n}\n\nstatic inline void\nil_set_bits_mask_prph(struct il_priv *il, u32 reg, u32 bits, u32 mask)\n{\n\tunsigned long reg_flags;\n\n\tspin_lock_irqsave(&il->reg_lock, reg_flags);\n\tif (likely(_il_grab_nic_access(il))) {\n\t\t_il_wr_prph(il, reg, ((_il_rd_prph(il, reg) & mask) | bits));\n\t\t_il_release_nic_access(il);\n\t}\n\tspin_unlock_irqrestore(&il->reg_lock, reg_flags);\n}\n\nstatic inline void\nil_clear_bits_prph(struct il_priv *il, u32 reg, u32 mask)\n{\n\tunsigned long reg_flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&il->reg_lock, reg_flags);\n\tif (likely(_il_grab_nic_access(il))) {\n\t\tval = _il_rd_prph(il, reg);\n\t\t_il_wr_prph(il, reg, (val & ~mask));\n\t\t_il_release_nic_access(il);\n\t}\n\tspin_unlock_irqrestore(&il->reg_lock, reg_flags);\n}\n\n#define HW_KEY_DYNAMIC 0\n#define HW_KEY_DEFAULT 1\n\n#define IL_STA_DRIVER_ACTIVE BIT(0)\t \n#define IL_STA_UCODE_ACTIVE  BIT(1)\t \n#define IL_STA_UCODE_INPROGRESS  BIT(2)\t \n#define IL_STA_LOCAL BIT(3)\t \n#define IL_STA_BCAST BIT(4)\t \n\nvoid il_restore_stations(struct il_priv *il);\nvoid il_clear_ucode_stations(struct il_priv *il);\nvoid il_dealloc_bcast_stations(struct il_priv *il);\nint il_get_free_ucode_key_idx(struct il_priv *il);\nint il_send_add_sta(struct il_priv *il, struct il_addsta_cmd *sta, u8 flags);\nint il_add_station_common(struct il_priv *il, const u8 *addr, bool is_ap,\n\t\t\t  struct ieee80211_sta *sta, u8 *sta_id_r);\nint il_remove_station(struct il_priv *il, const u8 sta_id, const u8 * addr);\nint il_mac_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t      struct ieee80211_sta *sta);\n\nu8 il_prep_station(struct il_priv *il, const u8 *addr, bool is_ap,\n\t\t   struct ieee80211_sta *sta);\n\nint il_send_lq_cmd(struct il_priv *il, struct il_link_quality_cmd *lq,\n\t\t   u8 flags, bool init);\n\n \nstatic inline void\nil_clear_driver_stations(struct il_priv *il)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\tmemset(il->stations, 0, sizeof(il->stations));\n\til->num_stations = 0;\n\til->ucode_key_table = 0;\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n}\n\nstatic inline int\nil_sta_id(struct ieee80211_sta *sta)\n{\n\tif (WARN_ON(!sta))\n\t\treturn IL_INVALID_STATION;\n\n\treturn ((struct il_station_priv_common *)sta->drv_priv)->sta_id;\n}\n\n \nstatic inline int\nil_sta_id_or_broadcast(struct il_priv *il, struct ieee80211_sta *sta)\n{\n\tint sta_id;\n\n\tif (!sta)\n\t\treturn il->hw_params.bcast_id;\n\n\tsta_id = il_sta_id(sta);\n\n\t \n\tWARN_ON(sta_id == IL_INVALID_STATION);\n\n\treturn sta_id;\n}\n\n \nstatic inline int\nil_queue_inc_wrap(int idx, int n_bd)\n{\n\treturn ++idx & (n_bd - 1);\n}\n\n \nstatic inline int\nil_queue_dec_wrap(int idx, int n_bd)\n{\n\treturn --idx & (n_bd - 1);\n}\n\n \nstatic inline void\nil_free_fw_desc(struct pci_dev *pci_dev, struct fw_desc *desc)\n{\n\tif (desc->v_addr)\n\t\tdma_free_coherent(&pci_dev->dev, desc->len, desc->v_addr,\n\t\t\t\t  desc->p_addr);\n\tdesc->v_addr = NULL;\n\tdesc->len = 0;\n}\n\nstatic inline int\nil_alloc_fw_desc(struct pci_dev *pci_dev, struct fw_desc *desc)\n{\n\tif (!desc->len) {\n\t\tdesc->v_addr = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\tdesc->v_addr = dma_alloc_coherent(&pci_dev->dev, desc->len,\n\t\t\t\t\t  &desc->p_addr, GFP_KERNEL);\n\treturn (desc->v_addr != NULL) ? 0 : -ENOMEM;\n}\n\n \nstatic inline void\nil_set_swq_id(struct il_tx_queue *txq, u8 ac, u8 hwq)\n{\n\tBUG_ON(ac > 3);\t\t \n\tBUG_ON(hwq > 31);\t \n\n\ttxq->swq_id = (hwq << 2) | ac;\n}\n\nstatic inline void\n_il_wake_queue(struct il_priv *il, u8 ac)\n{\n\tif (atomic_dec_return(&il->queue_stop_count[ac]) <= 0)\n\t\tieee80211_wake_queue(il->hw, ac);\n}\n\nstatic inline void\n_il_stop_queue(struct il_priv *il, u8 ac)\n{\n\tif (atomic_inc_return(&il->queue_stop_count[ac]) > 0)\n\t\tieee80211_stop_queue(il->hw, ac);\n}\nstatic inline void\nil_wake_queue(struct il_priv *il, struct il_tx_queue *txq)\n{\n\tu8 queue = txq->swq_id;\n\tu8 ac = queue & 3;\n\tu8 hwq = (queue >> 2) & 0x1f;\n\n\tif (test_and_clear_bit(hwq, il->queue_stopped))\n\t\t_il_wake_queue(il, ac);\n}\n\nstatic inline void\nil_stop_queue(struct il_priv *il, struct il_tx_queue *txq)\n{\n\tu8 queue = txq->swq_id;\n\tu8 ac = queue & 3;\n\tu8 hwq = (queue >> 2) & 0x1f;\n\n\tif (!test_and_set_bit(hwq, il->queue_stopped))\n\t\t_il_stop_queue(il, ac);\n}\n\nstatic inline void\nil_wake_queues_by_reason(struct il_priv *il, int reason)\n{\n\tu8 ac;\n\n\tif (test_and_clear_bit(reason, &il->stop_reason))\n\t\tfor (ac = 0; ac < 4; ac++)\n\t\t\t_il_wake_queue(il, ac);\n}\n\nstatic inline void\nil_stop_queues_by_reason(struct il_priv *il, int reason)\n{\n\tu8 ac;\n\n\tif (!test_and_set_bit(reason, &il->stop_reason))\n\t\tfor (ac = 0; ac < 4; ac++)\n\t\t\t_il_stop_queue(il, ac);\n}\n\n#ifdef ieee80211_stop_queue\n#undef ieee80211_stop_queue\n#endif\n\n#define ieee80211_stop_queue DO_NOT_USE_ieee80211_stop_queue\n\n#ifdef ieee80211_wake_queue\n#undef ieee80211_wake_queue\n#endif\n\n#define ieee80211_wake_queue DO_NOT_USE_ieee80211_wake_queue\n\nstatic inline void\nil_disable_interrupts(struct il_priv *il)\n{\n\tclear_bit(S_INT_ENABLED, &il->status);\n\n\t \n\t_il_wr(il, CSR_INT_MASK, 0x00000000);\n\n\t \n\t_il_wr(il, CSR_INT, 0xffffffff);\n\t_il_wr(il, CSR_FH_INT_STATUS, 0xffffffff);\n}\n\nstatic inline void\nil_enable_rfkill_int(struct il_priv *il)\n{\n\t_il_wr(il, CSR_INT_MASK, CSR_INT_BIT_RF_KILL);\n}\n\nstatic inline void\nil_enable_interrupts(struct il_priv *il)\n{\n\tset_bit(S_INT_ENABLED, &il->status);\n\t_il_wr(il, CSR_INT_MASK, il->inta_mask);\n}\n\n \nstatic inline u32\nil_beacon_time_mask_low(struct il_priv *il, u16 tsf_bits)\n{\n\treturn (1 << tsf_bits) - 1;\n}\n\n \nstatic inline u32\nil_beacon_time_mask_high(struct il_priv *il, u16 tsf_bits)\n{\n\treturn ((1 << (32 - tsf_bits)) - 1) << tsf_bits;\n}\n\n \nstruct il_rb_status {\n\t__le16 closed_rb_num;\n\t__le16 closed_fr_num;\n\t__le16 finished_rb_num;\n\t__le16 finished_fr_nam;\n\t__le32 __unused;\t \n} __packed;\n\n#define TFD_QUEUE_SIZE_MAX      256\n#define TFD_QUEUE_SIZE_BC_DUP\t64\n#define TFD_QUEUE_BC_SIZE\t(TFD_QUEUE_SIZE_MAX + TFD_QUEUE_SIZE_BC_DUP)\n#define IL_TX_DMA_MASK\t\tDMA_BIT_MASK(36)\n#define IL_NUM_OF_TBS\t\t20\n\nstatic inline u8\nil_get_dma_hi_addr(dma_addr_t addr)\n{\n\treturn (sizeof(addr) > sizeof(u32) ? (addr >> 16) >> 16 : 0) & 0xF;\n}\n\n \nstruct il_tfd_tb {\n\t__le32 lo;\n\t__le16 hi_n_len;\n} __packed;\n\n \nstruct il_tfd {\n\tu8 __reserved1[3];\n\tu8 num_tbs;\n\tstruct il_tfd_tb tbs[IL_NUM_OF_TBS];\n\t__le32 __pad;\n} __packed;\n \n#define PCI_CFG_RETRY_TIMEOUT\t0x041\n\nstruct il_rate_info {\n\tu8 plcp;\t\t \n\tu8 plcp_siso;\t\t \n\tu8 plcp_mimo2;\t\t \n\tu8 ieee;\t\t \n\tu8 prev_ieee;\t\t \n\tu8 next_ieee;\t\t \n\tu8 prev_rs;\t\t \n\tu8 next_rs;\t\t \n\tu8 prev_rs_tgg;\t\t \n\tu8 next_rs_tgg;\t\t \n};\n\nstruct il3945_rate_info {\n\tu8 plcp;\t\t \n\tu8 ieee;\t\t \n\tu8 prev_ieee;\t\t \n\tu8 next_ieee;\t\t \n\tu8 prev_rs;\t\t \n\tu8 next_rs;\t\t \n\tu8 prev_rs_tgg;\t\t \n\tu8 next_rs_tgg;\t\t \n\tu8 table_rs_idx;\t \n\tu8 prev_table_rs;\t \n};\n\n \nenum {\n\tRATE_1M_IDX = 0,\n\tRATE_2M_IDX,\n\tRATE_5M_IDX,\n\tRATE_11M_IDX,\n\tRATE_6M_IDX,\n\tRATE_9M_IDX,\n\tRATE_12M_IDX,\n\tRATE_18M_IDX,\n\tRATE_24M_IDX,\n\tRATE_36M_IDX,\n\tRATE_48M_IDX,\n\tRATE_54M_IDX,\n\tRATE_60M_IDX,\n\tRATE_COUNT,\n\tRATE_COUNT_LEGACY = RATE_COUNT - 1,\t \n\tRATE_COUNT_3945 = RATE_COUNT - 1,\n\tRATE_INVM_IDX = RATE_COUNT,\n\tRATE_INVALID = RATE_COUNT,\n};\n\nenum {\n\tRATE_6M_IDX_TBL = 0,\n\tRATE_9M_IDX_TBL,\n\tRATE_12M_IDX_TBL,\n\tRATE_18M_IDX_TBL,\n\tRATE_24M_IDX_TBL,\n\tRATE_36M_IDX_TBL,\n\tRATE_48M_IDX_TBL,\n\tRATE_54M_IDX_TBL,\n\tRATE_1M_IDX_TBL,\n\tRATE_2M_IDX_TBL,\n\tRATE_5M_IDX_TBL,\n\tRATE_11M_IDX_TBL,\n\tRATE_INVM_IDX_TBL = RATE_INVM_IDX - 1,\n};\n\nenum {\n\tIL_FIRST_OFDM_RATE = RATE_6M_IDX,\n\tIL39_LAST_OFDM_RATE = RATE_54M_IDX,\n\tIL_LAST_OFDM_RATE = RATE_60M_IDX,\n\tIL_FIRST_CCK_RATE = RATE_1M_IDX,\n\tIL_LAST_CCK_RATE = RATE_11M_IDX,\n};\n\n \n#define\tRATE_6M_MASK   (1 << RATE_6M_IDX)\n#define\tRATE_9M_MASK   (1 << RATE_9M_IDX)\n#define\tRATE_12M_MASK  (1 << RATE_12M_IDX)\n#define\tRATE_18M_MASK  (1 << RATE_18M_IDX)\n#define\tRATE_24M_MASK  (1 << RATE_24M_IDX)\n#define\tRATE_36M_MASK  (1 << RATE_36M_IDX)\n#define\tRATE_48M_MASK  (1 << RATE_48M_IDX)\n#define\tRATE_54M_MASK  (1 << RATE_54M_IDX)\n#define RATE_60M_MASK  (1 << RATE_60M_IDX)\n#define\tRATE_1M_MASK   (1 << RATE_1M_IDX)\n#define\tRATE_2M_MASK   (1 << RATE_2M_IDX)\n#define\tRATE_5M_MASK   (1 << RATE_5M_IDX)\n#define\tRATE_11M_MASK  (1 << RATE_11M_IDX)\n\n \nenum {\n\tRATE_6M_PLCP = 13,\n\tRATE_9M_PLCP = 15,\n\tRATE_12M_PLCP = 5,\n\tRATE_18M_PLCP = 7,\n\tRATE_24M_PLCP = 9,\n\tRATE_36M_PLCP = 11,\n\tRATE_48M_PLCP = 1,\n\tRATE_54M_PLCP = 3,\n\tRATE_60M_PLCP = 3,\t \n\tRATE_1M_PLCP = 10,\n\tRATE_2M_PLCP = 20,\n\tRATE_5M_PLCP = 55,\n\tRATE_11M_PLCP = 110,\n\t \n};\n\n \nenum {\n\tRATE_SISO_6M_PLCP = 0,\n\tRATE_SISO_12M_PLCP = 1,\n\tRATE_SISO_18M_PLCP = 2,\n\tRATE_SISO_24M_PLCP = 3,\n\tRATE_SISO_36M_PLCP = 4,\n\tRATE_SISO_48M_PLCP = 5,\n\tRATE_SISO_54M_PLCP = 6,\n\tRATE_SISO_60M_PLCP = 7,\n\tRATE_MIMO2_6M_PLCP = 0x8,\n\tRATE_MIMO2_12M_PLCP = 0x9,\n\tRATE_MIMO2_18M_PLCP = 0xa,\n\tRATE_MIMO2_24M_PLCP = 0xb,\n\tRATE_MIMO2_36M_PLCP = 0xc,\n\tRATE_MIMO2_48M_PLCP = 0xd,\n\tRATE_MIMO2_54M_PLCP = 0xe,\n\tRATE_MIMO2_60M_PLCP = 0xf,\n\tRATE_SISO_INVM_PLCP,\n\tRATE_MIMO2_INVM_PLCP = RATE_SISO_INVM_PLCP,\n};\n\n \nenum {\n\tRATE_6M_IEEE = 12,\n\tRATE_9M_IEEE = 18,\n\tRATE_12M_IEEE = 24,\n\tRATE_18M_IEEE = 36,\n\tRATE_24M_IEEE = 48,\n\tRATE_36M_IEEE = 72,\n\tRATE_48M_IEEE = 96,\n\tRATE_54M_IEEE = 108,\n\tRATE_60M_IEEE = 120,\n\tRATE_1M_IEEE = 2,\n\tRATE_2M_IEEE = 4,\n\tRATE_5M_IEEE = 11,\n\tRATE_11M_IEEE = 22,\n};\n\n#define IL_CCK_BASIC_RATES_MASK    \\\n\t(RATE_1M_MASK          | \\\n\tRATE_2M_MASK)\n\n#define IL_CCK_RATES_MASK          \\\n\t(IL_CCK_BASIC_RATES_MASK  | \\\n\tRATE_5M_MASK          | \\\n\tRATE_11M_MASK)\n\n#define IL_OFDM_BASIC_RATES_MASK   \\\n\t(RATE_6M_MASK         | \\\n\tRATE_12M_MASK         | \\\n\tRATE_24M_MASK)\n\n#define IL_OFDM_RATES_MASK         \\\n\t(IL_OFDM_BASIC_RATES_MASK | \\\n\tRATE_9M_MASK          | \\\n\tRATE_18M_MASK         | \\\n\tRATE_36M_MASK         | \\\n\tRATE_48M_MASK         | \\\n\tRATE_54M_MASK)\n\n#define IL_BASIC_RATES_MASK         \\\n\t(IL_OFDM_BASIC_RATES_MASK | \\\n\t IL_CCK_BASIC_RATES_MASK)\n\n#define RATES_MASK ((1 << RATE_COUNT) - 1)\n#define RATES_MASK_3945 ((1 << RATE_COUNT_3945) - 1)\n\n#define IL_INVALID_VALUE    -1\n\n#define IL_MIN_RSSI_VAL                 -100\n#define IL_MAX_RSSI_VAL                    0\n\n \n#define IL_LEGACY_FAILURE_LIMIT\t160\n#define IL_LEGACY_SUCCESS_LIMIT\t480\n#define IL_LEGACY_TBL_COUNT\t\t160\n\n#define IL_NONE_LEGACY_FAILURE_LIMIT\t400\n#define IL_NONE_LEGACY_SUCCESS_LIMIT\t4500\n#define IL_NONE_LEGACY_TBL_COUNT\t1500\n\n \n#define IL_RS_GOOD_RATIO\t\t12800\t \n#define RATE_SCALE_SWITCH\t\t10880\t \n#define RATE_HIGH_TH\t\t10880\t \n#define RATE_INCREASE_TH\t\t6400\t \n#define RATE_DECREASE_TH\t\t1920\t \n\n \n#define IL_LEGACY_SWITCH_ANTENNA1      0\n#define IL_LEGACY_SWITCH_ANTENNA2      1\n#define IL_LEGACY_SWITCH_SISO          2\n#define IL_LEGACY_SWITCH_MIMO2_AB      3\n#define IL_LEGACY_SWITCH_MIMO2_AC      4\n#define IL_LEGACY_SWITCH_MIMO2_BC      5\n\n \n#define IL_SISO_SWITCH_ANTENNA1        0\n#define IL_SISO_SWITCH_ANTENNA2        1\n#define IL_SISO_SWITCH_MIMO2_AB        2\n#define IL_SISO_SWITCH_MIMO2_AC        3\n#define IL_SISO_SWITCH_MIMO2_BC        4\n#define IL_SISO_SWITCH_GI              5\n\n \n#define IL_MIMO2_SWITCH_ANTENNA1       0\n#define IL_MIMO2_SWITCH_ANTENNA2       1\n#define IL_MIMO2_SWITCH_SISO_A         2\n#define IL_MIMO2_SWITCH_SISO_B         3\n#define IL_MIMO2_SWITCH_SISO_C         4\n#define IL_MIMO2_SWITCH_GI             5\n\n#define IL_MAX_SEARCH IL_MIMO2_SWITCH_GI\n\n#define IL_ACTION_LIMIT\t\t3\t \n\n#define LQ_SIZE\t\t2\t \n\n \n#define IL_AGG_TPT_THREHOLD\t0\n#define IL_AGG_LOAD_THRESHOLD\t10\n#define IL_AGG_ALL_TID\t\t0xff\n#define TID_QUEUE_CELL_SPACING\t50\t \n#define TID_QUEUE_MAX_SIZE\t20\n#define TID_ROUND_VALUE\t\t5\t \n#define TID_MAX_LOAD_COUNT\t8\n\n#define TID_MAX_TIME_DIFF ((TID_QUEUE_MAX_SIZE - 1) * TID_QUEUE_CELL_SPACING)\n#define TIME_WRAP_AROUND(x, y) (((y) > (x)) ? (y) - (x) : (0-(x)) + (y))\n\nextern const struct il_rate_info il_rates[RATE_COUNT];\n\nenum il_table_type {\n\tLQ_NONE,\n\tLQ_G,\t\t\t \n\tLQ_A,\n\tLQ_SISO,\t\t \n\tLQ_MIMO2,\n\tLQ_MAX,\n};\n\n#define is_legacy(tbl) ((tbl) == LQ_G || (tbl) == LQ_A)\n#define is_siso(tbl) ((tbl) == LQ_SISO)\n#define is_mimo2(tbl) ((tbl) == LQ_MIMO2)\n#define is_mimo(tbl) (is_mimo2(tbl))\n#define is_Ht(tbl) (is_siso(tbl) || is_mimo(tbl))\n#define is_a_band(tbl) ((tbl) == LQ_A)\n#define is_g_and(tbl) ((tbl) == LQ_G)\n\n#define\tANT_NONE\t0x0\n#define\tANT_A\t\tBIT(0)\n#define\tANT_B\t\tBIT(1)\n#define\tANT_AB\t\t(ANT_A | ANT_B)\n#define ANT_C\t\tBIT(2)\n#define\tANT_AC\t\t(ANT_A | ANT_C)\n#define ANT_BC\t\t(ANT_B | ANT_C)\n#define ANT_ABC\t\t(ANT_AB | ANT_C)\n\n#define IL_MAX_MCS_DISPLAY_SIZE\t12\n\nstruct il_rate_mcs_info {\n\tchar mbps[IL_MAX_MCS_DISPLAY_SIZE];\n\tchar mcs[IL_MAX_MCS_DISPLAY_SIZE];\n};\n\n \nstruct il_rate_scale_data {\n\tu64 data;\t\t \n\ts32 success_counter;\t \n\ts32 success_ratio;\t \n\ts32 counter;\t\t \n\ts32 average_tpt;\t \n\tunsigned long stamp;\n};\n\n \nstruct il_scale_tbl_info {\n\tenum il_table_type lq_type;\n\tu8 ant_type;\n\tu8 is_SGI;\t\t \n\tu8 is_ht40;\t\t \n\tu8 is_dup;\t\t \n\tu8 action;\t\t \n\tu8 max_search;\t\t \n\ts32 *expected_tpt;\t \n\tu32 current_rate;\t \n\tstruct il_rate_scale_data win[RATE_COUNT];\t \n};\n\nstruct il_traffic_load {\n\tunsigned long time_stamp;\t \n\tu32 packet_count[TID_QUEUE_MAX_SIZE];\t \n\tu32 total;\t\t \n\tu8 queue_count;\t\t \n\tu8 head;\t\t \n};\n\n \nstruct il_lq_sta {\n\tu8 active_tbl;\t\t \n\tu8 enable_counter;\t \n\tu8 stay_in_tbl;\t\t \n\tu8 search_better_tbl;\t \n\ts32 last_tpt;\n\n\t \n\tu32 table_count_limit;\n\tu32 max_failure_limit;\t \n\tu32 max_success_limit;\t \n\tu32 table_count;\n\tu32 total_failed;\t \n\tu32 total_success;\t \n\tu64 flush_timer;\t \n\n\tu8 action_counter;\t \n\tu8 is_green;\n\tu8 is_dup;\n\tenum nl80211_band band;\n\n\t \n\tu32 supp_rates;\n\tu16 active_legacy_rate;\n\tu16 active_siso_rate;\n\tu16 active_mimo2_rate;\n\ts8 max_rate_idx;\t \n\tu8 missed_rate_counter;\n\n\tstruct il_link_quality_cmd lq;\n\tstruct il_scale_tbl_info lq_info[LQ_SIZE];\t \n\tstruct il_traffic_load load[TID_MAX_LOAD_COUNT];\n\tu8 tx_agg_tid_en;\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tu32 dbg_fixed_rate;\n#endif\n\tstruct il_priv *drv;\n\n\t \n\tint last_txrate_idx;\n\t \n\tu32 last_rate_n_flags;\n\t \n\tu8 is_agg;\n};\n\n \nstruct il_station_priv {\n\tstruct il_station_priv_common common;\n\tstruct il_lq_sta lq_sta;\n\tatomic_t pending_frames;\n\tbool client;\n\tbool asleep;\n};\n\nstatic inline u8\nil4965_num_of_ant(u8 m)\n{\n\treturn !!(m & ANT_A) + !!(m & ANT_B) + !!(m & ANT_C);\n}\n\nstatic inline u8\nil4965_first_antenna(u8 mask)\n{\n\tif (mask & ANT_A)\n\t\treturn ANT_A;\n\tif (mask & ANT_B)\n\t\treturn ANT_B;\n\treturn ANT_C;\n}\n\n \nvoid il3945_rate_scale_init(struct ieee80211_hw *hw, s32 sta_id);\n\n \nvoid il4965_rs_rate_init(struct il_priv *il, struct ieee80211_sta *sta,\n\t\t\t u8 sta_id);\nvoid il3945_rs_rate_init(struct il_priv *il, struct ieee80211_sta *sta,\n\t\t\t u8 sta_id);\n\n \nint il4965_rate_control_register(void);\nint il3945_rate_control_register(void);\n\n \nvoid il4965_rate_control_unregister(void);\nvoid il3945_rate_control_unregister(void);\n\nint il_power_update_mode(struct il_priv *il, bool force);\nvoid il_power_initialize(struct il_priv *il);\n\nextern u32 il_debug_level;\n\n#ifdef CONFIG_IWLEGACY_DEBUG\n \nstatic inline u32\nil_get_debug_level(struct il_priv *il)\n{\n\tif (il->debug_level)\n\t\treturn il->debug_level;\n\telse\n\t\treturn il_debug_level;\n}\n#else\nstatic inline u32\nil_get_debug_level(struct il_priv *il)\n{\n\treturn il_debug_level;\n}\n#endif\n\n#define il_print_hex_error(il, p, len)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tprint_hex_dump(KERN_ERR, \"iwl data: \",\t\t\t\t\\\n\t\t       DUMP_PREFIX_OFFSET, 16, 1, p, len, 1);\t\t\\\n} while (0)\n\n#ifdef CONFIG_IWLEGACY_DEBUG\n#define IL_DBG(level, fmt, args...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (il_get_debug_level(il) & level)\t\t\t\t\\\n\t\tdev_err(&il->hw->wiphy->dev, \"%s \" fmt, __func__,\t\\\n\t\t\t ##args);\t\t\t\t\t\\\n} while (0)\n\n#define il_print_hex_dump(il, level, p, len)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (il_get_debug_level(il) & level)\t\t\t\t\\\n\t\tprint_hex_dump(KERN_DEBUG, \"iwl data: \",\t\t\\\n\t\t\t       DUMP_PREFIX_OFFSET, 16, 1, p, len, 1);\t\\\n} while (0)\n\n#else\n#define IL_DBG(level, fmt, args...) no_printk(fmt, ##args)\nstatic inline void\nil_print_hex_dump(struct il_priv *il, int level, const void *p, u32 len)\n{\n}\n#endif  \n\n#ifdef CONFIG_IWLEGACY_DEBUGFS\nvoid il_dbgfs_register(struct il_priv *il, const char *name);\nvoid il_dbgfs_unregister(struct il_priv *il);\n#else\nstatic inline void il_dbgfs_register(struct il_priv *il, const char *name)\n{\n}\n\nstatic inline void\nil_dbgfs_unregister(struct il_priv *il)\n{\n}\n#endif  \n\n \n\n \n#define IL_DL_INFO\t\t(1 << 0)\n#define IL_DL_MAC80211\t\t(1 << 1)\n#define IL_DL_HCMD\t\t(1 << 2)\n#define IL_DL_STATE\t\t(1 << 3)\n \n#define IL_DL_MACDUMP\t\t(1 << 4)\n#define IL_DL_HCMD_DUMP\t\t(1 << 5)\n#define IL_DL_EEPROM\t\t(1 << 6)\n#define IL_DL_RADIO\t\t(1 << 7)\n \n#define IL_DL_POWER\t\t(1 << 8)\n#define IL_DL_TEMP\t\t(1 << 9)\n#define IL_DL_NOTIF\t\t(1 << 10)\n#define IL_DL_SCAN\t\t(1 << 11)\n \n#define IL_DL_ASSOC\t\t(1 << 12)\n#define IL_DL_DROP\t\t(1 << 13)\n#define IL_DL_TXPOWER\t\t(1 << 14)\n#define IL_DL_AP\t\t(1 << 15)\n \n#define IL_DL_FW\t\t(1 << 16)\n#define IL_DL_RF_KILL\t\t(1 << 17)\n#define IL_DL_FW_ERRORS\t\t(1 << 18)\n#define IL_DL_LED\t\t(1 << 19)\n \n#define IL_DL_RATE\t\t(1 << 20)\n#define IL_DL_CALIB\t\t(1 << 21)\n#define IL_DL_WEP\t\t(1 << 22)\n#define IL_DL_TX\t\t(1 << 23)\n \n#define IL_DL_RX\t\t(1 << 24)\n#define IL_DL_ISR\t\t(1 << 25)\n#define IL_DL_HT\t\t(1 << 26)\n \n#define IL_DL_11H\t\t(1 << 28)\n#define IL_DL_STATS\t\t(1 << 29)\n#define IL_DL_TX_REPLY\t\t(1 << 30)\n#define IL_DL_QOS\t\t(1 << 31)\n\n#define D_INFO(f, a...)\t\tIL_DBG(IL_DL_INFO, f, ## a)\n#define D_MAC80211(f, a...)\tIL_DBG(IL_DL_MAC80211, f, ## a)\n#define D_MACDUMP(f, a...)\tIL_DBG(IL_DL_MACDUMP, f, ## a)\n#define D_TEMP(f, a...)\t\tIL_DBG(IL_DL_TEMP, f, ## a)\n#define D_SCAN(f, a...)\t\tIL_DBG(IL_DL_SCAN, f, ## a)\n#define D_RX(f, a...)\t\tIL_DBG(IL_DL_RX, f, ## a)\n#define D_TX(f, a...)\t\tIL_DBG(IL_DL_TX, f, ## a)\n#define D_ISR(f, a...)\t\tIL_DBG(IL_DL_ISR, f, ## a)\n#define D_LED(f, a...)\t\tIL_DBG(IL_DL_LED, f, ## a)\n#define D_WEP(f, a...)\t\tIL_DBG(IL_DL_WEP, f, ## a)\n#define D_HC(f, a...)\t\tIL_DBG(IL_DL_HCMD, f, ## a)\n#define D_HC_DUMP(f, a...)\tIL_DBG(IL_DL_HCMD_DUMP, f, ## a)\n#define D_EEPROM(f, a...)\tIL_DBG(IL_DL_EEPROM, f, ## a)\n#define D_CALIB(f, a...)\tIL_DBG(IL_DL_CALIB, f, ## a)\n#define D_FW(f, a...)\t\tIL_DBG(IL_DL_FW, f, ## a)\n#define D_RF_KILL(f, a...)\tIL_DBG(IL_DL_RF_KILL, f, ## a)\n#define D_DROP(f, a...)\t\tIL_DBG(IL_DL_DROP, f, ## a)\n#define D_AP(f, a...)\t\tIL_DBG(IL_DL_AP, f, ## a)\n#define D_TXPOWER(f, a...)\tIL_DBG(IL_DL_TXPOWER, f, ## a)\n#define D_RATE(f, a...)\t\tIL_DBG(IL_DL_RATE, f, ## a)\n#define D_NOTIF(f, a...)\tIL_DBG(IL_DL_NOTIF, f, ## a)\n#define D_ASSOC(f, a...)\tIL_DBG(IL_DL_ASSOC, f, ## a)\n#define D_HT(f, a...)\t\tIL_DBG(IL_DL_HT, f, ## a)\n#define D_STATS(f, a...)\tIL_DBG(IL_DL_STATS, f, ## a)\n#define D_TX_REPLY(f, a...)\tIL_DBG(IL_DL_TX_REPLY, f, ## a)\n#define D_QOS(f, a...)\t\tIL_DBG(IL_DL_QOS, f, ## a)\n#define D_RADIO(f, a...)\tIL_DBG(IL_DL_RADIO, f, ## a)\n#define D_POWER(f, a...)\tIL_DBG(IL_DL_POWER, f, ## a)\n#define D_11H(f, a...)\t\tIL_DBG(IL_DL_11H, f, ## a)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}