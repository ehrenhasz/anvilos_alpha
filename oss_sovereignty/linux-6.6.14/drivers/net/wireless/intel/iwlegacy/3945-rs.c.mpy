{
  "module_name": "3945-rs.c",
  "hash_id": "e41bbfa11131eeae94e8de70841d45cd515e0138e97a725ab9467d82528acb16",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlegacy/3945-rs.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <net/mac80211.h>\n\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/delay.h>\n\n#include <linux/workqueue.h>\n\n#include \"commands.h\"\n#include \"3945.h\"\n\n#define RS_NAME \"iwl-3945-rs\"\n\nstatic s32 il3945_expected_tpt_g[RATE_COUNT_3945] = {\n\t7, 13, 35, 58, 0, 0, 76, 104, 130, 168, 191, 202\n};\n\nstatic s32 il3945_expected_tpt_g_prot[RATE_COUNT_3945] = {\n\t7, 13, 35, 58, 0, 0, 0, 80, 93, 113, 123, 125\n};\n\nstatic s32 il3945_expected_tpt_a[RATE_COUNT_3945] = {\n\t0, 0, 0, 0, 40, 57, 72, 98, 121, 154, 177, 186\n};\n\nstatic s32 il3945_expected_tpt_b[RATE_COUNT_3945] = {\n\t7, 13, 35, 58, 0, 0, 0, 0, 0, 0, 0, 0\n};\n\nstruct il3945_tpt_entry {\n\ts8 min_rssi;\n\tu8 idx;\n};\n\nstatic struct il3945_tpt_entry il3945_tpt_table_a[] = {\n\t{-60, RATE_54M_IDX},\n\t{-64, RATE_48M_IDX},\n\t{-72, RATE_36M_IDX},\n\t{-80, RATE_24M_IDX},\n\t{-84, RATE_18M_IDX},\n\t{-85, RATE_12M_IDX},\n\t{-87, RATE_9M_IDX},\n\t{-89, RATE_6M_IDX}\n};\n\nstatic struct il3945_tpt_entry il3945_tpt_table_g[] = {\n\t{-60, RATE_54M_IDX},\n\t{-64, RATE_48M_IDX},\n\t{-68, RATE_36M_IDX},\n\t{-80, RATE_24M_IDX},\n\t{-84, RATE_18M_IDX},\n\t{-85, RATE_12M_IDX},\n\t{-86, RATE_11M_IDX},\n\t{-88, RATE_5M_IDX},\n\t{-90, RATE_2M_IDX},\n\t{-92, RATE_1M_IDX}\n};\n\n#define RATE_MAX_WINDOW\t\t62\n#define RATE_FLUSH\t\t(3*HZ)\n#define RATE_WIN_FLUSH\t\t(HZ/2)\n#define IL39_RATE_HIGH_TH\t11520\n#define IL_SUCCESS_UP_TH\t8960\n#define IL_SUCCESS_DOWN_TH\t10880\n#define RATE_MIN_FAILURE_TH\t6\n#define RATE_MIN_SUCCESS_TH\t8\n#define RATE_DECREASE_TH\t1920\n#define RATE_RETRY_TH\t\t15\n\nstatic u8\nil3945_get_rate_idx_by_rssi(s32 rssi, enum nl80211_band band)\n{\n\tu32 idx = 0;\n\tu32 table_size = 0;\n\tstruct il3945_tpt_entry *tpt_table = NULL;\n\n\tif (rssi < IL_MIN_RSSI_VAL || rssi > IL_MAX_RSSI_VAL)\n\t\trssi = IL_MIN_RSSI_VAL;\n\n\tswitch (band) {\n\tcase NL80211_BAND_2GHZ:\n\t\ttpt_table = il3945_tpt_table_g;\n\t\ttable_size = ARRAY_SIZE(il3945_tpt_table_g);\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\ttpt_table = il3945_tpt_table_a;\n\t\ttable_size = ARRAY_SIZE(il3945_tpt_table_a);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\twhile (idx < table_size && rssi < tpt_table[idx].min_rssi)\n\t\tidx++;\n\n\tidx = min(idx, table_size - 1);\n\n\treturn tpt_table[idx].idx;\n}\n\nstatic void\nil3945_clear_win(struct il3945_rate_scale_data *win)\n{\n\twin->data = 0;\n\twin->success_counter = 0;\n\twin->success_ratio = -1;\n\twin->counter = 0;\n\twin->average_tpt = IL_INVALID_VALUE;\n\twin->stamp = 0;\n}\n\n \nstatic int\nil3945_rate_scale_flush_wins(struct il3945_rs_sta *rs_sta)\n{\n\tint unflushed = 0;\n\tint i;\n\tunsigned long flags;\n\tstruct il_priv *il __maybe_unused = rs_sta->il;\n\n\t \n\tfor (i = 0; i < RATE_COUNT_3945; i++) {\n\t\tif (!rs_sta->win[i].counter)\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&rs_sta->lock, flags);\n\t\tif (time_after(jiffies, rs_sta->win[i].stamp + RATE_WIN_FLUSH)) {\n\t\t\tD_RATE(\"flushing %d samples of rate \" \"idx %d\\n\",\n\t\t\t       rs_sta->win[i].counter, i);\n\t\t\til3945_clear_win(&rs_sta->win[i]);\n\t\t} else\n\t\t\tunflushed++;\n\t\tspin_unlock_irqrestore(&rs_sta->lock, flags);\n\t}\n\n\treturn unflushed;\n}\n\n#define RATE_FLUSH_MAX              5000\t \n#define RATE_FLUSH_MIN              50\t \n#define IL_AVERAGE_PACKETS             1500\n\nstatic void\nil3945_bg_rate_scale_flush(struct timer_list *t)\n{\n\tstruct il3945_rs_sta *rs_sta = from_timer(rs_sta, t, rate_scale_flush);\n\tstruct il_priv *il __maybe_unused = rs_sta->il;\n\tint unflushed = 0;\n\tunsigned long flags;\n\tu32 packet_count, duration, pps;\n\n\tD_RATE(\"enter\\n\");\n\n\tunflushed = il3945_rate_scale_flush_wins(rs_sta);\n\n\tspin_lock_irqsave(&rs_sta->lock, flags);\n\n\t \n\tpacket_count = (rs_sta->tx_packets - rs_sta->last_tx_packets) + 1;\n\n\trs_sta->last_tx_packets = rs_sta->tx_packets + 1;\n\n\tif (unflushed) {\n\t\tduration =\n\t\t    jiffies_to_msecs(jiffies - rs_sta->last_partial_flush);\n\n\t\tD_RATE(\"Tx'd %d packets in %dms\\n\", packet_count, duration);\n\n\t\t \n\t\tif (duration)\n\t\t\tpps = (packet_count * 1000) / duration;\n\t\telse\n\t\t\tpps = 0;\n\n\t\tif (pps) {\n\t\t\tduration = (IL_AVERAGE_PACKETS * 1000) / pps;\n\t\t\tif (duration < RATE_FLUSH_MIN)\n\t\t\t\tduration = RATE_FLUSH_MIN;\n\t\t\telse if (duration > RATE_FLUSH_MAX)\n\t\t\t\tduration = RATE_FLUSH_MAX;\n\t\t} else\n\t\t\tduration = RATE_FLUSH_MAX;\n\n\t\trs_sta->flush_time = msecs_to_jiffies(duration);\n\n\t\tD_RATE(\"new flush period: %d msec ave %d\\n\", duration,\n\t\t       packet_count);\n\n\t\tmod_timer(&rs_sta->rate_scale_flush,\n\t\t\t  jiffies + rs_sta->flush_time);\n\n\t\trs_sta->last_partial_flush = jiffies;\n\t} else {\n\t\trs_sta->flush_time = RATE_FLUSH;\n\t\trs_sta->flush_pending = 0;\n\t}\n\t \n\n\trs_sta->last_flush = jiffies;\n\n\tspin_unlock_irqrestore(&rs_sta->lock, flags);\n\n\tD_RATE(\"leave\\n\");\n}\n\n \nstatic void\nil3945_collect_tx_data(struct il3945_rs_sta *rs_sta,\n\t\t       struct il3945_rate_scale_data *win, int success,\n\t\t       int retries, int idx)\n{\n\tunsigned long flags;\n\ts32 fail_count;\n\tstruct il_priv *il __maybe_unused = rs_sta->il;\n\n\tif (!retries) {\n\t\tD_RATE(\"leave: retries == 0 -- should be at least 1\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&rs_sta->lock, flags);\n\n\t \n\twhile (retries > 0) {\n\t\tif (win->counter >= RATE_MAX_WINDOW) {\n\n\t\t\t \n\t\t\twin->counter = RATE_MAX_WINDOW - 1;\n\n\t\t\tif (win->data & (1ULL << (RATE_MAX_WINDOW - 1))) {\n\t\t\t\twin->data &= ~(1ULL << (RATE_MAX_WINDOW - 1));\n\t\t\t\twin->success_counter--;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\twin->counter++;\n\n\t\t \n\t\twin->data <<= 1;\n\t\tif (success > 0) {\n\t\t\twin->success_counter++;\n\t\t\twin->data |= 0x1;\n\t\t\tsuccess--;\n\t\t}\n\n\t\tretries--;\n\t}\n\n\t \n\tif (win->counter > 0)\n\t\twin->success_ratio =\n\t\t    128 * (100 * win->success_counter) / win->counter;\n\telse\n\t\twin->success_ratio = IL_INVALID_VALUE;\n\n\tfail_count = win->counter - win->success_counter;\n\n\t \n\tif (fail_count >= RATE_MIN_FAILURE_TH ||\n\t    win->success_counter >= RATE_MIN_SUCCESS_TH)\n\t\twin->average_tpt =\n\t\t    ((win->success_ratio * rs_sta->expected_tpt[idx] +\n\t\t      64) / 128);\n\telse\n\t\twin->average_tpt = IL_INVALID_VALUE;\n\n\t \n\twin->stamp = jiffies;\n\n\tspin_unlock_irqrestore(&rs_sta->lock, flags);\n}\n\n \nvoid\nil3945_rs_rate_init(struct il_priv *il, struct ieee80211_sta *sta, u8 sta_id)\n{\n\tstruct ieee80211_hw *hw = il->hw;\n\tstruct ieee80211_conf *conf = &il->hw->conf;\n\tstruct il3945_sta_priv *psta;\n\tstruct il3945_rs_sta *rs_sta;\n\tstruct ieee80211_supported_band *sband;\n\tint i;\n\n\tD_INFO(\"enter\\n\");\n\tif (sta_id == il->hw_params.bcast_id)\n\t\tgoto out;\n\n\tpsta = (struct il3945_sta_priv *)sta->drv_priv;\n\trs_sta = &psta->rs_sta;\n\tsband = hw->wiphy->bands[conf->chandef.chan->band];\n\n\trs_sta->il = il;\n\n\trs_sta->start_rate = RATE_INVALID;\n\n\t \n\trs_sta->expected_tpt = il3945_expected_tpt_b;\n\n\trs_sta->last_partial_flush = jiffies;\n\trs_sta->last_flush = jiffies;\n\trs_sta->flush_time = RATE_FLUSH;\n\trs_sta->last_tx_packets = 0;\n\n\tfor (i = 0; i < RATE_COUNT_3945; i++)\n\t\til3945_clear_win(&rs_sta->win[i]);\n\n\t \n\n\tfor (i = sband->n_bitrates - 1; i >= 0; i--) {\n\t\tif (sta->deflink.supp_rates[sband->band] & (1 << i)) {\n\t\t\trs_sta->last_txrate_idx = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\til->_3945.sta_supp_rates = sta->deflink.supp_rates[sband->band];\n\t \n\tif (sband->band == NL80211_BAND_5GHZ) {\n\t\trs_sta->last_txrate_idx += IL_FIRST_OFDM_RATE;\n\t\til->_3945.sta_supp_rates <<= IL_FIRST_OFDM_RATE;\n\t}\n\nout:\n\til->stations[sta_id].used &= ~IL_STA_UCODE_INPROGRESS;\n\n\tD_INFO(\"leave\\n\");\n}\n\nstatic void *\nil3945_rs_alloc(struct ieee80211_hw *hw)\n{\n\treturn hw->priv;\n}\n\n \nstatic void\nil3945_rs_free(void *il)\n{\n}\n\nstatic void *\nil3945_rs_alloc_sta(void *il_priv, struct ieee80211_sta *sta, gfp_t gfp)\n{\n\tstruct il3945_rs_sta *rs_sta;\n\tstruct il3945_sta_priv *psta = (void *)sta->drv_priv;\n\tstruct il_priv *il __maybe_unused = il_priv;\n\n\tD_RATE(\"enter\\n\");\n\n\trs_sta = &psta->rs_sta;\n\n\tspin_lock_init(&rs_sta->lock);\n\ttimer_setup(&rs_sta->rate_scale_flush, il3945_bg_rate_scale_flush, 0);\n\tD_RATE(\"leave\\n\");\n\n\treturn rs_sta;\n}\n\nstatic void\nil3945_rs_free_sta(void *il_priv, struct ieee80211_sta *sta, void *il_sta)\n{\n\tstruct il3945_rs_sta *rs_sta = il_sta;\n\n\t \n\tdel_timer_sync(&rs_sta->rate_scale_flush);\n}\n\n \nstatic void\nil3945_rs_tx_status(void *il_rate, struct ieee80211_supported_band *sband,\n\t\t    struct ieee80211_sta *sta, void *il_sta,\n\t\t    struct sk_buff *skb)\n{\n\ts8 retries = 0, current_count;\n\tint scale_rate_idx, first_idx, last_idx;\n\tunsigned long flags;\n\tstruct il_priv *il = (struct il_priv *)il_rate;\n\tstruct il3945_rs_sta *rs_sta = il_sta;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\n\tD_RATE(\"enter\\n\");\n\n\tretries = info->status.rates[0].count;\n\t \n\tif (retries > RATE_RETRY_TH)\n\t\tretries = RATE_RETRY_TH;\n\n\tfirst_idx = sband->bitrates[info->status.rates[0].idx].hw_value;\n\tif (first_idx < 0 || first_idx >= RATE_COUNT_3945) {\n\t\tD_RATE(\"leave: Rate out of bounds: %d\\n\", first_idx);\n\t\treturn;\n\t}\n\n\tif (!il_sta) {\n\t\tD_RATE(\"leave: No STA il data to update!\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (!rs_sta->il) {\n\t\tD_RATE(\"leave: STA il data uninitialized!\\n\");\n\t\treturn;\n\t}\n\n\trs_sta->tx_packets++;\n\n\tscale_rate_idx = first_idx;\n\tlast_idx = first_idx;\n\n\t \n\twhile (retries > 1) {\n\t\tif ((retries - 1) < il->retry_rate) {\n\t\t\tcurrent_count = (retries - 1);\n\t\t\tlast_idx = scale_rate_idx;\n\t\t} else {\n\t\t\tcurrent_count = il->retry_rate;\n\t\t\tlast_idx = il3945_rs_next_rate(il, scale_rate_idx);\n\t\t}\n\n\t\t \n\t\til3945_collect_tx_data(rs_sta, &rs_sta->win[scale_rate_idx], 0,\n\t\t\t\t       current_count, scale_rate_idx);\n\t\tD_RATE(\"Update rate %d for %d retries.\\n\", scale_rate_idx,\n\t\t       current_count);\n\n\t\tretries -= current_count;\n\n\t\tscale_rate_idx = last_idx;\n\t}\n\n\t \n\tD_RATE(\"Update rate %d with %s.\\n\", last_idx,\n\t       (info->flags & IEEE80211_TX_STAT_ACK) ? \"success\" : \"failure\");\n\til3945_collect_tx_data(rs_sta, &rs_sta->win[last_idx],\n\t\t\t       info->flags & IEEE80211_TX_STAT_ACK, 1,\n\t\t\t       last_idx);\n\n\t \n\tspin_lock_irqsave(&rs_sta->lock, flags);\n\n\tif (!rs_sta->flush_pending &&\n\t    time_after(jiffies, rs_sta->last_flush + rs_sta->flush_time)) {\n\n\t\trs_sta->last_partial_flush = jiffies;\n\t\trs_sta->flush_pending = 1;\n\t\tmod_timer(&rs_sta->rate_scale_flush,\n\t\t\t  jiffies + rs_sta->flush_time);\n\t}\n\n\tspin_unlock_irqrestore(&rs_sta->lock, flags);\n\n\tD_RATE(\"leave\\n\");\n}\n\nstatic u16\nil3945_get_adjacent_rate(struct il3945_rs_sta *rs_sta, u8 idx, u16 rate_mask,\n\t\t\t enum nl80211_band band)\n{\n\tu8 high = RATE_INVALID;\n\tu8 low = RATE_INVALID;\n\tstruct il_priv *il __maybe_unused = rs_sta->il;\n\n\t \n\tif (unlikely(band == NL80211_BAND_5GHZ)) {\n\t\tint i;\n\t\tu32 mask;\n\n\t\t \n\t\ti = idx - 1;\n\t\tfor (mask = (1 << i); i >= 0; i--, mask >>= 1) {\n\t\t\tif (rate_mask & mask) {\n\t\t\t\tlow = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\ti = idx + 1;\n\t\tfor (mask = (1 << i); i < RATE_COUNT_3945; i++, mask <<= 1) {\n\t\t\tif (rate_mask & mask) {\n\t\t\t\thigh = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn (high << 8) | low;\n\t}\n\n\tlow = idx;\n\twhile (low != RATE_INVALID) {\n\t\tif (rs_sta->tgg)\n\t\t\tlow = il3945_rates[low].prev_rs_tgg;\n\t\telse\n\t\t\tlow = il3945_rates[low].prev_rs;\n\t\tif (low == RATE_INVALID)\n\t\t\tbreak;\n\t\tif (rate_mask & (1 << low))\n\t\t\tbreak;\n\t\tD_RATE(\"Skipping masked lower rate: %d\\n\", low);\n\t}\n\n\thigh = idx;\n\twhile (high != RATE_INVALID) {\n\t\tif (rs_sta->tgg)\n\t\t\thigh = il3945_rates[high].next_rs_tgg;\n\t\telse\n\t\t\thigh = il3945_rates[high].next_rs;\n\t\tif (high == RATE_INVALID)\n\t\t\tbreak;\n\t\tif (rate_mask & (1 << high))\n\t\t\tbreak;\n\t\tD_RATE(\"Skipping masked higher rate: %d\\n\", high);\n\t}\n\n\treturn (high << 8) | low;\n}\n\n \nstatic void\nil3945_rs_get_rate(void *il_r, struct ieee80211_sta *sta, void *il_sta,\n\t\t   struct ieee80211_tx_rate_control *txrc)\n{\n\tstruct ieee80211_supported_band *sband = txrc->sband;\n\tstruct sk_buff *skb = txrc->skb;\n\tu8 low = RATE_INVALID;\n\tu8 high = RATE_INVALID;\n\tu16 high_low;\n\tint idx;\n\tstruct il3945_rs_sta *rs_sta = il_sta;\n\tstruct il3945_rate_scale_data *win = NULL;\n\tint current_tpt = IL_INVALID_VALUE;\n\tint low_tpt = IL_INVALID_VALUE;\n\tint high_tpt = IL_INVALID_VALUE;\n\tu32 fail_count;\n\ts8 scale_action = 0;\n\tunsigned long flags;\n\tu16 rate_mask;\n\ts8 max_rate_idx = -1;\n\tstruct il_priv *il __maybe_unused = (struct il_priv *)il_r;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\n\tD_RATE(\"enter\\n\");\n\n\t \n\tif (rs_sta && !rs_sta->il) {\n\t\tD_RATE(\"Rate scaling information not initialized yet.\\n\");\n\t\til_sta = NULL;\n\t}\n\n\trate_mask = sta->deflink.supp_rates[sband->band];\n\n\t \n\tmax_rate_idx = fls(txrc->rate_idx_mask) - 1;\n\tif (sband->band == NL80211_BAND_5GHZ && max_rate_idx != -1)\n\t\tmax_rate_idx += IL_FIRST_OFDM_RATE;\n\tif (max_rate_idx < 0 || max_rate_idx >= RATE_COUNT)\n\t\tmax_rate_idx = -1;\n\n\tidx = min(rs_sta->last_txrate_idx & 0xffff, RATE_COUNT_3945 - 1);\n\n\tif (sband->band == NL80211_BAND_5GHZ)\n\t\trate_mask = rate_mask << IL_FIRST_OFDM_RATE;\n\n\tspin_lock_irqsave(&rs_sta->lock, flags);\n\n\t \n\tif (rs_sta->start_rate != RATE_INVALID) {\n\t\tif (rs_sta->start_rate < idx &&\n\t\t    (rate_mask & (1 << rs_sta->start_rate)))\n\t\t\tidx = rs_sta->start_rate;\n\t\trs_sta->start_rate = RATE_INVALID;\n\t}\n\n\t \n\tif (max_rate_idx != -1 && max_rate_idx < idx) {\n\t\tif (rate_mask & (1 << max_rate_idx))\n\t\t\tidx = max_rate_idx;\n\t}\n\n\twin = &(rs_sta->win[idx]);\n\n\tfail_count = win->counter - win->success_counter;\n\n\tif (fail_count < RATE_MIN_FAILURE_TH &&\n\t    win->success_counter < RATE_MIN_SUCCESS_TH) {\n\t\tspin_unlock_irqrestore(&rs_sta->lock, flags);\n\n\t\tD_RATE(\"Invalid average_tpt on rate %d: \"\n\t\t       \"counter: %d, success_counter: %d, \"\n\t\t       \"expected_tpt is %sNULL\\n\", idx, win->counter,\n\t\t       win->success_counter,\n\t\t       rs_sta->expected_tpt ? \"not \" : \"\");\n\n\t\t \n\t\twin->average_tpt = IL_INVALID_VALUE;\n\t\tgoto out;\n\n\t}\n\n\tcurrent_tpt = win->average_tpt;\n\n\thigh_low =\n\t    il3945_get_adjacent_rate(rs_sta, idx, rate_mask, sband->band);\n\tlow = high_low & 0xff;\n\thigh = (high_low >> 8) & 0xff;\n\n\t \n\tif (max_rate_idx != -1 && max_rate_idx < high)\n\t\thigh = RATE_INVALID;\n\n\t \n\tif (low != RATE_INVALID)\n\t\tlow_tpt = rs_sta->win[low].average_tpt;\n\n\tif (high != RATE_INVALID)\n\t\thigh_tpt = rs_sta->win[high].average_tpt;\n\n\tspin_unlock_irqrestore(&rs_sta->lock, flags);\n\n\tscale_action = 0;\n\n\t \n\tif (win->success_ratio < RATE_DECREASE_TH || !current_tpt) {\n\t\tD_RATE(\"decrease rate because of low success_ratio\\n\");\n\t\tscale_action = -1;\n\t\t \n\t} else if (low_tpt == IL_INVALID_VALUE && high_tpt == IL_INVALID_VALUE) {\n\n\t\tif (high != RATE_INVALID &&\n\t\t    win->success_ratio >= RATE_INCREASE_TH)\n\t\t\tscale_action = 1;\n\t\telse if (low != RATE_INVALID)\n\t\t\tscale_action = 0;\n\n\t\t \n\t} else if (low_tpt != IL_INVALID_VALUE && high_tpt != IL_INVALID_VALUE\n\t\t   && low_tpt < current_tpt && high_tpt < current_tpt) {\n\n\t\tD_RATE(\"No action -- low [%d] & high [%d] < \"\n\t\t       \"current_tpt [%d]\\n\", low_tpt, high_tpt, current_tpt);\n\t\tscale_action = 0;\n\n\t\t \n\t} else {\n\t\tif (high_tpt != IL_INVALID_VALUE) {\n\n\t\t\t \n\t\t\tif (high_tpt > current_tpt &&\n\t\t\t    win->success_ratio >= RATE_INCREASE_TH)\n\t\t\t\tscale_action = 1;\n\t\t\telse {\n\t\t\t\tD_RATE(\"decrease rate because of high tpt\\n\");\n\t\t\t\tscale_action = 0;\n\t\t\t}\n\t\t} else if (low_tpt != IL_INVALID_VALUE) {\n\t\t\tif (low_tpt > current_tpt) {\n\t\t\t\tD_RATE(\"decrease rate because of low tpt\\n\");\n\t\t\t\tscale_action = -1;\n\t\t\t} else if (win->success_ratio >= RATE_INCREASE_TH) {\n\t\t\t\t \n\t\t\t\tscale_action = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (scale_action == -1 && low != RATE_INVALID &&\n\t    (win->success_ratio > RATE_HIGH_TH ||\n\t     current_tpt > 100 * rs_sta->expected_tpt[low]))\n\t\tscale_action = 0;\n\n\tswitch (scale_action) {\n\tcase -1:\n\t\t \n\t\tif (low != RATE_INVALID)\n\t\t\tidx = low;\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tif (high != RATE_INVALID)\n\t\t\tidx = high;\n\n\t\tbreak;\n\tcase 0:\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tD_RATE(\"Selected %d (action %d) - low %d high %d\\n\", idx, scale_action,\n\t       low, high);\n\nout:\n\n\tif (sband->band == NL80211_BAND_5GHZ) {\n\t\tif (WARN_ON_ONCE(idx < IL_FIRST_OFDM_RATE))\n\t\t\tidx = IL_FIRST_OFDM_RATE;\n\t\trs_sta->last_txrate_idx = idx;\n\t\tinfo->control.rates[0].idx = idx - IL_FIRST_OFDM_RATE;\n\t} else {\n\t\trs_sta->last_txrate_idx = idx;\n\t\tinfo->control.rates[0].idx = rs_sta->last_txrate_idx;\n\t}\n\tinfo->control.rates[0].count = 1;\n\n\tD_RATE(\"leave: %d\\n\", idx);\n}\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\nstatic ssize_t\nil3945_sta_dbgfs_stats_table_read(struct file *file, char __user *user_buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tchar *buff;\n\tint desc = 0;\n\tint j;\n\tssize_t ret;\n\tstruct il3945_rs_sta *lq_sta = file->private_data;\n\n\tbuff = kmalloc(1024, GFP_KERNEL);\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\tdesc +=\n\t    sprintf(buff + desc,\n\t\t    \"tx packets=%d last rate idx=%d\\n\"\n\t\t    \"rate=0x%X flush time %d\\n\", lq_sta->tx_packets,\n\t\t    lq_sta->last_txrate_idx, lq_sta->start_rate,\n\t\t    jiffies_to_msecs(lq_sta->flush_time));\n\tfor (j = 0; j < RATE_COUNT_3945; j++) {\n\t\tdesc +=\n\t\t    sprintf(buff + desc, \"counter=%d success=%d %%=%d\\n\",\n\t\t\t    lq_sta->win[j].counter,\n\t\t\t    lq_sta->win[j].success_counter,\n\t\t\t    lq_sta->win[j].success_ratio);\n\t}\n\tret = simple_read_from_buffer(user_buf, count, ppos, buff, desc);\n\tkfree(buff);\n\treturn ret;\n}\n\nstatic const struct file_operations rs_sta_dbgfs_stats_table_ops = {\n\t.read = il3945_sta_dbgfs_stats_table_read,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic void\nil3945_add_debugfs(void *il, void *il_sta, struct dentry *dir)\n{\n\tstruct il3945_rs_sta *lq_sta = il_sta;\n\n\tdebugfs_create_file(\"rate_stats_table\", 0600, dir, lq_sta,\n\t\t\t    &rs_sta_dbgfs_stats_table_ops);\n}\n#endif\n\n \nstatic void\nil3945_rs_rate_init_stub(void *il_r, struct ieee80211_supported_band *sband,\n\t\t\t struct cfg80211_chan_def *chandef,\n\t\t\t struct ieee80211_sta *sta, void *il_sta)\n{\n}\n\nstatic const struct rate_control_ops rs_ops = {\n\t.name = RS_NAME,\n\t.tx_status = il3945_rs_tx_status,\n\t.get_rate = il3945_rs_get_rate,\n\t.rate_init = il3945_rs_rate_init_stub,\n\t.alloc = il3945_rs_alloc,\n\t.free = il3945_rs_free,\n\t.alloc_sta = il3945_rs_alloc_sta,\n\t.free_sta = il3945_rs_free_sta,\n#ifdef CONFIG_MAC80211_DEBUGFS\n\t.add_sta_debugfs = il3945_add_debugfs,\n#endif\n\n};\n\nvoid\nil3945_rate_scale_init(struct ieee80211_hw *hw, s32 sta_id)\n{\n\tstruct il_priv *il = hw->priv;\n\ts32 rssi = 0;\n\tunsigned long flags;\n\tstruct il3945_rs_sta *rs_sta;\n\tstruct ieee80211_sta *sta;\n\tstruct il3945_sta_priv *psta;\n\n\tD_RATE(\"enter\\n\");\n\n\trcu_read_lock();\n\n\tsta = ieee80211_find_sta(il->vif, il->stations[sta_id].sta.sta.addr);\n\tif (!sta) {\n\t\tD_RATE(\"Unable to find station to initialize rate scaling.\\n\");\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tpsta = (void *)sta->drv_priv;\n\trs_sta = &psta->rs_sta;\n\n\tspin_lock_irqsave(&rs_sta->lock, flags);\n\n\trs_sta->tgg = 0;\n\tswitch (il->band) {\n\tcase NL80211_BAND_2GHZ:\n\t\t \n\t\tif (il->active.flags & RXON_FLG_TGG_PROTECT_MSK) {\n\t\t\trs_sta->tgg = 1;\n\t\t\trs_sta->expected_tpt = il3945_expected_tpt_g_prot;\n\t\t} else\n\t\t\trs_sta->expected_tpt = il3945_expected_tpt_g;\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\trs_sta->expected_tpt = il3945_expected_tpt_a;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&rs_sta->lock, flags);\n\n\trssi = il->_3945.last_rx_rssi;\n\tif (rssi == 0)\n\t\trssi = IL_MIN_RSSI_VAL;\n\n\tD_RATE(\"Network RSSI: %d\\n\", rssi);\n\n\trs_sta->start_rate = il3945_get_rate_idx_by_rssi(rssi, il->band);\n\n\tD_RATE(\"leave: rssi %d assign rate idx: \" \"%d (plcp 0x%x)\\n\", rssi,\n\t       rs_sta->start_rate, il3945_rates[rs_sta->start_rate].plcp);\n\trcu_read_unlock();\n}\n\nint\nil3945_rate_control_register(void)\n{\n\treturn ieee80211_rate_control_register(&rs_ops);\n}\n\nvoid\nil3945_rate_control_unregister(void)\n{\n\tieee80211_rate_control_unregister(&rs_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}