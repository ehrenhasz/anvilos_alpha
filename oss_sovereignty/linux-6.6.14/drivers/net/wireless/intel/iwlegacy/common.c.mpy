{
  "module_name": "common.c",
  "hash_id": "5b3cdc3c7017c79deb440f411f5799739f5508a31e4c2ddb000e44fb1752b8f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlegacy/common.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/etherdevice.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/lockdep.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/skbuff.h>\n#include <net/mac80211.h>\n\n#include \"common.h\"\n\nint\n_il_poll_bit(struct il_priv *il, u32 addr, u32 bits, u32 mask, int timeout)\n{\n\tconst int interval = 10;  \n\tint t = 0;\n\n\tdo {\n\t\tif ((_il_rd(il, addr) & mask) == (bits & mask))\n\t\t\treturn t;\n\t\tudelay(interval);\n\t\tt += interval;\n\t} while (t < timeout);\n\n\treturn -ETIMEDOUT;\n}\nEXPORT_SYMBOL(_il_poll_bit);\n\nvoid\nil_set_bit(struct il_priv *p, u32 r, u32 m)\n{\n\tunsigned long reg_flags;\n\n\tspin_lock_irqsave(&p->reg_lock, reg_flags);\n\t_il_set_bit(p, r, m);\n\tspin_unlock_irqrestore(&p->reg_lock, reg_flags);\n}\nEXPORT_SYMBOL(il_set_bit);\n\nvoid\nil_clear_bit(struct il_priv *p, u32 r, u32 m)\n{\n\tunsigned long reg_flags;\n\n\tspin_lock_irqsave(&p->reg_lock, reg_flags);\n\t_il_clear_bit(p, r, m);\n\tspin_unlock_irqrestore(&p->reg_lock, reg_flags);\n}\nEXPORT_SYMBOL(il_clear_bit);\n\nbool\n_il_grab_nic_access(struct il_priv *il)\n{\n\tint ret;\n\tu32 val;\n\n\t \n\t_il_set_bit(il, CSR_GP_CNTRL, CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);\n\n\t \n\tret =\n\t    _il_poll_bit(il, CSR_GP_CNTRL, CSR_GP_CNTRL_REG_VAL_MAC_ACCESS_EN,\n\t\t\t (CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY |\n\t\t\t  CSR_GP_CNTRL_REG_FLAG_GOING_TO_SLEEP), 15000);\n\tif (unlikely(ret < 0)) {\n\t\tval = _il_rd(il, CSR_GP_CNTRL);\n\t\tWARN_ONCE(1, \"Timeout waiting for ucode processor access \"\n\t\t\t     \"(CSR_GP_CNTRL 0x%08x)\\n\", val);\n\t\t_il_wr(il, CSR_RESET, CSR_RESET_REG_FLAG_FORCE_NMI);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(_il_grab_nic_access);\n\nint\nil_poll_bit(struct il_priv *il, u32 addr, u32 mask, int timeout)\n{\n\tconst int interval = 10;  \n\tint t = 0;\n\n\tdo {\n\t\tif ((il_rd(il, addr) & mask) == mask)\n\t\t\treturn t;\n\t\tudelay(interval);\n\t\tt += interval;\n\t} while (t < timeout);\n\n\treturn -ETIMEDOUT;\n}\nEXPORT_SYMBOL(il_poll_bit);\n\nu32\nil_rd_prph(struct il_priv *il, u32 reg)\n{\n\tunsigned long reg_flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&il->reg_lock, reg_flags);\n\t_il_grab_nic_access(il);\n\tval = _il_rd_prph(il, reg);\n\t_il_release_nic_access(il);\n\tspin_unlock_irqrestore(&il->reg_lock, reg_flags);\n\treturn val;\n}\nEXPORT_SYMBOL(il_rd_prph);\n\nvoid\nil_wr_prph(struct il_priv *il, u32 addr, u32 val)\n{\n\tunsigned long reg_flags;\n\n\tspin_lock_irqsave(&il->reg_lock, reg_flags);\n\tif (likely(_il_grab_nic_access(il))) {\n\t\t_il_wr_prph(il, addr, val);\n\t\t_il_release_nic_access(il);\n\t}\n\tspin_unlock_irqrestore(&il->reg_lock, reg_flags);\n}\nEXPORT_SYMBOL(il_wr_prph);\n\nu32\nil_read_targ_mem(struct il_priv *il, u32 addr)\n{\n\tunsigned long reg_flags;\n\tu32 value;\n\n\tspin_lock_irqsave(&il->reg_lock, reg_flags);\n\t_il_grab_nic_access(il);\n\n\t_il_wr(il, HBUS_TARG_MEM_RADDR, addr);\n\tvalue = _il_rd(il, HBUS_TARG_MEM_RDAT);\n\n\t_il_release_nic_access(il);\n\tspin_unlock_irqrestore(&il->reg_lock, reg_flags);\n\treturn value;\n}\nEXPORT_SYMBOL(il_read_targ_mem);\n\nvoid\nil_write_targ_mem(struct il_priv *il, u32 addr, u32 val)\n{\n\tunsigned long reg_flags;\n\n\tspin_lock_irqsave(&il->reg_lock, reg_flags);\n\tif (likely(_il_grab_nic_access(il))) {\n\t\t_il_wr(il, HBUS_TARG_MEM_WADDR, addr);\n\t\t_il_wr(il, HBUS_TARG_MEM_WDAT, val);\n\t\t_il_release_nic_access(il);\n\t}\n\tspin_unlock_irqrestore(&il->reg_lock, reg_flags);\n}\nEXPORT_SYMBOL(il_write_targ_mem);\n\nconst char *\nil_get_cmd_string(u8 cmd)\n{\n\tswitch (cmd) {\n\t\tIL_CMD(N_ALIVE);\n\t\tIL_CMD(N_ERROR);\n\t\tIL_CMD(C_RXON);\n\t\tIL_CMD(C_RXON_ASSOC);\n\t\tIL_CMD(C_QOS_PARAM);\n\t\tIL_CMD(C_RXON_TIMING);\n\t\tIL_CMD(C_ADD_STA);\n\t\tIL_CMD(C_REM_STA);\n\t\tIL_CMD(C_WEPKEY);\n\t\tIL_CMD(N_3945_RX);\n\t\tIL_CMD(C_TX);\n\t\tIL_CMD(C_RATE_SCALE);\n\t\tIL_CMD(C_LEDS);\n\t\tIL_CMD(C_TX_LINK_QUALITY_CMD);\n\t\tIL_CMD(C_CHANNEL_SWITCH);\n\t\tIL_CMD(N_CHANNEL_SWITCH);\n\t\tIL_CMD(C_SPECTRUM_MEASUREMENT);\n\t\tIL_CMD(N_SPECTRUM_MEASUREMENT);\n\t\tIL_CMD(C_POWER_TBL);\n\t\tIL_CMD(N_PM_SLEEP);\n\t\tIL_CMD(N_PM_DEBUG_STATS);\n\t\tIL_CMD(C_SCAN);\n\t\tIL_CMD(C_SCAN_ABORT);\n\t\tIL_CMD(N_SCAN_START);\n\t\tIL_CMD(N_SCAN_RESULTS);\n\t\tIL_CMD(N_SCAN_COMPLETE);\n\t\tIL_CMD(N_BEACON);\n\t\tIL_CMD(C_TX_BEACON);\n\t\tIL_CMD(C_TX_PWR_TBL);\n\t\tIL_CMD(C_BT_CONFIG);\n\t\tIL_CMD(C_STATS);\n\t\tIL_CMD(N_STATS);\n\t\tIL_CMD(N_CARD_STATE);\n\t\tIL_CMD(N_MISSED_BEACONS);\n\t\tIL_CMD(C_CT_KILL_CONFIG);\n\t\tIL_CMD(C_SENSITIVITY);\n\t\tIL_CMD(C_PHY_CALIBRATION);\n\t\tIL_CMD(N_RX_PHY);\n\t\tIL_CMD(N_RX_MPDU);\n\t\tIL_CMD(N_RX);\n\t\tIL_CMD(N_COMPRESSED_BA);\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\n\t}\n}\nEXPORT_SYMBOL(il_get_cmd_string);\n\n#define HOST_COMPLETE_TIMEOUT (HZ / 2)\n\nstatic void\nil_generic_cmd_callback(struct il_priv *il, struct il_device_cmd *cmd,\n\t\t\tstruct il_rx_pkt *pkt)\n{\n\tif (pkt->hdr.flags & IL_CMD_FAILED_MSK) {\n\t\tIL_ERR(\"Bad return from %s (0x%08X)\\n\",\n\t\t       il_get_cmd_string(cmd->hdr.cmd), pkt->hdr.flags);\n\t\treturn;\n\t}\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tswitch (cmd->hdr.cmd) {\n\tcase C_TX_LINK_QUALITY_CMD:\n\tcase C_SENSITIVITY:\n\t\tD_HC_DUMP(\"back from %s (0x%08X)\\n\",\n\t\t\t  il_get_cmd_string(cmd->hdr.cmd), pkt->hdr.flags);\n\t\tbreak;\n\tdefault:\n\t\tD_HC(\"back from %s (0x%08X)\\n\", il_get_cmd_string(cmd->hdr.cmd),\n\t\t     pkt->hdr.flags);\n\t}\n#endif\n}\n\nstatic int\nil_send_cmd_async(struct il_priv *il, struct il_host_cmd *cmd)\n{\n\tint ret;\n\n\tBUG_ON(!(cmd->flags & CMD_ASYNC));\n\n\t \n\tBUG_ON(cmd->flags & CMD_WANT_SKB);\n\n\t \n\tif (!cmd->callback)\n\t\tcmd->callback = il_generic_cmd_callback;\n\n\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\treturn -EBUSY;\n\n\tret = il_enqueue_hcmd(il, cmd);\n\tif (ret < 0) {\n\t\tIL_ERR(\"Error sending %s: enqueue_hcmd failed: %d\\n\",\n\t\t       il_get_cmd_string(cmd->id), ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nint\nil_send_cmd_sync(struct il_priv *il, struct il_host_cmd *cmd)\n{\n\tint cmd_idx;\n\tint ret;\n\n\tlockdep_assert_held(&il->mutex);\n\n\tBUG_ON(cmd->flags & CMD_ASYNC);\n\n\t \n\tBUG_ON(cmd->callback);\n\n\tD_INFO(\"Attempting to send sync command %s\\n\",\n\t       il_get_cmd_string(cmd->id));\n\n\tset_bit(S_HCMD_ACTIVE, &il->status);\n\tD_INFO(\"Setting HCMD_ACTIVE for command %s\\n\",\n\t       il_get_cmd_string(cmd->id));\n\n\tcmd_idx = il_enqueue_hcmd(il, cmd);\n\tif (cmd_idx < 0) {\n\t\tret = cmd_idx;\n\t\tIL_ERR(\"Error sending %s: enqueue_hcmd failed: %d\\n\",\n\t\t       il_get_cmd_string(cmd->id), ret);\n\t\tgoto out;\n\t}\n\n\tret = wait_event_timeout(il->wait_command_queue,\n\t\t\t\t !test_bit(S_HCMD_ACTIVE, &il->status),\n\t\t\t\t HOST_COMPLETE_TIMEOUT);\n\tif (!ret) {\n\t\tif (test_bit(S_HCMD_ACTIVE, &il->status)) {\n\t\t\tIL_ERR(\"Error sending %s: time out after %dms.\\n\",\n\t\t\t       il_get_cmd_string(cmd->id),\n\t\t\t       jiffies_to_msecs(HOST_COMPLETE_TIMEOUT));\n\n\t\t\tclear_bit(S_HCMD_ACTIVE, &il->status);\n\t\t\tD_INFO(\"Clearing HCMD_ACTIVE for command %s\\n\",\n\t\t\t       il_get_cmd_string(cmd->id));\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto cancel;\n\t\t}\n\t}\n\n\tif (test_bit(S_RFKILL, &il->status)) {\n\t\tIL_ERR(\"Command %s aborted: RF KILL Switch\\n\",\n\t\t       il_get_cmd_string(cmd->id));\n\t\tret = -ECANCELED;\n\t\tgoto fail;\n\t}\n\tif (test_bit(S_FW_ERROR, &il->status)) {\n\t\tIL_ERR(\"Command %s failed: FW Error\\n\",\n\t\t       il_get_cmd_string(cmd->id));\n\t\tret = -EIO;\n\t\tgoto fail;\n\t}\n\tif ((cmd->flags & CMD_WANT_SKB) && !cmd->reply_page) {\n\t\tIL_ERR(\"Error: Response NULL in '%s'\\n\",\n\t\t       il_get_cmd_string(cmd->id));\n\t\tret = -EIO;\n\t\tgoto cancel;\n\t}\n\n\tret = 0;\n\tgoto out;\n\ncancel:\n\tif (cmd->flags & CMD_WANT_SKB) {\n\t\t \n\t\til->txq[il->cmd_queue].meta[cmd_idx].flags &= ~CMD_WANT_SKB;\n\t}\nfail:\n\tif (cmd->reply_page) {\n\t\til_free_pages(il, cmd->reply_page);\n\t\tcmd->reply_page = 0;\n\t}\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL(il_send_cmd_sync);\n\nint\nil_send_cmd(struct il_priv *il, struct il_host_cmd *cmd)\n{\n\tif (cmd->flags & CMD_ASYNC)\n\t\treturn il_send_cmd_async(il, cmd);\n\n\treturn il_send_cmd_sync(il, cmd);\n}\nEXPORT_SYMBOL(il_send_cmd);\n\nint\nil_send_cmd_pdu(struct il_priv *il, u8 id, u16 len, const void *data)\n{\n\tstruct il_host_cmd cmd = {\n\t\t.id = id,\n\t\t.len = len,\n\t\t.data = data,\n\t};\n\n\treturn il_send_cmd_sync(il, &cmd);\n}\nEXPORT_SYMBOL(il_send_cmd_pdu);\n\nint\nil_send_cmd_pdu_async(struct il_priv *il, u8 id, u16 len, const void *data,\n\t\t      void (*callback) (struct il_priv *il,\n\t\t\t\t\tstruct il_device_cmd *cmd,\n\t\t\t\t\tstruct il_rx_pkt *pkt))\n{\n\tstruct il_host_cmd cmd = {\n\t\t.id = id,\n\t\t.len = len,\n\t\t.data = data,\n\t};\n\n\tcmd.flags |= CMD_ASYNC;\n\tcmd.callback = callback;\n\n\treturn il_send_cmd_async(il, &cmd);\n}\nEXPORT_SYMBOL(il_send_cmd_pdu_async);\n\n \nstatic int led_mode;\nmodule_param(led_mode, int, 0444);\nMODULE_PARM_DESC(led_mode,\n\t\t \"0=system default, \" \"1=On(RF On)/Off(RF Off), 2=blinking\");\n\n \nstatic const struct ieee80211_tpt_blink il_blink[] = {\n\t{.throughput = 0,\t\t.blink_time = 334},\n\t{.throughput = 1 * 1024 - 1,\t.blink_time = 260},\n\t{.throughput = 5 * 1024 - 1,\t.blink_time = 220},\n\t{.throughput = 10 * 1024 - 1,\t.blink_time = 190},\n\t{.throughput = 20 * 1024 - 1,\t.blink_time = 170},\n\t{.throughput = 50 * 1024 - 1,\t.blink_time = 150},\n\t{.throughput = 70 * 1024 - 1,\t.blink_time = 130},\n\t{.throughput = 100 * 1024 - 1,\t.blink_time = 110},\n\t{.throughput = 200 * 1024 - 1,\t.blink_time = 80},\n\t{.throughput = 300 * 1024 - 1,\t.blink_time = 50},\n};\n\n \nstatic inline u8\nil_blink_compensation(struct il_priv *il, u8 time, u16 compensation)\n{\n\tif (!compensation) {\n\t\tIL_ERR(\"undefined blink compensation: \"\n\t\t       \"use pre-defined blinking time\\n\");\n\t\treturn time;\n\t}\n\n\treturn (u8) ((time * compensation) >> 6);\n}\n\n \nstatic int\nil_led_cmd(struct il_priv *il, unsigned long on, unsigned long off)\n{\n\tstruct il_led_cmd led_cmd = {\n\t\t.id = IL_LED_LINK,\n\t\t.interval = IL_DEF_LED_INTRVL\n\t};\n\tint ret;\n\n\tif (!test_bit(S_READY, &il->status))\n\t\treturn -EBUSY;\n\n\tif (il->blink_on == on && il->blink_off == off)\n\t\treturn 0;\n\n\tif (off == 0) {\n\t\t \n\t\ton = IL_LED_SOLID;\n\t}\n\n\tD_LED(\"Led blink time compensation=%u\\n\",\n\t      il->cfg->led_compensation);\n\tled_cmd.on =\n\t    il_blink_compensation(il, on,\n\t\t\t\t  il->cfg->led_compensation);\n\tled_cmd.off =\n\t    il_blink_compensation(il, off,\n\t\t\t\t  il->cfg->led_compensation);\n\n\tret = il->ops->send_led_cmd(il, &led_cmd);\n\tif (!ret) {\n\t\til->blink_on = on;\n\t\til->blink_off = off;\n\t}\n\treturn ret;\n}\n\nstatic void\nil_led_brightness_set(struct led_classdev *led_cdev,\n\t\t      enum led_brightness brightness)\n{\n\tstruct il_priv *il = container_of(led_cdev, struct il_priv, led);\n\tunsigned long on = 0;\n\n\tif (brightness > 0)\n\t\ton = IL_LED_SOLID;\n\n\til_led_cmd(il, on, 0);\n}\n\nstatic int\nil_led_blink_set(struct led_classdev *led_cdev, unsigned long *delay_on,\n\t\t unsigned long *delay_off)\n{\n\tstruct il_priv *il = container_of(led_cdev, struct il_priv, led);\n\n\treturn il_led_cmd(il, *delay_on, *delay_off);\n}\n\nvoid\nil_leds_init(struct il_priv *il)\n{\n\tint mode = led_mode;\n\tint ret;\n\n\tif (mode == IL_LED_DEFAULT)\n\t\tmode = il->cfg->led_mode;\n\n\til->led.name =\n\t    kasprintf(GFP_KERNEL, \"%s-led\", wiphy_name(il->hw->wiphy));\n\til->led.brightness_set = il_led_brightness_set;\n\til->led.blink_set = il_led_blink_set;\n\til->led.max_brightness = 1;\n\n\tswitch (mode) {\n\tcase IL_LED_DEFAULT:\n\t\tWARN_ON(1);\n\t\tbreak;\n\tcase IL_LED_BLINK:\n\t\til->led.default_trigger =\n\t\t    ieee80211_create_tpt_led_trigger(il->hw,\n\t\t\t\t\t\t     IEEE80211_TPT_LEDTRIG_FL_CONNECTED,\n\t\t\t\t\t\t     il_blink,\n\t\t\t\t\t\t     ARRAY_SIZE(il_blink));\n\t\tbreak;\n\tcase IL_LED_RF_STATE:\n\t\til->led.default_trigger = ieee80211_get_radio_led_name(il->hw);\n\t\tbreak;\n\t}\n\n\tret = led_classdev_register(&il->pci_dev->dev, &il->led);\n\tif (ret) {\n\t\tkfree(il->led.name);\n\t\treturn;\n\t}\n\n\til->led_registered = true;\n}\nEXPORT_SYMBOL(il_leds_init);\n\nvoid\nil_leds_exit(struct il_priv *il)\n{\n\tif (!il->led_registered)\n\t\treturn;\n\n\tled_classdev_unregister(&il->led);\n\tkfree(il->led.name);\n}\nEXPORT_SYMBOL(il_leds_exit);\n\n \n\n \nconst u8 il_eeprom_band_1[14] = {\n\t1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14\n};\n\n \nstatic const u8 il_eeprom_band_2[] = {\t \n\t183, 184, 185, 187, 188, 189, 192, 196, 7, 8, 11, 12, 16\n};\n\nstatic const u8 il_eeprom_band_3[] = {\t \n\t34, 36, 38, 40, 42, 44, 46, 48, 52, 56, 60, 64\n};\n\nstatic const u8 il_eeprom_band_4[] = {\t \n\t100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140\n};\n\nstatic const u8 il_eeprom_band_5[] = {\t \n\t145, 149, 153, 157, 161, 165\n};\n\nstatic const u8 il_eeprom_band_6[] = {\t \n\t1, 2, 3, 4, 5, 6, 7\n};\n\nstatic const u8 il_eeprom_band_7[] = {\t \n\t36, 44, 52, 60, 100, 108, 116, 124, 132, 149, 157\n};\n\n \n\nstatic int\nil_eeprom_verify_signature(struct il_priv *il)\n{\n\tu32 gp = _il_rd(il, CSR_EEPROM_GP) & CSR_EEPROM_GP_VALID_MSK;\n\tint ret = 0;\n\n\tD_EEPROM(\"EEPROM signature=0x%08x\\n\", gp);\n\tswitch (gp) {\n\tcase CSR_EEPROM_GP_GOOD_SIG_EEP_LESS_THAN_4K:\n\tcase CSR_EEPROM_GP_GOOD_SIG_EEP_MORE_THAN_4K:\n\t\tbreak;\n\tdefault:\n\t\tIL_ERR(\"bad EEPROM signature,\" \"EEPROM_GP=0x%08x\\n\", gp);\n\t\tret = -ENOENT;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nconst u8 *\nil_eeprom_query_addr(const struct il_priv *il, size_t offset)\n{\n\tBUG_ON(offset >= il->cfg->eeprom_size);\n\treturn &il->eeprom[offset];\n}\nEXPORT_SYMBOL(il_eeprom_query_addr);\n\nu16\nil_eeprom_query16(const struct il_priv *il, size_t offset)\n{\n\tif (!il->eeprom)\n\t\treturn 0;\n\treturn (u16) il->eeprom[offset] | ((u16) il->eeprom[offset + 1] << 8);\n}\nEXPORT_SYMBOL(il_eeprom_query16);\n\n \nint\nil_eeprom_init(struct il_priv *il)\n{\n\t__le16 *e;\n\tu32 gp = _il_rd(il, CSR_EEPROM_GP);\n\tint sz;\n\tint ret;\n\tint addr;\n\n\t \n\tsz = il->cfg->eeprom_size;\n\tD_EEPROM(\"NVM size = %d\\n\", sz);\n\til->eeprom = kzalloc(sz, GFP_KERNEL);\n\tif (!il->eeprom)\n\t\treturn -ENOMEM;\n\n\te = (__le16 *) il->eeprom;\n\n\til->ops->apm_init(il);\n\n\tret = il_eeprom_verify_signature(il);\n\tif (ret < 0) {\n\t\tIL_ERR(\"EEPROM not found, EEPROM_GP=0x%08x\\n\", gp);\n\t\tret = -ENOENT;\n\t\tgoto err;\n\t}\n\n\t \n\tret = il->ops->eeprom_acquire_semaphore(il);\n\tif (ret < 0) {\n\t\tIL_ERR(\"Failed to acquire EEPROM semaphore.\\n\");\n\t\tret = -ENOENT;\n\t\tgoto err;\n\t}\n\n\t \n\tfor (addr = 0; addr < sz; addr += sizeof(u16)) {\n\t\tu32 r;\n\n\t\t_il_wr(il, CSR_EEPROM_REG,\n\t\t       CSR_EEPROM_REG_MSK_ADDR & (addr << 1));\n\n\t\tret =\n\t\t    _il_poll_bit(il, CSR_EEPROM_REG,\n\t\t\t\t CSR_EEPROM_REG_READ_VALID_MSK,\n\t\t\t\t CSR_EEPROM_REG_READ_VALID_MSK,\n\t\t\t\t IL_EEPROM_ACCESS_TIMEOUT);\n\t\tif (ret < 0) {\n\t\t\tIL_ERR(\"Time out reading EEPROM[%d]\\n\", addr);\n\t\t\tgoto done;\n\t\t}\n\t\tr = _il_rd(il, CSR_EEPROM_REG);\n\t\te[addr / 2] = cpu_to_le16(r >> 16);\n\t}\n\n\tD_EEPROM(\"NVM Type: %s, version: 0x%x\\n\", \"EEPROM\",\n\t\t il_eeprom_query16(il, EEPROM_VERSION));\n\n\tret = 0;\ndone:\n\til->ops->eeprom_release_semaphore(il);\n\nerr:\n\tif (ret)\n\t\til_eeprom_free(il);\n\t \n\til_apm_stop(il);\n\treturn ret;\n}\nEXPORT_SYMBOL(il_eeprom_init);\n\nvoid\nil_eeprom_free(struct il_priv *il)\n{\n\tkfree(il->eeprom);\n\til->eeprom = NULL;\n}\nEXPORT_SYMBOL(il_eeprom_free);\n\nstatic void\nil_init_band_reference(const struct il_priv *il, int eep_band,\n\t\t       int *eeprom_ch_count,\n\t\t       const struct il_eeprom_channel **eeprom_ch_info,\n\t\t       const u8 **eeprom_ch_idx)\n{\n\tu32 offset = il->cfg->regulatory_bands[eep_band - 1];\n\n\tswitch (eep_band) {\n\tcase 1:\t\t \n\t\t*eeprom_ch_count = ARRAY_SIZE(il_eeprom_band_1);\n\t\t*eeprom_ch_info =\n\t\t    (struct il_eeprom_channel *)il_eeprom_query_addr(il,\n\t\t\t\t\t\t\t\t     offset);\n\t\t*eeprom_ch_idx = il_eeprom_band_1;\n\t\tbreak;\n\tcase 2:\t\t \n\t\t*eeprom_ch_count = ARRAY_SIZE(il_eeprom_band_2);\n\t\t*eeprom_ch_info =\n\t\t    (struct il_eeprom_channel *)il_eeprom_query_addr(il,\n\t\t\t\t\t\t\t\t     offset);\n\t\t*eeprom_ch_idx = il_eeprom_band_2;\n\t\tbreak;\n\tcase 3:\t\t \n\t\t*eeprom_ch_count = ARRAY_SIZE(il_eeprom_band_3);\n\t\t*eeprom_ch_info =\n\t\t    (struct il_eeprom_channel *)il_eeprom_query_addr(il,\n\t\t\t\t\t\t\t\t     offset);\n\t\t*eeprom_ch_idx = il_eeprom_band_3;\n\t\tbreak;\n\tcase 4:\t\t \n\t\t*eeprom_ch_count = ARRAY_SIZE(il_eeprom_band_4);\n\t\t*eeprom_ch_info =\n\t\t    (struct il_eeprom_channel *)il_eeprom_query_addr(il,\n\t\t\t\t\t\t\t\t     offset);\n\t\t*eeprom_ch_idx = il_eeprom_band_4;\n\t\tbreak;\n\tcase 5:\t\t \n\t\t*eeprom_ch_count = ARRAY_SIZE(il_eeprom_band_5);\n\t\t*eeprom_ch_info =\n\t\t    (struct il_eeprom_channel *)il_eeprom_query_addr(il,\n\t\t\t\t\t\t\t\t     offset);\n\t\t*eeprom_ch_idx = il_eeprom_band_5;\n\t\tbreak;\n\tcase 6:\t\t \n\t\t*eeprom_ch_count = ARRAY_SIZE(il_eeprom_band_6);\n\t\t*eeprom_ch_info =\n\t\t    (struct il_eeprom_channel *)il_eeprom_query_addr(il,\n\t\t\t\t\t\t\t\t     offset);\n\t\t*eeprom_ch_idx = il_eeprom_band_6;\n\t\tbreak;\n\tcase 7:\t\t \n\t\t*eeprom_ch_count = ARRAY_SIZE(il_eeprom_band_7);\n\t\t*eeprom_ch_info =\n\t\t    (struct il_eeprom_channel *)il_eeprom_query_addr(il,\n\t\t\t\t\t\t\t\t     offset);\n\t\t*eeprom_ch_idx = il_eeprom_band_7;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\n#define CHECK_AND_PRINT(x) ((eeprom_ch->flags & EEPROM_CHANNEL_##x) \\\n\t\t\t    ? # x \" \" : \"\")\n \nstatic int\nil_mod_ht40_chan_info(struct il_priv *il, enum nl80211_band band, u16 channel,\n\t\t      const struct il_eeprom_channel *eeprom_ch,\n\t\t      u8 clear_ht40_extension_channel)\n{\n\tstruct il_channel_info *ch_info;\n\n\tch_info =\n\t    (struct il_channel_info *)il_get_channel_info(il, band, channel);\n\n\tif (!il_is_channel_valid(ch_info))\n\t\treturn -1;\n\n\tD_EEPROM(\"HT40 Ch. %d [%sGHz] %s%s%s%s%s(0x%02x %ddBm):\"\n\t\t \" Ad-Hoc %ssupported\\n\", ch_info->channel,\n\t\t il_is_channel_a_band(ch_info) ? \"5.2\" : \"2.4\",\n\t\t CHECK_AND_PRINT(IBSS), CHECK_AND_PRINT(ACTIVE),\n\t\t CHECK_AND_PRINT(RADAR), CHECK_AND_PRINT(WIDE),\n\t\t CHECK_AND_PRINT(DFS), eeprom_ch->flags,\n\t\t eeprom_ch->max_power_avg,\n\t\t ((eeprom_ch->flags & EEPROM_CHANNEL_IBSS) &&\n\t\t  !(eeprom_ch->flags & EEPROM_CHANNEL_RADAR)) ? \"\" : \"not \");\n\n\tch_info->ht40_eeprom = *eeprom_ch;\n\tch_info->ht40_max_power_avg = eeprom_ch->max_power_avg;\n\tch_info->ht40_flags = eeprom_ch->flags;\n\tif (eeprom_ch->flags & EEPROM_CHANNEL_VALID)\n\t\tch_info->ht40_extension_channel &=\n\t\t    ~clear_ht40_extension_channel;\n\n\treturn 0;\n}\n\n#define CHECK_AND_PRINT_I(x) ((eeprom_ch_info[ch].flags & EEPROM_CHANNEL_##x) \\\n\t\t\t    ? # x \" \" : \"\")\n\n \nint\nil_init_channel_map(struct il_priv *il)\n{\n\tint eeprom_ch_count = 0;\n\tconst u8 *eeprom_ch_idx = NULL;\n\tconst struct il_eeprom_channel *eeprom_ch_info = NULL;\n\tint band, ch;\n\tstruct il_channel_info *ch_info;\n\n\tif (il->channel_count) {\n\t\tD_EEPROM(\"Channel map already initialized.\\n\");\n\t\treturn 0;\n\t}\n\n\tD_EEPROM(\"Initializing regulatory info from EEPROM\\n\");\n\n\til->channel_count =\n\t    ARRAY_SIZE(il_eeprom_band_1) + ARRAY_SIZE(il_eeprom_band_2) +\n\t    ARRAY_SIZE(il_eeprom_band_3) + ARRAY_SIZE(il_eeprom_band_4) +\n\t    ARRAY_SIZE(il_eeprom_band_5);\n\n\tD_EEPROM(\"Parsing data for %d channels.\\n\", il->channel_count);\n\n\til->channel_info =\n\t    kcalloc(il->channel_count, sizeof(struct il_channel_info),\n\t\t    GFP_KERNEL);\n\tif (!il->channel_info) {\n\t\tIL_ERR(\"Could not allocate channel_info\\n\");\n\t\til->channel_count = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tch_info = il->channel_info;\n\n\t \n\tfor (band = 1; band <= 5; band++) {\n\n\t\til_init_band_reference(il, band, &eeprom_ch_count,\n\t\t\t\t       &eeprom_ch_info, &eeprom_ch_idx);\n\n\t\t \n\t\tfor (ch = 0; ch < eeprom_ch_count; ch++) {\n\t\t\tch_info->channel = eeprom_ch_idx[ch];\n\t\t\tch_info->band =\n\t\t\t    (band ==\n\t\t\t     1) ? NL80211_BAND_2GHZ : NL80211_BAND_5GHZ;\n\n\t\t\t \n\t\t\tch_info->eeprom = eeprom_ch_info[ch];\n\n\t\t\t \n\t\t\tch_info->flags = eeprom_ch_info[ch].flags;\n\t\t\t \n\t\t\tch_info->ht40_extension_channel =\n\t\t\t    IEEE80211_CHAN_NO_HT40;\n\n\t\t\tif (!(il_is_channel_valid(ch_info))) {\n\t\t\t\tD_EEPROM(\"Ch. %d Flags %x [%sGHz] - \"\n\t\t\t\t\t \"No traffic\\n\", ch_info->channel,\n\t\t\t\t\t ch_info->flags,\n\t\t\t\t\t il_is_channel_a_band(ch_info) ? \"5.2\" :\n\t\t\t\t\t \"2.4\");\n\t\t\t\tch_info++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tch_info->max_power_avg = ch_info->curr_txpow =\n\t\t\t    eeprom_ch_info[ch].max_power_avg;\n\t\t\tch_info->scan_power = eeprom_ch_info[ch].max_power_avg;\n\t\t\tch_info->min_power = 0;\n\n\t\t\tD_EEPROM(\"Ch. %d [%sGHz] \" \"%s%s%s%s%s%s(0x%02x %ddBm):\"\n\t\t\t\t \" Ad-Hoc %ssupported\\n\", ch_info->channel,\n\t\t\t\t il_is_channel_a_band(ch_info) ? \"5.2\" : \"2.4\",\n\t\t\t\t CHECK_AND_PRINT_I(VALID),\n\t\t\t\t CHECK_AND_PRINT_I(IBSS),\n\t\t\t\t CHECK_AND_PRINT_I(ACTIVE),\n\t\t\t\t CHECK_AND_PRINT_I(RADAR),\n\t\t\t\t CHECK_AND_PRINT_I(WIDE),\n\t\t\t\t CHECK_AND_PRINT_I(DFS),\n\t\t\t\t eeprom_ch_info[ch].flags,\n\t\t\t\t eeprom_ch_info[ch].max_power_avg,\n\t\t\t\t ((eeprom_ch_info[ch].\n\t\t\t\t   flags & EEPROM_CHANNEL_IBSS) &&\n\t\t\t\t  !(eeprom_ch_info[ch].\n\t\t\t\t    flags & EEPROM_CHANNEL_RADAR)) ? \"\" :\n\t\t\t\t \"not \");\n\n\t\t\tch_info++;\n\t\t}\n\t}\n\n\t \n\tif (il->cfg->regulatory_bands[5] == EEPROM_REGULATORY_BAND_NO_HT40 &&\n\t    il->cfg->regulatory_bands[6] == EEPROM_REGULATORY_BAND_NO_HT40)\n\t\treturn 0;\n\n\t \n\tfor (band = 6; band <= 7; band++) {\n\t\tenum nl80211_band ieeeband;\n\n\t\til_init_band_reference(il, band, &eeprom_ch_count,\n\t\t\t\t       &eeprom_ch_info, &eeprom_ch_idx);\n\n\t\t \n\t\tieeeband =\n\t\t    (band == 6) ? NL80211_BAND_2GHZ : NL80211_BAND_5GHZ;\n\n\t\t \n\t\tfor (ch = 0; ch < eeprom_ch_count; ch++) {\n\t\t\t \n\t\t\til_mod_ht40_chan_info(il, ieeeband, eeprom_ch_idx[ch],\n\t\t\t\t\t      &eeprom_ch_info[ch],\n\t\t\t\t\t      IEEE80211_CHAN_NO_HT40PLUS);\n\n\t\t\t \n\t\t\til_mod_ht40_chan_info(il, ieeeband,\n\t\t\t\t\t      eeprom_ch_idx[ch] + 4,\n\t\t\t\t\t      &eeprom_ch_info[ch],\n\t\t\t\t\t      IEEE80211_CHAN_NO_HT40MINUS);\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(il_init_channel_map);\n\n \nvoid\nil_free_channel_map(struct il_priv *il)\n{\n\tkfree(il->channel_info);\n\til->channel_count = 0;\n}\nEXPORT_SYMBOL(il_free_channel_map);\n\n \nconst struct il_channel_info *\nil_get_channel_info(const struct il_priv *il, enum nl80211_band band,\n\t\t    u16 channel)\n{\n\tint i;\n\n\tswitch (band) {\n\tcase NL80211_BAND_5GHZ:\n\t\tfor (i = 14; i < il->channel_count; i++) {\n\t\t\tif (il->channel_info[i].channel == channel)\n\t\t\t\treturn &il->channel_info[i];\n\t\t}\n\t\tbreak;\n\tcase NL80211_BAND_2GHZ:\n\t\tif (channel >= 1 && channel <= 14)\n\t\t\treturn &il->channel_info[channel - 1];\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(il_get_channel_info);\n\n \n\n#define SLP_VEC(X0, X1, X2, X3, X4) { \\\n\t\tcpu_to_le32(X0), \\\n\t\tcpu_to_le32(X1), \\\n\t\tcpu_to_le32(X2), \\\n\t\tcpu_to_le32(X3), \\\n\t\tcpu_to_le32(X4)  \\\n}\n\nstatic void\nil_build_powertable_cmd(struct il_priv *il, struct il_powertable_cmd *cmd)\n{\n\tstatic const __le32 interval[3][IL_POWER_VEC_SIZE] = {\n\t\tSLP_VEC(2, 2, 4, 6, 0xFF),\n\t\tSLP_VEC(2, 4, 7, 10, 10),\n\t\tSLP_VEC(4, 7, 10, 10, 0xFF)\n\t};\n\tint i, dtim_period, no_dtim;\n\tu32 max_sleep;\n\tbool skip;\n\n\tmemset(cmd, 0, sizeof(*cmd));\n\n\tif (il->power_data.pci_pm)\n\t\tcmd->flags |= IL_POWER_PCI_PM_MSK;\n\n\t \n\tif (il->power_data.ps_disabled)\n\t\treturn;\n\n\tcmd->flags = IL_POWER_DRIVER_ALLOW_SLEEP_MSK;\n\tcmd->keep_alive_seconds = 0;\n\tcmd->debug_flags = 0;\n\tcmd->rx_data_timeout = cpu_to_le32(25 * 1024);\n\tcmd->tx_data_timeout = cpu_to_le32(25 * 1024);\n\tcmd->keep_alive_beacons = 0;\n\n\tdtim_period = il->vif ? il->vif->bss_conf.dtim_period : 0;\n\n\tif (dtim_period <= 2) {\n\t\tmemcpy(cmd->sleep_interval, interval[0], sizeof(interval[0]));\n\t\tno_dtim = 2;\n\t} else if (dtim_period <= 10) {\n\t\tmemcpy(cmd->sleep_interval, interval[1], sizeof(interval[1]));\n\t\tno_dtim = 2;\n\t} else {\n\t\tmemcpy(cmd->sleep_interval, interval[2], sizeof(interval[2]));\n\t\tno_dtim = 0;\n\t}\n\n\tif (dtim_period == 0) {\n\t\tdtim_period = 1;\n\t\tskip = false;\n\t} else {\n\t\tskip = !!no_dtim;\n\t}\n\n\tif (skip) {\n\t\t__le32 tmp = cmd->sleep_interval[IL_POWER_VEC_SIZE - 1];\n\n\t\tmax_sleep = le32_to_cpu(tmp);\n\t\tif (max_sleep == 0xFF)\n\t\t\tmax_sleep = dtim_period * (skip + 1);\n\t\telse if (max_sleep >  dtim_period)\n\t\t\tmax_sleep = (max_sleep / dtim_period) * dtim_period;\n\t\tcmd->flags |= IL_POWER_SLEEP_OVER_DTIM_MSK;\n\t} else {\n\t\tmax_sleep = dtim_period;\n\t\tcmd->flags &= ~IL_POWER_SLEEP_OVER_DTIM_MSK;\n\t}\n\n\tfor (i = 0; i < IL_POWER_VEC_SIZE; i++)\n\t\tif (le32_to_cpu(cmd->sleep_interval[i]) > max_sleep)\n\t\t\tcmd->sleep_interval[i] = cpu_to_le32(max_sleep);\n}\n\nstatic int\nil_set_power(struct il_priv *il, struct il_powertable_cmd *cmd)\n{\n\tD_POWER(\"Sending power/sleep command\\n\");\n\tD_POWER(\"Flags value = 0x%08X\\n\", cmd->flags);\n\tD_POWER(\"Tx timeout = %u\\n\", le32_to_cpu(cmd->tx_data_timeout));\n\tD_POWER(\"Rx timeout = %u\\n\", le32_to_cpu(cmd->rx_data_timeout));\n\tD_POWER(\"Sleep interval vector = { %d , %d , %d , %d , %d }\\n\",\n\t\tle32_to_cpu(cmd->sleep_interval[0]),\n\t\tle32_to_cpu(cmd->sleep_interval[1]),\n\t\tle32_to_cpu(cmd->sleep_interval[2]),\n\t\tle32_to_cpu(cmd->sleep_interval[3]),\n\t\tle32_to_cpu(cmd->sleep_interval[4]));\n\n\treturn il_send_cmd_pdu(il, C_POWER_TBL,\n\t\t\t       sizeof(struct il_powertable_cmd), cmd);\n}\n\nstatic int\nil_power_set_mode(struct il_priv *il, struct il_powertable_cmd *cmd, bool force)\n{\n\tint ret;\n\tbool update_chains;\n\n\tlockdep_assert_held(&il->mutex);\n\n\t \n\tupdate_chains = il->chain_noise_data.state == IL_CHAIN_NOISE_DONE ||\n\t    il->chain_noise_data.state == IL_CHAIN_NOISE_ALIVE;\n\n\tif (!memcmp(&il->power_data.sleep_cmd, cmd, sizeof(*cmd)) && !force)\n\t\treturn 0;\n\n\tif (!il_is_ready_rf(il))\n\t\treturn -EIO;\n\n\t \n\tmemcpy(&il->power_data.sleep_cmd_next, cmd, sizeof(*cmd));\n\tif (test_bit(S_SCANNING, &il->status) && !force) {\n\t\tD_INFO(\"Defer power set mode while scanning\\n\");\n\t\treturn 0;\n\t}\n\n\tif (cmd->flags & IL_POWER_DRIVER_ALLOW_SLEEP_MSK)\n\t\tset_bit(S_POWER_PMI, &il->status);\n\n\tret = il_set_power(il, cmd);\n\tif (!ret) {\n\t\tif (!(cmd->flags & IL_POWER_DRIVER_ALLOW_SLEEP_MSK))\n\t\t\tclear_bit(S_POWER_PMI, &il->status);\n\n\t\tif (il->ops->update_chain_flags && update_chains)\n\t\t\til->ops->update_chain_flags(il);\n\t\telse if (il->ops->update_chain_flags)\n\t\t\tD_POWER(\"Cannot update the power, chain noise \"\n\t\t\t\t\"calibration running: %d\\n\",\n\t\t\t\til->chain_noise_data.state);\n\n\t\tmemcpy(&il->power_data.sleep_cmd, cmd, sizeof(*cmd));\n\t} else\n\t\tIL_ERR(\"set power fail, ret = %d\", ret);\n\n\treturn ret;\n}\n\nint\nil_power_update_mode(struct il_priv *il, bool force)\n{\n\tstruct il_powertable_cmd cmd;\n\n\til_build_powertable_cmd(il, &cmd);\n\n\treturn il_power_set_mode(il, &cmd, force);\n}\nEXPORT_SYMBOL(il_power_update_mode);\n\n \nvoid\nil_power_initialize(struct il_priv *il)\n{\n\tu16 lctl;\n\n\tpcie_capability_read_word(il->pci_dev, PCI_EXP_LNKCTL, &lctl);\n\til->power_data.pci_pm = !(lctl & PCI_EXP_LNKCTL_ASPM_L0S);\n\n\til->power_data.debug_sleep_level_override = -1;\n\n\tmemset(&il->power_data.sleep_cmd, 0, sizeof(il->power_data.sleep_cmd));\n}\nEXPORT_SYMBOL(il_power_initialize);\n\n \n#define IL_ACTIVE_DWELL_TIME_24    (30)\t \n#define IL_ACTIVE_DWELL_TIME_52    (20)\n\n#define IL_ACTIVE_DWELL_FACTOR_24GHZ (3)\n#define IL_ACTIVE_DWELL_FACTOR_52GHZ (2)\n\n \n#define IL_PASSIVE_DWELL_TIME_24   (20)\t \n#define IL_PASSIVE_DWELL_TIME_52   (10)\n#define IL_PASSIVE_DWELL_BASE      (100)\n#define IL_CHANNEL_TUNE_TIME       5\n\nstatic int\nil_send_scan_abort(struct il_priv *il)\n{\n\tint ret;\n\tstruct il_rx_pkt *pkt;\n\tstruct il_host_cmd cmd = {\n\t\t.id = C_SCAN_ABORT,\n\t\t.flags = CMD_WANT_SKB,\n\t};\n\n\t \n\tif (!test_bit(S_READY, &il->status) ||\n\t    !test_bit(S_GEO_CONFIGURED, &il->status) ||\n\t    !test_bit(S_SCAN_HW, &il->status) ||\n\t    test_bit(S_FW_ERROR, &il->status) ||\n\t    test_bit(S_EXIT_PENDING, &il->status))\n\t\treturn -EIO;\n\n\tret = il_send_cmd_sync(il, &cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tpkt = (struct il_rx_pkt *)cmd.reply_page;\n\tif (pkt->u.status != CAN_ABORT_STATUS) {\n\t\t \n\t\tD_SCAN(\"SCAN_ABORT ret %d.\\n\", pkt->u.status);\n\t\tret = -EIO;\n\t}\n\n\til_free_pages(il, cmd.reply_page);\n\treturn ret;\n}\n\nstatic void\nil_complete_scan(struct il_priv *il, bool aborted)\n{\n\tstruct cfg80211_scan_info info = {\n\t\t.aborted = aborted,\n\t};\n\n\t \n\tif (il->scan_request) {\n\t\tD_SCAN(\"Complete scan in mac80211\\n\");\n\t\tieee80211_scan_completed(il->hw, &info);\n\t}\n\n\til->scan_vif = NULL;\n\til->scan_request = NULL;\n}\n\nvoid\nil_force_scan_end(struct il_priv *il)\n{\n\tlockdep_assert_held(&il->mutex);\n\n\tif (!test_bit(S_SCANNING, &il->status)) {\n\t\tD_SCAN(\"Forcing scan end while not scanning\\n\");\n\t\treturn;\n\t}\n\n\tD_SCAN(\"Forcing scan end\\n\");\n\tclear_bit(S_SCANNING, &il->status);\n\tclear_bit(S_SCAN_HW, &il->status);\n\tclear_bit(S_SCAN_ABORTING, &il->status);\n\til_complete_scan(il, true);\n}\n\nstatic void\nil_do_scan_abort(struct il_priv *il)\n{\n\tint ret;\n\n\tlockdep_assert_held(&il->mutex);\n\n\tif (!test_bit(S_SCANNING, &il->status)) {\n\t\tD_SCAN(\"Not performing scan to abort\\n\");\n\t\treturn;\n\t}\n\n\tif (test_and_set_bit(S_SCAN_ABORTING, &il->status)) {\n\t\tD_SCAN(\"Scan abort in progress\\n\");\n\t\treturn;\n\t}\n\n\tret = il_send_scan_abort(il);\n\tif (ret) {\n\t\tD_SCAN(\"Send scan abort failed %d\\n\", ret);\n\t\til_force_scan_end(il);\n\t} else\n\t\tD_SCAN(\"Successfully send scan abort\\n\");\n}\n\n \nint\nil_scan_cancel(struct il_priv *il)\n{\n\tD_SCAN(\"Queuing abort scan\\n\");\n\tqueue_work(il->workqueue, &il->abort_scan);\n\treturn 0;\n}\nEXPORT_SYMBOL(il_scan_cancel);\n\n \nint\nil_scan_cancel_timeout(struct il_priv *il, unsigned long ms)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(ms);\n\n\tlockdep_assert_held(&il->mutex);\n\n\tD_SCAN(\"Scan cancel timeout\\n\");\n\n\til_do_scan_abort(il);\n\n\twhile (time_before_eq(jiffies, timeout)) {\n\t\tif (!test_bit(S_SCAN_HW, &il->status))\n\t\t\tbreak;\n\t\tmsleep(20);\n\t}\n\n\treturn test_bit(S_SCAN_HW, &il->status);\n}\nEXPORT_SYMBOL(il_scan_cancel_timeout);\n\n \nstatic void\nil_hdl_scan(struct il_priv *il, struct il_rx_buf *rxb)\n{\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tstruct il_scanreq_notification *notif =\n\t    (struct il_scanreq_notification *)pkt->u.raw;\n\n\tD_SCAN(\"Scan request status = 0x%x\\n\", notif->status);\n#endif\n}\n\n \nstatic void\nil_hdl_scan_start(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tstruct il_scanstart_notification *notif =\n\t    (struct il_scanstart_notification *)pkt->u.raw;\n\til->scan_start_tsf = le32_to_cpu(notif->tsf_low);\n\tD_SCAN(\"Scan start: \" \"%d [802.11%s] \"\n\t       \"(TSF: 0x%08X:%08X) - %d (beacon timer %u)\\n\", notif->channel,\n\t       notif->band ? \"bg\" : \"a\", le32_to_cpu(notif->tsf_high),\n\t       le32_to_cpu(notif->tsf_low), notif->status, notif->beacon_timer);\n}\n\n \nstatic void\nil_hdl_scan_results(struct il_priv *il, struct il_rx_buf *rxb)\n{\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tstruct il_scanresults_notification *notif =\n\t    (struct il_scanresults_notification *)pkt->u.raw;\n\n\tD_SCAN(\"Scan ch.res: \" \"%d [802.11%s] \" \"(TSF: 0x%08X:%08X) - %d \"\n\t       \"elapsed=%lu usec\\n\", notif->channel, notif->band ? \"bg\" : \"a\",\n\t       le32_to_cpu(notif->tsf_high), le32_to_cpu(notif->tsf_low),\n\t       le32_to_cpu(notif->stats[0]),\n\t       le32_to_cpu(notif->tsf_low) - il->scan_start_tsf);\n#endif\n}\n\n \nstatic void\nil_hdl_scan_complete(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tstruct il_scancomplete_notification *scan_notif = (void *)pkt->u.raw;\n\n\tD_SCAN(\"Scan complete: %d channels (TSF 0x%08X:%08X) - %d\\n\",\n\t       scan_notif->scanned_channels, scan_notif->tsf_low,\n\t       scan_notif->tsf_high, scan_notif->status);\n\n\t \n\tclear_bit(S_SCAN_HW, &il->status);\n\n\tD_SCAN(\"Scan on %sGHz took %dms\\n\",\n\t       (il->scan_band == NL80211_BAND_2GHZ) ? \"2.4\" : \"5.2\",\n\t       jiffies_to_msecs(jiffies - il->scan_start));\n\n\tqueue_work(il->workqueue, &il->scan_completed);\n}\n\nvoid\nil_setup_rx_scan_handlers(struct il_priv *il)\n{\n\t \n\til->handlers[C_SCAN] = il_hdl_scan;\n\til->handlers[N_SCAN_START] = il_hdl_scan_start;\n\til->handlers[N_SCAN_RESULTS] = il_hdl_scan_results;\n\til->handlers[N_SCAN_COMPLETE] = il_hdl_scan_complete;\n}\nEXPORT_SYMBOL(il_setup_rx_scan_handlers);\n\nu16\nil_get_active_dwell_time(struct il_priv *il, enum nl80211_band band,\n\t\t\t u8 n_probes)\n{\n\tif (band == NL80211_BAND_5GHZ)\n\t\treturn IL_ACTIVE_DWELL_TIME_52 +\n\t\t    IL_ACTIVE_DWELL_FACTOR_52GHZ * (n_probes + 1);\n\telse\n\t\treturn IL_ACTIVE_DWELL_TIME_24 +\n\t\t    IL_ACTIVE_DWELL_FACTOR_24GHZ * (n_probes + 1);\n}\nEXPORT_SYMBOL(il_get_active_dwell_time);\n\nu16\nil_get_passive_dwell_time(struct il_priv *il, enum nl80211_band band,\n\t\t\t  struct ieee80211_vif *vif)\n{\n\tu16 value;\n\n\tu16 passive =\n\t    (band ==\n\t     NL80211_BAND_2GHZ) ? IL_PASSIVE_DWELL_BASE +\n\t    IL_PASSIVE_DWELL_TIME_24 : IL_PASSIVE_DWELL_BASE +\n\t    IL_PASSIVE_DWELL_TIME_52;\n\n\tif (il_is_any_associated(il)) {\n\t\t \n\t\tvalue = il->vif ? il->vif->bss_conf.beacon_int : 0;\n\t\tif (value > IL_PASSIVE_DWELL_BASE || !value)\n\t\t\tvalue = IL_PASSIVE_DWELL_BASE;\n\t\tvalue = (value * 98) / 100 - IL_CHANNEL_TUNE_TIME * 2;\n\t\tpassive = min(value, passive);\n\t}\n\n\treturn passive;\n}\nEXPORT_SYMBOL(il_get_passive_dwell_time);\n\nvoid\nil_init_scan_params(struct il_priv *il)\n{\n\tu8 ant_idx = fls(il->hw_params.valid_tx_ant) - 1;\n\tif (!il->scan_tx_ant[NL80211_BAND_5GHZ])\n\t\til->scan_tx_ant[NL80211_BAND_5GHZ] = ant_idx;\n\tif (!il->scan_tx_ant[NL80211_BAND_2GHZ])\n\t\til->scan_tx_ant[NL80211_BAND_2GHZ] = ant_idx;\n}\nEXPORT_SYMBOL(il_init_scan_params);\n\nstatic int\nil_scan_initiate(struct il_priv *il, struct ieee80211_vif *vif)\n{\n\tint ret;\n\n\tlockdep_assert_held(&il->mutex);\n\n\tcancel_delayed_work(&il->scan_check);\n\n\tif (!il_is_ready_rf(il)) {\n\t\tIL_WARN(\"Request scan called when driver not ready.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (test_bit(S_SCAN_HW, &il->status)) {\n\t\tD_SCAN(\"Multiple concurrent scan requests in parallel.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (test_bit(S_SCAN_ABORTING, &il->status)) {\n\t\tD_SCAN(\"Scan request while abort pending.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tD_SCAN(\"Starting scan...\\n\");\n\n\tset_bit(S_SCANNING, &il->status);\n\til->scan_start = jiffies;\n\n\tret = il->ops->request_scan(il, vif);\n\tif (ret) {\n\t\tclear_bit(S_SCANNING, &il->status);\n\t\treturn ret;\n\t}\n\n\tqueue_delayed_work(il->workqueue, &il->scan_check,\n\t\t\t   IL_SCAN_CHECK_WATCHDOG);\n\n\treturn 0;\n}\n\nint\nil_mac_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t       struct ieee80211_scan_request *hw_req)\n{\n\tstruct cfg80211_scan_request *req = &hw_req->req;\n\tstruct il_priv *il = hw->priv;\n\tint ret;\n\n\tif (req->n_channels == 0) {\n\t\tIL_ERR(\"Can not scan on no channels.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&il->mutex);\n\tD_MAC80211(\"enter\\n\");\n\n\tif (test_bit(S_SCANNING, &il->status)) {\n\t\tD_SCAN(\"Scan already in progress.\\n\");\n\t\tret = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\til->scan_request = req;\n\til->scan_vif = vif;\n\til->scan_band = req->channels[0]->band;\n\n\tret = il_scan_initiate(il, vif);\n\nout_unlock:\n\tD_MAC80211(\"leave ret %d\\n\", ret);\n\tmutex_unlock(&il->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(il_mac_hw_scan);\n\nstatic void\nil_bg_scan_check(struct work_struct *data)\n{\n\tstruct il_priv *il =\n\t    container_of(data, struct il_priv, scan_check.work);\n\n\tD_SCAN(\"Scan check work\\n\");\n\n\t \n\tmutex_lock(&il->mutex);\n\til_force_scan_end(il);\n\tmutex_unlock(&il->mutex);\n}\n\n \nu16\nil_fill_probe_req(struct il_priv *il, struct ieee80211_mgmt *frame,\n\t\t  const u8 *ta, const u8 *ies, int ie_len, int left)\n{\n\tint len = 0;\n\tu8 *pos = NULL;\n\n\t \n\tleft -= 24;\n\tif (left < 0)\n\t\treturn 0;\n\n\tframe->frame_control = cpu_to_le16(IEEE80211_STYPE_PROBE_REQ);\n\teth_broadcast_addr(frame->da);\n\tmemcpy(frame->sa, ta, ETH_ALEN);\n\teth_broadcast_addr(frame->bssid);\n\tframe->seq_ctrl = 0;\n\n\tlen += 24;\n\n\t \n\tpos = &frame->u.probe_req.variable[0];\n\n\t \n\tleft -= 2;\n\tif (left < 0)\n\t\treturn 0;\n\t*pos++ = WLAN_EID_SSID;\n\t*pos++ = 0;\n\n\tlen += 2;\n\n\tif (WARN_ON(left < ie_len))\n\t\treturn len;\n\n\tif (ies && ie_len) {\n\t\tmemcpy(pos, ies, ie_len);\n\t\tlen += ie_len;\n\t}\n\n\treturn (u16) len;\n}\nEXPORT_SYMBOL(il_fill_probe_req);\n\nstatic void\nil_bg_abort_scan(struct work_struct *work)\n{\n\tstruct il_priv *il = container_of(work, struct il_priv, abort_scan);\n\n\tD_SCAN(\"Abort scan work\\n\");\n\n\t \n\tmutex_lock(&il->mutex);\n\til_scan_cancel_timeout(il, 200);\n\tmutex_unlock(&il->mutex);\n}\n\nstatic void\nil_bg_scan_completed(struct work_struct *work)\n{\n\tstruct il_priv *il = container_of(work, struct il_priv, scan_completed);\n\tbool aborted;\n\n\tD_SCAN(\"Completed scan.\\n\");\n\n\tcancel_delayed_work(&il->scan_check);\n\n\tmutex_lock(&il->mutex);\n\n\taborted = test_and_clear_bit(S_SCAN_ABORTING, &il->status);\n\tif (aborted)\n\t\tD_SCAN(\"Aborted scan completed.\\n\");\n\n\tif (!test_and_clear_bit(S_SCANNING, &il->status)) {\n\t\tD_SCAN(\"Scan already completed.\\n\");\n\t\tgoto out_settings;\n\t}\n\n\til_complete_scan(il, aborted);\n\nout_settings:\n\t \n\tif (!il_is_ready_rf(il))\n\t\tgoto out;\n\n\t \n\til_power_set_mode(il, &il->power_data.sleep_cmd_next, false);\n\til_set_tx_power(il, il->tx_power_next, false);\n\n\til->ops->post_scan(il);\n\nout:\n\tmutex_unlock(&il->mutex);\n}\n\nvoid\nil_setup_scan_deferred_work(struct il_priv *il)\n{\n\tINIT_WORK(&il->scan_completed, il_bg_scan_completed);\n\tINIT_WORK(&il->abort_scan, il_bg_abort_scan);\n\tINIT_DELAYED_WORK(&il->scan_check, il_bg_scan_check);\n}\nEXPORT_SYMBOL(il_setup_scan_deferred_work);\n\nvoid\nil_cancel_scan_deferred_work(struct il_priv *il)\n{\n\tcancel_work_sync(&il->abort_scan);\n\tcancel_work_sync(&il->scan_completed);\n\n\tif (cancel_delayed_work_sync(&il->scan_check)) {\n\t\tmutex_lock(&il->mutex);\n\t\til_force_scan_end(il);\n\t\tmutex_unlock(&il->mutex);\n\t}\n}\nEXPORT_SYMBOL(il_cancel_scan_deferred_work);\n\n \nstatic void\nil_sta_ucode_activate(struct il_priv *il, u8 sta_id)\n{\n\n\tif (!(il->stations[sta_id].used & IL_STA_DRIVER_ACTIVE))\n\t\tIL_ERR(\"ACTIVATE a non DRIVER active station id %u addr %pM\\n\",\n\t\t       sta_id, il->stations[sta_id].sta.sta.addr);\n\n\tif (il->stations[sta_id].used & IL_STA_UCODE_ACTIVE) {\n\t\tD_ASSOC(\"STA id %u addr %pM already present\"\n\t\t\t\" in uCode (according to driver)\\n\", sta_id,\n\t\t\til->stations[sta_id].sta.sta.addr);\n\t} else {\n\t\til->stations[sta_id].used |= IL_STA_UCODE_ACTIVE;\n\t\tD_ASSOC(\"Added STA id %u addr %pM to uCode\\n\", sta_id,\n\t\t\til->stations[sta_id].sta.sta.addr);\n\t}\n}\n\nstatic int\nil_process_add_sta_resp(struct il_priv *il, struct il_addsta_cmd *addsta,\n\t\t\tstruct il_rx_pkt *pkt, bool sync)\n{\n\tu8 sta_id = addsta->sta.sta_id;\n\tunsigned long flags;\n\tint ret = -EIO;\n\n\tif (pkt->hdr.flags & IL_CMD_FAILED_MSK) {\n\t\tIL_ERR(\"Bad return from C_ADD_STA (0x%08X)\\n\", pkt->hdr.flags);\n\t\treturn ret;\n\t}\n\n\tD_INFO(\"Processing response for adding station %u\\n\", sta_id);\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\n\tswitch (pkt->u.add_sta.status) {\n\tcase ADD_STA_SUCCESS_MSK:\n\t\tD_INFO(\"C_ADD_STA PASSED\\n\");\n\t\til_sta_ucode_activate(il, sta_id);\n\t\tret = 0;\n\t\tbreak;\n\tcase ADD_STA_NO_ROOM_IN_TBL:\n\t\tIL_ERR(\"Adding station %d failed, no room in table.\\n\", sta_id);\n\t\tbreak;\n\tcase ADD_STA_NO_BLOCK_ACK_RESOURCE:\n\t\tIL_ERR(\"Adding station %d failed, no block ack resource.\\n\",\n\t\t       sta_id);\n\t\tbreak;\n\tcase ADD_STA_MODIFY_NON_EXIST_STA:\n\t\tIL_ERR(\"Attempting to modify non-existing station %d\\n\",\n\t\t       sta_id);\n\t\tbreak;\n\tdefault:\n\t\tD_ASSOC(\"Received C_ADD_STA:(0x%08X)\\n\", pkt->u.add_sta.status);\n\t\tbreak;\n\t}\n\n\tD_INFO(\"%s station id %u addr %pM\\n\",\n\t       il->stations[sta_id].sta.mode ==\n\t       STA_CONTROL_MODIFY_MSK ? \"Modified\" : \"Added\", sta_id,\n\t       il->stations[sta_id].sta.sta.addr);\n\n\t \n\tD_INFO(\"%s station according to cmd buffer %pM\\n\",\n\t       il->stations[sta_id].sta.mode ==\n\t       STA_CONTROL_MODIFY_MSK ? \"Modified\" : \"Added\", addsta->sta.addr);\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\treturn ret;\n}\n\nstatic void\nil_add_sta_callback(struct il_priv *il, struct il_device_cmd *cmd,\n\t\t    struct il_rx_pkt *pkt)\n{\n\tstruct il_addsta_cmd *addsta = (struct il_addsta_cmd *)cmd->cmd.payload;\n\n\til_process_add_sta_resp(il, addsta, pkt, false);\n\n}\n\nint\nil_send_add_sta(struct il_priv *il, struct il_addsta_cmd *sta, u8 flags)\n{\n\tstruct il_rx_pkt *pkt = NULL;\n\tint ret = 0;\n\tu8 data[sizeof(*sta)];\n\tstruct il_host_cmd cmd = {\n\t\t.id = C_ADD_STA,\n\t\t.flags = flags,\n\t\t.data = data,\n\t};\n\tu8 sta_id __maybe_unused = sta->sta.sta_id;\n\n\tD_INFO(\"Adding sta %u (%pM) %ssynchronously\\n\", sta_id, sta->sta.addr,\n\t       flags & CMD_ASYNC ? \"a\" : \"\");\n\n\tif (flags & CMD_ASYNC)\n\t\tcmd.callback = il_add_sta_callback;\n\telse {\n\t\tcmd.flags |= CMD_WANT_SKB;\n\t\tmight_sleep();\n\t}\n\n\tcmd.len = il->ops->build_addsta_hcmd(sta, data);\n\tret = il_send_cmd(il, &cmd);\n\tif (ret)\n\t\treturn ret;\n\tif (flags & CMD_ASYNC)\n\t\treturn 0;\n\n\tpkt = (struct il_rx_pkt *)cmd.reply_page;\n\tret = il_process_add_sta_resp(il, sta, pkt, true);\n\n\til_free_pages(il, cmd.reply_page);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(il_send_add_sta);\n\nstatic void\nil_set_ht_add_station(struct il_priv *il, u8 idx, struct ieee80211_sta *sta)\n{\n\tstruct ieee80211_sta_ht_cap *sta_ht_inf = &sta->deflink.ht_cap;\n\t__le32 sta_flags;\n\n\tif (!sta || !sta_ht_inf->ht_supported)\n\t\tgoto done;\n\n\tD_ASSOC(\"spatial multiplexing power save mode: %s\\n\",\n\t\t(sta->deflink.smps_mode == IEEE80211_SMPS_STATIC) ? \"static\" :\n\t\t(sta->deflink.smps_mode == IEEE80211_SMPS_DYNAMIC) ? \"dynamic\" :\n\t\t\"disabled\");\n\n\tsta_flags = il->stations[idx].sta.station_flags;\n\n\tsta_flags &= ~(STA_FLG_RTS_MIMO_PROT_MSK | STA_FLG_MIMO_DIS_MSK);\n\n\tswitch (sta->deflink.smps_mode) {\n\tcase IEEE80211_SMPS_STATIC:\n\t\tsta_flags |= STA_FLG_MIMO_DIS_MSK;\n\t\tbreak;\n\tcase IEEE80211_SMPS_DYNAMIC:\n\t\tsta_flags |= STA_FLG_RTS_MIMO_PROT_MSK;\n\t\tbreak;\n\tcase IEEE80211_SMPS_OFF:\n\t\tbreak;\n\tdefault:\n\t\tIL_WARN(\"Invalid MIMO PS mode %d\\n\", sta->deflink.smps_mode);\n\t\tbreak;\n\t}\n\n\tsta_flags |=\n\t    cpu_to_le32((u32) sta_ht_inf->\n\t\t\tampdu_factor << STA_FLG_MAX_AGG_SIZE_POS);\n\n\tsta_flags |=\n\t    cpu_to_le32((u32) sta_ht_inf->\n\t\t\tampdu_density << STA_FLG_AGG_MPDU_DENSITY_POS);\n\n\tif (il_is_ht40_tx_allowed(il, &sta->deflink.ht_cap))\n\t\tsta_flags |= STA_FLG_HT40_EN_MSK;\n\telse\n\t\tsta_flags &= ~STA_FLG_HT40_EN_MSK;\n\n\til->stations[idx].sta.station_flags = sta_flags;\ndone:\n\treturn;\n}\n\n \nu8\nil_prep_station(struct il_priv *il, const u8 *addr, bool is_ap,\n\t\tstruct ieee80211_sta *sta)\n{\n\tstruct il_station_entry *station;\n\tint i;\n\tu8 sta_id = IL_INVALID_STATION;\n\tu16 rate;\n\n\tif (is_ap)\n\t\tsta_id = IL_AP_ID;\n\telse if (is_broadcast_ether_addr(addr))\n\t\tsta_id = il->hw_params.bcast_id;\n\telse\n\t\tfor (i = IL_STA_ID; i < il->hw_params.max_stations; i++) {\n\t\t\tif (ether_addr_equal(il->stations[i].sta.sta.addr,\n\t\t\t\t\t     addr)) {\n\t\t\t\tsta_id = i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!il->stations[i].used &&\n\t\t\t    sta_id == IL_INVALID_STATION)\n\t\t\t\tsta_id = i;\n\t\t}\n\n\t \n\tif (unlikely(sta_id == IL_INVALID_STATION))\n\t\treturn sta_id;\n\n\t \n\tif (il->stations[sta_id].used & IL_STA_UCODE_INPROGRESS) {\n\t\tD_INFO(\"STA %d already in process of being added.\\n\", sta_id);\n\t\treturn sta_id;\n\t}\n\n\tif ((il->stations[sta_id].used & IL_STA_DRIVER_ACTIVE) &&\n\t    (il->stations[sta_id].used & IL_STA_UCODE_ACTIVE) &&\n\t    ether_addr_equal(il->stations[sta_id].sta.sta.addr, addr)) {\n\t\tD_ASSOC(\"STA %d (%pM) already added, not adding again.\\n\",\n\t\t\tsta_id, addr);\n\t\treturn sta_id;\n\t}\n\n\tstation = &il->stations[sta_id];\n\tstation->used = IL_STA_DRIVER_ACTIVE;\n\tD_ASSOC(\"Add STA to driver ID %d: %pM\\n\", sta_id, addr);\n\til->num_stations++;\n\n\t \n\tmemset(&station->sta, 0, sizeof(struct il_addsta_cmd));\n\tmemcpy(station->sta.sta.addr, addr, ETH_ALEN);\n\tstation->sta.mode = 0;\n\tstation->sta.sta.sta_id = sta_id;\n\tstation->sta.station_flags = 0;\n\n\t \n\til_set_ht_add_station(il, sta_id, sta);\n\n\t \n\trate = (il->band == NL80211_BAND_5GHZ) ? RATE_6M_PLCP : RATE_1M_PLCP;\n\t \n\tstation->sta.rate_n_flags = cpu_to_le16(rate | RATE_MCS_ANT_AB_MSK);\n\n\treturn sta_id;\n\n}\nEXPORT_SYMBOL_GPL(il_prep_station);\n\n#define STA_WAIT_TIMEOUT (HZ/2)\n\n \nint\nil_add_station_common(struct il_priv *il, const u8 *addr, bool is_ap,\n\t\t      struct ieee80211_sta *sta, u8 *sta_id_r)\n{\n\tunsigned long flags_spin;\n\tint ret = 0;\n\tu8 sta_id;\n\tstruct il_addsta_cmd sta_cmd;\n\n\t*sta_id_r = 0;\n\tspin_lock_irqsave(&il->sta_lock, flags_spin);\n\tsta_id = il_prep_station(il, addr, is_ap, sta);\n\tif (sta_id == IL_INVALID_STATION) {\n\t\tIL_ERR(\"Unable to prepare station %pM for addition\\n\", addr);\n\t\tspin_unlock_irqrestore(&il->sta_lock, flags_spin);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (il->stations[sta_id].used & IL_STA_UCODE_INPROGRESS) {\n\t\tD_INFO(\"STA %d already in process of being added.\\n\", sta_id);\n\t\tspin_unlock_irqrestore(&il->sta_lock, flags_spin);\n\t\treturn -EEXIST;\n\t}\n\n\tif ((il->stations[sta_id].used & IL_STA_DRIVER_ACTIVE) &&\n\t    (il->stations[sta_id].used & IL_STA_UCODE_ACTIVE)) {\n\t\tD_ASSOC(\"STA %d (%pM) already added, not adding again.\\n\",\n\t\t\tsta_id, addr);\n\t\tspin_unlock_irqrestore(&il->sta_lock, flags_spin);\n\t\treturn -EEXIST;\n\t}\n\n\til->stations[sta_id].used |= IL_STA_UCODE_INPROGRESS;\n\tmemcpy(&sta_cmd, &il->stations[sta_id].sta,\n\t       sizeof(struct il_addsta_cmd));\n\tspin_unlock_irqrestore(&il->sta_lock, flags_spin);\n\n\t \n\tret = il_send_add_sta(il, &sta_cmd, CMD_SYNC);\n\tif (ret) {\n\t\tspin_lock_irqsave(&il->sta_lock, flags_spin);\n\t\tIL_ERR(\"Adding station %pM failed.\\n\",\n\t\t       il->stations[sta_id].sta.sta.addr);\n\t\til->stations[sta_id].used &= ~IL_STA_DRIVER_ACTIVE;\n\t\til->stations[sta_id].used &= ~IL_STA_UCODE_INPROGRESS;\n\t\tspin_unlock_irqrestore(&il->sta_lock, flags_spin);\n\t}\n\t*sta_id_r = sta_id;\n\treturn ret;\n}\nEXPORT_SYMBOL(il_add_station_common);\n\n \nstatic void\nil_sta_ucode_deactivate(struct il_priv *il, u8 sta_id)\n{\n\t \n\tif ((il->stations[sta_id].\n\t     used & (IL_STA_UCODE_ACTIVE | IL_STA_DRIVER_ACTIVE)) !=\n\t    IL_STA_UCODE_ACTIVE)\n\t\tIL_ERR(\"removed non active STA %u\\n\", sta_id);\n\n\til->stations[sta_id].used &= ~IL_STA_UCODE_ACTIVE;\n\n\tmemset(&il->stations[sta_id], 0, sizeof(struct il_station_entry));\n\tD_ASSOC(\"Removed STA %u\\n\", sta_id);\n}\n\nstatic int\nil_send_remove_station(struct il_priv *il, const u8 * addr, int sta_id,\n\t\t       bool temporary)\n{\n\tstruct il_rx_pkt *pkt;\n\tint ret;\n\n\tunsigned long flags_spin;\n\tstruct il_rem_sta_cmd rm_sta_cmd;\n\n\tstruct il_host_cmd cmd = {\n\t\t.id = C_REM_STA,\n\t\t.len = sizeof(struct il_rem_sta_cmd),\n\t\t.flags = CMD_SYNC,\n\t\t.data = &rm_sta_cmd,\n\t};\n\n\tmemset(&rm_sta_cmd, 0, sizeof(rm_sta_cmd));\n\trm_sta_cmd.num_sta = 1;\n\tmemcpy(&rm_sta_cmd.addr, addr, ETH_ALEN);\n\n\tcmd.flags |= CMD_WANT_SKB;\n\n\tret = il_send_cmd(il, &cmd);\n\n\tif (ret)\n\t\treturn ret;\n\n\tpkt = (struct il_rx_pkt *)cmd.reply_page;\n\tif (pkt->hdr.flags & IL_CMD_FAILED_MSK) {\n\t\tIL_ERR(\"Bad return from C_REM_STA (0x%08X)\\n\", pkt->hdr.flags);\n\t\tret = -EIO;\n\t}\n\n\tif (!ret) {\n\t\tswitch (pkt->u.rem_sta.status) {\n\t\tcase REM_STA_SUCCESS_MSK:\n\t\t\tif (!temporary) {\n\t\t\t\tspin_lock_irqsave(&il->sta_lock, flags_spin);\n\t\t\t\til_sta_ucode_deactivate(il, sta_id);\n\t\t\t\tspin_unlock_irqrestore(&il->sta_lock,\n\t\t\t\t\t\t       flags_spin);\n\t\t\t}\n\t\t\tD_ASSOC(\"C_REM_STA PASSED\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EIO;\n\t\t\tIL_ERR(\"C_REM_STA failed\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\til_free_pages(il, cmd.reply_page);\n\n\treturn ret;\n}\n\n \nint\nil_remove_station(struct il_priv *il, const u8 sta_id, const u8 * addr)\n{\n\tunsigned long flags;\n\n\tif (!il_is_ready(il)) {\n\t\tD_INFO(\"Unable to remove station %pM, device not ready.\\n\",\n\t\t       addr);\n\t\t \n\t\treturn 0;\n\t}\n\n\tD_ASSOC(\"Removing STA from driver:%d  %pM\\n\", sta_id, addr);\n\n\tif (WARN_ON(sta_id == IL_INVALID_STATION))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\n\tif (!(il->stations[sta_id].used & IL_STA_DRIVER_ACTIVE)) {\n\t\tD_INFO(\"Removing %pM but non DRIVER active\\n\", addr);\n\t\tgoto out_err;\n\t}\n\n\tif (!(il->stations[sta_id].used & IL_STA_UCODE_ACTIVE)) {\n\t\tD_INFO(\"Removing %pM but non UCODE active\\n\", addr);\n\t\tgoto out_err;\n\t}\n\n\tif (il->stations[sta_id].used & IL_STA_LOCAL) {\n\t\tkfree(il->stations[sta_id].lq);\n\t\til->stations[sta_id].lq = NULL;\n\t}\n\n\til->stations[sta_id].used &= ~IL_STA_DRIVER_ACTIVE;\n\n\til->num_stations--;\n\n\tBUG_ON(il->num_stations < 0);\n\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\n\treturn il_send_remove_station(il, addr, sta_id, false);\nout_err:\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(il_remove_station);\n\n \nvoid\nil_clear_ucode_stations(struct il_priv *il)\n{\n\tint i;\n\tunsigned long flags_spin;\n\tbool cleared = false;\n\n\tD_INFO(\"Clearing ucode stations in driver\\n\");\n\n\tspin_lock_irqsave(&il->sta_lock, flags_spin);\n\tfor (i = 0; i < il->hw_params.max_stations; i++) {\n\t\tif (il->stations[i].used & IL_STA_UCODE_ACTIVE) {\n\t\t\tD_INFO(\"Clearing ucode active for station %d\\n\", i);\n\t\t\til->stations[i].used &= ~IL_STA_UCODE_ACTIVE;\n\t\t\tcleared = true;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&il->sta_lock, flags_spin);\n\n\tif (!cleared)\n\t\tD_INFO(\"No active stations found to be cleared\\n\");\n}\nEXPORT_SYMBOL(il_clear_ucode_stations);\n\n \nvoid\nil_restore_stations(struct il_priv *il)\n{\n\tstruct il_addsta_cmd sta_cmd;\n\tstruct il_link_quality_cmd lq;\n\tunsigned long flags_spin;\n\tint i;\n\tbool found = false;\n\tint ret;\n\tbool send_lq;\n\n\tif (!il_is_ready(il)) {\n\t\tD_INFO(\"Not ready yet, not restoring any stations.\\n\");\n\t\treturn;\n\t}\n\n\tD_ASSOC(\"Restoring all known stations ... start.\\n\");\n\tspin_lock_irqsave(&il->sta_lock, flags_spin);\n\tfor (i = 0; i < il->hw_params.max_stations; i++) {\n\t\tif ((il->stations[i].used & IL_STA_DRIVER_ACTIVE) &&\n\t\t    !(il->stations[i].used & IL_STA_UCODE_ACTIVE)) {\n\t\t\tD_ASSOC(\"Restoring sta %pM\\n\",\n\t\t\t\til->stations[i].sta.sta.addr);\n\t\t\til->stations[i].sta.mode = 0;\n\t\t\til->stations[i].used |= IL_STA_UCODE_INPROGRESS;\n\t\t\tfound = true;\n\t\t}\n\t}\n\n\tfor (i = 0; i < il->hw_params.max_stations; i++) {\n\t\tif ((il->stations[i].used & IL_STA_UCODE_INPROGRESS)) {\n\t\t\tmemcpy(&sta_cmd, &il->stations[i].sta,\n\t\t\t       sizeof(struct il_addsta_cmd));\n\t\t\tsend_lq = false;\n\t\t\tif (il->stations[i].lq) {\n\t\t\t\tmemcpy(&lq, il->stations[i].lq,\n\t\t\t\t       sizeof(struct il_link_quality_cmd));\n\t\t\t\tsend_lq = true;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&il->sta_lock, flags_spin);\n\t\t\tret = il_send_add_sta(il, &sta_cmd, CMD_SYNC);\n\t\t\tif (ret) {\n\t\t\t\tspin_lock_irqsave(&il->sta_lock, flags_spin);\n\t\t\t\tIL_ERR(\"Adding station %pM failed.\\n\",\n\t\t\t\t       il->stations[i].sta.sta.addr);\n\t\t\t\til->stations[i].used &= ~IL_STA_DRIVER_ACTIVE;\n\t\t\t\til->stations[i].used &=\n\t\t\t\t    ~IL_STA_UCODE_INPROGRESS;\n\t\t\t\tspin_unlock_irqrestore(&il->sta_lock,\n\t\t\t\t\t\t       flags_spin);\n\t\t\t}\n\t\t\t \n\t\t\tif (send_lq)\n\t\t\t\til_send_lq_cmd(il, &lq, CMD_SYNC, true);\n\t\t\tspin_lock_irqsave(&il->sta_lock, flags_spin);\n\t\t\til->stations[i].used &= ~IL_STA_UCODE_INPROGRESS;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&il->sta_lock, flags_spin);\n\tif (!found)\n\t\tD_INFO(\"Restoring all known stations\"\n\t\t       \" .... no stations to be restored.\\n\");\n\telse\n\t\tD_INFO(\"Restoring all known stations\" \" .... complete.\\n\");\n}\nEXPORT_SYMBOL(il_restore_stations);\n\nint\nil_get_free_ucode_key_idx(struct il_priv *il)\n{\n\tint i;\n\n\tfor (i = 0; i < il->sta_key_max_num; i++)\n\t\tif (!test_and_set_bit(i, &il->ucode_key_table))\n\t\t\treturn i;\n\n\treturn WEP_INVALID_OFFSET;\n}\nEXPORT_SYMBOL(il_get_free_ucode_key_idx);\n\nvoid\nil_dealloc_bcast_stations(struct il_priv *il)\n{\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&il->sta_lock, flags);\n\tfor (i = 0; i < il->hw_params.max_stations; i++) {\n\t\tif (!(il->stations[i].used & IL_STA_BCAST))\n\t\t\tcontinue;\n\n\t\til->stations[i].used &= ~IL_STA_UCODE_ACTIVE;\n\t\til->num_stations--;\n\t\tBUG_ON(il->num_stations < 0);\n\t\tkfree(il->stations[i].lq);\n\t\til->stations[i].lq = NULL;\n\t}\n\tspin_unlock_irqrestore(&il->sta_lock, flags);\n}\nEXPORT_SYMBOL_GPL(il_dealloc_bcast_stations);\n\n#ifdef CONFIG_IWLEGACY_DEBUG\nstatic void\nil_dump_lq_cmd(struct il_priv *il, struct il_link_quality_cmd *lq)\n{\n\tint i;\n\tD_RATE(\"lq station id 0x%x\\n\", lq->sta_id);\n\tD_RATE(\"lq ant 0x%X 0x%X\\n\", lq->general_params.single_stream_ant_msk,\n\t       lq->general_params.dual_stream_ant_msk);\n\n\tfor (i = 0; i < LINK_QUAL_MAX_RETRY_NUM; i++)\n\t\tD_RATE(\"lq idx %d 0x%X\\n\", i, lq->rs_table[i].rate_n_flags);\n}\n#else\nstatic inline void\nil_dump_lq_cmd(struct il_priv *il, struct il_link_quality_cmd *lq)\n{\n}\n#endif\n\n \nstatic bool\nil_is_lq_table_valid(struct il_priv *il, struct il_link_quality_cmd *lq)\n{\n\tint i;\n\n\tif (il->ht.enabled)\n\t\treturn true;\n\n\tD_INFO(\"Channel %u is not an HT channel\\n\", il->active.channel);\n\tfor (i = 0; i < LINK_QUAL_MAX_RETRY_NUM; i++) {\n\t\tif (le32_to_cpu(lq->rs_table[i].rate_n_flags) & RATE_MCS_HT_MSK) {\n\t\t\tD_INFO(\"idx %d of LQ expects HT channel\\n\", i);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n \nint\nil_send_lq_cmd(struct il_priv *il, struct il_link_quality_cmd *lq,\n\t       u8 flags, bool init)\n{\n\tint ret = 0;\n\tunsigned long flags_spin;\n\n\tstruct il_host_cmd cmd = {\n\t\t.id = C_TX_LINK_QUALITY_CMD,\n\t\t.len = sizeof(struct il_link_quality_cmd),\n\t\t.flags = flags,\n\t\t.data = lq,\n\t};\n\n\tif (WARN_ON(lq->sta_id == IL_INVALID_STATION))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&il->sta_lock, flags_spin);\n\tif (!(il->stations[lq->sta_id].used & IL_STA_DRIVER_ACTIVE)) {\n\t\tspin_unlock_irqrestore(&il->sta_lock, flags_spin);\n\t\treturn -EINVAL;\n\t}\n\tspin_unlock_irqrestore(&il->sta_lock, flags_spin);\n\n\til_dump_lq_cmd(il, lq);\n\tBUG_ON(init && (cmd.flags & CMD_ASYNC));\n\n\tif (il_is_lq_table_valid(il, lq))\n\t\tret = il_send_cmd(il, &cmd);\n\telse\n\t\tret = -EINVAL;\n\n\tif (cmd.flags & CMD_ASYNC)\n\t\treturn ret;\n\n\tif (init) {\n\t\tD_INFO(\"init LQ command complete,\"\n\t\t       \" clearing sta addition status for sta %d\\n\",\n\t\t       lq->sta_id);\n\t\tspin_lock_irqsave(&il->sta_lock, flags_spin);\n\t\til->stations[lq->sta_id].used &= ~IL_STA_UCODE_INPROGRESS;\n\t\tspin_unlock_irqrestore(&il->sta_lock, flags_spin);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(il_send_lq_cmd);\n\nint\nil_mac_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t  struct ieee80211_sta *sta)\n{\n\tstruct il_priv *il = hw->priv;\n\tstruct il_station_priv_common *sta_common = (void *)sta->drv_priv;\n\tint ret;\n\n\tmutex_lock(&il->mutex);\n\tD_MAC80211(\"enter station %pM\\n\", sta->addr);\n\n\tret = il_remove_station(il, sta_common->sta_id, sta->addr);\n\tif (ret)\n\t\tIL_ERR(\"Error removing station %pM\\n\", sta->addr);\n\n\tD_MAC80211(\"leave ret %d\\n\", ret);\n\tmutex_unlock(&il->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(il_mac_sta_remove);\n\n \n \n\n \nint\nil_rx_queue_space(const struct il_rx_queue *q)\n{\n\tint s = q->read - q->write;\n\tif (s <= 0)\n\t\ts += RX_QUEUE_SIZE;\n\t \n\ts -= 2;\n\tif (s < 0)\n\t\ts = 0;\n\treturn s;\n}\nEXPORT_SYMBOL(il_rx_queue_space);\n\n \nvoid\nil_rx_queue_update_write_ptr(struct il_priv *il, struct il_rx_queue *q)\n{\n\tunsigned long flags;\n\tu32 rx_wrt_ptr_reg = il->hw_params.rx_wrt_ptr_reg;\n\tu32 reg;\n\n\tspin_lock_irqsave(&q->lock, flags);\n\n\tif (q->need_update == 0)\n\t\tgoto exit_unlock;\n\n\t \n\tif (test_bit(S_POWER_PMI, &il->status)) {\n\t\treg = _il_rd(il, CSR_UCODE_DRV_GP1);\n\n\t\tif (reg & CSR_UCODE_DRV_GP1_BIT_MAC_SLEEP) {\n\t\t\tD_INFO(\"Rx queue requesting wakeup,\" \" GP1 = 0x%x\\n\",\n\t\t\t       reg);\n\t\t\til_set_bit(il, CSR_GP_CNTRL,\n\t\t\t\t   CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);\n\t\t\tgoto exit_unlock;\n\t\t}\n\n\t\tq->write_actual = (q->write & ~0x7);\n\t\til_wr(il, rx_wrt_ptr_reg, q->write_actual);\n\n\t\t \n\t} else {\n\t\t \n\t\tq->write_actual = (q->write & ~0x7);\n\t\til_wr(il, rx_wrt_ptr_reg, q->write_actual);\n\t}\n\n\tq->need_update = 0;\n\nexit_unlock:\n\tspin_unlock_irqrestore(&q->lock, flags);\n}\nEXPORT_SYMBOL(il_rx_queue_update_write_ptr);\n\nint\nil_rx_queue_alloc(struct il_priv *il)\n{\n\tstruct il_rx_queue *rxq = &il->rxq;\n\tstruct device *dev = &il->pci_dev->dev;\n\tint i;\n\n\tspin_lock_init(&rxq->lock);\n\tINIT_LIST_HEAD(&rxq->rx_free);\n\tINIT_LIST_HEAD(&rxq->rx_used);\n\n\t \n\trxq->bd = dma_alloc_coherent(dev, 4 * RX_QUEUE_SIZE, &rxq->bd_dma,\n\t\t\t\t     GFP_KERNEL);\n\tif (!rxq->bd)\n\t\tgoto err_bd;\n\n\trxq->rb_stts = dma_alloc_coherent(dev, sizeof(struct il_rb_status),\n\t\t\t\t\t  &rxq->rb_stts_dma, GFP_KERNEL);\n\tif (!rxq->rb_stts)\n\t\tgoto err_rb;\n\n\t \n\tfor (i = 0; i < RX_FREE_BUFFERS + RX_QUEUE_SIZE; i++)\n\t\tlist_add_tail(&rxq->pool[i].list, &rxq->rx_used);\n\n\t \n\trxq->read = rxq->write = 0;\n\trxq->write_actual = 0;\n\trxq->free_count = 0;\n\trxq->need_update = 0;\n\treturn 0;\n\nerr_rb:\n\tdma_free_coherent(&il->pci_dev->dev, 4 * RX_QUEUE_SIZE, rxq->bd,\n\t\t\t  rxq->bd_dma);\nerr_bd:\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL(il_rx_queue_alloc);\n\nvoid\nil_hdl_spectrum_measurement(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tstruct il_spectrum_notification *report = &(pkt->u.spectrum_notif);\n\n\tif (!report->state) {\n\t\tD_11H(\"Spectrum Measure Notification: Start\\n\");\n\t\treturn;\n\t}\n\n\tmemcpy(&il->measure_report, report, sizeof(*report));\n\til->measurement_status |= MEASUREMENT_READY;\n}\nEXPORT_SYMBOL(il_hdl_spectrum_measurement);\n\n \nint\nil_set_decrypted_flag(struct il_priv *il, struct ieee80211_hdr *hdr,\n\t\t      u32 decrypt_res, struct ieee80211_rx_status *stats)\n{\n\tu16 fc = le16_to_cpu(hdr->frame_control);\n\n\t \n\tif (il->active.filter_flags & RXON_FILTER_DIS_DECRYPT_MSK)\n\t\treturn 0;\n\n\tif (!(fc & IEEE80211_FCTL_PROTECTED))\n\t\treturn 0;\n\n\tD_RX(\"decrypt_res:0x%x\\n\", decrypt_res);\n\tswitch (decrypt_res & RX_RES_STATUS_SEC_TYPE_MSK) {\n\tcase RX_RES_STATUS_SEC_TYPE_TKIP:\n\t\t \n\t\tif ((decrypt_res & RX_RES_STATUS_DECRYPT_TYPE_MSK) ==\n\t\t    RX_RES_STATUS_BAD_KEY_TTAK)\n\t\t\tbreak;\n\t\tfallthrough;\n\n\tcase RX_RES_STATUS_SEC_TYPE_WEP:\n\t\tif ((decrypt_res & RX_RES_STATUS_DECRYPT_TYPE_MSK) ==\n\t\t    RX_RES_STATUS_BAD_ICV_MIC) {\n\t\t\t \n\t\t\tD_RX(\"Packet destroyed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tfallthrough;\n\tcase RX_RES_STATUS_SEC_TYPE_CCMP:\n\t\tif ((decrypt_res & RX_RES_STATUS_DECRYPT_TYPE_MSK) ==\n\t\t    RX_RES_STATUS_DECRYPT_OK) {\n\t\t\tD_RX(\"hw decrypt successfully!!!\\n\");\n\t\t\tstats->flag |= RX_FLAG_DECRYPTED;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(il_set_decrypted_flag);\n\n \nvoid\nil_txq_update_write_ptr(struct il_priv *il, struct il_tx_queue *txq)\n{\n\tu32 reg = 0;\n\tint txq_id = txq->q.id;\n\n\tif (txq->need_update == 0)\n\t\treturn;\n\n\t \n\tif (test_bit(S_POWER_PMI, &il->status)) {\n\t\t \n\t\treg = _il_rd(il, CSR_UCODE_DRV_GP1);\n\n\t\tif (reg & CSR_UCODE_DRV_GP1_BIT_MAC_SLEEP) {\n\t\t\tD_INFO(\"Tx queue %d requesting wakeup,\" \" GP1 = 0x%x\\n\",\n\t\t\t       txq_id, reg);\n\t\t\til_set_bit(il, CSR_GP_CNTRL,\n\t\t\t\t   CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);\n\t\t\treturn;\n\t\t}\n\n\t\til_wr(il, HBUS_TARG_WRPTR, txq->q.write_ptr | (txq_id << 8));\n\n\t\t \n\t} else\n\t\t_il_wr(il, HBUS_TARG_WRPTR, txq->q.write_ptr | (txq_id << 8));\n\ttxq->need_update = 0;\n}\nEXPORT_SYMBOL(il_txq_update_write_ptr);\n\n \nvoid\nil_tx_queue_unmap(struct il_priv *il, int txq_id)\n{\n\tstruct il_tx_queue *txq = &il->txq[txq_id];\n\tstruct il_queue *q = &txq->q;\n\n\tif (q->n_bd == 0)\n\t\treturn;\n\n\twhile (q->write_ptr != q->read_ptr) {\n\t\til->ops->txq_free_tfd(il, txq);\n\t\tq->read_ptr = il_queue_inc_wrap(q->read_ptr, q->n_bd);\n\t}\n}\nEXPORT_SYMBOL(il_tx_queue_unmap);\n\n \nvoid\nil_tx_queue_free(struct il_priv *il, int txq_id)\n{\n\tstruct il_tx_queue *txq = &il->txq[txq_id];\n\tstruct device *dev = &il->pci_dev->dev;\n\tint i;\n\n\til_tx_queue_unmap(il, txq_id);\n\n\t \n\tif (txq->cmd) {\n\t\tfor (i = 0; i < TFD_TX_CMD_SLOTS; i++)\n\t\t\tkfree(txq->cmd[i]);\n\t}\n\n\t \n\tif (txq->q.n_bd)\n\t\tdma_free_coherent(dev, il->hw_params.tfd_size * txq->q.n_bd,\n\t\t\t\t  txq->tfds, txq->q.dma_addr);\n\n\t \n\tkfree(txq->skbs);\n\ttxq->skbs = NULL;\n\n\t \n\tkfree(txq->cmd);\n\tkfree(txq->meta);\n\ttxq->cmd = NULL;\n\ttxq->meta = NULL;\n\n\t \n\tmemset(txq, 0, sizeof(*txq));\n}\nEXPORT_SYMBOL(il_tx_queue_free);\n\n \nvoid\nil_cmd_queue_unmap(struct il_priv *il)\n{\n\tstruct il_tx_queue *txq = &il->txq[il->cmd_queue];\n\tstruct il_queue *q = &txq->q;\n\tint i;\n\n\tif (q->n_bd == 0)\n\t\treturn;\n\n\twhile (q->read_ptr != q->write_ptr) {\n\t\ti = il_get_cmd_idx(q, q->read_ptr, 0);\n\n\t\tif (txq->meta[i].flags & CMD_MAPPED) {\n\t\t\tdma_unmap_single(&il->pci_dev->dev,\n\t\t\t\t\t dma_unmap_addr(&txq->meta[i], mapping),\n\t\t\t\t\t dma_unmap_len(&txq->meta[i], len),\n\t\t\t\t\t DMA_BIDIRECTIONAL);\n\t\t\ttxq->meta[i].flags = 0;\n\t\t}\n\n\t\tq->read_ptr = il_queue_inc_wrap(q->read_ptr, q->n_bd);\n\t}\n\n\ti = q->n_win;\n\tif (txq->meta[i].flags & CMD_MAPPED) {\n\t\tdma_unmap_single(&il->pci_dev->dev,\n\t\t\t\t dma_unmap_addr(&txq->meta[i], mapping),\n\t\t\t\t dma_unmap_len(&txq->meta[i], len),\n\t\t\t\t DMA_BIDIRECTIONAL);\n\t\ttxq->meta[i].flags = 0;\n\t}\n}\nEXPORT_SYMBOL(il_cmd_queue_unmap);\n\n \nvoid\nil_cmd_queue_free(struct il_priv *il)\n{\n\tstruct il_tx_queue *txq = &il->txq[il->cmd_queue];\n\tstruct device *dev = &il->pci_dev->dev;\n\tint i;\n\n\til_cmd_queue_unmap(il);\n\n\t \n\tif (txq->cmd) {\n\t\tfor (i = 0; i <= TFD_CMD_SLOTS; i++)\n\t\t\tkfree(txq->cmd[i]);\n\t}\n\n\t \n\tif (txq->q.n_bd)\n\t\tdma_free_coherent(dev, il->hw_params.tfd_size * txq->q.n_bd,\n\t\t\t\t  txq->tfds, txq->q.dma_addr);\n\n\t \n\tkfree(txq->cmd);\n\tkfree(txq->meta);\n\ttxq->cmd = NULL;\n\ttxq->meta = NULL;\n\n\t \n\tmemset(txq, 0, sizeof(*txq));\n}\nEXPORT_SYMBOL(il_cmd_queue_free);\n\n \n\nint\nil_queue_space(const struct il_queue *q)\n{\n\tint s = q->read_ptr - q->write_ptr;\n\n\tif (q->read_ptr > q->write_ptr)\n\t\ts -= q->n_bd;\n\n\tif (s <= 0)\n\t\ts += q->n_win;\n\t \n\ts -= 2;\n\tif (s < 0)\n\t\ts = 0;\n\treturn s;\n}\nEXPORT_SYMBOL(il_queue_space);\n\n\n \nstatic int\nil_queue_init(struct il_priv *il, struct il_queue *q, int slots, u32 id)\n{\n\t \n\tBUILD_BUG_ON(TFD_QUEUE_SIZE_MAX & (TFD_QUEUE_SIZE_MAX - 1));\n\t \n\tq->n_bd = TFD_QUEUE_SIZE_MAX;\n\n\tq->n_win = slots;\n\tq->id = id;\n\n\t \n\tBUG_ON(!is_power_of_2(slots));\n\n\tq->low_mark = q->n_win / 4;\n\tif (q->low_mark < 4)\n\t\tq->low_mark = 4;\n\n\tq->high_mark = q->n_win / 8;\n\tif (q->high_mark < 2)\n\t\tq->high_mark = 2;\n\n\tq->write_ptr = q->read_ptr = 0;\n\n\treturn 0;\n}\n\n \nstatic int\nil_tx_queue_alloc(struct il_priv *il, struct il_tx_queue *txq, u32 id)\n{\n\tstruct device *dev = &il->pci_dev->dev;\n\tsize_t tfd_sz = il->hw_params.tfd_size * TFD_QUEUE_SIZE_MAX;\n\n\t \n\tif (id != il->cmd_queue) {\n\t\ttxq->skbs = kcalloc(TFD_QUEUE_SIZE_MAX,\n\t\t\t\t    sizeof(struct sk_buff *),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (!txq->skbs) {\n\t\t\tIL_ERR(\"Fail to alloc skbs\\n\");\n\t\t\tgoto error;\n\t\t}\n\t} else\n\t\ttxq->skbs = NULL;\n\n\t \n\ttxq->tfds =\n\t    dma_alloc_coherent(dev, tfd_sz, &txq->q.dma_addr, GFP_KERNEL);\n\tif (!txq->tfds)\n\t\tgoto error;\n\n\ttxq->q.id = id;\n\n\treturn 0;\n\nerror:\n\tkfree(txq->skbs);\n\ttxq->skbs = NULL;\n\n\treturn -ENOMEM;\n}\n\n \nint\nil_tx_queue_init(struct il_priv *il, u32 txq_id)\n{\n\tint i, len, ret;\n\tint slots, actual_slots;\n\tstruct il_tx_queue *txq = &il->txq[txq_id];\n\n\t \n\tif (txq_id == il->cmd_queue) {\n\t\tslots = TFD_CMD_SLOTS;\n\t\tactual_slots = slots + 1;\n\t} else {\n\t\tslots = TFD_TX_CMD_SLOTS;\n\t\tactual_slots = slots;\n\t}\n\n\ttxq->meta =\n\t    kcalloc(actual_slots, sizeof(struct il_cmd_meta), GFP_KERNEL);\n\ttxq->cmd =\n\t    kcalloc(actual_slots, sizeof(struct il_device_cmd *), GFP_KERNEL);\n\n\tif (!txq->meta || !txq->cmd)\n\t\tgoto out_free_arrays;\n\n\tlen = sizeof(struct il_device_cmd);\n\tfor (i = 0; i < actual_slots; i++) {\n\t\t \n\t\tif (i == slots)\n\t\t\tlen = IL_MAX_CMD_SIZE;\n\n\t\ttxq->cmd[i] = kmalloc(len, GFP_KERNEL);\n\t\tif (!txq->cmd[i])\n\t\t\tgoto err;\n\t}\n\n\t \n\tret = il_tx_queue_alloc(il, txq, txq_id);\n\tif (ret)\n\t\tgoto err;\n\n\ttxq->need_update = 0;\n\n\t \n\tif (txq_id < 4)\n\t\til_set_swq_id(txq, txq_id, txq_id);\n\n\t \n\til_queue_init(il, &txq->q, slots, txq_id);\n\n\t \n\til->ops->txq_init(il, txq);\n\n\treturn 0;\nerr:\n\tfor (i = 0; i < actual_slots; i++)\n\t\tkfree(txq->cmd[i]);\nout_free_arrays:\n\tkfree(txq->meta);\n\ttxq->meta = NULL;\n\tkfree(txq->cmd);\n\ttxq->cmd = NULL;\n\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL(il_tx_queue_init);\n\nvoid\nil_tx_queue_reset(struct il_priv *il, u32 txq_id)\n{\n\tint slots, actual_slots;\n\tstruct il_tx_queue *txq = &il->txq[txq_id];\n\n\tif (txq_id == il->cmd_queue) {\n\t\tslots = TFD_CMD_SLOTS;\n\t\tactual_slots = TFD_CMD_SLOTS + 1;\n\t} else {\n\t\tslots = TFD_TX_CMD_SLOTS;\n\t\tactual_slots = TFD_TX_CMD_SLOTS;\n\t}\n\n\tmemset(txq->meta, 0, sizeof(struct il_cmd_meta) * actual_slots);\n\ttxq->need_update = 0;\n\n\t \n\til_queue_init(il, &txq->q, slots, txq_id);\n\n\t \n\til->ops->txq_init(il, txq);\n}\nEXPORT_SYMBOL(il_tx_queue_reset);\n\n \n\n \nint\nil_enqueue_hcmd(struct il_priv *il, struct il_host_cmd *cmd)\n{\n\tstruct il_tx_queue *txq = &il->txq[il->cmd_queue];\n\tstruct il_queue *q = &txq->q;\n\tstruct il_device_cmd *out_cmd;\n\tstruct il_cmd_meta *out_meta;\n\tdma_addr_t phys_addr;\n\tunsigned long flags;\n\tu32 idx;\n\tu16 fix_size;\n\n\tcmd->len = il->ops->get_hcmd_size(cmd->id, cmd->len);\n\tfix_size = (u16) (cmd->len + sizeof(out_cmd->hdr));\n\n\t \n\tBUG_ON((fix_size > TFD_MAX_PAYLOAD_SIZE) &&\n\t       !(cmd->flags & CMD_SIZE_HUGE));\n\tBUG_ON(fix_size > IL_MAX_CMD_SIZE);\n\n\tif (il_is_rfkill(il) || il_is_ctkill(il)) {\n\t\tIL_WARN(\"Not sending command - %s KILL\\n\",\n\t\t\til_is_rfkill(il) ? \"RF\" : \"CT\");\n\t\treturn -EIO;\n\t}\n\n\tspin_lock_irqsave(&il->hcmd_lock, flags);\n\n\tif (il_queue_space(q) < ((cmd->flags & CMD_ASYNC) ? 2 : 1)) {\n\t\tspin_unlock_irqrestore(&il->hcmd_lock, flags);\n\n\t\tIL_ERR(\"Restarting adapter due to command queue full\\n\");\n\t\tqueue_work(il->workqueue, &il->restart);\n\t\treturn -ENOSPC;\n\t}\n\n\tidx = il_get_cmd_idx(q, q->write_ptr, cmd->flags & CMD_SIZE_HUGE);\n\tout_cmd = txq->cmd[idx];\n\tout_meta = &txq->meta[idx];\n\n\tif (WARN_ON(out_meta->flags & CMD_MAPPED)) {\n\t\tspin_unlock_irqrestore(&il->hcmd_lock, flags);\n\t\treturn -ENOSPC;\n\t}\n\n\tmemset(out_meta, 0, sizeof(*out_meta));\t \n\tout_meta->flags = cmd->flags | CMD_MAPPED;\n\tif (cmd->flags & CMD_WANT_SKB)\n\t\tout_meta->source = cmd;\n\tif (cmd->flags & CMD_ASYNC)\n\t\tout_meta->callback = cmd->callback;\n\n\tout_cmd->hdr.cmd = cmd->id;\n\tmemcpy(&out_cmd->cmd.payload, cmd->data, cmd->len);\n\n\t \n\n\tout_cmd->hdr.flags = 0;\n\tout_cmd->hdr.sequence =\n\t    cpu_to_le16(QUEUE_TO_SEQ(il->cmd_queue) | IDX_TO_SEQ(q->write_ptr));\n\tif (cmd->flags & CMD_SIZE_HUGE)\n\t\tout_cmd->hdr.sequence |= SEQ_HUGE_FRAME;\n\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tswitch (out_cmd->hdr.cmd) {\n\tcase C_TX_LINK_QUALITY_CMD:\n\tcase C_SENSITIVITY:\n\t\tD_HC_DUMP(\"Sending command %s (#%x), seq: 0x%04X, \"\n\t\t\t  \"%d bytes at %d[%d]:%d\\n\",\n\t\t\t  il_get_cmd_string(out_cmd->hdr.cmd), out_cmd->hdr.cmd,\n\t\t\t  le16_to_cpu(out_cmd->hdr.sequence), fix_size,\n\t\t\t  q->write_ptr, idx, il->cmd_queue);\n\t\tbreak;\n\tdefault:\n\t\tD_HC(\"Sending command %s (#%x), seq: 0x%04X, \"\n\t\t     \"%d bytes at %d[%d]:%d\\n\",\n\t\t     il_get_cmd_string(out_cmd->hdr.cmd), out_cmd->hdr.cmd,\n\t\t     le16_to_cpu(out_cmd->hdr.sequence), fix_size, q->write_ptr,\n\t\t     idx, il->cmd_queue);\n\t}\n#endif\n\n\tphys_addr = dma_map_single(&il->pci_dev->dev, &out_cmd->hdr, fix_size,\n\t\t\t\t   DMA_BIDIRECTIONAL);\n\tif (unlikely(dma_mapping_error(&il->pci_dev->dev, phys_addr))) {\n\t\tidx = -ENOMEM;\n\t\tgoto out;\n\t}\n\tdma_unmap_addr_set(out_meta, mapping, phys_addr);\n\tdma_unmap_len_set(out_meta, len, fix_size);\n\n\ttxq->need_update = 1;\n\n\tif (il->ops->txq_update_byte_cnt_tbl)\n\t\t \n\t\til->ops->txq_update_byte_cnt_tbl(il, txq, 0);\n\n\til->ops->txq_attach_buf_to_tfd(il, txq, phys_addr, fix_size, 1,\n\t\t\t\t\t    U32_PAD(cmd->len));\n\n\t \n\tq->write_ptr = il_queue_inc_wrap(q->write_ptr, q->n_bd);\n\til_txq_update_write_ptr(il, txq);\n\nout:\n\tspin_unlock_irqrestore(&il->hcmd_lock, flags);\n\treturn idx;\n}\n\n \nstatic void\nil_hcmd_queue_reclaim(struct il_priv *il, int txq_id, int idx, int cmd_idx)\n{\n\tstruct il_tx_queue *txq = &il->txq[txq_id];\n\tstruct il_queue *q = &txq->q;\n\tint nfreed = 0;\n\n\tif (idx >= q->n_bd || il_queue_used(q, idx) == 0) {\n\t\tIL_ERR(\"Read idx for DMA queue txq id (%d), idx %d, \"\n\t\t       \"is out of range [0-%d] %d %d.\\n\", txq_id, idx, q->n_bd,\n\t\t       q->write_ptr, q->read_ptr);\n\t\treturn;\n\t}\n\n\tfor (idx = il_queue_inc_wrap(idx, q->n_bd); q->read_ptr != idx;\n\t     q->read_ptr = il_queue_inc_wrap(q->read_ptr, q->n_bd)) {\n\n\t\tif (nfreed++ > 0) {\n\t\t\tIL_ERR(\"HCMD skipped: idx (%d) %d %d\\n\", idx,\n\t\t\t       q->write_ptr, q->read_ptr);\n\t\t\tqueue_work(il->workqueue, &il->restart);\n\t\t}\n\n\t}\n}\n\n \nvoid\nil_tx_cmd_complete(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tu16 sequence = le16_to_cpu(pkt->hdr.sequence);\n\tint txq_id = SEQ_TO_QUEUE(sequence);\n\tint idx = SEQ_TO_IDX(sequence);\n\tint cmd_idx;\n\tbool huge = !!(pkt->hdr.sequence & SEQ_HUGE_FRAME);\n\tstruct il_device_cmd *cmd;\n\tstruct il_cmd_meta *meta;\n\tstruct il_tx_queue *txq = &il->txq[il->cmd_queue];\n\tunsigned long flags;\n\n\t \n\tif (WARN\n\t    (txq_id != il->cmd_queue,\n\t     \"wrong command queue %d (should be %d), sequence 0x%X readp=%d writep=%d\\n\",\n\t     txq_id, il->cmd_queue, sequence, il->txq[il->cmd_queue].q.read_ptr,\n\t     il->txq[il->cmd_queue].q.write_ptr)) {\n\t\til_print_hex_error(il, pkt, 32);\n\t\treturn;\n\t}\n\n\tcmd_idx = il_get_cmd_idx(&txq->q, idx, huge);\n\tcmd = txq->cmd[cmd_idx];\n\tmeta = &txq->meta[cmd_idx];\n\n\ttxq->time_stamp = jiffies;\n\n\tdma_unmap_single(&il->pci_dev->dev, dma_unmap_addr(meta, mapping),\n\t\t\t dma_unmap_len(meta, len), DMA_BIDIRECTIONAL);\n\n\t \n\tif (meta->flags & CMD_WANT_SKB) {\n\t\tmeta->source->reply_page = (unsigned long)rxb_addr(rxb);\n\t\trxb->page = NULL;\n\t} else if (meta->callback)\n\t\tmeta->callback(il, cmd, pkt);\n\n\tspin_lock_irqsave(&il->hcmd_lock, flags);\n\n\til_hcmd_queue_reclaim(il, txq_id, idx, cmd_idx);\n\n\tif (!(meta->flags & CMD_ASYNC)) {\n\t\tclear_bit(S_HCMD_ACTIVE, &il->status);\n\t\tD_INFO(\"Clearing HCMD_ACTIVE for command %s\\n\",\n\t\t       il_get_cmd_string(cmd->hdr.cmd));\n\t\twake_up(&il->wait_command_queue);\n\t}\n\n\t \n\tmeta->flags = 0;\n\n\tspin_unlock_irqrestore(&il->hcmd_lock, flags);\n}\nEXPORT_SYMBOL(il_tx_cmd_complete);\n\nMODULE_DESCRIPTION(\"iwl-legacy: common functions for 3945 and 4965\");\nMODULE_VERSION(IWLWIFI_VERSION);\nMODULE_AUTHOR(DRV_COPYRIGHT \" \" DRV_AUTHOR);\nMODULE_LICENSE(\"GPL\");\n\n \nstatic bool bt_coex_active = true;\nmodule_param(bt_coex_active, bool, 0444);\nMODULE_PARM_DESC(bt_coex_active, \"enable wifi/bluetooth co-exist\");\n\nu32 il_debug_level;\nEXPORT_SYMBOL(il_debug_level);\n\nconst u8 il_bcast_addr[ETH_ALEN] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };\nEXPORT_SYMBOL(il_bcast_addr);\n\n#define MAX_BIT_RATE_40_MHZ 150\t \n#define MAX_BIT_RATE_20_MHZ 72\t \nstatic void\nil_init_ht_hw_capab(const struct il_priv *il,\n\t\t    struct ieee80211_sta_ht_cap *ht_info,\n\t\t    enum nl80211_band band)\n{\n\tu16 max_bit_rate = 0;\n\tu8 rx_chains_num = il->hw_params.rx_chains_num;\n\tu8 tx_chains_num = il->hw_params.tx_chains_num;\n\n\tht_info->cap = 0;\n\tmemset(&ht_info->mcs, 0, sizeof(ht_info->mcs));\n\n\tht_info->ht_supported = true;\n\n\tht_info->cap |= IEEE80211_HT_CAP_SGI_20;\n\tmax_bit_rate = MAX_BIT_RATE_20_MHZ;\n\tif (il->hw_params.ht40_channel & BIT(band)) {\n\t\tht_info->cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t\tht_info->cap |= IEEE80211_HT_CAP_SGI_40;\n\t\tht_info->mcs.rx_mask[4] = 0x01;\n\t\tmax_bit_rate = MAX_BIT_RATE_40_MHZ;\n\t}\n\n\tif (il->cfg->mod_params->amsdu_size_8K)\n\t\tht_info->cap |= IEEE80211_HT_CAP_MAX_AMSDU;\n\n\tht_info->ampdu_factor = CFG_HT_RX_AMPDU_FACTOR_DEF;\n\tht_info->ampdu_density = CFG_HT_MPDU_DENSITY_DEF;\n\n\tht_info->mcs.rx_mask[0] = 0xFF;\n\tif (rx_chains_num >= 2)\n\t\tht_info->mcs.rx_mask[1] = 0xFF;\n\tif (rx_chains_num >= 3)\n\t\tht_info->mcs.rx_mask[2] = 0xFF;\n\n\t \n\tmax_bit_rate *= rx_chains_num;\n\tWARN_ON(max_bit_rate & ~IEEE80211_HT_MCS_RX_HIGHEST_MASK);\n\tht_info->mcs.rx_highest = cpu_to_le16(max_bit_rate);\n\n\t \n\tht_info->mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\n\tif (tx_chains_num != rx_chains_num) {\n\t\tht_info->mcs.tx_params |= IEEE80211_HT_MCS_TX_RX_DIFF;\n\t\tht_info->mcs.tx_params |=\n\t\t    ((tx_chains_num -\n\t\t      1) << IEEE80211_HT_MCS_TX_MAX_STREAMS_SHIFT);\n\t}\n}\n\n \nint\nil_init_geos(struct il_priv *il)\n{\n\tstruct il_channel_info *ch;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *channels;\n\tstruct ieee80211_channel *geo_ch;\n\tstruct ieee80211_rate *rates;\n\tint i = 0;\n\ts8 max_tx_power = 0;\n\n\tif (il->bands[NL80211_BAND_2GHZ].n_bitrates ||\n\t    il->bands[NL80211_BAND_5GHZ].n_bitrates) {\n\t\tD_INFO(\"Geography modes already initialized.\\n\");\n\t\tset_bit(S_GEO_CONFIGURED, &il->status);\n\t\treturn 0;\n\t}\n\n\tchannels =\n\t    kcalloc(il->channel_count, sizeof(struct ieee80211_channel),\n\t\t    GFP_KERNEL);\n\tif (!channels)\n\t\treturn -ENOMEM;\n\n\trates =\n\t    kzalloc((sizeof(struct ieee80211_rate) * RATE_COUNT_LEGACY),\n\t\t    GFP_KERNEL);\n\tif (!rates) {\n\t\tkfree(channels);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tsband = &il->bands[NL80211_BAND_5GHZ];\n\tsband->channels = &channels[ARRAY_SIZE(il_eeprom_band_1)];\n\t \n\tsband->bitrates = &rates[IL_FIRST_OFDM_RATE];\n\tsband->n_bitrates = RATE_COUNT_LEGACY - IL_FIRST_OFDM_RATE;\n\n\tif (il->cfg->sku & IL_SKU_N)\n\t\til_init_ht_hw_capab(il, &sband->ht_cap, NL80211_BAND_5GHZ);\n\n\tsband = &il->bands[NL80211_BAND_2GHZ];\n\tsband->channels = channels;\n\t \n\tsband->bitrates = rates;\n\tsband->n_bitrates = RATE_COUNT_LEGACY;\n\n\tif (il->cfg->sku & IL_SKU_N)\n\t\til_init_ht_hw_capab(il, &sband->ht_cap, NL80211_BAND_2GHZ);\n\n\til->ieee_channels = channels;\n\til->ieee_rates = rates;\n\n\tfor (i = 0; i < il->channel_count; i++) {\n\t\tch = &il->channel_info[i];\n\n\t\tif (!il_is_channel_valid(ch))\n\t\t\tcontinue;\n\n\t\tsband = &il->bands[ch->band];\n\n\t\tgeo_ch = &sband->channels[sband->n_channels++];\n\n\t\tgeo_ch->center_freq =\n\t\t    ieee80211_channel_to_frequency(ch->channel, ch->band);\n\t\tgeo_ch->max_power = ch->max_power_avg;\n\t\tgeo_ch->max_antenna_gain = 0xff;\n\t\tgeo_ch->hw_value = ch->channel;\n\n\t\tif (il_is_channel_valid(ch)) {\n\t\t\tif (!(ch->flags & EEPROM_CHANNEL_IBSS))\n\t\t\t\tgeo_ch->flags |= IEEE80211_CHAN_NO_IR;\n\n\t\t\tif (!(ch->flags & EEPROM_CHANNEL_ACTIVE))\n\t\t\t\tgeo_ch->flags |= IEEE80211_CHAN_NO_IR;\n\n\t\t\tif (ch->flags & EEPROM_CHANNEL_RADAR)\n\t\t\t\tgeo_ch->flags |= IEEE80211_CHAN_RADAR;\n\n\t\t\tgeo_ch->flags |= ch->ht40_extension_channel;\n\n\t\t\tif (ch->max_power_avg > max_tx_power)\n\t\t\t\tmax_tx_power = ch->max_power_avg;\n\t\t} else {\n\t\t\tgeo_ch->flags |= IEEE80211_CHAN_DISABLED;\n\t\t}\n\n\t\tD_INFO(\"Channel %d Freq=%d[%sGHz] %s flag=0x%X\\n\", ch->channel,\n\t\t       geo_ch->center_freq,\n\t\t       il_is_channel_a_band(ch) ? \"5.2\" : \"2.4\",\n\t\t       geo_ch->\n\t\t       flags & IEEE80211_CHAN_DISABLED ? \"restricted\" : \"valid\",\n\t\t       geo_ch->flags);\n\t}\n\n\til->tx_power_device_lmt = max_tx_power;\n\til->tx_power_user_lmt = max_tx_power;\n\til->tx_power_next = max_tx_power;\n\n\tif (il->bands[NL80211_BAND_5GHZ].n_channels == 0 &&\n\t    (il->cfg->sku & IL_SKU_A)) {\n\t\tIL_INFO(\"Incorrectly detected BG card as ABG. \"\n\t\t\t\"Please send your PCI ID 0x%04X:0x%04X to maintainer.\\n\",\n\t\t\til->pci_dev->device, il->pci_dev->subsystem_device);\n\t\til->cfg->sku &= ~IL_SKU_A;\n\t}\n\n\tIL_INFO(\"Tunable channels: %d 802.11bg, %d 802.11a channels\\n\",\n\t\til->bands[NL80211_BAND_2GHZ].n_channels,\n\t\til->bands[NL80211_BAND_5GHZ].n_channels);\n\n\tset_bit(S_GEO_CONFIGURED, &il->status);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(il_init_geos);\n\n \nvoid\nil_free_geos(struct il_priv *il)\n{\n\tkfree(il->ieee_channels);\n\tkfree(il->ieee_rates);\n\tclear_bit(S_GEO_CONFIGURED, &il->status);\n}\nEXPORT_SYMBOL(il_free_geos);\n\nstatic bool\nil_is_channel_extension(struct il_priv *il, enum nl80211_band band,\n\t\t\tu16 channel, u8 extension_chan_offset)\n{\n\tconst struct il_channel_info *ch_info;\n\n\tch_info = il_get_channel_info(il, band, channel);\n\tif (!il_is_channel_valid(ch_info))\n\t\treturn false;\n\n\tif (extension_chan_offset == IEEE80211_HT_PARAM_CHA_SEC_ABOVE)\n\t\treturn !(ch_info->\n\t\t\t ht40_extension_channel & IEEE80211_CHAN_NO_HT40PLUS);\n\telse if (extension_chan_offset == IEEE80211_HT_PARAM_CHA_SEC_BELOW)\n\t\treturn !(ch_info->\n\t\t\t ht40_extension_channel & IEEE80211_CHAN_NO_HT40MINUS);\n\n\treturn false;\n}\n\nbool\nil_is_ht40_tx_allowed(struct il_priv *il, struct ieee80211_sta_ht_cap *ht_cap)\n{\n\tif (!il->ht.enabled || !il->ht.is_40mhz)\n\t\treturn false;\n\n\t \n\tif (ht_cap && !ht_cap->ht_supported)\n\t\treturn false;\n\n#ifdef CONFIG_IWLEGACY_DEBUGFS\n\tif (il->disable_ht40)\n\t\treturn false;\n#endif\n\n\treturn il_is_channel_extension(il, il->band,\n\t\t\t\t       le16_to_cpu(il->staging.channel),\n\t\t\t\t       il->ht.extension_chan_offset);\n}\nEXPORT_SYMBOL(il_is_ht40_tx_allowed);\n\nstatic u16 noinline\nil_adjust_beacon_interval(u16 beacon_val, u16 max_beacon_val)\n{\n\tu16 new_val;\n\tu16 beacon_factor;\n\n\t \n\tif (!beacon_val)\n\t\treturn DEFAULT_BEACON_INTERVAL;\n\n\t \n\n\tbeacon_factor = (beacon_val + max_beacon_val) / max_beacon_val;\n\tnew_val = beacon_val / beacon_factor;\n\n\tif (!new_val)\n\t\tnew_val = max_beacon_val;\n\n\treturn new_val;\n}\n\nint\nil_send_rxon_timing(struct il_priv *il)\n{\n\tu64 tsf;\n\ts32 interval_tm, rem;\n\tstruct ieee80211_conf *conf = NULL;\n\tu16 beacon_int;\n\tstruct ieee80211_vif *vif = il->vif;\n\n\tconf = &il->hw->conf;\n\n\tlockdep_assert_held(&il->mutex);\n\n\tmemset(&il->timing, 0, sizeof(struct il_rxon_time_cmd));\n\n\til->timing.timestamp = cpu_to_le64(il->timestamp);\n\til->timing.listen_interval = cpu_to_le16(conf->listen_interval);\n\n\tbeacon_int = vif ? vif->bss_conf.beacon_int : 0;\n\n\t \n\til->timing.atim_win = 0;\n\n\tbeacon_int =\n\t    il_adjust_beacon_interval(beacon_int,\n\t\t\t\t      il->hw_params.max_beacon_itrvl *\n\t\t\t\t      TIME_UNIT);\n\til->timing.beacon_interval = cpu_to_le16(beacon_int);\n\n\ttsf = il->timestamp;\t \n\tinterval_tm = beacon_int * TIME_UNIT;\n\trem = do_div(tsf, interval_tm);\n\til->timing.beacon_init_val = cpu_to_le32(interval_tm - rem);\n\n\til->timing.dtim_period = vif ? (vif->bss_conf.dtim_period ? : 1) : 1;\n\n\tD_ASSOC(\"beacon interval %d beacon timer %d beacon tim %d\\n\",\n\t\tle16_to_cpu(il->timing.beacon_interval),\n\t\tle32_to_cpu(il->timing.beacon_init_val),\n\t\tle16_to_cpu(il->timing.atim_win));\n\n\treturn il_send_cmd_pdu(il, C_RXON_TIMING, sizeof(il->timing),\n\t\t\t       &il->timing);\n}\nEXPORT_SYMBOL(il_send_rxon_timing);\n\nvoid\nil_set_rxon_hwcrypto(struct il_priv *il, int hw_decrypt)\n{\n\tstruct il_rxon_cmd *rxon = &il->staging;\n\n\tif (hw_decrypt)\n\t\trxon->filter_flags &= ~RXON_FILTER_DIS_DECRYPT_MSK;\n\telse\n\t\trxon->filter_flags |= RXON_FILTER_DIS_DECRYPT_MSK;\n\n}\nEXPORT_SYMBOL(il_set_rxon_hwcrypto);\n\n \nint\nil_check_rxon_cmd(struct il_priv *il)\n{\n\tstruct il_rxon_cmd *rxon = &il->staging;\n\tbool error = false;\n\n\tif (rxon->flags & RXON_FLG_BAND_24G_MSK) {\n\t\tif (rxon->flags & RXON_FLG_TGJ_NARROW_BAND_MSK) {\n\t\t\tIL_WARN(\"check 2.4G: wrong narrow\\n\");\n\t\t\terror = true;\n\t\t}\n\t\tif (rxon->flags & RXON_FLG_RADAR_DETECT_MSK) {\n\t\t\tIL_WARN(\"check 2.4G: wrong radar\\n\");\n\t\t\terror = true;\n\t\t}\n\t} else {\n\t\tif (!(rxon->flags & RXON_FLG_SHORT_SLOT_MSK)) {\n\t\t\tIL_WARN(\"check 5.2G: not short slot!\\n\");\n\t\t\terror = true;\n\t\t}\n\t\tif (rxon->flags & RXON_FLG_CCK_MSK) {\n\t\t\tIL_WARN(\"check 5.2G: CCK!\\n\");\n\t\t\terror = true;\n\t\t}\n\t}\n\tif ((rxon->node_addr[0] | rxon->bssid_addr[0]) & 0x1) {\n\t\tIL_WARN(\"mac/bssid mcast!\\n\");\n\t\terror = true;\n\t}\n\n\t \n\tif ((rxon->ofdm_basic_rates & RATE_6M_MASK) == 0 &&\n\t    (rxon->cck_basic_rates & RATE_1M_MASK) == 0) {\n\t\tIL_WARN(\"neither 1 nor 6 are basic\\n\");\n\t\terror = true;\n\t}\n\n\tif (le16_to_cpu(rxon->assoc_id) > 2007) {\n\t\tIL_WARN(\"aid > 2007\\n\");\n\t\terror = true;\n\t}\n\n\tif ((rxon->flags & (RXON_FLG_CCK_MSK | RXON_FLG_SHORT_SLOT_MSK)) ==\n\t    (RXON_FLG_CCK_MSK | RXON_FLG_SHORT_SLOT_MSK)) {\n\t\tIL_WARN(\"CCK and short slot\\n\");\n\t\terror = true;\n\t}\n\n\tif ((rxon->flags & (RXON_FLG_CCK_MSK | RXON_FLG_AUTO_DETECT_MSK)) ==\n\t    (RXON_FLG_CCK_MSK | RXON_FLG_AUTO_DETECT_MSK)) {\n\t\tIL_WARN(\"CCK and auto detect\");\n\t\terror = true;\n\t}\n\n\tif ((rxon->\n\t     flags & (RXON_FLG_AUTO_DETECT_MSK | RXON_FLG_TGG_PROTECT_MSK)) ==\n\t    RXON_FLG_TGG_PROTECT_MSK) {\n\t\tIL_WARN(\"TGg but no auto-detect\\n\");\n\t\terror = true;\n\t}\n\n\tif (error)\n\t\tIL_WARN(\"Tuning to channel %d\\n\", le16_to_cpu(rxon->channel));\n\n\tif (error) {\n\t\tIL_ERR(\"Invalid RXON\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(il_check_rxon_cmd);\n\n \nint\nil_full_rxon_required(struct il_priv *il)\n{\n\tconst struct il_rxon_cmd *staging = &il->staging;\n\tconst struct il_rxon_cmd *active = &il->active;\n\n#define CHK(cond)\t\t\t\t\t\t\t\\\n\tif ((cond)) {\t\t\t\t\t\t\t\\\n\t\tD_INFO(\"need full RXON - \" #cond \"\\n\");\t\\\n\t\treturn 1;\t\t\t\t\t\t\\\n\t}\n\n#define CHK_NEQ(c1, c2)\t\t\t\t\t\t\\\n\tif ((c1) != (c2)) {\t\t\t\t\t\\\n\t\tD_INFO(\"need full RXON - \"\t\\\n\t\t\t       #c1 \" != \" #c2 \" - %d != %d\\n\",\t\\\n\t\t\t       (c1), (c2));\t\t\t\\\n\t\treturn 1;\t\t\t\t\t\\\n\t}\n\n\t \n\tCHK(!il_is_associated(il));\n\tCHK(!ether_addr_equal_64bits(staging->bssid_addr, active->bssid_addr));\n\tCHK(!ether_addr_equal_64bits(staging->node_addr, active->node_addr));\n\tCHK(!ether_addr_equal_64bits(staging->wlap_bssid_addr,\n\t\t\t\t     active->wlap_bssid_addr));\n\tCHK_NEQ(staging->dev_type, active->dev_type);\n\tCHK_NEQ(staging->channel, active->channel);\n\tCHK_NEQ(staging->air_propagation, active->air_propagation);\n\tCHK_NEQ(staging->ofdm_ht_single_stream_basic_rates,\n\t\tactive->ofdm_ht_single_stream_basic_rates);\n\tCHK_NEQ(staging->ofdm_ht_dual_stream_basic_rates,\n\t\tactive->ofdm_ht_dual_stream_basic_rates);\n\tCHK_NEQ(staging->assoc_id, active->assoc_id);\n\n\t \n\n\t \n\tCHK_NEQ(staging->flags & RXON_FLG_BAND_24G_MSK,\n\t\tactive->flags & RXON_FLG_BAND_24G_MSK);\n\n\t \n\tCHK_NEQ(staging->filter_flags & RXON_FILTER_ASSOC_MSK,\n\t\tactive->filter_flags & RXON_FILTER_ASSOC_MSK);\n\n#undef CHK\n#undef CHK_NEQ\n\n\treturn 0;\n}\nEXPORT_SYMBOL(il_full_rxon_required);\n\nu8\nil_get_lowest_plcp(struct il_priv *il)\n{\n\t \n\tif (il->staging.flags & RXON_FLG_BAND_24G_MSK)\n\t\treturn RATE_1M_PLCP;\n\telse\n\t\treturn RATE_6M_PLCP;\n}\nEXPORT_SYMBOL(il_get_lowest_plcp);\n\nstatic void\n_il_set_rxon_ht(struct il_priv *il, struct il_ht_config *ht_conf)\n{\n\tstruct il_rxon_cmd *rxon = &il->staging;\n\n\tif (!il->ht.enabled) {\n\t\trxon->flags &=\n\t\t    ~(RXON_FLG_CHANNEL_MODE_MSK |\n\t\t      RXON_FLG_CTRL_CHANNEL_LOC_HI_MSK | RXON_FLG_HT40_PROT_MSK\n\t\t      | RXON_FLG_HT_PROT_MSK);\n\t\treturn;\n\t}\n\n\trxon->flags |=\n\t    cpu_to_le32(il->ht.protection << RXON_FLG_HT_OPERATING_MODE_POS);\n\n\t \n\t \n\trxon->flags &=\n\t    ~(RXON_FLG_CHANNEL_MODE_MSK | RXON_FLG_CTRL_CHANNEL_LOC_HI_MSK);\n\tif (il_is_ht40_tx_allowed(il, NULL)) {\n\t\t \n\t\tif (il->ht.protection == IEEE80211_HT_OP_MODE_PROTECTION_20MHZ) {\n\t\t\trxon->flags |= RXON_FLG_CHANNEL_MODE_PURE_40;\n\t\t\t \n\t\t\tswitch (il->ht.extension_chan_offset) {\n\t\t\tcase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\n\t\t\t\trxon->flags &=\n\t\t\t\t    ~RXON_FLG_CTRL_CHANNEL_LOC_HI_MSK;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\n\t\t\t\trxon->flags |= RXON_FLG_CTRL_CHANNEL_LOC_HI_MSK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tswitch (il->ht.extension_chan_offset) {\n\t\t\tcase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\n\t\t\t\trxon->flags &=\n\t\t\t\t    ~(RXON_FLG_CTRL_CHANNEL_LOC_HI_MSK);\n\t\t\t\trxon->flags |= RXON_FLG_CHANNEL_MODE_MIXED;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\n\t\t\t\trxon->flags |= RXON_FLG_CTRL_CHANNEL_LOC_HI_MSK;\n\t\t\t\trxon->flags |= RXON_FLG_CHANNEL_MODE_MIXED;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_HT_PARAM_CHA_SEC_NONE:\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tIL_ERR(\"invalid extension channel offset\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trxon->flags |= RXON_FLG_CHANNEL_MODE_LEGACY;\n\t}\n\n\tif (il->ops->set_rxon_chain)\n\t\til->ops->set_rxon_chain(il);\n\n\tD_ASSOC(\"rxon flags 0x%X operation mode :0x%X \"\n\t\t\"extension channel offset 0x%x\\n\", le32_to_cpu(rxon->flags),\n\t\til->ht.protection, il->ht.extension_chan_offset);\n}\n\nvoid\nil_set_rxon_ht(struct il_priv *il, struct il_ht_config *ht_conf)\n{\n\t_il_set_rxon_ht(il, ht_conf);\n}\nEXPORT_SYMBOL(il_set_rxon_ht);\n\n \nu8\nil_get_single_channel_number(struct il_priv *il, enum nl80211_band band)\n{\n\tconst struct il_channel_info *ch_info;\n\tint i;\n\tu8 channel = 0;\n\tu8 min, max;\n\n\tif (band == NL80211_BAND_5GHZ) {\n\t\tmin = 14;\n\t\tmax = il->channel_count;\n\t} else {\n\t\tmin = 0;\n\t\tmax = 14;\n\t}\n\n\tfor (i = min; i < max; i++) {\n\t\tchannel = il->channel_info[i].channel;\n\t\tif (channel == le16_to_cpu(il->staging.channel))\n\t\t\tcontinue;\n\n\t\tch_info = il_get_channel_info(il, band, channel);\n\t\tif (il_is_channel_valid(ch_info))\n\t\t\tbreak;\n\t}\n\n\treturn channel;\n}\nEXPORT_SYMBOL(il_get_single_channel_number);\n\n \nint\nil_set_rxon_channel(struct il_priv *il, struct ieee80211_channel *ch)\n{\n\tenum nl80211_band band = ch->band;\n\tu16 channel = ch->hw_value;\n\n\tif (le16_to_cpu(il->staging.channel) == channel && il->band == band)\n\t\treturn 0;\n\n\til->staging.channel = cpu_to_le16(channel);\n\tif (band == NL80211_BAND_5GHZ)\n\t\til->staging.flags &= ~RXON_FLG_BAND_24G_MSK;\n\telse\n\t\til->staging.flags |= RXON_FLG_BAND_24G_MSK;\n\n\til->band = band;\n\n\tD_INFO(\"Staging channel set to %d [%d]\\n\", channel, band);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(il_set_rxon_channel);\n\nvoid\nil_set_flags_for_band(struct il_priv *il, enum nl80211_band band,\n\t\t      struct ieee80211_vif *vif)\n{\n\tif (band == NL80211_BAND_5GHZ) {\n\t\til->staging.flags &=\n\t\t    ~(RXON_FLG_BAND_24G_MSK | RXON_FLG_AUTO_DETECT_MSK |\n\t\t      RXON_FLG_CCK_MSK);\n\t\til->staging.flags |= RXON_FLG_SHORT_SLOT_MSK;\n\t} else {\n\t\t \n\t\tif (vif && vif->bss_conf.use_short_slot)\n\t\t\til->staging.flags |= RXON_FLG_SHORT_SLOT_MSK;\n\t\telse\n\t\t\til->staging.flags &= ~RXON_FLG_SHORT_SLOT_MSK;\n\n\t\til->staging.flags |= RXON_FLG_BAND_24G_MSK;\n\t\til->staging.flags |= RXON_FLG_AUTO_DETECT_MSK;\n\t\til->staging.flags &= ~RXON_FLG_CCK_MSK;\n\t}\n}\nEXPORT_SYMBOL(il_set_flags_for_band);\n\n \nvoid\nil_connection_init_rx_config(struct il_priv *il)\n{\n\tconst struct il_channel_info *ch_info;\n\n\tmemset(&il->staging, 0, sizeof(il->staging));\n\n\tswitch (il->iw_mode) {\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\t\til->staging.dev_type = RXON_DEV_TYPE_ESS;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\til->staging.dev_type = RXON_DEV_TYPE_ESS;\n\t\til->staging.filter_flags = RXON_FILTER_ACCEPT_GRP_MSK;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\til->staging.dev_type = RXON_DEV_TYPE_IBSS;\n\t\til->staging.flags = RXON_FLG_SHORT_PREAMBLE_MSK;\n\t\til->staging.filter_flags =\n\t\t    RXON_FILTER_BCON_AWARE_MSK | RXON_FILTER_ACCEPT_GRP_MSK;\n\t\tbreak;\n\tdefault:\n\t\tIL_ERR(\"Unsupported interface type %d\\n\", il->vif->type);\n\t\treturn;\n\t}\n\n#if 0\n\t \n\tif (!hw_to_local(il->hw)->short_preamble)\n\t\til->staging.flags &= ~RXON_FLG_SHORT_PREAMBLE_MSK;\n\telse\n\t\til->staging.flags |= RXON_FLG_SHORT_PREAMBLE_MSK;\n#endif\n\n\tch_info =\n\t    il_get_channel_info(il, il->band, le16_to_cpu(il->active.channel));\n\n\tif (!ch_info)\n\t\tch_info = &il->channel_info[0];\n\n\til->staging.channel = cpu_to_le16(ch_info->channel);\n\til->band = ch_info->band;\n\n\til_set_flags_for_band(il, il->band, il->vif);\n\n\til->staging.ofdm_basic_rates =\n\t    (IL_OFDM_RATES_MASK >> IL_FIRST_OFDM_RATE) & 0xFF;\n\til->staging.cck_basic_rates =\n\t    (IL_CCK_RATES_MASK >> IL_FIRST_CCK_RATE) & 0xF;\n\n\t \n\til->staging.flags &=\n\t    ~(RXON_FLG_CHANNEL_MODE_MIXED | RXON_FLG_CHANNEL_MODE_PURE_40);\n\tif (il->vif)\n\t\tmemcpy(il->staging.node_addr, il->vif->addr, ETH_ALEN);\n\n\til->staging.ofdm_ht_single_stream_basic_rates = 0xff;\n\til->staging.ofdm_ht_dual_stream_basic_rates = 0xff;\n}\nEXPORT_SYMBOL(il_connection_init_rx_config);\n\nvoid\nil_set_rate(struct il_priv *il)\n{\n\tconst struct ieee80211_supported_band *hw = NULL;\n\tstruct ieee80211_rate *rate;\n\tint i;\n\n\thw = il_get_hw_mode(il, il->band);\n\tif (!hw) {\n\t\tIL_ERR(\"Failed to set rate: unable to get hw mode\\n\");\n\t\treturn;\n\t}\n\n\til->active_rate = 0;\n\n\tfor (i = 0; i < hw->n_bitrates; i++) {\n\t\trate = &(hw->bitrates[i]);\n\t\tif (rate->hw_value < RATE_COUNT_LEGACY)\n\t\t\til->active_rate |= (1 << rate->hw_value);\n\t}\n\n\tD_RATE(\"Set active_rate = %0x\\n\", il->active_rate);\n\n\til->staging.cck_basic_rates =\n\t    (IL_CCK_BASIC_RATES_MASK >> IL_FIRST_CCK_RATE) & 0xF;\n\n\til->staging.ofdm_basic_rates =\n\t    (IL_OFDM_BASIC_RATES_MASK >> IL_FIRST_OFDM_RATE) & 0xFF;\n}\nEXPORT_SYMBOL(il_set_rate);\n\nvoid\nil_chswitch_done(struct il_priv *il, bool is_success)\n{\n\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\treturn;\n\n\tif (test_and_clear_bit(S_CHANNEL_SWITCH_PENDING, &il->status))\n\t\tieee80211_chswitch_done(il->vif, is_success);\n}\nEXPORT_SYMBOL(il_chswitch_done);\n\nvoid\nil_hdl_csa(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tstruct il_csa_notification *csa = &(pkt->u.csa_notif);\n\tstruct il_rxon_cmd *rxon = (void *)&il->active;\n\n\tif (!test_bit(S_CHANNEL_SWITCH_PENDING, &il->status))\n\t\treturn;\n\n\tif (!le32_to_cpu(csa->status) && csa->channel == il->switch_channel) {\n\t\trxon->channel = csa->channel;\n\t\til->staging.channel = csa->channel;\n\t\tD_11H(\"CSA notif: channel %d\\n\", le16_to_cpu(csa->channel));\n\t\til_chswitch_done(il, true);\n\t} else {\n\t\tIL_ERR(\"CSA notif (fail) : channel %d\\n\",\n\t\t       le16_to_cpu(csa->channel));\n\t\til_chswitch_done(il, false);\n\t}\n}\nEXPORT_SYMBOL(il_hdl_csa);\n\n#ifdef CONFIG_IWLEGACY_DEBUG\nvoid\nil_print_rx_config_cmd(struct il_priv *il)\n{\n\tstruct il_rxon_cmd *rxon = &il->staging;\n\n\tD_RADIO(\"RX CONFIG:\\n\");\n\til_print_hex_dump(il, IL_DL_RADIO, (u8 *) rxon, sizeof(*rxon));\n\tD_RADIO(\"u16 channel: 0x%x\\n\", le16_to_cpu(rxon->channel));\n\tD_RADIO(\"u32 flags: 0x%08X\\n\", le32_to_cpu(rxon->flags));\n\tD_RADIO(\"u32 filter_flags: 0x%08x\\n\", le32_to_cpu(rxon->filter_flags));\n\tD_RADIO(\"u8 dev_type: 0x%x\\n\", rxon->dev_type);\n\tD_RADIO(\"u8 ofdm_basic_rates: 0x%02x\\n\", rxon->ofdm_basic_rates);\n\tD_RADIO(\"u8 cck_basic_rates: 0x%02x\\n\", rxon->cck_basic_rates);\n\tD_RADIO(\"u8[6] node_addr: %pM\\n\", rxon->node_addr);\n\tD_RADIO(\"u8[6] bssid_addr: %pM\\n\", rxon->bssid_addr);\n\tD_RADIO(\"u16 assoc_id: 0x%x\\n\", le16_to_cpu(rxon->assoc_id));\n}\nEXPORT_SYMBOL(il_print_rx_config_cmd);\n#endif\n \nvoid\nil_irq_handle_error(struct il_priv *il)\n{\n\t \n\tset_bit(S_FW_ERROR, &il->status);\n\n\t \n\tclear_bit(S_HCMD_ACTIVE, &il->status);\n\n\tIL_ERR(\"Loaded firmware version: %s\\n\", il->hw->wiphy->fw_version);\n\n\til->ops->dump_nic_error_log(il);\n\tif (il->ops->dump_fh)\n\t\til->ops->dump_fh(il, NULL, false);\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tif (il_get_debug_level(il) & IL_DL_FW_ERRORS)\n\t\til_print_rx_config_cmd(il);\n#endif\n\n\twake_up(&il->wait_command_queue);\n\n\t \n\tclear_bit(S_READY, &il->status);\n\n\tif (!test_bit(S_EXIT_PENDING, &il->status)) {\n\t\tIL_DBG(IL_DL_FW_ERRORS,\n\t\t       \"Restarting adapter due to uCode error.\\n\");\n\n\t\tif (il->cfg->mod_params->restart_fw)\n\t\t\tqueue_work(il->workqueue, &il->restart);\n\t}\n}\nEXPORT_SYMBOL(il_irq_handle_error);\n\nstatic int\n_il_apm_stop_master(struct il_priv *il)\n{\n\tint ret = 0;\n\n\t \n\t_il_set_bit(il, CSR_RESET, CSR_RESET_REG_FLAG_STOP_MASTER);\n\n\tret =\n\t    _il_poll_bit(il, CSR_RESET, CSR_RESET_REG_FLAG_MASTER_DISABLED,\n\t\t\t CSR_RESET_REG_FLAG_MASTER_DISABLED, 100);\n\tif (ret < 0)\n\t\tIL_WARN(\"Master Disable Timed Out, 100 usec\\n\");\n\n\tD_INFO(\"stop master\\n\");\n\n\treturn ret;\n}\n\nvoid\n_il_apm_stop(struct il_priv *il)\n{\n\tlockdep_assert_held(&il->reg_lock);\n\n\tD_INFO(\"Stop card, put in low power state\\n\");\n\n\t \n\t_il_apm_stop_master(il);\n\n\t \n\t_il_set_bit(il, CSR_RESET, CSR_RESET_REG_FLAG_SW_RESET);\n\n\tudelay(10);\n\n\t \n\t_il_clear_bit(il, CSR_GP_CNTRL, CSR_GP_CNTRL_REG_FLAG_INIT_DONE);\n}\nEXPORT_SYMBOL(_il_apm_stop);\n\nvoid\nil_apm_stop(struct il_priv *il)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&il->reg_lock, flags);\n\t_il_apm_stop(il);\n\tspin_unlock_irqrestore(&il->reg_lock, flags);\n}\nEXPORT_SYMBOL(il_apm_stop);\n\n \nint\nil_apm_init(struct il_priv *il)\n{\n\tint ret = 0;\n\tu16 lctl;\n\n\tD_INFO(\"Init card's basic functions\\n\");\n\n\t \n\n\t \n\til_set_bit(il, CSR_GIO_CHICKEN_BITS,\n\t\t   CSR_GIO_CHICKEN_BITS_REG_BIT_DIS_L0S_EXIT_TIMER);\n\n\t \n\til_set_bit(il, CSR_GIO_CHICKEN_BITS,\n\t\t   CSR_GIO_CHICKEN_BITS_REG_BIT_L1A_NO_L0S_RX);\n\n\t \n\til_set_bit(il, CSR_DBG_HPET_MEM_REG, CSR_DBG_HPET_MEM_REG_VAL);\n\n\t \n\til_set_bit(il, CSR_HW_IF_CONFIG_REG,\n\t\t   CSR_HW_IF_CONFIG_REG_BIT_HAP_WAKE_L1A);\n\n\t \n\tif (il->cfg->set_l0s) {\n\t\tret = pcie_capability_read_word(il->pci_dev, PCI_EXP_LNKCTL, &lctl);\n\t\tif (!ret && (lctl & PCI_EXP_LNKCTL_ASPM_L1)) {\n\t\t\t \n\t\t\til_set_bit(il, CSR_GIO_REG,\n\t\t\t\t   CSR_GIO_REG_VAL_L0S_ENABLED);\n\t\t\tD_POWER(\"L1 Enabled; Disabling L0S\\n\");\n\t\t} else {\n\t\t\t \n\t\t\til_clear_bit(il, CSR_GIO_REG,\n\t\t\t\t     CSR_GIO_REG_VAL_L0S_ENABLED);\n\t\t\tD_POWER(\"L1 Disabled; Enabling L0S\\n\");\n\t\t}\n\t}\n\n\t \n\tif (il->cfg->pll_cfg_val)\n\t\til_set_bit(il, CSR_ANA_PLL_CFG,\n\t\t\t   il->cfg->pll_cfg_val);\n\n\t \n\til_set_bit(il, CSR_GP_CNTRL, CSR_GP_CNTRL_REG_FLAG_INIT_DONE);\n\n\t \n\tret =\n\t    _il_poll_bit(il, CSR_GP_CNTRL,\n\t\t\t CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY,\n\t\t\t CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY, 25000);\n\tif (ret < 0) {\n\t\tD_INFO(\"Failed to init the card\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (il->cfg->use_bsm)\n\t\til_wr_prph(il, APMG_CLK_EN_REG,\n\t\t\t   APMG_CLK_VAL_DMA_CLK_RQT | APMG_CLK_VAL_BSM_CLK_RQT);\n\telse\n\t\til_wr_prph(il, APMG_CLK_EN_REG, APMG_CLK_VAL_DMA_CLK_RQT);\n\tudelay(20);\n\n\t \n\til_set_bits_prph(il, APMG_PCIDEV_STT_REG,\n\t\t\t APMG_PCIDEV_STT_VAL_L1_ACT_DIS);\n\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL(il_apm_init);\n\nint\nil_set_tx_power(struct il_priv *il, s8 tx_power, bool force)\n{\n\tint ret;\n\ts8 prev_tx_power;\n\tbool defer;\n\n\tlockdep_assert_held(&il->mutex);\n\n\tif (il->tx_power_user_lmt == tx_power && !force)\n\t\treturn 0;\n\n\tif (!il->ops->send_tx_power)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (tx_power < 0) {\n\t\tIL_WARN(\"Requested user TXPOWER %d below 1 mW.\\n\", tx_power);\n\t\treturn -EINVAL;\n\t}\n\n\tif (tx_power > il->tx_power_device_lmt) {\n\t\tIL_WARN(\"Requested user TXPOWER %d above upper limit %d.\\n\",\n\t\t\ttx_power, il->tx_power_device_lmt);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!il_is_ready_rf(il))\n\t\treturn -EIO;\n\n\t \n\til->tx_power_next = tx_power;\n\n\t \n\tdefer = test_bit(S_SCANNING, &il->status) ||\n\t    memcmp(&il->active, &il->staging, sizeof(il->staging));\n\tif (defer && !force) {\n\t\tD_INFO(\"Deferring tx power set\\n\");\n\t\treturn 0;\n\t}\n\n\tprev_tx_power = il->tx_power_user_lmt;\n\til->tx_power_user_lmt = tx_power;\n\n\tret = il->ops->send_tx_power(il);\n\n\t \n\tif (ret) {\n\t\til->tx_power_user_lmt = prev_tx_power;\n\t\til->tx_power_next = prev_tx_power;\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(il_set_tx_power);\n\nvoid\nil_send_bt_config(struct il_priv *il)\n{\n\tstruct il_bt_cmd bt_cmd = {\n\t\t.lead_time = BT_LEAD_TIME_DEF,\n\t\t.max_kill = BT_MAX_KILL_DEF,\n\t\t.kill_ack_mask = 0,\n\t\t.kill_cts_mask = 0,\n\t};\n\n\tif (!bt_coex_active)\n\t\tbt_cmd.flags = BT_COEX_DISABLE;\n\telse\n\t\tbt_cmd.flags = BT_COEX_ENABLE;\n\n\tD_INFO(\"BT coex %s\\n\",\n\t       (bt_cmd.flags == BT_COEX_DISABLE) ? \"disable\" : \"active\");\n\n\tif (il_send_cmd_pdu(il, C_BT_CONFIG, sizeof(struct il_bt_cmd), &bt_cmd))\n\t\tIL_ERR(\"failed to send BT Coex Config\\n\");\n}\nEXPORT_SYMBOL(il_send_bt_config);\n\nint\nil_send_stats_request(struct il_priv *il, u8 flags, bool clear)\n{\n\tstruct il_stats_cmd stats_cmd = {\n\t\t.configuration_flags = clear ? IL_STATS_CONF_CLEAR_STATS : 0,\n\t};\n\n\tif (flags & CMD_ASYNC)\n\t\treturn il_send_cmd_pdu_async(il, C_STATS, sizeof(struct il_stats_cmd),\n\t\t\t\t\t     &stats_cmd, NULL);\n\telse\n\t\treturn il_send_cmd_pdu(il, C_STATS, sizeof(struct il_stats_cmd),\n\t\t\t\t       &stats_cmd);\n}\nEXPORT_SYMBOL(il_send_stats_request);\n\nvoid\nil_hdl_pm_sleep(struct il_priv *il, struct il_rx_buf *rxb)\n{\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tstruct il_sleep_notification *sleep = &(pkt->u.sleep_notif);\n\tD_RX(\"sleep mode: %d, src: %d\\n\",\n\t     sleep->pm_sleep_mode, sleep->pm_wakeup_src);\n#endif\n}\nEXPORT_SYMBOL(il_hdl_pm_sleep);\n\nvoid\nil_hdl_pm_debug_stats(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\tu32 len = le32_to_cpu(pkt->len_n_flags) & IL_RX_FRAME_SIZE_MSK;\n\tD_RADIO(\"Dumping %d bytes of unhandled notification for %s:\\n\", len,\n\t\til_get_cmd_string(pkt->hdr.cmd));\n\til_print_hex_dump(il, IL_DL_RADIO, pkt->u.raw, len);\n}\nEXPORT_SYMBOL(il_hdl_pm_debug_stats);\n\nvoid\nil_hdl_error(struct il_priv *il, struct il_rx_buf *rxb)\n{\n\tstruct il_rx_pkt *pkt = rxb_addr(rxb);\n\n\tIL_ERR(\"Error Reply type 0x%08X cmd %s (0x%02X) \"\n\t       \"seq 0x%04X ser 0x%08X\\n\",\n\t       le32_to_cpu(pkt->u.err_resp.error_type),\n\t       il_get_cmd_string(pkt->u.err_resp.cmd_id),\n\t       pkt->u.err_resp.cmd_id,\n\t       le16_to_cpu(pkt->u.err_resp.bad_cmd_seq_num),\n\t       le32_to_cpu(pkt->u.err_resp.error_info));\n}\nEXPORT_SYMBOL(il_hdl_error);\n\nvoid\nil_clear_isr_stats(struct il_priv *il)\n{\n\tmemset(&il->isr_stats, 0, sizeof(il->isr_stats));\n}\n\nint\nil_mac_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t       unsigned int link_id, u16 queue,\n\t       const struct ieee80211_tx_queue_params *params)\n{\n\tstruct il_priv *il = hw->priv;\n\tunsigned long flags;\n\tint q;\n\n\tD_MAC80211(\"enter\\n\");\n\n\tif (!il_is_ready_rf(il)) {\n\t\tD_MAC80211(\"leave - RF not ready\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (queue >= AC_NUM) {\n\t\tD_MAC80211(\"leave - queue >= AC_NUM %d\\n\", queue);\n\t\treturn 0;\n\t}\n\n\tq = AC_NUM - 1 - queue;\n\n\tspin_lock_irqsave(&il->lock, flags);\n\n\til->qos_data.def_qos_parm.ac[q].cw_min =\n\t    cpu_to_le16(params->cw_min);\n\til->qos_data.def_qos_parm.ac[q].cw_max =\n\t    cpu_to_le16(params->cw_max);\n\til->qos_data.def_qos_parm.ac[q].aifsn = params->aifs;\n\til->qos_data.def_qos_parm.ac[q].edca_txop =\n\t    cpu_to_le16((params->txop * 32));\n\n\til->qos_data.def_qos_parm.ac[q].reserved1 = 0;\n\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\tD_MAC80211(\"leave\\n\");\n\treturn 0;\n}\nEXPORT_SYMBOL(il_mac_conf_tx);\n\nint\nil_mac_tx_last_beacon(struct ieee80211_hw *hw)\n{\n\tstruct il_priv *il = hw->priv;\n\tint ret;\n\n\tD_MAC80211(\"enter\\n\");\n\n\tret = (il->ibss_manager == IL_IBSS_MANAGER);\n\n\tD_MAC80211(\"leave ret %d\\n\", ret);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(il_mac_tx_last_beacon);\n\nstatic int\nil_set_mode(struct il_priv *il)\n{\n\til_connection_init_rx_config(il);\n\n\tif (il->ops->set_rxon_chain)\n\t\til->ops->set_rxon_chain(il);\n\n\treturn il_commit_rxon(il);\n}\n\nint\nil_mac_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct il_priv *il = hw->priv;\n\tint err;\n\tbool reset;\n\n\tmutex_lock(&il->mutex);\n\tD_MAC80211(\"enter: type %d, addr %pM\\n\", vif->type, vif->addr);\n\n\tif (!il_is_ready_rf(il)) {\n\t\tIL_WARN(\"Try to add interface when device not ready\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\treset = (il->vif == vif);\n\tif (il->vif && !reset) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\til->vif = vif;\n\til->iw_mode = vif->type;\n\n\terr = il_set_mode(il);\n\tif (err) {\n\t\tIL_WARN(\"Fail to set mode %d\\n\", vif->type);\n\t\tif (!reset) {\n\t\t\til->vif = NULL;\n\t\t\til->iw_mode = NL80211_IFTYPE_STATION;\n\t\t}\n\t}\n\nout:\n\tD_MAC80211(\"leave err %d\\n\", err);\n\tmutex_unlock(&il->mutex);\n\n\treturn err;\n}\nEXPORT_SYMBOL(il_mac_add_interface);\n\nstatic void\nil_teardown_interface(struct il_priv *il, struct ieee80211_vif *vif)\n{\n\tlockdep_assert_held(&il->mutex);\n\n\tif (il->scan_vif == vif) {\n\t\til_scan_cancel_timeout(il, 200);\n\t\til_force_scan_end(il);\n\t}\n\n\til_set_mode(il);\n}\n\nvoid\nil_mac_remove_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct il_priv *il = hw->priv;\n\n\tmutex_lock(&il->mutex);\n\tD_MAC80211(\"enter: type %d, addr %pM\\n\", vif->type, vif->addr);\n\n\tWARN_ON(il->vif != vif);\n\til->vif = NULL;\n\til->iw_mode = NL80211_IFTYPE_UNSPECIFIED;\n\til_teardown_interface(il, vif);\n\teth_zero_addr(il->bssid);\n\n\tD_MAC80211(\"leave\\n\");\n\tmutex_unlock(&il->mutex);\n}\nEXPORT_SYMBOL(il_mac_remove_interface);\n\nint\nil_alloc_txq_mem(struct il_priv *il)\n{\n\tif (!il->txq)\n\t\til->txq =\n\t\t    kcalloc(il->cfg->num_of_queues,\n\t\t\t    sizeof(struct il_tx_queue),\n\t\t\t    GFP_KERNEL);\n\tif (!il->txq) {\n\t\tIL_ERR(\"Not enough memory for txq\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(il_alloc_txq_mem);\n\nvoid\nil_free_txq_mem(struct il_priv *il)\n{\n\tkfree(il->txq);\n\til->txq = NULL;\n}\nEXPORT_SYMBOL(il_free_txq_mem);\n\nint\nil_force_reset(struct il_priv *il, bool external)\n{\n\tstruct il_force_reset *force_reset;\n\n\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\treturn -EINVAL;\n\n\tforce_reset = &il->force_reset;\n\tforce_reset->reset_request_count++;\n\tif (!external) {\n\t\tif (force_reset->last_force_reset_jiffies &&\n\t\t    time_after(force_reset->last_force_reset_jiffies +\n\t\t\t       force_reset->reset_duration, jiffies)) {\n\t\t\tD_INFO(\"force reset rejected\\n\");\n\t\t\tforce_reset->reset_reject_count++;\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\tforce_reset->reset_success_count++;\n\tforce_reset->last_force_reset_jiffies = jiffies;\n\n\t \n\n\tif (!external && !il->cfg->mod_params->restart_fw) {\n\t\tD_INFO(\"Cancel firmware reload based on \"\n\t\t       \"module parameter setting\\n\");\n\t\treturn 0;\n\t}\n\n\tIL_ERR(\"On demand firmware reload\\n\");\n\n\t \n\tset_bit(S_FW_ERROR, &il->status);\n\twake_up(&il->wait_command_queue);\n\t \n\tclear_bit(S_READY, &il->status);\n\tqueue_work(il->workqueue, &il->restart);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(il_force_reset);\n\nint\nil_mac_change_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tenum nl80211_iftype newtype, bool newp2p)\n{\n\tstruct il_priv *il = hw->priv;\n\tint err;\n\n\tmutex_lock(&il->mutex);\n\tD_MAC80211(\"enter: type %d, addr %pM newtype %d newp2p %d\\n\",\n\t\t    vif->type, vif->addr, newtype, newp2p);\n\n\tif (newp2p) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (!il->vif || !il_is_ready_rf(il)) {\n\t\t \n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tvif->type = newtype;\n\tvif->p2p = false;\n\til->iw_mode = newtype;\n\til_teardown_interface(il, vif);\n\terr = 0;\n\nout:\n\tD_MAC80211(\"leave err %d\\n\", err);\n\tmutex_unlock(&il->mutex);\n\n\treturn err;\n}\nEXPORT_SYMBOL(il_mac_change_interface);\n\nvoid il_mac_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t  u32 queues, bool drop)\n{\n\tstruct il_priv *il = hw->priv;\n\tunsigned long timeout = jiffies + msecs_to_jiffies(500);\n\tint i;\n\n\tmutex_lock(&il->mutex);\n\tD_MAC80211(\"enter\\n\");\n\n\tif (il->txq == NULL)\n\t\tgoto out;\n\n\tfor (i = 0; i < il->hw_params.max_txq_num; i++) {\n\t\tstruct il_queue *q;\n\n\t\tif (i == il->cmd_queue)\n\t\t\tcontinue;\n\n\t\tq = &il->txq[i].q;\n\t\tif (q->read_ptr == q->write_ptr)\n\t\t\tcontinue;\n\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tIL_ERR(\"Failed to flush queue %d\\n\", q->id);\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(20);\n\t}\nout:\n\tD_MAC80211(\"leave\\n\");\n\tmutex_unlock(&il->mutex);\n}\nEXPORT_SYMBOL(il_mac_flush);\n\n \nstatic int\nil_check_stuck_queue(struct il_priv *il, int cnt)\n{\n\tstruct il_tx_queue *txq = &il->txq[cnt];\n\tstruct il_queue *q = &txq->q;\n\tunsigned long timeout;\n\tunsigned long now = jiffies;\n\tint ret;\n\n\tif (q->read_ptr == q->write_ptr) {\n\t\ttxq->time_stamp = now;\n\t\treturn 0;\n\t}\n\n\ttimeout =\n\t    txq->time_stamp +\n\t    msecs_to_jiffies(il->cfg->wd_timeout);\n\n\tif (time_after(now, timeout)) {\n\t\tIL_ERR(\"Queue %d stuck for %u ms.\\n\", q->id,\n\t\t       jiffies_to_msecs(now - txq->time_stamp));\n\t\tret = il_force_reset(il, false);\n\t\treturn (ret == -EAGAIN) ? 0 : 1;\n\t}\n\n\treturn 0;\n}\n\n \n#define IL_WD_TICK(timeout) ((timeout) / 4)\n\n \nvoid\nil_bg_watchdog(struct timer_list *t)\n{\n\tstruct il_priv *il = from_timer(il, t, watchdog);\n\tint cnt;\n\tunsigned long timeout;\n\n\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\treturn;\n\n\ttimeout = il->cfg->wd_timeout;\n\tif (timeout == 0)\n\t\treturn;\n\n\t \n\tif (il_check_stuck_queue(il, il->cmd_queue))\n\t\treturn;\n\n\t \n\tfor (cnt = 0; cnt < il->hw_params.max_txq_num; cnt++) {\n\t\t \n\t\tif (cnt == il->cmd_queue)\n\t\t\tcontinue;\n\t\tif (il_check_stuck_queue(il, cnt))\n\t\t\treturn;\n\t}\n\n\tmod_timer(&il->watchdog,\n\t\t  jiffies + msecs_to_jiffies(IL_WD_TICK(timeout)));\n}\nEXPORT_SYMBOL(il_bg_watchdog);\n\nvoid\nil_setup_watchdog(struct il_priv *il)\n{\n\tunsigned int timeout = il->cfg->wd_timeout;\n\n\tif (timeout)\n\t\tmod_timer(&il->watchdog,\n\t\t\t  jiffies + msecs_to_jiffies(IL_WD_TICK(timeout)));\n\telse\n\t\tdel_timer(&il->watchdog);\n}\nEXPORT_SYMBOL(il_setup_watchdog);\n\n \nu32\nil_usecs_to_beacons(struct il_priv *il, u32 usec, u32 beacon_interval)\n{\n\tu32 quot;\n\tu32 rem;\n\tu32 interval = beacon_interval * TIME_UNIT;\n\n\tif (!interval || !usec)\n\t\treturn 0;\n\n\tquot =\n\t    (usec /\n\t     interval) & (il_beacon_time_mask_high(il,\n\t\t\t\t\t\t   il->hw_params.\n\t\t\t\t\t\t   beacon_time_tsf_bits) >> il->\n\t\t\t  hw_params.beacon_time_tsf_bits);\n\trem =\n\t    (usec % interval) & il_beacon_time_mask_low(il,\n\t\t\t\t\t\t\til->hw_params.\n\t\t\t\t\t\t\tbeacon_time_tsf_bits);\n\n\treturn (quot << il->hw_params.beacon_time_tsf_bits) + rem;\n}\nEXPORT_SYMBOL(il_usecs_to_beacons);\n\n \n__le32\nil_add_beacon_time(struct il_priv *il, u32 base, u32 addon,\n\t\t   u32 beacon_interval)\n{\n\tu32 base_low = base & il_beacon_time_mask_low(il,\n\t\t\t\t\t\t      il->hw_params.\n\t\t\t\t\t\t      beacon_time_tsf_bits);\n\tu32 addon_low = addon & il_beacon_time_mask_low(il,\n\t\t\t\t\t\t\til->hw_params.\n\t\t\t\t\t\t\tbeacon_time_tsf_bits);\n\tu32 interval = beacon_interval * TIME_UNIT;\n\tu32 res = (base & il_beacon_time_mask_high(il,\n\t\t\t\t\t\t   il->hw_params.\n\t\t\t\t\t\t   beacon_time_tsf_bits)) +\n\t    (addon & il_beacon_time_mask_high(il,\n\t\t\t\t\t      il->hw_params.\n\t\t\t\t\t      beacon_time_tsf_bits));\n\n\tif (base_low > addon_low)\n\t\tres += base_low - addon_low;\n\telse if (base_low < addon_low) {\n\t\tres += interval + base_low - addon_low;\n\t\tres += (1 << il->hw_params.beacon_time_tsf_bits);\n\t} else\n\t\tres += (1 << il->hw_params.beacon_time_tsf_bits);\n\n\treturn cpu_to_le32(res);\n}\nEXPORT_SYMBOL(il_add_beacon_time);\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int\nil_pci_suspend(struct device *device)\n{\n\tstruct il_priv *il = dev_get_drvdata(device);\n\n\t \n\til_apm_stop(il);\n\n\treturn 0;\n}\n\nstatic int\nil_pci_resume(struct device *device)\n{\n\tstruct pci_dev *pdev = to_pci_dev(device);\n\tstruct il_priv *il = pci_get_drvdata(pdev);\n\tbool hw_rfkill = false;\n\n\t \n\tpci_write_config_byte(pdev, PCI_CFG_RETRY_TIMEOUT, 0x00);\n\n\til_enable_interrupts(il);\n\n\tif (!(_il_rd(il, CSR_GP_CNTRL) & CSR_GP_CNTRL_REG_FLAG_HW_RF_KILL_SW))\n\t\thw_rfkill = true;\n\n\tif (hw_rfkill)\n\t\tset_bit(S_RFKILL, &il->status);\n\telse\n\t\tclear_bit(S_RFKILL, &il->status);\n\n\twiphy_rfkill_set_hw_state(il->hw->wiphy, hw_rfkill);\n\n\treturn 0;\n}\n\nSIMPLE_DEV_PM_OPS(il_pm_ops, il_pci_suspend, il_pci_resume);\nEXPORT_SYMBOL(il_pm_ops);\n\n#endif  \n\nstatic void\nil_update_qos(struct il_priv *il)\n{\n\tif (test_bit(S_EXIT_PENDING, &il->status))\n\t\treturn;\n\n\til->qos_data.def_qos_parm.qos_flags = 0;\n\n\tif (il->qos_data.qos_active)\n\t\til->qos_data.def_qos_parm.qos_flags |=\n\t\t    QOS_PARAM_FLG_UPDATE_EDCA_MSK;\n\n\tif (il->ht.enabled)\n\t\til->qos_data.def_qos_parm.qos_flags |= QOS_PARAM_FLG_TGN_MSK;\n\n\tD_QOS(\"send QoS cmd with Qos active=%d FLAGS=0x%X\\n\",\n\t      il->qos_data.qos_active, il->qos_data.def_qos_parm.qos_flags);\n\n\til_send_cmd_pdu_async(il, C_QOS_PARAM, sizeof(struct il_qosparam_cmd),\n\t\t\t      &il->qos_data.def_qos_parm, NULL);\n}\n\n \nint\nil_mac_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct il_priv *il = hw->priv;\n\tconst struct il_channel_info *ch_info;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tstruct ieee80211_channel *channel = conf->chandef.chan;\n\tstruct il_ht_config *ht_conf = &il->current_ht_config;\n\tunsigned long flags = 0;\n\tint ret = 0;\n\tu16 ch;\n\tint scan_active = 0;\n\tbool ht_changed = false;\n\n\tmutex_lock(&il->mutex);\n\tD_MAC80211(\"enter: channel %d changed 0x%X\\n\", channel->hw_value,\n\t\t   changed);\n\n\tif (unlikely(test_bit(S_SCANNING, &il->status))) {\n\t\tscan_active = 1;\n\t\tD_MAC80211(\"scan active\\n\");\n\t}\n\n\tif (changed &\n\t    (IEEE80211_CONF_CHANGE_SMPS | IEEE80211_CONF_CHANGE_CHANNEL)) {\n\t\t \n\t\til->current_ht_config.smps = conf->smps_mode;\n\n\t\t \n\t\tif (il->ops->set_rxon_chain)\n\t\t\til->ops->set_rxon_chain(il);\n\t}\n\n\t \n\tif (!changed || (changed & IEEE80211_CONF_CHANGE_CHANNEL)) {\n\n\t\tif (scan_active)\n\t\t\tgoto set_ch_out;\n\n\t\tch = channel->hw_value;\n\t\tch_info = il_get_channel_info(il, channel->band, ch);\n\t\tif (!il_is_channel_valid(ch_info)) {\n\t\t\tD_MAC80211(\"leave - invalid channel\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto set_ch_out;\n\t\t}\n\n\t\tif (il->iw_mode == NL80211_IFTYPE_ADHOC &&\n\t\t    !il_is_channel_ibss(ch_info)) {\n\t\t\tD_MAC80211(\"leave - not IBSS channel\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto set_ch_out;\n\t\t}\n\n\t\tspin_lock_irqsave(&il->lock, flags);\n\n\t\t \n\t\tif (il->ht.enabled != conf_is_ht(conf)) {\n\t\t\til->ht.enabled = conf_is_ht(conf);\n\t\t\tht_changed = true;\n\t\t}\n\t\tif (il->ht.enabled) {\n\t\t\tif (conf_is_ht40_minus(conf)) {\n\t\t\t\til->ht.extension_chan_offset =\n\t\t\t\t    IEEE80211_HT_PARAM_CHA_SEC_BELOW;\n\t\t\t\til->ht.is_40mhz = true;\n\t\t\t} else if (conf_is_ht40_plus(conf)) {\n\t\t\t\til->ht.extension_chan_offset =\n\t\t\t\t    IEEE80211_HT_PARAM_CHA_SEC_ABOVE;\n\t\t\t\til->ht.is_40mhz = true;\n\t\t\t} else {\n\t\t\t\til->ht.extension_chan_offset =\n\t\t\t\t    IEEE80211_HT_PARAM_CHA_SEC_NONE;\n\t\t\t\til->ht.is_40mhz = false;\n\t\t\t}\n\t\t} else\n\t\t\til->ht.is_40mhz = false;\n\n\t\t \n\t\til->ht.protection = IEEE80211_HT_OP_MODE_PROTECTION_NONE;\n\n\t\t \n\t\tif ((le16_to_cpu(il->staging.channel) != ch))\n\t\t\til->staging.flags = 0;\n\n\t\til_set_rxon_channel(il, channel);\n\t\til_set_rxon_ht(il, ht_conf);\n\n\t\til_set_flags_for_band(il, channel->band, il->vif);\n\n\t\tspin_unlock_irqrestore(&il->lock, flags);\n\n\t\tif (il->ops->update_bcast_stations)\n\t\t\tret = il->ops->update_bcast_stations(il);\n\nset_ch_out:\n\t\t \n\t\til_set_rate(il);\n\t}\n\n\tif (changed & (IEEE80211_CONF_CHANGE_PS | IEEE80211_CONF_CHANGE_IDLE)) {\n\t\til->power_data.ps_disabled = !(conf->flags & IEEE80211_CONF_PS);\n\t\tif (!il->power_data.ps_disabled)\n\t\t\tIL_WARN_ONCE(\"Enabling power save might cause firmware crashes\\n\");\n\t\tret = il_power_update_mode(il, false);\n\t\tif (ret)\n\t\t\tD_MAC80211(\"Error setting sleep level\\n\");\n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_POWER) {\n\t\tD_MAC80211(\"TX Power old=%d new=%d\\n\", il->tx_power_user_lmt,\n\t\t\t   conf->power_level);\n\n\t\til_set_tx_power(il, conf->power_level, false);\n\t}\n\n\tif (!il_is_ready(il)) {\n\t\tD_MAC80211(\"leave - not ready\\n\");\n\t\tgoto out;\n\t}\n\n\tif (scan_active)\n\t\tgoto out;\n\n\tif (memcmp(&il->active, &il->staging, sizeof(il->staging)))\n\t\til_commit_rxon(il);\n\telse\n\t\tD_INFO(\"Not re-sending same RXON configuration.\\n\");\n\tif (ht_changed)\n\t\til_update_qos(il);\n\nout:\n\tD_MAC80211(\"leave ret %d\\n\", ret);\n\tmutex_unlock(&il->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(il_mac_config);\n\nvoid\nil_mac_reset_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct il_priv *il = hw->priv;\n\tunsigned long flags;\n\n\tmutex_lock(&il->mutex);\n\tD_MAC80211(\"enter: type %d, addr %pM\\n\", vif->type, vif->addr);\n\n\tspin_lock_irqsave(&il->lock, flags);\n\n\tmemset(&il->current_ht_config, 0, sizeof(struct il_ht_config));\n\n\t \n\tdev_consume_skb_irq(il->beacon_skb);\n\til->beacon_skb = NULL;\n\til->timestamp = 0;\n\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\til_scan_cancel_timeout(il, 100);\n\tif (!il_is_ready_rf(il)) {\n\t\tD_MAC80211(\"leave - not ready\\n\");\n\t\tmutex_unlock(&il->mutex);\n\t\treturn;\n\t}\n\n\t \n\til->staging.filter_flags &= ~RXON_FILTER_ASSOC_MSK;\n\til_commit_rxon(il);\n\n\til_set_rate(il);\n\n\tD_MAC80211(\"leave\\n\");\n\tmutex_unlock(&il->mutex);\n}\nEXPORT_SYMBOL(il_mac_reset_tsf);\n\nstatic void\nil_ht_conf(struct il_priv *il, struct ieee80211_vif *vif)\n{\n\tstruct il_ht_config *ht_conf = &il->current_ht_config;\n\tstruct ieee80211_sta *sta;\n\tstruct ieee80211_bss_conf *bss_conf = &vif->bss_conf;\n\n\tD_ASSOC(\"enter:\\n\");\n\n\tif (!il->ht.enabled)\n\t\treturn;\n\n\til->ht.protection =\n\t    bss_conf->ht_operation_mode & IEEE80211_HT_OP_MODE_PROTECTION;\n\til->ht.non_gf_sta_present =\n\t    !!(bss_conf->\n\t       ht_operation_mode & IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\n\n\tht_conf->single_chain_sufficient = false;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\trcu_read_lock();\n\t\tsta = ieee80211_find_sta(vif, bss_conf->bssid);\n\t\tif (sta) {\n\t\t\tstruct ieee80211_sta_ht_cap *ht_cap = &sta->deflink.ht_cap;\n\t\t\tint maxstreams;\n\n\t\t\tmaxstreams =\n\t\t\t    (ht_cap->mcs.\n\t\t\t     tx_params & IEEE80211_HT_MCS_TX_MAX_STREAMS_MASK)\n\t\t\t    >> IEEE80211_HT_MCS_TX_MAX_STREAMS_SHIFT;\n\t\t\tmaxstreams += 1;\n\n\t\t\tif (ht_cap->mcs.rx_mask[1] == 0 &&\n\t\t\t    ht_cap->mcs.rx_mask[2] == 0)\n\t\t\t\tht_conf->single_chain_sufficient = true;\n\t\t\tif (maxstreams <= 1)\n\t\t\t\tht_conf->single_chain_sufficient = true;\n\t\t} else {\n\t\t\t \n\t\t\tht_conf->single_chain_sufficient = true;\n\t\t}\n\t\trcu_read_unlock();\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tht_conf->single_chain_sufficient = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tD_ASSOC(\"leave\\n\");\n}\n\nstatic inline void\nil_set_no_assoc(struct il_priv *il, struct ieee80211_vif *vif)\n{\n\t \n\til->staging.filter_flags &= ~RXON_FILTER_ASSOC_MSK;\n\til->staging.assoc_id = 0;\n\til_commit_rxon(il);\n}\n\nstatic void\nil_beacon_update(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct il_priv *il = hw->priv;\n\tunsigned long flags;\n\t__le64 timestamp;\n\tstruct sk_buff *skb = ieee80211_beacon_get(hw, vif, 0);\n\n\tif (!skb)\n\t\treturn;\n\n\tD_MAC80211(\"enter\\n\");\n\n\tlockdep_assert_held(&il->mutex);\n\n\tif (!il->beacon_enabled) {\n\t\tIL_ERR(\"update beacon with no beaconing enabled\\n\");\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&il->lock, flags);\n\tdev_consume_skb_irq(il->beacon_skb);\n\til->beacon_skb = skb;\n\n\ttimestamp = ((struct ieee80211_mgmt *)skb->data)->u.beacon.timestamp;\n\til->timestamp = le64_to_cpu(timestamp);\n\n\tD_MAC80211(\"leave\\n\");\n\tspin_unlock_irqrestore(&il->lock, flags);\n\n\tif (!il_is_ready_rf(il)) {\n\t\tD_MAC80211(\"leave - RF not ready\\n\");\n\t\treturn;\n\t}\n\n\til->ops->post_associate(il);\n}\n\nvoid\nil_mac_bss_info_changed(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_bss_conf *bss_conf, u64 changes)\n{\n\tstruct il_priv *il = hw->priv;\n\tint ret;\n\n\tmutex_lock(&il->mutex);\n\tD_MAC80211(\"enter: changes 0x%llx\\n\", changes);\n\n\tif (!il_is_alive(il)) {\n\t\tD_MAC80211(\"leave - not alive\\n\");\n\t\tmutex_unlock(&il->mutex);\n\t\treturn;\n\t}\n\n\tif (changes & BSS_CHANGED_QOS) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&il->lock, flags);\n\t\til->qos_data.qos_active = bss_conf->qos;\n\t\til_update_qos(il);\n\t\tspin_unlock_irqrestore(&il->lock, flags);\n\t}\n\n\tif (changes & BSS_CHANGED_BEACON_ENABLED) {\n\t\t \n\t\tif (vif->bss_conf.enable_beacon)\n\t\t\til->beacon_enabled = true;\n\t\telse\n\t\t\til->beacon_enabled = false;\n\t}\n\n\tif (changes & BSS_CHANGED_BSSID) {\n\t\tD_MAC80211(\"BSSID %pM\\n\", bss_conf->bssid);\n\n\t\t \n\t\tif (is_zero_ether_addr(bss_conf->bssid))\n\t\t\til_wake_queues_by_reason(il, IL_STOP_REASON_PASSIVE);\n\n\t\t \n\t\tif (il_scan_cancel_timeout(il, 100)) {\n\t\t\tD_MAC80211(\"leave - scan abort failed\\n\");\n\t\t\tmutex_unlock(&il->mutex);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tmemcpy(il->staging.bssid_addr, bss_conf->bssid, ETH_ALEN);\n\n\t\t \n\t\tmemcpy(il->bssid, bss_conf->bssid, ETH_ALEN);\n\t}\n\n\t \n\tif (vif->type == NL80211_IFTYPE_ADHOC && (changes & BSS_CHANGED_BEACON))\n\t\til_beacon_update(hw, vif);\n\n\tif (changes & BSS_CHANGED_ERP_PREAMBLE) {\n\t\tD_MAC80211(\"ERP_PREAMBLE %d\\n\", bss_conf->use_short_preamble);\n\t\tif (bss_conf->use_short_preamble)\n\t\t\til->staging.flags |= RXON_FLG_SHORT_PREAMBLE_MSK;\n\t\telse\n\t\t\til->staging.flags &= ~RXON_FLG_SHORT_PREAMBLE_MSK;\n\t}\n\n\tif (changes & BSS_CHANGED_ERP_CTS_PROT) {\n\t\tD_MAC80211(\"ERP_CTS %d\\n\", bss_conf->use_cts_prot);\n\t\tif (bss_conf->use_cts_prot && il->band != NL80211_BAND_5GHZ)\n\t\t\til->staging.flags |= RXON_FLG_TGG_PROTECT_MSK;\n\t\telse\n\t\t\til->staging.flags &= ~RXON_FLG_TGG_PROTECT_MSK;\n\t\tif (bss_conf->use_cts_prot)\n\t\t\til->staging.flags |= RXON_FLG_SELF_CTS_EN;\n\t\telse\n\t\t\til->staging.flags &= ~RXON_FLG_SELF_CTS_EN;\n\t}\n\n\tif (changes & BSS_CHANGED_BASIC_RATES) {\n\t\t \n\t}\n\n\tif (changes & BSS_CHANGED_HT) {\n\t\til_ht_conf(il, vif);\n\n\t\tif (il->ops->set_rxon_chain)\n\t\t\til->ops->set_rxon_chain(il);\n\t}\n\n\tif (changes & BSS_CHANGED_ASSOC) {\n\t\tD_MAC80211(\"ASSOC %d\\n\", vif->cfg.assoc);\n\t\tif (vif->cfg.assoc) {\n\t\t\til->timestamp = bss_conf->sync_tsf;\n\n\t\t\tif (!il_is_rfkill(il))\n\t\t\t\til->ops->post_associate(il);\n\t\t} else\n\t\t\til_set_no_assoc(il, vif);\n\t}\n\n\tif (changes && il_is_associated(il) && vif->cfg.aid) {\n\t\tD_MAC80211(\"Changes (%#llx) while associated\\n\", changes);\n\t\tret = il_send_rxon_assoc(il);\n\t\tif (!ret) {\n\t\t\t \n\t\t\tmemcpy((void *)&il->active, &il->staging,\n\t\t\t       sizeof(struct il_rxon_cmd));\n\t\t}\n\t}\n\n\tif (changes & BSS_CHANGED_BEACON_ENABLED) {\n\t\tif (vif->bss_conf.enable_beacon) {\n\t\t\tmemcpy(il->staging.bssid_addr, bss_conf->bssid,\n\t\t\t       ETH_ALEN);\n\t\t\tmemcpy(il->bssid, bss_conf->bssid, ETH_ALEN);\n\t\t\til->ops->config_ap(il);\n\t\t} else\n\t\t\til_set_no_assoc(il, vif);\n\t}\n\n\tif (changes & BSS_CHANGED_IBSS) {\n\t\tret = il->ops->manage_ibss_station(il, vif,\n\t\t\t\t\t\t   vif->cfg.ibss_joined);\n\t\tif (ret)\n\t\t\tIL_ERR(\"failed to %s IBSS station %pM\\n\",\n\t\t\t       vif->cfg.ibss_joined ? \"add\" : \"remove\",\n\t\t\t       bss_conf->bssid);\n\t}\n\n\tD_MAC80211(\"leave\\n\");\n\tmutex_unlock(&il->mutex);\n}\nEXPORT_SYMBOL(il_mac_bss_info_changed);\n\nirqreturn_t\nil_isr(int irq, void *data)\n{\n\tstruct il_priv *il = data;\n\tu32 inta, inta_mask;\n\tu32 inta_fh;\n\tunsigned long flags;\n\tif (!il)\n\t\treturn IRQ_NONE;\n\n\tspin_lock_irqsave(&il->lock, flags);\n\n\t \n\tinta_mask = _il_rd(il, CSR_INT_MASK);\t \n\t_il_wr(il, CSR_INT_MASK, 0x00000000);\n\n\t \n\tinta = _il_rd(il, CSR_INT);\n\tinta_fh = _il_rd(il, CSR_FH_INT_STATUS);\n\n\t \n\tif (!inta && !inta_fh) {\n\t\tD_ISR(\"Ignore interrupt, inta == 0, inta_fh == 0\\n\");\n\t\tgoto none;\n\t}\n\n\tif (inta == 0xFFFFFFFF || (inta & 0xFFFFFFF0) == 0xa5a5a5a0) {\n\t\t \n\t\tIL_WARN(\"HARDWARE GONE?? INTA == 0x%08x\\n\", inta);\n\t\tgoto unplugged;\n\t}\n\n\tD_ISR(\"ISR inta 0x%08x, enabled 0x%08x, fh 0x%08x\\n\", inta, inta_mask,\n\t      inta_fh);\n\n\tinta &= ~CSR_INT_BIT_SCD;\n\n\t \n\tif (likely(inta || inta_fh))\n\t\ttasklet_schedule(&il->irq_tasklet);\n\nunplugged:\n\tspin_unlock_irqrestore(&il->lock, flags);\n\treturn IRQ_HANDLED;\n\nnone:\n\t \n\t \n\tif (test_bit(S_INT_ENABLED, &il->status))\n\t\til_enable_interrupts(il);\n\tspin_unlock_irqrestore(&il->lock, flags);\n\treturn IRQ_NONE;\n}\nEXPORT_SYMBOL(il_isr);\n\n \nvoid\nil_tx_cmd_protection(struct il_priv *il, struct ieee80211_tx_info *info,\n\t\t     __le16 fc, __le32 *tx_flags)\n{\n\tif (info->control.rates[0].flags & IEEE80211_TX_RC_USE_RTS_CTS) {\n\t\t*tx_flags |= TX_CMD_FLG_RTS_MSK;\n\t\t*tx_flags &= ~TX_CMD_FLG_CTS_MSK;\n\t\t*tx_flags |= TX_CMD_FLG_FULL_TXOP_PROT_MSK;\n\n\t\tif (!ieee80211_is_mgmt(fc))\n\t\t\treturn;\n\n\t\tswitch (fc & cpu_to_le16(IEEE80211_FCTL_STYPE)) {\n\t\tcase cpu_to_le16(IEEE80211_STYPE_AUTH):\n\t\tcase cpu_to_le16(IEEE80211_STYPE_DEAUTH):\n\t\tcase cpu_to_le16(IEEE80211_STYPE_ASSOC_REQ):\n\t\tcase cpu_to_le16(IEEE80211_STYPE_REASSOC_REQ):\n\t\t\t*tx_flags &= ~TX_CMD_FLG_RTS_MSK;\n\t\t\t*tx_flags |= TX_CMD_FLG_CTS_MSK;\n\t\t\tbreak;\n\t\t}\n\t} else if (info->control.rates[0].\n\t\t   flags & IEEE80211_TX_RC_USE_CTS_PROTECT) {\n\t\t*tx_flags &= ~TX_CMD_FLG_RTS_MSK;\n\t\t*tx_flags |= TX_CMD_FLG_CTS_MSK;\n\t\t*tx_flags |= TX_CMD_FLG_FULL_TXOP_PROT_MSK;\n\t}\n}\nEXPORT_SYMBOL(il_tx_cmd_protection);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}