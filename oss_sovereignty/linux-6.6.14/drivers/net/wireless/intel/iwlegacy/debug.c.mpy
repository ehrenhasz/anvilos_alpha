{
  "module_name": "debug.c",
  "hash_id": "1d5b4f4fedf92e7db67eef80ca9c5a4043fbd5a2eb67d7d381e2331b09b50ac2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlegacy/debug.c",
  "human_readable_source": "\n \n#include <linux/ieee80211.h>\n#include <linux/export.h>\n#include <net/mac80211.h>\n\n#include \"common.h\"\n\nstatic void\nil_clear_traffic_stats(struct il_priv *il)\n{\n\tmemset(&il->tx_stats, 0, sizeof(struct traffic_stats));\n\tmemset(&il->rx_stats, 0, sizeof(struct traffic_stats));\n}\n\n \nvoid\nil_update_stats(struct il_priv *il, bool is_tx, __le16 fc, u16 len)\n{\n\tstruct traffic_stats *stats;\n\n\tif (is_tx)\n\t\tstats = &il->tx_stats;\n\telse\n\t\tstats = &il->rx_stats;\n\n\tif (ieee80211_is_mgmt(fc)) {\n\t\tswitch (fc & cpu_to_le16(IEEE80211_FCTL_STYPE)) {\n\t\tcase cpu_to_le16(IEEE80211_STYPE_ASSOC_REQ):\n\t\t\tstats->mgmt[MANAGEMENT_ASSOC_REQ]++;\n\t\t\tbreak;\n\t\tcase cpu_to_le16(IEEE80211_STYPE_ASSOC_RESP):\n\t\t\tstats->mgmt[MANAGEMENT_ASSOC_RESP]++;\n\t\t\tbreak;\n\t\tcase cpu_to_le16(IEEE80211_STYPE_REASSOC_REQ):\n\t\t\tstats->mgmt[MANAGEMENT_REASSOC_REQ]++;\n\t\t\tbreak;\n\t\tcase cpu_to_le16(IEEE80211_STYPE_REASSOC_RESP):\n\t\t\tstats->mgmt[MANAGEMENT_REASSOC_RESP]++;\n\t\t\tbreak;\n\t\tcase cpu_to_le16(IEEE80211_STYPE_PROBE_REQ):\n\t\t\tstats->mgmt[MANAGEMENT_PROBE_REQ]++;\n\t\t\tbreak;\n\t\tcase cpu_to_le16(IEEE80211_STYPE_PROBE_RESP):\n\t\t\tstats->mgmt[MANAGEMENT_PROBE_RESP]++;\n\t\t\tbreak;\n\t\tcase cpu_to_le16(IEEE80211_STYPE_BEACON):\n\t\t\tstats->mgmt[MANAGEMENT_BEACON]++;\n\t\t\tbreak;\n\t\tcase cpu_to_le16(IEEE80211_STYPE_ATIM):\n\t\t\tstats->mgmt[MANAGEMENT_ATIM]++;\n\t\t\tbreak;\n\t\tcase cpu_to_le16(IEEE80211_STYPE_DISASSOC):\n\t\t\tstats->mgmt[MANAGEMENT_DISASSOC]++;\n\t\t\tbreak;\n\t\tcase cpu_to_le16(IEEE80211_STYPE_AUTH):\n\t\t\tstats->mgmt[MANAGEMENT_AUTH]++;\n\t\t\tbreak;\n\t\tcase cpu_to_le16(IEEE80211_STYPE_DEAUTH):\n\t\t\tstats->mgmt[MANAGEMENT_DEAUTH]++;\n\t\t\tbreak;\n\t\tcase cpu_to_le16(IEEE80211_STYPE_ACTION):\n\t\t\tstats->mgmt[MANAGEMENT_ACTION]++;\n\t\t\tbreak;\n\t\t}\n\t} else if (ieee80211_is_ctl(fc)) {\n\t\tswitch (fc & cpu_to_le16(IEEE80211_FCTL_STYPE)) {\n\t\tcase cpu_to_le16(IEEE80211_STYPE_BACK_REQ):\n\t\t\tstats->ctrl[CONTROL_BACK_REQ]++;\n\t\t\tbreak;\n\t\tcase cpu_to_le16(IEEE80211_STYPE_BACK):\n\t\t\tstats->ctrl[CONTROL_BACK]++;\n\t\t\tbreak;\n\t\tcase cpu_to_le16(IEEE80211_STYPE_PSPOLL):\n\t\t\tstats->ctrl[CONTROL_PSPOLL]++;\n\t\t\tbreak;\n\t\tcase cpu_to_le16(IEEE80211_STYPE_RTS):\n\t\t\tstats->ctrl[CONTROL_RTS]++;\n\t\t\tbreak;\n\t\tcase cpu_to_le16(IEEE80211_STYPE_CTS):\n\t\t\tstats->ctrl[CONTROL_CTS]++;\n\t\t\tbreak;\n\t\tcase cpu_to_le16(IEEE80211_STYPE_ACK):\n\t\t\tstats->ctrl[CONTROL_ACK]++;\n\t\t\tbreak;\n\t\tcase cpu_to_le16(IEEE80211_STYPE_CFEND):\n\t\t\tstats->ctrl[CONTROL_CFEND]++;\n\t\t\tbreak;\n\t\tcase cpu_to_le16(IEEE80211_STYPE_CFENDACK):\n\t\t\tstats->ctrl[CONTROL_CFENDACK]++;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tstats->data_cnt++;\n\t\tstats->data_bytes += len;\n\t}\n}\nEXPORT_SYMBOL(il_update_stats);\n\n \n#define DEBUGFS_ADD_FILE(name, parent, mode) do {\t\t\t\\\n\tdebugfs_create_file(#name, mode, parent, il,\t\t\t\\\n\t\t\t    &il_dbgfs_##name##_ops);\t\t\t\\\n} while (0)\n\n#define DEBUGFS_ADD_BOOL(name, parent, ptr) do {\t\t\t\\\n\tdebugfs_create_bool(#name, 0600, parent, ptr);\t\t\t\\\n} while (0)\n\n \n#define DEBUGFS_READ_FUNC(name)                                         \\\nstatic ssize_t il_dbgfs_##name##_read(struct file *file,               \\\n\t\t\t\t\tchar __user *user_buf,          \\\n\t\t\t\t\tsize_t count, loff_t *ppos);\n\n#define DEBUGFS_WRITE_FUNC(name)                                        \\\nstatic ssize_t il_dbgfs_##name##_write(struct file *file,              \\\n\t\t\t\t\tconst char __user *user_buf,    \\\n\t\t\t\t\tsize_t count, loff_t *ppos);\n\n\n#define DEBUGFS_READ_FILE_OPS(name)\t\t\t\t\\\n\tDEBUGFS_READ_FUNC(name);\t\t\t\t\\\nstatic const struct file_operations il_dbgfs_##name##_ops = {\t\\\n\t.read = il_dbgfs_##name##_read,\t\t\t\t\\\n\t.open = simple_open,\t\t\t\t\t\\\n\t.llseek = generic_file_llseek,\t\t\t\t\\\n};\n\n#define DEBUGFS_WRITE_FILE_OPS(name)\t\t\t\t\\\n\tDEBUGFS_WRITE_FUNC(name);\t\t\t\t\\\nstatic const struct file_operations il_dbgfs_##name##_ops = {\t\\\n\t.write = il_dbgfs_##name##_write,\t\t\t\\\n\t.open = simple_open,\t\t\t\t\t\\\n\t.llseek = generic_file_llseek,\t\t\t\t\\\n};\n\n#define DEBUGFS_READ_WRITE_FILE_OPS(name)\t\t\t\\\n\tDEBUGFS_READ_FUNC(name);\t\t\t\t\\\n\tDEBUGFS_WRITE_FUNC(name);\t\t\t\t\\\nstatic const struct file_operations il_dbgfs_##name##_ops = {\t\\\n\t.write = il_dbgfs_##name##_write,\t\t\t\\\n\t.read = il_dbgfs_##name##_read,\t\t\t\t\\\n\t.open = simple_open,\t\t\t\t\t\\\n\t.llseek = generic_file_llseek,\t\t\t\t\\\n};\n\nstatic const char *\nil_get_mgmt_string(int cmd)\n{\n\tswitch (cmd) {\n\tIL_CMD(MANAGEMENT_ASSOC_REQ);\n\tIL_CMD(MANAGEMENT_ASSOC_RESP);\n\tIL_CMD(MANAGEMENT_REASSOC_REQ);\n\tIL_CMD(MANAGEMENT_REASSOC_RESP);\n\tIL_CMD(MANAGEMENT_PROBE_REQ);\n\tIL_CMD(MANAGEMENT_PROBE_RESP);\n\tIL_CMD(MANAGEMENT_BEACON);\n\tIL_CMD(MANAGEMENT_ATIM);\n\tIL_CMD(MANAGEMENT_DISASSOC);\n\tIL_CMD(MANAGEMENT_AUTH);\n\tIL_CMD(MANAGEMENT_DEAUTH);\n\tIL_CMD(MANAGEMENT_ACTION);\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\n\t}\n}\n\nstatic const char *\nil_get_ctrl_string(int cmd)\n{\n\tswitch (cmd) {\n\tIL_CMD(CONTROL_BACK_REQ);\n\tIL_CMD(CONTROL_BACK);\n\tIL_CMD(CONTROL_PSPOLL);\n\tIL_CMD(CONTROL_RTS);\n\tIL_CMD(CONTROL_CTS);\n\tIL_CMD(CONTROL_ACK);\n\tIL_CMD(CONTROL_CFEND);\n\tIL_CMD(CONTROL_CFENDACK);\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\n\t}\n}\n\nstatic ssize_t\nil_dbgfs_tx_stats_read(struct file *file, char __user *user_buf, size_t count,\n\t\t       loff_t *ppos)\n{\n\n\tstruct il_priv *il = file->private_data;\n\tchar *buf;\n\tint pos = 0;\n\n\tint cnt;\n\tssize_t ret;\n\tconst size_t bufsz =\n\t    100 + sizeof(char) * 50 * (MANAGEMENT_MAX + CONTROL_MAX);\n\tbuf = kzalloc(bufsz, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tpos += scnprintf(buf + pos, bufsz - pos, \"Management:\\n\");\n\tfor (cnt = 0; cnt < MANAGEMENT_MAX; cnt++) {\n\t\tpos +=\n\t\t    scnprintf(buf + pos, bufsz - pos, \"\\t%25s\\t\\t: %u\\n\",\n\t\t\t      il_get_mgmt_string(cnt), il->tx_stats.mgmt[cnt]);\n\t}\n\tpos += scnprintf(buf + pos, bufsz - pos, \"Control\\n\");\n\tfor (cnt = 0; cnt < CONTROL_MAX; cnt++) {\n\t\tpos +=\n\t\t    scnprintf(buf + pos, bufsz - pos, \"\\t%25s\\t\\t: %u\\n\",\n\t\t\t      il_get_ctrl_string(cnt), il->tx_stats.ctrl[cnt]);\n\t}\n\tpos += scnprintf(buf + pos, bufsz - pos, \"Data:\\n\");\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"\\tcnt: %u\\n\",\n\t\t      il->tx_stats.data_cnt);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"\\tbytes: %llu\\n\",\n\t\t      il->tx_stats.data_bytes);\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic ssize_t\nil_dbgfs_clear_traffic_stats_write(struct file *file,\n\t\t\t\t   const char __user *user_buf, size_t count,\n\t\t\t\t   loff_t *ppos)\n{\n\tstruct il_priv *il = file->private_data;\n\tu32 clear_flag;\n\tchar buf[8];\n\tint buf_size;\n\n\tmemset(buf, 0, sizeof(buf));\n\tbuf_size = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\tif (sscanf(buf, \"%x\", &clear_flag) != 1)\n\t\treturn -EFAULT;\n\til_clear_traffic_stats(il);\n\n\treturn count;\n}\n\nstatic ssize_t\nil_dbgfs_rx_stats_read(struct file *file, char __user *user_buf, size_t count,\n\t\t       loff_t *ppos)\n{\n\n\tstruct il_priv *il = file->private_data;\n\tchar *buf;\n\tint pos = 0;\n\tint cnt;\n\tssize_t ret;\n\tconst size_t bufsz =\n\t    100 + sizeof(char) * 50 * (MANAGEMENT_MAX + CONTROL_MAX);\n\tbuf = kzalloc(bufsz, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tpos += scnprintf(buf + pos, bufsz - pos, \"Management:\\n\");\n\tfor (cnt = 0; cnt < MANAGEMENT_MAX; cnt++) {\n\t\tpos +=\n\t\t    scnprintf(buf + pos, bufsz - pos, \"\\t%25s\\t\\t: %u\\n\",\n\t\t\t      il_get_mgmt_string(cnt), il->rx_stats.mgmt[cnt]);\n\t}\n\tpos += scnprintf(buf + pos, bufsz - pos, \"Control:\\n\");\n\tfor (cnt = 0; cnt < CONTROL_MAX; cnt++) {\n\t\tpos +=\n\t\t    scnprintf(buf + pos, bufsz - pos, \"\\t%25s\\t\\t: %u\\n\",\n\t\t\t      il_get_ctrl_string(cnt), il->rx_stats.ctrl[cnt]);\n\t}\n\tpos += scnprintf(buf + pos, bufsz - pos, \"Data:\\n\");\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"\\tcnt: %u\\n\",\n\t\t      il->rx_stats.data_cnt);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"\\tbytes: %llu\\n\",\n\t\t      il->rx_stats.data_bytes);\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n\tkfree(buf);\n\treturn ret;\n}\n\n#define BYTE1_MASK 0x000000ff;\n#define BYTE2_MASK 0x0000ffff;\n#define BYTE3_MASK 0x00ffffff;\nstatic ssize_t\nil_dbgfs_sram_read(struct file *file, char __user *user_buf, size_t count,\n\t\t   loff_t *ppos)\n{\n\tu32 val;\n\tchar *buf;\n\tssize_t ret;\n\tint i;\n\tint pos = 0;\n\tstruct il_priv *il = file->private_data;\n\tsize_t bufsz;\n\n\t \n\tif (!il->dbgfs_sram_offset && !il->dbgfs_sram_len) {\n\t\til->dbgfs_sram_offset = 0x800000;\n\t\tif (il->ucode_type == UCODE_INIT)\n\t\t\til->dbgfs_sram_len = il->ucode_init_data.len;\n\t\telse\n\t\t\til->dbgfs_sram_len = il->ucode_data.len;\n\t}\n\tbufsz = 30 + il->dbgfs_sram_len * sizeof(char) * 10;\n\tbuf = kmalloc(bufsz, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"sram_len: 0x%x\\n\",\n\t\t      il->dbgfs_sram_len);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"sram_offset: 0x%x\\n\",\n\t\t      il->dbgfs_sram_offset);\n\tfor (i = il->dbgfs_sram_len; i > 0; i -= 4) {\n\t\tval =\n\t\t    il_read_targ_mem(il,\n\t\t\t\t     il->dbgfs_sram_offset +\n\t\t\t\t     il->dbgfs_sram_len - i);\n\t\tif (i < 4) {\n\t\t\tswitch (i) {\n\t\t\tcase 1:\n\t\t\t\tval &= BYTE1_MASK;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tval &= BYTE2_MASK;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tval &= BYTE3_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!(i % 16))\n\t\t\tpos += scnprintf(buf + pos, bufsz - pos, \"\\n\");\n\t\tpos += scnprintf(buf + pos, bufsz - pos, \"0x%08x \", val);\n\t}\n\tpos += scnprintf(buf + pos, bufsz - pos, \"\\n\");\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic ssize_t\nil_dbgfs_sram_write(struct file *file, const char __user *user_buf,\n\t\t    size_t count, loff_t *ppos)\n{\n\tstruct il_priv *il = file->private_data;\n\tchar buf[64];\n\tint buf_size;\n\tu32 offset, len;\n\n\tmemset(buf, 0, sizeof(buf));\n\tbuf_size = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\n\tif (sscanf(buf, \"%x,%x\", &offset, &len) == 2) {\n\t\til->dbgfs_sram_offset = offset;\n\t\til->dbgfs_sram_len = len;\n\t} else {\n\t\til->dbgfs_sram_offset = 0;\n\t\til->dbgfs_sram_len = 0;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t\nil_dbgfs_stations_read(struct file *file, char __user *user_buf, size_t count,\n\t\t       loff_t *ppos)\n{\n\tstruct il_priv *il = file->private_data;\n\tstruct il_station_entry *station;\n\tint max_sta = il->hw_params.max_stations;\n\tchar *buf;\n\tint i, j, pos = 0;\n\tssize_t ret;\n\t \n\tconst size_t bufsz = 30 + sizeof(char) * 500 * (il->num_stations);\n\n\tbuf = kmalloc(bufsz, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"num of stations: %d\\n\\n\",\n\t\t      il->num_stations);\n\n\tfor (i = 0; i < max_sta; i++) {\n\t\tstation = &il->stations[i];\n\t\tif (!station->used)\n\t\t\tcontinue;\n\t\tpos +=\n\t\t    scnprintf(buf + pos, bufsz - pos,\n\t\t\t      \"station %d - addr: %pM, flags: %#x\\n\", i,\n\t\t\t      station->sta.sta.addr,\n\t\t\t      station->sta.station_flags_msk);\n\t\tpos +=\n\t\t    scnprintf(buf + pos, bufsz - pos,\n\t\t\t      \"TID\\tseq_num\\ttxq_id\\tframes\\ttfds\\t\");\n\t\tpos +=\n\t\t    scnprintf(buf + pos, bufsz - pos,\n\t\t\t      \"start_idx\\tbitmap\\t\\t\\trate_n_flags\\n\");\n\n\t\tfor (j = 0; j < MAX_TID_COUNT; j++) {\n\t\t\tpos +=\n\t\t\t    scnprintf(buf + pos, bufsz - pos,\n\t\t\t\t      \"%d:\\t%#x\\t%#x\\t%u\\t%u\\t%u\\t\\t%#.16llx\\t%#x\",\n\t\t\t\t      j, station->tid[j].seq_number,\n\t\t\t\t      station->tid[j].agg.txq_id,\n\t\t\t\t      station->tid[j].agg.frame_count,\n\t\t\t\t      station->tid[j].tfds_in_queue,\n\t\t\t\t      station->tid[j].agg.start_idx,\n\t\t\t\t      station->tid[j].agg.bitmap,\n\t\t\t\t      station->tid[j].agg.rate_n_flags);\n\n\t\t\tif (station->tid[j].agg.wait_for_ba)\n\t\t\t\tpos +=\n\t\t\t\t    scnprintf(buf + pos, bufsz - pos,\n\t\t\t\t\t      \" - waitforba\");\n\t\t\tpos += scnprintf(buf + pos, bufsz - pos, \"\\n\");\n\t\t}\n\n\t\tpos += scnprintf(buf + pos, bufsz - pos, \"\\n\");\n\t}\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic ssize_t\nil_dbgfs_nvm_read(struct file *file, char __user *user_buf, size_t count,\n\t\t  loff_t *ppos)\n{\n\tssize_t ret;\n\tstruct il_priv *il = file->private_data;\n\tint pos = 0, ofs = 0, buf_size = 0;\n\tconst u8 *ptr;\n\tchar *buf;\n\tu16 eeprom_ver;\n\tsize_t eeprom_len = il->cfg->eeprom_size;\n\tbuf_size = 4 * eeprom_len + 256;\n\n\tif (eeprom_len % 16) {\n\t\tIL_ERR(\"NVM size is not multiple of 16.\\n\");\n\t\treturn -ENODATA;\n\t}\n\n\tptr = il->eeprom;\n\tif (!ptr) {\n\t\tIL_ERR(\"Invalid EEPROM memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tbuf = kzalloc(buf_size, GFP_KERNEL);\n\tif (!buf) {\n\t\tIL_ERR(\"Can not allocate Buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\teeprom_ver = il_eeprom_query16(il, EEPROM_VERSION);\n\tpos +=\n\t    scnprintf(buf + pos, buf_size - pos, \"EEPROM \" \"version: 0x%x\\n\",\n\t\t      eeprom_ver);\n\tfor (ofs = 0; ofs < eeprom_len; ofs += 16) {\n\t\tpos += scnprintf(buf + pos, buf_size - pos, \"0x%.4x %16ph\\n\",\n\t\t\t\t ofs, ptr + ofs);\n\t}\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic ssize_t\nil_dbgfs_channels_read(struct file *file, char __user *user_buf, size_t count,\n\t\t       loff_t *ppos)\n{\n\tstruct il_priv *il = file->private_data;\n\tstruct ieee80211_channel *channels = NULL;\n\tconst struct ieee80211_supported_band *supp_band = NULL;\n\tint pos = 0, i, bufsz = PAGE_SIZE;\n\tchar *buf;\n\tssize_t ret;\n\n\tif (!test_bit(S_GEO_CONFIGURED, &il->status))\n\t\treturn -EAGAIN;\n\n\tbuf = kzalloc(bufsz, GFP_KERNEL);\n\tif (!buf) {\n\t\tIL_ERR(\"Can not allocate Buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsupp_band = il_get_hw_mode(il, NL80211_BAND_2GHZ);\n\tif (supp_band) {\n\t\tchannels = supp_band->channels;\n\n\t\tpos +=\n\t\t    scnprintf(buf + pos, bufsz - pos,\n\t\t\t      \"Displaying %d channels in 2.4GHz band 802.11bg):\\n\",\n\t\t\t      supp_band->n_channels);\n\n\t\tfor (i = 0; i < supp_band->n_channels; i++)\n\t\t\tpos +=\n\t\t\t    scnprintf(buf + pos, bufsz - pos,\n\t\t\t\t      \"%d: %ddBm: BSS%s%s, %s.\\n\",\n\t\t\t\t      channels[i].hw_value,\n\t\t\t\t      channels[i].max_power,\n\t\t\t\t      channels[i].\n\t\t\t\t      flags & IEEE80211_CHAN_RADAR ?\n\t\t\t\t      \" (IEEE 802.11h required)\" : \"\",\n\t\t\t\t      ((channels[i].\n\t\t\t\t\tflags & IEEE80211_CHAN_NO_IR) ||\n\t\t\t\t       (channels[i].\n\t\t\t\t\tflags & IEEE80211_CHAN_RADAR)) ? \"\" :\n\t\t\t\t      \", IBSS\",\n\t\t\t\t      channels[i].\n\t\t\t\t      flags & IEEE80211_CHAN_NO_IR ?\n\t\t\t\t      \"passive only\" : \"active/passive\");\n\t}\n\tsupp_band = il_get_hw_mode(il, NL80211_BAND_5GHZ);\n\tif (supp_band) {\n\t\tchannels = supp_band->channels;\n\n\t\tpos +=\n\t\t    scnprintf(buf + pos, bufsz - pos,\n\t\t\t      \"Displaying %d channels in 5.2GHz band (802.11a)\\n\",\n\t\t\t      supp_band->n_channels);\n\n\t\tfor (i = 0; i < supp_band->n_channels; i++)\n\t\t\tpos +=\n\t\t\t    scnprintf(buf + pos, bufsz - pos,\n\t\t\t\t      \"%d: %ddBm: BSS%s%s, %s.\\n\",\n\t\t\t\t      channels[i].hw_value,\n\t\t\t\t      channels[i].max_power,\n\t\t\t\t      channels[i].\n\t\t\t\t      flags & IEEE80211_CHAN_RADAR ?\n\t\t\t\t      \" (IEEE 802.11h required)\" : \"\",\n\t\t\t\t      ((channels[i].\n\t\t\t\t\tflags & IEEE80211_CHAN_NO_IR) ||\n\t\t\t\t       (channels[i].\n\t\t\t\t\tflags & IEEE80211_CHAN_RADAR)) ? \"\" :\n\t\t\t\t      \", IBSS\",\n\t\t\t\t      channels[i].\n\t\t\t\t      flags & IEEE80211_CHAN_NO_IR ?\n\t\t\t\t      \"passive only\" : \"active/passive\");\n\t}\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic ssize_t\nil_dbgfs_status_read(struct file *file, char __user *user_buf, size_t count,\n\t\t     loff_t *ppos)\n{\n\n\tstruct il_priv *il = file->private_data;\n\tchar buf[512];\n\tint pos = 0;\n\tconst size_t bufsz = sizeof(buf);\n\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"S_HCMD_ACTIVE:\\t %d\\n\",\n\t\t      test_bit(S_HCMD_ACTIVE, &il->status));\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"S_INT_ENABLED:\\t %d\\n\",\n\t\t      test_bit(S_INT_ENABLED, &il->status));\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"S_RFKILL:\\t %d\\n\",\n\t\t      test_bit(S_RFKILL, &il->status));\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"S_CT_KILL:\\t\\t %d\\n\",\n\t\t      test_bit(S_CT_KILL, &il->status));\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"S_INIT:\\t\\t %d\\n\",\n\t\t      test_bit(S_INIT, &il->status));\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"S_ALIVE:\\t\\t %d\\n\",\n\t\t      test_bit(S_ALIVE, &il->status));\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"S_READY:\\t\\t %d\\n\",\n\t\t      test_bit(S_READY, &il->status));\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"S_TEMPERATURE:\\t %d\\n\",\n\t\t      test_bit(S_TEMPERATURE, &il->status));\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"S_GEO_CONFIGURED:\\t %d\\n\",\n\t\t      test_bit(S_GEO_CONFIGURED, &il->status));\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"S_EXIT_PENDING:\\t %d\\n\",\n\t\t      test_bit(S_EXIT_PENDING, &il->status));\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"S_STATS:\\t %d\\n\",\n\t\t      test_bit(S_STATS, &il->status));\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"S_SCANNING:\\t %d\\n\",\n\t\t      test_bit(S_SCANNING, &il->status));\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"S_SCAN_ABORTING:\\t %d\\n\",\n\t\t      test_bit(S_SCAN_ABORTING, &il->status));\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"S_SCAN_HW:\\t\\t %d\\n\",\n\t\t      test_bit(S_SCAN_HW, &il->status));\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"S_POWER_PMI:\\t %d\\n\",\n\t\t      test_bit(S_POWER_PMI, &il->status));\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"S_FW_ERROR:\\t %d\\n\",\n\t\t      test_bit(S_FW_ERROR, &il->status));\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\nstatic ssize_t\nil_dbgfs_interrupt_read(struct file *file, char __user *user_buf, size_t count,\n\t\t\tloff_t *ppos)\n{\n\n\tstruct il_priv *il = file->private_data;\n\tint pos = 0;\n\tint cnt = 0;\n\tchar *buf;\n\tint bufsz = 24 * 64;\t \n\tssize_t ret;\n\n\tbuf = kzalloc(bufsz, GFP_KERNEL);\n\tif (!buf) {\n\t\tIL_ERR(\"Can not allocate Buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"Interrupt Statistics Report:\\n\");\n\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"HW Error:\\t\\t\\t %u\\n\",\n\t\t      il->isr_stats.hw);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"SW Error:\\t\\t\\t %u\\n\",\n\t\t      il->isr_stats.sw);\n\tif (il->isr_stats.sw || il->isr_stats.hw) {\n\t\tpos +=\n\t\t    scnprintf(buf + pos, bufsz - pos,\n\t\t\t      \"\\tLast Restarting Code:  0x%X\\n\",\n\t\t\t      il->isr_stats.err_code);\n\t}\n#ifdef CONFIG_IWLEGACY_DEBUG\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"Frame transmitted:\\t\\t %u\\n\",\n\t\t      il->isr_stats.sch);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"Alive interrupt:\\t\\t %u\\n\",\n\t\t      il->isr_stats.alive);\n#endif\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos,\n\t\t      \"HW RF KILL switch toggled:\\t %u\\n\",\n\t\t      il->isr_stats.rfkill);\n\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"CT KILL:\\t\\t\\t %u\\n\",\n\t\t      il->isr_stats.ctkill);\n\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"Wakeup Interrupt:\\t\\t %u\\n\",\n\t\t      il->isr_stats.wakeup);\n\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"Rx command responses:\\t\\t %u\\n\",\n\t\t      il->isr_stats.rx);\n\tfor (cnt = 0; cnt < IL_CN_MAX; cnt++) {\n\t\tif (il->isr_stats.handlers[cnt] > 0)\n\t\t\tpos +=\n\t\t\t    scnprintf(buf + pos, bufsz - pos,\n\t\t\t\t      \"\\tRx handler[%36s]:\\t\\t %u\\n\",\n\t\t\t\t      il_get_cmd_string(cnt),\n\t\t\t\t      il->isr_stats.handlers[cnt]);\n\t}\n\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"Tx/FH interrupt:\\t\\t %u\\n\",\n\t\t      il->isr_stats.tx);\n\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"Unexpected INTA:\\t\\t %u\\n\",\n\t\t      il->isr_stats.unhandled);\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic ssize_t\nil_dbgfs_interrupt_write(struct file *file, const char __user *user_buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct il_priv *il = file->private_data;\n\tchar buf[8];\n\tint buf_size;\n\tu32 reset_flag;\n\n\tmemset(buf, 0, sizeof(buf));\n\tbuf_size = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\tif (sscanf(buf, \"%x\", &reset_flag) != 1)\n\t\treturn -EFAULT;\n\tif (reset_flag == 0)\n\t\til_clear_isr_stats(il);\n\n\treturn count;\n}\n\nstatic ssize_t\nil_dbgfs_qos_read(struct file *file, char __user *user_buf, size_t count,\n\t\t  loff_t *ppos)\n{\n\tstruct il_priv *il = file->private_data;\n\tint pos = 0, i;\n\tchar buf[256];\n\tconst size_t bufsz = sizeof(buf);\n\n\tfor (i = 0; i < AC_NUM; i++) {\n\t\tpos +=\n\t\t    scnprintf(buf + pos, bufsz - pos,\n\t\t\t      \"\\tcw_min\\tcw_max\\taifsn\\ttxop\\n\");\n\t\tpos +=\n\t\t    scnprintf(buf + pos, bufsz - pos,\n\t\t\t      \"AC[%d]\\t%u\\t%u\\t%u\\t%u\\n\", i,\n\t\t\t      il->qos_data.def_qos_parm.ac[i].cw_min,\n\t\t\t      il->qos_data.def_qos_parm.ac[i].cw_max,\n\t\t\t      il->qos_data.def_qos_parm.ac[i].aifsn,\n\t\t\t      il->qos_data.def_qos_parm.ac[i].edca_txop);\n\t}\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\nstatic ssize_t\nil_dbgfs_disable_ht40_write(struct file *file, const char __user *user_buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct il_priv *il = file->private_data;\n\tchar buf[8];\n\tint buf_size;\n\tint ht40;\n\n\tmemset(buf, 0, sizeof(buf));\n\tbuf_size = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\tif (sscanf(buf, \"%d\", &ht40) != 1)\n\t\treturn -EFAULT;\n\tif (!il_is_any_associated(il))\n\t\til->disable_ht40 = ht40 ? true : false;\n\telse {\n\t\tIL_ERR(\"Sta associated with AP - \"\n\t\t       \"Change to 40MHz channel support is not allowed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t\nil_dbgfs_disable_ht40_read(struct file *file, char __user *user_buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct il_priv *il = file->private_data;\n\tchar buf[100];\n\tint pos = 0;\n\tconst size_t bufsz = sizeof(buf);\n\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"11n 40MHz Mode: %s\\n\",\n\t\t      il->disable_ht40 ? \"Disabled\" : \"Enabled\");\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\nDEBUGFS_READ_WRITE_FILE_OPS(sram);\nDEBUGFS_READ_FILE_OPS(nvm);\nDEBUGFS_READ_FILE_OPS(stations);\nDEBUGFS_READ_FILE_OPS(channels);\nDEBUGFS_READ_FILE_OPS(status);\nDEBUGFS_READ_WRITE_FILE_OPS(interrupt);\nDEBUGFS_READ_FILE_OPS(qos);\nDEBUGFS_READ_WRITE_FILE_OPS(disable_ht40);\n\nstatic ssize_t\nil_dbgfs_tx_queue_read(struct file *file, char __user *user_buf, size_t count,\n\t\t       loff_t *ppos)\n{\n\n\tstruct il_priv *il = file->private_data;\n\tstruct il_tx_queue *txq;\n\tstruct il_queue *q;\n\tchar *buf;\n\tint pos = 0;\n\tint cnt;\n\tint ret;\n\tconst size_t bufsz =\n\t    sizeof(char) * 64 * il->cfg->num_of_queues;\n\n\tif (!il->txq) {\n\t\tIL_ERR(\"txq not ready\\n\");\n\t\treturn -EAGAIN;\n\t}\n\tbuf = kzalloc(bufsz, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tfor (cnt = 0; cnt < il->hw_params.max_txq_num; cnt++) {\n\t\ttxq = &il->txq[cnt];\n\t\tq = &txq->q;\n\t\tpos +=\n\t\t    scnprintf(buf + pos, bufsz - pos,\n\t\t\t      \"hwq %.2d: read=%u write=%u stop=%d\"\n\t\t\t      \" swq_id=%#.2x (ac %d/hwq %d)\\n\", cnt,\n\t\t\t      q->read_ptr, q->write_ptr,\n\t\t\t      !!test_bit(cnt, il->queue_stopped),\n\t\t\t      txq->swq_id, txq->swq_id & 3,\n\t\t\t      (txq->swq_id >> 2) & 0x1f);\n\t\tif (cnt >= 4)\n\t\t\tcontinue;\n\t\t \n\t\tpos +=\n\t\t    scnprintf(buf + pos, bufsz - pos,\n\t\t\t      \"        stop-count: %d\\n\",\n\t\t\t      atomic_read(&il->queue_stop_count[cnt]));\n\t}\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic ssize_t\nil_dbgfs_rx_queue_read(struct file *file, char __user *user_buf, size_t count,\n\t\t       loff_t *ppos)\n{\n\n\tstruct il_priv *il = file->private_data;\n\tstruct il_rx_queue *rxq = &il->rxq;\n\tchar buf[256];\n\tint pos = 0;\n\tconst size_t bufsz = sizeof(buf);\n\n\tpos += scnprintf(buf + pos, bufsz - pos, \"read: %u\\n\", rxq->read);\n\tpos += scnprintf(buf + pos, bufsz - pos, \"write: %u\\n\", rxq->write);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"free_count: %u\\n\",\n\t\t      rxq->free_count);\n\tif (rxq->rb_stts) {\n\t\tpos +=\n\t\t    scnprintf(buf + pos, bufsz - pos, \"closed_rb_num: %u\\n\",\n\t\t\t      le16_to_cpu(rxq->rb_stts->\n\t\t\t\t\t  closed_rb_num) & 0x0FFF);\n\t} else {\n\t\tpos +=\n\t\t    scnprintf(buf + pos, bufsz - pos,\n\t\t\t      \"closed_rb_num: Not Allocated\\n\");\n\t}\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\nstatic ssize_t\nil_dbgfs_ucode_rx_stats_read(struct file *file, char __user *user_buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct il_priv *il = file->private_data;\n\n\treturn il->debugfs_ops->rx_stats_read(file, user_buf, count, ppos);\n}\n\nstatic ssize_t\nil_dbgfs_ucode_tx_stats_read(struct file *file, char __user *user_buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct il_priv *il = file->private_data;\n\n\treturn il->debugfs_ops->tx_stats_read(file, user_buf, count, ppos);\n}\n\nstatic ssize_t\nil_dbgfs_ucode_general_stats_read(struct file *file, char __user *user_buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct il_priv *il = file->private_data;\n\n\treturn il->debugfs_ops->general_stats_read(file, user_buf, count, ppos);\n}\n\nstatic ssize_t\nil_dbgfs_sensitivity_read(struct file *file, char __user *user_buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\n\tstruct il_priv *il = file->private_data;\n\tint pos = 0;\n\tint cnt = 0;\n\tchar *buf;\n\tint bufsz = sizeof(struct il_sensitivity_data) * 4 + 100;\n\tssize_t ret;\n\tstruct il_sensitivity_data *data;\n\n\tdata = &il->sensitivity_data;\n\tbuf = kzalloc(bufsz, GFP_KERNEL);\n\tif (!buf) {\n\t\tIL_ERR(\"Can not allocate Buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"auto_corr_ofdm:\\t\\t\\t %u\\n\",\n\t\t      data->auto_corr_ofdm);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"auto_corr_ofdm_mrc:\\t\\t %u\\n\",\n\t\t      data->auto_corr_ofdm_mrc);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"auto_corr_ofdm_x1:\\t\\t %u\\n\",\n\t\t      data->auto_corr_ofdm_x1);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"auto_corr_ofdm_mrc_x1:\\t\\t %u\\n\",\n\t\t      data->auto_corr_ofdm_mrc_x1);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"auto_corr_cck:\\t\\t\\t %u\\n\",\n\t\t      data->auto_corr_cck);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"auto_corr_cck_mrc:\\t\\t %u\\n\",\n\t\t      data->auto_corr_cck_mrc);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos,\n\t\t      \"last_bad_plcp_cnt_ofdm:\\t\\t %u\\n\",\n\t\t      data->last_bad_plcp_cnt_ofdm);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"last_fa_cnt_ofdm:\\t\\t %u\\n\",\n\t\t      data->last_fa_cnt_ofdm);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"last_bad_plcp_cnt_cck:\\t\\t %u\\n\",\n\t\t      data->last_bad_plcp_cnt_cck);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"last_fa_cnt_cck:\\t\\t %u\\n\",\n\t\t      data->last_fa_cnt_cck);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"nrg_curr_state:\\t\\t\\t %u\\n\",\n\t\t      data->nrg_curr_state);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"nrg_prev_state:\\t\\t\\t %u\\n\",\n\t\t      data->nrg_prev_state);\n\tpos += scnprintf(buf + pos, bufsz - pos, \"nrg_value:\\t\\t\\t\");\n\tfor (cnt = 0; cnt < 10; cnt++) {\n\t\tpos +=\n\t\t    scnprintf(buf + pos, bufsz - pos, \" %u\",\n\t\t\t      data->nrg_value[cnt]);\n\t}\n\tpos += scnprintf(buf + pos, bufsz - pos, \"\\n\");\n\tpos += scnprintf(buf + pos, bufsz - pos, \"nrg_silence_rssi:\\t\\t\");\n\tfor (cnt = 0; cnt < NRG_NUM_PREV_STAT_L; cnt++) {\n\t\tpos +=\n\t\t    scnprintf(buf + pos, bufsz - pos, \" %u\",\n\t\t\t      data->nrg_silence_rssi[cnt]);\n\t}\n\tpos += scnprintf(buf + pos, bufsz - pos, \"\\n\");\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"nrg_silence_ref:\\t\\t %u\\n\",\n\t\t      data->nrg_silence_ref);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"nrg_energy_idx:\\t\\t\\t %u\\n\",\n\t\t      data->nrg_energy_idx);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"nrg_silence_idx:\\t\\t %u\\n\",\n\t\t      data->nrg_silence_idx);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"nrg_th_cck:\\t\\t\\t %u\\n\",\n\t\t      data->nrg_th_cck);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos,\n\t\t      \"nrg_auto_corr_silence_diff:\\t %u\\n\",\n\t\t      data->nrg_auto_corr_silence_diff);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"num_in_cck_no_fa:\\t\\t %u\\n\",\n\t\t      data->num_in_cck_no_fa);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"nrg_th_ofdm:\\t\\t\\t %u\\n\",\n\t\t      data->nrg_th_ofdm);\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic ssize_t\nil_dbgfs_chain_noise_read(struct file *file, char __user *user_buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\n\tstruct il_priv *il = file->private_data;\n\tint pos = 0;\n\tint cnt = 0;\n\tchar *buf;\n\tint bufsz = sizeof(struct il_chain_noise_data) * 4 + 100;\n\tssize_t ret;\n\tstruct il_chain_noise_data *data;\n\n\tdata = &il->chain_noise_data;\n\tbuf = kzalloc(bufsz, GFP_KERNEL);\n\tif (!buf) {\n\t\tIL_ERR(\"Can not allocate Buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"active_chains:\\t\\t\\t %u\\n\",\n\t\t      data->active_chains);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"chain_noise_a:\\t\\t\\t %u\\n\",\n\t\t      data->chain_noise_a);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"chain_noise_b:\\t\\t\\t %u\\n\",\n\t\t      data->chain_noise_b);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"chain_noise_c:\\t\\t\\t %u\\n\",\n\t\t      data->chain_noise_c);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"chain_signal_a:\\t\\t\\t %u\\n\",\n\t\t      data->chain_signal_a);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"chain_signal_b:\\t\\t\\t %u\\n\",\n\t\t      data->chain_signal_b);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"chain_signal_c:\\t\\t\\t %u\\n\",\n\t\t      data->chain_signal_c);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"beacon_count:\\t\\t\\t %u\\n\",\n\t\t      data->beacon_count);\n\n\tpos += scnprintf(buf + pos, bufsz - pos, \"disconn_array:\\t\\t\\t\");\n\tfor (cnt = 0; cnt < NUM_RX_CHAINS; cnt++) {\n\t\tpos +=\n\t\t    scnprintf(buf + pos, bufsz - pos, \" %u\",\n\t\t\t      data->disconn_array[cnt]);\n\t}\n\tpos += scnprintf(buf + pos, bufsz - pos, \"\\n\");\n\tpos += scnprintf(buf + pos, bufsz - pos, \"delta_gain_code:\\t\\t\");\n\tfor (cnt = 0; cnt < NUM_RX_CHAINS; cnt++) {\n\t\tpos +=\n\t\t    scnprintf(buf + pos, bufsz - pos, \" %u\",\n\t\t\t      data->delta_gain_code[cnt]);\n\t}\n\tpos += scnprintf(buf + pos, bufsz - pos, \"\\n\");\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"radio_write:\\t\\t\\t %u\\n\",\n\t\t      data->radio_write);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"state:\\t\\t\\t\\t %u\\n\",\n\t\t      data->state);\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic ssize_t\nil_dbgfs_power_save_status_read(struct file *file, char __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct il_priv *il = file->private_data;\n\tchar buf[60];\n\tint pos = 0;\n\tconst size_t bufsz = sizeof(buf);\n\tu32 pwrsave_status;\n\n\tpwrsave_status =\n\t    _il_rd(il, CSR_GP_CNTRL) & CSR_GP_REG_POWER_SAVE_STATUS_MSK;\n\n\tpos += scnprintf(buf + pos, bufsz - pos, \"Power Save Status: \");\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"%s\\n\",\n\t\t      (pwrsave_status == CSR_GP_REG_NO_POWER_SAVE) ? \"none\" :\n\t\t      (pwrsave_status == CSR_GP_REG_MAC_POWER_SAVE) ? \"MAC\" :\n\t\t      (pwrsave_status == CSR_GP_REG_PHY_POWER_SAVE) ? \"PHY\" :\n\t\t      \"error\");\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\nstatic ssize_t\nil_dbgfs_clear_ucode_stats_write(struct file *file,\n\t\t\t\t const char __user *user_buf, size_t count,\n\t\t\t\t loff_t *ppos)\n{\n\tstruct il_priv *il = file->private_data;\n\tchar buf[8];\n\tint buf_size;\n\tint clear;\n\n\tmemset(buf, 0, sizeof(buf));\n\tbuf_size = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\tif (sscanf(buf, \"%d\", &clear) != 1)\n\t\treturn -EFAULT;\n\n\t \n\tmutex_lock(&il->mutex);\n\til_send_stats_request(il, CMD_SYNC, true);\n\tmutex_unlock(&il->mutex);\n\n\treturn count;\n}\n\nstatic ssize_t\nil_dbgfs_rxon_flags_read(struct file *file, char __user *user_buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\n\tstruct il_priv *il = file->private_data;\n\tint len = 0;\n\tchar buf[20];\n\n\tlen = sprintf(buf, \"0x%04X\\n\", le32_to_cpu(il->active.flags));\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t\nil_dbgfs_rxon_filter_flags_read(struct file *file, char __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\n\tstruct il_priv *il = file->private_data;\n\tint len = 0;\n\tchar buf[20];\n\n\tlen =\n\t    sprintf(buf, \"0x%04X\\n\", le32_to_cpu(il->active.filter_flags));\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t\nil_dbgfs_fh_reg_read(struct file *file, char __user *user_buf, size_t count,\n\t\t     loff_t *ppos)\n{\n\tstruct il_priv *il = file->private_data;\n\tchar *buf;\n\tint pos = 0;\n\tssize_t ret = -EFAULT;\n\n\tif (il->ops->dump_fh) {\n\t\tret = pos = il->ops->dump_fh(il, &buf, true);\n\t\tif (buf) {\n\t\t\tret =\n\t\t\t    simple_read_from_buffer(user_buf, count, ppos, buf,\n\t\t\t\t\t\t    pos);\n\t\t\tkfree(buf);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t\nil_dbgfs_missed_beacon_read(struct file *file, char __user *user_buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\n\tstruct il_priv *il = file->private_data;\n\tint pos = 0;\n\tchar buf[12];\n\tconst size_t bufsz = sizeof(buf);\n\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"%d\\n\",\n\t\t      il->missed_beacon_threshold);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\nstatic ssize_t\nil_dbgfs_missed_beacon_write(struct file *file, const char __user *user_buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct il_priv *il = file->private_data;\n\tchar buf[8];\n\tint buf_size;\n\tint missed;\n\n\tmemset(buf, 0, sizeof(buf));\n\tbuf_size = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\tif (sscanf(buf, \"%d\", &missed) != 1)\n\t\treturn -EINVAL;\n\n\tif (missed < IL_MISSED_BEACON_THRESHOLD_MIN ||\n\t    missed > IL_MISSED_BEACON_THRESHOLD_MAX)\n\t\til->missed_beacon_threshold = IL_MISSED_BEACON_THRESHOLD_DEF;\n\telse\n\t\til->missed_beacon_threshold = missed;\n\n\treturn count;\n}\n\nstatic ssize_t\nil_dbgfs_force_reset_read(struct file *file, char __user *user_buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\n\tstruct il_priv *il = file->private_data;\n\tint pos = 0;\n\tchar buf[300];\n\tconst size_t bufsz = sizeof(buf);\n\tstruct il_force_reset *force_reset;\n\n\tforce_reset = &il->force_reset;\n\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"\\tnumber of reset request: %d\\n\",\n\t\t      force_reset->reset_request_count);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos,\n\t\t      \"\\tnumber of reset request success: %d\\n\",\n\t\t      force_reset->reset_success_count);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos,\n\t\t      \"\\tnumber of reset request reject: %d\\n\",\n\t\t      force_reset->reset_reject_count);\n\tpos +=\n\t    scnprintf(buf + pos, bufsz - pos, \"\\treset duration: %lu\\n\",\n\t\t      force_reset->reset_duration);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\nstatic ssize_t\nil_dbgfs_force_reset_write(struct file *file, const char __user *user_buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\n\tint ret;\n\tstruct il_priv *il = file->private_data;\n\n\tret = il_force_reset(il, true);\n\n\treturn ret ? ret : count;\n}\n\nstatic ssize_t\nil_dbgfs_wd_timeout_write(struct file *file, const char __user *user_buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\n\tstruct il_priv *il = file->private_data;\n\tchar buf[8];\n\tint buf_size;\n\tint timeout;\n\n\tmemset(buf, 0, sizeof(buf));\n\tbuf_size = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\tif (sscanf(buf, \"%d\", &timeout) != 1)\n\t\treturn -EINVAL;\n\tif (timeout < 0 || timeout > IL_MAX_WD_TIMEOUT)\n\t\ttimeout = IL_DEF_WD_TIMEOUT;\n\n\til->cfg->wd_timeout = timeout;\n\til_setup_watchdog(il);\n\treturn count;\n}\n\nDEBUGFS_READ_FILE_OPS(rx_stats);\nDEBUGFS_READ_FILE_OPS(tx_stats);\nDEBUGFS_READ_FILE_OPS(rx_queue);\nDEBUGFS_READ_FILE_OPS(tx_queue);\nDEBUGFS_READ_FILE_OPS(ucode_rx_stats);\nDEBUGFS_READ_FILE_OPS(ucode_tx_stats);\nDEBUGFS_READ_FILE_OPS(ucode_general_stats);\nDEBUGFS_READ_FILE_OPS(sensitivity);\nDEBUGFS_READ_FILE_OPS(chain_noise);\nDEBUGFS_READ_FILE_OPS(power_save_status);\nDEBUGFS_WRITE_FILE_OPS(clear_ucode_stats);\nDEBUGFS_WRITE_FILE_OPS(clear_traffic_stats);\nDEBUGFS_READ_FILE_OPS(fh_reg);\nDEBUGFS_READ_WRITE_FILE_OPS(missed_beacon);\nDEBUGFS_READ_WRITE_FILE_OPS(force_reset);\nDEBUGFS_READ_FILE_OPS(rxon_flags);\nDEBUGFS_READ_FILE_OPS(rxon_filter_flags);\nDEBUGFS_WRITE_FILE_OPS(wd_timeout);\n\n \nvoid\nil_dbgfs_register(struct il_priv *il, const char *name)\n{\n\tstruct dentry *phyd = il->hw->wiphy->debugfsdir;\n\tstruct dentry *dir_drv, *dir_data, *dir_rf, *dir_debug;\n\n\tdir_drv = debugfs_create_dir(name, phyd);\n\til->debugfs_dir = dir_drv;\n\n\tdir_data = debugfs_create_dir(\"data\", dir_drv);\n\tdir_rf = debugfs_create_dir(\"rf\", dir_drv);\n\tdir_debug = debugfs_create_dir(\"debug\", dir_drv);\n\n\tDEBUGFS_ADD_FILE(nvm, dir_data, 0400);\n\tDEBUGFS_ADD_FILE(sram, dir_data, 0600);\n\tDEBUGFS_ADD_FILE(stations, dir_data, 0400);\n\tDEBUGFS_ADD_FILE(channels, dir_data, 0400);\n\tDEBUGFS_ADD_FILE(status, dir_data, 0400);\n\tDEBUGFS_ADD_FILE(interrupt, dir_data, 0600);\n\tDEBUGFS_ADD_FILE(qos, dir_data, 0400);\n\tDEBUGFS_ADD_FILE(disable_ht40, dir_data, 0600);\n\tDEBUGFS_ADD_FILE(rx_stats, dir_debug, 0400);\n\tDEBUGFS_ADD_FILE(tx_stats, dir_debug, 0400);\n\tDEBUGFS_ADD_FILE(rx_queue, dir_debug, 0400);\n\tDEBUGFS_ADD_FILE(tx_queue, dir_debug, 0400);\n\tDEBUGFS_ADD_FILE(power_save_status, dir_debug, 0400);\n\tDEBUGFS_ADD_FILE(clear_ucode_stats, dir_debug, 0200);\n\tDEBUGFS_ADD_FILE(clear_traffic_stats, dir_debug, 0200);\n\tDEBUGFS_ADD_FILE(fh_reg, dir_debug, 0400);\n\tDEBUGFS_ADD_FILE(missed_beacon, dir_debug, 0200);\n\tDEBUGFS_ADD_FILE(force_reset, dir_debug, 0600);\n\tDEBUGFS_ADD_FILE(ucode_rx_stats, dir_debug, 0400);\n\tDEBUGFS_ADD_FILE(ucode_tx_stats, dir_debug, 0400);\n\tDEBUGFS_ADD_FILE(ucode_general_stats, dir_debug, 0400);\n\n\tif (il->cfg->sensitivity_calib_by_driver)\n\t\tDEBUGFS_ADD_FILE(sensitivity, dir_debug, 0400);\n\tif (il->cfg->chain_noise_calib_by_driver)\n\t\tDEBUGFS_ADD_FILE(chain_noise, dir_debug, 0400);\n\tDEBUGFS_ADD_FILE(rxon_flags, dir_debug, 0200);\n\tDEBUGFS_ADD_FILE(rxon_filter_flags, dir_debug, 0200);\n\tDEBUGFS_ADD_FILE(wd_timeout, dir_debug, 0200);\n\tif (il->cfg->sensitivity_calib_by_driver)\n\t\tDEBUGFS_ADD_BOOL(disable_sensitivity, dir_rf,\n\t\t\t\t &il->disable_sens_cal);\n\tif (il->cfg->chain_noise_calib_by_driver)\n\t\tDEBUGFS_ADD_BOOL(disable_chain_noise, dir_rf,\n\t\t\t\t &il->disable_chain_noise_cal);\n\tDEBUGFS_ADD_BOOL(disable_tx_power, dir_rf, &il->disable_tx_power_cal);\n}\nEXPORT_SYMBOL(il_dbgfs_register);\n\n \nvoid\nil_dbgfs_unregister(struct il_priv *il)\n{\n\tif (!il->debugfs_dir)\n\t\treturn;\n\n\tdebugfs_remove_recursive(il->debugfs_dir);\n\til->debugfs_dir = NULL;\n}\nEXPORT_SYMBOL(il_dbgfs_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}