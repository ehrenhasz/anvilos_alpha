{
  "module_name": "rt2500usb.c",
  "hash_id": "4cb3ef7493e4f0e64087048121c13380c148e73589939a08e2e9971ecd654981",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ralink/rt2x00/rt2500usb.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/delay.h>\n#include <linux/etherdevice.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n\n#include \"rt2x00.h\"\n#include \"rt2x00usb.h\"\n#include \"rt2500usb.h\"\n\n \nstatic bool modparam_nohwcrypt;\nmodule_param_named(nohwcrypt, modparam_nohwcrypt, bool, 0444);\nMODULE_PARM_DESC(nohwcrypt, \"Disable hardware encryption.\");\n\n \nstatic u16 rt2500usb_register_read(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t   const unsigned int offset)\n{\n\t__le16 reg;\n\trt2x00usb_vendor_request_buff(rt2x00dev, USB_MULTI_READ,\n\t\t\t\t      USB_VENDOR_REQUEST_IN, offset,\n\t\t\t\t      &reg, sizeof(reg));\n\treturn le16_to_cpu(reg);\n}\n\nstatic u16 rt2500usb_register_read_lock(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\tconst unsigned int offset)\n{\n\t__le16 reg;\n\trt2x00usb_vendor_req_buff_lock(rt2x00dev, USB_MULTI_READ,\n\t\t\t\t       USB_VENDOR_REQUEST_IN, offset,\n\t\t\t\t       &reg, sizeof(reg), REGISTER_TIMEOUT);\n\treturn le16_to_cpu(reg);\n}\n\nstatic void rt2500usb_register_write(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t    const unsigned int offset,\n\t\t\t\t\t    u16 value)\n{\n\t__le16 reg = cpu_to_le16(value);\n\trt2x00usb_vendor_request_buff(rt2x00dev, USB_MULTI_WRITE,\n\t\t\t\t      USB_VENDOR_REQUEST_OUT, offset,\n\t\t\t\t      &reg, sizeof(reg));\n}\n\nstatic void rt2500usb_register_write_lock(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t\t const unsigned int offset,\n\t\t\t\t\t\t u16 value)\n{\n\t__le16 reg = cpu_to_le16(value);\n\trt2x00usb_vendor_req_buff_lock(rt2x00dev, USB_MULTI_WRITE,\n\t\t\t\t       USB_VENDOR_REQUEST_OUT, offset,\n\t\t\t\t       &reg, sizeof(reg), REGISTER_TIMEOUT);\n}\n\nstatic void rt2500usb_register_multiwrite(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t\t const unsigned int offset,\n\t\t\t\t\t\t void *value, const u16 length)\n{\n\trt2x00usb_vendor_request_buff(rt2x00dev, USB_MULTI_WRITE,\n\t\t\t\t      USB_VENDOR_REQUEST_OUT, offset,\n\t\t\t\t      value, length);\n}\n\nstatic int rt2500usb_regbusy_read(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t  const unsigned int offset,\n\t\t\t\t  struct rt2x00_field16 field,\n\t\t\t\t  u16 *reg)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < REGISTER_USB_BUSY_COUNT; i++) {\n\t\t*reg = rt2500usb_register_read_lock(rt2x00dev, offset);\n\t\tif (!rt2x00_get_field16(*reg, field))\n\t\t\treturn 1;\n\t\tudelay(REGISTER_BUSY_DELAY);\n\t}\n\n\trt2x00_err(rt2x00dev, \"Indirect register access failed: offset=0x%.08x, value=0x%.08x\\n\",\n\t\t   offset, *reg);\n\t*reg = ~0;\n\n\treturn 0;\n}\n\n#define WAIT_FOR_BBP(__dev, __reg) \\\n\trt2500usb_regbusy_read((__dev), PHY_CSR8, PHY_CSR8_BUSY, (__reg))\n#define WAIT_FOR_RF(__dev, __reg) \\\n\trt2500usb_regbusy_read((__dev), PHY_CSR10, PHY_CSR10_RF_BUSY, (__reg))\n\nstatic void rt2500usb_bbp_write(struct rt2x00_dev *rt2x00dev,\n\t\t\t\tconst unsigned int word, const u8 value)\n{\n\tu16 reg;\n\n\tmutex_lock(&rt2x00dev->csr_mutex);\n\n\t \n\tif (WAIT_FOR_BBP(rt2x00dev, &reg)) {\n\t\treg = 0;\n\t\trt2x00_set_field16(&reg, PHY_CSR7_DATA, value);\n\t\trt2x00_set_field16(&reg, PHY_CSR7_REG_ID, word);\n\t\trt2x00_set_field16(&reg, PHY_CSR7_READ_CONTROL, 0);\n\n\t\trt2500usb_register_write_lock(rt2x00dev, PHY_CSR7, reg);\n\t}\n\n\tmutex_unlock(&rt2x00dev->csr_mutex);\n}\n\nstatic u8 rt2500usb_bbp_read(struct rt2x00_dev *rt2x00dev,\n\t\t\t     const unsigned int word)\n{\n\tu16 reg;\n\tu8 value;\n\n\tmutex_lock(&rt2x00dev->csr_mutex);\n\n\t \n\tif (WAIT_FOR_BBP(rt2x00dev, &reg)) {\n\t\treg = 0;\n\t\trt2x00_set_field16(&reg, PHY_CSR7_REG_ID, word);\n\t\trt2x00_set_field16(&reg, PHY_CSR7_READ_CONTROL, 1);\n\n\t\trt2500usb_register_write_lock(rt2x00dev, PHY_CSR7, reg);\n\n\t\tif (WAIT_FOR_BBP(rt2x00dev, &reg))\n\t\t\treg = rt2500usb_register_read_lock(rt2x00dev, PHY_CSR7);\n\t}\n\n\tvalue = rt2x00_get_field16(reg, PHY_CSR7_DATA);\n\n\tmutex_unlock(&rt2x00dev->csr_mutex);\n\n\treturn value;\n}\n\nstatic void rt2500usb_rf_write(struct rt2x00_dev *rt2x00dev,\n\t\t\t       const unsigned int word, const u32 value)\n{\n\tu16 reg;\n\n\tmutex_lock(&rt2x00dev->csr_mutex);\n\n\t \n\tif (WAIT_FOR_RF(rt2x00dev, &reg)) {\n\t\treg = 0;\n\t\trt2x00_set_field16(&reg, PHY_CSR9_RF_VALUE, value);\n\t\trt2500usb_register_write_lock(rt2x00dev, PHY_CSR9, reg);\n\n\t\treg = 0;\n\t\trt2x00_set_field16(&reg, PHY_CSR10_RF_VALUE, value >> 16);\n\t\trt2x00_set_field16(&reg, PHY_CSR10_RF_NUMBER_OF_BITS, 20);\n\t\trt2x00_set_field16(&reg, PHY_CSR10_RF_IF_SELECT, 0);\n\t\trt2x00_set_field16(&reg, PHY_CSR10_RF_BUSY, 1);\n\n\t\trt2500usb_register_write_lock(rt2x00dev, PHY_CSR10, reg);\n\t\trt2x00_rf_write(rt2x00dev, word, value);\n\t}\n\n\tmutex_unlock(&rt2x00dev->csr_mutex);\n}\n\n#ifdef CONFIG_RT2X00_LIB_DEBUGFS\nstatic u32 _rt2500usb_register_read(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t     const unsigned int offset)\n{\n\treturn rt2500usb_register_read(rt2x00dev, offset);\n}\n\nstatic void _rt2500usb_register_write(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t      const unsigned int offset,\n\t\t\t\t      u32 value)\n{\n\trt2500usb_register_write(rt2x00dev, offset, value);\n}\n\nstatic const struct rt2x00debug rt2500usb_rt2x00debug = {\n\t.owner\t= THIS_MODULE,\n\t.csr\t= {\n\t\t.read\t\t= _rt2500usb_register_read,\n\t\t.write\t\t= _rt2500usb_register_write,\n\t\t.flags\t\t= RT2X00DEBUGFS_OFFSET,\n\t\t.word_base\t= CSR_REG_BASE,\n\t\t.word_size\t= sizeof(u16),\n\t\t.word_count\t= CSR_REG_SIZE / sizeof(u16),\n\t},\n\t.eeprom\t= {\n\t\t.read\t\t= rt2x00_eeprom_read,\n\t\t.write\t\t= rt2x00_eeprom_write,\n\t\t.word_base\t= EEPROM_BASE,\n\t\t.word_size\t= sizeof(u16),\n\t\t.word_count\t= EEPROM_SIZE / sizeof(u16),\n\t},\n\t.bbp\t= {\n\t\t.read\t\t= rt2500usb_bbp_read,\n\t\t.write\t\t= rt2500usb_bbp_write,\n\t\t.word_base\t= BBP_BASE,\n\t\t.word_size\t= sizeof(u8),\n\t\t.word_count\t= BBP_SIZE / sizeof(u8),\n\t},\n\t.rf\t= {\n\t\t.read\t\t= rt2x00_rf_read,\n\t\t.write\t\t= rt2500usb_rf_write,\n\t\t.word_base\t= RF_BASE,\n\t\t.word_size\t= sizeof(u32),\n\t\t.word_count\t= RF_SIZE / sizeof(u32),\n\t},\n};\n#endif  \n\nstatic int rt2500usb_rfkill_poll(struct rt2x00_dev *rt2x00dev)\n{\n\tu16 reg;\n\n\treg = rt2500usb_register_read(rt2x00dev, MAC_CSR19);\n\treturn rt2x00_get_field16(reg, MAC_CSR19_VAL7);\n}\n\n#ifdef CONFIG_RT2X00_LIB_LEDS\nstatic void rt2500usb_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t     enum led_brightness brightness)\n{\n\tstruct rt2x00_led *led =\n\t    container_of(led_cdev, struct rt2x00_led, led_dev);\n\tunsigned int enabled = brightness != LED_OFF;\n\tu16 reg;\n\n\treg = rt2500usb_register_read(led->rt2x00dev, MAC_CSR20);\n\n\tif (led->type == LED_TYPE_RADIO || led->type == LED_TYPE_ASSOC)\n\t\trt2x00_set_field16(&reg, MAC_CSR20_LINK, enabled);\n\telse if (led->type == LED_TYPE_ACTIVITY)\n\t\trt2x00_set_field16(&reg, MAC_CSR20_ACTIVITY, enabled);\n\n\trt2500usb_register_write(led->rt2x00dev, MAC_CSR20, reg);\n}\n\nstatic int rt2500usb_blink_set(struct led_classdev *led_cdev,\n\t\t\t       unsigned long *delay_on,\n\t\t\t       unsigned long *delay_off)\n{\n\tstruct rt2x00_led *led =\n\t    container_of(led_cdev, struct rt2x00_led, led_dev);\n\tu16 reg;\n\n\treg = rt2500usb_register_read(led->rt2x00dev, MAC_CSR21);\n\trt2x00_set_field16(&reg, MAC_CSR21_ON_PERIOD, *delay_on);\n\trt2x00_set_field16(&reg, MAC_CSR21_OFF_PERIOD, *delay_off);\n\trt2500usb_register_write(led->rt2x00dev, MAC_CSR21, reg);\n\n\treturn 0;\n}\n\nstatic void rt2500usb_init_led(struct rt2x00_dev *rt2x00dev,\n\t\t\t       struct rt2x00_led *led,\n\t\t\t       enum led_type type)\n{\n\tled->rt2x00dev = rt2x00dev;\n\tled->type = type;\n\tled->led_dev.brightness_set = rt2500usb_brightness_set;\n\tled->led_dev.blink_set = rt2500usb_blink_set;\n\tled->flags = LED_INITIALIZED;\n}\n#endif  \n\n \n\n \nstatic int rt2500usb_config_key(struct rt2x00_dev *rt2x00dev,\n\t\t\t\tstruct rt2x00lib_crypto *crypto,\n\t\t\t\tstruct ieee80211_key_conf *key)\n{\n\tu32 mask;\n\tu16 reg;\n\tenum cipher curr_cipher;\n\n\tif (crypto->cmd == SET_KEY) {\n\t\t \n\t\tif ((key->cipher == WLAN_CIPHER_SUITE_WEP40 ||\n\t\t     key->cipher == WLAN_CIPHER_SUITE_WEP104) &&\n\t\t    key->keyidx != 0)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tmask = TXRX_CSR0_KEY_ID.bit_mask;\n\n\t\treg = rt2500usb_register_read(rt2x00dev, TXRX_CSR0);\n\t\tcurr_cipher = rt2x00_get_field16(reg, TXRX_CSR0_ALGORITHM);\n\t\treg &= mask;\n\n\t\tif (reg && reg == mask)\n\t\t\treturn -ENOSPC;\n\n\t\treg = rt2x00_get_field16(reg, TXRX_CSR0_KEY_ID);\n\n\t\tkey->hw_key_idx += reg ? ffz(reg) : 0;\n\t\t \n\t\tif (key->hw_key_idx > 0 && crypto->cipher != curr_cipher)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\trt2500usb_register_multiwrite(rt2x00dev, KEY_ENTRY(key->hw_key_idx),\n\t\t\t\t\t      crypto->key, sizeof(crypto->key));\n\n\t\t \n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;\n\t}\n\n\t \n\treg = rt2500usb_register_read(rt2x00dev, TXRX_CSR0);\n\trt2x00_set_field16(&reg, TXRX_CSR0_ALGORITHM, crypto->cipher);\n\trt2x00_set_field16(&reg, TXRX_CSR0_IV_OFFSET, IEEE80211_HEADER);\n\n\tmask = rt2x00_get_field16(reg, TXRX_CSR0_KEY_ID);\n\tif (crypto->cmd == SET_KEY)\n\t\tmask |= 1 << key->hw_key_idx;\n\telse if (crypto->cmd == DISABLE_KEY)\n\t\tmask &= ~(1 << key->hw_key_idx);\n\trt2x00_set_field16(&reg, TXRX_CSR0_KEY_ID, mask);\n\trt2500usb_register_write(rt2x00dev, TXRX_CSR0, reg);\n\n\treturn 0;\n}\n\nstatic void rt2500usb_config_filter(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t    const unsigned int filter_flags)\n{\n\tu16 reg;\n\n\t \n\treg = rt2500usb_register_read(rt2x00dev, TXRX_CSR2);\n\trt2x00_set_field16(&reg, TXRX_CSR2_DROP_CRC,\n\t\t\t   !(filter_flags & FIF_FCSFAIL));\n\trt2x00_set_field16(&reg, TXRX_CSR2_DROP_PHYSICAL,\n\t\t\t   !(filter_flags & FIF_PLCPFAIL));\n\trt2x00_set_field16(&reg, TXRX_CSR2_DROP_CONTROL,\n\t\t\t   !(filter_flags & FIF_CONTROL));\n\trt2x00_set_field16(&reg, TXRX_CSR2_DROP_NOT_TO_ME,\n\t\t\t   !test_bit(CONFIG_MONITORING, &rt2x00dev->flags));\n\trt2x00_set_field16(&reg, TXRX_CSR2_DROP_TODS,\n\t\t\t   !test_bit(CONFIG_MONITORING, &rt2x00dev->flags) &&\n\t\t\t   !rt2x00dev->intf_ap_count);\n\trt2x00_set_field16(&reg, TXRX_CSR2_DROP_VERSION_ERROR, 1);\n\trt2x00_set_field16(&reg, TXRX_CSR2_DROP_MULTICAST,\n\t\t\t   !(filter_flags & FIF_ALLMULTI));\n\trt2x00_set_field16(&reg, TXRX_CSR2_DROP_BROADCAST, 0);\n\trt2500usb_register_write(rt2x00dev, TXRX_CSR2, reg);\n}\n\nstatic void rt2500usb_config_intf(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t  struct rt2x00_intf *intf,\n\t\t\t\t  struct rt2x00intf_conf *conf,\n\t\t\t\t  const unsigned int flags)\n{\n\tunsigned int bcn_preload;\n\tu16 reg;\n\n\tif (flags & CONFIG_UPDATE_TYPE) {\n\t\t \n\t\tbcn_preload = PREAMBLE + GET_DURATION(IEEE80211_HEADER, 20);\n\t\treg = rt2500usb_register_read(rt2x00dev, TXRX_CSR20);\n\t\trt2x00_set_field16(&reg, TXRX_CSR20_OFFSET, bcn_preload >> 6);\n\t\trt2x00_set_field16(&reg, TXRX_CSR20_BCN_EXPECT_WINDOW,\n\t\t\t\t   2 * (conf->type != NL80211_IFTYPE_STATION));\n\t\trt2500usb_register_write(rt2x00dev, TXRX_CSR20, reg);\n\n\t\t \n\t\treg = rt2500usb_register_read(rt2x00dev, TXRX_CSR18);\n\t\trt2x00_set_field16(&reg, TXRX_CSR18_OFFSET, 0);\n\t\trt2500usb_register_write(rt2x00dev, TXRX_CSR18, reg);\n\n\t\treg = rt2500usb_register_read(rt2x00dev, TXRX_CSR19);\n\t\trt2x00_set_field16(&reg, TXRX_CSR19_TSF_SYNC, conf->sync);\n\t\trt2500usb_register_write(rt2x00dev, TXRX_CSR19, reg);\n\t}\n\n\tif (flags & CONFIG_UPDATE_MAC)\n\t\trt2500usb_register_multiwrite(rt2x00dev, MAC_CSR2, conf->mac,\n\t\t\t\t\t      (3 * sizeof(__le16)));\n\n\tif (flags & CONFIG_UPDATE_BSSID)\n\t\trt2500usb_register_multiwrite(rt2x00dev, MAC_CSR5, conf->bssid,\n\t\t\t\t\t      (3 * sizeof(__le16)));\n}\n\nstatic void rt2500usb_config_erp(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t struct rt2x00lib_erp *erp,\n\t\t\t\t u32 changed)\n{\n\tu16 reg;\n\n\tif (changed & BSS_CHANGED_ERP_PREAMBLE) {\n\t\treg = rt2500usb_register_read(rt2x00dev, TXRX_CSR10);\n\t\trt2x00_set_field16(&reg, TXRX_CSR10_AUTORESPOND_PREAMBLE,\n\t\t\t\t   !!erp->short_preamble);\n\t\trt2500usb_register_write(rt2x00dev, TXRX_CSR10, reg);\n\t}\n\n\tif (changed & BSS_CHANGED_BASIC_RATES)\n\t\trt2500usb_register_write(rt2x00dev, TXRX_CSR11,\n\t\t\t\t\t erp->basic_rates);\n\n\tif (changed & BSS_CHANGED_BEACON_INT) {\n\t\treg = rt2500usb_register_read(rt2x00dev, TXRX_CSR18);\n\t\trt2x00_set_field16(&reg, TXRX_CSR18_INTERVAL,\n\t\t\t\t   erp->beacon_int * 4);\n\t\trt2500usb_register_write(rt2x00dev, TXRX_CSR18, reg);\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\trt2500usb_register_write(rt2x00dev, MAC_CSR10, erp->slot_time);\n\t\trt2500usb_register_write(rt2x00dev, MAC_CSR11, erp->sifs);\n\t\trt2500usb_register_write(rt2x00dev, MAC_CSR12, erp->eifs);\n\t}\n}\n\nstatic void rt2500usb_config_ant(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t struct antenna_setup *ant)\n{\n\tu8 r2;\n\tu8 r14;\n\tu16 csr5;\n\tu16 csr6;\n\n\t \n\tBUG_ON(ant->rx == ANTENNA_SW_DIVERSITY ||\n\t       ant->tx == ANTENNA_SW_DIVERSITY);\n\n\tr2 = rt2500usb_bbp_read(rt2x00dev, 2);\n\tr14 = rt2500usb_bbp_read(rt2x00dev, 14);\n\tcsr5 = rt2500usb_register_read(rt2x00dev, PHY_CSR5);\n\tcsr6 = rt2500usb_register_read(rt2x00dev, PHY_CSR6);\n\n\t \n\tswitch (ant->tx) {\n\tcase ANTENNA_HW_DIVERSITY:\n\t\trt2x00_set_field8(&r2, BBP_R2_TX_ANTENNA, 1);\n\t\trt2x00_set_field16(&csr5, PHY_CSR5_CCK, 1);\n\t\trt2x00_set_field16(&csr6, PHY_CSR6_OFDM, 1);\n\t\tbreak;\n\tcase ANTENNA_A:\n\t\trt2x00_set_field8(&r2, BBP_R2_TX_ANTENNA, 0);\n\t\trt2x00_set_field16(&csr5, PHY_CSR5_CCK, 0);\n\t\trt2x00_set_field16(&csr6, PHY_CSR6_OFDM, 0);\n\t\tbreak;\n\tcase ANTENNA_B:\n\tdefault:\n\t\trt2x00_set_field8(&r2, BBP_R2_TX_ANTENNA, 2);\n\t\trt2x00_set_field16(&csr5, PHY_CSR5_CCK, 2);\n\t\trt2x00_set_field16(&csr6, PHY_CSR6_OFDM, 2);\n\t\tbreak;\n\t}\n\n\t \n\tswitch (ant->rx) {\n\tcase ANTENNA_HW_DIVERSITY:\n\t\trt2x00_set_field8(&r14, BBP_R14_RX_ANTENNA, 1);\n\t\tbreak;\n\tcase ANTENNA_A:\n\t\trt2x00_set_field8(&r14, BBP_R14_RX_ANTENNA, 0);\n\t\tbreak;\n\tcase ANTENNA_B:\n\tdefault:\n\t\trt2x00_set_field8(&r14, BBP_R14_RX_ANTENNA, 2);\n\t\tbreak;\n\t}\n\n\t \n\tif (rt2x00_rf(rt2x00dev, RF2525E) || rt2x00_rf(rt2x00dev, RF5222)) {\n\t\trt2x00_set_field8(&r2, BBP_R2_TX_IQ_FLIP, 1);\n\t\trt2x00_set_field16(&csr5, PHY_CSR5_CCK_FLIP, 1);\n\t\trt2x00_set_field16(&csr6, PHY_CSR6_OFDM_FLIP, 1);\n\n\t\t \n\t\tif (rt2x00_rf(rt2x00dev, RF2525E))\n\t\t\trt2x00_set_field8(&r14, BBP_R14_RX_IQ_FLIP, 0);\n\t} else {\n\t\trt2x00_set_field16(&csr5, PHY_CSR5_CCK_FLIP, 0);\n\t\trt2x00_set_field16(&csr6, PHY_CSR6_OFDM_FLIP, 0);\n\t}\n\n\trt2500usb_bbp_write(rt2x00dev, 2, r2);\n\trt2500usb_bbp_write(rt2x00dev, 14, r14);\n\trt2500usb_register_write(rt2x00dev, PHY_CSR5, csr5);\n\trt2500usb_register_write(rt2x00dev, PHY_CSR6, csr6);\n}\n\nstatic void rt2500usb_config_channel(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t     struct rf_channel *rf, const int txpower)\n{\n\t \n\trt2x00_set_field32(&rf->rf3, RF3_TXPOWER, TXPOWER_TO_DEV(txpower));\n\n\t \n\tif (rt2x00_rf(rt2x00dev, RF2525E)) {\n\t\tstatic const u32 vals[] = {\n\t\t\t0x000008aa, 0x000008ae, 0x000008ae, 0x000008b2,\n\t\t\t0x000008b2, 0x000008b6, 0x000008b6, 0x000008ba,\n\t\t\t0x000008ba, 0x000008be, 0x000008b7, 0x00000902,\n\t\t\t0x00000902, 0x00000906\n\t\t};\n\n\t\trt2500usb_rf_write(rt2x00dev, 2, vals[rf->channel - 1]);\n\t\tif (rf->rf4)\n\t\t\trt2500usb_rf_write(rt2x00dev, 4, rf->rf4);\n\t}\n\n\trt2500usb_rf_write(rt2x00dev, 1, rf->rf1);\n\trt2500usb_rf_write(rt2x00dev, 2, rf->rf2);\n\trt2500usb_rf_write(rt2x00dev, 3, rf->rf3);\n\tif (rf->rf4)\n\t\trt2500usb_rf_write(rt2x00dev, 4, rf->rf4);\n}\n\nstatic void rt2500usb_config_txpower(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t     const int txpower)\n{\n\tu32 rf3;\n\n\trf3 = rt2x00_rf_read(rt2x00dev, 3);\n\trt2x00_set_field32(&rf3, RF3_TXPOWER, TXPOWER_TO_DEV(txpower));\n\trt2500usb_rf_write(rt2x00dev, 3, rf3);\n}\n\nstatic void rt2500usb_config_ps(struct rt2x00_dev *rt2x00dev,\n\t\t\t\tstruct rt2x00lib_conf *libconf)\n{\n\tenum dev_state state =\n\t    (libconf->conf->flags & IEEE80211_CONF_PS) ?\n\t\tSTATE_SLEEP : STATE_AWAKE;\n\tu16 reg;\n\n\tif (state == STATE_SLEEP) {\n\t\treg = rt2500usb_register_read(rt2x00dev, MAC_CSR18);\n\t\trt2x00_set_field16(&reg, MAC_CSR18_DELAY_AFTER_BEACON,\n\t\t\t\t   rt2x00dev->beacon_int - 20);\n\t\trt2x00_set_field16(&reg, MAC_CSR18_BEACONS_BEFORE_WAKEUP,\n\t\t\t\t   libconf->conf->listen_interval - 1);\n\n\t\t \n\t\trt2x00_set_field16(&reg, MAC_CSR18_AUTO_WAKE, 0);\n\t\trt2500usb_register_write(rt2x00dev, MAC_CSR18, reg);\n\n\t\trt2x00_set_field16(&reg, MAC_CSR18_AUTO_WAKE, 1);\n\t\trt2500usb_register_write(rt2x00dev, MAC_CSR18, reg);\n\t} else {\n\t\treg = rt2500usb_register_read(rt2x00dev, MAC_CSR18);\n\t\trt2x00_set_field16(&reg, MAC_CSR18_AUTO_WAKE, 0);\n\t\trt2500usb_register_write(rt2x00dev, MAC_CSR18, reg);\n\t}\n\n\trt2x00dev->ops->lib->set_device_state(rt2x00dev, state);\n}\n\nstatic void rt2500usb_config(struct rt2x00_dev *rt2x00dev,\n\t\t\t     struct rt2x00lib_conf *libconf,\n\t\t\t     const unsigned int flags)\n{\n\tif (flags & IEEE80211_CONF_CHANGE_CHANNEL)\n\t\trt2500usb_config_channel(rt2x00dev, &libconf->rf,\n\t\t\t\t\t libconf->conf->power_level);\n\tif ((flags & IEEE80211_CONF_CHANGE_POWER) &&\n\t    !(flags & IEEE80211_CONF_CHANGE_CHANNEL))\n\t\trt2500usb_config_txpower(rt2x00dev,\n\t\t\t\t\t libconf->conf->power_level);\n\tif (flags & IEEE80211_CONF_CHANGE_PS)\n\t\trt2500usb_config_ps(rt2x00dev, libconf);\n}\n\n \nstatic void rt2500usb_link_stats(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t struct link_qual *qual)\n{\n\tu16 reg;\n\n\t \n\treg = rt2500usb_register_read(rt2x00dev, STA_CSR0);\n\tqual->rx_failed = rt2x00_get_field16(reg, STA_CSR0_FCS_ERROR);\n\n\t \n\treg = rt2500usb_register_read(rt2x00dev, STA_CSR3);\n\tqual->false_cca = rt2x00_get_field16(reg, STA_CSR3_FALSE_CCA_ERROR);\n}\n\nstatic void rt2500usb_reset_tuner(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t  struct link_qual *qual)\n{\n\tu16 eeprom;\n\tu16 value;\n\n\teeprom = rt2x00_eeprom_read(rt2x00dev, EEPROM_BBPTUNE_R24);\n\tvalue = rt2x00_get_field16(eeprom, EEPROM_BBPTUNE_R24_LOW);\n\trt2500usb_bbp_write(rt2x00dev, 24, value);\n\n\teeprom = rt2x00_eeprom_read(rt2x00dev, EEPROM_BBPTUNE_R25);\n\tvalue = rt2x00_get_field16(eeprom, EEPROM_BBPTUNE_R25_LOW);\n\trt2500usb_bbp_write(rt2x00dev, 25, value);\n\n\teeprom = rt2x00_eeprom_read(rt2x00dev, EEPROM_BBPTUNE_R61);\n\tvalue = rt2x00_get_field16(eeprom, EEPROM_BBPTUNE_R61_LOW);\n\trt2500usb_bbp_write(rt2x00dev, 61, value);\n\n\teeprom = rt2x00_eeprom_read(rt2x00dev, EEPROM_BBPTUNE_VGC);\n\tvalue = rt2x00_get_field16(eeprom, EEPROM_BBPTUNE_VGCUPPER);\n\trt2500usb_bbp_write(rt2x00dev, 17, value);\n\n\tqual->vgc_level = value;\n}\n\n \nstatic void rt2500usb_start_queue(struct data_queue *queue)\n{\n\tstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\n\tu16 reg;\n\n\tswitch (queue->qid) {\n\tcase QID_RX:\n\t\treg = rt2500usb_register_read(rt2x00dev, TXRX_CSR2);\n\t\trt2x00_set_field16(&reg, TXRX_CSR2_DISABLE_RX, 0);\n\t\trt2500usb_register_write(rt2x00dev, TXRX_CSR2, reg);\n\t\tbreak;\n\tcase QID_BEACON:\n\t\treg = rt2500usb_register_read(rt2x00dev, TXRX_CSR19);\n\t\trt2x00_set_field16(&reg, TXRX_CSR19_TSF_COUNT, 1);\n\t\trt2x00_set_field16(&reg, TXRX_CSR19_TBCN, 1);\n\t\trt2x00_set_field16(&reg, TXRX_CSR19_BEACON_GEN, 1);\n\t\trt2500usb_register_write(rt2x00dev, TXRX_CSR19, reg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void rt2500usb_stop_queue(struct data_queue *queue)\n{\n\tstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\n\tu16 reg;\n\n\tswitch (queue->qid) {\n\tcase QID_RX:\n\t\treg = rt2500usb_register_read(rt2x00dev, TXRX_CSR2);\n\t\trt2x00_set_field16(&reg, TXRX_CSR2_DISABLE_RX, 1);\n\t\trt2500usb_register_write(rt2x00dev, TXRX_CSR2, reg);\n\t\tbreak;\n\tcase QID_BEACON:\n\t\treg = rt2500usb_register_read(rt2x00dev, TXRX_CSR19);\n\t\trt2x00_set_field16(&reg, TXRX_CSR19_TSF_COUNT, 0);\n\t\trt2x00_set_field16(&reg, TXRX_CSR19_TBCN, 0);\n\t\trt2x00_set_field16(&reg, TXRX_CSR19_BEACON_GEN, 0);\n\t\trt2500usb_register_write(rt2x00dev, TXRX_CSR19, reg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic int rt2500usb_init_registers(struct rt2x00_dev *rt2x00dev)\n{\n\tu16 reg;\n\n\trt2x00usb_vendor_request_sw(rt2x00dev, USB_DEVICE_MODE, 0x0001,\n\t\t\t\t    USB_MODE_TEST, REGISTER_TIMEOUT);\n\trt2x00usb_vendor_request_sw(rt2x00dev, USB_SINGLE_WRITE, 0x0308,\n\t\t\t\t    0x00f0, REGISTER_TIMEOUT);\n\n\treg = rt2500usb_register_read(rt2x00dev, TXRX_CSR2);\n\trt2x00_set_field16(&reg, TXRX_CSR2_DISABLE_RX, 1);\n\trt2500usb_register_write(rt2x00dev, TXRX_CSR2, reg);\n\n\trt2500usb_register_write(rt2x00dev, MAC_CSR13, 0x1111);\n\trt2500usb_register_write(rt2x00dev, MAC_CSR14, 0x1e11);\n\n\treg = rt2500usb_register_read(rt2x00dev, MAC_CSR1);\n\trt2x00_set_field16(&reg, MAC_CSR1_SOFT_RESET, 1);\n\trt2x00_set_field16(&reg, MAC_CSR1_BBP_RESET, 1);\n\trt2x00_set_field16(&reg, MAC_CSR1_HOST_READY, 0);\n\trt2500usb_register_write(rt2x00dev, MAC_CSR1, reg);\n\n\treg = rt2500usb_register_read(rt2x00dev, MAC_CSR1);\n\trt2x00_set_field16(&reg, MAC_CSR1_SOFT_RESET, 0);\n\trt2x00_set_field16(&reg, MAC_CSR1_BBP_RESET, 0);\n\trt2x00_set_field16(&reg, MAC_CSR1_HOST_READY, 0);\n\trt2500usb_register_write(rt2x00dev, MAC_CSR1, reg);\n\n\treg = rt2500usb_register_read(rt2x00dev, TXRX_CSR5);\n\trt2x00_set_field16(&reg, TXRX_CSR5_BBP_ID0, 13);\n\trt2x00_set_field16(&reg, TXRX_CSR5_BBP_ID0_VALID, 1);\n\trt2x00_set_field16(&reg, TXRX_CSR5_BBP_ID1, 12);\n\trt2x00_set_field16(&reg, TXRX_CSR5_BBP_ID1_VALID, 1);\n\trt2500usb_register_write(rt2x00dev, TXRX_CSR5, reg);\n\n\treg = rt2500usb_register_read(rt2x00dev, TXRX_CSR6);\n\trt2x00_set_field16(&reg, TXRX_CSR6_BBP_ID0, 10);\n\trt2x00_set_field16(&reg, TXRX_CSR6_BBP_ID0_VALID, 1);\n\trt2x00_set_field16(&reg, TXRX_CSR6_BBP_ID1, 11);\n\trt2x00_set_field16(&reg, TXRX_CSR6_BBP_ID1_VALID, 1);\n\trt2500usb_register_write(rt2x00dev, TXRX_CSR6, reg);\n\n\treg = rt2500usb_register_read(rt2x00dev, TXRX_CSR7);\n\trt2x00_set_field16(&reg, TXRX_CSR7_BBP_ID0, 7);\n\trt2x00_set_field16(&reg, TXRX_CSR7_BBP_ID0_VALID, 1);\n\trt2x00_set_field16(&reg, TXRX_CSR7_BBP_ID1, 6);\n\trt2x00_set_field16(&reg, TXRX_CSR7_BBP_ID1_VALID, 1);\n\trt2500usb_register_write(rt2x00dev, TXRX_CSR7, reg);\n\n\treg = rt2500usb_register_read(rt2x00dev, TXRX_CSR8);\n\trt2x00_set_field16(&reg, TXRX_CSR8_BBP_ID0, 5);\n\trt2x00_set_field16(&reg, TXRX_CSR8_BBP_ID0_VALID, 1);\n\trt2x00_set_field16(&reg, TXRX_CSR8_BBP_ID1, 0);\n\trt2x00_set_field16(&reg, TXRX_CSR8_BBP_ID1_VALID, 0);\n\trt2500usb_register_write(rt2x00dev, TXRX_CSR8, reg);\n\n\treg = rt2500usb_register_read(rt2x00dev, TXRX_CSR19);\n\trt2x00_set_field16(&reg, TXRX_CSR19_TSF_COUNT, 0);\n\trt2x00_set_field16(&reg, TXRX_CSR19_TSF_SYNC, 0);\n\trt2x00_set_field16(&reg, TXRX_CSR19_TBCN, 0);\n\trt2x00_set_field16(&reg, TXRX_CSR19_BEACON_GEN, 0);\n\trt2500usb_register_write(rt2x00dev, TXRX_CSR19, reg);\n\n\trt2500usb_register_write(rt2x00dev, TXRX_CSR21, 0xe78f);\n\trt2500usb_register_write(rt2x00dev, MAC_CSR9, 0xff1d);\n\n\tif (rt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_AWAKE))\n\t\treturn -EBUSY;\n\n\treg = rt2500usb_register_read(rt2x00dev, MAC_CSR1);\n\trt2x00_set_field16(&reg, MAC_CSR1_SOFT_RESET, 0);\n\trt2x00_set_field16(&reg, MAC_CSR1_BBP_RESET, 0);\n\trt2x00_set_field16(&reg, MAC_CSR1_HOST_READY, 1);\n\trt2500usb_register_write(rt2x00dev, MAC_CSR1, reg);\n\n\tif (rt2x00_rev(rt2x00dev) >= RT2570_VERSION_C) {\n\t\treg = rt2500usb_register_read(rt2x00dev, PHY_CSR2);\n\t\trt2x00_set_field16(&reg, PHY_CSR2_LNA, 0);\n\t} else {\n\t\treg = 0;\n\t\trt2x00_set_field16(&reg, PHY_CSR2_LNA, 1);\n\t\trt2x00_set_field16(&reg, PHY_CSR2_LNA_MODE, 3);\n\t}\n\trt2500usb_register_write(rt2x00dev, PHY_CSR2, reg);\n\n\trt2500usb_register_write(rt2x00dev, MAC_CSR11, 0x0002);\n\trt2500usb_register_write(rt2x00dev, MAC_CSR22, 0x0053);\n\trt2500usb_register_write(rt2x00dev, MAC_CSR15, 0x01ee);\n\trt2500usb_register_write(rt2x00dev, MAC_CSR16, 0x0000);\n\n\treg = rt2500usb_register_read(rt2x00dev, MAC_CSR8);\n\trt2x00_set_field16(&reg, MAC_CSR8_MAX_FRAME_UNIT,\n\t\t\t   rt2x00dev->rx->data_size);\n\trt2500usb_register_write(rt2x00dev, MAC_CSR8, reg);\n\n\treg = rt2500usb_register_read(rt2x00dev, TXRX_CSR0);\n\trt2x00_set_field16(&reg, TXRX_CSR0_ALGORITHM, CIPHER_NONE);\n\trt2x00_set_field16(&reg, TXRX_CSR0_IV_OFFSET, IEEE80211_HEADER);\n\trt2x00_set_field16(&reg, TXRX_CSR0_KEY_ID, 0);\n\trt2500usb_register_write(rt2x00dev, TXRX_CSR0, reg);\n\n\treg = rt2500usb_register_read(rt2x00dev, MAC_CSR18);\n\trt2x00_set_field16(&reg, MAC_CSR18_DELAY_AFTER_BEACON, 90);\n\trt2500usb_register_write(rt2x00dev, MAC_CSR18, reg);\n\n\treg = rt2500usb_register_read(rt2x00dev, PHY_CSR4);\n\trt2x00_set_field16(&reg, PHY_CSR4_LOW_RF_LE, 1);\n\trt2500usb_register_write(rt2x00dev, PHY_CSR4, reg);\n\n\treg = rt2500usb_register_read(rt2x00dev, TXRX_CSR1);\n\trt2x00_set_field16(&reg, TXRX_CSR1_AUTO_SEQUENCE, 1);\n\trt2500usb_register_write(rt2x00dev, TXRX_CSR1, reg);\n\n\treturn 0;\n}\n\nstatic int rt2500usb_wait_bbp_ready(struct rt2x00_dev *rt2x00dev)\n{\n\tunsigned int i;\n\tu8 value;\n\n\tfor (i = 0; i < REGISTER_USB_BUSY_COUNT; i++) {\n\t\tvalue = rt2500usb_bbp_read(rt2x00dev, 0);\n\t\tif ((value != 0xff) && (value != 0x00))\n\t\t\treturn 0;\n\t\tudelay(REGISTER_BUSY_DELAY);\n\t}\n\n\trt2x00_err(rt2x00dev, \"BBP register access failed, aborting\\n\");\n\treturn -EACCES;\n}\n\nstatic int rt2500usb_init_bbp(struct rt2x00_dev *rt2x00dev)\n{\n\tunsigned int i;\n\tu16 eeprom;\n\tu8 value;\n\tu8 reg_id;\n\n\tif (unlikely(rt2500usb_wait_bbp_ready(rt2x00dev)))\n\t\treturn -EACCES;\n\n\trt2500usb_bbp_write(rt2x00dev, 3, 0x02);\n\trt2500usb_bbp_write(rt2x00dev, 4, 0x19);\n\trt2500usb_bbp_write(rt2x00dev, 14, 0x1c);\n\trt2500usb_bbp_write(rt2x00dev, 15, 0x30);\n\trt2500usb_bbp_write(rt2x00dev, 16, 0xac);\n\trt2500usb_bbp_write(rt2x00dev, 18, 0x18);\n\trt2500usb_bbp_write(rt2x00dev, 19, 0xff);\n\trt2500usb_bbp_write(rt2x00dev, 20, 0x1e);\n\trt2500usb_bbp_write(rt2x00dev, 21, 0x08);\n\trt2500usb_bbp_write(rt2x00dev, 22, 0x08);\n\trt2500usb_bbp_write(rt2x00dev, 23, 0x08);\n\trt2500usb_bbp_write(rt2x00dev, 24, 0x80);\n\trt2500usb_bbp_write(rt2x00dev, 25, 0x50);\n\trt2500usb_bbp_write(rt2x00dev, 26, 0x08);\n\trt2500usb_bbp_write(rt2x00dev, 27, 0x23);\n\trt2500usb_bbp_write(rt2x00dev, 30, 0x10);\n\trt2500usb_bbp_write(rt2x00dev, 31, 0x2b);\n\trt2500usb_bbp_write(rt2x00dev, 32, 0xb9);\n\trt2500usb_bbp_write(rt2x00dev, 34, 0x12);\n\trt2500usb_bbp_write(rt2x00dev, 35, 0x50);\n\trt2500usb_bbp_write(rt2x00dev, 39, 0xc4);\n\trt2500usb_bbp_write(rt2x00dev, 40, 0x02);\n\trt2500usb_bbp_write(rt2x00dev, 41, 0x60);\n\trt2500usb_bbp_write(rt2x00dev, 53, 0x10);\n\trt2500usb_bbp_write(rt2x00dev, 54, 0x18);\n\trt2500usb_bbp_write(rt2x00dev, 56, 0x08);\n\trt2500usb_bbp_write(rt2x00dev, 57, 0x10);\n\trt2500usb_bbp_write(rt2x00dev, 58, 0x08);\n\trt2500usb_bbp_write(rt2x00dev, 61, 0x60);\n\trt2500usb_bbp_write(rt2x00dev, 62, 0x10);\n\trt2500usb_bbp_write(rt2x00dev, 75, 0xff);\n\n\tfor (i = 0; i < EEPROM_BBP_SIZE; i++) {\n\t\teeprom = rt2x00_eeprom_read(rt2x00dev, EEPROM_BBP_START + i);\n\n\t\tif (eeprom != 0xffff && eeprom != 0x0000) {\n\t\t\treg_id = rt2x00_get_field16(eeprom, EEPROM_BBP_REG_ID);\n\t\t\tvalue = rt2x00_get_field16(eeprom, EEPROM_BBP_VALUE);\n\t\t\trt2500usb_bbp_write(rt2x00dev, reg_id, value);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int rt2500usb_enable_radio(struct rt2x00_dev *rt2x00dev)\n{\n\t \n\tif (unlikely(rt2500usb_init_registers(rt2x00dev) ||\n\t\t     rt2500usb_init_bbp(rt2x00dev)))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic void rt2500usb_disable_radio(struct rt2x00_dev *rt2x00dev)\n{\n\trt2500usb_register_write(rt2x00dev, MAC_CSR13, 0x2121);\n\trt2500usb_register_write(rt2x00dev, MAC_CSR14, 0x2121);\n\n\t \n\trt2500usb_register_write(rt2x00dev, TXRX_CSR19, 0);\n\n\trt2x00usb_disable_radio(rt2x00dev);\n}\n\nstatic int rt2500usb_set_state(struct rt2x00_dev *rt2x00dev,\n\t\t\t       enum dev_state state)\n{\n\tu16 reg;\n\tu16 reg2;\n\tunsigned int i;\n\tbool put_to_sleep;\n\tu8 bbp_state;\n\tu8 rf_state;\n\n\tput_to_sleep = (state != STATE_AWAKE);\n\n\treg = 0;\n\trt2x00_set_field16(&reg, MAC_CSR17_BBP_DESIRE_STATE, state);\n\trt2x00_set_field16(&reg, MAC_CSR17_RF_DESIRE_STATE, state);\n\trt2x00_set_field16(&reg, MAC_CSR17_PUT_TO_SLEEP, put_to_sleep);\n\trt2500usb_register_write(rt2x00dev, MAC_CSR17, reg);\n\trt2x00_set_field16(&reg, MAC_CSR17_SET_STATE, 1);\n\trt2500usb_register_write(rt2x00dev, MAC_CSR17, reg);\n\n\t \n\tfor (i = 0; i < REGISTER_USB_BUSY_COUNT; i++) {\n\t\treg2 = rt2500usb_register_read(rt2x00dev, MAC_CSR17);\n\t\tbbp_state = rt2x00_get_field16(reg2, MAC_CSR17_BBP_CURR_STATE);\n\t\trf_state = rt2x00_get_field16(reg2, MAC_CSR17_RF_CURR_STATE);\n\t\tif (bbp_state == state && rf_state == state)\n\t\t\treturn 0;\n\t\trt2500usb_register_write(rt2x00dev, MAC_CSR17, reg);\n\t\tmsleep(30);\n\t}\n\n\treturn -EBUSY;\n}\n\nstatic int rt2500usb_set_device_state(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t      enum dev_state state)\n{\n\tint retval = 0;\n\n\tswitch (state) {\n\tcase STATE_RADIO_ON:\n\t\tretval = rt2500usb_enable_radio(rt2x00dev);\n\t\tbreak;\n\tcase STATE_RADIO_OFF:\n\t\trt2500usb_disable_radio(rt2x00dev);\n\t\tbreak;\n\tcase STATE_RADIO_IRQ_ON:\n\tcase STATE_RADIO_IRQ_OFF:\n\t\t \n\t\tbreak;\n\tcase STATE_DEEP_SLEEP:\n\tcase STATE_SLEEP:\n\tcase STATE_STANDBY:\n\tcase STATE_AWAKE:\n\t\tretval = rt2500usb_set_state(rt2x00dev, state);\n\t\tbreak;\n\tdefault:\n\t\tretval = -ENOTSUPP;\n\t\tbreak;\n\t}\n\n\tif (unlikely(retval))\n\t\trt2x00_err(rt2x00dev, \"Device failed to enter state %d (%d)\\n\",\n\t\t\t   state, retval);\n\n\treturn retval;\n}\n\n \nstatic void rt2500usb_write_tx_desc(struct queue_entry *entry,\n\t\t\t\t    struct txentry_desc *txdesc)\n{\n\tstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\n\t__le32 *txd = (__le32 *) entry->skb->data;\n\tu32 word;\n\n\t \n\tword = rt2x00_desc_read(txd, 0);\n\trt2x00_set_field32(&word, TXD_W0_RETRY_LIMIT, txdesc->retry_limit);\n\trt2x00_set_field32(&word, TXD_W0_MORE_FRAG,\n\t\t\t   test_bit(ENTRY_TXD_MORE_FRAG, &txdesc->flags));\n\trt2x00_set_field32(&word, TXD_W0_ACK,\n\t\t\t   test_bit(ENTRY_TXD_ACK, &txdesc->flags));\n\trt2x00_set_field32(&word, TXD_W0_TIMESTAMP,\n\t\t\t   test_bit(ENTRY_TXD_REQ_TIMESTAMP, &txdesc->flags));\n\trt2x00_set_field32(&word, TXD_W0_OFDM,\n\t\t\t   (txdesc->rate_mode == RATE_MODE_OFDM));\n\trt2x00_set_field32(&word, TXD_W0_NEW_SEQ,\n\t\t\t   test_bit(ENTRY_TXD_FIRST_FRAGMENT, &txdesc->flags));\n\trt2x00_set_field32(&word, TXD_W0_IFS, txdesc->u.plcp.ifs);\n\trt2x00_set_field32(&word, TXD_W0_DATABYTE_COUNT, txdesc->length);\n\trt2x00_set_field32(&word, TXD_W0_CIPHER, !!txdesc->cipher);\n\trt2x00_set_field32(&word, TXD_W0_KEY_ID, txdesc->key_idx);\n\trt2x00_desc_write(txd, 0, word);\n\n\tword = rt2x00_desc_read(txd, 1);\n\trt2x00_set_field32(&word, TXD_W1_IV_OFFSET, txdesc->iv_offset);\n\trt2x00_set_field32(&word, TXD_W1_AIFS, entry->queue->aifs);\n\trt2x00_set_field32(&word, TXD_W1_CWMIN, entry->queue->cw_min);\n\trt2x00_set_field32(&word, TXD_W1_CWMAX, entry->queue->cw_max);\n\trt2x00_desc_write(txd, 1, word);\n\n\tword = rt2x00_desc_read(txd, 2);\n\trt2x00_set_field32(&word, TXD_W2_PLCP_SIGNAL, txdesc->u.plcp.signal);\n\trt2x00_set_field32(&word, TXD_W2_PLCP_SERVICE, txdesc->u.plcp.service);\n\trt2x00_set_field32(&word, TXD_W2_PLCP_LENGTH_LOW,\n\t\t\t   txdesc->u.plcp.length_low);\n\trt2x00_set_field32(&word, TXD_W2_PLCP_LENGTH_HIGH,\n\t\t\t   txdesc->u.plcp.length_high);\n\trt2x00_desc_write(txd, 2, word);\n\n\tif (test_bit(ENTRY_TXD_ENCRYPT, &txdesc->flags)) {\n\t\t_rt2x00_desc_write(txd, 3, skbdesc->iv[0]);\n\t\t_rt2x00_desc_write(txd, 4, skbdesc->iv[1]);\n\t}\n\n\t \n\tskbdesc->flags |= SKBDESC_DESC_IN_SKB;\n\tskbdesc->desc = txd;\n\tskbdesc->desc_len = TXD_DESC_SIZE;\n}\n\n \nstatic void rt2500usb_beacondone(struct urb *urb);\n\nstatic void rt2500usb_write_beacon(struct queue_entry *entry,\n\t\t\t\t   struct txentry_desc *txdesc)\n{\n\tstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\n\tstruct usb_device *usb_dev = to_usb_device_intf(rt2x00dev->dev);\n\tstruct queue_entry_priv_usb_bcn *bcn_priv = entry->priv_data;\n\tint pipe = usb_sndbulkpipe(usb_dev, entry->queue->usb_endpoint);\n\tint length;\n\tu16 reg, reg0;\n\n\t \n\treg = rt2500usb_register_read(rt2x00dev, TXRX_CSR19);\n\trt2x00_set_field16(&reg, TXRX_CSR19_BEACON_GEN, 0);\n\trt2500usb_register_write(rt2x00dev, TXRX_CSR19, reg);\n\n\t \n\tskb_push(entry->skb, TXD_DESC_SIZE);\n\tmemset(entry->skb->data, 0, TXD_DESC_SIZE);\n\n\t \n\trt2500usb_write_tx_desc(entry, txdesc);\n\n\t \n\trt2x00debug_dump_frame(rt2x00dev, DUMP_FRAME_BEACON, entry);\n\n\t \n\tlength = rt2x00dev->ops->lib->get_tx_data_len(entry);\n\n\tusb_fill_bulk_urb(bcn_priv->urb, usb_dev, pipe,\n\t\t\t  entry->skb->data, length, rt2500usb_beacondone,\n\t\t\t  entry);\n\n\t \n\tbcn_priv->guardian_data = 0;\n\tusb_fill_bulk_urb(bcn_priv->guardian_urb, usb_dev, pipe,\n\t\t\t  &bcn_priv->guardian_data, 1, rt2500usb_beacondone,\n\t\t\t  entry);\n\n\t \n\tusb_submit_urb(bcn_priv->guardian_urb, GFP_ATOMIC);\n\n\t \n\trt2x00_set_field16(&reg, TXRX_CSR19_TSF_COUNT, 1);\n\trt2x00_set_field16(&reg, TXRX_CSR19_TBCN, 1);\n\treg0 = reg;\n\trt2x00_set_field16(&reg, TXRX_CSR19_BEACON_GEN, 1);\n\t \n\trt2500usb_register_write(rt2x00dev, TXRX_CSR19, reg);\n\trt2500usb_register_write(rt2x00dev, TXRX_CSR19, reg0);\n\trt2500usb_register_write(rt2x00dev, TXRX_CSR19, reg);\n\trt2500usb_register_write(rt2x00dev, TXRX_CSR19, reg0);\n\trt2500usb_register_write(rt2x00dev, TXRX_CSR19, reg);\n}\n\nstatic int rt2500usb_get_tx_data_len(struct queue_entry *entry)\n{\n\tint length;\n\n\t \n\tlength = roundup(entry->skb->len, 2);\n\tlength += (2 * !(length % entry->queue->usb_maxpacket));\n\n\treturn length;\n}\n\n \nstatic void rt2500usb_fill_rxdone(struct queue_entry *entry,\n\t\t\t\t  struct rxdone_entry_desc *rxdesc)\n{\n\tstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\n\tstruct queue_entry_priv_usb *entry_priv = entry->priv_data;\n\tstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\n\t__le32 *rxd =\n\t    (__le32 *)(entry->skb->data +\n\t\t       (entry_priv->urb->actual_length -\n\t\t\tentry->queue->desc_size));\n\tu32 word0;\n\tu32 word1;\n\n\t \n\tmemcpy(skbdesc->desc, rxd, skbdesc->desc_len);\n\trxd = (__le32 *)skbdesc->desc;\n\n\t \n\tword0 = rt2x00_desc_read(rxd, 0);\n\tword1 = rt2x00_desc_read(rxd, 1);\n\n\tif (rt2x00_get_field32(word0, RXD_W0_CRC_ERROR))\n\t\trxdesc->flags |= RX_FLAG_FAILED_FCS_CRC;\n\tif (rt2x00_get_field32(word0, RXD_W0_PHYSICAL_ERROR))\n\t\trxdesc->flags |= RX_FLAG_FAILED_PLCP_CRC;\n\n\trxdesc->cipher = rt2x00_get_field32(word0, RXD_W0_CIPHER);\n\tif (rt2x00_get_field32(word0, RXD_W0_CIPHER_ERROR))\n\t\trxdesc->cipher_status = RX_CRYPTO_FAIL_KEY;\n\n\tif (rxdesc->cipher != CIPHER_NONE) {\n\t\trxdesc->iv[0] = _rt2x00_desc_read(rxd, 2);\n\t\trxdesc->iv[1] = _rt2x00_desc_read(rxd, 3);\n\t\trxdesc->dev_flags |= RXDONE_CRYPTO_IV;\n\n\t\t \n\n\t\trxdesc->flags |= RX_FLAG_MMIC_STRIPPED;\n\t\tif (rxdesc->cipher_status == RX_CRYPTO_SUCCESS)\n\t\t\trxdesc->flags |= RX_FLAG_DECRYPTED;\n\t\telse if (rxdesc->cipher_status == RX_CRYPTO_FAIL_MIC)\n\t\t\trxdesc->flags |= RX_FLAG_MMIC_ERROR;\n\t}\n\n\t \n\trxdesc->signal = rt2x00_get_field32(word1, RXD_W1_SIGNAL);\n\trxdesc->rssi =\n\t    rt2x00_get_field32(word1, RXD_W1_RSSI) - rt2x00dev->rssi_offset;\n\trxdesc->size = rt2x00_get_field32(word0, RXD_W0_DATABYTE_COUNT);\n\n\tif (rt2x00_get_field32(word0, RXD_W0_OFDM))\n\t\trxdesc->dev_flags |= RXDONE_SIGNAL_PLCP;\n\telse\n\t\trxdesc->dev_flags |= RXDONE_SIGNAL_BITRATE;\n\tif (rt2x00_get_field32(word0, RXD_W0_MY_BSS))\n\t\trxdesc->dev_flags |= RXDONE_MY_BSS;\n\n\t \n\tskb_trim(entry->skb, rxdesc->size);\n}\n\n \nstatic void rt2500usb_beacondone(struct urb *urb)\n{\n\tstruct queue_entry *entry = (struct queue_entry *)urb->context;\n\tstruct queue_entry_priv_usb_bcn *bcn_priv = entry->priv_data;\n\n\tif (!test_bit(DEVICE_STATE_ENABLED_RADIO, &entry->queue->rt2x00dev->flags))\n\t\treturn;\n\n\t \n\tif (bcn_priv->guardian_urb == urb) {\n\t\tusb_submit_urb(bcn_priv->urb, GFP_ATOMIC);\n\t} else if (bcn_priv->urb == urb) {\n\t\tdev_kfree_skb(entry->skb);\n\t\tentry->skb = NULL;\n\t}\n}\n\n \nstatic int rt2500usb_validate_eeprom(struct rt2x00_dev *rt2x00dev)\n{\n\tu16 word;\n\tu8 *mac;\n\tu8 bbp;\n\n\trt2x00usb_eeprom_read(rt2x00dev, rt2x00dev->eeprom, EEPROM_SIZE);\n\n\t \n\tmac = rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0);\n\trt2x00lib_set_mac_address(rt2x00dev, mac);\n\n\tword = rt2x00_eeprom_read(rt2x00dev, EEPROM_ANTENNA);\n\tif (word == 0xffff) {\n\t\trt2x00_set_field16(&word, EEPROM_ANTENNA_NUM, 2);\n\t\trt2x00_set_field16(&word, EEPROM_ANTENNA_TX_DEFAULT,\n\t\t\t\t   ANTENNA_SW_DIVERSITY);\n\t\trt2x00_set_field16(&word, EEPROM_ANTENNA_RX_DEFAULT,\n\t\t\t\t   ANTENNA_SW_DIVERSITY);\n\t\trt2x00_set_field16(&word, EEPROM_ANTENNA_LED_MODE,\n\t\t\t\t   LED_MODE_DEFAULT);\n\t\trt2x00_set_field16(&word, EEPROM_ANTENNA_DYN_TXAGC, 0);\n\t\trt2x00_set_field16(&word, EEPROM_ANTENNA_HARDWARE_RADIO, 0);\n\t\trt2x00_set_field16(&word, EEPROM_ANTENNA_RF_TYPE, RF2522);\n\t\trt2x00_eeprom_write(rt2x00dev, EEPROM_ANTENNA, word);\n\t\trt2x00_eeprom_dbg(rt2x00dev, \"Antenna: 0x%04x\\n\", word);\n\t}\n\n\tword = rt2x00_eeprom_read(rt2x00dev, EEPROM_NIC);\n\tif (word == 0xffff) {\n\t\trt2x00_set_field16(&word, EEPROM_NIC_CARDBUS_ACCEL, 0);\n\t\trt2x00_set_field16(&word, EEPROM_NIC_DYN_BBP_TUNE, 0);\n\t\trt2x00_set_field16(&word, EEPROM_NIC_CCK_TX_POWER, 0);\n\t\trt2x00_eeprom_write(rt2x00dev, EEPROM_NIC, word);\n\t\trt2x00_eeprom_dbg(rt2x00dev, \"NIC: 0x%04x\\n\", word);\n\t}\n\n\tword = rt2x00_eeprom_read(rt2x00dev, EEPROM_CALIBRATE_OFFSET);\n\tif (word == 0xffff) {\n\t\trt2x00_set_field16(&word, EEPROM_CALIBRATE_OFFSET_RSSI,\n\t\t\t\t   DEFAULT_RSSI_OFFSET);\n\t\trt2x00_eeprom_write(rt2x00dev, EEPROM_CALIBRATE_OFFSET, word);\n\t\trt2x00_eeprom_dbg(rt2x00dev, \"Calibrate offset: 0x%04x\\n\",\n\t\t\t\t  word);\n\t}\n\n\tword = rt2x00_eeprom_read(rt2x00dev, EEPROM_BBPTUNE);\n\tif (word == 0xffff) {\n\t\trt2x00_set_field16(&word, EEPROM_BBPTUNE_THRESHOLD, 45);\n\t\trt2x00_eeprom_write(rt2x00dev, EEPROM_BBPTUNE, word);\n\t\trt2x00_eeprom_dbg(rt2x00dev, \"BBPtune: 0x%04x\\n\", word);\n\t}\n\n\t \n\tbbp = rt2500usb_bbp_read(rt2x00dev, 17);\n\tbbp -= 6;\n\n\tword = rt2x00_eeprom_read(rt2x00dev, EEPROM_BBPTUNE_VGC);\n\tif (word == 0xffff) {\n\t\trt2x00_set_field16(&word, EEPROM_BBPTUNE_VGCUPPER, 0x40);\n\t\trt2x00_set_field16(&word, EEPROM_BBPTUNE_VGCLOWER, bbp);\n\t\trt2x00_eeprom_write(rt2x00dev, EEPROM_BBPTUNE_VGC, word);\n\t\trt2x00_eeprom_dbg(rt2x00dev, \"BBPtune vgc: 0x%04x\\n\", word);\n\t} else {\n\t\trt2x00_set_field16(&word, EEPROM_BBPTUNE_VGCLOWER, bbp);\n\t\trt2x00_eeprom_write(rt2x00dev, EEPROM_BBPTUNE_VGC, word);\n\t}\n\n\tword = rt2x00_eeprom_read(rt2x00dev, EEPROM_BBPTUNE_R17);\n\tif (word == 0xffff) {\n\t\trt2x00_set_field16(&word, EEPROM_BBPTUNE_R17_LOW, 0x48);\n\t\trt2x00_set_field16(&word, EEPROM_BBPTUNE_R17_HIGH, 0x41);\n\t\trt2x00_eeprom_write(rt2x00dev, EEPROM_BBPTUNE_R17, word);\n\t\trt2x00_eeprom_dbg(rt2x00dev, \"BBPtune r17: 0x%04x\\n\", word);\n\t}\n\n\tword = rt2x00_eeprom_read(rt2x00dev, EEPROM_BBPTUNE_R24);\n\tif (word == 0xffff) {\n\t\trt2x00_set_field16(&word, EEPROM_BBPTUNE_R24_LOW, 0x40);\n\t\trt2x00_set_field16(&word, EEPROM_BBPTUNE_R24_HIGH, 0x80);\n\t\trt2x00_eeprom_write(rt2x00dev, EEPROM_BBPTUNE_R24, word);\n\t\trt2x00_eeprom_dbg(rt2x00dev, \"BBPtune r24: 0x%04x\\n\", word);\n\t}\n\n\tword = rt2x00_eeprom_read(rt2x00dev, EEPROM_BBPTUNE_R25);\n\tif (word == 0xffff) {\n\t\trt2x00_set_field16(&word, EEPROM_BBPTUNE_R25_LOW, 0x40);\n\t\trt2x00_set_field16(&word, EEPROM_BBPTUNE_R25_HIGH, 0x50);\n\t\trt2x00_eeprom_write(rt2x00dev, EEPROM_BBPTUNE_R25, word);\n\t\trt2x00_eeprom_dbg(rt2x00dev, \"BBPtune r25: 0x%04x\\n\", word);\n\t}\n\n\tword = rt2x00_eeprom_read(rt2x00dev, EEPROM_BBPTUNE_R61);\n\tif (word == 0xffff) {\n\t\trt2x00_set_field16(&word, EEPROM_BBPTUNE_R61_LOW, 0x60);\n\t\trt2x00_set_field16(&word, EEPROM_BBPTUNE_R61_HIGH, 0x6d);\n\t\trt2x00_eeprom_write(rt2x00dev, EEPROM_BBPTUNE_R61, word);\n\t\trt2x00_eeprom_dbg(rt2x00dev, \"BBPtune r61: 0x%04x\\n\", word);\n\t}\n\n\treturn 0;\n}\n\nstatic int rt2500usb_init_eeprom(struct rt2x00_dev *rt2x00dev)\n{\n\tu16 reg;\n\tu16 value;\n\tu16 eeprom;\n\n\t \n\teeprom = rt2x00_eeprom_read(rt2x00dev, EEPROM_ANTENNA);\n\n\t \n\tvalue = rt2x00_get_field16(eeprom, EEPROM_ANTENNA_RF_TYPE);\n\treg = rt2500usb_register_read(rt2x00dev, MAC_CSR0);\n\trt2x00_set_chip(rt2x00dev, RT2570, value, reg);\n\n\tif (((reg & 0xfff0) != 0) || ((reg & 0x0000000f) == 0)) {\n\t\trt2x00_err(rt2x00dev, \"Invalid RT chipset detected\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!rt2x00_rf(rt2x00dev, RF2522) &&\n\t    !rt2x00_rf(rt2x00dev, RF2523) &&\n\t    !rt2x00_rf(rt2x00dev, RF2524) &&\n\t    !rt2x00_rf(rt2x00dev, RF2525) &&\n\t    !rt2x00_rf(rt2x00dev, RF2525E) &&\n\t    !rt2x00_rf(rt2x00dev, RF5222)) {\n\t\trt2x00_err(rt2x00dev, \"Invalid RF chipset detected\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\trt2x00dev->default_ant.tx =\n\t    rt2x00_get_field16(eeprom, EEPROM_ANTENNA_TX_DEFAULT);\n\trt2x00dev->default_ant.rx =\n\t    rt2x00_get_field16(eeprom, EEPROM_ANTENNA_RX_DEFAULT);\n\n\t \n\tif (rt2x00dev->default_ant.tx == ANTENNA_SW_DIVERSITY)\n\t\trt2x00dev->default_ant.tx = ANTENNA_HW_DIVERSITY;\n\tif (rt2x00dev->default_ant.rx == ANTENNA_SW_DIVERSITY)\n\t\trt2x00dev->default_ant.rx = ANTENNA_HW_DIVERSITY;\n\n\t \n#ifdef CONFIG_RT2X00_LIB_LEDS\n\tvalue = rt2x00_get_field16(eeprom, EEPROM_ANTENNA_LED_MODE);\n\n\trt2500usb_init_led(rt2x00dev, &rt2x00dev->led_radio, LED_TYPE_RADIO);\n\tif (value == LED_MODE_TXRX_ACTIVITY ||\n\t    value == LED_MODE_DEFAULT ||\n\t    value == LED_MODE_ASUS)\n\t\trt2500usb_init_led(rt2x00dev, &rt2x00dev->led_qual,\n\t\t\t\t   LED_TYPE_ACTIVITY);\n#endif  \n\n\t \n\tif (rt2x00_get_field16(eeprom, EEPROM_ANTENNA_HARDWARE_RADIO))\n\t\t__set_bit(CAPABILITY_HW_BUTTON, &rt2x00dev->cap_flags);\n\n\t \n\teeprom = rt2x00_eeprom_read(rt2x00dev, EEPROM_CALIBRATE_OFFSET);\n\trt2x00dev->rssi_offset =\n\t    rt2x00_get_field16(eeprom, EEPROM_CALIBRATE_OFFSET_RSSI);\n\n\treturn 0;\n}\n\n \nstatic const struct rf_channel rf_vals_bg_2522[] = {\n\t{ 1,  0x00002050, 0x000c1fda, 0x00000101, 0 },\n\t{ 2,  0x00002050, 0x000c1fee, 0x00000101, 0 },\n\t{ 3,  0x00002050, 0x000c2002, 0x00000101, 0 },\n\t{ 4,  0x00002050, 0x000c2016, 0x00000101, 0 },\n\t{ 5,  0x00002050, 0x000c202a, 0x00000101, 0 },\n\t{ 6,  0x00002050, 0x000c203e, 0x00000101, 0 },\n\t{ 7,  0x00002050, 0x000c2052, 0x00000101, 0 },\n\t{ 8,  0x00002050, 0x000c2066, 0x00000101, 0 },\n\t{ 9,  0x00002050, 0x000c207a, 0x00000101, 0 },\n\t{ 10, 0x00002050, 0x000c208e, 0x00000101, 0 },\n\t{ 11, 0x00002050, 0x000c20a2, 0x00000101, 0 },\n\t{ 12, 0x00002050, 0x000c20b6, 0x00000101, 0 },\n\t{ 13, 0x00002050, 0x000c20ca, 0x00000101, 0 },\n\t{ 14, 0x00002050, 0x000c20fa, 0x00000101, 0 },\n};\n\n \nstatic const struct rf_channel rf_vals_bg_2523[] = {\n\t{ 1,  0x00022010, 0x00000c9e, 0x000e0111, 0x00000a1b },\n\t{ 2,  0x00022010, 0x00000ca2, 0x000e0111, 0x00000a1b },\n\t{ 3,  0x00022010, 0x00000ca6, 0x000e0111, 0x00000a1b },\n\t{ 4,  0x00022010, 0x00000caa, 0x000e0111, 0x00000a1b },\n\t{ 5,  0x00022010, 0x00000cae, 0x000e0111, 0x00000a1b },\n\t{ 6,  0x00022010, 0x00000cb2, 0x000e0111, 0x00000a1b },\n\t{ 7,  0x00022010, 0x00000cb6, 0x000e0111, 0x00000a1b },\n\t{ 8,  0x00022010, 0x00000cba, 0x000e0111, 0x00000a1b },\n\t{ 9,  0x00022010, 0x00000cbe, 0x000e0111, 0x00000a1b },\n\t{ 10, 0x00022010, 0x00000d02, 0x000e0111, 0x00000a1b },\n\t{ 11, 0x00022010, 0x00000d06, 0x000e0111, 0x00000a1b },\n\t{ 12, 0x00022010, 0x00000d0a, 0x000e0111, 0x00000a1b },\n\t{ 13, 0x00022010, 0x00000d0e, 0x000e0111, 0x00000a1b },\n\t{ 14, 0x00022010, 0x00000d1a, 0x000e0111, 0x00000a03 },\n};\n\n \nstatic const struct rf_channel rf_vals_bg_2524[] = {\n\t{ 1,  0x00032020, 0x00000c9e, 0x00000101, 0x00000a1b },\n\t{ 2,  0x00032020, 0x00000ca2, 0x00000101, 0x00000a1b },\n\t{ 3,  0x00032020, 0x00000ca6, 0x00000101, 0x00000a1b },\n\t{ 4,  0x00032020, 0x00000caa, 0x00000101, 0x00000a1b },\n\t{ 5,  0x00032020, 0x00000cae, 0x00000101, 0x00000a1b },\n\t{ 6,  0x00032020, 0x00000cb2, 0x00000101, 0x00000a1b },\n\t{ 7,  0x00032020, 0x00000cb6, 0x00000101, 0x00000a1b },\n\t{ 8,  0x00032020, 0x00000cba, 0x00000101, 0x00000a1b },\n\t{ 9,  0x00032020, 0x00000cbe, 0x00000101, 0x00000a1b },\n\t{ 10, 0x00032020, 0x00000d02, 0x00000101, 0x00000a1b },\n\t{ 11, 0x00032020, 0x00000d06, 0x00000101, 0x00000a1b },\n\t{ 12, 0x00032020, 0x00000d0a, 0x00000101, 0x00000a1b },\n\t{ 13, 0x00032020, 0x00000d0e, 0x00000101, 0x00000a1b },\n\t{ 14, 0x00032020, 0x00000d1a, 0x00000101, 0x00000a03 },\n};\n\n \nstatic const struct rf_channel rf_vals_bg_2525[] = {\n\t{ 1,  0x00022020, 0x00080c9e, 0x00060111, 0x00000a1b },\n\t{ 2,  0x00022020, 0x00080ca2, 0x00060111, 0x00000a1b },\n\t{ 3,  0x00022020, 0x00080ca6, 0x00060111, 0x00000a1b },\n\t{ 4,  0x00022020, 0x00080caa, 0x00060111, 0x00000a1b },\n\t{ 5,  0x00022020, 0x00080cae, 0x00060111, 0x00000a1b },\n\t{ 6,  0x00022020, 0x00080cb2, 0x00060111, 0x00000a1b },\n\t{ 7,  0x00022020, 0x00080cb6, 0x00060111, 0x00000a1b },\n\t{ 8,  0x00022020, 0x00080cba, 0x00060111, 0x00000a1b },\n\t{ 9,  0x00022020, 0x00080cbe, 0x00060111, 0x00000a1b },\n\t{ 10, 0x00022020, 0x00080d02, 0x00060111, 0x00000a1b },\n\t{ 11, 0x00022020, 0x00080d06, 0x00060111, 0x00000a1b },\n\t{ 12, 0x00022020, 0x00080d0a, 0x00060111, 0x00000a1b },\n\t{ 13, 0x00022020, 0x00080d0e, 0x00060111, 0x00000a1b },\n\t{ 14, 0x00022020, 0x00080d1a, 0x00060111, 0x00000a03 },\n};\n\n \nstatic const struct rf_channel rf_vals_bg_2525e[] = {\n\t{ 1,  0x00022010, 0x0000089a, 0x00060111, 0x00000e1b },\n\t{ 2,  0x00022010, 0x0000089e, 0x00060111, 0x00000e07 },\n\t{ 3,  0x00022010, 0x0000089e, 0x00060111, 0x00000e1b },\n\t{ 4,  0x00022010, 0x000008a2, 0x00060111, 0x00000e07 },\n\t{ 5,  0x00022010, 0x000008a2, 0x00060111, 0x00000e1b },\n\t{ 6,  0x00022010, 0x000008a6, 0x00060111, 0x00000e07 },\n\t{ 7,  0x00022010, 0x000008a6, 0x00060111, 0x00000e1b },\n\t{ 8,  0x00022010, 0x000008aa, 0x00060111, 0x00000e07 },\n\t{ 9,  0x00022010, 0x000008aa, 0x00060111, 0x00000e1b },\n\t{ 10, 0x00022010, 0x000008ae, 0x00060111, 0x00000e07 },\n\t{ 11, 0x00022010, 0x000008ae, 0x00060111, 0x00000e1b },\n\t{ 12, 0x00022010, 0x000008b2, 0x00060111, 0x00000e07 },\n\t{ 13, 0x00022010, 0x000008b2, 0x00060111, 0x00000e1b },\n\t{ 14, 0x00022010, 0x000008b6, 0x00060111, 0x00000e23 },\n};\n\n \nstatic const struct rf_channel rf_vals_5222[] = {\n\t{ 1,  0x00022020, 0x00001136, 0x00000101, 0x00000a0b },\n\t{ 2,  0x00022020, 0x0000113a, 0x00000101, 0x00000a0b },\n\t{ 3,  0x00022020, 0x0000113e, 0x00000101, 0x00000a0b },\n\t{ 4,  0x00022020, 0x00001182, 0x00000101, 0x00000a0b },\n\t{ 5,  0x00022020, 0x00001186, 0x00000101, 0x00000a0b },\n\t{ 6,  0x00022020, 0x0000118a, 0x00000101, 0x00000a0b },\n\t{ 7,  0x00022020, 0x0000118e, 0x00000101, 0x00000a0b },\n\t{ 8,  0x00022020, 0x00001192, 0x00000101, 0x00000a0b },\n\t{ 9,  0x00022020, 0x00001196, 0x00000101, 0x00000a0b },\n\t{ 10, 0x00022020, 0x0000119a, 0x00000101, 0x00000a0b },\n\t{ 11, 0x00022020, 0x0000119e, 0x00000101, 0x00000a0b },\n\t{ 12, 0x00022020, 0x000011a2, 0x00000101, 0x00000a0b },\n\t{ 13, 0x00022020, 0x000011a6, 0x00000101, 0x00000a0b },\n\t{ 14, 0x00022020, 0x000011ae, 0x00000101, 0x00000a1b },\n\n\t \n\t{ 36, 0x00022010, 0x00018896, 0x00000101, 0x00000a1f },\n\t{ 40, 0x00022010, 0x0001889a, 0x00000101, 0x00000a1f },\n\t{ 44, 0x00022010, 0x0001889e, 0x00000101, 0x00000a1f },\n\t{ 48, 0x00022010, 0x000188a2, 0x00000101, 0x00000a1f },\n\t{ 52, 0x00022010, 0x000188a6, 0x00000101, 0x00000a1f },\n\t{ 66, 0x00022010, 0x000188aa, 0x00000101, 0x00000a1f },\n\t{ 60, 0x00022010, 0x000188ae, 0x00000101, 0x00000a1f },\n\t{ 64, 0x00022010, 0x000188b2, 0x00000101, 0x00000a1f },\n\n\t \n\t{ 100, 0x00022010, 0x00008802, 0x00000101, 0x00000a0f },\n\t{ 104, 0x00022010, 0x00008806, 0x00000101, 0x00000a0f },\n\t{ 108, 0x00022010, 0x0000880a, 0x00000101, 0x00000a0f },\n\t{ 112, 0x00022010, 0x0000880e, 0x00000101, 0x00000a0f },\n\t{ 116, 0x00022010, 0x00008812, 0x00000101, 0x00000a0f },\n\t{ 120, 0x00022010, 0x00008816, 0x00000101, 0x00000a0f },\n\t{ 124, 0x00022010, 0x0000881a, 0x00000101, 0x00000a0f },\n\t{ 128, 0x00022010, 0x0000881e, 0x00000101, 0x00000a0f },\n\t{ 132, 0x00022010, 0x00008822, 0x00000101, 0x00000a0f },\n\t{ 136, 0x00022010, 0x00008826, 0x00000101, 0x00000a0f },\n\n\t \n\t{ 140, 0x00022010, 0x0000882a, 0x00000101, 0x00000a0f },\n\t{ 149, 0x00022020, 0x000090a6, 0x00000101, 0x00000a07 },\n\t{ 153, 0x00022020, 0x000090ae, 0x00000101, 0x00000a07 },\n\t{ 157, 0x00022020, 0x000090b6, 0x00000101, 0x00000a07 },\n\t{ 161, 0x00022020, 0x000090be, 0x00000101, 0x00000a07 },\n};\n\nstatic int rt2500usb_probe_hw_mode(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct hw_mode_spec *spec = &rt2x00dev->spec;\n\tstruct channel_info *info;\n\tu8 *tx_power;\n\tunsigned int i;\n\n\t \n\tieee80211_hw_set(rt2x00dev->hw, PS_NULLFUNC_STACK);\n\tieee80211_hw_set(rt2x00dev->hw, SUPPORTS_PS);\n\tieee80211_hw_set(rt2x00dev->hw, RX_INCLUDES_FCS);\n\tieee80211_hw_set(rt2x00dev->hw, SIGNAL_DBM);\n\n\t \n\trt2x00dev->hw->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;\n\n\tSET_IEEE80211_DEV(rt2x00dev->hw, rt2x00dev->dev);\n\tSET_IEEE80211_PERM_ADDR(rt2x00dev->hw,\n\t\t\t\trt2x00_eeprom_addr(rt2x00dev,\n\t\t\t\t\t\t   EEPROM_MAC_ADDR_0));\n\n\t \n\tspec->supported_bands = SUPPORT_BAND_2GHZ;\n\tspec->supported_rates = SUPPORT_RATE_CCK | SUPPORT_RATE_OFDM;\n\n\tif (rt2x00_rf(rt2x00dev, RF2522)) {\n\t\tspec->num_channels = ARRAY_SIZE(rf_vals_bg_2522);\n\t\tspec->channels = rf_vals_bg_2522;\n\t} else if (rt2x00_rf(rt2x00dev, RF2523)) {\n\t\tspec->num_channels = ARRAY_SIZE(rf_vals_bg_2523);\n\t\tspec->channels = rf_vals_bg_2523;\n\t} else if (rt2x00_rf(rt2x00dev, RF2524)) {\n\t\tspec->num_channels = ARRAY_SIZE(rf_vals_bg_2524);\n\t\tspec->channels = rf_vals_bg_2524;\n\t} else if (rt2x00_rf(rt2x00dev, RF2525)) {\n\t\tspec->num_channels = ARRAY_SIZE(rf_vals_bg_2525);\n\t\tspec->channels = rf_vals_bg_2525;\n\t} else if (rt2x00_rf(rt2x00dev, RF2525E)) {\n\t\tspec->num_channels = ARRAY_SIZE(rf_vals_bg_2525e);\n\t\tspec->channels = rf_vals_bg_2525e;\n\t} else if (rt2x00_rf(rt2x00dev, RF5222)) {\n\t\tspec->supported_bands |= SUPPORT_BAND_5GHZ;\n\t\tspec->num_channels = ARRAY_SIZE(rf_vals_5222);\n\t\tspec->channels = rf_vals_5222;\n\t}\n\n\t \n\tinfo = kcalloc(spec->num_channels, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tspec->channels_info = info;\n\n\ttx_power = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_START);\n\tfor (i = 0; i < 14; i++) {\n\t\tinfo[i].max_power = MAX_TXPOWER;\n\t\tinfo[i].default_power1 = TXPOWER_FROM_DEV(tx_power[i]);\n\t}\n\n\tif (spec->num_channels > 14) {\n\t\tfor (i = 14; i < spec->num_channels; i++) {\n\t\t\tinfo[i].max_power = MAX_TXPOWER;\n\t\t\tinfo[i].default_power1 = DEFAULT_TXPOWER;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rt2500usb_probe_hw(struct rt2x00_dev *rt2x00dev)\n{\n\tint retval;\n\tu16 reg;\n\n\t \n\tretval = rt2500usb_validate_eeprom(rt2x00dev);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = rt2500usb_init_eeprom(rt2x00dev);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\treg = rt2500usb_register_read(rt2x00dev, MAC_CSR19);\n\trt2x00_set_field16(&reg, MAC_CSR19_DIR0, 0);\n\trt2500usb_register_write(rt2x00dev, MAC_CSR19, reg);\n\n\t \n\tretval = rt2500usb_probe_hw_mode(rt2x00dev);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\t__set_bit(REQUIRE_ATIM_QUEUE, &rt2x00dev->cap_flags);\n\t__set_bit(REQUIRE_BEACON_GUARD, &rt2x00dev->cap_flags);\n\tif (!modparam_nohwcrypt) {\n\t\t__set_bit(CAPABILITY_HW_CRYPTO, &rt2x00dev->cap_flags);\n\t\t__set_bit(REQUIRE_COPY_IV, &rt2x00dev->cap_flags);\n\t}\n\t__set_bit(REQUIRE_SW_SEQNO, &rt2x00dev->cap_flags);\n\t__set_bit(REQUIRE_PS_AUTOWAKE, &rt2x00dev->cap_flags);\n\n\t \n\trt2x00dev->rssi_offset = DEFAULT_RSSI_OFFSET;\n\n\treturn 0;\n}\n\nstatic const struct ieee80211_ops rt2500usb_mac80211_ops = {\n\t.tx\t\t\t= rt2x00mac_tx,\n\t.wake_tx_queue\t\t= ieee80211_handle_wake_tx_queue,\n\t.start\t\t\t= rt2x00mac_start,\n\t.stop\t\t\t= rt2x00mac_stop,\n\t.add_interface\t\t= rt2x00mac_add_interface,\n\t.remove_interface\t= rt2x00mac_remove_interface,\n\t.config\t\t\t= rt2x00mac_config,\n\t.configure_filter\t= rt2x00mac_configure_filter,\n\t.set_tim\t\t= rt2x00mac_set_tim,\n\t.set_key\t\t= rt2x00mac_set_key,\n\t.sw_scan_start\t\t= rt2x00mac_sw_scan_start,\n\t.sw_scan_complete\t= rt2x00mac_sw_scan_complete,\n\t.get_stats\t\t= rt2x00mac_get_stats,\n\t.bss_info_changed\t= rt2x00mac_bss_info_changed,\n\t.conf_tx\t\t= rt2x00mac_conf_tx,\n\t.rfkill_poll\t\t= rt2x00mac_rfkill_poll,\n\t.flush\t\t\t= rt2x00mac_flush,\n\t.set_antenna\t\t= rt2x00mac_set_antenna,\n\t.get_antenna\t\t= rt2x00mac_get_antenna,\n\t.get_ringparam\t\t= rt2x00mac_get_ringparam,\n\t.tx_frames_pending\t= rt2x00mac_tx_frames_pending,\n};\n\nstatic const struct rt2x00lib_ops rt2500usb_rt2x00_ops = {\n\t.probe_hw\t\t= rt2500usb_probe_hw,\n\t.initialize\t\t= rt2x00usb_initialize,\n\t.uninitialize\t\t= rt2x00usb_uninitialize,\n\t.clear_entry\t\t= rt2x00usb_clear_entry,\n\t.set_device_state\t= rt2500usb_set_device_state,\n\t.rfkill_poll\t\t= rt2500usb_rfkill_poll,\n\t.link_stats\t\t= rt2500usb_link_stats,\n\t.reset_tuner\t\t= rt2500usb_reset_tuner,\n\t.watchdog\t\t= rt2x00usb_watchdog,\n\t.start_queue\t\t= rt2500usb_start_queue,\n\t.kick_queue\t\t= rt2x00usb_kick_queue,\n\t.stop_queue\t\t= rt2500usb_stop_queue,\n\t.flush_queue\t\t= rt2x00usb_flush_queue,\n\t.write_tx_desc\t\t= rt2500usb_write_tx_desc,\n\t.write_beacon\t\t= rt2500usb_write_beacon,\n\t.get_tx_data_len\t= rt2500usb_get_tx_data_len,\n\t.fill_rxdone\t\t= rt2500usb_fill_rxdone,\n\t.config_shared_key\t= rt2500usb_config_key,\n\t.config_pairwise_key\t= rt2500usb_config_key,\n\t.config_filter\t\t= rt2500usb_config_filter,\n\t.config_intf\t\t= rt2500usb_config_intf,\n\t.config_erp\t\t= rt2500usb_config_erp,\n\t.config_ant\t\t= rt2500usb_config_ant,\n\t.config\t\t\t= rt2500usb_config,\n};\n\nstatic void rt2500usb_queue_init(struct data_queue *queue)\n{\n\tswitch (queue->qid) {\n\tcase QID_RX:\n\t\tqueue->limit = 32;\n\t\tqueue->data_size = DATA_FRAME_SIZE;\n\t\tqueue->desc_size = RXD_DESC_SIZE;\n\t\tqueue->priv_size = sizeof(struct queue_entry_priv_usb);\n\t\tbreak;\n\n\tcase QID_AC_VO:\n\tcase QID_AC_VI:\n\tcase QID_AC_BE:\n\tcase QID_AC_BK:\n\t\tqueue->limit = 32;\n\t\tqueue->data_size = DATA_FRAME_SIZE;\n\t\tqueue->desc_size = TXD_DESC_SIZE;\n\t\tqueue->priv_size = sizeof(struct queue_entry_priv_usb);\n\t\tbreak;\n\n\tcase QID_BEACON:\n\t\tqueue->limit = 1;\n\t\tqueue->data_size = MGMT_FRAME_SIZE;\n\t\tqueue->desc_size = TXD_DESC_SIZE;\n\t\tqueue->priv_size = sizeof(struct queue_entry_priv_usb_bcn);\n\t\tbreak;\n\n\tcase QID_ATIM:\n\t\tqueue->limit = 8;\n\t\tqueue->data_size = DATA_FRAME_SIZE;\n\t\tqueue->desc_size = TXD_DESC_SIZE;\n\t\tqueue->priv_size = sizeof(struct queue_entry_priv_usb);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n}\n\nstatic const struct rt2x00_ops rt2500usb_ops = {\n\t.name\t\t\t= KBUILD_MODNAME,\n\t.max_ap_intf\t\t= 1,\n\t.eeprom_size\t\t= EEPROM_SIZE,\n\t.rf_size\t\t= RF_SIZE,\n\t.tx_queues\t\t= NUM_TX_QUEUES,\n\t.queue_init\t\t= rt2500usb_queue_init,\n\t.lib\t\t\t= &rt2500usb_rt2x00_ops,\n\t.hw\t\t\t= &rt2500usb_mac80211_ops,\n#ifdef CONFIG_RT2X00_LIB_DEBUGFS\n\t.debugfs\t\t= &rt2500usb_rt2x00debug,\n#endif  \n};\n\n \nstatic const struct usb_device_id rt2500usb_device_table[] = {\n\t \n\t{ USB_DEVICE(0x0b05, 0x1706) },\n\t{ USB_DEVICE(0x0b05, 0x1707) },\n\t \n\t{ USB_DEVICE(0x050d, 0x7050) },\t \n\t{ USB_DEVICE(0x050d, 0x7051) },\n\t \n\t{ USB_DEVICE(0x13b1, 0x000d) },\n\t{ USB_DEVICE(0x13b1, 0x0011) },\n\t{ USB_DEVICE(0x13b1, 0x001a) },\n\t \n\t{ USB_DEVICE(0x14b2, 0x3c02) },\n\t \n\t{ USB_DEVICE(0x2001, 0x3c00) },\n\t \n\t{ USB_DEVICE(0x1044, 0x8001) },\n\t{ USB_DEVICE(0x1044, 0x8007) },\n\t \n\t{ USB_DEVICE(0x06f8, 0xe000) },\n\t \n\t{ USB_DEVICE(0x0411, 0x005e) },\n\t{ USB_DEVICE(0x0411, 0x0066) },\n\t{ USB_DEVICE(0x0411, 0x0067) },\n\t{ USB_DEVICE(0x0411, 0x008b) },\n\t{ USB_DEVICE(0x0411, 0x0097) },\n\t \n\t{ USB_DEVICE(0x0db0, 0x6861) },\n\t{ USB_DEVICE(0x0db0, 0x6865) },\n\t{ USB_DEVICE(0x0db0, 0x6869) },\n\t \n\t{ USB_DEVICE(0x148f, 0x1706) },\n\t{ USB_DEVICE(0x148f, 0x2570) },\n\t{ USB_DEVICE(0x148f, 0x9020) },\n\t \n\t{ USB_DEVICE(0x079b, 0x004b) },\n\t \n\t{ USB_DEVICE(0x0681, 0x3c06) },\n\t \n\t{ USB_DEVICE(0x0707, 0xee13) },\n\t \n\t{ USB_DEVICE(0x114b, 0x0110) },\n\t \n\t{ USB_DEVICE(0x0769, 0x11f3) },\n\t \n\t{ USB_DEVICE(0x0eb0, 0x9020) },\n\t \n\t{ USB_DEVICE(0x0f88, 0x3012) },\n\t \n\t{ USB_DEVICE(0x5a57, 0x0260) },\n\t{ 0, }\n};\n\nMODULE_AUTHOR(DRV_PROJECT);\nMODULE_VERSION(DRV_VERSION);\nMODULE_DESCRIPTION(\"Ralink RT2500 USB Wireless LAN driver.\");\nMODULE_DEVICE_TABLE(usb, rt2500usb_device_table);\nMODULE_LICENSE(\"GPL\");\n\nstatic int rt2500usb_probe(struct usb_interface *usb_intf,\n\t\t\t   const struct usb_device_id *id)\n{\n\treturn rt2x00usb_probe(usb_intf, &rt2500usb_ops);\n}\n\nstatic struct usb_driver rt2500usb_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= rt2500usb_device_table,\n\t.probe\t\t= rt2500usb_probe,\n\t.disconnect\t= rt2x00usb_disconnect,\n\t.suspend\t= rt2x00usb_suspend,\n\t.resume\t\t= rt2x00usb_resume,\n\t.reset_resume\t= rt2x00usb_resume,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(rt2500usb_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}