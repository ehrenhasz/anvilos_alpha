{
  "module_name": "rt2400pci.c",
  "hash_id": "78010bb09eab9dd10fc64e419d38a5f03c54bc73b8800ddedbadba1be45c1cc8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ralink/rt2x00/rt2400pci.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/delay.h>\n#include <linux/etherdevice.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/eeprom_93cx6.h>\n#include <linux/slab.h>\n\n#include \"rt2x00.h\"\n#include \"rt2x00mmio.h\"\n#include \"rt2x00pci.h\"\n#include \"rt2400pci.h\"\n\n \n#define WAIT_FOR_BBP(__dev, __reg) \\\n\trt2x00mmio_regbusy_read((__dev), BBPCSR, BBPCSR_BUSY, (__reg))\n#define WAIT_FOR_RF(__dev, __reg) \\\n\trt2x00mmio_regbusy_read((__dev), RFCSR, RFCSR_BUSY, (__reg))\n\nstatic void rt2400pci_bbp_write(struct rt2x00_dev *rt2x00dev,\n\t\t\t\tconst unsigned int word, const u8 value)\n{\n\tu32 reg;\n\n\tmutex_lock(&rt2x00dev->csr_mutex);\n\n\t \n\tif (WAIT_FOR_BBP(rt2x00dev, &reg)) {\n\t\treg = 0;\n\t\trt2x00_set_field32(&reg, BBPCSR_VALUE, value);\n\t\trt2x00_set_field32(&reg, BBPCSR_REGNUM, word);\n\t\trt2x00_set_field32(&reg, BBPCSR_BUSY, 1);\n\t\trt2x00_set_field32(&reg, BBPCSR_WRITE_CONTROL, 1);\n\n\t\trt2x00mmio_register_write(rt2x00dev, BBPCSR, reg);\n\t}\n\n\tmutex_unlock(&rt2x00dev->csr_mutex);\n}\n\nstatic u8 rt2400pci_bbp_read(struct rt2x00_dev *rt2x00dev,\n\t\t\t     const unsigned int word)\n{\n\tu32 reg;\n\tu8 value;\n\n\tmutex_lock(&rt2x00dev->csr_mutex);\n\n\t \n\tif (WAIT_FOR_BBP(rt2x00dev, &reg)) {\n\t\treg = 0;\n\t\trt2x00_set_field32(&reg, BBPCSR_REGNUM, word);\n\t\trt2x00_set_field32(&reg, BBPCSR_BUSY, 1);\n\t\trt2x00_set_field32(&reg, BBPCSR_WRITE_CONTROL, 0);\n\n\t\trt2x00mmio_register_write(rt2x00dev, BBPCSR, reg);\n\n\t\tWAIT_FOR_BBP(rt2x00dev, &reg);\n\t}\n\n\tvalue = rt2x00_get_field32(reg, BBPCSR_VALUE);\n\n\tmutex_unlock(&rt2x00dev->csr_mutex);\n\n\treturn value;\n}\n\nstatic void rt2400pci_rf_write(struct rt2x00_dev *rt2x00dev,\n\t\t\t       const unsigned int word, const u32 value)\n{\n\tu32 reg;\n\n\tmutex_lock(&rt2x00dev->csr_mutex);\n\n\t \n\tif (WAIT_FOR_RF(rt2x00dev, &reg)) {\n\t\treg = 0;\n\t\trt2x00_set_field32(&reg, RFCSR_VALUE, value);\n\t\trt2x00_set_field32(&reg, RFCSR_NUMBER_OF_BITS, 20);\n\t\trt2x00_set_field32(&reg, RFCSR_IF_SELECT, 0);\n\t\trt2x00_set_field32(&reg, RFCSR_BUSY, 1);\n\n\t\trt2x00mmio_register_write(rt2x00dev, RFCSR, reg);\n\t\trt2x00_rf_write(rt2x00dev, word, value);\n\t}\n\n\tmutex_unlock(&rt2x00dev->csr_mutex);\n}\n\nstatic void rt2400pci_eepromregister_read(struct eeprom_93cx6 *eeprom)\n{\n\tstruct rt2x00_dev *rt2x00dev = eeprom->data;\n\tu32 reg;\n\n\treg = rt2x00mmio_register_read(rt2x00dev, CSR21);\n\n\teeprom->reg_data_in = !!rt2x00_get_field32(reg, CSR21_EEPROM_DATA_IN);\n\teeprom->reg_data_out = !!rt2x00_get_field32(reg, CSR21_EEPROM_DATA_OUT);\n\teeprom->reg_data_clock =\n\t    !!rt2x00_get_field32(reg, CSR21_EEPROM_DATA_CLOCK);\n\teeprom->reg_chip_select =\n\t    !!rt2x00_get_field32(reg, CSR21_EEPROM_CHIP_SELECT);\n}\n\nstatic void rt2400pci_eepromregister_write(struct eeprom_93cx6 *eeprom)\n{\n\tstruct rt2x00_dev *rt2x00dev = eeprom->data;\n\tu32 reg = 0;\n\n\trt2x00_set_field32(&reg, CSR21_EEPROM_DATA_IN, !!eeprom->reg_data_in);\n\trt2x00_set_field32(&reg, CSR21_EEPROM_DATA_OUT, !!eeprom->reg_data_out);\n\trt2x00_set_field32(&reg, CSR21_EEPROM_DATA_CLOCK,\n\t\t\t   !!eeprom->reg_data_clock);\n\trt2x00_set_field32(&reg, CSR21_EEPROM_CHIP_SELECT,\n\t\t\t   !!eeprom->reg_chip_select);\n\n\trt2x00mmio_register_write(rt2x00dev, CSR21, reg);\n}\n\n#ifdef CONFIG_RT2X00_LIB_DEBUGFS\nstatic const struct rt2x00debug rt2400pci_rt2x00debug = {\n\t.owner\t= THIS_MODULE,\n\t.csr\t= {\n\t\t.read\t\t= rt2x00mmio_register_read,\n\t\t.write\t\t= rt2x00mmio_register_write,\n\t\t.flags\t\t= RT2X00DEBUGFS_OFFSET,\n\t\t.word_base\t= CSR_REG_BASE,\n\t\t.word_size\t= sizeof(u32),\n\t\t.word_count\t= CSR_REG_SIZE / sizeof(u32),\n\t},\n\t.eeprom\t= {\n\t\t.read\t\t= rt2x00_eeprom_read,\n\t\t.write\t\t= rt2x00_eeprom_write,\n\t\t.word_base\t= EEPROM_BASE,\n\t\t.word_size\t= sizeof(u16),\n\t\t.word_count\t= EEPROM_SIZE / sizeof(u16),\n\t},\n\t.bbp\t= {\n\t\t.read\t\t= rt2400pci_bbp_read,\n\t\t.write\t\t= rt2400pci_bbp_write,\n\t\t.word_base\t= BBP_BASE,\n\t\t.word_size\t= sizeof(u8),\n\t\t.word_count\t= BBP_SIZE / sizeof(u8),\n\t},\n\t.rf\t= {\n\t\t.read\t\t= rt2x00_rf_read,\n\t\t.write\t\t= rt2400pci_rf_write,\n\t\t.word_base\t= RF_BASE,\n\t\t.word_size\t= sizeof(u32),\n\t\t.word_count\t= RF_SIZE / sizeof(u32),\n\t},\n};\n#endif  \n\nstatic int rt2400pci_rfkill_poll(struct rt2x00_dev *rt2x00dev)\n{\n\tu32 reg;\n\n\treg = rt2x00mmio_register_read(rt2x00dev, GPIOCSR);\n\treturn rt2x00_get_field32(reg, GPIOCSR_VAL0);\n}\n\n#ifdef CONFIG_RT2X00_LIB_LEDS\nstatic void rt2400pci_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t     enum led_brightness brightness)\n{\n\tstruct rt2x00_led *led =\n\t    container_of(led_cdev, struct rt2x00_led, led_dev);\n\tunsigned int enabled = brightness != LED_OFF;\n\tu32 reg;\n\n\treg = rt2x00mmio_register_read(led->rt2x00dev, LEDCSR);\n\n\tif (led->type == LED_TYPE_RADIO || led->type == LED_TYPE_ASSOC)\n\t\trt2x00_set_field32(&reg, LEDCSR_LINK, enabled);\n\telse if (led->type == LED_TYPE_ACTIVITY)\n\t\trt2x00_set_field32(&reg, LEDCSR_ACTIVITY, enabled);\n\n\trt2x00mmio_register_write(led->rt2x00dev, LEDCSR, reg);\n}\n\nstatic int rt2400pci_blink_set(struct led_classdev *led_cdev,\n\t\t\t       unsigned long *delay_on,\n\t\t\t       unsigned long *delay_off)\n{\n\tstruct rt2x00_led *led =\n\t    container_of(led_cdev, struct rt2x00_led, led_dev);\n\tu32 reg;\n\n\treg = rt2x00mmio_register_read(led->rt2x00dev, LEDCSR);\n\trt2x00_set_field32(&reg, LEDCSR_ON_PERIOD, *delay_on);\n\trt2x00_set_field32(&reg, LEDCSR_OFF_PERIOD, *delay_off);\n\trt2x00mmio_register_write(led->rt2x00dev, LEDCSR, reg);\n\n\treturn 0;\n}\n\nstatic void rt2400pci_init_led(struct rt2x00_dev *rt2x00dev,\n\t\t\t       struct rt2x00_led *led,\n\t\t\t       enum led_type type)\n{\n\tled->rt2x00dev = rt2x00dev;\n\tled->type = type;\n\tled->led_dev.brightness_set = rt2400pci_brightness_set;\n\tled->led_dev.blink_set = rt2400pci_blink_set;\n\tled->flags = LED_INITIALIZED;\n}\n#endif  \n\n \nstatic void rt2400pci_config_filter(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t    const unsigned int filter_flags)\n{\n\tu32 reg;\n\n\t \n\treg = rt2x00mmio_register_read(rt2x00dev, RXCSR0);\n\trt2x00_set_field32(&reg, RXCSR0_DROP_CRC,\n\t\t\t   !(filter_flags & FIF_FCSFAIL));\n\trt2x00_set_field32(&reg, RXCSR0_DROP_PHYSICAL,\n\t\t\t   !(filter_flags & FIF_PLCPFAIL));\n\trt2x00_set_field32(&reg, RXCSR0_DROP_CONTROL,\n\t\t\t   !(filter_flags & FIF_CONTROL));\n\trt2x00_set_field32(&reg, RXCSR0_DROP_NOT_TO_ME,\n\t\t\t   !test_bit(CONFIG_MONITORING, &rt2x00dev->flags));\n\trt2x00_set_field32(&reg, RXCSR0_DROP_TODS,\n\t\t\t   !test_bit(CONFIG_MONITORING, &rt2x00dev->flags) &&\n\t\t\t   !rt2x00dev->intf_ap_count);\n\trt2x00_set_field32(&reg, RXCSR0_DROP_VERSION_ERROR, 1);\n\trt2x00mmio_register_write(rt2x00dev, RXCSR0, reg);\n}\n\nstatic void rt2400pci_config_intf(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t  struct rt2x00_intf *intf,\n\t\t\t\t  struct rt2x00intf_conf *conf,\n\t\t\t\t  const unsigned int flags)\n{\n\tunsigned int bcn_preload;\n\tu32 reg;\n\n\tif (flags & CONFIG_UPDATE_TYPE) {\n\t\t \n\t\tbcn_preload = PREAMBLE + GET_DURATION(IEEE80211_HEADER, 20);\n\t\treg = rt2x00mmio_register_read(rt2x00dev, BCNCSR1);\n\t\trt2x00_set_field32(&reg, BCNCSR1_PRELOAD, bcn_preload);\n\t\trt2x00mmio_register_write(rt2x00dev, BCNCSR1, reg);\n\n\t\t \n\t\treg = rt2x00mmio_register_read(rt2x00dev, CSR14);\n\t\trt2x00_set_field32(&reg, CSR14_TSF_SYNC, conf->sync);\n\t\trt2x00mmio_register_write(rt2x00dev, CSR14, reg);\n\t}\n\n\tif (flags & CONFIG_UPDATE_MAC)\n\t\trt2x00mmio_register_multiwrite(rt2x00dev, CSR3,\n\t\t\t\t\t       conf->mac, sizeof(conf->mac));\n\n\tif (flags & CONFIG_UPDATE_BSSID)\n\t\trt2x00mmio_register_multiwrite(rt2x00dev, CSR5,\n\t\t\t\t\t       conf->bssid,\n\t\t\t\t\t       sizeof(conf->bssid));\n}\n\nstatic void rt2400pci_config_erp(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t struct rt2x00lib_erp *erp,\n\t\t\t\t u32 changed)\n{\n\tint preamble_mask;\n\tu32 reg;\n\n\t \n\tif (changed & BSS_CHANGED_ERP_PREAMBLE) {\n\t\tpreamble_mask = erp->short_preamble << 3;\n\n\t\treg = rt2x00mmio_register_read(rt2x00dev, TXCSR1);\n\t\trt2x00_set_field32(&reg, TXCSR1_ACK_TIMEOUT, 0x1ff);\n\t\trt2x00_set_field32(&reg, TXCSR1_ACK_CONSUME_TIME, 0x13a);\n\t\trt2x00_set_field32(&reg, TXCSR1_TSF_OFFSET, IEEE80211_HEADER);\n\t\trt2x00_set_field32(&reg, TXCSR1_AUTORESPONDER, 1);\n\t\trt2x00mmio_register_write(rt2x00dev, TXCSR1, reg);\n\n\t\treg = rt2x00mmio_register_read(rt2x00dev, ARCSR2);\n\t\trt2x00_set_field32(&reg, ARCSR2_SIGNAL, 0x00);\n\t\trt2x00_set_field32(&reg, ARCSR2_SERVICE, 0x04);\n\t\trt2x00_set_field32(&reg, ARCSR2_LENGTH,\n\t\t\t\t   GET_DURATION(ACK_SIZE, 10));\n\t\trt2x00mmio_register_write(rt2x00dev, ARCSR2, reg);\n\n\t\treg = rt2x00mmio_register_read(rt2x00dev, ARCSR3);\n\t\trt2x00_set_field32(&reg, ARCSR3_SIGNAL, 0x01 | preamble_mask);\n\t\trt2x00_set_field32(&reg, ARCSR3_SERVICE, 0x04);\n\t\trt2x00_set_field32(&reg, ARCSR2_LENGTH,\n\t\t\t\t   GET_DURATION(ACK_SIZE, 20));\n\t\trt2x00mmio_register_write(rt2x00dev, ARCSR3, reg);\n\n\t\treg = rt2x00mmio_register_read(rt2x00dev, ARCSR4);\n\t\trt2x00_set_field32(&reg, ARCSR4_SIGNAL, 0x02 | preamble_mask);\n\t\trt2x00_set_field32(&reg, ARCSR4_SERVICE, 0x04);\n\t\trt2x00_set_field32(&reg, ARCSR2_LENGTH,\n\t\t\t\t   GET_DURATION(ACK_SIZE, 55));\n\t\trt2x00mmio_register_write(rt2x00dev, ARCSR4, reg);\n\n\t\treg = rt2x00mmio_register_read(rt2x00dev, ARCSR5);\n\t\trt2x00_set_field32(&reg, ARCSR5_SIGNAL, 0x03 | preamble_mask);\n\t\trt2x00_set_field32(&reg, ARCSR5_SERVICE, 0x84);\n\t\trt2x00_set_field32(&reg, ARCSR2_LENGTH,\n\t\t\t\t   GET_DURATION(ACK_SIZE, 110));\n\t\trt2x00mmio_register_write(rt2x00dev, ARCSR5, reg);\n\t}\n\n\tif (changed & BSS_CHANGED_BASIC_RATES)\n\t\trt2x00mmio_register_write(rt2x00dev, ARCSR1, erp->basic_rates);\n\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\treg = rt2x00mmio_register_read(rt2x00dev, CSR11);\n\t\trt2x00_set_field32(&reg, CSR11_SLOT_TIME, erp->slot_time);\n\t\trt2x00mmio_register_write(rt2x00dev, CSR11, reg);\n\n\t\treg = rt2x00mmio_register_read(rt2x00dev, CSR18);\n\t\trt2x00_set_field32(&reg, CSR18_SIFS, erp->sifs);\n\t\trt2x00_set_field32(&reg, CSR18_PIFS, erp->pifs);\n\t\trt2x00mmio_register_write(rt2x00dev, CSR18, reg);\n\n\t\treg = rt2x00mmio_register_read(rt2x00dev, CSR19);\n\t\trt2x00_set_field32(&reg, CSR19_DIFS, erp->difs);\n\t\trt2x00_set_field32(&reg, CSR19_EIFS, erp->eifs);\n\t\trt2x00mmio_register_write(rt2x00dev, CSR19, reg);\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON_INT) {\n\t\treg = rt2x00mmio_register_read(rt2x00dev, CSR12);\n\t\trt2x00_set_field32(&reg, CSR12_BEACON_INTERVAL,\n\t\t\t\t   erp->beacon_int * 16);\n\t\trt2x00_set_field32(&reg, CSR12_CFP_MAX_DURATION,\n\t\t\t\t   erp->beacon_int * 16);\n\t\trt2x00mmio_register_write(rt2x00dev, CSR12, reg);\n\t}\n}\n\nstatic void rt2400pci_config_ant(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t struct antenna_setup *ant)\n{\n\tu8 r1;\n\tu8 r4;\n\n\t \n\tBUG_ON(ant->rx == ANTENNA_SW_DIVERSITY ||\n\t       ant->tx == ANTENNA_SW_DIVERSITY);\n\n\tr4 = rt2400pci_bbp_read(rt2x00dev, 4);\n\tr1 = rt2400pci_bbp_read(rt2x00dev, 1);\n\n\t \n\tswitch (ant->tx) {\n\tcase ANTENNA_HW_DIVERSITY:\n\t\trt2x00_set_field8(&r1, BBP_R1_TX_ANTENNA, 1);\n\t\tbreak;\n\tcase ANTENNA_A:\n\t\trt2x00_set_field8(&r1, BBP_R1_TX_ANTENNA, 0);\n\t\tbreak;\n\tcase ANTENNA_B:\n\tdefault:\n\t\trt2x00_set_field8(&r1, BBP_R1_TX_ANTENNA, 2);\n\t\tbreak;\n\t}\n\n\t \n\tswitch (ant->rx) {\n\tcase ANTENNA_HW_DIVERSITY:\n\t\trt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA, 1);\n\t\tbreak;\n\tcase ANTENNA_A:\n\t\trt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA, 0);\n\t\tbreak;\n\tcase ANTENNA_B:\n\tdefault:\n\t\trt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA, 2);\n\t\tbreak;\n\t}\n\n\trt2400pci_bbp_write(rt2x00dev, 4, r4);\n\trt2400pci_bbp_write(rt2x00dev, 1, r1);\n}\n\nstatic void rt2400pci_config_channel(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t     struct rf_channel *rf)\n{\n\t \n\trt2x00_set_field32(&rf->rf1, RF1_TUNER, 1);\n\trt2x00_set_field32(&rf->rf3, RF3_TUNER, 1);\n\n\trt2400pci_rf_write(rt2x00dev, 1, rf->rf1);\n\trt2400pci_rf_write(rt2x00dev, 2, rf->rf2);\n\trt2400pci_rf_write(rt2x00dev, 3, rf->rf3);\n\n\t \n\tif (rt2x00_rf(rt2x00dev, RF2420))\n\t\treturn;\n\n\t \n\trt2400pci_rf_write(rt2x00dev, 1, rf->rf1);\n\trt2400pci_rf_write(rt2x00dev, 2, 0x000c2a32);\n\trt2400pci_rf_write(rt2x00dev, 3, rf->rf3);\n\n\tmsleep(1);\n\n\trt2400pci_rf_write(rt2x00dev, 1, rf->rf1);\n\trt2400pci_rf_write(rt2x00dev, 2, rf->rf2);\n\trt2400pci_rf_write(rt2x00dev, 3, rf->rf3);\n\n\tmsleep(1);\n\n\t \n\trt2x00_set_field32(&rf->rf1, RF1_TUNER, 0);\n\trt2x00_set_field32(&rf->rf3, RF3_TUNER, 0);\n\n\trt2400pci_rf_write(rt2x00dev, 1, rf->rf1);\n\trt2400pci_rf_write(rt2x00dev, 3, rf->rf3);\n\n\t \n\trf->rf1 = rt2x00mmio_register_read(rt2x00dev, CNT0);\n}\n\nstatic void rt2400pci_config_txpower(struct rt2x00_dev *rt2x00dev, int txpower)\n{\n\trt2400pci_bbp_write(rt2x00dev, 3, TXPOWER_TO_DEV(txpower));\n}\n\nstatic void rt2400pci_config_retry_limit(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t struct rt2x00lib_conf *libconf)\n{\n\tu32 reg;\n\n\treg = rt2x00mmio_register_read(rt2x00dev, CSR11);\n\trt2x00_set_field32(&reg, CSR11_LONG_RETRY,\n\t\t\t   libconf->conf->long_frame_max_tx_count);\n\trt2x00_set_field32(&reg, CSR11_SHORT_RETRY,\n\t\t\t   libconf->conf->short_frame_max_tx_count);\n\trt2x00mmio_register_write(rt2x00dev, CSR11, reg);\n}\n\nstatic void rt2400pci_config_ps(struct rt2x00_dev *rt2x00dev,\n\t\t\t\tstruct rt2x00lib_conf *libconf)\n{\n\tenum dev_state state =\n\t    (libconf->conf->flags & IEEE80211_CONF_PS) ?\n\t\tSTATE_SLEEP : STATE_AWAKE;\n\tu32 reg;\n\n\tif (state == STATE_SLEEP) {\n\t\treg = rt2x00mmio_register_read(rt2x00dev, CSR20);\n\t\trt2x00_set_field32(&reg, CSR20_DELAY_AFTER_TBCN,\n\t\t\t\t   (rt2x00dev->beacon_int - 20) * 16);\n\t\trt2x00_set_field32(&reg, CSR20_TBCN_BEFORE_WAKEUP,\n\t\t\t\t   libconf->conf->listen_interval - 1);\n\n\t\t \n\t\trt2x00_set_field32(&reg, CSR20_AUTOWAKE, 0);\n\t\trt2x00mmio_register_write(rt2x00dev, CSR20, reg);\n\n\t\trt2x00_set_field32(&reg, CSR20_AUTOWAKE, 1);\n\t\trt2x00mmio_register_write(rt2x00dev, CSR20, reg);\n\t} else {\n\t\treg = rt2x00mmio_register_read(rt2x00dev, CSR20);\n\t\trt2x00_set_field32(&reg, CSR20_AUTOWAKE, 0);\n\t\trt2x00mmio_register_write(rt2x00dev, CSR20, reg);\n\t}\n\n\trt2x00dev->ops->lib->set_device_state(rt2x00dev, state);\n}\n\nstatic void rt2400pci_config(struct rt2x00_dev *rt2x00dev,\n\t\t\t     struct rt2x00lib_conf *libconf,\n\t\t\t     const unsigned int flags)\n{\n\tif (flags & IEEE80211_CONF_CHANGE_CHANNEL)\n\t\trt2400pci_config_channel(rt2x00dev, &libconf->rf);\n\tif (flags & IEEE80211_CONF_CHANGE_POWER)\n\t\trt2400pci_config_txpower(rt2x00dev,\n\t\t\t\t\t libconf->conf->power_level);\n\tif (flags & IEEE80211_CONF_CHANGE_RETRY_LIMITS)\n\t\trt2400pci_config_retry_limit(rt2x00dev, libconf);\n\tif (flags & IEEE80211_CONF_CHANGE_PS)\n\t\trt2400pci_config_ps(rt2x00dev, libconf);\n}\n\nstatic void rt2400pci_config_cw(struct rt2x00_dev *rt2x00dev,\n\t\t\t\tconst int cw_min, const int cw_max)\n{\n\tu32 reg;\n\n\treg = rt2x00mmio_register_read(rt2x00dev, CSR11);\n\trt2x00_set_field32(&reg, CSR11_CWMIN, cw_min);\n\trt2x00_set_field32(&reg, CSR11_CWMAX, cw_max);\n\trt2x00mmio_register_write(rt2x00dev, CSR11, reg);\n}\n\n \nstatic void rt2400pci_link_stats(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t struct link_qual *qual)\n{\n\tu32 reg;\n\tu8 bbp;\n\n\t \n\treg = rt2x00mmio_register_read(rt2x00dev, CNT0);\n\tqual->rx_failed = rt2x00_get_field32(reg, CNT0_FCS_ERROR);\n\n\t \n\tbbp = rt2400pci_bbp_read(rt2x00dev, 39);\n\tqual->false_cca = bbp;\n}\n\nstatic inline void rt2400pci_set_vgc(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t     struct link_qual *qual, u8 vgc_level)\n{\n\tif (qual->vgc_level_reg != vgc_level) {\n\t\trt2400pci_bbp_write(rt2x00dev, 13, vgc_level);\n\t\tqual->vgc_level = vgc_level;\n\t\tqual->vgc_level_reg = vgc_level;\n\t}\n}\n\nstatic void rt2400pci_reset_tuner(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t  struct link_qual *qual)\n{\n\trt2400pci_set_vgc(rt2x00dev, qual, 0x08);\n}\n\nstatic void rt2400pci_link_tuner(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t struct link_qual *qual, const u32 count)\n{\n\t \n\tif (count > 60 || !(count & 1))\n\t\treturn;\n\n\t \n\tif ((qual->false_cca > 512) && (qual->vgc_level < 0x20))\n\t\trt2400pci_set_vgc(rt2x00dev, qual, ++qual->vgc_level);\n\telse if ((qual->false_cca < 100) && (qual->vgc_level > 0x08))\n\t\trt2400pci_set_vgc(rt2x00dev, qual, --qual->vgc_level);\n}\n\n \nstatic void rt2400pci_start_queue(struct data_queue *queue)\n{\n\tstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\n\tu32 reg;\n\n\tswitch (queue->qid) {\n\tcase QID_RX:\n\t\treg = rt2x00mmio_register_read(rt2x00dev, RXCSR0);\n\t\trt2x00_set_field32(&reg, RXCSR0_DISABLE_RX, 0);\n\t\trt2x00mmio_register_write(rt2x00dev, RXCSR0, reg);\n\t\tbreak;\n\tcase QID_BEACON:\n\t\treg = rt2x00mmio_register_read(rt2x00dev, CSR14);\n\t\trt2x00_set_field32(&reg, CSR14_TSF_COUNT, 1);\n\t\trt2x00_set_field32(&reg, CSR14_TBCN, 1);\n\t\trt2x00_set_field32(&reg, CSR14_BEACON_GEN, 1);\n\t\trt2x00mmio_register_write(rt2x00dev, CSR14, reg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void rt2400pci_kick_queue(struct data_queue *queue)\n{\n\tstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\n\tu32 reg;\n\n\tswitch (queue->qid) {\n\tcase QID_AC_VO:\n\t\treg = rt2x00mmio_register_read(rt2x00dev, TXCSR0);\n\t\trt2x00_set_field32(&reg, TXCSR0_KICK_PRIO, 1);\n\t\trt2x00mmio_register_write(rt2x00dev, TXCSR0, reg);\n\t\tbreak;\n\tcase QID_AC_VI:\n\t\treg = rt2x00mmio_register_read(rt2x00dev, TXCSR0);\n\t\trt2x00_set_field32(&reg, TXCSR0_KICK_TX, 1);\n\t\trt2x00mmio_register_write(rt2x00dev, TXCSR0, reg);\n\t\tbreak;\n\tcase QID_ATIM:\n\t\treg = rt2x00mmio_register_read(rt2x00dev, TXCSR0);\n\t\trt2x00_set_field32(&reg, TXCSR0_KICK_ATIM, 1);\n\t\trt2x00mmio_register_write(rt2x00dev, TXCSR0, reg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void rt2400pci_stop_queue(struct data_queue *queue)\n{\n\tstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\n\tu32 reg;\n\n\tswitch (queue->qid) {\n\tcase QID_AC_VO:\n\tcase QID_AC_VI:\n\tcase QID_ATIM:\n\t\treg = rt2x00mmio_register_read(rt2x00dev, TXCSR0);\n\t\trt2x00_set_field32(&reg, TXCSR0_ABORT, 1);\n\t\trt2x00mmio_register_write(rt2x00dev, TXCSR0, reg);\n\t\tbreak;\n\tcase QID_RX:\n\t\treg = rt2x00mmio_register_read(rt2x00dev, RXCSR0);\n\t\trt2x00_set_field32(&reg, RXCSR0_DISABLE_RX, 1);\n\t\trt2x00mmio_register_write(rt2x00dev, RXCSR0, reg);\n\t\tbreak;\n\tcase QID_BEACON:\n\t\treg = rt2x00mmio_register_read(rt2x00dev, CSR14);\n\t\trt2x00_set_field32(&reg, CSR14_TSF_COUNT, 0);\n\t\trt2x00_set_field32(&reg, CSR14_TBCN, 0);\n\t\trt2x00_set_field32(&reg, CSR14_BEACON_GEN, 0);\n\t\trt2x00mmio_register_write(rt2x00dev, CSR14, reg);\n\n\t\t \n\t\ttasklet_kill(&rt2x00dev->tbtt_tasklet);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic bool rt2400pci_get_entry_state(struct queue_entry *entry)\n{\n\tstruct queue_entry_priv_mmio *entry_priv = entry->priv_data;\n\tu32 word;\n\n\tif (entry->queue->qid == QID_RX) {\n\t\tword = rt2x00_desc_read(entry_priv->desc, 0);\n\n\t\treturn rt2x00_get_field32(word, RXD_W0_OWNER_NIC);\n\t} else {\n\t\tword = rt2x00_desc_read(entry_priv->desc, 0);\n\n\t\treturn (rt2x00_get_field32(word, TXD_W0_OWNER_NIC) ||\n\t\t        rt2x00_get_field32(word, TXD_W0_VALID));\n\t}\n}\n\nstatic void rt2400pci_clear_entry(struct queue_entry *entry)\n{\n\tstruct queue_entry_priv_mmio *entry_priv = entry->priv_data;\n\tstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\n\tu32 word;\n\n\tif (entry->queue->qid == QID_RX) {\n\t\tword = rt2x00_desc_read(entry_priv->desc, 2);\n\t\trt2x00_set_field32(&word, RXD_W2_BUFFER_LENGTH, entry->skb->len);\n\t\trt2x00_desc_write(entry_priv->desc, 2, word);\n\n\t\tword = rt2x00_desc_read(entry_priv->desc, 1);\n\t\trt2x00_set_field32(&word, RXD_W1_BUFFER_ADDRESS, skbdesc->skb_dma);\n\t\trt2x00_desc_write(entry_priv->desc, 1, word);\n\n\t\tword = rt2x00_desc_read(entry_priv->desc, 0);\n\t\trt2x00_set_field32(&word, RXD_W0_OWNER_NIC, 1);\n\t\trt2x00_desc_write(entry_priv->desc, 0, word);\n\t} else {\n\t\tword = rt2x00_desc_read(entry_priv->desc, 0);\n\t\trt2x00_set_field32(&word, TXD_W0_VALID, 0);\n\t\trt2x00_set_field32(&word, TXD_W0_OWNER_NIC, 0);\n\t\trt2x00_desc_write(entry_priv->desc, 0, word);\n\t}\n}\n\nstatic int rt2400pci_init_queues(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct queue_entry_priv_mmio *entry_priv;\n\tu32 reg;\n\n\t \n\treg = rt2x00mmio_register_read(rt2x00dev, TXCSR2);\n\trt2x00_set_field32(&reg, TXCSR2_TXD_SIZE, rt2x00dev->tx[0].desc_size);\n\trt2x00_set_field32(&reg, TXCSR2_NUM_TXD, rt2x00dev->tx[1].limit);\n\trt2x00_set_field32(&reg, TXCSR2_NUM_ATIM, rt2x00dev->atim->limit);\n\trt2x00_set_field32(&reg, TXCSR2_NUM_PRIO, rt2x00dev->tx[0].limit);\n\trt2x00mmio_register_write(rt2x00dev, TXCSR2, reg);\n\n\tentry_priv = rt2x00dev->tx[1].entries[0].priv_data;\n\treg = rt2x00mmio_register_read(rt2x00dev, TXCSR3);\n\trt2x00_set_field32(&reg, TXCSR3_TX_RING_REGISTER,\n\t\t\t   entry_priv->desc_dma);\n\trt2x00mmio_register_write(rt2x00dev, TXCSR3, reg);\n\n\tentry_priv = rt2x00dev->tx[0].entries[0].priv_data;\n\treg = rt2x00mmio_register_read(rt2x00dev, TXCSR5);\n\trt2x00_set_field32(&reg, TXCSR5_PRIO_RING_REGISTER,\n\t\t\t   entry_priv->desc_dma);\n\trt2x00mmio_register_write(rt2x00dev, TXCSR5, reg);\n\n\tentry_priv = rt2x00dev->atim->entries[0].priv_data;\n\treg = rt2x00mmio_register_read(rt2x00dev, TXCSR4);\n\trt2x00_set_field32(&reg, TXCSR4_ATIM_RING_REGISTER,\n\t\t\t   entry_priv->desc_dma);\n\trt2x00mmio_register_write(rt2x00dev, TXCSR4, reg);\n\n\tentry_priv = rt2x00dev->bcn->entries[0].priv_data;\n\treg = rt2x00mmio_register_read(rt2x00dev, TXCSR6);\n\trt2x00_set_field32(&reg, TXCSR6_BEACON_RING_REGISTER,\n\t\t\t   entry_priv->desc_dma);\n\trt2x00mmio_register_write(rt2x00dev, TXCSR6, reg);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, RXCSR1);\n\trt2x00_set_field32(&reg, RXCSR1_RXD_SIZE, rt2x00dev->rx->desc_size);\n\trt2x00_set_field32(&reg, RXCSR1_NUM_RXD, rt2x00dev->rx->limit);\n\trt2x00mmio_register_write(rt2x00dev, RXCSR1, reg);\n\n\tentry_priv = rt2x00dev->rx->entries[0].priv_data;\n\treg = rt2x00mmio_register_read(rt2x00dev, RXCSR2);\n\trt2x00_set_field32(&reg, RXCSR2_RX_RING_REGISTER,\n\t\t\t   entry_priv->desc_dma);\n\trt2x00mmio_register_write(rt2x00dev, RXCSR2, reg);\n\n\treturn 0;\n}\n\nstatic int rt2400pci_init_registers(struct rt2x00_dev *rt2x00dev)\n{\n\tu32 reg;\n\n\trt2x00mmio_register_write(rt2x00dev, PSCSR0, 0x00020002);\n\trt2x00mmio_register_write(rt2x00dev, PSCSR1, 0x00000002);\n\trt2x00mmio_register_write(rt2x00dev, PSCSR2, 0x00023f20);\n\trt2x00mmio_register_write(rt2x00dev, PSCSR3, 0x00000002);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, TIMECSR);\n\trt2x00_set_field32(&reg, TIMECSR_US_COUNT, 33);\n\trt2x00_set_field32(&reg, TIMECSR_US_64_COUNT, 63);\n\trt2x00_set_field32(&reg, TIMECSR_BEACON_EXPECT, 0);\n\trt2x00mmio_register_write(rt2x00dev, TIMECSR, reg);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, CSR9);\n\trt2x00_set_field32(&reg, CSR9_MAX_FRAME_UNIT,\n\t\t\t   (rt2x00dev->rx->data_size / 128));\n\trt2x00mmio_register_write(rt2x00dev, CSR9, reg);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, CSR14);\n\trt2x00_set_field32(&reg, CSR14_TSF_COUNT, 0);\n\trt2x00_set_field32(&reg, CSR14_TSF_SYNC, 0);\n\trt2x00_set_field32(&reg, CSR14_TBCN, 0);\n\trt2x00_set_field32(&reg, CSR14_TCFP, 0);\n\trt2x00_set_field32(&reg, CSR14_TATIMW, 0);\n\trt2x00_set_field32(&reg, CSR14_BEACON_GEN, 0);\n\trt2x00_set_field32(&reg, CSR14_CFP_COUNT_PRELOAD, 0);\n\trt2x00_set_field32(&reg, CSR14_TBCM_PRELOAD, 0);\n\trt2x00mmio_register_write(rt2x00dev, CSR14, reg);\n\n\trt2x00mmio_register_write(rt2x00dev, CNT3, 0x3f080000);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, ARCSR0);\n\trt2x00_set_field32(&reg, ARCSR0_AR_BBP_DATA0, 133);\n\trt2x00_set_field32(&reg, ARCSR0_AR_BBP_ID0, 134);\n\trt2x00_set_field32(&reg, ARCSR0_AR_BBP_DATA1, 136);\n\trt2x00_set_field32(&reg, ARCSR0_AR_BBP_ID1, 135);\n\trt2x00mmio_register_write(rt2x00dev, ARCSR0, reg);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, RXCSR3);\n\trt2x00_set_field32(&reg, RXCSR3_BBP_ID0, 3);  \n\trt2x00_set_field32(&reg, RXCSR3_BBP_ID0_VALID, 1);\n\trt2x00_set_field32(&reg, RXCSR3_BBP_ID1, 32);  \n\trt2x00_set_field32(&reg, RXCSR3_BBP_ID1_VALID, 1);\n\trt2x00_set_field32(&reg, RXCSR3_BBP_ID2, 36);  \n\trt2x00_set_field32(&reg, RXCSR3_BBP_ID2_VALID, 1);\n\trt2x00mmio_register_write(rt2x00dev, RXCSR3, reg);\n\n\trt2x00mmio_register_write(rt2x00dev, PWRCSR0, 0x3f3b3100);\n\n\tif (rt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_AWAKE))\n\t\treturn -EBUSY;\n\n\trt2x00mmio_register_write(rt2x00dev, MACCSR0, 0x00217223);\n\trt2x00mmio_register_write(rt2x00dev, MACCSR1, 0x00235518);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, MACCSR2);\n\trt2x00_set_field32(&reg, MACCSR2_DELAY, 64);\n\trt2x00mmio_register_write(rt2x00dev, MACCSR2, reg);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, RALINKCSR);\n\trt2x00_set_field32(&reg, RALINKCSR_AR_BBP_DATA0, 17);\n\trt2x00_set_field32(&reg, RALINKCSR_AR_BBP_ID0, 154);\n\trt2x00_set_field32(&reg, RALINKCSR_AR_BBP_DATA1, 0);\n\trt2x00_set_field32(&reg, RALINKCSR_AR_BBP_ID1, 154);\n\trt2x00mmio_register_write(rt2x00dev, RALINKCSR, reg);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, CSR1);\n\trt2x00_set_field32(&reg, CSR1_SOFT_RESET, 1);\n\trt2x00_set_field32(&reg, CSR1_BBP_RESET, 0);\n\trt2x00_set_field32(&reg, CSR1_HOST_READY, 0);\n\trt2x00mmio_register_write(rt2x00dev, CSR1, reg);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, CSR1);\n\trt2x00_set_field32(&reg, CSR1_SOFT_RESET, 0);\n\trt2x00_set_field32(&reg, CSR1_HOST_READY, 1);\n\trt2x00mmio_register_write(rt2x00dev, CSR1, reg);\n\n\t \n\treg = rt2x00mmio_register_read(rt2x00dev, CNT0);\n\treg = rt2x00mmio_register_read(rt2x00dev, CNT4);\n\n\treturn 0;\n}\n\nstatic int rt2400pci_wait_bbp_ready(struct rt2x00_dev *rt2x00dev)\n{\n\tunsigned int i;\n\tu8 value;\n\n\tfor (i = 0; i < REGISTER_BUSY_COUNT; i++) {\n\t\tvalue = rt2400pci_bbp_read(rt2x00dev, 0);\n\t\tif ((value != 0xff) && (value != 0x00))\n\t\t\treturn 0;\n\t\tudelay(REGISTER_BUSY_DELAY);\n\t}\n\n\trt2x00_err(rt2x00dev, \"BBP register access failed, aborting\\n\");\n\treturn -EACCES;\n}\n\nstatic int rt2400pci_init_bbp(struct rt2x00_dev *rt2x00dev)\n{\n\tunsigned int i;\n\tu16 eeprom;\n\tu8 reg_id;\n\tu8 value;\n\n\tif (unlikely(rt2400pci_wait_bbp_ready(rt2x00dev)))\n\t\treturn -EACCES;\n\n\trt2400pci_bbp_write(rt2x00dev, 1, 0x00);\n\trt2400pci_bbp_write(rt2x00dev, 3, 0x27);\n\trt2400pci_bbp_write(rt2x00dev, 4, 0x08);\n\trt2400pci_bbp_write(rt2x00dev, 10, 0x0f);\n\trt2400pci_bbp_write(rt2x00dev, 15, 0x72);\n\trt2400pci_bbp_write(rt2x00dev, 16, 0x74);\n\trt2400pci_bbp_write(rt2x00dev, 17, 0x20);\n\trt2400pci_bbp_write(rt2x00dev, 18, 0x72);\n\trt2400pci_bbp_write(rt2x00dev, 19, 0x0b);\n\trt2400pci_bbp_write(rt2x00dev, 20, 0x00);\n\trt2400pci_bbp_write(rt2x00dev, 28, 0x11);\n\trt2400pci_bbp_write(rt2x00dev, 29, 0x04);\n\trt2400pci_bbp_write(rt2x00dev, 30, 0x21);\n\trt2400pci_bbp_write(rt2x00dev, 31, 0x00);\n\n\tfor (i = 0; i < EEPROM_BBP_SIZE; i++) {\n\t\teeprom = rt2x00_eeprom_read(rt2x00dev, EEPROM_BBP_START + i);\n\n\t\tif (eeprom != 0xffff && eeprom != 0x0000) {\n\t\t\treg_id = rt2x00_get_field16(eeprom, EEPROM_BBP_REG_ID);\n\t\t\tvalue = rt2x00_get_field16(eeprom, EEPROM_BBP_VALUE);\n\t\t\trt2400pci_bbp_write(rt2x00dev, reg_id, value);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void rt2400pci_toggle_irq(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t enum dev_state state)\n{\n\tint mask = (state == STATE_RADIO_IRQ_OFF);\n\tu32 reg;\n\tunsigned long flags;\n\n\t \n\tif (state == STATE_RADIO_IRQ_ON) {\n\t\treg = rt2x00mmio_register_read(rt2x00dev, CSR7);\n\t\trt2x00mmio_register_write(rt2x00dev, CSR7, reg);\n\t}\n\n\t \n\tspin_lock_irqsave(&rt2x00dev->irqmask_lock, flags);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, CSR8);\n\trt2x00_set_field32(&reg, CSR8_TBCN_EXPIRE, mask);\n\trt2x00_set_field32(&reg, CSR8_TXDONE_TXRING, mask);\n\trt2x00_set_field32(&reg, CSR8_TXDONE_ATIMRING, mask);\n\trt2x00_set_field32(&reg, CSR8_TXDONE_PRIORING, mask);\n\trt2x00_set_field32(&reg, CSR8_RXDONE, mask);\n\trt2x00mmio_register_write(rt2x00dev, CSR8, reg);\n\n\tspin_unlock_irqrestore(&rt2x00dev->irqmask_lock, flags);\n\n\tif (state == STATE_RADIO_IRQ_OFF) {\n\t\t \n\t\ttasklet_kill(&rt2x00dev->txstatus_tasklet);\n\t\ttasklet_kill(&rt2x00dev->rxdone_tasklet);\n\t\ttasklet_kill(&rt2x00dev->tbtt_tasklet);\n\t}\n}\n\nstatic int rt2400pci_enable_radio(struct rt2x00_dev *rt2x00dev)\n{\n\t \n\tif (unlikely(rt2400pci_init_queues(rt2x00dev) ||\n\t\t     rt2400pci_init_registers(rt2x00dev) ||\n\t\t     rt2400pci_init_bbp(rt2x00dev)))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic void rt2400pci_disable_radio(struct rt2x00_dev *rt2x00dev)\n{\n\t \n\trt2x00mmio_register_write(rt2x00dev, PWRCSR0, 0);\n}\n\nstatic int rt2400pci_set_state(struct rt2x00_dev *rt2x00dev,\n\t\t\t       enum dev_state state)\n{\n\tu32 reg, reg2;\n\tunsigned int i;\n\tbool put_to_sleep;\n\tu8 bbp_state;\n\tu8 rf_state;\n\n\tput_to_sleep = (state != STATE_AWAKE);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, PWRCSR1);\n\trt2x00_set_field32(&reg, PWRCSR1_SET_STATE, 1);\n\trt2x00_set_field32(&reg, PWRCSR1_BBP_DESIRE_STATE, state);\n\trt2x00_set_field32(&reg, PWRCSR1_RF_DESIRE_STATE, state);\n\trt2x00_set_field32(&reg, PWRCSR1_PUT_TO_SLEEP, put_to_sleep);\n\trt2x00mmio_register_write(rt2x00dev, PWRCSR1, reg);\n\n\t \n\tfor (i = 0; i < REGISTER_BUSY_COUNT; i++) {\n\t\treg2 = rt2x00mmio_register_read(rt2x00dev, PWRCSR1);\n\t\tbbp_state = rt2x00_get_field32(reg2, PWRCSR1_BBP_CURR_STATE);\n\t\trf_state = rt2x00_get_field32(reg2, PWRCSR1_RF_CURR_STATE);\n\t\tif (bbp_state == state && rf_state == state)\n\t\t\treturn 0;\n\t\trt2x00mmio_register_write(rt2x00dev, PWRCSR1, reg);\n\t\tmsleep(10);\n\t}\n\n\treturn -EBUSY;\n}\n\nstatic int rt2400pci_set_device_state(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t      enum dev_state state)\n{\n\tint retval = 0;\n\n\tswitch (state) {\n\tcase STATE_RADIO_ON:\n\t\tretval = rt2400pci_enable_radio(rt2x00dev);\n\t\tbreak;\n\tcase STATE_RADIO_OFF:\n\t\trt2400pci_disable_radio(rt2x00dev);\n\t\tbreak;\n\tcase STATE_RADIO_IRQ_ON:\n\tcase STATE_RADIO_IRQ_OFF:\n\t\trt2400pci_toggle_irq(rt2x00dev, state);\n\t\tbreak;\n\tcase STATE_DEEP_SLEEP:\n\tcase STATE_SLEEP:\n\tcase STATE_STANDBY:\n\tcase STATE_AWAKE:\n\t\tretval = rt2400pci_set_state(rt2x00dev, state);\n\t\tbreak;\n\tdefault:\n\t\tretval = -ENOTSUPP;\n\t\tbreak;\n\t}\n\n\tif (unlikely(retval))\n\t\trt2x00_err(rt2x00dev, \"Device failed to enter state %d (%d)\\n\",\n\t\t\t   state, retval);\n\n\treturn retval;\n}\n\n \nstatic void rt2400pci_write_tx_desc(struct queue_entry *entry,\n\t\t\t\t    struct txentry_desc *txdesc)\n{\n\tstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\n\tstruct queue_entry_priv_mmio *entry_priv = entry->priv_data;\n\t__le32 *txd = entry_priv->desc;\n\tu32 word;\n\n\t \n\tword = rt2x00_desc_read(txd, 1);\n\trt2x00_set_field32(&word, TXD_W1_BUFFER_ADDRESS, skbdesc->skb_dma);\n\trt2x00_desc_write(txd, 1, word);\n\n\tword = rt2x00_desc_read(txd, 2);\n\trt2x00_set_field32(&word, TXD_W2_BUFFER_LENGTH, txdesc->length);\n\trt2x00_set_field32(&word, TXD_W2_DATABYTE_COUNT, txdesc->length);\n\trt2x00_desc_write(txd, 2, word);\n\n\tword = rt2x00_desc_read(txd, 3);\n\trt2x00_set_field32(&word, TXD_W3_PLCP_SIGNAL, txdesc->u.plcp.signal);\n\trt2x00_set_field32(&word, TXD_W3_PLCP_SIGNAL_REGNUM, 5);\n\trt2x00_set_field32(&word, TXD_W3_PLCP_SIGNAL_BUSY, 1);\n\trt2x00_set_field32(&word, TXD_W3_PLCP_SERVICE, txdesc->u.plcp.service);\n\trt2x00_set_field32(&word, TXD_W3_PLCP_SERVICE_REGNUM, 6);\n\trt2x00_set_field32(&word, TXD_W3_PLCP_SERVICE_BUSY, 1);\n\trt2x00_desc_write(txd, 3, word);\n\n\tword = rt2x00_desc_read(txd, 4);\n\trt2x00_set_field32(&word, TXD_W4_PLCP_LENGTH_LOW,\n\t\t\t   txdesc->u.plcp.length_low);\n\trt2x00_set_field32(&word, TXD_W3_PLCP_LENGTH_LOW_REGNUM, 8);\n\trt2x00_set_field32(&word, TXD_W3_PLCP_LENGTH_LOW_BUSY, 1);\n\trt2x00_set_field32(&word, TXD_W4_PLCP_LENGTH_HIGH,\n\t\t\t   txdesc->u.plcp.length_high);\n\trt2x00_set_field32(&word, TXD_W3_PLCP_LENGTH_HIGH_REGNUM, 7);\n\trt2x00_set_field32(&word, TXD_W3_PLCP_LENGTH_HIGH_BUSY, 1);\n\trt2x00_desc_write(txd, 4, word);\n\n\t \n\tword = rt2x00_desc_read(txd, 0);\n\trt2x00_set_field32(&word, TXD_W0_OWNER_NIC, 1);\n\trt2x00_set_field32(&word, TXD_W0_VALID, 1);\n\trt2x00_set_field32(&word, TXD_W0_MORE_FRAG,\n\t\t\t   test_bit(ENTRY_TXD_MORE_FRAG, &txdesc->flags));\n\trt2x00_set_field32(&word, TXD_W0_ACK,\n\t\t\t   test_bit(ENTRY_TXD_ACK, &txdesc->flags));\n\trt2x00_set_field32(&word, TXD_W0_TIMESTAMP,\n\t\t\t   test_bit(ENTRY_TXD_REQ_TIMESTAMP, &txdesc->flags));\n\trt2x00_set_field32(&word, TXD_W0_RTS,\n\t\t\t   test_bit(ENTRY_TXD_RTS_FRAME, &txdesc->flags));\n\trt2x00_set_field32(&word, TXD_W0_IFS, txdesc->u.plcp.ifs);\n\trt2x00_set_field32(&word, TXD_W0_RETRY_MODE,\n\t\t\t   test_bit(ENTRY_TXD_RETRY_MODE, &txdesc->flags));\n\trt2x00_desc_write(txd, 0, word);\n\n\t \n\tskbdesc->desc = txd;\n\tskbdesc->desc_len = TXD_DESC_SIZE;\n}\n\n \nstatic void rt2400pci_write_beacon(struct queue_entry *entry,\n\t\t\t\t   struct txentry_desc *txdesc)\n{\n\tstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\n\tu32 reg;\n\n\t \n\treg = rt2x00mmio_register_read(rt2x00dev, CSR14);\n\trt2x00_set_field32(&reg, CSR14_BEACON_GEN, 0);\n\trt2x00mmio_register_write(rt2x00dev, CSR14, reg);\n\n\tif (rt2x00queue_map_txskb(entry)) {\n\t\trt2x00_err(rt2x00dev, \"Fail to map beacon, aborting\\n\");\n\t\tgoto out;\n\t}\n\t \n\trt2x00_set_field32(&reg, CSR14_BEACON_GEN, 1);\n\t \n\trt2400pci_write_tx_desc(entry, txdesc);\n\n\t \n\trt2x00debug_dump_frame(rt2x00dev, DUMP_FRAME_BEACON, entry);\nout:\n\t \n\trt2x00_set_field32(&reg, CSR14_BEACON_GEN, 1);\n\trt2x00mmio_register_write(rt2x00dev, CSR14, reg);\n}\n\n \nstatic void rt2400pci_fill_rxdone(struct queue_entry *entry,\n\t\t\t\t  struct rxdone_entry_desc *rxdesc)\n{\n\tstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\n\tstruct queue_entry_priv_mmio *entry_priv = entry->priv_data;\n\tu32 word0;\n\tu32 word2;\n\tu32 word3;\n\tu32 word4;\n\tu64 tsf;\n\tu32 rx_low;\n\tu32 rx_high;\n\n\tword0 = rt2x00_desc_read(entry_priv->desc, 0);\n\tword2 = rt2x00_desc_read(entry_priv->desc, 2);\n\tword3 = rt2x00_desc_read(entry_priv->desc, 3);\n\tword4 = rt2x00_desc_read(entry_priv->desc, 4);\n\n\tif (rt2x00_get_field32(word0, RXD_W0_CRC_ERROR))\n\t\trxdesc->flags |= RX_FLAG_FAILED_FCS_CRC;\n\tif (rt2x00_get_field32(word0, RXD_W0_PHYSICAL_ERROR))\n\t\trxdesc->flags |= RX_FLAG_FAILED_PLCP_CRC;\n\n\t \n\ttsf = rt2x00dev->ops->hw->get_tsf(rt2x00dev->hw, NULL);\n\trx_low = rt2x00_get_field32(word4, RXD_W4_RX_END_TIME);\n\trx_high = upper_32_bits(tsf);\n\n\tif ((u32)tsf <= rx_low)\n\t\trx_high--;\n\n\t \n\trxdesc->timestamp = ((u64)rx_high << 32) | rx_low;\n\trxdesc->signal = rt2x00_get_field32(word2, RXD_W2_SIGNAL) & ~0x08;\n\trxdesc->rssi = rt2x00_get_field32(word3, RXD_W3_RSSI) -\n\t    entry->queue->rt2x00dev->rssi_offset;\n\trxdesc->size = rt2x00_get_field32(word0, RXD_W0_DATABYTE_COUNT);\n\n\trxdesc->dev_flags |= RXDONE_SIGNAL_PLCP;\n\tif (rt2x00_get_field32(word0, RXD_W0_MY_BSS))\n\t\trxdesc->dev_flags |= RXDONE_MY_BSS;\n}\n\n \nstatic void rt2400pci_txdone(struct rt2x00_dev *rt2x00dev,\n\t\t\t     const enum data_queue_qid queue_idx)\n{\n\tstruct data_queue *queue = rt2x00queue_get_tx_queue(rt2x00dev, queue_idx);\n\tstruct queue_entry_priv_mmio *entry_priv;\n\tstruct queue_entry *entry;\n\tstruct txdone_entry_desc txdesc;\n\tu32 word;\n\n\twhile (!rt2x00queue_empty(queue)) {\n\t\tentry = rt2x00queue_get_entry(queue, Q_INDEX_DONE);\n\t\tentry_priv = entry->priv_data;\n\t\tword = rt2x00_desc_read(entry_priv->desc, 0);\n\n\t\tif (rt2x00_get_field32(word, TXD_W0_OWNER_NIC) ||\n\t\t    !rt2x00_get_field32(word, TXD_W0_VALID))\n\t\t\tbreak;\n\n\t\t \n\t\ttxdesc.flags = 0;\n\t\tswitch (rt2x00_get_field32(word, TXD_W0_RESULT)) {\n\t\tcase 0:  \n\t\tcase 1:  \n\t\t\t__set_bit(TXDONE_SUCCESS, &txdesc.flags);\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\t__set_bit(TXDONE_EXCESSIVE_RETRY, &txdesc.flags);\n\t\t\tfallthrough;\t \n\t\tdefault:  \n\t\t\t__set_bit(TXDONE_FAILURE, &txdesc.flags);\n\t\t}\n\t\ttxdesc.retry = rt2x00_get_field32(word, TXD_W0_RETRY_COUNT);\n\n\t\trt2x00lib_txdone(entry, &txdesc);\n\t}\n}\n\nstatic inline void rt2400pci_enable_interrupt(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t      struct rt2x00_field32 irq_field)\n{\n\tu32 reg;\n\n\t \n\tspin_lock_irq(&rt2x00dev->irqmask_lock);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, CSR8);\n\trt2x00_set_field32(&reg, irq_field, 0);\n\trt2x00mmio_register_write(rt2x00dev, CSR8, reg);\n\n\tspin_unlock_irq(&rt2x00dev->irqmask_lock);\n}\n\nstatic void rt2400pci_txstatus_tasklet(struct tasklet_struct *t)\n{\n\tstruct rt2x00_dev *rt2x00dev = from_tasklet(rt2x00dev, t,\n\t\t\t\t\t\t    txstatus_tasklet);\n\tu32 reg;\n\n\t \n\trt2400pci_txdone(rt2x00dev, QID_ATIM);\n\trt2400pci_txdone(rt2x00dev, QID_AC_VO);\n\trt2400pci_txdone(rt2x00dev, QID_AC_VI);\n\n\t \n\tif (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags)) {\n\t\tspin_lock_irq(&rt2x00dev->irqmask_lock);\n\n\t\treg = rt2x00mmio_register_read(rt2x00dev, CSR8);\n\t\trt2x00_set_field32(&reg, CSR8_TXDONE_TXRING, 0);\n\t\trt2x00_set_field32(&reg, CSR8_TXDONE_ATIMRING, 0);\n\t\trt2x00_set_field32(&reg, CSR8_TXDONE_PRIORING, 0);\n\t\trt2x00mmio_register_write(rt2x00dev, CSR8, reg);\n\n\t\tspin_unlock_irq(&rt2x00dev->irqmask_lock);\n\t}\n}\n\nstatic void rt2400pci_tbtt_tasklet(struct tasklet_struct *t)\n{\n\tstruct rt2x00_dev *rt2x00dev = from_tasklet(rt2x00dev, t, tbtt_tasklet);\n\trt2x00lib_beacondone(rt2x00dev);\n\tif (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\trt2400pci_enable_interrupt(rt2x00dev, CSR8_TBCN_EXPIRE);\n}\n\nstatic void rt2400pci_rxdone_tasklet(struct tasklet_struct *t)\n{\n\tstruct rt2x00_dev *rt2x00dev = from_tasklet(rt2x00dev, t,\n\t\t\t\t\t\t    rxdone_tasklet);\n\tif (rt2x00mmio_rxdone(rt2x00dev))\n\t\ttasklet_schedule(&rt2x00dev->rxdone_tasklet);\n\telse if (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\trt2400pci_enable_interrupt(rt2x00dev, CSR8_RXDONE);\n}\n\nstatic irqreturn_t rt2400pci_interrupt(int irq, void *dev_instance)\n{\n\tstruct rt2x00_dev *rt2x00dev = dev_instance;\n\tu32 reg, mask;\n\n\t \n\treg = rt2x00mmio_register_read(rt2x00dev, CSR7);\n\trt2x00mmio_register_write(rt2x00dev, CSR7, reg);\n\n\tif (!reg)\n\t\treturn IRQ_NONE;\n\n\tif (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\treturn IRQ_HANDLED;\n\n\tmask = reg;\n\n\t \n\tif (rt2x00_get_field32(reg, CSR7_TBCN_EXPIRE))\n\t\ttasklet_hi_schedule(&rt2x00dev->tbtt_tasklet);\n\n\tif (rt2x00_get_field32(reg, CSR7_RXDONE))\n\t\ttasklet_schedule(&rt2x00dev->rxdone_tasklet);\n\n\tif (rt2x00_get_field32(reg, CSR7_TXDONE_ATIMRING) ||\n\t    rt2x00_get_field32(reg, CSR7_TXDONE_PRIORING) ||\n\t    rt2x00_get_field32(reg, CSR7_TXDONE_TXRING)) {\n\t\ttasklet_schedule(&rt2x00dev->txstatus_tasklet);\n\t\t \n\t\trt2x00_set_field32(&mask, CSR8_TXDONE_TXRING, 1);\n\t\trt2x00_set_field32(&mask, CSR8_TXDONE_ATIMRING, 1);\n\t\trt2x00_set_field32(&mask, CSR8_TXDONE_PRIORING, 1);\n\t}\n\n\t \n\tspin_lock(&rt2x00dev->irqmask_lock);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, CSR8);\n\treg |= mask;\n\trt2x00mmio_register_write(rt2x00dev, CSR8, reg);\n\n\tspin_unlock(&rt2x00dev->irqmask_lock);\n\n\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int rt2400pci_validate_eeprom(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct eeprom_93cx6 eeprom;\n\tu32 reg;\n\tu16 word;\n\tu8 *mac;\n\n\treg = rt2x00mmio_register_read(rt2x00dev, CSR21);\n\n\teeprom.data = rt2x00dev;\n\teeprom.register_read = rt2400pci_eepromregister_read;\n\teeprom.register_write = rt2400pci_eepromregister_write;\n\teeprom.width = rt2x00_get_field32(reg, CSR21_TYPE_93C46) ?\n\t    PCI_EEPROM_WIDTH_93C46 : PCI_EEPROM_WIDTH_93C66;\n\teeprom.reg_data_in = 0;\n\teeprom.reg_data_out = 0;\n\teeprom.reg_data_clock = 0;\n\teeprom.reg_chip_select = 0;\n\n\teeprom_93cx6_multiread(&eeprom, EEPROM_BASE, rt2x00dev->eeprom,\n\t\t\t       EEPROM_SIZE / sizeof(u16));\n\n\t \n\tmac = rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0);\n\trt2x00lib_set_mac_address(rt2x00dev, mac);\n\n\tword = rt2x00_eeprom_read(rt2x00dev, EEPROM_ANTENNA);\n\tif (word == 0xffff) {\n\t\trt2x00_err(rt2x00dev, \"Invalid EEPROM data detected\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rt2400pci_init_eeprom(struct rt2x00_dev *rt2x00dev)\n{\n\tu32 reg;\n\tu16 value;\n\tu16 eeprom;\n\n\t \n\teeprom = rt2x00_eeprom_read(rt2x00dev, EEPROM_ANTENNA);\n\n\t \n\tvalue = rt2x00_get_field16(eeprom, EEPROM_ANTENNA_RF_TYPE);\n\treg = rt2x00mmio_register_read(rt2x00dev, CSR0);\n\trt2x00_set_chip(rt2x00dev, RT2460, value,\n\t\t\trt2x00_get_field32(reg, CSR0_REVISION));\n\n\tif (!rt2x00_rf(rt2x00dev, RF2420) && !rt2x00_rf(rt2x00dev, RF2421)) {\n\t\trt2x00_err(rt2x00dev, \"Invalid RF chipset detected\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\trt2x00dev->default_ant.tx =\n\t    rt2x00_get_field16(eeprom, EEPROM_ANTENNA_TX_DEFAULT);\n\trt2x00dev->default_ant.rx =\n\t    rt2x00_get_field16(eeprom, EEPROM_ANTENNA_RX_DEFAULT);\n\n\t \n\tif (rt2x00dev->default_ant.tx == ANTENNA_SW_DIVERSITY)\n\t\trt2x00dev->default_ant.tx = ANTENNA_HW_DIVERSITY;\n\tif (rt2x00dev->default_ant.rx == ANTENNA_SW_DIVERSITY)\n\t\trt2x00dev->default_ant.rx = ANTENNA_HW_DIVERSITY;\n\n\t \n#ifdef CONFIG_RT2X00_LIB_LEDS\n\tvalue = rt2x00_get_field16(eeprom, EEPROM_ANTENNA_LED_MODE);\n\n\trt2400pci_init_led(rt2x00dev, &rt2x00dev->led_radio, LED_TYPE_RADIO);\n\tif (value == LED_MODE_TXRX_ACTIVITY ||\n\t    value == LED_MODE_DEFAULT ||\n\t    value == LED_MODE_ASUS)\n\t\trt2400pci_init_led(rt2x00dev, &rt2x00dev->led_qual,\n\t\t\t\t   LED_TYPE_ACTIVITY);\n#endif  \n\n\t \n\tif (rt2x00_get_field16(eeprom, EEPROM_ANTENNA_HARDWARE_RADIO))\n\t\t__set_bit(CAPABILITY_HW_BUTTON, &rt2x00dev->cap_flags);\n\n\t \n\tif (rt2x00_get_field16(eeprom, EEPROM_ANTENNA_RX_AGCVGC_TUNING))\n\t\t__set_bit(CAPABILITY_LINK_TUNING, &rt2x00dev->cap_flags);\n\n\treturn 0;\n}\n\n \nstatic const struct rf_channel rf_vals_b[] = {\n\t{ 1,  0x00022058, 0x000c1fda, 0x00000101, 0 },\n\t{ 2,  0x00022058, 0x000c1fee, 0x00000101, 0 },\n\t{ 3,  0x00022058, 0x000c2002, 0x00000101, 0 },\n\t{ 4,  0x00022058, 0x000c2016, 0x00000101, 0 },\n\t{ 5,  0x00022058, 0x000c202a, 0x00000101, 0 },\n\t{ 6,  0x00022058, 0x000c203e, 0x00000101, 0 },\n\t{ 7,  0x00022058, 0x000c2052, 0x00000101, 0 },\n\t{ 8,  0x00022058, 0x000c2066, 0x00000101, 0 },\n\t{ 9,  0x00022058, 0x000c207a, 0x00000101, 0 },\n\t{ 10, 0x00022058, 0x000c208e, 0x00000101, 0 },\n\t{ 11, 0x00022058, 0x000c20a2, 0x00000101, 0 },\n\t{ 12, 0x00022058, 0x000c20b6, 0x00000101, 0 },\n\t{ 13, 0x00022058, 0x000c20ca, 0x00000101, 0 },\n\t{ 14, 0x00022058, 0x000c20fa, 0x00000101, 0 },\n};\n\nstatic int rt2400pci_probe_hw_mode(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct hw_mode_spec *spec = &rt2x00dev->spec;\n\tstruct channel_info *info;\n\tu8 *tx_power;\n\tunsigned int i;\n\n\t \n\tieee80211_hw_set(rt2x00dev->hw, PS_NULLFUNC_STACK);\n\tieee80211_hw_set(rt2x00dev->hw, SUPPORTS_PS);\n\tieee80211_hw_set(rt2x00dev->hw, HOST_BROADCAST_PS_BUFFERING);\n\tieee80211_hw_set(rt2x00dev->hw, SIGNAL_DBM);\n\n\tSET_IEEE80211_DEV(rt2x00dev->hw, rt2x00dev->dev);\n\tSET_IEEE80211_PERM_ADDR(rt2x00dev->hw,\n\t\t\t\trt2x00_eeprom_addr(rt2x00dev,\n\t\t\t\t\t\t   EEPROM_MAC_ADDR_0));\n\n\t \n\tspec->supported_bands = SUPPORT_BAND_2GHZ;\n\tspec->supported_rates = SUPPORT_RATE_CCK;\n\n\tspec->num_channels = ARRAY_SIZE(rf_vals_b);\n\tspec->channels = rf_vals_b;\n\n\t \n\tinfo = kcalloc(spec->num_channels, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tspec->channels_info = info;\n\n\ttx_power = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_START);\n\tfor (i = 0; i < 14; i++) {\n\t\tinfo[i].max_power = TXPOWER_FROM_DEV(MAX_TXPOWER);\n\t\tinfo[i].default_power1 = TXPOWER_FROM_DEV(tx_power[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int rt2400pci_probe_hw(struct rt2x00_dev *rt2x00dev)\n{\n\tint retval;\n\tu32 reg;\n\n\t \n\tretval = rt2400pci_validate_eeprom(rt2x00dev);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = rt2400pci_init_eeprom(rt2x00dev);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\treg = rt2x00mmio_register_read(rt2x00dev, GPIOCSR);\n\trt2x00_set_field32(&reg, GPIOCSR_DIR0, 1);\n\trt2x00mmio_register_write(rt2x00dev, GPIOCSR, reg);\n\n\t \n\tretval = rt2400pci_probe_hw_mode(rt2x00dev);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\t__set_bit(REQUIRE_ATIM_QUEUE, &rt2x00dev->cap_flags);\n\t__set_bit(REQUIRE_DMA, &rt2x00dev->cap_flags);\n\t__set_bit(REQUIRE_SW_SEQNO, &rt2x00dev->cap_flags);\n\n\t \n\trt2x00dev->rssi_offset = DEFAULT_RSSI_OFFSET;\n\n\treturn 0;\n}\n\n \nstatic int rt2400pci_conf_tx(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     unsigned int link_id, u16 queue,\n\t\t\t     const struct ieee80211_tx_queue_params *params)\n{\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\n\t \n\tif (queue != 0)\n\t\treturn -EINVAL;\n\n\tif (rt2x00mac_conf_tx(hw, vif, link_id, queue, params))\n\t\treturn -EINVAL;\n\n\t \n\trt2400pci_config_cw(rt2x00dev,\n\t\t\t    rt2x00dev->tx->cw_min, rt2x00dev->tx->cw_max);\n\n\treturn 0;\n}\n\nstatic u64 rt2400pci_get_tsf(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\tu64 tsf;\n\tu32 reg;\n\n\treg = rt2x00mmio_register_read(rt2x00dev, CSR17);\n\ttsf = (u64) rt2x00_get_field32(reg, CSR17_HIGH_TSFTIMER) << 32;\n\treg = rt2x00mmio_register_read(rt2x00dev, CSR16);\n\ttsf |= rt2x00_get_field32(reg, CSR16_LOW_TSFTIMER);\n\n\treturn tsf;\n}\n\nstatic int rt2400pci_tx_last_beacon(struct ieee80211_hw *hw)\n{\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\tu32 reg;\n\n\treg = rt2x00mmio_register_read(rt2x00dev, CSR15);\n\treturn rt2x00_get_field32(reg, CSR15_BEACON_SENT);\n}\n\nstatic const struct ieee80211_ops rt2400pci_mac80211_ops = {\n\t.tx\t\t\t= rt2x00mac_tx,\n\t.wake_tx_queue\t\t= ieee80211_handle_wake_tx_queue,\n\t.start\t\t\t= rt2x00mac_start,\n\t.stop\t\t\t= rt2x00mac_stop,\n\t.add_interface\t\t= rt2x00mac_add_interface,\n\t.remove_interface\t= rt2x00mac_remove_interface,\n\t.config\t\t\t= rt2x00mac_config,\n\t.configure_filter\t= rt2x00mac_configure_filter,\n\t.sw_scan_start\t\t= rt2x00mac_sw_scan_start,\n\t.sw_scan_complete\t= rt2x00mac_sw_scan_complete,\n\t.get_stats\t\t= rt2x00mac_get_stats,\n\t.bss_info_changed\t= rt2x00mac_bss_info_changed,\n\t.conf_tx\t\t= rt2400pci_conf_tx,\n\t.get_tsf\t\t= rt2400pci_get_tsf,\n\t.tx_last_beacon\t\t= rt2400pci_tx_last_beacon,\n\t.rfkill_poll\t\t= rt2x00mac_rfkill_poll,\n\t.flush\t\t\t= rt2x00mac_flush,\n\t.set_antenna\t\t= rt2x00mac_set_antenna,\n\t.get_antenna\t\t= rt2x00mac_get_antenna,\n\t.get_ringparam\t\t= rt2x00mac_get_ringparam,\n\t.tx_frames_pending\t= rt2x00mac_tx_frames_pending,\n};\n\nstatic const struct rt2x00lib_ops rt2400pci_rt2x00_ops = {\n\t.irq_handler\t\t= rt2400pci_interrupt,\n\t.txstatus_tasklet\t= rt2400pci_txstatus_tasklet,\n\t.tbtt_tasklet\t\t= rt2400pci_tbtt_tasklet,\n\t.rxdone_tasklet\t\t= rt2400pci_rxdone_tasklet,\n\t.probe_hw\t\t= rt2400pci_probe_hw,\n\t.initialize\t\t= rt2x00mmio_initialize,\n\t.uninitialize\t\t= rt2x00mmio_uninitialize,\n\t.get_entry_state\t= rt2400pci_get_entry_state,\n\t.clear_entry\t\t= rt2400pci_clear_entry,\n\t.set_device_state\t= rt2400pci_set_device_state,\n\t.rfkill_poll\t\t= rt2400pci_rfkill_poll,\n\t.link_stats\t\t= rt2400pci_link_stats,\n\t.reset_tuner\t\t= rt2400pci_reset_tuner,\n\t.link_tuner\t\t= rt2400pci_link_tuner,\n\t.start_queue\t\t= rt2400pci_start_queue,\n\t.kick_queue\t\t= rt2400pci_kick_queue,\n\t.stop_queue\t\t= rt2400pci_stop_queue,\n\t.flush_queue\t\t= rt2x00mmio_flush_queue,\n\t.write_tx_desc\t\t= rt2400pci_write_tx_desc,\n\t.write_beacon\t\t= rt2400pci_write_beacon,\n\t.fill_rxdone\t\t= rt2400pci_fill_rxdone,\n\t.config_filter\t\t= rt2400pci_config_filter,\n\t.config_intf\t\t= rt2400pci_config_intf,\n\t.config_erp\t\t= rt2400pci_config_erp,\n\t.config_ant\t\t= rt2400pci_config_ant,\n\t.config\t\t\t= rt2400pci_config,\n};\n\nstatic void rt2400pci_queue_init(struct data_queue *queue)\n{\n\tswitch (queue->qid) {\n\tcase QID_RX:\n\t\tqueue->limit = 24;\n\t\tqueue->data_size = DATA_FRAME_SIZE;\n\t\tqueue->desc_size = RXD_DESC_SIZE;\n\t\tqueue->priv_size = sizeof(struct queue_entry_priv_mmio);\n\t\tbreak;\n\n\tcase QID_AC_VO:\n\tcase QID_AC_VI:\n\tcase QID_AC_BE:\n\tcase QID_AC_BK:\n\t\tqueue->limit = 24;\n\t\tqueue->data_size = DATA_FRAME_SIZE;\n\t\tqueue->desc_size = TXD_DESC_SIZE;\n\t\tqueue->priv_size = sizeof(struct queue_entry_priv_mmio);\n\t\tbreak;\n\n\tcase QID_BEACON:\n\t\tqueue->limit = 1;\n\t\tqueue->data_size = MGMT_FRAME_SIZE;\n\t\tqueue->desc_size = TXD_DESC_SIZE;\n\t\tqueue->priv_size = sizeof(struct queue_entry_priv_mmio);\n\t\tbreak;\n\n\tcase QID_ATIM:\n\t\tqueue->limit = 8;\n\t\tqueue->data_size = DATA_FRAME_SIZE;\n\t\tqueue->desc_size = TXD_DESC_SIZE;\n\t\tqueue->priv_size = sizeof(struct queue_entry_priv_mmio);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n}\n\nstatic const struct rt2x00_ops rt2400pci_ops = {\n\t.name\t\t\t= KBUILD_MODNAME,\n\t.max_ap_intf\t\t= 1,\n\t.eeprom_size\t\t= EEPROM_SIZE,\n\t.rf_size\t\t= RF_SIZE,\n\t.tx_queues\t\t= NUM_TX_QUEUES,\n\t.queue_init\t\t= rt2400pci_queue_init,\n\t.lib\t\t\t= &rt2400pci_rt2x00_ops,\n\t.hw\t\t\t= &rt2400pci_mac80211_ops,\n#ifdef CONFIG_RT2X00_LIB_DEBUGFS\n\t.debugfs\t\t= &rt2400pci_rt2x00debug,\n#endif  \n};\n\n \nstatic const struct pci_device_id rt2400pci_device_table[] = {\n\t{ PCI_DEVICE(0x1814, 0x0101) },\n\t{ 0, }\n};\n\n\nMODULE_AUTHOR(DRV_PROJECT);\nMODULE_VERSION(DRV_VERSION);\nMODULE_DESCRIPTION(\"Ralink RT2400 PCI & PCMCIA Wireless LAN driver.\");\nMODULE_DEVICE_TABLE(pci, rt2400pci_device_table);\nMODULE_LICENSE(\"GPL\");\n\nstatic int rt2400pci_probe(struct pci_dev *pci_dev,\n\t\t\t   const struct pci_device_id *id)\n{\n\treturn rt2x00pci_probe(pci_dev, &rt2400pci_ops);\n}\n\nstatic struct pci_driver rt2400pci_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= rt2400pci_device_table,\n\t.probe\t\t= rt2400pci_probe,\n\t.remove\t\t= rt2x00pci_remove,\n\t.driver.pm\t= &rt2x00pci_pm_ops,\n};\n\nmodule_pci_driver(rt2400pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}