{
  "module_name": "rt2800soc.c",
  "hash_id": "a8a10afc9b472c05c1c85d045e563c4c665517f0301bb8d90d3cc6dd9927a69b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ralink/rt2x00/rt2800soc.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/etherdevice.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#include \"rt2x00.h\"\n#include \"rt2x00mmio.h\"\n#include \"rt2x00soc.h\"\n#include \"rt2800.h\"\n#include \"rt2800lib.h\"\n#include \"rt2800mmio.h\"\n\n \nstatic bool modparam_nohwcrypt;\nmodule_param_named(nohwcrypt, modparam_nohwcrypt, bool, 0444);\nMODULE_PARM_DESC(nohwcrypt, \"Disable hardware encryption.\");\n\nstatic bool rt2800soc_hwcrypt_disabled(struct rt2x00_dev *rt2x00dev)\n{\n\treturn modparam_nohwcrypt;\n}\n\nstatic void rt2800soc_disable_radio(struct rt2x00_dev *rt2x00dev)\n{\n\tu32 reg;\n\n\trt2800_disable_radio(rt2x00dev);\n\trt2x00mmio_register_write(rt2x00dev, PWR_PIN_CFG, 0);\n\n\treg = 0;\n\tif (rt2x00_rt(rt2x00dev, RT3883))\n\t\trt2x00_set_field32(&reg, TX_PIN_CFG_RFTR_EN, 1);\n\n\trt2x00mmio_register_write(rt2x00dev, TX_PIN_CFG, reg);\n}\n\nstatic int rt2800soc_set_device_state(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t      enum dev_state state)\n{\n\tint retval = 0;\n\n\tswitch (state) {\n\tcase STATE_RADIO_ON:\n\t\tretval = rt2800mmio_enable_radio(rt2x00dev);\n\t\tbreak;\n\n\tcase STATE_RADIO_OFF:\n\t\trt2800soc_disable_radio(rt2x00dev);\n\t\tbreak;\n\n\tcase STATE_RADIO_IRQ_ON:\n\tcase STATE_RADIO_IRQ_OFF:\n\t\trt2800mmio_toggle_irq(rt2x00dev, state);\n\t\tbreak;\n\n\tcase STATE_DEEP_SLEEP:\n\tcase STATE_SLEEP:\n\tcase STATE_STANDBY:\n\tcase STATE_AWAKE:\n\t\t \n\t\tretval = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tretval = -ENOTSUPP;\n\t\tbreak;\n\t}\n\n\tif (unlikely(retval))\n\t\trt2x00_err(rt2x00dev, \"Device failed to enter state %d (%d)\\n\",\n\t\t\t   state, retval);\n\n\treturn retval;\n}\n\nstatic int rt2800soc_read_eeprom(struct rt2x00_dev *rt2x00dev)\n{\n\tvoid __iomem *base_addr = ioremap(0x1F040000, EEPROM_SIZE);\n\n\tif (!base_addr)\n\t\treturn -ENOMEM;\n\n\tmemcpy_fromio(rt2x00dev->eeprom, base_addr, EEPROM_SIZE);\n\n\tiounmap(base_addr);\n\treturn 0;\n}\n\n \nstatic char *rt2800soc_get_firmware_name(struct rt2x00_dev *rt2x00dev)\n{\n\tWARN_ON_ONCE(1);\n\treturn NULL;\n}\n\nstatic int rt2800soc_load_firmware(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t   const u8 *data, const size_t len)\n{\n\tWARN_ON_ONCE(1);\n\treturn 0;\n}\n\nstatic int rt2800soc_check_firmware(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t    const u8 *data, const size_t len)\n{\n\tWARN_ON_ONCE(1);\n\treturn 0;\n}\n\nstatic int rt2800soc_write_firmware(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t    const u8 *data, const size_t len)\n{\n\tWARN_ON_ONCE(1);\n\treturn 0;\n}\n\nstatic const struct ieee80211_ops rt2800soc_mac80211_ops = {\n\t.tx\t\t\t= rt2x00mac_tx,\n\t.wake_tx_queue\t\t= ieee80211_handle_wake_tx_queue,\n\t.start\t\t\t= rt2x00mac_start,\n\t.stop\t\t\t= rt2x00mac_stop,\n\t.add_interface\t\t= rt2x00mac_add_interface,\n\t.remove_interface\t= rt2x00mac_remove_interface,\n\t.config\t\t\t= rt2x00mac_config,\n\t.configure_filter\t= rt2x00mac_configure_filter,\n\t.set_key\t\t= rt2x00mac_set_key,\n\t.sw_scan_start\t\t= rt2x00mac_sw_scan_start,\n\t.sw_scan_complete\t= rt2x00mac_sw_scan_complete,\n\t.get_stats\t\t= rt2x00mac_get_stats,\n\t.get_key_seq\t\t= rt2800_get_key_seq,\n\t.set_rts_threshold\t= rt2800_set_rts_threshold,\n\t.sta_add\t\t= rt2800_sta_add,\n\t.sta_remove\t\t= rt2800_sta_remove,\n\t.bss_info_changed\t= rt2x00mac_bss_info_changed,\n\t.conf_tx\t\t= rt2800_conf_tx,\n\t.get_tsf\t\t= rt2800_get_tsf,\n\t.rfkill_poll\t\t= rt2x00mac_rfkill_poll,\n\t.ampdu_action\t\t= rt2800_ampdu_action,\n\t.flush\t\t\t= rt2x00mac_flush,\n\t.get_survey\t\t= rt2800_get_survey,\n\t.get_ringparam\t\t= rt2x00mac_get_ringparam,\n\t.tx_frames_pending\t= rt2x00mac_tx_frames_pending,\n\t.reconfig_complete\t= rt2x00mac_reconfig_complete,\n};\n\nstatic const struct rt2800_ops rt2800soc_rt2800_ops = {\n\t.register_read\t\t= rt2x00mmio_register_read,\n\t.register_read_lock\t= rt2x00mmio_register_read,  \n\t.register_write\t\t= rt2x00mmio_register_write,\n\t.register_write_lock\t= rt2x00mmio_register_write,  \n\t.register_multiread\t= rt2x00mmio_register_multiread,\n\t.register_multiwrite\t= rt2x00mmio_register_multiwrite,\n\t.regbusy_read\t\t= rt2x00mmio_regbusy_read,\n\t.read_eeprom\t\t= rt2800soc_read_eeprom,\n\t.hwcrypt_disabled\t= rt2800soc_hwcrypt_disabled,\n\t.drv_write_firmware\t= rt2800soc_write_firmware,\n\t.drv_init_registers\t= rt2800mmio_init_registers,\n\t.drv_get_txwi\t\t= rt2800mmio_get_txwi,\n\t.drv_get_dma_done\t= rt2800mmio_get_dma_done,\n};\n\nstatic const struct rt2x00lib_ops rt2800soc_rt2x00_ops = {\n\t.irq_handler\t\t= rt2800mmio_interrupt,\n\t.txstatus_tasklet\t= rt2800mmio_txstatus_tasklet,\n\t.pretbtt_tasklet\t= rt2800mmio_pretbtt_tasklet,\n\t.tbtt_tasklet\t\t= rt2800mmio_tbtt_tasklet,\n\t.rxdone_tasklet\t\t= rt2800mmio_rxdone_tasklet,\n\t.autowake_tasklet\t= rt2800mmio_autowake_tasklet,\n\t.probe_hw\t\t= rt2800mmio_probe_hw,\n\t.get_firmware_name\t= rt2800soc_get_firmware_name,\n\t.check_firmware\t\t= rt2800soc_check_firmware,\n\t.load_firmware\t\t= rt2800soc_load_firmware,\n\t.initialize\t\t= rt2x00mmio_initialize,\n\t.uninitialize\t\t= rt2x00mmio_uninitialize,\n\t.get_entry_state\t= rt2800mmio_get_entry_state,\n\t.clear_entry\t\t= rt2800mmio_clear_entry,\n\t.set_device_state\t= rt2800soc_set_device_state,\n\t.rfkill_poll\t\t= rt2800_rfkill_poll,\n\t.link_stats\t\t= rt2800_link_stats,\n\t.reset_tuner\t\t= rt2800_reset_tuner,\n\t.link_tuner\t\t= rt2800_link_tuner,\n\t.gain_calibration\t= rt2800_gain_calibration,\n\t.vco_calibration\t= rt2800_vco_calibration,\n\t.watchdog\t\t= rt2800_watchdog,\n\t.start_queue\t\t= rt2800mmio_start_queue,\n\t.kick_queue\t\t= rt2800mmio_kick_queue,\n\t.stop_queue\t\t= rt2800mmio_stop_queue,\n\t.flush_queue\t\t= rt2800mmio_flush_queue,\n\t.write_tx_desc\t\t= rt2800mmio_write_tx_desc,\n\t.write_tx_data\t\t= rt2800_write_tx_data,\n\t.write_beacon\t\t= rt2800_write_beacon,\n\t.clear_beacon\t\t= rt2800_clear_beacon,\n\t.fill_rxdone\t\t= rt2800mmio_fill_rxdone,\n\t.config_shared_key\t= rt2800_config_shared_key,\n\t.config_pairwise_key\t= rt2800_config_pairwise_key,\n\t.config_filter\t\t= rt2800_config_filter,\n\t.config_intf\t\t= rt2800_config_intf,\n\t.config_erp\t\t= rt2800_config_erp,\n\t.config_ant\t\t= rt2800_config_ant,\n\t.config\t\t\t= rt2800_config,\n\t.pre_reset_hw\t\t= rt2800_pre_reset_hw,\n};\n\nstatic const struct rt2x00_ops rt2800soc_ops = {\n\t.name\t\t\t= KBUILD_MODNAME,\n\t.drv_data_size\t\t= sizeof(struct rt2800_drv_data),\n\t.max_ap_intf\t\t= 8,\n\t.eeprom_size\t\t= EEPROM_SIZE,\n\t.rf_size\t\t= RF_SIZE,\n\t.tx_queues\t\t= NUM_TX_QUEUES,\n\t.queue_init\t\t= rt2800mmio_queue_init,\n\t.lib\t\t\t= &rt2800soc_rt2x00_ops,\n\t.drv\t\t\t= &rt2800soc_rt2800_ops,\n\t.hw\t\t\t= &rt2800soc_mac80211_ops,\n#ifdef CONFIG_RT2X00_LIB_DEBUGFS\n\t.debugfs\t\t= &rt2800_rt2x00debug,\n#endif  \n};\n\nstatic int rt2800soc_probe(struct platform_device *pdev)\n{\n\treturn rt2x00soc_probe(pdev, &rt2800soc_ops);\n}\n\nstatic struct platform_driver rt2800soc_driver = {\n\t.driver\t\t= {\n\t\t.name\t\t= \"rt2800_wmac\",\n\t\t.mod_name\t= KBUILD_MODNAME,\n\t},\n\t.probe\t\t= rt2800soc_probe,\n\t.remove\t\t= rt2x00soc_remove,\n\t.suspend\t= rt2x00soc_suspend,\n\t.resume\t\t= rt2x00soc_resume,\n};\n\nmodule_platform_driver(rt2800soc_driver);\n\nMODULE_AUTHOR(DRV_PROJECT);\nMODULE_VERSION(DRV_VERSION);\nMODULE_DESCRIPTION(\"Ralink WiSoC Wireless LAN driver.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}