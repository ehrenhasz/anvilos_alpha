{
  "module_name": "rt2x00config.c",
  "hash_id": "da152142cb49ea398cda7a59ca4aa6331e0f9953e472e0f7cefead73dd6b4f4c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ralink/rt2x00/rt2x00config.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#include \"rt2x00.h\"\n#include \"rt2x00lib.h\"\n\nvoid rt2x00lib_config_intf(struct rt2x00_dev *rt2x00dev,\n\t\t\t   struct rt2x00_intf *intf,\n\t\t\t   enum nl80211_iftype type,\n\t\t\t   const u8 *mac, const u8 *bssid)\n{\n\tstruct rt2x00intf_conf conf;\n\tunsigned int flags = 0;\n\n\tconf.type = type;\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tconf.sync = TSF_SYNC_ADHOC;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tconf.sync = TSF_SYNC_AP_NONE;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tconf.sync = TSF_SYNC_INFRA;\n\t\tbreak;\n\tdefault:\n\t\tconf.sync = TSF_SYNC_NONE;\n\t\tbreak;\n\t}\n\n\t \n\tmemset(conf.mac, 0, sizeof(conf.mac));\n\tif (mac)\n\t\tmemcpy(conf.mac, mac, ETH_ALEN);\n\n\tmemset(conf.bssid, 0, sizeof(conf.bssid));\n\tif (bssid)\n\t\tmemcpy(conf.bssid, bssid, ETH_ALEN);\n\n\tflags |= CONFIG_UPDATE_TYPE;\n\tif (mac || (!rt2x00dev->intf_ap_count && !rt2x00dev->intf_sta_count))\n\t\tflags |= CONFIG_UPDATE_MAC;\n\tif (bssid || (!rt2x00dev->intf_ap_count && !rt2x00dev->intf_sta_count))\n\t\tflags |= CONFIG_UPDATE_BSSID;\n\n\trt2x00dev->ops->lib->config_intf(rt2x00dev, intf, &conf, flags);\n}\n\nvoid rt2x00lib_config_erp(struct rt2x00_dev *rt2x00dev,\n\t\t\t  struct rt2x00_intf *intf,\n\t\t\t  struct ieee80211_bss_conf *bss_conf,\n\t\t\t  u32 changed)\n{\n\tstruct ieee80211_vif *vif = container_of(bss_conf, struct ieee80211_vif,\n\t\t\t\t\t\t bss_conf);\n\tstruct rt2x00lib_erp erp;\n\n\tmemset(&erp, 0, sizeof(erp));\n\n\terp.short_preamble = bss_conf->use_short_preamble;\n\terp.cts_protection = bss_conf->use_cts_prot;\n\n\terp.slot_time = bss_conf->use_short_slot ? SHORT_SLOT_TIME : SLOT_TIME;\n\terp.sifs = SIFS;\n\terp.pifs = bss_conf->use_short_slot ? SHORT_PIFS : PIFS;\n\terp.difs = bss_conf->use_short_slot ? SHORT_DIFS : DIFS;\n\terp.eifs = bss_conf->use_short_slot ? SHORT_EIFS : EIFS;\n\n\terp.basic_rates = bss_conf->basic_rates;\n\terp.beacon_int = bss_conf->beacon_int;\n\n\t \n\trt2x00dev->aid = vif->cfg.assoc ? vif->cfg.aid : 0;\n\trt2x00dev->last_beacon = bss_conf->sync_tsf;\n\n\t \n\trt2x00dev->beacon_int = bss_conf->beacon_int;\n\n\tif (changed & BSS_CHANGED_HT)\n\t\terp.ht_opmode = bss_conf->ht_operation_mode;\n\n\trt2x00dev->ops->lib->config_erp(rt2x00dev, &erp, changed);\n}\n\nvoid rt2x00lib_config_antenna(struct rt2x00_dev *rt2x00dev,\n\t\t\t      struct antenna_setup config)\n{\n\tstruct link_ant *ant = &rt2x00dev->link.ant;\n\tstruct antenna_setup *def = &rt2x00dev->default_ant;\n\tstruct antenna_setup *active = &rt2x00dev->link.ant.active;\n\n\t \n\tif (!(ant->flags & ANTENNA_RX_DIVERSITY)) {\n\t\tif (config.rx == ANTENNA_SW_DIVERSITY) {\n\t\t\tant->flags |= ANTENNA_RX_DIVERSITY;\n\n\t\t\tif (def->rx == ANTENNA_SW_DIVERSITY)\n\t\t\t\tconfig.rx = ANTENNA_B;\n\t\t\telse\n\t\t\t\tconfig.rx = def->rx;\n\t\t}\n\t} else if (config.rx == ANTENNA_SW_DIVERSITY)\n\t\tconfig.rx = active->rx;\n\n\tif (!(ant->flags & ANTENNA_TX_DIVERSITY)) {\n\t\tif (config.tx == ANTENNA_SW_DIVERSITY) {\n\t\t\tant->flags |= ANTENNA_TX_DIVERSITY;\n\n\t\t\tif (def->tx == ANTENNA_SW_DIVERSITY)\n\t\t\t\tconfig.tx = ANTENNA_B;\n\t\t\telse\n\t\t\t\tconfig.tx = def->tx;\n\t\t}\n\t} else if (config.tx == ANTENNA_SW_DIVERSITY)\n\t\tconfig.tx = active->tx;\n\n\t \n\tif (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\trt2x00queue_stop_queue(rt2x00dev->rx);\n\n\t \n\trt2x00dev->ops->lib->config_ant(rt2x00dev, &config);\n\n\trt2x00link_reset_tuner(rt2x00dev, true);\n\n\tmemcpy(active, &config, sizeof(config));\n\n\tif (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\trt2x00queue_start_queue(rt2x00dev->rx);\n}\n\nstatic u16 rt2x00ht_center_channel(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t   struct ieee80211_conf *conf)\n{\n\tstruct hw_mode_spec *spec = &rt2x00dev->spec;\n\tint center_channel;\n\tu16 i;\n\n\t \n\tcenter_channel = spec->channels[conf->chandef.chan->hw_value].channel;\n\n\t \n\tif (conf_is_ht40_plus(conf))\n\t\tcenter_channel += 2;\n\telse if (conf_is_ht40_minus(conf))\n\t\tcenter_channel -= (center_channel == 14) ? 1 : 2;\n\n\tfor (i = 0; i < spec->num_channels; i++)\n\t\tif (spec->channels[i].channel == center_channel)\n\t\t\treturn i;\n\n\tWARN_ON(1);\n\treturn conf->chandef.chan->hw_value;\n}\n\nvoid rt2x00lib_config(struct rt2x00_dev *rt2x00dev,\n\t\t      struct ieee80211_conf *conf,\n\t\t      unsigned int ieee80211_flags)\n{\n\tstruct rt2x00lib_conf libconf;\n\tu16 hw_value;\n\tu16 autowake_timeout;\n\tu16 beacon_int;\n\tu16 beacon_diff;\n\n\tmemset(&libconf, 0, sizeof(libconf));\n\n\tlibconf.conf = conf;\n\n\tif (ieee80211_flags & IEEE80211_CONF_CHANGE_CHANNEL) {\n\t\tif (!conf_is_ht(conf))\n\t\t\tset_bit(CONFIG_HT_DISABLED, &rt2x00dev->flags);\n\t\telse\n\t\t\tclear_bit(CONFIG_HT_DISABLED, &rt2x00dev->flags);\n\n\t\tif (conf_is_ht40(conf)) {\n\t\t\tset_bit(CONFIG_CHANNEL_HT40, &rt2x00dev->flags);\n\t\t\thw_value = rt2x00ht_center_channel(rt2x00dev, conf);\n\t\t} else {\n\t\t\tclear_bit(CONFIG_CHANNEL_HT40, &rt2x00dev->flags);\n\t\t\thw_value = conf->chandef.chan->hw_value;\n\t\t}\n\n\t\tmemcpy(&libconf.rf,\n\t\t       &rt2x00dev->spec.channels[hw_value],\n\t\t       sizeof(libconf.rf));\n\n\t\tmemcpy(&libconf.channel,\n\t\t       &rt2x00dev->spec.channels_info[hw_value],\n\t\t       sizeof(libconf.channel));\n\n\t\t \n\t\trt2x00dev->rf_channel = libconf.rf.channel;\n\t}\n\n\tif (rt2x00_has_cap_flag(rt2x00dev, REQUIRE_PS_AUTOWAKE) &&\n\t    (ieee80211_flags & IEEE80211_CONF_CHANGE_PS))\n\t\tcancel_delayed_work_sync(&rt2x00dev->autowakeup_work);\n\n\t \n\trt2x00dev->ops->lib->config(rt2x00dev, &libconf, ieee80211_flags);\n\n\tif (conf->flags & IEEE80211_CONF_PS)\n\t\tset_bit(CONFIG_POWERSAVING, &rt2x00dev->flags);\n\telse\n\t\tclear_bit(CONFIG_POWERSAVING, &rt2x00dev->flags);\n\n\tif (conf->flags & IEEE80211_CONF_MONITOR)\n\t\tset_bit(CONFIG_MONITORING, &rt2x00dev->flags);\n\telse\n\t\tclear_bit(CONFIG_MONITORING, &rt2x00dev->flags);\n\n\trt2x00dev->curr_band = conf->chandef.chan->band;\n\trt2x00dev->curr_freq = conf->chandef.chan->center_freq;\n\trt2x00dev->tx_power = conf->power_level;\n\trt2x00dev->short_retry = conf->short_frame_max_tx_count;\n\trt2x00dev->long_retry = conf->long_frame_max_tx_count;\n\n\t \n\tif (ieee80211_flags & IEEE80211_CONF_CHANGE_CHANNEL)\n\t\trt2x00link_reset_tuner(rt2x00dev, false);\n\n\tif (test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags) &&\n\t    rt2x00_has_cap_flag(rt2x00dev, REQUIRE_PS_AUTOWAKE) &&\n\t    (ieee80211_flags & IEEE80211_CONF_CHANGE_PS) &&\n\t    (conf->flags & IEEE80211_CONF_PS)) {\n\t\tbeacon_diff = (long)jiffies - (long)rt2x00dev->last_beacon;\n\t\tbeacon_int = msecs_to_jiffies(rt2x00dev->beacon_int);\n\n\t\tif (beacon_diff > beacon_int)\n\t\t\tbeacon_diff = 0;\n\n\t\tautowake_timeout = (conf->ps_dtim_period * beacon_int) - beacon_diff;\n\t\tqueue_delayed_work(rt2x00dev->workqueue,\n\t\t\t\t   &rt2x00dev->autowakeup_work,\n\t\t\t\t   autowake_timeout - 15);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}