{
  "module_name": "rt2x00crypto.c",
  "hash_id": "5f9510b6ed8554dc23664281bfa4a3d5d23f26dbe803ca0d148d50045238e216",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ralink/rt2x00/rt2x00crypto.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#include \"rt2x00.h\"\n#include \"rt2x00lib.h\"\n\nenum cipher rt2x00crypto_key_to_cipher(struct ieee80211_key_conf *key)\n{\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\treturn CIPHER_WEP64;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\treturn CIPHER_WEP128;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\treturn CIPHER_TKIP;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\treturn CIPHER_AES;\n\tdefault:\n\t\treturn CIPHER_NONE;\n\t}\n}\n\nvoid rt2x00crypto_create_tx_descriptor(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t       struct txentry_desc *txdesc)\n{\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_key_conf *hw_key = tx_info->control.hw_key;\n\n\tif (!rt2x00_has_cap_hw_crypto(rt2x00dev) || !hw_key)\n\t\treturn;\n\n\t__set_bit(ENTRY_TXD_ENCRYPT, &txdesc->flags);\n\n\ttxdesc->cipher = rt2x00crypto_key_to_cipher(hw_key);\n\n\tif (hw_key->flags & IEEE80211_KEY_FLAG_PAIRWISE)\n\t\t__set_bit(ENTRY_TXD_ENCRYPT_PAIRWISE, &txdesc->flags);\n\n\ttxdesc->key_idx = hw_key->hw_key_idx;\n\ttxdesc->iv_offset = txdesc->header_length;\n\ttxdesc->iv_len = hw_key->iv_len;\n\n\tif (!(hw_key->flags & IEEE80211_KEY_FLAG_GENERATE_IV))\n\t\t__set_bit(ENTRY_TXD_ENCRYPT_IV, &txdesc->flags);\n\n\tif (!(hw_key->flags & IEEE80211_KEY_FLAG_GENERATE_MMIC))\n\t\t__set_bit(ENTRY_TXD_ENCRYPT_MMIC, &txdesc->flags);\n}\n\nunsigned int rt2x00crypto_tx_overhead(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_key_conf *key = tx_info->control.hw_key;\n\tunsigned int overhead = 0;\n\n\tif (!rt2x00_has_cap_hw_crypto(rt2x00dev) || !key)\n\t\treturn overhead;\n\n\t \n\toverhead += key->icv_len;\n\n\tif (!(key->flags & IEEE80211_KEY_FLAG_GENERATE_IV))\n\t\toverhead += key->iv_len;\n\n\tif (!(key->flags & IEEE80211_KEY_FLAG_GENERATE_MMIC)) {\n\t\tif (key->cipher == WLAN_CIPHER_SUITE_TKIP)\n\t\t\toverhead += 8;\n\t}\n\n\treturn overhead;\n}\n\nvoid rt2x00crypto_tx_copy_iv(struct sk_buff *skb, struct txentry_desc *txdesc)\n{\n\tstruct skb_frame_desc *skbdesc = get_skb_frame_desc(skb);\n\n\tif (unlikely(!txdesc->iv_len))\n\t\treturn;\n\n\t \n\tmemcpy(skbdesc->iv, skb->data + txdesc->iv_offset, txdesc->iv_len);\n}\n\nvoid rt2x00crypto_tx_remove_iv(struct sk_buff *skb, struct txentry_desc *txdesc)\n{\n\tstruct skb_frame_desc *skbdesc = get_skb_frame_desc(skb);\n\n\tif (unlikely(!txdesc->iv_len))\n\t\treturn;\n\n\t \n\tmemcpy(skbdesc->iv, skb->data + txdesc->iv_offset, txdesc->iv_len);\n\n\t \n\tmemmove(skb->data + txdesc->iv_len, skb->data, txdesc->iv_offset);\n\n\t \n\tskb_pull(skb, txdesc->iv_len);\n\ttxdesc->length -= txdesc->iv_len;\n\n\t \n\tskbdesc->flags |= SKBDESC_IV_STRIPPED;\n}\n\nvoid rt2x00crypto_tx_insert_iv(struct sk_buff *skb, unsigned int header_length)\n{\n\tstruct skb_frame_desc *skbdesc = get_skb_frame_desc(skb);\n\tconst unsigned int iv_len =\n\t    ((!!(skbdesc->iv[0])) * 4) + ((!!(skbdesc->iv[1])) * 4);\n\n\tif (!(skbdesc->flags & SKBDESC_IV_STRIPPED))\n\t\treturn;\n\n\tskb_push(skb, iv_len);\n\n\t \n\tmemmove(skb->data, skb->data + iv_len, header_length);\n\n\t \n\tmemcpy(skb->data + header_length, skbdesc->iv, iv_len);\n\n\t \n\tskbdesc->flags &= ~SKBDESC_IV_STRIPPED;\n}\n\nvoid rt2x00crypto_rx_insert_iv(struct sk_buff *skb,\n\t\t\t       unsigned int header_length,\n\t\t\t       struct rxdone_entry_desc *rxdesc)\n{\n\tunsigned int payload_len = rxdesc->size - header_length;\n\tunsigned int align = ALIGN_SIZE(skb, header_length);\n\tunsigned int iv_len;\n\tunsigned int icv_len;\n\tunsigned int transfer = 0;\n\n\t \n\tswitch (rxdesc->cipher) {\n\tcase CIPHER_WEP64:\n\tcase CIPHER_WEP128:\n\t\tiv_len = 4;\n\t\ticv_len = 4;\n\t\tbreak;\n\tcase CIPHER_TKIP:\n\t\tiv_len = 8;\n\t\ticv_len = 4;\n\t\tbreak;\n\tcase CIPHER_AES:\n\t\tiv_len = 8;\n\t\ticv_len = 8;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tif (rxdesc->dev_flags & RXDONE_L2PAD) {\n\t\tskb_push(skb, iv_len - align);\n\t\tskb_put(skb, icv_len);\n\n\t\t \n\t\tmemmove(skb->data + transfer,\n\t\t\tskb->data + transfer + (iv_len - align),\n\t\t\theader_length);\n\t\ttransfer += header_length;\n\t} else {\n\t\tskb_push(skb, iv_len + align);\n\t\tif (align < icv_len)\n\t\t\tskb_put(skb, icv_len - align);\n\t\telse if (align > icv_len)\n\t\t\tskb_trim(skb, rxdesc->size + iv_len + icv_len);\n\n\t\t \n\t\tmemmove(skb->data + transfer,\n\t\t\tskb->data + transfer + iv_len + align,\n\t\t\theader_length);\n\t\ttransfer += header_length;\n\t}\n\n\t \n\tmemcpy(skb->data + transfer, rxdesc->iv, iv_len);\n\ttransfer += iv_len;\n\n\t \n\tif (!(rxdesc->dev_flags & RXDONE_L2PAD)) {\n\t\tmemmove(skb->data + transfer,\n\t\t\tskb->data + transfer + align,\n\t\t\tpayload_len);\n\t}\n\n\t \n\ttransfer += payload_len;\n\n\t \n\tmemcpy(skb->data + transfer, &rxdesc->icv, 4);\n\ttransfer += icv_len;\n\n\t \n\trxdesc->size = transfer;\n\trxdesc->flags &= ~RX_FLAG_IV_STRIPPED;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}