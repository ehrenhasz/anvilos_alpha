{
  "module_name": "rt2x00leds.c",
  "hash_id": "b40f43fe9c70db4df67ed833eae781def47a12da1625c98d77328694d0c5fa7f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ralink/rt2x00/rt2x00leds.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#include \"rt2x00.h\"\n#include \"rt2x00lib.h\"\n\nvoid rt2x00leds_led_quality(struct rt2x00_dev *rt2x00dev, int rssi)\n{\n\tstruct rt2x00_led *led = &rt2x00dev->led_qual;\n\tunsigned int brightness;\n\n\tif ((led->type != LED_TYPE_QUALITY) || !(led->flags & LED_REGISTERED))\n\t\treturn;\n\n\t \n\trssi += rt2x00dev->rssi_offset;\n\n\t \n\tif (rssi <= 30)\n\t\trssi = 0;\n\telse if (rssi <= 39)\n\t\trssi = 1;\n\telse if (rssi <= 49)\n\t\trssi = 2;\n\telse if (rssi <= 53)\n\t\trssi = 3;\n\telse if (rssi <= 63)\n\t\trssi = 4;\n\telse\n\t\trssi = 5;\n\n\t \n\tbrightness = ((LED_FULL / 6) * rssi) + 1;\n\tif (brightness != led->led_dev.brightness) {\n\t\tled->led_dev.brightness_set(&led->led_dev, brightness);\n\t\tled->led_dev.brightness = brightness;\n\t}\n}\n\nstatic void rt2x00led_led_simple(struct rt2x00_led *led, bool enabled)\n{\n\tunsigned int brightness = enabled ? LED_FULL : LED_OFF;\n\n\tif (!(led->flags & LED_REGISTERED))\n\t\treturn;\n\n\tled->led_dev.brightness_set(&led->led_dev, brightness);\n\tled->led_dev.brightness = brightness;\n}\n\nvoid rt2x00led_led_activity(struct rt2x00_dev *rt2x00dev, bool enabled)\n{\n\tif (rt2x00dev->led_qual.type == LED_TYPE_ACTIVITY)\n\t\trt2x00led_led_simple(&rt2x00dev->led_qual, enabled);\n}\n\nvoid rt2x00leds_led_assoc(struct rt2x00_dev *rt2x00dev, bool enabled)\n{\n\tif (rt2x00dev->led_assoc.type == LED_TYPE_ASSOC)\n\t\trt2x00led_led_simple(&rt2x00dev->led_assoc, enabled);\n}\n\nvoid rt2x00leds_led_radio(struct rt2x00_dev *rt2x00dev, bool enabled)\n{\n\tif (rt2x00dev->led_radio.type == LED_TYPE_RADIO)\n\t\trt2x00led_led_simple(&rt2x00dev->led_radio, enabled);\n}\n\nstatic int rt2x00leds_register_led(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t   struct rt2x00_led *led,\n\t\t\t\t   const char *name)\n{\n\tstruct device *device = wiphy_dev(rt2x00dev->hw->wiphy);\n\tint retval;\n\n\tled->led_dev.name = name;\n\tled->led_dev.brightness = LED_OFF;\n\n\tretval = led_classdev_register(device, &led->led_dev);\n\tif (retval) {\n\t\trt2x00_err(rt2x00dev, \"Failed to register led handler\\n\");\n\t\treturn retval;\n\t}\n\n\tled->flags |= LED_REGISTERED;\n\n\treturn 0;\n}\n\nvoid rt2x00leds_register(struct rt2x00_dev *rt2x00dev)\n{\n\tchar name[36];\n\tint retval;\n\tunsigned long on_period;\n\tunsigned long off_period;\n\tconst char *phy_name = wiphy_name(rt2x00dev->hw->wiphy);\n\n\tif (rt2x00dev->led_radio.flags & LED_INITIALIZED) {\n\t\tsnprintf(name, sizeof(name), \"%s-%s::radio\",\n\t\t\t rt2x00dev->ops->name, phy_name);\n\n\t\tretval = rt2x00leds_register_led(rt2x00dev,\n\t\t\t\t\t\t &rt2x00dev->led_radio,\n\t\t\t\t\t\t name);\n\t\tif (retval)\n\t\t\tgoto exit_fail;\n\t}\n\n\tif (rt2x00dev->led_assoc.flags & LED_INITIALIZED) {\n\t\tsnprintf(name, sizeof(name), \"%s-%s::assoc\",\n\t\t\t rt2x00dev->ops->name, phy_name);\n\n\t\tretval = rt2x00leds_register_led(rt2x00dev,\n\t\t\t\t\t\t &rt2x00dev->led_assoc,\n\t\t\t\t\t\t name);\n\t\tif (retval)\n\t\t\tgoto exit_fail;\n\t}\n\n\tif (rt2x00dev->led_qual.flags & LED_INITIALIZED) {\n\t\tsnprintf(name, sizeof(name), \"%s-%s::quality\",\n\t\t\t rt2x00dev->ops->name, phy_name);\n\n\t\tretval = rt2x00leds_register_led(rt2x00dev,\n\t\t\t\t\t\t &rt2x00dev->led_qual,\n\t\t\t\t\t\t name);\n\t\tif (retval)\n\t\t\tgoto exit_fail;\n\t}\n\n\t \n\tif (rt2x00dev->led_radio.led_dev.blink_set) {\n\t\ton_period = 70;\n\t\toff_period = 30;\n\t\trt2x00dev->led_radio.led_dev.blink_set(\n\t\t    &rt2x00dev->led_radio.led_dev, &on_period, &off_period);\n\t}\n\n\treturn;\n\nexit_fail:\n\trt2x00leds_unregister(rt2x00dev);\n}\n\nstatic void rt2x00leds_unregister_led(struct rt2x00_led *led)\n{\n\tled_classdev_unregister(&led->led_dev);\n\n\t \n\tif (!(led->led_dev.flags & LED_SUSPENDED))\n\t\tled->led_dev.brightness_set(&led->led_dev, LED_OFF);\n\n\tled->flags &= ~LED_REGISTERED;\n}\n\nvoid rt2x00leds_unregister(struct rt2x00_dev *rt2x00dev)\n{\n\tif (rt2x00dev->led_qual.flags & LED_REGISTERED)\n\t\trt2x00leds_unregister_led(&rt2x00dev->led_qual);\n\tif (rt2x00dev->led_assoc.flags & LED_REGISTERED)\n\t\trt2x00leds_unregister_led(&rt2x00dev->led_assoc);\n\tif (rt2x00dev->led_radio.flags & LED_REGISTERED)\n\t\trt2x00leds_unregister_led(&rt2x00dev->led_radio);\n}\n\nstatic inline void rt2x00leds_suspend_led(struct rt2x00_led *led)\n{\n\tled_classdev_suspend(&led->led_dev);\n\n\t \n\tled->led_dev.brightness_set(&led->led_dev, LED_OFF);\n\tled->led_dev.brightness = LED_OFF;\n}\n\nvoid rt2x00leds_suspend(struct rt2x00_dev *rt2x00dev)\n{\n\tif (rt2x00dev->led_qual.flags & LED_REGISTERED)\n\t\trt2x00leds_suspend_led(&rt2x00dev->led_qual);\n\tif (rt2x00dev->led_assoc.flags & LED_REGISTERED)\n\t\trt2x00leds_suspend_led(&rt2x00dev->led_assoc);\n\tif (rt2x00dev->led_radio.flags & LED_REGISTERED)\n\t\trt2x00leds_suspend_led(&rt2x00dev->led_radio);\n}\n\nstatic inline void rt2x00leds_resume_led(struct rt2x00_led *led)\n{\n\tled_classdev_resume(&led->led_dev);\n\n\t \n\tled->led_dev.brightness_set(&led->led_dev, LED_OFF);\n\tled->led_dev.brightness = LED_OFF;\n}\n\nvoid rt2x00leds_resume(struct rt2x00_dev *rt2x00dev)\n{\n\tif (rt2x00dev->led_radio.flags & LED_REGISTERED)\n\t\trt2x00leds_resume_led(&rt2x00dev->led_radio);\n\tif (rt2x00dev->led_assoc.flags & LED_REGISTERED)\n\t\trt2x00leds_resume_led(&rt2x00dev->led_assoc);\n\tif (rt2x00dev->led_qual.flags & LED_REGISTERED)\n\t\trt2x00leds_resume_led(&rt2x00dev->led_qual);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}