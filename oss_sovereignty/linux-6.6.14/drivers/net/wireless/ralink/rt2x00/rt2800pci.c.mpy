{
  "module_name": "rt2800pci.c",
  "hash_id": "3594e81310a0b4bf81eee1cc77204a2821d4e92a4d6700c3efd8ba245df76e1a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ralink/rt2x00/rt2800pci.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/delay.h>\n#include <linux/etherdevice.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/eeprom_93cx6.h>\n\n#include \"rt2x00.h\"\n#include \"rt2x00mmio.h\"\n#include \"rt2x00pci.h\"\n#include \"rt2800lib.h\"\n#include \"rt2800mmio.h\"\n#include \"rt2800.h\"\n#include \"rt2800pci.h\"\n\n \nstatic bool modparam_nohwcrypt = false;\nmodule_param_named(nohwcrypt, modparam_nohwcrypt, bool, 0444);\nMODULE_PARM_DESC(nohwcrypt, \"Disable hardware encryption.\");\n\nstatic bool rt2800pci_hwcrypt_disabled(struct rt2x00_dev *rt2x00dev)\n{\n\treturn modparam_nohwcrypt;\n}\n\nstatic void rt2800pci_mcu_status(struct rt2x00_dev *rt2x00dev, const u8 token)\n{\n\tunsigned int i;\n\tu32 reg;\n\n\t \n\tif (rt2x00_is_soc(rt2x00dev))\n\t\treturn;\n\n\tfor (i = 0; i < 200; i++) {\n\t\treg = rt2x00mmio_register_read(rt2x00dev, H2M_MAILBOX_CID);\n\n\t\tif ((rt2x00_get_field32(reg, H2M_MAILBOX_CID_CMD0) == token) ||\n\t\t    (rt2x00_get_field32(reg, H2M_MAILBOX_CID_CMD1) == token) ||\n\t\t    (rt2x00_get_field32(reg, H2M_MAILBOX_CID_CMD2) == token) ||\n\t\t    (rt2x00_get_field32(reg, H2M_MAILBOX_CID_CMD3) == token))\n\t\t\tbreak;\n\n\t\tudelay(REGISTER_BUSY_DELAY);\n\t}\n\n\tif (i == 200)\n\t\trt2x00_err(rt2x00dev, \"MCU request failed, no response from hardware\\n\");\n\n\trt2x00mmio_register_write(rt2x00dev, H2M_MAILBOX_STATUS, ~0);\n\trt2x00mmio_register_write(rt2x00dev, H2M_MAILBOX_CID, ~0);\n}\n\nstatic void rt2800pci_eepromregister_read(struct eeprom_93cx6 *eeprom)\n{\n\tstruct rt2x00_dev *rt2x00dev = eeprom->data;\n\tu32 reg;\n\n\treg = rt2x00mmio_register_read(rt2x00dev, E2PROM_CSR);\n\n\teeprom->reg_data_in = !!rt2x00_get_field32(reg, E2PROM_CSR_DATA_IN);\n\teeprom->reg_data_out = !!rt2x00_get_field32(reg, E2PROM_CSR_DATA_OUT);\n\teeprom->reg_data_clock =\n\t    !!rt2x00_get_field32(reg, E2PROM_CSR_DATA_CLOCK);\n\teeprom->reg_chip_select =\n\t    !!rt2x00_get_field32(reg, E2PROM_CSR_CHIP_SELECT);\n}\n\nstatic void rt2800pci_eepromregister_write(struct eeprom_93cx6 *eeprom)\n{\n\tstruct rt2x00_dev *rt2x00dev = eeprom->data;\n\tu32 reg = 0;\n\n\trt2x00_set_field32(&reg, E2PROM_CSR_DATA_IN, !!eeprom->reg_data_in);\n\trt2x00_set_field32(&reg, E2PROM_CSR_DATA_OUT, !!eeprom->reg_data_out);\n\trt2x00_set_field32(&reg, E2PROM_CSR_DATA_CLOCK,\n\t\t\t   !!eeprom->reg_data_clock);\n\trt2x00_set_field32(&reg, E2PROM_CSR_CHIP_SELECT,\n\t\t\t   !!eeprom->reg_chip_select);\n\n\trt2x00mmio_register_write(rt2x00dev, E2PROM_CSR, reg);\n}\n\nstatic int rt2800pci_read_eeprom_pci(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct eeprom_93cx6 eeprom;\n\tu32 reg;\n\n\treg = rt2x00mmio_register_read(rt2x00dev, E2PROM_CSR);\n\n\teeprom.data = rt2x00dev;\n\teeprom.register_read = rt2800pci_eepromregister_read;\n\teeprom.register_write = rt2800pci_eepromregister_write;\n\tswitch (rt2x00_get_field32(reg, E2PROM_CSR_TYPE))\n\t{\n\tcase 0:\n\t\teeprom.width = PCI_EEPROM_WIDTH_93C46;\n\t\tbreak;\n\tcase 1:\n\t\teeprom.width = PCI_EEPROM_WIDTH_93C66;\n\t\tbreak;\n\tdefault:\n\t\teeprom.width = PCI_EEPROM_WIDTH_93C86;\n\t\tbreak;\n\t}\n\teeprom.reg_data_in = 0;\n\teeprom.reg_data_out = 0;\n\teeprom.reg_data_clock = 0;\n\teeprom.reg_chip_select = 0;\n\n\teeprom_93cx6_multiread(&eeprom, EEPROM_BASE, rt2x00dev->eeprom,\n\t\t\t       EEPROM_SIZE / sizeof(u16));\n\n\treturn 0;\n}\n\nstatic int rt2800pci_efuse_detect(struct rt2x00_dev *rt2x00dev)\n{\n\treturn rt2800_efuse_detect(rt2x00dev);\n}\n\nstatic inline int rt2800pci_read_eeprom_efuse(struct rt2x00_dev *rt2x00dev)\n{\n\treturn rt2800_read_eeprom_efuse(rt2x00dev);\n}\n\n \nstatic char *rt2800pci_get_firmware_name(struct rt2x00_dev *rt2x00dev)\n{\n\t \n\tif (rt2x00_rt(rt2x00dev, RT3290))\n\t\treturn FIRMWARE_RT3290;\n\telse\n\t\treturn FIRMWARE_RT2860;\n}\n\nstatic int rt2800pci_write_firmware(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t    const u8 *data, const size_t len)\n{\n\tu32 reg;\n\n\t \n\treg = 0;\n\trt2x00_set_field32(&reg, PBF_SYS_CTRL_HOST_RAM_WRITE, 1);\n\trt2x00mmio_register_write(rt2x00dev, PBF_SYS_CTRL, reg);\n\n\t \n\trt2x00mmio_register_multiwrite(rt2x00dev, FIRMWARE_IMAGE_BASE,\n\t\t\t\t       data, len);\n\n\trt2x00mmio_register_write(rt2x00dev, PBF_SYS_CTRL, 0x00000);\n\trt2x00mmio_register_write(rt2x00dev, PBF_SYS_CTRL, 0x00001);\n\n\trt2x00mmio_register_write(rt2x00dev, H2M_BBP_AGENT, 0);\n\trt2x00mmio_register_write(rt2x00dev, H2M_MAILBOX_CSR, 0);\n\n\treturn 0;\n}\n\n \nstatic int rt2800pci_enable_radio(struct rt2x00_dev *rt2x00dev)\n{\n\tint retval;\n\n\tretval = rt2800mmio_enable_radio(rt2x00dev);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\trt2x00mmio_register_write(rt2x00dev, H2M_MAILBOX_STATUS, ~0);\n\trt2x00mmio_register_write(rt2x00dev, H2M_MAILBOX_CID, ~0);\n\n\trt2800_mcu_request(rt2x00dev, MCU_SLEEP, TOKEN_RADIO_OFF, 0xff, 0x02);\n\trt2800pci_mcu_status(rt2x00dev, TOKEN_RADIO_OFF);\n\n\trt2800_mcu_request(rt2x00dev, MCU_WAKEUP, TOKEN_WAKEUP, 0, 0);\n\trt2800pci_mcu_status(rt2x00dev, TOKEN_WAKEUP);\n\n\treturn retval;\n}\n\nstatic int rt2800pci_set_state(struct rt2x00_dev *rt2x00dev,\n\t\t\t       enum dev_state state)\n{\n\tif (state == STATE_AWAKE) {\n\t\trt2800_mcu_request(rt2x00dev, MCU_WAKEUP, TOKEN_WAKEUP,\n\t\t\t\t   0, 0x02);\n\t\trt2800pci_mcu_status(rt2x00dev, TOKEN_WAKEUP);\n\t} else if (state == STATE_SLEEP) {\n\t\trt2x00mmio_register_write(rt2x00dev, H2M_MAILBOX_STATUS,\n\t\t\t\t\t  0xffffffff);\n\t\trt2x00mmio_register_write(rt2x00dev, H2M_MAILBOX_CID,\n\t\t\t\t\t  0xffffffff);\n\t\trt2800_mcu_request(rt2x00dev, MCU_SLEEP, TOKEN_SLEEP,\n\t\t\t\t   0xff, 0x01);\n\t}\n\n\treturn 0;\n}\n\nstatic int rt2800pci_set_device_state(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t      enum dev_state state)\n{\n\tint retval = 0;\n\n\tswitch (state) {\n\tcase STATE_RADIO_ON:\n\t\tretval = rt2800pci_enable_radio(rt2x00dev);\n\t\tbreak;\n\tcase STATE_RADIO_OFF:\n\t\t \n\t\trt2800pci_set_state(rt2x00dev, STATE_SLEEP);\n\t\tbreak;\n\tcase STATE_RADIO_IRQ_ON:\n\tcase STATE_RADIO_IRQ_OFF:\n\t\trt2800mmio_toggle_irq(rt2x00dev, state);\n\t\tbreak;\n\tcase STATE_DEEP_SLEEP:\n\tcase STATE_SLEEP:\n\tcase STATE_STANDBY:\n\tcase STATE_AWAKE:\n\t\tretval = rt2800pci_set_state(rt2x00dev, state);\n\t\tbreak;\n\tdefault:\n\t\tretval = -ENOTSUPP;\n\t\tbreak;\n\t}\n\n\tif (unlikely(retval))\n\t\trt2x00_err(rt2x00dev, \"Device failed to enter state %d (%d)\\n\",\n\t\t\t   state, retval);\n\n\treturn retval;\n}\n\n \nstatic int rt2800pci_read_eeprom(struct rt2x00_dev *rt2x00dev)\n{\n\tint retval;\n\n\tif (rt2800pci_efuse_detect(rt2x00dev))\n\t\tretval = rt2800pci_read_eeprom_efuse(rt2x00dev);\n\telse\n\t\tretval = rt2800pci_read_eeprom_pci(rt2x00dev);\n\n\treturn retval;\n}\n\nstatic const struct ieee80211_ops rt2800pci_mac80211_ops = {\n\t.tx\t\t\t= rt2x00mac_tx,\n\t.wake_tx_queue\t\t= ieee80211_handle_wake_tx_queue,\n\t.start\t\t\t= rt2x00mac_start,\n\t.stop\t\t\t= rt2x00mac_stop,\n\t.add_interface\t\t= rt2x00mac_add_interface,\n\t.remove_interface\t= rt2x00mac_remove_interface,\n\t.config\t\t\t= rt2x00mac_config,\n\t.configure_filter\t= rt2x00mac_configure_filter,\n\t.set_key\t\t= rt2x00mac_set_key,\n\t.sw_scan_start\t\t= rt2x00mac_sw_scan_start,\n\t.sw_scan_complete\t= rt2x00mac_sw_scan_complete,\n\t.get_stats\t\t= rt2x00mac_get_stats,\n\t.get_key_seq\t\t= rt2800_get_key_seq,\n\t.set_rts_threshold\t= rt2800_set_rts_threshold,\n\t.sta_add\t\t= rt2800_sta_add,\n\t.sta_remove\t\t= rt2800_sta_remove,\n\t.bss_info_changed\t= rt2x00mac_bss_info_changed,\n\t.conf_tx\t\t= rt2800_conf_tx,\n\t.get_tsf\t\t= rt2800_get_tsf,\n\t.rfkill_poll\t\t= rt2x00mac_rfkill_poll,\n\t.ampdu_action\t\t= rt2800_ampdu_action,\n\t.flush\t\t\t= rt2x00mac_flush,\n\t.get_survey\t\t= rt2800_get_survey,\n\t.get_ringparam\t\t= rt2x00mac_get_ringparam,\n\t.tx_frames_pending\t= rt2x00mac_tx_frames_pending,\n\t.reconfig_complete\t= rt2x00mac_reconfig_complete,\n};\n\nstatic const struct rt2800_ops rt2800pci_rt2800_ops = {\n\t.register_read\t\t= rt2x00mmio_register_read,\n\t.register_read_lock\t= rt2x00mmio_register_read,  \n\t.register_write\t\t= rt2x00mmio_register_write,\n\t.register_write_lock\t= rt2x00mmio_register_write,  \n\t.register_multiread\t= rt2x00mmio_register_multiread,\n\t.register_multiwrite\t= rt2x00mmio_register_multiwrite,\n\t.regbusy_read\t\t= rt2x00mmio_regbusy_read,\n\t.read_eeprom\t\t= rt2800pci_read_eeprom,\n\t.hwcrypt_disabled\t= rt2800pci_hwcrypt_disabled,\n\t.drv_write_firmware\t= rt2800pci_write_firmware,\n\t.drv_init_registers\t= rt2800mmio_init_registers,\n\t.drv_get_txwi\t\t= rt2800mmio_get_txwi,\n\t.drv_get_dma_done\t= rt2800mmio_get_dma_done,\n};\n\nstatic const struct rt2x00lib_ops rt2800pci_rt2x00_ops = {\n\t.irq_handler\t\t= rt2800mmio_interrupt,\n\t.txstatus_tasklet\t= rt2800mmio_txstatus_tasklet,\n\t.pretbtt_tasklet\t= rt2800mmio_pretbtt_tasklet,\n\t.tbtt_tasklet\t\t= rt2800mmio_tbtt_tasklet,\n\t.rxdone_tasklet\t\t= rt2800mmio_rxdone_tasklet,\n\t.autowake_tasklet\t= rt2800mmio_autowake_tasklet,\n\t.probe_hw\t\t= rt2800mmio_probe_hw,\n\t.get_firmware_name\t= rt2800pci_get_firmware_name,\n\t.check_firmware\t\t= rt2800_check_firmware,\n\t.load_firmware\t\t= rt2800_load_firmware,\n\t.initialize\t\t= rt2x00mmio_initialize,\n\t.uninitialize\t\t= rt2x00mmio_uninitialize,\n\t.get_entry_state\t= rt2800mmio_get_entry_state,\n\t.clear_entry\t\t= rt2800mmio_clear_entry,\n\t.set_device_state\t= rt2800pci_set_device_state,\n\t.rfkill_poll\t\t= rt2800_rfkill_poll,\n\t.link_stats\t\t= rt2800_link_stats,\n\t.reset_tuner\t\t= rt2800_reset_tuner,\n\t.link_tuner\t\t= rt2800_link_tuner,\n\t.gain_calibration\t= rt2800_gain_calibration,\n\t.vco_calibration\t= rt2800_vco_calibration,\n\t.watchdog\t\t= rt2800_watchdog,\n\t.start_queue\t\t= rt2800mmio_start_queue,\n\t.kick_queue\t\t= rt2800mmio_kick_queue,\n\t.stop_queue\t\t= rt2800mmio_stop_queue,\n\t.flush_queue\t\t= rt2800mmio_flush_queue,\n\t.write_tx_desc\t\t= rt2800mmio_write_tx_desc,\n\t.write_tx_data\t\t= rt2800_write_tx_data,\n\t.write_beacon\t\t= rt2800_write_beacon,\n\t.clear_beacon\t\t= rt2800_clear_beacon,\n\t.fill_rxdone\t\t= rt2800mmio_fill_rxdone,\n\t.config_shared_key\t= rt2800_config_shared_key,\n\t.config_pairwise_key\t= rt2800_config_pairwise_key,\n\t.config_filter\t\t= rt2800_config_filter,\n\t.config_intf\t\t= rt2800_config_intf,\n\t.config_erp\t\t= rt2800_config_erp,\n\t.config_ant\t\t= rt2800_config_ant,\n\t.config\t\t\t= rt2800_config,\n\t.pre_reset_hw\t\t= rt2800_pre_reset_hw,\n};\n\nstatic const struct rt2x00_ops rt2800pci_ops = {\n\t.name\t\t\t= KBUILD_MODNAME,\n\t.drv_data_size\t\t= sizeof(struct rt2800_drv_data),\n\t.max_ap_intf\t\t= 8,\n\t.eeprom_size\t\t= EEPROM_SIZE,\n\t.rf_size\t\t= RF_SIZE,\n\t.tx_queues\t\t= NUM_TX_QUEUES,\n\t.queue_init\t\t= rt2800mmio_queue_init,\n\t.lib\t\t\t= &rt2800pci_rt2x00_ops,\n\t.drv\t\t\t= &rt2800pci_rt2800_ops,\n\t.hw\t\t\t= &rt2800pci_mac80211_ops,\n#ifdef CONFIG_RT2X00_LIB_DEBUGFS\n\t.debugfs\t\t= &rt2800_rt2x00debug,\n#endif  \n};\n\n \nstatic const struct pci_device_id rt2800pci_device_table[] = {\n\t{ PCI_DEVICE(0x1814, 0x0601) },\n\t{ PCI_DEVICE(0x1814, 0x0681) },\n\t{ PCI_DEVICE(0x1814, 0x0701) },\n\t{ PCI_DEVICE(0x1814, 0x0781) },\n\t{ PCI_DEVICE(0x1814, 0x3090) },\n\t{ PCI_DEVICE(0x1814, 0x3091) },\n\t{ PCI_DEVICE(0x1814, 0x3092) },\n\t{ PCI_DEVICE(0x1432, 0x7708) },\n\t{ PCI_DEVICE(0x1432, 0x7727) },\n\t{ PCI_DEVICE(0x1432, 0x7728) },\n\t{ PCI_DEVICE(0x1432, 0x7738) },\n\t{ PCI_DEVICE(0x1432, 0x7748) },\n\t{ PCI_DEVICE(0x1432, 0x7758) },\n\t{ PCI_DEVICE(0x1432, 0x7768) },\n\t{ PCI_DEVICE(0x1462, 0x891a) },\n\t{ PCI_DEVICE(0x1a3b, 0x1059) },\n#ifdef CONFIG_RT2800PCI_RT3290\n\t{ PCI_DEVICE(0x1814, 0x3290) },\n#endif\n#ifdef CONFIG_RT2800PCI_RT33XX\n\t{ PCI_DEVICE(0x1814, 0x3390) },\n#endif\n#ifdef CONFIG_RT2800PCI_RT35XX\n\t{ PCI_DEVICE(0x1432, 0x7711) },\n\t{ PCI_DEVICE(0x1432, 0x7722) },\n\t{ PCI_DEVICE(0x1814, 0x3060) },\n\t{ PCI_DEVICE(0x1814, 0x3062) },\n\t{ PCI_DEVICE(0x1814, 0x3562) },\n\t{ PCI_DEVICE(0x1814, 0x3592) },\n\t{ PCI_DEVICE(0x1814, 0x3593) },\n\t{ PCI_DEVICE(0x1814, 0x359f) },\n#endif\n#ifdef CONFIG_RT2800PCI_RT53XX\n\t{ PCI_DEVICE(0x1814, 0x5360) },\n\t{ PCI_DEVICE(0x1814, 0x5362) },\n\t{ PCI_DEVICE(0x1814, 0x5390) },\n\t{ PCI_DEVICE(0x1814, 0x5392) },\n\t{ PCI_DEVICE(0x1814, 0x539a) },\n\t{ PCI_DEVICE(0x1814, 0x539b) },\n\t{ PCI_DEVICE(0x1814, 0x539f) },\n#endif\n\t{ 0, }\n};\n\nMODULE_AUTHOR(DRV_PROJECT);\nMODULE_VERSION(DRV_VERSION);\nMODULE_DESCRIPTION(\"Ralink RT2800 PCI & PCMCIA Wireless LAN driver.\");\nMODULE_FIRMWARE(FIRMWARE_RT2860);\nMODULE_DEVICE_TABLE(pci, rt2800pci_device_table);\nMODULE_LICENSE(\"GPL\");\n\nstatic int rt2800pci_probe(struct pci_dev *pci_dev,\n\t\t\t   const struct pci_device_id *id)\n{\n\treturn rt2x00pci_probe(pci_dev, &rt2800pci_ops);\n}\n\nstatic struct pci_driver rt2800pci_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= rt2800pci_device_table,\n\t.probe\t\t= rt2800pci_probe,\n\t.remove\t\t= rt2x00pci_remove,\n\t.driver.pm\t= &rt2x00pci_pm_ops,\n};\n\nmodule_pci_driver(rt2800pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}