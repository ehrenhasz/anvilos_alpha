{
  "module_name": "rt2x00mac.c",
  "hash_id": "10a3e4639046a9416668879c9a7ef6c1385b6bddcb80d7e5e166b11f7d91cdbd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ralink/rt2x00/rt2x00mac.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#include \"rt2x00.h\"\n#include \"rt2x00lib.h\"\n\nstatic int rt2x00mac_tx_rts_cts(struct rt2x00_dev *rt2x00dev,\n\t\t\t\tstruct data_queue *queue,\n\t\t\t\tstruct sk_buff *frag_skb)\n{\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(frag_skb);\n\tstruct ieee80211_tx_info *rts_info;\n\tstruct sk_buff *skb;\n\tunsigned int data_length;\n\tint retval = 0;\n\n\tif (tx_info->control.rates[0].flags & IEEE80211_TX_RC_USE_CTS_PROTECT)\n\t\tdata_length = sizeof(struct ieee80211_cts);\n\telse\n\t\tdata_length = sizeof(struct ieee80211_rts);\n\n\tskb = dev_alloc_skb(data_length + rt2x00dev->hw->extra_tx_headroom);\n\tif (unlikely(!skb)) {\n\t\trt2x00_warn(rt2x00dev, \"Failed to create RTS/CTS frame\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_reserve(skb, rt2x00dev->hw->extra_tx_headroom);\n\tskb_put(skb, data_length);\n\n\t \n\tmemcpy(skb->cb, frag_skb->cb, sizeof(skb->cb));\n\trts_info = IEEE80211_SKB_CB(skb);\n\trts_info->control.rates[0].flags &= ~IEEE80211_TX_RC_USE_RTS_CTS;\n\trts_info->control.rates[0].flags &= ~IEEE80211_TX_RC_USE_CTS_PROTECT;\n\n\tif (tx_info->control.rates[0].flags & IEEE80211_TX_RC_USE_CTS_PROTECT)\n\t\trts_info->flags |= IEEE80211_TX_CTL_NO_ACK;\n\telse\n\t\trts_info->flags &= ~IEEE80211_TX_CTL_NO_ACK;\n\n\t \n\trts_info->control.hw_key = NULL;\n\n\t \n\tdata_length += rt2x00crypto_tx_overhead(rt2x00dev, skb);\n\n\tif (tx_info->control.rates[0].flags & IEEE80211_TX_RC_USE_CTS_PROTECT)\n\t\tieee80211_ctstoself_get(rt2x00dev->hw, tx_info->control.vif,\n\t\t\t\t\tfrag_skb->data, data_length, tx_info,\n\t\t\t\t\t(struct ieee80211_cts *)(skb->data));\n\telse\n\t\tieee80211_rts_get(rt2x00dev->hw, tx_info->control.vif,\n\t\t\t\t  frag_skb->data, data_length, tx_info,\n\t\t\t\t  (struct ieee80211_rts *)(skb->data));\n\n\tretval = rt2x00queue_write_tx_frame(queue, skb, NULL, true);\n\tif (retval) {\n\t\tdev_kfree_skb_any(skb);\n\t\trt2x00_warn(rt2x00dev, \"Failed to send RTS/CTS frame\\n\");\n\t}\n\n\treturn retval;\n}\n\nvoid rt2x00mac_tx(struct ieee80211_hw *hw,\n\t\t  struct ieee80211_tx_control *control,\n\t\t  struct sk_buff *skb)\n{\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tenum data_queue_qid qid = skb_get_queue_mapping(skb);\n\tstruct data_queue *queue = NULL;\n\n\t \n\tif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\n\t\tgoto exit_free_skb;\n\n\t \n\tif (tx_info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM &&\n\t    rt2x00_has_cap_flag(rt2x00dev, REQUIRE_ATIM_QUEUE))\n\t\tqid = QID_ATIM;\n\n\tqueue = rt2x00queue_get_tx_queue(rt2x00dev, qid);\n\tif (unlikely(!queue)) {\n\t\trt2x00_err(rt2x00dev,\n\t\t\t   \"Attempt to send packet over invalid queue %d\\n\"\n\t\t\t   \"Please file bug report to %s\\n\", qid, DRV_PROJECT);\n\t\tgoto exit_free_skb;\n\t}\n\n\t \n\tif (!rt2x00dev->ops->hw->set_rts_threshold &&\n\t    (tx_info->control.rates[0].flags & (IEEE80211_TX_RC_USE_RTS_CTS |\n\t\t\t\t\t\tIEEE80211_TX_RC_USE_CTS_PROTECT))) {\n\t\tif (rt2x00queue_available(queue) <= 1) {\n\t\t\t \n\t\t\tspin_lock(&queue->tx_lock);\n\t\t\tif (rt2x00queue_threshold(queue))\n\t\t\t\trt2x00queue_pause_queue(queue);\n\t\t\tspin_unlock(&queue->tx_lock);\n\n\t\t\tgoto exit_free_skb;\n\t\t}\n\n\t\tif (rt2x00mac_tx_rts_cts(rt2x00dev, queue, skb))\n\t\t\tgoto exit_free_skb;\n\t}\n\n\tif (unlikely(rt2x00queue_write_tx_frame(queue, skb, control->sta, false)))\n\t\tgoto exit_free_skb;\n\n\treturn;\n\n exit_free_skb:\n\tieee80211_free_txskb(hw, skb);\n}\nEXPORT_SYMBOL_GPL(rt2x00mac_tx);\n\nint rt2x00mac_start(struct ieee80211_hw *hw)\n{\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\n\tif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\n\t\treturn 0;\n\n\tif (test_bit(DEVICE_STATE_STARTED, &rt2x00dev->flags)) {\n\t\t \n\t\tset_bit(DEVICE_STATE_RESET, &rt2x00dev->flags);\n\t\trt2x00dev->ops->lib->pre_reset_hw(rt2x00dev);\n\t\trt2x00lib_stop(rt2x00dev);\n\t}\n\treturn rt2x00lib_start(rt2x00dev);\n}\nEXPORT_SYMBOL_GPL(rt2x00mac_start);\n\nvoid rt2x00mac_stop(struct ieee80211_hw *hw)\n{\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\n\tif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\n\t\treturn;\n\n\trt2x00lib_stop(rt2x00dev);\n}\nEXPORT_SYMBOL_GPL(rt2x00mac_stop);\n\nvoid\nrt2x00mac_reconfig_complete(struct ieee80211_hw *hw,\n\t\t\t    enum ieee80211_reconfig_type reconfig_type)\n{\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\n\tif (reconfig_type == IEEE80211_RECONFIG_TYPE_RESTART)\n\t\tclear_bit(DEVICE_STATE_RESET, &rt2x00dev->flags);\n}\nEXPORT_SYMBOL_GPL(rt2x00mac_reconfig_complete);\n\nint rt2x00mac_add_interface(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\tstruct rt2x00_intf *intf = vif_to_intf(vif);\n\tstruct data_queue *queue = rt2x00dev->bcn;\n\tstruct queue_entry *entry = NULL;\n\tunsigned int i;\n\n\t \n\tif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags) ||\n\t    !test_bit(DEVICE_STATE_STARTED, &rt2x00dev->flags))\n\t\treturn -ENODEV;\n\n\t \n\tfor (i = 0; i < queue->limit; i++) {\n\t\tentry = &queue->entries[i];\n\t\tif (!test_and_set_bit(ENTRY_BCN_ASSIGNED, &entry->flags))\n\t\t\tbreak;\n\t}\n\n\tif (unlikely(i == queue->limit))\n\t\treturn -ENOBUFS;\n\n\t \n\n\tif (vif->type == NL80211_IFTYPE_AP)\n\t\trt2x00dev->intf_ap_count++;\n\telse\n\t\trt2x00dev->intf_sta_count++;\n\n\tmutex_init(&intf->beacon_skb_mutex);\n\tintf->beacon = entry;\n\n\t \n\trt2x00lib_config_intf(rt2x00dev, intf, vif->type,\n\t\t\t      vif->addr, NULL);\n\n\t \n\trt2x00dev->packet_filter = 0;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rt2x00mac_add_interface);\n\nvoid rt2x00mac_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\tstruct rt2x00_intf *intf = vif_to_intf(vif);\n\n\t \n\tif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags) ||\n\t    (vif->type == NL80211_IFTYPE_AP && !rt2x00dev->intf_ap_count) ||\n\t    (vif->type != NL80211_IFTYPE_AP && !rt2x00dev->intf_sta_count))\n\t\treturn;\n\n\tif (vif->type == NL80211_IFTYPE_AP)\n\t\trt2x00dev->intf_ap_count--;\n\telse\n\t\trt2x00dev->intf_sta_count--;\n\n\t \n\tclear_bit(ENTRY_BCN_ASSIGNED, &intf->beacon->flags);\n\n\t \n\trt2x00lib_config_intf(rt2x00dev, intf,\n\t\t\t      NL80211_IFTYPE_UNSPECIFIED, NULL, NULL);\n}\nEXPORT_SYMBOL_GPL(rt2x00mac_remove_interface);\n\nint rt2x00mac_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\n\t \n\tif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\n\t\treturn 0;\n\n\t \n\trt2x00queue_stop_queue(rt2x00dev->rx);\n\n\t \n\tmutex_lock(&rt2x00dev->conf_mutex);\n\n\t \n\trt2x00lib_config(rt2x00dev, conf, changed);\n\n\t \n\trt2x00lib_config_antenna(rt2x00dev, rt2x00dev->default_ant);\n\n\tmutex_unlock(&rt2x00dev->conf_mutex);\n\n\t \n\trt2x00queue_start_queue(rt2x00dev->rx);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rt2x00mac_config);\n\nvoid rt2x00mac_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\tunsigned int changed_flags,\n\t\t\t\tunsigned int *total_flags,\n\t\t\t\tu64 multicast)\n{\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\n\t \n\t*total_flags &=\n\t    FIF_ALLMULTI |\n\t    FIF_FCSFAIL |\n\t    FIF_PLCPFAIL |\n\t    FIF_CONTROL |\n\t    FIF_PSPOLL |\n\t    FIF_OTHER_BSS;\n\n\t \n\t*total_flags |= FIF_ALLMULTI;\n\n\t \n\tif (!rt2x00_has_cap_control_filters(rt2x00dev)) {\n\t\tif (*total_flags & FIF_CONTROL || *total_flags & FIF_PSPOLL)\n\t\t\t*total_flags |= FIF_CONTROL | FIF_PSPOLL;\n\t}\n\tif (!rt2x00_has_cap_control_filter_pspoll(rt2x00dev)) {\n\t\tif (*total_flags & FIF_CONTROL)\n\t\t\t*total_flags |= FIF_PSPOLL;\n\t}\n\n\trt2x00dev->packet_filter = *total_flags;\n\n\trt2x00dev->ops->lib->config_filter(rt2x00dev, *total_flags);\n}\nEXPORT_SYMBOL_GPL(rt2x00mac_configure_filter);\n\nstatic void rt2x00mac_set_tim_iter(void *data, u8 *mac,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct rt2x00_intf *intf = vif_to_intf(vif);\n\n\tif (vif->type != NL80211_IFTYPE_AP &&\n\t    vif->type != NL80211_IFTYPE_ADHOC &&\n\t    vif->type != NL80211_IFTYPE_MESH_POINT)\n\t\treturn;\n\n\tset_bit(DELAYED_UPDATE_BEACON, &intf->delayed_flags);\n}\n\nint rt2x00mac_set_tim(struct ieee80211_hw *hw, struct ieee80211_sta *sta,\n\t\t      bool set)\n{\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\n\tif (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\treturn 0;\n\n\tieee80211_iterate_active_interfaces_atomic(\n\t\trt2x00dev->hw, IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\trt2x00mac_set_tim_iter, rt2x00dev);\n\n\t \n\tieee80211_queue_work(rt2x00dev->hw, &rt2x00dev->intf_work);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rt2x00mac_set_tim);\n\n#ifdef CONFIG_RT2X00_LIB_CRYPTO\nstatic void memcpy_tkip(struct rt2x00lib_crypto *crypto, u8 *key, u8 key_len)\n{\n\tif (key_len > NL80211_TKIP_DATA_OFFSET_ENCR_KEY)\n\t\tmemcpy(crypto->key,\n\t\t       &key[NL80211_TKIP_DATA_OFFSET_ENCR_KEY],\n\t\t       sizeof(crypto->key));\n\n\tif (key_len > NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY)\n\t\tmemcpy(crypto->tx_mic,\n\t\t       &key[NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY],\n\t\t       sizeof(crypto->tx_mic));\n\n\tif (key_len > NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY)\n\t\tmemcpy(crypto->rx_mic,\n\t\t       &key[NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY],\n\t\t       sizeof(crypto->rx_mic));\n}\n\nint rt2x00mac_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t      struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t      struct ieee80211_key_conf *key)\n{\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\tint (*set_key) (struct rt2x00_dev *rt2x00dev,\n\t\t\tstruct rt2x00lib_crypto *crypto,\n\t\t\tstruct ieee80211_key_conf *key);\n\tstruct rt2x00lib_crypto crypto;\n\tstatic const u8 bcast_addr[ETH_ALEN] =\n\t\t{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, };\n\tstruct rt2x00_sta *sta_priv = NULL;\n\n\tif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\n\t\treturn 0;\n\n\t \n\tif (!rt2x00_has_cap_hw_crypto(rt2x00dev) || (sta && sta->mfp))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (vif->type == NL80211_IFTYPE_ADHOC &&\n\t    !(key->flags & IEEE80211_KEY_FLAG_PAIRWISE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (key->keylen > 32)\n\t\treturn -ENOSPC;\n\n\tmemset(&crypto, 0, sizeof(crypto));\n\n\tcrypto.bssidx = rt2x00lib_get_bssidx(rt2x00dev, vif);\n\tcrypto.cipher = rt2x00crypto_key_to_cipher(key);\n\tif (crypto.cipher == CIPHER_NONE)\n\t\treturn -EOPNOTSUPP;\n\tif (crypto.cipher == CIPHER_TKIP && rt2x00_is_usb(rt2x00dev))\n\t\treturn -EOPNOTSUPP;\n\n\tcrypto.cmd = cmd;\n\n\tif (sta) {\n\t\tcrypto.address = sta->addr;\n\t\tsta_priv = sta_to_rt2x00_sta(sta);\n\t\tcrypto.wcid = sta_priv->wcid;\n\t} else\n\t\tcrypto.address = bcast_addr;\n\n\tif (crypto.cipher == CIPHER_TKIP)\n\t\tmemcpy_tkip(&crypto, &key->key[0], key->keylen);\n\telse\n\t\tmemcpy(crypto.key, &key->key[0], key->keylen);\n\t \n\tif (cmd == SET_KEY)\n\t\tkey->hw_key_idx = 0;\n\n\tif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)\n\t\tset_key = rt2x00dev->ops->lib->config_pairwise_key;\n\telse\n\t\tset_key = rt2x00dev->ops->lib->config_shared_key;\n\n\tif (!set_key)\n\t\treturn -EOPNOTSUPP;\n\n\treturn set_key(rt2x00dev, &crypto, key);\n}\nEXPORT_SYMBOL_GPL(rt2x00mac_set_key);\n#endif  \n\nvoid rt2x00mac_sw_scan_start(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     const u8 *mac_addr)\n{\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\tset_bit(DEVICE_STATE_SCANNING, &rt2x00dev->flags);\n\trt2x00link_stop_tuner(rt2x00dev);\n}\nEXPORT_SYMBOL_GPL(rt2x00mac_sw_scan_start);\n\nvoid rt2x00mac_sw_scan_complete(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\tclear_bit(DEVICE_STATE_SCANNING, &rt2x00dev->flags);\n\trt2x00link_start_tuner(rt2x00dev);\n}\nEXPORT_SYMBOL_GPL(rt2x00mac_sw_scan_complete);\n\nint rt2x00mac_get_stats(struct ieee80211_hw *hw,\n\t\t\tstruct ieee80211_low_level_stats *stats)\n{\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\n\t \n\tmemcpy(stats, &rt2x00dev->low_level_stats, sizeof(*stats));\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rt2x00mac_get_stats);\n\nvoid rt2x00mac_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_bss_conf *bss_conf,\n\t\t\t\tu64 changes)\n{\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\tstruct rt2x00_intf *intf = vif_to_intf(vif);\n\n\t \n\tif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\n\t\treturn;\n\n\t \n\tif (changes & BSS_CHANGED_BSSID)\n\t\trt2x00lib_config_intf(rt2x00dev, intf, vif->type, NULL,\n\t\t\t\t      bss_conf->bssid);\n\n\t \n\tif (changes & BSS_CHANGED_BEACON_ENABLED) {\n\t\tmutex_lock(&intf->beacon_skb_mutex);\n\t\tif (!bss_conf->enable_beacon && intf->enable_beacon) {\n\t\t\trt2x00dev->intf_beaconing--;\n\t\t\tintf->enable_beacon = false;\n\n\t\t\tif (rt2x00dev->intf_beaconing == 0) {\n\t\t\t\t \n\t\t\t\trt2x00queue_stop_queue(rt2x00dev->bcn);\n\t\t\t}\n\t\t\t \n\t\t\trt2x00queue_clear_beacon(rt2x00dev, vif);\n\t\t} else if (bss_conf->enable_beacon && !intf->enable_beacon) {\n\t\t\trt2x00dev->intf_beaconing++;\n\t\t\tintf->enable_beacon = true;\n\t\t\t \n\t\t\tif (rt2x00_is_usb(rt2x00dev))\n\t\t\t\trt2x00queue_update_beacon(rt2x00dev, vif);\n\n\t\t\tif (rt2x00dev->intf_beaconing == 1) {\n\t\t\t\t \n\t\t\t\trt2x00queue_start_queue(rt2x00dev->bcn);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&intf->beacon_skb_mutex);\n\t}\n\n\t \n\tif (changes & BSS_CHANGED_ASSOC) {\n\t\trt2x00dev->link.count = 0;\n\n\t\tif (vif->cfg.assoc)\n\t\t\trt2x00dev->intf_associated++;\n\t\telse\n\t\t\trt2x00dev->intf_associated--;\n\n\t\trt2x00leds_led_assoc(rt2x00dev, !!rt2x00dev->intf_associated);\n\t}\n\n\t \n\tif (changes & (BSS_CHANGED_ERP_CTS_PROT | BSS_CHANGED_ERP_PREAMBLE |\n\t\t       BSS_CHANGED_ERP_SLOT | BSS_CHANGED_BASIC_RATES |\n\t\t       BSS_CHANGED_BEACON_INT | BSS_CHANGED_HT))\n\t\trt2x00lib_config_erp(rt2x00dev, intf, bss_conf, changes);\n}\nEXPORT_SYMBOL_GPL(rt2x00mac_bss_info_changed);\n\nint rt2x00mac_conf_tx(struct ieee80211_hw *hw,\n\t\t      struct ieee80211_vif *vif,\n\t\t      unsigned int link_id, u16 queue_idx,\n\t\t      const struct ieee80211_tx_queue_params *params)\n{\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\tstruct data_queue *queue;\n\n\tqueue = rt2x00queue_get_tx_queue(rt2x00dev, queue_idx);\n\tif (unlikely(!queue))\n\t\treturn -EINVAL;\n\n\t \n\tif (params->cw_min > 0)\n\t\tqueue->cw_min = fls(params->cw_min);\n\telse\n\t\tqueue->cw_min = 5;  \n\n\tif (params->cw_max > 0)\n\t\tqueue->cw_max = fls(params->cw_max);\n\telse\n\t\tqueue->cw_max = 10;  \n\n\tqueue->aifs = params->aifs;\n\tqueue->txop = params->txop;\n\n\trt2x00_dbg(rt2x00dev,\n\t\t   \"Configured TX queue %d - CWmin: %d, CWmax: %d, Aifs: %d, TXop: %d\\n\",\n\t\t   queue_idx, queue->cw_min, queue->cw_max, queue->aifs,\n\t\t   queue->txop);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rt2x00mac_conf_tx);\n\nvoid rt2x00mac_rfkill_poll(struct ieee80211_hw *hw)\n{\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\tbool active = !!rt2x00dev->ops->lib->rfkill_poll(rt2x00dev);\n\n\twiphy_rfkill_set_hw_state(hw->wiphy, !active);\n}\nEXPORT_SYMBOL_GPL(rt2x00mac_rfkill_poll);\n\nvoid rt2x00mac_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t     u32 queues, bool drop)\n{\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\tstruct data_queue *queue;\n\n\tif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\n\t\treturn;\n\n\tset_bit(DEVICE_STATE_FLUSHING, &rt2x00dev->flags);\n\n\ttx_queue_for_each(rt2x00dev, queue)\n\t\trt2x00queue_flush_queue(queue, drop);\n\n\tclear_bit(DEVICE_STATE_FLUSHING, &rt2x00dev->flags);\n}\nEXPORT_SYMBOL_GPL(rt2x00mac_flush);\n\nint rt2x00mac_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)\n{\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\tstruct link_ant *ant = &rt2x00dev->link.ant;\n\tstruct antenna_setup *def = &rt2x00dev->default_ant;\n\tstruct antenna_setup setup;\n\n\t \n\t \n\tif (!tx_ant || (tx_ant & ~3) || !rx_ant || (rx_ant & ~3))\n\t\treturn -EINVAL;\n\n\t\n\t\n\t\n\tif (ant->flags & ANTENNA_TX_DIVERSITY && tx_ant != 3)\n\t\tant->flags &= ~ANTENNA_TX_DIVERSITY;\n\tif (ant->flags & ANTENNA_RX_DIVERSITY && rx_ant != 3)\n\t\tant->flags &= ~ANTENNA_RX_DIVERSITY;\n\n\t\n\t\n\t\n\t\n\tif (tx_ant == 3 && def->tx == ANTENNA_SW_DIVERSITY) {\n\t\ttx_ant = ANTENNA_SW_DIVERSITY;\n\t\tant->flags |= ANTENNA_TX_DIVERSITY;\n\t}\n\n\tif (rx_ant == 3 && def->rx == ANTENNA_SW_DIVERSITY) {\n\t\trx_ant = ANTENNA_SW_DIVERSITY;\n\t\tant->flags |= ANTENNA_RX_DIVERSITY;\n\t}\n\n\tsetup.tx = tx_ant;\n\tsetup.rx = rx_ant;\n\tsetup.rx_chain_num = 0;\n\tsetup.tx_chain_num = 0;\n\n\trt2x00lib_config_antenna(rt2x00dev, setup);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rt2x00mac_set_antenna);\n\nint rt2x00mac_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant)\n{\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\tstruct link_ant *ant = &rt2x00dev->link.ant;\n\tstruct antenna_setup *active = &rt2x00dev->link.ant.active;\n\n\t\n\t\n\tif (ant->flags & ANTENNA_TX_DIVERSITY)\n\t\t*tx_ant = ANTENNA_HW_DIVERSITY;\n\telse\n\t\t*tx_ant = active->tx;\n\n\tif (ant->flags & ANTENNA_RX_DIVERSITY)\n\t\t*rx_ant = ANTENNA_HW_DIVERSITY;\n\telse\n\t\t*rx_ant = active->rx;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rt2x00mac_get_antenna);\n\nvoid rt2x00mac_get_ringparam(struct ieee80211_hw *hw,\n\t\t\t     u32 *tx, u32 *tx_max, u32 *rx, u32 *rx_max)\n{\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\tstruct data_queue *queue;\n\n\ttx_queue_for_each(rt2x00dev, queue) {\n\t\t*tx += queue->length;\n\t\t*tx_max += queue->limit;\n\t}\n\n\t*rx = rt2x00dev->rx->length;\n\t*rx_max = rt2x00dev->rx->limit;\n}\nEXPORT_SYMBOL_GPL(rt2x00mac_get_ringparam);\n\nbool rt2x00mac_tx_frames_pending(struct ieee80211_hw *hw)\n{\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\tstruct data_queue *queue;\n\n\ttx_queue_for_each(rt2x00dev, queue) {\n\t\tif (!rt2x00queue_empty(queue))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(rt2x00mac_tx_frames_pending);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}