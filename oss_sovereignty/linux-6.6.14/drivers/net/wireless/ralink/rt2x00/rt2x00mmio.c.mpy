{
  "module_name": "rt2x00mmio.c",
  "hash_id": "1500d73a2bd88a654972365836796024a2b73d9955cfee45d26a8b251bf14892",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ralink/rt2x00/rt2x00mmio.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/dma-mapping.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include \"rt2x00.h\"\n#include \"rt2x00mmio.h\"\n\n \nint rt2x00mmio_regbusy_read(struct rt2x00_dev *rt2x00dev,\n\t\t\t    const unsigned int offset,\n\t\t\t    const struct rt2x00_field32 field,\n\t\t\t    u32 *reg)\n{\n\tunsigned int i;\n\n\tif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\n\t\treturn 0;\n\n\tfor (i = 0; i < REGISTER_BUSY_COUNT; i++) {\n\t\t*reg = rt2x00mmio_register_read(rt2x00dev, offset);\n\t\tif (!rt2x00_get_field32(*reg, field))\n\t\t\treturn 1;\n\t\tudelay(REGISTER_BUSY_DELAY);\n\t}\n\n\tprintk_once(KERN_ERR \"%s() Indirect register access failed: \"\n\t      \"offset=0x%.08x, value=0x%.08x\\n\", __func__, offset, *reg);\n\t*reg = ~0;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rt2x00mmio_regbusy_read);\n\nbool rt2x00mmio_rxdone(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct data_queue *queue = rt2x00dev->rx;\n\tstruct queue_entry *entry;\n\tstruct queue_entry_priv_mmio *entry_priv;\n\tstruct skb_frame_desc *skbdesc;\n\tint max_rx = 16;\n\n\twhile (--max_rx) {\n\t\tentry = rt2x00queue_get_entry(queue, Q_INDEX);\n\t\tentry_priv = entry->priv_data;\n\n\t\tif (rt2x00dev->ops->lib->get_entry_state(entry))\n\t\t\tbreak;\n\n\t\t \n\t\tskbdesc = get_skb_frame_desc(entry->skb);\n\t\tskbdesc->desc = entry_priv->desc;\n\t\tskbdesc->desc_len = entry->queue->desc_size;\n\n\t\t \n\t\trt2x00lib_dmastart(entry);\n\t\trt2x00lib_dmadone(entry);\n\n\t\t \n\t\trt2x00lib_rxdone(entry, GFP_ATOMIC);\n\t}\n\n\treturn !max_rx;\n}\nEXPORT_SYMBOL_GPL(rt2x00mmio_rxdone);\n\nvoid rt2x00mmio_flush_queue(struct data_queue *queue, bool drop)\n{\n\tunsigned int i;\n\n\tfor (i = 0; !rt2x00queue_empty(queue) && i < 10; i++)\n\t\tmsleep(50);\n}\nEXPORT_SYMBOL_GPL(rt2x00mmio_flush_queue);\n\n \nstatic int rt2x00mmio_alloc_queue_dma(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t      struct data_queue *queue)\n{\n\tstruct queue_entry_priv_mmio *entry_priv;\n\tvoid *addr;\n\tdma_addr_t dma;\n\tunsigned int i;\n\n\t \n\taddr = dma_alloc_coherent(rt2x00dev->dev,\n\t\t\t\t  queue->limit * queue->desc_size, &dma,\n\t\t\t\t  GFP_KERNEL);\n\tif (!addr)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < queue->limit; i++) {\n\t\tentry_priv = queue->entries[i].priv_data;\n\t\tentry_priv->desc = addr + i * queue->desc_size;\n\t\tentry_priv->desc_dma = dma + i * queue->desc_size;\n\t}\n\n\treturn 0;\n}\n\nstatic void rt2x00mmio_free_queue_dma(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t      struct data_queue *queue)\n{\n\tstruct queue_entry_priv_mmio *entry_priv =\n\t    queue->entries[0].priv_data;\n\n\tif (entry_priv->desc)\n\t\tdma_free_coherent(rt2x00dev->dev,\n\t\t\t\t  queue->limit * queue->desc_size,\n\t\t\t\t  entry_priv->desc, entry_priv->desc_dma);\n\tentry_priv->desc = NULL;\n}\n\nint rt2x00mmio_initialize(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct data_queue *queue;\n\tint status;\n\n\t \n\tqueue_for_each(rt2x00dev, queue) {\n\t\tstatus = rt2x00mmio_alloc_queue_dma(rt2x00dev, queue);\n\t\tif (status)\n\t\t\tgoto exit;\n\t}\n\n\t \n\tstatus = request_irq(rt2x00dev->irq,\n\t\t\t     rt2x00dev->ops->lib->irq_handler,\n\t\t\t     IRQF_SHARED, rt2x00dev->name, rt2x00dev);\n\tif (status) {\n\t\trt2x00_err(rt2x00dev, \"IRQ %d allocation failed (error %d)\\n\",\n\t\t\t   rt2x00dev->irq, status);\n\t\tgoto exit;\n\t}\n\n\treturn 0;\n\nexit:\n\tqueue_for_each(rt2x00dev, queue)\n\t\trt2x00mmio_free_queue_dma(rt2x00dev, queue);\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(rt2x00mmio_initialize);\n\nvoid rt2x00mmio_uninitialize(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct data_queue *queue;\n\n\t \n\tfree_irq(rt2x00dev->irq, rt2x00dev);\n\n\t \n\tqueue_for_each(rt2x00dev, queue)\n\t\trt2x00mmio_free_queue_dma(rt2x00dev, queue);\n}\nEXPORT_SYMBOL_GPL(rt2x00mmio_uninitialize);\n\n \nMODULE_AUTHOR(DRV_PROJECT);\nMODULE_VERSION(DRV_VERSION);\nMODULE_DESCRIPTION(\"rt2x00 mmio library\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}