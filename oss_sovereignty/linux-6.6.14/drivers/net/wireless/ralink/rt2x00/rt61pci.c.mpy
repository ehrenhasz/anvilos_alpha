{
  "module_name": "rt61pci.c",
  "hash_id": "5428e3786e4bd97664a2c941d909aea281bd08e03b2eeda5f4a1dfebc4aa7815",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ralink/rt2x00/rt61pci.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/crc-itu-t.h>\n#include <linux/delay.h>\n#include <linux/etherdevice.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/eeprom_93cx6.h>\n\n#include \"rt2x00.h\"\n#include \"rt2x00mmio.h\"\n#include \"rt2x00pci.h\"\n#include \"rt61pci.h\"\n\n \nstatic bool modparam_nohwcrypt = false;\nmodule_param_named(nohwcrypt, modparam_nohwcrypt, bool, 0444);\nMODULE_PARM_DESC(nohwcrypt, \"Disable hardware encryption.\");\n\n \n#define WAIT_FOR_BBP(__dev, __reg) \\\n\trt2x00mmio_regbusy_read((__dev), PHY_CSR3, PHY_CSR3_BUSY, (__reg))\n#define WAIT_FOR_RF(__dev, __reg) \\\n\trt2x00mmio_regbusy_read((__dev), PHY_CSR4, PHY_CSR4_BUSY, (__reg))\n#define WAIT_FOR_MCU(__dev, __reg) \\\n\trt2x00mmio_regbusy_read((__dev), H2M_MAILBOX_CSR, \\\n\t\t\t\tH2M_MAILBOX_CSR_OWNER, (__reg))\n\nstatic void rt61pci_bbp_write(struct rt2x00_dev *rt2x00dev,\n\t\t\t      const unsigned int word, const u8 value)\n{\n\tu32 reg;\n\n\tmutex_lock(&rt2x00dev->csr_mutex);\n\n\t \n\tif (WAIT_FOR_BBP(rt2x00dev, &reg)) {\n\t\treg = 0;\n\t\trt2x00_set_field32(&reg, PHY_CSR3_VALUE, value);\n\t\trt2x00_set_field32(&reg, PHY_CSR3_REGNUM, word);\n\t\trt2x00_set_field32(&reg, PHY_CSR3_BUSY, 1);\n\t\trt2x00_set_field32(&reg, PHY_CSR3_READ_CONTROL, 0);\n\n\t\trt2x00mmio_register_write(rt2x00dev, PHY_CSR3, reg);\n\t}\n\n\tmutex_unlock(&rt2x00dev->csr_mutex);\n}\n\nstatic u8 rt61pci_bbp_read(struct rt2x00_dev *rt2x00dev,\n\t\t\t   const unsigned int word)\n{\n\tu32 reg;\n\tu8 value;\n\n\tmutex_lock(&rt2x00dev->csr_mutex);\n\n\t \n\tif (WAIT_FOR_BBP(rt2x00dev, &reg)) {\n\t\treg = 0;\n\t\trt2x00_set_field32(&reg, PHY_CSR3_REGNUM, word);\n\t\trt2x00_set_field32(&reg, PHY_CSR3_BUSY, 1);\n\t\trt2x00_set_field32(&reg, PHY_CSR3_READ_CONTROL, 1);\n\n\t\trt2x00mmio_register_write(rt2x00dev, PHY_CSR3, reg);\n\n\t\tWAIT_FOR_BBP(rt2x00dev, &reg);\n\t}\n\n\tvalue = rt2x00_get_field32(reg, PHY_CSR3_VALUE);\n\n\tmutex_unlock(&rt2x00dev->csr_mutex);\n\n\treturn value;\n}\n\nstatic void rt61pci_rf_write(struct rt2x00_dev *rt2x00dev,\n\t\t\t     const unsigned int word, const u32 value)\n{\n\tu32 reg;\n\n\tmutex_lock(&rt2x00dev->csr_mutex);\n\n\t \n\tif (WAIT_FOR_RF(rt2x00dev, &reg)) {\n\t\treg = 0;\n\t\trt2x00_set_field32(&reg, PHY_CSR4_VALUE, value);\n\t\trt2x00_set_field32(&reg, PHY_CSR4_NUMBER_OF_BITS, 21);\n\t\trt2x00_set_field32(&reg, PHY_CSR4_IF_SELECT, 0);\n\t\trt2x00_set_field32(&reg, PHY_CSR4_BUSY, 1);\n\n\t\trt2x00mmio_register_write(rt2x00dev, PHY_CSR4, reg);\n\t\trt2x00_rf_write(rt2x00dev, word, value);\n\t}\n\n\tmutex_unlock(&rt2x00dev->csr_mutex);\n}\n\nstatic void rt61pci_mcu_request(struct rt2x00_dev *rt2x00dev,\n\t\t\t\tconst u8 command, const u8 token,\n\t\t\t\tconst u8 arg0, const u8 arg1)\n{\n\tu32 reg;\n\n\tmutex_lock(&rt2x00dev->csr_mutex);\n\n\t \n\tif (WAIT_FOR_MCU(rt2x00dev, &reg)) {\n\t\trt2x00_set_field32(&reg, H2M_MAILBOX_CSR_OWNER, 1);\n\t\trt2x00_set_field32(&reg, H2M_MAILBOX_CSR_CMD_TOKEN, token);\n\t\trt2x00_set_field32(&reg, H2M_MAILBOX_CSR_ARG0, arg0);\n\t\trt2x00_set_field32(&reg, H2M_MAILBOX_CSR_ARG1, arg1);\n\t\trt2x00mmio_register_write(rt2x00dev, H2M_MAILBOX_CSR, reg);\n\n\t\treg = rt2x00mmio_register_read(rt2x00dev, HOST_CMD_CSR);\n\t\trt2x00_set_field32(&reg, HOST_CMD_CSR_HOST_COMMAND, command);\n\t\trt2x00_set_field32(&reg, HOST_CMD_CSR_INTERRUPT_MCU, 1);\n\t\trt2x00mmio_register_write(rt2x00dev, HOST_CMD_CSR, reg);\n\t}\n\n\tmutex_unlock(&rt2x00dev->csr_mutex);\n\n}\n\nstatic void rt61pci_eepromregister_read(struct eeprom_93cx6 *eeprom)\n{\n\tstruct rt2x00_dev *rt2x00dev = eeprom->data;\n\tu32 reg;\n\n\treg = rt2x00mmio_register_read(rt2x00dev, E2PROM_CSR);\n\n\teeprom->reg_data_in = !!rt2x00_get_field32(reg, E2PROM_CSR_DATA_IN);\n\teeprom->reg_data_out = !!rt2x00_get_field32(reg, E2PROM_CSR_DATA_OUT);\n\teeprom->reg_data_clock =\n\t    !!rt2x00_get_field32(reg, E2PROM_CSR_DATA_CLOCK);\n\teeprom->reg_chip_select =\n\t    !!rt2x00_get_field32(reg, E2PROM_CSR_CHIP_SELECT);\n}\n\nstatic void rt61pci_eepromregister_write(struct eeprom_93cx6 *eeprom)\n{\n\tstruct rt2x00_dev *rt2x00dev = eeprom->data;\n\tu32 reg = 0;\n\n\trt2x00_set_field32(&reg, E2PROM_CSR_DATA_IN, !!eeprom->reg_data_in);\n\trt2x00_set_field32(&reg, E2PROM_CSR_DATA_OUT, !!eeprom->reg_data_out);\n\trt2x00_set_field32(&reg, E2PROM_CSR_DATA_CLOCK,\n\t\t\t   !!eeprom->reg_data_clock);\n\trt2x00_set_field32(&reg, E2PROM_CSR_CHIP_SELECT,\n\t\t\t   !!eeprom->reg_chip_select);\n\n\trt2x00mmio_register_write(rt2x00dev, E2PROM_CSR, reg);\n}\n\n#ifdef CONFIG_RT2X00_LIB_DEBUGFS\nstatic const struct rt2x00debug rt61pci_rt2x00debug = {\n\t.owner\t= THIS_MODULE,\n\t.csr\t= {\n\t\t.read\t\t= rt2x00mmio_register_read,\n\t\t.write\t\t= rt2x00mmio_register_write,\n\t\t.flags\t\t= RT2X00DEBUGFS_OFFSET,\n\t\t.word_base\t= CSR_REG_BASE,\n\t\t.word_size\t= sizeof(u32),\n\t\t.word_count\t= CSR_REG_SIZE / sizeof(u32),\n\t},\n\t.eeprom\t= {\n\t\t.read\t\t= rt2x00_eeprom_read,\n\t\t.write\t\t= rt2x00_eeprom_write,\n\t\t.word_base\t= EEPROM_BASE,\n\t\t.word_size\t= sizeof(u16),\n\t\t.word_count\t= EEPROM_SIZE / sizeof(u16),\n\t},\n\t.bbp\t= {\n\t\t.read\t\t= rt61pci_bbp_read,\n\t\t.write\t\t= rt61pci_bbp_write,\n\t\t.word_base\t= BBP_BASE,\n\t\t.word_size\t= sizeof(u8),\n\t\t.word_count\t= BBP_SIZE / sizeof(u8),\n\t},\n\t.rf\t= {\n\t\t.read\t\t= rt2x00_rf_read,\n\t\t.write\t\t= rt61pci_rf_write,\n\t\t.word_base\t= RF_BASE,\n\t\t.word_size\t= sizeof(u32),\n\t\t.word_count\t= RF_SIZE / sizeof(u32),\n\t},\n};\n#endif  \n\nstatic int rt61pci_rfkill_poll(struct rt2x00_dev *rt2x00dev)\n{\n\tu32 reg;\n\n\treg = rt2x00mmio_register_read(rt2x00dev, MAC_CSR13);\n\treturn rt2x00_get_field32(reg, MAC_CSR13_VAL5);\n}\n\n#ifdef CONFIG_RT2X00_LIB_LEDS\nstatic void rt61pci_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t   enum led_brightness brightness)\n{\n\tstruct rt2x00_led *led =\n\t    container_of(led_cdev, struct rt2x00_led, led_dev);\n\tunsigned int enabled = brightness != LED_OFF;\n\tunsigned int a_mode =\n\t    (enabled && led->rt2x00dev->curr_band == NL80211_BAND_5GHZ);\n\tunsigned int bg_mode =\n\t    (enabled && led->rt2x00dev->curr_band == NL80211_BAND_2GHZ);\n\n\tif (led->type == LED_TYPE_RADIO) {\n\t\trt2x00_set_field16(&led->rt2x00dev->led_mcu_reg,\n\t\t\t\t   MCU_LEDCS_RADIO_STATUS, enabled);\n\n\t\trt61pci_mcu_request(led->rt2x00dev, MCU_LED, 0xff,\n\t\t\t\t    (led->rt2x00dev->led_mcu_reg & 0xff),\n\t\t\t\t    ((led->rt2x00dev->led_mcu_reg >> 8)));\n\t} else if (led->type == LED_TYPE_ASSOC) {\n\t\trt2x00_set_field16(&led->rt2x00dev->led_mcu_reg,\n\t\t\t\t   MCU_LEDCS_LINK_BG_STATUS, bg_mode);\n\t\trt2x00_set_field16(&led->rt2x00dev->led_mcu_reg,\n\t\t\t\t   MCU_LEDCS_LINK_A_STATUS, a_mode);\n\n\t\trt61pci_mcu_request(led->rt2x00dev, MCU_LED, 0xff,\n\t\t\t\t    (led->rt2x00dev->led_mcu_reg & 0xff),\n\t\t\t\t    ((led->rt2x00dev->led_mcu_reg >> 8)));\n\t} else if (led->type == LED_TYPE_QUALITY) {\n\t\t \n\t\trt61pci_mcu_request(led->rt2x00dev, MCU_LED_STRENGTH, 0xff,\n\t\t\t\t    brightness / (LED_FULL / 6), 0);\n\t}\n}\n\nstatic int rt61pci_blink_set(struct led_classdev *led_cdev,\n\t\t\t     unsigned long *delay_on,\n\t\t\t     unsigned long *delay_off)\n{\n\tstruct rt2x00_led *led =\n\t    container_of(led_cdev, struct rt2x00_led, led_dev);\n\tu32 reg;\n\n\treg = rt2x00mmio_register_read(led->rt2x00dev, MAC_CSR14);\n\trt2x00_set_field32(&reg, MAC_CSR14_ON_PERIOD, *delay_on);\n\trt2x00_set_field32(&reg, MAC_CSR14_OFF_PERIOD, *delay_off);\n\trt2x00mmio_register_write(led->rt2x00dev, MAC_CSR14, reg);\n\n\treturn 0;\n}\n\nstatic void rt61pci_init_led(struct rt2x00_dev *rt2x00dev,\n\t\t\t     struct rt2x00_led *led,\n\t\t\t     enum led_type type)\n{\n\tled->rt2x00dev = rt2x00dev;\n\tled->type = type;\n\tled->led_dev.brightness_set = rt61pci_brightness_set;\n\tled->led_dev.blink_set = rt61pci_blink_set;\n\tled->flags = LED_INITIALIZED;\n}\n#endif  \n\n \nstatic int rt61pci_config_shared_key(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t     struct rt2x00lib_crypto *crypto,\n\t\t\t\t     struct ieee80211_key_conf *key)\n{\n\t \n\treturn -EOPNOTSUPP;\n}\n\nstatic int rt61pci_config_pairwise_key(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t       struct rt2x00lib_crypto *crypto,\n\t\t\t\t       struct ieee80211_key_conf *key)\n{\n\tstruct hw_pairwise_ta_entry addr_entry;\n\tstruct hw_key_entry key_entry;\n\tu32 mask;\n\tu32 reg;\n\n\tif (crypto->cmd == SET_KEY) {\n\t\t \n\t\treg = rt2x00mmio_register_read(rt2x00dev, SEC_CSR2);\n\t\tif (reg && reg == ~0) {\n\t\t\tkey->hw_key_idx = 32;\n\t\t\treg = rt2x00mmio_register_read(rt2x00dev, SEC_CSR3);\n\t\t\tif (reg && reg == ~0)\n\t\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tkey->hw_key_idx += reg ? ffz(reg) : 0;\n\n\t\t \n\t\tmemcpy(key_entry.key, crypto->key,\n\t\t       sizeof(key_entry.key));\n\t\tmemcpy(key_entry.tx_mic, crypto->tx_mic,\n\t\t       sizeof(key_entry.tx_mic));\n\t\tmemcpy(key_entry.rx_mic, crypto->rx_mic,\n\t\t       sizeof(key_entry.rx_mic));\n\n\t\tmemset(&addr_entry, 0, sizeof(addr_entry));\n\t\tmemcpy(&addr_entry, crypto->address, ETH_ALEN);\n\t\taddr_entry.cipher = crypto->cipher;\n\n\t\treg = PAIRWISE_KEY_ENTRY(key->hw_key_idx);\n\t\trt2x00mmio_register_multiwrite(rt2x00dev, reg,\n\t\t\t\t\t       &key_entry, sizeof(key_entry));\n\n\t\treg = PAIRWISE_TA_ENTRY(key->hw_key_idx);\n\t\trt2x00mmio_register_multiwrite(rt2x00dev, reg,\n\t\t\t\t\t       &addr_entry, sizeof(addr_entry));\n\n\t\t \n\t\treg = rt2x00mmio_register_read(rt2x00dev, SEC_CSR4);\n\t\treg |= (1 << crypto->bssidx);\n\t\trt2x00mmio_register_write(rt2x00dev, SEC_CSR4, reg);\n\n\t\t \n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\n\t}\n\n\t \n\tif (key->hw_key_idx < 32) {\n\t\tmask = 1 << key->hw_key_idx;\n\n\t\treg = rt2x00mmio_register_read(rt2x00dev, SEC_CSR2);\n\t\tif (crypto->cmd == SET_KEY)\n\t\t\treg |= mask;\n\t\telse if (crypto->cmd == DISABLE_KEY)\n\t\t\treg &= ~mask;\n\t\trt2x00mmio_register_write(rt2x00dev, SEC_CSR2, reg);\n\t} else {\n\t\tmask = 1 << (key->hw_key_idx - 32);\n\n\t\treg = rt2x00mmio_register_read(rt2x00dev, SEC_CSR3);\n\t\tif (crypto->cmd == SET_KEY)\n\t\t\treg |= mask;\n\t\telse if (crypto->cmd == DISABLE_KEY)\n\t\t\treg &= ~mask;\n\t\trt2x00mmio_register_write(rt2x00dev, SEC_CSR3, reg);\n\t}\n\n\treturn 0;\n}\n\nstatic void rt61pci_config_filter(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t  const unsigned int filter_flags)\n{\n\tu32 reg;\n\n\t \n\treg = rt2x00mmio_register_read(rt2x00dev, TXRX_CSR0);\n\trt2x00_set_field32(&reg, TXRX_CSR0_DROP_CRC,\n\t\t\t   !(filter_flags & FIF_FCSFAIL));\n\trt2x00_set_field32(&reg, TXRX_CSR0_DROP_PHYSICAL,\n\t\t\t   !(filter_flags & FIF_PLCPFAIL));\n\trt2x00_set_field32(&reg, TXRX_CSR0_DROP_CONTROL,\n\t\t\t   !(filter_flags & (FIF_CONTROL | FIF_PSPOLL)));\n\trt2x00_set_field32(&reg, TXRX_CSR0_DROP_NOT_TO_ME,\n\t\t\t   !test_bit(CONFIG_MONITORING, &rt2x00dev->flags));\n\trt2x00_set_field32(&reg, TXRX_CSR0_DROP_TO_DS,\n\t\t\t   !test_bit(CONFIG_MONITORING, &rt2x00dev->flags) &&\n\t\t\t   !rt2x00dev->intf_ap_count);\n\trt2x00_set_field32(&reg, TXRX_CSR0_DROP_VERSION_ERROR, 1);\n\trt2x00_set_field32(&reg, TXRX_CSR0_DROP_MULTICAST,\n\t\t\t   !(filter_flags & FIF_ALLMULTI));\n\trt2x00_set_field32(&reg, TXRX_CSR0_DROP_BROADCAST, 0);\n\trt2x00_set_field32(&reg, TXRX_CSR0_DROP_ACK_CTS,\n\t\t\t   !(filter_flags & FIF_CONTROL));\n\trt2x00mmio_register_write(rt2x00dev, TXRX_CSR0, reg);\n}\n\nstatic void rt61pci_config_intf(struct rt2x00_dev *rt2x00dev,\n\t\t\t\tstruct rt2x00_intf *intf,\n\t\t\t\tstruct rt2x00intf_conf *conf,\n\t\t\t\tconst unsigned int flags)\n{\n\tu32 reg;\n\n\tif (flags & CONFIG_UPDATE_TYPE) {\n\t\t \n\t\treg = rt2x00mmio_register_read(rt2x00dev, TXRX_CSR9);\n\t\trt2x00_set_field32(&reg, TXRX_CSR9_TSF_SYNC, conf->sync);\n\t\trt2x00mmio_register_write(rt2x00dev, TXRX_CSR9, reg);\n\t}\n\n\tif (flags & CONFIG_UPDATE_MAC) {\n\t\treg = le32_to_cpu(conf->mac[1]);\n\t\trt2x00_set_field32(&reg, MAC_CSR3_UNICAST_TO_ME_MASK, 0xff);\n\t\tconf->mac[1] = cpu_to_le32(reg);\n\n\t\trt2x00mmio_register_multiwrite(rt2x00dev, MAC_CSR2,\n\t\t\t\t\t       conf->mac, sizeof(conf->mac));\n\t}\n\n\tif (flags & CONFIG_UPDATE_BSSID) {\n\t\treg = le32_to_cpu(conf->bssid[1]);\n\t\trt2x00_set_field32(&reg, MAC_CSR5_BSS_ID_MASK, 3);\n\t\tconf->bssid[1] = cpu_to_le32(reg);\n\n\t\trt2x00mmio_register_multiwrite(rt2x00dev, MAC_CSR4,\n\t\t\t\t\t       conf->bssid,\n\t\t\t\t\t       sizeof(conf->bssid));\n\t}\n}\n\nstatic void rt61pci_config_erp(struct rt2x00_dev *rt2x00dev,\n\t\t\t       struct rt2x00lib_erp *erp,\n\t\t\t       u32 changed)\n{\n\tu32 reg;\n\n\treg = rt2x00mmio_register_read(rt2x00dev, TXRX_CSR0);\n\trt2x00_set_field32(&reg, TXRX_CSR0_RX_ACK_TIMEOUT, 0x32);\n\trt2x00_set_field32(&reg, TXRX_CSR0_TSF_OFFSET, IEEE80211_HEADER);\n\trt2x00mmio_register_write(rt2x00dev, TXRX_CSR0, reg);\n\n\tif (changed & BSS_CHANGED_ERP_PREAMBLE) {\n\t\treg = rt2x00mmio_register_read(rt2x00dev, TXRX_CSR4);\n\t\trt2x00_set_field32(&reg, TXRX_CSR4_AUTORESPOND_ENABLE, 1);\n\t\trt2x00_set_field32(&reg, TXRX_CSR4_AUTORESPOND_PREAMBLE,\n\t\t\t\t   !!erp->short_preamble);\n\t\trt2x00mmio_register_write(rt2x00dev, TXRX_CSR4, reg);\n\t}\n\n\tif (changed & BSS_CHANGED_BASIC_RATES)\n\t\trt2x00mmio_register_write(rt2x00dev, TXRX_CSR5,\n\t\t\t\t\t  erp->basic_rates);\n\n\tif (changed & BSS_CHANGED_BEACON_INT) {\n\t\treg = rt2x00mmio_register_read(rt2x00dev, TXRX_CSR9);\n\t\trt2x00_set_field32(&reg, TXRX_CSR9_BEACON_INTERVAL,\n\t\t\t\t   erp->beacon_int * 16);\n\t\trt2x00mmio_register_write(rt2x00dev, TXRX_CSR9, reg);\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\treg = rt2x00mmio_register_read(rt2x00dev, MAC_CSR9);\n\t\trt2x00_set_field32(&reg, MAC_CSR9_SLOT_TIME, erp->slot_time);\n\t\trt2x00mmio_register_write(rt2x00dev, MAC_CSR9, reg);\n\n\t\treg = rt2x00mmio_register_read(rt2x00dev, MAC_CSR8);\n\t\trt2x00_set_field32(&reg, MAC_CSR8_SIFS, erp->sifs);\n\t\trt2x00_set_field32(&reg, MAC_CSR8_SIFS_AFTER_RX_OFDM, 3);\n\t\trt2x00_set_field32(&reg, MAC_CSR8_EIFS, erp->eifs);\n\t\trt2x00mmio_register_write(rt2x00dev, MAC_CSR8, reg);\n\t}\n}\n\nstatic void rt61pci_config_antenna_5x(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t      struct antenna_setup *ant)\n{\n\tu8 r3;\n\tu8 r4;\n\tu8 r77;\n\n\tr3 = rt61pci_bbp_read(rt2x00dev, 3);\n\tr4 = rt61pci_bbp_read(rt2x00dev, 4);\n\tr77 = rt61pci_bbp_read(rt2x00dev, 77);\n\n\trt2x00_set_field8(&r3, BBP_R3_SMART_MODE, rt2x00_rf(rt2x00dev, RF5325));\n\n\t \n\tswitch (ant->rx) {\n\tcase ANTENNA_HW_DIVERSITY:\n\t\trt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA_CONTROL, 2);\n\t\trt2x00_set_field8(&r4, BBP_R4_RX_FRAME_END,\n\t\t\t\t  (rt2x00dev->curr_band != NL80211_BAND_5GHZ));\n\t\tbreak;\n\tcase ANTENNA_A:\n\t\trt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA_CONTROL, 1);\n\t\trt2x00_set_field8(&r4, BBP_R4_RX_FRAME_END, 0);\n\t\tif (rt2x00dev->curr_band == NL80211_BAND_5GHZ)\n\t\t\trt2x00_set_field8(&r77, BBP_R77_RX_ANTENNA, 0);\n\t\telse\n\t\t\trt2x00_set_field8(&r77, BBP_R77_RX_ANTENNA, 3);\n\t\tbreak;\n\tcase ANTENNA_B:\n\tdefault:\n\t\trt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA_CONTROL, 1);\n\t\trt2x00_set_field8(&r4, BBP_R4_RX_FRAME_END, 0);\n\t\tif (rt2x00dev->curr_band == NL80211_BAND_5GHZ)\n\t\t\trt2x00_set_field8(&r77, BBP_R77_RX_ANTENNA, 3);\n\t\telse\n\t\t\trt2x00_set_field8(&r77, BBP_R77_RX_ANTENNA, 0);\n\t\tbreak;\n\t}\n\n\trt61pci_bbp_write(rt2x00dev, 77, r77);\n\trt61pci_bbp_write(rt2x00dev, 3, r3);\n\trt61pci_bbp_write(rt2x00dev, 4, r4);\n}\n\nstatic void rt61pci_config_antenna_2x(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t      struct antenna_setup *ant)\n{\n\tu8 r3;\n\tu8 r4;\n\tu8 r77;\n\n\tr3 = rt61pci_bbp_read(rt2x00dev, 3);\n\tr4 = rt61pci_bbp_read(rt2x00dev, 4);\n\tr77 = rt61pci_bbp_read(rt2x00dev, 77);\n\n\trt2x00_set_field8(&r3, BBP_R3_SMART_MODE, rt2x00_rf(rt2x00dev, RF2529));\n\trt2x00_set_field8(&r4, BBP_R4_RX_FRAME_END,\n\t\t\t  !rt2x00_has_cap_frame_type(rt2x00dev));\n\n\t \n\tswitch (ant->rx) {\n\tcase ANTENNA_HW_DIVERSITY:\n\t\trt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA_CONTROL, 2);\n\t\tbreak;\n\tcase ANTENNA_A:\n\t\trt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA_CONTROL, 1);\n\t\trt2x00_set_field8(&r77, BBP_R77_RX_ANTENNA, 3);\n\t\tbreak;\n\tcase ANTENNA_B:\n\tdefault:\n\t\trt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA_CONTROL, 1);\n\t\trt2x00_set_field8(&r77, BBP_R77_RX_ANTENNA, 0);\n\t\tbreak;\n\t}\n\n\trt61pci_bbp_write(rt2x00dev, 77, r77);\n\trt61pci_bbp_write(rt2x00dev, 3, r3);\n\trt61pci_bbp_write(rt2x00dev, 4, r4);\n}\n\nstatic void rt61pci_config_antenna_2529_rx(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t   const int p1, const int p2)\n{\n\tu32 reg;\n\n\treg = rt2x00mmio_register_read(rt2x00dev, MAC_CSR13);\n\n\trt2x00_set_field32(&reg, MAC_CSR13_DIR4, 0);\n\trt2x00_set_field32(&reg, MAC_CSR13_VAL4, p1);\n\n\trt2x00_set_field32(&reg, MAC_CSR13_DIR3, 0);\n\trt2x00_set_field32(&reg, MAC_CSR13_VAL3, !p2);\n\n\trt2x00mmio_register_write(rt2x00dev, MAC_CSR13, reg);\n}\n\nstatic void rt61pci_config_antenna_2529(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\tstruct antenna_setup *ant)\n{\n\tu8 r3;\n\tu8 r4;\n\tu8 r77;\n\n\tr3 = rt61pci_bbp_read(rt2x00dev, 3);\n\tr4 = rt61pci_bbp_read(rt2x00dev, 4);\n\tr77 = rt61pci_bbp_read(rt2x00dev, 77);\n\n\t \n\tswitch (ant->rx) {\n\tcase ANTENNA_A:\n\t\trt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA_CONTROL, 1);\n\t\trt2x00_set_field8(&r77, BBP_R77_RX_ANTENNA, 0);\n\t\trt61pci_config_antenna_2529_rx(rt2x00dev, 0, 0);\n\t\tbreak;\n\tcase ANTENNA_HW_DIVERSITY:\n\t\t \n\tcase ANTENNA_B:\n\tdefault:\n\t\trt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA_CONTROL, 1);\n\t\trt2x00_set_field8(&r77, BBP_R77_RX_ANTENNA, 3);\n\t\trt61pci_config_antenna_2529_rx(rt2x00dev, 1, 1);\n\t\tbreak;\n\t}\n\n\trt61pci_bbp_write(rt2x00dev, 77, r77);\n\trt61pci_bbp_write(rt2x00dev, 3, r3);\n\trt61pci_bbp_write(rt2x00dev, 4, r4);\n}\n\nstruct antenna_sel {\n\tu8 word;\n\t \n\tu8 value[2];\n};\n\nstatic const struct antenna_sel antenna_sel_a[] = {\n\t{ 96,  { 0x58, 0x78 } },\n\t{ 104, { 0x38, 0x48 } },\n\t{ 75,  { 0xfe, 0x80 } },\n\t{ 86,  { 0xfe, 0x80 } },\n\t{ 88,  { 0xfe, 0x80 } },\n\t{ 35,  { 0x60, 0x60 } },\n\t{ 97,  { 0x58, 0x58 } },\n\t{ 98,  { 0x58, 0x58 } },\n};\n\nstatic const struct antenna_sel antenna_sel_bg[] = {\n\t{ 96,  { 0x48, 0x68 } },\n\t{ 104, { 0x2c, 0x3c } },\n\t{ 75,  { 0xfe, 0x80 } },\n\t{ 86,  { 0xfe, 0x80 } },\n\t{ 88,  { 0xfe, 0x80 } },\n\t{ 35,  { 0x50, 0x50 } },\n\t{ 97,  { 0x48, 0x48 } },\n\t{ 98,  { 0x48, 0x48 } },\n};\n\nstatic void rt61pci_config_ant(struct rt2x00_dev *rt2x00dev,\n\t\t\t       struct antenna_setup *ant)\n{\n\tconst struct antenna_sel *sel;\n\tunsigned int lna;\n\tunsigned int i;\n\tu32 reg;\n\n\t \n\tBUG_ON(ant->rx == ANTENNA_SW_DIVERSITY ||\n\t       ant->tx == ANTENNA_SW_DIVERSITY);\n\n\tif (rt2x00dev->curr_band == NL80211_BAND_5GHZ) {\n\t\tsel = antenna_sel_a;\n\t\tlna = rt2x00_has_cap_external_lna_a(rt2x00dev);\n\t} else {\n\t\tsel = antenna_sel_bg;\n\t\tlna = rt2x00_has_cap_external_lna_bg(rt2x00dev);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(antenna_sel_a); i++)\n\t\trt61pci_bbp_write(rt2x00dev, sel[i].word, sel[i].value[lna]);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, PHY_CSR0);\n\n\trt2x00_set_field32(&reg, PHY_CSR0_PA_PE_BG,\n\t\t\t   rt2x00dev->curr_band == NL80211_BAND_2GHZ);\n\trt2x00_set_field32(&reg, PHY_CSR0_PA_PE_A,\n\t\t\t   rt2x00dev->curr_band == NL80211_BAND_5GHZ);\n\n\trt2x00mmio_register_write(rt2x00dev, PHY_CSR0, reg);\n\n\tif (rt2x00_rf(rt2x00dev, RF5225) || rt2x00_rf(rt2x00dev, RF5325))\n\t\trt61pci_config_antenna_5x(rt2x00dev, ant);\n\telse if (rt2x00_rf(rt2x00dev, RF2527))\n\t\trt61pci_config_antenna_2x(rt2x00dev, ant);\n\telse if (rt2x00_rf(rt2x00dev, RF2529)) {\n\t\tif (rt2x00_has_cap_double_antenna(rt2x00dev))\n\t\t\trt61pci_config_antenna_2x(rt2x00dev, ant);\n\t\telse\n\t\t\trt61pci_config_antenna_2529(rt2x00dev, ant);\n\t}\n}\n\nstatic void rt61pci_config_lna_gain(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t    struct rt2x00lib_conf *libconf)\n{\n\tu16 eeprom;\n\tshort lna_gain = 0;\n\n\tif (libconf->conf->chandef.chan->band == NL80211_BAND_2GHZ) {\n\t\tif (rt2x00_has_cap_external_lna_bg(rt2x00dev))\n\t\t\tlna_gain += 14;\n\n\t\teeprom = rt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_OFFSET_BG);\n\t\tlna_gain -= rt2x00_get_field16(eeprom, EEPROM_RSSI_OFFSET_BG_1);\n\t} else {\n\t\tif (rt2x00_has_cap_external_lna_a(rt2x00dev))\n\t\t\tlna_gain += 14;\n\n\t\teeprom = rt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_OFFSET_A);\n\t\tlna_gain -= rt2x00_get_field16(eeprom, EEPROM_RSSI_OFFSET_A_1);\n\t}\n\n\trt2x00dev->lna_gain = lna_gain;\n}\n\nstatic void rt61pci_config_channel(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t   struct rf_channel *rf, const int txpower)\n{\n\tu8 r3;\n\tu8 r94;\n\tu8 smart;\n\n\trt2x00_set_field32(&rf->rf3, RF3_TXPOWER, TXPOWER_TO_DEV(txpower));\n\trt2x00_set_field32(&rf->rf4, RF4_FREQ_OFFSET, rt2x00dev->freq_offset);\n\n\tsmart = !(rt2x00_rf(rt2x00dev, RF5225) || rt2x00_rf(rt2x00dev, RF2527));\n\n\tr3 = rt61pci_bbp_read(rt2x00dev, 3);\n\trt2x00_set_field8(&r3, BBP_R3_SMART_MODE, smart);\n\trt61pci_bbp_write(rt2x00dev, 3, r3);\n\n\tr94 = 6;\n\tif (txpower > MAX_TXPOWER && txpower <= (MAX_TXPOWER + r94))\n\t\tr94 += txpower - MAX_TXPOWER;\n\telse if (txpower < MIN_TXPOWER && txpower >= (MIN_TXPOWER - r94))\n\t\tr94 += txpower;\n\trt61pci_bbp_write(rt2x00dev, 94, r94);\n\n\trt61pci_rf_write(rt2x00dev, 1, rf->rf1);\n\trt61pci_rf_write(rt2x00dev, 2, rf->rf2);\n\trt61pci_rf_write(rt2x00dev, 3, rf->rf3 & ~0x00000004);\n\trt61pci_rf_write(rt2x00dev, 4, rf->rf4);\n\n\tudelay(200);\n\n\trt61pci_rf_write(rt2x00dev, 1, rf->rf1);\n\trt61pci_rf_write(rt2x00dev, 2, rf->rf2);\n\trt61pci_rf_write(rt2x00dev, 3, rf->rf3 | 0x00000004);\n\trt61pci_rf_write(rt2x00dev, 4, rf->rf4);\n\n\tudelay(200);\n\n\trt61pci_rf_write(rt2x00dev, 1, rf->rf1);\n\trt61pci_rf_write(rt2x00dev, 2, rf->rf2);\n\trt61pci_rf_write(rt2x00dev, 3, rf->rf3 & ~0x00000004);\n\trt61pci_rf_write(rt2x00dev, 4, rf->rf4);\n\n\tmsleep(1);\n}\n\nstatic void rt61pci_config_txpower(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t   const int txpower)\n{\n\tstruct rf_channel rf;\n\n\trf.rf1 = rt2x00_rf_read(rt2x00dev, 1);\n\trf.rf2 = rt2x00_rf_read(rt2x00dev, 2);\n\trf.rf3 = rt2x00_rf_read(rt2x00dev, 3);\n\trf.rf4 = rt2x00_rf_read(rt2x00dev, 4);\n\n\trt61pci_config_channel(rt2x00dev, &rf, txpower);\n}\n\nstatic void rt61pci_config_retry_limit(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t    struct rt2x00lib_conf *libconf)\n{\n\tu32 reg;\n\n\treg = rt2x00mmio_register_read(rt2x00dev, TXRX_CSR4);\n\trt2x00_set_field32(&reg, TXRX_CSR4_OFDM_TX_RATE_DOWN, 1);\n\trt2x00_set_field32(&reg, TXRX_CSR4_OFDM_TX_RATE_STEP, 0);\n\trt2x00_set_field32(&reg, TXRX_CSR4_OFDM_TX_FALLBACK_CCK, 0);\n\trt2x00_set_field32(&reg, TXRX_CSR4_LONG_RETRY_LIMIT,\n\t\t\t   libconf->conf->long_frame_max_tx_count);\n\trt2x00_set_field32(&reg, TXRX_CSR4_SHORT_RETRY_LIMIT,\n\t\t\t   libconf->conf->short_frame_max_tx_count);\n\trt2x00mmio_register_write(rt2x00dev, TXRX_CSR4, reg);\n}\n\nstatic void rt61pci_config_ps(struct rt2x00_dev *rt2x00dev,\n\t\t\t\tstruct rt2x00lib_conf *libconf)\n{\n\tenum dev_state state =\n\t    (libconf->conf->flags & IEEE80211_CONF_PS) ?\n\t\tSTATE_SLEEP : STATE_AWAKE;\n\tu32 reg;\n\n\tif (state == STATE_SLEEP) {\n\t\treg = rt2x00mmio_register_read(rt2x00dev, MAC_CSR11);\n\t\trt2x00_set_field32(&reg, MAC_CSR11_DELAY_AFTER_TBCN,\n\t\t\t\t   rt2x00dev->beacon_int - 10);\n\t\trt2x00_set_field32(&reg, MAC_CSR11_TBCN_BEFORE_WAKEUP,\n\t\t\t\t   libconf->conf->listen_interval - 1);\n\t\trt2x00_set_field32(&reg, MAC_CSR11_WAKEUP_LATENCY, 5);\n\n\t\t \n\t\trt2x00_set_field32(&reg, MAC_CSR11_AUTOWAKE, 0);\n\t\trt2x00mmio_register_write(rt2x00dev, MAC_CSR11, reg);\n\n\t\trt2x00_set_field32(&reg, MAC_CSR11_AUTOWAKE, 1);\n\t\trt2x00mmio_register_write(rt2x00dev, MAC_CSR11, reg);\n\n\t\trt2x00mmio_register_write(rt2x00dev, SOFT_RESET_CSR,\n\t\t\t\t\t  0x00000005);\n\t\trt2x00mmio_register_write(rt2x00dev, IO_CNTL_CSR, 0x0000001c);\n\t\trt2x00mmio_register_write(rt2x00dev, PCI_USEC_CSR, 0x00000060);\n\n\t\trt61pci_mcu_request(rt2x00dev, MCU_SLEEP, 0xff, 0, 0);\n\t} else {\n\t\treg = rt2x00mmio_register_read(rt2x00dev, MAC_CSR11);\n\t\trt2x00_set_field32(&reg, MAC_CSR11_DELAY_AFTER_TBCN, 0);\n\t\trt2x00_set_field32(&reg, MAC_CSR11_TBCN_BEFORE_WAKEUP, 0);\n\t\trt2x00_set_field32(&reg, MAC_CSR11_AUTOWAKE, 0);\n\t\trt2x00_set_field32(&reg, MAC_CSR11_WAKEUP_LATENCY, 0);\n\t\trt2x00mmio_register_write(rt2x00dev, MAC_CSR11, reg);\n\n\t\trt2x00mmio_register_write(rt2x00dev, SOFT_RESET_CSR,\n\t\t\t\t\t  0x00000007);\n\t\trt2x00mmio_register_write(rt2x00dev, IO_CNTL_CSR, 0x00000018);\n\t\trt2x00mmio_register_write(rt2x00dev, PCI_USEC_CSR, 0x00000020);\n\n\t\trt61pci_mcu_request(rt2x00dev, MCU_WAKEUP, 0xff, 0, 0);\n\t}\n}\n\nstatic void rt61pci_config(struct rt2x00_dev *rt2x00dev,\n\t\t\t   struct rt2x00lib_conf *libconf,\n\t\t\t   const unsigned int flags)\n{\n\t \n\trt61pci_config_lna_gain(rt2x00dev, libconf);\n\n\tif (flags & IEEE80211_CONF_CHANGE_CHANNEL)\n\t\trt61pci_config_channel(rt2x00dev, &libconf->rf,\n\t\t\t\t       libconf->conf->power_level);\n\tif ((flags & IEEE80211_CONF_CHANGE_POWER) &&\n\t    !(flags & IEEE80211_CONF_CHANGE_CHANNEL))\n\t\trt61pci_config_txpower(rt2x00dev, libconf->conf->power_level);\n\tif (flags & IEEE80211_CONF_CHANGE_RETRY_LIMITS)\n\t\trt61pci_config_retry_limit(rt2x00dev, libconf);\n\tif (flags & IEEE80211_CONF_CHANGE_PS)\n\t\trt61pci_config_ps(rt2x00dev, libconf);\n}\n\n \nstatic void rt61pci_link_stats(struct rt2x00_dev *rt2x00dev,\n\t\t\t       struct link_qual *qual)\n{\n\tu32 reg;\n\n\t \n\treg = rt2x00mmio_register_read(rt2x00dev, STA_CSR0);\n\tqual->rx_failed = rt2x00_get_field32(reg, STA_CSR0_FCS_ERROR);\n\n\t \n\treg = rt2x00mmio_register_read(rt2x00dev, STA_CSR1);\n\tqual->false_cca = rt2x00_get_field32(reg, STA_CSR1_FALSE_CCA_ERROR);\n}\n\nstatic inline void rt61pci_set_vgc(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t   struct link_qual *qual, u8 vgc_level)\n{\n\tif (qual->vgc_level != vgc_level) {\n\t\trt61pci_bbp_write(rt2x00dev, 17, vgc_level);\n\t\tqual->vgc_level = vgc_level;\n\t\tqual->vgc_level_reg = vgc_level;\n\t}\n}\n\nstatic void rt61pci_reset_tuner(struct rt2x00_dev *rt2x00dev,\n\t\t\t\tstruct link_qual *qual)\n{\n\trt61pci_set_vgc(rt2x00dev, qual, 0x20);\n}\n\nstatic void rt61pci_link_tuner(struct rt2x00_dev *rt2x00dev,\n\t\t\t       struct link_qual *qual, const u32 count)\n{\n\tu8 up_bound;\n\tu8 low_bound;\n\n\t \n\tif (rt2x00dev->curr_band == NL80211_BAND_5GHZ) {\n\t\tlow_bound = 0x28;\n\t\tup_bound = 0x48;\n\t\tif (rt2x00_has_cap_external_lna_a(rt2x00dev)) {\n\t\t\tlow_bound += 0x10;\n\t\t\tup_bound += 0x10;\n\t\t}\n\t} else {\n\t\tlow_bound = 0x20;\n\t\tup_bound = 0x40;\n\t\tif (rt2x00_has_cap_external_lna_bg(rt2x00dev)) {\n\t\t\tlow_bound += 0x10;\n\t\t\tup_bound += 0x10;\n\t\t}\n\t}\n\n\t \n\tif (!rt2x00dev->intf_associated)\n\t\tgoto dynamic_cca_tune;\n\n\t \n\tif (qual->rssi >= -35) {\n\t\trt61pci_set_vgc(rt2x00dev, qual, 0x60);\n\t\treturn;\n\t}\n\n\t \n\tif (qual->rssi >= -58) {\n\t\trt61pci_set_vgc(rt2x00dev, qual, up_bound);\n\t\treturn;\n\t}\n\n\t \n\tif (qual->rssi >= -66) {\n\t\trt61pci_set_vgc(rt2x00dev, qual, low_bound + 0x10);\n\t\treturn;\n\t}\n\n\t \n\tif (qual->rssi >= -74) {\n\t\trt61pci_set_vgc(rt2x00dev, qual, low_bound + 0x08);\n\t\treturn;\n\t}\n\n\t \n\tup_bound -= 2 * (-74 - qual->rssi);\n\tif (low_bound > up_bound)\n\t\tup_bound = low_bound;\n\n\tif (qual->vgc_level > up_bound) {\n\t\trt61pci_set_vgc(rt2x00dev, qual, up_bound);\n\t\treturn;\n\t}\n\ndynamic_cca_tune:\n\n\t \n\tif ((qual->false_cca > 512) && (qual->vgc_level < up_bound))\n\t\trt61pci_set_vgc(rt2x00dev, qual, ++qual->vgc_level);\n\telse if ((qual->false_cca < 100) && (qual->vgc_level > low_bound))\n\t\trt61pci_set_vgc(rt2x00dev, qual, --qual->vgc_level);\n}\n\n \nstatic void rt61pci_start_queue(struct data_queue *queue)\n{\n\tstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\n\tu32 reg;\n\n\tswitch (queue->qid) {\n\tcase QID_RX:\n\t\treg = rt2x00mmio_register_read(rt2x00dev, TXRX_CSR0);\n\t\trt2x00_set_field32(&reg, TXRX_CSR0_DISABLE_RX, 0);\n\t\trt2x00mmio_register_write(rt2x00dev, TXRX_CSR0, reg);\n\t\tbreak;\n\tcase QID_BEACON:\n\t\treg = rt2x00mmio_register_read(rt2x00dev, TXRX_CSR9);\n\t\trt2x00_set_field32(&reg, TXRX_CSR9_TSF_TICKING, 1);\n\t\trt2x00_set_field32(&reg, TXRX_CSR9_TBTT_ENABLE, 1);\n\t\trt2x00_set_field32(&reg, TXRX_CSR9_BEACON_GEN, 1);\n\t\trt2x00mmio_register_write(rt2x00dev, TXRX_CSR9, reg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void rt61pci_kick_queue(struct data_queue *queue)\n{\n\tstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\n\tu32 reg;\n\n\tswitch (queue->qid) {\n\tcase QID_AC_VO:\n\t\treg = rt2x00mmio_register_read(rt2x00dev, TX_CNTL_CSR);\n\t\trt2x00_set_field32(&reg, TX_CNTL_CSR_KICK_TX_AC0, 1);\n\t\trt2x00mmio_register_write(rt2x00dev, TX_CNTL_CSR, reg);\n\t\tbreak;\n\tcase QID_AC_VI:\n\t\treg = rt2x00mmio_register_read(rt2x00dev, TX_CNTL_CSR);\n\t\trt2x00_set_field32(&reg, TX_CNTL_CSR_KICK_TX_AC1, 1);\n\t\trt2x00mmio_register_write(rt2x00dev, TX_CNTL_CSR, reg);\n\t\tbreak;\n\tcase QID_AC_BE:\n\t\treg = rt2x00mmio_register_read(rt2x00dev, TX_CNTL_CSR);\n\t\trt2x00_set_field32(&reg, TX_CNTL_CSR_KICK_TX_AC2, 1);\n\t\trt2x00mmio_register_write(rt2x00dev, TX_CNTL_CSR, reg);\n\t\tbreak;\n\tcase QID_AC_BK:\n\t\treg = rt2x00mmio_register_read(rt2x00dev, TX_CNTL_CSR);\n\t\trt2x00_set_field32(&reg, TX_CNTL_CSR_KICK_TX_AC3, 1);\n\t\trt2x00mmio_register_write(rt2x00dev, TX_CNTL_CSR, reg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void rt61pci_stop_queue(struct data_queue *queue)\n{\n\tstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\n\tu32 reg;\n\n\tswitch (queue->qid) {\n\tcase QID_AC_VO:\n\t\treg = rt2x00mmio_register_read(rt2x00dev, TX_CNTL_CSR);\n\t\trt2x00_set_field32(&reg, TX_CNTL_CSR_ABORT_TX_AC0, 1);\n\t\trt2x00mmio_register_write(rt2x00dev, TX_CNTL_CSR, reg);\n\t\tbreak;\n\tcase QID_AC_VI:\n\t\treg = rt2x00mmio_register_read(rt2x00dev, TX_CNTL_CSR);\n\t\trt2x00_set_field32(&reg, TX_CNTL_CSR_ABORT_TX_AC1, 1);\n\t\trt2x00mmio_register_write(rt2x00dev, TX_CNTL_CSR, reg);\n\t\tbreak;\n\tcase QID_AC_BE:\n\t\treg = rt2x00mmio_register_read(rt2x00dev, TX_CNTL_CSR);\n\t\trt2x00_set_field32(&reg, TX_CNTL_CSR_ABORT_TX_AC2, 1);\n\t\trt2x00mmio_register_write(rt2x00dev, TX_CNTL_CSR, reg);\n\t\tbreak;\n\tcase QID_AC_BK:\n\t\treg = rt2x00mmio_register_read(rt2x00dev, TX_CNTL_CSR);\n\t\trt2x00_set_field32(&reg, TX_CNTL_CSR_ABORT_TX_AC3, 1);\n\t\trt2x00mmio_register_write(rt2x00dev, TX_CNTL_CSR, reg);\n\t\tbreak;\n\tcase QID_RX:\n\t\treg = rt2x00mmio_register_read(rt2x00dev, TXRX_CSR0);\n\t\trt2x00_set_field32(&reg, TXRX_CSR0_DISABLE_RX, 1);\n\t\trt2x00mmio_register_write(rt2x00dev, TXRX_CSR0, reg);\n\t\tbreak;\n\tcase QID_BEACON:\n\t\treg = rt2x00mmio_register_read(rt2x00dev, TXRX_CSR9);\n\t\trt2x00_set_field32(&reg, TXRX_CSR9_TSF_TICKING, 0);\n\t\trt2x00_set_field32(&reg, TXRX_CSR9_TBTT_ENABLE, 0);\n\t\trt2x00_set_field32(&reg, TXRX_CSR9_BEACON_GEN, 0);\n\t\trt2x00mmio_register_write(rt2x00dev, TXRX_CSR9, reg);\n\n\t\t \n\t\ttasklet_kill(&rt2x00dev->tbtt_tasklet);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic char *rt61pci_get_firmware_name(struct rt2x00_dev *rt2x00dev)\n{\n\tu16 chip;\n\tchar *fw_name;\n\n\tpci_read_config_word(to_pci_dev(rt2x00dev->dev), PCI_DEVICE_ID, &chip);\n\tswitch (chip) {\n\tcase RT2561_PCI_ID:\n\t\tfw_name = FIRMWARE_RT2561;\n\t\tbreak;\n\tcase RT2561s_PCI_ID:\n\t\tfw_name = FIRMWARE_RT2561s;\n\t\tbreak;\n\tcase RT2661_PCI_ID:\n\t\tfw_name = FIRMWARE_RT2661;\n\t\tbreak;\n\tdefault:\n\t\tfw_name = NULL;\n\t\tbreak;\n\t}\n\n\treturn fw_name;\n}\n\nstatic int rt61pci_check_firmware(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t  const u8 *data, const size_t len)\n{\n\tu16 fw_crc;\n\tu16 crc;\n\n\t \n\tif (len != 8192)\n\t\treturn FW_BAD_LENGTH;\n\n\t \n\tfw_crc = (data[len - 2] << 8 | data[len - 1]);\n\n\t \n\tcrc = crc_itu_t(0, data, len - 2);\n\tcrc = crc_itu_t_byte(crc, 0);\n\tcrc = crc_itu_t_byte(crc, 0);\n\n\treturn (fw_crc == crc) ? FW_OK : FW_BAD_CRC;\n}\n\nstatic int rt61pci_load_firmware(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t const u8 *data, const size_t len)\n{\n\tint i;\n\tu32 reg;\n\n\t \n\tfor (i = 0; i < 100; i++) {\n\t\treg = rt2x00mmio_register_read(rt2x00dev, MAC_CSR0);\n\t\tif (reg)\n\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n\n\tif (!reg) {\n\t\trt2x00_err(rt2x00dev, \"Unstable hardware\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\treg = 0;\n\trt2x00_set_field32(&reg, MCU_CNTL_CSR_RESET, 1);\n\trt2x00mmio_register_write(rt2x00dev, MCU_CNTL_CSR, reg);\n\trt2x00mmio_register_write(rt2x00dev, M2H_CMD_DONE_CSR, 0xffffffff);\n\trt2x00mmio_register_write(rt2x00dev, H2M_MAILBOX_CSR, 0);\n\trt2x00mmio_register_write(rt2x00dev, HOST_CMD_CSR, 0);\n\n\t \n\treg = 0;\n\trt2x00_set_field32(&reg, MCU_CNTL_CSR_RESET, 1);\n\trt2x00_set_field32(&reg, MCU_CNTL_CSR_SELECT_BANK, 1);\n\trt2x00mmio_register_write(rt2x00dev, MCU_CNTL_CSR, reg);\n\n\trt2x00mmio_register_multiwrite(rt2x00dev, FIRMWARE_IMAGE_BASE,\n\t\t\t\t       data, len);\n\n\trt2x00_set_field32(&reg, MCU_CNTL_CSR_SELECT_BANK, 0);\n\trt2x00mmio_register_write(rt2x00dev, MCU_CNTL_CSR, reg);\n\n\trt2x00_set_field32(&reg, MCU_CNTL_CSR_RESET, 0);\n\trt2x00mmio_register_write(rt2x00dev, MCU_CNTL_CSR, reg);\n\n\tfor (i = 0; i < 100; i++) {\n\t\treg = rt2x00mmio_register_read(rt2x00dev, MCU_CNTL_CSR);\n\t\tif (rt2x00_get_field32(reg, MCU_CNTL_CSR_READY))\n\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n\n\tif (i == 100) {\n\t\trt2x00_err(rt2x00dev, \"MCU Control register not ready\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tmsleep(1);\n\n\t \n\treg = 0;\n\trt2x00_set_field32(&reg, MAC_CSR1_SOFT_RESET, 1);\n\trt2x00_set_field32(&reg, MAC_CSR1_BBP_RESET, 1);\n\trt2x00mmio_register_write(rt2x00dev, MAC_CSR1, reg);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, MAC_CSR1);\n\trt2x00_set_field32(&reg, MAC_CSR1_SOFT_RESET, 0);\n\trt2x00_set_field32(&reg, MAC_CSR1_BBP_RESET, 0);\n\trt2x00mmio_register_write(rt2x00dev, MAC_CSR1, reg);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, MAC_CSR1);\n\trt2x00_set_field32(&reg, MAC_CSR1_HOST_READY, 1);\n\trt2x00mmio_register_write(rt2x00dev, MAC_CSR1, reg);\n\n\treturn 0;\n}\n\n \nstatic bool rt61pci_get_entry_state(struct queue_entry *entry)\n{\n\tstruct queue_entry_priv_mmio *entry_priv = entry->priv_data;\n\tu32 word;\n\n\tif (entry->queue->qid == QID_RX) {\n\t\tword = rt2x00_desc_read(entry_priv->desc, 0);\n\n\t\treturn rt2x00_get_field32(word, RXD_W0_OWNER_NIC);\n\t} else {\n\t\tword = rt2x00_desc_read(entry_priv->desc, 0);\n\n\t\treturn (rt2x00_get_field32(word, TXD_W0_OWNER_NIC) ||\n\t\t        rt2x00_get_field32(word, TXD_W0_VALID));\n\t}\n}\n\nstatic void rt61pci_clear_entry(struct queue_entry *entry)\n{\n\tstruct queue_entry_priv_mmio *entry_priv = entry->priv_data;\n\tstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\n\tu32 word;\n\n\tif (entry->queue->qid == QID_RX) {\n\t\tword = rt2x00_desc_read(entry_priv->desc, 5);\n\t\trt2x00_set_field32(&word, RXD_W5_BUFFER_PHYSICAL_ADDRESS,\n\t\t\t\t   skbdesc->skb_dma);\n\t\trt2x00_desc_write(entry_priv->desc, 5, word);\n\n\t\tword = rt2x00_desc_read(entry_priv->desc, 0);\n\t\trt2x00_set_field32(&word, RXD_W0_OWNER_NIC, 1);\n\t\trt2x00_desc_write(entry_priv->desc, 0, word);\n\t} else {\n\t\tword = rt2x00_desc_read(entry_priv->desc, 0);\n\t\trt2x00_set_field32(&word, TXD_W0_VALID, 0);\n\t\trt2x00_set_field32(&word, TXD_W0_OWNER_NIC, 0);\n\t\trt2x00_desc_write(entry_priv->desc, 0, word);\n\t}\n}\n\nstatic int rt61pci_init_queues(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct queue_entry_priv_mmio *entry_priv;\n\tu32 reg;\n\n\t \n\treg = rt2x00mmio_register_read(rt2x00dev, TX_RING_CSR0);\n\trt2x00_set_field32(&reg, TX_RING_CSR0_AC0_RING_SIZE,\n\t\t\t   rt2x00dev->tx[0].limit);\n\trt2x00_set_field32(&reg, TX_RING_CSR0_AC1_RING_SIZE,\n\t\t\t   rt2x00dev->tx[1].limit);\n\trt2x00_set_field32(&reg, TX_RING_CSR0_AC2_RING_SIZE,\n\t\t\t   rt2x00dev->tx[2].limit);\n\trt2x00_set_field32(&reg, TX_RING_CSR0_AC3_RING_SIZE,\n\t\t\t   rt2x00dev->tx[3].limit);\n\trt2x00mmio_register_write(rt2x00dev, TX_RING_CSR0, reg);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, TX_RING_CSR1);\n\trt2x00_set_field32(&reg, TX_RING_CSR1_TXD_SIZE,\n\t\t\t   rt2x00dev->tx[0].desc_size / 4);\n\trt2x00mmio_register_write(rt2x00dev, TX_RING_CSR1, reg);\n\n\tentry_priv = rt2x00dev->tx[0].entries[0].priv_data;\n\treg = rt2x00mmio_register_read(rt2x00dev, AC0_BASE_CSR);\n\trt2x00_set_field32(&reg, AC0_BASE_CSR_RING_REGISTER,\n\t\t\t   entry_priv->desc_dma);\n\trt2x00mmio_register_write(rt2x00dev, AC0_BASE_CSR, reg);\n\n\tentry_priv = rt2x00dev->tx[1].entries[0].priv_data;\n\treg = rt2x00mmio_register_read(rt2x00dev, AC1_BASE_CSR);\n\trt2x00_set_field32(&reg, AC1_BASE_CSR_RING_REGISTER,\n\t\t\t   entry_priv->desc_dma);\n\trt2x00mmio_register_write(rt2x00dev, AC1_BASE_CSR, reg);\n\n\tentry_priv = rt2x00dev->tx[2].entries[0].priv_data;\n\treg = rt2x00mmio_register_read(rt2x00dev, AC2_BASE_CSR);\n\trt2x00_set_field32(&reg, AC2_BASE_CSR_RING_REGISTER,\n\t\t\t   entry_priv->desc_dma);\n\trt2x00mmio_register_write(rt2x00dev, AC2_BASE_CSR, reg);\n\n\tentry_priv = rt2x00dev->tx[3].entries[0].priv_data;\n\treg = rt2x00mmio_register_read(rt2x00dev, AC3_BASE_CSR);\n\trt2x00_set_field32(&reg, AC3_BASE_CSR_RING_REGISTER,\n\t\t\t   entry_priv->desc_dma);\n\trt2x00mmio_register_write(rt2x00dev, AC3_BASE_CSR, reg);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, RX_RING_CSR);\n\trt2x00_set_field32(&reg, RX_RING_CSR_RING_SIZE, rt2x00dev->rx->limit);\n\trt2x00_set_field32(&reg, RX_RING_CSR_RXD_SIZE,\n\t\t\t   rt2x00dev->rx->desc_size / 4);\n\trt2x00_set_field32(&reg, RX_RING_CSR_RXD_WRITEBACK_SIZE, 4);\n\trt2x00mmio_register_write(rt2x00dev, RX_RING_CSR, reg);\n\n\tentry_priv = rt2x00dev->rx->entries[0].priv_data;\n\treg = rt2x00mmio_register_read(rt2x00dev, RX_BASE_CSR);\n\trt2x00_set_field32(&reg, RX_BASE_CSR_RING_REGISTER,\n\t\t\t   entry_priv->desc_dma);\n\trt2x00mmio_register_write(rt2x00dev, RX_BASE_CSR, reg);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, TX_DMA_DST_CSR);\n\trt2x00_set_field32(&reg, TX_DMA_DST_CSR_DEST_AC0, 2);\n\trt2x00_set_field32(&reg, TX_DMA_DST_CSR_DEST_AC1, 2);\n\trt2x00_set_field32(&reg, TX_DMA_DST_CSR_DEST_AC2, 2);\n\trt2x00_set_field32(&reg, TX_DMA_DST_CSR_DEST_AC3, 2);\n\trt2x00mmio_register_write(rt2x00dev, TX_DMA_DST_CSR, reg);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, LOAD_TX_RING_CSR);\n\trt2x00_set_field32(&reg, LOAD_TX_RING_CSR_LOAD_TXD_AC0, 1);\n\trt2x00_set_field32(&reg, LOAD_TX_RING_CSR_LOAD_TXD_AC1, 1);\n\trt2x00_set_field32(&reg, LOAD_TX_RING_CSR_LOAD_TXD_AC2, 1);\n\trt2x00_set_field32(&reg, LOAD_TX_RING_CSR_LOAD_TXD_AC3, 1);\n\trt2x00mmio_register_write(rt2x00dev, LOAD_TX_RING_CSR, reg);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, RX_CNTL_CSR);\n\trt2x00_set_field32(&reg, RX_CNTL_CSR_LOAD_RXD, 1);\n\trt2x00mmio_register_write(rt2x00dev, RX_CNTL_CSR, reg);\n\n\treturn 0;\n}\n\nstatic int rt61pci_init_registers(struct rt2x00_dev *rt2x00dev)\n{\n\tu32 reg;\n\n\treg = rt2x00mmio_register_read(rt2x00dev, TXRX_CSR0);\n\trt2x00_set_field32(&reg, TXRX_CSR0_AUTO_TX_SEQ, 1);\n\trt2x00_set_field32(&reg, TXRX_CSR0_DISABLE_RX, 0);\n\trt2x00_set_field32(&reg, TXRX_CSR0_TX_WITHOUT_WAITING, 0);\n\trt2x00mmio_register_write(rt2x00dev, TXRX_CSR0, reg);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, TXRX_CSR1);\n\trt2x00_set_field32(&reg, TXRX_CSR1_BBP_ID0, 47);  \n\trt2x00_set_field32(&reg, TXRX_CSR1_BBP_ID0_VALID, 1);\n\trt2x00_set_field32(&reg, TXRX_CSR1_BBP_ID1, 30);  \n\trt2x00_set_field32(&reg, TXRX_CSR1_BBP_ID1_VALID, 1);\n\trt2x00_set_field32(&reg, TXRX_CSR1_BBP_ID2, 42);  \n\trt2x00_set_field32(&reg, TXRX_CSR1_BBP_ID2_VALID, 1);\n\trt2x00_set_field32(&reg, TXRX_CSR1_BBP_ID3, 30);  \n\trt2x00_set_field32(&reg, TXRX_CSR1_BBP_ID3_VALID, 1);\n\trt2x00mmio_register_write(rt2x00dev, TXRX_CSR1, reg);\n\n\t \n\treg = rt2x00mmio_register_read(rt2x00dev, TXRX_CSR2);\n\trt2x00_set_field32(&reg, TXRX_CSR2_BBP_ID0, 13);\n\trt2x00_set_field32(&reg, TXRX_CSR2_BBP_ID0_VALID, 1);\n\trt2x00_set_field32(&reg, TXRX_CSR2_BBP_ID1, 12);\n\trt2x00_set_field32(&reg, TXRX_CSR2_BBP_ID1_VALID, 1);\n\trt2x00_set_field32(&reg, TXRX_CSR2_BBP_ID2, 11);\n\trt2x00_set_field32(&reg, TXRX_CSR2_BBP_ID2_VALID, 1);\n\trt2x00_set_field32(&reg, TXRX_CSR2_BBP_ID3, 10);\n\trt2x00_set_field32(&reg, TXRX_CSR2_BBP_ID3_VALID, 1);\n\trt2x00mmio_register_write(rt2x00dev, TXRX_CSR2, reg);\n\n\t \n\treg = rt2x00mmio_register_read(rt2x00dev, TXRX_CSR3);\n\trt2x00_set_field32(&reg, TXRX_CSR3_BBP_ID0, 7);\n\trt2x00_set_field32(&reg, TXRX_CSR3_BBP_ID0_VALID, 1);\n\trt2x00_set_field32(&reg, TXRX_CSR3_BBP_ID1, 6);\n\trt2x00_set_field32(&reg, TXRX_CSR3_BBP_ID1_VALID, 1);\n\trt2x00_set_field32(&reg, TXRX_CSR3_BBP_ID2, 5);\n\trt2x00_set_field32(&reg, TXRX_CSR3_BBP_ID2_VALID, 1);\n\trt2x00mmio_register_write(rt2x00dev, TXRX_CSR3, reg);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, TXRX_CSR7);\n\trt2x00_set_field32(&reg, TXRX_CSR7_ACK_CTS_6MBS, 59);\n\trt2x00_set_field32(&reg, TXRX_CSR7_ACK_CTS_9MBS, 53);\n\trt2x00_set_field32(&reg, TXRX_CSR7_ACK_CTS_12MBS, 49);\n\trt2x00_set_field32(&reg, TXRX_CSR7_ACK_CTS_18MBS, 46);\n\trt2x00mmio_register_write(rt2x00dev, TXRX_CSR7, reg);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, TXRX_CSR8);\n\trt2x00_set_field32(&reg, TXRX_CSR8_ACK_CTS_24MBS, 44);\n\trt2x00_set_field32(&reg, TXRX_CSR8_ACK_CTS_36MBS, 42);\n\trt2x00_set_field32(&reg, TXRX_CSR8_ACK_CTS_48MBS, 42);\n\trt2x00_set_field32(&reg, TXRX_CSR8_ACK_CTS_54MBS, 42);\n\trt2x00mmio_register_write(rt2x00dev, TXRX_CSR8, reg);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, TXRX_CSR9);\n\trt2x00_set_field32(&reg, TXRX_CSR9_BEACON_INTERVAL, 0);\n\trt2x00_set_field32(&reg, TXRX_CSR9_TSF_TICKING, 0);\n\trt2x00_set_field32(&reg, TXRX_CSR9_TSF_SYNC, 0);\n\trt2x00_set_field32(&reg, TXRX_CSR9_TBTT_ENABLE, 0);\n\trt2x00_set_field32(&reg, TXRX_CSR9_BEACON_GEN, 0);\n\trt2x00_set_field32(&reg, TXRX_CSR9_TIMESTAMP_COMPENSATE, 0);\n\trt2x00mmio_register_write(rt2x00dev, TXRX_CSR9, reg);\n\n\trt2x00mmio_register_write(rt2x00dev, TXRX_CSR15, 0x0000000f);\n\n\trt2x00mmio_register_write(rt2x00dev, MAC_CSR6, 0x00000fff);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, MAC_CSR9);\n\trt2x00_set_field32(&reg, MAC_CSR9_CW_SELECT, 0);\n\trt2x00mmio_register_write(rt2x00dev, MAC_CSR9, reg);\n\n\trt2x00mmio_register_write(rt2x00dev, MAC_CSR10, 0x0000071c);\n\n\tif (rt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_AWAKE))\n\t\treturn -EBUSY;\n\n\trt2x00mmio_register_write(rt2x00dev, MAC_CSR13, 0x0000e000);\n\n\t \n\trt2x00mmio_register_write(rt2x00dev, SEC_CSR0, 0x00000000);\n\trt2x00mmio_register_write(rt2x00dev, SEC_CSR1, 0x00000000);\n\trt2x00mmio_register_write(rt2x00dev, SEC_CSR5, 0x00000000);\n\n\trt2x00mmio_register_write(rt2x00dev, PHY_CSR1, 0x000023b0);\n\trt2x00mmio_register_write(rt2x00dev, PHY_CSR5, 0x060a100c);\n\trt2x00mmio_register_write(rt2x00dev, PHY_CSR6, 0x00080606);\n\trt2x00mmio_register_write(rt2x00dev, PHY_CSR7, 0x00000a08);\n\n\trt2x00mmio_register_write(rt2x00dev, PCI_CFG_CSR, 0x28ca4404);\n\n\trt2x00mmio_register_write(rt2x00dev, TEST_MODE_CSR, 0x00000200);\n\n\trt2x00mmio_register_write(rt2x00dev, M2H_CMD_DONE_CSR, 0xffffffff);\n\n\t \n\trt2x00mmio_register_write(rt2x00dev, HW_BEACON_BASE0, 0);\n\trt2x00mmio_register_write(rt2x00dev, HW_BEACON_BASE1, 0);\n\trt2x00mmio_register_write(rt2x00dev, HW_BEACON_BASE2, 0);\n\trt2x00mmio_register_write(rt2x00dev, HW_BEACON_BASE3, 0);\n\n\t \n\treg = rt2x00mmio_register_read(rt2x00dev, STA_CSR0);\n\treg = rt2x00mmio_register_read(rt2x00dev, STA_CSR1);\n\treg = rt2x00mmio_register_read(rt2x00dev, STA_CSR2);\n\n\t \n\treg = rt2x00mmio_register_read(rt2x00dev, MAC_CSR1);\n\trt2x00_set_field32(&reg, MAC_CSR1_SOFT_RESET, 1);\n\trt2x00_set_field32(&reg, MAC_CSR1_BBP_RESET, 1);\n\trt2x00mmio_register_write(rt2x00dev, MAC_CSR1, reg);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, MAC_CSR1);\n\trt2x00_set_field32(&reg, MAC_CSR1_SOFT_RESET, 0);\n\trt2x00_set_field32(&reg, MAC_CSR1_BBP_RESET, 0);\n\trt2x00mmio_register_write(rt2x00dev, MAC_CSR1, reg);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, MAC_CSR1);\n\trt2x00_set_field32(&reg, MAC_CSR1_HOST_READY, 1);\n\trt2x00mmio_register_write(rt2x00dev, MAC_CSR1, reg);\n\n\treturn 0;\n}\n\nstatic int rt61pci_wait_bbp_ready(struct rt2x00_dev *rt2x00dev)\n{\n\tunsigned int i;\n\tu8 value;\n\n\tfor (i = 0; i < REGISTER_BUSY_COUNT; i++) {\n\t\tvalue = rt61pci_bbp_read(rt2x00dev, 0);\n\t\tif ((value != 0xff) && (value != 0x00))\n\t\t\treturn 0;\n\t\tudelay(REGISTER_BUSY_DELAY);\n\t}\n\n\trt2x00_err(rt2x00dev, \"BBP register access failed, aborting\\n\");\n\treturn -EACCES;\n}\n\nstatic int rt61pci_init_bbp(struct rt2x00_dev *rt2x00dev)\n{\n\tunsigned int i;\n\tu16 eeprom;\n\tu8 reg_id;\n\tu8 value;\n\n\tif (unlikely(rt61pci_wait_bbp_ready(rt2x00dev)))\n\t\treturn -EACCES;\n\n\trt61pci_bbp_write(rt2x00dev, 3, 0x00);\n\trt61pci_bbp_write(rt2x00dev, 15, 0x30);\n\trt61pci_bbp_write(rt2x00dev, 21, 0xc8);\n\trt61pci_bbp_write(rt2x00dev, 22, 0x38);\n\trt61pci_bbp_write(rt2x00dev, 23, 0x06);\n\trt61pci_bbp_write(rt2x00dev, 24, 0xfe);\n\trt61pci_bbp_write(rt2x00dev, 25, 0x0a);\n\trt61pci_bbp_write(rt2x00dev, 26, 0x0d);\n\trt61pci_bbp_write(rt2x00dev, 34, 0x12);\n\trt61pci_bbp_write(rt2x00dev, 37, 0x07);\n\trt61pci_bbp_write(rt2x00dev, 39, 0xf8);\n\trt61pci_bbp_write(rt2x00dev, 41, 0x60);\n\trt61pci_bbp_write(rt2x00dev, 53, 0x10);\n\trt61pci_bbp_write(rt2x00dev, 54, 0x18);\n\trt61pci_bbp_write(rt2x00dev, 60, 0x10);\n\trt61pci_bbp_write(rt2x00dev, 61, 0x04);\n\trt61pci_bbp_write(rt2x00dev, 62, 0x04);\n\trt61pci_bbp_write(rt2x00dev, 75, 0xfe);\n\trt61pci_bbp_write(rt2x00dev, 86, 0xfe);\n\trt61pci_bbp_write(rt2x00dev, 88, 0xfe);\n\trt61pci_bbp_write(rt2x00dev, 90, 0x0f);\n\trt61pci_bbp_write(rt2x00dev, 99, 0x00);\n\trt61pci_bbp_write(rt2x00dev, 102, 0x16);\n\trt61pci_bbp_write(rt2x00dev, 107, 0x04);\n\n\tfor (i = 0; i < EEPROM_BBP_SIZE; i++) {\n\t\teeprom = rt2x00_eeprom_read(rt2x00dev, EEPROM_BBP_START + i);\n\n\t\tif (eeprom != 0xffff && eeprom != 0x0000) {\n\t\t\treg_id = rt2x00_get_field16(eeprom, EEPROM_BBP_REG_ID);\n\t\t\tvalue = rt2x00_get_field16(eeprom, EEPROM_BBP_VALUE);\n\t\t\trt61pci_bbp_write(rt2x00dev, reg_id, value);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void rt61pci_toggle_irq(struct rt2x00_dev *rt2x00dev,\n\t\t\t       enum dev_state state)\n{\n\tint mask = (state == STATE_RADIO_IRQ_OFF);\n\tu32 reg;\n\tunsigned long flags;\n\n\t \n\tif (state == STATE_RADIO_IRQ_ON) {\n\t\treg = rt2x00mmio_register_read(rt2x00dev, INT_SOURCE_CSR);\n\t\trt2x00mmio_register_write(rt2x00dev, INT_SOURCE_CSR, reg);\n\n\t\treg = rt2x00mmio_register_read(rt2x00dev, MCU_INT_SOURCE_CSR);\n\t\trt2x00mmio_register_write(rt2x00dev, MCU_INT_SOURCE_CSR, reg);\n\t}\n\n\t \n\tspin_lock_irqsave(&rt2x00dev->irqmask_lock, flags);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, INT_MASK_CSR);\n\trt2x00_set_field32(&reg, INT_MASK_CSR_TXDONE, mask);\n\trt2x00_set_field32(&reg, INT_MASK_CSR_RXDONE, mask);\n\trt2x00_set_field32(&reg, INT_MASK_CSR_BEACON_DONE, mask);\n\trt2x00_set_field32(&reg, INT_MASK_CSR_ENABLE_MITIGATION, mask);\n\trt2x00_set_field32(&reg, INT_MASK_CSR_MITIGATION_PERIOD, 0xff);\n\trt2x00mmio_register_write(rt2x00dev, INT_MASK_CSR, reg);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, MCU_INT_MASK_CSR);\n\trt2x00_set_field32(&reg, MCU_INT_MASK_CSR_0, mask);\n\trt2x00_set_field32(&reg, MCU_INT_MASK_CSR_1, mask);\n\trt2x00_set_field32(&reg, MCU_INT_MASK_CSR_2, mask);\n\trt2x00_set_field32(&reg, MCU_INT_MASK_CSR_3, mask);\n\trt2x00_set_field32(&reg, MCU_INT_MASK_CSR_4, mask);\n\trt2x00_set_field32(&reg, MCU_INT_MASK_CSR_5, mask);\n\trt2x00_set_field32(&reg, MCU_INT_MASK_CSR_6, mask);\n\trt2x00_set_field32(&reg, MCU_INT_MASK_CSR_7, mask);\n\trt2x00_set_field32(&reg, MCU_INT_MASK_CSR_TWAKEUP, mask);\n\trt2x00mmio_register_write(rt2x00dev, MCU_INT_MASK_CSR, reg);\n\n\tspin_unlock_irqrestore(&rt2x00dev->irqmask_lock, flags);\n\n\tif (state == STATE_RADIO_IRQ_OFF) {\n\t\t \n\t\ttasklet_kill(&rt2x00dev->txstatus_tasklet);\n\t\ttasklet_kill(&rt2x00dev->rxdone_tasklet);\n\t\ttasklet_kill(&rt2x00dev->autowake_tasklet);\n\t\ttasklet_kill(&rt2x00dev->tbtt_tasklet);\n\t}\n}\n\nstatic int rt61pci_enable_radio(struct rt2x00_dev *rt2x00dev)\n{\n\tu32 reg;\n\n\t \n\tif (unlikely(rt61pci_init_queues(rt2x00dev) ||\n\t\t     rt61pci_init_registers(rt2x00dev) ||\n\t\t     rt61pci_init_bbp(rt2x00dev)))\n\t\treturn -EIO;\n\n\t \n\treg = rt2x00mmio_register_read(rt2x00dev, RX_CNTL_CSR);\n\trt2x00_set_field32(&reg, RX_CNTL_CSR_ENABLE_RX_DMA, 1);\n\trt2x00mmio_register_write(rt2x00dev, RX_CNTL_CSR, reg);\n\n\treturn 0;\n}\n\nstatic void rt61pci_disable_radio(struct rt2x00_dev *rt2x00dev)\n{\n\t \n\trt2x00mmio_register_write(rt2x00dev, MAC_CSR10, 0x00001818);\n}\n\nstatic int rt61pci_set_state(struct rt2x00_dev *rt2x00dev, enum dev_state state)\n{\n\tu32 reg, reg2;\n\tunsigned int i;\n\tbool put_to_sleep;\n\n\tput_to_sleep = (state != STATE_AWAKE);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, MAC_CSR12);\n\trt2x00_set_field32(&reg, MAC_CSR12_FORCE_WAKEUP, !put_to_sleep);\n\trt2x00_set_field32(&reg, MAC_CSR12_PUT_TO_SLEEP, put_to_sleep);\n\trt2x00mmio_register_write(rt2x00dev, MAC_CSR12, reg);\n\n\t \n\tfor (i = 0; i < REGISTER_BUSY_COUNT; i++) {\n\t\treg2 = rt2x00mmio_register_read(rt2x00dev, MAC_CSR12);\n\t\tstate = rt2x00_get_field32(reg2, MAC_CSR12_BBP_CURRENT_STATE);\n\t\tif (state == !put_to_sleep)\n\t\t\treturn 0;\n\t\trt2x00mmio_register_write(rt2x00dev, MAC_CSR12, reg);\n\t\tmsleep(10);\n\t}\n\n\treturn -EBUSY;\n}\n\nstatic int rt61pci_set_device_state(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t    enum dev_state state)\n{\n\tint retval = 0;\n\n\tswitch (state) {\n\tcase STATE_RADIO_ON:\n\t\tretval = rt61pci_enable_radio(rt2x00dev);\n\t\tbreak;\n\tcase STATE_RADIO_OFF:\n\t\trt61pci_disable_radio(rt2x00dev);\n\t\tbreak;\n\tcase STATE_RADIO_IRQ_ON:\n\tcase STATE_RADIO_IRQ_OFF:\n\t\trt61pci_toggle_irq(rt2x00dev, state);\n\t\tbreak;\n\tcase STATE_DEEP_SLEEP:\n\tcase STATE_SLEEP:\n\tcase STATE_STANDBY:\n\tcase STATE_AWAKE:\n\t\tretval = rt61pci_set_state(rt2x00dev, state);\n\t\tbreak;\n\tdefault:\n\t\tretval = -ENOTSUPP;\n\t\tbreak;\n\t}\n\n\tif (unlikely(retval))\n\t\trt2x00_err(rt2x00dev, \"Device failed to enter state %d (%d)\\n\",\n\t\t\t   state, retval);\n\n\treturn retval;\n}\n\n \nstatic void rt61pci_write_tx_desc(struct queue_entry *entry,\n\t\t\t\t  struct txentry_desc *txdesc)\n{\n\tstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\n\tstruct queue_entry_priv_mmio *entry_priv = entry->priv_data;\n\t__le32 *txd = entry_priv->desc;\n\tu32 word;\n\n\t \n\tword = rt2x00_desc_read(txd, 1);\n\trt2x00_set_field32(&word, TXD_W1_HOST_Q_ID, entry->queue->qid);\n\trt2x00_set_field32(&word, TXD_W1_AIFSN, entry->queue->aifs);\n\trt2x00_set_field32(&word, TXD_W1_CWMIN, entry->queue->cw_min);\n\trt2x00_set_field32(&word, TXD_W1_CWMAX, entry->queue->cw_max);\n\trt2x00_set_field32(&word, TXD_W1_IV_OFFSET, txdesc->iv_offset);\n\trt2x00_set_field32(&word, TXD_W1_HW_SEQUENCE,\n\t\t\t   test_bit(ENTRY_TXD_GENERATE_SEQ, &txdesc->flags));\n\trt2x00_set_field32(&word, TXD_W1_BUFFER_COUNT, 1);\n\trt2x00_desc_write(txd, 1, word);\n\n\tword = rt2x00_desc_read(txd, 2);\n\trt2x00_set_field32(&word, TXD_W2_PLCP_SIGNAL, txdesc->u.plcp.signal);\n\trt2x00_set_field32(&word, TXD_W2_PLCP_SERVICE, txdesc->u.plcp.service);\n\trt2x00_set_field32(&word, TXD_W2_PLCP_LENGTH_LOW,\n\t\t\t   txdesc->u.plcp.length_low);\n\trt2x00_set_field32(&word, TXD_W2_PLCP_LENGTH_HIGH,\n\t\t\t   txdesc->u.plcp.length_high);\n\trt2x00_desc_write(txd, 2, word);\n\n\tif (test_bit(ENTRY_TXD_ENCRYPT, &txdesc->flags)) {\n\t\t_rt2x00_desc_write(txd, 3, skbdesc->iv[0]);\n\t\t_rt2x00_desc_write(txd, 4, skbdesc->iv[1]);\n\t}\n\n\tword = rt2x00_desc_read(txd, 5);\n\trt2x00_set_field32(&word, TXD_W5_PID_TYPE, entry->queue->qid);\n\trt2x00_set_field32(&word, TXD_W5_PID_SUBTYPE, entry->entry_idx);\n\trt2x00_set_field32(&word, TXD_W5_TX_POWER,\n\t\t\t   TXPOWER_TO_DEV(entry->queue->rt2x00dev->tx_power));\n\trt2x00_set_field32(&word, TXD_W5_WAITING_DMA_DONE_INT, 1);\n\trt2x00_desc_write(txd, 5, word);\n\n\tif (entry->queue->qid != QID_BEACON) {\n\t\tword = rt2x00_desc_read(txd, 6);\n\t\trt2x00_set_field32(&word, TXD_W6_BUFFER_PHYSICAL_ADDRESS,\n\t\t\t\t   skbdesc->skb_dma);\n\t\trt2x00_desc_write(txd, 6, word);\n\n\t\tword = rt2x00_desc_read(txd, 11);\n\t\trt2x00_set_field32(&word, TXD_W11_BUFFER_LENGTH0,\n\t\t\t\t   txdesc->length);\n\t\trt2x00_desc_write(txd, 11, word);\n\t}\n\n\t \n\tword = rt2x00_desc_read(txd, 0);\n\trt2x00_set_field32(&word, TXD_W0_OWNER_NIC, 1);\n\trt2x00_set_field32(&word, TXD_W0_VALID, 1);\n\trt2x00_set_field32(&word, TXD_W0_MORE_FRAG,\n\t\t\t   test_bit(ENTRY_TXD_MORE_FRAG, &txdesc->flags));\n\trt2x00_set_field32(&word, TXD_W0_ACK,\n\t\t\t   test_bit(ENTRY_TXD_ACK, &txdesc->flags));\n\trt2x00_set_field32(&word, TXD_W0_TIMESTAMP,\n\t\t\t   test_bit(ENTRY_TXD_REQ_TIMESTAMP, &txdesc->flags));\n\trt2x00_set_field32(&word, TXD_W0_OFDM,\n\t\t\t   (txdesc->rate_mode == RATE_MODE_OFDM));\n\trt2x00_set_field32(&word, TXD_W0_IFS, txdesc->u.plcp.ifs);\n\trt2x00_set_field32(&word, TXD_W0_RETRY_MODE,\n\t\t\t   test_bit(ENTRY_TXD_RETRY_MODE, &txdesc->flags));\n\trt2x00_set_field32(&word, TXD_W0_TKIP_MIC,\n\t\t\t   test_bit(ENTRY_TXD_ENCRYPT_MMIC, &txdesc->flags));\n\trt2x00_set_field32(&word, TXD_W0_KEY_TABLE,\n\t\t\t   test_bit(ENTRY_TXD_ENCRYPT_PAIRWISE, &txdesc->flags));\n\trt2x00_set_field32(&word, TXD_W0_KEY_INDEX, txdesc->key_idx);\n\trt2x00_set_field32(&word, TXD_W0_DATABYTE_COUNT, txdesc->length);\n\trt2x00_set_field32(&word, TXD_W0_BURST,\n\t\t\t   test_bit(ENTRY_TXD_BURST, &txdesc->flags));\n\trt2x00_set_field32(&word, TXD_W0_CIPHER_ALG, txdesc->cipher);\n\trt2x00_desc_write(txd, 0, word);\n\n\t \n\tskbdesc->desc = txd;\n\tskbdesc->desc_len = (entry->queue->qid == QID_BEACON) ? TXINFO_SIZE :\n\t\t\t    TXD_DESC_SIZE;\n}\n\n \nstatic void rt61pci_write_beacon(struct queue_entry *entry,\n\t\t\t\t struct txentry_desc *txdesc)\n{\n\tstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\n\tstruct queue_entry_priv_mmio *entry_priv = entry->priv_data;\n\tunsigned int beacon_base;\n\tunsigned int padding_len;\n\tu32 orig_reg, reg;\n\n\t \n\treg = rt2x00mmio_register_read(rt2x00dev, TXRX_CSR9);\n\torig_reg = reg;\n\trt2x00_set_field32(&reg, TXRX_CSR9_BEACON_GEN, 0);\n\trt2x00mmio_register_write(rt2x00dev, TXRX_CSR9, reg);\n\n\t \n\trt61pci_write_tx_desc(entry, txdesc);\n\n\t \n\trt2x00debug_dump_frame(rt2x00dev, DUMP_FRAME_BEACON, entry);\n\n\t \n\tpadding_len = roundup(entry->skb->len, 4) - entry->skb->len;\n\tif (padding_len && skb_pad(entry->skb, padding_len)) {\n\t\trt2x00_err(rt2x00dev, \"Failure padding beacon, aborting\\n\");\n\t\t \n\t\tentry->skb = NULL;\n\t\trt2x00mmio_register_write(rt2x00dev, TXRX_CSR9, orig_reg);\n\t\treturn;\n\t}\n\n\tbeacon_base = HW_BEACON_OFFSET(entry->entry_idx);\n\trt2x00mmio_register_multiwrite(rt2x00dev, beacon_base,\n\t\t\t\t       entry_priv->desc, TXINFO_SIZE);\n\trt2x00mmio_register_multiwrite(rt2x00dev, beacon_base + TXINFO_SIZE,\n\t\t\t\t       entry->skb->data,\n\t\t\t\t       entry->skb->len + padding_len);\n\n\t \n\trt2x00mmio_register_write(rt2x00dev, TXRX_CSR10, 0x00001008);\n\n\trt2x00_set_field32(&reg, TXRX_CSR9_BEACON_GEN, 1);\n\trt2x00mmio_register_write(rt2x00dev, TXRX_CSR9, reg);\n\n\t \n\tdev_kfree_skb_any(entry->skb);\n\tentry->skb = NULL;\n}\n\nstatic void rt61pci_clear_beacon(struct queue_entry *entry)\n{\n\tstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\n\tu32 orig_reg, reg;\n\n\t \n\torig_reg = rt2x00mmio_register_read(rt2x00dev, TXRX_CSR9);\n\treg = orig_reg;\n\trt2x00_set_field32(&reg, TXRX_CSR9_BEACON_GEN, 0);\n\trt2x00mmio_register_write(rt2x00dev, TXRX_CSR9, reg);\n\n\t \n\trt2x00mmio_register_write(rt2x00dev,\n\t\t\t\t  HW_BEACON_OFFSET(entry->entry_idx), 0);\n\n\t \n\trt2x00mmio_register_write(rt2x00dev, TXRX_CSR9, orig_reg);\n}\n\n \nstatic int rt61pci_agc_to_rssi(struct rt2x00_dev *rt2x00dev, int rxd_w1)\n{\n\tu8 offset = rt2x00dev->lna_gain;\n\tu8 lna;\n\n\tlna = rt2x00_get_field32(rxd_w1, RXD_W1_RSSI_LNA);\n\tswitch (lna) {\n\tcase 3:\n\t\toffset += 90;\n\t\tbreak;\n\tcase 2:\n\t\toffset += 74;\n\t\tbreak;\n\tcase 1:\n\t\toffset += 64;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (rt2x00dev->curr_band == NL80211_BAND_5GHZ) {\n\t\tif (lna == 3 || lna == 2)\n\t\t\toffset += 10;\n\t}\n\n\treturn rt2x00_get_field32(rxd_w1, RXD_W1_RSSI_AGC) * 2 - offset;\n}\n\nstatic void rt61pci_fill_rxdone(struct queue_entry *entry,\n\t\t\t\tstruct rxdone_entry_desc *rxdesc)\n{\n\tstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\n\tstruct queue_entry_priv_mmio *entry_priv = entry->priv_data;\n\tu32 word0;\n\tu32 word1;\n\n\tword0 = rt2x00_desc_read(entry_priv->desc, 0);\n\tword1 = rt2x00_desc_read(entry_priv->desc, 1);\n\n\tif (rt2x00_get_field32(word0, RXD_W0_CRC_ERROR))\n\t\trxdesc->flags |= RX_FLAG_FAILED_FCS_CRC;\n\n\trxdesc->cipher = rt2x00_get_field32(word0, RXD_W0_CIPHER_ALG);\n\trxdesc->cipher_status = rt2x00_get_field32(word0, RXD_W0_CIPHER_ERROR);\n\n\tif (rxdesc->cipher != CIPHER_NONE) {\n\t\trxdesc->iv[0] = _rt2x00_desc_read(entry_priv->desc, 2);\n\t\trxdesc->iv[1] = _rt2x00_desc_read(entry_priv->desc, 3);\n\t\trxdesc->dev_flags |= RXDONE_CRYPTO_IV;\n\n\t\trxdesc->icv = _rt2x00_desc_read(entry_priv->desc, 4);\n\t\trxdesc->dev_flags |= RXDONE_CRYPTO_ICV;\n\n\t\t \n\t\trxdesc->flags |= RX_FLAG_IV_STRIPPED;\n\n\t\t \n\t\trxdesc->flags |= RX_FLAG_MMIC_STRIPPED;\n\n\t\tif (rxdesc->cipher_status == RX_CRYPTO_SUCCESS)\n\t\t\trxdesc->flags |= RX_FLAG_DECRYPTED;\n\t\telse if (rxdesc->cipher_status == RX_CRYPTO_FAIL_MIC)\n\t\t\trxdesc->flags |= RX_FLAG_MMIC_ERROR;\n\t}\n\n\t \n\trxdesc->signal = rt2x00_get_field32(word1, RXD_W1_SIGNAL);\n\trxdesc->rssi = rt61pci_agc_to_rssi(rt2x00dev, word1);\n\trxdesc->size = rt2x00_get_field32(word0, RXD_W0_DATABYTE_COUNT);\n\n\tif (rt2x00_get_field32(word0, RXD_W0_OFDM))\n\t\trxdesc->dev_flags |= RXDONE_SIGNAL_PLCP;\n\telse\n\t\trxdesc->dev_flags |= RXDONE_SIGNAL_BITRATE;\n\tif (rt2x00_get_field32(word0, RXD_W0_MY_BSS))\n\t\trxdesc->dev_flags |= RXDONE_MY_BSS;\n}\n\n \nstatic void rt61pci_txdone(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct data_queue *queue;\n\tstruct queue_entry *entry;\n\tstruct queue_entry *entry_done;\n\tstruct queue_entry_priv_mmio *entry_priv;\n\tstruct txdone_entry_desc txdesc;\n\tu32 word;\n\tu32 reg;\n\tint type;\n\tint index;\n\tint i;\n\n\t \n\tfor (i = 0; i < rt2x00dev->tx->limit; i++) {\n\t\treg = rt2x00mmio_register_read(rt2x00dev, STA_CSR4);\n\t\tif (!rt2x00_get_field32(reg, STA_CSR4_VALID))\n\t\t\tbreak;\n\n\t\t \n\t\ttype = rt2x00_get_field32(reg, STA_CSR4_PID_TYPE);\n\t\tqueue = rt2x00queue_get_tx_queue(rt2x00dev, type);\n\t\tif (unlikely(!queue))\n\t\t\tcontinue;\n\n\t\t \n\t\tindex = rt2x00_get_field32(reg, STA_CSR4_PID_SUBTYPE);\n\t\tif (unlikely(index >= queue->limit))\n\t\t\tcontinue;\n\n\t\tentry = &queue->entries[index];\n\t\tentry_priv = entry->priv_data;\n\t\tword = rt2x00_desc_read(entry_priv->desc, 0);\n\n\t\tif (rt2x00_get_field32(word, TXD_W0_OWNER_NIC) ||\n\t\t    !rt2x00_get_field32(word, TXD_W0_VALID))\n\t\t\treturn;\n\n\t\tentry_done = rt2x00queue_get_entry(queue, Q_INDEX_DONE);\n\t\twhile (entry != entry_done) {\n\t\t\t \n\t\t\trt2x00_warn(rt2x00dev, \"TX status report missed for entry %d\\n\",\n\t\t\t\t    entry_done->entry_idx);\n\n\t\t\trt2x00lib_txdone_noinfo(entry_done, TXDONE_UNKNOWN);\n\t\t\tentry_done = rt2x00queue_get_entry(queue, Q_INDEX_DONE);\n\t\t}\n\n\t\t \n\t\ttxdesc.flags = 0;\n\t\tswitch (rt2x00_get_field32(reg, STA_CSR4_TX_RESULT)) {\n\t\tcase 0:  \n\t\t\t__set_bit(TXDONE_SUCCESS, &txdesc.flags);\n\t\t\tbreak;\n\t\tcase 6:  \n\t\t\t__set_bit(TXDONE_EXCESSIVE_RETRY, &txdesc.flags);\n\t\t\tfallthrough;\t \n\t\tdefault:  \n\t\t\t__set_bit(TXDONE_FAILURE, &txdesc.flags);\n\t\t}\n\t\ttxdesc.retry = rt2x00_get_field32(reg, STA_CSR4_RETRY_COUNT);\n\n\t\t \n\t\tif (txdesc.retry)\n\t\t\t__set_bit(TXDONE_FALLBACK, &txdesc.flags);\n\n\t\trt2x00lib_txdone(entry, &txdesc);\n\t}\n}\n\nstatic void rt61pci_wakeup(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct rt2x00lib_conf libconf = { .conf = &rt2x00dev->hw->conf };\n\n\trt61pci_config(rt2x00dev, &libconf, IEEE80211_CONF_CHANGE_PS);\n}\n\nstatic inline void rt61pci_enable_interrupt(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t    struct rt2x00_field32 irq_field)\n{\n\tu32 reg;\n\n\t \n\tspin_lock_irq(&rt2x00dev->irqmask_lock);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, INT_MASK_CSR);\n\trt2x00_set_field32(&reg, irq_field, 0);\n\trt2x00mmio_register_write(rt2x00dev, INT_MASK_CSR, reg);\n\n\tspin_unlock_irq(&rt2x00dev->irqmask_lock);\n}\n\nstatic void rt61pci_enable_mcu_interrupt(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t struct rt2x00_field32 irq_field)\n{\n\tu32 reg;\n\n\t \n\tspin_lock_irq(&rt2x00dev->irqmask_lock);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, MCU_INT_MASK_CSR);\n\trt2x00_set_field32(&reg, irq_field, 0);\n\trt2x00mmio_register_write(rt2x00dev, MCU_INT_MASK_CSR, reg);\n\n\tspin_unlock_irq(&rt2x00dev->irqmask_lock);\n}\n\nstatic void rt61pci_txstatus_tasklet(struct tasklet_struct *t)\n{\n\tstruct rt2x00_dev *rt2x00dev = from_tasklet(rt2x00dev, t,\n\t\t\t\t\t\t    txstatus_tasklet);\n\n\trt61pci_txdone(rt2x00dev);\n\tif (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\trt61pci_enable_interrupt(rt2x00dev, INT_MASK_CSR_TXDONE);\n}\n\nstatic void rt61pci_tbtt_tasklet(struct tasklet_struct *t)\n{\n\tstruct rt2x00_dev *rt2x00dev = from_tasklet(rt2x00dev, t, tbtt_tasklet);\n\trt2x00lib_beacondone(rt2x00dev);\n\tif (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\trt61pci_enable_interrupt(rt2x00dev, INT_MASK_CSR_BEACON_DONE);\n}\n\nstatic void rt61pci_rxdone_tasklet(struct tasklet_struct *t)\n{\n\tstruct rt2x00_dev *rt2x00dev = from_tasklet(rt2x00dev, t,\n\t\t\t\t\t\t    rxdone_tasklet);\n\tif (rt2x00mmio_rxdone(rt2x00dev))\n\t\ttasklet_schedule(&rt2x00dev->rxdone_tasklet);\n\telse if (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\trt61pci_enable_interrupt(rt2x00dev, INT_MASK_CSR_RXDONE);\n}\n\nstatic void rt61pci_autowake_tasklet(struct tasklet_struct *t)\n{\n\tstruct rt2x00_dev *rt2x00dev = from_tasklet(rt2x00dev, t,\n\t\t\t\t\t\t    autowake_tasklet);\n\trt61pci_wakeup(rt2x00dev);\n\trt2x00mmio_register_write(rt2x00dev,\n\t\t\t\t  M2H_CMD_DONE_CSR, 0xffffffff);\n\tif (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\trt61pci_enable_mcu_interrupt(rt2x00dev, MCU_INT_MASK_CSR_TWAKEUP);\n}\n\nstatic irqreturn_t rt61pci_interrupt(int irq, void *dev_instance)\n{\n\tstruct rt2x00_dev *rt2x00dev = dev_instance;\n\tu32 reg_mcu, mask_mcu;\n\tu32 reg, mask;\n\n\t \n\treg_mcu = rt2x00mmio_register_read(rt2x00dev, MCU_INT_SOURCE_CSR);\n\trt2x00mmio_register_write(rt2x00dev, MCU_INT_SOURCE_CSR, reg_mcu);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, INT_SOURCE_CSR);\n\trt2x00mmio_register_write(rt2x00dev, INT_SOURCE_CSR, reg);\n\n\tif (!reg && !reg_mcu)\n\t\treturn IRQ_NONE;\n\n\tif (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\treturn IRQ_HANDLED;\n\n\t \n\tif (rt2x00_get_field32(reg, INT_SOURCE_CSR_RXDONE))\n\t\ttasklet_schedule(&rt2x00dev->rxdone_tasklet);\n\n\tif (rt2x00_get_field32(reg, INT_SOURCE_CSR_TXDONE))\n\t\ttasklet_schedule(&rt2x00dev->txstatus_tasklet);\n\n\tif (rt2x00_get_field32(reg, INT_SOURCE_CSR_BEACON_DONE))\n\t\ttasklet_hi_schedule(&rt2x00dev->tbtt_tasklet);\n\n\tif (rt2x00_get_field32(reg_mcu, MCU_INT_SOURCE_CSR_TWAKEUP))\n\t\ttasklet_schedule(&rt2x00dev->autowake_tasklet);\n\n\t \n\tmask = reg;\n\tmask_mcu = reg_mcu;\n\n\t \n\tspin_lock(&rt2x00dev->irqmask_lock);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, INT_MASK_CSR);\n\treg |= mask;\n\trt2x00mmio_register_write(rt2x00dev, INT_MASK_CSR, reg);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, MCU_INT_MASK_CSR);\n\treg |= mask_mcu;\n\trt2x00mmio_register_write(rt2x00dev, MCU_INT_MASK_CSR, reg);\n\n\tspin_unlock(&rt2x00dev->irqmask_lock);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int rt61pci_validate_eeprom(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct eeprom_93cx6 eeprom;\n\tu32 reg;\n\tu16 word;\n\tu8 *mac;\n\ts8 value;\n\n\treg = rt2x00mmio_register_read(rt2x00dev, E2PROM_CSR);\n\n\teeprom.data = rt2x00dev;\n\teeprom.register_read = rt61pci_eepromregister_read;\n\teeprom.register_write = rt61pci_eepromregister_write;\n\teeprom.width = rt2x00_get_field32(reg, E2PROM_CSR_TYPE_93C46) ?\n\t    PCI_EEPROM_WIDTH_93C46 : PCI_EEPROM_WIDTH_93C66;\n\teeprom.reg_data_in = 0;\n\teeprom.reg_data_out = 0;\n\teeprom.reg_data_clock = 0;\n\teeprom.reg_chip_select = 0;\n\n\teeprom_93cx6_multiread(&eeprom, EEPROM_BASE, rt2x00dev->eeprom,\n\t\t\t       EEPROM_SIZE / sizeof(u16));\n\n\t \n\tmac = rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0);\n\trt2x00lib_set_mac_address(rt2x00dev, mac);\n\n\tword = rt2x00_eeprom_read(rt2x00dev, EEPROM_ANTENNA);\n\tif (word == 0xffff) {\n\t\trt2x00_set_field16(&word, EEPROM_ANTENNA_NUM, 2);\n\t\trt2x00_set_field16(&word, EEPROM_ANTENNA_TX_DEFAULT,\n\t\t\t\t   ANTENNA_B);\n\t\trt2x00_set_field16(&word, EEPROM_ANTENNA_RX_DEFAULT,\n\t\t\t\t   ANTENNA_B);\n\t\trt2x00_set_field16(&word, EEPROM_ANTENNA_FRAME_TYPE, 0);\n\t\trt2x00_set_field16(&word, EEPROM_ANTENNA_DYN_TXAGC, 0);\n\t\trt2x00_set_field16(&word, EEPROM_ANTENNA_HARDWARE_RADIO, 0);\n\t\trt2x00_set_field16(&word, EEPROM_ANTENNA_RF_TYPE, RF5225);\n\t\trt2x00_eeprom_write(rt2x00dev, EEPROM_ANTENNA, word);\n\t\trt2x00_eeprom_dbg(rt2x00dev, \"Antenna: 0x%04x\\n\", word);\n\t}\n\n\tword = rt2x00_eeprom_read(rt2x00dev, EEPROM_NIC);\n\tif (word == 0xffff) {\n\t\trt2x00_set_field16(&word, EEPROM_NIC_ENABLE_DIVERSITY, 0);\n\t\trt2x00_set_field16(&word, EEPROM_NIC_TX_DIVERSITY, 0);\n\t\trt2x00_set_field16(&word, EEPROM_NIC_RX_FIXED, 0);\n\t\trt2x00_set_field16(&word, EEPROM_NIC_TX_FIXED, 0);\n\t\trt2x00_set_field16(&word, EEPROM_NIC_EXTERNAL_LNA_BG, 0);\n\t\trt2x00_set_field16(&word, EEPROM_NIC_CARDBUS_ACCEL, 0);\n\t\trt2x00_set_field16(&word, EEPROM_NIC_EXTERNAL_LNA_A, 0);\n\t\trt2x00_eeprom_write(rt2x00dev, EEPROM_NIC, word);\n\t\trt2x00_eeprom_dbg(rt2x00dev, \"NIC: 0x%04x\\n\", word);\n\t}\n\n\tword = rt2x00_eeprom_read(rt2x00dev, EEPROM_LED);\n\tif (word == 0xffff) {\n\t\trt2x00_set_field16(&word, EEPROM_LED_LED_MODE,\n\t\t\t\t   LED_MODE_DEFAULT);\n\t\trt2x00_eeprom_write(rt2x00dev, EEPROM_LED, word);\n\t\trt2x00_eeprom_dbg(rt2x00dev, \"Led: 0x%04x\\n\", word);\n\t}\n\n\tword = rt2x00_eeprom_read(rt2x00dev, EEPROM_FREQ);\n\tif (word == 0xffff) {\n\t\trt2x00_set_field16(&word, EEPROM_FREQ_OFFSET, 0);\n\t\trt2x00_set_field16(&word, EEPROM_FREQ_SEQ, 0);\n\t\trt2x00_eeprom_write(rt2x00dev, EEPROM_FREQ, word);\n\t\trt2x00_eeprom_dbg(rt2x00dev, \"Freq: 0x%04x\\n\", word);\n\t}\n\n\tword = rt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_OFFSET_BG);\n\tif (word == 0xffff) {\n\t\trt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_BG_1, 0);\n\t\trt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_BG_2, 0);\n\t\trt2x00_eeprom_write(rt2x00dev, EEPROM_RSSI_OFFSET_BG, word);\n\t\trt2x00_eeprom_dbg(rt2x00dev, \"RSSI OFFSET BG: 0x%04x\\n\", word);\n\t} else {\n\t\tvalue = rt2x00_get_field16(word, EEPROM_RSSI_OFFSET_BG_1);\n\t\tif (value < -10 || value > 10)\n\t\t\trt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_BG_1, 0);\n\t\tvalue = rt2x00_get_field16(word, EEPROM_RSSI_OFFSET_BG_2);\n\t\tif (value < -10 || value > 10)\n\t\t\trt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_BG_2, 0);\n\t\trt2x00_eeprom_write(rt2x00dev, EEPROM_RSSI_OFFSET_BG, word);\n\t}\n\n\tword = rt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_OFFSET_A);\n\tif (word == 0xffff) {\n\t\trt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_A_1, 0);\n\t\trt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_A_2, 0);\n\t\trt2x00_eeprom_write(rt2x00dev, EEPROM_RSSI_OFFSET_A, word);\n\t\trt2x00_eeprom_dbg(rt2x00dev, \"RSSI OFFSET A: 0x%04x\\n\", word);\n\t} else {\n\t\tvalue = rt2x00_get_field16(word, EEPROM_RSSI_OFFSET_A_1);\n\t\tif (value < -10 || value > 10)\n\t\t\trt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_A_1, 0);\n\t\tvalue = rt2x00_get_field16(word, EEPROM_RSSI_OFFSET_A_2);\n\t\tif (value < -10 || value > 10)\n\t\t\trt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_A_2, 0);\n\t\trt2x00_eeprom_write(rt2x00dev, EEPROM_RSSI_OFFSET_A, word);\n\t}\n\n\treturn 0;\n}\n\nstatic int rt61pci_init_eeprom(struct rt2x00_dev *rt2x00dev)\n{\n\tu32 reg;\n\tu16 value;\n\tu16 eeprom;\n\n\t \n\teeprom = rt2x00_eeprom_read(rt2x00dev, EEPROM_ANTENNA);\n\n\t \n\tvalue = rt2x00_get_field16(eeprom, EEPROM_ANTENNA_RF_TYPE);\n\treg = rt2x00mmio_register_read(rt2x00dev, MAC_CSR0);\n\trt2x00_set_chip(rt2x00dev, rt2x00_get_field32(reg, MAC_CSR0_CHIPSET),\n\t\t\tvalue, rt2x00_get_field32(reg, MAC_CSR0_REVISION));\n\n\tif (!rt2x00_rf(rt2x00dev, RF5225) &&\n\t    !rt2x00_rf(rt2x00dev, RF5325) &&\n\t    !rt2x00_rf(rt2x00dev, RF2527) &&\n\t    !rt2x00_rf(rt2x00dev, RF2529)) {\n\t\trt2x00_err(rt2x00dev, \"Invalid RF chipset detected\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (rt2x00_get_field16(eeprom, EEPROM_ANTENNA_NUM) == 2)\n\t\t__set_bit(CAPABILITY_DOUBLE_ANTENNA, &rt2x00dev->cap_flags);\n\n\t \n\trt2x00dev->default_ant.tx =\n\t    rt2x00_get_field16(eeprom, EEPROM_ANTENNA_TX_DEFAULT);\n\trt2x00dev->default_ant.rx =\n\t    rt2x00_get_field16(eeprom, EEPROM_ANTENNA_RX_DEFAULT);\n\n\t \n\tif (rt2x00_get_field16(eeprom, EEPROM_ANTENNA_FRAME_TYPE))\n\t\t__set_bit(CAPABILITY_FRAME_TYPE, &rt2x00dev->cap_flags);\n\n\t \n\tif (rt2x00_get_field16(eeprom, EEPROM_ANTENNA_HARDWARE_RADIO))\n\t\t__set_bit(CAPABILITY_HW_BUTTON, &rt2x00dev->cap_flags);\n\n\t \n\teeprom = rt2x00_eeprom_read(rt2x00dev, EEPROM_FREQ);\n\tif (rt2x00_get_field16(eeprom, EEPROM_FREQ_SEQ))\n\t\t__set_bit(CAPABILITY_RF_SEQUENCE, &rt2x00dev->cap_flags);\n\n\trt2x00dev->freq_offset = rt2x00_get_field16(eeprom, EEPROM_FREQ_OFFSET);\n\n\t \n\teeprom = rt2x00_eeprom_read(rt2x00dev, EEPROM_NIC);\n\n\tif (rt2x00_get_field16(eeprom, EEPROM_NIC_EXTERNAL_LNA_A))\n\t\t__set_bit(CAPABILITY_EXTERNAL_LNA_A, &rt2x00dev->cap_flags);\n\tif (rt2x00_get_field16(eeprom, EEPROM_NIC_EXTERNAL_LNA_BG))\n\t\t__set_bit(CAPABILITY_EXTERNAL_LNA_BG, &rt2x00dev->cap_flags);\n\n\t \n\tif (rt2x00_rf(rt2x00dev, RF2529) &&\n\t    !rt2x00_has_cap_double_antenna(rt2x00dev)) {\n\t\trt2x00dev->default_ant.rx =\n\t\t    ANTENNA_A + rt2x00_get_field16(eeprom, EEPROM_NIC_RX_FIXED);\n\t\trt2x00dev->default_ant.tx =\n\t\t    ANTENNA_B - rt2x00_get_field16(eeprom, EEPROM_NIC_TX_FIXED);\n\n\t\tif (rt2x00_get_field16(eeprom, EEPROM_NIC_TX_DIVERSITY))\n\t\t\trt2x00dev->default_ant.tx = ANTENNA_SW_DIVERSITY;\n\t\tif (rt2x00_get_field16(eeprom, EEPROM_NIC_ENABLE_DIVERSITY))\n\t\t\trt2x00dev->default_ant.rx = ANTENNA_SW_DIVERSITY;\n\t}\n\n\t \n#ifdef CONFIG_RT2X00_LIB_LEDS\n\teeprom = rt2x00_eeprom_read(rt2x00dev, EEPROM_LED);\n\tvalue = rt2x00_get_field16(eeprom, EEPROM_LED_LED_MODE);\n\n\trt61pci_init_led(rt2x00dev, &rt2x00dev->led_radio, LED_TYPE_RADIO);\n\trt61pci_init_led(rt2x00dev, &rt2x00dev->led_assoc, LED_TYPE_ASSOC);\n\tif (value == LED_MODE_SIGNAL_STRENGTH)\n\t\trt61pci_init_led(rt2x00dev, &rt2x00dev->led_qual,\n\t\t\t\t LED_TYPE_QUALITY);\n\n\trt2x00_set_field16(&rt2x00dev->led_mcu_reg, MCU_LEDCS_LED_MODE, value);\n\trt2x00_set_field16(&rt2x00dev->led_mcu_reg, MCU_LEDCS_POLARITY_GPIO_0,\n\t\t\t   rt2x00_get_field16(eeprom,\n\t\t\t\t\t      EEPROM_LED_POLARITY_GPIO_0));\n\trt2x00_set_field16(&rt2x00dev->led_mcu_reg, MCU_LEDCS_POLARITY_GPIO_1,\n\t\t\t   rt2x00_get_field16(eeprom,\n\t\t\t\t\t      EEPROM_LED_POLARITY_GPIO_1));\n\trt2x00_set_field16(&rt2x00dev->led_mcu_reg, MCU_LEDCS_POLARITY_GPIO_2,\n\t\t\t   rt2x00_get_field16(eeprom,\n\t\t\t\t\t      EEPROM_LED_POLARITY_GPIO_2));\n\trt2x00_set_field16(&rt2x00dev->led_mcu_reg, MCU_LEDCS_POLARITY_GPIO_3,\n\t\t\t   rt2x00_get_field16(eeprom,\n\t\t\t\t\t      EEPROM_LED_POLARITY_GPIO_3));\n\trt2x00_set_field16(&rt2x00dev->led_mcu_reg, MCU_LEDCS_POLARITY_GPIO_4,\n\t\t\t   rt2x00_get_field16(eeprom,\n\t\t\t\t\t      EEPROM_LED_POLARITY_GPIO_4));\n\trt2x00_set_field16(&rt2x00dev->led_mcu_reg, MCU_LEDCS_POLARITY_ACT,\n\t\t\t   rt2x00_get_field16(eeprom, EEPROM_LED_POLARITY_ACT));\n\trt2x00_set_field16(&rt2x00dev->led_mcu_reg, MCU_LEDCS_POLARITY_READY_BG,\n\t\t\t   rt2x00_get_field16(eeprom,\n\t\t\t\t\t      EEPROM_LED_POLARITY_RDY_G));\n\trt2x00_set_field16(&rt2x00dev->led_mcu_reg, MCU_LEDCS_POLARITY_READY_A,\n\t\t\t   rt2x00_get_field16(eeprom,\n\t\t\t\t\t      EEPROM_LED_POLARITY_RDY_A));\n#endif  \n\n\treturn 0;\n}\n\n \nstatic const struct rf_channel rf_vals_noseq[] = {\n\t{ 1,  0x00002ccc, 0x00004786, 0x00068455, 0x000ffa0b },\n\t{ 2,  0x00002ccc, 0x00004786, 0x00068455, 0x000ffa1f },\n\t{ 3,  0x00002ccc, 0x0000478a, 0x00068455, 0x000ffa0b },\n\t{ 4,  0x00002ccc, 0x0000478a, 0x00068455, 0x000ffa1f },\n\t{ 5,  0x00002ccc, 0x0000478e, 0x00068455, 0x000ffa0b },\n\t{ 6,  0x00002ccc, 0x0000478e, 0x00068455, 0x000ffa1f },\n\t{ 7,  0x00002ccc, 0x00004792, 0x00068455, 0x000ffa0b },\n\t{ 8,  0x00002ccc, 0x00004792, 0x00068455, 0x000ffa1f },\n\t{ 9,  0x00002ccc, 0x00004796, 0x00068455, 0x000ffa0b },\n\t{ 10, 0x00002ccc, 0x00004796, 0x00068455, 0x000ffa1f },\n\t{ 11, 0x00002ccc, 0x0000479a, 0x00068455, 0x000ffa0b },\n\t{ 12, 0x00002ccc, 0x0000479a, 0x00068455, 0x000ffa1f },\n\t{ 13, 0x00002ccc, 0x0000479e, 0x00068455, 0x000ffa0b },\n\t{ 14, 0x00002ccc, 0x000047a2, 0x00068455, 0x000ffa13 },\n\n\t \n\t{ 36, 0x00002ccc, 0x0000499a, 0x0009be55, 0x000ffa23 },\n\t{ 40, 0x00002ccc, 0x000049a2, 0x0009be55, 0x000ffa03 },\n\t{ 44, 0x00002ccc, 0x000049a6, 0x0009be55, 0x000ffa0b },\n\t{ 48, 0x00002ccc, 0x000049aa, 0x0009be55, 0x000ffa13 },\n\t{ 52, 0x00002ccc, 0x000049ae, 0x0009ae55, 0x000ffa1b },\n\t{ 56, 0x00002ccc, 0x000049b2, 0x0009ae55, 0x000ffa23 },\n\t{ 60, 0x00002ccc, 0x000049ba, 0x0009ae55, 0x000ffa03 },\n\t{ 64, 0x00002ccc, 0x000049be, 0x0009ae55, 0x000ffa0b },\n\n\t \n\t{ 100, 0x00002ccc, 0x00004a2a, 0x000bae55, 0x000ffa03 },\n\t{ 104, 0x00002ccc, 0x00004a2e, 0x000bae55, 0x000ffa0b },\n\t{ 108, 0x00002ccc, 0x00004a32, 0x000bae55, 0x000ffa13 },\n\t{ 112, 0x00002ccc, 0x00004a36, 0x000bae55, 0x000ffa1b },\n\t{ 116, 0x00002ccc, 0x00004a3a, 0x000bbe55, 0x000ffa23 },\n\t{ 120, 0x00002ccc, 0x00004a82, 0x000bbe55, 0x000ffa03 },\n\t{ 124, 0x00002ccc, 0x00004a86, 0x000bbe55, 0x000ffa0b },\n\t{ 128, 0x00002ccc, 0x00004a8a, 0x000bbe55, 0x000ffa13 },\n\t{ 132, 0x00002ccc, 0x00004a8e, 0x000bbe55, 0x000ffa1b },\n\t{ 136, 0x00002ccc, 0x00004a92, 0x000bbe55, 0x000ffa23 },\n\n\t \n\t{ 140, 0x00002ccc, 0x00004a9a, 0x000bbe55, 0x000ffa03 },\n\t{ 149, 0x00002ccc, 0x00004aa2, 0x000bbe55, 0x000ffa1f },\n\t{ 153, 0x00002ccc, 0x00004aa6, 0x000bbe55, 0x000ffa27 },\n\t{ 157, 0x00002ccc, 0x00004aae, 0x000bbe55, 0x000ffa07 },\n\t{ 161, 0x00002ccc, 0x00004ab2, 0x000bbe55, 0x000ffa0f },\n\t{ 165, 0x00002ccc, 0x00004ab6, 0x000bbe55, 0x000ffa17 },\n\n\t \n\t{ 34, 0x00002ccc, 0x0000499a, 0x0009be55, 0x000ffa0b },\n\t{ 38, 0x00002ccc, 0x0000499e, 0x0009be55, 0x000ffa13 },\n\t{ 42, 0x00002ccc, 0x000049a2, 0x0009be55, 0x000ffa1b },\n\t{ 46, 0x00002ccc, 0x000049a6, 0x0009be55, 0x000ffa23 },\n};\n\n \nstatic const struct rf_channel rf_vals_seq[] = {\n\t{ 1,  0x00002ccc, 0x00004786, 0x00068455, 0x000ffa0b },\n\t{ 2,  0x00002ccc, 0x00004786, 0x00068455, 0x000ffa1f },\n\t{ 3,  0x00002ccc, 0x0000478a, 0x00068455, 0x000ffa0b },\n\t{ 4,  0x00002ccc, 0x0000478a, 0x00068455, 0x000ffa1f },\n\t{ 5,  0x00002ccc, 0x0000478e, 0x00068455, 0x000ffa0b },\n\t{ 6,  0x00002ccc, 0x0000478e, 0x00068455, 0x000ffa1f },\n\t{ 7,  0x00002ccc, 0x00004792, 0x00068455, 0x000ffa0b },\n\t{ 8,  0x00002ccc, 0x00004792, 0x00068455, 0x000ffa1f },\n\t{ 9,  0x00002ccc, 0x00004796, 0x00068455, 0x000ffa0b },\n\t{ 10, 0x00002ccc, 0x00004796, 0x00068455, 0x000ffa1f },\n\t{ 11, 0x00002ccc, 0x0000479a, 0x00068455, 0x000ffa0b },\n\t{ 12, 0x00002ccc, 0x0000479a, 0x00068455, 0x000ffa1f },\n\t{ 13, 0x00002ccc, 0x0000479e, 0x00068455, 0x000ffa0b },\n\t{ 14, 0x00002ccc, 0x000047a2, 0x00068455, 0x000ffa13 },\n\n\t \n\t{ 36, 0x00002cd4, 0x0004481a, 0x00098455, 0x000c0a03 },\n\t{ 40, 0x00002cd0, 0x00044682, 0x00098455, 0x000c0a03 },\n\t{ 44, 0x00002cd0, 0x00044686, 0x00098455, 0x000c0a1b },\n\t{ 48, 0x00002cd0, 0x0004468e, 0x00098655, 0x000c0a0b },\n\t{ 52, 0x00002cd0, 0x00044692, 0x00098855, 0x000c0a23 },\n\t{ 56, 0x00002cd0, 0x0004469a, 0x00098c55, 0x000c0a13 },\n\t{ 60, 0x00002cd0, 0x000446a2, 0x00098e55, 0x000c0a03 },\n\t{ 64, 0x00002cd0, 0x000446a6, 0x00099255, 0x000c0a1b },\n\n\t \n\t{ 100, 0x00002cd4, 0x0004489a, 0x000b9855, 0x000c0a03 },\n\t{ 104, 0x00002cd4, 0x000448a2, 0x000b9855, 0x000c0a03 },\n\t{ 108, 0x00002cd4, 0x000448aa, 0x000b9855, 0x000c0a03 },\n\t{ 112, 0x00002cd4, 0x000448b2, 0x000b9a55, 0x000c0a03 },\n\t{ 116, 0x00002cd4, 0x000448ba, 0x000b9a55, 0x000c0a03 },\n\t{ 120, 0x00002cd0, 0x00044702, 0x000b9a55, 0x000c0a03 },\n\t{ 124, 0x00002cd0, 0x00044706, 0x000b9a55, 0x000c0a1b },\n\t{ 128, 0x00002cd0, 0x0004470e, 0x000b9c55, 0x000c0a0b },\n\t{ 132, 0x00002cd0, 0x00044712, 0x000b9c55, 0x000c0a23 },\n\t{ 136, 0x00002cd0, 0x0004471a, 0x000b9e55, 0x000c0a13 },\n\n\t \n\t{ 140, 0x00002cd0, 0x00044722, 0x000b9e55, 0x000c0a03 },\n\t{ 149, 0x00002cd0, 0x0004472e, 0x000ba255, 0x000c0a1b },\n\t{ 153, 0x00002cd0, 0x00044736, 0x000ba255, 0x000c0a0b },\n\t{ 157, 0x00002cd4, 0x0004490a, 0x000ba255, 0x000c0a17 },\n\t{ 161, 0x00002cd4, 0x00044912, 0x000ba255, 0x000c0a17 },\n\t{ 165, 0x00002cd4, 0x0004491a, 0x000ba255, 0x000c0a17 },\n\n\t \n\t{ 34, 0x00002ccc, 0x0000499a, 0x0009be55, 0x000c0a0b },\n\t{ 38, 0x00002ccc, 0x0000499e, 0x0009be55, 0x000c0a13 },\n\t{ 42, 0x00002ccc, 0x000049a2, 0x0009be55, 0x000c0a1b },\n\t{ 46, 0x00002ccc, 0x000049a6, 0x0009be55, 0x000c0a23 },\n};\n\nstatic int rt61pci_probe_hw_mode(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct hw_mode_spec *spec = &rt2x00dev->spec;\n\tstruct channel_info *info;\n\tu8 *tx_power;\n\tunsigned int i;\n\n\t \n\trt2x00dev->hw->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;\n\n\t \n\tieee80211_hw_set(rt2x00dev->hw, PS_NULLFUNC_STACK);\n\tieee80211_hw_set(rt2x00dev->hw, SUPPORTS_PS);\n\tieee80211_hw_set(rt2x00dev->hw, HOST_BROADCAST_PS_BUFFERING);\n\tieee80211_hw_set(rt2x00dev->hw, SIGNAL_DBM);\n\n\tSET_IEEE80211_DEV(rt2x00dev->hw, rt2x00dev->dev);\n\tSET_IEEE80211_PERM_ADDR(rt2x00dev->hw,\n\t\t\t\trt2x00_eeprom_addr(rt2x00dev,\n\t\t\t\t\t\t   EEPROM_MAC_ADDR_0));\n\n\t \n\trt2x00dev->hw->max_rates = 1;\n\trt2x00dev->hw->max_report_rates = 7;\n\trt2x00dev->hw->max_rate_tries = 1;\n\n\t \n\tspec->supported_bands = SUPPORT_BAND_2GHZ;\n\tspec->supported_rates = SUPPORT_RATE_CCK | SUPPORT_RATE_OFDM;\n\n\tif (!rt2x00_has_cap_rf_sequence(rt2x00dev)) {\n\t\tspec->num_channels = 14;\n\t\tspec->channels = rf_vals_noseq;\n\t} else {\n\t\tspec->num_channels = 14;\n\t\tspec->channels = rf_vals_seq;\n\t}\n\n\tif (rt2x00_rf(rt2x00dev, RF5225) || rt2x00_rf(rt2x00dev, RF5325)) {\n\t\tspec->supported_bands |= SUPPORT_BAND_5GHZ;\n\t\tspec->num_channels = ARRAY_SIZE(rf_vals_seq);\n\t}\n\n\t \n\tinfo = kcalloc(spec->num_channels, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tspec->channels_info = info;\n\n\ttx_power = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_G_START);\n\tfor (i = 0; i < 14; i++) {\n\t\tinfo[i].max_power = MAX_TXPOWER;\n\t\tinfo[i].default_power1 = TXPOWER_FROM_DEV(tx_power[i]);\n\t}\n\n\tif (spec->num_channels > 14) {\n\t\ttx_power = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_A_START);\n\t\tfor (i = 14; i < spec->num_channels; i++) {\n\t\t\tinfo[i].max_power = MAX_TXPOWER;\n\t\t\tinfo[i].default_power1 =\n\t\t\t\t\tTXPOWER_FROM_DEV(tx_power[i - 14]);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rt61pci_probe_hw(struct rt2x00_dev *rt2x00dev)\n{\n\tint retval;\n\tu32 reg;\n\n\t \n\trt2x00mmio_register_write(rt2x00dev, SOFT_RESET_CSR, 0x00000007);\n\n\t \n\tretval = rt61pci_validate_eeprom(rt2x00dev);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = rt61pci_init_eeprom(rt2x00dev);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\treg = rt2x00mmio_register_read(rt2x00dev, MAC_CSR13);\n\trt2x00_set_field32(&reg, MAC_CSR13_DIR5, 1);\n\trt2x00mmio_register_write(rt2x00dev, MAC_CSR13, reg);\n\n\t \n\tretval = rt61pci_probe_hw_mode(rt2x00dev);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\t__set_bit(CAPABILITY_CONTROL_FILTERS, &rt2x00dev->cap_flags);\n\n\t \n\t__set_bit(REQUIRE_FIRMWARE, &rt2x00dev->cap_flags);\n\t__set_bit(REQUIRE_DMA, &rt2x00dev->cap_flags);\n\tif (!modparam_nohwcrypt)\n\t\t__set_bit(CAPABILITY_HW_CRYPTO, &rt2x00dev->cap_flags);\n\t__set_bit(CAPABILITY_LINK_TUNING, &rt2x00dev->cap_flags);\n\n\t \n\trt2x00dev->rssi_offset = DEFAULT_RSSI_OFFSET;\n\n\treturn 0;\n}\n\n \nstatic int rt61pci_conf_tx(struct ieee80211_hw *hw,\n\t\t\t   struct ieee80211_vif *vif,\n\t\t\t   unsigned int link_id, u16 queue_idx,\n\t\t\t   const struct ieee80211_tx_queue_params *params)\n{\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\tstruct data_queue *queue;\n\tstruct rt2x00_field32 field;\n\tint retval;\n\tu32 reg;\n\tu32 offset;\n\n\t \n\tretval = rt2x00mac_conf_tx(hw, vif, link_id, queue_idx, params);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tif (queue_idx >= 4)\n\t\treturn 0;\n\n\tqueue = rt2x00queue_get_tx_queue(rt2x00dev, queue_idx);\n\n\t \n\toffset = AC_TXOP_CSR0 + (sizeof(u32) * (!!(queue_idx & 2)));\n\tfield.bit_offset = (queue_idx & 1) * 16;\n\tfield.bit_mask = 0xffff << field.bit_offset;\n\n\treg = rt2x00mmio_register_read(rt2x00dev, offset);\n\trt2x00_set_field32(&reg, field, queue->txop);\n\trt2x00mmio_register_write(rt2x00dev, offset, reg);\n\n\t \n\tfield.bit_offset = queue_idx * 4;\n\tfield.bit_mask = 0xf << field.bit_offset;\n\n\treg = rt2x00mmio_register_read(rt2x00dev, AIFSN_CSR);\n\trt2x00_set_field32(&reg, field, queue->aifs);\n\trt2x00mmio_register_write(rt2x00dev, AIFSN_CSR, reg);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, CWMIN_CSR);\n\trt2x00_set_field32(&reg, field, queue->cw_min);\n\trt2x00mmio_register_write(rt2x00dev, CWMIN_CSR, reg);\n\n\treg = rt2x00mmio_register_read(rt2x00dev, CWMAX_CSR);\n\trt2x00_set_field32(&reg, field, queue->cw_max);\n\trt2x00mmio_register_write(rt2x00dev, CWMAX_CSR, reg);\n\n\treturn 0;\n}\n\nstatic u64 rt61pci_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\tu64 tsf;\n\tu32 reg;\n\n\treg = rt2x00mmio_register_read(rt2x00dev, TXRX_CSR13);\n\ttsf = (u64) rt2x00_get_field32(reg, TXRX_CSR13_HIGH_TSFTIMER) << 32;\n\treg = rt2x00mmio_register_read(rt2x00dev, TXRX_CSR12);\n\ttsf |= rt2x00_get_field32(reg, TXRX_CSR12_LOW_TSFTIMER);\n\n\treturn tsf;\n}\n\nstatic const struct ieee80211_ops rt61pci_mac80211_ops = {\n\t.tx\t\t\t= rt2x00mac_tx,\n\t.wake_tx_queue\t\t= ieee80211_handle_wake_tx_queue,\n\t.start\t\t\t= rt2x00mac_start,\n\t.stop\t\t\t= rt2x00mac_stop,\n\t.add_interface\t\t= rt2x00mac_add_interface,\n\t.remove_interface\t= rt2x00mac_remove_interface,\n\t.config\t\t\t= rt2x00mac_config,\n\t.configure_filter\t= rt2x00mac_configure_filter,\n\t.set_key\t\t= rt2x00mac_set_key,\n\t.sw_scan_start\t\t= rt2x00mac_sw_scan_start,\n\t.sw_scan_complete\t= rt2x00mac_sw_scan_complete,\n\t.get_stats\t\t= rt2x00mac_get_stats,\n\t.bss_info_changed\t= rt2x00mac_bss_info_changed,\n\t.conf_tx\t\t= rt61pci_conf_tx,\n\t.get_tsf\t\t= rt61pci_get_tsf,\n\t.rfkill_poll\t\t= rt2x00mac_rfkill_poll,\n\t.flush\t\t\t= rt2x00mac_flush,\n\t.set_antenna\t\t= rt2x00mac_set_antenna,\n\t.get_antenna\t\t= rt2x00mac_get_antenna,\n\t.get_ringparam\t\t= rt2x00mac_get_ringparam,\n\t.tx_frames_pending\t= rt2x00mac_tx_frames_pending,\n};\n\nstatic const struct rt2x00lib_ops rt61pci_rt2x00_ops = {\n\t.irq_handler\t\t= rt61pci_interrupt,\n\t.txstatus_tasklet\t= rt61pci_txstatus_tasklet,\n\t.tbtt_tasklet\t\t= rt61pci_tbtt_tasklet,\n\t.rxdone_tasklet\t\t= rt61pci_rxdone_tasklet,\n\t.autowake_tasklet\t= rt61pci_autowake_tasklet,\n\t.probe_hw\t\t= rt61pci_probe_hw,\n\t.get_firmware_name\t= rt61pci_get_firmware_name,\n\t.check_firmware\t\t= rt61pci_check_firmware,\n\t.load_firmware\t\t= rt61pci_load_firmware,\n\t.initialize\t\t= rt2x00mmio_initialize,\n\t.uninitialize\t\t= rt2x00mmio_uninitialize,\n\t.get_entry_state\t= rt61pci_get_entry_state,\n\t.clear_entry\t\t= rt61pci_clear_entry,\n\t.set_device_state\t= rt61pci_set_device_state,\n\t.rfkill_poll\t\t= rt61pci_rfkill_poll,\n\t.link_stats\t\t= rt61pci_link_stats,\n\t.reset_tuner\t\t= rt61pci_reset_tuner,\n\t.link_tuner\t\t= rt61pci_link_tuner,\n\t.start_queue\t\t= rt61pci_start_queue,\n\t.kick_queue\t\t= rt61pci_kick_queue,\n\t.stop_queue\t\t= rt61pci_stop_queue,\n\t.flush_queue\t\t= rt2x00mmio_flush_queue,\n\t.write_tx_desc\t\t= rt61pci_write_tx_desc,\n\t.write_beacon\t\t= rt61pci_write_beacon,\n\t.clear_beacon\t\t= rt61pci_clear_beacon,\n\t.fill_rxdone\t\t= rt61pci_fill_rxdone,\n\t.config_shared_key\t= rt61pci_config_shared_key,\n\t.config_pairwise_key\t= rt61pci_config_pairwise_key,\n\t.config_filter\t\t= rt61pci_config_filter,\n\t.config_intf\t\t= rt61pci_config_intf,\n\t.config_erp\t\t= rt61pci_config_erp,\n\t.config_ant\t\t= rt61pci_config_ant,\n\t.config\t\t\t= rt61pci_config,\n};\n\nstatic void rt61pci_queue_init(struct data_queue *queue)\n{\n\tswitch (queue->qid) {\n\tcase QID_RX:\n\t\tqueue->limit = 32;\n\t\tqueue->data_size = DATA_FRAME_SIZE;\n\t\tqueue->desc_size = RXD_DESC_SIZE;\n\t\tqueue->priv_size = sizeof(struct queue_entry_priv_mmio);\n\t\tbreak;\n\n\tcase QID_AC_VO:\n\tcase QID_AC_VI:\n\tcase QID_AC_BE:\n\tcase QID_AC_BK:\n\t\tqueue->limit = 32;\n\t\tqueue->data_size = DATA_FRAME_SIZE;\n\t\tqueue->desc_size = TXD_DESC_SIZE;\n\t\tqueue->priv_size = sizeof(struct queue_entry_priv_mmio);\n\t\tbreak;\n\n\tcase QID_BEACON:\n\t\tqueue->limit = 4;\n\t\tqueue->data_size = 0;  \n\t\tqueue->desc_size = TXINFO_SIZE;\n\t\tqueue->priv_size = sizeof(struct queue_entry_priv_mmio);\n\t\tbreak;\n\n\tcase QID_ATIM:\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n}\n\nstatic const struct rt2x00_ops rt61pci_ops = {\n\t.name\t\t\t= KBUILD_MODNAME,\n\t.max_ap_intf\t\t= 4,\n\t.eeprom_size\t\t= EEPROM_SIZE,\n\t.rf_size\t\t= RF_SIZE,\n\t.tx_queues\t\t= NUM_TX_QUEUES,\n\t.queue_init\t\t= rt61pci_queue_init,\n\t.lib\t\t\t= &rt61pci_rt2x00_ops,\n\t.hw\t\t\t= &rt61pci_mac80211_ops,\n#ifdef CONFIG_RT2X00_LIB_DEBUGFS\n\t.debugfs\t\t= &rt61pci_rt2x00debug,\n#endif  \n};\n\n \nstatic const struct pci_device_id rt61pci_device_table[] = {\n\t \n\t{ PCI_DEVICE(0x1814, 0x0301) },\n\t \n\t{ PCI_DEVICE(0x1814, 0x0302) },\n\t \n\t{ PCI_DEVICE(0x1814, 0x0401) },\n\t{ 0, }\n};\n\nMODULE_AUTHOR(DRV_PROJECT);\nMODULE_VERSION(DRV_VERSION);\nMODULE_DESCRIPTION(\"Ralink RT61 PCI & PCMCIA Wireless LAN driver.\");\nMODULE_DEVICE_TABLE(pci, rt61pci_device_table);\nMODULE_FIRMWARE(FIRMWARE_RT2561);\nMODULE_FIRMWARE(FIRMWARE_RT2561s);\nMODULE_FIRMWARE(FIRMWARE_RT2661);\nMODULE_LICENSE(\"GPL\");\n\nstatic int rt61pci_probe(struct pci_dev *pci_dev,\n\t\t\t const struct pci_device_id *id)\n{\n\treturn rt2x00pci_probe(pci_dev, &rt61pci_ops);\n}\n\nstatic struct pci_driver rt61pci_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= rt61pci_device_table,\n\t.probe\t\t= rt61pci_probe,\n\t.remove\t\t= rt2x00pci_remove,\n\t.driver.pm\t= &rt2x00pci_pm_ops,\n};\n\nmodule_pci_driver(rt61pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}