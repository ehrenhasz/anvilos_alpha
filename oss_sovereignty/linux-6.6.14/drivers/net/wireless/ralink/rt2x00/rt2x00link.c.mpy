{
  "module_name": "rt2x00link.c",
  "hash_id": "0ab42b1118b20f9b43e72d83aed5e0866fc3ab0849c3e814a3d0e554e2cafb42",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ralink/rt2x00/rt2x00link.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#include \"rt2x00.h\"\n#include \"rt2x00lib.h\"\n\n \n#define DEFAULT_RSSI\t\t-128\n\nstatic inline int rt2x00link_get_avg_rssi(struct ewma_rssi *ewma)\n{\n\tunsigned long avg;\n\n\tavg = ewma_rssi_read(ewma);\n\tif (avg)\n\t\treturn -avg;\n\n\treturn DEFAULT_RSSI;\n}\n\nstatic int rt2x00link_antenna_get_link_rssi(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct link_ant *ant = &rt2x00dev->link.ant;\n\n\tif (rt2x00dev->link.qual.rx_success)\n\t\treturn rt2x00link_get_avg_rssi(&ant->rssi_ant);\n\n\treturn DEFAULT_RSSI;\n}\n\nstatic int rt2x00link_antenna_get_rssi_history(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct link_ant *ant = &rt2x00dev->link.ant;\n\n\tif (ant->rssi_history)\n\t\treturn ant->rssi_history;\n\treturn DEFAULT_RSSI;\n}\n\nstatic void rt2x00link_antenna_update_rssi_history(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t\t   int rssi)\n{\n\tstruct link_ant *ant = &rt2x00dev->link.ant;\n\tant->rssi_history = rssi;\n}\n\nstatic void rt2x00link_antenna_reset(struct rt2x00_dev *rt2x00dev)\n{\n\tewma_rssi_init(&rt2x00dev->link.ant.rssi_ant);\n}\n\nstatic void rt2x00lib_antenna_diversity_sample(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct link_ant *ant = &rt2x00dev->link.ant;\n\tstruct antenna_setup new_ant;\n\tint other_antenna;\n\n\tint sample_current = rt2x00link_antenna_get_link_rssi(rt2x00dev);\n\tint sample_other = rt2x00link_antenna_get_rssi_history(rt2x00dev);\n\n\tmemcpy(&new_ant, &ant->active, sizeof(new_ant));\n\n\t \n\tant->flags &= ~ANTENNA_MODE_SAMPLE;\n\n\t \n\tif (sample_current >= sample_other) {\n\t\trt2x00link_antenna_update_rssi_history(rt2x00dev,\n\t\t\tsample_current);\n\t\treturn;\n\t}\n\n\tother_antenna = (ant->active.rx == ANTENNA_A) ? ANTENNA_B : ANTENNA_A;\n\n\tif (ant->flags & ANTENNA_RX_DIVERSITY)\n\t\tnew_ant.rx = other_antenna;\n\n\tif (ant->flags & ANTENNA_TX_DIVERSITY)\n\t\tnew_ant.tx = other_antenna;\n\n\trt2x00lib_config_antenna(rt2x00dev, new_ant);\n}\n\nstatic void rt2x00lib_antenna_diversity_eval(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct link_ant *ant = &rt2x00dev->link.ant;\n\tstruct antenna_setup new_ant;\n\tint rssi_curr;\n\tint rssi_old;\n\n\tmemcpy(&new_ant, &ant->active, sizeof(new_ant));\n\n\t \n\trssi_curr = rt2x00link_antenna_get_link_rssi(rt2x00dev);\n\trssi_old = rt2x00link_antenna_get_rssi_history(rt2x00dev);\n\trt2x00link_antenna_update_rssi_history(rt2x00dev, rssi_curr);\n\n\t \n\tif (abs(rssi_curr - rssi_old) < 5)\n\t\treturn;\n\n\tant->flags |= ANTENNA_MODE_SAMPLE;\n\n\tif (ant->flags & ANTENNA_RX_DIVERSITY)\n\t\tnew_ant.rx = (new_ant.rx == ANTENNA_A) ? ANTENNA_B : ANTENNA_A;\n\n\tif (ant->flags & ANTENNA_TX_DIVERSITY)\n\t\tnew_ant.tx = (new_ant.tx == ANTENNA_A) ? ANTENNA_B : ANTENNA_A;\n\n\trt2x00lib_config_antenna(rt2x00dev, new_ant);\n}\n\nstatic bool rt2x00lib_antenna_diversity(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct link_ant *ant = &rt2x00dev->link.ant;\n\n\t \n\tif (!(ant->flags & ANTENNA_RX_DIVERSITY) &&\n\t    !(ant->flags & ANTENNA_TX_DIVERSITY)) {\n\t\tant->flags = 0;\n\t\treturn true;\n\t}\n\n\t \n\tif (ant->flags & ANTENNA_MODE_SAMPLE) {\n\t\trt2x00lib_antenna_diversity_sample(rt2x00dev);\n\t\treturn true;\n\t} else if (rt2x00dev->link.count & 1) {\n\t\trt2x00lib_antenna_diversity_eval(rt2x00dev);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid rt2x00link_update_stats(struct rt2x00_dev *rt2x00dev,\n\t\t\t     struct sk_buff *skb,\n\t\t\t     struct rxdone_entry_desc *rxdesc)\n{\n\tstruct link *link = &rt2x00dev->link;\n\tstruct link_qual *qual = &rt2x00dev->link.qual;\n\tstruct link_ant *ant = &rt2x00dev->link.ant;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\n\t \n\tif (!rt2x00dev->intf_sta_count)\n\t\treturn;\n\n\t \n\tqual->rx_success++;\n\n\t \n\tif (!ieee80211_is_beacon(hdr->frame_control) ||\n\t    !(rxdesc->dev_flags & RXDONE_MY_BSS))\n\t\treturn;\n\n\t \n\tewma_rssi_add(&link->avg_rssi, -rxdesc->rssi);\n\n\t \n\tewma_rssi_add(&ant->rssi_ant, -rxdesc->rssi);\n}\n\nvoid rt2x00link_start_tuner(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct link *link = &rt2x00dev->link;\n\n\t \n\tif (!rt2x00dev->intf_ap_count && !rt2x00dev->intf_sta_count)\n\t\treturn;\n\n\t \n\tif (test_bit(DEVICE_STATE_SCANNING, &rt2x00dev->flags))\n\t\treturn;\n\n\trt2x00link_reset_tuner(rt2x00dev, false);\n\n\tif (test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\n\t\tieee80211_queue_delayed_work(rt2x00dev->hw,\n\t\t\t\t\t     &link->work, LINK_TUNE_INTERVAL);\n}\n\nvoid rt2x00link_stop_tuner(struct rt2x00_dev *rt2x00dev)\n{\n\tcancel_delayed_work_sync(&rt2x00dev->link.work);\n}\n\nvoid rt2x00link_reset_tuner(struct rt2x00_dev *rt2x00dev, bool antenna)\n{\n\tstruct link_qual *qual = &rt2x00dev->link.qual;\n\tu8 vgc_level = qual->vgc_level_reg;\n\n\tif (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\treturn;\n\n\t \n\trt2x00dev->link.count = 0;\n\tmemset(qual, 0, sizeof(*qual));\n\tewma_rssi_init(&rt2x00dev->link.avg_rssi);\n\n\t \n\tqual->vgc_level_reg = vgc_level;\n\n\t \n\trt2x00dev->ops->lib->reset_tuner(rt2x00dev, qual);\n\n\tif (antenna)\n\t\trt2x00link_antenna_reset(rt2x00dev);\n}\n\nstatic void rt2x00link_reset_qual(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct link_qual *qual = &rt2x00dev->link.qual;\n\n\tqual->rx_success = 0;\n\tqual->rx_failed = 0;\n\tqual->tx_success = 0;\n\tqual->tx_failed = 0;\n}\n\nstatic void rt2x00link_tuner_sta(struct rt2x00_dev *rt2x00dev, struct link *link)\n{\n\tstruct link_qual *qual = &rt2x00dev->link.qual;\n\n\t \n\trt2x00dev->ops->lib->link_stats(rt2x00dev, qual);\n\trt2x00dev->low_level_stats.dot11FCSErrorCount += qual->rx_failed;\n\n\t \n\tif (!qual->rx_success)\n\t\tqual->rssi = DEFAULT_RSSI;\n\telse\n\t\tqual->rssi = rt2x00link_get_avg_rssi(&link->avg_rssi);\n\n\t \n\tif (rt2x00_has_cap_link_tuning(rt2x00dev))\n\t\trt2x00dev->ops->lib->link_tuner(rt2x00dev, qual, link->count);\n\n\t \n\trt2x00leds_led_quality(rt2x00dev, qual->rssi);\n\n\t \n\tif (rt2x00lib_antenna_diversity(rt2x00dev))\n\t\trt2x00link_reset_qual(rt2x00dev);\n}\n\nstatic void rt2x00link_tuner(struct work_struct *work)\n{\n\tstruct rt2x00_dev *rt2x00dev =\n\t    container_of(work, struct rt2x00_dev, link.work.work);\n\tstruct link *link = &rt2x00dev->link;\n\n\t \n\tif (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags) ||\n\t    test_bit(DEVICE_STATE_SCANNING, &rt2x00dev->flags))\n\t\treturn;\n\n\t \n\tmutex_lock(&rt2x00dev->conf_mutex);\n\n\tif (rt2x00dev->intf_sta_count)\n\t\trt2x00link_tuner_sta(rt2x00dev, link);\n\n\tif (rt2x00dev->ops->lib->gain_calibration &&\n\t    (link->count % (AGC_SECONDS / LINK_TUNE_SECONDS)) == 0)\n\t\trt2x00dev->ops->lib->gain_calibration(rt2x00dev);\n\n\tif (rt2x00dev->ops->lib->vco_calibration &&\n\t    rt2x00_has_cap_vco_recalibration(rt2x00dev) &&\n\t    (link->count % (VCO_SECONDS / LINK_TUNE_SECONDS)) == 0)\n\t\trt2x00dev->ops->lib->vco_calibration(rt2x00dev);\n\n\tmutex_unlock(&rt2x00dev->conf_mutex);\n\n\t \n\tlink->count++;\n\n\tif (test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\n\t\tieee80211_queue_delayed_work(rt2x00dev->hw,\n\t\t\t\t\t     &link->work, LINK_TUNE_INTERVAL);\n}\n\nvoid rt2x00link_start_watchdog(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct link *link = &rt2x00dev->link;\n\n\tif (test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags) &&\n\t    rt2x00dev->ops->lib->watchdog && !link->watchdog_disabled)\n\t\tieee80211_queue_delayed_work(rt2x00dev->hw,\n\t\t\t\t\t     &link->watchdog_work,\n\t\t\t\t\t     link->watchdog_interval);\n}\n\nvoid rt2x00link_stop_watchdog(struct rt2x00_dev *rt2x00dev)\n{\n\tcancel_delayed_work_sync(&rt2x00dev->link.watchdog_work);\n}\n\nstatic void rt2x00link_watchdog(struct work_struct *work)\n{\n\tstruct rt2x00_dev *rt2x00dev =\n\t    container_of(work, struct rt2x00_dev, link.watchdog_work.work);\n\tstruct link *link = &rt2x00dev->link;\n\n\t \n\tif (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\treturn;\n\n\trt2x00dev->ops->lib->watchdog(rt2x00dev);\n\n\tif (test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\n\t\tieee80211_queue_delayed_work(rt2x00dev->hw,\n\t\t\t\t\t     &link->watchdog_work,\n\t\t\t\t\t     link->watchdog_interval);\n}\n\nvoid rt2x00link_register(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct link *link = &rt2x00dev->link;\n\n\tINIT_DELAYED_WORK(&link->work, rt2x00link_tuner);\n\tINIT_DELAYED_WORK(&link->watchdog_work, rt2x00link_watchdog);\n\n\tif (link->watchdog_interval == 0)\n\t\tlink->watchdog_interval = WATCHDOG_INTERVAL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}