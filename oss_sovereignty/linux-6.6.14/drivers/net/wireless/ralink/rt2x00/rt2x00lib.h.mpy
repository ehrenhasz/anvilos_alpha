{
  "module_name": "rt2x00lib.h",
  "hash_id": "c66693f9f52196e01a794169d526218d9f997c782a3b22a9894b1aacf3e44c48",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ralink/rt2x00/rt2x00lib.h",
  "human_readable_source": " \n \n\n \n\n#ifndef RT2X00LIB_H\n#define RT2X00LIB_H\n\n \n#define WATCHDOG_INTERVAL\tround_jiffies_relative(HZ)\n#define LINK_TUNE_SECONDS\t1\n#define LINK_TUNE_INTERVAL\tround_jiffies_relative(LINK_TUNE_SECONDS * HZ)\n#define AGC_SECONDS\t\t4\n#define VCO_SECONDS\t\t10\n\n \nstruct rt2x00_rate {\n\tunsigned short flags;\n#define DEV_RATE_CCK\t\t\t0x0001\n#define DEV_RATE_OFDM\t\t\t0x0002\n#define DEV_RATE_SHORT_PREAMBLE\t\t0x0004\n\n\tunsigned short bitrate;  \n\tunsigned short ratemask;\n\n\tunsigned short plcp;\n\tunsigned short mcs;\n};\n\nextern const struct rt2x00_rate rt2x00_supported_rates[12];\n\nstatic inline const struct rt2x00_rate *rt2x00_get_rate(const u16 hw_value)\n{\n\treturn &rt2x00_supported_rates[hw_value & 0xff];\n}\n\n#define RATE_MCS(__mode, __mcs) \\\n\t((((__mode) & 0x00ff) << 8) | ((__mcs) & 0x00ff))\n\nstatic inline int rt2x00_get_rate_mcs(const u16 mcs_value)\n{\n\treturn (mcs_value & 0x00ff);\n}\n\n \nint rt2x00lib_enable_radio(struct rt2x00_dev *rt2x00dev);\nvoid rt2x00lib_disable_radio(struct rt2x00_dev *rt2x00dev);\n\n \nint rt2x00lib_start(struct rt2x00_dev *rt2x00dev);\nvoid rt2x00lib_stop(struct rt2x00_dev *rt2x00dev);\n\n \nvoid rt2x00lib_config_intf(struct rt2x00_dev *rt2x00dev,\n\t\t\t   struct rt2x00_intf *intf,\n\t\t\t   enum nl80211_iftype type,\n\t\t\t   const u8 *mac, const u8 *bssid);\nvoid rt2x00lib_config_erp(struct rt2x00_dev *rt2x00dev,\n\t\t\t  struct rt2x00_intf *intf,\n\t\t\t  struct ieee80211_bss_conf *conf,\n\t\t\t  u32 changed);\nvoid rt2x00lib_config_antenna(struct rt2x00_dev *rt2x00dev,\n\t\t\t      struct antenna_setup ant);\nvoid rt2x00lib_config(struct rt2x00_dev *rt2x00dev,\n\t\t      struct ieee80211_conf *conf,\n\t\t      const unsigned int changed_flags);\n\n \n\n \nstruct sk_buff *rt2x00queue_alloc_rxskb(struct queue_entry *entry, gfp_t gfp);\n\n \nvoid rt2x00queue_free_skb(struct queue_entry *entry);\n\n \nvoid rt2x00queue_align_frame(struct sk_buff *skb);\n\n \nvoid rt2x00queue_insert_l2pad(struct sk_buff *skb, unsigned int header_length);\n\n \nvoid rt2x00queue_remove_l2pad(struct sk_buff *skb, unsigned int header_length);\n\n \nint rt2x00queue_write_tx_frame(struct data_queue *queue, struct sk_buff *skb,\n\t\t\t       struct ieee80211_sta *sta, bool local);\n\n \nint rt2x00queue_update_beacon(struct rt2x00_dev *rt2x00dev,\n\t\t\t      struct ieee80211_vif *vif);\n\n \nint rt2x00queue_update_beacon_locked(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t     struct ieee80211_vif *vif);\n\n \nint rt2x00queue_clear_beacon(struct rt2x00_dev *rt2x00dev,\n\t\t\t     struct ieee80211_vif *vif);\n\n \nvoid rt2x00queue_index_inc(struct queue_entry *entry, enum queue_index index);\n\n \nvoid rt2x00queue_init_queues(struct rt2x00_dev *rt2x00dev);\n\nint rt2x00queue_initialize(struct rt2x00_dev *rt2x00dev);\nvoid rt2x00queue_uninitialize(struct rt2x00_dev *rt2x00dev);\nint rt2x00queue_allocate(struct rt2x00_dev *rt2x00dev);\nvoid rt2x00queue_free(struct rt2x00_dev *rt2x00dev);\n\n \nvoid rt2x00link_update_stats(struct rt2x00_dev *rt2x00dev,\n\t\t\t     struct sk_buff *skb,\n\t\t\t     struct rxdone_entry_desc *rxdesc);\n\n \nvoid rt2x00link_start_tuner(struct rt2x00_dev *rt2x00dev);\n\n \nvoid rt2x00link_stop_tuner(struct rt2x00_dev *rt2x00dev);\n\n \nvoid rt2x00link_reset_tuner(struct rt2x00_dev *rt2x00dev, bool antenna);\n\n \nvoid rt2x00link_start_watchdog(struct rt2x00_dev *rt2x00dev);\n\n \nvoid rt2x00link_stop_watchdog(struct rt2x00_dev *rt2x00dev);\n\n \nvoid rt2x00link_register(struct rt2x00_dev *rt2x00dev);\n\n \n#ifdef CONFIG_RT2X00_LIB_FIRMWARE\nint rt2x00lib_load_firmware(struct rt2x00_dev *rt2x00dev);\nvoid rt2x00lib_free_firmware(struct rt2x00_dev *rt2x00dev);\n#else\nstatic inline int rt2x00lib_load_firmware(struct rt2x00_dev *rt2x00dev)\n{\n\treturn 0;\n}\nstatic inline void rt2x00lib_free_firmware(struct rt2x00_dev *rt2x00dev)\n{\n}\n#endif  \n\n \n#ifdef CONFIG_RT2X00_LIB_DEBUGFS\nvoid rt2x00debug_register(struct rt2x00_dev *rt2x00dev);\nvoid rt2x00debug_deregister(struct rt2x00_dev *rt2x00dev);\nvoid rt2x00debug_update_crypto(struct rt2x00_dev *rt2x00dev,\n\t\t\t       struct rxdone_entry_desc *rxdesc);\n#else\nstatic inline void rt2x00debug_register(struct rt2x00_dev *rt2x00dev)\n{\n}\n\nstatic inline void rt2x00debug_deregister(struct rt2x00_dev *rt2x00dev)\n{\n}\n\nstatic inline void rt2x00debug_update_crypto(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t     struct rxdone_entry_desc *rxdesc)\n{\n}\n#endif  \n\n \n#ifdef CONFIG_RT2X00_LIB_CRYPTO\nenum cipher rt2x00crypto_key_to_cipher(struct ieee80211_key_conf *key);\nvoid rt2x00crypto_create_tx_descriptor(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t       struct txentry_desc *txdesc);\nunsigned int rt2x00crypto_tx_overhead(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t      struct sk_buff *skb);\nvoid rt2x00crypto_tx_copy_iv(struct sk_buff *skb,\n\t\t\t     struct txentry_desc *txdesc);\nvoid rt2x00crypto_tx_remove_iv(struct sk_buff *skb,\n\t\t\t       struct txentry_desc *txdesc);\nvoid rt2x00crypto_tx_insert_iv(struct sk_buff *skb, unsigned int header_length);\nvoid rt2x00crypto_rx_insert_iv(struct sk_buff *skb,\n\t\t\t       unsigned int header_length,\n\t\t\t       struct rxdone_entry_desc *rxdesc);\n#else\nstatic inline enum cipher rt2x00crypto_key_to_cipher(struct ieee80211_key_conf *key)\n{\n\treturn CIPHER_NONE;\n}\n\nstatic inline void rt2x00crypto_create_tx_descriptor(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t\t\t     struct txentry_desc *txdesc)\n{\n}\n\nstatic inline unsigned int rt2x00crypto_tx_overhead(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t\t    struct sk_buff *skb)\n{\n\treturn 0;\n}\n\nstatic inline void rt2x00crypto_tx_copy_iv(struct sk_buff *skb,\n\t\t\t\t\t   struct txentry_desc *txdesc)\n{\n}\n\nstatic inline void rt2x00crypto_tx_remove_iv(struct sk_buff *skb,\n\t\t\t\t\t     struct txentry_desc *txdesc)\n{\n}\n\nstatic inline void rt2x00crypto_tx_insert_iv(struct sk_buff *skb,\n\t\t\t\t\t     unsigned int header_length)\n{\n}\n\nstatic inline void rt2x00crypto_rx_insert_iv(struct sk_buff *skb,\n\t\t\t\t\t     unsigned int header_length,\n\t\t\t\t\t     struct rxdone_entry_desc *rxdesc)\n{\n}\n#endif  \n\n \nstatic inline void rt2x00rfkill_register(struct rt2x00_dev *rt2x00dev)\n{\n\tif (test_bit(CAPABILITY_HW_BUTTON, &rt2x00dev->cap_flags))\n\t\twiphy_rfkill_start_polling(rt2x00dev->hw->wiphy);\n}\n\nstatic inline void rt2x00rfkill_unregister(struct rt2x00_dev *rt2x00dev)\n{\n\tif (test_bit(CAPABILITY_HW_BUTTON, &rt2x00dev->cap_flags))\n\t\twiphy_rfkill_stop_polling(rt2x00dev->hw->wiphy);\n}\n\n \n#ifdef CONFIG_RT2X00_LIB_LEDS\nvoid rt2x00leds_led_quality(struct rt2x00_dev *rt2x00dev, int rssi);\nvoid rt2x00led_led_activity(struct rt2x00_dev *rt2x00dev, bool enabled);\nvoid rt2x00leds_led_assoc(struct rt2x00_dev *rt2x00dev, bool enabled);\nvoid rt2x00leds_led_radio(struct rt2x00_dev *rt2x00dev, bool enabled);\nvoid rt2x00leds_register(struct rt2x00_dev *rt2x00dev);\nvoid rt2x00leds_unregister(struct rt2x00_dev *rt2x00dev);\nvoid rt2x00leds_suspend(struct rt2x00_dev *rt2x00dev);\nvoid rt2x00leds_resume(struct rt2x00_dev *rt2x00dev);\n#else\nstatic inline void rt2x00leds_led_quality(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t  int rssi)\n{\n}\n\nstatic inline void rt2x00led_led_activity(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t  bool enabled)\n{\n}\n\nstatic inline void rt2x00leds_led_assoc(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\tbool enabled)\n{\n}\n\nstatic inline void rt2x00leds_led_radio(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\tbool enabled)\n{\n}\n\nstatic inline void rt2x00leds_register(struct rt2x00_dev *rt2x00dev)\n{\n}\n\nstatic inline void rt2x00leds_unregister(struct rt2x00_dev *rt2x00dev)\n{\n}\n\nstatic inline void rt2x00leds_suspend(struct rt2x00_dev *rt2x00dev)\n{\n}\n\nstatic inline void rt2x00leds_resume(struct rt2x00_dev *rt2x00dev)\n{\n}\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}