{
  "module_name": "rt2x00usb.c",
  "hash_id": "d3d68accfeb3ed7abed4a1ff80c211c18a0d9d56796fe4aeebf1a2e3ba929785",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ralink/rt2x00/rt2x00usb.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/bug.h>\n\n#include \"rt2x00.h\"\n#include \"rt2x00usb.h\"\n\nstatic bool rt2x00usb_check_usb_error(struct rt2x00_dev *rt2x00dev, int status)\n{\n\tif (status == -ENODEV || status == -ENOENT)\n\t\treturn true;\n\n\tif (!test_bit(DEVICE_STATE_STARTED, &rt2x00dev->flags))\n\t\treturn false;\n\n\tif (status == -EPROTO || status == -ETIMEDOUT)\n\t\trt2x00dev->num_proto_errs++;\n\telse\n\t\trt2x00dev->num_proto_errs = 0;\n\n\tif (rt2x00dev->num_proto_errs > 3)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nint rt2x00usb_vendor_request(struct rt2x00_dev *rt2x00dev,\n\t\t\t     const u8 request, const u8 requesttype,\n\t\t\t     const u16 offset, const u16 value,\n\t\t\t     void *buffer, const u16 buffer_length,\n\t\t\t     const int timeout)\n{\n\tstruct usb_device *usb_dev = to_usb_device_intf(rt2x00dev->dev);\n\tint status;\n\tunsigned int pipe =\n\t    (requesttype == USB_VENDOR_REQUEST_IN) ?\n\t    usb_rcvctrlpipe(usb_dev, 0) : usb_sndctrlpipe(usb_dev, 0);\n\tunsigned long expire = jiffies + msecs_to_jiffies(timeout);\n\n\tif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\n\t\treturn -ENODEV;\n\n\tdo {\n\t\tstatus = usb_control_msg(usb_dev, pipe, request, requesttype,\n\t\t\t\t\t value, offset, buffer, buffer_length,\n\t\t\t\t\t timeout / 2);\n\t\tif (status >= 0)\n\t\t\treturn 0;\n\n\t\tif (rt2x00usb_check_usb_error(rt2x00dev, status)) {\n\t\t\t \n\t\t\tclear_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags);\n\t\t\tbreak;\n\t\t}\n\t} while (time_before(jiffies, expire));\n\n\trt2x00_err(rt2x00dev,\n\t\t   \"Vendor Request 0x%02x failed for offset 0x%04x with error %d\\n\",\n\t\t   request, offset, status);\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(rt2x00usb_vendor_request);\n\nint rt2x00usb_vendor_req_buff_lock(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t   const u8 request, const u8 requesttype,\n\t\t\t\t   const u16 offset, void *buffer,\n\t\t\t\t   const u16 buffer_length, const int timeout)\n{\n\tint status;\n\n\tBUG_ON(!mutex_is_locked(&rt2x00dev->csr_mutex));\n\n\t \n\tif (unlikely(!rt2x00dev->csr.cache || buffer_length > CSR_CACHE_SIZE)) {\n\t\trt2x00_err(rt2x00dev, \"CSR cache not available\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (requesttype == USB_VENDOR_REQUEST_OUT)\n\t\tmemcpy(rt2x00dev->csr.cache, buffer, buffer_length);\n\n\tstatus = rt2x00usb_vendor_request(rt2x00dev, request, requesttype,\n\t\t\t\t\t  offset, 0, rt2x00dev->csr.cache,\n\t\t\t\t\t  buffer_length, timeout);\n\n\tif (!status && requesttype == USB_VENDOR_REQUEST_IN)\n\t\tmemcpy(buffer, rt2x00dev->csr.cache, buffer_length);\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(rt2x00usb_vendor_req_buff_lock);\n\nint rt2x00usb_vendor_request_buff(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t  const u8 request, const u8 requesttype,\n\t\t\t\t  const u16 offset, void *buffer,\n\t\t\t\t  const u16 buffer_length)\n{\n\tint status = 0;\n\tu8 *tb;\n\tu16 off, len, bsize;\n\n\tmutex_lock(&rt2x00dev->csr_mutex);\n\n\ttb  = (u8 *)buffer;\n\toff = offset;\n\tlen = buffer_length;\n\twhile (len && !status) {\n\t\tbsize = min_t(u16, CSR_CACHE_SIZE, len);\n\t\tstatus = rt2x00usb_vendor_req_buff_lock(rt2x00dev, request,\n\t\t\t\t\t\t\trequesttype, off, tb,\n\t\t\t\t\t\t\tbsize, REGISTER_TIMEOUT);\n\n\t\ttb  += bsize;\n\t\tlen -= bsize;\n\t\toff += bsize;\n\t}\n\n\tmutex_unlock(&rt2x00dev->csr_mutex);\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(rt2x00usb_vendor_request_buff);\n\nint rt2x00usb_regbusy_read(struct rt2x00_dev *rt2x00dev,\n\t\t\t   const unsigned int offset,\n\t\t\t   const struct rt2x00_field32 field,\n\t\t\t   u32 *reg)\n{\n\tunsigned int i;\n\n\tif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < REGISTER_USB_BUSY_COUNT; i++) {\n\t\t*reg = rt2x00usb_register_read_lock(rt2x00dev, offset);\n\t\tif (!rt2x00_get_field32(*reg, field))\n\t\t\treturn 1;\n\t\tudelay(REGISTER_BUSY_DELAY);\n\t}\n\n\trt2x00_err(rt2x00dev, \"Indirect register access failed: offset=0x%.08x, value=0x%.08x\\n\",\n\t\t   offset, *reg);\n\t*reg = ~0;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rt2x00usb_regbusy_read);\n\n\nstruct rt2x00_async_read_data {\n\t__le32 reg;\n\tstruct usb_ctrlrequest cr;\n\tstruct rt2x00_dev *rt2x00dev;\n\tbool (*callback)(struct rt2x00_dev *, int, u32);\n};\n\nstatic void rt2x00usb_register_read_async_cb(struct urb *urb)\n{\n\tstruct rt2x00_async_read_data *rd = urb->context;\n\tif (rd->callback(rd->rt2x00dev, urb->status, le32_to_cpu(rd->reg))) {\n\t\tusb_anchor_urb(urb, rd->rt2x00dev->anchor);\n\t\tif (usb_submit_urb(urb, GFP_ATOMIC) < 0) {\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tkfree(rd);\n\t\t}\n\t} else\n\t\tkfree(rd);\n}\n\nvoid rt2x00usb_register_read_async(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t   const unsigned int offset,\n\t\t\t\t   bool (*callback)(struct rt2x00_dev*, int, u32))\n{\n\tstruct usb_device *usb_dev = to_usb_device_intf(rt2x00dev->dev);\n\tstruct urb *urb;\n\tstruct rt2x00_async_read_data *rd;\n\n\trd = kmalloc(sizeof(*rd), GFP_ATOMIC);\n\tif (!rd)\n\t\treturn;\n\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb) {\n\t\tkfree(rd);\n\t\treturn;\n\t}\n\n\trd->rt2x00dev = rt2x00dev;\n\trd->callback = callback;\n\trd->cr.bRequestType = USB_VENDOR_REQUEST_IN;\n\trd->cr.bRequest = USB_MULTI_READ;\n\trd->cr.wValue = 0;\n\trd->cr.wIndex = cpu_to_le16(offset);\n\trd->cr.wLength = cpu_to_le16(sizeof(u32));\n\n\tusb_fill_control_urb(urb, usb_dev, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t     (u8 *)(&rd->cr), &rd->reg, sizeof(rd->reg),\n\t\t\t     rt2x00usb_register_read_async_cb, rd);\n\tusb_anchor_urb(urb, rt2x00dev->anchor);\n\tif (usb_submit_urb(urb, GFP_ATOMIC) < 0) {\n\t\tusb_unanchor_urb(urb);\n\t\tkfree(rd);\n\t}\n\tusb_free_urb(urb);\n}\nEXPORT_SYMBOL_GPL(rt2x00usb_register_read_async);\n\n \nstatic void rt2x00usb_work_txdone_entry(struct queue_entry *entry)\n{\n\t \n\tif (test_bit(ENTRY_DATA_IO_FAILED, &entry->flags))\n\t\trt2x00lib_txdone_noinfo(entry, TXDONE_FAILURE);\n\telse\n\t\trt2x00lib_txdone_noinfo(entry, TXDONE_UNKNOWN);\n}\n\nstatic void rt2x00usb_work_txdone(struct work_struct *work)\n{\n\tstruct rt2x00_dev *rt2x00dev =\n\t    container_of(work, struct rt2x00_dev, txdone_work);\n\tstruct data_queue *queue;\n\tstruct queue_entry *entry;\n\n\ttx_queue_for_each(rt2x00dev, queue) {\n\t\twhile (!rt2x00queue_empty(queue)) {\n\t\t\tentry = rt2x00queue_get_entry(queue, Q_INDEX_DONE);\n\n\t\t\tif (test_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags) ||\n\t\t\t    !test_bit(ENTRY_DATA_STATUS_PENDING, &entry->flags))\n\t\t\t\tbreak;\n\n\t\t\trt2x00usb_work_txdone_entry(entry);\n\t\t}\n\t}\n}\n\nstatic void rt2x00usb_interrupt_txdone(struct urb *urb)\n{\n\tstruct queue_entry *entry = (struct queue_entry *)urb->context;\n\tstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\n\n\tif (!test_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags))\n\t\treturn;\n\t \n\tif (urb->status)\n\t\tset_bit(ENTRY_DATA_IO_FAILED, &entry->flags);\n\t \n\trt2x00lib_dmadone(entry);\n\n\tif (rt2x00dev->ops->lib->tx_dma_done)\n\t\trt2x00dev->ops->lib->tx_dma_done(entry);\n\t \n\tif (!rt2x00_has_cap_flag(rt2x00dev, REQUIRE_TXSTATUS_FIFO) ||\n\t    !kfifo_is_empty(&rt2x00dev->txstatus_fifo))\n\t\tqueue_work(rt2x00dev->workqueue, &rt2x00dev->txdone_work);\n}\n\nstatic bool rt2x00usb_kick_tx_entry(struct queue_entry *entry, void *data)\n{\n\tstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\n\tstruct usb_device *usb_dev = to_usb_device_intf(rt2x00dev->dev);\n\tstruct queue_entry_priv_usb *entry_priv = entry->priv_data;\n\tu32 length;\n\tint status;\n\n\tif (!test_and_clear_bit(ENTRY_DATA_PENDING, &entry->flags) ||\n\t    test_bit(ENTRY_DATA_STATUS_PENDING, &entry->flags))\n\t\treturn false;\n\n\t \n\tlength = rt2x00dev->ops->lib->get_tx_data_len(entry);\n\n\tstatus = skb_padto(entry->skb, length);\n\tif (unlikely(status)) {\n\t\t \n\t\trt2x00_warn(rt2x00dev, \"TX SKB padding error, out of memory\\n\");\n\t\tset_bit(ENTRY_DATA_IO_FAILED, &entry->flags);\n\t\trt2x00lib_dmadone(entry);\n\n\t\treturn false;\n\t}\n\n\tusb_fill_bulk_urb(entry_priv->urb, usb_dev,\n\t\t\t  usb_sndbulkpipe(usb_dev, entry->queue->usb_endpoint),\n\t\t\t  entry->skb->data, length,\n\t\t\t  rt2x00usb_interrupt_txdone, entry);\n\n\tstatus = usb_submit_urb(entry_priv->urb, GFP_ATOMIC);\n\tif (status) {\n\t\tif (rt2x00usb_check_usb_error(rt2x00dev, status))\n\t\t\tclear_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags);\n\t\tset_bit(ENTRY_DATA_IO_FAILED, &entry->flags);\n\t\trt2x00lib_dmadone(entry);\n\t}\n\n\treturn false;\n}\n\n \nstatic void rt2x00usb_work_rxdone(struct work_struct *work)\n{\n\tstruct rt2x00_dev *rt2x00dev =\n\t    container_of(work, struct rt2x00_dev, rxdone_work);\n\tstruct queue_entry *entry;\n\tstruct skb_frame_desc *skbdesc;\n\tu8 rxd[32];\n\n\twhile (!rt2x00queue_empty(rt2x00dev->rx)) {\n\t\tentry = rt2x00queue_get_entry(rt2x00dev->rx, Q_INDEX_DONE);\n\n\t\tif (test_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags))\n\t\t\tbreak;\n\n\t\t \n\t\tskbdesc = get_skb_frame_desc(entry->skb);\n\t\tskbdesc->desc = rxd;\n\t\tskbdesc->desc_len = entry->queue->desc_size;\n\n\t\t \n\t\trt2x00lib_rxdone(entry, GFP_KERNEL);\n\t}\n}\n\nstatic void rt2x00usb_interrupt_rxdone(struct urb *urb)\n{\n\tstruct queue_entry *entry = (struct queue_entry *)urb->context;\n\tstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\n\n\tif (!test_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags))\n\t\treturn;\n\n\t \n\tif (urb->actual_length < entry->queue->desc_size || urb->status)\n\t\tset_bit(ENTRY_DATA_IO_FAILED, &entry->flags);\n\n\t \n\trt2x00lib_dmadone(entry);\n\n\t \n\tqueue_work(rt2x00dev->workqueue, &rt2x00dev->rxdone_work);\n}\n\nstatic bool rt2x00usb_kick_rx_entry(struct queue_entry *entry, void *data)\n{\n\tstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\n\tstruct usb_device *usb_dev = to_usb_device_intf(rt2x00dev->dev);\n\tstruct queue_entry_priv_usb *entry_priv = entry->priv_data;\n\tint status;\n\n\tif (test_and_set_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags))\n\t\treturn false;\n\n\trt2x00lib_dmastart(entry);\n\n\tusb_fill_bulk_urb(entry_priv->urb, usb_dev,\n\t\t\t  usb_rcvbulkpipe(usb_dev, entry->queue->usb_endpoint),\n\t\t\t  entry->skb->data, entry->skb->len,\n\t\t\t  rt2x00usb_interrupt_rxdone, entry);\n\n\tstatus = usb_submit_urb(entry_priv->urb, GFP_ATOMIC);\n\tif (status) {\n\t\tif (rt2x00usb_check_usb_error(rt2x00dev, status))\n\t\t\tclear_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags);\n\t\tset_bit(ENTRY_DATA_IO_FAILED, &entry->flags);\n\t\trt2x00lib_dmadone(entry);\n\t}\n\n\treturn false;\n}\n\nvoid rt2x00usb_kick_queue(struct data_queue *queue)\n{\n\tswitch (queue->qid) {\n\tcase QID_AC_VO:\n\tcase QID_AC_VI:\n\tcase QID_AC_BE:\n\tcase QID_AC_BK:\n\t\tif (!rt2x00queue_empty(queue))\n\t\t\trt2x00queue_for_each_entry(queue,\n\t\t\t\t\t\t   Q_INDEX_DONE,\n\t\t\t\t\t\t   Q_INDEX,\n\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t   rt2x00usb_kick_tx_entry);\n\t\tbreak;\n\tcase QID_RX:\n\t\tif (!rt2x00queue_full(queue))\n\t\t\trt2x00queue_for_each_entry(queue,\n\t\t\t\t\t\t   Q_INDEX,\n\t\t\t\t\t\t   Q_INDEX_DONE,\n\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t   rt2x00usb_kick_rx_entry);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(rt2x00usb_kick_queue);\n\nstatic bool rt2x00usb_flush_entry(struct queue_entry *entry, void *data)\n{\n\tstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\n\tstruct queue_entry_priv_usb *entry_priv = entry->priv_data;\n\tstruct queue_entry_priv_usb_bcn *bcn_priv = entry->priv_data;\n\n\tif (!test_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags))\n\t\treturn false;\n\n\tusb_kill_urb(entry_priv->urb);\n\n\t \n\tif ((entry->queue->qid == QID_BEACON) &&\n\t    (rt2x00_has_cap_flag(rt2x00dev, REQUIRE_BEACON_GUARD)))\n\t\tusb_kill_urb(bcn_priv->guardian_urb);\n\n\treturn false;\n}\n\nvoid rt2x00usb_flush_queue(struct data_queue *queue, bool drop)\n{\n\tstruct work_struct *completion;\n\tunsigned int i;\n\n\tif (drop)\n\t\trt2x00queue_for_each_entry(queue, Q_INDEX_DONE, Q_INDEX, NULL,\n\t\t\t\t\t   rt2x00usb_flush_entry);\n\n\t \n\tswitch (queue->qid) {\n\tcase QID_AC_VO:\n\tcase QID_AC_VI:\n\tcase QID_AC_BE:\n\tcase QID_AC_BK:\n\t\tcompletion = &queue->rt2x00dev->txdone_work;\n\t\tbreak;\n\tcase QID_RX:\n\t\tcompletion = &queue->rt2x00dev->rxdone_work;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 10; i++) {\n\t\t \n\t\tif (rt2x00queue_empty(queue))\n\t\t\tbreak;\n\n\t\t \n\t\tqueue_work(queue->rt2x00dev->workqueue, completion);\n\n\t\t \n\t\tmsleep(50);\n\t}\n}\nEXPORT_SYMBOL_GPL(rt2x00usb_flush_queue);\n\nstatic void rt2x00usb_watchdog_tx_dma(struct data_queue *queue)\n{\n\trt2x00_warn(queue->rt2x00dev, \"TX queue %d DMA timed out, invoke forced reset\\n\",\n\t\t    queue->qid);\n\n\trt2x00queue_stop_queue(queue);\n\trt2x00queue_flush_queue(queue, true);\n\trt2x00queue_start_queue(queue);\n}\n\nstatic int rt2x00usb_dma_timeout(struct data_queue *queue)\n{\n\tstruct queue_entry *entry;\n\n\tentry = rt2x00queue_get_entry(queue, Q_INDEX_DMA_DONE);\n\treturn rt2x00queue_dma_timeout(entry);\n}\n\nvoid rt2x00usb_watchdog(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct data_queue *queue;\n\n\ttx_queue_for_each(rt2x00dev, queue) {\n\t\tif (!rt2x00queue_empty(queue)) {\n\t\t\tif (rt2x00usb_dma_timeout(queue))\n\t\t\t\trt2x00usb_watchdog_tx_dma(queue);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(rt2x00usb_watchdog);\n\n \nvoid rt2x00usb_disable_radio(struct rt2x00_dev *rt2x00dev)\n{\n\trt2x00usb_vendor_request_sw(rt2x00dev, USB_RX_CONTROL, 0, 0,\n\t\t\t\t    REGISTER_TIMEOUT);\n}\nEXPORT_SYMBOL_GPL(rt2x00usb_disable_radio);\n\n \nvoid rt2x00usb_clear_entry(struct queue_entry *entry)\n{\n\tentry->flags = 0;\n\n\tif (entry->queue->qid == QID_RX)\n\t\trt2x00usb_kick_rx_entry(entry, NULL);\n}\nEXPORT_SYMBOL_GPL(rt2x00usb_clear_entry);\n\nstatic void rt2x00usb_assign_endpoint(struct data_queue *queue,\n\t\t\t\t      struct usb_endpoint_descriptor *ep_desc)\n{\n\tstruct usb_device *usb_dev = to_usb_device_intf(queue->rt2x00dev->dev);\n\tint pipe;\n\n\tqueue->usb_endpoint = usb_endpoint_num(ep_desc);\n\n\tif (queue->qid == QID_RX) {\n\t\tpipe = usb_rcvbulkpipe(usb_dev, queue->usb_endpoint);\n\t\tqueue->usb_maxpacket = usb_maxpacket(usb_dev, pipe);\n\t} else {\n\t\tpipe = usb_sndbulkpipe(usb_dev, queue->usb_endpoint);\n\t\tqueue->usb_maxpacket = usb_maxpacket(usb_dev, pipe);\n\t}\n\n\tif (!queue->usb_maxpacket)\n\t\tqueue->usb_maxpacket = 1;\n}\n\nstatic int rt2x00usb_find_endpoints(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct usb_interface *intf = to_usb_interface(rt2x00dev->dev);\n\tstruct usb_host_interface *intf_desc = intf->cur_altsetting;\n\tstruct usb_endpoint_descriptor *ep_desc;\n\tstruct data_queue *queue = rt2x00dev->tx;\n\tstruct usb_endpoint_descriptor *tx_ep_desc = NULL;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < intf_desc->desc.bNumEndpoints; i++) {\n\t\tep_desc = &intf_desc->endpoint[i].desc;\n\n\t\tif (usb_endpoint_is_bulk_in(ep_desc)) {\n\t\t\trt2x00usb_assign_endpoint(rt2x00dev->rx, ep_desc);\n\t\t} else if (usb_endpoint_is_bulk_out(ep_desc) &&\n\t\t\t   (queue != queue_end(rt2x00dev))) {\n\t\t\trt2x00usb_assign_endpoint(queue, ep_desc);\n\t\t\tqueue = queue_next(queue);\n\n\t\t\ttx_ep_desc = ep_desc;\n\t\t}\n\t}\n\n\t \n\tif (!rt2x00dev->rx->usb_endpoint || !rt2x00dev->tx->usb_endpoint) {\n\t\trt2x00_err(rt2x00dev, \"Bulk-in/Bulk-out endpoints not found\\n\");\n\t\treturn -EPIPE;\n\t}\n\n\t \n\ttxall_queue_for_each(rt2x00dev, queue) {\n\t\tif (!queue->usb_endpoint)\n\t\t\trt2x00usb_assign_endpoint(queue, tx_ep_desc);\n\t}\n\n\treturn 0;\n}\n\nstatic int rt2x00usb_alloc_entries(struct data_queue *queue)\n{\n\tstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\n\tstruct queue_entry_priv_usb *entry_priv;\n\tstruct queue_entry_priv_usb_bcn *bcn_priv;\n\tunsigned int i;\n\n\tfor (i = 0; i < queue->limit; i++) {\n\t\tentry_priv = queue->entries[i].priv_data;\n\t\tentry_priv->urb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!entry_priv->urb)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (queue->qid != QID_BEACON ||\n\t    !rt2x00_has_cap_flag(rt2x00dev, REQUIRE_BEACON_GUARD))\n\t\treturn 0;\n\n\tfor (i = 0; i < queue->limit; i++) {\n\t\tbcn_priv = queue->entries[i].priv_data;\n\t\tbcn_priv->guardian_urb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!bcn_priv->guardian_urb)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void rt2x00usb_free_entries(struct data_queue *queue)\n{\n\tstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\n\tstruct queue_entry_priv_usb *entry_priv;\n\tstruct queue_entry_priv_usb_bcn *bcn_priv;\n\tunsigned int i;\n\n\tif (!queue->entries)\n\t\treturn;\n\n\tfor (i = 0; i < queue->limit; i++) {\n\t\tentry_priv = queue->entries[i].priv_data;\n\t\tusb_kill_urb(entry_priv->urb);\n\t\tusb_free_urb(entry_priv->urb);\n\t}\n\n\t \n\tif (queue->qid != QID_BEACON ||\n\t    !rt2x00_has_cap_flag(rt2x00dev, REQUIRE_BEACON_GUARD))\n\t\treturn;\n\n\tfor (i = 0; i < queue->limit; i++) {\n\t\tbcn_priv = queue->entries[i].priv_data;\n\t\tusb_kill_urb(bcn_priv->guardian_urb);\n\t\tusb_free_urb(bcn_priv->guardian_urb);\n\t}\n}\n\nint rt2x00usb_initialize(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct data_queue *queue;\n\tint status;\n\n\t \n\tstatus = rt2x00usb_find_endpoints(rt2x00dev);\n\tif (status)\n\t\tgoto exit;\n\n\t \n\tqueue_for_each(rt2x00dev, queue) {\n\t\tstatus = rt2x00usb_alloc_entries(queue);\n\t\tif (status)\n\t\t\tgoto exit;\n\t}\n\n\treturn 0;\n\nexit:\n\trt2x00usb_uninitialize(rt2x00dev);\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(rt2x00usb_initialize);\n\nvoid rt2x00usb_uninitialize(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct data_queue *queue;\n\n\tusb_kill_anchored_urbs(rt2x00dev->anchor);\n\thrtimer_cancel(&rt2x00dev->txstatus_timer);\n\tcancel_work_sync(&rt2x00dev->rxdone_work);\n\tcancel_work_sync(&rt2x00dev->txdone_work);\n\n\tqueue_for_each(rt2x00dev, queue)\n\t\trt2x00usb_free_entries(queue);\n}\nEXPORT_SYMBOL_GPL(rt2x00usb_uninitialize);\n\n \nstatic void rt2x00usb_free_reg(struct rt2x00_dev *rt2x00dev)\n{\n\tkfree(rt2x00dev->rf);\n\trt2x00dev->rf = NULL;\n\n\tkfree(rt2x00dev->eeprom);\n\trt2x00dev->eeprom = NULL;\n\n\tkfree(rt2x00dev->csr.cache);\n\trt2x00dev->csr.cache = NULL;\n}\n\nstatic int rt2x00usb_alloc_reg(struct rt2x00_dev *rt2x00dev)\n{\n\trt2x00dev->csr.cache = kzalloc(CSR_CACHE_SIZE, GFP_KERNEL);\n\tif (!rt2x00dev->csr.cache)\n\t\tgoto exit;\n\n\trt2x00dev->eeprom = kzalloc(rt2x00dev->ops->eeprom_size, GFP_KERNEL);\n\tif (!rt2x00dev->eeprom)\n\t\tgoto exit;\n\n\trt2x00dev->rf = kzalloc(rt2x00dev->ops->rf_size, GFP_KERNEL);\n\tif (!rt2x00dev->rf)\n\t\tgoto exit;\n\n\treturn 0;\n\nexit:\n\trt2x00_probe_err(\"Failed to allocate registers\\n\");\n\n\trt2x00usb_free_reg(rt2x00dev);\n\n\treturn -ENOMEM;\n}\n\nint rt2x00usb_probe(struct usb_interface *usb_intf,\n\t\t    const struct rt2x00_ops *ops)\n{\n\tstruct usb_device *usb_dev = interface_to_usbdev(usb_intf);\n\tstruct ieee80211_hw *hw;\n\tstruct rt2x00_dev *rt2x00dev;\n\tint retval;\n\n\tusb_dev = usb_get_dev(usb_dev);\n\tusb_reset_device(usb_dev);\n\n\thw = ieee80211_alloc_hw(sizeof(struct rt2x00_dev), ops->hw);\n\tif (!hw) {\n\t\trt2x00_probe_err(\"Failed to allocate hardware\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto exit_put_device;\n\t}\n\n\tusb_set_intfdata(usb_intf, hw);\n\n\trt2x00dev = hw->priv;\n\trt2x00dev->dev = &usb_intf->dev;\n\trt2x00dev->ops = ops;\n\trt2x00dev->hw = hw;\n\n\trt2x00_set_chip_intf(rt2x00dev, RT2X00_CHIP_INTF_USB);\n\n\tINIT_WORK(&rt2x00dev->rxdone_work, rt2x00usb_work_rxdone);\n\tINIT_WORK(&rt2x00dev->txdone_work, rt2x00usb_work_txdone);\n\thrtimer_init(&rt2x00dev->txstatus_timer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_REL);\n\n\tretval = rt2x00usb_alloc_reg(rt2x00dev);\n\tif (retval)\n\t\tgoto exit_free_device;\n\n\trt2x00dev->anchor = devm_kmalloc(&usb_dev->dev,\n\t\t\t\t\tsizeof(struct usb_anchor),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!rt2x00dev->anchor) {\n\t\tretval = -ENOMEM;\n\t\tgoto exit_free_reg;\n\t}\n\tinit_usb_anchor(rt2x00dev->anchor);\n\n\tretval = rt2x00lib_probe_dev(rt2x00dev);\n\tif (retval)\n\t\tgoto exit_free_anchor;\n\n\treturn 0;\n\nexit_free_anchor:\n\tusb_kill_anchored_urbs(rt2x00dev->anchor);\n\nexit_free_reg:\n\trt2x00usb_free_reg(rt2x00dev);\n\nexit_free_device:\n\tieee80211_free_hw(hw);\n\nexit_put_device:\n\tusb_put_dev(usb_dev);\n\n\tusb_set_intfdata(usb_intf, NULL);\n\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(rt2x00usb_probe);\n\nvoid rt2x00usb_disconnect(struct usb_interface *usb_intf)\n{\n\tstruct ieee80211_hw *hw = usb_get_intfdata(usb_intf);\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\n\t \n\trt2x00lib_remove_dev(rt2x00dev);\n\trt2x00usb_free_reg(rt2x00dev);\n\tieee80211_free_hw(hw);\n\n\t \n\tusb_set_intfdata(usb_intf, NULL);\n\tusb_put_dev(interface_to_usbdev(usb_intf));\n}\nEXPORT_SYMBOL_GPL(rt2x00usb_disconnect);\n\n#ifdef CONFIG_PM\nint rt2x00usb_suspend(struct usb_interface *usb_intf, pm_message_t state)\n{\n\tstruct ieee80211_hw *hw = usb_get_intfdata(usb_intf);\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\n\treturn rt2x00lib_suspend(rt2x00dev);\n}\nEXPORT_SYMBOL_GPL(rt2x00usb_suspend);\n\nint rt2x00usb_resume(struct usb_interface *usb_intf)\n{\n\tstruct ieee80211_hw *hw = usb_get_intfdata(usb_intf);\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\n\treturn rt2x00lib_resume(rt2x00dev);\n}\nEXPORT_SYMBOL_GPL(rt2x00usb_resume);\n#endif  \n\n \nMODULE_AUTHOR(DRV_PROJECT);\nMODULE_VERSION(DRV_VERSION);\nMODULE_DESCRIPTION(\"rt2x00 usb library\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}