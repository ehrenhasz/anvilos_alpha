{
  "module_name": "rt2x00soc.c",
  "hash_id": "967cf396694ee979b507f2d2abb78e4e955a8daffa24e0b8172489570810cae4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/bug.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"rt2x00.h\"\n#include \"rt2x00soc.h\"\n\nstatic void rt2x00soc_free_reg(struct rt2x00_dev *rt2x00dev)\n{\n\tkfree(rt2x00dev->rf);\n\trt2x00dev->rf = NULL;\n\n\tkfree(rt2x00dev->eeprom);\n\trt2x00dev->eeprom = NULL;\n\n\tiounmap(rt2x00dev->csr.base);\n}\n\nstatic int rt2x00soc_alloc_reg(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct platform_device *pdev = to_platform_device(rt2x00dev->dev);\n\tstruct resource *res;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENODEV;\n\n\trt2x00dev->csr.base = ioremap(res->start, resource_size(res));\n\tif (!rt2x00dev->csr.base)\n\t\treturn -ENOMEM;\n\n\trt2x00dev->eeprom = kzalloc(rt2x00dev->ops->eeprom_size, GFP_KERNEL);\n\tif (!rt2x00dev->eeprom)\n\t\tgoto exit;\n\n\trt2x00dev->rf = kzalloc(rt2x00dev->ops->rf_size, GFP_KERNEL);\n\tif (!rt2x00dev->rf)\n\t\tgoto exit;\n\n\treturn 0;\n\nexit:\n\trt2x00_probe_err(\"Failed to allocate registers\\n\");\n\trt2x00soc_free_reg(rt2x00dev);\n\n\treturn -ENOMEM;\n}\n\nint rt2x00soc_probe(struct platform_device *pdev, const struct rt2x00_ops *ops)\n{\n\tstruct ieee80211_hw *hw;\n\tstruct rt2x00_dev *rt2x00dev;\n\tint retval;\n\n\thw = ieee80211_alloc_hw(sizeof(struct rt2x00_dev), ops->hw);\n\tif (!hw) {\n\t\trt2x00_probe_err(\"Failed to allocate hardware\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tplatform_set_drvdata(pdev, hw);\n\n\trt2x00dev = hw->priv;\n\trt2x00dev->dev = &pdev->dev;\n\trt2x00dev->ops = ops;\n\trt2x00dev->hw = hw;\n\trt2x00dev->irq = platform_get_irq(pdev, 0);\n\trt2x00dev->name = pdev->dev.driver->name;\n\n\trt2x00dev->clk = clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(rt2x00dev->clk))\n\t\trt2x00dev->clk = NULL;\n\n\trt2x00_set_chip_intf(rt2x00dev, RT2X00_CHIP_INTF_SOC);\n\n\tretval = rt2x00soc_alloc_reg(rt2x00dev);\n\tif (retval)\n\t\tgoto exit_free_device;\n\n\tretval = rt2x00lib_probe_dev(rt2x00dev);\n\tif (retval)\n\t\tgoto exit_free_reg;\n\n\treturn 0;\n\nexit_free_reg:\n\trt2x00soc_free_reg(rt2x00dev);\n\nexit_free_device:\n\tieee80211_free_hw(hw);\n\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(rt2x00soc_probe);\n\nint rt2x00soc_remove(struct platform_device *pdev)\n{\n\tstruct ieee80211_hw *hw = platform_get_drvdata(pdev);\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\n\t \n\trt2x00lib_remove_dev(rt2x00dev);\n\trt2x00soc_free_reg(rt2x00dev);\n\tieee80211_free_hw(hw);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rt2x00soc_remove);\n\n#ifdef CONFIG_PM\nint rt2x00soc_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\tstruct ieee80211_hw *hw = platform_get_drvdata(pdev);\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\n\treturn rt2x00lib_suspend(rt2x00dev);\n}\nEXPORT_SYMBOL_GPL(rt2x00soc_suspend);\n\nint rt2x00soc_resume(struct platform_device *pdev)\n{\n\tstruct ieee80211_hw *hw = platform_get_drvdata(pdev);\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\n\treturn rt2x00lib_resume(rt2x00dev);\n}\nEXPORT_SYMBOL_GPL(rt2x00soc_resume);\n#endif  \n\n \nMODULE_AUTHOR(DRV_PROJECT);\nMODULE_VERSION(DRV_VERSION);\nMODULE_DESCRIPTION(\"rt2x00 soc library\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}