{
  "module_name": "rt2x00.h",
  "hash_id": "a7209121d203efda37973ba3632e533bf40f46a1796056dc8b41f337f762f1c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ralink/rt2x00/rt2x00.h",
  "human_readable_source": " \n \n\n \n\n#ifndef RT2X00_H\n#define RT2X00_H\n\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/skbuff.h>\n#include <linux/workqueue.h>\n#include <linux/firmware.h>\n#include <linux/leds.h>\n#include <linux/mutex.h>\n#include <linux/etherdevice.h>\n#include <linux/kfifo.h>\n#include <linux/hrtimer.h>\n#include <linux/average.h>\n#include <linux/usb.h>\n#include <linux/clk.h>\n\n#include <net/mac80211.h>\n\n#include \"rt2x00debug.h\"\n#include \"rt2x00dump.h\"\n#include \"rt2x00leds.h\"\n#include \"rt2x00reg.h\"\n#include \"rt2x00queue.h\"\n\n \n#define DRV_VERSION\t\"2.3.0\"\n#define DRV_PROJECT\t\"http://rt2x00.serialmonkey.com\"\n\n \n#ifdef CONFIG_RT2X00_DEBUG\n#define DEBUG\n#endif  \n\n \n#define rt2x00_probe_err(fmt, ...)\t\t\t\t\t\\\n\tprintk(KERN_ERR KBUILD_MODNAME \": %s: Error - \" fmt,\t\t\\\n\t       __func__, ##__VA_ARGS__)\n#define rt2x00_err(dev, fmt, ...)\t\t\t\t\t\\\n\twiphy_err_ratelimited((dev)->hw->wiphy, \"%s: Error - \" fmt,\t\\\n\t\t  __func__, ##__VA_ARGS__)\n#define rt2x00_warn(dev, fmt, ...)\t\t\t\t\t\\\n\twiphy_warn_ratelimited((dev)->hw->wiphy, \"%s: Warning - \" fmt,\t\\\n\t\t   __func__, ##__VA_ARGS__)\n#define rt2x00_info(dev, fmt, ...)\t\t\t\t\t\\\n\twiphy_info((dev)->hw->wiphy, \"%s: Info - \" fmt,\t\t\t\\\n\t\t   __func__, ##__VA_ARGS__)\n\n \n#define rt2x00_dbg(dev, fmt, ...)\t\t\t\t\t\\\n\twiphy_dbg((dev)->hw->wiphy, \"%s: Debug - \" fmt,\t\t\t\\\n\t\t  __func__, ##__VA_ARGS__)\n#define rt2x00_eeprom_dbg(dev, fmt, ...)\t\t\t\t\\\n\twiphy_dbg((dev)->hw->wiphy, \"%s: EEPROM recovery - \" fmt,\t\\\n\t\t  __func__, ##__VA_ARGS__)\n\n \n#define GET_DURATION(__size, __rate)\t(((__size) * 8 * 10) / (__rate))\n#define GET_DURATION_RES(__size, __rate)(((__size) * 8 * 10) % (__rate))\n\n \n#define L2PAD_SIZE(__hdrlen)\t(-(__hdrlen) & 3)\n\n \n#define ALIGN_SIZE(__skb, __header) \\\n\t(((unsigned long)((__skb)->data + (__header))) & 3)\n\n \n#define RT2X00_ALIGN_SIZE\t4  \n#define RT2X00_L2PAD_SIZE\t8  \n\n \n#define ACK_SIZE\t\t14\n#define IEEE80211_HEADER\t24\n#define PLCP\t\t\t48\n#define BEACON\t\t\t100\n#define PREAMBLE\t\t144\n#define SHORT_PREAMBLE\t\t72\n#define SLOT_TIME\t\t20\n#define SHORT_SLOT_TIME\t\t9\n#define SIFS\t\t\t10\n#define PIFS\t\t\t(SIFS + SLOT_TIME)\n#define SHORT_PIFS\t\t(SIFS + SHORT_SLOT_TIME)\n#define DIFS\t\t\t(PIFS + SLOT_TIME)\n#define SHORT_DIFS\t\t(SHORT_PIFS + SHORT_SLOT_TIME)\n#define EIFS\t\t\t(SIFS + DIFS + \\\n\t\t\t\t  GET_DURATION(IEEE80211_HEADER + ACK_SIZE, 10))\n#define SHORT_EIFS\t\t(SIFS + SHORT_DIFS + \\\n\t\t\t\t  GET_DURATION(IEEE80211_HEADER + ACK_SIZE, 10))\n\nenum rt2x00_chip_intf {\n\tRT2X00_CHIP_INTF_PCI,\n\tRT2X00_CHIP_INTF_PCIE,\n\tRT2X00_CHIP_INTF_USB,\n\tRT2X00_CHIP_INTF_SOC,\n};\n\n \nstruct rt2x00_chip {\n\tu16 rt;\n#define RT2460\t\t0x2460\n#define RT2560\t\t0x2560\n#define RT2570\t\t0x2570\n#define RT2661\t\t0x2661\n#define RT2573\t\t0x2573\n#define RT2860\t\t0x2860\t \n#define RT2872\t\t0x2872\t \n#define RT2883\t\t0x2883\t \n#define RT3070\t\t0x3070\n#define RT3071\t\t0x3071\n#define RT3090\t\t0x3090\t \n#define RT3290\t\t0x3290\n#define RT3352\t\t0x3352   \n#define RT3390\t\t0x3390\n#define RT3572\t\t0x3572\n#define RT3593\t\t0x3593\n#define RT3883\t\t0x3883\t \n#define RT5350\t\t0x5350   \n#define RT5390\t\t0x5390   \n#define RT5392\t\t0x5392   \n#define RT5592\t\t0x5592\n#define RT6352\t\t0x6352   \n\n\tu16 rf;\n\tu16 rev;\n\n\tenum rt2x00_chip_intf intf;\n};\n\n \nstruct rf_channel {\n\tint channel;\n\tu32 rf1;\n\tu32 rf2;\n\tu32 rf3;\n\tu32 rf4;\n};\n\n \nstruct rt2x00_chan_survey {\n\tu64 time_idle;\n\tu64 time_busy;\n\tu64 time_ext_busy;\n};\n\n \nstruct channel_info {\n\tunsigned int flags;\n#define GEOGRAPHY_ALLOWED\t0x00000001\n\n\tshort max_power;\n\tshort default_power1;\n\tshort default_power2;\n\tshort default_power3;\n};\n\n \nstruct antenna_setup {\n\tenum antenna rx;\n\tenum antenna tx;\n\tu8 rx_chain_num;\n\tu8 tx_chain_num;\n};\n\n \nstruct link_qual {\n\t \n\tint rssi;\n\tint false_cca;\n\n\t \n\tu8 vgc_level;\n\tu8 vgc_level_reg;\n\n\t \n\tint rx_success;\n\tint rx_failed;\n\tint tx_success;\n\tint tx_failed;\n};\n\nDECLARE_EWMA(rssi, 10, 8)\n\n \nstruct link_ant {\n\t \n\tunsigned int flags;\n#define ANTENNA_RX_DIVERSITY\t0x00000001\n#define ANTENNA_TX_DIVERSITY\t0x00000002\n#define ANTENNA_MODE_SAMPLE\t0x00000004\n\n\t \n\tstruct antenna_setup active;\n\n\t \n\tint rssi_history;\n\n\t \n\tstruct ewma_rssi rssi_ant;\n};\n\n \nstruct link {\n\t \n\tu32 count;\n\n\t \n\tstruct link_qual qual;\n\n\t \n\tstruct link_ant ant;\n\n\t \n\tstruct ewma_rssi avg_rssi;\n\n\t \n\tstruct delayed_work work;\n\n\t \n\tstruct delayed_work watchdog_work;\n\tunsigned int watchdog_interval;\n\tbool watchdog_disabled;\n\n\t \n\tstruct delayed_work agc_work;\n\n\t \n\tstruct delayed_work vco_work;\n};\n\nenum rt2x00_delayed_flags {\n\tDELAYED_UPDATE_BEACON,\n};\n\n \nstruct rt2x00_intf {\n\t \n\tstruct mutex beacon_skb_mutex;\n\n\t \n\tstruct queue_entry *beacon;\n\tbool enable_beacon;\n\n\t \n\tunsigned long delayed_flags;\n\n\t \n\tatomic_t seqno;\n};\n\nstatic inline struct rt2x00_intf* vif_to_intf(struct ieee80211_vif *vif)\n{\n\treturn (struct rt2x00_intf *)vif->drv_priv;\n}\n\n \nstruct hw_mode_spec {\n\tunsigned int supported_bands;\n#define SUPPORT_BAND_2GHZ\t0x00000001\n#define SUPPORT_BAND_5GHZ\t0x00000002\n\n\tunsigned int supported_rates;\n#define SUPPORT_RATE_CCK\t0x00000001\n#define SUPPORT_RATE_OFDM\t0x00000002\n\n\tunsigned int num_channels;\n\tconst struct rf_channel *channels;\n\tconst struct channel_info *channels_info;\n\n\tstruct ieee80211_sta_ht_cap ht;\n};\n\n \nstruct rt2x00lib_conf {\n\tstruct ieee80211_conf *conf;\n\n\tstruct rf_channel rf;\n\tstruct channel_info channel;\n};\n\n \nstruct rt2x00lib_erp {\n\tint short_preamble;\n\tint cts_protection;\n\n\tu32 basic_rates;\n\n\tint slot_time;\n\n\tshort sifs;\n\tshort pifs;\n\tshort difs;\n\tshort eifs;\n\n\tu16 beacon_int;\n\tu16 ht_opmode;\n};\n\n \nstruct rt2x00lib_crypto {\n\tenum cipher cipher;\n\n\tenum set_key_cmd cmd;\n\tconst u8 *address;\n\n\tu32 bssidx;\n\n\tu8 key[16];\n\tu8 tx_mic[8];\n\tu8 rx_mic[8];\n\n\tint wcid;\n};\n\n \nstruct rt2x00intf_conf {\n\t \n\tenum nl80211_iftype type;\n\n\t \n\tenum tsf_sync sync;\n\n\t \n\t__le32 mac[2];\n\t__le32 bssid[2];\n};\n\n \nstruct rt2x00_sta {\n\tint wcid;\n};\n\nstatic inline struct rt2x00_sta* sta_to_rt2x00_sta(struct ieee80211_sta *sta)\n{\n\treturn (struct rt2x00_sta *)sta->drv_priv;\n}\n\n \nstruct rt2x00lib_ops {\n\t \n\tirq_handler_t irq_handler;\n\n\t \n\tvoid (*txstatus_tasklet) (struct tasklet_struct *t);\n\tvoid (*pretbtt_tasklet) (struct tasklet_struct *t);\n\tvoid (*tbtt_tasklet) (struct tasklet_struct *t);\n\tvoid (*rxdone_tasklet) (struct tasklet_struct *t);\n\tvoid (*autowake_tasklet) (struct tasklet_struct *t);\n\n\t \n\tint (*probe_hw) (struct rt2x00_dev *rt2x00dev);\n\tchar *(*get_firmware_name) (struct rt2x00_dev *rt2x00dev);\n\tint (*check_firmware) (struct rt2x00_dev *rt2x00dev,\n\t\t\t       const u8 *data, const size_t len);\n\tint (*load_firmware) (struct rt2x00_dev *rt2x00dev,\n\t\t\t      const u8 *data, const size_t len);\n\n\t \n\tint (*initialize) (struct rt2x00_dev *rt2x00dev);\n\tvoid (*uninitialize) (struct rt2x00_dev *rt2x00dev);\n\n\t \n\tbool (*get_entry_state) (struct queue_entry *entry);\n\tvoid (*clear_entry) (struct queue_entry *entry);\n\n\t \n\tint (*set_device_state) (struct rt2x00_dev *rt2x00dev,\n\t\t\t\t enum dev_state state);\n\tint (*rfkill_poll) (struct rt2x00_dev *rt2x00dev);\n\tvoid (*link_stats) (struct rt2x00_dev *rt2x00dev,\n\t\t\t    struct link_qual *qual);\n\tvoid (*reset_tuner) (struct rt2x00_dev *rt2x00dev,\n\t\t\t     struct link_qual *qual);\n\tvoid (*link_tuner) (struct rt2x00_dev *rt2x00dev,\n\t\t\t    struct link_qual *qual, const u32 count);\n\tvoid (*gain_calibration) (struct rt2x00_dev *rt2x00dev);\n\tvoid (*vco_calibration) (struct rt2x00_dev *rt2x00dev);\n\n\t \n\tvoid (*watchdog) (struct rt2x00_dev *rt2x00dev);\n\tvoid (*start_queue) (struct data_queue *queue);\n\tvoid (*kick_queue) (struct data_queue *queue);\n\tvoid (*stop_queue) (struct data_queue *queue);\n\tvoid (*flush_queue) (struct data_queue *queue, bool drop);\n\tvoid (*tx_dma_done) (struct queue_entry *entry);\n\n\t \n\tvoid (*write_tx_desc) (struct queue_entry *entry,\n\t\t\t       struct txentry_desc *txdesc);\n\tvoid (*write_tx_data) (struct queue_entry *entry,\n\t\t\t       struct txentry_desc *txdesc);\n\tvoid (*write_beacon) (struct queue_entry *entry,\n\t\t\t      struct txentry_desc *txdesc);\n\tvoid (*clear_beacon) (struct queue_entry *entry);\n\tint (*get_tx_data_len) (struct queue_entry *entry);\n\n\t \n\tvoid (*fill_rxdone) (struct queue_entry *entry,\n\t\t\t     struct rxdone_entry_desc *rxdesc);\n\n\t \n\tint (*config_shared_key) (struct rt2x00_dev *rt2x00dev,\n\t\t\t\t  struct rt2x00lib_crypto *crypto,\n\t\t\t\t  struct ieee80211_key_conf *key);\n\tint (*config_pairwise_key) (struct rt2x00_dev *rt2x00dev,\n\t\t\t\t    struct rt2x00lib_crypto *crypto,\n\t\t\t\t    struct ieee80211_key_conf *key);\n\tvoid (*config_filter) (struct rt2x00_dev *rt2x00dev,\n\t\t\t       const unsigned int filter_flags);\n\tvoid (*config_intf) (struct rt2x00_dev *rt2x00dev,\n\t\t\t     struct rt2x00_intf *intf,\n\t\t\t     struct rt2x00intf_conf *conf,\n\t\t\t     const unsigned int flags);\n#define CONFIG_UPDATE_TYPE\t\t( 1 << 1 )\n#define CONFIG_UPDATE_MAC\t\t( 1 << 2 )\n#define CONFIG_UPDATE_BSSID\t\t( 1 << 3 )\n\n\tvoid (*config_erp) (struct rt2x00_dev *rt2x00dev,\n\t\t\t    struct rt2x00lib_erp *erp,\n\t\t\t    u32 changed);\n\tvoid (*config_ant) (struct rt2x00_dev *rt2x00dev,\n\t\t\t    struct antenna_setup *ant);\n\tvoid (*config) (struct rt2x00_dev *rt2x00dev,\n\t\t\tstruct rt2x00lib_conf *libconf,\n\t\t\tconst unsigned int changed_flags);\n\tvoid (*pre_reset_hw) (struct rt2x00_dev *rt2x00dev);\n\tint (*sta_add) (struct rt2x00_dev *rt2x00dev,\n\t\t\tstruct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_sta *sta);\n\tint (*sta_remove) (struct rt2x00_dev *rt2x00dev,\n\t\t\t   struct ieee80211_sta *sta);\n};\n\n \nstruct rt2x00_ops {\n\tconst char *name;\n\tconst unsigned int drv_data_size;\n\tconst unsigned int max_ap_intf;\n\tconst unsigned int eeprom_size;\n\tconst unsigned int rf_size;\n\tconst unsigned int tx_queues;\n\tvoid (*queue_init)(struct data_queue *queue);\n\tconst struct rt2x00lib_ops *lib;\n\tconst void *drv;\n\tconst struct ieee80211_ops *hw;\n#ifdef CONFIG_RT2X00_LIB_DEBUGFS\n\tconst struct rt2x00debug *debugfs;\n#endif  \n};\n\n \nenum rt2x00_state_flags {\n\t \n\tDEVICE_STATE_PRESENT,\n\tDEVICE_STATE_REGISTERED_HW,\n\tDEVICE_STATE_INITIALIZED,\n\tDEVICE_STATE_STARTED,\n\tDEVICE_STATE_ENABLED_RADIO,\n\tDEVICE_STATE_SCANNING,\n\tDEVICE_STATE_FLUSHING,\n\tDEVICE_STATE_RESET,\n\n\t \n\tCONFIG_CHANNEL_HT40,\n\tCONFIG_POWERSAVING,\n\tCONFIG_HT_DISABLED,\n\tCONFIG_MONITORING,\n\n\t \n\tTX_STATUS_READING,\n};\n\n \nenum rt2x00_capability_flags {\n\t \n\tREQUIRE_FIRMWARE,\n\tREQUIRE_BEACON_GUARD,\n\tREQUIRE_ATIM_QUEUE,\n\tREQUIRE_DMA,\n\tREQUIRE_COPY_IV,\n\tREQUIRE_L2PAD,\n\tREQUIRE_TXSTATUS_FIFO,\n\tREQUIRE_TASKLET_CONTEXT,\n\tREQUIRE_SW_SEQNO,\n\tREQUIRE_HT_TX_DESC,\n\tREQUIRE_PS_AUTOWAKE,\n\tREQUIRE_DELAYED_RFKILL,\n\n\t \n\tCAPABILITY_HW_BUTTON,\n\tCAPABILITY_HW_CRYPTO,\n\tCAPABILITY_POWER_LIMIT,\n\tCAPABILITY_CONTROL_FILTERS,\n\tCAPABILITY_CONTROL_FILTER_PSPOLL,\n\tCAPABILITY_PRE_TBTT_INTERRUPT,\n\tCAPABILITY_LINK_TUNING,\n\tCAPABILITY_FRAME_TYPE,\n\tCAPABILITY_RF_SEQUENCE,\n\tCAPABILITY_EXTERNAL_LNA_A,\n\tCAPABILITY_EXTERNAL_LNA_BG,\n\tCAPABILITY_DOUBLE_ANTENNA,\n\tCAPABILITY_BT_COEXIST,\n\tCAPABILITY_VCO_RECALIBRATION,\n\tCAPABILITY_EXTERNAL_PA_TX0,\n\tCAPABILITY_EXTERNAL_PA_TX1,\n\tCAPABILITY_RESTART_HW,\n};\n\n \nenum {\n\tIF_COMB_AP = 0,\n\tNUM_IF_COMB,\n};\n\n \nstruct rt2x00_dev {\n\t \n\tstruct device *dev;\n\n\t \n\tconst struct rt2x00_ops *ops;\n\n\t \n\tvoid *drv_data;\n\n\t \n\tstruct ieee80211_hw *hw;\n\tstruct ieee80211_supported_band bands[NUM_NL80211_BANDS];\n\tstruct rt2x00_chan_survey *chan_survey;\n\tenum nl80211_band curr_band;\n\tint curr_freq;\n\n\t \n#ifdef CONFIG_RT2X00_LIB_DEBUGFS\n\tstruct rt2x00debug_intf *debugfs_intf;\n#endif  \n\n\t \n#ifdef CONFIG_RT2X00_LIB_LEDS\n\tstruct rt2x00_led led_radio;\n\tstruct rt2x00_led led_assoc;\n\tstruct rt2x00_led led_qual;\n\tu16 led_mcu_reg;\n#endif  \n\n\t \n\tunsigned long flags;\n\n\t \n\tunsigned long cap_flags;\n\n\t \n\tint irq;\n\tconst char *name;\n\n\t \n\tstruct rt2x00_chip chip;\n\n\t \n\tstruct hw_mode_spec spec;\n\n\t \n\tstruct antenna_setup default_ant;\n\n\t \n\tunion csr {\n\t\tvoid __iomem *base;\n\t\tvoid *cache;\n\t} csr;\n\n\t \n\tstruct mutex csr_mutex;\n\n\t \n\tstruct mutex conf_mutex;\n\t \n\tunsigned int packet_filter;\n\n\t \n\tunsigned int intf_ap_count;\n\tunsigned int intf_sta_count;\n\tunsigned int intf_associated;\n\tunsigned int intf_beaconing;\n\n\t \n\tstruct ieee80211_iface_limit if_limits_ap;\n\tstruct ieee80211_iface_combination if_combinations[NUM_IF_COMB];\n\n\t \n\tstruct link link;\n\n\t \n\t__le16 *eeprom;\n\n\t \n\tu32 *rf;\n\n\t \n\tshort lna_gain;\n\n\t \n\tu16 tx_power;\n\n\t \n\tu8 short_retry;\n\tu8 long_retry;\n\n\t \n\tu8 rssi_offset;\n\n\t \n\tu8 freq_offset;\n\n\t \n\tu16 aid;\n\n\t \n\tu16 beacon_int;\n\n\t \n\tunsigned long last_beacon;\n\n\t \n\tstruct ieee80211_low_level_stats low_level_stats;\n\n\t \n\tstruct workqueue_struct *workqueue;\n\n\t \n\tstruct work_struct intf_work;\n\n\t \n\tstruct work_struct rxdone_work;\n\tstruct work_struct txdone_work;\n\n\t \n\tstruct delayed_work autowakeup_work;\n\tstruct work_struct sleep_work;\n\n\t \n\tunsigned int data_queues;\n\tstruct data_queue *rx;\n\tstruct data_queue *tx;\n\tstruct data_queue *bcn;\n\tstruct data_queue *atim;\n\n\t \n\tconst struct firmware *fw;\n\n\t \n\tDECLARE_KFIFO_PTR(txstatus_fifo, u32);\n\n\t \n\tstruct hrtimer txstatus_timer;\n\n\t \n\tstruct tasklet_struct txstatus_tasklet;\n\tstruct tasklet_struct pretbtt_tasklet;\n\tstruct tasklet_struct tbtt_tasklet;\n\tstruct tasklet_struct rxdone_tasklet;\n\tstruct tasklet_struct autowake_tasklet;\n\n\t \n\tint rf_channel;\n\n\t \n\tspinlock_t irqmask_lock;\n\n\t \n\tstruct list_head bar_list;\n\tspinlock_t bar_list_lock;\n\n\t \n\tunsigned int extra_tx_headroom;\n\n\tstruct usb_anchor *anchor;\n\tunsigned int num_proto_errs;\n\n\t \n\tstruct clk *clk;\n};\n\nstruct rt2x00_bar_list_entry {\n\tstruct list_head list;\n\tstruct rcu_head head;\n\n\tstruct queue_entry *entry;\n\tint block_acked;\n\n\t \n\t__u8 ra[6];\n\t__u8 ta[6];\n\t__le16 control;\n\t__le16 start_seq_num;\n};\n\n \n#define REGISTER_BUSY_COUNT\t100\n#define REGISTER_USB_BUSY_COUNT 20\n#define REGISTER_BUSY_DELAY\t100\n\n \nstatic inline u32 rt2x00_rf_read(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t const unsigned int word)\n{\n\tBUG_ON(word < 1 || word > rt2x00dev->ops->rf_size / sizeof(u32));\n\treturn rt2x00dev->rf[word - 1];\n}\n\nstatic inline void rt2x00_rf_write(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t   const unsigned int word, u32 data)\n{\n\tBUG_ON(word < 1 || word > rt2x00dev->ops->rf_size / sizeof(u32));\n\trt2x00dev->rf[word - 1] = data;\n}\n\n \nstatic inline void *rt2x00_eeprom_addr(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t       const unsigned int word)\n{\n\treturn (void *)&rt2x00dev->eeprom[word];\n}\n\nstatic inline u16 rt2x00_eeprom_read(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t     const unsigned int word)\n{\n\treturn le16_to_cpu(rt2x00dev->eeprom[word]);\n}\n\nstatic inline void rt2x00_eeprom_write(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t       const unsigned int word, u16 data)\n{\n\trt2x00dev->eeprom[word] = cpu_to_le16(data);\n}\n\nstatic inline u8 rt2x00_eeprom_byte(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t    const unsigned int byte)\n{\n\treturn *(((u8 *)rt2x00dev->eeprom) + byte);\n}\n\n \nstatic inline void rt2x00_set_chip(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t   const u16 rt, const u16 rf, const u16 rev)\n{\n\trt2x00dev->chip.rt = rt;\n\trt2x00dev->chip.rf = rf;\n\trt2x00dev->chip.rev = rev;\n\n\trt2x00_info(rt2x00dev, \"Chipset detected - rt: %04x, rf: %04x, rev: %04x\\n\",\n\t\t    rt2x00dev->chip.rt, rt2x00dev->chip.rf,\n\t\t    rt2x00dev->chip.rev);\n}\n\nstatic inline void rt2x00_set_rt(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t const u16 rt, const u16 rev)\n{\n\trt2x00dev->chip.rt = rt;\n\trt2x00dev->chip.rev = rev;\n\n\trt2x00_info(rt2x00dev, \"RT chipset %04x, rev %04x detected\\n\",\n\t\t    rt2x00dev->chip.rt, rt2x00dev->chip.rev);\n}\n\nstatic inline void rt2x00_set_rf(struct rt2x00_dev *rt2x00dev, const u16 rf)\n{\n\trt2x00dev->chip.rf = rf;\n\n\trt2x00_info(rt2x00dev, \"RF chipset %04x detected\\n\",\n\t\t    rt2x00dev->chip.rf);\n}\n\nstatic inline bool rt2x00_rt(struct rt2x00_dev *rt2x00dev, const u16 rt)\n{\n\treturn (rt2x00dev->chip.rt == rt);\n}\n\nstatic inline bool rt2x00_rf(struct rt2x00_dev *rt2x00dev, const u16 rf)\n{\n\treturn (rt2x00dev->chip.rf == rf);\n}\n\nstatic inline u16 rt2x00_rev(struct rt2x00_dev *rt2x00dev)\n{\n\treturn rt2x00dev->chip.rev;\n}\n\nstatic inline bool rt2x00_rt_rev(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t const u16 rt, const u16 rev)\n{\n\treturn (rt2x00_rt(rt2x00dev, rt) && rt2x00_rev(rt2x00dev) == rev);\n}\n\nstatic inline bool rt2x00_rt_rev_lt(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t    const u16 rt, const u16 rev)\n{\n\treturn (rt2x00_rt(rt2x00dev, rt) && rt2x00_rev(rt2x00dev) < rev);\n}\n\nstatic inline bool rt2x00_rt_rev_gte(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t     const u16 rt, const u16 rev)\n{\n\treturn (rt2x00_rt(rt2x00dev, rt) && rt2x00_rev(rt2x00dev) >= rev);\n}\n\nstatic inline void rt2x00_set_chip_intf(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\tenum rt2x00_chip_intf intf)\n{\n\trt2x00dev->chip.intf = intf;\n}\n\nstatic inline bool rt2x00_intf(struct rt2x00_dev *rt2x00dev,\n\t\t\t       enum rt2x00_chip_intf intf)\n{\n\treturn (rt2x00dev->chip.intf == intf);\n}\n\nstatic inline bool rt2x00_is_pci(struct rt2x00_dev *rt2x00dev)\n{\n\treturn rt2x00_intf(rt2x00dev, RT2X00_CHIP_INTF_PCI) ||\n\t       rt2x00_intf(rt2x00dev, RT2X00_CHIP_INTF_PCIE);\n}\n\nstatic inline bool rt2x00_is_pcie(struct rt2x00_dev *rt2x00dev)\n{\n\treturn rt2x00_intf(rt2x00dev, RT2X00_CHIP_INTF_PCIE);\n}\n\nstatic inline bool rt2x00_is_usb(struct rt2x00_dev *rt2x00dev)\n{\n\treturn rt2x00_intf(rt2x00dev, RT2X00_CHIP_INTF_USB);\n}\n\nstatic inline bool rt2x00_is_soc(struct rt2x00_dev *rt2x00dev)\n{\n\treturn rt2x00_intf(rt2x00dev, RT2X00_CHIP_INTF_SOC);\n}\n\n \n\nstatic inline bool\nrt2x00_has_cap_flag(struct rt2x00_dev *rt2x00dev,\n\t\t    enum rt2x00_capability_flags cap_flag)\n{\n\treturn test_bit(cap_flag, &rt2x00dev->cap_flags);\n}\n\nstatic inline bool\nrt2x00_has_cap_hw_crypto(struct rt2x00_dev *rt2x00dev)\n{\n\treturn rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_HW_CRYPTO);\n}\n\nstatic inline bool\nrt2x00_has_cap_power_limit(struct rt2x00_dev *rt2x00dev)\n{\n\treturn rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_POWER_LIMIT);\n}\n\nstatic inline bool\nrt2x00_has_cap_control_filters(struct rt2x00_dev *rt2x00dev)\n{\n\treturn rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_CONTROL_FILTERS);\n}\n\nstatic inline bool\nrt2x00_has_cap_control_filter_pspoll(struct rt2x00_dev *rt2x00dev)\n{\n\treturn rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_CONTROL_FILTER_PSPOLL);\n}\n\nstatic inline bool\nrt2x00_has_cap_pre_tbtt_interrupt(struct rt2x00_dev *rt2x00dev)\n{\n\treturn rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_PRE_TBTT_INTERRUPT);\n}\n\nstatic inline bool\nrt2x00_has_cap_link_tuning(struct rt2x00_dev *rt2x00dev)\n{\n\treturn rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_LINK_TUNING);\n}\n\nstatic inline bool\nrt2x00_has_cap_frame_type(struct rt2x00_dev *rt2x00dev)\n{\n\treturn rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_FRAME_TYPE);\n}\n\nstatic inline bool\nrt2x00_has_cap_rf_sequence(struct rt2x00_dev *rt2x00dev)\n{\n\treturn rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_RF_SEQUENCE);\n}\n\nstatic inline bool\nrt2x00_has_cap_external_lna_a(struct rt2x00_dev *rt2x00dev)\n{\n\treturn rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_EXTERNAL_LNA_A);\n}\n\nstatic inline bool\nrt2x00_has_cap_external_lna_bg(struct rt2x00_dev *rt2x00dev)\n{\n\treturn rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_EXTERNAL_LNA_BG);\n}\n\nstatic inline bool\nrt2x00_has_cap_double_antenna(struct rt2x00_dev *rt2x00dev)\n{\n\treturn rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_DOUBLE_ANTENNA);\n}\n\nstatic inline bool\nrt2x00_has_cap_bt_coexist(struct rt2x00_dev *rt2x00dev)\n{\n\treturn rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_BT_COEXIST);\n}\n\nstatic inline bool\nrt2x00_has_cap_vco_recalibration(struct rt2x00_dev *rt2x00dev)\n{\n\treturn rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_VCO_RECALIBRATION);\n}\n\nstatic inline bool\nrt2x00_has_cap_restart_hw(struct rt2x00_dev *rt2x00dev)\n{\n\treturn rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_RESTART_HW);\n}\n\n \nint rt2x00queue_map_txskb(struct queue_entry *entry);\n\n \nvoid rt2x00queue_unmap_skb(struct queue_entry *entry);\n\n \nstatic inline struct data_queue *\nrt2x00queue_get_tx_queue(struct rt2x00_dev *rt2x00dev,\n\t\t\t enum data_queue_qid queue)\n{\n\tif (queue >= rt2x00dev->ops->tx_queues && queue < IEEE80211_NUM_ACS)\n\t\tqueue = rt2x00dev->ops->tx_queues - 1;\n\n\tif (queue < rt2x00dev->ops->tx_queues && rt2x00dev->tx)\n\t\treturn &rt2x00dev->tx[queue];\n\n\tif (queue == QID_ATIM)\n\t\treturn rt2x00dev->atim;\n\n\treturn NULL;\n}\n\n \nstruct queue_entry *rt2x00queue_get_entry(struct data_queue *queue,\n\t\t\t\t\t  enum queue_index index);\n\n \nvoid rt2x00queue_pause_queue(struct data_queue *queue);\n\n \nvoid rt2x00queue_unpause_queue(struct data_queue *queue);\n\n \nvoid rt2x00queue_start_queue(struct data_queue *queue);\n\n \nvoid rt2x00queue_stop_queue(struct data_queue *queue);\n\n \nvoid rt2x00queue_flush_queue(struct data_queue *queue, bool drop);\n\n \nvoid rt2x00queue_start_queues(struct rt2x00_dev *rt2x00dev);\n\n \nvoid rt2x00queue_stop_queues(struct rt2x00_dev *rt2x00dev);\n\n \nvoid rt2x00queue_flush_queues(struct rt2x00_dev *rt2x00dev, bool drop);\n\n \n \n#ifdef CONFIG_RT2X00_LIB_DEBUGFS\nvoid rt2x00debug_dump_frame(struct rt2x00_dev *rt2x00dev,\n\t\t\t    enum rt2x00_dump_type type, struct queue_entry *entry);\n#else\nstatic inline void rt2x00debug_dump_frame(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t  enum rt2x00_dump_type type,\n\t\t\t\t\t  struct queue_entry *entry)\n{\n}\n#endif  \n\n \nu32 rt2x00lib_get_bssidx(struct rt2x00_dev *rt2x00dev,\n\t\t\t struct ieee80211_vif *vif);\nvoid rt2x00lib_set_mac_address(struct rt2x00_dev *rt2x00dev, u8 *eeprom_mac_addr);\n\n \nvoid rt2x00lib_beacondone(struct rt2x00_dev *rt2x00dev);\nvoid rt2x00lib_pretbtt(struct rt2x00_dev *rt2x00dev);\nvoid rt2x00lib_dmastart(struct queue_entry *entry);\nvoid rt2x00lib_dmadone(struct queue_entry *entry);\nvoid rt2x00lib_txdone(struct queue_entry *entry,\n\t\t      struct txdone_entry_desc *txdesc);\nvoid rt2x00lib_txdone_nomatch(struct queue_entry *entry,\n\t\t\t      struct txdone_entry_desc *txdesc);\nvoid rt2x00lib_txdone_noinfo(struct queue_entry *entry, u32 status);\nvoid rt2x00lib_rxdone(struct queue_entry *entry, gfp_t gfp);\n\n \nvoid rt2x00mac_tx(struct ieee80211_hw *hw,\n\t\t  struct ieee80211_tx_control *control,\n\t\t  struct sk_buff *skb);\nint rt2x00mac_start(struct ieee80211_hw *hw);\nvoid rt2x00mac_stop(struct ieee80211_hw *hw);\nvoid rt2x00mac_reconfig_complete(struct ieee80211_hw *hw,\n\t\t\t\t enum ieee80211_reconfig_type reconfig_type);\nint rt2x00mac_add_interface(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif);\nvoid rt2x00mac_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif);\nint rt2x00mac_config(struct ieee80211_hw *hw, u32 changed);\nvoid rt2x00mac_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\tunsigned int changed_flags,\n\t\t\t\tunsigned int *total_flags,\n\t\t\t\tu64 multicast);\nint rt2x00mac_set_tim(struct ieee80211_hw *hw, struct ieee80211_sta *sta,\n\t\t      bool set);\n#ifdef CONFIG_RT2X00_LIB_CRYPTO\nint rt2x00mac_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t      struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t      struct ieee80211_key_conf *key);\n#else\n#define rt2x00mac_set_key\tNULL\n#endif  \nvoid rt2x00mac_sw_scan_start(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     const u8 *mac_addr);\nvoid rt2x00mac_sw_scan_complete(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif);\nint rt2x00mac_get_stats(struct ieee80211_hw *hw,\n\t\t\tstruct ieee80211_low_level_stats *stats);\nvoid rt2x00mac_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_bss_conf *bss_conf,\n\t\t\t\tu64 changes);\nint rt2x00mac_conf_tx(struct ieee80211_hw *hw,\n\t\t      struct ieee80211_vif *vif,\n\t\t      unsigned int link_id, u16 queue,\n\t\t      const struct ieee80211_tx_queue_params *params);\nvoid rt2x00mac_rfkill_poll(struct ieee80211_hw *hw);\nvoid rt2x00mac_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t     u32 queues, bool drop);\nint rt2x00mac_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant);\nint rt2x00mac_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant);\nvoid rt2x00mac_get_ringparam(struct ieee80211_hw *hw,\n\t\t\t     u32 *tx, u32 *tx_max, u32 *rx, u32 *rx_max);\nbool rt2x00mac_tx_frames_pending(struct ieee80211_hw *hw);\n\n \nint rt2x00lib_probe_dev(struct rt2x00_dev *rt2x00dev);\nvoid rt2x00lib_remove_dev(struct rt2x00_dev *rt2x00dev);\n\nint rt2x00lib_suspend(struct rt2x00_dev *rt2x00dev);\nint rt2x00lib_resume(struct rt2x00_dev *rt2x00dev);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}