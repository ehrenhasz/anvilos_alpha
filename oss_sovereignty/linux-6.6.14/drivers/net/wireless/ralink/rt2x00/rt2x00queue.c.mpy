{
  "module_name": "rt2x00queue.c",
  "hash_id": "3e18ab181551b6a8a1fe9309a1083e13201a9ee8d8a1dc568e32eca705b63717",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ralink/rt2x00/rt2x00queue.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/dma-mapping.h>\n\n#include \"rt2x00.h\"\n#include \"rt2x00lib.h\"\n\nstruct sk_buff *rt2x00queue_alloc_rxskb(struct queue_entry *entry, gfp_t gfp)\n{\n\tstruct data_queue *queue = entry->queue;\n\tstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\n\tstruct sk_buff *skb;\n\tstruct skb_frame_desc *skbdesc;\n\tunsigned int frame_size;\n\tunsigned int head_size = 0;\n\tunsigned int tail_size = 0;\n\n\t \n\tframe_size = queue->data_size + queue->desc_size + queue->winfo_size;\n\n\t \n\thead_size = 4;\n\n\t \n\tif (rt2x00_has_cap_hw_crypto(rt2x00dev)) {\n\t\thead_size += 8;\n\t\ttail_size += 8;\n\t}\n\n\t \n\tskb = __dev_alloc_skb(frame_size + head_size + tail_size, gfp);\n\tif (!skb)\n\t\treturn NULL;\n\n\t \n\tskb_reserve(skb, head_size);\n\tskb_put(skb, frame_size);\n\n\t \n\tskbdesc = get_skb_frame_desc(skb);\n\tmemset(skbdesc, 0, sizeof(*skbdesc));\n\n\tif (rt2x00_has_cap_flag(rt2x00dev, REQUIRE_DMA)) {\n\t\tdma_addr_t skb_dma;\n\n\t\tskb_dma = dma_map_single(rt2x00dev->dev, skb->data, skb->len,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\tif (unlikely(dma_mapping_error(rt2x00dev->dev, skb_dma))) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tskbdesc->skb_dma = skb_dma;\n\t\tskbdesc->flags |= SKBDESC_DMA_MAPPED_RX;\n\t}\n\n\treturn skb;\n}\n\nint rt2x00queue_map_txskb(struct queue_entry *entry)\n{\n\tstruct device *dev = entry->queue->rt2x00dev->dev;\n\tstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\n\n\tskbdesc->skb_dma =\n\t    dma_map_single(dev, entry->skb->data, entry->skb->len, DMA_TO_DEVICE);\n\n\tif (unlikely(dma_mapping_error(dev, skbdesc->skb_dma)))\n\t\treturn -ENOMEM;\n\n\tskbdesc->flags |= SKBDESC_DMA_MAPPED_TX;\n\trt2x00lib_dmadone(entry);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rt2x00queue_map_txskb);\n\nvoid rt2x00queue_unmap_skb(struct queue_entry *entry)\n{\n\tstruct device *dev = entry->queue->rt2x00dev->dev;\n\tstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\n\n\tif (skbdesc->flags & SKBDESC_DMA_MAPPED_RX) {\n\t\tdma_unmap_single(dev, skbdesc->skb_dma, entry->skb->len,\n\t\t\t\t DMA_FROM_DEVICE);\n\t\tskbdesc->flags &= ~SKBDESC_DMA_MAPPED_RX;\n\t} else if (skbdesc->flags & SKBDESC_DMA_MAPPED_TX) {\n\t\tdma_unmap_single(dev, skbdesc->skb_dma, entry->skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\t\tskbdesc->flags &= ~SKBDESC_DMA_MAPPED_TX;\n\t}\n}\nEXPORT_SYMBOL_GPL(rt2x00queue_unmap_skb);\n\nvoid rt2x00queue_free_skb(struct queue_entry *entry)\n{\n\tif (!entry->skb)\n\t\treturn;\n\n\trt2x00queue_unmap_skb(entry);\n\tdev_kfree_skb_any(entry->skb);\n\tentry->skb = NULL;\n}\n\nvoid rt2x00queue_align_frame(struct sk_buff *skb)\n{\n\tunsigned int frame_length = skb->len;\n\tunsigned int align = ALIGN_SIZE(skb, 0);\n\n\tif (!align)\n\t\treturn;\n\n\tskb_push(skb, align);\n\tmemmove(skb->data, skb->data + align, frame_length);\n\tskb_trim(skb, frame_length);\n}\n\n \nvoid rt2x00queue_insert_l2pad(struct sk_buff *skb, unsigned int hdr_len)\n{\n\tunsigned int l2pad = (skb->len > hdr_len) ? L2PAD_SIZE(hdr_len) : 0;\n\n\tif (!l2pad)\n\t\treturn;\n\n\tskb_push(skb, l2pad);\n\tmemmove(skb->data, skb->data + l2pad, hdr_len);\n}\n\nvoid rt2x00queue_remove_l2pad(struct sk_buff *skb, unsigned int hdr_len)\n{\n\tunsigned int l2pad = (skb->len > hdr_len) ? L2PAD_SIZE(hdr_len) : 0;\n\n\tif (!l2pad)\n\t\treturn;\n\n\tmemmove(skb->data + l2pad, skb->data, hdr_len);\n\tskb_pull(skb, l2pad);\n}\n\nstatic void rt2x00queue_create_tx_descriptor_seq(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t\t struct txentry_desc *txdesc)\n{\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct rt2x00_intf *intf = vif_to_intf(tx_info->control.vif);\n\tu16 seqno;\n\n\tif (!(tx_info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ))\n\t\treturn;\n\n\t__set_bit(ENTRY_TXD_GENERATE_SEQ, &txdesc->flags);\n\n\tif (!rt2x00_has_cap_flag(rt2x00dev, REQUIRE_SW_SEQNO)) {\n\t\t \n\t    \tif (ieee80211_is_beacon(hdr->frame_control)) {\n\t\t\t__set_bit(ENTRY_TXD_GENERATE_SEQ, &txdesc->flags);\n\t\t\t \n\t\t\treturn;\n\t\t}\n\n\t\t__clear_bit(ENTRY_TXD_GENERATE_SEQ, &txdesc->flags);\n\t}\n\n\t \n\tif (test_bit(ENTRY_TXD_FIRST_FRAGMENT, &txdesc->flags))\n\t\tseqno = atomic_add_return(0x10, &intf->seqno);\n\telse\n\t\tseqno = atomic_read(&intf->seqno);\n\n\thdr->seq_ctrl &= cpu_to_le16(IEEE80211_SCTL_FRAG);\n\thdr->seq_ctrl |= cpu_to_le16(seqno);\n}\n\nstatic void rt2x00queue_create_tx_descriptor_plcp(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t\t  struct txentry_desc *txdesc,\n\t\t\t\t\t\t  const struct rt2x00_rate *hwrate)\n{\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_tx_rate *txrate = &tx_info->control.rates[0];\n\tunsigned int data_length;\n\tunsigned int duration;\n\tunsigned int residual;\n\n\t \n\tif (test_bit(ENTRY_TXD_FIRST_FRAGMENT, &txdesc->flags))\n\t\ttxdesc->u.plcp.ifs = IFS_BACKOFF;\n\telse\n\t\ttxdesc->u.plcp.ifs = IFS_SIFS;\n\n\t \n\tdata_length = skb->len + 4;\n\tdata_length += rt2x00crypto_tx_overhead(rt2x00dev, skb);\n\n\t \n\ttxdesc->u.plcp.signal = hwrate->plcp;\n\ttxdesc->u.plcp.service = 0x04;\n\n\tif (hwrate->flags & DEV_RATE_OFDM) {\n\t\ttxdesc->u.plcp.length_high = (data_length >> 6) & 0x3f;\n\t\ttxdesc->u.plcp.length_low = data_length & 0x3f;\n\t} else {\n\t\t \n\t\tresidual = GET_DURATION_RES(data_length, hwrate->bitrate);\n\t\tduration = GET_DURATION(data_length, hwrate->bitrate);\n\n\t\tif (residual != 0) {\n\t\t\tduration++;\n\n\t\t\t \n\t\t\tif (hwrate->bitrate == 110 && residual <= 30)\n\t\t\t\ttxdesc->u.plcp.service |= 0x80;\n\t\t}\n\n\t\ttxdesc->u.plcp.length_high = (duration >> 8) & 0xff;\n\t\ttxdesc->u.plcp.length_low = duration & 0xff;\n\n\t\t \n\t\tif (txrate->flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE)\n\t\t\ttxdesc->u.plcp.signal |= 0x08;\n\t}\n}\n\nstatic void rt2x00queue_create_tx_descriptor_ht(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\t\tstruct txentry_desc *txdesc,\n\t\t\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\t\t\tconst struct rt2x00_rate *hwrate)\n{\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_tx_rate *txrate = &tx_info->control.rates[0];\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct rt2x00_sta *sta_priv = NULL;\n\tu8 density = 0;\n\n\tif (sta) {\n\t\tsta_priv = sta_to_rt2x00_sta(sta);\n\t\ttxdesc->u.ht.wcid = sta_priv->wcid;\n\t\tdensity = sta->deflink.ht_cap.ampdu_density;\n\t}\n\n\t \n\tif (txrate->flags & IEEE80211_TX_RC_MCS) {\n\t\ttxdesc->u.ht.mcs = txrate->idx;\n\n\t\t \n\t\tif (sta && txdesc->u.ht.mcs > 7 &&\n\t\t    sta->deflink.smps_mode == IEEE80211_SMPS_DYNAMIC)\n\t\t\t__set_bit(ENTRY_TXD_HT_MIMO_PS, &txdesc->flags);\n\t} else {\n\t\ttxdesc->u.ht.mcs = rt2x00_get_rate_mcs(hwrate->mcs);\n\t\tif (txrate->flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE)\n\t\t\ttxdesc->u.ht.mcs |= 0x08;\n\t}\n\n\tif (test_bit(CONFIG_HT_DISABLED, &rt2x00dev->flags)) {\n\t\tif (!(tx_info->flags & IEEE80211_TX_CTL_FIRST_FRAGMENT))\n\t\t\ttxdesc->u.ht.txop = TXOP_SIFS;\n\t\telse\n\t\t\ttxdesc->u.ht.txop = TXOP_BACKOFF;\n\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tif (tx_info->flags & IEEE80211_TX_CTL_STBC)\n\t\ttxdesc->u.ht.stbc = 1;\n\n\t \n\tif (tx_info->flags & IEEE80211_TX_CTL_AMPDU &&\n\t    !(tx_info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE)) {\n\t\t__set_bit(ENTRY_TXD_HT_AMPDU, &txdesc->flags);\n\t\ttxdesc->u.ht.mpdu_density = density;\n\t\ttxdesc->u.ht.ba_size = 7;  \n\t}\n\n\t \n\tif (txrate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH ||\n\t    txrate->flags & IEEE80211_TX_RC_DUP_DATA)\n\t\t__set_bit(ENTRY_TXD_HT_BW_40, &txdesc->flags);\n\tif (txrate->flags & IEEE80211_TX_RC_SHORT_GI)\n\t\t__set_bit(ENTRY_TXD_HT_SHORT_GI, &txdesc->flags);\n\n\t \n\tif (ieee80211_is_mgmt(hdr->frame_control) &&\n\t    !ieee80211_is_beacon(hdr->frame_control))\n\t\ttxdesc->u.ht.txop = TXOP_BACKOFF;\n\telse if (!(tx_info->flags & IEEE80211_TX_CTL_FIRST_FRAGMENT))\n\t\ttxdesc->u.ht.txop = TXOP_SIFS;\n\telse\n\t\ttxdesc->u.ht.txop = TXOP_HTTXOP;\n}\n\nstatic void rt2x00queue_create_tx_descriptor(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t\t     struct txentry_desc *txdesc,\n\t\t\t\t\t     struct ieee80211_sta *sta)\n{\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct ieee80211_tx_rate *txrate = &tx_info->control.rates[0];\n\tstruct ieee80211_rate *rate;\n\tconst struct rt2x00_rate *hwrate = NULL;\n\n\tmemset(txdesc, 0, sizeof(*txdesc));\n\n\t \n\ttxdesc->length = skb->len;\n\ttxdesc->header_length = ieee80211_get_hdrlen_from_skb(skb);\n\n\t \n\tif (!(tx_info->flags & IEEE80211_TX_CTL_NO_ACK))\n\t\t__set_bit(ENTRY_TXD_ACK, &txdesc->flags);\n\n\t \n\tif (ieee80211_is_rts(hdr->frame_control) ||\n\t    ieee80211_is_cts(hdr->frame_control)) {\n\t\t__set_bit(ENTRY_TXD_BURST, &txdesc->flags);\n\t\tif (ieee80211_is_rts(hdr->frame_control))\n\t\t\t__set_bit(ENTRY_TXD_RTS_FRAME, &txdesc->flags);\n\t\telse\n\t\t\t__set_bit(ENTRY_TXD_CTS_FRAME, &txdesc->flags);\n\t\tif (tx_info->control.rts_cts_rate_idx >= 0)\n\t\t\trate =\n\t\t\t    ieee80211_get_rts_cts_rate(rt2x00dev->hw, tx_info);\n\t}\n\n\t \n\ttxdesc->retry_limit = tx_info->control.rates[0].count - 1;\n\tif (txdesc->retry_limit >= rt2x00dev->long_retry)\n\t\t__set_bit(ENTRY_TXD_RETRY_MODE, &txdesc->flags);\n\n\t \n\tif (ieee80211_has_morefrags(hdr->frame_control)) {\n\t\t__set_bit(ENTRY_TXD_BURST, &txdesc->flags);\n\t\t__set_bit(ENTRY_TXD_MORE_FRAG, &txdesc->flags);\n\t}\n\n\t \n\tif (tx_info->flags & IEEE80211_TX_CTL_MORE_FRAMES)\n\t\t__set_bit(ENTRY_TXD_BURST, &txdesc->flags);\n\n\t \n\tif ((ieee80211_is_beacon(hdr->frame_control) ||\n\t     ieee80211_is_probe_resp(hdr->frame_control)) &&\n\t    !(tx_info->flags & IEEE80211_TX_CTL_INJECTED))\n\t\t__set_bit(ENTRY_TXD_REQ_TIMESTAMP, &txdesc->flags);\n\n\tif ((tx_info->flags & IEEE80211_TX_CTL_FIRST_FRAGMENT) &&\n\t    !test_bit(ENTRY_TXD_RTS_FRAME, &txdesc->flags))\n\t\t__set_bit(ENTRY_TXD_FIRST_FRAGMENT, &txdesc->flags);\n\n\t \n\tif (txrate->flags & IEEE80211_TX_RC_GREEN_FIELD)\n\t\ttxdesc->rate_mode = RATE_MODE_HT_GREENFIELD;\n\telse if (txrate->flags & IEEE80211_TX_RC_MCS)\n\t\ttxdesc->rate_mode = RATE_MODE_HT_MIX;\n\telse {\n\t\trate = ieee80211_get_tx_rate(rt2x00dev->hw, tx_info);\n\t\thwrate = rt2x00_get_rate(rate->hw_value);\n\t\tif (hwrate->flags & DEV_RATE_OFDM)\n\t\t\ttxdesc->rate_mode = RATE_MODE_OFDM;\n\t\telse\n\t\t\ttxdesc->rate_mode = RATE_MODE_CCK;\n\t}\n\n\t \n\trt2x00crypto_create_tx_descriptor(rt2x00dev, skb, txdesc);\n\trt2x00queue_create_tx_descriptor_seq(rt2x00dev, skb, txdesc);\n\n\tif (rt2x00_has_cap_flag(rt2x00dev, REQUIRE_HT_TX_DESC))\n\t\trt2x00queue_create_tx_descriptor_ht(rt2x00dev, skb, txdesc,\n\t\t\t\t\t\t   sta, hwrate);\n\telse\n\t\trt2x00queue_create_tx_descriptor_plcp(rt2x00dev, skb, txdesc,\n\t\t\t\t\t\t      hwrate);\n}\n\nstatic int rt2x00queue_write_tx_data(struct queue_entry *entry,\n\t\t\t\t     struct txentry_desc *txdesc)\n{\n\tstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\n\n\t \n\tif (unlikely(rt2x00dev->ops->lib->get_entry_state &&\n\t\t     rt2x00dev->ops->lib->get_entry_state(entry))) {\n\t\trt2x00_err(rt2x00dev,\n\t\t\t   \"Corrupt queue %d, accessing entry which is not ours\\n\"\n\t\t\t   \"Please file bug report to %s\\n\",\n\t\t\t   entry->queue->qid, DRV_PROJECT);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tskb_push(entry->skb, rt2x00dev->extra_tx_headroom);\n\tmemset(entry->skb->data, 0, rt2x00dev->extra_tx_headroom);\n\n\t \n\tif (rt2x00dev->ops->lib->write_tx_data)\n\t\trt2x00dev->ops->lib->write_tx_data(entry, txdesc);\n\n\t \n\tif (rt2x00_has_cap_flag(rt2x00dev, REQUIRE_DMA) &&\n\t    rt2x00queue_map_txskb(entry))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void rt2x00queue_write_tx_descriptor(struct queue_entry *entry,\n\t\t\t\t\t    struct txentry_desc *txdesc)\n{\n\tstruct data_queue *queue = entry->queue;\n\n\tqueue->rt2x00dev->ops->lib->write_tx_desc(entry, txdesc);\n\n\t \n\trt2x00debug_dump_frame(queue->rt2x00dev, DUMP_FRAME_TX, entry);\n}\n\nstatic void rt2x00queue_kick_tx_queue(struct data_queue *queue,\n\t\t\t\t      struct txentry_desc *txdesc)\n{\n\t \n\tif (rt2x00queue_threshold(queue) ||\n\t    !test_bit(ENTRY_TXD_BURST, &txdesc->flags))\n\t\tqueue->rt2x00dev->ops->lib->kick_queue(queue);\n}\n\nstatic void rt2x00queue_bar_check(struct queue_entry *entry)\n{\n\tstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\n\tstruct ieee80211_bar *bar = (void *) (entry->skb->data +\n\t\t\t\t    rt2x00dev->extra_tx_headroom);\n\tstruct rt2x00_bar_list_entry *bar_entry;\n\n\tif (likely(!ieee80211_is_back_req(bar->frame_control)))\n\t\treturn;\n\n\tbar_entry = kmalloc(sizeof(*bar_entry), GFP_ATOMIC);\n\n\t \n\tif (!bar_entry)\n\t\treturn;\n\n\tbar_entry->entry = entry;\n\tbar_entry->block_acked = 0;\n\n\t \n\tmemcpy(bar_entry->ra, bar->ra, sizeof(bar->ra));\n\tmemcpy(bar_entry->ta, bar->ta, sizeof(bar->ta));\n\tbar_entry->control = bar->control;\n\tbar_entry->start_seq_num = bar->start_seq_num;\n\n\t \n\tspin_lock_bh(&rt2x00dev->bar_list_lock);\n\tlist_add_tail_rcu(&bar_entry->list, &rt2x00dev->bar_list);\n\tspin_unlock_bh(&rt2x00dev->bar_list_lock);\n}\n\nint rt2x00queue_write_tx_frame(struct data_queue *queue, struct sk_buff *skb,\n\t\t\t       struct ieee80211_sta *sta, bool local)\n{\n\tstruct ieee80211_tx_info *tx_info;\n\tstruct queue_entry *entry;\n\tstruct txentry_desc txdesc;\n\tstruct skb_frame_desc *skbdesc;\n\tu8 rate_idx, rate_flags;\n\tint ret = 0;\n\n\t \n\trt2x00queue_create_tx_descriptor(queue->rt2x00dev, skb, &txdesc, sta);\n\n\t \n\ttx_info = IEEE80211_SKB_CB(skb);\n\trate_idx = tx_info->control.rates[0].idx;\n\trate_flags = tx_info->control.rates[0].flags;\n\tskbdesc = get_skb_frame_desc(skb);\n\tmemset(skbdesc, 0, sizeof(*skbdesc));\n\tskbdesc->tx_rate_idx = rate_idx;\n\tskbdesc->tx_rate_flags = rate_flags;\n\n\tif (local)\n\t\tskbdesc->flags |= SKBDESC_NOT_MAC80211;\n\n\t \n\tif (test_bit(ENTRY_TXD_ENCRYPT, &txdesc.flags) &&\n\t    !test_bit(ENTRY_TXD_ENCRYPT_IV, &txdesc.flags)) {\n\t\tif (rt2x00_has_cap_flag(queue->rt2x00dev, REQUIRE_COPY_IV))\n\t\t\trt2x00crypto_tx_copy_iv(skb, &txdesc);\n\t\telse\n\t\t\trt2x00crypto_tx_remove_iv(skb, &txdesc);\n\t}\n\n\t \n\tif (rt2x00_has_cap_flag(queue->rt2x00dev, REQUIRE_L2PAD))\n\t\trt2x00queue_insert_l2pad(skb, txdesc.header_length);\n\telse if (rt2x00_has_cap_flag(queue->rt2x00dev, REQUIRE_DMA))\n\t\trt2x00queue_align_frame(skb);\n\n\t \n\tspin_lock(&queue->tx_lock);\n\n\tif (unlikely(rt2x00queue_full(queue))) {\n\t\trt2x00_dbg(queue->rt2x00dev, \"Dropping frame due to full tx queue %d\\n\",\n\t\t\t   queue->qid);\n\t\tret = -ENOBUFS;\n\t\tgoto out;\n\t}\n\n\tentry = rt2x00queue_get_entry(queue, Q_INDEX);\n\n\tif (unlikely(test_and_set_bit(ENTRY_OWNER_DEVICE_DATA,\n\t\t\t\t      &entry->flags))) {\n\t\trt2x00_err(queue->rt2x00dev,\n\t\t\t   \"Arrived at non-free entry in the non-full queue %d\\n\"\n\t\t\t   \"Please file bug report to %s\\n\",\n\t\t\t   queue->qid, DRV_PROJECT);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tentry->skb = skb;\n\n\t \n\tif (unlikely(rt2x00queue_write_tx_data(entry, &txdesc))) {\n\t\tclear_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags);\n\t\tentry->skb = NULL;\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\trt2x00queue_bar_check(entry);\n\n\tset_bit(ENTRY_DATA_PENDING, &entry->flags);\n\n\trt2x00queue_index_inc(entry, Q_INDEX);\n\trt2x00queue_write_tx_descriptor(entry, &txdesc);\n\trt2x00queue_kick_tx_queue(queue, &txdesc);\n\nout:\n\t \n\tif (rt2x00queue_threshold(queue))\n\t\trt2x00queue_pause_queue(queue);\n\n\tspin_unlock(&queue->tx_lock);\n\treturn ret;\n}\n\nint rt2x00queue_clear_beacon(struct rt2x00_dev *rt2x00dev,\n\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct rt2x00_intf *intf = vif_to_intf(vif);\n\n\tif (unlikely(!intf->beacon))\n\t\treturn -ENOBUFS;\n\n\t \n\trt2x00queue_free_skb(intf->beacon);\n\n\t \n\tif (rt2x00dev->ops->lib->clear_beacon)\n\t\trt2x00dev->ops->lib->clear_beacon(intf->beacon);\n\n\treturn 0;\n}\n\nint rt2x00queue_update_beacon(struct rt2x00_dev *rt2x00dev,\n\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct rt2x00_intf *intf = vif_to_intf(vif);\n\tstruct skb_frame_desc *skbdesc;\n\tstruct txentry_desc txdesc;\n\n\tif (unlikely(!intf->beacon))\n\t\treturn -ENOBUFS;\n\n\t \n\trt2x00queue_free_skb(intf->beacon);\n\n\tintf->beacon->skb = ieee80211_beacon_get(rt2x00dev->hw, vif, 0);\n\tif (!intf->beacon->skb)\n\t\treturn -ENOMEM;\n\n\t \n\trt2x00queue_create_tx_descriptor(rt2x00dev, intf->beacon->skb, &txdesc, NULL);\n\n\t \n\tskbdesc = get_skb_frame_desc(intf->beacon->skb);\n\tmemset(skbdesc, 0, sizeof(*skbdesc));\n\n\t \n\trt2x00dev->ops->lib->write_beacon(intf->beacon, &txdesc);\n\n\treturn 0;\n\n}\n\nbool rt2x00queue_for_each_entry(struct data_queue *queue,\n\t\t\t\tenum queue_index start,\n\t\t\t\tenum queue_index end,\n\t\t\t\tvoid *data,\n\t\t\t\tbool (*fn)(struct queue_entry *entry,\n\t\t\t\t\t   void *data))\n{\n\tunsigned long irqflags;\n\tunsigned int index_start;\n\tunsigned int index_end;\n\tunsigned int i;\n\n\tif (unlikely(start >= Q_INDEX_MAX || end >= Q_INDEX_MAX)) {\n\t\trt2x00_err(queue->rt2x00dev,\n\t\t\t   \"Entry requested from invalid index range (%d - %d)\\n\",\n\t\t\t   start, end);\n\t\treturn true;\n\t}\n\n\t \n\tspin_lock_irqsave(&queue->index_lock, irqflags);\n\tindex_start = queue->index[start];\n\tindex_end = queue->index[end];\n\tspin_unlock_irqrestore(&queue->index_lock, irqflags);\n\n\t \n\tif (index_start < index_end) {\n\t\tfor (i = index_start; i < index_end; i++) {\n\t\t\tif (fn(&queue->entries[i], data))\n\t\t\t\treturn true;\n\t\t}\n\t} else {\n\t\tfor (i = index_start; i < queue->limit; i++) {\n\t\t\tif (fn(&queue->entries[i], data))\n\t\t\t\treturn true;\n\t\t}\n\n\t\tfor (i = 0; i < index_end; i++) {\n\t\t\tif (fn(&queue->entries[i], data))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(rt2x00queue_for_each_entry);\n\nstruct queue_entry *rt2x00queue_get_entry(struct data_queue *queue,\n\t\t\t\t\t  enum queue_index index)\n{\n\tstruct queue_entry *entry;\n\tunsigned long irqflags;\n\n\tif (unlikely(index >= Q_INDEX_MAX)) {\n\t\trt2x00_err(queue->rt2x00dev, \"Entry requested from invalid index type (%d)\\n\",\n\t\t\t   index);\n\t\treturn NULL;\n\t}\n\n\tspin_lock_irqsave(&queue->index_lock, irqflags);\n\n\tentry = &queue->entries[queue->index[index]];\n\n\tspin_unlock_irqrestore(&queue->index_lock, irqflags);\n\n\treturn entry;\n}\nEXPORT_SYMBOL_GPL(rt2x00queue_get_entry);\n\nvoid rt2x00queue_index_inc(struct queue_entry *entry, enum queue_index index)\n{\n\tstruct data_queue *queue = entry->queue;\n\tunsigned long irqflags;\n\n\tif (unlikely(index >= Q_INDEX_MAX)) {\n\t\trt2x00_err(queue->rt2x00dev,\n\t\t\t   \"Index change on invalid index type (%d)\\n\", index);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&queue->index_lock, irqflags);\n\n\tqueue->index[index]++;\n\tif (queue->index[index] >= queue->limit)\n\t\tqueue->index[index] = 0;\n\n\tentry->last_action = jiffies;\n\n\tif (index == Q_INDEX) {\n\t\tqueue->length++;\n\t} else if (index == Q_INDEX_DONE) {\n\t\tqueue->length--;\n\t\tqueue->count++;\n\t}\n\n\tspin_unlock_irqrestore(&queue->index_lock, irqflags);\n}\n\nstatic void rt2x00queue_pause_queue_nocheck(struct data_queue *queue)\n{\n\tswitch (queue->qid) {\n\tcase QID_AC_VO:\n\tcase QID_AC_VI:\n\tcase QID_AC_BE:\n\tcase QID_AC_BK:\n\t\t \n\t\tieee80211_stop_queue(queue->rt2x00dev->hw, queue->qid);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\nvoid rt2x00queue_pause_queue(struct data_queue *queue)\n{\n\tif (!test_bit(DEVICE_STATE_PRESENT, &queue->rt2x00dev->flags) ||\n\t    !test_bit(QUEUE_STARTED, &queue->flags) ||\n\t    test_and_set_bit(QUEUE_PAUSED, &queue->flags))\n\t\treturn;\n\n\trt2x00queue_pause_queue_nocheck(queue);\n}\nEXPORT_SYMBOL_GPL(rt2x00queue_pause_queue);\n\nvoid rt2x00queue_unpause_queue(struct data_queue *queue)\n{\n\tif (!test_bit(DEVICE_STATE_PRESENT, &queue->rt2x00dev->flags) ||\n\t    !test_bit(QUEUE_STARTED, &queue->flags) ||\n\t    !test_and_clear_bit(QUEUE_PAUSED, &queue->flags))\n\t\treturn;\n\n\tswitch (queue->qid) {\n\tcase QID_AC_VO:\n\tcase QID_AC_VI:\n\tcase QID_AC_BE:\n\tcase QID_AC_BK:\n\t\t \n\t\tieee80211_wake_queue(queue->rt2x00dev->hw, queue->qid);\n\t\tbreak;\n\tcase QID_RX:\n\t\t \n\t\tqueue->rt2x00dev->ops->lib->kick_queue(queue);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(rt2x00queue_unpause_queue);\n\nvoid rt2x00queue_start_queue(struct data_queue *queue)\n{\n\tmutex_lock(&queue->status_lock);\n\n\tif (!test_bit(DEVICE_STATE_PRESENT, &queue->rt2x00dev->flags) ||\n\t    test_and_set_bit(QUEUE_STARTED, &queue->flags)) {\n\t\tmutex_unlock(&queue->status_lock);\n\t\treturn;\n\t}\n\n\tset_bit(QUEUE_PAUSED, &queue->flags);\n\n\tqueue->rt2x00dev->ops->lib->start_queue(queue);\n\n\trt2x00queue_unpause_queue(queue);\n\n\tmutex_unlock(&queue->status_lock);\n}\nEXPORT_SYMBOL_GPL(rt2x00queue_start_queue);\n\nvoid rt2x00queue_stop_queue(struct data_queue *queue)\n{\n\tmutex_lock(&queue->status_lock);\n\n\tif (!test_and_clear_bit(QUEUE_STARTED, &queue->flags)) {\n\t\tmutex_unlock(&queue->status_lock);\n\t\treturn;\n\t}\n\n\trt2x00queue_pause_queue_nocheck(queue);\n\n\tqueue->rt2x00dev->ops->lib->stop_queue(queue);\n\n\tmutex_unlock(&queue->status_lock);\n}\nEXPORT_SYMBOL_GPL(rt2x00queue_stop_queue);\n\nvoid rt2x00queue_flush_queue(struct data_queue *queue, bool drop)\n{\n\tbool tx_queue =\n\t\t(queue->qid == QID_AC_VO) ||\n\t\t(queue->qid == QID_AC_VI) ||\n\t\t(queue->qid == QID_AC_BE) ||\n\t\t(queue->qid == QID_AC_BK);\n\n\tif (rt2x00queue_empty(queue))\n\t\treturn;\n\n\t \n\tif (!drop && tx_queue)\n\t\tqueue->rt2x00dev->ops->lib->kick_queue(queue);\n\n\t \n\tif (likely(queue->rt2x00dev->ops->lib->flush_queue))\n\t\tqueue->rt2x00dev->ops->lib->flush_queue(queue, drop);\n\n\t \n\tif (unlikely(!rt2x00queue_empty(queue)))\n\t\trt2x00_warn(queue->rt2x00dev, \"Queue %d failed to flush\\n\",\n\t\t\t    queue->qid);\n}\nEXPORT_SYMBOL_GPL(rt2x00queue_flush_queue);\n\nvoid rt2x00queue_start_queues(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct data_queue *queue;\n\n\t \n\ttx_queue_for_each(rt2x00dev, queue)\n\t\trt2x00queue_start_queue(queue);\n\n\trt2x00queue_start_queue(rt2x00dev->rx);\n}\nEXPORT_SYMBOL_GPL(rt2x00queue_start_queues);\n\nvoid rt2x00queue_stop_queues(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct data_queue *queue;\n\n\t \n\tieee80211_stop_queues(rt2x00dev->hw);\n\n\ttx_queue_for_each(rt2x00dev, queue)\n\t\trt2x00queue_stop_queue(queue);\n\n\trt2x00queue_stop_queue(rt2x00dev->rx);\n}\nEXPORT_SYMBOL_GPL(rt2x00queue_stop_queues);\n\nvoid rt2x00queue_flush_queues(struct rt2x00_dev *rt2x00dev, bool drop)\n{\n\tstruct data_queue *queue;\n\n\ttx_queue_for_each(rt2x00dev, queue)\n\t\trt2x00queue_flush_queue(queue, drop);\n\n\trt2x00queue_flush_queue(rt2x00dev->rx, drop);\n}\nEXPORT_SYMBOL_GPL(rt2x00queue_flush_queues);\n\nstatic void rt2x00queue_reset(struct data_queue *queue)\n{\n\tunsigned long irqflags;\n\tunsigned int i;\n\n\tspin_lock_irqsave(&queue->index_lock, irqflags);\n\n\tqueue->count = 0;\n\tqueue->length = 0;\n\n\tfor (i = 0; i < Q_INDEX_MAX; i++)\n\t\tqueue->index[i] = 0;\n\n\tspin_unlock_irqrestore(&queue->index_lock, irqflags);\n}\n\nvoid rt2x00queue_init_queues(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct data_queue *queue;\n\tunsigned int i;\n\n\tqueue_for_each(rt2x00dev, queue) {\n\t\trt2x00queue_reset(queue);\n\n\t\tfor (i = 0; i < queue->limit; i++)\n\t\t\trt2x00dev->ops->lib->clear_entry(&queue->entries[i]);\n\t}\n}\n\nstatic int rt2x00queue_alloc_entries(struct data_queue *queue)\n{\n\tstruct queue_entry *entries;\n\tunsigned int entry_size;\n\tunsigned int i;\n\n\trt2x00queue_reset(queue);\n\n\t \n\tentry_size = sizeof(*entries) + queue->priv_size;\n\tentries = kcalloc(queue->limit, entry_size, GFP_KERNEL);\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n#define QUEUE_ENTRY_PRIV_OFFSET(__base, __index, __limit, __esize, __psize) \\\n\t(((char *)(__base)) + ((__limit) * (__esize)) + \\\n\t    ((__index) * (__psize)))\n\n\tfor (i = 0; i < queue->limit; i++) {\n\t\tentries[i].flags = 0;\n\t\tentries[i].queue = queue;\n\t\tentries[i].skb = NULL;\n\t\tentries[i].entry_idx = i;\n\t\tentries[i].priv_data =\n\t\t    QUEUE_ENTRY_PRIV_OFFSET(entries, i, queue->limit,\n\t\t\t\t\t    sizeof(*entries), queue->priv_size);\n\t}\n\n#undef QUEUE_ENTRY_PRIV_OFFSET\n\n\tqueue->entries = entries;\n\n\treturn 0;\n}\n\nstatic void rt2x00queue_free_skbs(struct data_queue *queue)\n{\n\tunsigned int i;\n\n\tif (!queue->entries)\n\t\treturn;\n\n\tfor (i = 0; i < queue->limit; i++) {\n\t\trt2x00queue_free_skb(&queue->entries[i]);\n\t}\n}\n\nstatic int rt2x00queue_alloc_rxskbs(struct data_queue *queue)\n{\n\tunsigned int i;\n\tstruct sk_buff *skb;\n\n\tfor (i = 0; i < queue->limit; i++) {\n\t\tskb = rt2x00queue_alloc_rxskb(&queue->entries[i], GFP_KERNEL);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\t\tqueue->entries[i].skb = skb;\n\t}\n\n\treturn 0;\n}\n\nint rt2x00queue_initialize(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct data_queue *queue;\n\tint status;\n\n\tstatus = rt2x00queue_alloc_entries(rt2x00dev->rx);\n\tif (status)\n\t\tgoto exit;\n\n\ttx_queue_for_each(rt2x00dev, queue) {\n\t\tstatus = rt2x00queue_alloc_entries(queue);\n\t\tif (status)\n\t\t\tgoto exit;\n\t}\n\n\tstatus = rt2x00queue_alloc_entries(rt2x00dev->bcn);\n\tif (status)\n\t\tgoto exit;\n\n\tif (rt2x00_has_cap_flag(rt2x00dev, REQUIRE_ATIM_QUEUE)) {\n\t\tstatus = rt2x00queue_alloc_entries(rt2x00dev->atim);\n\t\tif (status)\n\t\t\tgoto exit;\n\t}\n\n\tstatus = rt2x00queue_alloc_rxskbs(rt2x00dev->rx);\n\tif (status)\n\t\tgoto exit;\n\n\treturn 0;\n\nexit:\n\trt2x00_err(rt2x00dev, \"Queue entries allocation failed\\n\");\n\n\trt2x00queue_uninitialize(rt2x00dev);\n\n\treturn status;\n}\n\nvoid rt2x00queue_uninitialize(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct data_queue *queue;\n\n\trt2x00queue_free_skbs(rt2x00dev->rx);\n\n\tqueue_for_each(rt2x00dev, queue) {\n\t\tkfree(queue->entries);\n\t\tqueue->entries = NULL;\n\t}\n}\n\nstatic void rt2x00queue_init(struct rt2x00_dev *rt2x00dev,\n\t\t\t     struct data_queue *queue, enum data_queue_qid qid)\n{\n\tmutex_init(&queue->status_lock);\n\tspin_lock_init(&queue->tx_lock);\n\tspin_lock_init(&queue->index_lock);\n\n\tqueue->rt2x00dev = rt2x00dev;\n\tqueue->qid = qid;\n\tqueue->txop = 0;\n\tqueue->aifs = 2;\n\tqueue->cw_min = 5;\n\tqueue->cw_max = 10;\n\n\trt2x00dev->ops->queue_init(queue);\n\n\tqueue->threshold = DIV_ROUND_UP(queue->limit, 10);\n}\n\nint rt2x00queue_allocate(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct data_queue *queue;\n\tenum data_queue_qid qid;\n\tunsigned int req_atim =\n\t    rt2x00_has_cap_flag(rt2x00dev, REQUIRE_ATIM_QUEUE);\n\n\t \n\trt2x00dev->data_queues = 2 + rt2x00dev->ops->tx_queues + req_atim;\n\n\tqueue = kcalloc(rt2x00dev->data_queues, sizeof(*queue), GFP_KERNEL);\n\tif (!queue)\n\t\treturn -ENOMEM;\n\n\t \n\trt2x00dev->rx = queue;\n\trt2x00dev->tx = &queue[1];\n\trt2x00dev->bcn = &queue[1 + rt2x00dev->ops->tx_queues];\n\trt2x00dev->atim = req_atim ? &queue[2 + rt2x00dev->ops->tx_queues] : NULL;\n\n\t \n\trt2x00queue_init(rt2x00dev, rt2x00dev->rx, QID_RX);\n\n\tqid = QID_AC_VO;\n\ttx_queue_for_each(rt2x00dev, queue)\n\t\trt2x00queue_init(rt2x00dev, queue, qid++);\n\n\trt2x00queue_init(rt2x00dev, rt2x00dev->bcn, QID_BEACON);\n\tif (req_atim)\n\t\trt2x00queue_init(rt2x00dev, rt2x00dev->atim, QID_ATIM);\n\n\treturn 0;\n}\n\nvoid rt2x00queue_free(struct rt2x00_dev *rt2x00dev)\n{\n\tkfree(rt2x00dev->rx);\n\trt2x00dev->rx = NULL;\n\trt2x00dev->tx = NULL;\n\trt2x00dev->bcn = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}