{
  "module_name": "rt2x00usb.h",
  "hash_id": "ac5f95ff05c8307fcb06b4fc0ab60fce1328289a12740c59432fe98ec217285a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ralink/rt2x00/rt2x00usb.h",
  "human_readable_source": " \n \n\n \n\n#ifndef RT2X00USB_H\n#define RT2X00USB_H\n\n#include <linux/usb.h>\n\n#define to_usb_device_intf(d) \\\n({ \\\n\tstruct usb_interface *intf = to_usb_interface(d); \\\n\tinterface_to_usbdev(intf); \\\n})\n\n \n#define REGISTER_TIMEOUT\t\t100\n#define REGISTER_TIMEOUT_FIRMWARE\t1000\n#define EEPROM_TIMEOUT\t\t\t2000\n\n \n#define CSR_CACHE_SIZE\t\t\t64\n\n \n#define USB_VENDOR_REQUEST\t( USB_TYPE_VENDOR | USB_RECIP_DEVICE )\n#define USB_VENDOR_REQUEST_IN\t( USB_DIR_IN | USB_VENDOR_REQUEST )\n#define USB_VENDOR_REQUEST_OUT\t( USB_DIR_OUT | USB_VENDOR_REQUEST )\n\n \nenum rt2x00usb_vendor_request {\n\tUSB_DEVICE_MODE = 1,\n\tUSB_SINGLE_WRITE = 2,\n\tUSB_SINGLE_READ = 3,\n\tUSB_MULTI_WRITE = 6,\n\tUSB_MULTI_READ = 7,\n\tUSB_EEPROM_WRITE = 8,\n\tUSB_EEPROM_READ = 9,\n\tUSB_LED_CONTROL = 10,  \n\tUSB_RX_CONTROL = 12,\n};\n\n \nenum rt2x00usb_mode_offset {\n\tUSB_MODE_RESET = 1,\n\tUSB_MODE_UNPLUG = 2,\n\tUSB_MODE_FUNCTION = 3,\n\tUSB_MODE_TEST = 4,\n\tUSB_MODE_SLEEP = 7,\t \n\tUSB_MODE_FIRMWARE = 8,\t \n\tUSB_MODE_WAKEUP = 9,\t \n\tUSB_MODE_AUTORUN = 17,  \n};\n\n \nint rt2x00usb_vendor_request(struct rt2x00_dev *rt2x00dev,\n\t\t\t     const u8 request, const u8 requesttype,\n\t\t\t     const u16 offset, const u16 value,\n\t\t\t     void *buffer, const u16 buffer_length,\n\t\t\t     const int timeout);\n\n \nint rt2x00usb_vendor_request_buff(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t  const u8 request, const u8 requesttype,\n\t\t\t\t  const u16 offset, void *buffer,\n\t\t\t\t  const u16 buffer_length);\n\n \nint rt2x00usb_vendor_req_buff_lock(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t   const u8 request, const u8 requesttype,\n\t\t\t\t   const u16 offset, void *buffer,\n\t\t\t\t   const u16 buffer_length, const int timeout);\n\n \nstatic inline int rt2x00usb_vendor_request_sw(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t      const u8 request,\n\t\t\t\t\t      const u16 offset,\n\t\t\t\t\t      const u16 value,\n\t\t\t\t\t      const int timeout)\n{\n\treturn rt2x00usb_vendor_request(rt2x00dev, request,\n\t\t\t\t\tUSB_VENDOR_REQUEST_OUT, offset,\n\t\t\t\t\tvalue, NULL, 0, timeout);\n}\n\n \nstatic inline int rt2x00usb_eeprom_read(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t__le16 *eeprom, const u16 length)\n{\n\treturn rt2x00usb_vendor_request(rt2x00dev, USB_EEPROM_READ,\n\t\t\t\t\tUSB_VENDOR_REQUEST_IN, 0, 0,\n\t\t\t\t\teeprom, length, EEPROM_TIMEOUT);\n}\n\n \nstatic inline u32 rt2x00usb_register_read(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t  const unsigned int offset)\n{\n\t__le32 reg = 0;\n\trt2x00usb_vendor_request_buff(rt2x00dev, USB_MULTI_READ,\n\t\t\t\t      USB_VENDOR_REQUEST_IN, offset,\n\t\t\t\t      &reg, sizeof(reg));\n\treturn le32_to_cpu(reg);\n}\n\n \nstatic inline u32 rt2x00usb_register_read_lock(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t       const unsigned int offset)\n{\n\t__le32 reg = 0;\n\trt2x00usb_vendor_req_buff_lock(rt2x00dev, USB_MULTI_READ,\n\t\t\t\t       USB_VENDOR_REQUEST_IN, offset,\n\t\t\t\t       &reg, sizeof(reg), REGISTER_TIMEOUT);\n\treturn le32_to_cpu(reg);\n}\n\n \nstatic inline void rt2x00usb_register_multiread(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t\tconst unsigned int offset,\n\t\t\t\t\t\tvoid *value, const u32 length)\n{\n\trt2x00usb_vendor_request_buff(rt2x00dev, USB_MULTI_READ,\n\t\t\t\t      USB_VENDOR_REQUEST_IN, offset,\n\t\t\t\t      value, length);\n}\n\n \nstatic inline void rt2x00usb_register_write(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t    const unsigned int offset,\n\t\t\t\t\t    u32 value)\n{\n\t__le32 reg = cpu_to_le32(value);\n\trt2x00usb_vendor_request_buff(rt2x00dev, USB_MULTI_WRITE,\n\t\t\t\t      USB_VENDOR_REQUEST_OUT, offset,\n\t\t\t\t      &reg, sizeof(reg));\n}\n\n \nstatic inline void rt2x00usb_register_write_lock(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t\t const unsigned int offset,\n\t\t\t\t\t\t u32 value)\n{\n\t__le32 reg = cpu_to_le32(value);\n\trt2x00usb_vendor_req_buff_lock(rt2x00dev, USB_MULTI_WRITE,\n\t\t\t\t       USB_VENDOR_REQUEST_OUT, offset,\n\t\t\t\t       &reg, sizeof(reg), REGISTER_TIMEOUT);\n}\n\n \nstatic inline void rt2x00usb_register_multiwrite(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t\t const unsigned int offset,\n\t\t\t\t\t\t const void *value,\n\t\t\t\t\t\t const u32 length)\n{\n\trt2x00usb_vendor_request_buff(rt2x00dev, USB_MULTI_WRITE,\n\t\t\t\t      USB_VENDOR_REQUEST_OUT, offset,\n\t\t\t\t      (void *)value, length);\n}\n\n \nint rt2x00usb_regbusy_read(struct rt2x00_dev *rt2x00dev,\n\t\t\t   const unsigned int offset,\n\t\t\t   const struct rt2x00_field32 field,\n\t\t\t   u32 *reg);\n\n \nvoid rt2x00usb_register_read_async(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t   const unsigned int offset,\n\t\t\t\t   bool (*callback)(struct rt2x00_dev*, int, u32));\n\n \nvoid rt2x00usb_disable_radio(struct rt2x00_dev *rt2x00dev);\n\n \nstruct queue_entry_priv_usb {\n\tstruct urb *urb;\n};\n\n \nstruct queue_entry_priv_usb_bcn {\n\tstruct urb *urb;\n\n\tunsigned int guardian_data;\n\tstruct urb *guardian_urb;\n};\n\n \nvoid rt2x00usb_kick_queue(struct data_queue *queue);\n\n \nvoid rt2x00usb_flush_queue(struct data_queue *queue, bool drop);\n\n \nvoid rt2x00usb_watchdog(struct rt2x00_dev *rt2x00dev);\n\n \nvoid rt2x00usb_clear_entry(struct queue_entry *entry);\nint rt2x00usb_initialize(struct rt2x00_dev *rt2x00dev);\nvoid rt2x00usb_uninitialize(struct rt2x00_dev *rt2x00dev);\n\n \nint rt2x00usb_probe(struct usb_interface *usb_intf,\n\t\t    const struct rt2x00_ops *ops);\nvoid rt2x00usb_disconnect(struct usb_interface *usb_intf);\n#ifdef CONFIG_PM\nint rt2x00usb_suspend(struct usb_interface *usb_intf, pm_message_t state);\nint rt2x00usb_resume(struct usb_interface *usb_intf);\n#else\n#define rt2x00usb_suspend\tNULL\n#define rt2x00usb_resume\tNULL\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}