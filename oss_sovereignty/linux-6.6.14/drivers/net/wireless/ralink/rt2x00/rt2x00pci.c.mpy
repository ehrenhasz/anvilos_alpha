{
  "module_name": "rt2x00pci.c",
  "hash_id": "9f42798fcd16e0b8f8ffe0283c3a739dc9f9ad719241e0537e6637f6ef1b221e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ralink/rt2x00/rt2x00pci.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/dma-mapping.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n\n#include \"rt2x00.h\"\n#include \"rt2x00pci.h\"\n\n \nstatic void rt2x00pci_free_reg(struct rt2x00_dev *rt2x00dev)\n{\n\tkfree(rt2x00dev->rf);\n\trt2x00dev->rf = NULL;\n\n\tkfree(rt2x00dev->eeprom);\n\trt2x00dev->eeprom = NULL;\n\n\tif (rt2x00dev->csr.base) {\n\t\tiounmap(rt2x00dev->csr.base);\n\t\trt2x00dev->csr.base = NULL;\n\t}\n}\n\nstatic int rt2x00pci_alloc_reg(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(rt2x00dev->dev);\n\n\trt2x00dev->csr.base = pci_ioremap_bar(pci_dev, 0);\n\tif (!rt2x00dev->csr.base)\n\t\tgoto exit;\n\n\trt2x00dev->eeprom = kzalloc(rt2x00dev->ops->eeprom_size, GFP_KERNEL);\n\tif (!rt2x00dev->eeprom)\n\t\tgoto exit;\n\n\trt2x00dev->rf = kzalloc(rt2x00dev->ops->rf_size, GFP_KERNEL);\n\tif (!rt2x00dev->rf)\n\t\tgoto exit;\n\n\treturn 0;\n\nexit:\n\trt2x00_probe_err(\"Failed to allocate registers\\n\");\n\n\trt2x00pci_free_reg(rt2x00dev);\n\n\treturn -ENOMEM;\n}\n\nint rt2x00pci_probe(struct pci_dev *pci_dev, const struct rt2x00_ops *ops)\n{\n\tstruct ieee80211_hw *hw;\n\tstruct rt2x00_dev *rt2x00dev;\n\tint retval;\n\tu16 chip;\n\n\tretval = pci_enable_device(pci_dev);\n\tif (retval) {\n\t\trt2x00_probe_err(\"Enable device failed\\n\");\n\t\treturn retval;\n\t}\n\n\tretval = pci_request_regions(pci_dev, pci_name(pci_dev));\n\tif (retval) {\n\t\trt2x00_probe_err(\"PCI request regions failed\\n\");\n\t\tgoto exit_disable_device;\n\t}\n\n\tpci_set_master(pci_dev);\n\n\tif (pci_set_mwi(pci_dev))\n\t\trt2x00_probe_err(\"MWI not available\\n\");\n\n\tif (dma_set_mask(&pci_dev->dev, DMA_BIT_MASK(32))) {\n\t\trt2x00_probe_err(\"PCI DMA not supported\\n\");\n\t\tretval = -EIO;\n\t\tgoto exit_release_regions;\n\t}\n\n\thw = ieee80211_alloc_hw(sizeof(struct rt2x00_dev), ops->hw);\n\tif (!hw) {\n\t\trt2x00_probe_err(\"Failed to allocate hardware\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto exit_release_regions;\n\t}\n\n\tpci_set_drvdata(pci_dev, hw);\n\n\trt2x00dev = hw->priv;\n\trt2x00dev->dev = &pci_dev->dev;\n\trt2x00dev->ops = ops;\n\trt2x00dev->hw = hw;\n\trt2x00dev->irq = pci_dev->irq;\n\trt2x00dev->name = ops->name;\n\n\tif (pci_is_pcie(pci_dev))\n\t\trt2x00_set_chip_intf(rt2x00dev, RT2X00_CHIP_INTF_PCIE);\n\telse\n\t\trt2x00_set_chip_intf(rt2x00dev, RT2X00_CHIP_INTF_PCI);\n\n\tretval = rt2x00pci_alloc_reg(rt2x00dev);\n\tif (retval)\n\t\tgoto exit_free_device;\n\n\t \n\tpci_read_config_word(pci_dev, PCI_DEVICE_ID, &chip);\n\trt2x00dev->chip.rt = chip;\n\n\tretval = rt2x00lib_probe_dev(rt2x00dev);\n\tif (retval)\n\t\tgoto exit_free_reg;\n\n\treturn 0;\n\nexit_free_reg:\n\trt2x00pci_free_reg(rt2x00dev);\n\nexit_free_device:\n\tieee80211_free_hw(hw);\n\nexit_release_regions:\n\tpci_clear_mwi(pci_dev);\n\tpci_release_regions(pci_dev);\n\nexit_disable_device:\n\tpci_disable_device(pci_dev);\n\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(rt2x00pci_probe);\n\nvoid rt2x00pci_remove(struct pci_dev *pci_dev)\n{\n\tstruct ieee80211_hw *hw = pci_get_drvdata(pci_dev);\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\n\t \n\trt2x00lib_remove_dev(rt2x00dev);\n\trt2x00pci_free_reg(rt2x00dev);\n\tieee80211_free_hw(hw);\n\n\t \n\tpci_clear_mwi(pci_dev);\n\tpci_disable_device(pci_dev);\n\tpci_release_regions(pci_dev);\n}\nEXPORT_SYMBOL_GPL(rt2x00pci_remove);\n\nstatic int __maybe_unused rt2x00pci_suspend(struct device *dev)\n{\n\tstruct ieee80211_hw *hw = dev_get_drvdata(dev);\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\n\treturn rt2x00lib_suspend(rt2x00dev);\n}\n\nstatic int __maybe_unused rt2x00pci_resume(struct device *dev)\n{\n\tstruct ieee80211_hw *hw = dev_get_drvdata(dev);\n\tstruct rt2x00_dev *rt2x00dev = hw->priv;\n\n\treturn rt2x00lib_resume(rt2x00dev);\n}\n\nSIMPLE_DEV_PM_OPS(rt2x00pci_pm_ops, rt2x00pci_suspend, rt2x00pci_resume);\nEXPORT_SYMBOL_GPL(rt2x00pci_pm_ops);\n\n \nMODULE_AUTHOR(DRV_PROJECT);\nMODULE_VERSION(DRV_VERSION);\nMODULE_DESCRIPTION(\"rt2x00 pci library\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}