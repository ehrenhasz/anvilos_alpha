{
  "module_name": "rt2800mmio.c",
  "hash_id": "8e1f6ceabf84553e4395b5778381e056f2e290c123ea28d2f47dbb0629317756",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/export.h>\n\n#include \"rt2x00.h\"\n#include \"rt2x00mmio.h\"\n#include \"rt2800.h\"\n#include \"rt2800lib.h\"\n#include \"rt2800mmio.h\"\n\nunsigned int rt2800mmio_get_dma_done(struct data_queue *queue)\n{\n\tstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\n\tstruct queue_entry *entry;\n\tint idx, qid;\n\n\tswitch (queue->qid) {\n\tcase QID_AC_VO:\n\tcase QID_AC_VI:\n\tcase QID_AC_BE:\n\tcase QID_AC_BK:\n\t\tqid = queue->qid;\n\t\tidx = rt2x00mmio_register_read(rt2x00dev, TX_DTX_IDX(qid));\n\t\tbreak;\n\tcase QID_MGMT:\n\t\tidx = rt2x00mmio_register_read(rt2x00dev, TX_DTX_IDX(5));\n\t\tbreak;\n\tcase QID_RX:\n\t\tentry = rt2x00queue_get_entry(queue, Q_INDEX_DMA_DONE);\n\t\tidx = entry->entry_idx;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tidx = 0;\n\t\tbreak;\n\t}\n\n\treturn idx;\n}\nEXPORT_SYMBOL_GPL(rt2800mmio_get_dma_done);\n\n \n__le32 *rt2800mmio_get_txwi(struct queue_entry *entry)\n{\n\treturn (__le32 *) entry->skb->data;\n}\nEXPORT_SYMBOL_GPL(rt2800mmio_get_txwi);\n\nvoid rt2800mmio_write_tx_desc(struct queue_entry *entry,\n\t\t\t      struct txentry_desc *txdesc)\n{\n\tstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\n\tstruct queue_entry_priv_mmio *entry_priv = entry->priv_data;\n\t__le32 *txd = entry_priv->desc;\n\tu32 word;\n\tconst unsigned int txwi_size = entry->queue->winfo_size;\n\n\t \n\n\t \n\tword = 0;\n\trt2x00_set_field32(&word, TXD_W0_SD_PTR0, skbdesc->skb_dma);\n\trt2x00_desc_write(txd, 0, word);\n\n\tword = 0;\n\trt2x00_set_field32(&word, TXD_W1_SD_LEN1, entry->skb->len);\n\trt2x00_set_field32(&word, TXD_W1_LAST_SEC1,\n\t\t\t   !test_bit(ENTRY_TXD_MORE_FRAG, &txdesc->flags));\n\trt2x00_set_field32(&word, TXD_W1_BURST,\n\t\t\t   test_bit(ENTRY_TXD_BURST, &txdesc->flags));\n\trt2x00_set_field32(&word, TXD_W1_SD_LEN0, txwi_size);\n\trt2x00_set_field32(&word, TXD_W1_LAST_SEC0, 0);\n\trt2x00_set_field32(&word, TXD_W1_DMA_DONE, 0);\n\trt2x00_desc_write(txd, 1, word);\n\n\tword = 0;\n\trt2x00_set_field32(&word, TXD_W2_SD_PTR1,\n\t\t\t   skbdesc->skb_dma + txwi_size);\n\trt2x00_desc_write(txd, 2, word);\n\n\tword = 0;\n\trt2x00_set_field32(&word, TXD_W3_WIV,\n\t\t\t   !test_bit(ENTRY_TXD_ENCRYPT_IV, &txdesc->flags));\n\trt2x00_set_field32(&word, TXD_W3_QSEL, 2);\n\trt2x00_desc_write(txd, 3, word);\n\n\t \n\tskbdesc->desc = txd;\n\tskbdesc->desc_len = TXD_DESC_SIZE;\n}\nEXPORT_SYMBOL_GPL(rt2800mmio_write_tx_desc);\n\n \nvoid rt2800mmio_fill_rxdone(struct queue_entry *entry,\n\t\t\t    struct rxdone_entry_desc *rxdesc)\n{\n\tstruct queue_entry_priv_mmio *entry_priv = entry->priv_data;\n\t__le32 *rxd = entry_priv->desc;\n\tu32 word;\n\n\tword = rt2x00_desc_read(rxd, 3);\n\n\tif (rt2x00_get_field32(word, RXD_W3_CRC_ERROR))\n\t\trxdesc->flags |= RX_FLAG_FAILED_FCS_CRC;\n\n\t \n\trxdesc->cipher_status = rt2x00_get_field32(word, RXD_W3_CIPHER_ERROR);\n\n\tif (rt2x00_get_field32(word, RXD_W3_DECRYPTED)) {\n\t\t \n\t\trxdesc->flags |= RX_FLAG_IV_STRIPPED;\n\n\t\t \n\t\trxdesc->flags |= RX_FLAG_MMIC_STRIPPED;\n\n\t\tif (rxdesc->cipher_status == RX_CRYPTO_SUCCESS) {\n\t\t\trxdesc->flags |= RX_FLAG_DECRYPTED;\n\t\t} else if (rxdesc->cipher_status == RX_CRYPTO_FAIL_MIC) {\n\t\t\t \n\t\t\trxdesc->flags |= RX_FLAG_DECRYPTED;\n\n\t\t\trxdesc->flags |= RX_FLAG_MMIC_ERROR;\n\t\t}\n\t}\n\n\tif (rt2x00_get_field32(word, RXD_W3_MY_BSS))\n\t\trxdesc->dev_flags |= RXDONE_MY_BSS;\n\n\tif (rt2x00_get_field32(word, RXD_W3_L2PAD))\n\t\trxdesc->dev_flags |= RXDONE_L2PAD;\n\n\t \n\trt2800_process_rxwi(entry, rxdesc);\n}\nEXPORT_SYMBOL_GPL(rt2800mmio_fill_rxdone);\n\n \nstatic void rt2800mmio_wakeup(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct ieee80211_conf conf = { .flags = 0 };\n\tstruct rt2x00lib_conf libconf = { .conf = &conf };\n\n\trt2800_config(rt2x00dev, &libconf, IEEE80211_CONF_CHANGE_PS);\n}\n\nstatic inline void rt2800mmio_enable_interrupt(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t       struct rt2x00_field32 irq_field)\n{\n\tu32 reg;\n\n\t \n\tspin_lock_irq(&rt2x00dev->irqmask_lock);\n\treg = rt2x00mmio_register_read(rt2x00dev, INT_MASK_CSR);\n\trt2x00_set_field32(&reg, irq_field, 1);\n\trt2x00mmio_register_write(rt2x00dev, INT_MASK_CSR, reg);\n\tspin_unlock_irq(&rt2x00dev->irqmask_lock);\n}\n\nvoid rt2800mmio_pretbtt_tasklet(struct tasklet_struct *t)\n{\n\tstruct rt2x00_dev *rt2x00dev = from_tasklet(rt2x00dev, t,\n\t\t\t\t\t\t    pretbtt_tasklet);\n\trt2x00lib_pretbtt(rt2x00dev);\n\tif (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\trt2800mmio_enable_interrupt(rt2x00dev, INT_MASK_CSR_PRE_TBTT);\n}\nEXPORT_SYMBOL_GPL(rt2800mmio_pretbtt_tasklet);\n\nvoid rt2800mmio_tbtt_tasklet(struct tasklet_struct *t)\n{\n\tstruct rt2x00_dev *rt2x00dev = from_tasklet(rt2x00dev, t, tbtt_tasklet);\n\tstruct rt2800_drv_data *drv_data = rt2x00dev->drv_data;\n\tu32 reg;\n\n\trt2x00lib_beacondone(rt2x00dev);\n\n\tif (rt2x00dev->intf_ap_count) {\n\t\t \n\t\tif (drv_data->tbtt_tick == (BCN_TBTT_OFFSET - 2)) {\n\t\t\treg = rt2x00mmio_register_read(rt2x00dev, BCN_TIME_CFG);\n\t\t\trt2x00_set_field32(&reg, BCN_TIME_CFG_BEACON_INTERVAL,\n\t\t\t\t\t   (rt2x00dev->beacon_int * 16) - 1);\n\t\t\trt2x00mmio_register_write(rt2x00dev, BCN_TIME_CFG, reg);\n\t\t} else if (drv_data->tbtt_tick == (BCN_TBTT_OFFSET - 1)) {\n\t\t\treg = rt2x00mmio_register_read(rt2x00dev, BCN_TIME_CFG);\n\t\t\trt2x00_set_field32(&reg, BCN_TIME_CFG_BEACON_INTERVAL,\n\t\t\t\t\t   (rt2x00dev->beacon_int * 16));\n\t\t\trt2x00mmio_register_write(rt2x00dev, BCN_TIME_CFG, reg);\n\t\t}\n\t\tdrv_data->tbtt_tick++;\n\t\tdrv_data->tbtt_tick %= BCN_TBTT_OFFSET;\n\t}\n\n\tif (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\trt2800mmio_enable_interrupt(rt2x00dev, INT_MASK_CSR_TBTT);\n}\nEXPORT_SYMBOL_GPL(rt2800mmio_tbtt_tasklet);\n\nvoid rt2800mmio_rxdone_tasklet(struct tasklet_struct *t)\n{\n\tstruct rt2x00_dev *rt2x00dev = from_tasklet(rt2x00dev, t,\n\t\t\t\t\t\t    rxdone_tasklet);\n\tif (rt2x00mmio_rxdone(rt2x00dev))\n\t\ttasklet_schedule(&rt2x00dev->rxdone_tasklet);\n\telse if (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\trt2800mmio_enable_interrupt(rt2x00dev, INT_MASK_CSR_RX_DONE);\n}\nEXPORT_SYMBOL_GPL(rt2800mmio_rxdone_tasklet);\n\nvoid rt2800mmio_autowake_tasklet(struct tasklet_struct *t)\n{\n\tstruct rt2x00_dev *rt2x00dev = from_tasklet(rt2x00dev, t,\n\t\t\t\t\t\t    autowake_tasklet);\n\trt2800mmio_wakeup(rt2x00dev);\n\tif (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\trt2800mmio_enable_interrupt(rt2x00dev,\n\t\t\t\t\t    INT_MASK_CSR_AUTO_WAKEUP);\n}\nEXPORT_SYMBOL_GPL(rt2800mmio_autowake_tasklet);\n\nstatic void rt2800mmio_fetch_txstatus(struct rt2x00_dev *rt2x00dev)\n{\n\tu32 status;\n\tunsigned long flags;\n\n\t \n\n\tspin_lock_irqsave(&rt2x00dev->irqmask_lock, flags);\n\n\twhile (!kfifo_is_full(&rt2x00dev->txstatus_fifo)) {\n\t\tstatus = rt2x00mmio_register_read(rt2x00dev, TX_STA_FIFO);\n\t\tif (!rt2x00_get_field32(status, TX_STA_FIFO_VALID))\n\t\t\tbreak;\n\n\t\tkfifo_put(&rt2x00dev->txstatus_fifo, status);\n\t}\n\n\tspin_unlock_irqrestore(&rt2x00dev->irqmask_lock, flags);\n}\n\nvoid rt2800mmio_txstatus_tasklet(struct tasklet_struct *t)\n{\n\tstruct rt2x00_dev *rt2x00dev = from_tasklet(rt2x00dev, t,\n\t\t\t\t\t\t    txstatus_tasklet);\n\n\trt2800_txdone(rt2x00dev, 16);\n\n\tif (!kfifo_is_empty(&rt2x00dev->txstatus_fifo))\n\t\ttasklet_schedule(&rt2x00dev->txstatus_tasklet);\n\n}\nEXPORT_SYMBOL_GPL(rt2800mmio_txstatus_tasklet);\n\nirqreturn_t rt2800mmio_interrupt(int irq, void *dev_instance)\n{\n\tstruct rt2x00_dev *rt2x00dev = dev_instance;\n\tu32 reg, mask;\n\n\t \n\treg = rt2x00mmio_register_read(rt2x00dev, INT_SOURCE_CSR);\n\trt2x00mmio_register_write(rt2x00dev, INT_SOURCE_CSR, reg);\n\n\tif (!reg)\n\t\treturn IRQ_NONE;\n\n\tif (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\treturn IRQ_HANDLED;\n\n\t \n\tmask = ~reg;\n\n\tif (rt2x00_get_field32(reg, INT_SOURCE_CSR_TX_FIFO_STATUS)) {\n\t\trt2x00_set_field32(&mask, INT_MASK_CSR_TX_FIFO_STATUS, 1);\n\t\trt2800mmio_fetch_txstatus(rt2x00dev);\n\t\tif (!kfifo_is_empty(&rt2x00dev->txstatus_fifo))\n\t\t\ttasklet_schedule(&rt2x00dev->txstatus_tasklet);\n\t}\n\n\tif (rt2x00_get_field32(reg, INT_SOURCE_CSR_PRE_TBTT))\n\t\ttasklet_hi_schedule(&rt2x00dev->pretbtt_tasklet);\n\n\tif (rt2x00_get_field32(reg, INT_SOURCE_CSR_TBTT))\n\t\ttasklet_hi_schedule(&rt2x00dev->tbtt_tasklet);\n\n\tif (rt2x00_get_field32(reg, INT_SOURCE_CSR_RX_DONE))\n\t\ttasklet_schedule(&rt2x00dev->rxdone_tasklet);\n\n\tif (rt2x00_get_field32(reg, INT_SOURCE_CSR_AUTO_WAKEUP))\n\t\ttasklet_schedule(&rt2x00dev->autowake_tasklet);\n\n\t \n\tspin_lock(&rt2x00dev->irqmask_lock);\n\treg = rt2x00mmio_register_read(rt2x00dev, INT_MASK_CSR);\n\treg &= mask;\n\trt2x00mmio_register_write(rt2x00dev, INT_MASK_CSR, reg);\n\tspin_unlock(&rt2x00dev->irqmask_lock);\n\n\treturn IRQ_HANDLED;\n}\nEXPORT_SYMBOL_GPL(rt2800mmio_interrupt);\n\nvoid rt2800mmio_toggle_irq(struct rt2x00_dev *rt2x00dev,\n\t\t\t   enum dev_state state)\n{\n\tu32 reg;\n\tunsigned long flags;\n\n\t \n\tif (state == STATE_RADIO_IRQ_ON) {\n\t\treg = rt2x00mmio_register_read(rt2x00dev, INT_SOURCE_CSR);\n\t\trt2x00mmio_register_write(rt2x00dev, INT_SOURCE_CSR, reg);\n\t}\n\n\tspin_lock_irqsave(&rt2x00dev->irqmask_lock, flags);\n\treg = 0;\n\tif (state == STATE_RADIO_IRQ_ON) {\n\t\trt2x00_set_field32(&reg, INT_MASK_CSR_RX_DONE, 1);\n\t\trt2x00_set_field32(&reg, INT_MASK_CSR_TBTT, 1);\n\t\trt2x00_set_field32(&reg, INT_MASK_CSR_PRE_TBTT, 1);\n\t\trt2x00_set_field32(&reg, INT_MASK_CSR_TX_FIFO_STATUS, 1);\n\t\trt2x00_set_field32(&reg, INT_MASK_CSR_AUTO_WAKEUP, 1);\n\t}\n\trt2x00mmio_register_write(rt2x00dev, INT_MASK_CSR, reg);\n\tspin_unlock_irqrestore(&rt2x00dev->irqmask_lock, flags);\n\n\tif (state == STATE_RADIO_IRQ_OFF) {\n\t\t \n\t\ttasklet_kill(&rt2x00dev->txstatus_tasklet);\n\t\ttasklet_kill(&rt2x00dev->rxdone_tasklet);\n\t\ttasklet_kill(&rt2x00dev->autowake_tasklet);\n\t\ttasklet_kill(&rt2x00dev->tbtt_tasklet);\n\t\ttasklet_kill(&rt2x00dev->pretbtt_tasklet);\n\t}\n}\nEXPORT_SYMBOL_GPL(rt2800mmio_toggle_irq);\n\n \nvoid rt2800mmio_start_queue(struct data_queue *queue)\n{\n\tstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\n\tu32 reg;\n\n\tswitch (queue->qid) {\n\tcase QID_RX:\n\t\treg = rt2x00mmio_register_read(rt2x00dev, MAC_SYS_CTRL);\n\t\trt2x00_set_field32(&reg, MAC_SYS_CTRL_ENABLE_RX, 1);\n\t\trt2x00mmio_register_write(rt2x00dev, MAC_SYS_CTRL, reg);\n\t\tbreak;\n\tcase QID_BEACON:\n\t\treg = rt2x00mmio_register_read(rt2x00dev, BCN_TIME_CFG);\n\t\trt2x00_set_field32(&reg, BCN_TIME_CFG_TSF_TICKING, 1);\n\t\trt2x00_set_field32(&reg, BCN_TIME_CFG_TBTT_ENABLE, 1);\n\t\trt2x00_set_field32(&reg, BCN_TIME_CFG_BEACON_GEN, 1);\n\t\trt2x00mmio_register_write(rt2x00dev, BCN_TIME_CFG, reg);\n\n\t\treg = rt2x00mmio_register_read(rt2x00dev, INT_TIMER_EN);\n\t\trt2x00_set_field32(&reg, INT_TIMER_EN_PRE_TBTT_TIMER, 1);\n\t\trt2x00mmio_register_write(rt2x00dev, INT_TIMER_EN, reg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(rt2800mmio_start_queue);\n\n \n#define TXSTATUS_TIMEOUT 200000000\n\nvoid rt2800mmio_kick_queue(struct data_queue *queue)\n{\n\tstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\n\tstruct queue_entry *entry;\n\n\tswitch (queue->qid) {\n\tcase QID_AC_VO:\n\tcase QID_AC_VI:\n\tcase QID_AC_BE:\n\tcase QID_AC_BK:\n\t\tWARN_ON_ONCE(rt2x00queue_empty(queue));\n\t\tentry = rt2x00queue_get_entry(queue, Q_INDEX);\n\t\trt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX(queue->qid),\n\t\t\t\t\t  entry->entry_idx);\n\t\thrtimer_start(&rt2x00dev->txstatus_timer,\n\t\t\t      TXSTATUS_TIMEOUT, HRTIMER_MODE_REL);\n\t\tbreak;\n\tcase QID_MGMT:\n\t\tentry = rt2x00queue_get_entry(queue, Q_INDEX);\n\t\trt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX(5),\n\t\t\t\t\t  entry->entry_idx);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(rt2800mmio_kick_queue);\n\nvoid rt2800mmio_flush_queue(struct data_queue *queue, bool drop)\n{\n\tstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\n\tbool tx_queue = false;\n\tunsigned int i;\n\n\tswitch (queue->qid) {\n\tcase QID_AC_VO:\n\tcase QID_AC_VI:\n\tcase QID_AC_BE:\n\tcase QID_AC_BK:\n\t\ttx_queue = true;\n\t\tbreak;\n\tcase QID_RX:\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 5; i++) {\n\t\t \n\t\tif (rt2x00queue_empty(queue))\n\t\t\tbreak;\n\n\t\t \n\t\tif (tx_queue)\n\t\t\tqueue_work(rt2x00dev->workqueue, &rt2x00dev->txdone_work);\n\n\t\t \n\t\tmsleep(50);\n\t}\n}\nEXPORT_SYMBOL_GPL(rt2800mmio_flush_queue);\n\nvoid rt2800mmio_stop_queue(struct data_queue *queue)\n{\n\tstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\n\tu32 reg;\n\n\tswitch (queue->qid) {\n\tcase QID_RX:\n\t\treg = rt2x00mmio_register_read(rt2x00dev, MAC_SYS_CTRL);\n\t\trt2x00_set_field32(&reg, MAC_SYS_CTRL_ENABLE_RX, 0);\n\t\trt2x00mmio_register_write(rt2x00dev, MAC_SYS_CTRL, reg);\n\t\tbreak;\n\tcase QID_BEACON:\n\t\treg = rt2x00mmio_register_read(rt2x00dev, BCN_TIME_CFG);\n\t\trt2x00_set_field32(&reg, BCN_TIME_CFG_TSF_TICKING, 0);\n\t\trt2x00_set_field32(&reg, BCN_TIME_CFG_TBTT_ENABLE, 0);\n\t\trt2x00_set_field32(&reg, BCN_TIME_CFG_BEACON_GEN, 0);\n\t\trt2x00mmio_register_write(rt2x00dev, BCN_TIME_CFG, reg);\n\n\t\treg = rt2x00mmio_register_read(rt2x00dev, INT_TIMER_EN);\n\t\trt2x00_set_field32(&reg, INT_TIMER_EN_PRE_TBTT_TIMER, 0);\n\t\trt2x00mmio_register_write(rt2x00dev, INT_TIMER_EN, reg);\n\n\t\t \n\t\ttasklet_kill(&rt2x00dev->tbtt_tasklet);\n\t\ttasklet_kill(&rt2x00dev->pretbtt_tasklet);\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(rt2800mmio_stop_queue);\n\nvoid rt2800mmio_queue_init(struct data_queue *queue)\n{\n\tstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\n\tunsigned short txwi_size, rxwi_size;\n\n\trt2800_get_txwi_rxwi_size(rt2x00dev, &txwi_size, &rxwi_size);\n\n\tswitch (queue->qid) {\n\tcase QID_RX:\n\t\tqueue->limit = 128;\n\t\tqueue->data_size = AGGREGATION_SIZE;\n\t\tqueue->desc_size = RXD_DESC_SIZE;\n\t\tqueue->winfo_size = rxwi_size;\n\t\tqueue->priv_size = sizeof(struct queue_entry_priv_mmio);\n\t\tbreak;\n\n\tcase QID_AC_VO:\n\tcase QID_AC_VI:\n\tcase QID_AC_BE:\n\tcase QID_AC_BK:\n\t\tqueue->limit = 64;\n\t\tqueue->data_size = AGGREGATION_SIZE;\n\t\tqueue->desc_size = TXD_DESC_SIZE;\n\t\tqueue->winfo_size = txwi_size;\n\t\tqueue->priv_size = sizeof(struct queue_entry_priv_mmio);\n\t\tbreak;\n\n\tcase QID_BEACON:\n\t\tqueue->limit = 8;\n\t\tqueue->data_size = 0;  \n\t\tqueue->desc_size = TXD_DESC_SIZE;\n\t\tqueue->winfo_size = txwi_size;\n\t\tqueue->priv_size = sizeof(struct queue_entry_priv_mmio);\n\t\tbreak;\n\n\tcase QID_ATIM:\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(rt2800mmio_queue_init);\n\n \nbool rt2800mmio_get_entry_state(struct queue_entry *entry)\n{\n\tstruct queue_entry_priv_mmio *entry_priv = entry->priv_data;\n\tu32 word;\n\n\tif (entry->queue->qid == QID_RX) {\n\t\tword = rt2x00_desc_read(entry_priv->desc, 1);\n\n\t\treturn (!rt2x00_get_field32(word, RXD_W1_DMA_DONE));\n\t} else {\n\t\tword = rt2x00_desc_read(entry_priv->desc, 1);\n\n\t\treturn (!rt2x00_get_field32(word, TXD_W1_DMA_DONE));\n\t}\n}\nEXPORT_SYMBOL_GPL(rt2800mmio_get_entry_state);\n\nvoid rt2800mmio_clear_entry(struct queue_entry *entry)\n{\n\tstruct queue_entry_priv_mmio *entry_priv = entry->priv_data;\n\tstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\n\tstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\n\tu32 word;\n\n\tif (entry->queue->qid == QID_RX) {\n\t\tword = rt2x00_desc_read(entry_priv->desc, 0);\n\t\trt2x00_set_field32(&word, RXD_W0_SDP0, skbdesc->skb_dma);\n\t\trt2x00_desc_write(entry_priv->desc, 0, word);\n\n\t\tword = rt2x00_desc_read(entry_priv->desc, 1);\n\t\trt2x00_set_field32(&word, RXD_W1_DMA_DONE, 0);\n\t\trt2x00_desc_write(entry_priv->desc, 1, word);\n\n\t\t \n\t\trt2x00mmio_register_write(rt2x00dev, RX_CRX_IDX,\n\t\t\t\t\t  entry->entry_idx);\n\t} else {\n\t\tword = rt2x00_desc_read(entry_priv->desc, 1);\n\t\trt2x00_set_field32(&word, TXD_W1_DMA_DONE, 1);\n\t\trt2x00_desc_write(entry_priv->desc, 1, word);\n\n\t\t \n\t\tif (entry->queue->length == 1)\n\t\t\thrtimer_cancel(&rt2x00dev->txstatus_timer);\n\t}\n}\nEXPORT_SYMBOL_GPL(rt2800mmio_clear_entry);\n\nint rt2800mmio_init_queues(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct queue_entry_priv_mmio *entry_priv;\n\n\t \n\tentry_priv = rt2x00dev->tx[0].entries[0].priv_data;\n\trt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR0,\n\t\t\t\t  entry_priv->desc_dma);\n\trt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT0,\n\t\t\t\t  rt2x00dev->tx[0].limit);\n\trt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX0, 0);\n\trt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX0, 0);\n\n\tentry_priv = rt2x00dev->tx[1].entries[0].priv_data;\n\trt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR1,\n\t\t\t\t  entry_priv->desc_dma);\n\trt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT1,\n\t\t\t\t  rt2x00dev->tx[1].limit);\n\trt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX1, 0);\n\trt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX1, 0);\n\n\tentry_priv = rt2x00dev->tx[2].entries[0].priv_data;\n\trt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR2,\n\t\t\t\t  entry_priv->desc_dma);\n\trt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT2,\n\t\t\t\t  rt2x00dev->tx[2].limit);\n\trt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX2, 0);\n\trt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX2, 0);\n\n\tentry_priv = rt2x00dev->tx[3].entries[0].priv_data;\n\trt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR3,\n\t\t\t\t  entry_priv->desc_dma);\n\trt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT3,\n\t\t\t\t  rt2x00dev->tx[3].limit);\n\trt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX3, 0);\n\trt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX3, 0);\n\n\trt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR4, 0);\n\trt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT4, 0);\n\trt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX4, 0);\n\trt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX4, 0);\n\n\trt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR5, 0);\n\trt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT5, 0);\n\trt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX5, 0);\n\trt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX5, 0);\n\n\tentry_priv = rt2x00dev->rx->entries[0].priv_data;\n\trt2x00mmio_register_write(rt2x00dev, RX_BASE_PTR,\n\t\t\t\t  entry_priv->desc_dma);\n\trt2x00mmio_register_write(rt2x00dev, RX_MAX_CNT,\n\t\t\t\t  rt2x00dev->rx[0].limit);\n\trt2x00mmio_register_write(rt2x00dev, RX_CRX_IDX,\n\t\t\t\t  rt2x00dev->rx[0].limit - 1);\n\trt2x00mmio_register_write(rt2x00dev, RX_DRX_IDX, 0);\n\n\trt2800_disable_wpdma(rt2x00dev);\n\n\trt2x00mmio_register_write(rt2x00dev, DELAY_INT_CFG, 0);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rt2800mmio_init_queues);\n\nint rt2800mmio_init_registers(struct rt2x00_dev *rt2x00dev)\n{\n\tu32 reg;\n\n\t \n\treg = rt2x00mmio_register_read(rt2x00dev, WPDMA_RST_IDX);\n\trt2x00_set_field32(&reg, WPDMA_RST_IDX_DTX_IDX0, 1);\n\trt2x00_set_field32(&reg, WPDMA_RST_IDX_DTX_IDX1, 1);\n\trt2x00_set_field32(&reg, WPDMA_RST_IDX_DTX_IDX2, 1);\n\trt2x00_set_field32(&reg, WPDMA_RST_IDX_DTX_IDX3, 1);\n\trt2x00_set_field32(&reg, WPDMA_RST_IDX_DTX_IDX4, 1);\n\trt2x00_set_field32(&reg, WPDMA_RST_IDX_DTX_IDX5, 1);\n\trt2x00_set_field32(&reg, WPDMA_RST_IDX_DRX_IDX0, 1);\n\trt2x00mmio_register_write(rt2x00dev, WPDMA_RST_IDX, reg);\n\n\trt2x00mmio_register_write(rt2x00dev, PBF_SYS_CTRL, 0x00000e1f);\n\trt2x00mmio_register_write(rt2x00dev, PBF_SYS_CTRL, 0x00000e00);\n\n\tif (rt2x00_is_pcie(rt2x00dev) &&\n\t    (rt2x00_rt(rt2x00dev, RT3090) ||\n\t     rt2x00_rt(rt2x00dev, RT3390) ||\n\t     rt2x00_rt(rt2x00dev, RT3572) ||\n\t     rt2x00_rt(rt2x00dev, RT3593) ||\n\t     rt2x00_rt(rt2x00dev, RT5390) ||\n\t     rt2x00_rt(rt2x00dev, RT5392) ||\n\t     rt2x00_rt(rt2x00dev, RT5592))) {\n\t\treg = rt2x00mmio_register_read(rt2x00dev, AUX_CTRL);\n\t\trt2x00_set_field32(&reg, AUX_CTRL_FORCE_PCIE_CLK, 1);\n\t\trt2x00_set_field32(&reg, AUX_CTRL_WAKE_PCIE_EN, 1);\n\t\trt2x00mmio_register_write(rt2x00dev, AUX_CTRL, reg);\n\t}\n\n\trt2x00mmio_register_write(rt2x00dev, PWR_PIN_CFG, 0x00000003);\n\n\treg = 0;\n\trt2x00_set_field32(&reg, MAC_SYS_CTRL_RESET_CSR, 1);\n\trt2x00_set_field32(&reg, MAC_SYS_CTRL_RESET_BBP, 1);\n\trt2x00mmio_register_write(rt2x00dev, MAC_SYS_CTRL, reg);\n\n\trt2x00mmio_register_write(rt2x00dev, MAC_SYS_CTRL, 0x00000000);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rt2800mmio_init_registers);\n\n \nint rt2800mmio_enable_radio(struct rt2x00_dev *rt2x00dev)\n{\n\t \n\trt2800_wait_wpdma_ready(rt2x00dev);\n\n\tif (unlikely(rt2800mmio_init_queues(rt2x00dev)))\n\t\treturn -EIO;\n\n\treturn rt2800_enable_radio(rt2x00dev);\n}\nEXPORT_SYMBOL_GPL(rt2800mmio_enable_radio);\n\nstatic void rt2800mmio_work_txdone(struct work_struct *work)\n{\n\tstruct rt2x00_dev *rt2x00dev =\n\t    container_of(work, struct rt2x00_dev, txdone_work);\n\n\tif (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\treturn;\n\n\twhile (!kfifo_is_empty(&rt2x00dev->txstatus_fifo) ||\n\t       rt2800_txstatus_timeout(rt2x00dev)) {\n\n\t\ttasklet_disable(&rt2x00dev->txstatus_tasklet);\n\t\trt2800_txdone(rt2x00dev, UINT_MAX);\n\t\trt2800_txdone_nostatus(rt2x00dev);\n\t\ttasklet_enable(&rt2x00dev->txstatus_tasklet);\n\t}\n\n\tif (rt2800_txstatus_pending(rt2x00dev))\n\t\thrtimer_start(&rt2x00dev->txstatus_timer,\n\t\t\t      TXSTATUS_TIMEOUT, HRTIMER_MODE_REL);\n}\n\nstatic enum hrtimer_restart rt2800mmio_tx_sta_fifo_timeout(struct hrtimer *timer)\n{\n\tstruct rt2x00_dev *rt2x00dev =\n\t    container_of(timer, struct rt2x00_dev, txstatus_timer);\n\n\tif (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\tgoto out;\n\n\tif (!rt2800_txstatus_pending(rt2x00dev))\n\t\tgoto out;\n\n\trt2800mmio_fetch_txstatus(rt2x00dev);\n\tif (!kfifo_is_empty(&rt2x00dev->txstatus_fifo))\n\t\ttasklet_schedule(&rt2x00dev->txstatus_tasklet);\n\telse\n\t\tqueue_work(rt2x00dev->workqueue, &rt2x00dev->txdone_work);\nout:\n\treturn HRTIMER_NORESTART;\n}\n\nint rt2800mmio_probe_hw(struct rt2x00_dev *rt2x00dev)\n{\n\tint retval;\n\n\tretval = rt2800_probe_hw(rt2x00dev);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\trt2x00dev->txstatus_timer.function = rt2800mmio_tx_sta_fifo_timeout;\n\n\t \n\tINIT_WORK(&rt2x00dev->txdone_work, rt2800mmio_work_txdone);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rt2800mmio_probe_hw);\n\nMODULE_AUTHOR(DRV_PROJECT);\nMODULE_VERSION(DRV_VERSION);\nMODULE_DESCRIPTION(\"rt2800 MMIO library\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}