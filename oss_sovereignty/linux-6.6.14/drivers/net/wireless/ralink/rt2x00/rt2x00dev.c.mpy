{
  "module_name": "rt2x00dev.c",
  "hash_id": "065da681fb9dca690f9a652722d68229652516151a629acbe68a042327ece9a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/log2.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n\n#include \"rt2x00.h\"\n#include \"rt2x00lib.h\"\n\n \nu32 rt2x00lib_get_bssidx(struct rt2x00_dev *rt2x00dev,\n\t\t\t struct ieee80211_vif *vif)\n{\n\t \n\tif (rt2x00dev->intf_sta_count)\n\t\treturn 0;\n\treturn vif->addr[5] & (rt2x00dev->ops->max_ap_intf - 1);\n}\nEXPORT_SYMBOL_GPL(rt2x00lib_get_bssidx);\n\n \nint rt2x00lib_enable_radio(struct rt2x00_dev *rt2x00dev)\n{\n\tint status;\n\n\t \n\tif (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\treturn 0;\n\n\t \n\trt2x00queue_init_queues(rt2x00dev);\n\n\t \n\tstatus =\n\t    rt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_RADIO_ON);\n\tif (status)\n\t\treturn status;\n\n\trt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_RADIO_IRQ_ON);\n\n\trt2x00leds_led_radio(rt2x00dev, true);\n\trt2x00led_led_activity(rt2x00dev, true);\n\n\tset_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags);\n\n\t \n\trt2x00queue_start_queues(rt2x00dev);\n\trt2x00link_start_tuner(rt2x00dev);\n\n\t \n\trt2x00link_start_watchdog(rt2x00dev);\n\n\treturn 0;\n}\n\nvoid rt2x00lib_disable_radio(struct rt2x00_dev *rt2x00dev)\n{\n\tif (!test_and_clear_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\treturn;\n\n\t \n\trt2x00link_stop_watchdog(rt2x00dev);\n\n\t \n\trt2x00link_stop_tuner(rt2x00dev);\n\trt2x00queue_stop_queues(rt2x00dev);\n\trt2x00queue_flush_queues(rt2x00dev, true);\n\n\t \n\trt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_RADIO_OFF);\n\trt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_RADIO_IRQ_OFF);\n\trt2x00led_led_activity(rt2x00dev, false);\n\trt2x00leds_led_radio(rt2x00dev, false);\n}\n\nstatic void rt2x00lib_intf_scheduled_iter(void *data, u8 *mac,\n\t\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct rt2x00_dev *rt2x00dev = data;\n\tstruct rt2x00_intf *intf = vif_to_intf(vif);\n\n\t \n\tif (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\treturn;\n\n\tif (test_and_clear_bit(DELAYED_UPDATE_BEACON, &intf->delayed_flags)) {\n\t\tmutex_lock(&intf->beacon_skb_mutex);\n\t\trt2x00queue_update_beacon(rt2x00dev, vif);\n\t\tmutex_unlock(&intf->beacon_skb_mutex);\n\t}\n}\n\nstatic void rt2x00lib_intf_scheduled(struct work_struct *work)\n{\n\tstruct rt2x00_dev *rt2x00dev =\n\t    container_of(work, struct rt2x00_dev, intf_work);\n\n\t \n\tieee80211_iterate_active_interfaces(rt2x00dev->hw,\n\t\t\t\t\t    IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\t\t\t    rt2x00lib_intf_scheduled_iter,\n\t\t\t\t\t    rt2x00dev);\n}\n\nstatic void rt2x00lib_autowakeup(struct work_struct *work)\n{\n\tstruct rt2x00_dev *rt2x00dev =\n\t    container_of(work, struct rt2x00_dev, autowakeup_work.work);\n\n\tif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\n\t\treturn;\n\n\tif (rt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_AWAKE))\n\t\trt2x00_err(rt2x00dev, \"Device failed to wakeup\\n\");\n\tclear_bit(CONFIG_POWERSAVING, &rt2x00dev->flags);\n}\n\n \nstatic void rt2x00lib_bc_buffer_iter(void *data, u8 *mac,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_tx_control control = {};\n\tstruct rt2x00_dev *rt2x00dev = data;\n\tstruct sk_buff *skb;\n\n\t \n\tif (vif->type != NL80211_IFTYPE_AP)\n\t\treturn;\n\n\t \n\tskb = ieee80211_get_buffered_bc(rt2x00dev->hw, vif);\n\twhile (skb) {\n\t\trt2x00mac_tx(rt2x00dev->hw, &control, skb);\n\t\tskb = ieee80211_get_buffered_bc(rt2x00dev->hw, vif);\n\t}\n}\n\nstatic void rt2x00lib_beaconupdate_iter(void *data, u8 *mac,\n\t\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct rt2x00_dev *rt2x00dev = data;\n\n\tif (vif->type != NL80211_IFTYPE_AP &&\n\t    vif->type != NL80211_IFTYPE_ADHOC &&\n\t    vif->type != NL80211_IFTYPE_MESH_POINT)\n\t\treturn;\n\n\t \n\tWARN_ON(rt2x00_is_usb(rt2x00dev));\n\trt2x00queue_update_beacon(rt2x00dev, vif);\n}\n\nvoid rt2x00lib_beacondone(struct rt2x00_dev *rt2x00dev)\n{\n\tif (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\treturn;\n\n\t \n\tieee80211_iterate_active_interfaces_atomic(\n\t\trt2x00dev->hw, IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\trt2x00lib_bc_buffer_iter, rt2x00dev);\n\t \n\tif (rt2x00_has_cap_pre_tbtt_interrupt(rt2x00dev))\n\t\treturn;\n\n\t \n\tieee80211_iterate_active_interfaces_atomic(\n\t\trt2x00dev->hw, IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\trt2x00lib_beaconupdate_iter, rt2x00dev);\n}\nEXPORT_SYMBOL_GPL(rt2x00lib_beacondone);\n\nvoid rt2x00lib_pretbtt(struct rt2x00_dev *rt2x00dev)\n{\n\tif (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\treturn;\n\n\t \n\tieee80211_iterate_active_interfaces_atomic(\n\t\trt2x00dev->hw, IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\trt2x00lib_beaconupdate_iter, rt2x00dev);\n}\nEXPORT_SYMBOL_GPL(rt2x00lib_pretbtt);\n\nvoid rt2x00lib_dmastart(struct queue_entry *entry)\n{\n\tset_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags);\n\trt2x00queue_index_inc(entry, Q_INDEX);\n}\nEXPORT_SYMBOL_GPL(rt2x00lib_dmastart);\n\nvoid rt2x00lib_dmadone(struct queue_entry *entry)\n{\n\tset_bit(ENTRY_DATA_STATUS_PENDING, &entry->flags);\n\tclear_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags);\n\trt2x00queue_index_inc(entry, Q_INDEX_DMA_DONE);\n}\nEXPORT_SYMBOL_GPL(rt2x00lib_dmadone);\n\nstatic inline int rt2x00lib_txdone_bar_status(struct queue_entry *entry)\n{\n\tstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\n\tstruct ieee80211_bar *bar = (void *) entry->skb->data;\n\tstruct rt2x00_bar_list_entry *bar_entry;\n\tint ret;\n\n\tif (likely(!ieee80211_is_back_req(bar->frame_control)))\n\t\treturn 0;\n\n\t \n\tret = 0;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(bar_entry, &rt2x00dev->bar_list, list) {\n\t\tif (bar_entry->entry != entry)\n\t\t\tcontinue;\n\n\t\tspin_lock_bh(&rt2x00dev->bar_list_lock);\n\t\t \n\t\tret = bar_entry->block_acked;\n\t\t \n\t\tlist_del_rcu(&bar_entry->list);\n\t\tspin_unlock_bh(&rt2x00dev->bar_list_lock);\n\t\tkfree_rcu(bar_entry, head);\n\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nstatic void rt2x00lib_fill_tx_status(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t     struct ieee80211_tx_info *tx_info,\n\t\t\t\t     struct skb_frame_desc *skbdesc,\n\t\t\t\t     struct txdone_entry_desc *txdesc,\n\t\t\t\t     bool success)\n{\n\tu8 rate_idx, rate_flags, retry_rates;\n\tint i;\n\n\trate_idx = skbdesc->tx_rate_idx;\n\trate_flags = skbdesc->tx_rate_flags;\n\tretry_rates = test_bit(TXDONE_FALLBACK, &txdesc->flags) ?\n\t    (txdesc->retry + 1) : 1;\n\n\t \n\tmemset(&tx_info->status, 0, sizeof(tx_info->status));\n\ttx_info->status.ack_signal = 0;\n\n\t \n\tfor (i = 0; i < retry_rates && i < IEEE80211_TX_MAX_RATES; i++) {\n\t\ttx_info->status.rates[i].idx = rate_idx - i;\n\t\ttx_info->status.rates[i].flags = rate_flags;\n\n\t\tif (rate_idx - i == 0) {\n\t\t\t \n\t\t\ttx_info->status.rates[i].count = retry_rates - i;\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\ttx_info->status.rates[i].count = 1;\n\t}\n\tif (i < (IEEE80211_TX_MAX_RATES - 1))\n\t\ttx_info->status.rates[i].idx = -1;  \n\n\tif (test_bit(TXDONE_NO_ACK_REQ, &txdesc->flags))\n\t\ttx_info->flags |= IEEE80211_TX_CTL_NO_ACK;\n\n\tif (!(tx_info->flags & IEEE80211_TX_CTL_NO_ACK)) {\n\t\tif (success)\n\t\t\ttx_info->flags |= IEEE80211_TX_STAT_ACK;\n\t\telse\n\t\t\trt2x00dev->low_level_stats.dot11ACKFailureCount++;\n\t}\n\n\t \n\tif (test_bit(TXDONE_AMPDU, &txdesc->flags) ||\n\t    tx_info->flags & IEEE80211_TX_CTL_AMPDU) {\n\t\ttx_info->flags |= IEEE80211_TX_STAT_AMPDU |\n\t\t\t\t  IEEE80211_TX_CTL_AMPDU;\n\t\ttx_info->status.ampdu_len = 1;\n\t\ttx_info->status.ampdu_ack_len = success ? 1 : 0;\n\t}\n\n\tif (rate_flags & IEEE80211_TX_RC_USE_RTS_CTS) {\n\t\tif (success)\n\t\t\trt2x00dev->low_level_stats.dot11RTSSuccessCount++;\n\t\telse\n\t\t\trt2x00dev->low_level_stats.dot11RTSFailureCount++;\n\t}\n}\n\nstatic void rt2x00lib_clear_entry(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t  struct queue_entry *entry)\n{\n\t \n\tentry->skb = NULL;\n\tentry->flags = 0;\n\n\trt2x00dev->ops->lib->clear_entry(entry);\n\n\trt2x00queue_index_inc(entry, Q_INDEX_DONE);\n\n\t \n\tspin_lock_bh(&entry->queue->tx_lock);\n\tif (!rt2x00queue_threshold(entry->queue))\n\t\trt2x00queue_unpause_queue(entry->queue);\n\tspin_unlock_bh(&entry->queue->tx_lock);\n}\n\nvoid rt2x00lib_txdone_nomatch(struct queue_entry *entry,\n\t\t\t      struct txdone_entry_desc *txdesc)\n{\n\tstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\n\tstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\n\tstruct ieee80211_tx_info txinfo = {};\n\tbool success;\n\n\t \n\trt2x00queue_unmap_skb(entry);\n\n\t \n\tskbdesc->flags &= ~SKBDESC_DESC_IN_SKB;\n\n\t \n\trt2x00debug_dump_frame(rt2x00dev, DUMP_FRAME_TXDONE, entry);\n\n\t \n\tsuccess =\n\t    rt2x00lib_txdone_bar_status(entry) ||\n\t    test_bit(TXDONE_SUCCESS, &txdesc->flags);\n\n\tif (!test_bit(TXDONE_UNKNOWN, &txdesc->flags)) {\n\t\t \n\t\trt2x00dev->link.qual.tx_success += success;\n\t\trt2x00dev->link.qual.tx_failed += !success;\n\n\t\trt2x00lib_fill_tx_status(rt2x00dev, &txinfo, skbdesc, txdesc,\n\t\t\t\t\t success);\n\t\tieee80211_tx_status_noskb(rt2x00dev->hw, skbdesc->sta, &txinfo);\n\t}\n\n\tdev_kfree_skb_any(entry->skb);\n\trt2x00lib_clear_entry(rt2x00dev, entry);\n}\nEXPORT_SYMBOL_GPL(rt2x00lib_txdone_nomatch);\n\nvoid rt2x00lib_txdone(struct queue_entry *entry,\n\t\t      struct txdone_entry_desc *txdesc)\n{\n\tstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(entry->skb);\n\tstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\n\tu8 skbdesc_flags = skbdesc->flags;\n\tunsigned int header_length;\n\tbool success;\n\n\t \n\trt2x00queue_unmap_skb(entry);\n\n\t \n\tskb_pull(entry->skb, rt2x00dev->extra_tx_headroom);\n\n\t \n\tskbdesc->flags &= ~SKBDESC_DESC_IN_SKB;\n\n\t \n\theader_length = ieee80211_get_hdrlen_from_skb(entry->skb);\n\n\t \n\tif (rt2x00_has_cap_flag(rt2x00dev, REQUIRE_L2PAD))\n\t\trt2x00queue_remove_l2pad(entry->skb, header_length);\n\n\t \n\tif (rt2x00_has_cap_hw_crypto(rt2x00dev))\n\t\trt2x00crypto_tx_insert_iv(entry->skb, header_length);\n\n\t \n\trt2x00debug_dump_frame(rt2x00dev, DUMP_FRAME_TXDONE, entry);\n\n\t \n\tsuccess =\n\t    rt2x00lib_txdone_bar_status(entry) ||\n\t    test_bit(TXDONE_SUCCESS, &txdesc->flags) ||\n\t    test_bit(TXDONE_UNKNOWN, &txdesc->flags);\n\n\t \n\trt2x00dev->link.qual.tx_success += success;\n\trt2x00dev->link.qual.tx_failed += !success;\n\n\trt2x00lib_fill_tx_status(rt2x00dev, tx_info, skbdesc, txdesc, success);\n\n\t \n\tif (!(skbdesc_flags & SKBDESC_NOT_MAC80211)) {\n\t\tif (rt2x00_has_cap_flag(rt2x00dev, REQUIRE_TASKLET_CONTEXT))\n\t\t\tieee80211_tx_status(rt2x00dev->hw, entry->skb);\n\t\telse\n\t\t\tieee80211_tx_status_ni(rt2x00dev->hw, entry->skb);\n\t} else {\n\t\tdev_kfree_skb_any(entry->skb);\n\t}\n\n\trt2x00lib_clear_entry(rt2x00dev, entry);\n}\nEXPORT_SYMBOL_GPL(rt2x00lib_txdone);\n\nvoid rt2x00lib_txdone_noinfo(struct queue_entry *entry, u32 status)\n{\n\tstruct txdone_entry_desc txdesc;\n\n\ttxdesc.flags = 0;\n\t__set_bit(status, &txdesc.flags);\n\ttxdesc.retry = 0;\n\n\trt2x00lib_txdone(entry, &txdesc);\n}\nEXPORT_SYMBOL_GPL(rt2x00lib_txdone_noinfo);\n\nstatic u8 *rt2x00lib_find_ie(u8 *data, unsigned int len, u8 ie)\n{\n\tstruct ieee80211_mgmt *mgmt = (void *)data;\n\tu8 *pos, *end;\n\n\tpos = (u8 *)mgmt->u.beacon.variable;\n\tend = data + len;\n\twhile (pos < end) {\n\t\tif (pos + 2 + pos[1] > end)\n\t\t\treturn NULL;\n\n\t\tif (pos[0] == ie)\n\t\t\treturn pos;\n\n\t\tpos += 2 + pos[1];\n\t}\n\n\treturn NULL;\n}\n\nstatic void rt2x00lib_sleep(struct work_struct *work)\n{\n\tstruct rt2x00_dev *rt2x00dev =\n\t    container_of(work, struct rt2x00_dev, sleep_work);\n\n\tif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\n\t\treturn;\n\n\t \n\tif (!test_bit(CONFIG_POWERSAVING, &rt2x00dev->flags))\n\t\trt2x00lib_config(rt2x00dev, &rt2x00dev->hw->conf,\n\t\t\t\t IEEE80211_CONF_CHANGE_PS);\n}\n\nstatic void rt2x00lib_rxdone_check_ba(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      struct rxdone_entry_desc *rxdesc)\n{\n\tstruct rt2x00_bar_list_entry *entry;\n\tstruct ieee80211_bar *ba = (void *)skb->data;\n\n\tif (likely(!ieee80211_is_back(ba->frame_control)))\n\t\treturn;\n\n\tif (rxdesc->size < sizeof(*ba) + FCS_LEN)\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(entry, &rt2x00dev->bar_list, list) {\n\n\t\tif (ba->start_seq_num != entry->start_seq_num)\n\t\t\tcontinue;\n\n#define TID_CHECK(a, b) (\t\t\t\t\t\t\\\n\t((a) & cpu_to_le16(IEEE80211_BAR_CTRL_TID_INFO_MASK)) ==\t\\\n\t((b) & cpu_to_le16(IEEE80211_BAR_CTRL_TID_INFO_MASK)))\t\t\\\n\n\t\tif (!TID_CHECK(ba->control, entry->control))\n\t\t\tcontinue;\n\n#undef TID_CHECK\n\n\t\tif (!ether_addr_equal_64bits(ba->ra, entry->ta))\n\t\t\tcontinue;\n\n\t\tif (!ether_addr_equal_64bits(ba->ta, entry->ra))\n\t\t\tcontinue;\n\n\t\t \n\t\tspin_lock_bh(&rt2x00dev->bar_list_lock);\n\t\tentry->block_acked = 1;\n\t\tspin_unlock_bh(&rt2x00dev->bar_list_lock);\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n}\n\nstatic void rt2x00lib_rxdone_check_ps(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      struct rxdone_entry_desc *rxdesc)\n{\n\tstruct ieee80211_hdr *hdr = (void *) skb->data;\n\tstruct ieee80211_tim_ie *tim_ie;\n\tu8 *tim;\n\tu8 tim_len;\n\tbool cam;\n\n\t \n\tif (likely(!ieee80211_is_beacon(hdr->frame_control) ||\n\t\t   !(rt2x00dev->hw->conf.flags & IEEE80211_CONF_PS)))\n\t\treturn;\n\n\t \n\tif (skb->len <= 40 + FCS_LEN)\n\t\treturn;\n\n\t \n\tif (!(rxdesc->dev_flags & RXDONE_MY_BSS) ||\n\t    !rt2x00dev->aid)\n\t\treturn;\n\n\trt2x00dev->last_beacon = jiffies;\n\n\ttim = rt2x00lib_find_ie(skb->data, skb->len - FCS_LEN, WLAN_EID_TIM);\n\tif (!tim)\n\t\treturn;\n\n\tif (tim[1] < sizeof(*tim_ie))\n\t\treturn;\n\n\ttim_len = tim[1];\n\ttim_ie = (struct ieee80211_tim_ie *) &tim[2];\n\n\t \n\n\t \n\tcam = ieee80211_check_tim(tim_ie, tim_len, rt2x00dev->aid);\n\n\t \n\tcam |= (tim_ie->bitmap_ctrl & 0x01);\n\n\tif (!cam && !test_bit(CONFIG_POWERSAVING, &rt2x00dev->flags))\n\t\tqueue_work(rt2x00dev->workqueue, &rt2x00dev->sleep_work);\n}\n\nstatic int rt2x00lib_rxdone_read_signal(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\tstruct rxdone_entry_desc *rxdesc)\n{\n\tstruct ieee80211_supported_band *sband;\n\tconst struct rt2x00_rate *rate;\n\tunsigned int i;\n\tint signal = rxdesc->signal;\n\tint type = (rxdesc->dev_flags & RXDONE_SIGNAL_MASK);\n\n\tswitch (rxdesc->rate_mode) {\n\tcase RATE_MODE_CCK:\n\tcase RATE_MODE_OFDM:\n\t\t \n\t\tif (rxdesc->dev_flags & RXDONE_SIGNAL_MCS)\n\t\t\tsignal = RATE_MCS(rxdesc->rate_mode, signal);\n\n\t\tsband = &rt2x00dev->bands[rt2x00dev->curr_band];\n\t\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\t\trate = rt2x00_get_rate(sband->bitrates[i].hw_value);\n\t\t\tif (((type == RXDONE_SIGNAL_PLCP) &&\n\t\t\t     (rate->plcp == signal)) ||\n\t\t\t    ((type == RXDONE_SIGNAL_BITRATE) &&\n\t\t\t      (rate->bitrate == signal)) ||\n\t\t\t    ((type == RXDONE_SIGNAL_MCS) &&\n\t\t\t      (rate->mcs == signal))) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase RATE_MODE_HT_MIX:\n\tcase RATE_MODE_HT_GREENFIELD:\n\t\tif (signal >= 0 && signal <= 76)\n\t\t\treturn signal;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\trt2x00_warn(rt2x00dev, \"Frame received with unrecognized signal, mode=0x%.4x, signal=0x%.4x, type=%d\\n\",\n\t\t    rxdesc->rate_mode, signal, type);\n\treturn 0;\n}\n\nvoid rt2x00lib_rxdone(struct queue_entry *entry, gfp_t gfp)\n{\n\tstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\n\tstruct rxdone_entry_desc rxdesc;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_rx_status *rx_status;\n\tunsigned int header_length;\n\tint rate_idx;\n\n\tif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags) ||\n\t    !test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\tgoto submit_entry;\n\n\tif (test_bit(ENTRY_DATA_IO_FAILED, &entry->flags))\n\t\tgoto submit_entry;\n\n\t \n\tskb = rt2x00queue_alloc_rxskb(entry, gfp);\n\tif (!skb)\n\t\tgoto submit_entry;\n\n\t \n\trt2x00queue_unmap_skb(entry);\n\n\t \n\tmemset(&rxdesc, 0, sizeof(rxdesc));\n\trt2x00dev->ops->lib->fill_rxdone(entry, &rxdesc);\n\n\t \n\tif (unlikely(rxdesc.size == 0 ||\n\t\t     rxdesc.size > entry->queue->data_size)) {\n\t\trt2x00_err(rt2x00dev, \"Wrong frame size %d max %d\\n\",\n\t\t\t   rxdesc.size, entry->queue->data_size);\n\t\tdev_kfree_skb(entry->skb);\n\t\tgoto renew_skb;\n\t}\n\n\t \n\theader_length = ieee80211_get_hdrlen_from_skb(entry->skb);\n\n\t \n\tif ((rxdesc.dev_flags & RXDONE_CRYPTO_IV) &&\n\t    (rxdesc.flags & RX_FLAG_IV_STRIPPED))\n\t\trt2x00crypto_rx_insert_iv(entry->skb, header_length,\n\t\t\t\t\t  &rxdesc);\n\telse if (header_length &&\n\t\t (rxdesc.size > header_length) &&\n\t\t (rxdesc.dev_flags & RXDONE_L2PAD))\n\t\trt2x00queue_remove_l2pad(entry->skb, header_length);\n\n\t \n\tskb_trim(entry->skb, rxdesc.size);\n\n\t \n\trate_idx = rt2x00lib_rxdone_read_signal(rt2x00dev, &rxdesc);\n\tif (rxdesc.rate_mode == RATE_MODE_HT_MIX ||\n\t    rxdesc.rate_mode == RATE_MODE_HT_GREENFIELD)\n\t\trxdesc.encoding = RX_ENC_HT;\n\n\t \n\trt2x00lib_rxdone_check_ps(rt2x00dev, entry->skb, &rxdesc);\n\n\t \n\trt2x00lib_rxdone_check_ba(rt2x00dev, entry->skb, &rxdesc);\n\n\t \n\trt2x00link_update_stats(rt2x00dev, entry->skb, &rxdesc);\n\trt2x00debug_update_crypto(rt2x00dev, &rxdesc);\n\trt2x00debug_dump_frame(rt2x00dev, DUMP_FRAME_RXDONE, entry);\n\n\t \n\trx_status = IEEE80211_SKB_RXCB(entry->skb);\n\n\t \n\tmemset(rx_status, 0, sizeof(*rx_status));\n\n\trx_status->mactime = rxdesc.timestamp;\n\trx_status->band = rt2x00dev->curr_band;\n\trx_status->freq = rt2x00dev->curr_freq;\n\trx_status->rate_idx = rate_idx;\n\trx_status->signal = rxdesc.rssi;\n\trx_status->flag = rxdesc.flags;\n\trx_status->enc_flags = rxdesc.enc_flags;\n\trx_status->encoding = rxdesc.encoding;\n\trx_status->bw = rxdesc.bw;\n\trx_status->antenna = rt2x00dev->link.ant.active.rx;\n\n\tieee80211_rx_ni(rt2x00dev->hw, entry->skb);\n\nrenew_skb:\n\t \n\tentry->skb = skb;\n\nsubmit_entry:\n\tentry->flags = 0;\n\trt2x00queue_index_inc(entry, Q_INDEX_DONE);\n\tif (test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags) &&\n\t    test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\n\t\trt2x00dev->ops->lib->clear_entry(entry);\n}\nEXPORT_SYMBOL_GPL(rt2x00lib_rxdone);\n\n \nconst struct rt2x00_rate rt2x00_supported_rates[12] = {\n\t{\n\t\t.flags = DEV_RATE_CCK,\n\t\t.bitrate = 10,\n\t\t.ratemask = BIT(0),\n\t\t.plcp = 0x00,\n\t\t.mcs = RATE_MCS(RATE_MODE_CCK, 0),\n\t},\n\t{\n\t\t.flags = DEV_RATE_CCK | DEV_RATE_SHORT_PREAMBLE,\n\t\t.bitrate = 20,\n\t\t.ratemask = BIT(1),\n\t\t.plcp = 0x01,\n\t\t.mcs = RATE_MCS(RATE_MODE_CCK, 1),\n\t},\n\t{\n\t\t.flags = DEV_RATE_CCK | DEV_RATE_SHORT_PREAMBLE,\n\t\t.bitrate = 55,\n\t\t.ratemask = BIT(2),\n\t\t.plcp = 0x02,\n\t\t.mcs = RATE_MCS(RATE_MODE_CCK, 2),\n\t},\n\t{\n\t\t.flags = DEV_RATE_CCK | DEV_RATE_SHORT_PREAMBLE,\n\t\t.bitrate = 110,\n\t\t.ratemask = BIT(3),\n\t\t.plcp = 0x03,\n\t\t.mcs = RATE_MCS(RATE_MODE_CCK, 3),\n\t},\n\t{\n\t\t.flags = DEV_RATE_OFDM,\n\t\t.bitrate = 60,\n\t\t.ratemask = BIT(4),\n\t\t.plcp = 0x0b,\n\t\t.mcs = RATE_MCS(RATE_MODE_OFDM, 0),\n\t},\n\t{\n\t\t.flags = DEV_RATE_OFDM,\n\t\t.bitrate = 90,\n\t\t.ratemask = BIT(5),\n\t\t.plcp = 0x0f,\n\t\t.mcs = RATE_MCS(RATE_MODE_OFDM, 1),\n\t},\n\t{\n\t\t.flags = DEV_RATE_OFDM,\n\t\t.bitrate = 120,\n\t\t.ratemask = BIT(6),\n\t\t.plcp = 0x0a,\n\t\t.mcs = RATE_MCS(RATE_MODE_OFDM, 2),\n\t},\n\t{\n\t\t.flags = DEV_RATE_OFDM,\n\t\t.bitrate = 180,\n\t\t.ratemask = BIT(7),\n\t\t.plcp = 0x0e,\n\t\t.mcs = RATE_MCS(RATE_MODE_OFDM, 3),\n\t},\n\t{\n\t\t.flags = DEV_RATE_OFDM,\n\t\t.bitrate = 240,\n\t\t.ratemask = BIT(8),\n\t\t.plcp = 0x09,\n\t\t.mcs = RATE_MCS(RATE_MODE_OFDM, 4),\n\t},\n\t{\n\t\t.flags = DEV_RATE_OFDM,\n\t\t.bitrate = 360,\n\t\t.ratemask = BIT(9),\n\t\t.plcp = 0x0d,\n\t\t.mcs = RATE_MCS(RATE_MODE_OFDM, 5),\n\t},\n\t{\n\t\t.flags = DEV_RATE_OFDM,\n\t\t.bitrate = 480,\n\t\t.ratemask = BIT(10),\n\t\t.plcp = 0x08,\n\t\t.mcs = RATE_MCS(RATE_MODE_OFDM, 6),\n\t},\n\t{\n\t\t.flags = DEV_RATE_OFDM,\n\t\t.bitrate = 540,\n\t\t.ratemask = BIT(11),\n\t\t.plcp = 0x0c,\n\t\t.mcs = RATE_MCS(RATE_MODE_OFDM, 7),\n\t},\n};\n\nstatic void rt2x00lib_channel(struct ieee80211_channel *entry,\n\t\t\t      const int channel, const int tx_power,\n\t\t\t      const int value)\n{\n\t \n\tentry->band = channel <= 14 ? NL80211_BAND_2GHZ : NL80211_BAND_5GHZ;\n\tentry->center_freq = ieee80211_channel_to_frequency(channel,\n\t\t\t\t\t\t\t    entry->band);\n\tentry->hw_value = value;\n\tentry->max_power = tx_power;\n\tentry->max_antenna_gain = 0xff;\n}\n\nstatic void rt2x00lib_rate(struct ieee80211_rate *entry,\n\t\t\t   const u16 index, const struct rt2x00_rate *rate)\n{\n\tentry->flags = 0;\n\tentry->bitrate = rate->bitrate;\n\tentry->hw_value = index;\n\tentry->hw_value_short = index;\n\n\tif (rate->flags & DEV_RATE_SHORT_PREAMBLE)\n\t\tentry->flags |= IEEE80211_RATE_SHORT_PREAMBLE;\n}\n\nvoid rt2x00lib_set_mac_address(struct rt2x00_dev *rt2x00dev, u8 *eeprom_mac_addr)\n{\n\tof_get_mac_address(rt2x00dev->dev->of_node, eeprom_mac_addr);\n\n\tif (!is_valid_ether_addr(eeprom_mac_addr)) {\n\t\teth_random_addr(eeprom_mac_addr);\n\t\trt2x00_eeprom_dbg(rt2x00dev, \"MAC: %pM\\n\", eeprom_mac_addr);\n\t}\n}\nEXPORT_SYMBOL_GPL(rt2x00lib_set_mac_address);\n\nstatic int rt2x00lib_probe_hw_modes(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t    struct hw_mode_spec *spec)\n{\n\tstruct ieee80211_hw *hw = rt2x00dev->hw;\n\tstruct ieee80211_channel *channels;\n\tstruct ieee80211_rate *rates;\n\tunsigned int num_rates;\n\tunsigned int i;\n\n\tnum_rates = 0;\n\tif (spec->supported_rates & SUPPORT_RATE_CCK)\n\t\tnum_rates += 4;\n\tif (spec->supported_rates & SUPPORT_RATE_OFDM)\n\t\tnum_rates += 8;\n\n\tchannels = kcalloc(spec->num_channels, sizeof(*channels), GFP_KERNEL);\n\tif (!channels)\n\t\treturn -ENOMEM;\n\n\trates = kcalloc(num_rates, sizeof(*rates), GFP_KERNEL);\n\tif (!rates)\n\t\tgoto exit_free_channels;\n\n\t \n\tfor (i = 0; i < num_rates; i++)\n\t\trt2x00lib_rate(&rates[i], i, rt2x00_get_rate(i));\n\n\t \n\tfor (i = 0; i < spec->num_channels; i++) {\n\t\trt2x00lib_channel(&channels[i],\n\t\t\t\t  spec->channels[i].channel,\n\t\t\t\t  spec->channels_info[i].max_power, i);\n\t}\n\n\t \n\tif (spec->supported_bands & SUPPORT_BAND_2GHZ) {\n\t\trt2x00dev->bands[NL80211_BAND_2GHZ].n_channels = 14;\n\t\trt2x00dev->bands[NL80211_BAND_2GHZ].n_bitrates = num_rates;\n\t\trt2x00dev->bands[NL80211_BAND_2GHZ].channels = channels;\n\t\trt2x00dev->bands[NL80211_BAND_2GHZ].bitrates = rates;\n\t\thw->wiphy->bands[NL80211_BAND_2GHZ] =\n\t\t    &rt2x00dev->bands[NL80211_BAND_2GHZ];\n\t\tmemcpy(&rt2x00dev->bands[NL80211_BAND_2GHZ].ht_cap,\n\t\t       &spec->ht, sizeof(spec->ht));\n\t}\n\n\t \n\tif (spec->supported_bands & SUPPORT_BAND_5GHZ) {\n\t\trt2x00dev->bands[NL80211_BAND_5GHZ].n_channels =\n\t\t    spec->num_channels - 14;\n\t\trt2x00dev->bands[NL80211_BAND_5GHZ].n_bitrates =\n\t\t    num_rates - 4;\n\t\trt2x00dev->bands[NL80211_BAND_5GHZ].channels = &channels[14];\n\t\trt2x00dev->bands[NL80211_BAND_5GHZ].bitrates = &rates[4];\n\t\thw->wiphy->bands[NL80211_BAND_5GHZ] =\n\t\t    &rt2x00dev->bands[NL80211_BAND_5GHZ];\n\t\tmemcpy(&rt2x00dev->bands[NL80211_BAND_5GHZ].ht_cap,\n\t\t       &spec->ht, sizeof(spec->ht));\n\t}\n\n\treturn 0;\n\n exit_free_channels:\n\tkfree(channels);\n\trt2x00_err(rt2x00dev, \"Allocation ieee80211 modes failed\\n\");\n\treturn -ENOMEM;\n}\n\nstatic void rt2x00lib_remove_hw(struct rt2x00_dev *rt2x00dev)\n{\n\tif (test_bit(DEVICE_STATE_REGISTERED_HW, &rt2x00dev->flags))\n\t\tieee80211_unregister_hw(rt2x00dev->hw);\n\n\tif (likely(rt2x00dev->hw->wiphy->bands[NL80211_BAND_2GHZ])) {\n\t\tkfree(rt2x00dev->hw->wiphy->bands[NL80211_BAND_2GHZ]->channels);\n\t\tkfree(rt2x00dev->hw->wiphy->bands[NL80211_BAND_2GHZ]->bitrates);\n\t\trt2x00dev->hw->wiphy->bands[NL80211_BAND_2GHZ] = NULL;\n\t\trt2x00dev->hw->wiphy->bands[NL80211_BAND_5GHZ] = NULL;\n\t}\n\n\tkfree(rt2x00dev->spec.channels_info);\n\tkfree(rt2x00dev->chan_survey);\n}\n\nstatic const struct ieee80211_tpt_blink rt2x00_tpt_blink[] = {\n\t{ .throughput = 0 * 1024, .blink_time = 334 },\n\t{ .throughput = 1 * 1024, .blink_time = 260 },\n\t{ .throughput = 2 * 1024, .blink_time = 220 },\n\t{ .throughput = 5 * 1024, .blink_time = 190 },\n\t{ .throughput = 10 * 1024, .blink_time = 170 },\n\t{ .throughput = 25 * 1024, .blink_time = 150 },\n\t{ .throughput = 54 * 1024, .blink_time = 130 },\n\t{ .throughput = 120 * 1024, .blink_time = 110 },\n\t{ .throughput = 265 * 1024, .blink_time = 80 },\n\t{ .throughput = 586 * 1024, .blink_time = 50 },\n};\n\nstatic int rt2x00lib_probe_hw(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct hw_mode_spec *spec = &rt2x00dev->spec;\n\tint status;\n\n\tif (test_bit(DEVICE_STATE_REGISTERED_HW, &rt2x00dev->flags))\n\t\treturn 0;\n\n\t \n\tstatus = rt2x00lib_probe_hw_modes(rt2x00dev, spec);\n\tif (status)\n\t\treturn status;\n\n\t \n\trt2x00dev->hw->queues = rt2x00dev->ops->tx_queues;\n\n\t \n\trt2x00dev->hw->extra_tx_headroom =\n\t\tmax_t(unsigned int, IEEE80211_TX_STATUS_HEADROOM,\n\t\t      rt2x00dev->extra_tx_headroom);\n\n\t \n\tif (rt2x00_has_cap_flag(rt2x00dev, REQUIRE_L2PAD))\n\t\trt2x00dev->hw->extra_tx_headroom += RT2X00_L2PAD_SIZE;\n\telse if (rt2x00_has_cap_flag(rt2x00dev, REQUIRE_DMA))\n\t\trt2x00dev->hw->extra_tx_headroom += RT2X00_ALIGN_SIZE;\n\n\t \n\trt2x00dev->hw->sta_data_size = sizeof(struct rt2x00_sta);\n\n\t \n\tif (rt2x00_has_cap_flag(rt2x00dev, REQUIRE_TXSTATUS_FIFO)) {\n\t\t \n\t\tint kfifo_size =\n\t\t\troundup_pow_of_two(rt2x00dev->ops->tx_queues *\n\t\t\t\t\t   rt2x00dev->tx->limit *\n\t\t\t\t\t   sizeof(u32));\n\n\t\tstatus = kfifo_alloc(&rt2x00dev->txstatus_fifo, kfifo_size,\n\t\t\t\t     GFP_KERNEL);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\t \n#define RT2X00_TASKLET_INIT(taskletname) \\\n\tif (rt2x00dev->ops->lib->taskletname) { \\\n\t\ttasklet_setup(&rt2x00dev->taskletname, \\\n\t\t\t     rt2x00dev->ops->lib->taskletname); \\\n\t}\n\n\tRT2X00_TASKLET_INIT(txstatus_tasklet);\n\tRT2X00_TASKLET_INIT(pretbtt_tasklet);\n\tRT2X00_TASKLET_INIT(tbtt_tasklet);\n\tRT2X00_TASKLET_INIT(rxdone_tasklet);\n\tRT2X00_TASKLET_INIT(autowake_tasklet);\n\n#undef RT2X00_TASKLET_INIT\n\n\tieee80211_create_tpt_led_trigger(rt2x00dev->hw,\n\t\t\t\t\t IEEE80211_TPT_LEDTRIG_FL_RADIO,\n\t\t\t\t\t rt2x00_tpt_blink,\n\t\t\t\t\t ARRAY_SIZE(rt2x00_tpt_blink));\n\n\t \n\tstatus = ieee80211_register_hw(rt2x00dev->hw);\n\tif (status)\n\t\treturn status;\n\n\tset_bit(DEVICE_STATE_REGISTERED_HW, &rt2x00dev->flags);\n\n\treturn 0;\n}\n\n \nstatic void rt2x00lib_uninitialize(struct rt2x00_dev *rt2x00dev)\n{\n\tif (!test_and_clear_bit(DEVICE_STATE_INITIALIZED, &rt2x00dev->flags))\n\t\treturn;\n\n\t \n\tif (rt2x00_has_cap_flag(rt2x00dev, REQUIRE_DELAYED_RFKILL))\n\t\trt2x00rfkill_unregister(rt2x00dev);\n\n\t \n\trt2x00dev->ops->lib->uninitialize(rt2x00dev);\n\n\t \n\trt2x00queue_uninitialize(rt2x00dev);\n}\n\nstatic int rt2x00lib_initialize(struct rt2x00_dev *rt2x00dev)\n{\n\tint status;\n\n\tif (test_bit(DEVICE_STATE_INITIALIZED, &rt2x00dev->flags))\n\t\treturn 0;\n\n\t \n\tstatus = rt2x00queue_initialize(rt2x00dev);\n\tif (status)\n\t\treturn status;\n\n\t \n\tstatus = rt2x00dev->ops->lib->initialize(rt2x00dev);\n\tif (status) {\n\t\trt2x00queue_uninitialize(rt2x00dev);\n\t\treturn status;\n\t}\n\n\tset_bit(DEVICE_STATE_INITIALIZED, &rt2x00dev->flags);\n\n\t \n\tif (rt2x00_has_cap_flag(rt2x00dev, REQUIRE_DELAYED_RFKILL))\n\t\trt2x00rfkill_register(rt2x00dev);\n\n\treturn 0;\n}\n\nint rt2x00lib_start(struct rt2x00_dev *rt2x00dev)\n{\n\tint retval = 0;\n\n\t \n\tretval = rt2x00lib_load_firmware(rt2x00dev);\n\tif (retval)\n\t\tgoto out;\n\n\t \n\tretval = rt2x00lib_initialize(rt2x00dev);\n\tif (retval)\n\t\tgoto out;\n\n\trt2x00dev->intf_ap_count = 0;\n\trt2x00dev->intf_sta_count = 0;\n\trt2x00dev->intf_associated = 0;\n\n\t \n\tretval = rt2x00lib_enable_radio(rt2x00dev);\n\tif (retval)\n\t\tgoto out;\n\n\tset_bit(DEVICE_STATE_STARTED, &rt2x00dev->flags);\n\nout:\n\treturn retval;\n}\n\nvoid rt2x00lib_stop(struct rt2x00_dev *rt2x00dev)\n{\n\tif (!test_and_clear_bit(DEVICE_STATE_STARTED, &rt2x00dev->flags))\n\t\treturn;\n\n\t \n\trt2x00lib_disable_radio(rt2x00dev);\n\n\trt2x00dev->intf_ap_count = 0;\n\trt2x00dev->intf_sta_count = 0;\n\trt2x00dev->intf_associated = 0;\n}\n\nstatic inline void rt2x00lib_set_if_combinations(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct ieee80211_iface_limit *if_limit;\n\tstruct ieee80211_iface_combination *if_combination;\n\n\tif (rt2x00dev->ops->max_ap_intf < 2)\n\t\treturn;\n\n\t \n\tif_limit = &rt2x00dev->if_limits_ap;\n\tif_limit->max = rt2x00dev->ops->max_ap_intf;\n\tif_limit->types = BIT(NL80211_IFTYPE_AP);\n#ifdef CONFIG_MAC80211_MESH\n\tif_limit->types |= BIT(NL80211_IFTYPE_MESH_POINT);\n#endif\n\n\t \n\tif_combination = &rt2x00dev->if_combinations[IF_COMB_AP];\n\tif_combination->limits = if_limit;\n\tif_combination->n_limits = 1;\n\tif_combination->max_interfaces = if_limit->max;\n\tif_combination->num_different_channels = 1;\n\n\t \n\trt2x00dev->hw->wiphy->iface_combinations = rt2x00dev->if_combinations;\n\trt2x00dev->hw->wiphy->n_iface_combinations = 1;\n}\n\nstatic unsigned int rt2x00dev_extra_tx_headroom(struct rt2x00_dev *rt2x00dev)\n{\n\tif (WARN_ON(!rt2x00dev->tx))\n\t\treturn 0;\n\n\tif (rt2x00_is_usb(rt2x00dev))\n\t\treturn rt2x00dev->tx[0].winfo_size + rt2x00dev->tx[0].desc_size;\n\n\treturn rt2x00dev->tx[0].winfo_size;\n}\n\n \nint rt2x00lib_probe_dev(struct rt2x00_dev *rt2x00dev)\n{\n\tint retval = -ENOMEM;\n\n\t \n\trt2x00lib_set_if_combinations(rt2x00dev);\n\n\t \n\tif (rt2x00dev->ops->drv_data_size > 0) {\n\t\trt2x00dev->drv_data = kzalloc(rt2x00dev->ops->drv_data_size,\n\t\t\t                      GFP_KERNEL);\n\t\tif (!rt2x00dev->drv_data) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tspin_lock_init(&rt2x00dev->irqmask_lock);\n\tmutex_init(&rt2x00dev->csr_mutex);\n\tmutex_init(&rt2x00dev->conf_mutex);\n\tINIT_LIST_HEAD(&rt2x00dev->bar_list);\n\tspin_lock_init(&rt2x00dev->bar_list_lock);\n\thrtimer_init(&rt2x00dev->txstatus_timer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_REL);\n\n\tset_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags);\n\n\t \n\trt2x00dev->hw->vif_data_size = sizeof(struct rt2x00_intf);\n\n\t \n\trt2x00dev->hw->wiphy->addr_mask[ETH_ALEN - 1] =\n\t\t(rt2x00dev->ops->max_ap_intf - 1);\n\n\t \n\trt2x00dev->workqueue =\n\t    alloc_ordered_workqueue(\"%s\", 0, wiphy_name(rt2x00dev->hw->wiphy));\n\tif (!rt2x00dev->workqueue) {\n\t\tretval = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tINIT_WORK(&rt2x00dev->intf_work, rt2x00lib_intf_scheduled);\n\tINIT_DELAYED_WORK(&rt2x00dev->autowakeup_work, rt2x00lib_autowakeup);\n\tINIT_WORK(&rt2x00dev->sleep_work, rt2x00lib_sleep);\n\n\t \n\tretval = rt2x00dev->ops->lib->probe_hw(rt2x00dev);\n\tif (retval) {\n\t\trt2x00_err(rt2x00dev, \"Failed to allocate device\\n\");\n\t\tgoto exit;\n\t}\n\n\t \n\tretval = rt2x00queue_allocate(rt2x00dev);\n\tif (retval)\n\t\tgoto exit;\n\n\t \n\trt2x00dev->extra_tx_headroom = rt2x00dev_extra_tx_headroom(rt2x00dev);\n\n\t \n\trt2x00dev->hw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION);\n\tif (rt2x00dev->bcn->limit > 0)\n\t\trt2x00dev->hw->wiphy->interface_modes |=\n\t\t    BIT(NL80211_IFTYPE_ADHOC) |\n#ifdef CONFIG_MAC80211_MESH\n\t\t    BIT(NL80211_IFTYPE_MESH_POINT) |\n#endif\n\t\t    BIT(NL80211_IFTYPE_AP);\n\n\trt2x00dev->hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;\n\n\twiphy_ext_feature_set(rt2x00dev->hw->wiphy,\n\t\t\t      NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\t \n\tretval = rt2x00lib_probe_hw(rt2x00dev);\n\tif (retval) {\n\t\trt2x00_err(rt2x00dev, \"Failed to initialize hw\\n\");\n\t\tgoto exit;\n\t}\n\n\t \n\trt2x00link_register(rt2x00dev);\n\trt2x00leds_register(rt2x00dev);\n\trt2x00debug_register(rt2x00dev);\n\n\t \n\tif (!rt2x00_has_cap_flag(rt2x00dev, REQUIRE_DELAYED_RFKILL))\n\t\trt2x00rfkill_register(rt2x00dev);\n\n\treturn 0;\n\nexit:\n\trt2x00lib_remove_dev(rt2x00dev);\n\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(rt2x00lib_probe_dev);\n\nvoid rt2x00lib_remove_dev(struct rt2x00_dev *rt2x00dev)\n{\n\tclear_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags);\n\n\t \n\tif (!rt2x00_has_cap_flag(rt2x00dev, REQUIRE_DELAYED_RFKILL))\n\t\trt2x00rfkill_unregister(rt2x00dev);\n\n\t \n\trt2x00lib_disable_radio(rt2x00dev);\n\n\t \n\tcancel_work_sync(&rt2x00dev->intf_work);\n\tcancel_delayed_work_sync(&rt2x00dev->autowakeup_work);\n\tcancel_work_sync(&rt2x00dev->sleep_work);\n\n\thrtimer_cancel(&rt2x00dev->txstatus_timer);\n\n\t \n\ttasklet_kill(&rt2x00dev->txstatus_tasklet);\n\ttasklet_kill(&rt2x00dev->pretbtt_tasklet);\n\ttasklet_kill(&rt2x00dev->tbtt_tasklet);\n\ttasklet_kill(&rt2x00dev->rxdone_tasklet);\n\ttasklet_kill(&rt2x00dev->autowake_tasklet);\n\n\t \n\trt2x00lib_uninitialize(rt2x00dev);\n\n\tif (rt2x00dev->workqueue)\n\t\tdestroy_workqueue(rt2x00dev->workqueue);\n\n\t \n\tkfifo_free(&rt2x00dev->txstatus_fifo);\n\n\t \n\trt2x00debug_deregister(rt2x00dev);\n\trt2x00leds_unregister(rt2x00dev);\n\n\t \n\trt2x00lib_remove_hw(rt2x00dev);\n\n\t \n\trt2x00lib_free_firmware(rt2x00dev);\n\n\t \n\trt2x00queue_free(rt2x00dev);\n\n\t \n\tkfree(rt2x00dev->drv_data);\n}\nEXPORT_SYMBOL_GPL(rt2x00lib_remove_dev);\n\n \nint rt2x00lib_suspend(struct rt2x00_dev *rt2x00dev)\n{\n\trt2x00_dbg(rt2x00dev, \"Going to sleep\\n\");\n\n\t \n\tif (!test_and_clear_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\n\t\treturn 0;\n\n\t \n\trt2x00lib_uninitialize(rt2x00dev);\n\n\t \n\trt2x00leds_suspend(rt2x00dev);\n\trt2x00debug_deregister(rt2x00dev);\n\n\t \n\tif (rt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_SLEEP))\n\t\trt2x00_warn(rt2x00dev, \"Device failed to enter sleep state, continue suspending\\n\");\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rt2x00lib_suspend);\n\nint rt2x00lib_resume(struct rt2x00_dev *rt2x00dev)\n{\n\trt2x00_dbg(rt2x00dev, \"Waking up\\n\");\n\n\t \n\trt2x00debug_register(rt2x00dev);\n\trt2x00leds_resume(rt2x00dev);\n\n\t \n\tset_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rt2x00lib_resume);\n\n \nMODULE_AUTHOR(DRV_PROJECT);\nMODULE_VERSION(DRV_VERSION);\nMODULE_DESCRIPTION(\"rt2x00 library\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}