{
  "module_name": "rt2x00debug.c",
  "hash_id": "e74911af5ab7091538a845905fe6be829616f6565f294161f663304ea12c3117",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ralink/rt2x00/rt2x00debug.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/debugfs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/poll.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n#include \"rt2x00.h\"\n#include \"rt2x00lib.h\"\n#include \"rt2x00dump.h\"\n\n#define MAX_LINE_LENGTH 64\n\nstruct rt2x00debug_crypto {\n\tunsigned long success;\n\tunsigned long icv_error;\n\tunsigned long mic_error;\n\tunsigned long key_error;\n};\n\nstruct rt2x00debug_intf {\n\t \n\tstruct rt2x00_dev *rt2x00dev;\n\n\t \n\tconst struct rt2x00debug *debug;\n\n\t \n\tstruct dentry *driver_folder;\n\n\t \n\tunsigned long frame_dump_flags;\n#define FRAME_DUMP_FILE_OPEN\t1\n\n\t \n\tstruct sk_buff_head frame_dump_skbqueue;\n\twait_queue_head_t frame_dump_waitqueue;\n\n\t \n\tstruct rt2x00debug_crypto crypto_stats[CIPHER_MAX];\n\n\t \n\tstruct debugfs_blob_wrapper driver_blob;\n\tstruct debugfs_blob_wrapper chipset_blob;\n\n\t \n\tunsigned int offset_csr;\n\tunsigned int offset_eeprom;\n\tunsigned int offset_bbp;\n\tunsigned int offset_rf;\n\tunsigned int offset_rfcsr;\n};\n\nvoid rt2x00debug_update_crypto(struct rt2x00_dev *rt2x00dev,\n\t\t\t       struct rxdone_entry_desc *rxdesc)\n{\n\tstruct rt2x00debug_intf *intf = rt2x00dev->debugfs_intf;\n\tenum cipher cipher = rxdesc->cipher;\n\tenum rx_crypto status = rxdesc->cipher_status;\n\n\tif (cipher == CIPHER_TKIP_NO_MIC)\n\t\tcipher = CIPHER_TKIP;\n\tif (cipher == CIPHER_NONE || cipher >= CIPHER_MAX)\n\t\treturn;\n\n\t \n\tcipher--;\n\n\tintf->crypto_stats[cipher].success += (status == RX_CRYPTO_SUCCESS);\n\tintf->crypto_stats[cipher].icv_error += (status == RX_CRYPTO_FAIL_ICV);\n\tintf->crypto_stats[cipher].mic_error += (status == RX_CRYPTO_FAIL_MIC);\n\tintf->crypto_stats[cipher].key_error += (status == RX_CRYPTO_FAIL_KEY);\n}\n\nvoid rt2x00debug_dump_frame(struct rt2x00_dev *rt2x00dev,\n\t\t\t    enum rt2x00_dump_type type, struct queue_entry *entry)\n{\n\tstruct rt2x00debug_intf *intf = rt2x00dev->debugfs_intf;\n\tstruct sk_buff *skb = entry->skb;\n\tstruct skb_frame_desc *skbdesc = get_skb_frame_desc(skb);\n\tstruct sk_buff *skbcopy;\n\tstruct rt2x00dump_hdr *dump_hdr;\n\tstruct timespec64 timestamp;\n\tu32 data_len;\n\n\tif (likely(!test_bit(FRAME_DUMP_FILE_OPEN, &intf->frame_dump_flags)))\n\t\treturn;\n\n\tktime_get_ts64(&timestamp);\n\n\tif (skb_queue_len(&intf->frame_dump_skbqueue) > 20) {\n\t\trt2x00_dbg(rt2x00dev, \"txrx dump queue length exceeded\\n\");\n\t\treturn;\n\t}\n\n\tdata_len = skb->len;\n\tif (skbdesc->flags & SKBDESC_DESC_IN_SKB)\n\t\tdata_len -= skbdesc->desc_len;\n\n\tskbcopy = alloc_skb(sizeof(*dump_hdr) + skbdesc->desc_len + data_len,\n\t\t\t    GFP_ATOMIC);\n\tif (!skbcopy) {\n\t\trt2x00_dbg(rt2x00dev, \"Failed to copy skb for dump\\n\");\n\t\treturn;\n\t}\n\n\tdump_hdr = skb_put(skbcopy, sizeof(*dump_hdr));\n\tdump_hdr->version = cpu_to_le32(DUMP_HEADER_VERSION);\n\tdump_hdr->header_length = cpu_to_le32(sizeof(*dump_hdr));\n\tdump_hdr->desc_length = cpu_to_le32(skbdesc->desc_len);\n\tdump_hdr->data_length = cpu_to_le32(data_len);\n\tdump_hdr->chip_rt = cpu_to_le16(rt2x00dev->chip.rt);\n\tdump_hdr->chip_rf = cpu_to_le16(rt2x00dev->chip.rf);\n\tdump_hdr->chip_rev = cpu_to_le16(rt2x00dev->chip.rev);\n\tdump_hdr->type = cpu_to_le16(type);\n\tdump_hdr->queue_index = entry->queue->qid;\n\tdump_hdr->entry_index = entry->entry_idx;\n\tdump_hdr->timestamp_sec = cpu_to_le32(timestamp.tv_sec);\n\tdump_hdr->timestamp_usec = cpu_to_le32(timestamp.tv_nsec /\n\t\t\t\t\t       NSEC_PER_USEC);\n\n\tif (!(skbdesc->flags & SKBDESC_DESC_IN_SKB))\n\t\tskb_put_data(skbcopy, skbdesc->desc, skbdesc->desc_len);\n\tskb_put_data(skbcopy, skb->data, skb->len);\n\n\tskb_queue_tail(&intf->frame_dump_skbqueue, skbcopy);\n\twake_up_interruptible(&intf->frame_dump_waitqueue);\n\n\t \n\tif (!test_bit(FRAME_DUMP_FILE_OPEN, &intf->frame_dump_flags))\n\t\tskb_queue_purge(&intf->frame_dump_skbqueue);\n}\nEXPORT_SYMBOL_GPL(rt2x00debug_dump_frame);\n\nstatic int rt2x00debug_file_open(struct inode *inode, struct file *file)\n{\n\tstruct rt2x00debug_intf *intf = inode->i_private;\n\n\tfile->private_data = inode->i_private;\n\n\tif (!try_module_get(intf->debug->owner))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic int rt2x00debug_file_release(struct inode *inode, struct file *file)\n{\n\tstruct rt2x00debug_intf *intf = file->private_data;\n\n\tmodule_put(intf->debug->owner);\n\n\treturn 0;\n}\n\nstatic int rt2x00debug_open_queue_dump(struct inode *inode, struct file *file)\n{\n\tstruct rt2x00debug_intf *intf = inode->i_private;\n\tint retval;\n\n\tretval = rt2x00debug_file_open(inode, file);\n\tif (retval)\n\t\treturn retval;\n\n\tif (test_and_set_bit(FRAME_DUMP_FILE_OPEN, &intf->frame_dump_flags)) {\n\t\trt2x00debug_file_release(inode, file);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int rt2x00debug_release_queue_dump(struct inode *inode, struct file *file)\n{\n\tstruct rt2x00debug_intf *intf = inode->i_private;\n\n\tskb_queue_purge(&intf->frame_dump_skbqueue);\n\n\tclear_bit(FRAME_DUMP_FILE_OPEN, &intf->frame_dump_flags);\n\n\treturn rt2x00debug_file_release(inode, file);\n}\n\nstatic ssize_t rt2x00debug_read_queue_dump(struct file *file,\n\t\t\t\t\t   char __user *buf,\n\t\t\t\t\t   size_t length,\n\t\t\t\t\t   loff_t *offset)\n{\n\tstruct rt2x00debug_intf *intf = file->private_data;\n\tstruct sk_buff *skb;\n\tsize_t status;\n\tint retval;\n\n\tif (file->f_flags & O_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\tretval =\n\t    wait_event_interruptible(intf->frame_dump_waitqueue,\n\t\t\t\t     (skb =\n\t\t\t\t     skb_dequeue(&intf->frame_dump_skbqueue)));\n\tif (retval)\n\t\treturn retval;\n\n\tstatus = min_t(size_t, skb->len, length);\n\tif (copy_to_user(buf, skb->data, status)) {\n\t\tstatus = -EFAULT;\n\t\tgoto exit;\n\t}\n\n\t*offset += status;\n\nexit:\n\tkfree_skb(skb);\n\n\treturn status;\n}\n\nstatic __poll_t rt2x00debug_poll_queue_dump(struct file *file,\n\t\t\t\t\t\tpoll_table *wait)\n{\n\tstruct rt2x00debug_intf *intf = file->private_data;\n\n\tpoll_wait(file, &intf->frame_dump_waitqueue, wait);\n\n\tif (!skb_queue_empty(&intf->frame_dump_skbqueue))\n\t\treturn EPOLLOUT | EPOLLWRNORM;\n\n\treturn 0;\n}\n\nstatic const struct file_operations rt2x00debug_fop_queue_dump = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= rt2x00debug_read_queue_dump,\n\t.poll\t\t= rt2x00debug_poll_queue_dump,\n\t.open\t\t= rt2x00debug_open_queue_dump,\n\t.release\t= rt2x00debug_release_queue_dump,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic ssize_t rt2x00debug_read_queue_stats(struct file *file,\n\t\t\t\t\t    char __user *buf,\n\t\t\t\t\t    size_t length,\n\t\t\t\t\t    loff_t *offset)\n{\n\tstruct rt2x00debug_intf *intf = file->private_data;\n\tstruct data_queue *queue;\n\tunsigned long irqflags;\n\tunsigned int lines = 1 + intf->rt2x00dev->data_queues;\n\tsize_t size;\n\tchar *data;\n\tchar *temp;\n\n\tif (*offset)\n\t\treturn 0;\n\n\tdata = kcalloc(lines, MAX_LINE_LENGTH, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\ttemp = data +\n\t    sprintf(data, \"qid\\tflags\\t\\tcount\\tlimit\\tlength\\tindex\\tdma done\\tdone\\n\");\n\n\tqueue_for_each(intf->rt2x00dev, queue) {\n\t\tspin_lock_irqsave(&queue->index_lock, irqflags);\n\n\t\ttemp += sprintf(temp, \"%d\\t0x%.8x\\t%d\\t%d\\t%d\\t%d\\t%d\\t\\t%d\\n\",\n\t\t\t\tqueue->qid, (unsigned int)queue->flags,\n\t\t\t\tqueue->count, queue->limit, queue->length,\n\t\t\t\tqueue->index[Q_INDEX],\n\t\t\t\tqueue->index[Q_INDEX_DMA_DONE],\n\t\t\t\tqueue->index[Q_INDEX_DONE]);\n\n\t\tspin_unlock_irqrestore(&queue->index_lock, irqflags);\n\t}\n\n\tsize = strlen(data);\n\tsize = min(size, length);\n\n\tif (copy_to_user(buf, data, size)) {\n\t\tkfree(data);\n\t\treturn -EFAULT;\n\t}\n\n\tkfree(data);\n\n\t*offset += size;\n\treturn size;\n}\n\nstatic const struct file_operations rt2x00debug_fop_queue_stats = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= rt2x00debug_read_queue_stats,\n\t.open\t\t= rt2x00debug_file_open,\n\t.release\t= rt2x00debug_file_release,\n\t.llseek\t\t= default_llseek,\n};\n\n#ifdef CONFIG_RT2X00_LIB_CRYPTO\nstatic ssize_t rt2x00debug_read_crypto_stats(struct file *file,\n\t\t\t\t\t     char __user *buf,\n\t\t\t\t\t     size_t length,\n\t\t\t\t\t     loff_t *offset)\n{\n\tstruct rt2x00debug_intf *intf = file->private_data;\n\tstatic const char * const name[] = { \"WEP64\", \"WEP128\", \"TKIP\", \"AES\" };\n\tchar *data;\n\tchar *temp;\n\tsize_t size;\n\tunsigned int i;\n\n\tif (*offset)\n\t\treturn 0;\n\n\tdata = kcalloc(1 + CIPHER_MAX, MAX_LINE_LENGTH, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\ttemp = data;\n\ttemp += sprintf(data, \"cipher\\tsuccess\\ticv err\\tmic err\\tkey err\\n\");\n\n\tfor (i = 0; i < CIPHER_MAX; i++) {\n\t\ttemp += sprintf(temp, \"%s\\t%lu\\t%lu\\t%lu\\t%lu\\n\", name[i],\n\t\t\t\tintf->crypto_stats[i].success,\n\t\t\t\tintf->crypto_stats[i].icv_error,\n\t\t\t\tintf->crypto_stats[i].mic_error,\n\t\t\t\tintf->crypto_stats[i].key_error);\n\t}\n\n\tsize = strlen(data);\n\tsize = min(size, length);\n\n\tif (copy_to_user(buf, data, size)) {\n\t\tkfree(data);\n\t\treturn -EFAULT;\n\t}\n\n\tkfree(data);\n\n\t*offset += size;\n\treturn size;\n}\n\nstatic const struct file_operations rt2x00debug_fop_crypto_stats = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= rt2x00debug_read_crypto_stats,\n\t.open\t\t= rt2x00debug_file_open,\n\t.release\t= rt2x00debug_file_release,\n\t.llseek\t\t= default_llseek,\n};\n#endif\n\n#define RT2X00DEBUGFS_OPS_READ(__name, __format, __type)\t\\\nstatic ssize_t rt2x00debug_read_##__name(struct file *file,\t\\\n\t\t\t\t\t char __user *buf,\t\\\n\t\t\t\t\t size_t length,\t\t\\\n\t\t\t\t\t loff_t *offset)\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct rt2x00debug_intf *intf = file->private_data;\t\\\n\tconst struct rt2x00debug *debug = intf->debug;\t\t\\\n\tchar line[16];\t\t\t\t\t\t\\\n\tsize_t size;\t\t\t\t\t\t\\\n\tunsigned int index = intf->offset_##__name;\t\t\\\n\t__type value;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (*offset)\t\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (index >= debug->__name.word_count)\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tindex += (debug->__name.word_base /\t\t\t\\\n\t\t  debug->__name.word_size);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (debug->__name.flags & RT2X00DEBUGFS_OFFSET)\t\t\\\n\t\tindex *= debug->__name.word_size;\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tvalue = debug->__name.read(intf->rt2x00dev, index);\t\\\n\t\t\t\t\t\t\t\t\\\n\tsize = sprintf(line, __format, value);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\treturn simple_read_from_buffer(buf, length, offset, line, size); \\\n}\n\n#define RT2X00DEBUGFS_OPS_WRITE(__name, __type)\t\t\t\\\nstatic ssize_t rt2x00debug_write_##__name(struct file *file,\t\\\n\t\t\t\t\t  const char __user *buf,\\\n\t\t\t\t\t  size_t length,\t\\\n\t\t\t\t\t  loff_t *offset)\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct rt2x00debug_intf *intf = file->private_data;\t\\\n\tconst struct rt2x00debug *debug = intf->debug;\t\t\\\n\tchar line[17];\t\t\t\t\t\t\\\n\tsize_t size;\t\t\t\t\t\t\\\n\tunsigned int index = intf->offset_##__name;\t\t\\\n\t__type value;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (*offset)\t\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (index >= debug->__name.word_count)\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (length > sizeof(line))\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (copy_from_user(line, buf, length))\t\t\t\\\n\t\treturn -EFAULT;\t\t\t\t\t\\\n\tline[16] = 0;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\\\n\tsize = strlen(line);\t\t\t\t\t\\\n\tvalue = simple_strtoul(line, NULL, 0);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tindex += (debug->__name.word_base /\t\t\t\\\n\t\t  debug->__name.word_size);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (debug->__name.flags & RT2X00DEBUGFS_OFFSET)\t\t\\\n\t\tindex *= debug->__name.word_size;\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tdebug->__name.write(intf->rt2x00dev, index, value);\t\\\n\t\t\t\t\t\t\t\t\\\n\t*offset += size;\t\t\t\t\t\\\n\treturn size;\t\t\t\t\t\t\\\n}\n\n#define RT2X00DEBUGFS_OPS(__name, __format, __type)\t\t\\\nRT2X00DEBUGFS_OPS_READ(__name, __format, __type);\t\t\\\nRT2X00DEBUGFS_OPS_WRITE(__name, __type);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\nstatic const struct file_operations rt2x00debug_fop_##__name = {\\\n\t.owner\t\t= THIS_MODULE,\t\t\t\t\\\n\t.read\t\t= rt2x00debug_read_##__name,\t\t\\\n\t.write\t\t= rt2x00debug_write_##__name,\t\t\\\n\t.open\t\t= rt2x00debug_file_open,\t\t\\\n\t.release\t= rt2x00debug_file_release,\t\t\\\n\t.llseek\t\t= generic_file_llseek,\t\t\t\\\n};\n\nRT2X00DEBUGFS_OPS(csr, \"0x%.8x\\n\", u32);\nRT2X00DEBUGFS_OPS(eeprom, \"0x%.4x\\n\", u16);\nRT2X00DEBUGFS_OPS(bbp, \"0x%.2x\\n\", u8);\nRT2X00DEBUGFS_OPS(rf, \"0x%.8x\\n\", u32);\nRT2X00DEBUGFS_OPS(rfcsr, \"0x%.2x\\n\", u8);\n\nstatic ssize_t rt2x00debug_read_dev_flags(struct file *file,\n\t\t\t\t\t  char __user *buf,\n\t\t\t\t\t  size_t length,\n\t\t\t\t\t  loff_t *offset)\n{\n\tstruct rt2x00debug_intf *intf =\tfile->private_data;\n\tchar line[16];\n\tsize_t size;\n\n\tif (*offset)\n\t\treturn 0;\n\n\tsize = sprintf(line, \"0x%.8x\\n\", (unsigned int)intf->rt2x00dev->flags);\n\n\treturn simple_read_from_buffer(buf, length, offset, line, size);\n}\n\nstatic const struct file_operations rt2x00debug_fop_dev_flags = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= rt2x00debug_read_dev_flags,\n\t.open\t\t= rt2x00debug_file_open,\n\t.release\t= rt2x00debug_file_release,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic ssize_t rt2x00debug_read_cap_flags(struct file *file,\n\t\t\t\t\t  char __user *buf,\n\t\t\t\t\t  size_t length,\n\t\t\t\t\t  loff_t *offset)\n{\n\tstruct rt2x00debug_intf *intf =\tfile->private_data;\n\tchar line[16];\n\tsize_t size;\n\n\tif (*offset)\n\t\treturn 0;\n\n\tsize = sprintf(line, \"0x%.8x\\n\", (unsigned int)intf->rt2x00dev->cap_flags);\n\n\treturn simple_read_from_buffer(buf, length, offset, line, size);\n}\n\nstatic const struct file_operations rt2x00debug_fop_cap_flags = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= rt2x00debug_read_cap_flags,\n\t.open\t\t= rt2x00debug_file_open,\n\t.release\t= rt2x00debug_file_release,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic ssize_t rt2x00debug_write_restart_hw(struct file *file,\n\t\t\t\t\t    const char __user *buf,\n\t\t\t\t\t    size_t length,\n\t\t\t\t\t    loff_t *offset)\n{\n\tstruct rt2x00debug_intf *intf =\tfile->private_data;\n\tstruct rt2x00_dev *rt2x00dev = intf->rt2x00dev;\n\tstatic unsigned long last_reset = INITIAL_JIFFIES;\n\n\tif (!rt2x00_has_cap_restart_hw(rt2x00dev))\n\t\treturn -EOPNOTSUPP;\n\n\tif (time_before(jiffies, last_reset + msecs_to_jiffies(2000)))\n\t\treturn -EBUSY;\n\n\tlast_reset = jiffies;\n\n\tieee80211_restart_hw(rt2x00dev->hw);\n\treturn length;\n}\n\nstatic const struct file_operations rt2x00debug_restart_hw = {\n\t.owner = THIS_MODULE,\n\t.write = rt2x00debug_write_restart_hw,\n\t.open = simple_open,\n\t.llseek = generic_file_llseek,\n};\n\nstatic void rt2x00debug_create_file_driver(const char *name,\n\t\t\t\t\t   struct rt2x00debug_intf *intf,\n\t\t\t\t\t   struct debugfs_blob_wrapper *blob)\n{\n\tchar *data;\n\n\tdata = kzalloc(3 * MAX_LINE_LENGTH, GFP_KERNEL);\n\tif (!data)\n\t\treturn;\n\n\tblob->data = data;\n\tdata += sprintf(data, \"driver:\\t%s\\n\", intf->rt2x00dev->ops->name);\n\tdata += sprintf(data, \"version:\\t%s\\n\", DRV_VERSION);\n\tblob->size = strlen(blob->data);\n\n\tdebugfs_create_blob(name, 0400, intf->driver_folder, blob);\n}\n\nstatic void rt2x00debug_create_file_chipset(const char *name,\n\t\t\t\t\t    struct rt2x00debug_intf *intf,\n\t\t\t\t\t    struct debugfs_blob_wrapper *blob)\n{\n\tconst struct rt2x00debug *debug = intf->debug;\n\tchar *data;\n\n\tdata = kzalloc(9 * MAX_LINE_LENGTH, GFP_KERNEL);\n\tif (!data)\n\t\treturn;\n\n\tblob->data = data;\n\tdata += sprintf(data, \"rt chip:\\t%04x\\n\", intf->rt2x00dev->chip.rt);\n\tdata += sprintf(data, \"rf chip:\\t%04x\\n\", intf->rt2x00dev->chip.rf);\n\tdata += sprintf(data, \"revision:\\t%04x\\n\", intf->rt2x00dev->chip.rev);\n\tdata += sprintf(data, \"\\n\");\n\tdata += sprintf(data, \"register\\tbase\\twords\\twordsize\\n\");\n#define RT2X00DEBUGFS_SPRINTF_REGISTER(__name)\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tif (debug->__name.read)\t\t\t\t\t\\\n\t\tdata += sprintf(data, __stringify(__name)\t\\\n\t\t\t\t\"\\t%d\\t%d\\t%d\\n\",\t\t\\\n\t\t\t\tdebug->__name.word_base,\t\\\n\t\t\t\tdebug->__name.word_count,\t\\\n\t\t\t\tdebug->__name.word_size);\t\\\n}\n\tRT2X00DEBUGFS_SPRINTF_REGISTER(csr);\n\tRT2X00DEBUGFS_SPRINTF_REGISTER(eeprom);\n\tRT2X00DEBUGFS_SPRINTF_REGISTER(bbp);\n\tRT2X00DEBUGFS_SPRINTF_REGISTER(rf);\n\tRT2X00DEBUGFS_SPRINTF_REGISTER(rfcsr);\n#undef RT2X00DEBUGFS_SPRINTF_REGISTER\n\n\tblob->size = strlen(blob->data);\n\n\tdebugfs_create_blob(name, 0400, intf->driver_folder, blob);\n}\n\nvoid rt2x00debug_register(struct rt2x00_dev *rt2x00dev)\n{\n\tconst struct rt2x00debug *debug = rt2x00dev->ops->debugfs;\n\tstruct rt2x00debug_intf *intf;\n\tstruct dentry *queue_folder;\n\tstruct dentry *register_folder;\n\n\tintf = kzalloc(sizeof(struct rt2x00debug_intf), GFP_KERNEL);\n\tif (!intf) {\n\t\trt2x00_err(rt2x00dev, \"Failed to allocate debug handler\\n\");\n\t\treturn;\n\t}\n\n\tintf->debug = debug;\n\tintf->rt2x00dev = rt2x00dev;\n\trt2x00dev->debugfs_intf = intf;\n\n\tintf->driver_folder =\n\t    debugfs_create_dir(intf->rt2x00dev->ops->name,\n\t\t\t       rt2x00dev->hw->wiphy->debugfsdir);\n\n\trt2x00debug_create_file_driver(\"driver\", intf, &intf->driver_blob);\n\trt2x00debug_create_file_chipset(\"chipset\", intf, &intf->chipset_blob);\n\tdebugfs_create_file(\"dev_flags\", 0400, intf->driver_folder, intf,\n\t\t\t    &rt2x00debug_fop_dev_flags);\n\tdebugfs_create_file(\"cap_flags\", 0400, intf->driver_folder, intf,\n\t\t\t    &rt2x00debug_fop_cap_flags);\n\tdebugfs_create_file(\"restart_hw\", 0200, intf->driver_folder, intf,\n\t\t\t    &rt2x00debug_restart_hw);\n\n\tregister_folder = debugfs_create_dir(\"register\", intf->driver_folder);\n\n#define RT2X00DEBUGFS_CREATE_REGISTER_ENTRY(__intf, __name)\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tif (debug->__name.read) {\t\t\t\t\t\\\n\t\tdebugfs_create_u32(__stringify(__name) \"_offset\", 0600,\t\\\n\t\t\t\t   register_folder,\t\t\t\\\n\t\t\t\t   &(__intf)->offset_##__name);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tdebugfs_create_file(__stringify(__name) \"_value\", 0600,\t\\\n\t\t\t\t    register_folder, (__intf),\t\t\\\n\t\t\t\t    &rt2x00debug_fop_##__name);\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n})\n\n\tRT2X00DEBUGFS_CREATE_REGISTER_ENTRY(intf, csr);\n\tRT2X00DEBUGFS_CREATE_REGISTER_ENTRY(intf, eeprom);\n\tRT2X00DEBUGFS_CREATE_REGISTER_ENTRY(intf, bbp);\n\tRT2X00DEBUGFS_CREATE_REGISTER_ENTRY(intf, rf);\n\tRT2X00DEBUGFS_CREATE_REGISTER_ENTRY(intf, rfcsr);\n\n#undef RT2X00DEBUGFS_CREATE_REGISTER_ENTRY\n\n\tqueue_folder = debugfs_create_dir(\"queue\", intf->driver_folder);\n\n\tdebugfs_create_file(\"dump\", 0400, queue_folder, intf,\n\t\t\t    &rt2x00debug_fop_queue_dump);\n\n\tskb_queue_head_init(&intf->frame_dump_skbqueue);\n\tinit_waitqueue_head(&intf->frame_dump_waitqueue);\n\n\tdebugfs_create_file(\"queue\", 0400, queue_folder, intf,\n\t\t\t    &rt2x00debug_fop_queue_stats);\n\n#ifdef CONFIG_RT2X00_LIB_CRYPTO\n\tif (rt2x00_has_cap_hw_crypto(rt2x00dev))\n\t\tdebugfs_create_file(\"crypto\", 0444, queue_folder, intf,\n\t\t\t\t    &rt2x00debug_fop_crypto_stats);\n#endif\n\n\treturn;\n}\n\nvoid rt2x00debug_deregister(struct rt2x00_dev *rt2x00dev)\n{\n\tstruct rt2x00debug_intf *intf = rt2x00dev->debugfs_intf;\n\n\tif (unlikely(!intf))\n\t\treturn;\n\n\tskb_queue_purge(&intf->frame_dump_skbqueue);\n\n\tdebugfs_remove_recursive(intf->driver_folder);\n\tkfree(intf->chipset_blob.data);\n\tkfree(intf->driver_blob.data);\n\tkfree(intf);\n\n\trt2x00dev->debugfs_intf = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}