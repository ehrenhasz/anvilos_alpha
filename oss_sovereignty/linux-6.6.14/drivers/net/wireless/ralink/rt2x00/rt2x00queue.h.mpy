{
  "module_name": "rt2x00queue.h",
  "hash_id": "983c40be0ce80d6d15e178e0d526ab8c10c986a70bb3fca5429f3a552586c8c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ralink/rt2x00/rt2x00queue.h",
  "human_readable_source": " \n \n\n \n\n#ifndef RT2X00QUEUE_H\n#define RT2X00QUEUE_H\n\n#include <linux/prefetch.h>\n\n \n#define DATA_FRAME_SIZE\t\t2432\n#define MGMT_FRAME_SIZE\t\t256\n#define AGGREGATION_SIZE\t3840\n\n \nenum data_queue_qid {\n\tQID_AC_VO = 0,\n\tQID_AC_VI = 1,\n\tQID_AC_BE = 2,\n\tQID_AC_BK = 3,\n\tQID_HCCA = 4,\n\tQID_MGMT = 13,\n\tQID_RX = 14,\n\tQID_OTHER = 15,\n\tQID_BEACON,\n\tQID_ATIM,\n};\n\n \nenum skb_frame_desc_flags {\n\tSKBDESC_DMA_MAPPED_RX = 1 << 0,\n\tSKBDESC_DMA_MAPPED_TX = 1 << 1,\n\tSKBDESC_IV_STRIPPED = 1 << 2,\n\tSKBDESC_NOT_MAC80211 = 1 << 3,\n\tSKBDESC_DESC_IN_SKB = 1 << 4,\n};\n\n \nstruct skb_frame_desc {\n\tu8 flags;\n\n\tu8 desc_len;\n\tu8 tx_rate_idx;\n\tu8 tx_rate_flags;\n\n\tvoid *desc;\n\n\t__le32 iv[2];\n\n\tdma_addr_t skb_dma;\n\tstruct ieee80211_sta *sta;\n};\n\n \nstatic inline struct skb_frame_desc* get_skb_frame_desc(struct sk_buff *skb)\n{\n\tBUILD_BUG_ON(sizeof(struct skb_frame_desc) >\n\t\t     IEEE80211_TX_INFO_DRIVER_DATA_SIZE);\n\treturn (struct skb_frame_desc *)&IEEE80211_SKB_CB(skb)->driver_data;\n}\n\n \nenum rxdone_entry_desc_flags {\n\tRXDONE_SIGNAL_PLCP = BIT(0),\n\tRXDONE_SIGNAL_BITRATE = BIT(1),\n\tRXDONE_SIGNAL_MCS = BIT(2),\n\tRXDONE_MY_BSS = BIT(3),\n\tRXDONE_CRYPTO_IV = BIT(4),\n\tRXDONE_CRYPTO_ICV = BIT(5),\n\tRXDONE_L2PAD = BIT(6),\n};\n\n \n#define RXDONE_SIGNAL_MASK \\\n\t( RXDONE_SIGNAL_PLCP | RXDONE_SIGNAL_BITRATE | RXDONE_SIGNAL_MCS )\n\n \nstruct rxdone_entry_desc {\n\tu64 timestamp;\n\tint signal;\n\tint rssi;\n\tint size;\n\tint flags;\n\tint dev_flags;\n\tu16 rate_mode;\n\tu16 enc_flags;\n\tenum mac80211_rx_encoding encoding;\n\tenum rate_info_bw bw;\n\tu8 cipher;\n\tu8 cipher_status;\n\n\t__le32 iv[2];\n\t__le32 icv;\n};\n\n \nenum txdone_entry_desc_flags {\n\tTXDONE_UNKNOWN,\n\tTXDONE_SUCCESS,\n\tTXDONE_FALLBACK,\n\tTXDONE_FAILURE,\n\tTXDONE_EXCESSIVE_RETRY,\n\tTXDONE_AMPDU,\n\tTXDONE_NO_ACK_REQ,\n};\n\n \nstruct txdone_entry_desc {\n\tunsigned long flags;\n\tint retry;\n};\n\n \nenum txentry_desc_flags {\n\tENTRY_TXD_RTS_FRAME,\n\tENTRY_TXD_CTS_FRAME,\n\tENTRY_TXD_GENERATE_SEQ,\n\tENTRY_TXD_FIRST_FRAGMENT,\n\tENTRY_TXD_MORE_FRAG,\n\tENTRY_TXD_REQ_TIMESTAMP,\n\tENTRY_TXD_BURST,\n\tENTRY_TXD_ACK,\n\tENTRY_TXD_RETRY_MODE,\n\tENTRY_TXD_ENCRYPT,\n\tENTRY_TXD_ENCRYPT_PAIRWISE,\n\tENTRY_TXD_ENCRYPT_IV,\n\tENTRY_TXD_ENCRYPT_MMIC,\n\tENTRY_TXD_HT_AMPDU,\n\tENTRY_TXD_HT_BW_40,\n\tENTRY_TXD_HT_SHORT_GI,\n\tENTRY_TXD_HT_MIMO_PS,\n};\n\n \nstruct txentry_desc {\n\tunsigned long flags;\n\n\tu16 length;\n\tu16 header_length;\n\n\tunion {\n\t\tstruct {\n\t\t\tu16 length_high;\n\t\t\tu16 length_low;\n\t\t\tu16 signal;\n\t\t\tu16 service;\n\t\t\tenum ifs ifs;\n\t\t} plcp;\n\n\t\tstruct {\n\t\t\tu16 mcs;\n\t\t\tu8 stbc;\n\t\t\tu8 ba_size;\n\t\t\tu8 mpdu_density;\n\t\t\tenum txop txop;\n\t\t\tint wcid;\n\t\t} ht;\n\t} u;\n\n\tenum rate_modulation rate_mode;\n\n\tshort retry_limit;\n\n\tenum cipher cipher;\n\tu16 key_idx;\n\tu16 iv_offset;\n\tu16 iv_len;\n};\n\n \nenum queue_entry_flags {\n\tENTRY_BCN_ASSIGNED,\n\tENTRY_BCN_ENABLED,\n\tENTRY_OWNER_DEVICE_DATA,\n\tENTRY_DATA_PENDING,\n\tENTRY_DATA_IO_FAILED,\n\tENTRY_DATA_STATUS_PENDING,\n};\n\n \nstruct queue_entry {\n\tunsigned long flags;\n\tunsigned long last_action;\n\n\tstruct data_queue *queue;\n\n\tstruct sk_buff *skb;\n\n\tunsigned int entry_idx;\n\n\tvoid *priv_data;\n};\n\n \nenum queue_index {\n\tQ_INDEX,\n\tQ_INDEX_DMA_DONE,\n\tQ_INDEX_DONE,\n\tQ_INDEX_MAX,\n};\n\n \nenum data_queue_flags {\n\tQUEUE_STARTED,\n\tQUEUE_PAUSED,\n};\n\n \nstruct data_queue {\n\tstruct rt2x00_dev *rt2x00dev;\n\tstruct queue_entry *entries;\n\n\tenum data_queue_qid qid;\n\tunsigned long flags;\n\n\tstruct mutex status_lock;\n\tspinlock_t tx_lock;\n\tspinlock_t index_lock;\n\n\tunsigned int count;\n\tunsigned short limit;\n\tunsigned short threshold;\n\tunsigned short length;\n\tunsigned short index[Q_INDEX_MAX];\n\n\tunsigned short wd_count;\n\tunsigned int wd_idx;\n\n\tunsigned short txop;\n\tunsigned short aifs;\n\tunsigned short cw_min;\n\tunsigned short cw_max;\n\n\tunsigned short data_size;\n\tunsigned char  desc_size;\n\tunsigned char  winfo_size;\n\tunsigned short priv_size;\n\n\tunsigned short usb_endpoint;\n\tunsigned short usb_maxpacket;\n};\n\n \n#define queue_end(__dev) \\\n\t&(__dev)->rx[(__dev)->data_queues]\n\n \n#define tx_queue_end(__dev) \\\n\t&(__dev)->tx[(__dev)->ops->tx_queues]\n\n \n#define queue_next(__queue) \\\n\t&(__queue)[1]\n\n \n#define queue_loop(__entry, __start, __end)\t\t\t\\\n\tfor ((__entry) = (__start);\t\t\t\t\\\n\t     prefetch(queue_next(__entry)), (__entry) != (__end);\\\n\t     (__entry) = queue_next(__entry))\n\n \n#define queue_for_each(__dev, __entry) \\\n\tqueue_loop(__entry, (__dev)->rx, queue_end(__dev))\n\n \n#define tx_queue_for_each(__dev, __entry) \\\n\tqueue_loop(__entry, (__dev)->tx, tx_queue_end(__dev))\n\n \n#define txall_queue_for_each(__dev, __entry) \\\n\tqueue_loop(__entry, (__dev)->tx, queue_end(__dev))\n\n \nbool rt2x00queue_for_each_entry(struct data_queue *queue,\n\t\t\t\tenum queue_index start,\n\t\t\t\tenum queue_index end,\n\t\t\t\tvoid *data,\n\t\t\t\tbool (*fn)(struct queue_entry *entry,\n\t\t\t\t\t   void *data));\n\n \nstatic inline int rt2x00queue_empty(struct data_queue *queue)\n{\n\treturn queue->length == 0;\n}\n\n \nstatic inline int rt2x00queue_full(struct data_queue *queue)\n{\n\treturn queue->length == queue->limit;\n}\n\n \nstatic inline int rt2x00queue_available(struct data_queue *queue)\n{\n\treturn queue->limit - queue->length;\n}\n\n \nstatic inline int rt2x00queue_threshold(struct data_queue *queue)\n{\n\treturn rt2x00queue_available(queue) < queue->threshold;\n}\n \nstatic inline int rt2x00queue_dma_timeout(struct queue_entry *entry)\n{\n\tif (!test_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags))\n\t\treturn false;\n\treturn time_after(jiffies, entry->last_action + msecs_to_jiffies(100));\n}\n\n \nstatic inline __le32 _rt2x00_desc_read(__le32 *desc, const u8 word)\n{\n\treturn desc[word];\n}\n\n \nstatic inline u32 rt2x00_desc_read(__le32 *desc, const u8 word)\n{\n\treturn le32_to_cpu(_rt2x00_desc_read(desc, word));\n}\n\n \nstatic inline void _rt2x00_desc_write(__le32 *desc, const u8 word, __le32 value)\n{\n\tdesc[word] = value;\n}\n\n \nstatic inline void rt2x00_desc_write(__le32 *desc, const u8 word, u32 value)\n{\n\t_rt2x00_desc_write(desc, word, cpu_to_le32(value));\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}