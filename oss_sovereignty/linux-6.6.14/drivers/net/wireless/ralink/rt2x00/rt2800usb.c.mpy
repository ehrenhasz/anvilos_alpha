{
  "module_name": "rt2800usb.c",
  "hash_id": "1915338b26287df1c1b0245fb6727cf6aa1829452ee418fa0a7583c0d31c7c89",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ralink/rt2x00/rt2800usb.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/delay.h>\n#include <linux/etherdevice.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n\n#include \"rt2x00.h\"\n#include \"rt2x00usb.h\"\n#include \"rt2800lib.h\"\n#include \"rt2800.h\"\n#include \"rt2800usb.h\"\n\n \nstatic bool modparam_nohwcrypt;\nmodule_param_named(nohwcrypt, modparam_nohwcrypt, bool, 0444);\nMODULE_PARM_DESC(nohwcrypt, \"Disable hardware encryption.\");\n\nstatic bool rt2800usb_hwcrypt_disabled(struct rt2x00_dev *rt2x00dev)\n{\n\treturn modparam_nohwcrypt;\n}\n\n \nstatic void rt2800usb_start_queue(struct data_queue *queue)\n{\n\tstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\n\tu32 reg;\n\n\tswitch (queue->qid) {\n\tcase QID_RX:\n\t\treg = rt2x00usb_register_read(rt2x00dev, MAC_SYS_CTRL);\n\t\trt2x00_set_field32(&reg, MAC_SYS_CTRL_ENABLE_RX, 1);\n\t\trt2x00usb_register_write(rt2x00dev, MAC_SYS_CTRL, reg);\n\t\tbreak;\n\tcase QID_BEACON:\n\t\treg = rt2x00usb_register_read(rt2x00dev, BCN_TIME_CFG);\n\t\trt2x00_set_field32(&reg, BCN_TIME_CFG_TSF_TICKING, 1);\n\t\trt2x00_set_field32(&reg, BCN_TIME_CFG_TBTT_ENABLE, 1);\n\t\trt2x00_set_field32(&reg, BCN_TIME_CFG_BEACON_GEN, 1);\n\t\trt2x00usb_register_write(rt2x00dev, BCN_TIME_CFG, reg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void rt2800usb_stop_queue(struct data_queue *queue)\n{\n\tstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\n\tu32 reg;\n\n\tswitch (queue->qid) {\n\tcase QID_RX:\n\t\treg = rt2x00usb_register_read(rt2x00dev, MAC_SYS_CTRL);\n\t\trt2x00_set_field32(&reg, MAC_SYS_CTRL_ENABLE_RX, 0);\n\t\trt2x00usb_register_write(rt2x00dev, MAC_SYS_CTRL, reg);\n\t\tbreak;\n\tcase QID_BEACON:\n\t\treg = rt2x00usb_register_read(rt2x00dev, BCN_TIME_CFG);\n\t\trt2x00_set_field32(&reg, BCN_TIME_CFG_TSF_TICKING, 0);\n\t\trt2x00_set_field32(&reg, BCN_TIME_CFG_TBTT_ENABLE, 0);\n\t\trt2x00_set_field32(&reg, BCN_TIME_CFG_BEACON_GEN, 0);\n\t\trt2x00usb_register_write(rt2x00dev, BCN_TIME_CFG, reg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n#define TXSTATUS_READ_INTERVAL 1000000\n\nstatic bool rt2800usb_tx_sta_fifo_read_completed(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t\t\t int urb_status, u32 tx_status)\n{\n\tbool valid;\n\n\tif (urb_status) {\n\t\trt2x00_warn(rt2x00dev, \"TX status read failed %d\\n\",\n\t\t\t    urb_status);\n\n\t\tgoto stop_reading;\n\t}\n\n\tvalid = rt2x00_get_field32(tx_status, TX_STA_FIFO_VALID);\n\tif (valid) {\n\t\tif (!kfifo_put(&rt2x00dev->txstatus_fifo, tx_status))\n\t\t\trt2x00_warn(rt2x00dev, \"TX status FIFO overrun\\n\");\n\n\t\tqueue_work(rt2x00dev->workqueue, &rt2x00dev->txdone_work);\n\n\t\t \n\t\treturn true;\n\t}\n\n\t \n\tif (rt2800_txstatus_timeout(rt2x00dev))\n\t\tqueue_work(rt2x00dev->workqueue, &rt2x00dev->txdone_work);\n\n\tif (rt2800_txstatus_pending(rt2x00dev)) {\n\t\t \n\t\thrtimer_start(&rt2x00dev->txstatus_timer,\n\t\t\t      TXSTATUS_READ_INTERVAL,\n\t\t\t      HRTIMER_MODE_REL);\n\t\treturn false;\n\t}\n\nstop_reading:\n\tclear_bit(TX_STATUS_READING, &rt2x00dev->flags);\n\t \n\tif (rt2800_txstatus_pending(rt2x00dev) &&\n\t    !test_and_set_bit(TX_STATUS_READING, &rt2x00dev->flags))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic void rt2800usb_async_read_tx_status(struct rt2x00_dev *rt2x00dev)\n{\n\n\tif (test_and_set_bit(TX_STATUS_READING, &rt2x00dev->flags))\n\t\treturn;\n\n\t \n\thrtimer_start(&rt2x00dev->txstatus_timer,\n\t\t      2 * TXSTATUS_READ_INTERVAL,\n\t\t      HRTIMER_MODE_REL);\n}\n\nstatic void rt2800usb_tx_dma_done(struct queue_entry *entry)\n{\n\tstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\n\n\trt2800usb_async_read_tx_status(rt2x00dev);\n}\n\nstatic enum hrtimer_restart rt2800usb_tx_sta_fifo_timeout(struct hrtimer *timer)\n{\n\tstruct rt2x00_dev *rt2x00dev =\n\t    container_of(timer, struct rt2x00_dev, txstatus_timer);\n\n\trt2x00usb_register_read_async(rt2x00dev, TX_STA_FIFO,\n\t\t\t\t      rt2800usb_tx_sta_fifo_read_completed);\n\n\treturn HRTIMER_NORESTART;\n}\n\n \nstatic int rt2800usb_autorun_detect(struct rt2x00_dev *rt2x00dev)\n{\n\t__le32 *reg;\n\tu32 fw_mode;\n\tint ret;\n\n\treg = kmalloc(sizeof(*reg), GFP_KERNEL);\n\tif (reg == NULL)\n\t\treturn -ENOMEM;\n\t \n\tret = rt2x00usb_vendor_request(rt2x00dev, USB_DEVICE_MODE,\n\t\t\t\t       USB_VENDOR_REQUEST_IN, 0,\n\t\t\t\t       USB_MODE_AUTORUN, reg, sizeof(*reg),\n\t\t\t\t       REGISTER_TIMEOUT_FIRMWARE);\n\tfw_mode = le32_to_cpu(*reg);\n\tkfree(reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif ((fw_mode & 0x00000003) == 2)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic char *rt2800usb_get_firmware_name(struct rt2x00_dev *rt2x00dev)\n{\n\treturn FIRMWARE_RT2870;\n}\n\nstatic int rt2800usb_write_firmware(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t    const u8 *data, const size_t len)\n{\n\tint status;\n\tu32 offset;\n\tu32 length;\n\tint retval;\n\n\t \n\tif (rt2x00_rt(rt2x00dev, RT2860) ||\n\t    rt2x00_rt(rt2x00dev, RT2872) ||\n\t    rt2x00_rt(rt2x00dev, RT3070)) {\n\t\toffset = 0;\n\t\tlength = 4096;\n\t} else {\n\t\toffset = 4096;\n\t\tlength = 4096;\n\t}\n\n\t \n\tretval = rt2800usb_autorun_detect(rt2x00dev);\n\tif (retval < 0)\n\t\treturn retval;\n\tif (retval) {\n\t\trt2x00_info(rt2x00dev,\n\t\t\t    \"Firmware loading not required - NIC in AutoRun mode\\n\");\n\t\t__clear_bit(REQUIRE_FIRMWARE, &rt2x00dev->cap_flags);\n\t} else {\n\t\trt2x00usb_register_multiwrite(rt2x00dev, FIRMWARE_IMAGE_BASE,\n\t\t\t\t\t      data + offset, length);\n\t}\n\n\trt2x00usb_register_write(rt2x00dev, H2M_MAILBOX_CID, ~0);\n\trt2x00usb_register_write(rt2x00dev, H2M_MAILBOX_STATUS, ~0);\n\n\t \n\tstatus = rt2x00usb_vendor_request_sw(rt2x00dev, USB_DEVICE_MODE,\n\t\t\t\t\t     0, USB_MODE_FIRMWARE,\n\t\t\t\t\t     REGISTER_TIMEOUT_FIRMWARE);\n\tif (status < 0) {\n\t\trt2x00_err(rt2x00dev, \"Failed to write Firmware to device\\n\");\n\t\treturn status;\n\t}\n\n\tmsleep(10);\n\trt2x00usb_register_write(rt2x00dev, H2M_MAILBOX_CSR, 0);\n\n\treturn 0;\n}\n\n \nstatic int rt2800usb_init_registers(struct rt2x00_dev *rt2x00dev)\n{\n\tu32 reg;\n\n\t \n\tif (rt2800_wait_csr_ready(rt2x00dev))\n\t\treturn -EBUSY;\n\n\treg = rt2x00usb_register_read(rt2x00dev, PBF_SYS_CTRL);\n\trt2x00usb_register_write(rt2x00dev, PBF_SYS_CTRL, reg & ~0x00002000);\n\n\treg = 0;\n\trt2x00_set_field32(&reg, MAC_SYS_CTRL_RESET_CSR, 1);\n\trt2x00_set_field32(&reg, MAC_SYS_CTRL_RESET_BBP, 1);\n\trt2x00usb_register_write(rt2x00dev, MAC_SYS_CTRL, reg);\n\n\trt2x00usb_vendor_request_sw(rt2x00dev, USB_DEVICE_MODE, 0,\n\t\t\t\t    USB_MODE_RESET, REGISTER_TIMEOUT);\n\n\trt2x00usb_register_write(rt2x00dev, MAC_SYS_CTRL, 0x00000000);\n\n\treturn 0;\n}\n\nstatic int rt2800usb_enable_radio(struct rt2x00_dev *rt2x00dev)\n{\n\tu32 reg = 0;\n\n\tif (unlikely(rt2800_wait_wpdma_ready(rt2x00dev)))\n\t\treturn -EIO;\n\n\trt2x00_set_field32(&reg, USB_DMA_CFG_PHY_CLEAR, 0);\n\trt2x00_set_field32(&reg, USB_DMA_CFG_RX_BULK_AGG_EN, 0);\n\trt2x00_set_field32(&reg, USB_DMA_CFG_RX_BULK_AGG_TIMEOUT, 128);\n\t \n\trt2x00_set_field32(&reg, USB_DMA_CFG_RX_BULK_AGG_LIMIT,\n\t\t\t   ((rt2x00dev->rx->limit * DATA_FRAME_SIZE)\n\t\t\t    / 1024) - 3);\n\trt2x00_set_field32(&reg, USB_DMA_CFG_RX_BULK_EN, 1);\n\trt2x00_set_field32(&reg, USB_DMA_CFG_TX_BULK_EN, 1);\n\trt2x00usb_register_write(rt2x00dev, USB_DMA_CFG, reg);\n\n\treturn rt2800_enable_radio(rt2x00dev);\n}\n\nstatic void rt2800usb_disable_radio(struct rt2x00_dev *rt2x00dev)\n{\n\trt2800_disable_radio(rt2x00dev);\n}\n\nstatic int rt2800usb_set_state(struct rt2x00_dev *rt2x00dev,\n\t\t\t       enum dev_state state)\n{\n\tif (state == STATE_AWAKE)\n\t\trt2800_mcu_request(rt2x00dev, MCU_WAKEUP, 0xff, 0, 2);\n\telse\n\t\trt2800_mcu_request(rt2x00dev, MCU_SLEEP, 0xff, 0xff, 2);\n\n\treturn 0;\n}\n\nstatic int rt2800usb_set_device_state(struct rt2x00_dev *rt2x00dev,\n\t\t\t\t      enum dev_state state)\n{\n\tint retval = 0;\n\n\tswitch (state) {\n\tcase STATE_RADIO_ON:\n\t\t \n\t\trt2800usb_set_state(rt2x00dev, STATE_AWAKE);\n\t\tmsleep(1);\n\t\tretval = rt2800usb_enable_radio(rt2x00dev);\n\t\tbreak;\n\tcase STATE_RADIO_OFF:\n\t\t \n\t\trt2800usb_disable_radio(rt2x00dev);\n\t\trt2800usb_set_state(rt2x00dev, STATE_SLEEP);\n\t\tbreak;\n\tcase STATE_RADIO_IRQ_ON:\n\tcase STATE_RADIO_IRQ_OFF:\n\t\t \n\t\tbreak;\n\tcase STATE_DEEP_SLEEP:\n\tcase STATE_SLEEP:\n\tcase STATE_STANDBY:\n\tcase STATE_AWAKE:\n\t\tretval = rt2800usb_set_state(rt2x00dev, state);\n\t\tbreak;\n\tdefault:\n\t\tretval = -ENOTSUPP;\n\t\tbreak;\n\t}\n\n\tif (unlikely(retval))\n\t\trt2x00_err(rt2x00dev, \"Device failed to enter state %d (%d)\\n\",\n\t\t\t   state, retval);\n\n\treturn retval;\n}\n\nstatic unsigned int rt2800usb_get_dma_done(struct data_queue *queue)\n{\n\tstruct queue_entry *entry;\n\n\tentry = rt2x00queue_get_entry(queue, Q_INDEX_DMA_DONE);\n\treturn entry->entry_idx;\n}\n\n \nstatic __le32 *rt2800usb_get_txwi(struct queue_entry *entry)\n{\n\tif (entry->queue->qid == QID_BEACON)\n\t\treturn (__le32 *) (entry->skb->data);\n\telse\n\t\treturn (__le32 *) (entry->skb->data + TXINFO_DESC_SIZE);\n}\n\nstatic void rt2800usb_write_tx_desc(struct queue_entry *entry,\n\t\t\t\t    struct txentry_desc *txdesc)\n{\n\tstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\n\t__le32 *txi = (__le32 *) entry->skb->data;\n\tu32 word;\n\n\t \n\tword = rt2x00_desc_read(txi, 0);\n\n\t \n\trt2x00_set_field32(&word, TXINFO_W0_USB_DMA_TX_PKT_LEN,\n\t\t\t   roundup(entry->skb->len, 4) - TXINFO_DESC_SIZE);\n\trt2x00_set_field32(&word, TXINFO_W0_WIV,\n\t\t\t   !test_bit(ENTRY_TXD_ENCRYPT_IV, &txdesc->flags));\n\trt2x00_set_field32(&word, TXINFO_W0_QSEL, 2);\n\trt2x00_set_field32(&word, TXINFO_W0_SW_USE_LAST_ROUND, 0);\n\trt2x00_set_field32(&word, TXINFO_W0_USB_DMA_NEXT_VALID, 0);\n\trt2x00_set_field32(&word, TXINFO_W0_USB_DMA_TX_BURST,\n\t\t\t   test_bit(ENTRY_TXD_BURST, &txdesc->flags));\n\trt2x00_desc_write(txi, 0, word);\n\n\t \n\tskbdesc->flags |= SKBDESC_DESC_IN_SKB;\n\tskbdesc->desc = txi;\n\tskbdesc->desc_len = TXINFO_DESC_SIZE + entry->queue->winfo_size;\n}\n\n \nstatic int rt2800usb_get_tx_data_len(struct queue_entry *entry)\n{\n\t \n\n\treturn roundup(entry->skb->len, 4) + 4;\n}\n\n \nstatic void rt2800usb_work_txdone(struct work_struct *work)\n{\n\tstruct rt2x00_dev *rt2x00dev =\n\t    container_of(work, struct rt2x00_dev, txdone_work);\n\n\twhile (!kfifo_is_empty(&rt2x00dev->txstatus_fifo) ||\n\t       rt2800_txstatus_timeout(rt2x00dev)) {\n\n\t\trt2800_txdone(rt2x00dev, UINT_MAX);\n\n\t\trt2800_txdone_nostatus(rt2x00dev);\n\n\t\t \n\t\tif (rt2800_txstatus_pending(rt2x00dev))\n\t\t\trt2800usb_async_read_tx_status(rt2x00dev);\n\t}\n}\n\n \nstatic void rt2800usb_fill_rxdone(struct queue_entry *entry,\n\t\t\t\t  struct rxdone_entry_desc *rxdesc)\n{\n\tstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\n\t__le32 *rxi = (__le32 *)entry->skb->data;\n\t__le32 *rxd;\n\tu32 word;\n\tint rx_pkt_len;\n\n\t \n\tmemcpy(skbdesc->desc, rxi, skbdesc->desc_len);\n\n\t \n\tword = rt2x00_desc_read(rxi, 0);\n\trx_pkt_len = rt2x00_get_field32(word, RXINFO_W0_USB_DMA_RX_PKT_LEN);\n\n\t \n\tskb_pull(entry->skb, RXINFO_DESC_SIZE);\n\n\t \n\tif (unlikely(rx_pkt_len == 0 ||\n\t\t\trx_pkt_len > entry->queue->data_size)) {\n\t\trt2x00_err(entry->queue->rt2x00dev,\n\t\t\t   \"Bad frame size %d, forcing to 0\\n\", rx_pkt_len);\n\t\treturn;\n\t}\n\n\trxd = (__le32 *)(entry->skb->data + rx_pkt_len);\n\n\t \n\tword = rt2x00_desc_read(rxd, 0);\n\n\tif (rt2x00_get_field32(word, RXD_W0_CRC_ERROR))\n\t\trxdesc->flags |= RX_FLAG_FAILED_FCS_CRC;\n\n\trxdesc->cipher_status = rt2x00_get_field32(word, RXD_W0_CIPHER_ERROR);\n\n\tif (rt2x00_get_field32(word, RXD_W0_DECRYPTED)) {\n\t\t \n\t\trxdesc->flags |= RX_FLAG_IV_STRIPPED;\n\n\t\t \n\t\trxdesc->flags |= RX_FLAG_MMIC_STRIPPED;\n\n\t\tif (rxdesc->cipher_status == RX_CRYPTO_SUCCESS) {\n\t\t\trxdesc->flags |= RX_FLAG_DECRYPTED;\n\t\t} else if (rxdesc->cipher_status == RX_CRYPTO_FAIL_MIC) {\n\t\t\t \n\t\t\trxdesc->flags |= RX_FLAG_DECRYPTED;\n\n\t\t\trxdesc->flags |= RX_FLAG_MMIC_ERROR;\n\t\t}\n\t}\n\n\tif (rt2x00_get_field32(word, RXD_W0_MY_BSS))\n\t\trxdesc->dev_flags |= RXDONE_MY_BSS;\n\n\tif (rt2x00_get_field32(word, RXD_W0_L2PAD))\n\t\trxdesc->dev_flags |= RXDONE_L2PAD;\n\n\t \n\tskb_trim(entry->skb, rx_pkt_len);\n\n\t \n\trt2800_process_rxwi(entry, rxdesc);\n}\n\n \nstatic int rt2800usb_efuse_detect(struct rt2x00_dev *rt2x00dev)\n{\n\tint retval;\n\n\tretval = rt2800usb_autorun_detect(rt2x00dev);\n\tif (retval < 0)\n\t\treturn retval;\n\tif (retval)\n\t\treturn 1;\n\treturn rt2800_efuse_detect(rt2x00dev);\n}\n\nstatic int rt2800usb_read_eeprom(struct rt2x00_dev *rt2x00dev)\n{\n\tint retval;\n\n\tretval = rt2800usb_efuse_detect(rt2x00dev);\n\tif (retval < 0)\n\t\treturn retval;\n\tif (retval)\n\t\tretval = rt2800_read_eeprom_efuse(rt2x00dev);\n\telse\n\t\tretval = rt2x00usb_eeprom_read(rt2x00dev, rt2x00dev->eeprom,\n\t\t\t\t\t       EEPROM_SIZE);\n\n\treturn retval;\n}\n\nstatic int rt2800usb_probe_hw(struct rt2x00_dev *rt2x00dev)\n{\n\tint retval;\n\n\tretval = rt2800_probe_hw(rt2x00dev);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\trt2x00dev->txstatus_timer.function = rt2800usb_tx_sta_fifo_timeout;\n\n\t \n\tINIT_WORK(&rt2x00dev->txdone_work, rt2800usb_work_txdone);\n\n\treturn 0;\n}\n\nstatic const struct ieee80211_ops rt2800usb_mac80211_ops = {\n\t.tx\t\t\t= rt2x00mac_tx,\n\t.wake_tx_queue\t\t= ieee80211_handle_wake_tx_queue,\n\t.start\t\t\t= rt2x00mac_start,\n\t.stop\t\t\t= rt2x00mac_stop,\n\t.add_interface\t\t= rt2x00mac_add_interface,\n\t.remove_interface\t= rt2x00mac_remove_interface,\n\t.config\t\t\t= rt2x00mac_config,\n\t.configure_filter\t= rt2x00mac_configure_filter,\n\t.set_tim\t\t= rt2x00mac_set_tim,\n\t.set_key\t\t= rt2x00mac_set_key,\n\t.sw_scan_start\t\t= rt2x00mac_sw_scan_start,\n\t.sw_scan_complete\t= rt2x00mac_sw_scan_complete,\n\t.get_stats\t\t= rt2x00mac_get_stats,\n\t.get_key_seq\t\t= rt2800_get_key_seq,\n\t.set_rts_threshold\t= rt2800_set_rts_threshold,\n\t.sta_add\t\t= rt2800_sta_add,\n\t.sta_remove\t\t= rt2800_sta_remove,\n\t.bss_info_changed\t= rt2x00mac_bss_info_changed,\n\t.conf_tx\t\t= rt2800_conf_tx,\n\t.get_tsf\t\t= rt2800_get_tsf,\n\t.rfkill_poll\t\t= rt2x00mac_rfkill_poll,\n\t.ampdu_action\t\t= rt2800_ampdu_action,\n\t.flush\t\t\t= rt2x00mac_flush,\n\t.get_survey\t\t= rt2800_get_survey,\n\t.get_ringparam\t\t= rt2x00mac_get_ringparam,\n\t.tx_frames_pending\t= rt2x00mac_tx_frames_pending,\n\t.reconfig_complete\t= rt2x00mac_reconfig_complete,\n};\n\nstatic const struct rt2800_ops rt2800usb_rt2800_ops = {\n\t.register_read\t\t= rt2x00usb_register_read,\n\t.register_read_lock\t= rt2x00usb_register_read_lock,\n\t.register_write\t\t= rt2x00usb_register_write,\n\t.register_write_lock\t= rt2x00usb_register_write_lock,\n\t.register_multiread\t= rt2x00usb_register_multiread,\n\t.register_multiwrite\t= rt2x00usb_register_multiwrite,\n\t.regbusy_read\t\t= rt2x00usb_regbusy_read,\n\t.read_eeprom\t\t= rt2800usb_read_eeprom,\n\t.hwcrypt_disabled\t= rt2800usb_hwcrypt_disabled,\n\t.drv_write_firmware\t= rt2800usb_write_firmware,\n\t.drv_init_registers\t= rt2800usb_init_registers,\n\t.drv_get_txwi\t\t= rt2800usb_get_txwi,\n\t.drv_get_dma_done\t= rt2800usb_get_dma_done,\n};\n\nstatic const struct rt2x00lib_ops rt2800usb_rt2x00_ops = {\n\t.probe_hw\t\t= rt2800usb_probe_hw,\n\t.get_firmware_name\t= rt2800usb_get_firmware_name,\n\t.check_firmware\t\t= rt2800_check_firmware,\n\t.load_firmware\t\t= rt2800_load_firmware,\n\t.initialize\t\t= rt2x00usb_initialize,\n\t.uninitialize\t\t= rt2x00usb_uninitialize,\n\t.clear_entry\t\t= rt2x00usb_clear_entry,\n\t.set_device_state\t= rt2800usb_set_device_state,\n\t.rfkill_poll\t\t= rt2800_rfkill_poll,\n\t.link_stats\t\t= rt2800_link_stats,\n\t.reset_tuner\t\t= rt2800_reset_tuner,\n\t.link_tuner\t\t= rt2800_link_tuner,\n\t.gain_calibration\t= rt2800_gain_calibration,\n\t.vco_calibration\t= rt2800_vco_calibration,\n\t.watchdog\t\t= rt2800_watchdog,\n\t.start_queue\t\t= rt2800usb_start_queue,\n\t.kick_queue\t\t= rt2x00usb_kick_queue,\n\t.stop_queue\t\t= rt2800usb_stop_queue,\n\t.flush_queue\t\t= rt2x00usb_flush_queue,\n\t.tx_dma_done\t\t= rt2800usb_tx_dma_done,\n\t.write_tx_desc\t\t= rt2800usb_write_tx_desc,\n\t.write_tx_data\t\t= rt2800_write_tx_data,\n\t.write_beacon\t\t= rt2800_write_beacon,\n\t.clear_beacon\t\t= rt2800_clear_beacon,\n\t.get_tx_data_len\t= rt2800usb_get_tx_data_len,\n\t.fill_rxdone\t\t= rt2800usb_fill_rxdone,\n\t.config_shared_key\t= rt2800_config_shared_key,\n\t.config_pairwise_key\t= rt2800_config_pairwise_key,\n\t.config_filter\t\t= rt2800_config_filter,\n\t.config_intf\t\t= rt2800_config_intf,\n\t.config_erp\t\t= rt2800_config_erp,\n\t.config_ant\t\t= rt2800_config_ant,\n\t.config\t\t\t= rt2800_config,\n\t.pre_reset_hw\t\t= rt2800_pre_reset_hw,\n};\n\nstatic void rt2800usb_queue_init(struct data_queue *queue)\n{\n\tstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\n\tunsigned short txwi_size, rxwi_size;\n\n\trt2800_get_txwi_rxwi_size(rt2x00dev, &txwi_size, &rxwi_size);\n\n\tswitch (queue->qid) {\n\tcase QID_RX:\n\t\tqueue->limit = 128;\n\t\tqueue->data_size = AGGREGATION_SIZE;\n\t\tqueue->desc_size = RXINFO_DESC_SIZE;\n\t\tqueue->winfo_size = rxwi_size;\n\t\tqueue->priv_size = sizeof(struct queue_entry_priv_usb);\n\t\tbreak;\n\n\tcase QID_AC_VO:\n\tcase QID_AC_VI:\n\tcase QID_AC_BE:\n\tcase QID_AC_BK:\n\t\tqueue->limit = 16;\n\t\tqueue->data_size = AGGREGATION_SIZE;\n\t\tqueue->desc_size = TXINFO_DESC_SIZE;\n\t\tqueue->winfo_size = txwi_size;\n\t\tqueue->priv_size = sizeof(struct queue_entry_priv_usb);\n\t\tbreak;\n\n\tcase QID_BEACON:\n\t\tqueue->limit = 8;\n\t\tqueue->data_size = MGMT_FRAME_SIZE;\n\t\tqueue->desc_size = TXINFO_DESC_SIZE;\n\t\tqueue->winfo_size = txwi_size;\n\t\tqueue->priv_size = sizeof(struct queue_entry_priv_usb);\n\t\tbreak;\n\n\tcase QID_ATIM:\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n}\n\nstatic const struct rt2x00_ops rt2800usb_ops = {\n\t.name\t\t\t= KBUILD_MODNAME,\n\t.drv_data_size\t\t= sizeof(struct rt2800_drv_data),\n\t.max_ap_intf\t\t= 8,\n\t.eeprom_size\t\t= EEPROM_SIZE,\n\t.rf_size\t\t= RF_SIZE,\n\t.tx_queues\t\t= NUM_TX_QUEUES,\n\t.queue_init\t\t= rt2800usb_queue_init,\n\t.lib\t\t\t= &rt2800usb_rt2x00_ops,\n\t.drv\t\t\t= &rt2800usb_rt2800_ops,\n\t.hw\t\t\t= &rt2800usb_mac80211_ops,\n#ifdef CONFIG_RT2X00_LIB_DEBUGFS\n\t.debugfs\t\t= &rt2800_rt2x00debug,\n#endif  \n};\n\n \nstatic const struct usb_device_id rt2800usb_device_table[] = {\n\t \n\t{ USB_DEVICE(0x07b8, 0x2870) },\n\t{ USB_DEVICE(0x07b8, 0x2770) },\n\t{ USB_DEVICE(0x07b8, 0x3070) },\n\t{ USB_DEVICE(0x07b8, 0x3071) },\n\t{ USB_DEVICE(0x07b8, 0x3072) },\n\t{ USB_DEVICE(0x1482, 0x3c09) },\n\t \n\t{ USB_DEVICE(0x1eda, 0x2012) },\n\t{ USB_DEVICE(0x1eda, 0x2210) },\n\t{ USB_DEVICE(0x1eda, 0x2310) },\n\t \n\t{ USB_DEVICE(0x8516, 0x2070) },\n\t{ USB_DEVICE(0x8516, 0x2770) },\n\t{ USB_DEVICE(0x8516, 0x2870) },\n\t{ USB_DEVICE(0x8516, 0x3070) },\n\t{ USB_DEVICE(0x8516, 0x3071) },\n\t{ USB_DEVICE(0x8516, 0x3072) },\n\t \n\t{ USB_DEVICE(0x14b2, 0x3c06) },\n\t{ USB_DEVICE(0x14b2, 0x3c07) },\n\t{ USB_DEVICE(0x14b2, 0x3c09) },\n\t{ USB_DEVICE(0x14b2, 0x3c12) },\n\t{ USB_DEVICE(0x14b2, 0x3c23) },\n\t{ USB_DEVICE(0x14b2, 0x3c25) },\n\t{ USB_DEVICE(0x14b2, 0x3c27) },\n\t{ USB_DEVICE(0x14b2, 0x3c28) },\n\t{ USB_DEVICE(0x14b2, 0x3c2c) },\n\t \n\t{ USB_DEVICE(0x15c5, 0x0008) },\n\t \n\t{ USB_DEVICE(0x1690, 0x0740) },\n\t \n\t{ USB_DEVICE(0x0b05, 0x1731) },\n\t{ USB_DEVICE(0x0b05, 0x1732) },\n\t{ USB_DEVICE(0x0b05, 0x1742) },\n\t{ USB_DEVICE(0x0b05, 0x1784) },\n\t{ USB_DEVICE(0x1761, 0x0b05) },\n\t \n\t{ USB_DEVICE(0x13d3, 0x3247) },\n\t{ USB_DEVICE(0x13d3, 0x3273) },\n\t{ USB_DEVICE(0x13d3, 0x3305) },\n\t{ USB_DEVICE(0x13d3, 0x3307) },\n\t{ USB_DEVICE(0x13d3, 0x3321) },\n\t \n\t{ USB_DEVICE(0x050d, 0x8053) },\n\t{ USB_DEVICE(0x050d, 0x805c) },\n\t{ USB_DEVICE(0x050d, 0x815c) },\n\t{ USB_DEVICE(0x050d, 0x825a) },\n\t{ USB_DEVICE(0x050d, 0x825b) },\n\t{ USB_DEVICE(0x050d, 0x935a) },\n\t{ USB_DEVICE(0x050d, 0x935b) },\n\t \n\t{ USB_DEVICE(0x0411, 0x00e8) },\n\t{ USB_DEVICE(0x0411, 0x0158) },\n\t{ USB_DEVICE(0x0411, 0x015d) },\n\t{ USB_DEVICE(0x0411, 0x016f) },\n\t{ USB_DEVICE(0x0411, 0x01a2) },\n\t{ USB_DEVICE(0x0411, 0x01ee) },\n\t{ USB_DEVICE(0x0411, 0x01a8) },\n\t{ USB_DEVICE(0x0411, 0x01fd) },\n\t \n\t{ USB_DEVICE(0x07aa, 0x002f) },\n\t{ USB_DEVICE(0x07aa, 0x003c) },\n\t{ USB_DEVICE(0x07aa, 0x003f) },\n\t{ USB_DEVICE(0x18c5, 0x0012) },\n\t \n\t{ USB_DEVICE(0x07d1, 0x3c09) },\n\t{ USB_DEVICE(0x07d1, 0x3c0a) },\n\t{ USB_DEVICE(0x07d1, 0x3c0d) },\n\t{ USB_DEVICE(0x07d1, 0x3c0e) },\n\t{ USB_DEVICE(0x07d1, 0x3c0f) },\n\t{ USB_DEVICE(0x07d1, 0x3c11) },\n\t{ USB_DEVICE(0x07d1, 0x3c13) },\n\t{ USB_DEVICE(0x07d1, 0x3c15) },\n\t{ USB_DEVICE(0x07d1, 0x3c16) },\n\t{ USB_DEVICE(0x07d1, 0x3c17) },\n\t{ USB_DEVICE(0x2001, 0x3317) },\n\t{ USB_DEVICE(0x2001, 0x3c1b) },\n\t{ USB_DEVICE(0x2001, 0x3c25) },\n\t \n\t{ USB_DEVICE(0x07fa, 0x7712) },\n\t \n\t{ USB_DEVICE(0x0fe9, 0xb307) },\n\t \n\t{ USB_DEVICE(0x7392, 0x4085) },\n\t{ USB_DEVICE(0x7392, 0x7711) },\n\t{ USB_DEVICE(0x7392, 0x7717) },\n\t{ USB_DEVICE(0x7392, 0x7718) },\n\t{ USB_DEVICE(0x7392, 0x7722) },\n\t \n\t{ USB_DEVICE(0x203d, 0x1480) },\n\t{ USB_DEVICE(0x203d, 0x14a9) },\n\t \n\t{ USB_DEVICE(0x1740, 0x9701) },\n\t{ USB_DEVICE(0x1740, 0x9702) },\n\t{ USB_DEVICE(0x1740, 0x9703) },\n\t{ USB_DEVICE(0x1740, 0x9705) },\n\t{ USB_DEVICE(0x1740, 0x9706) },\n\t{ USB_DEVICE(0x1740, 0x9707) },\n\t{ USB_DEVICE(0x1740, 0x9708) },\n\t{ USB_DEVICE(0x1740, 0x9709) },\n\t \n\t{ USB_DEVICE(0x15a9, 0x0012) },\n\t \n\t{ USB_DEVICE(0x1044, 0x800b) },\n\t{ USB_DEVICE(0x1044, 0x800d) },\n\t \n\t{ USB_DEVICE(0x0e66, 0x0001) },\n\t{ USB_DEVICE(0x0e66, 0x0003) },\n\t{ USB_DEVICE(0x0e66, 0x0009) },\n\t{ USB_DEVICE(0x0e66, 0x000b) },\n\t{ USB_DEVICE(0x0e66, 0x0013) },\n\t{ USB_DEVICE(0x0e66, 0x0017) },\n\t{ USB_DEVICE(0x0e66, 0x0018) },\n\t \n\t{ USB_DEVICE(0x04bb, 0x0945) },\n\t{ USB_DEVICE(0x04bb, 0x0947) },\n\t{ USB_DEVICE(0x04bb, 0x0948) },\n\t \n\t{ USB_DEVICE(0x13b1, 0x0031) },\n\t{ USB_DEVICE(0x1737, 0x0070) },\n\t{ USB_DEVICE(0x1737, 0x0071) },\n\t{ USB_DEVICE(0x1737, 0x0077) },\n\t{ USB_DEVICE(0x1737, 0x0078) },\n\t \n\t{ USB_DEVICE(0x0789, 0x0162) },\n\t{ USB_DEVICE(0x0789, 0x0163) },\n\t{ USB_DEVICE(0x0789, 0x0164) },\n\t{ USB_DEVICE(0x0789, 0x0166) },\n\t \n\t{ USB_DEVICE(0x100d, 0x9031) },\n\t \n\t{ USB_DEVICE(0x0db0, 0x3820) },\n\t{ USB_DEVICE(0x0db0, 0x3821) },\n\t{ USB_DEVICE(0x0db0, 0x3822) },\n\t{ USB_DEVICE(0x0db0, 0x3870) },\n\t{ USB_DEVICE(0x0db0, 0x3871) },\n\t{ USB_DEVICE(0x0db0, 0x6899) },\n\t{ USB_DEVICE(0x0db0, 0x821a) },\n\t{ USB_DEVICE(0x0db0, 0x822a) },\n\t{ USB_DEVICE(0x0db0, 0x822b) },\n\t{ USB_DEVICE(0x0db0, 0x822c) },\n\t{ USB_DEVICE(0x0db0, 0x870a) },\n\t{ USB_DEVICE(0x0db0, 0x871a) },\n\t{ USB_DEVICE(0x0db0, 0x871b) },\n\t{ USB_DEVICE(0x0db0, 0x871c) },\n\t{ USB_DEVICE(0x0db0, 0x899a) },\n\t \n\t{ USB_DEVICE(0x1b75, 0x3070) },\n\t{ USB_DEVICE(0x1b75, 0x3071) },\n\t{ USB_DEVICE(0x1b75, 0x3072) },\n\t{ USB_DEVICE(0x1b75, 0xa200) },\n\t \n\t{ USB_DEVICE(0x20b8, 0x8888) },\n\t \n\t{ USB_DEVICE(0x1d4d, 0x0002) },\n\t{ USB_DEVICE(0x1d4d, 0x000c) },\n\t{ USB_DEVICE(0x1d4d, 0x000e) },\n\t{ USB_DEVICE(0x1d4d, 0x0011) },\n\t \n\t{ USB_DEVICE(0x0471, 0x200f) },\n\t \n\t{ USB_DEVICE(0x2019, 0x5201) },\n\t{ USB_DEVICE(0x2019, 0xab25) },\n\t{ USB_DEVICE(0x2019, 0xed06) },\n\t \n\t{ USB_DEVICE(0x1a32, 0x0304) },\n\t \n\t{ USB_DEVICE(0x148f, 0x2070) },\n\t{ USB_DEVICE(0x148f, 0x2770) },\n\t{ USB_DEVICE(0x148f, 0x2870) },\n\t{ USB_DEVICE(0x148f, 0x3070) },\n\t{ USB_DEVICE(0x148f, 0x3071) },\n\t{ USB_DEVICE(0x148f, 0x3072) },\n\t \n\t{ USB_DEVICE(0x04e8, 0x2018) },\n\t \n\t{ USB_DEVICE(0x129b, 0x1828) },\n\t \n\t{ USB_DEVICE(0x0df6, 0x0017) },\n\t{ USB_DEVICE(0x0df6, 0x002b) },\n\t{ USB_DEVICE(0x0df6, 0x002c) },\n\t{ USB_DEVICE(0x0df6, 0x002d) },\n\t{ USB_DEVICE(0x0df6, 0x0039) },\n\t{ USB_DEVICE(0x0df6, 0x003b) },\n\t{ USB_DEVICE(0x0df6, 0x003d) },\n\t{ USB_DEVICE(0x0df6, 0x003e) },\n\t{ USB_DEVICE(0x0df6, 0x003f) },\n\t{ USB_DEVICE(0x0df6, 0x0040) },\n\t{ USB_DEVICE(0x0df6, 0x0042) },\n\t{ USB_DEVICE(0x0df6, 0x0047) },\n\t{ USB_DEVICE(0x0df6, 0x0048) },\n\t{ USB_DEVICE(0x0df6, 0x0051) },\n\t{ USB_DEVICE(0x0df6, 0x005f) },\n\t{ USB_DEVICE(0x0df6, 0x0060) },\n\t \n\t{ USB_DEVICE(0x083a, 0x6618) },\n\t{ USB_DEVICE(0x083a, 0x7511) },\n\t{ USB_DEVICE(0x083a, 0x7512) },\n\t{ USB_DEVICE(0x083a, 0x7522) },\n\t{ USB_DEVICE(0x083a, 0x8522) },\n\t{ USB_DEVICE(0x083a, 0xa618) },\n\t{ USB_DEVICE(0x083a, 0xa701) },\n\t{ USB_DEVICE(0x083a, 0xa702) },\n\t{ USB_DEVICE(0x083a, 0xa703) },\n\t{ USB_DEVICE(0x083a, 0xb522) },\n\t \n\t{ USB_DEVICE(0x15a9, 0x0006) },\n\t \n\t{ USB_DEVICE(0x177f, 0x0153) },\n\t{ USB_DEVICE(0x177f, 0x0164) },\n\t{ USB_DEVICE(0x177f, 0x0302) },\n\t{ USB_DEVICE(0x177f, 0x0313) },\n\t{ USB_DEVICE(0x177f, 0x0323) },\n\t{ USB_DEVICE(0x177f, 0x0324) },\n\t{ USB_DEVICE(0x177f, 0x1163) },\n\t \n\t{ USB_DEVICE(0x157e, 0x300e) },\n\t{ USB_DEVICE(0x157e, 0x3013) },\n\t \n\t{ USB_DEVICE(0x0cde, 0x0022) },\n\t{ USB_DEVICE(0x0cde, 0x0025) },\n\t \n\t{ USB_DEVICE(0x5a57, 0x0280) },\n\t{ USB_DEVICE(0x5a57, 0x0282) },\n\t{ USB_DEVICE(0x5a57, 0x0283) },\n\t{ USB_DEVICE(0x5a57, 0x5257) },\n\t \n\t{ USB_DEVICE(0x0586, 0x3416) },\n\t{ USB_DEVICE(0x0586, 0x3418) },\n\t{ USB_DEVICE(0x0586, 0x341a) },\n\t{ USB_DEVICE(0x0586, 0x341e) },\n\t{ USB_DEVICE(0x0586, 0x343e) },\n#ifdef CONFIG_RT2800USB_RT33XX\n\t \n\t{ USB_DEVICE(0x050d, 0x945b) },\n\t \n\t{ USB_DEVICE(0x2001, 0x3c17) },\n\t \n\t{ USB_DEVICE(0x083a, 0xb511) },\n\t \n\t{ USB_DEVICE(0x083a, 0xb512) },\n\t \n\t{ USB_DEVICE(0x0471, 0x20dd) },\n\t \n\t{ USB_DEVICE(0x148f, 0x3370) },\n\t{ USB_DEVICE(0x148f, 0x8070) },\n\t \n\t{ USB_DEVICE(0x0df6, 0x0050) },\n\t \n\t{ USB_DEVICE(0x177f, 0x0163) },\n\t{ USB_DEVICE(0x177f, 0x0165) },\n#endif\n#ifdef CONFIG_RT2800USB_RT35XX\n\t \n\t{ USB_DEVICE(0x8516, 0x3572) },\n\t \n\t{ USB_DEVICE(0x1690, 0x0744) },\n\t{ USB_DEVICE(0x1690, 0x0761) },\n\t{ USB_DEVICE(0x1690, 0x0764) },\n\t \n\t{ USB_DEVICE(0x0b05, 0x179d) },\n\t \n\t{ USB_DEVICE(0x167b, 0x4001) },\n\t \n\t{ USB_DEVICE(0x1740, 0x9801) },\n\t \n\t{ USB_DEVICE(0x04bb, 0x0944) },\n\t \n\t{ USB_DEVICE(0x13b1, 0x002f) },\n\t{ USB_DEVICE(0x1737, 0x0079) },\n\t \n\t{ USB_DEVICE(0x0789, 0x0170) },\n\t \n\t{ USB_DEVICE(0x148f, 0x3572) },\n\t \n\t{ USB_DEVICE(0x0df6, 0x0041) },\n\t{ USB_DEVICE(0x0df6, 0x0062) },\n\t{ USB_DEVICE(0x0df6, 0x0065) },\n\t{ USB_DEVICE(0x0df6, 0x0066) },\n\t{ USB_DEVICE(0x0df6, 0x0068) },\n\t \n\t{ USB_DEVICE(0x0930, 0x0a07) },\n\t \n\t{ USB_DEVICE(0x5a57, 0x0284) },\n#endif\n#ifdef CONFIG_RT2800USB_RT3573\n\t \n\t{ USB_DEVICE(0x1b75, 0x7733) },\n\t \n\t{ USB_DEVICE(0x0b05, 0x17bc) },\n\t{ USB_DEVICE(0x0b05, 0x17ad) },\n\t \n\t{ USB_DEVICE(0x050d, 0x1103) },\n\t \n\t{ USB_DEVICE(0x148f, 0xf301) },\n\t \n\t{ USB_DEVICE(0x2001, 0x3c1f) },\n\t \n\t{ USB_DEVICE(0x7392, 0x7733) },\n\t \n\t{ USB_DEVICE(0x0e66, 0x0020) },\n\t{ USB_DEVICE(0x0e66, 0x0021) },\n\t \n\t{ USB_DEVICE(0x04bb, 0x094e) },\n\t \n\t{ USB_DEVICE(0x13b1, 0x003b) },\n\t \n\t{ USB_DEVICE(0x0789, 0x016b) },\n\t \n\t{ USB_DEVICE(0x0846, 0x9012) },\n\t{ USB_DEVICE(0x0846, 0x9013) },\n\t{ USB_DEVICE(0x0846, 0x9019) },\n\t \n\t{ USB_DEVICE(0x2019, 0xed14) },\n\t{ USB_DEVICE(0x2019, 0xed19) },\n\t \n\t{ USB_DEVICE(0x148f, 0x3573) },\n\t \n\t{ USB_DEVICE(0x0df6, 0x0067) },\n\t{ USB_DEVICE(0x0df6, 0x006a) },\n\t{ USB_DEVICE(0x0df6, 0x006e) },\n\t \n\t{ USB_DEVICE(0x0586, 0x3421) },\n#endif\n#ifdef CONFIG_RT2800USB_RT53XX\n\t \n\t{ USB_DEVICE(0x043e, 0x7a12) },\n\t \n\t{ USB_DEVICE(0x0b05, 0x17e8) },\n\t \n\t{ USB_DEVICE(0x13d3, 0x3329) },\n\t{ USB_DEVICE(0x13d3, 0x3365) },\n\t \n\t{ USB_DEVICE(0x2001, 0x3c15) },\n\t{ USB_DEVICE(0x2001, 0x3c19) },\n\t{ USB_DEVICE(0x2001, 0x3c1c) },\n\t{ USB_DEVICE(0x2001, 0x3c1d) },\n\t{ USB_DEVICE(0x2001, 0x3c1e) },\n\t{ USB_DEVICE(0x2001, 0x3c20) },\n\t{ USB_DEVICE(0x2001, 0x3c22) },\n\t{ USB_DEVICE(0x2001, 0x3c23) },\n\t \n\t{ USB_DEVICE(0x043e, 0x7a22) },\n\t{ USB_DEVICE(0x043e, 0x7a42) },\n\t \n\t{ USB_DEVICE(0x04da, 0x1801) },\n\t{ USB_DEVICE(0x04da, 0x1800) },\n\t{ USB_DEVICE(0x04da, 0x23f6) },\n\t \n\t{ USB_DEVICE(0x0471, 0x2104) },\n\t{ USB_DEVICE(0x0471, 0x2126) },\n\t{ USB_DEVICE(0x0471, 0x2180) },\n\t{ USB_DEVICE(0x0471, 0x2181) },\n\t{ USB_DEVICE(0x0471, 0x2182) },\n\t \n\t{ USB_DEVICE(0x148f, 0x5370) },\n\t{ USB_DEVICE(0x148f, 0x5372) },\n#endif\n#ifdef CONFIG_RT2800USB_RT55XX\n\t \n\t{ USB_DEVICE(0x043e, 0x7a32) },\n\t \n\t{ USB_DEVICE(0x057c, 0x8501) },\n\t \n\t{ USB_DEVICE(0x0411, 0x0241) },\n\t{ USB_DEVICE(0x0411, 0x0253) },\n\t \n\t{ USB_DEVICE(0x2001, 0x3c1a) },\n\t{ USB_DEVICE(0x2001, 0x3c21) },\n\t \n\t{ USB_DEVICE(0x043e, 0x7a13) },\n\t \n\t{ USB_DEVICE(0x148f, 0x5572) },\n\t \n\t{ USB_DEVICE(0x20f4, 0x724a) },\n#endif\n#ifdef CONFIG_RT2800USB_UNKNOWN\n\t \n\t \n\t{ USB_DEVICE(0x07b8, 0x3073) },\n\t{ USB_DEVICE(0x07b8, 0x3074) },\n\t \n\t{ USB_DEVICE(0x14b2, 0x3c08) },\n\t{ USB_DEVICE(0x14b2, 0x3c11) },\n\t \n\t{ USB_DEVICE(0x0e0b, 0x9031) },\n\t{ USB_DEVICE(0x0e0b, 0x9041) },\n\t \n\t{ USB_DEVICE(0x0b05, 0x166a) },\n\t{ USB_DEVICE(0x0b05, 0x1760) },\n\t{ USB_DEVICE(0x0b05, 0x1761) },\n\t{ USB_DEVICE(0x0b05, 0x1790) },\n\t{ USB_DEVICE(0x0b05, 0x17a7) },\n\t \n\t{ USB_DEVICE(0x13d3, 0x3262) },\n\t{ USB_DEVICE(0x13d3, 0x3284) },\n\t{ USB_DEVICE(0x13d3, 0x3322) },\n\t{ USB_DEVICE(0x13d3, 0x3340) },\n\t{ USB_DEVICE(0x13d3, 0x3399) },\n\t{ USB_DEVICE(0x13d3, 0x3400) },\n\t{ USB_DEVICE(0x13d3, 0x3401) },\n\t \n\t{ USB_DEVICE(0x050d, 0x1003) },\n\t \n\t{ USB_DEVICE(0x0411, 0x012e) },\n\t{ USB_DEVICE(0x0411, 0x0148) },\n\t{ USB_DEVICE(0x0411, 0x0150) },\n\t \n\t{ USB_DEVICE(0x07aa, 0x0041) },\n\t{ USB_DEVICE(0x07aa, 0x0042) },\n\t{ USB_DEVICE(0x18c5, 0x0008) },\n\t \n\t{ USB_DEVICE(0x07d1, 0x3c0b) },\n\t \n\t{ USB_DEVICE(0x203d, 0x14a1) },\n\t \n\t{ USB_DEVICE(0x1740, 0x0600) },\n\t{ USB_DEVICE(0x1740, 0x0602) },\n\t \n\t{ USB_DEVICE(0x15a9, 0x0010) },\n\t \n\t{ USB_DEVICE(0x1044, 0x800c) },\n\t \n\t{ USB_DEVICE(0x06f8, 0xe036) },\n\t \n\t{ USB_DEVICE(0x148f, 0xf101) },\n\t \n\t{ USB_DEVICE(0x04bb, 0x094b) },\n\t \n\t{ USB_DEVICE(0x1740, 0x0605) },\n\t{ USB_DEVICE(0x1740, 0x0615) },\n\t \n\t{ USB_DEVICE(0x0789, 0x0168) },\n\t{ USB_DEVICE(0x0789, 0x0169) },\n\t \n\t{ USB_DEVICE(0x100d, 0x9032) },\n\t \n\t{ USB_DEVICE(0x05a6, 0x0101) },\n\t{ USB_DEVICE(0x1d4d, 0x0010) },\n\t \n\t{ USB_DEVICE(0x2019, 0xab24) },\n\t{ USB_DEVICE(0x2019, 0xab29) },\n\t \n\t{ USB_DEVICE(0x18e8, 0x6259) },\n\t \n\t{ USB_DEVICE(0x08b9, 0x1197) },\n\t \n\t{ USB_DEVICE(0x0df6, 0x003c) },\n\t{ USB_DEVICE(0x0df6, 0x004a) },\n\t{ USB_DEVICE(0x0df6, 0x004d) },\n\t{ USB_DEVICE(0x0df6, 0x0053) },\n\t{ USB_DEVICE(0x0df6, 0x0069) },\n\t{ USB_DEVICE(0x0df6, 0x006f) },\n\t{ USB_DEVICE(0x0df6, 0x0078) },\n\t \n\t{ USB_DEVICE(0x083a, 0xa512) },\n\t{ USB_DEVICE(0x083a, 0xc522) },\n\t{ USB_DEVICE(0x083a, 0xd522) },\n\t{ USB_DEVICE(0x083a, 0xf511) },\n\t \n\t{ USB_DEVICE(0x177f, 0x0254) },\n\t \n\t{ USB_DEVICE(0xf201, 0x5370) },\n#endif\n\t{ 0, }\n};\n\nMODULE_AUTHOR(DRV_PROJECT);\nMODULE_VERSION(DRV_VERSION);\nMODULE_DESCRIPTION(\"Ralink RT2800 USB Wireless LAN driver.\");\nMODULE_DEVICE_TABLE(usb, rt2800usb_device_table);\nMODULE_FIRMWARE(FIRMWARE_RT2870);\nMODULE_LICENSE(\"GPL\");\n\nstatic int rt2800usb_probe(struct usb_interface *usb_intf,\n\t\t\t   const struct usb_device_id *id)\n{\n\treturn rt2x00usb_probe(usb_intf, &rt2800usb_ops);\n}\n\nstatic struct usb_driver rt2800usb_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= rt2800usb_device_table,\n\t.probe\t\t= rt2800usb_probe,\n\t.disconnect\t= rt2x00usb_disconnect,\n\t.suspend\t= rt2x00usb_suspend,\n\t.resume\t\t= rt2x00usb_resume,\n\t.reset_resume\t= rt2x00usb_resume,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(rt2800usb_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}