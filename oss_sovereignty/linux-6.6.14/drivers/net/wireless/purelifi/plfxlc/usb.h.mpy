{
  "module_name": "usb.h",
  "hash_id": "364587a73c0794302da0b17df2b3878643dffcdc0b742594ae7de085939ef1a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/purelifi/plfxlc/usb.h",
  "human_readable_source": " \n \n\n#ifndef PLFXLC_USB_H\n#define PLFXLC_USB_H\n\n#include <linux/completion.h>\n#include <linux/netdevice.h>\n#include <linux/spinlock.h>\n#include <linux/skbuff.h>\n#include <linux/usb.h>\n\n#include \"intf.h\"\n\n#define USB_BULK_MSG_TIMEOUT_MS 2000\n\n#define PURELIFI_X_VENDOR_ID_0   0x16C1\n#define PURELIFI_X_PRODUCT_ID_0  0x1CDE\n#define PURELIFI_XC_VENDOR_ID_0  0x2EF5\n#define PURELIFI_XC_PRODUCT_ID_0 0x0008\n#define PURELIFI_XL_VENDOR_ID_0  0x2EF5\n#define PURELIFI_XL_PRODUCT_ID_0 0x000A  \n\n#define PLF_FPGA_STATUS_LEN 2\n#define PLF_FPGA_STATE_LEN 9\n#define PLF_BULK_TLEN 16384\n#define PLF_FPGA_MG 6  \n#define PLF_XL_BUF_LEN 64\n#define PLF_MSG_STATUS_OFFSET 7\n\n#define PLF_USB_TIMEOUT 1000\n#define PLF_MSLEEP_TIME 200\n\n#define PURELIFI_URB_RETRY_MAX 5\n\n#define plfxlc_usb_dev(usb) (&(usb)->intf->dev)\n\n \n#define TX_RETRY_BACKOFF_MS 10\n#define STA_QUEUE_CLEANUP_MS 5000\n\n \n#define TX_RETRY_BACKOFF_JIFF ((TX_RETRY_BACKOFF_MS * HZ) / 1000)\n#define STA_QUEUE_CLEANUP_JIFF ((STA_QUEUE_CLEANUP_MS * HZ) / 1000)\n\n \n#define MAX_TRANSFER_SIZE (USB_MAX_TRANSFER_SIZE & ~1)\n#define plfxlc_urb_dev(urb) (&(urb)->dev->dev)\n\n#define STATION_FIFO_ALMOST_FULL_MESSAGE     0\n#define STATION_FIFO_ALMOST_FULL_NOT_MESSAGE 1\n#define STATION_CONNECT_MESSAGE              2\n#define STATION_DISCONNECT_MESSAGE           3\n\nint plfxlc_usb_wreq(struct usb_interface *ez_usb, void *buffer, int buffer_len,\n\t\t    enum plf_usb_req_enum usb_req_id);\nvoid plfxlc_tx_urb_complete(struct urb *urb);\n\nenum {\n\tUSB_MAX_RX_SIZE       = 4800,\n\tUSB_MAX_EP_INT_BUFFER = 64,\n};\n\nstruct plfxlc_usb_interrupt {\n\tspinlock_t lock;  \n\tstruct urb *urb;\n\tvoid *buffer;\n\tint interval;\n};\n\n#define RX_URBS_COUNT 5\n\nstruct plfxlc_usb_rx {\n\tspinlock_t lock;  \n\tstruct mutex setup_mutex;  \n\tu8 fragment[2 * USB_MAX_RX_SIZE];\n\tunsigned int fragment_length;\n\tunsigned int usb_packet_size;\n\tstruct urb **urbs;\n\tint urbs_count;\n};\n\nstruct plf_station {\n    \n\tunsigned char flag;\n\tunsigned char mac[ETH_ALEN];\n\tstruct sk_buff_head data_list;\n};\n\nstruct plfxlc_firmware_file {\n\tu32 total_files;\n\tu32 total_size;\n\tu32 size;\n\tu32 start_addr;\n\tu32 control_packets;\n} __packed;\n\n#define STATION_CONNECTED_FLAG 0x1\n#define STATION_FIFO_FULL_FLAG 0x2\n#define STATION_HEARTBEAT_FLAG 0x4\n#define STATION_ACTIVE_FLAG    0xFD\n\n#define PURELIFI_SERIAL_LEN 256\n#define STA_BROADCAST_INDEX (AP_USER_LIMIT)\n#define MAX_STA_NUM         (AP_USER_LIMIT + 1)\n\nstruct plfxlc_usb_tx {\n\tunsigned long enabled;\n\tspinlock_t lock;  \n\tu8 mac_fifo_full;\n\tstruct sk_buff_head submitted_skbs;\n\tstruct usb_anchor submitted;\n\tint submitted_urbs;\n\tbool stopped;\n\tstruct timer_list tx_retry_timer;\n\tstruct plf_station station[MAX_STA_NUM];\n};\n\n \nstruct plfxlc_usb {\n\tstruct timer_list sta_queue_cleanup;\n\tstruct plfxlc_usb_rx rx;\n\tstruct plfxlc_usb_tx tx;\n\tstruct usb_interface *intf;\n\tstruct usb_interface *ez_usb;\n\tu8 req_buf[64];  \n\tu8 sidx;  \n\tbool rx_usb_enabled;\n\tbool initialized;\n\tbool was_running;\n\tbool link_up;\n};\n\nenum endpoints {\n\tEP_DATA_IN  = 2,\n\tEP_DATA_OUT = 8,\n};\n\nenum devicetype {\n\tDEVICE_LIFI_X  = 0,\n\tDEVICE_LIFI_XC  = 1,\n\tDEVICE_LIFI_XL  = 1,\n};\n\nenum {\n\tPLF_BIT_ENABLED = 1,\n\tPLF_BIT_MAX = 2,\n};\n\nint plfxlc_usb_wreq_async(struct plfxlc_usb *usb, const u8 *buffer,\n\t\t\t  int buffer_len, enum plf_usb_req_enum usb_req_id,\n\t\t\t  usb_complete_t complete_fn, void *context);\n\nstatic inline struct usb_device *\nplfxlc_usb_to_usbdev(struct plfxlc_usb *usb)\n{\n\treturn interface_to_usbdev(usb->intf);\n}\n\nstatic inline struct ieee80211_hw *\nplfxlc_intf_to_hw(struct usb_interface *intf)\n{\n\treturn usb_get_intfdata(intf);\n}\n\nstatic inline struct ieee80211_hw *\nplfxlc_usb_to_hw(struct plfxlc_usb *usb)\n{\n\treturn plfxlc_intf_to_hw(usb->intf);\n}\n\nvoid plfxlc_usb_init(struct plfxlc_usb *usb, struct ieee80211_hw *hw,\n\t\t     struct usb_interface *intf);\nvoid plfxlc_send_packet_from_data_queue(struct plfxlc_usb *usb);\nvoid plfxlc_usb_release(struct plfxlc_usb *usb);\nvoid plfxlc_usb_disable_rx(struct plfxlc_usb *usb);\nvoid plfxlc_usb_enable_tx(struct plfxlc_usb *usb);\nvoid plfxlc_usb_disable_tx(struct plfxlc_usb *usb);\nint plfxlc_usb_tx(struct plfxlc_usb *usb, struct sk_buff *skb);\nint plfxlc_usb_enable_rx(struct plfxlc_usb *usb);\nint plfxlc_usb_init_hw(struct plfxlc_usb *usb);\nconst char *plfxlc_speed(enum usb_device_speed speed);\n\n \nint plfxlc_download_xl_firmware(struct usb_interface *intf);\nint plfxlc_download_fpga(struct usb_interface *intf);\n\nint plfxlc_upload_mac_and_serial(struct usb_interface *intf,\n\t\t\t\t unsigned char *hw_address,\n\t\t\t\t unsigned char *serial_number);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}