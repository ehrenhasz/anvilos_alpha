{
  "module_name": "mac.c",
  "hash_id": "292135ad054bdb1e5d8a37a4aad95e586f2355d51bdd10fa5b7f519610e16dda",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/purelifi/plfxlc/mac.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/gpio.h>\n#include <linux/jiffies.h>\n#include <net/ieee80211_radiotap.h>\n\n#include \"chip.h\"\n#include \"mac.h\"\n#include \"usb.h\"\n\nstatic const struct ieee80211_rate plfxlc_rates[] = {\n\t{ .bitrate = 10,\n\t\t.hw_value = PURELIFI_CCK_RATE_1M,\n\t\t.flags = 0 },\n\t{ .bitrate = 20,\n\t\t.hw_value = PURELIFI_CCK_RATE_2M,\n\t\t.hw_value_short = PURELIFI_CCK_RATE_2M\n\t\t\t| PURELIFI_CCK_PREA_SHORT,\n\t\t.flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 55,\n\t\t.hw_value = PURELIFI_CCK_RATE_5_5M,\n\t\t.hw_value_short = PURELIFI_CCK_RATE_5_5M\n\t\t\t| PURELIFI_CCK_PREA_SHORT,\n\t\t.flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 110,\n\t\t.hw_value = PURELIFI_CCK_RATE_11M,\n\t\t.hw_value_short = PURELIFI_CCK_RATE_11M\n\t\t\t| PURELIFI_CCK_PREA_SHORT,\n\t\t.flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 60,\n\t\t.hw_value = PURELIFI_OFDM_RATE_6M,\n\t\t.flags = 0 },\n\t{ .bitrate = 90,\n\t\t.hw_value = PURELIFI_OFDM_RATE_9M,\n\t\t.flags = 0 },\n\t{ .bitrate = 120,\n\t\t.hw_value = PURELIFI_OFDM_RATE_12M,\n\t\t.flags = 0 },\n\t{ .bitrate = 180,\n\t\t.hw_value = PURELIFI_OFDM_RATE_18M,\n\t\t.flags = 0 },\n\t{ .bitrate = 240,\n\t\t.hw_value = PURELIFI_OFDM_RATE_24M,\n\t\t.flags = 0 },\n\t{ .bitrate = 360,\n\t\t.hw_value = PURELIFI_OFDM_RATE_36M,\n\t\t.flags = 0 },\n\t{ .bitrate = 480,\n\t\t.hw_value = PURELIFI_OFDM_RATE_48M,\n\t\t.flags = 0 },\n\t{ .bitrate = 540,\n\t\t.hw_value = PURELIFI_OFDM_RATE_54M,\n\t\t.flags = 0 }\n};\n\nstatic const struct ieee80211_channel plfxlc_channels[] = {\n\t{ .center_freq = 2412, .hw_value = 1 },\n\t{ .center_freq = 2417, .hw_value = 2 },\n\t{ .center_freq = 2422, .hw_value = 3 },\n\t{ .center_freq = 2427, .hw_value = 4 },\n\t{ .center_freq = 2432, .hw_value = 5 },\n\t{ .center_freq = 2437, .hw_value = 6 },\n\t{ .center_freq = 2442, .hw_value = 7 },\n\t{ .center_freq = 2447, .hw_value = 8 },\n\t{ .center_freq = 2452, .hw_value = 9 },\n\t{ .center_freq = 2457, .hw_value = 10 },\n\t{ .center_freq = 2462, .hw_value = 11 },\n\t{ .center_freq = 2467, .hw_value = 12 },\n\t{ .center_freq = 2472, .hw_value = 13 },\n\t{ .center_freq = 2484, .hw_value = 14 },\n};\n\nint plfxlc_mac_preinit_hw(struct ieee80211_hw *hw, const u8 *hw_address)\n{\n\tSET_IEEE80211_PERM_ADDR(hw, hw_address);\n\treturn 0;\n}\n\nint plfxlc_mac_init_hw(struct ieee80211_hw *hw)\n{\n\tstruct plfxlc_mac *mac = plfxlc_hw_mac(hw);\n\tstruct plfxlc_chip *chip = &mac->chip;\n\tint r;\n\n\tr = plfxlc_chip_init_hw(chip);\n\tif (r) {\n\t\tdev_warn(plfxlc_mac_dev(mac), \"init hw failed (%d)\\n\", r);\n\t\treturn r;\n\t}\n\n\tdev_dbg(plfxlc_mac_dev(mac), \"irq_disabled (%d)\\n\", irqs_disabled());\n\tregulatory_hint(hw->wiphy, \"00\");\n\treturn r;\n}\n\nvoid plfxlc_mac_release(struct plfxlc_mac *mac)\n{\n\tplfxlc_chip_release(&mac->chip);\n\tlockdep_assert_held(&mac->lock);\n}\n\nint plfxlc_op_start(struct ieee80211_hw *hw)\n{\n\tplfxlc_hw_mac(hw)->chip.usb.initialized = 1;\n\treturn 0;\n}\n\nvoid plfxlc_op_stop(struct ieee80211_hw *hw)\n{\n\tstruct plfxlc_mac *mac = plfxlc_hw_mac(hw);\n\n\tclear_bit(PURELIFI_DEVICE_RUNNING, &mac->flags);\n}\n\nint plfxlc_restore_settings(struct plfxlc_mac *mac)\n{\n\tint beacon_interval, beacon_period;\n\tstruct sk_buff *beacon;\n\n\tspin_lock_irq(&mac->lock);\n\tbeacon_interval = mac->beacon.interval;\n\tbeacon_period = mac->beacon.period;\n\tspin_unlock_irq(&mac->lock);\n\n\tif (mac->type != NL80211_IFTYPE_ADHOC)\n\t\treturn 0;\n\n\tif (mac->vif) {\n\t\tbeacon = ieee80211_beacon_get(mac->hw, mac->vif, 0);\n\t\tif (beacon) {\n\t\t\t \n\t\t\tkfree_skb(beacon);\n\t\t\t \n\t\t}\n\t}\n\n\tplfxlc_set_beacon_interval(&mac->chip, beacon_interval,\n\t\t\t\t   beacon_period, mac->type);\n\n\tspin_lock_irq(&mac->lock);\n\tmac->beacon.last_update = jiffies;\n\tspin_unlock_irq(&mac->lock);\n\n\treturn 0;\n}\n\nstatic void plfxlc_mac_tx_status(struct ieee80211_hw *hw,\n\t\t\t\t struct sk_buff *skb,\n\t\t\t\t int ackssi,\n\t\t\t\t struct tx_status *tx_status)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tint success = 1;\n\n\tieee80211_tx_info_clear_status(info);\n\tif (tx_status)\n\t\tsuccess = !tx_status->failure;\n\n\tif (success)\n\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\telse\n\t\tinfo->flags &= ~IEEE80211_TX_STAT_ACK;\n\n\tinfo->status.ack_signal = 50;\n\tieee80211_tx_status_irqsafe(hw, skb);\n}\n\nvoid plfxlc_mac_tx_to_dev(struct sk_buff *skb, int error)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hw *hw = info->rate_driver_data[0];\n\tstruct plfxlc_mac *mac = plfxlc_hw_mac(hw);\n\tstruct sk_buff_head *q = NULL;\n\n\tieee80211_tx_info_clear_status(info);\n\tskb_pull(skb, sizeof(struct plfxlc_ctrlset));\n\n\tif (unlikely(error ||\n\t\t     (info->flags & IEEE80211_TX_CTL_NO_ACK))) {\n\t\tieee80211_tx_status_irqsafe(hw, skb);\n\t\treturn;\n\t}\n\n\tq = &mac->ack_wait_queue;\n\n\tskb_queue_tail(q, skb);\n\twhile (skb_queue_len(q) ) {\n\t\tplfxlc_mac_tx_status(hw, skb_dequeue(q),\n\t\t\t\t     mac->ack_pending ?\n\t\t\t\t     mac->ack_signal : 0,\n\t\t\t\t     NULL);\n\t\tmac->ack_pending = 0;\n\t}\n}\n\nstatic int plfxlc_fill_ctrlset(struct plfxlc_mac *mac, struct sk_buff *skb)\n{\n\tunsigned int frag_len = skb->len;\n\tstruct plfxlc_ctrlset *cs;\n\tu32 temp_payload_len = 0;\n\tunsigned int tmp;\n\tu32 temp_len = 0;\n\n\tif (skb_headroom(skb) < sizeof(struct plfxlc_ctrlset)) {\n\t\tdev_dbg(plfxlc_mac_dev(mac), \"Not enough hroom(1)\\n\");\n\t\treturn 1;\n\t}\n\n\tcs = (void *)skb_push(skb, sizeof(struct plfxlc_ctrlset));\n\ttemp_payload_len = frag_len;\n\ttemp_len = temp_payload_len +\n\t\t  sizeof(struct plfxlc_ctrlset) -\n\t\t  sizeof(cs->id) - sizeof(cs->len);\n\n\t \n\t \n\ttmp = skb->len & 3;\n\tif (tmp) {\n\t\tif (skb_tailroom(skb) < (3 - tmp)) {\n\t\t\tif (skb_headroom(skb) >= 4 - tmp) {\n\t\t\t\tu8 len;\n\t\t\t\tu8 *src_pt;\n\t\t\t\tu8 *dest_pt;\n\n\t\t\t\tlen = skb->len;\n\t\t\t\tsrc_pt = skb->data;\n\t\t\t\tdest_pt = skb_push(skb, 4 - tmp);\n\t\t\t\tmemmove(dest_pt, src_pt, len);\n\t\t\t} else {\n\t\t\t\treturn -ENOBUFS;\n\t\t\t}\n\t\t} else {\n\t\t\tskb_put(skb, 4 - tmp);\n\t\t}\n\t\ttemp_len += 4 - tmp;\n\t}\n\n\t \n\ttmp = skb->len & 0x1ff;\n\tif (!tmp) {\n\t\tif (skb_tailroom(skb) < 4) {\n\t\t\tif (skb_headroom(skb) >= 4) {\n\t\t\t\tu8 len = skb->len;\n\t\t\t\tu8 *src_pt = skb->data;\n\t\t\t\tu8 *dest_pt = skb_push(skb, 4);\n\n\t\t\t\tmemmove(dest_pt, src_pt, len);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\treturn -ENOBUFS;\n\t\t\t}\n\t\t} else {\n\t\t\tskb_put(skb, 4);\n\t\t}\n\t\ttemp_len += 4;\n\t}\n\n\tcs->id = cpu_to_be32(USB_REQ_DATA_TX);\n\tcs->len = cpu_to_be32(temp_len);\n\tcs->payload_len_nw = cpu_to_be32(temp_payload_len);\n\n\treturn 0;\n}\n\nstatic void plfxlc_op_tx(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_tx_control *control,\n\t\t\t struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct plfxlc_header *plhdr = (void *)skb->data;\n\tstruct plfxlc_mac *mac = plfxlc_hw_mac(hw);\n\tstruct plfxlc_usb *usb = &mac->chip.usb;\n\tunsigned long flags;\n\tint r;\n\n\tr = plfxlc_fill_ctrlset(mac, skb);\n\tif (r)\n\t\tgoto fail;\n\n\tinfo->rate_driver_data[0] = hw;\n\n\tif (plhdr->frametype  == IEEE80211_FTYPE_DATA) {\n\t\tu8 *dst_mac = plhdr->dmac;\n\t\tu8 sidx;\n\t\tbool found = false;\n\t\tstruct plfxlc_usb_tx *tx = &usb->tx;\n\n\t\tfor (sidx = 0; sidx < MAX_STA_NUM; sidx++) {\n\t\t\tif (!(tx->station[sidx].flag & STATION_CONNECTED_FLAG))\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(tx->station[sidx].mac, dst_mac, ETH_ALEN))\n\t\t\t\tcontinue;\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!found)\n\t\t\tsidx = STA_BROADCAST_INDEX;\n\n\t\t \n\t\tif (skb_queue_len(&tx->station[sidx].data_list) > 60)\n\t\t\tieee80211_stop_queues(plfxlc_usb_to_hw(usb));\n\n\t\t \n\t\tif (skb_queue_len(&tx->station[sidx].data_list) > 256)\n\t\t\tgoto fail;\n\t\tskb_queue_tail(&tx->station[sidx].data_list, skb);\n\t\tplfxlc_send_packet_from_data_queue(usb);\n\n\t} else {\n\t\tspin_lock_irqsave(&usb->tx.lock, flags);\n\t\tr = plfxlc_usb_wreq_async(&mac->chip.usb, skb->data, skb->len,\n\t\t\t\t\t  USB_REQ_DATA_TX, plfxlc_tx_urb_complete, skb);\n\t\tspin_unlock_irqrestore(&usb->tx.lock, flags);\n\t\tif (r)\n\t\t\tgoto fail;\n\t}\n\treturn;\n\nfail:\n\tdev_kfree_skb(skb);\n}\n\nstatic int plfxlc_filter_ack(struct ieee80211_hw *hw, struct ieee80211_hdr *rx_hdr,\n\t\t\t     struct ieee80211_rx_status *stats)\n{\n\tstruct plfxlc_mac *mac = plfxlc_hw_mac(hw);\n\tstruct sk_buff_head *q;\n\tint i, position = 0;\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\tbool found = false;\n\n\tif (!ieee80211_is_ack(rx_hdr->frame_control))\n\t\treturn 0;\n\n\tdev_dbg(plfxlc_mac_dev(mac), \"ACK Received\\n\");\n\n\t \n\tq = &mac->ack_wait_queue;\n\tspin_lock_irqsave(&q->lock, flags);\n\n\tskb_queue_walk(q, skb) {\n\t\tstruct ieee80211_hdr *tx_hdr;\n\n\t\tposition++;\n\n\t\tif (mac->ack_pending && skb_queue_is_first(q, skb))\n\t\t\tcontinue;\n\t\tif (mac->ack_pending == 0)\n\t\t\tbreak;\n\n\t\ttx_hdr = (struct ieee80211_hdr *)skb->data;\n\t\tif (likely(ether_addr_equal(tx_hdr->addr2, rx_hdr->addr1))) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tfor (i = 1; i < position; i++)\n\t\t\tskb = __skb_dequeue(q);\n\t\tif (i == position) {\n\t\t\tplfxlc_mac_tx_status(hw, skb,\n\t\t\t\t\t     mac->ack_pending ?\n\t\t\t\t\t     mac->ack_signal : 0,\n\t\t\t\t\t     NULL);\n\t\t\tmac->ack_pending = 0;\n\t\t}\n\n\t\tmac->ack_pending = skb_queue_len(q) ? 1 : 0;\n\t\tmac->ack_signal = stats->signal;\n\t}\n\n\tspin_unlock_irqrestore(&q->lock, flags);\n\treturn 1;\n}\n\nint plfxlc_mac_rx(struct ieee80211_hw *hw, const u8 *buffer,\n\t\t  unsigned int length)\n{\n\tstruct plfxlc_mac *mac = plfxlc_hw_mac(hw);\n\tstruct ieee80211_rx_status stats;\n\tconst struct rx_status *status;\n\tunsigned int payload_length;\n\tstruct plfxlc_usb_tx *tx;\n\tstruct sk_buff *skb;\n\tint need_padding;\n\t__le16 fc;\n\tint sidx;\n\n\t \n\tif (!mac->vif)\n\t\treturn 0;\n\n\tstatus = (struct rx_status *)buffer;\n\n\tmemset(&stats, 0, sizeof(stats));\n\n\tstats.flag     = 0;\n\tstats.freq     = 2412;\n\tstats.band     = NL80211_BAND_LC;\n\tmac->rssi      = -15 * be16_to_cpu(status->rssi) / 10;\n\n\tstats.signal   = mac->rssi;\n\n\tif (status->rate_idx > 7)\n\t\tstats.rate_idx = 0;\n\telse\n\t\tstats.rate_idx = status->rate_idx;\n\n\tmac->crc_errors = be64_to_cpu(status->crc_error_count);\n\n\t \n\tif (plfxlc_filter_ack(hw, (struct ieee80211_hdr *)buffer, &stats) &&\n\t    !mac->pass_ctrl)\n\t\treturn 0;\n\n\tbuffer += sizeof(struct rx_status);\n\tpayload_length = get_unaligned_be32(buffer);\n\n\tif (payload_length > 1560) {\n\t\tdev_err(plfxlc_mac_dev(mac), \" > MTU %u\\n\", payload_length);\n\t\treturn 0;\n\t}\n\tbuffer += sizeof(u32);\n\n\tfc = get_unaligned((__le16 *)buffer);\n\tneed_padding = ieee80211_is_data_qos(fc) ^ ieee80211_has_a4(fc);\n\n\ttx = &mac->chip.usb.tx;\n\n\tfor (sidx = 0; sidx < MAX_STA_NUM - 1; sidx++) {\n\t\tif (memcmp(&buffer[10], tx->station[sidx].mac, ETH_ALEN))\n\t\t\tcontinue;\n\t\tif (tx->station[sidx].flag & STATION_CONNECTED_FLAG) {\n\t\t\ttx->station[sidx].flag |= STATION_HEARTBEAT_FLAG;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (sidx == MAX_STA_NUM - 1) {\n\t\tfor (sidx = 0; sidx < MAX_STA_NUM - 1; sidx++) {\n\t\t\tif (tx->station[sidx].flag & STATION_CONNECTED_FLAG)\n\t\t\t\tcontinue;\n\t\t\tmemcpy(tx->station[sidx].mac, &buffer[10], ETH_ALEN);\n\t\t\ttx->station[sidx].flag |= STATION_CONNECTED_FLAG;\n\t\t\ttx->station[sidx].flag |= STATION_HEARTBEAT_FLAG;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (buffer[0]) {\n\tcase IEEE80211_STYPE_PROBE_REQ:\n\t\tdev_dbg(plfxlc_mac_dev(mac), \"Probe request\\n\");\n\t\tbreak;\n\tcase IEEE80211_STYPE_ASSOC_REQ:\n\t\tdev_dbg(plfxlc_mac_dev(mac), \"Association request\\n\");\n\t\tbreak;\n\tcase IEEE80211_STYPE_AUTH:\n\t\tdev_dbg(plfxlc_mac_dev(mac), \"Authentication req\\n\");\n\t\tbreak;\n\tcase IEEE80211_FTYPE_DATA:\n\t\tdev_dbg(plfxlc_mac_dev(mac), \"802.11 data frame\\n\");\n\t\tbreak;\n\t}\n\n\tskb = dev_alloc_skb(payload_length + (need_padding ? 2 : 0));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tif (need_padding)\n\t\t \n\t\tskb_reserve(skb, 2);\n\n\tskb_put_data(skb, buffer, payload_length);\n\tmemcpy(IEEE80211_SKB_RXCB(skb), &stats, sizeof(stats));\n\tieee80211_rx_irqsafe(hw, skb);\n\treturn 0;\n}\n\nstatic int plfxlc_op_add_interface(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct plfxlc_mac *mac = plfxlc_hw_mac(hw);\n\tstatic const char * const iftype80211[] = {\n\t\t[NL80211_IFTYPE_STATION]\t= \"Station\",\n\t\t[NL80211_IFTYPE_ADHOC]\t\t= \"Adhoc\"\n\t};\n\n\tif (mac->type != NL80211_IFTYPE_UNSPECIFIED)\n\t\treturn -EOPNOTSUPP;\n\n\tif (vif->type == NL80211_IFTYPE_ADHOC ||\n\t    vif->type == NL80211_IFTYPE_STATION) {\n\t\tdev_dbg(plfxlc_mac_dev(mac), \"%s %s\\n\", __func__,\n\t\t\tiftype80211[vif->type]);\n\t\tmac->type = vif->type;\n\t\tmac->vif = vif;\n\t\treturn 0;\n\t}\n\tdev_dbg(plfxlc_mac_dev(mac), \"unsupported iftype\\n\");\n\treturn -EOPNOTSUPP;\n}\n\nstatic void plfxlc_op_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tstruct plfxlc_mac *mac = plfxlc_hw_mac(hw);\n\n\tmac->type = NL80211_IFTYPE_UNSPECIFIED;\n\tmac->vif = NULL;\n}\n\nstatic int plfxlc_op_config(struct ieee80211_hw *hw, u32 changed)\n{\n\treturn 0;\n}\n\n#define SUPPORTED_FIF_FLAGS \\\n\t(FIF_ALLMULTI | FIF_FCSFAIL | FIF_CONTROL | \\\n\t FIF_OTHER_BSS | FIF_BCN_PRBRESP_PROMISC)\nstatic void plfxlc_op_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t       unsigned int changed_flags,\n\t\t\t\t       unsigned int *new_flags,\n\t\t\t\t       u64 multicast)\n{\n\tstruct plfxlc_mc_hash hash = {\n\t\t.low = multicast,\n\t\t.high = multicast >> 32,\n\t};\n\tstruct plfxlc_mac *mac = plfxlc_hw_mac(hw);\n\tunsigned long flags;\n\n\t \n\t*new_flags &= SUPPORTED_FIF_FLAGS;\n\n\t \n\tif (*new_flags & (FIF_ALLMULTI))\n\t\tplfxlc_mc_add_all(&hash);\n\n\tspin_lock_irqsave(&mac->lock, flags);\n\tmac->pass_failed_fcs = !!(*new_flags & FIF_FCSFAIL);\n\tmac->pass_ctrl = !!(*new_flags & FIF_CONTROL);\n\tmac->multicast_hash = hash;\n\tspin_unlock_irqrestore(&mac->lock, flags);\n\n\t \n\t \n}\n\nstatic void plfxlc_op_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_bss_conf *bss_conf,\n\t\t\t\t       u64 changes)\n{\n\tstruct plfxlc_mac *mac = plfxlc_hw_mac(hw);\n\tint associated;\n\n\tdev_dbg(plfxlc_mac_dev(mac), \"changes: %llx\\n\", changes);\n\n\tif (mac->type != NL80211_IFTYPE_ADHOC) {  \n\t\tassociated = is_valid_ether_addr(bss_conf->bssid);\n\t\tgoto exit_all;\n\t}\n\t \n\tassociated = true;\n\tif (changes & BSS_CHANGED_BEACON) {\n\t\tstruct sk_buff *beacon = ieee80211_beacon_get(hw, vif, 0);\n\n\t\tif (beacon) {\n\t\t\t \n\t\t\tkfree_skb(beacon);\n\t\t\t \n\t\t}\n\t}\n\n\tif (changes & BSS_CHANGED_BEACON_ENABLED) {\n\t\tu16 interval = 0;\n\t\tu8 period = 0;\n\n\t\tif (bss_conf->enable_beacon) {\n\t\t\tperiod = bss_conf->dtim_period;\n\t\t\tinterval = bss_conf->beacon_int;\n\t\t}\n\n\t\tspin_lock_irq(&mac->lock);\n\t\tmac->beacon.period = period;\n\t\tmac->beacon.interval = interval;\n\t\tmac->beacon.last_update = jiffies;\n\t\tspin_unlock_irq(&mac->lock);\n\n\t\tplfxlc_set_beacon_interval(&mac->chip, interval,\n\t\t\t\t\t   period, mac->type);\n\t}\nexit_all:\n\tspin_lock_irq(&mac->lock);\n\tmac->associated = associated;\n\tspin_unlock_irq(&mac->lock);\n}\n\nstatic int plfxlc_get_stats(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_low_level_stats *stats)\n{\n\tstats->dot11ACKFailureCount = 0;\n\tstats->dot11RTSFailureCount = 0;\n\tstats->dot11FCSErrorCount   = 0;\n\tstats->dot11RTSSuccessCount = 0;\n\treturn 0;\n}\n\nstatic const char et_strings[][ETH_GSTRING_LEN] = {\n\t\"phy_rssi\",\n\t\"phy_rx_crc_err\"\n};\n\nstatic int plfxlc_get_et_sset_count(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif, int sset)\n{\n\tif (sset == ETH_SS_STATS)\n\t\treturn ARRAY_SIZE(et_strings);\n\n\treturn 0;\n}\n\nstatic void plfxlc_get_et_strings(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  u32 sset, u8 *data)\n{\n\tif (sset == ETH_SS_STATS)\n\t\tmemcpy(data, et_strings, sizeof(et_strings));\n}\n\nstatic void plfxlc_get_et_stats(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ethtool_stats *stats, u64 *data)\n{\n\tstruct plfxlc_mac *mac = plfxlc_hw_mac(hw);\n\n\tdata[0] = mac->rssi;\n\tdata[1] = mac->crc_errors;\n}\n\nstatic int plfxlc_set_rts_threshold(struct ieee80211_hw *hw, u32 value)\n{\n\treturn 0;\n}\n\nstatic const struct ieee80211_ops plfxlc_ops = {\n\t.tx = plfxlc_op_tx,\n\t.wake_tx_queue = ieee80211_handle_wake_tx_queue,\n\t.start = plfxlc_op_start,\n\t.stop = plfxlc_op_stop,\n\t.add_interface = plfxlc_op_add_interface,\n\t.remove_interface = plfxlc_op_remove_interface,\n\t.set_rts_threshold = plfxlc_set_rts_threshold,\n\t.config = plfxlc_op_config,\n\t.configure_filter = plfxlc_op_configure_filter,\n\t.bss_info_changed = plfxlc_op_bss_info_changed,\n\t.get_stats = plfxlc_get_stats,\n\t.get_et_sset_count = plfxlc_get_et_sset_count,\n\t.get_et_stats = plfxlc_get_et_stats,\n\t.get_et_strings = plfxlc_get_et_strings,\n};\n\nstruct ieee80211_hw *plfxlc_mac_alloc_hw(struct usb_interface *intf)\n{\n\tstruct ieee80211_hw *hw;\n\tstruct plfxlc_mac *mac;\n\n\thw = ieee80211_alloc_hw(sizeof(struct plfxlc_mac), &plfxlc_ops);\n\tif (!hw) {\n\t\tdev_dbg(&intf->dev, \"out of memory\\n\");\n\t\treturn NULL;\n\t}\n\tset_wiphy_dev(hw->wiphy, &intf->dev);\n\n\tmac = plfxlc_hw_mac(hw);\n\tmemset(mac, 0, sizeof(*mac));\n\tspin_lock_init(&mac->lock);\n\tmac->hw = hw;\n\n\tmac->type = NL80211_IFTYPE_UNSPECIFIED;\n\n\tmemcpy(mac->channels, plfxlc_channels, sizeof(plfxlc_channels));\n\tmemcpy(mac->rates, plfxlc_rates, sizeof(plfxlc_rates));\n\tmac->band.n_bitrates = ARRAY_SIZE(plfxlc_rates);\n\tmac->band.bitrates = mac->rates;\n\tmac->band.n_channels = ARRAY_SIZE(plfxlc_channels);\n\tmac->band.channels = mac->channels;\n\thw->wiphy->bands[NL80211_BAND_LC] = &mac->band;\n\thw->conf.chandef.width = NL80211_CHAN_WIDTH_20;\n\n\tieee80211_hw_set(hw, RX_INCLUDES_FCS);\n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\tieee80211_hw_set(hw, HOST_BROADCAST_PS_BUFFERING);\n\tieee80211_hw_set(hw, MFP_CAPABLE);\n\n\thw->wiphy->interface_modes =\n\t\tBIT(NL80211_IFTYPE_STATION) |\n\t\tBIT(NL80211_IFTYPE_ADHOC);\n\thw->max_signal = 100;\n\thw->queues = 1;\n\t \n\thw->extra_tx_headroom = sizeof(struct plfxlc_ctrlset) + 4;\n\t \n\thw->max_rates = IEEE80211_TX_MAX_RATES;\n\thw->max_rate_tries = 18;    \n\n\tskb_queue_head_init(&mac->ack_wait_queue);\n\tmac->ack_pending = 0;\n\n\tplfxlc_chip_init(&mac->chip, hw, intf);\n\n\tSET_IEEE80211_DEV(hw, &intf->dev);\n\treturn hw;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}