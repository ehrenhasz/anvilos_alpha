{
  "module_name": "usb.c",
  "hash_id": "60e1fcda6045b80abd1eff25bac33faf55aa4f6c035392f6cce51c9721c3da25",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/purelifi/plfxlc/usb.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <linux/usb.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <net/mac80211.h>\n#include <asm/unaligned.h>\n#include <linux/sysfs.h>\n\n#include \"mac.h\"\n#include \"usb.h\"\n#include \"chip.h\"\n\nstatic const struct usb_device_id usb_ids[] = {\n\t{ USB_DEVICE(PURELIFI_X_VENDOR_ID_0, PURELIFI_X_PRODUCT_ID_0),\n\t  .driver_info = DEVICE_LIFI_X },\n\t{ USB_DEVICE(PURELIFI_XC_VENDOR_ID_0, PURELIFI_XC_PRODUCT_ID_0),\n\t  .driver_info = DEVICE_LIFI_XC },\n\t{ USB_DEVICE(PURELIFI_XL_VENDOR_ID_0, PURELIFI_XL_PRODUCT_ID_0),\n\t  .driver_info = DEVICE_LIFI_XL },\n\t{}\n};\n\nvoid plfxlc_send_packet_from_data_queue(struct plfxlc_usb *usb)\n{\n\tstruct plfxlc_usb_tx *tx = &usb->tx;\n\tstruct sk_buff *skb = NULL;\n\tunsigned long flags;\n\tu8 last_served_sidx;\n\n\tspin_lock_irqsave(&tx->lock, flags);\n\tlast_served_sidx = usb->sidx;\n\tdo {\n\t\tusb->sidx = (usb->sidx + 1) % MAX_STA_NUM;\n\t\tif (!(tx->station[usb->sidx].flag & STATION_CONNECTED_FLAG))\n\t\t\tcontinue;\n\t\tif (!(tx->station[usb->sidx].flag & STATION_FIFO_FULL_FLAG))\n\t\t\tskb = skb_peek(&tx->station[usb->sidx].data_list);\n\t} while ((usb->sidx != last_served_sidx) && (!skb));\n\n\tif (skb) {\n\t\tskb = skb_dequeue(&tx->station[usb->sidx].data_list);\n\t\tplfxlc_usb_wreq_async(usb, skb->data, skb->len, USB_REQ_DATA_TX,\n\t\t\t\t      plfxlc_tx_urb_complete, skb);\n\t\tif (skb_queue_len(&tx->station[usb->sidx].data_list) <= 60)\n\t\t\tieee80211_wake_queues(plfxlc_usb_to_hw(usb));\n\t}\n\tspin_unlock_irqrestore(&tx->lock, flags);\n}\n\nstatic void handle_rx_packet(struct plfxlc_usb *usb, const u8 *buffer,\n\t\t\t     unsigned int length)\n{\n\tplfxlc_mac_rx(plfxlc_usb_to_hw(usb), buffer, length);\n}\n\nstatic void rx_urb_complete(struct urb *urb)\n{\n\tstruct plfxlc_usb_tx *tx;\n\tstruct plfxlc_usb *usb;\n\tunsigned int length;\n\tconst u8 *buffer;\n\tu16 status;\n\tu8 sidx;\n\tint r;\n\n\tif (!urb) {\n\t\tpr_err(\"urb is NULL\\n\");\n\t\treturn;\n\t}\n\tif (!urb->context) {\n\t\tpr_err(\"urb ctx is NULL\\n\");\n\t\treturn;\n\t}\n\tusb = urb->context;\n\n\tif (usb->initialized != 1) {\n\t\tpr_err(\"usb is not initialized\\n\");\n\t\treturn;\n\t}\n\n\ttx = &usb->tx;\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ESHUTDOWN:\n\tcase -EINVAL:\n\tcase -ENODEV:\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -EPIPE:\n\t\tdev_dbg(plfxlc_urb_dev(urb), \"urb %p error %d\\n\", urb, urb->status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(plfxlc_urb_dev(urb), \"urb %p error %d\\n\", urb, urb->status);\n\t\tif (tx->submitted_urbs++ < PURELIFI_URB_RETRY_MAX) {\n\t\t\tdev_dbg(plfxlc_urb_dev(urb), \"urb %p resubmit %d\", urb,\n\t\t\t\ttx->submitted_urbs++);\n\t\t\tgoto resubmit;\n\t\t} else {\n\t\t\tdev_dbg(plfxlc_urb_dev(urb), \"urb %p  max resubmits reached\", urb);\n\t\t\ttx->submitted_urbs = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tbuffer = urb->transfer_buffer;\n\tlength = le32_to_cpu(*(__le32 *)(buffer + sizeof(struct rx_status)))\n\t\t + sizeof(u32);\n\n\tif (urb->actual_length != (PLF_MSG_STATUS_OFFSET + 1)) {\n\t\tif (usb->initialized && usb->link_up)\n\t\t\thandle_rx_packet(usb, buffer, length);\n\t\tgoto resubmit;\n\t}\n\n\tstatus = buffer[PLF_MSG_STATUS_OFFSET];\n\n\tswitch (status) {\n\tcase STATION_FIFO_ALMOST_FULL_NOT_MESSAGE:\n\t\tdev_dbg(&usb->intf->dev,\n\t\t\t\"FIFO full not packet receipt\\n\");\n\t\ttx->mac_fifo_full = 1;\n\t\tfor (sidx = 0; sidx < MAX_STA_NUM; sidx++)\n\t\t\ttx->station[sidx].flag |= STATION_FIFO_FULL_FLAG;\n\t\tbreak;\n\tcase STATION_FIFO_ALMOST_FULL_MESSAGE:\n\t\tdev_dbg(&usb->intf->dev, \"FIFO full packet receipt\\n\");\n\n\t\tfor (sidx = 0; sidx < MAX_STA_NUM; sidx++)\n\t\t\ttx->station[sidx].flag &= STATION_ACTIVE_FLAG;\n\n\t\tplfxlc_send_packet_from_data_queue(usb);\n\t\tbreak;\n\tcase STATION_CONNECT_MESSAGE:\n\t\tusb->link_up = 1;\n\t\tdev_dbg(&usb->intf->dev, \"ST_CONNECT_MSG packet receipt\\n\");\n\t\tbreak;\n\tcase STATION_DISCONNECT_MESSAGE:\n\t\tusb->link_up = 0;\n\t\tdev_dbg(&usb->intf->dev, \"ST_DISCONN_MSG packet receipt\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&usb->intf->dev, \"Unknown packet receipt\\n\");\n\t\tbreak;\n\t}\n\nresubmit:\n\tr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (r)\n\t\tdev_dbg(plfxlc_urb_dev(urb), \"urb %p resubmit fail (%d)\\n\", urb, r);\n}\n\nstatic struct urb *alloc_rx_urb(struct plfxlc_usb *usb)\n{\n\tstruct usb_device *udev = plfxlc_usb_to_usbdev(usb);\n\tstruct urb *urb;\n\tvoid *buffer;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn NULL;\n\n\tbuffer = usb_alloc_coherent(udev, USB_MAX_RX_SIZE, GFP_KERNEL,\n\t\t\t\t    &urb->transfer_dma);\n\tif (!buffer) {\n\t\tusb_free_urb(urb);\n\t\treturn NULL;\n\t}\n\n\tusb_fill_bulk_urb(urb, udev, usb_rcvbulkpipe(udev, EP_DATA_IN),\n\t\t\t  buffer, USB_MAX_RX_SIZE,\n\t\t\t  rx_urb_complete, usb);\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\treturn urb;\n}\n\nstatic void free_rx_urb(struct urb *urb)\n{\n\tif (!urb)\n\t\treturn;\n\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\tusb_free_urb(urb);\n}\n\nstatic int __lf_x_usb_enable_rx(struct plfxlc_usb *usb)\n{\n\tstruct plfxlc_usb_rx *rx = &usb->rx;\n\tstruct urb **urbs;\n\tint i, r;\n\n\tr = -ENOMEM;\n\turbs = kcalloc(RX_URBS_COUNT, sizeof(struct urb *), GFP_KERNEL);\n\tif (!urbs)\n\t\tgoto error;\n\n\tfor (i = 0; i < RX_URBS_COUNT; i++) {\n\t\turbs[i] = alloc_rx_urb(usb);\n\t\tif (!urbs[i])\n\t\t\tgoto error;\n\t}\n\n\tspin_lock_irq(&rx->lock);\n\n\tdev_dbg(plfxlc_usb_dev(usb), \"irq_disabled %d\\n\", irqs_disabled());\n\n\tif (rx->urbs) {\n\t\tspin_unlock_irq(&rx->lock);\n\t\tr = 0;\n\t\tgoto error;\n\t}\n\trx->urbs = urbs;\n\trx->urbs_count = RX_URBS_COUNT;\n\tspin_unlock_irq(&rx->lock);\n\n\tfor (i = 0; i < RX_URBS_COUNT; i++) {\n\t\tr = usb_submit_urb(urbs[i], GFP_KERNEL);\n\t\tif (r)\n\t\t\tgoto error_submit;\n\t}\n\n\treturn 0;\n\nerror_submit:\n\tfor (i = 0; i < RX_URBS_COUNT; i++)\n\t\tusb_kill_urb(urbs[i]);\n\tspin_lock_irq(&rx->lock);\n\trx->urbs = NULL;\n\trx->urbs_count = 0;\n\tspin_unlock_irq(&rx->lock);\nerror:\n\tif (urbs) {\n\t\tfor (i = 0; i < RX_URBS_COUNT; i++)\n\t\t\tfree_rx_urb(urbs[i]);\n\t}\n\tkfree(urbs);\n\treturn r;\n}\n\nint plfxlc_usb_enable_rx(struct plfxlc_usb *usb)\n{\n\tstruct plfxlc_usb_rx *rx = &usb->rx;\n\tint r;\n\n\tmutex_lock(&rx->setup_mutex);\n\tr = __lf_x_usb_enable_rx(usb);\n\tif (!r)\n\t\tusb->rx_usb_enabled = 1;\n\n\tmutex_unlock(&rx->setup_mutex);\n\n\treturn r;\n}\n\nstatic void __lf_x_usb_disable_rx(struct plfxlc_usb *usb)\n{\n\tstruct plfxlc_usb_rx *rx = &usb->rx;\n\tunsigned long flags;\n\tunsigned int count;\n\tstruct urb **urbs;\n\tint i;\n\n\tspin_lock_irqsave(&rx->lock, flags);\n\turbs = rx->urbs;\n\tcount = rx->urbs_count;\n\tspin_unlock_irqrestore(&rx->lock, flags);\n\n\tif (!urbs)\n\t\treturn;\n\n\tfor (i = 0; i < count; i++) {\n\t\tusb_kill_urb(urbs[i]);\n\t\tfree_rx_urb(urbs[i]);\n\t}\n\tkfree(urbs);\n\trx->urbs = NULL;\n\trx->urbs_count = 0;\n}\n\nvoid plfxlc_usb_disable_rx(struct plfxlc_usb *usb)\n{\n\tstruct plfxlc_usb_rx *rx = &usb->rx;\n\n\tmutex_lock(&rx->setup_mutex);\n\t__lf_x_usb_disable_rx(usb);\n\tusb->rx_usb_enabled = 0;\n\tmutex_unlock(&rx->setup_mutex);\n}\n\nvoid plfxlc_usb_disable_tx(struct plfxlc_usb *usb)\n{\n\tstruct plfxlc_usb_tx *tx = &usb->tx;\n\tunsigned long flags;\n\n\tclear_bit(PLF_BIT_ENABLED, &tx->enabled);\n\n\t \n\tusb_kill_anchored_urbs(&tx->submitted);\n\n\tspin_lock_irqsave(&tx->lock, flags);\n\tWARN_ON(!skb_queue_empty(&tx->submitted_skbs));\n\tWARN_ON(tx->submitted_urbs != 0);\n\ttx->submitted_urbs = 0;\n\tspin_unlock_irqrestore(&tx->lock, flags);\n\n\t \n}\n\nvoid plfxlc_usb_enable_tx(struct plfxlc_usb *usb)\n{\n\tstruct plfxlc_usb_tx *tx = &usb->tx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tx->lock, flags);\n\tset_bit(PLF_BIT_ENABLED, &tx->enabled);\n\ttx->submitted_urbs = 0;\n\tieee80211_wake_queues(plfxlc_usb_to_hw(usb));\n\ttx->stopped = 0;\n\tspin_unlock_irqrestore(&tx->lock, flags);\n}\n\nvoid plfxlc_tx_urb_complete(struct urb *urb)\n{\n\tstruct ieee80211_tx_info *info;\n\tstruct plfxlc_usb *usb;\n\tstruct sk_buff *skb;\n\n\tskb = urb->context;\n\tinfo = IEEE80211_SKB_CB(skb);\n\t \n\tusb = &plfxlc_hw_mac(info->rate_driver_data[0])->chip.usb;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ESHUTDOWN:\n\tcase -EINVAL:\n\tcase -ENODEV:\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -EPIPE:\n\t\tdev_dbg(plfxlc_urb_dev(urb), \"urb %p error %d\\n\", urb, urb->status);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(plfxlc_urb_dev(urb), \"urb %p error %d\\n\", urb, urb->status);\n\t\treturn;\n\t}\n\n\tplfxlc_mac_tx_to_dev(skb, urb->status);\n\tplfxlc_send_packet_from_data_queue(usb);\n\tusb_free_urb(urb);\n}\n\nstatic inline void init_usb_rx(struct plfxlc_usb *usb)\n{\n\tstruct plfxlc_usb_rx *rx = &usb->rx;\n\n\tspin_lock_init(&rx->lock);\n\tmutex_init(&rx->setup_mutex);\n\n\tif (interface_to_usbdev(usb->intf)->speed == USB_SPEED_HIGH)\n\t\trx->usb_packet_size = 512;\n\telse\n\t\trx->usb_packet_size = 64;\n\n\tif (rx->fragment_length != 0)\n\t\tdev_dbg(plfxlc_usb_dev(usb), \"fragment_length error\\n\");\n}\n\nstatic inline void init_usb_tx(struct plfxlc_usb *usb)\n{\n\tstruct plfxlc_usb_tx *tx = &usb->tx;\n\n\tspin_lock_init(&tx->lock);\n\tclear_bit(PLF_BIT_ENABLED, &tx->enabled);\n\ttx->stopped = 0;\n\tskb_queue_head_init(&tx->submitted_skbs);\n\tinit_usb_anchor(&tx->submitted);\n}\n\nvoid plfxlc_usb_init(struct plfxlc_usb *usb, struct ieee80211_hw *hw,\n\t\t     struct usb_interface *intf)\n{\n\tmemset(usb, 0, sizeof(*usb));\n\tusb->intf = usb_get_intf(intf);\n\tusb_set_intfdata(usb->intf, hw);\n\tinit_usb_tx(usb);\n\tinit_usb_rx(usb);\n}\n\nvoid plfxlc_usb_release(struct plfxlc_usb *usb)\n{\n\tplfxlc_op_stop(plfxlc_usb_to_hw(usb));\n\tplfxlc_usb_disable_tx(usb);\n\tplfxlc_usb_disable_rx(usb);\n\tusb_set_intfdata(usb->intf, NULL);\n\tusb_put_intf(usb->intf);\n}\n\nconst char *plfxlc_speed(enum usb_device_speed speed)\n{\n\tswitch (speed) {\n\tcase USB_SPEED_LOW:\n\t\treturn \"low\";\n\tcase USB_SPEED_FULL:\n\t\treturn \"full\";\n\tcase USB_SPEED_HIGH:\n\t\treturn \"high\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nint plfxlc_usb_init_hw(struct plfxlc_usb *usb)\n{\n\tint r;\n\n\tr = usb_reset_configuration(plfxlc_usb_to_usbdev(usb));\n\tif (r) {\n\t\tdev_err(plfxlc_usb_dev(usb), \"cfg reset failed (%d)\\n\", r);\n\t\treturn r;\n\t}\n\treturn 0;\n}\n\nstatic void get_usb_req(struct usb_device *udev, void *buffer,\n\t\t\tu32 buffer_len, enum plf_usb_req_enum usb_req_id,\n\t\t\tstruct plf_usb_req *usb_req)\n{\n\t__be32 payload_len_nw = cpu_to_be32(buffer_len + FCS_LEN);\n\tconst u8 *buffer_src_p = buffer;\n\tu8 *buffer_dst = usb_req->buf;\n\tu32 temp_usb_len = 0;\n\n\tusb_req->id = cpu_to_be32(usb_req_id);\n\tusb_req->len  = cpu_to_be32(0);\n\n\t \n\tif (usb_req->id == cpu_to_be32(USB_REQ_BEACON_WR)) {\n\t\tmemcpy(buffer_dst, &payload_len_nw, sizeof(payload_len_nw));\n\t\tbuffer_dst += sizeof(payload_len_nw);\n\t\ttemp_usb_len += sizeof(payload_len_nw);\n\t}\n\n\tmemcpy(buffer_dst, buffer_src_p, buffer_len);\n\tbuffer_dst += buffer_len;\n\tbuffer_src_p += buffer_len;\n\ttemp_usb_len +=  buffer_len;\n\n\t \n\tmemset(buffer_dst, 0, FCS_LEN);\n\tbuffer_dst += FCS_LEN;\n\ttemp_usb_len += FCS_LEN;\n\n\t \n\tif (temp_usb_len % PURELIFI_BYTE_NUM_ALIGNMENT) {\n\t\tmemset(buffer_dst, 0, PURELIFI_BYTE_NUM_ALIGNMENT -\n\t\t       (temp_usb_len %\n\t\t\tPURELIFI_BYTE_NUM_ALIGNMENT));\n\t\tbuffer_dst += PURELIFI_BYTE_NUM_ALIGNMENT -\n\t\t\t\t(temp_usb_len %\n\t\t\t\tPURELIFI_BYTE_NUM_ALIGNMENT);\n\t\ttemp_usb_len += PURELIFI_BYTE_NUM_ALIGNMENT -\n\t\t\t\t(temp_usb_len % PURELIFI_BYTE_NUM_ALIGNMENT);\n\t}\n\n\tusb_req->len = cpu_to_be32(temp_usb_len);\n}\n\nint plfxlc_usb_wreq_async(struct plfxlc_usb *usb, const u8 *buffer,\n\t\t\t  int buffer_len, enum plf_usb_req_enum usb_req_id,\n\t\t\t  usb_complete_t complete_fn,\n\t\t\t  void *context)\n{\n\tstruct usb_device *udev = interface_to_usbdev(usb->ez_usb);\n\tstruct urb *urb;\n\tint r;\n\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\tusb_fill_bulk_urb(urb, udev, usb_sndbulkpipe(udev, EP_DATA_OUT),\n\t\t\t  (void *)buffer, buffer_len, complete_fn, context);\n\n\tr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (r)\n\t\tdev_err(&udev->dev, \"Async write submit failed (%d)\\n\", r);\n\n\treturn r;\n}\n\nint plfxlc_usb_wreq(struct usb_interface *ez_usb, void *buffer, int buffer_len,\n\t\t    enum plf_usb_req_enum usb_req_id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(ez_usb);\n\tunsigned char *dma_buffer = NULL;\n\tstruct plf_usb_req usb_req;\n\tint usb_bulk_msg_len;\n\tint actual_length;\n\tint r;\n\n\tget_usb_req(udev, buffer, buffer_len, usb_req_id, &usb_req);\n\tusb_bulk_msg_len = sizeof(__le32) + sizeof(__le32) +\n\t\t\t   be32_to_cpu(usb_req.len);\n\n\tdma_buffer = kmemdup(&usb_req, usb_bulk_msg_len, GFP_KERNEL);\n\n\tif (!dma_buffer) {\n\t\tr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tr = usb_bulk_msg(udev,\n\t\t\t usb_sndbulkpipe(udev, EP_DATA_OUT),\n\t\t\t dma_buffer, usb_bulk_msg_len,\n\t\t\t &actual_length, USB_BULK_MSG_TIMEOUT_MS);\n\tkfree(dma_buffer);\nerror:\n\tif (r) {\n\t\tr = -ENOMEM;\n\t\tdev_err(&udev->dev, \"usb_bulk_msg failed (%d)\\n\", r);\n\t}\n\n\treturn r;\n}\n\nstatic void slif_data_plane_sap_timer_callb(struct timer_list *t)\n{\n\tstruct plfxlc_usb *usb = from_timer(usb, t, tx.tx_retry_timer);\n\n\tplfxlc_send_packet_from_data_queue(usb);\n\ttimer_setup(&usb->tx.tx_retry_timer,\n\t\t    slif_data_plane_sap_timer_callb, 0);\n\tmod_timer(&usb->tx.tx_retry_timer, jiffies + TX_RETRY_BACKOFF_JIFF);\n}\n\nstatic void sta_queue_cleanup_timer_callb(struct timer_list *t)\n{\n\tstruct plfxlc_usb *usb = from_timer(usb, t, sta_queue_cleanup);\n\tstruct plfxlc_usb_tx *tx = &usb->tx;\n\tint sidx;\n\n\tfor (sidx = 0; sidx < MAX_STA_NUM - 1; sidx++) {\n\t\tif (!(tx->station[sidx].flag & STATION_CONNECTED_FLAG))\n\t\t\tcontinue;\n\t\tif (tx->station[sidx].flag & STATION_HEARTBEAT_FLAG) {\n\t\t\ttx->station[sidx].flag ^= STATION_HEARTBEAT_FLAG;\n\t\t} else {\n\t\t\teth_zero_addr(tx->station[sidx].mac);\n\t\t\ttx->station[sidx].flag = 0;\n\t\t}\n\t}\n\ttimer_setup(&usb->sta_queue_cleanup,\n\t\t    sta_queue_cleanup_timer_callb, 0);\n\tmod_timer(&usb->sta_queue_cleanup, jiffies + STA_QUEUE_CLEANUP_JIFF);\n}\n\nstatic int probe(struct usb_interface *intf,\n\t\t const struct usb_device_id *id)\n{\n\tu8 serial_number[PURELIFI_SERIAL_LEN];\n\tstruct ieee80211_hw *hw = NULL;\n\tstruct plfxlc_usb_tx *tx;\n\tstruct plfxlc_chip *chip;\n\tstruct plfxlc_usb *usb;\n\tu8 hw_address[ETH_ALEN];\n\tunsigned int i;\n\tint r = 0;\n\n\thw = plfxlc_mac_alloc_hw(intf);\n\n\tif (!hw) {\n\t\tr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tchip = &plfxlc_hw_mac(hw)->chip;\n\tusb = &chip->usb;\n\tusb->ez_usb = intf;\n\ttx = &usb->tx;\n\n\tr = plfxlc_upload_mac_and_serial(intf, hw_address, serial_number);\n\tif (r) {\n\t\tdev_err(&intf->dev, \"MAC and Serial upload failed (%d)\\n\", r);\n\t\tgoto error;\n\t}\n\n\tchip->unit_type = STA;\n\tdev_err(&intf->dev, \"Unit type is station\");\n\n\tr = plfxlc_mac_preinit_hw(hw, hw_address);\n\tif (r) {\n\t\tdev_err(&intf->dev, \"Init mac failed (%d)\\n\", r);\n\t\tgoto error;\n\t}\n\n\tr = ieee80211_register_hw(hw);\n\tif (r) {\n\t\tdev_err(&intf->dev, \"Register device failed (%d)\\n\", r);\n\t\tgoto error;\n\t}\n\n\tif ((le16_to_cpu(interface_to_usbdev(intf)->descriptor.idVendor) ==\n\t\t\t\tPURELIFI_XL_VENDOR_ID_0) &&\n\t    (le16_to_cpu(interface_to_usbdev(intf)->descriptor.idProduct) ==\n\t\t\t\tPURELIFI_XL_PRODUCT_ID_0)) {\n\t\tr = plfxlc_download_xl_firmware(intf);\n\t} else {\n\t\tr = plfxlc_download_fpga(intf);\n\t}\n\tif (r != 0) {\n\t\tdev_err(&intf->dev, \"FPGA download failed (%d)\\n\", r);\n\t\tgoto error;\n\t}\n\n\ttx->mac_fifo_full = 0;\n\tspin_lock_init(&tx->lock);\n\n\tmsleep(PLF_MSLEEP_TIME);\n\tr = plfxlc_usb_init_hw(usb);\n\tif (r < 0) {\n\t\tdev_err(&intf->dev, \"usb_init_hw failed (%d)\\n\", r);\n\t\tgoto error;\n\t}\n\n\tmsleep(PLF_MSLEEP_TIME);\n\tr = plfxlc_chip_switch_radio(chip, PLFXLC_RADIO_ON);\n\tif (r < 0) {\n\t\tdev_dbg(&intf->dev, \"chip_switch_radio_on failed (%d)\\n\", r);\n\t\tgoto error;\n\t}\n\n\tmsleep(PLF_MSLEEP_TIME);\n\tr = plfxlc_chip_set_rate(chip, 8);\n\tif (r < 0) {\n\t\tdev_dbg(&intf->dev, \"chip_set_rate failed (%d)\\n\", r);\n\t\tgoto error;\n\t}\n\n\tmsleep(PLF_MSLEEP_TIME);\n\tr = plfxlc_usb_wreq(usb->ez_usb,\n\t\t\t    hw_address, ETH_ALEN, USB_REQ_MAC_WR);\n\tif (r < 0) {\n\t\tdev_dbg(&intf->dev, \"MAC_WR failure (%d)\\n\", r);\n\t\tgoto error;\n\t}\n\n\tplfxlc_chip_enable_rxtx(chip);\n\n\t \n\tfor (i = 0; i < MAX_STA_NUM; i++) {\n\t\tskb_queue_head_init(&tx->station[i].data_list);\n\t\ttx->station[i].flag = 0;\n\t}\n\n\ttx->station[STA_BROADCAST_INDEX].flag |= STATION_CONNECTED_FLAG;\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\ttx->station[STA_BROADCAST_INDEX].mac[i] = 0xFF;\n\n\ttimer_setup(&tx->tx_retry_timer, slif_data_plane_sap_timer_callb, 0);\n\ttx->tx_retry_timer.expires = jiffies + TX_RETRY_BACKOFF_JIFF;\n\tadd_timer(&tx->tx_retry_timer);\n\n\ttimer_setup(&usb->sta_queue_cleanup,\n\t\t    sta_queue_cleanup_timer_callb, 0);\n\tusb->sta_queue_cleanup.expires = jiffies + STA_QUEUE_CLEANUP_JIFF;\n\tadd_timer(&usb->sta_queue_cleanup);\n\n\tplfxlc_mac_init_hw(hw);\n\tusb->initialized = true;\n\treturn 0;\nerror:\n\tif (hw) {\n\t\tplfxlc_mac_release(plfxlc_hw_mac(hw));\n\t\tieee80211_unregister_hw(hw);\n\t\tieee80211_free_hw(hw);\n\t}\n\tdev_err(&intf->dev, \"pureLifi:Device error\");\n\treturn r;\n}\n\nstatic void disconnect(struct usb_interface *intf)\n{\n\tstruct ieee80211_hw *hw = plfxlc_intf_to_hw(intf);\n\tstruct plfxlc_mac *mac;\n\tstruct plfxlc_usb *usb;\n\n\t \n\tif (!hw)\n\t\treturn;\n\n\tmac = plfxlc_hw_mac(hw);\n\tusb = &mac->chip.usb;\n\n\tdel_timer_sync(&usb->tx.tx_retry_timer);\n\tdel_timer_sync(&usb->sta_queue_cleanup);\n\n\tieee80211_unregister_hw(hw);\n\n\tplfxlc_chip_disable_rxtx(&mac->chip);\n\n\t \n\tusb_reset_device(interface_to_usbdev(intf));\n\n\tplfxlc_mac_release(mac);\n\tieee80211_free_hw(hw);\n}\n\nstatic void plfxlc_usb_resume(struct plfxlc_usb *usb)\n{\n\tstruct plfxlc_mac *mac = plfxlc_usb_to_mac(usb);\n\tint r;\n\n\tr = plfxlc_op_start(plfxlc_usb_to_hw(usb));\n\tif (r < 0) {\n\t\tdev_warn(plfxlc_usb_dev(usb),\n\t\t\t \"Device resume failed (%d)\\n\", r);\n\n\t\tif (usb->was_running)\n\t\t\tset_bit(PURELIFI_DEVICE_RUNNING, &mac->flags);\n\n\t\tusb_queue_reset_device(usb->intf);\n\t\treturn;\n\t}\n\n\tif (mac->type != NL80211_IFTYPE_UNSPECIFIED) {\n\t\tr = plfxlc_restore_settings(mac);\n\t\tif (r < 0) {\n\t\t\tdev_dbg(plfxlc_usb_dev(usb),\n\t\t\t\t\"Restore failed (%d)\\n\", r);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void plfxlc_usb_stop(struct plfxlc_usb *usb)\n{\n\tplfxlc_op_stop(plfxlc_usb_to_hw(usb));\n\tplfxlc_usb_disable_tx(usb);\n\tplfxlc_usb_disable_rx(usb);\n\n\tusb->initialized = false;\n}\n\nstatic int pre_reset(struct usb_interface *intf)\n{\n\tstruct ieee80211_hw *hw = usb_get_intfdata(intf);\n\tstruct plfxlc_mac *mac;\n\tstruct plfxlc_usb *usb;\n\n\tif (!hw || intf->condition != USB_INTERFACE_BOUND)\n\t\treturn 0;\n\n\tmac = plfxlc_hw_mac(hw);\n\tusb = &mac->chip.usb;\n\n\tusb->was_running = test_bit(PURELIFI_DEVICE_RUNNING, &mac->flags);\n\n\tplfxlc_usb_stop(usb);\n\n\treturn 0;\n}\n\nstatic int post_reset(struct usb_interface *intf)\n{\n\tstruct ieee80211_hw *hw = usb_get_intfdata(intf);\n\tstruct plfxlc_mac *mac;\n\tstruct plfxlc_usb *usb;\n\n\tif (!hw || intf->condition != USB_INTERFACE_BOUND)\n\t\treturn 0;\n\n\tmac = plfxlc_hw_mac(hw);\n\tusb = &mac->chip.usb;\n\n\tif (usb->was_running)\n\t\tplfxlc_usb_resume(usb);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\n\nstatic struct plfxlc_usb *get_plfxlc_usb(struct usb_interface *intf)\n{\n\tstruct ieee80211_hw *hw = plfxlc_intf_to_hw(intf);\n\tstruct plfxlc_mac *mac;\n\n\t \n\tif (!hw)\n\t\treturn NULL;\n\n\tmac = plfxlc_hw_mac(hw);\n\treturn &mac->chip.usb;\n}\n\nstatic int suspend(struct usb_interface *interface,\n\t\t   pm_message_t message)\n{\n\tstruct plfxlc_usb *pl = get_plfxlc_usb(interface);\n\tstruct plfxlc_mac *mac = plfxlc_usb_to_mac(pl);\n\n\tif (!pl)\n\t\treturn -ENODEV;\n\tif (pl->initialized == 0)\n\t\treturn 0;\n\tpl->was_running = test_bit(PURELIFI_DEVICE_RUNNING, &mac->flags);\n\tplfxlc_usb_stop(pl);\n\treturn 0;\n}\n\nstatic int resume(struct usb_interface *interface)\n{\n\tstruct plfxlc_usb *pl = get_plfxlc_usb(interface);\n\n\tif (!pl)\n\t\treturn -ENODEV;\n\tif (pl->was_running)\n\t\tplfxlc_usb_resume(pl);\n\treturn 0;\n}\n\n#endif\n\nstatic struct usb_driver driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = usb_ids,\n\t.probe = probe,\n\t.disconnect = disconnect,\n\t.pre_reset = pre_reset,\n\t.post_reset = post_reset,\n#ifdef CONFIG_PM\n\t.suspend = suspend,\n\t.resume = resume,\n#endif\n\t.disable_hub_initiated_lpm = 1,\n};\n\nstatic int __init usb_init(void)\n{\n\tint r;\n\n\tr = usb_register(&driver);\n\tif (r) {\n\t\tpr_err(\"%s usb_register() failed %d\\n\", driver.name, r);\n\t\treturn r;\n\t}\n\n\tpr_debug(\"Driver initialized :%s\\n\", driver.name);\n\treturn 0;\n}\n\nstatic void __exit usb_exit(void)\n{\n\tusb_deregister(&driver);\n\tpr_debug(\"%s %s\\n\", driver.name, __func__);\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"USB driver for pureLiFi devices\");\nMODULE_AUTHOR(\"pureLiFi\");\nMODULE_VERSION(\"1.0\");\nMODULE_FIRMWARE(\"plfxlc/lifi-x.bin\");\nMODULE_DEVICE_TABLE(usb, usb_ids);\n\nmodule_init(usb_init);\nmodule_exit(usb_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}