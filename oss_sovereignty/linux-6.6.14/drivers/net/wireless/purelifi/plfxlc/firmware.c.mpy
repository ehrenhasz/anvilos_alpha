{
  "module_name": "firmware.c",
  "hash_id": "4dc05e6a82f09597a0af530571239084015a6f2497d873ed3baaba3773db9434",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/purelifi/plfxlc/firmware.c",
  "human_readable_source": "\n \n\n#include <linux/firmware.h>\n#include <linux/bitrev.h>\n\n#include \"mac.h\"\n#include \"usb.h\"\n\nstatic int send_vendor_request(struct usb_device *udev, int request,\n\t\t\t       unsigned char *buffer, int buffer_size)\n{\n\treturn usb_control_msg(udev,\n\t\t\t       usb_rcvctrlpipe(udev, 0),\n\t\t\t       request, 0xC0, 0, 0,\n\t\t\t       buffer, buffer_size, PLF_USB_TIMEOUT);\n}\n\nstatic int send_vendor_command(struct usb_device *udev, int request,\n\t\t\t       unsigned char *buffer, int buffer_size)\n{\n\treturn usb_control_msg(udev,\n\t\t\t       usb_sndctrlpipe(udev, 0),\n\t\t\t       request, USB_TYPE_VENDOR  , 0, 0,\n\t\t\t       buffer, buffer_size, PLF_USB_TIMEOUT);\n}\n\nint plfxlc_download_fpga(struct usb_interface *intf)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tunsigned char *fpga_dmabuff = NULL;\n\tconst struct firmware *fw = NULL;\n\tint blk_tran_len = PLF_BULK_TLEN;\n\tunsigned char *fw_data;\n\tconst char *fw_name;\n\tint r, actual_length;\n\tint fw_data_i = 0;\n\n\tif ((le16_to_cpu(udev->descriptor.idVendor) ==\n\t\t\t\tPURELIFI_X_VENDOR_ID_0) &&\n\t    (le16_to_cpu(udev->descriptor.idProduct) ==\n\t\t\t\tPURELIFI_X_PRODUCT_ID_0)) {\n\t\tfw_name = \"plfxlc/lifi-x.bin\";\n\t\tdev_dbg(&intf->dev, \"bin file for X selected\\n\");\n\n\t} else if ((le16_to_cpu(udev->descriptor.idVendor)) ==\n\t\t\t\t\tPURELIFI_XC_VENDOR_ID_0 &&\n\t\t   (le16_to_cpu(udev->descriptor.idProduct) ==\n\t\t\t\t\tPURELIFI_XC_PRODUCT_ID_0)) {\n\t\tfw_name = \"plfxlc/lifi-xc.bin\";\n\t\tdev_dbg(&intf->dev, \"bin file for XC selected\\n\");\n\n\t} else {\n\t\tr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tr = request_firmware(&fw, fw_name, &intf->dev);\n\tif (r) {\n\t\tdev_err(&intf->dev, \"request_firmware failed (%d)\\n\", r);\n\t\tgoto error;\n\t}\n\tfpga_dmabuff = kmalloc(PLF_FPGA_STATUS_LEN, GFP_KERNEL);\n\n\tif (!fpga_dmabuff) {\n\t\tr = -ENOMEM;\n\t\tgoto error_free_fw;\n\t}\n\tsend_vendor_request(udev, PLF_VNDR_FPGA_SET_REQ,\n\t\t\t    fpga_dmabuff, PLF_FPGA_STATUS_LEN);\n\n\tsend_vendor_command(udev, PLF_VNDR_FPGA_SET_CMD, NULL, 0);\n\n\tif (fpga_dmabuff[0] != PLF_FPGA_MG) {\n\t\tdev_err(&intf->dev, \"fpga_dmabuff[0] is wrong\\n\");\n\t\tr = -EINVAL;\n\t\tgoto error_free_fw;\n\t}\n\n\tfor (fw_data_i = 0; fw_data_i < fw->size;) {\n\t\tint tbuf_idx;\n\n\t\tif ((fw->size - fw_data_i) < blk_tran_len)\n\t\t\tblk_tran_len = fw->size - fw_data_i;\n\n\t\tfw_data = kmemdup(&fw->data[fw_data_i], blk_tran_len,\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!fw_data) {\n\t\t\tr = -ENOMEM;\n\t\t\tgoto error_free_fw;\n\t\t}\n\n\t\tfor (tbuf_idx = 0; tbuf_idx < blk_tran_len; tbuf_idx++) {\n\t\t\t \n\t\t\tfw_data[tbuf_idx] = bitrev8(fw_data[tbuf_idx]);\n\t\t}\n\t\tr = usb_bulk_msg(udev,\n\t\t\t\t usb_sndbulkpipe(interface_to_usbdev(intf),\n\t\t\t\t\t\t fpga_dmabuff[0] & 0xff),\n\t\t\t\t fw_data,\n\t\t\t\t blk_tran_len,\n\t\t\t\t &actual_length,\n\t\t\t\t 2 * PLF_USB_TIMEOUT);\n\n\t\tif (r)\n\t\t\tdev_err(&intf->dev, \"Bulk msg failed (%d)\\n\", r);\n\n\t\tkfree(fw_data);\n\t\tfw_data_i += blk_tran_len;\n\t}\n\n\tkfree(fpga_dmabuff);\n\tfpga_dmabuff = kmalloc(PLF_FPGA_STATE_LEN, GFP_KERNEL);\n\tif (!fpga_dmabuff) {\n\t\tr = -ENOMEM;\n\t\tgoto error_free_fw;\n\t}\n\tmemset(fpga_dmabuff, 0xff, PLF_FPGA_STATE_LEN);\n\n\tsend_vendor_request(udev, PLF_VNDR_FPGA_STATE_REQ, fpga_dmabuff,\n\t\t\t    PLF_FPGA_STATE_LEN);\n\n\tdev_dbg(&intf->dev, \"%*ph\\n\", 8, fpga_dmabuff);\n\n\tif (fpga_dmabuff[0] != 0) {\n\t\tr = -EINVAL;\n\t\tgoto error_free_fw;\n\t}\n\n\tsend_vendor_command(udev, PLF_VNDR_FPGA_STATE_CMD, NULL, 0);\n\n\tmsleep(PLF_MSLEEP_TIME);\n\nerror_free_fw:\n\tkfree(fpga_dmabuff);\n\trelease_firmware(fw);\nerror:\n\treturn r;\n}\n\nint plfxlc_download_xl_firmware(struct usb_interface *intf)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tconst struct firmware *fwp = NULL;\n\tstruct plfxlc_firmware_file file = {0};\n\tconst char *fw_pack;\n\tint s, r;\n\tu8 *buf;\n\tu32 i;\n\n\tr = send_vendor_command(udev, PLF_VNDR_XL_FW_CMD, NULL, 0);\n\tmsleep(PLF_MSLEEP_TIME);\n\n\tif (r) {\n\t\tdev_err(&intf->dev, \"vendor command failed (%d)\\n\", r);\n\t\treturn -EINVAL;\n\t}\n\t \n\n\tfw_pack = \"plfxlc/lifi-xl.bin\";\n\n\tr = request_firmware(&fwp, fw_pack, &intf->dev);\n\tif (r) {\n\t\tdev_err(&intf->dev, \"Request_firmware failed (%d)\\n\", r);\n\t\treturn -EINVAL;\n\t}\n\tfile.total_files = get_unaligned_le32(&fwp->data[0]);\n\tfile.total_size = get_unaligned_le32(&fwp->size);\n\n\tdev_dbg(&intf->dev, \"XL Firmware (%d, %d)\\n\",\n\t\tfile.total_files, file.total_size);\n\n\tbuf = kzalloc(PLF_XL_BUF_LEN, GFP_KERNEL);\n\tif (!buf) {\n\t\trelease_firmware(fwp);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (file.total_files > 10) {\n\t\tdev_err(&intf->dev, \"Too many files (%d)\\n\", file.total_files);\n\t\trelease_firmware(fwp);\n\t\tkfree(buf);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (s = 0; s < file.total_files; s++) {\n\t\tbuf[0] = s;\n\t\tr = send_vendor_command(udev, PLF_VNDR_XL_FILE_CMD, buf,\n\t\t\t\t\tPLF_XL_BUF_LEN);\n\n\t\tif (s < file.total_files - 1)\n\t\t\tfile.size = get_unaligned_le32(&fwp->data[4 + ((s + 1) * 4)])\n\t\t\t\t    - get_unaligned_le32(&fwp->data[4 + (s) * 4]);\n\t\telse\n\t\t\tfile.size = file.total_size -\n\t\t\t\t    get_unaligned_le32(&fwp->data[4 + (s) * 4]);\n\n\t\tif (file.size > file.total_size || file.size > 60000) {\n\t\t\tdev_err(&intf->dev, \"File size is too large (%d)\\n\", file.size);\n\t\t\tbreak;\n\t\t}\n\n\t\tfile.start_addr = get_unaligned_le32(&fwp->data[4 + (s * 4)]);\n\n\t\tif (file.size % PLF_XL_BUF_LEN && s < 2)\n\t\t\tfile.size += PLF_XL_BUF_LEN - file.size % PLF_XL_BUF_LEN;\n\n\t\tfile.control_packets = file.size / PLF_XL_BUF_LEN;\n\n\t\tfor (i = 0; i < file.control_packets; i++) {\n\t\t\tmemcpy(buf,\n\t\t\t       &fwp->data[file.start_addr + (i * PLF_XL_BUF_LEN)],\n\t\t\t       PLF_XL_BUF_LEN);\n\t\t\tr = send_vendor_command(udev, PLF_VNDR_XL_DATA_CMD, buf,\n\t\t\t\t\t\tPLF_XL_BUF_LEN);\n\t\t}\n\t\tdev_dbg(&intf->dev, \"fw-dw step=%d,r=%d size=%d\\n\", s, r,\n\t\t\tfile.size);\n\t}\n\trelease_firmware(fwp);\n\tkfree(buf);\n\n\t \n\n\tr = send_vendor_command(udev, PLF_VNDR_XL_EX_CMD, NULL, 0);\n\tdev_dbg(&intf->dev, \"Download fpga (4) (%d)\\n\", r);\n\n\treturn 0;\n}\n\nint plfxlc_upload_mac_and_serial(struct usb_interface *intf,\n\t\t\t\t unsigned char *hw_address,\n\t\t\t\t unsigned char *serial_number)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tunsigned long long firmware_version;\n\tunsigned char *dma_buffer = NULL;\n\n\tdma_buffer = kmalloc(PLF_SERIAL_LEN, GFP_KERNEL);\n\tif (!dma_buffer)\n\t\treturn -ENOMEM;\n\n\tBUILD_BUG_ON(ETH_ALEN > PLF_SERIAL_LEN);\n\tBUILD_BUG_ON(PLF_FW_VER_LEN > PLF_SERIAL_LEN);\n\n\tsend_vendor_request(udev, PLF_MAC_VENDOR_REQUEST, dma_buffer,\n\t\t\t    ETH_ALEN);\n\n\tmemcpy(hw_address, dma_buffer, ETH_ALEN);\n\n\tsend_vendor_request(udev, PLF_SERIAL_NUMBER_VENDOR_REQUEST,\n\t\t\t    dma_buffer, PLF_SERIAL_LEN);\n\n\tsend_vendor_request(udev, PLF_SERIAL_NUMBER_VENDOR_REQUEST,\n\t\t\t    dma_buffer, PLF_SERIAL_LEN);\n\n\tmemcpy(serial_number, dma_buffer, PLF_SERIAL_LEN);\n\n\tmemset(dma_buffer, 0x00, PLF_SERIAL_LEN);\n\n\tsend_vendor_request(udev, PLF_FIRMWARE_VERSION_VENDOR_REQUEST,\n\t\t\t    (unsigned char *)dma_buffer, PLF_FW_VER_LEN);\n\n\tmemcpy(&firmware_version, dma_buffer, PLF_FW_VER_LEN);\n\n\tdev_info(&intf->dev, \"Firmware Version: %llu\\n\", firmware_version);\n\tkfree(dma_buffer);\n\n\tdev_dbg(&intf->dev, \"Mac: %pM\\n\", hw_address);\n\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}