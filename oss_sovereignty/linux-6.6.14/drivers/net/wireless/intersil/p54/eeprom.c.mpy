{
  "module_name": "eeprom.c",
  "hash_id": "5f3411907cb2ef1022b3dd4296997ab4e7d9be224ef3b8156bb8b936f5769cfe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/p54/eeprom.c",
  "human_readable_source": "\n \n\n#include <linux/firmware.h>\n#include <linux/etherdevice.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n\n#include <net/mac80211.h>\n#include <linux/crc-ccitt.h>\n#include <linux/export.h>\n\n#include \"p54.h\"\n#include \"eeprom.h\"\n#include \"lmac.h\"\n\nstatic struct ieee80211_rate p54_bgrates[] = {\n\t{ .bitrate = 10, .hw_value = 0, },\n\t{ .bitrate = 20, .hw_value = 1, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 55, .hw_value = 2, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 110, .hw_value = 3, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 60, .hw_value = 4, },\n\t{ .bitrate = 90, .hw_value = 5, },\n\t{ .bitrate = 120, .hw_value = 6, },\n\t{ .bitrate = 180, .hw_value = 7, },\n\t{ .bitrate = 240, .hw_value = 8, },\n\t{ .bitrate = 360, .hw_value = 9, },\n\t{ .bitrate = 480, .hw_value = 10, },\n\t{ .bitrate = 540, .hw_value = 11, },\n};\n\nstatic struct ieee80211_rate p54_arates[] = {\n\t{ .bitrate = 60, .hw_value = 4, },\n\t{ .bitrate = 90, .hw_value = 5, },\n\t{ .bitrate = 120, .hw_value = 6, },\n\t{ .bitrate = 180, .hw_value = 7, },\n\t{ .bitrate = 240, .hw_value = 8, },\n\t{ .bitrate = 360, .hw_value = 9, },\n\t{ .bitrate = 480, .hw_value = 10, },\n\t{ .bitrate = 540, .hw_value = 11, },\n};\n\nstatic struct p54_rssi_db_entry p54_rssi_default = {\n\t \n\t.mul = 130,\n\t.add = -398,\n};\n\n#define CHAN_HAS_CAL\t\tBIT(0)\n#define CHAN_HAS_LIMIT\t\tBIT(1)\n#define CHAN_HAS_CURVE\t\tBIT(2)\n#define CHAN_HAS_ALL\t\t(CHAN_HAS_CAL | CHAN_HAS_LIMIT | CHAN_HAS_CURVE)\n\nstruct p54_channel_entry {\n\tu16 freq;\n\tu16 data;\n\tint index;\n\tint max_power;\n\tenum nl80211_band band;\n};\n\nstruct p54_channel_list {\n\tstruct p54_channel_entry *channels;\n\tsize_t entries;\n\tsize_t max_entries;\n\tsize_t band_channel_num[NUM_NL80211_BANDS];\n};\n\nstatic int p54_get_band_from_freq(u16 freq)\n{\n\t \n\n\tif ((freq >= 2412) && (freq <= 2484))\n\t\treturn NL80211_BAND_2GHZ;\n\n\tif ((freq >= 4920) && (freq <= 5825))\n\t\treturn NL80211_BAND_5GHZ;\n\n\treturn -1;\n}\n\nstatic int same_band(u16 freq, u16 freq2)\n{\n\treturn p54_get_band_from_freq(freq) == p54_get_band_from_freq(freq2);\n}\n\nstatic int p54_compare_channels(const void *_a,\n\t\t\t\tconst void *_b)\n{\n\tconst struct p54_channel_entry *a = _a;\n\tconst struct p54_channel_entry *b = _b;\n\n\treturn a->freq - b->freq;\n}\n\nstatic int p54_compare_rssichan(const void *_a,\n\t\t\t\tconst void *_b)\n{\n\tconst struct p54_rssi_db_entry *a = _a;\n\tconst struct p54_rssi_db_entry *b = _b;\n\n\treturn a->freq - b->freq;\n}\n\nstatic int p54_fill_band_bitrates(struct ieee80211_hw *dev,\n\t\t\t\t  struct ieee80211_supported_band *band_entry,\n\t\t\t\t  enum nl80211_band band)\n{\n\t \n\n\tswitch (band) {\n\tcase NL80211_BAND_2GHZ:\n\t\tband_entry->bitrates = p54_bgrates;\n\t\tband_entry->n_bitrates = ARRAY_SIZE(p54_bgrates);\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\tband_entry->bitrates = p54_arates;\n\t\tband_entry->n_bitrates = ARRAY_SIZE(p54_arates);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int p54_generate_band(struct ieee80211_hw *dev,\n\t\t\t     struct p54_channel_list *list,\n\t\t\t     unsigned int *chan_num,\n\t\t\t     enum nl80211_band band)\n{\n\tstruct p54_common *priv = dev->priv;\n\tstruct ieee80211_supported_band *tmp, *old;\n\tunsigned int i, j;\n\tint ret = -ENOMEM;\n\n\tif ((!list->entries) || (!list->band_channel_num[band]))\n\t\treturn -EINVAL;\n\n\ttmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\n\tif (!tmp)\n\t\tgoto err_out;\n\n\ttmp->channels = kcalloc(list->band_channel_num[band],\n\t\t\t\tsizeof(struct ieee80211_channel),\n\t\t\t\tGFP_KERNEL);\n\tif (!tmp->channels)\n\t\tgoto err_out;\n\n\tret = p54_fill_band_bitrates(dev, tmp, band);\n\tif (ret)\n\t\tgoto err_out;\n\n\tfor (i = 0, j = 0; (j < list->band_channel_num[band]) &&\n\t\t\t   (i < list->entries); i++) {\n\t\tstruct p54_channel_entry *chan = &list->channels[i];\n\t\tstruct ieee80211_channel *dest = &tmp->channels[j];\n\n\t\tif (chan->band != band)\n\t\t\tcontinue;\n\n\t\tif (chan->data != CHAN_HAS_ALL) {\n\t\t\twiphy_err(dev->wiphy, \"%s%s%s is/are missing for \"\n\t\t\t\t  \"channel:%d [%d MHz].\\n\",\n\t\t\t\t  (chan->data & CHAN_HAS_CAL ? \"\" :\n\t\t\t\t   \" [iqauto calibration data]\"),\n\t\t\t\t  (chan->data & CHAN_HAS_LIMIT ? \"\" :\n\t\t\t\t   \" [output power limits]\"),\n\t\t\t\t  (chan->data & CHAN_HAS_CURVE ? \"\" :\n\t\t\t\t   \" [curve data]\"),\n\t\t\t\t  chan->index, chan->freq);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdest->band = chan->band;\n\t\tdest->center_freq = chan->freq;\n\t\tdest->max_power = chan->max_power;\n\t\tpriv->survey[*chan_num].channel = &tmp->channels[j];\n\t\tpriv->survey[*chan_num].filled = SURVEY_INFO_NOISE_DBM |\n\t\t\tSURVEY_INFO_TIME |\n\t\t\tSURVEY_INFO_TIME_BUSY |\n\t\t\tSURVEY_INFO_TIME_TX;\n\t\tdest->hw_value = (*chan_num);\n\t\tj++;\n\t\t(*chan_num)++;\n\t}\n\n\tif (j == 0) {\n\t\twiphy_err(dev->wiphy, \"Disabling totally damaged %d GHz band\\n\",\n\t\t\t  (band == NL80211_BAND_2GHZ) ? 2 : 5);\n\n\t\tret = -ENODATA;\n\t\tgoto err_out;\n\t}\n\n\ttmp->n_channels = j;\n\told = priv->band_table[band];\n\tpriv->band_table[band] = tmp;\n\tif (old) {\n\t\tkfree(old->channels);\n\t\tkfree(old);\n\t}\n\n\treturn 0;\n\nerr_out:\n\tif (tmp) {\n\t\tkfree(tmp->channels);\n\t\tkfree(tmp);\n\t}\n\n\treturn ret;\n}\n\nstatic struct p54_channel_entry *p54_update_channel_param(struct p54_channel_list *list,\n\t\t\t\t\t\t\t  u16 freq, u16 data)\n{\n\tint i;\n\tstruct p54_channel_entry *entry = NULL;\n\n\t \n\tfor (i = list->entries; i >= 0; i--) {\n\t\tif (freq == list->channels[i].freq) {\n\t\t\tentry = &list->channels[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((i < 0) && (list->entries < list->max_entries)) {\n\t\t \n\t\tint band = p54_get_band_from_freq(freq);\n\n\t\t \n\t\tif (band >= 0) {\n\t\t\ti = list->entries++;\n\t\t\tlist->band_channel_num[band]++;\n\n\t\t\tentry = &list->channels[i];\n\t\t\tentry->freq = freq;\n\t\t\tentry->band = band;\n\t\t\tentry->index = ieee80211_frequency_to_channel(freq);\n\t\t\tentry->max_power = 0;\n\t\t\tentry->data = 0;\n\t\t}\n\t}\n\n\tif (entry)\n\t\tentry->data |= data;\n\n\treturn entry;\n}\n\nstatic int p54_get_maxpower(struct p54_common *priv, void *data)\n{\n\tswitch (priv->rxhw & PDR_SYNTH_FRONTEND_MASK) {\n\tcase PDR_SYNTH_FRONTEND_LONGBOW: {\n\t\tstruct pda_channel_output_limit_longbow *pda = data;\n\t\tint j;\n\t\tu16 rawpower = 0;\n\t\tpda = data;\n\t\tfor (j = 0; j < ARRAY_SIZE(pda->point); j++) {\n\t\t\tstruct pda_channel_output_limit_point_longbow *point =\n\t\t\t\t&pda->point[j];\n\t\t\trawpower = max_t(u16,\n\t\t\t\trawpower, le16_to_cpu(point->val_qpsk));\n\t\t\trawpower = max_t(u16,\n\t\t\t\trawpower, le16_to_cpu(point->val_bpsk));\n\t\t\trawpower = max_t(u16,\n\t\t\t\trawpower, le16_to_cpu(point->val_16qam));\n\t\t\trawpower = max_t(u16,\n\t\t\t\trawpower, le16_to_cpu(point->val_64qam));\n\t\t}\n\t\t \n\t\treturn rawpower / 16;\n\t\t}\n\n\tcase PDR_SYNTH_FRONTEND_DUETTE3:\n\tcase PDR_SYNTH_FRONTEND_DUETTE2:\n\tcase PDR_SYNTH_FRONTEND_FRISBEE:\n\tcase PDR_SYNTH_FRONTEND_XBOW: {\n\t\tstruct pda_channel_output_limit *pda = data;\n\t\tu8 rawpower = 0;\n\t\trawpower = max(rawpower, pda->val_qpsk);\n\t\trawpower = max(rawpower, pda->val_bpsk);\n\t\trawpower = max(rawpower, pda->val_16qam);\n\t\trawpower = max(rawpower, pda->val_64qam);\n\t\t \n\t\treturn rawpower / 4;\n\t\t}\n\n\tdefault:\n\t\treturn 20;\n\t}\n}\n\nstatic int p54_generate_channel_lists(struct ieee80211_hw *dev)\n{\n\tstruct p54_common *priv = dev->priv;\n\tstruct p54_channel_list *list;\n\tunsigned int i, j, k, max_channel_num;\n\tint ret = 0;\n\tu16 freq;\n\n\tif ((priv->iq_autocal_len != priv->curve_data->entries) ||\n\t    (priv->iq_autocal_len != priv->output_limit->entries))\n\t\twiphy_err(dev->wiphy,\n\t\t\t  \"Unsupported or damaged EEPROM detected. \"\n\t\t\t  \"You may not be able to use all channels.\\n\");\n\n\tmax_channel_num = max_t(unsigned int, priv->output_limit->entries,\n\t\t\t\tpriv->iq_autocal_len);\n\tmax_channel_num = max_t(unsigned int, max_channel_num,\n\t\t\t\tpriv->curve_data->entries);\n\n\tlist = kzalloc(sizeof(*list), GFP_KERNEL);\n\tif (!list) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\tpriv->chan_num = max_channel_num;\n\tpriv->survey = kcalloc(max_channel_num, sizeof(struct survey_info),\n\t\t\t       GFP_KERNEL);\n\tif (!priv->survey) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tlist->max_entries = max_channel_num;\n\tlist->channels = kcalloc(max_channel_num,\n\t\t\t\t sizeof(struct p54_channel_entry),\n\t\t\t\t GFP_KERNEL);\n\tif (!list->channels) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tfor (i = 0; i < max_channel_num; i++) {\n\t\tif (i < priv->iq_autocal_len) {\n\t\t\tfreq = le16_to_cpu(priv->iq_autocal[i].freq);\n\t\t\tp54_update_channel_param(list, freq, CHAN_HAS_CAL);\n\t\t}\n\n\t\tif (i < priv->output_limit->entries) {\n\t\t\tstruct p54_channel_entry *tmp;\n\n\t\t\tvoid *data = (void *) ((unsigned long) i *\n\t\t\t\tpriv->output_limit->entry_size +\n\t\t\t\tpriv->output_limit->offset +\n\t\t\t\tpriv->output_limit->data);\n\n\t\t\tfreq = le16_to_cpup((__le16 *) data);\n\t\t\ttmp = p54_update_channel_param(list, freq,\n\t\t\t\t\t\t       CHAN_HAS_LIMIT);\n\t\t\tif (tmp) {\n\t\t\t\ttmp->max_power = p54_get_maxpower(priv, data);\n\t\t\t}\n\t\t}\n\n\t\tif (i < priv->curve_data->entries) {\n\t\t\tfreq = le16_to_cpup((__le16 *) (i *\n\t\t\t\t\t    priv->curve_data->entry_size +\n\t\t\t\t\t    priv->curve_data->offset +\n\t\t\t\t\t    priv->curve_data->data));\n\n\t\t\tp54_update_channel_param(list, freq, CHAN_HAS_CURVE);\n\t\t}\n\t}\n\n\t \n\tsort(list->channels, list->entries, sizeof(struct p54_channel_entry),\n\t     p54_compare_channels, NULL);\n\n\tk = 0;\n\tfor (i = 0, j = 0; i < NUM_NL80211_BANDS; i++) {\n\t\tif (p54_generate_band(dev, list, &k, i) == 0)\n\t\t\tj++;\n\t}\n\tif (j == 0) {\n\t\t \n\t\tret = -EINVAL;\n\t}\n\nfree:\n\tif (list) {\n\t\tkfree(list->channels);\n\t\tkfree(list);\n\t}\n\tif (ret) {\n\t\tkfree(priv->survey);\n\t\tpriv->survey = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic int p54_convert_rev0(struct ieee80211_hw *dev,\n\t\t\t    struct pda_pa_curve_data *curve_data)\n{\n\tstruct p54_common *priv = dev->priv;\n\tstruct p54_pa_curve_data_sample *dst;\n\tstruct pda_pa_curve_data_sample_rev0 *src;\n\tsize_t cd_len = sizeof(*curve_data) +\n\t\t(curve_data->points_per_channel*sizeof(*dst) + 2) *\n\t\t curve_data->channels;\n\tunsigned int i, j;\n\tvoid *source, *target;\n\n\tpriv->curve_data = kmalloc(sizeof(*priv->curve_data) + cd_len,\n\t\t\t\t   GFP_KERNEL);\n\tif (!priv->curve_data)\n\t\treturn -ENOMEM;\n\n\tpriv->curve_data->entries = curve_data->channels;\n\tpriv->curve_data->entry_size = sizeof(__le16) +\n\t\tsizeof(*dst) * curve_data->points_per_channel;\n\tpriv->curve_data->offset = offsetof(struct pda_pa_curve_data, data);\n\tpriv->curve_data->len = cd_len;\n\tmemcpy(priv->curve_data->data, curve_data, sizeof(*curve_data));\n\tsource = curve_data->data;\n\ttarget = ((struct pda_pa_curve_data *) priv->curve_data->data)->data;\n\tfor (i = 0; i < curve_data->channels; i++) {\n\t\t__le16 *freq = source;\n\t\tsource += sizeof(__le16);\n\t\t*((__le16 *)target) = *freq;\n\t\ttarget += sizeof(__le16);\n\t\tfor (j = 0; j < curve_data->points_per_channel; j++) {\n\t\t\tdst = target;\n\t\t\tsrc = source;\n\n\t\t\tdst->rf_power = src->rf_power;\n\t\t\tdst->pa_detector = src->pa_detector;\n\t\t\tdst->data_64qam = src->pcv;\n\t\t\t \n#define SUB(x, y) (u8)(((x) - (y)) > (x) ? 0 : (x) - (y))\n\t\t\tdst->data_16qam = SUB(src->pcv, 12);\n\t\t\tdst->data_qpsk = SUB(dst->data_16qam, 12);\n\t\t\tdst->data_bpsk = SUB(dst->data_qpsk, 12);\n\t\t\tdst->data_barker = SUB(dst->data_bpsk, 14);\n#undef SUB\n\t\t\ttarget += sizeof(*dst);\n\t\t\tsource += sizeof(*src);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int p54_convert_rev1(struct ieee80211_hw *dev,\n\t\t\t    struct pda_pa_curve_data *curve_data)\n{\n\tstruct p54_common *priv = dev->priv;\n\tstruct p54_pa_curve_data_sample *dst;\n\tstruct pda_pa_curve_data_sample_rev1 *src;\n\tsize_t cd_len = sizeof(*curve_data) +\n\t\t(curve_data->points_per_channel*sizeof(*dst) + 2) *\n\t\t curve_data->channels;\n\tunsigned int i, j;\n\tvoid *source, *target;\n\n\tpriv->curve_data = kzalloc(cd_len + sizeof(*priv->curve_data),\n\t\t\t\t   GFP_KERNEL);\n\tif (!priv->curve_data)\n\t\treturn -ENOMEM;\n\n\tpriv->curve_data->entries = curve_data->channels;\n\tpriv->curve_data->entry_size = sizeof(__le16) +\n\t\tsizeof(*dst) * curve_data->points_per_channel;\n\tpriv->curve_data->offset = offsetof(struct pda_pa_curve_data, data);\n\tpriv->curve_data->len = cd_len;\n\tmemcpy(priv->curve_data->data, curve_data, sizeof(*curve_data));\n\tsource = curve_data->data;\n\ttarget = ((struct pda_pa_curve_data *) priv->curve_data->data)->data;\n\tfor (i = 0; i < curve_data->channels; i++) {\n\t\t__le16 *freq = source;\n\t\tsource += sizeof(__le16);\n\t\t*((__le16 *)target) = *freq;\n\t\ttarget += sizeof(__le16);\n\t\tfor (j = 0; j < curve_data->points_per_channel; j++) {\n\t\t\tmemcpy(target, source, sizeof(*src));\n\n\t\t\ttarget += sizeof(*dst);\n\t\t\tsource += sizeof(*src);\n\t\t}\n\t\tsource++;\n\t}\n\n\treturn 0;\n}\n\nstatic const char *p54_rf_chips[] = { \"INVALID-0\", \"Duette3\", \"Duette2\",\n\t\"Frisbee\", \"Xbow\", \"Longbow\", \"INVALID-6\", \"INVALID-7\" };\n\nstatic int p54_parse_rssical(struct ieee80211_hw *dev,\n\t\t\t     u8 *data, int len, u16 type)\n{\n\tstruct p54_common *priv = dev->priv;\n\tstruct p54_rssi_db_entry *entry;\n\tsize_t db_len, entries;\n\tint offset = 0, i;\n\n\tif (type != PDR_RSSI_LINEAR_APPROXIMATION_EXTENDED) {\n\t\tentries = (type == PDR_RSSI_LINEAR_APPROXIMATION) ? 1 : 2;\n\t\tif (len != sizeof(struct pda_rssi_cal_entry) * entries) {\n\t\t\twiphy_err(dev->wiphy, \"rssical size mismatch.\\n\");\n\t\t\tgoto err_data;\n\t\t}\n\t} else {\n\t\t \n\t\tif (*((__le16 *)&data[offset]) == cpu_to_le16(0))\n\t\t\toffset += 2;\n\n\t\tentries = (len - offset) /\n\t\t\tsizeof(struct pda_rssi_cal_ext_entry);\n\n\t\tif (len < offset ||\n\t\t    (len - offset) % sizeof(struct pda_rssi_cal_ext_entry) ||\n\t\t    entries == 0) {\n\t\t\twiphy_err(dev->wiphy, \"invalid rssi database.\\n\");\n\t\t\tgoto err_data;\n\t\t}\n\t}\n\n\tdb_len = sizeof(*entry) * entries;\n\tpriv->rssi_db = kzalloc(db_len + sizeof(*priv->rssi_db), GFP_KERNEL);\n\tif (!priv->rssi_db)\n\t\treturn -ENOMEM;\n\n\tpriv->rssi_db->offset = 0;\n\tpriv->rssi_db->entries = entries;\n\tpriv->rssi_db->entry_size = sizeof(*entry);\n\tpriv->rssi_db->len = db_len;\n\n\tentry = (void *)((unsigned long)priv->rssi_db->data + priv->rssi_db->offset);\n\tif (type == PDR_RSSI_LINEAR_APPROXIMATION_EXTENDED) {\n\t\tstruct pda_rssi_cal_ext_entry *cal = (void *) &data[offset];\n\n\t\tfor (i = 0; i < entries; i++) {\n\t\t\tentry[i].freq = le16_to_cpu(cal[i].freq);\n\t\t\tentry[i].mul = (s16) le16_to_cpu(cal[i].mul);\n\t\t\tentry[i].add = (s16) le16_to_cpu(cal[i].add);\n\t\t}\n\t} else {\n\t\tstruct pda_rssi_cal_entry *cal = (void *) &data[offset];\n\n\t\tfor (i = 0; i < entries; i++) {\n\t\t\tu16 freq = 0;\n\t\t\tswitch (i) {\n\t\t\tcase NL80211_BAND_2GHZ:\n\t\t\t\tfreq = 2437;\n\t\t\t\tbreak;\n\t\t\tcase NL80211_BAND_5GHZ:\n\t\t\t\tfreq = 5240;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tentry[i].freq = freq;\n\t\t\tentry[i].mul = (s16) le16_to_cpu(cal[i].mul);\n\t\t\tentry[i].add = (s16) le16_to_cpu(cal[i].add);\n\t\t}\n\t}\n\n\t \n\tsort(entry, entries, sizeof(*entry), p54_compare_rssichan, NULL);\n\treturn 0;\n\nerr_data:\n\twiphy_err(dev->wiphy,\n\t\t  \"rssi calibration data packing type:(%x) len:%d.\\n\",\n\t\t  type, len);\n\n\tprint_hex_dump_bytes(\"rssical:\", DUMP_PREFIX_NONE, data, len);\n\n\twiphy_err(dev->wiphy, \"please report this issue.\\n\");\n\treturn -EINVAL;\n}\n\nstruct p54_rssi_db_entry *p54_rssi_find(struct p54_common *priv, const u16 freq)\n{\n\tstruct p54_rssi_db_entry *entry;\n\tint i, found = -1;\n\n\tif (!priv->rssi_db)\n\t\treturn &p54_rssi_default;\n\n\tentry = (void *)(priv->rssi_db->data + priv->rssi_db->offset);\n\tfor (i = 0; i < priv->rssi_db->entries; i++) {\n\t\tif (!same_band(freq, entry[i].freq))\n\t\t\tcontinue;\n\n\t\tif (found == -1) {\n\t\t\tfound = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (abs(freq - entry[i].freq) <\n\t\t    abs(freq - entry[found].freq)) {\n\t\t\tfound = i;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found < 0 ? &p54_rssi_default : &entry[found];\n}\n\nstatic void p54_parse_default_country(struct ieee80211_hw *dev,\n\t\t\t\t      void *data, int len)\n{\n\tstruct pda_country *country;\n\n\tif (len != sizeof(*country)) {\n\t\twiphy_err(dev->wiphy,\n\t\t\t  \"found possible invalid default country eeprom entry. (entry size: %d)\\n\",\n\t\t\t  len);\n\n\t\tprint_hex_dump_bytes(\"country:\", DUMP_PREFIX_NONE,\n\t\t\t\t     data, len);\n\n\t\twiphy_err(dev->wiphy, \"please report this issue.\\n\");\n\t\treturn;\n\t}\n\n\tcountry = (struct pda_country *) data;\n\tif (country->flags == PDR_COUNTRY_CERT_CODE_PSEUDO)\n\t\tregulatory_hint(dev->wiphy, country->alpha2);\n\telse {\n\t\t \n\t}\n}\n\nstatic int p54_convert_output_limits(struct ieee80211_hw *dev,\n\t\t\t\t     u8 *data, size_t len)\n{\n\tstruct p54_common *priv = dev->priv;\n\n\tif (len < 2)\n\t\treturn -EINVAL;\n\n\tif (data[0] != 0) {\n\t\twiphy_err(dev->wiphy, \"unknown output power db revision:%x\\n\",\n\t\t\t  data[0]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (2 + data[1] * sizeof(struct pda_channel_output_limit) > len)\n\t\treturn -EINVAL;\n\n\tpriv->output_limit = kmalloc(data[1] *\n\t\tsizeof(struct pda_channel_output_limit) +\n\t\tsizeof(*priv->output_limit), GFP_KERNEL);\n\n\tif (!priv->output_limit)\n\t\treturn -ENOMEM;\n\n\tpriv->output_limit->offset = 0;\n\tpriv->output_limit->entries = data[1];\n\tpriv->output_limit->entry_size =\n\t\tsizeof(struct pda_channel_output_limit);\n\tpriv->output_limit->len = priv->output_limit->entry_size *\n\t\t\t\t  priv->output_limit->entries +\n\t\t\t\t  priv->output_limit->offset;\n\n\tmemcpy(priv->output_limit->data, &data[2],\n\t       data[1] * sizeof(struct pda_channel_output_limit));\n\n\treturn 0;\n}\n\nstatic struct p54_cal_database *p54_convert_db(struct pda_custom_wrapper *src,\n\t\t\t\t\t       size_t total_len)\n{\n\tstruct p54_cal_database *dst;\n\tsize_t payload_len, entries, entry_size, offset;\n\n\tpayload_len = le16_to_cpu(src->len);\n\tentries = le16_to_cpu(src->entries);\n\tentry_size = le16_to_cpu(src->entry_size);\n\toffset = le16_to_cpu(src->offset);\n\tif (((entries * entry_size + offset) != payload_len) ||\n\t     (payload_len + sizeof(*src) != total_len))\n\t\treturn NULL;\n\n\tdst = kmalloc(sizeof(*dst) + payload_len, GFP_KERNEL);\n\tif (!dst)\n\t\treturn NULL;\n\n\tdst->entries = entries;\n\tdst->entry_size = entry_size;\n\tdst->offset = offset;\n\tdst->len = payload_len;\n\n\tmemcpy(dst->data, src->data, payload_len);\n\treturn dst;\n}\n\nint p54_parse_eeprom(struct ieee80211_hw *dev, void *eeprom, int len)\n{\n\tstruct p54_common *priv = dev->priv;\n\tstruct eeprom_pda_wrap *wrap;\n\tstruct pda_entry *entry;\n\tunsigned int data_len, entry_len;\n\tvoid *tmp;\n\tint err;\n\tu8 *end = (u8 *)eeprom + len;\n\tu16 synth = 0;\n\tu16 crc16 = ~0;\n\n\twrap = (struct eeprom_pda_wrap *) eeprom;\n\tentry = (void *)wrap->data + le16_to_cpu(wrap->len);\n\n\t \n\twhile ((u8 *)entry <= end - sizeof(*entry)) {\n\t\tentry_len = le16_to_cpu(entry->len);\n\t\tdata_len = ((entry_len - 1) << 1);\n\n\t\t \n\t\tif ((u8 *)entry + sizeof(*entry) + data_len > end)\n\t\t\tbreak;\n\n\t\tswitch (le16_to_cpu(entry->code)) {\n\t\tcase PDR_MAC_ADDRESS:\n\t\t\tif (data_len != ETH_ALEN)\n\t\t\t\tbreak;\n\t\t\tSET_IEEE80211_PERM_ADDR(dev, entry->data);\n\t\t\tbreak;\n\t\tcase PDR_PRISM_PA_CAL_OUTPUT_POWER_LIMITS:\n\t\t\tif (priv->output_limit)\n\t\t\t\tbreak;\n\t\t\terr = p54_convert_output_limits(dev, entry->data,\n\t\t\t\t\t\t\tdata_len);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\tcase PDR_PRISM_PA_CAL_CURVE_DATA: {\n\t\t\tstruct pda_pa_curve_data *curve_data =\n\t\t\t\t(struct pda_pa_curve_data *)entry->data;\n\t\t\tif (data_len < sizeof(*curve_data)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tswitch (curve_data->cal_method_rev) {\n\t\t\tcase 0:\n\t\t\t\terr = p54_convert_rev0(dev, curve_data);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\terr = p54_convert_rev1(dev, curve_data);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\twiphy_err(dev->wiphy,\n\t\t\t\t\t  \"unknown curve data revision %d\\n\",\n\t\t\t\t\t  curve_data->cal_method_rev);\n\t\t\t\terr = -ENODEV;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PDR_PRISM_ZIF_TX_IQ_CALIBRATION:\n\t\t\tpriv->iq_autocal = kmemdup(entry->data, data_len,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\tif (!priv->iq_autocal) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tpriv->iq_autocal_len = data_len / sizeof(struct pda_iq_autocal_entry);\n\t\t\tbreak;\n\t\tcase PDR_DEFAULT_COUNTRY:\n\t\t\tp54_parse_default_country(dev, entry->data, data_len);\n\t\t\tbreak;\n\t\tcase PDR_INTERFACE_LIST:\n\t\t\ttmp = entry->data;\n\t\t\twhile ((u8 *)tmp < entry->data + data_len) {\n\t\t\t\tstruct exp_if *exp_if = tmp;\n\t\t\t\tif (exp_if->if_id == cpu_to_le16(IF_ID_ISL39000))\n\t\t\t\t\tsynth = le16_to_cpu(exp_if->variant);\n\t\t\t\ttmp += sizeof(*exp_if);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PDR_HARDWARE_PLATFORM_COMPONENT_ID:\n\t\t\tif (data_len < 2)\n\t\t\t\tbreak;\n\t\t\tpriv->version = *(u8 *)(entry->data + 1);\n\t\t\tbreak;\n\t\tcase PDR_RSSI_LINEAR_APPROXIMATION:\n\t\tcase PDR_RSSI_LINEAR_APPROXIMATION_DUAL_BAND:\n\t\tcase PDR_RSSI_LINEAR_APPROXIMATION_EXTENDED:\n\t\t\terr = p54_parse_rssical(dev, entry->data, data_len,\n\t\t\t\t\t\tle16_to_cpu(entry->code));\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\tcase PDR_RSSI_LINEAR_APPROXIMATION_CUSTOMV2: {\n\t\t\tstruct pda_custom_wrapper *pda = (void *) entry->data;\n\t\t\t__le16 *src;\n\t\t\tu16 *dst;\n\t\t\tint i;\n\n\t\t\tif (priv->rssi_db || data_len < sizeof(*pda))\n\t\t\t\tbreak;\n\n\t\t\tpriv->rssi_db = p54_convert_db(pda, data_len);\n\t\t\tif (!priv->rssi_db)\n\t\t\t\tbreak;\n\n\t\t\tsrc = (void *) priv->rssi_db->data;\n\t\t\tdst = (void *) priv->rssi_db->data;\n\n\t\t\tfor (i = 0; i < priv->rssi_db->entries; i++)\n\t\t\t\t*(dst++) = (s16) le16_to_cpu(*(src++));\n\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PDR_PRISM_PA_CAL_OUTPUT_POWER_LIMITS_CUSTOM: {\n\t\t\tstruct pda_custom_wrapper *pda = (void *) entry->data;\n\t\t\tif (priv->output_limit || data_len < sizeof(*pda))\n\t\t\t\tbreak;\n\t\t\tpriv->output_limit = p54_convert_db(pda, data_len);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PDR_PRISM_PA_CAL_CURVE_DATA_CUSTOM: {\n\t\t\tstruct pda_custom_wrapper *pda = (void *) entry->data;\n\t\t\tif (priv->curve_data || data_len < sizeof(*pda))\n\t\t\t\tbreak;\n\t\t\tpriv->curve_data = p54_convert_db(pda, data_len);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PDR_END:\n\t\t\tcrc16 = ~crc_ccitt(crc16, (u8 *) entry, sizeof(*entry));\n\t\t\tif (crc16 != le16_to_cpup((__le16 *)entry->data)) {\n\t\t\t\twiphy_err(dev->wiphy, \"eeprom failed checksum \"\n\t\t\t\t\t \"test!\\n\");\n\t\t\t\terr = -ENOMSG;\n\t\t\t\tgoto err;\n\t\t\t} else {\n\t\t\t\tgoto good_eeprom;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tcrc16 = crc_ccitt(crc16, (u8 *)entry, (entry_len + 1) * 2);\n\t\tentry = (void *)entry + (entry_len + 1) * 2;\n\t}\n\n\twiphy_err(dev->wiphy, \"unexpected end of eeprom data.\\n\");\n\terr = -ENODATA;\n\tgoto err;\n\ngood_eeprom:\n\tif (!synth || !priv->iq_autocal || !priv->output_limit ||\n\t    !priv->curve_data) {\n\t\twiphy_err(dev->wiphy,\n\t\t\t  \"not all required entries found in eeprom!\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tpriv->rxhw = synth & PDR_SYNTH_FRONTEND_MASK;\n\n\terr = p54_generate_channel_lists(dev);\n\tif (err)\n\t\tgoto err;\n\n\tif (priv->rxhw == PDR_SYNTH_FRONTEND_XBOW)\n\t\tp54_init_xbow_synth(priv);\n\tif (!(synth & PDR_SYNTH_24_GHZ_DISABLED))\n\t\tdev->wiphy->bands[NL80211_BAND_2GHZ] =\n\t\t\tpriv->band_table[NL80211_BAND_2GHZ];\n\tif (!(synth & PDR_SYNTH_5_GHZ_DISABLED))\n\t\tdev->wiphy->bands[NL80211_BAND_5GHZ] =\n\t\t\tpriv->band_table[NL80211_BAND_5GHZ];\n\tif ((synth & PDR_SYNTH_RX_DIV_MASK) == PDR_SYNTH_RX_DIV_SUPPORTED)\n\t\tpriv->rx_diversity_mask = 3;\n\tif ((synth & PDR_SYNTH_TX_DIV_MASK) == PDR_SYNTH_TX_DIV_SUPPORTED)\n\t\tpriv->tx_diversity_mask = 3;\n\n\tif (!is_valid_ether_addr(dev->wiphy->perm_addr)) {\n\t\tu8 perm_addr[ETH_ALEN];\n\n\t\twiphy_warn(dev->wiphy,\n\t\t\t   \"Invalid hwaddr! Using randomly generated MAC addr\\n\");\n\t\teth_random_addr(perm_addr);\n\t\tSET_IEEE80211_PERM_ADDR(dev, perm_addr);\n\t}\n\n\tpriv->cur_rssi = &p54_rssi_default;\n\n\twiphy_info(dev->wiphy, \"hwaddr %pM, MAC:isl38%02x RF:%s\\n\",\n\t\t   dev->wiphy->perm_addr, priv->version,\n\t\t   p54_rf_chips[priv->rxhw]);\n\n\treturn 0;\n\nerr:\n\tkfree(priv->iq_autocal);\n\tkfree(priv->output_limit);\n\tkfree(priv->curve_data);\n\tkfree(priv->rssi_db);\n\tkfree(priv->survey);\n\tpriv->iq_autocal = NULL;\n\tpriv->output_limit = NULL;\n\tpriv->curve_data = NULL;\n\tpriv->rssi_db = NULL;\n\tpriv->survey = NULL;\n\n\twiphy_err(dev->wiphy, \"eeprom parse failed!\\n\");\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(p54_parse_eeprom);\n\nint p54_read_eeprom(struct ieee80211_hw *dev)\n{\n\tstruct p54_common *priv = dev->priv;\n\tsize_t eeprom_size = 0x2020, offset = 0, blocksize, maxblocksize;\n\tint ret = -ENOMEM;\n\tvoid *eeprom;\n\n\tmaxblocksize = EEPROM_READBACK_LEN;\n\tif (priv->fw_var >= 0x509)\n\t\tmaxblocksize -= 0xc;\n\telse\n\t\tmaxblocksize -= 0x4;\n\n\teeprom = kzalloc(eeprom_size, GFP_KERNEL);\n\tif (unlikely(!eeprom))\n\t\tgoto free;\n\n\twhile (eeprom_size) {\n\t\tblocksize = min(eeprom_size, maxblocksize);\n\t\tret = p54_download_eeprom(priv, eeprom + offset,\n\t\t\t\t\t  offset, blocksize);\n\t\tif (unlikely(ret))\n\t\t\tgoto free;\n\n\t\toffset += blocksize;\n\t\teeprom_size -= blocksize;\n\t}\n\n\tret = p54_parse_eeprom(dev, eeprom, offset);\nfree:\n\tkfree(eeprom);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(p54_read_eeprom);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}