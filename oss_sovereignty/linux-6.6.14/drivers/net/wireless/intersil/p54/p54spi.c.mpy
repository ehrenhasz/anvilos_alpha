{
  "module_name": "p54spi.c",
  "hash_id": "b99e5166c3a2b68cd70b562be1ca8172e9939cc9cf91c42be92da204ac8d6cc8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/p54/p54spi.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/firmware.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/spi/spi.h>\n#include <linux/etherdevice.h>\n#include <linux/gpio.h>\n#include <linux/slab.h>\n\n#include \"p54spi.h\"\n#include \"p54.h\"\n\n#include \"lmac.h\"\n\n#ifdef CONFIG_P54_SPI_DEFAULT_EEPROM\n#include \"p54spi_eeprom.h\"\n#endif  \n\nMODULE_FIRMWARE(\"3826.arm\");\nMODULE_FIRMWARE(\"3826.eeprom\");\n\n \n\nstatic int p54spi_gpio_power = 97;\nmodule_param(p54spi_gpio_power, int, 0444);\nMODULE_PARM_DESC(p54spi_gpio_power, \"gpio number for power line\");\n\nstatic int p54spi_gpio_irq = 87;\nmodule_param(p54spi_gpio_irq, int, 0444);\nMODULE_PARM_DESC(p54spi_gpio_irq, \"gpio number for irq line\");\n\nstatic void p54spi_spi_read(struct p54s_priv *priv, u8 address,\n\t\t\t      void *buf, size_t len)\n{\n\tstruct spi_transfer t[2];\n\tstruct spi_message m;\n\t__le16 addr;\n\n\t \n\taddr = cpu_to_le16(address << 8 | SPI_ADRS_READ_BIT_15);\n\n\tspi_message_init(&m);\n\tmemset(t, 0, sizeof(t));\n\n\tt[0].tx_buf = &addr;\n\tt[0].len = sizeof(addr);\n\tspi_message_add_tail(&t[0], &m);\n\n\tt[1].rx_buf = buf;\n\tt[1].len = len;\n\tspi_message_add_tail(&t[1], &m);\n\n\tspi_sync(priv->spi, &m);\n}\n\n\nstatic void p54spi_spi_write(struct p54s_priv *priv, u8 address,\n\t\t\t     const void *buf, size_t len)\n{\n\tstruct spi_transfer t[3];\n\tstruct spi_message m;\n\t__le16 addr;\n\n\t \n\taddr = cpu_to_le16(address << 8);\n\n\tspi_message_init(&m);\n\tmemset(t, 0, sizeof(t));\n\n\tt[0].tx_buf = &addr;\n\tt[0].len = sizeof(addr);\n\tspi_message_add_tail(&t[0], &m);\n\n\tt[1].tx_buf = buf;\n\tt[1].len = len & ~1;\n\tspi_message_add_tail(&t[1], &m);\n\n\tif (len % 2) {\n\t\t__le16 last_word;\n\t\tlast_word = cpu_to_le16(((u8 *)buf)[len - 1]);\n\n\t\tt[2].tx_buf = &last_word;\n\t\tt[2].len = sizeof(last_word);\n\t\tspi_message_add_tail(&t[2], &m);\n\t}\n\n\tspi_sync(priv->spi, &m);\n}\n\nstatic u32 p54spi_read32(struct p54s_priv *priv, u8 addr)\n{\n\t__le32 val;\n\n\tp54spi_spi_read(priv, addr, &val, sizeof(val));\n\n\treturn le32_to_cpu(val);\n}\n\nstatic inline void p54spi_write16(struct p54s_priv *priv, u8 addr, __le16 val)\n{\n\tp54spi_spi_write(priv, addr, &val, sizeof(val));\n}\n\nstatic inline void p54spi_write32(struct p54s_priv *priv, u8 addr, __le32 val)\n{\n\tp54spi_spi_write(priv, addr, &val, sizeof(val));\n}\n\nstatic int p54spi_wait_bit(struct p54s_priv *priv, u16 reg, u32 bits)\n{\n\tint i;\n\n\tfor (i = 0; i < 2000; i++) {\n\t\tu32 buffer = p54spi_read32(priv, reg);\n\t\tif ((buffer & bits) == bits)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int p54spi_spi_write_dma(struct p54s_priv *priv, __le32 base,\n\t\t\t\tconst void *buf, size_t len)\n{\n\tif (!p54spi_wait_bit(priv, SPI_ADRS_DMA_WRITE_CTRL, HOST_ALLOWED)) {\n\t\tdev_err(&priv->spi->dev, \"spi_write_dma not allowed \"\n\t\t\t\"to DMA write.\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tp54spi_write16(priv, SPI_ADRS_DMA_WRITE_CTRL,\n\t\t       cpu_to_le16(SPI_DMA_WRITE_CTRL_ENABLE));\n\n\tp54spi_write16(priv, SPI_ADRS_DMA_WRITE_LEN, cpu_to_le16(len));\n\tp54spi_write32(priv, SPI_ADRS_DMA_WRITE_BASE, base);\n\tp54spi_spi_write(priv, SPI_ADRS_DMA_DATA, buf, len);\n\treturn 0;\n}\n\nstatic int p54spi_request_firmware(struct ieee80211_hw *dev)\n{\n\tstruct p54s_priv *priv = dev->priv;\n\tint ret;\n\n\t \n\tret = request_firmware(&priv->firmware, \"3826.arm\", &priv->spi->dev);\n\n\tif (ret < 0) {\n\t\tdev_err(&priv->spi->dev, \"request_firmware() failed: %d\", ret);\n\t\treturn ret;\n\t}\n\n\tret = p54_parse_firmware(dev, priv->firmware);\n\tif (ret) {\n\t\t \n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int p54spi_request_eeprom(struct ieee80211_hw *dev)\n{\n\tstruct p54s_priv *priv = dev->priv;\n\tconst struct firmware *eeprom;\n\tint ret;\n\n\t \n\n\tret = request_firmware_direct(&eeprom, \"3826.eeprom\", &priv->spi->dev);\n\tif (ret < 0) {\n#ifdef CONFIG_P54_SPI_DEFAULT_EEPROM\n\t\tdev_info(&priv->spi->dev, \"loading default eeprom...\\n\");\n\t\tret = p54_parse_eeprom(dev, (void *) p54spi_eeprom,\n\t\t\t\t       sizeof(p54spi_eeprom));\n#else\n\t\tdev_err(&priv->spi->dev, \"Failed to request user eeprom\\n\");\n#endif  \n\t} else {\n\t\tdev_info(&priv->spi->dev, \"loading user eeprom...\\n\");\n\t\tret = p54_parse_eeprom(dev, (void *) eeprom->data,\n\t\t\t\t       (int)eeprom->size);\n\t\trelease_firmware(eeprom);\n\t}\n\treturn ret;\n}\n\nstatic int p54spi_upload_firmware(struct ieee80211_hw *dev)\n{\n\tstruct p54s_priv *priv = dev->priv;\n\tunsigned long fw_len, _fw_len;\n\tunsigned int offset = 0;\n\tint err = 0;\n\tu8 *fw;\n\n\tfw_len = priv->firmware->size;\n\tfw = kmemdup(priv->firmware->data, fw_len, GFP_KERNEL);\n\tif (!fw)\n\t\treturn -ENOMEM;\n\n\t \n\tp54spi_write16(priv, SPI_ADRS_DEV_CTRL_STAT, cpu_to_le16(\n\t\t       SPI_CTRL_STAT_HOST_OVERRIDE | SPI_CTRL_STAT_HOST_RESET |\n\t\t       SPI_CTRL_STAT_START_HALTED));\n\n\tmsleep(TARGET_BOOT_SLEEP);\n\n\tp54spi_write16(priv, SPI_ADRS_DEV_CTRL_STAT, cpu_to_le16(\n\t\t       SPI_CTRL_STAT_HOST_OVERRIDE |\n\t\t       SPI_CTRL_STAT_START_HALTED));\n\n\tmsleep(TARGET_BOOT_SLEEP);\n\n\twhile (fw_len > 0) {\n\t\t_fw_len = min_t(long, fw_len, SPI_MAX_PACKET_SIZE);\n\n\t\terr = p54spi_spi_write_dma(priv, cpu_to_le32(\n\t\t\t\t\t   ISL38XX_DEV_FIRMWARE_ADDR + offset),\n\t\t\t\t\t   (fw + offset), _fw_len);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\tfw_len -= _fw_len;\n\t\toffset += _fw_len;\n\t}\n\n\tBUG_ON(fw_len != 0);\n\n\t \n\tp54spi_write32(priv, SPI_ADRS_HOST_INT_EN,\n\t\t       cpu_to_le32(SPI_HOST_INTS_DEFAULT));\n\n\t \n\tp54spi_write16(priv, SPI_ADRS_DEV_CTRL_STAT, cpu_to_le16(\n\t\t       SPI_CTRL_STAT_HOST_OVERRIDE | SPI_CTRL_STAT_HOST_RESET |\n\t\t       SPI_CTRL_STAT_RAM_BOOT));\n\n\tmsleep(TARGET_BOOT_SLEEP);\n\n\tp54spi_write16(priv, SPI_ADRS_DEV_CTRL_STAT, cpu_to_le16(\n\t\t       SPI_CTRL_STAT_HOST_OVERRIDE | SPI_CTRL_STAT_RAM_BOOT));\n\tmsleep(TARGET_BOOT_SLEEP);\n\nout:\n\tkfree(fw);\n\treturn err;\n}\n\nstatic void p54spi_power_off(struct p54s_priv *priv)\n{\n\tdisable_irq(gpio_to_irq(p54spi_gpio_irq));\n\tgpio_set_value(p54spi_gpio_power, 0);\n}\n\nstatic void p54spi_power_on(struct p54s_priv *priv)\n{\n\tgpio_set_value(p54spi_gpio_power, 1);\n\tenable_irq(gpio_to_irq(p54spi_gpio_irq));\n\n\t \n\tmsleep(10);\n}\n\nstatic inline void p54spi_int_ack(struct p54s_priv *priv, u32 val)\n{\n\tp54spi_write32(priv, SPI_ADRS_HOST_INT_ACK, cpu_to_le32(val));\n}\n\nstatic int p54spi_wakeup(struct p54s_priv *priv)\n{\n\t \n\tp54spi_write32(priv, SPI_ADRS_ARM_INTERRUPTS,\n\t\t       cpu_to_le32(SPI_TARGET_INT_WAKEUP));\n\n\t \n\tif (!p54spi_wait_bit(priv, SPI_ADRS_HOST_INTERRUPTS,\n\t\t\t     SPI_HOST_INT_READY)) {\n\t\tdev_err(&priv->spi->dev, \"INT_READY timeout\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tp54spi_int_ack(priv, SPI_HOST_INT_READY);\n\treturn 0;\n}\n\nstatic inline void p54spi_sleep(struct p54s_priv *priv)\n{\n\tp54spi_write32(priv, SPI_ADRS_ARM_INTERRUPTS,\n\t\t       cpu_to_le32(SPI_TARGET_INT_SLEEP));\n}\n\nstatic void p54spi_int_ready(struct p54s_priv *priv)\n{\n\tp54spi_write32(priv, SPI_ADRS_HOST_INT_EN, cpu_to_le32(\n\t\t       SPI_HOST_INT_UPDATE | SPI_HOST_INT_SW_UPDATE));\n\n\tswitch (priv->fw_state) {\n\tcase FW_STATE_BOOTING:\n\t\tpriv->fw_state = FW_STATE_READY;\n\t\tcomplete(&priv->fw_comp);\n\t\tbreak;\n\tcase FW_STATE_RESETTING:\n\t\tpriv->fw_state = FW_STATE_READY;\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int p54spi_rx(struct p54s_priv *priv)\n{\n\tstruct sk_buff *skb;\n\tu16 len;\n\tu16 rx_head[2];\n#define READAHEAD_SZ (sizeof(rx_head)-sizeof(u16))\n\n\tif (p54spi_wakeup(priv) < 0)\n\t\treturn -EBUSY;\n\n\t \n\tp54spi_spi_read(priv, SPI_ADRS_DMA_DATA, rx_head, sizeof(rx_head));\n\tlen = rx_head[0];\n\n\tif (len == 0) {\n\t\tp54spi_sleep(priv);\n\t\tdev_err(&priv->spi->dev, \"rx request of zero bytes\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tskb = dev_alloc_skb(len + 4);\n\tif (!skb) {\n\t\tp54spi_sleep(priv);\n\t\tdev_err(&priv->spi->dev, \"could not alloc skb\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (len <= READAHEAD_SZ) {\n\t\tskb_put_data(skb, rx_head + 1, len);\n\t} else {\n\t\tskb_put_data(skb, rx_head + 1, READAHEAD_SZ);\n\t\tp54spi_spi_read(priv, SPI_ADRS_DMA_DATA,\n\t\t\t\tskb_put(skb, len - READAHEAD_SZ),\n\t\t\t\tlen - READAHEAD_SZ);\n\t}\n\tp54spi_sleep(priv);\n\t \n\tskb_put(skb, 4);\n\n\tif (p54_rx(priv->hw, skb) == 0)\n\t\tdev_kfree_skb(skb);\n\n\treturn 0;\n}\n\n\nstatic irqreturn_t p54spi_interrupt(int irq, void *config)\n{\n\tstruct spi_device *spi = config;\n\tstruct p54s_priv *priv = spi_get_drvdata(spi);\n\n\tieee80211_queue_work(priv->hw, &priv->work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int p54spi_tx_frame(struct p54s_priv *priv, struct sk_buff *skb)\n{\n\tstruct p54_hdr *hdr = (struct p54_hdr *) skb->data;\n\tint ret = 0;\n\n\tif (p54spi_wakeup(priv) < 0)\n\t\treturn -EBUSY;\n\n\tret = p54spi_spi_write_dma(priv, hdr->req_id, skb->data, skb->len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!p54spi_wait_bit(priv, SPI_ADRS_HOST_INTERRUPTS,\n\t\t\t     SPI_HOST_INT_WR_READY)) {\n\t\tdev_err(&priv->spi->dev, \"WR_READY timeout\\n\");\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tp54spi_int_ack(priv, SPI_HOST_INT_WR_READY);\n\n\tif (FREE_AFTER_TX(skb))\n\t\tp54_free_skb(priv->hw, skb);\nout:\n\tp54spi_sleep(priv);\n\treturn ret;\n}\n\nstatic int p54spi_wq_tx(struct p54s_priv *priv)\n{\n\tstruct p54s_tx_info *entry;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_tx_info *info;\n\tstruct p54_tx_info *minfo;\n\tstruct p54s_tx_info *dinfo;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&priv->tx_lock, flags);\n\n\twhile (!list_empty(&priv->tx_pending)) {\n\t\tentry = list_entry(priv->tx_pending.next,\n\t\t\t\t   struct p54s_tx_info, tx_list);\n\n\t\tlist_del_init(&entry->tx_list);\n\n\t\tspin_unlock_irqrestore(&priv->tx_lock, flags);\n\n\t\tdinfo = container_of((void *) entry, struct p54s_tx_info,\n\t\t\t\t     tx_list);\n\t\tminfo = container_of((void *) dinfo, struct p54_tx_info,\n\t\t\t\t     data);\n\t\tinfo = container_of((void *) minfo, struct ieee80211_tx_info,\n\t\t\t\t    rate_driver_data);\n\t\tskb = container_of((void *) info, struct sk_buff, cb);\n\n\t\tret = p54spi_tx_frame(priv, skb);\n\n\t\tif (ret < 0) {\n\t\t\tp54_free_skb(priv->hw, skb);\n\t\t\treturn ret;\n\t\t}\n\n\t\tspin_lock_irqsave(&priv->tx_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&priv->tx_lock, flags);\n\treturn ret;\n}\n\nstatic void p54spi_op_tx(struct ieee80211_hw *dev, struct sk_buff *skb)\n{\n\tstruct p54s_priv *priv = dev->priv;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct p54_tx_info *mi = (struct p54_tx_info *) info->rate_driver_data;\n\tstruct p54s_tx_info *di = (struct p54s_tx_info *) mi->data;\n\tunsigned long flags;\n\n\tBUILD_BUG_ON(sizeof(*di) > sizeof((mi->data)));\n\n\tspin_lock_irqsave(&priv->tx_lock, flags);\n\tlist_add_tail(&di->tx_list, &priv->tx_pending);\n\tspin_unlock_irqrestore(&priv->tx_lock, flags);\n\n\tieee80211_queue_work(priv->hw, &priv->work);\n}\n\nstatic void p54spi_work(struct work_struct *work)\n{\n\tstruct p54s_priv *priv = container_of(work, struct p54s_priv, work);\n\tu32 ints;\n\tint ret;\n\n\tmutex_lock(&priv->mutex);\n\n\tif (priv->fw_state == FW_STATE_OFF)\n\t\tgoto out;\n\n\tints = p54spi_read32(priv, SPI_ADRS_HOST_INTERRUPTS);\n\n\tif (ints & SPI_HOST_INT_READY) {\n\t\tp54spi_int_ready(priv);\n\t\tp54spi_int_ack(priv, SPI_HOST_INT_READY);\n\t}\n\n\tif (priv->fw_state != FW_STATE_READY)\n\t\tgoto out;\n\n\tif (ints & SPI_HOST_INT_UPDATE) {\n\t\tp54spi_int_ack(priv, SPI_HOST_INT_UPDATE);\n\t\tret = p54spi_rx(priv);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tif (ints & SPI_HOST_INT_SW_UPDATE) {\n\t\tp54spi_int_ack(priv, SPI_HOST_INT_SW_UPDATE);\n\t\tret = p54spi_rx(priv);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = p54spi_wq_tx(priv);\nout:\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic int p54spi_op_start(struct ieee80211_hw *dev)\n{\n\tstruct p54s_priv *priv = dev->priv;\n\tunsigned long timeout;\n\tint ret = 0;\n\n\tif (mutex_lock_interruptible(&priv->mutex)) {\n\t\tret = -EINTR;\n\t\tgoto out;\n\t}\n\n\tpriv->fw_state = FW_STATE_BOOTING;\n\n\tp54spi_power_on(priv);\n\n\tret = p54spi_upload_firmware(dev);\n\tif (ret < 0) {\n\t\tp54spi_power_off(priv);\n\t\tgoto out_unlock;\n\t}\n\n\tmutex_unlock(&priv->mutex);\n\n\ttimeout = msecs_to_jiffies(2000);\n\ttimeout = wait_for_completion_interruptible_timeout(&priv->fw_comp,\n\t\t\t\t\t\t\t    timeout);\n\tif (!timeout) {\n\t\tdev_err(&priv->spi->dev, \"firmware boot failed\");\n\t\tp54spi_power_off(priv);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (mutex_lock_interruptible(&priv->mutex)) {\n\t\tret = -EINTR;\n\t\tp54spi_power_off(priv);\n\t\tgoto out;\n\t}\n\n\tWARN_ON(priv->fw_state != FW_STATE_READY);\n\nout_unlock:\n\tmutex_unlock(&priv->mutex);\n\nout:\n\treturn ret;\n}\n\nstatic void p54spi_op_stop(struct ieee80211_hw *dev)\n{\n\tstruct p54s_priv *priv = dev->priv;\n\tunsigned long flags;\n\n\tmutex_lock(&priv->mutex);\n\tWARN_ON(priv->fw_state != FW_STATE_READY);\n\n\tp54spi_power_off(priv);\n\tspin_lock_irqsave(&priv->tx_lock, flags);\n\tINIT_LIST_HEAD(&priv->tx_pending);\n\tspin_unlock_irqrestore(&priv->tx_lock, flags);\n\n\tpriv->fw_state = FW_STATE_OFF;\n\tmutex_unlock(&priv->mutex);\n\n\tcancel_work_sync(&priv->work);\n}\n\nstatic int p54spi_probe(struct spi_device *spi)\n{\n\tstruct p54s_priv *priv = NULL;\n\tstruct ieee80211_hw *hw;\n\tint ret = -EINVAL;\n\n\thw = p54_init_common(sizeof(*priv));\n\tif (!hw) {\n\t\tdev_err(&spi->dev, \"could not alloc ieee80211_hw\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv = hw->priv;\n\tpriv->hw = hw;\n\tspi_set_drvdata(spi, priv);\n\tpriv->spi = spi;\n\n\tspi->bits_per_word = 16;\n\tspi->max_speed_hz = 24000000;\n\n\tret = spi_setup(spi);\n\tif (ret < 0) {\n\t\tdev_err(&priv->spi->dev, \"spi_setup failed\");\n\t\tgoto err_free;\n\t}\n\n\tret = gpio_request(p54spi_gpio_power, \"p54spi power\");\n\tif (ret < 0) {\n\t\tdev_err(&priv->spi->dev, \"power GPIO request failed: %d\", ret);\n\t\tgoto err_free;\n\t}\n\n\tret = gpio_request(p54spi_gpio_irq, \"p54spi irq\");\n\tif (ret < 0) {\n\t\tdev_err(&priv->spi->dev, \"irq GPIO request failed: %d\", ret);\n\t\tgoto err_free_gpio_power;\n\t}\n\n\tgpio_direction_output(p54spi_gpio_power, 0);\n\tgpio_direction_input(p54spi_gpio_irq);\n\n\tret = request_irq(gpio_to_irq(p54spi_gpio_irq),\n\t\t\t  p54spi_interrupt, 0, \"p54spi\",\n\t\t\t  priv->spi);\n\tif (ret < 0) {\n\t\tdev_err(&priv->spi->dev, \"request_irq() failed\");\n\t\tgoto err_free_gpio_irq;\n\t}\n\n\tirq_set_irq_type(gpio_to_irq(p54spi_gpio_irq), IRQ_TYPE_EDGE_RISING);\n\n\tdisable_irq(gpio_to_irq(p54spi_gpio_irq));\n\n\tINIT_WORK(&priv->work, p54spi_work);\n\tinit_completion(&priv->fw_comp);\n\tINIT_LIST_HEAD(&priv->tx_pending);\n\tmutex_init(&priv->mutex);\n\tspin_lock_init(&priv->tx_lock);\n\tSET_IEEE80211_DEV(hw, &spi->dev);\n\tpriv->common.open = p54spi_op_start;\n\tpriv->common.stop = p54spi_op_stop;\n\tpriv->common.tx = p54spi_op_tx;\n\n\tret = p54spi_request_firmware(hw);\n\tif (ret < 0)\n\t\tgoto err_free_common;\n\n\tret = p54spi_request_eeprom(hw);\n\tif (ret)\n\t\tgoto err_free_common;\n\n\tret = p54_register_common(hw, &priv->spi->dev);\n\tif (ret)\n\t\tgoto err_free_common;\n\n\treturn 0;\n\nerr_free_common:\n\trelease_firmware(priv->firmware);\n\tfree_irq(gpio_to_irq(p54spi_gpio_irq), spi);\nerr_free_gpio_irq:\n\tgpio_free(p54spi_gpio_irq);\nerr_free_gpio_power:\n\tgpio_free(p54spi_gpio_power);\nerr_free:\n\tp54_free_common(priv->hw);\n\treturn ret;\n}\n\nstatic void p54spi_remove(struct spi_device *spi)\n{\n\tstruct p54s_priv *priv = spi_get_drvdata(spi);\n\n\tp54_unregister_common(priv->hw);\n\n\tfree_irq(gpio_to_irq(p54spi_gpio_irq), spi);\n\n\tgpio_free(p54spi_gpio_power);\n\tgpio_free(p54spi_gpio_irq);\n\trelease_firmware(priv->firmware);\n\n\tmutex_destroy(&priv->mutex);\n\n\tp54_free_common(priv->hw);\n}\n\n\nstatic struct spi_driver p54spi_driver = {\n\t.driver = {\n\t\t.name\t\t= \"p54spi\",\n\t},\n\n\t.probe\t\t= p54spi_probe,\n\t.remove\t\t= p54spi_remove,\n};\n\nmodule_spi_driver(p54spi_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Christian Lamparter <chunkeey@web.de>\");\nMODULE_ALIAS(\"spi:cx3110x\");\nMODULE_ALIAS(\"spi:p54spi\");\nMODULE_ALIAS(\"spi:stlc45xx\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}