{
  "module_name": "p54usb.c",
  "hash_id": "909d7ef4ec769f353346ea9ae7f093eabbb7642ee41b2c227e8add72e2d3b29c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/p54/p54usb.c",
  "human_readable_source": "\n\n \n\n#include <linux/usb.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/firmware.h>\n#include <linux/etherdevice.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/module.h>\n#include <net/mac80211.h>\n\n#include \"p54.h\"\n#include \"lmac.h\"\n#include \"p54usb.h\"\n\nMODULE_AUTHOR(\"Michael Wu <flamingice@sourmilk.net>\");\nMODULE_DESCRIPTION(\"Prism54 USB wireless driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"prism54usb\");\nMODULE_FIRMWARE(\"isl3886usb\");\nMODULE_FIRMWARE(\"isl3887usb\");\n\nstatic struct usb_driver p54u_driver;\n\n \n\nstatic const struct usb_device_id p54u_table[] = {\n\t \n\t{USB_DEVICE(0x0411, 0x0050)},\t \n\t{USB_DEVICE(0x045e, 0x00c2)},\t \n\t{USB_DEVICE(0x0506, 0x0a11)},\t \n\t{USB_DEVICE(0x0675, 0x0530)},\t \n\t{USB_DEVICE(0x06b9, 0x0120)},\t \n\t{USB_DEVICE(0x0707, 0xee06)},\t \n\t{USB_DEVICE(0x07aa, 0x001c)},\t \n\t{USB_DEVICE(0x083a, 0x4501)},\t \n\t{USB_DEVICE(0x083a, 0x4502)},\t \n\t{USB_DEVICE(0x083a, 0x5501)},\t \n\t{USB_DEVICE(0x0846, 0x4200)},\t \n\t{USB_DEVICE(0x0846, 0x4210)},\t \n\t{USB_DEVICE(0x0846, 0x4220)},\t \n\t{USB_DEVICE(0x09aa, 0x1000)},\t \n\t{USB_DEVICE(0x0bf8, 0x1007)},\t \n\t{USB_DEVICE(0x0cde, 0x0006)},\t \n\t{USB_DEVICE(0x0db0, 0x6826)},\t \n\t{USB_DEVICE(0x107b, 0x55f2)},\t \n\t{USB_DEVICE(0x124a, 0x4023)},\t \n\t{USB_DEVICE(0x124a, 0x4026)},\t \n\t{USB_DEVICE(0x1435, 0x0210)},\t \n\t{USB_DEVICE(0x15a9, 0x0002)},\t \n\t{USB_DEVICE(0x1630, 0x0005)},\t \n\t{USB_DEVICE(0x182d, 0x096b)},\t \n\t{USB_DEVICE(0x1915, 0x2234)},\t \n\t{USB_DEVICE(0x1915, 0x2235)},\t \n\t{USB_DEVICE(0x2001, 0x3701)},\t \n\t{USB_DEVICE(0x2001, 0x3703)},\t \n\t{USB_DEVICE(0x2001, 0x3762)},\t \n\t{USB_DEVICE(0x5041, 0x2234)},\t \n\t{USB_DEVICE(0x5041, 0x2235)},\t \n\n\t \n\t{USB_DEVICE(0x0471, 0x1230)},    \n\t{USB_DEVICE(0x050d, 0x7050)},\t \n\t{USB_DEVICE(0x0572, 0x2000)},\t \n\t{USB_DEVICE(0x0572, 0x2002)},\t \n\t{USB_DEVICE(0x06a9, 0x000e)},\t \n\t{USB_DEVICE(0x06b9, 0x0121)},\t \n\t{USB_DEVICE(0x0707, 0xee13)},    \n\t{USB_DEVICE(0x07aa, 0x0020)},\t \n\t{USB_DEVICE(0x0803, 0x4310)},\t \n\t{USB_DEVICE(0x083a, 0x4521)},    \n\t{USB_DEVICE(0x083a, 0x4531)},\t \n\t{USB_DEVICE(0x083a, 0xc501)},\t \n\t{USB_DEVICE(0x083a, 0xf503)},\t \n\t{USB_DEVICE(0x0846, 0x4240)},\t \n\t{USB_DEVICE(0x0915, 0x2000)},\t \n\t{USB_DEVICE(0x0915, 0x2002)},\t \n\t{USB_DEVICE(0x0baf, 0x0118)},    \n\t{USB_DEVICE(0x0bf8, 0x1009)},    \n\t \n\t{USB_DEVICE(0x0cde, 0x0008)},\t \n\t{USB_DEVICE(0x0cde, 0x0015)},\t \n\t{USB_DEVICE(0x0d8e, 0x3762)},\t \n\t{USB_DEVICE(0x124a, 0x4025)},\t \n\t{USB_DEVICE(0x1260, 0xee22)},\t \n\t{USB_DEVICE(0x13b1, 0x000a)},\t \n\t{USB_DEVICE(0x13B1, 0x000C)},\t \n\t{USB_DEVICE(0x1413, 0x5400)},    \n\t{USB_DEVICE(0x1435, 0x0427)},\t \n\t \n\t{USB_DEVICE(0x1668, 0x1050)},\t \n\t{USB_DEVICE(0x1740, 0x1000)},\t \n\t{USB_DEVICE(0x2001, 0x3704)},\t \n\t{USB_DEVICE(0x2001, 0x3705)},\t \n\t{USB_DEVICE(0x413c, 0x5513)},\t \n\t{USB_DEVICE(0x413c, 0x8102)},\t \n\t{USB_DEVICE(0x413c, 0x8104)},\t \n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, p54u_table);\n\nstatic const struct {\n\tu32 intf;\n\tenum p54u_hw_type type;\n\tconst char *fw;\n\tchar hw[20];\n} p54u_fwlist[__NUM_P54U_HWTYPES] = {\n\t{\n\t\t.type = P54U_NET2280,\n\t\t.intf = FW_LM86,\n\t\t.fw = \"isl3886usb\",\n\t\t.hw = \"ISL3886 + net2280\",\n\t},\n\t{\n\t\t.type = P54U_3887,\n\t\t.intf = FW_LM87,\n\t\t.fw = \"isl3887usb\",\n\t\t.hw = \"ISL3887\",\n\t},\n};\n\nstatic void p54u_rx_cb(struct urb *urb)\n{\n\tstruct sk_buff *skb = (struct sk_buff *) urb->context;\n\tstruct p54u_rx_info *info = (struct p54u_rx_info *)skb->cb;\n\tstruct ieee80211_hw *dev = info->dev;\n\tstruct p54u_priv *priv = dev->priv;\n\n\tskb_unlink(skb, &priv->rx_queue);\n\n\tif (unlikely(urb->status)) {\n\t\tdev_kfree_skb_irq(skb);\n\t\treturn;\n\t}\n\n\tskb_put(skb, urb->actual_length);\n\n\tif (priv->hw_type == P54U_NET2280)\n\t\tskb_pull(skb, priv->common.tx_hdr_len);\n\tif (priv->common.fw_interface == FW_LM87) {\n\t\tskb_pull(skb, 4);\n\t\tskb_put(skb, 4);\n\t}\n\n\tif (p54_rx(dev, skb)) {\n\t\tskb = dev_alloc_skb(priv->common.rx_mtu + 32);\n\t\tif (unlikely(!skb)) {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\n\t\tinfo = (struct p54u_rx_info *) skb->cb;\n\t\tinfo->urb = urb;\n\t\tinfo->dev = dev;\n\t\turb->transfer_buffer = skb_tail_pointer(skb);\n\t\turb->context = skb;\n\t} else {\n\t\tif (priv->hw_type == P54U_NET2280)\n\t\t\tskb_push(skb, priv->common.tx_hdr_len);\n\t\tif (priv->common.fw_interface == FW_LM87) {\n\t\t\tskb_push(skb, 4);\n\t\t\tskb_put(skb, 4);\n\t\t}\n\t\tskb_reset_tail_pointer(skb);\n\t\tskb_trim(skb, 0);\n\t\turb->transfer_buffer = skb_tail_pointer(skb);\n\t}\n\tskb_queue_tail(&priv->rx_queue, skb);\n\tusb_anchor_urb(urb, &priv->submitted);\n\tif (usb_submit_urb(urb, GFP_ATOMIC)) {\n\t\tskb_unlink(skb, &priv->rx_queue);\n\t\tusb_unanchor_urb(urb);\n\t\tdev_kfree_skb_irq(skb);\n\t}\n}\n\nstatic void p54u_tx_cb(struct urb *urb)\n{\n\tstruct sk_buff *skb = urb->context;\n\tstruct ieee80211_hw *dev =\n\t\tusb_get_intfdata(usb_ifnum_to_if(urb->dev, 0));\n\n\tp54_free_skb(dev, skb);\n}\n\nstatic void p54u_tx_dummy_cb(struct urb *urb) { }\n\nstatic void p54u_free_urbs(struct ieee80211_hw *dev)\n{\n\tstruct p54u_priv *priv = dev->priv;\n\tusb_kill_anchored_urbs(&priv->submitted);\n}\n\nstatic void p54u_stop(struct ieee80211_hw *dev)\n{\n\t \n\tp54u_free_urbs(dev);\n}\n\nstatic int p54u_init_urbs(struct ieee80211_hw *dev)\n{\n\tstruct p54u_priv *priv = dev->priv;\n\tstruct urb *entry = NULL;\n\tstruct sk_buff *skb;\n\tstruct p54u_rx_info *info;\n\tint ret = 0;\n\n\twhile (skb_queue_len(&priv->rx_queue) < 32) {\n\t\tskb = __dev_alloc_skb(priv->common.rx_mtu + 32, GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tentry = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!entry) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tusb_fill_bulk_urb(entry, priv->udev,\n\t\t\t\t  usb_rcvbulkpipe(priv->udev, P54U_PIPE_DATA),\n\t\t\t\t  skb_tail_pointer(skb),\n\t\t\t\t  priv->common.rx_mtu + 32, p54u_rx_cb, skb);\n\t\tinfo = (struct p54u_rx_info *) skb->cb;\n\t\tinfo->urb = entry;\n\t\tinfo->dev = dev;\n\t\tskb_queue_tail(&priv->rx_queue, skb);\n\n\t\tusb_anchor_urb(entry, &priv->submitted);\n\t\tret = usb_submit_urb(entry, GFP_KERNEL);\n\t\tif (ret) {\n\t\t\tskb_unlink(skb, &priv->rx_queue);\n\t\t\tusb_unanchor_urb(entry);\n\t\t\tgoto err;\n\t\t}\n\t\tusb_free_urb(entry);\n\t\tentry = NULL;\n\t}\n\n\treturn 0;\n\n err:\n\tusb_free_urb(entry);\n\tkfree_skb(skb);\n\tp54u_free_urbs(dev);\n\treturn ret;\n}\n\nstatic int p54u_open(struct ieee80211_hw *dev)\n{\n\t \n\treturn p54u_init_urbs(dev);\n}\n\nstatic __le32 p54u_lm87_chksum(const __le32 *data, size_t length)\n{\n\tu32 chk = 0;\n\n\tlength >>= 2;\n\twhile (length--) {\n\t\tchk ^= le32_to_cpu(*data++);\n\t\tchk = (chk >> 5) ^ (chk << 3);\n\t}\n\n\treturn cpu_to_le32(chk);\n}\n\nstatic void p54u_tx_lm87(struct ieee80211_hw *dev, struct sk_buff *skb)\n{\n\tstruct p54u_priv *priv = dev->priv;\n\tstruct urb *data_urb;\n\tstruct lm87_tx_hdr *hdr = (void *)skb->data - sizeof(*hdr);\n\n\tdata_urb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!data_urb) {\n\t\tp54_free_skb(dev, skb);\n\t\treturn;\n\t}\n\n\thdr->chksum = p54u_lm87_chksum((__le32 *)skb->data, skb->len);\n\thdr->device_addr = ((struct p54_hdr *)skb->data)->req_id;\n\n\tusb_fill_bulk_urb(data_urb, priv->udev,\n\t\t\t  usb_sndbulkpipe(priv->udev, P54U_PIPE_DATA),\n\t\t\t  hdr, skb->len + sizeof(*hdr),  FREE_AFTER_TX(skb) ?\n\t\t\t  p54u_tx_cb : p54u_tx_dummy_cb, skb);\n\tdata_urb->transfer_flags |= URB_ZERO_PACKET;\n\n\tusb_anchor_urb(data_urb, &priv->submitted);\n\tif (usb_submit_urb(data_urb, GFP_ATOMIC)) {\n\t\tusb_unanchor_urb(data_urb);\n\t\tp54_free_skb(dev, skb);\n\t}\n\tusb_free_urb(data_urb);\n}\n\nstatic void p54u_tx_net2280(struct ieee80211_hw *dev, struct sk_buff *skb)\n{\n\tstruct p54u_priv *priv = dev->priv;\n\tstruct urb *int_urb = NULL, *data_urb = NULL;\n\tstruct net2280_tx_hdr *hdr = (void *)skb->data - sizeof(*hdr);\n\tstruct net2280_reg_write *reg = NULL;\n\tint err = -ENOMEM;\n\n\treg = kmalloc(sizeof(*reg), GFP_ATOMIC);\n\tif (!reg)\n\t\tgoto out;\n\n\tint_urb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!int_urb)\n\t\tgoto out;\n\n\tdata_urb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!data_urb)\n\t\tgoto out;\n\n\treg->port = cpu_to_le16(NET2280_DEV_U32);\n\treg->addr = cpu_to_le32(P54U_DEV_BASE);\n\treg->val = cpu_to_le32(ISL38XX_DEV_INT_DATA);\n\n\tmemset(hdr, 0, sizeof(*hdr));\n\thdr->len = cpu_to_le16(skb->len);\n\thdr->device_addr = ((struct p54_hdr *) skb->data)->req_id;\n\n\tusb_fill_bulk_urb(int_urb, priv->udev,\n\t\tusb_sndbulkpipe(priv->udev, P54U_PIPE_DEV), reg, sizeof(*reg),\n\t\tp54u_tx_dummy_cb, dev);\n\n\t \n\tint_urb->transfer_flags |= URB_FREE_BUFFER | URB_ZERO_PACKET;\n\treg = NULL;\n\n\tusb_fill_bulk_urb(data_urb, priv->udev,\n\t\t\t  usb_sndbulkpipe(priv->udev, P54U_PIPE_DATA),\n\t\t\t  hdr, skb->len + sizeof(*hdr), FREE_AFTER_TX(skb) ?\n\t\t\t  p54u_tx_cb : p54u_tx_dummy_cb, skb);\n\tdata_urb->transfer_flags |= URB_ZERO_PACKET;\n\n\tusb_anchor_urb(int_urb, &priv->submitted);\n\terr = usb_submit_urb(int_urb, GFP_ATOMIC);\n\tif (err) {\n\t\tusb_unanchor_urb(int_urb);\n\t\tgoto out;\n\t}\n\n\tusb_anchor_urb(data_urb, &priv->submitted);\n\terr = usb_submit_urb(data_urb, GFP_ATOMIC);\n\tif (err) {\n\t\tusb_unanchor_urb(data_urb);\n\t\tgoto out;\n\t}\nout:\n\tusb_free_urb(int_urb);\n\tusb_free_urb(data_urb);\n\n\tif (err) {\n\t\tkfree(reg);\n\t\tp54_free_skb(dev, skb);\n\t}\n}\n\nstatic int p54u_write(struct p54u_priv *priv,\n\t\t      struct net2280_reg_write *buf,\n\t\t      enum net2280_op_type type,\n\t\t      __le32 addr, __le32 val)\n{\n\tunsigned int ep;\n\tint alen;\n\n\tif (type & 0x0800)\n\t\tep = usb_sndbulkpipe(priv->udev, P54U_PIPE_DEV);\n\telse\n\t\tep = usb_sndbulkpipe(priv->udev, P54U_PIPE_BRG);\n\n\tbuf->port = cpu_to_le16(type);\n\tbuf->addr = addr;\n\tbuf->val = val;\n\n\treturn usb_bulk_msg(priv->udev, ep, buf, sizeof(*buf), &alen, 1000);\n}\n\nstatic int p54u_read(struct p54u_priv *priv, void *buf,\n\t\t     enum net2280_op_type type,\n\t\t     __le32 addr, __le32 *val)\n{\n\tstruct net2280_reg_read *read = buf;\n\t__le32 *reg = buf;\n\tunsigned int ep;\n\tint alen, err;\n\n\tif (type & 0x0800)\n\t\tep = P54U_PIPE_DEV;\n\telse\n\t\tep = P54U_PIPE_BRG;\n\n\tread->port = cpu_to_le16(type);\n\tread->addr = addr;\n\n\terr = usb_bulk_msg(priv->udev, usb_sndbulkpipe(priv->udev, ep),\n\t\t\t   read, sizeof(*read), &alen, 1000);\n\tif (err)\n\t\treturn err;\n\n\terr = usb_bulk_msg(priv->udev, usb_rcvbulkpipe(priv->udev, ep),\n\t\t\t   reg, sizeof(*reg), &alen, 1000);\n\tif (err)\n\t\treturn err;\n\n\t*val = *reg;\n\treturn 0;\n}\n\nstatic int p54u_bulk_msg(struct p54u_priv *priv, unsigned int ep,\n\t\t\t void *data, size_t len)\n{\n\tint alen;\n\treturn usb_bulk_msg(priv->udev, usb_sndbulkpipe(priv->udev, ep),\n\t\t\t    data, len, &alen, 2000);\n}\n\nstatic int p54u_device_reset(struct ieee80211_hw *dev)\n{\n\tstruct p54u_priv *priv = dev->priv;\n\tint ret, lock = (priv->intf->condition != USB_INTERFACE_BINDING);\n\n\tif (lock) {\n\t\tret = usb_lock_device_for_reset(priv->udev, priv->intf);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&priv->udev->dev, \"(p54usb) unable to lock \"\n\t\t\t\t\"device for reset (%d)!\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = usb_reset_device(priv->udev);\n\tif (lock)\n\t\tusb_unlock_device(priv->udev);\n\n\tif (ret)\n\t\tdev_err(&priv->udev->dev, \"(p54usb) unable to reset \"\n\t\t\t\"device (%d)!\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const char p54u_romboot_3887[] = \"~~~~\";\nstatic int p54u_firmware_reset_3887(struct ieee80211_hw *dev)\n{\n\tstruct p54u_priv *priv = dev->priv;\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmemdup(p54u_romboot_3887, 4, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = p54u_bulk_msg(priv, P54U_PIPE_DATA,\n\t\t\t    buf, 4);\n\tkfree(buf);\n\tif (ret)\n\t\tdev_err(&priv->udev->dev, \"(p54usb) unable to jump to \"\n\t\t\t\"boot ROM (%d)!\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const char p54u_firmware_upload_3887[] = \"<\\r\";\nstatic int p54u_upload_firmware_3887(struct ieee80211_hw *dev)\n{\n\tstruct p54u_priv *priv = dev->priv;\n\tint err, alen;\n\tu8 carry = 0;\n\tu8 *buf, *tmp;\n\tconst u8 *data;\n\tunsigned int left, remains, block_size;\n\tstruct x2_header *hdr;\n\tunsigned long timeout;\n\n\terr = p54u_firmware_reset_3887(dev);\n\tif (err)\n\t\treturn err;\n\n\ttmp = buf = kmalloc(P54U_FW_BLOCK, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tleft = block_size = min_t(size_t, P54U_FW_BLOCK, priv->fw->size);\n\tstrcpy(buf, p54u_firmware_upload_3887);\n\tleft -= strlen(p54u_firmware_upload_3887);\n\ttmp += strlen(p54u_firmware_upload_3887);\n\n\tdata = priv->fw->data;\n\tremains = priv->fw->size;\n\n\thdr = (struct x2_header *)(buf + strlen(p54u_firmware_upload_3887));\n\tmemcpy(hdr->signature, X2_SIGNATURE, X2_SIGNATURE_SIZE);\n\thdr->fw_load_addr = cpu_to_le32(ISL38XX_DEV_FIRMWARE_ADDR);\n\thdr->fw_length = cpu_to_le32(priv->fw->size);\n\thdr->crc = cpu_to_le32(~crc32_le(~0, (void *)&hdr->fw_load_addr,\n\t\t\t\t\t sizeof(u32)*2));\n\tleft -= sizeof(*hdr);\n\ttmp += sizeof(*hdr);\n\n\twhile (remains) {\n\t\twhile (left--) {\n\t\t\tif (carry) {\n\t\t\t\t*tmp++ = carry;\n\t\t\t\tcarry = 0;\n\t\t\t\tremains--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (*data) {\n\t\t\tcase '~':\n\t\t\t\t*tmp++ = '}';\n\t\t\t\tcarry = '^';\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\t*tmp++ = '}';\n\t\t\t\tcarry = ']';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*tmp++ = *data;\n\t\t\t\tremains--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdata++;\n\t\t}\n\n\t\terr = p54u_bulk_msg(priv, P54U_PIPE_DATA, buf, block_size);\n\t\tif (err) {\n\t\t\tdev_err(&priv->udev->dev, \"(p54usb) firmware \"\n\t\t\t\t\t\t  \"upload failed!\\n\");\n\t\t\tgoto err_upload_failed;\n\t\t}\n\n\t\ttmp = buf;\n\t\tleft = block_size = min((unsigned int)P54U_FW_BLOCK, remains);\n\t}\n\n\t*((__le32 *)buf) = cpu_to_le32(~crc32_le(~0, priv->fw->data,\n\t\t\t\t\t\t priv->fw->size));\n\terr = p54u_bulk_msg(priv, P54U_PIPE_DATA, buf, sizeof(u32));\n\tif (err) {\n\t\tdev_err(&priv->udev->dev, \"(p54usb) firmware upload failed!\\n\");\n\t\tgoto err_upload_failed;\n\t}\n\ttimeout = jiffies + msecs_to_jiffies(1000);\n\twhile (!(err = usb_bulk_msg(priv->udev,\n\t\tusb_rcvbulkpipe(priv->udev, P54U_PIPE_DATA), buf, 128, &alen, 1000))) {\n\t\tif (alen > 2 && !memcmp(buf, \"OK\", 2))\n\t\t\tbreak;\n\n\t\tif (alen > 5 && !memcmp(buf, \"ERROR\", 5)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_err(&priv->udev->dev, \"(p54usb) firmware boot \"\n\t\t\t\t\t\t  \"timed out!\\n\");\n\t\t\terr = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (err) {\n\t\tdev_err(&priv->udev->dev, \"(p54usb) firmware upload failed!\\n\");\n\t\tgoto err_upload_failed;\n\t}\n\n\tbuf[0] = 'g';\n\tbuf[1] = '\\r';\n\terr = p54u_bulk_msg(priv, P54U_PIPE_DATA, buf, 2);\n\tif (err) {\n\t\tdev_err(&priv->udev->dev, \"(p54usb) firmware boot failed!\\n\");\n\t\tgoto err_upload_failed;\n\t}\n\n\ttimeout = jiffies + msecs_to_jiffies(1000);\n\twhile (!(err = usb_bulk_msg(priv->udev,\n\t\tusb_rcvbulkpipe(priv->udev, P54U_PIPE_DATA), buf, 128, &alen, 1000))) {\n\t\tif (alen > 0 && buf[0] == 'g')\n\t\t\tbreak;\n\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\terr = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (err)\n\t\tgoto err_upload_failed;\n\nerr_upload_failed:\n\tkfree(buf);\n\treturn err;\n}\n\nstatic int p54u_upload_firmware_net2280(struct ieee80211_hw *dev)\n{\n\tstruct p54u_priv *priv = dev->priv;\n\tconst struct p54p_csr *devreg = (const struct p54p_csr *) P54U_DEV_BASE;\n\tint err, alen;\n\tvoid *buf;\n\t__le32 reg;\n\tunsigned int remains, offset;\n\tconst u8 *data;\n\n\tbuf = kmalloc(512, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n#define P54U_WRITE(type, addr, data) \\\n\tdo {\\\n\t\terr = p54u_write(priv, buf, type,\\\n\t\t\t\t cpu_to_le32((u32)(unsigned long)addr), data);\\\n\t\tif (err) \\\n\t\t\tgoto fail;\\\n\t} while (0)\n\n#define P54U_READ(type, addr) \\\n\tdo {\\\n\t\terr = p54u_read(priv, buf, type,\\\n\t\t\t\tcpu_to_le32((u32)(unsigned long)addr), &reg);\\\n\t\tif (err)\\\n\t\t\tgoto fail;\\\n\t} while (0)\n\n\t \n\tP54U_READ(NET2280_BRG_U32, NET2280_GPIOCTL);\n\treg |= cpu_to_le32(P54U_BRG_POWER_DOWN);\n\treg &= cpu_to_le32(~P54U_BRG_POWER_UP);\n\tP54U_WRITE(NET2280_BRG_U32, NET2280_GPIOCTL, reg);\n\n\tmdelay(100);\n\n\t \n\treg |= cpu_to_le32(P54U_BRG_POWER_UP);\n\treg &= cpu_to_le32(~P54U_BRG_POWER_DOWN);\n\tP54U_WRITE(NET2280_BRG_U32, NET2280_GPIOCTL, reg);\n\n\tmdelay(100);\n\n\tP54U_WRITE(NET2280_BRG_U32, NET2280_DEVINIT,\n\t\t   cpu_to_le32(NET2280_CLK_30Mhz |\n\t\t\t       NET2280_PCI_ENABLE |\n\t\t\t       NET2280_PCI_SOFT_RESET));\n\n\tmdelay(20);\n\n\tP54U_WRITE(NET2280_BRG_CFG_U16, PCI_COMMAND,\n\t\t   cpu_to_le32(PCI_COMMAND_MEMORY |\n\t\t\t       PCI_COMMAND_MASTER));\n\n\tP54U_WRITE(NET2280_BRG_CFG_U32, PCI_BASE_ADDRESS_0,\n\t\t   cpu_to_le32(NET2280_BASE));\n\n\tP54U_READ(NET2280_BRG_CFG_U16, PCI_STATUS);\n\treg |= cpu_to_le32(PCI_STATUS_REC_MASTER_ABORT);\n\tP54U_WRITE(NET2280_BRG_CFG_U16, PCI_STATUS, reg);\n\n\t\n\tP54U_READ(NET2280_BRG_U32, NET2280_RELNUM);\n\n\tP54U_WRITE(NET2280_BRG_U32, NET2280_EPA_RSP,\n\t\t   cpu_to_le32(NET2280_CLEAR_NAK_OUT_PACKETS_MODE));\n\tP54U_WRITE(NET2280_BRG_U32, NET2280_EPC_RSP,\n\t\t   cpu_to_le32(NET2280_CLEAR_NAK_OUT_PACKETS_MODE));\n\n\tP54U_WRITE(NET2280_BRG_CFG_U32, PCI_BASE_ADDRESS_2,\n\t\t   cpu_to_le32(NET2280_BASE2));\n\n\t \n\n\tP54U_WRITE(NET2280_DEV_CFG_U16, 0x10000 | PCI_COMMAND,\n\t\t   cpu_to_le32(PCI_COMMAND_MEMORY |\n\t\t\t       PCI_COMMAND_MASTER));\n\n\tP54U_WRITE(NET2280_DEV_CFG_U16, 0x10000 | 0x40  , 0);\n\tP54U_WRITE(NET2280_DEV_CFG_U32, 0x10000 | PCI_BASE_ADDRESS_0,\n\t\t   cpu_to_le32(P54U_DEV_BASE));\n\n\tP54U_WRITE(NET2280_BRG_U32, NET2280_USBIRQENB1, 0);\n\tP54U_WRITE(NET2280_BRG_U32, NET2280_IRQSTAT1,\n\t\t   cpu_to_le32(NET2280_PCI_INTA_INTERRUPT));\n\n\t \n\tP54U_WRITE(NET2280_DEV_U32, &devreg->int_enable, 0);\n\n\tP54U_READ(NET2280_DEV_U32, &devreg->ctrl_stat);\n\treg &= cpu_to_le32(~ISL38XX_CTRL_STAT_RESET);\n\treg &= cpu_to_le32(~ISL38XX_CTRL_STAT_RAMBOOT);\n\treg &= cpu_to_le32(~ISL38XX_CTRL_STAT_CLKRUN);\n\tP54U_WRITE(NET2280_DEV_U32, &devreg->ctrl_stat, reg);\n\n\tmdelay(20);\n\n\treg |= cpu_to_le32(ISL38XX_CTRL_STAT_RESET);\n\tP54U_WRITE(NET2280_DEV_U32, &devreg->ctrl_stat, reg);\n\n\tmdelay(20);\n\n\treg &= cpu_to_le32(~ISL38XX_CTRL_STAT_RESET);\n\tP54U_WRITE(NET2280_DEV_U32, &devreg->ctrl_stat, reg);\n\n\tmdelay(100);\n\n\tP54U_READ(NET2280_DEV_U32, &devreg->int_ident);\n\tP54U_WRITE(NET2280_DEV_U32, &devreg->int_ack, reg);\n\n\t \n\tremains = priv->fw->size;\n\tdata = priv->fw->data;\n\toffset = ISL38XX_DEV_FIRMWARE_ADDR;\n\n\twhile (remains) {\n\t\tunsigned int block_len = min(remains, (unsigned int)512);\n\t\tmemcpy(buf, data, block_len);\n\n\t\terr = p54u_bulk_msg(priv, P54U_PIPE_DATA, buf, block_len);\n\t\tif (err) {\n\t\t\tdev_err(&priv->udev->dev, \"(p54usb) firmware block \"\n\t\t\t\t\t\t  \"upload failed\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tP54U_WRITE(NET2280_DEV_U32, &devreg->direct_mem_base,\n\t\t\t   cpu_to_le32(0xc0000f00));\n\n\t\tP54U_WRITE(NET2280_DEV_U32,\n\t\t\t   0x0020 | (unsigned long)&devreg->direct_mem_win, 0);\n\t\tP54U_WRITE(NET2280_DEV_U32,\n\t\t\t   0x0020 | (unsigned long)&devreg->direct_mem_win,\n\t\t\t   cpu_to_le32(1));\n\n\t\tP54U_WRITE(NET2280_DEV_U32,\n\t\t\t   0x0024 | (unsigned long)&devreg->direct_mem_win,\n\t\t\t   cpu_to_le32(block_len));\n\t\tP54U_WRITE(NET2280_DEV_U32,\n\t\t\t   0x0028 | (unsigned long)&devreg->direct_mem_win,\n\t\t\t   cpu_to_le32(offset));\n\n\t\tP54U_WRITE(NET2280_DEV_U32, &devreg->dma_addr,\n\t\t\t   cpu_to_le32(NET2280_EPA_FIFO_PCI_ADDR));\n\t\tP54U_WRITE(NET2280_DEV_U32, &devreg->dma_len,\n\t\t\t   cpu_to_le32(block_len >> 2));\n\t\tP54U_WRITE(NET2280_DEV_U32, &devreg->dma_ctrl,\n\t\t\t   cpu_to_le32(ISL38XX_DMA_MASTER_CONTROL_TRIGGER));\n\n\t\tmdelay(10);\n\n\t\tP54U_READ(NET2280_DEV_U32,\n\t\t\t  0x002C | (unsigned long)&devreg->direct_mem_win);\n\t\tif (!(reg & cpu_to_le32(ISL38XX_DMA_STATUS_DONE)) ||\n\t\t    !(reg & cpu_to_le32(ISL38XX_DMA_STATUS_READY))) {\n\t\t\tdev_err(&priv->udev->dev, \"(p54usb) firmware DMA \"\n\t\t\t\t\t\t  \"transfer failed\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tP54U_WRITE(NET2280_BRG_U32, NET2280_EPA_STAT,\n\t\t\t   cpu_to_le32(NET2280_FIFO_FLUSH));\n\n\t\tremains -= block_len;\n\t\tdata += block_len;\n\t\toffset += block_len;\n\t}\n\n\t \n\tP54U_READ(NET2280_DEV_U32, &devreg->ctrl_stat);\n\treg &= cpu_to_le32(~ISL38XX_CTRL_STAT_RESET);\n\treg &= cpu_to_le32(~ISL38XX_CTRL_STAT_CLKRUN);\n\treg |= cpu_to_le32(ISL38XX_CTRL_STAT_RAMBOOT);\n\tP54U_WRITE(NET2280_DEV_U32, &devreg->ctrl_stat, reg);\n\n\tmdelay(20);\n\n\treg |= cpu_to_le32(ISL38XX_CTRL_STAT_RESET);\n\tP54U_WRITE(NET2280_DEV_U32, &devreg->ctrl_stat, reg);\n\n\treg &= cpu_to_le32(~ISL38XX_CTRL_STAT_RESET);\n\tP54U_WRITE(NET2280_DEV_U32, &devreg->ctrl_stat, reg);\n\n\tmdelay(100);\n\n\tP54U_READ(NET2280_DEV_U32, &devreg->int_ident);\n\tP54U_WRITE(NET2280_DEV_U32, &devreg->int_ack, reg);\n\n\t \n\tP54U_WRITE(NET2280_DEV_U32, &devreg->int_enable,\n\t\t   cpu_to_le32(ISL38XX_INT_IDENT_INIT));\n\n\tP54U_WRITE(NET2280_BRG_U32, NET2280_IRQSTAT1,\n\t\t   cpu_to_le32(NET2280_PCI_INTA_INTERRUPT));\n\n\tP54U_WRITE(NET2280_BRG_U32, NET2280_USBIRQENB1,\n\t\t   cpu_to_le32(NET2280_PCI_INTA_INTERRUPT_ENABLE |\n\t\t\t       NET2280_USB_INTERRUPT_ENABLE));\n\n\tP54U_WRITE(NET2280_DEV_U32, &devreg->dev_int,\n\t\t   cpu_to_le32(ISL38XX_DEV_INT_RESET));\n\n\terr = usb_interrupt_msg(priv->udev,\n\t\t\t\tusb_rcvbulkpipe(priv->udev, P54U_PIPE_INT),\n\t\t\t\tbuf, sizeof(__le32), &alen, 1000);\n\tif (err || alen != sizeof(__le32))\n\t\tgoto fail;\n\n\tP54U_READ(NET2280_DEV_U32, &devreg->int_ident);\n\tP54U_WRITE(NET2280_DEV_U32, &devreg->int_ack, reg);\n\n\tif (!(reg & cpu_to_le32(ISL38XX_INT_IDENT_INIT)))\n\t\terr = -EINVAL;\n\n\tP54U_WRITE(NET2280_BRG_U32, NET2280_USBIRQENB1, 0);\n\tP54U_WRITE(NET2280_BRG_U32, NET2280_IRQSTAT1,\n\t\t   cpu_to_le32(NET2280_PCI_INTA_INTERRUPT));\n\n#undef P54U_WRITE\n#undef P54U_READ\n\nfail:\n\tkfree(buf);\n\treturn err;\n}\n\nstatic int p54_find_type(struct p54u_priv *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < __NUM_P54U_HWTYPES; i++)\n\t\tif (p54u_fwlist[i].type == priv->hw_type)\n\t\t\tbreak;\n\tif (i == __NUM_P54U_HWTYPES)\n\t\treturn -EOPNOTSUPP;\n\n\treturn i;\n}\n\nstatic int p54u_start_ops(struct p54u_priv *priv)\n{\n\tstruct ieee80211_hw *dev = priv->common.hw;\n\tint ret;\n\n\tret = p54_parse_firmware(dev, priv->fw);\n\tif (ret)\n\t\tgoto err_out;\n\n\tret = p54_find_type(priv);\n\tif (ret < 0)\n\t\tgoto err_out;\n\n\tif (priv->common.fw_interface != p54u_fwlist[ret].intf) {\n\t\tdev_err(&priv->udev->dev, \"wrong firmware, please get \"\n\t\t\t\"a firmware for \\\"%s\\\" and try again.\\n\",\n\t\t\tp54u_fwlist[ret].hw);\n\t\tret = -ENODEV;\n\t\tgoto err_out;\n\t}\n\n\tret = priv->upload_fw(dev);\n\tif (ret)\n\t\tgoto err_out;\n\n\tret = p54u_open(dev);\n\tif (ret)\n\t\tgoto err_out;\n\n\tret = p54_read_eeprom(dev);\n\tif (ret)\n\t\tgoto err_stop;\n\n\tp54u_stop(dev);\n\n\tret = p54_register_common(dev, &priv->udev->dev);\n\tif (ret)\n\t\tgoto err_stop;\n\n\treturn 0;\n\nerr_stop:\n\tp54u_stop(dev);\n\nerr_out:\n\t \n\treturn ret;\n}\n\nstatic void p54u_load_firmware_cb(const struct firmware *firmware,\n\t\t\t\t  void *context)\n{\n\tstruct p54u_priv *priv = context;\n\tstruct usb_device *udev = priv->udev;\n\tstruct usb_interface *intf = priv->intf;\n\tint err;\n\n\tif (firmware) {\n\t\tpriv->fw = firmware;\n\t\terr = p54u_start_ops(priv);\n\t} else {\n\t\terr = -ENOENT;\n\t\tdev_err(&udev->dev, \"Firmware not found.\\n\");\n\t}\n\n\tcomplete(&priv->fw_wait_load);\n\t \n\tpriv = NULL;\n\n\tif (err) {\n\t\tdev_err(&intf->dev, \"failed to initialize device (%d)\\n\", err);\n\n\t\tusb_lock_device(udev);\n\t\tusb_driver_release_interface(&p54u_driver, intf);\n\t\tusb_unlock_device(udev);\n\t}\n\n\tusb_put_intf(intf);\n}\n\nstatic int p54u_load_firmware(struct ieee80211_hw *dev,\n\t\t\t      struct usb_interface *intf)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct p54u_priv *priv = dev->priv;\n\tstruct device *device = &udev->dev;\n\tint err, i;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(p54u_fwlist) != __NUM_P54U_HWTYPES);\n\n\tinit_completion(&priv->fw_wait_load);\n\ti = p54_find_type(priv);\n\tif (i < 0)\n\t\treturn i;\n\n\tdev_info(&priv->udev->dev, \"Loading firmware file %s\\n\",\n\t       p54u_fwlist[i].fw);\n\n\tusb_get_intf(intf);\n\terr = request_firmware_nowait(THIS_MODULE, 1, p54u_fwlist[i].fw,\n\t\t\t\t      device, GFP_KERNEL, priv,\n\t\t\t\t      p54u_load_firmware_cb);\n\tif (err) {\n\t\tdev_err(&priv->udev->dev, \"(p54usb) cannot load firmware %s \"\n\t\t\t\t\t  \"(%d)!\\n\", p54u_fwlist[i].fw, err);\n\t\tusb_put_intf(intf);\n\t}\n\n\treturn err;\n}\n\nstatic int p54u_probe(struct usb_interface *intf,\n\t\t\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct ieee80211_hw *dev;\n\tstruct p54u_priv *priv;\n\tint err;\n\tunsigned int i, recognized_pipes;\n\n\tdev = p54_init_common(sizeof(*priv));\n\n\tif (!dev) {\n\t\tdev_err(&udev->dev, \"(p54usb) ieee80211 alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv = dev->priv;\n\tpriv->hw_type = P54U_INVALID_HW;\n\n\tSET_IEEE80211_DEV(dev, &intf->dev);\n\tusb_set_intfdata(intf, dev);\n\tpriv->udev = udev;\n\tpriv->intf = intf;\n\tskb_queue_head_init(&priv->rx_queue);\n\tinit_usb_anchor(&priv->submitted);\n\n\t \n\t \n\ti = intf->altsetting->desc.bNumEndpoints;\n\trecognized_pipes = 0;\n\twhile (i--) {\n\t\tswitch (intf->altsetting->endpoint[i].desc.bEndpointAddress) {\n\t\tcase P54U_PIPE_DATA:\n\t\tcase P54U_PIPE_MGMT:\n\t\tcase P54U_PIPE_BRG:\n\t\tcase P54U_PIPE_DEV:\n\t\tcase P54U_PIPE_DATA | USB_DIR_IN:\n\t\tcase P54U_PIPE_MGMT | USB_DIR_IN:\n\t\tcase P54U_PIPE_BRG | USB_DIR_IN:\n\t\tcase P54U_PIPE_DEV | USB_DIR_IN:\n\t\tcase P54U_PIPE_INT | USB_DIR_IN:\n\t\t\trecognized_pipes++;\n\t\t}\n\t}\n\tpriv->common.open = p54u_open;\n\tpriv->common.stop = p54u_stop;\n\tif (recognized_pipes < P54U_PIPE_NUMBER) {\n#ifdef CONFIG_PM\n\t\t \n\t\tudev->reset_resume = 1;\n#endif  \n\t\terr = p54u_device_reset(dev);\n\n\t\tpriv->hw_type = P54U_3887;\n\t\tdev->extra_tx_headroom += sizeof(struct lm87_tx_hdr);\n\t\tpriv->common.tx_hdr_len = sizeof(struct lm87_tx_hdr);\n\t\tpriv->common.tx = p54u_tx_lm87;\n\t\tpriv->upload_fw = p54u_upload_firmware_3887;\n\t} else {\n\t\tpriv->hw_type = P54U_NET2280;\n\t\tdev->extra_tx_headroom += sizeof(struct net2280_tx_hdr);\n\t\tpriv->common.tx_hdr_len = sizeof(struct net2280_tx_hdr);\n\t\tpriv->common.tx = p54u_tx_net2280;\n\t\tpriv->upload_fw = p54u_upload_firmware_net2280;\n\t}\n\terr = p54u_load_firmware(dev, intf);\n\tif (err)\n\t\tp54_free_common(dev);\n\treturn err;\n}\n\nstatic void p54u_disconnect(struct usb_interface *intf)\n{\n\tstruct ieee80211_hw *dev = usb_get_intfdata(intf);\n\tstruct p54u_priv *priv;\n\n\tif (!dev)\n\t\treturn;\n\n\tpriv = dev->priv;\n\twait_for_completion(&priv->fw_wait_load);\n\tp54_unregister_common(dev);\n\n\trelease_firmware(priv->fw);\n\tp54_free_common(dev);\n}\n\nstatic int p54u_pre_reset(struct usb_interface *intf)\n{\n\tstruct ieee80211_hw *dev = usb_get_intfdata(intf);\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tp54u_stop(dev);\n\treturn 0;\n}\n\nstatic int p54u_resume(struct usb_interface *intf)\n{\n\tstruct ieee80211_hw *dev = usb_get_intfdata(intf);\n\tstruct p54u_priv *priv;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tpriv = dev->priv;\n\tif (unlikely(!(priv->upload_fw && priv->fw)))\n\t\treturn 0;\n\n\treturn priv->upload_fw(dev);\n}\n\nstatic int p54u_post_reset(struct usb_interface *intf)\n{\n\tstruct ieee80211_hw *dev = usb_get_intfdata(intf);\n\tstruct p54u_priv *priv;\n\tint err;\n\n\terr = p54u_resume(intf);\n\tif (err)\n\t\treturn err;\n\n\t \n\tpriv = dev->priv;\n\tif (priv->common.mode != NL80211_IFTYPE_UNSPECIFIED)\n\t\tieee80211_restart_hw(dev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\n\nstatic int p54u_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\treturn p54u_pre_reset(intf);\n}\n\n#endif  \n\nstatic struct usb_driver p54u_driver = {\n\t.name\t= \"p54usb\",\n\t.id_table = p54u_table,\n\t.probe = p54u_probe,\n\t.disconnect = p54u_disconnect,\n\t.pre_reset = p54u_pre_reset,\n\t.post_reset = p54u_post_reset,\n#ifdef CONFIG_PM\n\t.suspend = p54u_suspend,\n\t.resume = p54u_resume,\n\t.reset_resume = p54u_resume,\n#endif  \n\t.soft_unbind = 1,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(p54u_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}