{
  "module_name": "p54pci.c",
  "hash_id": "bb3f7bc9426eaab6bf3b4f5e9922c543f90fc8c770d152f7c5aa3e55f053485a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/p54/p54pci.c",
  "human_readable_source": "\n\n \n\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/firmware.h>\n#include <linux/etherdevice.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/module.h>\n#include <net/mac80211.h>\n\n#include \"p54.h\"\n#include \"lmac.h\"\n#include \"p54pci.h\"\n\nMODULE_AUTHOR(\"Michael Wu <flamingice@sourmilk.net>\");\nMODULE_DESCRIPTION(\"Prism54 PCI wireless driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"prism54pci\");\nMODULE_FIRMWARE(\"isl3886pci\");\n\nstatic const struct pci_device_id p54p_table[] = {\n\t \n\t{ PCI_DEVICE(0x1260, 0x3890) },\n\t \n\t{ PCI_DEVICE(0x10b7, 0x6001) },\n\t \n\t{ PCI_DEVICE(0x1260, 0x3877) },\n\t \n\t{ PCI_DEVICE(0x1260, 0x3886) },\n\t \n\t{ PCI_DEVICE(0x1260, 0xffff) },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(pci, p54p_table);\n\nstatic int p54p_upload_firmware(struct ieee80211_hw *dev)\n{\n\tstruct p54p_priv *priv = dev->priv;\n\t__le32 reg;\n\tint err;\n\t__le32 *data;\n\tu32 remains, left, device_addr;\n\n\tP54P_WRITE(int_enable, cpu_to_le32(0));\n\tP54P_READ(int_enable);\n\tudelay(10);\n\n\treg = P54P_READ(ctrl_stat);\n\treg &= cpu_to_le32(~ISL38XX_CTRL_STAT_RESET);\n\treg &= cpu_to_le32(~ISL38XX_CTRL_STAT_RAMBOOT);\n\tP54P_WRITE(ctrl_stat, reg);\n\tP54P_READ(ctrl_stat);\n\tudelay(10);\n\n\treg |= cpu_to_le32(ISL38XX_CTRL_STAT_RESET);\n\tP54P_WRITE(ctrl_stat, reg);\n\twmb();\n\tudelay(10);\n\n\treg &= cpu_to_le32(~ISL38XX_CTRL_STAT_RESET);\n\tP54P_WRITE(ctrl_stat, reg);\n\twmb();\n\n\t \n\tmdelay(10);\n\n\terr = p54_parse_firmware(dev, priv->firmware);\n\tif (err)\n\t\treturn err;\n\n\tif (priv->common.fw_interface != FW_LM86) {\n\t\tdev_err(&priv->pdev->dev, \"wrong firmware, \"\n\t\t\t\"please get a LM86(PCI) firmware a try again.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata = (__le32 *) priv->firmware->data;\n\tremains = priv->firmware->size;\n\tdevice_addr = ISL38XX_DEV_FIRMWARE_ADDR;\n\twhile (remains) {\n\t\tu32 i = 0;\n\t\tleft = min((u32)0x1000, remains);\n\t\tP54P_WRITE(direct_mem_base, cpu_to_le32(device_addr));\n\t\tP54P_READ(int_enable);\n\n\t\tdevice_addr += 0x1000;\n\t\twhile (i < left) {\n\t\t\tP54P_WRITE(direct_mem_win[i], *data++);\n\t\t\ti += sizeof(u32);\n\t\t}\n\n\t\tremains -= left;\n\t\tP54P_READ(int_enable);\n\t}\n\n\treg = P54P_READ(ctrl_stat);\n\treg &= cpu_to_le32(~ISL38XX_CTRL_STAT_CLKRUN);\n\treg &= cpu_to_le32(~ISL38XX_CTRL_STAT_RESET);\n\treg |= cpu_to_le32(ISL38XX_CTRL_STAT_RAMBOOT);\n\tP54P_WRITE(ctrl_stat, reg);\n\tP54P_READ(ctrl_stat);\n\tudelay(10);\n\n\treg |= cpu_to_le32(ISL38XX_CTRL_STAT_RESET);\n\tP54P_WRITE(ctrl_stat, reg);\n\twmb();\n\tudelay(10);\n\n\treg &= cpu_to_le32(~ISL38XX_CTRL_STAT_RESET);\n\tP54P_WRITE(ctrl_stat, reg);\n\twmb();\n\tudelay(10);\n\n\t \n\tmdelay(100);\n\n\treturn 0;\n}\n\nstatic void p54p_refill_rx_ring(struct ieee80211_hw *dev,\n\tint ring_index, struct p54p_desc *ring, u32 ring_limit,\n\tstruct sk_buff **rx_buf, u32 index)\n{\n\tstruct p54p_priv *priv = dev->priv;\n\tstruct p54p_ring_control *ring_control = priv->ring_control;\n\tu32 limit, idx, i;\n\n\tidx = le32_to_cpu(ring_control->host_idx[ring_index]);\n\tlimit = idx;\n\tlimit -= index;\n\tlimit = ring_limit - limit;\n\n\ti = idx % ring_limit;\n\twhile (limit-- > 1) {\n\t\tstruct p54p_desc *desc = &ring[i];\n\n\t\tif (!desc->host_addr) {\n\t\t\tstruct sk_buff *skb;\n\t\t\tdma_addr_t mapping;\n\t\t\tskb = dev_alloc_skb(priv->common.rx_mtu + 32);\n\t\t\tif (!skb)\n\t\t\t\tbreak;\n\n\t\t\tmapping = dma_map_single(&priv->pdev->dev,\n\t\t\t\t\t\t skb_tail_pointer(skb),\n\t\t\t\t\t\t priv->common.rx_mtu + 32,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\n\t\t\tif (dma_mapping_error(&priv->pdev->dev, mapping)) {\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\tdev_err(&priv->pdev->dev,\n\t\t\t\t\t\"RX DMA Mapping error\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdesc->host_addr = cpu_to_le32(mapping);\n\t\t\tdesc->device_addr = 0;\t\n\t\t\tdesc->len = cpu_to_le16(priv->common.rx_mtu + 32);\n\t\t\tdesc->flags = 0;\n\t\t\trx_buf[i] = skb;\n\t\t}\n\n\t\ti++;\n\t\tidx++;\n\t\ti %= ring_limit;\n\t}\n\n\twmb();\n\tring_control->host_idx[ring_index] = cpu_to_le32(idx);\n}\n\nstatic void p54p_check_rx_ring(struct ieee80211_hw *dev, u32 *index,\n\tint ring_index, struct p54p_desc *ring, u32 ring_limit,\n\tstruct sk_buff **rx_buf)\n{\n\tstruct p54p_priv *priv = dev->priv;\n\tstruct p54p_ring_control *ring_control = priv->ring_control;\n\tstruct p54p_desc *desc;\n\tu32 idx, i;\n\n\ti = (*index) % ring_limit;\n\t(*index) = idx = le32_to_cpu(ring_control->device_idx[ring_index]);\n\tidx %= ring_limit;\n\twhile (i != idx) {\n\t\tu16 len;\n\t\tstruct sk_buff *skb;\n\t\tdma_addr_t dma_addr;\n\t\tdesc = &ring[i];\n\t\tlen = le16_to_cpu(desc->len);\n\t\tskb = rx_buf[i];\n\n\t\tif (!skb) {\n\t\t\ti++;\n\t\t\ti %= ring_limit;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (unlikely(len > priv->common.rx_mtu)) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tdev_err(&priv->pdev->dev, \"rx'd frame size \"\n\t\t\t\t\t\"exceeds length threshold.\\n\");\n\n\t\t\tlen = priv->common.rx_mtu;\n\t\t}\n\t\tdma_addr = le32_to_cpu(desc->host_addr);\n\t\tdma_sync_single_for_cpu(&priv->pdev->dev, dma_addr,\n\t\t\t\t\tpriv->common.rx_mtu + 32,\n\t\t\t\t\tDMA_FROM_DEVICE);\n\t\tskb_put(skb, len);\n\n\t\tif (p54_rx(dev, skb)) {\n\t\t\tdma_unmap_single(&priv->pdev->dev, dma_addr,\n\t\t\t\t\t priv->common.rx_mtu + 32,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\trx_buf[i] = NULL;\n\t\t\tdesc->host_addr = cpu_to_le32(0);\n\t\t} else {\n\t\t\tskb_trim(skb, 0);\n\t\t\tdma_sync_single_for_device(&priv->pdev->dev, dma_addr,\n\t\t\t\t\t\t   priv->common.rx_mtu + 32,\n\t\t\t\t\t\t   DMA_FROM_DEVICE);\n\t\t\tdesc->len = cpu_to_le16(priv->common.rx_mtu + 32);\n\t\t}\n\n\t\ti++;\n\t\ti %= ring_limit;\n\t}\n\n\tp54p_refill_rx_ring(dev, ring_index, ring, ring_limit, rx_buf, *index);\n}\n\nstatic void p54p_check_tx_ring(struct ieee80211_hw *dev, u32 *index,\n\tint ring_index, struct p54p_desc *ring, u32 ring_limit,\n\tstruct sk_buff **tx_buf)\n{\n\tstruct p54p_priv *priv = dev->priv;\n\tstruct p54p_ring_control *ring_control = priv->ring_control;\n\tstruct p54p_desc *desc;\n\tstruct sk_buff *skb;\n\tu32 idx, i;\n\n\ti = (*index) % ring_limit;\n\t(*index) = idx = le32_to_cpu(ring_control->device_idx[ring_index]);\n\tidx %= ring_limit;\n\n\twhile (i != idx) {\n\t\tdesc = &ring[i];\n\n\t\tskb = tx_buf[i];\n\t\ttx_buf[i] = NULL;\n\n\t\tdma_unmap_single(&priv->pdev->dev,\n\t\t\t\t le32_to_cpu(desc->host_addr),\n\t\t\t\t le16_to_cpu(desc->len), DMA_TO_DEVICE);\n\n\t\tdesc->host_addr = 0;\n\t\tdesc->device_addr = 0;\n\t\tdesc->len = 0;\n\t\tdesc->flags = 0;\n\n\t\tif (skb && FREE_AFTER_TX(skb))\n\t\t\tp54_free_skb(dev, skb);\n\n\t\ti++;\n\t\ti %= ring_limit;\n\t}\n}\n\nstatic void p54p_tasklet(struct tasklet_struct *t)\n{\n\tstruct p54p_priv *priv = from_tasklet(priv, t, tasklet);\n\tstruct ieee80211_hw *dev = pci_get_drvdata(priv->pdev);\n\tstruct p54p_ring_control *ring_control = priv->ring_control;\n\n\tp54p_check_tx_ring(dev, &priv->tx_idx_mgmt, 3, ring_control->tx_mgmt,\n\t\t\t   ARRAY_SIZE(ring_control->tx_mgmt),\n\t\t\t   priv->tx_buf_mgmt);\n\n\tp54p_check_tx_ring(dev, &priv->tx_idx_data, 1, ring_control->tx_data,\n\t\t\t   ARRAY_SIZE(ring_control->tx_data),\n\t\t\t   priv->tx_buf_data);\n\n\tp54p_check_rx_ring(dev, &priv->rx_idx_mgmt, 2, ring_control->rx_mgmt,\n\t\tARRAY_SIZE(ring_control->rx_mgmt), priv->rx_buf_mgmt);\n\n\tp54p_check_rx_ring(dev, &priv->rx_idx_data, 0, ring_control->rx_data,\n\t\tARRAY_SIZE(ring_control->rx_data), priv->rx_buf_data);\n\n\twmb();\n\tP54P_WRITE(dev_int, cpu_to_le32(ISL38XX_DEV_INT_UPDATE));\n}\n\nstatic irqreturn_t p54p_interrupt(int irq, void *dev_id)\n{\n\tstruct ieee80211_hw *dev = dev_id;\n\tstruct p54p_priv *priv = dev->priv;\n\t__le32 reg;\n\n\treg = P54P_READ(int_ident);\n\tif (unlikely(reg == cpu_to_le32(0xFFFFFFFF))) {\n\t\tgoto out;\n\t}\n\tP54P_WRITE(int_ack, reg);\n\n\treg &= P54P_READ(int_enable);\n\n\tif (reg & cpu_to_le32(ISL38XX_INT_IDENT_UPDATE))\n\t\ttasklet_schedule(&priv->tasklet);\n\telse if (reg & cpu_to_le32(ISL38XX_INT_IDENT_INIT))\n\t\tcomplete(&priv->boot_comp);\n\nout:\n\treturn reg ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic void p54p_tx(struct ieee80211_hw *dev, struct sk_buff *skb)\n{\n\tunsigned long flags;\n\tstruct p54p_priv *priv = dev->priv;\n\tstruct p54p_ring_control *ring_control = priv->ring_control;\n\tstruct p54p_desc *desc;\n\tdma_addr_t mapping;\n\tu32 idx, i;\n\t__le32 device_addr;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tidx = le32_to_cpu(ring_control->host_idx[1]);\n\ti = idx % ARRAY_SIZE(ring_control->tx_data);\n\tdevice_addr = ((struct p54_hdr *)skb->data)->req_id;\n\n\tmapping = dma_map_single(&priv->pdev->dev, skb->data, skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\tif (dma_mapping_error(&priv->pdev->dev, mapping)) {\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tp54_free_skb(dev, skb);\n\t\tdev_err(&priv->pdev->dev, \"TX DMA mapping error\\n\");\n\t\treturn ;\n\t}\n\tpriv->tx_buf_data[i] = skb;\n\n\tdesc = &ring_control->tx_data[i];\n\tdesc->host_addr = cpu_to_le32(mapping);\n\tdesc->device_addr = device_addr;\n\tdesc->len = cpu_to_le16(skb->len);\n\tdesc->flags = 0;\n\n\twmb();\n\tring_control->host_idx[1] = cpu_to_le32(idx + 1);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tP54P_WRITE(dev_int, cpu_to_le32(ISL38XX_DEV_INT_UPDATE));\n\tP54P_READ(dev_int);\n}\n\nstatic void p54p_stop(struct ieee80211_hw *dev)\n{\n\tstruct p54p_priv *priv = dev->priv;\n\tstruct p54p_ring_control *ring_control = priv->ring_control;\n\tunsigned int i;\n\tstruct p54p_desc *desc;\n\n\tP54P_WRITE(int_enable, cpu_to_le32(0));\n\tP54P_READ(int_enable);\n\tudelay(10);\n\n\tfree_irq(priv->pdev->irq, dev);\n\n\ttasklet_kill(&priv->tasklet);\n\n\tP54P_WRITE(dev_int, cpu_to_le32(ISL38XX_DEV_INT_RESET));\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->rx_buf_data); i++) {\n\t\tdesc = &ring_control->rx_data[i];\n\t\tif (desc->host_addr)\n\t\t\tdma_unmap_single(&priv->pdev->dev,\n\t\t\t\t\t le32_to_cpu(desc->host_addr),\n\t\t\t\t\t priv->common.rx_mtu + 32,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\tkfree_skb(priv->rx_buf_data[i]);\n\t\tpriv->rx_buf_data[i] = NULL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->rx_buf_mgmt); i++) {\n\t\tdesc = &ring_control->rx_mgmt[i];\n\t\tif (desc->host_addr)\n\t\t\tdma_unmap_single(&priv->pdev->dev,\n\t\t\t\t\t le32_to_cpu(desc->host_addr),\n\t\t\t\t\t priv->common.rx_mtu + 32,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\tkfree_skb(priv->rx_buf_mgmt[i]);\n\t\tpriv->rx_buf_mgmt[i] = NULL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->tx_buf_data); i++) {\n\t\tdesc = &ring_control->tx_data[i];\n\t\tif (desc->host_addr)\n\t\t\tdma_unmap_single(&priv->pdev->dev,\n\t\t\t\t\t le32_to_cpu(desc->host_addr),\n\t\t\t\t\t le16_to_cpu(desc->len),\n\t\t\t\t\t DMA_TO_DEVICE);\n\n\t\tp54_free_skb(dev, priv->tx_buf_data[i]);\n\t\tpriv->tx_buf_data[i] = NULL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->tx_buf_mgmt); i++) {\n\t\tdesc = &ring_control->tx_mgmt[i];\n\t\tif (desc->host_addr)\n\t\t\tdma_unmap_single(&priv->pdev->dev,\n\t\t\t\t\t le32_to_cpu(desc->host_addr),\n\t\t\t\t\t le16_to_cpu(desc->len),\n\t\t\t\t\t DMA_TO_DEVICE);\n\n\t\tp54_free_skb(dev, priv->tx_buf_mgmt[i]);\n\t\tpriv->tx_buf_mgmt[i] = NULL;\n\t}\n\n\tmemset(ring_control, 0, sizeof(*ring_control));\n}\n\nstatic int p54p_open(struct ieee80211_hw *dev)\n{\n\tstruct p54p_priv *priv = dev->priv;\n\tint err;\n\tlong timeout;\n\n\tinit_completion(&priv->boot_comp);\n\terr = request_irq(priv->pdev->irq, p54p_interrupt,\n\t\t\t  IRQF_SHARED, \"p54pci\", dev);\n\tif (err) {\n\t\tdev_err(&priv->pdev->dev, \"failed to register IRQ handler\\n\");\n\t\treturn err;\n\t}\n\n\tmemset(priv->ring_control, 0, sizeof(*priv->ring_control));\n\terr = p54p_upload_firmware(dev);\n\tif (err) {\n\t\tfree_irq(priv->pdev->irq, dev);\n\t\treturn err;\n\t}\n\tpriv->rx_idx_data = priv->tx_idx_data = 0;\n\tpriv->rx_idx_mgmt = priv->tx_idx_mgmt = 0;\n\n\tp54p_refill_rx_ring(dev, 0, priv->ring_control->rx_data,\n\t\tARRAY_SIZE(priv->ring_control->rx_data), priv->rx_buf_data, 0);\n\n\tp54p_refill_rx_ring(dev, 2, priv->ring_control->rx_mgmt,\n\t\tARRAY_SIZE(priv->ring_control->rx_mgmt), priv->rx_buf_mgmt, 0);\n\n\tP54P_WRITE(ring_control_base, cpu_to_le32(priv->ring_control_dma));\n\tP54P_READ(ring_control_base);\n\twmb();\n\tudelay(10);\n\n\tP54P_WRITE(int_enable, cpu_to_le32(ISL38XX_INT_IDENT_INIT));\n\tP54P_READ(int_enable);\n\twmb();\n\tudelay(10);\n\n\tP54P_WRITE(dev_int, cpu_to_le32(ISL38XX_DEV_INT_RESET));\n\tP54P_READ(dev_int);\n\n\ttimeout = wait_for_completion_interruptible_timeout(\n\t\t\t&priv->boot_comp, HZ);\n\tif (timeout <= 0) {\n\t\twiphy_err(dev->wiphy, \"Cannot boot firmware!\\n\");\n\t\tp54p_stop(dev);\n\t\treturn timeout ? -ERESTARTSYS : -ETIMEDOUT;\n\t}\n\n\tP54P_WRITE(int_enable, cpu_to_le32(ISL38XX_INT_IDENT_UPDATE));\n\tP54P_READ(int_enable);\n\twmb();\n\tudelay(10);\n\n\tP54P_WRITE(dev_int, cpu_to_le32(ISL38XX_DEV_INT_UPDATE));\n\tP54P_READ(dev_int);\n\twmb();\n\tudelay(10);\n\n\treturn 0;\n}\n\nstatic void p54p_firmware_step2(const struct firmware *fw,\n\t\t\t\tvoid *context)\n{\n\tstruct p54p_priv *priv = context;\n\tstruct ieee80211_hw *dev = priv->common.hw;\n\tstruct pci_dev *pdev = priv->pdev;\n\tint err;\n\n\tif (!fw) {\n\t\tdev_err(&pdev->dev, \"Cannot find firmware (isl3886pci)\\n\");\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tpriv->firmware = fw;\n\n\terr = p54p_open(dev);\n\tif (err)\n\t\tgoto out;\n\terr = p54_read_eeprom(dev);\n\tp54p_stop(dev);\n\tif (err)\n\t\tgoto out;\n\n\terr = p54_register_common(dev, &pdev->dev);\n\tif (err)\n\t\tgoto out;\n\nout:\n\n\tcomplete(&priv->fw_loaded);\n\n\tif (err) {\n\t\tstruct device *parent = pdev->dev.parent;\n\n\t\tif (parent)\n\t\t\tdevice_lock(parent);\n\n\t\t \n\t\tdevice_release_driver(&pdev->dev);\n\n\t\tif (parent)\n\t\t\tdevice_unlock(parent);\n\t}\n\n\tpci_dev_put(pdev);\n}\n\nstatic int p54p_probe(struct pci_dev *pdev,\n\t\t\t\tconst struct pci_device_id *id)\n{\n\tstruct p54p_priv *priv;\n\tstruct ieee80211_hw *dev;\n\tunsigned long mem_addr, mem_len;\n\tint err;\n\n\tpci_dev_get(pdev);\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Cannot enable new PCI device\\n\");\n\t\tgoto err_put;\n\t}\n\n\tmem_addr = pci_resource_start(pdev, 0);\n\tmem_len = pci_resource_len(pdev, 0);\n\tif (mem_len < sizeof(struct p54p_csr)) {\n\t\tdev_err(&pdev->dev, \"Too short PCI resources\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_disable_dev;\n\t}\n\n\terr = pci_request_regions(pdev, \"p54pci\");\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Cannot obtain PCI resources\\n\");\n\t\tgoto err_disable_dev;\n\t}\n\n\terr = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (!err)\n\t\terr = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"No suitable DMA available\\n\");\n\t\tgoto err_free_reg;\n\t}\n\n\tpci_set_master(pdev);\n\tpci_try_set_mwi(pdev);\n\n\tpci_write_config_byte(pdev, 0x40, 0);\n\tpci_write_config_byte(pdev, 0x41, 0);\n\n\tdev = p54_init_common(sizeof(*priv));\n\tif (!dev) {\n\t\tdev_err(&pdev->dev, \"ieee80211 alloc failed\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_free_reg;\n\t}\n\n\tpriv = dev->priv;\n\tpriv->pdev = pdev;\n\n\tinit_completion(&priv->fw_loaded);\n\tSET_IEEE80211_DEV(dev, &pdev->dev);\n\tpci_set_drvdata(pdev, dev);\n\n\tpriv->map = ioremap(mem_addr, mem_len);\n\tif (!priv->map) {\n\t\tdev_err(&pdev->dev, \"Cannot map device memory\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_free_dev;\n\t}\n\n\tpriv->ring_control = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t\tsizeof(*priv->ring_control),\n\t\t\t\t\t\t&priv->ring_control_dma, GFP_KERNEL);\n\tif (!priv->ring_control) {\n\t\tdev_err(&pdev->dev, \"Cannot allocate rings\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_iounmap;\n\t}\n\tpriv->common.open = p54p_open;\n\tpriv->common.stop = p54p_stop;\n\tpriv->common.tx = p54p_tx;\n\n\tspin_lock_init(&priv->lock);\n\ttasklet_setup(&priv->tasklet, p54p_tasklet);\n\n\terr = request_firmware_nowait(THIS_MODULE, 1, \"isl3886pci\",\n\t\t\t\t      &priv->pdev->dev, GFP_KERNEL,\n\t\t\t\t      priv, p54p_firmware_step2);\n\tif (!err)\n\t\treturn 0;\n\n\tdma_free_coherent(&pdev->dev, sizeof(*priv->ring_control),\n\t\t\t  priv->ring_control, priv->ring_control_dma);\n\n err_iounmap:\n\tiounmap(priv->map);\n\n err_free_dev:\n\tp54_free_common(dev);\n\n err_free_reg:\n\tpci_release_regions(pdev);\n err_disable_dev:\n\tpci_disable_device(pdev);\nerr_put:\n\tpci_dev_put(pdev);\n\treturn err;\n}\n\nstatic void p54p_remove(struct pci_dev *pdev)\n{\n\tstruct ieee80211_hw *dev = pci_get_drvdata(pdev);\n\tstruct p54p_priv *priv;\n\n\tif (!dev)\n\t\treturn;\n\n\tpriv = dev->priv;\n\twait_for_completion(&priv->fw_loaded);\n\tp54_unregister_common(dev);\n\trelease_firmware(priv->firmware);\n\tdma_free_coherent(&pdev->dev, sizeof(*priv->ring_control),\n\t\t\t  priv->ring_control, priv->ring_control_dma);\n\tiounmap(priv->map);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tp54_free_common(dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int p54p_suspend(struct device *device)\n{\n\tstruct pci_dev *pdev = to_pci_dev(device);\n\n\tpci_save_state(pdev);\n\tpci_set_power_state(pdev, PCI_D3hot);\n\tpci_disable_device(pdev);\n\treturn 0;\n}\n\nstatic int p54p_resume(struct device *device)\n{\n\tstruct pci_dev *pdev = to_pci_dev(device);\n\tint err;\n\n\terr = pci_reenable_device(pdev);\n\tif (err)\n\t\treturn err;\n\treturn pci_set_power_state(pdev, PCI_D0);\n}\n\nstatic SIMPLE_DEV_PM_OPS(p54pci_pm_ops, p54p_suspend, p54p_resume);\n\n#define P54P_PM_OPS (&p54pci_pm_ops)\n#else\n#define P54P_PM_OPS (NULL)\n#endif  \n\nstatic struct pci_driver p54p_driver = {\n\t.name\t\t= \"p54pci\",\n\t.id_table\t= p54p_table,\n\t.probe\t\t= p54p_probe,\n\t.remove\t\t= p54p_remove,\n\t.driver.pm\t= P54P_PM_OPS,\n};\n\nmodule_pci_driver(p54p_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}