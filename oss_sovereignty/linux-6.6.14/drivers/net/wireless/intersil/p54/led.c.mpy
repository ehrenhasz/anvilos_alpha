{
  "module_name": "led.c",
  "hash_id": "96acfc79e23e136b176258793958d92f3bb88af7cca5ef9c09ac35e8ff565e35",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/p54/led.c",
  "human_readable_source": "\n \n\n#include <linux/firmware.h>\n#include <linux/etherdevice.h>\n\n#include <net/mac80211.h>\n#ifdef CONFIG_P54_LEDS\n#include <linux/leds.h>\n#endif  \n\n#include \"p54.h\"\n#include \"lmac.h\"\n\nstatic void p54_update_leds(struct work_struct *work)\n{\n\tstruct p54_common *priv = container_of(work, struct p54_common,\n\t\t\t\t\t       led_work.work);\n\tint err, i, tmp, blink_delay = 400;\n\tbool rerun = false;\n\n\t \n\tif (priv->mode == NL80211_IFTYPE_UNSPECIFIED)\n\t\treturn ;\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->leds); i++)\n\t\tif (priv->leds[i].toggled) {\n\t\t\tpriv->softled_state |= BIT(i);\n\n\t\t\ttmp = 70 + 200 / (priv->leds[i].toggled);\n\t\t\tif (tmp < blink_delay)\n\t\t\t\tblink_delay = tmp;\n\n\t\t\tif (priv->leds[i].led_dev.brightness == LED_OFF)\n\t\t\t\trerun = true;\n\n\t\t\tpriv->leds[i].toggled =\n\t\t\t\t!!priv->leds[i].led_dev.brightness;\n\t\t} else\n\t\t\tpriv->softled_state &= ~BIT(i);\n\n\terr = p54_set_leds(priv);\n\tif (err && net_ratelimit())\n\t\twiphy_err(priv->hw->wiphy,\n\t\t\t  \"failed to update LEDs (%d).\\n\", err);\n\n\tif (rerun)\n\t\tieee80211_queue_delayed_work(priv->hw, &priv->led_work,\n\t\t\tmsecs_to_jiffies(blink_delay));\n}\n\nstatic void p54_led_brightness_set(struct led_classdev *led_dev,\n\t\t\t\t   enum led_brightness brightness)\n{\n\tstruct p54_led_dev *led = container_of(led_dev, struct p54_led_dev,\n\t\t\t\t\t       led_dev);\n\tstruct ieee80211_hw *dev = led->hw_dev;\n\tstruct p54_common *priv = dev->priv;\n\n\tif (priv->mode == NL80211_IFTYPE_UNSPECIFIED)\n\t\treturn ;\n\n\tif ((brightness) && (led->registered)) {\n\t\tled->toggled++;\n\t\tieee80211_queue_delayed_work(priv->hw, &priv->led_work, HZ/10);\n\t}\n}\n\nstatic int p54_register_led(struct p54_common *priv,\n\t\t\t    unsigned int led_index,\n\t\t\t    char *name, const char *trigger)\n{\n\tstruct p54_led_dev *led = &priv->leds[led_index];\n\tint err;\n\n\tif (led->registered)\n\t\treturn -EEXIST;\n\n\tsnprintf(led->name, sizeof(led->name), \"p54-%s::%s\",\n\t\t wiphy_name(priv->hw->wiphy), name);\n\tled->hw_dev = priv->hw;\n\tled->index = led_index;\n\tled->led_dev.name = led->name;\n\tled->led_dev.default_trigger = trigger;\n\tled->led_dev.brightness_set = p54_led_brightness_set;\n\n\terr = led_classdev_register(wiphy_dev(priv->hw->wiphy), &led->led_dev);\n\tif (err)\n\t\twiphy_err(priv->hw->wiphy,\n\t\t\t  \"Failed to register %s LED.\\n\", name);\n\telse\n\t\tled->registered = 1;\n\n\treturn err;\n}\n\nint p54_init_leds(struct p54_common *priv)\n{\n\tint err;\n\n\t \n\n\tINIT_DELAYED_WORK(&priv->led_work, p54_update_leds);\n\n\terr = p54_register_led(priv, 0, \"assoc\",\n\t\t\t       ieee80211_get_assoc_led_name(priv->hw));\n\tif (err)\n\t\treturn err;\n\n\terr = p54_register_led(priv, 1, \"tx\",\n\t\t\t       ieee80211_get_tx_led_name(priv->hw));\n\tif (err)\n\t\treturn err;\n\n\terr = p54_register_led(priv, 2, \"rx\",\n\t\t\t       ieee80211_get_rx_led_name(priv->hw));\n\tif (err)\n\t\treturn err;\n\n\terr = p54_register_led(priv, 3, \"radio\",\n\t\t\t       ieee80211_get_radio_led_name(priv->hw));\n\tif (err)\n\t\treturn err;\n\n\terr = p54_set_leds(priv);\n\treturn err;\n}\n\nvoid p54_unregister_leds(struct p54_common *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->leds); i++) {\n\t\tif (priv->leds[i].registered) {\n\t\t\tpriv->leds[i].registered = false;\n\t\t\tpriv->leds[i].toggled = 0;\n\t\t\tled_classdev_unregister(&priv->leds[i].led_dev);\n\t\t}\n\t}\n\n\tcancel_delayed_work_sync(&priv->led_work);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}