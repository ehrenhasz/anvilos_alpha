{
  "module_name": "txrx.c",
  "hash_id": "290f19c77bc766a7e38bec5f930137271b2e42dee69fa45ab100b5c7e7e998c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/p54/txrx.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/firmware.h>\n#include <linux/etherdevice.h>\n#include <asm/div64.h>\n\n#include <net/mac80211.h>\n\n#include \"p54.h\"\n#include \"lmac.h\"\n\n#ifdef P54_MM_DEBUG\nstatic void p54_dump_tx_queue(struct p54_common *priv)\n{\n\tunsigned long flags;\n\tstruct ieee80211_tx_info *info;\n\tstruct p54_tx_info *range;\n\tstruct sk_buff *skb;\n\tstruct p54_hdr *hdr;\n\tunsigned int i = 0;\n\tu32 prev_addr;\n\tu32 largest_hole = 0, free;\n\n\tspin_lock_irqsave(&priv->tx_queue.lock, flags);\n\twiphy_debug(priv->hw->wiphy, \"/ --- tx queue dump (%d entries) ---\\n\",\n\t\t    skb_queue_len(&priv->tx_queue));\n\n\tprev_addr = priv->rx_start;\n\tskb_queue_walk(&priv->tx_queue, skb) {\n\t\tinfo = IEEE80211_SKB_CB(skb);\n\t\trange = (void *) info->rate_driver_data;\n\t\thdr = (void *) skb->data;\n\n\t\tfree = range->start_addr - prev_addr;\n\t\twiphy_debug(priv->hw->wiphy,\n\t\t\t    \"| [%02d] => [skb:%p skb_len:0x%04x \"\n\t\t\t    \"hdr:{flags:%02x len:%04x req_id:%04x type:%02x} \"\n\t\t\t    \"mem:{start:%04x end:%04x, free:%d}]\\n\",\n\t\t\t    i++, skb, skb->len,\n\t\t\t    le16_to_cpu(hdr->flags), le16_to_cpu(hdr->len),\n\t\t\t    le32_to_cpu(hdr->req_id), le16_to_cpu(hdr->type),\n\t\t\t    range->start_addr, range->end_addr, free);\n\n\t\tprev_addr = range->end_addr;\n\t\tlargest_hole = max(largest_hole, free);\n\t}\n\tfree = priv->rx_end - prev_addr;\n\tlargest_hole = max(largest_hole, free);\n\twiphy_debug(priv->hw->wiphy,\n\t\t    \"\\\\ --- [free: %d], largest free block: %d ---\\n\",\n\t\t    free, largest_hole);\n\tspin_unlock_irqrestore(&priv->tx_queue.lock, flags);\n}\n#endif  \n\n \nstatic int p54_assign_address(struct p54_common *priv, struct sk_buff *skb)\n{\n\tstruct sk_buff *entry, *target_skb = NULL;\n\tstruct ieee80211_tx_info *info;\n\tstruct p54_tx_info *range;\n\tstruct p54_hdr *data = (void *) skb->data;\n\tunsigned long flags;\n\tu32 last_addr = priv->rx_start;\n\tu32 target_addr = priv->rx_start;\n\tu16 len = priv->headroom + skb->len + priv->tailroom + 3;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\trange = (void *) info->rate_driver_data;\n\tlen = (range->extra_len + len) & ~0x3;\n\n\tspin_lock_irqsave(&priv->tx_queue.lock, flags);\n\tif (unlikely(skb_queue_len(&priv->tx_queue) == 32)) {\n\t\t \n\t\tspin_unlock_irqrestore(&priv->tx_queue.lock, flags);\n\t\treturn -EBUSY;\n\t}\n\n\tskb_queue_walk(&priv->tx_queue, entry) {\n\t\tu32 hole_size;\n\t\tinfo = IEEE80211_SKB_CB(entry);\n\t\trange = (void *) info->rate_driver_data;\n\t\thole_size = range->start_addr - last_addr;\n\n\t\tif (!target_skb && hole_size >= len) {\n\t\t\ttarget_skb = entry->prev;\n\t\t\thole_size -= len;\n\t\t\ttarget_addr = last_addr;\n\t\t\tbreak;\n\t\t}\n\t\tlast_addr = range->end_addr;\n\t}\n\tif (unlikely(!target_skb)) {\n\t\tif (priv->rx_end - last_addr >= len) {\n\t\t\ttarget_skb = skb_peek_tail(&priv->tx_queue);\n\t\t\tif (target_skb) {\n\t\t\t\tinfo = IEEE80211_SKB_CB(target_skb);\n\t\t\t\trange = (void *)info->rate_driver_data;\n\t\t\t\ttarget_addr = range->end_addr;\n\t\t\t}\n\t\t} else {\n\t\t\tspin_unlock_irqrestore(&priv->tx_queue.lock, flags);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t}\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\trange = (void *) info->rate_driver_data;\n\trange->start_addr = target_addr;\n\trange->end_addr = target_addr + len;\n\tdata->req_id = cpu_to_le32(target_addr + priv->headroom);\n\tif (IS_DATA_FRAME(skb) &&\n\t    unlikely(GET_HW_QUEUE(skb) == P54_QUEUE_BEACON))\n\t\tpriv->beacon_req_id = data->req_id;\n\n\tif (target_skb)\n\t\t__skb_queue_after(&priv->tx_queue, target_skb, skb);\n\telse\n\t\t__skb_queue_head(&priv->tx_queue, skb);\n\tspin_unlock_irqrestore(&priv->tx_queue.lock, flags);\n\treturn 0;\n}\n\nstatic void p54_tx_pending(struct p54_common *priv)\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = skb_dequeue(&priv->tx_pending);\n\tif (unlikely(!skb))\n\t\treturn ;\n\n\tret = p54_assign_address(priv, skb);\n\tif (unlikely(ret))\n\t\tskb_queue_head(&priv->tx_pending, skb);\n\telse\n\t\tpriv->tx(priv->hw, skb);\n}\n\nstatic void p54_wake_queues(struct p54_common *priv)\n{\n\tunsigned long flags;\n\tunsigned int i;\n\n\tif (unlikely(priv->mode == NL80211_IFTYPE_UNSPECIFIED))\n\t\treturn ;\n\n\tp54_tx_pending(priv);\n\n\tspin_lock_irqsave(&priv->tx_stats_lock, flags);\n\tfor (i = 0; i < priv->hw->queues; i++) {\n\t\tif (priv->tx_stats[i + P54_QUEUE_DATA].len <\n\t\t    priv->tx_stats[i + P54_QUEUE_DATA].limit)\n\t\t\tieee80211_wake_queue(priv->hw, i);\n\t}\n\tspin_unlock_irqrestore(&priv->tx_stats_lock, flags);\n}\n\nstatic int p54_tx_qos_accounting_alloc(struct p54_common *priv,\n\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t       const u16 p54_queue)\n{\n\tstruct p54_tx_queue_stats *queue;\n\tunsigned long flags;\n\n\tif (WARN_ON(p54_queue >= P54_QUEUE_NUM))\n\t\treturn -EINVAL;\n\n\tqueue = &priv->tx_stats[p54_queue];\n\n\tspin_lock_irqsave(&priv->tx_stats_lock, flags);\n\tif (unlikely(queue->len >= queue->limit && IS_QOS_QUEUE(p54_queue))) {\n\t\tspin_unlock_irqrestore(&priv->tx_stats_lock, flags);\n\t\treturn -ENOSPC;\n\t}\n\n\tqueue->len++;\n\tqueue->count++;\n\n\tif (unlikely(queue->len == queue->limit && IS_QOS_QUEUE(p54_queue))) {\n\t\tu16 ac_queue = p54_queue - P54_QUEUE_DATA;\n\t\tieee80211_stop_queue(priv->hw, ac_queue);\n\t}\n\n\tspin_unlock_irqrestore(&priv->tx_stats_lock, flags);\n\treturn 0;\n}\n\nstatic void p54_tx_qos_accounting_free(struct p54_common *priv,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tif (IS_DATA_FRAME(skb)) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&priv->tx_stats_lock, flags);\n\t\tpriv->tx_stats[GET_HW_QUEUE(skb)].len--;\n\t\tspin_unlock_irqrestore(&priv->tx_stats_lock, flags);\n\n\t\tif (unlikely(GET_HW_QUEUE(skb) == P54_QUEUE_BEACON)) {\n\t\t\tif (priv->beacon_req_id == GET_REQ_ID(skb)) {\n\t\t\t\t \n\t\t\t\tpriv->beacon_req_id = 0;\n\t\t\t}\n\t\t\tcomplete(&priv->beacon_comp);\n\t\t}\n\t}\n\tp54_wake_queues(priv);\n}\n\nvoid p54_free_skb(struct ieee80211_hw *dev, struct sk_buff *skb)\n{\n\tstruct p54_common *priv = dev->priv;\n\tif (unlikely(!skb))\n\t\treturn ;\n\n\tskb_unlink(skb, &priv->tx_queue);\n\tp54_tx_qos_accounting_free(priv, skb);\n\tieee80211_free_txskb(dev, skb);\n}\nEXPORT_SYMBOL_GPL(p54_free_skb);\n\nstatic struct sk_buff *p54_find_and_unlink_skb(struct p54_common *priv,\n\t\t\t\t\t       const __le32 req_id)\n{\n\tstruct sk_buff *entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->tx_queue.lock, flags);\n\tskb_queue_walk(&priv->tx_queue, entry) {\n\t\tstruct p54_hdr *hdr = (struct p54_hdr *) entry->data;\n\n\t\tif (hdr->req_id == req_id) {\n\t\t\t__skb_unlink(entry, &priv->tx_queue);\n\t\t\tspin_unlock_irqrestore(&priv->tx_queue.lock, flags);\n\t\t\tp54_tx_qos_accounting_free(priv, entry);\n\t\t\treturn entry;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&priv->tx_queue.lock, flags);\n\treturn NULL;\n}\n\nvoid p54_tx(struct p54_common *priv, struct sk_buff *skb)\n{\n\tskb_queue_tail(&priv->tx_pending, skb);\n\tp54_tx_pending(priv);\n}\n\nstatic int p54_rssi_to_dbm(struct p54_common *priv, int rssi)\n{\n\tif (priv->rxhw != 5) {\n\t\treturn ((rssi * priv->cur_rssi->mul) / 64 +\n\t\t\t priv->cur_rssi->add) / 4;\n\t} else {\n\t\t \n\t\treturn rssi / 2 - 110;\n\t}\n}\n\n \nstatic void p54_pspoll_workaround(struct p54_common *priv, struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (void *) skb->data;\n\tstruct ieee80211_tim_ie *tim_ie;\n\tu8 *tim;\n\tu8 tim_len;\n\tbool new_psm;\n\n\t \n\tif (!ieee80211_is_beacon(hdr->frame_control))\n\t\treturn;\n\n\tif (!priv->aid)\n\t\treturn;\n\n\t \n\tif (!ether_addr_equal_64bits(hdr->addr3, priv->bssid))\n\t\treturn;\n\n\ttim = p54_find_ie(skb, WLAN_EID_TIM);\n\tif (!tim)\n\t\treturn;\n\n\ttim_len = tim[1];\n\ttim_ie = (struct ieee80211_tim_ie *) &tim[2];\n\n\tnew_psm = ieee80211_check_tim(tim_ie, tim_len, priv->aid);\n\tif (new_psm != priv->powersave_override) {\n\t\tpriv->powersave_override = new_psm;\n\t\tp54_set_ps(priv);\n\t}\n}\n\nstatic int p54_rx_data(struct p54_common *priv, struct sk_buff *skb)\n{\n\tstruct p54_rx_data *hdr = (struct p54_rx_data *) skb->data;\n\tstruct ieee80211_rx_status *rx_status = IEEE80211_SKB_RXCB(skb);\n\tu16 freq = le16_to_cpu(hdr->freq);\n\tsize_t header_len = sizeof(*hdr);\n\tu32 tsf32;\n\t__le16 fc;\n\tu8 rate = hdr->rate & 0xf;\n\n\t \n\tif (unlikely(priv->mode == NL80211_IFTYPE_UNSPECIFIED))\n\t\treturn 0;\n\n\tif (!(hdr->flags & cpu_to_le16(P54_HDR_FLAG_DATA_IN_FCS_GOOD)))\n\t\treturn 0;\n\n\tif (hdr->decrypt_status == P54_DECRYPT_OK)\n\t\trx_status->flag |= RX_FLAG_DECRYPTED;\n\tif ((hdr->decrypt_status == P54_DECRYPT_FAIL_MICHAEL) ||\n\t    (hdr->decrypt_status == P54_DECRYPT_FAIL_TKIP))\n\t\trx_status->flag |= RX_FLAG_MMIC_ERROR;\n\n\trx_status->signal = p54_rssi_to_dbm(priv, hdr->rssi);\n\tif (hdr->rate & 0x10)\n\t\trx_status->enc_flags |= RX_ENC_FLAG_SHORTPRE;\n\tif (priv->hw->conf.chandef.chan->band == NL80211_BAND_5GHZ)\n\t\trx_status->rate_idx = (rate < 4) ? 0 : rate - 4;\n\telse\n\t\trx_status->rate_idx = rate;\n\n\trx_status->freq = freq;\n\trx_status->band =  priv->hw->conf.chandef.chan->band;\n\trx_status->antenna = hdr->antenna;\n\n\ttsf32 = le32_to_cpu(hdr->tsf32);\n\tif (tsf32 < priv->tsf_low32)\n\t\tpriv->tsf_high32++;\n\trx_status->mactime = ((u64)priv->tsf_high32) << 32 | tsf32;\n\tpriv->tsf_low32 = tsf32;\n\n\t \n\trx_status->flag |= RX_FLAG_MACTIME_END;\n\n\tif (hdr->flags & cpu_to_le16(P54_HDR_FLAG_DATA_ALIGN))\n\t\theader_len += hdr->align[0];\n\n\tskb_pull(skb, header_len);\n\tskb_trim(skb, le16_to_cpu(hdr->len));\n\n\tfc = ((struct ieee80211_hdr *)skb->data)->frame_control;\n\tif (ieee80211_is_probe_resp(fc) || ieee80211_is_beacon(fc))\n\t\trx_status->boottime_ns = ktime_get_boottime_ns();\n\n\tif (unlikely(priv->hw->conf.flags & IEEE80211_CONF_PS))\n\t\tp54_pspoll_workaround(priv, skb);\n\n\tieee80211_rx_irqsafe(priv->hw, skb);\n\n\tieee80211_queue_delayed_work(priv->hw, &priv->work,\n\t\t\t   msecs_to_jiffies(P54_STATISTICS_UPDATE));\n\n\treturn -1;\n}\n\nstatic void p54_rx_frame_sent(struct p54_common *priv, struct sk_buff *skb)\n{\n\tstruct p54_hdr *hdr = (struct p54_hdr *) skb->data;\n\tstruct p54_frame_sent *payload = (struct p54_frame_sent *) hdr->data;\n\tstruct ieee80211_tx_info *info;\n\tstruct p54_hdr *entry_hdr;\n\tstruct p54_tx_data *entry_data;\n\tstruct sk_buff *entry;\n\tunsigned int pad = 0, frame_len;\n\tint count, idx;\n\n\tentry = p54_find_and_unlink_skb(priv, hdr->req_id);\n\tif (unlikely(!entry))\n\t\treturn ;\n\n\tframe_len = entry->len;\n\tinfo = IEEE80211_SKB_CB(entry);\n\tentry_hdr = (struct p54_hdr *) entry->data;\n\tentry_data = (struct p54_tx_data *) entry_hdr->data;\n\tpriv->stats.dot11ACKFailureCount += payload->tries - 1;\n\n\t \n\tif (unlikely(entry_data->hw_queue < P54_QUEUE_FWSCAN)) {\n\t\tdev_kfree_skb_any(entry);\n\t\treturn ;\n\t}\n\n\t \n\tmemset_after(&info->status, 0, rates);\n\n\tif (entry_hdr->flags & cpu_to_le16(P54_HDR_FLAG_DATA_ALIGN))\n\t\tpad = entry_data->align[0];\n\n\t \n\tcount = payload->tries;\n\tfor (idx = 0; idx < 4; idx++) {\n\t\tif (count >= info->status.rates[idx].count) {\n\t\t\tcount -= info->status.rates[idx].count;\n\t\t} else if (count > 0) {\n\t\t\tinfo->status.rates[idx].count = count;\n\t\t\tcount = 0;\n\t\t} else {\n\t\t\tinfo->status.rates[idx].idx = -1;\n\t\t\tinfo->status.rates[idx].count = 0;\n\t\t}\n\t}\n\n\tif (!(info->flags & IEEE80211_TX_CTL_NO_ACK) &&\n\t     !(payload->status & P54_TX_FAILED))\n\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\tif (payload->status & P54_TX_PSM_CANCELLED)\n\t\tinfo->flags |= IEEE80211_TX_STAT_TX_FILTERED;\n\tinfo->status.ack_signal = p54_rssi_to_dbm(priv,\n\t\t\t\t\t\t  (int)payload->ack_rssi);\n\n\t \n\tswitch (entry_data->key_type) {\n\tcase P54_CRYPTO_TKIPMICHAEL: {\n\t\tu8 *iv = (u8 *)(entry_data->align + pad +\n\t\t\t\tentry_data->crypt_offset);\n\n\t\t \n\t\tiv[2] = iv[0];\n\t\tiv[0] = iv[1];\n\t\tiv[1] = (iv[0] | 0x20) & 0x7f;\t \n\n\t\tframe_len -= 12;  \n\t\tbreak;\n\t\t}\n\tcase P54_CRYPTO_AESCCMP:\n\t\tframe_len -= 8;  \n\t\tbreak;\n\tcase P54_CRYPTO_WEP:\n\t\tframe_len -= 4;  \n\t\tbreak;\n\t}\n\n\tskb_trim(entry, frame_len);\n\tskb_pull(entry, sizeof(*hdr) + pad + sizeof(*entry_data));\n\tieee80211_tx_status_irqsafe(priv->hw, entry);\n}\n\nstatic void p54_rx_eeprom_readback(struct p54_common *priv,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct p54_hdr *hdr = (struct p54_hdr *) skb->data;\n\tstruct p54_eeprom_lm86 *eeprom = (struct p54_eeprom_lm86 *) hdr->data;\n\tstruct sk_buff *tmp;\n\n\tif (!priv->eeprom)\n\t\treturn ;\n\n\tif (priv->fw_var >= 0x509) {\n\t\tmemcpy(priv->eeprom, eeprom->v2.data,\n\t\t       le16_to_cpu(eeprom->v2.len));\n\t} else {\n\t\tmemcpy(priv->eeprom, eeprom->v1.data,\n\t\t       le16_to_cpu(eeprom->v1.len));\n\t}\n\n\tpriv->eeprom = NULL;\n\ttmp = p54_find_and_unlink_skb(priv, hdr->req_id);\n\tdev_kfree_skb_any(tmp);\n\tcomplete(&priv->eeprom_comp);\n}\n\nstatic void p54_rx_stats(struct p54_common *priv, struct sk_buff *skb)\n{\n\tstruct p54_hdr *hdr = (struct p54_hdr *) skb->data;\n\tstruct p54_statistics *stats = (struct p54_statistics *) hdr->data;\n\tstruct sk_buff *tmp;\n\tstruct ieee80211_channel *chan;\n\tunsigned int i, rssi, tx, cca, dtime, dtotal, dcca, dtx, drssi, unit;\n\tu32 tsf32;\n\n\tif (unlikely(priv->mode == NL80211_IFTYPE_UNSPECIFIED))\n\t\treturn ;\n\n\ttsf32 = le32_to_cpu(stats->tsf32);\n\tif (tsf32 < priv->tsf_low32)\n\t\tpriv->tsf_high32++;\n\tpriv->tsf_low32 = tsf32;\n\n\tpriv->stats.dot11RTSFailureCount = le32_to_cpu(stats->rts_fail);\n\tpriv->stats.dot11RTSSuccessCount = le32_to_cpu(stats->rts_success);\n\tpriv->stats.dot11FCSErrorCount = le32_to_cpu(stats->rx_bad_fcs);\n\n\tpriv->noise = p54_rssi_to_dbm(priv, le32_to_cpu(stats->noise));\n\n\t \n\tdtime = tsf32 - priv->survey_raw.timestamp;\n\n\t \n\tcca = le32_to_cpu(stats->sample_cca);\n\ttx = le32_to_cpu(stats->sample_tx);\n\trssi = 0;\n\tfor (i = 0; i < ARRAY_SIZE(stats->sample_noise); i++)\n\t\trssi += le32_to_cpu(stats->sample_noise[i]);\n\n\tdcca = cca - priv->survey_raw.cached_cca;\n\tdrssi = rssi - priv->survey_raw.cached_rssi;\n\tdtx = tx - priv->survey_raw.cached_tx;\n\tdtotal = dcca + drssi + dtx;\n\n\t \n\tif (dtotal && (priv->update_stats || dtime >= USEC_PER_SEC) &&\n\t    dtime >= dtotal) {\n\t\tpriv->survey_raw.timestamp = tsf32;\n\t\tpriv->update_stats = false;\n\t\tunit = dtime / dtotal;\n\n\t\tif (dcca) {\n\t\t\tpriv->survey_raw.cca += dcca * unit;\n\t\t\tpriv->survey_raw.cached_cca = cca;\n\t\t}\n\t\tif (dtx) {\n\t\t\tpriv->survey_raw.tx += dtx * unit;\n\t\t\tpriv->survey_raw.cached_tx = tx;\n\t\t}\n\t\tif (drssi) {\n\t\t\tpriv->survey_raw.rssi += drssi * unit;\n\t\t\tpriv->survey_raw.cached_rssi = rssi;\n\t\t}\n\n\t\t \n\t\tif (!(priv->phy_ps || priv->phy_idle))\n\t\t\tpriv->survey_raw.active += dtotal * unit;\n\t\telse\n\t\t\tpriv->survey_raw.active += (dcca + dtx) * unit;\n\t}\n\n\tchan = priv->curchan;\n\tif (chan) {\n\t\tstruct survey_info *survey = &priv->survey[chan->hw_value];\n\t\tsurvey->noise = clamp(priv->noise, -128, 127);\n\t\tsurvey->time = priv->survey_raw.active;\n\t\tsurvey->time_tx = priv->survey_raw.tx;\n\t\tsurvey->time_busy = priv->survey_raw.tx +\n\t\t\tpriv->survey_raw.cca;\n\t\tdo_div(survey->time, 1024);\n\t\tdo_div(survey->time_tx, 1024);\n\t\tdo_div(survey->time_busy, 1024);\n\t}\n\n\ttmp = p54_find_and_unlink_skb(priv, hdr->req_id);\n\tdev_kfree_skb_any(tmp);\n\tcomplete(&priv->stat_comp);\n}\n\nstatic void p54_rx_trap(struct p54_common *priv, struct sk_buff *skb)\n{\n\tstruct p54_hdr *hdr = (struct p54_hdr *) skb->data;\n\tstruct p54_trap *trap = (struct p54_trap *) hdr->data;\n\tu16 event = le16_to_cpu(trap->event);\n\tu16 freq = le16_to_cpu(trap->frequency);\n\n\tswitch (event) {\n\tcase P54_TRAP_BEACON_TX:\n\t\tbreak;\n\tcase P54_TRAP_RADAR:\n\t\twiphy_info(priv->hw->wiphy, \"radar (freq:%d MHz)\\n\", freq);\n\t\tbreak;\n\tcase P54_TRAP_NO_BEACON:\n\t\tif (priv->vif)\n\t\t\tieee80211_beacon_loss(priv->vif);\n\t\tbreak;\n\tcase P54_TRAP_SCAN:\n\t\tbreak;\n\tcase P54_TRAP_TBTT:\n\t\tbreak;\n\tcase P54_TRAP_TIMER:\n\t\tbreak;\n\tcase P54_TRAP_FAA_RADIO_OFF:\n\t\twiphy_rfkill_set_hw_state(priv->hw->wiphy, true);\n\t\tbreak;\n\tcase P54_TRAP_FAA_RADIO_ON:\n\t\twiphy_rfkill_set_hw_state(priv->hw->wiphy, false);\n\t\tbreak;\n\tdefault:\n\t\twiphy_info(priv->hw->wiphy, \"received event:%x freq:%d\\n\",\n\t\t\t   event, freq);\n\t\tbreak;\n\t}\n}\n\nstatic int p54_rx_control(struct p54_common *priv, struct sk_buff *skb)\n{\n\tstruct p54_hdr *hdr = (struct p54_hdr *) skb->data;\n\n\tswitch (le16_to_cpu(hdr->type)) {\n\tcase P54_CONTROL_TYPE_TXDONE:\n\t\tp54_rx_frame_sent(priv, skb);\n\t\tbreak;\n\tcase P54_CONTROL_TYPE_TRAP:\n\t\tp54_rx_trap(priv, skb);\n\t\tbreak;\n\tcase P54_CONTROL_TYPE_BBP:\n\t\tbreak;\n\tcase P54_CONTROL_TYPE_STAT_READBACK:\n\t\tp54_rx_stats(priv, skb);\n\t\tbreak;\n\tcase P54_CONTROL_TYPE_EEPROM_READBACK:\n\t\tp54_rx_eeprom_readback(priv, skb);\n\t\tbreak;\n\tdefault:\n\t\twiphy_debug(priv->hw->wiphy,\n\t\t\t    \"not handling 0x%02x type control frame\\n\",\n\t\t\t    le16_to_cpu(hdr->type));\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nint p54_rx(struct ieee80211_hw *dev, struct sk_buff *skb)\n{\n\tstruct p54_common *priv = dev->priv;\n\tu16 type = le16_to_cpu(*((__le16 *)skb->data));\n\n\tif (type & P54_HDR_FLAG_CONTROL)\n\t\treturn p54_rx_control(priv, skb);\n\telse\n\t\treturn p54_rx_data(priv, skb);\n}\nEXPORT_SYMBOL_GPL(p54_rx);\n\nstatic void p54_tx_80211_header(struct p54_common *priv, struct sk_buff *skb,\n\t\t\t\tstruct ieee80211_tx_info *info,\n\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\tu8 *queue, u32 *extra_len, u16 *flags, u16 *aid,\n\t\t\t\tbool *burst_possible)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\n\tif (ieee80211_is_data_qos(hdr->frame_control))\n\t\t*burst_possible = true;\n\telse\n\t\t*burst_possible = false;\n\n\tif (!(info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ))\n\t\t*flags |= P54_HDR_FLAG_DATA_OUT_SEQNR;\n\n\tif (info->flags & IEEE80211_TX_CTL_NO_PS_BUFFER)\n\t\t*flags |= P54_HDR_FLAG_DATA_OUT_NOCANCEL;\n\n\tif (info->flags & IEEE80211_TX_CTL_CLEAR_PS_FILT)\n\t\t*flags |= P54_HDR_FLAG_DATA_OUT_NOCANCEL;\n\n\t*queue = skb_get_queue_mapping(skb) + P54_QUEUE_DATA;\n\n\tswitch (priv->mode) {\n\tcase NL80211_IFTYPE_MONITOR:\n\t\t \n\t\t*aid = 0;\n\t\t*flags |= P54_HDR_FLAG_DATA_OUT_PROMISC;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\t*aid = 1;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM) {\n\t\t\t*aid = 0;\n\t\t\t*queue = P54_QUEUE_CAB;\n\t\t\treturn;\n\t\t}\n\n\t\tif (unlikely(ieee80211_is_mgmt(hdr->frame_control))) {\n\t\t\tif (ieee80211_is_probe_resp(hdr->frame_control)) {\n\t\t\t\t*aid = 0;\n\t\t\t\t*flags |= P54_HDR_FLAG_DATA_OUT_TIMESTAMP |\n\t\t\t\t\t  P54_HDR_FLAG_DATA_OUT_NOCANCEL;\n\t\t\t\treturn;\n\t\t\t} else if (ieee80211_is_beacon(hdr->frame_control)) {\n\t\t\t\t*aid = 0;\n\n\t\t\t\tif (info->flags & IEEE80211_TX_CTL_INJECTED) {\n\t\t\t\t\t \n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t*flags |= P54_HDR_FLAG_DATA_OUT_TIMESTAMP;\n\t\t\t\t*queue = P54_QUEUE_BEACON;\n\t\t\t\t*extra_len = IEEE80211_MAX_TIM_LEN;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (sta)\n\t\t\t*aid = sta->aid;\n\t\tbreak;\n\t}\n}\n\nstatic u8 p54_convert_algo(u32 cipher)\n{\n\tswitch (cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\treturn P54_CRYPTO_WEP;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\treturn P54_CRYPTO_TKIPMICHAEL;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\treturn P54_CRYPTO_AESCCMP;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nvoid p54_tx_80211(struct ieee80211_hw *dev,\n\t\t  struct ieee80211_tx_control *control,\n\t\t  struct sk_buff *skb)\n{\n\tstruct p54_common *priv = dev->priv;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct p54_tx_info *p54info;\n\tstruct p54_hdr *hdr;\n\tstruct p54_tx_data *txhdr;\n\tunsigned int padding, len, extra_len = 0;\n\tint i, j, ridx;\n\tu16 hdr_flags = 0, aid = 0;\n\tu8 rate, queue = 0, crypt_offset = 0;\n\tu8 cts_rate = 0x20;\n\tu8 rc_flags;\n\tu8 calculated_tries[4];\n\tu8 nrates = 0, nremaining = 8;\n\tbool burst_allowed = false;\n\n\tp54_tx_80211_header(priv, skb, info, control->sta, &queue, &extra_len,\n\t\t\t    &hdr_flags, &aid, &burst_allowed);\n\n\tif (p54_tx_qos_accounting_alloc(priv, skb, queue)) {\n\t\tieee80211_free_txskb(dev, skb);\n\t\treturn;\n\t}\n\n\tpadding = (unsigned long)(skb->data - (sizeof(*hdr) + sizeof(*txhdr))) & 3;\n\tlen = skb->len;\n\n\tif (info->control.hw_key) {\n\t\tcrypt_offset = ieee80211_get_hdrlen_from_skb(skb);\n\t\tif (info->control.hw_key->cipher == WLAN_CIPHER_SUITE_TKIP) {\n\t\t\tu8 *iv = (u8 *)(skb->data + crypt_offset);\n\t\t\t \n\t\t\tiv[1] = iv[0];\n\t\t\tiv[0] = iv[2];\n\t\t\tiv[2] = 0;\n\t\t}\n\t}\n\n\ttxhdr = skb_push(skb, sizeof(*txhdr) + padding);\n\thdr = skb_push(skb, sizeof(*hdr));\n\n\tif (padding)\n\t\thdr_flags |= P54_HDR_FLAG_DATA_ALIGN;\n\thdr->type = cpu_to_le16(aid);\n\thdr->rts_tries = info->control.rates[0].count;\n\n\t \n\tcts_rate = info->control.rts_cts_rate_idx;\n\n\tmemset(&txhdr->rateset, 0, sizeof(txhdr->rateset));\n\n\t \n\tfor (i = 0; i < dev->max_rates; i++) {\n\t\tif (info->control.rates[i].idx < 0)\n\t\t\tbreak;\n\t\tnrates++;\n\t}\n\n\t \n\tfor (i = 0; i < nrates; i++) {\n\t\t \n\t\tcalculated_tries[i] = min_t(int, ((15 >> nrates) | 1) + 1,\n\t\t\t\t\t\t info->control.rates[i].count);\n\t\tnremaining -= calculated_tries[i];\n\t}\n\n\t \n\tfor (i = nrates - 1; nremaining > 0 && i >= 0; i--) {\n\t\tint tmp = info->control.rates[i].count - calculated_tries[i];\n\n\t\tif (tmp <= 0)\n\t\t\tcontinue;\n\t\t \n\n\t\ttmp = min_t(int, tmp, nremaining);\n\t\tcalculated_tries[i] += tmp;\n\t\tnremaining -= tmp;\n\t}\n\n\tridx = 0;\n\tfor (i = 0; i < nrates && ridx < 8; i++) {\n\t\t \n\t\trate = info->control.rates[i].idx;\n\t\tif (info->band == NL80211_BAND_5GHZ)\n\t\t\trate += 4;\n\n\t\t \n\t\tinfo->control.rates[i].count = calculated_tries[i];\n\n\t\trc_flags = info->control.rates[i].flags;\n\t\tif (rc_flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE) {\n\t\t\trate |= 0x10;\n\t\t\tcts_rate |= 0x10;\n\t\t}\n\t\tif (rc_flags & IEEE80211_TX_RC_USE_RTS_CTS) {\n\t\t\tburst_allowed = false;\n\t\t\trate |= 0x40;\n\t\t} else if (rc_flags & IEEE80211_TX_RC_USE_CTS_PROTECT) {\n\t\t\trate |= 0x20;\n\t\t\tburst_allowed = false;\n\t\t}\n\t\tfor (j = 0; j < calculated_tries[i] && ridx < 8; j++) {\n\t\t\ttxhdr->rateset[ridx] = rate;\n\t\t\tridx++;\n\t\t}\n\t}\n\n\tif (burst_allowed)\n\t\thdr_flags |= P54_HDR_FLAG_DATA_OUT_BURST;\n\n\t \n\thdr->flags = cpu_to_le16(hdr_flags);\n\thdr->tries = ridx;\n\ttxhdr->rts_rate_idx = 0;\n\tif (info->control.hw_key) {\n\t\ttxhdr->key_type = p54_convert_algo(info->control.hw_key->cipher);\n\t\ttxhdr->key_len = min((u8)16, info->control.hw_key->keylen);\n\t\tmemcpy(txhdr->key, info->control.hw_key->key, txhdr->key_len);\n\t\tif (info->control.hw_key->cipher == WLAN_CIPHER_SUITE_TKIP) {\n\t\t\t \n\t\t\tlen += 8;\n\t\t\tskb_put_data(skb,\n\t\t\t\t     &(info->control.hw_key->key[NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY]),\n\t\t\t\t     8);\n\t\t}\n\t\t \n\t\tlen += info->control.hw_key->icv_len;\n\t\tskb_put_zero(skb, info->control.hw_key->icv_len);\n\t} else {\n\t\ttxhdr->key_type = 0;\n\t\ttxhdr->key_len = 0;\n\t}\n\ttxhdr->crypt_offset = crypt_offset;\n\ttxhdr->hw_queue = queue;\n\ttxhdr->backlog = priv->tx_stats[queue].len - 1;\n\tmemset(txhdr->durations, 0, sizeof(txhdr->durations));\n\ttxhdr->tx_antenna = 2 & priv->tx_diversity_mask;\n\tif (priv->rxhw == 5) {\n\t\ttxhdr->longbow.cts_rate = cts_rate;\n\t\ttxhdr->longbow.output_power = cpu_to_le16(priv->output_power);\n\t} else {\n\t\ttxhdr->normal.output_power = priv->output_power;\n\t\ttxhdr->normal.cts_rate = cts_rate;\n\t}\n\tif (padding)\n\t\ttxhdr->align[0] = padding;\n\n\thdr->len = cpu_to_le16(len);\n\t \n\tp54info = (void *) info->rate_driver_data;\n\tp54info->extra_len = extra_len;\n\n\tp54_tx(priv, skb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}