{
  "module_name": "main.c",
  "hash_id": "12cb68344bf753e61666ef6a2f86eec951a68fd91dc2a1c1f91d22e4eb427658",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/p54/main.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/firmware.h>\n#include <linux/etherdevice.h>\n#include <linux/module.h>\n\n#include <net/mac80211.h>\n\n#include \"p54.h\"\n#include \"lmac.h\"\n\nstatic bool modparam_nohwcrypt;\nmodule_param_named(nohwcrypt, modparam_nohwcrypt, bool, 0444);\nMODULE_PARM_DESC(nohwcrypt, \"Disable hardware encryption.\");\nMODULE_AUTHOR(\"Michael Wu <flamingice@sourmilk.net>\");\nMODULE_DESCRIPTION(\"Softmac Prism54 common code\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"prism54common\");\n\nstatic int p54_sta_add_remove(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_sta *sta)\n{\n\tstruct p54_common *priv = hw->priv;\n\n\t \n\n\tp54_sta_unlock(priv, sta->addr);\n\n\treturn 0;\n}\n\nstatic void p54_sta_notify(struct ieee80211_hw *dev, struct ieee80211_vif *vif,\n\t\t\t      enum sta_notify_cmd notify_cmd,\n\t\t\t      struct ieee80211_sta *sta)\n{\n\tstruct p54_common *priv = dev->priv;\n\n\tswitch (notify_cmd) {\n\tcase STA_NOTIFY_AWAKE:\n\t\t \n\t\tp54_sta_unlock(priv, sta->addr);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int p54_set_tim(struct ieee80211_hw *dev, struct ieee80211_sta *sta,\n\t\t\tbool set)\n{\n\tstruct p54_common *priv = dev->priv;\n\n\treturn p54_update_beacon_tim(priv, sta->aid, set);\n}\n\nu8 *p54_find_ie(struct sk_buff *skb, u8 ie)\n{\n\tstruct ieee80211_mgmt *mgmt = (void *)skb->data;\n\tu8 *pos, *end;\n\n\tif (skb->len <= sizeof(mgmt))\n\t\treturn NULL;\n\n\tpos = (u8 *)mgmt->u.beacon.variable;\n\tend = skb->data + skb->len;\n\twhile (pos < end) {\n\t\tif (pos + 2 + pos[1] > end)\n\t\t\treturn NULL;\n\n\t\tif (pos[0] == ie)\n\t\t\treturn pos;\n\n\t\tpos += 2 + pos[1];\n\t}\n\treturn NULL;\n}\n\nstatic int p54_beacon_format_ie_tim(struct sk_buff *skb)\n{\n\t \n\tu8 *tim;\n\tu8 dtim_len;\n\tu8 dtim_period;\n\tu8 *next;\n\n\ttim = p54_find_ie(skb, WLAN_EID_TIM);\n\tif (!tim)\n\t\treturn 0;\n\n\tdtim_len = tim[1];\n\tdtim_period = tim[3];\n\tnext = tim + 2 + dtim_len;\n\n\tif (dtim_len < 3)\n\t\treturn -EINVAL;\n\n\tmemmove(tim, next, skb_tail_pointer(skb) - next);\n\ttim = skb_tail_pointer(skb) - (dtim_len + 2);\n\n\t \n\ttim[0] = WLAN_EID_TIM;\n\ttim[1] = 3;\n\ttim[2] = 0;\n\ttim[3] = dtim_period;\n\ttim[4] = 0;\n\n\tif (dtim_len > 3)\n\t\tskb_trim(skb, skb->len - (dtim_len - 3));\n\n\treturn 0;\n}\n\nstatic int p54_beacon_update(struct p54_common *priv,\n\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct ieee80211_tx_control control = { };\n\tstruct sk_buff *beacon;\n\tint ret;\n\n\tbeacon = ieee80211_beacon_get(priv->hw, vif, 0);\n\tif (!beacon)\n\t\treturn -ENOMEM;\n\tret = p54_beacon_format_ie_tim(beacon);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tp54_tx_80211(priv->hw, &control, beacon);\n\tpriv->tsf_high32 = 0;\n\tpriv->tsf_low32 = 0;\n\n\treturn 0;\n}\n\nstatic int p54_start(struct ieee80211_hw *dev)\n{\n\tstruct p54_common *priv = dev->priv;\n\tint err;\n\n\tmutex_lock(&priv->conf_mutex);\n\terr = priv->open(dev);\n\tif (err)\n\t\tgoto out;\n\tP54_SET_QUEUE(priv->qos_params[0], 0x0002, 0x0003, 0x0007, 47);\n\tP54_SET_QUEUE(priv->qos_params[1], 0x0002, 0x0007, 0x000f, 94);\n\tP54_SET_QUEUE(priv->qos_params[2], 0x0003, 0x000f, 0x03ff, 0);\n\tP54_SET_QUEUE(priv->qos_params[3], 0x0007, 0x000f, 0x03ff, 0);\n\terr = p54_set_edcf(priv);\n\tif (err)\n\t\tgoto out;\n\n\teth_broadcast_addr(priv->bssid);\n\tpriv->mode = NL80211_IFTYPE_MONITOR;\n\terr = p54_setup_mac(priv);\n\tif (err) {\n\t\tpriv->mode = NL80211_IFTYPE_UNSPECIFIED;\n\t\tgoto out;\n\t}\n\n\tieee80211_queue_delayed_work(dev, &priv->work, 0);\n\n\tpriv->softled_state = 0;\n\terr = p54_set_leds(priv);\n\nout:\n\tmutex_unlock(&priv->conf_mutex);\n\treturn err;\n}\n\nstatic void p54_stop(struct ieee80211_hw *dev)\n{\n\tstruct p54_common *priv = dev->priv;\n\tint i;\n\n\tpriv->mode = NL80211_IFTYPE_UNSPECIFIED;\n\tpriv->softled_state = 0;\n\tcancel_delayed_work_sync(&priv->work);\n\tmutex_lock(&priv->conf_mutex);\n\tp54_set_leds(priv);\n\tpriv->stop(dev);\n\tskb_queue_purge(&priv->tx_pending);\n\tskb_queue_purge(&priv->tx_queue);\n\tfor (i = 0; i < P54_QUEUE_NUM; i++) {\n\t\tpriv->tx_stats[i].count = 0;\n\t\tpriv->tx_stats[i].len = 0;\n\t}\n\n\tpriv->beacon_req_id = cpu_to_le32(0);\n\tpriv->tsf_high32 = priv->tsf_low32 = 0;\n\tmutex_unlock(&priv->conf_mutex);\n}\n\nstatic int p54_add_interface(struct ieee80211_hw *dev,\n\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct p54_common *priv = dev->priv;\n\tint err;\n\n\tvif->driver_flags |= IEEE80211_VIF_BEACON_FILTER;\n\n\tmutex_lock(&priv->conf_mutex);\n\tif (priv->mode != NL80211_IFTYPE_MONITOR) {\n\t\tmutex_unlock(&priv->conf_mutex);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpriv->vif = vif;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tpriv->mode = vif->type;\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&priv->conf_mutex);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmemcpy(priv->mac_addr, vif->addr, ETH_ALEN);\n\terr = p54_setup_mac(priv);\n\tmutex_unlock(&priv->conf_mutex);\n\treturn err;\n}\n\nstatic void p54_remove_interface(struct ieee80211_hw *dev,\n\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct p54_common *priv = dev->priv;\n\n\tmutex_lock(&priv->conf_mutex);\n\tpriv->vif = NULL;\n\n\t \n\tif (le32_to_cpu(priv->beacon_req_id) != 0) {\n\t\tp54_tx_cancel(priv, priv->beacon_req_id);\n\t\twait_for_completion_interruptible_timeout(&priv->beacon_comp, HZ);\n\t}\n\tpriv->mode = NL80211_IFTYPE_MONITOR;\n\teth_zero_addr(priv->mac_addr);\n\teth_zero_addr(priv->bssid);\n\tp54_setup_mac(priv);\n\tmutex_unlock(&priv->conf_mutex);\n}\n\nstatic int p54_wait_for_stats(struct ieee80211_hw *dev)\n{\n\tstruct p54_common *priv = dev->priv;\n\tint ret;\n\n\tpriv->update_stats = true;\n\tret = p54_fetch_statistics(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = wait_for_completion_interruptible_timeout(&priv->stat_comp, HZ);\n\tif (ret == 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic void p54_reset_stats(struct p54_common *priv)\n{\n\tstruct ieee80211_channel *chan = priv->curchan;\n\n\tif (chan) {\n\t\tstruct survey_info *info = &priv->survey[chan->hw_value];\n\n\t\t \n\t\tinfo->time = 0;\n\t\tinfo->time_busy = 0;\n\t\tinfo->time_tx = 0;\n\t}\n\n\tpriv->update_stats = true;\n\tpriv->survey_raw.active = 0;\n\tpriv->survey_raw.cca = 0;\n\tpriv->survey_raw.tx = 0;\n}\n\nstatic int p54_config(struct ieee80211_hw *dev, u32 changed)\n{\n\tint ret = 0;\n\tstruct p54_common *priv = dev->priv;\n\tstruct ieee80211_conf *conf = &dev->conf;\n\n\tmutex_lock(&priv->conf_mutex);\n\tif (changed & IEEE80211_CONF_CHANGE_POWER)\n\t\tpriv->output_power = conf->power_level << 2;\n\tif (changed & IEEE80211_CONF_CHANGE_CHANNEL) {\n\t\tstruct ieee80211_channel *oldchan;\n\t\tWARN_ON(p54_wait_for_stats(dev));\n\t\toldchan = priv->curchan;\n\t\tpriv->curchan = NULL;\n\t\tret = p54_scan(priv, P54_SCAN_EXIT, 0);\n\t\tif (ret) {\n\t\t\tpriv->curchan = oldchan;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tpriv->curchan = priv->hw->conf.chandef.chan;\n\t\tp54_reset_stats(priv);\n\t\tWARN_ON(p54_fetch_statistics(priv));\n\t}\n\tif (changed & IEEE80211_CONF_CHANGE_PS) {\n\t\tWARN_ON(p54_wait_for_stats(dev));\n\t\tret = p54_set_ps(priv);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tWARN_ON(p54_wait_for_stats(dev));\n\t}\n\tif (changed & IEEE80211_CONF_CHANGE_IDLE) {\n\t\tWARN_ON(p54_wait_for_stats(dev));\n\t\tret = p54_setup_mac(priv);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tWARN_ON(p54_wait_for_stats(dev));\n\t}\n\nout:\n\tmutex_unlock(&priv->conf_mutex);\n\treturn ret;\n}\n\nstatic u64 p54_prepare_multicast(struct ieee80211_hw *dev,\n\t\t\t\t struct netdev_hw_addr_list *mc_list)\n{\n\tstruct p54_common *priv = dev->priv;\n\tstruct netdev_hw_addr *ha;\n\tint i;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(priv->mc_maclist) !=\n\t\tARRAY_SIZE(((struct p54_group_address_table *)NULL)->mac_list));\n\t \n\ti = 1;\n\tpriv->mc_maclist_num = netdev_hw_addr_list_count(mc_list) + i;\n\tnetdev_hw_addr_list_for_each(ha, mc_list) {\n\t\tmemcpy(&priv->mc_maclist[i], ha->addr, ETH_ALEN);\n\t\ti++;\n\t\tif (i >= ARRAY_SIZE(priv->mc_maclist))\n\t\t\tbreak;\n\t}\n\n\treturn 1;  \n}\n\nstatic void p54_configure_filter(struct ieee80211_hw *dev,\n\t\t\t\t unsigned int changed_flags,\n\t\t\t\t unsigned int *total_flags,\n\t\t\t\t u64 multicast)\n{\n\tstruct p54_common *priv = dev->priv;\n\n\t*total_flags &= FIF_ALLMULTI | FIF_OTHER_BSS;\n\n\tpriv->filter_flags = *total_flags;\n\n\tif (changed_flags & FIF_OTHER_BSS)\n\t\tp54_setup_mac(priv);\n\n\tif (changed_flags & FIF_ALLMULTI || multicast)\n\t\tp54_set_groupfilter(priv);\n}\n\nstatic int p54_conf_tx(struct ieee80211_hw *dev,\n\t\t       struct ieee80211_vif *vif,\n\t\t       unsigned int link_id, u16 queue,\n\t\t       const struct ieee80211_tx_queue_params *params)\n{\n\tstruct p54_common *priv = dev->priv;\n\tint ret;\n\n\tmutex_lock(&priv->conf_mutex);\n\tP54_SET_QUEUE(priv->qos_params[queue], params->aifs,\n\t\t      params->cw_min, params->cw_max, params->txop);\n\tret = p54_set_edcf(priv);\n\tmutex_unlock(&priv->conf_mutex);\n\treturn ret;\n}\n\nstatic void p54_work(struct work_struct *work)\n{\n\tstruct p54_common *priv = container_of(work, struct p54_common,\n\t\t\t\t\t       work.work);\n\n\tif (unlikely(priv->mode == NL80211_IFTYPE_UNSPECIFIED))\n\t\treturn ;\n\n\t \n\n\tmutex_lock(&priv->conf_mutex);\n\tWARN_ON_ONCE(p54_fetch_statistics(priv));\n\tmutex_unlock(&priv->conf_mutex);\n}\n\nstatic int p54_get_stats(struct ieee80211_hw *dev,\n\t\t\t struct ieee80211_low_level_stats *stats)\n{\n\tstruct p54_common *priv = dev->priv;\n\n\tmemcpy(stats, &priv->stats, sizeof(*stats));\n\treturn 0;\n}\n\nstatic void p54_bss_info_changed(struct ieee80211_hw *dev,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_bss_conf *info,\n\t\t\t\t u64 changed)\n{\n\tstruct p54_common *priv = dev->priv;\n\n\tmutex_lock(&priv->conf_mutex);\n\tif (changed & BSS_CHANGED_BSSID) {\n\t\tmemcpy(priv->bssid, info->bssid, ETH_ALEN);\n\t\tp54_setup_mac(priv);\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON) {\n\t\tp54_scan(priv, P54_SCAN_EXIT, 0);\n\t\tp54_setup_mac(priv);\n\t\tp54_beacon_update(priv, vif);\n\t\tp54_set_edcf(priv);\n\t}\n\n\tif (changed & (BSS_CHANGED_ERP_SLOT | BSS_CHANGED_BEACON)) {\n\t\tpriv->use_short_slot = info->use_short_slot;\n\t\tp54_set_edcf(priv);\n\t}\n\tif (changed & BSS_CHANGED_BASIC_RATES) {\n\t\tif (dev->conf.chandef.chan->band == NL80211_BAND_5GHZ)\n\t\t\tpriv->basic_rate_mask = (info->basic_rates << 4);\n\t\telse\n\t\t\tpriv->basic_rate_mask = info->basic_rates;\n\t\tp54_setup_mac(priv);\n\t\tif (priv->fw_var >= 0x500)\n\t\t\tp54_scan(priv, P54_SCAN_EXIT, 0);\n\t}\n\tif (changed & BSS_CHANGED_ASSOC) {\n\t\tif (vif->cfg.assoc) {\n\t\t\tpriv->aid = vif->cfg.aid;\n\t\t\tpriv->wakeup_timer = info->beacon_int *\n\t\t\t\t\t     info->dtim_period * 5;\n\t\t\tp54_setup_mac(priv);\n\t\t} else {\n\t\t\tpriv->wakeup_timer = 500;\n\t\t\tpriv->aid = 0;\n\t\t}\n\t}\n\n\tmutex_unlock(&priv->conf_mutex);\n}\n\nstatic int p54_set_key(struct ieee80211_hw *dev, enum set_key_cmd cmd,\n\t\t       struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t       struct ieee80211_key_conf *key)\n{\n\tstruct p54_common *priv = dev->priv;\n\tint slot, ret = 0;\n\tu8 algo = 0;\n\tu8 *addr = NULL;\n\n\tif (modparam_nohwcrypt)\n\t\treturn -EOPNOTSUPP;\n\n\tif (key->flags & IEEE80211_KEY_FLAG_RX_MGMT) {\n\t\t \n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmutex_lock(&priv->conf_mutex);\n\tif (cmd == SET_KEY) {\n\t\tswitch (key->cipher) {\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\tif (!(priv->privacy_caps & (BR_DESC_PRIV_CAP_MICHAEL |\n\t\t\t      BR_DESC_PRIV_CAP_TKIP))) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\n\t\t\talgo = P54_CRYPTO_TKIPMICHAEL;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\t\tif (!(priv->privacy_caps & BR_DESC_PRIV_CAP_WEP)) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\n\t\t\talgo = P54_CRYPTO_WEP;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\t\tif (!(priv->privacy_caps & BR_DESC_PRIV_CAP_AESCCMP)) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\n\t\t\talgo = P54_CRYPTO_AESCCMP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tslot = bitmap_find_free_region(priv->used_rxkeys,\n\t\t\t\t\t       priv->rx_keycache_size, 0);\n\n\t\tif (slot < 0) {\n\t\t\t \n\n\t\t\t \n\t\t\tkey->hw_key_idx = 0xff;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tkey->flags |= IEEE80211_KEY_FLAG_RESERVE_TAILROOM;\n\t} else {\n\t\tslot = key->hw_key_idx;\n\n\t\tif (slot == 0xff) {\n\t\t\t \n\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tbitmap_release_region(priv->used_rxkeys, slot, 0);\n\t\talgo = 0;\n\t}\n\n\tif (sta)\n\t\taddr = sta->addr;\n\n\tret = p54_upload_key(priv, algo, slot, key->keyidx,\n\t\t\t     key->keylen, addr, key->key);\n\tif (ret) {\n\t\tbitmap_release_region(priv->used_rxkeys, slot, 0);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_unlock;\n\t}\n\n\tkey->hw_key_idx = slot;\n\nout_unlock:\n\tmutex_unlock(&priv->conf_mutex);\n\treturn ret;\n}\n\nstatic int p54_get_survey(struct ieee80211_hw *dev, int idx,\n\t\t\t\tstruct survey_info *survey)\n{\n\tstruct p54_common *priv = dev->priv;\n\tstruct ieee80211_channel *chan;\n\tint err, tries;\n\tbool in_use = false;\n\n\tif (idx >= priv->chan_num)\n\t\treturn -ENOENT;\n\n#define MAX_TRIES 1\n\tfor (tries = 0; tries < MAX_TRIES; tries++) {\n\t\tchan = priv->curchan;\n\t\tif (chan && chan->hw_value == idx) {\n\t\t\tmutex_lock(&priv->conf_mutex);\n\t\t\terr = p54_wait_for_stats(dev);\n\t\t\tmutex_unlock(&priv->conf_mutex);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tin_use = true;\n\t\t}\n\n\t\tmemcpy(survey, &priv->survey[idx], sizeof(*survey));\n\n\t\tif (in_use) {\n\t\t\t \n\t\t\tif  (survey->time != 0) {\n\t\t\t\tsurvey->filled |= SURVEY_INFO_IN_USE;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tmsleep(100);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\treturn -ETIMEDOUT;\n#undef MAX_TRIES\n}\n\nstatic unsigned int p54_flush_count(struct p54_common *priv)\n{\n\tunsigned int total = 0, i;\n\n\tBUILD_BUG_ON(P54_QUEUE_NUM > ARRAY_SIZE(priv->tx_stats));\n\n\t \n\tfor (i = P54_QUEUE_MGMT; i < P54_QUEUE_NUM; i++)\n\t\ttotal += priv->tx_stats[i].len;\n\treturn total;\n}\n\nstatic void p54_flush(struct ieee80211_hw *dev, struct ieee80211_vif *vif,\n\t\t      u32 queues, bool drop)\n{\n\tstruct p54_common *priv = dev->priv;\n\tunsigned int total, i;\n\n\t \n\ti = P54_STATISTICS_UPDATE * 2 / 20;\n\n\t \n\twhile ((total = p54_flush_count(priv)) && i--) {\n\t\t \n\t\tmsleep(20);\n\t}\n\n\tWARN(total, \"tx flush timeout, unresponsive firmware\");\n}\n\nstatic void p54_set_coverage_class(struct ieee80211_hw *dev,\n\t\t\t\t   s16 coverage_class)\n{\n\tstruct p54_common *priv = dev->priv;\n\n\tmutex_lock(&priv->conf_mutex);\n\t \n\tpriv->coverage_class = clamp_t(u8, coverage_class, 0, 31);\n\tp54_set_edcf(priv);\n\tmutex_unlock(&priv->conf_mutex);\n}\n\nstatic const struct ieee80211_ops p54_ops = {\n\t.tx\t\t\t= p54_tx_80211,\n\t.wake_tx_queue\t\t= ieee80211_handle_wake_tx_queue,\n\t.start\t\t\t= p54_start,\n\t.stop\t\t\t= p54_stop,\n\t.add_interface\t\t= p54_add_interface,\n\t.remove_interface\t= p54_remove_interface,\n\t.set_tim\t\t= p54_set_tim,\n\t.sta_notify\t\t= p54_sta_notify,\n\t.sta_add\t\t= p54_sta_add_remove,\n\t.sta_remove\t\t= p54_sta_add_remove,\n\t.set_key\t\t= p54_set_key,\n\t.config\t\t\t= p54_config,\n\t.flush\t\t\t= p54_flush,\n\t.bss_info_changed\t= p54_bss_info_changed,\n\t.prepare_multicast\t= p54_prepare_multicast,\n\t.configure_filter\t= p54_configure_filter,\n\t.conf_tx\t\t= p54_conf_tx,\n\t.get_stats\t\t= p54_get_stats,\n\t.get_survey\t\t= p54_get_survey,\n\t.set_coverage_class\t= p54_set_coverage_class,\n};\n\nstruct ieee80211_hw *p54_init_common(size_t priv_data_len)\n{\n\tstruct ieee80211_hw *dev;\n\tstruct p54_common *priv;\n\n\tdev = ieee80211_alloc_hw(priv_data_len, &p54_ops);\n\tif (!dev)\n\t\treturn NULL;\n\n\tpriv = dev->priv;\n\tpriv->hw = dev;\n\tpriv->mode = NL80211_IFTYPE_UNSPECIFIED;\n\tpriv->basic_rate_mask = 0x15f;\n\tspin_lock_init(&priv->tx_stats_lock);\n\tskb_queue_head_init(&priv->tx_queue);\n\tskb_queue_head_init(&priv->tx_pending);\n\tieee80211_hw_set(dev, REPORTS_TX_ACK_STATUS);\n\tieee80211_hw_set(dev, MFP_CAPABLE);\n\tieee80211_hw_set(dev, PS_NULLFUNC_STACK);\n\tieee80211_hw_set(dev, SUPPORTS_PS);\n\tieee80211_hw_set(dev, RX_INCLUDES_FCS);\n\tieee80211_hw_set(dev, SIGNAL_DBM);\n\n\tdev->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t      BIT(NL80211_IFTYPE_ADHOC) |\n\t\t\t\t      BIT(NL80211_IFTYPE_AP) |\n\t\t\t\t      BIT(NL80211_IFTYPE_MESH_POINT);\n\n\tpriv->beacon_req_id = cpu_to_le32(0);\n\tpriv->tx_stats[P54_QUEUE_BEACON].limit = 1;\n\tpriv->tx_stats[P54_QUEUE_FWSCAN].limit = 1;\n\tpriv->tx_stats[P54_QUEUE_MGMT].limit = 3;\n\tpriv->tx_stats[P54_QUEUE_CAB].limit = 3;\n\tpriv->tx_stats[P54_QUEUE_DATA].limit = 5;\n\tdev->queues = 1;\n\tpriv->noise = -94;\n\t \n\tdev->max_rates = 4;\n\tdev->max_rate_tries = 7;\n\tdev->extra_tx_headroom = sizeof(struct p54_hdr) + 4 +\n\t\t\t\t sizeof(struct p54_tx_data);\n\n\t \n\tdev->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;\n\n\tmutex_init(&priv->conf_mutex);\n\tmutex_init(&priv->eeprom_mutex);\n\tinit_completion(&priv->stat_comp);\n\tinit_completion(&priv->eeprom_comp);\n\tinit_completion(&priv->beacon_comp);\n\tINIT_DELAYED_WORK(&priv->work, p54_work);\n\n\teth_broadcast_addr(priv->mc_maclist[0]);\n\tpriv->curchan = NULL;\n\tp54_reset_stats(priv);\n\treturn dev;\n}\nEXPORT_SYMBOL_GPL(p54_init_common);\n\nint p54_register_common(struct ieee80211_hw *dev, struct device *pdev)\n{\n\tstruct p54_common __maybe_unused *priv = dev->priv;\n\tint err;\n\n\terr = ieee80211_register_hw(dev);\n\tif (err) {\n\t\tdev_err(pdev, \"Cannot register device (%d).\\n\", err);\n\t\treturn err;\n\t}\n\tpriv->registered = true;\n\n#ifdef CONFIG_P54_LEDS\n\terr = p54_init_leds(priv);\n\tif (err) {\n\t\tp54_unregister_common(dev);\n\t\treturn err;\n\t}\n#endif  \n\n\tdev_info(pdev, \"is registered as '%s'\\n\", wiphy_name(dev->wiphy));\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(p54_register_common);\n\nvoid p54_free_common(struct ieee80211_hw *dev)\n{\n\tstruct p54_common *priv = dev->priv;\n\tunsigned int i;\n\n\tfor (i = 0; i < NUM_NL80211_BANDS; i++)\n\t\tkfree(priv->band_table[i]);\n\n\tkfree(priv->iq_autocal);\n\tkfree(priv->output_limit);\n\tkfree(priv->curve_data);\n\tkfree(priv->rssi_db);\n\tbitmap_free(priv->used_rxkeys);\n\tkfree(priv->survey);\n\tpriv->iq_autocal = NULL;\n\tpriv->output_limit = NULL;\n\tpriv->curve_data = NULL;\n\tpriv->rssi_db = NULL;\n\tpriv->used_rxkeys = NULL;\n\tpriv->survey = NULL;\n\tieee80211_free_hw(dev);\n}\nEXPORT_SYMBOL_GPL(p54_free_common);\n\nvoid p54_unregister_common(struct ieee80211_hw *dev)\n{\n\tstruct p54_common *priv = dev->priv;\n\n\tif (priv->registered) {\n\t\tpriv->registered = false;\n#ifdef CONFIG_P54_LEDS\n\t\tp54_unregister_leds(priv);\n#endif  \n\t\tieee80211_unregister_hw(dev);\n\t}\n\n\tmutex_destroy(&priv->conf_mutex);\n\tmutex_destroy(&priv->eeprom_mutex);\n}\nEXPORT_SYMBOL_GPL(p54_unregister_common);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}