{
  "module_name": "fwio.c",
  "hash_id": "e2fc8eb65015ba68d7b2772a7ac2e64c17ec5ba3288a72a88b6b564a6028210c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/p54/fwio.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/firmware.h>\n#include <linux/etherdevice.h>\n#include <linux/export.h>\n\n#include <net/mac80211.h>\n\n#include \"p54.h\"\n#include \"eeprom.h\"\n#include \"lmac.h\"\n\nint p54_parse_firmware(struct ieee80211_hw *dev, const struct firmware *fw)\n{\n\tstruct p54_common *priv = dev->priv;\n\tstruct exp_if *exp_if;\n\tstruct bootrec *bootrec;\n\tu32 *data = (u32 *)fw->data;\n\tu32 *end_data = (u32 *)fw->data + (fw->size >> 2);\n\tu8 *fw_version = NULL;\n\tsize_t len;\n\tint i;\n\tint maxlen;\n\n\tif (priv->rx_start)\n\t\treturn 0;\n\n\twhile (data < end_data && *data)\n\t\tdata++;\n\n\twhile (data < end_data && !*data)\n\t\tdata++;\n\n\tbootrec = (struct bootrec *) data;\n\n\twhile (bootrec->data <= end_data && (bootrec->data +\n\t       (len = le32_to_cpu(bootrec->len))) <= end_data) {\n\t\tu32 code = le32_to_cpu(bootrec->code);\n\t\tswitch (code) {\n\t\tcase BR_CODE_COMPONENT_ID:\n\t\t\tpriv->fw_interface = be32_to_cpup((__be32 *)\n\t\t\t\t\t     bootrec->data);\n\t\t\tswitch (priv->fw_interface) {\n\t\t\tcase FW_LM86:\n\t\t\tcase FW_LM20:\n\t\t\tcase FW_LM87: {\n\t\t\t\tchar *iftype = (char *)bootrec->data;\n\t\t\t\twiphy_info(priv->hw->wiphy,\n\t\t\t\t\t   \"p54 detected a LM%c%c firmware\\n\",\n\t\t\t\t\t   iftype[2], iftype[3]);\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase FW_FMAC:\n\t\t\tdefault:\n\t\t\t\twiphy_err(priv->hw->wiphy,\n\t\t\t\t\t  \"unsupported firmware\\n\");\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BR_CODE_COMPONENT_VERSION:\n\t\t\t \n\t\t\tif (strnlen((unsigned char *) bootrec->data, 24) < 24)\n\t\t\t\tfw_version = (unsigned char *) bootrec->data;\n\t\t\tbreak;\n\t\tcase BR_CODE_DESCR: {\n\t\t\tstruct bootrec_desc *desc =\n\t\t\t\t(struct bootrec_desc *)bootrec->data;\n\t\t\tpriv->rx_start = le32_to_cpu(desc->rx_start);\n\t\t\t \n\t\t\tpriv->rx_end = le32_to_cpu(desc->rx_end) - 0x3500;\n\t\t\tpriv->headroom = desc->headroom;\n\t\t\tpriv->tailroom = desc->tailroom;\n\t\t\tpriv->privacy_caps = desc->privacy_caps;\n\t\t\tpriv->rx_keycache_size = desc->rx_keycache_size;\n\t\t\tif (le32_to_cpu(bootrec->len) == 11)\n\t\t\t\tpriv->rx_mtu = le16_to_cpu(desc->rx_mtu);\n\t\t\telse\n\t\t\t\tpriv->rx_mtu = (size_t)\n\t\t\t\t\t0x620 - priv->tx_hdr_len;\n\t\t\tmaxlen = priv->tx_hdr_len +  \n\t\t\t\t sizeof(struct p54_rx_data) +\n\t\t\t\t 4 +  \n\t\t\t\t IEEE80211_MAX_FRAG_THRESHOLD;\n\t\t\tif (priv->rx_mtu > maxlen && PAGE_SIZE == 4096) {\n\t\t\t\tprintk(KERN_INFO \"p54: rx_mtu reduced from %d \"\n\t\t\t\t       \"to %d\\n\", priv->rx_mtu, maxlen);\n\t\t\t\tpriv->rx_mtu = maxlen;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t}\n\t\tcase BR_CODE_EXPOSED_IF:\n\t\t\texp_if = (struct exp_if *) bootrec->data;\n\t\t\tfor (i = 0; i < (len * sizeof(*exp_if) / 4); i++)\n\t\t\t\tif (exp_if[i].if_id == cpu_to_le16(IF_ID_LMAC))\n\t\t\t\t\tpriv->fw_var = le16_to_cpu(exp_if[i].variant);\n\t\t\tbreak;\n\t\tcase BR_CODE_DEPENDENT_IF:\n\t\t\tbreak;\n\t\tcase BR_CODE_END_OF_BRA:\n\t\tcase LEGACY_BR_CODE_END_OF_BRA:\n\t\t\tend_data = NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbootrec = (struct bootrec *)&bootrec->data[len];\n\t}\n\n\tif (fw_version) {\n\t\twiphy_info(priv->hw->wiphy,\n\t\t\t   \"FW rev %s - Softmac protocol %x.%x\\n\",\n\t\t\t   fw_version, priv->fw_var >> 8, priv->fw_var & 0xff);\n\t\tsnprintf(dev->wiphy->fw_version, sizeof(dev->wiphy->fw_version),\n\t\t\t\t\"%s - %x.%x\", fw_version,\n\t\t\t\tpriv->fw_var >> 8, priv->fw_var & 0xff);\n\t}\n\n\tif (priv->fw_var < 0x500)\n\t\twiphy_info(priv->hw->wiphy,\n\t\t\t   \"you are using an obsolete firmware. \"\n\t\t\t   \"visit http://wireless.wiki.kernel.org/en/users/Drivers/p54 \"\n\t\t\t   \"and grab one for \\\"kernel >= 2.6.28\\\"!\\n\");\n\n\tif (priv->fw_var >= 0x300) {\n\t\t \n\n\t\tif (priv->fw_var >= 0x500) {\n\t\t\tpriv->tx_stats[P54_QUEUE_AC_VO].limit = 16;\n\t\t\tpriv->tx_stats[P54_QUEUE_AC_VI].limit = 16;\n\t\t\tpriv->tx_stats[P54_QUEUE_AC_BE].limit = 16;\n\t\t\tpriv->tx_stats[P54_QUEUE_AC_BK].limit = 16;\n\t\t} else {\n\t\t\tpriv->tx_stats[P54_QUEUE_AC_VO].limit = 3;\n\t\t\tpriv->tx_stats[P54_QUEUE_AC_VI].limit = 4;\n\t\t\tpriv->tx_stats[P54_QUEUE_AC_BE].limit = 3;\n\t\t\tpriv->tx_stats[P54_QUEUE_AC_BK].limit = 2;\n\t\t}\n\t\tpriv->hw->queues = P54_QUEUE_AC_NUM;\n\t}\n\n\twiphy_info(priv->hw->wiphy,\n\t\t   \"cryptographic accelerator WEP:%s, TKIP:%s, CCMP:%s\\n\",\n\t\t   (priv->privacy_caps & BR_DESC_PRIV_CAP_WEP) ? \"YES\" : \"no\",\n\t\t   (priv->privacy_caps &\n\t\t    (BR_DESC_PRIV_CAP_TKIP | BR_DESC_PRIV_CAP_MICHAEL))\n\t\t   ? \"YES\" : \"no\",\n\t\t   (priv->privacy_caps & BR_DESC_PRIV_CAP_AESCCMP)\n\t\t   ? \"YES\" : \"no\");\n\n\tif (priv->rx_keycache_size) {\n\t\t \n\n\t\tpriv->used_rxkeys = bitmap_zalloc(priv->rx_keycache_size,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!priv->used_rxkeys)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(p54_parse_firmware);\n\nstatic struct sk_buff *p54_alloc_skb(struct p54_common *priv, u16 hdr_flags,\n\t\t\t\t     u16 payload_len, u16 type, gfp_t memflags)\n{\n\tstruct p54_hdr *hdr;\n\tstruct sk_buff *skb;\n\tsize_t frame_len = sizeof(*hdr) + payload_len;\n\n\tif (frame_len > P54_MAX_CTRL_FRAME_LEN)\n\t\treturn NULL;\n\n\tif (unlikely(skb_queue_len(&priv->tx_pending) > 64))\n\t\treturn NULL;\n\n\tskb = __dev_alloc_skb(priv->tx_hdr_len + frame_len, memflags);\n\tif (!skb)\n\t\treturn NULL;\n\tskb_reserve(skb, priv->tx_hdr_len);\n\n\thdr = skb_put(skb, sizeof(*hdr));\n\thdr->flags = cpu_to_le16(hdr_flags);\n\thdr->len = cpu_to_le16(payload_len);\n\thdr->type = cpu_to_le16(type);\n\thdr->tries = hdr->rts_tries = 0;\n\treturn skb;\n}\n\nint p54_download_eeprom(struct p54_common *priv, void *buf,\n\t\t\tu16 offset, u16 len)\n{\n\tstruct p54_eeprom_lm86 *eeprom_hdr;\n\tstruct sk_buff *skb;\n\tsize_t eeprom_hdr_size;\n\tint ret = 0;\n\tlong timeout;\n\n\tif (priv->fw_var >= 0x509)\n\t\teeprom_hdr_size = sizeof(*eeprom_hdr);\n\telse\n\t\teeprom_hdr_size = 0x4;\n\n\tskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL, eeprom_hdr_size +\n\t\t\t    len, P54_CONTROL_TYPE_EEPROM_READBACK,\n\t\t\t    GFP_KERNEL);\n\tif (unlikely(!skb))\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&priv->eeprom_mutex);\n\tpriv->eeprom = buf;\n\teeprom_hdr = skb_put(skb, eeprom_hdr_size + len);\n\n\tif (priv->fw_var < 0x509) {\n\t\teeprom_hdr->v1.offset = cpu_to_le16(offset);\n\t\teeprom_hdr->v1.len = cpu_to_le16(len);\n\t} else {\n\t\teeprom_hdr->v2.offset = cpu_to_le32(offset);\n\t\teeprom_hdr->v2.len = cpu_to_le16(len);\n\t\teeprom_hdr->v2.magic2 = 0xf;\n\t\tmemcpy(eeprom_hdr->v2.magic, (const char *)\"LOCK\", 4);\n\t}\n\n\tp54_tx(priv, skb);\n\n\ttimeout = wait_for_completion_interruptible_timeout(\n\t\t\t&priv->eeprom_comp, HZ);\n\tif (timeout <= 0) {\n\t\twiphy_err(priv->hw->wiphy,\n\t\t\t\"device does not respond or signal received!\\n\");\n\t\tret = -EBUSY;\n\t}\n\tpriv->eeprom = NULL;\n\tmutex_unlock(&priv->eeprom_mutex);\n\treturn ret;\n}\n\nint p54_update_beacon_tim(struct p54_common *priv, u16 aid, bool set)\n{\n\tstruct sk_buff *skb;\n\tstruct p54_tim *tim;\n\n\tskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL_OPSET, sizeof(*tim),\n\t\t\t    P54_CONTROL_TYPE_TIM, GFP_ATOMIC);\n\tif (unlikely(!skb))\n\t\treturn -ENOMEM;\n\n\ttim = skb_put(skb, sizeof(*tim));\n\ttim->count = 1;\n\ttim->entry[0] = cpu_to_le16(set ? (aid | 0x8000) : aid);\n\tp54_tx(priv, skb);\n\treturn 0;\n}\n\nint p54_sta_unlock(struct p54_common *priv, u8 *addr)\n{\n\tstruct sk_buff *skb;\n\tstruct p54_sta_unlock *sta;\n\n\tskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL_OPSET, sizeof(*sta),\n\t\t\t    P54_CONTROL_TYPE_PSM_STA_UNLOCK, GFP_ATOMIC);\n\tif (unlikely(!skb))\n\t\treturn -ENOMEM;\n\n\tsta = skb_put(skb, sizeof(*sta));\n\tmemcpy(sta->addr, addr, ETH_ALEN);\n\tp54_tx(priv, skb);\n\treturn 0;\n}\n\nint p54_tx_cancel(struct p54_common *priv, __le32 req_id)\n{\n\tstruct sk_buff *skb;\n\tstruct p54_txcancel *cancel;\n\tu32 _req_id = le32_to_cpu(req_id);\n\n\tif (unlikely(_req_id < priv->rx_start || _req_id > priv->rx_end))\n\t\treturn -EINVAL;\n\n\tskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL_OPSET, sizeof(*cancel),\n\t\t\t    P54_CONTROL_TYPE_TXCANCEL, GFP_ATOMIC);\n\tif (unlikely(!skb))\n\t\treturn -ENOMEM;\n\n\tcancel = skb_put(skb, sizeof(*cancel));\n\tcancel->req_id = req_id;\n\tp54_tx(priv, skb);\n\treturn 0;\n}\n\nint p54_setup_mac(struct p54_common *priv)\n{\n\tstruct sk_buff *skb;\n\tstruct p54_setup_mac *setup;\n\tu16 mode;\n\n\tskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL_OPSET, sizeof(*setup),\n\t\t\t    P54_CONTROL_TYPE_SETUP, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tsetup = skb_put(skb, sizeof(*setup));\n\tif (!(priv->hw->conf.flags & IEEE80211_CONF_IDLE)) {\n\t\tswitch (priv->mode) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\tmode = P54_FILTER_TYPE_STATION;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\tmode = P54_FILTER_TYPE_AP;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t\tmode = P54_FILTER_TYPE_IBSS;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_MONITOR:\n\t\t\tmode = P54_FILTER_TYPE_PROMISCUOUS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmode = P54_FILTER_TYPE_HIBERNATE;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (priv->filter_flags & FIF_OTHER_BSS &&\n\t\t    (mode != P54_FILTER_TYPE_PROMISCUOUS))\n\t\t\tmode |= P54_FILTER_TYPE_TRANSPARENT;\n\t} else {\n\t\tmode = P54_FILTER_TYPE_HIBERNATE;\n\t}\n\n\tsetup->mac_mode = cpu_to_le16(mode);\n\tmemcpy(setup->mac_addr, priv->mac_addr, ETH_ALEN);\n\tmemcpy(setup->bssid, priv->bssid, ETH_ALEN);\n\tsetup->rx_antenna = 2 & priv->rx_diversity_mask;  \n\tsetup->rx_align = 0;\n\tif (priv->fw_var < 0x500) {\n\t\tsetup->v1.basic_rate_mask = cpu_to_le32(priv->basic_rate_mask);\n\t\tmemset(setup->v1.rts_rates, 0, 8);\n\t\tsetup->v1.rx_addr = cpu_to_le32(priv->rx_end);\n\t\tsetup->v1.max_rx = cpu_to_le16(priv->rx_mtu);\n\t\tsetup->v1.rxhw = cpu_to_le16(priv->rxhw);\n\t\tsetup->v1.wakeup_timer = cpu_to_le16(priv->wakeup_timer);\n\t\tsetup->v1.unalloc0 = cpu_to_le16(0);\n\t} else {\n\t\tsetup->v2.rx_addr = cpu_to_le32(priv->rx_end);\n\t\tsetup->v2.max_rx = cpu_to_le16(priv->rx_mtu);\n\t\tsetup->v2.rxhw = cpu_to_le16(priv->rxhw);\n\t\tsetup->v2.timer = cpu_to_le16(priv->wakeup_timer);\n\t\tsetup->v2.truncate = cpu_to_le16(48896);\n\t\tsetup->v2.basic_rate_mask = cpu_to_le32(priv->basic_rate_mask);\n\t\tsetup->v2.sbss_offset = 0;\n\t\tsetup->v2.mcast_window = 0;\n\t\tsetup->v2.rx_rssi_threshold = 0;\n\t\tsetup->v2.rx_ed_threshold = 0;\n\t\tsetup->v2.ref_clock = cpu_to_le32(644245094);\n\t\tsetup->v2.lpf_bandwidth = cpu_to_le16(65535);\n\t\tsetup->v2.osc_start_delay = cpu_to_le16(65535);\n\t}\n\tp54_tx(priv, skb);\n\tpriv->phy_idle = mode == P54_FILTER_TYPE_HIBERNATE;\n\treturn 0;\n}\n\nint p54_scan(struct p54_common *priv, u16 mode, u16 dwell)\n{\n\tstruct sk_buff *skb;\n\tstruct p54_hdr *hdr;\n\tstruct p54_scan_head *head;\n\tstruct p54_iq_autocal_entry *iq_autocal;\n\tunion p54_scan_body_union *body;\n\tstruct p54_scan_tail_rate *rate;\n\tstruct pda_rssi_cal_entry *rssi;\n\tstruct p54_rssi_db_entry *rssi_data;\n\tunsigned int i;\n\tvoid *entry;\n\t__le16 freq = cpu_to_le16(priv->hw->conf.chandef.chan->center_freq);\n\n\tskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL_OPSET, sizeof(*head) +\n\t\t\t    2 + sizeof(*iq_autocal) + sizeof(*body) +\n\t\t\t    sizeof(*rate) + 2 * sizeof(*rssi),\n\t\t\t    P54_CONTROL_TYPE_SCAN, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\thead = skb_put(skb, sizeof(*head));\n\tmemset(head->scan_params, 0, sizeof(head->scan_params));\n\thead->mode = cpu_to_le16(mode);\n\thead->dwell = cpu_to_le16(dwell);\n\thead->freq = freq;\n\n\tif (priv->rxhw == PDR_SYNTH_FRONTEND_LONGBOW) {\n\t\t__le16 *pa_power_points = skb_put(skb, 2);\n\t\t*pa_power_points = cpu_to_le16(0x0c);\n\t}\n\n\tiq_autocal = skb_put(skb, sizeof(*iq_autocal));\n\tfor (i = 0; i < priv->iq_autocal_len; i++) {\n\t\tif (priv->iq_autocal[i].freq != freq)\n\t\t\tcontinue;\n\n\t\tmemcpy(iq_autocal, &priv->iq_autocal[i].params,\n\t\t       sizeof(struct p54_iq_autocal_entry));\n\t\tbreak;\n\t}\n\tif (i == priv->iq_autocal_len)\n\t\tgoto err;\n\n\tif (priv->rxhw == PDR_SYNTH_FRONTEND_LONGBOW)\n\t\tbody = skb_put(skb, sizeof(body->longbow));\n\telse\n\t\tbody = skb_put(skb, sizeof(body->normal));\n\n\tfor (i = 0; i < priv->output_limit->entries; i++) {\n\t\t__le16 *entry_freq = (void *) (priv->output_limit->data +\n\t\t\t\t     priv->output_limit->entry_size * i);\n\n\t\tif (*entry_freq != freq)\n\t\t\tcontinue;\n\n\t\tif (priv->rxhw == PDR_SYNTH_FRONTEND_LONGBOW) {\n\t\t\tmemcpy(&body->longbow.power_limits,\n\t\t\t       (void *) entry_freq + sizeof(__le16),\n\t\t\t       priv->output_limit->entry_size);\n\t\t} else {\n\t\t\tstruct pda_channel_output_limit *limits =\n\t\t\t       (void *) entry_freq;\n\n\t\t\tbody->normal.val_barker = 0x38;\n\t\t\tbody->normal.val_bpsk = body->normal.dup_bpsk =\n\t\t\t\tlimits->val_bpsk;\n\t\t\tbody->normal.val_qpsk = body->normal.dup_qpsk =\n\t\t\t\tlimits->val_qpsk;\n\t\t\tbody->normal.val_16qam = body->normal.dup_16qam =\n\t\t\t\tlimits->val_16qam;\n\t\t\tbody->normal.val_64qam = body->normal.dup_64qam =\n\t\t\t\tlimits->val_64qam;\n\t\t}\n\t\tbreak;\n\t}\n\tif (i == priv->output_limit->entries)\n\t\tgoto err;\n\n\tentry = (void *)(priv->curve_data->data + priv->curve_data->offset);\n\tfor (i = 0; i < priv->curve_data->entries; i++) {\n\t\tif (*((__le16 *)entry) != freq) {\n\t\t\tentry += priv->curve_data->entry_size;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (priv->rxhw == PDR_SYNTH_FRONTEND_LONGBOW) {\n\t\t\tmemcpy(&body->longbow.curve_data,\n\t\t\t\tentry + sizeof(__le16),\n\t\t\t\tpriv->curve_data->entry_size);\n\t\t} else {\n\t\t\tstruct p54_scan_body *chan = &body->normal;\n\t\t\tstruct pda_pa_curve_data *curve_data =\n\t\t\t\t(void *) priv->curve_data->data;\n\n\t\t\tentry += sizeof(__le16);\n\t\t\tchan->pa_points_per_curve = 8;\n\t\t\tmemset(chan->curve_data, 0, sizeof(chan->curve_data));\n\t\t\tmemcpy(chan->curve_data, entry,\n\t\t\t       sizeof(struct p54_pa_curve_data_sample) *\n\t\t\t       min((u8)8, curve_data->points_per_channel));\n\t\t}\n\t\tbreak;\n\t}\n\tif (i == priv->curve_data->entries)\n\t\tgoto err;\n\n\tif ((priv->fw_var >= 0x500) && (priv->fw_var < 0x509)) {\n\t\trate = skb_put(skb, sizeof(*rate));\n\t\trate->basic_rate_mask = cpu_to_le32(priv->basic_rate_mask);\n\t\tfor (i = 0; i < sizeof(rate->rts_rates); i++)\n\t\t\trate->rts_rates[i] = i;\n\t}\n\n\trssi = skb_put(skb, sizeof(*rssi));\n\trssi_data = p54_rssi_find(priv, le16_to_cpu(freq));\n\trssi->mul = cpu_to_le16(rssi_data->mul);\n\trssi->add = cpu_to_le16(rssi_data->add);\n\tif (priv->rxhw == PDR_SYNTH_FRONTEND_LONGBOW) {\n\t\t \n\t\trssi = skb_put(skb, sizeof(*rssi));\n\t\trssi->mul = cpu_to_le16(rssi_data->longbow_unkn);\n\t\trssi->add = cpu_to_le16(rssi_data->longbow_unk2);\n\t}\n\n\tif (priv->fw_var >= 0x509) {\n\t\trate = skb_put(skb, sizeof(*rate));\n\t\trate->basic_rate_mask = cpu_to_le32(priv->basic_rate_mask);\n\t\tfor (i = 0; i < sizeof(rate->rts_rates); i++)\n\t\t\trate->rts_rates[i] = i;\n\t}\n\n\thdr = (struct p54_hdr *) skb->data;\n\thdr->len = cpu_to_le16(skb->len - sizeof(*hdr));\n\n\tp54_tx(priv, skb);\n\tpriv->cur_rssi = rssi_data;\n\treturn 0;\n\nerr:\n\twiphy_err(priv->hw->wiphy, \"frequency change to channel %d failed.\\n\",\n\t\t  ieee80211_frequency_to_channel(\n\t\t\t  priv->hw->conf.chandef.chan->center_freq));\n\n\tdev_kfree_skb_any(skb);\n\treturn -EINVAL;\n}\n\nint p54_set_leds(struct p54_common *priv)\n{\n\tstruct sk_buff *skb;\n\tstruct p54_led *led;\n\n\tskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL_OPSET, sizeof(*led),\n\t\t\t    P54_CONTROL_TYPE_LED, GFP_ATOMIC);\n\tif (unlikely(!skb))\n\t\treturn -ENOMEM;\n\n\tled = skb_put(skb, sizeof(*led));\n\tled->flags = cpu_to_le16(0x0003);\n\tled->mask[0] = led->mask[1] = cpu_to_le16(priv->softled_state);\n\tled->delay[0] = cpu_to_le16(1);\n\tled->delay[1] = cpu_to_le16(0);\n\tp54_tx(priv, skb);\n\treturn 0;\n}\n\nint p54_set_edcf(struct p54_common *priv)\n{\n\tstruct sk_buff *skb;\n\tstruct p54_edcf *edcf;\n\tu8 rtd;\n\n\tskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL_OPSET, sizeof(*edcf),\n\t\t\t    P54_CONTROL_TYPE_DCFINIT, GFP_ATOMIC);\n\tif (unlikely(!skb))\n\t\treturn -ENOMEM;\n\n\tedcf = skb_put(skb, sizeof(*edcf));\n\tif (priv->use_short_slot) {\n\t\tedcf->slottime = 9;\n\t\tedcf->sifs = 0x10;\n\t\tedcf->eofpad = 0x00;\n\t} else {\n\t\tedcf->slottime = 20;\n\t\tedcf->sifs = 0x0a;\n\t\tedcf->eofpad = 0x06;\n\t}\n\t \n\trtd = 3 * priv->coverage_class;\n\tedcf->slottime += rtd;\n\tedcf->round_trip_delay = cpu_to_le16(rtd);\n\t \n\tedcf->frameburst = cpu_to_le16(0);\n\tedcf->flags = 0;\n\tmemset(edcf->mapping, 0, sizeof(edcf->mapping));\n\tmemcpy(edcf->queue, priv->qos_params, sizeof(edcf->queue));\n\tp54_tx(priv, skb);\n\treturn 0;\n}\n\nint p54_set_ps(struct p54_common *priv)\n{\n\tstruct sk_buff *skb;\n\tstruct p54_psm *psm;\n\tunsigned int i;\n\tu16 mode;\n\n\tif (priv->hw->conf.flags & IEEE80211_CONF_PS &&\n\t    !priv->powersave_override)\n\t\tmode = P54_PSM | P54_PSM_BEACON_TIMEOUT | P54_PSM_DTIM |\n\t\t       P54_PSM_CHECKSUM | P54_PSM_MCBC;\n\telse\n\t\tmode = P54_PSM_CAM;\n\n\tskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL_OPSET, sizeof(*psm),\n\t\t\t    P54_CONTROL_TYPE_PSM, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tpsm = skb_put(skb, sizeof(*psm));\n\tpsm->mode = cpu_to_le16(mode);\n\tpsm->aid = cpu_to_le16(priv->aid);\n\tfor (i = 0; i < ARRAY_SIZE(psm->intervals); i++) {\n\t\tpsm->intervals[i].interval =\n\t\t\tcpu_to_le16(priv->hw->conf.listen_interval);\n\t\tpsm->intervals[i].periods = cpu_to_le16(1);\n\t}\n\n\tpsm->beacon_rssi_skip_max = 200;\n\tpsm->rssi_delta_threshold = 0;\n\tpsm->nr = 1;\n\tpsm->exclude[0] = WLAN_EID_TIM;\n\n\tp54_tx(priv, skb);\n\tpriv->phy_ps = mode != P54_PSM_CAM;\n\treturn 0;\n}\n\nint p54_init_xbow_synth(struct p54_common *priv)\n{\n\tstruct sk_buff *skb;\n\tstruct p54_xbow_synth *xbow;\n\n\tskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL_OPSET, sizeof(*xbow),\n\t\t\t    P54_CONTROL_TYPE_XBOW_SYNTH_CFG, GFP_KERNEL);\n\tif (unlikely(!skb))\n\t\treturn -ENOMEM;\n\n\txbow = skb_put(skb, sizeof(*xbow));\n\txbow->magic1 = cpu_to_le16(0x1);\n\txbow->magic2 = cpu_to_le16(0x2);\n\txbow->freq = cpu_to_le16(5390);\n\tmemset(xbow->padding, 0, sizeof(xbow->padding));\n\tp54_tx(priv, skb);\n\treturn 0;\n}\n\nint p54_upload_key(struct p54_common *priv, u8 algo, int slot, u8 idx, u8 len,\n\t\t   u8 *addr, u8* key)\n{\n\tstruct sk_buff *skb;\n\tstruct p54_keycache *rxkey;\n\n\tskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL_OPSET, sizeof(*rxkey),\n\t\t\t    P54_CONTROL_TYPE_RX_KEYCACHE, GFP_KERNEL);\n\tif (unlikely(!skb))\n\t\treturn -ENOMEM;\n\n\trxkey = skb_put(skb, sizeof(*rxkey));\n\trxkey->entry = slot;\n\trxkey->key_id = idx;\n\trxkey->key_type = algo;\n\tif (addr)\n\t\tmemcpy(rxkey->mac, addr, ETH_ALEN);\n\telse\n\t\teth_broadcast_addr(rxkey->mac);\n\n\tswitch (algo) {\n\tcase P54_CRYPTO_WEP:\n\tcase P54_CRYPTO_AESCCMP:\n\t\trxkey->key_len = min_t(u8, 16, len);\n\t\tmemcpy(rxkey->key, key, rxkey->key_len);\n\t\tbreak;\n\n\tcase P54_CRYPTO_TKIPMICHAEL:\n\t\trxkey->key_len = 24;\n\t\tmemcpy(rxkey->key, key, 16);\n\t\tmemcpy(&(rxkey->key[16]), &(key\n\t\t\t[NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY]), 8);\n\t\tbreak;\n\n\tcase P54_CRYPTO_NONE:\n\t\trxkey->key_len = 0;\n\t\tmemset(rxkey->key, 0, sizeof(rxkey->key));\n\t\tbreak;\n\n\tdefault:\n\t\twiphy_err(priv->hw->wiphy,\n\t\t\t  \"invalid cryptographic algorithm: %d\\n\", algo);\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tp54_tx(priv, skb);\n\treturn 0;\n}\n\nint p54_fetch_statistics(struct p54_common *priv)\n{\n\tstruct ieee80211_tx_info *txinfo;\n\tstruct p54_tx_info *p54info;\n\tstruct sk_buff *skb;\n\n\tskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL,\n\t\t\t    sizeof(struct p54_statistics),\n\t\t\t    P54_CONTROL_TYPE_STAT_READBACK, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\t \n\ttxinfo = IEEE80211_SKB_CB(skb);\n\tp54info = (void *) txinfo->rate_driver_data;\n\tp54info->extra_len = sizeof(struct p54_statistics);\n\n\tp54_tx(priv, skb);\n\treturn 0;\n}\n\nint p54_set_groupfilter(struct p54_common *priv)\n{\n\tstruct p54_group_address_table *grp;\n\tstruct sk_buff *skb;\n\tbool on = false;\n\n\tskb = p54_alloc_skb(priv, P54_HDR_FLAG_CONTROL_OPSET, sizeof(*grp),\n\t\t\t    P54_CONTROL_TYPE_GROUP_ADDRESS_TABLE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tgrp = skb_put(skb, sizeof(*grp));\n\n\ton = !(priv->filter_flags & FIF_ALLMULTI) &&\n\t     (priv->mc_maclist_num > 0 &&\n\t      priv->mc_maclist_num <= MC_FILTER_ADDRESS_NUM);\n\n\tif (on) {\n\t\tgrp->filter_enable = cpu_to_le16(1);\n\t\tgrp->num_address = cpu_to_le16(priv->mc_maclist_num);\n\t\tmemcpy(grp->mac_list, priv->mc_maclist, sizeof(grp->mac_list));\n\t} else {\n\t\tgrp->filter_enable = cpu_to_le16(0);\n\t\tgrp->num_address = cpu_to_le16(0);\n\t\tmemset(grp->mac_list, 0, sizeof(grp->mac_list));\n\t}\n\n\tp54_tx(priv, skb);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}