{
  "module_name": "airport.c",
  "hash_id": "362e1df32de3a1da5b956f1bae4c18e40d8ea4564a0b2bc4d956dfc8a77187f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/orinoco/airport.c",
  "human_readable_source": " \n\n#define DRIVER_NAME \"airport\"\n#define PFX DRIVER_NAME \": \"\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/mod_devicetable.h>\n#include <asm/pmac_feature.h>\n\n#include \"orinoco.h\"\n\n#define AIRPORT_IO_LEN\t(0x1000)\t \n\nstruct airport {\n\tstruct macio_dev *mdev;\n\tvoid __iomem *vaddr;\n\tunsigned int irq;\n\tint irq_requested;\n\tint ndev_registered;\n};\n\nstatic int\nairport_suspend(struct macio_dev *mdev, pm_message_t state)\n{\n\tstruct orinoco_private *priv = dev_get_drvdata(&mdev->ofdev.dev);\n\tstruct net_device *dev = priv->ndev;\n\tstruct airport *card = priv->card;\n\tunsigned long flags;\n\tint err;\n\n\tprintk(KERN_DEBUG \"%s: Airport entering sleep mode\\n\", dev->name);\n\n\terr = orinoco_lock(priv, &flags);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: hw_unavailable on PBOOK_SLEEP_NOW\\n\",\n\t\t       dev->name);\n\t\treturn 0;\n\t}\n\n\torinoco_down(priv);\n\torinoco_unlock(priv, &flags);\n\n\tdisable_irq(card->irq);\n\tpmac_call_feature(PMAC_FTR_AIRPORT_ENABLE,\n\t\t\t  macio_get_of_node(mdev), 0, 0);\n\n\treturn 0;\n}\n\nstatic int\nairport_resume(struct macio_dev *mdev)\n{\n\tstruct orinoco_private *priv = dev_get_drvdata(&mdev->ofdev.dev);\n\tstruct net_device *dev = priv->ndev;\n\tstruct airport *card = priv->card;\n\tunsigned long flags;\n\tint err;\n\n\tprintk(KERN_DEBUG \"%s: Airport waking up\\n\", dev->name);\n\n\tpmac_call_feature(PMAC_FTR_AIRPORT_ENABLE,\n\t\t\t  macio_get_of_node(mdev), 0, 1);\n\tmsleep(200);\n\n\tenable_irq(card->irq);\n\n\tpriv->hw.ops->lock_irqsave(&priv->lock, &flags);\n\terr = orinoco_up(priv);\n\tpriv->hw.ops->unlock_irqrestore(&priv->lock, &flags);\n\n\treturn err;\n}\n\nstatic int\nairport_detach(struct macio_dev *mdev)\n{\n\tstruct orinoco_private *priv = dev_get_drvdata(&mdev->ofdev.dev);\n\tstruct airport *card = priv->card;\n\n\tif (card->ndev_registered)\n\t\torinoco_if_del(priv);\n\tcard->ndev_registered = 0;\n\n\tif (card->irq_requested)\n\t\tfree_irq(card->irq, priv);\n\tcard->irq_requested = 0;\n\n\tif (card->vaddr)\n\t\tiounmap(card->vaddr);\n\tcard->vaddr = NULL;\n\n\tmacio_release_resource(mdev, 0);\n\n\tpmac_call_feature(PMAC_FTR_AIRPORT_ENABLE,\n\t\t\t  macio_get_of_node(mdev), 0, 0);\n\tssleep(1);\n\n\tmacio_set_drvdata(mdev, NULL);\n\tfree_orinocodev(priv);\n\n\treturn 0;\n}\n\nstatic int airport_hard_reset(struct orinoco_private *priv)\n{\n\t \n#if 0\n\tstruct airport *card = priv->card;\n\n\t \n\tdisable_irq(card->irq);\n\n\tpmac_call_feature(PMAC_FTR_AIRPORT_ENABLE,\n\t\t\t  macio_get_of_node(card->mdev), 0, 0);\n\tssleep(1);\n\tpmac_call_feature(PMAC_FTR_AIRPORT_ENABLE,\n\t\t\t  macio_get_of_node(card->mdev), 0, 1);\n\tssleep(1);\n\n\tenable_irq(card->irq);\n\tssleep(1);\n#endif\n\n\treturn 0;\n}\n\nstatic int\nairport_attach(struct macio_dev *mdev, const struct of_device_id *match)\n{\n\tstruct orinoco_private *priv;\n\tstruct airport *card;\n\tunsigned long phys_addr;\n\tstruct hermes *hw;\n\n\tif (macio_resource_count(mdev) < 1 || macio_irq_count(mdev) < 1) {\n\t\tprintk(KERN_ERR PFX \"Wrong interrupt/addresses in OF tree\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tpriv = alloc_orinocodev(sizeof(*card), &mdev->ofdev.dev,\n\t\t\t\tairport_hard_reset, NULL);\n\tif (!priv) {\n\t\tprintk(KERN_ERR PFX \"Cannot allocate network device\\n\");\n\t\treturn -ENODEV;\n\t}\n\tcard = priv->card;\n\n\thw = &priv->hw;\n\tcard->mdev = mdev;\n\n\tif (macio_request_resource(mdev, 0, DRIVER_NAME)) {\n\t\tprintk(KERN_ERR PFX \"can't request IO resource !\\n\");\n\t\tfree_orinocodev(priv);\n\t\treturn -EBUSY;\n\t}\n\n\tmacio_set_drvdata(mdev, priv);\n\n\t \n\tcard->irq = macio_irq(mdev, 0);\n\tphys_addr = macio_resource_start(mdev, 0);   \n\tprintk(KERN_DEBUG PFX \"Physical address %lx\\n\", phys_addr);\n\tcard->vaddr = ioremap(phys_addr, AIRPORT_IO_LEN);\n\tif (!card->vaddr) {\n\t\tprintk(KERN_ERR PFX \"ioremap() failed\\n\");\n\t\tgoto failed;\n\t}\n\n\thermes_struct_init(hw, card->vaddr, HERMES_16BIT_REGSPACING);\n\n\t \n\tpmac_call_feature(PMAC_FTR_AIRPORT_ENABLE,\n\t\t\t  macio_get_of_node(mdev), 0, 1);\n\tssleep(1);\n\n\t \n\thw->ops->init(hw);\n\n\tif (request_irq(card->irq, orinoco_interrupt, 0, DRIVER_NAME, priv)) {\n\t\tprintk(KERN_ERR PFX \"Couldn't get IRQ %d\\n\", card->irq);\n\t\tgoto failed;\n\t}\n\tcard->irq_requested = 1;\n\n\t \n\tif (orinoco_init(priv) != 0) {\n\t\tprintk(KERN_ERR PFX \"orinoco_init() failed\\n\");\n\t\tgoto failed;\n\t}\n\n\t \n\tif (orinoco_if_add(priv, phys_addr, card->irq, NULL) != 0) {\n\t\tprintk(KERN_ERR PFX \"orinoco_if_add() failed\\n\");\n\t\tgoto failed;\n\t}\n\tcard->ndev_registered = 1;\n\treturn 0;\n failed:\n\tairport_detach(mdev);\n\treturn -ENODEV;\n}\t\t\t\t \n\n\nstatic char version[] __initdata = DRIVER_NAME \" \" DRIVER_VERSION\n\t\" (Benjamin Herrenschmidt <benh@kernel.crashing.org>)\";\nMODULE_AUTHOR(\"Benjamin Herrenschmidt <benh@kernel.crashing.org>\");\nMODULE_DESCRIPTION(\"Driver for the Apple Airport wireless card.\");\nMODULE_LICENSE(\"Dual MPL/GPL\");\n\nstatic const struct of_device_id airport_match[] = {\n\t{\n\t.name\t\t= \"radio\",\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, airport_match);\n\nstatic struct macio_driver airport_driver = {\n\t.driver = {\n\t\t.name\t\t= DRIVER_NAME,\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.of_match_table\t= airport_match,\n\t},\n\t.probe\t\t= airport_attach,\n\t.remove\t\t= airport_detach,\n\t.suspend\t= airport_suspend,\n\t.resume\t\t= airport_resume,\n};\n\nstatic int __init\ninit_airport(void)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", version);\n\n\treturn macio_register_driver(&airport_driver);\n}\n\nstatic void __exit\nexit_airport(void)\n{\n\tmacio_unregister_driver(&airport_driver);\n}\n\nmodule_init(init_airport);\nmodule_exit(exit_airport);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}