{
  "module_name": "hermes.c",
  "hash_id": "c2fbc52415ae51cbc15004fb29ef4cbe88545b19fe3e1ca629f49bb06bfb43b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/orinoco/hermes.c",
  "human_readable_source": " \n\n#include <linux/net.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n\n#include \"hermes.h\"\n\n \n#define CMD_BUSY_TIMEOUT (100)  \n#define CMD_INIT_TIMEOUT (50000)  \n#define CMD_COMPL_TIMEOUT (20000)  \n#define ALLOC_COMPL_TIMEOUT (1000)  \n\n \n#define HERMES_AUX_ENABLE\t0x8000\t \n#define HERMES_AUX_DISABLE\t0x4000\t \n#define HERMES_AUX_ENABLED\t0xC000\t \n#define HERMES_AUX_DISABLED\t0x0000\t \n\n#define HERMES_AUX_PW0\t0xFE01\n#define HERMES_AUX_PW1\t0xDC23\n#define HERMES_AUX_PW2\t0xBA45\n\n \n#define HERMES_PROGRAM_DISABLE             (0x0000 | HERMES_CMD_DOWNLD)\n#define HERMES_PROGRAM_ENABLE_VOLATILE     (0x0100 | HERMES_CMD_DOWNLD)\n#define HERMES_PROGRAM_ENABLE_NON_VOLATILE (0x0200 | HERMES_CMD_DOWNLD)\n#define HERMES_PROGRAM_NON_VOLATILE        (0x0300 | HERMES_CMD_DOWNLD)\n\n \n\n#define DMSG(stuff...) do {printk(KERN_DEBUG \"hermes @ %p: \" , hw->iobase); \\\n\t\t\tprintk(stuff); } while (0)\n\n#undef HERMES_DEBUG\n#ifdef HERMES_DEBUG\n\n#define DEBUG(lvl, stuff...) if ((lvl) <= HERMES_DEBUG) DMSG(stuff)\n\n#else  \n\n#define DEBUG(lvl, stuff...) do { } while (0)\n\n#endif  \n\nstatic const struct hermes_ops hermes_ops_local;\n\n \n\n \nstatic int hermes_issue_cmd(struct hermes *hw, u16 cmd, u16 param0,\n\t\t\t    u16 param1, u16 param2)\n{\n\tint k = CMD_BUSY_TIMEOUT;\n\tu16 reg;\n\n\t \n\treg = hermes_read_regn(hw, CMD);\n\twhile ((reg & HERMES_CMD_BUSY) && k) {\n\t\tk--;\n\t\tudelay(1);\n\t\treg = hermes_read_regn(hw, CMD);\n\t}\n\tif (reg & HERMES_CMD_BUSY)\n\t\treturn -EBUSY;\n\n\thermes_write_regn(hw, PARAM2, param2);\n\thermes_write_regn(hw, PARAM1, param1);\n\thermes_write_regn(hw, PARAM0, param0);\n\thermes_write_regn(hw, CMD, cmd);\n\n\treturn 0;\n}\n\n \n\n \nstatic int hermes_doicmd_wait(struct hermes *hw, u16 cmd,\n\t\t\t      u16 parm0, u16 parm1, u16 parm2,\n\t\t\t      struct hermes_response *resp)\n{\n\tint err = 0;\n\tint k;\n\tu16 status, reg;\n\n\terr = hermes_issue_cmd(hw, cmd, parm0, parm1, parm2);\n\tif (err)\n\t\treturn err;\n\n\treg = hermes_read_regn(hw, EVSTAT);\n\tk = CMD_INIT_TIMEOUT;\n\twhile ((!(reg & HERMES_EV_CMD)) && k) {\n\t\tk--;\n\t\tudelay(10);\n\t\treg = hermes_read_regn(hw, EVSTAT);\n\t}\n\n\thermes_write_regn(hw, SWSUPPORT0, HERMES_MAGIC);\n\n\tif (!hermes_present(hw)) {\n\t\tDEBUG(0, \"hermes @ 0x%x: Card removed during reset.\\n\",\n\t\t       hw->iobase);\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (!(reg & HERMES_EV_CMD)) {\n\t\tprintk(KERN_ERR \"hermes @ %p: \"\n\t\t       \"Timeout waiting for card to reset (reg=0x%04x)!\\n\",\n\t\t       hw->iobase, reg);\n\t\terr = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\tstatus = hermes_read_regn(hw, STATUS);\n\tif (resp) {\n\t\tresp->status = status;\n\t\tresp->resp0 = hermes_read_regn(hw, RESP0);\n\t\tresp->resp1 = hermes_read_regn(hw, RESP1);\n\t\tresp->resp2 = hermes_read_regn(hw, RESP2);\n\t}\n\n\thermes_write_regn(hw, EVACK, HERMES_EV_CMD);\n\n\tif (status & HERMES_STATUS_RESULT)\n\t\terr = -EIO;\nout:\n\treturn err;\n}\n\nvoid hermes_struct_init(struct hermes *hw, void __iomem *address,\n\t\t\tint reg_spacing)\n{\n\thw->iobase = address;\n\thw->reg_spacing = reg_spacing;\n\thw->inten = 0x0;\n\thw->eeprom_pda = false;\n\thw->ops = &hermes_ops_local;\n}\nEXPORT_SYMBOL(hermes_struct_init);\n\nstatic int hermes_init(struct hermes *hw)\n{\n\tu16 reg;\n\tint err = 0;\n\tint k;\n\n\t \n\thw->inten = 0x0;\n\thermes_write_regn(hw, INTEN, 0);\n\thermes_write_regn(hw, EVACK, 0xffff);\n\n\t \n\tk = CMD_BUSY_TIMEOUT;\n\treg = hermes_read_regn(hw, CMD);\n\twhile (k && (reg & HERMES_CMD_BUSY)) {\n\t\tif (reg == 0xffff)  \n\t\t\treturn -ENODEV;\n\n\t\tk--;\n\t\tudelay(1);\n\t\treg = hermes_read_regn(hw, CMD);\n\t}\n\n\t \n\n\t \n\treg = hermes_read_regn(hw, EVSTAT);\n\thermes_write_regn(hw, EVACK, reg);\n\n\t \n\terr = hermes_doicmd_wait(hw, HERMES_CMD_INIT, 0, 0, 0, NULL);\n\n\treturn err;\n}\n\n \nstatic int hermes_docmd_wait(struct hermes *hw, u16 cmd, u16 parm0,\n\t\t\t     struct hermes_response *resp)\n{\n\tint err;\n\tint k;\n\tu16 reg;\n\tu16 status;\n\n\terr = hermes_issue_cmd(hw, cmd, parm0, 0, 0);\n\tif (err) {\n\t\tif (!hermes_present(hw)) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tprintk(KERN_WARNING \"hermes @ %p: \"\n\t\t\t\t       \"Card removed while issuing command \"\n\t\t\t\t       \"0x%04x.\\n\", hw->iobase, cmd);\n\t\t\terr = -ENODEV;\n\t\t} else\n\t\t\tif (net_ratelimit())\n\t\t\t\tprintk(KERN_ERR \"hermes @ %p: \"\n\t\t\t\t       \"Error %d issuing command 0x%04x.\\n\",\n\t\t\t\t       hw->iobase, err, cmd);\n\t\tgoto out;\n\t}\n\n\treg = hermes_read_regn(hw, EVSTAT);\n\tk = CMD_COMPL_TIMEOUT;\n\twhile ((!(reg & HERMES_EV_CMD)) && k) {\n\t\tk--;\n\t\tudelay(10);\n\t\treg = hermes_read_regn(hw, EVSTAT);\n\t}\n\n\tif (!hermes_present(hw)) {\n\t\tprintk(KERN_WARNING \"hermes @ %p: Card removed \"\n\t\t       \"while waiting for command 0x%04x completion.\\n\",\n\t\t       hw->iobase, cmd);\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (!(reg & HERMES_EV_CMD)) {\n\t\tprintk(KERN_ERR \"hermes @ %p: Timeout waiting for \"\n\t\t       \"command 0x%04x completion.\\n\", hw->iobase, cmd);\n\t\terr = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\tstatus = hermes_read_regn(hw, STATUS);\n\tif (resp) {\n\t\tresp->status = status;\n\t\tresp->resp0 = hermes_read_regn(hw, RESP0);\n\t\tresp->resp1 = hermes_read_regn(hw, RESP1);\n\t\tresp->resp2 = hermes_read_regn(hw, RESP2);\n\t}\n\n\thermes_write_regn(hw, EVACK, HERMES_EV_CMD);\n\n\tif (status & HERMES_STATUS_RESULT)\n\t\terr = -EIO;\n\n out:\n\treturn err;\n}\n\nstatic int hermes_allocate(struct hermes *hw, u16 size, u16 *fid)\n{\n\tint err = 0;\n\tint k;\n\tu16 reg;\n\n\tif ((size < HERMES_ALLOC_LEN_MIN) || (size > HERMES_ALLOC_LEN_MAX))\n\t\treturn -EINVAL;\n\n\terr = hermes_docmd_wait(hw, HERMES_CMD_ALLOC, size, NULL);\n\tif (err)\n\t\treturn err;\n\n\treg = hermes_read_regn(hw, EVSTAT);\n\tk = ALLOC_COMPL_TIMEOUT;\n\twhile ((!(reg & HERMES_EV_ALLOC)) && k) {\n\t\tk--;\n\t\tudelay(10);\n\t\treg = hermes_read_regn(hw, EVSTAT);\n\t}\n\n\tif (!hermes_present(hw)) {\n\t\tprintk(KERN_WARNING \"hermes @ %p: \"\n\t\t       \"Card removed waiting for frame allocation.\\n\",\n\t\t       hw->iobase);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!(reg & HERMES_EV_ALLOC)) {\n\t\tprintk(KERN_ERR \"hermes @ %p: \"\n\t\t       \"Timeout waiting for frame allocation\\n\",\n\t\t       hw->iobase);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t*fid = hermes_read_regn(hw, ALLOCFID);\n\thermes_write_regn(hw, EVACK, HERMES_EV_ALLOC);\n\n\treturn 0;\n}\n\n \nstatic int hermes_bap_seek(struct hermes *hw, int bap, u16 id, u16 offset)\n{\n\tint sreg = bap ? HERMES_SELECT1 : HERMES_SELECT0;\n\tint oreg = bap ? HERMES_OFFSET1 : HERMES_OFFSET0;\n\tint k;\n\tu16 reg;\n\n\t \n\tif ((offset > HERMES_BAP_OFFSET_MAX) || (offset % 2))\n\t\treturn -EINVAL;\n\n\tk = HERMES_BAP_BUSY_TIMEOUT;\n\treg = hermes_read_reg(hw, oreg);\n\twhile ((reg & HERMES_OFFSET_BUSY) && k) {\n\t\tk--;\n\t\tudelay(1);\n\t\treg = hermes_read_reg(hw, oreg);\n\t}\n\n\tif (reg & HERMES_OFFSET_BUSY)\n\t\treturn -ETIMEDOUT;\n\n\t \n\thermes_write_reg(hw, sreg, id);\n\thermes_write_reg(hw, oreg, offset);\n\n\t \n\tk = HERMES_BAP_BUSY_TIMEOUT;\n\treg = hermes_read_reg(hw, oreg);\n\twhile ((reg & (HERMES_OFFSET_BUSY | HERMES_OFFSET_ERR)) && k) {\n\t\tk--;\n\t\tudelay(1);\n\t\treg = hermes_read_reg(hw, oreg);\n\t}\n\n\tif (reg != offset) {\n\t\tprintk(KERN_ERR \"hermes @ %p: BAP%d offset %s: \"\n\t\t       \"reg=0x%x id=0x%x offset=0x%x\\n\", hw->iobase, bap,\n\t\t       (reg & HERMES_OFFSET_BUSY) ? \"timeout\" : \"error\",\n\t\t       reg, id, offset);\n\n\t\tif (reg & HERMES_OFFSET_BUSY)\n\t\t\treturn -ETIMEDOUT;\n\n\t\treturn -EIO;\t\t \n\t}\n\n\treturn 0;\n}\n\n \nstatic int hermes_bap_pread(struct hermes *hw, int bap, void *buf, int len,\n\t\t\t    u16 id, u16 offset)\n{\n\tint dreg = bap ? HERMES_DATA1 : HERMES_DATA0;\n\tint err = 0;\n\n\tif ((len < 0) || (len % 2))\n\t\treturn -EINVAL;\n\n\terr = hermes_bap_seek(hw, bap, id, offset);\n\tif (err)\n\t\tgoto out;\n\n\t \n\thermes_read_words(hw, dreg, buf, len / 2);\n\n out:\n\treturn err;\n}\n\n \nstatic int hermes_bap_pwrite(struct hermes *hw, int bap, const void *buf,\n\t\t\t     int len, u16 id, u16 offset)\n{\n\tint dreg = bap ? HERMES_DATA1 : HERMES_DATA0;\n\tint err = 0;\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\terr = hermes_bap_seek(hw, bap, id, offset);\n\tif (err)\n\t\tgoto out;\n\n\t \n\thermes_write_bytes(hw, dreg, buf, len);\n\n out:\n\treturn err;\n}\n\n \nstatic int hermes_read_ltv(struct hermes *hw, int bap, u16 rid,\n\t\t\t   unsigned bufsize, u16 *length, void *buf)\n{\n\tint err = 0;\n\tint dreg = bap ? HERMES_DATA1 : HERMES_DATA0;\n\tu16 rlength, rtype;\n\tunsigned nwords;\n\n\tif (bufsize % 2)\n\t\treturn -EINVAL;\n\n\terr = hermes_docmd_wait(hw, HERMES_CMD_ACCESS, rid, NULL);\n\tif (err)\n\t\treturn err;\n\n\terr = hermes_bap_seek(hw, bap, rid, 0);\n\tif (err)\n\t\treturn err;\n\n\trlength = hermes_read_reg(hw, dreg);\n\n\tif (!rlength)\n\t\treturn -ENODATA;\n\n\trtype = hermes_read_reg(hw, dreg);\n\n\tif (length)\n\t\t*length = rlength;\n\n\tif (rtype != rid)\n\t\tprintk(KERN_WARNING \"hermes @ %p: %s(): \"\n\t\t       \"rid (0x%04x) does not match type (0x%04x)\\n\",\n\t\t       hw->iobase, __func__, rid, rtype);\n\tif (HERMES_RECLEN_TO_BYTES(rlength) > bufsize)\n\t\tprintk(KERN_WARNING \"hermes @ %p: \"\n\t\t       \"Truncating LTV record from %d to %d bytes. \"\n\t\t       \"(rid=0x%04x, len=0x%04x)\\n\", hw->iobase,\n\t\t       HERMES_RECLEN_TO_BYTES(rlength), bufsize, rid, rlength);\n\n\tnwords = min((unsigned)rlength - 1, bufsize / 2);\n\thermes_read_words(hw, dreg, buf, nwords);\n\n\treturn 0;\n}\n\nstatic int hermes_write_ltv(struct hermes *hw, int bap, u16 rid,\n\t\t\t    u16 length, const void *value)\n{\n\tint dreg = bap ? HERMES_DATA1 : HERMES_DATA0;\n\tint err = 0;\n\tunsigned count;\n\n\tif (length == 0)\n\t\treturn -EINVAL;\n\n\terr = hermes_bap_seek(hw, bap, rid, 0);\n\tif (err)\n\t\treturn err;\n\n\thermes_write_reg(hw, dreg, length);\n\thermes_write_reg(hw, dreg, rid);\n\n\tcount = length - 1;\n\n\thermes_write_bytes(hw, dreg, value, count << 1);\n\n\terr = hermes_docmd_wait(hw, HERMES_CMD_ACCESS | HERMES_CMD_WRITE,\n\t\t\t\trid, NULL);\n\n\treturn err;\n}\n\n \n\nstatic inline void\nhermes_aux_setaddr(struct hermes *hw, u32 addr)\n{\n\thermes_write_reg(hw, HERMES_AUXPAGE, (u16) (addr >> 7));\n\thermes_write_reg(hw, HERMES_AUXOFFSET, (u16) (addr & 0x7F));\n}\n\nstatic inline int\nhermes_aux_control(struct hermes *hw, int enabled)\n{\n\tint desired_state = enabled ? HERMES_AUX_ENABLED : HERMES_AUX_DISABLED;\n\tint action = enabled ? HERMES_AUX_ENABLE : HERMES_AUX_DISABLE;\n\tint i;\n\n\t \n\tif (hermes_read_reg(hw, HERMES_CONTROL) == desired_state)\n\t\treturn 0;\n\n\thermes_write_reg(hw, HERMES_PARAM0, HERMES_AUX_PW0);\n\thermes_write_reg(hw, HERMES_PARAM1, HERMES_AUX_PW1);\n\thermes_write_reg(hw, HERMES_PARAM2, HERMES_AUX_PW2);\n\thermes_write_reg(hw, HERMES_CONTROL, action);\n\n\tfor (i = 0; i < 20; i++) {\n\t\tudelay(10);\n\t\tif (hermes_read_reg(hw, HERMES_CONTROL) ==\n\t\t    desired_state)\n\t\t\treturn 0;\n\t}\n\n\treturn -EBUSY;\n}\n\n \n\n \nstatic int hermesi_program_init(struct hermes *hw, u32 offset)\n{\n\tint err;\n\n\t \n\t \n\t \n\t \n\n\t \n\thermes_write_regn(hw, EVACK, 0xFFFF);\n\n\t \n\terr = hw->ops->init_cmd_wait(hw,\n\t\t\t\t     0x0100 | HERMES_CMD_INIT,\n\t\t\t\t     0, 0, 0, NULL);\n\tif (err)\n\t\treturn err;\n\n\terr = hw->ops->init_cmd_wait(hw,\n\t\t\t\t     0x0000 | HERMES_CMD_INIT,\n\t\t\t\t     0, 0, 0, NULL);\n\tif (err)\n\t\treturn err;\n\n\terr = hermes_aux_control(hw, 1);\n\tpr_debug(\"AUX enable returned %d\\n\", err);\n\n\tif (err)\n\t\treturn err;\n\n\tpr_debug(\"Enabling volatile, EP 0x%08x\\n\", offset);\n\terr = hw->ops->init_cmd_wait(hw,\n\t\t\t\t     HERMES_PROGRAM_ENABLE_VOLATILE,\n\t\t\t\t     offset & 0xFFFFu,\n\t\t\t\t     offset >> 16,\n\t\t\t\t     0,\n\t\t\t\t     NULL);\n\tpr_debug(\"PROGRAM_ENABLE returned %d\\n\", err);\n\n\treturn err;\n}\n\n \nstatic int hermesi_program_end(struct hermes *hw)\n{\n\tstruct hermes_response resp;\n\tint rc = 0;\n\tint err;\n\n\trc = hw->ops->cmd_wait(hw, HERMES_PROGRAM_DISABLE, 0, &resp);\n\n\tpr_debug(\"PROGRAM_DISABLE returned %d, \"\n\t\t \"r0 0x%04x, r1 0x%04x, r2 0x%04x\\n\",\n\t\t rc, resp.resp0, resp.resp1, resp.resp2);\n\n\tif ((rc == 0) &&\n\t    ((resp.status & HERMES_STATUS_CMDCODE) != HERMES_CMD_DOWNLD))\n\t\trc = -EIO;\n\n\terr = hermes_aux_control(hw, 0);\n\tpr_debug(\"AUX disable returned %d\\n\", err);\n\n\t \n\thermes_write_regn(hw, EVACK, 0xFFFF);\n\n\t \n\t(void) hw->ops->init_cmd_wait(hw, 0x0000 | HERMES_CMD_INIT,\n\t\t\t\t      0, 0, 0, NULL);\n\n\treturn rc ? rc : err;\n}\n\nstatic int hermes_program_bytes(struct hermes *hw, const char *data,\n\t\t\t\tu32 addr, u32 len)\n{\n\t \n\thermes_aux_setaddr(hw, addr);\n\thermes_write_bytes(hw, HERMES_AUXDATA, data, len);\n\treturn 0;\n}\n\n \nstatic int hermes_read_pda(struct hermes *hw, __le16 *pda, u32 pda_addr,\n\t\t\t   u16 pda_len)\n{\n\tint ret;\n\tu16 pda_size;\n\tu16 data_len = pda_len;\n\t__le16 *data = pda;\n\n\tif (hw->eeprom_pda) {\n\t\t \n\n\t\t \n\t\tret = hw->ops->cmd_wait(hw, HERMES_CMD_READMIF, 0, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\t \n\t\tpda[0] = cpu_to_le16(pda_len - 2);\n\t\t\t \n\t\tpda[1] = cpu_to_le16(0x0800);  \n\t\tdata_len = pda_len - 4;\n\t\tdata = pda + 2;\n\t}\n\n\t \n\tret = hermes_aux_control(hw, 1);\n\tpr_debug(\"AUX enable returned %d\\n\", ret);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\thermes_aux_setaddr(hw, pda_addr);\n\thermes_read_words(hw, HERMES_AUXDATA, data, data_len / 2);\n\n\t \n\tret = hermes_aux_control(hw, 0);\n\tpr_debug(\"AUX disable returned %d\\n\", ret);\n\n\t \n\tpda_size = le16_to_cpu(pda[0]);\n\tpr_debug(\"Actual PDA length %d, Max allowed %d\\n\",\n\t\t pda_size, pda_len);\n\tif (pda_size > pda_len)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void hermes_lock_irqsave(spinlock_t *lock,\n\t\t\t\tunsigned long *flags) __acquires(lock)\n{\n\tspin_lock_irqsave(lock, *flags);\n}\n\nstatic void hermes_unlock_irqrestore(spinlock_t *lock,\n\t\t\t\t     unsigned long *flags) __releases(lock)\n{\n\tspin_unlock_irqrestore(lock, *flags);\n}\n\nstatic void hermes_lock_irq(spinlock_t *lock) __acquires(lock)\n{\n\tspin_lock_irq(lock);\n}\n\nstatic void hermes_unlock_irq(spinlock_t *lock) __releases(lock)\n{\n\tspin_unlock_irq(lock);\n}\n\n \nstatic const struct hermes_ops hermes_ops_local = {\n\t.init = hermes_init,\n\t.cmd_wait = hermes_docmd_wait,\n\t.init_cmd_wait = hermes_doicmd_wait,\n\t.allocate = hermes_allocate,\n\t.read_ltv = hermes_read_ltv,\n\t.read_ltv_pr = hermes_read_ltv,\n\t.write_ltv = hermes_write_ltv,\n\t.bap_pread = hermes_bap_pread,\n\t.bap_pwrite = hermes_bap_pwrite,\n\t.read_pda = hermes_read_pda,\n\t.program_init = hermesi_program_init,\n\t.program_end = hermesi_program_end,\n\t.program = hermes_program_bytes,\n\t.lock_irqsave = hermes_lock_irqsave,\n\t.unlock_irqrestore = hermes_unlock_irqrestore,\n\t.lock_irq = hermes_lock_irq,\n\t.unlock_irq = hermes_unlock_irq,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}