{
  "module_name": "main.c",
  "hash_id": "3b82971943f39c2d27b6d96e0d6d75273a9308d1831ffc03649f1f95531fe4d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/orinoco/main.c",
  "human_readable_source": " \n\n \n\n \n\n#define DRIVER_NAME \"orinoco\"\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/suspend.h>\n#include <linux/if_arp.h>\n#include <linux/wireless.h>\n#include <linux/ieee80211.h>\n#include <net/iw_handler.h>\n#include <net/cfg80211.h>\n\n#include \"hermes_rid.h\"\n#include \"hermes_dld.h\"\n#include \"hw.h\"\n#include \"scan.h\"\n#include \"mic.h\"\n#include \"fw.h\"\n#include \"wext.h\"\n#include \"cfg.h\"\n#include \"main.h\"\n\n#include \"orinoco.h\"\n\n \n \n \n\nMODULE_AUTHOR(\"Pavel Roskin <proski@gnu.org> & \"\n\t      \"David Gibson <hermes@gibson.dropbear.id.au>\");\nMODULE_DESCRIPTION(\"Driver for Lucent Orinoco, Prism II based \"\n\t\t   \"and similar wireless cards\");\nMODULE_LICENSE(\"Dual MPL/GPL\");\n\n \n#ifdef ORINOCO_DEBUG\nint orinoco_debug = ORINOCO_DEBUG;\nEXPORT_SYMBOL(orinoco_debug);\nmodule_param(orinoco_debug, int, 0644);\nMODULE_PARM_DESC(orinoco_debug, \"Debug level\");\n#endif\n\nstatic bool suppress_linkstatus;  \nmodule_param(suppress_linkstatus, bool, 0644);\nMODULE_PARM_DESC(suppress_linkstatus, \"Don't log link status changes\");\n\nstatic int ignore_disconnect;  \nmodule_param(ignore_disconnect, int, 0644);\nMODULE_PARM_DESC(ignore_disconnect,\n\t\t \"Don't report lost link to the network layer\");\n\nint force_monitor;  \nmodule_param(force_monitor, int, 0644);\nMODULE_PARM_DESC(force_monitor, \"Allow monitor mode for all firmware versions\");\n\n \n \n \n\n \nstatic const u8 encaps_hdr[] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00};\n#define ENCAPS_OVERHEAD\t\t(sizeof(encaps_hdr) + 2)\n\n#define ORINOCO_MIN_MTU\t\t256\n#define ORINOCO_MAX_MTU\t\t(IEEE80211_MAX_DATA_LEN - ENCAPS_OVERHEAD)\n\n#define MAX_IRQLOOPS_PER_IRQ\t10\n#define MAX_IRQLOOPS_PER_JIFFY\t(20000 / HZ)\t \n\n#define DUMMY_FID\t\t0xFFFF\n\n \n#define MAX_MULTICAST(priv)\t(HERMES_MAX_MULTICAST)\n\n#define ORINOCO_INTEN\t\t(HERMES_EV_RX | HERMES_EV_ALLOC \\\n\t\t\t\t | HERMES_EV_TX | HERMES_EV_TXEXC \\\n\t\t\t\t | HERMES_EV_WTERR | HERMES_EV_INFO \\\n\t\t\t\t | HERMES_EV_INFDROP)\n\n \n \n \n\n \nstruct hermes_txexc_data {\n\tstruct hermes_tx_descriptor desc;\n\t__le16 frame_ctl;\n\t__le16 duration_id;\n\tu8 addr1[ETH_ALEN];\n} __packed;\n\n \nstruct hermes_rx_descriptor {\n\t \n\t__le16 status;\n\t__le32 time;\n\tu8 silence;\n\tu8 signal;\n\tu8 rate;\n\tu8 rxflow;\n\t__le32 reserved;\n\n\t \n\t__le16 frame_ctl;\n\t__le16 duration_id;\n\tu8 addr1[ETH_ALEN];\n\tu8 addr2[ETH_ALEN];\n\tu8 addr3[ETH_ALEN];\n\t__le16 seq_ctl;\n\tu8 addr4[ETH_ALEN];\n\n\t \n\t__le16 data_len;\n} __packed;\n\nstruct orinoco_rx_data {\n\tstruct hermes_rx_descriptor *desc;\n\tstruct sk_buff *skb;\n\tstruct list_head list;\n};\n\nstruct orinoco_scan_data {\n\tvoid *buf;\n\tsize_t len;\n\tint type;\n\tstruct list_head list;\n};\n\n \n \n \n\nstatic int __orinoco_set_multicast_list(struct net_device *dev);\nstatic int __orinoco_up(struct orinoco_private *priv);\nstatic int __orinoco_down(struct orinoco_private *priv);\nstatic int __orinoco_commit(struct orinoco_private *priv);\n\n \n \n \n\nvoid set_port_type(struct orinoco_private *priv)\n{\n\tswitch (priv->iw_mode) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tpriv->port_type = 1;\n\t\tpriv->createibss = 0;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (priv->prefer_port3) {\n\t\t\tpriv->port_type = 3;\n\t\t\tpriv->createibss = 0;\n\t\t} else {\n\t\t\tpriv->port_type = priv->ibss_port;\n\t\t\tpriv->createibss = 1;\n\t\t}\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tpriv->port_type = 3;\n\t\tpriv->createibss = 0;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"%s: Invalid priv->iw_mode in set_port_type()\\n\",\n\t\t       priv->ndev->name);\n\t}\n}\n\n \n \n \n\nint orinoco_open(struct net_device *dev)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tunsigned long flags;\n\tint err;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\terr = __orinoco_up(priv);\n\n\tif (!err)\n\t\tpriv->open = 1;\n\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\nEXPORT_SYMBOL(orinoco_open);\n\nint orinoco_stop(struct net_device *dev)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint err = 0;\n\n\t \n\torinoco_lock_irq(priv);\n\n\tpriv->open = 0;\n\n\terr = __orinoco_down(priv);\n\n\torinoco_unlock_irq(priv);\n\n\treturn err;\n}\nEXPORT_SYMBOL(orinoco_stop);\n\nvoid orinoco_set_multicast_list(struct net_device *dev)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tunsigned long flags;\n\n\tif (orinoco_lock(priv, &flags) != 0) {\n\t\tprintk(KERN_DEBUG \"%s: orinoco_set_multicast_list() \"\n\t\t       \"called when hw_unavailable\\n\", dev->name);\n\t\treturn;\n\t}\n\n\t__orinoco_set_multicast_list(dev);\n\torinoco_unlock(priv, &flags);\n}\nEXPORT_SYMBOL(orinoco_set_multicast_list);\n\nint orinoco_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\n\t \n\tif ((new_mtu + ENCAPS_OVERHEAD + sizeof(struct ieee80211_hdr)) >\n\t     (priv->nicbuf_size - ETH_HLEN))\n\t\treturn -EINVAL;\n\n\tdev->mtu = new_mtu;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(orinoco_change_mtu);\n\n \n \n \n\n \nint orinoco_process_xmit_skb(struct sk_buff *skb,\n\t\t\t     struct net_device *dev,\n\t\t\t     struct orinoco_private *priv,\n\t\t\t     int *tx_control,\n\t\t\t     u8 *mic_buf)\n{\n\tstruct orinoco_tkip_key *key;\n\tstruct ethhdr *eh;\n\tint do_mic;\n\n\tkey = (struct orinoco_tkip_key *) priv->keys[priv->tx_key].key;\n\n\tdo_mic = ((priv->encode_alg == ORINOCO_ALG_TKIP) &&\n\t\t  (key != NULL));\n\n\tif (do_mic)\n\t\t*tx_control |= (priv->tx_key << HERMES_MIC_KEY_ID_SHIFT) |\n\t\t\tHERMES_TXCTRL_MIC;\n\n\teh = (struct ethhdr *)skb->data;\n\n\t \n\tif (ntohs(eh->h_proto) > ETH_DATA_LEN) {  \n\t\tstruct header_struct {\n\t\t\tstruct ethhdr eth;\t \n\t\t\tu8 encap[6];\t\t \n\t\t} __packed hdr;\n\t\tint len = skb->len + sizeof(encaps_hdr) - (2 * ETH_ALEN);\n\n\t\tif (skb_headroom(skb) < ENCAPS_OVERHEAD) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"%s: Not enough headroom for 802.2 headers %d\\n\",\n\t\t\t\t       dev->name, skb_headroom(skb));\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t \n\t\tmemcpy(&hdr.eth, eh, 2 * ETH_ALEN);\n\t\thdr.eth.h_proto = htons(len);\n\t\tmemcpy(hdr.encap, encaps_hdr, sizeof(encaps_hdr));\n\n\t\t \n\t\teh = skb_push(skb, ENCAPS_OVERHEAD);\n\t\tmemcpy(eh, &hdr, sizeof(hdr));\n\t}\n\n\t \n\tif (do_mic) {\n\t\tsize_t len = skb->len - ETH_HLEN;\n\t\tu8 *mic = &mic_buf[0];\n\n\t\t \n\t\tif (skb->len % 2) {\n\t\t\t*mic = skb->data[skb->len - 1];\n\t\t\tmic++;\n\t\t}\n\n\t\torinoco_mic(priv->tx_tfm_mic, key->tx_mic,\n\t\t\t    eh->h_dest, eh->h_source, 0  ,\n\t\t\t    skb->data + ETH_HLEN,\n\t\t\t    len, mic);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(orinoco_process_xmit_skb);\n\nstatic netdev_tx_t orinoco_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct hermes *hw = &priv->hw;\n\tint err = 0;\n\tu16 txfid = priv->txfid;\n\tint tx_control;\n\tunsigned long flags;\n\tu8 mic_buf[MICHAEL_MIC_LEN + 1];\n\n\tif (!netif_running(dev)) {\n\t\tprintk(KERN_ERR \"%s: Tx on stopped device!\\n\",\n\t\t       dev->name);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tif (netif_queue_stopped(dev)) {\n\t\tprintk(KERN_DEBUG \"%s: Tx while transmitter busy!\\n\",\n\t\t       dev->name);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tif (orinoco_lock(priv, &flags) != 0) {\n\t\tprintk(KERN_ERR \"%s: orinoco_xmit() called while hw_unavailable\\n\",\n\t\t       dev->name);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tif (!netif_carrier_ok(dev) ||\n\t    (priv->iw_mode == NL80211_IFTYPE_MONITOR)) {\n\t\t \n\t\tgoto drop;\n\t}\n\n\t \n\tif (skb->len < ETH_HLEN)\n\t\tgoto drop;\n\n\ttx_control = HERMES_TXCTRL_TX_OK | HERMES_TXCTRL_TX_EX;\n\n\terr = orinoco_process_xmit_skb(skb, dev, priv, &tx_control,\n\t\t\t\t       &mic_buf[0]);\n\tif (err)\n\t\tgoto drop;\n\n\tif (priv->has_alt_txcntl) {\n\t\t \n\t\tchar desc[HERMES_802_3_OFFSET];\n\t\t__le16 *txcntl = (__le16 *) &desc[HERMES_TXCNTL2_OFFSET];\n\n\t\tmemset(&desc, 0, sizeof(desc));\n\n\t\t*txcntl = cpu_to_le16(tx_control);\n\t\terr = hw->ops->bap_pwrite(hw, USER_BAP, &desc, sizeof(desc),\n\t\t\t\t\t  txfid, 0);\n\t\tif (err) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tprintk(KERN_ERR \"%s: Error %d writing Tx \"\n\t\t\t\t       \"descriptor to BAP\\n\", dev->name, err);\n\t\t\tgoto busy;\n\t\t}\n\t} else {\n\t\tstruct hermes_tx_descriptor desc;\n\n\t\tmemset(&desc, 0, sizeof(desc));\n\n\t\tdesc.tx_control = cpu_to_le16(tx_control);\n\t\terr = hw->ops->bap_pwrite(hw, USER_BAP, &desc, sizeof(desc),\n\t\t\t\t\t  txfid, 0);\n\t\tif (err) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tprintk(KERN_ERR \"%s: Error %d writing Tx \"\n\t\t\t\t       \"descriptor to BAP\\n\", dev->name, err);\n\t\t\tgoto busy;\n\t\t}\n\n\t\t \n\t\thermes_clear_words(hw, HERMES_DATA0,\n\t\t\t\t   HERMES_802_3_OFFSET - HERMES_802_11_OFFSET);\n\t}\n\n\terr = hw->ops->bap_pwrite(hw, USER_BAP, skb->data, skb->len,\n\t\t\t\t  txfid, HERMES_802_3_OFFSET);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Error %d writing packet to BAP\\n\",\n\t\t       dev->name, err);\n\t\tgoto busy;\n\t}\n\n\tif (tx_control & HERMES_TXCTRL_MIC) {\n\t\tsize_t offset = HERMES_802_3_OFFSET + skb->len;\n\t\tsize_t len = MICHAEL_MIC_LEN;\n\n\t\tif (offset % 2) {\n\t\t\toffset--;\n\t\t\tlen++;\n\t\t}\n\t\terr = hw->ops->bap_pwrite(hw, USER_BAP, &mic_buf[0], len,\n\t\t\t\t\t  txfid, offset);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"%s: Error %d writing MIC to BAP\\n\",\n\t\t\t       dev->name, err);\n\t\t\tgoto busy;\n\t\t}\n\t}\n\n\t \n\tnetif_stop_queue(dev);\n\n\terr = hw->ops->cmd_wait(hw, HERMES_CMD_TX | HERMES_CMD_RECL,\n\t\t\t\ttxfid, NULL);\n\tif (err) {\n\t\tnetif_start_queue(dev);\n\t\tif (net_ratelimit())\n\t\t\tprintk(KERN_ERR \"%s: Error %d transmitting packet\\n\",\n\t\t\t\tdev->name, err);\n\t\tgoto busy;\n\t}\n\n\tstats->tx_bytes += HERMES_802_3_OFFSET + skb->len;\n\tgoto ok;\n\n drop:\n\tstats->tx_errors++;\n\tstats->tx_dropped++;\n\n ok:\n\torinoco_unlock(priv, &flags);\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n\n busy:\n\tif (err == -EIO)\n\t\tschedule_work(&priv->reset_work);\n\torinoco_unlock(priv, &flags);\n\treturn NETDEV_TX_BUSY;\n}\n\nstatic void __orinoco_ev_alloc(struct net_device *dev, struct hermes *hw)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tu16 fid = hermes_read_regn(hw, ALLOCFID);\n\n\tif (fid != priv->txfid) {\n\t\tif (fid != DUMMY_FID)\n\t\t\tprintk(KERN_WARNING \"%s: Allocate event on unexpected fid (%04X)\\n\",\n\t\t\t       dev->name, fid);\n\t\treturn;\n\t}\n\n\thermes_write_regn(hw, ALLOCFID, DUMMY_FID);\n}\n\nstatic void __orinoco_ev_tx(struct net_device *dev, struct hermes *hw)\n{\n\tdev->stats.tx_packets++;\n\n\tnetif_wake_queue(dev);\n\n\thermes_write_regn(hw, TXCOMPLFID, DUMMY_FID);\n}\n\nstatic void __orinoco_ev_txexc(struct net_device *dev, struct hermes *hw)\n{\n\tstruct net_device_stats *stats = &dev->stats;\n\tu16 fid = hermes_read_regn(hw, TXCOMPLFID);\n\tu16 status;\n\tstruct hermes_txexc_data hdr;\n\tint err = 0;\n\n\tif (fid == DUMMY_FID)\n\t\treturn;  \n\n\t \n\terr = hw->ops->bap_pread(hw, IRQ_BAP, &hdr,\n\t\t\t\t sizeof(struct hermes_txexc_data),\n\t\t\t\t fid, 0);\n\n\thermes_write_regn(hw, TXCOMPLFID, DUMMY_FID);\n\tstats->tx_errors++;\n\n\tif (err) {\n\t\tprintk(KERN_WARNING \"%s: Unable to read descriptor on Tx error \"\n\t\t       \"(FID=%04X error %d)\\n\",\n\t\t       dev->name, fid, err);\n\t\treturn;\n\t}\n\n\tDEBUG(1, \"%s: Tx error, err %d (FID=%04X)\\n\", dev->name,\n\t      err, fid);\n\n\t \n\tstatus = le16_to_cpu(hdr.desc.status);\n\tif (status & (HERMES_TXSTAT_RETRYERR | HERMES_TXSTAT_AGEDERR)) {\n\t\tunion iwreq_data\twrqu;\n\n\t\t \n\t\tmemcpy(wrqu.addr.sa_data, hdr.addr1, ETH_ALEN);\n\t\twrqu.addr.sa_family = ARPHRD_ETHER;\n\n\t\t \n\t\twireless_send_event(dev, IWEVTXDROP, &wrqu, NULL);\n\t}\n\n\tnetif_wake_queue(dev);\n}\n\nvoid orinoco_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct hermes *hw = &priv->hw;\n\n\tprintk(KERN_WARNING \"%s: Tx timeout! \"\n\t       \"ALLOCFID=%04x, TXCOMPLFID=%04x, EVSTAT=%04x\\n\",\n\t       dev->name, hermes_read_regn(hw, ALLOCFID),\n\t       hermes_read_regn(hw, TXCOMPLFID), hermes_read_regn(hw, EVSTAT));\n\n\tstats->tx_errors++;\n\n\tschedule_work(&priv->reset_work);\n}\nEXPORT_SYMBOL(orinoco_tx_timeout);\n\n \n \n \n\n \nstatic inline int is_ethersnap(void *_hdr)\n{\n\tu8 *hdr = _hdr;\n\n\t \n\treturn (memcmp(hdr, &encaps_hdr, 5) == 0)\n\t\t&& ((hdr[5] == 0x00) || (hdr[5] == 0xf8));\n}\n\nstatic inline void orinoco_spy_gather(struct net_device *dev, u_char *mac,\n\t\t\t\t      int level, int noise)\n{\n\tstruct iw_quality wstats;\n\twstats.level = level - 0x95;\n\twstats.noise = noise - 0x95;\n\twstats.qual = (level > noise) ? (level - noise) : 0;\n\twstats.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;\n\t \n\twireless_spy_update(dev, mac, &wstats);\n}\n\nstatic void orinoco_stat_gather(struct net_device *dev,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct hermes_rx_descriptor *desc)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\n\t \n\t \n\tif (SPY_NUMBER(priv)) {\n\t\torinoco_spy_gather(dev, skb_mac_header(skb) + ETH_ALEN,\n\t\t\t\t   desc->signal, desc->silence);\n\t}\n}\n\n \nstatic void orinoco_rx_monitor(struct net_device *dev, u16 rxfid,\n\t\t\t       struct hermes_rx_descriptor *desc)\n{\n\tu32 hdrlen = 30;\t \n\tu32 datalen = 0;\n\tu16 fc;\n\tint err;\n\tint len;\n\tstruct sk_buff *skb;\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct hermes *hw = &priv->hw;\n\n\tlen = le16_to_cpu(desc->data_len);\n\n\t \n\tfc = le16_to_cpu(desc->frame_ctl);\n\tswitch (fc & IEEE80211_FCTL_FTYPE) {\n\tcase IEEE80211_FTYPE_DATA:\n\t\tif ((fc & IEEE80211_FCTL_TODS)\n\t\t    && (fc & IEEE80211_FCTL_FROMDS))\n\t\t\thdrlen = 30;\n\t\telse\n\t\t\thdrlen = 24;\n\t\tdatalen = len;\n\t\tbreak;\n\tcase IEEE80211_FTYPE_MGMT:\n\t\thdrlen = 24;\n\t\tdatalen = len;\n\t\tbreak;\n\tcase IEEE80211_FTYPE_CTL:\n\t\tswitch (fc & IEEE80211_FCTL_STYPE) {\n\t\tcase IEEE80211_STYPE_PSPOLL:\n\t\tcase IEEE80211_STYPE_RTS:\n\t\tcase IEEE80211_STYPE_CFEND:\n\t\tcase IEEE80211_STYPE_CFENDACK:\n\t\t\thdrlen = 16;\n\t\t\tbreak;\n\t\tcase IEEE80211_STYPE_CTS:\n\t\tcase IEEE80211_STYPE_ACK:\n\t\t\thdrlen = 10;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\t \n\tif (datalen > IEEE80211_MAX_DATA_LEN + 12) {\n\t\tprintk(KERN_DEBUG \"%s: oversized monitor frame, \"\n\t\t       \"data length = %d\\n\", dev->name, datalen);\n\t\tstats->rx_length_errors++;\n\t\tgoto update_stats;\n\t}\n\n\tskb = dev_alloc_skb(hdrlen + datalen);\n\tif (!skb) {\n\t\tprintk(KERN_WARNING \"%s: Cannot allocate skb for monitor frame\\n\",\n\t\t       dev->name);\n\t\tgoto update_stats;\n\t}\n\n\t \n\tskb_put_data(skb, &(desc->frame_ctl), hdrlen);\n\tskb_reset_mac_header(skb);\n\n\t \n\tif (datalen > 0) {\n\t\terr = hw->ops->bap_pread(hw, IRQ_BAP, skb_put(skb, datalen),\n\t\t\t\t\t ALIGN(datalen, 2), rxfid,\n\t\t\t\t\t HERMES_802_2_OFFSET);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"%s: error %d reading monitor frame\\n\",\n\t\t\t       dev->name, err);\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tskb->dev = dev;\n\tskb->ip_summed = CHECKSUM_NONE;\n\tskb->pkt_type = PACKET_OTHERHOST;\n\tskb->protocol = cpu_to_be16(ETH_P_802_2);\n\n\tstats->rx_packets++;\n\tstats->rx_bytes += skb->len;\n\n\tnetif_rx(skb);\n\treturn;\n\n drop:\n\tdev_kfree_skb_irq(skb);\n update_stats:\n\tstats->rx_errors++;\n\tstats->rx_dropped++;\n}\n\nvoid __orinoco_ev_rx(struct net_device *dev, struct hermes *hw)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct iw_statistics *wstats = &priv->wstats;\n\tstruct sk_buff *skb = NULL;\n\tu16 rxfid, status;\n\tint length;\n\tstruct hermes_rx_descriptor *desc;\n\tstruct orinoco_rx_data *rx_data;\n\tint err;\n\n\tdesc = kmalloc(sizeof(*desc), GFP_ATOMIC);\n\tif (!desc)\n\t\tgoto update_stats;\n\n\trxfid = hermes_read_regn(hw, RXFID);\n\n\terr = hw->ops->bap_pread(hw, IRQ_BAP, desc, sizeof(*desc),\n\t\t\t\t rxfid, 0);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: error %d reading Rx descriptor. \"\n\t\t       \"Frame dropped.\\n\", dev->name, err);\n\t\tgoto update_stats;\n\t}\n\n\tstatus = le16_to_cpu(desc->status);\n\n\tif (status & HERMES_RXSTAT_BADCRC) {\n\t\tDEBUG(1, \"%s: Bad CRC on Rx. Frame dropped.\\n\",\n\t\t      dev->name);\n\t\tstats->rx_crc_errors++;\n\t\tgoto update_stats;\n\t}\n\n\t \n\tif (priv->iw_mode == NL80211_IFTYPE_MONITOR) {\n\t\torinoco_rx_monitor(dev, rxfid, desc);\n\t\tgoto out;\n\t}\n\n\tif (status & HERMES_RXSTAT_UNDECRYPTABLE) {\n\t\tDEBUG(1, \"%s: Undecryptable frame on Rx. Frame dropped.\\n\",\n\t\t      dev->name);\n\t\twstats->discard.code++;\n\t\tgoto update_stats;\n\t}\n\n\tlength = le16_to_cpu(desc->data_len);\n\n\t \n\tif (length < 3) {  \n\t\t \n\t\tgoto out;\n\t}\n\tif (length > IEEE80211_MAX_DATA_LEN) {\n\t\tprintk(KERN_WARNING \"%s: Oversized frame received (%d bytes)\\n\",\n\t\t       dev->name, length);\n\t\tstats->rx_length_errors++;\n\t\tgoto update_stats;\n\t}\n\n\t \n\tif (status & HERMES_RXSTAT_MIC)\n\t\tlength += MICHAEL_MIC_LEN;\n\n\t \n\tskb = dev_alloc_skb(length + ETH_HLEN + 2 + 1);\n\tif (!skb) {\n\t\tprintk(KERN_WARNING \"%s: Can't allocate skb for Rx\\n\",\n\t\t       dev->name);\n\t\tgoto update_stats;\n\t}\n\n\t \n\tskb_reserve(skb, ETH_HLEN + 2);\n\n\terr = hw->ops->bap_pread(hw, IRQ_BAP, skb_put(skb, length),\n\t\t\t\t ALIGN(length, 2), rxfid,\n\t\t\t\t HERMES_802_2_OFFSET);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: error %d reading frame. \"\n\t\t       \"Frame dropped.\\n\", dev->name, err);\n\t\tgoto drop;\n\t}\n\n\t \n\trx_data = kzalloc(sizeof(*rx_data), GFP_ATOMIC);\n\tif (!rx_data)\n\t\tgoto drop;\n\n\trx_data->desc = desc;\n\trx_data->skb = skb;\n\tlist_add_tail(&rx_data->list, &priv->rx_list);\n\ttasklet_schedule(&priv->rx_tasklet);\n\n\treturn;\n\ndrop:\n\tdev_kfree_skb_irq(skb);\nupdate_stats:\n\tstats->rx_errors++;\n\tstats->rx_dropped++;\nout:\n\tkfree(desc);\n}\nEXPORT_SYMBOL(__orinoco_ev_rx);\n\nstatic void orinoco_rx(struct net_device *dev,\n\t\t       struct hermes_rx_descriptor *desc,\n\t\t       struct sk_buff *skb)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tu16 status, fc;\n\tint length;\n\tstruct ethhdr *hdr;\n\n\tstatus = le16_to_cpu(desc->status);\n\tlength = le16_to_cpu(desc->data_len);\n\tfc = le16_to_cpu(desc->frame_ctl);\n\n\t \n\tif (status & HERMES_RXSTAT_MIC) {\n\t\tstruct orinoco_tkip_key *key;\n\t\tint key_id = ((status & HERMES_RXSTAT_MIC_KEY_ID) >>\n\t\t\t      HERMES_MIC_KEY_ID_SHIFT);\n\t\tu8 mic[MICHAEL_MIC_LEN];\n\t\tu8 *rxmic;\n\t\tu8 *src = (fc & IEEE80211_FCTL_FROMDS) ?\n\t\t\tdesc->addr3 : desc->addr2;\n\n\t\t \n\t\trxmic = skb->data + skb->len - MICHAEL_MIC_LEN;\n\n\t\tskb_trim(skb, skb->len - MICHAEL_MIC_LEN);\n\t\tlength -= MICHAEL_MIC_LEN;\n\n\t\tkey = (struct orinoco_tkip_key *) priv->keys[key_id].key;\n\n\t\tif (!key) {\n\t\t\tprintk(KERN_WARNING \"%s: Received encrypted frame from \"\n\t\t\t       \"%pM using key %i, but key is not installed\\n\",\n\t\t\t       dev->name, src, key_id);\n\t\t\tgoto drop;\n\t\t}\n\n\t\torinoco_mic(priv->rx_tfm_mic, key->rx_mic, desc->addr1, src,\n\t\t\t    0,  \n\t\t\t    skb->data, skb->len, &mic[0]);\n\n\t\tif (memcmp(mic, rxmic,\n\t\t\t   MICHAEL_MIC_LEN)) {\n\t\t\tunion iwreq_data wrqu;\n\t\t\tstruct iw_michaelmicfailure wxmic;\n\n\t\t\tprintk(KERN_WARNING \"%s: \"\n\t\t\t       \"Invalid Michael MIC in data frame from %pM, \"\n\t\t\t       \"using key %i\\n\",\n\t\t\t       dev->name, src, key_id);\n\n\t\t\t \n\n\t\t\t \n\t\t\tmemset(&wxmic, 0, sizeof(wxmic));\n\t\t\twxmic.flags = key_id & IW_MICFAILURE_KEY_ID;\n\t\t\twxmic.flags |= (desc->addr1[0] & 1) ?\n\t\t\t\tIW_MICFAILURE_GROUP : IW_MICFAILURE_PAIRWISE;\n\t\t\twxmic.src_addr.sa_family = ARPHRD_ETHER;\n\t\t\tmemcpy(wxmic.src_addr.sa_data, src, ETH_ALEN);\n\n\t\t\t(void) orinoco_hw_get_tkip_iv(priv, key_id,\n\t\t\t\t\t\t      &wxmic.tsc[0]);\n\n\t\t\tmemset(&wrqu, 0, sizeof(wrqu));\n\t\t\twrqu.data.length = sizeof(wxmic);\n\t\t\twireless_send_event(dev, IWEVMICHAELMICFAILURE, &wrqu,\n\t\t\t\t\t    (char *) &wxmic);\n\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\t \n\tif (length >= ENCAPS_OVERHEAD &&\n\t    (((status & HERMES_RXSTAT_MSGTYPE) == HERMES_RXSTAT_1042) ||\n\t     ((status & HERMES_RXSTAT_MSGTYPE) == HERMES_RXSTAT_TUNNEL) ||\n\t     is_ethersnap(skb->data))) {\n\t\t \n\t\thdr = skb_push(skb, ETH_HLEN - ENCAPS_OVERHEAD);\n\t} else {\n\t\t \n\t\thdr = skb_push(skb, ETH_HLEN);\n\t\thdr->h_proto = htons(length);\n\t}\n\tmemcpy(hdr->h_dest, desc->addr1, ETH_ALEN);\n\tif (fc & IEEE80211_FCTL_FROMDS)\n\t\tmemcpy(hdr->h_source, desc->addr3, ETH_ALEN);\n\telse\n\t\tmemcpy(hdr->h_source, desc->addr2, ETH_ALEN);\n\n\tskb->protocol = eth_type_trans(skb, dev);\n\tskb->ip_summed = CHECKSUM_NONE;\n\tif (fc & IEEE80211_FCTL_TODS)\n\t\tskb->pkt_type = PACKET_OTHERHOST;\n\n\t \n\torinoco_stat_gather(dev, skb, desc);\n\n\t \n\tnetif_rx(skb);\n\tstats->rx_packets++;\n\tstats->rx_bytes += length;\n\n\treturn;\n\n drop:\n\tdev_kfree_skb(skb);\n\tstats->rx_errors++;\n\tstats->rx_dropped++;\n}\n\nstatic void orinoco_rx_isr_tasklet(struct tasklet_struct *t)\n{\n\tstruct orinoco_private *priv = from_tasklet(priv, t, rx_tasklet);\n\tstruct net_device *dev = priv->ndev;\n\tstruct orinoco_rx_data *rx_data, *temp;\n\tstruct hermes_rx_descriptor *desc;\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\n\t \n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn;\n\n\t \n\tlist_for_each_entry_safe(rx_data, temp, &priv->rx_list, list) {\n\t\tdesc = rx_data->desc;\n\t\tskb = rx_data->skb;\n\t\tlist_del(&rx_data->list);\n\t\tkfree(rx_data);\n\n\t\torinoco_rx(dev, desc, skb);\n\n\t\tkfree(desc);\n\t}\n\n\torinoco_unlock(priv, &flags);\n}\n\n \n \n \n\nstatic void print_linkstatus(struct net_device *dev, u16 status)\n{\n\tchar *s;\n\n\tif (suppress_linkstatus)\n\t\treturn;\n\n\tswitch (status) {\n\tcase HERMES_LINKSTATUS_NOT_CONNECTED:\n\t\ts = \"Not Connected\";\n\t\tbreak;\n\tcase HERMES_LINKSTATUS_CONNECTED:\n\t\ts = \"Connected\";\n\t\tbreak;\n\tcase HERMES_LINKSTATUS_DISCONNECTED:\n\t\ts = \"Disconnected\";\n\t\tbreak;\n\tcase HERMES_LINKSTATUS_AP_CHANGE:\n\t\ts = \"AP Changed\";\n\t\tbreak;\n\tcase HERMES_LINKSTATUS_AP_OUT_OF_RANGE:\n\t\ts = \"AP Out of Range\";\n\t\tbreak;\n\tcase HERMES_LINKSTATUS_AP_IN_RANGE:\n\t\ts = \"AP In Range\";\n\t\tbreak;\n\tcase HERMES_LINKSTATUS_ASSOC_FAILED:\n\t\ts = \"Association Failed\";\n\t\tbreak;\n\tdefault:\n\t\ts = \"UNKNOWN\";\n\t}\n\n\tprintk(KERN_DEBUG \"%s: New link status: %s (%04x)\\n\",\n\t       dev->name, s, status);\n}\n\n \nstatic void orinoco_join_ap(struct work_struct *work)\n{\n\tstruct orinoco_private *priv =\n\t\tcontainer_of(work, struct orinoco_private, join_work);\n\tstruct net_device *dev = priv->ndev;\n\tstruct hermes *hw = &priv->hw;\n\tint err;\n\tunsigned long flags;\n\tstruct join_req {\n\t\tu8 bssid[ETH_ALEN];\n\t\t__le16 channel;\n\t} __packed req;\n\tconst int atom_len = offsetof(struct prism2_scan_apinfo, atim);\n\tstruct prism2_scan_apinfo *atom = NULL;\n\tint offset = 4;\n\tint found = 0;\n\tu8 *buf;\n\tu16 len;\n\n\t \n\tbuf = kmalloc(MAX_SCAN_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\tgoto fail_lock;\n\n\t \n\tif (!priv->bssid_fixed)\n\t\tgoto out;\n\n\tif (strlen(priv->desired_essid) == 0)\n\t\tgoto out;\n\n\t \n\terr = hw->ops->read_ltv(hw, USER_BAP,\n\t\t\t\tHERMES_RID_SCANRESULTSTABLE,\n\t\t\t\tMAX_SCAN_LEN, &len, buf);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Cannot read scan results\\n\",\n\t\t       dev->name);\n\t\tgoto out;\n\t}\n\n\tlen = HERMES_RECLEN_TO_BYTES(len);\n\n\t \n\tfor (; offset + atom_len <= len; offset += atom_len) {\n\t\tatom = (struct prism2_scan_apinfo *) (buf + offset);\n\t\tif (memcmp(&atom->bssid, priv->desired_bssid, ETH_ALEN) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tDEBUG(1, \"%s: Requested AP not found in scan results\\n\",\n\t\t      dev->name);\n\t\tgoto out;\n\t}\n\n\tmemcpy(req.bssid, priv->desired_bssid, ETH_ALEN);\n\treq.channel = atom->channel;\t \n\terr = HERMES_WRITE_RECORD(hw, USER_BAP, HERMES_RID_CNFJOINREQUEST,\n\t\t\t\t  &req);\n\tif (err)\n\t\tprintk(KERN_ERR \"%s: Error issuing join request\\n\", dev->name);\n\n out:\n\torinoco_unlock(priv, &flags);\n\n fail_lock:\n\tkfree(buf);\n}\n\n \nstatic void orinoco_send_bssid_wevent(struct orinoco_private *priv)\n{\n\tstruct net_device *dev = priv->ndev;\n\tstruct hermes *hw = &priv->hw;\n\tunion iwreq_data wrqu;\n\tint err;\n\n\terr = hw->ops->read_ltv(hw, USER_BAP, HERMES_RID_CURRENTBSSID,\n\t\t\t\tETH_ALEN, NULL, wrqu.ap_addr.sa_data);\n\tif (err != 0)\n\t\treturn;\n\n\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\n\t \n\twireless_send_event(dev, SIOCGIWAP, &wrqu, NULL);\n}\n\nstatic void orinoco_send_assocreqie_wevent(struct orinoco_private *priv)\n{\n\tstruct net_device *dev = priv->ndev;\n\tstruct hermes *hw = &priv->hw;\n\tunion iwreq_data wrqu;\n\tint err;\n\tu8 buf[88];\n\tu8 *ie;\n\n\tif (!priv->has_wpa)\n\t\treturn;\n\n\terr = hw->ops->read_ltv(hw, USER_BAP, HERMES_RID_CURRENT_ASSOC_REQ_INFO,\n\t\t\t\tsizeof(buf), NULL, &buf);\n\tif (err != 0)\n\t\treturn;\n\n\tie = orinoco_get_wpa_ie(buf, sizeof(buf));\n\tif (ie) {\n\t\tint rem = sizeof(buf) - (ie - &buf[0]);\n\t\twrqu.data.length = ie[1] + 2;\n\t\tif (wrqu.data.length > rem)\n\t\t\twrqu.data.length = rem;\n\n\t\tif (wrqu.data.length)\n\t\t\t \n\t\t\twireless_send_event(dev, IWEVASSOCREQIE, &wrqu, ie);\n\t}\n}\n\nstatic void orinoco_send_assocrespie_wevent(struct orinoco_private *priv)\n{\n\tstruct net_device *dev = priv->ndev;\n\tstruct hermes *hw = &priv->hw;\n\tunion iwreq_data wrqu;\n\tint err;\n\tu8 buf[88];  \n\tu8 *ie;\n\n\tif (!priv->has_wpa)\n\t\treturn;\n\n\terr = hw->ops->read_ltv(hw, USER_BAP,\n\t\t\t\tHERMES_RID_CURRENT_ASSOC_RESP_INFO,\n\t\t\t\tsizeof(buf), NULL, &buf);\n\tif (err != 0)\n\t\treturn;\n\n\tie = orinoco_get_wpa_ie(buf, sizeof(buf));\n\tif (ie) {\n\t\tint rem = sizeof(buf) - (ie - &buf[0]);\n\t\twrqu.data.length = ie[1] + 2;\n\t\tif (wrqu.data.length > rem)\n\t\t\twrqu.data.length = rem;\n\n\t\tif (wrqu.data.length)\n\t\t\t \n\t\t\twireless_send_event(dev, IWEVASSOCRESPIE, &wrqu, ie);\n\t}\n}\n\nstatic void orinoco_send_wevents(struct work_struct *work)\n{\n\tstruct orinoco_private *priv =\n\t\tcontainer_of(work, struct orinoco_private, wevent_work);\n\tunsigned long flags;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn;\n\n\torinoco_send_assocreqie_wevent(priv);\n\torinoco_send_assocrespie_wevent(priv);\n\torinoco_send_bssid_wevent(priv);\n\n\torinoco_unlock(priv, &flags);\n}\n\nstatic void qbuf_scan(struct orinoco_private *priv, void *buf,\n\t\t      int len, int type)\n{\n\tstruct orinoco_scan_data *sd;\n\tunsigned long flags;\n\n\tsd = kmalloc(sizeof(*sd), GFP_ATOMIC);\n\tif (!sd)\n\t\treturn;\n\n\tsd->buf = buf;\n\tsd->len = len;\n\tsd->type = type;\n\n\tspin_lock_irqsave(&priv->scan_lock, flags);\n\tlist_add_tail(&sd->list, &priv->scan_list);\n\tspin_unlock_irqrestore(&priv->scan_lock, flags);\n\n\tschedule_work(&priv->process_scan);\n}\n\nstatic void qabort_scan(struct orinoco_private *priv)\n{\n\tstruct orinoco_scan_data *sd;\n\tunsigned long flags;\n\n\tsd = kmalloc(sizeof(*sd), GFP_ATOMIC);\n\tif (!sd)\n\t\treturn;\n\n\tsd->len = -1;  \n\n\tspin_lock_irqsave(&priv->scan_lock, flags);\n\tlist_add_tail(&sd->list, &priv->scan_list);\n\tspin_unlock_irqrestore(&priv->scan_lock, flags);\n\n\tschedule_work(&priv->process_scan);\n}\n\nstatic void orinoco_process_scan_results(struct work_struct *work)\n{\n\tstruct orinoco_private *priv =\n\t\tcontainer_of(work, struct orinoco_private, process_scan);\n\tstruct orinoco_scan_data *sd, *temp;\n\tunsigned long flags;\n\tvoid *buf;\n\tint len;\n\tint type;\n\n\tspin_lock_irqsave(&priv->scan_lock, flags);\n\tlist_for_each_entry_safe(sd, temp, &priv->scan_list, list) {\n\n\t\tbuf = sd->buf;\n\t\tlen = sd->len;\n\t\ttype = sd->type;\n\n\t\tlist_del(&sd->list);\n\t\tspin_unlock_irqrestore(&priv->scan_lock, flags);\n\t\tkfree(sd);\n\n\t\tif (len > 0) {\n\t\t\tif (type == HERMES_INQ_CHANNELINFO)\n\t\t\t\torinoco_add_extscan_result(priv, buf, len);\n\t\t\telse\n\t\t\t\torinoco_add_hostscan_results(priv, buf, len);\n\n\t\t\tkfree(buf);\n\t\t} else {\n\t\t\t \n\t\t\torinoco_scan_done(priv, (len < 0));\n\t\t}\n\n\t\tspin_lock_irqsave(&priv->scan_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&priv->scan_lock, flags);\n}\n\nvoid __orinoco_ev_info(struct net_device *dev, struct hermes *hw)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tu16 infofid;\n\tstruct {\n\t\t__le16 len;\n\t\t__le16 type;\n\t} __packed info;\n\tint len, type;\n\tint err;\n\n\t \n\tinfofid = hermes_read_regn(hw, INFOFID);\n\n\t \n\terr = hw->ops->bap_pread(hw, IRQ_BAP, &info, sizeof(info),\n\t\t\t\t infofid, 0);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: error %d reading info frame. \"\n\t\t       \"Frame dropped.\\n\", dev->name, err);\n\t\treturn;\n\t}\n\n\tlen = HERMES_RECLEN_TO_BYTES(le16_to_cpu(info.len));\n\ttype = le16_to_cpu(info.type);\n\n\tswitch (type) {\n\tcase HERMES_INQ_TALLIES: {\n\t\tstruct hermes_tallies_frame tallies;\n\t\tstruct iw_statistics *wstats = &priv->wstats;\n\n\t\tif (len > sizeof(tallies)) {\n\t\t\tprintk(KERN_WARNING \"%s: Tallies frame too long (%d bytes)\\n\",\n\t\t\t       dev->name, len);\n\t\t\tlen = sizeof(tallies);\n\t\t}\n\n\t\terr = hw->ops->bap_pread(hw, IRQ_BAP, &tallies, len,\n\t\t\t\t\t infofid, sizeof(info));\n\t\tif (err)\n\t\t\tbreak;\n\n\t\t \n\t\t \n\t\twstats->discard.code +=\n\t\t\tle16_to_cpu(tallies.RxWEPUndecryptable);\n\t\tif (len == sizeof(tallies))\n\t\t\twstats->discard.code +=\n\t\t\t\tle16_to_cpu(tallies.RxDiscards_WEPICVError) +\n\t\t\t\tle16_to_cpu(tallies.RxDiscards_WEPExcluded);\n\t\twstats->discard.misc +=\n\t\t\tle16_to_cpu(tallies.TxDiscardsWrongSA);\n\t\twstats->discard.fragment +=\n\t\t\tle16_to_cpu(tallies.RxMsgInBadMsgFragments);\n\t\twstats->discard.retries +=\n\t\t\tle16_to_cpu(tallies.TxRetryLimitExceeded);\n\t\t \n\t}\n\tbreak;\n\tcase HERMES_INQ_LINKSTATUS: {\n\t\tstruct hermes_linkstatus linkstatus;\n\t\tu16 newstatus;\n\t\tint connected;\n\n\t\tif (priv->iw_mode == NL80211_IFTYPE_MONITOR)\n\t\t\tbreak;\n\n\t\tif (len != sizeof(linkstatus)) {\n\t\t\tprintk(KERN_WARNING \"%s: Unexpected size for linkstatus frame (%d bytes)\\n\",\n\t\t\t       dev->name, len);\n\t\t\tbreak;\n\t\t}\n\n\t\terr = hw->ops->bap_pread(hw, IRQ_BAP, &linkstatus, len,\n\t\t\t\t\t infofid, sizeof(info));\n\t\tif (err)\n\t\t\tbreak;\n\t\tnewstatus = le16_to_cpu(linkstatus.linkstatus);\n\n\t\t \n\t\tif (newstatus == HERMES_LINKSTATUS_AP_OUT_OF_RANGE &&\n\t\t    priv->firmware_type == FIRMWARE_TYPE_SYMBOL &&\n\t\t    priv->has_hostscan && priv->scan_request) {\n\t\t\thermes_inquire(hw, HERMES_INQ_HOSTSCAN_SYMBOL);\n\t\t\tbreak;\n\t\t}\n\n\t\tconnected = (newstatus == HERMES_LINKSTATUS_CONNECTED)\n\t\t\t|| (newstatus == HERMES_LINKSTATUS_AP_CHANGE)\n\t\t\t|| (newstatus == HERMES_LINKSTATUS_AP_IN_RANGE);\n\n\t\tif (connected)\n\t\t\tnetif_carrier_on(dev);\n\t\telse if (!ignore_disconnect)\n\t\t\tnetif_carrier_off(dev);\n\n\t\tif (newstatus != priv->last_linkstatus) {\n\t\t\tpriv->last_linkstatus = newstatus;\n\t\t\tprint_linkstatus(dev, newstatus);\n\t\t\t \n\t\t\tschedule_work(&priv->wevent_work);\n\t\t}\n\t}\n\tbreak;\n\tcase HERMES_INQ_SCAN:\n\t\tif (!priv->scan_request && priv->bssid_fixed &&\n\t\t    priv->firmware_type == FIRMWARE_TYPE_INTERSIL) {\n\t\t\tschedule_work(&priv->join_work);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase HERMES_INQ_HOSTSCAN:\n\tcase HERMES_INQ_HOSTSCAN_SYMBOL: {\n\t\t \n\t\tunsigned char *buf;\n\n\t\t \n\t\tif (len > 4096) {\n\t\t\tprintk(KERN_WARNING \"%s: Scan results too large (%d bytes)\\n\",\n\t\t\t       dev->name, len);\n\t\t\tqabort_scan(priv);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tbuf = kmalloc(len, GFP_ATOMIC);\n\t\tif (buf == NULL) {\n\t\t\t \n\t\t\tqabort_scan(priv);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\terr = hw->ops->bap_pread(hw, IRQ_BAP, (void *) buf, len,\n\t\t\t\t\t infofid, sizeof(info));\n\t\tif (err) {\n\t\t\tkfree(buf);\n\t\t\tqabort_scan(priv);\n\t\t\tbreak;\n\t\t}\n\n#ifdef ORINOCO_DEBUG\n\t\t{\n\t\t\tint\ti;\n\t\t\tprintk(KERN_DEBUG \"Scan result [%02X\", buf[0]);\n\t\t\tfor (i = 1; i < (len * 2); i++)\n\t\t\t\tprintk(\":%02X\", buf[i]);\n\t\t\tprintk(\"]\\n\");\n\t\t}\n#endif\t \n\n\t\tqbuf_scan(priv, buf, len, type);\n\t}\n\tbreak;\n\tcase HERMES_INQ_CHANNELINFO:\n\t{\n\t\tstruct agere_ext_scan_info *bss;\n\n\t\tif (!priv->scan_request) {\n\t\t\tprintk(KERN_DEBUG \"%s: Got chaninfo without scan, \"\n\t\t\t       \"len=%d\\n\", dev->name, len);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (len == 0) {\n\t\t\tqbuf_scan(priv, NULL, len, type);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\telse if (len < (offsetof(struct agere_ext_scan_info,\n\t\t\t\t\t   data) + 2)) {\n\t\t\t \n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: Ext scan results too short (%d bytes)\\n\",\n\t\t\t       dev->name, len);\n\t\t\tbreak;\n\t\t}\n\n\t\tbss = kmalloc(len, GFP_ATOMIC);\n\t\tif (bss == NULL)\n\t\t\tbreak;\n\n\t\t \n\t\terr = hw->ops->bap_pread(hw, IRQ_BAP, (void *) bss, len,\n\t\t\t\t\t infofid, sizeof(info));\n\t\tif (err)\n\t\t\tkfree(bss);\n\t\telse\n\t\t\tqbuf_scan(priv, bss, len, type);\n\n\t\tbreak;\n\t}\n\tcase HERMES_INQ_SEC_STAT_AGERE:\n\t\t \n\t\t \n\t\tif (priv->firmware_type == FIRMWARE_TYPE_AGERE)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\tprintk(KERN_DEBUG \"%s: Unknown information frame received: \"\n\t\t       \"type 0x%04x, length %d\\n\", dev->name, type, len);\n\t\t \n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(__orinoco_ev_info);\n\nstatic void __orinoco_ev_infdrop(struct net_device *dev, struct hermes *hw)\n{\n\tif (net_ratelimit())\n\t\tprintk(KERN_DEBUG \"%s: Information frame lost.\\n\", dev->name);\n}\n\n \n \n \n\nstatic int __orinoco_up(struct orinoco_private *priv)\n{\n\tstruct net_device *dev = priv->ndev;\n\tstruct hermes *hw = &priv->hw;\n\tint err;\n\n\tnetif_carrier_off(dev);  \n\n\terr = __orinoco_commit(priv);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Error %d configuring card\\n\",\n\t\t       dev->name, err);\n\t\treturn err;\n\t}\n\n\t \n\thermes_set_irqmask(hw, ORINOCO_INTEN);\n\terr = hermes_enable_port(hw, 0);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Error %d enabling MAC port\\n\",\n\t\t       dev->name, err);\n\t\treturn err;\n\t}\n\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\nstatic int __orinoco_down(struct orinoco_private *priv)\n{\n\tstruct net_device *dev = priv->ndev;\n\tstruct hermes *hw = &priv->hw;\n\tint err;\n\n\tnetif_stop_queue(dev);\n\n\tif (!priv->hw_unavailable) {\n\t\tif (!priv->broken_disableport) {\n\t\t\terr = hermes_disable_port(hw, 0);\n\t\t\tif (err) {\n\t\t\t\t \n\t\t\t\tprintk(KERN_WARNING \"%s: Error %d disabling MAC port\\n\",\n\t\t\t\t       dev->name, err);\n\t\t\t\tpriv->broken_disableport = 1;\n\t\t\t}\n\t\t}\n\t\thermes_set_irqmask(hw, 0);\n\t\thermes_write_regn(hw, EVACK, 0xffff);\n\t}\n\n\torinoco_scan_done(priv, true);\n\n\t \n\tnetif_carrier_off(dev);\n\tpriv->last_linkstatus = 0xffff;\n\n\treturn 0;\n}\n\nstatic int orinoco_reinit_firmware(struct orinoco_private *priv)\n{\n\tstruct hermes *hw = &priv->hw;\n\tint err;\n\n\terr = hw->ops->init(hw);\n\tif (priv->do_fw_download && !err) {\n\t\terr = orinoco_download(priv);\n\t\tif (err)\n\t\t\tpriv->do_fw_download = 0;\n\t}\n\tif (!err)\n\t\terr = orinoco_hw_allocate_fid(priv);\n\n\treturn err;\n}\n\nstatic int\n__orinoco_set_multicast_list(struct net_device *dev)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint err = 0;\n\tint promisc, mc_count;\n\n\t \n\tif ((dev->flags & IFF_PROMISC) || (dev->flags & IFF_ALLMULTI) ||\n\t    (netdev_mc_count(dev) > MAX_MULTICAST(priv))) {\n\t\tpromisc = 1;\n\t\tmc_count = 0;\n\t} else {\n\t\tpromisc = 0;\n\t\tmc_count = netdev_mc_count(dev);\n\t}\n\n\terr = __orinoco_hw_set_multicast_list(priv, dev, mc_count, promisc);\n\n\treturn err;\n}\n\n \nvoid orinoco_reset(struct work_struct *work)\n{\n\tstruct orinoco_private *priv =\n\t\tcontainer_of(work, struct orinoco_private, reset_work);\n\tstruct net_device *dev = priv->ndev;\n\tstruct hermes *hw = &priv->hw;\n\tint err;\n\tunsigned long flags;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\t \n\t\treturn;\n\n\tnetif_stop_queue(dev);\n\n\t \n\thermes_set_irqmask(hw, 0);\n\thermes_write_regn(hw, EVACK, 0xffff);\n\n\tpriv->hw_unavailable++;\n\tpriv->last_linkstatus = 0xffff;  \n\tnetif_carrier_off(dev);\n\n\torinoco_unlock(priv, &flags);\n\n\t \n\torinoco_scan_done(priv, true);\n\n\tif (priv->hard_reset) {\n\t\terr = (*priv->hard_reset)(priv);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"%s: orinoco_reset: Error %d \"\n\t\t\t       \"performing hard reset\\n\", dev->name, err);\n\t\t\tgoto disable;\n\t\t}\n\t}\n\n\terr = orinoco_reinit_firmware(priv);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: orinoco_reset: Error %d re-initializing firmware\\n\",\n\t\t       dev->name, err);\n\t\tgoto disable;\n\t}\n\n\t \n\torinoco_lock_irq(priv);\n\n\tpriv->hw_unavailable--;\n\n\t \n\tif (priv->open && (!priv->hw_unavailable)) {\n\t\terr = __orinoco_up(priv);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"%s: orinoco_reset: Error %d reenabling card\\n\",\n\t\t\t       dev->name, err);\n\t\t} else\n\t\t\tnetif_trans_update(dev);\n\t}\n\n\torinoco_unlock_irq(priv);\n\n\treturn;\n disable:\n\thermes_set_irqmask(hw, 0);\n\tnetif_device_detach(dev);\n\tprintk(KERN_ERR \"%s: Device has been disabled!\\n\", dev->name);\n}\n\nstatic int __orinoco_commit(struct orinoco_private *priv)\n{\n\tstruct net_device *dev = priv->ndev;\n\tint err = 0;\n\n\t \n\tpriv->tkip_cm_active = 0;\n\n\terr = orinoco_hw_program_rids(priv);\n\n\t \n\t(void) __orinoco_set_multicast_list(dev);\n\n\treturn err;\n}\n\n \nint orinoco_commit(struct orinoco_private *priv)\n{\n\tstruct net_device *dev = priv->ndev;\n\tstruct hermes *hw = &priv->hw;\n\tint err;\n\n\tif (priv->broken_disableport) {\n\t\tschedule_work(&priv->reset_work);\n\t\treturn 0;\n\t}\n\n\terr = hermes_disable_port(hw, 0);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"%s: Unable to disable port \"\n\t\t       \"while reconfiguring card\\n\", dev->name);\n\t\tpriv->broken_disableport = 1;\n\t\tgoto out;\n\t}\n\n\terr = __orinoco_commit(priv);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"%s: Unable to reconfigure card\\n\",\n\t\t       dev->name);\n\t\tgoto out;\n\t}\n\n\terr = hermes_enable_port(hw, 0);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"%s: Unable to enable port while reconfiguring card\\n\",\n\t\t       dev->name);\n\t\tgoto out;\n\t}\n\n out:\n\tif (err) {\n\t\tprintk(KERN_WARNING \"%s: Resetting instead...\\n\", dev->name);\n\t\tschedule_work(&priv->reset_work);\n\t\terr = 0;\n\t}\n\treturn err;\n}\n\n \n \n \n\nstatic void __orinoco_ev_tick(struct net_device *dev, struct hermes *hw)\n{\n\tprintk(KERN_DEBUG \"%s: TICK\\n\", dev->name);\n}\n\nstatic void __orinoco_ev_wterr(struct net_device *dev, struct hermes *hw)\n{\n\t \n\tprintk(KERN_DEBUG \"%s: MAC controller error (WTERR). Ignoring.\\n\",\n\t       dev->name);\n}\n\nirqreturn_t orinoco_interrupt(int irq, void *dev_id)\n{\n\tstruct orinoco_private *priv = dev_id;\n\tstruct net_device *dev = priv->ndev;\n\tstruct hermes *hw = &priv->hw;\n\tint count = MAX_IRQLOOPS_PER_IRQ;\n\tu16 evstat, events;\n\t \n\t \n\tstatic int last_irq_jiffy;  \n\tstatic int loops_this_jiffy;  \n\tunsigned long flags;\n\n\tif (orinoco_lock(priv, &flags) != 0) {\n\t\t \n\t\treturn IRQ_HANDLED;\n\t}\n\n\tevstat = hermes_read_regn(hw, EVSTAT);\n\tevents = evstat & hw->inten;\n\tif (!events) {\n\t\torinoco_unlock(priv, &flags);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (jiffies != last_irq_jiffy)\n\t\tloops_this_jiffy = 0;\n\tlast_irq_jiffy = jiffies;\n\n\twhile (events && count--) {\n\t\tif (++loops_this_jiffy > MAX_IRQLOOPS_PER_JIFFY) {\n\t\t\tprintk(KERN_WARNING \"%s: IRQ handler is looping too \"\n\t\t\t       \"much! Resetting.\\n\", dev->name);\n\t\t\t \n\t\t\thermes_set_irqmask(hw, 0);\n\t\t\tschedule_work(&priv->reset_work);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!hermes_present(hw)) {\n\t\t\tDEBUG(0, \"orinoco_interrupt(): card removed\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (events & HERMES_EV_TICK)\n\t\t\t__orinoco_ev_tick(dev, hw);\n\t\tif (events & HERMES_EV_WTERR)\n\t\t\t__orinoco_ev_wterr(dev, hw);\n\t\tif (events & HERMES_EV_INFDROP)\n\t\t\t__orinoco_ev_infdrop(dev, hw);\n\t\tif (events & HERMES_EV_INFO)\n\t\t\t__orinoco_ev_info(dev, hw);\n\t\tif (events & HERMES_EV_RX)\n\t\t\t__orinoco_ev_rx(dev, hw);\n\t\tif (events & HERMES_EV_TXEXC)\n\t\t\t__orinoco_ev_txexc(dev, hw);\n\t\tif (events & HERMES_EV_TX)\n\t\t\t__orinoco_ev_tx(dev, hw);\n\t\tif (events & HERMES_EV_ALLOC)\n\t\t\t__orinoco_ev_alloc(dev, hw);\n\n\t\thermes_write_regn(hw, EVACK, evstat);\n\n\t\tevstat = hermes_read_regn(hw, EVSTAT);\n\t\tevents = evstat & hw->inten;\n\t}\n\n\torinoco_unlock(priv, &flags);\n\treturn IRQ_HANDLED;\n}\nEXPORT_SYMBOL(orinoco_interrupt);\n\n \n \n \n#if defined(CONFIG_PM_SLEEP) && !defined(CONFIG_HERMES_CACHE_FW_ON_INIT)\nstatic int orinoco_pm_notifier(struct notifier_block *notifier,\n\t\t\t       unsigned long pm_event,\n\t\t\t       void *unused)\n{\n\tstruct orinoco_private *priv = container_of(notifier,\n\t\t\t\t\t\t    struct orinoco_private,\n\t\t\t\t\t\t    pm_notifier);\n\n\t \n\tif (!priv->do_fw_download)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (pm_event) {\n\tcase PM_HIBERNATION_PREPARE:\n\tcase PM_SUSPEND_PREPARE:\n\t\torinoco_cache_fw(priv, 0);\n\t\tbreak;\n\n\tcase PM_POST_RESTORE:\n\t\t \n\tcase PM_POST_HIBERNATION:\n\tcase PM_POST_SUSPEND:\n\t\torinoco_uncache_fw(priv);\n\t\tbreak;\n\n\tcase PM_RESTORE_PREPARE:\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic void orinoco_register_pm_notifier(struct orinoco_private *priv)\n{\n\tpriv->pm_notifier.notifier_call = orinoco_pm_notifier;\n\tregister_pm_notifier(&priv->pm_notifier);\n}\n\nstatic void orinoco_unregister_pm_notifier(struct orinoco_private *priv)\n{\n\tunregister_pm_notifier(&priv->pm_notifier);\n}\n#else  \n#define orinoco_register_pm_notifier(priv) do { } while (0)\n#define orinoco_unregister_pm_notifier(priv) do { } while (0)\n#endif\n\n \n \n \n\nint orinoco_init(struct orinoco_private *priv)\n{\n\tstruct device *dev = priv->dev;\n\tstruct wiphy *wiphy = priv_to_wiphy(priv);\n\tstruct hermes *hw = &priv->hw;\n\tint err = 0;\n\n\t \n\tpriv->nicbuf_size = IEEE80211_MAX_FRAME_LEN + ETH_HLEN;\n\n\t \n\terr = hw->ops->init(hw);\n\tif (err != 0) {\n\t\tdev_err(dev, \"Failed to initialize firmware (err = %d)\\n\",\n\t\t\terr);\n\t\tgoto out;\n\t}\n\n\terr = determine_fw_capabilities(priv, wiphy->fw_version,\n\t\t\t\t\tsizeof(wiphy->fw_version),\n\t\t\t\t\t&wiphy->hw_version);\n\tif (err != 0) {\n\t\tdev_err(dev, \"Incompatible firmware, aborting\\n\");\n\t\tgoto out;\n\t}\n\n\tif (priv->do_fw_download) {\n#ifdef CONFIG_HERMES_CACHE_FW_ON_INIT\n\t\torinoco_cache_fw(priv, 0);\n#endif\n\n\t\terr = orinoco_download(priv);\n\t\tif (err)\n\t\t\tpriv->do_fw_download = 0;\n\n\t\t \n\t\terr = determine_fw_capabilities(priv, wiphy->fw_version,\n\t\t\t\t\t\tsizeof(wiphy->fw_version),\n\t\t\t\t\t\t&wiphy->hw_version);\n\t\tif (err != 0) {\n\t\t\tdev_err(dev, \"Incompatible firmware, aborting\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (priv->has_port3)\n\t\tdev_info(dev, \"Ad-hoc demo mode supported\\n\");\n\tif (priv->has_ibss)\n\t\tdev_info(dev, \"IEEE standard IBSS ad-hoc mode supported\\n\");\n\tif (priv->has_wep)\n\t\tdev_info(dev, \"WEP supported, %s-bit key\\n\",\n\t\t\t priv->has_big_wep ? \"104\" : \"40\");\n\tif (priv->has_wpa) {\n\t\tdev_info(dev, \"WPA-PSK supported\\n\");\n\t\tif (orinoco_mic_init(priv)) {\n\t\t\tdev_err(dev, \"Failed to setup MIC crypto algorithm. \"\n\t\t\t\t\"Disabling WPA support\\n\");\n\t\t\tpriv->has_wpa = 0;\n\t\t}\n\t}\n\n\terr = orinoco_hw_read_card_settings(priv, wiphy->perm_addr);\n\tif (err)\n\t\tgoto out;\n\n\terr = orinoco_hw_allocate_fid(priv);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to allocate NIC buffer!\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tpriv->iw_mode = NL80211_IFTYPE_STATION;\n\t \n\tpriv->prefer_port3 = priv->has_port3 && (!priv->has_ibss);\n\tset_port_type(priv);\n\tpriv->channel = 0;  \n\n\tpriv->promiscuous = 0;\n\tpriv->encode_alg = ORINOCO_ALG_NONE;\n\tpriv->tx_key = 0;\n\tpriv->wpa_enabled = 0;\n\tpriv->tkip_cm_active = 0;\n\tpriv->key_mgmt = 0;\n\tpriv->wpa_ie_len = 0;\n\tpriv->wpa_ie = NULL;\n\n\tif (orinoco_wiphy_register(wiphy)) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\t \n\torinoco_lock_irq(priv);\n\tpriv->hw_unavailable--;\n\torinoco_unlock_irq(priv);\n\n\tdev_dbg(dev, \"Ready\\n\");\n\n out:\n\treturn err;\n}\nEXPORT_SYMBOL(orinoco_init);\n\nstatic const struct net_device_ops orinoco_netdev_ops = {\n\t.ndo_open\t\t= orinoco_open,\n\t.ndo_stop\t\t= orinoco_stop,\n\t.ndo_start_xmit\t\t= orinoco_xmit,\n\t.ndo_set_rx_mode\t= orinoco_set_multicast_list,\n\t.ndo_change_mtu\t\t= orinoco_change_mtu,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_tx_timeout\t\t= orinoco_tx_timeout,\n};\n\n \nstruct orinoco_private\n*alloc_orinocodev(int sizeof_card,\n\t\t  struct device *device,\n\t\t  int (*hard_reset)(struct orinoco_private *),\n\t\t  int (*stop_fw)(struct orinoco_private *, int))\n{\n\tstruct orinoco_private *priv;\n\tstruct wiphy *wiphy;\n\n\t \n\twiphy = wiphy_new(&orinoco_cfg_ops,\n\t\t\t  sizeof(struct orinoco_private) + sizeof_card);\n\tif (!wiphy)\n\t\treturn NULL;\n\n\tpriv = wiphy_priv(wiphy);\n\tpriv->dev = device;\n\n\tif (sizeof_card)\n\t\tpriv->card = (void *)((unsigned long)priv\n\t\t\t\t      + sizeof(struct orinoco_private));\n\telse\n\t\tpriv->card = NULL;\n\n\torinoco_wiphy_init(wiphy);\n\n#ifdef WIRELESS_SPY\n\tpriv->wireless_data.spy_data = &priv->spy_data;\n#endif\n\n\t \n\tpriv->hard_reset = hard_reset;\n\tpriv->stop_fw = stop_fw;\n\n\tspin_lock_init(&priv->lock);\n\tpriv->open = 0;\n\tpriv->hw_unavailable = 1;  \n\tINIT_WORK(&priv->reset_work, orinoco_reset);\n\tINIT_WORK(&priv->join_work, orinoco_join_ap);\n\tINIT_WORK(&priv->wevent_work, orinoco_send_wevents);\n\n\tINIT_LIST_HEAD(&priv->rx_list);\n\ttasklet_setup(&priv->rx_tasklet, orinoco_rx_isr_tasklet);\n\n\tspin_lock_init(&priv->scan_lock);\n\tINIT_LIST_HEAD(&priv->scan_list);\n\tINIT_WORK(&priv->process_scan, orinoco_process_scan_results);\n\n\tpriv->last_linkstatus = 0xffff;\n\n#if defined(CONFIG_HERMES_CACHE_FW_ON_INIT) || defined(CONFIG_PM_SLEEP)\n\tpriv->cached_pri_fw = NULL;\n\tpriv->cached_fw = NULL;\n#endif\n\n\t \n\torinoco_register_pm_notifier(priv);\n\n\treturn priv;\n}\nEXPORT_SYMBOL(alloc_orinocodev);\n\n \nint orinoco_if_add(struct orinoco_private *priv,\n\t\t   unsigned long base_addr,\n\t\t   unsigned int irq,\n\t\t   const struct net_device_ops *ops)\n{\n\tstruct wiphy *wiphy = priv_to_wiphy(priv);\n\tstruct wireless_dev *wdev;\n\tstruct net_device *dev;\n\tint ret;\n\n\tdev = alloc_etherdev(sizeof(struct wireless_dev));\n\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\t \n\twdev = netdev_priv(dev);\n\twdev->wiphy = wiphy;\n\twdev->iftype = NL80211_IFTYPE_STATION;\n\n\t \n\tdev->ieee80211_ptr = wdev;\n\tdev->watchdog_timeo = HZ;  \n\tdev->wireless_handlers = &orinoco_handler_def;\n#ifdef WIRELESS_SPY\n\tdev->wireless_data = &priv->wireless_data;\n#endif\n\t \n\tif (ops)\n\t\tdev->netdev_ops = ops;\n\telse\n\t\tdev->netdev_ops = &orinoco_netdev_ops;\n\n\t \n\n\t \n\tdev->needed_headroom = ENCAPS_OVERHEAD;\n\n\tnetif_carrier_off(dev);\n\n\teth_hw_addr_set(dev, wiphy->perm_addr);\n\n\tdev->base_addr = base_addr;\n\tdev->irq = irq;\n\n\tdev->min_mtu = ORINOCO_MIN_MTU;\n\tdev->max_mtu = ORINOCO_MAX_MTU;\n\n\tSET_NETDEV_DEV(dev, priv->dev);\n\tret = register_netdev(dev);\n\tif (ret)\n\t\tgoto fail;\n\n\tpriv->ndev = dev;\n\n\t \n\tdev_dbg(priv->dev, \"Registered interface %s.\\n\", dev->name);\n\n\treturn 0;\n\n fail:\n\tfree_netdev(dev);\n\treturn ret;\n}\nEXPORT_SYMBOL(orinoco_if_add);\n\nvoid orinoco_if_del(struct orinoco_private *priv)\n{\n\tstruct net_device *dev = priv->ndev;\n\n\tunregister_netdev(dev);\n\tfree_netdev(dev);\n}\nEXPORT_SYMBOL(orinoco_if_del);\n\nvoid free_orinocodev(struct orinoco_private *priv)\n{\n\tstruct wiphy *wiphy = priv_to_wiphy(priv);\n\tstruct orinoco_rx_data *rx_data, *temp;\n\tstruct orinoco_scan_data *sd, *sdtemp;\n\n\t \n\ttasklet_kill(&priv->rx_tasklet);\n\n\t \n\tlist_for_each_entry_safe(rx_data, temp, &priv->rx_list, list) {\n\t\tlist_del(&rx_data->list);\n\n\t\tdev_kfree_skb(rx_data->skb);\n\t\tkfree(rx_data->desc);\n\t\tkfree(rx_data);\n\t}\n\n\tcancel_work_sync(&priv->process_scan);\n\t \n\tlist_for_each_entry_safe(sd, sdtemp, &priv->scan_list, list) {\n\t\tlist_del(&sd->list);\n\n\t\tif (sd->len > 0)\n\t\t\tkfree(sd->buf);\n\t\tkfree(sd);\n\t}\n\n\torinoco_unregister_pm_notifier(priv);\n\torinoco_uncache_fw(priv);\n\n\tpriv->wpa_ie_len = 0;\n\tkfree(priv->wpa_ie);\n\torinoco_mic_free(priv);\n\twiphy_free(wiphy);\n}\nEXPORT_SYMBOL(free_orinocodev);\n\nint orinoco_up(struct orinoco_private *priv)\n{\n\tstruct net_device *dev = priv->ndev;\n\tunsigned long flags;\n\tint err;\n\n\tpriv->hw.ops->lock_irqsave(&priv->lock, &flags);\n\n\terr = orinoco_reinit_firmware(priv);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Error %d re-initializing firmware\\n\",\n\t\t       dev->name, err);\n\t\tgoto exit;\n\t}\n\n\tnetif_device_attach(dev);\n\tpriv->hw_unavailable--;\n\n\tif (priv->open && !priv->hw_unavailable) {\n\t\terr = __orinoco_up(priv);\n\t\tif (err)\n\t\t\tprintk(KERN_ERR \"%s: Error %d restarting card\\n\",\n\t\t\t       dev->name, err);\n\t}\n\nexit:\n\tpriv->hw.ops->unlock_irqrestore(&priv->lock, &flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(orinoco_up);\n\nvoid orinoco_down(struct orinoco_private *priv)\n{\n\tstruct net_device *dev = priv->ndev;\n\tunsigned long flags;\n\tint err;\n\n\tpriv->hw.ops->lock_irqsave(&priv->lock, &flags);\n\terr = __orinoco_down(priv);\n\tif (err)\n\t\tprintk(KERN_WARNING \"%s: Error %d downing interface\\n\",\n\t\t       dev->name, err);\n\n\tnetif_device_detach(dev);\n\tpriv->hw_unavailable++;\n\tpriv->hw.ops->unlock_irqrestore(&priv->lock, &flags);\n}\nEXPORT_SYMBOL(orinoco_down);\n\n \n \n \n\n \nstatic char version[] __initdata = DRIVER_NAME \" \" DRIVER_VERSION\n\t\" (David Gibson <hermes@gibson.dropbear.id.au>, \"\n\t\"Pavel Roskin <proski@gnu.org>, et al)\";\n\nstatic int __init init_orinoco(void)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", version);\n\treturn 0;\n}\n\nstatic void __exit exit_orinoco(void)\n{\n}\n\nmodule_init(init_orinoco);\nmodule_exit(exit_orinoco);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}