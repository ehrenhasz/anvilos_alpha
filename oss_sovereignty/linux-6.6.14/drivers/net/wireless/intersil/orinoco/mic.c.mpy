{
  "module_name": "mic.c",
  "hash_id": "2a1e499b0e68317afa64c8a8311b98720e95b58ccf9b85e5cefc6ae4e3401fa0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/orinoco/mic.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/if_ether.h>\n#include <linux/scatterlist.h>\n#include <crypto/hash.h>\n\n#include \"orinoco.h\"\n#include \"mic.h\"\n\n \n \n \nint orinoco_mic_init(struct orinoco_private *priv)\n{\n\tpriv->tx_tfm_mic = crypto_alloc_shash(\"michael_mic\", 0, 0);\n\tif (IS_ERR(priv->tx_tfm_mic)) {\n\t\tprintk(KERN_DEBUG \"%s: could not allocate \"\n\t\t       \"crypto API michael_mic\\n\", __func__);\n\t\tpriv->tx_tfm_mic = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->rx_tfm_mic = crypto_alloc_shash(\"michael_mic\", 0, 0);\n\tif (IS_ERR(priv->rx_tfm_mic)) {\n\t\tprintk(KERN_DEBUG \"%s: could not allocate \"\n\t\t       \"crypto API michael_mic\\n\", __func__);\n\t\tpriv->rx_tfm_mic = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nvoid orinoco_mic_free(struct orinoco_private *priv)\n{\n\tif (priv->tx_tfm_mic)\n\t\tcrypto_free_shash(priv->tx_tfm_mic);\n\tif (priv->rx_tfm_mic)\n\t\tcrypto_free_shash(priv->rx_tfm_mic);\n}\n\nint orinoco_mic(struct crypto_shash *tfm_michael, u8 *key,\n\t\tu8 *da, u8 *sa, u8 priority,\n\t\tu8 *data, size_t data_len, u8 *mic)\n{\n\tSHASH_DESC_ON_STACK(desc, tfm_michael);\n\tu8 hdr[ETH_HLEN + 2];  \n\tint err;\n\n\tif (tfm_michael == NULL) {\n\t\tprintk(KERN_WARNING \"%s: tfm_michael == NULL\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\t \n\tmemcpy(&hdr[0], da, ETH_ALEN);\n\tmemcpy(&hdr[ETH_ALEN], sa, ETH_ALEN);\n\thdr[ETH_ALEN * 2] = priority;\n\thdr[ETH_ALEN * 2 + 1] = 0;\n\thdr[ETH_ALEN * 2 + 2] = 0;\n\thdr[ETH_ALEN * 2 + 3] = 0;\n\n\tdesc->tfm = tfm_michael;\n\n\terr = crypto_shash_setkey(tfm_michael, key, MIC_KEYLEN);\n\tif (err)\n\t\treturn err;\n\n\terr = crypto_shash_init(desc);\n\tif (err)\n\t\treturn err;\n\n\terr = crypto_shash_update(desc, hdr, sizeof(hdr));\n\tif (err)\n\t\treturn err;\n\n\terr = crypto_shash_update(desc, data, data_len);\n\tif (err)\n\t\treturn err;\n\n\terr = crypto_shash_final(desc, mic);\n\tshash_desc_zero(desc);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}