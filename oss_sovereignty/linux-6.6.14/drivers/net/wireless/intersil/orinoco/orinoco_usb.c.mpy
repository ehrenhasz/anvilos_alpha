{
  "module_name": "orinoco_usb.c",
  "hash_id": "3ea1a8973ac113f4c8f0f0b4b6d5e365a9a593dc0d9a0467d951d76b49cc404d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/orinoco/orinoco_usb.c",
  "human_readable_source": " \n\n#define DRIVER_NAME \"orinoco_usb\"\n#define PFX DRIVER_NAME \": \"\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/usb.h>\n#include <linux/timer.h>\n\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/etherdevice.h>\n#include <linux/wireless.h>\n#include <linux/firmware.h>\n#include <linux/refcount.h>\n\n#include \"mic.h\"\n#include \"orinoco.h\"\n\n#ifndef URB_ASYNC_UNLINK\n#define URB_ASYNC_UNLINK 0\n#endif\n\nstruct header_struct {\n\t \n\tu8 dest[ETH_ALEN];\n\tu8 src[ETH_ALEN];\n\t__be16 len;\n\t \n\tu8 dsap;\n\tu8 ssap;\n\tu8 ctrl;\n\t \n\tu8 oui[3];\n\t__be16 ethertype;\n} __packed;\n\nstruct ez_usb_fw {\n\tu16 size;\n\tconst u8 *code;\n};\n\nstatic struct ez_usb_fw firmware = {\n\t.size = 0,\n\t.code = NULL,\n};\n\n \n#undef err\n#define err(format, arg...) \\\n\tdo { printk(KERN_ERR PFX format \"\\n\", ## arg); } while (0)\n\nMODULE_FIRMWARE(\"orinoco_ezusb_fw\");\n\n \n\n#define USB_COMPAQ_VENDOR_ID     0x049f  \n#define USB_COMPAQ_WL215_ID      0x001f  \n#define USB_COMPAQ_W200_ID       0x0076  \n#define USB_HP_WL215_ID          0x0082  \n\n#define USB_MELCO_VENDOR_ID      0x0411\n#define USB_BUFFALO_L11_ID       0x0006  \n#define USB_BUFFALO_L11G_WR_ID   0x000B  \n#define USB_BUFFALO_L11G_ID      0x000D  \n\n#define USB_LUCENT_VENDOR_ID     0x047E  \n#define USB_LUCENT_ORINOCO_ID    0x0300  \n\n#define USB_AVAYA8_VENDOR_ID     0x0D98\n#define USB_AVAYAE_VENDOR_ID     0x0D9E\n#define USB_AVAYA_WIRELESS_ID    0x0300  \n\n#define USB_AGERE_VENDOR_ID      0x0D4E  \n#define USB_AGERE_MODEL0801_ID   0x1000  \n#define USB_AGERE_MODEL0802_ID   0x1001  \n#define USB_AGERE_REBRANDED_ID   0x047A  \n\n#define USB_ELSA_VENDOR_ID       0x05CC\n#define USB_ELSA_AIRLANCER_ID    0x3100  \n\n#define USB_LEGEND_VENDOR_ID     0x0E7C\n#define USB_LEGEND_JOYNET_ID     0x0300  \n\n#define USB_SAMSUNG_VENDOR_ID    0x04E8\n#define USB_SAMSUNG_SEW2001U1_ID 0x5002  \n#define USB_SAMSUNG_SEW2001U2_ID 0x5B11  \n#define USB_SAMSUNG_SEW2003U_ID  0x7011  \n\n#define USB_IGATE_VENDOR_ID      0x0681\n#define USB_IGATE_IGATE_11M_ID   0x0012  \n\n#define USB_FUJITSU_VENDOR_ID    0x0BF8\n#define USB_FUJITSU_E1100_ID     0x1002  \n\n#define USB_2WIRE_VENDOR_ID      0x1630\n#define USB_2WIRE_WIRELESS_ID    0xff81  \n\n\n#define EZUSB_REQUEST_FW_TRANS\t\t0xA0\n#define EZUSB_REQUEST_TRIGGER\t\t0xAA\n#define EZUSB_REQUEST_TRIG_AC\t\t0xAC\n#define EZUSB_CPUCS_REG\t\t\t0x7F92\n\n#define EZUSB_RID_TX\t\t\t0x0700\n#define EZUSB_RID_RX\t\t\t0x0701\n#define EZUSB_RID_INIT1\t\t\t0x0702\n#define EZUSB_RID_ACK\t\t\t0x0710\n#define EZUSB_RID_READ_PDA\t\t0x0800\n#define EZUSB_RID_PROG_INIT\t\t0x0852\n#define EZUSB_RID_PROG_SET_ADDR\t\t0x0853\n#define EZUSB_RID_PROG_BYTES\t\t0x0854\n#define EZUSB_RID_PROG_END\t\t0x0855\n#define EZUSB_RID_DOCMD\t\t\t0x0860\n\n \n#define EZUSB_IS_INFO(id)\t\t((id >= 0xF000) && (id <= 0xF2FF))\n\n#define EZUSB_MAGIC\t\t\t0x0210\n\n#define EZUSB_FRAME_DATA\t\t1\n#define EZUSB_FRAME_CONTROL\t\t2\n\n#define DEF_TIMEOUT\t\t\t(3 * HZ)\n\n#define BULK_BUF_SIZE\t\t\t2048\n\n#define MAX_DL_SIZE (BULK_BUF_SIZE - sizeof(struct ezusb_packet))\n\n#define FW_BUF_SIZE\t\t\t64\n#define FW_VAR_OFFSET_PTR\t\t0x359\n#define FW_VAR_VALUE\t\t\t0\n#define FW_HOLE_START\t\t\t0x100\n#define FW_HOLE_END\t\t\t0x300\n\nstruct ezusb_packet {\n\t__le16 magic;\t\t \n\tu8 req_reply_count;\n\tu8 ans_reply_count;\n\t__le16 frame_type;\t \n\t__le16 size;\t\t \n\t__le16 crc;\t\t \n\t__le16 hermes_len;\n\t__le16 hermes_rid;\n\tu8 data[];\n} __packed;\n\n \nstatic const struct usb_device_id ezusb_table[] = {\n\t{USB_DEVICE(USB_COMPAQ_VENDOR_ID, USB_COMPAQ_WL215_ID)},\n\t{USB_DEVICE(USB_COMPAQ_VENDOR_ID, USB_HP_WL215_ID)},\n\t{USB_DEVICE(USB_COMPAQ_VENDOR_ID, USB_COMPAQ_W200_ID)},\n\t{USB_DEVICE(USB_MELCO_VENDOR_ID, USB_BUFFALO_L11_ID)},\n\t{USB_DEVICE(USB_MELCO_VENDOR_ID, USB_BUFFALO_L11G_WR_ID)},\n\t{USB_DEVICE(USB_MELCO_VENDOR_ID, USB_BUFFALO_L11G_ID)},\n\t{USB_DEVICE(USB_LUCENT_VENDOR_ID, USB_LUCENT_ORINOCO_ID)},\n\t{USB_DEVICE(USB_AVAYA8_VENDOR_ID, USB_AVAYA_WIRELESS_ID)},\n\t{USB_DEVICE(USB_AVAYAE_VENDOR_ID, USB_AVAYA_WIRELESS_ID)},\n\t{USB_DEVICE(USB_AGERE_VENDOR_ID, USB_AGERE_MODEL0801_ID)},\n\t{USB_DEVICE(USB_AGERE_VENDOR_ID, USB_AGERE_MODEL0802_ID)},\n\t{USB_DEVICE(USB_ELSA_VENDOR_ID, USB_ELSA_AIRLANCER_ID)},\n\t{USB_DEVICE(USB_LEGEND_VENDOR_ID, USB_LEGEND_JOYNET_ID)},\n\t{USB_DEVICE_VER(USB_SAMSUNG_VENDOR_ID, USB_SAMSUNG_SEW2001U1_ID,\n\t\t\t0, 0)},\n\t{USB_DEVICE(USB_SAMSUNG_VENDOR_ID, USB_SAMSUNG_SEW2001U2_ID)},\n\t{USB_DEVICE(USB_SAMSUNG_VENDOR_ID, USB_SAMSUNG_SEW2003U_ID)},\n\t{USB_DEVICE(USB_IGATE_VENDOR_ID, USB_IGATE_IGATE_11M_ID)},\n\t{USB_DEVICE(USB_FUJITSU_VENDOR_ID, USB_FUJITSU_E1100_ID)},\n\t{USB_DEVICE(USB_2WIRE_VENDOR_ID, USB_2WIRE_WIRELESS_ID)},\n\t{USB_DEVICE(USB_AGERE_VENDOR_ID, USB_AGERE_REBRANDED_ID)},\n\t{}\t\t\t \n};\n\nMODULE_DEVICE_TABLE(usb, ezusb_table);\n\n \nstruct ezusb_priv {\n\tstruct usb_device *udev;\n\tstruct net_device *dev;\n\tstruct mutex mtx;\n\tspinlock_t req_lock;\n\tstruct list_head req_pending;\n\tstruct list_head req_active;\n\tspinlock_t reply_count_lock;\n\tu16 hermes_reg_fake[0x40];\n\tu8 *bap_buf;\n\tstruct urb *read_urb;\n\tint read_pipe;\n\tint write_pipe;\n\tu8 reply_count;\n};\n\nenum ezusb_state {\n\tEZUSB_CTX_START,\n\tEZUSB_CTX_QUEUED,\n\tEZUSB_CTX_REQ_SUBMITTED,\n\tEZUSB_CTX_REQ_COMPLETE,\n\tEZUSB_CTX_RESP_RECEIVED,\n\tEZUSB_CTX_REQ_TIMEOUT,\n\tEZUSB_CTX_REQ_FAILED,\n\tEZUSB_CTX_RESP_TIMEOUT,\n\tEZUSB_CTX_REQSUBMIT_FAIL,\n\tEZUSB_CTX_COMPLETE,\n};\n\nstruct request_context {\n\tstruct list_head list;\n\trefcount_t refcount;\n\tstruct completion done;\t \n\tint killed;\n\tstruct urb *outurb;\t \n\tstruct ezusb_priv *upriv;\n\tstruct ezusb_packet *buf;\n\tint buf_length;\n\tstruct timer_list timer;\t \n\tenum ezusb_state state;\t \n\t \n\tu16 out_rid;\n\tu16 in_rid;\n};\n\n\n \nstatic void ezusb_ctx_complete(struct request_context *ctx);\nstatic void ezusb_req_queue_run(struct ezusb_priv *upriv);\nstatic void ezusb_bulk_in_callback(struct urb *urb);\n\nstatic inline u8 ezusb_reply_inc(u8 count)\n{\n\tif (count < 0x7F)\n\t\treturn count + 1;\n\telse\n\t\treturn 1;\n}\n\nstatic void ezusb_request_context_put(struct request_context *ctx)\n{\n\tif (!refcount_dec_and_test(&ctx->refcount))\n\t\treturn;\n\n\tWARN_ON(!ctx->done.done);\n\tBUG_ON(ctx->outurb->status == -EINPROGRESS);\n\tBUG_ON(timer_pending(&ctx->timer));\n\tusb_free_urb(ctx->outurb);\n\tkfree(ctx->buf);\n\tkfree(ctx);\n}\n\nstatic inline void ezusb_mod_timer(struct ezusb_priv *upriv,\n\t\t\t\t   struct timer_list *timer,\n\t\t\t\t   unsigned long expire)\n{\n\tif (!upriv->udev)\n\t\treturn;\n\tmod_timer(timer, expire);\n}\n\nstatic void ezusb_request_timerfn(struct timer_list *t)\n{\n\tstruct request_context *ctx = from_timer(ctx, t, timer);\n\n\tctx->outurb->transfer_flags |= URB_ASYNC_UNLINK;\n\tif (usb_unlink_urb(ctx->outurb) == -EINPROGRESS) {\n\t\tctx->state = EZUSB_CTX_REQ_TIMEOUT;\n\t} else {\n\t\tctx->state = EZUSB_CTX_RESP_TIMEOUT;\n\t\tdev_dbg(&ctx->outurb->dev->dev, \"couldn't unlink\\n\");\n\t\trefcount_inc(&ctx->refcount);\n\t\tctx->killed = 1;\n\t\tezusb_ctx_complete(ctx);\n\t\tezusb_request_context_put(ctx);\n\t}\n};\n\nstatic struct request_context *ezusb_alloc_ctx(struct ezusb_priv *upriv,\n\t\t\t\t\t       u16 out_rid, u16 in_rid)\n{\n\tstruct request_context *ctx;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_ATOMIC);\n\tif (!ctx)\n\t\treturn NULL;\n\n\tctx->buf = kmalloc(BULK_BUF_SIZE, GFP_ATOMIC);\n\tif (!ctx->buf) {\n\t\tkfree(ctx);\n\t\treturn NULL;\n\t}\n\tctx->outurb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!ctx->outurb) {\n\t\tkfree(ctx->buf);\n\t\tkfree(ctx);\n\t\treturn NULL;\n\t}\n\n\tctx->upriv = upriv;\n\tctx->state = EZUSB_CTX_START;\n\tctx->out_rid = out_rid;\n\tctx->in_rid = in_rid;\n\n\trefcount_set(&ctx->refcount, 1);\n\tinit_completion(&ctx->done);\n\n\ttimer_setup(&ctx->timer, ezusb_request_timerfn, 0);\n\treturn ctx;\n}\n\nstatic void ezusb_ctx_complete(struct request_context *ctx)\n{\n\tstruct ezusb_priv *upriv = ctx->upriv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&upriv->req_lock, flags);\n\n\tlist_del_init(&ctx->list);\n\tif (upriv->udev) {\n\t\tspin_unlock_irqrestore(&upriv->req_lock, flags);\n\t\tezusb_req_queue_run(upriv);\n\t\tspin_lock_irqsave(&upriv->req_lock, flags);\n\t}\n\n\tswitch (ctx->state) {\n\tcase EZUSB_CTX_COMPLETE:\n\tcase EZUSB_CTX_REQSUBMIT_FAIL:\n\tcase EZUSB_CTX_REQ_FAILED:\n\tcase EZUSB_CTX_REQ_TIMEOUT:\n\tcase EZUSB_CTX_RESP_TIMEOUT:\n\t\tspin_unlock_irqrestore(&upriv->req_lock, flags);\n\n\t\tif ((ctx->out_rid == EZUSB_RID_TX) && upriv->dev) {\n\t\t\tstruct net_device *dev = upriv->dev;\n\t\t\tstruct net_device_stats *stats = &dev->stats;\n\n\t\t\tif (ctx->state != EZUSB_CTX_COMPLETE)\n\t\t\t\tstats->tx_errors++;\n\t\t\telse\n\t\t\t\tstats->tx_packets++;\n\n\t\t\tnetif_wake_queue(dev);\n\t\t}\n\t\tcomplete_all(&ctx->done);\n\t\tezusb_request_context_put(ctx);\n\t\tbreak;\n\n\tdefault:\n\t\tspin_unlock_irqrestore(&upriv->req_lock, flags);\n\t\tif (!upriv->udev) {\n\t\t\t \n\t\t\terr(\"Called, CTX not terminating, but device gone\");\n\t\t\tcomplete_all(&ctx->done);\n\t\t\tezusb_request_context_put(ctx);\n\t\t\tbreak;\n\t\t}\n\n\t\terr(\"Called, CTX not in terminating state.\");\n\t\t \n\t\tbreak;\n\t}\n}\n\n \nstatic void ezusb_req_queue_run(struct ezusb_priv *upriv)\n{\n\tunsigned long flags;\n\tstruct request_context *ctx;\n\tint result;\n\n\tspin_lock_irqsave(&upriv->req_lock, flags);\n\n\tif (!list_empty(&upriv->req_active))\n\t\tgoto unlock;\n\n\tif (list_empty(&upriv->req_pending))\n\t\tgoto unlock;\n\n\tctx =\n\t    list_entry(upriv->req_pending.next, struct request_context,\n\t\t       list);\n\n\tif (!ctx->upriv->udev)\n\t\tgoto unlock;\n\n\t \n\tlist_move_tail(&ctx->list, &upriv->req_active);\n\n\tif (ctx->state == EZUSB_CTX_QUEUED) {\n\t\trefcount_inc(&ctx->refcount);\n\t\tresult = usb_submit_urb(ctx->outurb, GFP_ATOMIC);\n\t\tif (result) {\n\t\t\tctx->state = EZUSB_CTX_REQSUBMIT_FAIL;\n\n\t\t\tspin_unlock_irqrestore(&upriv->req_lock, flags);\n\n\t\t\terr(\"Fatal, failed to submit command urb.\"\n\t\t\t    \" error=%d\\n\", result);\n\n\t\t\tezusb_ctx_complete(ctx);\n\t\t\tezusb_request_context_put(ctx);\n\t\t\tgoto done;\n\t\t}\n\n\t\tctx->state = EZUSB_CTX_REQ_SUBMITTED;\n\t\tezusb_mod_timer(ctx->upriv, &ctx->timer,\n\t\t\t\tjiffies + DEF_TIMEOUT);\n\t}\n\n unlock:\n\tspin_unlock_irqrestore(&upriv->req_lock, flags);\n\n done:\n\treturn;\n}\n\nstatic void ezusb_req_enqueue_run(struct ezusb_priv *upriv,\n\t\t\t\t  struct request_context *ctx)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&upriv->req_lock, flags);\n\n\tif (!ctx->upriv->udev) {\n\t\tspin_unlock_irqrestore(&upriv->req_lock, flags);\n\t\tgoto done;\n\t}\n\trefcount_inc(&ctx->refcount);\n\tlist_add_tail(&ctx->list, &upriv->req_pending);\n\tspin_unlock_irqrestore(&upriv->req_lock, flags);\n\n\tctx->state = EZUSB_CTX_QUEUED;\n\tezusb_req_queue_run(upriv);\n\n done:\n\treturn;\n}\n\nstatic void ezusb_request_out_callback(struct urb *urb)\n{\n\tunsigned long flags;\n\tenum ezusb_state state;\n\tstruct request_context *ctx = urb->context;\n\tstruct ezusb_priv *upriv = ctx->upriv;\n\n\tspin_lock_irqsave(&upriv->req_lock, flags);\n\n\tdel_timer(&ctx->timer);\n\n\tif (ctx->killed) {\n\t\tspin_unlock_irqrestore(&upriv->req_lock, flags);\n\t\tpr_warn(\"interrupt called with dead ctx\\n\");\n\t\tgoto out;\n\t}\n\n\tstate = ctx->state;\n\n\tif (urb->status == 0) {\n\t\tswitch (state) {\n\t\tcase EZUSB_CTX_REQ_SUBMITTED:\n\t\t\tif (ctx->in_rid) {\n\t\t\t\tctx->state = EZUSB_CTX_REQ_COMPLETE;\n\t\t\t\t \n\t\t\t\tezusb_mod_timer(upriv, &ctx->timer,\n\t\t\t\t\t\tjiffies + DEF_TIMEOUT);\n\t\t\t\tspin_unlock_irqrestore(&upriv->req_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase EZUSB_CTX_RESP_RECEIVED:\n\t\t\t \n\t\t\tctx->state = EZUSB_CTX_COMPLETE;\n\t\t\tspin_unlock_irqrestore(&upriv->req_lock, flags);\n\t\t\tezusb_ctx_complete(ctx);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tspin_unlock_irqrestore(&upriv->req_lock, flags);\n\t\t\terr(\"Unexpected state(0x%x, %d) in OUT URB\",\n\t\t\t    state, urb->status);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tswitch (state) {\n\t\tcase EZUSB_CTX_REQ_SUBMITTED:\n\t\tcase EZUSB_CTX_RESP_RECEIVED:\n\t\t\tctx->state = EZUSB_CTX_REQ_FAILED;\n\t\t\tfallthrough;\n\n\t\tcase EZUSB_CTX_REQ_FAILED:\n\t\tcase EZUSB_CTX_REQ_TIMEOUT:\n\t\t\tspin_unlock_irqrestore(&upriv->req_lock, flags);\n\n\t\t\tezusb_ctx_complete(ctx);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tspin_unlock_irqrestore(&upriv->req_lock, flags);\n\n\t\t\terr(\"Unexpected state(0x%x, %d) in OUT URB\",\n\t\t\t    state, urb->status);\n\t\t\tbreak;\n\t\t}\n\t}\n out:\n\tezusb_request_context_put(ctx);\n}\n\nstatic void ezusb_request_in_callback(struct ezusb_priv *upriv,\n\t\t\t\t      struct urb *urb)\n{\n\tstruct ezusb_packet *ans = urb->transfer_buffer;\n\tstruct request_context *ctx = NULL;\n\tenum ezusb_state state;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&upriv->req_lock, flags);\n\tif (upriv->udev) {\n\t\tstruct list_head *item;\n\n\t\tlist_for_each(item, &upriv->req_active) {\n\t\t\tstruct request_context *c;\n\t\t\tint reply_count;\n\n\t\t\tc = list_entry(item, struct request_context, list);\n\t\t\treply_count =\n\t\t\t    ezusb_reply_inc(c->buf->req_reply_count);\n\t\t\tif ((ans->ans_reply_count == reply_count)\n\t\t\t    && (le16_to_cpu(ans->hermes_rid) == c->in_rid)) {\n\t\t\t\tctx = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnetdev_dbg(upriv->dev, \"Skipped (0x%x/0x%x) (%d/%d)\\n\",\n\t\t\t\t   le16_to_cpu(ans->hermes_rid), c->in_rid,\n\t\t\t\t   ans->ans_reply_count, reply_count);\n\t\t}\n\t}\n\n\tif (ctx == NULL) {\n\t\tspin_unlock_irqrestore(&upriv->req_lock, flags);\n\t\terr(\"%s: got unexpected RID: 0x%04X\", __func__,\n\t\t    le16_to_cpu(ans->hermes_rid));\n\t\tezusb_req_queue_run(upriv);\n\t\treturn;\n\t}\n\n\t \n\turb->transfer_buffer = ctx->buf;\n\tctx->buf = (void *) ans;\n\tctx->buf_length = urb->actual_length;\n\n\tstate = ctx->state;\n\tswitch (state) {\n\tcase EZUSB_CTX_REQ_SUBMITTED:\n\t\t \n\t\tctx->state = EZUSB_CTX_RESP_RECEIVED;\n\t\tspin_unlock_irqrestore(&upriv->req_lock, flags);\n\n\t\t \n\t\tbreak;\n\n\tcase EZUSB_CTX_REQ_COMPLETE:\n\t\t \n\t\tctx->state = EZUSB_CTX_COMPLETE;\n\n\t\t \n\t\tdel_timer(&ctx->timer);\n\t\tspin_unlock_irqrestore(&upriv->req_lock, flags);\n\n\t\t \n\t\tezusb_ctx_complete(ctx);\n\t\tbreak;\n\n\tdefault:\n\t\tspin_unlock_irqrestore(&upriv->req_lock, flags);\n\n\t\tpr_warn(\"Matched IN URB, unexpected context state(0x%x)\\n\",\n\t\t\tstate);\n\t\t \n\t\tdel_timer(&ctx->timer);\n\t\tctx->outurb->transfer_flags |= URB_ASYNC_UNLINK;\n\t\tusb_unlink_urb(ctx->outurb);\n\t\tezusb_req_queue_run(upriv);\n\t\tbreak;\n\t}\t\t\t \n}\n\ntypedef void (*ezusb_ctx_wait)(struct ezusb_priv *, struct request_context *);\n\nstatic void ezusb_req_ctx_wait_compl(struct ezusb_priv *upriv,\n\t\t\t\t     struct request_context *ctx)\n{\n\tswitch (ctx->state) {\n\tcase EZUSB_CTX_QUEUED:\n\tcase EZUSB_CTX_REQ_SUBMITTED:\n\tcase EZUSB_CTX_REQ_COMPLETE:\n\tcase EZUSB_CTX_RESP_RECEIVED:\n\t\twait_for_completion(&ctx->done);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n\nstatic void ezusb_req_ctx_wait_poll(struct ezusb_priv *upriv,\n\t\t\t\t    struct request_context *ctx)\n{\n\tint msecs;\n\n\tswitch (ctx->state) {\n\tcase EZUSB_CTX_QUEUED:\n\tcase EZUSB_CTX_REQ_SUBMITTED:\n\tcase EZUSB_CTX_REQ_COMPLETE:\n\tcase EZUSB_CTX_RESP_RECEIVED:\n\t\t \n\t\tmsecs = DEF_TIMEOUT * (1000 / HZ);\n\n\t\twhile (!try_wait_for_completion(&ctx->done) && msecs--)\n\t\t\tudelay(1000);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n\nstatic void ezusb_req_ctx_wait_skip(struct ezusb_priv *upriv,\n\t\t\t\t    struct request_context *ctx)\n{\n\tWARN(1, \"Shouldn't be invoked for in_rid\\n\");\n}\n\nstatic inline u16 build_crc(struct ezusb_packet *data)\n{\n\tu16 crc = 0;\n\tu8 *bytes = (u8 *)data;\n\tint i;\n\n\tfor (i = 0; i < 8; i++)\n\t\tcrc = (crc << 1) + bytes[i];\n\n\treturn crc;\n}\n\n \nstatic int ezusb_fill_req(struct ezusb_packet *req, u16 length, u16 rid,\n\t\t\t  const void *data, u16 frame_type, u8 reply_count)\n{\n\tint total_size = sizeof(*req) + length;\n\n\tBUG_ON(total_size > BULK_BUF_SIZE);\n\n\treq->magic = cpu_to_le16(EZUSB_MAGIC);\n\treq->req_reply_count = reply_count;\n\treq->ans_reply_count = 0;\n\treq->frame_type = cpu_to_le16(frame_type);\n\treq->size = cpu_to_le16(length + 4);\n\treq->crc = cpu_to_le16(build_crc(req));\n\treq->hermes_len = cpu_to_le16(HERMES_BYTES_TO_RECLEN(length));\n\treq->hermes_rid = cpu_to_le16(rid);\n\tif (data)\n\t\tmemcpy(req->data, data, length);\n\treturn total_size;\n}\n\nstatic int ezusb_submit_in_urb(struct ezusb_priv *upriv)\n{\n\tint retval = 0;\n\tvoid *cur_buf = upriv->read_urb->transfer_buffer;\n\n\tif (upriv->read_urb->status == -EINPROGRESS) {\n\t\tnetdev_dbg(upriv->dev, \"urb busy, not resubmiting\\n\");\n\t\tretval = -EBUSY;\n\t\tgoto exit;\n\t}\n\tusb_fill_bulk_urb(upriv->read_urb, upriv->udev, upriv->read_pipe,\n\t\t\t  cur_buf, BULK_BUF_SIZE,\n\t\t\t  ezusb_bulk_in_callback, upriv);\n\tupriv->read_urb->transfer_flags = 0;\n\tretval = usb_submit_urb(upriv->read_urb, GFP_ATOMIC);\n\tif (retval)\n\t\terr(\"%s submit failed %d\", __func__, retval);\n\n exit:\n\treturn retval;\n}\n\nstatic inline int ezusb_8051_cpucs(struct ezusb_priv *upriv, int reset)\n{\n\tint ret;\n\tu8 *res_val = NULL;\n\n\tif (!upriv->udev) {\n\t\terr(\"%s: !upriv->udev\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tres_val = kmalloc(sizeof(*res_val), GFP_KERNEL);\n\n\tif (!res_val)\n\t\treturn -ENOMEM;\n\n\t*res_val = reset;\t \n\n\tret =  usb_control_msg(upriv->udev,\n\t\t\t       usb_sndctrlpipe(upriv->udev, 0),\n\t\t\t       EZUSB_REQUEST_FW_TRANS,\n\t\t\t       USB_TYPE_VENDOR | USB_RECIP_DEVICE |\n\t\t\t       USB_DIR_OUT, EZUSB_CPUCS_REG, 0, res_val,\n\t\t\t       sizeof(*res_val), DEF_TIMEOUT);\n\n\tkfree(res_val);\n\n\treturn ret;\n}\n\nstatic int ezusb_firmware_download(struct ezusb_priv *upriv,\n\t\t\t\t   struct ez_usb_fw *fw)\n{\n\tu8 *fw_buffer;\n\tint retval, addr;\n\tint variant_offset;\n\n\tfw_buffer = kmalloc(FW_BUF_SIZE, GFP_KERNEL);\n\tif (!fw_buffer) {\n\t\tprintk(KERN_ERR PFX \"Out of memory for firmware buffer.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\t \n\tvariant_offset = be16_to_cpup((__be16 *) &fw->code[FW_VAR_OFFSET_PTR]);\n\tif (variant_offset >= fw->size) {\n\t\tprintk(KERN_ERR PFX \"Invalid firmware variant offset: \"\n\t\t       \"0x%04x\\n\", variant_offset);\n\t\tretval = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tretval = ezusb_8051_cpucs(upriv, 1);\n\tif (retval < 0)\n\t\tgoto fail;\n\tfor (addr = 0; addr < fw->size; addr += FW_BUF_SIZE) {\n\t\t \n\t\tif ((addr >= FW_HOLE_START) && (addr < FW_HOLE_END))\n\t\t\tcontinue;\n\n\t\tmemcpy(fw_buffer, &fw->code[addr], FW_BUF_SIZE);\n\t\tif (variant_offset >= addr &&\n\t\t    variant_offset < addr + FW_BUF_SIZE) {\n\t\t\tnetdev_dbg(upriv->dev,\n\t\t\t\t   \"Patching card_variant byte at 0x%04X\\n\",\n\t\t\t\t   variant_offset);\n\t\t\tfw_buffer[variant_offset - addr] = FW_VAR_VALUE;\n\t\t}\n\t\tretval = usb_control_msg(upriv->udev,\n\t\t\t\t\t usb_sndctrlpipe(upriv->udev, 0),\n\t\t\t\t\t EZUSB_REQUEST_FW_TRANS,\n\t\t\t\t\t USB_TYPE_VENDOR | USB_RECIP_DEVICE\n\t\t\t\t\t | USB_DIR_OUT,\n\t\t\t\t\t addr, 0x0,\n\t\t\t\t\t fw_buffer, FW_BUF_SIZE,\n\t\t\t\t\t DEF_TIMEOUT);\n\n\t\tif (retval < 0)\n\t\t\tgoto fail;\n\t}\n\tretval = ezusb_8051_cpucs(upriv, 0);\n\tif (retval < 0)\n\t\tgoto fail;\n\n\tgoto exit;\n fail:\n\tprintk(KERN_ERR PFX \"Firmware download failed, error %d\\n\",\n\t       retval);\n exit:\n\tkfree(fw_buffer);\n\treturn retval;\n}\n\nstatic int ezusb_access_ltv(struct ezusb_priv *upriv,\n\t\t\t    struct request_context *ctx,\n\t\t\t    u16 length, const void *data, u16 frame_type,\n\t\t\t    void *ans_buff, unsigned ans_size, u16 *ans_length,\n\t\t\t    ezusb_ctx_wait ezusb_ctx_wait_func)\n{\n\tint req_size;\n\tint retval = 0;\n\tenum ezusb_state state;\n\n\tif (!upriv->udev) {\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tif (upriv->read_urb->status != -EINPROGRESS)\n\t\terr(\"%s: in urb not pending\", __func__);\n\n\t \n\tspin_lock_bh(&upriv->reply_count_lock);\n\treq_size = ezusb_fill_req(ctx->buf, length, ctx->out_rid, data,\n\t\t\t\t  frame_type, upriv->reply_count);\n\tusb_fill_bulk_urb(ctx->outurb, upriv->udev, upriv->write_pipe,\n\t\t\t  ctx->buf, req_size,\n\t\t\t  ezusb_request_out_callback, ctx);\n\n\tif (ctx->in_rid)\n\t\tupriv->reply_count = ezusb_reply_inc(upriv->reply_count);\n\n\tezusb_req_enqueue_run(upriv, ctx);\n\n\tspin_unlock_bh(&upriv->reply_count_lock);\n\n\tif (ctx->in_rid)\n\t\tezusb_ctx_wait_func(upriv, ctx);\n\n\tstate = ctx->state;\n\tswitch (state) {\n\tcase EZUSB_CTX_COMPLETE:\n\t\tretval = ctx->outurb->status;\n\t\tbreak;\n\n\tcase EZUSB_CTX_QUEUED:\n\tcase EZUSB_CTX_REQ_SUBMITTED:\n\t\tif (!ctx->in_rid)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\terr(\"%s: Unexpected context state %d\", __func__,\n\t\t    state);\n\t\tfallthrough;\n\tcase EZUSB_CTX_REQ_TIMEOUT:\n\tcase EZUSB_CTX_REQ_FAILED:\n\tcase EZUSB_CTX_RESP_TIMEOUT:\n\tcase EZUSB_CTX_REQSUBMIT_FAIL:\n\t\tprintk(KERN_ERR PFX \"Access failed, resetting (state %d,\"\n\t\t       \" reply_count %d)\\n\", state, upriv->reply_count);\n\t\tupriv->reply_count = 0;\n\t\tif (state == EZUSB_CTX_REQ_TIMEOUT\n\t\t    || state == EZUSB_CTX_RESP_TIMEOUT) {\n\t\t\tprintk(KERN_ERR PFX \"ctx timed out\\n\");\n\t\t\tretval = -ETIMEDOUT;\n\t\t} else {\n\t\t\tprintk(KERN_ERR PFX \"ctx failed\\n\");\n\t\t\tretval = -EFAULT;\n\t\t}\n\t\tgoto exit;\n\t}\n\tif (ctx->in_rid) {\n\t\tstruct ezusb_packet *ans = ctx->buf;\n\t\tunsigned exp_len;\n\n\t\tif (ans->hermes_len != 0)\n\t\t\texp_len = le16_to_cpu(ans->hermes_len) * 2 + 12;\n\t\telse\n\t\t\texp_len = 14;\n\n\t\tif (exp_len != ctx->buf_length) {\n\t\t\terr(\"%s: length mismatch for RID 0x%04x: \"\n\t\t\t    \"expected %d, got %d\", __func__,\n\t\t\t    ctx->in_rid, exp_len, ctx->buf_length);\n\t\t\tretval = -EIO;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (ans_buff)\n\t\t\tmemcpy(ans_buff, ans->data, min(exp_len, ans_size));\n\t\tif (ans_length)\n\t\t\t*ans_length = le16_to_cpu(ans->hermes_len);\n\t}\n exit:\n\tezusb_request_context_put(ctx);\n\treturn retval;\n}\n\nstatic int __ezusb_write_ltv(struct hermes *hw, int bap, u16 rid,\n\t\t\t   u16 length, const void *data,\n\t\t\t   ezusb_ctx_wait ezusb_ctx_wait_func)\n{\n\tstruct ezusb_priv *upriv = hw->priv;\n\tu16 frame_type;\n\tstruct request_context *ctx;\n\n\tif (length == 0)\n\t\treturn -EINVAL;\n\n\tlength = HERMES_RECLEN_TO_BYTES(length);\n\n\t \n\tif (length == 0)\n\t\treturn 0;\n\n\tctx = ezusb_alloc_ctx(upriv, rid, EZUSB_RID_ACK);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tif (rid == EZUSB_RID_TX)\n\t\tframe_type = EZUSB_FRAME_DATA;\n\telse\n\t\tframe_type = EZUSB_FRAME_CONTROL;\n\n\treturn ezusb_access_ltv(upriv, ctx, length, data, frame_type,\n\t\t\t\tNULL, 0, NULL, ezusb_ctx_wait_func);\n}\n\nstatic int ezusb_write_ltv(struct hermes *hw, int bap, u16 rid,\n\t\t\t   u16 length, const void *data)\n{\n\treturn __ezusb_write_ltv(hw, bap, rid, length, data,\n\t\t\t\t ezusb_req_ctx_wait_poll);\n}\n\nstatic int __ezusb_read_ltv(struct hermes *hw, int bap, u16 rid,\n\t\t\t    unsigned bufsize, u16 *length, void *buf,\n\t\t\t    ezusb_ctx_wait ezusb_ctx_wait_func)\n\n{\n\tstruct ezusb_priv *upriv = hw->priv;\n\tstruct request_context *ctx;\n\n\tif (bufsize % 2)\n\t\treturn -EINVAL;\n\n\tctx = ezusb_alloc_ctx(upriv, rid, rid);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\treturn ezusb_access_ltv(upriv, ctx, 0, NULL, EZUSB_FRAME_CONTROL,\n\t\t\t\tbuf, bufsize, length, ezusb_req_ctx_wait_poll);\n}\n\nstatic int ezusb_read_ltv(struct hermes *hw, int bap, u16 rid,\n\t\t\t    unsigned bufsize, u16 *length, void *buf)\n{\n\treturn __ezusb_read_ltv(hw, bap, rid, bufsize, length, buf,\n\t\t\t\tezusb_req_ctx_wait_poll);\n}\n\nstatic int ezusb_read_ltv_preempt(struct hermes *hw, int bap, u16 rid,\n\t\t\t\t  unsigned bufsize, u16 *length, void *buf)\n{\n\treturn __ezusb_read_ltv(hw, bap, rid, bufsize, length, buf,\n\t\t\t\tezusb_req_ctx_wait_compl);\n}\n\nstatic int ezusb_doicmd_wait(struct hermes *hw, u16 cmd, u16 parm0, u16 parm1,\n\t\t\t     u16 parm2, struct hermes_response *resp)\n{\n\tWARN_ON_ONCE(1);\n\treturn -EINVAL;\n}\n\nstatic int __ezusb_docmd_wait(struct hermes *hw, u16 cmd, u16 parm0,\n\t\t\t    struct hermes_response *resp,\n\t\t\t    ezusb_ctx_wait ezusb_ctx_wait_func)\n{\n\tstruct ezusb_priv *upriv = hw->priv;\n\tstruct request_context *ctx;\n\n\t__le16 data[4] = {\n\t\tcpu_to_le16(cmd),\n\t\tcpu_to_le16(parm0),\n\t\t0,\n\t\t0,\n\t};\n\tnetdev_dbg(upriv->dev, \"0x%04X, parm0 0x%04X\\n\", cmd, parm0);\n\tctx = ezusb_alloc_ctx(upriv, EZUSB_RID_DOCMD, EZUSB_RID_ACK);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\treturn ezusb_access_ltv(upriv, ctx, sizeof(data), &data,\n\t\t\t\tEZUSB_FRAME_CONTROL, NULL, 0, NULL,\n\t\t\t\tezusb_ctx_wait_func);\n}\n\nstatic int ezusb_docmd_wait(struct hermes *hw, u16 cmd, u16 parm0,\n\t\t\t    struct hermes_response *resp)\n{\n\treturn __ezusb_docmd_wait(hw, cmd, parm0, resp, ezusb_req_ctx_wait_poll);\n}\n\nstatic int ezusb_bap_pread(struct hermes *hw, int bap,\n\t\t\t   void *buf, int len, u16 id, u16 offset)\n{\n\tstruct ezusb_priv *upriv = hw->priv;\n\tstruct ezusb_packet *ans = (void *) upriv->read_urb->transfer_buffer;\n\tint actual_length = upriv->read_urb->actual_length;\n\n\tif (id == EZUSB_RID_RX) {\n\t\tif ((sizeof(*ans) + offset + len) > actual_length) {\n\t\t\tprintk(KERN_ERR PFX \"BAP read beyond buffer end \"\n\t\t\t       \"in rx frame\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmemcpy(buf, ans->data + offset, len);\n\t\treturn 0;\n\t}\n\n\tif (EZUSB_IS_INFO(id)) {\n\t\t \n\t\tif ((sizeof(*ans) + offset + len - 4) > actual_length) {\n\t\t\tprintk(KERN_ERR PFX \"BAP read beyond buffer end \"\n\t\t\t       \"in info frame\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tmemcpy(buf, ans->data + offset - 4, len);\n\t} else {\n\t\tprintk(KERN_ERR PFX \"Unexpected fid 0x%04x\\n\", id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ezusb_read_pda(struct hermes *hw, __le16 *pda,\n\t\t\t  u32 pda_addr, u16 pda_len)\n{\n\tstruct ezusb_priv *upriv = hw->priv;\n\tstruct request_context *ctx;\n\t__le16 data[] = {\n\t\tcpu_to_le16(pda_addr & 0xffff),\n\t\tcpu_to_le16(pda_len - 4)\n\t};\n\tctx = ezusb_alloc_ctx(upriv, EZUSB_RID_READ_PDA, EZUSB_RID_READ_PDA);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t \n\tpda[0] = cpu_to_le16(pda_len - 2);\n\t \n\tpda[1] = cpu_to_le16(0x0800);  \n\n\treturn ezusb_access_ltv(upriv, ctx, sizeof(data), &data,\n\t\t\t\tEZUSB_FRAME_CONTROL, &pda[2], pda_len - 4,\n\t\t\t\tNULL, ezusb_req_ctx_wait_compl);\n}\n\nstatic int ezusb_program_init(struct hermes *hw, u32 entry_point)\n{\n\tstruct ezusb_priv *upriv = hw->priv;\n\tstruct request_context *ctx;\n\t__le32 data = cpu_to_le32(entry_point);\n\n\tctx = ezusb_alloc_ctx(upriv, EZUSB_RID_PROG_INIT, EZUSB_RID_ACK);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\treturn ezusb_access_ltv(upriv, ctx, sizeof(data), &data,\n\t\t\t\tEZUSB_FRAME_CONTROL, NULL, 0, NULL,\n\t\t\t\tezusb_req_ctx_wait_compl);\n}\n\nstatic int ezusb_program_end(struct hermes *hw)\n{\n\tstruct ezusb_priv *upriv = hw->priv;\n\tstruct request_context *ctx;\n\n\tctx = ezusb_alloc_ctx(upriv, EZUSB_RID_PROG_END, EZUSB_RID_ACK);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\treturn ezusb_access_ltv(upriv, ctx, 0, NULL,\n\t\t\t\tEZUSB_FRAME_CONTROL, NULL, 0, NULL,\n\t\t\t\tezusb_req_ctx_wait_compl);\n}\n\nstatic int ezusb_program_bytes(struct hermes *hw, const char *buf,\n\t\t\t       u32 addr, u32 len)\n{\n\tstruct ezusb_priv *upriv = hw->priv;\n\tstruct request_context *ctx;\n\t__le32 data = cpu_to_le32(addr);\n\tint err;\n\n\tctx = ezusb_alloc_ctx(upriv, EZUSB_RID_PROG_SET_ADDR, EZUSB_RID_ACK);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\terr = ezusb_access_ltv(upriv, ctx, sizeof(data), &data,\n\t\t\t       EZUSB_FRAME_CONTROL, NULL, 0, NULL,\n\t\t\t       ezusb_req_ctx_wait_compl);\n\tif (err)\n\t\treturn err;\n\n\tctx = ezusb_alloc_ctx(upriv, EZUSB_RID_PROG_BYTES, EZUSB_RID_ACK);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\treturn ezusb_access_ltv(upriv, ctx, len, buf,\n\t\t\t\tEZUSB_FRAME_CONTROL, NULL, 0, NULL,\n\t\t\t\tezusb_req_ctx_wait_compl);\n}\n\nstatic int ezusb_program(struct hermes *hw, const char *buf,\n\t\t\t u32 addr, u32 len)\n{\n\tu32 ch_addr;\n\tu32 ch_len;\n\tint err = 0;\n\n\t \n\n\tch_len = (len < MAX_DL_SIZE) ? len : MAX_DL_SIZE;\n\tch_addr = addr;\n\n\twhile (ch_addr < (addr + len)) {\n\t\tpr_debug(\"Programming subblock of length %d \"\n\t\t\t \"to address 0x%08x. Data @ %p\\n\",\n\t\t\t ch_len, ch_addr, &buf[ch_addr - addr]);\n\n\t\terr = ezusb_program_bytes(hw, &buf[ch_addr - addr],\n\t\t\t\t\t  ch_addr, ch_len);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tch_addr += ch_len;\n\t\tch_len = ((addr + len - ch_addr) < MAX_DL_SIZE) ?\n\t\t\t(addr + len - ch_addr) : MAX_DL_SIZE;\n\t}\n\n\treturn err;\n}\n\nstatic netdev_tx_t ezusb_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct ezusb_priv *upriv = priv->card;\n\tu8 mic[MICHAEL_MIC_LEN + 1];\n\tint err = 0;\n\tint tx_control;\n\tunsigned long flags;\n\tstruct request_context *ctx;\n\tu8 *buf;\n\tint tx_size;\n\n\tif (!netif_running(dev)) {\n\t\tprintk(KERN_ERR \"%s: Tx on stopped device!\\n\",\n\t\t       dev->name);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tif (netif_queue_stopped(dev)) {\n\t\tprintk(KERN_DEBUG \"%s: Tx while transmitter busy!\\n\",\n\t\t       dev->name);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tif (orinoco_lock(priv, &flags) != 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: ezusb_xmit() called while hw_unavailable\\n\",\n\t\t       dev->name);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tif (!netif_carrier_ok(dev) ||\n\t    (priv->iw_mode == NL80211_IFTYPE_MONITOR)) {\n\t\t \n\t\tgoto drop;\n\t}\n\n\t \n\tif (skb->len < ETH_HLEN)\n\t\tgoto drop;\n\n\ttx_control = 0;\n\n\terr = orinoco_process_xmit_skb(skb, dev, priv, &tx_control,\n\t\t\t\t       &mic[0]);\n\tif (err)\n\t\tgoto drop;\n\n\tctx = ezusb_alloc_ctx(upriv, EZUSB_RID_TX, 0);\n\tif (!ctx)\n\t\tgoto drop;\n\n\tmemset(ctx->buf, 0, BULK_BUF_SIZE);\n\tbuf = ctx->buf->data;\n\n\t{\n\t\t__le16 *tx_cntl = (__le16 *)buf;\n\t\t*tx_cntl = cpu_to_le16(tx_control);\n\t\tbuf += sizeof(*tx_cntl);\n\t}\n\n\tmemcpy(buf, skb->data, skb->len);\n\tbuf += skb->len;\n\n\tif (tx_control & HERMES_TXCTRL_MIC) {\n\t\tu8 *m = mic;\n\t\t \n\t\tif (skb->len % 2)\n\t\t\tm++;\n\t\tmemcpy(buf, m, MICHAEL_MIC_LEN);\n\t\tbuf += MICHAEL_MIC_LEN;\n\t}\n\n\t \n\tnetif_stop_queue(dev);\n\n\t \n\ttx_size = ALIGN(buf - ctx->buf->data, 2);\n\n\terr = ezusb_access_ltv(upriv, ctx, tx_size, NULL,\n\t\t\t       EZUSB_FRAME_DATA, NULL, 0, NULL,\n\t\t\t       ezusb_req_ctx_wait_skip);\n\n\tif (err) {\n\t\tnetif_start_queue(dev);\n\t\tif (net_ratelimit())\n\t\t\tprintk(KERN_ERR \"%s: Error %d transmitting packet\\n\",\n\t\t\t\tdev->name, err);\n\t\tgoto busy;\n\t}\n\n\tnetif_trans_update(dev);\n\tstats->tx_bytes += skb->len;\n\tgoto ok;\n\n drop:\n\tstats->tx_errors++;\n\tstats->tx_dropped++;\n\n ok:\n\torinoco_unlock(priv, &flags);\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n\n busy:\n\torinoco_unlock(priv, &flags);\n\treturn NETDEV_TX_BUSY;\n}\n\nstatic int ezusb_allocate(struct hermes *hw, u16 size, u16 *fid)\n{\n\t*fid = EZUSB_RID_TX;\n\treturn 0;\n}\n\n\nstatic int ezusb_hard_reset(struct orinoco_private *priv)\n{\n\tstruct ezusb_priv *upriv = priv->card;\n\tint retval = ezusb_8051_cpucs(upriv, 1);\n\n\tif (retval < 0) {\n\t\terr(\"Failed to reset\");\n\t\treturn retval;\n\t}\n\n\tretval = ezusb_8051_cpucs(upriv, 0);\n\tif (retval < 0) {\n\t\terr(\"Failed to unreset\");\n\t\treturn retval;\n\t}\n\n\tnetdev_dbg(upriv->dev, \"sending control message\\n\");\n\tretval = usb_control_msg(upriv->udev,\n\t\t\t\t usb_sndctrlpipe(upriv->udev, 0),\n\t\t\t\t EZUSB_REQUEST_TRIGGER,\n\t\t\t\t USB_TYPE_VENDOR | USB_RECIP_DEVICE |\n\t\t\t\t USB_DIR_OUT, 0x0, 0x0, NULL, 0,\n\t\t\t\t DEF_TIMEOUT);\n\tif (retval < 0) {\n\t\terr(\"EZUSB_REQUEST_TRIGGER failed retval %d\", retval);\n\t\treturn retval;\n\t}\n#if 0\n\tdbg(\"Sending EZUSB_REQUEST_TRIG_AC\");\n\tretval = usb_control_msg(upriv->udev,\n\t\t\t\t usb_sndctrlpipe(upriv->udev, 0),\n\t\t\t\t EZUSB_REQUEST_TRIG_AC,\n\t\t\t\t USB_TYPE_VENDOR | USB_RECIP_DEVICE |\n\t\t\t\t USB_DIR_OUT, 0x00FA, 0x0, NULL, 0,\n\t\t\t\t DEF_TIMEOUT);\n\tif (retval < 0) {\n\t\terr(\"EZUSB_REQUEST_TRIG_AC failed retval %d\", retval);\n\t\treturn retval;\n\t}\n#endif\n\n\treturn 0;\n}\n\n\nstatic int ezusb_init(struct hermes *hw)\n{\n\tstruct ezusb_priv *upriv = hw->priv;\n\tint retval;\n\n\tif (!upriv)\n\t\treturn -EINVAL;\n\n\tupriv->reply_count = 0;\n\t \n\thermes_write_regn(hw, SWSUPPORT0, HERMES_MAGIC);\n\thermes_write_regn(hw, RXFID, EZUSB_RID_RX);\n\n\tusb_kill_urb(upriv->read_urb);\n\tezusb_submit_in_urb(upriv);\n\n\tretval = __ezusb_write_ltv(hw, 0, EZUSB_RID_INIT1,\n\t\t\t\t HERMES_BYTES_TO_RECLEN(2), \"\\x10\\x00\",\n\t\t\t\t ezusb_req_ctx_wait_compl);\n\tif (retval < 0) {\n\t\tprintk(KERN_ERR PFX \"EZUSB_RID_INIT1 error %d\\n\", retval);\n\t\treturn retval;\n\t}\n\n\tretval = __ezusb_docmd_wait(hw, HERMES_CMD_INIT, 0, NULL,\n\t\t\t\t    ezusb_req_ctx_wait_compl);\n\tif (retval < 0) {\n\t\tprintk(KERN_ERR PFX \"HERMES_CMD_INIT error %d\\n\", retval);\n\t\treturn retval;\n\t}\n\n\treturn 0;\n}\n\nstatic void ezusb_bulk_in_callback(struct urb *urb)\n{\n\tstruct ezusb_priv *upriv = (struct ezusb_priv *) urb->context;\n\tstruct ezusb_packet *ans = urb->transfer_buffer;\n\tu16 crc;\n\tu16 hermes_rid;\n\n\tif (upriv->udev == NULL)\n\t\treturn;\n\n\tif (urb->status == -ETIMEDOUT) {\n\t\t \n\t\tpr_warn(\"%s: urb timed out, not resubmitting\\n\", __func__);\n\t\treturn;\n\t}\n\tif (urb->status == -ECONNABORTED) {\n\t\tpr_warn(\"%s: connection abort, resubmitting urb\\n\",\n\t\t\t__func__);\n\t\tgoto resubmit;\n\t}\n\tif ((urb->status == -EILSEQ)\n\t    || (urb->status == -ENOENT)\n\t    || (urb->status == -ECONNRESET)) {\n\t\tnetdev_dbg(upriv->dev, \"status %d, not resubmiting\\n\",\n\t\t\t   urb->status);\n\t\treturn;\n\t}\n\tif (urb->status)\n\t\tnetdev_dbg(upriv->dev, \"status: %d length: %d\\n\",\n\t\t\t   urb->status, urb->actual_length);\n\tif (urb->actual_length < sizeof(*ans)) {\n\t\terr(\"%s: short read, ignoring\", __func__);\n\t\tgoto resubmit;\n\t}\n\tcrc = build_crc(ans);\n\tif (le16_to_cpu(ans->crc) != crc) {\n\t\terr(\"CRC error, ignoring packet\");\n\t\tgoto resubmit;\n\t}\n\n\thermes_rid = le16_to_cpu(ans->hermes_rid);\n\tif ((hermes_rid != EZUSB_RID_RX) && !EZUSB_IS_INFO(hermes_rid)) {\n\t\tezusb_request_in_callback(upriv, urb);\n\t} else if (upriv->dev) {\n\t\tstruct net_device *dev = upriv->dev;\n\t\tstruct orinoco_private *priv = ndev_priv(dev);\n\t\tstruct hermes *hw = &priv->hw;\n\n\t\tif (hermes_rid == EZUSB_RID_RX) {\n\t\t\t__orinoco_ev_rx(dev, hw);\n\t\t} else {\n\t\t\thermes_write_regn(hw, INFOFID,\n\t\t\t\t\t  le16_to_cpu(ans->hermes_rid));\n\t\t\t__orinoco_ev_info(dev, hw);\n\t\t}\n\t}\n\n resubmit:\n\tif (upriv->udev)\n\t\tezusb_submit_in_urb(upriv);\n}\n\nstatic inline void ezusb_delete(struct ezusb_priv *upriv)\n{\n\tstruct list_head *item;\n\tstruct list_head *tmp_item;\n\tunsigned long flags;\n\n\tBUG_ON(!upriv);\n\n\tmutex_lock(&upriv->mtx);\n\n\tupriv->udev = NULL;\t \n\n\tusb_kill_urb(upriv->read_urb);\n\n\tspin_lock_irqsave(&upriv->req_lock, flags);\n\tlist_for_each_safe(item, tmp_item, &upriv->req_active) {\n\t\tstruct request_context *ctx;\n\t\tint err;\n\n\t\tctx = list_entry(item, struct request_context, list);\n\t\trefcount_inc(&ctx->refcount);\n\n\t\tctx->outurb->transfer_flags |= URB_ASYNC_UNLINK;\n\t\terr = usb_unlink_urb(ctx->outurb);\n\n\t\tspin_unlock_irqrestore(&upriv->req_lock, flags);\n\t\tif (err == -EINPROGRESS)\n\t\t\twait_for_completion(&ctx->done);\n\n\t\tdel_timer_sync(&ctx->timer);\n\t\t \n\t\tif (!list_empty(&ctx->list))\n\t\t\tezusb_ctx_complete(ctx);\n\n\t\tezusb_request_context_put(ctx);\n\t\tspin_lock_irqsave(&upriv->req_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&upriv->req_lock, flags);\n\n\tlist_for_each_safe(item, tmp_item, &upriv->req_pending)\n\t    ezusb_ctx_complete(list_entry(item,\n\t\t\t\t\t  struct request_context, list));\n\n\tif (upriv->read_urb && upriv->read_urb->status == -EINPROGRESS)\n\t\tprintk(KERN_ERR PFX \"Some URB in progress\\n\");\n\n\tmutex_unlock(&upriv->mtx);\n\n\tif (upriv->read_urb) {\n\t\tkfree(upriv->read_urb->transfer_buffer);\n\t\tusb_free_urb(upriv->read_urb);\n\t}\n\tkfree(upriv->bap_buf);\n\tif (upriv->dev) {\n\t\tstruct orinoco_private *priv = ndev_priv(upriv->dev);\n\t\torinoco_if_del(priv);\n\t\twiphy_unregister(priv_to_wiphy(upriv));\n\t\tfree_orinocodev(priv);\n\t}\n}\n\nstatic void ezusb_lock_irqsave(spinlock_t *lock,\n\t\t\t       unsigned long *flags) __acquires(lock)\n{\n\tspin_lock_bh(lock);\n}\n\nstatic void ezusb_unlock_irqrestore(spinlock_t *lock,\n\t\t\t\t    unsigned long *flags) __releases(lock)\n{\n\tspin_unlock_bh(lock);\n}\n\nstatic void ezusb_lock_irq(spinlock_t *lock) __acquires(lock)\n{\n\tspin_lock_bh(lock);\n}\n\nstatic void ezusb_unlock_irq(spinlock_t *lock) __releases(lock)\n{\n\tspin_unlock_bh(lock);\n}\n\nstatic const struct hermes_ops ezusb_ops = {\n\t.init = ezusb_init,\n\t.cmd_wait = ezusb_docmd_wait,\n\t.init_cmd_wait = ezusb_doicmd_wait,\n\t.allocate = ezusb_allocate,\n\t.read_ltv = ezusb_read_ltv,\n\t.read_ltv_pr = ezusb_read_ltv_preempt,\n\t.write_ltv = ezusb_write_ltv,\n\t.bap_pread = ezusb_bap_pread,\n\t.read_pda = ezusb_read_pda,\n\t.program_init = ezusb_program_init,\n\t.program_end = ezusb_program_end,\n\t.program = ezusb_program,\n\t.lock_irqsave = ezusb_lock_irqsave,\n\t.unlock_irqrestore = ezusb_unlock_irqrestore,\n\t.lock_irq = ezusb_lock_irq,\n\t.unlock_irq = ezusb_unlock_irq,\n};\n\nstatic const struct net_device_ops ezusb_netdev_ops = {\n\t.ndo_open\t\t= orinoco_open,\n\t.ndo_stop\t\t= orinoco_stop,\n\t.ndo_start_xmit\t\t= ezusb_xmit,\n\t.ndo_set_rx_mode\t= orinoco_set_multicast_list,\n\t.ndo_change_mtu\t\t= orinoco_change_mtu,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_tx_timeout\t\t= orinoco_tx_timeout,\n};\n\nstatic int ezusb_probe(struct usb_interface *interface,\n\t\t       const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct orinoco_private *priv;\n\tstruct hermes *hw;\n\tstruct ezusb_priv *upriv = NULL;\n\tstruct usb_interface_descriptor *iface_desc;\n\tstruct usb_endpoint_descriptor *ep;\n\tconst struct firmware *fw_entry = NULL;\n\tint retval = 0;\n\tint i;\n\n\tpriv = alloc_orinocodev(sizeof(*upriv), &udev->dev,\n\t\t\t\tezusb_hard_reset, NULL);\n\tif (!priv) {\n\t\terr(\"Couldn't allocate orinocodev\");\n\t\tretval = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\thw = &priv->hw;\n\n\tupriv = priv->card;\n\n\tmutex_init(&upriv->mtx);\n\tspin_lock_init(&upriv->reply_count_lock);\n\n\tspin_lock_init(&upriv->req_lock);\n\tINIT_LIST_HEAD(&upriv->req_pending);\n\tINIT_LIST_HEAD(&upriv->req_active);\n\n\tupriv->udev = udev;\n\n\thw->iobase = (void __force __iomem *) &upriv->hermes_reg_fake;\n\thw->reg_spacing = HERMES_16BIT_REGSPACING;\n\thw->priv = upriv;\n\thw->ops = &ezusb_ops;\n\n\t \n\t \n\n\tiface_desc = &interface->cur_altsetting->desc;\n\tfor (i = 0; i < iface_desc->bNumEndpoints; ++i) {\n\t\tep = &interface->cur_altsetting->endpoint[i].desc;\n\n\t\tif (usb_endpoint_is_bulk_in(ep)) {\n\t\t\t \n\t\t\tif (upriv->read_urb != NULL) {\n\t\t\t\tpr_warn(\"Found a second bulk in ep, ignored\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tupriv->read_urb = usb_alloc_urb(0, GFP_KERNEL);\n\t\t\tif (!upriv->read_urb)\n\t\t\t\tgoto error;\n\t\t\tif (le16_to_cpu(ep->wMaxPacketSize) != 64)\n\t\t\t\tpr_warn(\"bulk in: wMaxPacketSize!= 64\\n\");\n\t\t\tif (ep->bEndpointAddress != (2 | USB_DIR_IN))\n\t\t\t\tpr_warn(\"bulk in: bEndpointAddress: %d\\n\",\n\t\t\t\t\tep->bEndpointAddress);\n\t\t\tupriv->read_pipe = usb_rcvbulkpipe(udev,\n\t\t\t\t\t\t\t ep->\n\t\t\t\t\t\t\t bEndpointAddress);\n\t\t\tupriv->read_urb->transfer_buffer =\n\t\t\t    kmalloc(BULK_BUF_SIZE, GFP_KERNEL);\n\t\t\tif (!upriv->read_urb->transfer_buffer) {\n\t\t\t\terr(\"Couldn't allocate IN buffer\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\tif (usb_endpoint_is_bulk_out(ep)) {\n\t\t\t \n\t\t\tif (upriv->bap_buf != NULL) {\n\t\t\t\tpr_warn(\"Found a second bulk out ep, ignored\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (le16_to_cpu(ep->wMaxPacketSize) != 64)\n\t\t\t\tpr_warn(\"bulk out: wMaxPacketSize != 64\\n\");\n\t\t\tif (ep->bEndpointAddress != 2)\n\t\t\t\tpr_warn(\"bulk out: bEndpointAddress: %d\\n\",\n\t\t\t\t\tep->bEndpointAddress);\n\t\t\tupriv->write_pipe = usb_sndbulkpipe(udev,\n\t\t\t\t\t\t\t  ep->\n\t\t\t\t\t\t\t  bEndpointAddress);\n\t\t\tupriv->bap_buf = kmalloc(BULK_BUF_SIZE, GFP_KERNEL);\n\t\t\tif (!upriv->bap_buf) {\n\t\t\t\terr(\"Couldn't allocate bulk_out_buffer\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\tif (!upriv->bap_buf || !upriv->read_urb) {\n\t\terr(\"Didn't find the required bulk endpoints\");\n\t\tgoto error;\n\t}\n\n\tif (request_firmware(&fw_entry, \"orinoco_ezusb_fw\",\n\t\t\t     &interface->dev) == 0) {\n\t\tfirmware.size = fw_entry->size;\n\t\tfirmware.code = fw_entry->data;\n\t}\n\tif (firmware.size && firmware.code) {\n\t\tif (ezusb_firmware_download(upriv, &firmware) < 0)\n\t\t\tgoto error;\n\t} else {\n\t\terr(\"No firmware to download\");\n\t\tgoto error;\n\t}\n\n\tif (ezusb_hard_reset(priv) < 0) {\n\t\terr(\"Cannot reset the device\");\n\t\tgoto error;\n\t}\n\n\t \n\tif (ezusb_init(hw) < 0) {\n\t\terr(\"Couldn't initialize the device\");\n\t\terr(\"Firmware may not be downloaded or may be wrong.\");\n\t\tgoto error;\n\t}\n\n\t \n\tif (orinoco_init(priv) != 0) {\n\t\terr(\"orinoco_init() failed\\n\");\n\t\tgoto error;\n\t}\n\n\tif (orinoco_if_add(priv, 0, 0, &ezusb_netdev_ops) != 0) {\n\t\tupriv->dev = NULL;\n\t\terr(\"%s: orinoco_if_add() failed\", __func__);\n\t\twiphy_unregister(priv_to_wiphy(priv));\n\t\tgoto error;\n\t}\n\tupriv->dev = priv->ndev;\n\n\tgoto exit;\n\n error:\n\tezusb_delete(upriv);\n\tif (upriv->dev) {\n\t\t \n\t\tfree_orinocodev(priv);\n\t}\n\tupriv = NULL;\n\tretval = -EFAULT;\n exit:\n\tif (fw_entry) {\n\t\tfirmware.code = NULL;\n\t\tfirmware.size = 0;\n\t\trelease_firmware(fw_entry);\n\t}\n\tusb_set_intfdata(interface, upriv);\n\treturn retval;\n}\n\n\nstatic void ezusb_disconnect(struct usb_interface *intf)\n{\n\tstruct ezusb_priv *upriv = usb_get_intfdata(intf);\n\tusb_set_intfdata(intf, NULL);\n\tezusb_delete(upriv);\n\tprintk(KERN_INFO PFX \"Disconnected\\n\");\n}\n\n\n \nstatic struct usb_driver orinoco_driver = {\n\t.name = DRIVER_NAME,\n\t.probe = ezusb_probe,\n\t.disconnect = ezusb_disconnect,\n\t.id_table = ezusb_table,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(orinoco_driver);\n\nMODULE_AUTHOR(\"Manuel Estrada Sainz\");\nMODULE_DESCRIPTION(\"Driver for Orinoco wireless LAN cards using EZUSB bridge\");\nMODULE_LICENSE(\"Dual MPL/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}