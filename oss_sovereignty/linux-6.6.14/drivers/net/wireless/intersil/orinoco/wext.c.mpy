{
  "module_name": "wext.c",
  "hash_id": "4444351c7e9adda596e5a7cd189c7b7cc814acd3539b58851b6f9a5249c9530b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/orinoco/wext.c",
  "human_readable_source": " \n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/if_arp.h>\n#include <linux/wireless.h>\n#include <linux/ieee80211.h>\n#include <linux/etherdevice.h>\n#include <net/iw_handler.h>\n#include <net/cfg80211.h>\n#include <net/cfg80211-wext.h>\n\n#include \"hermes.h\"\n#include \"hermes_rid.h\"\n#include \"orinoco.h\"\n\n#include \"hw.h\"\n#include \"mic.h\"\n#include \"scan.h\"\n#include \"main.h\"\n\n#include \"wext.h\"\n\n#define MAX_RID_LEN 1024\n\n \nstatic int orinoco_set_key(struct orinoco_private *priv, int index,\n\t\t\t   enum orinoco_alg alg, const u8 *key, int key_len,\n\t\t\t   const u8 *seq, int seq_len)\n{\n\tkfree_sensitive(priv->keys[index].key);\n\tkfree_sensitive(priv->keys[index].seq);\n\n\tif (key_len) {\n\t\tpriv->keys[index].key = kzalloc(key_len, GFP_ATOMIC);\n\t\tif (!priv->keys[index].key)\n\t\t\tgoto nomem;\n\t} else\n\t\tpriv->keys[index].key = NULL;\n\n\tif (seq_len) {\n\t\tpriv->keys[index].seq = kzalloc(seq_len, GFP_ATOMIC);\n\t\tif (!priv->keys[index].seq)\n\t\t\tgoto free_key;\n\t} else\n\t\tpriv->keys[index].seq = NULL;\n\n\tpriv->keys[index].key_len = key_len;\n\tpriv->keys[index].seq_len = seq_len;\n\n\tif (key_len)\n\t\tmemcpy((void *)priv->keys[index].key, key, key_len);\n\tif (seq_len)\n\t\tmemcpy((void *)priv->keys[index].seq, seq, seq_len);\n\n\tswitch (alg) {\n\tcase ORINOCO_ALG_TKIP:\n\t\tpriv->keys[index].cipher = WLAN_CIPHER_SUITE_TKIP;\n\t\tbreak;\n\n\tcase ORINOCO_ALG_WEP:\n\t\tpriv->keys[index].cipher = (key_len > SMALL_KEY_SIZE) ?\n\t\t\tWLAN_CIPHER_SUITE_WEP104 : WLAN_CIPHER_SUITE_WEP40;\n\t\tbreak;\n\n\tcase ORINOCO_ALG_NONE:\n\tdefault:\n\t\tpriv->keys[index].cipher = 0;\n\t\tbreak;\n\t}\n\n\treturn 0;\n\nfree_key:\n\tkfree(priv->keys[index].key);\n\tpriv->keys[index].key = NULL;\n\nnomem:\n\tpriv->keys[index].key_len = 0;\n\tpriv->keys[index].seq_len = 0;\n\tpriv->keys[index].cipher = 0;\n\n\treturn -ENOMEM;\n}\n\nstatic struct iw_statistics *orinoco_get_wireless_stats(struct net_device *dev)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tstruct hermes *hw = &priv->hw;\n\tstruct iw_statistics *wstats = &priv->wstats;\n\tint err;\n\tunsigned long flags;\n\n\tif (!netif_device_present(dev)) {\n\t\tprintk(KERN_WARNING \"%s: get_wireless_stats() called while device not present\\n\",\n\t\t       dev->name);\n\t\treturn NULL;  \n\t}\n\n\t \n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn wstats;\n\n\t \n\t \n\thermes_inquire(hw, HERMES_INQ_TALLIES);\n\n\tif (priv->iw_mode == NL80211_IFTYPE_ADHOC) {\n\t\tmemset(&wstats->qual, 0, sizeof(wstats->qual));\n\t\t \n\t\tif (SPY_NUMBER(priv)) {\n\t\t\twstats->qual.qual = priv->spy_data.spy_stat[0].qual;\n\t\t\twstats->qual.level = priv->spy_data.spy_stat[0].level;\n\t\t\twstats->qual.noise = priv->spy_data.spy_stat[0].noise;\n\t\t\twstats->qual.updated =\n\t\t\t\tpriv->spy_data.spy_stat[0].updated;\n\t\t}\n\t} else {\n\t\tstruct {\n\t\t\t__le16 qual, signal, noise, unused;\n\t\t} __packed cq;\n\n\t\terr = HERMES_READ_RECORD(hw, USER_BAP,\n\t\t\t\t\t HERMES_RID_COMMSQUALITY, &cq);\n\n\t\tif (!err) {\n\t\t\twstats->qual.qual = (int)le16_to_cpu(cq.qual);\n\t\t\twstats->qual.level = (int)le16_to_cpu(cq.signal) - 0x95;\n\t\t\twstats->qual.noise = (int)le16_to_cpu(cq.noise) - 0x95;\n\t\t\twstats->qual.updated =\n\t\t\t\tIW_QUAL_ALL_UPDATED | IW_QUAL_DBM;\n\t\t}\n\t}\n\n\torinoco_unlock(priv, &flags);\n\treturn wstats;\n}\n\n \n \n \n\nstatic int orinoco_ioctl_setwap(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu,\n\t\t\t\tchar *extra)\n{\n\tstruct sockaddr *ap_addr = &wrqu->ap_addr;\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint err = -EINPROGRESS;\t\t \n\tunsigned long flags;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\t \n\tif (is_zero_ether_addr(ap_addr->sa_data) ||\n\t    is_broadcast_ether_addr(ap_addr->sa_data)) {\n\t\tpriv->bssid_fixed = 0;\n\t\teth_zero_addr(priv->desired_bssid);\n\n\t\t \n\t\tif (ap_addr->sa_data[0] == 0) {\n\t\t\t__orinoco_hw_set_wap(priv);\n\t\t\terr = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (priv->firmware_type == FIRMWARE_TYPE_AGERE) {\n\t\tprintk(KERN_WARNING \"%s: Lucent/Agere firmware doesn't \"\n\t\t       \"support manual roaming\\n\",\n\t\t       dev->name);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (priv->iw_mode != NL80211_IFTYPE_STATION) {\n\t\tprintk(KERN_WARNING \"%s: Manual roaming supported only in \"\n\t\t       \"managed mode\\n\", dev->name);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t \n\tif (priv->firmware_type == FIRMWARE_TYPE_INTERSIL &&\n\t    strlen(priv->desired_essid) == 0) {\n\t\tprintk(KERN_WARNING \"%s: Desired ESSID must be set for \"\n\t\t       \"manual roaming\\n\", dev->name);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t \n\tpriv->bssid_fixed = 1;\n\tmemcpy(priv->desired_bssid, &ap_addr->sa_data, ETH_ALEN);\n\n out:\n\torinoco_unlock(priv, &flags);\n\treturn err;\n}\n\nstatic int orinoco_ioctl_getwap(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu,\n\t\t\t\tchar *extra)\n{\n\tstruct sockaddr *ap_addr = &wrqu->ap_addr;\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\n\tint err = 0;\n\tunsigned long flags;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tap_addr->sa_family = ARPHRD_ETHER;\n\terr = orinoco_hw_get_current_bssid(priv, ap_addr->sa_data);\n\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_setiwencode(struct net_device *dev,\n\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t     union iwreq_data *wrqu,\n\t\t\t\t     char *keybuf)\n{\n\tstruct iw_point *erq = &wrqu->encoding;\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint index = (erq->flags & IW_ENCODE_INDEX) - 1;\n\tint setindex = priv->tx_key;\n\tenum orinoco_alg encode_alg = priv->encode_alg;\n\tint restricted = priv->wep_restrict;\n\tint err = -EINPROGRESS;\t\t \n\tunsigned long flags;\n\n\tif (!priv->has_wep)\n\t\treturn -EOPNOTSUPP;\n\n\tif (erq->pointer) {\n\t\t \n\t\tif (erq->length > LARGE_KEY_SIZE)\n\t\t\treturn -E2BIG;\n\n\t\tif ((erq->length > SMALL_KEY_SIZE) && !priv->has_big_wep)\n\t\t\treturn -E2BIG;\n\t}\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\t \n\tif ((priv->has_wpa) && (priv->encode_alg == ORINOCO_ALG_TKIP))\n\t\t(void) orinoco_clear_tkip_key(priv, setindex);\n\n\tif (erq->length > 0) {\n\t\tif ((index < 0) || (index >= ORINOCO_MAX_KEYS))\n\t\t\tindex = priv->tx_key;\n\n\t\t \n\t\tif (encode_alg != ORINOCO_ALG_WEP) {\n\t\t\tsetindex = index;\n\t\t\tencode_alg = ORINOCO_ALG_WEP;\n\t\t}\n\t} else {\n\t\t \n\t\tif ((index < 0) || (index >= ORINOCO_MAX_KEYS)) {\n\t\t\tif ((index != -1) || (erq->flags == 0)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (priv->keys[index].key_len == 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsetindex = index;\n\t\t}\n\t}\n\n\tif (erq->flags & IW_ENCODE_DISABLED)\n\t\tencode_alg = ORINOCO_ALG_NONE;\n\tif (erq->flags & IW_ENCODE_OPEN)\n\t\trestricted = 0;\n\tif (erq->flags & IW_ENCODE_RESTRICTED)\n\t\trestricted = 1;\n\n\tif (erq->pointer && erq->length > 0) {\n\t\terr = orinoco_set_key(priv, index, ORINOCO_ALG_WEP, keybuf,\n\t\t\t\t      erq->length, NULL, 0);\n\t}\n\tpriv->tx_key = setindex;\n\n\t \n\tif ((priv->encode_alg == encode_alg) &&\n\t    (priv->wep_restrict == restricted) &&\n\t    netif_carrier_ok(dev)) {\n\t\terr = __orinoco_hw_setup_wepkeys(priv);\n\t\t \n\t\tgoto out;\n\t}\n\n\tpriv->encode_alg = encode_alg;\n\tpriv->wep_restrict = restricted;\n\n out:\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_getiwencode(struct net_device *dev,\n\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t     union iwreq_data *wrqu,\n\t\t\t\t     char *keybuf)\n{\n\tstruct iw_point *erq = &wrqu->encoding;\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint index = (erq->flags & IW_ENCODE_INDEX) - 1;\n\tunsigned long flags;\n\n\tif (!priv->has_wep)\n\t\treturn -EOPNOTSUPP;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tif ((index < 0) || (index >= ORINOCO_MAX_KEYS))\n\t\tindex = priv->tx_key;\n\n\terq->flags = 0;\n\tif (!priv->encode_alg)\n\t\terq->flags |= IW_ENCODE_DISABLED;\n\terq->flags |= index + 1;\n\n\tif (priv->wep_restrict)\n\t\terq->flags |= IW_ENCODE_RESTRICTED;\n\telse\n\t\terq->flags |= IW_ENCODE_OPEN;\n\n\terq->length = priv->keys[index].key_len;\n\n\tmemcpy(keybuf, priv->keys[index].key, erq->length);\n\n\torinoco_unlock(priv, &flags);\n\treturn 0;\n}\n\nstatic int orinoco_ioctl_setessid(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu,\n\t\t\t\t  char *essidbuf)\n{\n\tstruct iw_point *erq = &wrqu->essid;\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tunsigned long flags;\n\n\t \n\n\t \n\tif (erq->length > IW_ESSID_MAX_SIZE)\n\t\treturn -E2BIG;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\t \n\tmemset(priv->desired_essid, 0, sizeof(priv->desired_essid));\n\n\t \n\tif (erq->flags)\n\t\tmemcpy(priv->desired_essid, essidbuf, erq->length);\n\n\torinoco_unlock(priv, &flags);\n\n\treturn -EINPROGRESS;\t\t \n}\n\nstatic int orinoco_ioctl_getessid(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu,\n\t\t\t\t  char *essidbuf)\n{\n\tstruct iw_point *erq = &wrqu->essid;\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint active;\n\tint err = 0;\n\tunsigned long flags;\n\n\tif (netif_running(dev)) {\n\t\terr = orinoco_hw_get_essid(priv, &active, essidbuf);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terq->length = err;\n\t} else {\n\t\tif (orinoco_lock(priv, &flags) != 0)\n\t\t\treturn -EBUSY;\n\t\tmemcpy(essidbuf, priv->desired_essid, IW_ESSID_MAX_SIZE);\n\t\terq->length = strlen(priv->desired_essid);\n\t\torinoco_unlock(priv, &flags);\n\t}\n\n\terq->flags = 1;\n\n\treturn 0;\n}\n\nstatic int orinoco_ioctl_setfreq(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu,\n\t\t\t\t char *extra)\n{\n\tstruct iw_freq *frq = &wrqu->freq;\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint chan = -1;\n\tunsigned long flags;\n\tint err = -EINPROGRESS;\t\t \n\n\t \n\tif (priv->iw_mode == NL80211_IFTYPE_STATION)\n\t\treturn -EBUSY;\n\n\tif ((frq->e == 0) && (frq->m <= 1000)) {\n\t\t \n\t\tchan = frq->m;\n\t} else {\n\t\t \n\t\tint denom = 1;\n\t\tint i;\n\n\t\t \n\t\tfor (i = 0; i < (6 - frq->e); i++)\n\t\t\tdenom *= 10;\n\n\t\tchan = ieee80211_frequency_to_channel(frq->m / denom);\n\t}\n\n\tif ((chan < 1) || (chan > NUM_CHANNELS) ||\n\t     !(priv->channel_mask & (1 << (chan - 1))))\n\t\treturn -EINVAL;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tpriv->channel = chan;\n\tif (priv->iw_mode == NL80211_IFTYPE_MONITOR) {\n\t\t \n\t\tstruct hermes *hw = &priv->hw;\n\t\terr = hw->ops->cmd_wait(hw, HERMES_CMD_TEST |\n\t\t\t\t\t    HERMES_TEST_SET_CHANNEL,\n\t\t\t\t\tchan, NULL);\n\t}\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_getfreq(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu,\n\t\t\t\t char *extra)\n{\n\tstruct iw_freq *frq = &wrqu->freq;\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint tmp;\n\n\t \n\ttmp = orinoco_hw_get_freq(priv);\n\tif (tmp < 0)\n\t\treturn tmp;\n\n\tfrq->m = tmp * 100000;\n\tfrq->e = 1;\n\n\treturn 0;\n}\n\nstatic int orinoco_ioctl_getsens(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu,\n\t\t\t\t char *extra)\n{\n\tstruct iw_param *srq = &wrqu->sens;\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tstruct hermes *hw = &priv->hw;\n\tu16 val;\n\tint err;\n\tunsigned long flags;\n\n\tif (!priv->has_sensitivity)\n\t\treturn -EOPNOTSUPP;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\terr = hermes_read_wordrec(hw, USER_BAP,\n\t\t\t\t  HERMES_RID_CNFSYSTEMSCALE, &val);\n\torinoco_unlock(priv, &flags);\n\n\tif (err)\n\t\treturn err;\n\n\tsrq->value = val;\n\tsrq->fixed = 0;  \n\n\treturn 0;\n}\n\nstatic int orinoco_ioctl_setsens(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu,\n\t\t\t\t char *extra)\n{\n\tstruct iw_param *srq = &wrqu->sens;\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint val = srq->value;\n\tunsigned long flags;\n\n\tif (!priv->has_sensitivity)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((val < 1) || (val > 3))\n\t\treturn -EINVAL;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tpriv->ap_density = val;\n\torinoco_unlock(priv, &flags);\n\n\treturn -EINPROGRESS;\t\t \n}\n\nstatic int orinoco_ioctl_setrate(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu,\n\t\t\t\t char *extra)\n{\n\tstruct iw_param *rrq = &wrqu->bitrate;\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint ratemode;\n\tint bitrate;  \n\tunsigned long flags;\n\n\t \n\tif (rrq->value == -1)\n\t\tbitrate = 110;\n\telse {\n\t\tif (rrq->value % 100000)\n\t\t\treturn -EINVAL;\n\t\tbitrate = rrq->value / 100000;\n\t}\n\n\tratemode = orinoco_get_bitratemode(bitrate, !rrq->fixed);\n\n\tif (ratemode == -1)\n\t\treturn -EINVAL;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tpriv->bitratemode = ratemode;\n\torinoco_unlock(priv, &flags);\n\n\treturn -EINPROGRESS;\n}\n\nstatic int orinoco_ioctl_getrate(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu,\n\t\t\t\t char *extra)\n{\n\tstruct iw_param *rrq = &wrqu->bitrate;\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint err = 0;\n\tint bitrate, automatic;\n\tunsigned long flags;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\torinoco_get_ratemode_cfg(priv->bitratemode, &bitrate, &automatic);\n\n\t \n\tif (netif_running(dev)) {\n\t\tint act_bitrate;\n\t\tint lerr;\n\n\t\t \n\t\tlerr = orinoco_hw_get_act_bitrate(priv, &act_bitrate);\n\t\tif (!lerr)\n\t\t\tbitrate = act_bitrate;\n\t}\n\n\torinoco_unlock(priv, &flags);\n\n\trrq->value = bitrate;\n\trrq->fixed = !automatic;\n\trrq->disabled = 0;\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_setpower(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu,\n\t\t\t\t  char *extra)\n{\n\tstruct iw_param *prq = &wrqu->power;\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint err = -EINPROGRESS;\t\t \n\tunsigned long flags;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tif (prq->disabled) {\n\t\tpriv->pm_on = 0;\n\t} else {\n\t\tswitch (prq->flags & IW_POWER_MODE) {\n\t\tcase IW_POWER_UNICAST_R:\n\t\t\tpriv->pm_mcast = 0;\n\t\t\tpriv->pm_on = 1;\n\t\t\tbreak;\n\t\tcase IW_POWER_ALL_R:\n\t\t\tpriv->pm_mcast = 1;\n\t\t\tpriv->pm_on = 1;\n\t\t\tbreak;\n\t\tcase IW_POWER_ON:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (prq->flags & IW_POWER_TIMEOUT) {\n\t\t\tpriv->pm_on = 1;\n\t\t\tpriv->pm_timeout = prq->value / 1000;\n\t\t}\n\t\tif (prq->flags & IW_POWER_PERIOD) {\n\t\t\tpriv->pm_on = 1;\n\t\t\tpriv->pm_period = prq->value / 1000;\n\t\t}\n\t\t \n\t\tif (!priv->pm_on) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n out:\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_getpower(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu,\n\t\t\t\t  char *extra)\n{\n\tstruct iw_param *prq = &wrqu->power;\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tstruct hermes *hw = &priv->hw;\n\tint err = 0;\n\tu16 enable, period, timeout, mcast;\n\tunsigned long flags;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\terr = hermes_read_wordrec(hw, USER_BAP,\n\t\t\t\t  HERMES_RID_CNFPMENABLED, &enable);\n\tif (err)\n\t\tgoto out;\n\n\terr = hermes_read_wordrec(hw, USER_BAP,\n\t\t\t\t  HERMES_RID_CNFMAXSLEEPDURATION, &period);\n\tif (err)\n\t\tgoto out;\n\n\terr = hermes_read_wordrec(hw, USER_BAP,\n\t\t\t\t  HERMES_RID_CNFPMHOLDOVERDURATION, &timeout);\n\tif (err)\n\t\tgoto out;\n\n\terr = hermes_read_wordrec(hw, USER_BAP,\n\t\t\t\t  HERMES_RID_CNFMULTICASTRECEIVE, &mcast);\n\tif (err)\n\t\tgoto out;\n\n\tprq->disabled = !enable;\n\t \n\tif ((prq->flags & IW_POWER_TYPE) == IW_POWER_TIMEOUT) {\n\t\tprq->flags = IW_POWER_TIMEOUT;\n\t\tprq->value = timeout * 1000;\n\t} else {\n\t\tprq->flags = IW_POWER_PERIOD;\n\t\tprq->value = period * 1000;\n\t}\n\tif (mcast)\n\t\tprq->flags |= IW_POWER_ALL_R;\n\telse\n\t\tprq->flags |= IW_POWER_UNICAST_R;\n\n out:\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_set_encodeext(struct net_device *dev,\n\t\t\t\t       struct iw_request_info *info,\n\t\t\t\t       union iwreq_data *wrqu,\n\t\t\t\t       char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tstruct iw_point *encoding = &wrqu->encoding;\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\n\tint idx, alg = ext->alg, set_key = 1;\n\tunsigned long flags;\n\tint err = -EINVAL;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\t \n\tidx = encoding->flags & IW_ENCODE_INDEX;\n\tif (idx) {\n\t\tif ((idx < 1) || (idx > 4))\n\t\t\tgoto out;\n\t\tidx--;\n\t} else\n\t\tidx = priv->tx_key;\n\n\tif (encoding->flags & IW_ENCODE_DISABLED)\n\t\talg = IW_ENCODE_ALG_NONE;\n\n\tif (priv->has_wpa && (alg != IW_ENCODE_ALG_TKIP)) {\n\t\t \n\t\t(void) orinoco_clear_tkip_key(priv, priv->tx_key);\n\t}\n\n\tif (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {\n\t\tpriv->tx_key = idx;\n\t\tset_key = ((alg == IW_ENCODE_ALG_TKIP) ||\n\t\t\t   (ext->key_len > 0)) ? 1 : 0;\n\t}\n\n\tif (set_key) {\n\t\t \n\t\tswitch (alg) {\n\t\tcase IW_ENCODE_ALG_NONE:\n\t\t\tpriv->encode_alg = ORINOCO_ALG_NONE;\n\t\t\terr = orinoco_set_key(priv, idx, ORINOCO_ALG_NONE,\n\t\t\t\t\t      NULL, 0, NULL, 0);\n\t\t\tbreak;\n\n\t\tcase IW_ENCODE_ALG_WEP:\n\t\t\tif (ext->key_len <= 0)\n\t\t\t\tgoto out;\n\n\t\t\tpriv->encode_alg = ORINOCO_ALG_WEP;\n\t\t\terr = orinoco_set_key(priv, idx, ORINOCO_ALG_WEP,\n\t\t\t\t\t      ext->key, ext->key_len, NULL, 0);\n\t\t\tbreak;\n\n\t\tcase IW_ENCODE_ALG_TKIP:\n\t\t{\n\t\t\tu8 *tkip_iv = NULL;\n\n\t\t\tif (!priv->has_wpa ||\n\t\t\t    (ext->key_len > sizeof(struct orinoco_tkip_key)))\n\t\t\t\tgoto out;\n\n\t\t\tpriv->encode_alg = ORINOCO_ALG_TKIP;\n\n\t\t\tif (ext->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID)\n\t\t\t\ttkip_iv = &ext->rx_seq[0];\n\n\t\t\terr = orinoco_set_key(priv, idx, ORINOCO_ALG_TKIP,\n\t\t\t\t\t      ext->key, ext->key_len, tkip_iv,\n\t\t\t\t\t      ORINOCO_SEQ_LEN);\n\n\t\t\terr = __orinoco_hw_set_tkip_key(priv, idx,\n\t\t\t\t ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY,\n\t\t\t\t priv->keys[idx].key, priv->keys[idx].key_len,\n\t\t\t\t tkip_iv, ORINOCO_SEQ_LEN, NULL, 0);\n\t\t\tif (err)\n\t\t\t\tprintk(KERN_ERR \"%s: Error %d setting TKIP key\"\n\t\t\t\t       \"\\n\", dev->name, err);\n\n\t\t\tgoto out;\n\t\t}\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t}\n\terr = -EINPROGRESS;\n out:\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_get_encodeext(struct net_device *dev,\n\t\t\t\t       struct iw_request_info *info,\n\t\t\t\t       union iwreq_data *wrqu,\n\t\t\t\t       char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tstruct iw_point *encoding = &wrqu->encoding;\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\n\tint idx, max_key_len;\n\tunsigned long flags;\n\tint err;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\terr = -EINVAL;\n\tmax_key_len = encoding->length - sizeof(*ext);\n\tif (max_key_len < 0)\n\t\tgoto out;\n\n\tidx = encoding->flags & IW_ENCODE_INDEX;\n\tif (idx) {\n\t\tif ((idx < 1) || (idx > 4))\n\t\t\tgoto out;\n\t\tidx--;\n\t} else\n\t\tidx = priv->tx_key;\n\n\tencoding->flags = idx + 1;\n\tmemset(ext, 0, sizeof(*ext));\n\n\tswitch (priv->encode_alg) {\n\tcase ORINOCO_ALG_NONE:\n\t\text->alg = IW_ENCODE_ALG_NONE;\n\t\text->key_len = 0;\n\t\tencoding->flags |= IW_ENCODE_DISABLED;\n\t\tbreak;\n\tcase ORINOCO_ALG_WEP:\n\t\text->alg = IW_ENCODE_ALG_WEP;\n\t\text->key_len = min(priv->keys[idx].key_len, max_key_len);\n\t\tmemcpy(ext->key, priv->keys[idx].key, ext->key_len);\n\t\tencoding->flags |= IW_ENCODE_ENABLED;\n\t\tbreak;\n\tcase ORINOCO_ALG_TKIP:\n\t\text->alg = IW_ENCODE_ALG_TKIP;\n\t\text->key_len = min(priv->keys[idx].key_len, max_key_len);\n\t\tmemcpy(ext->key, priv->keys[idx].key, ext->key_len);\n\t\tencoding->flags |= IW_ENCODE_ENABLED;\n\t\tbreak;\n\t}\n\n\terr = 0;\n out:\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_set_auth(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tstruct hermes *hw = &priv->hw;\n\tstruct iw_param *param = &wrqu->param;\n\tunsigned long flags;\n\tint ret = -EINPROGRESS;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\t \n\t\tbreak;\n\n\tcase IW_AUTH_MFP:\n\t\t \n\t\tif (param->value == IW_AUTH_MFP_REQUIRED)\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\n\tcase IW_AUTH_KEY_MGMT:\n\t\t \n\t\tpriv->key_mgmt = param->value;\n\t\tbreak;\n\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\t \n\t\tif (param->value) {\n\t\t\tpriv->tkip_cm_active = 1;\n\t\t\tret = hermes_disable_port(hw, 0);\n\t\t} else {\n\t\t\tpriv->tkip_cm_active = 0;\n\t\t\tret = hermes_enable_port(hw, 0);\n\t\t}\n\t\tbreak;\n\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tif (param->value & IW_AUTH_ALG_SHARED_KEY)\n\t\t\tpriv->wep_restrict = 1;\n\t\telse if (param->value & IW_AUTH_ALG_OPEN_SYSTEM)\n\t\t\tpriv->wep_restrict = 0;\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tif (priv->has_wpa) {\n\t\t\tpriv->wpa_enabled = param->value ? 1 : 0;\n\t\t} else {\n\t\t\tif (param->value)\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t \n\t\t\tpriv->wpa_enabled = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\torinoco_unlock(priv, &flags);\n\treturn ret;\n}\n\nstatic int orinoco_ioctl_get_auth(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tstruct iw_param *param = &wrqu->param;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_KEY_MGMT:\n\t\tparam->value = priv->key_mgmt;\n\t\tbreak;\n\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\tparam->value = priv->tkip_cm_active;\n\t\tbreak;\n\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tif (priv->wep_restrict)\n\t\t\tparam->value = IW_AUTH_ALG_SHARED_KEY;\n\t\telse\n\t\t\tparam->value = IW_AUTH_ALG_OPEN_SYSTEM;\n\t\tbreak;\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tparam->value = priv->wpa_enabled;\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\torinoco_unlock(priv, &flags);\n\treturn ret;\n}\n\nstatic int orinoco_ioctl_set_genie(struct net_device *dev,\n\t\t\t\t   struct iw_request_info *info,\n\t\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tu8 *buf;\n\tunsigned long flags;\n\n\t \n\tif ((wrqu->data.length > IEEE80211_MAX_DATA_LEN) ||\n\t    (wrqu->data.length && (extra == NULL)))\n\t\treturn -EINVAL;\n\n\tif (wrqu->data.length) {\n\t\tbuf = kmemdup(extra, wrqu->data.length, GFP_KERNEL);\n\t\tif (buf == NULL)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tbuf = NULL;\n\n\tif (orinoco_lock(priv, &flags) != 0) {\n\t\tkfree(buf);\n\t\treturn -EBUSY;\n\t}\n\n\tkfree(priv->wpa_ie);\n\tpriv->wpa_ie = buf;\n\tpriv->wpa_ie_len = wrqu->data.length;\n\n\tif (priv->wpa_ie) {\n\t\t \n\t}\n\n\torinoco_unlock(priv, &flags);\n\treturn 0;\n}\n\nstatic int orinoco_ioctl_get_genie(struct net_device *dev,\n\t\t\t\t   struct iw_request_info *info,\n\t\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tunsigned long flags;\n\tint err = 0;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tif ((priv->wpa_ie_len == 0) || (priv->wpa_ie == NULL)) {\n\t\twrqu->data.length = 0;\n\t\tgoto out;\n\t}\n\n\tif (wrqu->data.length < priv->wpa_ie_len) {\n\t\terr = -E2BIG;\n\t\tgoto out;\n\t}\n\n\twrqu->data.length = priv->wpa_ie_len;\n\tmemcpy(extra, priv->wpa_ie, priv->wpa_ie_len);\n\nout:\n\torinoco_unlock(priv, &flags);\n\treturn err;\n}\n\nstatic int orinoco_ioctl_set_mlme(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tstruct iw_mlme *mlme = (struct iw_mlme *)extra;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tswitch (mlme->cmd) {\n\tcase IW_MLME_DEAUTH:\n\t\t \n\t\tbreak;\n\n\tcase IW_MLME_DISASSOC:\n\n\t\tret = orinoco_hw_disassociate(priv, mlme->addr.sa_data,\n\t\t\t\t\t      mlme->reason_code);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\torinoco_unlock(priv, &flags);\n\treturn ret;\n}\n\nstatic int orinoco_ioctl_reset(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu,\n\t\t\t       char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (info->cmd == (SIOCIWFIRSTPRIV + 0x1)) {\n\t\tprintk(KERN_DEBUG \"%s: Forcing reset!\\n\", dev->name);\n\n\t\t \n\t\torinoco_reset(&priv->reset_work);\n\t} else {\n\t\tprintk(KERN_DEBUG \"%s: Force scheduling reset!\\n\", dev->name);\n\n\t\tschedule_work(&priv->reset_work);\n\t}\n\n\treturn 0;\n}\n\nstatic int orinoco_ioctl_setibssport(struct net_device *dev,\n\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t     union iwreq_data *wrqu,\n\t\t\t\t     char *extra)\n\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint val = *((int *) extra);\n\tunsigned long flags;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tpriv->ibss_port = val;\n\n\t \n\tset_port_type(priv);\n\n\torinoco_unlock(priv, &flags);\n\treturn -EINPROGRESS;\t\t \n}\n\nstatic int orinoco_ioctl_getibssport(struct net_device *dev,\n\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t     union iwreq_data *wrqu,\n\t\t\t\t     char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint *val = (int *) extra;\n\n\t*val = priv->ibss_port;\n\treturn 0;\n}\n\nstatic int orinoco_ioctl_setport3(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu,\n\t\t\t\t  char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint val = *((int *) extra);\n\tint err = 0;\n\tunsigned long flags;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tswitch (val) {\n\tcase 0:  \n\t\tif (!priv->has_ibss) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tpriv->prefer_port3 = 0;\n\n\t\tbreak;\n\n\tcase 1:  \n\t\tif (!priv->has_port3) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tpriv->prefer_port3 = 1;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\n\tif (!err) {\n\t\t \n\t\tset_port_type(priv);\n\t\terr = -EINPROGRESS;\n\t}\n\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\n\nstatic int orinoco_ioctl_getport3(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu,\n\t\t\t\t  char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint *val = (int *) extra;\n\n\t*val = priv->prefer_port3;\n\treturn 0;\n}\n\nstatic int orinoco_ioctl_setpreamble(struct net_device *dev,\n\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t     union iwreq_data *wrqu,\n\t\t\t\t     char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tunsigned long flags;\n\tint val;\n\n\tif (!priv->has_preamble)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tval = *((int *) extra);\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tif (val)\n\t\tpriv->preamble = 1;\n\telse\n\t\tpriv->preamble = 0;\n\n\torinoco_unlock(priv, &flags);\n\n\treturn -EINPROGRESS;\t\t \n}\n\nstatic int orinoco_ioctl_getpreamble(struct net_device *dev,\n\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t     union iwreq_data *wrqu,\n\t\t\t\t     char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint *val = (int *) extra;\n\n\tif (!priv->has_preamble)\n\t\treturn -EOPNOTSUPP;\n\n\t*val = priv->preamble;\n\treturn 0;\n}\n\n \nstatic int orinoco_ioctl_getrid(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu,\n\t\t\t\tchar *extra)\n{\n\tstruct iw_point *data = &wrqu->data;\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tstruct hermes *hw = &priv->hw;\n\tint rid = data->flags;\n\tu16 length;\n\tint err;\n\tunsigned long flags;\n\n\t \n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (rid < 0xfc00 || rid > 0xffff)\n\t\treturn -EINVAL;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\terr = hw->ops->read_ltv(hw, USER_BAP, rid, MAX_RID_LEN, &length,\n\t\t\t\textra);\n\tif (err)\n\t\tgoto out;\n\n\tdata->length = min_t(u16, HERMES_RECLEN_TO_BYTES(length),\n\t\t\t     MAX_RID_LEN);\n\n out:\n\torinoco_unlock(priv, &flags);\n\treturn err;\n}\n\n\n \nstatic int orinoco_ioctl_commit(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu,\n\t\t\t\tchar *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tunsigned long flags;\n\tint err = 0;\n\n\tif (!priv->open)\n\t\treturn 0;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn err;\n\n\terr = orinoco_commit(priv);\n\n\torinoco_unlock(priv, &flags);\n\treturn err;\n}\n\nstatic const struct iw_priv_args orinoco_privtab[] = {\n\t{ SIOCIWFIRSTPRIV + 0x0, 0, 0, \"force_reset\" },\n\t{ SIOCIWFIRSTPRIV + 0x1, 0, 0, \"card_reset\" },\n\t{ SIOCIWFIRSTPRIV + 0x2, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t  0, \"set_port3\" },\n\t{ SIOCIWFIRSTPRIV + 0x3, 0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t  \"get_port3\" },\n\t{ SIOCIWFIRSTPRIV + 0x4, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t  0, \"set_preamble\" },\n\t{ SIOCIWFIRSTPRIV + 0x5, 0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t  \"get_preamble\" },\n\t{ SIOCIWFIRSTPRIV + 0x6, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t  0, \"set_ibssport\" },\n\t{ SIOCIWFIRSTPRIV + 0x7, 0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t  \"get_ibssport\" },\n\t{ SIOCIWFIRSTPRIV + 0x9, 0, IW_PRIV_TYPE_BYTE | MAX_RID_LEN,\n\t  \"get_rid\" },\n};\n\n\n \n\nstatic const iw_handler\torinoco_handler[] = {\n\tIW_HANDLER(SIOCSIWCOMMIT,\torinoco_ioctl_commit),\n\tIW_HANDLER(SIOCGIWNAME,\t\tcfg80211_wext_giwname),\n\tIW_HANDLER(SIOCSIWFREQ,\t\torinoco_ioctl_setfreq),\n\tIW_HANDLER(SIOCGIWFREQ,\t\torinoco_ioctl_getfreq),\n\tIW_HANDLER(SIOCSIWMODE,\t\tcfg80211_wext_siwmode),\n\tIW_HANDLER(SIOCGIWMODE,\t\tcfg80211_wext_giwmode),\n\tIW_HANDLER(SIOCSIWSENS,\t\torinoco_ioctl_setsens),\n\tIW_HANDLER(SIOCGIWSENS,\t\torinoco_ioctl_getsens),\n\tIW_HANDLER(SIOCGIWRANGE,\tcfg80211_wext_giwrange),\n\tIW_HANDLER(SIOCSIWSPY,\t\tiw_handler_set_spy),\n\tIW_HANDLER(SIOCGIWSPY,\t\tiw_handler_get_spy),\n\tIW_HANDLER(SIOCSIWTHRSPY,\tiw_handler_set_thrspy),\n\tIW_HANDLER(SIOCGIWTHRSPY,\tiw_handler_get_thrspy),\n\tIW_HANDLER(SIOCSIWAP,\t\torinoco_ioctl_setwap),\n\tIW_HANDLER(SIOCGIWAP,\t\torinoco_ioctl_getwap),\n\tIW_HANDLER(SIOCSIWSCAN,\t\tcfg80211_wext_siwscan),\n\tIW_HANDLER(SIOCGIWSCAN,\t\tcfg80211_wext_giwscan),\n\tIW_HANDLER(SIOCSIWESSID,\torinoco_ioctl_setessid),\n\tIW_HANDLER(SIOCGIWESSID,\torinoco_ioctl_getessid),\n\tIW_HANDLER(SIOCSIWRATE,\t\torinoco_ioctl_setrate),\n\tIW_HANDLER(SIOCGIWRATE,\t\torinoco_ioctl_getrate),\n\tIW_HANDLER(SIOCSIWRTS,\t\tcfg80211_wext_siwrts),\n\tIW_HANDLER(SIOCGIWRTS,\t\tcfg80211_wext_giwrts),\n\tIW_HANDLER(SIOCSIWFRAG,\t\tcfg80211_wext_siwfrag),\n\tIW_HANDLER(SIOCGIWFRAG,\t\tcfg80211_wext_giwfrag),\n\tIW_HANDLER(SIOCGIWRETRY,\tcfg80211_wext_giwretry),\n\tIW_HANDLER(SIOCSIWENCODE,\torinoco_ioctl_setiwencode),\n\tIW_HANDLER(SIOCGIWENCODE,\torinoco_ioctl_getiwencode),\n\tIW_HANDLER(SIOCSIWPOWER,\torinoco_ioctl_setpower),\n\tIW_HANDLER(SIOCGIWPOWER,\torinoco_ioctl_getpower),\n\tIW_HANDLER(SIOCSIWGENIE,\torinoco_ioctl_set_genie),\n\tIW_HANDLER(SIOCGIWGENIE,\torinoco_ioctl_get_genie),\n\tIW_HANDLER(SIOCSIWMLME,\t\torinoco_ioctl_set_mlme),\n\tIW_HANDLER(SIOCSIWAUTH,\t\torinoco_ioctl_set_auth),\n\tIW_HANDLER(SIOCGIWAUTH,\t\torinoco_ioctl_get_auth),\n\tIW_HANDLER(SIOCSIWENCODEEXT,\torinoco_ioctl_set_encodeext),\n\tIW_HANDLER(SIOCGIWENCODEEXT,\torinoco_ioctl_get_encodeext),\n};\n\n\n \nstatic const iw_handler\torinoco_private_handler[] = {\n\t[0] = orinoco_ioctl_reset,\n\t[1] = orinoco_ioctl_reset,\n\t[2] = orinoco_ioctl_setport3,\n\t[3] = orinoco_ioctl_getport3,\n\t[4] = orinoco_ioctl_setpreamble,\n\t[5] = orinoco_ioctl_getpreamble,\n\t[6] = orinoco_ioctl_setibssport,\n\t[7] = orinoco_ioctl_getibssport,\n\t[9] = orinoco_ioctl_getrid,\n};\n\nconst struct iw_handler_def orinoco_handler_def = {\n\t.num_standard = ARRAY_SIZE(orinoco_handler),\n\t.num_private = ARRAY_SIZE(orinoco_private_handler),\n\t.num_private_args = ARRAY_SIZE(orinoco_privtab),\n\t.standard = orinoco_handler,\n\t.private = orinoco_private_handler,\n\t.private_args = orinoco_privtab,\n\t.get_wireless_stats = orinoco_get_wireless_stats,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}