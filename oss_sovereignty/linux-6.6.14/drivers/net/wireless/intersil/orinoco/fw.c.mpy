{
  "module_name": "fw.c",
  "hash_id": "fbf6bb79b56a6cca6ad8aeba8adf683bc5e7a6997d432ec9aa206be72c33fc3b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/orinoco/fw.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/firmware.h>\n#include <linux/device.h>\n#include <linux/module.h>\n\n#include \"hermes.h\"\n#include \"hermes_dld.h\"\n#include \"orinoco.h\"\n\n#include \"fw.h\"\n\n \n#define TEXT_END\t0x1A\t\t \n\nstruct fw_info {\n\tchar *pri_fw;\n\tchar *sta_fw;\n\tchar *ap_fw;\n\tu32 pda_addr;\n\tu16 pda_size;\n};\n\nstatic const struct fw_info orinoco_fw[] = {\n\t{ NULL, \"agere_sta_fw.bin\", \"agere_ap_fw.bin\", 0x00390000, 1000 },\n\t{ NULL, \"prism_sta_fw.bin\", \"prism_ap_fw.bin\", 0, 1024 },\n\t{ \"symbol_sp24t_prim_fw\", \"symbol_sp24t_sec_fw\", NULL, 0x00003100, 512 }\n};\nMODULE_FIRMWARE(\"agere_sta_fw.bin\");\nMODULE_FIRMWARE(\"agere_ap_fw.bin\");\nMODULE_FIRMWARE(\"prism_sta_fw.bin\");\nMODULE_FIRMWARE(\"prism_ap_fw.bin\");\nMODULE_FIRMWARE(\"symbol_sp24t_prim_fw\");\nMODULE_FIRMWARE(\"symbol_sp24t_sec_fw\");\n\n \nstruct orinoco_fw_header {\n\tchar hdr_vers[6];        \n\t__le16 headersize;       \n\t__le32 entry_point;      \n\t__le32 blocks;           \n\t__le32 block_offset;     \n\t__le32 pdr_offset;       \n\t__le32 pri_offset;       \n\t__le32 compat_offset;    \n\tchar signature[];       \n} __packed;\n\n \nstatic const char *validate_fw(const struct orinoco_fw_header *hdr, size_t len)\n{\n\tu16 hdrsize;\n\n\tif (len < sizeof(*hdr))\n\t\treturn \"image too small\";\n\tif (memcmp(hdr->hdr_vers, \"HFW\", 3) != 0)\n\t\treturn \"format not recognised\";\n\n\thdrsize = le16_to_cpu(hdr->headersize);\n\tif (hdrsize > len)\n\t\treturn \"bad headersize\";\n\tif ((hdrsize + le32_to_cpu(hdr->block_offset)) > len)\n\t\treturn \"bad block offset\";\n\tif ((hdrsize + le32_to_cpu(hdr->pdr_offset)) > len)\n\t\treturn \"bad PDR offset\";\n\tif ((hdrsize + le32_to_cpu(hdr->pri_offset)) > len)\n\t\treturn \"bad PRI offset\";\n\tif ((hdrsize + le32_to_cpu(hdr->compat_offset)) > len)\n\t\treturn \"bad compat offset\";\n\n\t \n\treturn NULL;\n}\n\n#if defined(CONFIG_HERMES_CACHE_FW_ON_INIT) || defined(CONFIG_PM_SLEEP)\nstatic inline const struct firmware *\norinoco_cached_fw_get(struct orinoco_private *priv, bool primary)\n{\n\tif (primary)\n\t\treturn priv->cached_pri_fw;\n\telse\n\t\treturn priv->cached_fw;\n}\n#else\n#define orinoco_cached_fw_get(priv, primary) (NULL)\n#endif\n\n \nstatic int\norinoco_dl_firmware(struct orinoco_private *priv,\n\t\t    const struct fw_info *fw,\n\t\t    int ap)\n{\n\t \n\t__le16 *pda;\n\n\tstruct hermes *hw = &priv->hw;\n\tconst struct firmware *fw_entry;\n\tconst struct orinoco_fw_header *hdr;\n\tconst unsigned char *first_block;\n\tconst void *end;\n\tconst char *firmware;\n\tconst char *fw_err;\n\tstruct device *dev = priv->dev;\n\tint err = 0;\n\n\tpda = kzalloc(fw->pda_size, GFP_KERNEL);\n\tif (!pda)\n\t\treturn -ENOMEM;\n\n\tif (ap)\n\t\tfirmware = fw->ap_fw;\n\telse\n\t\tfirmware = fw->sta_fw;\n\n\tdev_dbg(dev, \"Attempting to download firmware %s\\n\", firmware);\n\n\t \n\terr = hw->ops->read_pda(hw, pda, fw->pda_addr, fw->pda_size);\n\tdev_dbg(dev, \"Read PDA returned %d\\n\", err);\n\tif (err)\n\t\tgoto free;\n\n\tif (!orinoco_cached_fw_get(priv, false)) {\n\t\terr = request_firmware(&fw_entry, firmware, priv->dev);\n\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Cannot find firmware %s\\n\", firmware);\n\t\t\terr = -ENOENT;\n\t\t\tgoto free;\n\t\t}\n\t} else\n\t\tfw_entry = orinoco_cached_fw_get(priv, false);\n\n\thdr = (const struct orinoco_fw_header *) fw_entry->data;\n\n\tfw_err = validate_fw(hdr, fw_entry->size);\n\tif (fw_err) {\n\t\tdev_warn(dev, \"Invalid firmware image detected (%s). \"\n\t\t\t \"Aborting download\\n\", fw_err);\n\t\terr = -EINVAL;\n\t\tgoto abort;\n\t}\n\n\t \n\terr = hw->ops->program_init(hw, le32_to_cpu(hdr->entry_point));\n\tdev_dbg(dev, \"Program init returned %d\\n\", err);\n\tif (err != 0)\n\t\tgoto abort;\n\n\t \n\tfirst_block = (fw_entry->data +\n\t\t       le16_to_cpu(hdr->headersize) +\n\t\t       le32_to_cpu(hdr->block_offset));\n\tend = fw_entry->data + fw_entry->size;\n\n\terr = hermes_program(hw, first_block, end);\n\tdev_dbg(dev, \"Program returned %d\\n\", err);\n\tif (err != 0)\n\t\tgoto abort;\n\n\t \n\tfirst_block = (fw_entry->data +\n\t\t       le16_to_cpu(hdr->headersize) +\n\t\t       le32_to_cpu(hdr->pdr_offset));\n\n\terr = hermes_apply_pda_with_defaults(hw, first_block, end, pda,\n\t\t\t\t\t     &pda[fw->pda_size / sizeof(*pda)]);\n\tdev_dbg(dev, \"Apply PDA returned %d\\n\", err);\n\tif (err)\n\t\tgoto abort;\n\n\t \n\terr = hw->ops->program_end(hw);\n\tdev_dbg(dev, \"Program end returned %d\\n\", err);\n\tif (err != 0)\n\t\tgoto abort;\n\n\t \n\tdev_dbg(dev, \"hermes_present returned %d\\n\", hermes_present(hw));\n\nabort:\n\t \n\tif (!orinoco_cached_fw_get(priv, false))\n\t\trelease_firmware(fw_entry);\n\nfree:\n\tkfree(pda);\n\treturn err;\n}\n\n \nstatic int\nsymbol_dl_image(struct orinoco_private *priv, const struct fw_info *fw,\n\t\tconst unsigned char *image, const void *end,\n\t\tint secondary)\n{\n\tstruct hermes *hw = &priv->hw;\n\tint ret = 0;\n\tconst unsigned char *ptr;\n\tconst unsigned char *first_block;\n\n\t \n\t__le16 *pda = NULL;\n\n\t \n\tptr = image;\n\twhile (*ptr++ != TEXT_END);\n\tfirst_block = ptr;\n\n\t \n\tif (secondary) {\n\t\tpda = kzalloc(fw->pda_size, GFP_KERNEL);\n\t\tif (!pda)\n\t\t\treturn -ENOMEM;\n\n\t\tret = hw->ops->read_pda(hw, pda, fw->pda_addr, fw->pda_size);\n\t\tif (ret)\n\t\t\tgoto free;\n\t}\n\n\t \n\tif (priv->stop_fw) {\n\t\tret = priv->stop_fw(priv, 1);\n\t\tif (ret)\n\t\t\tgoto free;\n\t}\n\n\t \n\tret = hermes_program(hw, first_block, end);\n\tif (ret)\n\t\tgoto free;\n\n\t \n\tif (secondary) {\n\t\tsize_t len = hermes_blocks_length(first_block, end);\n\t\tptr = first_block + len;\n\t\tret = hermes_apply_pda(hw, ptr, end, pda,\n\t\t\t\t       &pda[fw->pda_size / sizeof(*pda)]);\n\t\tkfree(pda);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (priv->stop_fw) {\n\t\tret = priv->stop_fw(priv, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = hw->ops->init(hw);\n\n\t \n\tif (secondary && ret != 0)\n\t\treturn -ENODEV;\n\n\t \n\tif (!hermes_present(hw))\n\t\treturn -ENODEV;\n\n\treturn 0;\n\nfree:\n\tkfree(pda);\n\treturn ret;\n}\n\n\n \nstatic int\nsymbol_dl_firmware(struct orinoco_private *priv,\n\t\t   const struct fw_info *fw)\n{\n\tstruct device *dev = priv->dev;\n\tint ret;\n\tconst struct firmware *fw_entry;\n\n\tif (!orinoco_cached_fw_get(priv, true)) {\n\t\tif (request_firmware(&fw_entry, fw->pri_fw, priv->dev) != 0) {\n\t\t\tdev_err(dev, \"Cannot find firmware: %s\\n\", fw->pri_fw);\n\t\t\treturn -ENOENT;\n\t\t}\n\t} else\n\t\tfw_entry = orinoco_cached_fw_get(priv, true);\n\n\t \n\tret = symbol_dl_image(priv, fw, fw_entry->data,\n\t\t\t      fw_entry->data + fw_entry->size, 0);\n\n\tif (!orinoco_cached_fw_get(priv, true))\n\t\trelease_firmware(fw_entry);\n\tif (ret) {\n\t\tdev_err(dev, \"Primary firmware download failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!orinoco_cached_fw_get(priv, false)) {\n\t\tif (request_firmware(&fw_entry, fw->sta_fw, priv->dev) != 0) {\n\t\t\tdev_err(dev, \"Cannot find firmware: %s\\n\", fw->sta_fw);\n\t\t\treturn -ENOENT;\n\t\t}\n\t} else\n\t\tfw_entry = orinoco_cached_fw_get(priv, false);\n\n\t \n\tret = symbol_dl_image(priv, fw, fw_entry->data,\n\t\t\t      fw_entry->data + fw_entry->size, 1);\n\tif (!orinoco_cached_fw_get(priv, false))\n\t\trelease_firmware(fw_entry);\n\tif (ret)\n\t\tdev_err(dev, \"Secondary firmware download failed\\n\");\n\n\treturn ret;\n}\n\nint orinoco_download(struct orinoco_private *priv)\n{\n\tint err = 0;\n\t \n\tswitch (priv->firmware_type) {\n\tcase FIRMWARE_TYPE_AGERE:\n\t\t \n\t\terr = orinoco_dl_firmware(priv,\n\t\t\t\t\t  &orinoco_fw[priv->firmware_type], 0);\n\t\tbreak;\n\n\tcase FIRMWARE_TYPE_SYMBOL:\n\t\terr = symbol_dl_firmware(priv,\n\t\t\t\t\t &orinoco_fw[priv->firmware_type]);\n\t\tbreak;\n\tcase FIRMWARE_TYPE_INTERSIL:\n\t\tbreak;\n\t}\n\t \n\n\treturn err;\n}\n\n#if defined(CONFIG_HERMES_CACHE_FW_ON_INIT) || defined(CONFIG_PM_SLEEP)\nvoid orinoco_cache_fw(struct orinoco_private *priv, int ap)\n{\n\tconst struct firmware *fw_entry = NULL;\n\tconst char *pri_fw;\n\tconst char *fw;\n\n\tpri_fw = orinoco_fw[priv->firmware_type].pri_fw;\n\tif (ap)\n\t\tfw = orinoco_fw[priv->firmware_type].ap_fw;\n\telse\n\t\tfw = orinoco_fw[priv->firmware_type].sta_fw;\n\n\tif (pri_fw) {\n\t\tif (request_firmware(&fw_entry, pri_fw, priv->dev) == 0)\n\t\t\tpriv->cached_pri_fw = fw_entry;\n\t}\n\n\tif (fw) {\n\t\tif (request_firmware(&fw_entry, fw, priv->dev) == 0)\n\t\t\tpriv->cached_fw = fw_entry;\n\t}\n}\n\nvoid orinoco_uncache_fw(struct orinoco_private *priv)\n{\n\trelease_firmware(priv->cached_pri_fw);\n\trelease_firmware(priv->cached_fw);\n\tpriv->cached_pri_fw = NULL;\n\tpriv->cached_fw = NULL;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}