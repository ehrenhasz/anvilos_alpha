{
  "module_name": "scan.c",
  "hash_id": "531026a13c4d3a7e0259cf1cd97b2f60cb17c8cd989bfae93ad07bc6c82cb617",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/orinoco/scan.c",
  "human_readable_source": " \n\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ieee80211.h>\n#include <net/cfg80211.h>\n\n#include \"hermes.h\"\n#include \"orinoco.h\"\n#include \"main.h\"\n\n#include \"scan.h\"\n\n#define ZERO_DBM_OFFSET 0x95\n#define MAX_SIGNAL_LEVEL 0x8A\n#define MIN_SIGNAL_LEVEL 0x2F\n\n#define SIGNAL_TO_DBM(x)\t\t\t\t\t\\\n\t(clamp_t(s32, (x), MIN_SIGNAL_LEVEL, MAX_SIGNAL_LEVEL)\t\\\n\t - ZERO_DBM_OFFSET)\n#define SIGNAL_TO_MBM(x) (SIGNAL_TO_DBM(x) * 100)\n\nstatic int symbol_build_supp_rates(u8 *buf, const __le16 *rates)\n{\n\tint i;\n\tu8 rate;\n\n\tbuf[0] = WLAN_EID_SUPP_RATES;\n\tfor (i = 0; i < 5; i++) {\n\t\trate = le16_to_cpu(rates[i]);\n\t\t \n\t\tif (rate == 0x0)\n\t\t\tbreak;\n\t\tbuf[i + 2] = rate;\n\t}\n\tbuf[1] = i;\n\n\treturn i + 2;\n}\n\nstatic int prism_build_supp_rates(u8 *buf, const u8 *rates)\n{\n\tint i;\n\n\tbuf[0] = WLAN_EID_SUPP_RATES;\n\tfor (i = 0; i < 8; i++) {\n\t\t \n\t\tif (rates[i] == 0x0)\n\t\t\tbreak;\n\t\tbuf[i + 2] = rates[i];\n\t}\n\tbuf[1] = i;\n\n\t \n\tif (i == 8 && rates[i] > 0) {\n\t\tbuf[10] = WLAN_EID_EXT_SUPP_RATES;\n\t\tfor (; i < 10; i++) {\n\t\t\t \n\t\t\tif (rates[i] == 0x0)\n\t\t\t\tbreak;\n\t\t\tbuf[i + 2] = rates[i];\n\t\t}\n\t\tbuf[11] = i - 8;\n\t}\n\n\treturn (i < 8) ? i + 2 : i + 4;\n}\n\nstatic void orinoco_add_hostscan_result(struct orinoco_private *priv,\n\t\t\t\t\tconst union hermes_scan_info *bss)\n{\n\tstruct wiphy *wiphy = priv_to_wiphy(priv);\n\tstruct ieee80211_channel *channel;\n\tstruct cfg80211_bss *cbss;\n\tu8 *ie;\n\tu8 ie_buf[46];\n\tu64 timestamp;\n\ts32 signal;\n\tu16 capability;\n\tu16 beacon_interval;\n\tint ie_len;\n\tint freq;\n\tint len;\n\n\tlen = le16_to_cpu(bss->a.essid_len);\n\n\t \n\tie_buf[0] = WLAN_EID_SSID;\n\tie_buf[1] = len;\n\tmemcpy(&ie_buf[2], bss->a.essid, len);\n\n\tie = ie_buf + len + 2;\n\tie_len = ie_buf[1] + 2;\n\tswitch (priv->firmware_type) {\n\tcase FIRMWARE_TYPE_SYMBOL:\n\t\tie_len += symbol_build_supp_rates(ie, bss->s.rates);\n\t\tbreak;\n\n\tcase FIRMWARE_TYPE_INTERSIL:\n\t\tie_len += prism_build_supp_rates(ie, bss->p.rates);\n\t\tbreak;\n\n\tcase FIRMWARE_TYPE_AGERE:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfreq = ieee80211_channel_to_frequency(\n\t\tle16_to_cpu(bss->a.channel), NL80211_BAND_2GHZ);\n\tchannel = ieee80211_get_channel(wiphy, freq);\n\tif (!channel) {\n\t\tprintk(KERN_DEBUG \"Invalid channel designation %04X(%04X)\",\n\t\t\tbss->a.channel, freq);\n\t\treturn;\t \n\t}\n\ttimestamp = 0;\n\tcapability = le16_to_cpu(bss->a.capabilities);\n\tbeacon_interval = le16_to_cpu(bss->a.beacon_interv);\n\tsignal = SIGNAL_TO_MBM(le16_to_cpu(bss->a.level));\n\n\tcbss = cfg80211_inform_bss(wiphy, channel, CFG80211_BSS_FTYPE_UNKNOWN,\n\t\t\t\t   bss->a.bssid, timestamp, capability,\n\t\t\t\t   beacon_interval, ie_buf, ie_len, signal,\n\t\t\t\t   GFP_KERNEL);\n\tcfg80211_put_bss(wiphy, cbss);\n}\n\nvoid orinoco_add_extscan_result(struct orinoco_private *priv,\n\t\t\t\tstruct agere_ext_scan_info *bss,\n\t\t\t\tsize_t len)\n{\n\tstruct wiphy *wiphy = priv_to_wiphy(priv);\n\tstruct ieee80211_channel *channel;\n\tstruct cfg80211_bss *cbss;\n\tconst u8 *ie;\n\tu64 timestamp;\n\ts32 signal;\n\tu16 capability;\n\tu16 beacon_interval;\n\tsize_t ie_len;\n\tint chan, freq;\n\n\tie_len = len - sizeof(*bss);\n\tie = cfg80211_find_ie(WLAN_EID_DS_PARAMS, bss->data, ie_len);\n\tchan = ie ? ie[2] : 0;\n\tfreq = ieee80211_channel_to_frequency(chan, NL80211_BAND_2GHZ);\n\tchannel = ieee80211_get_channel(wiphy, freq);\n\n\ttimestamp = le64_to_cpu(bss->timestamp);\n\tcapability = le16_to_cpu(bss->capabilities);\n\tbeacon_interval = le16_to_cpu(bss->beacon_interval);\n\tie = bss->data;\n\tsignal = SIGNAL_TO_MBM(bss->level);\n\n\tcbss = cfg80211_inform_bss(wiphy, channel, CFG80211_BSS_FTYPE_UNKNOWN,\n\t\t\t\t   bss->bssid, timestamp, capability,\n\t\t\t\t   beacon_interval, ie, ie_len, signal,\n\t\t\t\t   GFP_KERNEL);\n\tcfg80211_put_bss(wiphy, cbss);\n}\n\nvoid orinoco_add_hostscan_results(struct orinoco_private *priv,\n\t\t\t\t  unsigned char *buf,\n\t\t\t\t  size_t len)\n{\n\tint offset;\t\t \n\tsize_t atom_len;\n\tbool abort = false;\n\n\tswitch (priv->firmware_type) {\n\tcase FIRMWARE_TYPE_AGERE:\n\t\tatom_len = sizeof(struct agere_scan_apinfo);\n\t\toffset = 0;\n\t\tbreak;\n\n\tcase FIRMWARE_TYPE_SYMBOL:\n\t\t \n\t\tif (len % 76)\n\t\t\tatom_len = 68;\n\t\telse if (len % 68)\n\t\t\tatom_len = 76;\n\t\telse if (len >= 1292 && buf[68] == 0)\n\t\t\tatom_len = 76;\n\t\telse\n\t\t\tatom_len = 68;\n\t\toffset = 0;\n\t\tbreak;\n\n\tcase FIRMWARE_TYPE_INTERSIL:\n\t\toffset = 4;\n\t\tif (priv->has_hostscan) {\n\t\t\tatom_len = le16_to_cpup((__le16 *)buf);\n\t\t\t \n\t\t\tif (atom_len < sizeof(struct prism2_scan_apinfo)) {\n\t\t\t\tprintk(KERN_ERR \"%s: Invalid atom_len in scan \"\n\t\t\t\t       \"data: %zu\\n\", priv->ndev->name,\n\t\t\t\t       atom_len);\n\t\t\t\tabort = true;\n\t\t\t\tgoto scan_abort;\n\t\t\t}\n\t\t} else\n\t\t\tatom_len = offsetof(struct prism2_scan_apinfo, atim);\n\t\tbreak;\n\n\tdefault:\n\t\tabort = true;\n\t\tgoto scan_abort;\n\t}\n\n\t \n\tif ((len - offset) % atom_len) {\n\t\tprintk(KERN_ERR \"%s: Unexpected scan data length %zu, \"\n\t\t       \"atom_len %zu, offset %d\\n\", priv->ndev->name, len,\n\t\t       atom_len, offset);\n\t\tabort = true;\n\t\tgoto scan_abort;\n\t}\n\n\t \n\tfor (; offset + atom_len <= len; offset += atom_len) {\n\t\tunion hermes_scan_info *atom;\n\n\t\tatom = (union hermes_scan_info *) (buf + offset);\n\n\t\torinoco_add_hostscan_result(priv, atom);\n\t}\n\n scan_abort:\n\tif (priv->scan_request) {\n\t\tstruct cfg80211_scan_info info = {\n\t\t\t.aborted = abort,\n\t\t};\n\n\t\tcfg80211_scan_done(priv->scan_request, &info);\n\t\tpriv->scan_request = NULL;\n\t}\n}\n\nvoid orinoco_scan_done(struct orinoco_private *priv, bool abort)\n{\n\tif (priv->scan_request) {\n\t\tstruct cfg80211_scan_info info = {\n\t\t\t.aborted = abort,\n\t\t};\n\n\t\tcfg80211_scan_done(priv->scan_request, &info);\n\t\tpriv->scan_request = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}