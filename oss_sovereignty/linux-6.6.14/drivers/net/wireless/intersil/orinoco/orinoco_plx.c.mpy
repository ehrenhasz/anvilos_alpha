{
  "module_name": "orinoco_plx.c",
  "hash_id": "934fa4a3db5fda066b686c1a0cd894858327cda9664a350e5f67c1a494a1c220",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/orinoco/orinoco_plx.c",
  "human_readable_source": " \n\n#define DRIVER_NAME \"orinoco_plx\"\n#define PFX DRIVER_NAME \": \"\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <pcmcia/cisreg.h>\n\n#include \"orinoco.h\"\n#include \"orinoco_pci.h\"\n\n#define COR_OFFSET\t(0x3e0)\t \n#define COR_VALUE\t(COR_LEVEL_REQ | COR_FUNC_ENA)  \n#define COR_RESET     (0x80)\t \n#define PLX_RESET_TIME\t(500)\t \n\n#define PLX_INTCSR\t\t0x4c  \n#define PLX_INTCSR_INTEN\t(1 << 6)  \n\n \nstatic int orinoco_plx_cor_reset(struct orinoco_private *priv)\n{\n\tstruct hermes *hw = &priv->hw;\n\tstruct orinoco_pci_card *card = priv->card;\n\tunsigned long timeout;\n\tu16 reg;\n\n\tiowrite8(COR_VALUE | COR_RESET, card->attr_io + COR_OFFSET);\n\tmdelay(1);\n\n\tiowrite8(COR_VALUE, card->attr_io + COR_OFFSET);\n\tmdelay(1);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(PLX_RESET_TIME);\n\treg = hermes_read_regn(hw, CMD);\n\twhile (time_before(jiffies, timeout) && (reg & HERMES_CMD_BUSY)) {\n\t\tmdelay(1);\n\t\treg = hermes_read_regn(hw, CMD);\n\t}\n\n\t \n\tif (reg & HERMES_CMD_BUSY) {\n\t\tprintk(KERN_ERR PFX \"Busy timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int orinoco_plx_hw_init(struct orinoco_pci_card *card)\n{\n\tint i;\n\tu32 csr_reg;\n\tstatic const u8 cis_magic[] = {\n\t\t0x01, 0x03, 0x00, 0x00, 0xff, 0x17, 0x04, 0x67\n\t};\n\n\tprintk(KERN_DEBUG PFX \"CIS: \");\n\tfor (i = 0; i < 16; i++)\n\t\tprintk(\"%02X:\", ioread8(card->attr_io + (i << 1)));\n\tprintk(\"\\n\");\n\n\t \n\t \n\tfor (i = 0; i < sizeof(cis_magic); i++) {\n\t\tif (cis_magic[i] != ioread8(card->attr_io + (i << 1))) {\n\t\t\tprintk(KERN_ERR PFX \"The CIS value of Prism2 PC \"\n\t\t\t       \"card is unexpected\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t \n\tcsr_reg = ioread32(card->bridge_io + PLX_INTCSR);\n\tif (!(csr_reg & PLX_INTCSR_INTEN)) {\n\t\tcsr_reg |= PLX_INTCSR_INTEN;\n\t\tiowrite32(csr_reg, card->bridge_io + PLX_INTCSR);\n\t\tcsr_reg = ioread32(card->bridge_io + PLX_INTCSR);\n\t\tif (!(csr_reg & PLX_INTCSR_INTEN)) {\n\t\t\tprintk(KERN_ERR PFX \"Cannot enable interrupts\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int orinoco_plx_init_one(struct pci_dev *pdev,\n\t\t\t\tconst struct pci_device_id *ent)\n{\n\tint err;\n\tstruct orinoco_private *priv;\n\tstruct orinoco_pci_card *card;\n\tvoid __iomem *hermes_io, *attr_io, *bridge_io;\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tprintk(KERN_ERR PFX \"Cannot enable PCI device\\n\");\n\t\treturn err;\n\t}\n\n\terr = pci_request_regions(pdev, DRIVER_NAME);\n\tif (err) {\n\t\tprintk(KERN_ERR PFX \"Cannot obtain PCI resources\\n\");\n\t\tgoto fail_resources;\n\t}\n\n\tbridge_io = pci_iomap(pdev, 1, 0);\n\tif (!bridge_io) {\n\t\tprintk(KERN_ERR PFX \"Cannot map bridge registers\\n\");\n\t\terr = -EIO;\n\t\tgoto fail_map_bridge;\n\t}\n\n\tattr_io = pci_iomap(pdev, 2, 0);\n\tif (!attr_io) {\n\t\tprintk(KERN_ERR PFX \"Cannot map PCMCIA attributes\\n\");\n\t\terr = -EIO;\n\t\tgoto fail_map_attr;\n\t}\n\n\thermes_io = pci_iomap(pdev, 3, 0);\n\tif (!hermes_io) {\n\t\tprintk(KERN_ERR PFX \"Cannot map chipset registers\\n\");\n\t\terr = -EIO;\n\t\tgoto fail_map_hermes;\n\t}\n\n\t \n\tpriv = alloc_orinocodev(sizeof(*card), &pdev->dev,\n\t\t\t\torinoco_plx_cor_reset, NULL);\n\tif (!priv) {\n\t\tprintk(KERN_ERR PFX \"Cannot allocate network device\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto fail_alloc;\n\t}\n\n\tcard = priv->card;\n\tcard->bridge_io = bridge_io;\n\tcard->attr_io = attr_io;\n\n\thermes_struct_init(&priv->hw, hermes_io, HERMES_16BIT_REGSPACING);\n\n\terr = request_irq(pdev->irq, orinoco_interrupt, IRQF_SHARED,\n\t\t\t  DRIVER_NAME, priv);\n\tif (err) {\n\t\tprintk(KERN_ERR PFX \"Cannot allocate IRQ %d\\n\", pdev->irq);\n\t\terr = -EBUSY;\n\t\tgoto fail_irq;\n\t}\n\n\terr = orinoco_plx_hw_init(card);\n\tif (err) {\n\t\tprintk(KERN_ERR PFX \"Hardware initialization failed\\n\");\n\t\tgoto fail;\n\t}\n\n\terr = orinoco_plx_cor_reset(priv);\n\tif (err) {\n\t\tprintk(KERN_ERR PFX \"Initial reset failed\\n\");\n\t\tgoto fail;\n\t}\n\n\terr = orinoco_init(priv);\n\tif (err) {\n\t\tprintk(KERN_ERR PFX \"orinoco_init() failed\\n\");\n\t\tgoto fail;\n\t}\n\n\terr = orinoco_if_add(priv, 0, 0, NULL);\n\tif (err) {\n\t\tprintk(KERN_ERR PFX \"orinoco_if_add() failed\\n\");\n\t\tgoto fail_wiphy;\n\t}\n\n\tpci_set_drvdata(pdev, priv);\n\n\treturn 0;\n\n fail_wiphy:\n\twiphy_unregister(priv_to_wiphy(priv));\n fail:\n\tfree_irq(pdev->irq, priv);\n\n fail_irq:\n\tfree_orinocodev(priv);\n\n fail_alloc:\n\tpci_iounmap(pdev, hermes_io);\n\n fail_map_hermes:\n\tpci_iounmap(pdev, attr_io);\n\n fail_map_attr:\n\tpci_iounmap(pdev, bridge_io);\n\n fail_map_bridge:\n\tpci_release_regions(pdev);\n\n fail_resources:\n\tpci_disable_device(pdev);\n\n\treturn err;\n}\n\nstatic void orinoco_plx_remove_one(struct pci_dev *pdev)\n{\n\tstruct orinoco_private *priv = pci_get_drvdata(pdev);\n\tstruct orinoco_pci_card *card = priv->card;\n\n\torinoco_if_del(priv);\n\twiphy_unregister(priv_to_wiphy(priv));\n\tfree_irq(pdev->irq, priv);\n\tfree_orinocodev(priv);\n\tpci_iounmap(pdev, priv->hw.iobase);\n\tpci_iounmap(pdev, card->attr_io);\n\tpci_iounmap(pdev, card->bridge_io);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n}\n\nstatic const struct pci_device_id orinoco_plx_id_table[] = {\n\t{0x111a, 0x1023, PCI_ANY_ID, PCI_ANY_ID,},\t \n\t{0x1385, 0x4100, PCI_ANY_ID, PCI_ANY_ID,},\t \n\t{0x15e8, 0x0130, PCI_ANY_ID, PCI_ANY_ID,},\t \n\t{0x1638, 0x1100, PCI_ANY_ID, PCI_ANY_ID,},\t \n\t{0x16ab, 0x1100, PCI_ANY_ID, PCI_ANY_ID,},\t \n\t{0x16ab, 0x1101, PCI_ANY_ID, PCI_ANY_ID,},\t \n\t{0x16ab, 0x1102, PCI_ANY_ID, PCI_ANY_ID,},\t \n\t{0x16ec, 0x3685, PCI_ANY_ID, PCI_ANY_ID,},\t \n\t{0xec80, 0xec00, PCI_ANY_ID, PCI_ANY_ID,},\t \n\t{0x10b7, 0x7770, PCI_ANY_ID, PCI_ANY_ID,},\t \n\t{0,},\n};\n\nMODULE_DEVICE_TABLE(pci, orinoco_plx_id_table);\n\nstatic struct pci_driver orinoco_plx_driver = {\n\t.name\t\t= DRIVER_NAME,\n\t.id_table\t= orinoco_plx_id_table,\n\t.probe\t\t= orinoco_plx_init_one,\n\t.remove\t\t= orinoco_plx_remove_one,\n\t.driver.pm\t= &orinoco_pci_pm_ops,\n};\n\nstatic char version[] __initdata = DRIVER_NAME \" \" DRIVER_VERSION\n\t\" (Pavel Roskin <proski@gnu.org>,\"\n\t\" David Gibson <hermes@gibson.dropbear.id.au>,\"\n\t\" Daniel Barlow <dan@telent.net>)\";\nMODULE_AUTHOR(\"Daniel Barlow <dan@telent.net>\");\nMODULE_DESCRIPTION(\"Driver for wireless LAN cards using the PLX9052 PCI bridge\");\nMODULE_LICENSE(\"Dual MPL/GPL\");\n\nstatic int __init orinoco_plx_init(void)\n{\n\tprintk(KERN_DEBUG \"%s\\n\", version);\n\treturn pci_register_driver(&orinoco_plx_driver);\n}\n\nstatic void __exit orinoco_plx_exit(void)\n{\n\tpci_unregister_driver(&orinoco_plx_driver);\n}\n\nmodule_init(orinoco_plx_init);\nmodule_exit(orinoco_plx_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}