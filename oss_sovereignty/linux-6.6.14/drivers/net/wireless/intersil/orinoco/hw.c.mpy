{
  "module_name": "hw.c",
  "hash_id": "fde97f19f4e61efb79b7bc67519a7dfc61b9a86b1d237e576fc30db560209720",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/orinoco/hw.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/if_arp.h>\n#include <linux/ieee80211.h>\n#include <linux/wireless.h>\n#include <net/cfg80211.h>\n#include \"hermes.h\"\n#include \"hermes_rid.h\"\n#include \"orinoco.h\"\n\n#include \"hw.h\"\n\n#define SYMBOL_MAX_VER_LEN\t(14)\n\n \n#define TX_NICBUF_SIZE_BUG\t1585\n\n \n \n \n\n \nstatic const struct {\n\tint bitrate;  \n\tint automatic;\n\tu16 agere_txratectrl;\n\tu16 intersil_txratectrl;\n} bitrate_table[] = {\n\t{110, 1,  3, 15},  \n\t{10,  0,  1,  1},\n\t{10,  1,  1,  1},\n\t{20,  0,  2,  2},\n\t{20,  1,  6,  3},\n\t{55,  0,  4,  4},\n\t{55,  1,  7,  7},\n\t{110, 0,  5,  8},\n};\n#define BITRATE_TABLE_SIZE ARRAY_SIZE(bitrate_table)\n\n \nstruct comp_id {\n\tu16 id, variant, major, minor;\n} __packed;\n\nstatic inline enum fwtype determine_firmware_type(struct comp_id *nic_id)\n{\n\tif (nic_id->id < 0x8000)\n\t\treturn FIRMWARE_TYPE_AGERE;\n\telse if (nic_id->id == 0x8000 && nic_id->major == 0)\n\t\treturn FIRMWARE_TYPE_SYMBOL;\n\telse\n\t\treturn FIRMWARE_TYPE_INTERSIL;\n}\n\n \nint determine_fw_capabilities(struct orinoco_private *priv,\n\t\t\t      char *fw_name, size_t fw_name_len,\n\t\t\t      u32 *hw_ver)\n{\n\tstruct device *dev = priv->dev;\n\tstruct hermes *hw = &priv->hw;\n\tint err;\n\tstruct comp_id nic_id, sta_id;\n\tunsigned int firmver;\n\tchar tmp[SYMBOL_MAX_VER_LEN + 1] __attribute__((aligned(2)));\n\n\t \n\terr = HERMES_READ_RECORD_PR(hw, USER_BAP, HERMES_RID_NICID, &nic_id);\n\tif (err) {\n\t\tdev_err(dev, \"Cannot read hardware identity: error %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tle16_to_cpus(&nic_id.id);\n\tle16_to_cpus(&nic_id.variant);\n\tle16_to_cpus(&nic_id.major);\n\tle16_to_cpus(&nic_id.minor);\n\tdev_info(dev, \"Hardware identity %04x:%04x:%04x:%04x\\n\",\n\t\t nic_id.id, nic_id.variant, nic_id.major, nic_id.minor);\n\n\tif (hw_ver)\n\t\t*hw_ver = (((nic_id.id & 0xff) << 24) |\n\t\t\t   ((nic_id.variant & 0xff) << 16) |\n\t\t\t   ((nic_id.major & 0xff) << 8) |\n\t\t\t   (nic_id.minor & 0xff));\n\n\tpriv->firmware_type = determine_firmware_type(&nic_id);\n\n\t \n\terr = HERMES_READ_RECORD_PR(hw, USER_BAP, HERMES_RID_STAID, &sta_id);\n\tif (err) {\n\t\tdev_err(dev, \"Cannot read station identity: error %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tle16_to_cpus(&sta_id.id);\n\tle16_to_cpus(&sta_id.variant);\n\tle16_to_cpus(&sta_id.major);\n\tle16_to_cpus(&sta_id.minor);\n\tdev_info(dev, \"Station identity  %04x:%04x:%04x:%04x\\n\",\n\t\t sta_id.id, sta_id.variant, sta_id.major, sta_id.minor);\n\n\tswitch (sta_id.id) {\n\tcase 0x15:\n\t\tdev_err(dev, \"Primary firmware is active\\n\");\n\t\treturn -ENODEV;\n\tcase 0x14b:\n\t\tdev_err(dev, \"Tertiary firmware is active\\n\");\n\t\treturn -ENODEV;\n\tcase 0x1f:\t \n\tcase 0x21:\t \n\t\tbreak;\n\tdefault:\n\t\tdev_notice(dev, \"Unknown station ID, please report\\n\");\n\t\tbreak;\n\t}\n\n\t \n\tpriv->has_sensitivity = 1;\n\tpriv->has_mwo = 0;\n\tpriv->has_preamble = 0;\n\tpriv->has_port3 = 1;\n\tpriv->has_ibss = 1;\n\tpriv->has_wep = 0;\n\tpriv->has_big_wep = 0;\n\tpriv->has_alt_txcntl = 0;\n\tpriv->has_ext_scan = 0;\n\tpriv->has_wpa = 0;\n\tpriv->do_fw_download = 0;\n\n\t \n\tswitch (priv->firmware_type) {\n\tcase FIRMWARE_TYPE_AGERE:\n\t\t \n\t\tif (fw_name)\n\t\t\tsnprintf(fw_name, fw_name_len, \"Lucent/Agere %d.%02d\",\n\t\t\t\t sta_id.major, sta_id.minor);\n\n\t\tfirmver = ((unsigned long)sta_id.major << 16) | sta_id.minor;\n\n\t\tpriv->has_ibss = (firmver >= 0x60006);\n\t\tpriv->has_wep = (firmver >= 0x40020);\n\t\tpriv->has_big_wep = 1;  \n\t\tpriv->has_mwo = (firmver >= 0x60000);\n\t\tpriv->has_pm = (firmver >= 0x40020);  \n\t\tpriv->ibss_port = 1;\n\t\tpriv->has_hostscan = (firmver >= 0x8000a);\n\t\tpriv->do_fw_download = 1;\n\t\tpriv->broken_monitor = (firmver >= 0x80000);\n\t\tpriv->has_alt_txcntl = (firmver >= 0x90000);  \n\t\tpriv->has_ext_scan = (firmver >= 0x90000);  \n\t\tpriv->has_wpa = (firmver >= 0x9002a);\n\t\t \n\t\tbreak;\n\tcase FIRMWARE_TYPE_SYMBOL:\n\t\t \n\t\t \n\t\t \n\t\tmemset(tmp, 0, sizeof(tmp));\n\t\t \n\t\terr = hw->ops->read_ltv_pr(hw, USER_BAP,\n\t\t\t\t\tHERMES_RID_SECONDARYVERSION_SYMBOL,\n\t\t\t\t\tSYMBOL_MAX_VER_LEN, NULL, &tmp);\n\t\tif (err) {\n\t\t\tdev_warn(dev, \"Error %d reading Symbol firmware info. \"\n\t\t\t\t \"Wildly guessing capabilities...\\n\", err);\n\t\t\tfirmver = 0;\n\t\t\ttmp[0] = '\\0';\n\t\t} else {\n\t\t\t \n\t\t\tfirmver = ((tmp[1] - '0') << 16)\n\t\t\t\t| ((tmp[3] - '0') << 12)\n\t\t\t\t| ((tmp[4] - '0') << 8)\n\t\t\t\t| ((tmp[6] - '0') << 4)\n\t\t\t\t| (tmp[7] - '0');\n\n\t\t\ttmp[SYMBOL_MAX_VER_LEN] = '\\0';\n\t\t}\n\n\t\tif (fw_name)\n\t\t\tsnprintf(fw_name, fw_name_len, \"Symbol %s\", tmp);\n\n\t\tpriv->has_ibss = (firmver >= 0x20000);\n\t\tpriv->has_wep = (firmver >= 0x15012);\n\t\tpriv->has_big_wep = (firmver >= 0x20000);\n\t\tpriv->has_pm = (firmver >= 0x20000 && firmver < 0x22000) ||\n\t\t\t       (firmver >= 0x29000 && firmver < 0x30000) ||\n\t\t\t       firmver >= 0x31000;\n\t\tpriv->has_preamble = (firmver >= 0x20000);\n\t\tpriv->ibss_port = 4;\n\n\t\t \n\t\tpriv->do_fw_download = (priv->stop_fw != NULL);\n\n\t\tpriv->broken_disableport = (firmver == 0x25013) ||\n\t\t\t\t(firmver >= 0x30000 && firmver <= 0x31000);\n\t\tpriv->has_hostscan = (firmver >= 0x31001) ||\n\t\t\t\t     (firmver >= 0x29057 && firmver < 0x30000);\n\t\t \n\t\t \n\t\tbreak;\n\tcase FIRMWARE_TYPE_INTERSIL:\n\t\t \n\t\t \n\t\t \n\t\tif (fw_name)\n\t\t\tsnprintf(fw_name, fw_name_len, \"Intersil %d.%d.%d\",\n\t\t\t\t sta_id.major, sta_id.minor, sta_id.variant);\n\n\t\tfirmver = ((unsigned long)sta_id.major << 16) |\n\t\t\t((unsigned long)sta_id.minor << 8) | sta_id.variant;\n\n\t\tpriv->has_ibss = (firmver >= 0x000700);  \n\t\tpriv->has_big_wep = priv->has_wep = (firmver >= 0x000800);\n\t\tpriv->has_pm = (firmver >= 0x000700);\n\t\tpriv->has_hostscan = (firmver >= 0x010301);\n\n\t\tif (firmver >= 0x000800)\n\t\t\tpriv->ibss_port = 0;\n\t\telse {\n\t\t\tdev_notice(dev, \"Intersil firmware earlier than v0.8.x\"\n\t\t\t\t   \" - several features not supported\\n\");\n\t\t\tpriv->ibss_port = 1;\n\t\t}\n\t\tbreak;\n\t}\n\tif (fw_name)\n\t\tdev_info(dev, \"Firmware determined as %s\\n\", fw_name);\n\n#ifndef CONFIG_HERMES_PRISM\n\tif (priv->firmware_type == FIRMWARE_TYPE_INTERSIL) {\n\t\tdev_err(dev, \"Support for Prism chipset is not enabled\\n\");\n\t\treturn -ENODEV;\n\t}\n#endif\n\n\treturn 0;\n}\n\n \nint orinoco_hw_read_card_settings(struct orinoco_private *priv, u8 *dev_addr)\n{\n\tstruct device *dev = priv->dev;\n\tstruct hermes_idstring nickbuf;\n\tstruct hermes *hw = &priv->hw;\n\tint len;\n\tint err;\n\tu16 reclen;\n\n\t \n\terr = hw->ops->read_ltv_pr(hw, USER_BAP, HERMES_RID_CNFOWNMACADDR,\n\t\t\t\tETH_ALEN, NULL, dev_addr);\n\tif (err) {\n\t\tdev_warn(dev, \"Failed to read MAC address!\\n\");\n\t\tgoto out;\n\t}\n\n\tdev_dbg(dev, \"MAC address %pM\\n\", dev_addr);\n\n\t \n\terr = hw->ops->read_ltv_pr(hw, USER_BAP, HERMES_RID_CNFOWNNAME,\n\t\t\t\tsizeof(nickbuf), &reclen, &nickbuf);\n\tif (err) {\n\t\tdev_err(dev, \"failed to read station name\\n\");\n\t\tgoto out;\n\t}\n\tif (nickbuf.len)\n\t\tlen = min(IW_ESSID_MAX_SIZE, (int)le16_to_cpu(nickbuf.len));\n\telse\n\t\tlen = min(IW_ESSID_MAX_SIZE, 2 * reclen);\n\tmemcpy(priv->nick, &nickbuf.val, len);\n\tpriv->nick[len] = '\\0';\n\n\tdev_dbg(dev, \"Station name \\\"%s\\\"\\n\", priv->nick);\n\n\t \n\terr = hermes_read_wordrec_pr(hw, USER_BAP, HERMES_RID_CHANNELLIST,\n\t\t\t\t  &priv->channel_mask);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to read channel list!\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\terr = hermes_read_wordrec_pr(hw, USER_BAP, HERMES_RID_CNFSYSTEMSCALE,\n\t\t\t\t  &priv->ap_density);\n\tif (err || priv->ap_density < 1 || priv->ap_density > 3)\n\t\tpriv->has_sensitivity = 0;\n\n\t \n\terr = hermes_read_wordrec_pr(hw, USER_BAP, HERMES_RID_CNFRTSTHRESHOLD,\n\t\t\t\t  &priv->rts_thresh);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to read RTS threshold!\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (priv->has_mwo)\n\t\terr = hermes_read_wordrec_pr(hw, USER_BAP,\n\t\t\t\t\t  HERMES_RID_CNFMWOROBUST_AGERE,\n\t\t\t\t\t  &priv->mwo_robust);\n\telse\n\t\terr = hermes_read_wordrec_pr(hw, USER_BAP,\n\t\t\t\t\t  HERMES_RID_CNFFRAGMENTATIONTHRESHOLD,\n\t\t\t\t\t  &priv->frag_thresh);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to read fragmentation settings!\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (priv->has_pm) {\n\t\tpriv->pm_on = 0;\n\t\tpriv->pm_mcast = 1;\n\t\terr = hermes_read_wordrec_pr(hw, USER_BAP,\n\t\t\t\t\t  HERMES_RID_CNFMAXSLEEPDURATION,\n\t\t\t\t\t  &priv->pm_period);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Failed to read power management \"\n\t\t\t\t\"period!\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\terr = hermes_read_wordrec_pr(hw, USER_BAP,\n\t\t\t\t\t  HERMES_RID_CNFPMHOLDOVERDURATION,\n\t\t\t\t\t  &priv->pm_timeout);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Failed to read power management \"\n\t\t\t\t\"timeout!\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (priv->has_preamble) {\n\t\terr = hermes_read_wordrec_pr(hw, USER_BAP,\n\t\t\t\t\t  HERMES_RID_CNFPREAMBLE_SYMBOL,\n\t\t\t\t\t  &priv->preamble);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Failed to read preamble setup\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\terr = hermes_read_wordrec_pr(hw, USER_BAP, HERMES_RID_SHORTRETRYLIMIT,\n\t\t\t\t  &priv->short_retry_limit);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to read short retry limit\\n\");\n\t\tgoto out;\n\t}\n\n\terr = hermes_read_wordrec_pr(hw, USER_BAP, HERMES_RID_LONGRETRYLIMIT,\n\t\t\t\t  &priv->long_retry_limit);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to read long retry limit\\n\");\n\t\tgoto out;\n\t}\n\n\terr = hermes_read_wordrec_pr(hw, USER_BAP, HERMES_RID_MAXTRANSMITLIFETIME,\n\t\t\t\t  &priv->retry_lifetime);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to read max retry lifetime\\n\");\n\t\tgoto out;\n\t}\n\nout:\n\treturn err;\n}\n\n \nint orinoco_hw_allocate_fid(struct orinoco_private *priv)\n{\n\tstruct device *dev = priv->dev;\n\tstruct hermes *hw = &priv->hw;\n\tint err;\n\n\terr = hw->ops->allocate(hw, priv->nicbuf_size, &priv->txfid);\n\tif (err == -EIO && priv->nicbuf_size > TX_NICBUF_SIZE_BUG) {\n\t\t \n\t\tpriv->nicbuf_size = TX_NICBUF_SIZE_BUG;\n\t\terr = hw->ops->allocate(hw, priv->nicbuf_size, &priv->txfid);\n\n\t\tdev_warn(dev, \"Firmware ALLOC bug detected \"\n\t\t\t \"(old Symbol firmware?). Work around %s\\n\",\n\t\t\t err ? \"failed!\" : \"ok.\");\n\t}\n\n\treturn err;\n}\n\nint orinoco_get_bitratemode(int bitrate, int automatic)\n{\n\tint ratemode = -1;\n\tint i;\n\n\tif ((bitrate != 10) && (bitrate != 20) &&\n\t    (bitrate != 55) && (bitrate != 110))\n\t\treturn ratemode;\n\n\tfor (i = 0; i < BITRATE_TABLE_SIZE; i++) {\n\t\tif ((bitrate_table[i].bitrate == bitrate) &&\n\t\t    (bitrate_table[i].automatic == automatic)) {\n\t\t\tratemode = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ratemode;\n}\n\nvoid orinoco_get_ratemode_cfg(int ratemode, int *bitrate, int *automatic)\n{\n\tBUG_ON((ratemode < 0) || (ratemode >= BITRATE_TABLE_SIZE));\n\n\t*bitrate = bitrate_table[ratemode].bitrate * 100000;\n\t*automatic = bitrate_table[ratemode].automatic;\n}\n\nint orinoco_hw_program_rids(struct orinoco_private *priv)\n{\n\tstruct net_device *dev = priv->ndev;\n\tstruct wireless_dev *wdev = netdev_priv(dev);\n\tstruct hermes *hw = &priv->hw;\n\tint err;\n\tstruct hermes_idstring idbuf;\n\n\t \n\terr = hw->ops->write_ltv(hw, USER_BAP, HERMES_RID_CNFOWNMACADDR,\n\t\t\t\t HERMES_BYTES_TO_RECLEN(ETH_ALEN),\n\t\t\t\t dev->dev_addr);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Error %d setting MAC address\\n\",\n\t\t       dev->name, err);\n\t\treturn err;\n\t}\n\n\t \n\terr = hermes_write_wordrec(hw, USER_BAP, HERMES_RID_CNFPORTTYPE,\n\t\t\t\t   priv->port_type);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Error %d setting port type\\n\",\n\t\t       dev->name, err);\n\t\treturn err;\n\t}\n\t \n\tif (priv->channel != 0 && priv->iw_mode != NL80211_IFTYPE_STATION) {\n\t\terr = hermes_write_wordrec(hw, USER_BAP,\n\t\t\t\t\t   HERMES_RID_CNFOWNCHANNEL,\n\t\t\t\t\t   priv->channel);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"%s: Error %d setting channel %d\\n\",\n\t\t\t       dev->name, err, priv->channel);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (priv->has_ibss) {\n\t\tu16 createibss;\n\n\t\tif ((strlen(priv->desired_essid) == 0) && (priv->createibss)) {\n\t\t\tprintk(KERN_WARNING \"%s: This firmware requires an \"\n\t\t\t       \"ESSID in IBSS-Ad-Hoc mode.\\n\", dev->name);\n\t\t\t \n\t\t\tcreateibss = 0;\n\t\t} else {\n\t\t\tcreateibss = priv->createibss;\n\t\t}\n\n\t\terr = hermes_write_wordrec(hw, USER_BAP,\n\t\t\t\t\t   HERMES_RID_CNFCREATEIBSS,\n\t\t\t\t\t   createibss);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"%s: Error %d setting CREATEIBSS\\n\",\n\t\t\t       dev->name, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\terr = __orinoco_hw_set_wap(priv);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Error %d setting AP address\\n\",\n\t\t       dev->name, err);\n\t\treturn err;\n\t}\n\n\t \n\tidbuf.len = cpu_to_le16(strlen(priv->desired_essid));\n\tmemcpy(&idbuf.val, priv->desired_essid, sizeof(idbuf.val));\n\t \n\terr = hw->ops->write_ltv(hw, USER_BAP, HERMES_RID_CNFOWNSSID,\n\t\t\tHERMES_BYTES_TO_RECLEN(strlen(priv->desired_essid) + 2),\n\t\t\t&idbuf);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Error %d setting OWNSSID\\n\",\n\t\t       dev->name, err);\n\t\treturn err;\n\t}\n\terr = hw->ops->write_ltv(hw, USER_BAP, HERMES_RID_CNFDESIREDSSID,\n\t\t\tHERMES_BYTES_TO_RECLEN(strlen(priv->desired_essid) + 2),\n\t\t\t&idbuf);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Error %d setting DESIREDSSID\\n\",\n\t\t       dev->name, err);\n\t\treturn err;\n\t}\n\n\t \n\tidbuf.len = cpu_to_le16(strlen(priv->nick));\n\tmemcpy(&idbuf.val, priv->nick, sizeof(idbuf.val));\n\terr = hw->ops->write_ltv(hw, USER_BAP, HERMES_RID_CNFOWNNAME,\n\t\t\t\t HERMES_BYTES_TO_RECLEN(strlen(priv->nick) + 2),\n\t\t\t\t &idbuf);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Error %d setting nickname\\n\",\n\t\t       dev->name, err);\n\t\treturn err;\n\t}\n\n\t \n\tif (priv->has_sensitivity) {\n\t\terr = hermes_write_wordrec(hw, USER_BAP,\n\t\t\t\t\t   HERMES_RID_CNFSYSTEMSCALE,\n\t\t\t\t\t   priv->ap_density);\n\t\tif (err) {\n\t\t\tprintk(KERN_WARNING \"%s: Error %d setting SYSTEMSCALE. \"\n\t\t\t       \"Disabling sensitivity control\\n\",\n\t\t\t       dev->name, err);\n\n\t\t\tpriv->has_sensitivity = 0;\n\t\t}\n\t}\n\n\t \n\terr = hermes_write_wordrec(hw, USER_BAP, HERMES_RID_CNFRTSTHRESHOLD,\n\t\t\t\t   priv->rts_thresh);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Error %d setting RTS threshold\\n\",\n\t\t       dev->name, err);\n\t\treturn err;\n\t}\n\n\t \n\tif (priv->has_mwo)\n\t\terr = hermes_write_wordrec(hw, USER_BAP,\n\t\t\t\t\t   HERMES_RID_CNFMWOROBUST_AGERE,\n\t\t\t\t\t   priv->mwo_robust);\n\telse\n\t\terr = hermes_write_wordrec(hw, USER_BAP,\n\t\t\t\t\t   HERMES_RID_CNFFRAGMENTATIONTHRESHOLD,\n\t\t\t\t\t   priv->frag_thresh);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Error %d setting fragmentation\\n\",\n\t\t       dev->name, err);\n\t\treturn err;\n\t}\n\n\t \n\terr = __orinoco_hw_set_bitrate(priv);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Error %d setting bitrate\\n\",\n\t\t       dev->name, err);\n\t\treturn err;\n\t}\n\n\t \n\tif (priv->has_pm) {\n\t\terr = hermes_write_wordrec(hw, USER_BAP,\n\t\t\t\t\t   HERMES_RID_CNFPMENABLED,\n\t\t\t\t\t   priv->pm_on);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"%s: Error %d setting up PM\\n\",\n\t\t\t       dev->name, err);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = hermes_write_wordrec(hw, USER_BAP,\n\t\t\t\t\t   HERMES_RID_CNFMULTICASTRECEIVE,\n\t\t\t\t\t   priv->pm_mcast);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"%s: Error %d setting up PM\\n\",\n\t\t\t       dev->name, err);\n\t\t\treturn err;\n\t\t}\n\t\terr = hermes_write_wordrec(hw, USER_BAP,\n\t\t\t\t\t   HERMES_RID_CNFMAXSLEEPDURATION,\n\t\t\t\t\t   priv->pm_period);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"%s: Error %d setting up PM\\n\",\n\t\t\t       dev->name, err);\n\t\t\treturn err;\n\t\t}\n\t\terr = hermes_write_wordrec(hw, USER_BAP,\n\t\t\t\t\t   HERMES_RID_CNFPMHOLDOVERDURATION,\n\t\t\t\t\t   priv->pm_timeout);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"%s: Error %d setting up PM\\n\",\n\t\t\t       dev->name, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tif (priv->has_preamble) {\n\t\terr = hermes_write_wordrec(hw, USER_BAP,\n\t\t\t\t\t   HERMES_RID_CNFPREAMBLE_SYMBOL,\n\t\t\t\t\t   priv->preamble);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"%s: Error %d setting preamble\\n\",\n\t\t\t       dev->name, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tif (priv->has_wep || priv->has_wpa) {\n\t\terr = __orinoco_hw_setup_enc(priv);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"%s: Error %d activating encryption\\n\",\n\t\t\t       dev->name, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (priv->iw_mode == NL80211_IFTYPE_MONITOR) {\n\t\t \n\t\tdev->type = ARPHRD_IEEE80211;\n\t\terr = hw->ops->cmd_wait(hw, HERMES_CMD_TEST |\n\t\t\t\t\t    HERMES_TEST_MONITOR, 0, NULL);\n\t} else {\n\t\t \n\t\tdev->type = ARPHRD_ETHER;\n\t\terr = hw->ops->cmd_wait(hw, HERMES_CMD_TEST |\n\t\t\t\t\t    HERMES_TEST_STOP, 0, NULL);\n\t}\n\tif (err)\n\t\treturn err;\n\n\t \n\tpriv->promiscuous = 0;\n\tpriv->mc_count = 0;\n\n\t \n\twdev->iftype = priv->iw_mode;\n\n\treturn 0;\n}\n\n \nint orinoco_hw_get_tkip_iv(struct orinoco_private *priv, int key, u8 *tsc)\n{\n\tstruct hermes *hw = &priv->hw;\n\tint err = 0;\n\tu8 tsc_arr[4][ORINOCO_SEQ_LEN];\n\n\tif ((key < 0) || (key >= 4))\n\t\treturn -EINVAL;\n\n\terr = hw->ops->read_ltv(hw, USER_BAP, HERMES_RID_CURRENT_TKIP_IV,\n\t\t\t\tsizeof(tsc_arr), NULL, &tsc_arr);\n\tif (!err)\n\t\tmemcpy(tsc, &tsc_arr[key][0], sizeof(tsc_arr[0]));\n\n\treturn err;\n}\n\nint __orinoco_hw_set_bitrate(struct orinoco_private *priv)\n{\n\tstruct hermes *hw = &priv->hw;\n\tint ratemode = priv->bitratemode;\n\tint err = 0;\n\n\tif (ratemode >= BITRATE_TABLE_SIZE) {\n\t\tprintk(KERN_ERR \"%s: BUG: Invalid bitrate mode %d\\n\",\n\t\t       priv->ndev->name, ratemode);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (priv->firmware_type) {\n\tcase FIRMWARE_TYPE_AGERE:\n\t\terr = hermes_write_wordrec(hw, USER_BAP,\n\t\t\t\tHERMES_RID_CNFTXRATECONTROL,\n\t\t\t\tbitrate_table[ratemode].agere_txratectrl);\n\t\tbreak;\n\tcase FIRMWARE_TYPE_INTERSIL:\n\tcase FIRMWARE_TYPE_SYMBOL:\n\t\terr = hermes_write_wordrec(hw, USER_BAP,\n\t\t\t\tHERMES_RID_CNFTXRATECONTROL,\n\t\t\t\tbitrate_table[ratemode].intersil_txratectrl);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn err;\n}\n\nint orinoco_hw_get_act_bitrate(struct orinoco_private *priv, int *bitrate)\n{\n\tstruct hermes *hw = &priv->hw;\n\tint i;\n\tint err = 0;\n\tu16 val;\n\n\terr = hermes_read_wordrec(hw, USER_BAP,\n\t\t\t\t  HERMES_RID_CURRENTTXRATE, &val);\n\tif (err)\n\t\treturn err;\n\n\tswitch (priv->firmware_type) {\n\tcase FIRMWARE_TYPE_AGERE:  \n\t\t \n\t\tif (val == 6)\n\t\t\t*bitrate = 5500000;\n\t\telse\n\t\t\t*bitrate = val * 1000000;\n\t\tbreak;\n\tcase FIRMWARE_TYPE_INTERSIL:  \n\tcase FIRMWARE_TYPE_SYMBOL:  \n\t\tfor (i = 0; i < BITRATE_TABLE_SIZE; i++)\n\t\t\tif (bitrate_table[i].intersil_txratectrl == val) {\n\t\t\t\t*bitrate = bitrate_table[i].bitrate * 100000;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (i >= BITRATE_TABLE_SIZE) {\n\t\t\tprintk(KERN_INFO \"%s: Unable to determine current bitrate (0x%04hx)\\n\",\n\t\t\t       priv->ndev->name, val);\n\t\t\terr = -EIO;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn err;\n}\n\n \nint __orinoco_hw_set_wap(struct orinoco_private *priv)\n{\n\tint roaming_flag;\n\tint err = 0;\n\tstruct hermes *hw = &priv->hw;\n\n\tswitch (priv->firmware_type) {\n\tcase FIRMWARE_TYPE_AGERE:\n\t\t \n\t\tbreak;\n\tcase FIRMWARE_TYPE_INTERSIL:\n\t\tif (priv->bssid_fixed)\n\t\t\troaming_flag = 2;\n\t\telse\n\t\t\troaming_flag = 1;\n\n\t\terr = hermes_write_wordrec(hw, USER_BAP,\n\t\t\t\t\t   HERMES_RID_CNFROAMINGMODE,\n\t\t\t\t\t   roaming_flag);\n\t\tbreak;\n\tcase FIRMWARE_TYPE_SYMBOL:\n\t\terr = HERMES_WRITE_RECORD(hw, USER_BAP,\n\t\t\t\t\t  HERMES_RID_CNFMANDATORYBSSID_SYMBOL,\n\t\t\t\t\t  &priv->desired_bssid);\n\t\tbreak;\n\t}\n\treturn err;\n}\n\n \nint __orinoco_hw_setup_wepkeys(struct orinoco_private *priv)\n{\n\tstruct hermes *hw = &priv->hw;\n\tint err = 0;\n\tint i;\n\n\tswitch (priv->firmware_type) {\n\tcase FIRMWARE_TYPE_AGERE:\n\t{\n\t\tstruct orinoco_key keys[ORINOCO_MAX_KEYS];\n\n\t\tmemset(&keys, 0, sizeof(keys));\n\t\tfor (i = 0; i < ORINOCO_MAX_KEYS; i++) {\n\t\t\tint len = min(priv->keys[i].key_len,\n\t\t\t\t      ORINOCO_MAX_KEY_SIZE);\n\t\t\tmemcpy(&keys[i].data, priv->keys[i].key, len);\n\t\t\tif (len > SMALL_KEY_SIZE)\n\t\t\t\tkeys[i].len = cpu_to_le16(LARGE_KEY_SIZE);\n\t\t\telse if (len > 0)\n\t\t\t\tkeys[i].len = cpu_to_le16(SMALL_KEY_SIZE);\n\t\t\telse\n\t\t\t\tkeys[i].len = cpu_to_le16(0);\n\t\t}\n\n\t\terr = HERMES_WRITE_RECORD(hw, USER_BAP,\n\t\t\t\t\t  HERMES_RID_CNFWEPKEYS_AGERE,\n\t\t\t\t\t  &keys);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = hermes_write_wordrec(hw, USER_BAP,\n\t\t\t\t\t   HERMES_RID_CNFTXKEY_AGERE,\n\t\t\t\t\t   priv->tx_key);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\t}\n\tcase FIRMWARE_TYPE_INTERSIL:\n\tcase FIRMWARE_TYPE_SYMBOL:\n\t\t{\n\t\t\tint keylen;\n\n\t\t\t \n\t\t\tkeylen = priv->keys[priv->tx_key].key_len;\n\n\t\t\tif (keylen > LARGE_KEY_SIZE) {\n\t\t\t\tprintk(KERN_ERR \"%s: BUG: Key %d has oversize length %d.\\n\",\n\t\t\t\t       priv->ndev->name, priv->tx_key, keylen);\n\t\t\t\treturn -E2BIG;\n\t\t\t} else if (keylen > SMALL_KEY_SIZE)\n\t\t\t\tkeylen = LARGE_KEY_SIZE;\n\t\t\telse if (keylen > 0)\n\t\t\t\tkeylen = SMALL_KEY_SIZE;\n\t\t\telse\n\t\t\t\tkeylen = 0;\n\n\t\t\t \n\t\t\tfor (i = 0; i < ORINOCO_MAX_KEYS; i++) {\n\t\t\t\tu8 key[LARGE_KEY_SIZE] = { 0 };\n\n\t\t\t\tmemcpy(key, priv->keys[i].key,\n\t\t\t\t       priv->keys[i].key_len);\n\n\t\t\t\terr = hw->ops->write_ltv(hw, USER_BAP,\n\t\t\t\t\t\tHERMES_RID_CNFDEFAULTKEY0 + i,\n\t\t\t\t\t\tHERMES_BYTES_TO_RECLEN(keylen),\n\t\t\t\t\t\tkey);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\t \n\t\t\terr = hermes_write_wordrec(hw, USER_BAP,\n\t\t\t\t\t\tHERMES_RID_CNFWEPDEFAULTKEYID,\n\t\t\t\t\t\tpriv->tx_key);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint __orinoco_hw_setup_enc(struct orinoco_private *priv)\n{\n\tstruct hermes *hw = &priv->hw;\n\tint err = 0;\n\tint master_wep_flag;\n\tint auth_flag;\n\tint enc_flag;\n\n\t \n\tif (priv->encode_alg == ORINOCO_ALG_WEP)\n\t\t__orinoco_hw_setup_wepkeys(priv);\n\n\tif (priv->wep_restrict)\n\t\tauth_flag = HERMES_AUTH_SHARED_KEY;\n\telse\n\t\tauth_flag = HERMES_AUTH_OPEN;\n\n\tif (priv->wpa_enabled)\n\t\tenc_flag = 2;\n\telse if (priv->encode_alg == ORINOCO_ALG_WEP)\n\t\tenc_flag = 1;\n\telse\n\t\tenc_flag = 0;\n\n\tswitch (priv->firmware_type) {\n\tcase FIRMWARE_TYPE_AGERE:  \n\t\tif (priv->encode_alg == ORINOCO_ALG_WEP) {\n\t\t\t \n\t\t\terr = hermes_write_wordrec(hw, USER_BAP,\n\t\t\t\t\tHERMES_RID_CNFAUTHENTICATION_AGERE,\n\t\t\t\t\tauth_flag);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = hermes_write_wordrec(hw, USER_BAP,\n\t\t\t\t\t   HERMES_RID_CNFWEPENABLED_AGERE,\n\t\t\t\t\t   enc_flag);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (priv->has_wpa) {\n\t\t\t \n\t\t\terr = hermes_write_wordrec(hw, USER_BAP,\n\t\t\t\t  HERMES_RID_CNFSETWPAAUTHMGMTSUITE_AGERE,\n\t\t\t\t  priv->key_mgmt);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tbreak;\n\n\tcase FIRMWARE_TYPE_INTERSIL:  \n\tcase FIRMWARE_TYPE_SYMBOL:  \n\t\tif (priv->encode_alg == ORINOCO_ALG_WEP) {\n\t\t\tif (priv->wep_restrict ||\n\t\t\t    (priv->firmware_type == FIRMWARE_TYPE_SYMBOL))\n\t\t\t\tmaster_wep_flag = HERMES_WEP_PRIVACY_INVOKED |\n\t\t\t\t\t\t  HERMES_WEP_EXCL_UNENCRYPTED;\n\t\t\telse\n\t\t\t\tmaster_wep_flag = HERMES_WEP_PRIVACY_INVOKED;\n\n\t\t\terr = hermes_write_wordrec(hw, USER_BAP,\n\t\t\t\t\t\t   HERMES_RID_CNFAUTHENTICATION,\n\t\t\t\t\t\t   auth_flag);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else\n\t\t\tmaster_wep_flag = 0;\n\n\t\tif (priv->iw_mode == NL80211_IFTYPE_MONITOR)\n\t\t\tmaster_wep_flag |= HERMES_WEP_HOST_DECRYPT;\n\n\t\t \n\t\terr = hermes_write_wordrec(hw, USER_BAP,\n\t\t\t\t\t   HERMES_RID_CNFWEPFLAGS_INTERSIL,\n\t\t\t\t\t   master_wep_flag);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nint __orinoco_hw_set_tkip_key(struct orinoco_private *priv, int key_idx,\n\t\t\t      int set_tx, const u8 *key, size_t key_len,\n\t\t\t      const u8 *rsc, size_t rsc_len,\n\t\t\t      const u8 *tsc, size_t tsc_len)\n{\n\tstruct {\n\t\t__le16 idx;\n\t\tu8 rsc[ORINOCO_SEQ_LEN];\n\t\tstruct {\n\t\t\tu8 key[TKIP_KEYLEN];\n\t\t\tu8 tx_mic[MIC_KEYLEN];\n\t\t\tu8 rx_mic[MIC_KEYLEN];\n\t\t} tkip;\n\t\tu8 tsc[ORINOCO_SEQ_LEN];\n\t} __packed buf;\n\tstruct hermes *hw = &priv->hw;\n\tint ret;\n\tint err;\n\tint k;\n\tu16 xmitting;\n\n\tkey_idx &= 0x3;\n\n\tif (set_tx)\n\t\tkey_idx |= 0x8000;\n\n\tbuf.idx = cpu_to_le16(key_idx);\n\tif (key_len != sizeof(buf.tkip))\n\t\treturn -EINVAL;\n\tmemcpy(&buf.tkip, key, sizeof(buf.tkip));\n\n\tif (rsc_len > sizeof(buf.rsc))\n\t\trsc_len = sizeof(buf.rsc);\n\n\tif (tsc_len > sizeof(buf.tsc))\n\t\ttsc_len = sizeof(buf.tsc);\n\n\tmemset(buf.rsc, 0, sizeof(buf.rsc));\n\tmemset(buf.tsc, 0, sizeof(buf.tsc));\n\n\tif (rsc != NULL)\n\t\tmemcpy(buf.rsc, rsc, rsc_len);\n\n\tif (tsc != NULL)\n\t\tmemcpy(buf.tsc, tsc, tsc_len);\n\telse\n\t\tbuf.tsc[4] = 0x10;\n\n\t \n\tfor (k = 100; k > 0; k--) {\n\t\tudelay(1000);\n\t\tret = hermes_read_wordrec(hw, USER_BAP, HERMES_RID_TXQUEUEEMPTY,\n\t\t\t\t\t  &xmitting);\n\t\tif (ret || !xmitting)\n\t\t\tbreak;\n\t}\n\n\tif (k == 0)\n\t\tret = -ETIMEDOUT;\n\n\terr = HERMES_WRITE_RECORD(hw, USER_BAP,\n\t\t\t\t  HERMES_RID_CNFADDDEFAULTTKIPKEY_AGERE,\n\t\t\t\t  &buf);\n\n\treturn ret ? ret : err;\n}\n\nint orinoco_clear_tkip_key(struct orinoco_private *priv, int key_idx)\n{\n\tstruct hermes *hw = &priv->hw;\n\tint err;\n\n\terr = hermes_write_wordrec(hw, USER_BAP,\n\t\t\t\t   HERMES_RID_CNFREMDEFAULTTKIPKEY_AGERE,\n\t\t\t\t   key_idx);\n\tif (err)\n\t\tprintk(KERN_WARNING \"%s: Error %d clearing TKIP key %d\\n\",\n\t\t       priv->ndev->name, err, key_idx);\n\treturn err;\n}\n\nint __orinoco_hw_set_multicast_list(struct orinoco_private *priv,\n\t\t\t\t    struct net_device *dev,\n\t\t\t\t    int mc_count, int promisc)\n{\n\tstruct hermes *hw = &priv->hw;\n\tint err = 0;\n\n\tif (promisc != priv->promiscuous) {\n\t\terr = hermes_write_wordrec(hw, USER_BAP,\n\t\t\t\t\t   HERMES_RID_CNFPROMISCUOUSMODE,\n\t\t\t\t\t   promisc);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"%s: Error %d setting PROMISCUOUSMODE to 1.\\n\",\n\t\t\t       priv->ndev->name, err);\n\t\t} else\n\t\t\tpriv->promiscuous = promisc;\n\t}\n\n\t \n\tif (!promisc && (mc_count || priv->mc_count)) {\n\t\tstruct netdev_hw_addr *ha;\n\t\tstruct hermes_multicast mclist;\n\t\tint i = 0;\n\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tif (i == mc_count)\n\t\t\t\tbreak;\n\t\t\tmemcpy(mclist.addr[i++], ha->addr, ETH_ALEN);\n\t\t}\n\n\t\terr = hw->ops->write_ltv(hw, USER_BAP,\n\t\t\t\t   HERMES_RID_CNFGROUPADDRESSES,\n\t\t\t\t   HERMES_BYTES_TO_RECLEN(mc_count * ETH_ALEN),\n\t\t\t\t   &mclist);\n\t\tif (err)\n\t\t\tprintk(KERN_ERR \"%s: Error %d setting multicast list.\\n\",\n\t\t\t       priv->ndev->name, err);\n\t\telse\n\t\t\tpriv->mc_count = mc_count;\n\t}\n\treturn err;\n}\n\n \nint orinoco_hw_get_essid(struct orinoco_private *priv, int *active,\n\t\t\t char buf[IW_ESSID_MAX_SIZE + 1])\n{\n\tstruct hermes *hw = &priv->hw;\n\tint err = 0;\n\tstruct hermes_idstring essidbuf;\n\tchar *p = (char *)(&essidbuf.val);\n\tint len;\n\tunsigned long flags;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tif (strlen(priv->desired_essid) > 0) {\n\t\t \n\t\t \n\t\tu16 rid;\n\n\t\t*active = 1;\n\n\t\trid = (priv->port_type == 3) ? HERMES_RID_CNFOWNSSID :\n\t\t\tHERMES_RID_CNFDESIREDSSID;\n\n\t\terr = hw->ops->read_ltv(hw, USER_BAP, rid, sizeof(essidbuf),\n\t\t\t\t\tNULL, &essidbuf);\n\t\tif (err)\n\t\t\tgoto fail_unlock;\n\t} else {\n\t\t*active = 0;\n\n\t\terr = hw->ops->read_ltv(hw, USER_BAP, HERMES_RID_CURRENTSSID,\n\t\t\t\t\tsizeof(essidbuf), NULL, &essidbuf);\n\t\tif (err)\n\t\t\tgoto fail_unlock;\n\t}\n\n\tlen = le16_to_cpu(essidbuf.len);\n\tBUG_ON(len > IW_ESSID_MAX_SIZE);\n\n\tmemset(buf, 0, IW_ESSID_MAX_SIZE);\n\tmemcpy(buf, p, len);\n\terr = len;\n\n fail_unlock:\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\n\nint orinoco_hw_get_freq(struct orinoco_private *priv)\n{\n\tstruct hermes *hw = &priv->hw;\n\tint err = 0;\n\tu16 channel;\n\tint freq = 0;\n\tunsigned long flags;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\terr = hermes_read_wordrec(hw, USER_BAP, HERMES_RID_CURRENTCHANNEL,\n\t\t\t\t  &channel);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tif (channel == 0) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif ((channel < 1) || (channel > NUM_CHANNELS)) {\n\t\tprintk(KERN_WARNING \"%s: Channel out of range (%d)!\\n\",\n\t\t       priv->ndev->name, channel);\n\t\terr = -EBUSY;\n\t\tgoto out;\n\n\t}\n\tfreq = ieee80211_channel_to_frequency(channel, NL80211_BAND_2GHZ);\n\n out:\n\torinoco_unlock(priv, &flags);\n\n\tif (err > 0)\n\t\terr = -EBUSY;\n\treturn err ? err : freq;\n}\n\nint orinoco_hw_get_bitratelist(struct orinoco_private *priv,\n\t\t\t       int *numrates, s32 *rates, int max)\n{\n\tstruct hermes *hw = &priv->hw;\n\tstruct hermes_idstring list;\n\tunsigned char *p = (unsigned char *)&list.val;\n\tint err = 0;\n\tint num;\n\tint i;\n\tunsigned long flags;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\terr = hw->ops->read_ltv(hw, USER_BAP, HERMES_RID_SUPPORTEDDATARATES,\n\t\t\t\tsizeof(list), NULL, &list);\n\torinoco_unlock(priv, &flags);\n\n\tif (err)\n\t\treturn err;\n\n\tnum = le16_to_cpu(list.len);\n\t*numrates = num;\n\tnum = min(num, max);\n\n\tfor (i = 0; i < num; i++)\n\t\trates[i] = (p[i] & 0x7f) * 500000;  \n\n\treturn 0;\n}\n\nint orinoco_hw_trigger_scan(struct orinoco_private *priv,\n\t\t\t    const struct cfg80211_ssid *ssid)\n{\n\tstruct net_device *dev = priv->ndev;\n\tstruct hermes *hw = &priv->hw;\n\tunsigned long flags;\n\tint err = 0;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\t \n\tif (!netif_running(dev)) {\n\t\terr = -ENETDOWN;\n\t\tgoto out;\n\t}\n\n\t \n\tif (priv->iw_mode == NL80211_IFTYPE_MONITOR) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (priv->has_hostscan) {\n\t\tswitch (priv->firmware_type) {\n\t\tcase FIRMWARE_TYPE_SYMBOL:\n\t\t\terr = hermes_write_wordrec(hw, USER_BAP,\n\t\t\t\t\t\tHERMES_RID_CNFHOSTSCAN_SYMBOL,\n\t\t\t\t\t\tHERMES_HOSTSCAN_SYMBOL_ONCE |\n\t\t\t\t\t\tHERMES_HOSTSCAN_SYMBOL_BCAST);\n\t\t\tbreak;\n\t\tcase FIRMWARE_TYPE_INTERSIL: {\n\t\t\t__le16 req[3];\n\n\t\t\treq[0] = cpu_to_le16(0x3fff);\t \n\t\t\treq[1] = cpu_to_le16(0x0001);\t \n\t\t\treq[2] = 0;\t\t\t \n\t\t\terr = HERMES_WRITE_RECORD(hw, USER_BAP,\n\t\t\t\t\t\t  HERMES_RID_CNFHOSTSCAN, &req);\n\t\t\tbreak;\n\t\t}\n\t\tcase FIRMWARE_TYPE_AGERE:\n\t\t\tif (ssid->ssid_len > 0) {\n\t\t\t\tstruct hermes_idstring idbuf;\n\t\t\t\tsize_t len = ssid->ssid_len;\n\n\t\t\t\tidbuf.len = cpu_to_le16(len);\n\t\t\t\tmemcpy(idbuf.val, ssid->ssid, len);\n\n\t\t\t\terr = hw->ops->write_ltv(hw, USER_BAP,\n\t\t\t\t\t       HERMES_RID_CNFSCANSSID_AGERE,\n\t\t\t\t\t       HERMES_BYTES_TO_RECLEN(len + 2),\n\t\t\t\t\t       &idbuf);\n\t\t\t} else\n\t\t\t\terr = hermes_write_wordrec(hw, USER_BAP,\n\t\t\t\t\t\t   HERMES_RID_CNFSCANSSID_AGERE,\n\t\t\t\t\t\t   0);\t \n\t\t\tif (err)\n\t\t\t\tbreak;\n\n\t\t\tif (priv->has_ext_scan) {\n\t\t\t\terr = hermes_write_wordrec(hw, USER_BAP,\n\t\t\t\t\t\tHERMES_RID_CNFSCANCHANNELS2GHZ,\n\t\t\t\t\t\t0x7FFF);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\n\t\t\t\terr = hermes_inquire(hw,\n\t\t\t\t\t\t     HERMES_INQ_CHANNELINFO);\n\t\t\t} else\n\t\t\t\terr = hermes_inquire(hw, HERMES_INQ_SCAN);\n\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\terr = hermes_inquire(hw, HERMES_INQ_SCAN);\n\n out:\n\torinoco_unlock(priv, &flags);\n\n\treturn err;\n}\n\n \nint orinoco_hw_disassociate(struct orinoco_private *priv,\n\t\t\t    u8 *addr, u16 reason_code)\n{\n\tstruct hermes *hw = &priv->hw;\n\tint err;\n\n\tstruct {\n\t\tu8 addr[ETH_ALEN];\n\t\t__le16 reason_code;\n\t} __packed buf;\n\n\t \n\tif (!priv->has_wpa)\n\t\treturn -EOPNOTSUPP;\n\n\tmemcpy(buf.addr, addr, ETH_ALEN);\n\tbuf.reason_code = cpu_to_le16(reason_code);\n\terr = HERMES_WRITE_RECORD(hw, USER_BAP,\n\t\t\t\t  HERMES_RID_CNFDISASSOCIATE,\n\t\t\t\t  &buf);\n\treturn err;\n}\n\nint orinoco_hw_get_current_bssid(struct orinoco_private *priv,\n\t\t\t\t u8 *addr)\n{\n\tstruct hermes *hw = &priv->hw;\n\tint err;\n\n\terr = hw->ops->read_ltv(hw, USER_BAP, HERMES_RID_CURRENTBSSID,\n\t\t\t\tETH_ALEN, NULL, addr);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}