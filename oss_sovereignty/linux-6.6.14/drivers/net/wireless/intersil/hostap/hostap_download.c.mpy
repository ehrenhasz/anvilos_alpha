{
  "module_name": "hostap_download.c",
  "hash_id": "af969c2dfcdd47d95557e2de336bf01a852c9da61b355efbf9d1f566af0b7aaf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/hostap/hostap_download.c",
  "human_readable_source": "\nstatic int prism2_enable_aux_port(struct net_device *dev, int enable)\n{\n\tu16 val, reg;\n\tint i, tries;\n\tunsigned long flags;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (local->no_pri) {\n\t\tif (enable) {\n\t\t\tPDEBUG(DEBUG_EXTRA2, \"%s: no PRI f/w - assuming Aux \"\n\t\t\t       \"port is already enabled\\n\", dev->name);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tspin_lock_irqsave(&local->cmdlock, flags);\n\n\t \n\ttries = HFA384X_CMD_BUSY_TIMEOUT;\n\twhile (HFA384X_INW(HFA384X_CMD_OFF) & HFA384X_CMD_BUSY && tries > 0) {\n\t\ttries--;\n\t\tudelay(1);\n\t}\n\tif (tries == 0) {\n\t\treg = HFA384X_INW(HFA384X_CMD_OFF);\n\t\tspin_unlock_irqrestore(&local->cmdlock, flags);\n\t\tprintk(\"%s: prism2_enable_aux_port - timeout - reg=0x%04x\\n\",\n\t\t       dev->name, reg);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tval = HFA384X_INW(HFA384X_CONTROL_OFF);\n\n\tif (enable) {\n\t\tHFA384X_OUTW(HFA384X_AUX_MAGIC0, HFA384X_PARAM0_OFF);\n\t\tHFA384X_OUTW(HFA384X_AUX_MAGIC1, HFA384X_PARAM1_OFF);\n\t\tHFA384X_OUTW(HFA384X_AUX_MAGIC2, HFA384X_PARAM2_OFF);\n\n\t\tif ((val & HFA384X_AUX_PORT_MASK) != HFA384X_AUX_PORT_DISABLED)\n\t\t\tprintk(\"prism2_enable_aux_port: was not disabled!?\\n\");\n\t\tval &= ~HFA384X_AUX_PORT_MASK;\n\t\tval |= HFA384X_AUX_PORT_ENABLE;\n\t} else {\n\t\tHFA384X_OUTW(0, HFA384X_PARAM0_OFF);\n\t\tHFA384X_OUTW(0, HFA384X_PARAM1_OFF);\n\t\tHFA384X_OUTW(0, HFA384X_PARAM2_OFF);\n\n\t\tif ((val & HFA384X_AUX_PORT_MASK) != HFA384X_AUX_PORT_ENABLED)\n\t\t\tprintk(\"prism2_enable_aux_port: was not enabled!?\\n\");\n\t\tval &= ~HFA384X_AUX_PORT_MASK;\n\t\tval |= HFA384X_AUX_PORT_DISABLE;\n\t}\n\tHFA384X_OUTW(val, HFA384X_CONTROL_OFF);\n\n\tudelay(5);\n\n\ti = 10000;\n\twhile (i > 0) {\n\t\tval = HFA384X_INW(HFA384X_CONTROL_OFF);\n\t\tval &= HFA384X_AUX_PORT_MASK;\n\n\t\tif ((enable && val == HFA384X_AUX_PORT_ENABLED) ||\n\t\t    (!enable && val == HFA384X_AUX_PORT_DISABLED))\n\t\t\tbreak;\n\n\t\tudelay(10);\n\t\ti--;\n\t}\n\n\tspin_unlock_irqrestore(&local->cmdlock, flags);\n\n\tif (i == 0) {\n\t\tprintk(\"prism2_enable_aux_port(%d) timed out\\n\",\n\t\t       enable);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int hfa384x_from_aux(struct net_device *dev, unsigned int addr, int len,\n\t\t\t    void *buf)\n{\n\tu16 page, offset;\n\tif (addr & 1 || len & 1)\n\t\treturn -1;\n\n\tpage = addr >> 7;\n\toffset = addr & 0x7f;\n\n\tHFA384X_OUTW(page, HFA384X_AUXPAGE_OFF);\n\tHFA384X_OUTW(offset, HFA384X_AUXOFFSET_OFF);\n\n\tudelay(5);\n\n#ifdef PRISM2_PCI\n\t{\n\t\t__le16 *pos = (__le16 *) buf;\n\t\twhile (len > 0) {\n\t\t\t*pos++ = HFA384X_INW_DATA(HFA384X_AUXDATA_OFF);\n\t\t\tlen -= 2;\n\t\t}\n\t}\n#else  \n\tHFA384X_INSW(HFA384X_AUXDATA_OFF, buf, len / 2);\n#endif  \n\n\treturn 0;\n}\n\n\nstatic int hfa384x_to_aux(struct net_device *dev, unsigned int addr, int len,\n\t\t\t  void *buf)\n{\n\tu16 page, offset;\n\tif (addr & 1 || len & 1)\n\t\treturn -1;\n\n\tpage = addr >> 7;\n\toffset = addr & 0x7f;\n\n\tHFA384X_OUTW(page, HFA384X_AUXPAGE_OFF);\n\tHFA384X_OUTW(offset, HFA384X_AUXOFFSET_OFF);\n\n\tudelay(5);\n\n#ifdef PRISM2_PCI\n\t{\n\t\t__le16 *pos = (__le16 *) buf;\n\t\twhile (len > 0) {\n\t\t\tHFA384X_OUTW_DATA(*pos++, HFA384X_AUXDATA_OFF);\n\t\t\tlen -= 2;\n\t\t}\n\t}\n#else  \n\tHFA384X_OUTSW(HFA384X_AUXDATA_OFF, buf, len / 2);\n#endif  \n\n\treturn 0;\n}\n\n\nstatic int prism2_pda_ok(u8 *buf)\n{\n\t__le16 *pda = (__le16 *) buf;\n\tint pos;\n\tu16 len, pdr;\n\n\tif (buf[0] == 0xff && buf[1] == 0x00 && buf[2] == 0xff &&\n\t    buf[3] == 0x00)\n\t\treturn 0;\n\n\tpos = 0;\n\twhile (pos + 1 < PRISM2_PDA_SIZE / 2) {\n\t\tlen = le16_to_cpu(pda[pos]);\n\t\tpdr = le16_to_cpu(pda[pos + 1]);\n\t\tif (len == 0 || pos + len > PRISM2_PDA_SIZE / 2)\n\t\t\treturn 0;\n\n\t\tif (pdr == 0x0000 && len == 2) {\n\t\t\t \n\t\t\treturn 1;\n\t\t}\n\n\t\tpos += len + 1;\n\t}\n\n\treturn 0;\n}\n\n\n#define prism2_download_aux_dump_npages 65536\n\nstruct prism2_download_aux_dump {\n\tlocal_info_t *local;\n\tu16 page[0x80];\n};\n\nstatic int prism2_download_aux_dump_proc_show(struct seq_file *m, void *v)\n{\n\tstruct prism2_download_aux_dump *ctx = m->private;\n\n\thfa384x_from_aux(ctx->local->dev, (unsigned long)v - 1, 0x80, ctx->page);\n\tseq_write(m, ctx->page, 0x80);\n\treturn 0;\n}\n\nstatic void *prism2_download_aux_dump_proc_start(struct seq_file *m, loff_t *_pos)\n{\n\tstruct prism2_download_aux_dump *ctx = m->private;\n\tprism2_enable_aux_port(ctx->local->dev, 1);\n\tif (*_pos >= prism2_download_aux_dump_npages)\n\t\treturn NULL;\n\treturn (void *)((unsigned long)*_pos + 1);\n}\n\nstatic void *prism2_download_aux_dump_proc_next(struct seq_file *m, void *v, loff_t *_pos)\n{\n\t++*_pos;\n\tif (*_pos >= prism2_download_aux_dump_npages)\n\t\treturn NULL;\n\treturn (void *)((unsigned long)*_pos + 1);\n}\n\nstatic void prism2_download_aux_dump_proc_stop(struct seq_file *m, void *v)\n{\n\tstruct prism2_download_aux_dump *ctx = m->private;\n\tprism2_enable_aux_port(ctx->local->dev, 0);\n}\n\nstatic const struct seq_operations prism2_download_aux_dump_proc_seqops = {\n\t.start\t= prism2_download_aux_dump_proc_start,\n\t.next\t= prism2_download_aux_dump_proc_next,\n\t.stop\t= prism2_download_aux_dump_proc_stop,\n\t.show\t= prism2_download_aux_dump_proc_show,\n};\n\nstatic int prism2_download_aux_dump_proc_open(struct inode *inode, struct file *file)\n{\n\tint ret = seq_open_private(file, &prism2_download_aux_dump_proc_seqops,\n\t\t\t\t   sizeof(struct prism2_download_aux_dump));\n\tif (ret == 0) {\n\t\tstruct seq_file *m = file->private_data;\n\t\tm->private = pde_data(inode);\n\t}\n\treturn ret;\n}\n\nstatic const struct proc_ops prism2_download_aux_dump_proc_ops = {\n\t.proc_open\t\t= prism2_download_aux_dump_proc_open,\n\t.proc_read\t\t= seq_read,\n\t.proc_lseek\t\t= seq_lseek,\n\t.proc_release\t\t= seq_release_private,\n};\n\n\nstatic u8 * prism2_read_pda(struct net_device *dev)\n{\n\tu8 *buf;\n\tint res, i, found = 0;\n#define NUM_PDA_ADDRS 4\n\tunsigned int pda_addr[NUM_PDA_ADDRS] = {\n\t\t0x7f0000  ,\n\t\t0x3f0000  ,\n\t\t0x390000  ,\n\t\t0x7f0002  ,\n\t};\n\n\tbuf = kmalloc(PRISM2_PDA_SIZE, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn NULL;\n\n\t \n\n\tprism2_enable_aux_port(dev, 1);\n\n\tfor (i = 0; i < NUM_PDA_ADDRS; i++) {\n\t\tPDEBUG(DEBUG_EXTRA2, \"%s: trying to read PDA from 0x%08x\",\n\t\t       dev->name, pda_addr[i]);\n\t\tres = hfa384x_from_aux(dev, pda_addr[i], PRISM2_PDA_SIZE, buf);\n\t\tif (res)\n\t\t\tcontinue;\n\t\tif (res == 0 && prism2_pda_ok(buf)) {\n\t\t\tPDEBUG2(DEBUG_EXTRA2, \": OK\\n\");\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tPDEBUG2(DEBUG_EXTRA2, \": failed\\n\");\n\t\t}\n\t}\n\n\tprism2_enable_aux_port(dev, 0);\n\n\tif (!found) {\n\t\tprintk(KERN_DEBUG \"%s: valid PDA not found\\n\", dev->name);\n\t\tkfree(buf);\n\t\tbuf = NULL;\n\t}\n\n\treturn buf;\n}\n\n\nstatic int prism2_download_volatile(local_info_t *local,\n\t\t\t\t    struct prism2_download_data *param)\n{\n\tstruct net_device *dev = local->dev;\n\tint ret = 0, i;\n\tu16 param0, param1;\n\n\tif (local->hw_downloading) {\n\t\tprintk(KERN_WARNING \"%s: Already downloading - aborting new \"\n\t\t       \"request\\n\", dev->name);\n\t\treturn -1;\n\t}\n\n\tlocal->hw_downloading = 1;\n\tif (local->pri_only) {\n\t\thfa384x_disable_interrupts(dev);\n\t} else {\n\t\tprism2_hw_shutdown(dev, 0);\n\n\t\tif (prism2_hw_init(dev, 0)) {\n\t\t\tprintk(KERN_WARNING \"%s: Could not initialize card for\"\n\t\t\t       \" download\\n\", dev->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (prism2_enable_aux_port(dev, 1)) {\n\t\tprintk(KERN_WARNING \"%s: Could not enable AUX port\\n\",\n\t\t       dev->name);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tparam0 = param->start_addr & 0xffff;\n\tparam1 = param->start_addr >> 16;\n\n\tHFA384X_OUTW(0, HFA384X_PARAM2_OFF);\n\tHFA384X_OUTW(param1, HFA384X_PARAM1_OFF);\n\tif (hfa384x_cmd_wait(dev, HFA384X_CMDCODE_DOWNLOAD |\n\t\t\t     (HFA384X_PROGMODE_ENABLE_VOLATILE << 8),\n\t\t\t     param0)) {\n\t\tprintk(KERN_WARNING \"%s: Download command execution failed\\n\",\n\t\t       dev->name);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < param->num_areas; i++) {\n\t\tPDEBUG(DEBUG_EXTRA2, \"%s: Writing %d bytes at 0x%08x\\n\",\n\t\t       dev->name, param->data[i].len, param->data[i].addr);\n\t\tif (hfa384x_to_aux(dev, param->data[i].addr,\n\t\t\t\t   param->data[i].len, param->data[i].data)) {\n\t\t\tprintk(KERN_WARNING \"%s: RAM download at 0x%08x \"\n\t\t\t       \"(len=%d) failed\\n\", dev->name,\n\t\t\t       param->data[i].addr, param->data[i].len);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tHFA384X_OUTW(param1, HFA384X_PARAM1_OFF);\n\tHFA384X_OUTW(0, HFA384X_PARAM2_OFF);\n\tif (hfa384x_cmd_no_wait(dev, HFA384X_CMDCODE_DOWNLOAD |\n\t\t\t\t(HFA384X_PROGMODE_DISABLE << 8), param0)) {\n\t\tprintk(KERN_WARNING \"%s: Download command execution failed\\n\",\n\t\t       dev->name);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\t \n\tmdelay(5);\n\tHFA384X_OUTW(HFA384X_EV_CMD, HFA384X_EVACK_OFF);\n\n\tif (prism2_enable_aux_port(dev, 0)) {\n\t\tprintk(KERN_DEBUG \"%s: Disabling AUX port failed\\n\",\n\t\t       dev->name);\n\t\t \n\t}\n\n\tmdelay(5);\n\tlocal->hw_downloading = 0;\n\tif (prism2_hw_config(dev, 2)) {\n\t\tprintk(KERN_WARNING \"%s: Card configuration after RAM \"\n\t\t       \"download failed\\n\", dev->name);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n out:\n\tlocal->hw_downloading = 0;\n\treturn ret;\n}\n\n\nstatic int prism2_enable_genesis(local_info_t *local, int hcr)\n{\n\tstruct net_device *dev = local->dev;\n\tu8 initseq[4] = { 0x00, 0xe1, 0xa1, 0xff };\n\tu8 readbuf[4];\n\n\tprintk(KERN_DEBUG \"%s: test Genesis mode with HCR 0x%02x\\n\",\n\t       dev->name, hcr);\n\tlocal->func->cor_sreset(local);\n\thfa384x_to_aux(dev, 0x7e0038, sizeof(initseq), initseq);\n\tlocal->func->genesis_reset(local, hcr);\n\n\t \n\thfa384x_from_aux(dev, 0x7e0038, sizeof(readbuf), readbuf);\n\thfa384x_to_aux(dev, 0x7e0038, sizeof(initseq), initseq);\n\thfa384x_from_aux(dev, 0x7e0038, sizeof(readbuf), readbuf);\n\n\tif (memcmp(initseq, readbuf, sizeof(initseq)) == 0) {\n\t\tprintk(KERN_DEBUG \"Readback test succeeded, HCR 0x%02x\\n\",\n\t\t       hcr);\n\t\treturn 0;\n\t} else {\n\t\tprintk(KERN_DEBUG \"Readback test failed, HCR 0x%02x write %4ph read %4ph\\n\",\n\t\t       hcr, initseq, readbuf);\n\t\treturn 1;\n\t}\n}\n\n\nstatic int prism2_get_ram_size(local_info_t *local)\n{\n\tint ret;\n\n\t \n\tif (prism2_enable_genesis(local, 0x1f) == 0)\n\t\tret = 8;\n\telse if (prism2_enable_genesis(local, 0x0f) == 0)\n\t\tret = 16;\n\telse\n\t\tret = -1;\n\n\t \n\tlocal->func->genesis_reset(local, ret == 16 ? 0x07 : 0x17);\n\n\treturn ret;\n}\n\n\nstatic int prism2_download_genesis(local_info_t *local,\n\t\t\t\t   struct prism2_download_data *param)\n{\n\tstruct net_device *dev = local->dev;\n\tint ram16 = 0, i;\n\tint ret = 0;\n\n\tif (local->hw_downloading) {\n\t\tprintk(KERN_WARNING \"%s: Already downloading - aborting new \"\n\t\t       \"request\\n\", dev->name);\n\t\treturn -EBUSY;\n\t}\n\n\tif (!local->func->genesis_reset || !local->func->cor_sreset) {\n\t\tprintk(KERN_INFO \"%s: Genesis mode downloading not supported \"\n\t\t       \"with this hwmodel\\n\", dev->name);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tlocal->hw_downloading = 1;\n\n\tif (prism2_enable_aux_port(dev, 1)) {\n\t\tprintk(KERN_DEBUG \"%s: failed to enable AUX port\\n\",\n\t\t       dev->name);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (local->sram_type == -1) {\n\t\t \n\t\tif (prism2_enable_genesis(local, 0x1f) == 0) {\n\t\t\tram16 = 0;\n\t\t\tPDEBUG(DEBUG_EXTRA2, \"%s: Genesis mode OK using x8 \"\n\t\t\t       \"SRAM\\n\", dev->name);\n\t\t} else if (prism2_enable_genesis(local, 0x0f) == 0) {\n\t\t\tram16 = 1;\n\t\t\tPDEBUG(DEBUG_EXTRA2, \"%s: Genesis mode OK using x16 \"\n\t\t\t       \"SRAM\\n\", dev->name);\n\t\t} else {\n\t\t\tprintk(KERN_DEBUG \"%s: Could not initiate genesis \"\n\t\t\t       \"mode\\n\", dev->name);\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (prism2_enable_genesis(local, local->sram_type == 8 ?\n\t\t\t\t\t  0x1f : 0x0f)) {\n\t\t\tprintk(KERN_DEBUG \"%s: Failed to set Genesis \"\n\t\t\t       \"mode (sram_type=%d)\\n\", dev->name,\n\t\t\t       local->sram_type);\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tram16 = local->sram_type != 8;\n\t}\n\n\tfor (i = 0; i < param->num_areas; i++) {\n\t\tPDEBUG(DEBUG_EXTRA2, \"%s: Writing %d bytes at 0x%08x\\n\",\n\t\t       dev->name, param->data[i].len, param->data[i].addr);\n\t\tif (hfa384x_to_aux(dev, param->data[i].addr,\n\t\t\t\t   param->data[i].len, param->data[i].data)) {\n\t\t\tprintk(KERN_WARNING \"%s: RAM download at 0x%08x \"\n\t\t\t       \"(len=%d) failed\\n\", dev->name,\n\t\t\t       param->data[i].addr, param->data[i].len);\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tPDEBUG(DEBUG_EXTRA2, \"Disable genesis mode\\n\");\n\tlocal->func->genesis_reset(local, ram16 ? 0x07 : 0x17);\n\tif (prism2_enable_aux_port(dev, 0)) {\n\t\tprintk(KERN_DEBUG \"%s: Failed to disable AUX port\\n\",\n\t\t       dev->name);\n\t}\n\n\tmdelay(5);\n\tlocal->hw_downloading = 0;\n\n\tPDEBUG(DEBUG_EXTRA2, \"Trying to initialize card\\n\");\n\t \n\thfa384x_disable_interrupts(dev);\n\tif (prism2_hw_init(dev, 1)) {\n\t\tprintk(KERN_DEBUG \"%s: Initialization after genesis mode \"\n\t\t       \"download failed\\n\", dev->name);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tPDEBUG(DEBUG_EXTRA2, \"Card initialized - running PRI only\\n\");\n\tif (prism2_hw_init2(dev, 1)) {\n\t\tprintk(KERN_DEBUG \"%s: Initialization(2) after genesis mode \"\n\t\t       \"download failed\\n\", dev->name);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n out:\n\tlocal->hw_downloading = 0;\n\treturn ret;\n}\n\n\n#ifdef PRISM2_NON_VOLATILE_DOWNLOAD\n \n\nstatic inline int prism2_download_block(struct net_device *dev,\n\t\t\t\t\tu32 addr, u8 *data,\n\t\t\t\t\tu32 bufaddr, int rest_len)\n{\n\tu16 param0, param1;\n\tint block_len;\n\n\tblock_len = rest_len < 4096 ? rest_len : 4096;\n\n\tparam0 = addr & 0xffff;\n\tparam1 = addr >> 16;\n\n\tHFA384X_OUTW(block_len, HFA384X_PARAM2_OFF);\n\tHFA384X_OUTW(param1, HFA384X_PARAM1_OFF);\n\n\tif (hfa384x_cmd_wait(dev, HFA384X_CMDCODE_DOWNLOAD |\n\t\t\t     (HFA384X_PROGMODE_ENABLE_NON_VOLATILE << 8),\n\t\t\t     param0)) {\n\t\tprintk(KERN_WARNING \"%s: Flash download command execution \"\n\t\t       \"failed\\n\", dev->name);\n\t\treturn -1;\n\t}\n\n\tif (hfa384x_to_aux(dev, bufaddr, block_len, data)) {\n\t\tprintk(KERN_WARNING \"%s: flash download at 0x%08x \"\n\t\t       \"(len=%d) failed\\n\", dev->name, addr, block_len);\n\t\treturn -1;\n\t}\n\n\tHFA384X_OUTW(0, HFA384X_PARAM2_OFF);\n\tHFA384X_OUTW(0, HFA384X_PARAM1_OFF);\n\tif (hfa384x_cmd_wait(dev, HFA384X_CMDCODE_DOWNLOAD |\n\t\t\t     (HFA384X_PROGMODE_PROGRAM_NON_VOLATILE << 8),\n\t\t\t     0)) {\n\t\tprintk(KERN_WARNING \"%s: Flash write command execution \"\n\t\t       \"failed\\n\", dev->name);\n\t\treturn -1;\n\t}\n\n\treturn block_len;\n}\n\n\nstatic int prism2_download_nonvolatile(local_info_t *local,\n\t\t\t\t       struct prism2_download_data *dl)\n{\n\tstruct net_device *dev = local->dev;\n\tint ret = 0, i;\n\tstruct {\n\t\t__le16 page;\n\t\t__le16 offset;\n\t\t__le16 len;\n\t} dlbuffer;\n\tu32 bufaddr;\n\n\tif (local->hw_downloading) {\n\t\tprintk(KERN_WARNING \"%s: Already downloading - aborting new \"\n\t\t       \"request\\n\", dev->name);\n\t\treturn -1;\n\t}\n\n\tret = local->func->get_rid(dev, HFA384X_RID_DOWNLOADBUFFER,\n\t\t\t\t   &dlbuffer, 6, 0);\n\n\tif (ret < 0) {\n\t\tprintk(KERN_WARNING \"%s: Could not read download buffer \"\n\t\t       \"parameters\\n\", dev->name);\n\t\tgoto out;\n\t}\n\n\tprintk(KERN_DEBUG \"Download buffer: %d bytes at 0x%04x:0x%04x\\n\",\n\t       le16_to_cpu(dlbuffer.len),\n\t       le16_to_cpu(dlbuffer.page),\n\t       le16_to_cpu(dlbuffer.offset));\n\n\tbufaddr = (le16_to_cpu(dlbuffer.page) << 7) + le16_to_cpu(dlbuffer.offset);\n\n\tlocal->hw_downloading = 1;\n\n\tif (!local->pri_only) {\n\t\tprism2_hw_shutdown(dev, 0);\n\n\t\tif (prism2_hw_init(dev, 0)) {\n\t\t\tprintk(KERN_WARNING \"%s: Could not initialize card for\"\n\t\t\t       \" download\\n\", dev->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thfa384x_disable_interrupts(dev);\n\n\tif (prism2_enable_aux_port(dev, 1)) {\n\t\tprintk(KERN_WARNING \"%s: Could not enable AUX port\\n\",\n\t\t       dev->name);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tprintk(KERN_DEBUG \"%s: starting flash download\\n\", dev->name);\n\tfor (i = 0; i < dl->num_areas; i++) {\n\t\tint rest_len = dl->data[i].len;\n\t\tint data_off = 0;\n\n\t\twhile (rest_len > 0) {\n\t\t\tint block_len;\n\n\t\t\tblock_len = prism2_download_block(\n\t\t\t\tdev, dl->data[i].addr + data_off,\n\t\t\t\tdl->data[i].data + data_off, bufaddr,\n\t\t\t\trest_len);\n\n\t\t\tif (block_len < 0) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\trest_len -= block_len;\n\t\t\tdata_off += block_len;\n\t\t}\n\t}\n\n\tHFA384X_OUTW(0, HFA384X_PARAM1_OFF);\n\tHFA384X_OUTW(0, HFA384X_PARAM2_OFF);\n\tif (hfa384x_cmd_wait(dev, HFA384X_CMDCODE_DOWNLOAD |\n\t\t\t\t(HFA384X_PROGMODE_DISABLE << 8), 0)) {\n\t\tprintk(KERN_WARNING \"%s: Download command execution failed\\n\",\n\t\t       dev->name);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (prism2_enable_aux_port(dev, 0)) {\n\t\tprintk(KERN_DEBUG \"%s: Disabling AUX port failed\\n\",\n\t\t       dev->name);\n\t\t \n\t}\n\n\tmdelay(5);\n\n\tlocal->func->hw_reset(dev);\n\tlocal->hw_downloading = 0;\n\tif (prism2_hw_config(dev, 2)) {\n\t\tprintk(KERN_WARNING \"%s: Card configuration after flash \"\n\t\t       \"download failed\\n\", dev->name);\n\t\tret = -1;\n\t} else {\n\t\tprintk(KERN_INFO \"%s: Card initialized successfully after \"\n\t\t       \"flash download\\n\", dev->name);\n\t}\n\n out:\n\tlocal->hw_downloading = 0;\n\treturn ret;\n}\n#endif  \n\n\nstatic void prism2_download_free_data(struct prism2_download_data *dl)\n{\n\tint i;\n\n\tif (dl == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < dl->num_areas; i++)\n\t\tkfree(dl->data[i].data);\n\tkfree(dl);\n}\n\n\nstatic int prism2_download(local_info_t *local,\n\t\t\t   struct prism2_download_param *param)\n{\n\tint ret = 0;\n\tint i;\n\tu32 total_len = 0;\n\tstruct prism2_download_data *dl = NULL;\n\n\tprintk(KERN_DEBUG \"prism2_download: dl_cmd=%d start_addr=0x%08x \"\n\t       \"num_areas=%d\\n\",\n\t       param->dl_cmd, param->start_addr, param->num_areas);\n\n\tif (param->num_areas > 100) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdl = kzalloc(sizeof(*dl) + param->num_areas *\n\t\t     sizeof(struct prism2_download_data_area), GFP_KERNEL);\n\tif (dl == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tdl->dl_cmd = param->dl_cmd;\n\tdl->start_addr = param->start_addr;\n\tdl->num_areas = param->num_areas;\n\tfor (i = 0; i < param->num_areas; i++) {\n\t\tPDEBUG(DEBUG_EXTRA2,\n\t\t       \"  area %d: addr=0x%08x len=%d ptr=0x%p\\n\",\n\t\t       i, param->data[i].addr, param->data[i].len,\n\t\t       param->data[i].ptr);\n\n\t\tdl->data[i].addr = param->data[i].addr;\n\t\tdl->data[i].len = param->data[i].len;\n\n\t\ttotal_len += param->data[i].len;\n\t\tif (param->data[i].len > PRISM2_MAX_DOWNLOAD_AREA_LEN ||\n\t\t    total_len > PRISM2_MAX_DOWNLOAD_LEN) {\n\t\t\tret = -E2BIG;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdl->data[i].data = kmalloc(dl->data[i].len, GFP_KERNEL);\n\t\tif (dl->data[i].data == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (copy_from_user(dl->data[i].data, param->data[i].ptr,\n\t\t\t\t   param->data[i].len)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (param->dl_cmd) {\n\tcase PRISM2_DOWNLOAD_VOLATILE:\n\tcase PRISM2_DOWNLOAD_VOLATILE_PERSISTENT:\n\t\tret = prism2_download_volatile(local, dl);\n\t\tbreak;\n\tcase PRISM2_DOWNLOAD_VOLATILE_GENESIS:\n\tcase PRISM2_DOWNLOAD_VOLATILE_GENESIS_PERSISTENT:\n\t\tret = prism2_download_genesis(local, dl);\n\t\tbreak;\n\tcase PRISM2_DOWNLOAD_NON_VOLATILE:\n#ifdef PRISM2_NON_VOLATILE_DOWNLOAD\n\t\tret = prism2_download_nonvolatile(local, dl);\n#else  \n\t\tprintk(KERN_INFO \"%s: non-volatile downloading not enabled\\n\",\n\t\t       local->dev->name);\n\t\tret = -EOPNOTSUPP;\n#endif  \n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_DEBUG \"%s: unsupported download command %d\\n\",\n\t\t       local->dev->name, param->dl_cmd);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n out:\n\tif (ret == 0 && dl &&\n\t    param->dl_cmd == PRISM2_DOWNLOAD_VOLATILE_GENESIS_PERSISTENT) {\n\t\tprism2_download_free_data(local->dl_pri);\n\t\tlocal->dl_pri = dl;\n\t} else if (ret == 0 && dl &&\n\t\t   param->dl_cmd == PRISM2_DOWNLOAD_VOLATILE_PERSISTENT) {\n\t\tprism2_download_free_data(local->dl_sec);\n\t\tlocal->dl_sec = dl;\n\t} else\n\t\tprism2_download_free_data(dl);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}