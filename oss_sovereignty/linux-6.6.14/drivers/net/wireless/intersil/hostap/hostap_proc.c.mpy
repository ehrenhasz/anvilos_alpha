{
  "module_name": "hostap_proc.c",
  "hash_id": "c7d4d62645430843213a95a0344176d96dfbb0a8d740a5c280c0b8d26e48f77d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/hostap/hostap_proc.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n#include <net/lib80211.h>\n\n#include \"hostap_wlan.h\"\n#include \"hostap.h\"\n\n#define PROC_LIMIT (PAGE_SIZE - 80)\n\n#if !defined(PRISM2_NO_PROCFS_DEBUG) && defined(CONFIG_PROC_FS)\nstatic int prism2_debug_proc_show(struct seq_file *m, void *v)\n{\n\tlocal_info_t *local = m->private;\n\tint i;\n\n\tseq_printf(m, \"next_txfid=%d next_alloc=%d\\n\",\n\t\t   local->next_txfid, local->next_alloc);\n\tfor (i = 0; i < PRISM2_TXFID_COUNT; i++)\n\t\tseq_printf(m, \"FID: tx=%04X intransmit=%04X\\n\",\n\t\t\t   local->txfid[i], local->intransmitfid[i]);\n\tseq_printf(m, \"FW TX rate control: %d\\n\", local->fw_tx_rate_control);\n\tseq_printf(m, \"beacon_int=%d\\n\", local->beacon_int);\n\tseq_printf(m, \"dtim_period=%d\\n\", local->dtim_period);\n\tseq_printf(m, \"wds_max_connections=%d\\n\", local->wds_max_connections);\n\tseq_printf(m, \"dev_enabled=%d\\n\", local->dev_enabled);\n\tseq_printf(m, \"sw_tick_stuck=%d\\n\", local->sw_tick_stuck);\n\tfor (i = 0; i < WEP_KEYS; i++) {\n\t\tif (local->crypt_info.crypt[i] &&\n\t\t    local->crypt_info.crypt[i]->ops) {\n\t\t\tseq_printf(m, \"crypt[%d]=%s\\n\", i,\n\t\t\t\t   local->crypt_info.crypt[i]->ops->name);\n\t\t}\n\t}\n\tseq_printf(m, \"pri_only=%d\\n\", local->pri_only);\n\tseq_printf(m, \"pci=%d\\n\", local->func->hw_type == HOSTAP_HW_PCI);\n\tseq_printf(m, \"sram_type=%d\\n\", local->sram_type);\n\tseq_printf(m, \"no_pri=%d\\n\", local->no_pri);\n\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_PROC_FS\nstatic int prism2_stats_proc_show(struct seq_file *m, void *v)\n{\n\tlocal_info_t *local = m->private;\n\tstruct comm_tallies_sums *sums = &local->comm_tallies;\n\n\tseq_printf(m, \"TxUnicastFrames=%u\\n\", sums->tx_unicast_frames);\n\tseq_printf(m, \"TxMulticastframes=%u\\n\", sums->tx_multicast_frames);\n\tseq_printf(m, \"TxFragments=%u\\n\", sums->tx_fragments);\n\tseq_printf(m, \"TxUnicastOctets=%u\\n\", sums->tx_unicast_octets);\n\tseq_printf(m, \"TxMulticastOctets=%u\\n\", sums->tx_multicast_octets);\n\tseq_printf(m, \"TxDeferredTransmissions=%u\\n\",\n\t\t   sums->tx_deferred_transmissions);\n\tseq_printf(m, \"TxSingleRetryFrames=%u\\n\", sums->tx_single_retry_frames);\n\tseq_printf(m, \"TxMultipleRetryFrames=%u\\n\",\n\t\t   sums->tx_multiple_retry_frames);\n\tseq_printf(m, \"TxRetryLimitExceeded=%u\\n\",\n\t\t   sums->tx_retry_limit_exceeded);\n\tseq_printf(m, \"TxDiscards=%u\\n\", sums->tx_discards);\n\tseq_printf(m, \"RxUnicastFrames=%u\\n\", sums->rx_unicast_frames);\n\tseq_printf(m, \"RxMulticastFrames=%u\\n\", sums->rx_multicast_frames);\n\tseq_printf(m, \"RxFragments=%u\\n\", sums->rx_fragments);\n\tseq_printf(m, \"RxUnicastOctets=%u\\n\", sums->rx_unicast_octets);\n\tseq_printf(m, \"RxMulticastOctets=%u\\n\", sums->rx_multicast_octets);\n\tseq_printf(m, \"RxFCSErrors=%u\\n\", sums->rx_fcs_errors);\n\tseq_printf(m, \"RxDiscardsNoBuffer=%u\\n\", sums->rx_discards_no_buffer);\n\tseq_printf(m, \"TxDiscardsWrongSA=%u\\n\", sums->tx_discards_wrong_sa);\n\tseq_printf(m, \"RxDiscardsWEPUndecryptable=%u\\n\",\n\t\t   sums->rx_discards_wep_undecryptable);\n\tseq_printf(m, \"RxMessageInMsgFragments=%u\\n\",\n\t\t   sums->rx_message_in_msg_fragments);\n\tseq_printf(m, \"RxMessageInBadMsgFragments=%u\\n\",\n\t\t   sums->rx_message_in_bad_msg_fragments);\n\t \n\n\treturn 0;\n}\n#endif\n\nstatic int prism2_wds_proc_show(struct seq_file *m, void *v)\n{\n\tstruct list_head *ptr = v;\n\tstruct hostap_interface *iface;\n\n\tiface = list_entry(ptr, struct hostap_interface, list);\n\tif (iface->type == HOSTAP_INTERFACE_WDS)\n\t\tseq_printf(m, \"%s\\t%pM\\n\",\n\t\t\t   iface->dev->name, iface->u.wds.remote_addr);\n\treturn 0;\n}\n\nstatic void *prism2_wds_proc_start(struct seq_file *m, loff_t *_pos)\n{\n\tlocal_info_t *local = pde_data(file_inode(m->file));\n\tread_lock_bh(&local->iface_lock);\n\treturn seq_list_start(&local->hostap_interfaces, *_pos);\n}\n\nstatic void *prism2_wds_proc_next(struct seq_file *m, void *v, loff_t *_pos)\n{\n\tlocal_info_t *local = pde_data(file_inode(m->file));\n\treturn seq_list_next(v, &local->hostap_interfaces, _pos);\n}\n\nstatic void prism2_wds_proc_stop(struct seq_file *m, void *v)\n{\n\tlocal_info_t *local = pde_data(file_inode(m->file));\n\tread_unlock_bh(&local->iface_lock);\n}\n\nstatic const struct seq_operations prism2_wds_proc_seqops = {\n\t.start\t= prism2_wds_proc_start,\n\t.next\t= prism2_wds_proc_next,\n\t.stop\t= prism2_wds_proc_stop,\n\t.show\t= prism2_wds_proc_show,\n};\n\nstatic int prism2_bss_list_proc_show(struct seq_file *m, void *v)\n{\n\tlocal_info_t *local = pde_data(file_inode(m->file));\n\tstruct list_head *ptr = v;\n\tstruct hostap_bss_info *bss;\n\n\tif (ptr == &local->bss_list) {\n\t\tseq_printf(m, \"#BSSID\\tlast_update\\tcount\\tcapab_info\\tSSID(txt)\\t\"\n\t\t\t   \"SSID(hex)\\tWPA IE\\n\");\n\t\treturn 0;\n\t}\n\n\tbss = list_entry(ptr, struct hostap_bss_info, list);\n\tseq_printf(m, \"%pM\\t%lu\\t%u\\t0x%x\\t\",\n\t\t   bss->bssid, bss->last_update,\n\t\t   bss->count, bss->capab_info);\n\n\tseq_printf(m, \"%*pE\", (int)bss->ssid_len, bss->ssid);\n\n\tseq_putc(m, '\\t');\n\tseq_printf(m, \"%*phN\", (int)bss->ssid_len, bss->ssid);\n\tseq_putc(m, '\\t');\n\tseq_printf(m, \"%*phN\", (int)bss->wpa_ie_len, bss->wpa_ie);\n\tseq_putc(m, '\\n');\n\treturn 0;\n}\n\nstatic void *prism2_bss_list_proc_start(struct seq_file *m, loff_t *_pos)\n\t__acquires(&local->lock)\n{\n\tlocal_info_t *local = pde_data(file_inode(m->file));\n\tspin_lock_bh(&local->lock);\n\treturn seq_list_start_head(&local->bss_list, *_pos);\n}\n\nstatic void *prism2_bss_list_proc_next(struct seq_file *m, void *v, loff_t *_pos)\n{\n\tlocal_info_t *local = pde_data(file_inode(m->file));\n\treturn seq_list_next(v, &local->bss_list, _pos);\n}\n\nstatic void prism2_bss_list_proc_stop(struct seq_file *m, void *v)\n\t__releases(&local->lock)\n{\n\tlocal_info_t *local = pde_data(file_inode(m->file));\n\tspin_unlock_bh(&local->lock);\n}\n\nstatic const struct seq_operations prism2_bss_list_proc_seqops = {\n\t.start\t= prism2_bss_list_proc_start,\n\t.next\t= prism2_bss_list_proc_next,\n\t.stop\t= prism2_bss_list_proc_stop,\n\t.show\t= prism2_bss_list_proc_show,\n};\n\n#ifdef CONFIG_PROC_FS\nstatic int prism2_crypt_proc_show(struct seq_file *m, void *v)\n{\n\tlocal_info_t *local = m->private;\n\tint i;\n\n\tseq_printf(m, \"tx_keyidx=%d\\n\", local->crypt_info.tx_keyidx);\n\tfor (i = 0; i < WEP_KEYS; i++) {\n\t\tif (local->crypt_info.crypt[i] &&\n\t\t    local->crypt_info.crypt[i]->ops &&\n\t\t    local->crypt_info.crypt[i]->ops->print_stats) {\n\t\t\tlocal->crypt_info.crypt[i]->ops->print_stats(\n\t\t\t\tm, local->crypt_info.crypt[i]->priv);\n\t\t}\n\t}\n\treturn 0;\n}\n#endif\n\nstatic ssize_t prism2_pda_proc_read(struct file *file, char __user *buf,\n\t\t\t\t    size_t count, loff_t *_pos)\n{\n\tlocal_info_t *local = pde_data(file_inode(file));\n\tsize_t off;\n\n\tif (local->pda == NULL || *_pos >= PRISM2_PDA_SIZE)\n\t\treturn 0;\n\n\toff = *_pos;\n\tif (count > PRISM2_PDA_SIZE - off)\n\t\tcount = PRISM2_PDA_SIZE - off;\n\tif (copy_to_user(buf, local->pda + off, count) != 0)\n\t\treturn -EFAULT;\n\t*_pos += count;\n\treturn count;\n}\n\nstatic const struct proc_ops prism2_pda_proc_ops = {\n\t.proc_read\t= prism2_pda_proc_read,\n\t.proc_lseek\t= generic_file_llseek,\n};\n\n\nstatic ssize_t prism2_aux_dump_proc_no_read(struct file *file, char __user *buf,\n\t\t\t\t\t    size_t bufsize, loff_t *_pos)\n{\n\treturn 0;\n}\n\nstatic const struct proc_ops prism2_aux_dump_proc_ops = {\n\t.proc_read\t= prism2_aux_dump_proc_no_read,\n\t.proc_lseek\t= default_llseek,\n};\n\n\n#ifdef PRISM2_IO_DEBUG\nstatic int prism2_io_debug_proc_read(char *page, char **start, off_t off,\n\t\t\t\t     int count, int *eof, void *data)\n{\n\tlocal_info_t *local = (local_info_t *) data;\n\tint head = local->io_debug_head;\n\tint start_bytes, left, copy;\n\n\tif (off + count > PRISM2_IO_DEBUG_SIZE * 4) {\n\t\t*eof = 1;\n\t\tif (off >= PRISM2_IO_DEBUG_SIZE * 4)\n\t\t\treturn 0;\n\t\tcount = PRISM2_IO_DEBUG_SIZE * 4 - off;\n\t}\n\n\tstart_bytes = (PRISM2_IO_DEBUG_SIZE - head) * 4;\n\tleft = count;\n\n\tif (off < start_bytes) {\n\t\tcopy = start_bytes - off;\n\t\tif (copy > count)\n\t\t\tcopy = count;\n\t\tmemcpy(page, ((u8 *) &local->io_debug[head]) + off, copy);\n\t\tleft -= copy;\n\t\tif (left > 0)\n\t\t\tmemcpy(&page[copy], local->io_debug, left);\n\t} else {\n\t\tmemcpy(page, ((u8 *) local->io_debug) + (off - start_bytes),\n\t\t       left);\n\t}\n\n\t*start = page;\n\n\treturn count;\n}\n#endif  \n\n\n#ifndef PRISM2_NO_STATION_MODES\nstatic int prism2_scan_results_proc_show(struct seq_file *m, void *v)\n{\n\tlocal_info_t *local = pde_data(file_inode(m->file));\n\tunsigned long entry;\n\tint i, len;\n\tstruct hfa384x_hostscan_result *scanres;\n\tu8 *p;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_printf(m,\n\t\t\t   \"CHID ANL SL BcnInt Capab Rate BSSID ATIM SupRates SSID\\n\");\n\t\treturn 0;\n\t}\n\n\tentry = (unsigned long)v - 2;\n\tscanres = &local->last_scan_results[entry];\n\n\tseq_printf(m, \"%d %d %d %d 0x%02x %d %pM %d \",\n\t\t   le16_to_cpu(scanres->chid),\n\t\t   (s16) le16_to_cpu(scanres->anl),\n\t\t   (s16) le16_to_cpu(scanres->sl),\n\t\t   le16_to_cpu(scanres->beacon_interval),\n\t\t   le16_to_cpu(scanres->capability),\n\t\t   le16_to_cpu(scanres->rate),\n\t\t   scanres->bssid,\n\t\t   le16_to_cpu(scanres->atim));\n\n\tp = scanres->sup_rates;\n\tfor (i = 0; i < sizeof(scanres->sup_rates); i++) {\n\t\tif (p[i] == 0)\n\t\t\tbreak;\n\t\tseq_printf(m, \"<%02x>\", p[i]);\n\t}\n\tseq_putc(m, ' ');\n\n\tp = scanres->ssid;\n\tlen = le16_to_cpu(scanres->ssid_len);\n\tif (len > 32)\n\t\tlen = 32;\n\tfor (i = 0; i < len; i++) {\n\t\tunsigned char c = p[i];\n\t\tif (c >= 32 && c < 127)\n\t\t\tseq_putc(m, c);\n\t\telse\n\t\t\tseq_printf(m, \"<%02x>\", c);\n\t}\n\tseq_putc(m, '\\n');\n\treturn 0;\n}\n\nstatic void *prism2_scan_results_proc_start(struct seq_file *m, loff_t *_pos)\n{\n\tlocal_info_t *local = pde_data(file_inode(m->file));\n\tspin_lock_bh(&local->lock);\n\n\t \n\tif (*_pos > local->last_scan_results_count)\n\t\treturn NULL;\n\treturn (void *)(unsigned long)(*_pos + 1);  \n}\n\nstatic void *prism2_scan_results_proc_next(struct seq_file *m, void *v, loff_t *_pos)\n{\n\tlocal_info_t *local = pde_data(file_inode(m->file));\n\n\t++*_pos;\n\tif (*_pos > local->last_scan_results_count)\n\t\treturn NULL;\n\treturn (void *)(unsigned long)(*_pos + 1);  \n}\n\nstatic void prism2_scan_results_proc_stop(struct seq_file *m, void *v)\n{\n\tlocal_info_t *local = pde_data(file_inode(m->file));\n\tspin_unlock_bh(&local->lock);\n}\n\nstatic const struct seq_operations prism2_scan_results_proc_seqops = {\n\t.start\t= prism2_scan_results_proc_start,\n\t.next\t= prism2_scan_results_proc_next,\n\t.stop\t= prism2_scan_results_proc_stop,\n\t.show\t= prism2_scan_results_proc_show,\n};\n#endif  \n\n\nvoid hostap_init_proc(local_info_t *local)\n{\n\tlocal->proc = NULL;\n\n\tif (hostap_proc == NULL) {\n\t\tprintk(KERN_WARNING \"%s: hostap proc directory not created\\n\",\n\t\t       local->dev->name);\n\t\treturn;\n\t}\n\n\tlocal->proc = proc_mkdir(local->ddev->name, hostap_proc);\n\tif (local->proc == NULL) {\n\t\tprintk(KERN_INFO \"/proc/net/hostap/%s creation failed\\n\",\n\t\t       local->ddev->name);\n\t\treturn;\n\t}\n\n#ifndef PRISM2_NO_PROCFS_DEBUG\n\tproc_create_single_data(\"debug\", 0, local->proc,\n\t\t\tprism2_debug_proc_show, local);\n#endif  \n\tproc_create_single_data(\"stats\", 0, local->proc, prism2_stats_proc_show,\n\t\t\tlocal);\n\tproc_create_seq_data(\"wds\", 0, local->proc,\n\t\t\t&prism2_wds_proc_seqops, local);\n\tproc_create_data(\"pda\", 0, local->proc,\n\t\t\t &prism2_pda_proc_ops, local);\n\tproc_create_data(\"aux_dump\", 0, local->proc,\n\t\t\t local->func->read_aux_proc_ops ?: &prism2_aux_dump_proc_ops,\n\t\t\t local);\n\tproc_create_seq_data(\"bss_list\", 0, local->proc,\n\t\t\t&prism2_bss_list_proc_seqops, local);\n\tproc_create_single_data(\"crypt\", 0, local->proc, prism2_crypt_proc_show,\n\t\tlocal);\n#ifdef PRISM2_IO_DEBUG\n\tproc_create_single_data(\"io_debug\", 0, local->proc,\n\t\t\tprism2_debug_proc_show, local);\n#endif  \n#ifndef PRISM2_NO_STATION_MODES\n\tproc_create_seq_data(\"scan_results\", 0, local->proc,\n\t\t\t&prism2_scan_results_proc_seqops, local);\n#endif  \n}\n\n\nvoid hostap_remove_proc(local_info_t *local)\n{\n\tproc_remove(local->proc);\n}\n\n\nEXPORT_SYMBOL(hostap_init_proc);\nEXPORT_SYMBOL(hostap_remove_proc);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}