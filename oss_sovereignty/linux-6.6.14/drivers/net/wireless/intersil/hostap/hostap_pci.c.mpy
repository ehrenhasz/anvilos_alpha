{
  "module_name": "hostap_pci.c",
  "hash_id": "acad9850be59e39bf6fd202ef6de48115731db7c48539375eaaccf52a5e3a321",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/hostap/hostap_pci.c",
  "human_readable_source": "\n#define PRISM2_PCI\n\n \n\n#include <linux/module.h>\n#include <linux/if.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/wireless.h>\n#include <net/iw_handler.h>\n\n#include <linux/ioport.h>\n#include <linux/pci.h>\n#include <asm/io.h>\n\n#include \"hostap_wlan.h\"\n\n\nstatic char *dev_info = \"hostap_pci\";\n\n\nMODULE_AUTHOR(\"Jouni Malinen\");\nMODULE_DESCRIPTION(\"Support for Intersil Prism2.5-based 802.11 wireless LAN \"\n\t\t   \"PCI cards.\");\nMODULE_LICENSE(\"GPL\");\n\n\n \nstruct hostap_pci_priv {\n\tvoid __iomem *mem_start;\n};\n\n\n \n\n\nstatic const struct pci_device_id prism2_pci_id_table[] = {\n\t \n\t{ 0x1260, 0x3872, PCI_ANY_ID, PCI_ANY_ID },\n\t \n\t{ 0x1260, 0x3873, PCI_ANY_ID, PCI_ANY_ID },\n\t \n\t{ 0x167d, 0xa000, PCI_ANY_ID, PCI_ANY_ID },\n\t{ 0 }\n};\n\n\n#ifdef PRISM2_IO_DEBUG\n\nstatic inline void hfa384x_outb_debug(struct net_device *dev, int a, u8 v)\n{\n\tstruct hostap_interface *iface;\n\tstruct hostap_pci_priv *hw_priv;\n\tlocal_info_t *local;\n\tunsigned long flags;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\thw_priv = local->hw_priv;\n\n\tspin_lock_irqsave(&local->lock, flags);\n\tprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_OUTB, a, v);\n\twriteb(v, hw_priv->mem_start + a);\n\tspin_unlock_irqrestore(&local->lock, flags);\n}\n\nstatic inline u8 hfa384x_inb_debug(struct net_device *dev, int a)\n{\n\tstruct hostap_interface *iface;\n\tstruct hostap_pci_priv *hw_priv;\n\tlocal_info_t *local;\n\tunsigned long flags;\n\tu8 v;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\thw_priv = local->hw_priv;\n\n\tspin_lock_irqsave(&local->lock, flags);\n\tv = readb(hw_priv->mem_start + a);\n\tprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_INB, a, v);\n\tspin_unlock_irqrestore(&local->lock, flags);\n\treturn v;\n}\n\nstatic inline void hfa384x_outw_debug(struct net_device *dev, int a, u16 v)\n{\n\tstruct hostap_interface *iface;\n\tstruct hostap_pci_priv *hw_priv;\n\tlocal_info_t *local;\n\tunsigned long flags;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\thw_priv = local->hw_priv;\n\n\tspin_lock_irqsave(&local->lock, flags);\n\tprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_OUTW, a, v);\n\twritew(v, hw_priv->mem_start + a);\n\tspin_unlock_irqrestore(&local->lock, flags);\n}\n\nstatic inline u16 hfa384x_inw_debug(struct net_device *dev, int a)\n{\n\tstruct hostap_interface *iface;\n\tstruct hostap_pci_priv *hw_priv;\n\tlocal_info_t *local;\n\tunsigned long flags;\n\tu16 v;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\thw_priv = local->hw_priv;\n\n\tspin_lock_irqsave(&local->lock, flags);\n\tv = readw(hw_priv->mem_start + a);\n\tprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_INW, a, v);\n\tspin_unlock_irqrestore(&local->lock, flags);\n\treturn v;\n}\n\n#define HFA384X_OUTB(v,a) hfa384x_outb_debug(dev, (a), (v))\n#define HFA384X_INB(a) hfa384x_inb_debug(dev, (a))\n#define HFA384X_OUTW(v,a) hfa384x_outw_debug(dev, (a), (v))\n#define HFA384X_INW(a) hfa384x_inw_debug(dev, (a))\n#define HFA384X_OUTW_DATA(v,a) hfa384x_outw_debug(dev, (a), le16_to_cpu((v)))\n#define HFA384X_INW_DATA(a) cpu_to_le16(hfa384x_inw_debug(dev, (a)))\n\n#else  \n\nstatic inline void hfa384x_outb(struct net_device *dev, int a, u8 v)\n{\n\tstruct hostap_interface *iface;\n\tstruct hostap_pci_priv *hw_priv;\n\tiface = netdev_priv(dev);\n\thw_priv = iface->local->hw_priv;\n\twriteb(v, hw_priv->mem_start + a);\n}\n\nstatic inline u8 hfa384x_inb(struct net_device *dev, int a)\n{\n\tstruct hostap_interface *iface;\n\tstruct hostap_pci_priv *hw_priv;\n\tiface = netdev_priv(dev);\n\thw_priv = iface->local->hw_priv;\n\treturn readb(hw_priv->mem_start + a);\n}\n\nstatic inline void hfa384x_outw(struct net_device *dev, int a, u16 v)\n{\n\tstruct hostap_interface *iface;\n\tstruct hostap_pci_priv *hw_priv;\n\tiface = netdev_priv(dev);\n\thw_priv = iface->local->hw_priv;\n\twritew(v, hw_priv->mem_start + a);\n}\n\nstatic inline u16 hfa384x_inw(struct net_device *dev, int a)\n{\n\tstruct hostap_interface *iface;\n\tstruct hostap_pci_priv *hw_priv;\n\tiface = netdev_priv(dev);\n\thw_priv = iface->local->hw_priv;\n\treturn readw(hw_priv->mem_start + a);\n}\n\n#define HFA384X_OUTB(v,a) hfa384x_outb(dev, (a), (v))\n#define HFA384X_INB(a) hfa384x_inb(dev, (a))\n#define HFA384X_OUTW(v,a) hfa384x_outw(dev, (a), (v))\n#define HFA384X_INW(a) hfa384x_inw(dev, (a))\n#define HFA384X_OUTW_DATA(v,a) hfa384x_outw(dev, (a), le16_to_cpu((v)))\n#define HFA384X_INW_DATA(a) cpu_to_le16(hfa384x_inw(dev, (a)))\n\n#endif  \n\n\nstatic int hfa384x_from_bap(struct net_device *dev, u16 bap, void *buf,\n\t\t\t    int len)\n{\n\tu16 d_off;\n\t__le16 *pos;\n\n\td_off = (bap == 1) ? HFA384X_DATA1_OFF : HFA384X_DATA0_OFF;\n\tpos = (__le16 *) buf;\n\n\tfor ( ; len > 1; len -= 2)\n\t\t*pos++ = HFA384X_INW_DATA(d_off);\n\n\tif (len & 1)\n\t\t*((char *) pos) = HFA384X_INB(d_off);\n\n\treturn 0;\n}\n\n\nstatic int hfa384x_to_bap(struct net_device *dev, u16 bap, void *buf, int len)\n{\n\tu16 d_off;\n\t__le16 *pos;\n\n\td_off = (bap == 1) ? HFA384X_DATA1_OFF : HFA384X_DATA0_OFF;\n\tpos = (__le16 *) buf;\n\n\tfor ( ; len > 1; len -= 2)\n\t\tHFA384X_OUTW_DATA(*pos++, d_off);\n\n\tif (len & 1)\n\t\tHFA384X_OUTB(*((char *) pos), d_off);\n\n\treturn 0;\n}\n\n\n \n#include \"hostap_hw.c\"\n\nstatic void prism2_pci_cor_sreset(local_info_t *local)\n{\n\tstruct net_device *dev = local->dev;\n\tu16 reg;\n\n\treg = HFA384X_INB(HFA384X_PCICOR_OFF);\n\tprintk(KERN_DEBUG \"%s: Original COR value: 0x%0x\\n\", dev->name, reg);\n\n\t \n \n\n#ifdef PRISM2_PCI_USE_LONG_DELAYS\n\tint i;\n\n\tHFA384X_OUTW(reg | 0x0080, HFA384X_PCICOR_OFF);\n\tmdelay(250);\n\n\tHFA384X_OUTW(reg & ~0x0080, HFA384X_PCICOR_OFF);\n\tmdelay(500);\n\n\t \n\ti = 2000000 / 10;\n\twhile ((HFA384X_INW(HFA384X_CMD_OFF) & HFA384X_CMD_BUSY) && --i)\n\t\tudelay(10);\n\n#else  \n\n\tHFA384X_OUTW(reg | 0x0080, HFA384X_PCICOR_OFF);\n\tmdelay(2);\n\tHFA384X_OUTW(reg & ~0x0080, HFA384X_PCICOR_OFF);\n\tmdelay(2);\n\n#endif  \n\n\tif (HFA384X_INW(HFA384X_CMD_OFF) & HFA384X_CMD_BUSY) {\n\t\tprintk(KERN_DEBUG \"%s: COR sreset timeout\\n\", dev->name);\n\t}\n}\n\n\nstatic void prism2_pci_genesis_reset(local_info_t *local, int hcr)\n{\n\tstruct net_device *dev = local->dev;\n\n\tHFA384X_OUTW(0x00C5, HFA384X_PCICOR_OFF);\n\tmdelay(10);\n\tHFA384X_OUTW(hcr, HFA384X_PCIHCR_OFF);\n\tmdelay(10);\n\tHFA384X_OUTW(0x0045, HFA384X_PCICOR_OFF);\n\tmdelay(10);\n}\n\n\nstatic struct prism2_helper_functions prism2_pci_funcs =\n{\n\t.card_present\t= NULL,\n\t.cor_sreset\t= prism2_pci_cor_sreset,\n\t.genesis_reset\t= prism2_pci_genesis_reset,\n\t.hw_type\t= HOSTAP_HW_PCI,\n};\n\n\nstatic int prism2_pci_probe(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *id)\n{\n\tunsigned long phymem;\n\tvoid __iomem *mem = NULL;\n\tlocal_info_t *local = NULL;\n\tstruct net_device *dev = NULL;\n\tstatic int cards_found  ;\n\tint irq_registered = 0;\n\tstruct hostap_interface *iface;\n\tstruct hostap_pci_priv *hw_priv;\n\n\thw_priv = kzalloc(sizeof(*hw_priv), GFP_KERNEL);\n\tif (hw_priv == NULL)\n\t\treturn -ENOMEM;\n\n\tif (pci_enable_device(pdev))\n\t\tgoto err_out_free;\n\n\tphymem = pci_resource_start(pdev, 0);\n\n\tif (!request_mem_region(phymem, pci_resource_len(pdev, 0), \"Prism2\")) {\n\t\tprintk(KERN_ERR \"prism2: Cannot reserve PCI memory region\\n\");\n\t\tgoto err_out_disable;\n\t}\n\n\tmem = pci_ioremap_bar(pdev, 0);\n\tif (mem == NULL) {\n\t\tprintk(KERN_ERR \"prism2: Cannot remap PCI memory region\\n\") ;\n\t\tgoto fail;\n\t}\n\n\tdev = prism2_init_local_data(&prism2_pci_funcs, cards_found,\n\t\t\t\t     &pdev->dev);\n\tif (dev == NULL)\n\t\tgoto fail;\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\tlocal->hw_priv = hw_priv;\n\tcards_found++;\n\n        dev->irq = pdev->irq;\n        hw_priv->mem_start = mem;\n\tdev->base_addr = (unsigned long) mem;\n\n\tprism2_pci_cor_sreset(local);\n\n\tpci_set_drvdata(pdev, dev);\n\n\tif (request_irq(dev->irq, prism2_interrupt, IRQF_SHARED, dev->name,\n\t\t\tdev)) {\n\t\tprintk(KERN_WARNING \"%s: request_irq failed\\n\", dev->name);\n\t\tgoto fail;\n\t} else\n\t\tirq_registered = 1;\n\n\tif (!local->pri_only && prism2_hw_config(dev, 1)) {\n\t\tprintk(KERN_DEBUG \"%s: hardware initialization failed\\n\",\n\t\t       dev_info);\n\t\tgoto fail;\n\t}\n\n\tprintk(KERN_INFO \"%s: Intersil Prism2.5 PCI: \"\n\t       \"mem=0x%lx, irq=%d\\n\", dev->name, phymem, dev->irq);\n\n\treturn hostap_hw_ready(dev);\n\n fail:\n\tif (irq_registered && dev)\n\t\tfree_irq(dev->irq, dev);\n\n\tif (mem)\n\t\tiounmap(mem);\n\n\trelease_mem_region(phymem, pci_resource_len(pdev, 0));\n\n err_out_disable:\n\tpci_disable_device(pdev);\n\tprism2_free_local_data(dev);\n\n err_out_free:\n\tkfree(hw_priv);\n\n\treturn -ENODEV;\n}\n\n\nstatic void prism2_pci_remove(struct pci_dev *pdev)\n{\n\tstruct net_device *dev;\n\tstruct hostap_interface *iface;\n\tvoid __iomem *mem_start;\n\tstruct hostap_pci_priv *hw_priv;\n\n\tdev = pci_get_drvdata(pdev);\n\tiface = netdev_priv(dev);\n\thw_priv = iface->local->hw_priv;\n\n\t \n\tprism2_pci_cor_sreset(iface->local);\n\thfa384x_disable_interrupts(dev);\n\n\tif (dev->irq)\n\t\tfree_irq(dev->irq, dev);\n\n\tmem_start = hw_priv->mem_start;\n\tprism2_free_local_data(dev);\n\tkfree(hw_priv);\n\n\tiounmap(mem_start);\n\n\trelease_mem_region(pci_resource_start(pdev, 0),\n\t\t\t   pci_resource_len(pdev, 0));\n\tpci_disable_device(pdev);\n}\n\nstatic int __maybe_unused prism2_pci_suspend(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\n\tif (netif_running(dev)) {\n\t\tnetif_stop_queue(dev);\n\t\tnetif_device_detach(dev);\n\t}\n\tprism2_suspend(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused prism2_pci_resume(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\n\tprism2_hw_config(dev, 0);\n\tif (netif_running(dev)) {\n\t\tnetif_device_attach(dev);\n\t\tnetif_start_queue(dev);\n\t}\n\n\treturn 0;\n}\n\nMODULE_DEVICE_TABLE(pci, prism2_pci_id_table);\n\nstatic SIMPLE_DEV_PM_OPS(prism2_pci_pm_ops,\n\t\t\t prism2_pci_suspend,\n\t\t\t prism2_pci_resume);\n\nstatic struct pci_driver prism2_pci_driver = {\n\t.name\t\t= \"hostap_pci\",\n\t.id_table\t= prism2_pci_id_table,\n\t.probe\t\t= prism2_pci_probe,\n\t.remove\t\t= prism2_pci_remove,\n\t.driver.pm\t= &prism2_pci_pm_ops,\n};\n\nmodule_pci_driver(prism2_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}