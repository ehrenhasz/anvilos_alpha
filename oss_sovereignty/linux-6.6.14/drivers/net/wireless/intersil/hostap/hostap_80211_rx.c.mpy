{
  "module_name": "hostap_80211_rx.c",
  "hash_id": "8740d3c411a8570eb7728fc1e483bd457516a6696b38f5d4095414917c3ca6f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/hostap/hostap_80211_rx.c",
  "human_readable_source": "\n#include <linux/etherdevice.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <net/lib80211.h>\n#include <linux/if_arp.h>\n\n#include \"hostap_80211.h\"\n#include \"hostap.h\"\n#include \"hostap_ap.h\"\n\n \n \nstatic unsigned char rfc1042_header[] =\n{ 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };\n \nstatic unsigned char bridge_tunnel_header[] =\n{ 0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8 };\n \n\nvoid hostap_dump_rx_80211(const char *name, struct sk_buff *skb,\n\t\t\t  struct hostap_80211_rx_status *rx_stats)\n{\n\tstruct ieee80211_hdr *hdr;\n\tu16 fc;\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\n\tprintk(KERN_DEBUG \"%s: RX signal=%d noise=%d rate=%d len=%d \"\n\t       \"jiffies=%ld\\n\",\n\t       name, rx_stats->signal, rx_stats->noise, rx_stats->rate,\n\t       skb->len, jiffies);\n\n\tif (skb->len < 2)\n\t\treturn;\n\n\tfc = le16_to_cpu(hdr->frame_control);\n\tprintk(KERN_DEBUG \"   FC=0x%04x (type=%d:%d)%s%s\",\n\t       fc, (fc & IEEE80211_FCTL_FTYPE) >> 2,\n\t       (fc & IEEE80211_FCTL_STYPE) >> 4,\n\t       fc & IEEE80211_FCTL_TODS ? \" [ToDS]\" : \"\",\n\t       fc & IEEE80211_FCTL_FROMDS ? \" [FromDS]\" : \"\");\n\n\tif (skb->len < IEEE80211_DATA_HDR3_LEN) {\n\t\tprintk(\"\\n\");\n\t\treturn;\n\t}\n\n\tprintk(\" dur=0x%04x seq=0x%04x\\n\", le16_to_cpu(hdr->duration_id),\n\t       le16_to_cpu(hdr->seq_ctrl));\n\n\tprintk(KERN_DEBUG \"   A1=%pM\", hdr->addr1);\n\tprintk(\" A2=%pM\", hdr->addr2);\n\tprintk(\" A3=%pM\", hdr->addr3);\n\tif (skb->len >= 30)\n\t\tprintk(\" A4=%pM\", hdr->addr4);\n\tprintk(\"\\n\");\n}\n\n\n \nint prism2_rx_80211(struct net_device *dev, struct sk_buff *skb,\n\t\t    struct hostap_80211_rx_status *rx_stats, int type)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint hdrlen, phdrlen, head_need, tail_need;\n\tu16 fc;\n\tint prism_header, ret;\n\tstruct ieee80211_hdr *fhdr;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (dev->type == ARPHRD_IEEE80211_PRISM) {\n\t\tif (local->monitor_type == PRISM2_MONITOR_PRISM) {\n\t\t\tprism_header = 1;\n\t\t\tphdrlen = sizeof(struct linux_wlan_ng_prism_hdr);\n\t\t} else {  \n\t\t\tprism_header = 2;\n\t\t\tphdrlen = sizeof(struct linux_wlan_ng_cap_hdr);\n\t\t}\n\t} else if (dev->type == ARPHRD_IEEE80211_RADIOTAP) {\n\t\tprism_header = 3;\n\t\tphdrlen = sizeof(struct hostap_radiotap_rx);\n\t} else {\n\t\tprism_header = 0;\n\t\tphdrlen = 0;\n\t}\n\n\tfhdr = (struct ieee80211_hdr *) skb->data;\n\tfc = le16_to_cpu(fhdr->frame_control);\n\n\tif (type == PRISM2_RX_MGMT && (fc & IEEE80211_FCTL_VERS)) {\n\t\tprintk(KERN_DEBUG \"%s: dropped management frame with header \"\n\t\t       \"version %d\\n\", dev->name, fc & IEEE80211_FCTL_VERS);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn 0;\n\t}\n\n\thdrlen = hostap_80211_get_hdrlen(fhdr->frame_control);\n\n\t \n\thead_need = phdrlen;\n\ttail_need = 0;\n#ifdef PRISM2_ADD_BOGUS_CRC\n\ttail_need += 4;\n#endif  \n\n\thead_need -= skb_headroom(skb);\n\ttail_need -= skb_tailroom(skb);\n\n\tif (head_need > 0 || tail_need > 0) {\n\t\tif (pskb_expand_head(skb, head_need > 0 ? head_need : 0,\n\t\t\t\t     tail_need > 0 ? tail_need : 0,\n\t\t\t\t     GFP_ATOMIC)) {\n\t\t\tprintk(KERN_DEBUG \"%s: prism2_rx_80211 failed to \"\n\t\t\t       \"reallocate skb buffer\\n\", dev->name);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\n#ifdef PRISM2_ADD_BOGUS_CRC\n\tmemset(skb_put(skb, 4), 0xff, 4);  \n#endif  \n\n\tif (prism_header == 1) {\n\t\tstruct linux_wlan_ng_prism_hdr *hdr;\n\t\thdr = skb_push(skb, phdrlen);\n\t\tmemset(hdr, 0, phdrlen);\n\t\thdr->msgcode = LWNG_CAP_DID_BASE;\n\t\thdr->msglen = sizeof(*hdr);\n\t\tmemcpy(hdr->devname, dev->name, sizeof(hdr->devname));\n#define LWNG_SETVAL(f,i,s,l,d) \\\nhdr->f.did = LWNG_CAP_DID_BASE | (i << 12); \\\nhdr->f.status = s; hdr->f.len = l; hdr->f.data = d\n\t\tLWNG_SETVAL(hosttime, 1, 0, 4, jiffies);\n\t\tLWNG_SETVAL(mactime, 2, 0, 4, rx_stats->mac_time);\n\t\tLWNG_SETVAL(channel, 3, 1  , 4, 0);\n\t\tLWNG_SETVAL(rssi, 4, 1  , 4, 0);\n\t\tLWNG_SETVAL(sq, 5, 1  , 4, 0);\n\t\tLWNG_SETVAL(signal, 6, 0, 4, rx_stats->signal);\n\t\tLWNG_SETVAL(noise, 7, 0, 4, rx_stats->noise);\n\t\tLWNG_SETVAL(rate, 8, 0, 4, rx_stats->rate / 5);\n\t\tLWNG_SETVAL(istx, 9, 0, 4, 0);\n\t\tLWNG_SETVAL(frmlen, 10, 0, 4, skb->len - phdrlen);\n#undef LWNG_SETVAL\n\t} else if (prism_header == 2) {\n\t\tstruct linux_wlan_ng_cap_hdr *hdr;\n\t\thdr = skb_push(skb, phdrlen);\n\t\tmemset(hdr, 0, phdrlen);\n\t\thdr->version    = htonl(LWNG_CAPHDR_VERSION);\n\t\thdr->length     = htonl(phdrlen);\n\t\thdr->mactime    = __cpu_to_be64(rx_stats->mac_time);\n\t\thdr->hosttime   = __cpu_to_be64(jiffies);\n\t\thdr->phytype    = htonl(4);  \n\t\thdr->channel    = htonl(local->channel);\n\t\thdr->datarate   = htonl(rx_stats->rate);\n\t\thdr->antenna    = htonl(0);  \n\t\thdr->priority   = htonl(0);  \n\t\thdr->ssi_type   = htonl(3);  \n\t\thdr->ssi_signal = htonl(rx_stats->signal);\n\t\thdr->ssi_noise  = htonl(rx_stats->noise);\n\t\thdr->preamble   = htonl(0);  \n\t\thdr->encoding   = htonl(1);  \n\t} else if (prism_header == 3) {\n\t\tstruct hostap_radiotap_rx *hdr;\n\t\thdr = skb_push(skb, phdrlen);\n\t\tmemset(hdr, 0, phdrlen);\n\t\thdr->hdr.it_len = cpu_to_le16(phdrlen);\n\t\thdr->hdr.it_present =\n\t\t\tcpu_to_le32((1 << IEEE80211_RADIOTAP_TSFT) |\n\t\t\t\t    (1 << IEEE80211_RADIOTAP_CHANNEL) |\n\t\t\t\t    (1 << IEEE80211_RADIOTAP_RATE) |\n\t\t\t\t    (1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL) |\n\t\t\t\t    (1 << IEEE80211_RADIOTAP_DBM_ANTNOISE));\n\t\thdr->tsft = cpu_to_le64(rx_stats->mac_time);\n\t\thdr->chan_freq = cpu_to_le16(freq_list[local->channel - 1]);\n\t\thdr->chan_flags = cpu_to_le16(IEEE80211_CHAN_CCK |\n\t\t\t\t\t\t IEEE80211_CHAN_2GHZ);\n\t\thdr->rate = rx_stats->rate / 5;\n\t\thdr->dbm_antsignal = rx_stats->signal;\n\t\thdr->dbm_antnoise = rx_stats->noise;\n\t}\n\n\tret = skb->len - phdrlen;\n\tskb->dev = dev;\n\tskb_reset_mac_header(skb);\n\tskb_pull(skb, hdrlen);\n\tif (prism_header)\n\t\tskb_pull(skb, phdrlen);\n\tskb->pkt_type = PACKET_OTHERHOST;\n\tskb->protocol = cpu_to_be16(ETH_P_802_2);\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\tnetif_rx(skb);\n\n\treturn ret;\n}\n\n\n \nstatic void monitor_rx(struct net_device *dev, struct sk_buff *skb,\n\t\t       struct hostap_80211_rx_status *rx_stats)\n{\n\tint len;\n\n\tlen = prism2_rx_80211(dev, skb, rx_stats, PRISM2_RX_MONITOR);\n\tdev->stats.rx_packets++;\n\tdev->stats.rx_bytes += len;\n}\n\n\n \nstatic struct prism2_frag_entry *\nprism2_frag_cache_find(local_info_t *local, unsigned int seq,\n\t\t       unsigned int frag, u8 *src, u8 *dst)\n{\n\tstruct prism2_frag_entry *entry;\n\tint i;\n\n\tfor (i = 0; i < PRISM2_FRAG_CACHE_LEN; i++) {\n\t\tentry = &local->frag_cache[i];\n\t\tif (entry->skb != NULL &&\n\t\t    time_after(jiffies, entry->first_frag_time + 2 * HZ)) {\n\t\t\tprintk(KERN_DEBUG \"%s: expiring fragment cache entry \"\n\t\t\t       \"seq=%u last_frag=%u\\n\",\n\t\t\t       local->dev->name, entry->seq, entry->last_frag);\n\t\t\tdev_kfree_skb(entry->skb);\n\t\t\tentry->skb = NULL;\n\t\t}\n\n\t\tif (entry->skb != NULL && entry->seq == seq &&\n\t\t    (entry->last_frag + 1 == frag || frag == -1) &&\n\t\t    memcmp(entry->src_addr, src, ETH_ALEN) == 0 &&\n\t\t    memcmp(entry->dst_addr, dst, ETH_ALEN) == 0)\n\t\t\treturn entry;\n\t}\n\n\treturn NULL;\n}\n\n\n \nstatic struct sk_buff *\nprism2_frag_cache_get(local_info_t *local, struct ieee80211_hdr *hdr)\n{\n\tstruct sk_buff *skb = NULL;\n\tu16 sc;\n\tunsigned int frag, seq;\n\tstruct prism2_frag_entry *entry;\n\n\tsc = le16_to_cpu(hdr->seq_ctrl);\n\tfrag = sc & IEEE80211_SCTL_FRAG;\n\tseq = (sc & IEEE80211_SCTL_SEQ) >> 4;\n\n\tif (frag == 0) {\n\t\t \n\t\tskb = dev_alloc_skb(local->dev->mtu +\n\t\t\t\t    sizeof(struct ieee80211_hdr) +\n\t\t\t\t    8   +\n\t\t\t\t    2   +\n\t\t\t\t    8   + ETH_ALEN  );\n\t\tif (skb == NULL)\n\t\t\treturn NULL;\n\n\t\tentry = &local->frag_cache[local->frag_next_idx];\n\t\tlocal->frag_next_idx++;\n\t\tif (local->frag_next_idx >= PRISM2_FRAG_CACHE_LEN)\n\t\t\tlocal->frag_next_idx = 0;\n\n\t\tif (entry->skb != NULL)\n\t\t\tdev_kfree_skb(entry->skb);\n\n\t\tentry->first_frag_time = jiffies;\n\t\tentry->seq = seq;\n\t\tentry->last_frag = frag;\n\t\tentry->skb = skb;\n\t\tmemcpy(entry->src_addr, hdr->addr2, ETH_ALEN);\n\t\tmemcpy(entry->dst_addr, hdr->addr1, ETH_ALEN);\n\t} else {\n\t\t \n\t\tentry = prism2_frag_cache_find(local, seq, frag, hdr->addr2,\n\t\t\t\t\t       hdr->addr1);\n\t\tif (entry != NULL) {\n\t\t\tentry->last_frag = frag;\n\t\t\tskb = entry->skb;\n\t\t}\n\t}\n\n\treturn skb;\n}\n\n\n \nstatic int prism2_frag_cache_invalidate(local_info_t *local,\n\t\t\t\t\tstruct ieee80211_hdr *hdr)\n{\n\tu16 sc;\n\tunsigned int seq;\n\tstruct prism2_frag_entry *entry;\n\n\tsc = le16_to_cpu(hdr->seq_ctrl);\n\tseq = (sc & IEEE80211_SCTL_SEQ) >> 4;\n\n\tentry = prism2_frag_cache_find(local, seq, -1, hdr->addr2, hdr->addr1);\n\n\tif (entry == NULL) {\n\t\tprintk(KERN_DEBUG \"%s: could not invalidate fragment cache \"\n\t\t       \"entry (seq=%u)\\n\",\n\t\t       local->dev->name, seq);\n\t\treturn -1;\n\t}\n\n\tentry->skb = NULL;\n\treturn 0;\n}\n\n\nstatic struct hostap_bss_info *__hostap_get_bss(local_info_t *local, u8 *bssid,\n\t\t\t\t\t\tu8 *ssid, size_t ssid_len)\n{\n\tstruct list_head *ptr;\n\tstruct hostap_bss_info *bss;\n\n\tlist_for_each(ptr, &local->bss_list) {\n\t\tbss = list_entry(ptr, struct hostap_bss_info, list);\n\t\tif (memcmp(bss->bssid, bssid, ETH_ALEN) == 0 &&\n\t\t    (ssid == NULL ||\n\t\t     (ssid_len == bss->ssid_len &&\n\t\t      memcmp(ssid, bss->ssid, ssid_len) == 0))) {\n\t\t\tlist_move(&bss->list, &local->bss_list);\n\t\t\treturn bss;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n\nstatic struct hostap_bss_info *__hostap_add_bss(local_info_t *local, u8 *bssid,\n\t\t\t\t\t\tu8 *ssid, size_t ssid_len)\n{\n\tstruct hostap_bss_info *bss;\n\n\tif (local->num_bss_info >= HOSTAP_MAX_BSS_COUNT) {\n\t\tbss = list_entry(local->bss_list.prev,\n\t\t\t\t struct hostap_bss_info, list);\n\t\tlist_del(&bss->list);\n\t\tlocal->num_bss_info--;\n\t} else {\n\t\tbss = kmalloc(sizeof(*bss), GFP_ATOMIC);\n\t\tif (bss == NULL)\n\t\t\treturn NULL;\n\t}\n\n\tmemset(bss, 0, sizeof(*bss));\n\tmemcpy(bss->bssid, bssid, ETH_ALEN);\n\tmemcpy(bss->ssid, ssid, ssid_len);\n\tbss->ssid_len = ssid_len;\n\tlocal->num_bss_info++;\n\tlist_add(&bss->list, &local->bss_list);\n\treturn bss;\n}\n\n\nstatic void __hostap_expire_bss(local_info_t *local)\n{\n\tstruct hostap_bss_info *bss;\n\n\twhile (local->num_bss_info > 0) {\n\t\tbss = list_entry(local->bss_list.prev,\n\t\t\t\t struct hostap_bss_info, list);\n\t\tif (!time_after(jiffies, bss->last_update + 60 * HZ))\n\t\t\tbreak;\n\n\t\tlist_del(&bss->list);\n\t\tlocal->num_bss_info--;\n\t\tkfree(bss);\n\t}\n}\n\n\n \nstatic void hostap_rx_sta_beacon(local_info_t *local, struct sk_buff *skb,\n\t\t\t\t int stype)\n{\n\tstruct hostap_ieee80211_mgmt *mgmt;\n\tint left, chan = 0;\n\tu8 *pos;\n\tu8 *ssid = NULL, *wpa = NULL, *rsn = NULL;\n\tsize_t ssid_len = 0, wpa_len = 0, rsn_len = 0;\n\tstruct hostap_bss_info *bss;\n\n\tif (skb->len < IEEE80211_MGMT_HDR_LEN + sizeof(mgmt->u.beacon))\n\t\treturn;\n\n\tmgmt = (struct hostap_ieee80211_mgmt *) skb->data;\n\tpos = mgmt->u.beacon.variable;\n\tleft = skb->len - (pos - skb->data);\n\n\twhile (left >= 2) {\n\t\tif (2 + pos[1] > left)\n\t\t\treturn;  \n\t\tswitch (*pos) {\n\t\tcase WLAN_EID_SSID:\n\t\t\tssid = pos + 2;\n\t\t\tssid_len = pos[1];\n\t\t\tbreak;\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\tif (pos[1] >= 4 &&\n\t\t\t    pos[2] == 0x00 && pos[3] == 0x50 &&\n\t\t\t    pos[4] == 0xf2 && pos[5] == 1) {\n\t\t\t\twpa = pos;\n\t\t\t\twpa_len = pos[1] + 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WLAN_EID_RSN:\n\t\t\trsn = pos;\n\t\t\trsn_len = pos[1] + 2;\n\t\t\tbreak;\n\t\tcase WLAN_EID_DS_PARAMS:\n\t\t\tif (pos[1] >= 1)\n\t\t\t\tchan = pos[2];\n\t\t\tbreak;\n\t\t}\n\t\tleft -= 2 + pos[1];\n\t\tpos += 2 + pos[1];\n\t}\n\n\tif (wpa_len > MAX_WPA_IE_LEN)\n\t\twpa_len = MAX_WPA_IE_LEN;\n\tif (rsn_len > MAX_WPA_IE_LEN)\n\t\trsn_len = MAX_WPA_IE_LEN;\n\tif (ssid_len > sizeof(bss->ssid))\n\t\tssid_len = sizeof(bss->ssid);\n\n\tspin_lock(&local->lock);\n\tbss = __hostap_get_bss(local, mgmt->bssid, ssid, ssid_len);\n\tif (bss == NULL)\n\t\tbss = __hostap_add_bss(local, mgmt->bssid, ssid, ssid_len);\n\tif (bss) {\n\t\tbss->last_update = jiffies;\n\t\tbss->count++;\n\t\tbss->capab_info = le16_to_cpu(mgmt->u.beacon.capab_info);\n\t\tif (wpa) {\n\t\t\tmemcpy(bss->wpa_ie, wpa, wpa_len);\n\t\t\tbss->wpa_ie_len = wpa_len;\n\t\t} else\n\t\t\tbss->wpa_ie_len = 0;\n\t\tif (rsn) {\n\t\t\tmemcpy(bss->rsn_ie, rsn, rsn_len);\n\t\t\tbss->rsn_ie_len = rsn_len;\n\t\t} else\n\t\t\tbss->rsn_ie_len = 0;\n\t\tbss->chan = chan;\n\t}\n\t__hostap_expire_bss(local);\n\tspin_unlock(&local->lock);\n}\n\n\nstatic int\nhostap_rx_frame_mgmt(local_info_t *local, struct sk_buff *skb,\n\t\t     struct hostap_80211_rx_status *rx_stats, u16 type,\n\t\t     u16 stype)\n{\n\tif (local->iw_mode == IW_MODE_MASTER)\n\t\thostap_update_sta_ps(local, (struct ieee80211_hdr *) skb->data);\n\n\tif (local->hostapd && type == IEEE80211_FTYPE_MGMT) {\n\t\tif (stype == IEEE80211_STYPE_BEACON &&\n\t\t    local->iw_mode == IW_MODE_MASTER) {\n\t\t\tstruct sk_buff *skb2;\n\t\t\t \n\t\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (skb2)\n\t\t\t\thostap_rx(skb2->dev, skb2, rx_stats);\n\t\t}\n\n\t\t \n\t\tlocal->apdevstats.rx_packets++;\n\t\tlocal->apdevstats.rx_bytes += skb->len;\n\t\tif (local->apdev == NULL)\n\t\t\treturn -1;\n\t\tprism2_rx_80211(local->apdev, skb, rx_stats, PRISM2_RX_MGMT);\n\t\treturn 0;\n\t}\n\n\tif (local->iw_mode == IW_MODE_MASTER) {\n\t\tif (type != IEEE80211_FTYPE_MGMT &&\n\t\t    type != IEEE80211_FTYPE_CTL) {\n\t\t\tprintk(KERN_DEBUG \"%s: unknown management frame \"\n\t\t\t       \"(type=0x%02x, stype=0x%02x) dropped\\n\",\n\t\t\t       skb->dev->name, type >> 2, stype >> 4);\n\t\t\treturn -1;\n\t\t}\n\n\t\thostap_rx(skb->dev, skb, rx_stats);\n\t\treturn 0;\n\t} else if (type == IEEE80211_FTYPE_MGMT &&\n\t\t   (stype == IEEE80211_STYPE_BEACON ||\n\t\t    stype == IEEE80211_STYPE_PROBE_RESP)) {\n\t\thostap_rx_sta_beacon(local, skb, stype);\n\t\treturn -1;\n\t} else if (type == IEEE80211_FTYPE_MGMT &&\n\t\t   (stype == IEEE80211_STYPE_ASSOC_RESP ||\n\t\t    stype == IEEE80211_STYPE_REASSOC_RESP)) {\n\t\t \n\t\treturn -1;\n\t} else {\n\t\tprintk(KERN_DEBUG \"%s: hostap_rx_frame_mgmt: dropped unhandled\"\n\t\t       \" management frame in non-Host AP mode (type=%d:%d)\\n\",\n\t\t       skb->dev->name, type >> 2, stype >> 4);\n\t\treturn -1;\n\t}\n}\n\n\n \nstatic struct net_device *prism2_rx_get_wds(local_info_t *local,\n\t\t\t\t\t\t   u8 *addr)\n{\n\tstruct hostap_interface *iface = NULL;\n\tstruct list_head *ptr;\n\n\tread_lock_bh(&local->iface_lock);\n\tlist_for_each(ptr, &local->hostap_interfaces) {\n\t\tiface = list_entry(ptr, struct hostap_interface, list);\n\t\tif (iface->type == HOSTAP_INTERFACE_WDS &&\n\t\t    memcmp(iface->u.wds.remote_addr, addr, ETH_ALEN) == 0)\n\t\t\tbreak;\n\t\tiface = NULL;\n\t}\n\tread_unlock_bh(&local->iface_lock);\n\n\treturn iface ? iface->dev : NULL;\n}\n\n\nstatic int\nhostap_rx_frame_wds(local_info_t *local, struct ieee80211_hdr *hdr, u16 fc,\n\t\t    struct net_device **wds)\n{\n\t \n\tif ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) !=\n\t    (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS) &&\n\t    (local->iw_mode != IW_MODE_MASTER || !(fc & IEEE80211_FCTL_TODS)))\n\t\treturn 0;  \n\n\t \n\tif (!ether_addr_equal(hdr->addr1, local->dev->dev_addr) &&\n\t    (hdr->addr1[0] != 0xff || hdr->addr1[1] != 0xff ||\n\t     hdr->addr1[2] != 0xff || hdr->addr1[3] != 0xff ||\n\t     hdr->addr1[4] != 0xff || hdr->addr1[5] != 0xff)) {\n\t\t \n\t\tPDEBUG(DEBUG_EXTRA2, \"%s: received WDS frame with \"\n\t\t       \"not own or broadcast %s=%pM\\n\",\n\t\t       local->dev->name,\n\t\t       fc & IEEE80211_FCTL_FROMDS ? \"RA\" : \"BSSID\",\n\t\t       hdr->addr1);\n\t\treturn -1;\n\t}\n\n\t \n\t*wds = prism2_rx_get_wds(local, hdr->addr2);\n\tif (*wds == NULL && fc & IEEE80211_FCTL_FROMDS &&\n\t    (local->iw_mode != IW_MODE_INFRA ||\n\t     !(local->wds_type & HOSTAP_WDS_AP_CLIENT) ||\n\t     memcmp(hdr->addr2, local->bssid, ETH_ALEN) != 0)) {\n\t\t \n\t\tPDEBUG(DEBUG_EXTRA, \"%s: received WDS[4 addr] frame \"\n\t\t       \"from unknown TA=%pM\\n\",\n\t\t       local->dev->name, hdr->addr2);\n\t\tif (local->ap && local->ap->autom_ap_wds)\n\t\t\thostap_wds_link_oper(local, hdr->addr2, WDS_ADD);\n\t\treturn -1;\n\t}\n\n\tif (*wds && !(fc & IEEE80211_FCTL_FROMDS) && local->ap &&\n\t    hostap_is_sta_assoc(local->ap, hdr->addr2)) {\n\t\t \n\t\t*wds = NULL;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int hostap_is_eapol_frame(local_info_t *local, struct sk_buff *skb)\n{\n\tstruct net_device *dev = local->dev;\n\tu16 fc, ethertype;\n\tstruct ieee80211_hdr *hdr;\n\tu8 *pos;\n\n\tif (skb->len < 24)\n\t\treturn 0;\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\tfc = le16_to_cpu(hdr->frame_control);\n\n\t \n\tif ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\n\t    IEEE80211_FCTL_TODS &&\n\t    ether_addr_equal(hdr->addr1, dev->dev_addr) &&\n\t    ether_addr_equal(hdr->addr3, dev->dev_addr)) {\n\t\t \n\t} else if ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\n\t\t   IEEE80211_FCTL_FROMDS &&\n\t\t   ether_addr_equal(hdr->addr1, dev->dev_addr)) {\n\t\t \n\t} else\n\t\treturn 0;\n\n\tif (skb->len < 24 + 8)\n\t\treturn 0;\n\n\t \n\tpos = skb->data + 24;\n\tethertype = (pos[6] << 8) | pos[7];\n\tif (ethertype == ETH_P_PAE)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n\n \nstatic int\nhostap_rx_frame_decrypt(local_info_t *local, struct sk_buff *skb,\n\t\t\tstruct lib80211_crypt_data *crypt)\n{\n\tstruct ieee80211_hdr *hdr;\n\tint res, hdrlen;\n\n\tif (crypt == NULL || crypt->ops->decrypt_mpdu == NULL)\n\t\treturn 0;\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\thdrlen = hostap_80211_get_hdrlen(hdr->frame_control);\n\n\tif (local->tkip_countermeasures &&\n\t    strcmp(crypt->ops->name, \"TKIP\") == 0) {\n\t\tif (net_ratelimit()) {\n\t\t\tprintk(KERN_DEBUG \"%s: TKIP countermeasures: dropped \"\n\t\t\t       \"received packet from %pM\\n\",\n\t\t\t       local->dev->name, hdr->addr2);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tatomic_inc(&crypt->refcnt);\n\tres = crypt->ops->decrypt_mpdu(skb, hdrlen, crypt->priv);\n\tatomic_dec(&crypt->refcnt);\n\tif (res < 0) {\n\t\tprintk(KERN_DEBUG \"%s: decryption failed (SA=%pM) res=%d\\n\",\n\t\t       local->dev->name, hdr->addr2, res);\n\t\tlocal->comm_tallies.rx_discards_wep_undecryptable++;\n\t\treturn -1;\n\t}\n\n\treturn res;\n}\n\n\n \nstatic int\nhostap_rx_frame_decrypt_msdu(local_info_t *local, struct sk_buff *skb,\n\t\t\t     int keyidx, struct lib80211_crypt_data *crypt)\n{\n\tstruct ieee80211_hdr *hdr;\n\tint res, hdrlen;\n\n\tif (crypt == NULL || crypt->ops->decrypt_msdu == NULL)\n\t\treturn 0;\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\thdrlen = hostap_80211_get_hdrlen(hdr->frame_control);\n\n\tatomic_inc(&crypt->refcnt);\n\tres = crypt->ops->decrypt_msdu(skb, keyidx, hdrlen, crypt->priv);\n\tatomic_dec(&crypt->refcnt);\n\tif (res < 0) {\n\t\tprintk(KERN_DEBUG \"%s: MSDU decryption/MIC verification failed\"\n\t\t       \" (SA=%pM keyidx=%d)\\n\",\n\t\t       local->dev->name, hdr->addr2, keyidx);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n\n \nvoid hostap_80211_rx(struct net_device *dev, struct sk_buff *skb,\n\t\t     struct hostap_80211_rx_status *rx_stats)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tstruct ieee80211_hdr *hdr;\n\tsize_t hdrlen;\n\tu16 fc, type, stype, sc;\n\tstruct net_device *wds = NULL;\n\tunsigned int frag;\n\tu8 *payload;\n\tstruct sk_buff *skb2 = NULL;\n\tu16 ethertype;\n\tint frame_authorized = 0;\n\tint from_assoc_ap = 0;\n\tu8 dst[ETH_ALEN];\n\tu8 src[ETH_ALEN];\n\tstruct lib80211_crypt_data *crypt = NULL;\n\tvoid *sta = NULL;\n\tint keyidx = 0;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\tiface->stats.rx_packets++;\n\tiface->stats.rx_bytes += skb->len;\n\n\t \n\tdev = local->ddev;\n\tiface = netdev_priv(dev);\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\n\tif (skb->len < 10)\n\t\tgoto rx_dropped;\n\n\tfc = le16_to_cpu(hdr->frame_control);\n\ttype = fc & IEEE80211_FCTL_FTYPE;\n\tstype = fc & IEEE80211_FCTL_STYPE;\n\tsc = le16_to_cpu(hdr->seq_ctrl);\n\tfrag = sc & IEEE80211_SCTL_FRAG;\n\thdrlen = hostap_80211_get_hdrlen(hdr->frame_control);\n\n\t \n#ifdef IW_WIRELESS_SPY\t\t \n\t \n\tif (iface->spy_data.spy_number > 0) {\n\t\tstruct iw_quality wstats;\n\t\twstats.level = rx_stats->signal;\n\t\twstats.noise = rx_stats->noise;\n\t\twstats.updated = IW_QUAL_LEVEL_UPDATED | IW_QUAL_NOISE_UPDATED\n\t\t\t| IW_QUAL_QUAL_INVALID | IW_QUAL_DBM;\n\t\t \n\t\twireless_spy_update(dev, hdr->addr2, &wstats);\n\t}\n#endif  \n\thostap_update_rx_stats(local->ap, hdr, rx_stats);\n\n\tif (local->iw_mode == IW_MODE_MONITOR) {\n\t\tmonitor_rx(dev, skb, rx_stats);\n\t\treturn;\n\t}\n\n\tif (local->host_decrypt) {\n\t\tint idx = 0;\n\t\tif (skb->len >= hdrlen + 3)\n\t\t\tidx = skb->data[hdrlen + 3] >> 6;\n\t\tcrypt = local->crypt_info.crypt[idx];\n\t\tsta = NULL;\n\n\t\t \n\n\t\tif (!(hdr->addr1[0] & 0x01) || local->bcrx_sta_key)\n\t\t\t(void) hostap_handle_sta_crypto(local, hdr, &crypt,\n\t\t\t\t\t\t\t&sta);\n\n\t\t \n\t\tif (crypt && (crypt->ops == NULL ||\n\t\t\t      crypt->ops->decrypt_mpdu == NULL))\n\t\t\tcrypt = NULL;\n\n\t\tif (!crypt && (fc & IEEE80211_FCTL_PROTECTED)) {\n#if 0\n\t\t\t \n\t\t\tprintk(KERN_DEBUG \"%s: WEP decryption failed (not set)\"\n\t\t\t       \" (SA=%pM)\\n\",\n\t\t\t       local->dev->name, hdr->addr2);\n#endif\n\t\t\tlocal->comm_tallies.rx_discards_wep_undecryptable++;\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n\n\tif (type != IEEE80211_FTYPE_DATA) {\n\t\tif (type == IEEE80211_FTYPE_MGMT &&\n\t\t    stype == IEEE80211_STYPE_AUTH &&\n\t\t    fc & IEEE80211_FCTL_PROTECTED && local->host_decrypt &&\n\t\t    (keyidx = hostap_rx_frame_decrypt(local, skb, crypt)) < 0)\n\t\t{\n\t\t\tprintk(KERN_DEBUG \"%s: failed to decrypt mgmt::auth \"\n\t\t\t       \"from %pM\\n\", dev->name, hdr->addr2);\n\t\t\t \n\t\t\tgoto rx_dropped;\n\t\t}\n\n\t\tif (hostap_rx_frame_mgmt(local, skb, rx_stats, type, stype))\n\t\t\tgoto rx_dropped;\n\t\telse\n\t\t\tgoto rx_exit;\n\t}\n\n\t \n\tif (skb->len < IEEE80211_DATA_HDR3_LEN)\n\t\tgoto rx_dropped;\n\n\tswitch (fc & (IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS)) {\n\tcase IEEE80211_FCTL_FROMDS:\n\t\tmemcpy(dst, hdr->addr1, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr3, ETH_ALEN);\n\t\tbreak;\n\tcase IEEE80211_FCTL_TODS:\n\t\tmemcpy(dst, hdr->addr3, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr2, ETH_ALEN);\n\t\tbreak;\n\tcase IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS:\n\t\tif (skb->len < IEEE80211_DATA_HDR4_LEN)\n\t\t\tgoto rx_dropped;\n\t\tmemcpy(dst, hdr->addr3, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr4, ETH_ALEN);\n\t\tbreak;\n\tdefault:\n\t\tmemcpy(dst, hdr->addr1, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr2, ETH_ALEN);\n\t\tbreak;\n\t}\n\n\tif (hostap_rx_frame_wds(local, hdr, fc, &wds))\n\t\tgoto rx_dropped;\n\tif (wds)\n\t\tskb->dev = dev = wds;\n\n\tif (local->iw_mode == IW_MODE_MASTER && !wds &&\n\t    (fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\n\t    IEEE80211_FCTL_FROMDS &&\n\t    local->stadev &&\n\t    memcmp(hdr->addr2, local->assoc_ap_addr, ETH_ALEN) == 0) {\n\t\t \n\t\tskb->dev = dev = local->stadev;\n\t\tfrom_assoc_ap = 1;\n\t}\n\n\tif ((local->iw_mode == IW_MODE_MASTER ||\n\t     local->iw_mode == IW_MODE_REPEAT) &&\n\t    !from_assoc_ap) {\n\t\tswitch (hostap_handle_sta_rx(local, dev, skb, rx_stats,\n\t\t\t\t\t     wds != NULL)) {\n\t\tcase AP_RX_CONTINUE_NOT_AUTHORIZED:\n\t\t\tframe_authorized = 0;\n\t\t\tbreak;\n\t\tcase AP_RX_CONTINUE:\n\t\t\tframe_authorized = 1;\n\t\t\tbreak;\n\t\tcase AP_RX_DROP:\n\t\t\tgoto rx_dropped;\n\t\tcase AP_RX_EXIT:\n\t\t\tgoto rx_exit;\n\t\t}\n\t}\n\n\t \n\tif (stype != IEEE80211_STYPE_DATA &&\n\t    stype != IEEE80211_STYPE_DATA_CFACK &&\n\t    stype != IEEE80211_STYPE_DATA_CFPOLL &&\n\t    stype != IEEE80211_STYPE_DATA_CFACKPOLL) {\n\t\tif (stype != IEEE80211_STYPE_NULLFUNC)\n\t\t\tprintk(KERN_DEBUG \"%s: RX: dropped data frame \"\n\t\t\t       \"with no data (type=0x%02x, subtype=0x%02x)\\n\",\n\t\t\t       dev->name, type >> 2, stype >> 4);\n\t\tgoto rx_dropped;\n\t}\n\n\t \n\n\tif (local->host_decrypt && (fc & IEEE80211_FCTL_PROTECTED) &&\n\t    (keyidx = hostap_rx_frame_decrypt(local, skb, crypt)) < 0)\n\t\tgoto rx_dropped;\n\thdr = (struct ieee80211_hdr *) skb->data;\n\n\t \n\n\tif (local->host_decrypt && (fc & IEEE80211_FCTL_PROTECTED) &&\n\t    (frag != 0 || (fc & IEEE80211_FCTL_MOREFRAGS))) {\n\t\tint flen;\n\t\tstruct sk_buff *frag_skb =\n\t\t\tprism2_frag_cache_get(local, hdr);\n\t\tif (!frag_skb) {\n\t\t\tprintk(KERN_DEBUG \"%s: Rx cannot get skb from \"\n\t\t\t       \"fragment cache (morefrag=%d seq=%u frag=%u)\\n\",\n\t\t\t       dev->name, (fc & IEEE80211_FCTL_MOREFRAGS) != 0,\n\t\t\t       (sc & IEEE80211_SCTL_SEQ) >> 4, frag);\n\t\t\tgoto rx_dropped;\n\t\t}\n\n\t\tflen = skb->len;\n\t\tif (frag != 0)\n\t\t\tflen -= hdrlen;\n\n\t\tif (frag_skb->tail + flen > frag_skb->end) {\n\t\t\tprintk(KERN_WARNING \"%s: host decrypted and \"\n\t\t\t       \"reassembled frame did not fit skb\\n\",\n\t\t\t       dev->name);\n\t\t\tprism2_frag_cache_invalidate(local, hdr);\n\t\t\tgoto rx_dropped;\n\t\t}\n\n\t\tif (frag == 0) {\n\t\t\t \n\t\t\tskb_copy_from_linear_data(skb, skb_put(frag_skb, flen),\n\t\t\t\t\t\t  flen);\n\t\t} else {\n\t\t\t \n\t\t\tskb_copy_from_linear_data_offset(skb, hdrlen,\n\t\t\t\t\t\t\t skb_put(frag_skb,\n\t\t\t\t\t\t\t\t flen), flen);\n\t\t}\n\t\tdev_kfree_skb(skb);\n\t\tskb = NULL;\n\n\t\tif (fc & IEEE80211_FCTL_MOREFRAGS) {\n\t\t\t \n\t\t\tgoto rx_exit;\n\t\t}\n\n\t\t \n\t\tskb = frag_skb;\n\t\thdr = (struct ieee80211_hdr *) skb->data;\n\t\tprism2_frag_cache_invalidate(local, hdr);\n\t}\n\n\t \n\n\tif (local->host_decrypt && (fc & IEEE80211_FCTL_PROTECTED) &&\n\t    hostap_rx_frame_decrypt_msdu(local, skb, keyidx, crypt))\n\t\tgoto rx_dropped;\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\tif (crypt && !(fc & IEEE80211_FCTL_PROTECTED) && !local->open_wep) {\n\t\tif (local->ieee_802_1x &&\n\t\t    hostap_is_eapol_frame(local, skb)) {\n\t\t\t \n\t\t\tPDEBUG(DEBUG_EXTRA2, \"%s: RX: IEEE 802.1X - passing \"\n\t\t\t       \"unencrypted EAPOL frame\\n\", local->dev->name);\n\t\t} else {\n\t\t\tprintk(KERN_DEBUG \"%s: encryption configured, but RX \"\n\t\t\t       \"frame not encrypted (SA=%pM)\\n\",\n\t\t\t       local->dev->name, hdr->addr2);\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n\n\tif (local->drop_unencrypted && !(fc & IEEE80211_FCTL_PROTECTED) &&\n\t    !hostap_is_eapol_frame(local, skb)) {\n\t\tif (net_ratelimit()) {\n\t\t\tprintk(KERN_DEBUG \"%s: dropped unencrypted RX data \"\n\t\t\t       \"frame from %pM (drop_unencrypted=1)\\n\",\n\t\t\t       dev->name, hdr->addr2);\n\t\t}\n\t\tgoto rx_dropped;\n\t}\n\n\t \n\n\tpayload = skb->data + hdrlen;\n\tethertype = (payload[6] << 8) | payload[7];\n\n\t \n\tif (local->ieee_802_1x && local->iw_mode == IW_MODE_MASTER) {\n\t\tif (ethertype == ETH_P_PAE) {\n\t\t\tPDEBUG(DEBUG_EXTRA2, \"%s: RX: IEEE 802.1X frame\\n\",\n\t\t\t       dev->name);\n\t\t\tif (local->hostapd && local->apdev) {\n\t\t\t\t \n\t\t\t\tprism2_rx_80211(local->apdev, skb, rx_stats,\n\t\t\t\t\t\tPRISM2_RX_MGMT);\n\t\t\t\tlocal->apdevstats.rx_packets++;\n\t\t\t\tlocal->apdevstats.rx_bytes += skb->len;\n\t\t\t\tgoto rx_exit;\n\t\t\t}\n\t\t} else if (!frame_authorized) {\n\t\t\tprintk(KERN_DEBUG \"%s: dropped frame from \"\n\t\t\t       \"unauthorized port (IEEE 802.1X): \"\n\t\t\t       \"ethertype=0x%04x\\n\",\n\t\t\t       dev->name, ethertype);\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n\n\t \n\tif (skb->len - hdrlen >= 8 &&\n\t    ((memcmp(payload, rfc1042_header, 6) == 0 &&\n\t      ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||\n\t     memcmp(payload, bridge_tunnel_header, 6) == 0)) {\n\t\t \n\t\tskb_pull(skb, hdrlen + 6);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);\n\t} else {\n\t\t__be16 len;\n\t\t \n\t\tskb_pull(skb, hdrlen);\n\t\tlen = htons(skb->len);\n\t\tmemcpy(skb_push(skb, 2), &len, 2);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);\n\t}\n\n\tif (wds && ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\n\t\t    IEEE80211_FCTL_TODS) &&\n\t    skb->len >= ETH_HLEN + ETH_ALEN) {\n\t\t \n\t\tskb_copy_from_linear_data_offset(skb, skb->len - ETH_ALEN,\n\t\t\t\t\t\t skb->data + ETH_ALEN,\n\t\t\t\t\t\t ETH_ALEN);\n\t\tskb_trim(skb, skb->len - ETH_ALEN);\n\t}\n\n\tdev->stats.rx_packets++;\n\tdev->stats.rx_bytes += skb->len;\n\n\tif (local->iw_mode == IW_MODE_MASTER && !wds &&\n\t    local->ap->bridge_packets) {\n\t\tif (dst[0] & 0x01) {\n\t\t\t \n\t\t\tlocal->ap->bridged_multicast++;\n\t\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (skb2 == NULL)\n\t\t\t\tprintk(KERN_DEBUG \"%s: skb_clone failed for \"\n\t\t\t\t       \"multicast frame\\n\", dev->name);\n\t\t} else if (hostap_is_sta_authorized(local->ap, dst)) {\n\t\t\t \n\t\t\tlocal->ap->bridged_unicast++;\n\t\t\tskb2 = skb;\n\t\t\tskb = NULL;\n\t\t}\n\t}\n\n\tif (skb2 != NULL) {\n\t\t \n\t\tskb2->dev = dev;\n\t\tskb2->protocol = cpu_to_be16(ETH_P_802_3);\n\t\tskb_reset_mac_header(skb2);\n\t\tskb_reset_network_header(skb2);\n\t\t \n\t\tdev_queue_xmit(skb2);\n\t}\n\n\tif (skb) {\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\tmemset(skb->cb, 0, sizeof(skb->cb));\n\t\tnetif_rx(skb);\n\t}\n\n rx_exit:\n\tif (sta)\n\t\thostap_handle_sta_release(sta);\n\treturn;\n\n rx_dropped:\n\tdev_kfree_skb(skb);\n\n\tdev->stats.rx_dropped++;\n\tgoto rx_exit;\n}\n\n\nEXPORT_SYMBOL(hostap_80211_rx);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}