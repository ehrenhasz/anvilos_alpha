{
  "module_name": "hostap_80211_tx.c",
  "hash_id": "99995c8d72c329987941f2711ef4ff34d1ed9d21e8c0f838a8e8ed0ff6018cab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/hostap/hostap_80211_tx.c",
  "human_readable_source": "\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/etherdevice.h>\n\n#include \"hostap_80211.h\"\n#include \"hostap_common.h\"\n#include \"hostap_wlan.h\"\n#include \"hostap.h\"\n#include \"hostap_ap.h\"\n\n \n \nstatic unsigned char rfc1042_header[] =\n{ 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };\n \nstatic unsigned char bridge_tunnel_header[] =\n{ 0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8 };\n \n\nvoid hostap_dump_tx_80211(const char *name, struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr;\n\tu16 fc;\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\n\tprintk(KERN_DEBUG \"%s: TX len=%d jiffies=%ld\\n\",\n\t       name, skb->len, jiffies);\n\n\tif (skb->len < 2)\n\t\treturn;\n\n\tfc = le16_to_cpu(hdr->frame_control);\n\tprintk(KERN_DEBUG \"   FC=0x%04x (type=%d:%d)%s%s\",\n\t       fc, (fc & IEEE80211_FCTL_FTYPE) >> 2,\n\t       (fc & IEEE80211_FCTL_STYPE) >> 4,\n\t       fc & IEEE80211_FCTL_TODS ? \" [ToDS]\" : \"\",\n\t       fc & IEEE80211_FCTL_FROMDS ? \" [FromDS]\" : \"\");\n\n\tif (skb->len < IEEE80211_DATA_HDR3_LEN) {\n\t\tprintk(\"\\n\");\n\t\treturn;\n\t}\n\n\tprintk(\" dur=0x%04x seq=0x%04x\\n\", le16_to_cpu(hdr->duration_id),\n\t       le16_to_cpu(hdr->seq_ctrl));\n\n\tprintk(KERN_DEBUG \"   A1=%pM\", hdr->addr1);\n\tprintk(\" A2=%pM\", hdr->addr2);\n\tprintk(\" A3=%pM\", hdr->addr3);\n\tif (skb->len >= 30)\n\t\tprintk(\" A4=%pM\", hdr->addr4);\n\tprintk(\"\\n\");\n}\n\n\n \nnetdev_tx_t hostap_data_start_xmit(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint need_headroom, need_tailroom = 0;\n\tstruct ieee80211_hdr hdr;\n\tu16 fc, ethertype = 0;\n\tenum {\n\t\tWDS_NO = 0, WDS_OWN_FRAME, WDS_COMPLIANT_FRAME\n\t} use_wds = WDS_NO;\n\tu8 *encaps_data;\n\tint hdr_len, encaps_len, skip_header_bytes;\n\tint to_assoc_ap = 0;\n\tstruct hostap_skb_tx_data *meta;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (skb->len < ETH_HLEN) {\n\t\tprintk(KERN_DEBUG \"%s: hostap_data_start_xmit: short skb \"\n\t\t       \"(len=%d)\\n\", dev->name, skb->len);\n\t\tkfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (local->ddev != dev) {\n\t\tuse_wds = (local->iw_mode == IW_MODE_MASTER &&\n\t\t\t   !(local->wds_type & HOSTAP_WDS_STANDARD_FRAME)) ?\n\t\t\tWDS_OWN_FRAME : WDS_COMPLIANT_FRAME;\n\t\tif (dev == local->stadev) {\n\t\t\tto_assoc_ap = 1;\n\t\t\tuse_wds = WDS_NO;\n\t\t} else if (dev == local->apdev) {\n\t\t\tprintk(KERN_DEBUG \"%s: prism2_tx: trying to use \"\n\t\t\t       \"AP device with Ethernet net dev\\n\", dev->name);\n\t\t\tkfree_skb(skb);\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t} else {\n\t\tif (local->iw_mode == IW_MODE_REPEAT) {\n\t\t\tprintk(KERN_DEBUG \"%s: prism2_tx: trying to use \"\n\t\t\t       \"non-WDS link in Repeater mode\\n\", dev->name);\n\t\t\tkfree_skb(skb);\n\t\t\treturn NETDEV_TX_OK;\n\t\t} else if (local->iw_mode == IW_MODE_INFRA &&\n\t\t\t   (local->wds_type & HOSTAP_WDS_AP_CLIENT) &&\n\t\t\t   !ether_addr_equal(skb->data + ETH_ALEN, dev->dev_addr)) {\n\t\t\t \n\t\t\tuse_wds = WDS_COMPLIANT_FRAME;\n\t\t}\n\t}\n\n\t \n\n\tethertype = (skb->data[12] << 8) | skb->data[13];\n\n\tmemset(&hdr, 0, sizeof(hdr));\n\n\t \n\tencaps_data = NULL;\n\tencaps_len = 0;\n\tskip_header_bytes = ETH_HLEN;\n\tif (ethertype == ETH_P_AARP || ethertype == ETH_P_IPX) {\n\t\tencaps_data = bridge_tunnel_header;\n\t\tencaps_len = sizeof(bridge_tunnel_header);\n\t\tskip_header_bytes -= 2;\n\t} else if (ethertype >= 0x600) {\n\t\tencaps_data = rfc1042_header;\n\t\tencaps_len = sizeof(rfc1042_header);\n\t\tskip_header_bytes -= 2;\n\t}\n\n\tfc = IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA;\n\thdr_len = IEEE80211_DATA_HDR3_LEN;\n\n\tif (use_wds != WDS_NO) {\n\t\t \n\n\t\tif (use_wds == WDS_COMPLIANT_FRAME) {\n\t\t\tfc |= IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS;\n\t\t\t \n\t\t\tskb_copy_from_linear_data_offset(skb, ETH_ALEN,\n\t\t\t\t\t\t\t &hdr.addr4, ETH_ALEN);\n\t\t\thdr_len += ETH_ALEN;\n\t\t} else {\n\t\t\t \n\t\t\tfc |= IEEE80211_FCTL_TODS;\n\t\t\t \n\n\t\t\t \n\t\t\tskb_copy_from_linear_data_offset(skb, ETH_ALEN,\n\t\t\t\t\t\t\t &hdr.addr4, ETH_ALEN);\n\t\t\tneed_tailroom += ETH_ALEN;\n\t\t}\n\n\t\t \n\t\tif ((local->wds_type & HOSTAP_WDS_BROADCAST_RA) &&\n\t\t    is_multicast_ether_addr(skb->data))\n\t\t\teth_broadcast_addr(hdr.addr1);\n\t\telse if (iface->type == HOSTAP_INTERFACE_WDS)\n\t\t\tmemcpy(&hdr.addr1, iface->u.wds.remote_addr,\n\t\t\t       ETH_ALEN);\n\t\telse\n\t\t\tmemcpy(&hdr.addr1, local->bssid, ETH_ALEN);\n\t\tmemcpy(&hdr.addr2, dev->dev_addr, ETH_ALEN);\n\t\tskb_copy_from_linear_data(skb, &hdr.addr3, ETH_ALEN);\n\t} else if (local->iw_mode == IW_MODE_MASTER && !to_assoc_ap) {\n\t\tfc |= IEEE80211_FCTL_FROMDS;\n\t\t \n\t\tskb_copy_from_linear_data(skb, &hdr.addr1, ETH_ALEN);\n\t\tmemcpy(&hdr.addr2, dev->dev_addr, ETH_ALEN);\n\t\tskb_copy_from_linear_data_offset(skb, ETH_ALEN, &hdr.addr3,\n\t\t\t\t\t\t ETH_ALEN);\n\t} else if (local->iw_mode == IW_MODE_INFRA || to_assoc_ap) {\n\t\tfc |= IEEE80211_FCTL_TODS;\n\t\t \n\t\tmemcpy(&hdr.addr1, to_assoc_ap ?\n\t\t       local->assoc_ap_addr : local->bssid, ETH_ALEN);\n\t\tskb_copy_from_linear_data_offset(skb, ETH_ALEN, &hdr.addr2,\n\t\t\t\t\t\t ETH_ALEN);\n\t\tskb_copy_from_linear_data(skb, &hdr.addr3, ETH_ALEN);\n\t} else if (local->iw_mode == IW_MODE_ADHOC) {\n\t\t \n\t\tskb_copy_from_linear_data(skb, &hdr.addr1, ETH_ALEN);\n\t\tskb_copy_from_linear_data_offset(skb, ETH_ALEN, &hdr.addr2,\n\t\t\t\t\t\t ETH_ALEN);\n\t\tmemcpy(&hdr.addr3, local->bssid, ETH_ALEN);\n\t}\n\n\thdr.frame_control = cpu_to_le16(fc);\n\n\tskb_pull(skb, skip_header_bytes);\n\tneed_headroom = local->func->need_tx_headroom + hdr_len + encaps_len;\n\tif (skb_tailroom(skb) < need_tailroom) {\n\t\tskb = skb_unshare(skb, GFP_ATOMIC);\n\t\tif (skb == NULL) {\n\t\t\tiface->stats.tx_dropped++;\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t\tif (pskb_expand_head(skb, need_headroom, need_tailroom,\n\t\t\t\t     GFP_ATOMIC)) {\n\t\t\tkfree_skb(skb);\n\t\t\tiface->stats.tx_dropped++;\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t} else if (skb_headroom(skb) < need_headroom) {\n\t\tstruct sk_buff *tmp = skb;\n\t\tskb = skb_realloc_headroom(skb, need_headroom);\n\t\tkfree_skb(tmp);\n\t\tif (skb == NULL) {\n\t\t\tiface->stats.tx_dropped++;\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t} else {\n\t\tskb = skb_unshare(skb, GFP_ATOMIC);\n\t\tif (skb == NULL) {\n\t\t\tiface->stats.tx_dropped++;\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t}\n\n\tif (encaps_data)\n\t\tmemcpy(skb_push(skb, encaps_len), encaps_data, encaps_len);\n\tmemcpy(skb_push(skb, hdr_len), &hdr, hdr_len);\n\tif (use_wds == WDS_OWN_FRAME) {\n\t\tskb_put_data(skb, &hdr.addr4, ETH_ALEN);\n\t}\n\n\tiface->stats.tx_packets++;\n\tiface->stats.tx_bytes += skb->len;\n\n\tskb_reset_mac_header(skb);\n\tmeta = (struct hostap_skb_tx_data *) skb->cb;\n\tmemset(meta, 0, sizeof(*meta));\n\tmeta->magic = HOSTAP_SKB_TX_DATA_MAGIC;\n\tif (use_wds)\n\t\tmeta->flags |= HOSTAP_TX_FLAGS_WDS;\n\tmeta->ethertype = ethertype;\n\tmeta->iface = iface;\n\n\t \n\tskb->dev = local->dev;\n\tdev_queue_xmit(skb);\n\treturn NETDEV_TX_OK;\n}\n\n\n \nnetdev_tx_t hostap_mgmt_start_xmit(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tstruct hostap_skb_tx_data *meta;\n\tstruct ieee80211_hdr *hdr;\n\tu16 fc;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (skb->len < 10) {\n\t\tprintk(KERN_DEBUG \"%s: hostap_mgmt_start_xmit: short skb \"\n\t\t       \"(len=%d)\\n\", dev->name, skb->len);\n\t\tkfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tiface->stats.tx_packets++;\n\tiface->stats.tx_bytes += skb->len;\n\n\tmeta = (struct hostap_skb_tx_data *) skb->cb;\n\tmemset(meta, 0, sizeof(*meta));\n\tmeta->magic = HOSTAP_SKB_TX_DATA_MAGIC;\n\tmeta->iface = iface;\n\n\tif (skb->len >= IEEE80211_DATA_HDR3_LEN + sizeof(rfc1042_header) + 2) {\n\t\thdr = (struct ieee80211_hdr *) skb->data;\n\t\tfc = le16_to_cpu(hdr->frame_control);\n\t\tif (ieee80211_is_data(hdr->frame_control) &&\n\t\t    (fc & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_DATA) {\n\t\t\tu8 *pos = &skb->data[IEEE80211_DATA_HDR3_LEN +\n\t\t\t\t\t     sizeof(rfc1042_header)];\n\t\t\tmeta->ethertype = (pos[0] << 8) | pos[1];\n\t\t}\n\t}\n\n\t \n\tskb->dev = local->dev;\n\tdev_queue_xmit(skb);\n\treturn NETDEV_TX_OK;\n}\n\n\n \nstatic struct sk_buff * hostap_tx_encrypt(struct sk_buff *skb,\n\t\t\t\t\t  struct lib80211_crypt_data *crypt)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tstruct ieee80211_hdr *hdr;\n\tint prefix_len, postfix_len, hdr_len, res;\n\n\tiface = netdev_priv(skb->dev);\n\tlocal = iface->local;\n\n\tif (skb->len < IEEE80211_DATA_HDR3_LEN) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tif (local->tkip_countermeasures &&\n\t    strcmp(crypt->ops->name, \"TKIP\") == 0) {\n\t\thdr = (struct ieee80211_hdr *) skb->data;\n\t\tif (net_ratelimit()) {\n\t\t\tprintk(KERN_DEBUG \"%s: TKIP countermeasures: dropped \"\n\t\t\t       \"TX packet to %pM\\n\",\n\t\t\t       local->dev->name, hdr->addr1);\n\t\t}\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tskb = skb_unshare(skb, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn NULL;\n\n\tprefix_len = crypt->ops->extra_mpdu_prefix_len +\n\t\tcrypt->ops->extra_msdu_prefix_len;\n\tpostfix_len = crypt->ops->extra_mpdu_postfix_len +\n\t\tcrypt->ops->extra_msdu_postfix_len;\n\tif ((skb_headroom(skb) < prefix_len ||\n\t     skb_tailroom(skb) < postfix_len) &&\n\t    pskb_expand_head(skb, prefix_len, postfix_len, GFP_ATOMIC)) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\thdr_len = hostap_80211_get_hdrlen(hdr->frame_control);\n\n\t \n\tatomic_inc(&crypt->refcnt);\n\tres = 0;\n\tif (crypt->ops->encrypt_msdu)\n\t\tres = crypt->ops->encrypt_msdu(skb, hdr_len, crypt->priv);\n\tif (res == 0 && crypt->ops->encrypt_mpdu)\n\t\tres = crypt->ops->encrypt_mpdu(skb, hdr_len, crypt->priv);\n\tatomic_dec(&crypt->refcnt);\n\tif (res < 0) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\treturn skb;\n}\n\n\n \nnetdev_tx_t hostap_master_start_xmit(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tnetdev_tx_t ret = NETDEV_TX_BUSY;\n\tu16 fc;\n\tstruct hostap_tx_data tx;\n\tap_tx_ret tx_ret;\n\tstruct hostap_skb_tx_data *meta;\n\tint no_encrypt = 0;\n\tstruct ieee80211_hdr *hdr;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\ttx.skb = skb;\n\ttx.sta_ptr = NULL;\n\n\tmeta = (struct hostap_skb_tx_data *) skb->cb;\n\tif (meta->magic != HOSTAP_SKB_TX_DATA_MAGIC) {\n\t\tprintk(KERN_DEBUG \"%s: invalid skb->cb magic (0x%08x, \"\n\t\t       \"expected 0x%08x)\\n\",\n\t\t       dev->name, meta->magic, HOSTAP_SKB_TX_DATA_MAGIC);\n\t\tret = NETDEV_TX_OK;\n\t\tiface->stats.tx_dropped++;\n\t\tgoto fail;\n\t}\n\n\tif (local->host_encrypt) {\n\t\t \n\t\ttx.crypt = local->crypt_info.crypt[local->crypt_info.tx_keyidx];\n\t\ttx.host_encrypt = 1;\n\t} else {\n\t\ttx.crypt = NULL;\n\t\ttx.host_encrypt = 0;\n\t}\n\n\tif (skb->len < 24) {\n\t\tprintk(KERN_DEBUG \"%s: hostap_master_start_xmit: short skb \"\n\t\t       \"(len=%d)\\n\", dev->name, skb->len);\n\t\tret = NETDEV_TX_OK;\n\t\tiface->stats.tx_dropped++;\n\t\tgoto fail;\n\t}\n\n\t \n\ttx_ret = hostap_handle_sta_tx(local, &tx);\n\tskb = tx.skb;\n\tmeta = (struct hostap_skb_tx_data *) skb->cb;\n\thdr = (struct ieee80211_hdr *) skb->data;\n\tfc = le16_to_cpu(hdr->frame_control);\n\tswitch (tx_ret) {\n\tcase AP_TX_CONTINUE:\n\t\tbreak;\n\tcase AP_TX_CONTINUE_NOT_AUTHORIZED:\n\t\tif (local->ieee_802_1x &&\n\t\t    ieee80211_is_data(hdr->frame_control) &&\n\t\t    meta->ethertype != ETH_P_PAE &&\n\t\t    !(meta->flags & HOSTAP_TX_FLAGS_WDS)) {\n\t\t\tprintk(KERN_DEBUG \"%s: dropped frame to unauthorized \"\n\t\t\t       \"port (IEEE 802.1X): ethertype=0x%04x\\n\",\n\t\t\t       dev->name, meta->ethertype);\n\t\t\thostap_dump_tx_80211(dev->name, skb);\n\n\t\t\tret = NETDEV_TX_OK;  \n\t\t\tiface->stats.tx_dropped++;\n\t\t\tgoto fail;\n\t\t}\n\t\tbreak;\n\tcase AP_TX_DROP:\n\t\tret = NETDEV_TX_OK;  \n\t\tiface->stats.tx_dropped++;\n\t\tgoto fail;\n\tcase AP_TX_RETRY:\n\t\tgoto fail;\n\tcase AP_TX_BUFFERED:\n\t\t \n\t\tret = NETDEV_TX_OK;\n\t\tgoto tx_exit;\n\t}\n\n\t \n\tif (((fc & IEEE80211_FCTL_VERS) == BIT(1)) &&\n\t    local->ap && local->ap->tx_callback_idx && meta->tx_cb_idx == 0) {\n\t\tmeta->tx_cb_idx = local->ap->tx_callback_idx;\n\n\t\t \n\t\tfc &= ~IEEE80211_FCTL_VERS;\n\t\thdr->frame_control = cpu_to_le16(fc);\n\t}\n\n\tif (!ieee80211_is_data(hdr->frame_control)) {\n\t\tno_encrypt = 1;\n\t\ttx.crypt = NULL;\n\t}\n\n\tif (local->ieee_802_1x && meta->ethertype == ETH_P_PAE && tx.crypt &&\n\t    !(fc & IEEE80211_FCTL_PROTECTED)) {\n\t\tno_encrypt = 1;\n\t\tPDEBUG(DEBUG_EXTRA2, \"%s: TX: IEEE 802.1X - passing \"\n\t\t       \"unencrypted EAPOL frame\\n\", dev->name);\n\t\ttx.crypt = NULL;  \n\t}\n\n\tif (tx.crypt && (!tx.crypt->ops || !tx.crypt->ops->encrypt_mpdu))\n\t\ttx.crypt = NULL;\n\telse if ((tx.crypt ||\n\t\t local->crypt_info.crypt[local->crypt_info.tx_keyidx]) &&\n\t\t !no_encrypt) {\n\t\t \n\t\tfc |= IEEE80211_FCTL_PROTECTED;\n\t\thdr->frame_control = cpu_to_le16(fc);\n\t} else if (local->drop_unencrypted &&\n\t\t   ieee80211_is_data(hdr->frame_control) &&\n\t\t   meta->ethertype != ETH_P_PAE) {\n\t\tif (net_ratelimit()) {\n\t\t\tprintk(KERN_DEBUG \"%s: dropped unencrypted TX data \"\n\t\t\t       \"frame (drop_unencrypted=1)\\n\", dev->name);\n\t\t}\n\t\tiface->stats.tx_dropped++;\n\t\tret = NETDEV_TX_OK;\n\t\tgoto fail;\n\t}\n\n\tif (tx.crypt) {\n\t\tskb = hostap_tx_encrypt(skb, tx.crypt);\n\t\tif (skb == NULL) {\n\t\t\tprintk(KERN_DEBUG \"%s: TX - encryption failed\\n\",\n\t\t\t       dev->name);\n\t\t\tret = NETDEV_TX_OK;\n\t\t\tgoto fail;\n\t\t}\n\t\tmeta = (struct hostap_skb_tx_data *) skb->cb;\n\t\tif (meta->magic != HOSTAP_SKB_TX_DATA_MAGIC) {\n\t\t\tprintk(KERN_DEBUG \"%s: invalid skb->cb magic (0x%08x, \"\n\t\t\t       \"expected 0x%08x) after hostap_tx_encrypt\\n\",\n\t\t\t       dev->name, meta->magic,\n\t\t\t       HOSTAP_SKB_TX_DATA_MAGIC);\n\t\t\tret = NETDEV_TX_OK;\n\t\t\tiface->stats.tx_dropped++;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (local->func->tx == NULL || local->func->tx(skb, dev)) {\n\t\tret = NETDEV_TX_OK;\n\t\tiface->stats.tx_dropped++;\n\t} else {\n\t\tret = NETDEV_TX_OK;\n\t\tiface->stats.tx_packets++;\n\t\tiface->stats.tx_bytes += skb->len;\n\t}\n\n fail:\n\tif (ret == NETDEV_TX_OK && skb)\n\t\tdev_kfree_skb(skb);\n tx_exit:\n\tif (tx.sta_ptr)\n\t\thostap_handle_sta_release(tx.sta_ptr);\n\treturn ret;\n}\n\n\nEXPORT_SYMBOL(hostap_master_start_xmit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}