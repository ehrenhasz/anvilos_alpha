{
  "module_name": "hostap_cs.c",
  "hash_id": "dd9c7cdd736be222e63f9f74dda14620750c8cc00de8b4185b150eb9416b3489",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/hostap/hostap_cs.c",
  "human_readable_source": "\n#define PRISM2_PCCARD\n\n#include <linux/module.h>\n#include <linux/if.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/workqueue.h>\n#include <linux/wireless.h>\n#include <net/iw_handler.h>\n\n#include <pcmcia/cistpl.h>\n#include <pcmcia/cisreg.h>\n#include <pcmcia/ds.h>\n\n#include <asm/io.h>\n\n#include \"hostap_wlan.h\"\n\n\nstatic char *dev_info = \"hostap_cs\";\n\nMODULE_AUTHOR(\"Jouni Malinen\");\nMODULE_DESCRIPTION(\"Support for Intersil Prism2-based 802.11 wireless LAN \"\n\t\t   \"cards (PC Card).\");\nMODULE_LICENSE(\"GPL\");\n\n\nstatic int ignore_cis_vcc;\nmodule_param(ignore_cis_vcc, int, 0444);\nMODULE_PARM_DESC(ignore_cis_vcc, \"Ignore broken CIS VCC entry\");\n\n\n \nstruct hostap_cs_priv {\n\tstruct pcmcia_device *link;\n\tint sandisk_connectplus;\n};\n\n\n#ifdef PRISM2_IO_DEBUG\n\nstatic inline void hfa384x_outb_debug(struct net_device *dev, int a, u8 v)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tunsigned long flags;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\tspin_lock_irqsave(&local->lock, flags);\n\tprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_OUTB, a, v);\n\toutb(v, dev->base_addr + a);\n\tspin_unlock_irqrestore(&local->lock, flags);\n}\n\nstatic inline u8 hfa384x_inb_debug(struct net_device *dev, int a)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tunsigned long flags;\n\tu8 v;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\tspin_lock_irqsave(&local->lock, flags);\n\tv = inb(dev->base_addr + a);\n\tprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_INB, a, v);\n\tspin_unlock_irqrestore(&local->lock, flags);\n\treturn v;\n}\n\nstatic inline void hfa384x_outw_debug(struct net_device *dev, int a, u16 v)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tunsigned long flags;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\tspin_lock_irqsave(&local->lock, flags);\n\tprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_OUTW, a, v);\n\toutw(v, dev->base_addr + a);\n\tspin_unlock_irqrestore(&local->lock, flags);\n}\n\nstatic inline u16 hfa384x_inw_debug(struct net_device *dev, int a)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tunsigned long flags;\n\tu16 v;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\tspin_lock_irqsave(&local->lock, flags);\n\tv = inw(dev->base_addr + a);\n\tprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_INW, a, v);\n\tspin_unlock_irqrestore(&local->lock, flags);\n\treturn v;\n}\n\nstatic inline void hfa384x_outsw_debug(struct net_device *dev, int a,\n\t\t\t\t       u8 *buf, int wc)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tunsigned long flags;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\tspin_lock_irqsave(&local->lock, flags);\n\tprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_OUTSW, a, wc);\n\toutsw(dev->base_addr + a, buf, wc);\n\tspin_unlock_irqrestore(&local->lock, flags);\n}\n\nstatic inline void hfa384x_insw_debug(struct net_device *dev, int a,\n\t\t\t\t      u8 *buf, int wc)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tunsigned long flags;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\tspin_lock_irqsave(&local->lock, flags);\n\tprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_INSW, a, wc);\n\tinsw(dev->base_addr + a, buf, wc);\n\tspin_unlock_irqrestore(&local->lock, flags);\n}\n\n#define HFA384X_OUTB(v,a) hfa384x_outb_debug(dev, (a), (v))\n#define HFA384X_INB(a) hfa384x_inb_debug(dev, (a))\n#define HFA384X_OUTW(v,a) hfa384x_outw_debug(dev, (a), (v))\n#define HFA384X_INW(a) hfa384x_inw_debug(dev, (a))\n#define HFA384X_OUTSW(a, buf, wc) hfa384x_outsw_debug(dev, (a), (buf), (wc))\n#define HFA384X_INSW(a, buf, wc) hfa384x_insw_debug(dev, (a), (buf), (wc))\n\n#else  \n\n#define HFA384X_OUTB(v,a) outb((v), dev->base_addr + (a))\n#define HFA384X_INB(a) inb(dev->base_addr + (a))\n#define HFA384X_OUTW(v,a) outw((v), dev->base_addr + (a))\n#define HFA384X_INW(a) inw(dev->base_addr + (a))\n#define HFA384X_INSW(a, buf, wc) insw(dev->base_addr + (a), buf, wc)\n#define HFA384X_OUTSW(a, buf, wc) outsw(dev->base_addr + (a), buf, wc)\n\n#endif  \n\n\nstatic int hfa384x_from_bap(struct net_device *dev, u16 bap, void *buf,\n\t\t\t    int len)\n{\n\tu16 d_off;\n\tu16 *pos;\n\n\td_off = (bap == 1) ? HFA384X_DATA1_OFF : HFA384X_DATA0_OFF;\n\tpos = (u16 *) buf;\n\n\tif (len / 2)\n\t\tHFA384X_INSW(d_off, buf, len / 2);\n\tpos += len / 2;\n\n\tif (len & 1)\n\t\t*((char *) pos) = HFA384X_INB(d_off);\n\n\treturn 0;\n}\n\n\nstatic int hfa384x_to_bap(struct net_device *dev, u16 bap, void *buf, int len)\n{\n\tu16 d_off;\n\tu16 *pos;\n\n\td_off = (bap == 1) ? HFA384X_DATA1_OFF : HFA384X_DATA0_OFF;\n\tpos = (u16 *) buf;\n\n\tif (len / 2)\n\t\tHFA384X_OUTSW(d_off, buf, len / 2);\n\tpos += len / 2;\n\n\tif (len & 1)\n\t\tHFA384X_OUTB(*((char *) pos), d_off);\n\n\treturn 0;\n}\n\n\n \n#include \"hostap_hw.c\"\n\n\n\nstatic void prism2_detach(struct pcmcia_device *p_dev);\nstatic void prism2_release(u_long arg);\nstatic int prism2_config(struct pcmcia_device *link);\n\n\nstatic int prism2_pccard_card_present(local_info_t *local)\n{\n\tstruct hostap_cs_priv *hw_priv = local->hw_priv;\n\tif (hw_priv != NULL && hw_priv->link != NULL && pcmcia_dev_present(hw_priv->link))\n\t\treturn 1;\n\treturn 0;\n}\n\n\n \n#define SANDISK_WLAN_ACTIVATION_OFF 0x40\n#define SANDISK_HCR_OFF 0x42\n\n\nstatic void sandisk_set_iobase(local_info_t *local)\n{\n\tint res;\n\tstruct hostap_cs_priv *hw_priv = local->hw_priv;\n\n\tres = pcmcia_write_config_byte(hw_priv->link, 0x10,\n\t\t\t\thw_priv->link->resource[0]->start & 0x00ff);\n\tif (res != 0) {\n\t\tprintk(KERN_DEBUG \"Prism3 SanDisk - failed to set I/O base 0 -\"\n\t\t       \" res=%d\\n\", res);\n\t}\n\tudelay(10);\n\n\tres = pcmcia_write_config_byte(hw_priv->link, 0x12,\n\t\t\t\t(hw_priv->link->resource[0]->start >> 8) & 0x00ff);\n\tif (res != 0) {\n\t\tprintk(KERN_DEBUG \"Prism3 SanDisk - failed to set I/O base 1 -\"\n\t\t       \" res=%d\\n\", res);\n\t}\n}\n\n\nstatic void sandisk_write_hcr(local_info_t *local, int hcr)\n{\n\tstruct net_device *dev = local->dev;\n\tint i;\n\n\tHFA384X_OUTB(0x80, SANDISK_WLAN_ACTIVATION_OFF);\n\tudelay(50);\n\tfor (i = 0; i < 10; i++) {\n\t\tHFA384X_OUTB(hcr, SANDISK_HCR_OFF);\n\t}\n\tudelay(55);\n\tHFA384X_OUTB(0x45, SANDISK_WLAN_ACTIVATION_OFF);\n}\n\n\nstatic int sandisk_enable_wireless(struct net_device *dev)\n{\n\tint res, ret = 0;\n\tstruct hostap_interface *iface = netdev_priv(dev);\n\tlocal_info_t *local = iface->local;\n\tstruct hostap_cs_priv *hw_priv = local->hw_priv;\n\n\tif (resource_size(hw_priv->link->resource[0]) < 0x42) {\n\t\t \n\t\tret = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tif (hw_priv->link->manf_id != 0xd601 || hw_priv->link->card_id != 0x0101) {\n\t\t \n\t\tret = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tif (hw_priv->link->socket->functions < 2) {\n\t\t \n\t\tret = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tprintk(KERN_DEBUG \"%s: Multi-function SanDisk ConnectPlus detected\"\n\t       \" - using vendor-specific initialization\\n\", dev->name);\n\thw_priv->sandisk_connectplus = 1;\n\n\tres = pcmcia_write_config_byte(hw_priv->link, CISREG_COR,\n\t\t\t\tCOR_SOFT_RESET);\n\tif (res != 0) {\n\t\tprintk(KERN_DEBUG \"%s: SanDisk - COR sreset failed (%d)\\n\",\n\t\t       dev->name, res);\n\t\tgoto done;\n\t}\n\tmdelay(5);\n\n\t \n\tres = pcmcia_write_config_byte(hw_priv->link, CISREG_COR,\n\t\t\t\t(COR_LEVEL_REQ | 0x8 | COR_ADDR_DECODE |\n\t\t\t\t\tCOR_FUNC_ENA));\n\tif (res != 0) {\n\t\tprintk(KERN_DEBUG \"%s: SanDisk - COR sreset failed (%d)\\n\",\n\t\t       dev->name, res);\n\t\tgoto done;\n\t}\n\tmdelay(5);\n\n\tsandisk_set_iobase(local);\n\n\tHFA384X_OUTB(0xc5, SANDISK_WLAN_ACTIVATION_OFF);\n\tudelay(10);\n\tHFA384X_OUTB(0x4b, SANDISK_WLAN_ACTIVATION_OFF);\n\tudelay(10);\n\ndone:\n\treturn ret;\n}\n\n\nstatic void prism2_pccard_cor_sreset(local_info_t *local)\n{\n\tint res;\n\tu8 val;\n\tstruct hostap_cs_priv *hw_priv = local->hw_priv;\n\n\tif (!prism2_pccard_card_present(local))\n\t       return;\n\n\tres = pcmcia_read_config_byte(hw_priv->link, CISREG_COR, &val);\n\tif (res != 0) {\n\t\tprintk(KERN_DEBUG \"prism2_pccard_cor_sreset failed 1 (%d)\\n\",\n\t\t       res);\n\t\treturn;\n\t}\n\tprintk(KERN_DEBUG \"prism2_pccard_cor_sreset: original COR %02x\\n\",\n\t\tval);\n\n\tval |= COR_SOFT_RESET;\n\tres = pcmcia_write_config_byte(hw_priv->link, CISREG_COR, val);\n\tif (res != 0) {\n\t\tprintk(KERN_DEBUG \"prism2_pccard_cor_sreset failed 2 (%d)\\n\",\n\t\t       res);\n\t\treturn;\n\t}\n\n\tmdelay(hw_priv->sandisk_connectplus ? 5 : 2);\n\n\tval &= ~COR_SOFT_RESET;\n\tif (hw_priv->sandisk_connectplus)\n\t\tval |= COR_IREQ_ENA;\n\tres = pcmcia_write_config_byte(hw_priv->link, CISREG_COR, val);\n\tif (res != 0) {\n\t\tprintk(KERN_DEBUG \"prism2_pccard_cor_sreset failed 3 (%d)\\n\",\n\t\t       res);\n\t\treturn;\n\t}\n\n\tmdelay(hw_priv->sandisk_connectplus ? 5 : 2);\n\n\tif (hw_priv->sandisk_connectplus)\n\t\tsandisk_set_iobase(local);\n}\n\n\nstatic void prism2_pccard_genesis_reset(local_info_t *local, int hcr)\n{\n\tint res;\n\tu8 old_cor;\n\tstruct hostap_cs_priv *hw_priv = local->hw_priv;\n\n\tif (!prism2_pccard_card_present(local))\n\t       return;\n\n\tif (hw_priv->sandisk_connectplus) {\n\t\tsandisk_write_hcr(local, hcr);\n\t\treturn;\n\t}\n\n\tres = pcmcia_read_config_byte(hw_priv->link, CISREG_COR, &old_cor);\n\tif (res != 0) {\n\t\tprintk(KERN_DEBUG \"%s failed 1 (%d)\\n\", __func__, res);\n\t\treturn;\n\t}\n\tprintk(KERN_DEBUG \"%s: original COR %02x\\n\", __func__, old_cor);\n\n\tres = pcmcia_write_config_byte(hw_priv->link, CISREG_COR,\n\t\t\t\told_cor | COR_SOFT_RESET);\n\tif (res != 0) {\n\t\tprintk(KERN_DEBUG \"%s failed 2 (%d)\\n\", __func__, res);\n\t\treturn;\n\t}\n\n\tmdelay(10);\n\n\t \n\tres = pcmcia_write_config_byte(hw_priv->link, CISREG_CCSR, hcr);\n\tif (res != 0) {\n\t\tprintk(KERN_DEBUG \"%s failed 3 (%d)\\n\", __func__, res);\n\t\treturn;\n\t}\n\tmdelay(10);\n\n\tres = pcmcia_write_config_byte(hw_priv->link, CISREG_COR,\n\t\t\t\told_cor & ~COR_SOFT_RESET);\n\tif (res != 0) {\n\t\tprintk(KERN_DEBUG \"%s failed 4 (%d)\\n\", __func__, res);\n\t\treturn;\n\t}\n\n\tmdelay(10);\n}\n\n\nstatic struct prism2_helper_functions prism2_pccard_funcs =\n{\n\t.card_present\t= prism2_pccard_card_present,\n\t.cor_sreset\t= prism2_pccard_cor_sreset,\n\t.genesis_reset\t= prism2_pccard_genesis_reset,\n\t.hw_type\t= HOSTAP_HW_PCCARD,\n};\n\n\n \nstatic int hostap_cs_probe(struct pcmcia_device *p_dev)\n{\n\tint ret;\n\n\tPDEBUG(DEBUG_HW, \"%s: setting Vcc=33 (constant)\\n\", dev_info);\n\n\tret = prism2_config(p_dev);\n\tif (ret) {\n\t\tPDEBUG(DEBUG_EXTRA, \"prism2_config() failed\\n\");\n\t}\n\n\treturn ret;\n}\n\n\nstatic void prism2_detach(struct pcmcia_device *link)\n{\n\tPDEBUG(DEBUG_FLOW, \"prism2_detach\\n\");\n\n\tprism2_release((u_long)link);\n\n\t \n\tif (link->priv) {\n\t\tstruct hostap_cs_priv *hw_priv;\n\t\tstruct net_device *dev;\n\t\tstruct hostap_interface *iface;\n\t\tdev = link->priv;\n\t\tiface = netdev_priv(dev);\n\t\thw_priv = iface->local->hw_priv;\n\t\tprism2_free_local_data(dev);\n\t\tkfree(hw_priv);\n\t}\n}\n\n\nstatic int prism2_config_check(struct pcmcia_device *p_dev, void *priv_data)\n{\n\tif (p_dev->config_index == 0)\n\t\treturn -EINVAL;\n\n\treturn pcmcia_request_io(p_dev);\n}\n\nstatic int prism2_config(struct pcmcia_device *link)\n{\n\tstruct net_device *dev;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint ret;\n\tstruct hostap_cs_priv *hw_priv;\n\tunsigned long flags;\n\n\tPDEBUG(DEBUG_FLOW, \"prism2_config()\\n\");\n\n\thw_priv = kzalloc(sizeof(*hw_priv), GFP_KERNEL);\n\tif (hw_priv == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\t \n\tlink->config_flags |= CONF_AUTO_SET_VPP | CONF_AUTO_AUDIO |\n\t\tCONF_AUTO_CHECK_VCC | CONF_AUTO_SET_IO | CONF_ENABLE_IRQ;\n\tif (ignore_cis_vcc)\n\t\tlink->config_flags &= ~CONF_AUTO_CHECK_VCC;\n\tret = pcmcia_loop_config(link, prism2_config_check, NULL);\n\tif (ret) {\n\t\tif (!ignore_cis_vcc)\n\t\t\tprintk(KERN_ERR \"GetNextTuple(): No matching \"\n\t\t\t       \"CIS configuration.  Maybe you need the \"\n\t\t\t       \"ignore_cis_vcc=1 parameter.\\n\");\n\t\tgoto failed;\n\t}\n\n\t \n\tdev = prism2_init_local_data(&prism2_pccard_funcs, 0,\n\t\t\t\t     &link->dev);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto failed;\n\t}\n\tlink->priv = dev;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\tlocal->hw_priv = hw_priv;\n\thw_priv->link = link;\n\n\t \n\tret = pcmcia_request_irq(link, prism2_interrupt);\n\tif (ret)\n\t\tgoto failed;\n\n\tret = pcmcia_enable_device(link);\n\tif (ret)\n\t\tgoto failed;\n\n\tspin_lock_irqsave(&local->irq_init_lock, flags);\n\tdev->irq = link->irq;\n\tdev->base_addr = link->resource[0]->start;\n\tspin_unlock_irqrestore(&local->irq_init_lock, flags);\n\n\tlocal->shutdown = 0;\n\n\tsandisk_enable_wireless(dev);\n\n\tret = prism2_hw_config(dev, 1);\n\tif (!ret)\n\t\tret = hostap_hw_ready(dev);\n\n\treturn ret;\n\n failed:\n\tkfree(hw_priv);\n\tprism2_release((u_long)link);\n\treturn ret;\n}\n\n\nstatic void prism2_release(u_long arg)\n{\n\tstruct pcmcia_device *link = (struct pcmcia_device *)arg;\n\n\tPDEBUG(DEBUG_FLOW, \"prism2_release\\n\");\n\n\tif (link->priv) {\n\t\tstruct net_device *dev = link->priv;\n\t\tstruct hostap_interface *iface;\n\n\t\tiface = netdev_priv(dev);\n\t\tprism2_hw_shutdown(dev, 0);\n\t\tiface->local->shutdown = 1;\n\t}\n\n\tpcmcia_disable_device(link);\n\tPDEBUG(DEBUG_FLOW, \"release - done\\n\");\n}\n\nstatic int hostap_cs_suspend(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = (struct net_device *) link->priv;\n\tint dev_open = 0;\n\tstruct hostap_interface *iface = NULL;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tiface = netdev_priv(dev);\n\n\tPDEBUG(DEBUG_EXTRA, \"%s: CS_EVENT_PM_SUSPEND\\n\", dev_info);\n\tif (iface && iface->local)\n\t\tdev_open = iface->local->num_dev_open > 0;\n\tif (dev_open) {\n\t\tnetif_stop_queue(dev);\n\t\tnetif_device_detach(dev);\n\t}\n\tprism2_suspend(dev);\n\n\treturn 0;\n}\n\nstatic int hostap_cs_resume(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = (struct net_device *) link->priv;\n\tint dev_open = 0;\n\tstruct hostap_interface *iface = NULL;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tiface = netdev_priv(dev);\n\n\tPDEBUG(DEBUG_EXTRA, \"%s: CS_EVENT_PM_RESUME\\n\", dev_info);\n\n\tif (iface && iface->local)\n\t\tdev_open = iface->local->num_dev_open > 0;\n\n\tprism2_hw_shutdown(dev, 1);\n\tprism2_hw_config(dev, dev_open ? 0 : 1);\n\tif (dev_open) {\n\t\tnetif_device_attach(dev);\n\t\tnetif_start_queue(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pcmcia_device_id hostap_cs_ids[] = {\n\tPCMCIA_DEVICE_MANF_CARD(0x000b, 0x7100),\n\tPCMCIA_DEVICE_MANF_CARD(0x000b, 0x7300),\n\tPCMCIA_DEVICE_MANF_CARD(0x0101, 0x0777),\n\tPCMCIA_DEVICE_MANF_CARD(0x0126, 0x8000),\n\tPCMCIA_DEVICE_MANF_CARD(0x0138, 0x0002),\n\tPCMCIA_DEVICE_MANF_CARD(0x01bf, 0x3301),\n\tPCMCIA_DEVICE_MANF_CARD(0x0250, 0x0002),\n\tPCMCIA_DEVICE_MANF_CARD(0x026f, 0x030b),\n\tPCMCIA_DEVICE_MANF_CARD(0x0274, 0x1612),\n\tPCMCIA_DEVICE_MANF_CARD(0x0274, 0x1613),\n\tPCMCIA_DEVICE_MANF_CARD(0x028a, 0x0002),\n\tPCMCIA_DEVICE_MANF_CARD(0x02aa, 0x0002),\n\tPCMCIA_DEVICE_MANF_CARD(0x02d2, 0x0001),\n\tPCMCIA_DEVICE_MANF_CARD(0x50c2, 0x0001),\n\tPCMCIA_DEVICE_MANF_CARD(0x50c2, 0x7300),\n \n\tPCMCIA_DEVICE_MANF_CARD(0xc250, 0x0002),\n\tPCMCIA_DEVICE_MANF_CARD(0xd601, 0x0002),\n\tPCMCIA_DEVICE_MANF_CARD(0xd601, 0x0005),\n\tPCMCIA_DEVICE_MANF_CARD(0xd601, 0x0010),\n\tPCMCIA_DEVICE_MANF_CARD(0x0126, 0x0002),\n\tPCMCIA_DEVICE_MANF_CARD_PROD_ID1(0xd601, 0x0005, \"ADLINK 345 CF\",\n\t\t\t\t\t 0x2d858104),\n\tPCMCIA_DEVICE_MANF_CARD_PROD_ID1(0x0156, 0x0002, \"INTERSIL\",\n\t\t\t\t\t 0x74c5e40d),\n\tPCMCIA_DEVICE_MANF_CARD_PROD_ID1(0x0156, 0x0002, \"Intersil\",\n\t\t\t\t\t 0x4b801a17),\n\tPCMCIA_DEVICE_MANF_CARD_PROD_ID3(0x0156, 0x0002, \"Version 01.02\",\n\t\t\t\t\t 0x4b74baa0),\n\tPCMCIA_MFC_DEVICE_PROD_ID12(0, \"SanDisk\", \"ConnectPlus\",\n\t\t\t\t    0x7a954bd9, 0x74be00c6),\n\tPCMCIA_DEVICE_PROD_ID123(\n\t\t\"Addtron\", \"AWP-100 Wireless PCMCIA\", \"Version 01.02\",\n\t\t0xe6ec52ce, 0x08649af2, 0x4b74baa0),\n\tPCMCIA_DEVICE_PROD_ID123(\n\t\t\"Canon\", \"Wireless LAN CF Card K30225\", \"Version 01.00\",\n\t\t0x96ef6fe2, 0x263fcbab, 0xa57adb8c),\n\tPCMCIA_DEVICE_PROD_ID123(\n\t\t\"D\", \"Link DWL-650 11Mbps WLAN Card\", \"Version 01.02\",\n\t\t0x71b18589, 0xb6f1b0ab, 0x4b74baa0),\n\tPCMCIA_DEVICE_PROD_ID123(\n\t\t\"Instant Wireless \", \" Network PC CARD\", \"Version 01.02\",\n\t\t0x11d901af, 0x6e9bd926, 0x4b74baa0),\n\tPCMCIA_DEVICE_PROD_ID123(\n\t\t\"SMC\", \"SMC2632W\", \"Version 01.02\",\n\t\t0xc4f8b18b, 0x474a1f2a, 0x4b74baa0),\n\tPCMCIA_DEVICE_PROD_ID12(\"BUFFALO\", \"WLI-CF-S11G\", \n\t\t\t\t0x2decece3, 0x82067c18),\n\tPCMCIA_DEVICE_PROD_ID12(\"Compaq\", \"WL200_11Mbps_Wireless_PCI_Card\",\n\t\t\t\t0x54f7c49c, 0x15a75e5b),\n\tPCMCIA_DEVICE_PROD_ID12(\"INTERSIL\", \"HFA384x/IEEE\",\n\t\t\t\t0x74c5e40d, 0xdb472a18),\n\tPCMCIA_DEVICE_PROD_ID12(\"Linksys\", \"Wireless CompactFlash Card\",\n\t\t\t\t0x0733cc81, 0x0c52f395),\n\tPCMCIA_DEVICE_PROD_ID12(\n\t\t\"ZoomAir 11Mbps High\", \"Rate wireless Networking\",\n\t\t0x273fe3db, 0x32a1eaee),\n\tPCMCIA_DEVICE_PROD_ID12(\"NETGEAR MA401 Wireless PC\", \"Card\",\n\t\t0xa37434e9, 0x9762e8f1),\n\tPCMCIA_DEVICE_PROD_ID123(\n\t\t\"Pretec\", \"CompactWLAN Card 802.11b\", \"2.5\",\n\t\t0x1cadd3e5, 0xe697636c, 0x7a5bfcf1),\n\tPCMCIA_DEVICE_PROD_ID123(\n\t\t\"U.S. Robotics\", \"IEEE 802.11b PC-CARD\", \"Version 01.02\",\n\t\t0xc7b8df9d, 0x1700d087, 0x4b74baa0),\n\tPCMCIA_DEVICE_PROD_ID123(\n\t\t\"Allied Telesyn\", \"AT-WCL452 Wireless PCMCIA Radio\",\n\t\t\"Ver. 1.00\",\n\t\t0x5cd01705, 0x4271660f, 0x9d08ee12),\n\tPCMCIA_DEVICE_PROD_ID123(\n\t\t\"Wireless LAN\" , \"11Mbps PC Card\", \"Version 01.02\",\n\t\t0x4b8870ff, 0x70e946d1, 0x4b74baa0),\n\tPCMCIA_DEVICE_PROD_ID3(\"HFA3863\", 0x355cb092),\n\tPCMCIA_DEVICE_PROD_ID3(\"ISL37100P\", 0x630d52b2),\n\tPCMCIA_DEVICE_PROD_ID3(\"ISL37101P-10\", 0xdd97a26b),\n\tPCMCIA_DEVICE_PROD_ID3(\"ISL37300P\", 0xc9049a39),\n\tPCMCIA_DEVICE_NULL\n};\nMODULE_DEVICE_TABLE(pcmcia, hostap_cs_ids);\n\n\nstatic struct pcmcia_driver hostap_driver = {\n\t.name\t\t= \"hostap_cs\",\n\t.probe\t\t= hostap_cs_probe,\n\t.remove\t\t= prism2_detach,\n\t.owner\t\t= THIS_MODULE,\n\t.id_table\t= hostap_cs_ids,\n\t.suspend\t= hostap_cs_suspend,\n\t.resume\t\t= hostap_cs_resume,\n};\nmodule_pcmcia_driver(hostap_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}