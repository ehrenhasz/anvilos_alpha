{
  "module_name": "hostap_hw.c",
  "hash_id": "55a861f10b8cfdd8a759d556112edb8afce7f34bfbd7eeaa0c8af7c73f790e8e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/hostap/hostap_hw.c",
  "human_readable_source": "\n \n\n\n\n#include <asm/delay.h>\n#include <linux/uaccess.h>\n\n#include <linux/slab.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/if_arp.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/wait.h>\n#include <linux/sched/signal.h>\n#include <linux/rtnetlink.h>\n#include <linux/wireless.h>\n#include <net/iw_handler.h>\n#include <net/lib80211.h>\n#include <asm/irq.h>\n\n#include \"hostap_80211.h\"\n#include \"hostap.h\"\n#include \"hostap_ap.h\"\n\n\n \n\nstatic int mtu = 1500;\nmodule_param(mtu, int, 0444);\nMODULE_PARM_DESC(mtu, \"Maximum transfer unit\");\n\nstatic int channel[MAX_PARM_DEVICES] = { 3, DEF_INTS };\nmodule_param_array(channel, int, NULL, 0444);\nMODULE_PARM_DESC(channel, \"Initial channel\");\n\nstatic char essid[33] = \"test\";\nmodule_param_string(essid, essid, sizeof(essid), 0444);\nMODULE_PARM_DESC(essid, \"Host AP's ESSID\");\n\nstatic int iw_mode[MAX_PARM_DEVICES] = { IW_MODE_MASTER, DEF_INTS };\nmodule_param_array(iw_mode, int, NULL, 0444);\nMODULE_PARM_DESC(iw_mode, \"Initial operation mode\");\n\nstatic int beacon_int[MAX_PARM_DEVICES] = { 100, DEF_INTS };\nmodule_param_array(beacon_int, int, NULL, 0444);\nMODULE_PARM_DESC(beacon_int, \"Beacon interval (1 = 1024 usec)\");\n\nstatic int dtim_period[MAX_PARM_DEVICES] = { 1, DEF_INTS };\nmodule_param_array(dtim_period, int, NULL, 0444);\nMODULE_PARM_DESC(dtim_period, \"DTIM period\");\n\nstatic char dev_template[16] = \"wlan%d\";\nmodule_param_string(dev_template, dev_template, sizeof(dev_template), 0444);\nMODULE_PARM_DESC(dev_template, \"Prefix for network device name (default: \"\n\t\t \"wlan%d)\");\n\n#ifdef final_version\n#define EXTRA_EVENTS_WTERR 0\n#else\n \n#define EXTRA_EVENTS_WTERR HFA384X_EV_WTERR\n#endif\n\n \n#define HFA384X_BAP0_EVENTS \\\n\t(HFA384X_EV_TXEXC | HFA384X_EV_RX | HFA384X_EV_INFO | HFA384X_EV_TX)\n\n \n#define HFA384X_EVENT_MASK \\\n\t(HFA384X_BAP0_EVENTS | HFA384X_EV_ALLOC | HFA384X_EV_INFDROP | \\\n\tHFA384X_EV_CMD | HFA384X_EV_TICK | \\\n\tEXTRA_EVENTS_WTERR)\n\n \n#define HFA384X_TX_CTRL_FLAGS \\\n\t(HFA384X_TX_CTRL_802_11 | HFA384X_TX_CTRL_TX_EX)\n\n\n \n#define HFA384X_CMD_BUSY_TIMEOUT 5000\n#define HFA384X_BAP_BUSY_TIMEOUT 50000\n\n \n#define HFA384X_CMD_COMPL_TIMEOUT 20000\n#define HFA384X_DL_COMPL_TIMEOUT 1000000\n\n \n#define HFA384X_INIT_TIMEOUT (HZ / 2)  \n#define HFA384X_ALLOC_COMPL_TIMEOUT (HZ / 20)  \n\n\nstatic void prism2_hw_reset(struct net_device *dev);\nstatic void prism2_check_sta_fw_version(local_info_t *local);\n\n#ifdef PRISM2_DOWNLOAD_SUPPORT\n \nstatic const struct proc_ops prism2_download_aux_dump_proc_ops;\nstatic u8 * prism2_read_pda(struct net_device *dev);\nstatic int prism2_download(local_info_t *local,\n\t\t\t   struct prism2_download_param *param);\nstatic void prism2_download_free_data(struct prism2_download_data *dl);\nstatic int prism2_download_volatile(local_info_t *local,\n\t\t\t\t    struct prism2_download_data *param);\nstatic int prism2_download_genesis(local_info_t *local,\n\t\t\t\t   struct prism2_download_data *param);\nstatic int prism2_get_ram_size(local_info_t *local);\n#endif  \n\n\n\n\n#ifndef final_version\n \n#define HFA384X_MAGIC 0x8A32\n#endif\n\nstatic void hfa384x_read_regs(struct net_device *dev,\n\t\t\t      struct hfa384x_regs *regs)\n{\n\tregs->cmd = HFA384X_INW(HFA384X_CMD_OFF);\n\tregs->evstat = HFA384X_INW(HFA384X_EVSTAT_OFF);\n\tregs->offset0 = HFA384X_INW(HFA384X_OFFSET0_OFF);\n\tregs->offset1 = HFA384X_INW(HFA384X_OFFSET1_OFF);\n\tregs->swsupport0 = HFA384X_INW(HFA384X_SWSUPPORT0_OFF);\n}\n\n\n \nstatic inline void __hostap_cmd_queue_free(local_info_t *local,\n\t\t\t\t\t   struct hostap_cmd_queue *entry,\n\t\t\t\t\t   int del_req)\n{\n\tif (del_req) {\n\t\tentry->del_req = 1;\n\t\tif (!list_empty(&entry->list)) {\n\t\t\tlist_del_init(&entry->list);\n\t\t\tlocal->cmd_queue_len--;\n\t\t}\n\t}\n\n\tif (refcount_dec_and_test(&entry->usecnt) && entry->del_req)\n\t\tkfree(entry);\n}\n\n\n \nstatic inline void hostap_cmd_queue_free(local_info_t *local,\n\t\t\t\t\t struct hostap_cmd_queue *entry,\n\t\t\t\t\t int del_req)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&local->cmdlock, flags);\n\t__hostap_cmd_queue_free(local, entry, del_req);\n\tspin_unlock_irqrestore(&local->cmdlock, flags);\n}\n\n\n \nstatic void prism2_clear_cmd_queue(local_info_t *local)\n{\n\tstruct list_head *ptr, *n;\n\tunsigned long flags;\n\tstruct hostap_cmd_queue *entry;\n\n\tspin_lock_irqsave(&local->cmdlock, flags);\n\tlist_for_each_safe(ptr, n, &local->cmd_queue) {\n\t\tentry = list_entry(ptr, struct hostap_cmd_queue, list);\n\t\trefcount_inc(&entry->usecnt);\n\t\tprintk(KERN_DEBUG \"%s: removed pending cmd_queue entry \"\n\t\t       \"(type=%d, cmd=0x%04x, param0=0x%04x)\\n\",\n\t\t       local->dev->name, entry->type, entry->cmd,\n\t\t       entry->param0);\n\t\t__hostap_cmd_queue_free(local, entry, 1);\n\t}\n\tif (local->cmd_queue_len) {\n\t\t \n\t\tprintk(KERN_DEBUG \"%s: cmd_queue_len (%d) not zero after \"\n\t\t       \"flush\\n\", local->dev->name, local->cmd_queue_len);\n\t\tlocal->cmd_queue_len = 0;\n\t}\n\tspin_unlock_irqrestore(&local->cmdlock, flags);\n}\n\n\n \nstatic int hfa384x_cmd_issue(struct net_device *dev,\n\t\t\t\t    struct hostap_cmd_queue *entry)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint tries;\n\tu16 reg;\n\tunsigned long flags;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (local->func->card_present && !local->func->card_present(local))\n\t\treturn -ENODEV;\n\n\tif (entry->issued) {\n\t\tprintk(KERN_DEBUG \"%s: driver bug - re-issuing command @%p\\n\",\n\t\t       dev->name, entry);\n\t}\n\n\t \n\ttries = HFA384X_CMD_BUSY_TIMEOUT;\n\twhile (HFA384X_INW(HFA384X_CMD_OFF) & HFA384X_CMD_BUSY && tries > 0) {\n\t\ttries--;\n\t\tudelay(1);\n\t}\n#ifndef final_version\n\tif (tries != HFA384X_CMD_BUSY_TIMEOUT) {\n\t\tprism2_io_debug_error(dev, 1);\n\t\tprintk(KERN_DEBUG \"%s: hfa384x_cmd_issue: cmd reg was busy \"\n\t\t       \"for %d usec\\n\", dev->name,\n\t\t       HFA384X_CMD_BUSY_TIMEOUT - tries);\n\t}\n#endif\n\tif (tries == 0) {\n\t\treg = HFA384X_INW(HFA384X_CMD_OFF);\n\t\tprism2_io_debug_error(dev, 2);\n\t\tprintk(KERN_DEBUG \"%s: hfa384x_cmd_issue - timeout - \"\n\t\t       \"reg=0x%04x\\n\", dev->name, reg);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tspin_lock_irqsave(&local->cmdlock, flags);\n\tHFA384X_OUTW(entry->param0, HFA384X_PARAM0_OFF);\n\tHFA384X_OUTW(entry->param1, HFA384X_PARAM1_OFF);\n\tHFA384X_OUTW(entry->cmd, HFA384X_CMD_OFF);\n\tentry->issued = 1;\n\tspin_unlock_irqrestore(&local->cmdlock, flags);\n\n\treturn 0;\n}\n\n\n \nstatic int hfa384x_cmd(struct net_device *dev, u16 cmd, u16 param0,\n\t\t       u16 *param1, u16 *resp0)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint err, res, issue, issued = 0;\n\tunsigned long flags;\n\tstruct hostap_cmd_queue *entry;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (local->cmd_queue_len >= HOSTAP_CMD_QUEUE_MAX_LEN) {\n\t\tprintk(KERN_DEBUG \"%s: hfa384x_cmd: cmd_queue full\\n\",\n\t\t       dev->name);\n\t\treturn -1;\n\t}\n\n\tif (signal_pending(current))\n\t\treturn -EINTR;\n\n\tentry = kzalloc(sizeof(*entry), GFP_ATOMIC);\n\tif (entry == NULL)\n\t\treturn -ENOMEM;\n\n\trefcount_set(&entry->usecnt, 1);\n\tentry->type = CMD_SLEEP;\n\tentry->cmd = cmd;\n\tentry->param0 = param0;\n\tif (param1)\n\t\tentry->param1 = *param1;\n\tinit_waitqueue_head(&entry->compl);\n\n\t \n\tadd_wait_queue(&entry->compl, &wait);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\n\tspin_lock_irqsave(&local->cmdlock, flags);\n\tissue = list_empty(&local->cmd_queue);\n\tif (issue)\n\t\tentry->issuing = 1;\n\tlist_add_tail(&entry->list, &local->cmd_queue);\n\tlocal->cmd_queue_len++;\n\tspin_unlock_irqrestore(&local->cmdlock, flags);\n\n\terr = 0;\n\tif (!issue)\n\t\tgoto wait_completion;\n\n\tif (signal_pending(current))\n\t\terr = -EINTR;\n\n\tif (!err) {\n\t\tif (hfa384x_cmd_issue(dev, entry))\n\t\t\terr = -ETIMEDOUT;\n\t\telse\n\t\t\tissued = 1;\n\t}\n\n wait_completion:\n\tif (!err && entry->type != CMD_COMPLETED) {\n\t\t \n\t\tres = schedule_timeout(2 * HZ);\n\t} else\n\t\tres = -1;\n\n\tif (!err && signal_pending(current))\n\t\terr = -EINTR;\n\n\tif (err && issued) {\n\t\t \n\t\tudelay(300);\n\t}\n\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&entry->compl, &wait);\n\n\t \n\n\t \n\n\tspin_lock_irqsave(&local->cmdlock, flags);\n\tif (!list_empty(&entry->list)) {\n\t\tprintk(KERN_DEBUG \"%s: hfa384x_cmd: entry still in list? \"\n\t\t       \"(entry=%p, type=%d, res=%d)\\n\", dev->name, entry,\n\t\t       entry->type, res);\n\t\tlist_del_init(&entry->list);\n\t\tlocal->cmd_queue_len--;\n\t}\n\tspin_unlock_irqrestore(&local->cmdlock, flags);\n\n\tif (err) {\n\t\tprintk(KERN_DEBUG \"%s: hfa384x_cmd: interrupted; err=%d\\n\",\n\t\t       dev->name, err);\n\t\tres = err;\n\t\tgoto done;\n\t}\n\n\tif (entry->type != CMD_COMPLETED) {\n\t\tu16 reg = HFA384X_INW(HFA384X_EVSTAT_OFF);\n\t\tprintk(KERN_DEBUG \"%s: hfa384x_cmd: command was not \"\n\t\t       \"completed (res=%d, entry=%p, type=%d, cmd=0x%04x, \"\n\t\t       \"param0=0x%04x, EVSTAT=%04x INTEN=%04x)\\n\", dev->name,\n\t\t       res, entry, entry->type, entry->cmd, entry->param0, reg,\n\t\t       HFA384X_INW(HFA384X_INTEN_OFF));\n\t\tif (reg & HFA384X_EV_CMD) {\n\t\t\t \n\t\t\tprintk(KERN_WARNING \"%s: interrupt delivery does not \"\n\t\t\t       \"seem to work\\n\", dev->name);\n\t\t}\n\t\tprism2_io_debug_error(dev, 3);\n\t\tres = -ETIMEDOUT;\n\t\tgoto done;\n\t}\n\n\tif (resp0 != NULL)\n\t\t*resp0 = entry->resp0;\n#ifndef final_version\n\tif (entry->res) {\n\t\tprintk(KERN_DEBUG \"%s: CMD=0x%04x => res=0x%02x, \"\n\t\t       \"resp0=0x%04x\\n\",\n\t\t       dev->name, cmd, entry->res, entry->resp0);\n\t}\n#endif  \n\n\tres = entry->res;\n done:\n\thostap_cmd_queue_free(local, entry, 1);\n\treturn res;\n}\n\n\n \nstatic int hfa384x_cmd_callback(struct net_device *dev, u16 cmd, u16 param0,\n\t\t\t\tvoid (*callback)(struct net_device *dev,\n\t\t\t\t\t\t long context, u16 resp0,\n\t\t\t\t\t\t u16 status),\n\t\t\t\tlong context)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint issue, ret;\n\tunsigned long flags;\n\tstruct hostap_cmd_queue *entry;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (local->cmd_queue_len >= HOSTAP_CMD_QUEUE_MAX_LEN + 2) {\n\t\tprintk(KERN_DEBUG \"%s: hfa384x_cmd: cmd_queue full\\n\",\n\t\t       dev->name);\n\t\treturn -1;\n\t}\n\n\tentry = kzalloc(sizeof(*entry), GFP_ATOMIC);\n\tif (entry == NULL)\n\t\treturn -ENOMEM;\n\n\trefcount_set(&entry->usecnt, 1);\n\tentry->type = CMD_CALLBACK;\n\tentry->cmd = cmd;\n\tentry->param0 = param0;\n\tentry->callback = callback;\n\tentry->context = context;\n\n\tspin_lock_irqsave(&local->cmdlock, flags);\n\tissue = list_empty(&local->cmd_queue);\n\tif (issue)\n\t\tentry->issuing = 1;\n\tlist_add_tail(&entry->list, &local->cmd_queue);\n\tlocal->cmd_queue_len++;\n\tspin_unlock_irqrestore(&local->cmdlock, flags);\n\n\tif (issue && hfa384x_cmd_issue(dev, entry))\n\t\tret = -ETIMEDOUT;\n\telse\n\t\tret = 0;\n\n\thostap_cmd_queue_free(local, entry, ret);\n\n\treturn ret;\n}\n\n\n \nstatic int __hfa384x_cmd_no_wait(struct net_device *dev, u16 cmd, u16 param0,\n\t\t\t\t int io_debug_num)\n{\n\tint tries;\n\tu16 reg;\n\n\t \n\ttries = HFA384X_CMD_BUSY_TIMEOUT;\n\twhile (HFA384X_INW(HFA384X_CMD_OFF) & HFA384X_CMD_BUSY && tries > 0) {\n\t\ttries--;\n\t\tudelay(1);\n\t}\n\tif (tries == 0) {\n\t\treg = HFA384X_INW(HFA384X_CMD_OFF);\n\t\tprism2_io_debug_error(dev, io_debug_num);\n\t\tprintk(KERN_DEBUG \"%s: __hfa384x_cmd_no_wait(%d) - timeout - \"\n\t\t       \"reg=0x%04x\\n\", dev->name, io_debug_num, reg);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tHFA384X_OUTW(param0, HFA384X_PARAM0_OFF);\n\tHFA384X_OUTW(cmd, HFA384X_CMD_OFF);\n\n\treturn 0;\n}\n\n\n \nstatic int hfa384x_cmd_wait(struct net_device *dev, u16 cmd, u16 param0)\n{\n\tint res, tries;\n\tu16 reg;\n\n\tres = __hfa384x_cmd_no_wait(dev, cmd, param0, 4);\n\tif (res)\n\t\treturn res;\n\n         \n\tif ((cmd & HFA384X_CMDCODE_MASK) == HFA384X_CMDCODE_DOWNLOAD)\n\t\ttries = HFA384X_DL_COMPL_TIMEOUT;\n\telse\n\t\ttries = HFA384X_CMD_COMPL_TIMEOUT;\n\n        while (!(HFA384X_INW(HFA384X_EVSTAT_OFF) & HFA384X_EV_CMD) &&\n               tries > 0) {\n                tries--;\n                udelay(10);\n        }\n        if (tries == 0) {\n                reg = HFA384X_INW(HFA384X_EVSTAT_OFF);\n\t\tprism2_io_debug_error(dev, 5);\n                printk(KERN_DEBUG \"%s: hfa384x_cmd_wait - timeout2 - \"\n\t\t       \"reg=0x%04x\\n\", dev->name, reg);\n                return -ETIMEDOUT;\n        }\n\n        res = (HFA384X_INW(HFA384X_STATUS_OFF) &\n               (BIT(14) | BIT(13) | BIT(12) | BIT(11) | BIT(10) | BIT(9) |\n                BIT(8))) >> 8;\n#ifndef final_version\n\tif (res) {\n\t\tprintk(KERN_DEBUG \"%s: CMD=0x%04x => res=0x%02x\\n\",\n\t\t       dev->name, cmd, res);\n\t}\n#endif\n\n\tHFA384X_OUTW(HFA384X_EV_CMD, HFA384X_EVACK_OFF);\n\n\treturn res;\n}\n\n\n \nstatic inline int hfa384x_cmd_no_wait(struct net_device *dev, u16 cmd,\n\t\t\t\t      u16 param0)\n{\n\treturn __hfa384x_cmd_no_wait(dev, cmd, param0, 6);\n}\n\n\n \nstatic void prism2_cmd_ev(struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tstruct hostap_cmd_queue *entry = NULL;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tspin_lock(&local->cmdlock);\n\tif (!list_empty(&local->cmd_queue)) {\n\t\tentry = list_entry(local->cmd_queue.next,\n\t\t\t\t   struct hostap_cmd_queue, list);\n\t\trefcount_inc(&entry->usecnt);\n\t\tlist_del_init(&entry->list);\n\t\tlocal->cmd_queue_len--;\n\n\t\tif (!entry->issued) {\n\t\t\tprintk(KERN_DEBUG \"%s: Command completion event, but \"\n\t\t\t       \"cmd not issued\\n\", dev->name);\n\t\t\t__hostap_cmd_queue_free(local, entry, 1);\n\t\t\tentry = NULL;\n\t\t}\n\t}\n\tspin_unlock(&local->cmdlock);\n\n\tif (!entry) {\n\t\tHFA384X_OUTW(HFA384X_EV_CMD, HFA384X_EVACK_OFF);\n\t\tprintk(KERN_DEBUG \"%s: Command completion event, but no \"\n\t\t       \"pending commands\\n\", dev->name);\n\t\treturn;\n\t}\n\n\tentry->resp0 = HFA384X_INW(HFA384X_RESP0_OFF);\n\tentry->res = (HFA384X_INW(HFA384X_STATUS_OFF) &\n\t\t      (BIT(14) | BIT(13) | BIT(12) | BIT(11) | BIT(10) |\n\t\t       BIT(9) | BIT(8))) >> 8;\n\tHFA384X_OUTW(HFA384X_EV_CMD, HFA384X_EVACK_OFF);\n\n\t \n\tif (entry->type == CMD_SLEEP) {\n\t\tentry->type = CMD_COMPLETED;\n\t\twake_up_interruptible(&entry->compl);\n\t} else if (entry->type == CMD_CALLBACK) {\n\t\tif (entry->callback)\n\t\t\tentry->callback(dev, entry->context, entry->resp0,\n\t\t\t\t\tentry->res);\n\t} else {\n\t\tprintk(KERN_DEBUG \"%s: Invalid command completion type %d\\n\",\n\t\t       dev->name, entry->type);\n\t}\n\thostap_cmd_queue_free(local, entry, 1);\n\n\t \n\tentry = NULL;\n\tspin_lock(&local->cmdlock);\n\tif (!list_empty(&local->cmd_queue)) {\n\t\tentry = list_entry(local->cmd_queue.next,\n\t\t\t\t   struct hostap_cmd_queue, list);\n\t\tif (entry->issuing) {\n\t\t\t \n\t\t\tentry = NULL;\n\t\t}\n\t\tif (entry)\n\t\t\trefcount_inc(&entry->usecnt);\n\t}\n\tspin_unlock(&local->cmdlock);\n\n\tif (entry) {\n\t\t \n\t\tint res = hfa384x_cmd_issue(dev, entry);\n\t\tspin_lock(&local->cmdlock);\n\t\t__hostap_cmd_queue_free(local, entry, res);\n\t\tspin_unlock(&local->cmdlock);\n\t}\n}\n\n\nstatic int hfa384x_wait_offset(struct net_device *dev, u16 o_off)\n{\n\tint tries = HFA384X_BAP_BUSY_TIMEOUT;\n\tint res = HFA384X_INW(o_off) & HFA384X_OFFSET_BUSY;\n\n\twhile (res && tries > 0) {\n\t\ttries--;\n\t\tudelay(1);\n\t\tres = HFA384X_INW(o_off) & HFA384X_OFFSET_BUSY;\n\t}\n\treturn res;\n}\n\n\n \nstatic int hfa384x_setup_bap(struct net_device *dev, u16 bap, u16 id,\n\t\t\t     int offset)\n{\n\tu16 o_off, s_off;\n\tint ret = 0;\n\n\tif (offset % 2 || bap > 1)\n\t\treturn -EINVAL;\n\n\tif (bap == BAP1) {\n\t\to_off = HFA384X_OFFSET1_OFF;\n\t\ts_off = HFA384X_SELECT1_OFF;\n\t} else {\n\t\to_off = HFA384X_OFFSET0_OFF;\n\t\ts_off = HFA384X_SELECT0_OFF;\n\t}\n\n\tif (hfa384x_wait_offset(dev, o_off)) {\n\t\tprism2_io_debug_error(dev, 7);\n\t\tprintk(KERN_DEBUG \"%s: hfa384x_setup_bap - timeout before\\n\",\n\t\t       dev->name);\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\tHFA384X_OUTW(id, s_off);\n\tHFA384X_OUTW(offset, o_off);\n\n\tif (hfa384x_wait_offset(dev, o_off)) {\n\t\tprism2_io_debug_error(dev, 8);\n\t\tprintk(KERN_DEBUG \"%s: hfa384x_setup_bap - timeout after\\n\",\n\t\t       dev->name);\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n#ifndef final_version\n\tif (HFA384X_INW(o_off) & HFA384X_OFFSET_ERR) {\n\t\tprism2_io_debug_error(dev, 9);\n\t\tprintk(KERN_DEBUG \"%s: hfa384x_setup_bap - offset error \"\n\t\t       \"(%d,0x04%x,%d); reg=0x%04x\\n\",\n\t\t       dev->name, bap, id, offset, HFA384X_INW(o_off));\n\t\tret = -EINVAL;\n\t}\n#endif\n\n out:\n\treturn ret;\n}\n\n\nstatic int hfa384x_get_rid(struct net_device *dev, u16 rid, void *buf, int len,\n\t\t\t   int exact_len)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint res, rlen = 0;\n\tstruct hfa384x_rid_hdr rec;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (local->no_pri) {\n\t\tprintk(KERN_DEBUG \"%s: cannot get RID %04x (len=%d) - no PRI \"\n\t\t       \"f/w\\n\", dev->name, rid, len);\n\t\treturn -ENOTTY;  \n\t}\n\n\tif ((local->func->card_present && !local->func->card_present(local)) ||\n\t    local->hw_downloading)\n\t\treturn -ENODEV;\n\n\tres = mutex_lock_interruptible(&local->rid_bap_mtx);\n\tif (res)\n\t\treturn res;\n\n\tres = hfa384x_cmd(dev, HFA384X_CMDCODE_ACCESS, rid, NULL, NULL);\n\tif (res) {\n\t\tprintk(KERN_DEBUG \"%s: hfa384x_get_rid: CMDCODE_ACCESS failed \"\n\t\t       \"(res=%d, rid=%04x, len=%d)\\n\",\n\t\t       dev->name, res, rid, len);\n\t\tmutex_unlock(&local->rid_bap_mtx);\n\t\treturn res;\n\t}\n\n\tspin_lock_bh(&local->baplock);\n\n\tres = hfa384x_setup_bap(dev, BAP0, rid, 0);\n\tif (res)\n\t\tgoto unlock;\n\n\tres = hfa384x_from_bap(dev, BAP0, &rec, sizeof(rec));\n\tif (res)\n\t\tgoto unlock;\n\n\tif (le16_to_cpu(rec.len) == 0) {\n\t\t \n\t\tres = -ENODATA;\n\t\tgoto unlock;\n\t}\n\n\trlen = (le16_to_cpu(rec.len) - 1) * 2;\n\tif (exact_len && rlen != len) {\n\t\tprintk(KERN_DEBUG \"%s: hfa384x_get_rid - RID len mismatch: \"\n\t\t       \"rid=0x%04x, len=%d (expected %d)\\n\",\n\t\t       dev->name, rid, rlen, len);\n\t\tres = -ENODATA;\n\t}\n\n\tres = hfa384x_from_bap(dev, BAP0, buf, len);\n\nunlock:\n\tspin_unlock_bh(&local->baplock);\n\tmutex_unlock(&local->rid_bap_mtx);\n\n\tif (res) {\n\t\tif (res != -ENODATA)\n\t\t\tprintk(KERN_DEBUG \"%s: hfa384x_get_rid (rid=%04x, \"\n\t\t\t       \"len=%d) - failed - res=%d\\n\", dev->name, rid,\n\t\t\t       len, res);\n\t\tif (res == -ETIMEDOUT)\n\t\t\tprism2_hw_reset(dev);\n\t\treturn res;\n\t}\n\n\treturn rlen;\n}\n\n\nstatic int hfa384x_set_rid(struct net_device *dev, u16 rid, void *buf, int len)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tstruct hfa384x_rid_hdr rec;\n\tint res;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (local->no_pri) {\n\t\tprintk(KERN_DEBUG \"%s: cannot set RID %04x (len=%d) - no PRI \"\n\t\t       \"f/w\\n\", dev->name, rid, len);\n\t\treturn -ENOTTY;  \n\t}\n\n\tif ((local->func->card_present && !local->func->card_present(local)) ||\n\t    local->hw_downloading)\n\t\treturn -ENODEV;\n\n\trec.rid = cpu_to_le16(rid);\n\t \n\trec.len = cpu_to_le16(len / 2 + len % 2 + 1);\n\n\tres = mutex_lock_interruptible(&local->rid_bap_mtx);\n\tif (res)\n\t\treturn res;\n\n\tspin_lock_bh(&local->baplock);\n\tres = hfa384x_setup_bap(dev, BAP0, rid, 0);\n\tif (!res)\n\t\tres = hfa384x_to_bap(dev, BAP0, &rec, sizeof(rec));\n\tif (!res)\n\t\tres = hfa384x_to_bap(dev, BAP0, buf, len);\n\tspin_unlock_bh(&local->baplock);\n\n\tif (res) {\n\t\tprintk(KERN_DEBUG \"%s: hfa384x_set_rid (rid=%04x, len=%d) - \"\n\t\t       \"failed - res=%d\\n\", dev->name, rid, len, res);\n\t\tmutex_unlock(&local->rid_bap_mtx);\n\t\treturn res;\n\t}\n\n\tres = hfa384x_cmd(dev, HFA384X_CMDCODE_ACCESS_WRITE, rid, NULL, NULL);\n\tmutex_unlock(&local->rid_bap_mtx);\n\n\tif (res) {\n\t\tprintk(KERN_DEBUG \"%s: hfa384x_set_rid: CMDCODE_ACCESS_WRITE \"\n\t\t       \"failed (res=%d, rid=%04x, len=%d)\\n\",\n\t\t       dev->name, res, rid, len);\n\n\t\tif (res == -ETIMEDOUT)\n\t\t\tprism2_hw_reset(dev);\n\t}\n\n\treturn res;\n}\n\n\nstatic void hfa384x_disable_interrupts(struct net_device *dev)\n{\n\t \n\tHFA384X_OUTW(0, HFA384X_INTEN_OFF);\n\tHFA384X_OUTW(0xffff, HFA384X_EVACK_OFF);\n}\n\n\nstatic void hfa384x_enable_interrupts(struct net_device *dev)\n{\n\t \n\tHFA384X_OUTW(0xffff, HFA384X_EVACK_OFF);\n\tHFA384X_OUTW(HFA384X_EVENT_MASK, HFA384X_INTEN_OFF);\n}\n\n\nstatic void hfa384x_events_no_bap0(struct net_device *dev)\n{\n\tHFA384X_OUTW(HFA384X_EVENT_MASK & ~HFA384X_BAP0_EVENTS,\n\t\t     HFA384X_INTEN_OFF);\n}\n\n\nstatic void hfa384x_events_all(struct net_device *dev)\n{\n\tHFA384X_OUTW(HFA384X_EVENT_MASK, HFA384X_INTEN_OFF);\n}\n\n\nstatic void hfa384x_events_only_cmd(struct net_device *dev)\n{\n\tHFA384X_OUTW(HFA384X_EV_CMD, HFA384X_INTEN_OFF);\n}\n\n\nstatic u16 hfa384x_allocate_fid(struct net_device *dev, int len)\n{\n\tu16 fid;\n\tunsigned long delay;\n\n\t \n\tif (hfa384x_cmd_wait(dev, HFA384X_CMDCODE_ALLOC, len)) {\n\t\tprintk(KERN_DEBUG \"%s: cannot allocate fid, len=%d\\n\",\n\t\t       dev->name, len);\n\t\treturn 0xffff;\n\t}\n\n\tdelay = jiffies + HFA384X_ALLOC_COMPL_TIMEOUT;\n\twhile (!(HFA384X_INW(HFA384X_EVSTAT_OFF) & HFA384X_EV_ALLOC) &&\n\t       time_before(jiffies, delay))\n\t\tyield();\n\tif (!(HFA384X_INW(HFA384X_EVSTAT_OFF) & HFA384X_EV_ALLOC)) {\n\t\tprintk(\"%s: fid allocate, len=%d - timeout\\n\", dev->name, len);\n\t\treturn 0xffff;\n\t}\n\n\tfid = HFA384X_INW(HFA384X_ALLOCFID_OFF);\n\tHFA384X_OUTW(HFA384X_EV_ALLOC, HFA384X_EVACK_OFF);\n\n\treturn fid;\n}\n\n\nstatic int prism2_reset_port(struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint res;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (!local->dev_enabled)\n\t\treturn 0;\n\n\tres = hfa384x_cmd(dev, HFA384X_CMDCODE_DISABLE, 0,\n\t\t\t  NULL, NULL);\n\tif (res)\n\t\tprintk(KERN_DEBUG \"%s: reset port failed to disable port\\n\",\n\t\t       dev->name);\n\telse {\n\t\tres = hfa384x_cmd(dev, HFA384X_CMDCODE_ENABLE, 0,\n\t\t\t\t  NULL, NULL);\n\t\tif (res)\n\t\t\tprintk(KERN_DEBUG \"%s: reset port failed to enable \"\n\t\t\t       \"port\\n\", dev->name);\n\t}\n\n\t \n\tif (local->fragm_threshold != 2346 &&\n\t    hostap_set_word(dev, HFA384X_RID_FRAGMENTATIONTHRESHOLD,\n\t\t\t    local->fragm_threshold)) {\n\t\tprintk(KERN_DEBUG \"%s: failed to restore fragmentation \"\n\t\t       \"threshold (%d) after Port0 enable\\n\",\n\t\t       dev->name, local->fragm_threshold);\n\t}\n\n\t \n\t(void) hostap_set_antsel(local);\n\n\treturn res;\n}\n\n\nstatic int prism2_get_version_info(struct net_device *dev, u16 rid,\n\t\t\t\t   const char *txt)\n{\n\tstruct hfa384x_comp_ident comp;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (local->no_pri) {\n\t\t \n\t\treturn -1;\n\t}\n\tif (hfa384x_get_rid(dev, rid, &comp, sizeof(comp), 1) < 0) {\n\t\tprintk(KERN_DEBUG \"Could not get RID for component %s\\n\", txt);\n\t\treturn -1;\n\t}\n\n\tprintk(KERN_INFO \"%s: %s: id=0x%02x v%d.%d.%d\\n\", dev->name, txt,\n\t       __le16_to_cpu(comp.id), __le16_to_cpu(comp.major),\n\t       __le16_to_cpu(comp.minor), __le16_to_cpu(comp.variant));\n\treturn 0;\n}\n\n\nstatic int prism2_setup_rids(struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\t__le16 tmp;\n\tint ret = 0;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\thostap_set_word(dev, HFA384X_RID_TICKTIME, 2000);\n\n\tif (!local->fw_ap) {\n\t\tu16 tmp1 = hostap_get_porttype(local);\n\t\tret = hostap_set_word(dev, HFA384X_RID_CNFPORTTYPE, tmp1);\n\t\tif (ret) {\n\t\t\tprintk(\"%s: Port type setting to %d failed\\n\",\n\t\t\t       dev->name, tmp1);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t \n\tif (local->iw_mode != IW_MODE_MASTER || local->essid[0] != '\\0') {\n\t\tret = hostap_set_string(dev, HFA384X_RID_CNFOWNSSID,\n\t\t\t\t\tlocal->essid);\n\t\tif (ret) {\n\t\t\tprintk(\"%s: AP own SSID setting failed\\n\", dev->name);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tret = hostap_set_word(dev, HFA384X_RID_CNFMAXDATALEN,\n\t\t\t      PRISM2_DATA_MAXLEN);\n\tif (ret) {\n\t\tprintk(\"%s: MAC data length setting to %d failed\\n\",\n\t\t       dev->name, PRISM2_DATA_MAXLEN);\n\t\tgoto fail;\n\t}\n\n\tif (hfa384x_get_rid(dev, HFA384X_RID_CHANNELLIST, &tmp, 2, 1) < 0) {\n\t\tprintk(\"%s: Channel list read failed\\n\", dev->name);\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\tlocal->channel_mask = le16_to_cpu(tmp);\n\n\tif (local->channel < 1 || local->channel > 14 ||\n\t    !(local->channel_mask & (1 << (local->channel - 1)))) {\n\t\tprintk(KERN_WARNING \"%s: Channel setting out of range \"\n\t\t       \"(%d)!\\n\", dev->name, local->channel);\n\t\tret = -EBUSY;\n\t\tgoto fail;\n\t}\n\n\tret = hostap_set_word(dev, HFA384X_RID_CNFOWNCHANNEL, local->channel);\n\tif (ret) {\n\t\tprintk(\"%s: Channel setting to %d failed\\n\",\n\t\t       dev->name, local->channel);\n\t\tgoto fail;\n\t}\n\n\tret = hostap_set_word(dev, HFA384X_RID_CNFBEACONINT,\n\t\t\t      local->beacon_int);\n\tif (ret) {\n\t\tprintk(\"%s: Beacon interval setting to %d failed\\n\",\n\t\t       dev->name, local->beacon_int);\n\t\t \n\t\tif (ret == -ETIMEDOUT)\n\t\t\tgoto fail;\n\t}\n\n\tret = hostap_set_word(dev, HFA384X_RID_CNFOWNDTIMPERIOD,\n\t\t\t      local->dtim_period);\n\tif (ret) {\n\t\tprintk(\"%s: DTIM period setting to %d failed\\n\",\n\t\t       dev->name, local->dtim_period);\n\t\t \n\t\tif (ret == -ETIMEDOUT)\n\t\t\tgoto fail;\n\t}\n\n\tret = hostap_set_word(dev, HFA384X_RID_PROMISCUOUSMODE,\n\t\t\t      local->is_promisc);\n\tif (ret)\n\t\tprintk(KERN_INFO \"%s: Setting promiscuous mode (%d) failed\\n\",\n\t\t       dev->name, local->is_promisc);\n\n\tif (!local->fw_ap) {\n\t\tret = hostap_set_string(dev, HFA384X_RID_CNFDESIREDSSID,\n\t\t\t\t\tlocal->essid);\n\t\tif (ret) {\n\t\t\tprintk(\"%s: Desired SSID setting failed\\n\", dev->name);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t \n\tif (local->tx_rate_control == 0) {\n\t\tlocal->tx_rate_control =\n\t\t\tHFA384X_RATES_1MBPS |\n\t\t\tHFA384X_RATES_2MBPS |\n\t\t\tHFA384X_RATES_5MBPS |\n\t\t\tHFA384X_RATES_11MBPS;\n\t}\n\tif (local->basic_rates == 0)\n\t\tlocal->basic_rates = HFA384X_RATES_1MBPS | HFA384X_RATES_2MBPS;\n\n\tif (!local->fw_ap) {\n\t\tret = hostap_set_word(dev, HFA384X_RID_TXRATECONTROL,\n\t\t\t\t      local->tx_rate_control);\n\t\tif (ret) {\n\t\t\tprintk(\"%s: TXRateControl setting to %d failed\\n\",\n\t\t\t       dev->name, local->tx_rate_control);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tret = hostap_set_word(dev, HFA384X_RID_CNFSUPPORTEDRATES,\n\t\t\t\t      local->tx_rate_control);\n\t\tif (ret) {\n\t\t\tprintk(\"%s: cnfSupportedRates setting to %d failed\\n\",\n\t\t\t       dev->name, local->tx_rate_control);\n\t\t}\n\n\t\tret = hostap_set_word(dev, HFA384X_RID_CNFBASICRATES,\n\t\t\t\t      local->basic_rates);\n\t\tif (ret) {\n\t\t\tprintk(\"%s: cnfBasicRates setting to %d failed\\n\",\n\t\t\t       dev->name, local->basic_rates);\n\t\t}\n\n\t\tret = hostap_set_word(dev, HFA384X_RID_CREATEIBSS, 1);\n\t\tif (ret) {\n\t\t\tprintk(\"%s: Create IBSS setting to 1 failed\\n\",\n\t\t\t       dev->name);\n\t\t}\n\t}\n\n\tif (local->name_set)\n\t\t(void) hostap_set_string(dev, HFA384X_RID_CNFOWNNAME,\n\t\t\t\t\t local->name);\n\n\tif (hostap_set_encryption(local)) {\n\t\tprintk(KERN_INFO \"%s: could not configure encryption\\n\",\n\t\t       dev->name);\n\t}\n\n\t(void) hostap_set_antsel(local);\n\n\tif (hostap_set_roaming(local)) {\n\t\tprintk(KERN_INFO \"%s: could not set host roaming\\n\",\n\t\t       dev->name);\n\t}\n\n\tif (local->sta_fw_ver >= PRISM2_FW_VER(1,6,3) &&\n\t    hostap_set_word(dev, HFA384X_RID_CNFENHSECURITY, local->enh_sec))\n\t\tprintk(KERN_INFO \"%s: cnfEnhSecurity setting to 0x%x failed\\n\",\n\t\t       dev->name, local->enh_sec);\n\n\t \n\tif (local->sta_fw_ver >= PRISM2_FW_VER(0,8,2)) {\n\t\tif (hostap_set_word(dev, HFA384X_RID_CNFTHIRTY2TALLY, 1)) {\n\t\t\tprintk(KERN_INFO \"%s: cnfThirty2Tally setting \"\n\t\t\t       \"failed\\n\", dev->name);\n\t\t\tlocal->tallies32 = 0;\n\t\t} else\n\t\t\tlocal->tallies32 = 1;\n\t} else\n\t\tlocal->tallies32 = 0;\n\n\thostap_set_auth_algs(local);\n\n\tif (hostap_set_word(dev, HFA384X_RID_FRAGMENTATIONTHRESHOLD,\n\t\t\t    local->fragm_threshold)) {\n\t\tprintk(KERN_INFO \"%s: setting FragmentationThreshold to %d \"\n\t\t       \"failed\\n\", dev->name, local->fragm_threshold);\n\t}\n\n\tif (hostap_set_word(dev, HFA384X_RID_RTSTHRESHOLD,\n\t\t\t    local->rts_threshold)) {\n\t\tprintk(KERN_INFO \"%s: setting RTSThreshold to %d failed\\n\",\n\t\t       dev->name, local->rts_threshold);\n\t}\n\n\tif (local->manual_retry_count >= 0 &&\n\t    hostap_set_word(dev, HFA384X_RID_CNFALTRETRYCOUNT,\n\t\t\t    local->manual_retry_count)) {\n\t\tprintk(KERN_INFO \"%s: setting cnfAltRetryCount to %d failed\\n\",\n\t\t       dev->name, local->manual_retry_count);\n\t}\n\n\tif (local->sta_fw_ver >= PRISM2_FW_VER(1,3,1) &&\n\t    hfa384x_get_rid(dev, HFA384X_RID_CNFDBMADJUST, &tmp, 2, 1) == 2) {\n\t\tlocal->rssi_to_dBm = le16_to_cpu(tmp);\n\t}\n\n\tif (local->sta_fw_ver >= PRISM2_FW_VER(1,7,0) && local->wpa &&\n\t    hostap_set_word(dev, HFA384X_RID_SSNHANDLINGMODE, 1)) {\n\t\tprintk(KERN_INFO \"%s: setting ssnHandlingMode to 1 failed\\n\",\n\t\t       dev->name);\n\t}\n\n\tif (local->sta_fw_ver >= PRISM2_FW_VER(1,7,0) && local->generic_elem &&\n\t    hfa384x_set_rid(dev, HFA384X_RID_GENERICELEMENT,\n\t\t\t    local->generic_elem, local->generic_elem_len)) {\n\t\tprintk(KERN_INFO \"%s: setting genericElement failed\\n\",\n\t\t       dev->name);\n\t}\n\n fail:\n\treturn ret;\n}\n\n\nstatic int prism2_hw_init(struct net_device *dev, int initial)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint ret, first = 1;\n\tunsigned long start, delay;\n\n\tPDEBUG(DEBUG_FLOW, \"prism2_hw_init()\\n\");\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tclear_bit(HOSTAP_BITS_TRANSMIT, &local->bits);\n\n init:\n\t \n\tret = hfa384x_cmd_no_wait(dev, HFA384X_CMDCODE_INIT, 0);\n\tif (ret) {\n\t\tprintk(KERN_INFO \"%s: first command failed - assuming card \"\n\t\t       \"does not have primary firmware\\n\", dev_info);\n\t}\n\n\tif (first && (HFA384X_INW(HFA384X_EVSTAT_OFF) & HFA384X_EV_CMD)) {\n\t\t \n\t\tHFA384X_OUTW(HFA384X_EV_CMD, HFA384X_EVACK_OFF);\n\t\tprintk(KERN_DEBUG \"%s: init command completed too quickly - \"\n\t\t       \"retrying\\n\", dev->name);\n\t\tfirst = 0;\n\t\tgoto init;\n\t}\n\n\tstart = jiffies;\n\tdelay = jiffies + HFA384X_INIT_TIMEOUT;\n\twhile (!(HFA384X_INW(HFA384X_EVSTAT_OFF) & HFA384X_EV_CMD) &&\n\t       time_before(jiffies, delay))\n\t\tyield();\n\tif (!(HFA384X_INW(HFA384X_EVSTAT_OFF) & HFA384X_EV_CMD)) {\n\t\tprintk(KERN_DEBUG \"%s: assuming no Primary image in \"\n\t\t       \"flash - card initialization not completed\\n\",\n\t\t       dev_info);\n\t\tlocal->no_pri = 1;\n#ifdef PRISM2_DOWNLOAD_SUPPORT\n\t\t\tif (local->sram_type == -1)\n\t\t\t\tlocal->sram_type = prism2_get_ram_size(local);\n#endif  \n\t\treturn 1;\n\t}\n\tlocal->no_pri = 0;\n\tprintk(KERN_DEBUG \"prism2_hw_init: initialized in %lu ms\\n\",\n\t       (jiffies - start) * 1000 / HZ);\n\tHFA384X_OUTW(HFA384X_EV_CMD, HFA384X_EVACK_OFF);\n\treturn 0;\n}\n\n\nstatic int prism2_hw_init2(struct net_device *dev, int initial)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint i;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n#ifdef PRISM2_DOWNLOAD_SUPPORT\n\tkfree(local->pda);\n\tif (local->no_pri)\n\t\tlocal->pda = NULL;\n\telse\n\t\tlocal->pda = prism2_read_pda(dev);\n#endif  \n\n\thfa384x_disable_interrupts(dev);\n\n#ifndef final_version\n\tHFA384X_OUTW(HFA384X_MAGIC, HFA384X_SWSUPPORT0_OFF);\n\tif (HFA384X_INW(HFA384X_SWSUPPORT0_OFF) != HFA384X_MAGIC) {\n\t\tprintk(\"SWSUPPORT0 write/read failed: %04X != %04X\\n\",\n\t\t       HFA384X_INW(HFA384X_SWSUPPORT0_OFF), HFA384X_MAGIC);\n\t\tgoto failed;\n\t}\n#endif\n\n\tif (initial || local->pri_only) {\n\t\thfa384x_events_only_cmd(dev);\n\t\t \n\t\tif (prism2_get_version_info(dev, HFA384X_RID_NICID, \"NIC\") ||\n\t\t    prism2_get_version_info(dev, HFA384X_RID_PRIID, \"PRI\")) {\n\t\t\thfa384x_disable_interrupts(dev);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (prism2_get_version_info(dev, HFA384X_RID_STAID, \"STA\")) {\n\t\t\tprintk(KERN_DEBUG \"%s: Failed to read STA f/w version \"\n\t\t\t       \"- only Primary f/w present\\n\", dev->name);\n\t\t\tlocal->pri_only = 1;\n\t\t\treturn 0;\n\t\t}\n\t\tlocal->pri_only = 0;\n\t\thfa384x_disable_interrupts(dev);\n\t}\n\n\t \n\n\t \n\tlocal->txfid_len = PRISM2_TXFID_LEN;\n\tfor (i = 0; i < PRISM2_TXFID_COUNT; i++) {\n\t\tlocal->txfid[i] = hfa384x_allocate_fid(dev, local->txfid_len);\n\t\tif (local->txfid[i] == 0xffff && local->txfid_len > 1600) {\n\t\t\tlocal->txfid[i] = hfa384x_allocate_fid(dev, 1600);\n\t\t\tif (local->txfid[i] != 0xffff) {\n\t\t\t\tprintk(KERN_DEBUG \"%s: Using shorter TX FID \"\n\t\t\t\t       \"(1600 bytes)\\n\", dev->name);\n\t\t\t\tlocal->txfid_len = 1600;\n\t\t\t}\n\t\t}\n\t\tif (local->txfid[i] == 0xffff)\n\t\t\tgoto failed;\n\t\tlocal->intransmitfid[i] = PRISM2_TXFID_EMPTY;\n\t}\n\n\thfa384x_events_only_cmd(dev);\n\n\tif (initial) {\n\t\tu8 addr[ETH_ALEN] = {};\n\t\tstruct list_head *ptr;\n\n\t\tprism2_check_sta_fw_version(local);\n\n\t\tif (hfa384x_get_rid(dev, HFA384X_RID_CNFOWNMACADDR,\n\t\t\t\t    addr, ETH_ALEN, 1) < 0) {\n\t\t\tprintk(\"%s: could not get own MAC address\\n\",\n\t\t\t       dev->name);\n\t\t}\n\t\teth_hw_addr_set(dev, addr);\n\t\tlist_for_each(ptr, &local->hostap_interfaces) {\n\t\t\tiface = list_entry(ptr, struct hostap_interface, list);\n\t\t\teth_hw_addr_inherit(iface->dev, dev);\n\t\t}\n\t} else if (local->fw_ap)\n\t\tprism2_check_sta_fw_version(local);\n\n\tprism2_setup_rids(dev);\n\n\t \n\treturn 0;\n\n failed:\n\tif (!local->no_pri)\n\t\tprintk(KERN_WARNING \"%s: Initialization failed\\n\", dev_info);\n\treturn 1;\n}\n\n\nstatic int prism2_hw_enable(struct net_device *dev, int initial)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint was_resetting;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\twas_resetting = local->hw_resetting;\n\n\tif (hfa384x_cmd(dev, HFA384X_CMDCODE_ENABLE, 0, NULL, NULL)) {\n\t\tprintk(\"%s: MAC port 0 enabling failed\\n\", dev->name);\n\t\treturn 1;\n\t}\n\n\tlocal->hw_ready = 1;\n\tlocal->hw_reset_tries = 0;\n\tlocal->hw_resetting = 0;\n\thfa384x_enable_interrupts(dev);\n\n\t \n\tif (initial && prism2_reset_port(dev)) {\n\t\tprintk(\"%s: MAC port 0 resetting failed\\n\", dev->name);\n\t\treturn 1;\n\t}\n\n\tif (was_resetting && netif_queue_stopped(dev)) {\n\t\t \n\t\tnetif_wake_queue(dev);\n\t}\n\n\treturn 0;\n}\n\n\nstatic int prism2_hw_config(struct net_device *dev, int initial)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (local->hw_downloading)\n\t\treturn 1;\n\n\tif (prism2_hw_init(dev, initial)) {\n\t\treturn local->no_pri ? 0 : 1;\n\t}\n\n\tif (prism2_hw_init2(dev, initial))\n\t\treturn 1;\n\n\t \n\tif (!local->pri_only &&\n\t    (initial == 0 || (initial == 2 && local->num_dev_open > 0))) {\n\t\tif (!local->dev_enabled)\n\t\t\tprism2_callback(local, PRISM2_CALLBACK_ENABLE);\n\t\tlocal->dev_enabled = 1;\n\t\treturn prism2_hw_enable(dev, initial);\n\t}\n\n\treturn 0;\n}\n\n\nstatic void prism2_hw_shutdown(struct net_device *dev, int no_disable)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\t \n\thfa384x_events_only_cmd(dev);\n\n\tlocal->hw_ready = 0;\n\tif (local->dev_enabled)\n\t\tprism2_callback(local, PRISM2_CALLBACK_DISABLE);\n\tlocal->dev_enabled = 0;\n\n\tif (local->func->card_present && !local->func->card_present(local)) {\n\t\tprintk(KERN_DEBUG \"%s: card already removed or not configured \"\n\t\t       \"during shutdown\\n\", dev->name);\n\t\treturn;\n\t}\n\n\tif ((no_disable & HOSTAP_HW_NO_DISABLE) == 0 &&\n\t    hfa384x_cmd(dev, HFA384X_CMDCODE_DISABLE, 0, NULL, NULL))\n\t\tprintk(KERN_WARNING \"%s: Shutdown failed\\n\", dev_info);\n\n\thfa384x_disable_interrupts(dev);\n\n\tif (no_disable & HOSTAP_HW_ENABLE_CMDCOMPL)\n\t\thfa384x_events_only_cmd(dev);\n\telse\n\t\tprism2_clear_cmd_queue(local);\n}\n\n\nstatic void prism2_hw_reset(struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n#if 0\n\tstatic long last_reset = 0;\n\n\t \n\tif (time_before_eq(jiffies, last_reset + HZ))\n\t\treturn;\n\tlast_reset = jiffies;\n#endif\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (local->hw_downloading)\n\t\treturn;\n\n\tif (local->hw_resetting) {\n\t\tprintk(KERN_WARNING \"%s: %s: already resetting card - \"\n\t\t       \"ignoring reset request\\n\", dev_info, dev->name);\n\t\treturn;\n\t}\n\n\tlocal->hw_reset_tries++;\n\tif (local->hw_reset_tries > 10) {\n\t\tprintk(KERN_WARNING \"%s: too many reset tries, skipping\\n\",\n\t\t       dev->name);\n\t\treturn;\n\t}\n\n\tprintk(KERN_WARNING \"%s: %s: resetting card\\n\", dev_info, dev->name);\n\thfa384x_disable_interrupts(dev);\n\tlocal->hw_resetting = 1;\n\tif (local->func->cor_sreset) {\n\t\t \n\t\tdisable_irq(dev->irq);\n\t\tlocal->func->cor_sreset(local);\n\t\tenable_irq(dev->irq);\n\t}\n\tprism2_hw_shutdown(dev, 1);\n\tprism2_hw_config(dev, 0);\n\tlocal->hw_resetting = 0;\n\n#ifdef PRISM2_DOWNLOAD_SUPPORT\n\tif (local->dl_pri) {\n\t\tprintk(KERN_DEBUG \"%s: persistent download of primary \"\n\t\t       \"firmware\\n\", dev->name);\n\t\tif (prism2_download_genesis(local, local->dl_pri) < 0)\n\t\t\tprintk(KERN_WARNING \"%s: download (PRI) failed\\n\",\n\t\t\t       dev->name);\n\t}\n\n\tif (local->dl_sec) {\n\t\tprintk(KERN_DEBUG \"%s: persistent download of secondary \"\n\t\t       \"firmware\\n\", dev->name);\n\t\tif (prism2_download_volatile(local, local->dl_sec) < 0)\n\t\t\tprintk(KERN_WARNING \"%s: download (SEC) failed\\n\",\n\t\t\t       dev->name);\n\t}\n#endif  \n\n\t \n}\n\n\nstatic void prism2_schedule_reset(local_info_t *local)\n{\n\tschedule_work(&local->reset_queue);\n}\n\n\n \nstatic void handle_reset_queue(struct work_struct *work)\n{\n\tlocal_info_t *local = container_of(work, local_info_t, reset_queue);\n\n\tprintk(KERN_DEBUG \"%s: scheduled card reset\\n\", local->dev->name);\n\tprism2_hw_reset(local->dev);\n\n\tif (netif_queue_stopped(local->dev)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < PRISM2_TXFID_COUNT; i++)\n\t\t\tif (local->intransmitfid[i] == PRISM2_TXFID_EMPTY) {\n\t\t\t\tPDEBUG(DEBUG_EXTRA, \"prism2_tx_timeout: \"\n\t\t\t\t       \"wake up queue\\n\");\n\t\t\t\tnetif_wake_queue(local->dev);\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n}\n\n\nstatic int prism2_get_txfid_idx(local_info_t *local)\n{\n\tint idx, end;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&local->txfidlock, flags);\n\tend = idx = local->next_txfid;\n\tdo {\n\t\tif (local->intransmitfid[idx] == PRISM2_TXFID_EMPTY) {\n\t\t\tlocal->intransmitfid[idx] = PRISM2_TXFID_RESERVED;\n\t\t\tspin_unlock_irqrestore(&local->txfidlock, flags);\n\t\t\treturn idx;\n\t\t}\n\t\tidx++;\n\t\tif (idx >= PRISM2_TXFID_COUNT)\n\t\t\tidx = 0;\n\t} while (idx != end);\n\tspin_unlock_irqrestore(&local->txfidlock, flags);\n\n\tPDEBUG(DEBUG_EXTRA2, \"prism2_get_txfid_idx: no room in txfid buf: \"\n\t       \"packet dropped\\n\");\n\tlocal->dev->stats.tx_dropped++;\n\n\treturn -1;\n}\n\n\n \nstatic void prism2_transmit_cb(struct net_device *dev, long context,\n\t\t\t       u16 resp0, u16 res)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint idx = (int) context;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (res) {\n\t\tprintk(KERN_DEBUG \"%s: prism2_transmit_cb - res=0x%02x\\n\",\n\t\t       dev->name, res);\n\t\treturn;\n\t}\n\n\tif (idx < 0 || idx >= PRISM2_TXFID_COUNT) {\n\t\tprintk(KERN_DEBUG \"%s: prism2_transmit_cb called with invalid \"\n\t\t       \"idx=%d\\n\", dev->name, idx);\n\t\treturn;\n\t}\n\n\tif (!test_and_clear_bit(HOSTAP_BITS_TRANSMIT, &local->bits)) {\n\t\tprintk(KERN_DEBUG \"%s: driver bug: prism2_transmit_cb called \"\n\t\t       \"with no pending transmit\\n\", dev->name);\n\t}\n\n\tif (netif_queue_stopped(dev)) {\n\t\t \n\t\tnetif_wake_queue(dev);\n\t}\n\n\tspin_lock(&local->txfidlock);\n\n\t \n\tlocal->intransmitfid[idx] = resp0;\n\n\tPDEBUG(DEBUG_FID, \"%s: prism2_transmit_cb: txfid[%d]=0x%04x, \"\n\t       \"resp0=0x%04x, transmit_txfid=0x%04x\\n\",\n\t       dev->name, idx, local->txfid[idx],\n\t       resp0, local->intransmitfid[local->next_txfid]);\n\n\tidx++;\n\tif (idx >= PRISM2_TXFID_COUNT)\n\t\tidx = 0;\n\tlocal->next_txfid = idx;\n\n\t \n\tdo {\n\t\tif (local->intransmitfid[idx] == PRISM2_TXFID_EMPTY) {\n\t\t\tspin_unlock(&local->txfidlock);\n\t\t\treturn;\n\t\t}\n\t\tidx++;\n\t\tif (idx >= PRISM2_TXFID_COUNT)\n\t\t\tidx = 0;\n\t} while (idx != local->next_txfid);\n\tspin_unlock(&local->txfidlock);\n\n\t \n\tnetif_stop_queue(dev);\n}\n\n\n \nstatic int prism2_transmit(struct net_device *dev, int idx)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint res;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\t \n\n\tif (test_and_set_bit(HOSTAP_BITS_TRANSMIT, &local->bits)) {\n\t\tprintk(KERN_DEBUG \"%s: driver bug - prism2_transmit() called \"\n\t\t       \"when previous TX was pending\\n\", dev->name);\n\t\treturn -1;\n\t}\n\n\t \n\tnetif_stop_queue(dev);\n\n\t \n\tres = hfa384x_cmd_callback(\n\t\tdev,\n\t\tHFA384X_CMDCODE_TRANSMIT | HFA384X_CMD_TX_RECLAIM,\n\t\tlocal->txfid[idx],\n\t\tprism2_transmit_cb, (long) idx);\n\n\tif (res) {\n\t\tprintk(KERN_DEBUG \"%s: prism2_transmit: CMDCODE_TRANSMIT \"\n\t\t       \"failed (res=%d)\\n\", dev->name, res);\n\t\tdev->stats.tx_dropped++;\n\t\tnetif_wake_queue(dev);\n\t\treturn -1;\n\t}\n\tnetif_trans_update(dev);\n\n\t \n\n\treturn 0;\n}\n\n\n \n \nstatic int prism2_tx_80211(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tstruct hfa384x_tx_frame txdesc;\n\tstruct hostap_skb_tx_data *meta;\n\tint hdr_len, data_len, idx, res, ret = -1;\n\tu16 tx_control;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tmeta = (struct hostap_skb_tx_data *) skb->cb;\n\n\tprism2_callback(local, PRISM2_CALLBACK_TX_START);\n\n\tif ((local->func->card_present && !local->func->card_present(local)) ||\n\t    !local->hw_ready || local->hw_downloading || local->pri_only) {\n\t\tif (net_ratelimit()) {\n\t\t\tprintk(KERN_DEBUG \"%s: prism2_tx_80211: hw not ready -\"\n\t\t\t       \" skipping\\n\", dev->name);\n\t\t}\n\t\tgoto fail;\n\t}\n\n\tmemset(&txdesc, 0, sizeof(txdesc));\n\n\t \n\thdr_len = sizeof(txdesc.header);\n\tBUILD_BUG_ON(hdr_len != 24);\n\tskb_copy_from_linear_data(skb, &txdesc.header, hdr_len);\n\tif (ieee80211_is_data(txdesc.frame_control) &&\n\t    ieee80211_has_a4(txdesc.frame_control) &&\n\t    skb->len >= 30) {\n\t\t \n\t\tskb_copy_from_linear_data_offset(skb, hdr_len, txdesc.addr4,\n\t\t\t\t\t\t ETH_ALEN);\n\t\thdr_len += ETH_ALEN;\n\t}\n\n\ttx_control = local->tx_control;\n\tif (meta->tx_cb_idx) {\n\t\ttx_control |= HFA384X_TX_CTRL_TX_OK;\n\t\ttxdesc.sw_support = cpu_to_le32(meta->tx_cb_idx);\n\t}\n\ttxdesc.tx_control = cpu_to_le16(tx_control);\n\ttxdesc.tx_rate = meta->rate;\n\n\tdata_len = skb->len - hdr_len;\n\ttxdesc.data_len = cpu_to_le16(data_len);\n\ttxdesc.len = cpu_to_be16(data_len);\n\n\tidx = prism2_get_txfid_idx(local);\n\tif (idx < 0)\n\t\tgoto fail;\n\n\tif (local->frame_dump & PRISM2_DUMP_TX_HDR)\n\t\thostap_dump_tx_header(dev->name, &txdesc);\n\n\tspin_lock(&local->baplock);\n\tres = hfa384x_setup_bap(dev, BAP0, local->txfid[idx], 0);\n\n\tif (!res)\n\t\tres = hfa384x_to_bap(dev, BAP0, &txdesc, sizeof(txdesc));\n\tif (!res)\n\t\tres = hfa384x_to_bap(dev, BAP0, skb->data + hdr_len,\n\t\t\t\t     skb->len - hdr_len);\n\tspin_unlock(&local->baplock);\n\n\tif (!res)\n\t\tres = prism2_transmit(dev, idx);\n\tif (res) {\n\t\tprintk(KERN_DEBUG \"%s: prism2_tx_80211 - to BAP0 failed\\n\",\n\t\t       dev->name);\n\t\tlocal->intransmitfid[idx] = PRISM2_TXFID_EMPTY;\n\t\tschedule_work(&local->reset_queue);\n\t\tgoto fail;\n\t}\n\n\tret = 0;\n\nfail:\n\tprism2_callback(local, PRISM2_CALLBACK_TX_END);\n\treturn ret;\n}\n\n\n \n#define EXTRA_FID_READ_TESTS\n\nstatic u16 prism2_read_fid_reg(struct net_device *dev, u16 reg)\n{\n#ifdef EXTRA_FID_READ_TESTS\n\tu16 val, val2, val3;\n\tint i;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tval = HFA384X_INW(reg);\n\t\tval2 = HFA384X_INW(reg);\n\t\tval3 = HFA384X_INW(reg);\n\n\t\tif (val == val2 && val == val3)\n\t\t\treturn val;\n\n\t\tprintk(KERN_DEBUG \"%s: detected fid change (try=%d, reg=%04x):\"\n\t\t       \" %04x %04x %04x\\n\",\n\t\t       dev->name, i, reg, val, val2, val3);\n\t\tif ((val == val2 || val == val3) && val != 0)\n\t\t\treturn val;\n\t\tif (val2 == val3 && val2 != 0)\n\t\t\treturn val2;\n\t}\n\tprintk(KERN_WARNING \"%s: Uhhuh.. could not read good fid from reg \"\n\t       \"%04x (%04x %04x %04x)\\n\", dev->name, reg, val, val2, val3);\n\treturn val;\n#else  \n\treturn HFA384X_INW(reg);\n#endif  \n}\n\n\n \nstatic void prism2_rx(local_info_t *local)\n{\n\tstruct net_device *dev = local->dev;\n\tint res, rx_pending = 0;\n\tu16 len, hdr_len, rxfid, status, macport;\n\tstruct hfa384x_rx_frame rxdesc;\n\tstruct sk_buff *skb = NULL;\n\n\tprism2_callback(local, PRISM2_CALLBACK_RX_START);\n\n\trxfid = prism2_read_fid_reg(dev, HFA384X_RXFID_OFF);\n#ifndef final_version\n\tif (rxfid == 0) {\n\t\trxfid = HFA384X_INW(HFA384X_RXFID_OFF);\n\t\tprintk(KERN_DEBUG \"prism2_rx: rxfid=0 (next 0x%04x)\\n\",\n\t\t       rxfid);\n\t\tif (rxfid == 0) {\n\t\t\tschedule_work(&local->reset_queue);\n\t\t\tgoto rx_dropped;\n\t\t}\n\t\t \n\t}\n#endif\n\n\tspin_lock(&local->baplock);\n\tres = hfa384x_setup_bap(dev, BAP0, rxfid, 0);\n\tif (!res)\n\t\tres = hfa384x_from_bap(dev, BAP0, &rxdesc, sizeof(rxdesc));\n\n\tif (res) {\n\t\tspin_unlock(&local->baplock);\n\t\tprintk(KERN_DEBUG \"%s: copy from BAP0 failed %d\\n\", dev->name,\n\t\t       res);\n\t\tif (res == -ETIMEDOUT) {\n\t\t\tschedule_work(&local->reset_queue);\n\t\t}\n\t\tgoto rx_dropped;\n\t}\n\n\tlen = le16_to_cpu(rxdesc.data_len);\n\thdr_len = sizeof(rxdesc);\n\tstatus = le16_to_cpu(rxdesc.status);\n\tmacport = (status >> 8) & 0x07;\n\n\t \n\tif (len > PRISM2_DATA_MAXLEN + 8  ) {\n\t\tif (macport == 7 && local->iw_mode == IW_MODE_MONITOR) {\n\t\t\tif (len >= (u16) -14) {\n\t\t\t\thdr_len -= 65535 - len;\n\t\t\t\thdr_len--;\n\t\t\t}\n\t\t\tlen = 0;\n\t\t} else {\n\t\t\tspin_unlock(&local->baplock);\n\t\t\tprintk(KERN_DEBUG \"%s: Received frame with invalid \"\n\t\t\t       \"length 0x%04x\\n\", dev->name, len);\n\t\t\thostap_dump_rx_header(dev->name, &rxdesc);\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n\n\tskb = dev_alloc_skb(len + hdr_len);\n\tif (!skb) {\n\t\tspin_unlock(&local->baplock);\n\t\tprintk(KERN_DEBUG \"%s: RX failed to allocate skb\\n\",\n\t\t       dev->name);\n\t\tgoto rx_dropped;\n\t}\n\tskb->dev = dev;\n\tskb_put_data(skb, &rxdesc, hdr_len);\n\n\tif (len > 0)\n\t\tres = hfa384x_from_bap(dev, BAP0, skb_put(skb, len), len);\n\tspin_unlock(&local->baplock);\n\tif (res) {\n\t\tprintk(KERN_DEBUG \"%s: RX failed to read \"\n\t\t       \"frame data\\n\", dev->name);\n\t\tgoto rx_dropped;\n\t}\n\n\tskb_queue_tail(&local->rx_list, skb);\n\ttasklet_schedule(&local->rx_tasklet);\n\n rx_exit:\n\tprism2_callback(local, PRISM2_CALLBACK_RX_END);\n\tif (!rx_pending) {\n\t\tHFA384X_OUTW(HFA384X_EV_RX, HFA384X_EVACK_OFF);\n\t}\n\n\treturn;\n\n rx_dropped:\n\tdev->stats.rx_dropped++;\n\tif (skb)\n\t\tdev_kfree_skb(skb);\n\tgoto rx_exit;\n}\n\n\n \nstatic void hostap_rx_skb(local_info_t *local, struct sk_buff *skb)\n{\n\tstruct hfa384x_rx_frame *rxdesc;\n\tstruct net_device *dev = skb->dev;\n\tstruct hostap_80211_rx_status stats;\n\tint hdrlen, rx_hdrlen;\n\n\trx_hdrlen = sizeof(*rxdesc);\n\tif (skb->len < sizeof(*rxdesc)) {\n\t\t \n\t\tif (local->iw_mode == IW_MODE_MONITOR &&\n\t\t    skb->len >= sizeof(*rxdesc) - 30) {\n\t\t\trx_hdrlen = skb->len;\n\t\t} else {\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t}\n\n\trxdesc = (struct hfa384x_rx_frame *) skb->data;\n\n\tif (local->frame_dump & PRISM2_DUMP_RX_HDR &&\n\t    skb->len >= sizeof(*rxdesc))\n\t\thostap_dump_rx_header(dev->name, rxdesc);\n\n\tif (le16_to_cpu(rxdesc->status) & HFA384X_RX_STATUS_FCSERR &&\n\t    (!local->monitor_allow_fcserr ||\n\t     local->iw_mode != IW_MODE_MONITOR))\n\t\tgoto drop;\n\n\tif (skb->len > PRISM2_DATA_MAXLEN) {\n\t\tprintk(KERN_DEBUG \"%s: RX: len(%d) > MAX(%d)\\n\",\n\t\t       dev->name, skb->len, PRISM2_DATA_MAXLEN);\n\t\tgoto drop;\n\t}\n\n\tstats.mac_time = le32_to_cpu(rxdesc->time);\n\tstats.signal = rxdesc->signal - local->rssi_to_dBm;\n\tstats.noise = rxdesc->silence - local->rssi_to_dBm;\n\tstats.rate = rxdesc->rate;\n\n\t \n\thdrlen = hostap_80211_get_hdrlen(rxdesc->frame_control);\n\tif (hdrlen > rx_hdrlen)\n\t\thdrlen = rx_hdrlen;\n\n\tmemmove(skb_pull(skb, rx_hdrlen - hdrlen),\n\t\t&rxdesc->frame_control, hdrlen);\n\n\thostap_80211_rx(dev, skb, &stats);\n\treturn;\n\n drop:\n\tdev_kfree_skb(skb);\n}\n\n\n \nstatic void hostap_rx_tasklet(struct tasklet_struct *t)\n{\n\tlocal_info_t *local = from_tasklet(local, t, rx_tasklet);\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(&local->rx_list)) != NULL)\n\t\thostap_rx_skb(local, skb);\n}\n\n\n \nstatic void prism2_alloc_ev(struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint idx;\n\tu16 fid;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tfid = prism2_read_fid_reg(dev, HFA384X_ALLOCFID_OFF);\n\n\tPDEBUG(DEBUG_FID, \"FID: interrupt: ALLOC - fid=0x%04x\\n\", fid);\n\n\tspin_lock(&local->txfidlock);\n\tidx = local->next_alloc;\n\n\tdo {\n\t\tif (local->txfid[idx] == fid) {\n\t\t\tPDEBUG(DEBUG_FID, \"FID: found matching txfid[%d]\\n\",\n\t\t\t       idx);\n\n#ifndef final_version\n\t\t\tif (local->intransmitfid[idx] == PRISM2_TXFID_EMPTY)\n\t\t\t\tprintk(\"Already released txfid found at idx \"\n\t\t\t\t       \"%d\\n\", idx);\n\t\t\tif (local->intransmitfid[idx] == PRISM2_TXFID_RESERVED)\n\t\t\t\tprintk(\"Already reserved txfid found at idx \"\n\t\t\t\t       \"%d\\n\", idx);\n#endif\n\t\t\tlocal->intransmitfid[idx] = PRISM2_TXFID_EMPTY;\n\t\t\tidx++;\n\t\t\tlocal->next_alloc = idx >= PRISM2_TXFID_COUNT ? 0 :\n\t\t\t\tidx;\n\n\t\t\tif (!test_bit(HOSTAP_BITS_TRANSMIT, &local->bits) &&\n\t\t\t    netif_queue_stopped(dev))\n\t\t\t\tnetif_wake_queue(dev);\n\n\t\t\tspin_unlock(&local->txfidlock);\n\t\t\treturn;\n\t\t}\n\n\t\tidx++;\n\t\tif (idx >= PRISM2_TXFID_COUNT)\n\t\t\tidx = 0;\n\t} while (idx != local->next_alloc);\n\n\tprintk(KERN_WARNING \"%s: could not find matching txfid (0x%04x, new \"\n\t       \"read 0x%04x) for alloc event\\n\", dev->name, fid,\n\t       HFA384X_INW(HFA384X_ALLOCFID_OFF));\n\tprintk(KERN_DEBUG \"TXFIDs:\");\n\tfor (idx = 0; idx < PRISM2_TXFID_COUNT; idx++)\n\t\tprintk(\" %04x[%04x]\", local->txfid[idx],\n\t\t       local->intransmitfid[idx]);\n\tprintk(\"\\n\");\n\tspin_unlock(&local->txfidlock);\n\n\t \n}\n\n\n \nstatic void hostap_tx_callback(local_info_t *local,\n\t\t\t       struct hfa384x_tx_frame *txdesc, int ok,\n\t\t\t       char *payload)\n{\n\tu16 sw_support, hdrlen, len;\n\tstruct sk_buff *skb;\n\tstruct hostap_tx_callback_info *cb;\n\n\t \n\tif (!ether_addr_equal(txdesc->addr2, local->dev->dev_addr)) {\n\t\tprintk(KERN_DEBUG \"%s: TX callback - foreign frame\\n\",\n\t\t       local->dev->name);\n\t\treturn;\n\t}\n\n\tsw_support = le32_to_cpu(txdesc->sw_support);\n\n\tspin_lock(&local->lock);\n\tcb = local->tx_callback;\n\twhile (cb != NULL && cb->idx != sw_support)\n\t\tcb = cb->next;\n\tspin_unlock(&local->lock);\n\n\tif (cb == NULL) {\n\t\tprintk(KERN_DEBUG \"%s: could not find TX callback (idx %d)\\n\",\n\t\t       local->dev->name, sw_support);\n\t\treturn;\n\t}\n\n\thdrlen = hostap_80211_get_hdrlen(txdesc->frame_control);\n\tlen = le16_to_cpu(txdesc->data_len);\n\tskb = dev_alloc_skb(hdrlen + len);\n\tif (skb == NULL) {\n\t\tprintk(KERN_DEBUG \"%s: hostap_tx_callback failed to allocate \"\n\t\t       \"skb\\n\", local->dev->name);\n\t\treturn;\n\t}\n\n\tskb_put_data(skb, (void *)&txdesc->frame_control, hdrlen);\n\tif (payload)\n\t\tskb_put_data(skb, payload, len);\n\n\tskb->dev = local->dev;\n\tskb_reset_mac_header(skb);\n\n\tcb->func(skb, ok, cb->data);\n}\n\n\n \nstatic int hostap_tx_compl_read(local_info_t *local, int error,\n\t\t\t\tstruct hfa384x_tx_frame *txdesc,\n\t\t\t\tchar **payload)\n{\n\tu16 fid, len;\n\tint res, ret = 0;\n\tstruct net_device *dev = local->dev;\n\n\tfid = prism2_read_fid_reg(dev, HFA384X_TXCOMPLFID_OFF);\n\n\tPDEBUG(DEBUG_FID, \"interrupt: TX (err=%d) - fid=0x%04x\\n\", fid, error);\n\n\tspin_lock(&local->baplock);\n\tres = hfa384x_setup_bap(dev, BAP0, fid, 0);\n\tif (!res)\n\t\tres = hfa384x_from_bap(dev, BAP0, txdesc, sizeof(*txdesc));\n\tif (res) {\n\t\tPDEBUG(DEBUG_EXTRA, \"%s: TX (err=%d) - fid=0x%04x - could not \"\n\t\t       \"read txdesc\\n\", dev->name, error, fid);\n\t\tif (res == -ETIMEDOUT) {\n\t\t\tschedule_work(&local->reset_queue);\n\t\t}\n\t\tret = -1;\n\t\tgoto fail;\n\t}\n\tif (txdesc->sw_support) {\n\t\tlen = le16_to_cpu(txdesc->data_len);\n\t\tif (len < PRISM2_DATA_MAXLEN) {\n\t\t\t*payload = kmalloc(len, GFP_ATOMIC);\n\t\t\tif (*payload == NULL ||\n\t\t\t    hfa384x_from_bap(dev, BAP0, *payload, len)) {\n\t\t\t\tPDEBUG(DEBUG_EXTRA, \"%s: could not read TX \"\n\t\t\t\t       \"frame payload\\n\", dev->name);\n\t\t\t\tkfree(*payload);\n\t\t\t\t*payload = NULL;\n\t\t\t\tret = -1;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n\n fail:\n\tspin_unlock(&local->baplock);\n\n\treturn ret;\n}\n\n\n \nstatic void prism2_tx_ev(local_info_t *local)\n{\n\tstruct net_device *dev = local->dev;\n\tchar *payload = NULL;\n\tstruct hfa384x_tx_frame txdesc;\n\n\tif (hostap_tx_compl_read(local, 0, &txdesc, &payload))\n\t\tgoto fail;\n\n\tif (local->frame_dump & PRISM2_DUMP_TX_HDR) {\n\t\tPDEBUG(DEBUG_EXTRA, \"%s: TX - status=0x%04x \"\n\t\t       \"retry_count=%d tx_rate=%d seq_ctrl=%d \"\n\t\t       \"duration_id=%d\\n\",\n\t\t       dev->name, le16_to_cpu(txdesc.status),\n\t\t       txdesc.retry_count, txdesc.tx_rate,\n\t\t       le16_to_cpu(txdesc.seq_ctrl),\n\t\t       le16_to_cpu(txdesc.duration_id));\n\t}\n\n\tif (txdesc.sw_support)\n\t\thostap_tx_callback(local, &txdesc, 1, payload);\n\tkfree(payload);\n\n fail:\n\tHFA384X_OUTW(HFA384X_EV_TX, HFA384X_EVACK_OFF);\n}\n\n\n \nstatic void hostap_sta_tx_exc_tasklet(struct tasklet_struct *t)\n{\n\tlocal_info_t *local = from_tasklet(local, t, sta_tx_exc_tasklet);\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(&local->sta_tx_exc_list)) != NULL) {\n\t\tstruct hfa384x_tx_frame *txdesc =\n\t\t\t(struct hfa384x_tx_frame *) skb->data;\n\n\t\tif (skb->len >= sizeof(*txdesc)) {\n\t\t\t \n\t\t\tint hdrlen = hostap_80211_get_hdrlen(txdesc->frame_control);\n\t\t\tmemmove(skb_pull(skb, sizeof(*txdesc) - hdrlen),\n\t\t\t\t&txdesc->frame_control, hdrlen);\n\n\t\t\thostap_handle_sta_tx_exc(local, skb);\n\t\t}\n\t\tdev_kfree_skb(skb);\n\t}\n}\n\n\n \nstatic void prism2_txexc(local_info_t *local)\n{\n\tstruct net_device *dev = local->dev;\n\tu16 status, fc;\n\tint show_dump, res;\n\tchar *payload = NULL;\n\tstruct hfa384x_tx_frame txdesc;\n\n\tshow_dump = local->frame_dump & PRISM2_DUMP_TXEXC_HDR;\n\tdev->stats.tx_errors++;\n\n\tres = hostap_tx_compl_read(local, 1, &txdesc, &payload);\n\tHFA384X_OUTW(HFA384X_EV_TXEXC, HFA384X_EVACK_OFF);\n\tif (res)\n\t\treturn;\n\n\tstatus = le16_to_cpu(txdesc.status);\n\n\t \n\tif (status & (HFA384X_TX_STATUS_RETRYERR | HFA384X_TX_STATUS_AGEDERR))\n\t{\n\t\tunion iwreq_data wrqu;\n\n\t\t \n\t\tmemcpy(wrqu.addr.sa_data, txdesc.addr1, ETH_ALEN);\n\t\twrqu.addr.sa_family = ARPHRD_ETHER;\n\t\twireless_send_event(dev, IWEVTXDROP, &wrqu, NULL);\n\t} else\n\t\tshow_dump = 1;\n\n\tif (local->iw_mode == IW_MODE_MASTER ||\n\t    local->iw_mode == IW_MODE_REPEAT ||\n\t    local->wds_type & HOSTAP_WDS_AP_CLIENT) {\n\t\tstruct sk_buff *skb;\n\t\tskb = dev_alloc_skb(sizeof(txdesc));\n\t\tif (skb) {\n\t\t\tskb_put_data(skb, &txdesc, sizeof(txdesc));\n\t\t\tskb_queue_tail(&local->sta_tx_exc_list, skb);\n\t\t\ttasklet_schedule(&local->sta_tx_exc_tasklet);\n\t\t}\n\t}\n\n\tif (txdesc.sw_support)\n\t\thostap_tx_callback(local, &txdesc, 0, payload);\n\tkfree(payload);\n\n\tif (!show_dump)\n\t\treturn;\n\n\tPDEBUG(DEBUG_EXTRA, \"%s: TXEXC - status=0x%04x (%s%s%s%s)\"\n\t       \" tx_control=%04x\\n\",\n\t       dev->name, status,\n\t       status & HFA384X_TX_STATUS_RETRYERR ? \"[RetryErr]\" : \"\",\n\t       status & HFA384X_TX_STATUS_AGEDERR ? \"[AgedErr]\" : \"\",\n\t       status & HFA384X_TX_STATUS_DISCON ? \"[Discon]\" : \"\",\n\t       status & HFA384X_TX_STATUS_FORMERR ? \"[FormErr]\" : \"\",\n\t       le16_to_cpu(txdesc.tx_control));\n\n\tfc = le16_to_cpu(txdesc.frame_control);\n\tPDEBUG(DEBUG_EXTRA, \"   retry_count=%d tx_rate=%d fc=0x%04x \"\n\t       \"(%s%s%s::%d%s%s)\\n\",\n\t       txdesc.retry_count, txdesc.tx_rate, fc,\n\t       ieee80211_is_mgmt(txdesc.frame_control) ? \"Mgmt\" : \"\",\n\t       ieee80211_is_ctl(txdesc.frame_control) ? \"Ctrl\" : \"\",\n\t       ieee80211_is_data(txdesc.frame_control) ? \"Data\" : \"\",\n\t       (fc & IEEE80211_FCTL_STYPE) >> 4,\n\t       ieee80211_has_tods(txdesc.frame_control) ? \" ToDS\" : \"\",\n\t       ieee80211_has_fromds(txdesc.frame_control) ? \" FromDS\" : \"\");\n\tPDEBUG(DEBUG_EXTRA, \"   A1=%pM A2=%pM A3=%pM A4=%pM\\n\",\n\t       txdesc.addr1, txdesc.addr2,\n\t       txdesc.addr3, txdesc.addr4);\n}\n\n\n \nstatic void hostap_info_tasklet(struct tasklet_struct *t)\n{\n\tlocal_info_t *local = from_tasklet(local, t, info_tasklet);\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(&local->info_list)) != NULL) {\n\t\thostap_info_process(local, skb);\n\t\tdev_kfree_skb(skb);\n\t}\n}\n\n\n \nstatic void prism2_info(local_info_t *local)\n{\n\tstruct net_device *dev = local->dev;\n\tu16 fid;\n\tint res, left;\n\tstruct hfa384x_info_frame info;\n\tstruct sk_buff *skb;\n\n\tfid = HFA384X_INW(HFA384X_INFOFID_OFF);\n\n\tspin_lock(&local->baplock);\n\tres = hfa384x_setup_bap(dev, BAP0, fid, 0);\n\tif (!res)\n\t\tres = hfa384x_from_bap(dev, BAP0, &info, sizeof(info));\n\tif (res) {\n\t\tspin_unlock(&local->baplock);\n\t\tprintk(KERN_DEBUG \"Could not get info frame (fid=0x%04x)\\n\",\n\t\t       fid);\n\t\tif (res == -ETIMEDOUT) {\n\t\t\tschedule_work(&local->reset_queue);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tleft = (le16_to_cpu(info.len) - 1) * 2;\n\n\tif (info.len & cpu_to_le16(0x8000) || info.len == 0 || left > 2060) {\n\t\t \n\t\tspin_unlock(&local->baplock);\n\t\tprintk(KERN_DEBUG \"%s: Received info frame with invalid \"\n\t\t       \"length 0x%04x (type 0x%04x)\\n\", dev->name,\n\t\t       le16_to_cpu(info.len), le16_to_cpu(info.type));\n\t\tgoto out;\n\t}\n\n\tskb = dev_alloc_skb(sizeof(info) + left);\n\tif (skb == NULL) {\n\t\tspin_unlock(&local->baplock);\n\t\tprintk(KERN_DEBUG \"%s: Could not allocate skb for info \"\n\t\t       \"frame\\n\", dev->name);\n\t\tgoto out;\n\t}\n\n\tskb_put_data(skb, &info, sizeof(info));\n\tif (left > 0 && hfa384x_from_bap(dev, BAP0, skb_put(skb, left), left))\n\t{\n\t\tspin_unlock(&local->baplock);\n\t\tprintk(KERN_WARNING \"%s: Info frame read failed (fid=0x%04x, \"\n\t\t       \"len=0x%04x, type=0x%04x\\n\", dev->name, fid,\n\t\t       le16_to_cpu(info.len), le16_to_cpu(info.type));\n\t\tdev_kfree_skb(skb);\n\t\tgoto out;\n\t}\n\tspin_unlock(&local->baplock);\n\n\tskb_queue_tail(&local->info_list, skb);\n\ttasklet_schedule(&local->info_tasklet);\n\n out:\n\tHFA384X_OUTW(HFA384X_EV_INFO, HFA384X_EVACK_OFF);\n}\n\n\n \nstatic void hostap_bap_tasklet(struct tasklet_struct *t)\n{\n\tlocal_info_t *local = from_tasklet(local, t, bap_tasklet);\n\tstruct net_device *dev = local->dev;\n\tu16 ev;\n\tint frames = 30;\n\n\tif (local->func->card_present && !local->func->card_present(local))\n\t\treturn;\n\n\tset_bit(HOSTAP_BITS_BAP_TASKLET, &local->bits);\n\n\t \n\twhile (frames-- > 0) {\n\t\tev = HFA384X_INW(HFA384X_EVSTAT_OFF);\n\t\tif (ev == 0xffff || !(ev & HFA384X_BAP0_EVENTS))\n\t\t\tbreak;\n\t\tif (ev & HFA384X_EV_RX)\n\t\t\tprism2_rx(local);\n\t\tif (ev & HFA384X_EV_INFO)\n\t\t\tprism2_info(local);\n\t\tif (ev & HFA384X_EV_TX)\n\t\t\tprism2_tx_ev(local);\n\t\tif (ev & HFA384X_EV_TXEXC)\n\t\t\tprism2_txexc(local);\n\t}\n\n\tset_bit(HOSTAP_BITS_BAP_TASKLET2, &local->bits);\n\tclear_bit(HOSTAP_BITS_BAP_TASKLET, &local->bits);\n\n\t \n\thfa384x_events_all(dev);\n\tclear_bit(HOSTAP_BITS_BAP_TASKLET2, &local->bits);\n}\n\n\n \nstatic void prism2_infdrop(struct net_device *dev)\n{\n\tstatic unsigned long last_inquire = 0;\n\n\tPDEBUG(DEBUG_EXTRA, \"%s: INFDROP event\\n\", dev->name);\n\n\t \n\tif (!last_inquire || time_after(jiffies, last_inquire + HZ)) {\n\t\thfa384x_cmd_callback(dev, HFA384X_CMDCODE_INQUIRE,\n\t\t\t\t     HFA384X_INFO_COMMTALLIES, NULL, 0);\n\t\tlast_inquire = jiffies;\n\t}\n}\n\n\n \nstatic void prism2_ev_tick(struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tu16 evstat, inten;\n\tstatic int prev_stuck = 0;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (time_after(jiffies, local->last_tick_timer + 5 * HZ) &&\n\t    local->last_tick_timer) {\n\t\tevstat = HFA384X_INW(HFA384X_EVSTAT_OFF);\n\t\tinten = HFA384X_INW(HFA384X_INTEN_OFF);\n\t\tif (!prev_stuck) {\n\t\t\tprintk(KERN_INFO \"%s: SW TICK stuck? \"\n\t\t\t       \"bits=0x%lx EvStat=%04x IntEn=%04x\\n\",\n\t\t\t       dev->name, local->bits, evstat, inten);\n\t\t}\n\t\tlocal->sw_tick_stuck++;\n\t\tif ((evstat & HFA384X_BAP0_EVENTS) &&\n\t\t    (inten & HFA384X_BAP0_EVENTS)) {\n\t\t\tprintk(KERN_INFO \"%s: trying to recover from IRQ \"\n\t\t\t       \"hang\\n\", dev->name);\n\t\t\thfa384x_events_no_bap0(dev);\n\t\t}\n\t\tprev_stuck = 1;\n\t} else\n\t\tprev_stuck = 0;\n}\n\n\n \nstatic void prism2_check_magic(local_info_t *local)\n{\n\t \n\n#ifndef PRISM2_PCI\n#ifndef final_version\n\tstatic unsigned long last_magic_err = 0;\n\tstruct net_device *dev = local->dev;\n\n\tif (HFA384X_INW(HFA384X_SWSUPPORT0_OFF) != HFA384X_MAGIC) {\n\t\tif (!local->hw_ready)\n\t\t\treturn;\n\t\tHFA384X_OUTW(0xffff, HFA384X_EVACK_OFF);\n\t\tif (time_after(jiffies, last_magic_err + 10 * HZ)) {\n\t\t\tprintk(\"%s: Interrupt, but SWSUPPORT0 does not match: \"\n\t\t\t       \"%04X != %04X - card removed?\\n\", dev->name,\n\t\t\t       HFA384X_INW(HFA384X_SWSUPPORT0_OFF),\n\t\t\t       HFA384X_MAGIC);\n\t\t\tlast_magic_err = jiffies;\n\t\t} else if (net_ratelimit()) {\n\t\t\tprintk(KERN_DEBUG \"%s: interrupt - SWSUPPORT0=%04x \"\n\t\t\t       \"MAGIC=%04x\\n\", dev->name,\n\t\t\t       HFA384X_INW(HFA384X_SWSUPPORT0_OFF),\n\t\t\t       HFA384X_MAGIC);\n\t\t}\n\t\tif (HFA384X_INW(HFA384X_SWSUPPORT0_OFF) != 0xffff)\n\t\t\tschedule_work(&local->reset_queue);\n\t\treturn;\n\t}\n#endif  \n#endif  \n}\n\n\n \nstatic irqreturn_t prism2_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint events = 0;\n\tu16 ev;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\t \n\tspin_lock(&local->irq_init_lock);\n\tif (!dev->base_addr) {\n\t\tif (net_ratelimit()) {\n\t\t\tprintk(KERN_DEBUG \"%s: Interrupt, but dev not configured\\n\",\n\t\t\t       dev->name);\n\t\t}\n\t\tspin_unlock(&local->irq_init_lock);\n\t\treturn IRQ_HANDLED;\n\t}\n\tspin_unlock(&local->irq_init_lock);\n\n\tprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_INTERRUPT, 0, 0);\n\n\tif (local->func->card_present && !local->func->card_present(local)) {\n\t\tif (net_ratelimit()) {\n\t\t\tprintk(KERN_DEBUG \"%s: Interrupt, but dev not OK\\n\",\n\t\t\t       dev->name);\n\t\t}\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tprism2_check_magic(local);\n\n\tfor (;;) {\n\t\tev = HFA384X_INW(HFA384X_EVSTAT_OFF);\n\t\tif (ev == 0xffff) {\n\t\t\tif (local->shutdown)\n\t\t\t\treturn IRQ_HANDLED;\n\t\t\tHFA384X_OUTW(0xffff, HFA384X_EVACK_OFF);\n\t\t\tprintk(KERN_DEBUG \"%s: prism2_interrupt: ev=0xffff\\n\",\n\t\t\t       dev->name);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\n\t\tev &= HFA384X_INW(HFA384X_INTEN_OFF);\n\t\tif (ev == 0)\n\t\t\tbreak;\n\n\t\tif (ev & HFA384X_EV_CMD) {\n\t\t\tprism2_cmd_ev(dev);\n\t\t}\n\n\t\t \n\t\tif (!local->hw_ready || local->hw_resetting ||\n\t\t    !local->dev_enabled) {\n\t\t\tev = HFA384X_INW(HFA384X_EVSTAT_OFF);\n\t\t\tif (ev & HFA384X_EV_CMD)\n\t\t\t\tgoto next_event;\n\t\t\tif ((ev & HFA384X_EVENT_MASK) == 0)\n\t\t\t\treturn IRQ_HANDLED;\n\t\t\tif (local->dev_enabled && (ev & ~HFA384X_EV_TICK) &&\n\t\t\t    net_ratelimit()) {\n\t\t\t\tprintk(KERN_DEBUG \"%s: prism2_interrupt: hw \"\n\t\t\t\t       \"not ready; skipping events 0x%04x \"\n\t\t\t\t       \"(IntEn=0x%04x)%s%s%s\\n\",\n\t\t\t\t       dev->name, ev,\n\t\t\t\t       HFA384X_INW(HFA384X_INTEN_OFF),\n\t\t\t\t       !local->hw_ready ? \" (!hw_ready)\" : \"\",\n\t\t\t\t       local->hw_resetting ?\n\t\t\t\t       \" (hw_resetting)\" : \"\",\n\t\t\t\t       !local->dev_enabled ?\n\t\t\t\t       \" (!dev_enabled)\" : \"\");\n\t\t\t}\n\t\t\tHFA384X_OUTW(ev, HFA384X_EVACK_OFF);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\n\t\tif (ev & HFA384X_EV_TICK) {\n\t\t\tprism2_ev_tick(dev);\n\t\t\tHFA384X_OUTW(HFA384X_EV_TICK, HFA384X_EVACK_OFF);\n\t\t}\n\n\t\tif (ev & HFA384X_EV_ALLOC) {\n\t\t\tprism2_alloc_ev(dev);\n\t\t\tHFA384X_OUTW(HFA384X_EV_ALLOC, HFA384X_EVACK_OFF);\n\t\t}\n\n\t\t \n\t\tif (ev & HFA384X_BAP0_EVENTS) {\n\t\t\thfa384x_events_no_bap0(dev);\n\t\t\ttasklet_schedule(&local->bap_tasklet);\n\t\t}\n\n#ifndef final_version\n\t\tif (ev & HFA384X_EV_WTERR) {\n\t\t\tPDEBUG(DEBUG_EXTRA, \"%s: WTERR event\\n\", dev->name);\n\t\t\tHFA384X_OUTW(HFA384X_EV_WTERR, HFA384X_EVACK_OFF);\n\t\t}\n#endif  \n\n\t\tif (ev & HFA384X_EV_INFDROP) {\n\t\t\tprism2_infdrop(dev);\n\t\t\tHFA384X_OUTW(HFA384X_EV_INFDROP, HFA384X_EVACK_OFF);\n\t\t}\n\n\tnext_event:\n\t\tevents++;\n\t\tif (events >= PRISM2_MAX_INTERRUPT_EVENTS) {\n\t\t\tPDEBUG(DEBUG_EXTRA, \"prism2_interrupt: >%d events \"\n\t\t\t       \"(EvStat=0x%04x)\\n\",\n\t\t\t       PRISM2_MAX_INTERRUPT_EVENTS,\n\t\t\t       HFA384X_INW(HFA384X_EVSTAT_OFF));\n\t\t\tbreak;\n\t\t}\n\t}\n\tprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_INTERRUPT, 0, 1);\n\treturn IRQ_RETVAL(events);\n}\n\n\nstatic void prism2_check_sta_fw_version(local_info_t *local)\n{\n\tstruct hfa384x_comp_ident comp;\n\tint id, variant, major, minor;\n\n\tif (hfa384x_get_rid(local->dev, HFA384X_RID_STAID,\n\t\t\t    &comp, sizeof(comp), 1) < 0)\n\t\treturn;\n\n\tlocal->fw_ap = 0;\n\tid = le16_to_cpu(comp.id);\n\tif (id != HFA384X_COMP_ID_STA) {\n\t\tif (id == HFA384X_COMP_ID_FW_AP)\n\t\t\tlocal->fw_ap = 1;\n\t\treturn;\n\t}\n\n\tmajor = __le16_to_cpu(comp.major);\n\tminor = __le16_to_cpu(comp.minor);\n\tvariant = __le16_to_cpu(comp.variant);\n\tlocal->sta_fw_ver = PRISM2_FW_VER(major, minor, variant);\n\n\t \n\tlocal->fw_encrypt_ok = local->sta_fw_ver >= PRISM2_FW_VER(1,4,9);\n\n\tif (local->iw_mode == IW_MODE_MASTER && !local->host_encrypt &&\n\t    !local->fw_encrypt_ok) {\n\t\tprintk(KERN_DEBUG \"%s: defaulting to host-based encryption as \"\n\t\t       \"a workaround for firmware bug in Host AP mode WEP\\n\",\n\t\t       local->dev->name);\n\t\tlocal->host_encrypt = 1;\n\t}\n\n\t \n\tif (local->sta_fw_ver >= PRISM2_FW_VER(1,5,0))\n\t\tlocal->wds_type |= HOSTAP_WDS_STANDARD_FRAME;\n\telse {\n\t\tprintk(KERN_DEBUG \"%s: defaulting to bogus WDS frame as a \"\n\t\t       \"workaround for firmware bug in Host AP mode WDS\\n\",\n\t\t       local->dev->name);\n\t}\n\n\thostap_check_sta_fw_version(local->ap, local->sta_fw_ver);\n}\n\n\nstatic void hostap_passive_scan(struct timer_list *t)\n{\n\tlocal_info_t *local = from_timer(local, t, passive_scan_timer);\n\tstruct net_device *dev = local->dev;\n\tu16 chan;\n\n\tif (local->passive_scan_interval <= 0)\n\t\treturn;\n\n\tif (local->passive_scan_state == PASSIVE_SCAN_LISTEN) {\n\t\tint max_tries = 16;\n\n\t\t \n\t\tif (test_bit(HOSTAP_BITS_TRANSMIT, &local->bits)) {\n\t\t\tprintk(KERN_DEBUG \"%s: passive scan detected pending \"\n\t\t\t       \"TX - delaying\\n\", dev->name);\n\t\t\tlocal->passive_scan_timer.expires = jiffies + HZ / 10;\n\t\t\tadd_timer(&local->passive_scan_timer);\n\t\t\treturn;\n\t\t}\n\n\t\tdo {\n\t\t\tlocal->passive_scan_channel++;\n\t\t\tif (local->passive_scan_channel > 14)\n\t\t\t\tlocal->passive_scan_channel = 1;\n\t\t\tmax_tries--;\n\t\t} while (!(local->channel_mask &\n\t\t\t   (1 << (local->passive_scan_channel - 1))) &&\n\t\t\t max_tries > 0);\n\n\t\tif (max_tries == 0) {\n\t\t\tprintk(KERN_INFO \"%s: no allowed passive scan channels\"\n\t\t\t       \" found\\n\", dev->name);\n\t\t\treturn;\n\t\t}\n\n\t\tprintk(KERN_DEBUG \"%s: passive scan channel %d\\n\",\n\t\t       dev->name, local->passive_scan_channel);\n\t\tchan = local->passive_scan_channel;\n\t\tlocal->passive_scan_state = PASSIVE_SCAN_WAIT;\n\t\tlocal->passive_scan_timer.expires = jiffies + HZ / 10;\n\t} else {\n\t\tchan = local->channel;\n\t\tlocal->passive_scan_state = PASSIVE_SCAN_LISTEN;\n\t\tlocal->passive_scan_timer.expires = jiffies +\n\t\t\tlocal->passive_scan_interval * HZ;\n\t}\n\n\tif (hfa384x_cmd_callback(dev, HFA384X_CMDCODE_TEST |\n\t\t\t\t (HFA384X_TEST_CHANGE_CHANNEL << 8),\n\t\t\t\t chan, NULL, 0))\n\t\tprintk(KERN_ERR \"%s: passive scan channel set %d \"\n\t\t       \"failed\\n\", dev->name, chan);\n\n\tadd_timer(&local->passive_scan_timer);\n}\n\n\n \nstatic void handle_comms_qual_update(struct work_struct *work)\n{\n\tlocal_info_t *local =\n\t\tcontainer_of(work, local_info_t, comms_qual_update);\n\tprism2_update_comms_qual(local->dev);\n}\n\n\n \nstatic void hostap_tick_timer(struct timer_list *t)\n{\n\tstatic unsigned long last_inquire = 0;\n\tlocal_info_t *local = from_timer(local, t, tick_timer);\n\tlocal->last_tick_timer = jiffies;\n\n\t \n\tif ((!last_inquire || time_after(jiffies, last_inquire + 10 * HZ)) &&\n\t    !local->hw_downloading && local->hw_ready &&\n\t    !local->hw_resetting && local->dev_enabled) {\n\t\thfa384x_cmd_callback(local->dev, HFA384X_CMDCODE_INQUIRE,\n\t\t\t\t     HFA384X_INFO_COMMTALLIES, NULL, 0);\n\t\tlast_inquire = jiffies;\n\t}\n\n\tif ((local->last_comms_qual_update == 0 ||\n\t     time_after(jiffies, local->last_comms_qual_update + 10 * HZ)) &&\n\t    (local->iw_mode == IW_MODE_INFRA ||\n\t     local->iw_mode == IW_MODE_ADHOC)) {\n\t\tschedule_work(&local->comms_qual_update);\n\t}\n\n\tlocal->tick_timer.expires = jiffies + 2 * HZ;\n\tadd_timer(&local->tick_timer);\n}\n\n\n#if !defined(PRISM2_NO_PROCFS_DEBUG) && defined(CONFIG_PROC_FS)\nstatic u16 hfa384x_read_reg(struct net_device *dev, u16 reg)\n{\n\treturn HFA384X_INW(reg);\n}\n\nstatic int prism2_registers_proc_show(struct seq_file *m, void *v)\n{\n\tlocal_info_t *local = m->private;\n\n#define SHOW_REG(n) \\\n  seq_printf(m, #n \"=%04x\\n\", hfa384x_read_reg(local->dev, HFA384X_##n##_OFF))\n\n\tSHOW_REG(CMD);\n\tSHOW_REG(PARAM0);\n\tSHOW_REG(PARAM1);\n\tSHOW_REG(PARAM2);\n\tSHOW_REG(STATUS);\n\tSHOW_REG(RESP0);\n\tSHOW_REG(RESP1);\n\tSHOW_REG(RESP2);\n\tSHOW_REG(INFOFID);\n\tSHOW_REG(CONTROL);\n\tSHOW_REG(SELECT0);\n\tSHOW_REG(SELECT1);\n\tSHOW_REG(OFFSET0);\n\tSHOW_REG(OFFSET1);\n\tSHOW_REG(RXFID);\n\tSHOW_REG(ALLOCFID);\n\tSHOW_REG(TXCOMPLFID);\n\tSHOW_REG(SWSUPPORT0);\n\tSHOW_REG(SWSUPPORT1);\n\tSHOW_REG(SWSUPPORT2);\n\tSHOW_REG(EVSTAT);\n\tSHOW_REG(INTEN);\n\tSHOW_REG(EVACK);\n\t \n\t \n\t \n\tSHOW_REG(AUXPAGE);\n\tSHOW_REG(AUXOFFSET);\n\t \n#ifdef PRISM2_PCI\n\tSHOW_REG(PCICOR);\n\tSHOW_REG(PCIHCR);\n\tSHOW_REG(PCI_M0_ADDRH);\n\tSHOW_REG(PCI_M0_ADDRL);\n\tSHOW_REG(PCI_M0_LEN);\n\tSHOW_REG(PCI_M0_CTL);\n\tSHOW_REG(PCI_STATUS);\n\tSHOW_REG(PCI_M1_ADDRH);\n\tSHOW_REG(PCI_M1_ADDRL);\n\tSHOW_REG(PCI_M1_LEN);\n\tSHOW_REG(PCI_M1_CTL);\n#endif  \n\n\treturn 0;\n}\n#endif\n\nstruct set_tim_data {\n\tstruct list_head list;\n\tint aid;\n\tint set;\n};\n\nstatic int prism2_set_tim(struct net_device *dev, int aid, int set)\n{\n\tstruct list_head *ptr;\n\tstruct set_tim_data *new_entry;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tnew_entry = kzalloc(sizeof(*new_entry), GFP_ATOMIC);\n\tif (new_entry == NULL)\n\t\treturn -ENOMEM;\n\n\tnew_entry->aid = aid;\n\tnew_entry->set = set;\n\n\tspin_lock_bh(&local->set_tim_lock);\n\tlist_for_each(ptr, &local->set_tim_list) {\n\t\tstruct set_tim_data *entry =\n\t\t\tlist_entry(ptr, struct set_tim_data, list);\n\t\tif (entry->aid == aid) {\n\t\t\tPDEBUG(DEBUG_PS2, \"%s: prism2_set_tim: aid=%d \"\n\t\t\t       \"set=%d ==> %d\\n\",\n\t\t\t       local->dev->name, aid, entry->set, set);\n\t\t\tentry->set = set;\n\t\t\tkfree(new_entry);\n\t\t\tnew_entry = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (new_entry)\n\t\tlist_add_tail(&new_entry->list, &local->set_tim_list);\n\tspin_unlock_bh(&local->set_tim_lock);\n\n\tschedule_work(&local->set_tim_queue);\n\n\treturn 0;\n}\n\n\nstatic void handle_set_tim_queue(struct work_struct *work)\n{\n\tlocal_info_t *local = container_of(work, local_info_t, set_tim_queue);\n\tstruct set_tim_data *entry;\n\tu16 val;\n\n\tfor (;;) {\n\t\tentry = NULL;\n\t\tspin_lock_bh(&local->set_tim_lock);\n\t\tif (!list_empty(&local->set_tim_list)) {\n\t\t\tentry = list_entry(local->set_tim_list.next,\n\t\t\t\t\t   struct set_tim_data, list);\n\t\t\tlist_del(&entry->list);\n\t\t}\n\t\tspin_unlock_bh(&local->set_tim_lock);\n\t\tif (!entry)\n\t\t\tbreak;\n\n\t\tPDEBUG(DEBUG_PS2, \"%s: handle_set_tim_queue: aid=%d set=%d\\n\",\n\t\t       local->dev->name, entry->aid, entry->set);\n\n\t\tval = entry->aid;\n\t\tif (entry->set)\n\t\t\tval |= 0x8000;\n\t\tif (hostap_set_word(local->dev, HFA384X_RID_CNFTIMCTRL, val)) {\n\t\t\tprintk(KERN_DEBUG \"%s: set_tim failed (aid=%d \"\n\t\t\t       \"set=%d)\\n\",\n\t\t\t       local->dev->name, entry->aid, entry->set);\n\t\t}\n\n\t\tkfree(entry);\n\t}\n}\n\n\nstatic void prism2_clear_set_tim_queue(local_info_t *local)\n{\n\tstruct list_head *ptr, *n;\n\n\tlist_for_each_safe(ptr, n, &local->set_tim_list) {\n\t\tstruct set_tim_data *entry;\n\t\tentry = list_entry(ptr, struct set_tim_data, list);\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n}\n\n\n \nstatic struct lock_class_key hostap_netdev_xmit_lock_key;\nstatic struct lock_class_key hostap_netdev_addr_lock_key;\n\nstatic void prism2_set_lockdep_class_one(struct net_device *dev,\n\t\t\t\t\t struct netdev_queue *txq,\n\t\t\t\t\t void *_unused)\n{\n\tlockdep_set_class(&txq->_xmit_lock,\n\t\t\t  &hostap_netdev_xmit_lock_key);\n}\n\nstatic void prism2_set_lockdep_class(struct net_device *dev)\n{\n\tlockdep_set_class(&dev->addr_list_lock,\n\t\t\t  &hostap_netdev_addr_lock_key);\n\tnetdev_for_each_tx_queue(dev, prism2_set_lockdep_class_one, NULL);\n}\n\nstatic struct net_device *\nprism2_init_local_data(struct prism2_helper_functions *funcs, int card_idx,\n\t\t       struct device *sdev)\n{\n\tstruct net_device *dev;\n\tstruct hostap_interface *iface;\n\tstruct local_info *local;\n\tint len, i, ret;\n\n\tif (funcs == NULL)\n\t\treturn NULL;\n\n\tlen = strlen(dev_template);\n\tif (len >= IFNAMSIZ || strstr(dev_template, \"%d\") == NULL) {\n\t\tprintk(KERN_WARNING \"hostap: Invalid dev_template='%s'\\n\",\n\t\t       dev_template);\n\t\treturn NULL;\n\t}\n\n\tlen = sizeof(struct hostap_interface) +\n\t\t3 + sizeof(struct local_info) +\n\t\t3 + sizeof(struct ap_data);\n\n\tdev = alloc_etherdev(len);\n\tif (dev == NULL)\n\t\treturn NULL;\n\n\tiface = netdev_priv(dev);\n\tlocal = (struct local_info *) ((((long) (iface + 1)) + 3) & ~3);\n\tlocal->ap = (struct ap_data *) ((((long) (local + 1)) + 3) & ~3);\n\tlocal->dev = iface->dev = dev;\n\tiface->local = local;\n\tiface->type = HOSTAP_INTERFACE_MASTER;\n\tINIT_LIST_HEAD(&local->hostap_interfaces);\n\n\tlocal->hw_module = THIS_MODULE;\n\n#ifdef PRISM2_IO_DEBUG\n\tlocal->io_debug_enabled = 1;\n#endif  \n\n\tlocal->func = funcs;\n\tlocal->func->cmd = hfa384x_cmd;\n\tlocal->func->read_regs = hfa384x_read_regs;\n\tlocal->func->get_rid = hfa384x_get_rid;\n\tlocal->func->set_rid = hfa384x_set_rid;\n\tlocal->func->hw_enable = prism2_hw_enable;\n\tlocal->func->hw_config = prism2_hw_config;\n\tlocal->func->hw_reset = prism2_hw_reset;\n\tlocal->func->hw_shutdown = prism2_hw_shutdown;\n\tlocal->func->reset_port = prism2_reset_port;\n\tlocal->func->schedule_reset = prism2_schedule_reset;\n#ifdef PRISM2_DOWNLOAD_SUPPORT\n\tlocal->func->read_aux_proc_ops = &prism2_download_aux_dump_proc_ops;\n\tlocal->func->download = prism2_download;\n#endif  \n\tlocal->func->tx = prism2_tx_80211;\n\tlocal->func->set_tim = prism2_set_tim;\n\tlocal->func->need_tx_headroom = 0;  \n\n\tlocal->mtu = mtu;\n\n\trwlock_init(&local->iface_lock);\n\tspin_lock_init(&local->txfidlock);\n\tspin_lock_init(&local->cmdlock);\n\tspin_lock_init(&local->baplock);\n\tspin_lock_init(&local->lock);\n\tspin_lock_init(&local->irq_init_lock);\n\tmutex_init(&local->rid_bap_mtx);\n\n\tif (card_idx < 0 || card_idx >= MAX_PARM_DEVICES)\n\t\tcard_idx = 0;\n\tlocal->card_idx = card_idx;\n\n\tlen = strlen(essid);\n\tmemcpy(local->essid, essid,\n\t       len > MAX_SSID_LEN ? MAX_SSID_LEN : len);\n\tlocal->essid[MAX_SSID_LEN] = '\\0';\n\ti = GET_INT_PARM(iw_mode, card_idx);\n\tif ((i >= IW_MODE_ADHOC && i <= IW_MODE_REPEAT) ||\n\t    i == IW_MODE_MONITOR) {\n\t\tlocal->iw_mode = i;\n\t} else {\n\t\tprintk(KERN_WARNING \"prism2: Unknown iw_mode %d; using \"\n\t\t       \"IW_MODE_MASTER\\n\", i);\n\t\tlocal->iw_mode = IW_MODE_MASTER;\n\t}\n\tlocal->channel = GET_INT_PARM(channel, card_idx);\n\tlocal->beacon_int = GET_INT_PARM(beacon_int, card_idx);\n\tlocal->dtim_period = GET_INT_PARM(dtim_period, card_idx);\n\tlocal->wds_max_connections = 16;\n\tlocal->tx_control = HFA384X_TX_CTRL_FLAGS;\n\tlocal->manual_retry_count = -1;\n\tlocal->rts_threshold = 2347;\n\tlocal->fragm_threshold = 2346;\n\tlocal->rssi_to_dBm = 100;  \n\tlocal->auth_algs = PRISM2_AUTH_OPEN | PRISM2_AUTH_SHARED_KEY;\n\tlocal->sram_type = -1;\n\tlocal->scan_channel_mask = 0xffff;\n\tlocal->monitor_type = PRISM2_MONITOR_RADIOTAP;\n\n\t \n\tINIT_WORK(&local->reset_queue, handle_reset_queue);\n\tINIT_WORK(&local->set_multicast_list_queue,\n\t\t  hostap_set_multicast_list_queue);\n\n\tINIT_WORK(&local->set_tim_queue, handle_set_tim_queue);\n\tINIT_LIST_HEAD(&local->set_tim_list);\n\tspin_lock_init(&local->set_tim_lock);\n\n\tINIT_WORK(&local->comms_qual_update, handle_comms_qual_update);\n\n\t \n\ttasklet_setup(&local->bap_tasklet, hostap_bap_tasklet);\n\ttasklet_setup(&local->info_tasklet, hostap_info_tasklet);\n\thostap_info_init(local);\n\n\ttasklet_setup(&local->rx_tasklet, hostap_rx_tasklet);\n\tskb_queue_head_init(&local->rx_list);\n\n\ttasklet_setup(&local->sta_tx_exc_tasklet,\n\t\t\t    hostap_sta_tx_exc_tasklet);\n\tskb_queue_head_init(&local->sta_tx_exc_list);\n\n\tINIT_LIST_HEAD(&local->cmd_queue);\n\tinit_waitqueue_head(&local->hostscan_wq);\n\n\tlib80211_crypt_info_init(&local->crypt_info, dev->name, &local->lock);\n\n\ttimer_setup(&local->passive_scan_timer, hostap_passive_scan, 0);\n\ttimer_setup(&local->tick_timer, hostap_tick_timer, 0);\n\tlocal->tick_timer.expires = jiffies + 2 * HZ;\n\tadd_timer(&local->tick_timer);\n\n\tINIT_LIST_HEAD(&local->bss_list);\n\n\thostap_setup_dev(dev, local, HOSTAP_INTERFACE_MASTER);\n\n\tdev->type = ARPHRD_IEEE80211;\n\tdev->header_ops = &hostap_80211_ops;\n\n\trtnl_lock();\n\tret = dev_alloc_name(dev, \"wifi%d\");\n\tSET_NETDEV_DEV(dev, sdev);\n\tif (ret >= 0)\n\t\tret = register_netdevice(dev);\n\n\tprism2_set_lockdep_class(dev);\n\trtnl_unlock();\n\tif (ret < 0) {\n\t\tprintk(KERN_WARNING \"%s: register netdevice failed!\\n\",\n\t\t       dev_info);\n\t\tgoto fail;\n\t}\n\tprintk(KERN_INFO \"%s: Registered netdevice %s\\n\", dev_info, dev->name);\n\n\thostap_init_data(local);\n\treturn dev;\n\n fail:\n\tfree_netdev(dev);\n\treturn NULL;\n}\n\n\nstatic int hostap_hw_ready(struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tstruct local_info *local;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\tlocal->ddev = hostap_add_interface(local, HOSTAP_INTERFACE_MAIN, 0,\n\t\t\t\t\t   \"\", dev_template);\n\n\tif (local->ddev) {\n\t\tif (local->iw_mode == IW_MODE_INFRA ||\n\t\t    local->iw_mode == IW_MODE_ADHOC) {\n\t\t\tnetif_carrier_off(local->dev);\n\t\t\tnetif_carrier_off(local->ddev);\n\t\t}\n\t\thostap_init_proc(local);\n#ifndef PRISM2_NO_PROCFS_DEBUG\n\t\tproc_create_single_data(\"registers\", 0, local->proc,\n\t\t\t\t prism2_registers_proc_show, local);\n#endif  \n\t\thostap_init_ap_proc(local);\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\n\nstatic void prism2_free_local_data(struct net_device *dev)\n{\n\tstruct hostap_tx_callback_info *tx_cb, *tx_cb_prev;\n\tint i;\n\tstruct hostap_interface *iface;\n\tstruct local_info *local;\n\tstruct list_head *ptr, *n;\n\n\tif (dev == NULL)\n\t\treturn;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\t \n\tlist_for_each_safe(ptr, n, &local->hostap_interfaces) {\n\t\tiface = list_entry(ptr, struct hostap_interface, list);\n\t\tif (iface->type == HOSTAP_INTERFACE_MASTER) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\thostap_remove_interface(iface->dev, 0, 1);\n\t}\n\n\tunregister_netdev(local->dev);\n\n\tflush_work(&local->reset_queue);\n\tflush_work(&local->set_multicast_list_queue);\n\tflush_work(&local->set_tim_queue);\n#ifndef PRISM2_NO_STATION_MODES\n\tflush_work(&local->info_queue);\n#endif\n\tflush_work(&local->comms_qual_update);\n\n\tlib80211_crypt_info_free(&local->crypt_info);\n\n\tif (timer_pending(&local->passive_scan_timer))\n\t\tdel_timer(&local->passive_scan_timer);\n\n\tif (timer_pending(&local->tick_timer))\n\t\tdel_timer(&local->tick_timer);\n\n\tprism2_clear_cmd_queue(local);\n\n\tskb_queue_purge(&local->info_list);\n\tskb_queue_purge(&local->rx_list);\n\tskb_queue_purge(&local->sta_tx_exc_list);\n\n\tif (local->dev_enabled)\n\t\tprism2_callback(local, PRISM2_CALLBACK_DISABLE);\n\n\tif (local->ap != NULL)\n\t\thostap_free_data(local->ap);\n\n#ifndef PRISM2_NO_PROCFS_DEBUG\n\tif (local->proc != NULL)\n\t\tremove_proc_entry(\"registers\", local->proc);\n#endif  \n\thostap_remove_proc(local);\n\n\ttx_cb = local->tx_callback;\n\twhile (tx_cb != NULL) {\n\t\ttx_cb_prev = tx_cb;\n\t\ttx_cb = tx_cb->next;\n\t\tkfree(tx_cb_prev);\n\t}\n\n\thostap_set_hostapd(local, 0, 0);\n\thostap_set_hostapd_sta(local, 0, 0);\n\n\tfor (i = 0; i < PRISM2_FRAG_CACHE_LEN; i++) {\n\t\tif (local->frag_cache[i].skb != NULL)\n\t\t\tdev_kfree_skb(local->frag_cache[i].skb);\n\t}\n\n#ifdef PRISM2_DOWNLOAD_SUPPORT\n\tprism2_download_free_data(local->dl_pri);\n\tprism2_download_free_data(local->dl_sec);\n#endif  \n\n\tprism2_clear_set_tim_queue(local);\n\n\tlist_for_each_safe(ptr, n, &local->bss_list) {\n\t\tstruct hostap_bss_info *bss =\n\t\t\tlist_entry(ptr, struct hostap_bss_info, list);\n\t\tkfree(bss);\n\t}\n\n\tkfree(local->pda);\n\tkfree(local->last_scan_results);\n\tkfree(local->generic_elem);\n\n\tfree_netdev(local->dev);\n}\n\n\n#if defined(PRISM2_PCI) || defined(PRISM2_PCCARD)\nstatic void __maybe_unused prism2_suspend(struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tstruct local_info *local;\n\tunion iwreq_data wrqu;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\t \n\tmemset(&wrqu, 0, sizeof(wrqu));\n\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\twireless_send_event(local->dev, SIOCGIWAP, &wrqu, NULL);\n\n\t \n\tprism2_hw_shutdown(dev, 0);\n}\n#endif  \n\n\n \n#ifdef PRISM2_DOWNLOAD_SUPPORT\n#include \"hostap_download.c\"\n#endif  \n\n#ifdef PRISM2_CALLBACK\n \n#include \"hostap_callback.c\"\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}