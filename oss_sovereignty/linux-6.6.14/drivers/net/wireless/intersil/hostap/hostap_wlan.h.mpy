{
  "module_name": "hostap_wlan.h",
  "hash_id": "cf2984b169d6739f6d729446aacca7f207aad40eba69f630598200d1214235b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/hostap/hostap_wlan.h",
  "human_readable_source": " \n#ifndef HOSTAP_WLAN_H\n#define HOSTAP_WLAN_H\n\n#include <linux/interrupt.h>\n#include <linux/wireless.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <net/iw_handler.h>\n#include <net/ieee80211_radiotap.h>\n#include <net/lib80211.h>\n\n#include \"hostap_config.h\"\n#include \"hostap_common.h\"\n\n#define MAX_PARM_DEVICES 8\n#define PARM_MIN_MAX \"1-\" __MODULE_STRING(MAX_PARM_DEVICES)\n#define DEF_INTS -1, -1, -1, -1, -1, -1, -1\n#define GET_INT_PARM(var,idx) var[var[idx] < 0 ? 0 : idx]\n\n\n \n#define ETH_P_HOSTAP ETH_P_CONTROL\n\n \nstruct linux_wlan_ng_val {\n\tu32 did;\n\tu16 status, len;\n\tu32 data;\n} __packed;\n\nstruct linux_wlan_ng_prism_hdr {\n\tu32 msgcode, msglen;\n\tchar devname[16];\n\tstruct linux_wlan_ng_val hosttime, mactime, channel, rssi, sq, signal,\n\t\tnoise, rate, istx, frmlen;\n} __packed;\n\nstruct linux_wlan_ng_cap_hdr {\n\t__be32 version;\n\t__be32 length;\n\t__be64 mactime;\n\t__be64 hosttime;\n\t__be32 phytype;\n\t__be32 channel;\n\t__be32 datarate;\n\t__be32 antenna;\n\t__be32 priority;\n\t__be32 ssi_type;\n\t__be32 ssi_signal;\n\t__be32 ssi_noise;\n\t__be32 preamble;\n\t__be32 encoding;\n} __packed;\n\nstruct hostap_radiotap_rx {\n\tstruct ieee80211_radiotap_header hdr;\n\t__le64 tsft;\n\tu8 rate;\n\tu8 padding;\n\t__le16 chan_freq;\n\t__le16 chan_flags;\n\ts8 dbm_antsignal;\n\ts8 dbm_antnoise;\n} __packed;\n\n#define LWNG_CAP_DID_BASE   (4 | (1 << 6))  \n#define LWNG_CAPHDR_VERSION 0x80211001\n\nstruct hfa384x_rx_frame {\n\t \n\t__le16 status;  \n\t__le32 time;  \n\tu8 silence;  \n\tu8 signal;  \n\tu8 rate;  \n\tu8 rxflow;\n\t__le32 reserved;\n\n\t \n\t__le16 frame_control;\n\t__le16 duration_id;\n\tu8 addr1[ETH_ALEN];\n\tu8 addr2[ETH_ALEN];\n\tu8 addr3[ETH_ALEN];\n\t__le16 seq_ctrl;\n\tu8 addr4[ETH_ALEN];\n\t__le16 data_len;\n\n\t \n\tu8 dst_addr[ETH_ALEN];\n\tu8 src_addr[ETH_ALEN];\n\t__be16 len;\n\n\t \n} __packed;\n\n\nstruct hfa384x_tx_frame {\n\t \n\t__le16 status;  \n\t__le16 reserved1;\n\t__le16 reserved2;\n\t__le32 sw_support;\n\tu8 retry_count;  \n\tu8 tx_rate;  \n\t__le16 tx_control;  \n\n\t \n\tstruct_group(header,\n\t\t__le16 frame_control;  \n\t\t__le16 duration_id;\n\t\tu8 addr1[ETH_ALEN];\n\t\tu8 addr2[ETH_ALEN];  \n\t\tu8 addr3[ETH_ALEN];\n\t\t__le16 seq_ctrl;  \n\t);\n\tu8 addr4[ETH_ALEN];\n\t__le16 data_len;\n\n\t \n\tu8 dst_addr[ETH_ALEN];\n\tu8 src_addr[ETH_ALEN];\n\t__be16 len;\n\n\t \n} __packed;\n\n\nstruct hfa384x_rid_hdr\n{\n\t__le16 len;\n\t__le16 rid;\n} __packed;\n\n\n \n#define HFA384X_LEVEL_TO_dBm(v) 0x100 + (v) * 100 / 255 - 100\n\n#define HFA384X_LEVEL_TO_dBm_sign(v) (v) * 100 / 255 - 100\n\nstruct hfa384x_scan_request {\n\t__le16 channel_list;\n\t__le16 txrate;  \n} __packed;\n\nstruct hfa384x_hostscan_request {\n\t__le16 channel_list;\n\t__le16 txrate;\n\t__le16 target_ssid_len;\n\tu8 target_ssid[32];\n} __packed;\n\nstruct hfa384x_join_request {\n\tu8 bssid[ETH_ALEN];\n\t__le16 channel;\n} __packed;\n\nstruct hfa384x_info_frame {\n\t__le16 len;\n\t__le16 type;\n} __packed;\n\nstruct hfa384x_comm_tallies {\n\t__le16 tx_unicast_frames;\n\t__le16 tx_multicast_frames;\n\t__le16 tx_fragments;\n\t__le16 tx_unicast_octets;\n\t__le16 tx_multicast_octets;\n\t__le16 tx_deferred_transmissions;\n\t__le16 tx_single_retry_frames;\n\t__le16 tx_multiple_retry_frames;\n\t__le16 tx_retry_limit_exceeded;\n\t__le16 tx_discards;\n\t__le16 rx_unicast_frames;\n\t__le16 rx_multicast_frames;\n\t__le16 rx_fragments;\n\t__le16 rx_unicast_octets;\n\t__le16 rx_multicast_octets;\n\t__le16 rx_fcs_errors;\n\t__le16 rx_discards_no_buffer;\n\t__le16 tx_discards_wrong_sa;\n\t__le16 rx_discards_wep_undecryptable;\n\t__le16 rx_message_in_msg_fragments;\n\t__le16 rx_message_in_bad_msg_fragments;\n} __packed;\n\nstruct hfa384x_comm_tallies32 {\n\t__le32 tx_unicast_frames;\n\t__le32 tx_multicast_frames;\n\t__le32 tx_fragments;\n\t__le32 tx_unicast_octets;\n\t__le32 tx_multicast_octets;\n\t__le32 tx_deferred_transmissions;\n\t__le32 tx_single_retry_frames;\n\t__le32 tx_multiple_retry_frames;\n\t__le32 tx_retry_limit_exceeded;\n\t__le32 tx_discards;\n\t__le32 rx_unicast_frames;\n\t__le32 rx_multicast_frames;\n\t__le32 rx_fragments;\n\t__le32 rx_unicast_octets;\n\t__le32 rx_multicast_octets;\n\t__le32 rx_fcs_errors;\n\t__le32 rx_discards_no_buffer;\n\t__le32 tx_discards_wrong_sa;\n\t__le32 rx_discards_wep_undecryptable;\n\t__le32 rx_message_in_msg_fragments;\n\t__le32 rx_message_in_bad_msg_fragments;\n} __packed;\n\nstruct hfa384x_scan_result_hdr {\n\t__le16 reserved;\n\t__le16 scan_reason;\n#define HFA384X_SCAN_IN_PROGRESS 0  \n#define HFA384X_SCAN_HOST_INITIATED 1\n#define HFA384X_SCAN_FIRMWARE_INITIATED 2\n#define HFA384X_SCAN_INQUIRY_FROM_HOST 3\n} __packed;\n\n#define HFA384X_SCAN_MAX_RESULTS 32\n\nstruct hfa384x_scan_result {\n\t__le16 chid;\n\t__le16 anl;\n\t__le16 sl;\n\tu8 bssid[ETH_ALEN];\n\t__le16 beacon_interval;\n\t__le16 capability;\n\t__le16 ssid_len;\n\tu8 ssid[32];\n\tu8 sup_rates[10];\n\t__le16 rate;\n} __packed;\n\nstruct hfa384x_hostscan_result {\n\t__le16 chid;\n\t__le16 anl;\n\t__le16 sl;\n\tu8 bssid[ETH_ALEN];\n\t__le16 beacon_interval;\n\t__le16 capability;\n\t__le16 ssid_len;\n\tu8 ssid[32];\n\tu8 sup_rates[10];\n\t__le16 rate;\n\t__le16 atim;\n} __packed;\n\nstruct comm_tallies_sums {\n\tunsigned int tx_unicast_frames;\n\tunsigned int tx_multicast_frames;\n\tunsigned int tx_fragments;\n\tunsigned int tx_unicast_octets;\n\tunsigned int tx_multicast_octets;\n\tunsigned int tx_deferred_transmissions;\n\tunsigned int tx_single_retry_frames;\n\tunsigned int tx_multiple_retry_frames;\n\tunsigned int tx_retry_limit_exceeded;\n\tunsigned int tx_discards;\n\tunsigned int rx_unicast_frames;\n\tunsigned int rx_multicast_frames;\n\tunsigned int rx_fragments;\n\tunsigned int rx_unicast_octets;\n\tunsigned int rx_multicast_octets;\n\tunsigned int rx_fcs_errors;\n\tunsigned int rx_discards_no_buffer;\n\tunsigned int tx_discards_wrong_sa;\n\tunsigned int rx_discards_wep_undecryptable;\n\tunsigned int rx_message_in_msg_fragments;\n\tunsigned int rx_message_in_bad_msg_fragments;\n};\n\n\nstruct hfa384x_regs {\n\tu16 cmd;\n\tu16 evstat;\n\tu16 offset0;\n\tu16 offset1;\n\tu16 swsupport0;\n};\n\n\n#if defined(PRISM2_PCCARD) || defined(PRISM2_PLX)\n \n#define HFA384X_CMD_OFF 0x00\n#define HFA384X_PARAM0_OFF 0x02\n#define HFA384X_PARAM1_OFF 0x04\n#define HFA384X_PARAM2_OFF 0x06\n#define HFA384X_STATUS_OFF 0x08\n#define HFA384X_RESP0_OFF 0x0A\n#define HFA384X_RESP1_OFF 0x0C\n#define HFA384X_RESP2_OFF 0x0E\n#define HFA384X_INFOFID_OFF 0x10\n#define HFA384X_CONTROL_OFF 0x14\n#define HFA384X_SELECT0_OFF 0x18\n#define HFA384X_SELECT1_OFF 0x1A\n#define HFA384X_OFFSET0_OFF 0x1C\n#define HFA384X_OFFSET1_OFF 0x1E\n#define HFA384X_RXFID_OFF 0x20\n#define HFA384X_ALLOCFID_OFF 0x22\n#define HFA384X_TXCOMPLFID_OFF 0x24\n#define HFA384X_SWSUPPORT0_OFF 0x28\n#define HFA384X_SWSUPPORT1_OFF 0x2A\n#define HFA384X_SWSUPPORT2_OFF 0x2C\n#define HFA384X_EVSTAT_OFF 0x30\n#define HFA384X_INTEN_OFF 0x32\n#define HFA384X_EVACK_OFF 0x34\n#define HFA384X_DATA0_OFF 0x36\n#define HFA384X_DATA1_OFF 0x38\n#define HFA384X_AUXPAGE_OFF 0x3A\n#define HFA384X_AUXOFFSET_OFF 0x3C\n#define HFA384X_AUXDATA_OFF 0x3E\n#endif  \n\n#ifdef PRISM2_PCI\n \n#define HFA384X_CMD_OFF 0x00\n#define HFA384X_PARAM0_OFF 0x04\n#define HFA384X_PARAM1_OFF 0x08\n#define HFA384X_PARAM2_OFF 0x0C\n#define HFA384X_STATUS_OFF 0x10\n#define HFA384X_RESP0_OFF 0x14\n#define HFA384X_RESP1_OFF 0x18\n#define HFA384X_RESP2_OFF 0x1C\n#define HFA384X_INFOFID_OFF 0x20\n#define HFA384X_CONTROL_OFF 0x28\n#define HFA384X_SELECT0_OFF 0x30\n#define HFA384X_SELECT1_OFF 0x34\n#define HFA384X_OFFSET0_OFF 0x38\n#define HFA384X_OFFSET1_OFF 0x3C\n#define HFA384X_RXFID_OFF 0x40\n#define HFA384X_ALLOCFID_OFF 0x44\n#define HFA384X_TXCOMPLFID_OFF 0x48\n#define HFA384X_PCICOR_OFF 0x4C\n#define HFA384X_SWSUPPORT0_OFF 0x50\n#define HFA384X_SWSUPPORT1_OFF 0x54\n#define HFA384X_SWSUPPORT2_OFF 0x58\n#define HFA384X_PCIHCR_OFF 0x5C\n#define HFA384X_EVSTAT_OFF 0x60\n#define HFA384X_INTEN_OFF 0x64\n#define HFA384X_EVACK_OFF 0x68\n#define HFA384X_DATA0_OFF 0x6C\n#define HFA384X_DATA1_OFF 0x70\n#define HFA384X_AUXPAGE_OFF 0x74\n#define HFA384X_AUXOFFSET_OFF 0x78\n#define HFA384X_AUXDATA_OFF 0x7C\n#define HFA384X_PCI_M0_ADDRH_OFF 0x80\n#define HFA384X_PCI_M0_ADDRL_OFF 0x84\n#define HFA384X_PCI_M0_LEN_OFF 0x88\n#define HFA384X_PCI_M0_CTL_OFF 0x8C\n#define HFA384X_PCI_STATUS_OFF 0x98\n#define HFA384X_PCI_M1_ADDRH_OFF 0xA0\n#define HFA384X_PCI_M1_ADDRL_OFF 0xA4\n#define HFA384X_PCI_M1_LEN_OFF 0xA8\n#define HFA384X_PCI_M1_CTL_OFF 0xAC\n\n \n#define HFA384X_PCI_CTL_FROM_BAP (BIT(5) | BIT(1) | BIT(0))\n#define HFA384X_PCI_CTL_TO_BAP (BIT(5) | BIT(0))\n\n#endif  \n\n\n \n#define HFA384X_CMDCODE_INIT 0x00\n#define HFA384X_CMDCODE_ENABLE 0x01\n#define HFA384X_CMDCODE_DISABLE 0x02\n#define HFA384X_CMDCODE_ALLOC 0x0A\n#define HFA384X_CMDCODE_TRANSMIT 0x0B\n#define HFA384X_CMDCODE_INQUIRE 0x11\n#define HFA384X_CMDCODE_ACCESS 0x21\n#define HFA384X_CMDCODE_ACCESS_WRITE (0x21 | BIT(8))\n#define HFA384X_CMDCODE_DOWNLOAD 0x22\n#define HFA384X_CMDCODE_READMIF 0x30\n#define HFA384X_CMDCODE_WRITEMIF 0x31\n#define HFA384X_CMDCODE_TEST 0x38\n\n#define HFA384X_CMDCODE_MASK 0x3F\n\n \n#define HFA384X_TEST_CHANGE_CHANNEL 0x08\n#define HFA384X_TEST_MONITOR 0x0B\n#define HFA384X_TEST_STOP 0x0F\n#define HFA384X_TEST_CFG_BITS 0x15\n#define HFA384X_TEST_CFG_BIT_ALC BIT(3)\n\n#define HFA384X_CMD_BUSY BIT(15)\n\n#define HFA384X_CMD_TX_RECLAIM BIT(8)\n\n#define HFA384X_OFFSET_ERR BIT(14)\n#define HFA384X_OFFSET_BUSY BIT(15)\n\n\n \n#define HFA384X_PROGMODE_DISABLE 0\n#define HFA384X_PROGMODE_ENABLE_VOLATILE 1\n#define HFA384X_PROGMODE_ENABLE_NON_VOLATILE 2\n#define HFA384X_PROGMODE_PROGRAM_NON_VOLATILE 3\n\n#define HFA384X_AUX_MAGIC0 0xfe01\n#define HFA384X_AUX_MAGIC1 0xdc23\n#define HFA384X_AUX_MAGIC2 0xba45\n\n#define HFA384X_AUX_PORT_DISABLED 0\n#define HFA384X_AUX_PORT_DISABLE BIT(14)\n#define HFA384X_AUX_PORT_ENABLE BIT(15)\n#define HFA384X_AUX_PORT_ENABLED (BIT(14) | BIT(15))\n#define HFA384X_AUX_PORT_MASK (BIT(14) | BIT(15))\n\n#define PRISM2_PDA_SIZE 1024\n\n\n \n#define HFA384X_EV_TICK BIT(15)\n#define HFA384X_EV_WTERR BIT(14)\n#define HFA384X_EV_INFDROP BIT(13)\n#ifdef PRISM2_PCI\n#define HFA384X_EV_PCI_M1 BIT(9)\n#define HFA384X_EV_PCI_M0 BIT(8)\n#endif  \n#define HFA384X_EV_INFO BIT(7)\n#define HFA384X_EV_DTIM BIT(5)\n#define HFA384X_EV_CMD BIT(4)\n#define HFA384X_EV_ALLOC BIT(3)\n#define HFA384X_EV_TXEXC BIT(2)\n#define HFA384X_EV_TX BIT(1)\n#define HFA384X_EV_RX BIT(0)\n\n\n \n#define HFA384X_INFO_HANDOVERADDR 0xF000  \n#define HFA384X_INFO_HANDOVERDEAUTHADDR 0xF001  \n#define HFA384X_INFO_COMMTALLIES 0xF100\n#define HFA384X_INFO_SCANRESULTS 0xF101\n#define HFA384X_INFO_CHANNELINFORESULTS 0xF102  \n#define HFA384X_INFO_HOSTSCANRESULTS 0xF103\n#define HFA384X_INFO_LINKSTATUS 0xF200\n#define HFA384X_INFO_ASSOCSTATUS 0xF201  \n#define HFA384X_INFO_AUTHREQ 0xF202  \n#define HFA384X_INFO_PSUSERCNT 0xF203  \n#define HFA384X_INFO_KEYIDCHANGED 0xF204  \n\nenum { HFA384X_LINKSTATUS_CONNECTED = 1,\n       HFA384X_LINKSTATUS_DISCONNECTED = 2,\n       HFA384X_LINKSTATUS_AP_CHANGE = 3,\n       HFA384X_LINKSTATUS_AP_OUT_OF_RANGE = 4,\n       HFA384X_LINKSTATUS_AP_IN_RANGE = 5,\n       HFA384X_LINKSTATUS_ASSOC_FAILED = 6 };\n\nenum { HFA384X_PORTTYPE_BSS = 1, HFA384X_PORTTYPE_WDS = 2,\n       HFA384X_PORTTYPE_PSEUDO_IBSS = 3, HFA384X_PORTTYPE_IBSS = 0,\n       HFA384X_PORTTYPE_HOSTAP = 6 };\n\n#define HFA384X_RATES_1MBPS BIT(0)\n#define HFA384X_RATES_2MBPS BIT(1)\n#define HFA384X_RATES_5MBPS BIT(2)\n#define HFA384X_RATES_11MBPS BIT(3)\n\n#define HFA384X_ROAMING_FIRMWARE 1\n#define HFA384X_ROAMING_HOST 2\n#define HFA384X_ROAMING_DISABLED 3\n\n#define HFA384X_WEPFLAGS_PRIVACYINVOKED BIT(0)\n#define HFA384X_WEPFLAGS_EXCLUDEUNENCRYPTED BIT(1)\n#define HFA384X_WEPFLAGS_HOSTENCRYPT BIT(4)\n#define HFA384X_WEPFLAGS_HOSTDECRYPT BIT(7)\n\n#define HFA384X_RX_STATUS_MSGTYPE (BIT(15) | BIT(14) | BIT(13))\n#define HFA384X_RX_STATUS_PCF BIT(12)\n#define HFA384X_RX_STATUS_MACPORT (BIT(10) | BIT(9) | BIT(8))\n#define HFA384X_RX_STATUS_UNDECR BIT(1)\n#define HFA384X_RX_STATUS_FCSERR BIT(0)\n\n#define HFA384X_RX_STATUS_GET_MSGTYPE(s) \\\n(((s) & HFA384X_RX_STATUS_MSGTYPE) >> 13)\n#define HFA384X_RX_STATUS_GET_MACPORT(s) \\\n(((s) & HFA384X_RX_STATUS_MACPORT) >> 8)\n\nenum { HFA384X_RX_MSGTYPE_NORMAL = 0, HFA384X_RX_MSGTYPE_RFC1042 = 1,\n       HFA384X_RX_MSGTYPE_BRIDGETUNNEL = 2, HFA384X_RX_MSGTYPE_MGMT = 4 };\n\n\n#define HFA384X_TX_CTRL_ALT_RTRY BIT(5)\n#define HFA384X_TX_CTRL_802_11 BIT(3)\n#define HFA384X_TX_CTRL_802_3 0\n#define HFA384X_TX_CTRL_TX_EX BIT(2)\n#define HFA384X_TX_CTRL_TX_OK BIT(1)\n\n#define HFA384X_TX_STATUS_RETRYERR BIT(0)\n#define HFA384X_TX_STATUS_AGEDERR BIT(1)\n#define HFA384X_TX_STATUS_DISCON BIT(2)\n#define HFA384X_TX_STATUS_FORMERR BIT(3)\n\n \n#define HFA386X_CR_TX_CONFIGURE 0x12  \n#define HFA386X_CR_RX_CONFIGURE 0x14  \n#define HFA386X_CR_A_D_TEST_MODES2 0x1A  \n#define HFA386X_CR_MANUAL_TX_POWER 0x3E  \n#define HFA386X_CR_MEASURED_TX_POWER 0x74  \n\n\n#ifdef __KERNEL__\n\n#define PRISM2_TXFID_COUNT 8\n#define PRISM2_DATA_MAXLEN 2304\n#define PRISM2_TXFID_LEN (PRISM2_DATA_MAXLEN + sizeof(struct hfa384x_tx_frame))\n#define PRISM2_TXFID_EMPTY 0xffff\n#define PRISM2_TXFID_RESERVED 0xfffe\n#define PRISM2_DUMMY_FID 0xffff\n#define MAX_SSID_LEN 32\n#define MAX_NAME_LEN 32  \n\n#define PRISM2_DUMP_RX_HDR BIT(0)\n#define PRISM2_DUMP_TX_HDR BIT(1)\n#define PRISM2_DUMP_TXEXC_HDR BIT(2)\n\nstruct hostap_tx_callback_info {\n\tu16 idx;\n\tvoid (*func)(struct sk_buff *, int ok, void *);\n\tvoid *data;\n\tstruct hostap_tx_callback_info *next;\n};\n\n\n \n#define PRISM2_FRAG_CACHE_LEN 4\n\nstruct prism2_frag_entry {\n\tunsigned long first_frag_time;\n\tunsigned int seq;\n\tunsigned int last_frag;\n\tstruct sk_buff *skb;\n\tu8 src_addr[ETH_ALEN];\n\tu8 dst_addr[ETH_ALEN];\n};\n\n\nstruct hostap_cmd_queue {\n\tstruct list_head list;\n\twait_queue_head_t compl;\n\tvolatile enum { CMD_SLEEP, CMD_CALLBACK, CMD_COMPLETED } type;\n\tvoid (*callback)(struct net_device *dev, long context, u16 resp0,\n\t\t\t u16 res);\n\tlong context;\n\tu16 cmd, param0, param1;\n\tu16 resp0, res;\n\tvolatile int issued, issuing;\n\n\trefcount_t usecnt;\n\tint del_req;\n};\n\n \n#define HOSTAP_HW_NO_DISABLE BIT(0)\n#define HOSTAP_HW_ENABLE_CMDCOMPL BIT(1)\n\ntypedef struct local_info local_info_t;\n\nstruct prism2_helper_functions {\n\t \n\tint (*card_present)(local_info_t *local);\n\tvoid (*cor_sreset)(local_info_t *local);\n\tvoid (*genesis_reset)(local_info_t *local, int hcr);\n\n\t \n\n\t \n\tint (*cmd)(struct net_device *dev, u16 cmd, u16 param0, u16 *param1,\n\t\t   u16 *resp0);\n\tvoid (*read_regs)(struct net_device *dev, struct hfa384x_regs *regs);\n\tint (*get_rid)(struct net_device *dev, u16 rid, void *buf, int len,\n\t\t       int exact_len);\n\tint (*set_rid)(struct net_device *dev, u16 rid, void *buf, int len);\n\tint (*hw_enable)(struct net_device *dev, int initial);\n\tint (*hw_config)(struct net_device *dev, int initial);\n\tvoid (*hw_reset)(struct net_device *dev);\n\tvoid (*hw_shutdown)(struct net_device *dev, int no_disable);\n\tint (*reset_port)(struct net_device *dev);\n\tvoid (*schedule_reset)(local_info_t *local);\n\tint (*download)(local_info_t *local,\n\t\t\tstruct prism2_download_param *param);\n\tint (*tx)(struct sk_buff *skb, struct net_device *dev);\n\tint (*set_tim)(struct net_device *dev, int aid, int set);\n\tconst struct proc_ops *read_aux_proc_ops;\n\n\tint need_tx_headroom;  \n\tenum { HOSTAP_HW_PCCARD, HOSTAP_HW_PLX, HOSTAP_HW_PCI } hw_type;\n};\n\n\nstruct prism2_download_data {\n\tu32 dl_cmd;\n\tu32 start_addr;\n\tu32 num_areas;\n\tstruct prism2_download_data_area {\n\t\tu32 addr;  \n\t\tu32 len;\n\t\tu8 *data;  \n\t} data[];\n};\n\n\n#define HOSTAP_MAX_BSS_COUNT 64\n#define MAX_WPA_IE_LEN 64\n\nstruct hostap_bss_info {\n\tstruct list_head list;\n\tunsigned long last_update;\n\tunsigned int count;\n\tu8 bssid[ETH_ALEN];\n\tu16 capab_info;\n\tu8 ssid[32];\n\tsize_t ssid_len;\n\tu8 wpa_ie[MAX_WPA_IE_LEN];\n\tsize_t wpa_ie_len;\n\tu8 rsn_ie[MAX_WPA_IE_LEN];\n\tsize_t rsn_ie_len;\n\tint chan;\n\tint included;\n};\n\n\n \nstruct local_info {\n\tstruct module *hw_module;\n\tint card_idx;\n\tint dev_enabled;\n\tint master_dev_auto_open;  \n\tint num_dev_open;  \n\tstruct net_device *dev;  \n\tstruct net_device *ddev;  \n\tstruct list_head hostap_interfaces;  \n\trwlock_t iface_lock;  \n\tspinlock_t cmdlock, baplock, lock, irq_init_lock;\n\tstruct mutex rid_bap_mtx;\n\tu16 infofid;  \n\t \n\tspinlock_t txfidlock;\n\tint txfid_len;  \n\tu16 txfid[PRISM2_TXFID_COUNT];  \n\t \n\tu16 intransmitfid[PRISM2_TXFID_COUNT];\n\tint next_txfid;  \n\tint next_alloc;  \n\n\t \n#define HOSTAP_BITS_TRANSMIT 0\n#define HOSTAP_BITS_BAP_TASKLET 1\n#define HOSTAP_BITS_BAP_TASKLET2 2\n\tunsigned long bits;\n\n\tstruct ap_data *ap;\n\n\tchar essid[MAX_SSID_LEN + 1];\n\tchar name[MAX_NAME_LEN + 1];\n\tint name_set;\n\tu16 channel_mask;  \n\tu16 scan_channel_mask;  \n\tstruct comm_tallies_sums comm_tallies;\n\tstruct proc_dir_entry *proc;\n\tint iw_mode;  \n\tint pseudo_adhoc;  \n\tchar bssid[ETH_ALEN];\n\tint channel;\n\tint beacon_int;\n\tint dtim_period;\n\tint mtu;\n\tint frame_dump;  \n\tint fw_tx_rate_control;\n\tu16 tx_rate_control;\n\tu16 basic_rates;\n\tint hw_resetting;\n\tint hw_ready;\n\tint hw_reset_tries;  \n\tint hw_downloading;\n\tint shutdown;\n\tint pri_only;\n\tint no_pri;  \n\tint sram_type;  \n\n\tenum {\n\t\tPRISM2_TXPOWER_AUTO = 0, PRISM2_TXPOWER_OFF,\n\t\tPRISM2_TXPOWER_FIXED, PRISM2_TXPOWER_UNKNOWN\n\t} txpower_type;\n\tint txpower;  \n\n\t \n\tstruct list_head cmd_queue;\n\t \n#define HOSTAP_CMD_QUEUE_MAX_LEN 16\n\tint cmd_queue_len;  \n\n\t \n\tstruct work_struct reset_queue;\n\n\t \n\tint is_promisc;\n\tstruct work_struct set_multicast_list_queue;\n\n\tstruct work_struct set_tim_queue;\n\tstruct list_head set_tim_list;\n\tspinlock_t set_tim_lock;\n\n\tint wds_max_connections;\n\tint wds_connections;\n#define HOSTAP_WDS_BROADCAST_RA BIT(0)\n#define HOSTAP_WDS_AP_CLIENT BIT(1)\n#define HOSTAP_WDS_STANDARD_FRAME BIT(2)\n\tu32 wds_type;\n\tu16 tx_control;  \n\tint manual_retry_count;  \n\n\tstruct iw_statistics wstats;\n\tunsigned long scan_timestamp;  \n\tenum {\n\t\tPRISM2_MONITOR_80211 = 0, PRISM2_MONITOR_PRISM = 1,\n\t\tPRISM2_MONITOR_CAPHDR = 2, PRISM2_MONITOR_RADIOTAP = 3\n\t} monitor_type;\n\tint monitor_allow_fcserr;\n\n\tint hostapd;  \n\tint hostapd_sta;  \n\tstruct net_device *apdev;\n\tstruct net_device_stats apdevstats;\n\n\tchar assoc_ap_addr[ETH_ALEN];\n\tstruct net_device *stadev;\n\tstruct net_device_stats stadevstats;\n\n#define WEP_KEYS 4\n#define WEP_KEY_LEN 13\n\tstruct lib80211_crypt_info crypt_info;\n\n\tint open_wep;  \n\tint host_encrypt;\n\tint host_decrypt;\n\tint privacy_invoked;  \n\tint fw_encrypt_ok;  \n\tint bcrx_sta_key;  \n\n\tstruct prism2_frag_entry frag_cache[PRISM2_FRAG_CACHE_LEN];\n\tunsigned int frag_next_idx;\n\n\tint ieee_802_1x;  \n\n\tint antsel_tx, antsel_rx;\n\tint rts_threshold;  \n\tint fragm_threshold;  \n\tint auth_algs;  \n\n\tint enh_sec;  \n\tint tallies32;  \n\n\tstruct prism2_helper_functions *func;\n\n\tu8 *pda;\n\tint fw_ap;\n#define PRISM2_FW_VER(major, minor, variant) \\\n(((major) << 16) | ((minor) << 8) | variant)\n\tu32 sta_fw_ver;\n\n\t \n\tstruct tasklet_struct bap_tasklet;\n\n\tstruct tasklet_struct info_tasklet;\n\tstruct sk_buff_head info_list;  \n\n\tstruct hostap_tx_callback_info *tx_callback;  \n\n\tstruct tasklet_struct rx_tasklet;\n\tstruct sk_buff_head rx_list;\n\n\tstruct tasklet_struct sta_tx_exc_tasklet;\n\tstruct sk_buff_head sta_tx_exc_list;\n\n\tint host_roaming;\n\tunsigned long last_join_time;  \n\tstruct hfa384x_hostscan_result *last_scan_results;\n\tint last_scan_results_count;\n\tenum { PRISM2_SCAN, PRISM2_HOSTSCAN } last_scan_type;\n\tstruct work_struct info_queue;\n\tunsigned long pending_info;  \n#define PRISM2_INFO_PENDING_LINKSTATUS 0\n#define PRISM2_INFO_PENDING_SCANRESULTS 1\n\tint prev_link_status;  \n\tint prev_linkstatus_connected;\n\tu8 preferred_ap[ETH_ALEN];  \n\n#ifdef PRISM2_CALLBACK\n\tvoid *callback_data;  \n#endif  \n\n\twait_queue_head_t hostscan_wq;\n\n\t \n\tstruct timer_list passive_scan_timer;\n\tint passive_scan_interval;  \n\tint passive_scan_channel;\n\tenum { PASSIVE_SCAN_WAIT, PASSIVE_SCAN_LISTEN } passive_scan_state;\n\n\tstruct timer_list tick_timer;\n\tunsigned long last_tick_timer;\n\tunsigned int sw_tick_stuck;\n\n\t \n\tunsigned long last_comms_qual_update;\n\tint comms_qual;  \n\tint avg_signal;  \n\tint avg_noise;  \n\tstruct work_struct comms_qual_update;\n\n\t \n\tint rssi_to_dBm;  \n\n\t \n\tstruct list_head bss_list;\n\tint num_bss_info;\n\tint wpa;  \n\tint tkip_countermeasures;\n\tint drop_unencrypted;\n\t \n\tu8 *generic_elem;\n\tsize_t generic_elem_len;\n\n#ifdef PRISM2_DOWNLOAD_SUPPORT\n\t \n\tstruct prism2_download_data *dl_pri;\n\tstruct prism2_download_data *dl_sec;\n#endif  \n\n#ifdef PRISM2_IO_DEBUG\n#define PRISM2_IO_DEBUG_SIZE 10000\n\tu32 io_debug[PRISM2_IO_DEBUG_SIZE];\n\tint io_debug_head;\n\tint io_debug_enabled;\n#endif  \n\n\t \n\tvoid *hw_priv;\n};\n\n\n \nstruct hostap_interface {\n\tstruct list_head list;  \n\tstruct net_device *dev;  \n\tstruct local_info *local;  \n\tstruct net_device_stats stats;\n\tstruct iw_spy_data spy_data;  \n\tstruct iw_public_data wireless_data;\n\n\tenum {\n\t\tHOSTAP_INTERFACE_MASTER,\n\t\tHOSTAP_INTERFACE_MAIN,\n\t\tHOSTAP_INTERFACE_AP,\n\t\tHOSTAP_INTERFACE_STA,\n\t\tHOSTAP_INTERFACE_WDS,\n\t} type;\n\n\tunion {\n\t\tstruct hostap_interface_wds {\n\t\t\tu8 remote_addr[ETH_ALEN];\n\t\t} wds;\n\t} u;\n};\n\n\n#define HOSTAP_SKB_TX_DATA_MAGIC 0xf08a36a2\n\n \nstruct hostap_skb_tx_data {\n\tunsigned int __padding_for_default_qdiscs;\n\tu32 magic;  \n\tu8 rate;  \n#define HOSTAP_TX_FLAGS_WDS BIT(0)\n#define HOSTAP_TX_FLAGS_BUFFERED_FRAME BIT(1)\n#define HOSTAP_TX_FLAGS_ADD_MOREDATA BIT(2)\n\tu8 flags;  \n\tu16 tx_cb_idx;\n\tstruct hostap_interface *iface;\n\tunsigned long jiffies;  \n\tunsigned short ethertype;\n};\n\n\n#ifndef PRISM2_NO_DEBUG\n\n#define DEBUG_FID BIT(0)\n#define DEBUG_PS BIT(1)\n#define DEBUG_FLOW BIT(2)\n#define DEBUG_AP BIT(3)\n#define DEBUG_HW BIT(4)\n#define DEBUG_EXTRA BIT(5)\n#define DEBUG_EXTRA2 BIT(6)\n#define DEBUG_PS2 BIT(7)\n#define DEBUG_MASK (DEBUG_PS | DEBUG_AP | DEBUG_HW | DEBUG_EXTRA)\n#define PDEBUG(n, args...) \\\ndo { if ((n) & DEBUG_MASK) printk(KERN_DEBUG args); } while (0)\n#define PDEBUG2(n, args...) \\\ndo { if ((n) & DEBUG_MASK) printk(args); } while (0)\n\n#else  \n\n#define PDEBUG(n, args...)\n#define PDEBUG2(n, args...)\n\n#endif  \n\nenum { BAP0 = 0, BAP1 = 1 };\n\n#define PRISM2_IO_DEBUG_CMD_INB 0\n#define PRISM2_IO_DEBUG_CMD_INW 1\n#define PRISM2_IO_DEBUG_CMD_INSW 2\n#define PRISM2_IO_DEBUG_CMD_OUTB 3\n#define PRISM2_IO_DEBUG_CMD_OUTW 4\n#define PRISM2_IO_DEBUG_CMD_OUTSW 5\n#define PRISM2_IO_DEBUG_CMD_ERROR 6\n#define PRISM2_IO_DEBUG_CMD_INTERRUPT 7\n\n#ifdef PRISM2_IO_DEBUG\n\n#define PRISM2_IO_DEBUG_ENTRY(cmd, reg, value) \\\n(((cmd) << 24) | ((reg) << 16) | value)\n\nstatic inline void prism2_io_debug_add(struct net_device *dev, int cmd,\n\t\t\t\t       int reg, int value)\n{\n\tstruct hostap_interface *iface = netdev_priv(dev);\n\tlocal_info_t *local = iface->local;\n\n\tif (!local->io_debug_enabled)\n\t\treturn;\n\n\tlocal->io_debug[local->io_debug_head] =\tjiffies & 0xffffffff;\n\tif (++local->io_debug_head >= PRISM2_IO_DEBUG_SIZE)\n\t\tlocal->io_debug_head = 0;\n\tlocal->io_debug[local->io_debug_head] =\n\t\tPRISM2_IO_DEBUG_ENTRY(cmd, reg, value);\n\tif (++local->io_debug_head >= PRISM2_IO_DEBUG_SIZE)\n\t\tlocal->io_debug_head = 0;\n}\n\n\nstatic inline void prism2_io_debug_error(struct net_device *dev, int err)\n{\n\tstruct hostap_interface *iface = netdev_priv(dev);\n\tlocal_info_t *local = iface->local;\n\tunsigned long flags;\n\n\tif (!local->io_debug_enabled)\n\t\treturn;\n\n\tspin_lock_irqsave(&local->lock, flags);\n\tprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_ERROR, 0, err);\n\tif (local->io_debug_enabled == 1) {\n\t\tlocal->io_debug_enabled = 0;\n\t\tprintk(KERN_DEBUG \"%s: I/O debug stopped\\n\", dev->name);\n\t}\n\tspin_unlock_irqrestore(&local->lock, flags);\n}\n\n#else  \n\nstatic inline void prism2_io_debug_add(struct net_device *dev, int cmd,\n\t\t\t\t       int reg, int value)\n{\n}\n\nstatic inline void prism2_io_debug_error(struct net_device *dev, int err)\n{\n}\n\n#endif  \n\n\n#ifdef PRISM2_CALLBACK\nenum {\n\t \n\tPRISM2_CALLBACK_ENABLE,\n\n\t \n\tPRISM2_CALLBACK_DISABLE,\n\n\t \n\tPRISM2_CALLBACK_RX_START, PRISM2_CALLBACK_RX_END,\n\tPRISM2_CALLBACK_TX_START, PRISM2_CALLBACK_TX_END\n};\nvoid prism2_callback(local_info_t *local, int event);\n#else  \n#define prism2_callback(d, e) do { } while (0)\n#endif  \n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}