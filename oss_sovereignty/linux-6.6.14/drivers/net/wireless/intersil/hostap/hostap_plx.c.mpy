{
  "module_name": "hostap_plx.c",
  "hash_id": "9add9e6fe4682598bdfb2e6e47faa5e35743f4ed70ec0534f715fa664ab40c11",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/hostap/hostap_plx.c",
  "human_readable_source": "\n#define PRISM2_PLX\n\n \n\n\n#include <linux/module.h>\n#include <linux/if.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/wireless.h>\n#include <net/iw_handler.h>\n\n#include <linux/ioport.h>\n#include <linux/pci.h>\n#include <asm/io.h>\n\n#include \"hostap_wlan.h\"\n\n\nstatic char *dev_info = \"hostap_plx\";\n\n\nMODULE_AUTHOR(\"Jouni Malinen\");\nMODULE_DESCRIPTION(\"Support for Intersil Prism2-based 802.11 wireless LAN \"\n\t\t   \"cards (PLX).\");\nMODULE_LICENSE(\"GPL\");\n\n\nstatic int ignore_cis;\nmodule_param(ignore_cis, int, 0444);\nMODULE_PARM_DESC(ignore_cis, \"Do not verify manfid information in CIS\");\n\n\n \nstruct hostap_plx_priv {\n\tvoid __iomem *attr_mem;\n\tunsigned int cor_offset;\n};\n\n\n#define PLX_MIN_ATTR_LEN 512\t \n#define COR_SRESET       0x80\n#define COR_LEVLREQ      0x40\n#define COR_ENABLE_FUNC  0x01\n \n#define PLX_PCIIPR       0x3d    \n \n#define PLX_INTCSR       0x4c    \n#define PLX_INTCSR_PCI_INTEN BIT(6)  \n#define PLX_CNTRL        0x50\n#define PLX_CNTRL_SERIAL_EEPROM_PRESENT BIT(28)\n\n\n#define PLXDEV(vendor,dev,str) { vendor, dev, PCI_ANY_ID, PCI_ANY_ID }\n\nstatic const struct pci_device_id prism2_plx_id_table[] = {\n\tPLXDEV(0x10b7, 0x7770, \"3Com AirConnect PCI 777A\"),\n\tPLXDEV(0x111a, 0x1023, \"Siemens SpeedStream SS1023\"),\n\tPLXDEV(0x126c, 0x8030, \"Nortel emobility\"),\n\tPLXDEV(0x1562, 0x0001, \"Symbol LA-4123\"),\n\tPLXDEV(0x1385, 0x4100, \"Netgear MA301\"),\n\tPLXDEV(0x15e8, 0x0130, \"National Datacomm NCP130 (PLX9052)\"),\n\tPLXDEV(0x15e8, 0x0131, \"National Datacomm NCP130 (TMD7160)\"),\n\tPLXDEV(0x1638, 0x1100, \"Eumitcom WL11000\"),\n\tPLXDEV(0x16ab, 0x1100, \"Global Sun Tech GL24110P\"),\n\tPLXDEV(0x16ab, 0x1101, \"Global Sun Tech GL24110P (?)\"),\n\tPLXDEV(0x16ab, 0x1102, \"Linksys WPC11 with WDT11\"),\n\tPLXDEV(0x16ab, 0x1103, \"Longshine 8031\"),\n\tPLXDEV(0x16ec, 0x3685, \"US Robotics USR2415\"),\n\tPLXDEV(0xec80, 0xec00, \"Belkin F5D6000\"),\n\t{ 0 }\n};\n\n\n \nstatic struct prism2_plx_manfid {\n\tu16 manfid1, manfid2;\n} prism2_plx_known_manfids[] = {\n\t{ 0x000b, 0x7110 }  ,\n\t{ 0x000b, 0x7300 }  ,\n\t{ 0x0101, 0x0777 }  ,\n\t{ 0x0126, 0x8000 }  ,\n\t{ 0x0138, 0x0002 }  ,\n\t{ 0x0156, 0x0002 }  ,\n\t{ 0x026f, 0x030b }  ,\n\t{ 0x0274, 0x1612 }  ,\n\t{ 0x0274, 0x1613 }  ,\n\t{ 0x028a, 0x0002 }  ,\n\t{ 0x0250, 0x0002 }  ,\n\t{ 0xc250, 0x0002 }  ,\n\t{ 0xd601, 0x0002 }  ,\n\t{ 0xd601, 0x0005 }  ,\n\t{ 0, 0}\n};\n\n\n#ifdef PRISM2_IO_DEBUG\n\nstatic inline void hfa384x_outb_debug(struct net_device *dev, int a, u8 v)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tunsigned long flags;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tspin_lock_irqsave(&local->lock, flags);\n\tprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_OUTB, a, v);\n\toutb(v, dev->base_addr + a);\n\tspin_unlock_irqrestore(&local->lock, flags);\n}\n\nstatic inline u8 hfa384x_inb_debug(struct net_device *dev, int a)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tunsigned long flags;\n\tu8 v;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tspin_lock_irqsave(&local->lock, flags);\n\tv = inb(dev->base_addr + a);\n\tprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_INB, a, v);\n\tspin_unlock_irqrestore(&local->lock, flags);\n\treturn v;\n}\n\nstatic inline void hfa384x_outw_debug(struct net_device *dev, int a, u16 v)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tunsigned long flags;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tspin_lock_irqsave(&local->lock, flags);\n\tprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_OUTW, a, v);\n\toutw(v, dev->base_addr + a);\n\tspin_unlock_irqrestore(&local->lock, flags);\n}\n\nstatic inline u16 hfa384x_inw_debug(struct net_device *dev, int a)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tunsigned long flags;\n\tu16 v;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tspin_lock_irqsave(&local->lock, flags);\n\tv = inw(dev->base_addr + a);\n\tprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_INW, a, v);\n\tspin_unlock_irqrestore(&local->lock, flags);\n\treturn v;\n}\n\nstatic inline void hfa384x_outsw_debug(struct net_device *dev, int a,\n\t\t\t\t       u8 *buf, int wc)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tunsigned long flags;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tspin_lock_irqsave(&local->lock, flags);\n\tprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_OUTSW, a, wc);\n\toutsw(dev->base_addr + a, buf, wc);\n\tspin_unlock_irqrestore(&local->lock, flags);\n}\n\nstatic inline void hfa384x_insw_debug(struct net_device *dev, int a,\n\t\t\t\t      u8 *buf, int wc)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tunsigned long flags;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tspin_lock_irqsave(&local->lock, flags);\n\tprism2_io_debug_add(dev, PRISM2_IO_DEBUG_CMD_INSW, a, wc);\n\tinsw(dev->base_addr + a, buf, wc);\n\tspin_unlock_irqrestore(&local->lock, flags);\n}\n\n#define HFA384X_OUTB(v,a) hfa384x_outb_debug(dev, (a), (v))\n#define HFA384X_INB(a) hfa384x_inb_debug(dev, (a))\n#define HFA384X_OUTW(v,a) hfa384x_outw_debug(dev, (a), (v))\n#define HFA384X_INW(a) hfa384x_inw_debug(dev, (a))\n#define HFA384X_OUTSW(a, buf, wc) hfa384x_outsw_debug(dev, (a), (buf), (wc))\n#define HFA384X_INSW(a, buf, wc) hfa384x_insw_debug(dev, (a), (buf), (wc))\n\n#else  \n\n#define HFA384X_OUTB(v,a) outb((v), dev->base_addr + (a))\n#define HFA384X_INB(a) inb(dev->base_addr + (a))\n#define HFA384X_OUTW(v,a) outw((v), dev->base_addr + (a))\n#define HFA384X_INW(a) inw(dev->base_addr + (a))\n#define HFA384X_INSW(a, buf, wc) insw(dev->base_addr + (a), buf, wc)\n#define HFA384X_OUTSW(a, buf, wc) outsw(dev->base_addr + (a), buf, wc)\n\n#endif  \n\n\nstatic int hfa384x_from_bap(struct net_device *dev, u16 bap, void *buf,\n\t\t\t    int len)\n{\n\tu16 d_off;\n\tu16 *pos;\n\n\td_off = (bap == 1) ? HFA384X_DATA1_OFF : HFA384X_DATA0_OFF;\n\tpos = (u16 *) buf;\n\n\tif (len / 2)\n\t\tHFA384X_INSW(d_off, buf, len / 2);\n\tpos += len / 2;\n\n\tif (len & 1)\n\t\t*((char *) pos) = HFA384X_INB(d_off);\n\n\treturn 0;\n}\n\n\nstatic int hfa384x_to_bap(struct net_device *dev, u16 bap, void *buf, int len)\n{\n\tu16 d_off;\n\tu16 *pos;\n\n\td_off = (bap == 1) ? HFA384X_DATA1_OFF : HFA384X_DATA0_OFF;\n\tpos = (u16 *) buf;\n\n\tif (len / 2)\n\t\tHFA384X_OUTSW(d_off, buf, len / 2);\n\tpos += len / 2;\n\n\tif (len & 1)\n\t\tHFA384X_OUTB(*((char *) pos), d_off);\n\n\treturn 0;\n}\n\n\n \n#include \"hostap_hw.c\"\n\n\nstatic void prism2_plx_cor_sreset(local_info_t *local)\n{\n\tunsigned char corsave;\n\tstruct hostap_plx_priv *hw_priv = local->hw_priv;\n\n\tprintk(KERN_DEBUG \"%s: Doing reset via direct COR access.\\n\",\n\t       dev_info);\n\n\t \n\n\tif (hw_priv->attr_mem == NULL) {\n\t\t \n\t\tcorsave = inb(hw_priv->cor_offset);\n\t\toutb(corsave | COR_SRESET, hw_priv->cor_offset);\n\t\tmdelay(2);\n\t\toutb(corsave & ~COR_SRESET, hw_priv->cor_offset);\n\t\tmdelay(2);\n\t} else {\n\t\t \n\t\tcorsave = readb(hw_priv->attr_mem + hw_priv->cor_offset);\n\t\twriteb(corsave | COR_SRESET,\n\t\t       hw_priv->attr_mem + hw_priv->cor_offset);\n\t\tmdelay(2);\n\t\twriteb(corsave & ~COR_SRESET,\n\t\t       hw_priv->attr_mem + hw_priv->cor_offset);\n\t\tmdelay(2);\n\t}\n}\n\n\nstatic void prism2_plx_genesis_reset(local_info_t *local, int hcr)\n{\n\tunsigned char corsave;\n\tstruct hostap_plx_priv *hw_priv = local->hw_priv;\n\n\tif (hw_priv->attr_mem == NULL) {\n\t\t \n\t\tcorsave = inb(hw_priv->cor_offset);\n\t\toutb(corsave | COR_SRESET, hw_priv->cor_offset);\n\t\tmdelay(10);\n\t\toutb(hcr, hw_priv->cor_offset + 2);\n\t\tmdelay(10);\n\t\toutb(corsave & ~COR_SRESET, hw_priv->cor_offset);\n\t\tmdelay(10);\n\t} else {\n\t\t \n\t\tcorsave = readb(hw_priv->attr_mem + hw_priv->cor_offset);\n\t\twriteb(corsave | COR_SRESET,\n\t\t       hw_priv->attr_mem + hw_priv->cor_offset);\n\t\tmdelay(10);\n\t\twriteb(hcr, hw_priv->attr_mem + hw_priv->cor_offset + 2);\n\t\tmdelay(10);\n\t\twriteb(corsave & ~COR_SRESET,\n\t\t       hw_priv->attr_mem + hw_priv->cor_offset);\n\t\tmdelay(10);\n\t}\n}\n\n\nstatic struct prism2_helper_functions prism2_plx_funcs =\n{\n\t.card_present\t= NULL,\n\t.cor_sreset\t= prism2_plx_cor_sreset,\n\t.genesis_reset\t= prism2_plx_genesis_reset,\n\t.hw_type\t= HOSTAP_HW_PLX,\n};\n\n\nstatic int prism2_plx_check_cis(void __iomem *attr_mem, int attr_len,\n\t\t\t\tunsigned int *cor_offset,\n\t\t\t\tunsigned int *cor_index)\n{\n#define CISTPL_CONFIG 0x1A\n#define CISTPL_MANFID 0x20\n#define CISTPL_END 0xFF\n#define CIS_MAX_LEN 256\n\tu8 *cis;\n\tint i, pos;\n\tunsigned int rmsz, rasz, manfid1, manfid2;\n\tstruct prism2_plx_manfid *manfid;\n\n\tcis = kmalloc(CIS_MAX_LEN, GFP_KERNEL);\n\tif (cis == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < CIS_MAX_LEN; i++)\n\t\tcis[i] = readb(attr_mem + 2 * i);\n\tprintk(KERN_DEBUG \"%s: CIS: %6ph ...\\n\", dev_info, cis);\n\n\t \n\t*cor_offset = 0x3e0;\n\t*cor_index = 0x01;\n\tmanfid1 = manfid2 = 0;\n\n\tpos = 0;\n\twhile (pos < CIS_MAX_LEN - 1 && cis[pos] != CISTPL_END) {\n\t\tif (pos + 2 + cis[pos + 1] > CIS_MAX_LEN)\n\t\t\tgoto cis_error;\n\n\t\tswitch (cis[pos]) {\n\t\tcase CISTPL_CONFIG:\n\t\t\tif (cis[pos + 1] < 2)\n\t\t\t\tgoto cis_error;\n\t\t\trmsz = (cis[pos + 2] & 0x3c) >> 2;\n\t\t\trasz = cis[pos + 2] & 0x03;\n\t\t\tif (4 + rasz + rmsz > cis[pos + 1])\n\t\t\t\tgoto cis_error;\n\t\t\t*cor_index = cis[pos + 3] & 0x3F;\n\t\t\t*cor_offset = 0;\n\t\t\tfor (i = 0; i <= rasz; i++)\n\t\t\t\t*cor_offset += cis[pos + 4 + i] << (8 * i);\n\t\t\tprintk(KERN_DEBUG \"%s: cor_index=0x%x \"\n\t\t\t       \"cor_offset=0x%x\\n\", dev_info,\n\t\t\t       *cor_index, *cor_offset);\n\t\t\tif (*cor_offset > attr_len) {\n\t\t\t\tprintk(KERN_ERR \"%s: COR offset not within \"\n\t\t\t\t       \"attr_mem\\n\", dev_info);\n\t\t\t\tkfree(cis);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase CISTPL_MANFID:\n\t\t\tif (cis[pos + 1] < 4)\n\t\t\t\tgoto cis_error;\n\t\t\tmanfid1 = cis[pos + 2] + (cis[pos + 3] << 8);\n\t\t\tmanfid2 = cis[pos + 4] + (cis[pos + 5] << 8);\n\t\t\tprintk(KERN_DEBUG \"%s: manfid=0x%04x, 0x%04x\\n\",\n\t\t\t       dev_info, manfid1, manfid2);\n\t\t\tbreak;\n\t\t}\n\n\t\tpos += cis[pos + 1] + 2;\n\t}\n\n\tif (pos >= CIS_MAX_LEN || cis[pos] != CISTPL_END)\n\t\tgoto cis_error;\n\n\tfor (manfid = prism2_plx_known_manfids; manfid->manfid1 != 0; manfid++)\n\t\tif (manfid1 == manfid->manfid1 && manfid2 == manfid->manfid2) {\n\t\t\tkfree(cis);\n\t\t\treturn 0;\n\t\t}\n\n\tprintk(KERN_INFO \"%s: unknown manfid 0x%04x, 0x%04x - assuming this is\"\n\t       \" not supported card\\n\", dev_info, manfid1, manfid2);\n\tgoto fail;\n\n cis_error:\n\tprintk(KERN_WARNING \"%s: invalid CIS data\\n\", dev_info);\n\n fail:\n\tkfree(cis);\n\tif (ignore_cis) {\n\t\tprintk(KERN_INFO \"%s: ignore_cis parameter set - ignoring \"\n\t\t       \"errors during CIS verification\\n\", dev_info);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\n\nstatic int prism2_plx_probe(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *id)\n{\n\tunsigned int pccard_ioaddr, plx_ioaddr;\n\tunsigned long pccard_attr_mem;\n\tunsigned int pccard_attr_len;\n\tvoid __iomem *attr_mem = NULL;\n\tunsigned int cor_offset = 0, cor_index = 0;\n\tu32 reg;\n\tlocal_info_t *local = NULL;\n\tstruct net_device *dev = NULL;\n\tstruct hostap_interface *iface;\n\tstatic int cards_found  ;\n\tint irq_registered = 0;\n\tint tmd7160;\n\tstruct hostap_plx_priv *hw_priv;\n\n\thw_priv = kzalloc(sizeof(*hw_priv), GFP_KERNEL);\n\tif (hw_priv == NULL)\n\t\treturn -ENOMEM;\n\n\tif (pci_enable_device(pdev))\n\t\tgoto err_out_free;\n\n\t \n\ttmd7160 = (pdev->vendor == 0x15e8) && (pdev->device == 0x0131);\n\n\tplx_ioaddr = pci_resource_start(pdev, 1);\n\tpccard_ioaddr = pci_resource_start(pdev, tmd7160 ? 2 : 3);\n\n\tif (tmd7160) {\n\t\t \n\t\tattr_mem = NULL;  \n\n\t\tprintk(KERN_INFO \"TMD7160 PCI/PCMCIA adapter: io=0x%x, \"\n\t\t       \"irq=%d, pccard_io=0x%x\\n\",\n\t\t       plx_ioaddr, pdev->irq, pccard_ioaddr);\n\n\t\tcor_offset = plx_ioaddr;\n\t\tcor_index = 0x04;\n\n\t\toutb(cor_index | COR_LEVLREQ | COR_ENABLE_FUNC, plx_ioaddr);\n\t\tmdelay(1);\n\t\treg = inb(plx_ioaddr);\n\t\tif (reg != (cor_index | COR_LEVLREQ | COR_ENABLE_FUNC)) {\n\t\t\tprintk(KERN_ERR \"%s: Error setting COR (expected=\"\n\t\t\t       \"0x%02x, was=0x%02x)\\n\", dev_info,\n\t\t\t       cor_index | COR_LEVLREQ | COR_ENABLE_FUNC, reg);\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\t \n\t\tpccard_attr_mem = pci_resource_start(pdev, 2);\n\t\tpccard_attr_len = pci_resource_len(pdev, 2);\n\t\tif (pccard_attr_len < PLX_MIN_ATTR_LEN)\n\t\t\tgoto fail;\n\n\n\t\tattr_mem = ioremap(pccard_attr_mem, pccard_attr_len);\n\t\tif (attr_mem == NULL) {\n\t\t\tprintk(KERN_ERR \"%s: cannot remap attr_mem\\n\",\n\t\t\t       dev_info);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tprintk(KERN_INFO \"PLX9052 PCI/PCMCIA adapter: \"\n\t\t       \"mem=0x%lx, plx_io=0x%x, irq=%d, pccard_io=0x%x\\n\",\n\t\t       pccard_attr_mem, plx_ioaddr, pdev->irq, pccard_ioaddr);\n\n\t\tif (prism2_plx_check_cis(attr_mem, pccard_attr_len,\n\t\t\t\t\t &cor_offset, &cor_index)) {\n\t\t\tprintk(KERN_INFO \"Unknown PC Card CIS - not a \"\n\t\t\t       \"Prism2/2.5 card?\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tprintk(KERN_DEBUG \"Prism2/2.5 PC Card detected in PLX9052 \"\n\t\t       \"adapter\\n\");\n\n\t\t \n\t\twriteb(cor_index | COR_LEVLREQ | COR_ENABLE_FUNC,\n\t\t       attr_mem + cor_offset);\n\n\t\t \n\t\treg = inl(plx_ioaddr + PLX_INTCSR);\n\t\tprintk(KERN_DEBUG \"PLX_INTCSR=0x%x\\n\", reg);\n\t\tif (!(reg & PLX_INTCSR_PCI_INTEN)) {\n\t\t\toutl(reg | PLX_INTCSR_PCI_INTEN,\n\t\t\t     plx_ioaddr + PLX_INTCSR);\n\t\t\tif (!(inl(plx_ioaddr + PLX_INTCSR) &\n\t\t\t      PLX_INTCSR_PCI_INTEN)) {\n\t\t\t\tprintk(KERN_WARNING \"%s: Could not enable \"\n\t\t\t\t       \"Local Interrupts\\n\", dev_info);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\n\t\treg = inl(plx_ioaddr + PLX_CNTRL);\n\t\tprintk(KERN_DEBUG \"PLX_CNTRL=0x%x (Serial EEPROM \"\n\t\t       \"present=%d)\\n\",\n\t\t       reg, (reg & PLX_CNTRL_SERIAL_EEPROM_PRESENT) != 0);\n\t\t \n\t}\n\n\tdev = prism2_init_local_data(&prism2_plx_funcs, cards_found,\n\t\t\t\t     &pdev->dev);\n\tif (dev == NULL)\n\t\tgoto fail;\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\tlocal->hw_priv = hw_priv;\n\tcards_found++;\n\n\tdev->irq = pdev->irq;\n\tdev->base_addr = pccard_ioaddr;\n\thw_priv->attr_mem = attr_mem;\n\thw_priv->cor_offset = cor_offset;\n\n\tpci_set_drvdata(pdev, dev);\n\n\tif (request_irq(dev->irq, prism2_interrupt, IRQF_SHARED, dev->name,\n\t\t\tdev)) {\n\t\tprintk(KERN_WARNING \"%s: request_irq failed\\n\", dev->name);\n\t\tgoto fail;\n\t} else\n\t\tirq_registered = 1;\n\n\tif (prism2_hw_config(dev, 1)) {\n\t\tprintk(KERN_DEBUG \"%s: hardware initialization failed\\n\",\n\t\t       dev_info);\n\t\tgoto fail;\n\t}\n\n\treturn hostap_hw_ready(dev);\n\n fail:\n\tif (irq_registered && dev)\n\t\tfree_irq(dev->irq, dev);\n\n\tif (attr_mem)\n\t\tiounmap(attr_mem);\n\n\tpci_disable_device(pdev);\n\tprism2_free_local_data(dev);\n\n err_out_free:\n\tkfree(hw_priv);\n\n\treturn -ENODEV;\n}\n\n\nstatic void prism2_plx_remove(struct pci_dev *pdev)\n{\n\tstruct net_device *dev;\n\tstruct hostap_interface *iface;\n\tstruct hostap_plx_priv *hw_priv;\n\n\tdev = pci_get_drvdata(pdev);\n\tiface = netdev_priv(dev);\n\thw_priv = iface->local->hw_priv;\n\n\t \n\tprism2_plx_cor_sreset(iface->local);\n\thfa384x_disable_interrupts(dev);\n\n\tif (hw_priv->attr_mem)\n\t\tiounmap(hw_priv->attr_mem);\n\tif (dev->irq)\n\t\tfree_irq(dev->irq, dev);\n\n\tprism2_free_local_data(dev);\n\tkfree(hw_priv);\n\tpci_disable_device(pdev);\n}\n\n\nMODULE_DEVICE_TABLE(pci, prism2_plx_id_table);\n\nstatic struct pci_driver prism2_plx_driver = {\n\t.name\t\t= \"hostap_plx\",\n\t.id_table\t= prism2_plx_id_table,\n\t.probe\t\t= prism2_plx_probe,\n\t.remove\t\t= prism2_plx_remove,\n};\n\nmodule_pci_driver(prism2_plx_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}