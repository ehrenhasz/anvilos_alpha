{
  "module_name": "hostap_ioctl.c",
  "hash_id": "be32d4dbb49c117cc2b56184f594d70cf589c13ebba9c7695d80401bae501c60",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/hostap/hostap_ioctl.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/sched/signal.h>\n#include <linux/ethtool.h>\n#include <linux/if_arp.h>\n#include <linux/module.h>\n#include <linux/etherdevice.h>\n#include <net/lib80211.h>\n\n#include \"hostap_wlan.h\"\n#include \"hostap.h\"\n#include \"hostap_ap.h\"\n\nstatic struct iw_statistics *hostap_get_wireless_stats(struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tstruct iw_statistics *wstats;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\t \n\tif (iface->type != HOSTAP_INTERFACE_MAIN)\n\t\treturn NULL;\n\n\twstats = &local->wstats;\n\n\twstats->status = 0;\n\twstats->discard.code =\n\t\tlocal->comm_tallies.rx_discards_wep_undecryptable;\n\twstats->discard.misc =\n\t\tlocal->comm_tallies.rx_fcs_errors +\n\t\tlocal->comm_tallies.rx_discards_no_buffer +\n\t\tlocal->comm_tallies.tx_discards_wrong_sa;\n\n\twstats->discard.retries =\n\t\tlocal->comm_tallies.tx_retry_limit_exceeded;\n\twstats->discard.fragment =\n\t\tlocal->comm_tallies.rx_message_in_bad_msg_fragments;\n\n\tif (local->iw_mode != IW_MODE_MASTER &&\n\t    local->iw_mode != IW_MODE_REPEAT) {\n\n\t\tif (prism2_update_comms_qual(dev) == 0)\n\t\t\twstats->qual.updated = IW_QUAL_ALL_UPDATED |\n\t\t\t\tIW_QUAL_DBM;\n\n\t\twstats->qual.qual = local->comms_qual;\n\t\twstats->qual.level = local->avg_signal;\n\t\twstats->qual.noise = local->avg_noise;\n\t} else {\n\t\twstats->qual.qual = 0;\n\t\twstats->qual.level = 0;\n\t\twstats->qual.noise = 0;\n\t\twstats->qual.updated = IW_QUAL_ALL_INVALID;\n\t}\n\n\treturn wstats;\n}\n\n\nstatic int prism2_get_datarates(struct net_device *dev, u8 *rates)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tu8 buf[12];\n\tint len;\n\tu16 val;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tlen = local->func->get_rid(dev, HFA384X_RID_SUPPORTEDDATARATES, buf,\n\t\t\t\t   sizeof(buf), 0);\n\tif (len < 2)\n\t\treturn 0;\n\n\tval = le16_to_cpu(*(__le16 *) buf);  \n\n\tif (len - 2 < val || val > 10)\n\t\treturn 0;\n\n\tmemcpy(rates, buf + 2, val);\n\treturn val;\n}\n\n\nstatic int prism2_get_name(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tu8 rates[10];\n\tint len, i, over2 = 0;\n\n\tlen = prism2_get_datarates(dev, rates);\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (rates[i] == 0x0b || rates[i] == 0x16) {\n\t\t\tover2 = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstrcpy(wrqu->name, over2 ? \"IEEE 802.11b\" : \"IEEE 802.11-DS\");\n\n\treturn 0;\n}\n\n\nstatic int prism2_ioctl_siwencode(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *keybuf)\n{\n\tstruct iw_point *erq = &wrqu->encoding;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint i;\n\tstruct lib80211_crypt_data **crypt;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\ti = erq->flags & IW_ENCODE_INDEX;\n\tif (i < 1 || i > 4)\n\t\ti = local->crypt_info.tx_keyidx;\n\telse\n\t\ti--;\n\tif (i < 0 || i >= WEP_KEYS)\n\t\treturn -EINVAL;\n\n\tcrypt = &local->crypt_info.crypt[i];\n\n\tif (erq->flags & IW_ENCODE_DISABLED) {\n\t\tif (*crypt)\n\t\t\tlib80211_crypt_delayed_deinit(&local->crypt_info, crypt);\n\t\tgoto done;\n\t}\n\n\tif (*crypt != NULL && (*crypt)->ops != NULL &&\n\t    strcmp((*crypt)->ops->name, \"WEP\") != 0) {\n\t\t \n\t\tlib80211_crypt_delayed_deinit(&local->crypt_info, crypt);\n\t}\n\n\tif (*crypt == NULL) {\n\t\tstruct lib80211_crypt_data *new_crypt;\n\n\t\t \n\t\tnew_crypt = kzalloc(sizeof(struct lib80211_crypt_data),\n\t\t\t\tGFP_KERNEL);\n\t\tif (new_crypt == NULL)\n\t\t\treturn -ENOMEM;\n\t\tnew_crypt->ops = lib80211_get_crypto_ops(\"WEP\");\n\t\tif (!new_crypt->ops) {\n\t\t\trequest_module(\"lib80211_crypt_wep\");\n\t\t\tnew_crypt->ops = lib80211_get_crypto_ops(\"WEP\");\n\t\t}\n\t\tif (new_crypt->ops && try_module_get(new_crypt->ops->owner))\n\t\t\tnew_crypt->priv = new_crypt->ops->init(i);\n\t\tif (!new_crypt->ops || !new_crypt->priv) {\n\t\t\tkfree(new_crypt);\n\t\t\tnew_crypt = NULL;\n\n\t\t\tprintk(KERN_WARNING \"%s: could not initialize WEP: \"\n\t\t\t       \"load module hostap_crypt_wep.o\\n\",\n\t\t\t       dev->name);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\t*crypt = new_crypt;\n\t}\n\n\tif (erq->length > 0) {\n\t\tint len = erq->length <= 5 ? 5 : 13;\n\t\tint first = 1, j;\n\t\tif (len > erq->length)\n\t\t\tmemset(keybuf + erq->length, 0, len - erq->length);\n\t\t(*crypt)->ops->set_key(keybuf, len, NULL, (*crypt)->priv);\n\t\tfor (j = 0; j < WEP_KEYS; j++) {\n\t\t\tif (j != i && local->crypt_info.crypt[j]) {\n\t\t\t\tfirst = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (first)\n\t\t\tlocal->crypt_info.tx_keyidx = i;\n\t} else {\n\t\t \n\t\tlocal->crypt_info.tx_keyidx = i;\n\t}\n\n done:\n\tlocal->open_wep = erq->flags & IW_ENCODE_OPEN;\n\n\tif (hostap_set_encryption(local)) {\n\t\tprintk(KERN_DEBUG \"%s: set_encryption failed\\n\", dev->name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (local->iw_mode != IW_MODE_INFRA && local->func->reset_port(dev)) {\n\t\tprintk(KERN_DEBUG \"%s: reset_port failed\\n\", dev->name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int prism2_ioctl_giwencode(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *key)\n{\n\tstruct iw_point *erq = &wrqu->encoding;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint i, len;\n\tu16 val;\n\tstruct lib80211_crypt_data *crypt;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\ti = erq->flags & IW_ENCODE_INDEX;\n\tif (i < 1 || i > 4)\n\t\ti = local->crypt_info.tx_keyidx;\n\telse\n\t\ti--;\n\tif (i < 0 || i >= WEP_KEYS)\n\t\treturn -EINVAL;\n\n\tcrypt = local->crypt_info.crypt[i];\n\terq->flags = i + 1;\n\n\tif (crypt == NULL || crypt->ops == NULL) {\n\t\terq->length = 0;\n\t\terq->flags |= IW_ENCODE_DISABLED;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(crypt->ops->name, \"WEP\") != 0) {\n\t\t \n\t\terq->length = 0;\n\t\terq->flags |= IW_ENCODE_ENABLED;\n\t\treturn 0;\n\t}\n\n\t \n\tlen = crypt->ops->get_key(key, WEP_KEY_LEN, NULL, crypt->priv);\n\terq->length = (len >= 0 ? len : 0);\n\n\tif (local->func->get_rid(dev, HFA384X_RID_CNFWEPFLAGS, &val, 2, 1) < 0)\n\t{\n\t\tprintk(\"CNFWEPFLAGS reading failed\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tle16_to_cpus(&val);\n\tif (val & HFA384X_WEPFLAGS_PRIVACYINVOKED)\n\t\terq->flags |= IW_ENCODE_ENABLED;\n\telse\n\t\terq->flags |= IW_ENCODE_DISABLED;\n\tif (val & HFA384X_WEPFLAGS_EXCLUDEUNENCRYPTED)\n\t\terq->flags |= IW_ENCODE_RESTRICTED;\n\telse\n\t\terq->flags |= IW_ENCODE_OPEN;\n\n\treturn 0;\n}\n\n\nstatic int hostap_set_rate(struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint ret, basic_rates;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tbasic_rates = local->basic_rates & local->tx_rate_control;\n\tif (!basic_rates || basic_rates != local->basic_rates) {\n\t\tprintk(KERN_INFO \"%s: updating basic rate set automatically \"\n\t\t       \"to match with the new supported rate set\\n\",\n\t\t       dev->name);\n\t\tif (!basic_rates)\n\t\t\tbasic_rates = local->tx_rate_control;\n\n\t\tlocal->basic_rates = basic_rates;\n\t\tif (hostap_set_word(dev, HFA384X_RID_CNFBASICRATES,\n\t\t\t\t    basic_rates))\n\t\t\tprintk(KERN_WARNING \"%s: failed to set \"\n\t\t\t       \"cnfBasicRates\\n\", dev->name);\n\t}\n\n\tret = (hostap_set_word(dev, HFA384X_RID_TXRATECONTROL,\n\t\t\t       local->tx_rate_control) ||\n\t       hostap_set_word(dev, HFA384X_RID_CNFSUPPORTEDRATES,\n\t\t\t       local->tx_rate_control) ||\n\t       local->func->reset_port(dev));\n\n\tif (ret) {\n\t\tprintk(KERN_WARNING \"%s: TXRateControl/cnfSupportedRates \"\n\t\t       \"setting to 0x%x failed\\n\",\n\t\t       dev->name, local->tx_rate_control);\n\t}\n\n\t \n\thostap_update_rates(local);\n\n\treturn ret;\n}\n\n\nstatic int prism2_ioctl_siwrate(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *rrq = &wrqu->bitrate;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (rrq->fixed) {\n\t\tswitch (rrq->value) {\n\t\tcase 11000000:\n\t\t\tlocal->tx_rate_control = HFA384X_RATES_11MBPS;\n\t\t\tbreak;\n\t\tcase 5500000:\n\t\t\tlocal->tx_rate_control = HFA384X_RATES_5MBPS;\n\t\t\tbreak;\n\t\tcase 2000000:\n\t\t\tlocal->tx_rate_control = HFA384X_RATES_2MBPS;\n\t\t\tbreak;\n\t\tcase 1000000:\n\t\t\tlocal->tx_rate_control = HFA384X_RATES_1MBPS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlocal->tx_rate_control = HFA384X_RATES_1MBPS |\n\t\t\t\tHFA384X_RATES_2MBPS | HFA384X_RATES_5MBPS |\n\t\t\t\tHFA384X_RATES_11MBPS;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (rrq->value) {\n\t\tcase 11000000:\n\t\t\tlocal->tx_rate_control = HFA384X_RATES_1MBPS |\n\t\t\t\tHFA384X_RATES_2MBPS | HFA384X_RATES_5MBPS |\n\t\t\t\tHFA384X_RATES_11MBPS;\n\t\t\tbreak;\n\t\tcase 5500000:\n\t\t\tlocal->tx_rate_control = HFA384X_RATES_1MBPS |\n\t\t\t\tHFA384X_RATES_2MBPS | HFA384X_RATES_5MBPS;\n\t\t\tbreak;\n\t\tcase 2000000:\n\t\t\tlocal->tx_rate_control = HFA384X_RATES_1MBPS |\n\t\t\t\tHFA384X_RATES_2MBPS;\n\t\t\tbreak;\n\t\tcase 1000000:\n\t\t\tlocal->tx_rate_control = HFA384X_RATES_1MBPS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlocal->tx_rate_control = HFA384X_RATES_1MBPS |\n\t\t\t\tHFA384X_RATES_2MBPS | HFA384X_RATES_5MBPS |\n\t\t\t\tHFA384X_RATES_11MBPS;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn hostap_set_rate(dev);\n}\n\n\nstatic int prism2_ioctl_giwrate(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *rrq = &wrqu->bitrate;\n\tu16 val;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint ret = 0;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (local->func->get_rid(dev, HFA384X_RID_TXRATECONTROL, &val, 2, 1) <\n\t    0)\n\t\treturn -EINVAL;\n\n\tif ((val & 0x1) && (val > 1))\n\t\trrq->fixed = 0;\n\telse\n\t\trrq->fixed = 1;\n\n\tif (local->iw_mode == IW_MODE_MASTER && local->ap != NULL &&\n\t    !local->fw_tx_rate_control) {\n\t\t \n\t\trrq->value = local->ap->last_tx_rate > 0 ?\n\t\t\tlocal->ap->last_tx_rate * 100000 : 11000000;\n\t\treturn 0;\n\t}\n\n\tif (local->func->get_rid(dev, HFA384X_RID_CURRENTTXRATE, &val, 2, 1) <\n\t    0)\n\t\treturn -EINVAL;\n\n\tswitch (val) {\n\tcase HFA384X_RATES_1MBPS:\n\t\trrq->value = 1000000;\n\t\tbreak;\n\tcase HFA384X_RATES_2MBPS:\n\t\trrq->value = 2000000;\n\t\tbreak;\n\tcase HFA384X_RATES_5MBPS:\n\t\trrq->value = 5500000;\n\t\tbreak;\n\tcase HFA384X_RATES_11MBPS:\n\t\trrq->value = 11000000;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\trrq->value = 11000000;\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n\nstatic int prism2_ioctl_siwsens(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *sens = &wrqu->sens;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\t \n\tif (sens->value < 1 || sens->value > 3)\n\t\treturn -EINVAL;\n\n\tif (hostap_set_word(dev, HFA384X_RID_CNFSYSTEMSCALE, sens->value) ||\n\t    local->func->reset_port(dev))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int prism2_ioctl_giwsens(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *sens = &wrqu->sens;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\t__le16 val;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\t \n\tif (local->func->get_rid(dev, HFA384X_RID_CNFSYSTEMSCALE, &val, 2, 1) <\n\t    0)\n\t\treturn -EINVAL;\n\n\tsens->value = le16_to_cpu(val);\n\tsens->fixed = 1;\n\n\treturn 0;\n}\n\n\n \nstatic int prism2_ioctl_giwaplist(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_point *data = &wrqu->data;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tstruct sockaddr *addr;\n\tstruct iw_quality *qual;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (local->iw_mode != IW_MODE_MASTER) {\n\t\tprintk(KERN_DEBUG \"SIOCGIWAPLIST is currently only supported \"\n\t\t       \"in Host AP mode\\n\");\n\t\tdata->length = 0;\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\taddr = kmalloc_array(IW_MAX_AP, sizeof(struct sockaddr), GFP_KERNEL);\n\tqual = kmalloc_array(IW_MAX_AP, sizeof(struct iw_quality), GFP_KERNEL);\n\tif (addr == NULL || qual == NULL) {\n\t\tkfree(addr);\n\t\tkfree(qual);\n\t\tdata->length = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->length = prism2_ap_get_sta_qual(local, addr, qual, IW_MAX_AP, 1);\n\n\tmemcpy(extra, addr, sizeof(struct sockaddr) * data->length);\n\tdata->flags = 1;  \n\tmemcpy(extra + sizeof(struct sockaddr) * data->length, qual,\n\t       sizeof(struct iw_quality) * data->length);\n\n\tkfree(addr);\n\tkfree(qual);\n\treturn 0;\n}\n\n\nstatic int prism2_ioctl_siwrts(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *rts = &wrqu->rts;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\t__le16 val;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (rts->disabled)\n\t\tval = cpu_to_le16(2347);\n\telse if (rts->value < 0 || rts->value > 2347)\n\t\treturn -EINVAL;\n\telse\n\t\tval = cpu_to_le16(rts->value);\n\n\tif (local->func->set_rid(dev, HFA384X_RID_RTSTHRESHOLD, &val, 2) ||\n\t    local->func->reset_port(dev))\n\t\treturn -EINVAL;\n\n\tlocal->rts_threshold = rts->value;\n\n\treturn 0;\n}\n\nstatic int prism2_ioctl_giwrts(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *rts = &wrqu->rts;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\t__le16 val;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (local->func->get_rid(dev, HFA384X_RID_RTSTHRESHOLD, &val, 2, 1) <\n\t    0)\n\t\treturn -EINVAL;\n\n\trts->value = le16_to_cpu(val);\n\trts->disabled = (rts->value == 2347);\n\trts->fixed = 1;\n\n\treturn 0;\n}\n\n\nstatic int prism2_ioctl_siwfrag(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *rts = &wrqu->rts;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\t__le16 val;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (rts->disabled)\n\t\tval = cpu_to_le16(2346);\n\telse if (rts->value < 256 || rts->value > 2346)\n\t\treturn -EINVAL;\n\telse\n\t\tval = cpu_to_le16(rts->value & ~0x1);  \n\n\tlocal->fragm_threshold = rts->value & ~0x1;\n\tif (local->func->set_rid(dev, HFA384X_RID_FRAGMENTATIONTHRESHOLD, &val,\n\t\t\t\t 2)\n\t    || local->func->reset_port(dev))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int prism2_ioctl_giwfrag(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *rts = &wrqu->rts;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\t__le16 val;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (local->func->get_rid(dev, HFA384X_RID_FRAGMENTATIONTHRESHOLD,\n\t\t\t\t &val, 2, 1) < 0)\n\t\treturn -EINVAL;\n\n\trts->value = le16_to_cpu(val);\n\trts->disabled = (rts->value == 2346);\n\trts->fixed = 1;\n\n\treturn 0;\n}\n\n\n#ifndef PRISM2_NO_STATION_MODES\nstatic int hostap_join_ap(struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tstruct hfa384x_join_request req;\n\tunsigned long flags;\n\tint i;\n\tstruct hfa384x_hostscan_result *entry;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tmemcpy(req.bssid, local->preferred_ap, ETH_ALEN);\n\treq.channel = 0;\n\n\tspin_lock_irqsave(&local->lock, flags);\n\tfor (i = 0; i < local->last_scan_results_count; i++) {\n\t\tif (!local->last_scan_results)\n\t\t\tbreak;\n\t\tentry = &local->last_scan_results[i];\n\t\tif (ether_addr_equal(local->preferred_ap, entry->bssid)) {\n\t\t\treq.channel = entry->chid;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&local->lock, flags);\n\n\tif (local->func->set_rid(dev, HFA384X_RID_JOINREQUEST, &req,\n\t\t\t\t sizeof(req))) {\n\t\tprintk(KERN_DEBUG \"%s: JoinRequest %pM failed\\n\",\n\t\t       dev->name, local->preferred_ap);\n\t\treturn -1;\n\t}\n\n\tprintk(KERN_DEBUG \"%s: Trying to join BSSID %pM\\n\",\n\t       dev->name, local->preferred_ap);\n\n\treturn 0;\n}\n#endif  \n\n\nstatic int prism2_ioctl_siwap(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *wrqu, char *extra)\n{\n\tstruct sockaddr *ap_addr = &wrqu->ap_addr;\n#ifdef PRISM2_NO_STATION_MODES\n\treturn -EOPNOTSUPP;\n#else  \n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tmemcpy(local->preferred_ap, &ap_addr->sa_data, ETH_ALEN);\n\n\tif (local->host_roaming == 1 && local->iw_mode == IW_MODE_INFRA) {\n\t\tstruct hfa384x_scan_request scan_req;\n\t\tmemset(&scan_req, 0, sizeof(scan_req));\n\t\tscan_req.channel_list = cpu_to_le16(0x3fff);\n\t\tscan_req.txrate = cpu_to_le16(HFA384X_RATES_1MBPS);\n\t\tif (local->func->set_rid(dev, HFA384X_RID_SCANREQUEST,\n\t\t\t\t\t &scan_req, sizeof(scan_req))) {\n\t\t\tprintk(KERN_DEBUG \"%s: ScanResults request failed - \"\n\t\t\t       \"preferred AP delayed to next unsolicited \"\n\t\t\t       \"scan\\n\", dev->name);\n\t\t}\n\t} else if (local->host_roaming == 2 &&\n\t\t   local->iw_mode == IW_MODE_INFRA) {\n\t\tif (hostap_join_ap(dev))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tprintk(KERN_DEBUG \"%s: Preferred AP (SIOCSIWAP) is used only \"\n\t\t       \"in Managed mode when host_roaming is enabled\\n\",\n\t\t       dev->name);\n\t}\n\n\treturn 0;\n#endif  \n}\n\nstatic int prism2_ioctl_giwap(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *wrqu, char *extra)\n{\n\tstruct sockaddr *ap_addr = &wrqu->ap_addr;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tap_addr->sa_family = ARPHRD_ETHER;\n\tswitch (iface->type) {\n\tcase HOSTAP_INTERFACE_AP:\n\t\tmemcpy(&ap_addr->sa_data, dev->dev_addr, ETH_ALEN);\n\t\tbreak;\n\tcase HOSTAP_INTERFACE_STA:\n\t\tmemcpy(&ap_addr->sa_data, local->assoc_ap_addr, ETH_ALEN);\n\t\tbreak;\n\tcase HOSTAP_INTERFACE_WDS:\n\t\tmemcpy(&ap_addr->sa_data, iface->u.wds.remote_addr, ETH_ALEN);\n\t\tbreak;\n\tdefault:\n\t\tif (local->func->get_rid(dev, HFA384X_RID_CURRENTBSSID,\n\t\t\t\t\t &ap_addr->sa_data, ETH_ALEN, 1) < 0)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tmemcpy(local->bssid, &ap_addr->sa_data, ETH_ALEN);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int prism2_ioctl_siwnickn(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *nickname)\n{\n\tstruct iw_point *data = &wrqu->data;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tmemset(local->name, 0, sizeof(local->name));\n\tmemcpy(local->name, nickname, data->length);\n\tlocal->name_set = 1;\n\n\tif (hostap_set_string(dev, HFA384X_RID_CNFOWNNAME, local->name) ||\n\t    local->func->reset_port(dev))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int prism2_ioctl_giwnickn(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *nickname)\n{\n\tstruct iw_point *data = &wrqu->data;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint len;\n\tchar name[MAX_NAME_LEN + 3];\n\tu16 val;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tlen = local->func->get_rid(dev, HFA384X_RID_CNFOWNNAME,\n\t\t\t\t   &name, MAX_NAME_LEN + 2, 0);\n\tval = le16_to_cpu(*(__le16 *) name);\n\tif (len > MAX_NAME_LEN + 2 || len < 0 || val > MAX_NAME_LEN)\n\t\treturn -EOPNOTSUPP;\n\n\tname[val + 2] = '\\0';\n\tdata->length = val + 1;\n\tmemcpy(nickname, name + 2, val + 1);\n\n\treturn 0;\n}\n\n\nstatic int prism2_ioctl_siwfreq(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_freq *freq = &wrqu->freq;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\t \n\tif (freq->e == 1 &&\n\t    freq->m / 100000 >= freq_list[0] &&\n\t    freq->m / 100000 <= freq_list[FREQ_COUNT - 1]) {\n\t\tint ch;\n\t\tint fr = freq->m / 100000;\n\t\tfor (ch = 0; ch < FREQ_COUNT; ch++) {\n\t\t\tif (fr == freq_list[ch]) {\n\t\t\t\tfreq->e = 0;\n\t\t\t\tfreq->m = ch + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (freq->e != 0 || freq->m < 1 || freq->m > FREQ_COUNT ||\n\t    !(local->channel_mask & (1 << (freq->m - 1))))\n\t\treturn -EINVAL;\n\n\tlocal->channel = freq->m;  \n\tif (hostap_set_word(dev, HFA384X_RID_CNFOWNCHANNEL, local->channel) ||\n\t    local->func->reset_port(dev))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int prism2_ioctl_giwfreq(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_freq *freq = &wrqu->freq;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tu16 val;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (local->func->get_rid(dev, HFA384X_RID_CURRENTCHANNEL, &val, 2, 1) <\n\t    0)\n\t\treturn -EINVAL;\n\n\tle16_to_cpus(&val);\n\tif (val < 1 || val > FREQ_COUNT)\n\t\treturn -EINVAL;\n\n\tfreq->m = freq_list[val - 1] * 100000;\n\tfreq->e = 1;\n\n\treturn 0;\n}\n\n\nstatic void hostap_monitor_set_type(local_info_t *local)\n{\n\tstruct net_device *dev = local->ddev;\n\n\tif (dev == NULL)\n\t\treturn;\n\n\tif (local->monitor_type == PRISM2_MONITOR_PRISM ||\n\t    local->monitor_type == PRISM2_MONITOR_CAPHDR) {\n\t\tdev->type = ARPHRD_IEEE80211_PRISM;\n\t} else if (local->monitor_type == PRISM2_MONITOR_RADIOTAP) {\n\t\tdev->type = ARPHRD_IEEE80211_RADIOTAP;\n\t} else {\n\t\tdev->type = ARPHRD_IEEE80211;\n\t}\n}\n\n\nstatic int prism2_ioctl_siwessid(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *ssid)\n{\n\tstruct iw_point *data = &wrqu->data;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (iface->type == HOSTAP_INTERFACE_WDS)\n\t\treturn -EOPNOTSUPP;\n\n\tif (data->flags == 0)\n\t\tssid[0] = '\\0';  \n\n\tif (local->iw_mode == IW_MODE_MASTER && ssid[0] == '\\0') {\n\t\t \n\t\tprintk(KERN_DEBUG \"%s: Host AP mode does not support \"\n\t\t       \"'Any' essid\\n\", dev->name);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(local->essid, ssid, data->length);\n\tlocal->essid[data->length] = '\\0';\n\n\tif ((!local->fw_ap &&\n\t     hostap_set_string(dev, HFA384X_RID_CNFDESIREDSSID, local->essid))\n\t    || hostap_set_string(dev, HFA384X_RID_CNFOWNSSID, local->essid) ||\n\t    local->func->reset_port(dev))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int prism2_ioctl_giwessid(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *essid)\n{\n\tstruct iw_point *data = &wrqu->data;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tu16 val;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (iface->type == HOSTAP_INTERFACE_WDS)\n\t\treturn -EOPNOTSUPP;\n\n\tdata->flags = 1;  \n\tif (local->iw_mode == IW_MODE_MASTER) {\n\t\tdata->length = strlen(local->essid);\n\t\tmemcpy(essid, local->essid, IW_ESSID_MAX_SIZE);\n\t} else {\n\t\tint len;\n\t\tchar ssid[MAX_SSID_LEN + 2];\n\t\tmemset(ssid, 0, sizeof(ssid));\n\t\tlen = local->func->get_rid(dev, HFA384X_RID_CURRENTSSID,\n\t\t\t\t\t   &ssid, MAX_SSID_LEN + 2, 0);\n\t\tval = le16_to_cpu(*(__le16 *) ssid);\n\t\tif (len > MAX_SSID_LEN + 2 || len < 0 || val > MAX_SSID_LEN) {\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tdata->length = val;\n\t\tmemcpy(essid, ssid + 2, IW_ESSID_MAX_SIZE);\n\t}\n\n\treturn 0;\n}\n\n\nstatic int prism2_ioctl_giwrange(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_point *data = &wrqu->data;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tstruct iw_range *range = (struct iw_range *) extra;\n\tu8 rates[10];\n\tu16 val;\n\tint i, len, over2;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tdata->length = sizeof(struct iw_range);\n\tmemset(range, 0, sizeof(struct iw_range));\n\n\t \n\n\trange->txpower_capa = IW_TXPOW_DBM;\n\n\tif (local->iw_mode == IW_MODE_INFRA || local->iw_mode == IW_MODE_ADHOC)\n\t{\n\t\trange->min_pmp = 1 * 1024;\n\t\trange->max_pmp = 65535 * 1024;\n\t\trange->min_pmt = 1 * 1024;\n\t\trange->max_pmt = 1000 * 1024;\n\t\trange->pmp_flags = IW_POWER_PERIOD;\n\t\trange->pmt_flags = IW_POWER_TIMEOUT;\n\t\trange->pm_capa = IW_POWER_PERIOD | IW_POWER_TIMEOUT |\n\t\t\tIW_POWER_UNICAST_R | IW_POWER_ALL_R;\n\t}\n\n\trange->we_version_compiled = WIRELESS_EXT;\n\trange->we_version_source = 18;\n\n\trange->retry_capa = IW_RETRY_LIMIT;\n\trange->retry_flags = IW_RETRY_LIMIT;\n\trange->min_retry = 0;\n\trange->max_retry = 255;\n\n\trange->num_channels = FREQ_COUNT;\n\n\tval = 0;\n\tfor (i = 0; i < FREQ_COUNT; i++) {\n\t\tif (local->channel_mask & (1 << i)) {\n\t\t\trange->freq[val].i = i + 1;\n\t\t\trange->freq[val].m = freq_list[i] * 100000;\n\t\t\trange->freq[val].e = 1;\n\t\t\tval++;\n\t\t}\n\t\tif (val == IW_MAX_FREQUENCIES)\n\t\t\tbreak;\n\t}\n\trange->num_frequency = val;\n\n\tif (local->sta_fw_ver >= PRISM2_FW_VER(1,3,1)) {\n\t\trange->max_qual.qual = 70;  \n\t\trange->max_qual.level = 0;  \n\t\trange->max_qual.noise = 0;  \n\n\t\t \n\t\trange->avg_qual.qual = 20;\n\t\trange->avg_qual.level = -60;\n\t\trange->avg_qual.noise = -95;\n\t} else {\n\t\trange->max_qual.qual = 92;  \n\t\trange->max_qual.level = 154;  \n\t\trange->max_qual.noise = 154;  \n\t}\n\trange->sensitivity = 3;\n\n\trange->max_encoding_tokens = WEP_KEYS;\n\trange->num_encoding_sizes = 2;\n\trange->encoding_size[0] = 5;\n\trange->encoding_size[1] = 13;\n\n\tover2 = 0;\n\tlen = prism2_get_datarates(dev, rates);\n\trange->num_bitrates = 0;\n\tfor (i = 0; i < len; i++) {\n\t\tif (range->num_bitrates < IW_MAX_BITRATES) {\n\t\t\trange->bitrate[range->num_bitrates] =\n\t\t\t\trates[i] * 500000;\n\t\t\trange->num_bitrates++;\n\t\t}\n\t\tif (rates[i] == 0x0b || rates[i] == 0x16)\n\t\t\tover2 = 1;\n\t}\n\t \n\trange->throughput = over2 ? 5500000 : 1500000;\n\n\trange->min_rts = 0;\n\trange->max_rts = 2347;\n\trange->min_frag = 256;\n\trange->max_frag = 2346;\n\n\t \n\trange->event_capa[0] = (IW_EVENT_CAPA_K_0 |\n\t\t\t\tIW_EVENT_CAPA_MASK(SIOCGIWTHRSPY) |\n\t\t\t\tIW_EVENT_CAPA_MASK(SIOCGIWAP) |\n\t\t\t\tIW_EVENT_CAPA_MASK(SIOCGIWSCAN));\n\trange->event_capa[1] = IW_EVENT_CAPA_K_1;\n\trange->event_capa[4] = (IW_EVENT_CAPA_MASK(IWEVTXDROP) |\n\t\t\t\tIW_EVENT_CAPA_MASK(IWEVCUSTOM) |\n\t\t\t\tIW_EVENT_CAPA_MASK(IWEVREGISTERED) |\n\t\t\t\tIW_EVENT_CAPA_MASK(IWEVEXPIRED));\n\n\trange->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 |\n\t\tIW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP;\n\n\tif (local->sta_fw_ver >= PRISM2_FW_VER(1,3,1))\n\t\trange->scan_capa = IW_SCAN_CAPA_ESSID;\n\n\treturn 0;\n}\n\n\nstatic int hostap_monitor_mode_enable(local_info_t *local)\n{\n\tstruct net_device *dev = local->dev;\n\n\tprintk(KERN_DEBUG \"Enabling monitor mode\\n\");\n\thostap_monitor_set_type(local);\n\n\tif (hostap_set_word(dev, HFA384X_RID_CNFPORTTYPE,\n\t\t\t    HFA384X_PORTTYPE_PSEUDO_IBSS)) {\n\t\tprintk(KERN_DEBUG \"Port type setting for monitor mode \"\n\t\t       \"failed\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (hostap_set_word(dev, HFA384X_RID_CNFWEPFLAGS,\n\t\t\t    HFA384X_WEPFLAGS_HOSTENCRYPT |\n\t\t\t    HFA384X_WEPFLAGS_HOSTDECRYPT)) {\n\t\tprintk(KERN_DEBUG \"WEP flags setting failed\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (local->func->reset_port(dev) ||\n\t    local->func->cmd(dev, HFA384X_CMDCODE_TEST |\n\t\t\t     (HFA384X_TEST_MONITOR << 8),\n\t\t\t     0, NULL, NULL)) {\n\t\tprintk(KERN_DEBUG \"Setting monitor mode failed\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int hostap_monitor_mode_disable(local_info_t *local)\n{\n\tstruct net_device *dev = local->ddev;\n\n\tif (dev == NULL)\n\t\treturn -1;\n\n\tprintk(KERN_DEBUG \"%s: Disabling monitor mode\\n\", dev->name);\n\tdev->type = ARPHRD_ETHER;\n\n\tif (local->func->cmd(dev, HFA384X_CMDCODE_TEST |\n\t\t\t     (HFA384X_TEST_STOP << 8),\n\t\t\t     0, NULL, NULL))\n\t\treturn -1;\n\treturn hostap_set_encryption(local);\n}\n\n\nstatic int prism2_ioctl_siwmode(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\t__u32 *mode = &wrqu->mode;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint double_reset = 0;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (*mode != IW_MODE_ADHOC && *mode != IW_MODE_INFRA &&\n\t    *mode != IW_MODE_MASTER && *mode != IW_MODE_REPEAT &&\n\t    *mode != IW_MODE_MONITOR)\n\t\treturn -EOPNOTSUPP;\n\n#ifdef PRISM2_NO_STATION_MODES\n\tif (*mode == IW_MODE_ADHOC || *mode == IW_MODE_INFRA)\n\t\treturn -EOPNOTSUPP;\n#endif  \n\n\tif (*mode == local->iw_mode)\n\t\treturn 0;\n\n\tif (*mode == IW_MODE_MASTER && local->essid[0] == '\\0') {\n\t\tprintk(KERN_WARNING \"%s: empty SSID not allowed in Master \"\n\t\t       \"mode\\n\", dev->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (local->iw_mode == IW_MODE_MONITOR)\n\t\thostap_monitor_mode_disable(local);\n\n\tif ((local->iw_mode == IW_MODE_ADHOC ||\n\t     local->iw_mode == IW_MODE_MONITOR) && *mode == IW_MODE_MASTER) {\n\t\t \n\t\tdouble_reset = 1;\n\t}\n\n\tprintk(KERN_DEBUG \"prism2: %s: operating mode changed \"\n\t       \"%d -> %d\\n\", dev->name, local->iw_mode, *mode);\n\tlocal->iw_mode = *mode;\n\n\tif (local->iw_mode == IW_MODE_MONITOR)\n\t\thostap_monitor_mode_enable(local);\n\telse if (local->iw_mode == IW_MODE_MASTER && !local->host_encrypt &&\n\t\t !local->fw_encrypt_ok) {\n\t\tprintk(KERN_DEBUG \"%s: defaulting to host-based encryption as \"\n\t\t       \"a workaround for firmware bug in Host AP mode WEP\\n\",\n\t\t       dev->name);\n\t\tlocal->host_encrypt = 1;\n\t}\n\n\tif (hostap_set_word(dev, HFA384X_RID_CNFPORTTYPE,\n\t\t\t    hostap_get_porttype(local)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (local->func->reset_port(dev))\n\t\treturn -EINVAL;\n\tif (double_reset && local->func->reset_port(dev))\n\t\treturn -EINVAL;\n\n\tif (local->iw_mode != IW_MODE_INFRA && local->iw_mode != IW_MODE_ADHOC)\n\t{\n\t\t \n\t\tnetif_carrier_on(local->dev);\n\t\tnetif_carrier_on(local->ddev);\n\t}\n\treturn 0;\n}\n\n\nstatic int prism2_ioctl_giwmode(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\t__u32 *mode = &wrqu->mode;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tswitch (iface->type) {\n\tcase HOSTAP_INTERFACE_STA:\n\t\t*mode = IW_MODE_INFRA;\n\t\tbreak;\n\tcase HOSTAP_INTERFACE_WDS:\n\t\t*mode = IW_MODE_REPEAT;\n\t\tbreak;\n\tdefault:\n\t\t*mode = local->iw_mode;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n\nstatic int prism2_ioctl_siwpower(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *wrq = &wrqu->power;\n#ifdef PRISM2_NO_STATION_MODES\n\treturn -EOPNOTSUPP;\n#else  \n\tint ret = 0;\n\n\tif (wrq->disabled)\n\t\treturn hostap_set_word(dev, HFA384X_RID_CNFPMENABLED, 0);\n\n\tswitch (wrq->flags & IW_POWER_MODE) {\n\tcase IW_POWER_UNICAST_R:\n\t\tret = hostap_set_word(dev, HFA384X_RID_CNFMULTICASTRECEIVE, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = hostap_set_word(dev, HFA384X_RID_CNFPMENABLED, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase IW_POWER_ALL_R:\n\t\tret = hostap_set_word(dev, HFA384X_RID_CNFMULTICASTRECEIVE, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = hostap_set_word(dev, HFA384X_RID_CNFPMENABLED, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase IW_POWER_ON:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (wrq->flags & IW_POWER_TIMEOUT) {\n\t\tret = hostap_set_word(dev, HFA384X_RID_CNFPMENABLED, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = hostap_set_word(dev, HFA384X_RID_CNFPMHOLDOVERDURATION,\n\t\t\t\t      wrq->value / 1024);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (wrq->flags & IW_POWER_PERIOD) {\n\t\tret = hostap_set_word(dev, HFA384X_RID_CNFPMENABLED, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = hostap_set_word(dev, HFA384X_RID_CNFMAXSLEEPDURATION,\n\t\t\t\t      wrq->value / 1024);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n#endif  \n}\n\n\nstatic int prism2_ioctl_giwpower(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *rrq = &wrqu->power;\n#ifdef PRISM2_NO_STATION_MODES\n\treturn -EOPNOTSUPP;\n#else  \n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\t__le16 enable, mcast;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (local->func->get_rid(dev, HFA384X_RID_CNFPMENABLED, &enable, 2, 1)\n\t    < 0)\n\t\treturn -EINVAL;\n\n\tif (!le16_to_cpu(enable)) {\n\t\trrq->disabled = 1;\n\t\treturn 0;\n\t}\n\n\trrq->disabled = 0;\n\n\tif ((rrq->flags & IW_POWER_TYPE) == IW_POWER_TIMEOUT) {\n\t\t__le16 timeout;\n\t\tif (local->func->get_rid(dev,\n\t\t\t\t\t HFA384X_RID_CNFPMHOLDOVERDURATION,\n\t\t\t\t\t &timeout, 2, 1) < 0)\n\t\t\treturn -EINVAL;\n\n\t\trrq->flags = IW_POWER_TIMEOUT;\n\t\trrq->value = le16_to_cpu(timeout) * 1024;\n\t} else {\n\t\t__le16 period;\n\t\tif (local->func->get_rid(dev, HFA384X_RID_CNFMAXSLEEPDURATION,\n\t\t\t\t\t &period, 2, 1) < 0)\n\t\t\treturn -EINVAL;\n\n\t\trrq->flags = IW_POWER_PERIOD;\n\t\trrq->value = le16_to_cpu(period) * 1024;\n\t}\n\n\tif (local->func->get_rid(dev, HFA384X_RID_CNFMULTICASTRECEIVE, &mcast,\n\t\t\t\t 2, 1) < 0)\n\t\treturn -EINVAL;\n\n\tif (le16_to_cpu(mcast))\n\t\trrq->flags |= IW_POWER_ALL_R;\n\telse\n\t\trrq->flags |= IW_POWER_UNICAST_R;\n\n\treturn 0;\n#endif  \n}\n\n\nstatic int prism2_ioctl_siwretry(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *rrq = &wrqu->retry;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (rrq->disabled)\n\t\treturn -EINVAL;\n\n\t \n\tif (rrq->flags == IW_RETRY_LIMIT) {\n\t\tif (rrq->value < 0) {\n\t\t\t \n\t\t\tlocal->manual_retry_count = -1;\n\t\t\tlocal->tx_control &= ~HFA384X_TX_CTRL_ALT_RTRY;\n\t\t} else {\n\t\t\tif (hostap_set_word(dev, HFA384X_RID_CNFALTRETRYCOUNT,\n\t\t\t\t\t    rrq->value)) {\n\t\t\t\tprintk(KERN_DEBUG \"%s: Alternate retry count \"\n\t\t\t\t       \"setting to %d failed\\n\",\n\t\t\t\t       dev->name, rrq->value);\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\tlocal->manual_retry_count = rrq->value;\n\t\t\tlocal->tx_control |= HFA384X_TX_CTRL_ALT_RTRY;\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn -EOPNOTSUPP;\n\n#if 0\n\t \n\n\tif (rrq->flags & IW_RETRY_LIMIT) {\n\t\tif (rrq->flags & IW_RETRY_LONG)\n\t\t\tHFA384X_RID_LONGRETRYLIMIT = rrq->value;\n\t\telse if (rrq->flags & IW_RETRY_SHORT)\n\t\t\tHFA384X_RID_SHORTRETRYLIMIT = rrq->value;\n\t\telse {\n\t\t\tHFA384X_RID_LONGRETRYLIMIT = rrq->value;\n\t\t\tHFA384X_RID_SHORTRETRYLIMIT = rrq->value;\n\t\t}\n\n\t}\n\n\tif (rrq->flags & IW_RETRY_LIFETIME) {\n\t\tHFA384X_RID_MAXTRANSMITLIFETIME = rrq->value / 1024;\n\t}\n\n\treturn 0;\n#endif  \n}\n\nstatic int prism2_ioctl_giwretry(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *rrq = &wrqu->retry;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\t__le16 shortretry, longretry, lifetime, altretry;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (local->func->get_rid(dev, HFA384X_RID_SHORTRETRYLIMIT, &shortretry,\n\t\t\t\t 2, 1) < 0 ||\n\t    local->func->get_rid(dev, HFA384X_RID_LONGRETRYLIMIT, &longretry,\n\t\t\t\t 2, 1) < 0 ||\n\t    local->func->get_rid(dev, HFA384X_RID_MAXTRANSMITLIFETIME,\n\t\t\t\t &lifetime, 2, 1) < 0)\n\t\treturn -EINVAL;\n\n\trrq->disabled = 0;\n\n\tif ((rrq->flags & IW_RETRY_TYPE) == IW_RETRY_LIFETIME) {\n\t\trrq->flags = IW_RETRY_LIFETIME;\n\t\trrq->value = le16_to_cpu(lifetime) * 1024;\n\t} else {\n\t\tif (local->manual_retry_count >= 0) {\n\t\t\trrq->flags = IW_RETRY_LIMIT;\n\t\t\tif (local->func->get_rid(dev,\n\t\t\t\t\t\t HFA384X_RID_CNFALTRETRYCOUNT,\n\t\t\t\t\t\t &altretry, 2, 1) >= 0)\n\t\t\t\trrq->value = le16_to_cpu(altretry);\n\t\t\telse\n\t\t\t\trrq->value = local->manual_retry_count;\n\t\t} else if ((rrq->flags & IW_RETRY_LONG)) {\n\t\t\trrq->flags = IW_RETRY_LIMIT | IW_RETRY_LONG;\n\t\t\trrq->value = le16_to_cpu(longretry);\n\t\t} else {\n\t\t\trrq->flags = IW_RETRY_LIMIT;\n\t\t\trrq->value = le16_to_cpu(shortretry);\n\t\t\tif (shortretry != longretry)\n\t\t\t\trrq->flags |= IW_RETRY_SHORT;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n \n\n#ifdef RAW_TXPOWER_SETTING\n \n\nstatic int prism2_txpower_hfa386x_to_dBm(u16 val)\n{\n\tsigned char tmp;\n\n\tif (val > 255)\n\t\tval = 255;\n\n\ttmp = val;\n\ttmp >>= 2;\n\n\treturn -12 - tmp;\n}\n\nstatic u16 prism2_txpower_dBm_to_hfa386x(int val)\n{\n\tsigned char tmp;\n\n\tif (val > 20)\n\t\treturn 128;\n\telse if (val < -43)\n\t\treturn 127;\n\n\ttmp = val;\n\ttmp = -12 - tmp;\n\ttmp <<= 2;\n\n\treturn (unsigned char) tmp;\n}\n#endif  \n\n\nstatic int prism2_ioctl_siwtxpow(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *rrq = &wrqu->txpower;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n#ifdef RAW_TXPOWER_SETTING\n\tchar *tmp;\n#endif\n\tu16 val;\n\tint ret = 0;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (rrq->disabled) {\n\t\tif (local->txpower_type != PRISM2_TXPOWER_OFF) {\n\t\t\tval = 0xff;  \n\t\t\tret = local->func->cmd(dev, HFA384X_CMDCODE_WRITEMIF,\n\t\t\t\t\t       HFA386X_CR_A_D_TEST_MODES2,\n\t\t\t\t\t       &val, NULL);\n\t\t\tprintk(KERN_DEBUG \"%s: Turning radio off: %s\\n\",\n\t\t\t       dev->name, ret ? \"failed\" : \"OK\");\n\t\t\tlocal->txpower_type = PRISM2_TXPOWER_OFF;\n\t\t}\n\t\treturn (ret ? -EOPNOTSUPP : 0);\n\t}\n\n\tif (local->txpower_type == PRISM2_TXPOWER_OFF) {\n\t\tval = 0;  \n\t\tret = local->func->cmd(dev, HFA384X_CMDCODE_WRITEMIF,\n\t\t\t\t       HFA386X_CR_A_D_TEST_MODES2, &val, NULL);\n\t\tprintk(KERN_DEBUG \"%s: Turning radio on: %s\\n\",\n\t\t       dev->name, ret ? \"failed\" : \"OK\");\n\t\tlocal->txpower_type = PRISM2_TXPOWER_UNKNOWN;\n\t}\n\n#ifdef RAW_TXPOWER_SETTING\n\tif (!rrq->fixed && local->txpower_type != PRISM2_TXPOWER_AUTO) {\n\t\tprintk(KERN_DEBUG \"Setting ALC on\\n\");\n\t\tval = HFA384X_TEST_CFG_BIT_ALC;\n\t\tlocal->func->cmd(dev, HFA384X_CMDCODE_TEST |\n\t\t\t\t (HFA384X_TEST_CFG_BITS << 8), 1, &val, NULL);\n\t\tlocal->txpower_type = PRISM2_TXPOWER_AUTO;\n\t\treturn 0;\n\t}\n\n\tif (local->txpower_type != PRISM2_TXPOWER_FIXED) {\n\t\tprintk(KERN_DEBUG \"Setting ALC off\\n\");\n\t\tval = HFA384X_TEST_CFG_BIT_ALC;\n\t\tlocal->func->cmd(dev, HFA384X_CMDCODE_TEST |\n\t\t\t\t (HFA384X_TEST_CFG_BITS << 8), 0, &val, NULL);\n\t\t\tlocal->txpower_type = PRISM2_TXPOWER_FIXED;\n\t}\n\n\tif (rrq->flags == IW_TXPOW_DBM)\n\t\ttmp = \"dBm\";\n\telse if (rrq->flags == IW_TXPOW_MWATT)\n\t\ttmp = \"mW\";\n\telse\n\t\ttmp = \"UNKNOWN\";\n\tprintk(KERN_DEBUG \"Setting TX power to %d %s\\n\", rrq->value, tmp);\n\n\tif (rrq->flags != IW_TXPOW_DBM) {\n\t\tprintk(\"SIOCSIWTXPOW with mW is not supported; use dBm\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tlocal->txpower = rrq->value;\n\tval = prism2_txpower_dBm_to_hfa386x(local->txpower);\n\tif (local->func->cmd(dev, HFA384X_CMDCODE_WRITEMIF,\n\t\t\t     HFA386X_CR_MANUAL_TX_POWER, &val, NULL))\n\t\tret = -EOPNOTSUPP;\n#else  \n\tif (rrq->fixed)\n\t\tret = -EOPNOTSUPP;\n#endif  \n\n\treturn ret;\n}\n\nstatic int prism2_ioctl_giwtxpow(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *extra)\n{\n#ifdef RAW_TXPOWER_SETTING\n\tstruct iw_param *rrq = &wrqu->txpower;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tu16 resp0;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\trrq->flags = IW_TXPOW_DBM;\n\trrq->disabled = 0;\n\trrq->fixed = 0;\n\n\tif (local->txpower_type == PRISM2_TXPOWER_AUTO) {\n\t\tif (local->func->cmd(dev, HFA384X_CMDCODE_READMIF,\n\t\t\t\t     HFA386X_CR_MANUAL_TX_POWER,\n\t\t\t\t     NULL, &resp0) == 0) {\n\t\t\trrq->value = prism2_txpower_hfa386x_to_dBm(resp0);\n\t\t} else {\n\t\t\t \n\t\t\trrq->value = 15;\n\t\t}\n\t} else if (local->txpower_type == PRISM2_TXPOWER_OFF) {\n\t\trrq->value = 0;\n\t\trrq->disabled = 1;\n\t} else if (local->txpower_type == PRISM2_TXPOWER_FIXED) {\n\t\trrq->value = local->txpower;\n\t\trrq->fixed = 1;\n\t} else {\n\t\tprintk(\"SIOCGIWTXPOW - unknown txpower_type=%d\\n\",\n\t\t       local->txpower_type);\n\t}\n\treturn 0;\n#else  \n\treturn -EOPNOTSUPP;\n#endif  \n}\n\n\n#ifndef PRISM2_NO_STATION_MODES\n\n \nstatic int prism2_request_hostscan(struct net_device *dev,\n\t\t\t\t   u8 *ssid, u8 ssid_len)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tstruct hfa384x_hostscan_request scan_req;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tmemset(&scan_req, 0, sizeof(scan_req));\n\tscan_req.channel_list = cpu_to_le16(local->channel_mask &\n\t\t\t\t\t    local->scan_channel_mask);\n\tscan_req.txrate = cpu_to_le16(HFA384X_RATES_1MBPS);\n\tif (ssid) {\n\t\tif (ssid_len > 32)\n\t\t\treturn -EINVAL;\n\t\tscan_req.target_ssid_len = cpu_to_le16(ssid_len);\n\t\tmemcpy(scan_req.target_ssid, ssid, ssid_len);\n\t}\n\n\tif (local->func->set_rid(dev, HFA384X_RID_HOSTSCAN, &scan_req,\n\t\t\t\t sizeof(scan_req))) {\n\t\tprintk(KERN_DEBUG \"%s: HOSTSCAN failed\\n\", dev->name);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n\nstatic int prism2_request_scan(struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tstruct hfa384x_scan_request scan_req;\n\tint ret = 0;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tmemset(&scan_req, 0, sizeof(scan_req));\n\tscan_req.channel_list = cpu_to_le16(local->channel_mask &\n\t\t\t\t\t    local->scan_channel_mask);\n\tscan_req.txrate = cpu_to_le16(HFA384X_RATES_1MBPS);\n\n\t \n\n\tif (!local->host_roaming)\n\t\thostap_set_word(dev, HFA384X_RID_CNFROAMINGMODE,\n\t\t\t\tHFA384X_ROAMING_HOST);\n\n\tif (local->func->set_rid(dev, HFA384X_RID_SCANREQUEST, &scan_req,\n\t\t\t\t sizeof(scan_req))) {\n\t\tprintk(KERN_DEBUG \"SCANREQUEST failed\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tif (!local->host_roaming)\n\t\thostap_set_word(dev, HFA384X_RID_CNFROAMINGMODE,\n\t\t\t\tHFA384X_ROAMING_FIRMWARE);\n\n\treturn ret;\n}\n\n#else  \n\nstatic inline int prism2_request_hostscan(struct net_device *dev,\n\t\t\t\t\t  u8 *ssid, u8 ssid_len)\n{\n\treturn -EOPNOTSUPP;\n}\n\n\nstatic inline int prism2_request_scan(struct net_device *dev)\n{\n\treturn -EOPNOTSUPP;\n}\n\n#endif  \n\n\nstatic int prism2_ioctl_siwscan(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_point *data = &wrqu->data;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint ret;\n\tu8 *ssid = NULL, ssid_len = 0;\n\tstruct iw_scan_req *req = (struct iw_scan_req *) extra;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (data->length < sizeof(struct iw_scan_req))\n\t\treq = NULL;\n\n\tif (local->iw_mode == IW_MODE_MASTER) {\n\t\t \n\t\tdata->length = 0;\n\t\treturn 0;\n\t}\n\n\tif (!local->dev_enabled)\n\t\treturn -ENETDOWN;\n\n\tif (req && data->flags & IW_SCAN_THIS_ESSID) {\n\t\tssid = req->essid;\n\t\tssid_len = req->essid_len;\n\n\t\tif (ssid_len &&\n\t\t    ((local->iw_mode != IW_MODE_INFRA &&\n\t\t      local->iw_mode != IW_MODE_ADHOC) ||\n\t\t     (local->sta_fw_ver < PRISM2_FW_VER(1,3,1))))\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (local->sta_fw_ver >= PRISM2_FW_VER(1,3,1))\n\t\tret = prism2_request_hostscan(dev, ssid, ssid_len);\n\telse\n\t\tret = prism2_request_scan(dev);\n\n\tif (ret == 0)\n\t\tlocal->scan_timestamp = jiffies;\n\n\t \n\n\treturn ret;\n}\n\n\n#ifndef PRISM2_NO_STATION_MODES\nstatic char * __prism2_translate_scan(local_info_t *local,\n\t\t\t\t      struct iw_request_info *info,\n\t\t\t\t      struct hfa384x_hostscan_result *scan,\n\t\t\t\t      struct hostap_bss_info *bss,\n\t\t\t\t      char *current_ev, char *end_buf)\n{\n\tint i, chan;\n\tstruct iw_event iwe;\n\tchar *current_val;\n\tu16 capabilities;\n\tu8 *pos;\n\tu8 *ssid, *bssid;\n\tsize_t ssid_len;\n\tchar *buf;\n\n\tif (bss) {\n\t\tssid = bss->ssid;\n\t\tssid_len = bss->ssid_len;\n\t\tbssid = bss->bssid;\n\t} else {\n\t\tssid = scan->ssid;\n\t\tssid_len = le16_to_cpu(scan->ssid_len);\n\t\tbssid = scan->bssid;\n\t}\n\tif (ssid_len > 32)\n\t\tssid_len = 32;\n\n\t \n\tmemset(&iwe, 0, sizeof(iwe));\n\tiwe.cmd = SIOCGIWAP;\n\tiwe.u.ap_addr.sa_family = ARPHRD_ETHER;\n\tmemcpy(iwe.u.ap_addr.sa_data, bssid, ETH_ALEN);\n\tcurrent_ev = iwe_stream_add_event(info, current_ev, end_buf, &iwe,\n\t\t\t\t\t  IW_EV_ADDR_LEN);\n\n\t \n\n\tmemset(&iwe, 0, sizeof(iwe));\n\tiwe.cmd = SIOCGIWESSID;\n\tiwe.u.data.length = ssid_len;\n\tiwe.u.data.flags = 1;\n\tcurrent_ev = iwe_stream_add_point(info, current_ev, end_buf,\n\t\t\t\t\t  &iwe, ssid);\n\n\tmemset(&iwe, 0, sizeof(iwe));\n\tiwe.cmd = SIOCGIWMODE;\n\tif (bss) {\n\t\tcapabilities = bss->capab_info;\n\t} else {\n\t\tcapabilities = le16_to_cpu(scan->capability);\n\t}\n\tif (capabilities & (WLAN_CAPABILITY_ESS |\n\t\t\t    WLAN_CAPABILITY_IBSS)) {\n\t\tif (capabilities & WLAN_CAPABILITY_ESS)\n\t\t\tiwe.u.mode = IW_MODE_MASTER;\n\t\telse\n\t\t\tiwe.u.mode = IW_MODE_ADHOC;\n\t\tcurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\n\t\t\t\t\t\t  &iwe, IW_EV_UINT_LEN);\n\t}\n\n\tmemset(&iwe, 0, sizeof(iwe));\n\tiwe.cmd = SIOCGIWFREQ;\n\tif (scan) {\n\t\tchan = le16_to_cpu(scan->chid);\n\t} else if (bss) {\n\t\tchan = bss->chan;\n\t} else {\n\t\tchan = 0;\n\t}\n\n\tif (chan > 0) {\n\t\tiwe.u.freq.m = freq_list[chan - 1] * 100000;\n\t\tiwe.u.freq.e = 1;\n\t\tcurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\n\t\t\t\t\t\t  &iwe, IW_EV_FREQ_LEN);\n\t}\n\n\tif (scan) {\n\t\tmemset(&iwe, 0, sizeof(iwe));\n\t\tiwe.cmd = IWEVQUAL;\n\t\tif (local->last_scan_type == PRISM2_HOSTSCAN) {\n\t\t\tiwe.u.qual.level = le16_to_cpu(scan->sl);\n\t\t\tiwe.u.qual.noise = le16_to_cpu(scan->anl);\n\t\t} else {\n\t\t\tiwe.u.qual.level =\n\t\t\t\tHFA384X_LEVEL_TO_dBm(le16_to_cpu(scan->sl));\n\t\t\tiwe.u.qual.noise =\n\t\t\t\tHFA384X_LEVEL_TO_dBm(le16_to_cpu(scan->anl));\n\t\t}\n\t\tiwe.u.qual.updated = IW_QUAL_LEVEL_UPDATED\n\t\t\t| IW_QUAL_NOISE_UPDATED\n\t\t\t| IW_QUAL_QUAL_INVALID\n\t\t\t| IW_QUAL_DBM;\n\t\tcurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\n\t\t\t\t\t\t  &iwe, IW_EV_QUAL_LEN);\n\t}\n\n\tmemset(&iwe, 0, sizeof(iwe));\n\tiwe.cmd = SIOCGIWENCODE;\n\tif (capabilities & WLAN_CAPABILITY_PRIVACY)\n\t\tiwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;\n\telse\n\t\tiwe.u.data.flags = IW_ENCODE_DISABLED;\n\tiwe.u.data.length = 0;\n\tcurrent_ev = iwe_stream_add_point(info, current_ev, end_buf, &iwe, \"\");\n\n\t \n\tif (scan) {\n\t\tmemset(&iwe, 0, sizeof(iwe));\n\t\tiwe.cmd = SIOCGIWRATE;\n\t\tcurrent_val = current_ev + iwe_stream_lcp_len(info);\n\t\tpos = scan->sup_rates;\n\t\tfor (i = 0; i < sizeof(scan->sup_rates); i++) {\n\t\t\tif (pos[i] == 0)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tiwe.u.bitrate.value = ((pos[i] & 0x7f) * 500000);\n\t\t\tcurrent_val = iwe_stream_add_value(\n\t\t\t\tinfo, current_ev, current_val, end_buf, &iwe,\n\t\t\t\tIW_EV_PARAM_LEN);\n\t\t}\n\t\t \n\t\tif ((current_val - current_ev) > iwe_stream_lcp_len(info))\n\t\t\tcurrent_ev = current_val;\n\t}\n\n\t \n\tbuf = kmalloc(MAX_WPA_IE_LEN * 2 + 30, GFP_ATOMIC);\n\tif (buf && scan) {\n\t\tmemset(&iwe, 0, sizeof(iwe));\n\t\tiwe.cmd = IWEVCUSTOM;\n\t\tsprintf(buf, \"bcn_int=%d\", le16_to_cpu(scan->beacon_interval));\n\t\tiwe.u.data.length = strlen(buf);\n\t\tcurrent_ev = iwe_stream_add_point(info, current_ev, end_buf,\n\t\t\t\t\t\t  &iwe, buf);\n\n\t\tmemset(&iwe, 0, sizeof(iwe));\n\t\tiwe.cmd = IWEVCUSTOM;\n\t\tsprintf(buf, \"resp_rate=%d\", le16_to_cpu(scan->rate));\n\t\tiwe.u.data.length = strlen(buf);\n\t\tcurrent_ev = iwe_stream_add_point(info, current_ev, end_buf,\n\t\t\t\t\t\t  &iwe, buf);\n\n\t\tif (local->last_scan_type == PRISM2_HOSTSCAN &&\n\t\t    (capabilities & WLAN_CAPABILITY_IBSS)) {\n\t\t\tmemset(&iwe, 0, sizeof(iwe));\n\t\t\tiwe.cmd = IWEVCUSTOM;\n\t\t\tsprintf(buf, \"atim=%d\", le16_to_cpu(scan->atim));\n\t\t\tiwe.u.data.length = strlen(buf);\n\t\t\tcurrent_ev = iwe_stream_add_point(info, current_ev,\n\t\t\t\t\t\t\t  end_buf, &iwe, buf);\n\t\t}\n\t}\n\tkfree(buf);\n\n\tif (bss && bss->wpa_ie_len > 0 && bss->wpa_ie_len <= MAX_WPA_IE_LEN) {\n\t\tmemset(&iwe, 0, sizeof(iwe));\n\t\tiwe.cmd = IWEVGENIE;\n\t\tiwe.u.data.length = bss->wpa_ie_len;\n\t\tcurrent_ev = iwe_stream_add_point(info, current_ev, end_buf,\n\t\t\t\t\t\t  &iwe, bss->wpa_ie);\n\t}\n\n\tif (bss && bss->rsn_ie_len > 0 && bss->rsn_ie_len <= MAX_WPA_IE_LEN) {\n\t\tmemset(&iwe, 0, sizeof(iwe));\n\t\tiwe.cmd = IWEVGENIE;\n\t\tiwe.u.data.length = bss->rsn_ie_len;\n\t\tcurrent_ev = iwe_stream_add_point(info, current_ev, end_buf,\n\t\t\t\t\t\t  &iwe, bss->rsn_ie);\n\t}\n\n\treturn current_ev;\n}\n\n\n \nstatic inline int prism2_translate_scan(local_info_t *local,\n\t\t\t\t\tstruct iw_request_info *info,\n\t\t\t\t\tchar *buffer, int buflen)\n{\n\tstruct hfa384x_hostscan_result *scan;\n\tint entry;\n\tchar *current_ev = buffer;\n\tchar *end_buf = buffer + buflen;\n\tstruct list_head *ptr;\n\n\tspin_lock_bh(&local->lock);\n\n\tlist_for_each(ptr, &local->bss_list) {\n\t\tstruct hostap_bss_info *bss;\n\t\tbss = list_entry(ptr, struct hostap_bss_info, list);\n\t\tbss->included = 0;\n\t}\n\n\tfor (entry = 0; entry < local->last_scan_results_count; entry++) {\n\t\tint found = 0;\n\t\tscan = &local->last_scan_results[entry];\n\n\t\t \n\t\tlist_for_each(ptr, &local->bss_list) {\n\t\t\tstruct hostap_bss_info *bss;\n\t\t\tbss = list_entry(ptr, struct hostap_bss_info, list);\n\t\t\tif (ether_addr_equal(bss->bssid, scan->bssid)) {\n\t\t\t\tbss->included = 1;\n\t\t\t\tcurrent_ev = __prism2_translate_scan(\n\t\t\t\t\tlocal, info, scan, bss, current_ev,\n\t\t\t\t\tend_buf);\n\t\t\t\tfound++;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tcurrent_ev = __prism2_translate_scan(\n\t\t\t\tlocal, info, scan, NULL, current_ev, end_buf);\n\t\t}\n\t\t \n\t\tif ((end_buf - current_ev) <= IW_EV_ADDR_LEN) {\n\t\t\t \n\t\t\tspin_unlock_bh(&local->lock);\n\t\t\treturn -E2BIG;\n\t\t}\n\t}\n\n\t \n\tlist_for_each(ptr, &local->bss_list) {\n\t\tstruct hostap_bss_info *bss;\n\t\tbss = list_entry(ptr, struct hostap_bss_info, list);\n\t\tif (bss->included)\n\t\t\tcontinue;\n\t\tcurrent_ev = __prism2_translate_scan(local, info, NULL, bss,\n\t\t\t\t\t\t     current_ev, end_buf);\n\t\t \n\t\tif ((end_buf - current_ev) <= IW_EV_ADDR_LEN) {\n\t\t\t \n\t\t\tspin_unlock_bh(&local->lock);\n\t\t\treturn -E2BIG;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&local->lock);\n\n\treturn current_ev - buffer;\n}\n#endif  \n\n\nstatic inline int prism2_ioctl_giwscan_sta(struct net_device *dev,\n\t\t\t\t\t   struct iw_request_info *info,\n\t\t\t\t\t   struct iw_point *data, char *extra)\n{\n#ifdef PRISM2_NO_STATION_MODES\n\treturn -EOPNOTSUPP;\n#else  \n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint res;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\t \n\tif (local->scan_timestamp &&\n\t    time_before(jiffies, local->scan_timestamp + 3 * HZ)) {\n\t\t \n\t\treturn -EAGAIN;\n\t}\n\tlocal->scan_timestamp = 0;\n\n\tres = prism2_translate_scan(local, info, extra, data->length);\n\n\tif (res >= 0) {\n\t\tdata->length = res;\n\t\treturn 0;\n\t} else {\n\t\tdata->length = 0;\n\t\treturn res;\n\t}\n#endif  \n}\n\n\nstatic int prism2_ioctl_giwscan(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_point *data = &wrqu->data;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint res;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (local->iw_mode == IW_MODE_MASTER) {\n\t\t \n\n\t\t \n\t\tres = prism2_ap_translate_scan(dev, info, extra);\n\t\tif (res >= 0) {\n\t\t\tprintk(KERN_DEBUG \"Scan result translation succeeded \"\n\t\t\t       \"(length=%d)\\n\", res);\n\t\t\tdata->length = res;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"Scan result translation failed (res=%d)\\n\",\n\t\t\t       res);\n\t\t\tdata->length = 0;\n\t\t\treturn res;\n\t\t}\n\t} else {\n\t\t \n\t\treturn prism2_ioctl_giwscan_sta(dev, info, data, extra);\n\t}\n}\n\n\nstatic const struct iw_priv_args prism2_priv[] = {\n\t{ PRISM2_IOCTL_MONITOR,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"monitor\" },\n\t{ PRISM2_IOCTL_READMIF,\n\t  IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 1,\n\t  IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 1, \"readmif\" },\n\t{ PRISM2_IOCTL_WRITEMIF,\n\t  IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 2, 0, \"writemif\" },\n\t{ PRISM2_IOCTL_RESET,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"reset\" },\n\t{ PRISM2_IOCTL_INQUIRE,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"inquire\" },\n\t{ PRISM2_IOCTL_SET_RID_WORD,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0, \"set_rid_word\" },\n\t{ PRISM2_IOCTL_MACCMD,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"maccmd\" },\n\t{ PRISM2_IOCTL_WDS_ADD,\n\t  IW_PRIV_TYPE_ADDR | IW_PRIV_SIZE_FIXED | 1, 0, \"wds_add\" },\n\t{ PRISM2_IOCTL_WDS_DEL,\n\t  IW_PRIV_TYPE_ADDR | IW_PRIV_SIZE_FIXED | 1, 0, \"wds_del\" },\n\t{ PRISM2_IOCTL_ADDMAC,\n\t  IW_PRIV_TYPE_ADDR | IW_PRIV_SIZE_FIXED | 1, 0, \"addmac\" },\n\t{ PRISM2_IOCTL_DELMAC,\n\t  IW_PRIV_TYPE_ADDR | IW_PRIV_SIZE_FIXED | 1, 0, \"delmac\" },\n\t{ PRISM2_IOCTL_KICKMAC,\n\t  IW_PRIV_TYPE_ADDR | IW_PRIV_SIZE_FIXED | 1, 0, \"kickmac\" },\n\t \n\t{ PRISM2_IOCTL_PRISM2_PARAM,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0, \"prism2_param\" },\n\t{ PRISM2_IOCTL_GET_PRISM2_PARAM,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getprism2_param\" },\n\t \n\t{ PRISM2_IOCTL_PRISM2_PARAM,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"\" },\n\t{ PRISM2_IOCTL_GET_PRISM2_PARAM,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"\" },\n\t \n\t{ PRISM2_PARAM_TXRATECTRL,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"txratectrl\" },\n\t{ PRISM2_PARAM_TXRATECTRL,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"gettxratectrl\" },\n\t{ PRISM2_PARAM_BEACON_INT,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"beacon_int\" },\n\t{ PRISM2_PARAM_BEACON_INT,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getbeacon_int\" },\n#ifndef PRISM2_NO_STATION_MODES\n\t{ PRISM2_PARAM_PSEUDO_IBSS,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"pseudo_ibss\" },\n\t{ PRISM2_PARAM_PSEUDO_IBSS,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getpseudo_ibss\" },\n#endif  \n\t{ PRISM2_PARAM_ALC,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"alc\" },\n\t{ PRISM2_PARAM_ALC,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getalc\" },\n\t{ PRISM2_PARAM_DUMP,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"dump\" },\n\t{ PRISM2_PARAM_DUMP,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getdump\" },\n\t{ PRISM2_PARAM_OTHER_AP_POLICY,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"other_ap_policy\" },\n\t{ PRISM2_PARAM_OTHER_AP_POLICY,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getother_ap_pol\" },\n\t{ PRISM2_PARAM_AP_MAX_INACTIVITY,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"max_inactivity\" },\n\t{ PRISM2_PARAM_AP_MAX_INACTIVITY,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getmax_inactivi\" },\n\t{ PRISM2_PARAM_AP_BRIDGE_PACKETS,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"bridge_packets\" },\n\t{ PRISM2_PARAM_AP_BRIDGE_PACKETS,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getbridge_packe\" },\n\t{ PRISM2_PARAM_DTIM_PERIOD,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"dtim_period\" },\n\t{ PRISM2_PARAM_DTIM_PERIOD,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getdtim_period\" },\n\t{ PRISM2_PARAM_AP_NULLFUNC_ACK,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"nullfunc_ack\" },\n\t{ PRISM2_PARAM_AP_NULLFUNC_ACK,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getnullfunc_ack\" },\n\t{ PRISM2_PARAM_MAX_WDS,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"max_wds\" },\n\t{ PRISM2_PARAM_MAX_WDS,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getmax_wds\" },\n\t{ PRISM2_PARAM_AP_AUTOM_AP_WDS,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"autom_ap_wds\" },\n\t{ PRISM2_PARAM_AP_AUTOM_AP_WDS,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getautom_ap_wds\" },\n\t{ PRISM2_PARAM_AP_AUTH_ALGS,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"ap_auth_algs\" },\n\t{ PRISM2_PARAM_AP_AUTH_ALGS,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getap_auth_algs\" },\n\t{ PRISM2_PARAM_MONITOR_ALLOW_FCSERR,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"allow_fcserr\" },\n\t{ PRISM2_PARAM_MONITOR_ALLOW_FCSERR,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getallow_fcserr\" },\n\t{ PRISM2_PARAM_HOST_ENCRYPT,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"host_encrypt\" },\n\t{ PRISM2_PARAM_HOST_ENCRYPT,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"gethost_encrypt\" },\n\t{ PRISM2_PARAM_HOST_DECRYPT,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"host_decrypt\" },\n\t{ PRISM2_PARAM_HOST_DECRYPT,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"gethost_decrypt\" },\n#ifndef PRISM2_NO_STATION_MODES\n\t{ PRISM2_PARAM_HOST_ROAMING,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"host_roaming\" },\n\t{ PRISM2_PARAM_HOST_ROAMING,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"gethost_roaming\" },\n#endif  \n\t{ PRISM2_PARAM_BCRX_STA_KEY,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"bcrx_sta_key\" },\n\t{ PRISM2_PARAM_BCRX_STA_KEY,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getbcrx_sta_key\" },\n\t{ PRISM2_PARAM_IEEE_802_1X,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"ieee_802_1x\" },\n\t{ PRISM2_PARAM_IEEE_802_1X,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getieee_802_1x\" },\n\t{ PRISM2_PARAM_ANTSEL_TX,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"antsel_tx\" },\n\t{ PRISM2_PARAM_ANTSEL_TX,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getantsel_tx\" },\n\t{ PRISM2_PARAM_ANTSEL_RX,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"antsel_rx\" },\n\t{ PRISM2_PARAM_ANTSEL_RX,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getantsel_rx\" },\n\t{ PRISM2_PARAM_MONITOR_TYPE,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"monitor_type\" },\n\t{ PRISM2_PARAM_MONITOR_TYPE,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getmonitor_type\" },\n\t{ PRISM2_PARAM_WDS_TYPE,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"wds_type\" },\n\t{ PRISM2_PARAM_WDS_TYPE,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getwds_type\" },\n\t{ PRISM2_PARAM_HOSTSCAN,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"hostscan\" },\n\t{ PRISM2_PARAM_HOSTSCAN,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"gethostscan\" },\n\t{ PRISM2_PARAM_AP_SCAN,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"ap_scan\" },\n\t{ PRISM2_PARAM_AP_SCAN,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getap_scan\" },\n\t{ PRISM2_PARAM_ENH_SEC,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"enh_sec\" },\n\t{ PRISM2_PARAM_ENH_SEC,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getenh_sec\" },\n#ifdef PRISM2_IO_DEBUG\n\t{ PRISM2_PARAM_IO_DEBUG,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"io_debug\" },\n\t{ PRISM2_PARAM_IO_DEBUG,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getio_debug\" },\n#endif  \n\t{ PRISM2_PARAM_BASIC_RATES,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"basic_rates\" },\n\t{ PRISM2_PARAM_BASIC_RATES,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getbasic_rates\" },\n\t{ PRISM2_PARAM_OPER_RATES,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"oper_rates\" },\n\t{ PRISM2_PARAM_OPER_RATES,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getoper_rates\" },\n\t{ PRISM2_PARAM_HOSTAPD,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"hostapd\" },\n\t{ PRISM2_PARAM_HOSTAPD,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"gethostapd\" },\n\t{ PRISM2_PARAM_HOSTAPD_STA,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"hostapd_sta\" },\n\t{ PRISM2_PARAM_HOSTAPD_STA,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"gethostapd_sta\" },\n\t{ PRISM2_PARAM_WPA,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"wpa\" },\n\t{ PRISM2_PARAM_WPA,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getwpa\" },\n\t{ PRISM2_PARAM_PRIVACY_INVOKED,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"privacy_invoked\" },\n\t{ PRISM2_PARAM_PRIVACY_INVOKED,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getprivacy_invo\" },\n\t{ PRISM2_PARAM_TKIP_COUNTERMEASURES,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"tkip_countermea\" },\n\t{ PRISM2_PARAM_TKIP_COUNTERMEASURES,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"gettkip_counter\" },\n\t{ PRISM2_PARAM_DROP_UNENCRYPTED,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"drop_unencrypte\" },\n\t{ PRISM2_PARAM_DROP_UNENCRYPTED,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getdrop_unencry\" },\n\t{ PRISM2_PARAM_SCAN_CHANNEL_MASK,\n\t  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"scan_channels\" },\n\t{ PRISM2_PARAM_SCAN_CHANNEL_MASK,\n\t  0, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getscan_channel\" },\n};\n\n\nstatic int prism2_ioctl_priv_inquire(struct net_device *dev, int *i)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (local->func->cmd(dev, HFA384X_CMDCODE_INQUIRE, *i, NULL, NULL))\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\n\nstatic int prism2_ioctl_priv_prism2_param(struct net_device *dev,\n\t\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t\t  union iwreq_data *uwrq, char *extra)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint *i = (int *) extra;\n\tint param = *i;\n\tint value = *(i + 1);\n\tint ret = 0;\n\tu16 val;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tswitch (param) {\n\tcase PRISM2_PARAM_TXRATECTRL:\n\t\tlocal->fw_tx_rate_control = value;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_BEACON_INT:\n\t\tif (hostap_set_word(dev, HFA384X_RID_CNFBEACONINT, value) ||\n\t\t    local->func->reset_port(dev))\n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\tlocal->beacon_int = value;\n\t\tbreak;\n\n#ifndef PRISM2_NO_STATION_MODES\n\tcase PRISM2_PARAM_PSEUDO_IBSS:\n\t\tif (value == local->pseudo_adhoc)\n\t\t\tbreak;\n\n\t\tif (value != 0 && value != 1) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tprintk(KERN_DEBUG \"prism2: %s: pseudo IBSS change %d -> %d\\n\",\n\t\t       dev->name, local->pseudo_adhoc, value);\n\t\tlocal->pseudo_adhoc = value;\n\t\tif (local->iw_mode != IW_MODE_ADHOC)\n\t\t\tbreak;\n\n\t\tif (hostap_set_word(dev, HFA384X_RID_CNFPORTTYPE,\n\t\t\t\t    hostap_get_porttype(local))) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (local->func->reset_port(dev))\n\t\t\tret = -EINVAL;\n\t\tbreak;\n#endif  \n\n\tcase PRISM2_PARAM_ALC:\n\t\tprintk(KERN_DEBUG \"%s: %s ALC\\n\", dev->name,\n\t\t       value == 0 ? \"Disabling\" : \"Enabling\");\n\t\tval = HFA384X_TEST_CFG_BIT_ALC;\n\t\tlocal->func->cmd(dev, HFA384X_CMDCODE_TEST |\n\t\t\t\t (HFA384X_TEST_CFG_BITS << 8),\n\t\t\t\t value == 0 ? 0 : 1, &val, NULL);\n\t\tbreak;\n\n\tcase PRISM2_PARAM_DUMP:\n\t\tlocal->frame_dump = value;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_OTHER_AP_POLICY:\n\t\tif (value < 0 || value > 3) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (local->ap != NULL)\n\t\t\tlocal->ap->ap_policy = value;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_AP_MAX_INACTIVITY:\n\t\tif (value < 0 || value > 7 * 24 * 60 * 60) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (local->ap != NULL)\n\t\t\tlocal->ap->max_inactivity = value * HZ;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_AP_BRIDGE_PACKETS:\n\t\tif (local->ap != NULL)\n\t\t\tlocal->ap->bridge_packets = value;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_DTIM_PERIOD:\n\t\tif (value < 0 || value > 65535) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (hostap_set_word(dev, HFA384X_RID_CNFOWNDTIMPERIOD, value)\n\t\t    || local->func->reset_port(dev))\n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\tlocal->dtim_period = value;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_AP_NULLFUNC_ACK:\n\t\tif (local->ap != NULL)\n\t\t\tlocal->ap->nullfunc_ack = value;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_MAX_WDS:\n\t\tlocal->wds_max_connections = value;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_AP_AUTOM_AP_WDS:\n\t\tif (local->ap != NULL) {\n\t\t\tif (!local->ap->autom_ap_wds && value) {\n\t\t\t\t \n\t\t\t\thostap_add_wds_links(local);\n\t\t\t}\n\t\t\tlocal->ap->autom_ap_wds = value;\n\t\t}\n\t\tbreak;\n\n\tcase PRISM2_PARAM_AP_AUTH_ALGS:\n\t\tlocal->auth_algs = value;\n\t\tif (hostap_set_auth_algs(local))\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_MONITOR_ALLOW_FCSERR:\n\t\tlocal->monitor_allow_fcserr = value;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_HOST_ENCRYPT:\n\t\tlocal->host_encrypt = value;\n\t\tif (hostap_set_encryption(local) ||\n\t\t    local->func->reset_port(dev))\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_HOST_DECRYPT:\n\t\tlocal->host_decrypt = value;\n\t\tif (hostap_set_encryption(local) ||\n\t\t    local->func->reset_port(dev))\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\n#ifndef PRISM2_NO_STATION_MODES\n\tcase PRISM2_PARAM_HOST_ROAMING:\n\t\tif (value < 0 || value > 2) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tlocal->host_roaming = value;\n\t\tif (hostap_set_roaming(local) || local->func->reset_port(dev))\n\t\t\tret = -EINVAL;\n\t\tbreak;\n#endif  \n\n\tcase PRISM2_PARAM_BCRX_STA_KEY:\n\t\tlocal->bcrx_sta_key = value;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_IEEE_802_1X:\n\t\tlocal->ieee_802_1x = value;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_ANTSEL_TX:\n\t\tif (value < 0 || value > HOSTAP_ANTSEL_HIGH) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tlocal->antsel_tx = value;\n\t\thostap_set_antsel(local);\n\t\tbreak;\n\n\tcase PRISM2_PARAM_ANTSEL_RX:\n\t\tif (value < 0 || value > HOSTAP_ANTSEL_HIGH) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tlocal->antsel_rx = value;\n\t\thostap_set_antsel(local);\n\t\tbreak;\n\n\tcase PRISM2_PARAM_MONITOR_TYPE:\n\t\tif (value != PRISM2_MONITOR_80211 &&\n\t\t    value != PRISM2_MONITOR_CAPHDR &&\n\t\t    value != PRISM2_MONITOR_PRISM &&\n\t\t    value != PRISM2_MONITOR_RADIOTAP) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tlocal->monitor_type = value;\n\t\tif (local->iw_mode == IW_MODE_MONITOR)\n\t\t\thostap_monitor_set_type(local);\n\t\tbreak;\n\n\tcase PRISM2_PARAM_WDS_TYPE:\n\t\tlocal->wds_type = value;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_HOSTSCAN:\n\t{\n\t\tstruct hfa384x_hostscan_request scan_req;\n\t\tu16 rate;\n\n\t\tmemset(&scan_req, 0, sizeof(scan_req));\n\t\tscan_req.channel_list = cpu_to_le16(0x3fff);\n\t\tswitch (value) {\n\t\tcase 1: rate = HFA384X_RATES_1MBPS; break;\n\t\tcase 2: rate = HFA384X_RATES_2MBPS; break;\n\t\tcase 3: rate = HFA384X_RATES_5MBPS; break;\n\t\tcase 4: rate = HFA384X_RATES_11MBPS; break;\n\t\tdefault: rate = HFA384X_RATES_1MBPS; break;\n\t\t}\n\t\tscan_req.txrate = cpu_to_le16(rate);\n\t\t \n\n\t\tif (local->iw_mode == IW_MODE_MASTER) {\n\t\t\tif (hostap_set_word(dev, HFA384X_RID_CNFPORTTYPE,\n\t\t\t\t\t    HFA384X_PORTTYPE_BSS) ||\n\t\t\t    local->func->reset_port(dev))\n\t\t\t\tprintk(KERN_DEBUG \"Leaving Host AP mode \"\n\t\t\t\t       \"for HostScan failed\\n\");\n\t\t}\n\n\t\tif (local->func->set_rid(dev, HFA384X_RID_HOSTSCAN, &scan_req,\n\t\t\t\t\t sizeof(scan_req))) {\n\t\t\tprintk(KERN_DEBUG \"HOSTSCAN failed\\n\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tif (local->iw_mode == IW_MODE_MASTER) {\n\t\t\twait_queue_entry_t __wait;\n\t\t\tinit_waitqueue_entry(&__wait, current);\n\t\t\tadd_wait_queue(&local->hostscan_wq, &__wait);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tschedule_timeout(HZ);\n\t\t\tif (signal_pending(current))\n\t\t\t\tret = -EINTR;\n\t\t\tset_current_state(TASK_RUNNING);\n\t\t\tremove_wait_queue(&local->hostscan_wq, &__wait);\n\n\t\t\tif (hostap_set_word(dev, HFA384X_RID_CNFPORTTYPE,\n\t\t\t\t\t    HFA384X_PORTTYPE_HOSTAP) ||\n\t\t\t    local->func->reset_port(dev))\n\t\t\t\tprintk(KERN_DEBUG \"Returning to Host AP mode \"\n\t\t\t\t       \"after HostScan failed\\n\");\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase PRISM2_PARAM_AP_SCAN:\n\t\tlocal->passive_scan_interval = value;\n\t\tif (timer_pending(&local->passive_scan_timer))\n\t\t\tdel_timer(&local->passive_scan_timer);\n\t\tif (value > 0 && value < INT_MAX / HZ) {\n\t\t\tlocal->passive_scan_timer.expires = jiffies +\n\t\t\t\tlocal->passive_scan_interval * HZ;\n\t\t\tadd_timer(&local->passive_scan_timer);\n\t\t}\n\t\tbreak;\n\n\tcase PRISM2_PARAM_ENH_SEC:\n\t\tif (value < 0 || value > 3) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tlocal->enh_sec = value;\n\t\tif (hostap_set_word(dev, HFA384X_RID_CNFENHSECURITY,\n\t\t\t\t    local->enh_sec) ||\n\t\t    local->func->reset_port(dev)) {\n\t\t\tprintk(KERN_INFO \"%s: cnfEnhSecurity requires STA f/w \"\n\t\t\t       \"1.6.3 or newer\\n\", dev->name);\n\t\t\tret = -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\n#ifdef PRISM2_IO_DEBUG\n\tcase PRISM2_PARAM_IO_DEBUG:\n\t\tlocal->io_debug_enabled = value;\n\t\tbreak;\n#endif  \n\n\tcase PRISM2_PARAM_BASIC_RATES:\n\t\tif ((value & local->tx_rate_control) != value || value == 0) {\n\t\t\tprintk(KERN_INFO \"%s: invalid basic rate set - basic \"\n\t\t\t       \"rates must be in supported rate set\\n\",\n\t\t\t       dev->name);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tlocal->basic_rates = value;\n\t\tif (hostap_set_word(dev, HFA384X_RID_CNFBASICRATES,\n\t\t\t\t    local->basic_rates) ||\n\t\t    local->func->reset_port(dev))\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_OPER_RATES:\n\t\tlocal->tx_rate_control = value;\n\t\tif (hostap_set_rate(dev))\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_HOSTAPD:\n\t\tret = hostap_set_hostapd(local, value, 1);\n\t\tbreak;\n\n\tcase PRISM2_PARAM_HOSTAPD_STA:\n\t\tret = hostap_set_hostapd_sta(local, value, 1);\n\t\tbreak;\n\n\tcase PRISM2_PARAM_WPA:\n\t\tlocal->wpa = value;\n\t\tif (local->sta_fw_ver < PRISM2_FW_VER(1,7,0))\n\t\t\tret = -EOPNOTSUPP;\n\t\telse if (hostap_set_word(dev, HFA384X_RID_SSNHANDLINGMODE,\n\t\t\t\t\t value ? 1 : 0))\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_PRIVACY_INVOKED:\n\t\tlocal->privacy_invoked = value;\n\t\tif (hostap_set_encryption(local) ||\n\t\t    local->func->reset_port(dev))\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_TKIP_COUNTERMEASURES:\n\t\tlocal->tkip_countermeasures = value;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_DROP_UNENCRYPTED:\n\t\tlocal->drop_unencrypted = value;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_SCAN_CHANNEL_MASK:\n\t\tlocal->scan_channel_mask = value;\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_DEBUG \"%s: prism2_param: unknown param %d\\n\",\n\t\t       dev->name, param);\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n\nstatic int prism2_ioctl_priv_get_prism2_param(struct net_device *dev,\n\t\t\t\t\t      struct iw_request_info *info,\n\t\t\t\t\t      union iwreq_data *wrqu, char *extra)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint *param = (int *) extra;\n\tint ret = 0;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tswitch (*param) {\n\tcase PRISM2_PARAM_TXRATECTRL:\n\t\t*param = local->fw_tx_rate_control;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_BEACON_INT:\n\t\t*param = local->beacon_int;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_PSEUDO_IBSS:\n\t\t*param = local->pseudo_adhoc;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_ALC:\n\t\tret = -EOPNOTSUPP;  \n\t\tbreak;\n\n\tcase PRISM2_PARAM_DUMP:\n\t\t*param = local->frame_dump;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_OTHER_AP_POLICY:\n\t\tif (local->ap != NULL)\n\t\t\t*param = local->ap->ap_policy;\n\t\telse\n\t\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_AP_MAX_INACTIVITY:\n\t\tif (local->ap != NULL)\n\t\t\t*param = local->ap->max_inactivity / HZ;\n\t\telse\n\t\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_AP_BRIDGE_PACKETS:\n\t\tif (local->ap != NULL)\n\t\t\t*param = local->ap->bridge_packets;\n\t\telse\n\t\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_DTIM_PERIOD:\n\t\t*param = local->dtim_period;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_AP_NULLFUNC_ACK:\n\t\tif (local->ap != NULL)\n\t\t\t*param = local->ap->nullfunc_ack;\n\t\telse\n\t\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_MAX_WDS:\n\t\t*param = local->wds_max_connections;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_AP_AUTOM_AP_WDS:\n\t\tif (local->ap != NULL)\n\t\t\t*param = local->ap->autom_ap_wds;\n\t\telse\n\t\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_AP_AUTH_ALGS:\n\t\t*param = local->auth_algs;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_MONITOR_ALLOW_FCSERR:\n\t\t*param = local->monitor_allow_fcserr;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_HOST_ENCRYPT:\n\t\t*param = local->host_encrypt;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_HOST_DECRYPT:\n\t\t*param = local->host_decrypt;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_HOST_ROAMING:\n\t\t*param = local->host_roaming;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_BCRX_STA_KEY:\n\t\t*param = local->bcrx_sta_key;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_IEEE_802_1X:\n\t\t*param = local->ieee_802_1x;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_ANTSEL_TX:\n\t\t*param = local->antsel_tx;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_ANTSEL_RX:\n\t\t*param = local->antsel_rx;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_MONITOR_TYPE:\n\t\t*param = local->monitor_type;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_WDS_TYPE:\n\t\t*param = local->wds_type;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_HOSTSCAN:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_AP_SCAN:\n\t\t*param = local->passive_scan_interval;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_ENH_SEC:\n\t\t*param = local->enh_sec;\n\t\tbreak;\n\n#ifdef PRISM2_IO_DEBUG\n\tcase PRISM2_PARAM_IO_DEBUG:\n\t\t*param = local->io_debug_enabled;\n\t\tbreak;\n#endif  \n\n\tcase PRISM2_PARAM_BASIC_RATES:\n\t\t*param = local->basic_rates;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_OPER_RATES:\n\t\t*param = local->tx_rate_control;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_HOSTAPD:\n\t\t*param = local->hostapd;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_HOSTAPD_STA:\n\t\t*param = local->hostapd_sta;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_WPA:\n\t\tif (local->sta_fw_ver < PRISM2_FW_VER(1,7,0))\n\t\t\tret = -EOPNOTSUPP;\n\t\t*param = local->wpa;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_PRIVACY_INVOKED:\n\t\t*param = local->privacy_invoked;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_TKIP_COUNTERMEASURES:\n\t\t*param = local->tkip_countermeasures;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_DROP_UNENCRYPTED:\n\t\t*param = local->drop_unencrypted;\n\t\tbreak;\n\n\tcase PRISM2_PARAM_SCAN_CHANNEL_MASK:\n\t\t*param = local->scan_channel_mask;\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_DEBUG \"%s: get_prism2_param: unknown param %d\\n\",\n\t\t       dev->name, *param);\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n\nstatic int prism2_ioctl_priv_readmif(struct net_device *dev,\n\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tu16 resp0;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (local->func->cmd(dev, HFA384X_CMDCODE_READMIF, *extra, NULL,\n\t\t\t     &resp0))\n\t\treturn -EOPNOTSUPP;\n\telse\n\t\t*extra = resp0;\n\n\treturn 0;\n}\n\n\nstatic int prism2_ioctl_priv_writemif(struct net_device *dev,\n\t\t\t\t      struct iw_request_info *info,\n\t\t\t\t      union iwreq_data *wrqu, char *extra)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tu16 cr, val;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tcr = *extra;\n\tval = *(extra + 1);\n\tif (local->func->cmd(dev, HFA384X_CMDCODE_WRITEMIF, cr, &val, NULL))\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\n\nstatic int prism2_ioctl_priv_monitor(struct net_device *dev, int *i)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint ret = 0;\n\tunion iwreq_data wrqu;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tprintk(KERN_DEBUG \"%s: process %d (%s) used deprecated iwpriv monitor \"\n\t       \"- update software to use iwconfig mode monitor\\n\",\n\t       dev->name, task_pid_nr(current), current->comm);\n\n\t \n\n\tif (*i == 0) {\n\t\t \n\t\twrqu.mode = IW_MODE_MASTER;\n\t\tret = prism2_ioctl_siwmode(dev, NULL, &wrqu, NULL);\n\t} else if (*i == 1) {\n\t\t \n\t\tret = -EOPNOTSUPP;\n\t} else if (*i == 2 || *i == 3) {\n\t\tswitch (*i) {\n\t\tcase 2:\n\t\t\tlocal->monitor_type = PRISM2_MONITOR_80211;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tlocal->monitor_type = PRISM2_MONITOR_PRISM;\n\t\t\tbreak;\n\t\t}\n\t\twrqu.mode = IW_MODE_MONITOR;\n\t\tret = prism2_ioctl_siwmode(dev, NULL, &wrqu, NULL);\n\t\thostap_monitor_mode_enable(local);\n\t} else\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\n\nstatic int prism2_ioctl_priv_reset(struct net_device *dev, int *i)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tprintk(KERN_DEBUG \"%s: manual reset request(%d)\\n\", dev->name, *i);\n\tswitch (*i) {\n\tcase 0:\n\t\t \n\t\tlocal->func->hw_shutdown(dev, 1);\n\t\tlocal->func->hw_config(dev, 0);\n\t\tbreak;\n\n\tcase 1:\n\t\t \n\t\tlocal->func->hw_reset(dev);\n\t\tbreak;\n\n\tcase 2:\n\t\t \n\t\tlocal->func->reset_port(dev);\n\t\tbreak;\n\n\tcase 3:\n\t\tprism2_sta_deauth(local, WLAN_REASON_DEAUTH_LEAVING);\n\t\tif (local->func->cmd(dev, HFA384X_CMDCODE_DISABLE, 0, NULL,\n\t\t\t\t     NULL))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase 4:\n\t\tif (local->func->cmd(dev, HFA384X_CMDCODE_ENABLE, 0, NULL,\n\t\t\t\t     NULL))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_DEBUG \"Unknown reset request %d\\n\", *i);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int prism2_ioctl_priv_set_rid_word(struct net_device *dev, int *i)\n{\n\tint rid = *i;\n\tint value = *(i + 1);\n\n\tprintk(KERN_DEBUG \"%s: Set RID[0x%X] = %d\\n\", dev->name, rid, value);\n\n\tif (hostap_set_word(dev, rid, value))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\nstatic int ap_mac_cmd_ioctl(local_info_t *local, int *cmd)\n{\n\tint ret = 0;\n\n\tswitch (*cmd) {\n\tcase AP_MAC_CMD_POLICY_OPEN:\n\t\tlocal->ap->mac_restrictions.policy = MAC_POLICY_OPEN;\n\t\tbreak;\n\tcase AP_MAC_CMD_POLICY_ALLOW:\n\t\tlocal->ap->mac_restrictions.policy = MAC_POLICY_ALLOW;\n\t\tbreak;\n\tcase AP_MAC_CMD_POLICY_DENY:\n\t\tlocal->ap->mac_restrictions.policy = MAC_POLICY_DENY;\n\t\tbreak;\n\tcase AP_MAC_CMD_FLUSH:\n\t\tap_control_flush_macs(&local->ap->mac_restrictions);\n\t\tbreak;\n\tcase AP_MAC_CMD_KICKALL:\n\t\tap_control_kickall(local->ap);\n\t\thostap_deauth_all_stas(local->dev, local->ap, 0);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n#endif  \n\n\n#ifdef PRISM2_DOWNLOAD_SUPPORT\nstatic int prism2_ioctl_priv_download(local_info_t *local, struct iw_point *p)\n{\n\tstruct prism2_download_param *param;\n\tint ret = 0;\n\n\tif (p->length < sizeof(struct prism2_download_param) ||\n\t    p->length > 1024 || !p->pointer)\n\t\treturn -EINVAL;\n\n\tparam = memdup_user(p->pointer, p->length);\n\tif (IS_ERR(param)) {\n\t\treturn PTR_ERR(param);\n\t}\n\n\tif (p->length < sizeof(struct prism2_download_param) +\n\t    param->num_areas * sizeof(struct prism2_download_area)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = local->func->download(local, param);\n\n out:\n\tkfree(param);\n\treturn ret;\n}\n#endif  \n\n\nstatic int prism2_set_genericelement(struct net_device *dev, u8 *elem,\n\t\t\t\t     size_t len)\n{\n\tstruct hostap_interface *iface = netdev_priv(dev);\n\tlocal_info_t *local = iface->local;\n\tu8 *buf;\n\n\t \n\tbuf = kmalloc(len + 2, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\t*((__le16 *) buf) = cpu_to_le16(len);\n\tmemcpy(buf + 2, elem, len);\n\n\tkfree(local->generic_elem);\n\tlocal->generic_elem = buf;\n\tlocal->generic_elem_len = len + 2;\n\n\treturn local->func->set_rid(local->dev, HFA384X_RID_GENERICELEMENT,\n\t\t\t\t    buf, len + 2);\n}\n\n\nstatic int prism2_ioctl_siwauth(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *data = &wrqu->param;\n\tstruct hostap_interface *iface = netdev_priv(dev);\n\tlocal_info_t *local = iface->local;\n\n\tswitch (data->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_KEY_MGMT:\n\t\t \n\t\tbreak;\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\tlocal->tkip_countermeasures = data->value;\n\t\tbreak;\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\tlocal->drop_unencrypted = data->value;\n\t\tbreak;\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tlocal->auth_algs = data->value;\n\t\tbreak;\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tif (data->value == 0) {\n\t\t\tlocal->wpa = 0;\n\t\t\tif (local->sta_fw_ver < PRISM2_FW_VER(1,7,0))\n\t\t\t\tbreak;\n\t\t\tprism2_set_genericelement(dev, \"\", 0);\n\t\t\tlocal->host_roaming = 0;\n\t\t\tlocal->privacy_invoked = 0;\n\t\t\tif (hostap_set_word(dev, HFA384X_RID_SSNHANDLINGMODE,\n\t\t\t\t\t    0) ||\n\t\t\t    hostap_set_roaming(local) ||\n\t\t\t    hostap_set_encryption(local) ||\n\t\t\t    local->func->reset_port(dev))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (local->sta_fw_ver < PRISM2_FW_VER(1,7,0))\n\t\t\treturn -EOPNOTSUPP;\n\t\tlocal->host_roaming = 2;\n\t\tlocal->privacy_invoked = 1;\n\t\tlocal->wpa = 1;\n\t\tif (hostap_set_word(dev, HFA384X_RID_SSNHANDLINGMODE, 1) ||\n\t\t    hostap_set_roaming(local) ||\n\t\t    hostap_set_encryption(local) ||\n\t\t    local->func->reset_port(dev))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\t\tlocal->ieee_802_1x = data->value;\n\t\tbreak;\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\t\tlocal->privacy_invoked = data->value;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n\nstatic int prism2_ioctl_giwauth(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *data = &wrqu->param;\n\tstruct hostap_interface *iface = netdev_priv(dev);\n\tlocal_info_t *local = iface->local;\n\n\tswitch (data->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_KEY_MGMT:\n\t\t \n\t\treturn -EOPNOTSUPP;\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\tdata->value = local->tkip_countermeasures;\n\t\tbreak;\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\tdata->value = local->drop_unencrypted;\n\t\tbreak;\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tdata->value = local->auth_algs;\n\t\tbreak;\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tdata->value = local->wpa;\n\t\tbreak;\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\t\tdata->value = local->ieee_802_1x;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n\nstatic int prism2_ioctl_siwencodeext(struct net_device *dev,\n\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_point *erq = &wrqu->encoding;\n\tstruct hostap_interface *iface = netdev_priv(dev);\n\tlocal_info_t *local = iface->local;\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *) extra;\n\tint i, ret = 0;\n\tstruct lib80211_crypto_ops *ops;\n\tstruct lib80211_crypt_data **crypt;\n\tvoid *sta_ptr;\n\tu8 *addr;\n\tconst char *alg, *module;\n\n\ti = erq->flags & IW_ENCODE_INDEX;\n\tif (i > WEP_KEYS)\n\t\treturn -EINVAL;\n\tif (i < 1 || i > WEP_KEYS)\n\t\ti = local->crypt_info.tx_keyidx;\n\telse\n\t\ti--;\n\tif (i < 0 || i >= WEP_KEYS)\n\t\treturn -EINVAL;\n\n\taddr = ext->addr.sa_data;\n\tif (is_broadcast_ether_addr(addr)) {\n\t\tsta_ptr = NULL;\n\t\tcrypt = &local->crypt_info.crypt[i];\n\t} else {\n\t\tif (i != 0)\n\t\t\treturn -EINVAL;\n\t\tsta_ptr = ap_crypt_get_ptrs(local->ap, addr, 0, &crypt);\n\t\tif (sta_ptr == NULL) {\n\t\t\tif (local->iw_mode == IW_MODE_INFRA) {\n\t\t\t\t \n\t\t\t\ti = 0;\n\t\t\t\tcrypt = &local->crypt_info.crypt[i];\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif ((erq->flags & IW_ENCODE_DISABLED) ||\n\t    ext->alg == IW_ENCODE_ALG_NONE) {\n\t\tif (*crypt)\n\t\t\tlib80211_crypt_delayed_deinit(&local->crypt_info, crypt);\n\t\tgoto done;\n\t}\n\n\tswitch (ext->alg) {\n\tcase IW_ENCODE_ALG_WEP:\n\t\talg = \"WEP\";\n\t\tmodule = \"lib80211_crypt_wep\";\n\t\tbreak;\n\tcase IW_ENCODE_ALG_TKIP:\n\t\talg = \"TKIP\";\n\t\tmodule = \"lib80211_crypt_tkip\";\n\t\tbreak;\n\tcase IW_ENCODE_ALG_CCMP:\n\t\talg = \"CCMP\";\n\t\tmodule = \"lib80211_crypt_ccmp\";\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_DEBUG \"%s: unsupported algorithm %d\\n\",\n\t\t       local->dev->name, ext->alg);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto done;\n\t}\n\n\tops = lib80211_get_crypto_ops(alg);\n\tif (ops == NULL) {\n\t\trequest_module(module);\n\t\tops = lib80211_get_crypto_ops(alg);\n\t}\n\tif (ops == NULL) {\n\t\tprintk(KERN_DEBUG \"%s: unknown crypto alg '%s'\\n\",\n\t\t       local->dev->name, alg);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto done;\n\t}\n\n\tif (sta_ptr || ext->alg != IW_ENCODE_ALG_WEP) {\n\t\t \n\t\tlocal->host_decrypt = local->host_encrypt = 1;\n\t}\n\n\tif (*crypt == NULL || (*crypt)->ops != ops) {\n\t\tstruct lib80211_crypt_data *new_crypt;\n\n\t\tlib80211_crypt_delayed_deinit(&local->crypt_info, crypt);\n\n\t\tnew_crypt = kzalloc(sizeof(struct lib80211_crypt_data),\n\t\t\t\tGFP_KERNEL);\n\t\tif (new_crypt == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t\tnew_crypt->ops = ops;\n\t\tif (new_crypt->ops && try_module_get(new_crypt->ops->owner))\n\t\t\tnew_crypt->priv = new_crypt->ops->init(i);\n\t\tif (new_crypt->priv == NULL) {\n\t\t\tkfree(new_crypt);\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\n\t\t*crypt = new_crypt;\n\t}\n\n\t \n\tif ((!(ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) || ext->key_len > 0)\n\t    && (*crypt)->ops->set_key &&\n\t    (*crypt)->ops->set_key(ext->key, ext->key_len, ext->rx_seq,\n\t\t\t\t   (*crypt)->priv) < 0) {\n\t\tprintk(KERN_DEBUG \"%s: key setting failed\\n\",\n\t\t       local->dev->name);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {\n\t\tif (!sta_ptr)\n\t\t\tlocal->crypt_info.tx_keyidx = i;\n\t}\n\n\n\tif (sta_ptr == NULL && ext->key_len > 0) {\n\t\tint first = 1, j;\n\t\tfor (j = 0; j < WEP_KEYS; j++) {\n\t\t\tif (j != i && local->crypt_info.crypt[j]) {\n\t\t\t\tfirst = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (first)\n\t\t\tlocal->crypt_info.tx_keyidx = i;\n\t}\n\n done:\n\tif (sta_ptr)\n\t\thostap_handle_sta_release(sta_ptr);\n\n\tlocal->open_wep = erq->flags & IW_ENCODE_OPEN;\n\n\t \n\tif (ret == 0 &&\n\t    (hostap_set_encryption(local) ||\n\t     (local->iw_mode != IW_MODE_INFRA &&\n\t      local->func->reset_port(local->dev))))\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\n\nstatic int prism2_ioctl_giwencodeext(struct net_device *dev,\n\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_point *erq = &wrqu->encoding;\n\tstruct hostap_interface *iface = netdev_priv(dev);\n\tlocal_info_t *local = iface->local;\n\tstruct lib80211_crypt_data **crypt;\n\tvoid *sta_ptr;\n\tint max_key_len, i;\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *) extra;\n\tu8 *addr;\n\n\tmax_key_len = erq->length - sizeof(*ext);\n\tif (max_key_len < 0)\n\t\treturn -EINVAL;\n\n\ti = erq->flags & IW_ENCODE_INDEX;\n\tif (i < 1 || i > WEP_KEYS)\n\t\ti = local->crypt_info.tx_keyidx;\n\telse\n\t\ti--;\n\n\taddr = ext->addr.sa_data;\n\tif (is_broadcast_ether_addr(addr)) {\n\t\tsta_ptr = NULL;\n\t\tcrypt = &local->crypt_info.crypt[i];\n\t} else {\n\t\ti = 0;\n\t\tsta_ptr = ap_crypt_get_ptrs(local->ap, addr, 0, &crypt);\n\t\tif (sta_ptr == NULL)\n\t\t\treturn -EINVAL;\n\t}\n\terq->flags = i + 1;\n\tmemset(ext, 0, sizeof(*ext));\n\n\tif (*crypt == NULL || (*crypt)->ops == NULL) {\n\t\text->alg = IW_ENCODE_ALG_NONE;\n\t\text->key_len = 0;\n\t\terq->flags |= IW_ENCODE_DISABLED;\n\t} else {\n\t\tif (strcmp((*crypt)->ops->name, \"WEP\") == 0)\n\t\t\text->alg = IW_ENCODE_ALG_WEP;\n\t\telse if (strcmp((*crypt)->ops->name, \"TKIP\") == 0)\n\t\t\text->alg = IW_ENCODE_ALG_TKIP;\n\t\telse if (strcmp((*crypt)->ops->name, \"CCMP\") == 0)\n\t\t\text->alg = IW_ENCODE_ALG_CCMP;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tif ((*crypt)->ops->get_key) {\n\t\t\text->key_len =\n\t\t\t\t(*crypt)->ops->get_key(ext->key,\n\t\t\t\t\t\t       max_key_len,\n\t\t\t\t\t\t       ext->tx_seq,\n\t\t\t\t\t\t       (*crypt)->priv);\n\t\t\tif (ext->key_len &&\n\t\t\t    (ext->alg == IW_ENCODE_ALG_TKIP ||\n\t\t\t     ext->alg == IW_ENCODE_ALG_CCMP))\n\t\t\t\text->ext_flags |= IW_ENCODE_EXT_TX_SEQ_VALID;\n\t\t}\n\t}\n\n\tif (sta_ptr)\n\t\thostap_handle_sta_release(sta_ptr);\n\n\treturn 0;\n}\n\n\nstatic int prism2_ioctl_set_encryption(local_info_t *local,\n\t\t\t\t       struct prism2_hostapd_param *param,\n\t\t\t\t       int param_len)\n{\n\tint ret = 0;\n\tstruct lib80211_crypto_ops *ops;\n\tstruct lib80211_crypt_data **crypt;\n\tvoid *sta_ptr;\n\n\tparam->u.crypt.err = 0;\n\tparam->u.crypt.alg[HOSTAP_CRYPT_ALG_NAME_LEN - 1] = '\\0';\n\n\tif (param_len !=\n\t    (int) ((char *) param->u.crypt.key - (char *) param) +\n\t    param->u.crypt.key_len)\n\t\treturn -EINVAL;\n\n\tif (is_broadcast_ether_addr(param->sta_addr)) {\n\t\tif (param->u.crypt.idx >= WEP_KEYS)\n\t\t\treturn -EINVAL;\n\t\tsta_ptr = NULL;\n\t\tcrypt = &local->crypt_info.crypt[param->u.crypt.idx];\n\t} else {\n\t\tif (param->u.crypt.idx)\n\t\t\treturn -EINVAL;\n\t\tsta_ptr = ap_crypt_get_ptrs(\n\t\t\tlocal->ap, param->sta_addr,\n\t\t\t(param->u.crypt.flags & HOSTAP_CRYPT_FLAG_PERMANENT),\n\t\t\t&crypt);\n\n\t\tif (sta_ptr == NULL) {\n\t\t\tparam->u.crypt.err = HOSTAP_CRYPT_ERR_UNKNOWN_ADDR;\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (strcmp(param->u.crypt.alg, \"none\") == 0) {\n\t\tif (crypt)\n\t\t\tlib80211_crypt_delayed_deinit(&local->crypt_info, crypt);\n\t\tgoto done;\n\t}\n\n\tops = lib80211_get_crypto_ops(param->u.crypt.alg);\n\tif (ops == NULL && strcmp(param->u.crypt.alg, \"WEP\") == 0) {\n\t\trequest_module(\"lib80211_crypt_wep\");\n\t\tops = lib80211_get_crypto_ops(param->u.crypt.alg);\n\t} else if (ops == NULL && strcmp(param->u.crypt.alg, \"TKIP\") == 0) {\n\t\trequest_module(\"lib80211_crypt_tkip\");\n\t\tops = lib80211_get_crypto_ops(param->u.crypt.alg);\n\t} else if (ops == NULL && strcmp(param->u.crypt.alg, \"CCMP\") == 0) {\n\t\trequest_module(\"lib80211_crypt_ccmp\");\n\t\tops = lib80211_get_crypto_ops(param->u.crypt.alg);\n\t}\n\tif (ops == NULL) {\n\t\tprintk(KERN_DEBUG \"%s: unknown crypto alg '%s'\\n\",\n\t\t       local->dev->name, param->u.crypt.alg);\n\t\tparam->u.crypt.err = HOSTAP_CRYPT_ERR_UNKNOWN_ALG;\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\t \n\tlocal->host_decrypt = local->host_encrypt = 1;\n\n\tif (*crypt == NULL || (*crypt)->ops != ops) {\n\t\tstruct lib80211_crypt_data *new_crypt;\n\n\t\tlib80211_crypt_delayed_deinit(&local->crypt_info, crypt);\n\n\t\tnew_crypt = kzalloc(sizeof(struct lib80211_crypt_data),\n\t\t\t\tGFP_KERNEL);\n\t\tif (new_crypt == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t\tnew_crypt->ops = ops;\n\t\tnew_crypt->priv = new_crypt->ops->init(param->u.crypt.idx);\n\t\tif (new_crypt->priv == NULL) {\n\t\t\tkfree(new_crypt);\n\t\t\tparam->u.crypt.err =\n\t\t\t\tHOSTAP_CRYPT_ERR_CRYPT_INIT_FAILED;\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\n\t\t*crypt = new_crypt;\n\t}\n\n\tif ((!(param->u.crypt.flags & HOSTAP_CRYPT_FLAG_SET_TX_KEY) ||\n\t     param->u.crypt.key_len > 0) && (*crypt)->ops->set_key &&\n\t    (*crypt)->ops->set_key(param->u.crypt.key,\n\t\t\t\t   param->u.crypt.key_len, param->u.crypt.seq,\n\t\t\t\t   (*crypt)->priv) < 0) {\n\t\tprintk(KERN_DEBUG \"%s: key setting failed\\n\",\n\t\t       local->dev->name);\n\t\tparam->u.crypt.err = HOSTAP_CRYPT_ERR_KEY_SET_FAILED;\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (param->u.crypt.flags & HOSTAP_CRYPT_FLAG_SET_TX_KEY) {\n\t\tif (!sta_ptr)\n\t\t\tlocal->crypt_info.tx_keyidx = param->u.crypt.idx;\n\t\telse if (param->u.crypt.idx) {\n\t\t\tprintk(KERN_DEBUG \"%s: TX key idx setting failed\\n\",\n\t\t\t       local->dev->name);\n\t\t\tparam->u.crypt.err =\n\t\t\t\tHOSTAP_CRYPT_ERR_TX_KEY_SET_FAILED;\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n done:\n\tif (sta_ptr)\n\t\thostap_handle_sta_release(sta_ptr);\n\n\t \n\tif (ret == 0 &&\n\t    (hostap_set_encryption(local) ||\n\t     (local->iw_mode != IW_MODE_INFRA &&\n\t      local->func->reset_port(local->dev)))) {\n\t\tparam->u.crypt.err = HOSTAP_CRYPT_ERR_CARD_CONF_FAILED;\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n\nstatic int prism2_ioctl_get_encryption(local_info_t *local,\n\t\t\t\t       struct prism2_hostapd_param *param,\n\t\t\t\t       int param_len)\n{\n\tstruct lib80211_crypt_data **crypt;\n\tvoid *sta_ptr;\n\tint max_key_len;\n\n\tparam->u.crypt.err = 0;\n\n\tmax_key_len = param_len -\n\t\t(int) ((char *) param->u.crypt.key - (char *) param);\n\tif (max_key_len < 0)\n\t\treturn -EINVAL;\n\n\tif (is_broadcast_ether_addr(param->sta_addr)) {\n\t\tsta_ptr = NULL;\n\t\tif (param->u.crypt.idx >= WEP_KEYS)\n\t\t\tparam->u.crypt.idx = local->crypt_info.tx_keyidx;\n\t\tcrypt = &local->crypt_info.crypt[param->u.crypt.idx];\n\t} else {\n\t\tparam->u.crypt.idx = 0;\n\t\tsta_ptr = ap_crypt_get_ptrs(local->ap, param->sta_addr, 0,\n\t\t\t\t\t    &crypt);\n\n\t\tif (sta_ptr == NULL) {\n\t\t\tparam->u.crypt.err = HOSTAP_CRYPT_ERR_UNKNOWN_ADDR;\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (*crypt == NULL || (*crypt)->ops == NULL) {\n\t\tmemcpy(param->u.crypt.alg, \"none\", 5);\n\t\tparam->u.crypt.key_len = 0;\n\t\tparam->u.crypt.idx = 0xff;\n\t} else {\n\t\tstrscpy(param->u.crypt.alg, (*crypt)->ops->name,\n\t\t\tHOSTAP_CRYPT_ALG_NAME_LEN);\n\t\tparam->u.crypt.key_len = 0;\n\n\t\tmemset(param->u.crypt.seq, 0, 8);\n\t\tif ((*crypt)->ops->get_key) {\n\t\t\tparam->u.crypt.key_len =\n\t\t\t\t(*crypt)->ops->get_key(param->u.crypt.key,\n\t\t\t\t\t\t       max_key_len,\n\t\t\t\t\t\t       param->u.crypt.seq,\n\t\t\t\t\t\t       (*crypt)->priv);\n\t\t}\n\t}\n\n\tif (sta_ptr)\n\t\thostap_handle_sta_release(sta_ptr);\n\n\treturn 0;\n}\n\n\nstatic int prism2_ioctl_get_rid(local_info_t *local,\n\t\t\t\tstruct prism2_hostapd_param *param,\n\t\t\t\tint param_len)\n{\n\tint max_len, res;\n\n\tmax_len = param_len - PRISM2_HOSTAPD_RID_HDR_LEN;\n\tif (max_len < 0)\n\t\treturn -EINVAL;\n\n\tres = local->func->get_rid(local->dev, param->u.rid.rid,\n\t\t\t\t   param->u.rid.data, param->u.rid.len, 0);\n\tif (res >= 0) {\n\t\tparam->u.rid.len = res;\n\t\treturn 0;\n\t}\n\n\treturn res;\n}\n\n\nstatic int prism2_ioctl_set_rid(local_info_t *local,\n\t\t\t\tstruct prism2_hostapd_param *param,\n\t\t\t\tint param_len)\n{\n\tint max_len;\n\n\tmax_len = param_len - PRISM2_HOSTAPD_RID_HDR_LEN;\n\tif (max_len < 0 || max_len < param->u.rid.len)\n\t\treturn -EINVAL;\n\n\treturn local->func->set_rid(local->dev, param->u.rid.rid,\n\t\t\t\t    param->u.rid.data, param->u.rid.len);\n}\n\n\nstatic int prism2_ioctl_set_assoc_ap_addr(local_info_t *local,\n\t\t\t\t\t  struct prism2_hostapd_param *param,\n\t\t\t\t\t  int param_len)\n{\n\tprintk(KERN_DEBUG \"%ssta: associated as client with AP %pM\\n\",\n\t       local->dev->name, param->sta_addr);\n\tmemcpy(local->assoc_ap_addr, param->sta_addr, ETH_ALEN);\n\treturn 0;\n}\n\n\nstatic int prism2_ioctl_siwgenie(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_point *data = &wrqu->data;\n\treturn prism2_set_genericelement(dev, extra, data->length);\n}\n\n\nstatic int prism2_ioctl_giwgenie(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_point *data = &wrqu->data;\n\tstruct hostap_interface *iface = netdev_priv(dev);\n\tlocal_info_t *local = iface->local;\n\tint len = local->generic_elem_len - 2;\n\n\tif (len <= 0 || local->generic_elem == NULL) {\n\t\tdata->length = 0;\n\t\treturn 0;\n\t}\n\n\tif (data->length < len)\n\t\treturn -E2BIG;\n\n\tdata->length = len;\n\tmemcpy(extra, local->generic_elem + 2, len);\n\n\treturn 0;\n}\n\n\nstatic int prism2_ioctl_set_generic_element(local_info_t *local,\n\t\t\t\t\t    struct prism2_hostapd_param *param,\n\t\t\t\t\t    int param_len)\n{\n\tint max_len, len;\n\n\tlen = param->u.generic_elem.len;\n\tmax_len = param_len - PRISM2_HOSTAPD_GENERIC_ELEMENT_HDR_LEN;\n\tif (max_len < 0 || max_len < len)\n\t\treturn -EINVAL;\n\n\treturn prism2_set_genericelement(local->dev,\n\t\t\t\t\t param->u.generic_elem.data, len);\n}\n\n\nstatic int prism2_ioctl_siwmlme(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct hostap_interface *iface = netdev_priv(dev);\n\tlocal_info_t *local = iface->local;\n\tstruct iw_mlme *mlme = (struct iw_mlme *) extra;\n\t__le16 reason;\n\n\treason = cpu_to_le16(mlme->reason_code);\n\n\tswitch (mlme->cmd) {\n\tcase IW_MLME_DEAUTH:\n\t\treturn prism2_sta_send_mgmt(local, mlme->addr.sa_data,\n\t\t\t\t\t    IEEE80211_STYPE_DEAUTH,\n\t\t\t\t\t    (u8 *) &reason, 2);\n\tcase IW_MLME_DISASSOC:\n\t\treturn prism2_sta_send_mgmt(local, mlme->addr.sa_data,\n\t\t\t\t\t    IEEE80211_STYPE_DISASSOC,\n\t\t\t\t\t    (u8 *) &reason, 2);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n\nstatic int prism2_ioctl_mlme(local_info_t *local,\n\t\t\t     struct prism2_hostapd_param *param)\n{\n\t__le16 reason;\n\n\treason = cpu_to_le16(param->u.mlme.reason_code);\n\tswitch (param->u.mlme.cmd) {\n\tcase MLME_STA_DEAUTH:\n\t\treturn prism2_sta_send_mgmt(local, param->sta_addr,\n\t\t\t\t\t    IEEE80211_STYPE_DEAUTH,\n\t\t\t\t\t    (u8 *) &reason, 2);\n\tcase MLME_STA_DISASSOC:\n\t\treturn prism2_sta_send_mgmt(local, param->sta_addr,\n\t\t\t\t\t    IEEE80211_STYPE_DISASSOC,\n\t\t\t\t\t    (u8 *) &reason, 2);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n\nstatic int prism2_ioctl_scan_req(local_info_t *local,\n\t\t\t\t struct prism2_hostapd_param *param)\n{\n#ifndef PRISM2_NO_STATION_MODES\n\tif ((local->iw_mode != IW_MODE_INFRA &&\n\t     local->iw_mode != IW_MODE_ADHOC) ||\n\t    (local->sta_fw_ver < PRISM2_FW_VER(1,3,1)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!local->dev_enabled)\n\t\treturn -ENETDOWN;\n\n\treturn prism2_request_hostscan(local->dev, param->u.scan_req.ssid,\n\t\t\t\t       param->u.scan_req.ssid_len);\n#else  \n\treturn -EOPNOTSUPP;\n#endif  \n}\n\n\nstatic int prism2_ioctl_priv_hostapd(local_info_t *local, struct iw_point *p)\n{\n\tstruct prism2_hostapd_param *param;\n\tint ret = 0;\n\tint ap_ioctl = 0;\n\n\tif (p->length < sizeof(struct prism2_hostapd_param) ||\n\t    p->length > PRISM2_HOSTAPD_MAX_BUF_SIZE || !p->pointer)\n\t\treturn -EINVAL;\n\n\tparam = memdup_user(p->pointer, p->length);\n\tif (IS_ERR(param)) {\n\t\treturn PTR_ERR(param);\n\t}\n\n\tswitch (param->cmd) {\n\tcase PRISM2_SET_ENCRYPTION:\n\t\tret = prism2_ioctl_set_encryption(local, param, p->length);\n\t\tbreak;\n\tcase PRISM2_GET_ENCRYPTION:\n\t\tret = prism2_ioctl_get_encryption(local, param, p->length);\n\t\tbreak;\n\tcase PRISM2_HOSTAPD_GET_RID:\n\t\tret = prism2_ioctl_get_rid(local, param, p->length);\n\t\tbreak;\n\tcase PRISM2_HOSTAPD_SET_RID:\n\t\tret = prism2_ioctl_set_rid(local, param, p->length);\n\t\tbreak;\n\tcase PRISM2_HOSTAPD_SET_ASSOC_AP_ADDR:\n\t\tret = prism2_ioctl_set_assoc_ap_addr(local, param, p->length);\n\t\tbreak;\n\tcase PRISM2_HOSTAPD_SET_GENERIC_ELEMENT:\n\t\tret = prism2_ioctl_set_generic_element(local, param,\n\t\t\t\t\t\t       p->length);\n\t\tbreak;\n\tcase PRISM2_HOSTAPD_MLME:\n\t\tret = prism2_ioctl_mlme(local, param);\n\t\tbreak;\n\tcase PRISM2_HOSTAPD_SCAN_REQ:\n\t\tret = prism2_ioctl_scan_req(local, param);\n\t\tbreak;\n\tdefault:\n\t\tret = prism2_hostapd(local->ap, param);\n\t\tap_ioctl = 1;\n\t\tbreak;\n\t}\n\n\tif (ret == 1 || !ap_ioctl) {\n\t\tif (copy_to_user(p->pointer, param, p->length)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t} else if (ap_ioctl)\n\t\t\tret = 0;\n\t}\n\n out:\n\tkfree(param);\n\treturn ret;\n}\n\n\nstatic void prism2_get_drvinfo(struct net_device *dev,\n\t\t\t       struct ethtool_drvinfo *info)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tstrscpy(info->driver, \"hostap\", sizeof(info->driver));\n\tsnprintf(info->fw_version, sizeof(info->fw_version),\n\t\t \"%d.%d.%d\", (local->sta_fw_ver >> 16) & 0xff,\n\t\t (local->sta_fw_ver >> 8) & 0xff,\n\t\t local->sta_fw_ver & 0xff);\n}\n\nconst struct ethtool_ops prism2_ethtool_ops = {\n\t.get_drvinfo = prism2_get_drvinfo\n};\n\n\n \n\nstatic const iw_handler prism2_handler[] =\n{\n\tIW_HANDLER(SIOCGIWNAME,\t\tprism2_get_name),\n\tIW_HANDLER(SIOCSIWFREQ,\t\tprism2_ioctl_siwfreq),\n\tIW_HANDLER(SIOCGIWFREQ,\t\tprism2_ioctl_giwfreq),\n\tIW_HANDLER(SIOCSIWMODE,\t\tprism2_ioctl_siwmode),\n\tIW_HANDLER(SIOCGIWMODE,\t\tprism2_ioctl_giwmode),\n\tIW_HANDLER(SIOCSIWSENS,\t\tprism2_ioctl_siwsens),\n\tIW_HANDLER(SIOCGIWSENS,\t\tprism2_ioctl_giwsens),\n\tIW_HANDLER(SIOCGIWRANGE,\tprism2_ioctl_giwrange),\n\tIW_HANDLER(SIOCSIWSPY,\t\tiw_handler_set_spy),\n\tIW_HANDLER(SIOCGIWSPY,\t\tiw_handler_get_spy),\n\tIW_HANDLER(SIOCSIWTHRSPY,\tiw_handler_set_thrspy),\n\tIW_HANDLER(SIOCGIWTHRSPY,\tiw_handler_get_thrspy),\n\tIW_HANDLER(SIOCSIWAP,\t\tprism2_ioctl_siwap),\n\tIW_HANDLER(SIOCGIWAP,\t\tprism2_ioctl_giwap),\n\tIW_HANDLER(SIOCSIWMLME,\t\tprism2_ioctl_siwmlme),\n\tIW_HANDLER(SIOCGIWAPLIST,       prism2_ioctl_giwaplist),\n\tIW_HANDLER(SIOCSIWSCAN,\t\tprism2_ioctl_siwscan),\n\tIW_HANDLER(SIOCGIWSCAN,\t\tprism2_ioctl_giwscan),\n\tIW_HANDLER(SIOCSIWESSID,        prism2_ioctl_siwessid),\n\tIW_HANDLER(SIOCGIWESSID,        prism2_ioctl_giwessid),\n\tIW_HANDLER(SIOCSIWNICKN,        prism2_ioctl_siwnickn),\n\tIW_HANDLER(SIOCGIWNICKN,        prism2_ioctl_giwnickn),\n\tIW_HANDLER(SIOCSIWRATE,\t\tprism2_ioctl_siwrate),\n\tIW_HANDLER(SIOCGIWRATE,\t\tprism2_ioctl_giwrate),\n\tIW_HANDLER(SIOCSIWRTS,\t\tprism2_ioctl_siwrts),\n\tIW_HANDLER(SIOCGIWRTS,\t\tprism2_ioctl_giwrts),\n\tIW_HANDLER(SIOCSIWFRAG,\t\tprism2_ioctl_siwfrag),\n\tIW_HANDLER(SIOCGIWFRAG,\t\tprism2_ioctl_giwfrag),\n\tIW_HANDLER(SIOCSIWTXPOW,        prism2_ioctl_siwtxpow),\n\tIW_HANDLER(SIOCGIWTXPOW,        prism2_ioctl_giwtxpow),\n\tIW_HANDLER(SIOCSIWRETRY,        prism2_ioctl_siwretry),\n\tIW_HANDLER(SIOCGIWRETRY,        prism2_ioctl_giwretry),\n\tIW_HANDLER(SIOCSIWENCODE,       prism2_ioctl_siwencode),\n\tIW_HANDLER(SIOCGIWENCODE,       prism2_ioctl_giwencode),\n\tIW_HANDLER(SIOCSIWPOWER,        prism2_ioctl_siwpower),\n\tIW_HANDLER(SIOCGIWPOWER,        prism2_ioctl_giwpower),\n\tIW_HANDLER(SIOCSIWGENIE,        prism2_ioctl_siwgenie),\n\tIW_HANDLER(SIOCGIWGENIE,        prism2_ioctl_giwgenie),\n\tIW_HANDLER(SIOCSIWAUTH,\t\tprism2_ioctl_siwauth),\n\tIW_HANDLER(SIOCGIWAUTH,\t\tprism2_ioctl_giwauth),\n\tIW_HANDLER(SIOCSIWENCODEEXT,    prism2_ioctl_siwencodeext),\n\tIW_HANDLER(SIOCGIWENCODEEXT,    prism2_ioctl_giwencodeext),\n};\n\nstatic const iw_handler prism2_private_handler[] =\n{\t\t\t\t\t\t \n\tprism2_ioctl_priv_prism2_param,\t\t \n\tprism2_ioctl_priv_get_prism2_param,\t \n\tprism2_ioctl_priv_writemif,\t\t \n\tprism2_ioctl_priv_readmif,\t\t \n};\n\nconst struct iw_handler_def hostap_iw_handler_def =\n{\n\t.num_standard\t= ARRAY_SIZE(prism2_handler),\n\t.num_private\t= ARRAY_SIZE(prism2_private_handler),\n\t.num_private_args = ARRAY_SIZE(prism2_priv),\n\t.standard\t= prism2_handler,\n\t.private\t= prism2_private_handler,\n\t.private_args\t= (struct iw_priv_args *) prism2_priv,\n\t.get_wireless_stats = hostap_get_wireless_stats,\n};\n\n \nint hostap_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct iwreq *wrq = (struct iwreq *) ifr;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint ret = 0;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tswitch (cmd) {\n\tcase PRISM2_IOCTL_INQUIRE:\n\t\tif (!capable(CAP_NET_ADMIN)) ret = -EPERM;\n\t\telse ret = prism2_ioctl_priv_inquire(dev, (int *) wrq->u.name);\n\t\tbreak;\n\n\tcase PRISM2_IOCTL_MONITOR:\n\t\tif (!capable(CAP_NET_ADMIN)) ret = -EPERM;\n\t\telse ret = prism2_ioctl_priv_monitor(dev, (int *) wrq->u.name);\n\t\tbreak;\n\n\tcase PRISM2_IOCTL_RESET:\n\t\tif (!capable(CAP_NET_ADMIN)) ret = -EPERM;\n\t\telse ret = prism2_ioctl_priv_reset(dev, (int *) wrq->u.name);\n\t\tbreak;\n\n\tcase PRISM2_IOCTL_WDS_ADD:\n\t\tif (!capable(CAP_NET_ADMIN)) ret = -EPERM;\n\t\telse ret = prism2_wds_add(local, wrq->u.ap_addr.sa_data, 1);\n\t\tbreak;\n\n\tcase PRISM2_IOCTL_WDS_DEL:\n\t\tif (!capable(CAP_NET_ADMIN)) ret = -EPERM;\n\t\telse ret = prism2_wds_del(local, wrq->u.ap_addr.sa_data, 1, 0);\n\t\tbreak;\n\n\tcase PRISM2_IOCTL_SET_RID_WORD:\n\t\tif (!capable(CAP_NET_ADMIN)) ret = -EPERM;\n\t\telse ret = prism2_ioctl_priv_set_rid_word(dev,\n\t\t\t\t\t\t\t  (int *) wrq->u.name);\n\t\tbreak;\n\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\n\tcase PRISM2_IOCTL_MACCMD:\n\t\tif (!capable(CAP_NET_ADMIN)) ret = -EPERM;\n\t\telse ret = ap_mac_cmd_ioctl(local, (int *) wrq->u.name);\n\t\tbreak;\n\n\tcase PRISM2_IOCTL_ADDMAC:\n\t\tif (!capable(CAP_NET_ADMIN)) ret = -EPERM;\n\t\telse ret = ap_control_add_mac(&local->ap->mac_restrictions,\n\t\t\t\t\t      wrq->u.ap_addr.sa_data);\n\t\tbreak;\n\tcase PRISM2_IOCTL_DELMAC:\n\t\tif (!capable(CAP_NET_ADMIN)) ret = -EPERM;\n\t\telse ret = ap_control_del_mac(&local->ap->mac_restrictions,\n\t\t\t\t\t      wrq->u.ap_addr.sa_data);\n\t\tbreak;\n\tcase PRISM2_IOCTL_KICKMAC:\n\t\tif (!capable(CAP_NET_ADMIN)) ret = -EPERM;\n\t\telse ret = ap_control_kick_mac(local->ap, local->dev,\n\t\t\t\t\t       wrq->u.ap_addr.sa_data);\n\t\tbreak;\n#endif  \n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nint hostap_siocdevprivate(struct net_device *dev, struct ifreq *ifr,\n\t\t\t  void __user *data, int cmd)\n{\n\tstruct iwreq *wrq = (struct iwreq *)ifr;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint ret = 0;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (in_compat_syscall())  \n\t\treturn -EOPNOTSUPP;\n\n\tswitch (cmd) {\n#ifdef PRISM2_DOWNLOAD_SUPPORT\n\tcase PRISM2_IOCTL_DOWNLOAD:\n\t\tif (!capable(CAP_NET_ADMIN)) ret = -EPERM;\n\t\telse ret = prism2_ioctl_priv_download(local, &wrq->u.data);\n\t\tbreak;\n#endif  \n\n\tcase PRISM2_IOCTL_HOSTAPD:\n\t\tif (!capable(CAP_NET_ADMIN)) ret = -EPERM;\n\t\telse ret = prism2_ioctl_priv_hostapd(local, &wrq->u.data);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}