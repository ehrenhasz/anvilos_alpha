{
  "module_name": "hostap_ap.c",
  "hash_id": "98b3303689f04a245875668075b00b2d6f5164083b213b9a6b687a9561a92971",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/hostap/hostap_ap.c",
  "human_readable_source": "\n \n\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/if_arp.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/etherdevice.h>\n\n#include \"hostap_wlan.h\"\n#include \"hostap.h\"\n#include \"hostap_ap.h\"\n\nstatic int other_ap_policy[MAX_PARM_DEVICES] = { AP_OTHER_AP_SKIP_ALL,\n\t\t\t\t\t\t DEF_INTS };\nmodule_param_array(other_ap_policy, int, NULL, 0444);\nMODULE_PARM_DESC(other_ap_policy, \"Other AP beacon monitoring policy (0-3)\");\n\nstatic int ap_max_inactivity[MAX_PARM_DEVICES] = { AP_MAX_INACTIVITY_SEC,\n\t\t\t\t\t\t   DEF_INTS };\nmodule_param_array(ap_max_inactivity, int, NULL, 0444);\nMODULE_PARM_DESC(ap_max_inactivity, \"AP timeout (in seconds) for station \"\n\t\t \"inactivity\");\n\nstatic int ap_bridge_packets[MAX_PARM_DEVICES] = { 1, DEF_INTS };\nmodule_param_array(ap_bridge_packets, int, NULL, 0444);\nMODULE_PARM_DESC(ap_bridge_packets, \"Bridge packets directly between \"\n\t\t \"stations\");\n\nstatic int autom_ap_wds[MAX_PARM_DEVICES] = { 0, DEF_INTS };\nmodule_param_array(autom_ap_wds, int, NULL, 0444);\nMODULE_PARM_DESC(autom_ap_wds, \"Add WDS connections to other APs \"\n\t\t \"automatically\");\n\n\nstatic struct sta_info* ap_get_sta(struct ap_data *ap, u8 *sta);\nstatic void hostap_event_expired_sta(struct net_device *dev,\n\t\t\t\t     struct sta_info *sta);\nstatic void handle_add_proc_queue(struct work_struct *work);\n\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\nstatic void handle_wds_oper_queue(struct work_struct *work);\nstatic void prism2_send_mgmt(struct net_device *dev,\n\t\t\t     u16 type_subtype, char *body,\n\t\t\t     int body_len, u8 *addr, u16 tx_cb_idx);\n#endif  \n\n\n#if !defined(PRISM2_NO_PROCFS_DEBUG) && defined(CONFIG_PROC_FS)\nstatic int ap_debug_proc_show(struct seq_file *m, void *v)\n{\n\tstruct ap_data *ap = pde_data(file_inode(m->file));\n\n\tseq_printf(m, \"BridgedUnicastFrames=%u\\n\", ap->bridged_unicast);\n\tseq_printf(m, \"BridgedMulticastFrames=%u\\n\", ap->bridged_multicast);\n\tseq_printf(m, \"max_inactivity=%u\\n\", ap->max_inactivity / HZ);\n\tseq_printf(m, \"bridge_packets=%u\\n\", ap->bridge_packets);\n\tseq_printf(m, \"nullfunc_ack=%u\\n\", ap->nullfunc_ack);\n\tseq_printf(m, \"autom_ap_wds=%u\\n\", ap->autom_ap_wds);\n\tseq_printf(m, \"auth_algs=%u\\n\", ap->local->auth_algs);\n\tseq_printf(m, \"tx_drop_nonassoc=%u\\n\", ap->tx_drop_nonassoc);\n\treturn 0;\n}\n#endif\n\nstatic void ap_sta_hash_add(struct ap_data *ap, struct sta_info *sta)\n{\n\tsta->hnext = ap->sta_hash[STA_HASH(sta->addr)];\n\tap->sta_hash[STA_HASH(sta->addr)] = sta;\n}\n\nstatic void ap_sta_hash_del(struct ap_data *ap, struct sta_info *sta)\n{\n\tstruct sta_info *s;\n\n\ts = ap->sta_hash[STA_HASH(sta->addr)];\n\tif (s == NULL) return;\n\tif (ether_addr_equal(s->addr, sta->addr)) {\n\t\tap->sta_hash[STA_HASH(sta->addr)] = s->hnext;\n\t\treturn;\n\t}\n\n\twhile (s->hnext != NULL && !ether_addr_equal(s->hnext->addr, sta->addr))\n\t\ts = s->hnext;\n\tif (s->hnext != NULL)\n\t\ts->hnext = s->hnext->hnext;\n\telse\n\t\tprintk(\"AP: could not remove STA %pM from hash table\\n\",\n\t\t       sta->addr);\n}\n\nstatic void ap_free_sta(struct ap_data *ap, struct sta_info *sta)\n{\n\tif (sta->ap && sta->local)\n\t\thostap_event_expired_sta(sta->local->dev, sta);\n\n\tif (ap->proc != NULL) {\n\t\tchar name[20];\n\t\tsprintf(name, \"%pM\", sta->addr);\n\t\tremove_proc_entry(name, ap->proc);\n\t}\n\n\tif (sta->crypt) {\n\t\tsta->crypt->ops->deinit(sta->crypt->priv);\n\t\tkfree(sta->crypt);\n\t\tsta->crypt = NULL;\n\t}\n\n\tskb_queue_purge(&sta->tx_buf);\n\n\tap->num_sta--;\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\n\tif (sta->aid > 0)\n\t\tap->sta_aid[sta->aid - 1] = NULL;\n\n\tif (!sta->ap)\n\t\tkfree(sta->u.sta.challenge);\n\ttimer_shutdown_sync(&sta->timer);\n#endif  \n\n\tkfree(sta);\n}\n\n\nstatic void hostap_set_tim(local_info_t *local, int aid, int set)\n{\n\tif (local->func->set_tim)\n\t\tlocal->func->set_tim(local->dev, aid, set);\n}\n\n\nstatic void hostap_event_new_sta(struct net_device *dev, struct sta_info *sta)\n{\n\tunion iwreq_data wrqu;\n\tmemset(&wrqu, 0, sizeof(wrqu));\n\tmemcpy(wrqu.addr.sa_data, sta->addr, ETH_ALEN);\n\twrqu.addr.sa_family = ARPHRD_ETHER;\n\twireless_send_event(dev, IWEVREGISTERED, &wrqu, NULL);\n}\n\n\nstatic void hostap_event_expired_sta(struct net_device *dev,\n\t\t\t\t     struct sta_info *sta)\n{\n\tunion iwreq_data wrqu;\n\tmemset(&wrqu, 0, sizeof(wrqu));\n\tmemcpy(wrqu.addr.sa_data, sta->addr, ETH_ALEN);\n\twrqu.addr.sa_family = ARPHRD_ETHER;\n\twireless_send_event(dev, IWEVEXPIRED, &wrqu, NULL);\n}\n\n\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\n\nstatic void ap_handle_timer(struct timer_list *t)\n{\n\tstruct sta_info *sta = from_timer(sta, t, timer);\n\tlocal_info_t *local;\n\tstruct ap_data *ap;\n\tunsigned long next_time = 0;\n\tint was_assoc;\n\n\tif (sta == NULL || sta->local == NULL || sta->local->ap == NULL) {\n\t\tPDEBUG(DEBUG_AP, \"ap_handle_timer() called with NULL data\\n\");\n\t\treturn;\n\t}\n\n\tlocal = sta->local;\n\tap = local->ap;\n\twas_assoc = sta->flags & WLAN_STA_ASSOC;\n\n\tif (atomic_read(&sta->users) != 0)\n\t\tnext_time = jiffies + HZ;\n\telse if ((sta->flags & WLAN_STA_PERM) && !(sta->flags & WLAN_STA_AUTH))\n\t\tnext_time = jiffies + ap->max_inactivity;\n\n\tif (time_before(jiffies, sta->last_rx + ap->max_inactivity)) {\n\t\t \n\t\tsta->timeout_next = STA_NULLFUNC;\n\t\tnext_time = sta->last_rx + ap->max_inactivity;\n\t} else if (sta->timeout_next == STA_DISASSOC &&\n\t\t   !(sta->flags & WLAN_STA_PENDING_POLL)) {\n\t\t \n\t\tsta->timeout_next = STA_NULLFUNC;\n\t\tnext_time = jiffies + ap->max_inactivity;\n\t}\n\n\tif (next_time) {\n\t\tsta->timer.expires = next_time;\n\t\tadd_timer(&sta->timer);\n\t\treturn;\n\t}\n\n\tif (sta->ap)\n\t\tsta->timeout_next = STA_DEAUTH;\n\n\tif (sta->timeout_next == STA_DEAUTH && !(sta->flags & WLAN_STA_PERM)) {\n\t\tspin_lock(&ap->sta_table_lock);\n\t\tap_sta_hash_del(ap, sta);\n\t\tlist_del(&sta->list);\n\t\tspin_unlock(&ap->sta_table_lock);\n\t\tsta->flags &= ~(WLAN_STA_AUTH | WLAN_STA_ASSOC);\n\t} else if (sta->timeout_next == STA_DISASSOC)\n\t\tsta->flags &= ~WLAN_STA_ASSOC;\n\n\tif (was_assoc && !(sta->flags & WLAN_STA_ASSOC) && !sta->ap)\n\t\thostap_event_expired_sta(local->dev, sta);\n\n\tif (sta->timeout_next == STA_DEAUTH && sta->aid > 0 &&\n\t    !skb_queue_empty(&sta->tx_buf)) {\n\t\thostap_set_tim(local, sta->aid, 0);\n\t\tsta->flags &= ~WLAN_STA_TIM;\n\t}\n\n\tif (sta->ap) {\n\t\tif (ap->autom_ap_wds) {\n\t\t\tPDEBUG(DEBUG_AP, \"%s: removing automatic WDS \"\n\t\t\t       \"connection to AP %pM\\n\",\n\t\t\t       local->dev->name, sta->addr);\n\t\t\thostap_wds_link_oper(local, sta->addr, WDS_DEL);\n\t\t}\n\t} else if (sta->timeout_next == STA_NULLFUNC) {\n\t\t \n\t\t \n\t\tsta->flags |= WLAN_STA_PENDING_POLL;\n\t\tprism2_send_mgmt(local->dev, IEEE80211_FTYPE_DATA |\n\t\t\t\t IEEE80211_STYPE_DATA, NULL, 0,\n\t\t\t\t sta->addr, ap->tx_callback_poll);\n\t} else {\n\t\tint deauth = sta->timeout_next == STA_DEAUTH;\n\t\t__le16 resp;\n\t\tPDEBUG(DEBUG_AP, \"%s: sending %s info to STA %pM\"\n\t\t       \"(last=%lu, jiffies=%lu)\\n\",\n\t\t       local->dev->name,\n\t\t       deauth ? \"deauthentication\" : \"disassociation\",\n\t\t       sta->addr, sta->last_rx, jiffies);\n\n\t\tresp = cpu_to_le16(deauth ? WLAN_REASON_PREV_AUTH_NOT_VALID :\n\t\t\t\t   WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY);\n\t\tprism2_send_mgmt(local->dev, IEEE80211_FTYPE_MGMT |\n\t\t\t\t (deauth ? IEEE80211_STYPE_DEAUTH :\n\t\t\t\t  IEEE80211_STYPE_DISASSOC),\n\t\t\t\t (char *) &resp, 2, sta->addr, 0);\n\t}\n\n\tif (sta->timeout_next == STA_DEAUTH) {\n\t\tif (sta->flags & WLAN_STA_PERM) {\n\t\t\tPDEBUG(DEBUG_AP, \"%s: STA %pM\"\n\t\t\t       \" would have been removed, \"\n\t\t\t       \"but it has 'perm' flag\\n\",\n\t\t\t       local->dev->name, sta->addr);\n\t\t} else\n\t\t\tap_free_sta(ap, sta);\n\t\treturn;\n\t}\n\n\tif (sta->timeout_next == STA_NULLFUNC) {\n\t\tsta->timeout_next = STA_DISASSOC;\n\t\tsta->timer.expires = jiffies + AP_DISASSOC_DELAY;\n\t} else {\n\t\tsta->timeout_next = STA_DEAUTH;\n\t\tsta->timer.expires = jiffies + AP_DEAUTH_DELAY;\n\t}\n\n\tadd_timer(&sta->timer);\n}\n\n\nvoid hostap_deauth_all_stas(struct net_device *dev, struct ap_data *ap,\n\t\t\t    int resend)\n{\n\tu8 addr[ETH_ALEN];\n\t__le16 resp;\n\tint i;\n\n\tPDEBUG(DEBUG_AP, \"%s: Deauthenticate all stations\\n\", dev->name);\n\teth_broadcast_addr(addr);\n\n\tresp = cpu_to_le16(WLAN_REASON_PREV_AUTH_NOT_VALID);\n\n\t \n\tfor (i = 0; i < 5; i++) {\n\t\tprism2_send_mgmt(dev, IEEE80211_FTYPE_MGMT |\n\t\t\t\t IEEE80211_STYPE_DEAUTH,\n\t\t\t\t (char *) &resp, 2, addr, 0);\n\n\t\tif (!resend || ap->num_sta <= 0)\n\t\t\treturn;\n\n\t\tmdelay(50);\n\t}\n}\n\n\nstatic int ap_control_proc_show(struct seq_file *m, void *v)\n{\n\tstruct ap_data *ap = pde_data(file_inode(m->file));\n\tchar *policy_txt;\n\tstruct mac_entry *entry;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tswitch (ap->mac_restrictions.policy) {\n\t\tcase MAC_POLICY_OPEN:\n\t\t\tpolicy_txt = \"open\";\n\t\t\tbreak;\n\t\tcase MAC_POLICY_ALLOW:\n\t\t\tpolicy_txt = \"allow\";\n\t\t\tbreak;\n\t\tcase MAC_POLICY_DENY:\n\t\t\tpolicy_txt = \"deny\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpolicy_txt = \"unknown\";\n\t\t\tbreak;\n\t\t}\n\t\tseq_printf(m, \"MAC policy: %s\\n\", policy_txt);\n\t\tseq_printf(m, \"MAC entries: %u\\n\", ap->mac_restrictions.entries);\n\t\tseq_puts(m, \"MAC list:\\n\");\n\t\treturn 0;\n\t}\n\n\tentry = v;\n\tseq_printf(m, \"%pM\\n\", entry->addr);\n\treturn 0;\n}\n\nstatic void *ap_control_proc_start(struct seq_file *m, loff_t *_pos)\n{\n\tstruct ap_data *ap = pde_data(file_inode(m->file));\n\tspin_lock_bh(&ap->mac_restrictions.lock);\n\treturn seq_list_start_head(&ap->mac_restrictions.mac_list, *_pos);\n}\n\nstatic void *ap_control_proc_next(struct seq_file *m, void *v, loff_t *_pos)\n{\n\tstruct ap_data *ap = pde_data(file_inode(m->file));\n\treturn seq_list_next(v, &ap->mac_restrictions.mac_list, _pos);\n}\n\nstatic void ap_control_proc_stop(struct seq_file *m, void *v)\n{\n\tstruct ap_data *ap = pde_data(file_inode(m->file));\n\tspin_unlock_bh(&ap->mac_restrictions.lock);\n}\n\nstatic const struct seq_operations ap_control_proc_seqops = {\n\t.start\t= ap_control_proc_start,\n\t.next\t= ap_control_proc_next,\n\t.stop\t= ap_control_proc_stop,\n\t.show\t= ap_control_proc_show,\n};\n\nint ap_control_add_mac(struct mac_restrictions *mac_restrictions, u8 *mac)\n{\n\tstruct mac_entry *entry;\n\n\tentry = kmalloc(sizeof(struct mac_entry), GFP_KERNEL);\n\tif (entry == NULL)\n\t\treturn -ENOMEM;\n\n\tmemcpy(entry->addr, mac, ETH_ALEN);\n\n\tspin_lock_bh(&mac_restrictions->lock);\n\tlist_add_tail(&entry->list, &mac_restrictions->mac_list);\n\tmac_restrictions->entries++;\n\tspin_unlock_bh(&mac_restrictions->lock);\n\n\treturn 0;\n}\n\n\nint ap_control_del_mac(struct mac_restrictions *mac_restrictions, u8 *mac)\n{\n\tstruct list_head *ptr;\n\tstruct mac_entry *entry;\n\n\tspin_lock_bh(&mac_restrictions->lock);\n\tfor (ptr = mac_restrictions->mac_list.next;\n\t     ptr != &mac_restrictions->mac_list; ptr = ptr->next) {\n\t\tentry = list_entry(ptr, struct mac_entry, list);\n\n\t\tif (ether_addr_equal(entry->addr, mac)) {\n\t\t\tlist_del(ptr);\n\t\t\tkfree(entry);\n\t\t\tmac_restrictions->entries--;\n\t\t\tspin_unlock_bh(&mac_restrictions->lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock_bh(&mac_restrictions->lock);\n\treturn -1;\n}\n\n\nstatic int ap_control_mac_deny(struct mac_restrictions *mac_restrictions,\n\t\t\t       u8 *mac)\n{\n\tstruct mac_entry *entry;\n\tint found = 0;\n\n\tif (mac_restrictions->policy == MAC_POLICY_OPEN)\n\t\treturn 0;\n\n\tspin_lock_bh(&mac_restrictions->lock);\n\tlist_for_each_entry(entry, &mac_restrictions->mac_list, list) {\n\t\tif (ether_addr_equal(entry->addr, mac)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&mac_restrictions->lock);\n\n\tif (mac_restrictions->policy == MAC_POLICY_ALLOW)\n\t\treturn !found;\n\telse\n\t\treturn found;\n}\n\n\nvoid ap_control_flush_macs(struct mac_restrictions *mac_restrictions)\n{\n\tstruct list_head *ptr, *n;\n\tstruct mac_entry *entry;\n\n\tif (mac_restrictions->entries == 0)\n\t\treturn;\n\n\tspin_lock_bh(&mac_restrictions->lock);\n\tfor (ptr = mac_restrictions->mac_list.next, n = ptr->next;\n\t     ptr != &mac_restrictions->mac_list;\n\t     ptr = n, n = ptr->next) {\n\t\tentry = list_entry(ptr, struct mac_entry, list);\n\t\tlist_del(ptr);\n\t\tkfree(entry);\n\t}\n\tmac_restrictions->entries = 0;\n\tspin_unlock_bh(&mac_restrictions->lock);\n}\n\n\nint ap_control_kick_mac(struct ap_data *ap, struct net_device *dev, u8 *mac)\n{\n\tstruct sta_info *sta;\n\t__le16 resp;\n\n\tspin_lock_bh(&ap->sta_table_lock);\n\tsta = ap_get_sta(ap, mac);\n\tif (sta) {\n\t\tap_sta_hash_del(ap, sta);\n\t\tlist_del(&sta->list);\n\t}\n\tspin_unlock_bh(&ap->sta_table_lock);\n\n\tif (!sta)\n\t\treturn -EINVAL;\n\n\tresp = cpu_to_le16(WLAN_REASON_PREV_AUTH_NOT_VALID);\n\tprism2_send_mgmt(dev, IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_DEAUTH,\n\t\t\t (char *) &resp, 2, sta->addr, 0);\n\n\tif ((sta->flags & WLAN_STA_ASSOC) && !sta->ap)\n\t\thostap_event_expired_sta(dev, sta);\n\n\tap_free_sta(ap, sta);\n\n\treturn 0;\n}\n\n#endif  \n\n\nvoid ap_control_kickall(struct ap_data *ap)\n{\n\tstruct list_head *ptr, *n;\n\tstruct sta_info *sta;\n\n\tspin_lock_bh(&ap->sta_table_lock);\n\tfor (ptr = ap->sta_list.next, n = ptr->next; ptr != &ap->sta_list;\n\t     ptr = n, n = ptr->next) {\n\t\tsta = list_entry(ptr, struct sta_info, list);\n\t\tap_sta_hash_del(ap, sta);\n\t\tlist_del(&sta->list);\n\t\tif ((sta->flags & WLAN_STA_ASSOC) && !sta->ap && sta->local)\n\t\t\thostap_event_expired_sta(sta->local->dev, sta);\n\t\tap_free_sta(ap, sta);\n\t}\n\tspin_unlock_bh(&ap->sta_table_lock);\n}\n\n\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\n\nstatic int prism2_ap_proc_show(struct seq_file *m, void *v)\n{\n\tstruct sta_info *sta = v;\n\tint i;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_printf(m, \"# BSSID CHAN SIGNAL NOISE RATE SSID FLAGS\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!sta->ap)\n\t\treturn 0;\n\n\tseq_printf(m, \"%pM %d %d %d %d '\",\n\t\t   sta->addr,\n\t\t   sta->u.ap.channel, sta->last_rx_signal,\n\t\t   sta->last_rx_silence, sta->last_rx_rate);\n\n\tfor (i = 0; i < sta->u.ap.ssid_len; i++) {\n\t\tif (sta->u.ap.ssid[i] >= 32 && sta->u.ap.ssid[i] < 127)\n\t\t\tseq_putc(m, sta->u.ap.ssid[i]);\n\t\telse\n\t\t\tseq_printf(m, \"<%02x>\", sta->u.ap.ssid[i]);\n\t}\n\n\tseq_putc(m, '\\'');\n\tif (sta->capability & WLAN_CAPABILITY_ESS)\n\t\tseq_puts(m, \" [ESS]\");\n\tif (sta->capability & WLAN_CAPABILITY_IBSS)\n\t\tseq_puts(m, \" [IBSS]\");\n\tif (sta->capability & WLAN_CAPABILITY_PRIVACY)\n\t\tseq_puts(m, \" [WEP]\");\n\tseq_putc(m, '\\n');\n\treturn 0;\n}\n\nstatic void *prism2_ap_proc_start(struct seq_file *m, loff_t *_pos)\n{\n\tstruct ap_data *ap = pde_data(file_inode(m->file));\n\tspin_lock_bh(&ap->sta_table_lock);\n\treturn seq_list_start_head(&ap->sta_list, *_pos);\n}\n\nstatic void *prism2_ap_proc_next(struct seq_file *m, void *v, loff_t *_pos)\n{\n\tstruct ap_data *ap = pde_data(file_inode(m->file));\n\treturn seq_list_next(v, &ap->sta_list, _pos);\n}\n\nstatic void prism2_ap_proc_stop(struct seq_file *m, void *v)\n{\n\tstruct ap_data *ap = pde_data(file_inode(m->file));\n\tspin_unlock_bh(&ap->sta_table_lock);\n}\n\nstatic const struct seq_operations prism2_ap_proc_seqops = {\n\t.start\t= prism2_ap_proc_start,\n\t.next\t= prism2_ap_proc_next,\n\t.stop\t= prism2_ap_proc_stop,\n\t.show\t= prism2_ap_proc_show,\n};\n#endif  \n\n\nvoid hostap_check_sta_fw_version(struct ap_data *ap, int sta_fw_ver)\n{\n\tif (!ap)\n\t\treturn;\n\n\tif (sta_fw_ver == PRISM2_FW_VER(0,8,0)) {\n\t\tPDEBUG(DEBUG_AP, \"Using data::nullfunc ACK workaround - \"\n\t\t       \"firmware upgrade recommended\\n\");\n\t\tap->nullfunc_ack = 1;\n\t} else\n\t\tap->nullfunc_ack = 0;\n\n\tif (sta_fw_ver == PRISM2_FW_VER(1,4,2)) {\n\t\tprintk(KERN_WARNING \"%s: Warning: secondary station firmware \"\n\t\t       \"version 1.4.2 does not seem to work in Host AP mode\\n\",\n\t\t       ap->local->dev->name);\n\t}\n}\n\n\n \nstatic void hostap_ap_tx_cb(struct sk_buff *skb, int ok, void *data)\n{\n\tstruct ap_data *ap = data;\n\tstruct ieee80211_hdr *hdr;\n\n\tif (!ap->local->hostapd || !ap->local->apdev) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n\t \n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\thdr->frame_control &= cpu_to_le16(~IEEE80211_FCTL_VERS);\n\thdr->frame_control |= cpu_to_le16(ok ? BIT(1) : BIT(0));\n\n\tskb->dev = ap->local->apdev;\n\tskb_pull(skb, hostap_80211_get_hdrlen(hdr->frame_control));\n\tskb->pkt_type = PACKET_OTHERHOST;\n\tskb->protocol = cpu_to_be16(ETH_P_802_2);\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\tnetif_rx(skb);\n}\n\n\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\n \nstatic void hostap_ap_tx_cb_auth(struct sk_buff *skb, int ok, void *data)\n{\n\tstruct ap_data *ap = data;\n\tstruct net_device *dev = ap->local->dev;\n\tstruct ieee80211_hdr *hdr;\n\tu16 auth_alg, auth_transaction, status;\n\t__le16 *pos;\n\tstruct sta_info *sta = NULL;\n\tchar *txt = NULL;\n\n\tif (ap->local->hostapd) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\tif (!ieee80211_is_auth(hdr->frame_control) ||\n\t    skb->len < IEEE80211_MGMT_HDR_LEN + 6) {\n\t\tprintk(KERN_DEBUG \"%s: hostap_ap_tx_cb_auth received invalid \"\n\t\t       \"frame\\n\", dev->name);\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n\tpos = (__le16 *) (skb->data + IEEE80211_MGMT_HDR_LEN);\n\tauth_alg = le16_to_cpu(*pos++);\n\tauth_transaction = le16_to_cpu(*pos++);\n\tstatus = le16_to_cpu(*pos++);\n\n\tif (!ok) {\n\t\ttxt = \"frame was not ACKed\";\n\t\tgoto done;\n\t}\n\n\tspin_lock(&ap->sta_table_lock);\n\tsta = ap_get_sta(ap, hdr->addr1);\n\tif (sta)\n\t\tatomic_inc(&sta->users);\n\tspin_unlock(&ap->sta_table_lock);\n\n\tif (!sta) {\n\t\ttxt = \"STA not found\";\n\t\tgoto done;\n\t}\n\n\tif (status == WLAN_STATUS_SUCCESS &&\n\t    ((auth_alg == WLAN_AUTH_OPEN && auth_transaction == 2) ||\n\t     (auth_alg == WLAN_AUTH_SHARED_KEY && auth_transaction == 4))) {\n\t\ttxt = \"STA authenticated\";\n\t\tsta->flags |= WLAN_STA_AUTH;\n\t\tsta->last_auth = jiffies;\n\t} else if (status != WLAN_STATUS_SUCCESS)\n\t\ttxt = \"authentication failed\";\n\n done:\n\tif (sta)\n\t\tatomic_dec(&sta->users);\n\tif (txt) {\n\t\tPDEBUG(DEBUG_AP, \"%s: %pM auth_cb - alg=%d \"\n\t\t       \"trans#=%d status=%d - %s\\n\",\n\t\t       dev->name, hdr->addr1,\n\t\t       auth_alg, auth_transaction, status, txt);\n\t}\n\tdev_kfree_skb(skb);\n}\n\n\n \nstatic void hostap_ap_tx_cb_assoc(struct sk_buff *skb, int ok, void *data)\n{\n\tstruct ap_data *ap = data;\n\tstruct net_device *dev = ap->local->dev;\n\tstruct ieee80211_hdr *hdr;\n\tu16 status;\n\t__le16 *pos;\n\tstruct sta_info *sta = NULL;\n\tchar *txt = NULL;\n\n\tif (ap->local->hostapd) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\tif ((!ieee80211_is_assoc_resp(hdr->frame_control) &&\n\t     !ieee80211_is_reassoc_resp(hdr->frame_control)) ||\n\t    skb->len < IEEE80211_MGMT_HDR_LEN + 4) {\n\t\tprintk(KERN_DEBUG \"%s: hostap_ap_tx_cb_assoc received invalid \"\n\t\t       \"frame\\n\", dev->name);\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n\tif (!ok) {\n\t\ttxt = \"frame was not ACKed\";\n\t\tgoto done;\n\t}\n\n\tspin_lock(&ap->sta_table_lock);\n\tsta = ap_get_sta(ap, hdr->addr1);\n\tif (sta)\n\t\tatomic_inc(&sta->users);\n\tspin_unlock(&ap->sta_table_lock);\n\n\tif (!sta) {\n\t\ttxt = \"STA not found\";\n\t\tgoto done;\n\t}\n\n\tpos = (__le16 *) (skb->data + IEEE80211_MGMT_HDR_LEN);\n\tpos++;\n\tstatus = le16_to_cpu(*pos++);\n\tif (status == WLAN_STATUS_SUCCESS) {\n\t\tif (!(sta->flags & WLAN_STA_ASSOC))\n\t\t\thostap_event_new_sta(dev, sta);\n\t\ttxt = \"STA associated\";\n\t\tsta->flags |= WLAN_STA_ASSOC;\n\t\tsta->last_assoc = jiffies;\n\t} else\n\t\ttxt = \"association failed\";\n\n done:\n\tif (sta)\n\t\tatomic_dec(&sta->users);\n\tif (txt) {\n\t\tPDEBUG(DEBUG_AP, \"%s: %pM assoc_cb - %s\\n\",\n\t\t       dev->name, hdr->addr1, txt);\n\t}\n\tdev_kfree_skb(skb);\n}\n\n \nstatic void hostap_ap_tx_cb_poll(struct sk_buff *skb, int ok, void *data)\n{\n\tstruct ap_data *ap = data;\n\tstruct ieee80211_hdr *hdr;\n\tstruct sta_info *sta;\n\n\tif (skb->len < 24)\n\t\tgoto fail;\n\thdr = (struct ieee80211_hdr *) skb->data;\n\tif (ok) {\n\t\tspin_lock(&ap->sta_table_lock);\n\t\tsta = ap_get_sta(ap, hdr->addr1);\n\t\tif (sta)\n\t\t\tsta->flags &= ~WLAN_STA_PENDING_POLL;\n\t\tspin_unlock(&ap->sta_table_lock);\n\t} else {\n\t\tPDEBUG(DEBUG_AP,\n\t\t       \"%s: STA %pM did not ACK activity poll frame\\n\",\n\t\t       ap->local->dev->name, hdr->addr1);\n\t}\n\n fail:\n\tdev_kfree_skb(skb);\n}\n#endif  \n\n\nvoid hostap_init_data(local_info_t *local)\n{\n\tstruct ap_data *ap = local->ap;\n\n\tif (ap == NULL) {\n\t\tprintk(KERN_WARNING \"hostap_init_data: ap == NULL\\n\");\n\t\treturn;\n\t}\n\tmemset(ap, 0, sizeof(struct ap_data));\n\tap->local = local;\n\n\tap->ap_policy = GET_INT_PARM(other_ap_policy, local->card_idx);\n\tap->bridge_packets = GET_INT_PARM(ap_bridge_packets, local->card_idx);\n\tap->max_inactivity =\n\t\tGET_INT_PARM(ap_max_inactivity, local->card_idx) * HZ;\n\tap->autom_ap_wds = GET_INT_PARM(autom_ap_wds, local->card_idx);\n\n\tspin_lock_init(&ap->sta_table_lock);\n\tINIT_LIST_HEAD(&ap->sta_list);\n\n\t \n\tINIT_WORK(&local->ap->add_sta_proc_queue, handle_add_proc_queue);\n\n\tap->tx_callback_idx =\n\t\thostap_tx_callback_register(local, hostap_ap_tx_cb, ap);\n\tif (ap->tx_callback_idx == 0)\n\t\tprintk(KERN_WARNING \"%s: failed to register TX callback for \"\n\t\t       \"AP\\n\", local->dev->name);\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\n\tINIT_WORK(&local->ap->wds_oper_queue, handle_wds_oper_queue);\n\n\tap->tx_callback_auth =\n\t\thostap_tx_callback_register(local, hostap_ap_tx_cb_auth, ap);\n\tap->tx_callback_assoc =\n\t\thostap_tx_callback_register(local, hostap_ap_tx_cb_assoc, ap);\n\tap->tx_callback_poll =\n\t\thostap_tx_callback_register(local, hostap_ap_tx_cb_poll, ap);\n\tif (ap->tx_callback_auth == 0 || ap->tx_callback_assoc == 0 ||\n\t\tap->tx_callback_poll == 0)\n\t\tprintk(KERN_WARNING \"%s: failed to register TX callback for \"\n\t\t       \"AP\\n\", local->dev->name);\n\n\tspin_lock_init(&ap->mac_restrictions.lock);\n\tINIT_LIST_HEAD(&ap->mac_restrictions.mac_list);\n#endif  \n\n\tap->initialized = 1;\n}\n\n\nvoid hostap_init_ap_proc(local_info_t *local)\n{\n\tstruct ap_data *ap = local->ap;\n\n\tap->proc = local->proc;\n\tif (ap->proc == NULL)\n\t\treturn;\n\n#ifndef PRISM2_NO_PROCFS_DEBUG\n\tproc_create_single_data(\"ap_debug\", 0, ap->proc, ap_debug_proc_show, ap);\n#endif  \n\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\n\tproc_create_seq_data(\"ap_control\", 0, ap->proc, &ap_control_proc_seqops,\n\t\t\tap);\n\tproc_create_seq_data(\"ap\", 0, ap->proc, &prism2_ap_proc_seqops, ap);\n#endif  \n\n}\n\n\nvoid hostap_free_data(struct ap_data *ap)\n{\n\tstruct sta_info *n, *sta;\n\n\tif (ap == NULL || !ap->initialized) {\n\t\tprintk(KERN_DEBUG \"hostap_free_data: ap has not yet been \"\n\t\t       \"initialized - skip resource freeing\\n\");\n\t\treturn;\n\t}\n\n\tflush_work(&ap->add_sta_proc_queue);\n\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\n\tflush_work(&ap->wds_oper_queue);\n\tif (ap->crypt)\n\t\tap->crypt->deinit(ap->crypt_priv);\n\tap->crypt = ap->crypt_priv = NULL;\n#endif  \n\n\tlist_for_each_entry_safe(sta, n, &ap->sta_list, list) {\n\t\tap_sta_hash_del(ap, sta);\n\t\tlist_del(&sta->list);\n\t\tif ((sta->flags & WLAN_STA_ASSOC) && !sta->ap && sta->local)\n\t\t\thostap_event_expired_sta(sta->local->dev, sta);\n\t\tap_free_sta(ap, sta);\n\t}\n\n#ifndef PRISM2_NO_PROCFS_DEBUG\n\tif (ap->proc != NULL) {\n\t\tremove_proc_entry(\"ap_debug\", ap->proc);\n\t}\n#endif  \n\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\n\tif (ap->proc != NULL) {\n\t  remove_proc_entry(\"ap\", ap->proc);\n\t\tremove_proc_entry(\"ap_control\", ap->proc);\n\t}\n\tap_control_flush_macs(&ap->mac_restrictions);\n#endif  \n\n\tap->initialized = 0;\n}\n\n\n \nstatic struct sta_info* ap_get_sta(struct ap_data *ap, u8 *sta)\n{\n\tstruct sta_info *s;\n\n\ts = ap->sta_hash[STA_HASH(sta)];\n\twhile (s != NULL && !ether_addr_equal(s->addr, sta))\n\t\ts = s->hnext;\n\treturn s;\n}\n\n\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\n\n \nstatic void prism2_send_mgmt(struct net_device *dev,\n\t\t\t     u16 type_subtype, char *body,\n\t\t\t     int body_len, u8 *addr, u16 tx_cb_idx)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tstruct ieee80211_hdr *hdr;\n\tu16 fc;\n\tstruct sk_buff *skb;\n\tstruct hostap_skb_tx_data *meta;\n\tint hdrlen;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\tdev = local->dev;  \n\tiface = netdev_priv(dev);\n\n\tif (!(dev->flags & IFF_UP)) {\n\t\tPDEBUG(DEBUG_AP, \"%s: prism2_send_mgmt - device is not UP - \"\n\t\t       \"cannot send frame\\n\", dev->name);\n\t\treturn;\n\t}\n\n\tskb = dev_alloc_skb(sizeof(*hdr) + body_len);\n\tif (skb == NULL) {\n\t\tPDEBUG(DEBUG_AP, \"%s: prism2_send_mgmt failed to allocate \"\n\t\t       \"skb\\n\", dev->name);\n\t\treturn;\n\t}\n\n\tfc = type_subtype;\n\thdrlen = hostap_80211_get_hdrlen(cpu_to_le16(type_subtype));\n\thdr = skb_put_zero(skb, hdrlen);\n\tif (body)\n\t\tskb_put_data(skb, body, body_len);\n\n\t \n\n\n\tmemcpy(hdr->addr1, addr, ETH_ALEN);  \n\tif (ieee80211_is_data(hdr->frame_control)) {\n\t\tfc |= IEEE80211_FCTL_FROMDS;\n\t\tmemcpy(hdr->addr2, dev->dev_addr, ETH_ALEN);  \n\t\tmemcpy(hdr->addr3, dev->dev_addr, ETH_ALEN);  \n\t} else if (ieee80211_is_ctl(hdr->frame_control)) {\n\t\t \n\t\teth_zero_addr(hdr->addr2);\n\t\teth_zero_addr(hdr->addr3);\n\t} else {\n\t\tmemcpy(hdr->addr2, dev->dev_addr, ETH_ALEN);  \n\t\tmemcpy(hdr->addr3, dev->dev_addr, ETH_ALEN);  \n\t}\n\n\thdr->frame_control = cpu_to_le16(fc);\n\n\tmeta = (struct hostap_skb_tx_data *) skb->cb;\n\tmemset(meta, 0, sizeof(*meta));\n\tmeta->magic = HOSTAP_SKB_TX_DATA_MAGIC;\n\tmeta->iface = iface;\n\tmeta->tx_cb_idx = tx_cb_idx;\n\n\tskb->dev = dev;\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\tdev_queue_xmit(skb);\n}\n#endif  \n\n#ifdef CONFIG_PROC_FS\nstatic int prism2_sta_proc_show(struct seq_file *m, void *v)\n{\n\tstruct sta_info *sta = m->private;\n\tint i;\n\n\t \n\n\tseq_printf(m,\n\t\t   \"%s=%pM\\nusers=%d\\naid=%d\\n\"\n\t\t   \"flags=0x%04x%s%s%s%s%s%s%s\\n\"\n\t\t   \"capability=0x%02x\\nlisten_interval=%d\\nsupported_rates=\",\n\t\t   sta->ap ? \"AP\" : \"STA\",\n\t\t   sta->addr, atomic_read(&sta->users), sta->aid,\n\t\t   sta->flags,\n\t\t   sta->flags & WLAN_STA_AUTH ? \" AUTH\" : \"\",\n\t\t   sta->flags & WLAN_STA_ASSOC ? \" ASSOC\" : \"\",\n\t\t   sta->flags & WLAN_STA_PS ? \" PS\" : \"\",\n\t\t   sta->flags & WLAN_STA_TIM ? \" TIM\" : \"\",\n\t\t   sta->flags & WLAN_STA_PERM ? \" PERM\" : \"\",\n\t\t   sta->flags & WLAN_STA_AUTHORIZED ? \" AUTHORIZED\" : \"\",\n\t\t   sta->flags & WLAN_STA_PENDING_POLL ? \" POLL\" : \"\",\n\t\t   sta->capability, sta->listen_interval);\n\t \n\tfor (i = 0; i < sizeof(sta->supported_rates); i++)\n\t\tif (sta->supported_rates[i] != 0)\n\t\t\tseq_printf(m, \"%d%sMbps \",\n\t\t\t\t   (sta->supported_rates[i] & 0x7f) / 2,\n\t\t\t\t   sta->supported_rates[i] & 1 ? \".5\" : \"\");\n\tseq_printf(m,\n\t\t   \"\\njiffies=%lu\\nlast_auth=%lu\\nlast_assoc=%lu\\n\"\n\t\t   \"last_rx=%lu\\nlast_tx=%lu\\nrx_packets=%lu\\n\"\n\t\t   \"tx_packets=%lu\\n\"\n\t\t   \"rx_bytes=%lu\\ntx_bytes=%lu\\nbuffer_count=%d\\n\"\n\t\t   \"last_rx: silence=%d dBm signal=%d dBm rate=%d%s Mbps\\n\"\n\t\t   \"tx_rate=%d\\ntx[1M]=%d\\ntx[2M]=%d\\ntx[5.5M]=%d\\n\"\n\t\t   \"tx[11M]=%d\\n\"\n\t\t   \"rx[1M]=%d\\nrx[2M]=%d\\nrx[5.5M]=%d\\nrx[11M]=%d\\n\",\n\t\t   jiffies, sta->last_auth, sta->last_assoc, sta->last_rx,\n\t\t   sta->last_tx,\n\t\t   sta->rx_packets, sta->tx_packets, sta->rx_bytes,\n\t\t   sta->tx_bytes, skb_queue_len(&sta->tx_buf),\n\t\t   sta->last_rx_silence,\n\t\t   sta->last_rx_signal, sta->last_rx_rate / 10,\n\t\t   sta->last_rx_rate % 10 ? \".5\" : \"\",\n\t\t   sta->tx_rate, sta->tx_count[0], sta->tx_count[1],\n\t\t   sta->tx_count[2], sta->tx_count[3],  sta->rx_count[0],\n\t\t   sta->rx_count[1], sta->rx_count[2], sta->rx_count[3]);\n\tif (sta->crypt && sta->crypt->ops && sta->crypt->ops->print_stats)\n\t\tsta->crypt->ops->print_stats(m, sta->crypt->priv);\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\n\tif (sta->ap) {\n\t\tif (sta->u.ap.channel >= 0)\n\t\t\tseq_printf(m, \"channel=%d\\n\", sta->u.ap.channel);\n\t\tseq_puts(m, \"ssid=\");\n\t\tfor (i = 0; i < sta->u.ap.ssid_len; i++) {\n\t\t\tif (sta->u.ap.ssid[i] >= 32 && sta->u.ap.ssid[i] < 127)\n\t\t\t\tseq_putc(m, sta->u.ap.ssid[i]);\n\t\t\telse\n\t\t\t\tseq_printf(m, \"<%02x>\", sta->u.ap.ssid[i]);\n\t\t}\n\t\tseq_putc(m, '\\n');\n\t}\n#endif  \n\n\treturn 0;\n}\n#endif\n\nstatic void handle_add_proc_queue(struct work_struct *work)\n{\n\tstruct ap_data *ap = container_of(work, struct ap_data,\n\t\t\t\t\t  add_sta_proc_queue);\n\tstruct sta_info *sta;\n\tchar name[20];\n\tstruct add_sta_proc_data *entry, *prev;\n\n\tentry = ap->add_sta_proc_entries;\n\tap->add_sta_proc_entries = NULL;\n\n\twhile (entry) {\n\t\tspin_lock_bh(&ap->sta_table_lock);\n\t\tsta = ap_get_sta(ap, entry->addr);\n\t\tif (sta)\n\t\t\tatomic_inc(&sta->users);\n\t\tspin_unlock_bh(&ap->sta_table_lock);\n\n\t\tif (sta) {\n\t\t\tsprintf(name, \"%pM\", sta->addr);\n\t\t\tsta->proc = proc_create_single_data(\n\t\t\t\tname, 0, ap->proc,\n\t\t\t\tprism2_sta_proc_show, sta);\n\n\t\t\tatomic_dec(&sta->users);\n\t\t}\n\n\t\tprev = entry;\n\t\tentry = entry->next;\n\t\tkfree(prev);\n\t}\n}\n\n\nstatic struct sta_info * ap_add_sta(struct ap_data *ap, u8 *addr)\n{\n\tstruct sta_info *sta;\n\n\tsta = kzalloc(sizeof(struct sta_info), GFP_ATOMIC);\n\tif (sta == NULL) {\n\t\tPDEBUG(DEBUG_AP, \"AP: kmalloc failed\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tsta->local = ap->local;\n\tskb_queue_head_init(&sta->tx_buf);\n\tmemcpy(sta->addr, addr, ETH_ALEN);\n\n\tatomic_inc(&sta->users);\n\tspin_lock_bh(&ap->sta_table_lock);\n\tlist_add(&sta->list, &ap->sta_list);\n\tap->num_sta++;\n\tap_sta_hash_add(ap, sta);\n\tspin_unlock_bh(&ap->sta_table_lock);\n\n\tif (ap->proc) {\n\t\tstruct add_sta_proc_data *entry;\n\t\t \n\t\tentry = kmalloc(sizeof(*entry), GFP_ATOMIC);\n\t\tif (entry) {\n\t\t\tmemcpy(entry->addr, sta->addr, ETH_ALEN);\n\t\t\tentry->next = ap->add_sta_proc_entries;\n\t\t\tap->add_sta_proc_entries = entry;\n\t\t\tschedule_work(&ap->add_sta_proc_queue);\n\t\t} else\n\t\t\tprintk(KERN_DEBUG \"Failed to add STA proc data\\n\");\n\t}\n\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\n\ttimer_setup(&sta->timer, ap_handle_timer, 0);\n\tsta->timer.expires = jiffies + ap->max_inactivity;\n\tif (!ap->local->hostapd)\n\t\tadd_timer(&sta->timer);\n#endif  \n\n\treturn sta;\n}\n\n\nstatic int ap_tx_rate_ok(int rateidx, struct sta_info *sta,\n\t\t\t local_info_t *local)\n{\n\tif (rateidx > sta->tx_max_rate ||\n\t    !(sta->tx_supp_rates & (1 << rateidx)))\n\t\treturn 0;\n\n\tif (local->tx_rate_control != 0 &&\n\t    !(local->tx_rate_control & (1 << rateidx)))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n\nstatic void prism2_check_tx_rates(struct sta_info *sta)\n{\n\tint i;\n\n\tsta->tx_supp_rates = 0;\n\tfor (i = 0; i < sizeof(sta->supported_rates); i++) {\n\t\tif ((sta->supported_rates[i] & 0x7f) == 2)\n\t\t\tsta->tx_supp_rates |= WLAN_RATE_1M;\n\t\tif ((sta->supported_rates[i] & 0x7f) == 4)\n\t\t\tsta->tx_supp_rates |= WLAN_RATE_2M;\n\t\tif ((sta->supported_rates[i] & 0x7f) == 11)\n\t\t\tsta->tx_supp_rates |= WLAN_RATE_5M5;\n\t\tif ((sta->supported_rates[i] & 0x7f) == 22)\n\t\t\tsta->tx_supp_rates |= WLAN_RATE_11M;\n\t}\n\tsta->tx_max_rate = sta->tx_rate = sta->tx_rate_idx = 0;\n\tif (sta->tx_supp_rates & WLAN_RATE_1M) {\n\t\tsta->tx_max_rate = 0;\n\t\tif (ap_tx_rate_ok(0, sta, sta->local)) {\n\t\t\tsta->tx_rate = 10;\n\t\t\tsta->tx_rate_idx = 0;\n\t\t}\n\t}\n\tif (sta->tx_supp_rates & WLAN_RATE_2M) {\n\t\tsta->tx_max_rate = 1;\n\t\tif (ap_tx_rate_ok(1, sta, sta->local)) {\n\t\t\tsta->tx_rate = 20;\n\t\t\tsta->tx_rate_idx = 1;\n\t\t}\n\t}\n\tif (sta->tx_supp_rates & WLAN_RATE_5M5) {\n\t\tsta->tx_max_rate = 2;\n\t\tif (ap_tx_rate_ok(2, sta, sta->local)) {\n\t\t\tsta->tx_rate = 55;\n\t\t\tsta->tx_rate_idx = 2;\n\t\t}\n\t}\n\tif (sta->tx_supp_rates & WLAN_RATE_11M) {\n\t\tsta->tx_max_rate = 3;\n\t\tif (ap_tx_rate_ok(3, sta, sta->local)) {\n\t\t\tsta->tx_rate = 110;\n\t\t\tsta->tx_rate_idx = 3;\n\t\t}\n\t}\n}\n\n\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\n\nstatic void ap_crypt_init(struct ap_data *ap)\n{\n\tap->crypt = lib80211_get_crypto_ops(\"WEP\");\n\n\tif (ap->crypt) {\n\t\tif (ap->crypt->init) {\n\t\t\tap->crypt_priv = ap->crypt->init(0);\n\t\t\tif (ap->crypt_priv == NULL)\n\t\t\t\tap->crypt = NULL;\n\t\t\telse {\n\t\t\t\tu8 key[WEP_KEY_LEN];\n\t\t\t\tget_random_bytes(key, WEP_KEY_LEN);\n\t\t\t\tap->crypt->set_key(key, WEP_KEY_LEN, NULL,\n\t\t\t\t\t\t   ap->crypt_priv);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ap->crypt == NULL) {\n\t\tprintk(KERN_WARNING \"AP could not initialize WEP: load module \"\n\t\t       \"lib80211_crypt_wep.ko\\n\");\n\t}\n}\n\n\n \nstatic char * ap_auth_make_challenge(struct ap_data *ap)\n{\n\tchar *tmpbuf;\n\tstruct sk_buff *skb;\n\n\tif (ap->crypt == NULL) {\n\t\tap_crypt_init(ap);\n\t\tif (ap->crypt == NULL)\n\t\t\treturn NULL;\n\t}\n\n\ttmpbuf = kmalloc(WLAN_AUTH_CHALLENGE_LEN, GFP_ATOMIC);\n\tif (tmpbuf == NULL) {\n\t\tPDEBUG(DEBUG_AP, \"AP: kmalloc failed for challenge\\n\");\n\t\treturn NULL;\n\t}\n\n\tskb = dev_alloc_skb(WLAN_AUTH_CHALLENGE_LEN +\n\t\t\t    ap->crypt->extra_mpdu_prefix_len +\n\t\t\t    ap->crypt->extra_mpdu_postfix_len);\n\tif (skb == NULL) {\n\t\tkfree(tmpbuf);\n\t\treturn NULL;\n\t}\n\n\tskb_reserve(skb, ap->crypt->extra_mpdu_prefix_len);\n\tskb_put_zero(skb, WLAN_AUTH_CHALLENGE_LEN);\n\tif (ap->crypt->encrypt_mpdu(skb, 0, ap->crypt_priv)) {\n\t\tdev_kfree_skb(skb);\n\t\tkfree(tmpbuf);\n\t\treturn NULL;\n\t}\n\n\tskb_copy_from_linear_data_offset(skb, ap->crypt->extra_mpdu_prefix_len,\n\t\t\t\t\t tmpbuf, WLAN_AUTH_CHALLENGE_LEN);\n\tdev_kfree_skb(skb);\n\n\treturn tmpbuf;\n}\n\n\n \nstatic void handle_authen(local_info_t *local, struct sk_buff *skb,\n\t\t\t  struct hostap_80211_rx_status *rx_stats)\n{\n\tstruct net_device *dev = local->dev;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tsize_t hdrlen;\n\tstruct ap_data *ap = local->ap;\n\tchar body[8 + WLAN_AUTH_CHALLENGE_LEN], *challenge = NULL;\n\tint len, olen;\n\tu16 auth_alg, auth_transaction, status_code;\n\t__le16 *pos;\n\tu16 resp = WLAN_STATUS_SUCCESS;\n\tstruct sta_info *sta = NULL;\n\tstruct lib80211_crypt_data *crypt;\n\tchar *txt = \"\";\n\n\tlen = skb->len - IEEE80211_MGMT_HDR_LEN;\n\n\thdrlen = hostap_80211_get_hdrlen(hdr->frame_control);\n\n\tif (len < 6) {\n\t\tPDEBUG(DEBUG_AP, \"%s: handle_authen - too short payload \"\n\t\t       \"(len=%d) from %pM\\n\", dev->name, len, hdr->addr2);\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&local->ap->sta_table_lock);\n\tsta = ap_get_sta(local->ap, hdr->addr2);\n\tif (sta)\n\t\tatomic_inc(&sta->users);\n\tspin_unlock_bh(&local->ap->sta_table_lock);\n\n\tif (sta && sta->crypt)\n\t\tcrypt = sta->crypt;\n\telse {\n\t\tint idx = 0;\n\t\tif (skb->len >= hdrlen + 3)\n\t\t\tidx = skb->data[hdrlen + 3] >> 6;\n\t\tcrypt = local->crypt_info.crypt[idx];\n\t}\n\n\tpos = (__le16 *) (skb->data + IEEE80211_MGMT_HDR_LEN);\n\tauth_alg = __le16_to_cpu(*pos);\n\tpos++;\n\tauth_transaction = __le16_to_cpu(*pos);\n\tpos++;\n\tstatus_code = __le16_to_cpu(*pos);\n\tpos++;\n\n\tif (ether_addr_equal(dev->dev_addr, hdr->addr2) ||\n\t    ap_control_mac_deny(&ap->mac_restrictions, hdr->addr2)) {\n\t\ttxt = \"authentication denied\";\n\t\tresp = WLAN_STATUS_UNSPECIFIED_FAILURE;\n\t\tgoto fail;\n\t}\n\n\tif (((local->auth_algs & PRISM2_AUTH_OPEN) &&\n\t     auth_alg == WLAN_AUTH_OPEN) ||\n\t    ((local->auth_algs & PRISM2_AUTH_SHARED_KEY) &&\n\t     crypt && auth_alg == WLAN_AUTH_SHARED_KEY)) {\n\t} else {\n\t\ttxt = \"unsupported algorithm\";\n\t\tresp = WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG;\n\t\tgoto fail;\n\t}\n\n\tif (len >= 8) {\n\t\tu8 *u = (u8 *) pos;\n\t\tif (*u == WLAN_EID_CHALLENGE) {\n\t\t\tif (*(u + 1) != WLAN_AUTH_CHALLENGE_LEN) {\n\t\t\t\ttxt = \"invalid challenge len\";\n\t\t\t\tresp = WLAN_STATUS_CHALLENGE_FAIL;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif (len - 8 < WLAN_AUTH_CHALLENGE_LEN) {\n\t\t\t\ttxt = \"challenge underflow\";\n\t\t\t\tresp = WLAN_STATUS_CHALLENGE_FAIL;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tchallenge = (char *) (u + 2);\n\t\t}\n\t}\n\n\tif (sta && sta->ap) {\n\t\tif (time_after(jiffies, sta->u.ap.last_beacon +\n\t\t\t       (10 * sta->listen_interval * HZ) / 1024)) {\n\t\t\tPDEBUG(DEBUG_AP, \"%s: no beacons received for a while,\"\n\t\t\t       \" assuming AP %pM is now STA\\n\",\n\t\t\t       dev->name, sta->addr);\n\t\t\tsta->ap = 0;\n\t\t\tsta->flags = 0;\n\t\t\tsta->u.sta.challenge = NULL;\n\t\t} else {\n\t\t\ttxt = \"AP trying to authenticate?\";\n\t\t\tresp = WLAN_STATUS_UNSPECIFIED_FAILURE;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif ((auth_alg == WLAN_AUTH_OPEN && auth_transaction == 1) ||\n\t    (auth_alg == WLAN_AUTH_SHARED_KEY &&\n\t     (auth_transaction == 1 ||\n\t      (auth_transaction == 3 && sta != NULL &&\n\t       sta->u.sta.challenge != NULL)))) {\n\t} else {\n\t\ttxt = \"unknown authentication transaction number\";\n\t\tresp = WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION;\n\t\tgoto fail;\n\t}\n\n\tif (sta == NULL) {\n\t\ttxt = \"new STA\";\n\n\t\tif (local->ap->num_sta >= MAX_STA_COUNT) {\n\t\t\t \n\t\t\ttxt = \"no more room for new STAs\";\n\t\t\tresp = WLAN_STATUS_UNSPECIFIED_FAILURE;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tsta = ap_add_sta(local->ap, hdr->addr2);\n\t\tif (sta == NULL) {\n\t\t\ttxt = \"ap_add_sta failed\";\n\t\t\tresp = WLAN_STATUS_UNSPECIFIED_FAILURE;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tswitch (auth_alg) {\n\tcase WLAN_AUTH_OPEN:\n\t\ttxt = \"authOK\";\n\t\t \n\t\tsta->flags |= WLAN_STA_AUTH;\n\t\tbreak;\n\n\tcase WLAN_AUTH_SHARED_KEY:\n\t\tif (auth_transaction == 1) {\n\t\t\tif (sta->u.sta.challenge == NULL) {\n\t\t\t\tsta->u.sta.challenge =\n\t\t\t\t\tap_auth_make_challenge(local->ap);\n\t\t\t\tif (sta->u.sta.challenge == NULL) {\n\t\t\t\t\tresp = WLAN_STATUS_UNSPECIFIED_FAILURE;\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (sta->u.sta.challenge == NULL ||\n\t\t\t    challenge == NULL ||\n\t\t\t    memcmp(sta->u.sta.challenge, challenge,\n\t\t\t\t   WLAN_AUTH_CHALLENGE_LEN) != 0 ||\n\t\t\t    !ieee80211_has_protected(hdr->frame_control)) {\n\t\t\t\ttxt = \"challenge response incorrect\";\n\t\t\t\tresp = WLAN_STATUS_CHALLENGE_FAIL;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\ttxt = \"challenge OK - authOK\";\n\t\t\t \n\t\t\tsta->flags |= WLAN_STA_AUTH;\n\t\t\tkfree(sta->u.sta.challenge);\n\t\t\tsta->u.sta.challenge = NULL;\n\t\t}\n\t\tbreak;\n\t}\n\n fail:\n\tpos = (__le16 *) body;\n\t*pos = cpu_to_le16(auth_alg);\n\tpos++;\n\t*pos = cpu_to_le16(auth_transaction + 1);\n\tpos++;\n\t*pos = cpu_to_le16(resp);  \n\tpos++;\n\tolen = 6;\n\n\tif (resp == WLAN_STATUS_SUCCESS && sta != NULL &&\n\t    sta->u.sta.challenge != NULL &&\n\t    auth_alg == WLAN_AUTH_SHARED_KEY && auth_transaction == 1) {\n\t\tu8 *tmp = (u8 *) pos;\n\t\t*tmp++ = WLAN_EID_CHALLENGE;\n\t\t*tmp++ = WLAN_AUTH_CHALLENGE_LEN;\n\t\tpos++;\n\t\tmemcpy(pos, sta->u.sta.challenge, WLAN_AUTH_CHALLENGE_LEN);\n\t\tolen += 2 + WLAN_AUTH_CHALLENGE_LEN;\n\t}\n\n\tprism2_send_mgmt(dev, IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_AUTH,\n\t\t\t body, olen, hdr->addr2, ap->tx_callback_auth);\n\n\tif (sta) {\n\t\tsta->last_rx = jiffies;\n\t\tatomic_dec(&sta->users);\n\t}\n\n\tif (resp) {\n\t\tPDEBUG(DEBUG_AP, \"%s: %pM auth (alg=%d \"\n\t\t       \"trans#=%d stat=%d len=%d fc=%04x) ==> %d (%s)\\n\",\n\t\t       dev->name, hdr->addr2,\n\t\t       auth_alg, auth_transaction, status_code, len,\n\t\t       le16_to_cpu(hdr->frame_control), resp, txt);\n\t}\n}\n\n\n \nstatic void handle_assoc(local_info_t *local, struct sk_buff *skb,\n\t\t\t struct hostap_80211_rx_status *rx_stats, int reassoc)\n{\n\tstruct net_device *dev = local->dev;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tchar body[12], *p, *lpos;\n\tint len, left;\n\t__le16 *pos;\n\tu16 resp = WLAN_STATUS_SUCCESS;\n\tstruct sta_info *sta = NULL;\n\tint send_deauth = 0;\n\tchar __always_unused *txt = \"\";\n\tu8 prev_ap[ETH_ALEN];\n\n\tleft = len = skb->len - IEEE80211_MGMT_HDR_LEN;\n\n\tif (len < (reassoc ? 10 : 4)) {\n\t\tPDEBUG(DEBUG_AP, \"%s: handle_assoc - too short payload \"\n\t\t       \"(len=%d, reassoc=%d) from %pM\\n\",\n\t\t       dev->name, len, reassoc, hdr->addr2);\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&local->ap->sta_table_lock);\n\tsta = ap_get_sta(local->ap, hdr->addr2);\n\tif (sta == NULL || (sta->flags & WLAN_STA_AUTH) == 0) {\n\t\tspin_unlock_bh(&local->ap->sta_table_lock);\n\t\ttxt = \"trying to associate before authentication\";\n\t\tsend_deauth = 1;\n\t\tresp = WLAN_STATUS_UNSPECIFIED_FAILURE;\n\t\tsta = NULL;  \n\t\tgoto fail;\n\t}\n\tatomic_inc(&sta->users);\n\tspin_unlock_bh(&local->ap->sta_table_lock);\n\n\tpos = (__le16 *) (skb->data + IEEE80211_MGMT_HDR_LEN);\n\tsta->capability = __le16_to_cpu(*pos);\n\tpos++; left -= 2;\n\tsta->listen_interval = __le16_to_cpu(*pos);\n\tpos++; left -= 2;\n\n\tif (reassoc) {\n\t\tmemcpy(prev_ap, pos, ETH_ALEN);\n\t\tpos++; pos++; pos++; left -= 6;\n\t} else\n\t\teth_zero_addr(prev_ap);\n\n\tif (left >= 2) {\n\t\tunsigned int ileft;\n\t\tunsigned char *u = (unsigned char *) pos;\n\n\t\tif (*u == WLAN_EID_SSID) {\n\t\t\tu++; left--;\n\t\t\tileft = *u;\n\t\t\tu++; left--;\n\n\t\t\tif (ileft > left || ileft > MAX_SSID_LEN) {\n\t\t\t\ttxt = \"SSID overflow\";\n\t\t\t\tresp = WLAN_STATUS_UNSPECIFIED_FAILURE;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (ileft != strlen(local->essid) ||\n\t\t\t    memcmp(local->essid, u, ileft) != 0) {\n\t\t\t\ttxt = \"not our SSID\";\n\t\t\t\tresp = WLAN_STATUS_ASSOC_DENIED_UNSPEC;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tu += ileft;\n\t\t\tleft -= ileft;\n\t\t}\n\n\t\tif (left >= 2 && *u == WLAN_EID_SUPP_RATES) {\n\t\t\tu++; left--;\n\t\t\tileft = *u;\n\t\t\tu++; left--;\n\n\t\t\tif (ileft > left || ileft == 0 ||\n\t\t\t    ileft > WLAN_SUPP_RATES_MAX) {\n\t\t\t\ttxt = \"SUPP_RATES len error\";\n\t\t\t\tresp = WLAN_STATUS_UNSPECIFIED_FAILURE;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tmemset(sta->supported_rates, 0,\n\t\t\t       sizeof(sta->supported_rates));\n\t\t\tmemcpy(sta->supported_rates, u, ileft);\n\t\t\tprism2_check_tx_rates(sta);\n\n\t\t\tu += ileft;\n\t\t\tleft -= ileft;\n\t\t}\n\n\t\tif (left > 0) {\n\t\t\tPDEBUG(DEBUG_AP, \"%s: assoc from %pM\"\n\t\t\t       \" with extra data (%d bytes) [\",\n\t\t\t       dev->name, hdr->addr2, left);\n\t\t\twhile (left > 0) {\n\t\t\t\tPDEBUG2(DEBUG_AP, \"<%02x>\", *u);\n\t\t\t\tu++; left--;\n\t\t\t}\n\t\t\tPDEBUG2(DEBUG_AP, \"]\\n\");\n\t\t}\n\t} else {\n\t\ttxt = \"frame underflow\";\n\t\tresp = WLAN_STATUS_UNSPECIFIED_FAILURE;\n\t\tgoto fail;\n\t}\n\n\t \n\tif (sta->aid > 0)\n\t\ttxt = \"OK, old AID\";\n\telse {\n\t\tspin_lock_bh(&local->ap->sta_table_lock);\n\t\tfor (sta->aid = 1; sta->aid <= MAX_AID_TABLE_SIZE; sta->aid++)\n\t\t\tif (local->ap->sta_aid[sta->aid - 1] == NULL)\n\t\t\t\tbreak;\n\t\tif (sta->aid > MAX_AID_TABLE_SIZE) {\n\t\t\tsta->aid = 0;\n\t\t\tspin_unlock_bh(&local->ap->sta_table_lock);\n\t\t\tresp = WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA;\n\t\t\ttxt = \"no room for more AIDs\";\n\t\t} else {\n\t\t\tlocal->ap->sta_aid[sta->aid - 1] = sta;\n\t\t\tspin_unlock_bh(&local->ap->sta_table_lock);\n\t\t\ttxt = \"OK, new AID\";\n\t\t}\n\t}\n\n fail:\n\tpos = (__le16 *) body;\n\n\tif (send_deauth) {\n\t\t*pos = cpu_to_le16(WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH);\n\t\tpos++;\n\t} else {\n\t\t \n\t\t \n\t\t \n\t\t*pos = cpu_to_le16(WLAN_CAPABILITY_ESS);\n\t\tpos++;\n\n\t\t \n\t\t*pos = cpu_to_le16(resp);\n\t\tpos++;\n\n\t\t*pos = cpu_to_le16((sta && sta->aid > 0 ? sta->aid : 0) |\n\t\t\t\t     BIT(14) | BIT(15));  \n\t\tpos++;\n\n\t\t \n\t\tp = (char *) pos;\n\t\t*p++ = WLAN_EID_SUPP_RATES;\n\t\tlpos = p;\n\t\t*p++ = 0;  \n\t\tif (local->tx_rate_control & WLAN_RATE_1M) {\n\t\t\t*p++ = local->basic_rates & WLAN_RATE_1M ? 0x82 : 0x02;\n\t\t\t(*lpos)++;\n\t\t}\n\t\tif (local->tx_rate_control & WLAN_RATE_2M) {\n\t\t\t*p++ = local->basic_rates & WLAN_RATE_2M ? 0x84 : 0x04;\n\t\t\t(*lpos)++;\n\t\t}\n\t\tif (local->tx_rate_control & WLAN_RATE_5M5) {\n\t\t\t*p++ = local->basic_rates & WLAN_RATE_5M5 ?\n\t\t\t\t0x8b : 0x0b;\n\t\t\t(*lpos)++;\n\t\t}\n\t\tif (local->tx_rate_control & WLAN_RATE_11M) {\n\t\t\t*p++ = local->basic_rates & WLAN_RATE_11M ?\n\t\t\t\t0x96 : 0x16;\n\t\t\t(*lpos)++;\n\t\t}\n\t\tpos = (__le16 *) p;\n\t}\n\n\tprism2_send_mgmt(dev, IEEE80211_FTYPE_MGMT |\n\t\t\t (send_deauth ? IEEE80211_STYPE_DEAUTH :\n\t\t\t  (reassoc ? IEEE80211_STYPE_REASSOC_RESP :\n\t\t\t   IEEE80211_STYPE_ASSOC_RESP)),\n\t\t\t body, (u8 *) pos - (u8 *) body,\n\t\t\t hdr->addr2,\n\t\t\t send_deauth ? 0 : local->ap->tx_callback_assoc);\n\n\tif (sta) {\n\t\tif (resp == WLAN_STATUS_SUCCESS) {\n\t\t\tsta->last_rx = jiffies;\n\t\t\t \n\t\t}\n\t\tatomic_dec(&sta->users);\n\t}\n\n#if 0\n\tPDEBUG(DEBUG_AP, \"%s: %pM %sassoc (len=%d \"\n\t       \"prev_ap=%pM) => %d(%d) (%s)\\n\",\n\t       dev->name,\n\t       hdr->addr2,\n\t       reassoc ? \"re\" : \"\", len,\n\t       prev_ap,\n\t       resp, send_deauth, txt);\n#endif\n}\n\n\n \nstatic void handle_deauth(local_info_t *local, struct sk_buff *skb,\n\t\t\t  struct hostap_80211_rx_status *rx_stats)\n{\n\tstruct net_device *dev = local->dev;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tchar *body = (char *) (skb->data + IEEE80211_MGMT_HDR_LEN);\n\tint len;\n\tu16 reason_code;\n\t__le16 *pos;\n\tstruct sta_info *sta = NULL;\n\n\tlen = skb->len - IEEE80211_MGMT_HDR_LEN;\n\n\tif (len < 2) {\n\t\tprintk(\"handle_deauth - too short payload (len=%d)\\n\", len);\n\t\treturn;\n\t}\n\n\tpos = (__le16 *) body;\n\treason_code = le16_to_cpu(*pos);\n\n\tPDEBUG(DEBUG_AP, \"%s: deauthentication: %pM len=%d, \"\n\t       \"reason_code=%d\\n\", dev->name, hdr->addr2,\n\t       len, reason_code);\n\n\tspin_lock_bh(&local->ap->sta_table_lock);\n\tsta = ap_get_sta(local->ap, hdr->addr2);\n\tif (sta != NULL) {\n\t\tif ((sta->flags & WLAN_STA_ASSOC) && !sta->ap)\n\t\t\thostap_event_expired_sta(local->dev, sta);\n\t\tsta->flags &= ~(WLAN_STA_AUTH | WLAN_STA_ASSOC);\n\t}\n\tspin_unlock_bh(&local->ap->sta_table_lock);\n\tif (sta == NULL) {\n\t\tprintk(\"%s: deauthentication from %pM, \"\n\t       \"reason_code=%d, but STA not authenticated\\n\", dev->name,\n\t\t       hdr->addr2, reason_code);\n\t}\n}\n\n\n \nstatic void handle_disassoc(local_info_t *local, struct sk_buff *skb,\n\t\t\t    struct hostap_80211_rx_status *rx_stats)\n{\n\tstruct net_device *dev = local->dev;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tchar *body = skb->data + IEEE80211_MGMT_HDR_LEN;\n\tint len;\n\tu16 reason_code;\n\t__le16 *pos;\n\tstruct sta_info *sta = NULL;\n\n\tlen = skb->len - IEEE80211_MGMT_HDR_LEN;\n\n\tif (len < 2) {\n\t\tprintk(\"handle_disassoc - too short payload (len=%d)\\n\", len);\n\t\treturn;\n\t}\n\n\tpos = (__le16 *) body;\n\treason_code = le16_to_cpu(*pos);\n\n\tPDEBUG(DEBUG_AP, \"%s: disassociation: %pM len=%d, \"\n\t       \"reason_code=%d\\n\", dev->name, hdr->addr2,\n\t       len, reason_code);\n\n\tspin_lock_bh(&local->ap->sta_table_lock);\n\tsta = ap_get_sta(local->ap, hdr->addr2);\n\tif (sta != NULL) {\n\t\tif ((sta->flags & WLAN_STA_ASSOC) && !sta->ap)\n\t\t\thostap_event_expired_sta(local->dev, sta);\n\t\tsta->flags &= ~WLAN_STA_ASSOC;\n\t}\n\tspin_unlock_bh(&local->ap->sta_table_lock);\n\tif (sta == NULL) {\n\t\tprintk(\"%s: disassociation from %pM, \"\n\t\t       \"reason_code=%d, but STA not authenticated\\n\",\n\t\t       dev->name, hdr->addr2, reason_code);\n\t}\n}\n\n\n \nstatic void ap_handle_data_nullfunc(local_info_t *local,\n\t\t\t\t    struct ieee80211_hdr *hdr)\n{\n\tstruct net_device *dev = local->dev;\n\n\t \n\n\tprintk(KERN_DEBUG \"Sending control::ACK for data::nullfunc\\n\");\n\tprism2_send_mgmt(dev, IEEE80211_FTYPE_CTL | IEEE80211_STYPE_ACK,\n\t\t\t NULL, 0, hdr->addr2, 0);\n}\n\n\n \nstatic void ap_handle_dropped_data(local_info_t *local,\n\t\t\t\t   struct ieee80211_hdr *hdr)\n{\n\tstruct net_device *dev = local->dev;\n\tstruct sta_info *sta;\n\t__le16 reason;\n\n\tspin_lock_bh(&local->ap->sta_table_lock);\n\tsta = ap_get_sta(local->ap, hdr->addr2);\n\tif (sta)\n\t\tatomic_inc(&sta->users);\n\tspin_unlock_bh(&local->ap->sta_table_lock);\n\n\tif (sta != NULL && (sta->flags & WLAN_STA_ASSOC)) {\n\t\tPDEBUG(DEBUG_AP, \"ap_handle_dropped_data: STA is now okay?\\n\");\n\t\tatomic_dec(&sta->users);\n\t\treturn;\n\t}\n\n\treason = cpu_to_le16(WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);\n\tprism2_send_mgmt(dev, IEEE80211_FTYPE_MGMT |\n\t\t\t ((sta == NULL || !(sta->flags & WLAN_STA_ASSOC)) ?\n\t\t\t  IEEE80211_STYPE_DEAUTH : IEEE80211_STYPE_DISASSOC),\n\t\t\t (char *) &reason, sizeof(reason), hdr->addr2, 0);\n\n\tif (sta)\n\t\tatomic_dec(&sta->users);\n}\n\n#endif  \n\n\n \nstatic void pspoll_send_buffered(local_info_t *local, struct sta_info *sta,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct hostap_skb_tx_data *meta;\n\n\tif (!(sta->flags & WLAN_STA_PS)) {\n\t\t \n\t\tdev_queue_xmit(skb);\n\t\treturn;\n\t}\n\n\t \n\tmeta = (struct hostap_skb_tx_data *) skb->cb;\n\tmeta->flags |= HOSTAP_TX_FLAGS_BUFFERED_FRAME;\n\tif (!skb_queue_empty(&sta->tx_buf)) {\n\t\t \n\t\tmeta->flags |= HOSTAP_TX_FLAGS_ADD_MOREDATA;\n\t}\n\tdev_queue_xmit(skb);\n}\n\n\n \nstatic void handle_pspoll(local_info_t *local,\n\t\t\t  struct ieee80211_hdr *hdr,\n\t\t\t  struct hostap_80211_rx_status *rx_stats)\n{\n\tstruct net_device *dev = local->dev;\n\tstruct sta_info *sta;\n\tu16 aid;\n\tstruct sk_buff *skb;\n\n\tPDEBUG(DEBUG_PS2, \"handle_pspoll: BSSID=%pM, TA=%pM PWRMGT=%d\\n\",\n\t       hdr->addr1, hdr->addr2, !!ieee80211_has_pm(hdr->frame_control));\n\n\tif (!ether_addr_equal(hdr->addr1, dev->dev_addr)) {\n\t\tPDEBUG(DEBUG_AP,\n\t\t       \"handle_pspoll - addr1(BSSID)=%pM not own MAC\\n\",\n\t\t       hdr->addr1);\n\t\treturn;\n\t}\n\n\taid = le16_to_cpu(hdr->duration_id);\n\tif ((aid & (BIT(15) | BIT(14))) != (BIT(15) | BIT(14))) {\n\t\tPDEBUG(DEBUG_PS, \"   PSPOLL and AID[15:14] not set\\n\");\n\t\treturn;\n\t}\n\taid &= ~(BIT(15) | BIT(14));\n\tif (aid == 0 || aid > MAX_AID_TABLE_SIZE) {\n\t\tPDEBUG(DEBUG_PS, \"   invalid aid=%d\\n\", aid);\n\t\treturn;\n\t}\n\tPDEBUG(DEBUG_PS2, \"   aid=%d\\n\", aid);\n\n\tspin_lock_bh(&local->ap->sta_table_lock);\n\tsta = ap_get_sta(local->ap, hdr->addr2);\n\tif (sta)\n\t\tatomic_inc(&sta->users);\n\tspin_unlock_bh(&local->ap->sta_table_lock);\n\n\tif (sta == NULL) {\n\t\tPDEBUG(DEBUG_PS, \"   STA not found\\n\");\n\t\treturn;\n\t}\n\tif (sta->aid != aid) {\n\t\tPDEBUG(DEBUG_PS, \"   received aid=%i does not match with \"\n\t\t       \"assoc.aid=%d\\n\", aid, sta->aid);\n\t\treturn;\n\t}\n\n\t \n\n\twhile ((skb = skb_dequeue(&sta->tx_buf)) != NULL) {\n\t\t \n\t\tPDEBUG(DEBUG_PS2, \"Sending buffered frame to STA after PS POLL\"\n\t\t       \" (buffer_count=%d)\\n\", skb_queue_len(&sta->tx_buf));\n\n\t\tpspoll_send_buffered(local, sta, skb);\n\n\t\tif (sta->flags & WLAN_STA_PS) {\n\t\t\t \n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (skb_queue_empty(&sta->tx_buf)) {\n\t\t \n\t\tif (!(sta->flags & WLAN_STA_TIM))\n\t\t\tPDEBUG(DEBUG_PS2,  \"Re-unsetting TIM for aid %d\\n\",\n\t\t\t       aid);\n\t\thostap_set_tim(local, aid, 0);\n\t\tsta->flags &= ~WLAN_STA_TIM;\n\t}\n\n\tatomic_dec(&sta->users);\n}\n\n\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\n\nstatic void handle_wds_oper_queue(struct work_struct *work)\n{\n\tstruct ap_data *ap = container_of(work, struct ap_data,\n\t\t\t\t\t  wds_oper_queue);\n\tlocal_info_t *local = ap->local;\n\tstruct wds_oper_data *entry, *prev;\n\n\tspin_lock_bh(&local->lock);\n\tentry = local->ap->wds_oper_entries;\n\tlocal->ap->wds_oper_entries = NULL;\n\tspin_unlock_bh(&local->lock);\n\n\twhile (entry) {\n\t\tPDEBUG(DEBUG_AP, \"%s: %s automatic WDS connection \"\n\t\t       \"to AP %pM\\n\",\n\t\t       local->dev->name,\n\t\t       entry->type == WDS_ADD ? \"adding\" : \"removing\",\n\t\t       entry->addr);\n\t\tif (entry->type == WDS_ADD)\n\t\t\tprism2_wds_add(local, entry->addr, 0);\n\t\telse if (entry->type == WDS_DEL)\n\t\t\tprism2_wds_del(local, entry->addr, 0, 1);\n\n\t\tprev = entry;\n\t\tentry = entry->next;\n\t\tkfree(prev);\n\t}\n}\n\n\n \nstatic void handle_beacon(local_info_t *local, struct sk_buff *skb,\n\t\t\t  struct hostap_80211_rx_status *rx_stats)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tchar *body = skb->data + IEEE80211_MGMT_HDR_LEN;\n\tint len, left;\n\tu16 beacon_int, capability;\n\t__le16 *pos;\n\tchar *ssid = NULL;\n\tunsigned char *supp_rates = NULL;\n\tint ssid_len = 0, supp_rates_len = 0;\n\tstruct sta_info *sta = NULL;\n\tint new_sta = 0, channel = -1;\n\n\tlen = skb->len - IEEE80211_MGMT_HDR_LEN;\n\n\tif (len < 8 + 2 + 2) {\n\t\tprintk(KERN_DEBUG \"handle_beacon - too short payload \"\n\t\t       \"(len=%d)\\n\", len);\n\t\treturn;\n\t}\n\n\tpos = (__le16 *) body;\n\tleft = len;\n\n\t \n\tpos += 4; left -= 8;\n\t \n\tbeacon_int = le16_to_cpu(*pos);\n\tpos++; left -= 2;\n\t \n\tcapability = le16_to_cpu(*pos);\n\tpos++; left -= 2;\n\n\tif (local->ap->ap_policy != AP_OTHER_AP_EVEN_IBSS &&\n\t    capability & WLAN_CAPABILITY_IBSS)\n\t\treturn;\n\n\tif (left >= 2) {\n\t\tunsigned int ileft;\n\t\tunsigned char *u = (unsigned char *) pos;\n\n\t\tif (*u == WLAN_EID_SSID) {\n\t\t\tu++; left--;\n\t\t\tileft = *u;\n\t\t\tu++; left--;\n\n\t\t\tif (ileft > left || ileft > MAX_SSID_LEN) {\n\t\t\t\tPDEBUG(DEBUG_AP, \"SSID: overflow\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (local->ap->ap_policy == AP_OTHER_AP_SAME_SSID &&\n\t\t\t    (ileft != strlen(local->essid) ||\n\t\t\t     memcmp(local->essid, u, ileft) != 0)) {\n\t\t\t\t \n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tssid = u;\n\t\t\tssid_len = ileft;\n\n\t\t\tu += ileft;\n\t\t\tleft -= ileft;\n\t\t}\n\n\t\tif (*u == WLAN_EID_SUPP_RATES) {\n\t\t\tu++; left--;\n\t\t\tileft = *u;\n\t\t\tu++; left--;\n\n\t\t\tif (ileft > left || ileft == 0 || ileft > 8) {\n\t\t\t\tPDEBUG(DEBUG_AP, \" - SUPP_RATES len error\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tsupp_rates = u;\n\t\t\tsupp_rates_len = ileft;\n\n\t\t\tu += ileft;\n\t\t\tleft -= ileft;\n\t\t}\n\n\t\tif (*u == WLAN_EID_DS_PARAMS) {\n\t\t\tu++; left--;\n\t\t\tileft = *u;\n\t\t\tu++; left--;\n\n\t\t\tif (ileft > left || ileft != 1) {\n\t\t\t\tPDEBUG(DEBUG_AP, \" - DS_PARAMS len error\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tchannel = *u;\n\n\t\t\tu += ileft;\n\t\t\tleft -= ileft;\n\t\t}\n\t}\n\n\tspin_lock_bh(&local->ap->sta_table_lock);\n\tsta = ap_get_sta(local->ap, hdr->addr2);\n\tif (sta != NULL)\n\t\tatomic_inc(&sta->users);\n\tspin_unlock_bh(&local->ap->sta_table_lock);\n\n\tif (sta == NULL) {\n\t\t \n\t\tnew_sta = 1;\n\t\tsta = ap_add_sta(local->ap, hdr->addr2);\n\t\tif (sta == NULL) {\n\t\t\tprintk(KERN_INFO \"prism2: kmalloc failed for AP \"\n\t\t\t       \"data structure\\n\");\n\t\t\treturn;\n\t\t}\n\t\thostap_event_new_sta(local->dev, sta);\n\n\t\t \n\t\tsta->flags = WLAN_STA_AUTH | WLAN_STA_ASSOC;\n\n\t\tif (local->ap->autom_ap_wds) {\n\t\t\thostap_wds_link_oper(local, sta->addr, WDS_ADD);\n\t\t}\n\t}\n\n\tsta->ap = 1;\n\tif (ssid) {\n\t\tsta->u.ap.ssid_len = ssid_len;\n\t\tmemcpy(sta->u.ap.ssid, ssid, ssid_len);\n\t\tsta->u.ap.ssid[ssid_len] = '\\0';\n\t} else {\n\t\tsta->u.ap.ssid_len = 0;\n\t\tsta->u.ap.ssid[0] = '\\0';\n\t}\n\tsta->u.ap.channel = channel;\n\tsta->rx_packets++;\n\tsta->rx_bytes += len;\n\tsta->u.ap.last_beacon = sta->last_rx = jiffies;\n\tsta->capability = capability;\n\tsta->listen_interval = beacon_int;\n\n\tatomic_dec(&sta->users);\n\n\tif (new_sta) {\n\t\tmemset(sta->supported_rates, 0, sizeof(sta->supported_rates));\n\t\tmemcpy(sta->supported_rates, supp_rates, supp_rates_len);\n\t\tprism2_check_tx_rates(sta);\n\t}\n}\n\n#endif  \n\n\n \nstatic void handle_ap_item(local_info_t *local, struct sk_buff *skb,\n\t\t\t   struct hostap_80211_rx_status *rx_stats)\n{\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\n\tstruct net_device *dev = local->dev;\n#endif  \n\tu16 fc, type, stype;\n\tstruct ieee80211_hdr *hdr;\n\n\t \n\thdr = (struct ieee80211_hdr *) skb->data;\n\tfc = le16_to_cpu(hdr->frame_control);\n\ttype = fc & IEEE80211_FCTL_FTYPE;\n\tstype = fc & IEEE80211_FCTL_STYPE;\n\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\n\tif (!local->hostapd && type == IEEE80211_FTYPE_DATA) {\n\t\tPDEBUG(DEBUG_AP, \"handle_ap_item - data frame\\n\");\n\n\t\tif (!(fc & IEEE80211_FCTL_TODS) ||\n\t\t    (fc & IEEE80211_FCTL_FROMDS)) {\n\t\t\tif (stype == IEEE80211_STYPE_NULLFUNC) {\n\t\t\t\t \n\t\t\t\tap_handle_dropped_data(local, hdr);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tPDEBUG(DEBUG_AP, \"   not ToDS frame (fc=0x%04x)\\n\",\n\t\t\t       fc);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!ether_addr_equal(hdr->addr1, dev->dev_addr)) {\n\t\t\tPDEBUG(DEBUG_AP, \"handle_ap_item - addr1(BSSID)=%pM\"\n\t\t\t       \" not own MAC\\n\", hdr->addr1);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (local->ap->nullfunc_ack &&\n\t\t    stype == IEEE80211_STYPE_NULLFUNC)\n\t\t\tap_handle_data_nullfunc(local, hdr);\n\t\telse\n\t\t\tap_handle_dropped_data(local, hdr);\n\t\tgoto done;\n\t}\n\n\tif (type == IEEE80211_FTYPE_MGMT && stype == IEEE80211_STYPE_BEACON) {\n\t\thandle_beacon(local, skb, rx_stats);\n\t\tgoto done;\n\t}\n#endif  \n\n\tif (type == IEEE80211_FTYPE_CTL && stype == IEEE80211_STYPE_PSPOLL) {\n\t\thandle_pspoll(local, hdr, rx_stats);\n\t\tgoto done;\n\t}\n\n\tif (local->hostapd) {\n\t\tPDEBUG(DEBUG_AP, \"Unknown frame in AP queue: type=0x%02x \"\n\t\t       \"subtype=0x%02x\\n\", type, stype);\n\t\tgoto done;\n\t}\n\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\n\tif (type != IEEE80211_FTYPE_MGMT) {\n\t\tPDEBUG(DEBUG_AP, \"handle_ap_item - not a management frame?\\n\");\n\t\tgoto done;\n\t}\n\n\tif (!ether_addr_equal(hdr->addr1, dev->dev_addr)) {\n\t\tPDEBUG(DEBUG_AP, \"handle_ap_item - addr1(DA)=%pM\"\n\t\t       \" not own MAC\\n\", hdr->addr1);\n\t\tgoto done;\n\t}\n\n\tif (!ether_addr_equal(hdr->addr3, dev->dev_addr)) {\n\t\tPDEBUG(DEBUG_AP, \"handle_ap_item - addr3(BSSID)=%pM\"\n\t\t       \" not own MAC\\n\", hdr->addr3);\n\t\tgoto done;\n\t}\n\n\tswitch (stype) {\n\tcase IEEE80211_STYPE_ASSOC_REQ:\n\t\thandle_assoc(local, skb, rx_stats, 0);\n\t\tbreak;\n\tcase IEEE80211_STYPE_ASSOC_RESP:\n\t\tPDEBUG(DEBUG_AP, \"==> ASSOC RESP (ignored)\\n\");\n\t\tbreak;\n\tcase IEEE80211_STYPE_REASSOC_REQ:\n\t\thandle_assoc(local, skb, rx_stats, 1);\n\t\tbreak;\n\tcase IEEE80211_STYPE_REASSOC_RESP:\n\t\tPDEBUG(DEBUG_AP, \"==> REASSOC RESP (ignored)\\n\");\n\t\tbreak;\n\tcase IEEE80211_STYPE_ATIM:\n\t\tPDEBUG(DEBUG_AP, \"==> ATIM (ignored)\\n\");\n\t\tbreak;\n\tcase IEEE80211_STYPE_DISASSOC:\n\t\thandle_disassoc(local, skb, rx_stats);\n\t\tbreak;\n\tcase IEEE80211_STYPE_AUTH:\n\t\thandle_authen(local, skb, rx_stats);\n\t\tbreak;\n\tcase IEEE80211_STYPE_DEAUTH:\n\t\thandle_deauth(local, skb, rx_stats);\n\t\tbreak;\n\tdefault:\n\t\tPDEBUG(DEBUG_AP, \"Unknown mgmt frame subtype 0x%02x\\n\",\n\t\t       stype >> 4);\n\t\tbreak;\n\t}\n#endif  \n\n done:\n\tdev_kfree_skb(skb);\n}\n\n\n \nvoid hostap_rx(struct net_device *dev, struct sk_buff *skb,\n\t       struct hostap_80211_rx_status *rx_stats)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tstruct ieee80211_hdr *hdr;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (skb->len < 16)\n\t\tgoto drop;\n\n\tdev->stats.rx_packets++;\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\n\tif (local->ap->ap_policy == AP_OTHER_AP_SKIP_ALL &&\n\t    ieee80211_is_beacon(hdr->frame_control))\n\t\tgoto drop;\n\n\tskb->protocol = cpu_to_be16(ETH_P_HOSTAP);\n\thandle_ap_item(local, skb, rx_stats);\n\treturn;\n\n drop:\n\tdev_kfree_skb(skb);\n}\n\n\n \nstatic void schedule_packet_send(local_info_t *local, struct sta_info *sta)\n{\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr *hdr;\n\tstruct hostap_80211_rx_status rx_stats;\n\n\tif (skb_queue_empty(&sta->tx_buf))\n\t\treturn;\n\n\tskb = dev_alloc_skb(16);\n\tif (skb == NULL) {\n\t\tprintk(KERN_DEBUG \"%s: schedule_packet_send: skb alloc \"\n\t\t       \"failed\\n\", local->dev->name);\n\t\treturn;\n\t}\n\n\thdr = skb_put(skb, 16);\n\n\t \n\thdr->frame_control = cpu_to_le16(\n\t\tIEEE80211_FTYPE_CTL | IEEE80211_STYPE_PSPOLL);\n\tmemcpy(hdr->addr1, local->dev->dev_addr, ETH_ALEN);\n\tmemcpy(hdr->addr2, sta->addr, ETH_ALEN);\n\thdr->duration_id = cpu_to_le16(sta->aid | BIT(15) | BIT(14));\n\n\tPDEBUG(DEBUG_PS2,\n\t       \"%s: Scheduling buffered packet delivery for STA %pM\\n\",\n\t       local->dev->name, sta->addr);\n\n\tskb->dev = local->dev;\n\n\tmemset(&rx_stats, 0, sizeof(rx_stats));\n\thostap_rx(local->dev, skb, &rx_stats);\n}\n\n\nint prism2_ap_get_sta_qual(local_info_t *local, struct sockaddr addr[],\n\t\t\t   struct iw_quality qual[], int buf_size,\n\t\t\t   int aplist)\n{\n\tstruct ap_data *ap = local->ap;\n\tstruct list_head *ptr;\n\tint count = 0;\n\n\tspin_lock_bh(&ap->sta_table_lock);\n\n\tfor (ptr = ap->sta_list.next; ptr != NULL && ptr != &ap->sta_list;\n\t     ptr = ptr->next) {\n\t\tstruct sta_info *sta = (struct sta_info *) ptr;\n\n\t\tif (aplist && !sta->ap)\n\t\t\tcontinue;\n\t\taddr[count].sa_family = ARPHRD_ETHER;\n\t\tmemcpy(addr[count].sa_data, sta->addr, ETH_ALEN);\n\t\tif (sta->last_rx_silence == 0)\n\t\t\tqual[count].qual = sta->last_rx_signal < 27 ?\n\t\t\t\t0 : (sta->last_rx_signal - 27) * 92 / 127;\n\t\telse\n\t\t\tqual[count].qual = sta->last_rx_signal -\n\t\t\t\tsta->last_rx_silence - 35;\n\t\tqual[count].level = HFA384X_LEVEL_TO_dBm(sta->last_rx_signal);\n\t\tqual[count].noise = HFA384X_LEVEL_TO_dBm(sta->last_rx_silence);\n\t\tqual[count].updated = sta->last_rx_updated;\n\n\t\tsta->last_rx_updated = IW_QUAL_DBM;\n\n\t\tcount++;\n\t\tif (count >= buf_size)\n\t\t\tbreak;\n\t}\n\tspin_unlock_bh(&ap->sta_table_lock);\n\n\treturn count;\n}\n\n\n \nint prism2_ap_translate_scan(struct net_device *dev,\n\t\t\t     struct iw_request_info *info, char *buffer)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tstruct ap_data *ap;\n\tstruct list_head *ptr;\n\tstruct iw_event iwe;\n\tchar *current_ev = buffer;\n\tchar *end_buf = buffer + IW_SCAN_MAX_DATA;\n#if !defined(PRISM2_NO_KERNEL_IEEE80211_MGMT)\n\tchar buf[64];\n#endif\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\tap = local->ap;\n\n\tspin_lock_bh(&ap->sta_table_lock);\n\n\tfor (ptr = ap->sta_list.next; ptr != NULL && ptr != &ap->sta_list;\n\t     ptr = ptr->next) {\n\t\tstruct sta_info *sta = (struct sta_info *) ptr;\n\n\t\t \n\t\tmemset(&iwe, 0, sizeof(iwe));\n\t\tiwe.cmd = SIOCGIWAP;\n\t\tiwe.u.ap_addr.sa_family = ARPHRD_ETHER;\n\t\tmemcpy(iwe.u.ap_addr.sa_data, sta->addr, ETH_ALEN);\n\t\tiwe.len = IW_EV_ADDR_LEN;\n\t\tcurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\n\t\t\t\t\t\t  &iwe, IW_EV_ADDR_LEN);\n\n\t\t \n\t\tmemset(&iwe, 0, sizeof(iwe));\n\t\tiwe.cmd = SIOCGIWMODE;\n\t\tif (sta->ap)\n\t\t\tiwe.u.mode = IW_MODE_MASTER;\n\t\telse\n\t\t\tiwe.u.mode = IW_MODE_INFRA;\n\t\tiwe.len = IW_EV_UINT_LEN;\n\t\tcurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\n\t\t\t\t\t\t  &iwe, IW_EV_UINT_LEN);\n\n\t\t \n\t\tmemset(&iwe, 0, sizeof(iwe));\n\t\tiwe.cmd = IWEVQUAL;\n\t\tif (sta->last_rx_silence == 0)\n\t\t\tiwe.u.qual.qual = sta->last_rx_signal < 27 ?\n\t\t\t\t0 : (sta->last_rx_signal - 27) * 92 / 127;\n\t\telse\n\t\t\tiwe.u.qual.qual = sta->last_rx_signal -\n\t\t\t\tsta->last_rx_silence - 35;\n\t\tiwe.u.qual.level = HFA384X_LEVEL_TO_dBm(sta->last_rx_signal);\n\t\tiwe.u.qual.noise = HFA384X_LEVEL_TO_dBm(sta->last_rx_silence);\n\t\tiwe.u.qual.updated = sta->last_rx_updated;\n\t\tiwe.len = IW_EV_QUAL_LEN;\n\t\tcurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\n\t\t\t\t\t\t  &iwe, IW_EV_QUAL_LEN);\n\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\n\t\tif (sta->ap) {\n\t\t\tmemset(&iwe, 0, sizeof(iwe));\n\t\t\tiwe.cmd = SIOCGIWESSID;\n\t\t\tiwe.u.data.length = sta->u.ap.ssid_len;\n\t\t\tiwe.u.data.flags = 1;\n\t\t\tcurrent_ev = iwe_stream_add_point(info, current_ev,\n\t\t\t\t\t\t\t  end_buf, &iwe,\n\t\t\t\t\t\t\t  sta->u.ap.ssid);\n\n\t\t\tmemset(&iwe, 0, sizeof(iwe));\n\t\t\tiwe.cmd = SIOCGIWENCODE;\n\t\t\tif (sta->capability & WLAN_CAPABILITY_PRIVACY)\n\t\t\t\tiwe.u.data.flags =\n\t\t\t\t\tIW_ENCODE_ENABLED | IW_ENCODE_NOKEY;\n\t\t\telse\n\t\t\t\tiwe.u.data.flags = IW_ENCODE_DISABLED;\n\t\t\tcurrent_ev = iwe_stream_add_point(info, current_ev,\n\t\t\t\t\t\t\t  end_buf, &iwe,\n\t\t\t\t\t\t\t  sta->u.ap.ssid);\n\n\t\t\tif (sta->u.ap.channel > 0 &&\n\t\t\t    sta->u.ap.channel <= FREQ_COUNT) {\n\t\t\t\tmemset(&iwe, 0, sizeof(iwe));\n\t\t\t\tiwe.cmd = SIOCGIWFREQ;\n\t\t\t\tiwe.u.freq.m = freq_list[sta->u.ap.channel - 1]\n\t\t\t\t\t* 100000;\n\t\t\t\tiwe.u.freq.e = 1;\n\t\t\t\tcurrent_ev = iwe_stream_add_event(\n\t\t\t\t\tinfo, current_ev, end_buf, &iwe,\n\t\t\t\t\tIW_EV_FREQ_LEN);\n\t\t\t}\n\n\t\t\tmemset(&iwe, 0, sizeof(iwe));\n\t\t\tiwe.cmd = IWEVCUSTOM;\n\t\t\tsprintf(buf, \"beacon_interval=%d\",\n\t\t\t\tsta->listen_interval);\n\t\t\tiwe.u.data.length = strlen(buf);\n\t\t\tcurrent_ev = iwe_stream_add_point(info, current_ev,\n\t\t\t\t\t\t\t  end_buf, &iwe, buf);\n\t\t}\n#endif  \n\n\t\tsta->last_rx_updated = IW_QUAL_DBM;\n\n\t\t \n\t}\n\n\tspin_unlock_bh(&ap->sta_table_lock);\n\n\treturn current_ev - buffer;\n}\n\n\nstatic int prism2_hostapd_add_sta(struct ap_data *ap,\n\t\t\t\t  struct prism2_hostapd_param *param)\n{\n\tstruct sta_info *sta;\n\n\tspin_lock_bh(&ap->sta_table_lock);\n\tsta = ap_get_sta(ap, param->sta_addr);\n\tif (sta)\n\t\tatomic_inc(&sta->users);\n\tspin_unlock_bh(&ap->sta_table_lock);\n\n\tif (sta == NULL) {\n\t\tsta = ap_add_sta(ap, param->sta_addr);\n\t\tif (sta == NULL)\n\t\t\treturn -1;\n\t}\n\n\tif (!(sta->flags & WLAN_STA_ASSOC) && !sta->ap && sta->local)\n\t\thostap_event_new_sta(sta->local->dev, sta);\n\n\tsta->flags |= WLAN_STA_AUTH | WLAN_STA_ASSOC;\n\tsta->last_rx = jiffies;\n\tsta->aid = param->u.add_sta.aid;\n\tsta->capability = param->u.add_sta.capability;\n\tsta->tx_supp_rates = param->u.add_sta.tx_supp_rates;\n\tif (sta->tx_supp_rates & WLAN_RATE_1M)\n\t\tsta->supported_rates[0] = 2;\n\tif (sta->tx_supp_rates & WLAN_RATE_2M)\n\t\tsta->supported_rates[1] = 4;\n\tif (sta->tx_supp_rates & WLAN_RATE_5M5)\n\t\tsta->supported_rates[2] = 11;\n\tif (sta->tx_supp_rates & WLAN_RATE_11M)\n\t\tsta->supported_rates[3] = 22;\n\tprism2_check_tx_rates(sta);\n\tatomic_dec(&sta->users);\n\treturn 0;\n}\n\n\nstatic int prism2_hostapd_remove_sta(struct ap_data *ap,\n\t\t\t\t     struct prism2_hostapd_param *param)\n{\n\tstruct sta_info *sta;\n\n\tspin_lock_bh(&ap->sta_table_lock);\n\tsta = ap_get_sta(ap, param->sta_addr);\n\tif (sta) {\n\t\tap_sta_hash_del(ap, sta);\n\t\tlist_del(&sta->list);\n\t}\n\tspin_unlock_bh(&ap->sta_table_lock);\n\n\tif (!sta)\n\t\treturn -ENOENT;\n\n\tif ((sta->flags & WLAN_STA_ASSOC) && !sta->ap && sta->local)\n\t\thostap_event_expired_sta(sta->local->dev, sta);\n\tap_free_sta(ap, sta);\n\n\treturn 0;\n}\n\n\nstatic int prism2_hostapd_get_info_sta(struct ap_data *ap,\n\t\t\t\t       struct prism2_hostapd_param *param)\n{\n\tstruct sta_info *sta;\n\n\tspin_lock_bh(&ap->sta_table_lock);\n\tsta = ap_get_sta(ap, param->sta_addr);\n\tif (sta)\n\t\tatomic_inc(&sta->users);\n\tspin_unlock_bh(&ap->sta_table_lock);\n\n\tif (!sta)\n\t\treturn -ENOENT;\n\n\tparam->u.get_info_sta.inactive_sec = (jiffies - sta->last_rx) / HZ;\n\n\tatomic_dec(&sta->users);\n\n\treturn 1;\n}\n\n\nstatic int prism2_hostapd_set_flags_sta(struct ap_data *ap,\n\t\t\t\t\tstruct prism2_hostapd_param *param)\n{\n\tstruct sta_info *sta;\n\n\tspin_lock_bh(&ap->sta_table_lock);\n\tsta = ap_get_sta(ap, param->sta_addr);\n\tif (sta) {\n\t\tsta->flags |= param->u.set_flags_sta.flags_or;\n\t\tsta->flags &= param->u.set_flags_sta.flags_and;\n\t}\n\tspin_unlock_bh(&ap->sta_table_lock);\n\n\tif (!sta)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\n\nstatic int prism2_hostapd_sta_clear_stats(struct ap_data *ap,\n\t\t\t\t\t  struct prism2_hostapd_param *param)\n{\n\tstruct sta_info *sta;\n\tint rate;\n\n\tspin_lock_bh(&ap->sta_table_lock);\n\tsta = ap_get_sta(ap, param->sta_addr);\n\tif (sta) {\n\t\tsta->rx_packets = sta->tx_packets = 0;\n\t\tsta->rx_bytes = sta->tx_bytes = 0;\n\t\tfor (rate = 0; rate < WLAN_RATE_COUNT; rate++) {\n\t\t\tsta->tx_count[rate] = 0;\n\t\t\tsta->rx_count[rate] = 0;\n\t\t}\n\t}\n\tspin_unlock_bh(&ap->sta_table_lock);\n\n\tif (!sta)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\n\nint prism2_hostapd(struct ap_data *ap, struct prism2_hostapd_param *param)\n{\n\tswitch (param->cmd) {\n\tcase PRISM2_HOSTAPD_FLUSH:\n\t\tap_control_kickall(ap);\n\t\treturn 0;\n\tcase PRISM2_HOSTAPD_ADD_STA:\n\t\treturn prism2_hostapd_add_sta(ap, param);\n\tcase PRISM2_HOSTAPD_REMOVE_STA:\n\t\treturn prism2_hostapd_remove_sta(ap, param);\n\tcase PRISM2_HOSTAPD_GET_INFO_STA:\n\t\treturn prism2_hostapd_get_info_sta(ap, param);\n\tcase PRISM2_HOSTAPD_SET_FLAGS_STA:\n\t\treturn prism2_hostapd_set_flags_sta(ap, param);\n\tcase PRISM2_HOSTAPD_STA_CLEAR_STATS:\n\t\treturn prism2_hostapd_sta_clear_stats(ap, param);\n\tdefault:\n\t\tprintk(KERN_WARNING \"prism2_hostapd: unknown cmd=%d\\n\",\n\t\t       param->cmd);\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n\n \nstatic int ap_update_sta_tx_rate(struct sta_info *sta, struct net_device *dev)\n{\n\tint ret = sta->tx_rate;\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tsta->tx_count[sta->tx_rate_idx]++;\n\tsta->tx_since_last_failure++;\n\tsta->tx_consecutive_exc = 0;\n\tif (sta->tx_since_last_failure >= WLAN_RATE_UPDATE_COUNT &&\n\t    sta->tx_rate_idx < sta->tx_max_rate) {\n\t\t \n\t\tint old_rate, new_rate;\n\t\told_rate = new_rate = sta->tx_rate_idx;\n\t\twhile (new_rate < sta->tx_max_rate) {\n\t\t\tnew_rate++;\n\t\t\tif (ap_tx_rate_ok(new_rate, sta, local)) {\n\t\t\t\tsta->tx_rate_idx = new_rate;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (old_rate != sta->tx_rate_idx) {\n\t\t\tswitch (sta->tx_rate_idx) {\n\t\t\tcase 0: sta->tx_rate = 10; break;\n\t\t\tcase 1: sta->tx_rate = 20; break;\n\t\t\tcase 2: sta->tx_rate = 55; break;\n\t\t\tcase 3: sta->tx_rate = 110; break;\n\t\t\tdefault: sta->tx_rate = 0; break;\n\t\t\t}\n\t\t\tPDEBUG(DEBUG_AP, \"%s: STA %pM TX rate raised to %d\\n\",\n\t\t\t       dev->name, sta->addr, sta->tx_rate);\n\t\t}\n\t\tsta->tx_since_last_failure = 0;\n\t}\n\n\treturn ret;\n}\n\n\n \nap_tx_ret hostap_handle_sta_tx(local_info_t *local, struct hostap_tx_data *tx)\n{\n\tstruct sta_info *sta = NULL;\n\tstruct sk_buff *skb = tx->skb;\n\tint set_tim, ret;\n\tstruct ieee80211_hdr *hdr;\n\tstruct hostap_skb_tx_data *meta;\n\n\tmeta = (struct hostap_skb_tx_data *) skb->cb;\n\tret = AP_TX_CONTINUE;\n\tif (local->ap == NULL || skb->len < 10 ||\n\t    meta->iface->type == HOSTAP_INTERFACE_STA)\n\t\tgoto out;\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\n\tif (hdr->addr1[0] & 0x01) {\n\t\t \n\t\tif (local->ap->num_sta <= 0)\n\t\t\tret = AP_TX_DROP;\n\t\tgoto out;\n\t}\n\n\t \n\tspin_lock(&local->ap->sta_table_lock);\n\tsta = ap_get_sta(local->ap, hdr->addr1);\n\tif (sta)\n\t\tatomic_inc(&sta->users);\n\tspin_unlock(&local->ap->sta_table_lock);\n\n\tif (local->iw_mode == IW_MODE_MASTER && sta == NULL &&\n\t    !(meta->flags & HOSTAP_TX_FLAGS_WDS) &&\n\t    meta->iface->type != HOSTAP_INTERFACE_MASTER &&\n\t    meta->iface->type != HOSTAP_INTERFACE_AP) {\n#if 0\n\t\t \n\t\tif (net_ratelimit()) {\n\t\t\tprintk(KERN_DEBUG \"AP: drop packet to non-associated \"\n\t\t\t       \"STA %pM\\n\", hdr->addr1);\n\t\t}\n#endif\n\t\tlocal->ap->tx_drop_nonassoc++;\n\t\tret = AP_TX_DROP;\n\t\tgoto out;\n\t}\n\n\tif (sta == NULL)\n\t\tgoto out;\n\n\tif (!(sta->flags & WLAN_STA_AUTHORIZED))\n\t\tret = AP_TX_CONTINUE_NOT_AUTHORIZED;\n\n\t \n\tif (!local->fw_tx_rate_control)\n\t\tlocal->ap->last_tx_rate = meta->rate =\n\t\t\tap_update_sta_tx_rate(sta, local->dev);\n\n\tif (local->iw_mode != IW_MODE_MASTER)\n\t\tgoto out;\n\n\tif (!(sta->flags & WLAN_STA_PS))\n\t\tgoto out;\n\n\tif (meta->flags & HOSTAP_TX_FLAGS_ADD_MOREDATA) {\n\t\t \n\t\thdr->frame_control |=\n\t\t\tcpu_to_le16(IEEE80211_FCTL_MOREDATA);\n\t}\n\n\tif (meta->flags & HOSTAP_TX_FLAGS_BUFFERED_FRAME) {\n\t\t \n\t\tgoto out;\n\t}\n\n\tif (skb_queue_len(&sta->tx_buf) >= STA_MAX_TX_BUFFER) {\n\t\tPDEBUG(DEBUG_PS, \"%s: No more space in STA (%pM)'s\"\n\t\t       \"PS mode buffer\\n\",\n\t\t       local->dev->name, sta->addr);\n\t\t \n\t\t \n\t\thostap_set_tim(local, sta->aid, 1);\n\t\tsta->flags |= WLAN_STA_TIM;\n\t\tret = AP_TX_DROP;\n\t\tgoto out;\n\t}\n\n\t \n\tset_tim = skb_queue_empty(&sta->tx_buf);\n\tskb_queue_tail(&sta->tx_buf, skb);\n\t \n\n\tif (set_tim) {\n\t\tif (sta->flags & WLAN_STA_TIM)\n\t\t\tPDEBUG(DEBUG_PS2, \"Re-setting TIM for aid %d\\n\",\n\t\t\t       sta->aid);\n\t\thostap_set_tim(local, sta->aid, 1);\n\t\tsta->flags |= WLAN_STA_TIM;\n\t}\n\n\tret = AP_TX_BUFFERED;\n\n out:\n\tif (sta != NULL) {\n\t\tif (ret == AP_TX_CONTINUE ||\n\t\t    ret == AP_TX_CONTINUE_NOT_AUTHORIZED) {\n\t\t\tsta->tx_packets++;\n\t\t\tsta->tx_bytes += skb->len;\n\t\t\tsta->last_tx = jiffies;\n\t\t}\n\n\t\tif ((ret == AP_TX_CONTINUE ||\n\t\t     ret == AP_TX_CONTINUE_NOT_AUTHORIZED) &&\n\t\t    sta->crypt && tx->host_encrypt) {\n\t\t\ttx->crypt = sta->crypt;\n\t\t\ttx->sta_ptr = sta;  \n\t\t} else\n\t\t\tatomic_dec(&sta->users);\n\t}\n\n\treturn ret;\n}\n\n\nvoid hostap_handle_sta_release(void *ptr)\n{\n\tstruct sta_info *sta = ptr;\n\tatomic_dec(&sta->users);\n}\n\n\n \nvoid hostap_handle_sta_tx_exc(local_info_t *local, struct sk_buff *skb)\n{\n\tstruct sta_info *sta;\n\tstruct ieee80211_hdr *hdr;\n\tstruct hostap_skb_tx_data *meta;\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\tmeta = (struct hostap_skb_tx_data *) skb->cb;\n\n\tspin_lock(&local->ap->sta_table_lock);\n\tsta = ap_get_sta(local->ap, hdr->addr1);\n\tif (!sta) {\n\t\tspin_unlock(&local->ap->sta_table_lock);\n\t\tPDEBUG(DEBUG_AP, \"%s: Could not find STA %pM\"\n\t\t       \" for this TX error (@%lu)\\n\",\n\t\t       local->dev->name, hdr->addr1, jiffies);\n\t\treturn;\n\t}\n\n\tsta->tx_since_last_failure = 0;\n\tsta->tx_consecutive_exc++;\n\n\tif (sta->tx_consecutive_exc >= WLAN_RATE_DECREASE_THRESHOLD &&\n\t    sta->tx_rate_idx > 0 && meta->rate <= sta->tx_rate) {\n\t\t \n\t\tint old, rate;\n\t\told = rate = sta->tx_rate_idx;\n\t\twhile (rate > 0) {\n\t\t\trate--;\n\t\t\tif (ap_tx_rate_ok(rate, sta, local)) {\n\t\t\t\tsta->tx_rate_idx = rate;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (old != sta->tx_rate_idx) {\n\t\t\tswitch (sta->tx_rate_idx) {\n\t\t\tcase 0: sta->tx_rate = 10; break;\n\t\t\tcase 1: sta->tx_rate = 20; break;\n\t\t\tcase 2: sta->tx_rate = 55; break;\n\t\t\tcase 3: sta->tx_rate = 110; break;\n\t\t\tdefault: sta->tx_rate = 0; break;\n\t\t\t}\n\t\t\tPDEBUG(DEBUG_AP,\n\t\t\t       \"%s: STA %pM TX rate lowered to %d\\n\",\n\t\t\t       local->dev->name, sta->addr, sta->tx_rate);\n\t\t}\n\t\tsta->tx_consecutive_exc = 0;\n\t}\n\tspin_unlock(&local->ap->sta_table_lock);\n}\n\n\nstatic void hostap_update_sta_ps2(local_info_t *local, struct sta_info *sta,\n\t\t\t\t  int pwrmgt, int type, int stype)\n{\n\tif (pwrmgt && !(sta->flags & WLAN_STA_PS)) {\n\t\tsta->flags |= WLAN_STA_PS;\n\t\tPDEBUG(DEBUG_PS2, \"STA %pM changed to use PS \"\n\t\t       \"mode (type=0x%02X, stype=0x%02X)\\n\",\n\t\t       sta->addr, type >> 2, stype >> 4);\n\t} else if (!pwrmgt && (sta->flags & WLAN_STA_PS)) {\n\t\tsta->flags &= ~WLAN_STA_PS;\n\t\tPDEBUG(DEBUG_PS2, \"STA %pM changed to not use \"\n\t\t       \"PS mode (type=0x%02X, stype=0x%02X)\\n\",\n\t\t       sta->addr, type >> 2, stype >> 4);\n\t\tif (type != IEEE80211_FTYPE_CTL ||\n\t\t    stype != IEEE80211_STYPE_PSPOLL)\n\t\t\tschedule_packet_send(local, sta);\n\t}\n}\n\n\n \nint hostap_update_sta_ps(local_info_t *local, struct ieee80211_hdr *hdr)\n{\n\tstruct sta_info *sta;\n\tu16 fc;\n\n\tspin_lock(&local->ap->sta_table_lock);\n\tsta = ap_get_sta(local->ap, hdr->addr2);\n\tif (sta)\n\t\tatomic_inc(&sta->users);\n\tspin_unlock(&local->ap->sta_table_lock);\n\n\tif (!sta)\n\t\treturn -1;\n\n\tfc = le16_to_cpu(hdr->frame_control);\n\thostap_update_sta_ps2(local, sta, fc & IEEE80211_FCTL_PM,\n\t\t\t      fc & IEEE80211_FCTL_FTYPE,\n\t\t\t      fc & IEEE80211_FCTL_STYPE);\n\n\tatomic_dec(&sta->users);\n\treturn 0;\n}\n\n\n \nap_rx_ret hostap_handle_sta_rx(local_info_t *local, struct net_device *dev,\n\t\t\t       struct sk_buff *skb,\n\t\t\t       struct hostap_80211_rx_status *rx_stats,\n\t\t\t       int wds)\n{\n\tint ret;\n\tstruct sta_info *sta;\n\tu16 fc, type, stype;\n\tstruct ieee80211_hdr *hdr;\n\n\tif (local->ap == NULL)\n\t\treturn AP_RX_CONTINUE;\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\n\tfc = le16_to_cpu(hdr->frame_control);\n\ttype = fc & IEEE80211_FCTL_FTYPE;\n\tstype = fc & IEEE80211_FCTL_STYPE;\n\n\tspin_lock(&local->ap->sta_table_lock);\n\tsta = ap_get_sta(local->ap, hdr->addr2);\n\tif (sta)\n\t\tatomic_inc(&sta->users);\n\tspin_unlock(&local->ap->sta_table_lock);\n\n\tif (sta && !(sta->flags & WLAN_STA_AUTHORIZED))\n\t\tret = AP_RX_CONTINUE_NOT_AUTHORIZED;\n\telse\n\t\tret = AP_RX_CONTINUE;\n\n\n\tif (fc & IEEE80211_FCTL_TODS) {\n\t\tif (!wds && (sta == NULL || !(sta->flags & WLAN_STA_ASSOC))) {\n\t\t\tif (local->hostapd) {\n\t\t\t\tprism2_rx_80211(local->apdev, skb, rx_stats,\n\t\t\t\t\t\tPRISM2_RX_NON_ASSOC);\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\n\t\t\t} else {\n\t\t\t\tprintk(KERN_DEBUG \"%s: dropped received packet\"\n\t\t\t\t       \" from non-associated STA %pM\"\n\t\t\t\t       \" (type=0x%02x, subtype=0x%02x)\\n\",\n\t\t\t\t       dev->name, hdr->addr2,\n\t\t\t\t       type >> 2, stype >> 4);\n\t\t\t\thostap_rx(dev, skb, rx_stats);\n#endif  \n\t\t\t}\n\t\t\tret = AP_RX_EXIT;\n\t\t\tgoto out;\n\t\t}\n\t} else if (fc & IEEE80211_FCTL_FROMDS) {\n\t\tif (!wds) {\n\t\t\t \n\t\t\tif (ether_addr_equal(hdr->addr1, dev->dev_addr)) {\n\t\t\t\tprintk(KERN_DEBUG \"Odd.. FromDS packet \"\n\t\t\t\t       \"received with own BSSID\\n\");\n\t\t\t\thostap_dump_rx_80211(dev->name, skb, rx_stats);\n\t\t\t}\n\t\t\tret = AP_RX_DROP;\n\t\t\tgoto out;\n\t\t}\n\t} else if (stype == IEEE80211_STYPE_NULLFUNC && sta == NULL &&\n\t\t   ether_addr_equal(hdr->addr1, dev->dev_addr)) {\n\n\t\tif (local->hostapd) {\n\t\t\tprism2_rx_80211(local->apdev, skb, rx_stats,\n\t\t\t\t\tPRISM2_RX_NON_ASSOC);\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\n\t\t} else {\n\t\t\t \n\t\t\tprintk(KERN_DEBUG \"%s: rejected received nullfunc frame\"\n\t\t\t       \" without ToDS from not associated STA %pM\\n\",\n\t\t\t       dev->name, hdr->addr2);\n\t\t\thostap_rx(dev, skb, rx_stats);\n#endif  \n\t\t}\n\t\tret = AP_RX_EXIT;\n\t\tgoto out;\n\t} else if (stype == IEEE80211_STYPE_NULLFUNC) {\n\t\t \n\t} else {\n\t\t \n\t\tif (ether_addr_equal(hdr->addr3, dev->dev_addr)) {\n\t\t\tprintk(KERN_DEBUG \"%s: dropped received packet from %pM\"\n\t\t\t       \" with no ToDS flag \"\n\t\t\t       \"(type=0x%02x, subtype=0x%02x)\\n\", dev->name,\n\t\t\t       hdr->addr2, type >> 2, stype >> 4);\n\t\t\thostap_dump_rx_80211(dev->name, skb, rx_stats);\n\t\t}\n\t\tret = AP_RX_DROP;\n\t\tgoto out;\n\t}\n\n\tif (sta) {\n\t\thostap_update_sta_ps2(local, sta, fc & IEEE80211_FCTL_PM,\n\t\t\t\t      type, stype);\n\n\t\tsta->rx_packets++;\n\t\tsta->rx_bytes += skb->len;\n\t\tsta->last_rx = jiffies;\n\t}\n\n\tif (local->ap->nullfunc_ack && stype == IEEE80211_STYPE_NULLFUNC &&\n\t    fc & IEEE80211_FCTL_TODS) {\n\t\tif (local->hostapd) {\n\t\t\tprism2_rx_80211(local->apdev, skb, rx_stats,\n\t\t\t\t\tPRISM2_RX_NULLFUNC_ACK);\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\n\t\t} else {\n\t\t\t \n\t\t\thostap_rx(dev, skb, rx_stats);\n#endif  \n\t\t}\n\t\tret = AP_RX_EXIT;\n\t\tgoto out;\n\t}\n\n out:\n\tif (sta)\n\t\tatomic_dec(&sta->users);\n\n\treturn ret;\n}\n\n\n \nint hostap_handle_sta_crypto(local_info_t *local,\n\t\t\t     struct ieee80211_hdr *hdr,\n\t\t\t     struct lib80211_crypt_data **crypt,\n\t\t\t     void **sta_ptr)\n{\n\tstruct sta_info *sta;\n\n\tspin_lock(&local->ap->sta_table_lock);\n\tsta = ap_get_sta(local->ap, hdr->addr2);\n\tif (sta)\n\t\tatomic_inc(&sta->users);\n\tspin_unlock(&local->ap->sta_table_lock);\n\n\tif (!sta)\n\t\treturn -1;\n\n\tif (sta->crypt) {\n\t\t*crypt = sta->crypt;\n\t\t*sta_ptr = sta;\n\t\t \n\t} else\n\t\tatomic_dec(&sta->users);\n\n\treturn 0;\n}\n\n\n \nint hostap_is_sta_assoc(struct ap_data *ap, u8 *sta_addr)\n{\n\tstruct sta_info *sta;\n\tint ret = 0;\n\n\tspin_lock(&ap->sta_table_lock);\n\tsta = ap_get_sta(ap, sta_addr);\n\tif (sta != NULL && (sta->flags & WLAN_STA_ASSOC) && !sta->ap)\n\t\tret = 1;\n\tspin_unlock(&ap->sta_table_lock);\n\n\treturn ret;\n}\n\n\n \nint hostap_is_sta_authorized(struct ap_data *ap, u8 *sta_addr)\n{\n\tstruct sta_info *sta;\n\tint ret = 0;\n\n\tspin_lock(&ap->sta_table_lock);\n\tsta = ap_get_sta(ap, sta_addr);\n\tif (sta != NULL && (sta->flags & WLAN_STA_ASSOC) && !sta->ap &&\n\t    ((sta->flags & WLAN_STA_AUTHORIZED) ||\n\t     ap->local->ieee_802_1x == 0))\n\t\tret = 1;\n\tspin_unlock(&ap->sta_table_lock);\n\n\treturn ret;\n}\n\n\n \nint hostap_add_sta(struct ap_data *ap, u8 *sta_addr)\n{\n\tstruct sta_info *sta;\n\tint ret = 1;\n\n\tif (!ap)\n\t\treturn -1;\n\n\tspin_lock(&ap->sta_table_lock);\n\tsta = ap_get_sta(ap, sta_addr);\n\tif (sta)\n\t\tret = 0;\n\tspin_unlock(&ap->sta_table_lock);\n\n\tif (ret == 1) {\n\t\tsta = ap_add_sta(ap, sta_addr);\n\t\tif (!sta)\n\t\t\treturn -1;\n\t\tsta->flags = WLAN_STA_AUTH | WLAN_STA_ASSOC;\n\t\tsta->ap = 1;\n\t\tmemset(sta->supported_rates, 0, sizeof(sta->supported_rates));\n\t\t \n\t\tsta->supported_rates[0] = 0x82;\n\t\tsta->supported_rates[1] = 0x84;\n\t\tsta->supported_rates[2] = 0x0b;\n\t\tsta->supported_rates[3] = 0x16;\n\t\tsta->tx_supp_rates = WLAN_RATE_1M | WLAN_RATE_2M |\n\t\t\tWLAN_RATE_5M5 | WLAN_RATE_11M;\n\t\tsta->tx_rate = 110;\n\t\tsta->tx_max_rate = sta->tx_rate_idx = 3;\n\t}\n\n\treturn ret;\n}\n\n\n \nint hostap_update_rx_stats(struct ap_data *ap,\n\t\t\t   struct ieee80211_hdr *hdr,\n\t\t\t   struct hostap_80211_rx_status *rx_stats)\n{\n\tstruct sta_info *sta;\n\n\tif (!ap)\n\t\treturn -1;\n\n\tspin_lock(&ap->sta_table_lock);\n\tsta = ap_get_sta(ap, hdr->addr2);\n\tif (sta) {\n\t\tsta->last_rx_silence = rx_stats->noise;\n\t\tsta->last_rx_signal = rx_stats->signal;\n\t\tsta->last_rx_rate = rx_stats->rate;\n\t\tsta->last_rx_updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;\n\t\tif (rx_stats->rate == 10)\n\t\t\tsta->rx_count[0]++;\n\t\telse if (rx_stats->rate == 20)\n\t\t\tsta->rx_count[1]++;\n\t\telse if (rx_stats->rate == 55)\n\t\t\tsta->rx_count[2]++;\n\t\telse if (rx_stats->rate == 110)\n\t\t\tsta->rx_count[3]++;\n\t}\n\tspin_unlock(&ap->sta_table_lock);\n\n\treturn sta ? 0 : -1;\n}\n\n\nvoid hostap_update_rates(local_info_t *local)\n{\n\tstruct sta_info *sta;\n\tstruct ap_data *ap = local->ap;\n\n\tif (!ap)\n\t\treturn;\n\n\tspin_lock_bh(&ap->sta_table_lock);\n\tlist_for_each_entry(sta, &ap->sta_list, list) {\n\t\tprism2_check_tx_rates(sta);\n\t}\n\tspin_unlock_bh(&ap->sta_table_lock);\n}\n\n\nvoid * ap_crypt_get_ptrs(struct ap_data *ap, u8 *addr, int permanent,\n\t\t\t struct lib80211_crypt_data ***crypt)\n{\n\tstruct sta_info *sta;\n\n\tspin_lock_bh(&ap->sta_table_lock);\n\tsta = ap_get_sta(ap, addr);\n\tif (sta)\n\t\tatomic_inc(&sta->users);\n\tspin_unlock_bh(&ap->sta_table_lock);\n\n\tif (!sta && permanent)\n\t\tsta = ap_add_sta(ap, addr);\n\n\tif (!sta)\n\t\treturn NULL;\n\n\tif (permanent)\n\t\tsta->flags |= WLAN_STA_PERM;\n\n\t*crypt = &sta->crypt;\n\n\treturn sta;\n}\n\n\nvoid hostap_add_wds_links(local_info_t *local)\n{\n\tstruct ap_data *ap = local->ap;\n\tstruct sta_info *sta;\n\n\tspin_lock_bh(&ap->sta_table_lock);\n\tlist_for_each_entry(sta, &ap->sta_list, list) {\n\t\tif (sta->ap)\n\t\t\thostap_wds_link_oper(local, sta->addr, WDS_ADD);\n\t}\n\tspin_unlock_bh(&ap->sta_table_lock);\n\n\tschedule_work(&local->ap->wds_oper_queue);\n}\n\n\nvoid hostap_wds_link_oper(local_info_t *local, u8 *addr, wds_oper_type type)\n{\n\tstruct wds_oper_data *entry;\n\n\tentry = kmalloc(sizeof(*entry), GFP_ATOMIC);\n\tif (!entry)\n\t\treturn;\n\tmemcpy(entry->addr, addr, ETH_ALEN);\n\tentry->type = type;\n\tspin_lock_bh(&local->lock);\n\tentry->next = local->ap->wds_oper_entries;\n\tlocal->ap->wds_oper_entries = entry;\n\tspin_unlock_bh(&local->lock);\n\n\tschedule_work(&local->ap->wds_oper_queue);\n}\n\n\nEXPORT_SYMBOL(hostap_init_data);\nEXPORT_SYMBOL(hostap_init_ap_proc);\nEXPORT_SYMBOL(hostap_free_data);\nEXPORT_SYMBOL(hostap_check_sta_fw_version);\nEXPORT_SYMBOL(hostap_handle_sta_tx_exc);\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}