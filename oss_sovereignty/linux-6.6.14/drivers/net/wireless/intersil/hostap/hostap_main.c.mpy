{
  "module_name": "hostap_main.c",
  "hash_id": "5597ca1ed62d30f087d1f00b0287689b01e442db61490cfef30cd8f13b6b8e51",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/hostap/hostap_main.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/proc_fs.h>\n#include <linux/if_arp.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/kmod.h>\n#include <linux/rtnetlink.h>\n#include <linux/wireless.h>\n#include <linux/etherdevice.h>\n#include <net/net_namespace.h>\n#include <net/iw_handler.h>\n#include <net/lib80211.h>\n#include <linux/uaccess.h>\n\n#include \"hostap_wlan.h\"\n#include \"hostap_80211.h\"\n#include \"hostap_ap.h\"\n#include \"hostap.h\"\n\nMODULE_AUTHOR(\"Jouni Malinen\");\nMODULE_DESCRIPTION(\"Host AP common routines\");\nMODULE_LICENSE(\"GPL\");\n\n#define TX_TIMEOUT (2 * HZ)\n\n#define PRISM2_MAX_FRAME_SIZE 2304\n#define PRISM2_MIN_MTU 256\n \n#define PRISM2_MAX_MTU (PRISM2_MAX_FRAME_SIZE - (6   + 8  ))\n\n\nstruct net_device * hostap_add_interface(struct local_info *local,\n\t\t\t\t\t int type, int rtnl_locked,\n\t\t\t\t\t const char *prefix,\n\t\t\t\t\t const char *name)\n{\n\tstruct net_device *dev, *mdev;\n\tstruct hostap_interface *iface;\n\tint ret;\n\n\tdev = alloc_etherdev(sizeof(struct hostap_interface));\n\tif (dev == NULL)\n\t\treturn NULL;\n\n\tiface = netdev_priv(dev);\n\tiface->dev = dev;\n\tiface->local = local;\n\tiface->type = type;\n\tlist_add(&iface->list, &local->hostap_interfaces);\n\n\tmdev = local->dev;\n\teth_hw_addr_inherit(dev, mdev);\n\tdev->base_addr = mdev->base_addr;\n\tdev->irq = mdev->irq;\n\tdev->mem_start = mdev->mem_start;\n\tdev->mem_end = mdev->mem_end;\n\n\thostap_setup_dev(dev, local, type);\n\tdev->needs_free_netdev = true;\n\n\tsprintf(dev->name, \"%s%s\", prefix, name);\n\tif (!rtnl_locked)\n\t\trtnl_lock();\n\n\tSET_NETDEV_DEV(dev, mdev->dev.parent);\n\tret = register_netdevice(dev);\n\n\tif (!rtnl_locked)\n\t\trtnl_unlock();\n\n\tif (ret < 0) {\n\t\tprintk(KERN_WARNING \"%s: failed to add new netdevice!\\n\",\n\t\t       dev->name);\n\t\tfree_netdev(dev);\n\t\treturn NULL;\n\t}\n\n\tprintk(KERN_DEBUG \"%s: registered netdevice %s\\n\",\n\t       mdev->name, dev->name);\n\n\treturn dev;\n}\n\n\nvoid hostap_remove_interface(struct net_device *dev, int rtnl_locked,\n\t\t\t     int remove_from_list)\n{\n\tstruct hostap_interface *iface;\n\n\tif (!dev)\n\t\treturn;\n\n\tiface = netdev_priv(dev);\n\n\tif (remove_from_list) {\n\t\tlist_del(&iface->list);\n\t}\n\n\tif (dev == iface->local->ddev)\n\t\tiface->local->ddev = NULL;\n\telse if (dev == iface->local->apdev)\n\t\tiface->local->apdev = NULL;\n\telse if (dev == iface->local->stadev)\n\t\tiface->local->stadev = NULL;\n\n\tif (rtnl_locked)\n\t\tunregister_netdevice(dev);\n\telse\n\t\tunregister_netdev(dev);\n\n\t \n}\n\n\nstatic inline int prism2_wds_special_addr(u8 *addr)\n{\n\tif (addr[0] || addr[1] || addr[2] || addr[3] || addr[4] || addr[5])\n\t\treturn 0;\n\n\treturn 1;\n}\n\n\nint prism2_wds_add(local_info_t *local, u8 *remote_addr,\n\t\t   int rtnl_locked)\n{\n\tstruct net_device *dev;\n\tstruct list_head *ptr;\n\tstruct hostap_interface *iface, *empty, *match;\n\n\tempty = match = NULL;\n\tread_lock_bh(&local->iface_lock);\n\tlist_for_each(ptr, &local->hostap_interfaces) {\n\t\tiface = list_entry(ptr, struct hostap_interface, list);\n\t\tif (iface->type != HOSTAP_INTERFACE_WDS)\n\t\t\tcontinue;\n\n\t\tif (prism2_wds_special_addr(iface->u.wds.remote_addr))\n\t\t\tempty = iface;\n\t\telse if (ether_addr_equal(iface->u.wds.remote_addr, remote_addr)) {\n\t\t\tmatch = iface;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!match && empty && !prism2_wds_special_addr(remote_addr)) {\n\t\t \n\t\tmemcpy(empty->u.wds.remote_addr, remote_addr, ETH_ALEN);\n\t\tread_unlock_bh(&local->iface_lock);\n\t\tprintk(KERN_DEBUG \"%s: using pre-allocated WDS netdevice %s\\n\",\n\t\t       local->dev->name, empty->dev->name);\n\t\treturn 0;\n\t}\n\tread_unlock_bh(&local->iface_lock);\n\n\tif (!prism2_wds_special_addr(remote_addr)) {\n\t\tif (match)\n\t\t\treturn -EEXIST;\n\t\thostap_add_sta(local->ap, remote_addr);\n\t}\n\n\tif (local->wds_connections >= local->wds_max_connections)\n\t\treturn -ENOBUFS;\n\n\t \n\tif (strlen(local->dev->name) >= IFNAMSIZ - 5) {\n\t\tprintk(KERN_DEBUG \"'%s' too long base device name\\n\",\n\t\t       local->dev->name);\n\t\treturn -EINVAL;\n\t}\n\n\tdev = hostap_add_interface(local, HOSTAP_INTERFACE_WDS, rtnl_locked,\n\t\t\t\t   local->ddev->name, \"wds%d\");\n\tif (dev == NULL)\n\t\treturn -ENOMEM;\n\n\tiface = netdev_priv(dev);\n\tmemcpy(iface->u.wds.remote_addr, remote_addr, ETH_ALEN);\n\n\tlocal->wds_connections++;\n\n\treturn 0;\n}\n\n\nint prism2_wds_del(local_info_t *local, u8 *remote_addr,\n\t\t   int rtnl_locked, int do_not_remove)\n{\n\tunsigned long flags;\n\tstruct list_head *ptr;\n\tstruct hostap_interface *iface, *selected = NULL;\n\n\twrite_lock_irqsave(&local->iface_lock, flags);\n\tlist_for_each(ptr, &local->hostap_interfaces) {\n\t\tiface = list_entry(ptr, struct hostap_interface, list);\n\t\tif (iface->type != HOSTAP_INTERFACE_WDS)\n\t\t\tcontinue;\n\n\t\tif (ether_addr_equal(iface->u.wds.remote_addr, remote_addr)) {\n\t\t\tselected = iface;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (selected && !do_not_remove)\n\t\tlist_del(&selected->list);\n\twrite_unlock_irqrestore(&local->iface_lock, flags);\n\n\tif (selected) {\n\t\tif (do_not_remove)\n\t\t\teth_zero_addr(selected->u.wds.remote_addr);\n\t\telse {\n\t\t\thostap_remove_interface(selected->dev, rtnl_locked, 0);\n\t\t\tlocal->wds_connections--;\n\t\t}\n\t}\n\n\treturn selected ? 0 : -ENODEV;\n}\n\n\nu16 hostap_tx_callback_register(local_info_t *local,\n\t\t\t\tvoid (*func)(struct sk_buff *, int ok, void *),\n\t\t\t\tvoid *data)\n{\n\tunsigned long flags;\n\tstruct hostap_tx_callback_info *entry;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (entry == NULL)\n\t\treturn 0;\n\n\tentry->func = func;\n\tentry->data = data;\n\n\tspin_lock_irqsave(&local->lock, flags);\n\tentry->idx = local->tx_callback ? local->tx_callback->idx + 1 : 1;\n\tentry->next = local->tx_callback;\n\tlocal->tx_callback = entry;\n\tspin_unlock_irqrestore(&local->lock, flags);\n\n\treturn entry->idx;\n}\n\n\nint hostap_tx_callback_unregister(local_info_t *local, u16 idx)\n{\n\tunsigned long flags;\n\tstruct hostap_tx_callback_info *cb, *prev = NULL;\n\n\tspin_lock_irqsave(&local->lock, flags);\n\tcb = local->tx_callback;\n\twhile (cb != NULL && cb->idx != idx) {\n\t\tprev = cb;\n\t\tcb = cb->next;\n\t}\n\tif (cb) {\n\t\tif (prev == NULL)\n\t\t\tlocal->tx_callback = cb->next;\n\t\telse\n\t\t\tprev->next = cb->next;\n\t\tkfree(cb);\n\t}\n\tspin_unlock_irqrestore(&local->lock, flags);\n\n\treturn cb ? 0 : -1;\n}\n\n\n \nint hostap_set_word(struct net_device *dev, int rid, u16 val)\n{\n\tstruct hostap_interface *iface;\n\t__le16 tmp = cpu_to_le16(val);\n\tiface = netdev_priv(dev);\n\treturn iface->local->func->set_rid(dev, rid, &tmp, 2);\n}\n\n\nint hostap_set_string(struct net_device *dev, int rid, const char *val)\n{\n\tstruct hostap_interface *iface;\n\tchar buf[MAX_SSID_LEN + 2];\n\tint len;\n\n\tiface = netdev_priv(dev);\n\tlen = strlen(val);\n\tif (len > MAX_SSID_LEN)\n\t\treturn -1;\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[0] = len;  \n\tmemcpy(buf + 2, val, len);\n\n\treturn iface->local->func->set_rid(dev, rid, &buf, MAX_SSID_LEN + 2);\n}\n\n\nu16 hostap_get_porttype(local_info_t *local)\n{\n\tif (local->iw_mode == IW_MODE_ADHOC && local->pseudo_adhoc)\n\t\treturn HFA384X_PORTTYPE_PSEUDO_IBSS;\n\tif (local->iw_mode == IW_MODE_ADHOC)\n\t\treturn HFA384X_PORTTYPE_IBSS;\n\tif (local->iw_mode == IW_MODE_INFRA)\n\t\treturn HFA384X_PORTTYPE_BSS;\n\tif (local->iw_mode == IW_MODE_REPEAT)\n\t\treturn HFA384X_PORTTYPE_WDS;\n\tif (local->iw_mode == IW_MODE_MONITOR)\n\t\treturn HFA384X_PORTTYPE_PSEUDO_IBSS;\n\treturn HFA384X_PORTTYPE_HOSTAP;\n}\n\n\nint hostap_set_encryption(local_info_t *local)\n{\n\tu16 val, old_val;\n\tint i, keylen, len, idx;\n\tchar keybuf[WEP_KEY_LEN + 1];\n\tenum { NONE, WEP, OTHER } encrypt_type;\n\n\tidx = local->crypt_info.tx_keyidx;\n\tif (local->crypt_info.crypt[idx] == NULL ||\n\t    local->crypt_info.crypt[idx]->ops == NULL)\n\t\tencrypt_type = NONE;\n\telse if (strcmp(local->crypt_info.crypt[idx]->ops->name, \"WEP\") == 0)\n\t\tencrypt_type = WEP;\n\telse\n\t\tencrypt_type = OTHER;\n\n\tif (local->func->get_rid(local->dev, HFA384X_RID_CNFWEPFLAGS, &val, 2,\n\t\t\t\t 1) < 0) {\n\t\tprintk(KERN_DEBUG \"Could not read current WEP flags.\\n\");\n\t\tgoto fail;\n\t}\n\tle16_to_cpus(&val);\n\told_val = val;\n\n\tif (encrypt_type != NONE || local->privacy_invoked)\n\t\tval |= HFA384X_WEPFLAGS_PRIVACYINVOKED;\n\telse\n\t\tval &= ~HFA384X_WEPFLAGS_PRIVACYINVOKED;\n\n\tif (local->open_wep || encrypt_type == NONE ||\n\t    ((local->ieee_802_1x || local->wpa) && local->host_decrypt))\n\t\tval &= ~HFA384X_WEPFLAGS_EXCLUDEUNENCRYPTED;\n\telse\n\t\tval |= HFA384X_WEPFLAGS_EXCLUDEUNENCRYPTED;\n\n\tif ((encrypt_type != NONE || local->privacy_invoked) &&\n\t    (encrypt_type == OTHER || local->host_encrypt))\n\t\tval |= HFA384X_WEPFLAGS_HOSTENCRYPT;\n\telse\n\t\tval &= ~HFA384X_WEPFLAGS_HOSTENCRYPT;\n\tif ((encrypt_type != NONE || local->privacy_invoked) &&\n\t    (encrypt_type == OTHER || local->host_decrypt))\n\t\tval |= HFA384X_WEPFLAGS_HOSTDECRYPT;\n\telse\n\t\tval &= ~HFA384X_WEPFLAGS_HOSTDECRYPT;\n\n\tif (val != old_val &&\n\t    hostap_set_word(local->dev, HFA384X_RID_CNFWEPFLAGS, val)) {\n\t\tprintk(KERN_DEBUG \"Could not write new WEP flags (0x%x)\\n\",\n\t\t       val);\n\t\tgoto fail;\n\t}\n\n\tif (encrypt_type != WEP)\n\t\treturn 0;\n\n\t \n\tkeylen = 6;  \n\tlen = local->crypt_info.crypt[idx]->ops->get_key(keybuf, sizeof(keybuf), NULL,\n\t\t\t\t\t\t\t   local->crypt_info.crypt[idx]->priv);\n\tif (idx >= 0 && idx < WEP_KEYS && len > 5)\n\t\tkeylen = WEP_KEY_LEN + 1;  \n\n\tfor (i = 0; i < WEP_KEYS; i++) {\n\t\tmemset(keybuf, 0, sizeof(keybuf));\n\t\tif (local->crypt_info.crypt[i]) {\n\t\t\t(void) local->crypt_info.crypt[i]->ops->get_key(\n\t\t\t\tkeybuf, sizeof(keybuf),\n\t\t\t\tNULL, local->crypt_info.crypt[i]->priv);\n\t\t}\n\t\tif (local->func->set_rid(local->dev,\n\t\t\t\t\t HFA384X_RID_CNFDEFAULTKEY0 + i,\n\t\t\t\t\t keybuf, keylen)) {\n\t\t\tprintk(KERN_DEBUG \"Could not set key %d (len=%d)\\n\",\n\t\t\t       i, keylen);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (hostap_set_word(local->dev, HFA384X_RID_CNFWEPDEFAULTKEYID, idx)) {\n\t\tprintk(KERN_DEBUG \"Could not set default keyid %d\\n\", idx);\n\t\tgoto fail;\n\t}\n\n\treturn 0;\n\n fail:\n\tprintk(KERN_DEBUG \"%s: encryption setup failed\\n\", local->dev->name);\n\treturn -1;\n}\n\n\nint hostap_set_antsel(local_info_t *local)\n{\n\tu16 val;\n\tint ret = 0;\n\n\tif (local->antsel_tx != HOSTAP_ANTSEL_DO_NOT_TOUCH &&\n\t    local->func->cmd(local->dev, HFA384X_CMDCODE_READMIF,\n\t\t\t     HFA386X_CR_TX_CONFIGURE,\n\t\t\t     NULL, &val) == 0) {\n\t\tval &= ~(BIT(2) | BIT(1));\n\t\tswitch (local->antsel_tx) {\n\t\tcase HOSTAP_ANTSEL_DIVERSITY:\n\t\t\tval |= BIT(1);\n\t\t\tbreak;\n\t\tcase HOSTAP_ANTSEL_LOW:\n\t\t\tbreak;\n\t\tcase HOSTAP_ANTSEL_HIGH:\n\t\t\tval |= BIT(2);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (local->func->cmd(local->dev, HFA384X_CMDCODE_WRITEMIF,\n\t\t\t\t     HFA386X_CR_TX_CONFIGURE, &val, NULL)) {\n\t\t\tprintk(KERN_INFO \"%s: setting TX AntSel failed\\n\",\n\t\t\t       local->dev->name);\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\tif (local->antsel_rx != HOSTAP_ANTSEL_DO_NOT_TOUCH &&\n\t    local->func->cmd(local->dev, HFA384X_CMDCODE_READMIF,\n\t\t\t     HFA386X_CR_RX_CONFIGURE,\n\t\t\t     NULL, &val) == 0) {\n\t\tval &= ~(BIT(1) | BIT(0));\n\t\tswitch (local->antsel_rx) {\n\t\tcase HOSTAP_ANTSEL_DIVERSITY:\n\t\t\tbreak;\n\t\tcase HOSTAP_ANTSEL_LOW:\n\t\t\tval |= BIT(0);\n\t\t\tbreak;\n\t\tcase HOSTAP_ANTSEL_HIGH:\n\t\t\tval |= BIT(0) | BIT(1);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (local->func->cmd(local->dev, HFA384X_CMDCODE_WRITEMIF,\n\t\t\t\t     HFA386X_CR_RX_CONFIGURE, &val, NULL)) {\n\t\t\tprintk(KERN_INFO \"%s: setting RX AntSel failed\\n\",\n\t\t\t       local->dev->name);\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nint hostap_set_roaming(local_info_t *local)\n{\n\tu16 val;\n\n\tswitch (local->host_roaming) {\n\tcase 1:\n\t\tval = HFA384X_ROAMING_HOST;\n\t\tbreak;\n\tcase 2:\n\t\tval = HFA384X_ROAMING_DISABLED;\n\t\tbreak;\n\tcase 0:\n\tdefault:\n\t\tval = HFA384X_ROAMING_FIRMWARE;\n\t\tbreak;\n\t}\n\n\treturn hostap_set_word(local->dev, HFA384X_RID_CNFROAMINGMODE, val);\n}\n\n\nint hostap_set_auth_algs(local_info_t *local)\n{\n\tint val = local->auth_algs;\n\t \n\tif (local->sta_fw_ver < PRISM2_FW_VER(0,7,0) &&\n\t    val != PRISM2_AUTH_OPEN && val != PRISM2_AUTH_SHARED_KEY)\n\t\tval = PRISM2_AUTH_OPEN;\n\n\tif (hostap_set_word(local->dev, HFA384X_RID_CNFAUTHENTICATION, val)) {\n\t\tprintk(KERN_INFO \"%s: cnfAuthentication setting to 0x%x \"\n\t\t       \"failed\\n\", local->dev->name, local->auth_algs);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n\nvoid hostap_dump_rx_header(const char *name, const struct hfa384x_rx_frame *rx)\n{\n\tu16 status, fc;\n\n\tstatus = __le16_to_cpu(rx->status);\n\n\tprintk(KERN_DEBUG \"%s: RX status=0x%04x (port=%d, type=%d, \"\n\t       \"fcserr=%d) silence=%d signal=%d rate=%d rxflow=%d; \"\n\t       \"jiffies=%ld\\n\",\n\t       name, status, (status >> 8) & 0x07, status >> 13, status & 1,\n\t       rx->silence, rx->signal, rx->rate, rx->rxflow, jiffies);\n\n\tfc = __le16_to_cpu(rx->frame_control);\n\tprintk(KERN_DEBUG \"   FC=0x%04x (type=%d:%d) dur=0x%04x seq=0x%04x \"\n\t       \"data_len=%d%s%s\\n\",\n\t       fc, (fc & IEEE80211_FCTL_FTYPE) >> 2,\n\t       (fc & IEEE80211_FCTL_STYPE) >> 4,\n\t       __le16_to_cpu(rx->duration_id), __le16_to_cpu(rx->seq_ctrl),\n\t       __le16_to_cpu(rx->data_len),\n\t       fc & IEEE80211_FCTL_TODS ? \" [ToDS]\" : \"\",\n\t       fc & IEEE80211_FCTL_FROMDS ? \" [FromDS]\" : \"\");\n\n\tprintk(KERN_DEBUG \"   A1=%pM A2=%pM A3=%pM A4=%pM\\n\",\n\t       rx->addr1, rx->addr2, rx->addr3, rx->addr4);\n\n\tprintk(KERN_DEBUG \"   dst=%pM src=%pM len=%d\\n\",\n\t       rx->dst_addr, rx->src_addr,\n\t       __be16_to_cpu(rx->len));\n}\n\n\nvoid hostap_dump_tx_header(const char *name, const struct hfa384x_tx_frame *tx)\n{\n\tu16 fc;\n\n\tprintk(KERN_DEBUG \"%s: TX status=0x%04x retry_count=%d tx_rate=%d \"\n\t       \"tx_control=0x%04x; jiffies=%ld\\n\",\n\t       name, __le16_to_cpu(tx->status), tx->retry_count, tx->tx_rate,\n\t       __le16_to_cpu(tx->tx_control), jiffies);\n\n\tfc = __le16_to_cpu(tx->frame_control);\n\tprintk(KERN_DEBUG \"   FC=0x%04x (type=%d:%d) dur=0x%04x seq=0x%04x \"\n\t       \"data_len=%d%s%s\\n\",\n\t       fc, (fc & IEEE80211_FCTL_FTYPE) >> 2,\n\t       (fc & IEEE80211_FCTL_STYPE) >> 4,\n\t       __le16_to_cpu(tx->duration_id), __le16_to_cpu(tx->seq_ctrl),\n\t       __le16_to_cpu(tx->data_len),\n\t       fc & IEEE80211_FCTL_TODS ? \" [ToDS]\" : \"\",\n\t       fc & IEEE80211_FCTL_FROMDS ? \" [FromDS]\" : \"\");\n\n\tprintk(KERN_DEBUG \"   A1=%pM A2=%pM A3=%pM A4=%pM\\n\",\n\t       tx->addr1, tx->addr2, tx->addr3, tx->addr4);\n\n\tprintk(KERN_DEBUG \"   dst=%pM src=%pM len=%d\\n\",\n\t       tx->dst_addr, tx->src_addr,\n\t       __be16_to_cpu(tx->len));\n}\n\n\nstatic int hostap_80211_header_parse(const struct sk_buff *skb,\n\t\t\t\t     unsigned char *haddr)\n{\n\tmemcpy(haddr, skb_mac_header(skb) + 10, ETH_ALEN);  \n\treturn ETH_ALEN;\n}\n\n\nint hostap_80211_get_hdrlen(__le16 fc)\n{\n\tif (ieee80211_is_data(fc) && ieee80211_has_a4 (fc))\n\t\treturn 30;  \n\telse if (ieee80211_is_cts(fc) || ieee80211_is_ack(fc))\n\t\treturn 10;\n\telse if (ieee80211_is_ctl(fc))\n\t\treturn 16;\n\n\treturn 24;\n}\n\n\nstatic int prism2_close(struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tPDEBUG(DEBUG_FLOW, \"%s: prism2_close\\n\", dev->name);\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (dev == local->ddev) {\n\t\tprism2_sta_deauth(local, WLAN_REASON_DEAUTH_LEAVING);\n\t}\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\n\tif (!local->hostapd && dev == local->dev &&\n\t    (!local->func->card_present || local->func->card_present(local)) &&\n\t    local->hw_ready && local->ap && local->iw_mode == IW_MODE_MASTER)\n\t\thostap_deauth_all_stas(dev, local->ap, 1);\n#endif  \n\n\tif (dev == local->dev) {\n\t\tlocal->func->hw_shutdown(dev, HOSTAP_HW_ENABLE_CMDCOMPL);\n\t}\n\n\tif (netif_running(dev)) {\n\t\tnetif_stop_queue(dev);\n\t\tnetif_device_detach(dev);\n\t}\n\n\tcancel_work_sync(&local->reset_queue);\n\tcancel_work_sync(&local->set_multicast_list_queue);\n\tcancel_work_sync(&local->set_tim_queue);\n#ifndef PRISM2_NO_STATION_MODES\n\tcancel_work_sync(&local->info_queue);\n#endif\n\tcancel_work_sync(&local->comms_qual_update);\n\n\tmodule_put(local->hw_module);\n\n\tlocal->num_dev_open--;\n\n\tif (dev != local->dev && local->dev->flags & IFF_UP &&\n\t    local->master_dev_auto_open && local->num_dev_open == 1) {\n\t\t \n\t\tdev_close(local->dev);\n\t}\n\n\treturn 0;\n}\n\n\nstatic int prism2_open(struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tPDEBUG(DEBUG_FLOW, \"%s: prism2_open\\n\", dev->name);\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (local->no_pri) {\n\t\tprintk(KERN_DEBUG \"%s: could not set interface UP - no PRI \"\n\t\t       \"f/w\\n\", dev->name);\n\t\treturn -ENODEV;\n\t}\n\n\tif ((local->func->card_present && !local->func->card_present(local)) ||\n\t    local->hw_downloading)\n\t\treturn -ENODEV;\n\n\tif (!try_module_get(local->hw_module))\n\t\treturn -ENODEV;\n\tlocal->num_dev_open++;\n\n\tif (!local->dev_enabled && local->func->hw_enable(dev, 1)) {\n\t\tprintk(KERN_WARNING \"%s: could not enable MAC port\\n\",\n\t\t       dev->name);\n\t\tprism2_close(dev);\n\t\treturn -ENODEV;\n\t}\n\tif (!local->dev_enabled)\n\t\tprism2_callback(local, PRISM2_CALLBACK_ENABLE);\n\tlocal->dev_enabled = 1;\n\n\tif (dev != local->dev && !(local->dev->flags & IFF_UP)) {\n\t\t \n\t\tlocal->master_dev_auto_open = 1;\n\t\tdev_open(local->dev, NULL);\n\t}\n\n\tnetif_device_attach(dev);\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\n\nstatic int prism2_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tstruct list_head *ptr;\n\tstruct sockaddr *addr = p;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (local->func->set_rid(dev, HFA384X_RID_CNFOWNMACADDR, addr->sa_data,\n\t\t\t\t ETH_ALEN) < 0 || local->func->reset_port(dev))\n\t\treturn -EINVAL;\n\n\tread_lock_bh(&local->iface_lock);\n\tlist_for_each(ptr, &local->hostap_interfaces) {\n\t\tiface = list_entry(ptr, struct hostap_interface, list);\n\t\teth_hw_addr_set(iface->dev, addr->sa_data);\n\t}\n\teth_hw_addr_set(local->dev, addr->sa_data);\n\tread_unlock_bh(&local->iface_lock);\n\n\treturn 0;\n}\n\n\n \nvoid hostap_set_multicast_list_queue(struct work_struct *work)\n{\n\tlocal_info_t *local =\n\t\tcontainer_of(work, local_info_t, set_multicast_list_queue);\n\tstruct net_device *dev = local->dev;\n\n\tif (hostap_set_word(dev, HFA384X_RID_PROMISCUOUSMODE,\n\t\t\t    local->is_promisc)) {\n\t\tprintk(KERN_INFO \"%s: %sabling promiscuous mode failed\\n\",\n\t\t       dev->name, local->is_promisc ? \"en\" : \"dis\");\n\t}\n}\n\n\nstatic void hostap_set_multicast_list(struct net_device *dev)\n{\n#if 0\n\t \n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\tif ((dev->flags & IFF_ALLMULTI) || (dev->flags & IFF_PROMISC)) {\n\t\tlocal->is_promisc = 1;\n\t} else {\n\t\tlocal->is_promisc = 0;\n\t}\n\n\tschedule_work(&local->set_multicast_list_queue);\n#endif\n}\n\n\nstatic void prism2_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tstruct hfa384x_regs regs;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tprintk(KERN_WARNING \"%s Tx timed out! Resetting card\\n\", dev->name);\n\tnetif_stop_queue(local->dev);\n\n\tlocal->func->read_regs(dev, &regs);\n\tprintk(KERN_DEBUG \"%s: CMD=%04x EVSTAT=%04x \"\n\t       \"OFFSET0=%04x OFFSET1=%04x SWSUPPORT0=%04x\\n\",\n\t       dev->name, regs.cmd, regs.evstat, regs.offset0, regs.offset1,\n\t       regs.swsupport0);\n\n\tlocal->func->schedule_reset(local);\n}\n\nconst struct header_ops hostap_80211_ops = {\n\t.create\t\t= eth_header,\n\t.cache\t\t= eth_header_cache,\n\t.cache_update\t= eth_header_cache_update,\n\t.parse\t\t= hostap_80211_header_parse,\n};\nEXPORT_SYMBOL(hostap_80211_ops);\n\n\nstatic const struct net_device_ops hostap_netdev_ops = {\n\t.ndo_start_xmit\t\t= hostap_data_start_xmit,\n\n\t.ndo_open\t\t= prism2_open,\n\t.ndo_stop\t\t= prism2_close,\n\t.ndo_do_ioctl\t\t= hostap_ioctl,\n\t.ndo_siocdevprivate\t= hostap_siocdevprivate,\n\t.ndo_set_mac_address\t= prism2_set_mac_address,\n\t.ndo_set_rx_mode\t= hostap_set_multicast_list,\n\t.ndo_tx_timeout \t= prism2_tx_timeout,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic const struct net_device_ops hostap_mgmt_netdev_ops = {\n\t.ndo_start_xmit\t\t= hostap_mgmt_start_xmit,\n\n\t.ndo_open\t\t= prism2_open,\n\t.ndo_stop\t\t= prism2_close,\n\t.ndo_do_ioctl\t\t= hostap_ioctl,\n\t.ndo_siocdevprivate\t= hostap_siocdevprivate,\n\t.ndo_set_mac_address\t= prism2_set_mac_address,\n\t.ndo_set_rx_mode\t= hostap_set_multicast_list,\n\t.ndo_tx_timeout \t= prism2_tx_timeout,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic const struct net_device_ops hostap_master_ops = {\n\t.ndo_start_xmit \t= hostap_master_start_xmit,\n\n\t.ndo_open\t\t= prism2_open,\n\t.ndo_stop\t\t= prism2_close,\n\t.ndo_do_ioctl\t\t= hostap_ioctl,\n\t.ndo_siocdevprivate\t= hostap_siocdevprivate,\n\t.ndo_set_mac_address\t= prism2_set_mac_address,\n\t.ndo_set_rx_mode\t= hostap_set_multicast_list,\n\t.ndo_tx_timeout \t= prism2_tx_timeout,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nvoid hostap_setup_dev(struct net_device *dev, local_info_t *local,\n\t\t      int type)\n{\n\tstruct hostap_interface *iface;\n\n\tiface = netdev_priv(dev);\n\tether_setup(dev);\n\tdev->min_mtu = PRISM2_MIN_MTU;\n\tdev->max_mtu = PRISM2_MAX_MTU;\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\n\t \n\tif (iface) {\n\t\t \n\t\tiface->wireless_data.spy_data = &iface->spy_data;\n\t\tdev->wireless_data = &iface->wireless_data;\n\t}\n\tdev->wireless_handlers = &hostap_iw_handler_def;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\n\tswitch(type) {\n\tcase HOSTAP_INTERFACE_AP:\n\t\tdev->priv_flags |= IFF_NO_QUEUE;\t \n\t\tdev->netdev_ops = &hostap_mgmt_netdev_ops;\n\t\tdev->type = ARPHRD_IEEE80211;\n\t\tdev->header_ops = &hostap_80211_ops;\n\t\tbreak;\n\tcase HOSTAP_INTERFACE_MASTER:\n\t\tdev->netdev_ops = &hostap_master_ops;\n\t\tbreak;\n\tdefault:\n\t\tdev->priv_flags |= IFF_NO_QUEUE;\t \n\t\tdev->netdev_ops = &hostap_netdev_ops;\n\t}\n\n\tdev->mtu = local->mtu;\n\n\n\tdev->ethtool_ops = &prism2_ethtool_ops;\n\n}\n\nstatic int hostap_enable_hostapd(local_info_t *local, int rtnl_locked)\n{\n\tstruct net_device *dev = local->dev;\n\n\tif (local->apdev)\n\t\treturn -EEXIST;\n\n\tprintk(KERN_DEBUG \"%s: enabling hostapd mode\\n\", dev->name);\n\n\tlocal->apdev = hostap_add_interface(local, HOSTAP_INTERFACE_AP,\n\t\t\t\t\t    rtnl_locked, local->ddev->name,\n\t\t\t\t\t    \"ap\");\n\tif (local->apdev == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n\nstatic int hostap_disable_hostapd(local_info_t *local, int rtnl_locked)\n{\n\tstruct net_device *dev = local->dev;\n\n\tprintk(KERN_DEBUG \"%s: disabling hostapd mode\\n\", dev->name);\n\n\thostap_remove_interface(local->apdev, rtnl_locked, 1);\n\tlocal->apdev = NULL;\n\n\treturn 0;\n}\n\n\nstatic int hostap_enable_hostapd_sta(local_info_t *local, int rtnl_locked)\n{\n\tstruct net_device *dev = local->dev;\n\n\tif (local->stadev)\n\t\treturn -EEXIST;\n\n\tprintk(KERN_DEBUG \"%s: enabling hostapd STA mode\\n\", dev->name);\n\n\tlocal->stadev = hostap_add_interface(local, HOSTAP_INTERFACE_STA,\n\t\t\t\t\t     rtnl_locked, local->ddev->name,\n\t\t\t\t\t     \"sta\");\n\tif (local->stadev == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n\nstatic int hostap_disable_hostapd_sta(local_info_t *local, int rtnl_locked)\n{\n\tstruct net_device *dev = local->dev;\n\n\tprintk(KERN_DEBUG \"%s: disabling hostapd mode\\n\", dev->name);\n\n\thostap_remove_interface(local->stadev, rtnl_locked, 1);\n\tlocal->stadev = NULL;\n\n\treturn 0;\n}\n\n\nint hostap_set_hostapd(local_info_t *local, int val, int rtnl_locked)\n{\n\tint ret;\n\n\tif (val < 0 || val > 1)\n\t\treturn -EINVAL;\n\n\tif (local->hostapd == val)\n\t\treturn 0;\n\n\tif (val) {\n\t\tret = hostap_enable_hostapd(local, rtnl_locked);\n\t\tif (ret == 0)\n\t\t\tlocal->hostapd = 1;\n\t} else {\n\t\tlocal->hostapd = 0;\n\t\tret = hostap_disable_hostapd(local, rtnl_locked);\n\t\tif (ret != 0)\n\t\t\tlocal->hostapd = 1;\n\t}\n\n\treturn ret;\n}\n\n\nint hostap_set_hostapd_sta(local_info_t *local, int val, int rtnl_locked)\n{\n\tint ret;\n\n\tif (val < 0 || val > 1)\n\t\treturn -EINVAL;\n\n\tif (local->hostapd_sta == val)\n\t\treturn 0;\n\n\tif (val) {\n\t\tret = hostap_enable_hostapd_sta(local, rtnl_locked);\n\t\tif (ret == 0)\n\t\t\tlocal->hostapd_sta = 1;\n\t} else {\n\t\tlocal->hostapd_sta = 0;\n\t\tret = hostap_disable_hostapd_sta(local, rtnl_locked);\n\t\tif (ret != 0)\n\t\t\tlocal->hostapd_sta = 1;\n\t}\n\n\n\treturn ret;\n}\n\n\nint prism2_update_comms_qual(struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint ret = 0;\n\tstruct hfa384x_comms_quality sq;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\tif (!local->sta_fw_ver)\n\t\tret = -1;\n\telse if (local->sta_fw_ver >= PRISM2_FW_VER(1,3,1)) {\n\t\tif (local->func->get_rid(local->dev,\n\t\t\t\t\t HFA384X_RID_DBMCOMMSQUALITY,\n\t\t\t\t\t &sq, sizeof(sq), 1) >= 0) {\n\t\t\tlocal->comms_qual = (s16) le16_to_cpu(sq.comm_qual);\n\t\t\tlocal->avg_signal = (s16) le16_to_cpu(sq.signal_level);\n\t\t\tlocal->avg_noise = (s16) le16_to_cpu(sq.noise_level);\n\t\t\tlocal->last_comms_qual_update = jiffies;\n\t\t} else\n\t\t\tret = -1;\n\t} else {\n\t\tif (local->func->get_rid(local->dev, HFA384X_RID_COMMSQUALITY,\n\t\t\t\t\t &sq, sizeof(sq), 1) >= 0) {\n\t\t\tlocal->comms_qual = le16_to_cpu(sq.comm_qual);\n\t\t\tlocal->avg_signal = HFA384X_LEVEL_TO_dBm(\n\t\t\t\tle16_to_cpu(sq.signal_level));\n\t\t\tlocal->avg_noise = HFA384X_LEVEL_TO_dBm(\n\t\t\t\tle16_to_cpu(sq.noise_level));\n\t\t\tlocal->last_comms_qual_update = jiffies;\n\t\t} else\n\t\t\tret = -1;\n\t}\n\n\treturn ret;\n}\n\n\nint prism2_sta_send_mgmt(local_info_t *local, u8 *dst, u16 stype,\n\t\t\t u8 *body, size_t bodylen)\n{\n\tstruct sk_buff *skb;\n\tstruct hostap_ieee80211_mgmt *mgmt;\n\tstruct hostap_skb_tx_data *meta;\n\tstruct net_device *dev = local->dev;\n\n\tskb = dev_alloc_skb(IEEE80211_MGMT_HDR_LEN + bodylen);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tmgmt = skb_put_zero(skb, IEEE80211_MGMT_HDR_LEN);\n\tmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT | stype);\n\tmemcpy(mgmt->da, dst, ETH_ALEN);\n\tmemcpy(mgmt->sa, dev->dev_addr, ETH_ALEN);\n\tmemcpy(mgmt->bssid, dst, ETH_ALEN);\n\tif (body)\n\t\tskb_put_data(skb, body, bodylen);\n\n\tmeta = (struct hostap_skb_tx_data *) skb->cb;\n\tmemset(meta, 0, sizeof(*meta));\n\tmeta->magic = HOSTAP_SKB_TX_DATA_MAGIC;\n\tmeta->iface = netdev_priv(dev);\n\n\tskb->dev = dev;\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\tdev_queue_xmit(skb);\n\n\treturn 0;\n}\n\n\nint prism2_sta_deauth(local_info_t *local, u16 reason)\n{\n\tunion iwreq_data wrqu;\n\tint ret;\n\t__le16 val = cpu_to_le16(reason);\n\n\tif (local->iw_mode != IW_MODE_INFRA ||\n\t    is_zero_ether_addr(local->bssid) ||\n\t    ether_addr_equal(local->bssid, \"\\x44\\x44\\x44\\x44\\x44\\x44\"))\n\t\treturn 0;\n\n\tret = prism2_sta_send_mgmt(local, local->bssid, IEEE80211_STYPE_DEAUTH,\n\t\t\t\t   (u8 *) &val, 2);\n\teth_zero_addr(wrqu.ap_addr.sa_data);\n\twireless_send_event(local->dev, SIOCGIWAP, &wrqu, NULL);\n\treturn ret;\n}\n\n\nstruct proc_dir_entry *hostap_proc;\n\nstatic int __init hostap_init(void)\n{\n\tif (init_net.proc_net != NULL) {\n\t\thostap_proc = proc_mkdir(\"hostap\", init_net.proc_net);\n\t\tif (!hostap_proc)\n\t\t\tprintk(KERN_WARNING \"Failed to mkdir \"\n\t\t\t       \"/proc/net/hostap\\n\");\n\t} else\n\t\thostap_proc = NULL;\n\n\treturn 0;\n}\n\n\nstatic void __exit hostap_exit(void)\n{\n\tif (hostap_proc != NULL) {\n\t\thostap_proc = NULL;\n\t\tremove_proc_entry(\"hostap\", init_net.proc_net);\n\t}\n}\n\n\nEXPORT_SYMBOL(hostap_set_word);\nEXPORT_SYMBOL(hostap_set_string);\nEXPORT_SYMBOL(hostap_get_porttype);\nEXPORT_SYMBOL(hostap_set_encryption);\nEXPORT_SYMBOL(hostap_set_antsel);\nEXPORT_SYMBOL(hostap_set_roaming);\nEXPORT_SYMBOL(hostap_set_auth_algs);\nEXPORT_SYMBOL(hostap_dump_rx_header);\nEXPORT_SYMBOL(hostap_dump_tx_header);\nEXPORT_SYMBOL(hostap_80211_get_hdrlen);\nEXPORT_SYMBOL(hostap_setup_dev);\nEXPORT_SYMBOL(hostap_set_multicast_list_queue);\nEXPORT_SYMBOL(hostap_set_hostapd);\nEXPORT_SYMBOL(hostap_set_hostapd_sta);\nEXPORT_SYMBOL(hostap_add_interface);\nEXPORT_SYMBOL(hostap_remove_interface);\nEXPORT_SYMBOL(prism2_update_comms_qual);\n\nmodule_init(hostap_init);\nmodule_exit(hostap_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}