{
  "module_name": "hostap_info.c",
  "hash_id": "d29328acc0e02b93572dfd4383e83424135a2926569c6ef2d59302b1dd219206",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intersil/hostap/hostap_info.c",
  "human_readable_source": "\n \n\n#include <linux/if_arp.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/etherdevice.h>\n#include \"hostap_wlan.h\"\n#include \"hostap.h\"\n#include \"hostap_ap.h\"\n\n \nstatic void prism2_info_commtallies16(local_info_t *local, unsigned char *buf,\n\t\t\t\t      int left)\n{\n\tstruct hfa384x_comm_tallies *tallies;\n\n\tif (left < sizeof(struct hfa384x_comm_tallies)) {\n\t\tprintk(KERN_DEBUG \"%s: too short (len=%d) commtallies \"\n\t\t       \"info frame\\n\", local->dev->name, left);\n\t\treturn;\n\t}\n\n\ttallies = (struct hfa384x_comm_tallies *) buf;\n#define ADD_COMM_TALLIES(name) \\\nlocal->comm_tallies.name += le16_to_cpu(tallies->name)\n\tADD_COMM_TALLIES(tx_unicast_frames);\n\tADD_COMM_TALLIES(tx_multicast_frames);\n\tADD_COMM_TALLIES(tx_fragments);\n\tADD_COMM_TALLIES(tx_unicast_octets);\n\tADD_COMM_TALLIES(tx_multicast_octets);\n\tADD_COMM_TALLIES(tx_deferred_transmissions);\n\tADD_COMM_TALLIES(tx_single_retry_frames);\n\tADD_COMM_TALLIES(tx_multiple_retry_frames);\n\tADD_COMM_TALLIES(tx_retry_limit_exceeded);\n\tADD_COMM_TALLIES(tx_discards);\n\tADD_COMM_TALLIES(rx_unicast_frames);\n\tADD_COMM_TALLIES(rx_multicast_frames);\n\tADD_COMM_TALLIES(rx_fragments);\n\tADD_COMM_TALLIES(rx_unicast_octets);\n\tADD_COMM_TALLIES(rx_multicast_octets);\n\tADD_COMM_TALLIES(rx_fcs_errors);\n\tADD_COMM_TALLIES(rx_discards_no_buffer);\n\tADD_COMM_TALLIES(tx_discards_wrong_sa);\n\tADD_COMM_TALLIES(rx_discards_wep_undecryptable);\n\tADD_COMM_TALLIES(rx_message_in_msg_fragments);\n\tADD_COMM_TALLIES(rx_message_in_bad_msg_fragments);\n#undef ADD_COMM_TALLIES\n}\n\n\n \nstatic void prism2_info_commtallies32(local_info_t *local, unsigned char *buf,\n\t\t\t\t      int left)\n{\n\tstruct hfa384x_comm_tallies32 *tallies;\n\n\tif (left < sizeof(struct hfa384x_comm_tallies32)) {\n\t\tprintk(KERN_DEBUG \"%s: too short (len=%d) commtallies32 \"\n\t\t       \"info frame\\n\", local->dev->name, left);\n\t\treturn;\n\t}\n\n\ttallies = (struct hfa384x_comm_tallies32 *) buf;\n#define ADD_COMM_TALLIES(name) \\\nlocal->comm_tallies.name += le32_to_cpu(tallies->name)\n\tADD_COMM_TALLIES(tx_unicast_frames);\n\tADD_COMM_TALLIES(tx_multicast_frames);\n\tADD_COMM_TALLIES(tx_fragments);\n\tADD_COMM_TALLIES(tx_unicast_octets);\n\tADD_COMM_TALLIES(tx_multicast_octets);\n\tADD_COMM_TALLIES(tx_deferred_transmissions);\n\tADD_COMM_TALLIES(tx_single_retry_frames);\n\tADD_COMM_TALLIES(tx_multiple_retry_frames);\n\tADD_COMM_TALLIES(tx_retry_limit_exceeded);\n\tADD_COMM_TALLIES(tx_discards);\n\tADD_COMM_TALLIES(rx_unicast_frames);\n\tADD_COMM_TALLIES(rx_multicast_frames);\n\tADD_COMM_TALLIES(rx_fragments);\n\tADD_COMM_TALLIES(rx_unicast_octets);\n\tADD_COMM_TALLIES(rx_multicast_octets);\n\tADD_COMM_TALLIES(rx_fcs_errors);\n\tADD_COMM_TALLIES(rx_discards_no_buffer);\n\tADD_COMM_TALLIES(tx_discards_wrong_sa);\n\tADD_COMM_TALLIES(rx_discards_wep_undecryptable);\n\tADD_COMM_TALLIES(rx_message_in_msg_fragments);\n\tADD_COMM_TALLIES(rx_message_in_bad_msg_fragments);\n#undef ADD_COMM_TALLIES\n}\n\n\n \nstatic void prism2_info_commtallies(local_info_t *local, unsigned char *buf,\n\t\t\t\t    int left)\n{\n\tif (local->tallies32)\n\t\tprism2_info_commtallies32(local, buf, left);\n\telse\n\t\tprism2_info_commtallies16(local, buf, left);\n}\n\n\n#ifndef PRISM2_NO_STATION_MODES\n#ifndef PRISM2_NO_DEBUG\nstatic const char* hfa384x_linkstatus_str(u16 linkstatus)\n{\n\tswitch (linkstatus) {\n\tcase HFA384X_LINKSTATUS_CONNECTED:\n\t\treturn \"Connected\";\n\tcase HFA384X_LINKSTATUS_DISCONNECTED:\n\t\treturn \"Disconnected\";\n\tcase HFA384X_LINKSTATUS_AP_CHANGE:\n\t\treturn \"Access point change\";\n\tcase HFA384X_LINKSTATUS_AP_OUT_OF_RANGE:\n\t\treturn \"Access point out of range\";\n\tcase HFA384X_LINKSTATUS_AP_IN_RANGE:\n\t\treturn \"Access point in range\";\n\tcase HFA384X_LINKSTATUS_ASSOC_FAILED:\n\t\treturn \"Association failed\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n#endif  \n\n\n \nstatic void prism2_info_linkstatus(local_info_t *local, unsigned char *buf,\n\t\t\t\t    int left)\n{\n\tu16 val;\n\tint non_sta_mode;\n\n\t \n\tlocal->last_join_time = 0;\n\n\tif (left != 2) {\n\t\tprintk(KERN_DEBUG \"%s: invalid linkstatus info frame \"\n\t\t       \"length %d\\n\", local->dev->name, left);\n\t\treturn;\n\t}\n\n\tnon_sta_mode = local->iw_mode == IW_MODE_MASTER ||\n\t\tlocal->iw_mode == IW_MODE_REPEAT ||\n\t\tlocal->iw_mode == IW_MODE_MONITOR;\n\n\tval = buf[0] | (buf[1] << 8);\n\tif (!non_sta_mode || val != HFA384X_LINKSTATUS_DISCONNECTED) {\n\t\tPDEBUG(DEBUG_EXTRA, \"%s: LinkStatus=%d (%s)\\n\",\n\t\t       local->dev->name, val, hfa384x_linkstatus_str(val));\n\t}\n\n\tif (non_sta_mode) {\n\t\tnetif_carrier_on(local->dev);\n\t\tnetif_carrier_on(local->ddev);\n\t\treturn;\n\t}\n\n\t \n\tset_bit(PRISM2_INFO_PENDING_LINKSTATUS, &local->pending_info);\n\tlocal->prev_link_status = val;\n\tschedule_work(&local->info_queue);\n}\n\n\nstatic void prism2_host_roaming(local_info_t *local)\n{\n\tstruct hfa384x_join_request req;\n\tstruct net_device *dev = local->dev;\n\tstruct hfa384x_hostscan_result *selected, *entry;\n\tint i;\n\tunsigned long flags;\n\n\tif (local->last_join_time &&\n\t    time_before(jiffies, local->last_join_time + 10 * HZ)) {\n\t\tPDEBUG(DEBUG_EXTRA, \"%s: last join request has not yet been \"\n\t\t       \"completed - waiting for it before issuing new one\\n\",\n\t\t       dev->name);\n\t\treturn;\n\t}\n\n\t \n\tspin_lock_irqsave(&local->lock, flags);\n\tif (local->last_scan_results == NULL ||\n\t    local->last_scan_results_count == 0) {\n\t\tspin_unlock_irqrestore(&local->lock, flags);\n\t\tPDEBUG(DEBUG_EXTRA, \"%s: no scan results for host roaming\\n\",\n\t\t       dev->name);\n\t\treturn;\n\t}\n\n\tselected = &local->last_scan_results[0];\n\n\tif (local->preferred_ap[0] || local->preferred_ap[1] ||\n\t    local->preferred_ap[2] || local->preferred_ap[3] ||\n\t    local->preferred_ap[4] || local->preferred_ap[5]) {\n\t\t \n\t\tPDEBUG(DEBUG_EXTRA, \"%s: Preferred AP BSSID %pM\\n\",\n\t\t       dev->name, local->preferred_ap);\n\t\tfor (i = 0; i < local->last_scan_results_count; i++) {\n\t\t\tentry = &local->last_scan_results[i];\n\t\t\tif (memcmp(local->preferred_ap, entry->bssid, 6) == 0)\n\t\t\t{\n\t\t\t\tPDEBUG(DEBUG_EXTRA, \"%s: using preferred AP \"\n\t\t\t\t       \"selection\\n\", dev->name);\n\t\t\t\tselected = entry;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tmemcpy(req.bssid, selected->bssid, ETH_ALEN);\n\treq.channel = selected->chid;\n\tspin_unlock_irqrestore(&local->lock, flags);\n\n\tPDEBUG(DEBUG_EXTRA, \"%s: JoinRequest: BSSID=%pM\"\n\t       \" channel=%d\\n\",\n\t       dev->name, req.bssid, le16_to_cpu(req.channel));\n\tif (local->func->set_rid(dev, HFA384X_RID_JOINREQUEST, &req,\n\t\t\t\t sizeof(req))) {\n\t\tprintk(KERN_DEBUG \"%s: JoinRequest failed\\n\", dev->name);\n\t}\n\tlocal->last_join_time = jiffies;\n}\n\n\nstatic void hostap_report_scan_complete(local_info_t *local)\n{\n\tunion iwreq_data wrqu;\n\n\t \n\twrqu.data.length = 0;\n\twrqu.data.flags = 0;\n\twireless_send_event(local->dev, SIOCGIWSCAN, &wrqu, NULL);\n\n\t \n\tlocal->scan_timestamp = 0;\n}\n\n\n \nstatic void prism2_info_scanresults(local_info_t *local, unsigned char *buf,\n\t\t\t\t    int left)\n{\n\tu16 *pos;\n\tint new_count, i;\n\tunsigned long flags;\n\tstruct hfa384x_scan_result *res;\n\tstruct hfa384x_hostscan_result *results, *prev;\n\n\tif (left < 4) {\n\t\tprintk(KERN_DEBUG \"%s: invalid scanresult info frame \"\n\t\t       \"length %d\\n\", local->dev->name, left);\n\t\treturn;\n\t}\n\n\tpos = (u16 *) buf;\n\tpos++;\n\tpos++;\n\tleft -= 4;\n\n\tnew_count = left / sizeof(struct hfa384x_scan_result);\n\tresults = kmalloc_array(new_count,\n\t\t\t\tsizeof(struct hfa384x_hostscan_result),\n\t\t\t\tGFP_ATOMIC);\n\tif (results == NULL)\n\t\treturn;\n\n\t \n\tres = (struct hfa384x_scan_result *) pos;\n\tfor (i = 0; i < new_count; i++) {\n\t\tmemcpy(&results[i], &res[i],\n\t\t       sizeof(struct hfa384x_scan_result));\n\t\tresults[i].atim = 0;\n\t}\n\n\tspin_lock_irqsave(&local->lock, flags);\n\tlocal->last_scan_type = PRISM2_SCAN;\n\tprev = local->last_scan_results;\n\tlocal->last_scan_results = results;\n\tlocal->last_scan_results_count = new_count;\n\tspin_unlock_irqrestore(&local->lock, flags);\n\tkfree(prev);\n\n\thostap_report_scan_complete(local);\n\n\t \n\tset_bit(PRISM2_INFO_PENDING_SCANRESULTS, &local->pending_info);\n\tschedule_work(&local->info_queue);\n}\n\n\n \nstatic void prism2_info_hostscanresults(local_info_t *local,\n\t\t\t\t\tunsigned char *buf, int left)\n{\n\tint i, result_size, copy_len, new_count;\n\tstruct hfa384x_hostscan_result *results, *prev;\n\tunsigned long flags;\n\t__le16 *pos;\n\tu8 *ptr;\n\n\twake_up_interruptible(&local->hostscan_wq);\n\n\tif (left < 4) {\n\t\tprintk(KERN_DEBUG \"%s: invalid hostscanresult info frame \"\n\t\t       \"length %d\\n\", local->dev->name, left);\n\t\treturn;\n\t}\n\n\tpos = (__le16 *) buf;\n\tcopy_len = result_size = le16_to_cpu(*pos);\n\tif (result_size == 0) {\n\t\tprintk(KERN_DEBUG \"%s: invalid result_size (0) in \"\n\t\t       \"hostscanresults\\n\", local->dev->name);\n\t\treturn;\n\t}\n\tif (copy_len > sizeof(struct hfa384x_hostscan_result))\n\t\tcopy_len = sizeof(struct hfa384x_hostscan_result);\n\n\tpos++;\n\tpos++;\n\tleft -= 4;\n\tptr = (u8 *) pos;\n\n\tnew_count = left / result_size;\n\tresults = kcalloc(new_count, sizeof(struct hfa384x_hostscan_result),\n\t\t\t  GFP_ATOMIC);\n\tif (results == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < new_count; i++) {\n\t\tmemcpy(&results[i], ptr, copy_len);\n\t\tptr += result_size;\n\t\tleft -= result_size;\n\t}\n\n\tif (left) {\n\t\tprintk(KERN_DEBUG \"%s: short HostScan result entry (%d/%d)\\n\",\n\t\t       local->dev->name, left, result_size);\n\t}\n\n\tspin_lock_irqsave(&local->lock, flags);\n\tlocal->last_scan_type = PRISM2_HOSTSCAN;\n\tprev = local->last_scan_results;\n\tlocal->last_scan_results = results;\n\tlocal->last_scan_results_count = new_count;\n\tspin_unlock_irqrestore(&local->lock, flags);\n\tkfree(prev);\n\n\thostap_report_scan_complete(local);\n}\n#endif  \n\n\n \nvoid hostap_info_process(local_info_t *local, struct sk_buff *skb)\n{\n\tstruct hfa384x_info_frame *info;\n\tunsigned char *buf;\n\tint left;\n#ifndef PRISM2_NO_DEBUG\n\tint i;\n#endif  \n\n\tinfo = (struct hfa384x_info_frame *) skb->data;\n\tbuf = skb->data + sizeof(*info);\n\tleft = skb->len - sizeof(*info);\n\n\tswitch (le16_to_cpu(info->type)) {\n\tcase HFA384X_INFO_COMMTALLIES:\n\t\tprism2_info_commtallies(local, buf, left);\n\t\tbreak;\n\n#ifndef PRISM2_NO_STATION_MODES\n\tcase HFA384X_INFO_LINKSTATUS:\n\t\tprism2_info_linkstatus(local, buf, left);\n\t\tbreak;\n\n\tcase HFA384X_INFO_SCANRESULTS:\n\t\tprism2_info_scanresults(local, buf, left);\n\t\tbreak;\n\n\tcase HFA384X_INFO_HOSTSCANRESULTS:\n\t\tprism2_info_hostscanresults(local, buf, left);\n\t\tbreak;\n#endif  \n\n#ifndef PRISM2_NO_DEBUG\n\tdefault:\n\t\tPDEBUG(DEBUG_EXTRA, \"%s: INFO - len=%d type=0x%04x\\n\",\n\t\t       local->dev->name, le16_to_cpu(info->len),\n\t\t       le16_to_cpu(info->type));\n\t\tPDEBUG(DEBUG_EXTRA, \"Unknown info frame:\");\n\t\tfor (i = 0; i < (left < 100 ? left : 100); i++)\n\t\t\tPDEBUG2(DEBUG_EXTRA, \" %02x\", buf[i]);\n\t\tPDEBUG2(DEBUG_EXTRA, \"\\n\");\n\t\tbreak;\n#endif  \n\t}\n}\n\n\n#ifndef PRISM2_NO_STATION_MODES\nstatic void handle_info_queue_linkstatus(local_info_t *local)\n{\n\tint val = local->prev_link_status;\n\tint connected;\n\tunion iwreq_data wrqu;\n\n\tconnected =\n\t\tval == HFA384X_LINKSTATUS_CONNECTED ||\n\t\tval == HFA384X_LINKSTATUS_AP_CHANGE ||\n\t\tval == HFA384X_LINKSTATUS_AP_IN_RANGE;\n\n\tif (local->func->get_rid(local->dev, HFA384X_RID_CURRENTBSSID,\n\t\t\t\t local->bssid, ETH_ALEN, 1) < 0) {\n\t\tprintk(KERN_DEBUG \"%s: could not read CURRENTBSSID after \"\n\t\t       \"LinkStatus event\\n\", local->dev->name);\n\t} else {\n\t\tPDEBUG(DEBUG_EXTRA, \"%s: LinkStatus: BSSID=%pM\\n\",\n\t\t       local->dev->name,\n\t\t       (unsigned char *) local->bssid);\n\t\tif (local->wds_type & HOSTAP_WDS_AP_CLIENT)\n\t\t\thostap_add_sta(local->ap, local->bssid);\n\t}\n\n\t \n\tif (connected) {\n\t\tnetif_carrier_on(local->dev);\n\t\tnetif_carrier_on(local->ddev);\n\t\tmemcpy(wrqu.ap_addr.sa_data, local->bssid, ETH_ALEN);\n\t} else {\n\t\tnetif_carrier_off(local->dev);\n\t\tnetif_carrier_off(local->ddev);\n\t\teth_zero_addr(wrqu.ap_addr.sa_data);\n\t}\n\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\n\t \n\tif (connected || local->prev_linkstatus_connected)\n\t\twireless_send_event(local->dev, SIOCGIWAP, &wrqu, NULL);\n\tlocal->prev_linkstatus_connected = connected;\n}\n\n\nstatic void handle_info_queue_scanresults(local_info_t *local)\n{\n\tif (local->host_roaming == 1 && local->iw_mode == IW_MODE_INFRA)\n\t\tprism2_host_roaming(local);\n\n\tif (local->host_roaming == 2 && local->iw_mode == IW_MODE_INFRA &&\n\t    !is_zero_ether_addr(local->preferred_ap)) {\n\t\t \n\t\tprism2_host_roaming(local);\n\t}\n}\n\n\n \nstatic void handle_info_queue(struct work_struct *work)\n{\n\tlocal_info_t *local = container_of(work, local_info_t, info_queue);\n\n\tif (test_and_clear_bit(PRISM2_INFO_PENDING_LINKSTATUS,\n\t\t\t       &local->pending_info))\n\t\thandle_info_queue_linkstatus(local);\n\n\tif (test_and_clear_bit(PRISM2_INFO_PENDING_SCANRESULTS,\n\t\t\t       &local->pending_info))\n\t\thandle_info_queue_scanresults(local);\n}\n#endif  \n\n\nvoid hostap_info_init(local_info_t *local)\n{\n\tskb_queue_head_init(&local->info_list);\n#ifndef PRISM2_NO_STATION_MODES\n\tINIT_WORK(&local->info_queue, handle_info_queue);\n#endif  \n}\n\n\nEXPORT_SYMBOL(hostap_info_init);\nEXPORT_SYMBOL(hostap_info_process);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}