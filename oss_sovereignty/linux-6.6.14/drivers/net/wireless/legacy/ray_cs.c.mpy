{
  "module_name": "ray_cs.c",
  "hash_id": "9ead3a58ba426a5a9c4fb92e41736a85c51a2487b02b971f292bbd07867615ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/legacy/ray_cs.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/proc_fs.h>\n#include <linux/ptrace.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/if_arp.h>\n#include <linux/ioport.h>\n#include <linux/skbuff.h>\n#include <linux/ieee80211.h>\n\n#include <pcmcia/cistpl.h>\n#include <pcmcia/cisreg.h>\n#include <pcmcia/ds.h>\n\n#include <linux/wireless.h>\n#include <net/iw_handler.h>\n\n#include <asm/io.h>\n#include <asm/byteorder.h>\n#include <linux/uaccess.h>\n\n \n#define WIRELESS_SPY\t\t \n \ntypedef struct iw_statistics iw_stats;\ntypedef u_char mac_addr[ETH_ALEN];\t \n\n#include \"rayctl.h\"\n#include \"ray_cs.h\"\n\n\n \nstatic int ray_config(struct pcmcia_device *link);\nstatic void ray_release(struct pcmcia_device *link);\nstatic void ray_detach(struct pcmcia_device *p_dev);\n\n \nstatic int ray_dev_close(struct net_device *dev);\nstatic int ray_dev_config(struct net_device *dev, struct ifmap *map);\nstatic struct net_device_stats *ray_get_stats(struct net_device *dev);\nstatic int ray_dev_init(struct net_device *dev);\n\nstatic int ray_open(struct net_device *dev);\nstatic netdev_tx_t ray_dev_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *dev);\nstatic void set_multicast_list(struct net_device *dev);\nstatic void ray_update_multi_list(struct net_device *dev, int all);\nstatic int translate_frame(ray_dev_t *local, struct tx_msg __iomem *ptx,\n\t\t\t   unsigned char *data, int len);\nstatic void ray_build_header(ray_dev_t *local, struct tx_msg __iomem *ptx,\n\t\t\t     UCHAR msg_type, unsigned char *data);\nstatic void untranslate(ray_dev_t *local, struct sk_buff *skb, int len);\nstatic iw_stats *ray_get_wireless_stats(struct net_device *dev);\nstatic const struct iw_handler_def ray_handler_def;\n\n \nstatic void authenticate(ray_dev_t *local);\nstatic int build_auth_frame(ray_dev_t *local, UCHAR *dest, int auth_type);\nstatic void authenticate_timeout(struct timer_list *t);\nstatic int get_free_ccs(ray_dev_t *local);\nstatic int get_free_tx_ccs(ray_dev_t *local);\nstatic void init_startup_params(ray_dev_t *local);\nstatic int parse_addr(char *in_str, UCHAR *out);\nstatic int ray_hw_xmit(unsigned char *data, int len, struct net_device *dev, UCHAR type);\nstatic int ray_init(struct net_device *dev);\nstatic int interrupt_ecf(ray_dev_t *local, int ccs);\nstatic void ray_reset(struct net_device *dev);\nstatic void ray_update_parm(struct net_device *dev, UCHAR objid, UCHAR *value, int len);\nstatic void verify_dl_startup(struct timer_list *t);\n\n \nstatic irqreturn_t ray_interrupt(int reg, void *dev_id);\nstatic void clear_interrupt(ray_dev_t *local);\nstatic void rx_deauthenticate(ray_dev_t *local, struct rcs __iomem *prcs,\n\t\t\t      unsigned int pkt_addr, int rx_len);\nstatic int copy_from_rx_buff(ray_dev_t *local, UCHAR *dest, int pkt_addr, int len);\nstatic void ray_rx(struct net_device *dev, ray_dev_t *local, struct rcs __iomem *prcs);\nstatic void release_frag_chain(ray_dev_t *local, struct rcs __iomem *prcs);\nstatic void rx_authenticate(ray_dev_t *local, struct rcs __iomem *prcs,\n\t\t\t    unsigned int pkt_addr, int rx_len);\nstatic void rx_data(struct net_device *dev, struct rcs __iomem *prcs,\n\t\t    unsigned int pkt_addr, int rx_len);\nstatic void associate(ray_dev_t *local);\n\n \nstatic int dl_startup_params(struct net_device *dev);\nstatic void join_net(struct timer_list *t);\nstatic void start_net(struct timer_list *t);\n\n \n \n\n \nstatic int net_type = ADHOC;\n\n \nstatic int hop_dwell = 128;\n\n \nstatic int beacon_period = 256;\n\n \nstatic int psm;\n\n \nstatic char *essid;\n\n \nstatic bool translate = true;\n\nstatic int country = USA;\n\nstatic int sniffer;\n\nstatic int bc;\n\n \nstatic char *phy_addr = NULL;\n\nstatic unsigned int ray_mem_speed = 500;\n\n \nstatic struct pcmcia_device *this_device = NULL;\n\nMODULE_AUTHOR(\"Corey Thomas <corey@world.std.com>\");\nMODULE_DESCRIPTION(\"Raylink/WebGear wireless LAN driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(net_type, int, 0);\nmodule_param(hop_dwell, int, 0);\nmodule_param(beacon_period, int, 0);\nmodule_param(psm, int, 0);\nmodule_param(essid, charp, 0);\nmodule_param(translate, bool, 0);\nmodule_param(country, int, 0);\nmodule_param(sniffer, int, 0);\nmodule_param(bc, int, 0);\nmodule_param(phy_addr, charp, 0);\nmodule_param(ray_mem_speed, int, 0);\n\nstatic const UCHAR b5_default_startup_parms[] = {\n\t0, 0,\t\t\t \n\t'L', 'I', 'N', 'U', 'X', 0, 0, 0,\t \n\t0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0,\n\t1, 0,\t\t\t \n\t0, 0, 0, 0, 0, 0,\t \n\t0x7f, 0xff,\t\t \n\t0x00, 0x80,\t\t \n\t0x01, 0x00,\t\t \n\t0x01, 0x07, 0xa3,\t \n\t0x1d, 0x82, 0x4e,\t \n\t0x7f, 0xff,\t\t \n\t0x04, 0xe2, 0x38, 0xA4,\t \n\t0x05,\t\t\t \n\t0x08, 0x02, 0x08,\t \n\t0,\t\t\t \n\t0x0c, 0x0bd,\t\t \n\t0x32,\t\t\t \n\t0xff, 0xff,\t\t \n\t0x05, 0xff,\t\t \n\t0x01, 0x0b, 0x4f,\t \n \n\t0x00, 0x3f,\t\t \n\t0x00, 0x0f,\t\t \n\t0x04, 0x08,\t\t \n\t0x28, 0x28,\t\t \n\t7,\t\t\t \n\t0, 2, 2,\t\t \n\t0,\t\t\t \n\t0, 0,\t\t\t \n\t2, 0, 0, 0, 0, 0, 0, 0\t \n};\n\nstatic const UCHAR b4_default_startup_parms[] = {\n\t0, 0,\t\t\t \n\t'L', 'I', 'N', 'U', 'X', 0, 0, 0,\t \n\t0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0,\n\t1, 0,\t\t\t \n\t0, 0, 0, 0, 0, 0,\t \n\t0x7f, 0xff,\t\t \n\t0x02, 0x00,\t\t \n\t0x00, 0x01,\t\t \n\t0x01, 0x07, 0xa3,\t \n\t0x1d, 0x82, 0xce,\t \n\t0x7f, 0xff,\t\t \n\t0xfb, 0x1e, 0xc7, 0x5c,\t \n\t0x05,\t\t\t \n\t0x04, 0x02, 0x4,\t \n\t0,\t\t\t \n\t0x0c, 0x0bd,\t\t \n\t0x4e,\t\t\t \n\t0xff, 0xff,\t\t \n\t0x05, 0xff,\t\t \n\t0x01, 0x0b, 0x4e,\t \n \n\t0x3f, 0x0f,\t\t \n\t0x04, 0x08,\t\t \n\t0x28, 0x28,\t\t \n\t7,\t\t\t \n\t0, 2, 2,\t\t \n\t0,\t\t\t \n\t0, 0, 0, 0, 0, 0,\t \n\t0\t\t\t \n};\n\n \nstatic const u8 eth2_llc[] = { 0xaa, 0xaa, 3, 0, 0, 0 };\n\nstatic const char hop_pattern_length[] = { 1,\n\tUSA_HOP_MOD, EUROPE_HOP_MOD,\n\tJAPAN_HOP_MOD, KOREA_HOP_MOD,\n\tSPAIN_HOP_MOD, FRANCE_HOP_MOD,\n\tISRAEL_HOP_MOD, AUSTRALIA_HOP_MOD,\n\tJAPAN_TEST_HOP_MOD\n};\n\nstatic const char rcsid[] =\n    \"Raylink/WebGear wireless LAN - Corey <Thomas corey@world.std.com>\";\n\nstatic const struct net_device_ops ray_netdev_ops = {\n\t.ndo_init \t\t= ray_dev_init,\n\t.ndo_open \t\t= ray_open,\n\t.ndo_stop \t\t= ray_dev_close,\n\t.ndo_start_xmit\t\t= ray_dev_start_xmit,\n\t.ndo_set_config\t\t= ray_dev_config,\n\t.ndo_get_stats\t\t= ray_get_stats,\n\t.ndo_set_rx_mode\t= set_multicast_list,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int ray_probe(struct pcmcia_device *p_dev)\n{\n\tray_dev_t *local;\n\tstruct net_device *dev;\n\tint ret;\n\n\tdev_dbg(&p_dev->dev, \"ray_attach()\\n\");\n\n\t \n\tdev = alloc_etherdev(sizeof(ray_dev_t));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tlocal = netdev_priv(dev);\n\tlocal->finder = p_dev;\n\n\t \n\tp_dev->resource[0]->end = 0;\n\tp_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;\n\n\t \n\tp_dev->config_flags |= CONF_ENABLE_IRQ;\n\tp_dev->config_index = 1;\n\n\tp_dev->priv = dev;\n\n\tlocal->finder = p_dev;\n\tlocal->card_status = CARD_INSERTED;\n\tlocal->authentication_state = UNAUTHENTICATED;\n\tlocal->num_multi = 0;\n\tdev_dbg(&p_dev->dev, \"ray_attach p_dev = %p,  dev = %p,  local = %p, intr = %p\\n\",\n\t      p_dev, dev, local, &ray_interrupt);\n\n\t \n\tdev->netdev_ops = &ray_netdev_ops;\n\tdev->wireless_handlers = &ray_handler_def;\n#ifdef WIRELESS_SPY\n\tlocal->wireless_data.spy_data = &local->spy_data;\n\tdev->wireless_data = &local->wireless_data;\n#endif  \n\n\n\tdev_dbg(&p_dev->dev, \"ray_cs ray_attach calling ether_setup.)\\n\");\n\tnetif_stop_queue(dev);\n\n\ttimer_setup(&local->timer, NULL, 0);\n\n\tthis_device = p_dev;\n\tret = ray_config(p_dev);\n\tif (ret)\n\t\tgoto err_free_dev;\n\n\treturn 0;\n\nerr_free_dev:\n\tfree_netdev(dev);\n\treturn ret;\n}\n\nstatic void ray_detach(struct pcmcia_device *link)\n{\n\tstruct net_device *dev;\n\n\tdev_dbg(&link->dev, \"ray_detach\\n\");\n\n\tthis_device = NULL;\n\tdev = link->priv;\n\n\tray_release(link);\n\n\tif (link->priv) {\n\t\tunregister_netdev(dev);\n\t\tfree_netdev(dev);\n\t}\n\tdev_dbg(&link->dev, \"ray_cs ray_detach ending\\n\");\n}  \n\n#define MAX_TUPLE_SIZE 128\nstatic int ray_config(struct pcmcia_device *link)\n{\n\tint ret = 0;\n\tint i;\n\tstruct net_device *dev = (struct net_device *)link->priv;\n\tray_dev_t *local = netdev_priv(dev);\n\n\tdev_dbg(&link->dev, \"ray_config\\n\");\n\n\t \n\tprintk(KERN_INFO \"ray_cs Detected: %s%s%s%s\\n\",\n\t       link->prod_id[0] ? link->prod_id[0] : \" \",\n\t       link->prod_id[1] ? link->prod_id[1] : \" \",\n\t       link->prod_id[2] ? link->prod_id[2] : \" \",\n\t       link->prod_id[3] ? link->prod_id[3] : \" \");\n\n\t \n\tret = pcmcia_request_irq(link, ray_interrupt);\n\tif (ret)\n\t\tgoto failed;\n\tdev->irq = link->irq;\n\n\tret = pcmcia_enable_device(link);\n\tif (ret)\n\t\tgoto failed;\n\n \n\tlink->resource[2]->flags |= WIN_DATA_WIDTH_8 | WIN_MEMORY_TYPE_CM | WIN_ENABLE | WIN_USE_WAIT;\n\tlink->resource[2]->start = 0;\n\tlink->resource[2]->end = 0x8000;\n\tret = pcmcia_request_window(link, link->resource[2], ray_mem_speed);\n\tif (ret)\n\t\tgoto failed;\n\tret = pcmcia_map_mem_page(link, link->resource[2], 0);\n\tif (ret)\n\t\tgoto failed;\n\tlocal->sram = ioremap(link->resource[2]->start,\n\t\t\tresource_size(link->resource[2]));\n\tif (!local->sram)\n\t\tgoto failed;\n\n \n\tlink->resource[3]->flags |=\n\t    WIN_DATA_WIDTH_8 | WIN_MEMORY_TYPE_CM | WIN_ENABLE | WIN_USE_WAIT;\n\tlink->resource[3]->start = 0;\n\tlink->resource[3]->end = 0x4000;\n\tret = pcmcia_request_window(link, link->resource[3], ray_mem_speed);\n\tif (ret)\n\t\tgoto failed;\n\tret = pcmcia_map_mem_page(link, link->resource[3], 0x8000);\n\tif (ret)\n\t\tgoto failed;\n\tlocal->rmem = ioremap(link->resource[3]->start,\n\t\t\tresource_size(link->resource[3]));\n\tif (!local->rmem)\n\t\tgoto failed;\n\n \n\tlink->resource[4]->flags |=\n\t    WIN_DATA_WIDTH_8 | WIN_MEMORY_TYPE_AM | WIN_ENABLE | WIN_USE_WAIT;\n\tlink->resource[4]->start = 0;\n\tlink->resource[4]->end = 0x1000;\n\tret = pcmcia_request_window(link, link->resource[4], ray_mem_speed);\n\tif (ret)\n\t\tgoto failed;\n\tret = pcmcia_map_mem_page(link, link->resource[4], 0);\n\tif (ret)\n\t\tgoto failed;\n\tlocal->amem = ioremap(link->resource[4]->start,\n\t\t\tresource_size(link->resource[4]));\n\tif (!local->amem)\n\t\tgoto failed;\n\n\tdev_dbg(&link->dev, \"ray_config sram=%p\\n\", local->sram);\n\tdev_dbg(&link->dev, \"ray_config rmem=%p\\n\", local->rmem);\n\tdev_dbg(&link->dev, \"ray_config amem=%p\\n\", local->amem);\n\tif (ray_init(dev) < 0) {\n\t\tray_release(link);\n\t\treturn -ENODEV;\n\t}\n\n\tSET_NETDEV_DEV(dev, &link->dev);\n\ti = register_netdev(dev);\n\tif (i != 0) {\n\t\tprintk(\"ray_config register_netdev() failed\\n\");\n\t\tray_release(link);\n\t\treturn i;\n\t}\n\n\tprintk(KERN_INFO \"%s: RayLink, irq %d, hw_addr %pM\\n\",\n\t       dev->name, dev->irq, dev->dev_addr);\n\n\treturn 0;\n\nfailed:\n\tray_release(link);\n\treturn -ENODEV;\n}  \n\nstatic inline struct ccs __iomem *ccs_base(ray_dev_t *dev)\n{\n\treturn dev->sram + CCS_BASE;\n}\n\nstatic inline struct rcs __iomem *rcs_base(ray_dev_t *dev)\n{\n\t \n\treturn dev->sram + CCS_BASE;\n}\n\n \nstatic int ray_init(struct net_device *dev)\n{\n\tint i;\n\tstruct ccs __iomem *pccs;\n\tray_dev_t *local = netdev_priv(dev);\n\tstruct pcmcia_device *link = local->finder;\n\tdev_dbg(&link->dev, \"ray_init(0x%p)\\n\", dev);\n\tif (!(pcmcia_dev_present(link))) {\n\t\tdev_dbg(&link->dev, \"ray_init - device not present\\n\");\n\t\treturn -1;\n\t}\n\n\tlocal->net_type = net_type;\n\tlocal->sta_type = TYPE_STA;\n\n\t \n\tmemcpy_fromio(&local->startup_res, local->sram + ECF_TO_HOST_BASE,\n\t\t      sizeof(struct startup_res_6));\n\n\t \n\tif (local->startup_res.startup_word != 0x80) {\n\t\tprintk(KERN_INFO \"ray_init ERROR card status = %2x\\n\",\n\t\t       local->startup_res.startup_word);\n\t\tlocal->card_status = CARD_INIT_ERROR;\n\t\treturn -1;\n\t}\n\n\tlocal->fw_ver = local->startup_res.firmware_version[0];\n\tlocal->fw_bld = local->startup_res.firmware_version[1];\n\tlocal->fw_var = local->startup_res.firmware_version[2];\n\tdev_dbg(&link->dev, \"ray_init firmware version %d.%d\\n\", local->fw_ver,\n\t      local->fw_bld);\n\n\tlocal->tib_length = 0x20;\n\tif ((local->fw_ver == 5) && (local->fw_bld >= 30))\n\t\tlocal->tib_length = local->startup_res.tib_length;\n\tdev_dbg(&link->dev, \"ray_init tib_length = 0x%02x\\n\", local->tib_length);\n\t \n\tpccs = ccs_base(local);\n\tfor (i = 0; i < NUMBER_OF_CCS; i++) {\n\t\twriteb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);\n\t}\n\tinit_startup_params(local);\n\n\t \n\tif (!parse_addr(phy_addr, local->sparm.b4.a_mac_addr)) {\n\t\tmemcpy(&local->sparm.b4.a_mac_addr,\n\t\t       &local->startup_res.station_addr, ADDRLEN);\n\t}\n\n\tclear_interrupt(local);\t \n\tlocal->card_status = CARD_AWAITING_PARAM;\n\tdev_dbg(&link->dev, \"ray_init ending\\n\");\n\treturn 0;\n}  \n\n \n \nstatic int dl_startup_params(struct net_device *dev)\n{\n\tint ccsindex;\n\tray_dev_t *local = netdev_priv(dev);\n\tstruct ccs __iomem *pccs;\n\tstruct pcmcia_device *link = local->finder;\n\n\tdev_dbg(&link->dev, \"dl_startup_params entered\\n\");\n\tif (!(pcmcia_dev_present(link))) {\n\t\tdev_dbg(&link->dev, \"ray_cs dl_startup_params - device not present\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tif (local->fw_ver == 0x55)\n\t\tmemcpy_toio(local->sram + HOST_TO_ECF_BASE, &local->sparm.b4,\n\t\t\t    sizeof(struct b4_startup_params));\n\telse\n\t\tmemcpy_toio(local->sram + HOST_TO_ECF_BASE, &local->sparm.b5,\n\t\t\t    sizeof(struct b5_startup_params));\n\n\t \n\tif ((ccsindex = get_free_ccs(local)) < 0)\n\t\treturn -1;\n\tlocal->dl_param_ccs = ccsindex;\n\tpccs = ccs_base(local) + ccsindex;\n\twriteb(CCS_DOWNLOAD_STARTUP_PARAMS, &pccs->cmd);\n\tdev_dbg(&link->dev, \"dl_startup_params start ccsindex = %d\\n\",\n\t      local->dl_param_ccs);\n\t \n\tif (interrupt_ecf(local, ccsindex)) {\n\t\tprintk(KERN_INFO \"ray dl_startup_params failed - \"\n\t\t       \"ECF not ready for intr\\n\");\n\t\tlocal->card_status = CARD_DL_PARAM_ERROR;\n\t\twriteb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);\n\t\treturn -2;\n\t}\n\tlocal->card_status = CARD_DL_PARAM;\n\t \n\tlocal->timer.expires = jiffies + HZ / 2;\n\tlocal->timer.function = verify_dl_startup;\n\tadd_timer(&local->timer);\n\tdev_dbg(&link->dev,\n\t      \"ray_cs dl_startup_params started timer for verify_dl_startup\\n\");\n\treturn 0;\n}  \n\n \nstatic void init_startup_params(ray_dev_t *local)\n{\n\tint i;\n\n\tif (country > JAPAN_TEST)\n\t\tcountry = USA;\n\telse if (country < USA)\n\t\tcountry = USA;\n\t  \n\tif (local->fw_ver == 0x55) {\n\t\tmemcpy(&local->sparm.b4, b4_default_startup_parms,\n\t\t       sizeof(struct b4_startup_params));\n\t\t \n\t\t \n\t\ti = (hop_dwell * 1024) & 0xffffff;\n\t\tlocal->sparm.b4.a_hop_time[0] = (i >> 16) & 0xff;\n\t\tlocal->sparm.b4.a_hop_time[1] = (i >> 8) & 0xff;\n\t\tlocal->sparm.b4.a_beacon_period[0] = 0;\n\t\tlocal->sparm.b4.a_beacon_period[1] =\n\t\t    ((beacon_period / hop_dwell) - 1) & 0xff;\n\t\tlocal->sparm.b4.a_curr_country_code = country;\n\t\tlocal->sparm.b4.a_hop_pattern_length =\n\t\t    hop_pattern_length[(int)country] - 1;\n\t\tif (bc) {\n\t\t\tlocal->sparm.b4.a_ack_timeout = 0x50;\n\t\t\tlocal->sparm.b4.a_sifs = 0x3f;\n\t\t}\n\t} else {  \n\t\tmemcpy((UCHAR *) &local->sparm.b5, b5_default_startup_parms,\n\t\t       sizeof(struct b5_startup_params));\n\n\t\tlocal->sparm.b5.a_hop_time[0] = (hop_dwell >> 8) & 0xff;\n\t\tlocal->sparm.b5.a_hop_time[1] = hop_dwell & 0xff;\n\t\tlocal->sparm.b5.a_beacon_period[0] =\n\t\t    (beacon_period >> 8) & 0xff;\n\t\tlocal->sparm.b5.a_beacon_period[1] = beacon_period & 0xff;\n\t\tif (psm)\n\t\t\tlocal->sparm.b5.a_power_mgt_state = 1;\n\t\tlocal->sparm.b5.a_curr_country_code = country;\n\t\tlocal->sparm.b5.a_hop_pattern_length =\n\t\t    hop_pattern_length[(int)country];\n\t}\n\n\tlocal->sparm.b4.a_network_type = net_type & 0x01;\n\tlocal->sparm.b4.a_acting_as_ap_status = TYPE_STA;\n\n\tif (essid != NULL)\n\t\tstrscpy(local->sparm.b4.a_current_ess_id, essid, ESSID_SIZE);\n}  \n\n \nstatic void verify_dl_startup(struct timer_list *t)\n{\n\tray_dev_t *local = from_timer(local, t, timer);\n\tstruct ccs __iomem *pccs = ccs_base(local) + local->dl_param_ccs;\n\tUCHAR status;\n\tstruct pcmcia_device *link = local->finder;\n\n\tif (!(pcmcia_dev_present(link))) {\n\t\tdev_dbg(&link->dev, \"ray_cs verify_dl_startup - device not present\\n\");\n\t\treturn;\n\t}\n#if 0\n\t{\n\t\tint i;\n\t\tprintk(KERN_DEBUG\n\t\t       \"verify_dl_startup parameters sent via ccs %d:\\n\",\n\t\t       local->dl_param_ccs);\n\t\tfor (i = 0; i < sizeof(struct b5_startup_params); i++) {\n\t\t\tprintk(\" %2x\",\n\t\t\t       (unsigned int)readb(local->sram +\n\t\t\t\t\t\t   HOST_TO_ECF_BASE + i));\n\t\t}\n\t\tprintk(\"\\n\");\n\t}\n#endif\n\n\tstatus = readb(&pccs->buffer_status);\n\tif (status != CCS_BUFFER_FREE) {\n\t\tprintk(KERN_INFO\n\t\t       \"Download startup params failed.  Status = %d\\n\",\n\t\t       status);\n\t\tlocal->card_status = CARD_DL_PARAM_ERROR;\n\t\treturn;\n\t}\n\tif (local->sparm.b4.a_network_type == ADHOC)\n\t\tstart_net(&local->timer);\n\telse\n\t\tjoin_net(&local->timer);\n}  \n\n \n \nstatic void start_net(struct timer_list *t)\n{\n\tray_dev_t *local = from_timer(local, t, timer);\n\tstruct ccs __iomem *pccs;\n\tint ccsindex;\n\tstruct pcmcia_device *link = local->finder;\n\tif (!(pcmcia_dev_present(link))) {\n\t\tdev_dbg(&link->dev, \"ray_cs start_net - device not present\\n\");\n\t\treturn;\n\t}\n\t \n\tif ((ccsindex = get_free_ccs(local)) < 0)\n\t\treturn;\n\tpccs = ccs_base(local) + ccsindex;\n\twriteb(CCS_START_NETWORK, &pccs->cmd);\n\twriteb(0, &pccs->var.start_network.update_param);\n\t \n\tif (interrupt_ecf(local, ccsindex)) {\n\t\tdev_dbg(&link->dev, \"ray start net failed - card not ready for intr\\n\");\n\t\twriteb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);\n\t\treturn;\n\t}\n\tlocal->card_status = CARD_DOING_ACQ;\n}  \n\n \n \nstatic void join_net(struct timer_list *t)\n{\n\tray_dev_t *local = from_timer(local, t, timer);\n\n\tstruct ccs __iomem *pccs;\n\tint ccsindex;\n\tstruct pcmcia_device *link = local->finder;\n\n\tif (!(pcmcia_dev_present(link))) {\n\t\tdev_dbg(&link->dev, \"ray_cs join_net - device not present\\n\");\n\t\treturn;\n\t}\n\t \n\tif ((ccsindex = get_free_ccs(local)) < 0)\n\t\treturn;\n\tpccs = ccs_base(local) + ccsindex;\n\twriteb(CCS_JOIN_NETWORK, &pccs->cmd);\n\twriteb(0, &pccs->var.join_network.update_param);\n\twriteb(0, &pccs->var.join_network.net_initiated);\n\t \n\tif (interrupt_ecf(local, ccsindex)) {\n\t\tdev_dbg(&link->dev, \"ray join net failed - card not ready for intr\\n\");\n\t\twriteb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);\n\t\treturn;\n\t}\n\tlocal->card_status = CARD_DOING_ACQ;\n}\n\n\nstatic void ray_release(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\tray_dev_t *local = netdev_priv(dev);\n\n\tdev_dbg(&link->dev, \"ray_release\\n\");\n\n\tdel_timer_sync(&local->timer);\n\n\tif (local->sram)\n\t\tiounmap(local->sram);\n\tif (local->rmem)\n\t\tiounmap(local->rmem);\n\tif (local->amem)\n\t\tiounmap(local->amem);\n\tpcmcia_disable_device(link);\n\n\tdev_dbg(&link->dev, \"ray_release ending\\n\");\n}\n\nstatic int ray_suspend(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\n\tif (link->open)\n\t\tnetif_device_detach(dev);\n\n\treturn 0;\n}\n\nstatic int ray_resume(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\n\tif (link->open) {\n\t\tray_reset(dev);\n\t\tnetif_device_attach(dev);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ray_dev_init(struct net_device *dev)\n{\n#ifdef RAY_IMMEDIATE_INIT\n\tint i;\n#endif  \n\tray_dev_t *local = netdev_priv(dev);\n\tstruct pcmcia_device *link = local->finder;\n\n\tdev_dbg(&link->dev, \"ray_dev_init(dev=%p)\\n\", dev);\n\tif (!(pcmcia_dev_present(link))) {\n\t\tdev_dbg(&link->dev, \"ray_dev_init - device not present\\n\");\n\t\treturn -1;\n\t}\n#ifdef RAY_IMMEDIATE_INIT\n\t \n\tif ((i = dl_startup_params(dev)) < 0) {\n\t\tprintk(KERN_INFO \"ray_dev_init dl_startup_params failed - \"\n\t\t       \"returns 0x%x\\n\", i);\n\t\treturn -1;\n\t}\n#else  \n\t \n\tdev_dbg(&link->dev,\n\t      \"ray_dev_init: postponing card init to ray_open() ; Status = %d\\n\",\n\t      local->card_status);\n#endif  \n\n\t \n\teth_hw_addr_set(dev, local->sparm.b4.a_mac_addr);\n\teth_broadcast_addr(dev->broadcast);\n\n\tdev_dbg(&link->dev, \"ray_dev_init ending\\n\");\n\treturn 0;\n}\n\n \nstatic int ray_dev_config(struct net_device *dev, struct ifmap *map)\n{\n\tray_dev_t *local = netdev_priv(dev);\n\tstruct pcmcia_device *link = local->finder;\n\t \n\tdev_dbg(&link->dev, \"ray_dev_config(dev=%p,ifmap=%p)\\n\", dev, map);\n\tif (!(pcmcia_dev_present(link))) {\n\t\tdev_dbg(&link->dev, \"ray_dev_config - device not present\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic netdev_tx_t ray_dev_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *dev)\n{\n\tray_dev_t *local = netdev_priv(dev);\n\tstruct pcmcia_device *link = local->finder;\n\tshort length = skb->len;\n\n\tif (!pcmcia_dev_present(link)) {\n\t\tdev_dbg(&link->dev, \"ray_dev_start_xmit - device not present\\n\");\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tdev_dbg(&link->dev, \"ray_dev_start_xmit(skb=%p, dev=%p)\\n\", skb, dev);\n\tif (local->authentication_state == NEED_TO_AUTH) {\n\t\tdev_dbg(&link->dev, \"ray_cs Sending authentication request.\\n\");\n\t\tif (!build_auth_frame(local, local->auth_id, OPEN_AUTH_REQUEST)) {\n\t\t\tlocal->authentication_state = AUTHENTICATED;\n\t\t\tnetif_stop_queue(dev);\n\t\t\treturn NETDEV_TX_BUSY;\n\t\t}\n\t}\n\n\tif (length < ETH_ZLEN) {\n\t\tif (skb_padto(skb, ETH_ZLEN))\n\t\t\treturn NETDEV_TX_OK;\n\t\tlength = ETH_ZLEN;\n\t}\n\tswitch (ray_hw_xmit(skb->data, length, dev, DATA_TYPE)) {\n\tcase XMIT_NO_CCS:\n\tcase XMIT_NEED_AUTH:\n\t\tnetif_stop_queue(dev);\n\t\treturn NETDEV_TX_BUSY;\n\tcase XMIT_NO_INTR:\n\tcase XMIT_MSG_BAD:\n\tcase XMIT_OK:\n\tdefault:\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn NETDEV_TX_OK;\n}  \n\n \nstatic int ray_hw_xmit(unsigned char *data, int len, struct net_device *dev,\n\t\t       UCHAR msg_type)\n{\n\tray_dev_t *local = netdev_priv(dev);\n\tstruct ccs __iomem *pccs;\n\tint ccsindex;\n\tint offset;\n\tstruct tx_msg __iomem *ptx;\t \n\tshort int addr;\t\t \n\n\tpr_debug(\"ray_hw_xmit(data=%p, len=%d, dev=%p)\\n\", data, len, dev);\n\tif (len + TX_HEADER_LENGTH > TX_BUF_SIZE) {\n\t\tprintk(KERN_INFO \"ray_hw_xmit packet too large: %d bytes\\n\",\n\t\t       len);\n\t\treturn XMIT_MSG_BAD;\n\t}\n\tswitch (ccsindex = get_free_tx_ccs(local)) {\n\tcase ECCSBUSY:\n\t\tpr_debug(\"ray_hw_xmit tx_ccs table busy\\n\");\n\t\tfallthrough;\n\tcase ECCSFULL:\n\t\tpr_debug(\"ray_hw_xmit No free tx ccs\\n\");\n\t\tfallthrough;\n\tcase ECARDGONE:\n\t\tnetif_stop_queue(dev);\n\t\treturn XMIT_NO_CCS;\n\tdefault:\n\t\tbreak;\n\t}\n\taddr = TX_BUF_BASE + (ccsindex << 11);\n\n\tif (msg_type == DATA_TYPE) {\n\t\tlocal->stats.tx_bytes += len;\n\t\tlocal->stats.tx_packets++;\n\t}\n\n\tptx = local->sram + addr;\n\n\tray_build_header(local, ptx, msg_type, data);\n\tif (translate) {\n\t\toffset = translate_frame(local, ptx, data, len);\n\t} else {  \n\t\t \n\t\tmemcpy_toio(&ptx->var, data, len);\n\t\toffset = 0;\n\t}\n\n\t \n\tpccs = ccs_base(local) + ccsindex;\n\tlen += TX_HEADER_LENGTH + offset;\n\twriteb(CCS_TX_REQUEST, &pccs->cmd);\n\twriteb(addr >> 8, &pccs->var.tx_request.tx_data_ptr[0]);\n\twriteb(local->tib_length, &pccs->var.tx_request.tx_data_ptr[1]);\n\twriteb(len >> 8, &pccs->var.tx_request.tx_data_length[0]);\n\twriteb(len & 0xff, &pccs->var.tx_request.tx_data_length[1]);\n \n\twriteb(PSM_CAM, &pccs->var.tx_request.pow_sav_mode);\n\twriteb(local->net_default_tx_rate, &pccs->var.tx_request.tx_rate);\n\twriteb(0, &pccs->var.tx_request.antenna);\n\tpr_debug(\"ray_hw_xmit default_tx_rate = 0x%x\\n\",\n\t      local->net_default_tx_rate);\n\n\t \n\tif (interrupt_ecf(local, ccsindex)) {\n\t\tpr_debug(\"ray_hw_xmit failed - ECF not ready for intr\\n\");\n \n\t\twriteb(CCS_BUFFER_FREE, &pccs->buffer_status);\n\t\treturn XMIT_NO_INTR;\n\t}\n\treturn XMIT_OK;\n}  \n\n \nstatic int translate_frame(ray_dev_t *local, struct tx_msg __iomem *ptx,\n\t\t\t   unsigned char *data, int len)\n{\n\t__be16 proto = ((struct ethhdr *)data)->h_proto;\n\tif (ntohs(proto) >= ETH_P_802_3_MIN) {  \n\t\tpr_debug(\"ray_cs translate_frame DIX II\\n\");\n\t\t \n\t\tmemcpy_toio(&ptx->var, eth2_llc, sizeof(eth2_llc));\n\t\tmemcpy_toio(((void __iomem *)&ptx->var) + sizeof(eth2_llc),\n\t\t\t    (UCHAR *) &proto, 2);\n\t\tif (proto == htons(ETH_P_AARP) || proto == htons(ETH_P_IPX)) {\n\t\t\t \n\t\t\twriteb(0xf8,\n\t\t\t       &((struct snaphdr_t __iomem *)ptx->var)->org[2]);\n\t\t}\n\t\t \n\t\tmemcpy_toio((void __iomem *)&ptx->var +\n\t\t\t    sizeof(struct snaphdr_t), data + ETH_HLEN,\n\t\t\t    len - ETH_HLEN);\n\t\treturn (int)sizeof(struct snaphdr_t) - ETH_HLEN;\n\t} else {  \n\t\tpr_debug(\"ray_cs translate_frame 802\\n\");\n\t\tif (proto == htons(0xffff)) {  \n\t\t\tpr_debug(\"ray_cs translate_frame evil IPX\\n\");\n\t\t\tmemcpy_toio(&ptx->var, data + ETH_HLEN, len - ETH_HLEN);\n\t\t\treturn 0 - ETH_HLEN;\n\t\t}\n\t\tmemcpy_toio(&ptx->var, data + ETH_HLEN, len - ETH_HLEN);\n\t\treturn 0 - ETH_HLEN;\n\t}\n\t \n}  \n\n \nstatic void ray_build_header(ray_dev_t *local, struct tx_msg __iomem *ptx,\n\t\t\t     UCHAR msg_type, unsigned char *data)\n{\n\twriteb(PROTOCOL_VER | msg_type, &ptx->mac.frame_ctl_1);\n \n\tif (local->net_type == ADHOC) {\n\t\twriteb(0, &ptx->mac.frame_ctl_2);\n\t\tmemcpy_toio(ptx->mac.addr_1, ((struct ethhdr *)data)->h_dest,\n\t\t\t    ADDRLEN);\n\t\tmemcpy_toio(ptx->mac.addr_2, ((struct ethhdr *)data)->h_source,\n\t\t\t    ADDRLEN);\n\t\tmemcpy_toio(ptx->mac.addr_3, local->bss_id, ADDRLEN);\n\t} else {  \n\n\t\tif (local->sparm.b4.a_acting_as_ap_status) {\n\t\t\twriteb(FC2_FROM_DS, &ptx->mac.frame_ctl_2);\n\t\t\tmemcpy_toio(ptx->mac.addr_1,\n\t\t\t\t    ((struct ethhdr *)data)->h_dest, ADDRLEN);\n\t\t\tmemcpy_toio(ptx->mac.addr_2, local->bss_id, 6);\n\t\t\tmemcpy_toio(ptx->mac.addr_3,\n\t\t\t\t    ((struct ethhdr *)data)->h_source, ADDRLEN);\n\t\t} else {  \n\n\t\t\twriteb(FC2_TO_DS, &ptx->mac.frame_ctl_2);\n\t\t\tmemcpy_toio(ptx->mac.addr_1, local->bss_id, ADDRLEN);\n\t\t\tmemcpy_toio(ptx->mac.addr_2,\n\t\t\t\t    ((struct ethhdr *)data)->h_source, ADDRLEN);\n\t\t\tmemcpy_toio(ptx->mac.addr_3,\n\t\t\t\t    ((struct ethhdr *)data)->h_dest, ADDRLEN);\n\t\t}\n\t}\n}  \n\n \n\n \n \nstatic int ray_get_name(struct net_device *dev, struct iw_request_info *info,\n\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstrcpy(wrqu->name, \"IEEE 802.11-FH\");\n\treturn 0;\n}\n\n \n \nstatic int ray_set_freq(struct net_device *dev, struct iw_request_info *info,\n\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tray_dev_t *local = netdev_priv(dev);\n\tint err = -EINPROGRESS;\t \n\n\t \n\tif (local->card_status != CARD_AWAITING_PARAM)\n\t\treturn -EBUSY;\n\n\t \n\tif ((wrqu->freq.m > USA_HOP_MOD) || (wrqu->freq.e > 0))\n\t\terr = -EOPNOTSUPP;\n\telse\n\t\tlocal->sparm.b5.a_hop_pattern = wrqu->freq.m;\n\n\treturn err;\n}\n\n \n \nstatic int ray_get_freq(struct net_device *dev, struct iw_request_info *info,\n\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tray_dev_t *local = netdev_priv(dev);\n\n\twrqu->freq.m = local->sparm.b5.a_hop_pattern;\n\twrqu->freq.e = 0;\n\treturn 0;\n}\n\n \n \nstatic int ray_set_essid(struct net_device *dev, struct iw_request_info *info,\n\t\t\t union iwreq_data *wrqu, char *extra)\n{\n\tray_dev_t *local = netdev_priv(dev);\n\n\t \n\tif (local->card_status != CARD_AWAITING_PARAM)\n\t\treturn -EBUSY;\n\n\t \n\tif (wrqu->essid.flags == 0)\n\t\t \n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (wrqu->essid.length > IW_ESSID_MAX_SIZE)\n\t\treturn -E2BIG;\n\n\t \n\tmemset(local->sparm.b5.a_current_ess_id, 0, IW_ESSID_MAX_SIZE);\n\tmemcpy(local->sparm.b5.a_current_ess_id, extra, wrqu->essid.length);\n\n\treturn -EINPROGRESS;\t \n}\n\n \n \nstatic int ray_get_essid(struct net_device *dev, struct iw_request_info *info,\n\t\t\t union iwreq_data *wrqu, char *extra)\n{\n\tray_dev_t *local = netdev_priv(dev);\n\tUCHAR tmp[IW_ESSID_MAX_SIZE + 1];\n\n\t \n\tmemcpy(extra, local->sparm.b5.a_current_ess_id, IW_ESSID_MAX_SIZE);\n\tmemcpy(tmp, local->sparm.b5.a_current_ess_id, IW_ESSID_MAX_SIZE);\n\ttmp[IW_ESSID_MAX_SIZE] = '\\0';\n\n\t \n\twrqu->essid.length = strlen(tmp);\n\twrqu->essid.flags = 1;\t \n\n\treturn 0;\n}\n\n \n \nstatic int ray_get_wap(struct net_device *dev, struct iw_request_info *info,\n\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tray_dev_t *local = netdev_priv(dev);\n\n\tmemcpy(wrqu->ap_addr.sa_data, local->bss_id, ETH_ALEN);\n\twrqu->ap_addr.sa_family = ARPHRD_ETHER;\n\n\treturn 0;\n}\n\n \n \nstatic int ray_set_rate(struct net_device *dev, struct iw_request_info *info,\n\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tray_dev_t *local = netdev_priv(dev);\n\n\t \n\tif (local->card_status != CARD_AWAITING_PARAM)\n\t\treturn -EBUSY;\n\n\t \n\tif ((wrqu->bitrate.value != 1000000) && (wrqu->bitrate.value != 2000000))\n\t\treturn -EINVAL;\n\n\t \n\tif ((local->fw_ver == 0x55) &&\t \n\t    (wrqu->bitrate.value == 2000000))\n\t\tlocal->net_default_tx_rate = 3;\n\telse\n\t\tlocal->net_default_tx_rate = wrqu->bitrate.value / 500000;\n\n\treturn 0;\n}\n\n \n \nstatic int ray_get_rate(struct net_device *dev, struct iw_request_info *info,\n\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tray_dev_t *local = netdev_priv(dev);\n\n\tif (local->net_default_tx_rate == 3)\n\t\twrqu->bitrate.value = 2000000;\t \n\telse\n\t\twrqu->bitrate.value = local->net_default_tx_rate * 500000;\n\twrqu->bitrate.fixed = 0;\t \n\n\treturn 0;\n}\n\n \n \nstatic int ray_set_rts(struct net_device *dev, struct iw_request_info *info,\n\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tray_dev_t *local = netdev_priv(dev);\n\tint rthr = wrqu->rts.value;\n\n\t \n\tif (local->card_status != CARD_AWAITING_PARAM)\n\t\treturn -EBUSY;\n\n\t \n\tif (wrqu->rts.disabled)\n\t\trthr = 32767;\n\telse {\n\t\tif ((rthr < 0) || (rthr > 2347))    \n\t\t\treturn -EINVAL;\n\t}\n\tlocal->sparm.b5.a_rts_threshold[0] = (rthr >> 8) & 0xFF;\n\tlocal->sparm.b5.a_rts_threshold[1] = rthr & 0xFF;\n\n\treturn -EINPROGRESS;\t \n}\n\n \n \nstatic int ray_get_rts(struct net_device *dev, struct iw_request_info *info,\n\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tray_dev_t *local = netdev_priv(dev);\n\n\twrqu->rts.value = (local->sparm.b5.a_rts_threshold[0] << 8)\n\t    + local->sparm.b5.a_rts_threshold[1];\n\twrqu->rts.disabled = (wrqu->rts.value == 32767);\n\twrqu->rts.fixed = 1;\n\n\treturn 0;\n}\n\n \n \nstatic int ray_set_frag(struct net_device *dev, struct iw_request_info *info,\n\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tray_dev_t *local = netdev_priv(dev);\n\tint fthr = wrqu->frag.value;\n\n\t \n\tif (local->card_status != CARD_AWAITING_PARAM)\n\t\treturn -EBUSY;\n\n\t \n\tif (wrqu->frag.disabled)\n\t\tfthr = 32767;\n\telse {\n\t\tif ((fthr < 256) || (fthr > 2347))\t \n\t\t\treturn -EINVAL;\n\t}\n\tlocal->sparm.b5.a_frag_threshold[0] = (fthr >> 8) & 0xFF;\n\tlocal->sparm.b5.a_frag_threshold[1] = fthr & 0xFF;\n\n\treturn -EINPROGRESS;\t \n}\n\n \n \nstatic int ray_get_frag(struct net_device *dev, struct iw_request_info *info,\n\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tray_dev_t *local = netdev_priv(dev);\n\n\twrqu->frag.value = (local->sparm.b5.a_frag_threshold[0] << 8)\n\t    + local->sparm.b5.a_frag_threshold[1];\n\twrqu->frag.disabled = (wrqu->frag.value == 32767);\n\twrqu->frag.fixed = 1;\n\n\treturn 0;\n}\n\n \n \nstatic int ray_set_mode(struct net_device *dev, struct iw_request_info *info,\n\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tray_dev_t *local = netdev_priv(dev);\n\tint err = -EINPROGRESS;\t \n\tchar card_mode = 1;\n\n\t \n\tif (local->card_status != CARD_AWAITING_PARAM)\n\t\treturn -EBUSY;\n\n\tswitch (wrqu->mode) {\n\tcase IW_MODE_ADHOC:\n\t\tcard_mode = 0;\n\t\tfallthrough;\n\tcase IW_MODE_INFRA:\n\t\tlocal->sparm.b5.a_network_type = card_mode;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\n\n \n \nstatic int ray_get_mode(struct net_device *dev, struct iw_request_info *info,\n\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tray_dev_t *local = netdev_priv(dev);\n\n\tif (local->sparm.b5.a_network_type)\n\t\twrqu->mode = IW_MODE_INFRA;\n\telse\n\t\twrqu->mode = IW_MODE_ADHOC;\n\n\treturn 0;\n}\n\n \n \nstatic int ray_get_range(struct net_device *dev, struct iw_request_info *info,\n\t\t\t union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_range *range = (struct iw_range *)extra;\n\n\tmemset(range, 0, sizeof(struct iw_range));\n\n\t \n\twrqu->data.length = sizeof(struct iw_range);\n\n\t \n\trange->we_version_compiled = WIRELESS_EXT;\n\trange->we_version_source = 9;\n\n\t \n\trange->throughput = 1.1 * 1000 * 1000;\t \n\trange->num_channels = hop_pattern_length[(int)country];\n\trange->num_frequency = 0;\n\trange->max_qual.qual = 0;\n\trange->max_qual.level = 255;\t \n\trange->max_qual.noise = 255;\t \n\trange->num_bitrates = 2;\n\trange->bitrate[0] = 1000000;\t \n\trange->bitrate[1] = 2000000;\t \n\treturn 0;\n}\n\n \n \nstatic int ray_set_framing(struct net_device *dev, struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\ttranslate = !!*(extra);\t \n\n\treturn 0;\n}\n\n \n \nstatic int ray_get_framing(struct net_device *dev, struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\t*(extra) = translate;\n\n\treturn 0;\n}\n\n \n \nstatic int ray_get_country(struct net_device *dev, struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\t*(extra) = country;\n\n\treturn 0;\n}\n\n \n \nstatic int ray_commit(struct net_device *dev, struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu, char *extra)\n{\n\treturn 0;\n}\n\n \n \nstatic iw_stats *ray_get_wireless_stats(struct net_device *dev)\n{\n\tray_dev_t *local = netdev_priv(dev);\n\tstruct pcmcia_device *link = local->finder;\n\tstruct status __iomem *p = local->sram + STATUS_BASE;\n\n\tlocal->wstats.status = local->card_status;\n#ifdef WIRELESS_SPY\n\tif ((local->spy_data.spy_number > 0)\n\t    && (local->sparm.b5.a_network_type == 0)) {\n\t\t \n\t\tlocal->wstats.qual.qual = local->spy_data.spy_stat[0].qual;\n\t\tlocal->wstats.qual.level = local->spy_data.spy_stat[0].level;\n\t\tlocal->wstats.qual.noise = local->spy_data.spy_stat[0].noise;\n\t\tlocal->wstats.qual.updated =\n\t\t    local->spy_data.spy_stat[0].updated;\n\t}\n#endif  \n\n\tif (pcmcia_dev_present(link)) {\n\t\tlocal->wstats.qual.noise = readb(&p->rxnoise);\n\t\tlocal->wstats.qual.updated |= 4;\n\t}\n\n\treturn &local->wstats;\n}  \n\n \n \n\nstatic const iw_handler ray_handler[] = {\n\tIW_HANDLER(SIOCSIWCOMMIT, ray_commit),\n\tIW_HANDLER(SIOCGIWNAME, ray_get_name),\n\tIW_HANDLER(SIOCSIWFREQ, ray_set_freq),\n\tIW_HANDLER(SIOCGIWFREQ, ray_get_freq),\n\tIW_HANDLER(SIOCSIWMODE, ray_set_mode),\n\tIW_HANDLER(SIOCGIWMODE, ray_get_mode),\n\tIW_HANDLER(SIOCGIWRANGE, ray_get_range),\n#ifdef WIRELESS_SPY\n\tIW_HANDLER(SIOCSIWSPY, iw_handler_set_spy),\n\tIW_HANDLER(SIOCGIWSPY, iw_handler_get_spy),\n\tIW_HANDLER(SIOCSIWTHRSPY, iw_handler_set_thrspy),\n\tIW_HANDLER(SIOCGIWTHRSPY, iw_handler_get_thrspy),\n#endif  \n\tIW_HANDLER(SIOCGIWAP, ray_get_wap),\n\tIW_HANDLER(SIOCSIWESSID, ray_set_essid),\n\tIW_HANDLER(SIOCGIWESSID, ray_get_essid),\n\tIW_HANDLER(SIOCSIWRATE, ray_set_rate),\n\tIW_HANDLER(SIOCGIWRATE, ray_get_rate),\n\tIW_HANDLER(SIOCSIWRTS, ray_set_rts),\n\tIW_HANDLER(SIOCGIWRTS, ray_get_rts),\n\tIW_HANDLER(SIOCSIWFRAG, ray_set_frag),\n\tIW_HANDLER(SIOCGIWFRAG, ray_get_frag),\n};\n\n#define SIOCSIPFRAMING\tSIOCIWFIRSTPRIV\t \n#define SIOCGIPFRAMING\tSIOCIWFIRSTPRIV + 1\t \n#define SIOCGIPCOUNTRY\tSIOCIWFIRSTPRIV + 3\t \n\nstatic const iw_handler ray_private_handler[] = {\n\t[0] = ray_set_framing,\n\t[1] = ray_get_framing,\n\t[3] = ray_get_country,\n};\n\nstatic const struct iw_priv_args ray_private_args[] = {\n \n\t{SIOCSIPFRAMING, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 1, 0,\n\t \"set_framing\"},\n\t{SIOCGIPFRAMING, 0, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 1,\n\t \"get_framing\"},\n\t{SIOCGIPCOUNTRY, 0, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 1,\n\t \"get_country\"},\n};\n\nstatic const struct iw_handler_def ray_handler_def = {\n\t.num_standard = ARRAY_SIZE(ray_handler),\n\t.num_private = ARRAY_SIZE(ray_private_handler),\n\t.num_private_args = ARRAY_SIZE(ray_private_args),\n\t.standard = ray_handler,\n\t.private = ray_private_handler,\n\t.private_args = ray_private_args,\n\t.get_wireless_stats = ray_get_wireless_stats,\n};\n\n \nstatic int ray_open(struct net_device *dev)\n{\n\tray_dev_t *local = netdev_priv(dev);\n\tstruct pcmcia_device *link;\n\tlink = local->finder;\n\n\tdev_dbg(&link->dev, \"ray_open('%s')\\n\", dev->name);\n\n\tif (link->open == 0)\n\t\tlocal->num_multi = 0;\n\tlink->open++;\n\n\t \n\tif (local->card_status == CARD_AWAITING_PARAM) {\n\t\tint i;\n\n\t\tdev_dbg(&link->dev, \"ray_open: doing init now !\\n\");\n\n\t\t \n\t\tif ((i = dl_startup_params(dev)) < 0) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"ray_dev_init dl_startup_params failed - \"\n\t\t\t       \"returns 0x%x\\n\", i);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (sniffer)\n\t\tnetif_stop_queue(dev);\n\telse\n\t\tnetif_start_queue(dev);\n\n\tdev_dbg(&link->dev, \"ray_open ending\\n\");\n\treturn 0;\n}  \n\n \nstatic int ray_dev_close(struct net_device *dev)\n{\n\tray_dev_t *local = netdev_priv(dev);\n\tstruct pcmcia_device *link;\n\tlink = local->finder;\n\n\tdev_dbg(&link->dev, \"ray_dev_close('%s')\\n\", dev->name);\n\n\tlink->open--;\n\tnetif_stop_queue(dev);\n\n\t \n\n\treturn 0;\n}  \n\n \nstatic void ray_reset(struct net_device *dev)\n{\n\tpr_debug(\"ray_reset entered\\n\");\n}\n\n \n \n \nstatic int interrupt_ecf(ray_dev_t *local, int ccs)\n{\n\tint i = 50;\n\tstruct pcmcia_device *link = local->finder;\n\n\tif (!(pcmcia_dev_present(link))) {\n\t\tdev_dbg(&link->dev, \"ray_cs interrupt_ecf - device not present\\n\");\n\t\treturn -1;\n\t}\n\tdev_dbg(&link->dev, \"interrupt_ecf(local=%p, ccs = 0x%x\\n\", local, ccs);\n\n\twhile (i &&\n\t       (readb(local->amem + CIS_OFFSET + ECF_INTR_OFFSET) &\n\t\tECF_INTR_SET))\n\t\ti--;\n\tif (i == 0) {\n\t\tdev_dbg(&link->dev, \"ray_cs interrupt_ecf card not ready for interrupt\\n\");\n\t\treturn -1;\n\t}\n\t \n\twriteb(ccs, local->sram + SCB_BASE);\n\twriteb(ECF_INTR_SET, local->amem + CIS_OFFSET + ECF_INTR_OFFSET);\n\treturn 0;\n}  \n\n \n \n \nstatic int get_free_tx_ccs(ray_dev_t *local)\n{\n\tint i;\n\tstruct ccs __iomem *pccs = ccs_base(local);\n\tstruct pcmcia_device *link = local->finder;\n\n\tif (!(pcmcia_dev_present(link))) {\n\t\tdev_dbg(&link->dev, \"ray_cs get_free_tx_ccs - device not present\\n\");\n\t\treturn ECARDGONE;\n\t}\n\n\tif (test_and_set_bit(0, &local->tx_ccs_lock)) {\n\t\tdev_dbg(&link->dev, \"ray_cs tx_ccs_lock busy\\n\");\n\t\treturn ECCSBUSY;\n\t}\n\n\tfor (i = 0; i < NUMBER_OF_TX_CCS; i++) {\n\t\tif (readb(&(pccs + i)->buffer_status) == CCS_BUFFER_FREE) {\n\t\t\twriteb(CCS_BUFFER_BUSY, &(pccs + i)->buffer_status);\n\t\t\twriteb(CCS_END_LIST, &(pccs + i)->link);\n\t\t\tlocal->tx_ccs_lock = 0;\n\t\t\treturn i;\n\t\t}\n\t}\n\tlocal->tx_ccs_lock = 0;\n\tdev_dbg(&link->dev, \"ray_cs ERROR no free tx CCS for raylink card\\n\");\n\treturn ECCSFULL;\n}  \n\n \n \n \nstatic int get_free_ccs(ray_dev_t *local)\n{\n\tint i;\n\tstruct ccs __iomem *pccs = ccs_base(local);\n\tstruct pcmcia_device *link = local->finder;\n\n\tif (!(pcmcia_dev_present(link))) {\n\t\tdev_dbg(&link->dev, \"ray_cs get_free_ccs - device not present\\n\");\n\t\treturn ECARDGONE;\n\t}\n\tif (test_and_set_bit(0, &local->ccs_lock)) {\n\t\tdev_dbg(&link->dev, \"ray_cs ccs_lock busy\\n\");\n\t\treturn ECCSBUSY;\n\t}\n\n\tfor (i = NUMBER_OF_TX_CCS; i < NUMBER_OF_CCS; i++) {\n\t\tif (readb(&(pccs + i)->buffer_status) == CCS_BUFFER_FREE) {\n\t\t\twriteb(CCS_BUFFER_BUSY, &(pccs + i)->buffer_status);\n\t\t\twriteb(CCS_END_LIST, &(pccs + i)->link);\n\t\t\tlocal->ccs_lock = 0;\n\t\t\treturn i;\n\t\t}\n\t}\n\tlocal->ccs_lock = 0;\n\tdev_dbg(&link->dev, \"ray_cs ERROR no free CCS for raylink card\\n\");\n\treturn ECCSFULL;\n}  \n\n \nstatic void authenticate_timeout(struct timer_list *t)\n{\n\tray_dev_t *local = from_timer(local, t, timer);\n\tdel_timer(&local->timer);\n\tprintk(KERN_INFO \"ray_cs Authentication with access point failed\"\n\t       \" - timeout\\n\");\n\tjoin_net(&local->timer);\n}\n\n \nstatic int parse_addr(char *in_str, UCHAR *out)\n{\n\tint i, k;\n\tint len;\n\n\tif (in_str == NULL)\n\t\treturn 0;\n\tlen = strnlen(in_str, ADDRLEN * 2 + 1) - 1;\n\tif (len < 1)\n\t\treturn 0;\n\tmemset(out, 0, ADDRLEN);\n\n\ti = 5;\n\n\twhile (len > 0) {\n\t\tif ((k = hex_to_bin(in_str[len--])) != -1)\n\t\t\tout[i] = k;\n\t\telse\n\t\t\treturn 0;\n\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tif ((k = hex_to_bin(in_str[len--])) != -1)\n\t\t\tout[i] += k << 4;\n\t\telse\n\t\t\treturn 0;\n\t\tif (!i--)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}\n\n \nstatic struct net_device_stats *ray_get_stats(struct net_device *dev)\n{\n\tray_dev_t *local = netdev_priv(dev);\n\tstruct pcmcia_device *link = local->finder;\n\tstruct status __iomem *p = local->sram + STATUS_BASE;\n\tif (!(pcmcia_dev_present(link))) {\n\t\tdev_dbg(&link->dev, \"ray_cs net_device_stats - device not present\\n\");\n\t\treturn &local->stats;\n\t}\n\tif (readb(&p->mrx_overflow_for_host)) {\n\t\tlocal->stats.rx_over_errors += swab16(readw(&p->mrx_overflow));\n\t\twriteb(0, &p->mrx_overflow);\n\t\twriteb(0, &p->mrx_overflow_for_host);\n\t}\n\tif (readb(&p->mrx_checksum_error_for_host)) {\n\t\tlocal->stats.rx_crc_errors +=\n\t\t    swab16(readw(&p->mrx_checksum_error));\n\t\twriteb(0, &p->mrx_checksum_error);\n\t\twriteb(0, &p->mrx_checksum_error_for_host);\n\t}\n\tif (readb(&p->rx_hec_error_for_host)) {\n\t\tlocal->stats.rx_frame_errors += swab16(readw(&p->rx_hec_error));\n\t\twriteb(0, &p->rx_hec_error);\n\t\twriteb(0, &p->rx_hec_error_for_host);\n\t}\n\treturn &local->stats;\n}\n\n \nstatic void ray_update_parm(struct net_device *dev, UCHAR objid, UCHAR *value,\n\t\t\t    int len)\n{\n\tray_dev_t *local = netdev_priv(dev);\n\tstruct pcmcia_device *link = local->finder;\n\tint ccsindex;\n\tint i;\n\tstruct ccs __iomem *pccs;\n\n\tif (!(pcmcia_dev_present(link))) {\n\t\tdev_dbg(&link->dev, \"ray_update_parm - device not present\\n\");\n\t\treturn;\n\t}\n\n\tif ((ccsindex = get_free_ccs(local)) < 0) {\n\t\tdev_dbg(&link->dev, \"ray_update_parm - No free ccs\\n\");\n\t\treturn;\n\t}\n\tpccs = ccs_base(local) + ccsindex;\n\twriteb(CCS_UPDATE_PARAMS, &pccs->cmd);\n\twriteb(objid, &pccs->var.update_param.object_id);\n\twriteb(1, &pccs->var.update_param.number_objects);\n\twriteb(0, &pccs->var.update_param.failure_cause);\n\tfor (i = 0; i < len; i++) {\n\t\twriteb(value[i], local->sram + HOST_TO_ECF_BASE);\n\t}\n\t \n\tif (interrupt_ecf(local, ccsindex)) {\n\t\tdev_dbg(&link->dev, \"ray_cs associate failed - ECF not ready for intr\\n\");\n\t\twriteb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);\n\t}\n}\n\n \nstatic void ray_update_multi_list(struct net_device *dev, int all)\n{\n\tint ccsindex;\n\tstruct ccs __iomem *pccs;\n\tray_dev_t *local = netdev_priv(dev);\n\tstruct pcmcia_device *link = local->finder;\n\tvoid __iomem *p = local->sram + HOST_TO_ECF_BASE;\n\n\tif (!(pcmcia_dev_present(link))) {\n\t\tdev_dbg(&link->dev, \"ray_update_multi_list - device not present\\n\");\n\t\treturn;\n\t} else\n\t\tdev_dbg(&link->dev, \"ray_update_multi_list(%p)\\n\", dev);\n\tif ((ccsindex = get_free_ccs(local)) < 0) {\n\t\tdev_dbg(&link->dev, \"ray_update_multi - No free ccs\\n\");\n\t\treturn;\n\t}\n\tpccs = ccs_base(local) + ccsindex;\n\twriteb(CCS_UPDATE_MULTICAST_LIST, &pccs->cmd);\n\n\tif (all) {\n\t\twriteb(0xff, &pccs->var);\n\t\tlocal->num_multi = 0xff;\n\t} else {\n\t\tstruct netdev_hw_addr *ha;\n\t\tint i = 0;\n\n\t\t \n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tmemcpy_toio(p, ha->addr, ETH_ALEN);\n\t\t\tdev_dbg(&link->dev, \"ray_update_multi add addr %pm\\n\",\n\t\t\t\tha->addr);\n\t\t\tp += ETH_ALEN;\n\t\t\ti++;\n\t\t}\n\t\tif (i > 256 / ADDRLEN)\n\t\t\ti = 256 / ADDRLEN;\n\t\twriteb((UCHAR) i, &pccs->var);\n\t\tdev_dbg(&link->dev, \"ray_cs update_multi %d addresses in list\\n\", i);\n\t\t \n\t\tlocal->num_multi = i;\n\t}\n\tif (interrupt_ecf(local, ccsindex)) {\n\t\tdev_dbg(&link->dev,\n\t\t      \"ray_cs update_multi failed - ECF not ready for intr\\n\");\n\t\twriteb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);\n\t}\n}  \n\n \nstatic void set_multicast_list(struct net_device *dev)\n{\n\tray_dev_t *local = netdev_priv(dev);\n\tUCHAR promisc;\n\n\tpr_debug(\"ray_cs set_multicast_list(%p)\\n\", dev);\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\tif (local->sparm.b5.a_promiscuous_mode == 0) {\n\t\t\tpr_debug(\"ray_cs set_multicast_list promisc on\\n\");\n\t\t\tlocal->sparm.b5.a_promiscuous_mode = 1;\n\t\t\tpromisc = 1;\n\t\t\tray_update_parm(dev, OBJID_promiscuous_mode,\n\t\t\t\t\t&promisc, sizeof(promisc));\n\t\t}\n\t} else {\n\t\tif (local->sparm.b5.a_promiscuous_mode == 1) {\n\t\t\tpr_debug(\"ray_cs set_multicast_list promisc off\\n\");\n\t\t\tlocal->sparm.b5.a_promiscuous_mode = 0;\n\t\t\tpromisc = 0;\n\t\t\tray_update_parm(dev, OBJID_promiscuous_mode,\n\t\t\t\t\t&promisc, sizeof(promisc));\n\t\t}\n\t}\n\n\tif (dev->flags & IFF_ALLMULTI)\n\t\tray_update_multi_list(dev, 1);\n\telse {\n\t\tif (local->num_multi != netdev_mc_count(dev))\n\t\t\tray_update_multi_list(dev, 0);\n\t}\n}  \n\n \nstatic irqreturn_t ray_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = (struct net_device *)dev_id;\n\tstruct pcmcia_device *link;\n\tray_dev_t *local;\n\tstruct ccs __iomem *pccs;\n\tstruct rcs __iomem *prcs;\n\tUCHAR rcsindex;\n\tUCHAR tmp;\n\tUCHAR cmd;\n\tUCHAR status;\n\tUCHAR memtmp[ESSID_SIZE + 1];\n\n\n\tif (dev == NULL)\t \n\t\treturn IRQ_NONE;\n\n\tpr_debug(\"ray_cs: interrupt for *dev=%p\\n\", dev);\n\n\tlocal = netdev_priv(dev);\n\tlink = local->finder;\n\tif (!pcmcia_dev_present(link)) {\n\t\tpr_debug(\n\t\t\t\"ray_cs interrupt from device not present or suspended.\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\trcsindex = readb(&((struct scb __iomem *)(local->sram))->rcs_index);\n\n\tif (rcsindex >= (NUMBER_OF_CCS + NUMBER_OF_RCS)) {\n\t\tdev_dbg(&link->dev, \"ray_cs interrupt bad rcsindex = 0x%x\\n\", rcsindex);\n\t\tclear_interrupt(local);\n\t\treturn IRQ_HANDLED;\n\t}\n\tif (rcsindex < NUMBER_OF_CCS) {  \n\t\tpccs = ccs_base(local) + rcsindex;\n\t\tcmd = readb(&pccs->cmd);\n\t\tstatus = readb(&pccs->buffer_status);\n\t\tswitch (cmd) {\n\t\tcase CCS_DOWNLOAD_STARTUP_PARAMS:\t \n\t\t\tdel_timer(&local->timer);\n\t\t\tif (status == CCS_COMMAND_COMPLETE) {\n\t\t\t\tdev_dbg(&link->dev,\n\t\t\t\t      \"ray_cs interrupt download_startup_parameters OK\\n\");\n\t\t\t} else {\n\t\t\t\tdev_dbg(&link->dev,\n\t\t\t\t      \"ray_cs interrupt download_startup_parameters fail\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CCS_UPDATE_PARAMS:\n\t\t\tdev_dbg(&link->dev, \"ray_cs interrupt update params done\\n\");\n\t\t\tif (status != CCS_COMMAND_COMPLETE) {\n\t\t\t\ttmp =\n\t\t\t\t    readb(&pccs->var.update_param.\n\t\t\t\t\t  failure_cause);\n\t\t\t\tdev_dbg(&link->dev,\n\t\t\t\t      \"ray_cs interrupt update params failed - reason %d\\n\",\n\t\t\t\t      tmp);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CCS_REPORT_PARAMS:\n\t\t\tdev_dbg(&link->dev, \"ray_cs interrupt report params done\\n\");\n\t\t\tbreak;\n\t\tcase CCS_UPDATE_MULTICAST_LIST:\t \n\t\t\tdev_dbg(&link->dev,\n\t\t\t      \"ray_cs interrupt CCS Update Multicast List done\\n\");\n\t\t\tbreak;\n\t\tcase CCS_UPDATE_POWER_SAVINGS_MODE:\n\t\t\tdev_dbg(&link->dev,\n\t\t\t      \"ray_cs interrupt update power save mode done\\n\");\n\t\t\tbreak;\n\t\tcase CCS_START_NETWORK:\n\t\tcase CCS_JOIN_NETWORK:\n\t\t\tmemcpy(memtmp, local->sparm.b4.a_current_ess_id,\n\t\t\t\t\t\t\t\tESSID_SIZE);\n\t\t\tmemtmp[ESSID_SIZE] = '\\0';\n\n\t\t\tif (status == CCS_COMMAND_COMPLETE) {\n\t\t\t\tif (readb\n\t\t\t\t    (&pccs->var.start_network.net_initiated) ==\n\t\t\t\t    1) {\n\t\t\t\t\tdev_dbg(&link->dev,\n\t\t\t\t\t      \"ray_cs interrupt network \\\"%s\\\" started\\n\",\n\t\t\t\t\t      memtmp);\n\t\t\t\t} else {\n\t\t\t\t\tdev_dbg(&link->dev,\n\t\t\t\t\t      \"ray_cs interrupt network \\\"%s\\\" joined\\n\",\n\t\t\t\t\t      memtmp);\n\t\t\t\t}\n\t\t\t\tmemcpy_fromio(&local->bss_id,\n\t\t\t\t\t      pccs->var.start_network.bssid,\n\t\t\t\t\t      ADDRLEN);\n\n\t\t\t\tif (local->fw_ver == 0x55)\n\t\t\t\t\tlocal->net_default_tx_rate = 3;\n\t\t\t\telse\n\t\t\t\t\tlocal->net_default_tx_rate =\n\t\t\t\t\t    readb(&pccs->var.start_network.\n\t\t\t\t\t\t  net_default_tx_rate);\n\t\t\t\tlocal->encryption =\n\t\t\t\t    readb(&pccs->var.start_network.encryption);\n\t\t\t\tif (!sniffer && (local->net_type == INFRA)\n\t\t\t\t    && !(local->sparm.b4.a_acting_as_ap_status)) {\n\t\t\t\t\tauthenticate(local);\n\t\t\t\t}\n\t\t\t\tlocal->card_status = CARD_ACQ_COMPLETE;\n\t\t\t} else {\n\t\t\t\tlocal->card_status = CARD_ACQ_FAILED;\n\n\t\t\t\tdel_timer(&local->timer);\n\t\t\t\tlocal->timer.expires = jiffies + HZ * 5;\n\t\t\t\tif (status == CCS_START_NETWORK) {\n\t\t\t\t\tdev_dbg(&link->dev,\n\t\t\t\t\t      \"ray_cs interrupt network \\\"%s\\\" start failed\\n\",\n\t\t\t\t\t      memtmp);\n\t\t\t\t\tlocal->timer.function = start_net;\n\t\t\t\t} else {\n\t\t\t\t\tdev_dbg(&link->dev,\n\t\t\t\t\t      \"ray_cs interrupt network \\\"%s\\\" join failed\\n\",\n\t\t\t\t\t      memtmp);\n\t\t\t\t\tlocal->timer.function = join_net;\n\t\t\t\t}\n\t\t\t\tadd_timer(&local->timer);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CCS_START_ASSOCIATION:\n\t\t\tif (status == CCS_COMMAND_COMPLETE) {\n\t\t\t\tlocal->card_status = CARD_ASSOC_COMPLETE;\n\t\t\t\tdev_dbg(&link->dev, \"ray_cs association successful\\n\");\n\t\t\t} else {\n\t\t\t\tdev_dbg(&link->dev, \"ray_cs association failed,\\n\");\n\t\t\t\tlocal->card_status = CARD_ASSOC_FAILED;\n\t\t\t\tjoin_net(&local->timer);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CCS_TX_REQUEST:\n\t\t\tif (status == CCS_COMMAND_COMPLETE) {\n\t\t\t\tdev_dbg(&link->dev,\n\t\t\t\t      \"ray_cs interrupt tx request complete\\n\");\n\t\t\t} else {\n\t\t\t\tdev_dbg(&link->dev,\n\t\t\t\t      \"ray_cs interrupt tx request failed\\n\");\n\t\t\t}\n\t\t\tif (!sniffer)\n\t\t\t\tnetif_start_queue(dev);\n\t\t\tnetif_wake_queue(dev);\n\t\t\tbreak;\n\t\tcase CCS_TEST_MEMORY:\n\t\t\tdev_dbg(&link->dev, \"ray_cs interrupt mem test done\\n\");\n\t\t\tbreak;\n\t\tcase CCS_SHUTDOWN:\n\t\t\tdev_dbg(&link->dev,\n\t\t\t      \"ray_cs interrupt Unexpected CCS returned - Shutdown\\n\");\n\t\t\tbreak;\n\t\tcase CCS_DUMP_MEMORY:\n\t\t\tdev_dbg(&link->dev, \"ray_cs interrupt dump memory done\\n\");\n\t\t\tbreak;\n\t\tcase CCS_START_TIMER:\n\t\t\tdev_dbg(&link->dev,\n\t\t\t      \"ray_cs interrupt DING - raylink timer expired\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&link->dev,\n\t\t\t      \"ray_cs interrupt Unexpected CCS 0x%x returned 0x%x\\n\",\n\t\t\t      rcsindex, cmd);\n\t\t}\n\t\twriteb(CCS_BUFFER_FREE, &pccs->buffer_status);\n\t} else {  \n\n\t\tprcs = rcs_base(local) + rcsindex;\n\n\t\tswitch (readb(&prcs->interrupt_id)) {\n\t\tcase PROCESS_RX_PACKET:\n\t\t\tray_rx(dev, local, prcs);\n\t\t\tbreak;\n\t\tcase REJOIN_NET_COMPLETE:\n\t\t\tdev_dbg(&link->dev, \"ray_cs interrupt rejoin net complete\\n\");\n\t\t\tlocal->card_status = CARD_ACQ_COMPLETE;\n\t\t\t \n\t\t\tif (local->sparm.b4.a_network_type == ADHOC) {\n\t\t\t\tif (!sniffer)\n\t\t\t\t\tnetif_start_queue(dev);\n\t\t\t} else {\n\t\t\t\tmemcpy_fromio(&local->bss_id,\n\t\t\t\t\t      prcs->var.rejoin_net_complete.\n\t\t\t\t\t      bssid, ADDRLEN);\n\t\t\t\tdev_dbg(&link->dev, \"ray_cs new BSSID = %pm\\n\",\n\t\t\t\t\tlocal->bss_id);\n\t\t\t\tif (!sniffer)\n\t\t\t\t\tauthenticate(local);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ROAMING_INITIATED:\n\t\t\tdev_dbg(&link->dev, \"ray_cs interrupt roaming initiated\\n\");\n\t\t\tnetif_stop_queue(dev);\n\t\t\tlocal->card_status = CARD_DOING_ACQ;\n\t\t\tbreak;\n\t\tcase JAPAN_CALL_SIGN_RXD:\n\t\t\tdev_dbg(&link->dev, \"ray_cs interrupt japan call sign rx\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&link->dev,\n\t\t\t      \"ray_cs Unexpected interrupt for RCS 0x%x cmd = 0x%x\\n\",\n\t\t\t      rcsindex,\n\t\t\t      (unsigned int)readb(&prcs->interrupt_id));\n\t\t\tbreak;\n\t\t}\n\t\twriteb(CCS_BUFFER_FREE, &prcs->buffer_status);\n\t}\n\tclear_interrupt(local);\n\treturn IRQ_HANDLED;\n}  \n\n \nstatic void ray_rx(struct net_device *dev, ray_dev_t *local,\n\t\t   struct rcs __iomem *prcs)\n{\n\tint rx_len;\n\tunsigned int pkt_addr;\n\tvoid __iomem *pmsg;\n\tpr_debug(\"ray_rx process rx packet\\n\");\n\n\t \n\tpkt_addr = ((readb(&prcs->var.rx_packet.rx_data_ptr[0]) << 8)\n\t\t    + readb(&prcs->var.rx_packet.rx_data_ptr[1])) & RX_BUFF_END;\n\t \n\trx_len = (readb(&prcs->var.rx_packet.rx_data_length[0]) << 8)\n\t    + readb(&prcs->var.rx_packet.rx_data_length[1]);\n\n\tlocal->last_rsl = readb(&prcs->var.rx_packet.rx_sig_lev);\n\tpmsg = local->rmem + pkt_addr;\n\tswitch (readb(pmsg)) {\n\tcase DATA_TYPE:\n\t\tpr_debug(\"ray_rx data type\\n\");\n\t\trx_data(dev, prcs, pkt_addr, rx_len);\n\t\tbreak;\n\tcase AUTHENTIC_TYPE:\n\t\tpr_debug(\"ray_rx authentic type\\n\");\n\t\tif (sniffer)\n\t\t\trx_data(dev, prcs, pkt_addr, rx_len);\n\t\telse\n\t\t\trx_authenticate(local, prcs, pkt_addr, rx_len);\n\t\tbreak;\n\tcase DEAUTHENTIC_TYPE:\n\t\tpr_debug(\"ray_rx deauth type\\n\");\n\t\tif (sniffer)\n\t\t\trx_data(dev, prcs, pkt_addr, rx_len);\n\t\telse\n\t\t\trx_deauthenticate(local, prcs, pkt_addr, rx_len);\n\t\tbreak;\n\tcase NULL_MSG_TYPE:\n\t\tpr_debug(\"ray_cs rx NULL msg\\n\");\n\t\tbreak;\n\tcase BEACON_TYPE:\n\t\tpr_debug(\"ray_rx beacon type\\n\");\n\t\tif (sniffer)\n\t\t\trx_data(dev, prcs, pkt_addr, rx_len);\n\n\t\tcopy_from_rx_buff(local, (UCHAR *) &local->last_bcn, pkt_addr,\n\t\t\t\t  rx_len < sizeof(struct beacon_rx) ?\n\t\t\t\t  rx_len : sizeof(struct beacon_rx));\n\n\t\tlocal->beacon_rxed = 1;\n\t\t \n\t\tray_get_stats(dev);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"ray_cs unknown pkt type %2x\\n\",\n\t\t      (unsigned int)readb(pmsg));\n\t\tbreak;\n\t}\n\n}  \n\n \nstatic void rx_data(struct net_device *dev, struct rcs __iomem *prcs,\n\t\t    unsigned int pkt_addr, int rx_len)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct rcs __iomem *prcslink = prcs;\n\tray_dev_t *local = netdev_priv(dev);\n\tUCHAR *rx_ptr;\n\tint total_len;\n\tint tmp;\n#ifdef WIRELESS_SPY\n\tint siglev = local->last_rsl;\n\tu_char linksrcaddr[ETH_ALEN];\t \n#endif\n\n\tif (!sniffer) {\n\t\tif (translate) {\n \n\t\t\tif (rx_len < (ETH_HLEN + RX_MAC_HEADER_LENGTH) ||\n\t\t\t    rx_len >\n\t\t\t    (dev->mtu + RX_MAC_HEADER_LENGTH + ETH_HLEN +\n\t\t\t     FCS_LEN)) {\n\t\t\t\tpr_debug(\n\t\t\t\t      \"ray_cs invalid packet length %d received\\n\",\n\t\t\t\t      rx_len);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {  \n\n\t\t\tif (rx_len < (ETH_HLEN + RX_MAC_HEADER_LENGTH) ||\n\t\t\t    rx_len >\n\t\t\t    (dev->mtu + RX_MAC_HEADER_LENGTH + ETH_HLEN +\n\t\t\t     FCS_LEN)) {\n\t\t\t\tpr_debug(\n\t\t\t\t      \"ray_cs invalid packet length %d received\\n\",\n\t\t\t\t      rx_len);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tpr_debug(\"ray_cs rx_data packet\\n\");\n\t \n\tif (readb(&prcs->var.rx_packet.next_frag_rcs_index) != 0xFF) {\n\t\tpr_debug(\"ray_cs rx'ed fragment\\n\");\n\t\ttmp = (readb(&prcs->var.rx_packet.totalpacketlength[0]) << 8)\n\t\t    + readb(&prcs->var.rx_packet.totalpacketlength[1]);\n\t\ttotal_len = tmp;\n\t\tprcslink = prcs;\n\t\tdo {\n\t\t\ttmp -=\n\t\t\t    (readb(&prcslink->var.rx_packet.rx_data_length[0])\n\t\t\t     << 8)\n\t\t\t    + readb(&prcslink->var.rx_packet.rx_data_length[1]);\n\t\t\tif (readb(&prcslink->var.rx_packet.next_frag_rcs_index)\n\t\t\t    == 0xFF || tmp < 0)\n\t\t\t\tbreak;\n\t\t\tprcslink = rcs_base(local)\n\t\t\t    + readb(&prcslink->link_field);\n\t\t} while (1);\n\n\t\tif (tmp < 0) {\n\t\t\tpr_debug(\n\t\t\t      \"ray_cs rx_data fragment lengths don't add up\\n\");\n\t\t\tlocal->stats.rx_dropped++;\n\t\t\trelease_frag_chain(local, prcs);\n\t\t\treturn;\n\t\t}\n\t} else {  \n\t\ttotal_len = rx_len;\n\t}\n\n\tskb = dev_alloc_skb(total_len + 5);\n\tif (skb == NULL) {\n\t\tpr_debug(\"ray_cs rx_data could not allocate skb\\n\");\n\t\tlocal->stats.rx_dropped++;\n\t\tif (readb(&prcs->var.rx_packet.next_frag_rcs_index) != 0xFF)\n\t\t\trelease_frag_chain(local, prcs);\n\t\treturn;\n\t}\n\tskb_reserve(skb, 2);\t \n\n\tpr_debug(\"ray_cs rx_data total_len = %x, rx_len = %x\\n\", total_len,\n\t      rx_len);\n\n \n\t \n\trx_ptr = skb_put(skb, total_len);\n\t \n\trx_ptr +=\n\t    copy_from_rx_buff(local, rx_ptr, pkt_addr & RX_BUFF_END, rx_len);\n\t \n#ifdef WIRELESS_SPY\n\tskb_copy_from_linear_data_offset(skb,\n\t\t\t\t\t offsetof(struct mac_header, addr_2),\n\t\t\t\t\t linksrcaddr, ETH_ALEN);\n#endif\n\t \n\tif (!sniffer) {\n\t\tif (!translate) {\n\t\t\t \n \n\t\t\tskb_pull(skb, RX_MAC_HEADER_LENGTH);\n\t\t} else {\n\t\t\t \n\t\t\tuntranslate(local, skb, total_len);\n\t\t}\n\t} else {  \n\t}\n\n \n\t \n\ttmp = 17;\n\tif (readb(&prcs->var.rx_packet.next_frag_rcs_index) != 0xFF) {\n\t\tprcslink = prcs;\n\t\tpr_debug(\"ray_cs rx_data in fragment loop\\n\");\n\t\tdo {\n\t\t\tprcslink = rcs_base(local)\n\t\t\t    +\n\t\t\t    readb(&prcslink->var.rx_packet.next_frag_rcs_index);\n\t\t\trx_len =\n\t\t\t    ((readb(&prcslink->var.rx_packet.rx_data_length[0])\n\t\t\t      << 8)\n\t\t\t     +\n\t\t\t     readb(&prcslink->var.rx_packet.rx_data_length[1]))\n\t\t\t    & RX_BUFF_END;\n\t\t\tpkt_addr =\n\t\t\t    ((readb(&prcslink->var.rx_packet.rx_data_ptr[0]) <<\n\t\t\t      8)\n\t\t\t     + readb(&prcslink->var.rx_packet.rx_data_ptr[1]))\n\t\t\t    & RX_BUFF_END;\n\n\t\t\trx_ptr +=\n\t\t\t    copy_from_rx_buff(local, rx_ptr, pkt_addr, rx_len);\n\n\t\t} while (tmp-- &&\n\t\t\t readb(&prcslink->var.rx_packet.next_frag_rcs_index) !=\n\t\t\t 0xFF);\n\t\trelease_frag_chain(local, prcs);\n\t}\n\n\tskb->protocol = eth_type_trans(skb, dev);\n\tnetif_rx(skb);\n\tlocal->stats.rx_packets++;\n\tlocal->stats.rx_bytes += total_len;\n\n\t \n#ifdef WIRELESS_SPY\n\t \n\tif (!memcmp(linksrcaddr, local->bss_id, ETH_ALEN)) {\n\t\t \n\t\t \n\t\tlocal->wstats.qual.level = siglev;\n\t\t \n\t\tlocal->wstats.qual.updated = 0x2;\n\t}\n\t \n\t{\n\t\tstruct iw_quality wstats;\n\t\twstats.level = siglev;\n\t\t \n\t\t \n\t\twstats.updated = 0x2;\n\t\t \n\t\twireless_spy_update(dev, linksrcaddr, &wstats);\n\t}\n#endif  \n}  \n\n \nstatic void untranslate(ray_dev_t *local, struct sk_buff *skb, int len)\n{\n\tsnaphdr_t *psnap = (snaphdr_t *) (skb->data + RX_MAC_HEADER_LENGTH);\n\tstruct ieee80211_hdr *pmac = (struct ieee80211_hdr *)skb->data;\n\t__be16 type = *(__be16 *) psnap->ethertype;\n\tint delta;\n\tstruct ethhdr *peth;\n\tUCHAR srcaddr[ADDRLEN];\n\tUCHAR destaddr[ADDRLEN];\n\tstatic const UCHAR org_bridge[3] = { 0, 0, 0xf8 };\n\tstatic const UCHAR org_1042[3] = { 0, 0, 0 };\n\n\tmemcpy(destaddr, ieee80211_get_DA(pmac), ADDRLEN);\n\tmemcpy(srcaddr, ieee80211_get_SA(pmac), ADDRLEN);\n\n#if 0\n\tif {\n\t\tprint_hex_dump(KERN_DEBUG, \"skb->data before untranslate: \",\n\t\t\t       DUMP_PREFIX_NONE, 16, 1,\n\t\t\t       skb->data, 64, true);\n\t\tprintk(KERN_DEBUG\n\t\t       \"type = %08x, xsap = %02x%02x%02x, org = %02x02x02x\\n\",\n\t\t       ntohs(type), psnap->dsap, psnap->ssap, psnap->ctrl,\n\t\t       psnap->org[0], psnap->org[1], psnap->org[2]);\n\t\tprintk(KERN_DEBUG \"untranslate skb->data = %p\\n\", skb->data);\n\t}\n#endif\n\n\tif (psnap->dsap != 0xaa || psnap->ssap != 0xaa || psnap->ctrl != 3) {\n\t\t \n\t\tpr_debug(\"ray_cs untranslate NOT SNAP %02x %02x %02x\\n\",\n\t\t      psnap->dsap, psnap->ssap, psnap->ctrl);\n\n\t\tdelta = RX_MAC_HEADER_LENGTH - ETH_HLEN;\n\t\tpeth = (struct ethhdr *)(skb->data + delta);\n\t\tpeth->h_proto = htons(len - RX_MAC_HEADER_LENGTH);\n\t} else {  \n\t\tif (memcmp(psnap->org, org_bridge, 3) == 0) {\n\t\t \n\t\t\tpr_debug(\"ray_cs untranslate Bridge encap\\n\");\n\t\t\tdelta = RX_MAC_HEADER_LENGTH\n\t\t\t    + sizeof(struct snaphdr_t) - ETH_HLEN;\n\t\t\tpeth = (struct ethhdr *)(skb->data + delta);\n\t\t\tpeth->h_proto = type;\n\t\t} else if (memcmp(psnap->org, org_1042, 3) == 0) {\n\t\t\tswitch (ntohs(type)) {\n\t\t\tcase ETH_P_IPX:\n\t\t\tcase ETH_P_AARP:\n\t\t\t\tpr_debug(\"ray_cs untranslate RFC IPX/AARP\\n\");\n\t\t\t\tdelta = RX_MAC_HEADER_LENGTH - ETH_HLEN;\n\t\t\t\tpeth = (struct ethhdr *)(skb->data + delta);\n\t\t\t\tpeth->h_proto =\n\t\t\t\t    htons(len - RX_MAC_HEADER_LENGTH);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_debug(\"ray_cs untranslate RFC default\\n\");\n\t\t\t\tdelta = RX_MAC_HEADER_LENGTH +\n\t\t\t\t    sizeof(struct snaphdr_t) - ETH_HLEN;\n\t\t\t\tpeth = (struct ethhdr *)(skb->data + delta);\n\t\t\t\tpeth->h_proto = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tprintk(\"ray_cs untranslate very confused by packet\\n\");\n\t\t\tdelta = RX_MAC_HEADER_LENGTH - ETH_HLEN;\n\t\t\tpeth = (struct ethhdr *)(skb->data + delta);\n\t\t\tpeth->h_proto = type;\n\t\t}\n\t}\n \n\tskb_pull(skb, delta);\n\tpr_debug(\"untranslate after skb_pull(%d), skb->data = %p\\n\", delta,\n\t      skb->data);\n\tmemcpy(peth->h_dest, destaddr, ADDRLEN);\n\tmemcpy(peth->h_source, srcaddr, ADDRLEN);\n#if 0\n\t{\n\t\tint i;\n\t\tprintk(KERN_DEBUG \"skb->data after untranslate:\");\n\t\tfor (i = 0; i < 64; i++)\n\t\t\tprintk(\"%02x \", skb->data[i]);\n\t\tprintk(\"\\n\");\n\t}\n#endif\n}  \n\n \n \nstatic int copy_from_rx_buff(ray_dev_t *local, UCHAR *dest, int pkt_addr,\n\t\t\t     int length)\n{\n\tint wrap_bytes = (pkt_addr + length) - (RX_BUFF_END + 1);\n\tif (wrap_bytes <= 0) {\n\t\tmemcpy_fromio(dest, local->rmem + pkt_addr, length);\n\t} else {  \n\n\t\tmemcpy_fromio(dest, local->rmem + pkt_addr,\n\t\t\t      length - wrap_bytes);\n\t\tmemcpy_fromio(dest + length - wrap_bytes, local->rmem,\n\t\t\t      wrap_bytes);\n\t}\n\treturn length;\n}\n\n \nstatic void release_frag_chain(ray_dev_t *local, struct rcs __iomem *prcs)\n{\n\tstruct rcs __iomem *prcslink = prcs;\n\tint tmp = 17;\n\tunsigned rcsindex = readb(&prcs->var.rx_packet.next_frag_rcs_index);\n\n\twhile (tmp--) {\n\t\twriteb(CCS_BUFFER_FREE, &prcslink->buffer_status);\n\t\tif (rcsindex >= (NUMBER_OF_CCS + NUMBER_OF_RCS)) {\n\t\t\tpr_debug(\"ray_cs interrupt bad rcsindex = 0x%x\\n\",\n\t\t\t      rcsindex);\n\t\t\tbreak;\n\t\t}\n\t\tprcslink = rcs_base(local) + rcsindex;\n\t\trcsindex = readb(&prcslink->var.rx_packet.next_frag_rcs_index);\n\t}\n\twriteb(CCS_BUFFER_FREE, &prcslink->buffer_status);\n}\n\n \nstatic void authenticate(ray_dev_t *local)\n{\n\tstruct pcmcia_device *link = local->finder;\n\tdev_dbg(&link->dev, \"ray_cs Starting authentication.\\n\");\n\tif (!(pcmcia_dev_present(link))) {\n\t\tdev_dbg(&link->dev, \"ray_cs authenticate - device not present\\n\");\n\t\treturn;\n\t}\n\n\tdel_timer(&local->timer);\n\tif (build_auth_frame(local, local->bss_id, OPEN_AUTH_REQUEST)) {\n\t\tlocal->timer.function = join_net;\n\t} else {\n\t\tlocal->timer.function = authenticate_timeout;\n\t}\n\tlocal->timer.expires = jiffies + HZ * 2;\n\tadd_timer(&local->timer);\n\tlocal->authentication_state = AWAITING_RESPONSE;\n}  \n\n \nstatic void rx_authenticate(ray_dev_t *local, struct rcs __iomem *prcs,\n\t\t\t    unsigned int pkt_addr, int rx_len)\n{\n\tUCHAR buff[256];\n\tstruct ray_rx_msg *msg = (struct ray_rx_msg *) buff;\n\n\tdel_timer(&local->timer);\n\n\tcopy_from_rx_buff(local, buff, pkt_addr, rx_len & 0xff);\n\t \n\tif (local->sparm.b4.a_network_type == ADHOC) {\n\t\tpr_debug(\"ray_cs rx_auth var= %6ph\\n\", msg->var);\n\t\tif (msg->var[2] == 1) {\n\t\t\tpr_debug(\"ray_cs Sending authentication response.\\n\");\n\t\t\tif (!build_auth_frame\n\t\t\t    (local, msg->mac.addr_2, OPEN_AUTH_RESPONSE)) {\n\t\t\t\tlocal->authentication_state = NEED_TO_AUTH;\n\t\t\t\tmemcpy(local->auth_id, msg->mac.addr_2,\n\t\t\t\t       ADDRLEN);\n\t\t\t}\n\t\t}\n\t} else {  \n\n\t\tif (local->authentication_state == AWAITING_RESPONSE) {\n\t\t\t \n\t\t\tif (msg->var[2] == 2) {\n\t\t\t\tif ((msg->var[3] | msg->var[4]) == 0) {\n\t\t\t\t\tpr_debug(\"Authentication successful\\n\");\n\t\t\t\t\tlocal->card_status = CARD_AUTH_COMPLETE;\n\t\t\t\t\tassociate(local);\n\t\t\t\t\tlocal->authentication_state =\n\t\t\t\t\t    AUTHENTICATED;\n\t\t\t\t} else {\n\t\t\t\t\tpr_debug(\"Authentication refused\\n\");\n\t\t\t\t\tlocal->card_status = CARD_AUTH_REFUSED;\n\t\t\t\t\tjoin_net(&local->timer);\n\t\t\t\t\tlocal->authentication_state =\n\t\t\t\t\t    UNAUTHENTICATED;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}  \n\n \nstatic void associate(ray_dev_t *local)\n{\n\tstruct ccs __iomem *pccs;\n\tstruct pcmcia_device *link = local->finder;\n\tstruct net_device *dev = link->priv;\n\tint ccsindex;\n\tif (!(pcmcia_dev_present(link))) {\n\t\tdev_dbg(&link->dev, \"ray_cs associate - device not present\\n\");\n\t\treturn;\n\t}\n\t \n\tif ((ccsindex = get_free_ccs(local)) < 0) {\n \n\t\tdev_dbg(&link->dev, \"ray_cs associate - No free ccs\\n\");\n\t\treturn;\n\t}\n\tdev_dbg(&link->dev, \"ray_cs Starting association with access point\\n\");\n\tpccs = ccs_base(local) + ccsindex;\n\t \n\twriteb(CCS_START_ASSOCIATION, &pccs->cmd);\n\t \n\tif (interrupt_ecf(local, ccsindex)) {\n\t\tdev_dbg(&link->dev, \"ray_cs associate failed - ECF not ready for intr\\n\");\n\t\twriteb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);\n\n\t\tdel_timer(&local->timer);\n\t\tlocal->timer.expires = jiffies + HZ * 2;\n\t\tlocal->timer.function = join_net;\n\t\tadd_timer(&local->timer);\n\t\tlocal->card_status = CARD_ASSOC_FAILED;\n\t\treturn;\n\t}\n\tif (!sniffer)\n\t\tnetif_start_queue(dev);\n\n}  \n\n \nstatic void rx_deauthenticate(ray_dev_t *local, struct rcs __iomem *prcs,\n\t\t\t      unsigned int pkt_addr, int rx_len)\n{\n \n\tpr_debug(\"Deauthentication frame received\\n\");\n\tlocal->authentication_state = UNAUTHENTICATED;\n\t \n \n}\n\n \nstatic void clear_interrupt(ray_dev_t *local)\n{\n\twriteb(0, local->amem + CIS_OFFSET + HCS_INTR_OFFSET);\n}\n\n \n#ifdef CONFIG_PROC_FS\n#define MAXDATA (PAGE_SIZE - 80)\n\nstatic const char *card_status[] = {\n\t\"Card inserted - uninitialized\",\t \n\t\"Card not downloaded\",\t\t\t \n\t\"Waiting for download parameters\",\t \n\t\"Card doing acquisition\",\t\t \n\t\"Acquisition complete\",\t\t\t \n\t\"Authentication complete\",\t\t \n\t\"Association complete\",\t\t\t \n\t\"???\", \"???\", \"???\", \"???\",\t\t \n\t\"Card init error\",\t\t\t \n\t\"Download parameters error\",\t\t \n\t\"???\",\t\t\t\t\t \n\t\"Acquisition failed\",\t\t\t \n\t\"Authentication refused\",\t\t \n\t\"Association failed\"\t\t\t \n};\n\nstatic const char *nettype[] = { \"Adhoc\", \"Infra \" };\nstatic const char *framing[] = { \"Encapsulation\", \"Translation\" }\n\n;\n \nstatic int ray_cs_proc_show(struct seq_file *m, void *v)\n{\n \n\tint i;\n\tstruct pcmcia_device *link;\n\tstruct net_device *dev;\n\tray_dev_t *local;\n\tUCHAR *p;\n\tstruct freq_hop_element *pfh;\n\tUCHAR c[33];\n\n\tlink = this_device;\n\tif (!link)\n\t\treturn 0;\n\tdev = (struct net_device *)link->priv;\n\tif (!dev)\n\t\treturn 0;\n\tlocal = netdev_priv(dev);\n\tif (!local)\n\t\treturn 0;\n\n\tseq_puts(m, \"Raylink Wireless LAN driver status\\n\");\n\tseq_printf(m, \"%s\\n\", rcsid);\n\t \n\tseq_puts(m, \"Firmware version     = \");\n\tif (local->fw_ver == 0x55)\n\t\tseq_puts(m, \"4 - Use dump_cis for more details\\n\");\n\telse\n\t\tseq_printf(m, \"%2d.%02d.%02d\\n\",\n\t\t\t   local->fw_ver, local->fw_bld, local->fw_var);\n\n\tfor (i = 0; i < 32; i++)\n\t\tc[i] = local->sparm.b5.a_current_ess_id[i];\n\tc[32] = 0;\n\tseq_printf(m, \"%s network ESSID = \\\"%s\\\"\\n\",\n\t\t   nettype[local->sparm.b5.a_network_type], c);\n\n\tp = local->bss_id;\n\tseq_printf(m, \"BSSID                = %pM\\n\", p);\n\n\tseq_printf(m, \"Country code         = %d\\n\",\n\t\t   local->sparm.b5.a_curr_country_code);\n\n\ti = local->card_status;\n\tif (i < 0)\n\t\ti = 10;\n\tif (i > 16)\n\t\ti = 10;\n\tseq_printf(m, \"Card status          = %s\\n\", card_status[i]);\n\n\tseq_printf(m, \"Framing mode         = %s\\n\", framing[translate]);\n\n\tseq_printf(m, \"Last pkt signal lvl  = %d\\n\", local->last_rsl);\n\n\tif (local->beacon_rxed) {\n\t\t \n\t\tseq_printf(m, \"Beacon Interval      = %d Kus\\n\",\n\t\t\t   local->last_bcn.beacon_intvl[0]\n\t\t\t   + 256 * local->last_bcn.beacon_intvl[1]);\n\n\t\tp = local->last_bcn.elements;\n\t\tif (p[0] == C_ESSID_ELEMENT_ID)\n\t\t\tp += p[1] + 2;\n\t\telse {\n\t\t\tseq_printf(m,\n\t\t\t\t   \"Parse beacon failed at essid element id = %d\\n\",\n\t\t\t\t   p[0]);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (p[0] == C_SUPPORTED_RATES_ELEMENT_ID) {\n\t\t\tseq_puts(m, \"Supported rate codes = \");\n\t\t\tfor (i = 2; i < p[1] + 2; i++)\n\t\t\t\tseq_printf(m, \"0x%02x \", p[i]);\n\t\t\tseq_putc(m, '\\n');\n\t\t\tp += p[1] + 2;\n\t\t} else {\n\t\t\tseq_puts(m, \"Parse beacon failed at rates element\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (p[0] == C_FH_PARAM_SET_ELEMENT_ID) {\n\t\t\tpfh = (struct freq_hop_element *)p;\n\t\t\tseq_printf(m, \"Hop dwell            = %d Kus\\n\",\n\t\t\t\t   pfh->dwell_time[0] +\n\t\t\t\t   256 * pfh->dwell_time[1]);\n\t\t\tseq_printf(m, \"Hop set              = %d\\n\",\n\t\t\t\t   pfh->hop_set);\n\t\t\tseq_printf(m, \"Hop pattern          = %d\\n\",\n\t\t\t\t   pfh->hop_pattern);\n\t\t\tseq_printf(m, \"Hop index            = %d\\n\",\n\t\t\t\t   pfh->hop_index);\n\t\t\tp += p[1] + 2;\n\t\t} else {\n\t\t\tseq_puts(m,\n\t\t\t\t \"Parse beacon failed at FH param element\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tseq_puts(m, \"No beacons received\\n\");\n\t}\n\treturn 0;\n}\n#endif\n \nstatic int build_auth_frame(ray_dev_t *local, UCHAR *dest, int auth_type)\n{\n\tint addr;\n\tstruct ccs __iomem *pccs;\n\tstruct tx_msg __iomem *ptx;\n\tint ccsindex;\n\n\t \n\tif ((ccsindex = get_free_tx_ccs(local)) < 0) {\n\t\tpr_debug(\"ray_cs send authenticate - No free tx ccs\\n\");\n\t\treturn -1;\n\t}\n\n\tpccs = ccs_base(local) + ccsindex;\n\n\t \n\taddr = TX_BUF_BASE + (ccsindex << 11);\n\t \n\twriteb(CCS_TX_REQUEST, &pccs->cmd);\n\twriteb(addr >> 8, pccs->var.tx_request.tx_data_ptr);\n\twriteb(0x20, pccs->var.tx_request.tx_data_ptr + 1);\n\twriteb(TX_AUTHENTICATE_LENGTH_MSB, pccs->var.tx_request.tx_data_length);\n\twriteb(TX_AUTHENTICATE_LENGTH_LSB,\n\t       pccs->var.tx_request.tx_data_length + 1);\n\twriteb(0, &pccs->var.tx_request.pow_sav_mode);\n\n\tptx = local->sram + addr;\n\t \n\twriteb(PROTOCOL_VER | AUTHENTIC_TYPE, &ptx->mac.frame_ctl_1);\n\twriteb(0, &ptx->mac.frame_ctl_2);\n\n\tmemcpy_toio(ptx->mac.addr_1, dest, ADDRLEN);\n\tmemcpy_toio(ptx->mac.addr_2, local->sparm.b4.a_mac_addr, ADDRLEN);\n\tmemcpy_toio(ptx->mac.addr_3, local->bss_id, ADDRLEN);\n\n\t \n\tmemset_io(ptx->var, 0, 6);\n\twriteb(auth_type & 0xff, ptx->var + 2);\n\n\t \n\tif (interrupt_ecf(local, ccsindex)) {\n\t\tpr_debug(\n\t\t      \"ray_cs send authentication request failed - ECF not ready for intr\\n\");\n\t\twriteb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);\n\t\treturn -1;\n\t}\n\treturn 0;\n}  \n\n \n#ifdef CONFIG_PROC_FS\nstatic ssize_t ray_cs_essid_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tstatic char proc_essid[33];\n\tunsigned int len = count;\n\n\tif (len > 32)\n\t\tlen = 32;\n\tmemset(proc_essid, 0, 33);\n\tif (copy_from_user(proc_essid, buffer, len))\n\t\treturn -EFAULT;\n\tessid = proc_essid;\n\treturn count;\n}\n\nstatic const struct proc_ops ray_cs_essid_proc_ops = {\n\t.proc_write\t= ray_cs_essid_proc_write,\n\t.proc_lseek\t= noop_llseek,\n};\n\nstatic ssize_t int_proc_write(struct file *file, const char __user *buffer,\n\t\t\t      size_t count, loff_t *pos)\n{\n\tstatic char proc_number[10];\n\tchar *p;\n\tint nr, len;\n\n\tif (!count)\n\t\treturn 0;\n\n\tif (count > 9)\n\t\treturn -EINVAL;\n\tif (copy_from_user(proc_number, buffer, count))\n\t\treturn -EFAULT;\n\tp = proc_number;\n\tnr = 0;\n\tlen = count;\n\tdo {\n\t\tunsigned int c = *p - '0';\n\t\tif (c > 9)\n\t\t\treturn -EINVAL;\n\t\tnr = nr * 10 + c;\n\t\tp++;\n\t} while (--len);\n\t*(int *)pde_data(file_inode(file)) = nr;\n\treturn count;\n}\n\nstatic const struct proc_ops int_proc_ops = {\n\t.proc_write\t= int_proc_write,\n\t.proc_lseek\t= noop_llseek,\n};\n#endif\n\nstatic const struct pcmcia_device_id ray_ids[] = {\n\tPCMCIA_DEVICE_MANF_CARD(0x01a6, 0x0000),\n\tPCMCIA_DEVICE_NULL,\n};\n\nMODULE_DEVICE_TABLE(pcmcia, ray_ids);\n\nstatic struct pcmcia_driver ray_driver = {\n\t.owner = THIS_MODULE,\n\t.name = \"ray_cs\",\n\t.probe = ray_probe,\n\t.remove = ray_detach,\n\t.id_table = ray_ids,\n\t.suspend = ray_suspend,\n\t.resume = ray_resume,\n};\n\nstatic int __init init_ray_cs(void)\n{\n\tint rc;\n\n\tpr_debug(\"%s\\n\", rcsid);\n\trc = pcmcia_register_driver(&ray_driver);\n\tpr_debug(\"raylink init_module register_pcmcia_driver returns 0x%x\\n\",\n\t      rc);\n\tif (rc)\n\t\treturn rc;\n\n#ifdef CONFIG_PROC_FS\n\tproc_mkdir(\"driver/ray_cs\", NULL);\n\n\tproc_create_single(\"driver/ray_cs/ray_cs\", 0, NULL, ray_cs_proc_show);\n\tproc_create(\"driver/ray_cs/essid\", 0200, NULL, &ray_cs_essid_proc_ops);\n\tproc_create_data(\"driver/ray_cs/net_type\", 0200, NULL, &int_proc_ops,\n\t\t\t &net_type);\n\tproc_create_data(\"driver/ray_cs/translate\", 0200, NULL, &int_proc_ops,\n\t\t\t &translate);\n#endif\n\ttranslate = !!translate;\n\treturn 0;\n}  \n\n \n\nstatic void __exit exit_ray_cs(void)\n{\n\tpr_debug(\"ray_cs: cleanup_module\\n\");\n\n#ifdef CONFIG_PROC_FS\n\tremove_proc_subtree(\"driver/ray_cs\", NULL);\n#endif\n\n\tpcmcia_unregister_driver(&ray_driver);\n}  \n\nmodule_init(init_ray_cs);\nmodule_exit(exit_ray_cs);\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}