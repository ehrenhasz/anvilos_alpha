{
  "module_name": "rndis_wlan.c",
  "hash_id": "bc96f4c402ffa3588090c9dba794f79fee5c31108121eefa837d27cf0b7e0504",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/legacy/rndis_wlan.c",
  "human_readable_source": "\n \n\n\n\n\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/usb/cdc.h>\n#include <linux/ieee80211.h>\n#include <linux/if_arp.h>\n#include <linux/ctype.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <net/cfg80211.h>\n#include <linux/usb/usbnet.h>\n#include <linux/usb/rndis_host.h>\n\n\n \nstatic char modparam_country[4] = \"EU\";\nmodule_param_string(country, modparam_country, 4, 0444);\nMODULE_PARM_DESC(country, \"Country code (ISO 3166-1 alpha-2), default: EU\");\n\nstatic int modparam_frameburst = 1;\nmodule_param_named(frameburst, modparam_frameburst, int, 0444);\nMODULE_PARM_DESC(frameburst, \"enable frame bursting (default: on)\");\n\nstatic int modparam_afterburner = 0;\nmodule_param_named(afterburner, modparam_afterburner, int, 0444);\nMODULE_PARM_DESC(afterburner,\n\t\"enable afterburner aka '125 High Speed Mode' (default: off)\");\n\nstatic int modparam_power_save = 0;\nmodule_param_named(power_save, modparam_power_save, int, 0444);\nMODULE_PARM_DESC(power_save,\n\t\"set power save mode: 0=off, 1=on, 2=fast (default: off)\");\n\nstatic int modparam_power_output = 3;\nmodule_param_named(power_output, modparam_power_output, int, 0444);\nMODULE_PARM_DESC(power_output,\n\t\"set power output: 0=25%, 1=50%, 2=75%, 3=100% (default: 100%)\");\n\nstatic int modparam_roamtrigger = -70;\nmodule_param_named(roamtrigger, modparam_roamtrigger, int, 0444);\nMODULE_PARM_DESC(roamtrigger,\n\t\"set roaming dBm trigger: -80=optimize for distance, \"\n\t\t\t\t\"-60=bandwidth (default: -70)\");\n\nstatic int modparam_roamdelta = 1;\nmodule_param_named(roamdelta, modparam_roamdelta, int, 0444);\nMODULE_PARM_DESC(roamdelta,\n\t\"set roaming tendency: 0=aggressive, 1=moderate, \"\n\t\t\t\t\"2=conservative (default: moderate)\");\n\nstatic int modparam_workaround_interval;\nmodule_param_named(workaround_interval, modparam_workaround_interval,\n\t\t\t\t\t\t\tint, 0444);\nMODULE_PARM_DESC(workaround_interval,\n\t\"set stall workaround interval in msecs (0=disabled) (default: 0)\");\n\n \n#define\tWL_NOISE\t-96\t \n#define\tWL_SIGMAX\t-32\t \n\n\n \n#define BCM4320_DEFAULT_TXPOWER_DBM_100 13\n#define BCM4320_DEFAULT_TXPOWER_DBM_75  12\n#define BCM4320_DEFAULT_TXPOWER_DBM_50  10\n#define BCM4320_DEFAULT_TXPOWER_DBM_25  7\n\n \n#define RNDIS_UNKNOWN\t0\n#define RNDIS_BCM4320A\t1\n#define RNDIS_BCM4320B\t2\n\n\n \n#define NDIS_802_11_LENGTH_SSID 32\n#define NDIS_802_11_LENGTH_RATES 8\n#define NDIS_802_11_LENGTH_RATES_EX 16\n\nenum ndis_80211_net_type {\n\tNDIS_80211_TYPE_FREQ_HOP,\n\tNDIS_80211_TYPE_DIRECT_SEQ,\n\tNDIS_80211_TYPE_OFDM_A,\n\tNDIS_80211_TYPE_OFDM_G\n};\n\nenum ndis_80211_net_infra {\n\tNDIS_80211_INFRA_ADHOC,\n\tNDIS_80211_INFRA_INFRA,\n\tNDIS_80211_INFRA_AUTO_UNKNOWN\n};\n\nenum ndis_80211_auth_mode {\n\tNDIS_80211_AUTH_OPEN,\n\tNDIS_80211_AUTH_SHARED,\n\tNDIS_80211_AUTH_AUTO_SWITCH,\n\tNDIS_80211_AUTH_WPA,\n\tNDIS_80211_AUTH_WPA_PSK,\n\tNDIS_80211_AUTH_WPA_NONE,\n\tNDIS_80211_AUTH_WPA2,\n\tNDIS_80211_AUTH_WPA2_PSK\n};\n\nenum ndis_80211_encr_status {\n\tNDIS_80211_ENCR_WEP_ENABLED,\n\tNDIS_80211_ENCR_DISABLED,\n\tNDIS_80211_ENCR_WEP_KEY_ABSENT,\n\tNDIS_80211_ENCR_NOT_SUPPORTED,\n\tNDIS_80211_ENCR_TKIP_ENABLED,\n\tNDIS_80211_ENCR_TKIP_KEY_ABSENT,\n\tNDIS_80211_ENCR_CCMP_ENABLED,\n\tNDIS_80211_ENCR_CCMP_KEY_ABSENT\n};\n\nenum ndis_80211_priv_filter {\n\tNDIS_80211_PRIV_ACCEPT_ALL,\n\tNDIS_80211_PRIV_8021X_WEP\n};\n\nenum ndis_80211_status_type {\n\tNDIS_80211_STATUSTYPE_AUTHENTICATION,\n\tNDIS_80211_STATUSTYPE_MEDIASTREAMMODE,\n\tNDIS_80211_STATUSTYPE_PMKID_CANDIDATELIST,\n\tNDIS_80211_STATUSTYPE_RADIOSTATE,\n};\n\nenum ndis_80211_media_stream_mode {\n\tNDIS_80211_MEDIA_STREAM_OFF,\n\tNDIS_80211_MEDIA_STREAM_ON\n};\n\nenum ndis_80211_radio_status {\n\tNDIS_80211_RADIO_STATUS_ON,\n\tNDIS_80211_RADIO_STATUS_HARDWARE_OFF,\n\tNDIS_80211_RADIO_STATUS_SOFTWARE_OFF,\n};\n\nenum ndis_80211_addkey_bits {\n\tNDIS_80211_ADDKEY_8021X_AUTH = cpu_to_le32(1 << 28),\n\tNDIS_80211_ADDKEY_SET_INIT_RECV_SEQ = cpu_to_le32(1 << 29),\n\tNDIS_80211_ADDKEY_PAIRWISE_KEY = cpu_to_le32(1 << 30),\n\tNDIS_80211_ADDKEY_TRANSMIT_KEY = cpu_to_le32(1 << 31)\n};\n\nenum ndis_80211_addwep_bits {\n\tNDIS_80211_ADDWEP_PERCLIENT_KEY = cpu_to_le32(1 << 30),\n\tNDIS_80211_ADDWEP_TRANSMIT_KEY = cpu_to_le32(1 << 31)\n};\n\nenum ndis_80211_power_mode {\n\tNDIS_80211_POWER_MODE_CAM,\n\tNDIS_80211_POWER_MODE_MAX_PSP,\n\tNDIS_80211_POWER_MODE_FAST_PSP,\n};\n\nenum ndis_80211_pmkid_cand_list_flag_bits {\n\tNDIS_80211_PMKID_CAND_PREAUTH = cpu_to_le32(1 << 0)\n};\n\nstruct ndis_80211_auth_request {\n\t__le32 length;\n\tu8 bssid[ETH_ALEN];\n\tu8 padding[2];\n\t__le32 flags;\n} __packed;\n\nstruct ndis_80211_pmkid_candidate {\n\tu8 bssid[ETH_ALEN];\n\tu8 padding[2];\n\t__le32 flags;\n} __packed;\n\nstruct ndis_80211_pmkid_cand_list {\n\t__le32 version;\n\t__le32 num_candidates;\n\tstruct ndis_80211_pmkid_candidate candidate_list[];\n} __packed;\n\nstruct ndis_80211_status_indication {\n\t__le32 status_type;\n\tunion {\n\t\t__le32\t\t\t\t\tmedia_stream_mode;\n\t\t__le32\t\t\t\t\tradio_status;\n\t\tDECLARE_FLEX_ARRAY(struct ndis_80211_auth_request, auth_request);\n\t\tstruct ndis_80211_pmkid_cand_list\tcand_list;\n\t} u;\n} __packed;\n\nstruct ndis_80211_ssid {\n\t__le32 length;\n\tu8 essid[NDIS_802_11_LENGTH_SSID];\n} __packed;\n\nstruct ndis_80211_conf_freq_hop {\n\t__le32 length;\n\t__le32 hop_pattern;\n\t__le32 hop_set;\n\t__le32 dwell_time;\n} __packed;\n\nstruct ndis_80211_conf {\n\t__le32 length;\n\t__le32 beacon_period;\n\t__le32 atim_window;\n\t__le32 ds_config;\n\tstruct ndis_80211_conf_freq_hop fh_config;\n} __packed;\n\nstruct ndis_80211_bssid_ex {\n\t__le32 length;\n\tu8 mac[ETH_ALEN];\n\tu8 padding[2];\n\tstruct ndis_80211_ssid ssid;\n\t__le32 privacy;\n\t__le32 rssi;\n\t__le32 net_type;\n\tstruct ndis_80211_conf config;\n\t__le32 net_infra;\n\tu8 rates[NDIS_802_11_LENGTH_RATES_EX];\n\t__le32 ie_length;\n\tu8 ies[];\n} __packed;\n\nstruct ndis_80211_bssid_list_ex {\n\t__le32 num_items;\n\tu8 bssid_data[];\n} __packed;\n\nstruct ndis_80211_fixed_ies {\n\tu8 timestamp[8];\n\t__le16 beacon_interval;\n\t__le16 capabilities;\n} __packed;\n\nstruct ndis_80211_wep_key {\n\t__le32 size;\n\t__le32 index;\n\t__le32 length;\n\tu8 material[32];\n} __packed;\n\nstruct ndis_80211_key {\n\t__le32 size;\n\t__le32 index;\n\t__le32 length;\n\tu8 bssid[ETH_ALEN];\n\tu8 padding[6];\n\tu8 rsc[8];\n\tu8 material[32];\n} __packed;\n\nstruct ndis_80211_remove_key {\n\t__le32 size;\n\t__le32 index;\n\tu8 bssid[ETH_ALEN];\n\tu8 padding[2];\n} __packed;\n\nstruct ndis_config_param {\n\t__le32 name_offs;\n\t__le32 name_length;\n\t__le32 type;\n\t__le32 value_offs;\n\t__le32 value_length;\n} __packed;\n\nstruct ndis_80211_assoc_info {\n\t__le32 length;\n\t__le16 req_ies;\n\tstruct req_ie {\n\t\t__le16 capa;\n\t\t__le16 listen_interval;\n\t\tu8 cur_ap_address[ETH_ALEN];\n\t} req_ie;\n\t__le32 req_ie_length;\n\t__le32 offset_req_ies;\n\t__le16 resp_ies;\n\tstruct resp_ie {\n\t\t__le16 capa;\n\t\t__le16 status_code;\n\t\t__le16 assoc_id;\n\t} resp_ie;\n\t__le32 resp_ie_length;\n\t__le32 offset_resp_ies;\n} __packed;\n\nstruct ndis_80211_capability {\n\t__le32 length;\n\t__le32 version;\n\t__le32 num_pmkids;\n\t__le32 num_auth_encr_pair;\n} __packed;\n\nstruct ndis_80211_bssid_info {\n\tu8 bssid[ETH_ALEN];\n\tu8 pmkid[16];\n} __packed;\n\nstruct ndis_80211_pmkid {\n\t__le32 length;\n\t__le32 bssid_info_count;\n\tstruct ndis_80211_bssid_info bssid_info[];\n} __packed;\n\n \n#define CAP_MODE_80211A\t\t1\n#define CAP_MODE_80211B\t\t2\n#define CAP_MODE_80211G\t\t4\n#define CAP_MODE_MASK\t\t7\n\n#define WORK_LINK_UP\t\t0\n#define WORK_LINK_DOWN\t\t1\n#define WORK_SET_MULTICAST_LIST\t2\n\n#define RNDIS_WLAN_ALG_NONE\t0\n#define RNDIS_WLAN_ALG_WEP\t(1<<0)\n#define RNDIS_WLAN_ALG_TKIP\t(1<<1)\n#define RNDIS_WLAN_ALG_CCMP\t(1<<2)\n\n#define RNDIS_WLAN_NUM_KEYS\t\t4\n#define RNDIS_WLAN_KEY_MGMT_NONE\t0\n#define RNDIS_WLAN_KEY_MGMT_802_1X\t(1<<0)\n#define RNDIS_WLAN_KEY_MGMT_PSK\t\t(1<<1)\n\n#define COMMAND_BUFFER_SIZE\t(CONTROL_BUFFER_SIZE + sizeof(struct rndis_set))\n\nstatic const struct ieee80211_channel rndis_channels[] = {\n\t{ .center_freq = 2412 },\n\t{ .center_freq = 2417 },\n\t{ .center_freq = 2422 },\n\t{ .center_freq = 2427 },\n\t{ .center_freq = 2432 },\n\t{ .center_freq = 2437 },\n\t{ .center_freq = 2442 },\n\t{ .center_freq = 2447 },\n\t{ .center_freq = 2452 },\n\t{ .center_freq = 2457 },\n\t{ .center_freq = 2462 },\n\t{ .center_freq = 2467 },\n\t{ .center_freq = 2472 },\n\t{ .center_freq = 2484 },\n};\n\nstatic const struct ieee80211_rate rndis_rates[] = {\n\t{ .bitrate = 10 },\n\t{ .bitrate = 20, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 55, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 110, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 60 },\n\t{ .bitrate = 90 },\n\t{ .bitrate = 120 },\n\t{ .bitrate = 180 },\n\t{ .bitrate = 240 },\n\t{ .bitrate = 360 },\n\t{ .bitrate = 480 },\n\t{ .bitrate = 540 }\n};\n\nstatic const u32 rndis_cipher_suites[] = {\n\tWLAN_CIPHER_SUITE_WEP40,\n\tWLAN_CIPHER_SUITE_WEP104,\n\tWLAN_CIPHER_SUITE_TKIP,\n\tWLAN_CIPHER_SUITE_CCMP,\n};\n\nstruct rndis_wlan_encr_key {\n\tint len;\n\tu32 cipher;\n\tu8 material[32];\n\tu8 bssid[ETH_ALEN];\n\tbool pairwise;\n\tbool tx_key;\n};\n\n \nstruct rndis_wlan_private {\n\tstruct usbnet *usbdev;\n\n\tstruct wireless_dev wdev;\n\n\tstruct cfg80211_scan_request *scan_request;\n\n\tstruct workqueue_struct *workqueue;\n\tstruct delayed_work dev_poller_work;\n\tstruct delayed_work scan_work;\n\tstruct work_struct work;\n\tstruct mutex command_lock;\n\tunsigned long work_pending;\n\tint last_qual;\n\ts32 cqm_rssi_thold;\n\tu32 cqm_rssi_hyst;\n\tint last_cqm_event_rssi;\n\n\tstruct ieee80211_supported_band band;\n\tstruct ieee80211_channel channels[ARRAY_SIZE(rndis_channels)];\n\tstruct ieee80211_rate rates[ARRAY_SIZE(rndis_rates)];\n\tu32 cipher_suites[ARRAY_SIZE(rndis_cipher_suites)];\n\n\tint device_type;\n\tint caps;\n\tint multicast_size;\n\n\t \n\tchar param_country[4];\n\tint  param_frameburst;\n\tint  param_afterburner;\n\tint  param_power_save;\n\tint  param_power_output;\n\tint  param_roamtrigger;\n\tint  param_roamdelta;\n\tu32  param_workaround_interval;\n\n\t \n\tbool radio_on;\n\tint power_mode;\n\tint infra_mode;\n\tbool connected;\n\tu8 bssid[ETH_ALEN];\n\tu32 current_command_oid;\n\n\t \n\tu8 encr_tx_key_index;\n\tstruct rndis_wlan_encr_key encr_keys[RNDIS_WLAN_NUM_KEYS];\n\tint  wpa_version;\n\n\tu8 command_buffer[COMMAND_BUFFER_SIZE];\n};\n\n \nstatic int rndis_change_virtual_intf(struct wiphy *wiphy,\n\t\t\t\t\tstruct net_device *dev,\n\t\t\t\t\tenum nl80211_iftype type,\n\t\t\t\t\tstruct vif_params *params);\n\nstatic int rndis_scan(struct wiphy *wiphy,\n\t\t\tstruct cfg80211_scan_request *request);\n\nstatic int rndis_set_wiphy_params(struct wiphy *wiphy, u32 changed);\n\nstatic int rndis_set_tx_power(struct wiphy *wiphy,\n\t\t\t      struct wireless_dev *wdev,\n\t\t\t      enum nl80211_tx_power_setting type,\n\t\t\t      int mbm);\nstatic int rndis_get_tx_power(struct wiphy *wiphy,\n\t\t\t      struct wireless_dev *wdev,\n\t\t\t      int *dbm);\n\nstatic int rndis_connect(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\tstruct cfg80211_connect_params *sme);\n\nstatic int rndis_disconnect(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\tu16 reason_code);\n\nstatic int rndis_join_ibss(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t\tstruct cfg80211_ibss_params *params);\n\nstatic int rndis_leave_ibss(struct wiphy *wiphy, struct net_device *dev);\n\nstatic int rndis_add_key(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t int link_id,  u8 key_index, bool pairwise,\n\t\t\t const u8 *mac_addr, struct key_params *params);\n\nstatic int rndis_del_key(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t int link_id, u8 key_index, bool pairwise,\n\t\t\t const u8 *mac_addr);\n\nstatic int rndis_set_default_key(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t\t int link_id, u8 key_index, bool unicast,\n\t\t\t\t bool multicast);\n\nstatic int rndis_get_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     const u8 *mac, struct station_info *sinfo);\n\nstatic int rndis_dump_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       int idx, u8 *mac, struct station_info *sinfo);\n\nstatic int rndis_set_pmksa(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t\tstruct cfg80211_pmksa *pmksa);\n\nstatic int rndis_del_pmksa(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t\tstruct cfg80211_pmksa *pmksa);\n\nstatic int rndis_flush_pmksa(struct wiphy *wiphy, struct net_device *netdev);\n\nstatic int rndis_set_power_mgmt(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\tbool enabled, int timeout);\n\nstatic int rndis_set_cqm_rssi_config(struct wiphy *wiphy,\n\t\t\t\t\tstruct net_device *dev,\n\t\t\t\t\ts32 rssi_thold, u32 rssi_hyst);\n\nstatic const struct cfg80211_ops rndis_config_ops = {\n\t.change_virtual_intf = rndis_change_virtual_intf,\n\t.scan = rndis_scan,\n\t.set_wiphy_params = rndis_set_wiphy_params,\n\t.set_tx_power = rndis_set_tx_power,\n\t.get_tx_power = rndis_get_tx_power,\n\t.connect = rndis_connect,\n\t.disconnect = rndis_disconnect,\n\t.join_ibss = rndis_join_ibss,\n\t.leave_ibss = rndis_leave_ibss,\n\t.add_key = rndis_add_key,\n\t.del_key = rndis_del_key,\n\t.set_default_key = rndis_set_default_key,\n\t.get_station = rndis_get_station,\n\t.dump_station = rndis_dump_station,\n\t.set_pmksa = rndis_set_pmksa,\n\t.del_pmksa = rndis_del_pmksa,\n\t.flush_pmksa = rndis_flush_pmksa,\n\t.set_power_mgmt = rndis_set_power_mgmt,\n\t.set_cqm_rssi_config = rndis_set_cqm_rssi_config,\n};\n\nstatic void *rndis_wiphy_privid = &rndis_wiphy_privid;\n\n\nstatic struct rndis_wlan_private *get_rndis_wlan_priv(struct usbnet *dev)\n{\n\treturn (struct rndis_wlan_private *)dev->driver_priv;\n}\n\nstatic u32 get_bcm4320_power_dbm(struct rndis_wlan_private *priv)\n{\n\tswitch (priv->param_power_output) {\n\tdefault:\n\tcase 3:\n\t\treturn BCM4320_DEFAULT_TXPOWER_DBM_100;\n\tcase 2:\n\t\treturn BCM4320_DEFAULT_TXPOWER_DBM_75;\n\tcase 1:\n\t\treturn BCM4320_DEFAULT_TXPOWER_DBM_50;\n\tcase 0:\n\t\treturn BCM4320_DEFAULT_TXPOWER_DBM_25;\n\t}\n}\n\nstatic bool is_wpa_key(struct rndis_wlan_private *priv, u8 idx)\n{\n\tint cipher = priv->encr_keys[idx].cipher;\n\n\treturn (cipher == WLAN_CIPHER_SUITE_CCMP ||\n\t\tcipher == WLAN_CIPHER_SUITE_TKIP);\n}\n\nstatic int rndis_cipher_to_alg(u32 cipher)\n{\n\tswitch (cipher) {\n\tdefault:\n\t\treturn RNDIS_WLAN_ALG_NONE;\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\treturn RNDIS_WLAN_ALG_WEP;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\treturn RNDIS_WLAN_ALG_TKIP;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\treturn RNDIS_WLAN_ALG_CCMP;\n\t}\n}\n\nstatic int rndis_akm_suite_to_key_mgmt(u32 akm_suite)\n{\n\tswitch (akm_suite) {\n\tdefault:\n\t\treturn RNDIS_WLAN_KEY_MGMT_NONE;\n\tcase WLAN_AKM_SUITE_8021X:\n\t\treturn RNDIS_WLAN_KEY_MGMT_802_1X;\n\tcase WLAN_AKM_SUITE_PSK:\n\t\treturn RNDIS_WLAN_KEY_MGMT_PSK;\n\t}\n}\n\n#ifdef DEBUG\nstatic const char *oid_to_string(u32 oid)\n{\n\tswitch (oid) {\n#define OID_STR(oid) case oid: return(#oid)\n\t\t \n\t\tOID_STR(RNDIS_OID_802_3_PERMANENT_ADDRESS);\n\t\tOID_STR(RNDIS_OID_GEN_MAXIMUM_FRAME_SIZE);\n\t\tOID_STR(RNDIS_OID_GEN_CURRENT_PACKET_FILTER);\n\t\tOID_STR(RNDIS_OID_GEN_PHYSICAL_MEDIUM);\n\n\t\t \n\t\tOID_STR(RNDIS_OID_GEN_LINK_SPEED);\n\t\tOID_STR(RNDIS_OID_GEN_RNDIS_CONFIG_PARAMETER);\n\n\t\tOID_STR(RNDIS_OID_GEN_XMIT_OK);\n\t\tOID_STR(RNDIS_OID_GEN_RCV_OK);\n\t\tOID_STR(RNDIS_OID_GEN_XMIT_ERROR);\n\t\tOID_STR(RNDIS_OID_GEN_RCV_ERROR);\n\t\tOID_STR(RNDIS_OID_GEN_RCV_NO_BUFFER);\n\n\t\tOID_STR(RNDIS_OID_802_3_CURRENT_ADDRESS);\n\t\tOID_STR(RNDIS_OID_802_3_MULTICAST_LIST);\n\t\tOID_STR(RNDIS_OID_802_3_MAXIMUM_LIST_SIZE);\n\n\t\tOID_STR(RNDIS_OID_802_11_BSSID);\n\t\tOID_STR(RNDIS_OID_802_11_SSID);\n\t\tOID_STR(RNDIS_OID_802_11_INFRASTRUCTURE_MODE);\n\t\tOID_STR(RNDIS_OID_802_11_ADD_WEP);\n\t\tOID_STR(RNDIS_OID_802_11_REMOVE_WEP);\n\t\tOID_STR(RNDIS_OID_802_11_DISASSOCIATE);\n\t\tOID_STR(RNDIS_OID_802_11_AUTHENTICATION_MODE);\n\t\tOID_STR(RNDIS_OID_802_11_PRIVACY_FILTER);\n\t\tOID_STR(RNDIS_OID_802_11_BSSID_LIST_SCAN);\n\t\tOID_STR(RNDIS_OID_802_11_ENCRYPTION_STATUS);\n\t\tOID_STR(RNDIS_OID_802_11_ADD_KEY);\n\t\tOID_STR(RNDIS_OID_802_11_REMOVE_KEY);\n\t\tOID_STR(RNDIS_OID_802_11_ASSOCIATION_INFORMATION);\n\t\tOID_STR(RNDIS_OID_802_11_CAPABILITY);\n\t\tOID_STR(RNDIS_OID_802_11_PMKID);\n\t\tOID_STR(RNDIS_OID_802_11_NETWORK_TYPES_SUPPORTED);\n\t\tOID_STR(RNDIS_OID_802_11_NETWORK_TYPE_IN_USE);\n\t\tOID_STR(RNDIS_OID_802_11_TX_POWER_LEVEL);\n\t\tOID_STR(RNDIS_OID_802_11_RSSI);\n\t\tOID_STR(RNDIS_OID_802_11_RSSI_TRIGGER);\n\t\tOID_STR(RNDIS_OID_802_11_FRAGMENTATION_THRESHOLD);\n\t\tOID_STR(RNDIS_OID_802_11_RTS_THRESHOLD);\n\t\tOID_STR(RNDIS_OID_802_11_SUPPORTED_RATES);\n\t\tOID_STR(RNDIS_OID_802_11_CONFIGURATION);\n\t\tOID_STR(RNDIS_OID_802_11_POWER_MODE);\n\t\tOID_STR(RNDIS_OID_802_11_BSSID_LIST);\n#undef OID_STR\n\t}\n\n\treturn \"?\";\n}\n#else\nstatic const char *oid_to_string(u32 oid)\n{\n\treturn \"?\";\n}\n#endif\n\n \nstatic int rndis_error_status(__le32 rndis_status)\n{\n\tint ret = -EINVAL;\n\tswitch (le32_to_cpu(rndis_status)) {\n\tcase RNDIS_STATUS_SUCCESS:\n\t\tret = 0;\n\t\tbreak;\n\tcase RNDIS_STATUS_FAILURE:\n\tcase RNDIS_STATUS_INVALID_DATA:\n\t\tret = -EINVAL;\n\t\tbreak;\n\tcase RNDIS_STATUS_NOT_SUPPORTED:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\tcase RNDIS_STATUS_ADAPTER_NOT_READY:\n\tcase RNDIS_STATUS_ADAPTER_NOT_OPEN:\n\t\tret = -EBUSY;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int rndis_query_oid(struct usbnet *dev, u32 oid, void *data, int *len)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(dev);\n\tunion {\n\t\tvoid\t\t\t*buf;\n\t\tstruct rndis_msg_hdr\t*header;\n\t\tstruct rndis_query\t*get;\n\t\tstruct rndis_query_c\t*get_c;\n\t} u;\n\tint ret;\n\tsize_t buflen, resplen, respoffs, copylen;\n\n\tbuflen = *len + sizeof(*u.get);\n\tif (buflen < CONTROL_BUFFER_SIZE)\n\t\tbuflen = CONTROL_BUFFER_SIZE;\n\n\tif (buflen > COMMAND_BUFFER_SIZE) {\n\t\tu.buf = kmalloc(buflen, GFP_KERNEL);\n\t\tif (!u.buf)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tu.buf = priv->command_buffer;\n\t}\n\n\tmutex_lock(&priv->command_lock);\n\n\tmemset(u.get, 0, sizeof *u.get);\n\tu.get->msg_type = cpu_to_le32(RNDIS_MSG_QUERY);\n\tu.get->msg_len = cpu_to_le32(sizeof *u.get);\n\tu.get->oid = cpu_to_le32(oid);\n\n\tpriv->current_command_oid = oid;\n\tret = rndis_command(dev, u.header, buflen);\n\tpriv->current_command_oid = 0;\n\tif (ret < 0)\n\t\tnetdev_dbg(dev->net, \"%s(%s): rndis_command() failed, %d (%08x)\\n\",\n\t\t\t   __func__, oid_to_string(oid), ret,\n\t\t\t   le32_to_cpu(u.get_c->status));\n\n\tif (ret == 0) {\n\t\tresplen = le32_to_cpu(u.get_c->len);\n\t\trespoffs = le32_to_cpu(u.get_c->offset) + 8;\n\n\t\tif (respoffs > buflen) {\n\t\t\t \n\t\t\tnetdev_dbg(dev->net,\n\t\t\t\t   \"%s(%s): received invalid data offset: %zu > %zu\\n\",\n\t\t\t\t   __func__, oid_to_string(oid), respoffs, buflen);\n\n\t\t\tret = -EINVAL;\n\t\t\tgoto exit_unlock;\n\t\t}\n\n\t\tcopylen = min(resplen, buflen - respoffs);\n\n\t\tif (copylen > *len)\n\t\t\tcopylen = *len;\n\n\t\tmemcpy(data, u.buf + respoffs, copylen);\n\n\t\t*len = resplen;\n\n\t\tret = rndis_error_status(u.get_c->status);\n\t\tif (ret < 0)\n\t\t\tnetdev_dbg(dev->net, \"%s(%s): device returned error,  0x%08x (%d)\\n\",\n\t\t\t\t   __func__, oid_to_string(oid),\n\t\t\t\t   le32_to_cpu(u.get_c->status), ret);\n\t}\n\nexit_unlock:\n\tmutex_unlock(&priv->command_lock);\n\n\tif (u.buf != priv->command_buffer)\n\t\tkfree(u.buf);\n\treturn ret;\n}\n\nstatic int rndis_set_oid(struct usbnet *dev, u32 oid, const void *data,\n\t\t\t int len)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(dev);\n\tunion {\n\t\tvoid\t\t\t*buf;\n\t\tstruct rndis_msg_hdr\t*header;\n\t\tstruct rndis_set\t*set;\n\t\tstruct rndis_set_c\t*set_c;\n\t} u;\n\tint ret, buflen;\n\n\tbuflen = len + sizeof(*u.set);\n\tif (buflen < CONTROL_BUFFER_SIZE)\n\t\tbuflen = CONTROL_BUFFER_SIZE;\n\n\tif (buflen > COMMAND_BUFFER_SIZE) {\n\t\tu.buf = kmalloc(buflen, GFP_KERNEL);\n\t\tif (!u.buf)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tu.buf = priv->command_buffer;\n\t}\n\n\tmutex_lock(&priv->command_lock);\n\n\tmemset(u.set, 0, sizeof *u.set);\n\tu.set->msg_type = cpu_to_le32(RNDIS_MSG_SET);\n\tu.set->msg_len = cpu_to_le32(sizeof(*u.set) + len);\n\tu.set->oid = cpu_to_le32(oid);\n\tu.set->len = cpu_to_le32(len);\n\tu.set->offset = cpu_to_le32(sizeof(*u.set) - 8);\n\tu.set->handle = cpu_to_le32(0);\n\tmemcpy(u.buf + sizeof(*u.set), data, len);\n\n\tpriv->current_command_oid = oid;\n\tret = rndis_command(dev, u.header, buflen);\n\tpriv->current_command_oid = 0;\n\tif (ret < 0)\n\t\tnetdev_dbg(dev->net, \"%s(%s): rndis_command() failed, %d (%08x)\\n\",\n\t\t\t   __func__, oid_to_string(oid), ret,\n\t\t\t   le32_to_cpu(u.set_c->status));\n\n\tif (ret == 0) {\n\t\tret = rndis_error_status(u.set_c->status);\n\n\t\tif (ret < 0)\n\t\t\tnetdev_dbg(dev->net, \"%s(%s): device returned error, 0x%08x (%d)\\n\",\n\t\t\t\t   __func__, oid_to_string(oid),\n\t\t\t\t   le32_to_cpu(u.set_c->status), ret);\n\t}\n\n\tmutex_unlock(&priv->command_lock);\n\n\tif (u.buf != priv->command_buffer)\n\t\tkfree(u.buf);\n\treturn ret;\n}\n\nstatic int rndis_reset(struct usbnet *usbdev)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\tstruct rndis_reset *reset;\n\tint ret;\n\n\tmutex_lock(&priv->command_lock);\n\n\treset = (void *)priv->command_buffer;\n\tmemset(reset, 0, sizeof(*reset));\n\treset->msg_type = cpu_to_le32(RNDIS_MSG_RESET);\n\treset->msg_len = cpu_to_le32(sizeof(*reset));\n\tpriv->current_command_oid = 0;\n\tret = rndis_command(usbdev, (void *)reset, CONTROL_BUFFER_SIZE);\n\n\tmutex_unlock(&priv->command_lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\n \nstatic int rndis_set_config_parameter(struct usbnet *dev, char *param,\n\t\t\t\t\t\tint value_type, void *value)\n{\n\tstruct ndis_config_param *infobuf;\n\tint value_len, info_len, param_len, ret, i;\n\t__le16 *unibuf;\n\t__le32 *dst_value;\n\n\tif (value_type == 0)\n\t\tvalue_len = sizeof(__le32);\n\telse if (value_type == 2)\n\t\tvalue_len = strlen(value) * sizeof(__le16);\n\telse\n\t\treturn -EINVAL;\n\n\tparam_len = strlen(param) * sizeof(__le16);\n\tinfo_len = sizeof(*infobuf) + param_len + value_len;\n\n#ifdef DEBUG\n\tinfo_len += 12;\n#endif\n\tinfobuf = kmalloc(info_len, GFP_KERNEL);\n\tif (!infobuf)\n\t\treturn -ENOMEM;\n\n#ifdef DEBUG\n\tinfo_len -= 12;\n\t \n\tmemset(infobuf, 0xCC, info_len + 12);\n#endif\n\n\tif (value_type == 2)\n\t\tnetdev_dbg(dev->net, \"setting config parameter: %s, value: %s\\n\",\n\t\t\t   param, (u8 *)value);\n\telse\n\t\tnetdev_dbg(dev->net, \"setting config parameter: %s, value: %d\\n\",\n\t\t\t   param, *(u32 *)value);\n\n\tinfobuf->name_offs = cpu_to_le32(sizeof(*infobuf));\n\tinfobuf->name_length = cpu_to_le32(param_len);\n\tinfobuf->type = cpu_to_le32(value_type);\n\tinfobuf->value_offs = cpu_to_le32(sizeof(*infobuf) + param_len);\n\tinfobuf->value_length = cpu_to_le32(value_len);\n\n\t \n\tunibuf = (void *)infobuf + sizeof(*infobuf);\n\tfor (i = 0; i < param_len / sizeof(__le16); i++)\n\t\tunibuf[i] = cpu_to_le16(param[i]);\n\n\tif (value_type == 2) {\n\t\tunibuf = (void *)infobuf + sizeof(*infobuf) + param_len;\n\t\tfor (i = 0; i < value_len / sizeof(__le16); i++)\n\t\t\tunibuf[i] = cpu_to_le16(((u8 *)value)[i]);\n\t} else {\n\t\tdst_value = (void *)infobuf + sizeof(*infobuf) + param_len;\n\t\t*dst_value = cpu_to_le32(*(u32 *)value);\n\t}\n\n#ifdef DEBUG\n\tnetdev_dbg(dev->net, \"info buffer (len: %d)\\n\", info_len);\n\tfor (i = 0; i < info_len; i += 12) {\n\t\tu32 *tmp = (u32 *)((u8 *)infobuf + i);\n\t\tnetdev_dbg(dev->net, \"%08X:%08X:%08X\\n\",\n\t\t\t   cpu_to_be32(tmp[0]),\n\t\t\t   cpu_to_be32(tmp[1]),\n\t\t\t   cpu_to_be32(tmp[2]));\n\t}\n#endif\n\n\tret = rndis_set_oid(dev, RNDIS_OID_GEN_RNDIS_CONFIG_PARAMETER,\n\t\t\t\t\t\t\tinfobuf, info_len);\n\tif (ret != 0)\n\t\tnetdev_dbg(dev->net, \"setting rndis config parameter failed, %d\\n\",\n\t\t\t   ret);\n\n\tkfree(infobuf);\n\treturn ret;\n}\n\nstatic int rndis_set_config_parameter_str(struct usbnet *dev,\n\t\t\t\t\t\tchar *param, char *value)\n{\n\treturn rndis_set_config_parameter(dev, param, 2, value);\n}\n\n \nstatic int level_to_qual(int level)\n{\n\tint qual = 100 * (level - WL_NOISE) / (WL_SIGMAX - WL_NOISE);\n\treturn qual >= 0 ? (qual <= 100 ? qual : 100) : 0;\n}\n\n \nstatic int set_infra_mode(struct usbnet *usbdev, int mode);\nstatic void restore_keys(struct usbnet *usbdev);\nstatic int rndis_check_bssid_list(struct usbnet *usbdev, u8 *match_bssid,\n\t\t\t\t\tbool *matched);\n\nstatic int rndis_start_bssid_list_scan(struct usbnet *usbdev)\n{\n\t__le32 tmp;\n\n\t \n\ttmp = cpu_to_le32(1);\n\treturn rndis_set_oid(usbdev, RNDIS_OID_802_11_BSSID_LIST_SCAN, &tmp,\n\t\t\t\t\t\t\tsizeof(tmp));\n}\n\nstatic int set_essid(struct usbnet *usbdev, struct ndis_80211_ssid *ssid)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\tint ret;\n\n\tret = rndis_set_oid(usbdev, RNDIS_OID_802_11_SSID,\n\t\t\t    ssid, sizeof(*ssid));\n\tif (ret < 0) {\n\t\tnetdev_warn(usbdev->net, \"setting SSID failed (%08X)\\n\", ret);\n\t\treturn ret;\n\t}\n\tif (ret == 0) {\n\t\tpriv->radio_on = true;\n\t\tnetdev_dbg(usbdev->net, \"%s(): radio_on = true\\n\", __func__);\n\t}\n\n\treturn ret;\n}\n\nstatic int set_bssid(struct usbnet *usbdev, const u8 *bssid)\n{\n\tint ret;\n\n\tret = rndis_set_oid(usbdev, RNDIS_OID_802_11_BSSID,\n\t\t\t    bssid, ETH_ALEN);\n\tif (ret < 0) {\n\t\tnetdev_warn(usbdev->net, \"setting BSSID[%pM] failed (%08X)\\n\",\n\t\t\t    bssid, ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int clear_bssid(struct usbnet *usbdev)\n{\n\tstatic const u8 broadcast_mac[ETH_ALEN] = {\n\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n\t};\n\n\treturn set_bssid(usbdev, broadcast_mac);\n}\n\nstatic int get_bssid(struct usbnet *usbdev, u8 bssid[ETH_ALEN])\n{\n\tint ret, len;\n\n\tlen = ETH_ALEN;\n\tret = rndis_query_oid(usbdev, RNDIS_OID_802_11_BSSID,\n\t\t\t      bssid, &len);\n\n\tif (ret != 0)\n\t\teth_zero_addr(bssid);\n\n\treturn ret;\n}\n\nstatic int get_association_info(struct usbnet *usbdev,\n\t\t\tstruct ndis_80211_assoc_info *info, int len)\n{\n\treturn rndis_query_oid(usbdev,\n\t\t\tRNDIS_OID_802_11_ASSOCIATION_INFORMATION,\n\t\t\tinfo, &len);\n}\n\nstatic bool is_associated(struct usbnet *usbdev)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\tu8 bssid[ETH_ALEN];\n\n\tif (!priv->radio_on)\n\t\treturn false;\n\n\treturn (get_bssid(usbdev, bssid) == 0 && !is_zero_ether_addr(bssid));\n}\n\nstatic int disassociate(struct usbnet *usbdev, bool reset_ssid)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\tstruct ndis_80211_ssid ssid;\n\tint i, ret = 0;\n\n\tif (priv->radio_on) {\n\t\tret = rndis_set_oid(usbdev,\n\t\t\t\tRNDIS_OID_802_11_DISASSOCIATE,\n\t\t\t\tNULL, 0);\n\t\tif (ret == 0) {\n\t\t\tpriv->radio_on = false;\n\t\t\tnetdev_dbg(usbdev->net, \"%s(): radio_on = false\\n\",\n\t\t\t\t   __func__);\n\n\t\t\tif (reset_ssid)\n\t\t\t\tmsleep(100);\n\t\t}\n\t}\n\n\t \n\tif (reset_ssid) {\n\t\t \n\t\tset_infra_mode(usbdev, NDIS_80211_INFRA_INFRA);\n\n\t\tssid.length = cpu_to_le32(sizeof(ssid.essid));\n\t\tget_random_bytes(&ssid.essid[2], sizeof(ssid.essid)-2);\n\t\tssid.essid[0] = 0x1;\n\t\tssid.essid[1] = 0xff;\n\t\tfor (i = 2; i < sizeof(ssid.essid); i++)\n\t\t\tssid.essid[i] = 0x1 + (ssid.essid[i] * 0xfe / 0xff);\n\t\tret = set_essid(usbdev, &ssid);\n\t}\n\treturn ret;\n}\n\nstatic int set_auth_mode(struct usbnet *usbdev, u32 wpa_version,\n\t\t\t\tenum nl80211_auth_type auth_type, int keymgmt)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\t__le32 tmp;\n\tint auth_mode, ret;\n\n\tnetdev_dbg(usbdev->net, \"%s(): wpa_version=0x%x authalg=0x%x keymgmt=0x%x\\n\",\n\t\t   __func__, wpa_version, auth_type, keymgmt);\n\n\tif (wpa_version & NL80211_WPA_VERSION_2) {\n\t\tif (keymgmt & RNDIS_WLAN_KEY_MGMT_802_1X)\n\t\t\tauth_mode = NDIS_80211_AUTH_WPA2;\n\t\telse\n\t\t\tauth_mode = NDIS_80211_AUTH_WPA2_PSK;\n\t} else if (wpa_version & NL80211_WPA_VERSION_1) {\n\t\tif (keymgmt & RNDIS_WLAN_KEY_MGMT_802_1X)\n\t\t\tauth_mode = NDIS_80211_AUTH_WPA;\n\t\telse if (keymgmt & RNDIS_WLAN_KEY_MGMT_PSK)\n\t\t\tauth_mode = NDIS_80211_AUTH_WPA_PSK;\n\t\telse\n\t\t\tauth_mode = NDIS_80211_AUTH_WPA_NONE;\n\t} else if (auth_type == NL80211_AUTHTYPE_SHARED_KEY)\n\t\tauth_mode = NDIS_80211_AUTH_SHARED;\n\telse if (auth_type == NL80211_AUTHTYPE_OPEN_SYSTEM)\n\t\tauth_mode = NDIS_80211_AUTH_OPEN;\n\telse if (auth_type == NL80211_AUTHTYPE_AUTOMATIC)\n\t\tauth_mode = NDIS_80211_AUTH_AUTO_SWITCH;\n\telse\n\t\treturn -ENOTSUPP;\n\n\ttmp = cpu_to_le32(auth_mode);\n\tret = rndis_set_oid(usbdev,\n\t\t\t    RNDIS_OID_802_11_AUTHENTICATION_MODE,\n\t\t\t    &tmp, sizeof(tmp));\n\tif (ret != 0) {\n\t\tnetdev_warn(usbdev->net, \"setting auth mode failed (%08X)\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\tpriv->wpa_version = wpa_version;\n\n\treturn 0;\n}\n\nstatic int set_priv_filter(struct usbnet *usbdev)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\t__le32 tmp;\n\n\tnetdev_dbg(usbdev->net, \"%s(): wpa_version=0x%x\\n\",\n\t\t   __func__, priv->wpa_version);\n\n\tif (priv->wpa_version & NL80211_WPA_VERSION_2 ||\n\t    priv->wpa_version & NL80211_WPA_VERSION_1)\n\t\ttmp = cpu_to_le32(NDIS_80211_PRIV_8021X_WEP);\n\telse\n\t\ttmp = cpu_to_le32(NDIS_80211_PRIV_ACCEPT_ALL);\n\n\treturn rndis_set_oid(usbdev,\n\t\t\t     RNDIS_OID_802_11_PRIVACY_FILTER, &tmp,\n\t\t\t     sizeof(tmp));\n}\n\nstatic int set_encr_mode(struct usbnet *usbdev, int pairwise, int groupwise)\n{\n\t__le32 tmp;\n\tint encr_mode, ret;\n\n\tnetdev_dbg(usbdev->net, \"%s(): cipher_pair=0x%x cipher_group=0x%x\\n\",\n\t\t   __func__, pairwise, groupwise);\n\n\tif (pairwise & RNDIS_WLAN_ALG_CCMP)\n\t\tencr_mode = NDIS_80211_ENCR_CCMP_ENABLED;\n\telse if (pairwise & RNDIS_WLAN_ALG_TKIP)\n\t\tencr_mode = NDIS_80211_ENCR_TKIP_ENABLED;\n\telse if (pairwise & RNDIS_WLAN_ALG_WEP)\n\t\tencr_mode = NDIS_80211_ENCR_WEP_ENABLED;\n\telse if (groupwise & RNDIS_WLAN_ALG_CCMP)\n\t\tencr_mode = NDIS_80211_ENCR_CCMP_ENABLED;\n\telse if (groupwise & RNDIS_WLAN_ALG_TKIP)\n\t\tencr_mode = NDIS_80211_ENCR_TKIP_ENABLED;\n\telse\n\t\tencr_mode = NDIS_80211_ENCR_DISABLED;\n\n\ttmp = cpu_to_le32(encr_mode);\n\tret = rndis_set_oid(usbdev,\n\t\t\tRNDIS_OID_802_11_ENCRYPTION_STATUS, &tmp,\n\t\t\tsizeof(tmp));\n\tif (ret != 0) {\n\t\tnetdev_warn(usbdev->net, \"setting encr mode failed (%08X)\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int set_infra_mode(struct usbnet *usbdev, int mode)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\t__le32 tmp;\n\tint ret;\n\n\tnetdev_dbg(usbdev->net, \"%s(): infra_mode=0x%x\\n\",\n\t\t   __func__, priv->infra_mode);\n\n\ttmp = cpu_to_le32(mode);\n\tret = rndis_set_oid(usbdev,\n\t\t\t    RNDIS_OID_802_11_INFRASTRUCTURE_MODE,\n\t\t\t    &tmp, sizeof(tmp));\n\tif (ret != 0) {\n\t\tnetdev_warn(usbdev->net, \"setting infra mode failed (%08X)\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\t \n\trestore_keys(usbdev);\n\n\tpriv->infra_mode = mode;\n\treturn 0;\n}\n\nstatic int set_rts_threshold(struct usbnet *usbdev, u32 rts_threshold)\n{\n\t__le32 tmp;\n\n\tnetdev_dbg(usbdev->net, \"%s(): %i\\n\", __func__, rts_threshold);\n\n\tif (rts_threshold == -1 || rts_threshold > 2347)\n\t\trts_threshold = 2347;\n\n\ttmp = cpu_to_le32(rts_threshold);\n\treturn rndis_set_oid(usbdev,\n\t\t\t     RNDIS_OID_802_11_RTS_THRESHOLD,\n\t\t\t     &tmp, sizeof(tmp));\n}\n\nstatic int set_frag_threshold(struct usbnet *usbdev, u32 frag_threshold)\n{\n\t__le32 tmp;\n\n\tnetdev_dbg(usbdev->net, \"%s(): %i\\n\", __func__, frag_threshold);\n\n\tif (frag_threshold < 256 || frag_threshold > 2346)\n\t\tfrag_threshold = 2346;\n\n\ttmp = cpu_to_le32(frag_threshold);\n\treturn rndis_set_oid(usbdev,\n\t\t\tRNDIS_OID_802_11_FRAGMENTATION_THRESHOLD,\n\t\t\t&tmp, sizeof(tmp));\n}\n\nstatic void set_default_iw_params(struct usbnet *usbdev)\n{\n\tset_infra_mode(usbdev, NDIS_80211_INFRA_INFRA);\n\tset_auth_mode(usbdev, 0, NL80211_AUTHTYPE_OPEN_SYSTEM,\n\t\t\t\t\t\tRNDIS_WLAN_KEY_MGMT_NONE);\n\tset_priv_filter(usbdev);\n\tset_encr_mode(usbdev, RNDIS_WLAN_ALG_NONE, RNDIS_WLAN_ALG_NONE);\n}\n\nstatic int deauthenticate(struct usbnet *usbdev)\n{\n\tint ret;\n\n\tret = disassociate(usbdev, true);\n\tset_default_iw_params(usbdev);\n\treturn ret;\n}\n\nstatic int set_channel(struct usbnet *usbdev, int channel)\n{\n\tstruct ndis_80211_conf config;\n\tunsigned int dsconfig;\n\tint len, ret;\n\n\tnetdev_dbg(usbdev->net, \"%s(%d)\\n\", __func__, channel);\n\n\t \n\tif (is_associated(usbdev))\n\t\treturn 0;\n\n\tdsconfig = 1000 *\n\t\tieee80211_channel_to_frequency(channel, NL80211_BAND_2GHZ);\n\n\tlen = sizeof(config);\n\tret = rndis_query_oid(usbdev,\n\t\t\tRNDIS_OID_802_11_CONFIGURATION,\n\t\t\t&config, &len);\n\tif (ret < 0) {\n\t\tnetdev_dbg(usbdev->net, \"%s(): querying configuration failed\\n\",\n\t\t\t   __func__);\n\t\treturn ret;\n\t}\n\n\tconfig.ds_config = cpu_to_le32(dsconfig);\n\tret = rndis_set_oid(usbdev,\n\t\t\tRNDIS_OID_802_11_CONFIGURATION,\n\t\t\t&config, sizeof(config));\n\n\tnetdev_dbg(usbdev->net, \"%s(): %d -> %d\\n\", __func__, channel, ret);\n\n\treturn ret;\n}\n\nstatic struct ieee80211_channel *get_current_channel(struct usbnet *usbdev,\n\t\t\t\t\t\t     u32 *beacon_period)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\tstruct ieee80211_channel *channel;\n\tstruct ndis_80211_conf config;\n\tint len, ret;\n\n\t \n\tlen = sizeof(config);\n\tret = rndis_query_oid(usbdev,\n\t\t\tRNDIS_OID_802_11_CONFIGURATION,\n\t\t\t&config, &len);\n\tnetdev_dbg(usbdev->net, \"%s(): RNDIS_OID_802_11_CONFIGURATION -> %d\\n\",\n\t\t\t\t__func__, ret);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\tchannel = ieee80211_get_channel(priv->wdev.wiphy,\n\t\t\t\tKHZ_TO_MHZ(le32_to_cpu(config.ds_config)));\n\tif (!channel)\n\t\treturn NULL;\n\n\tif (beacon_period)\n\t\t*beacon_period = le32_to_cpu(config.beacon_period);\n\treturn channel;\n}\n\n \nstatic int add_wep_key(struct usbnet *usbdev, const u8 *key, int key_len,\n\t\t\t\t\t\t\t\tu8 index)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\tstruct ndis_80211_wep_key ndis_key;\n\tu32 cipher;\n\tint ret;\n\n\tnetdev_dbg(usbdev->net, \"%s(idx: %d, len: %d)\\n\",\n\t\t   __func__, index, key_len);\n\n\tif (index >= RNDIS_WLAN_NUM_KEYS)\n\t\treturn -EINVAL;\n\n\tif (key_len == 5)\n\t\tcipher = WLAN_CIPHER_SUITE_WEP40;\n\telse if (key_len == 13)\n\t\tcipher = WLAN_CIPHER_SUITE_WEP104;\n\telse\n\t\treturn -EINVAL;\n\n\tmemset(&ndis_key, 0, sizeof(ndis_key));\n\n\tndis_key.size = cpu_to_le32(sizeof(ndis_key));\n\tndis_key.length = cpu_to_le32(key_len);\n\tndis_key.index = cpu_to_le32(index);\n\tmemcpy(&ndis_key.material, key, key_len);\n\n\tif (index == priv->encr_tx_key_index) {\n\t\tndis_key.index |= NDIS_80211_ADDWEP_TRANSMIT_KEY;\n\t\tret = set_encr_mode(usbdev, RNDIS_WLAN_ALG_WEP,\n\t\t\t\t\t\t\tRNDIS_WLAN_ALG_NONE);\n\t\tif (ret)\n\t\t\tnetdev_warn(usbdev->net, \"encryption couldn't be enabled (%08X)\\n\",\n\t\t\t\t    ret);\n\t}\n\n\tret = rndis_set_oid(usbdev,\n\t\t\tRNDIS_OID_802_11_ADD_WEP, &ndis_key,\n\t\t\tsizeof(ndis_key));\n\tif (ret != 0) {\n\t\tnetdev_warn(usbdev->net, \"adding encryption key %d failed (%08X)\\n\",\n\t\t\t    index + 1, ret);\n\t\treturn ret;\n\t}\n\n\tpriv->encr_keys[index].len = key_len;\n\tpriv->encr_keys[index].cipher = cipher;\n\tmemcpy(&priv->encr_keys[index].material, key, key_len);\n\teth_broadcast_addr(priv->encr_keys[index].bssid);\n\n\treturn 0;\n}\n\nstatic int add_wpa_key(struct usbnet *usbdev, const u8 *key, int key_len,\n\t\t\tu8 index, const u8 *addr, const u8 *rx_seq,\n\t\t\tint seq_len, u32 cipher, __le32 flags)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\tstruct ndis_80211_key ndis_key;\n\tbool is_addr_ok;\n\tint ret;\n\n\tif (index >= RNDIS_WLAN_NUM_KEYS) {\n\t\tnetdev_dbg(usbdev->net, \"%s(): index out of range (%i)\\n\",\n\t\t\t   __func__, index);\n\t\treturn -EINVAL;\n\t}\n\tif (key_len > sizeof(ndis_key.material) || key_len < 0) {\n\t\tnetdev_dbg(usbdev->net, \"%s(): key length out of range (%i)\\n\",\n\t\t\t   __func__, key_len);\n\t\treturn -EINVAL;\n\t}\n\tif (flags & NDIS_80211_ADDKEY_SET_INIT_RECV_SEQ) {\n\t\tif (!rx_seq || seq_len <= 0) {\n\t\t\tnetdev_dbg(usbdev->net, \"%s(): recv seq flag without buffer\\n\",\n\t\t\t\t   __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (rx_seq && seq_len > sizeof(ndis_key.rsc)) {\n\t\t\tnetdev_dbg(usbdev->net, \"%s(): too big recv seq buffer\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tis_addr_ok = addr && !is_zero_ether_addr(addr) &&\n\t\t\t\t\t!is_broadcast_ether_addr(addr);\n\tif ((flags & NDIS_80211_ADDKEY_PAIRWISE_KEY) && !is_addr_ok) {\n\t\tnetdev_dbg(usbdev->net, \"%s(): pairwise but bssid invalid (%pM)\\n\",\n\t\t\t   __func__, addr);\n\t\treturn -EINVAL;\n\t}\n\n\tnetdev_dbg(usbdev->net, \"%s(%i): flags:%i%i%i\\n\",\n\t\t   __func__, index,\n\t\t   !!(flags & NDIS_80211_ADDKEY_TRANSMIT_KEY),\n\t\t   !!(flags & NDIS_80211_ADDKEY_PAIRWISE_KEY),\n\t\t   !!(flags & NDIS_80211_ADDKEY_SET_INIT_RECV_SEQ));\n\n\tmemset(&ndis_key, 0, sizeof(ndis_key));\n\n\tndis_key.size = cpu_to_le32(sizeof(ndis_key) -\n\t\t\t\tsizeof(ndis_key.material) + key_len);\n\tndis_key.length = cpu_to_le32(key_len);\n\tndis_key.index = cpu_to_le32(index) | flags;\n\n\tif (cipher == WLAN_CIPHER_SUITE_TKIP && key_len == 32) {\n\t\t \n\t\tmemcpy(ndis_key.material, key, 16);\n\t\tmemcpy(ndis_key.material + 16, key + 24, 8);\n\t\tmemcpy(ndis_key.material + 24, key + 16, 8);\n\t} else\n\t\tmemcpy(ndis_key.material, key, key_len);\n\n\tif (flags & NDIS_80211_ADDKEY_SET_INIT_RECV_SEQ)\n\t\tmemcpy(ndis_key.rsc, rx_seq, seq_len);\n\n\tif (flags & NDIS_80211_ADDKEY_PAIRWISE_KEY) {\n\t\t \n\t\tmemcpy(ndis_key.bssid, addr, ETH_ALEN);\n\t} else {\n\t\t \n\t\tif (priv->infra_mode == NDIS_80211_INFRA_ADHOC)\n\t\t\teth_broadcast_addr(ndis_key.bssid);\n\t\telse\n\t\t\tget_bssid(usbdev, ndis_key.bssid);\n\t}\n\n\tret = rndis_set_oid(usbdev,\n\t\t\tRNDIS_OID_802_11_ADD_KEY, &ndis_key,\n\t\t\tle32_to_cpu(ndis_key.size));\n\tnetdev_dbg(usbdev->net, \"%s(): RNDIS_OID_802_11_ADD_KEY -> %08X\\n\",\n\t\t   __func__, ret);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tmemset(&priv->encr_keys[index], 0, sizeof(priv->encr_keys[index]));\n\tpriv->encr_keys[index].len = key_len;\n\tpriv->encr_keys[index].cipher = cipher;\n\tmemcpy(&priv->encr_keys[index].material, key, key_len);\n\tif (flags & NDIS_80211_ADDKEY_PAIRWISE_KEY)\n\t\tmemcpy(&priv->encr_keys[index].bssid, ndis_key.bssid, ETH_ALEN);\n\telse\n\t\teth_broadcast_addr(priv->encr_keys[index].bssid);\n\n\tif (flags & NDIS_80211_ADDKEY_TRANSMIT_KEY)\n\t\tpriv->encr_tx_key_index = index;\n\n\treturn 0;\n}\n\nstatic int restore_key(struct usbnet *usbdev, u8 key_idx)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\tstruct rndis_wlan_encr_key key;\n\n\tif (is_wpa_key(priv, key_idx))\n\t\treturn 0;\n\n\tkey = priv->encr_keys[key_idx];\n\n\tnetdev_dbg(usbdev->net, \"%s(): %i:%i\\n\", __func__, key_idx, key.len);\n\n\tif (key.len == 0)\n\t\treturn 0;\n\n\treturn add_wep_key(usbdev, key.material, key.len, key_idx);\n}\n\nstatic void restore_keys(struct usbnet *usbdev)\n{\n\tint i;\n\n\tfor (i = 0; i < 4; i++)\n\t\trestore_key(usbdev, i);\n}\n\nstatic void clear_key(struct rndis_wlan_private *priv, u8 idx)\n{\n\tmemset(&priv->encr_keys[idx], 0, sizeof(priv->encr_keys[idx]));\n}\n\n \nstatic int remove_key(struct usbnet *usbdev, u8 index, const u8 *bssid)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\tstruct ndis_80211_remove_key remove_key;\n\t__le32 keyindex;\n\tbool is_wpa;\n\tint ret;\n\n\tif (index >= RNDIS_WLAN_NUM_KEYS)\n\t\treturn -ENOENT;\n\n\tif (priv->encr_keys[index].len == 0)\n\t\treturn 0;\n\n\tis_wpa = is_wpa_key(priv, index);\n\n\tnetdev_dbg(usbdev->net, \"%s(): %i:%s:%i\\n\",\n\t\t   __func__, index, is_wpa ? \"wpa\" : \"wep\",\n\t\t   priv->encr_keys[index].len);\n\n\tclear_key(priv, index);\n\n\tif (is_wpa) {\n\t\tremove_key.size = cpu_to_le32(sizeof(remove_key));\n\t\tremove_key.index = cpu_to_le32(index);\n\t\tif (bssid) {\n\t\t\t \n\t\t\tif (!is_broadcast_ether_addr(bssid))\n\t\t\t\tremove_key.index |=\n\t\t\t\t\tNDIS_80211_ADDKEY_PAIRWISE_KEY;\n\t\t\tmemcpy(remove_key.bssid, bssid,\n\t\t\t\t\tsizeof(remove_key.bssid));\n\t\t} else\n\t\t\tmemset(remove_key.bssid, 0xff,\n\t\t\t\t\t\tsizeof(remove_key.bssid));\n\n\t\tret = rndis_set_oid(usbdev,\n\t\t\t\tRNDIS_OID_802_11_REMOVE_KEY,\n\t\t\t\t&remove_key, sizeof(remove_key));\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t} else {\n\t\tkeyindex = cpu_to_le32(index);\n\t\tret = rndis_set_oid(usbdev,\n\t\t\t\tRNDIS_OID_802_11_REMOVE_WEP,\n\t\t\t\t&keyindex, sizeof(keyindex));\n\t\tif (ret != 0) {\n\t\t\tnetdev_warn(usbdev->net,\n\t\t\t\t    \"removing encryption key %d failed (%08X)\\n\",\n\t\t\t\t    index, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (index == priv->encr_tx_key_index)\n\t\tset_encr_mode(usbdev, RNDIS_WLAN_ALG_NONE, RNDIS_WLAN_ALG_NONE);\n\n\treturn 0;\n}\n\nstatic void set_multicast_list(struct usbnet *usbdev)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\tstruct netdev_hw_addr *ha;\n\t__le32 filter, basefilter;\n\tint ret;\n\tchar *mc_addrs = NULL;\n\tint mc_count;\n\n\tbasefilter = filter = cpu_to_le32(RNDIS_PACKET_TYPE_DIRECTED |\n\t\t\t\t\t  RNDIS_PACKET_TYPE_BROADCAST);\n\n\tif (usbdev->net->flags & IFF_PROMISC) {\n\t\tfilter |= cpu_to_le32(RNDIS_PACKET_TYPE_PROMISCUOUS |\n\t\t\t\t      RNDIS_PACKET_TYPE_ALL_LOCAL);\n\t} else if (usbdev->net->flags & IFF_ALLMULTI) {\n\t\tfilter |= cpu_to_le32(RNDIS_PACKET_TYPE_ALL_MULTICAST);\n\t}\n\n\tif (filter != basefilter)\n\t\tgoto set_filter;\n\n\t \n\tnetif_addr_lock_bh(usbdev->net);\n\tmc_count = netdev_mc_count(usbdev->net);\n\tif (mc_count > priv->multicast_size) {\n\t\tfilter |= cpu_to_le32(RNDIS_PACKET_TYPE_ALL_MULTICAST);\n\t} else if (mc_count) {\n\t\tint i = 0;\n\n\t\tmc_addrs = kmalloc_array(mc_count, ETH_ALEN, GFP_ATOMIC);\n\t\tif (!mc_addrs) {\n\t\t\tnetif_addr_unlock_bh(usbdev->net);\n\t\t\treturn;\n\t\t}\n\n\t\tnetdev_for_each_mc_addr(ha, usbdev->net)\n\t\t\tmemcpy(mc_addrs + i++ * ETH_ALEN,\n\t\t\t       ha->addr, ETH_ALEN);\n\t}\n\tnetif_addr_unlock_bh(usbdev->net);\n\n\tif (filter != basefilter)\n\t\tgoto set_filter;\n\n\tif (mc_count) {\n\t\tret = rndis_set_oid(usbdev,\n\t\t\t\tRNDIS_OID_802_3_MULTICAST_LIST,\n\t\t\t\tmc_addrs, mc_count * ETH_ALEN);\n\t\tkfree(mc_addrs);\n\t\tif (ret == 0)\n\t\t\tfilter |= cpu_to_le32(RNDIS_PACKET_TYPE_MULTICAST);\n\t\telse\n\t\t\tfilter |= cpu_to_le32(RNDIS_PACKET_TYPE_ALL_MULTICAST);\n\n\t\tnetdev_dbg(usbdev->net, \"RNDIS_OID_802_3_MULTICAST_LIST(%d, max: %d) -> %d\\n\",\n\t\t\t   mc_count, priv->multicast_size, ret);\n\t}\n\nset_filter:\n\tret = rndis_set_oid(usbdev, RNDIS_OID_GEN_CURRENT_PACKET_FILTER, &filter,\n\t\t\t\t\t\t\tsizeof(filter));\n\tif (ret < 0) {\n\t\tnetdev_warn(usbdev->net, \"couldn't set packet filter: %08x\\n\",\n\t\t\t    le32_to_cpu(filter));\n\t}\n\n\tnetdev_dbg(usbdev->net, \"RNDIS_OID_GEN_CURRENT_PACKET_FILTER(%08x) -> %d\\n\",\n\t\t   le32_to_cpu(filter), ret);\n}\n\n#ifdef DEBUG\nstatic void debug_print_pmkids(struct usbnet *usbdev,\n\t\t\t\tstruct ndis_80211_pmkid *pmkids,\n\t\t\t\tconst char *func_str)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\tint i, len, count, max_pmkids, entry_len;\n\n\tmax_pmkids = priv->wdev.wiphy->max_num_pmkids;\n\tlen = le32_to_cpu(pmkids->length);\n\tcount = le32_to_cpu(pmkids->bssid_info_count);\n\n\tentry_len = (count > 0) ? (len - sizeof(*pmkids)) / count : -1;\n\n\tnetdev_dbg(usbdev->net, \"%s(): %d PMKIDs (data len: %d, entry len: \"\n\t\t\t\t\"%d)\\n\", func_str, count, len, entry_len);\n\n\tif (count > max_pmkids)\n\t\tcount = max_pmkids;\n\n\tfor (i = 0; i < count; i++) {\n\t\tu32 *tmp = (u32 *)pmkids->bssid_info[i].pmkid;\n\n\t\tnetdev_dbg(usbdev->net, \"%s():  bssid: %pM, \"\n\t\t\t\t\"pmkid: %08X:%08X:%08X:%08X\\n\",\n\t\t\t\tfunc_str, pmkids->bssid_info[i].bssid,\n\t\t\t\tcpu_to_be32(tmp[0]), cpu_to_be32(tmp[1]),\n\t\t\t\tcpu_to_be32(tmp[2]), cpu_to_be32(tmp[3]));\n\t}\n}\n#else\nstatic void debug_print_pmkids(struct usbnet *usbdev,\n\t\t\t\tstruct ndis_80211_pmkid *pmkids,\n\t\t\t\tconst char *func_str)\n{\n\treturn;\n}\n#endif\n\nstatic struct ndis_80211_pmkid *get_device_pmkids(struct usbnet *usbdev)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\tstruct ndis_80211_pmkid *pmkids;\n\tint len, ret, max_pmkids;\n\n\tmax_pmkids = priv->wdev.wiphy->max_num_pmkids;\n\tlen = struct_size(pmkids, bssid_info, max_pmkids);\n\n\tpmkids = kzalloc(len, GFP_KERNEL);\n\tif (!pmkids)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpmkids->length = cpu_to_le32(len);\n\tpmkids->bssid_info_count = cpu_to_le32(max_pmkids);\n\n\tret = rndis_query_oid(usbdev, RNDIS_OID_802_11_PMKID,\n\t\t\tpmkids, &len);\n\tif (ret < 0) {\n\t\tnetdev_dbg(usbdev->net, \"%s(): RNDIS_OID_802_11_PMKID(%d, %d)\"\n\t\t\t\t\" -> %d\\n\", __func__, len, max_pmkids, ret);\n\n\t\tkfree(pmkids);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (le32_to_cpu(pmkids->bssid_info_count) > max_pmkids)\n\t\tpmkids->bssid_info_count = cpu_to_le32(max_pmkids);\n\n\tdebug_print_pmkids(usbdev, pmkids, __func__);\n\n\treturn pmkids;\n}\n\nstatic int set_device_pmkids(struct usbnet *usbdev,\n\t\t\t\tstruct ndis_80211_pmkid *pmkids)\n{\n\tint ret, len, num_pmkids;\n\n\tnum_pmkids = le32_to_cpu(pmkids->bssid_info_count);\n\tlen = struct_size(pmkids, bssid_info, num_pmkids);\n\tpmkids->length = cpu_to_le32(len);\n\n\tdebug_print_pmkids(usbdev, pmkids, __func__);\n\n\tret = rndis_set_oid(usbdev, RNDIS_OID_802_11_PMKID, pmkids,\n\t\t\t    le32_to_cpu(pmkids->length));\n\tif (ret < 0) {\n\t\tnetdev_dbg(usbdev->net, \"%s(): RNDIS_OID_802_11_PMKID(%d, %d) -> %d\"\n\t\t\t\t\"\\n\", __func__, len, num_pmkids, ret);\n\t}\n\n\tkfree(pmkids);\n\treturn ret;\n}\n\nstatic struct ndis_80211_pmkid *remove_pmkid(struct usbnet *usbdev,\n\t\t\t\t\t\tstruct ndis_80211_pmkid *pmkids,\n\t\t\t\t\t\tstruct cfg80211_pmksa *pmksa,\n\t\t\t\t\t\tint max_pmkids)\n{\n\tint i, err;\n\tunsigned int count;\n\n\tcount = le32_to_cpu(pmkids->bssid_info_count);\n\n\tif (count > max_pmkids)\n\t\tcount = max_pmkids;\n\n\tfor (i = 0; i < count; i++)\n\t\tif (ether_addr_equal(pmkids->bssid_info[i].bssid,\n\t\t\t\t     pmksa->bssid))\n\t\t\tbreak;\n\n\t \n\tif (i == count) {\n\t\tnetdev_dbg(usbdev->net, \"%s(): bssid not found (%pM)\\n\",\n\t\t\t\t\t__func__, pmksa->bssid);\n\t\terr = -ENOENT;\n\t\tgoto error;\n\t}\n\n\tfor (; i + 1 < count; i++)\n\t\tpmkids->bssid_info[i] = pmkids->bssid_info[i + 1];\n\n\tcount--;\n\tpmkids->length = cpu_to_le32(struct_size(pmkids, bssid_info, count));\n\tpmkids->bssid_info_count = cpu_to_le32(count);\n\n\treturn pmkids;\nerror:\n\tkfree(pmkids);\n\treturn ERR_PTR(err);\n}\n\nstatic struct ndis_80211_pmkid *update_pmkid(struct usbnet *usbdev,\n\t\t\t\t\t\tstruct ndis_80211_pmkid *pmkids,\n\t\t\t\t\t\tstruct cfg80211_pmksa *pmksa,\n\t\t\t\t\t\tint max_pmkids)\n{\n\tstruct ndis_80211_pmkid *new_pmkids;\n\tint i, err, newlen;\n\tunsigned int count;\n\n\tcount = le32_to_cpu(pmkids->bssid_info_count);\n\n\tif (count > max_pmkids)\n\t\tcount = max_pmkids;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tif (!ether_addr_equal(pmkids->bssid_info[i].bssid,\n\t\t\t\t      pmksa->bssid))\n\t\t\tcontinue;\n\n\t\tmemcpy(pmkids->bssid_info[i].pmkid, pmksa->pmkid,\n\t\t\t\t\t\t\t\tWLAN_PMKID_LEN);\n\n\t\treturn pmkids;\n\t}\n\n\t \n\tif (i == max_pmkids) {\n\t\tnetdev_dbg(usbdev->net, \"%s(): out of space\\n\", __func__);\n\t\terr = -ENOSPC;\n\t\tgoto error;\n\t}\n\n\t \n\tnewlen = struct_size(pmkids, bssid_info, count + 1);\n\n\tnew_pmkids = krealloc(pmkids, newlen, GFP_KERNEL);\n\tif (!new_pmkids) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tpmkids = new_pmkids;\n\n\tpmkids->length = cpu_to_le32(newlen);\n\tpmkids->bssid_info_count = cpu_to_le32(count + 1);\n\n\tmemcpy(pmkids->bssid_info[count].bssid, pmksa->bssid, ETH_ALEN);\n\tmemcpy(pmkids->bssid_info[count].pmkid, pmksa->pmkid, WLAN_PMKID_LEN);\n\n\treturn pmkids;\nerror:\n\tkfree(pmkids);\n\treturn ERR_PTR(err);\n}\n\n \nstatic int rndis_change_virtual_intf(struct wiphy *wiphy,\n\t\t\t\t\tstruct net_device *dev,\n\t\t\t\t\tenum nl80211_iftype type,\n\t\t\t\t\tstruct vif_params *params)\n{\n\tstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\n\tstruct usbnet *usbdev = priv->usbdev;\n\tint mode;\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tmode = NDIS_80211_INFRA_ADHOC;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tmode = NDIS_80211_INFRA_INFRA;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->wdev.iftype = type;\n\n\treturn set_infra_mode(usbdev, mode);\n}\n\nstatic int rndis_set_wiphy_params(struct wiphy *wiphy, u32 changed)\n{\n\tstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\n\tstruct usbnet *usbdev = priv->usbdev;\n\tint err;\n\n\tif (changed & WIPHY_PARAM_FRAG_THRESHOLD) {\n\t\terr = set_frag_threshold(usbdev, wiphy->frag_threshold);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (changed & WIPHY_PARAM_RTS_THRESHOLD) {\n\t\terr = set_rts_threshold(usbdev, wiphy->rts_threshold);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int rndis_set_tx_power(struct wiphy *wiphy,\n\t\t\t      struct wireless_dev *wdev,\n\t\t\t      enum nl80211_tx_power_setting type,\n\t\t\t      int mbm)\n{\n\tstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\n\tstruct usbnet *usbdev = priv->usbdev;\n\n\tnetdev_dbg(usbdev->net, \"%s(): type:0x%x mbm:%i\\n\",\n\t\t   __func__, type, mbm);\n\n\tif (mbm < 0 || (mbm % 100))\n\t\treturn -ENOTSUPP;\n\n\t \n\tif (type == NL80211_TX_POWER_AUTOMATIC ||\n\t    MBM_TO_DBM(mbm) == get_bcm4320_power_dbm(priv)) {\n\t\tif (!priv->radio_on)\n\t\t\tdisassociate(usbdev, true);  \n\n\t\treturn 0;\n\t}\n\n\treturn -ENOTSUPP;\n}\n\nstatic int rndis_get_tx_power(struct wiphy *wiphy,\n\t\t\t      struct wireless_dev *wdev,\n\t\t\t      int *dbm)\n{\n\tstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\n\tstruct usbnet *usbdev = priv->usbdev;\n\n\t*dbm = get_bcm4320_power_dbm(priv);\n\n\tnetdev_dbg(usbdev->net, \"%s(): dbm:%i\\n\", __func__, *dbm);\n\n\treturn 0;\n}\n\n#define SCAN_DELAY_JIFFIES (6 * HZ)\nstatic int rndis_scan(struct wiphy *wiphy,\n\t\t\tstruct cfg80211_scan_request *request)\n{\n\tstruct net_device *dev = request->wdev->netdev;\n\tstruct usbnet *usbdev = netdev_priv(dev);\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\tint ret;\n\tint delay = SCAN_DELAY_JIFFIES;\n\n\tnetdev_dbg(usbdev->net, \"cfg80211.scan\\n\");\n\n\t \n\trndis_check_bssid_list(usbdev, NULL, NULL);\n\n\tif (priv->scan_request && priv->scan_request != request)\n\t\treturn -EBUSY;\n\n\tpriv->scan_request = request;\n\n\tret = rndis_start_bssid_list_scan(usbdev);\n\tif (ret == 0) {\n\t\tif (priv->device_type == RNDIS_BCM4320A)\n\t\t\tdelay = HZ;\n\n\t\t \n\t\tqueue_delayed_work(priv->workqueue, &priv->scan_work, delay);\n\t}\n\n\treturn ret;\n}\n\nstatic bool rndis_bss_info_update(struct usbnet *usbdev,\n\t\t\t\t  struct ndis_80211_bssid_ex *bssid)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\tstruct ieee80211_channel *channel;\n\tstruct cfg80211_bss *bss;\n\ts32 signal;\n\tu64 timestamp;\n\tu16 capability;\n\tu16 beacon_interval;\n\tstruct ndis_80211_fixed_ies *fixed;\n\tint ie_len, bssid_len;\n\tu8 *ie;\n\n\tnetdev_dbg(usbdev->net, \" found bssid: '%.32s' [%pM], len: %d\\n\",\n\t\t   bssid->ssid.essid, bssid->mac, le32_to_cpu(bssid->length));\n\n\t \n\tbssid_len = le32_to_cpu(bssid->length);\n\n\tif (bssid_len < sizeof(struct ndis_80211_bssid_ex) +\n\t\t\tsizeof(struct ndis_80211_fixed_ies))\n\t\treturn false;\n\n\tfixed = (struct ndis_80211_fixed_ies *)bssid->ies;\n\n\tie = (void *)(bssid->ies + sizeof(struct ndis_80211_fixed_ies));\n\tie_len = min(bssid_len - (int)sizeof(*bssid),\n\t\t\t\t\t(int)le32_to_cpu(bssid->ie_length));\n\tie_len -= sizeof(struct ndis_80211_fixed_ies);\n\tif (ie_len < 0)\n\t\treturn false;\n\n\t \n\tchannel = ieee80211_get_channel(priv->wdev.wiphy,\n\t\t\tKHZ_TO_MHZ(le32_to_cpu(bssid->config.ds_config)));\n\tif (!channel)\n\t\treturn false;\n\n\tsignal = level_to_qual(le32_to_cpu(bssid->rssi));\n\ttimestamp = le64_to_cpu(*(__le64 *)fixed->timestamp);\n\tcapability = le16_to_cpu(fixed->capabilities);\n\tbeacon_interval = le16_to_cpu(fixed->beacon_interval);\n\n\tbss = cfg80211_inform_bss(priv->wdev.wiphy, channel,\n\t\t\t\t  CFG80211_BSS_FTYPE_UNKNOWN, bssid->mac,\n\t\t\t\t  timestamp, capability, beacon_interval,\n\t\t\t\t  ie, ie_len, signal, GFP_KERNEL);\n\tcfg80211_put_bss(priv->wdev.wiphy, bss);\n\n\treturn (bss != NULL);\n}\n\nstatic struct ndis_80211_bssid_ex *next_bssid_list_item(\n\t\t\t\t\tstruct ndis_80211_bssid_ex *bssid,\n\t\t\t\t\tint *bssid_len, void *buf, int len)\n{\n\tvoid *buf_end, *bssid_end;\n\n\tbuf_end = (char *)buf + len;\n\tbssid_end = (char *)bssid + *bssid_len;\n\n\tif ((int)(buf_end - bssid_end) < sizeof(bssid->length)) {\n\t\t*bssid_len = 0;\n\t\treturn NULL;\n\t} else {\n\t\tbssid = (void *)((char *)bssid + *bssid_len);\n\t\t*bssid_len = le32_to_cpu(bssid->length);\n\t\treturn bssid;\n\t}\n}\n\nstatic bool check_bssid_list_item(struct ndis_80211_bssid_ex *bssid,\n\t\t\t\t  int bssid_len, void *buf, int len)\n{\n\tvoid *buf_end, *bssid_end;\n\n\tif (!bssid || bssid_len <= 0 || bssid_len > len)\n\t\treturn false;\n\n\tbuf_end = (char *)buf + len;\n\tbssid_end = (char *)bssid + bssid_len;\n\n\treturn (int)(buf_end - bssid_end) >= 0 && (int)(bssid_end - buf) >= 0;\n}\n\nstatic int rndis_check_bssid_list(struct usbnet *usbdev, u8 *match_bssid,\n\t\t\t\t\tbool *matched)\n{\n\tvoid *buf = NULL;\n\tstruct ndis_80211_bssid_list_ex *bssid_list;\n\tstruct ndis_80211_bssid_ex *bssid;\n\tint ret = -EINVAL, len, count, bssid_len, real_count, new_len;\n\n\tnetdev_dbg(usbdev->net, \"%s()\\n\", __func__);\n\n\tlen = CONTROL_BUFFER_SIZE;\nresize_buf:\n\tbuf = kzalloc(len, GFP_KERNEL);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tnew_len = len;\n\tret = rndis_query_oid(usbdev, RNDIS_OID_802_11_BSSID_LIST,\n\t\t\t      buf, &new_len);\n\tif (ret != 0 || new_len < sizeof(struct ndis_80211_bssid_list_ex))\n\t\tgoto out;\n\n\tif (new_len > len) {\n\t\tlen = new_len;\n\t\tkfree(buf);\n\t\tgoto resize_buf;\n\t}\n\n\tlen = new_len;\n\n\tbssid_list = buf;\n\tcount = le32_to_cpu(bssid_list->num_items);\n\treal_count = 0;\n\tnetdev_dbg(usbdev->net, \"%s(): buflen: %d\\n\", __func__, len);\n\n\tbssid_len = 0;\n\tbssid = next_bssid_list_item((void *)bssid_list->bssid_data,\n\t\t\t\t     &bssid_len, buf, len);\n\n\t \n\twhile (check_bssid_list_item(bssid, bssid_len, buf, len)) {\n\t\tif (rndis_bss_info_update(usbdev, bssid) && match_bssid &&\n\t\t    matched) {\n\t\t\tif (ether_addr_equal(bssid->mac, match_bssid))\n\t\t\t\t*matched = true;\n\t\t}\n\n\t\treal_count++;\n\t\tbssid = next_bssid_list_item(bssid, &bssid_len, buf, len);\n\t}\n\n\tnetdev_dbg(usbdev->net, \"%s(): num_items from device: %d, really found:\"\n\t\t\t\t\" %d\\n\", __func__, count, real_count);\n\nout:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic void rndis_get_scan_results(struct work_struct *work)\n{\n\tstruct rndis_wlan_private *priv =\n\t\tcontainer_of(work, struct rndis_wlan_private, scan_work.work);\n\tstruct usbnet *usbdev = priv->usbdev;\n\tstruct cfg80211_scan_info info = {};\n\tint ret;\n\n\tnetdev_dbg(usbdev->net, \"get_scan_results\\n\");\n\n\tif (!priv->scan_request)\n\t\treturn;\n\n\tret = rndis_check_bssid_list(usbdev, NULL, NULL);\n\n\tinfo.aborted = ret < 0;\n\tcfg80211_scan_done(priv->scan_request, &info);\n\n\tpriv->scan_request = NULL;\n}\n\nstatic int rndis_connect(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t\tstruct cfg80211_connect_params *sme)\n{\n\tstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\n\tstruct usbnet *usbdev = priv->usbdev;\n\tstruct ieee80211_channel *channel = sme->channel;\n\tstruct ndis_80211_ssid ssid;\n\tint pairwise = RNDIS_WLAN_ALG_NONE;\n\tint groupwise = RNDIS_WLAN_ALG_NONE;\n\tint keymgmt = RNDIS_WLAN_KEY_MGMT_NONE;\n\tint length, i, ret, chan = -1;\n\n\tif (channel)\n\t\tchan = ieee80211_frequency_to_channel(channel->center_freq);\n\n\tgroupwise = rndis_cipher_to_alg(sme->crypto.cipher_group);\n\tfor (i = 0; i < sme->crypto.n_ciphers_pairwise; i++)\n\t\tpairwise |=\n\t\t\trndis_cipher_to_alg(sme->crypto.ciphers_pairwise[i]);\n\n\tif (sme->crypto.n_ciphers_pairwise > 0 &&\n\t\t\tpairwise == RNDIS_WLAN_ALG_NONE) {\n\t\tnetdev_err(usbdev->net, \"Unsupported pairwise cipher\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tfor (i = 0; i < sme->crypto.n_akm_suites; i++)\n\t\tkeymgmt |=\n\t\t\trndis_akm_suite_to_key_mgmt(sme->crypto.akm_suites[i]);\n\n\tif (sme->crypto.n_akm_suites > 0 &&\n\t\t\tkeymgmt == RNDIS_WLAN_KEY_MGMT_NONE) {\n\t\tnetdev_err(usbdev->net, \"Invalid keymgmt\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tnetdev_dbg(usbdev->net, \"cfg80211.connect('%.32s':[%pM]:%d:[%d,0x%x:0x%x]:[0x%x:0x%x]:0x%x)\\n\",\n\t\t   sme->ssid, sme->bssid, chan,\n\t\t   sme->privacy, sme->crypto.wpa_versions, sme->auth_type,\n\t\t   groupwise, pairwise, keymgmt);\n\n\tif (is_associated(usbdev))\n\t\tdisassociate(usbdev, false);\n\n\tret = set_infra_mode(usbdev, NDIS_80211_INFRA_INFRA);\n\tif (ret < 0) {\n\t\tnetdev_dbg(usbdev->net, \"connect: set_infra_mode failed, %d\\n\",\n\t\t\t   ret);\n\t\tgoto err_turn_radio_on;\n\t}\n\n\tret = set_auth_mode(usbdev, sme->crypto.wpa_versions, sme->auth_type,\n\t\t\t\t\t\t\t\tkeymgmt);\n\tif (ret < 0) {\n\t\tnetdev_dbg(usbdev->net, \"connect: set_auth_mode failed, %d\\n\",\n\t\t\t   ret);\n\t\tgoto err_turn_radio_on;\n\t}\n\n\tset_priv_filter(usbdev);\n\n\tret = set_encr_mode(usbdev, pairwise, groupwise);\n\tif (ret < 0) {\n\t\tnetdev_dbg(usbdev->net, \"connect: set_encr_mode failed, %d\\n\",\n\t\t\t   ret);\n\t\tgoto err_turn_radio_on;\n\t}\n\n\tif (channel) {\n\t\tret = set_channel(usbdev, chan);\n\t\tif (ret < 0) {\n\t\t\tnetdev_dbg(usbdev->net, \"connect: set_channel failed, %d\\n\",\n\t\t\t\t   ret);\n\t\t\tgoto err_turn_radio_on;\n\t\t}\n\t}\n\n\tif (sme->key && ((groupwise | pairwise) & RNDIS_WLAN_ALG_WEP)) {\n\t\tpriv->encr_tx_key_index = sme->key_idx;\n\t\tret = add_wep_key(usbdev, sme->key, sme->key_len, sme->key_idx);\n\t\tif (ret < 0) {\n\t\t\tnetdev_dbg(usbdev->net, \"connect: add_wep_key failed, %d (%d, %d)\\n\",\n\t\t\t\t   ret, sme->key_len, sme->key_idx);\n\t\t\tgoto err_turn_radio_on;\n\t\t}\n\t}\n\n\tif (sme->bssid && !is_zero_ether_addr(sme->bssid) &&\n\t\t\t\t!is_broadcast_ether_addr(sme->bssid)) {\n\t\tret = set_bssid(usbdev, sme->bssid);\n\t\tif (ret < 0) {\n\t\t\tnetdev_dbg(usbdev->net, \"connect: set_bssid failed, %d\\n\",\n\t\t\t\t   ret);\n\t\t\tgoto err_turn_radio_on;\n\t\t}\n\t} else\n\t\tclear_bssid(usbdev);\n\n\tlength = sme->ssid_len;\n\tif (length > NDIS_802_11_LENGTH_SSID)\n\t\tlength = NDIS_802_11_LENGTH_SSID;\n\n\tmemset(&ssid, 0, sizeof(ssid));\n\tssid.length = cpu_to_le32(length);\n\tmemcpy(ssid.essid, sme->ssid, length);\n\n\t \n\tusbnet_pause_rx(usbdev);\n\tusbnet_purge_paused_rxq(usbdev);\n\n\tret = set_essid(usbdev, &ssid);\n\tif (ret < 0)\n\t\tnetdev_dbg(usbdev->net, \"connect: set_essid failed, %d\\n\", ret);\n\treturn ret;\n\nerr_turn_radio_on:\n\tdisassociate(usbdev, true);\n\n\treturn ret;\n}\n\nstatic int rndis_disconnect(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t\t\t\t\tu16 reason_code)\n{\n\tstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\n\tstruct usbnet *usbdev = priv->usbdev;\n\n\tnetdev_dbg(usbdev->net, \"cfg80211.disconnect(%d)\\n\", reason_code);\n\n\tpriv->connected = false;\n\teth_zero_addr(priv->bssid);\n\n\treturn deauthenticate(usbdev);\n}\n\nstatic int rndis_join_ibss(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t\tstruct cfg80211_ibss_params *params)\n{\n\tstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\n\tstruct usbnet *usbdev = priv->usbdev;\n\tstruct ieee80211_channel *channel = params->chandef.chan;\n\tstruct ndis_80211_ssid ssid;\n\tenum nl80211_auth_type auth_type;\n\tint ret, alg, length, chan = -1;\n\n\tif (channel)\n\t\tchan = ieee80211_frequency_to_channel(channel->center_freq);\n\n\t \n\tif (params->privacy) {\n\t\tauth_type = NL80211_AUTHTYPE_SHARED_KEY;\n\t\talg = RNDIS_WLAN_ALG_WEP;\n\t} else {\n\t\tauth_type = NL80211_AUTHTYPE_OPEN_SYSTEM;\n\t\talg = RNDIS_WLAN_ALG_NONE;\n\t}\n\n\tnetdev_dbg(usbdev->net, \"cfg80211.join_ibss('%.32s':[%pM]:%d:%d)\\n\",\n\t\t   params->ssid, params->bssid, chan, params->privacy);\n\n\tif (is_associated(usbdev))\n\t\tdisassociate(usbdev, false);\n\n\tret = set_infra_mode(usbdev, NDIS_80211_INFRA_ADHOC);\n\tif (ret < 0) {\n\t\tnetdev_dbg(usbdev->net, \"join_ibss: set_infra_mode failed, %d\\n\",\n\t\t\t   ret);\n\t\tgoto err_turn_radio_on;\n\t}\n\n\tret = set_auth_mode(usbdev, 0, auth_type, RNDIS_WLAN_KEY_MGMT_NONE);\n\tif (ret < 0) {\n\t\tnetdev_dbg(usbdev->net, \"join_ibss: set_auth_mode failed, %d\\n\",\n\t\t\t   ret);\n\t\tgoto err_turn_radio_on;\n\t}\n\n\tset_priv_filter(usbdev);\n\n\tret = set_encr_mode(usbdev, alg, RNDIS_WLAN_ALG_NONE);\n\tif (ret < 0) {\n\t\tnetdev_dbg(usbdev->net, \"join_ibss: set_encr_mode failed, %d\\n\",\n\t\t\t   ret);\n\t\tgoto err_turn_radio_on;\n\t}\n\n\tif (channel) {\n\t\tret = set_channel(usbdev, chan);\n\t\tif (ret < 0) {\n\t\t\tnetdev_dbg(usbdev->net, \"join_ibss: set_channel failed, %d\\n\",\n\t\t\t\t   ret);\n\t\t\tgoto err_turn_radio_on;\n\t\t}\n\t}\n\n\tif (params->bssid && !is_zero_ether_addr(params->bssid) &&\n\t\t\t\t!is_broadcast_ether_addr(params->bssid)) {\n\t\tret = set_bssid(usbdev, params->bssid);\n\t\tif (ret < 0) {\n\t\t\tnetdev_dbg(usbdev->net, \"join_ibss: set_bssid failed, %d\\n\",\n\t\t\t\t   ret);\n\t\t\tgoto err_turn_radio_on;\n\t\t}\n\t} else\n\t\tclear_bssid(usbdev);\n\n\tlength = params->ssid_len;\n\tif (length > NDIS_802_11_LENGTH_SSID)\n\t\tlength = NDIS_802_11_LENGTH_SSID;\n\n\tmemset(&ssid, 0, sizeof(ssid));\n\tssid.length = cpu_to_le32(length);\n\tmemcpy(ssid.essid, params->ssid, length);\n\n\t \n\tusbnet_purge_paused_rxq(usbdev);\n\tusbnet_resume_rx(usbdev);\n\n\tret = set_essid(usbdev, &ssid);\n\tif (ret < 0)\n\t\tnetdev_dbg(usbdev->net, \"join_ibss: set_essid failed, %d\\n\",\n\t\t\t   ret);\n\treturn ret;\n\nerr_turn_radio_on:\n\tdisassociate(usbdev, true);\n\n\treturn ret;\n}\n\nstatic int rndis_leave_ibss(struct wiphy *wiphy, struct net_device *dev)\n{\n\tstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\n\tstruct usbnet *usbdev = priv->usbdev;\n\n\tnetdev_dbg(usbdev->net, \"cfg80211.leave_ibss()\\n\");\n\n\tpriv->connected = false;\n\teth_zero_addr(priv->bssid);\n\n\treturn deauthenticate(usbdev);\n}\n\nstatic int rndis_add_key(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t int link_id,  u8 key_index, bool pairwise,\n\t\t\t const u8 *mac_addr, struct key_params *params)\n{\n\tstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\n\tstruct usbnet *usbdev = priv->usbdev;\n\t__le32 flags;\n\n\tnetdev_dbg(usbdev->net, \"%s(%i, %pM, %08x)\\n\",\n\t\t   __func__, key_index, mac_addr, params->cipher);\n\n\tswitch (params->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\treturn add_wep_key(usbdev, params->key, params->key_len,\n\t\t\t\t\t\t\t\tkey_index);\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tflags = 0;\n\n\t\tif (params->seq && params->seq_len > 0)\n\t\t\tflags |= NDIS_80211_ADDKEY_SET_INIT_RECV_SEQ;\n\t\tif (mac_addr)\n\t\t\tflags |= NDIS_80211_ADDKEY_PAIRWISE_KEY |\n\t\t\t\t\tNDIS_80211_ADDKEY_TRANSMIT_KEY;\n\n\t\treturn add_wpa_key(usbdev, params->key, params->key_len,\n\t\t\t\tkey_index, mac_addr, params->seq,\n\t\t\t\tparams->seq_len, params->cipher, flags);\n\tdefault:\n\t\tnetdev_dbg(usbdev->net, \"%s(): unsupported cipher %08x\\n\",\n\t\t\t   __func__, params->cipher);\n\t\treturn -ENOTSUPP;\n\t}\n}\n\nstatic int rndis_del_key(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t int link_id, u8 key_index, bool pairwise,\n\t\t\t const u8 *mac_addr)\n{\n\tstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\n\tstruct usbnet *usbdev = priv->usbdev;\n\n\tnetdev_dbg(usbdev->net, \"%s(%i, %pM)\\n\", __func__, key_index, mac_addr);\n\n\treturn remove_key(usbdev, key_index, mac_addr);\n}\n\nstatic int rndis_set_default_key(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t\t int link_id, u8 key_index, bool unicast,\n\t\t\t\t bool multicast)\n{\n\tstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\n\tstruct usbnet *usbdev = priv->usbdev;\n\tstruct rndis_wlan_encr_key key;\n\n\tnetdev_dbg(usbdev->net, \"%s(%i)\\n\", __func__, key_index);\n\n\tif (key_index >= RNDIS_WLAN_NUM_KEYS)\n\t\treturn -ENOENT;\n\n\tpriv->encr_tx_key_index = key_index;\n\n\tif (is_wpa_key(priv, key_index))\n\t\treturn 0;\n\n\tkey = priv->encr_keys[key_index];\n\n\treturn add_wep_key(usbdev, key.material, key.len, key_index);\n}\n\nstatic void rndis_fill_station_info(struct usbnet *usbdev,\n\t\t\t\t\t\tstruct station_info *sinfo)\n{\n\t__le32 linkspeed, rssi;\n\tint ret, len;\n\n\tmemset(sinfo, 0, sizeof(*sinfo));\n\n\tlen = sizeof(linkspeed);\n\tret = rndis_query_oid(usbdev, RNDIS_OID_GEN_LINK_SPEED, &linkspeed, &len);\n\tif (ret == 0) {\n\t\tsinfo->txrate.legacy = le32_to_cpu(linkspeed) / 1000;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);\n\t}\n\n\tlen = sizeof(rssi);\n\tret = rndis_query_oid(usbdev, RNDIS_OID_802_11_RSSI,\n\t\t\t      &rssi, &len);\n\tif (ret == 0) {\n\t\tsinfo->signal = level_to_qual(le32_to_cpu(rssi));\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL);\n\t}\n}\n\nstatic int rndis_get_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     const u8 *mac, struct station_info *sinfo)\n{\n\tstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\n\tstruct usbnet *usbdev = priv->usbdev;\n\n\tif (!ether_addr_equal(priv->bssid, mac))\n\t\treturn -ENOENT;\n\n\trndis_fill_station_info(usbdev, sinfo);\n\n\treturn 0;\n}\n\nstatic int rndis_dump_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       int idx, u8 *mac, struct station_info *sinfo)\n{\n\tstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\n\tstruct usbnet *usbdev = priv->usbdev;\n\n\tif (idx != 0)\n\t\treturn -ENOENT;\n\n\tmemcpy(mac, priv->bssid, ETH_ALEN);\n\n\trndis_fill_station_info(usbdev, sinfo);\n\n\treturn 0;\n}\n\nstatic int rndis_set_pmksa(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t\tstruct cfg80211_pmksa *pmksa)\n{\n\tstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\n\tstruct usbnet *usbdev = priv->usbdev;\n\tstruct ndis_80211_pmkid *pmkids;\n\tu32 *tmp = (u32 *)pmksa->pmkid;\n\n\tnetdev_dbg(usbdev->net, \"%s(%pM, %08X:%08X:%08X:%08X)\\n\", __func__,\n\t\t\tpmksa->bssid,\n\t\t\tcpu_to_be32(tmp[0]), cpu_to_be32(tmp[1]),\n\t\t\tcpu_to_be32(tmp[2]), cpu_to_be32(tmp[3]));\n\n\tpmkids = get_device_pmkids(usbdev);\n\tif (IS_ERR(pmkids)) {\n\t\t \n\t\treturn PTR_ERR(pmkids);\n\t}\n\n\tpmkids = update_pmkid(usbdev, pmkids, pmksa, wiphy->max_num_pmkids);\n\tif (IS_ERR(pmkids)) {\n\t\t \n\t\treturn PTR_ERR(pmkids);\n\t}\n\n\treturn set_device_pmkids(usbdev, pmkids);\n}\n\nstatic int rndis_del_pmksa(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t\tstruct cfg80211_pmksa *pmksa)\n{\n\tstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\n\tstruct usbnet *usbdev = priv->usbdev;\n\tstruct ndis_80211_pmkid *pmkids;\n\tu32 *tmp = (u32 *)pmksa->pmkid;\n\n\tnetdev_dbg(usbdev->net, \"%s(%pM, %08X:%08X:%08X:%08X)\\n\", __func__,\n\t\t\tpmksa->bssid,\n\t\t\tcpu_to_be32(tmp[0]), cpu_to_be32(tmp[1]),\n\t\t\tcpu_to_be32(tmp[2]), cpu_to_be32(tmp[3]));\n\n\tpmkids = get_device_pmkids(usbdev);\n\tif (IS_ERR(pmkids)) {\n\t\t \n\t\treturn PTR_ERR(pmkids);\n\t}\n\n\tpmkids = remove_pmkid(usbdev, pmkids, pmksa, wiphy->max_num_pmkids);\n\tif (IS_ERR(pmkids)) {\n\t\t \n\t\treturn PTR_ERR(pmkids);\n\t}\n\n\treturn set_device_pmkids(usbdev, pmkids);\n}\n\nstatic int rndis_flush_pmksa(struct wiphy *wiphy, struct net_device *netdev)\n{\n\tstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\n\tstruct usbnet *usbdev = priv->usbdev;\n\tstruct ndis_80211_pmkid pmkid;\n\n\tnetdev_dbg(usbdev->net, \"%s()\\n\", __func__);\n\n\tmemset(&pmkid, 0, sizeof(pmkid));\n\n\tpmkid.length = cpu_to_le32(sizeof(pmkid));\n\tpmkid.bssid_info_count = cpu_to_le32(0);\n\n\treturn rndis_set_oid(usbdev, RNDIS_OID_802_11_PMKID,\n\t\t\t     &pmkid, sizeof(pmkid));\n}\n\nstatic int rndis_set_power_mgmt(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\tbool enabled, int timeout)\n{\n\tstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\n\tstruct usbnet *usbdev = priv->usbdev;\n\tint power_mode;\n\t__le32 mode;\n\tint ret;\n\n\tif (priv->device_type != RNDIS_BCM4320B)\n\t\treturn -ENOTSUPP;\n\n\tnetdev_dbg(usbdev->net, \"%s(): %s, %d\\n\", __func__,\n\t\t\t\tenabled ? \"enabled\" : \"disabled\",\n\t\t\t\ttimeout);\n\n\tif (enabled)\n\t\tpower_mode = NDIS_80211_POWER_MODE_FAST_PSP;\n\telse\n\t\tpower_mode = NDIS_80211_POWER_MODE_CAM;\n\n\tif (power_mode == priv->power_mode)\n\t\treturn 0;\n\n\tpriv->power_mode = power_mode;\n\n\tmode = cpu_to_le32(power_mode);\n\tret = rndis_set_oid(usbdev, RNDIS_OID_802_11_POWER_MODE,\n\t\t\t    &mode, sizeof(mode));\n\n\tnetdev_dbg(usbdev->net, \"%s(): RNDIS_OID_802_11_POWER_MODE -> %d\\n\",\n\t\t\t\t__func__, ret);\n\n\treturn ret;\n}\n\nstatic int rndis_set_cqm_rssi_config(struct wiphy *wiphy,\n\t\t\t\t\tstruct net_device *dev,\n\t\t\t\t\ts32 rssi_thold, u32 rssi_hyst)\n{\n\tstruct rndis_wlan_private *priv = wiphy_priv(wiphy);\n\n\tpriv->cqm_rssi_thold = rssi_thold;\n\tpriv->cqm_rssi_hyst = rssi_hyst;\n\tpriv->last_cqm_event_rssi = 0;\n\n\treturn 0;\n}\n\nstatic void rndis_wlan_craft_connected_bss(struct usbnet *usbdev, u8 *bssid,\n\t\t\t\t\t   struct ndis_80211_assoc_info *info)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\tstruct ieee80211_channel *channel;\n\tstruct ndis_80211_ssid ssid;\n\tstruct cfg80211_bss *bss;\n\ts32 signal;\n\tu64 timestamp;\n\tu16 capability;\n\tu32 beacon_period = 0;\n\t__le32 rssi;\n\tu8 ie_buf[34];\n\tint len, ret, ie_len;\n\n\t \n\tlen = sizeof(rssi);\n\trssi = 0;\n\tret = rndis_query_oid(usbdev, RNDIS_OID_802_11_RSSI,\n\t\t\t      &rssi, &len);\n\tsignal = level_to_qual(le32_to_cpu(rssi));\n\n\tnetdev_dbg(usbdev->net, \"%s(): RNDIS_OID_802_11_RSSI -> %d, \"\n\t\t   \"rssi:%d, qual: %d\\n\", __func__, ret, le32_to_cpu(rssi),\n\t\t   level_to_qual(le32_to_cpu(rssi)));\n\n\t \n\tif (info) {\n\t\tcapability = le16_to_cpu(info->resp_ie.capa);\n\t} else {\n\t\t \n\t\tcapability = (priv->infra_mode == NDIS_80211_INFRA_INFRA) ?\n\t\t\t\tWLAN_CAPABILITY_ESS : WLAN_CAPABILITY_IBSS;\n\t}\n\n\t \n\tchannel = get_current_channel(usbdev, &beacon_period);\n\tif (!channel) {\n\t\tnetdev_warn(usbdev->net, \"%s(): could not get channel.\\n\",\n\t\t\t\t\t__func__);\n\t\treturn;\n\t}\n\n\t \n\tlen = sizeof(ssid);\n\tmemset(&ssid, 0, sizeof(ssid));\n\tret = rndis_query_oid(usbdev, RNDIS_OID_802_11_SSID,\n\t\t\t      &ssid, &len);\n\tnetdev_dbg(usbdev->net, \"%s(): RNDIS_OID_802_11_SSID -> %d, len: %d, ssid: \"\n\t\t\t\t\"'%.32s'\\n\", __func__, ret,\n\t\t\t\tle32_to_cpu(ssid.length), ssid.essid);\n\n\tif (le32_to_cpu(ssid.length) > 32)\n\t\tssid.length = cpu_to_le32(32);\n\n\tie_buf[0] = WLAN_EID_SSID;\n\tie_buf[1] = le32_to_cpu(ssid.length);\n\tmemcpy(&ie_buf[2], ssid.essid, le32_to_cpu(ssid.length));\n\n\tie_len = le32_to_cpu(ssid.length) + 2;\n\n\t \n\ttimestamp = 0;\n\n\tnetdev_dbg(usbdev->net, \"%s(): channel:%d(freq), bssid:[%pM], tsf:%d, \"\n\t\t\"capa:%x, beacon int:%d, resp_ie(len:%d, essid:'%.32s'), \"\n\t\t\"signal:%d\\n\", __func__, (channel ? channel->center_freq : -1),\n\t\tbssid, (u32)timestamp, capability, beacon_period, ie_len,\n\t\tssid.essid, signal);\n\n\tbss = cfg80211_inform_bss(priv->wdev.wiphy, channel,\n\t\t\t\t  CFG80211_BSS_FTYPE_UNKNOWN, bssid,\n\t\t\t\t  timestamp, capability, beacon_period,\n\t\t\t\t  ie_buf, ie_len, signal, GFP_KERNEL);\n\tcfg80211_put_bss(priv->wdev.wiphy, bss);\n}\n\n \nstatic void rndis_wlan_do_link_up_work(struct usbnet *usbdev)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\tstruct ndis_80211_assoc_info *info = NULL;\n\tu8 bssid[ETH_ALEN];\n\tunsigned int resp_ie_len, req_ie_len;\n\tunsigned int offset;\n\tu8 *req_ie, *resp_ie;\n\tint ret;\n\tbool roamed = false;\n\tbool match_bss;\n\n\tif (priv->infra_mode == NDIS_80211_INFRA_INFRA && priv->connected) {\n\t\t \n\t\troamed = true;\n\t}\n\n\treq_ie_len = 0;\n\tresp_ie_len = 0;\n\treq_ie = NULL;\n\tresp_ie = NULL;\n\n\tif (priv->infra_mode == NDIS_80211_INFRA_INFRA) {\n\t\tinfo = kzalloc(CONTROL_BUFFER_SIZE, GFP_KERNEL);\n\t\tif (!info) {\n\t\t\t \n\t\t\tset_bit(WORK_LINK_UP, &priv->work_pending);\n\t\t\tqueue_work(priv->workqueue, &priv->work);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tret = get_association_info(usbdev, info, CONTROL_BUFFER_SIZE);\n\t\tif (!ret) {\n\t\t\treq_ie_len = le32_to_cpu(info->req_ie_length);\n\t\t\tif (req_ie_len > CONTROL_BUFFER_SIZE)\n\t\t\t\treq_ie_len = CONTROL_BUFFER_SIZE;\n\t\t\tif (req_ie_len != 0) {\n\t\t\t\toffset = le32_to_cpu(info->offset_req_ies);\n\n\t\t\t\tif (offset > CONTROL_BUFFER_SIZE)\n\t\t\t\t\toffset = CONTROL_BUFFER_SIZE;\n\n\t\t\t\treq_ie = (u8 *)info + offset;\n\n\t\t\t\tif (offset + req_ie_len > CONTROL_BUFFER_SIZE)\n\t\t\t\t\treq_ie_len =\n\t\t\t\t\t\tCONTROL_BUFFER_SIZE - offset;\n\t\t\t}\n\n\t\t\tresp_ie_len = le32_to_cpu(info->resp_ie_length);\n\t\t\tif (resp_ie_len > CONTROL_BUFFER_SIZE)\n\t\t\t\tresp_ie_len = CONTROL_BUFFER_SIZE;\n\t\t\tif (resp_ie_len != 0) {\n\t\t\t\toffset = le32_to_cpu(info->offset_resp_ies);\n\n\t\t\t\tif (offset > CONTROL_BUFFER_SIZE)\n\t\t\t\t\toffset = CONTROL_BUFFER_SIZE;\n\n\t\t\t\tresp_ie = (u8 *)info + offset;\n\n\t\t\t\tif (offset + resp_ie_len > CONTROL_BUFFER_SIZE)\n\t\t\t\t\tresp_ie_len =\n\t\t\t\t\t\tCONTROL_BUFFER_SIZE - offset;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tkfree(info);\n\t\t\tinfo = NULL;\n\t\t}\n\t} else if (WARN_ON(priv->infra_mode != NDIS_80211_INFRA_ADHOC))\n\t\treturn;\n\n\tret = get_bssid(usbdev, bssid);\n\tif (ret < 0)\n\t\tmemset(bssid, 0, sizeof(bssid));\n\n\tnetdev_dbg(usbdev->net, \"link up work: [%pM]%s\\n\",\n\t\t   bssid, roamed ? \" roamed\" : \"\");\n\n\t \n\tmatch_bss = false;\n\trndis_check_bssid_list(usbdev, bssid, &match_bss);\n\n\tif (!is_zero_ether_addr(bssid) && !match_bss) {\n\t\t \n\t\trndis_wlan_craft_connected_bss(usbdev, bssid, info);\n\t}\n\n\tif (priv->infra_mode == NDIS_80211_INFRA_INFRA) {\n\t\tif (!roamed) {\n\t\t\tcfg80211_connect_result(usbdev->net, bssid, req_ie,\n\t\t\t\t\t\treq_ie_len, resp_ie,\n\t\t\t\t\t\tresp_ie_len, 0, GFP_KERNEL);\n\t\t} else {\n\t\t\tstruct cfg80211_roam_info roam_info = {\n\t\t\t\t.links[0].channel =\n\t\t\t\t\tget_current_channel(usbdev, NULL),\n\t\t\t\t.links[0].bssid = bssid,\n\t\t\t\t.req_ie = req_ie,\n\t\t\t\t.req_ie_len = req_ie_len,\n\t\t\t\t.resp_ie = resp_ie,\n\t\t\t\t.resp_ie_len = resp_ie_len,\n\t\t\t};\n\n\t\t\tcfg80211_roamed(usbdev->net, &roam_info, GFP_KERNEL);\n\t\t}\n\t} else if (priv->infra_mode == NDIS_80211_INFRA_ADHOC)\n\t\tcfg80211_ibss_joined(usbdev->net, bssid,\n\t\t\t\t     get_current_channel(usbdev, NULL),\n\t\t\t\t     GFP_KERNEL);\n\n\tkfree(info);\n\n\tpriv->connected = true;\n\tmemcpy(priv->bssid, bssid, ETH_ALEN);\n\n\tusbnet_resume_rx(usbdev);\n\tnetif_carrier_on(usbdev->net);\n}\n\nstatic void rndis_wlan_do_link_down_work(struct usbnet *usbdev)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\n\tif (priv->connected) {\n\t\tpriv->connected = false;\n\t\teth_zero_addr(priv->bssid);\n\n\t\tdeauthenticate(usbdev);\n\n\t\tcfg80211_disconnected(usbdev->net, 0, NULL, 0, true, GFP_KERNEL);\n\t}\n\n\tnetif_carrier_off(usbdev->net);\n}\n\nstatic void rndis_wlan_worker(struct work_struct *work)\n{\n\tstruct rndis_wlan_private *priv =\n\t\tcontainer_of(work, struct rndis_wlan_private, work);\n\tstruct usbnet *usbdev = priv->usbdev;\n\n\tif (test_and_clear_bit(WORK_LINK_UP, &priv->work_pending))\n\t\trndis_wlan_do_link_up_work(usbdev);\n\n\tif (test_and_clear_bit(WORK_LINK_DOWN, &priv->work_pending))\n\t\trndis_wlan_do_link_down_work(usbdev);\n\n\tif (test_and_clear_bit(WORK_SET_MULTICAST_LIST, &priv->work_pending))\n\t\tset_multicast_list(usbdev);\n}\n\nstatic void rndis_wlan_set_multicast_list(struct net_device *dev)\n{\n\tstruct usbnet *usbdev = netdev_priv(dev);\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\n\tif (test_bit(WORK_SET_MULTICAST_LIST, &priv->work_pending))\n\t\treturn;\n\n\tset_bit(WORK_SET_MULTICAST_LIST, &priv->work_pending);\n\tqueue_work(priv->workqueue, &priv->work);\n}\n\nstatic void rndis_wlan_auth_indication(struct usbnet *usbdev,\n\t\t\t\tstruct ndis_80211_status_indication *indication,\n\t\t\t\tint len)\n{\n\tu8 *buf;\n\tconst char *type;\n\tint flags, buflen, key_id;\n\tbool pairwise_error, group_error;\n\tstruct ndis_80211_auth_request *auth_req;\n\tenum nl80211_key_type key_type;\n\n\t \n\tif (len < offsetof(struct ndis_80211_status_indication, u) +\n\t\t\t\tsizeof(struct ndis_80211_auth_request)) {\n\t\tnetdev_info(usbdev->net, \"authentication indication: too short message (%i)\\n\",\n\t\t\t    len);\n\t\treturn;\n\t}\n\n\tbuf = (void *)&indication->u.auth_request[0];\n\tbuflen = len - offsetof(struct ndis_80211_status_indication, u);\n\n\twhile (buflen >= sizeof(*auth_req)) {\n\t\tauth_req = (void *)buf;\n\t\tif (buflen < le32_to_cpu(auth_req->length))\n\t\t\treturn;\n\t\ttype = \"unknown\";\n\t\tflags = le32_to_cpu(auth_req->flags);\n\t\tpairwise_error = false;\n\t\tgroup_error = false;\n\n\t\tif (flags & 0x1)\n\t\t\ttype = \"reauth request\";\n\t\tif (flags & 0x2)\n\t\t\ttype = \"key update request\";\n\t\tif (flags & 0x6) {\n\t\t\tpairwise_error = true;\n\t\t\ttype = \"pairwise_error\";\n\t\t}\n\t\tif (flags & 0xe) {\n\t\t\tgroup_error = true;\n\t\t\ttype = \"group_error\";\n\t\t}\n\n\t\tnetdev_info(usbdev->net, \"authentication indication: %s (0x%08x)\\n\",\n\t\t\t    type, le32_to_cpu(auth_req->flags));\n\n\t\tif (pairwise_error) {\n\t\t\tkey_type = NL80211_KEYTYPE_PAIRWISE;\n\t\t\tkey_id = -1;\n\n\t\t\tcfg80211_michael_mic_failure(usbdev->net,\n\t\t\t\t\t\t\tauth_req->bssid,\n\t\t\t\t\t\t\tkey_type, key_id, NULL,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t}\n\n\t\tif (group_error) {\n\t\t\tkey_type = NL80211_KEYTYPE_GROUP;\n\t\t\tkey_id = -1;\n\n\t\t\tcfg80211_michael_mic_failure(usbdev->net,\n\t\t\t\t\t\t\tauth_req->bssid,\n\t\t\t\t\t\t\tkey_type, key_id, NULL,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t}\n\n\t\tbuflen -= le32_to_cpu(auth_req->length);\n\t\tbuf += le32_to_cpu(auth_req->length);\n\t}\n}\n\nstatic void rndis_wlan_pmkid_cand_list_indication(struct usbnet *usbdev,\n\t\t\t\tstruct ndis_80211_status_indication *indication,\n\t\t\t\tint len)\n{\n\tstruct ndis_80211_pmkid_cand_list *cand_list;\n\tint list_len, expected_len, i;\n\n\tif (len < offsetof(struct ndis_80211_status_indication, u) +\n\t\t\t\tsizeof(struct ndis_80211_pmkid_cand_list)) {\n\t\tnetdev_info(usbdev->net, \"pmkid candidate list indication: too short message (%i)\\n\",\n\t\t\t    len);\n\t\treturn;\n\t}\n\n\tlist_len = le32_to_cpu(indication->u.cand_list.num_candidates) *\n\t\t\tsizeof(struct ndis_80211_pmkid_candidate);\n\texpected_len = sizeof(struct ndis_80211_pmkid_cand_list) + list_len +\n\t\t\toffsetof(struct ndis_80211_status_indication, u);\n\n\tif (len < expected_len) {\n\t\tnetdev_info(usbdev->net, \"pmkid candidate list indication: list larger than buffer (%i < %i)\\n\",\n\t\t\t    len, expected_len);\n\t\treturn;\n\t}\n\n\tcand_list = &indication->u.cand_list;\n\n\tnetdev_info(usbdev->net, \"pmkid candidate list indication: version %i, candidates %i\\n\",\n\t\t    le32_to_cpu(cand_list->version),\n\t\t    le32_to_cpu(cand_list->num_candidates));\n\n\tif (le32_to_cpu(cand_list->version) != 1)\n\t\treturn;\n\n\tfor (i = 0; i < le32_to_cpu(cand_list->num_candidates); i++) {\n\t\tstruct ndis_80211_pmkid_candidate *cand =\n\t\t\t\t\t\t&cand_list->candidate_list[i];\n\t\tbool preauth = !!(cand->flags & NDIS_80211_PMKID_CAND_PREAUTH);\n\n\t\tnetdev_dbg(usbdev->net, \"cand[%i]: flags: 0x%08x, preauth: %d, bssid: %pM\\n\",\n\t\t\t   i, le32_to_cpu(cand->flags), preauth, cand->bssid);\n\n\t\tcfg80211_pmksa_candidate_notify(usbdev->net, i, cand->bssid,\n\t\t\t\t\t\tpreauth, GFP_ATOMIC);\n\t}\n}\n\nstatic void rndis_wlan_media_specific_indication(struct usbnet *usbdev,\n\t\t\tstruct rndis_indicate *msg, int buflen)\n{\n\tstruct ndis_80211_status_indication *indication;\n\tunsigned int len, offset;\n\n\toffset = offsetof(struct rndis_indicate, status) +\n\t\t\tle32_to_cpu(msg->offset);\n\tlen = le32_to_cpu(msg->length);\n\n\tif (len < 8) {\n\t\tnetdev_info(usbdev->net, \"media specific indication, ignore too short message (%i < 8)\\n\",\n\t\t\t    len);\n\t\treturn;\n\t}\n\n\tif (len > buflen || offset > buflen || offset + len > buflen) {\n\t\tnetdev_info(usbdev->net, \"media specific indication, too large to fit to buffer (%i > %i)\\n\",\n\t\t\t    offset + len, buflen);\n\t\treturn;\n\t}\n\n\tindication = (void *)((u8 *)msg + offset);\n\n\tswitch (le32_to_cpu(indication->status_type)) {\n\tcase NDIS_80211_STATUSTYPE_RADIOSTATE:\n\t\tnetdev_info(usbdev->net, \"radio state indication: %i\\n\",\n\t\t\t    le32_to_cpu(indication->u.radio_status));\n\t\treturn;\n\n\tcase NDIS_80211_STATUSTYPE_MEDIASTREAMMODE:\n\t\tnetdev_info(usbdev->net, \"media stream mode indication: %i\\n\",\n\t\t\t    le32_to_cpu(indication->u.media_stream_mode));\n\t\treturn;\n\n\tcase NDIS_80211_STATUSTYPE_AUTHENTICATION:\n\t\trndis_wlan_auth_indication(usbdev, indication, len);\n\t\treturn;\n\n\tcase NDIS_80211_STATUSTYPE_PMKID_CANDIDATELIST:\n\t\trndis_wlan_pmkid_cand_list_indication(usbdev, indication, len);\n\t\treturn;\n\n\tdefault:\n\t\tnetdev_info(usbdev->net, \"media specific indication: unknown status type 0x%08x\\n\",\n\t\t\t    le32_to_cpu(indication->status_type));\n\t}\n}\n\nstatic void rndis_wlan_indication(struct usbnet *usbdev, void *ind, int buflen)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\tstruct rndis_indicate *msg = ind;\n\n\tswitch (le32_to_cpu(msg->status)) {\n\tcase RNDIS_STATUS_MEDIA_CONNECT:\n\t\tif (priv->current_command_oid == RNDIS_OID_802_11_ADD_KEY) {\n\t\t\t \n\t\t\tnetdev_dbg(usbdev->net, \"ignored RNDIS_OID_802_11_ADD_KEY triggered 'media connect'\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tusbnet_pause_rx(usbdev);\n\n\t\tnetdev_info(usbdev->net, \"media connect\\n\");\n\n\t\t \n\t\tset_bit(WORK_LINK_UP, &priv->work_pending);\n\t\tqueue_work(priv->workqueue, &priv->work);\n\t\tbreak;\n\n\tcase RNDIS_STATUS_MEDIA_DISCONNECT:\n\t\tnetdev_info(usbdev->net, \"media disconnect\\n\");\n\n\t\t \n\t\tset_bit(WORK_LINK_DOWN, &priv->work_pending);\n\t\tqueue_work(priv->workqueue, &priv->work);\n\t\tbreak;\n\n\tcase RNDIS_STATUS_MEDIA_SPECIFIC_INDICATION:\n\t\trndis_wlan_media_specific_indication(usbdev, msg, buflen);\n\t\tbreak;\n\n\tdefault:\n\t\tnetdev_info(usbdev->net, \"indication: 0x%08x\\n\",\n\t\t\t    le32_to_cpu(msg->status));\n\t\tbreak;\n\t}\n}\n\nstatic int rndis_wlan_get_caps(struct usbnet *usbdev, struct wiphy *wiphy)\n{\n\tstruct {\n\t\t__le32\tnum_items;\n\t\t__le32\titems[8];\n\t} networks_supported;\n\tstruct ndis_80211_capability caps;\n\tint len, retval, i, n;\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\n\t \n\tlen = sizeof(networks_supported);\n\tretval = rndis_query_oid(usbdev,\n\t\t\t\t RNDIS_OID_802_11_NETWORK_TYPES_SUPPORTED,\n\t\t\t\t &networks_supported, &len);\n\tif (!retval) {\n\t\tn = le32_to_cpu(networks_supported.num_items);\n\t\tif (n > 8)\n\t\t\tn = 8;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tswitch (le32_to_cpu(networks_supported.items[i])) {\n\t\t\tcase NDIS_80211_TYPE_FREQ_HOP:\n\t\t\tcase NDIS_80211_TYPE_DIRECT_SEQ:\n\t\t\t\tpriv->caps |= CAP_MODE_80211B;\n\t\t\t\tbreak;\n\t\t\tcase NDIS_80211_TYPE_OFDM_A:\n\t\t\t\tpriv->caps |= CAP_MODE_80211A;\n\t\t\t\tbreak;\n\t\t\tcase NDIS_80211_TYPE_OFDM_G:\n\t\t\t\tpriv->caps |= CAP_MODE_80211G;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tlen = sizeof(caps);\n\tretval = rndis_query_oid(usbdev,\n\t\t\t\t RNDIS_OID_802_11_CAPABILITY,\n\t\t\t\t &caps, &len);\n\tif (!retval) {\n\t\tnetdev_dbg(usbdev->net, \"RNDIS_OID_802_11_CAPABILITY -> len %d, \"\n\t\t\t\t\"ver %d, pmkids %d, auth-encr-pairs %d\\n\",\n\t\t\t\tle32_to_cpu(caps.length),\n\t\t\t\tle32_to_cpu(caps.version),\n\t\t\t\tle32_to_cpu(caps.num_pmkids),\n\t\t\t\tle32_to_cpu(caps.num_auth_encr_pair));\n\t\twiphy->max_num_pmkids = le32_to_cpu(caps.num_pmkids);\n\t} else\n\t\twiphy->max_num_pmkids = 0;\n\n\treturn retval;\n}\n\nstatic void rndis_do_cqm(struct usbnet *usbdev, s32 rssi)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\tenum nl80211_cqm_rssi_threshold_event event;\n\tint thold, hyst, last_event;\n\n\tif (priv->cqm_rssi_thold >= 0 || rssi >= 0)\n\t\treturn;\n\tif (priv->infra_mode != NDIS_80211_INFRA_INFRA)\n\t\treturn;\n\n\tlast_event = priv->last_cqm_event_rssi;\n\tthold = priv->cqm_rssi_thold;\n\thyst = priv->cqm_rssi_hyst;\n\n\tif (rssi < thold && (last_event == 0 || rssi < last_event - hyst))\n\t\tevent = NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW;\n\telse if (rssi > thold && (last_event == 0 || rssi > last_event + hyst))\n\t\tevent = NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH;\n\telse\n\t\treturn;\n\n\tpriv->last_cqm_event_rssi = rssi;\n\tcfg80211_cqm_rssi_notify(usbdev->net, event, rssi, GFP_KERNEL);\n}\n\n#define DEVICE_POLLER_JIFFIES (HZ)\nstatic void rndis_device_poller(struct work_struct *work)\n{\n\tstruct rndis_wlan_private *priv =\n\t\tcontainer_of(work, struct rndis_wlan_private,\n\t\t\t\t\t\t\tdev_poller_work.work);\n\tstruct usbnet *usbdev = priv->usbdev;\n\t__le32 rssi, tmp;\n\tint len, ret, j;\n\tint update_jiffies = DEVICE_POLLER_JIFFIES;\n\tvoid *buf;\n\n\t \n\tif (!is_associated(usbdev)) {\n\t\t \n\t\tif (priv->device_type == RNDIS_BCM4320A && priv->radio_on &&\n\t\t    !priv->scan_request) {\n\t\t\t \n\t\t\trndis_check_bssid_list(usbdev, NULL, NULL);\n\n\t\t\t \n\t\t\trndis_start_bssid_list_scan(usbdev);\n\t\t}\n\n\t\tgoto end;\n\t}\n\n\tlen = sizeof(rssi);\n\tret = rndis_query_oid(usbdev, RNDIS_OID_802_11_RSSI,\n\t\t\t      &rssi, &len);\n\tif (ret == 0) {\n\t\tpriv->last_qual = level_to_qual(le32_to_cpu(rssi));\n\t\trndis_do_cqm(usbdev, le32_to_cpu(rssi));\n\t}\n\n\tnetdev_dbg(usbdev->net, \"dev-poller: RNDIS_OID_802_11_RSSI -> %d, rssi:%d, qual: %d\\n\",\n\t\t   ret, le32_to_cpu(rssi), level_to_qual(le32_to_cpu(rssi)));\n\n\t \n\tif (priv->param_workaround_interval > 0 && priv->last_qual <= 25) {\n\t\t \n\t\tj = msecs_to_jiffies(priv->param_workaround_interval);\n\t\tif (j > DEVICE_POLLER_JIFFIES)\n\t\t\tj = DEVICE_POLLER_JIFFIES;\n\t\telse if (j <= 0)\n\t\t\tj = 1;\n\t\tupdate_jiffies = j;\n\n\t\t \n\t\ttmp = cpu_to_le32(1);\n\t\trndis_set_oid(usbdev,\n\t\t\t      RNDIS_OID_802_11_BSSID_LIST_SCAN,\n\t\t\t      &tmp, sizeof(tmp));\n\n\t\tlen = CONTROL_BUFFER_SIZE;\n\t\tbuf = kmalloc(len, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\tgoto end;\n\n\t\trndis_query_oid(usbdev,\n\t\t\t\tRNDIS_OID_802_11_BSSID_LIST,\n\t\t\t\tbuf, &len);\n\t\tkfree(buf);\n\t}\n\nend:\n\tif (update_jiffies >= HZ)\n\t\tupdate_jiffies = round_jiffies_relative(update_jiffies);\n\telse {\n\t\tj = round_jiffies_relative(update_jiffies);\n\t\tif (abs(j - update_jiffies) <= 10)\n\t\t\tupdate_jiffies = j;\n\t}\n\n\tqueue_delayed_work(priv->workqueue, &priv->dev_poller_work,\n\t\t\t\t\t\t\t\tupdate_jiffies);\n}\n\n \nstatic void rndis_copy_module_params(struct usbnet *usbdev, int device_type)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\n\tpriv->device_type = device_type;\n\n\tpriv->param_country[0] = modparam_country[0];\n\tpriv->param_country[1] = modparam_country[1];\n\tpriv->param_country[2] = 0;\n\tpriv->param_frameburst   = modparam_frameburst;\n\tpriv->param_afterburner  = modparam_afterburner;\n\tpriv->param_power_save   = modparam_power_save;\n\tpriv->param_power_output = modparam_power_output;\n\tpriv->param_roamtrigger  = modparam_roamtrigger;\n\tpriv->param_roamdelta    = modparam_roamdelta;\n\n\tpriv->param_country[0] = toupper(priv->param_country[0]);\n\tpriv->param_country[1] = toupper(priv->param_country[1]);\n\t \n\tif (!strcmp(priv->param_country, \"EU\"))\n\t\tstrcpy(priv->param_country, \"FI\");\n\n\tif (priv->param_power_save < 0)\n\t\tpriv->param_power_save = 0;\n\telse if (priv->param_power_save > 2)\n\t\tpriv->param_power_save = 2;\n\n\tif (priv->param_power_output < 0)\n\t\tpriv->param_power_output = 0;\n\telse if (priv->param_power_output > 3)\n\t\tpriv->param_power_output = 3;\n\n\tif (priv->param_roamtrigger < -80)\n\t\tpriv->param_roamtrigger = -80;\n\telse if (priv->param_roamtrigger > -60)\n\t\tpriv->param_roamtrigger = -60;\n\n\tif (priv->param_roamdelta < 0)\n\t\tpriv->param_roamdelta = 0;\n\telse if (priv->param_roamdelta > 2)\n\t\tpriv->param_roamdelta = 2;\n\n\tif (modparam_workaround_interval < 0)\n\t\tpriv->param_workaround_interval = 500;\n\telse\n\t\tpriv->param_workaround_interval = modparam_workaround_interval;\n}\n\nstatic int unknown_early_init(struct usbnet *usbdev)\n{\n\t \n\trndis_copy_module_params(usbdev, RNDIS_UNKNOWN);\n\n\t \n\n\treturn 0;\n}\n\nstatic int bcm4320a_early_init(struct usbnet *usbdev)\n{\n\t \n\trndis_copy_module_params(usbdev, RNDIS_BCM4320A);\n\n\t \n\n\treturn 0;\n}\n\nstatic int bcm4320b_early_init(struct usbnet *usbdev)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\tchar buf[8];\n\n\trndis_copy_module_params(usbdev, RNDIS_BCM4320B);\n\n\t \n\n\trndis_set_config_parameter_str(usbdev, \"Country\", priv->param_country);\n\trndis_set_config_parameter_str(usbdev, \"FrameBursting\",\n\t\t\t\t\tpriv->param_frameburst ? \"1\" : \"0\");\n\trndis_set_config_parameter_str(usbdev, \"Afterburner\",\n\t\t\t\t\tpriv->param_afterburner ? \"1\" : \"0\");\n\tsprintf(buf, \"%d\", priv->param_power_save);\n\trndis_set_config_parameter_str(usbdev, \"PowerSaveMode\", buf);\n\tsprintf(buf, \"%d\", priv->param_power_output);\n\trndis_set_config_parameter_str(usbdev, \"PwrOut\", buf);\n\tsprintf(buf, \"%d\", priv->param_roamtrigger);\n\trndis_set_config_parameter_str(usbdev, \"RoamTrigger\", buf);\n\tsprintf(buf, \"%d\", priv->param_roamdelta);\n\trndis_set_config_parameter_str(usbdev, \"RoamDelta\", buf);\n\n\treturn 0;\n}\n\n \nstatic const struct net_device_ops rndis_wlan_netdev_ops = {\n\t.ndo_open\t\t= usbnet_open,\n\t.ndo_stop\t\t= usbnet_stop,\n\t.ndo_start_xmit\t\t= usbnet_start_xmit,\n\t.ndo_tx_timeout\t\t= usbnet_tx_timeout,\n\t.ndo_get_stats64\t= dev_get_tstats64,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_rx_mode\t= rndis_wlan_set_multicast_list,\n};\n\nstatic int rndis_wlan_bind(struct usbnet *usbdev, struct usb_interface *intf)\n{\n\tstruct wiphy *wiphy;\n\tstruct rndis_wlan_private *priv;\n\tint retval, len;\n\t__le32 tmp;\n\n\t \n\twiphy = wiphy_new(&rndis_config_ops, sizeof(struct rndis_wlan_private));\n\tif (!wiphy)\n\t\treturn -ENOMEM;\n\n\tpriv = wiphy_priv(wiphy);\n\tusbdev->net->ieee80211_ptr = &priv->wdev;\n\tpriv->wdev.wiphy = wiphy;\n\tpriv->wdev.iftype = NL80211_IFTYPE_STATION;\n\n\t \n\tusbdev->driver_priv = priv;\n\tpriv->usbdev = usbdev;\n\n\tmutex_init(&priv->command_lock);\n\n\t \n\tpriv->workqueue = create_singlethread_workqueue(\"rndis_wlan\");\n\tif (!priv->workqueue) {\n\t\twiphy_free(wiphy);\n\t\treturn -ENOMEM;\n\t}\n\tINIT_WORK(&priv->work, rndis_wlan_worker);\n\tINIT_DELAYED_WORK(&priv->dev_poller_work, rndis_device_poller);\n\tINIT_DELAYED_WORK(&priv->scan_work, rndis_get_scan_results);\n\n\t \n\tretval = generic_rndis_bind(usbdev, intf, FLAG_RNDIS_PHYM_WIRELESS);\n\tif (retval < 0)\n\t\tgoto fail;\n\n\t \n\tusbdev->net->netdev_ops = &rndis_wlan_netdev_ops;\n\n\ttmp = cpu_to_le32(RNDIS_PACKET_TYPE_DIRECTED | RNDIS_PACKET_TYPE_BROADCAST);\n\tretval = rndis_set_oid(usbdev,\n\t\t\t       RNDIS_OID_GEN_CURRENT_PACKET_FILTER,\n\t\t\t       &tmp, sizeof(tmp));\n\n\tlen = sizeof(tmp);\n\tretval = rndis_query_oid(usbdev,\n\t\t\t\t RNDIS_OID_802_3_MAXIMUM_LIST_SIZE,\n\t\t\t\t &tmp, &len);\n\tpriv->multicast_size = le32_to_cpu(tmp);\n\tif (retval < 0 || priv->multicast_size < 0)\n\t\tpriv->multicast_size = 0;\n\tif (priv->multicast_size > 0)\n\t\tusbdev->net->flags |= IFF_MULTICAST;\n\telse\n\t\tusbdev->net->flags &= ~IFF_MULTICAST;\n\n\t \n\tmemcpy(wiphy->perm_addr, usbdev->net->dev_addr, ETH_ALEN);\n\twiphy->privid = rndis_wiphy_privid;\n\twiphy->interface_modes = BIT(NL80211_IFTYPE_STATION)\n\t\t\t\t\t| BIT(NL80211_IFTYPE_ADHOC);\n\twiphy->max_scan_ssids = 1;\n\n\t \n\trndis_wlan_get_caps(usbdev, wiphy);\n\n\tmemcpy(priv->channels, rndis_channels, sizeof(rndis_channels));\n\tmemcpy(priv->rates, rndis_rates, sizeof(rndis_rates));\n\tpriv->band.channels = priv->channels;\n\tpriv->band.n_channels = ARRAY_SIZE(rndis_channels);\n\tpriv->band.bitrates = priv->rates;\n\tpriv->band.n_bitrates = ARRAY_SIZE(rndis_rates);\n\twiphy->bands[NL80211_BAND_2GHZ] = &priv->band;\n\twiphy->signal_type = CFG80211_SIGNAL_TYPE_UNSPEC;\n\n\tmemcpy(priv->cipher_suites, rndis_cipher_suites,\n\t\t\t\t\t\tsizeof(rndis_cipher_suites));\n\twiphy->cipher_suites = priv->cipher_suites;\n\twiphy->n_cipher_suites = ARRAY_SIZE(rndis_cipher_suites);\n\n\tset_wiphy_dev(wiphy, &usbdev->udev->dev);\n\n\tif (wiphy_register(wiphy)) {\n\t\tretval = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tset_default_iw_params(usbdev);\n\n\tpriv->power_mode = -1;\n\n\t \n\trndis_set_wiphy_params(wiphy,\n\t\t\tWIPHY_PARAM_FRAG_THRESHOLD | WIPHY_PARAM_RTS_THRESHOLD);\n\n\t \n\tpriv->radio_on = false;\n\tdisassociate(usbdev, false);\n\tnetif_carrier_off(usbdev->net);\n\n\treturn 0;\n\nfail:\n\tcancel_delayed_work_sync(&priv->dev_poller_work);\n\tcancel_delayed_work_sync(&priv->scan_work);\n\tcancel_work_sync(&priv->work);\n\tdestroy_workqueue(priv->workqueue);\n\n\twiphy_free(wiphy);\n\treturn retval;\n}\n\nstatic void rndis_wlan_unbind(struct usbnet *usbdev, struct usb_interface *intf)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\n\t \n\tdisassociate(usbdev, false);\n\n\tcancel_delayed_work_sync(&priv->dev_poller_work);\n\tcancel_delayed_work_sync(&priv->scan_work);\n\tcancel_work_sync(&priv->work);\n\tdestroy_workqueue(priv->workqueue);\n\n\trndis_unbind(usbdev, intf);\n\n\twiphy_unregister(priv->wdev.wiphy);\n\twiphy_free(priv->wdev.wiphy);\n}\n\nstatic int rndis_wlan_reset(struct usbnet *usbdev)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\tint retval;\n\n\tnetdev_dbg(usbdev->net, \"%s()\\n\", __func__);\n\n\tretval = rndis_reset(usbdev);\n\tif (retval)\n\t\tnetdev_warn(usbdev->net, \"rndis_reset failed: %d\\n\", retval);\n\n\t \n\tset_multicast_list(usbdev);\n\n\tqueue_delayed_work(priv->workqueue, &priv->dev_poller_work,\n\t\tround_jiffies_relative(DEVICE_POLLER_JIFFIES));\n\n\treturn deauthenticate(usbdev);\n}\n\nstatic int rndis_wlan_stop(struct usbnet *usbdev)\n{\n\tstruct rndis_wlan_private *priv = get_rndis_wlan_priv(usbdev);\n\tint retval;\n\t__le32 filter;\n\n\tnetdev_dbg(usbdev->net, \"%s()\\n\", __func__);\n\n\tretval = disassociate(usbdev, false);\n\n\tpriv->work_pending = 0;\n\tcancel_delayed_work_sync(&priv->dev_poller_work);\n\tcancel_delayed_work_sync(&priv->scan_work);\n\tcancel_work_sync(&priv->work);\n\tflush_workqueue(priv->workqueue);\n\n\tif (priv->scan_request) {\n\t\tstruct cfg80211_scan_info info = {\n\t\t\t.aborted = true,\n\t\t};\n\n\t\tcfg80211_scan_done(priv->scan_request, &info);\n\t\tpriv->scan_request = NULL;\n\t}\n\n\t \n\tfilter = 0;\n\trndis_set_oid(usbdev, RNDIS_OID_GEN_CURRENT_PACKET_FILTER, &filter,\n\t\t\t\t\t\t\t\tsizeof(filter));\n\n\treturn retval;\n}\n\nstatic const struct driver_info\tbcm4320b_info = {\n\t.description =\t\"Wireless RNDIS device, BCM4320b based\",\n\t.flags =\tFLAG_WLAN | FLAG_FRAMING_RN | FLAG_NO_SETINT |\n\t\t\t\tFLAG_AVOID_UNLINK_URBS,\n\t.bind =\t\trndis_wlan_bind,\n\t.unbind =\trndis_wlan_unbind,\n\t.status =\trndis_status,\n\t.rx_fixup =\trndis_rx_fixup,\n\t.tx_fixup =\trndis_tx_fixup,\n\t.reset =\trndis_wlan_reset,\n\t.stop =\t\trndis_wlan_stop,\n\t.early_init =\tbcm4320b_early_init,\n\t.indication =\trndis_wlan_indication,\n};\n\nstatic const struct driver_info\tbcm4320a_info = {\n\t.description =\t\"Wireless RNDIS device, BCM4320a based\",\n\t.flags =\tFLAG_WLAN | FLAG_FRAMING_RN | FLAG_NO_SETINT |\n\t\t\t\tFLAG_AVOID_UNLINK_URBS,\n\t.bind =\t\trndis_wlan_bind,\n\t.unbind =\trndis_wlan_unbind,\n\t.status =\trndis_status,\n\t.rx_fixup =\trndis_rx_fixup,\n\t.tx_fixup =\trndis_tx_fixup,\n\t.reset =\trndis_wlan_reset,\n\t.stop =\t\trndis_wlan_stop,\n\t.early_init =\tbcm4320a_early_init,\n\t.indication =\trndis_wlan_indication,\n};\n\nstatic const struct driver_info rndis_wlan_info = {\n\t.description =\t\"Wireless RNDIS device\",\n\t.flags =\tFLAG_WLAN | FLAG_FRAMING_RN | FLAG_NO_SETINT |\n\t\t\t\tFLAG_AVOID_UNLINK_URBS,\n\t.bind =\t\trndis_wlan_bind,\n\t.unbind =\trndis_wlan_unbind,\n\t.status =\trndis_status,\n\t.rx_fixup =\trndis_rx_fixup,\n\t.tx_fixup =\trndis_tx_fixup,\n\t.reset =\trndis_wlan_reset,\n\t.stop =\t\trndis_wlan_stop,\n\t.early_init =\tunknown_early_init,\n\t.indication =\trndis_wlan_indication,\n};\n\n \n\nstatic const struct usb_device_id products [] = {\n#define\tRNDIS_MASTER_INTERFACE \\\n\t.bInterfaceClass\t= USB_CLASS_COMM, \\\n\t.bInterfaceSubClass\t= 2  , \\\n\t.bInterfaceProtocol\t= 0x0ff\n\n \n{\n\t.match_flags\t=   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t\t  | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x0411,\n\t.idProduct\t\t= 0x00bc,\t \n\tRNDIS_MASTER_INTERFACE,\n\t.driver_info\t\t= (unsigned long) &bcm4320b_info,\n}, {\n\t.match_flags\t=   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t\t  | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x0baf,\n\t.idProduct\t\t= 0x011b,\t \n\tRNDIS_MASTER_INTERFACE,\n\t.driver_info\t\t= (unsigned long) &bcm4320b_info,\n}, {\n\t.match_flags\t=   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t\t  | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x050d,\n\t.idProduct\t\t= 0x011b,\t \n\tRNDIS_MASTER_INTERFACE,\n\t.driver_info\t\t= (unsigned long) &bcm4320b_info,\n}, {\n\t.match_flags\t=   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t\t  | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x1799,\t \n\t.idProduct\t\t= 0x011b,\t \n\tRNDIS_MASTER_INTERFACE,\n\t.driver_info\t\t= (unsigned long) &bcm4320b_info,\n}, {\n\t.match_flags\t=   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t\t  | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x13b1,\n\t.idProduct\t\t= 0x0014,\t \n\tRNDIS_MASTER_INTERFACE,\n\t.driver_info\t\t= (unsigned long) &bcm4320b_info,\n}, {\n\t.match_flags\t=   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t\t  | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x13b1,\n\t.idProduct\t\t= 0x0026,\t \n\tRNDIS_MASTER_INTERFACE,\n\t.driver_info\t\t= (unsigned long) &bcm4320b_info,\n}, {\n\t.match_flags\t=   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t\t  | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x0b05,\n\t.idProduct\t\t= 0x1717,\t \n\tRNDIS_MASTER_INTERFACE,\n\t.driver_info\t\t= (unsigned long) &bcm4320b_info,\n}, {\n\t.match_flags\t=   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t\t  | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x0a5c,\n\t.idProduct\t\t= 0xd11b,\t \n\tRNDIS_MASTER_INTERFACE,\n\t.driver_info\t\t= (unsigned long) &bcm4320b_info,\n}, {\n\t.match_flags\t=   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t\t  | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x1690,\n\t.idProduct\t\t= 0x0715,\t \n\tRNDIS_MASTER_INTERFACE,\n\t.driver_info\t\t= (unsigned long) &bcm4320b_info,\n},\n \n{\n\t.match_flags\t=   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t\t  | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x13b1,\n\t.idProduct\t\t= 0x000e,\t \n\tRNDIS_MASTER_INTERFACE,\n\t.driver_info\t\t= (unsigned long) &bcm4320a_info,\n}, {\n\t.match_flags\t=   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t\t  | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x0baf,\n\t.idProduct\t\t= 0x0111,\t \n\tRNDIS_MASTER_INTERFACE,\n\t.driver_info\t\t= (unsigned long) &bcm4320a_info,\n}, {\n\t.match_flags\t=   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t\t  | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x0411,\n\t.idProduct\t\t= 0x004b,\t \n\tRNDIS_MASTER_INTERFACE,\n\t.driver_info\t\t= (unsigned long) &bcm4320a_info,\n},\n \n{\n\t \n\tUSB_INTERFACE_INFO(USB_CLASS_COMM, 2  , 0x0ff),\n\t.driver_info = (unsigned long) &rndis_wlan_info,\n}, {\n\t \n\tUSB_INTERFACE_INFO(USB_CLASS_MISC, 1, 1),\n\t.driver_info = (unsigned long) &rndis_wlan_info,\n},\n\t{ },\t\t\n};\nMODULE_DEVICE_TABLE(usb, products);\n\nstatic struct usb_driver rndis_wlan_driver = {\n\t.name =\t\t\"rndis_wlan\",\n\t.id_table =\tproducts,\n\t.probe =\tusbnet_probe,\n\t.disconnect =\tusbnet_disconnect,\n\t.suspend =\tusbnet_suspend,\n\t.resume =\tusbnet_resume,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(rndis_wlan_driver);\n\nMODULE_AUTHOR(\"Bjorge Dijkstra\");\nMODULE_AUTHOR(\"Jussi Kivilinna\");\nMODULE_DESCRIPTION(\"Driver for RNDIS based USB Wireless adapters\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}