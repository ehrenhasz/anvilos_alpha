{
  "module_name": "wl3501_cs.c",
  "hash_id": "eaa479b90ebffeb776abfb6022e6be199462315a000c071341527b5cca7bb3c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/legacy/wl3501_cs.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/fcntl.h>\n#include <linux/if_arp.h>\n#include <linux/ioport.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/wireless.h>\n#include <net/cfg80211.h>\n\n#include <net/iw_handler.h>\n\n#include <pcmcia/cistpl.h>\n#include <pcmcia/cisreg.h>\n#include <pcmcia/ds.h>\n\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n#include \"wl3501.h\"\n\n#ifndef __i386__\n#define slow_down_io()\n#endif\n\n \n#define WL3501_NOPLOOP(n) { int x = 0; while (x++ < n) slow_down_io(); }\n\n\n\n#define wl3501_outb(a, b) { outb(a, b); slow_down_io(); }\n#define wl3501_outb_p(a, b) { outb_p(a, b); slow_down_io(); }\n#define wl3501_outsb(a, b, c) { outsb(a, b, c); slow_down_io(); }\n\n#define WL3501_RELEASE_TIMEOUT (25 * HZ)\n#define WL3501_MAX_ADHOC_TRIES 16\n\n#define WL3501_RESUME\t0\n#define WL3501_SUSPEND\t1\n\nstatic int wl3501_config(struct pcmcia_device *link);\nstatic void wl3501_release(struct pcmcia_device *link);\n\nstatic const struct {\n\tint reg_domain;\n\tint min, max, deflt;\n} iw_channel_table[] = {\n\t{\n\t\t.reg_domain = IW_REG_DOMAIN_FCC,\n\t\t.min\t    = 1,\n\t\t.max\t    = 11,\n\t\t.deflt\t    = 1,\n\t},\n\t{\n\t\t.reg_domain = IW_REG_DOMAIN_DOC,\n\t\t.min\t    = 1,\n\t\t.max\t    = 11,\n\t\t.deflt\t    = 1,\n\t},\n\t{\n\t\t.reg_domain = IW_REG_DOMAIN_ETSI,\n\t\t.min\t    = 1,\n\t\t.max\t    = 13,\n\t\t.deflt\t    = 1,\n\t},\n\t{\n\t\t.reg_domain = IW_REG_DOMAIN_SPAIN,\n\t\t.min\t    = 10,\n\t\t.max\t    = 11,\n\t\t.deflt\t    = 10,\n\t},\n\t{\n\t\t.reg_domain = IW_REG_DOMAIN_FRANCE,\n\t\t.min\t    = 10,\n\t\t.max\t    = 13,\n\t\t.deflt\t    = 10,\n\t},\n\t{\n\t\t.reg_domain = IW_REG_DOMAIN_MKK,\n\t\t.min\t    = 14,\n\t\t.max\t    = 14,\n\t\t.deflt\t    = 14,\n\t},\n\t{\n\t\t.reg_domain = IW_REG_DOMAIN_MKK1,\n\t\t.min\t    = 1,\n\t\t.max\t    = 14,\n\t\t.deflt\t    = 1,\n\t},\n\t{\n\t\t.reg_domain = IW_REG_DOMAIN_ISRAEL,\n\t\t.min\t    = 3,\n\t\t.max\t    = 9,\n\t\t.deflt\t    = 9,\n\t},\n};\n\n \nstatic int iw_valid_channel(int reg_domain, int channel)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(iw_channel_table); i++)\n\t\tif (reg_domain == iw_channel_table[i].reg_domain) {\n\t\t\trc = channel >= iw_channel_table[i].min &&\n\t\t\t     channel <= iw_channel_table[i].max;\n\t\t\tbreak;\n\t\t}\n\treturn rc;\n}\n\n \nstatic int iw_default_channel(int reg_domain)\n{\n\tint i, rc = 1;\n\n\tfor (i = 0; i < ARRAY_SIZE(iw_channel_table); i++)\n\t\tif (reg_domain == iw_channel_table[i].reg_domain) {\n\t\t\trc = iw_channel_table[i].deflt;\n\t\t\tbreak;\n\t\t}\n\treturn rc;\n}\n\nstatic void iw_set_mgmt_info_element(enum iw_mgmt_info_element_ids id,\n\t\t\t\t     struct iw_mgmt_info_element *el,\n\t\t\t\t     void *value, int len)\n{\n\tel->id  = id;\n\tel->len = len;\n\tmemcpy(el->data, value, len);\n}\n\nstatic void iw_copy_mgmt_info_element(struct iw_mgmt_info_element *to,\n\t\t\t\t      struct iw_mgmt_info_element *from)\n{\n\tiw_set_mgmt_info_element(from->id, to, from->data, from->len);\n}\n\nstatic inline void wl3501_switch_page(struct wl3501_card *this, u8 page)\n{\n\twl3501_outb(page, this->base_addr + WL3501_NIC_BSS);\n}\n\n \nstatic int wl3501_get_flash_mac_addr(struct wl3501_card *this)\n{\n\tint base_addr = this->base_addr;\n\n\t \n\twl3501_outb(WL3501_BSS_FPAGE3, base_addr + WL3501_NIC_BSS);  \n\twl3501_outb(0x00, base_addr + WL3501_NIC_LMAL);\t \n\twl3501_outb(0x40, base_addr + WL3501_NIC_LMAH);\t \n\n\t \n\tWL3501_NOPLOOP(100);\n\tthis->mac_addr[0] = inb(base_addr + WL3501_NIC_IODPA);\n\tWL3501_NOPLOOP(100);\n\tthis->mac_addr[1] = inb(base_addr + WL3501_NIC_IODPA);\n\tWL3501_NOPLOOP(100);\n\tthis->mac_addr[2] = inb(base_addr + WL3501_NIC_IODPA);\n\tWL3501_NOPLOOP(100);\n\tthis->mac_addr[3] = inb(base_addr + WL3501_NIC_IODPA);\n\tWL3501_NOPLOOP(100);\n\tthis->mac_addr[4] = inb(base_addr + WL3501_NIC_IODPA);\n\tWL3501_NOPLOOP(100);\n\tthis->mac_addr[5] = inb(base_addr + WL3501_NIC_IODPA);\n\tWL3501_NOPLOOP(100);\n\tthis->reg_domain = inb(base_addr + WL3501_NIC_IODPA);\n\tWL3501_NOPLOOP(100);\n\twl3501_outb(WL3501_BSS_FPAGE0, base_addr + WL3501_NIC_BSS);\n\twl3501_outb(0x04, base_addr + WL3501_NIC_LMAL);\n\twl3501_outb(0x40, base_addr + WL3501_NIC_LMAH);\n\tWL3501_NOPLOOP(100);\n\tthis->version[0] = inb(base_addr + WL3501_NIC_IODPA);\n\tWL3501_NOPLOOP(100);\n\tthis->version[1] = inb(base_addr + WL3501_NIC_IODPA);\n\t \n\twl3501_switch_page(this, WL3501_BSS_SPAGE0);\n\n\t \n\treturn this->mac_addr[0] == 0x00 && this->mac_addr[1] == 0x60;\n}\n\n \nstatic void wl3501_set_to_wla(struct wl3501_card *this, u16 dest, void *src,\n\t\t\t      int size)\n{\n\t \n\twl3501_switch_page(this, (dest & 0x8000) ? WL3501_BSS_SPAGE1 :\n\t\t\t\t\t\t   WL3501_BSS_SPAGE0);\n\t \n\twl3501_outb(dest & 0xff, this->base_addr + WL3501_NIC_LMAL);\n\twl3501_outb(((dest >> 8) & 0x7f), this->base_addr + WL3501_NIC_LMAH);\n\n\t \n\twl3501_outsb(this->base_addr + WL3501_NIC_IODPA, src, size);\n}\n\n \nstatic void wl3501_get_from_wla(struct wl3501_card *this, u16 src, void *dest,\n\t\t\t\tint size)\n{\n\t \n\twl3501_switch_page(this, (src & 0x8000) ? WL3501_BSS_SPAGE1 :\n\t\t\t\t\t\t  WL3501_BSS_SPAGE0);\n\t \n\twl3501_outb(src & 0xff, this->base_addr + WL3501_NIC_LMAL);\n\twl3501_outb((src >> 8) & 0x7f, this->base_addr + WL3501_NIC_LMAH);\n\n\t \n\tinsb(this->base_addr + WL3501_NIC_IODPA, dest, size);\n}\n\n \nstatic u16 wl3501_get_tx_buffer(struct wl3501_card *this, u16 len)\n{\n\tu16 next, blk_cnt = 0, zero = 0;\n\tu16 full_len = sizeof(struct wl3501_80211_tx_hdr) + len;\n\tu16 ret = 0;\n\n\tif (full_len > this->tx_buffer_cnt * 254)\n\t\tgoto out;\n\tret = this->tx_buffer_head;\n\twhile (full_len) {\n\t\tif (full_len < 254)\n\t\t\tfull_len = 0;\n\t\telse\n\t\t\tfull_len -= 254;\n\t\twl3501_get_from_wla(this, this->tx_buffer_head, &next,\n\t\t\t\t    sizeof(next));\n\t\tif (!full_len)\n\t\t\twl3501_set_to_wla(this, this->tx_buffer_head, &zero,\n\t\t\t\t\t  sizeof(zero));\n\t\tthis->tx_buffer_head = next;\n\t\tblk_cnt++;\n\t\t \n\t\tif (!next && full_len) {\n\t\t\tthis->tx_buffer_head = ret;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tthis->tx_buffer_cnt -= blk_cnt;\nout:\n\treturn ret;\n}\n\n \nstatic void wl3501_free_tx_buffer(struct wl3501_card *this, u16 ptr)\n{\n\t \n\tif (!this->tx_buffer_head)\n\t\tthis->tx_buffer_head = ptr;\n\telse\n\t\twl3501_set_to_wla(this, this->tx_buffer_tail,\n\t\t\t\t  &ptr, sizeof(ptr));\n\twhile (ptr) {\n\t\tu16 next;\n\n\t\tthis->tx_buffer_cnt++;\n\t\twl3501_get_from_wla(this, ptr, &next, sizeof(next));\n\t\tthis->tx_buffer_tail = ptr;\n\t\tptr = next;\n\t}\n}\n\nstatic int wl3501_esbq_req_test(struct wl3501_card *this)\n{\n\tu8 tmp = 0;\n\n\twl3501_get_from_wla(this, this->esbq_req_head + 3, &tmp, sizeof(tmp));\n\treturn tmp & 0x80;\n}\n\nstatic void wl3501_esbq_req(struct wl3501_card *this, u16 *ptr)\n{\n\tu16 tmp = 0;\n\n\twl3501_set_to_wla(this, this->esbq_req_head, ptr, 2);\n\twl3501_set_to_wla(this, this->esbq_req_head + 2, &tmp, sizeof(tmp));\n\tthis->esbq_req_head += 4;\n\tif (this->esbq_req_head >= this->esbq_req_end)\n\t\tthis->esbq_req_head = this->esbq_req_start;\n}\n\nstatic int wl3501_esbq_exec(struct wl3501_card *this, void *sig, int sig_size)\n{\n\tint rc = -EIO;\n\n\tif (wl3501_esbq_req_test(this)) {\n\t\tu16 ptr = wl3501_get_tx_buffer(this, sig_size);\n\t\tif (ptr) {\n\t\t\twl3501_set_to_wla(this, ptr, sig, sig_size);\n\t\t\twl3501_esbq_req(this, &ptr);\n\t\t\trc = 0;\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic int wl3501_request_mib(struct wl3501_card *this, u8 index, void *bf)\n{\n\tstruct wl3501_get_req sig = {\n\t\t.sig_id\t    = WL3501_SIG_GET_REQ,\n\t\t.mib_attrib = index,\n\t};\n\tunsigned long flags;\n\tint rc = -EIO;\n\n\tspin_lock_irqsave(&this->lock, flags);\n\tif (wl3501_esbq_req_test(this)) {\n\t\tu16 ptr = wl3501_get_tx_buffer(this, sizeof(sig));\n\t\tif (ptr) {\n\t\t\twl3501_set_to_wla(this, ptr, &sig, sizeof(sig));\n\t\t\twl3501_esbq_req(this, &ptr);\n\t\t\tthis->sig_get_confirm.mib_status = 255;\n\t\t\trc = 0;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&this->lock, flags);\n\n\treturn rc;\n}\n\nstatic int wl3501_get_mib_value(struct wl3501_card *this, u8 index,\n\t\t\t\tvoid *bf, int size)\n{\n\tint rc;\n\n\trc = wl3501_request_mib(this, index, bf);\n\tif (rc)\n\t\treturn rc;\n\n\trc = wait_event_interruptible(this->wait,\n\t\tthis->sig_get_confirm.mib_status != 255);\n\tif (rc)\n\t\treturn rc;\n\n\tmemcpy(bf, this->sig_get_confirm.mib_value, size);\n\treturn 0;\n}\n\nstatic int wl3501_pwr_mgmt(struct wl3501_card *this, int suspend)\n{\n\tstruct wl3501_pwr_mgmt_req sig = {\n\t\t.sig_id\t\t= WL3501_SIG_PWR_MGMT_REQ,\n\t\t.pwr_save\t= suspend,\n\t\t.wake_up\t= !suspend,\n\t\t.receive_dtims\t= 10,\n\t};\n\tunsigned long flags;\n\tint rc = -EIO;\n\n\tspin_lock_irqsave(&this->lock, flags);\n\tif (wl3501_esbq_req_test(this)) {\n\t\tu16 ptr = wl3501_get_tx_buffer(this, sizeof(sig));\n\t\tif (ptr) {\n\t\t\twl3501_set_to_wla(this, ptr, &sig, sizeof(sig));\n\t\t\twl3501_esbq_req(this, &ptr);\n\t\t\tthis->sig_pwr_mgmt_confirm.status = 255;\n\t\t\tspin_unlock_irqrestore(&this->lock, flags);\n\t\t\trc = wait_event_interruptible(this->wait,\n\t\t\t\tthis->sig_pwr_mgmt_confirm.status != 255);\n\t\t\tprintk(KERN_INFO \"%s: %s status=%d\\n\", __func__,\n\t\t\t       suspend ? \"suspend\" : \"resume\",\n\t\t\t       this->sig_pwr_mgmt_confirm.status);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&this->lock, flags);\nout:\n\treturn rc;\n}\n\n \nstatic int wl3501_send_pkt(struct wl3501_card *this, u8 *data, u16 len)\n{\n\tu16 bf, sig_bf, next, tmplen, pktlen;\n\tstruct wl3501_md_req sig = {\n\t\t.sig_id = WL3501_SIG_MD_REQ,\n\t};\n\tsize_t sig_addr_len = sizeof(sig.addr);\n\tu8 *pdata = (char *)data;\n\tint rc = -EIO;\n\n\tif (wl3501_esbq_req_test(this)) {\n\t\tsig_bf = wl3501_get_tx_buffer(this, sizeof(sig));\n\t\trc = -ENOMEM;\n\t\tif (!sig_bf)\t \n\t\t\tgoto out;\n\t\tbf = wl3501_get_tx_buffer(this, len + 26 + 24);\n\t\tif (!bf) {\n\t\t\t \n\t\t\twl3501_free_tx_buffer(this, sig_bf);\n\t\t\tgoto out;\n\t\t}\n\t\trc = 0;\n\t\tmemcpy(&sig.addr, pdata, sig_addr_len);\n\t\tpktlen = len - sig_addr_len;\n\t\tpdata += sig_addr_len;\n\t\tsig.data = bf;\n\t\tif (((*pdata) * 256 + (*(pdata + 1))) > 1500) {\n\t\t\tu8 addr4[ETH_ALEN] = {\n\t\t\t\t[0] = 0xAA, [1] = 0xAA, [2] = 0x03, [4] = 0x00,\n\t\t\t};\n\n\t\t\twl3501_set_to_wla(this, bf + 2 +\n\t\t\t\t\t  offsetof(struct wl3501_tx_hdr, addr4),\n\t\t\t\t\t  addr4, sizeof(addr4));\n\t\t\tsig.size = pktlen + 24 + 4 + 6;\n\t\t\tif (pktlen > (254 - sizeof(struct wl3501_tx_hdr))) {\n\t\t\t\ttmplen = 254 - sizeof(struct wl3501_tx_hdr);\n\t\t\t\tpktlen -= tmplen;\n\t\t\t} else {\n\t\t\t\ttmplen = pktlen;\n\t\t\t\tpktlen = 0;\n\t\t\t}\n\t\t\twl3501_set_to_wla(this,\n\t\t\t\t\t  bf + 2 + sizeof(struct wl3501_tx_hdr),\n\t\t\t\t\t  pdata, tmplen);\n\t\t\tpdata += tmplen;\n\t\t\twl3501_get_from_wla(this, bf, &next, sizeof(next));\n\t\t\tbf = next;\n\t\t} else {\n\t\t\tsig.size = pktlen + 24 + 4 - 2;\n\t\t\tpdata += 2;\n\t\t\tpktlen -= 2;\n\t\t\tif (pktlen > (254 - sizeof(struct wl3501_tx_hdr) + 6)) {\n\t\t\t\ttmplen = 254 - sizeof(struct wl3501_tx_hdr) + 6;\n\t\t\t\tpktlen -= tmplen;\n\t\t\t} else {\n\t\t\t\ttmplen = pktlen;\n\t\t\t\tpktlen = 0;\n\t\t\t}\n\t\t\twl3501_set_to_wla(this, bf + 2 +\n\t\t\t\t\t  offsetof(struct wl3501_tx_hdr, addr4),\n\t\t\t\t\t  pdata, tmplen);\n\t\t\tpdata += tmplen;\n\t\t\twl3501_get_from_wla(this, bf, &next, sizeof(next));\n\t\t\tbf = next;\n\t\t}\n\t\twhile (pktlen > 0) {\n\t\t\tif (pktlen > 254) {\n\t\t\t\ttmplen = 254;\n\t\t\t\tpktlen -= 254;\n\t\t\t} else {\n\t\t\t\ttmplen = pktlen;\n\t\t\t\tpktlen = 0;\n\t\t\t}\n\t\t\twl3501_set_to_wla(this, bf + 2, pdata, tmplen);\n\t\t\tpdata += tmplen;\n\t\t\twl3501_get_from_wla(this, bf, &next, sizeof(next));\n\t\t\tbf = next;\n\t\t}\n\t\twl3501_set_to_wla(this, sig_bf, &sig, sizeof(sig));\n\t\twl3501_esbq_req(this, &sig_bf);\n\t}\nout:\n\treturn rc;\n}\n\nstatic int wl3501_mgmt_resync(struct wl3501_card *this)\n{\n\tstruct wl3501_resync_req sig = {\n\t\t.sig_id = WL3501_SIG_RESYNC_REQ,\n\t};\n\n\treturn wl3501_esbq_exec(this, &sig, sizeof(sig));\n}\n\nstatic inline int wl3501_fw_bss_type(struct wl3501_card *this)\n{\n\treturn this->net_type == IW_MODE_INFRA ? WL3501_NET_TYPE_INFRA :\n\t\t\t\t\t\t WL3501_NET_TYPE_ADHOC;\n}\n\nstatic inline int wl3501_fw_cap_info(struct wl3501_card *this)\n{\n\treturn this->net_type == IW_MODE_INFRA ? WL3501_MGMT_CAPABILITY_ESS :\n\t\t\t\t\t\t WL3501_MGMT_CAPABILITY_IBSS;\n}\n\nstatic int wl3501_mgmt_scan(struct wl3501_card *this, u16 chan_time)\n{\n\tstruct wl3501_scan_req sig = {\n\t\t.sig_id\t\t= WL3501_SIG_SCAN_REQ,\n\t\t.scan_type\t= WL3501_SCAN_TYPE_ACTIVE,\n\t\t.probe_delay\t= 0x10,\n\t\t.min_chan_time\t= chan_time,\n\t\t.max_chan_time\t= chan_time,\n\t\t.bss_type\t= wl3501_fw_bss_type(this),\n\t};\n\n\tthis->bss_cnt = this->join_sta_bss = 0;\n\treturn wl3501_esbq_exec(this, &sig, sizeof(sig));\n}\n\nstatic int wl3501_mgmt_join(struct wl3501_card *this, u16 stas)\n{\n\tstruct wl3501_join_req sig = {\n\t\t.sig_id\t\t  = WL3501_SIG_JOIN_REQ,\n\t\t.timeout\t  = 10,\n\t\t.req.ds_pset = {\n\t\t\t.el = {\n\t\t\t\t.id  = IW_MGMT_INFO_ELEMENT_DS_PARAMETER_SET,\n\t\t\t\t.len = 1,\n\t\t\t},\n\t\t\t.chan\t= this->chan,\n\t\t},\n\t};\n\n\tmemcpy(&sig.req, &this->bss_set[stas].req, sizeof(sig.req));\n\treturn wl3501_esbq_exec(this, &sig, sizeof(sig));\n}\n\nstatic int wl3501_mgmt_start(struct wl3501_card *this)\n{\n\tstruct wl3501_start_req sig = {\n\t\t.sig_id\t\t\t= WL3501_SIG_START_REQ,\n\t\t.beacon_period\t\t= 400,\n\t\t.dtim_period\t\t= 1,\n\t\t.ds_pset = {\n\t\t\t.el = {\n\t\t\t\t.id  = IW_MGMT_INFO_ELEMENT_DS_PARAMETER_SET,\n\t\t\t\t.len = 1,\n\t\t\t},\n\t\t\t.chan\t= this->chan,\n\t\t},\n\t\t.bss_basic_rset\t= {\n\t\t\t.el = {\n\t\t\t\t.id\t= IW_MGMT_INFO_ELEMENT_SUPPORTED_RATES,\n\t\t\t\t.len = 2,\n\t\t\t},\n\t\t\t.data_rate_labels = {\n\t\t\t\t[0] = IW_MGMT_RATE_LABEL_MANDATORY |\n\t\t\t\t      IW_MGMT_RATE_LABEL_1MBIT,\n\t\t\t\t[1] = IW_MGMT_RATE_LABEL_MANDATORY |\n\t\t\t\t      IW_MGMT_RATE_LABEL_2MBIT,\n\t\t\t},\n\t\t},\n\t\t.operational_rset\t= {\n\t\t\t.el = {\n\t\t\t\t.id\t= IW_MGMT_INFO_ELEMENT_SUPPORTED_RATES,\n\t\t\t\t.len = 2,\n\t\t\t},\n\t\t\t.data_rate_labels = {\n\t\t\t\t[0] = IW_MGMT_RATE_LABEL_MANDATORY |\n\t\t\t\t      IW_MGMT_RATE_LABEL_1MBIT,\n\t\t\t\t[1] = IW_MGMT_RATE_LABEL_MANDATORY |\n\t\t\t\t      IW_MGMT_RATE_LABEL_2MBIT,\n\t\t\t},\n\t\t},\n\t\t.ibss_pset\t\t= {\n\t\t\t.el = {\n\t\t\t\t.id\t = IW_MGMT_INFO_ELEMENT_IBSS_PARAMETER_SET,\n\t\t\t\t.len     = 2,\n\t\t\t},\n\t\t\t.atim_window = 10,\n\t\t},\n\t\t.bss_type\t\t= wl3501_fw_bss_type(this),\n\t\t.cap_info\t\t= wl3501_fw_cap_info(this),\n\t};\n\n\tiw_copy_mgmt_info_element(&sig.ssid.el, &this->essid.el);\n\tiw_copy_mgmt_info_element(&this->keep_essid.el, &this->essid.el);\n\treturn wl3501_esbq_exec(this, &sig, sizeof(sig));\n}\n\nstatic void wl3501_mgmt_scan_confirm(struct wl3501_card *this, u16 addr)\n{\n\tu16 i = 0;\n\tint matchflag = 0;\n\tstruct wl3501_scan_confirm sig;\n\n\tpr_debug(\"entry\");\n\twl3501_get_from_wla(this, addr, &sig, sizeof(sig));\n\tif (sig.status == WL3501_STATUS_SUCCESS) {\n\t\tpr_debug(\"success\");\n\t\tif ((this->net_type == IW_MODE_INFRA &&\n\t\t     (sig.req.cap_info & WL3501_MGMT_CAPABILITY_ESS)) ||\n\t\t    (this->net_type == IW_MODE_ADHOC &&\n\t\t     (sig.req.cap_info & WL3501_MGMT_CAPABILITY_IBSS)) ||\n\t\t    this->net_type == IW_MODE_AUTO) {\n\t\t\tif (!this->essid.el.len)\n\t\t\t\tmatchflag = 1;\n\t\t\telse if (this->essid.el.len == 3 &&\n\t\t\t\t !memcmp(this->essid.essid, \"ANY\", 3))\n\t\t\t\tmatchflag = 1;\n\t\t\telse if (this->essid.el.len != sig.req.ssid.el.len)\n\t\t\t\tmatchflag = 0;\n\t\t\telse if (memcmp(this->essid.essid, sig.req.ssid.essid,\n\t\t\t\t\tthis->essid.el.len))\n\t\t\t\tmatchflag = 0;\n\t\t\telse\n\t\t\t\tmatchflag = 1;\n\t\t\tif (matchflag) {\n\t\t\t\tfor (i = 0; i < this->bss_cnt; i++) {\n\t\t\t\t\tif (ether_addr_equal_unaligned(this->bss_set[i].req.bssid,\n\t\t\t\t\t\t\t\t       sig.req.bssid)) {\n\t\t\t\t\t\tmatchflag = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (matchflag && (i < 20)) {\n\t\t\t\tmemcpy(&this->bss_set[i].req,\n\t\t\t\t       &sig.req, sizeof(sig.req));\n\t\t\t\tthis->bss_cnt++;\n\t\t\t\tthis->rssi = sig.rssi;\n\t\t\t\tthis->bss_set[i].rssi = sig.rssi;\n\t\t\t}\n\t\t}\n\t} else if (sig.status == WL3501_STATUS_TIMEOUT) {\n\t\tpr_debug(\"timeout\");\n\t\tthis->join_sta_bss = 0;\n\t\tfor (i = this->join_sta_bss; i < this->bss_cnt; i++)\n\t\t\tif (!wl3501_mgmt_join(this, i))\n\t\t\t\tbreak;\n\t\tthis->join_sta_bss = i;\n\t\tif (this->join_sta_bss == this->bss_cnt) {\n\t\t\tif (this->net_type == IW_MODE_INFRA)\n\t\t\t\twl3501_mgmt_scan(this, 100);\n\t\t\telse {\n\t\t\t\tthis->adhoc_times++;\n\t\t\t\tif (this->adhoc_times > WL3501_MAX_ADHOC_TRIES)\n\t\t\t\t\twl3501_mgmt_start(this);\n\t\t\t\telse\n\t\t\t\t\twl3501_mgmt_scan(this, 100);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic int wl3501_block_interrupt(struct wl3501_card *this)\n{\n\tu8 old = inb(this->base_addr + WL3501_NIC_GCR);\n\tu8 new = old & (~(WL3501_GCR_ECINT | WL3501_GCR_INT2EC |\n\t\t\tWL3501_GCR_ENECINT));\n\n\twl3501_outb(new, this->base_addr + WL3501_NIC_GCR);\n\treturn old & WL3501_GCR_ENECINT;\n}\n\n \nstatic int wl3501_unblock_interrupt(struct wl3501_card *this)\n{\n\tu8 old = inb(this->base_addr + WL3501_NIC_GCR);\n\tu8 new = (old & ~(WL3501_GCR_ECINT | WL3501_GCR_INT2EC)) |\n\t\t  WL3501_GCR_ENECINT;\n\n\twl3501_outb(new, this->base_addr + WL3501_NIC_GCR);\n\treturn old & WL3501_GCR_ENECINT;\n}\n\n \nstatic u16 wl3501_receive(struct wl3501_card *this, u8 *bf, u16 size)\n{\n\tu16 next_addr, next_addr1;\n\tu8 *data = bf + 12;\n\n\tsize -= 12;\n\twl3501_get_from_wla(this, this->start_seg + 2,\n\t\t\t    &next_addr, sizeof(next_addr));\n\tif (size > WL3501_BLKSZ - sizeof(struct wl3501_rx_hdr)) {\n\t\twl3501_get_from_wla(this,\n\t\t\t\t    this->start_seg +\n\t\t\t\t\tsizeof(struct wl3501_rx_hdr), data,\n\t\t\t\t    WL3501_BLKSZ -\n\t\t\t\t\tsizeof(struct wl3501_rx_hdr));\n\t\tsize -= WL3501_BLKSZ - sizeof(struct wl3501_rx_hdr);\n\t\tdata += WL3501_BLKSZ - sizeof(struct wl3501_rx_hdr);\n\t} else {\n\t\twl3501_get_from_wla(this,\n\t\t\t\t    this->start_seg +\n\t\t\t\t\tsizeof(struct wl3501_rx_hdr),\n\t\t\t\t    data, size);\n\t\tsize = 0;\n\t}\n\twhile (size > 0) {\n\t\tif (size > WL3501_BLKSZ - 5) {\n\t\t\twl3501_get_from_wla(this, next_addr + 5, data,\n\t\t\t\t\t    WL3501_BLKSZ - 5);\n\t\t\tsize -= WL3501_BLKSZ - 5;\n\t\t\tdata += WL3501_BLKSZ - 5;\n\t\t\twl3501_get_from_wla(this, next_addr + 2, &next_addr1,\n\t\t\t\t\t    sizeof(next_addr1));\n\t\t\tnext_addr = next_addr1;\n\t\t} else {\n\t\t\twl3501_get_from_wla(this, next_addr + 5, data, size);\n\t\t\tsize = 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void wl3501_esbq_req_free(struct wl3501_card *this)\n{\n\tu8 tmp;\n\tu16 addr;\n\n\tif (this->esbq_req_head == this->esbq_req_tail)\n\t\tgoto out;\n\twl3501_get_from_wla(this, this->esbq_req_tail + 3, &tmp, sizeof(tmp));\n\tif (!(tmp & 0x80))\n\t\tgoto out;\n\twl3501_get_from_wla(this, this->esbq_req_tail, &addr, sizeof(addr));\n\twl3501_free_tx_buffer(this, addr);\n\tthis->esbq_req_tail += 4;\n\tif (this->esbq_req_tail >= this->esbq_req_end)\n\t\tthis->esbq_req_tail = this->esbq_req_start;\nout:\n\treturn;\n}\n\nstatic int wl3501_esbq_confirm(struct wl3501_card *this)\n{\n\tu8 tmp;\n\n\twl3501_get_from_wla(this, this->esbq_confirm + 3, &tmp, sizeof(tmp));\n\treturn tmp & 0x80;\n}\n\nstatic void wl3501_online(struct net_device *dev)\n{\n\tstruct wl3501_card *this = netdev_priv(dev);\n\n\tprintk(KERN_INFO \"%s: Wireless LAN online. BSSID: %pM\\n\",\n\t       dev->name, this->bssid);\n\tnetif_wake_queue(dev);\n}\n\nstatic void wl3501_esbq_confirm_done(struct wl3501_card *this)\n{\n\tu8 tmp = 0;\n\n\twl3501_set_to_wla(this, this->esbq_confirm + 3, &tmp, sizeof(tmp));\n\tthis->esbq_confirm += 4;\n\tif (this->esbq_confirm >= this->esbq_confirm_end)\n\t\tthis->esbq_confirm = this->esbq_confirm_start;\n}\n\nstatic int wl3501_mgmt_auth(struct wl3501_card *this)\n{\n\tstruct wl3501_auth_req sig = {\n\t\t.sig_id\t = WL3501_SIG_AUTH_REQ,\n\t\t.type\t = WL3501_SYS_TYPE_OPEN,\n\t\t.timeout = 1000,\n\t};\n\n\tpr_debug(\"entry\");\n\tmemcpy(sig.mac_addr, this->bssid, ETH_ALEN);\n\treturn wl3501_esbq_exec(this, &sig, sizeof(sig));\n}\n\nstatic int wl3501_mgmt_association(struct wl3501_card *this)\n{\n\tstruct wl3501_assoc_req sig = {\n\t\t.sig_id\t\t = WL3501_SIG_ASSOC_REQ,\n\t\t.timeout\t = 1000,\n\t\t.listen_interval = 5,\n\t\t.cap_info\t = this->cap_info,\n\t};\n\n\tpr_debug(\"entry\");\n\tmemcpy(sig.mac_addr, this->bssid, ETH_ALEN);\n\treturn wl3501_esbq_exec(this, &sig, sizeof(sig));\n}\n\nstatic void wl3501_mgmt_join_confirm(struct net_device *dev, u16 addr)\n{\n\tstruct wl3501_card *this = netdev_priv(dev);\n\tstruct wl3501_join_confirm sig;\n\n\tpr_debug(\"entry\");\n\twl3501_get_from_wla(this, addr, &sig, sizeof(sig));\n\tif (sig.status == WL3501_STATUS_SUCCESS) {\n\t\tif (this->net_type == IW_MODE_INFRA) {\n\t\t\tif (this->join_sta_bss < this->bss_cnt) {\n\t\t\t\tconst int i = this->join_sta_bss;\n\t\t\t\tmemcpy(this->bssid,\n\t\t\t\t       this->bss_set[i].req.bssid, ETH_ALEN);\n\t\t\t\tthis->chan = this->bss_set[i].req.ds_pset.chan;\n\t\t\t\tiw_copy_mgmt_info_element(&this->keep_essid.el,\n\t\t\t\t\t\t     &this->bss_set[i].req.ssid.el);\n\t\t\t\twl3501_mgmt_auth(this);\n\t\t\t}\n\t\t} else {\n\t\t\tconst int i = this->join_sta_bss;\n\n\t\t\tmemcpy(&this->bssid, &this->bss_set[i].req.bssid, ETH_ALEN);\n\t\t\tthis->chan = this->bss_set[i].req.ds_pset.chan;\n\t\t\tiw_copy_mgmt_info_element(&this->keep_essid.el,\n\t\t\t\t\t\t  &this->bss_set[i].req.ssid.el);\n\t\t\twl3501_online(dev);\n\t\t}\n\t} else {\n\t\tint i;\n\t\tthis->join_sta_bss++;\n\t\tfor (i = this->join_sta_bss; i < this->bss_cnt; i++)\n\t\t\tif (!wl3501_mgmt_join(this, i))\n\t\t\t\tbreak;\n\t\tthis->join_sta_bss = i;\n\t\tif (this->join_sta_bss == this->bss_cnt) {\n\t\t\tif (this->net_type == IW_MODE_INFRA)\n\t\t\t\twl3501_mgmt_scan(this, 100);\n\t\t\telse {\n\t\t\t\tthis->adhoc_times++;\n\t\t\t\tif (this->adhoc_times > WL3501_MAX_ADHOC_TRIES)\n\t\t\t\t\twl3501_mgmt_start(this);\n\t\t\t\telse\n\t\t\t\t\twl3501_mgmt_scan(this, 100);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic inline void wl3501_alarm_interrupt(struct net_device *dev,\n\t\t\t\t\t  struct wl3501_card *this)\n{\n\tif (this->net_type == IW_MODE_INFRA) {\n\t\tprintk(KERN_INFO \"Wireless LAN offline\\n\");\n\t\tnetif_stop_queue(dev);\n\t\twl3501_mgmt_resync(this);\n\t}\n}\n\nstatic inline void wl3501_md_confirm_interrupt(struct net_device *dev,\n\t\t\t\t\t       struct wl3501_card *this,\n\t\t\t\t\t       u16 addr)\n{\n\tstruct wl3501_md_confirm sig;\n\n\tpr_debug(\"entry\");\n\twl3501_get_from_wla(this, addr, &sig, sizeof(sig));\n\twl3501_free_tx_buffer(this, sig.data);\n\tif (netif_queue_stopped(dev))\n\t\tnetif_wake_queue(dev);\n}\n\nstatic inline void wl3501_md_ind_interrupt(struct net_device *dev,\n\t\t\t\t\t   struct wl3501_card *this, u16 addr)\n{\n\tstruct wl3501_md_ind sig;\n\tstruct sk_buff *skb;\n\tu8 rssi, addr4[ETH_ALEN];\n\tu16 pkt_len;\n\n\twl3501_get_from_wla(this, addr, &sig, sizeof(sig));\n\tthis->start_seg = sig.data;\n\twl3501_get_from_wla(this,\n\t\t\t    sig.data + offsetof(struct wl3501_rx_hdr, rssi),\n\t\t\t    &rssi, sizeof(rssi));\n\tthis->rssi = rssi <= 63 ? (rssi * 100) / 64 : 255;\n\n\twl3501_get_from_wla(this,\n\t\t\t    sig.data +\n\t\t\t\toffsetof(struct wl3501_rx_hdr, addr4),\n\t\t\t    &addr4, sizeof(addr4));\n\tif (!(addr4[0] == 0xAA && addr4[1] == 0xAA &&\n\t      addr4[2] == 0x03 && addr4[4] == 0x00)) {\n\t\tprintk(KERN_INFO \"Unsupported packet type!\\n\");\n\t\treturn;\n\t}\n\tpkt_len = sig.size + 12 - 24 - 4 - 6;\n\n\tskb = dev_alloc_skb(pkt_len + 5);\n\n\tif (!skb) {\n\t\tprintk(KERN_WARNING \"%s: Can't alloc a sk_buff of size %d.\\n\",\n\t\t       dev->name, pkt_len);\n\t\tdev->stats.rx_dropped++;\n\t} else {\n\t\tskb->dev = dev;\n\t\tskb_reserve(skb, 2);  \n\t\tskb_copy_to_linear_data(skb, (unsigned char *)&sig.addr,\n\t\t\t\t\tsizeof(sig.addr));\n\t\twl3501_receive(this, skb->data, pkt_len);\n\t\tskb_put(skb, pkt_len);\n\t\tskb->protocol\t= eth_type_trans(skb, dev);\n\t\tdev->stats.rx_packets++;\n\t\tdev->stats.rx_bytes += skb->len;\n\t\tnetif_rx(skb);\n\t}\n}\n\nstatic inline void wl3501_get_confirm_interrupt(struct wl3501_card *this,\n\t\t\t\t\t\tu16 addr, void *sig, int size)\n{\n\tpr_debug(\"entry\");\n\twl3501_get_from_wla(this, addr, &this->sig_get_confirm,\n\t\t\t    sizeof(this->sig_get_confirm));\n\twake_up(&this->wait);\n}\n\nstatic inline void wl3501_start_confirm_interrupt(struct net_device *dev,\n\t\t\t\t\t\t  struct wl3501_card *this,\n\t\t\t\t\t\t  u16 addr)\n{\n\tstruct wl3501_start_confirm sig;\n\n\tpr_debug(\"entry\");\n\twl3501_get_from_wla(this, addr, &sig, sizeof(sig));\n\tif (sig.status == WL3501_STATUS_SUCCESS)\n\t\tnetif_wake_queue(dev);\n}\n\nstatic inline void wl3501_assoc_confirm_interrupt(struct net_device *dev,\n\t\t\t\t\t\t  u16 addr)\n{\n\tstruct wl3501_card *this = netdev_priv(dev);\n\tstruct wl3501_assoc_confirm sig;\n\n\tpr_debug(\"entry\");\n\twl3501_get_from_wla(this, addr, &sig, sizeof(sig));\n\n\tif (sig.status == WL3501_STATUS_SUCCESS)\n\t\twl3501_online(dev);\n}\n\nstatic inline void wl3501_auth_confirm_interrupt(struct wl3501_card *this,\n\t\t\t\t\t\t u16 addr)\n{\n\tstruct wl3501_auth_confirm sig;\n\n\tpr_debug(\"entry\");\n\twl3501_get_from_wla(this, addr, &sig, sizeof(sig));\n\n\tif (sig.status == WL3501_STATUS_SUCCESS)\n\t\twl3501_mgmt_association(this);\n\telse\n\t\twl3501_mgmt_resync(this);\n}\n\nstatic inline void wl3501_rx_interrupt(struct net_device *dev)\n{\n\tint morepkts;\n\tu16 addr;\n\tu8 sig_id;\n\tstruct wl3501_card *this = netdev_priv(dev);\n\n\tpr_debug(\"entry\");\nloop:\n\tmorepkts = 0;\n\tif (!wl3501_esbq_confirm(this))\n\t\tgoto free;\n\twl3501_get_from_wla(this, this->esbq_confirm, &addr, sizeof(addr));\n\twl3501_get_from_wla(this, addr + 2, &sig_id, sizeof(sig_id));\n\n\tswitch (sig_id) {\n\tcase WL3501_SIG_DEAUTH_IND:\n\tcase WL3501_SIG_DISASSOC_IND:\n\tcase WL3501_SIG_ALARM:\n\t\twl3501_alarm_interrupt(dev, this);\n\t\tbreak;\n\tcase WL3501_SIG_MD_CONFIRM:\n\t\twl3501_md_confirm_interrupt(dev, this, addr);\n\t\tbreak;\n\tcase WL3501_SIG_MD_IND:\n\t\twl3501_md_ind_interrupt(dev, this, addr);\n\t\tbreak;\n\tcase WL3501_SIG_GET_CONFIRM:\n\t\twl3501_get_confirm_interrupt(this, addr,\n\t\t\t\t\t     &this->sig_get_confirm,\n\t\t\t\t\t     sizeof(this->sig_get_confirm));\n\t\tbreak;\n\tcase WL3501_SIG_PWR_MGMT_CONFIRM:\n\t\twl3501_get_confirm_interrupt(this, addr,\n\t\t\t\t\t     &this->sig_pwr_mgmt_confirm,\n\t\t\t\t\t    sizeof(this->sig_pwr_mgmt_confirm));\n\t\tbreak;\n\tcase WL3501_SIG_START_CONFIRM:\n\t\twl3501_start_confirm_interrupt(dev, this, addr);\n\t\tbreak;\n\tcase WL3501_SIG_SCAN_CONFIRM:\n\t\twl3501_mgmt_scan_confirm(this, addr);\n\t\tbreak;\n\tcase WL3501_SIG_JOIN_CONFIRM:\n\t\twl3501_mgmt_join_confirm(dev, addr);\n\t\tbreak;\n\tcase WL3501_SIG_ASSOC_CONFIRM:\n\t\twl3501_assoc_confirm_interrupt(dev, addr);\n\t\tbreak;\n\tcase WL3501_SIG_AUTH_CONFIRM:\n\t\twl3501_auth_confirm_interrupt(this, addr);\n\t\tbreak;\n\tcase WL3501_SIG_RESYNC_CONFIRM:\n\t\twl3501_mgmt_resync(this);  \n\t\tbreak;\n\t}\n\twl3501_esbq_confirm_done(this);\n\tmorepkts = 1;\n\t \nfree:\n\twl3501_esbq_req_free(this);\n\tif (morepkts)\n\t\tgoto loop;\n}\n\nstatic inline void wl3501_ack_interrupt(struct wl3501_card *this)\n{\n\twl3501_outb(WL3501_GCR_ECINT, this->base_addr + WL3501_NIC_GCR);\n}\n\n \nstatic irqreturn_t wl3501_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct wl3501_card *this;\n\n\tthis = netdev_priv(dev);\n\tspin_lock(&this->lock);\n\twl3501_ack_interrupt(this);\n\twl3501_block_interrupt(this);\n\twl3501_rx_interrupt(dev);\n\twl3501_unblock_interrupt(this);\n\tspin_unlock(&this->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int wl3501_reset_board(struct wl3501_card *this)\n{\n\tu8 tmp = 0;\n\tint i, rc = 0;\n\n\t \n\twl3501_outb_p(WL3501_GCR_CORESET, this->base_addr + WL3501_NIC_GCR);\n\twl3501_outb_p(0, this->base_addr + WL3501_NIC_GCR);\n\twl3501_outb_p(WL3501_GCR_CORESET, this->base_addr + WL3501_NIC_GCR);\n\n\t \n\twl3501_set_to_wla(this, 0x480, &tmp, sizeof(tmp));\n\n\t \n\twl3501_outb_p(0, this->base_addr + WL3501_NIC_GCR);\n\n\tWL3501_NOPLOOP(1024 * 50);\n\n\twl3501_unblock_interrupt(this);\t \n\n\t \n\tfor (i = 0; i < 10000; i++) {\n\t\twl3501_get_from_wla(this, 0x480, &tmp, sizeof(tmp));\n\n\t\tif (tmp == 'W') {\n\t\t\t \n\t\t\ttmp = 'A';\n\t\t\twl3501_set_to_wla(this, 0x480, &tmp, sizeof(tmp));\n\t\t\tgoto out;\n\t\t}\n\t\tWL3501_NOPLOOP(10);\n\t}\n\tprintk(KERN_WARNING \"%s: failed to reset the board!\\n\", __func__);\n\trc = -ENODEV;\nout:\n\treturn rc;\n}\n\nstatic int wl3501_init_firmware(struct wl3501_card *this)\n{\n\tu16 ptr, next;\n\tint rc = wl3501_reset_board(this);\n\n\tif (rc)\n\t\tgoto fail;\n\tthis->card_name[0] = '\\0';\n\twl3501_get_from_wla(this, 0x1a00,\n\t\t\t    this->card_name, sizeof(this->card_name));\n\tthis->card_name[sizeof(this->card_name) - 1] = '\\0';\n\tthis->firmware_date[0] = '\\0';\n\twl3501_get_from_wla(this, 0x1a40,\n\t\t\t    this->firmware_date, sizeof(this->firmware_date));\n\tthis->firmware_date[sizeof(this->firmware_date) - 1] = '\\0';\n\t \n\twl3501_switch_page(this, WL3501_BSS_SPAGE0);\n\t \n\twl3501_get_from_wla(this, 0x482, &this->esbq_req_start, 2);\n\twl3501_get_from_wla(this, 0x486, &this->esbq_req_end, 2);\n\twl3501_get_from_wla(this, 0x488, &this->esbq_confirm_start, 2);\n\twl3501_get_from_wla(this, 0x48c, &this->esbq_confirm_end, 2);\n\twl3501_get_from_wla(this, 0x48e, &this->tx_buffer_head, 2);\n\twl3501_get_from_wla(this, 0x492, &this->tx_buffer_size, 2);\n\tthis->esbq_req_tail\t= this->esbq_req_head = this->esbq_req_start;\n\tthis->esbq_req_end     += this->esbq_req_start;\n\tthis->esbq_confirm\t= this->esbq_confirm_start;\n\tthis->esbq_confirm_end += this->esbq_confirm_start;\n\t \n\tthis->tx_buffer_cnt = 1;\n\tptr = this->tx_buffer_head;\n\tnext = ptr + WL3501_BLKSZ;\n\twhile ((next - this->tx_buffer_head) < this->tx_buffer_size) {\n\t\tthis->tx_buffer_cnt++;\n\t\twl3501_set_to_wla(this, ptr, &next, sizeof(next));\n\t\tptr = next;\n\t\tnext = ptr + WL3501_BLKSZ;\n\t}\n\trc = 0;\n\tnext = 0;\n\twl3501_set_to_wla(this, ptr, &next, sizeof(next));\n\tthis->tx_buffer_tail = ptr;\nout:\n\treturn rc;\nfail:\n\tprintk(KERN_WARNING \"%s: failed!\\n\", __func__);\n\tgoto out;\n}\n\nstatic int wl3501_close(struct net_device *dev)\n{\n\tstruct wl3501_card *this = netdev_priv(dev);\n\tunsigned long flags;\n\tstruct pcmcia_device *link;\n\tlink = this->p_dev;\n\n\tspin_lock_irqsave(&this->lock, flags);\n\tlink->open--;\n\n\t \n\tnetif_stop_queue(dev);\n\twl3501_ack_interrupt(this);\n\n\t \n\twl3501_block_interrupt(this);\n\n\tprintk(KERN_INFO \"%s: WL3501 closed\\n\", dev->name);\n\tspin_unlock_irqrestore(&this->lock, flags);\n\treturn 0;\n}\n\n \nstatic int wl3501_reset(struct net_device *dev)\n{\n\tstruct wl3501_card *this = netdev_priv(dev);\n\tint rc = -ENODEV;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&this->lock, flags);\n\twl3501_block_interrupt(this);\n\n\tif (wl3501_init_firmware(this)) {\n\t\tprintk(KERN_WARNING \"%s: Can't initialize Firmware!\\n\",\n\t\t       dev->name);\n\t\t \n\t\tfree_irq(dev->irq, dev);\n\t\tgoto out;\n\t}\n\n\t \n\tnetif_stop_queue(dev);\n\tthis->adhoc_times = 0;\n\twl3501_ack_interrupt(this);\n\twl3501_unblock_interrupt(this);\n\twl3501_mgmt_scan(this, 100);\n\tpr_debug(\"%s: device reset\", dev->name);\n\trc = 0;\nout:\n\tspin_unlock_irqrestore(&this->lock, flags);\n\treturn rc;\n}\n\nstatic void wl3501_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct net_device_stats *stats = &dev->stats;\n\tint rc;\n\n\tstats->tx_errors++;\n\trc = wl3501_reset(dev);\n\tif (rc)\n\t\tprintk(KERN_ERR \"%s: Error %d resetting card on Tx timeout!\\n\",\n\t\t       dev->name, rc);\n\telse {\n\t\tnetif_trans_update(dev);  \n\t\tnetif_wake_queue(dev);\n\t}\n}\n\n \nstatic netdev_tx_t wl3501_hard_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t\tstruct net_device *dev)\n{\n\tint enabled, rc;\n\tstruct wl3501_card *this = netdev_priv(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&this->lock, flags);\n\tenabled = wl3501_block_interrupt(this);\n\trc = wl3501_send_pkt(this, skb->data, skb->len);\n\tif (enabled)\n\t\twl3501_unblock_interrupt(this);\n\tif (rc) {\n\t\t++dev->stats.tx_dropped;\n\t\tnetif_stop_queue(dev);\n\t} else {\n\t\t++dev->stats.tx_packets;\n\t\tdev->stats.tx_bytes += skb->len;\n\t\tdev_kfree_skb_irq(skb);\n\n\t\tif (this->tx_buffer_cnt < 2)\n\t\t\tnetif_stop_queue(dev);\n\t}\n\tspin_unlock_irqrestore(&this->lock, flags);\n\treturn NETDEV_TX_OK;\n}\n\nstatic int wl3501_open(struct net_device *dev)\n{\n\tint rc = -ENODEV;\n\tstruct wl3501_card *this = netdev_priv(dev);\n\tunsigned long flags;\n\tstruct pcmcia_device *link;\n\tlink = this->p_dev;\n\n\tspin_lock_irqsave(&this->lock, flags);\n\tif (!pcmcia_dev_present(link))\n\t\tgoto out;\n\tnetif_device_attach(dev);\n\tlink->open++;\n\n\t \n\tpr_debug(\"%s: Initialize WL3501 firmware...\", dev->name);\n\tif (wl3501_init_firmware(this))\n\t\tgoto fail;\n\t \n\tthis->adhoc_times = 0;\n\t \n\twl3501_ack_interrupt(this);\n\n\t \n\twl3501_unblock_interrupt(this);\n\twl3501_mgmt_scan(this, 100);\n\trc = 0;\n\tpr_debug(\"%s: WL3501 opened\", dev->name);\n\tprintk(KERN_INFO \"%s: Card Name: %s\\n\"\n\t\t\t \"%s: Firmware Date: %s\\n\",\n\t\t\t dev->name, this->card_name,\n\t\t\t dev->name, this->firmware_date);\nout:\n\tspin_unlock_irqrestore(&this->lock, flags);\n\treturn rc;\nfail:\n\tprintk(KERN_WARNING \"%s: Can't initialize firmware!\\n\", dev->name);\n\tgoto out;\n}\n\nstatic struct iw_statistics *wl3501_get_wireless_stats(struct net_device *dev)\n{\n\tstruct wl3501_card *this = netdev_priv(dev);\n\tstruct iw_statistics *wstats = &this->wstats;\n\tu32 value;  \n\n\tmemset(wstats, 0, sizeof(*wstats));\n\twstats->status = netif_running(dev);\n\tif (!wl3501_get_mib_value(this, WL3501_MIB_ATTR_WEP_ICV_ERROR_COUNT,\n\t\t\t\t  &value, sizeof(value)))\n\t\twstats->discard.code += value;\n\tif (!wl3501_get_mib_value(this, WL3501_MIB_ATTR_WEP_UNDECRYPTABLE_COUNT,\n\t\t\t\t  &value, sizeof(value)))\n\t\twstats->discard.code += value;\n\tif (!wl3501_get_mib_value(this, WL3501_MIB_ATTR_WEP_EXCLUDED_COUNT,\n\t\t\t\t  &value, sizeof(value)))\n\t\twstats->discard.code += value;\n\tif (!wl3501_get_mib_value(this, WL3501_MIB_ATTR_RETRY_COUNT,\n\t\t\t\t  &value, sizeof(value)))\n\t\twstats->discard.retries\t= value;\n\tif (!wl3501_get_mib_value(this, WL3501_MIB_ATTR_FAILED_COUNT,\n\t\t\t\t  &value, sizeof(value)))\n\t\twstats->discard.misc += value;\n\tif (!wl3501_get_mib_value(this, WL3501_MIB_ATTR_RTS_FAILURE_COUNT,\n\t\t\t\t  &value, sizeof(value)))\n\t\twstats->discard.misc += value;\n\tif (!wl3501_get_mib_value(this, WL3501_MIB_ATTR_ACK_FAILURE_COUNT,\n\t\t\t\t  &value, sizeof(value)))\n\t\twstats->discard.misc += value;\n\tif (!wl3501_get_mib_value(this, WL3501_MIB_ATTR_FRAME_DUPLICATE_COUNT,\n\t\t\t\t  &value, sizeof(value)))\n\t\twstats->discard.misc += value;\n\treturn wstats;\n}\n\n \nstatic void wl3501_detach(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\n\t \n\n\twhile (link->open > 0)\n\t\twl3501_close(dev);\n\n\tnetif_device_detach(dev);\n\twl3501_release(link);\n\n\tunregister_netdev(dev);\n\tfree_netdev(dev);\n}\n\nstatic int wl3501_get_name(struct net_device *dev, struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstrscpy(wrqu->name, \"IEEE 802.11-DS\", sizeof(wrqu->name));\n\treturn 0;\n}\n\nstatic int wl3501_set_freq(struct net_device *dev, struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct wl3501_card *this = netdev_priv(dev);\n\tint channel = wrqu->freq.m;\n\tint rc = -EINVAL;\n\n\tif (iw_valid_channel(this->reg_domain, channel)) {\n\t\tthis->chan = channel;\n\t\trc = wl3501_reset(dev);\n\t}\n\treturn rc;\n}\n\nstatic int wl3501_get_freq(struct net_device *dev, struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct wl3501_card *this = netdev_priv(dev);\n\n\twrqu->freq.m = 100000 *\n\t\tieee80211_channel_to_frequency(this->chan, NL80211_BAND_2GHZ);\n\twrqu->freq.e = 1;\n\treturn 0;\n}\n\nstatic int wl3501_set_mode(struct net_device *dev, struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tint rc = -EINVAL;\n\n\tif (wrqu->mode == IW_MODE_INFRA ||\n\t    wrqu->mode == IW_MODE_ADHOC ||\n\t    wrqu->mode == IW_MODE_AUTO) {\n\t\tstruct wl3501_card *this = netdev_priv(dev);\n\n\t\tthis->net_type = wrqu->mode;\n\t\trc = wl3501_reset(dev);\n\t}\n\treturn rc;\n}\n\nstatic int wl3501_get_mode(struct net_device *dev, struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct wl3501_card *this = netdev_priv(dev);\n\n\twrqu->mode = this->net_type;\n\treturn 0;\n}\n\nstatic int wl3501_get_sens(struct net_device *dev, struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct wl3501_card *this = netdev_priv(dev);\n\n\twrqu->sens.value = this->rssi;\n\twrqu->sens.disabled = !wrqu->sens.value;\n\twrqu->sens.fixed = 1;\n\treturn 0;\n}\n\nstatic int wl3501_get_range(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_range *range = (struct iw_range *)extra;\n\n\t \n\twrqu->data.length = sizeof(*range);\n\n\t \n\tmemset(range, 0, sizeof(*range));\n\n\t \n\trange->we_version_compiled\t= WIRELESS_EXT;\n\trange->we_version_source\t= 1;\n\trange->throughput\t\t= 2 * 1000 * 1000;      \n\t \n\treturn 0;\n}\n\nstatic int wl3501_set_wap(struct net_device *dev, struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct wl3501_card *this = netdev_priv(dev);\n\tint rc = -EINVAL;\n\n\t \n\tif (wrqu->ap_addr.sa_family != ARPHRD_ETHER)\n\t\tgoto out;\n\tif (is_broadcast_ether_addr(wrqu->ap_addr.sa_data)) {\n\t\t \n\t} else\n\t\tmemcpy(this->bssid, wrqu->ap_addr.sa_data, ETH_ALEN);\n\t\t \n\trc = 0;\nout:\n\treturn rc;\n}\n\nstatic int wl3501_get_wap(struct net_device *dev, struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct wl3501_card *this = netdev_priv(dev);\n\n\twrqu->ap_addr.sa_family = ARPHRD_ETHER;\n\tmemcpy(wrqu->ap_addr.sa_data, this->bssid, ETH_ALEN);\n\treturn 0;\n}\n\nstatic int wl3501_set_scan(struct net_device *dev, struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\t \n\treturn wl3501_reset(dev);\n}\n\nstatic int wl3501_get_scan(struct net_device *dev, struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct wl3501_card *this = netdev_priv(dev);\n\tint i;\n\tchar *current_ev = extra;\n\tstruct iw_event iwe;\n\n\tfor (i = 0; i < this->bss_cnt; ++i) {\n\t\tiwe.cmd\t\t\t= SIOCGIWAP;\n\t\tiwe.u.ap_addr.sa_family = ARPHRD_ETHER;\n\t\tmemcpy(iwe.u.ap_addr.sa_data, this->bss_set[i].req.bssid, ETH_ALEN);\n\t\tcurrent_ev = iwe_stream_add_event(info, current_ev,\n\t\t\t\t\t\t  extra + IW_SCAN_MAX_DATA,\n\t\t\t\t\t\t  &iwe, IW_EV_ADDR_LEN);\n\t\tiwe.cmd\t\t  = SIOCGIWESSID;\n\t\tiwe.u.data.flags  = 1;\n\t\tiwe.u.data.length = this->bss_set[i].req.ssid.el.len;\n\t\tcurrent_ev = iwe_stream_add_point(info, current_ev,\n\t\t\t\t\t\t  extra + IW_SCAN_MAX_DATA,\n\t\t\t\t\t\t  &iwe,\n\t\t\t\t\t\t  this->bss_set[i].req.ssid.essid);\n\t\tiwe.cmd\t   = SIOCGIWMODE;\n\t\tiwe.u.mode = this->bss_set[i].req.bss_type;\n\t\tcurrent_ev = iwe_stream_add_event(info, current_ev,\n\t\t\t\t\t\t  extra + IW_SCAN_MAX_DATA,\n\t\t\t\t\t\t  &iwe, IW_EV_UINT_LEN);\n\t\tiwe.cmd = SIOCGIWFREQ;\n\t\tiwe.u.freq.m = this->bss_set[i].req.ds_pset.chan;\n\t\tiwe.u.freq.e = 0;\n\t\tcurrent_ev = iwe_stream_add_event(info, current_ev,\n\t\t\t\t\t\t  extra + IW_SCAN_MAX_DATA,\n\t\t\t\t\t\t  &iwe, IW_EV_FREQ_LEN);\n\t\tiwe.cmd = SIOCGIWENCODE;\n\t\tif (this->bss_set[i].req.cap_info & WL3501_MGMT_CAPABILITY_PRIVACY)\n\t\t\tiwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;\n\t\telse\n\t\t\tiwe.u.data.flags = IW_ENCODE_DISABLED;\n\t\tiwe.u.data.length = 0;\n\t\tcurrent_ev = iwe_stream_add_point(info, current_ev,\n\t\t\t\t\t\t  extra + IW_SCAN_MAX_DATA,\n\t\t\t\t\t\t  &iwe, NULL);\n\t}\n\t \n\twrqu->data.length = (current_ev - extra);\n\twrqu->data.flags = 0;  \n\treturn 0;\n}\n\nstatic int wl3501_set_essid(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct wl3501_card *this = netdev_priv(dev);\n\n\tif (wrqu->data.flags) {\n\t\tiw_set_mgmt_info_element(IW_MGMT_INFO_ELEMENT_SSID,\n\t\t\t\t\t &this->essid.el,\n\t\t\t\t\t extra, wrqu->data.length);\n\t} else {  \n\t\tiw_set_mgmt_info_element(IW_MGMT_INFO_ELEMENT_SSID,\n\t\t\t\t\t &this->essid.el, \"ANY\", 3);\n\t}\n\treturn wl3501_reset(dev);\n}\n\nstatic int wl3501_get_essid(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct wl3501_card *this = netdev_priv(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&this->lock, flags);\n\twrqu->essid.flags  = 1;\n\twrqu->essid.length = this->essid.el.len;\n\tmemcpy(extra, this->essid.essid, this->essid.el.len);\n\tspin_unlock_irqrestore(&this->lock, flags);\n\treturn 0;\n}\n\nstatic int wl3501_set_nick(struct net_device *dev, struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct wl3501_card *this = netdev_priv(dev);\n\n\tif (wrqu->data.length > sizeof(this->nick))\n\t\treturn -E2BIG;\n\tstrscpy(this->nick, extra, wrqu->data.length);\n\treturn 0;\n}\n\nstatic int wl3501_get_nick(struct net_device *dev, struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct wl3501_card *this = netdev_priv(dev);\n\n\tstrscpy(extra, this->nick, 32);\n\twrqu->data.length = strlen(extra);\n\treturn 0;\n}\n\nstatic int wl3501_get_rate(struct net_device *dev, struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\t \n\twrqu->bitrate.value = 2000000;\n\twrqu->bitrate.fixed = 1;\n\treturn 0;\n}\n\nstatic int wl3501_get_rts_threshold(struct net_device *dev,\n\t\t\t\t    struct iw_request_info *info,\n\t\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tu16 threshold;  \n\tstruct wl3501_card *this = netdev_priv(dev);\n\tint rc = wl3501_get_mib_value(this, WL3501_MIB_ATTR_RTS_THRESHOLD,\n\t\t\t\t      &threshold, sizeof(threshold));\n\tif (!rc) {\n\t\twrqu->rts.value = threshold;\n\t\twrqu->rts.disabled = threshold >= 2347;\n\t\twrqu->rts.fixed = 1;\n\t}\n\treturn rc;\n}\n\nstatic int wl3501_get_frag_threshold(struct net_device *dev,\n\t\t\t\t     struct iw_request_info *info,\n\t\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tu16 threshold;  \n\tstruct wl3501_card *this = netdev_priv(dev);\n\tint rc = wl3501_get_mib_value(this, WL3501_MIB_ATTR_FRAG_THRESHOLD,\n\t\t\t\t      &threshold, sizeof(threshold));\n\tif (!rc) {\n\t\twrqu->frag.value = threshold;\n\t\twrqu->frag.disabled = threshold >= 2346;\n\t\twrqu->frag.fixed = 1;\n\t}\n\treturn rc;\n}\n\nstatic int wl3501_get_txpow(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tu16 txpow;\n\tstruct wl3501_card *this = netdev_priv(dev);\n\tint rc = wl3501_get_mib_value(this,\n\t\t\t\t      WL3501_MIB_ATTR_CURRENT_TX_PWR_LEVEL,\n\t\t\t\t      &txpow, sizeof(txpow));\n\tif (!rc) {\n\t\twrqu->txpower.value = txpow;\n\t\twrqu->txpower.disabled = 0;\n\t\t \n\t\twrqu->txpower.fixed = 0;\n\t\twrqu->txpower.flags = IW_TXPOW_MWATT;\n\t}\n\treturn rc;\n}\n\nstatic int wl3501_get_retry(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tu8 retry;  \n\tstruct wl3501_card *this = netdev_priv(dev);\n\tint rc = wl3501_get_mib_value(this,\n\t\t\t\t      WL3501_MIB_ATTR_LONG_RETRY_LIMIT,\n\t\t\t\t      &retry, sizeof(retry));\n\tif (rc)\n\t\tgoto out;\n\tif (wrqu->retry.flags & IW_RETRY_LONG) {\n\t\twrqu->retry.flags = IW_RETRY_LIMIT | IW_RETRY_LONG;\n\t\tgoto set_value;\n\t}\n\trc = wl3501_get_mib_value(this, WL3501_MIB_ATTR_SHORT_RETRY_LIMIT,\n\t\t\t\t  &retry, sizeof(retry));\n\tif (rc)\n\t\tgoto out;\n\twrqu->retry.flags = IW_RETRY_LIMIT | IW_RETRY_SHORT;\nset_value:\n\twrqu->retry.value = retry;\n\twrqu->retry.disabled = 0;\nout:\n\treturn rc;\n}\n\nstatic int wl3501_get_encode(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *extra)\n{\n\tu8 implemented, restricted, keys[100], len_keys, tocopy;\n\tstruct wl3501_card *this = netdev_priv(dev);\n\tint rc = wl3501_get_mib_value(this,\n\t\t\t\t      WL3501_MIB_ATTR_PRIV_OPT_IMPLEMENTED,\n\t\t\t\t      &implemented, sizeof(implemented));\n\tif (rc)\n\t\tgoto out;\n\tif (!implemented) {\n\t\twrqu->encoding.flags = IW_ENCODE_DISABLED;\n\t\tgoto out;\n\t}\n\trc = wl3501_get_mib_value(this, WL3501_MIB_ATTR_EXCLUDE_UNENCRYPTED,\n\t\t\t\t  &restricted, sizeof(restricted));\n\tif (rc)\n\t\tgoto out;\n\twrqu->encoding.flags = restricted ? IW_ENCODE_RESTRICTED :\n\t\t\t\t\t    IW_ENCODE_OPEN;\n\trc = wl3501_get_mib_value(this, WL3501_MIB_ATTR_WEP_KEY_MAPPINGS_LEN,\n\t\t\t\t  &len_keys, sizeof(len_keys));\n\tif (rc)\n\t\tgoto out;\n\trc = wl3501_get_mib_value(this, WL3501_MIB_ATTR_WEP_KEY_MAPPINGS,\n\t\t\t\t  keys, len_keys);\n\tif (rc)\n\t\tgoto out;\n\ttocopy = min_t(u16, len_keys, wrqu->encoding.length);\n\ttocopy = min_t(u8, tocopy, 100);\n\twrqu->encoding.length = tocopy;\n\tmemcpy(extra, keys, tocopy);\nout:\n\treturn rc;\n}\n\nstatic int wl3501_get_power(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tu8 pwr_state;\n\tstruct wl3501_card *this = netdev_priv(dev);\n\tint rc = wl3501_get_mib_value(this,\n\t\t\t\t      WL3501_MIB_ATTR_CURRENT_PWR_STATE,\n\t\t\t\t      &pwr_state, sizeof(pwr_state));\n\tif (rc)\n\t\tgoto out;\n\twrqu->power.disabled = !pwr_state;\n\twrqu->power.flags = IW_POWER_ON;\nout:\n\treturn rc;\n}\n\nstatic const iw_handler\twl3501_handler[] = {\n\tIW_HANDLER(SIOCGIWNAME, wl3501_get_name),\n\tIW_HANDLER(SIOCSIWFREQ, wl3501_set_freq),\n\tIW_HANDLER(SIOCGIWFREQ, wl3501_get_freq),\n\tIW_HANDLER(SIOCSIWMODE, wl3501_set_mode),\n\tIW_HANDLER(SIOCGIWMODE, wl3501_get_mode),\n\tIW_HANDLER(SIOCGIWSENS, wl3501_get_sens),\n\tIW_HANDLER(SIOCGIWRANGE, wl3501_get_range),\n\tIW_HANDLER(SIOCSIWSPY, iw_handler_set_spy),\n\tIW_HANDLER(SIOCGIWSPY, iw_handler_get_spy),\n\tIW_HANDLER(SIOCSIWTHRSPY, iw_handler_set_thrspy),\n\tIW_HANDLER(SIOCGIWTHRSPY, iw_handler_get_thrspy),\n\tIW_HANDLER(SIOCSIWAP, wl3501_set_wap),\n\tIW_HANDLER(SIOCGIWAP, wl3501_get_wap),\n\tIW_HANDLER(SIOCSIWSCAN, wl3501_set_scan),\n\tIW_HANDLER(SIOCGIWSCAN, wl3501_get_scan),\n\tIW_HANDLER(SIOCSIWESSID, wl3501_set_essid),\n\tIW_HANDLER(SIOCGIWESSID, wl3501_get_essid),\n\tIW_HANDLER(SIOCSIWNICKN, wl3501_set_nick),\n\tIW_HANDLER(SIOCGIWNICKN, wl3501_get_nick),\n\tIW_HANDLER(SIOCGIWRATE, wl3501_get_rate),\n\tIW_HANDLER(SIOCGIWRTS, wl3501_get_rts_threshold),\n\tIW_HANDLER(SIOCGIWFRAG, wl3501_get_frag_threshold),\n\tIW_HANDLER(SIOCGIWTXPOW, wl3501_get_txpow),\n\tIW_HANDLER(SIOCGIWRETRY, wl3501_get_retry),\n\tIW_HANDLER(SIOCGIWENCODE, wl3501_get_encode),\n\tIW_HANDLER(SIOCGIWPOWER, wl3501_get_power),\n};\n\nstatic const struct iw_handler_def wl3501_handler_def = {\n\t.num_standard\t= ARRAY_SIZE(wl3501_handler),\n\t.standard\t= (iw_handler *)wl3501_handler,\n\t.get_wireless_stats = wl3501_get_wireless_stats,\n};\n\nstatic const struct net_device_ops wl3501_netdev_ops = {\n\t.ndo_open\t\t= wl3501_open,\n\t.ndo_stop\t\t= wl3501_close,\n\t.ndo_start_xmit\t\t= wl3501_hard_start_xmit,\n\t.ndo_tx_timeout\t\t= wl3501_tx_timeout,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int wl3501_probe(struct pcmcia_device *p_dev)\n{\n\tstruct net_device *dev;\n\tstruct wl3501_card *this;\n\tint ret;\n\n\t \n\tp_dev->resource[0]->end\t= 16;\n\tp_dev->resource[0]->flags\t= IO_DATA_PATH_WIDTH_8;\n\n\t \n\tp_dev->config_flags\t= CONF_ENABLE_IRQ;\n\tp_dev->config_index\t= 1;\n\n\tdev = alloc_etherdev(sizeof(struct wl3501_card));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->netdev_ops\t\t= &wl3501_netdev_ops;\n\tdev->watchdog_timeo\t= 5 * HZ;\n\n\tthis = netdev_priv(dev);\n\tthis->wireless_data.spy_data = &this->spy_data;\n\tthis->p_dev = p_dev;\n\tdev->wireless_data\t= &this->wireless_data;\n\tdev->wireless_handlers\t= &wl3501_handler_def;\n\tnetif_stop_queue(dev);\n\tp_dev->priv = dev;\n\n\tret = wl3501_config(p_dev);\n\tif (ret)\n\t\tgoto out_free_etherdev;\n\n\treturn 0;\n\nout_free_etherdev:\n\tfree_netdev(dev);\n\treturn ret;\n}\n\nstatic int wl3501_config(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\tint i = 0, j, ret;\n\tstruct wl3501_card *this;\n\n\t \n\tlink->io_lines = 5;\n\n\tfor (j = 0x280; j < 0x400; j += 0x20) {\n\t\t \n\t\tlink->resource[0]->start = j;\n\t\tlink->resource[1]->start = link->resource[0]->start + 0x10;\n\t\ti = pcmcia_request_io(link);\n\t\tif (i == 0)\n\t\t\tbreak;\n\t}\n\tif (i != 0)\n\t\tgoto failed;\n\n\t \n\n\tret = pcmcia_request_irq(link, wl3501_interrupt);\n\tif (ret)\n\t\tgoto failed;\n\n\tret = pcmcia_enable_device(link);\n\tif (ret)\n\t\tgoto failed;\n\n\tdev->irq = link->irq;\n\tdev->base_addr = link->resource[0]->start;\n\tSET_NETDEV_DEV(dev, &link->dev);\n\tif (register_netdev(dev)) {\n\t\tprintk(KERN_NOTICE \"wl3501_cs: register_netdev() failed\\n\");\n\t\tgoto failed;\n\t}\n\n\tthis = netdev_priv(dev);\n\n\tthis->base_addr = dev->base_addr;\n\n\tif (!wl3501_get_flash_mac_addr(this)) {\n\t\tprintk(KERN_WARNING \"%s: Can't read MAC addr in flash ROM?\\n\",\n\t\t       dev->name);\n\t\tunregister_netdev(dev);\n\t\tgoto failed;\n\t}\n\n\teth_hw_addr_set(dev, this->mac_addr);\n\n\t \n\tprintk(KERN_INFO \"%s: wl3501 @ 0x%3.3x, IRQ %d, \"\n\t       \"MAC addr in flash ROM:%pM\\n\",\n\t       dev->name, this->base_addr, (int)dev->irq,\n\t       dev->dev_addr);\n\t \n\tthis->net_type\t\t= IW_MODE_INFRA;\n\tthis->bss_cnt\t\t= 0;\n\tthis->join_sta_bss\t= 0;\n\tthis->adhoc_times\t= 0;\n\tiw_set_mgmt_info_element(IW_MGMT_INFO_ELEMENT_SSID, &this->essid.el,\n\t\t\t\t \"ANY\", 3);\n\tthis->card_name[0]\t= '\\0';\n\tthis->firmware_date[0]\t= '\\0';\n\tthis->rssi\t\t= 255;\n\tthis->chan\t\t= iw_default_channel(this->reg_domain);\n\tstrscpy(this->nick, \"Planet WL3501\", sizeof(this->nick));\n\tspin_lock_init(&this->lock);\n\tinit_waitqueue_head(&this->wait);\n\tnetif_start_queue(dev);\n\treturn 0;\n\nfailed:\n\twl3501_release(link);\n\treturn -ENODEV;\n}\n\nstatic void wl3501_release(struct pcmcia_device *link)\n{\n\tpcmcia_disable_device(link);\n}\n\nstatic int wl3501_suspend(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\n\twl3501_pwr_mgmt(netdev_priv(dev), WL3501_SUSPEND);\n\tif (link->open)\n\t\tnetif_device_detach(dev);\n\n\treturn 0;\n}\n\nstatic int wl3501_resume(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\n\twl3501_pwr_mgmt(netdev_priv(dev), WL3501_RESUME);\n\tif (link->open) {\n\t\twl3501_reset(dev);\n\t\tnetif_device_attach(dev);\n\t}\n\n\treturn 0;\n}\n\n\nstatic const struct pcmcia_device_id wl3501_ids[] = {\n\tPCMCIA_DEVICE_MANF_CARD(0xd601, 0x0001),\n\tPCMCIA_DEVICE_NULL\n};\nMODULE_DEVICE_TABLE(pcmcia, wl3501_ids);\n\nstatic struct pcmcia_driver wl3501_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"wl3501_cs\",\n\t.probe\t\t= wl3501_probe,\n\t.remove\t\t= wl3501_detach,\n\t.id_table\t= wl3501_ids,\n\t.suspend\t= wl3501_suspend,\n\t.resume\t\t= wl3501_resume,\n};\nmodule_pcmcia_driver(wl3501_driver);\n\nMODULE_AUTHOR(\"Fox Chen <mhchen@golf.ccl.itri.org.tw>, \"\n\t      \"Arnaldo Carvalho de Melo <acme@conectiva.com.br>,\"\n\t      \"Gustavo Niemeyer <niemeyer@conectiva.com>\");\nMODULE_DESCRIPTION(\"Planet wl3501 wireless driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}