{
  "module_name": "sysfs.c",
  "hash_id": "6ea1edd9adfd535c692645dc3b0bf43a89ae66125a5a8f0a3c301860d380c8b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/b43legacy/sysfs.c",
  "human_readable_source": "\n \n\n#include \"sysfs.h\"\n#include \"b43legacy.h\"\n#include \"main.h\"\n#include \"phy.h\"\n#include \"radio.h\"\n\n#include <linux/capability.h>\n\n\n#define GENERIC_FILESIZE\t64\n\n\nstatic int get_integer(const char *buf, size_t count)\n{\n\tchar tmp[10 + 1] = { 0 };\n\tint ret = -EINVAL, res;\n\n\tif (count == 0)\n\t\tgoto out;\n\tcount = min_t(size_t, count, 10);\n\tmemcpy(tmp, buf, count);\n\tret = kstrtoint(tmp, 10, &res);\n\tif (!ret)\n\t\treturn res;\nout:\n\treturn ret;\n}\n\nstatic int get_boolean(const char *buf, size_t count)\n{\n\tif (count != 0) {\n\t\tif (buf[0] == '1')\n\t\t\treturn 1;\n\t\tif (buf[0] == '0')\n\t\t\treturn 0;\n\t\tif (count >= 4 && memcmp(buf, \"true\", 4) == 0)\n\t\t\treturn 1;\n\t\tif (count >= 5 && memcmp(buf, \"false\", 5) == 0)\n\t\t\treturn 0;\n\t\tif (count >= 3 && memcmp(buf, \"yes\", 3) == 0)\n\t\t\treturn 1;\n\t\tif (count >= 2 && memcmp(buf, \"no\", 2) == 0)\n\t\t\treturn 0;\n\t\tif (count >= 2 && memcmp(buf, \"on\", 2) == 0)\n\t\t\treturn 1;\n\t\tif (count >= 3 && memcmp(buf, \"off\", 3) == 0)\n\t\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic ssize_t b43legacy_attr_interfmode_show(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      char *buf)\n{\n\tstruct b43legacy_wldev *wldev = dev_to_b43legacy_wldev(dev);\n\tssize_t count = 0;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tmutex_lock(&wldev->wl->mutex);\n\n\tswitch (wldev->phy.interfmode) {\n\tcase B43legacy_INTERFMODE_NONE:\n\t\tcount = snprintf(buf, PAGE_SIZE, \"0 (No Interference\"\n\t\t\t\t \" Mitigation)\\n\");\n\t\tbreak;\n\tcase B43legacy_INTERFMODE_NONWLAN:\n\t\tcount = snprintf(buf, PAGE_SIZE, \"1 (Non-WLAN Interference\"\n\t\t\t\t \" Mitigation)\\n\");\n\t\tbreak;\n\tcase B43legacy_INTERFMODE_MANUALWLAN:\n\t\tcount = snprintf(buf, PAGE_SIZE, \"2 (WLAN Interference\"\n\t\t\t\t \" Mitigation)\\n\");\n\t\tbreak;\n\tdefault:\n\t\tB43legacy_WARN_ON(1);\n\t}\n\n\tmutex_unlock(&wldev->wl->mutex);\n\n\treturn count;\n}\n\nstatic ssize_t b43legacy_attr_interfmode_store(struct device *dev,\n\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t       const char *buf, size_t count)\n{\n\tstruct b43legacy_wldev *wldev = dev_to_b43legacy_wldev(dev);\n\tunsigned long flags;\n\tint err;\n\tint mode;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tmode = get_integer(buf, count);\n\tswitch (mode) {\n\tcase 0:\n\t\tmode = B43legacy_INTERFMODE_NONE;\n\t\tbreak;\n\tcase 1:\n\t\tmode = B43legacy_INTERFMODE_NONWLAN;\n\t\tbreak;\n\tcase 2:\n\t\tmode = B43legacy_INTERFMODE_MANUALWLAN;\n\t\tbreak;\n\tcase 3:\n\t\tmode = B43legacy_INTERFMODE_AUTOWLAN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&wldev->wl->mutex);\n\tspin_lock_irqsave(&wldev->wl->irq_lock, flags);\n\n\terr = b43legacy_radio_set_interference_mitigation(wldev, mode);\n\tif (err)\n\t\tb43legacyerr(wldev->wl, \"Interference Mitigation not \"\n\t\t       \"supported by device\\n\");\n\tspin_unlock_irqrestore(&wldev->wl->irq_lock, flags);\n\tmutex_unlock(&wldev->wl->mutex);\n\n\treturn err ? err : count;\n}\n\nstatic DEVICE_ATTR(interference, 0644,\n\t\t   b43legacy_attr_interfmode_show,\n\t\t   b43legacy_attr_interfmode_store);\n\nstatic ssize_t b43legacy_attr_preamble_show(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\tstruct b43legacy_wldev *wldev = dev_to_b43legacy_wldev(dev);\n\tssize_t count;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tmutex_lock(&wldev->wl->mutex);\n\n\tif (wldev->short_preamble)\n\t\tcount = snprintf(buf, PAGE_SIZE, \"1 (Short Preamble\"\n\t\t\t\t \" enabled)\\n\");\n\telse\n\t\tcount = snprintf(buf, PAGE_SIZE, \"0 (Short Preamble\"\n\t\t\t\t \" disabled)\\n\");\n\n\tmutex_unlock(&wldev->wl->mutex);\n\n\treturn count;\n}\n\nstatic ssize_t b43legacy_attr_preamble_store(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct b43legacy_wldev *wldev = dev_to_b43legacy_wldev(dev);\n\tunsigned long flags;\n\tint value;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tvalue = get_boolean(buf, count);\n\tif (value < 0)\n\t\treturn value;\n\tmutex_lock(&wldev->wl->mutex);\n\tspin_lock_irqsave(&wldev->wl->irq_lock, flags);\n\n\twldev->short_preamble = !!value;\n\n\tspin_unlock_irqrestore(&wldev->wl->irq_lock, flags);\n\tmutex_unlock(&wldev->wl->mutex);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(shortpreamble, 0644,\n\t\t   b43legacy_attr_preamble_show,\n\t\t   b43legacy_attr_preamble_store);\n\nint b43legacy_sysfs_register(struct b43legacy_wldev *wldev)\n{\n\tstruct device *dev = wldev->dev->dev;\n\tint err;\n\n\tB43legacy_WARN_ON(b43legacy_status(wldev) !=\n\t\t\t  B43legacy_STAT_INITIALIZED);\n\n\terr = device_create_file(dev, &dev_attr_interference);\n\tif (err)\n\t\tgoto out;\n\terr = device_create_file(dev, &dev_attr_shortpreamble);\n\tif (err)\n\t\tgoto err_remove_interfmode;\n\nout:\n\treturn err;\nerr_remove_interfmode:\n\tdevice_remove_file(dev, &dev_attr_interference);\n\tgoto out;\n}\n\nvoid b43legacy_sysfs_unregister(struct b43legacy_wldev *wldev)\n{\n\tstruct device *dev = wldev->dev->dev;\n\n\tdevice_remove_file(dev, &dev_attr_shortpreamble);\n\tdevice_remove_file(dev, &dev_attr_interference);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}