{
  "module_name": "debugfs.c",
  "hash_id": "5a1ea53ac1d6efae28ee9b0be97857db8a357096a98e25f9525fcca46caa6386",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/b43legacy/debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/netdevice.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n\n#include \"b43legacy.h\"\n#include \"main.h\"\n#include \"debugfs.h\"\n#include \"dma.h\"\n#include \"pio.h\"\n#include \"xmit.h\"\n\n\n \nstatic struct dentry *rootdir;\n\nstruct b43legacy_debugfs_fops {\n\tssize_t (*read)(struct b43legacy_wldev *dev, char *buf, size_t bufsize);\n\tint (*write)(struct b43legacy_wldev *dev, const char *buf, size_t count);\n\tstruct file_operations fops;\n\t \n\tsize_t file_struct_offset;\n\t \n\tbool take_irqlock;\n};\n\nstatic inline\nstruct b43legacy_dfs_file * fops_to_dfs_file(struct b43legacy_wldev *dev,\n\t\t\t\t       const struct b43legacy_debugfs_fops *dfops)\n{\n\tvoid *p;\n\n\tp = dev->dfsentry;\n\tp += dfops->file_struct_offset;\n\n\treturn p;\n}\n\n\n#define fappend(fmt, x...)\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (bufsize - count)\t\t\t\t\\\n\t\t\tcount += scnprintf(buf + count,\t\t\\\n\t\t\t\t\t  bufsize - count,\t\\\n\t\t\t\t\t  fmt , ##x);\t\t\\\n\t\telse\t\t\t\t\t\t\\\n\t\t\tprintk(KERN_ERR \"b43legacy: fappend overflow\\n\"); \\\n\t} while (0)\n\n\n \nstatic ssize_t tsf_read_file(struct b43legacy_wldev *dev, char *buf, size_t bufsize)\n{\n\tssize_t count = 0;\n\tu64 tsf;\n\n\tb43legacy_tsf_read(dev, &tsf);\n\tfappend(\"0x%08x%08x\\n\",\n\t\t(unsigned int)((tsf & 0xFFFFFFFF00000000ULL) >> 32),\n\t\t(unsigned int)(tsf & 0xFFFFFFFFULL));\n\n\treturn count;\n}\n\n \nstatic int tsf_write_file(struct b43legacy_wldev *dev, const char *buf, size_t count)\n{\n\tu64 tsf;\n\n\tif (sscanf(buf, \"%llu\", (unsigned long long *)(&tsf)) != 1)\n\t\treturn -EINVAL;\n\tb43legacy_tsf_write(dev, tsf);\n\n\treturn 0;\n}\n\n \nstatic ssize_t ucode_regs_read_file(struct b43legacy_wldev *dev, char *buf, size_t bufsize)\n{\n\tssize_t count = 0;\n\tint i;\n\n\tfor (i = 0; i < 64; i++) {\n\t\tfappend(\"r%d = 0x%04x\\n\", i,\n\t\t\tb43legacy_shm_read16(dev, B43legacy_SHM_WIRELESS, i));\n\t}\n\n\treturn count;\n}\n\n \nstatic ssize_t shm_read_file(struct b43legacy_wldev *dev, char *buf, size_t bufsize)\n{\n\tssize_t count = 0;\n\tint i;\n\tu16 tmp;\n\t__le16 *le16buf = (__le16 *)buf;\n\n\tfor (i = 0; i < 0x1000; i++) {\n\t\tif (bufsize < sizeof(tmp))\n\t\t\tbreak;\n\t\ttmp = b43legacy_shm_read16(dev, B43legacy_SHM_SHARED, 2 * i);\n\t\tle16buf[i] = cpu_to_le16(tmp);\n\t\tcount += sizeof(tmp);\n\t\tbufsize -= sizeof(tmp);\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t txstat_read_file(struct b43legacy_wldev *dev, char *buf, size_t bufsize)\n{\n\tstruct b43legacy_txstatus_log *log = &dev->dfsentry->txstatlog;\n\tssize_t count = 0;\n\tunsigned long flags;\n\tint i, idx;\n\tstruct b43legacy_txstatus *stat;\n\n\tspin_lock_irqsave(&log->lock, flags);\n\tif (log->end < 0) {\n\t\tfappend(\"Nothing transmitted, yet\\n\");\n\t\tgoto out_unlock;\n\t}\n\tfappend(\"b43legacy TX status reports:\\n\\n\"\n\t\t\"index | cookie | seq | phy_stat | frame_count | \"\n\t\t\"rts_count | supp_reason | pm_indicated | \"\n\t\t\"intermediate | for_ampdu | acked\\n\" \"---\\n\");\n\ti = log->end + 1;\n\tidx = 0;\n\twhile (1) {\n\t\tif (i == B43legacy_NR_LOGGED_TXSTATUS)\n\t\t\ti = 0;\n\t\tstat = &(log->log[i]);\n\t\tif (stat->cookie) {\n\t\t\tfappend(\"%03d | \"\n\t\t\t\t\"0x%04X | 0x%04X | 0x%02X | \"\n\t\t\t\t\"0x%X | 0x%X | \"\n\t\t\t\t\"%u | %u | \"\n\t\t\t\t\"%u | %u | %u\\n\",\n\t\t\t\tidx,\n\t\t\t\tstat->cookie, stat->seq, stat->phy_stat,\n\t\t\t\tstat->frame_count, stat->rts_count,\n\t\t\t\tstat->supp_reason, stat->pm_indicated,\n\t\t\t\tstat->intermediate, stat->for_ampdu,\n\t\t\t\tstat->acked);\n\t\t\tidx++;\n\t\t}\n\t\tif (i == log->end)\n\t\t\tbreak;\n\t\ti++;\n\t}\nout_unlock:\n\tspin_unlock_irqrestore(&log->lock, flags);\n\n\treturn count;\n}\n\n \nstatic int restart_write_file(struct b43legacy_wldev *dev, const char *buf, size_t count)\n{\n\tint err = 0;\n\n\tif (count > 0 && buf[0] == '1') {\n\t\tb43legacy_controller_restart(dev, \"manually restarted\");\n\t} else\n\t\terr = -EINVAL;\n\n\treturn err;\n}\n\n#undef fappend\n\nstatic ssize_t b43legacy_debugfs_read(struct file *file, char __user *userbuf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct b43legacy_wldev *dev;\n\tstruct b43legacy_debugfs_fops *dfops;\n\tstruct b43legacy_dfs_file *dfile;\n\tssize_t ret;\n\tchar *buf;\n\tconst size_t bufsize = 1024 * 16;  \n\tconst size_t buforder = get_order(bufsize);\n\tint err = 0;\n\n\tif (!count)\n\t\treturn 0;\n\tdev = file->private_data;\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&dev->wl->mutex);\n\tif (b43legacy_status(dev) < B43legacy_STAT_INITIALIZED) {\n\t\terr = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tdfops = container_of(debugfs_real_fops(file),\n\t\t\t     struct b43legacy_debugfs_fops, fops);\n\tif (!dfops->read) {\n\t\terr = -ENOSYS;\n\t\tgoto out_unlock;\n\t}\n\tdfile = fops_to_dfs_file(dev, dfops);\n\n\tif (!dfile->buffer) {\n\t\tbuf = (char *)__get_free_pages(GFP_KERNEL, buforder);\n\t\tif (!buf) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tmemset(buf, 0, bufsize);\n\t\tif (dfops->take_irqlock) {\n\t\t\tspin_lock_irq(&dev->wl->irq_lock);\n\t\t\tret = dfops->read(dev, buf, bufsize);\n\t\t\tspin_unlock_irq(&dev->wl->irq_lock);\n\t\t} else\n\t\t\tret = dfops->read(dev, buf, bufsize);\n\t\tif (ret <= 0) {\n\t\t\tfree_pages((unsigned long)buf, buforder);\n\t\t\terr = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tdfile->data_len = ret;\n\t\tdfile->buffer = buf;\n\t}\n\n\tret = simple_read_from_buffer(userbuf, count, ppos,\n\t\t\t\t      dfile->buffer,\n\t\t\t\t      dfile->data_len);\n\tif (*ppos >= dfile->data_len) {\n\t\tfree_pages((unsigned long)dfile->buffer, buforder);\n\t\tdfile->buffer = NULL;\n\t\tdfile->data_len = 0;\n\t}\nout_unlock:\n\tmutex_unlock(&dev->wl->mutex);\n\n\treturn err ? err : ret;\n}\n\nstatic ssize_t b43legacy_debugfs_write(struct file *file,\n\t\t\t\t const char __user *userbuf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct b43legacy_wldev *dev;\n\tstruct b43legacy_debugfs_fops *dfops;\n\tchar *buf;\n\tint err = 0;\n\n\tif (!count)\n\t\treturn 0;\n\tif (count > PAGE_SIZE)\n\t\treturn -E2BIG;\n\tdev = file->private_data;\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&dev->wl->mutex);\n\tif (b43legacy_status(dev) < B43legacy_STAT_INITIALIZED) {\n\t\terr = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tdfops = container_of(debugfs_real_fops(file),\n\t\t\t     struct b43legacy_debugfs_fops, fops);\n\tif (!dfops->write) {\n\t\terr = -ENOSYS;\n\t\tgoto out_unlock;\n\t}\n\n\tbuf = (char *)get_zeroed_page(GFP_KERNEL);\n\tif (!buf) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\tif (copy_from_user(buf, userbuf, count)) {\n\t\terr = -EFAULT;\n\t\tgoto out_freepage;\n\t}\n\tif (dfops->take_irqlock) {\n\t\tspin_lock_irq(&dev->wl->irq_lock);\n\t\terr = dfops->write(dev, buf, count);\n\t\tspin_unlock_irq(&dev->wl->irq_lock);\n\t} else\n\t\terr = dfops->write(dev, buf, count);\n\tif (err)\n\t\tgoto out_freepage;\n\nout_freepage:\n\tfree_page((unsigned long)buf);\nout_unlock:\n\tmutex_unlock(&dev->wl->mutex);\n\n\treturn err ? err : count;\n}\n\n\n#define B43legacy_DEBUGFS_FOPS(name, _read, _write, _take_irqlock)\t\\\n\tstatic struct b43legacy_debugfs_fops fops_##name = {\t\t\\\n\t\t.read\t= _read,\t\t\t\t\\\n\t\t.write\t= _write,\t\t\t\t\\\n\t\t.fops\t= {\t\t\t\t\t\\\n\t\t\t.open\t= simple_open,\t\t\t\t\\\n\t\t\t.read\t= b43legacy_debugfs_read,\t\t\\\n\t\t\t.write\t= b43legacy_debugfs_write,\t\t\\\n\t\t\t.llseek = generic_file_llseek,\t\t\t\\\n\t\t},\t\t\t\t\t\t\\\n\t\t.file_struct_offset = offsetof(struct b43legacy_dfsentry, \\\n\t\t\t\t\t       file_##name),\t\\\n\t\t.take_irqlock\t= _take_irqlock,\t\t\\\n\t}\n\nB43legacy_DEBUGFS_FOPS(tsf, tsf_read_file, tsf_write_file, 1);\nB43legacy_DEBUGFS_FOPS(ucode_regs, ucode_regs_read_file, NULL, 1);\nB43legacy_DEBUGFS_FOPS(shm, shm_read_file, NULL, 1);\nB43legacy_DEBUGFS_FOPS(txstat, txstat_read_file, NULL, 0);\nB43legacy_DEBUGFS_FOPS(restart, NULL, restart_write_file, 1);\n\n\nint b43legacy_debug(struct b43legacy_wldev *dev, enum b43legacy_dyndbg feature)\n{\n\treturn !!(dev->dfsentry && dev->dfsentry->dyn_debug[feature]);\n}\n\nstatic void b43legacy_add_dynamic_debug(struct b43legacy_wldev *dev)\n{\n\tstruct b43legacy_dfsentry *e = dev->dfsentry;\n\n#define add_dyn_dbg(name, id, initstate) do {\t\t\t\\\n\te->dyn_debug[id] = (initstate);\t\t\t\t\\\n\tdebugfs_create_bool(name, 0600, e->subdir,\t\t\\\n\t\t\t    &(e->dyn_debug[id]));\t\t\\\n\t} while (0)\n\n\tadd_dyn_dbg(\"debug_xmitpower\", B43legacy_DBG_XMITPOWER, false);\n\tadd_dyn_dbg(\"debug_dmaoverflow\", B43legacy_DBG_DMAOVERFLOW, false);\n\tadd_dyn_dbg(\"debug_dmaverbose\", B43legacy_DBG_DMAVERBOSE, false);\n\tadd_dyn_dbg(\"debug_pwork_fast\", B43legacy_DBG_PWORK_FAST, false);\n\tadd_dyn_dbg(\"debug_pwork_stop\", B43legacy_DBG_PWORK_STOP, false);\n\n#undef add_dyn_dbg\n}\n\nvoid b43legacy_debugfs_add_device(struct b43legacy_wldev *dev)\n{\n\tstruct b43legacy_dfsentry *e;\n\tstruct b43legacy_txstatus_log *log;\n\tchar devdir[16];\n\n\tB43legacy_WARN_ON(!dev);\n\te = kzalloc(sizeof(*e), GFP_KERNEL);\n\tif (!e) {\n\t\tb43legacyerr(dev->wl, \"debugfs: add device OOM\\n\");\n\t\treturn;\n\t}\n\te->dev = dev;\n\tlog = &e->txstatlog;\n\tlog->log = kcalloc(B43legacy_NR_LOGGED_TXSTATUS,\n\t\t\t   sizeof(struct b43legacy_txstatus), GFP_KERNEL);\n\tif (!log->log) {\n\t\tb43legacyerr(dev->wl, \"debugfs: add device txstatus OOM\\n\");\n\t\tkfree(e);\n\t\treturn;\n\t}\n\tlog->end = -1;\n\tspin_lock_init(&log->lock);\n\n\tdev->dfsentry = e;\n\n\tsnprintf(devdir, sizeof(devdir), \"%s\", wiphy_name(dev->wl->hw->wiphy));\n\te->subdir = debugfs_create_dir(devdir, rootdir);\n\n#define ADD_FILE(name, mode)\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tdebugfs_create_file(__stringify(name), mode,\t\\\n\t\t\t\t    e->subdir, dev,\t\t\\\n\t\t\t\t    &fops_##name.fops);\t\t\\\n\t} while (0)\n\n\n\tADD_FILE(tsf, 0600);\n\tADD_FILE(ucode_regs, 0400);\n\tADD_FILE(shm, 0400);\n\tADD_FILE(txstat, 0400);\n\tADD_FILE(restart, 0200);\n\n#undef ADD_FILE\n\n\tb43legacy_add_dynamic_debug(dev);\n}\n\nvoid b43legacy_debugfs_remove_device(struct b43legacy_wldev *dev)\n{\n\tstruct b43legacy_dfsentry *e;\n\n\tif (!dev)\n\t\treturn;\n\te = dev->dfsentry;\n\tif (!e)\n\t\treturn;\n\n\tdebugfs_remove(e->subdir);\n\tkfree(e->txstatlog.log);\n\tkfree(e);\n}\n\nvoid b43legacy_debugfs_log_txstat(struct b43legacy_wldev *dev,\n\t\t\t    const struct b43legacy_txstatus *status)\n{\n\tstruct b43legacy_dfsentry *e = dev->dfsentry;\n\tstruct b43legacy_txstatus_log *log;\n\tstruct b43legacy_txstatus *cur;\n\tint i;\n\n\tif (!e)\n\t\treturn;\n\tlog = &e->txstatlog;\n\tB43legacy_WARN_ON(!irqs_disabled());\n\tspin_lock(&log->lock);\n\ti = log->end + 1;\n\tif (i == B43legacy_NR_LOGGED_TXSTATUS)\n\t\ti = 0;\n\tlog->end = i;\n\tcur = &(log->log[i]);\n\tmemcpy(cur, status, sizeof(*cur));\n\tspin_unlock(&log->lock);\n}\n\nvoid b43legacy_debugfs_init(void)\n{\n\trootdir = debugfs_create_dir(KBUILD_MODNAME, NULL);\n}\n\nvoid b43legacy_debugfs_exit(void)\n{\n\tdebugfs_remove(rootdir);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}