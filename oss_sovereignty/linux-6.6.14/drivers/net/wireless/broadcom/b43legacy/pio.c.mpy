{
  "module_name": "pio.c",
  "hash_id": "a8d252aecf628b56484aec31398b2978e0b6acceaa3febf0868c69a32db2ee55",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/b43legacy/pio.c",
  "human_readable_source": "\n \n\n#include \"b43legacy.h\"\n#include \"pio.h\"\n#include \"main.h\"\n#include \"xmit.h\"\n\n#include <linux/delay.h>\n#include <linux/slab.h>\n\n\nstatic void tx_start(struct b43legacy_pioqueue *queue)\n{\n\tb43legacy_pio_write(queue, B43legacy_PIO_TXCTL,\n\t\t\t    B43legacy_PIO_TXCTL_INIT);\n}\n\nstatic void tx_octet(struct b43legacy_pioqueue *queue,\n\t\t     u8 octet)\n{\n\tif (queue->need_workarounds) {\n\t\tb43legacy_pio_write(queue, B43legacy_PIO_TXDATA, octet);\n\t\tb43legacy_pio_write(queue, B43legacy_PIO_TXCTL,\n\t\t\t\t    B43legacy_PIO_TXCTL_WRITELO);\n\t} else {\n\t\tb43legacy_pio_write(queue, B43legacy_PIO_TXCTL,\n\t\t\t\t    B43legacy_PIO_TXCTL_WRITELO);\n\t\tb43legacy_pio_write(queue, B43legacy_PIO_TXDATA, octet);\n\t}\n}\n\nstatic u16 tx_get_next_word(const u8 *txhdr,\n\t\t\t    const u8 *packet,\n\t\t\t    size_t txhdr_size,\n\t\t\t    unsigned int *pos)\n{\n\tconst u8 *source;\n\tunsigned int i = *pos;\n\tu16 ret;\n\n\tif (i < txhdr_size)\n\t\tsource = txhdr;\n\telse {\n\t\tsource = packet;\n\t\ti -= txhdr_size;\n\t}\n\tret = le16_to_cpu(*((__le16 *)(source + i)));\n\t*pos += 2;\n\n\treturn ret;\n}\n\nstatic void tx_data(struct b43legacy_pioqueue *queue,\n\t\t    u8 *txhdr,\n\t\t    const u8 *packet,\n\t\t    unsigned int octets)\n{\n\tu16 data;\n\tunsigned int i = 0;\n\n\tif (queue->need_workarounds) {\n\t\tdata = tx_get_next_word(txhdr, packet,\n\t\t\t\t\tsizeof(struct b43legacy_txhdr_fw3), &i);\n\t\tb43legacy_pio_write(queue, B43legacy_PIO_TXDATA, data);\n\t}\n\tb43legacy_pio_write(queue, B43legacy_PIO_TXCTL,\n\t\t\t    B43legacy_PIO_TXCTL_WRITELO |\n\t\t\t    B43legacy_PIO_TXCTL_WRITEHI);\n\twhile (i < octets - 1) {\n\t\tdata = tx_get_next_word(txhdr, packet,\n\t\t\t\t\tsizeof(struct b43legacy_txhdr_fw3), &i);\n\t\tb43legacy_pio_write(queue, B43legacy_PIO_TXDATA, data);\n\t}\n\tif (octets % 2)\n\t\ttx_octet(queue, packet[octets -\n\t\t\t sizeof(struct b43legacy_txhdr_fw3) - 1]);\n}\n\nstatic void tx_complete(struct b43legacy_pioqueue *queue,\n\t\t\tstruct sk_buff *skb)\n{\n\tif (queue->need_workarounds) {\n\t\tb43legacy_pio_write(queue, B43legacy_PIO_TXDATA,\n\t\t\t\t    skb->data[skb->len - 1]);\n\t\tb43legacy_pio_write(queue, B43legacy_PIO_TXCTL,\n\t\t\t\t    B43legacy_PIO_TXCTL_WRITELO |\n\t\t\t\t    B43legacy_PIO_TXCTL_COMPLETE);\n\t} else\n\t\tb43legacy_pio_write(queue, B43legacy_PIO_TXCTL,\n\t\t\t\t    B43legacy_PIO_TXCTL_COMPLETE);\n}\n\nstatic u16 generate_cookie(struct b43legacy_pioqueue *queue,\n\t\t\t   struct b43legacy_pio_txpacket *packet)\n{\n\tu16 cookie = 0x0000;\n\tint packetindex;\n\n\t \n\tswitch (queue->mmio_base) {\n\tcase B43legacy_MMIO_PIO1_BASE:\n\t\tbreak;\n\tcase B43legacy_MMIO_PIO2_BASE:\n\t\tcookie = 0x1000;\n\t\tbreak;\n\tcase B43legacy_MMIO_PIO3_BASE:\n\t\tcookie = 0x2000;\n\t\tbreak;\n\tcase B43legacy_MMIO_PIO4_BASE:\n\t\tcookie = 0x3000;\n\t\tbreak;\n\tdefault:\n\t\tB43legacy_WARN_ON(1);\n\t}\n\tpacketindex = pio_txpacket_getindex(packet);\n\tB43legacy_WARN_ON(!(((u16)packetindex & 0xF000) == 0x0000));\n\tcookie |= (u16)packetindex;\n\n\treturn cookie;\n}\n\nstatic\nstruct b43legacy_pioqueue *parse_cookie(struct b43legacy_wldev *dev,\n\t\t\t\t\tu16 cookie,\n\t\t\t\t\tstruct b43legacy_pio_txpacket **packet)\n{\n\tstruct b43legacy_pio *pio = &dev->pio;\n\tstruct b43legacy_pioqueue *queue = NULL;\n\tint packetindex;\n\n\tswitch (cookie & 0xF000) {\n\tcase 0x0000:\n\t\tqueue = pio->queue0;\n\t\tbreak;\n\tcase 0x1000:\n\t\tqueue = pio->queue1;\n\t\tbreak;\n\tcase 0x2000:\n\t\tqueue = pio->queue2;\n\t\tbreak;\n\tcase 0x3000:\n\t\tqueue = pio->queue3;\n\t\tbreak;\n\tdefault:\n\t\tB43legacy_WARN_ON(1);\n\t}\n\tpacketindex = (cookie & 0x0FFF);\n\tB43legacy_WARN_ON(!(packetindex >= 0 && packetindex\n\t\t\t  < B43legacy_PIO_MAXTXPACKETS));\n\t*packet = &(queue->tx_packets_cache[packetindex]);\n\n\treturn queue;\n}\n\nunion txhdr_union {\n\tstruct b43legacy_txhdr_fw3 txhdr_fw3;\n};\n\nstatic int pio_tx_write_fragment(struct b43legacy_pioqueue *queue,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct b43legacy_pio_txpacket *packet,\n\t\t\t\t  size_t txhdr_size)\n{\n\tunion txhdr_union txhdr_data;\n\tu8 *txhdr = NULL;\n\tunsigned int octets;\n\tint err;\n\n\ttxhdr = (u8 *)(&txhdr_data.txhdr_fw3);\n\n\tB43legacy_WARN_ON(skb_shinfo(skb)->nr_frags != 0);\n\terr = b43legacy_generate_txhdr(queue->dev,\n\t\t\t\t txhdr, skb->data, skb->len,\n\t\t\t\t IEEE80211_SKB_CB(skb),\n\t\t\t\t generate_cookie(queue, packet));\n\tif (err)\n\t\treturn err;\n\n\ttx_start(queue);\n\toctets = skb->len + txhdr_size;\n\tif (queue->need_workarounds)\n\t\toctets--;\n\ttx_data(queue, txhdr, (u8 *)skb->data, octets);\n\ttx_complete(queue, skb);\n\n\treturn 0;\n}\n\nstatic void free_txpacket(struct b43legacy_pio_txpacket *packet,\n\t\t\t  int irq_context)\n{\n\tstruct b43legacy_pioqueue *queue = packet->queue;\n\n\tif (packet->skb) {\n\t\tif (irq_context)\n\t\t\tdev_kfree_skb_irq(packet->skb);\n\t\telse\n\t\t\tdev_kfree_skb(packet->skb);\n\t}\n\tlist_move(&packet->list, &queue->txfree);\n\tqueue->nr_txfree++;\n}\n\nstatic int pio_tx_packet(struct b43legacy_pio_txpacket *packet)\n{\n\tstruct b43legacy_pioqueue *queue = packet->queue;\n\tstruct sk_buff *skb = packet->skb;\n\tu16 octets;\n\tint err;\n\n\toctets = (u16)skb->len + sizeof(struct b43legacy_txhdr_fw3);\n\tif (queue->tx_devq_size < octets) {\n\t\tb43legacywarn(queue->dev->wl, \"PIO queue too small. \"\n\t\t\t\"Dropping packet.\\n\");\n\t\t \n\t\tfree_txpacket(packet, 1);\n\t\treturn 0;\n\t}\n\tB43legacy_WARN_ON(queue->tx_devq_packets >\n\t\t\t  B43legacy_PIO_MAXTXDEVQPACKETS);\n\tB43legacy_WARN_ON(queue->tx_devq_used > queue->tx_devq_size);\n\t \n\tif (queue->tx_devq_packets == B43legacy_PIO_MAXTXDEVQPACKETS)\n\t\treturn -EBUSY;\n\tif (queue->tx_devq_used + octets > queue->tx_devq_size)\n\t\treturn -EBUSY;\n\t \n\terr = pio_tx_write_fragment(queue, skb, packet,\n\t\t\t      sizeof(struct b43legacy_txhdr_fw3));\n\tif (unlikely(err == -ENOKEY)) {\n\t\t \n\t\tfree_txpacket(packet, 1);\n\t\treturn 0;\n\t}\n\n\t \n\tqueue->tx_devq_packets++;\n\tqueue->tx_devq_used += octets;\n\n\t \n\tlist_move_tail(&packet->list, &queue->txrunning);\n\n\treturn 0;\n}\n\nstatic void tx_tasklet(struct tasklet_struct *t)\n{\n\tstruct b43legacy_pioqueue *queue = from_tasklet(queue, t, txtask);\n\tstruct b43legacy_wldev *dev = queue->dev;\n\tunsigned long flags;\n\tstruct b43legacy_pio_txpacket *packet, *tmp_packet;\n\tint err;\n\tu16 txctl;\n\n\tspin_lock_irqsave(&dev->wl->irq_lock, flags);\n\tif (queue->tx_frozen)\n\t\tgoto out_unlock;\n\ttxctl = b43legacy_pio_read(queue, B43legacy_PIO_TXCTL);\n\tif (txctl & B43legacy_PIO_TXCTL_SUSPEND)\n\t\tgoto out_unlock;\n\n\tlist_for_each_entry_safe(packet, tmp_packet, &queue->txqueue, list) {\n\t\t \n\t\terr = pio_tx_packet(packet);\n\t\tif (err)\n\t\t\tbreak;\n\t}\nout_unlock:\n\tspin_unlock_irqrestore(&dev->wl->irq_lock, flags);\n}\n\nstatic void setup_txqueues(struct b43legacy_pioqueue *queue)\n{\n\tstruct b43legacy_pio_txpacket *packet;\n\tint i;\n\n\tqueue->nr_txfree = B43legacy_PIO_MAXTXPACKETS;\n\tfor (i = 0; i < B43legacy_PIO_MAXTXPACKETS; i++) {\n\t\tpacket = &(queue->tx_packets_cache[i]);\n\n\t\tpacket->queue = queue;\n\t\tINIT_LIST_HEAD(&packet->list);\n\n\t\tlist_add(&packet->list, &queue->txfree);\n\t}\n}\n\nstatic\nstruct b43legacy_pioqueue *b43legacy_setup_pioqueue(struct b43legacy_wldev *dev,\n\t\t\t\t\t\t    u16 pio_mmio_base)\n{\n\tstruct b43legacy_pioqueue *queue;\n\tu32 value;\n\tu16 qsize;\n\n\tqueue = kzalloc(sizeof(*queue), GFP_KERNEL);\n\tif (!queue)\n\t\tgoto out;\n\n\tqueue->dev = dev;\n\tqueue->mmio_base = pio_mmio_base;\n\tqueue->need_workarounds = (dev->dev->id.revision < 3);\n\n\tINIT_LIST_HEAD(&queue->txfree);\n\tINIT_LIST_HEAD(&queue->txqueue);\n\tINIT_LIST_HEAD(&queue->txrunning);\n\ttasklet_setup(&queue->txtask, tx_tasklet);\n\n\tvalue = b43legacy_read32(dev, B43legacy_MMIO_MACCTL);\n\tvalue &= ~B43legacy_MACCTL_BE;\n\tb43legacy_write32(dev, B43legacy_MMIO_MACCTL, value);\n\n\tqsize = b43legacy_read16(dev, queue->mmio_base\n\t\t\t\t + B43legacy_PIO_TXQBUFSIZE);\n\tif (qsize == 0) {\n\t\tb43legacyerr(dev->wl, \"This card does not support PIO \"\n\t\t       \"operation mode. Please use DMA mode \"\n\t\t       \"(module parameter pio=0).\\n\");\n\t\tgoto err_freequeue;\n\t}\n\tif (qsize <= B43legacy_PIO_TXQADJUST) {\n\t\tb43legacyerr(dev->wl, \"PIO tx device-queue too small (%u)\\n\",\n\t\t       qsize);\n\t\tgoto err_freequeue;\n\t}\n\tqsize -= B43legacy_PIO_TXQADJUST;\n\tqueue->tx_devq_size = qsize;\n\n\tsetup_txqueues(queue);\n\nout:\n\treturn queue;\n\nerr_freequeue:\n\tkfree(queue);\n\tqueue = NULL;\n\tgoto out;\n}\n\nstatic void cancel_transfers(struct b43legacy_pioqueue *queue)\n{\n\tstruct b43legacy_pio_txpacket *packet, *tmp_packet;\n\n\ttasklet_kill(&queue->txtask);\n\n\tlist_for_each_entry_safe(packet, tmp_packet, &queue->txrunning, list)\n\t\tfree_txpacket(packet, 0);\n\tlist_for_each_entry_safe(packet, tmp_packet, &queue->txqueue, list)\n\t\tfree_txpacket(packet, 0);\n}\n\nstatic void b43legacy_destroy_pioqueue(struct b43legacy_pioqueue *queue)\n{\n\tif (!queue)\n\t\treturn;\n\n\tcancel_transfers(queue);\n\tkfree(queue);\n}\n\nvoid b43legacy_pio_free(struct b43legacy_wldev *dev)\n{\n\tstruct b43legacy_pio *pio;\n\n\tif (!b43legacy_using_pio(dev))\n\t\treturn;\n\tpio = &dev->pio;\n\n\tb43legacy_destroy_pioqueue(pio->queue3);\n\tpio->queue3 = NULL;\n\tb43legacy_destroy_pioqueue(pio->queue2);\n\tpio->queue2 = NULL;\n\tb43legacy_destroy_pioqueue(pio->queue1);\n\tpio->queue1 = NULL;\n\tb43legacy_destroy_pioqueue(pio->queue0);\n\tpio->queue0 = NULL;\n}\n\nint b43legacy_pio_init(struct b43legacy_wldev *dev)\n{\n\tstruct b43legacy_pio *pio = &dev->pio;\n\tstruct b43legacy_pioqueue *queue;\n\tint err = -ENOMEM;\n\n\tqueue = b43legacy_setup_pioqueue(dev, B43legacy_MMIO_PIO1_BASE);\n\tif (!queue)\n\t\tgoto out;\n\tpio->queue0 = queue;\n\n\tqueue = b43legacy_setup_pioqueue(dev, B43legacy_MMIO_PIO2_BASE);\n\tif (!queue)\n\t\tgoto err_destroy0;\n\tpio->queue1 = queue;\n\n\tqueue = b43legacy_setup_pioqueue(dev, B43legacy_MMIO_PIO3_BASE);\n\tif (!queue)\n\t\tgoto err_destroy1;\n\tpio->queue2 = queue;\n\n\tqueue = b43legacy_setup_pioqueue(dev, B43legacy_MMIO_PIO4_BASE);\n\tif (!queue)\n\t\tgoto err_destroy2;\n\tpio->queue3 = queue;\n\n\tif (dev->dev->id.revision < 3)\n\t\tdev->irq_mask |= B43legacy_IRQ_PIO_WORKAROUND;\n\n\tb43legacydbg(dev->wl, \"PIO initialized\\n\");\n\terr = 0;\nout:\n\treturn err;\n\nerr_destroy2:\n\tb43legacy_destroy_pioqueue(pio->queue2);\n\tpio->queue2 = NULL;\nerr_destroy1:\n\tb43legacy_destroy_pioqueue(pio->queue1);\n\tpio->queue1 = NULL;\nerr_destroy0:\n\tb43legacy_destroy_pioqueue(pio->queue0);\n\tpio->queue0 = NULL;\n\tgoto out;\n}\n\nint b43legacy_pio_tx(struct b43legacy_wldev *dev,\n\t\t     struct sk_buff *skb)\n{\n\tstruct b43legacy_pioqueue *queue = dev->pio.queue1;\n\tstruct b43legacy_pio_txpacket *packet;\n\n\tB43legacy_WARN_ON(queue->tx_suspended);\n\tB43legacy_WARN_ON(list_empty(&queue->txfree));\n\n\tpacket = list_entry(queue->txfree.next, struct b43legacy_pio_txpacket,\n\t\t\t    list);\n\tpacket->skb = skb;\n\n\tlist_move_tail(&packet->list, &queue->txqueue);\n\tqueue->nr_txfree--;\n\tB43legacy_WARN_ON(queue->nr_txfree >= B43legacy_PIO_MAXTXPACKETS);\n\n\ttasklet_schedule(&queue->txtask);\n\n\treturn 0;\n}\n\nvoid b43legacy_pio_handle_txstatus(struct b43legacy_wldev *dev,\n\t\t\t\t   const struct b43legacy_txstatus *status)\n{\n\tstruct b43legacy_pioqueue *queue;\n\tstruct b43legacy_pio_txpacket *packet;\n\tstruct ieee80211_tx_info *info;\n\tint retry_limit;\n\n\tqueue = parse_cookie(dev, status->cookie, &packet);\n\tB43legacy_WARN_ON(!queue);\n\n\tif (!packet->skb)\n\t\treturn;\n\n\tqueue->tx_devq_packets--;\n\tqueue->tx_devq_used -= (packet->skb->len +\n\t\t\t\tsizeof(struct b43legacy_txhdr_fw3));\n\n\tinfo = IEEE80211_SKB_CB(packet->skb);\n\n\t \n\tretry_limit = info->status.rates[0].count;\n\tieee80211_tx_info_clear_status(info);\n\n\tif (status->acked)\n\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\n\tif (status->rts_count > dev->wl->hw->conf.short_frame_max_tx_count) {\n\t\t \n\t\tinfo->status.rates[0].count = 0;\n\t\tinfo->status.rates[1].count = status->frame_count;\n\t} else {\n\t\tif (status->frame_count > retry_limit) {\n\t\t\tinfo->status.rates[0].count = retry_limit;\n\t\t\tinfo->status.rates[1].count = status->frame_count -\n\t\t\t\t\tretry_limit;\n\n\t\t} else {\n\t\t\tinfo->status.rates[0].count = status->frame_count;\n\t\t\tinfo->status.rates[1].idx = -1;\n\t\t}\n\t}\n\tieee80211_tx_status_irqsafe(dev->wl->hw, packet->skb);\n\tpacket->skb = NULL;\n\n\tfree_txpacket(packet, 1);\n\t \n\tif (!list_empty(&queue->txqueue))\n\t\ttasklet_schedule(&queue->txtask);\n}\n\nstatic void pio_rx_error(struct b43legacy_pioqueue *queue,\n\t\t\t int clear_buffers,\n\t\t\t const char *error)\n{\n\tint i;\n\n\tb43legacyerr(queue->dev->wl, \"PIO RX error: %s\\n\", error);\n\tb43legacy_pio_write(queue, B43legacy_PIO_RXCTL,\n\t\t\t    B43legacy_PIO_RXCTL_READY);\n\tif (clear_buffers) {\n\t\tB43legacy_WARN_ON(queue->mmio_base != B43legacy_MMIO_PIO1_BASE);\n\t\tfor (i = 0; i < 15; i++) {\n\t\t\t \n\t\t\tb43legacy_pio_read(queue, B43legacy_PIO_RXDATA);\n\t\t}\n\t}\n}\n\nvoid b43legacy_pio_rx(struct b43legacy_pioqueue *queue)\n{\n\t__le16 preamble[21] = { 0 };\n\tstruct b43legacy_rxhdr_fw3 *rxhdr;\n\tu16 tmp;\n\tu16 len;\n\tu16 macstat;\n\tint i;\n\tint preamble_readwords;\n\tstruct sk_buff *skb;\n\n\ttmp = b43legacy_pio_read(queue, B43legacy_PIO_RXCTL);\n\tif (!(tmp & B43legacy_PIO_RXCTL_DATAAVAILABLE))\n\t\treturn;\n\tb43legacy_pio_write(queue, B43legacy_PIO_RXCTL,\n\t\t\t    B43legacy_PIO_RXCTL_DATAAVAILABLE);\n\n\tfor (i = 0; i < 10; i++) {\n\t\ttmp = b43legacy_pio_read(queue, B43legacy_PIO_RXCTL);\n\t\tif (tmp & B43legacy_PIO_RXCTL_READY)\n\t\t\tgoto data_ready;\n\t\tudelay(10);\n\t}\n\tb43legacydbg(queue->dev->wl, \"PIO RX timed out\\n\");\n\treturn;\ndata_ready:\n\n\tlen = b43legacy_pio_read(queue, B43legacy_PIO_RXDATA);\n\tif (unlikely(len > 0x700)) {\n\t\tpio_rx_error(queue, 0, \"len > 0x700\");\n\t\treturn;\n\t}\n\tif (unlikely(len == 0 && queue->mmio_base !=\n\t\t     B43legacy_MMIO_PIO4_BASE)) {\n\t\tpio_rx_error(queue, 0, \"len == 0\");\n\t\treturn;\n\t}\n\tpreamble[0] = cpu_to_le16(len);\n\tif (queue->mmio_base == B43legacy_MMIO_PIO4_BASE)\n\t\tpreamble_readwords = 14 / sizeof(u16);\n\telse\n\t\tpreamble_readwords = 18 / sizeof(u16);\n\tfor (i = 0; i < preamble_readwords; i++) {\n\t\ttmp = b43legacy_pio_read(queue, B43legacy_PIO_RXDATA);\n\t\tpreamble[i + 1] = cpu_to_le16(tmp);\n\t}\n\trxhdr = (struct b43legacy_rxhdr_fw3 *)preamble;\n\tmacstat = le16_to_cpu(rxhdr->mac_status);\n\tif (macstat & B43legacy_RX_MAC_FCSERR) {\n\t\tpio_rx_error(queue,\n\t\t\t     (queue->mmio_base == B43legacy_MMIO_PIO1_BASE),\n\t\t\t     \"Frame FCS error\");\n\t\treturn;\n\t}\n\tif (queue->mmio_base == B43legacy_MMIO_PIO4_BASE) {\n\t\t \n\t\tstruct b43legacy_hwtxstatus *hw;\n\n\t\thw = (struct b43legacy_hwtxstatus *)(preamble + 1);\n\t\tb43legacy_handle_hwtxstatus(queue->dev, hw);\n\n\t\treturn;\n\t}\n\n\tskb = dev_alloc_skb(len);\n\tif (unlikely(!skb)) {\n\t\tpio_rx_error(queue, 1, \"OOM\");\n\t\treturn;\n\t}\n\tskb_put(skb, len);\n\tfor (i = 0; i < len - 1; i += 2) {\n\t\ttmp = b43legacy_pio_read(queue, B43legacy_PIO_RXDATA);\n\t\t*((__le16 *)(skb->data + i)) = cpu_to_le16(tmp);\n\t}\n\tif (len % 2) {\n\t\ttmp = b43legacy_pio_read(queue, B43legacy_PIO_RXDATA);\n\t\tskb->data[len - 1] = (tmp & 0x00FF);\n\t}\n\tb43legacy_rx(queue->dev, skb, rxhdr);\n}\n\nvoid b43legacy_pio_tx_suspend(struct b43legacy_pioqueue *queue)\n{\n\tb43legacy_power_saving_ctl_bits(queue->dev, -1, 1);\n\tb43legacy_pio_write(queue, B43legacy_PIO_TXCTL,\n\t\t\t    b43legacy_pio_read(queue, B43legacy_PIO_TXCTL)\n\t\t\t    | B43legacy_PIO_TXCTL_SUSPEND);\n}\n\nvoid b43legacy_pio_tx_resume(struct b43legacy_pioqueue *queue)\n{\n\tb43legacy_pio_write(queue, B43legacy_PIO_TXCTL,\n\t\t\t    b43legacy_pio_read(queue, B43legacy_PIO_TXCTL)\n\t\t\t    & ~B43legacy_PIO_TXCTL_SUSPEND);\n\tb43legacy_power_saving_ctl_bits(queue->dev, -1, -1);\n\ttasklet_schedule(&queue->txtask);\n}\n\nvoid b43legacy_pio_freeze_txqueues(struct b43legacy_wldev *dev)\n{\n\tstruct b43legacy_pio *pio;\n\n\tB43legacy_WARN_ON(!b43legacy_using_pio(dev));\n\tpio = &dev->pio;\n\tpio->queue0->tx_frozen = 1;\n\tpio->queue1->tx_frozen = 1;\n\tpio->queue2->tx_frozen = 1;\n\tpio->queue3->tx_frozen = 1;\n}\n\nvoid b43legacy_pio_thaw_txqueues(struct b43legacy_wldev *dev)\n{\n\tstruct b43legacy_pio *pio;\n\n\tB43legacy_WARN_ON(!b43legacy_using_pio(dev));\n\tpio = &dev->pio;\n\tpio->queue0->tx_frozen = 0;\n\tpio->queue1->tx_frozen = 0;\n\tpio->queue2->tx_frozen = 0;\n\tpio->queue3->tx_frozen = 0;\n\tif (!list_empty(&pio->queue0->txqueue))\n\t\ttasklet_schedule(&pio->queue0->txtask);\n\tif (!list_empty(&pio->queue1->txqueue))\n\t\ttasklet_schedule(&pio->queue1->txtask);\n\tif (!list_empty(&pio->queue2->txqueue))\n\t\ttasklet_schedule(&pio->queue2->txtask);\n\tif (!list_empty(&pio->queue3->txqueue))\n\t\ttasklet_schedule(&pio->queue3->txtask);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}