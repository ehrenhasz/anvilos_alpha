{
  "module_name": "leds.c",
  "hash_id": "b74887cbf832159f06b6f51329ec0097488f1ef812ab2ef4a0122cdba3e8bf0e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/b43legacy/leds.c",
  "human_readable_source": "\n \n\n#include \"b43legacy.h\"\n#include \"leds.h\"\n#include \"rfkill.h\"\n\n\nstatic void b43legacy_led_turn_on(struct b43legacy_wldev *dev, u8 led_index,\n\t\t\t    bool activelow)\n{\n\tstruct b43legacy_wl *wl = dev->wl;\n\tunsigned long flags;\n\tu16 ctl;\n\n\tspin_lock_irqsave(&wl->leds_lock, flags);\n\tctl = b43legacy_read16(dev, B43legacy_MMIO_GPIO_CONTROL);\n\tif (activelow)\n\t\tctl &= ~(1 << led_index);\n\telse\n\t\tctl |= (1 << led_index);\n\tb43legacy_write16(dev, B43legacy_MMIO_GPIO_CONTROL, ctl);\n\tspin_unlock_irqrestore(&wl->leds_lock, flags);\n}\n\nstatic void b43legacy_led_turn_off(struct b43legacy_wldev *dev, u8 led_index,\n\t\t\t     bool activelow)\n{\n\tstruct b43legacy_wl *wl = dev->wl;\n\tunsigned long flags;\n\tu16 ctl;\n\n\tspin_lock_irqsave(&wl->leds_lock, flags);\n\tctl = b43legacy_read16(dev, B43legacy_MMIO_GPIO_CONTROL);\n\tif (activelow)\n\t\tctl |= (1 << led_index);\n\telse\n\t\tctl &= ~(1 << led_index);\n\tb43legacy_write16(dev, B43legacy_MMIO_GPIO_CONTROL, ctl);\n\tspin_unlock_irqrestore(&wl->leds_lock, flags);\n}\n\n \nstatic void b43legacy_led_brightness_set(struct led_classdev *led_dev,\n\t\t\t\t   enum led_brightness brightness)\n{\n\tstruct b43legacy_led *led = container_of(led_dev, struct b43legacy_led,\n\t\t\t\t    led_dev);\n\tstruct b43legacy_wldev *dev = led->dev;\n\tbool radio_enabled;\n\n\t \n\tradio_enabled = (dev->phy.radio_on && dev->radio_hw_enable);\n\n\tif (brightness == LED_OFF || !radio_enabled)\n\t\tb43legacy_led_turn_off(dev, led->index, led->activelow);\n\telse\n\t\tb43legacy_led_turn_on(dev, led->index, led->activelow);\n}\n\nstatic int b43legacy_register_led(struct b43legacy_wldev *dev,\n\t\t\t\t  struct b43legacy_led *led,\n\t\t\t\t  const char *name,\n\t\t\t\t  const char *default_trigger,\n\t\t\t\t  u8 led_index, bool activelow)\n{\n\tint err;\n\n\tb43legacy_led_turn_off(dev, led_index, activelow);\n\tif (led->dev)\n\t\treturn -EEXIST;\n\tif (!default_trigger)\n\t\treturn -EINVAL;\n\tled->dev = dev;\n\tled->index = led_index;\n\tled->activelow = activelow;\n\tstrscpy(led->name, name, sizeof(led->name));\n\n\tled->led_dev.name = led->name;\n\tled->led_dev.default_trigger = default_trigger;\n\tled->led_dev.brightness_set = b43legacy_led_brightness_set;\n\n\terr = led_classdev_register(dev->dev->dev, &led->led_dev);\n\tif (err) {\n\t\tb43legacywarn(dev->wl, \"LEDs: Failed to register %s\\n\", name);\n\t\tled->dev = NULL;\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic void b43legacy_unregister_led(struct b43legacy_led *led)\n{\n\tif (!led->dev)\n\t\treturn;\n\tled_classdev_unregister(&led->led_dev);\n\tb43legacy_led_turn_off(led->dev, led->index, led->activelow);\n\tled->dev = NULL;\n}\n\nstatic void b43legacy_map_led(struct b43legacy_wldev *dev,\n\t\t\tu8 led_index,\n\t\t\tenum b43legacy_led_behaviour behaviour,\n\t\t\tbool activelow)\n{\n\tstruct ieee80211_hw *hw = dev->wl->hw;\n\tchar name[B43legacy_LED_MAX_NAME_LEN + 1];\n\n\t \n\tswitch (behaviour) {\n\tcase B43legacy_LED_INACTIVE:\n\t\tbreak;\n\tcase B43legacy_LED_OFF:\n\t\tb43legacy_led_turn_off(dev, led_index, activelow);\n\t\tbreak;\n\tcase B43legacy_LED_ON:\n\t\tb43legacy_led_turn_on(dev, led_index, activelow);\n\t\tbreak;\n\tcase B43legacy_LED_ACTIVITY:\n\tcase B43legacy_LED_TRANSFER:\n\tcase B43legacy_LED_APTRANSFER:\n\t\tsnprintf(name, sizeof(name),\n\t\t\t \"b43legacy-%s::tx\", wiphy_name(hw->wiphy));\n\t\tb43legacy_register_led(dev, &dev->led_tx, name,\n\t\t\t\t ieee80211_get_tx_led_name(hw),\n\t\t\t\t led_index, activelow);\n\t\tsnprintf(name, sizeof(name),\n\t\t\t \"b43legacy-%s::rx\", wiphy_name(hw->wiphy));\n\t\tb43legacy_register_led(dev, &dev->led_rx, name,\n\t\t\t\t ieee80211_get_rx_led_name(hw),\n\t\t\t\t led_index, activelow);\n\t\tbreak;\n\tcase B43legacy_LED_RADIO_ALL:\n\tcase B43legacy_LED_RADIO_A:\n\tcase B43legacy_LED_RADIO_B:\n\tcase B43legacy_LED_MODE_BG:\n\t\tsnprintf(name, sizeof(name),\n\t\t\t \"b43legacy-%s::radio\", wiphy_name(hw->wiphy));\n\t\tb43legacy_register_led(dev, &dev->led_radio, name,\n\t\t\t\t ieee80211_get_radio_led_name(hw),\n\t\t\t\t led_index, activelow);\n\t\t \n\t\tif (dev->phy.radio_on && b43legacy_is_hw_radio_enabled(dev))\n\t\t\tb43legacy_led_turn_on(dev, led_index, activelow);\n\t\tbreak;\n\tcase B43legacy_LED_WEIRD:\n\tcase B43legacy_LED_ASSOC:\n\t\tsnprintf(name, sizeof(name),\n\t\t\t \"b43legacy-%s::assoc\", wiphy_name(hw->wiphy));\n\t\tb43legacy_register_led(dev, &dev->led_assoc, name,\n\t\t\t\t ieee80211_get_assoc_led_name(hw),\n\t\t\t\t led_index, activelow);\n\t\tbreak;\n\tdefault:\n\t\tb43legacywarn(dev->wl, \"LEDs: Unknown behaviour 0x%02X\\n\",\n\t\t\tbehaviour);\n\t\tbreak;\n\t}\n}\n\nvoid b43legacy_leds_init(struct b43legacy_wldev *dev)\n{\n\tstruct ssb_bus *bus = dev->dev->bus;\n\tu8 sprom[4];\n\tint i;\n\tenum b43legacy_led_behaviour behaviour;\n\tbool activelow;\n\n\tsprom[0] = bus->sprom.gpio0;\n\tsprom[1] = bus->sprom.gpio1;\n\tsprom[2] = bus->sprom.gpio2;\n\tsprom[3] = bus->sprom.gpio3;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (sprom[i] == 0xFF) {\n\t\t\t \n\t\t\tactivelow = false;\n\t\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tbehaviour = B43legacy_LED_ACTIVITY;\n\t\t\t\tactivelow = true;\n\t\t\t\tif (bus->boardinfo.vendor == PCI_VENDOR_ID_COMPAQ)\n\t\t\t\t\tbehaviour = B43legacy_LED_RADIO_ALL;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tbehaviour = B43legacy_LED_RADIO_B;\n\t\t\t\tif (bus->boardinfo.vendor == PCI_VENDOR_ID_ASUSTEK)\n\t\t\t\t\tbehaviour = B43legacy_LED_ASSOC;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tbehaviour = B43legacy_LED_RADIO_A;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tbehaviour = B43legacy_LED_OFF;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tB43legacy_WARN_ON(1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tbehaviour = sprom[i] & B43legacy_LED_BEHAVIOUR;\n\t\t\tactivelow = !!(sprom[i] & B43legacy_LED_ACTIVELOW);\n\t\t}\n\t\tb43legacy_map_led(dev, i, behaviour, activelow);\n\t}\n}\n\nvoid b43legacy_leds_exit(struct b43legacy_wldev *dev)\n{\n\tb43legacy_unregister_led(&dev->led_tx);\n\tb43legacy_unregister_led(&dev->led_rx);\n\tb43legacy_unregister_led(&dev->led_assoc);\n\tb43legacy_unregister_led(&dev->led_radio);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}