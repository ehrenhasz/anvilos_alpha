{
  "module_name": "xmit.c",
  "hash_id": "c3fd3b8794fac6bc9507eec2575db32e40148a4a4aca4e97f6cef58b91e4732d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/b43legacy/xmit.c",
  "human_readable_source": "\n \n\n#include <net/dst.h>\n\n#include \"xmit.h\"\n#include \"phy.h\"\n#include \"dma.h\"\n#include \"pio.h\"\n\n\n \nstatic u8 b43legacy_plcp_get_bitrate_idx_cck(struct b43legacy_plcp_hdr6 *plcp)\n{\n\tswitch (plcp->raw[0]) {\n\tcase 0x0A:\n\t\treturn 0;\n\tcase 0x14:\n\t\treturn 1;\n\tcase 0x37:\n\t\treturn 2;\n\tcase 0x6E:\n\t\treturn 3;\n\t}\n\tB43legacy_BUG_ON(1);\n\treturn -1;\n}\n\n \nstatic u8 b43legacy_plcp_get_bitrate_idx_ofdm(struct b43legacy_plcp_hdr6 *plcp,\n\t\t\t\t\t      bool aphy)\n{\n\tint base = aphy ? 0 : 4;\n\n\tswitch (plcp->raw[0] & 0xF) {\n\tcase 0xB:\n\t\treturn base + 0;\n\tcase 0xF:\n\t\treturn base + 1;\n\tcase 0xA:\n\t\treturn base + 2;\n\tcase 0xE:\n\t\treturn base + 3;\n\tcase 0x9:\n\t\treturn base + 4;\n\tcase 0xD:\n\t\treturn base + 5;\n\tcase 0x8:\n\t\treturn base + 6;\n\tcase 0xC:\n\t\treturn base + 7;\n\t}\n\tB43legacy_BUG_ON(1);\n\treturn -1;\n}\n\nu8 b43legacy_plcp_get_ratecode_cck(const u8 bitrate)\n{\n\tswitch (bitrate) {\n\tcase B43legacy_CCK_RATE_1MB:\n\t\treturn 0x0A;\n\tcase B43legacy_CCK_RATE_2MB:\n\t\treturn 0x14;\n\tcase B43legacy_CCK_RATE_5MB:\n\t\treturn 0x37;\n\tcase B43legacy_CCK_RATE_11MB:\n\t\treturn 0x6E;\n\t}\n\tB43legacy_BUG_ON(1);\n\treturn 0;\n}\n\nu8 b43legacy_plcp_get_ratecode_ofdm(const u8 bitrate)\n{\n\tswitch (bitrate) {\n\tcase B43legacy_OFDM_RATE_6MB:\n\t\treturn 0xB;\n\tcase B43legacy_OFDM_RATE_9MB:\n\t\treturn 0xF;\n\tcase B43legacy_OFDM_RATE_12MB:\n\t\treturn 0xA;\n\tcase B43legacy_OFDM_RATE_18MB:\n\t\treturn 0xE;\n\tcase B43legacy_OFDM_RATE_24MB:\n\t\treturn 0x9;\n\tcase B43legacy_OFDM_RATE_36MB:\n\t\treturn 0xD;\n\tcase B43legacy_OFDM_RATE_48MB:\n\t\treturn 0x8;\n\tcase B43legacy_OFDM_RATE_54MB:\n\t\treturn 0xC;\n\t}\n\tB43legacy_BUG_ON(1);\n\treturn 0;\n}\n\nvoid b43legacy_generate_plcp_hdr(struct b43legacy_plcp_hdr4 *plcp,\n\t\t\t\t const u16 octets, const u8 bitrate)\n{\n\t__le32 *data = &(plcp->data);\n\t__u8 *raw = plcp->raw;\n\n\tif (b43legacy_is_ofdm_rate(bitrate)) {\n\t\tu16 d;\n\n\t\td = b43legacy_plcp_get_ratecode_ofdm(bitrate);\n\t\tB43legacy_WARN_ON(octets & 0xF000);\n\t\td |= (octets << 5);\n\t\t*data = cpu_to_le32(d);\n\t} else {\n\t\tu32 plen;\n\n\t\tplen = octets * 16 / bitrate;\n\t\tif ((octets * 16 % bitrate) > 0) {\n\t\t\tplen++;\n\t\t\tif ((bitrate == B43legacy_CCK_RATE_11MB)\n\t\t\t    && ((octets * 8 % 11) < 4))\n\t\t\t\traw[1] = 0x84;\n\t\t\telse\n\t\t\t\traw[1] = 0x04;\n\t\t} else\n\t\t\traw[1] = 0x04;\n\t\t*data |= cpu_to_le32(plen << 16);\n\t\traw[0] = b43legacy_plcp_get_ratecode_cck(bitrate);\n\t}\n}\n\nstatic u8 b43legacy_calc_fallback_rate(u8 bitrate)\n{\n\tswitch (bitrate) {\n\tcase B43legacy_CCK_RATE_1MB:\n\t\treturn B43legacy_CCK_RATE_1MB;\n\tcase B43legacy_CCK_RATE_2MB:\n\t\treturn B43legacy_CCK_RATE_1MB;\n\tcase B43legacy_CCK_RATE_5MB:\n\t\treturn B43legacy_CCK_RATE_2MB;\n\tcase B43legacy_CCK_RATE_11MB:\n\t\treturn B43legacy_CCK_RATE_5MB;\n\tcase B43legacy_OFDM_RATE_6MB:\n\t\treturn B43legacy_CCK_RATE_5MB;\n\tcase B43legacy_OFDM_RATE_9MB:\n\t\treturn B43legacy_OFDM_RATE_6MB;\n\tcase B43legacy_OFDM_RATE_12MB:\n\t\treturn B43legacy_OFDM_RATE_9MB;\n\tcase B43legacy_OFDM_RATE_18MB:\n\t\treturn B43legacy_OFDM_RATE_12MB;\n\tcase B43legacy_OFDM_RATE_24MB:\n\t\treturn B43legacy_OFDM_RATE_18MB;\n\tcase B43legacy_OFDM_RATE_36MB:\n\t\treturn B43legacy_OFDM_RATE_24MB;\n\tcase B43legacy_OFDM_RATE_48MB:\n\t\treturn B43legacy_OFDM_RATE_36MB;\n\tcase B43legacy_OFDM_RATE_54MB:\n\t\treturn B43legacy_OFDM_RATE_48MB;\n\t}\n\tB43legacy_BUG_ON(1);\n\treturn 0;\n}\n\nstatic int generate_txhdr_fw3(struct b43legacy_wldev *dev,\n\t\t\t       struct b43legacy_txhdr_fw3 *txhdr,\n\t\t\t       const unsigned char *fragment_data,\n\t\t\t       unsigned int fragment_len,\n\t\t\t       struct ieee80211_tx_info *info,\n\t\t\t       u16 cookie)\n{\n\tconst struct ieee80211_hdr *wlhdr;\n\tint use_encryption = !!info->control.hw_key;\n\tu8 rate;\n\tstruct ieee80211_rate *rate_fb;\n\tint rate_ofdm;\n\tint rate_fb_ofdm;\n\tunsigned int plcp_fragment_len;\n\tu32 mac_ctl = 0;\n\tu16 phy_ctl = 0;\n\tstruct ieee80211_rate *tx_rate;\n\tstruct ieee80211_tx_rate *rates;\n\n\twlhdr = (const struct ieee80211_hdr *)fragment_data;\n\n\tmemset(txhdr, 0, sizeof(*txhdr));\n\n\ttx_rate = ieee80211_get_tx_rate(dev->wl->hw, info);\n\n\trate = tx_rate->hw_value;\n\trate_ofdm = b43legacy_is_ofdm_rate(rate);\n\trate_fb = ieee80211_get_alt_retry_rate(dev->wl->hw, info, 0) ? : tx_rate;\n\trate_fb_ofdm = b43legacy_is_ofdm_rate(rate_fb->hw_value);\n\n\ttxhdr->mac_frame_ctl = wlhdr->frame_control;\n\tmemcpy(txhdr->tx_receiver, wlhdr->addr1, ETH_ALEN);\n\n\t \n\tif ((rate_fb->hw_value == rate) ||\n\t    (wlhdr->duration_id & cpu_to_le16(0x8000)) ||\n\t    (wlhdr->duration_id == cpu_to_le16(0))) {\n\t\t \n\t\ttxhdr->dur_fb = wlhdr->duration_id;\n\t} else {\n\t\ttxhdr->dur_fb = ieee80211_generic_frame_duration(dev->wl->hw,\n\t\t\t\t\t\t\t info->control.vif,\n\t\t\t\t\t\t\t info->band,\n\t\t\t\t\t\t\t fragment_len,\n\t\t\t\t\t\t\t rate_fb);\n\t}\n\n\tplcp_fragment_len = fragment_len + FCS_LEN;\n\tif (use_encryption) {\n\t\tu8 key_idx = info->control.hw_key->hw_key_idx;\n\t\tstruct b43legacy_key *key;\n\t\tint wlhdr_len;\n\t\tsize_t iv_len;\n\n\t\tB43legacy_WARN_ON(key_idx >= dev->max_nr_keys);\n\t\tkey = &(dev->key[key_idx]);\n\n\t\tif (key->enabled) {\n\t\t\t \n\t\t\tplcp_fragment_len += info->control.hw_key->icv_len;\n\n\t\t\tkey_idx = b43legacy_kidx_to_fw(dev, key_idx);\n\t\t\tmac_ctl |= (key_idx << B43legacy_TX4_MAC_KEYIDX_SHIFT) &\n\t\t\t\t   B43legacy_TX4_MAC_KEYIDX;\n\t\t\tmac_ctl |= (key->algorithm <<\n\t\t\t\t   B43legacy_TX4_MAC_KEYALG_SHIFT) &\n\t\t\t\t   B43legacy_TX4_MAC_KEYALG;\n\t\t\twlhdr_len = ieee80211_hdrlen(wlhdr->frame_control);\n\t\t\tiv_len = min_t(size_t, info->control.hw_key->iv_len,\n\t\t\t\t     ARRAY_SIZE(txhdr->iv));\n\t\t\tmemcpy(txhdr->iv, ((u8 *)wlhdr) + wlhdr_len, iv_len);\n\t\t} else {\n\t\t\t \n\t\t\treturn -ENOKEY;\n\t\t}\n\t}\n\tb43legacy_generate_plcp_hdr((struct b43legacy_plcp_hdr4 *)\n\t\t\t\t    (&txhdr->plcp), plcp_fragment_len,\n\t\t\t\t    rate);\n\tb43legacy_generate_plcp_hdr(&txhdr->plcp_fb, plcp_fragment_len,\n\t\t\t\t    rate_fb->hw_value);\n\n\t \n\tif (rate_ofdm)\n\t\tphy_ctl |= B43legacy_TX4_PHY_ENC_OFDM;\n\tif (info->control.rates[0].flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE)\n\t\tphy_ctl |= B43legacy_TX4_PHY_SHORTPRMBL;\n\tphy_ctl |= B43legacy_TX4_PHY_ANTLAST;\n\n\t \n\trates = info->control.rates;\n\tif (!(info->flags & IEEE80211_TX_CTL_NO_ACK))\n\t\tmac_ctl |= B43legacy_TX4_MAC_ACK;\n\tif (info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ)\n\t\tmac_ctl |= B43legacy_TX4_MAC_HWSEQ;\n\tif (info->flags & IEEE80211_TX_CTL_FIRST_FRAGMENT)\n\t\tmac_ctl |= B43legacy_TX4_MAC_STMSDU;\n\tif (rate_fb_ofdm)\n\t\tmac_ctl |= B43legacy_TX4_MAC_FALLBACKOFDM;\n\n\t \n\tif ((rates[0].flags & IEEE80211_TX_RC_USE_RTS_CTS) ||\n\t    (rates[0].count <= dev->wl->hw->conf.long_frame_max_tx_count)) {\n\t\trates[0].count = dev->wl->hw->conf.long_frame_max_tx_count;\n\t\tmac_ctl |= B43legacy_TX4_MAC_LONGFRAME;\n\t} else {\n\t\trates[0].count = dev->wl->hw->conf.short_frame_max_tx_count;\n\t}\n\n\t \n\tif ((rates[0].flags & IEEE80211_TX_RC_USE_RTS_CTS) ||\n\t    (rates[0].flags & IEEE80211_TX_RC_USE_CTS_PROTECT)) {\n\t\tunsigned int len;\n\t\tstruct ieee80211_hdr *hdr;\n\t\tint rts_rate;\n\t\tint rts_rate_fb;\n\t\tint rts_rate_fb_ofdm;\n\n\t\trts_rate = ieee80211_get_rts_cts_rate(dev->wl->hw, info)->hw_value;\n\t\trts_rate_fb = b43legacy_calc_fallback_rate(rts_rate);\n\t\trts_rate_fb_ofdm = b43legacy_is_ofdm_rate(rts_rate_fb);\n\t\tif (rts_rate_fb_ofdm)\n\t\t\tmac_ctl |= B43legacy_TX4_MAC_CTSFALLBACKOFDM;\n\n\t\tif (rates[0].flags & IEEE80211_TX_RC_USE_CTS_PROTECT) {\n\t\t\tieee80211_ctstoself_get(dev->wl->hw,\n\t\t\t\t\t\tinfo->control.vif,\n\t\t\t\t\t\tfragment_data,\n\t\t\t\t\t\tfragment_len, info,\n\t\t\t\t\t\t(struct ieee80211_cts *)\n\t\t\t\t\t\t(txhdr->rts_frame));\n\t\t\tmac_ctl |= B43legacy_TX4_MAC_SENDCTS;\n\t\t\tlen = sizeof(struct ieee80211_cts);\n\t\t} else {\n\t\t\tieee80211_rts_get(dev->wl->hw,\n\t\t\t\t\t  info->control.vif,\n\t\t\t\t\t  fragment_data, fragment_len, info,\n\t\t\t\t\t  (struct ieee80211_rts *)\n\t\t\t\t\t  (txhdr->rts_frame));\n\t\t\tmac_ctl |= B43legacy_TX4_MAC_SENDRTS;\n\t\t\tlen = sizeof(struct ieee80211_rts);\n\t\t}\n\t\tlen += FCS_LEN;\n\t\tb43legacy_generate_plcp_hdr((struct b43legacy_plcp_hdr4 *)\n\t\t\t\t\t    (&txhdr->rts_plcp),\n\t\t\t\t\t    len, rts_rate);\n\t\tb43legacy_generate_plcp_hdr(&txhdr->rts_plcp_fb,\n\t\t\t\t\t    len, rts_rate_fb);\n\t\thdr = (struct ieee80211_hdr *)(&txhdr->rts_frame);\n\t\ttxhdr->rts_dur_fb = hdr->duration_id;\n\t}\n\n\t \n\ttxhdr->cookie = cpu_to_le16(cookie);\n\n\t \n\ttxhdr->mac_ctl = cpu_to_le32(mac_ctl);\n\ttxhdr->phy_ctl = cpu_to_le16(phy_ctl);\n\n\treturn 0;\n}\n\nint b43legacy_generate_txhdr(struct b43legacy_wldev *dev,\n\t\t\t      u8 *txhdr,\n\t\t\t      const unsigned char *fragment_data,\n\t\t\t      unsigned int fragment_len,\n\t\t\t      struct ieee80211_tx_info *info,\n\t\t\t      u16 cookie)\n{\n\treturn generate_txhdr_fw3(dev, (struct b43legacy_txhdr_fw3 *)txhdr,\n\t\t\t   fragment_data, fragment_len,\n\t\t\t   info, cookie);\n}\n\nstatic s8 b43legacy_rssi_postprocess(struct b43legacy_wldev *dev,\n\t\t\t\t     u8 in_rssi, int ofdm,\n\t\t\t\t     int adjust_2053, int adjust_2050)\n{\n\tstruct b43legacy_phy *phy = &dev->phy;\n\ts32 tmp;\n\n\tswitch (phy->radio_ver) {\n\tcase 0x2050:\n\t\tif (ofdm) {\n\t\t\ttmp = in_rssi;\n\t\t\tif (tmp > 127)\n\t\t\t\ttmp -= 256;\n\t\t\ttmp *= 73;\n\t\t\ttmp /= 64;\n\t\t\tif (adjust_2050)\n\t\t\t\ttmp += 25;\n\t\t\telse\n\t\t\t\ttmp -= 3;\n\t\t} else {\n\t\t\tif (dev->dev->bus->sprom.boardflags_lo\n\t\t\t    & B43legacy_BFL_RSSI) {\n\t\t\t\tif (in_rssi > 63)\n\t\t\t\t\tin_rssi = 63;\n\t\t\t\ttmp = phy->nrssi_lt[in_rssi];\n\t\t\t\ttmp = 31 - tmp;\n\t\t\t\ttmp *= -131;\n\t\t\t\ttmp /= 128;\n\t\t\t\ttmp -= 57;\n\t\t\t} else {\n\t\t\t\ttmp = in_rssi;\n\t\t\t\ttmp = 31 - tmp;\n\t\t\t\ttmp *= -149;\n\t\t\t\ttmp /= 128;\n\t\t\t\ttmp -= 68;\n\t\t\t}\n\t\t\tif (phy->type == B43legacy_PHYTYPE_G &&\n\t\t\t    adjust_2050)\n\t\t\t\ttmp += 25;\n\t\t}\n\t\tbreak;\n\tcase 0x2060:\n\t\tif (in_rssi > 127)\n\t\t\ttmp = in_rssi - 256;\n\t\telse\n\t\t\ttmp = in_rssi;\n\t\tbreak;\n\tdefault:\n\t\ttmp = in_rssi;\n\t\ttmp -= 11;\n\t\ttmp *= 103;\n\t\ttmp /= 64;\n\t\tif (adjust_2053)\n\t\t\ttmp -= 109;\n\t\telse\n\t\t\ttmp -= 83;\n\t}\n\n\treturn (s8)tmp;\n}\n\nvoid b43legacy_rx(struct b43legacy_wldev *dev,\n\t\t  struct sk_buff *skb,\n\t\t  const void *_rxhdr)\n{\n\tstruct ieee80211_rx_status status;\n\tstruct b43legacy_plcp_hdr6 *plcp;\n\tstruct ieee80211_hdr *wlhdr;\n\tconst struct b43legacy_rxhdr_fw3 *rxhdr = _rxhdr;\n\t__le16 fctl;\n\tu16 phystat0;\n\tu16 phystat3;\n\tu16 chanstat;\n\tu16 mactime;\n\tu32 macstat;\n\tu16 chanid;\n\tu8 jssi;\n\tint padding;\n\n\tmemset(&status, 0, sizeof(status));\n\n\t \n\tphystat0 = le16_to_cpu(rxhdr->phy_status0);\n\tphystat3 = le16_to_cpu(rxhdr->phy_status3);\n\tjssi = rxhdr->jssi;\n\tmacstat = le16_to_cpu(rxhdr->mac_status);\n\tmactime = le16_to_cpu(rxhdr->mac_time);\n\tchanstat = le16_to_cpu(rxhdr->channel);\n\n\tif (macstat & B43legacy_RX_MAC_FCSERR)\n\t\tdev->wl->ieee_stats.dot11FCSErrorCount++;\n\n\t \n\tpadding = (macstat & B43legacy_RX_MAC_PADDING) ? 2 : 0;\n\tif (unlikely(skb->len < (sizeof(struct b43legacy_plcp_hdr6) +\n\t    padding))) {\n\t\tb43legacydbg(dev->wl, \"RX: Packet size underrun (1)\\n\");\n\t\tgoto drop;\n\t}\n\tplcp = (struct b43legacy_plcp_hdr6 *)(skb->data + padding);\n\tskb_pull(skb, sizeof(struct b43legacy_plcp_hdr6) + padding);\n\t \n\tif (unlikely(skb->len < (2+2+6  + FCS_LEN))) {\n\t\tb43legacydbg(dev->wl, \"RX: Packet size underrun (2)\\n\");\n\t\tgoto drop;\n\t}\n\twlhdr = (struct ieee80211_hdr *)(skb->data);\n\tfctl = wlhdr->frame_control;\n\n\tif ((macstat & B43legacy_RX_MAC_DEC) &&\n\t    !(macstat & B43legacy_RX_MAC_DECERR)) {\n\t\tunsigned int keyidx;\n\t\tint wlhdr_len;\n\t\tint iv_len;\n\t\tint icv_len;\n\n\t\tkeyidx = ((macstat & B43legacy_RX_MAC_KEYIDX)\n\t\t\t  >> B43legacy_RX_MAC_KEYIDX_SHIFT);\n\t\t \n\t\tkeyidx = b43legacy_kidx_to_raw(dev, keyidx);\n\t\tB43legacy_WARN_ON(keyidx >= dev->max_nr_keys);\n\n\t\tif (dev->key[keyidx].algorithm != B43legacy_SEC_ALGO_NONE) {\n\t\t\t \n\t\t\tB43legacy_WARN_ON(!ieee80211_has_protected(fctl));\n\t\t\tfctl &= ~cpu_to_le16(IEEE80211_FCTL_PROTECTED);\n\t\t\twlhdr->frame_control = fctl;\n\n\t\t\twlhdr_len = ieee80211_hdrlen(fctl);\n\t\t\tif (unlikely(skb->len < (wlhdr_len + 3))) {\n\t\t\t\tb43legacydbg(dev->wl, \"RX: Packet size\"\n\t\t\t\t\t     \" underrun3\\n\");\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\tif (skb->data[wlhdr_len + 3] & (1 << 5)) {\n\t\t\t\t \n\t\t\t\tiv_len = 8;\n\t\t\t\ticv_len = 8;\n\t\t\t} else {\n\t\t\t\tiv_len = 4;\n\t\t\t\ticv_len = 4;\n\t\t\t}\n\t\t\tif (unlikely(skb->len < (wlhdr_len + iv_len +\n\t\t\t    icv_len))) {\n\t\t\t\tb43legacydbg(dev->wl, \"RX: Packet size\"\n\t\t\t\t\t     \" underrun4\\n\");\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\t \n\t\t\tmemmove(skb->data + iv_len, skb->data, wlhdr_len);\n\t\t\tskb_pull(skb, iv_len);\n\t\t\t \n\t\t\tskb_trim(skb, skb->len - icv_len);\n\n\t\t\tstatus.flag |= RX_FLAG_DECRYPTED;\n\t\t}\n\t}\n\n\tstatus.signal = b43legacy_rssi_postprocess(dev, jssi,\n\t\t\t\t      (phystat0 & B43legacy_RX_PHYST0_OFDM),\n\t\t\t\t      (phystat0 & B43legacy_RX_PHYST0_GAINCTL),\n\t\t\t\t      (phystat3 & B43legacy_RX_PHYST3_TRSTATE));\n\t \n\tif (phystat0 & B43legacy_RX_PHYST0_OFDM)\n\t\tstatus.rate_idx = b43legacy_plcp_get_bitrate_idx_ofdm(plcp, false);\n\telse\n\t\tstatus.rate_idx = b43legacy_plcp_get_bitrate_idx_cck(plcp);\n\tstatus.antenna = !!(phystat0 & B43legacy_RX_PHYST0_ANT);\n\n\t \n\tif (ieee80211_is_beacon(fctl) || dev->wl->radiotap_enabled) {\n\t\tu16 low_mactime_now;\n\n\t\tb43legacy_tsf_read(dev, &status.mactime);\n\t\tlow_mactime_now = status.mactime;\n\t\tstatus.mactime = status.mactime & ~0xFFFFULL;\n\t\tstatus.mactime += mactime;\n\t\tif (low_mactime_now <= mactime)\n\t\t\tstatus.mactime -= 0x10000;\n\t\tstatus.flag |= RX_FLAG_MACTIME_START;\n\t}\n\n\tchanid = (chanstat & B43legacy_RX_CHAN_ID) >>\n\t\t  B43legacy_RX_CHAN_ID_SHIFT;\n\tswitch (chanstat & B43legacy_RX_CHAN_PHYTYPE) {\n\tcase B43legacy_PHYTYPE_B:\n\tcase B43legacy_PHYTYPE_G:\n\t\tstatus.band = NL80211_BAND_2GHZ;\n\t\tstatus.freq = chanid + 2400;\n\t\tbreak;\n\tdefault:\n\t\tb43legacywarn(dev->wl, \"Unexpected value for chanstat (0x%X)\\n\",\n\t\t       chanstat);\n\t\tgoto drop;\n\t}\n\n\tmemcpy(IEEE80211_SKB_RXCB(skb), &status, sizeof(status));\n\tieee80211_rx_irqsafe(dev->wl->hw, skb);\n\n\treturn;\ndrop:\n\tb43legacydbg(dev->wl, \"RX: Packet dropped\\n\");\n\tdev_kfree_skb_any(skb);\n}\n\nvoid b43legacy_handle_txstatus(struct b43legacy_wldev *dev,\n\t\t\t     const struct b43legacy_txstatus *status)\n{\n\tb43legacy_debugfs_log_txstat(dev, status);\n\n\tif (status->intermediate)\n\t\treturn;\n\tif (status->for_ampdu)\n\t\treturn;\n\tif (!status->acked)\n\t\tdev->wl->ieee_stats.dot11ACKFailureCount++;\n\tif (status->rts_count) {\n\t\tif (status->rts_count == 0xF)  \n\t\t\tdev->wl->ieee_stats.dot11RTSFailureCount++;\n\t\telse\n\t\t\tdev->wl->ieee_stats.dot11RTSSuccessCount++;\n\t}\n\n\tif (b43legacy_using_pio(dev))\n\t\tb43legacy_pio_handle_txstatus(dev, status);\n\telse\n\t\tb43legacy_dma_handle_txstatus(dev, status);\n}\n\n \nvoid b43legacy_handle_hwtxstatus(struct b43legacy_wldev *dev,\n\t\t\t\t const struct b43legacy_hwtxstatus *hw)\n{\n\tstruct b43legacy_txstatus status;\n\tu8 tmp;\n\n\tstatus.cookie = le16_to_cpu(hw->cookie);\n\tstatus.seq = le16_to_cpu(hw->seq);\n\tstatus.phy_stat = hw->phy_stat;\n\ttmp = hw->count;\n\tstatus.frame_count = (tmp >> 4);\n\tstatus.rts_count = (tmp & 0x0F);\n\ttmp = hw->flags << 1;\n\tstatus.supp_reason = ((tmp & 0x1C) >> 2);\n\tstatus.pm_indicated = !!(tmp & 0x80);\n\tstatus.intermediate = !!(tmp & 0x40);\n\tstatus.for_ampdu = !!(tmp & 0x20);\n\tstatus.acked = !!(tmp & 0x02);\n\n\tb43legacy_handle_txstatus(dev, &status);\n}\n\n \nvoid b43legacy_tx_suspend(struct b43legacy_wldev *dev)\n{\n\tif (b43legacy_using_pio(dev))\n\t\tb43legacy_pio_freeze_txqueues(dev);\n\telse\n\t\tb43legacy_dma_tx_suspend(dev);\n}\n\n \nvoid b43legacy_tx_resume(struct b43legacy_wldev *dev)\n{\n\tif (b43legacy_using_pio(dev))\n\t\tb43legacy_pio_thaw_txqueues(dev);\n\telse\n\t\tb43legacy_dma_tx_resume(dev);\n}\n\n \nvoid b43legacy_qos_init(struct b43legacy_wldev *dev)\n{\n\t \nreturn;\n\n\tb43legacy_hf_write(dev, b43legacy_hf_read(dev) | B43legacy_HF_EDCF);\n\t \n\tb43legacy_write16(dev, 0x688,\n\t\t\t  b43legacy_read16(dev, 0x688) | 0x4);\n\n\n\t \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}