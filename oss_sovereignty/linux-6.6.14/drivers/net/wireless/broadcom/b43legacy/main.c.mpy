{
  "module_name": "main.c",
  "hash_id": "a2a35338b46e908b2175d4bb5e517ebac8300555ebd86141985ef80da2a8472f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/b43legacy/main.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/if_arp.h>\n#include <linux/etherdevice.h>\n#include <linux/firmware.h>\n#include <linux/workqueue.h>\n#include <linux/sched/signal.h>\n#include <linux/skbuff.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <net/dst.h>\n#include <asm/unaligned.h>\n\n#include \"b43legacy.h\"\n#include \"main.h\"\n#include \"debugfs.h\"\n#include \"phy.h\"\n#include \"dma.h\"\n#include \"pio.h\"\n#include \"sysfs.h\"\n#include \"xmit.h\"\n#include \"radio.h\"\n\n\nMODULE_DESCRIPTION(\"Broadcom B43legacy wireless driver\");\nMODULE_AUTHOR(\"Martin Langer\");\nMODULE_AUTHOR(\"Stefano Brivio\");\nMODULE_AUTHOR(\"Michael Buesch\");\nMODULE_LICENSE(\"GPL\");\n\nMODULE_FIRMWARE(\"b43legacy/ucode2.fw\");\nMODULE_FIRMWARE(\"b43legacy/ucode4.fw\");\n\n#if defined(CONFIG_B43LEGACY_DMA) && defined(CONFIG_B43LEGACY_PIO)\nstatic int modparam_pio;\nmodule_param_named(pio, modparam_pio, int, 0444);\nMODULE_PARM_DESC(pio, \"enable(1) / disable(0) PIO mode\");\n#elif defined(CONFIG_B43LEGACY_DMA)\n# define modparam_pio\t0\n#elif defined(CONFIG_B43LEGACY_PIO)\n# define modparam_pio\t1\n#endif\n\nstatic int modparam_bad_frames_preempt;\nmodule_param_named(bad_frames_preempt, modparam_bad_frames_preempt, int, 0444);\nMODULE_PARM_DESC(bad_frames_preempt, \"enable(1) / disable(0) Bad Frames\"\n\t\t \" Preemption\");\n\nstatic char modparam_fwpostfix[16];\nmodule_param_string(fwpostfix, modparam_fwpostfix, 16, 0444);\nMODULE_PARM_DESC(fwpostfix, \"Postfix for the firmware files to load.\");\n\n \nstatic const struct ssb_device_id b43legacy_ssb_tbl[] = {\n\tSSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 2),\n\tSSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 4),\n\t{},\n};\nMODULE_DEVICE_TABLE(ssb, b43legacy_ssb_tbl);\n\n\n \n#define RATETAB_ENT(_rateid, _flags) \\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.bitrate\t= B43legacy_RATE_TO_100KBPS(_rateid),\t\\\n\t\t.hw_value\t= (_rateid),\t\t\t\t\\\n\t\t.flags\t\t= (_flags),\t\t\t\t\\\n\t}\n \nstatic struct ieee80211_rate __b43legacy_ratetable[] = {\n\tRATETAB_ENT(B43legacy_CCK_RATE_1MB, 0),\n\tRATETAB_ENT(B43legacy_CCK_RATE_2MB, IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATETAB_ENT(B43legacy_CCK_RATE_5MB, IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATETAB_ENT(B43legacy_CCK_RATE_11MB, IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATETAB_ENT(B43legacy_OFDM_RATE_6MB, 0),\n\tRATETAB_ENT(B43legacy_OFDM_RATE_9MB, 0),\n\tRATETAB_ENT(B43legacy_OFDM_RATE_12MB, 0),\n\tRATETAB_ENT(B43legacy_OFDM_RATE_18MB, 0),\n\tRATETAB_ENT(B43legacy_OFDM_RATE_24MB, 0),\n\tRATETAB_ENT(B43legacy_OFDM_RATE_36MB, 0),\n\tRATETAB_ENT(B43legacy_OFDM_RATE_48MB, 0),\n\tRATETAB_ENT(B43legacy_OFDM_RATE_54MB, 0),\n};\n#define b43legacy_b_ratetable\t\t(__b43legacy_ratetable + 0)\n#define b43legacy_b_ratetable_size\t4\n#define b43legacy_g_ratetable\t\t(__b43legacy_ratetable + 0)\n#define b43legacy_g_ratetable_size\t12\n\n#define CHANTAB_ENT(_chanid, _freq) \\\n\t{\t\t\t\t\t\t\t\\\n\t\t.center_freq\t= (_freq),\t\t\t\\\n\t\t.hw_value\t= (_chanid),\t\t\t\\\n\t}\nstatic struct ieee80211_channel b43legacy_bg_chantable[] = {\n\tCHANTAB_ENT(1, 2412),\n\tCHANTAB_ENT(2, 2417),\n\tCHANTAB_ENT(3, 2422),\n\tCHANTAB_ENT(4, 2427),\n\tCHANTAB_ENT(5, 2432),\n\tCHANTAB_ENT(6, 2437),\n\tCHANTAB_ENT(7, 2442),\n\tCHANTAB_ENT(8, 2447),\n\tCHANTAB_ENT(9, 2452),\n\tCHANTAB_ENT(10, 2457),\n\tCHANTAB_ENT(11, 2462),\n\tCHANTAB_ENT(12, 2467),\n\tCHANTAB_ENT(13, 2472),\n\tCHANTAB_ENT(14, 2484),\n};\n\nstatic struct ieee80211_supported_band b43legacy_band_2GHz_BPHY = {\n\t.channels = b43legacy_bg_chantable,\n\t.n_channels = ARRAY_SIZE(b43legacy_bg_chantable),\n\t.bitrates = b43legacy_b_ratetable,\n\t.n_bitrates = b43legacy_b_ratetable_size,\n};\n\nstatic struct ieee80211_supported_band b43legacy_band_2GHz_GPHY = {\n\t.channels = b43legacy_bg_chantable,\n\t.n_channels = ARRAY_SIZE(b43legacy_bg_chantable),\n\t.bitrates = b43legacy_g_ratetable,\n\t.n_bitrates = b43legacy_g_ratetable_size,\n};\n\nstatic void b43legacy_wireless_core_exit(struct b43legacy_wldev *dev);\nstatic int b43legacy_wireless_core_init(struct b43legacy_wldev *dev);\nstatic void b43legacy_wireless_core_stop(struct b43legacy_wldev *dev);\nstatic int b43legacy_wireless_core_start(struct b43legacy_wldev *dev);\n\n\nstatic int b43legacy_ratelimit(struct b43legacy_wl *wl)\n{\n\tif (!wl || !wl->current_dev)\n\t\treturn 1;\n\tif (b43legacy_status(wl->current_dev) < B43legacy_STAT_STARTED)\n\t\treturn 1;\n\t \n\treturn net_ratelimit();\n}\n\nvoid b43legacyinfo(struct b43legacy_wl *wl, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!b43legacy_ratelimit(wl))\n\t\treturn;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_INFO \"b43legacy-%s: %pV\",\n\t       (wl && wl->hw) ? wiphy_name(wl->hw->wiphy) : \"wlan\", &vaf);\n\n\tva_end(args);\n}\n\nvoid b43legacyerr(struct b43legacy_wl *wl, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!b43legacy_ratelimit(wl))\n\t\treturn;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_ERR \"b43legacy-%s ERROR: %pV\",\n\t       (wl && wl->hw) ? wiphy_name(wl->hw->wiphy) : \"wlan\", &vaf);\n\n\tva_end(args);\n}\n\nvoid b43legacywarn(struct b43legacy_wl *wl, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!b43legacy_ratelimit(wl))\n\t\treturn;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"b43legacy-%s warning: %pV\",\n\t       (wl && wl->hw) ? wiphy_name(wl->hw->wiphy) : \"wlan\", &vaf);\n\n\tva_end(args);\n}\n\n#if B43legacy_DEBUG\nvoid b43legacydbg(struct b43legacy_wl *wl, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_DEBUG \"b43legacy-%s debug: %pV\",\n\t       (wl && wl->hw) ? wiphy_name(wl->hw->wiphy) : \"wlan\", &vaf);\n\n\tva_end(args);\n}\n#endif  \n\nstatic void b43legacy_ram_write(struct b43legacy_wldev *dev, u16 offset,\n\t\t\t\tu32 val)\n{\n\tu32 status;\n\n\tB43legacy_WARN_ON(offset % 4 != 0);\n\n\tstatus = b43legacy_read32(dev, B43legacy_MMIO_MACCTL);\n\tif (status & B43legacy_MACCTL_BE)\n\t\tval = swab32(val);\n\n\tb43legacy_write32(dev, B43legacy_MMIO_RAM_CONTROL, offset);\n\tb43legacy_write32(dev, B43legacy_MMIO_RAM_DATA, val);\n}\n\nstatic inline\nvoid b43legacy_shm_control_word(struct b43legacy_wldev *dev,\n\t\t\t\tu16 routing, u16 offset)\n{\n\tu32 control;\n\n\t \n\n\tcontrol = routing;\n\tcontrol <<= 16;\n\tcontrol |= offset;\n\tb43legacy_write32(dev, B43legacy_MMIO_SHM_CONTROL, control);\n}\n\nu32 b43legacy_shm_read32(struct b43legacy_wldev *dev,\n\t\t       u16 routing, u16 offset)\n{\n\tu32 ret;\n\n\tif (routing == B43legacy_SHM_SHARED) {\n\t\tB43legacy_WARN_ON((offset & 0x0001) != 0);\n\t\tif (offset & 0x0003) {\n\t\t\t \n\t\t\tb43legacy_shm_control_word(dev, routing, offset >> 2);\n\t\t\tret = b43legacy_read16(dev,\n\t\t\t\tB43legacy_MMIO_SHM_DATA_UNALIGNED);\n\t\t\tret <<= 16;\n\t\t\tb43legacy_shm_control_word(dev, routing,\n\t\t\t\t\t\t     (offset >> 2) + 1);\n\t\t\tret |= b43legacy_read16(dev, B43legacy_MMIO_SHM_DATA);\n\n\t\t\treturn ret;\n\t\t}\n\t\toffset >>= 2;\n\t}\n\tb43legacy_shm_control_word(dev, routing, offset);\n\tret = b43legacy_read32(dev, B43legacy_MMIO_SHM_DATA);\n\n\treturn ret;\n}\n\nu16 b43legacy_shm_read16(struct b43legacy_wldev *dev,\n\t\t\t   u16 routing, u16 offset)\n{\n\tu16 ret;\n\n\tif (routing == B43legacy_SHM_SHARED) {\n\t\tB43legacy_WARN_ON((offset & 0x0001) != 0);\n\t\tif (offset & 0x0003) {\n\t\t\t \n\t\t\tb43legacy_shm_control_word(dev, routing, offset >> 2);\n\t\t\tret = b43legacy_read16(dev,\n\t\t\t\t\t     B43legacy_MMIO_SHM_DATA_UNALIGNED);\n\n\t\t\treturn ret;\n\t\t}\n\t\toffset >>= 2;\n\t}\n\tb43legacy_shm_control_word(dev, routing, offset);\n\tret = b43legacy_read16(dev, B43legacy_MMIO_SHM_DATA);\n\n\treturn ret;\n}\n\nvoid b43legacy_shm_write32(struct b43legacy_wldev *dev,\n\t\t\t   u16 routing, u16 offset,\n\t\t\t   u32 value)\n{\n\tif (routing == B43legacy_SHM_SHARED) {\n\t\tB43legacy_WARN_ON((offset & 0x0001) != 0);\n\t\tif (offset & 0x0003) {\n\t\t\t \n\t\t\tb43legacy_shm_control_word(dev, routing, offset >> 2);\n\t\t\tb43legacy_write16(dev,\n\t\t\t\t\t  B43legacy_MMIO_SHM_DATA_UNALIGNED,\n\t\t\t\t\t  (value >> 16) & 0xffff);\n\t\t\tb43legacy_shm_control_word(dev, routing,\n\t\t\t\t\t\t   (offset >> 2) + 1);\n\t\t\tb43legacy_write16(dev, B43legacy_MMIO_SHM_DATA,\n\t\t\t\t\t  value & 0xffff);\n\t\t\treturn;\n\t\t}\n\t\toffset >>= 2;\n\t}\n\tb43legacy_shm_control_word(dev, routing, offset);\n\tb43legacy_write32(dev, B43legacy_MMIO_SHM_DATA, value);\n}\n\nvoid b43legacy_shm_write16(struct b43legacy_wldev *dev, u16 routing, u16 offset,\n\t\t\t   u16 value)\n{\n\tif (routing == B43legacy_SHM_SHARED) {\n\t\tB43legacy_WARN_ON((offset & 0x0001) != 0);\n\t\tif (offset & 0x0003) {\n\t\t\t \n\t\t\tb43legacy_shm_control_word(dev, routing, offset >> 2);\n\t\t\tb43legacy_write16(dev,\n\t\t\t\t\t  B43legacy_MMIO_SHM_DATA_UNALIGNED,\n\t\t\t\t\t  value);\n\t\t\treturn;\n\t\t}\n\t\toffset >>= 2;\n\t}\n\tb43legacy_shm_control_word(dev, routing, offset);\n\tb43legacy_write16(dev, B43legacy_MMIO_SHM_DATA, value);\n}\n\n \nu32 b43legacy_hf_read(struct b43legacy_wldev *dev)\n{\n\tu32 ret;\n\n\tret = b43legacy_shm_read16(dev, B43legacy_SHM_SHARED,\n\t\t\t\t   B43legacy_SHM_SH_HOSTFHI);\n\tret <<= 16;\n\tret |= b43legacy_shm_read16(dev, B43legacy_SHM_SHARED,\n\t\t\t\t    B43legacy_SHM_SH_HOSTFLO);\n\n\treturn ret;\n}\n\n \nvoid b43legacy_hf_write(struct b43legacy_wldev *dev, u32 value)\n{\n\tb43legacy_shm_write16(dev, B43legacy_SHM_SHARED,\n\t\t\t      B43legacy_SHM_SH_HOSTFLO,\n\t\t\t      (value & 0x0000FFFF));\n\tb43legacy_shm_write16(dev, B43legacy_SHM_SHARED,\n\t\t\t      B43legacy_SHM_SH_HOSTFHI,\n\t\t\t      ((value & 0xFFFF0000) >> 16));\n}\n\nvoid b43legacy_tsf_read(struct b43legacy_wldev *dev, u64 *tsf)\n{\n\t \n\tif (dev->dev->id.revision >= 3) {\n\t\tu32 low;\n\t\tu32 high;\n\t\tu32 high2;\n\n\t\tdo {\n\t\t\thigh = b43legacy_read32(dev,\n\t\t\t\t\tB43legacy_MMIO_REV3PLUS_TSF_HIGH);\n\t\t\tlow = b43legacy_read32(dev,\n\t\t\t\t\tB43legacy_MMIO_REV3PLUS_TSF_LOW);\n\t\t\thigh2 = b43legacy_read32(dev,\n\t\t\t\t\tB43legacy_MMIO_REV3PLUS_TSF_HIGH);\n\t\t} while (unlikely(high != high2));\n\n\t\t*tsf = high;\n\t\t*tsf <<= 32;\n\t\t*tsf |= low;\n\t} else {\n\t\tu64 tmp;\n\t\tu16 v0;\n\t\tu16 v1;\n\t\tu16 v2;\n\t\tu16 v3;\n\t\tu16 test1;\n\t\tu16 test2;\n\t\tu16 test3;\n\n\t\tdo {\n\t\t\tv3 = b43legacy_read16(dev, B43legacy_MMIO_TSF_3);\n\t\t\tv2 = b43legacy_read16(dev, B43legacy_MMIO_TSF_2);\n\t\t\tv1 = b43legacy_read16(dev, B43legacy_MMIO_TSF_1);\n\t\t\tv0 = b43legacy_read16(dev, B43legacy_MMIO_TSF_0);\n\n\t\t\ttest3 = b43legacy_read16(dev, B43legacy_MMIO_TSF_3);\n\t\t\ttest2 = b43legacy_read16(dev, B43legacy_MMIO_TSF_2);\n\t\t\ttest1 = b43legacy_read16(dev, B43legacy_MMIO_TSF_1);\n\t\t} while (v3 != test3 || v2 != test2 || v1 != test1);\n\n\t\t*tsf = v3;\n\t\t*tsf <<= 48;\n\t\ttmp = v2;\n\t\ttmp <<= 32;\n\t\t*tsf |= tmp;\n\t\ttmp = v1;\n\t\ttmp <<= 16;\n\t\t*tsf |= tmp;\n\t\t*tsf |= v0;\n\t}\n}\n\nstatic void b43legacy_time_lock(struct b43legacy_wldev *dev)\n{\n\tu32 status;\n\n\tstatus = b43legacy_read32(dev, B43legacy_MMIO_MACCTL);\n\tstatus |= B43legacy_MACCTL_TBTTHOLD;\n\tb43legacy_write32(dev, B43legacy_MMIO_MACCTL, status);\n}\n\nstatic void b43legacy_time_unlock(struct b43legacy_wldev *dev)\n{\n\tu32 status;\n\n\tstatus = b43legacy_read32(dev, B43legacy_MMIO_MACCTL);\n\tstatus &= ~B43legacy_MACCTL_TBTTHOLD;\n\tb43legacy_write32(dev, B43legacy_MMIO_MACCTL, status);\n}\n\nstatic void b43legacy_tsf_write_locked(struct b43legacy_wldev *dev, u64 tsf)\n{\n\t \n\tif (dev->dev->id.revision >= 3) {\n\t\tu32 lo = (tsf & 0x00000000FFFFFFFFULL);\n\t\tu32 hi = (tsf & 0xFFFFFFFF00000000ULL) >> 32;\n\n\t\tb43legacy_write32(dev, B43legacy_MMIO_REV3PLUS_TSF_LOW, 0);\n\t\tb43legacy_write32(dev, B43legacy_MMIO_REV3PLUS_TSF_HIGH,\n\t\t\t\t    hi);\n\t\tb43legacy_write32(dev, B43legacy_MMIO_REV3PLUS_TSF_LOW,\n\t\t\t\t    lo);\n\t} else {\n\t\tu16 v0 = (tsf & 0x000000000000FFFFULL);\n\t\tu16 v1 = (tsf & 0x00000000FFFF0000ULL) >> 16;\n\t\tu16 v2 = (tsf & 0x0000FFFF00000000ULL) >> 32;\n\t\tu16 v3 = (tsf & 0xFFFF000000000000ULL) >> 48;\n\n\t\tb43legacy_write16(dev, B43legacy_MMIO_TSF_0, 0);\n\t\tb43legacy_write16(dev, B43legacy_MMIO_TSF_3, v3);\n\t\tb43legacy_write16(dev, B43legacy_MMIO_TSF_2, v2);\n\t\tb43legacy_write16(dev, B43legacy_MMIO_TSF_1, v1);\n\t\tb43legacy_write16(dev, B43legacy_MMIO_TSF_0, v0);\n\t}\n}\n\nvoid b43legacy_tsf_write(struct b43legacy_wldev *dev, u64 tsf)\n{\n\tb43legacy_time_lock(dev);\n\tb43legacy_tsf_write_locked(dev, tsf);\n\tb43legacy_time_unlock(dev);\n}\n\nstatic\nvoid b43legacy_macfilter_set(struct b43legacy_wldev *dev,\n\t\t\t     u16 offset, const u8 *mac)\n{\n\tstatic const u8 zero_addr[ETH_ALEN] = { 0 };\n\tu16 data;\n\n\tif (!mac)\n\t\tmac = zero_addr;\n\n\toffset |= 0x0020;\n\tb43legacy_write16(dev, B43legacy_MMIO_MACFILTER_CONTROL, offset);\n\n\tdata = mac[0];\n\tdata |= mac[1] << 8;\n\tb43legacy_write16(dev, B43legacy_MMIO_MACFILTER_DATA, data);\n\tdata = mac[2];\n\tdata |= mac[3] << 8;\n\tb43legacy_write16(dev, B43legacy_MMIO_MACFILTER_DATA, data);\n\tdata = mac[4];\n\tdata |= mac[5] << 8;\n\tb43legacy_write16(dev, B43legacy_MMIO_MACFILTER_DATA, data);\n}\n\nstatic void b43legacy_write_mac_bssid_templates(struct b43legacy_wldev *dev)\n{\n\tstatic const u8 zero_addr[ETH_ALEN] = { 0 };\n\tconst u8 *mac = dev->wl->mac_addr;\n\tconst u8 *bssid = dev->wl->bssid;\n\tu8 mac_bssid[ETH_ALEN * 2];\n\tint i;\n\tu32 tmp;\n\n\tif (!bssid)\n\t\tbssid = zero_addr;\n\tif (!mac)\n\t\tmac = zero_addr;\n\n\tb43legacy_macfilter_set(dev, B43legacy_MACFILTER_BSSID, bssid);\n\n\tmemcpy(mac_bssid, mac, ETH_ALEN);\n\tmemcpy(mac_bssid + ETH_ALEN, bssid, ETH_ALEN);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(mac_bssid); i += sizeof(u32)) {\n\t\ttmp =  (u32)(mac_bssid[i + 0]);\n\t\ttmp |= (u32)(mac_bssid[i + 1]) << 8;\n\t\ttmp |= (u32)(mac_bssid[i + 2]) << 16;\n\t\ttmp |= (u32)(mac_bssid[i + 3]) << 24;\n\t\tb43legacy_ram_write(dev, 0x20 + i, tmp);\n\t\tb43legacy_ram_write(dev, 0x78 + i, tmp);\n\t\tb43legacy_ram_write(dev, 0x478 + i, tmp);\n\t}\n}\n\nstatic void b43legacy_upload_card_macaddress(struct b43legacy_wldev *dev)\n{\n\tb43legacy_write_mac_bssid_templates(dev);\n\tb43legacy_macfilter_set(dev, B43legacy_MACFILTER_SELF,\n\t\t\t\tdev->wl->mac_addr);\n}\n\nstatic void b43legacy_set_slot_time(struct b43legacy_wldev *dev,\n\t\t\t\t    u16 slot_time)\n{\n\t \n\tif (dev->phy.type != B43legacy_PHYTYPE_G)\n\t\treturn;\n\tb43legacy_write16(dev, 0x684, 510 + slot_time);\n\tb43legacy_shm_write16(dev, B43legacy_SHM_SHARED, 0x0010,\n\t\t\t      slot_time);\n}\n\nstatic void b43legacy_short_slot_timing_enable(struct b43legacy_wldev *dev)\n{\n\tb43legacy_set_slot_time(dev, 9);\n}\n\nstatic void b43legacy_short_slot_timing_disable(struct b43legacy_wldev *dev)\n{\n\tb43legacy_set_slot_time(dev, 20);\n}\n\n \nstatic void b43legacy_synchronize_irq(struct b43legacy_wldev *dev)\n{\n\tsynchronize_irq(dev->dev->irq);\n\ttasklet_kill(&dev->isr_tasklet);\n}\n\n \nvoid b43legacy_dummy_transmission(struct b43legacy_wldev *dev)\n{\n\tstruct b43legacy_phy *phy = &dev->phy;\n\tunsigned int i;\n\tunsigned int max_loop;\n\tu16 value;\n\tu32 buffer[5] = {\n\t\t0x00000000,\n\t\t0x00D40000,\n\t\t0x00000000,\n\t\t0x01000000,\n\t\t0x00000000,\n\t};\n\n\tswitch (phy->type) {\n\tcase B43legacy_PHYTYPE_B:\n\tcase B43legacy_PHYTYPE_G:\n\t\tmax_loop = 0xFA;\n\t\tbuffer[0] = 0x000B846E;\n\t\tbreak;\n\tdefault:\n\t\tB43legacy_BUG_ON(1);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 5; i++)\n\t\tb43legacy_ram_write(dev, i * 4, buffer[i]);\n\n\t \n\tb43legacy_read32(dev, B43legacy_MMIO_MACCTL);\n\n\tb43legacy_write16(dev, 0x0568, 0x0000);\n\tb43legacy_write16(dev, 0x07C0, 0x0000);\n\tb43legacy_write16(dev, 0x050C, 0x0000);\n\tb43legacy_write16(dev, 0x0508, 0x0000);\n\tb43legacy_write16(dev, 0x050A, 0x0000);\n\tb43legacy_write16(dev, 0x054C, 0x0000);\n\tb43legacy_write16(dev, 0x056A, 0x0014);\n\tb43legacy_write16(dev, 0x0568, 0x0826);\n\tb43legacy_write16(dev, 0x0500, 0x0000);\n\tb43legacy_write16(dev, 0x0502, 0x0030);\n\n\tif (phy->radio_ver == 0x2050 && phy->radio_rev <= 0x5)\n\t\tb43legacy_radio_write16(dev, 0x0051, 0x0017);\n\tfor (i = 0x00; i < max_loop; i++) {\n\t\tvalue = b43legacy_read16(dev, 0x050E);\n\t\tif (value & 0x0080)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\tfor (i = 0x00; i < 0x0A; i++) {\n\t\tvalue = b43legacy_read16(dev, 0x050E);\n\t\tif (value & 0x0400)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\tfor (i = 0x00; i < 0x0A; i++) {\n\t\tvalue = b43legacy_read16(dev, 0x0690);\n\t\tif (!(value & 0x0100))\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\tif (phy->radio_ver == 0x2050 && phy->radio_rev <= 0x5)\n\t\tb43legacy_radio_write16(dev, 0x0051, 0x0037);\n}\n\n \nstatic void b43legacy_switch_analog(struct b43legacy_wldev *dev, int on)\n{\n\tb43legacy_write16(dev, B43legacy_MMIO_PHY0, on ? 0 : 0xF4);\n}\n\nvoid b43legacy_wireless_core_reset(struct b43legacy_wldev *dev, u32 flags)\n{\n\tu32 tmslow;\n\tu32 macctl;\n\n\tflags |= B43legacy_TMSLOW_PHYCLKEN;\n\tflags |= B43legacy_TMSLOW_PHYRESET;\n\tssb_device_enable(dev->dev, flags);\n\tmsleep(2);  \n\n\t \n\ttmslow = ssb_read32(dev->dev, SSB_TMSLOW);\n\ttmslow |= SSB_TMSLOW_FGC;\n\ttmslow &= ~B43legacy_TMSLOW_PHYRESET;\n\tssb_write32(dev->dev, SSB_TMSLOW, tmslow);\n\tssb_read32(dev->dev, SSB_TMSLOW);  \n\tmsleep(1);\n\ttmslow &= ~SSB_TMSLOW_FGC;\n\tssb_write32(dev->dev, SSB_TMSLOW, tmslow);\n\tssb_read32(dev->dev, SSB_TMSLOW);  \n\tmsleep(1);\n\n\t \n\tb43legacy_switch_analog(dev, 1);\n\n\tmacctl = b43legacy_read32(dev, B43legacy_MMIO_MACCTL);\n\tmacctl &= ~B43legacy_MACCTL_GMODE;\n\tif (flags & B43legacy_TMSLOW_GMODE) {\n\t\tmacctl |= B43legacy_MACCTL_GMODE;\n\t\tdev->phy.gmode = true;\n\t} else\n\t\tdev->phy.gmode = false;\n\tmacctl |= B43legacy_MACCTL_IHR_ENABLED;\n\tb43legacy_write32(dev, B43legacy_MMIO_MACCTL, macctl);\n}\n\nstatic void handle_irq_transmit_status(struct b43legacy_wldev *dev)\n{\n\tu32 v0;\n\tu32 v1;\n\tu16 tmp;\n\tstruct b43legacy_txstatus stat;\n\n\twhile (1) {\n\t\tv0 = b43legacy_read32(dev, B43legacy_MMIO_XMITSTAT_0);\n\t\tif (!(v0 & 0x00000001))\n\t\t\tbreak;\n\t\tv1 = b43legacy_read32(dev, B43legacy_MMIO_XMITSTAT_1);\n\n\t\tstat.cookie = (v0 >> 16);\n\t\tstat.seq = (v1 & 0x0000FFFF);\n\t\tstat.phy_stat = ((v1 & 0x00FF0000) >> 16);\n\t\ttmp = (v0 & 0x0000FFFF);\n\t\tstat.frame_count = ((tmp & 0xF000) >> 12);\n\t\tstat.rts_count = ((tmp & 0x0F00) >> 8);\n\t\tstat.supp_reason = ((tmp & 0x001C) >> 2);\n\t\tstat.pm_indicated = !!(tmp & 0x0080);\n\t\tstat.intermediate = !!(tmp & 0x0040);\n\t\tstat.for_ampdu = !!(tmp & 0x0020);\n\t\tstat.acked = !!(tmp & 0x0002);\n\n\t\tb43legacy_handle_txstatus(dev, &stat);\n\t}\n}\n\nstatic void drain_txstatus_queue(struct b43legacy_wldev *dev)\n{\n\tu32 dummy;\n\n\tif (dev->dev->id.revision < 5)\n\t\treturn;\n\t \n\twhile (1) {\n\t\tdummy = b43legacy_read32(dev, B43legacy_MMIO_XMITSTAT_0);\n\t\tif (!(dummy & 0x00000001))\n\t\t\tbreak;\n\t\tdummy = b43legacy_read32(dev, B43legacy_MMIO_XMITSTAT_1);\n\t}\n}\n\nstatic u32 b43legacy_jssi_read(struct b43legacy_wldev *dev)\n{\n\tu32 val = 0;\n\n\tval = b43legacy_shm_read16(dev, B43legacy_SHM_SHARED, 0x40A);\n\tval <<= 16;\n\tval |= b43legacy_shm_read16(dev, B43legacy_SHM_SHARED, 0x408);\n\n\treturn val;\n}\n\nstatic void b43legacy_jssi_write(struct b43legacy_wldev *dev, u32 jssi)\n{\n\tb43legacy_shm_write16(dev, B43legacy_SHM_SHARED, 0x408,\n\t\t\t      (jssi & 0x0000FFFF));\n\tb43legacy_shm_write16(dev, B43legacy_SHM_SHARED, 0x40A,\n\t\t\t      (jssi & 0xFFFF0000) >> 16);\n}\n\nstatic void b43legacy_generate_noise_sample(struct b43legacy_wldev *dev)\n{\n\tb43legacy_jssi_write(dev, 0x7F7F7F7F);\n\tb43legacy_write32(dev, B43legacy_MMIO_MACCMD,\n\t\t\t  b43legacy_read32(dev, B43legacy_MMIO_MACCMD)\n\t\t\t  | B43legacy_MACCMD_BGNOISE);\n\tB43legacy_WARN_ON(dev->noisecalc.channel_at_start !=\n\t\t\t    dev->phy.channel);\n}\n\nstatic void b43legacy_calculate_link_quality(struct b43legacy_wldev *dev)\n{\n\t \n\n\tif (dev->noisecalc.calculation_running)\n\t\treturn;\n\tdev->noisecalc.channel_at_start = dev->phy.channel;\n\tdev->noisecalc.calculation_running = true;\n\tdev->noisecalc.nr_samples = 0;\n\n\tb43legacy_generate_noise_sample(dev);\n}\n\nstatic void handle_irq_noise(struct b43legacy_wldev *dev)\n{\n\tstruct b43legacy_phy *phy = &dev->phy;\n\tu16 tmp;\n\tu8 noise[4];\n\tu8 i;\n\tu8 j;\n\ts32 average;\n\n\t \n\n\tB43legacy_WARN_ON(!dev->noisecalc.calculation_running);\n\tif (dev->noisecalc.channel_at_start != phy->channel)\n\t\tgoto drop_calculation;\n\t*((__le32 *)noise) = cpu_to_le32(b43legacy_jssi_read(dev));\n\tif (noise[0] == 0x7F || noise[1] == 0x7F ||\n\t    noise[2] == 0x7F || noise[3] == 0x7F)\n\t\tgoto generate_new;\n\n\t \n\tB43legacy_WARN_ON(dev->noisecalc.nr_samples >= 8);\n\ti = dev->noisecalc.nr_samples;\n\tnoise[0] = clamp_val(noise[0], 0, ARRAY_SIZE(phy->nrssi_lt) - 1);\n\tnoise[1] = clamp_val(noise[1], 0, ARRAY_SIZE(phy->nrssi_lt) - 1);\n\tnoise[2] = clamp_val(noise[2], 0, ARRAY_SIZE(phy->nrssi_lt) - 1);\n\tnoise[3] = clamp_val(noise[3], 0, ARRAY_SIZE(phy->nrssi_lt) - 1);\n\tdev->noisecalc.samples[i][0] = phy->nrssi_lt[noise[0]];\n\tdev->noisecalc.samples[i][1] = phy->nrssi_lt[noise[1]];\n\tdev->noisecalc.samples[i][2] = phy->nrssi_lt[noise[2]];\n\tdev->noisecalc.samples[i][3] = phy->nrssi_lt[noise[3]];\n\tdev->noisecalc.nr_samples++;\n\tif (dev->noisecalc.nr_samples == 8) {\n\t\t \n\t\taverage = 0;\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\taverage += dev->noisecalc.samples[i][j];\n\t\t}\n\t\taverage /= (8 * 4);\n\t\taverage *= 125;\n\t\taverage += 64;\n\t\taverage /= 128;\n\t\ttmp = b43legacy_shm_read16(dev, B43legacy_SHM_SHARED,\n\t\t\t\t\t     0x40C);\n\t\ttmp = (tmp / 128) & 0x1F;\n\t\tif (tmp >= 8)\n\t\t\taverage += 2;\n\t\telse\n\t\t\taverage -= 25;\n\t\tif (tmp == 8)\n\t\t\taverage -= 72;\n\t\telse\n\t\t\taverage -= 48;\n\n\t\tdev->stats.link_noise = average;\ndrop_calculation:\n\t\tdev->noisecalc.calculation_running = false;\n\t\treturn;\n\t}\ngenerate_new:\n\tb43legacy_generate_noise_sample(dev);\n}\n\nstatic void handle_irq_tbtt_indication(struct b43legacy_wldev *dev)\n{\n\tif (b43legacy_is_mode(dev->wl, NL80211_IFTYPE_AP)) {\n\t\t \n\t} else {\n\t\tif (1 )\n\t\t\tb43legacy_power_saving_ctl_bits(dev, -1, -1);\n\t}\n\tif (b43legacy_is_mode(dev->wl, NL80211_IFTYPE_ADHOC))\n\t\tdev->dfq_valid = true;\n}\n\nstatic void handle_irq_atim_end(struct b43legacy_wldev *dev)\n{\n\tif (dev->dfq_valid) {\n\t\tb43legacy_write32(dev, B43legacy_MMIO_MACCMD,\n\t\t\t\t  b43legacy_read32(dev, B43legacy_MMIO_MACCMD)\n\t\t\t\t  | B43legacy_MACCMD_DFQ_VALID);\n\t\tdev->dfq_valid = false;\n\t}\n}\n\nstatic void handle_irq_pmq(struct b43legacy_wldev *dev)\n{\n\tu32 tmp;\n\n\t \n\n\twhile (1) {\n\t\ttmp = b43legacy_read32(dev, B43legacy_MMIO_PS_STATUS);\n\t\tif (!(tmp & 0x00000008))\n\t\t\tbreak;\n\t}\n\t \n\tb43legacy_write16(dev, B43legacy_MMIO_PS_STATUS, 0x0002);\n}\n\nstatic void b43legacy_write_template_common(struct b43legacy_wldev *dev,\n\t\t\t\t\t    const u8 *data, u16 size,\n\t\t\t\t\t    u16 ram_offset,\n\t\t\t\t\t    u16 shm_size_offset, u8 rate)\n{\n\tu32 i;\n\tu32 tmp;\n\tstruct b43legacy_plcp_hdr4 plcp;\n\n\tplcp.data = 0;\n\tb43legacy_generate_plcp_hdr(&plcp, size + FCS_LEN, rate);\n\tb43legacy_ram_write(dev, ram_offset, le32_to_cpu(plcp.data));\n\tram_offset += sizeof(u32);\n\t \n\ttmp = (u32)(data[0]) << 16;\n\ttmp |= (u32)(data[1]) << 24;\n\tb43legacy_ram_write(dev, ram_offset, tmp);\n\tram_offset += sizeof(u32);\n\tfor (i = 2; i < size; i += sizeof(u32)) {\n\t\ttmp = (u32)(data[i + 0]);\n\t\tif (i + 1 < size)\n\t\t\ttmp |= (u32)(data[i + 1]) << 8;\n\t\tif (i + 2 < size)\n\t\t\ttmp |= (u32)(data[i + 2]) << 16;\n\t\tif (i + 3 < size)\n\t\t\ttmp |= (u32)(data[i + 3]) << 24;\n\t\tb43legacy_ram_write(dev, ram_offset + i - 2, tmp);\n\t}\n\tb43legacy_shm_write16(dev, B43legacy_SHM_SHARED, shm_size_offset,\n\t\t\t      size + sizeof(struct b43legacy_plcp_hdr6));\n}\n\n \nstatic u16 b43legacy_antenna_to_phyctl(int antenna)\n{\n\tswitch (antenna) {\n\tcase B43legacy_ANTENNA0:\n\t\treturn B43legacy_TX4_PHY_ANT0;\n\tcase B43legacy_ANTENNA1:\n\t\treturn B43legacy_TX4_PHY_ANT1;\n\t}\n\treturn B43legacy_TX4_PHY_ANTLAST;\n}\n\nstatic void b43legacy_write_beacon_template(struct b43legacy_wldev *dev,\n\t\t\t\t\t    u16 ram_offset,\n\t\t\t\t\t    u16 shm_size_offset)\n{\n\n\tunsigned int i, len, variable_len;\n\tconst struct ieee80211_mgmt *bcn;\n\tconst u8 *ie;\n\tbool tim_found = false;\n\tunsigned int rate;\n\tu16 ctl;\n\tint antenna;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(dev->wl->current_beacon);\n\n\tbcn = (const struct ieee80211_mgmt *)(dev->wl->current_beacon->data);\n\tlen = min_t(size_t, dev->wl->current_beacon->len,\n\t\t  0x200 - sizeof(struct b43legacy_plcp_hdr6));\n\trate = ieee80211_get_tx_rate(dev->wl->hw, info)->hw_value;\n\n\tb43legacy_write_template_common(dev, (const u8 *)bcn, len, ram_offset,\n\t\t\t\t\tshm_size_offset, rate);\n\n\t \n\tantenna = B43legacy_ANTENNA_DEFAULT;\n\tantenna = b43legacy_antenna_to_phyctl(antenna);\n\tctl = b43legacy_shm_read16(dev, B43legacy_SHM_SHARED,\n\t\t\t\t   B43legacy_SHM_SH_BEACPHYCTL);\n\t \n\tctl &= ~B43legacy_TX4_PHY_SHORTPRMBL;\n\tctl &= ~B43legacy_TX4_PHY_ANT;\n\tctl &= ~B43legacy_TX4_PHY_ENC;\n\tctl |= antenna;\n\tctl |= B43legacy_TX4_PHY_ENC_CCK;\n\tb43legacy_shm_write16(dev, B43legacy_SHM_SHARED,\n\t\t\t      B43legacy_SHM_SH_BEACPHYCTL, ctl);\n\n\t \n\tie = bcn->u.beacon.variable;\n\tvariable_len = len - offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\tfor (i = 0; i < variable_len - 2; ) {\n\t\tuint8_t ie_id, ie_len;\n\n\t\tie_id = ie[i];\n\t\tie_len = ie[i + 1];\n\t\tif (ie_id == 5) {\n\t\t\tu16 tim_position;\n\t\t\tu16 dtim_period;\n\t\t\t \n\n\t\t\t \n\t\t\tif (variable_len < ie_len + 2 + i)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (ie_len < 4)\n\t\t\t\tbreak;\n\t\t\ttim_found = true;\n\n\t\t\ttim_position = sizeof(struct b43legacy_plcp_hdr6);\n\t\t\ttim_position += offsetof(struct ieee80211_mgmt,\n\t\t\t\t\t\t u.beacon.variable);\n\t\t\ttim_position += i;\n\n\t\t\tdtim_period = ie[i + 3];\n\n\t\t\tb43legacy_shm_write16(dev, B43legacy_SHM_SHARED,\n\t\t\t\t\tB43legacy_SHM_SH_TIMPOS, tim_position);\n\t\t\tb43legacy_shm_write16(dev, B43legacy_SHM_SHARED,\n\t\t\t\t\tB43legacy_SHM_SH_DTIMP, dtim_period);\n\t\t\tbreak;\n\t\t}\n\t\ti += ie_len + 2;\n\t}\n\tif (!tim_found) {\n\t\tb43legacywarn(dev->wl, \"Did not find a valid TIM IE in the \"\n\t\t\t      \"beacon template packet. AP or IBSS operation \"\n\t\t\t      \"may be broken.\\n\");\n\t} else\n\t\tb43legacydbg(dev->wl, \"Updated beacon template\\n\");\n}\n\nstatic void b43legacy_write_probe_resp_plcp(struct b43legacy_wldev *dev,\n\t\t\t\t\t    u16 shm_offset, u16 size,\n\t\t\t\t\t    struct ieee80211_rate *rate)\n{\n\tstruct b43legacy_plcp_hdr4 plcp;\n\tu32 tmp;\n\t__le16 dur;\n\n\tplcp.data = 0;\n\tb43legacy_generate_plcp_hdr(&plcp, size + FCS_LEN, rate->hw_value);\n\tdur = ieee80211_generic_frame_duration(dev->wl->hw,\n\t\t\t\t\t       dev->wl->vif,\n\t\t\t\t\t       NL80211_BAND_2GHZ,\n\t\t\t\t\t       size,\n\t\t\t\t\t       rate);\n\t \n\ttmp = le32_to_cpu(plcp.data);\n\tb43legacy_shm_write16(dev, B43legacy_SHM_SHARED, shm_offset,\n\t\t\t      tmp & 0xFFFF);\n\tb43legacy_shm_write16(dev, B43legacy_SHM_SHARED, shm_offset + 2,\n\t\t\t      tmp >> 16);\n\tb43legacy_shm_write16(dev, B43legacy_SHM_SHARED, shm_offset + 6,\n\t\t\t      le16_to_cpu(dur));\n}\n\n \nstatic const u8 *b43legacy_generate_probe_resp(struct b43legacy_wldev *dev,\n\t\t\t\t\t       u16 *dest_size,\n\t\t\t\t\t       struct ieee80211_rate *rate)\n{\n\tconst u8 *src_data;\n\tu8 *dest_data;\n\tu16 src_size, elem_size, src_pos, dest_pos;\n\t__le16 dur;\n\tstruct ieee80211_hdr *hdr;\n\tsize_t ie_start;\n\n\tsrc_size = dev->wl->current_beacon->len;\n\tsrc_data = (const u8 *)dev->wl->current_beacon->data;\n\n\t \n\tie_start = offsetof(struct ieee80211_mgmt, u.probe_resp.variable);\n\tB43legacy_WARN_ON(ie_start != offsetof(struct ieee80211_mgmt,\n\t\t\t\t\t       u.beacon.variable));\n\n\tif (B43legacy_WARN_ON(src_size < ie_start))\n\t\treturn NULL;\n\n\tdest_data = kmalloc(src_size, GFP_ATOMIC);\n\tif (unlikely(!dest_data))\n\t\treturn NULL;\n\n\t \n\tmemcpy(dest_data, src_data, ie_start);\n\tsrc_pos = ie_start;\n\tdest_pos = ie_start;\n\tfor ( ; src_pos < src_size - 2; src_pos += elem_size) {\n\t\telem_size = src_data[src_pos + 1] + 2;\n\t\tif (src_data[src_pos] == 5) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\tmemcpy(dest_data + dest_pos, src_data + src_pos, elem_size);\n\t\tdest_pos += elem_size;\n\t}\n\t*dest_size = dest_pos;\n\thdr = (struct ieee80211_hdr *)dest_data;\n\n\t \n\thdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t IEEE80211_STYPE_PROBE_RESP);\n\tdur = ieee80211_generic_frame_duration(dev->wl->hw,\n\t\t\t\t\t       dev->wl->vif,\n\t\t\t\t\t       NL80211_BAND_2GHZ,\n\t\t\t\t\t       *dest_size,\n\t\t\t\t\t       rate);\n\thdr->duration_id = dur;\n\n\treturn dest_data;\n}\n\nstatic void b43legacy_write_probe_resp_template(struct b43legacy_wldev *dev,\n\t\t\t\t\t\tu16 ram_offset,\n\t\t\t\t\t\tu16 shm_size_offset,\n\t\t\t\t\t\tstruct ieee80211_rate *rate)\n{\n\tconst u8 *probe_resp_data;\n\tu16 size;\n\n\tsize = dev->wl->current_beacon->len;\n\tprobe_resp_data = b43legacy_generate_probe_resp(dev, &size, rate);\n\tif (unlikely(!probe_resp_data))\n\t\treturn;\n\n\t \n\tb43legacy_write_probe_resp_plcp(dev, 0x31A, size,\n\t\t\t\t\t&b43legacy_b_ratetable[0]);\n\tb43legacy_write_probe_resp_plcp(dev, 0x32C, size,\n\t\t\t\t\t&b43legacy_b_ratetable[1]);\n\tb43legacy_write_probe_resp_plcp(dev, 0x33E, size,\n\t\t\t\t\t&b43legacy_b_ratetable[2]);\n\tb43legacy_write_probe_resp_plcp(dev, 0x350, size,\n\t\t\t\t\t&b43legacy_b_ratetable[3]);\n\n\tsize = min_t(size_t, size,\n\t\t   0x200 - sizeof(struct b43legacy_plcp_hdr6));\n\tb43legacy_write_template_common(dev, probe_resp_data,\n\t\t\t\t\tsize, ram_offset,\n\t\t\t\t\tshm_size_offset, rate->hw_value);\n\tkfree(probe_resp_data);\n}\n\nstatic void b43legacy_upload_beacon0(struct b43legacy_wldev *dev)\n{\n\tstruct b43legacy_wl *wl = dev->wl;\n\n\tif (wl->beacon0_uploaded)\n\t\treturn;\n\tb43legacy_write_beacon_template(dev, 0x68, 0x18);\n\t \n\tb43legacy_write_probe_resp_template(dev, 0x268, 0x4A,\n\t\t\t\t      &__b43legacy_ratetable[3]);\n\twl->beacon0_uploaded = true;\n}\n\nstatic void b43legacy_upload_beacon1(struct b43legacy_wldev *dev)\n{\n\tstruct b43legacy_wl *wl = dev->wl;\n\n\tif (wl->beacon1_uploaded)\n\t\treturn;\n\tb43legacy_write_beacon_template(dev, 0x468, 0x1A);\n\twl->beacon1_uploaded = true;\n}\n\nstatic void handle_irq_beacon(struct b43legacy_wldev *dev)\n{\n\tstruct b43legacy_wl *wl = dev->wl;\n\tu32 cmd, beacon0_valid, beacon1_valid;\n\n\tif (!b43legacy_is_mode(wl, NL80211_IFTYPE_AP))\n\t\treturn;\n\n\t \n\n\t \n\tdev->irq_mask &= ~B43legacy_IRQ_BEACON;\n\n\tcmd = b43legacy_read32(dev, B43legacy_MMIO_MACCMD);\n\tbeacon0_valid = (cmd & B43legacy_MACCMD_BEACON0_VALID);\n\tbeacon1_valid = (cmd & B43legacy_MACCMD_BEACON1_VALID);\n\n\t \n\tif (beacon0_valid && beacon1_valid) {\n\t\tb43legacy_write32(dev, B43legacy_MMIO_GEN_IRQ_REASON, B43legacy_IRQ_BEACON);\n\t\tdev->irq_mask |= B43legacy_IRQ_BEACON;\n\t\treturn;\n\t}\n\n\tif (unlikely(wl->beacon_templates_virgin)) {\n\t\t \n\t\twl->beacon_templates_virgin = false;\n\t\tb43legacy_upload_beacon0(dev);\n\t\tb43legacy_upload_beacon1(dev);\n\t\tcmd = b43legacy_read32(dev, B43legacy_MMIO_MACCMD);\n\t\tcmd |= B43legacy_MACCMD_BEACON0_VALID;\n\t\tb43legacy_write32(dev, B43legacy_MMIO_MACCMD, cmd);\n\t} else {\n\t\tif (!beacon0_valid) {\n\t\t\tb43legacy_upload_beacon0(dev);\n\t\t\tcmd = b43legacy_read32(dev, B43legacy_MMIO_MACCMD);\n\t\t\tcmd |= B43legacy_MACCMD_BEACON0_VALID;\n\t\t\tb43legacy_write32(dev, B43legacy_MMIO_MACCMD, cmd);\n\t\t} else if (!beacon1_valid) {\n\t\t\tb43legacy_upload_beacon1(dev);\n\t\t\tcmd = b43legacy_read32(dev, B43legacy_MMIO_MACCMD);\n\t\t\tcmd |= B43legacy_MACCMD_BEACON1_VALID;\n\t\t\tb43legacy_write32(dev, B43legacy_MMIO_MACCMD, cmd);\n\t\t}\n\t}\n}\n\nstatic void b43legacy_beacon_update_trigger_work(struct work_struct *work)\n{\n\tstruct b43legacy_wl *wl = container_of(work, struct b43legacy_wl,\n\t\t\t\t\t beacon_update_trigger);\n\tstruct b43legacy_wldev *dev;\n\n\tmutex_lock(&wl->mutex);\n\tdev = wl->current_dev;\n\tif (likely(dev && (b43legacy_status(dev) >= B43legacy_STAT_INITIALIZED))) {\n\t\tspin_lock_irq(&wl->irq_lock);\n\t\t \n\t\thandle_irq_beacon(dev);\n\t\t \n\t\tb43legacy_write32(dev, B43legacy_MMIO_GEN_IRQ_MASK,\n\t\t\t\t  dev->irq_mask);\n\t\tspin_unlock_irq(&wl->irq_lock);\n\t}\n\tmutex_unlock(&wl->mutex);\n}\n\n \nstatic void b43legacy_update_templates(struct b43legacy_wl *wl)\n{\n\tstruct sk_buff *beacon;\n\t \n\n\t \n\tbeacon = ieee80211_beacon_get(wl->hw, wl->vif, 0);\n\tif (unlikely(!beacon))\n\t\treturn;\n\n\tif (wl->current_beacon)\n\t\tdev_kfree_skb_any(wl->current_beacon);\n\twl->current_beacon = beacon;\n\twl->beacon0_uploaded = false;\n\twl->beacon1_uploaded = false;\n\tieee80211_queue_work(wl->hw, &wl->beacon_update_trigger);\n}\n\nstatic void b43legacy_set_beacon_int(struct b43legacy_wldev *dev,\n\t\t\t\t     u16 beacon_int)\n{\n\tb43legacy_time_lock(dev);\n\tif (dev->dev->id.revision >= 3) {\n\t\tb43legacy_write32(dev, B43legacy_MMIO_TSF_CFP_REP,\n\t\t\t\t (beacon_int << 16));\n\t\tb43legacy_write32(dev, B43legacy_MMIO_TSF_CFP_START,\n\t\t\t\t (beacon_int << 10));\n\t} else {\n\t\tb43legacy_write16(dev, 0x606, (beacon_int >> 6));\n\t\tb43legacy_write16(dev, 0x610, beacon_int);\n\t}\n\tb43legacy_time_unlock(dev);\n\tb43legacydbg(dev->wl, \"Set beacon interval to %u\\n\", beacon_int);\n}\n\nstatic void handle_irq_ucode_debug(struct b43legacy_wldev *dev)\n{\n}\n\n \nstatic void b43legacy_interrupt_tasklet(struct tasklet_struct *t)\n{\n\tstruct b43legacy_wldev *dev = from_tasklet(dev, t, isr_tasklet);\n\tu32 reason;\n\tu32 dma_reason[ARRAY_SIZE(dev->dma_reason)];\n\tu32 merged_dma_reason = 0;\n\tint i;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->wl->irq_lock, flags);\n\n\tB43legacy_WARN_ON(b43legacy_status(dev) <\n\t\t\t  B43legacy_STAT_INITIALIZED);\n\n\treason = dev->irq_reason;\n\tfor (i = 0; i < ARRAY_SIZE(dma_reason); i++) {\n\t\tdma_reason[i] = dev->dma_reason[i];\n\t\tmerged_dma_reason |= dma_reason[i];\n\t}\n\n\tif (unlikely(reason & B43legacy_IRQ_MAC_TXERR))\n\t\tb43legacyerr(dev->wl, \"MAC transmission error\\n\");\n\n\tif (unlikely(reason & B43legacy_IRQ_PHY_TXERR)) {\n\t\tb43legacyerr(dev->wl, \"PHY transmission error\\n\");\n\t\trmb();\n\t\tif (unlikely(atomic_dec_and_test(&dev->phy.txerr_cnt))) {\n\t\t\tb43legacyerr(dev->wl, \"Too many PHY TX errors, \"\n\t\t\t\t\t      \"restarting the controller\\n\");\n\t\t\tb43legacy_controller_restart(dev, \"PHY TX errors\");\n\t\t}\n\t}\n\n\tif (unlikely(merged_dma_reason & (B43legacy_DMAIRQ_FATALMASK |\n\t\t\t\t\t  B43legacy_DMAIRQ_NONFATALMASK))) {\n\t\tif (merged_dma_reason & B43legacy_DMAIRQ_FATALMASK) {\n\t\t\tb43legacyerr(dev->wl, \"Fatal DMA error: \"\n\t\t\t       \"0x%08X, 0x%08X, 0x%08X, \"\n\t\t\t       \"0x%08X, 0x%08X, 0x%08X\\n\",\n\t\t\t       dma_reason[0], dma_reason[1],\n\t\t\t       dma_reason[2], dma_reason[3],\n\t\t\t       dma_reason[4], dma_reason[5]);\n\t\t\tb43legacy_controller_restart(dev, \"DMA error\");\n\t\t\tspin_unlock_irqrestore(&dev->wl->irq_lock, flags);\n\t\t\treturn;\n\t\t}\n\t\tif (merged_dma_reason & B43legacy_DMAIRQ_NONFATALMASK)\n\t\t\tb43legacyerr(dev->wl, \"DMA error: \"\n\t\t\t       \"0x%08X, 0x%08X, 0x%08X, \"\n\t\t\t       \"0x%08X, 0x%08X, 0x%08X\\n\",\n\t\t\t       dma_reason[0], dma_reason[1],\n\t\t\t       dma_reason[2], dma_reason[3],\n\t\t\t       dma_reason[4], dma_reason[5]);\n\t}\n\n\tif (unlikely(reason & B43legacy_IRQ_UCODE_DEBUG))\n\t\thandle_irq_ucode_debug(dev);\n\tif (reason & B43legacy_IRQ_TBTT_INDI)\n\t\thandle_irq_tbtt_indication(dev);\n\tif (reason & B43legacy_IRQ_ATIM_END)\n\t\thandle_irq_atim_end(dev);\n\tif (reason & B43legacy_IRQ_BEACON)\n\t\thandle_irq_beacon(dev);\n\tif (reason & B43legacy_IRQ_PMQ)\n\t\thandle_irq_pmq(dev);\n\tif (reason & B43legacy_IRQ_TXFIFO_FLUSH_OK) {\n\t\t; \n\t}\n\tif (reason & B43legacy_IRQ_NOISESAMPLE_OK)\n\t\thandle_irq_noise(dev);\n\n\t \n\tif (dma_reason[0] & B43legacy_DMAIRQ_RX_DONE) {\n\t\tif (b43legacy_using_pio(dev))\n\t\t\tb43legacy_pio_rx(dev->pio.queue0);\n\t\telse\n\t\t\tb43legacy_dma_rx(dev->dma.rx_ring0);\n\t}\n\tB43legacy_WARN_ON(dma_reason[1] & B43legacy_DMAIRQ_RX_DONE);\n\tB43legacy_WARN_ON(dma_reason[2] & B43legacy_DMAIRQ_RX_DONE);\n\tif (dma_reason[3] & B43legacy_DMAIRQ_RX_DONE) {\n\t\tif (b43legacy_using_pio(dev))\n\t\t\tb43legacy_pio_rx(dev->pio.queue3);\n\t\telse\n\t\t\tb43legacy_dma_rx(dev->dma.rx_ring3);\n\t}\n\tB43legacy_WARN_ON(dma_reason[4] & B43legacy_DMAIRQ_RX_DONE);\n\tB43legacy_WARN_ON(dma_reason[5] & B43legacy_DMAIRQ_RX_DONE);\n\n\tif (reason & B43legacy_IRQ_TX_OK)\n\t\thandle_irq_transmit_status(dev);\n\n\tb43legacy_write32(dev, B43legacy_MMIO_GEN_IRQ_MASK, dev->irq_mask);\n\tspin_unlock_irqrestore(&dev->wl->irq_lock, flags);\n}\n\nstatic void pio_irq_workaround(struct b43legacy_wldev *dev,\n\t\t\t       u16 base, int queueidx)\n{\n\tu16 rxctl;\n\n\trxctl = b43legacy_read16(dev, base + B43legacy_PIO_RXCTL);\n\tif (rxctl & B43legacy_PIO_RXCTL_DATAAVAILABLE)\n\t\tdev->dma_reason[queueidx] |= B43legacy_DMAIRQ_RX_DONE;\n\telse\n\t\tdev->dma_reason[queueidx] &= ~B43legacy_DMAIRQ_RX_DONE;\n}\n\nstatic void b43legacy_interrupt_ack(struct b43legacy_wldev *dev, u32 reason)\n{\n\tif (b43legacy_using_pio(dev) &&\n\t    (dev->dev->id.revision < 3) &&\n\t    (!(reason & B43legacy_IRQ_PIO_WORKAROUND))) {\n\t\t \n\t\tpio_irq_workaround(dev, B43legacy_MMIO_PIO1_BASE, 0);\n\t\tpio_irq_workaround(dev, B43legacy_MMIO_PIO2_BASE, 1);\n\t\tpio_irq_workaround(dev, B43legacy_MMIO_PIO3_BASE, 2);\n\t\tpio_irq_workaround(dev, B43legacy_MMIO_PIO4_BASE, 3);\n\t}\n\n\tb43legacy_write32(dev, B43legacy_MMIO_GEN_IRQ_REASON, reason);\n\n\tb43legacy_write32(dev, B43legacy_MMIO_DMA0_REASON,\n\t\t\t  dev->dma_reason[0]);\n\tb43legacy_write32(dev, B43legacy_MMIO_DMA1_REASON,\n\t\t\t  dev->dma_reason[1]);\n\tb43legacy_write32(dev, B43legacy_MMIO_DMA2_REASON,\n\t\t\t  dev->dma_reason[2]);\n\tb43legacy_write32(dev, B43legacy_MMIO_DMA3_REASON,\n\t\t\t  dev->dma_reason[3]);\n\tb43legacy_write32(dev, B43legacy_MMIO_DMA4_REASON,\n\t\t\t  dev->dma_reason[4]);\n\tb43legacy_write32(dev, B43legacy_MMIO_DMA5_REASON,\n\t\t\t  dev->dma_reason[5]);\n}\n\n \nstatic irqreturn_t b43legacy_interrupt_handler(int irq, void *dev_id)\n{\n\tirqreturn_t ret = IRQ_NONE;\n\tstruct b43legacy_wldev *dev = dev_id;\n\tu32 reason;\n\n\tB43legacy_WARN_ON(!dev);\n\n\tspin_lock(&dev->wl->irq_lock);\n\n\tif (unlikely(b43legacy_status(dev) < B43legacy_STAT_STARTED))\n\t\t \n\t\tgoto out;\n\treason = b43legacy_read32(dev, B43legacy_MMIO_GEN_IRQ_REASON);\n\tif (reason == 0xffffffff)  \n\t\tgoto out;\n\tret = IRQ_HANDLED;\n\treason &= dev->irq_mask;\n\tif (!reason)\n\t\tgoto out;\n\n\tdev->dma_reason[0] = b43legacy_read32(dev,\n\t\t\t\t\t      B43legacy_MMIO_DMA0_REASON)\n\t\t\t\t\t      & 0x0001DC00;\n\tdev->dma_reason[1] = b43legacy_read32(dev,\n\t\t\t\t\t      B43legacy_MMIO_DMA1_REASON)\n\t\t\t\t\t      & 0x0000DC00;\n\tdev->dma_reason[2] = b43legacy_read32(dev,\n\t\t\t\t\t      B43legacy_MMIO_DMA2_REASON)\n\t\t\t\t\t      & 0x0000DC00;\n\tdev->dma_reason[3] = b43legacy_read32(dev,\n\t\t\t\t\t      B43legacy_MMIO_DMA3_REASON)\n\t\t\t\t\t      & 0x0001DC00;\n\tdev->dma_reason[4] = b43legacy_read32(dev,\n\t\t\t\t\t      B43legacy_MMIO_DMA4_REASON)\n\t\t\t\t\t      & 0x0000DC00;\n\tdev->dma_reason[5] = b43legacy_read32(dev,\n\t\t\t\t\t      B43legacy_MMIO_DMA5_REASON)\n\t\t\t\t\t      & 0x0000DC00;\n\n\tb43legacy_interrupt_ack(dev, reason);\n\t \n\tb43legacy_write32(dev, B43legacy_MMIO_GEN_IRQ_MASK, 0);\n\t \n\tdev->irq_reason = reason;\n\ttasklet_schedule(&dev->isr_tasklet);\nout:\n\tspin_unlock(&dev->wl->irq_lock);\n\n\treturn ret;\n}\n\nstatic void b43legacy_release_firmware(struct b43legacy_wldev *dev)\n{\n\trelease_firmware(dev->fw.ucode);\n\tdev->fw.ucode = NULL;\n\trelease_firmware(dev->fw.pcm);\n\tdev->fw.pcm = NULL;\n\trelease_firmware(dev->fw.initvals);\n\tdev->fw.initvals = NULL;\n\trelease_firmware(dev->fw.initvals_band);\n\tdev->fw.initvals_band = NULL;\n}\n\nstatic void b43legacy_print_fw_helptext(struct b43legacy_wl *wl)\n{\n\tb43legacyerr(wl, \"You must go to https://wireless.wiki.kernel.org/en/\"\n\t\t     \"users/Drivers/b43#devicefirmware \"\n\t\t     \"and download the correct firmware (version 3).\\n\");\n}\n\nstatic void b43legacy_fw_cb(const struct firmware *firmware, void *context)\n{\n\tstruct b43legacy_wldev *dev = context;\n\n\tdev->fwp = firmware;\n\tcomplete(&dev->fw_load_complete);\n}\n\nstatic int do_request_fw(struct b43legacy_wldev *dev,\n\t\t\t const char *name,\n\t\t\t const struct firmware **fw, bool async)\n{\n\tchar path[sizeof(modparam_fwpostfix) + 32];\n\tstruct b43legacy_fw_header *hdr;\n\tu32 size;\n\tint err;\n\n\tif (!name)\n\t\treturn 0;\n\n\tsnprintf(path, ARRAY_SIZE(path),\n\t\t \"b43legacy%s/%s.fw\",\n\t\t modparam_fwpostfix, name);\n\tb43legacyinfo(dev->wl, \"Loading firmware %s\\n\", path);\n\tif (async) {\n\t\tinit_completion(&dev->fw_load_complete);\n\t\terr = request_firmware_nowait(THIS_MODULE, 1, path,\n\t\t\t\t\t      dev->dev->dev, GFP_KERNEL,\n\t\t\t\t\t      dev, b43legacy_fw_cb);\n\t\tif (err) {\n\t\t\tb43legacyerr(dev->wl, \"Unable to load firmware\\n\");\n\t\t\treturn err;\n\t\t}\n\t\t \n\t\twait_for_completion(&dev->fw_load_complete);\n\t\tif (!dev->fwp)\n\t\t\terr = -EINVAL;\n\t\t*fw = dev->fwp;\n\t} else {\n\t\terr = request_firmware(fw, path, dev->dev->dev);\n\t}\n\tif (err) {\n\t\tb43legacyerr(dev->wl, \"Firmware file \\\"%s\\\" not found \"\n\t\t       \"or load failed.\\n\", path);\n\t\treturn err;\n\t}\n\tif ((*fw)->size < sizeof(struct b43legacy_fw_header))\n\t\tgoto err_format;\n\thdr = (struct b43legacy_fw_header *)((*fw)->data);\n\tswitch (hdr->type) {\n\tcase B43legacy_FW_TYPE_UCODE:\n\tcase B43legacy_FW_TYPE_PCM:\n\t\tsize = be32_to_cpu(hdr->size);\n\t\tif (size != (*fw)->size - sizeof(struct b43legacy_fw_header))\n\t\t\tgoto err_format;\n\t\tfallthrough;\n\tcase B43legacy_FW_TYPE_IV:\n\t\tif (hdr->ver != 1)\n\t\t\tgoto err_format;\n\t\tbreak;\n\tdefault:\n\t\tgoto err_format;\n\t}\n\n\treturn err;\n\nerr_format:\n\tb43legacyerr(dev->wl, \"Firmware file \\\"%s\\\" format error.\\n\", path);\n\treturn -EPROTO;\n}\n\nstatic int b43legacy_one_core_attach(struct ssb_device *dev,\n\t\t\t\t     struct b43legacy_wl *wl);\nstatic void b43legacy_one_core_detach(struct ssb_device *dev);\n\nstatic void b43legacy_request_firmware(struct work_struct *work)\n{\n\tstruct b43legacy_wl *wl = container_of(work,\n\t\t\t\t  struct b43legacy_wl, firmware_load);\n\tstruct b43legacy_wldev *dev = wl->current_dev;\n\tstruct b43legacy_firmware *fw = &dev->fw;\n\tconst u8 rev = dev->dev->id.revision;\n\tconst char *filename;\n\tint err;\n\n\tif (!fw->ucode) {\n\t\tif (rev == 2)\n\t\t\tfilename = \"ucode2\";\n\t\telse if (rev == 4)\n\t\t\tfilename = \"ucode4\";\n\t\telse\n\t\t\tfilename = \"ucode5\";\n\t\terr = do_request_fw(dev, filename, &fw->ucode, true);\n\t\tif (err)\n\t\t\tgoto err_load;\n\t}\n\tif (!fw->pcm) {\n\t\tif (rev < 5)\n\t\t\tfilename = \"pcm4\";\n\t\telse\n\t\t\tfilename = \"pcm5\";\n\t\terr = do_request_fw(dev, filename, &fw->pcm, false);\n\t\tif (err)\n\t\t\tgoto err_load;\n\t}\n\tif (!fw->initvals) {\n\t\tswitch (dev->phy.type) {\n\t\tcase B43legacy_PHYTYPE_B:\n\t\tcase B43legacy_PHYTYPE_G:\n\t\t\tif ((rev >= 5) && (rev <= 10))\n\t\t\t\tfilename = \"b0g0initvals5\";\n\t\t\telse if (rev == 2 || rev == 4)\n\t\t\t\tfilename = \"b0g0initvals2\";\n\t\t\telse\n\t\t\t\tgoto err_no_initvals;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_no_initvals;\n\t\t}\n\t\terr = do_request_fw(dev, filename, &fw->initvals, false);\n\t\tif (err)\n\t\t\tgoto err_load;\n\t}\n\tif (!fw->initvals_band) {\n\t\tswitch (dev->phy.type) {\n\t\tcase B43legacy_PHYTYPE_B:\n\t\tcase B43legacy_PHYTYPE_G:\n\t\t\tif ((rev >= 5) && (rev <= 10))\n\t\t\t\tfilename = \"b0g0bsinitvals5\";\n\t\t\telse if (rev >= 11)\n\t\t\t\tfilename = NULL;\n\t\t\telse if (rev == 2 || rev == 4)\n\t\t\t\tfilename = NULL;\n\t\t\telse\n\t\t\t\tgoto err_no_initvals;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_no_initvals;\n\t\t}\n\t\terr = do_request_fw(dev, filename, &fw->initvals_band, false);\n\t\tif (err)\n\t\t\tgoto err_load;\n\t}\n\terr = ieee80211_register_hw(wl->hw);\n\tif (err)\n\t\tgoto err_one_core_detach;\n\treturn;\n\nerr_one_core_detach:\n\tb43legacy_one_core_detach(dev->dev);\n\tgoto error;\n\nerr_load:\n\tb43legacy_print_fw_helptext(dev->wl);\n\tgoto error;\n\nerr_no_initvals:\n\terr = -ENODEV;\n\tb43legacyerr(dev->wl, \"No Initial Values firmware file for PHY %u, \"\n\t       \"core rev %u\\n\", dev->phy.type, rev);\n\tgoto error;\n\nerror:\n\tb43legacy_release_firmware(dev);\n\treturn;\n}\n\nstatic int b43legacy_upload_microcode(struct b43legacy_wldev *dev)\n{\n\tstruct wiphy *wiphy = dev->wl->hw->wiphy;\n\tconst size_t hdr_len = sizeof(struct b43legacy_fw_header);\n\tconst __be32 *data;\n\tunsigned int i;\n\tunsigned int len;\n\tu16 fwrev;\n\tu16 fwpatch;\n\tu16 fwdate;\n\tu16 fwtime;\n\tu32 tmp, macctl;\n\tint err = 0;\n\n\t \n\tmacctl = b43legacy_read32(dev, B43legacy_MMIO_MACCTL);\n\tB43legacy_WARN_ON(macctl & B43legacy_MACCTL_PSM_RUN);\n\tmacctl |= B43legacy_MACCTL_PSM_JMP0;\n\tb43legacy_write32(dev, B43legacy_MMIO_MACCTL, macctl);\n\t \n\tfor (i = 0; i < 64; i++)\n\t\tb43legacy_shm_write16(dev, B43legacy_SHM_WIRELESS, i, 0);\n\tfor (i = 0; i < 4096; i += 2)\n\t\tb43legacy_shm_write16(dev, B43legacy_SHM_SHARED, i, 0);\n\n\t \n\tdata = (__be32 *) (dev->fw.ucode->data + hdr_len);\n\tlen = (dev->fw.ucode->size - hdr_len) / sizeof(__be32);\n\tb43legacy_shm_control_word(dev,\n\t\t\t\t   B43legacy_SHM_UCODE |\n\t\t\t\t   B43legacy_SHM_AUTOINC_W,\n\t\t\t\t   0x0000);\n\tfor (i = 0; i < len; i++) {\n\t\tb43legacy_write32(dev, B43legacy_MMIO_SHM_DATA,\n\t\t\t\t    be32_to_cpu(data[i]));\n\t\tudelay(10);\n\t}\n\n\tif (dev->fw.pcm) {\n\t\t \n\t\tdata = (__be32 *) (dev->fw.pcm->data + hdr_len);\n\t\tlen = (dev->fw.pcm->size - hdr_len) / sizeof(__be32);\n\t\tb43legacy_shm_control_word(dev, B43legacy_SHM_HW, 0x01EA);\n\t\tb43legacy_write32(dev, B43legacy_MMIO_SHM_DATA, 0x00004000);\n\t\t \n\t\tb43legacy_shm_control_word(dev, B43legacy_SHM_HW, 0x01EB);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tb43legacy_write32(dev, B43legacy_MMIO_SHM_DATA,\n\t\t\t\t\t  be32_to_cpu(data[i]));\n\t\t\tudelay(10);\n\t\t}\n\t}\n\n\tb43legacy_write32(dev, B43legacy_MMIO_GEN_IRQ_REASON,\n\t\t\t  B43legacy_IRQ_ALL);\n\n\t \n\tmacctl = b43legacy_read32(dev, B43legacy_MMIO_MACCTL);\n\tmacctl &= ~B43legacy_MACCTL_PSM_JMP0;\n\tmacctl |= B43legacy_MACCTL_PSM_RUN;\n\tb43legacy_write32(dev, B43legacy_MMIO_MACCTL, macctl);\n\n\t \n\ti = 0;\n\twhile (1) {\n\t\ttmp = b43legacy_read32(dev, B43legacy_MMIO_GEN_IRQ_REASON);\n\t\tif (tmp == B43legacy_IRQ_MAC_SUSPENDED)\n\t\t\tbreak;\n\t\ti++;\n\t\tif (i >= B43legacy_IRQWAIT_MAX_RETRIES) {\n\t\t\tb43legacyerr(dev->wl, \"Microcode not responding\\n\");\n\t\t\tb43legacy_print_fw_helptext(dev->wl);\n\t\t\terr = -ENODEV;\n\t\t\tgoto error;\n\t\t}\n\t\tmsleep_interruptible(50);\n\t\tif (signal_pending(current)) {\n\t\t\terr = -EINTR;\n\t\t\tgoto error;\n\t\t}\n\t}\n\t \n\tb43legacy_read32(dev, B43legacy_MMIO_GEN_IRQ_REASON);\n\n\t \n\tfwrev = b43legacy_shm_read16(dev, B43legacy_SHM_SHARED,\n\t\t\t\t     B43legacy_SHM_SH_UCODEREV);\n\tfwpatch = b43legacy_shm_read16(dev, B43legacy_SHM_SHARED,\n\t\t\t\t       B43legacy_SHM_SH_UCODEPATCH);\n\tfwdate = b43legacy_shm_read16(dev, B43legacy_SHM_SHARED,\n\t\t\t\t      B43legacy_SHM_SH_UCODEDATE);\n\tfwtime = b43legacy_shm_read16(dev, B43legacy_SHM_SHARED,\n\t\t\t\t      B43legacy_SHM_SH_UCODETIME);\n\n\tif (fwrev > 0x128) {\n\t\tb43legacyerr(dev->wl, \"YOU ARE TRYING TO LOAD V4 FIRMWARE.\"\n\t\t\t     \" Only firmware from binary drivers version 3.x\"\n\t\t\t     \" is supported. You must change your firmware\"\n\t\t\t     \" files.\\n\");\n\t\tb43legacy_print_fw_helptext(dev->wl);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\tb43legacyinfo(dev->wl, \"Loading firmware version 0x%X, patch level %u \"\n\t\t      \"(20%.2i-%.2i-%.2i %.2i:%.2i:%.2i)\\n\", fwrev, fwpatch,\n\t\t      (fwdate >> 12) & 0xF, (fwdate >> 8) & 0xF, fwdate & 0xFF,\n\t\t      (fwtime >> 11) & 0x1F, (fwtime >> 5) & 0x3F,\n\t\t      fwtime & 0x1F);\n\n\tdev->fw.rev = fwrev;\n\tdev->fw.patch = fwpatch;\n\n\tsnprintf(wiphy->fw_version, sizeof(wiphy->fw_version), \"%u.%u\",\n\t\t\tdev->fw.rev, dev->fw.patch);\n\twiphy->hw_version = dev->dev->id.coreid;\n\n\treturn 0;\n\nerror:\n\tmacctl = b43legacy_read32(dev, B43legacy_MMIO_MACCTL);\n\tmacctl &= ~B43legacy_MACCTL_PSM_RUN;\n\tmacctl |= B43legacy_MACCTL_PSM_JMP0;\n\tb43legacy_write32(dev, B43legacy_MMIO_MACCTL, macctl);\n\n\treturn err;\n}\n\nstatic int b43legacy_write_initvals(struct b43legacy_wldev *dev,\n\t\t\t\t    const struct b43legacy_iv *ivals,\n\t\t\t\t    size_t count,\n\t\t\t\t    size_t array_size)\n{\n\tconst struct b43legacy_iv *iv;\n\tu16 offset;\n\tsize_t i;\n\tbool bit32;\n\n\tBUILD_BUG_ON(sizeof(struct b43legacy_iv) != 6);\n\tiv = ivals;\n\tfor (i = 0; i < count; i++) {\n\t\tif (array_size < sizeof(iv->offset_size))\n\t\t\tgoto err_format;\n\t\tarray_size -= sizeof(iv->offset_size);\n\t\toffset = be16_to_cpu(iv->offset_size);\n\t\tbit32 = !!(offset & B43legacy_IV_32BIT);\n\t\toffset &= B43legacy_IV_OFFSET_MASK;\n\t\tif (offset >= 0x1000)\n\t\t\tgoto err_format;\n\t\tif (bit32) {\n\t\t\tu32 value;\n\n\t\t\tif (array_size < sizeof(iv->data.d32))\n\t\t\t\tgoto err_format;\n\t\t\tarray_size -= sizeof(iv->data.d32);\n\n\t\t\tvalue = get_unaligned_be32(&iv->data.d32);\n\t\t\tb43legacy_write32(dev, offset, value);\n\n\t\t\tiv = (const struct b43legacy_iv *)((const uint8_t *)iv +\n\t\t\t\t\t\t\tsizeof(__be16) +\n\t\t\t\t\t\t\tsizeof(__be32));\n\t\t} else {\n\t\t\tu16 value;\n\n\t\t\tif (array_size < sizeof(iv->data.d16))\n\t\t\t\tgoto err_format;\n\t\t\tarray_size -= sizeof(iv->data.d16);\n\n\t\t\tvalue = be16_to_cpu(iv->data.d16);\n\t\t\tb43legacy_write16(dev, offset, value);\n\n\t\t\tiv = (const struct b43legacy_iv *)((const uint8_t *)iv +\n\t\t\t\t\t\t\tsizeof(__be16) +\n\t\t\t\t\t\t\tsizeof(__be16));\n\t\t}\n\t}\n\tif (array_size)\n\t\tgoto err_format;\n\n\treturn 0;\n\nerr_format:\n\tb43legacyerr(dev->wl, \"Initial Values Firmware file-format error.\\n\");\n\tb43legacy_print_fw_helptext(dev->wl);\n\n\treturn -EPROTO;\n}\n\nstatic int b43legacy_upload_initvals(struct b43legacy_wldev *dev)\n{\n\tconst size_t hdr_len = sizeof(struct b43legacy_fw_header);\n\tconst struct b43legacy_fw_header *hdr;\n\tstruct b43legacy_firmware *fw = &dev->fw;\n\tconst struct b43legacy_iv *ivals;\n\tsize_t count;\n\tint err;\n\n\thdr = (const struct b43legacy_fw_header *)(fw->initvals->data);\n\tivals = (const struct b43legacy_iv *)(fw->initvals->data + hdr_len);\n\tcount = be32_to_cpu(hdr->size);\n\terr = b43legacy_write_initvals(dev, ivals, count,\n\t\t\t\t fw->initvals->size - hdr_len);\n\tif (err)\n\t\tgoto out;\n\tif (fw->initvals_band) {\n\t\thdr = (const struct b43legacy_fw_header *)\n\t\t      (fw->initvals_band->data);\n\t\tivals = (const struct b43legacy_iv *)(fw->initvals_band->data\n\t\t\t+ hdr_len);\n\t\tcount = be32_to_cpu(hdr->size);\n\t\terr = b43legacy_write_initvals(dev, ivals, count,\n\t\t\t\t\t fw->initvals_band->size - hdr_len);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\nout:\n\n\treturn err;\n}\n\n \nstatic int b43legacy_gpio_init(struct b43legacy_wldev *dev)\n{\n\tstruct ssb_bus *bus = dev->dev->bus;\n\tstruct ssb_device *gpiodev, *pcidev = NULL;\n\tu32 mask;\n\tu32 set;\n\n\tb43legacy_write32(dev, B43legacy_MMIO_MACCTL,\n\t\t\t  b43legacy_read32(dev,\n\t\t\t  B43legacy_MMIO_MACCTL)\n\t\t\t  & 0xFFFF3FFF);\n\n\tb43legacy_write16(dev, B43legacy_MMIO_GPIO_MASK,\n\t\t\t  b43legacy_read16(dev,\n\t\t\t  B43legacy_MMIO_GPIO_MASK)\n\t\t\t  | 0x000F);\n\n\tmask = 0x0000001F;\n\tset = 0x0000000F;\n\tif (dev->dev->bus->chip_id == 0x4301) {\n\t\tmask |= 0x0060;\n\t\tset |= 0x0060;\n\t}\n\tif (dev->dev->bus->sprom.boardflags_lo & B43legacy_BFL_PACTRL) {\n\t\tb43legacy_write16(dev, B43legacy_MMIO_GPIO_MASK,\n\t\t\t\t  b43legacy_read16(dev,\n\t\t\t\t  B43legacy_MMIO_GPIO_MASK)\n\t\t\t\t  | 0x0200);\n\t\tmask |= 0x0200;\n\t\tset |= 0x0200;\n\t}\n\tif (dev->dev->id.revision >= 2)\n\t\tmask  |= 0x0010;  \n\n#ifdef CONFIG_SSB_DRIVER_PCICORE\n\tpcidev = bus->pcicore.dev;\n#endif\n\tgpiodev = bus->chipco.dev ? : pcidev;\n\tif (!gpiodev)\n\t\treturn 0;\n\tssb_write32(gpiodev, B43legacy_GPIO_CONTROL,\n\t\t    (ssb_read32(gpiodev, B43legacy_GPIO_CONTROL)\n\t\t     & ~mask) | set);\n\n\treturn 0;\n}\n\n \nstatic void b43legacy_gpio_cleanup(struct b43legacy_wldev *dev)\n{\n\tstruct ssb_bus *bus = dev->dev->bus;\n\tstruct ssb_device *gpiodev, *pcidev = NULL;\n\n#ifdef CONFIG_SSB_DRIVER_PCICORE\n\tpcidev = bus->pcicore.dev;\n#endif\n\tgpiodev = bus->chipco.dev ? : pcidev;\n\tif (!gpiodev)\n\t\treturn;\n\tssb_write32(gpiodev, B43legacy_GPIO_CONTROL, 0);\n}\n\n \nvoid b43legacy_mac_enable(struct b43legacy_wldev *dev)\n{\n\tdev->mac_suspended--;\n\tB43legacy_WARN_ON(dev->mac_suspended < 0);\n\tB43legacy_WARN_ON(irqs_disabled());\n\tif (dev->mac_suspended == 0) {\n\t\tb43legacy_write32(dev, B43legacy_MMIO_MACCTL,\n\t\t\t\t  b43legacy_read32(dev,\n\t\t\t\t  B43legacy_MMIO_MACCTL)\n\t\t\t\t  | B43legacy_MACCTL_ENABLED);\n\t\tb43legacy_write32(dev, B43legacy_MMIO_GEN_IRQ_REASON,\n\t\t\t\t  B43legacy_IRQ_MAC_SUSPENDED);\n\t\t \n\t\tb43legacy_read32(dev, B43legacy_MMIO_MACCTL);\n\t\tb43legacy_read32(dev, B43legacy_MMIO_GEN_IRQ_REASON);\n\t\tb43legacy_power_saving_ctl_bits(dev, -1, -1);\n\n\t\t \n\t\tspin_lock_irq(&dev->wl->irq_lock);\n\t\tb43legacy_write32(dev, B43legacy_MMIO_GEN_IRQ_MASK,\n\t\t\t\t  dev->irq_mask);\n\t\tspin_unlock_irq(&dev->wl->irq_lock);\n\t}\n}\n\n \nvoid b43legacy_mac_suspend(struct b43legacy_wldev *dev)\n{\n\tint i;\n\tu32 tmp;\n\n\tmight_sleep();\n\tB43legacy_WARN_ON(irqs_disabled());\n\tB43legacy_WARN_ON(dev->mac_suspended < 0);\n\n\tif (dev->mac_suspended == 0) {\n\t\t \n\t\tspin_lock_irq(&dev->wl->irq_lock);\n\t\tb43legacy_write32(dev, B43legacy_MMIO_GEN_IRQ_MASK, 0);\n\t\tspin_unlock_irq(&dev->wl->irq_lock);\n\t\tb43legacy_synchronize_irq(dev);\n\n\t\tb43legacy_power_saving_ctl_bits(dev, -1, 1);\n\t\tb43legacy_write32(dev, B43legacy_MMIO_MACCTL,\n\t\t\t\t  b43legacy_read32(dev,\n\t\t\t\t  B43legacy_MMIO_MACCTL)\n\t\t\t\t  & ~B43legacy_MACCTL_ENABLED);\n\t\tb43legacy_read32(dev, B43legacy_MMIO_GEN_IRQ_REASON);\n\t\tfor (i = 40; i; i--) {\n\t\t\ttmp = b43legacy_read32(dev,\n\t\t\t\t\t       B43legacy_MMIO_GEN_IRQ_REASON);\n\t\t\tif (tmp & B43legacy_IRQ_MAC_SUSPENDED)\n\t\t\t\tgoto out;\n\t\t\tmsleep(1);\n\t\t}\n\t\tb43legacyerr(dev->wl, \"MAC suspend failed\\n\");\n\t}\nout:\n\tdev->mac_suspended++;\n}\n\nstatic void b43legacy_adjust_opmode(struct b43legacy_wldev *dev)\n{\n\tstruct b43legacy_wl *wl = dev->wl;\n\tu32 ctl;\n\tu16 cfp_pretbtt;\n\n\tctl = b43legacy_read32(dev, B43legacy_MMIO_MACCTL);\n\t \n\tctl &= ~B43legacy_MACCTL_AP;\n\tctl &= ~B43legacy_MACCTL_KEEP_CTL;\n\tctl &= ~B43legacy_MACCTL_KEEP_BADPLCP;\n\tctl &= ~B43legacy_MACCTL_KEEP_BAD;\n\tctl &= ~B43legacy_MACCTL_PROMISC;\n\tctl &= ~B43legacy_MACCTL_BEACPROMISC;\n\tctl |= B43legacy_MACCTL_INFRA;\n\n\tif (b43legacy_is_mode(wl, NL80211_IFTYPE_AP))\n\t\tctl |= B43legacy_MACCTL_AP;\n\telse if (b43legacy_is_mode(wl, NL80211_IFTYPE_ADHOC))\n\t\tctl &= ~B43legacy_MACCTL_INFRA;\n\n\tif (wl->filter_flags & FIF_CONTROL)\n\t\tctl |= B43legacy_MACCTL_KEEP_CTL;\n\tif (wl->filter_flags & FIF_FCSFAIL)\n\t\tctl |= B43legacy_MACCTL_KEEP_BAD;\n\tif (wl->filter_flags & FIF_PLCPFAIL)\n\t\tctl |= B43legacy_MACCTL_KEEP_BADPLCP;\n\tif (wl->filter_flags & FIF_BCN_PRBRESP_PROMISC)\n\t\tctl |= B43legacy_MACCTL_BEACPROMISC;\n\n\t \n\tif (dev->dev->id.revision <= 4)\n\t\tctl |= B43legacy_MACCTL_PROMISC;\n\n\tb43legacy_write32(dev, B43legacy_MMIO_MACCTL, ctl);\n\n\tcfp_pretbtt = 2;\n\tif ((ctl & B43legacy_MACCTL_INFRA) &&\n\t    !(ctl & B43legacy_MACCTL_AP)) {\n\t\tif (dev->dev->bus->chip_id == 0x4306 &&\n\t\t    dev->dev->bus->chip_rev == 3)\n\t\t\tcfp_pretbtt = 100;\n\t\telse\n\t\t\tcfp_pretbtt = 50;\n\t}\n\tb43legacy_write16(dev, 0x612, cfp_pretbtt);\n}\n\nstatic void b43legacy_rate_memory_write(struct b43legacy_wldev *dev,\n\t\t\t\t\tu16 rate,\n\t\t\t\t\tint is_ofdm)\n{\n\tu16 offset;\n\n\tif (is_ofdm) {\n\t\toffset = 0x480;\n\t\toffset += (b43legacy_plcp_get_ratecode_ofdm(rate) & 0x000F) * 2;\n\t} else {\n\t\toffset = 0x4C0;\n\t\toffset += (b43legacy_plcp_get_ratecode_cck(rate) & 0x000F) * 2;\n\t}\n\tb43legacy_shm_write16(dev, B43legacy_SHM_SHARED, offset + 0x20,\n\t\t\t      b43legacy_shm_read16(dev,\n\t\t\t      B43legacy_SHM_SHARED, offset));\n}\n\nstatic void b43legacy_rate_memory_init(struct b43legacy_wldev *dev)\n{\n\tswitch (dev->phy.type) {\n\tcase B43legacy_PHYTYPE_G:\n\t\tb43legacy_rate_memory_write(dev, B43legacy_OFDM_RATE_6MB, 1);\n\t\tb43legacy_rate_memory_write(dev, B43legacy_OFDM_RATE_12MB, 1);\n\t\tb43legacy_rate_memory_write(dev, B43legacy_OFDM_RATE_18MB, 1);\n\t\tb43legacy_rate_memory_write(dev, B43legacy_OFDM_RATE_24MB, 1);\n\t\tb43legacy_rate_memory_write(dev, B43legacy_OFDM_RATE_36MB, 1);\n\t\tb43legacy_rate_memory_write(dev, B43legacy_OFDM_RATE_48MB, 1);\n\t\tb43legacy_rate_memory_write(dev, B43legacy_OFDM_RATE_54MB, 1);\n\t\tfallthrough;\n\tcase B43legacy_PHYTYPE_B:\n\t\tb43legacy_rate_memory_write(dev, B43legacy_CCK_RATE_1MB, 0);\n\t\tb43legacy_rate_memory_write(dev, B43legacy_CCK_RATE_2MB, 0);\n\t\tb43legacy_rate_memory_write(dev, B43legacy_CCK_RATE_5MB, 0);\n\t\tb43legacy_rate_memory_write(dev, B43legacy_CCK_RATE_11MB, 0);\n\t\tbreak;\n\tdefault:\n\t\tB43legacy_BUG_ON(1);\n\t}\n}\n\n \nstatic void b43legacy_mgmtframe_txantenna(struct b43legacy_wldev *dev,\n\t\t\t\t\t  int antenna)\n{\n\tu16 ant = 0;\n\tu16 tmp;\n\n\tswitch (antenna) {\n\tcase B43legacy_ANTENNA0:\n\t\tant |= B43legacy_TX4_PHY_ANT0;\n\t\tbreak;\n\tcase B43legacy_ANTENNA1:\n\t\tant |= B43legacy_TX4_PHY_ANT1;\n\t\tbreak;\n\tcase B43legacy_ANTENNA_AUTO:\n\t\tant |= B43legacy_TX4_PHY_ANTLAST;\n\t\tbreak;\n\tdefault:\n\t\tB43legacy_BUG_ON(1);\n\t}\n\n\t \n\n\t \n\ttmp = b43legacy_shm_read16(dev, B43legacy_SHM_SHARED,\n\t\t\t\t   B43legacy_SHM_SH_BEACPHYCTL);\n\ttmp = (tmp & ~B43legacy_TX4_PHY_ANT) | ant;\n\tb43legacy_shm_write16(dev, B43legacy_SHM_SHARED,\n\t\t\t      B43legacy_SHM_SH_BEACPHYCTL, tmp);\n\t \n\ttmp = b43legacy_shm_read16(dev, B43legacy_SHM_SHARED,\n\t\t\t\t   B43legacy_SHM_SH_ACKCTSPHYCTL);\n\ttmp = (tmp & ~B43legacy_TX4_PHY_ANT) | ant;\n\tb43legacy_shm_write16(dev, B43legacy_SHM_SHARED,\n\t\t\t      B43legacy_SHM_SH_ACKCTSPHYCTL, tmp);\n\t \n\ttmp = b43legacy_shm_read16(dev, B43legacy_SHM_SHARED,\n\t\t\t\t   B43legacy_SHM_SH_PRPHYCTL);\n\ttmp = (tmp & ~B43legacy_TX4_PHY_ANT) | ant;\n\tb43legacy_shm_write16(dev, B43legacy_SHM_SHARED,\n\t\t\t      B43legacy_SHM_SH_PRPHYCTL, tmp);\n}\n\n \nstatic void b43legacy_chip_exit(struct b43legacy_wldev *dev)\n{\n\tb43legacy_radio_turn_off(dev, 1);\n\tb43legacy_gpio_cleanup(dev);\n\t \n}\n\n \nstatic int b43legacy_chip_init(struct b43legacy_wldev *dev)\n{\n\tstruct b43legacy_phy *phy = &dev->phy;\n\tint err;\n\tint tmp;\n\tu32 value32, macctl;\n\tu16 value16;\n\n\t \n\tmacctl = B43legacy_MACCTL_IHR_ENABLED | B43legacy_MACCTL_SHM_ENABLED;\n\tif (dev->phy.gmode)\n\t\tmacctl |= B43legacy_MACCTL_GMODE;\n\tmacctl |= B43legacy_MACCTL_INFRA;\n\tb43legacy_write32(dev, B43legacy_MMIO_MACCTL, macctl);\n\n\terr = b43legacy_upload_microcode(dev);\n\tif (err)\n\t\tgoto out;  \n\n\terr = b43legacy_gpio_init(dev);\n\tif (err)\n\t\tgoto out;  \n\n\terr = b43legacy_upload_initvals(dev);\n\tif (err)\n\t\tgoto err_gpio_clean;\n\tb43legacy_radio_turn_on(dev);\n\n\tb43legacy_write16(dev, 0x03E6, 0x0000);\n\terr = b43legacy_phy_init(dev);\n\tif (err)\n\t\tgoto err_radio_off;\n\n\t \n\ttmp = phy->interfmode;\n\tphy->interfmode = B43legacy_INTERFMODE_NONE;\n\tb43legacy_radio_set_interference_mitigation(dev, tmp);\n\n\tb43legacy_phy_set_antenna_diversity(dev);\n\tb43legacy_mgmtframe_txantenna(dev, B43legacy_ANTENNA_DEFAULT);\n\n\tif (phy->type == B43legacy_PHYTYPE_B) {\n\t\tvalue16 = b43legacy_read16(dev, 0x005E);\n\t\tvalue16 |= 0x0004;\n\t\tb43legacy_write16(dev, 0x005E, value16);\n\t}\n\tb43legacy_write32(dev, 0x0100, 0x01000000);\n\tif (dev->dev->id.revision < 5)\n\t\tb43legacy_write32(dev, 0x010C, 0x01000000);\n\n\tvalue32 = b43legacy_read32(dev, B43legacy_MMIO_MACCTL);\n\tvalue32 &= ~B43legacy_MACCTL_INFRA;\n\tb43legacy_write32(dev, B43legacy_MMIO_MACCTL, value32);\n\tvalue32 = b43legacy_read32(dev, B43legacy_MMIO_MACCTL);\n\tvalue32 |= B43legacy_MACCTL_INFRA;\n\tb43legacy_write32(dev, B43legacy_MMIO_MACCTL, value32);\n\n\tif (b43legacy_using_pio(dev)) {\n\t\tb43legacy_write32(dev, 0x0210, 0x00000100);\n\t\tb43legacy_write32(dev, 0x0230, 0x00000100);\n\t\tb43legacy_write32(dev, 0x0250, 0x00000100);\n\t\tb43legacy_write32(dev, 0x0270, 0x00000100);\n\t\tb43legacy_shm_write16(dev, B43legacy_SHM_SHARED, 0x0034,\n\t\t\t\t      0x0000);\n\t}\n\n\t \n\t \n\tb43legacy_shm_write16(dev, B43legacy_SHM_SHARED, 0x0074, 0x0000);\n\n\t \n\tb43legacy_adjust_opmode(dev);\n\n\tif (dev->dev->id.revision < 3) {\n\t\tb43legacy_write16(dev, 0x060E, 0x0000);\n\t\tb43legacy_write16(dev, 0x0610, 0x8000);\n\t\tb43legacy_write16(dev, 0x0604, 0x0000);\n\t\tb43legacy_write16(dev, 0x0606, 0x0200);\n\t} else {\n\t\tb43legacy_write32(dev, 0x0188, 0x80000000);\n\t\tb43legacy_write32(dev, 0x018C, 0x02000000);\n\t}\n\tb43legacy_write32(dev, B43legacy_MMIO_GEN_IRQ_REASON, 0x00004000);\n\tb43legacy_write32(dev, B43legacy_MMIO_DMA0_IRQ_MASK, 0x0001DC00);\n\tb43legacy_write32(dev, B43legacy_MMIO_DMA1_IRQ_MASK, 0x0000DC00);\n\tb43legacy_write32(dev, B43legacy_MMIO_DMA2_IRQ_MASK, 0x0000DC00);\n\tb43legacy_write32(dev, B43legacy_MMIO_DMA3_IRQ_MASK, 0x0001DC00);\n\tb43legacy_write32(dev, B43legacy_MMIO_DMA4_IRQ_MASK, 0x0000DC00);\n\tb43legacy_write32(dev, B43legacy_MMIO_DMA5_IRQ_MASK, 0x0000DC00);\n\n\tvalue32 = ssb_read32(dev->dev, SSB_TMSLOW);\n\tvalue32 |= B43legacy_TMSLOW_MACPHYCLKEN;\n\tssb_write32(dev->dev, SSB_TMSLOW, value32);\n\n\tb43legacy_write16(dev, B43legacy_MMIO_POWERUP_DELAY,\n\t\t\t  dev->dev->bus->chipco.fast_pwrup_delay);\n\n\t \n\tatomic_set(&phy->txerr_cnt, B43legacy_PHY_TX_BADNESS_LIMIT);\n\n\tB43legacy_WARN_ON(err != 0);\n\tb43legacydbg(dev->wl, \"Chip initialized\\n\");\nout:\n\treturn err;\n\nerr_radio_off:\n\tb43legacy_radio_turn_off(dev, 1);\nerr_gpio_clean:\n\tb43legacy_gpio_cleanup(dev);\n\tgoto out;\n}\n\nstatic void b43legacy_periodic_every120sec(struct b43legacy_wldev *dev)\n{\n\tstruct b43legacy_phy *phy = &dev->phy;\n\n\tif (phy->type != B43legacy_PHYTYPE_G || phy->rev < 2)\n\t\treturn;\n\n\tb43legacy_mac_suspend(dev);\n\tb43legacy_phy_lo_g_measure(dev);\n\tb43legacy_mac_enable(dev);\n}\n\nstatic void b43legacy_periodic_every60sec(struct b43legacy_wldev *dev)\n{\n\tb43legacy_phy_lo_mark_all_unused(dev);\n\tif (dev->dev->bus->sprom.boardflags_lo & B43legacy_BFL_RSSI) {\n\t\tb43legacy_mac_suspend(dev);\n\t\tb43legacy_calc_nrssi_slope(dev);\n\t\tb43legacy_mac_enable(dev);\n\t}\n}\n\nstatic void b43legacy_periodic_every30sec(struct b43legacy_wldev *dev)\n{\n\t \n\tb43legacy_calculate_link_quality(dev);\n}\n\nstatic void b43legacy_periodic_every15sec(struct b43legacy_wldev *dev)\n{\n\tb43legacy_phy_xmitpower(dev);  \n\n\tatomic_set(&dev->phy.txerr_cnt, B43legacy_PHY_TX_BADNESS_LIMIT);\n\twmb();\n}\n\nstatic void do_periodic_work(struct b43legacy_wldev *dev)\n{\n\tunsigned int state;\n\n\tstate = dev->periodic_state;\n\tif (state % 8 == 0)\n\t\tb43legacy_periodic_every120sec(dev);\n\tif (state % 4 == 0)\n\t\tb43legacy_periodic_every60sec(dev);\n\tif (state % 2 == 0)\n\t\tb43legacy_periodic_every30sec(dev);\n\tb43legacy_periodic_every15sec(dev);\n}\n\n \nstatic void b43legacy_periodic_work_handler(struct work_struct *work)\n{\n\tstruct b43legacy_wldev *dev = container_of(work, struct b43legacy_wldev,\n\t\t\t\t\t     periodic_work.work);\n\tstruct b43legacy_wl *wl = dev->wl;\n\tunsigned long delay;\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(b43legacy_status(dev) != B43legacy_STAT_STARTED))\n\t\tgoto out;\n\tif (b43legacy_debug(dev, B43legacy_DBG_PWORK_STOP))\n\t\tgoto out_requeue;\n\n\tdo_periodic_work(dev);\n\n\tdev->periodic_state++;\nout_requeue:\n\tif (b43legacy_debug(dev, B43legacy_DBG_PWORK_FAST))\n\t\tdelay = msecs_to_jiffies(50);\n\telse\n\t\tdelay = round_jiffies_relative(HZ * 15);\n\tieee80211_queue_delayed_work(wl->hw, &dev->periodic_work, delay);\nout:\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic void b43legacy_periodic_tasks_setup(struct b43legacy_wldev *dev)\n{\n\tstruct delayed_work *work = &dev->periodic_work;\n\n\tdev->periodic_state = 0;\n\tINIT_DELAYED_WORK(work, b43legacy_periodic_work_handler);\n\tieee80211_queue_delayed_work(dev->wl->hw, work, 0);\n}\n\n \nstatic int b43legacy_validate_chipaccess(struct b43legacy_wldev *dev)\n{\n\tu32 value;\n\tu32 shm_backup;\n\n\tshm_backup = b43legacy_shm_read32(dev, B43legacy_SHM_SHARED, 0);\n\tb43legacy_shm_write32(dev, B43legacy_SHM_SHARED, 0, 0xAA5555AA);\n\tif (b43legacy_shm_read32(dev, B43legacy_SHM_SHARED, 0) !=\n\t\t\t\t 0xAA5555AA)\n\t\tgoto error;\n\tb43legacy_shm_write32(dev, B43legacy_SHM_SHARED, 0, 0x55AAAA55);\n\tif (b43legacy_shm_read32(dev, B43legacy_SHM_SHARED, 0) !=\n\t\t\t\t 0x55AAAA55)\n\t\tgoto error;\n\tb43legacy_shm_write32(dev, B43legacy_SHM_SHARED, 0, shm_backup);\n\n\tvalue = b43legacy_read32(dev, B43legacy_MMIO_MACCTL);\n\tif ((value | B43legacy_MACCTL_GMODE) !=\n\t    (B43legacy_MACCTL_GMODE | B43legacy_MACCTL_IHR_ENABLED))\n\t\tgoto error;\n\n\tvalue = b43legacy_read32(dev, B43legacy_MMIO_GEN_IRQ_REASON);\n\tif (value)\n\t\tgoto error;\n\n\treturn 0;\nerror:\n\tb43legacyerr(dev->wl, \"Failed to validate the chipaccess\\n\");\n\treturn -ENODEV;\n}\n\nstatic void b43legacy_security_init(struct b43legacy_wldev *dev)\n{\n\tdev->max_nr_keys = (dev->dev->id.revision >= 5) ? 58 : 20;\n\tB43legacy_WARN_ON(dev->max_nr_keys > ARRAY_SIZE(dev->key));\n\tdev->ktp = b43legacy_shm_read16(dev, B43legacy_SHM_SHARED,\n\t\t\t\t\t0x0056);\n\t \n\tdev->ktp *= 2;\n\tif (dev->dev->id.revision >= 5)\n\t\t \n\t\tb43legacy_write16(dev, B43legacy_MMIO_RCMTA_COUNT,\n\t\t\t\t  dev->max_nr_keys - 8);\n}\n\n#ifdef CONFIG_B43LEGACY_HWRNG\nstatic int b43legacy_rng_read(struct hwrng *rng, u32 *data)\n{\n\tstruct b43legacy_wl *wl = (struct b43legacy_wl *)rng->priv;\n\tunsigned long flags;\n\n\t \n\n\tspin_lock_irqsave(&wl->irq_lock, flags);\n\t*data = b43legacy_read16(wl->current_dev, B43legacy_MMIO_RNG);\n\tspin_unlock_irqrestore(&wl->irq_lock, flags);\n\n\treturn (sizeof(u16));\n}\n#endif\n\nstatic void b43legacy_rng_exit(struct b43legacy_wl *wl)\n{\n#ifdef CONFIG_B43LEGACY_HWRNG\n\tif (wl->rng_initialized)\n\t\thwrng_unregister(&wl->rng);\n#endif\n}\n\nstatic int b43legacy_rng_init(struct b43legacy_wl *wl)\n{\n\tint err = 0;\n\n#ifdef CONFIG_B43LEGACY_HWRNG\n\tsnprintf(wl->rng_name, ARRAY_SIZE(wl->rng_name),\n\t\t \"%s_%s\", KBUILD_MODNAME, wiphy_name(wl->hw->wiphy));\n\twl->rng.name = wl->rng_name;\n\twl->rng.data_read = b43legacy_rng_read;\n\twl->rng.priv = (unsigned long)wl;\n\twl->rng_initialized = 1;\n\terr = hwrng_register(&wl->rng);\n\tif (err) {\n\t\twl->rng_initialized = 0;\n\t\tb43legacyerr(wl, \"Failed to register the random \"\n\t\t       \"number generator (%d)\\n\", err);\n\t}\n\n#endif\n\treturn err;\n}\n\nstatic void b43legacy_tx_work(struct work_struct *work)\n{\n\tstruct b43legacy_wl *wl = container_of(work, struct b43legacy_wl,\n\t\t\t\t  tx_work);\n\tstruct b43legacy_wldev *dev;\n\tstruct sk_buff *skb;\n\tint queue_num;\n\tint err = 0;\n\n\tmutex_lock(&wl->mutex);\n\tdev = wl->current_dev;\n\tif (unlikely(!dev || b43legacy_status(dev) < B43legacy_STAT_STARTED)) {\n\t\tmutex_unlock(&wl->mutex);\n\t\treturn;\n\t}\n\n\tfor (queue_num = 0; queue_num < B43legacy_QOS_QUEUE_NUM; queue_num++) {\n\t\twhile (skb_queue_len(&wl->tx_queue[queue_num])) {\n\t\t\tskb = skb_dequeue(&wl->tx_queue[queue_num]);\n\t\t\tif (b43legacy_using_pio(dev))\n\t\t\t\terr = b43legacy_pio_tx(dev, skb);\n\t\t\telse\n\t\t\t\terr = b43legacy_dma_tx(dev, skb);\n\t\t\tif (err == -ENOSPC) {\n\t\t\t\twl->tx_queue_stopped[queue_num] = 1;\n\t\t\t\tieee80211_stop_queue(wl->hw, queue_num);\n\t\t\t\tskb_queue_head(&wl->tx_queue[queue_num], skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(err))\n\t\t\t\tdev_kfree_skb(skb);  \n\t\t\terr = 0;\n\t\t}\n\n\t\tif (!err)\n\t\t\twl->tx_queue_stopped[queue_num] = 0;\n\t}\n\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic void b43legacy_op_tx(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_tx_control *control,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct b43legacy_wl *wl = hw_to_b43legacy_wl(hw);\n\n\tif (unlikely(skb->len < 2 + 2 + 6)) {\n\t\t \n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\tB43legacy_WARN_ON(skb_shinfo(skb)->nr_frags);\n\n\tskb_queue_tail(&wl->tx_queue[skb->queue_mapping], skb);\n\tif (!wl->tx_queue_stopped[skb->queue_mapping])\n\t\tieee80211_queue_work(wl->hw, &wl->tx_work);\n\telse\n\t\tieee80211_stop_queue(wl->hw, skb->queue_mapping);\n}\n\nstatic int b43legacy_op_conf_tx(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tunsigned int link_id, u16 queue,\n\t\t\t\tconst struct ieee80211_tx_queue_params *params)\n{\n\treturn 0;\n}\n\nstatic int b43legacy_op_get_stats(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_low_level_stats *stats)\n{\n\tstruct b43legacy_wl *wl = hw_to_b43legacy_wl(hw);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wl->irq_lock, flags);\n\tmemcpy(stats, &wl->ieee_stats, sizeof(*stats));\n\tspin_unlock_irqrestore(&wl->irq_lock, flags);\n\n\treturn 0;\n}\n\nstatic const char *phymode_to_string(unsigned int phymode)\n{\n\tswitch (phymode) {\n\tcase B43legacy_PHYMODE_B:\n\t\treturn \"B\";\n\tcase B43legacy_PHYMODE_G:\n\t\treturn \"G\";\n\tdefault:\n\t\tB43legacy_BUG_ON(1);\n\t}\n\treturn \"\";\n}\n\nstatic int find_wldev_for_phymode(struct b43legacy_wl *wl,\n\t\t\t\t  unsigned int phymode,\n\t\t\t\t  struct b43legacy_wldev **dev,\n\t\t\t\t  bool *gmode)\n{\n\tstruct b43legacy_wldev *d;\n\n\tlist_for_each_entry(d, &wl->devlist, list) {\n\t\tif (d->phy.possible_phymodes & phymode) {\n\t\t\t \n\t\t\t*gmode = true;\n\t\t\t*dev = d;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ESRCH;\n}\n\nstatic void b43legacy_put_phy_into_reset(struct b43legacy_wldev *dev)\n{\n\tstruct ssb_device *sdev = dev->dev;\n\tu32 tmslow;\n\n\ttmslow = ssb_read32(sdev, SSB_TMSLOW);\n\ttmslow &= ~B43legacy_TMSLOW_GMODE;\n\ttmslow |= B43legacy_TMSLOW_PHYRESET;\n\ttmslow |= SSB_TMSLOW_FGC;\n\tssb_write32(sdev, SSB_TMSLOW, tmslow);\n\tmsleep(1);\n\n\ttmslow = ssb_read32(sdev, SSB_TMSLOW);\n\ttmslow &= ~SSB_TMSLOW_FGC;\n\ttmslow |= B43legacy_TMSLOW_PHYRESET;\n\tssb_write32(sdev, SSB_TMSLOW, tmslow);\n\tmsleep(1);\n}\n\n \nstatic int b43legacy_switch_phymode(struct b43legacy_wl *wl,\n\t\t\t\t      unsigned int new_mode)\n{\n\tstruct b43legacy_wldev *up_dev;\n\tstruct b43legacy_wldev *down_dev;\n\tint err;\n\tbool gmode = false;\n\tint prev_status;\n\n\terr = find_wldev_for_phymode(wl, new_mode, &up_dev, &gmode);\n\tif (err) {\n\t\tb43legacyerr(wl, \"Could not find a device for %s-PHY mode\\n\",\n\t\t       phymode_to_string(new_mode));\n\t\treturn err;\n\t}\n\tif ((up_dev == wl->current_dev) &&\n\t    (!!wl->current_dev->phy.gmode == !!gmode))\n\t\t \n\t\treturn 0;\n\tb43legacydbg(wl, \"Reconfiguring PHYmode to %s-PHY\\n\",\n\t       phymode_to_string(new_mode));\n\tdown_dev = wl->current_dev;\n\n\tprev_status = b43legacy_status(down_dev);\n\t \n\tif (prev_status >= B43legacy_STAT_STARTED)\n\t\tb43legacy_wireless_core_stop(down_dev);\n\tif (prev_status >= B43legacy_STAT_INITIALIZED)\n\t\tb43legacy_wireless_core_exit(down_dev);\n\n\tif (down_dev != up_dev)\n\t\t \n\t\tb43legacy_put_phy_into_reset(down_dev);\n\n\t \n\tup_dev->phy.gmode = gmode;\n\tif (prev_status >= B43legacy_STAT_INITIALIZED) {\n\t\terr = b43legacy_wireless_core_init(up_dev);\n\t\tif (err) {\n\t\t\tb43legacyerr(wl, \"Fatal: Could not initialize device\"\n\t\t\t\t     \" for newly selected %s-PHY mode\\n\",\n\t\t\t\t     phymode_to_string(new_mode));\n\t\t\tgoto init_failure;\n\t\t}\n\t}\n\tif (prev_status >= B43legacy_STAT_STARTED) {\n\t\terr = b43legacy_wireless_core_start(up_dev);\n\t\tif (err) {\n\t\t\tb43legacyerr(wl, \"Fatal: Could not start device for \"\n\t\t\t       \"newly selected %s-PHY mode\\n\",\n\t\t\t       phymode_to_string(new_mode));\n\t\t\tb43legacy_wireless_core_exit(up_dev);\n\t\t\tgoto init_failure;\n\t\t}\n\t}\n\tB43legacy_WARN_ON(b43legacy_status(up_dev) != prev_status);\n\n\tb43legacy_shm_write32(up_dev, B43legacy_SHM_SHARED, 0x003E, 0);\n\n\twl->current_dev = up_dev;\n\n\treturn 0;\ninit_failure:\n\t \n\twl->current_dev = NULL;\n\treturn err;\n}\n\n \nstatic void b43legacy_set_retry_limits(struct b43legacy_wldev *dev,\n\t\t\t\t       unsigned int short_retry,\n\t\t\t\t       unsigned int long_retry)\n{\n\t \n\tshort_retry = min(short_retry, (unsigned int)0xF);\n\tlong_retry = min(long_retry, (unsigned int)0xF);\n\n\tb43legacy_shm_write16(dev, B43legacy_SHM_WIRELESS, 0x0006, short_retry);\n\tb43legacy_shm_write16(dev, B43legacy_SHM_WIRELESS, 0x0007, long_retry);\n}\n\nstatic int b43legacy_op_dev_config(struct ieee80211_hw *hw,\n\t\t\t\t   u32 changed)\n{\n\tstruct b43legacy_wl *wl = hw_to_b43legacy_wl(hw);\n\tstruct b43legacy_wldev *dev;\n\tstruct b43legacy_phy *phy;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tunsigned long flags;\n\tunsigned int new_phymode = 0xFFFF;\n\tint antenna_tx;\n\tint err = 0;\n\n\tantenna_tx = B43legacy_ANTENNA_DEFAULT;\n\n\tmutex_lock(&wl->mutex);\n\tdev = wl->current_dev;\n\tphy = &dev->phy;\n\n\tif (changed & IEEE80211_CONF_CHANGE_RETRY_LIMITS)\n\t\tb43legacy_set_retry_limits(dev,\n\t\t\t\t\t   conf->short_frame_max_tx_count,\n\t\t\t\t\t   conf->long_frame_max_tx_count);\n\tchanged &= ~IEEE80211_CONF_CHANGE_RETRY_LIMITS;\n\tif (!changed)\n\t\tgoto out_unlock_mutex;\n\n\t \n\tswitch (conf->chandef.chan->band) {\n\tcase NL80211_BAND_2GHZ:\n\t\tif (phy->type == B43legacy_PHYTYPE_B)\n\t\t\tnew_phymode = B43legacy_PHYMODE_B;\n\t\telse\n\t\t\tnew_phymode = B43legacy_PHYMODE_G;\n\t\tbreak;\n\tdefault:\n\t\tB43legacy_WARN_ON(1);\n\t}\n\terr = b43legacy_switch_phymode(wl, new_phymode);\n\tif (err)\n\t\tgoto out_unlock_mutex;\n\n\t \n\tspin_lock_irqsave(&wl->irq_lock, flags);\n\tif (b43legacy_status(dev) < B43legacy_STAT_STARTED) {\n\t\tspin_unlock_irqrestore(&wl->irq_lock, flags);\n\t\tgoto out_unlock_mutex;\n\t}\n\tb43legacy_write32(dev, B43legacy_MMIO_GEN_IRQ_MASK, 0);\n\tspin_unlock_irqrestore(&wl->irq_lock, flags);\n\tb43legacy_synchronize_irq(dev);\n\n\t \n\tif (conf->chandef.chan->hw_value != phy->channel)\n\t\tb43legacy_radio_selectchannel(dev, conf->chandef.chan->hw_value,\n\t\t\t\t\t      0);\n\n\tdev->wl->radiotap_enabled = !!(conf->flags & IEEE80211_CONF_MONITOR);\n\n\t \n\tif (conf->power_level != 0) {\n\t\tif (conf->power_level != phy->power_level) {\n\t\t\tphy->power_level = conf->power_level;\n\t\t\tb43legacy_phy_xmitpower(dev);\n\t\t}\n\t}\n\n\t \n\tb43legacy_mgmtframe_txantenna(dev, antenna_tx);\n\n\tif (wl->radio_enabled != phy->radio_on) {\n\t\tif (wl->radio_enabled) {\n\t\t\tb43legacy_radio_turn_on(dev);\n\t\t\tb43legacyinfo(dev->wl, \"Radio turned on by software\\n\");\n\t\t\tif (!dev->radio_hw_enable)\n\t\t\t\tb43legacyinfo(dev->wl, \"The hardware RF-kill\"\n\t\t\t\t\t      \" button still turns the radio\"\n\t\t\t\t\t      \" physically off. Press the\"\n\t\t\t\t\t      \" button to turn it on.\\n\");\n\t\t} else {\n\t\t\tb43legacy_radio_turn_off(dev, 0);\n\t\t\tb43legacyinfo(dev->wl, \"Radio turned off by\"\n\t\t\t\t      \" software\\n\");\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&wl->irq_lock, flags);\n\tb43legacy_write32(dev, B43legacy_MMIO_GEN_IRQ_MASK, dev->irq_mask);\n\tspin_unlock_irqrestore(&wl->irq_lock, flags);\nout_unlock_mutex:\n\tmutex_unlock(&wl->mutex);\n\n\treturn err;\n}\n\nstatic void b43legacy_update_basic_rates(struct b43legacy_wldev *dev, u32 brates)\n{\n\tstruct ieee80211_supported_band *sband =\n\t\tdev->wl->hw->wiphy->bands[NL80211_BAND_2GHZ];\n\tconst struct ieee80211_rate *rate;\n\tint i;\n\tu16 basic, direct, offset, basic_offset, rateptr;\n\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\trate = &sband->bitrates[i];\n\n\t\tif (b43legacy_is_cck_rate(rate->hw_value)) {\n\t\t\tdirect = B43legacy_SHM_SH_CCKDIRECT;\n\t\t\tbasic = B43legacy_SHM_SH_CCKBASIC;\n\t\t\toffset = b43legacy_plcp_get_ratecode_cck(rate->hw_value);\n\t\t\toffset &= 0xF;\n\t\t} else {\n\t\t\tdirect = B43legacy_SHM_SH_OFDMDIRECT;\n\t\t\tbasic = B43legacy_SHM_SH_OFDMBASIC;\n\t\t\toffset = b43legacy_plcp_get_ratecode_ofdm(rate->hw_value);\n\t\t\toffset &= 0xF;\n\t\t}\n\n\t\trate = ieee80211_get_response_rate(sband, brates, rate->bitrate);\n\n\t\tif (b43legacy_is_cck_rate(rate->hw_value)) {\n\t\t\tbasic_offset = b43legacy_plcp_get_ratecode_cck(rate->hw_value);\n\t\t\tbasic_offset &= 0xF;\n\t\t} else {\n\t\t\tbasic_offset = b43legacy_plcp_get_ratecode_ofdm(rate->hw_value);\n\t\t\tbasic_offset &= 0xF;\n\t\t}\n\n\t\t \n\t\trateptr = b43legacy_shm_read16(dev, B43legacy_SHM_SHARED,\n\t\t\t\t\t       direct + 2 * basic_offset);\n\t\t \n\t\tb43legacy_shm_write16(dev, B43legacy_SHM_SHARED,\n\t\t\t\t      basic + 2 * offset, rateptr);\n\t}\n}\n\nstatic void b43legacy_op_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_bss_conf *conf,\n\t\t\t\t    u64 changed)\n{\n\tstruct b43legacy_wl *wl = hw_to_b43legacy_wl(hw);\n\tstruct b43legacy_wldev *dev;\n\tunsigned long flags;\n\n\tmutex_lock(&wl->mutex);\n\tB43legacy_WARN_ON(wl->vif != vif);\n\n\tdev = wl->current_dev;\n\n\t \n\tspin_lock_irqsave(&wl->irq_lock, flags);\n\tif (b43legacy_status(dev) < B43legacy_STAT_STARTED) {\n\t\tspin_unlock_irqrestore(&wl->irq_lock, flags);\n\t\tgoto out_unlock_mutex;\n\t}\n\tb43legacy_write32(dev, B43legacy_MMIO_GEN_IRQ_MASK, 0);\n\n\tif (changed & BSS_CHANGED_BSSID) {\n\t\tb43legacy_synchronize_irq(dev);\n\n\t\tif (conf->bssid)\n\t\t\tmemcpy(wl->bssid, conf->bssid, ETH_ALEN);\n\t\telse\n\t\t\teth_zero_addr(wl->bssid);\n\t}\n\n\tif (b43legacy_status(dev) >= B43legacy_STAT_INITIALIZED) {\n\t\tif (changed & BSS_CHANGED_BEACON &&\n\t\t    (b43legacy_is_mode(wl, NL80211_IFTYPE_AP) ||\n\t\t     b43legacy_is_mode(wl, NL80211_IFTYPE_ADHOC)))\n\t\t\tb43legacy_update_templates(wl);\n\n\t\tif (changed & BSS_CHANGED_BSSID)\n\t\t\tb43legacy_write_mac_bssid_templates(dev);\n\t}\n\tspin_unlock_irqrestore(&wl->irq_lock, flags);\n\n\tb43legacy_mac_suspend(dev);\n\n\tif (changed & BSS_CHANGED_BEACON_INT &&\n\t    (b43legacy_is_mode(wl, NL80211_IFTYPE_AP) ||\n\t     b43legacy_is_mode(wl, NL80211_IFTYPE_ADHOC)))\n\t\tb43legacy_set_beacon_int(dev, conf->beacon_int);\n\n\tif (changed & BSS_CHANGED_BASIC_RATES)\n\t\tb43legacy_update_basic_rates(dev, conf->basic_rates);\n\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\tif (conf->use_short_slot)\n\t\t\tb43legacy_short_slot_timing_enable(dev);\n\t\telse\n\t\t\tb43legacy_short_slot_timing_disable(dev);\n\t}\n\n\tb43legacy_mac_enable(dev);\n\n\tspin_lock_irqsave(&wl->irq_lock, flags);\n\tb43legacy_write32(dev, B43legacy_MMIO_GEN_IRQ_MASK, dev->irq_mask);\n\t \n\tspin_unlock_irqrestore(&wl->irq_lock, flags);\n out_unlock_mutex:\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic void b43legacy_op_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t\t  unsigned int changed,\n\t\t\t\t\t  unsigned int *fflags,u64 multicast)\n{\n\tstruct b43legacy_wl *wl = hw_to_b43legacy_wl(hw);\n\tstruct b43legacy_wldev *dev = wl->current_dev;\n\tunsigned long flags;\n\n\tif (!dev) {\n\t\t*fflags = 0;\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&wl->irq_lock, flags);\n\t*fflags &= FIF_ALLMULTI |\n\t\t  FIF_FCSFAIL |\n\t\t  FIF_PLCPFAIL |\n\t\t  FIF_CONTROL |\n\t\t  FIF_OTHER_BSS |\n\t\t  FIF_BCN_PRBRESP_PROMISC;\n\n\tchanged &= FIF_ALLMULTI |\n\t\t   FIF_FCSFAIL |\n\t\t   FIF_PLCPFAIL |\n\t\t   FIF_CONTROL |\n\t\t   FIF_OTHER_BSS |\n\t\t   FIF_BCN_PRBRESP_PROMISC;\n\n\twl->filter_flags = *fflags;\n\n\tif (changed && b43legacy_status(dev) >= B43legacy_STAT_INITIALIZED)\n\t\tb43legacy_adjust_opmode(dev);\n\tspin_unlock_irqrestore(&wl->irq_lock, flags);\n}\n\n \nstatic void b43legacy_wireless_core_stop(struct b43legacy_wldev *dev)\n{\n\tstruct b43legacy_wl *wl = dev->wl;\n\tunsigned long flags;\n\tint queue_num;\n\n\tif (b43legacy_status(dev) < B43legacy_STAT_STARTED)\n\t\treturn;\n\n\t \n\tspin_lock_irqsave(&wl->irq_lock, flags);\n\tb43legacy_write32(dev, B43legacy_MMIO_GEN_IRQ_MASK, 0);\n\tb43legacy_read32(dev, B43legacy_MMIO_GEN_IRQ_MASK);  \n\tspin_unlock_irqrestore(&wl->irq_lock, flags);\n\tb43legacy_synchronize_irq(dev);\n\n\tb43legacy_set_status(dev, B43legacy_STAT_INITIALIZED);\n\n\tmutex_unlock(&wl->mutex);\n\t \n\tcancel_delayed_work_sync(&dev->periodic_work);\n\tcancel_work_sync(&wl->tx_work);\n\tmutex_lock(&wl->mutex);\n\n\t \n\tfor (queue_num = 0; queue_num < B43legacy_QOS_QUEUE_NUM; queue_num++) {\n\t\twhile (skb_queue_len(&wl->tx_queue[queue_num]))\n\t\t\tdev_kfree_skb(skb_dequeue(&wl->tx_queue[queue_num]));\n\t}\n\n\tb43legacy_mac_suspend(dev);\n\tfree_irq(dev->dev->irq, dev);\n\tb43legacydbg(wl, \"Wireless interface stopped\\n\");\n}\n\n \nstatic int b43legacy_wireless_core_start(struct b43legacy_wldev *dev)\n{\n\tint err;\n\n\tB43legacy_WARN_ON(b43legacy_status(dev) != B43legacy_STAT_INITIALIZED);\n\n\tdrain_txstatus_queue(dev);\n\terr = request_irq(dev->dev->irq, b43legacy_interrupt_handler,\n\t\t\t  IRQF_SHARED, KBUILD_MODNAME, dev);\n\tif (err) {\n\t\tb43legacyerr(dev->wl, \"Cannot request IRQ-%d\\n\",\n\t\t       dev->dev->irq);\n\t\tgoto out;\n\t}\n\t \n\tieee80211_wake_queues(dev->wl->hw);\n\tb43legacy_set_status(dev, B43legacy_STAT_STARTED);\n\n\t \n\tb43legacy_mac_enable(dev);\n\tb43legacy_write32(dev, B43legacy_MMIO_GEN_IRQ_MASK, dev->irq_mask);\n\n\t \n\tb43legacy_periodic_tasks_setup(dev);\n\n\tb43legacydbg(dev->wl, \"Wireless interface started\\n\");\nout:\n\treturn err;\n}\n\n \nstatic int b43legacy_phy_versioning(struct b43legacy_wldev *dev)\n{\n\tstruct b43legacy_phy *phy = &dev->phy;\n\tu32 tmp;\n\tu8 analog_type;\n\tu8 phy_type;\n\tu8 phy_rev;\n\tu16 radio_manuf;\n\tu16 radio_ver;\n\tu16 radio_rev;\n\tint unsupported = 0;\n\n\t \n\ttmp = b43legacy_read16(dev, B43legacy_MMIO_PHY_VER);\n\tanalog_type = (tmp & B43legacy_PHYVER_ANALOG)\n\t\t      >> B43legacy_PHYVER_ANALOG_SHIFT;\n\tphy_type = (tmp & B43legacy_PHYVER_TYPE) >> B43legacy_PHYVER_TYPE_SHIFT;\n\tphy_rev = (tmp & B43legacy_PHYVER_VERSION);\n\tswitch (phy_type) {\n\tcase B43legacy_PHYTYPE_B:\n\t\tif (phy_rev != 2 && phy_rev != 4\n\t\t    && phy_rev != 6 && phy_rev != 7)\n\t\t\tunsupported = 1;\n\t\tbreak;\n\tcase B43legacy_PHYTYPE_G:\n\t\tif (phy_rev > 8)\n\t\t\tunsupported = 1;\n\t\tbreak;\n\tdefault:\n\t\tunsupported = 1;\n\t}\n\tif (unsupported) {\n\t\tb43legacyerr(dev->wl, \"FOUND UNSUPPORTED PHY \"\n\t\t       \"(Analog %u, Type %u, Revision %u)\\n\",\n\t\t       analog_type, phy_type, phy_rev);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tb43legacydbg(dev->wl, \"Found PHY: Analog %u, Type %u, Revision %u\\n\",\n\t       analog_type, phy_type, phy_rev);\n\n\n\t \n\tif (dev->dev->bus->chip_id == 0x4317) {\n\t\tif (dev->dev->bus->chip_rev == 0)\n\t\t\ttmp = 0x3205017F;\n\t\telse if (dev->dev->bus->chip_rev == 1)\n\t\t\ttmp = 0x4205017F;\n\t\telse\n\t\t\ttmp = 0x5205017F;\n\t} else {\n\t\tb43legacy_write16(dev, B43legacy_MMIO_RADIO_CONTROL,\n\t\t\t\t  B43legacy_RADIOCTL_ID);\n\t\ttmp = b43legacy_read16(dev, B43legacy_MMIO_RADIO_DATA_HIGH);\n\t\ttmp <<= 16;\n\t\tb43legacy_write16(dev, B43legacy_MMIO_RADIO_CONTROL,\n\t\t\t\t  B43legacy_RADIOCTL_ID);\n\t\ttmp |= b43legacy_read16(dev, B43legacy_MMIO_RADIO_DATA_LOW);\n\t}\n\tradio_manuf = (tmp & 0x00000FFF);\n\tradio_ver = (tmp & 0x0FFFF000) >> 12;\n\tradio_rev = (tmp & 0xF0000000) >> 28;\n\tswitch (phy_type) {\n\tcase B43legacy_PHYTYPE_B:\n\t\tif ((radio_ver & 0xFFF0) != 0x2050)\n\t\t\tunsupported = 1;\n\t\tbreak;\n\tcase B43legacy_PHYTYPE_G:\n\t\tif (radio_ver != 0x2050)\n\t\t\tunsupported = 1;\n\t\tbreak;\n\tdefault:\n\t\tB43legacy_BUG_ON(1);\n\t}\n\tif (unsupported) {\n\t\tb43legacyerr(dev->wl, \"FOUND UNSUPPORTED RADIO \"\n\t\t       \"(Manuf 0x%X, Version 0x%X, Revision %u)\\n\",\n\t\t       radio_manuf, radio_ver, radio_rev);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tb43legacydbg(dev->wl, \"Found Radio: Manuf 0x%X, Version 0x%X,\"\n\t\t     \" Revision %u\\n\", radio_manuf, radio_ver, radio_rev);\n\n\n\tphy->radio_manuf = radio_manuf;\n\tphy->radio_ver = radio_ver;\n\tphy->radio_rev = radio_rev;\n\n\tphy->analog = analog_type;\n\tphy->type = phy_type;\n\tphy->rev = phy_rev;\n\n\treturn 0;\n}\n\nstatic void setup_struct_phy_for_init(struct b43legacy_wldev *dev,\n\t\t\t\t      struct b43legacy_phy *phy)\n{\n\tstruct b43legacy_lopair *lo;\n\tint i;\n\n\tmemset(phy->minlowsig, 0xFF, sizeof(phy->minlowsig));\n\tmemset(phy->minlowsigpos, 0, sizeof(phy->minlowsigpos));\n\n\t \n\tdev->radio_hw_enable = true;\n\n\tphy->savedpctlreg = 0xFFFF;\n\tphy->aci_enable = false;\n\tphy->aci_wlan_automatic = false;\n\tphy->aci_hw_rssi = false;\n\n\tlo = phy->_lo_pairs;\n\tif (lo)\n\t\tmemset(lo, 0, sizeof(struct b43legacy_lopair) *\n\t\t\t\t     B43legacy_LO_COUNT);\n\tphy->max_lb_gain = 0;\n\tphy->trsw_rx_gain = 0;\n\n\t \n\tphy->bbatt = b43legacy_default_baseband_attenuation(dev);\n\tphy->rfatt = b43legacy_default_radio_attenuation(dev);\n\tphy->txctl1 = b43legacy_default_txctl1(dev);\n\tphy->txpwr_offset = 0;\n\n\t \n\tphy->nrssislope = 0;\n\tfor (i = 0; i < ARRAY_SIZE(phy->nrssi); i++)\n\t\tphy->nrssi[i] = -1000;\n\tfor (i = 0; i < ARRAY_SIZE(phy->nrssi_lt); i++)\n\t\tphy->nrssi_lt[i] = i;\n\n\tphy->lofcal = 0xFFFF;\n\tphy->initval = 0xFFFF;\n\n\tphy->interfmode = B43legacy_INTERFMODE_NONE;\n\tphy->channel = 0xFF;\n}\n\nstatic void setup_struct_wldev_for_init(struct b43legacy_wldev *dev)\n{\n\t \n\tdev->dfq_valid = false;\n\n\t \n\tmemset(&dev->stats, 0, sizeof(dev->stats));\n\n\tsetup_struct_phy_for_init(dev, &dev->phy);\n\n\t \n\tdev->irq_reason = 0;\n\tmemset(dev->dma_reason, 0, sizeof(dev->dma_reason));\n\tdev->irq_mask = B43legacy_IRQ_MASKTEMPLATE;\n\n\tdev->mac_suspended = 1;\n\n\t \n\tmemset(&dev->noisecalc, 0, sizeof(dev->noisecalc));\n}\n\nstatic void b43legacy_set_synth_pu_delay(struct b43legacy_wldev *dev,\n\t\t\t\t\t  bool idle) {\n\tu16 pu_delay = 1050;\n\n\tif (b43legacy_is_mode(dev->wl, NL80211_IFTYPE_ADHOC) || idle)\n\t\tpu_delay = 500;\n\tif ((dev->phy.radio_ver == 0x2050) && (dev->phy.radio_rev == 8))\n\t\tpu_delay = max(pu_delay, (u16)2400);\n\n\tb43legacy_shm_write16(dev, B43legacy_SHM_SHARED,\n\t\t\t      B43legacy_SHM_SH_SPUWKUP, pu_delay);\n}\n\n \nstatic void b43legacy_set_pretbtt(struct b43legacy_wldev *dev)\n{\n\tu16 pretbtt;\n\n\t \n\tif (b43legacy_is_mode(dev->wl, NL80211_IFTYPE_ADHOC))\n\t\tpretbtt = 2;\n\telse\n\t\tpretbtt = 250;\n\tb43legacy_shm_write16(dev, B43legacy_SHM_SHARED,\n\t\t\t      B43legacy_SHM_SH_PRETBTT, pretbtt);\n\tb43legacy_write16(dev, B43legacy_MMIO_TSF_CFP_PRETBTT, pretbtt);\n}\n\n \n \nstatic void b43legacy_wireless_core_exit(struct b43legacy_wldev *dev)\n{\n\tstruct b43legacy_phy *phy = &dev->phy;\n\tu32 macctl;\n\n\tB43legacy_WARN_ON(b43legacy_status(dev) > B43legacy_STAT_INITIALIZED);\n\tif (b43legacy_status(dev) != B43legacy_STAT_INITIALIZED)\n\t\treturn;\n\tb43legacy_set_status(dev, B43legacy_STAT_UNINIT);\n\n\t \n\tmacctl = b43legacy_read32(dev, B43legacy_MMIO_MACCTL);\n\tmacctl &= ~B43legacy_MACCTL_PSM_RUN;\n\tmacctl |= B43legacy_MACCTL_PSM_JMP0;\n\tb43legacy_write32(dev, B43legacy_MMIO_MACCTL, macctl);\n\n\tb43legacy_leds_exit(dev);\n\tb43legacy_rng_exit(dev->wl);\n\tb43legacy_pio_free(dev);\n\tb43legacy_dma_free(dev);\n\tb43legacy_chip_exit(dev);\n\tb43legacy_radio_turn_off(dev, 1);\n\tb43legacy_switch_analog(dev, 0);\n\tif (phy->dyn_tssi_tbl)\n\t\tkfree(phy->tssi2dbm);\n\tkfree(phy->lo_control);\n\tphy->lo_control = NULL;\n\tif (dev->wl->current_beacon) {\n\t\tdev_kfree_skb_any(dev->wl->current_beacon);\n\t\tdev->wl->current_beacon = NULL;\n\t}\n\n\tssb_device_disable(dev->dev, 0);\n\tssb_bus_may_powerdown(dev->dev->bus);\n}\n\nstatic void prepare_phy_data_for_init(struct b43legacy_wldev *dev)\n{\n\tstruct b43legacy_phy *phy = &dev->phy;\n\tint i;\n\n\t \n\tphy->bbatt = b43legacy_default_baseband_attenuation(dev);\n\tphy->rfatt = b43legacy_default_radio_attenuation(dev);\n\tphy->txctl1 = b43legacy_default_txctl1(dev);\n\tphy->txctl2 = 0xFFFF;\n\tphy->txpwr_offset = 0;\n\n\t \n\tphy->nrssislope = 0;\n\tfor (i = 0; i < ARRAY_SIZE(phy->nrssi); i++)\n\t\tphy->nrssi[i] = -1000;\n\tfor (i = 0; i < ARRAY_SIZE(phy->nrssi_lt); i++)\n\t\tphy->nrssi_lt[i] = i;\n\n\tphy->lofcal = 0xFFFF;\n\tphy->initval = 0xFFFF;\n\n\tphy->aci_enable = false;\n\tphy->aci_wlan_automatic = false;\n\tphy->aci_hw_rssi = false;\n\n\tphy->antenna_diversity = 0xFFFF;\n\tmemset(phy->minlowsig, 0xFF, sizeof(phy->minlowsig));\n\tmemset(phy->minlowsigpos, 0, sizeof(phy->minlowsigpos));\n\n\t \n\tphy->calibrated = 0;\n\n\tif (phy->_lo_pairs)\n\t\tmemset(phy->_lo_pairs, 0,\n\t\t       sizeof(struct b43legacy_lopair) * B43legacy_LO_COUNT);\n\tmemset(phy->loopback_gain, 0, sizeof(phy->loopback_gain));\n}\n\n \nstatic int b43legacy_wireless_core_init(struct b43legacy_wldev *dev)\n{\n\tstruct b43legacy_wl *wl = dev->wl;\n\tstruct ssb_bus *bus = dev->dev->bus;\n\tstruct b43legacy_phy *phy = &dev->phy;\n\tstruct ssb_sprom *sprom = &dev->dev->bus->sprom;\n\tint err;\n\tu32 hf;\n\tu32 tmp;\n\n\tB43legacy_WARN_ON(b43legacy_status(dev) != B43legacy_STAT_UNINIT);\n\n\terr = ssb_bus_powerup(bus, 0);\n\tif (err)\n\t\tgoto out;\n\tif (!ssb_device_is_enabled(dev->dev)) {\n\t\ttmp = phy->gmode ? B43legacy_TMSLOW_GMODE : 0;\n\t\tb43legacy_wireless_core_reset(dev, tmp);\n\t}\n\n\tif ((phy->type == B43legacy_PHYTYPE_B) ||\n\t    (phy->type == B43legacy_PHYTYPE_G)) {\n\t\tphy->_lo_pairs = kcalloc(B43legacy_LO_COUNT,\n\t\t\t\t\t sizeof(struct b43legacy_lopair),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!phy->_lo_pairs)\n\t\t\treturn -ENOMEM;\n\t}\n\tsetup_struct_wldev_for_init(dev);\n\n\terr = b43legacy_phy_init_tssi2dbm_table(dev);\n\tif (err)\n\t\tgoto err_kfree_lo_control;\n\n\t \n\tssb_pcicore_dev_irqvecs_enable(&bus->pcicore, dev->dev);\n\n\tprepare_phy_data_for_init(dev);\n\tb43legacy_phy_calibrate(dev);\n\terr = b43legacy_chip_init(dev);\n\tif (err)\n\t\tgoto err_kfree_tssitbl;\n\tb43legacy_shm_write16(dev, B43legacy_SHM_SHARED,\n\t\t\t      B43legacy_SHM_SH_WLCOREREV,\n\t\t\t      dev->dev->id.revision);\n\thf = b43legacy_hf_read(dev);\n\tif (phy->type == B43legacy_PHYTYPE_G) {\n\t\thf |= B43legacy_HF_SYMW;\n\t\tif (phy->rev == 1)\n\t\t\thf |= B43legacy_HF_GDCW;\n\t\tif (sprom->boardflags_lo & B43legacy_BFL_PACTRL)\n\t\t\thf |= B43legacy_HF_OFDMPABOOST;\n\t} else if (phy->type == B43legacy_PHYTYPE_B) {\n\t\thf |= B43legacy_HF_SYMW;\n\t\tif (phy->rev >= 2 && phy->radio_ver == 0x2050)\n\t\t\thf &= ~B43legacy_HF_GDCW;\n\t}\n\tb43legacy_hf_write(dev, hf);\n\n\tb43legacy_set_retry_limits(dev,\n\t\t\t\t   B43legacy_DEFAULT_SHORT_RETRY_LIMIT,\n\t\t\t\t   B43legacy_DEFAULT_LONG_RETRY_LIMIT);\n\n\tb43legacy_shm_write16(dev, B43legacy_SHM_SHARED,\n\t\t\t      0x0044, 3);\n\tb43legacy_shm_write16(dev, B43legacy_SHM_SHARED,\n\t\t\t      0x0046, 2);\n\n\t \n\tb43legacy_shm_write16(dev, B43legacy_SHM_SHARED,\n\t\t\t      B43legacy_SHM_SH_PRMAXTIME, 1);\n\n\tb43legacy_rate_memory_init(dev);\n\n\t \n\tif (phy->type == B43legacy_PHYTYPE_B)\n\t\tb43legacy_shm_write16(dev, B43legacy_SHM_WIRELESS,\n\t\t\t\t      0x0003, 31);\n\telse\n\t\tb43legacy_shm_write16(dev, B43legacy_SHM_WIRELESS,\n\t\t\t\t      0x0003, 15);\n\t \n\tb43legacy_shm_write16(dev, B43legacy_SHM_WIRELESS,\n\t\t\t      0x0004, 1023);\n\n\tdo {\n\t\tif (b43legacy_using_pio(dev))\n\t\t\terr = b43legacy_pio_init(dev);\n\t\telse {\n\t\t\terr = b43legacy_dma_init(dev);\n\t\t\tif (!err)\n\t\t\t\tb43legacy_qos_init(dev);\n\t\t}\n\t} while (err == -EAGAIN);\n\tif (err)\n\t\tgoto err_chip_exit;\n\n\tb43legacy_set_synth_pu_delay(dev, 1);\n\n\tssb_bus_powerup(bus, 1);  \n\tb43legacy_upload_card_macaddress(dev);\n\tb43legacy_security_init(dev);\n\tb43legacy_rng_init(wl);\n\n\tieee80211_wake_queues(dev->wl->hw);\n\tb43legacy_set_status(dev, B43legacy_STAT_INITIALIZED);\n\n\tb43legacy_leds_init(dev);\nout:\n\treturn err;\n\nerr_chip_exit:\n\tb43legacy_chip_exit(dev);\nerr_kfree_tssitbl:\n\tif (phy->dyn_tssi_tbl)\n\t\tkfree(phy->tssi2dbm);\nerr_kfree_lo_control:\n\tkfree(phy->lo_control);\n\tphy->lo_control = NULL;\n\tssb_bus_may_powerdown(bus);\n\tB43legacy_WARN_ON(b43legacy_status(dev) != B43legacy_STAT_UNINIT);\n\treturn err;\n}\n\nstatic int b43legacy_op_add_interface(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct b43legacy_wl *wl = hw_to_b43legacy_wl(hw);\n\tstruct b43legacy_wldev *dev;\n\tunsigned long flags;\n\tint err = -EOPNOTSUPP;\n\n\t \n\n\tif (vif->type != NL80211_IFTYPE_AP &&\n\t    vif->type != NL80211_IFTYPE_STATION &&\n\t    vif->type != NL80211_IFTYPE_ADHOC)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&wl->mutex);\n\tif (wl->operating)\n\t\tgoto out_mutex_unlock;\n\n\tb43legacydbg(wl, \"Adding Interface type %d\\n\", vif->type);\n\n\tdev = wl->current_dev;\n\twl->operating = true;\n\twl->vif = vif;\n\twl->if_type = vif->type;\n\tmemcpy(wl->mac_addr, vif->addr, ETH_ALEN);\n\n\tspin_lock_irqsave(&wl->irq_lock, flags);\n\tb43legacy_adjust_opmode(dev);\n\tb43legacy_set_pretbtt(dev);\n\tb43legacy_set_synth_pu_delay(dev, 0);\n\tb43legacy_upload_card_macaddress(dev);\n\tspin_unlock_irqrestore(&wl->irq_lock, flags);\n\n\terr = 0;\n out_mutex_unlock:\n\tmutex_unlock(&wl->mutex);\n\n\treturn err;\n}\n\nstatic void b43legacy_op_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct b43legacy_wl *wl = hw_to_b43legacy_wl(hw);\n\tstruct b43legacy_wldev *dev = wl->current_dev;\n\tunsigned long flags;\n\n\tb43legacydbg(wl, \"Removing Interface type %d\\n\", vif->type);\n\n\tmutex_lock(&wl->mutex);\n\n\tB43legacy_WARN_ON(!wl->operating);\n\tB43legacy_WARN_ON(wl->vif != vif);\n\twl->vif = NULL;\n\n\twl->operating = false;\n\n\tspin_lock_irqsave(&wl->irq_lock, flags);\n\tb43legacy_adjust_opmode(dev);\n\teth_zero_addr(wl->mac_addr);\n\tb43legacy_upload_card_macaddress(dev);\n\tspin_unlock_irqrestore(&wl->irq_lock, flags);\n\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic int b43legacy_op_start(struct ieee80211_hw *hw)\n{\n\tstruct b43legacy_wl *wl = hw_to_b43legacy_wl(hw);\n\tstruct b43legacy_wldev *dev = wl->current_dev;\n\tint did_init = 0;\n\tint err = 0;\n\n\t \n\teth_zero_addr(wl->bssid);\n\teth_zero_addr(wl->mac_addr);\n\twl->filter_flags = 0;\n\twl->beacon0_uploaded = false;\n\twl->beacon1_uploaded = false;\n\twl->beacon_templates_virgin = true;\n\twl->radio_enabled = true;\n\n\tmutex_lock(&wl->mutex);\n\n\tif (b43legacy_status(dev) < B43legacy_STAT_INITIALIZED) {\n\t\terr = b43legacy_wireless_core_init(dev);\n\t\tif (err)\n\t\t\tgoto out_mutex_unlock;\n\t\tdid_init = 1;\n\t}\n\n\tif (b43legacy_status(dev) < B43legacy_STAT_STARTED) {\n\t\terr = b43legacy_wireless_core_start(dev);\n\t\tif (err) {\n\t\t\tif (did_init)\n\t\t\t\tb43legacy_wireless_core_exit(dev);\n\t\t\tgoto out_mutex_unlock;\n\t\t}\n\t}\n\n\twiphy_rfkill_start_polling(hw->wiphy);\n\nout_mutex_unlock:\n\tmutex_unlock(&wl->mutex);\n\n\treturn err;\n}\n\nstatic void b43legacy_op_stop(struct ieee80211_hw *hw)\n{\n\tstruct b43legacy_wl *wl = hw_to_b43legacy_wl(hw);\n\tstruct b43legacy_wldev *dev = wl->current_dev;\n\n\tcancel_work_sync(&(wl->beacon_update_trigger));\n\n\tmutex_lock(&wl->mutex);\n\tif (b43legacy_status(dev) >= B43legacy_STAT_STARTED)\n\t\tb43legacy_wireless_core_stop(dev);\n\tb43legacy_wireless_core_exit(dev);\n\twl->radio_enabled = false;\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic int b43legacy_op_beacon_set_tim(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_sta *sta, bool set)\n{\n\tstruct b43legacy_wl *wl = hw_to_b43legacy_wl(hw);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wl->irq_lock, flags);\n\tb43legacy_update_templates(wl);\n\tspin_unlock_irqrestore(&wl->irq_lock, flags);\n\n\treturn 0;\n}\n\nstatic int b43legacy_op_get_survey(struct ieee80211_hw *hw, int idx,\n\t\t\t\t   struct survey_info *survey)\n{\n\tstruct b43legacy_wl *wl = hw_to_b43legacy_wl(hw);\n\tstruct b43legacy_wldev *dev = wl->current_dev;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\n\tif (idx != 0)\n\t\treturn -ENOENT;\n\n\tsurvey->channel = conf->chandef.chan;\n\tsurvey->filled = SURVEY_INFO_NOISE_DBM;\n\tsurvey->noise = dev->stats.link_noise;\n\n\treturn 0;\n}\n\nstatic const struct ieee80211_ops b43legacy_hw_ops = {\n\t.tx\t\t\t= b43legacy_op_tx,\n\t.wake_tx_queue\t\t= ieee80211_handle_wake_tx_queue,\n\t.conf_tx\t\t= b43legacy_op_conf_tx,\n\t.add_interface\t\t= b43legacy_op_add_interface,\n\t.remove_interface\t= b43legacy_op_remove_interface,\n\t.config\t\t\t= b43legacy_op_dev_config,\n\t.bss_info_changed\t= b43legacy_op_bss_info_changed,\n\t.configure_filter\t= b43legacy_op_configure_filter,\n\t.get_stats\t\t= b43legacy_op_get_stats,\n\t.start\t\t\t= b43legacy_op_start,\n\t.stop\t\t\t= b43legacy_op_stop,\n\t.set_tim\t\t= b43legacy_op_beacon_set_tim,\n\t.get_survey\t\t= b43legacy_op_get_survey,\n\t.rfkill_poll\t\t= b43legacy_rfkill_poll,\n};\n\n \nstatic void b43legacy_chip_reset(struct work_struct *work)\n{\n\tstruct b43legacy_wldev *dev =\n\t\tcontainer_of(work, struct b43legacy_wldev, restart_work);\n\tstruct b43legacy_wl *wl = dev->wl;\n\tint err = 0;\n\tint prev_status;\n\n\tmutex_lock(&wl->mutex);\n\n\tprev_status = b43legacy_status(dev);\n\t \n\tif (prev_status >= B43legacy_STAT_STARTED)\n\t\tb43legacy_wireless_core_stop(dev);\n\tif (prev_status >= B43legacy_STAT_INITIALIZED)\n\t\tb43legacy_wireless_core_exit(dev);\n\n\t \n\tif (prev_status >= B43legacy_STAT_INITIALIZED) {\n\t\terr = b43legacy_wireless_core_init(dev);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\tif (prev_status >= B43legacy_STAT_STARTED) {\n\t\terr = b43legacy_wireless_core_start(dev);\n\t\tif (err) {\n\t\t\tb43legacy_wireless_core_exit(dev);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tif (err)\n\t\twl->current_dev = NULL;  \n\tmutex_unlock(&wl->mutex);\n\tif (err)\n\t\tb43legacyerr(wl, \"Controller restart FAILED\\n\");\n\telse\n\t\tb43legacyinfo(wl, \"Controller restarted\\n\");\n}\n\nstatic int b43legacy_setup_modes(struct b43legacy_wldev *dev,\n\t\t\t\t int have_bphy,\n\t\t\t\t int have_gphy)\n{\n\tstruct ieee80211_hw *hw = dev->wl->hw;\n\tstruct b43legacy_phy *phy = &dev->phy;\n\n\tphy->possible_phymodes = 0;\n\tif (have_bphy) {\n\t\thw->wiphy->bands[NL80211_BAND_2GHZ] =\n\t\t\t&b43legacy_band_2GHz_BPHY;\n\t\tphy->possible_phymodes |= B43legacy_PHYMODE_B;\n\t}\n\n\tif (have_gphy) {\n\t\thw->wiphy->bands[NL80211_BAND_2GHZ] =\n\t\t\t&b43legacy_band_2GHz_GPHY;\n\t\tphy->possible_phymodes |= B43legacy_PHYMODE_G;\n\t}\n\n\treturn 0;\n}\n\nstatic void b43legacy_wireless_core_detach(struct b43legacy_wldev *dev)\n{\n\t \n\tb43legacy_release_firmware(dev);\n}\n\nstatic int b43legacy_wireless_core_attach(struct b43legacy_wldev *dev)\n{\n\tstruct b43legacy_wl *wl = dev->wl;\n\tstruct ssb_bus *bus = dev->dev->bus;\n\tstruct pci_dev *pdev = (bus->bustype == SSB_BUSTYPE_PCI) ? bus->host_pci : NULL;\n\tint err;\n\tint have_bphy = 0;\n\tint have_gphy = 0;\n\tu32 tmp;\n\n\t \n\n\terr = ssb_bus_powerup(bus, 0);\n\tif (err) {\n\t\tb43legacyerr(wl, \"Bus powerup failed\\n\");\n\t\tgoto out;\n\t}\n\t \n\tif (dev->dev->id.revision >= 5) {\n\t\tu32 tmshigh;\n\n\t\ttmshigh = ssb_read32(dev->dev, SSB_TMSHIGH);\n\t\thave_gphy = !!(tmshigh & B43legacy_TMSHIGH_GPHY);\n\t\tif (!have_gphy)\n\t\t\thave_bphy = 1;\n\t} else if (dev->dev->id.revision == 4)\n\t\thave_gphy = 1;\n\telse\n\t\thave_bphy = 1;\n\n\tdev->phy.gmode = (have_gphy || have_bphy);\n\tdev->phy.radio_on = true;\n\ttmp = dev->phy.gmode ? B43legacy_TMSLOW_GMODE : 0;\n\tb43legacy_wireless_core_reset(dev, tmp);\n\n\terr = b43legacy_phy_versioning(dev);\n\tif (err)\n\t\tgoto err_powerdown;\n\t \n\tif (!pdev ||\n\t    (pdev->device != 0x4312 &&\n\t     pdev->device != 0x4319 &&\n\t     pdev->device != 0x4324)) {\n\t\t \n\t\thave_bphy = 0;\n\t\thave_gphy = 0;\n\t\tswitch (dev->phy.type) {\n\t\tcase B43legacy_PHYTYPE_B:\n\t\t\thave_bphy = 1;\n\t\t\tbreak;\n\t\tcase B43legacy_PHYTYPE_G:\n\t\t\thave_gphy = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tB43legacy_BUG_ON(1);\n\t\t}\n\t}\n\tdev->phy.gmode = (have_gphy || have_bphy);\n\ttmp = dev->phy.gmode ? B43legacy_TMSLOW_GMODE : 0;\n\tb43legacy_wireless_core_reset(dev, tmp);\n\n\terr = b43legacy_validate_chipaccess(dev);\n\tif (err)\n\t\tgoto err_powerdown;\n\terr = b43legacy_setup_modes(dev, have_bphy, have_gphy);\n\tif (err)\n\t\tgoto err_powerdown;\n\n\t \n\tif (!wl->current_dev)\n\t\twl->current_dev = dev;\n\tINIT_WORK(&dev->restart_work, b43legacy_chip_reset);\n\n\tb43legacy_radio_turn_off(dev, 1);\n\tb43legacy_switch_analog(dev, 0);\n\tssb_device_disable(dev->dev, 0);\n\tssb_bus_may_powerdown(bus);\n\nout:\n\treturn err;\n\nerr_powerdown:\n\tssb_bus_may_powerdown(bus);\n\treturn err;\n}\n\nstatic void b43legacy_one_core_detach(struct ssb_device *dev)\n{\n\tstruct b43legacy_wldev *wldev;\n\tstruct b43legacy_wl *wl;\n\n\t \n\n\twldev = ssb_get_drvdata(dev);\n\twl = wldev->wl;\n\tb43legacy_debugfs_remove_device(wldev);\n\tb43legacy_wireless_core_detach(wldev);\n\tlist_del(&wldev->list);\n\twl->nr_devs--;\n\tssb_set_drvdata(dev, NULL);\n\tkfree(wldev);\n}\n\nstatic int b43legacy_one_core_attach(struct ssb_device *dev,\n\t\t\t\t     struct b43legacy_wl *wl)\n{\n\tstruct b43legacy_wldev *wldev;\n\tint err = -ENOMEM;\n\n\twldev = kzalloc(sizeof(*wldev), GFP_KERNEL);\n\tif (!wldev)\n\t\tgoto out;\n\n\twldev->dev = dev;\n\twldev->wl = wl;\n\tb43legacy_set_status(wldev, B43legacy_STAT_UNINIT);\n\twldev->bad_frames_preempt = modparam_bad_frames_preempt;\n\ttasklet_setup(&wldev->isr_tasklet, b43legacy_interrupt_tasklet);\n\tif (modparam_pio)\n\t\twldev->__using_pio = true;\n\tINIT_LIST_HEAD(&wldev->list);\n\n\terr = b43legacy_wireless_core_attach(wldev);\n\tif (err)\n\t\tgoto err_kfree_wldev;\n\n\tlist_add(&wldev->list, &wl->devlist);\n\twl->nr_devs++;\n\tssb_set_drvdata(dev, wldev);\n\tb43legacy_debugfs_add_device(wldev);\nout:\n\treturn err;\n\nerr_kfree_wldev:\n\tkfree(wldev);\n\treturn err;\n}\n\nstatic void b43legacy_sprom_fixup(struct ssb_bus *bus)\n{\n\t \n\tif (bus->boardinfo.vendor == PCI_VENDOR_ID_APPLE &&\n\t    bus->boardinfo.type == 0x4E &&\n\t    bus->sprom.board_rev > 0x40)\n\t\tbus->sprom.boardflags_lo |= B43legacy_BFL_PACTRL;\n}\n\nstatic void b43legacy_wireless_exit(struct ssb_device *dev,\n\t\t\t\t  struct b43legacy_wl *wl)\n{\n\tstruct ieee80211_hw *hw = wl->hw;\n\n\tssb_set_devtypedata(dev, NULL);\n\tieee80211_free_hw(hw);\n}\n\nstatic int b43legacy_wireless_init(struct ssb_device *dev)\n{\n\tstruct ssb_sprom *sprom = &dev->bus->sprom;\n\tstruct ieee80211_hw *hw;\n\tstruct b43legacy_wl *wl;\n\tint err = -ENOMEM;\n\tint queue_num;\n\n\tb43legacy_sprom_fixup(dev->bus);\n\n\thw = ieee80211_alloc_hw(sizeof(*wl), &b43legacy_hw_ops);\n\tif (!hw) {\n\t\tb43legacyerr(NULL, \"Could not allocate ieee80211 device\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tieee80211_hw_set(hw, RX_INCLUDES_FCS);\n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\tieee80211_hw_set(hw, MFP_CAPABLE);  \n\n\thw->wiphy->interface_modes =\n\t\tBIT(NL80211_IFTYPE_AP) |\n\t\tBIT(NL80211_IFTYPE_STATION) |\n\t\tBIT(NL80211_IFTYPE_ADHOC);\n\thw->queues = 1;  \n\thw->max_rates = 2;\n\tSET_IEEE80211_DEV(hw, dev->dev);\n\tif (is_valid_ether_addr(sprom->et1mac))\n\t\tSET_IEEE80211_PERM_ADDR(hw, sprom->et1mac);\n\telse\n\t\tSET_IEEE80211_PERM_ADDR(hw, sprom->il0mac);\n\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\t \n\twl = hw_to_b43legacy_wl(hw);\n\tmemset(wl, 0, sizeof(*wl));\n\twl->hw = hw;\n\tspin_lock_init(&wl->irq_lock);\n\tspin_lock_init(&wl->leds_lock);\n\tmutex_init(&wl->mutex);\n\tINIT_LIST_HEAD(&wl->devlist);\n\tINIT_WORK(&wl->beacon_update_trigger, b43legacy_beacon_update_trigger_work);\n\tINIT_WORK(&wl->tx_work, b43legacy_tx_work);\n\n\t \n\tfor (queue_num = 0; queue_num < B43legacy_QOS_QUEUE_NUM; queue_num++) {\n\t\tskb_queue_head_init(&wl->tx_queue[queue_num]);\n\t\twl->tx_queue_stopped[queue_num] = 0;\n\t}\n\n\tssb_set_devtypedata(dev, wl);\n\tb43legacyinfo(wl, \"Broadcom %04X WLAN found (core revision %u)\\n\",\n\t\t      dev->bus->chip_id, dev->id.revision);\n\terr = 0;\nout:\n\treturn err;\n}\n\nstatic int b43legacy_probe(struct ssb_device *dev,\n\t\t\t const struct ssb_device_id *id)\n{\n\tstruct b43legacy_wl *wl;\n\tint err;\n\tint first = 0;\n\n\twl = ssb_get_devtypedata(dev);\n\tif (!wl) {\n\t\t \n\t\tfirst = 1;\n\t\terr = b43legacy_wireless_init(dev);\n\t\tif (err)\n\t\t\tgoto out;\n\t\twl = ssb_get_devtypedata(dev);\n\t\tB43legacy_WARN_ON(!wl);\n\t}\n\terr = b43legacy_one_core_attach(dev, wl);\n\tif (err)\n\t\tgoto err_wireless_exit;\n\n\t \n\tINIT_WORK(&wl->firmware_load, b43legacy_request_firmware);\n\tschedule_work(&wl->firmware_load);\n\nout:\n\treturn err;\n\nerr_wireless_exit:\n\tif (first)\n\t\tb43legacy_wireless_exit(dev, wl);\n\treturn err;\n}\n\nstatic void b43legacy_remove(struct ssb_device *dev)\n{\n\tstruct b43legacy_wl *wl = ssb_get_devtypedata(dev);\n\tstruct b43legacy_wldev *wldev = ssb_get_drvdata(dev);\n\n\t \n\tcancel_work_sync(&wldev->restart_work);\n\tcancel_work_sync(&wl->firmware_load);\n\tcomplete(&wldev->fw_load_complete);\n\n\tB43legacy_WARN_ON(!wl);\n\tif (!wldev->fw.ucode)\n\t\treturn;\t\t\t \n\tif (wl->current_dev == wldev)\n\t\tieee80211_unregister_hw(wl->hw);\n\n\tb43legacy_one_core_detach(dev);\n\n\tif (list_empty(&wl->devlist))\n\t\t \n\t\tb43legacy_wireless_exit(dev, wl);\n}\n\n \nvoid b43legacy_controller_restart(struct b43legacy_wldev *dev,\n\t\t\t\t  const char *reason)\n{\n\t \n\tif (b43legacy_status(dev) < B43legacy_STAT_INITIALIZED)\n\t\treturn;\n\tb43legacyinfo(dev->wl, \"Controller RESET (%s) ...\\n\", reason);\n\tieee80211_queue_work(dev->wl->hw, &dev->restart_work);\n}\n\n#ifdef CONFIG_PM\n\nstatic int b43legacy_suspend(struct ssb_device *dev, pm_message_t state)\n{\n\tstruct b43legacy_wldev *wldev = ssb_get_drvdata(dev);\n\tstruct b43legacy_wl *wl = wldev->wl;\n\n\tb43legacydbg(wl, \"Suspending...\\n\");\n\n\tmutex_lock(&wl->mutex);\n\twldev->suspend_init_status = b43legacy_status(wldev);\n\tif (wldev->suspend_init_status >= B43legacy_STAT_STARTED)\n\t\tb43legacy_wireless_core_stop(wldev);\n\tif (wldev->suspend_init_status >= B43legacy_STAT_INITIALIZED)\n\t\tb43legacy_wireless_core_exit(wldev);\n\tmutex_unlock(&wl->mutex);\n\n\tb43legacydbg(wl, \"Device suspended.\\n\");\n\n\treturn 0;\n}\n\nstatic int b43legacy_resume(struct ssb_device *dev)\n{\n\tstruct b43legacy_wldev *wldev = ssb_get_drvdata(dev);\n\tstruct b43legacy_wl *wl = wldev->wl;\n\tint err = 0;\n\n\tb43legacydbg(wl, \"Resuming...\\n\");\n\n\tmutex_lock(&wl->mutex);\n\tif (wldev->suspend_init_status >= B43legacy_STAT_INITIALIZED) {\n\t\terr = b43legacy_wireless_core_init(wldev);\n\t\tif (err) {\n\t\t\tb43legacyerr(wl, \"Resume failed at core init\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (wldev->suspend_init_status >= B43legacy_STAT_STARTED) {\n\t\terr = b43legacy_wireless_core_start(wldev);\n\t\tif (err) {\n\t\t\tb43legacy_wireless_core_exit(wldev);\n\t\t\tb43legacyerr(wl, \"Resume failed at core start\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tb43legacydbg(wl, \"Device resumed.\\n\");\nout:\n\tmutex_unlock(&wl->mutex);\n\treturn err;\n}\n\n#else\t \n# define b43legacy_suspend\tNULL\n# define b43legacy_resume\t\tNULL\n#endif\t \n\nstatic struct ssb_driver b43legacy_ssb_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= b43legacy_ssb_tbl,\n\t.probe\t\t= b43legacy_probe,\n\t.remove\t\t= b43legacy_remove,\n\t.suspend\t= b43legacy_suspend,\n\t.resume\t\t= b43legacy_resume,\n};\n\nstatic void b43legacy_print_driverinfo(void)\n{\n\tconst char *feat_pci = \"\", *feat_leds = \"\",\n\t\t   *feat_pio = \"\", *feat_dma = \"\";\n\n#ifdef CONFIG_B43LEGACY_PCI_AUTOSELECT\n\tfeat_pci = \"P\";\n#endif\n#ifdef CONFIG_B43LEGACY_LEDS\n\tfeat_leds = \"L\";\n#endif\n#ifdef CONFIG_B43LEGACY_PIO\n\tfeat_pio = \"I\";\n#endif\n#ifdef CONFIG_B43LEGACY_DMA\n\tfeat_dma = \"D\";\n#endif\n\tprintk(KERN_INFO \"Broadcom 43xx-legacy driver loaded \"\n\t       \"[ Features: %s%s%s%s ]\\n\",\n\t       feat_pci, feat_leds, feat_pio, feat_dma);\n}\n\nstatic int __init b43legacy_init(void)\n{\n\tint err;\n\n\tb43legacy_debugfs_init();\n\n\terr = ssb_driver_register(&b43legacy_ssb_driver);\n\tif (err)\n\t\tgoto err_dfs_exit;\n\n\tb43legacy_print_driverinfo();\n\n\treturn err;\n\nerr_dfs_exit:\n\tb43legacy_debugfs_exit();\n\treturn err;\n}\n\nstatic void __exit b43legacy_exit(void)\n{\n\tssb_driver_unregister(&b43legacy_ssb_driver);\n\tb43legacy_debugfs_exit();\n}\n\nmodule_init(b43legacy_init)\nmodule_exit(b43legacy_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}