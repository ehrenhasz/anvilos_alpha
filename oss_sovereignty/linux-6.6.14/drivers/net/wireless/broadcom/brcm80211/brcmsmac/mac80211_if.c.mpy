{
  "module_name": "mac80211_if.c",
  "hash_id": "036b1edfb1a22808ee21eaabd65f1869794da40daec74855dfad73fdb5dc17fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmsmac/mac80211_if.c",
  "human_readable_source": " \n\n#define __UNDEF_NO_VERSION__\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/etherdevice.h>\n#include <linux/sched.h>\n#include <linux/firmware.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/bcma/bcma.h>\n#include <net/mac80211.h>\n#include <defs.h>\n#include \"phy/phy_int.h\"\n#include \"d11.h\"\n#include \"channel.h\"\n#include \"scb.h\"\n#include \"pub.h\"\n#include \"ucode_loader.h\"\n#include \"mac80211_if.h\"\n#include \"main.h\"\n#include \"debug.h\"\n#include \"led.h\"\n\n#define N_TX_QUEUES\t4  \n#define BRCMS_FLUSH_TIMEOUT\t500  \n\n \n#define MAC_FILTERS (FIF_ALLMULTI | \\\n\tFIF_FCSFAIL | \\\n\tFIF_CONTROL | \\\n\tFIF_OTHER_BSS | \\\n\tFIF_BCN_PRBRESP_PROMISC | \\\n\tFIF_PSPOLL)\n\n#define CHAN2GHZ(channel, freqency, chflags)  { \\\n\t.band = NL80211_BAND_2GHZ, \\\n\t.center_freq = (freqency), \\\n\t.hw_value = (channel), \\\n\t.flags = chflags, \\\n\t.max_antenna_gain = 0, \\\n\t.max_power = 19, \\\n}\n\n#define CHAN5GHZ(channel, chflags)  { \\\n\t.band = NL80211_BAND_5GHZ, \\\n\t.center_freq = 5000 + 5*(channel), \\\n\t.hw_value = (channel), \\\n\t.flags = chflags, \\\n\t.max_antenna_gain = 0, \\\n\t.max_power = 21, \\\n}\n\n#define RATE(rate100m, _flags) { \\\n\t.bitrate = (rate100m), \\\n\t.flags = (_flags), \\\n\t.hw_value = (rate100m / 5), \\\n}\n\nstruct firmware_hdr {\n\t__le32 offset;\n\t__le32 len;\n\t__le32 idx;\n};\n\nstatic const char * const brcms_firmwares[MAX_FW_IMAGES] = {\n\t\"brcm/bcm43xx\",\n\tNULL\n};\n\nstatic int n_adapters_found;\n\nMODULE_AUTHOR(\"Broadcom Corporation\");\nMODULE_DESCRIPTION(\"Broadcom 802.11n wireless LAN driver.\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n \nMODULE_FIRMWARE(\"brcm/bcm43xx-0.fw\");\nMODULE_FIRMWARE(\"brcm/bcm43xx_hdr-0.fw\");\n\n \nstatic struct bcma_device_id brcms_coreid_table[] = {\n\tBCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_80211, 17, BCMA_ANY_CLASS),\n\tBCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_80211, 23, BCMA_ANY_CLASS),\n\tBCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_80211, 24, BCMA_ANY_CLASS),\n\t{},\n};\nMODULE_DEVICE_TABLE(bcma, brcms_coreid_table);\n\n#if defined(CONFIG_BRCMDBG)\n \nmodule_param_named(debug, brcm_msg_level, uint, 0644);\n#endif\n\nstatic struct ieee80211_channel brcms_2ghz_chantable[] = {\n\tCHAN2GHZ(1, 2412, IEEE80211_CHAN_NO_HT40MINUS),\n\tCHAN2GHZ(2, 2417, IEEE80211_CHAN_NO_HT40MINUS),\n\tCHAN2GHZ(3, 2422, IEEE80211_CHAN_NO_HT40MINUS),\n\tCHAN2GHZ(4, 2427, IEEE80211_CHAN_NO_HT40MINUS),\n\tCHAN2GHZ(5, 2432, 0),\n\tCHAN2GHZ(6, 2437, 0),\n\tCHAN2GHZ(7, 2442, 0),\n\tCHAN2GHZ(8, 2447, IEEE80211_CHAN_NO_HT40PLUS),\n\tCHAN2GHZ(9, 2452, IEEE80211_CHAN_NO_HT40PLUS),\n\tCHAN2GHZ(10, 2457, IEEE80211_CHAN_NO_HT40PLUS),\n\tCHAN2GHZ(11, 2462, IEEE80211_CHAN_NO_HT40PLUS),\n\tCHAN2GHZ(12, 2467,\n\t\t IEEE80211_CHAN_NO_IR |\n\t\t IEEE80211_CHAN_NO_HT40PLUS),\n\tCHAN2GHZ(13, 2472,\n\t\t IEEE80211_CHAN_NO_IR |\n\t\t IEEE80211_CHAN_NO_HT40PLUS),\n\tCHAN2GHZ(14, 2484,\n\t\t IEEE80211_CHAN_NO_IR |\n\t\t IEEE80211_CHAN_NO_HT40PLUS | IEEE80211_CHAN_NO_HT40MINUS |\n\t\t IEEE80211_CHAN_NO_OFDM)\n};\n\nstatic struct ieee80211_channel brcms_5ghz_nphy_chantable[] = {\n\t \n\tCHAN5GHZ(36, IEEE80211_CHAN_NO_HT40MINUS),\n\tCHAN5GHZ(40, IEEE80211_CHAN_NO_HT40PLUS),\n\tCHAN5GHZ(44, IEEE80211_CHAN_NO_HT40MINUS),\n\tCHAN5GHZ(48, IEEE80211_CHAN_NO_HT40PLUS),\n\t \n\tCHAN5GHZ(52,\n\t\t IEEE80211_CHAN_RADAR |\n\t\t IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_NO_HT40MINUS),\n\tCHAN5GHZ(56,\n\t\t IEEE80211_CHAN_RADAR |\n\t\t IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_NO_HT40PLUS),\n\tCHAN5GHZ(60,\n\t\t IEEE80211_CHAN_RADAR |\n\t\t IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_NO_HT40MINUS),\n\tCHAN5GHZ(64,\n\t\t IEEE80211_CHAN_RADAR |\n\t\t IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_NO_HT40PLUS),\n\t \n\tCHAN5GHZ(100,\n\t\t IEEE80211_CHAN_RADAR |\n\t\t IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_NO_HT40MINUS),\n\tCHAN5GHZ(104,\n\t\t IEEE80211_CHAN_RADAR |\n\t\t IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_NO_HT40PLUS),\n\tCHAN5GHZ(108,\n\t\t IEEE80211_CHAN_RADAR |\n\t\t IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_NO_HT40MINUS),\n\tCHAN5GHZ(112,\n\t\t IEEE80211_CHAN_RADAR |\n\t\t IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_NO_HT40PLUS),\n\tCHAN5GHZ(116,\n\t\t IEEE80211_CHAN_RADAR |\n\t\t IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_NO_HT40MINUS),\n\tCHAN5GHZ(120,\n\t\t IEEE80211_CHAN_RADAR |\n\t\t IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_NO_HT40PLUS),\n\tCHAN5GHZ(124,\n\t\t IEEE80211_CHAN_RADAR |\n\t\t IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_NO_HT40MINUS),\n\tCHAN5GHZ(128,\n\t\t IEEE80211_CHAN_RADAR |\n\t\t IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_NO_HT40PLUS),\n\tCHAN5GHZ(132,\n\t\t IEEE80211_CHAN_RADAR |\n\t\t IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_NO_HT40MINUS),\n\tCHAN5GHZ(136,\n\t\t IEEE80211_CHAN_RADAR |\n\t\t IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_NO_HT40PLUS),\n\tCHAN5GHZ(140,\n\t\t IEEE80211_CHAN_RADAR |\n\t\t IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_NO_HT40PLUS |\n\t\t IEEE80211_CHAN_NO_HT40MINUS),\n\t \n\tCHAN5GHZ(149, IEEE80211_CHAN_NO_HT40MINUS),\n\tCHAN5GHZ(153, IEEE80211_CHAN_NO_HT40PLUS),\n\tCHAN5GHZ(157, IEEE80211_CHAN_NO_HT40MINUS),\n\tCHAN5GHZ(161, IEEE80211_CHAN_NO_HT40PLUS),\n\tCHAN5GHZ(165, IEEE80211_CHAN_NO_HT40PLUS | IEEE80211_CHAN_NO_HT40MINUS)\n};\n\n \nstatic struct ieee80211_rate legacy_ratetable[] = {\n\tRATE(10, 0),\n\tRATE(20, IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATE(55, IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATE(110, IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATE(60, 0),\n\tRATE(90, 0),\n\tRATE(120, 0),\n\tRATE(180, 0),\n\tRATE(240, 0),\n\tRATE(360, 0),\n\tRATE(480, 0),\n\tRATE(540, 0),\n};\n\nstatic const struct ieee80211_supported_band brcms_band_2GHz_nphy_template = {\n\t.band = NL80211_BAND_2GHZ,\n\t.channels = brcms_2ghz_chantable,\n\t.n_channels = ARRAY_SIZE(brcms_2ghz_chantable),\n\t.bitrates = legacy_ratetable,\n\t.n_bitrates = ARRAY_SIZE(legacy_ratetable),\n\t.ht_cap = {\n\t\t    \n\t\t   .cap = IEEE80211_HT_CAP_GRN_FLD |\n\t\t\t  IEEE80211_HT_CAP_SGI_20 | IEEE80211_HT_CAP_SGI_40,\n\t\t   .ht_supported = true,\n\t\t   .ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K,\n\t\t   .ampdu_density = AMPDU_DEF_MPDU_DENSITY,\n\t\t   .mcs = {\n\t\t\t    \n\t\t\t   .rx_mask = {0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0},\n\t\t\t   .rx_highest = cpu_to_le16(500),\n\t\t\t   .tx_params = IEEE80211_HT_MCS_TX_DEFINED}\n\t\t   }\n};\n\nstatic const struct ieee80211_supported_band brcms_band_5GHz_nphy_template = {\n\t.band = NL80211_BAND_5GHZ,\n\t.channels = brcms_5ghz_nphy_chantable,\n\t.n_channels = ARRAY_SIZE(brcms_5ghz_nphy_chantable),\n\t.bitrates = legacy_ratetable + BRCMS_LEGACY_5G_RATE_OFFSET,\n\t.n_bitrates = ARRAY_SIZE(legacy_ratetable) -\n\t\t\tBRCMS_LEGACY_5G_RATE_OFFSET,\n\t.ht_cap = {\n\t\t   .cap = IEEE80211_HT_CAP_GRN_FLD | IEEE80211_HT_CAP_SGI_20 |\n\t\t\t  IEEE80211_HT_CAP_SGI_40,\n\t\t   .ht_supported = true,\n\t\t   .ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K,\n\t\t   .ampdu_density = AMPDU_DEF_MPDU_DENSITY,\n\t\t   .mcs = {\n\t\t\t    \n\t\t\t   .rx_mask = {0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0},\n\t\t\t   .rx_highest = cpu_to_le16(500),\n\t\t\t   .tx_params = IEEE80211_HT_MCS_TX_DEFINED}\n\t\t   }\n};\n\n \nstatic void brcms_set_basic_rate(struct brcm_rateset *rs, u16 rate, bool is_br)\n{\n\tu32 i;\n\n\tfor (i = 0; i < rs->count; i++) {\n\t\tif (rate != (rs->rates[i] & 0x7f))\n\t\t\tcontinue;\n\n\t\tif (is_br)\n\t\t\trs->rates[i] |= BRCMS_RATE_FLAG;\n\t\telse\n\t\t\trs->rates[i] &= BRCMS_RATE_MASK;\n\t\treturn;\n\t}\n}\n\n \nstatic void brcms_free(struct brcms_info *wl)\n{\n\tstruct brcms_timer *t, *next;\n\n\t \n\tif (wl->fw.fw_cnt)\n\t\tbrcms_ucode_data_free(&wl->ucode);\n\tif (wl->irq)\n\t\tfree_irq(wl->irq, wl);\n\n\t \n\ttasklet_kill(&wl->tasklet);\n\n\tif (wl->pub) {\n\t\tbrcms_debugfs_detach(wl->pub);\n\t\tbrcms_c_module_unregister(wl->pub, \"linux\", wl);\n\t}\n\n\t \n\tif (wl->wlc) {\n\t\tbrcms_c_detach(wl->wlc);\n\t\twl->wlc = NULL;\n\t\twl->pub = NULL;\n\t}\n\n\t \n\n\t \n\twhile (atomic_read(&wl->callbacks) > 0)\n\t\tschedule();\n\n\t \n\tfor (t = wl->timers; t; t = next) {\n\t\tnext = t->next;\n#ifdef DEBUG\n\t\tkfree(t->name);\n#endif\n\t\tkfree(t);\n\t}\n}\n\n \nstatic void brcms_remove(struct bcma_device *pdev)\n{\n\tstruct ieee80211_hw *hw = bcma_get_drvdata(pdev);\n\tstruct brcms_info *wl = hw->priv;\n\n\tif (wl->wlc) {\n\t\tbrcms_led_unregister(wl);\n\t\twiphy_rfkill_set_hw_state(wl->pub->ieee_hw->wiphy, false);\n\t\twiphy_rfkill_stop_polling(wl->pub->ieee_hw->wiphy);\n\t\tieee80211_unregister_hw(hw);\n\t}\n\n\tbrcms_free(wl);\n\n\tbcma_set_drvdata(pdev, NULL);\n\tieee80211_free_hw(hw);\n}\n\n \nstatic void brcms_release_fw(struct brcms_info *wl)\n{\n\tint i;\n\tfor (i = 0; i < MAX_FW_IMAGES; i++) {\n\t\trelease_firmware(wl->fw.fw_bin[i]);\n\t\trelease_firmware(wl->fw.fw_hdr[i]);\n\t}\n}\n\n \nstatic int brcms_request_fw(struct brcms_info *wl, struct bcma_device *pdev)\n{\n\tint status;\n\tstruct device *device = &pdev->dev;\n\tchar fw_name[100];\n\tint i;\n\n\tmemset(&wl->fw, 0, sizeof(struct brcms_firmware));\n\tfor (i = 0; i < MAX_FW_IMAGES; i++) {\n\t\tif (brcms_firmwares[i] == NULL)\n\t\t\tbreak;\n\t\tsprintf(fw_name, \"%s-%d.fw\", brcms_firmwares[i],\n\t\t\tUCODE_LOADER_API_VER);\n\t\tstatus = request_firmware(&wl->fw.fw_bin[i], fw_name, device);\n\t\tif (status) {\n\t\t\twiphy_err(wl->wiphy, \"%s: fail to load firmware %s\\n\",\n\t\t\t\t  KBUILD_MODNAME, fw_name);\n\t\t\treturn status;\n\t\t}\n\t\tsprintf(fw_name, \"%s_hdr-%d.fw\", brcms_firmwares[i],\n\t\t\tUCODE_LOADER_API_VER);\n\t\tstatus = request_firmware(&wl->fw.fw_hdr[i], fw_name, device);\n\t\tif (status) {\n\t\t\twiphy_err(wl->wiphy, \"%s: fail to load firmware %s\\n\",\n\t\t\t\t  KBUILD_MODNAME, fw_name);\n\t\t\treturn status;\n\t\t}\n\t\twl->fw.hdr_num_entries[i] =\n\t\t    wl->fw.fw_hdr[i]->size / (sizeof(struct firmware_hdr));\n\t}\n\twl->fw.fw_cnt = i;\n\tstatus = brcms_ucode_data_init(wl, &wl->ucode);\n\tbrcms_release_fw(wl);\n\treturn status;\n}\n\nstatic void brcms_ops_tx(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_tx_control *control,\n\t\t\t struct sk_buff *skb)\n{\n\tstruct brcms_info *wl = hw->priv;\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\n\tspin_lock_bh(&wl->lock);\n\tif (!wl->pub->up) {\n\t\tbrcms_err(wl->wlc->hw->d11core, \"ops->tx called while down\\n\");\n\t\tkfree_skb(skb);\n\t\tgoto done;\n\t}\n\tif (brcms_c_sendpkt_mac80211(wl->wlc, skb, hw))\n\t\ttx_info->rate_driver_data[0] = control->sta;\n done:\n\tspin_unlock_bh(&wl->lock);\n}\n\nstatic int brcms_ops_start(struct ieee80211_hw *hw)\n{\n\tstruct brcms_info *wl = hw->priv;\n\tbool blocked;\n\tint err;\n\n\tif (!wl->ucode.bcm43xx_bomminor) {\n\t\terr = brcms_request_fw(wl, wl->wlc->hw->d11core);\n\t\tif (err)\n\t\t\treturn -ENOENT;\n\t}\n\n\tieee80211_wake_queues(hw);\n\tspin_lock_bh(&wl->lock);\n\tblocked = brcms_rfkill_set_hw_state(wl);\n\tspin_unlock_bh(&wl->lock);\n\tif (!blocked)\n\t\twiphy_rfkill_stop_polling(wl->pub->ieee_hw->wiphy);\n\n\tspin_lock_bh(&wl->lock);\n\t \n\twl->mute_tx = true;\n\n\tif (!wl->pub->up)\n\t\tif (!blocked)\n\t\t\terr = brcms_up(wl);\n\t\telse\n\t\t\terr = -ERFKILL;\n\telse\n\t\terr = -ENODEV;\n\tspin_unlock_bh(&wl->lock);\n\n\tif (err != 0)\n\t\tbrcms_err(wl->wlc->hw->d11core, \"%s: brcms_up() returned %d\\n\",\n\t\t\t  __func__, err);\n\n\tbcma_core_pci_power_save(wl->wlc->hw->d11core->bus, true);\n\treturn err;\n}\n\nstatic void brcms_ops_stop(struct ieee80211_hw *hw)\n{\n\tstruct brcms_info *wl = hw->priv;\n\tint status;\n\n\tieee80211_stop_queues(hw);\n\n\tif (wl->wlc == NULL)\n\t\treturn;\n\n\tspin_lock_bh(&wl->lock);\n\tstatus = brcms_c_chipmatch(wl->wlc->hw->d11core);\n\tspin_unlock_bh(&wl->lock);\n\tif (!status) {\n\t\tbrcms_err(wl->wlc->hw->d11core,\n\t\t\t  \"wl: brcms_ops_stop: chipmatch failed\\n\");\n\t\treturn;\n\t}\n\n\tbcma_core_pci_power_save(wl->wlc->hw->d11core->bus, false);\n\n\t \n\tspin_lock_bh(&wl->lock);\n\tbrcms_down(wl);\n\tspin_unlock_bh(&wl->lock);\n}\n\nstatic int\nbrcms_ops_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct brcms_info *wl = hw->priv;\n\n\t \n\tif (vif->type != NL80211_IFTYPE_STATION &&\n\t    vif->type != NL80211_IFTYPE_AP &&\n\t    vif->type != NL80211_IFTYPE_ADHOC) {\n\t\tbrcms_err(wl->wlc->hw->d11core,\n\t\t\t  \"%s: Attempt to add type %d, only STA, AP and AdHoc for now\\n\",\n\t\t\t  __func__, vif->type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tspin_lock_bh(&wl->lock);\n\twl->wlc->vif = vif;\n\twl->mute_tx = false;\n\tbrcms_c_mute(wl->wlc, false);\n\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\tbrcms_c_start_station(wl->wlc, vif->addr);\n\telse if (vif->type == NL80211_IFTYPE_AP)\n\t\tbrcms_c_start_ap(wl->wlc, vif->addr, vif->bss_conf.bssid,\n\t\t\t\t vif->cfg.ssid, vif->cfg.ssid_len);\n\telse if (vif->type == NL80211_IFTYPE_ADHOC)\n\t\tbrcms_c_start_adhoc(wl->wlc, vif->addr);\n\tspin_unlock_bh(&wl->lock);\n\n\treturn 0;\n}\n\nstatic void\nbrcms_ops_remove_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct brcms_info *wl = hw->priv;\n\n\tspin_lock_bh(&wl->lock);\n\twl->wlc->vif = NULL;\n\tspin_unlock_bh(&wl->lock);\n}\n\nstatic int brcms_ops_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tstruct brcms_info *wl = hw->priv;\n\tstruct bcma_device *core = wl->wlc->hw->d11core;\n\tint err = 0;\n\tint new_int;\n\n\tspin_lock_bh(&wl->lock);\n\tif (changed & IEEE80211_CONF_CHANGE_LISTEN_INTERVAL) {\n\t\tbrcms_c_set_beacon_listen_interval(wl->wlc,\n\t\t\t\t\t\t   conf->listen_interval);\n\t}\n\tif (changed & IEEE80211_CONF_CHANGE_MONITOR)\n\t\tbrcms_dbg_info(core, \"%s: change monitor mode: %s\\n\",\n\t\t\t       __func__, conf->flags & IEEE80211_CONF_MONITOR ?\n\t\t\t       \"true\" : \"false\");\n\tif (changed & IEEE80211_CONF_CHANGE_PS)\n\t\tbrcms_err(core, \"%s: change power-save mode: %s (implement)\\n\",\n\t\t\t  __func__, conf->flags & IEEE80211_CONF_PS ?\n\t\t\t  \"true\" : \"false\");\n\n\tif (changed & IEEE80211_CONF_CHANGE_POWER) {\n\t\terr = brcms_c_set_tx_power(wl->wlc, conf->power_level);\n\t\tif (err < 0) {\n\t\t\tbrcms_err(core, \"%s: Error setting power_level\\n\",\n\t\t\t\t  __func__);\n\t\t\tgoto config_out;\n\t\t}\n\t\tnew_int = brcms_c_get_tx_power(wl->wlc);\n\t\tif (new_int != conf->power_level)\n\t\t\tbrcms_err(core,\n\t\t\t\t  \"%s: Power level req != actual, %d %d\\n\",\n\t\t\t\t  __func__, conf->power_level,\n\t\t\t\t  new_int);\n\t}\n\tif (changed & IEEE80211_CONF_CHANGE_CHANNEL) {\n\t\tif (conf->chandef.width == NL80211_CHAN_WIDTH_20 ||\n\t\t    conf->chandef.width == NL80211_CHAN_WIDTH_20_NOHT)\n\t\t\terr = brcms_c_set_channel(wl->wlc,\n\t\t\t\t\t\t  conf->chandef.chan->hw_value);\n\t\telse\n\t\t\terr = -ENOTSUPP;\n\t}\n\tif (changed & IEEE80211_CONF_CHANGE_RETRY_LIMITS)\n\t\terr = brcms_c_set_rate_limit(wl->wlc,\n\t\t\t\t\t     conf->short_frame_max_tx_count,\n\t\t\t\t\t     conf->long_frame_max_tx_count);\n\n config_out:\n\tspin_unlock_bh(&wl->lock);\n\treturn err;\n}\n\nstatic void\nbrcms_ops_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\tstruct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_bss_conf *info, u64 changed)\n{\n\tstruct brcms_info *wl = hw->priv;\n\tstruct bcma_device *core = wl->wlc->hw->d11core;\n\n\tif (changed & BSS_CHANGED_ASSOC) {\n\t\t \n\t\tbrcms_err(core, \"%s: %s: %sassociated\\n\", KBUILD_MODNAME,\n\t\t\t  __func__, vif->cfg.assoc ? \"\" : \"dis\");\n\t\tspin_lock_bh(&wl->lock);\n\t\tbrcms_c_associate_upd(wl->wlc, vif->cfg.assoc);\n\t\tspin_unlock_bh(&wl->lock);\n\t}\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\ts8 val;\n\n\t\t \n\t\tif (info->use_short_slot)\n\t\t\tval = 1;\n\t\telse\n\t\t\tval = 0;\n\t\tspin_lock_bh(&wl->lock);\n\t\tbrcms_c_set_shortslot_override(wl->wlc, val);\n\t\tspin_unlock_bh(&wl->lock);\n\t}\n\n\tif (changed & BSS_CHANGED_HT) {\n\t\t \n\t\tu16 mode = info->ht_operation_mode;\n\n\t\tspin_lock_bh(&wl->lock);\n\t\tbrcms_c_protection_upd(wl->wlc, BRCMS_PROT_N_CFG,\n\t\t\tmode & IEEE80211_HT_OP_MODE_PROTECTION);\n\t\tbrcms_c_protection_upd(wl->wlc, BRCMS_PROT_N_NONGF,\n\t\t\tmode & IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\n\t\tbrcms_c_protection_upd(wl->wlc, BRCMS_PROT_N_OBSS,\n\t\t\tmode & IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT);\n\t\tspin_unlock_bh(&wl->lock);\n\t}\n\tif (changed & BSS_CHANGED_BASIC_RATES) {\n\t\tstruct ieee80211_supported_band *bi;\n\t\tu32 br_mask, i;\n\t\tu16 rate;\n\t\tstruct brcm_rateset rs;\n\t\tint error;\n\n\t\t \n\t\tspin_lock_bh(&wl->lock);\n\t\tbrcms_c_get_current_rateset(wl->wlc, &rs);\n\t\tspin_unlock_bh(&wl->lock);\n\n\t\tbr_mask = info->basic_rates;\n\t\tbi = hw->wiphy->bands[brcms_c_get_curband(wl->wlc)];\n\t\tfor (i = 0; i < bi->n_bitrates; i++) {\n\t\t\t \n\t\t\trate = (bi->bitrates[i].bitrate << 1) / 10;\n\n\t\t\t \n\t\t\tbrcms_set_basic_rate(&rs, rate, br_mask & 1);\n\t\t\tbr_mask >>= 1;\n\t\t}\n\n\t\t \n\t\tspin_lock_bh(&wl->lock);\n\t\terror = brcms_c_set_rateset(wl->wlc, &rs);\n\t\tspin_unlock_bh(&wl->lock);\n\t\tif (error)\n\t\t\tbrcms_err(core, \"changing basic rates failed: %d\\n\",\n\t\t\t\t  error);\n\t}\n\tif (changed & BSS_CHANGED_BEACON_INT) {\n\t\t \n\t\tspin_lock_bh(&wl->lock);\n\t\tbrcms_c_set_beacon_period(wl->wlc, info->beacon_int);\n\t\tspin_unlock_bh(&wl->lock);\n\t}\n\tif (changed & BSS_CHANGED_BSSID) {\n\t\t \n\t\tspin_lock_bh(&wl->lock);\n\t\tbrcms_c_set_addrmatch(wl->wlc, RCM_BSSID_OFFSET, info->bssid);\n\t\tspin_unlock_bh(&wl->lock);\n\t}\n\tif (changed & BSS_CHANGED_SSID) {\n\t\t \n\t\tspin_lock_bh(&wl->lock);\n\t\tbrcms_c_set_ssid(wl->wlc, vif->cfg.ssid, vif->cfg.ssid_len);\n\t\tspin_unlock_bh(&wl->lock);\n\t}\n\tif (changed & BSS_CHANGED_BEACON) {\n\t\t \n\t\tstruct sk_buff *beacon;\n\t\tu16 tim_offset = 0;\n\n\t\tspin_lock_bh(&wl->lock);\n\t\tbeacon = ieee80211_beacon_get_tim(hw, vif, &tim_offset, NULL, 0);\n\t\tbrcms_c_set_new_beacon(wl->wlc, beacon, tim_offset,\n\t\t\t\t       info->dtim_period);\n\t\tspin_unlock_bh(&wl->lock);\n\t}\n\n\tif (changed & BSS_CHANGED_AP_PROBE_RESP) {\n\t\tstruct sk_buff *probe_resp;\n\n\t\tspin_lock_bh(&wl->lock);\n\t\tprobe_resp = ieee80211_proberesp_get(hw, vif);\n\t\tbrcms_c_set_new_probe_resp(wl->wlc, probe_resp);\n\t\tspin_unlock_bh(&wl->lock);\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON_ENABLED) {\n\t\t \n\t\tbrcms_err(core, \"%s: Beacon enabled: %s\\n\", __func__,\n\t\t\t  info->enable_beacon ? \"true\" : \"false\");\n\t\tif (info->enable_beacon &&\n\t\t    hw->wiphy->flags & WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD) {\n\t\t\tbrcms_c_enable_probe_resp(wl->wlc, true);\n\t\t} else {\n\t\t\tbrcms_c_enable_probe_resp(wl->wlc, false);\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_CQM) {\n\t\t \n\t\tbrcms_err(core, \"%s: cqm change: threshold %d, hys %d \"\n\t\t\t  \" (implement)\\n\", __func__, info->cqm_rssi_thold,\n\t\t\t  info->cqm_rssi_hyst);\n\t}\n\n\tif (changed & BSS_CHANGED_IBSS) {\n\t\t \n\t\tbrcms_err(core, \"%s: IBSS joined: %s (implement)\\n\",\n\t\t\t  __func__, vif->cfg.ibss_joined ? \"true\" : \"false\");\n\t}\n\n\tif (changed & BSS_CHANGED_ARP_FILTER) {\n\t\t \n\t\tbrcms_err(core, \"%s: arp filtering: %d addresses\"\n\t\t\t  \" (implement)\\n\", __func__, vif->cfg.arp_addr_cnt);\n\t}\n\n\tif (changed & BSS_CHANGED_QOS) {\n\t\t \n\t\tbrcms_err(core, \"%s: qos enabled: %s (implement)\\n\",\n\t\t\t  __func__, info->qos ? \"true\" : \"false\");\n\t}\n\treturn;\n}\n\nstatic void\nbrcms_ops_configure_filter(struct ieee80211_hw *hw,\n\t\t\tunsigned int changed_flags,\n\t\t\tunsigned int *total_flags, u64 multicast)\n{\n\tstruct brcms_info *wl = hw->priv;\n\tstruct bcma_device *core = wl->wlc->hw->d11core;\n\n\tchanged_flags &= MAC_FILTERS;\n\t*total_flags &= MAC_FILTERS;\n\n\tif (changed_flags & FIF_ALLMULTI)\n\t\tbrcms_dbg_info(core, \"FIF_ALLMULTI\\n\");\n\tif (changed_flags & FIF_FCSFAIL)\n\t\tbrcms_dbg_info(core, \"FIF_FCSFAIL\\n\");\n\tif (changed_flags & FIF_CONTROL)\n\t\tbrcms_dbg_info(core, \"FIF_CONTROL\\n\");\n\tif (changed_flags & FIF_OTHER_BSS)\n\t\tbrcms_dbg_info(core, \"FIF_OTHER_BSS\\n\");\n\tif (changed_flags & FIF_PSPOLL)\n\t\tbrcms_dbg_info(core, \"FIF_PSPOLL\\n\");\n\tif (changed_flags & FIF_BCN_PRBRESP_PROMISC)\n\t\tbrcms_dbg_info(core, \"FIF_BCN_PRBRESP_PROMISC\\n\");\n\n\tspin_lock_bh(&wl->lock);\n\tbrcms_c_mac_promisc(wl->wlc, *total_flags);\n\tspin_unlock_bh(&wl->lock);\n\treturn;\n}\n\nstatic void brcms_ops_sw_scan_start(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    const u8 *mac_addr)\n{\n\tstruct brcms_info *wl = hw->priv;\n\tspin_lock_bh(&wl->lock);\n\tbrcms_c_scan_start(wl->wlc);\n\tspin_unlock_bh(&wl->lock);\n\treturn;\n}\n\nstatic void brcms_ops_sw_scan_complete(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tstruct brcms_info *wl = hw->priv;\n\tspin_lock_bh(&wl->lock);\n\tbrcms_c_scan_stop(wl->wlc);\n\tspin_unlock_bh(&wl->lock);\n\treturn;\n}\n\nstatic int\nbrcms_ops_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t  unsigned int link_id, u16 queue,\n\t\t  const struct ieee80211_tx_queue_params *params)\n{\n\tstruct brcms_info *wl = hw->priv;\n\n\tspin_lock_bh(&wl->lock);\n\tbrcms_c_wme_setparams(wl->wlc, queue, params, true);\n\tspin_unlock_bh(&wl->lock);\n\n\treturn 0;\n}\n\nstatic int\nbrcms_ops_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t       struct ieee80211_sta *sta)\n{\n\tstruct brcms_info *wl = hw->priv;\n\tstruct scb *scb = &wl->wlc->pri_scb;\n\n\tbrcms_c_init_scb(scb);\n\n\twl->pub->global_ampdu = &(scb->scb_ampdu);\n\twl->pub->global_ampdu->max_pdu = 16;\n\n\t \n\treturn 0;\n}\n\nstatic int\nbrcms_ops_ampdu_action(struct ieee80211_hw *hw,\n\t\t    struct ieee80211_vif *vif,\n\t\t    struct ieee80211_ampdu_params *params)\n{\n\tstruct brcms_info *wl = hw->priv;\n\tstruct scb *scb = &wl->wlc->pri_scb;\n\tint status;\n\tstruct ieee80211_sta *sta = params->sta;\n\tenum ieee80211_ampdu_mlme_action action = params->action;\n\tu16 tid = params->tid;\n\n\tif (WARN_ON(scb->magic != SCB_MAGIC))\n\t\treturn -EIDRM;\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_RX_START:\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_START:\n\t\tspin_lock_bh(&wl->lock);\n\t\tstatus = brcms_c_aggregatable(wl->wlc, tid);\n\t\tspin_unlock_bh(&wl->lock);\n\t\tif (!status) {\n\t\t\tbrcms_dbg_ht(wl->wlc->hw->d11core,\n\t\t\t\t     \"START: tid %d is not agg\\'able\\n\", tid);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn IEEE80211_AMPDU_TX_START_IMMEDIATE;\n\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\t\tspin_lock_bh(&wl->lock);\n\t\tbrcms_c_ampdu_flush(wl->wlc, sta, tid);\n\t\tspin_unlock_bh(&wl->lock);\n\t\tieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\t \n\t\tspin_lock_bh(&wl->lock);\n\t\tbrcms_c_ampdu_tx_operational(wl->wlc, tid,\n\t\t\t(1 << (IEEE80211_HT_MAX_AMPDU_FACTOR +\n\t\t\t sta->deflink.ht_cap.ampdu_factor)) - 1);\n\t\tspin_unlock_bh(&wl->lock);\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tbrcms_err(wl->wlc->hw->d11core,\n\t\t\t  \"%s: Invalid command, ignoring\\n\", __func__);\n\t}\n\n\treturn 0;\n}\n\nstatic void brcms_ops_rfkill_poll(struct ieee80211_hw *hw)\n{\n\tstruct brcms_info *wl = hw->priv;\n\tbool blocked;\n\n\tspin_lock_bh(&wl->lock);\n\tblocked = brcms_c_check_radio_disabled(wl->wlc);\n\tspin_unlock_bh(&wl->lock);\n\n\twiphy_rfkill_set_hw_state(wl->pub->ieee_hw->wiphy, blocked);\n}\n\nstatic bool brcms_tx_flush_completed(struct brcms_info *wl)\n{\n\tbool result;\n\n\tspin_lock_bh(&wl->lock);\n\tresult = brcms_c_tx_flush_completed(wl->wlc);\n\tspin_unlock_bh(&wl->lock);\n\treturn result;\n}\n\nstatic void brcms_ops_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t    u32 queues, bool drop)\n{\n\tstruct brcms_info *wl = hw->priv;\n\tint ret;\n\n\tno_printk(\"%s: drop = %s\\n\", __func__, drop ? \"true\" : \"false\");\n\n\tret = wait_event_timeout(wl->tx_flush_wq,\n\t\t\t\t brcms_tx_flush_completed(wl),\n\t\t\t\t msecs_to_jiffies(BRCMS_FLUSH_TIMEOUT));\n\n\tbrcms_dbg_mac80211(wl->wlc->hw->d11core,\n\t\t\t   \"ret=%d\\n\", jiffies_to_msecs(ret));\n}\n\nstatic u64 brcms_ops_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct brcms_info *wl = hw->priv;\n\tu64 tsf;\n\n\tspin_lock_bh(&wl->lock);\n\ttsf = brcms_c_tsf_get(wl->wlc);\n\tspin_unlock_bh(&wl->lock);\n\n\treturn tsf;\n}\n\nstatic void brcms_ops_set_tsf(struct ieee80211_hw *hw,\n\t\t\t   struct ieee80211_vif *vif, u64 tsf)\n{\n\tstruct brcms_info *wl = hw->priv;\n\n\tspin_lock_bh(&wl->lock);\n\tbrcms_c_tsf_set(wl->wlc, tsf);\n\tspin_unlock_bh(&wl->lock);\n}\n\nstatic int brcms_ops_beacon_set_tim(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_sta *sta, bool set)\n{\n\tstruct brcms_info *wl = hw->priv;\n\tstruct sk_buff *beacon = NULL;\n\tu16 tim_offset = 0;\n\n\tspin_lock_bh(&wl->lock);\n\tif (wl->wlc->vif)\n\t\tbeacon = ieee80211_beacon_get_tim(hw, wl->wlc->vif,\n\t\t\t\t\t\t  &tim_offset, NULL, 0);\n\tif (beacon)\n\t\tbrcms_c_set_new_beacon(wl->wlc, beacon, tim_offset,\n\t\t\t\t       wl->wlc->vif->bss_conf.dtim_period);\n\tspin_unlock_bh(&wl->lock);\n\n\treturn 0;\n}\n\nstatic const struct ieee80211_ops brcms_ops = {\n\t.tx = brcms_ops_tx,\n\t.wake_tx_queue = ieee80211_handle_wake_tx_queue,\n\t.start = brcms_ops_start,\n\t.stop = brcms_ops_stop,\n\t.add_interface = brcms_ops_add_interface,\n\t.remove_interface = brcms_ops_remove_interface,\n\t.config = brcms_ops_config,\n\t.bss_info_changed = brcms_ops_bss_info_changed,\n\t.configure_filter = brcms_ops_configure_filter,\n\t.sw_scan_start = brcms_ops_sw_scan_start,\n\t.sw_scan_complete = brcms_ops_sw_scan_complete,\n\t.conf_tx = brcms_ops_conf_tx,\n\t.sta_add = brcms_ops_sta_add,\n\t.ampdu_action = brcms_ops_ampdu_action,\n\t.rfkill_poll = brcms_ops_rfkill_poll,\n\t.flush = brcms_ops_flush,\n\t.get_tsf = brcms_ops_get_tsf,\n\t.set_tsf = brcms_ops_set_tsf,\n\t.set_tim = brcms_ops_beacon_set_tim,\n};\n\nvoid brcms_dpc(struct tasklet_struct *t)\n{\n\tstruct brcms_info *wl;\n\n\twl = from_tasklet(wl, t, tasklet);\n\n\tspin_lock_bh(&wl->lock);\n\n\t \n\tif (wl->pub->up) {\n\t\tif (wl->resched) {\n\t\t\tunsigned long flags;\n\n\t\t\tspin_lock_irqsave(&wl->isr_lock, flags);\n\t\t\tbrcms_c_intrsupd(wl->wlc);\n\t\t\tspin_unlock_irqrestore(&wl->isr_lock, flags);\n\t\t}\n\n\t\twl->resched = brcms_c_dpc(wl->wlc, true);\n\t}\n\n\t \n\tif (!wl->pub->up)\n\t\tgoto done;\n\n\t \n\tif (wl->resched)\n\t\ttasklet_schedule(&wl->tasklet);\n\telse\n\t\t \n\t\tbrcms_intrson(wl);\n\n done:\n\tspin_unlock_bh(&wl->lock);\n\twake_up(&wl->tx_flush_wq);\n}\n\nstatic irqreturn_t brcms_isr(int irq, void *dev_id)\n{\n\tstruct brcms_info *wl;\n\tirqreturn_t ret = IRQ_NONE;\n\n\twl = (struct brcms_info *) dev_id;\n\n\tspin_lock(&wl->isr_lock);\n\n\t \n\tif (brcms_c_isr(wl->wlc)) {\n\t\t \n\t\ttasklet_schedule(&wl->tasklet);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tspin_unlock(&wl->isr_lock);\n\n\treturn ret;\n}\n\n \nstatic int ieee_hw_rate_init(struct ieee80211_hw *hw)\n{\n\tstruct brcms_info *wl = hw->priv;\n\tstruct brcms_c_info *wlc = wl->wlc;\n\tstruct ieee80211_supported_band *band;\n\tu16 phy_type;\n\n\thw->wiphy->bands[NL80211_BAND_2GHZ] = NULL;\n\thw->wiphy->bands[NL80211_BAND_5GHZ] = NULL;\n\n\tphy_type = brcms_c_get_phy_type(wl->wlc, 0);\n\tif (phy_type == PHY_TYPE_N || phy_type == PHY_TYPE_LCN) {\n\t\tband = &wlc->bandstate[BAND_2G_INDEX]->band;\n\t\t*band = brcms_band_2GHz_nphy_template;\n\t\tif (phy_type == PHY_TYPE_LCN) {\n\t\t\t \n\t\t\tband->ht_cap.mcs.rx_mask[1] = 0;\n\t\t\tband->ht_cap.mcs.rx_highest = cpu_to_le16(72);\n\t\t}\n\t\thw->wiphy->bands[NL80211_BAND_2GHZ] = band;\n\t} else {\n\t\treturn -EPERM;\n\t}\n\n\t \n\tif (wl->pub->_nbands > 1) {\n\t\tif (phy_type == PHY_TYPE_N || phy_type == PHY_TYPE_LCN) {\n\t\t\tband = &wlc->bandstate[BAND_5G_INDEX]->band;\n\t\t\t*band = brcms_band_5GHz_nphy_template;\n\t\t\thw->wiphy->bands[NL80211_BAND_5GHZ] = band;\n\t\t} else {\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int ieee_hw_init(struct ieee80211_hw *hw)\n{\n\tieee80211_hw_set(hw, AMPDU_AGGREGATION);\n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\tieee80211_hw_set(hw, REPORTS_TX_ACK_STATUS);\n\n\thw->extra_tx_headroom = brcms_c_get_header_len();\n\thw->queues = N_TX_QUEUES;\n\thw->max_rates = 2;\t \n\n\t \n\thw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t     BIT(NL80211_IFTYPE_AP) |\n\t\t\t\t     BIT(NL80211_IFTYPE_ADHOC);\n\n\t \n\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\thw->rate_control_algorithm = \"minstrel_ht\";\n\n\thw->sta_data_size = 0;\n\treturn ieee_hw_rate_init(hw);\n}\n\n \nstatic struct brcms_info *brcms_attach(struct bcma_device *pdev)\n{\n\tstruct brcms_info *wl = NULL;\n\tint unit, err;\n\tstruct ieee80211_hw *hw;\n\tu8 perm[ETH_ALEN];\n\n\tunit = n_adapters_found;\n\terr = 0;\n\n\tif (unit < 0)\n\t\treturn NULL;\n\n\t \n\thw = bcma_get_drvdata(pdev);\n\tif (hw != NULL)\n\t\twl = hw->priv;\n\tif (WARN_ON(hw == NULL) || WARN_ON(wl == NULL))\n\t\treturn NULL;\n\twl->wiphy = hw->wiphy;\n\n\tatomic_set(&wl->callbacks, 0);\n\n\tinit_waitqueue_head(&wl->tx_flush_wq);\n\n\t \n\ttasklet_setup(&wl->tasklet, brcms_dpc);\n\n\tspin_lock_init(&wl->lock);\n\tspin_lock_init(&wl->isr_lock);\n\n\t \n\twl->wlc = brcms_c_attach((void *)wl, pdev, unit, false, &err);\n\tif (!wl->wlc) {\n\t\twiphy_err(wl->wiphy, \"%s: attach() failed with code %d\\n\",\n\t\t\t  KBUILD_MODNAME, err);\n\t\tgoto fail;\n\t}\n\twl->pub = brcms_c_pub(wl->wlc);\n\n\twl->pub->ieee_hw = hw;\n\n\t \n\tif (request_irq(pdev->irq, brcms_isr,\n\t\t\tIRQF_SHARED, KBUILD_MODNAME, wl)) {\n\t\twiphy_err(wl->wiphy, \"wl%d: request_irq() failed\\n\", unit);\n\t\tgoto fail;\n\t}\n\twl->irq = pdev->irq;\n\n\t \n\tbrcms_c_module_register(wl->pub, \"linux\", wl, NULL);\n\n\tif (ieee_hw_init(hw)) {\n\t\twiphy_err(wl->wiphy, \"wl%d: %s: ieee_hw_init failed!\\n\", unit,\n\t\t\t  __func__);\n\t\tgoto fail;\n\t}\n\n\tbrcms_c_regd_init(wl->wlc);\n\n\tmemcpy(perm, &wl->pub->cur_etheraddr, ETH_ALEN);\n\tif (WARN_ON(!is_valid_ether_addr(perm)))\n\t\tgoto fail;\n\tSET_IEEE80211_PERM_ADDR(hw, perm);\n\n\terr = ieee80211_register_hw(hw);\n\tif (err)\n\t\twiphy_err(wl->wiphy, \"%s: ieee80211_register_hw failed, status\"\n\t\t\t  \"%d\\n\", __func__, err);\n\n\tif (wl->pub->srom_ccode[0] &&\n\t    regulatory_hint(wl->wiphy, wl->pub->srom_ccode))\n\t\twiphy_err(wl->wiphy, \"%s: regulatory hint failed\\n\", __func__);\n\n\tbrcms_debugfs_attach(wl->pub);\n\tbrcms_debugfs_create_files(wl->pub);\n\tn_adapters_found++;\n\treturn wl;\n\nfail:\n\tbrcms_free(wl);\n\treturn NULL;\n}\n\n\n\n \nstatic int brcms_bcma_probe(struct bcma_device *pdev)\n{\n\tstruct brcms_info *wl;\n\tstruct ieee80211_hw *hw;\n\tint ret;\n\n\tdev_info(&pdev->dev, \"mfg %x core %x rev %d class %d irq %d\\n\",\n\t\t pdev->id.manuf, pdev->id.id, pdev->id.rev, pdev->id.class,\n\t\t pdev->irq);\n\n\tif ((pdev->id.manuf != BCMA_MANUF_BCM) ||\n\t    (pdev->id.id != BCMA_CORE_80211))\n\t\treturn -ENODEV;\n\n\thw = ieee80211_alloc_hw(sizeof(struct brcms_info), &brcms_ops);\n\tif (!hw) {\n\t\tpr_err(\"%s: ieee80211_alloc_hw failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tSET_IEEE80211_DEV(hw, &pdev->dev);\n\n\tbcma_set_drvdata(pdev, hw);\n\n\tmemset(hw->priv, 0, sizeof(*wl));\n\n\twl = brcms_attach(pdev);\n\tif (!wl) {\n\t\tpr_err(\"%s: brcms_attach failed!\\n\", __func__);\n\t\tret = -ENODEV;\n\t\tgoto err_free_ieee80211;\n\t}\n\tbrcms_led_register(wl);\n\n\treturn 0;\n\nerr_free_ieee80211:\n\tieee80211_free_hw(hw);\n\treturn ret;\n}\n\nstatic int brcms_suspend(struct bcma_device *pdev)\n{\n\tstruct brcms_info *wl;\n\tstruct ieee80211_hw *hw;\n\n\thw = bcma_get_drvdata(pdev);\n\twl = hw->priv;\n\tif (!wl) {\n\t\tpr_err(\"%s: %s: no driver private struct!\\n\", KBUILD_MODNAME,\n\t\t       __func__);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tspin_lock_bh(&wl->lock);\n\twl->pub->hw_up = false;\n\tspin_unlock_bh(&wl->lock);\n\n\tbrcms_dbg_info(wl->wlc->hw->d11core, \"brcms_suspend ok\\n\");\n\n\treturn 0;\n}\n\nstatic int brcms_resume(struct bcma_device *pdev)\n{\n\treturn 0;\n}\n\nstatic struct bcma_driver brcms_bcma_driver = {\n\t.name     = KBUILD_MODNAME,\n\t.probe    = brcms_bcma_probe,\n\t.suspend  = brcms_suspend,\n\t.resume   = brcms_resume,\n\t.remove   = brcms_remove,\n\t.id_table = brcms_coreid_table,\n};\n\n \nstatic void brcms_driver_init(struct work_struct *work)\n{\n\tint error;\n\n\terror = bcma_driver_register(&brcms_bcma_driver);\n\tif (error)\n\t\tpr_err(\"%s: register returned %d\\n\", __func__, error);\n}\n\nstatic DECLARE_WORK(brcms_driver_work, brcms_driver_init);\n\nstatic int __init brcms_module_init(void)\n{\n\tbrcms_debugfs_init();\n\tif (!schedule_work(&brcms_driver_work))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\n \nstatic void __exit brcms_module_exit(void)\n{\n\tcancel_work_sync(&brcms_driver_work);\n\tbcma_driver_unregister(&brcms_bcma_driver);\n\tbrcms_debugfs_exit();\n}\n\nmodule_init(brcms_module_init);\nmodule_exit(brcms_module_exit);\n\n \nvoid brcms_txflowcontrol(struct brcms_info *wl, struct brcms_if *wlif,\n\t\t\t bool state, int prio)\n{\n\tbrcms_err(wl->wlc->hw->d11core, \"Shouldn't be here %s\\n\", __func__);\n}\n\n \nvoid brcms_init(struct brcms_info *wl)\n{\n\tbrcms_dbg_info(wl->wlc->hw->d11core, \"Initializing wl%d\\n\",\n\t\t       wl->pub->unit);\n\tbrcms_reset(wl);\n\tbrcms_c_init(wl->wlc, wl->mute_tx);\n}\n\n \nuint brcms_reset(struct brcms_info *wl)\n{\n\tbrcms_dbg_info(wl->wlc->hw->d11core, \"Resetting wl%d\\n\", wl->pub->unit);\n\tbrcms_c_reset(wl->wlc);\n\n\t \n\twl->resched = false;\n\n\t \n\twl->pub->up = false;\n\n\treturn 0;\n}\n\nvoid brcms_fatal_error(struct brcms_info *wl)\n{\n\tbrcms_err(wl->wlc->hw->d11core, \"wl%d: fatal error, reinitializing\\n\",\n\t\t  wl->wlc->pub->unit);\n\tbrcms_reset(wl);\n\tieee80211_restart_hw(wl->pub->ieee_hw);\n}\n\n \nvoid brcms_intrson(struct brcms_info *wl)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wl->isr_lock, flags);\n\tbrcms_c_intrson(wl->wlc);\n\tspin_unlock_irqrestore(&wl->isr_lock, flags);\n}\n\nu32 brcms_intrsoff(struct brcms_info *wl)\n{\n\tunsigned long flags;\n\tu32 status;\n\n\tspin_lock_irqsave(&wl->isr_lock, flags);\n\tstatus = brcms_c_intrsoff(wl->wlc);\n\tspin_unlock_irqrestore(&wl->isr_lock, flags);\n\treturn status;\n}\n\nvoid brcms_intrsrestore(struct brcms_info *wl, u32 macintmask)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wl->isr_lock, flags);\n\tbrcms_c_intrsrestore(wl->wlc, macintmask);\n\tspin_unlock_irqrestore(&wl->isr_lock, flags);\n}\n\n \nint brcms_up(struct brcms_info *wl)\n{\n\tint error = 0;\n\n\tif (wl->pub->up)\n\t\treturn 0;\n\n\terror = brcms_c_up(wl->wlc);\n\n\treturn error;\n}\n\n \nvoid brcms_down(struct brcms_info *wl)\n\t__must_hold(&wl->lock)\n{\n\tuint callbacks, ret_val = 0;\n\n\t \n\tret_val = brcms_c_down(wl->wlc);\n\tcallbacks = atomic_read(&wl->callbacks) - ret_val;\n\n\t \n\tspin_unlock_bh(&wl->lock);\n\n\t \n\tSPINWAIT((atomic_read(&wl->callbacks) > callbacks), 100 * 1000);\n\n\tspin_lock_bh(&wl->lock);\n}\n\n \nstatic void _brcms_timer(struct work_struct *work)\n{\n\tstruct brcms_timer *t = container_of(work, struct brcms_timer,\n\t\t\t\t\t     dly_wrk.work);\n\n\tspin_lock_bh(&t->wl->lock);\n\n\tif (t->set) {\n\t\tif (t->periodic) {\n\t\t\tatomic_inc(&t->wl->callbacks);\n\t\t\tieee80211_queue_delayed_work(t->wl->pub->ieee_hw,\n\t\t\t\t\t\t     &t->dly_wrk,\n\t\t\t\t\t\t     msecs_to_jiffies(t->ms));\n\t\t} else {\n\t\t\tt->set = false;\n\t\t}\n\n\t\tt->fn(t->arg);\n\t}\n\n\tatomic_dec(&t->wl->callbacks);\n\n\tspin_unlock_bh(&t->wl->lock);\n}\n\n \nstruct brcms_timer *brcms_init_timer(struct brcms_info *wl,\n\t\t\t\t     void (*fn) (void *arg),\n\t\t\t\t     void *arg, const char *name)\n{\n\tstruct brcms_timer *t;\n\n\tt = kzalloc(sizeof(struct brcms_timer), GFP_ATOMIC);\n\tif (!t)\n\t\treturn NULL;\n\n\tINIT_DELAYED_WORK(&t->dly_wrk, _brcms_timer);\n\tt->wl = wl;\n\tt->fn = fn;\n\tt->arg = arg;\n\tt->next = wl->timers;\n\twl->timers = t;\n\n#ifdef DEBUG\n\tt->name = kstrdup(name, GFP_ATOMIC);\n#endif\n\n\treturn t;\n}\n\n \nvoid brcms_add_timer(struct brcms_timer *t, uint ms, int periodic)\n{\n\tstruct ieee80211_hw *hw = t->wl->pub->ieee_hw;\n\n#ifdef DEBUG\n\tif (t->set)\n\t\tbrcms_dbg_info(t->wl->wlc->hw->d11core,\n\t\t\t       \"%s: Already set. Name: %s, per %d\\n\",\n\t\t\t       __func__, t->name, periodic);\n#endif\n\tt->ms = ms;\n\tt->periodic = (bool) periodic;\n\tif (!t->set) {\n\t\tt->set = true;\n\t\tatomic_inc(&t->wl->callbacks);\n\t}\n\n\tieee80211_queue_delayed_work(hw, &t->dly_wrk, msecs_to_jiffies(ms));\n}\n\n \nbool brcms_del_timer(struct brcms_timer *t)\n{\n\tif (t->set) {\n\t\tt->set = false;\n\t\tif (!cancel_delayed_work(&t->dly_wrk))\n\t\t\treturn false;\n\n\t\tatomic_dec(&t->wl->callbacks);\n\t}\n\n\treturn true;\n}\n\n \nvoid brcms_free_timer(struct brcms_timer *t)\n{\n\tstruct brcms_info *wl = t->wl;\n\tstruct brcms_timer *tmp;\n\n\t \n\tbrcms_del_timer(t);\n\n\tif (wl->timers == t) {\n\t\twl->timers = wl->timers->next;\n#ifdef DEBUG\n\t\tkfree(t->name);\n#endif\n\t\tkfree(t);\n\t\treturn;\n\n\t}\n\n\ttmp = wl->timers;\n\twhile (tmp) {\n\t\tif (tmp->next == t) {\n\t\t\ttmp->next = t->next;\n#ifdef DEBUG\n\t\t\tkfree(t->name);\n#endif\n\t\t\tkfree(t);\n\t\t\treturn;\n\t\t}\n\t\ttmp = tmp->next;\n\t}\n\n}\n\n \nint brcms_ucode_init_buf(struct brcms_info *wl, void **pbuf, u32 idx)\n{\n\tint i, entry;\n\tconst u8 *pdata;\n\tstruct firmware_hdr *hdr;\n\tfor (i = 0; i < wl->fw.fw_cnt; i++) {\n\t\thdr = (struct firmware_hdr *)wl->fw.fw_hdr[i]->data;\n\t\tfor (entry = 0; entry < wl->fw.hdr_num_entries[i];\n\t\t     entry++, hdr++) {\n\t\t\tu32 len = le32_to_cpu(hdr->len);\n\t\t\tif (le32_to_cpu(hdr->idx) == idx) {\n\t\t\t\tpdata = wl->fw.fw_bin[i]->data +\n\t\t\t\t\tle32_to_cpu(hdr->offset);\n\t\t\t\t*pbuf = kvmalloc(len, GFP_KERNEL);\n\t\t\t\tif (*pbuf == NULL)\n\t\t\t\t\tgoto fail;\n\t\t\t\tmemcpy(*pbuf, pdata, len);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tbrcms_err(wl->wlc->hw->d11core,\n\t\t  \"ERROR: ucode buf tag:%d can not be found!\\n\", idx);\n\t*pbuf = NULL;\nfail:\n\treturn -ENODATA;\n}\n\n \nint brcms_ucode_init_uint(struct brcms_info *wl, size_t *n_bytes, u32 idx)\n{\n\tint i, entry;\n\tconst u8 *pdata;\n\tstruct firmware_hdr *hdr;\n\tfor (i = 0; i < wl->fw.fw_cnt; i++) {\n\t\thdr = (struct firmware_hdr *)wl->fw.fw_hdr[i]->data;\n\t\tfor (entry = 0; entry < wl->fw.hdr_num_entries[i];\n\t\t     entry++, hdr++) {\n\t\t\tif (le32_to_cpu(hdr->idx) == idx) {\n\t\t\t\tpdata = wl->fw.fw_bin[i]->data +\n\t\t\t\t\tle32_to_cpu(hdr->offset);\n\t\t\t\tif (le32_to_cpu(hdr->len) != 4) {\n\t\t\t\t\tbrcms_err(wl->wlc->hw->d11core,\n\t\t\t\t\t\t  \"ERROR: fw hdr len\\n\");\n\t\t\t\t\treturn -ENOMSG;\n\t\t\t\t}\n\t\t\t\t*n_bytes = le32_to_cpu(*((__le32 *) pdata));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tbrcms_err(wl->wlc->hw->d11core,\n\t\t  \"ERROR: ucode tag:%d can not be found!\\n\", idx);\n\treturn -ENOMSG;\n}\n\n \nvoid brcms_ucode_free_buf(void *p)\n{\n\tkvfree(p);\n}\n\n \nint brcms_check_firmwares(struct brcms_info *wl)\n{\n\tint i;\n\tint entry;\n\tint rc = 0;\n\tconst struct firmware *fw;\n\tconst struct firmware *fw_hdr;\n\tstruct firmware_hdr *ucode_hdr;\n\tfor (i = 0; i < MAX_FW_IMAGES && rc == 0; i++) {\n\t\tfw =  wl->fw.fw_bin[i];\n\t\tfw_hdr = wl->fw.fw_hdr[i];\n\t\tif (fw == NULL && fw_hdr == NULL) {\n\t\t\tbreak;\n\t\t} else if (fw == NULL || fw_hdr == NULL) {\n\t\t\twiphy_err(wl->wiphy, \"%s: invalid bin/hdr fw\\n\",\n\t\t\t\t  __func__);\n\t\t\trc = -EBADF;\n\t\t} else if (fw_hdr->size % sizeof(struct firmware_hdr)) {\n\t\t\twiphy_err(wl->wiphy, \"%s: non integral fw hdr file \"\n\t\t\t\t\"size %zu/%zu\\n\", __func__, fw_hdr->size,\n\t\t\t\tsizeof(struct firmware_hdr));\n\t\t\trc = -EBADF;\n\t\t} else if (fw->size < MIN_FW_SIZE || fw->size > MAX_FW_SIZE) {\n\t\t\twiphy_err(wl->wiphy, \"%s: out of bounds fw file size %zu\\n\",\n\t\t\t\t  __func__, fw->size);\n\t\t\trc = -EBADF;\n\t\t} else {\n\t\t\t \n\t\t\tucode_hdr = (struct firmware_hdr *)fw_hdr->data;\n\t\t\tfor (entry = 0; entry < wl->fw.hdr_num_entries[i] &&\n\t\t\t     !rc; entry++, ucode_hdr++) {\n\t\t\t\tif (le32_to_cpu(ucode_hdr->offset) +\n\t\t\t\t    le32_to_cpu(ucode_hdr->len) >\n\t\t\t\t    fw->size) {\n\t\t\t\t\twiphy_err(wl->wiphy,\n\t\t\t\t\t\t  \"%s: conflicting bin/hdr\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\trc = -EBADF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (rc == 0 && wl->fw.fw_cnt != i) {\n\t\twiphy_err(wl->wiphy, \"%s: invalid fw_cnt=%d\\n\", __func__,\n\t\t\twl->fw.fw_cnt);\n\t\trc = -EBADF;\n\t}\n\treturn rc;\n}\n\n \nbool brcms_rfkill_set_hw_state(struct brcms_info *wl)\n\t__must_hold(&wl->lock)\n{\n\tbool blocked = brcms_c_check_radio_disabled(wl->wlc);\n\n\tspin_unlock_bh(&wl->lock);\n\twiphy_rfkill_set_hw_state(wl->pub->ieee_hw->wiphy, blocked);\n\tif (blocked)\n\t\twiphy_rfkill_start_polling(wl->pub->ieee_hw->wiphy);\n\tspin_lock_bh(&wl->lock);\n\treturn blocked;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}