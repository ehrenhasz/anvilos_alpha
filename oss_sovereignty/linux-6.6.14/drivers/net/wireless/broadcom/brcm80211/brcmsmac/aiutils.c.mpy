{
  "module_name": "aiutils.c",
  "hash_id": "d3488f5fcb2865d63b4a9250829ce620b33192610a7b4f40c0dbf469dc40e373",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmsmac/aiutils.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/delay.h>\n\n#include <defs.h>\n#include <chipcommon.h>\n#include <brcmu_utils.h>\n#include <brcm_hw_ids.h>\n#include <soc.h>\n#include \"types.h\"\n#include \"pub.h\"\n#include \"pmu.h\"\n#include \"aiutils.h\"\n\n \n  \n#define SCC_SS_MASK\t\t0x00000007\n  \n#define\tSCC_SS_LPO\t\t0x00000000\n  \n#define\tSCC_SS_XTAL\t\t0x00000001\n  \n#define\tSCC_SS_PCI\t\t0x00000002\n  \n#define SCC_LF\t\t\t0x00000200\n  \n#define SCC_LP\t\t\t0x00000400\n  \n#define SCC_FS\t\t\t0x00000800\n  \n#define SCC_IP\t\t\t0x00001000\n  \n#define SCC_XC\t\t\t0x00002000\n  \n#define SCC_XP\t\t\t0x00004000\n  \n#define SCC_CD_MASK\t\t0xffff0000\n#define SCC_CD_SHIFT\t\t16\n\n \n  \n#define\tSYCC_IE\t\t\t0x00000001\n  \n#define\tSYCC_AE\t\t\t0x00000002\n  \n#define\tSYCC_FP\t\t\t0x00000004\n  \n#define\tSYCC_AR\t\t\t0x00000008\n  \n#define\tSYCC_HR\t\t\t0x00000010\n  \n#define SYCC_CD_MASK\t\t0xffff0000\n#define SYCC_CD_SHIFT\t\t16\n\n#define CST4329_SPROM_OTP_SEL_MASK\t0x00000003\n  \n#define CST4329_DEFCIS_SEL\t\t0\n  \n#define CST4329_SPROM_SEL\t\t1\n  \n#define CST4329_OTP_SEL\t\t\t2\n  \n#define CST4329_OTP_PWRDN\t\t3\n\n#define CST4329_SPI_SDIO_MODE_MASK\t0x00000004\n#define CST4329_SPI_SDIO_MODE_SHIFT\t2\n\n \n#define CCTRL43224_GPIO_TOGGLE          0x8000\n  \n#define CCTRL_43224A0_12MA_LED_DRIVE    0x00F000F0\n  \n#define CCTRL_43224B0_12MA_LED_DRIVE    0xF0\n\n \n#define CST43236_SFLASH_MASK\t\t0x00000040\n#define CST43236_OTP_MASK\t\t0x00000080\n#define CST43236_HSIC_MASK\t\t0x00000100\t \n#define CST43236_BP_CLK\t\t\t0x00000200\t \n#define CST43236_BOOT_MASK\t\t0x00001800\n#define CST43236_BOOT_SHIFT\t\t11\n#define CST43236_BOOT_FROM_SRAM\t\t0  \n#define CST43236_BOOT_FROM_ROM\t\t1  \n#define CST43236_BOOT_FROM_FLASH\t2  \n#define CST43236_BOOT_FROM_INVALID\t3\n\n \n  \n#define CCTRL4331_BT_COEXIST\t\t(1<<0)\n  \n#define CCTRL4331_SECI\t\t\t(1<<1)\n  \n#define CCTRL4331_EXT_LNA\t\t(1<<2)\n  \n#define CCTRL4331_SPROM_GPIO13_15       (1<<3)\n  \n#define CCTRL4331_EXTPA_EN\t\t(1<<4)\n  \n#define CCTRL4331_GPIOCLK_ON_SPROMCS\t(1<<5)\n  \n#define CCTRL4331_PCIE_MDIO_ON_SPROMCS\t(1<<6)\n  \n#define CCTRL4331_EXTPA_ON_GPIO2_5\t(1<<7)\n  \n#define CCTRL4331_OVR_PIPEAUXCLKEN\t(1<<8)\n  \n#define CCTRL4331_OVR_PIPEAUXPWRDOWN\t(1<<9)\n  \n#define CCTRL4331_PCIE_AUXCLKEN\t\t(1<<10)\n  \n#define CCTRL4331_PCIE_PIPE_PLLDOWN\t(1<<11)\n  \n#define CCTRL4331_BT_SHD0_ON_GPIO4\t(1<<16)\n  \n#define CCTRL4331_BT_SHD1_ON_GPIO5\t(1<<17)\n\n \n  \n#define\tCST4331_XTAL_FREQ\t\t0x00000001\n#define\tCST4331_SPROM_PRESENT\t\t0x00000002\n#define\tCST4331_OTP_PRESENT\t\t0x00000004\n#define\tCST4331_LDO_RF\t\t\t0x00000008\n#define\tCST4331_LDO_PAR\t\t\t0x00000010\n\n \n#define\tCST4319_SPI_CPULESSUSB\t\t0x00000001\n#define\tCST4319_SPI_CLK_POL\t\t0x00000002\n#define\tCST4319_SPI_CLK_PH\t\t0x00000008\n  \n#define\tCST4319_SPROM_OTP_SEL_MASK\t0x000000c0\n#define\tCST4319_SPROM_OTP_SEL_SHIFT\t6\n  \n#define\tCST4319_DEFCIS_SEL\t\t0x00000000\n  \n#define\tCST4319_SPROM_SEL\t\t0x00000040\n  \n#define\tCST4319_OTP_SEL\t\t\t0x00000080\n  \n#define\tCST4319_OTP_PWRDN\t\t0x000000c0\n  \n#define\tCST4319_SDIO_USB_MODE\t\t0x00000100\n#define\tCST4319_REMAP_SEL_MASK\t\t0x00000600\n#define\tCST4319_ILPDIV_EN\t\t0x00000800\n#define\tCST4319_XTAL_PD_POL\t\t0x00001000\n#define\tCST4319_LPO_SEL\t\t\t0x00002000\n#define\tCST4319_RES_INIT_MODE\t\t0x0000c000\n  \n#define\tCST4319_PALDO_EXTPNP\t\t0x00010000\n#define\tCST4319_CBUCK_MODE_MASK\t\t0x00060000\n#define CST4319_CBUCK_MODE_BURST\t0x00020000\n#define CST4319_CBUCK_MODE_LPBURST\t0x00060000\n#define\tCST4319_RCAL_VALID\t\t0x01000000\n#define\tCST4319_RCAL_VALUE_MASK\t\t0x3e000000\n#define\tCST4319_RCAL_VALUE_SHIFT\t25\n\n \n#define\tCST4336_SPI_MODE_MASK\t\t0x00000001\n#define\tCST4336_SPROM_PRESENT\t\t0x00000002\n#define\tCST4336_OTP_PRESENT\t\t0x00000004\n#define\tCST4336_ARMREMAP_0\t\t0x00000008\n#define\tCST4336_ILPDIV_EN_MASK\t\t0x00000010\n#define\tCST4336_ILPDIV_EN_SHIFT\t\t4\n#define\tCST4336_XTAL_PD_POL_MASK\t0x00000020\n#define\tCST4336_XTAL_PD_POL_SHIFT\t5\n#define\tCST4336_LPO_SEL_MASK\t\t0x00000040\n#define\tCST4336_LPO_SEL_SHIFT\t\t6\n#define\tCST4336_RES_INIT_MODE_MASK\t0x00000180\n#define\tCST4336_RES_INIT_MODE_SHIFT\t7\n#define\tCST4336_CBUCK_MODE_MASK\t\t0x00000600\n#define\tCST4336_CBUCK_MODE_SHIFT\t9\n\n \n#define\tCST4313_SPROM_PRESENT\t\t\t1\n#define\tCST4313_OTP_PRESENT\t\t\t2\n#define\tCST4313_SPROM_OTP_SEL_MASK\t\t0x00000002\n#define\tCST4313_SPROM_OTP_SEL_SHIFT\t\t0\n\n \n  \n#define CCTRL_4313_12MA_LED_DRIVE    0x00000007\n\n \n#define\tMFGID_ARM\t\t0x43b\n#define\tMFGID_BRCM\t\t0x4bf\n#define\tMFGID_MIPS\t\t0x4a7\n\n \n#define\tER_EROMENTRY\t\t0x000\n#define\tER_REMAPCONTROL\t\t0xe00\n#define\tER_REMAPSELECT\t\t0xe04\n#define\tER_MASTERSELECT\t\t0xe10\n#define\tER_ITCR\t\t\t0xf00\n#define\tER_ITIP\t\t\t0xf04\n\n \n#define\tER_TAG\t\t\t0xe\n#define\tER_TAG1\t\t\t0x6\n#define\tER_VALID\t\t1\n#define\tER_CI\t\t\t0\n#define\tER_MP\t\t\t2\n#define\tER_ADD\t\t\t4\n#define\tER_END\t\t\t0xe\n#define\tER_BAD\t\t\t0xffffffff\n\n \n#define\tCIA_MFG_MASK\t\t0xfff00000\n#define\tCIA_MFG_SHIFT\t\t20\n#define\tCIA_CID_MASK\t\t0x000fff00\n#define\tCIA_CID_SHIFT\t\t8\n#define\tCIA_CCL_MASK\t\t0x000000f0\n#define\tCIA_CCL_SHIFT\t\t4\n\n \n#define\tCIB_REV_MASK\t\t0xff000000\n#define\tCIB_REV_SHIFT\t\t24\n#define\tCIB_NSW_MASK\t\t0x00f80000\n#define\tCIB_NSW_SHIFT\t\t19\n#define\tCIB_NMW_MASK\t\t0x0007c000\n#define\tCIB_NMW_SHIFT\t\t14\n#define\tCIB_NSP_MASK\t\t0x00003e00\n#define\tCIB_NSP_SHIFT\t\t9\n#define\tCIB_NMP_MASK\t\t0x000001f0\n#define\tCIB_NMP_SHIFT\t\t4\n\n \n#define\tAD_ADDR_MASK\t\t0xfffff000\n#define\tAD_SP_MASK\t\t0x00000f00\n#define\tAD_SP_SHIFT\t\t8\n#define\tAD_ST_MASK\t\t0x000000c0\n#define\tAD_ST_SHIFT\t\t6\n#define\tAD_ST_SLAVE\t\t0x00000000\n#define\tAD_ST_BRIDGE\t\t0x00000040\n#define\tAD_ST_SWRAP\t\t0x00000080\n#define\tAD_ST_MWRAP\t\t0x000000c0\n#define\tAD_SZ_MASK\t\t0x00000030\n#define\tAD_SZ_SHIFT\t\t4\n#define\tAD_SZ_4K\t\t0x00000000\n#define\tAD_SZ_8K\t\t0x00000010\n#define\tAD_SZ_16K\t\t0x00000020\n#define\tAD_SZ_SZD\t\t0x00000030\n#define\tAD_AG32\t\t\t0x00000008\n#define\tAD_ADDR_ALIGN\t\t0x00000fff\n#define\tAD_SZ_BASE\t\t0x00001000\t \n\n \n#define\tSD_SZ_MASK\t\t0xfffff000\n#define\tSD_SG32\t\t\t0x00000008\n#define\tSD_SZ_ALIGN\t\t0x00000fff\n\n \n#define\tPCI_CFG_GPIO_SCS\t0x10\n \n#define PCI_CFG_GPIO_XTAL\t0x40\n \n#define PCI_CFG_GPIO_PLL\t0x80\n\n \n#define PLL_DELAY\t\t150\t \n#define FREF_DELAY\t\t200\t \n#define\tXTAL_ON_DELAY\t\t1000\t \n\n \n#define\tAIRC_RESET\t\t1\n\n#define\tNOREV\t\t-1\t \n\n \n#define DEFAULT_GPIO_ONTIME\t10\t \n#define DEFAULT_GPIO_OFFTIME\t90\t \n\n \n#define\tSRC_START\t\t0x80000000\n#define\tSRC_BUSY\t\t0x80000000\n#define\tSRC_OPCODE\t\t0x60000000\n#define\tSRC_OP_READ\t\t0x00000000\n#define\tSRC_OP_WRITE\t\t0x20000000\n#define\tSRC_OP_WRDIS\t\t0x40000000\n#define\tSRC_OP_WREN\t\t0x60000000\n#define\tSRC_OTPSEL\t\t0x00000010\n#define\tSRC_LOCK\t\t0x00000008\n#define\tSRC_SIZE_MASK\t\t0x00000006\n#define\tSRC_SIZE_1K\t\t0x00000000\n#define\tSRC_SIZE_4K\t\t0x00000002\n#define\tSRC_SIZE_16K\t\t0x00000004\n#define\tSRC_SIZE_SHIFT\t\t1\n#define\tSRC_PRESENT\t\t0x00000001\n\n \n#define GPIO_CTRL_EPA_EN_MASK 0x40\n\n#define DEFAULT_GPIOTIMERVAL \\\n\t((DEFAULT_GPIO_ONTIME << GPIO_ONTIME_SHIFT) | DEFAULT_GPIO_OFFTIME)\n\n#define\tBADIDX\t\t(SI_MAXCORES + 1)\n\n#define\tIS_SIM(chippkg)\t\\\n\t((chippkg == HDLSIM_PKG_ID) || (chippkg == HWSIM_PKG_ID))\n\n#define\tGOODCOREADDR(x, b) \\\n\t(((x) >= (b)) && ((x) < ((b) + SI_MAXCORES * SI_CORE_SIZE)) && \\\n\t\tIS_ALIGNED((x), SI_CORE_SIZE))\n\nstruct aidmp {\n\tu32 oobselina30;\t \n\tu32 oobselina74;\t \n\tu32 PAD[6];\n\tu32 oobselinb30;\t \n\tu32 oobselinb74;\t \n\tu32 PAD[6];\n\tu32 oobselinc30;\t \n\tu32 oobselinc74;\t \n\tu32 PAD[6];\n\tu32 oobselind30;\t \n\tu32 oobselind74;\t \n\tu32 PAD[38];\n\tu32 oobselouta30;\t \n\tu32 oobselouta74;\t \n\tu32 PAD[6];\n\tu32 oobseloutb30;\t \n\tu32 oobseloutb74;\t \n\tu32 PAD[6];\n\tu32 oobseloutc30;\t \n\tu32 oobseloutc74;\t \n\tu32 PAD[6];\n\tu32 oobseloutd30;\t \n\tu32 oobseloutd74;\t \n\tu32 PAD[38];\n\tu32 oobsynca;\t \n\tu32 oobseloutaen;\t \n\tu32 PAD[6];\n\tu32 oobsyncb;\t \n\tu32 oobseloutben;\t \n\tu32 PAD[6];\n\tu32 oobsyncc;\t \n\tu32 oobseloutcen;\t \n\tu32 PAD[6];\n\tu32 oobsyncd;\t \n\tu32 oobseloutden;\t \n\tu32 PAD[38];\n\tu32 oobaextwidth;\t \n\tu32 oobainwidth;\t \n\tu32 oobaoutwidth;\t \n\tu32 PAD[5];\n\tu32 oobbextwidth;\t \n\tu32 oobbinwidth;\t \n\tu32 oobboutwidth;\t \n\tu32 PAD[5];\n\tu32 oobcextwidth;\t \n\tu32 oobcinwidth;\t \n\tu32 oobcoutwidth;\t \n\tu32 PAD[5];\n\tu32 oobdextwidth;\t \n\tu32 oobdinwidth;\t \n\tu32 oobdoutwidth;\t \n\tu32 PAD[37];\n\tu32 ioctrlset;\t \n\tu32 ioctrlclear;\t \n\tu32 ioctrl;\t\t \n\tu32 PAD[61];\n\tu32 iostatus;\t \n\tu32 PAD[127];\n\tu32 ioctrlwidth;\t \n\tu32 iostatuswidth;\t \n\tu32 PAD[62];\n\tu32 resetctrl;\t \n\tu32 resetstatus;\t \n\tu32 resetreadid;\t \n\tu32 resetwriteid;\t \n\tu32 PAD[60];\n\tu32 errlogctrl;\t \n\tu32 errlogdone;\t \n\tu32 errlogstatus;\t \n\tu32 errlogaddrlo;\t \n\tu32 errlogaddrhi;\t \n\tu32 errlogid;\t \n\tu32 errloguser;\t \n\tu32 errlogflags;\t \n\tu32 PAD[56];\n\tu32 intstatus;\t \n\tu32 PAD[127];\n\tu32 config;\t\t \n\tu32 PAD[63];\n\tu32 itcr;\t\t \n\tu32 PAD[3];\n\tu32 itipooba;\t \n\tu32 itipoobb;\t \n\tu32 itipoobc;\t \n\tu32 itipoobd;\t \n\tu32 PAD[4];\n\tu32 itipoobaout;\t \n\tu32 itipoobbout;\t \n\tu32 itipoobcout;\t \n\tu32 itipoobdout;\t \n\tu32 PAD[4];\n\tu32 itopooba;\t \n\tu32 itopoobb;\t \n\tu32 itopoobc;\t \n\tu32 itopoobd;\t \n\tu32 PAD[4];\n\tu32 itopoobain;\t \n\tu32 itopoobbin;\t \n\tu32 itopoobcin;\t \n\tu32 itopoobdin;\t \n\tu32 PAD[4];\n\tu32 itopreset;\t \n\tu32 PAD[15];\n\tu32 peripherialid4;\t \n\tu32 peripherialid5;\t \n\tu32 peripherialid6;\t \n\tu32 peripherialid7;\t \n\tu32 peripherialid0;\t \n\tu32 peripherialid1;\t \n\tu32 peripherialid2;\t \n\tu32 peripherialid3;\t \n\tu32 componentid0;\t \n\tu32 componentid1;\t \n\tu32 componentid2;\t \n\tu32 componentid3;\t \n};\n\nstatic bool\nai_buscore_setup(struct si_info *sii, struct bcma_device *cc)\n{\n\t \n\tif (cc->bus->nr_cores == 0)\n\t\treturn false;\n\n\t \n\tsii->pub.ccrev = cc->id.rev;\n\n\t \n\tsii->chipst = bcma_read32(cc, CHIPCREGOFFS(chipstatus));\n\n\t \n\tsii->pub.cccaps = bcma_read32(cc, CHIPCREGOFFS(capabilities));\n\n\t \n\tif (ai_get_cccaps(&sii->pub) & CC_CAP_PMU) {\n\t\tsii->pub.pmucaps = bcma_read32(cc,\n\t\t\t\t\t       CHIPCREGOFFS(pmucapabilities));\n\t\tsii->pub.pmurev = sii->pub.pmucaps & PCAP_REV_MASK;\n\t}\n\n\treturn true;\n}\n\nstatic struct si_info *ai_doattach(struct si_info *sii,\n\t\t\t\t   struct bcma_bus *pbus)\n{\n\tstruct si_pub *sih = &sii->pub;\n\tstruct bcma_device *cc;\n\n\tsii->icbus = pbus;\n\tsii->pcibus = pbus->host_pci;\n\n\t \n\tcc = pbus->drv_cc.core;\n\n\tsih->chip = pbus->chipinfo.id;\n\tsih->chiprev = pbus->chipinfo.rev;\n\tsih->chippkg = pbus->chipinfo.pkg;\n\tsih->boardvendor = pbus->boardinfo.vendor;\n\tsih->boardtype = pbus->boardinfo.type;\n\n\tif (!ai_buscore_setup(sii, cc))\n\t\tgoto exit;\n\n\t \n\tbcma_write32(cc, CHIPCREGOFFS(gpiopullup), 0);\n\tbcma_write32(cc, CHIPCREGOFFS(gpiopulldown), 0);\n\n\t \n\tif (ai_get_cccaps(sih) & CC_CAP_PMU) {\n\t\t(void)si_pmu_measure_alpclk(sih);\n\t}\n\n\treturn sii;\n\n exit:\n\n\treturn NULL;\n}\n\n \nstruct si_pub *\nai_attach(struct bcma_bus *pbus)\n{\n\tstruct si_info *sii;\n\n\t \n\tsii = kzalloc(sizeof(struct si_info), GFP_ATOMIC);\n\tif (sii == NULL)\n\t\treturn NULL;\n\n\tif (ai_doattach(sii, pbus) == NULL) {\n\t\tkfree(sii);\n\t\treturn NULL;\n\t}\n\n\treturn (struct si_pub *) sii;\n}\n\n \nvoid ai_detach(struct si_pub *sih)\n{\n\tstruct si_info *sii;\n\n\tsii = container_of(sih, struct si_info, pub);\n\n\tkfree(sii);\n}\n\n \nuint ai_cc_reg(struct si_pub *sih, uint regoff, u32 mask, u32 val)\n{\n\tstruct bcma_device *cc;\n\tu32 w;\n\tstruct si_info *sii;\n\n\tsii = container_of(sih, struct si_info, pub);\n\tcc = sii->icbus->drv_cc.core;\n\n\t \n\tif (mask || val)\n\t\tbcma_maskset32(cc, regoff, ~mask, val);\n\n\t \n\tw = bcma_read32(cc, regoff);\n\n\treturn w;\n}\n\n \nstatic uint ai_slowclk_src(struct si_pub *sih, struct bcma_device *cc)\n{\n\treturn SCC_SS_XTAL;\n}\n\n \nstatic uint ai_slowclk_freq(struct si_pub *sih, bool max_freq,\n\t\t\t    struct bcma_device *cc)\n{\n\tuint div;\n\n\t \n\tdiv = bcma_read32(cc, CHIPCREGOFFS(system_clk_ctl));\n\tdiv = 4 * ((div >> SYCC_CD_SHIFT) + 1);\n\treturn max_freq ? XTALMAXFREQ : (XTALMINFREQ / div);\n}\n\nstatic void\nai_clkctl_setdelay(struct si_pub *sih, struct bcma_device *cc)\n{\n\tuint slowmaxfreq, pll_delay, slowclk;\n\tuint pll_on_delay, fref_sel_delay;\n\n\tpll_delay = PLL_DELAY;\n\n\t \n\n\tslowclk = ai_slowclk_src(sih, cc);\n\tif (slowclk != SCC_SS_XTAL)\n\t\tpll_delay += XTAL_ON_DELAY;\n\n\t \n\tslowmaxfreq =\n\t    ai_slowclk_freq(sih, false, cc);\n\n\tpll_on_delay = ((slowmaxfreq * pll_delay) + 999999) / 1000000;\n\tfref_sel_delay = ((slowmaxfreq * FREF_DELAY) + 999999) / 1000000;\n\n\tbcma_write32(cc, CHIPCREGOFFS(pll_on_delay), pll_on_delay);\n\tbcma_write32(cc, CHIPCREGOFFS(fref_sel_delay), fref_sel_delay);\n}\n\n \nvoid ai_clkctl_init(struct si_pub *sih)\n{\n\tstruct si_info *sii = container_of(sih, struct si_info, pub);\n\tstruct bcma_device *cc;\n\n\tif (!(ai_get_cccaps(sih) & CC_CAP_PWR_CTL))\n\t\treturn;\n\n\tcc = sii->icbus->drv_cc.core;\n\tif (cc == NULL)\n\t\treturn;\n\n\t \n\tbcma_maskset32(cc, CHIPCREGOFFS(system_clk_ctl), SYCC_CD_MASK,\n\t\t       (ILP_DIV_1MHZ << SYCC_CD_SHIFT));\n\n\tai_clkctl_setdelay(sih, cc);\n}\n\n \nu16 ai_clkctl_fast_pwrup_delay(struct si_pub *sih)\n{\n\tstruct si_info *sii;\n\tstruct bcma_device *cc;\n\tuint slowminfreq;\n\tu16 fpdelay;\n\n\tsii = container_of(sih, struct si_info, pub);\n\tif (ai_get_cccaps(sih) & CC_CAP_PMU) {\n\t\tfpdelay = si_pmu_fast_pwrup_delay(sih);\n\t\treturn fpdelay;\n\t}\n\n\tif (!(ai_get_cccaps(sih) & CC_CAP_PWR_CTL))\n\t\treturn 0;\n\n\tfpdelay = 0;\n\tcc = sii->icbus->drv_cc.core;\n\tif (cc) {\n\t\tslowminfreq = ai_slowclk_freq(sih, false, cc);\n\t\tfpdelay = (((bcma_read32(cc, CHIPCREGOFFS(pll_on_delay)) + 2)\n\t\t\t    * 1000000) + (slowminfreq - 1)) / slowminfreq;\n\t}\n\treturn fpdelay;\n}\n\n \nbool ai_clkctl_cc(struct si_pub *sih, enum bcma_clkmode mode)\n{\n\tstruct si_info *sii;\n\tstruct bcma_device *cc;\n\n\tsii = container_of(sih, struct si_info, pub);\n\n\tcc = sii->icbus->drv_cc.core;\n\tbcma_core_set_clockmode(cc, mode);\n\treturn mode == BCMA_CLKMODE_FAST;\n}\n\n \nvoid ai_epa_4313war(struct si_pub *sih)\n{\n\tstruct si_info *sii = container_of(sih, struct si_info, pub);\n\tstruct bcma_device *cc;\n\n\tcc = sii->icbus->drv_cc.core;\n\n\t \n\tbcma_set32(cc, CHIPCREGOFFS(gpiocontrol), GPIO_CTRL_EPA_EN_MASK);\n}\n\n \nbool ai_deviceremoved(struct si_pub *sih)\n{\n\tu32 w = 0;\n\tstruct si_info *sii;\n\n\tsii = container_of(sih, struct si_info, pub);\n\n\tif (sii->icbus->hosttype != BCMA_HOSTTYPE_PCI)\n\t\treturn false;\n\n\tpci_read_config_dword(sii->pcibus, PCI_VENDOR_ID, &w);\n\tif ((w & 0xFFFF) != PCI_VENDOR_ID_BROADCOM)\n\t\treturn true;\n\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}