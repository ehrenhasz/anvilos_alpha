{
  "module_name": "phy_cmn.c",
  "hash_id": "d33d6d5abf3513dfaed3fdc984741f55bb7203018c748c337392d9ee83179673",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmsmac/phy/phy_cmn.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/bitops.h>\n\n#include <brcm_hw_ids.h>\n#include <chipcommon.h>\n#include <aiutils.h>\n#include <d11.h>\n#include <phy_shim.h>\n#include \"phy_hal.h\"\n#include \"phy_int.h\"\n#include \"phy_radio.h\"\n#include \"phy_lcn.h\"\n#include \"phyreg_n.h\"\n\n#define VALID_N_RADIO(radioid) ((radioid == BCM2055_ID) || \\\n\t\t\t\t (radioid == BCM2056_ID) || \\\n\t\t\t\t (radioid == BCM2057_ID))\n\n#define VALID_LCN_RADIO(radioid)\t(radioid == BCM2064_ID)\n\n#define VALID_RADIO(pi, radioid)        ( \\\n\t\t(ISNPHY(pi) ? VALID_N_RADIO(radioid) : false) || \\\n\t\t(ISLCNPHY(pi) ? VALID_LCN_RADIO(radioid) : false))\n\n \n#define MUX(pred, true, false) ((pred) ? (true) : (false))\n\n \n#define MODINC(x, bound) MUX((x) == (bound) - 1, 0, (x) + 1)\n\n \n#define MODDEC_POW2(x, bound) (((x) - 1) & ((bound) - 1))\n#define MODINC_POW2(x, bound) (((x) + 1) & ((bound) - 1))\n\nstruct chan_info_basic {\n\tu16 chan;\n\tu16 freq;\n};\n\nstatic const struct chan_info_basic chan_info_all[] = {\n\t{1, 2412},\n\t{2, 2417},\n\t{3, 2422},\n\t{4, 2427},\n\t{5, 2432},\n\t{6, 2437},\n\t{7, 2442},\n\t{8, 2447},\n\t{9, 2452},\n\t{10, 2457},\n\t{11, 2462},\n\t{12, 2467},\n\t{13, 2472},\n\t{14, 2484},\n\n\t{34, 5170},\n\t{38, 5190},\n\t{42, 5210},\n\t{46, 5230},\n\n\t{36, 5180},\n\t{40, 5200},\n\t{44, 5220},\n\t{48, 5240},\n\t{52, 5260},\n\t{56, 5280},\n\t{60, 5300},\n\t{64, 5320},\n\n\t{100, 5500},\n\t{104, 5520},\n\t{108, 5540},\n\t{112, 5560},\n\t{116, 5580},\n\t{120, 5600},\n\t{124, 5620},\n\t{128, 5640},\n\t{132, 5660},\n\t{136, 5680},\n\t{140, 5700},\n\n\t{149, 5745},\n\t{153, 5765},\n\t{157, 5785},\n\t{161, 5805},\n\t{165, 5825},\n\n\t{184, 4920},\n\t{188, 4940},\n\t{192, 4960},\n\t{196, 4980},\n\t{200, 5000},\n\t{204, 5020},\n\t{208, 5040},\n\t{212, 5060},\n\t{216, 5080}\n};\n\nstatic const u8 ofdm_rate_lookup[] = {\n\n\tBRCM_RATE_48M,\n\tBRCM_RATE_24M,\n\tBRCM_RATE_12M,\n\tBRCM_RATE_6M,\n\tBRCM_RATE_54M,\n\tBRCM_RATE_36M,\n\tBRCM_RATE_18M,\n\tBRCM_RATE_9M\n};\n\n#define PHY_WREG_LIMIT  24\n\nvoid wlc_phyreg_enter(struct brcms_phy_pub *pih)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\twlapi_bmac_ucode_wake_override_phyreg_set(pi->sh->physhim);\n}\n\nvoid wlc_phyreg_exit(struct brcms_phy_pub *pih)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\twlapi_bmac_ucode_wake_override_phyreg_clear(pi->sh->physhim);\n}\n\nvoid wlc_radioreg_enter(struct brcms_phy_pub *pih)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\twlapi_bmac_mctrl(pi->sh->physhim, MCTL_LOCK_RADIO, MCTL_LOCK_RADIO);\n\n\tudelay(10);\n}\n\nvoid wlc_radioreg_exit(struct brcms_phy_pub *pih)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\n\t(void)bcma_read16(pi->d11core, D11REGOFFS(phyversion));\n\tpi->phy_wreg = 0;\n\twlapi_bmac_mctrl(pi->sh->physhim, MCTL_LOCK_RADIO, 0);\n}\n\nu16 read_radio_reg(struct brcms_phy *pi, u16 addr)\n{\n\tu16 data;\n\n\tif (addr == RADIO_IDCODE)\n\t\treturn 0xffff;\n\n\tswitch (pi->pubpi.phy_type) {\n\tcase PHY_TYPE_N:\n\t\tif (!CONF_HAS(PHYTYPE, PHY_TYPE_N))\n\t\t\tbreak;\n\t\tif (NREV_GE(pi->pubpi.phy_rev, 7))\n\t\t\taddr |= RADIO_2057_READ_OFF;\n\t\telse\n\t\t\taddr |= RADIO_2055_READ_OFF;\n\t\tbreak;\n\n\tcase PHY_TYPE_LCN:\n\t\tif (!CONF_HAS(PHYTYPE, PHY_TYPE_LCN))\n\t\t\tbreak;\n\t\taddr |= RADIO_2064_READ_OFF;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif ((D11REV_GE(pi->sh->corerev, 24)) ||\n\t    (D11REV_IS(pi->sh->corerev, 22)\n\t     && (pi->pubpi.phy_type != PHY_TYPE_SSN))) {\n\t\tbcma_wflush16(pi->d11core, D11REGOFFS(radioregaddr), addr);\n\t\tdata = bcma_read16(pi->d11core, D11REGOFFS(radioregdata));\n\t} else {\n\t\tbcma_wflush16(pi->d11core, D11REGOFFS(phy4waddr), addr);\n\t\tdata = bcma_read16(pi->d11core, D11REGOFFS(phy4wdatalo));\n\t}\n\tpi->phy_wreg = 0;\n\n\treturn data;\n}\n\nvoid write_radio_reg(struct brcms_phy *pi, u16 addr, u16 val)\n{\n\tif ((D11REV_GE(pi->sh->corerev, 24)) ||\n\t    (D11REV_IS(pi->sh->corerev, 22)\n\t     && (pi->pubpi.phy_type != PHY_TYPE_SSN))) {\n\n\t\tbcma_wflush16(pi->d11core, D11REGOFFS(radioregaddr), addr);\n\t\tbcma_write16(pi->d11core, D11REGOFFS(radioregdata), val);\n\t} else {\n\t\tbcma_wflush16(pi->d11core, D11REGOFFS(phy4waddr), addr);\n\t\tbcma_write16(pi->d11core, D11REGOFFS(phy4wdatalo), val);\n\t}\n\n\tif ((pi->d11core->bus->hosttype == BCMA_HOSTTYPE_PCI) &&\n\t    (++pi->phy_wreg >= pi->phy_wreg_limit)) {\n\t\t(void)bcma_read32(pi->d11core, D11REGOFFS(maccontrol));\n\t\tpi->phy_wreg = 0;\n\t}\n}\n\nstatic u32 read_radio_id(struct brcms_phy *pi)\n{\n\tu32 id;\n\n\tif (D11REV_GE(pi->sh->corerev, 24)) {\n\t\tu32 b0, b1, b2;\n\n\t\tbcma_wflush16(pi->d11core, D11REGOFFS(radioregaddr), 0);\n\t\tb0 = (u32) bcma_read16(pi->d11core, D11REGOFFS(radioregdata));\n\t\tbcma_wflush16(pi->d11core, D11REGOFFS(radioregaddr), 1);\n\t\tb1 = (u32) bcma_read16(pi->d11core, D11REGOFFS(radioregdata));\n\t\tbcma_wflush16(pi->d11core, D11REGOFFS(radioregaddr), 2);\n\t\tb2 = (u32) bcma_read16(pi->d11core, D11REGOFFS(radioregdata));\n\n\t\tid = ((b0 & 0xf) << 28) | (((b2 << 8) | b1) << 12) | ((b0 >> 4)\n\t\t\t\t\t\t\t\t      & 0xf);\n\t} else {\n\t\tbcma_wflush16(pi->d11core, D11REGOFFS(phy4waddr), RADIO_IDCODE);\n\t\tid = (u32) bcma_read16(pi->d11core, D11REGOFFS(phy4wdatalo));\n\t\tid |= (u32) bcma_read16(pi->d11core,\n\t\t\t\t\tD11REGOFFS(phy4wdatahi)) << 16;\n\t}\n\tpi->phy_wreg = 0;\n\treturn id;\n}\n\nvoid and_radio_reg(struct brcms_phy *pi, u16 addr, u16 val)\n{\n\tu16 rval;\n\n\trval = read_radio_reg(pi, addr);\n\twrite_radio_reg(pi, addr, (rval & val));\n}\n\nvoid or_radio_reg(struct brcms_phy *pi, u16 addr, u16 val)\n{\n\tu16 rval;\n\n\trval = read_radio_reg(pi, addr);\n\twrite_radio_reg(pi, addr, (rval | val));\n}\n\nvoid xor_radio_reg(struct brcms_phy *pi, u16 addr, u16 mask)\n{\n\tu16 rval;\n\n\trval = read_radio_reg(pi, addr);\n\twrite_radio_reg(pi, addr, (rval ^ mask));\n}\n\nvoid mod_radio_reg(struct brcms_phy *pi, u16 addr, u16 mask, u16 val)\n{\n\tu16 rval;\n\n\trval = read_radio_reg(pi, addr);\n\twrite_radio_reg(pi, addr, (rval & ~mask) | (val & mask));\n}\n\nvoid write_phy_channel_reg(struct brcms_phy *pi, uint val)\n{\n\tbcma_write16(pi->d11core, D11REGOFFS(phychannel), val);\n}\n\nu16 read_phy_reg(struct brcms_phy *pi, u16 addr)\n{\n\tbcma_wflush16(pi->d11core, D11REGOFFS(phyregaddr), addr);\n\n\tpi->phy_wreg = 0;\n\treturn bcma_read16(pi->d11core, D11REGOFFS(phyregdata));\n}\n\nvoid write_phy_reg(struct brcms_phy *pi, u16 addr, u16 val)\n{\n#ifdef CONFIG_BCM47XX\n\tbcma_wflush16(pi->d11core, D11REGOFFS(phyregaddr), addr);\n\tbcma_write16(pi->d11core, D11REGOFFS(phyregdata), val);\n\tif (addr == 0x72)\n\t\t(void)bcma_read16(pi->d11core, D11REGOFFS(phyregdata));\n#else\n\tbcma_write32(pi->d11core, D11REGOFFS(phyregaddr), addr | (val << 16));\n\tif ((pi->d11core->bus->hosttype == BCMA_HOSTTYPE_PCI) &&\n\t    (++pi->phy_wreg >= pi->phy_wreg_limit)) {\n\t\tpi->phy_wreg = 0;\n\t\t(void)bcma_read16(pi->d11core, D11REGOFFS(phyversion));\n\t}\n#endif\n}\n\nvoid and_phy_reg(struct brcms_phy *pi, u16 addr, u16 val)\n{\n\tbcma_wflush16(pi->d11core, D11REGOFFS(phyregaddr), addr);\n\tbcma_mask16(pi->d11core, D11REGOFFS(phyregdata), val);\n\tpi->phy_wreg = 0;\n}\n\nvoid or_phy_reg(struct brcms_phy *pi, u16 addr, u16 val)\n{\n\tbcma_wflush16(pi->d11core, D11REGOFFS(phyregaddr), addr);\n\tbcma_set16(pi->d11core, D11REGOFFS(phyregdata), val);\n\tpi->phy_wreg = 0;\n}\n\nvoid mod_phy_reg(struct brcms_phy *pi, u16 addr, u16 mask, u16 val)\n{\n\tval &= mask;\n\tbcma_wflush16(pi->d11core, D11REGOFFS(phyregaddr), addr);\n\tbcma_maskset16(pi->d11core, D11REGOFFS(phyregdata), ~mask, val);\n\tpi->phy_wreg = 0;\n}\n\nstatic void wlc_set_phy_uninitted(struct brcms_phy *pi)\n{\n\tint i, j;\n\n\tpi->initialized = false;\n\n\tpi->tx_vos = 0xffff;\n\tpi->nrssi_table_delta = 0x7fffffff;\n\tpi->rc_cal = 0xffff;\n\tpi->mintxbias = 0xffff;\n\tpi->txpwridx = -1;\n\tif (ISNPHY(pi)) {\n\t\tpi->phy_spuravoid = SPURAVOID_DISABLE;\n\n\t\tif (NREV_GE(pi->pubpi.phy_rev, 3)\n\t\t    && NREV_LT(pi->pubpi.phy_rev, 7))\n\t\t\tpi->phy_spuravoid = SPURAVOID_AUTO;\n\n\t\tpi->nphy_papd_skip = 0;\n\t\tpi->nphy_papd_epsilon_offset[0] = 0xf588;\n\t\tpi->nphy_papd_epsilon_offset[1] = 0xf588;\n\t\tpi->nphy_txpwr_idx[0] = 128;\n\t\tpi->nphy_txpwr_idx[1] = 128;\n\t\tpi->nphy_txpwrindex[0].index_internal = 40;\n\t\tpi->nphy_txpwrindex[1].index_internal = 40;\n\t\tpi->phy_pabias = 0;\n\t} else {\n\t\tpi->phy_spuravoid = SPURAVOID_AUTO;\n\t}\n\tpi->radiopwr = 0xffff;\n\tfor (i = 0; i < STATIC_NUM_RF; i++) {\n\t\tfor (j = 0; j < STATIC_NUM_BB; j++)\n\t\t\tpi->stats_11b_txpower[i][j] = -1;\n\t}\n}\n\nstruct shared_phy *wlc_phy_shared_attach(struct shared_phy_params *shp)\n{\n\tstruct shared_phy *sh;\n\n\tsh = kzalloc(sizeof(struct shared_phy), GFP_ATOMIC);\n\tif (sh == NULL)\n\t\treturn NULL;\n\n\tsh->physhim = shp->physhim;\n\tsh->unit = shp->unit;\n\tsh->corerev = shp->corerev;\n\n\tsh->vid = shp->vid;\n\tsh->did = shp->did;\n\tsh->chip = shp->chip;\n\tsh->chiprev = shp->chiprev;\n\tsh->chippkg = shp->chippkg;\n\tsh->sromrev = shp->sromrev;\n\tsh->boardtype = shp->boardtype;\n\tsh->boardrev = shp->boardrev;\n\tsh->boardflags = shp->boardflags;\n\tsh->boardflags2 = shp->boardflags2;\n\n\tsh->fast_timer = PHY_SW_TIMER_FAST;\n\tsh->slow_timer = PHY_SW_TIMER_SLOW;\n\tsh->glacial_timer = PHY_SW_TIMER_GLACIAL;\n\n\tsh->rssi_mode = RSSI_ANT_MERGE_MAX;\n\n\treturn sh;\n}\n\nstatic void wlc_phy_timercb_phycal(struct brcms_phy *pi)\n{\n\tuint delay = 5;\n\n\tif (PHY_PERICAL_MPHASE_PENDING(pi)) {\n\t\tif (!pi->sh->up) {\n\t\t\twlc_phy_cal_perical_mphase_reset(pi);\n\t\t\treturn;\n\t\t}\n\n\t\tif (SCAN_RM_IN_PROGRESS(pi) || PLT_INPROG_PHY(pi)) {\n\n\t\t\tdelay = 1000;\n\t\t\twlc_phy_cal_perical_mphase_restart(pi);\n\t\t} else\n\t\t\twlc_phy_cal_perical_nphy_run(pi, PHY_PERICAL_AUTO);\n\t\twlapi_add_timer(pi->phycal_timer, delay, 0);\n\t\treturn;\n\t}\n\n}\n\nstatic u32 wlc_phy_get_radio_ver(struct brcms_phy *pi)\n{\n\tu32 ver;\n\n\tver = read_radio_id(pi);\n\n\treturn ver;\n}\n\nstruct brcms_phy_pub *\nwlc_phy_attach(struct shared_phy *sh, struct bcma_device *d11core,\n\t       int bandtype, struct wiphy *wiphy)\n{\n\tstruct brcms_phy *pi;\n\tu32 sflags = 0;\n\tuint phyversion;\n\tu32 idcode;\n\tint i;\n\n\tif (D11REV_IS(sh->corerev, 4))\n\t\tsflags = SISF_2G_PHY | SISF_5G_PHY;\n\telse\n\t\tsflags = bcma_aread32(d11core, BCMA_IOST);\n\n\tif (bandtype == BRCM_BAND_5G) {\n\t\tif ((sflags & (SISF_5G_PHY | SISF_DB_PHY)) == 0)\n\t\t\treturn NULL;\n\t}\n\n\tpi = sh->phy_head;\n\tif ((sflags & SISF_DB_PHY) && pi) {\n\t\twlapi_bmac_corereset(pi->sh->physhim, pi->pubpi.coreflags);\n\t\tpi->refcnt++;\n\t\treturn &pi->pubpi_ro;\n\t}\n\n\tpi = kzalloc(sizeof(struct brcms_phy), GFP_ATOMIC);\n\tif (pi == NULL)\n\t\treturn NULL;\n\tpi->wiphy = wiphy;\n\tpi->d11core = d11core;\n\tpi->sh = sh;\n\tpi->phy_init_por = true;\n\tpi->phy_wreg_limit = PHY_WREG_LIMIT;\n\n\tpi->txpwr_percent = 100;\n\n\tpi->do_initcal = true;\n\n\tpi->phycal_tempdelta = 0;\n\n\tif (bandtype == BRCM_BAND_2G && (sflags & SISF_2G_PHY))\n\t\tpi->pubpi.coreflags = SICF_GMODE;\n\n\twlapi_bmac_corereset(pi->sh->physhim, pi->pubpi.coreflags);\n\tphyversion = bcma_read16(pi->d11core, D11REGOFFS(phyversion));\n\n\tpi->pubpi.phy_type = PHY_TYPE(phyversion);\n\tpi->pubpi.phy_rev = phyversion & PV_PV_MASK;\n\n\tif (pi->pubpi.phy_type == PHY_TYPE_LCNXN) {\n\t\tpi->pubpi.phy_type = PHY_TYPE_N;\n\t\tpi->pubpi.phy_rev += LCNXN_BASEREV;\n\t}\n\tpi->pubpi.phy_corenum = PHY_CORE_NUM_2;\n\tpi->pubpi.ana_rev = (phyversion & PV_AV_MASK) >> PV_AV_SHIFT;\n\n\tif (pi->pubpi.phy_type != PHY_TYPE_N &&\n\t    pi->pubpi.phy_type != PHY_TYPE_LCN)\n\t\tgoto err;\n\n\tif (bandtype == BRCM_BAND_5G) {\n\t\tif (!ISNPHY(pi))\n\t\t\tgoto err;\n\t} else if (!ISNPHY(pi) && !ISLCNPHY(pi)) {\n\t\tgoto err;\n\t}\n\n\twlc_phy_anacore((struct brcms_phy_pub *) pi, ON);\n\n\tidcode = wlc_phy_get_radio_ver(pi);\n\tpi->pubpi.radioid =\n\t\t(idcode & IDCODE_ID_MASK) >> IDCODE_ID_SHIFT;\n\tpi->pubpi.radiorev =\n\t\t(idcode & IDCODE_REV_MASK) >> IDCODE_REV_SHIFT;\n\tpi->pubpi.radiover =\n\t\t(idcode & IDCODE_VER_MASK) >> IDCODE_VER_SHIFT;\n\tif (!VALID_RADIO(pi, pi->pubpi.radioid))\n\t\tgoto err;\n\n\twlc_phy_switch_radio((struct brcms_phy_pub *) pi, OFF);\n\n\twlc_set_phy_uninitted(pi);\n\n\tpi->bw = WL_CHANSPEC_BW_20;\n\tpi->radio_chanspec = (bandtype == BRCM_BAND_2G) ?\n\t\t\t     ch20mhz_chspec(1) : ch20mhz_chspec(36);\n\n\tpi->rxiq_samps = PHY_NOISE_SAMPLE_LOG_NUM_NPHY;\n\tpi->rxiq_antsel = ANT_RX_DIV_DEF;\n\n\tpi->watchdog_override = true;\n\n\tpi->cal_type_override = PHY_PERICAL_AUTO;\n\n\tpi->nphy_saved_noisevars.bufcount = 0;\n\n\tif (ISNPHY(pi))\n\t\tpi->min_txpower = PHY_TXPWR_MIN_NPHY;\n\telse\n\t\tpi->min_txpower = PHY_TXPWR_MIN;\n\n\tpi->sh->phyrxchain = 0x3;\n\n\tpi->rx2tx_biasentry = -1;\n\n\tpi->phy_txcore_disable_temp = PHY_CHAIN_TX_DISABLE_TEMP;\n\tpi->phy_txcore_enable_temp =\n\t\tPHY_CHAIN_TX_DISABLE_TEMP - PHY_HYSTERESIS_DELTATEMP;\n\tpi->phy_tempsense_offset = 0;\n\tpi->phy_txcore_heatedup = false;\n\n\tpi->nphy_lastcal_temp = -50;\n\n\tpi->phynoise_polling = true;\n\tif (ISNPHY(pi) || ISLCNPHY(pi))\n\t\tpi->phynoise_polling = false;\n\n\tfor (i = 0; i < TXP_NUM_RATES; i++) {\n\t\tpi->txpwr_limit[i] = BRCMS_TXPWR_MAX;\n\t\tpi->txpwr_env_limit[i] = BRCMS_TXPWR_MAX;\n\t\tpi->tx_user_target[i] = BRCMS_TXPWR_MAX;\n\t}\n\n\tpi->radiopwr_override = RADIOPWR_OVERRIDE_DEF;\n\n\tpi->user_txpwr_at_rfport = false;\n\n\tif (ISNPHY(pi)) {\n\n\t\tpi->phycal_timer = wlapi_init_timer(pi->sh->physhim,\n\t\t\t\t\t\t    wlc_phy_timercb_phycal,\n\t\t\t\t\t\t    pi, \"phycal\");\n\t\tif (!pi->phycal_timer)\n\t\t\tgoto err;\n\n\t\tif (!wlc_phy_attach_nphy(pi))\n\t\t\tgoto err;\n\n\t} else if (ISLCNPHY(pi)) {\n\t\tif (!wlc_phy_attach_lcnphy(pi))\n\t\t\tgoto err;\n\n\t}\n\n\tpi->refcnt++;\n\tpi->next = pi->sh->phy_head;\n\tsh->phy_head = pi;\n\n\tmemcpy(&pi->pubpi_ro, &pi->pubpi, sizeof(struct brcms_phy_pub));\n\n\treturn &pi->pubpi_ro;\n\nerr:\n\tkfree(pi);\n\treturn NULL;\n}\n\nvoid wlc_phy_detach(struct brcms_phy_pub *pih)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\n\tif (pih) {\n\t\tif (--pi->refcnt)\n\t\t\treturn;\n\n\t\tif (pi->phycal_timer) {\n\t\t\twlapi_free_timer(pi->phycal_timer);\n\t\t\tpi->phycal_timer = NULL;\n\t\t}\n\n\t\tif (pi->sh->phy_head == pi)\n\t\t\tpi->sh->phy_head = pi->next;\n\t\telse if (pi->sh->phy_head->next == pi)\n\t\t\tpi->sh->phy_head->next = NULL;\n\n\t\tif (pi->pi_fptr.detach)\n\t\t\t(pi->pi_fptr.detach)(pi);\n\n\t\tkfree(pi);\n\t}\n}\n\nbool\nwlc_phy_get_phyversion(struct brcms_phy_pub *pih, u16 *phytype, u16 *phyrev,\n\t\t       u16 *radioid, u16 *radiover)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\t*phytype = (u16) pi->pubpi.phy_type;\n\t*phyrev = (u16) pi->pubpi.phy_rev;\n\t*radioid = pi->pubpi.radioid;\n\t*radiover = pi->pubpi.radiorev;\n\n\treturn true;\n}\n\nbool wlc_phy_get_encore(struct brcms_phy_pub *pih)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\treturn pi->pubpi.abgphy_encore;\n}\n\nu32 wlc_phy_get_coreflags(struct brcms_phy_pub *pih)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\treturn pi->pubpi.coreflags;\n}\n\nvoid wlc_phy_anacore(struct brcms_phy_pub *pih, bool on)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\n\tif (ISNPHY(pi)) {\n\t\tif (on) {\n\t\t\tif (NREV_GE(pi->pubpi.phy_rev, 3)) {\n\t\t\t\twrite_phy_reg(pi, 0xa6, 0x0d);\n\t\t\t\twrite_phy_reg(pi, 0x8f, 0x0);\n\t\t\t\twrite_phy_reg(pi, 0xa7, 0x0d);\n\t\t\t\twrite_phy_reg(pi, 0xa5, 0x0);\n\t\t\t} else {\n\t\t\t\twrite_phy_reg(pi, 0xa5, 0x0);\n\t\t\t}\n\t\t} else {\n\t\t\tif (NREV_GE(pi->pubpi.phy_rev, 3)) {\n\t\t\t\twrite_phy_reg(pi, 0x8f, 0x07ff);\n\t\t\t\twrite_phy_reg(pi, 0xa6, 0x0fd);\n\t\t\t\twrite_phy_reg(pi, 0xa5, 0x07ff);\n\t\t\t\twrite_phy_reg(pi, 0xa7, 0x0fd);\n\t\t\t} else {\n\t\t\t\twrite_phy_reg(pi, 0xa5, 0x7fff);\n\t\t\t}\n\t\t}\n\t} else if (ISLCNPHY(pi)) {\n\t\tif (on) {\n\t\t\tand_phy_reg(pi, 0x43b,\n\t\t\t\t    ~((0x1 << 0) | (0x1 << 1) | (0x1 << 2)));\n\t\t} else {\n\t\t\tor_phy_reg(pi, 0x43c,\n\t\t\t\t   (0x1 << 0) | (0x1 << 1) | (0x1 << 2));\n\t\t\tor_phy_reg(pi, 0x43b,\n\t\t\t\t   (0x1 << 0) | (0x1 << 1) | (0x1 << 2));\n\t\t}\n\t}\n}\n\nu32 wlc_phy_clk_bwbits(struct brcms_phy_pub *pih)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\n\tu32 phy_bw_clkbits = 0;\n\n\tif (pi && (ISNPHY(pi) || ISLCNPHY(pi))) {\n\t\tswitch (pi->bw) {\n\t\tcase WL_CHANSPEC_BW_10:\n\t\t\tphy_bw_clkbits = SICF_BW10;\n\t\t\tbreak;\n\t\tcase WL_CHANSPEC_BW_20:\n\t\t\tphy_bw_clkbits = SICF_BW20;\n\t\t\tbreak;\n\t\tcase WL_CHANSPEC_BW_40:\n\t\t\tphy_bw_clkbits = SICF_BW40;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn phy_bw_clkbits;\n}\n\nvoid wlc_phy_por_inform(struct brcms_phy_pub *ppi)\n{\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\n\tpi->phy_init_por = true;\n}\n\nvoid wlc_phy_edcrs_lock(struct brcms_phy_pub *pih, bool lock)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\n\tpi->edcrs_threshold_lock = lock;\n\n\twrite_phy_reg(pi, 0x22c, 0x46b);\n\twrite_phy_reg(pi, 0x22d, 0x46b);\n\twrite_phy_reg(pi, 0x22e, 0x3c0);\n\twrite_phy_reg(pi, 0x22f, 0x3c0);\n}\n\nvoid wlc_phy_initcal_enable(struct brcms_phy_pub *pih, bool initcal)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\n\tpi->do_initcal = initcal;\n}\n\nvoid wlc_phy_hw_clk_state_upd(struct brcms_phy_pub *pih, bool newstate)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\n\tif (!pi || !pi->sh)\n\t\treturn;\n\n\tpi->sh->clk = newstate;\n}\n\nvoid wlc_phy_hw_state_upd(struct brcms_phy_pub *pih, bool newstate)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\n\tif (!pi || !pi->sh)\n\t\treturn;\n\n\tpi->sh->up = newstate;\n}\n\nvoid wlc_phy_init(struct brcms_phy_pub *pih, u16 chanspec)\n{\n\tu32 mc;\n\tvoid (*phy_init)(struct brcms_phy *) = NULL;\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\n\tif (pi->init_in_progress)\n\t\treturn;\n\n\tpi->init_in_progress = true;\n\n\tpi->radio_chanspec = chanspec;\n\n\tmc = bcma_read32(pi->d11core, D11REGOFFS(maccontrol));\n\tif (WARN(mc & MCTL_EN_MAC, \"HW error MAC running on init\"))\n\t\treturn;\n\n\tif (!(pi->measure_hold & PHY_HOLD_FOR_SCAN))\n\t\tpi->measure_hold |= PHY_HOLD_FOR_NOT_ASSOC;\n\n\tif (WARN(!(bcma_aread32(pi->d11core, BCMA_IOST) & SISF_FCLKA),\n\t\t \"HW error SISF_FCLKA\\n\"))\n\t\treturn;\n\n\tphy_init = pi->pi_fptr.init;\n\n\tif (phy_init == NULL)\n\t\treturn;\n\n\twlc_phy_anacore(pih, ON);\n\n\tif (CHSPEC_BW(pi->radio_chanspec) != pi->bw)\n\t\twlapi_bmac_bw_set(pi->sh->physhim,\n\t\t\t\t  CHSPEC_BW(pi->radio_chanspec));\n\n\tpi->nphy_gain_boost = true;\n\n\twlc_phy_switch_radio((struct brcms_phy_pub *) pi, ON);\n\n\t(*phy_init)(pi);\n\n\tpi->phy_init_por = false;\n\n\tif (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12))\n\t\twlc_phy_do_dummy_tx(pi, true, OFF);\n\n\tif (!(ISNPHY(pi)))\n\t\twlc_phy_txpower_update_shm(pi);\n\n\twlc_phy_ant_rxdiv_set((struct brcms_phy_pub *) pi, pi->sh->rx_antdiv);\n\n\tpi->init_in_progress = false;\n}\n\nvoid wlc_phy_cal_init(struct brcms_phy_pub *pih)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\tvoid (*cal_init)(struct brcms_phy *) = NULL;\n\n\tif (WARN((bcma_read32(pi->d11core, D11REGOFFS(maccontrol)) &\n\t\t  MCTL_EN_MAC) != 0, \"HW error: MAC enabled during phy cal\\n\"))\n\t\treturn;\n\n\tif (!pi->initialized) {\n\t\tcal_init = pi->pi_fptr.calinit;\n\t\tif (cal_init)\n\t\t\t(*cal_init)(pi);\n\n\t\tpi->initialized = true;\n\t}\n}\n\nint wlc_phy_down(struct brcms_phy_pub *pih)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\tint callbacks = 0;\n\n\tif (pi->phycal_timer\n\t    && !wlapi_del_timer(pi->phycal_timer))\n\t\tcallbacks++;\n\n\tpi->nphy_iqcal_chanspec_2G = 0;\n\tpi->nphy_iqcal_chanspec_5G = 0;\n\n\treturn callbacks;\n}\n\nvoid\nwlc_phy_table_addr(struct brcms_phy *pi, uint tbl_id, uint tbl_offset,\n\t\t   u16 tblAddr, u16 tblDataHi, u16 tblDataLo)\n{\n\twrite_phy_reg(pi, tblAddr, (tbl_id << 10) | tbl_offset);\n\n\tpi->tbl_data_hi = tblDataHi;\n\tpi->tbl_data_lo = tblDataLo;\n\n\tif (pi->sh->chip == BCMA_CHIP_ID_BCM43224 &&\n\t    pi->sh->chiprev == 1) {\n\t\tpi->tbl_addr = tblAddr;\n\t\tpi->tbl_save_id = tbl_id;\n\t\tpi->tbl_save_offset = tbl_offset;\n\t}\n}\n\nvoid wlc_phy_table_data_write(struct brcms_phy *pi, uint width, u32 val)\n{\n\tif ((pi->sh->chip == BCMA_CHIP_ID_BCM43224) &&\n\t    (pi->sh->chiprev == 1) &&\n\t    (pi->tbl_save_id == NPHY_TBL_ID_ANTSWCTRLLUT)) {\n\t\tread_phy_reg(pi, pi->tbl_data_lo);\n\n\t\twrite_phy_reg(pi, pi->tbl_addr,\n\t\t\t      (pi->tbl_save_id << 10) | pi->tbl_save_offset);\n\t\tpi->tbl_save_offset++;\n\t}\n\n\tif (width == 32) {\n\t\twrite_phy_reg(pi, pi->tbl_data_hi, (u16) (val >> 16));\n\t\twrite_phy_reg(pi, pi->tbl_data_lo, (u16) val);\n\t} else {\n\t\twrite_phy_reg(pi, pi->tbl_data_lo, (u16) val);\n\t}\n}\n\nvoid\nwlc_phy_write_table(struct brcms_phy *pi, const struct phytbl_info *ptbl_info,\n\t\t    u16 tblAddr, u16 tblDataHi, u16 tblDataLo)\n{\n\tuint idx;\n\tuint tbl_id = ptbl_info->tbl_id;\n\tuint tbl_offset = ptbl_info->tbl_offset;\n\tuint tbl_width = ptbl_info->tbl_width;\n\tconst u8 *ptbl_8b = (const u8 *)ptbl_info->tbl_ptr;\n\tconst u16 *ptbl_16b = (const u16 *)ptbl_info->tbl_ptr;\n\tconst u32 *ptbl_32b = (const u32 *)ptbl_info->tbl_ptr;\n\n\twrite_phy_reg(pi, tblAddr, (tbl_id << 10) | tbl_offset);\n\n\tfor (idx = 0; idx < ptbl_info->tbl_len; idx++) {\n\n\t\tif ((pi->sh->chip == BCMA_CHIP_ID_BCM43224) &&\n\t\t    (pi->sh->chiprev == 1) &&\n\t\t    (tbl_id == NPHY_TBL_ID_ANTSWCTRLLUT)) {\n\t\t\tread_phy_reg(pi, tblDataLo);\n\n\t\t\twrite_phy_reg(pi, tblAddr,\n\t\t\t\t      (tbl_id << 10) | (tbl_offset + idx));\n\t\t}\n\n\t\tif (tbl_width == 32) {\n\t\t\twrite_phy_reg(pi, tblDataHi,\n\t\t\t\t      (u16) (ptbl_32b[idx] >> 16));\n\t\t\twrite_phy_reg(pi, tblDataLo, (u16) ptbl_32b[idx]);\n\t\t} else if (tbl_width == 16) {\n\t\t\twrite_phy_reg(pi, tblDataLo, ptbl_16b[idx]);\n\t\t} else {\n\t\t\twrite_phy_reg(pi, tblDataLo, ptbl_8b[idx]);\n\t\t}\n\t}\n}\n\nvoid\nwlc_phy_read_table(struct brcms_phy *pi, const struct phytbl_info *ptbl_info,\n\t\t   u16 tblAddr, u16 tblDataHi, u16 tblDataLo)\n{\n\tuint idx;\n\tuint tbl_id = ptbl_info->tbl_id;\n\tuint tbl_offset = ptbl_info->tbl_offset;\n\tuint tbl_width = ptbl_info->tbl_width;\n\tu8 *ptbl_8b = (u8 *)ptbl_info->tbl_ptr;\n\tu16 *ptbl_16b = (u16 *)ptbl_info->tbl_ptr;\n\tu32 *ptbl_32b = (u32 *)ptbl_info->tbl_ptr;\n\n\twrite_phy_reg(pi, tblAddr, (tbl_id << 10) | tbl_offset);\n\n\tfor (idx = 0; idx < ptbl_info->tbl_len; idx++) {\n\n\t\tif ((pi->sh->chip == BCMA_CHIP_ID_BCM43224) &&\n\t\t    (pi->sh->chiprev == 1)) {\n\t\t\t(void)read_phy_reg(pi, tblDataLo);\n\n\t\t\twrite_phy_reg(pi, tblAddr,\n\t\t\t\t      (tbl_id << 10) | (tbl_offset + idx));\n\t\t}\n\n\t\tif (tbl_width == 32) {\n\t\t\tptbl_32b[idx] = read_phy_reg(pi, tblDataLo);\n\t\t\tptbl_32b[idx] |= (read_phy_reg(pi, tblDataHi) << 16);\n\t\t} else if (tbl_width == 16) {\n\t\t\tptbl_16b[idx] = read_phy_reg(pi, tblDataLo);\n\t\t} else {\n\t\t\tptbl_8b[idx] = (u8) read_phy_reg(pi, tblDataLo);\n\t\t}\n\t}\n}\n\nuint\nwlc_phy_init_radio_regs_allbands(struct brcms_phy *pi,\n\t\t\t\t struct radio_20xx_regs *radioregs)\n{\n\tuint i = 0;\n\n\tdo {\n\t\tif (radioregs[i].do_init)\n\t\t\twrite_radio_reg(pi, radioregs[i].address,\n\t\t\t\t\t(u16) radioregs[i].init);\n\n\t\ti++;\n\t} while (radioregs[i].address != 0xffff);\n\n\treturn i;\n}\n\nuint\nwlc_phy_init_radio_regs(struct brcms_phy *pi,\n\t\t\tconst struct radio_regs *radioregs,\n\t\t\tu16 core_offset)\n{\n\tuint i = 0;\n\tuint count = 0;\n\n\tdo {\n\t\tif (CHSPEC_IS5G(pi->radio_chanspec)) {\n\t\t\tif (radioregs[i].do_init_a) {\n\t\t\t\twrite_radio_reg(pi,\n\t\t\t\t\t\tradioregs[i].\n\t\t\t\t\t\taddress | core_offset,\n\t\t\t\t\t\t(u16) radioregs[i].init_a);\n\t\t\t\tif (ISNPHY(pi) && (++count % 4 == 0))\n\t\t\t\t\tBRCMS_PHY_WAR_PR51571(pi);\n\t\t\t}\n\t\t} else {\n\t\t\tif (radioregs[i].do_init_g) {\n\t\t\t\twrite_radio_reg(pi,\n\t\t\t\t\t\tradioregs[i].\n\t\t\t\t\t\taddress | core_offset,\n\t\t\t\t\t\t(u16) radioregs[i].init_g);\n\t\t\t\tif (ISNPHY(pi) && (++count % 4 == 0))\n\t\t\t\t\tBRCMS_PHY_WAR_PR51571(pi);\n\t\t\t}\n\t\t}\n\n\t\ti++;\n\t} while (radioregs[i].address != 0xffff);\n\n\treturn i;\n}\n\nvoid wlc_phy_do_dummy_tx(struct brcms_phy *pi, bool ofdm, bool pa_on)\n{\n#define DUMMY_PKT_LEN   20\n\tstruct bcma_device *core = pi->d11core;\n\tint i, count;\n\tu8 ofdmpkt[DUMMY_PKT_LEN] = {\n\t\t0xcc, 0x01, 0x02, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00\n\t};\n\tu8 cckpkt[DUMMY_PKT_LEN] = {\n\t\t0x6e, 0x84, 0x0b, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00\n\t};\n\tu32 *dummypkt;\n\n\tdummypkt = (u32 *) (ofdm ? ofdmpkt : cckpkt);\n\twlapi_bmac_write_template_ram(pi->sh->physhim, 0, DUMMY_PKT_LEN,\n\t\t\t\t      dummypkt);\n\n\tbcma_write16(core, D11REGOFFS(xmtsel), 0);\n\n\tif (D11REV_GE(pi->sh->corerev, 11))\n\t\tbcma_write16(core, D11REGOFFS(wepctl), 0x100);\n\telse\n\t\tbcma_write16(core, D11REGOFFS(wepctl), 0);\n\n\tbcma_write16(core, D11REGOFFS(txe_phyctl),\n\t\t     (ofdm ? 1 : 0) | PHY_TXC_ANT_0);\n\tif (ISNPHY(pi) || ISLCNPHY(pi))\n\t\tbcma_write16(core, D11REGOFFS(txe_phyctl1), 0x1A02);\n\n\tbcma_write16(core, D11REGOFFS(txe_wm_0), 0);\n\tbcma_write16(core, D11REGOFFS(txe_wm_1), 0);\n\n\tbcma_write16(core, D11REGOFFS(xmttplatetxptr), 0);\n\tbcma_write16(core, D11REGOFFS(xmttxcnt), DUMMY_PKT_LEN);\n\n\tbcma_write16(core, D11REGOFFS(xmtsel),\n\t\t     ((8 << 8) | (1 << 5) | (1 << 2) | 2));\n\n\tbcma_write16(core, D11REGOFFS(txe_ctl), 0);\n\n\tif (!pa_on) {\n\t\tif (ISNPHY(pi))\n\t\t\twlc_phy_pa_override_nphy(pi, OFF);\n\t}\n\n\tif (ISNPHY(pi) || ISLCNPHY(pi))\n\t\tbcma_write16(core, D11REGOFFS(txe_aux), 0xD0);\n\telse\n\t\tbcma_write16(core, D11REGOFFS(txe_aux), ((1 << 5) | (1 << 4)));\n\n\t(void)bcma_read16(core, D11REGOFFS(txe_aux));\n\n\ti = 0;\n\tcount = ofdm ? 30 : 250;\n\twhile ((i++ < count)\n\t       && (bcma_read16(core, D11REGOFFS(txe_status)) & (1 << 7)))\n\t\tudelay(10);\n\n\ti = 0;\n\n\twhile ((i++ < 10) &&\n\t       ((bcma_read16(core, D11REGOFFS(txe_status)) & (1 << 10)) == 0))\n\t\tudelay(10);\n\n\ti = 0;\n\n\twhile ((i++ < 10) &&\n\t       ((bcma_read16(core, D11REGOFFS(ifsstat)) & (1 << 8))))\n\t\tudelay(10);\n\n\tif (!pa_on) {\n\t\tif (ISNPHY(pi))\n\t\t\twlc_phy_pa_override_nphy(pi, ON);\n\t}\n}\n\nvoid wlc_phy_hold_upd(struct brcms_phy_pub *pih, u32 id, bool set)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\n\tif (set)\n\t\tmboolset(pi->measure_hold, id);\n\telse\n\t\tmboolclr(pi->measure_hold, id);\n\n\treturn;\n}\n\nvoid wlc_phy_mute_upd(struct brcms_phy_pub *pih, bool mute, u32 flags)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\n\tif (mute)\n\t\tmboolset(pi->measure_hold, PHY_HOLD_FOR_MUTE);\n\telse\n\t\tmboolclr(pi->measure_hold, PHY_HOLD_FOR_MUTE);\n\n\tif (!mute && (flags & PHY_MUTE_FOR_PREISM))\n\t\tpi->nphy_perical_last = pi->sh->now - pi->sh->glacial_timer;\n\treturn;\n}\n\nvoid wlc_phy_clear_tssi(struct brcms_phy_pub *pih)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\n\tif (ISNPHY(pi)) {\n\t\treturn;\n\t} else {\n\t\twlapi_bmac_write_shm(pi->sh->physhim, M_B_TSSI_0, NULL_TSSI_W);\n\t\twlapi_bmac_write_shm(pi->sh->physhim, M_B_TSSI_1, NULL_TSSI_W);\n\t\twlapi_bmac_write_shm(pi->sh->physhim, M_G_TSSI_0, NULL_TSSI_W);\n\t\twlapi_bmac_write_shm(pi->sh->physhim, M_G_TSSI_1, NULL_TSSI_W);\n\t}\n}\n\nstatic bool wlc_phy_cal_txpower_recalc_sw(struct brcms_phy *pi)\n{\n\treturn false;\n}\n\nvoid wlc_phy_switch_radio(struct brcms_phy_pub *pih, bool on)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\t(void)bcma_read32(pi->d11core, D11REGOFFS(maccontrol));\n\n\tif (ISNPHY(pi)) {\n\t\twlc_phy_switch_radio_nphy(pi, on);\n\t} else if (ISLCNPHY(pi)) {\n\t\tif (on) {\n\t\t\tand_phy_reg(pi, 0x44c,\n\t\t\t\t    ~((0x1 << 8) |\n\t\t\t\t      (0x1 << 9) |\n\t\t\t\t      (0x1 << 10) | (0x1 << 11) | (0x1 << 12)));\n\t\t\tand_phy_reg(pi, 0x4b0, ~((0x1 << 3) | (0x1 << 11)));\n\t\t\tand_phy_reg(pi, 0x4f9, ~(0x1 << 3));\n\t\t} else {\n\t\t\tand_phy_reg(pi, 0x44d,\n\t\t\t\t    ~((0x1 << 10) |\n\t\t\t\t      (0x1 << 11) |\n\t\t\t\t      (0x1 << 12) | (0x1 << 13) | (0x1 << 14)));\n\t\t\tor_phy_reg(pi, 0x44c,\n\t\t\t\t   (0x1 << 8) |\n\t\t\t\t   (0x1 << 9) |\n\t\t\t\t   (0x1 << 10) | (0x1 << 11) | (0x1 << 12));\n\n\t\t\tand_phy_reg(pi, 0x4b7, ~((0x7f << 8)));\n\t\t\tand_phy_reg(pi, 0x4b1, ~((0x1 << 13)));\n\t\t\tor_phy_reg(pi, 0x4b0, (0x1 << 3) | (0x1 << 11));\n\t\t\tand_phy_reg(pi, 0x4fa, ~((0x1 << 3)));\n\t\t\tor_phy_reg(pi, 0x4f9, (0x1 << 3));\n\t\t}\n\t}\n}\n\nu16 wlc_phy_bw_state_get(struct brcms_phy_pub *ppi)\n{\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\n\treturn pi->bw;\n}\n\nvoid wlc_phy_bw_state_set(struct brcms_phy_pub *ppi, u16 bw)\n{\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\n\tpi->bw = bw;\n}\n\nvoid wlc_phy_chanspec_radio_set(struct brcms_phy_pub *ppi, u16 newch)\n{\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\tpi->radio_chanspec = newch;\n\n}\n\nu16 wlc_phy_chanspec_get(struct brcms_phy_pub *ppi)\n{\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\n\treturn pi->radio_chanspec;\n}\n\nvoid wlc_phy_chanspec_set(struct brcms_phy_pub *ppi, u16 chanspec)\n{\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\tu16 m_cur_channel;\n\tvoid (*chanspec_set)(struct brcms_phy *, u16) = NULL;\n\tm_cur_channel = CHSPEC_CHANNEL(chanspec);\n\tif (CHSPEC_IS5G(chanspec))\n\t\tm_cur_channel |= D11_CURCHANNEL_5G;\n\tif (CHSPEC_IS40(chanspec))\n\t\tm_cur_channel |= D11_CURCHANNEL_40;\n\twlapi_bmac_write_shm(pi->sh->physhim, M_CURCHANNEL, m_cur_channel);\n\n\tchanspec_set = pi->pi_fptr.chanset;\n\tif (chanspec_set)\n\t\t(*chanspec_set)(pi, chanspec);\n\n}\n\nint wlc_phy_chanspec_freq2bandrange_lpssn(uint freq)\n{\n\tint range = -1;\n\n\tif (freq < 2500)\n\t\trange = WL_CHAN_FREQ_RANGE_2G;\n\telse if (freq <= 5320)\n\t\trange = WL_CHAN_FREQ_RANGE_5GL;\n\telse if (freq <= 5700)\n\t\trange = WL_CHAN_FREQ_RANGE_5GM;\n\telse\n\t\trange = WL_CHAN_FREQ_RANGE_5GH;\n\n\treturn range;\n}\n\nint wlc_phy_chanspec_bandrange_get(struct brcms_phy *pi, u16 chanspec)\n{\n\tint range = -1;\n\tuint channel = CHSPEC_CHANNEL(chanspec);\n\tuint freq = wlc_phy_channel2freq(channel);\n\n\tif (ISNPHY(pi))\n\t\trange = wlc_phy_get_chan_freq_range_nphy(pi, channel);\n\telse if (ISLCNPHY(pi))\n\t\trange = wlc_phy_chanspec_freq2bandrange_lpssn(freq);\n\n\treturn range;\n}\n\nvoid wlc_phy_chanspec_ch14_widefilter_set(struct brcms_phy_pub *ppi,\n\t\t\t\t\t  bool wide_filter)\n{\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\n\tpi->channel_14_wide_filter = wide_filter;\n\n}\n\nint wlc_phy_channel2freq(uint channel)\n{\n\tuint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(chan_info_all); i++)\n\t\tif (chan_info_all[i].chan == channel)\n\t\t\treturn chan_info_all[i].freq;\n\treturn 0;\n}\n\nvoid\nwlc_phy_chanspec_band_validch(struct brcms_phy_pub *ppi, uint band,\n\t\t\t      struct brcms_chanvec *channels)\n{\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\tuint i;\n\tuint channel;\n\n\tmemset(channels, 0, sizeof(struct brcms_chanvec));\n\n\tfor (i = 0; i < ARRAY_SIZE(chan_info_all); i++) {\n\t\tchannel = chan_info_all[i].chan;\n\n\t\tif ((pi->a_band_high_disable) && (channel >= FIRST_REF5_CHANNUM)\n\t\t    && (channel <= LAST_REF5_CHANNUM))\n\t\t\tcontinue;\n\n\t\tif ((band == BRCM_BAND_2G && channel <= CH_MAX_2G_CHANNEL) ||\n\t\t    (band == BRCM_BAND_5G && channel > CH_MAX_2G_CHANNEL))\n\t\t\tsetbit(channels->vec, channel);\n\t}\n}\n\nu16 wlc_phy_chanspec_band_firstch(struct brcms_phy_pub *ppi, uint band)\n{\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\tuint i;\n\tuint channel;\n\tu16 chspec;\n\n\tfor (i = 0; i < ARRAY_SIZE(chan_info_all); i++) {\n\t\tchannel = chan_info_all[i].chan;\n\n\t\tif (ISNPHY(pi) && pi->bw == WL_CHANSPEC_BW_40) {\n\t\t\tuint j;\n\n\t\t\tfor (j = 0; j < ARRAY_SIZE(chan_info_all); j++) {\n\t\t\t\tif (chan_info_all[j].chan ==\n\t\t\t\t    channel + CH_10MHZ_APART)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (j == ARRAY_SIZE(chan_info_all))\n\t\t\t\tcontinue;\n\n\t\t\tchannel = upper_20_sb(channel);\n\t\t\tchspec =  channel | WL_CHANSPEC_BW_40 |\n\t\t\t\t  WL_CHANSPEC_CTL_SB_LOWER;\n\t\t\tif (band == BRCM_BAND_2G)\n\t\t\t\tchspec |= WL_CHANSPEC_BAND_2G;\n\t\t\telse\n\t\t\t\tchspec |= WL_CHANSPEC_BAND_5G;\n\t\t} else\n\t\t\tchspec = ch20mhz_chspec(channel);\n\n\t\tif ((pi->a_band_high_disable) && (channel >= FIRST_REF5_CHANNUM)\n\t\t    && (channel <= LAST_REF5_CHANNUM))\n\t\t\tcontinue;\n\n\t\tif ((band == BRCM_BAND_2G && channel <= CH_MAX_2G_CHANNEL) ||\n\t\t    (band == BRCM_BAND_5G && channel > CH_MAX_2G_CHANNEL))\n\t\t\treturn chspec;\n\t}\n\n\treturn (u16) INVCHANSPEC;\n}\n\nint wlc_phy_txpower_get(struct brcms_phy_pub *ppi, uint *qdbm, bool *override)\n{\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\n\t*qdbm = pi->tx_user_target[0];\n\tif (override != NULL)\n\t\t*override = pi->txpwroverride;\n\treturn 0;\n}\n\nvoid wlc_phy_txpower_target_set(struct brcms_phy_pub *ppi,\n\t\t\t\tstruct txpwr_limits *txpwr)\n{\n\tbool mac_enabled = false;\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\n\tmemcpy(&pi->tx_user_target[TXP_FIRST_CCK],\n\t       &txpwr->cck[0], BRCMS_NUM_RATES_CCK);\n\n\tmemcpy(&pi->tx_user_target[TXP_FIRST_OFDM],\n\t       &txpwr->ofdm[0], BRCMS_NUM_RATES_OFDM);\n\tmemcpy(&pi->tx_user_target[TXP_FIRST_OFDM_20_CDD],\n\t       &txpwr->ofdm_cdd[0], BRCMS_NUM_RATES_OFDM);\n\n\tmemcpy(&pi->tx_user_target[TXP_FIRST_OFDM_40_SISO],\n\t       &txpwr->ofdm_40_siso[0], BRCMS_NUM_RATES_OFDM);\n\tmemcpy(&pi->tx_user_target[TXP_FIRST_OFDM_40_CDD],\n\t       &txpwr->ofdm_40_cdd[0], BRCMS_NUM_RATES_OFDM);\n\n\tmemcpy(&pi->tx_user_target[TXP_FIRST_MCS_20_SISO],\n\t       &txpwr->mcs_20_siso[0], BRCMS_NUM_RATES_MCS_1_STREAM);\n\tmemcpy(&pi->tx_user_target[TXP_FIRST_MCS_20_CDD],\n\t       &txpwr->mcs_20_cdd[0], BRCMS_NUM_RATES_MCS_1_STREAM);\n\tmemcpy(&pi->tx_user_target[TXP_FIRST_MCS_20_STBC],\n\t       &txpwr->mcs_20_stbc[0], BRCMS_NUM_RATES_MCS_1_STREAM);\n\tmemcpy(&pi->tx_user_target[TXP_FIRST_MCS_20_SDM],\n\t       &txpwr->mcs_20_mimo[0], BRCMS_NUM_RATES_MCS_2_STREAM);\n\n\tmemcpy(&pi->tx_user_target[TXP_FIRST_MCS_40_SISO],\n\t       &txpwr->mcs_40_siso[0], BRCMS_NUM_RATES_MCS_1_STREAM);\n\tmemcpy(&pi->tx_user_target[TXP_FIRST_MCS_40_CDD],\n\t       &txpwr->mcs_40_cdd[0], BRCMS_NUM_RATES_MCS_1_STREAM);\n\tmemcpy(&pi->tx_user_target[TXP_FIRST_MCS_40_STBC],\n\t       &txpwr->mcs_40_stbc[0], BRCMS_NUM_RATES_MCS_1_STREAM);\n\tmemcpy(&pi->tx_user_target[TXP_FIRST_MCS_40_SDM],\n\t       &txpwr->mcs_40_mimo[0], BRCMS_NUM_RATES_MCS_2_STREAM);\n\n\tif (bcma_read32(pi->d11core, D11REGOFFS(maccontrol)) & MCTL_EN_MAC)\n\t\tmac_enabled = true;\n\n\tif (mac_enabled)\n\t\twlapi_suspend_mac_and_wait(pi->sh->physhim);\n\n\twlc_phy_txpower_recalc_target(pi);\n\twlc_phy_cal_txpower_recalc_sw(pi);\n\n\tif (mac_enabled)\n\t\twlapi_enable_mac(pi->sh->physhim);\n}\n\nint wlc_phy_txpower_set(struct brcms_phy_pub *ppi, uint qdbm, bool override)\n{\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\tint i;\n\n\tif (qdbm > 127)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < TXP_NUM_RATES; i++)\n\t\tpi->tx_user_target[i] = (u8) qdbm;\n\n\tpi->txpwroverride = false;\n\n\tif (pi->sh->up) {\n\t\tif (!SCAN_INPROG_PHY(pi)) {\n\t\t\tbool suspend;\n\n\t\t\tsuspend = (0 == (bcma_read32(pi->d11core,\n\t\t\t\t\t\t     D11REGOFFS(maccontrol)) &\n\t\t\t\t\t MCTL_EN_MAC));\n\n\t\t\tif (!suspend)\n\t\t\t\twlapi_suspend_mac_and_wait(pi->sh->physhim);\n\n\t\t\twlc_phy_txpower_recalc_target(pi);\n\t\t\twlc_phy_cal_txpower_recalc_sw(pi);\n\n\t\t\tif (!suspend)\n\t\t\t\twlapi_enable_mac(pi->sh->physhim);\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid\nwlc_phy_txpower_sromlimit(struct brcms_phy_pub *ppi, uint channel, u8 *min_pwr,\n\t\t\t  u8 *max_pwr, int txp_rate_idx)\n{\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\tuint i;\n\n\t*min_pwr = pi->min_txpower * BRCMS_TXPWR_DB_FACTOR;\n\n\tif (ISNPHY(pi)) {\n\t\tif (txp_rate_idx < 0)\n\t\t\ttxp_rate_idx = TXP_FIRST_CCK;\n\t\twlc_phy_txpower_sromlimit_get_nphy(pi, channel, max_pwr,\n\t\t\t\t\t\t   (u8) txp_rate_idx);\n\n\t} else if ((channel <= CH_MAX_2G_CHANNEL)) {\n\t\tif (txp_rate_idx < 0)\n\t\t\ttxp_rate_idx = TXP_FIRST_CCK;\n\t\t*max_pwr = pi->tx_srom_max_rate_2g[txp_rate_idx];\n\t} else {\n\n\t\t*max_pwr = BRCMS_TXPWR_MAX;\n\n\t\tif (txp_rate_idx < 0)\n\t\t\ttxp_rate_idx = TXP_FIRST_OFDM;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(chan_info_all); i++) {\n\t\t\tif (channel == chan_info_all[i].chan)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (pi->hwtxpwr) {\n\t\t\t*max_pwr = pi->hwtxpwr[i];\n\t\t} else {\n\n\t\t\tif ((i >= FIRST_MID_5G_CHAN) && (i <= LAST_MID_5G_CHAN))\n\t\t\t\t*max_pwr =\n\t\t\t\t    pi->tx_srom_max_rate_5g_mid[txp_rate_idx];\n\t\t\tif ((i >= FIRST_HIGH_5G_CHAN)\n\t\t\t    && (i <= LAST_HIGH_5G_CHAN))\n\t\t\t\t*max_pwr =\n\t\t\t\t    pi->tx_srom_max_rate_5g_hi[txp_rate_idx];\n\t\t\tif ((i >= FIRST_LOW_5G_CHAN) && (i <= LAST_LOW_5G_CHAN))\n\t\t\t\t*max_pwr =\n\t\t\t\t    pi->tx_srom_max_rate_5g_low[txp_rate_idx];\n\t\t}\n\t}\n}\n\nvoid\nwlc_phy_txpower_sromlimit_max_get(struct brcms_phy_pub *ppi, uint chan,\n\t\t\t\t  u8 *max_txpwr, u8 *min_txpwr)\n{\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\tu8 tx_pwr_max = 0;\n\tu8 tx_pwr_min = 255;\n\tu8 max_num_rate;\n\tu8 maxtxpwr, mintxpwr, rate, pactrl;\n\n\tpactrl = 0;\n\n\tmax_num_rate = ISNPHY(pi) ? TXP_NUM_RATES :\n\t\t       ISLCNPHY(pi) ? (TXP_LAST_SISO_MCS_20 +\n\t\t\t\t       1) : (TXP_LAST_OFDM + 1);\n\n\tfor (rate = 0; rate < max_num_rate; rate++) {\n\n\t\twlc_phy_txpower_sromlimit(ppi, chan, &mintxpwr, &maxtxpwr,\n\t\t\t\t\t  rate);\n\n\t\tmaxtxpwr = (maxtxpwr > pactrl) ? (maxtxpwr - pactrl) : 0;\n\n\t\tmaxtxpwr = (maxtxpwr > 6) ? (maxtxpwr - 6) : 0;\n\n\t\ttx_pwr_max = max(tx_pwr_max, maxtxpwr);\n\t\ttx_pwr_min = min(tx_pwr_min, maxtxpwr);\n\t}\n\t*max_txpwr = tx_pwr_max;\n\t*min_txpwr = tx_pwr_min;\n}\n\nvoid\nwlc_phy_txpower_boardlimit_band(struct brcms_phy_pub *ppi, uint bandunit,\n\t\t\t\ts32 *max_pwr, s32 *min_pwr, u32 *step_pwr)\n{\n\treturn;\n}\n\nu8 wlc_phy_txpower_get_target_min(struct brcms_phy_pub *ppi)\n{\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\n\treturn pi->tx_power_min;\n}\n\nu8 wlc_phy_txpower_get_target_max(struct brcms_phy_pub *ppi)\n{\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\n\treturn pi->tx_power_max;\n}\n\nstatic s8 wlc_phy_env_measure_vbat(struct brcms_phy *pi)\n{\n\tif (ISLCNPHY(pi))\n\t\treturn wlc_lcnphy_vbatsense(pi, 0);\n\telse\n\t\treturn 0;\n}\n\nstatic s8 wlc_phy_env_measure_temperature(struct brcms_phy *pi)\n{\n\tif (ISLCNPHY(pi))\n\t\treturn wlc_lcnphy_tempsense_degree(pi, 0);\n\telse\n\t\treturn 0;\n}\n\nstatic void wlc_phy_upd_env_txpwr_rate_limits(struct brcms_phy *pi, u32 band)\n{\n\tu8 i;\n\n\tfor (i = 0; i < TXP_NUM_RATES; i++)\n\t\tpi->txpwr_env_limit[i] = BRCMS_TXPWR_MAX;\n\n\twlc_phy_env_measure_vbat(pi);\n\twlc_phy_env_measure_temperature(pi);\n}\n\nstatic s8\nwlc_user_txpwr_antport_to_rfport(struct brcms_phy *pi, uint chan, u32 band,\n\t\t\t\t u8 rate)\n{\n\treturn 0;\n}\n\nvoid wlc_phy_txpower_recalc_target(struct brcms_phy *pi)\n{\n\tu8 maxtxpwr, mintxpwr, rate, pactrl;\n\tuint target_chan;\n\tu8 tx_pwr_target[TXP_NUM_RATES];\n\tu8 tx_pwr_max = 0;\n\tu8 tx_pwr_min = 255;\n\tu8 tx_pwr_max_rate_ind = 0;\n\tu8 max_num_rate;\n\tu8 start_rate = 0;\n\tu16 chspec;\n\tu32 band = CHSPEC2BAND(pi->radio_chanspec);\n\tvoid (*txpwr_recalc_fn)(struct brcms_phy *) = NULL;\n\n\tchspec = pi->radio_chanspec;\n\tif (CHSPEC_CTL_SB(chspec) == WL_CHANSPEC_CTL_SB_NONE)\n\t\ttarget_chan = CHSPEC_CHANNEL(chspec);\n\telse if (CHSPEC_CTL_SB(chspec) == WL_CHANSPEC_CTL_SB_UPPER)\n\t\ttarget_chan = upper_20_sb(CHSPEC_CHANNEL(chspec));\n\telse\n\t\ttarget_chan = lower_20_sb(CHSPEC_CHANNEL(chspec));\n\n\tpactrl = 0;\n\tif (ISLCNPHY(pi)) {\n\t\tu32 offset_mcs, i;\n\n\t\tif (CHSPEC_IS40(pi->radio_chanspec)) {\n\t\t\toffset_mcs = pi->mcs40_po;\n\t\t\tfor (i = TXP_FIRST_SISO_MCS_20;\n\t\t\t     i <= TXP_LAST_SISO_MCS_20; i++) {\n\t\t\t\tpi->tx_srom_max_rate_2g[i - 8] =\n\t\t\t\t\tpi->tx_srom_max_2g -\n\t\t\t\t\t((offset_mcs & 0xf) * 2);\n\t\t\t\toffset_mcs >>= 4;\n\t\t\t}\n\t\t} else {\n\t\t\toffset_mcs = pi->mcs20_po;\n\t\t\tfor (i = TXP_FIRST_SISO_MCS_20;\n\t\t\t     i <= TXP_LAST_SISO_MCS_20; i++) {\n\t\t\t\tpi->tx_srom_max_rate_2g[i - 8] =\n\t\t\t\t\tpi->tx_srom_max_2g -\n\t\t\t\t\t((offset_mcs & 0xf) * 2);\n\t\t\t\toffset_mcs >>= 4;\n\t\t\t}\n\t\t}\n\t}\n\n\tmax_num_rate = ((ISNPHY(pi)) ? (TXP_NUM_RATES) :\n\t\t\t((ISLCNPHY(pi)) ?\n\t\t\t (TXP_LAST_SISO_MCS_20 + 1) : (TXP_LAST_OFDM + 1)));\n\n\twlc_phy_upd_env_txpwr_rate_limits(pi, band);\n\n\tfor (rate = start_rate; rate < max_num_rate; rate++) {\n\n\t\ttx_pwr_target[rate] = pi->tx_user_target[rate];\n\n\t\tif (pi->user_txpwr_at_rfport)\n\t\t\ttx_pwr_target[rate] +=\n\t\t\t\twlc_user_txpwr_antport_to_rfport(pi,\n\t\t\t\t\t\t\t\t target_chan,\n\t\t\t\t\t\t\t\t band,\n\t\t\t\t\t\t\t\t rate);\n\n\t\twlc_phy_txpower_sromlimit((struct brcms_phy_pub *) pi,\n\t\t\t\t\t  target_chan,\n\t\t\t\t\t  &mintxpwr, &maxtxpwr, rate);\n\n\t\tmaxtxpwr = min(maxtxpwr, pi->txpwr_limit[rate]);\n\n\t\tmaxtxpwr = (maxtxpwr > pactrl) ? (maxtxpwr - pactrl) : 0;\n\n\t\tmaxtxpwr = (maxtxpwr > 6) ? (maxtxpwr - 6) : 0;\n\n\t\tmaxtxpwr = min(maxtxpwr, tx_pwr_target[rate]);\n\n\t\tif (pi->txpwr_percent <= 100)\n\t\t\tmaxtxpwr = (maxtxpwr * pi->txpwr_percent) / 100;\n\n\t\ttx_pwr_target[rate] = max(maxtxpwr, mintxpwr);\n\n\t\ttx_pwr_target[rate] =\n\t\t\tmin(tx_pwr_target[rate], pi->txpwr_env_limit[rate]);\n\n\t\tif (tx_pwr_target[rate] > tx_pwr_max)\n\t\t\ttx_pwr_max_rate_ind = rate;\n\n\t\ttx_pwr_max = max(tx_pwr_max, tx_pwr_target[rate]);\n\t\ttx_pwr_min = min(tx_pwr_min, tx_pwr_target[rate]);\n\t}\n\n\tmemset(pi->tx_power_offset, 0, sizeof(pi->tx_power_offset));\n\tpi->tx_power_max = tx_pwr_max;\n\tpi->tx_power_min = tx_pwr_min;\n\tpi->tx_power_max_rate_ind = tx_pwr_max_rate_ind;\n\tfor (rate = 0; rate < max_num_rate; rate++) {\n\n\t\tpi->tx_power_target[rate] = tx_pwr_target[rate];\n\n\t\tif (!pi->hwpwrctrl || ISNPHY(pi))\n\t\t\tpi->tx_power_offset[rate] =\n\t\t\t\tpi->tx_power_max - pi->tx_power_target[rate];\n\t\telse\n\t\t\tpi->tx_power_offset[rate] =\n\t\t\t\tpi->tx_power_target[rate] - pi->tx_power_min;\n\t}\n\n\ttxpwr_recalc_fn = pi->pi_fptr.txpwrrecalc;\n\tif (txpwr_recalc_fn)\n\t\t(*txpwr_recalc_fn)(pi);\n}\n\nstatic void\nwlc_phy_txpower_reg_limit_calc(struct brcms_phy *pi, struct txpwr_limits *txpwr,\n\t\t\t       u16 chanspec)\n{\n\tu8 tmp_txpwr_limit[2 * BRCMS_NUM_RATES_OFDM];\n\tu8 *txpwr_ptr1 = NULL, *txpwr_ptr2 = NULL;\n\tint rate_start_index = 0, rate1, rate2, k;\n\n\tfor (rate1 = WL_TX_POWER_CCK_FIRST, rate2 = 0;\n\t     rate2 < WL_TX_POWER_CCK_NUM; rate1++, rate2++)\n\t\tpi->txpwr_limit[rate1] = txpwr->cck[rate2];\n\n\tfor (rate1 = WL_TX_POWER_OFDM_FIRST, rate2 = 0;\n\t     rate2 < WL_TX_POWER_OFDM_NUM; rate1++, rate2++)\n\t\tpi->txpwr_limit[rate1] = txpwr->ofdm[rate2];\n\n\tif (ISNPHY(pi)) {\n\n\t\tfor (k = 0; k < 4; k++) {\n\t\t\tswitch (k) {\n\t\t\tcase 0:\n\n\t\t\t\ttxpwr_ptr1 = txpwr->mcs_20_siso;\n\t\t\t\ttxpwr_ptr2 = txpwr->ofdm;\n\t\t\t\trate_start_index = WL_TX_POWER_OFDM_FIRST;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\n\t\t\t\ttxpwr_ptr1 = txpwr->mcs_20_cdd;\n\t\t\t\ttxpwr_ptr2 = txpwr->ofdm_cdd;\n\t\t\t\trate_start_index = WL_TX_POWER_OFDM20_CDD_FIRST;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\n\t\t\t\ttxpwr_ptr1 = txpwr->mcs_40_siso;\n\t\t\t\ttxpwr_ptr2 = txpwr->ofdm_40_siso;\n\t\t\t\trate_start_index =\n\t\t\t\t\tWL_TX_POWER_OFDM40_SISO_FIRST;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\n\t\t\t\ttxpwr_ptr1 = txpwr->mcs_40_cdd;\n\t\t\t\ttxpwr_ptr2 = txpwr->ofdm_40_cdd;\n\t\t\t\trate_start_index = WL_TX_POWER_OFDM40_CDD_FIRST;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (rate2 = 0; rate2 < BRCMS_NUM_RATES_OFDM;\n\t\t\t     rate2++) {\n\t\t\t\ttmp_txpwr_limit[rate2] = 0;\n\t\t\t\ttmp_txpwr_limit[BRCMS_NUM_RATES_OFDM + rate2] =\n\t\t\t\t\ttxpwr_ptr1[rate2];\n\t\t\t}\n\t\t\twlc_phy_mcs_to_ofdm_powers_nphy(\n\t\t\t\ttmp_txpwr_limit, 0,\n\t\t\t\tBRCMS_NUM_RATES_OFDM -\n\t\t\t\t1, BRCMS_NUM_RATES_OFDM);\n\t\t\tfor (rate1 = rate_start_index, rate2 = 0;\n\t\t\t     rate2 < BRCMS_NUM_RATES_OFDM; rate1++, rate2++)\n\t\t\t\tpi->txpwr_limit[rate1] =\n\t\t\t\t\tmin(txpwr_ptr2[rate2],\n\t\t\t\t\t    tmp_txpwr_limit[rate2]);\n\t\t}\n\n\t\tfor (k = 0; k < 4; k++) {\n\t\t\tswitch (k) {\n\t\t\tcase 0:\n\n\t\t\t\ttxpwr_ptr1 = txpwr->ofdm;\n\t\t\t\ttxpwr_ptr2 = txpwr->mcs_20_siso;\n\t\t\t\trate_start_index = WL_TX_POWER_MCS20_SISO_FIRST;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\n\t\t\t\ttxpwr_ptr1 = txpwr->ofdm_cdd;\n\t\t\t\ttxpwr_ptr2 = txpwr->mcs_20_cdd;\n\t\t\t\trate_start_index = WL_TX_POWER_MCS20_CDD_FIRST;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\n\t\t\t\ttxpwr_ptr1 = txpwr->ofdm_40_siso;\n\t\t\t\ttxpwr_ptr2 = txpwr->mcs_40_siso;\n\t\t\t\trate_start_index = WL_TX_POWER_MCS40_SISO_FIRST;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\n\t\t\t\ttxpwr_ptr1 = txpwr->ofdm_40_cdd;\n\t\t\t\ttxpwr_ptr2 = txpwr->mcs_40_cdd;\n\t\t\t\trate_start_index = WL_TX_POWER_MCS40_CDD_FIRST;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (rate2 = 0; rate2 < BRCMS_NUM_RATES_OFDM;\n\t\t\t     rate2++) {\n\t\t\t\ttmp_txpwr_limit[rate2] = 0;\n\t\t\t\ttmp_txpwr_limit[BRCMS_NUM_RATES_OFDM + rate2] =\n\t\t\t\t\ttxpwr_ptr1[rate2];\n\t\t\t}\n\t\t\twlc_phy_ofdm_to_mcs_powers_nphy(\n\t\t\t\ttmp_txpwr_limit, 0,\n\t\t\t\tBRCMS_NUM_RATES_OFDM -\n\t\t\t\t1, BRCMS_NUM_RATES_OFDM);\n\t\t\tfor (rate1 = rate_start_index, rate2 = 0;\n\t\t\t     rate2 < BRCMS_NUM_RATES_MCS_1_STREAM;\n\t\t\t     rate1++, rate2++)\n\t\t\t\tpi->txpwr_limit[rate1] =\n\t\t\t\t\tmin(txpwr_ptr2[rate2],\n\t\t\t\t\t    tmp_txpwr_limit[rate2]);\n\t\t}\n\n\t\tfor (k = 0; k < 2; k++) {\n\t\t\tswitch (k) {\n\t\t\tcase 0:\n\n\t\t\t\trate_start_index = WL_TX_POWER_MCS20_STBC_FIRST;\n\t\t\t\ttxpwr_ptr1 = txpwr->mcs_20_stbc;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\n\t\t\t\trate_start_index = WL_TX_POWER_MCS40_STBC_FIRST;\n\t\t\t\ttxpwr_ptr1 = txpwr->mcs_40_stbc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (rate1 = rate_start_index, rate2 = 0;\n\t\t\t     rate2 < BRCMS_NUM_RATES_MCS_1_STREAM;\n\t\t\t     rate1++, rate2++)\n\t\t\t\tpi->txpwr_limit[rate1] = txpwr_ptr1[rate2];\n\t\t}\n\n\t\tfor (k = 0; k < 2; k++) {\n\t\t\tswitch (k) {\n\t\t\tcase 0:\n\n\t\t\t\trate_start_index = WL_TX_POWER_MCS20_SDM_FIRST;\n\t\t\t\ttxpwr_ptr1 = txpwr->mcs_20_mimo;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\n\t\t\t\trate_start_index = WL_TX_POWER_MCS40_SDM_FIRST;\n\t\t\t\ttxpwr_ptr1 = txpwr->mcs_40_mimo;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (rate1 = rate_start_index, rate2 = 0;\n\t\t\t     rate2 < BRCMS_NUM_RATES_MCS_2_STREAM;\n\t\t\t     rate1++, rate2++)\n\t\t\t\tpi->txpwr_limit[rate1] = txpwr_ptr1[rate2];\n\t\t}\n\n\t\tpi->txpwr_limit[WL_TX_POWER_MCS_32] = txpwr->mcs32;\n\n\t\tpi->txpwr_limit[WL_TX_POWER_MCS40_CDD_FIRST] =\n\t\t\tmin(pi->txpwr_limit[WL_TX_POWER_MCS40_CDD_FIRST],\n\t\t\t    pi->txpwr_limit[WL_TX_POWER_MCS_32]);\n\t\tpi->txpwr_limit[WL_TX_POWER_MCS_32] =\n\t\t\tpi->txpwr_limit[WL_TX_POWER_MCS40_CDD_FIRST];\n\t}\n}\n\nvoid wlc_phy_txpwr_percent_set(struct brcms_phy_pub *ppi, u8 txpwr_percent)\n{\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\n\tpi->txpwr_percent = txpwr_percent;\n}\n\nvoid wlc_phy_machwcap_set(struct brcms_phy_pub *ppi, u32 machwcap)\n{\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\n\tpi->sh->machwcap = machwcap;\n}\n\nvoid wlc_phy_runbist_config(struct brcms_phy_pub *ppi, bool start_end)\n{\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\tu16 rxc;\n\trxc = 0;\n\n\tif (start_end == ON) {\n\t\tif (!ISNPHY(pi))\n\t\t\treturn;\n\n\t\tif (NREV_IS(pi->pubpi.phy_rev, 3)\n\t\t    || NREV_IS(pi->pubpi.phy_rev, 4)) {\n\t\t\tbcma_wflush16(pi->d11core, D11REGOFFS(phyregaddr),\n\t\t\t\t      0xa0);\n\t\t\tbcma_set16(pi->d11core, D11REGOFFS(phyregdata),\n\t\t\t\t   0x1 << 15);\n\t\t}\n\t} else {\n\t\tif (NREV_IS(pi->pubpi.phy_rev, 3)\n\t\t    || NREV_IS(pi->pubpi.phy_rev, 4)) {\n\t\t\tbcma_wflush16(pi->d11core, D11REGOFFS(phyregaddr),\n\t\t\t\t      0xa0);\n\t\t\tbcma_write16(pi->d11core, D11REGOFFS(phyregdata), rxc);\n\t\t}\n\n\t\twlc_phy_por_inform(ppi);\n\t}\n}\n\nvoid\nwlc_phy_txpower_limit_set(struct brcms_phy_pub *ppi, struct txpwr_limits *txpwr,\n\t\t\t  u16 chanspec)\n{\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\n\twlc_phy_txpower_reg_limit_calc(pi, txpwr, chanspec);\n\n\tif (ISLCNPHY(pi)) {\n\t\tint i, j;\n\t\tfor (i = TXP_FIRST_OFDM_20_CDD, j = 0;\n\t\t     j < BRCMS_NUM_RATES_MCS_1_STREAM; i++, j++) {\n\t\t\tif (txpwr->mcs_20_siso[j])\n\t\t\t\tpi->txpwr_limit[i] = txpwr->mcs_20_siso[j];\n\t\t\telse\n\t\t\t\tpi->txpwr_limit[i] = txpwr->ofdm[j];\n\t\t}\n\t}\n\n\twlapi_suspend_mac_and_wait(pi->sh->physhim);\n\n\twlc_phy_txpower_recalc_target(pi);\n\twlc_phy_cal_txpower_recalc_sw(pi);\n\twlapi_enable_mac(pi->sh->physhim);\n}\n\nvoid wlc_phy_ofdm_rateset_war(struct brcms_phy_pub *pih, bool war)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\n\tpi->ofdm_rateset_war = war;\n}\n\nvoid wlc_phy_bf_preempt_enable(struct brcms_phy_pub *pih, bool bf_preempt)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\n\tpi->bf_preempt_4306 = bf_preempt;\n}\n\nvoid wlc_phy_txpower_update_shm(struct brcms_phy *pi)\n{\n\tint j;\n\tif (ISNPHY(pi))\n\t\treturn;\n\n\tif (!pi->sh->clk)\n\t\treturn;\n\n\tif (pi->hwpwrctrl) {\n\t\tu16 offset;\n\n\t\twlapi_bmac_write_shm(pi->sh->physhim, M_TXPWR_MAX, 63);\n\t\twlapi_bmac_write_shm(pi->sh->physhim, M_TXPWR_N,\n\t\t\t\t     1 << NUM_TSSI_FRAMES);\n\n\t\twlapi_bmac_write_shm(pi->sh->physhim, M_TXPWR_TARGET,\n\t\t\t\t     pi->tx_power_min << NUM_TSSI_FRAMES);\n\n\t\twlapi_bmac_write_shm(pi->sh->physhim, M_TXPWR_CUR,\n\t\t\t\t     pi->hwpwr_txcur);\n\n\t\tfor (j = TXP_FIRST_OFDM; j <= TXP_LAST_OFDM; j++) {\n\t\t\tstatic const u8 ucode_ofdm_rates[] = {\n\t\t\t\t0x0c, 0x12, 0x18, 0x24, 0x30, 0x48, 0x60, 0x6c\n\t\t\t};\n\t\t\toffset = wlapi_bmac_rate_shm_offset(\n\t\t\t\tpi->sh->physhim,\n\t\t\t\tucode_ofdm_rates[j - TXP_FIRST_OFDM]);\n\t\t\twlapi_bmac_write_shm(pi->sh->physhim, offset + 6,\n\t\t\t\t\t     pi->tx_power_offset[j]);\n\t\t\twlapi_bmac_write_shm(pi->sh->physhim, offset + 14,\n\t\t\t\t\t     -(pi->tx_power_offset[j] / 2));\n\t\t}\n\n\t\twlapi_bmac_mhf(pi->sh->physhim, MHF2, MHF2_HWPWRCTL,\n\t\t\t       MHF2_HWPWRCTL, BRCM_BAND_ALL);\n\t} else {\n\t\tint i;\n\n\t\tfor (i = TXP_FIRST_OFDM; i <= TXP_LAST_OFDM; i++)\n\t\t\tpi->tx_power_offset[i] =\n\t\t\t\t(u8) roundup(pi->tx_power_offset[i], 8);\n\t\twlapi_bmac_write_shm(pi->sh->physhim, M_OFDM_OFFSET,\n\t\t\t\t     (u16)\n\t\t\t\t     ((pi->tx_power_offset[TXP_FIRST_OFDM]\n\t\t\t\t       + 7) >> 3));\n\t}\n}\n\nbool wlc_phy_txpower_hw_ctrl_get(struct brcms_phy_pub *ppi)\n{\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\n\tif (ISNPHY(pi))\n\t\treturn pi->nphy_txpwrctrl;\n\telse\n\t\treturn pi->hwpwrctrl;\n}\n\nvoid wlc_phy_txpower_hw_ctrl_set(struct brcms_phy_pub *ppi, bool hwpwrctrl)\n{\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\tbool suspend;\n\n\tif (!pi->hwpwrctrl_capable)\n\t\treturn;\n\n\tpi->hwpwrctrl = hwpwrctrl;\n\tpi->nphy_txpwrctrl = hwpwrctrl;\n\tpi->txpwrctrl = hwpwrctrl;\n\n\tif (ISNPHY(pi)) {\n\t\tsuspend = (0 == (bcma_read32(pi->d11core,\n\t\t\t\t\t     D11REGOFFS(maccontrol)) &\n\t\t\t\t MCTL_EN_MAC));\n\t\tif (!suspend)\n\t\t\twlapi_suspend_mac_and_wait(pi->sh->physhim);\n\n\t\twlc_phy_txpwrctrl_enable_nphy(pi, pi->nphy_txpwrctrl);\n\t\tif (pi->nphy_txpwrctrl == PHY_TPC_HW_OFF)\n\t\t\twlc_phy_txpwr_fixpower_nphy(pi);\n\t\telse\n\t\t\tmod_phy_reg(pi, 0x1e7, (0x7f << 0),\n\t\t\t\t    pi->saved_txpwr_idx);\n\n\t\tif (!suspend)\n\t\t\twlapi_enable_mac(pi->sh->physhim);\n\t}\n}\n\nvoid wlc_phy_txpower_ipa_upd(struct brcms_phy *pi)\n{\n\n\tif (NREV_GE(pi->pubpi.phy_rev, 3)) {\n\t\tpi->ipa2g_on = (pi->srom_fem2g.extpagain == 2);\n\t\tpi->ipa5g_on = (pi->srom_fem5g.extpagain == 2);\n\t} else {\n\t\tpi->ipa2g_on = false;\n\t\tpi->ipa5g_on = false;\n\t}\n}\n\nstatic u32 wlc_phy_txpower_est_power_nphy(struct brcms_phy *pi)\n{\n\ts16 tx0_status, tx1_status;\n\tu16 estPower1, estPower2;\n\tu8 pwr0, pwr1, adj_pwr0, adj_pwr1;\n\tu32 est_pwr;\n\n\testPower1 = read_phy_reg(pi, 0x118);\n\testPower2 = read_phy_reg(pi, 0x119);\n\n\tif ((estPower1 & (0x1 << 8)) == (0x1 << 8))\n\t\tpwr0 = (u8) (estPower1 & (0xff << 0)) >> 0;\n\telse\n\t\tpwr0 = 0x80;\n\n\tif ((estPower2 & (0x1 << 8)) == (0x1 << 8))\n\t\tpwr1 = (u8) (estPower2 & (0xff << 0)) >> 0;\n\telse\n\t\tpwr1 = 0x80;\n\n\ttx0_status = read_phy_reg(pi, 0x1ed);\n\ttx1_status = read_phy_reg(pi, 0x1ee);\n\n\tif ((tx0_status & (0x1 << 15)) == (0x1 << 15))\n\t\tadj_pwr0 = (u8) (tx0_status & (0xff << 0)) >> 0;\n\telse\n\t\tadj_pwr0 = 0x80;\n\tif ((tx1_status & (0x1 << 15)) == (0x1 << 15))\n\t\tadj_pwr1 = (u8) (tx1_status & (0xff << 0)) >> 0;\n\telse\n\t\tadj_pwr1 = 0x80;\n\n\test_pwr = (u32) ((pwr0 << 24) | (pwr1 << 16) | (adj_pwr0 << 8) |\n\t\t\t adj_pwr1);\n\n\treturn est_pwr;\n}\n\nvoid\nwlc_phy_txpower_get_current(struct brcms_phy_pub *ppi, struct tx_power *power,\n\t\t\t    uint channel)\n{\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\tuint rate, num_rates;\n\tu8 min_pwr, max_pwr;\n\n#if WL_TX_POWER_RATES != TXP_NUM_RATES\n#error \"struct tx_power out of sync with this fn\"\n#endif\n\n\tif (ISNPHY(pi)) {\n\t\tpower->rf_cores = 2;\n\t\tpower->flags |= (WL_TX_POWER_F_MIMO);\n\t\tif (pi->nphy_txpwrctrl == PHY_TPC_HW_ON)\n\t\t\tpower->flags |=\n\t\t\t\t(WL_TX_POWER_F_ENABLED | WL_TX_POWER_F_HW);\n\t} else if (ISLCNPHY(pi)) {\n\t\tpower->rf_cores = 1;\n\t\tpower->flags |= (WL_TX_POWER_F_SISO);\n\t\tif (pi->radiopwr_override == RADIOPWR_OVERRIDE_DEF)\n\t\t\tpower->flags |= WL_TX_POWER_F_ENABLED;\n\t\tif (pi->hwpwrctrl)\n\t\t\tpower->flags |= WL_TX_POWER_F_HW;\n\t}\n\n\tnum_rates = ((ISNPHY(pi)) ? (TXP_NUM_RATES) :\n\t\t     ((ISLCNPHY(pi)) ?\n\t\t      (TXP_LAST_OFDM_20_CDD + 1) : (TXP_LAST_OFDM + 1)));\n\n\tfor (rate = 0; rate < num_rates; rate++) {\n\t\tpower->user_limit[rate] = pi->tx_user_target[rate];\n\t\twlc_phy_txpower_sromlimit(ppi, channel, &min_pwr, &max_pwr,\n\t\t\t\t\t  rate);\n\t\tpower->board_limit[rate] = (u8) max_pwr;\n\t\tpower->target[rate] = pi->tx_power_target[rate];\n\t}\n\n\tif (ISNPHY(pi)) {\n\t\tu32 est_pout;\n\n\t\twlapi_suspend_mac_and_wait(pi->sh->physhim);\n\t\twlc_phyreg_enter((struct brcms_phy_pub *) pi);\n\t\test_pout = wlc_phy_txpower_est_power_nphy(pi);\n\t\twlc_phyreg_exit((struct brcms_phy_pub *) pi);\n\t\twlapi_enable_mac(pi->sh->physhim);\n\n\t\tpower->est_Pout[0] = (est_pout >> 8) & 0xff;\n\t\tpower->est_Pout[1] = est_pout & 0xff;\n\n\t\tpower->est_Pout_act[0] = est_pout >> 24;\n\t\tpower->est_Pout_act[1] = (est_pout >> 16) & 0xff;\n\n\t\tif (power->est_Pout[0] == 0x80)\n\t\t\tpower->est_Pout[0] = 0;\n\t\tif (power->est_Pout[1] == 0x80)\n\t\t\tpower->est_Pout[1] = 0;\n\n\t\tif (power->est_Pout_act[0] == 0x80)\n\t\t\tpower->est_Pout_act[0] = 0;\n\t\tif (power->est_Pout_act[1] == 0x80)\n\t\t\tpower->est_Pout_act[1] = 0;\n\n\t\tpower->est_Pout_cck = 0;\n\n\t\tpower->tx_power_max[0] = pi->tx_power_max;\n\t\tpower->tx_power_max[1] = pi->tx_power_max;\n\n\t\tpower->tx_power_max_rate_ind[0] = pi->tx_power_max_rate_ind;\n\t\tpower->tx_power_max_rate_ind[1] = pi->tx_power_max_rate_ind;\n\t} else if (pi->hwpwrctrl && pi->sh->up) {\n\n\t\twlc_phyreg_enter(ppi);\n\t\tif (ISLCNPHY(pi)) {\n\n\t\t\tpower->tx_power_max[0] = pi->tx_power_max;\n\t\t\tpower->tx_power_max[1] = pi->tx_power_max;\n\n\t\t\tpower->tx_power_max_rate_ind[0] =\n\t\t\t\tpi->tx_power_max_rate_ind;\n\t\t\tpower->tx_power_max_rate_ind[1] =\n\t\t\t\tpi->tx_power_max_rate_ind;\n\n\t\t\tif (wlc_phy_tpc_isenabled_lcnphy(pi))\n\t\t\t\tpower->flags |=\n\t\t\t\t\t(WL_TX_POWER_F_HW |\n\t\t\t\t\t WL_TX_POWER_F_ENABLED);\n\t\t\telse\n\t\t\t\tpower->flags &=\n\t\t\t\t\t~(WL_TX_POWER_F_HW |\n\t\t\t\t\t  WL_TX_POWER_F_ENABLED);\n\n\t\t\twlc_lcnphy_get_tssi(pi, (s8 *) &power->est_Pout[0],\n\t\t\t\t\t    (s8 *) &power->est_Pout_cck);\n\t\t}\n\t\twlc_phyreg_exit(ppi);\n\t}\n}\n\nvoid wlc_phy_antsel_type_set(struct brcms_phy_pub *ppi, u8 antsel_type)\n{\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\n\tpi->antsel_type = antsel_type;\n}\n\nbool wlc_phy_test_ison(struct brcms_phy_pub *ppi)\n{\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\n\treturn pi->phytest_on;\n}\n\nvoid wlc_phy_ant_rxdiv_set(struct brcms_phy_pub *ppi, u8 val)\n{\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\tbool suspend;\n\n\tpi->sh->rx_antdiv = val;\n\n\tif (!(ISNPHY(pi) && D11REV_IS(pi->sh->corerev, 16))) {\n\t\tif (val > ANT_RX_DIV_FORCE_1)\n\t\t\twlapi_bmac_mhf(pi->sh->physhim, MHF1, MHF1_ANTDIV,\n\t\t\t\t       MHF1_ANTDIV, BRCM_BAND_ALL);\n\t\telse\n\t\t\twlapi_bmac_mhf(pi->sh->physhim, MHF1, MHF1_ANTDIV, 0,\n\t\t\t\t       BRCM_BAND_ALL);\n\t}\n\n\tif (ISNPHY(pi))\n\t\treturn;\n\n\tif (!pi->sh->clk)\n\t\treturn;\n\n\tsuspend = (0 == (bcma_read32(pi->d11core, D11REGOFFS(maccontrol)) &\n\t\t\t MCTL_EN_MAC));\n\tif (!suspend)\n\t\twlapi_suspend_mac_and_wait(pi->sh->physhim);\n\n\tif (ISLCNPHY(pi)) {\n\t\tif (val > ANT_RX_DIV_FORCE_1) {\n\t\t\tmod_phy_reg(pi, 0x410, (0x1 << 1), 0x01 << 1);\n\t\t\tmod_phy_reg(pi, 0x410,\n\t\t\t\t    (0x1 << 0),\n\t\t\t\t    ((ANT_RX_DIV_START_1 == val) ? 1 : 0) << 0);\n\t\t} else {\n\t\t\tmod_phy_reg(pi, 0x410, (0x1 << 1), 0x00 << 1);\n\t\t\tmod_phy_reg(pi, 0x410, (0x1 << 0), (u16) val << 0);\n\t\t}\n\t}\n\n\tif (!suspend)\n\t\twlapi_enable_mac(pi->sh->physhim);\n\n\treturn;\n}\n\nstatic bool\nwlc_phy_noise_calc_phy(struct brcms_phy *pi, u32 *cmplx_pwr, s8 *pwr_ant)\n{\n\ts8 cmplx_pwr_dbm[PHY_CORE_MAX];\n\tu8 i;\n\n\tmemset((u8 *) cmplx_pwr_dbm, 0, sizeof(cmplx_pwr_dbm));\n\twlc_phy_compute_dB(cmplx_pwr, cmplx_pwr_dbm, pi->pubpi.phy_corenum);\n\n\tfor (i = 0; i < pi->pubpi.phy_corenum; i++) {\n\t\tif (NREV_GE(pi->pubpi.phy_rev, 3))\n\t\t\tcmplx_pwr_dbm[i] += (s8) PHY_NOISE_OFFSETFACT_4322;\n\t\telse\n\n\t\t\tcmplx_pwr_dbm[i] += (s8) (16 - (15) * 3 - 70);\n\t}\n\n\tfor (i = 0; i < pi->pubpi.phy_corenum; i++) {\n\t\tpi->nphy_noise_win[i][pi->nphy_noise_index] = cmplx_pwr_dbm[i];\n\t\tpwr_ant[i] = cmplx_pwr_dbm[i];\n\t}\n\tpi->nphy_noise_index =\n\t\tMODINC_POW2(pi->nphy_noise_index, PHY_NOISE_WINDOW_SZ);\n\treturn true;\n}\n\nstatic void wlc_phy_noise_cb(struct brcms_phy *pi, u8 channel, s8 noise_dbm)\n{\n\tif (!pi->phynoise_state)\n\t\treturn;\n\n\tif (pi->phynoise_state & PHY_NOISE_STATE_MON) {\n\t\tif (pi->phynoise_chan_watchdog == channel) {\n\t\t\tpi->sh->phy_noise_window[pi->sh->phy_noise_index] =\n\t\t\t\tnoise_dbm;\n\t\t\tpi->sh->phy_noise_index =\n\t\t\t\tMODINC(pi->sh->phy_noise_index, MA_WINDOW_SZ);\n\t\t}\n\t\tpi->phynoise_state &= ~PHY_NOISE_STATE_MON;\n\t}\n\n\tif (pi->phynoise_state & PHY_NOISE_STATE_EXTERNAL)\n\t\tpi->phynoise_state &= ~PHY_NOISE_STATE_EXTERNAL;\n\n}\n\nstatic s8 wlc_phy_noise_read_shmem(struct brcms_phy *pi)\n{\n\tu32 cmplx_pwr[PHY_CORE_MAX];\n\ts8 noise_dbm_ant[PHY_CORE_MAX];\n\tu16 lo, hi;\n\tu32 cmplx_pwr_tot = 0;\n\ts8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;\n\tu8 idx, core;\n\n\tmemset((u8 *) cmplx_pwr, 0, sizeof(cmplx_pwr));\n\tmemset((u8 *) noise_dbm_ant, 0, sizeof(noise_dbm_ant));\n\n\tfor (idx = 0, core = 0; core < pi->pubpi.phy_corenum; idx += 2,\n\t     core++) {\n\t\tlo = wlapi_bmac_read_shm(pi->sh->physhim, M_PWRIND_MAP(idx));\n\t\thi = wlapi_bmac_read_shm(pi->sh->physhim,\n\t\t\t\t\t M_PWRIND_MAP(idx + 1));\n\t\tcmplx_pwr[core] = (hi << 16) + lo;\n\t\tcmplx_pwr_tot += cmplx_pwr[core];\n\t\tif (cmplx_pwr[core] == 0)\n\t\t\tnoise_dbm_ant[core] = PHY_NOISE_FIXED_VAL_NPHY;\n\t\telse\n\t\t\tcmplx_pwr[core] >>= PHY_NOISE_SAMPLE_LOG_NUM_UCODE;\n\t}\n\n\tif (cmplx_pwr_tot != 0)\n\t\twlc_phy_noise_calc_phy(pi, cmplx_pwr, noise_dbm_ant);\n\n\tfor (core = 0; core < pi->pubpi.phy_corenum; core++) {\n\t\tpi->nphy_noise_win[core][pi->nphy_noise_index] =\n\t\t\tnoise_dbm_ant[core];\n\n\t\tif (noise_dbm_ant[core] > noise_dbm)\n\t\t\tnoise_dbm = noise_dbm_ant[core];\n\t}\n\tpi->nphy_noise_index =\n\t\tMODINC_POW2(pi->nphy_noise_index, PHY_NOISE_WINDOW_SZ);\n\n\treturn noise_dbm;\n\n}\n\nvoid wlc_phy_noise_sample_intr(struct brcms_phy_pub *pih)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\tu16 jssi_aux;\n\tu8 channel = 0;\n\ts8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;\n\n\tif (ISLCNPHY(pi)) {\n\t\tu32 cmplx_pwr, cmplx_pwr0, cmplx_pwr1;\n\t\tu16 lo, hi;\n\t\ts32 pwr_offset_dB, gain_dB;\n\t\tu16 status_0, status_1;\n\n\t\tjssi_aux = wlapi_bmac_read_shm(pi->sh->physhim, M_JSSI_AUX);\n\t\tchannel = jssi_aux & D11_CURCHANNEL_MAX;\n\n\t\tlo = wlapi_bmac_read_shm(pi->sh->physhim, M_PWRIND_MAP0);\n\t\thi = wlapi_bmac_read_shm(pi->sh->physhim, M_PWRIND_MAP1);\n\t\tcmplx_pwr0 = (hi << 16) + lo;\n\n\t\tlo = wlapi_bmac_read_shm(pi->sh->physhim, M_PWRIND_MAP2);\n\t\thi = wlapi_bmac_read_shm(pi->sh->physhim, M_PWRIND_MAP3);\n\t\tcmplx_pwr1 = (hi << 16) + lo;\n\t\tcmplx_pwr = (cmplx_pwr0 + cmplx_pwr1) >> 6;\n\n\t\tstatus_0 = 0x44;\n\t\tstatus_1 = wlapi_bmac_read_shm(pi->sh->physhim, M_JSSI_0);\n\t\tif ((cmplx_pwr > 0 && cmplx_pwr < 500)\n\t\t    && ((status_1 & 0xc000) == 0x4000)) {\n\n\t\t\twlc_phy_compute_dB(&cmplx_pwr, &noise_dbm,\n\t\t\t\t\t   pi->pubpi.phy_corenum);\n\t\t\tpwr_offset_dB = (read_phy_reg(pi, 0x434) & 0xFF);\n\t\t\tif (pwr_offset_dB > 127)\n\t\t\t\tpwr_offset_dB -= 256;\n\n\t\t\tnoise_dbm += (s8) (pwr_offset_dB - 30);\n\n\t\t\tgain_dB = (status_0 & 0x1ff);\n\t\t\tnoise_dbm -= (s8) (gain_dB);\n\t\t} else {\n\t\t\tnoise_dbm = PHY_NOISE_FIXED_VAL_LCNPHY;\n\t\t}\n\t} else if (ISNPHY(pi)) {\n\n\t\tjssi_aux = wlapi_bmac_read_shm(pi->sh->physhim, M_JSSI_AUX);\n\t\tchannel = jssi_aux & D11_CURCHANNEL_MAX;\n\n\t\tnoise_dbm = wlc_phy_noise_read_shmem(pi);\n\t}\n\n\twlc_phy_noise_cb(pi, channel, noise_dbm);\n\n}\n\nstatic void\nwlc_phy_noise_sample_request(struct brcms_phy_pub *pih, u8 reason, u8 ch)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\ts8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;\n\tbool sampling_in_progress = (pi->phynoise_state != 0);\n\tbool wait_for_intr = true;\n\n\tswitch (reason) {\n\tcase PHY_NOISE_SAMPLE_MON:\n\t\tpi->phynoise_chan_watchdog = ch;\n\t\tpi->phynoise_state |= PHY_NOISE_STATE_MON;\n\t\tbreak;\n\n\tcase PHY_NOISE_SAMPLE_EXTERNAL:\n\t\tpi->phynoise_state |= PHY_NOISE_STATE_EXTERNAL;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (sampling_in_progress)\n\t\treturn;\n\n\tpi->phynoise_now = pi->sh->now;\n\n\tif (pi->phy_fixed_noise) {\n\t\tif (ISNPHY(pi)) {\n\t\t\tpi->nphy_noise_win[WL_ANT_IDX_1][pi->nphy_noise_index] =\n\t\t\t\tPHY_NOISE_FIXED_VAL_NPHY;\n\t\t\tpi->nphy_noise_win[WL_ANT_IDX_2][pi->nphy_noise_index] =\n\t\t\t\tPHY_NOISE_FIXED_VAL_NPHY;\n\t\t\tpi->nphy_noise_index = MODINC_POW2(pi->nphy_noise_index,\n\t\t\t\t\t\t\t   PHY_NOISE_WINDOW_SZ);\n\t\t\tnoise_dbm = PHY_NOISE_FIXED_VAL_NPHY;\n\t\t} else {\n\t\t\tnoise_dbm = PHY_NOISE_FIXED_VAL;\n\t\t}\n\n\t\twait_for_intr = false;\n\t\tgoto done;\n\t}\n\n\tif (ISLCNPHY(pi)) {\n\t\tif (!pi->phynoise_polling\n\t\t    || (reason == PHY_NOISE_SAMPLE_EXTERNAL)) {\n\t\t\twlapi_bmac_write_shm(pi->sh->physhim, M_JSSI_0, 0);\n\t\t\twlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP0, 0);\n\t\t\twlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP1, 0);\n\t\t\twlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP2, 0);\n\t\t\twlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP3, 0);\n\n\t\t\tbcma_set32(pi->d11core, D11REGOFFS(maccommand),\n\t\t\t\t   MCMD_BG_NOISE);\n\t\t} else {\n\t\t\twlapi_suspend_mac_and_wait(pi->sh->physhim);\n\t\t\twlc_lcnphy_deaf_mode(pi, (bool) 0);\n\t\t\tnoise_dbm = (s8) wlc_lcnphy_rx_signal_power(pi, 20);\n\t\t\twlc_lcnphy_deaf_mode(pi, (bool) 1);\n\t\t\twlapi_enable_mac(pi->sh->physhim);\n\t\t\twait_for_intr = false;\n\t\t}\n\t} else if (ISNPHY(pi)) {\n\t\tif (!pi->phynoise_polling\n\t\t    || (reason == PHY_NOISE_SAMPLE_EXTERNAL)) {\n\n\t\t\twlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP0, 0);\n\t\t\twlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP1, 0);\n\t\t\twlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP2, 0);\n\t\t\twlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP3, 0);\n\n\t\t\tbcma_set32(pi->d11core, D11REGOFFS(maccommand),\n\t\t\t\t   MCMD_BG_NOISE);\n\t\t} else {\n\t\t\tstruct phy_iq_est est[PHY_CORE_MAX];\n\t\t\tu32 cmplx_pwr[PHY_CORE_MAX];\n\t\t\ts8 noise_dbm_ant[PHY_CORE_MAX];\n\t\t\tu16 log_num_samps, num_samps, classif_state = 0;\n\t\t\tu8 wait_time = 32;\n\t\t\tu8 wait_crs = 0;\n\t\t\tu8 i;\n\n\t\t\tmemset((u8 *) est, 0, sizeof(est));\n\t\t\tmemset((u8 *) cmplx_pwr, 0, sizeof(cmplx_pwr));\n\t\t\tmemset((u8 *) noise_dbm_ant, 0, sizeof(noise_dbm_ant));\n\n\t\t\tlog_num_samps = PHY_NOISE_SAMPLE_LOG_NUM_NPHY;\n\t\t\tnum_samps = 1 << log_num_samps;\n\n\t\t\twlapi_suspend_mac_and_wait(pi->sh->physhim);\n\t\t\tclassif_state = wlc_phy_classifier_nphy(pi, 0, 0);\n\t\t\twlc_phy_classifier_nphy(pi, 3, 0);\n\t\t\twlc_phy_rx_iq_est_nphy(pi, est, num_samps, wait_time,\n\t\t\t\t\t       wait_crs);\n\t\t\twlc_phy_classifier_nphy(pi, (0x7 << 0), classif_state);\n\t\t\twlapi_enable_mac(pi->sh->physhim);\n\n\t\t\tfor (i = 0; i < pi->pubpi.phy_corenum; i++)\n\t\t\t\tcmplx_pwr[i] = (est[i].i_pwr + est[i].q_pwr) >>\n\t\t\t\t\t       log_num_samps;\n\n\t\t\twlc_phy_noise_calc_phy(pi, cmplx_pwr, noise_dbm_ant);\n\n\t\t\tfor (i = 0; i < pi->pubpi.phy_corenum; i++) {\n\t\t\t\tpi->nphy_noise_win[i][pi->nphy_noise_index] =\n\t\t\t\t\tnoise_dbm_ant[i];\n\n\t\t\t\tif (noise_dbm_ant[i] > noise_dbm)\n\t\t\t\t\tnoise_dbm = noise_dbm_ant[i];\n\t\t\t}\n\t\t\tpi->nphy_noise_index = MODINC_POW2(pi->nphy_noise_index,\n\t\t\t\t\t\t\t   PHY_NOISE_WINDOW_SZ);\n\n\t\t\twait_for_intr = false;\n\t\t}\n\t}\n\ndone:\n\n\tif (!wait_for_intr)\n\t\twlc_phy_noise_cb(pi, ch, noise_dbm);\n\n}\n\nvoid wlc_phy_noise_sample_request_external(struct brcms_phy_pub *pih)\n{\n\tu8 channel;\n\n\tchannel = CHSPEC_CHANNEL(wlc_phy_chanspec_get(pih));\n\n\twlc_phy_noise_sample_request(pih, PHY_NOISE_SAMPLE_EXTERNAL, channel);\n}\n\nstatic const s8 lcnphy_gain_index_offset_for_pkt_rssi[] = {\n\t8,\n\t8,\n\t8,\n\t8,\n\t8,\n\t8,\n\t8,\n\t9,\n\t10,\n\t8,\n\t8,\n\t7,\n\t7,\n\t1,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t2,\n\t1,\n\t1,\n\t0,\n\t0,\n\t0,\n\t0\n};\n\nvoid wlc_phy_compute_dB(u32 *cmplx_pwr, s8 *p_cmplx_pwr_dB, u8 core)\n{\n\tu8 msb, secondmsb, i;\n\tu32 tmp;\n\n\tfor (i = 0; i < core; i++) {\n\t\tsecondmsb = 0;\n\t\ttmp = cmplx_pwr[i];\n\t\tmsb = fls(tmp);\n\t\tif (msb)\n\t\t\tsecondmsb = (u8) ((tmp >> (--msb - 1)) & 1);\n\t\tp_cmplx_pwr_dB[i] = (s8) (3 * msb + 2 * secondmsb);\n\t}\n}\n\nint wlc_phy_rssi_compute(struct brcms_phy_pub *pih,\n\t\t\t struct d11rxhdr *rxh)\n{\n\tint rssi = rxh->PhyRxStatus_1 & PRXS1_JSSI_MASK;\n\tuint radioid = pih->radioid;\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\n\tif ((pi->sh->corerev >= 11)\n\t    && !(rxh->RxStatus2 & RXS_PHYRXST_VALID)) {\n\t\trssi = BRCMS_RSSI_INVALID;\n\t\tgoto end;\n\t}\n\n\tif (ISLCNPHY(pi)) {\n\t\tu8 gidx = (rxh->PhyRxStatus_2 & 0xFC00) >> 10;\n\t\tstruct brcms_phy_lcnphy *pi_lcn = pi->u.pi_lcnphy;\n\n\t\tif (rssi > 127)\n\t\t\trssi -= 256;\n\n\t\trssi = rssi + lcnphy_gain_index_offset_for_pkt_rssi[gidx];\n\t\tif ((rssi > -46) && (gidx > 18))\n\t\t\trssi = rssi + 7;\n\n\t\trssi = rssi + pi_lcn->lcnphy_pkteng_rssi_slope;\n\n\t\trssi = rssi + 2;\n\n\t}\n\n\tif (ISLCNPHY(pi)) {\n\t\tif (rssi > 127)\n\t\t\trssi -= 256;\n\t} else if (radioid == BCM2055_ID || radioid == BCM2056_ID\n\t\t   || radioid == BCM2057_ID) {\n\t\trssi = wlc_phy_rssi_compute_nphy(pi, rxh);\n\t}\n\nend:\n\treturn rssi;\n}\n\nvoid wlc_phy_freqtrack_start(struct brcms_phy_pub *pih)\n{\n\treturn;\n}\n\nvoid wlc_phy_freqtrack_end(struct brcms_phy_pub *pih)\n{\n\treturn;\n}\n\nvoid wlc_phy_set_deaf(struct brcms_phy_pub *ppi, bool user_flag)\n{\n\tstruct brcms_phy *pi;\n\tpi = (struct brcms_phy *) ppi;\n\n\tif (ISLCNPHY(pi))\n\t\twlc_lcnphy_deaf_mode(pi, true);\n\telse if (ISNPHY(pi))\n\t\twlc_nphy_deaf_mode(pi, true);\n}\n\nvoid wlc_phy_watchdog(struct brcms_phy_pub *pih)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\tbool delay_phy_cal = false;\n\tpi->sh->now++;\n\n\tif (!pi->watchdog_override)\n\t\treturn;\n\n\tif (!(SCAN_RM_IN_PROGRESS(pi) || PLT_INPROG_PHY(pi)))\n\t\twlc_phy_noise_sample_request((struct brcms_phy_pub *) pi,\n\t\t\t\t\t     PHY_NOISE_SAMPLE_MON,\n\t\t\t\t\t     CHSPEC_CHANNEL(pi->\n\t\t\t\t\t\t\t    radio_chanspec));\n\n\tif (pi->phynoise_state && (pi->sh->now - pi->phynoise_now) > 5)\n\t\tpi->phynoise_state = 0;\n\n\tif ((!pi->phycal_txpower) ||\n\t    ((pi->sh->now - pi->phycal_txpower) >= pi->sh->fast_timer)) {\n\n\t\tif (!SCAN_INPROG_PHY(pi) && wlc_phy_cal_txpower_recalc_sw(pi))\n\t\t\tpi->phycal_txpower = pi->sh->now;\n\t}\n\n\tif ((SCAN_RM_IN_PROGRESS(pi) || PLT_INPROG_PHY(pi)\n\t     || ASSOC_INPROG_PHY(pi)))\n\t\treturn;\n\n\tif (ISNPHY(pi) && !pi->disable_percal && !delay_phy_cal) {\n\n\t\tif ((pi->nphy_perical != PHY_PERICAL_DISABLE) &&\n\t\t    (pi->nphy_perical != PHY_PERICAL_MANUAL) &&\n\t\t    ((pi->sh->now - pi->nphy_perical_last) >=\n\t\t     pi->sh->glacial_timer))\n\t\t\twlc_phy_cal_perical((struct brcms_phy_pub *) pi,\n\t\t\t\t\t    PHY_PERICAL_WATCHDOG);\n\n\t\twlc_phy_txpwr_papd_cal_nphy(pi);\n\t}\n\n\tif (ISLCNPHY(pi)) {\n\t\tif (pi->phy_forcecal ||\n\t\t    ((pi->sh->now - pi->phy_lastcal) >=\n\t\t     pi->sh->glacial_timer)) {\n\t\t\tif (!(SCAN_RM_IN_PROGRESS(pi) || ASSOC_INPROG_PHY(pi)))\n\t\t\t\twlc_lcnphy_calib_modes(\n\t\t\t\t\tpi,\n\t\t\t\t\tLCNPHY_PERICAL_TEMPBASED_TXPWRCTRL);\n\t\t\tif (!\n\t\t\t    (SCAN_RM_IN_PROGRESS(pi) || PLT_INPROG_PHY(pi)\n\t\t\t     || ASSOC_INPROG_PHY(pi)\n\t\t\t     || pi->carrier_suppr_disable\n\t\t\t     || pi->disable_percal))\n\t\t\t\twlc_lcnphy_calib_modes(pi,\n\t\t\t\t\t\t       PHY_PERICAL_WATCHDOG);\n\t\t}\n\t}\n}\n\nvoid wlc_phy_BSSinit(struct brcms_phy_pub *pih, bool bonlyap, int rssi)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\tuint i;\n\tuint k;\n\n\tfor (i = 0; i < MA_WINDOW_SZ; i++)\n\t\tpi->sh->phy_noise_window[i] = (s8) (rssi & 0xff);\n\tif (ISLCNPHY(pi)) {\n\t\tfor (i = 0; i < MA_WINDOW_SZ; i++)\n\t\t\tpi->sh->phy_noise_window[i] =\n\t\t\t\tPHY_NOISE_FIXED_VAL_LCNPHY;\n\t}\n\tpi->sh->phy_noise_index = 0;\n\n\tfor (i = 0; i < PHY_NOISE_WINDOW_SZ; i++) {\n\t\tfor (k = WL_ANT_IDX_1; k < WL_ANT_RX_MAX; k++)\n\t\t\tpi->nphy_noise_win[k][i] = PHY_NOISE_FIXED_VAL_NPHY;\n\t}\n\tpi->nphy_noise_index = 0;\n}\n\nvoid\nwlc_phy_papd_decode_epsilon(u32 epsilon, s32 *eps_real, s32 *eps_imag)\n{\n\t*eps_imag = (epsilon >> 13);\n\tif (*eps_imag > 0xfff)\n\t\t*eps_imag -= 0x2000;\n\n\t*eps_real = (epsilon & 0x1fff);\n\tif (*eps_real > 0xfff)\n\t\t*eps_real -= 0x2000;\n}\n\nvoid wlc_phy_cal_perical_mphase_reset(struct brcms_phy *pi)\n{\n\twlapi_del_timer(pi->phycal_timer);\n\n\tpi->cal_type_override = PHY_PERICAL_AUTO;\n\tpi->mphase_cal_phase_id = MPHASE_CAL_STATE_IDLE;\n\tpi->mphase_txcal_cmdidx = 0;\n}\n\nstatic void\nwlc_phy_cal_perical_mphase_schedule(struct brcms_phy *pi, uint delay)\n{\n\n\tif ((pi->nphy_perical != PHY_PERICAL_MPHASE) &&\n\t    (pi->nphy_perical != PHY_PERICAL_MANUAL))\n\t\treturn;\n\n\twlapi_del_timer(pi->phycal_timer);\n\n\tpi->mphase_cal_phase_id = MPHASE_CAL_STATE_INIT;\n\twlapi_add_timer(pi->phycal_timer, delay, 0);\n}\n\nvoid wlc_phy_cal_perical(struct brcms_phy_pub *pih, u8 reason)\n{\n\ts16 nphy_currtemp = 0;\n\ts16 delta_temp = 0;\n\tbool do_periodic_cal = true;\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\n\tif (!ISNPHY(pi))\n\t\treturn;\n\n\tif ((pi->nphy_perical == PHY_PERICAL_DISABLE) ||\n\t    (pi->nphy_perical == PHY_PERICAL_MANUAL))\n\t\treturn;\n\n\tswitch (reason) {\n\tcase PHY_PERICAL_DRIVERUP:\n\t\tbreak;\n\n\tcase PHY_PERICAL_PHYINIT:\n\t\tif (pi->nphy_perical == PHY_PERICAL_MPHASE) {\n\t\t\tif (PHY_PERICAL_MPHASE_PENDING(pi))\n\t\t\t\twlc_phy_cal_perical_mphase_reset(pi);\n\n\t\t\twlc_phy_cal_perical_mphase_schedule(\n\t\t\t\tpi,\n\t\t\t\tPHY_PERICAL_INIT_DELAY);\n\t\t}\n\t\tbreak;\n\n\tcase PHY_PERICAL_JOIN_BSS:\n\tcase PHY_PERICAL_START_IBSS:\n\tcase PHY_PERICAL_UP_BSS:\n\t\tif ((pi->nphy_perical == PHY_PERICAL_MPHASE) &&\n\t\t    PHY_PERICAL_MPHASE_PENDING(pi))\n\t\t\twlc_phy_cal_perical_mphase_reset(pi);\n\n\t\tpi->first_cal_after_assoc = true;\n\n\t\tpi->cal_type_override = PHY_PERICAL_FULL;\n\n\t\tif (pi->phycal_tempdelta)\n\t\t\tpi->nphy_lastcal_temp = wlc_phy_tempsense_nphy(pi);\n\n\t\twlc_phy_cal_perical_nphy_run(pi, PHY_PERICAL_FULL);\n\t\tbreak;\n\n\tcase PHY_PERICAL_WATCHDOG:\n\t\tif (pi->phycal_tempdelta) {\n\t\t\tnphy_currtemp = wlc_phy_tempsense_nphy(pi);\n\t\t\tdelta_temp =\n\t\t\t\t(nphy_currtemp > pi->nphy_lastcal_temp) ?\n\t\t\t\tnphy_currtemp - pi->nphy_lastcal_temp :\n\t\t\t\tpi->nphy_lastcal_temp - nphy_currtemp;\n\n\t\t\tif ((delta_temp < (s16) pi->phycal_tempdelta) &&\n\t\t\t    (pi->nphy_txiqlocal_chanspec ==\n\t\t\t     pi->radio_chanspec))\n\t\t\t\tdo_periodic_cal = false;\n\t\t\telse\n\t\t\t\tpi->nphy_lastcal_temp = nphy_currtemp;\n\t\t}\n\n\t\tif (do_periodic_cal) {\n\t\t\tif (pi->nphy_perical == PHY_PERICAL_MPHASE) {\n\t\t\t\tif (!PHY_PERICAL_MPHASE_PENDING(pi))\n\t\t\t\t\twlc_phy_cal_perical_mphase_schedule(\n\t\t\t\t\t\tpi,\n\t\t\t\t\t\tPHY_PERICAL_WDOG_DELAY);\n\t\t\t} else if (pi->nphy_perical == PHY_PERICAL_SPHASE)\n\t\t\t\twlc_phy_cal_perical_nphy_run(pi,\n\t\t\t\t\t\t\t     PHY_PERICAL_AUTO);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid wlc_phy_cal_perical_mphase_restart(struct brcms_phy *pi)\n{\n\tpi->mphase_cal_phase_id = MPHASE_CAL_STATE_INIT;\n\tpi->mphase_txcal_cmdidx = 0;\n}\n\nu8 wlc_phy_nbits(s32 value)\n{\n\ts32 abs_val;\n\tu8 nbits = 0;\n\n\tabs_val = abs(value);\n\twhile ((abs_val >> nbits) > 0)\n\t\tnbits++;\n\n\treturn nbits;\n}\n\nvoid wlc_phy_stf_chain_init(struct brcms_phy_pub *pih, u8 txchain, u8 rxchain)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\n\tpi->sh->hw_phytxchain = txchain;\n\tpi->sh->hw_phyrxchain = rxchain;\n\tpi->sh->phytxchain = txchain;\n\tpi->sh->phyrxchain = rxchain;\n\tpi->pubpi.phy_corenum = (u8)hweight8(pi->sh->phyrxchain);\n}\n\nvoid wlc_phy_stf_chain_set(struct brcms_phy_pub *pih, u8 txchain, u8 rxchain)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\n\tpi->sh->phytxchain = txchain;\n\n\tif (ISNPHY(pi))\n\t\twlc_phy_rxcore_setstate_nphy(pih, rxchain);\n\n\tpi->pubpi.phy_corenum = (u8)hweight8(pi->sh->phyrxchain);\n}\n\nvoid wlc_phy_stf_chain_get(struct brcms_phy_pub *pih, u8 *txchain, u8 *rxchain)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\n\t*txchain = pi->sh->phytxchain;\n\t*rxchain = pi->sh->phyrxchain;\n}\n\nu8 wlc_phy_stf_chain_active_get(struct brcms_phy_pub *pih)\n{\n\ts16 nphy_currtemp;\n\tu8 active_bitmap;\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\n\tactive_bitmap = (pi->phy_txcore_heatedup) ? 0x31 : 0x33;\n\n\tif (!pi->watchdog_override)\n\t\treturn active_bitmap;\n\n\tif (NREV_GE(pi->pubpi.phy_rev, 6)) {\n\t\twlapi_suspend_mac_and_wait(pi->sh->physhim);\n\t\tnphy_currtemp = wlc_phy_tempsense_nphy(pi);\n\t\twlapi_enable_mac(pi->sh->physhim);\n\n\t\tif (!pi->phy_txcore_heatedup) {\n\t\t\tif (nphy_currtemp >= pi->phy_txcore_disable_temp) {\n\t\t\t\tactive_bitmap &= 0xFD;\n\t\t\t\tpi->phy_txcore_heatedup = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (nphy_currtemp <= pi->phy_txcore_enable_temp) {\n\t\t\t\tactive_bitmap |= 0x2;\n\t\t\t\tpi->phy_txcore_heatedup = false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn active_bitmap;\n}\n\ns8 wlc_phy_stf_ssmode_get(struct brcms_phy_pub *pih, u16 chanspec)\n{\n\tstruct brcms_phy *pi = container_of(pih, struct brcms_phy, pubpi_ro);\n\tu8 siso_mcs_id, cdd_mcs_id;\n\n\tsiso_mcs_id =\n\t\t(CHSPEC_IS40(chanspec)) ? TXP_FIRST_MCS_40_SISO :\n\t\tTXP_FIRST_MCS_20_SISO;\n\tcdd_mcs_id =\n\t\t(CHSPEC_IS40(chanspec)) ? TXP_FIRST_MCS_40_CDD :\n\t\tTXP_FIRST_MCS_20_CDD;\n\n\tif (pi->tx_power_target[siso_mcs_id] >\n\t    (pi->tx_power_target[cdd_mcs_id] + 12))\n\t\treturn PHY_TXC1_MODE_SISO;\n\telse\n\t\treturn PHY_TXC1_MODE_CDD;\n}\n\nconst u8 *wlc_phy_get_ofdm_rate_lookup(void)\n{\n\treturn ofdm_rate_lookup;\n}\n\nvoid wlc_lcnphy_epa_switch(struct brcms_phy *pi, bool mode)\n{\n\tif ((pi->sh->chip == BCMA_CHIP_ID_BCM4313) &&\n\t    (pi->sh->boardflags & BFL_FEM)) {\n\t\tif (mode) {\n\t\t\tu16 txant = 0;\n\t\t\ttxant = wlapi_bmac_get_txant(pi->sh->physhim);\n\t\t\tif (txant == 1) {\n\t\t\t\tmod_phy_reg(pi, 0x44d, (0x1 << 2), (1) << 2);\n\n\t\t\t\tmod_phy_reg(pi, 0x44c, (0x1 << 2), (1) << 2);\n\n\t\t\t}\n\n\t\t\tbcma_chipco_gpio_control(&pi->d11core->bus->drv_cc,\n\t\t\t\t\t\t 0x0, 0x0);\n\t\t\tbcma_chipco_gpio_out(&pi->d11core->bus->drv_cc,\n\t\t\t\t\t     ~0x40, 0x40);\n\t\t\tbcma_chipco_gpio_outen(&pi->d11core->bus->drv_cc,\n\t\t\t\t\t       ~0x40, 0x40);\n\t\t} else {\n\t\t\tmod_phy_reg(pi, 0x44c, (0x1 << 2), (0) << 2);\n\n\t\t\tmod_phy_reg(pi, 0x44d, (0x1 << 2), (0) << 2);\n\n\t\t\tbcma_chipco_gpio_out(&pi->d11core->bus->drv_cc,\n\t\t\t\t\t     ~0x40, 0x00);\n\t\t\tbcma_chipco_gpio_outen(&pi->d11core->bus->drv_cc,\n\t\t\t\t\t       ~0x40, 0x00);\n\t\t\tbcma_chipco_gpio_control(&pi->d11core->bus->drv_cc,\n\t\t\t\t\t\t 0x0, 0x40);\n\t\t}\n\t}\n}\n\nvoid wlc_phy_ldpc_override_set(struct brcms_phy_pub *ppi, bool ldpc)\n{\n\treturn;\n}\n\nvoid\nwlc_phy_get_pwrdet_offsets(struct brcms_phy *pi, s8 *cckoffset, s8 *ofdmoffset)\n{\n\t*cckoffset = 0;\n\t*ofdmoffset = 0;\n}\n\ns8 wlc_phy_upd_rssi_offset(struct brcms_phy *pi, s8 rssi, u16 chanspec)\n{\n\n\treturn rssi;\n}\n\nbool wlc_phy_txpower_ipa_ison(struct brcms_phy_pub *ppi)\n{\n\tstruct brcms_phy *pi = container_of(ppi, struct brcms_phy, pubpi_ro);\n\n\tif (ISNPHY(pi))\n\t\treturn wlc_phy_n_txpower_ipa_ison(pi);\n\telse\n\t\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}