{
  "module_name": "phy_qmath.c",
  "hash_id": "2281fec4a18be3ba9814303152f18fa61393d24111f6942222ce78108c73ebb0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmsmac/phy/phy_qmath.c",
  "human_readable_source": "\n \n\n#include \"phy_qmath.h\"\n\n \nu16 qm_mulu16(u16 op1, u16 op2)\n{\n\treturn (u16) (((u32) op1 * (u32) op2) >> 16);\n}\n\n \ns16 qm_muls16(s16 op1, s16 op2)\n{\n\ts32 result;\n\tif (op1 == (s16) 0x8000 && op2 == (s16) 0x8000)\n\t\tresult = 0x7fffffff;\n\telse\n\t\tresult = ((s32) (op1) * (s32) (op2));\n\n\treturn (s16) (result >> 15);\n}\n\n \ns32 qm_add32(s32 op1, s32 op2)\n{\n\ts32 result;\n\tresult = op1 + op2;\n\tif (op1 < 0 && op2 < 0 && result > 0)\n\t\tresult = 0x80000000;\n\telse if (op1 > 0 && op2 > 0 && result < 0)\n\t\tresult = 0x7fffffff;\n\n\treturn result;\n}\n\n \ns16 qm_add16(s16 op1, s16 op2)\n{\n\ts16 result;\n\ts32 temp = (s32) op1 + (s32) op2;\n\tif (temp > (s32) 0x7fff)\n\t\tresult = (s16) 0x7fff;\n\telse if (temp < (s32) 0xffff8000)\n\t\tresult = (s16) 0xffff8000;\n\telse\n\t\tresult = (s16) temp;\n\n\treturn result;\n}\n\n \ns16 qm_sub16(s16 op1, s16 op2)\n{\n\ts16 result;\n\ts32 temp = (s32) op1 - (s32) op2;\n\tif (temp > (s32) 0x7fff)\n\t\tresult = (s16) 0x7fff;\n\telse if (temp < (s32) 0xffff8000)\n\t\tresult = (s16) 0xffff8000;\n\telse\n\t\tresult = (s16) temp;\n\n\treturn result;\n}\n\n \ns32 qm_shl32(s32 op, int shift)\n{\n\tint i;\n\ts32 result;\n\tresult = op;\n\tif (shift > 31)\n\t\tshift = 31;\n\telse if (shift < -31)\n\t\tshift = -31;\n\tif (shift >= 0) {\n\t\tfor (i = 0; i < shift; i++)\n\t\t\tresult = qm_add32(result, result);\n\t} else {\n\t\tresult = result >> (-shift);\n\t}\n\n\treturn result;\n}\n\n \ns16 qm_shl16(s16 op, int shift)\n{\n\tint i;\n\ts16 result;\n\tresult = op;\n\tif (shift > 15)\n\t\tshift = 15;\n\telse if (shift < -15)\n\t\tshift = -15;\n\tif (shift > 0) {\n\t\tfor (i = 0; i < shift; i++)\n\t\t\tresult = qm_add16(result, result);\n\t} else {\n\t\tresult = result >> (-shift);\n\t}\n\n\treturn result;\n}\n\n \ns16 qm_shr16(s16 op, int shift)\n{\n\treturn qm_shl16(op, -shift);\n}\n\n \ns16 qm_norm32(s32 op)\n{\n\tu16 u16extraSignBits;\n\tif (op == 0) {\n\t\treturn 31;\n\t} else {\n\t\tu16extraSignBits = 0;\n\t\twhile ((op >> 31) == (op >> 30)) {\n\t\t\tu16extraSignBits++;\n\t\t\top = op << 1;\n\t\t}\n\t}\n\treturn u16extraSignBits;\n}\n\n \nstatic const s16 log_table[] = {\n\t0,\n\t1455,\n\t2866,\n\t4236,\n\t5568,\n\t6863,\n\t8124,\n\t9352,\n\t10549,\n\t11716,\n\t12855,\n\t13968,\n\t15055,\n\t16117,\n\t17156,\n\t18173,\n\t19168,\n\t20143,\n\t21098,\n\t22034,\n\t22952,\n\t23852,\n\t24736,\n\t25604,\n\t26455,\n\t27292,\n\t28114,\n\t28922,\n\t29717,\n\t30498,\n\t31267,\n\t32024,\n\t32767\n};\n\n#define LOG_TABLE_SIZE 32        \n#define LOG2_LOG_TABLE_SIZE 5    \n#define Q_LOG_TABLE 15           \n#define LOG10_2         19728    \n\n \nvoid qm_log10(s32 N, s16 qN, s16 *log10N, s16 *qLog10N)\n{\n\ts16 s16norm, s16tableIndex, s16errorApproximation;\n\tu16 u16offset;\n\ts32 s32log;\n\n\t \n\ts16norm = qm_norm32(N);\n\tN = N << s16norm;\n\n\t \n\tqN = qN + s16norm - 30;\n\n\t \n\ts16tableIndex = (s16) (N >> (32 - (2 + LOG2_LOG_TABLE_SIZE)));\n\n\t \n\ts16tableIndex =\n\t\ts16tableIndex & (s16) ((1 << LOG2_LOG_TABLE_SIZE) - 1);\n\n\t \n\tN = N & ((1 << (32 - (2 + LOG2_LOG_TABLE_SIZE))) - 1);\n\n\t \n\tu16offset = (u16) (N >> (32 - (2 + LOG2_LOG_TABLE_SIZE + 16)));\n\n\t \n\ts32log = log_table[s16tableIndex];       \n\n\t \n\ts16errorApproximation = (s16) qm_mulu16(u16offset,\n\t\t\t\t(u16) (log_table[s16tableIndex + 1] -\n\t\t\t\t       log_table[s16tableIndex]));\n\n\t  \n\ts32log = qm_add16((s16) s32log, s16errorApproximation);\n\n\t \n\ts32log = qm_add32(s32log, ((s32) -qN) << 15);    \n\n\t \n\ts16norm = qm_norm32(s32log);\n\n\t \n\t \n\ts32log = qm_shl32(s32log, s16norm - 16);\n\n\t \n\t*log10N = qm_muls16((s16) s32log, (s16) LOG10_2);\n\n\t \n\t*qLog10N = 15 + s16norm - 16 + 1;\n\n\treturn;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}