{
  "module_name": "ampdu.c",
  "hash_id": "eb6c9aac27ed1d9554a3ea300e575aa0597441535b2ed57cd59bdda3a83520e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmsmac/ampdu.c",
  "human_readable_source": " \n#include <net/mac80211.h>\n\n#include \"rate.h\"\n#include \"scb.h\"\n#include \"phy/phy_hal.h\"\n#include \"antsel.h\"\n#include \"main.h\"\n#include \"ampdu.h\"\n#include \"debug.h\"\n#include \"brcms_trace_events.h\"\n\n \n#define AMPDU_MAX_MPDU\t\t\t32\n \n#define AMPDU_NUM_MPDU_LEGACY\t\t16\n \n#define AMPDU_TX_BA_MAX_WSIZE\t\t64\n \n#define AMPDU_TX_BA_DEF_WSIZE\t\t64\n \n#define AMPDU_RX_BA_DEF_WSIZE\t\t64\n \n#define AMPDU_RX_BA_MAX_WSIZE\t\t64\n \n#define\tAMPDU_MAX_DUR\t\t\t5\n \n#define AMPDU_DEF_RETRY_LIMIT\t\t5\n \n#define AMPDU_DEF_RR_RETRY_LIMIT\t2\n \n#define AMPDU_DEF_FFPLD_RSVD\t\t2048\n \n#define AMPDU_INI_FREE\t\t\t10\n \n#define\tAMPDU_SCB_MAX_RELEASE\t\t20\n\n#define NUM_FFPLD_FIFO 4\t \n#define FFPLD_TX_MAX_UNFL   200\t \n#define FFPLD_MPDU_SIZE 1800\t \n#define FFPLD_MAX_MCS 23\t \n#define FFPLD_PLD_INCR 1000\t \n#define FFPLD_MAX_AMPDU_CNT 5000\t \n\n#define AMPDU_DELIMITER_LEN\t4\n\n \n#define AMPDU_NUM_MPDU\t\t16\n\n#define TX_SEQ_TO_INDEX(seq) ((seq) % AMPDU_TX_BA_MAX_WSIZE)\n\n \n#define AMPDU_MAX_MPDU_OVERHEAD (FCS_LEN + DOT11_ICV_AES_LEN +\\\n\tAMPDU_DELIMITER_LEN + 3\\\n\t+ DOT11_A4_HDR_LEN + DOT11_QOS_LEN + DOT11_IV_MAX_LEN)\n\n \n#define MODADD_POW2(x, y, bound) (((x) + (y)) & ((bound) - 1))\n#define MODSUB_POW2(x, y, bound) (((x) - (y)) & ((bound) - 1))\n\n \nstruct brcms_fifo_info {\n\tu16 ampdu_pld_size;\n\tu8 mcs2ampdu_table[FFPLD_MAX_MCS + 1];\n\tu16 prev_txfunfl;\n\tu32 accum_txfunfl;\n\tu32 accum_txampdu;\n\tu32 prev_txampdu;\n\tu32 dmaxferrate;\n};\n\n \nstruct ampdu_info {\n\tstruct brcms_c_info *wlc;\n\tint scb_handle;\n\tu8 ini_enable[AMPDU_MAX_SCB_TID];\n\tu8 ba_tx_wsize;\n\tu8 ba_rx_wsize;\n\tu8 retry_limit;\n\tu8 rr_retry_limit;\n\tu8 retry_limit_tid[AMPDU_MAX_SCB_TID];\n\tu8 rr_retry_limit_tid[AMPDU_MAX_SCB_TID];\n\tu8 mpdu_density;\n\ts8 max_pdu;\n\tu8 dur;\n\tu8 rx_factor;\n\tu32 ffpld_rsvd;\n\tu32 max_txlen[MCS_TABLE_SIZE][2][2];\n\tbool mfbr;\n\tu32 tx_max_funl;\n\tstruct brcms_fifo_info fifo_tb[NUM_FFPLD_FIFO];\n};\n\n \nstruct cb_del_ampdu_pars {\n\tstruct ieee80211_sta *sta;\n\tu16 tid;\n};\n\nstatic void brcms_c_scb_ampdu_update_max_txlen(struct ampdu_info *ampdu, u8 dur)\n{\n\tu32 rate, mcs;\n\n\tfor (mcs = 0; mcs < MCS_TABLE_SIZE; mcs++) {\n\t\t \n\t\t \n\t\trate = mcs_2_rate(mcs, false, false);\n\t\tampdu->max_txlen[mcs][0][0] = (rate * dur) >> 3;\n\t\t \n\t\trate = mcs_2_rate(mcs, true, false);\n\t\tampdu->max_txlen[mcs][1][0] = (rate * dur) >> 3;\n\t\t \n\t\trate = mcs_2_rate(mcs, false, true);\n\t\tampdu->max_txlen[mcs][0][1] = (rate * dur) >> 3;\n\t\t \n\t\trate = mcs_2_rate(mcs, true, true);\n\t\tampdu->max_txlen[mcs][1][1] = (rate * dur) >> 3;\n\t}\n}\n\nstatic bool brcms_c_ampdu_cap(struct ampdu_info *ampdu)\n{\n\tif (BRCMS_PHY_11N_CAP(ampdu->wlc->band))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic int brcms_c_ampdu_set(struct ampdu_info *ampdu, bool on)\n{\n\tstruct brcms_c_info *wlc = ampdu->wlc;\n\tstruct bcma_device *core = wlc->hw->d11core;\n\n\twlc->pub->_ampdu = false;\n\n\tif (on) {\n\t\tif (!(wlc->pub->_n_enab & SUPPORT_11N)) {\n\t\t\tbrcms_err(core, \"wl%d: driver not nmode enabled\\n\",\n\t\t\t\t  wlc->pub->unit);\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tif (!brcms_c_ampdu_cap(ampdu)) {\n\t\t\tbrcms_err(core, \"wl%d: device not ampdu capable\\n\",\n\t\t\t\t  wlc->pub->unit);\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\twlc->pub->_ampdu = on;\n\t}\n\n\treturn 0;\n}\n\nstatic void brcms_c_ffpld_init(struct ampdu_info *ampdu)\n{\n\tint i, j;\n\tstruct brcms_fifo_info *fifo;\n\n\tfor (j = 0; j < NUM_FFPLD_FIFO; j++) {\n\t\tfifo = (ampdu->fifo_tb + j);\n\t\tfifo->ampdu_pld_size = 0;\n\t\tfor (i = 0; i <= FFPLD_MAX_MCS; i++)\n\t\t\tfifo->mcs2ampdu_table[i] = 255;\n\t\tfifo->dmaxferrate = 0;\n\t\tfifo->accum_txampdu = 0;\n\t\tfifo->prev_txfunfl = 0;\n\t\tfifo->accum_txfunfl = 0;\n\n\t}\n}\n\nstruct ampdu_info *brcms_c_ampdu_attach(struct brcms_c_info *wlc)\n{\n\tstruct ampdu_info *ampdu;\n\tint i;\n\n\tampdu = kzalloc(sizeof(struct ampdu_info), GFP_ATOMIC);\n\tif (!ampdu)\n\t\treturn NULL;\n\n\tampdu->wlc = wlc;\n\n\tfor (i = 0; i < AMPDU_MAX_SCB_TID; i++)\n\t\tampdu->ini_enable[i] = true;\n\t \n\tampdu->ini_enable[PRIO_8021D_VO] = false;\n\tampdu->ini_enable[PRIO_8021D_NC] = false;\n\n\t \n\tampdu->ini_enable[PRIO_8021D_NONE] = false;\n\tampdu->ini_enable[PRIO_8021D_BK] = false;\n\n\tampdu->ba_tx_wsize = AMPDU_TX_BA_DEF_WSIZE;\n\tampdu->ba_rx_wsize = AMPDU_RX_BA_DEF_WSIZE;\n\tampdu->mpdu_density = AMPDU_DEF_MPDU_DENSITY;\n\tampdu->max_pdu = AUTO;\n\tampdu->dur = AMPDU_MAX_DUR;\n\n\tampdu->ffpld_rsvd = AMPDU_DEF_FFPLD_RSVD;\n\t \n\tif (BRCMS_ISNPHY(wlc->band) && NREV_LT(wlc->band->phyrev, 2))\n\t\tampdu->rx_factor = IEEE80211_HT_MAX_AMPDU_32K;\n\telse\n\t\tampdu->rx_factor = IEEE80211_HT_MAX_AMPDU_64K;\n\tampdu->retry_limit = AMPDU_DEF_RETRY_LIMIT;\n\tampdu->rr_retry_limit = AMPDU_DEF_RR_RETRY_LIMIT;\n\n\tfor (i = 0; i < AMPDU_MAX_SCB_TID; i++) {\n\t\tampdu->retry_limit_tid[i] = ampdu->retry_limit;\n\t\tampdu->rr_retry_limit_tid[i] = ampdu->rr_retry_limit;\n\t}\n\n\tbrcms_c_scb_ampdu_update_max_txlen(ampdu, ampdu->dur);\n\tampdu->mfbr = false;\n\t \n\tbrcms_c_ampdu_set(ampdu, wlc->pub->_ampdu);\n\n\tampdu->tx_max_funl = FFPLD_TX_MAX_UNFL;\n\tbrcms_c_ffpld_init(ampdu);\n\n\treturn ampdu;\n}\n\nvoid brcms_c_ampdu_detach(struct ampdu_info *ampdu)\n{\n\tkfree(ampdu);\n}\n\nstatic void brcms_c_scb_ampdu_update_config(struct ampdu_info *ampdu,\n\t\t\t\t\t    struct scb *scb)\n{\n\tstruct scb_ampdu *scb_ampdu = &scb->scb_ampdu;\n\tint i;\n\n\tscb_ampdu->max_pdu = AMPDU_NUM_MPDU;\n\n\t \n\tfor (i = 0; i < NUM_FFPLD_FIFO; i++) {\n\t\tif (ampdu->fifo_tb[i].ampdu_pld_size > FFPLD_PLD_INCR)\n\t\t\tscb_ampdu->max_pdu = AMPDU_NUM_MPDU_LEGACY;\n\t}\n\n\t \n\tif (ampdu->max_pdu != AUTO)\n\t\tscb_ampdu->max_pdu = (u8) ampdu->max_pdu;\n\n\tscb_ampdu->release = min_t(u8, scb_ampdu->max_pdu,\n\t\t\t\t   AMPDU_SCB_MAX_RELEASE);\n\n\tif (scb_ampdu->max_rx_ampdu_bytes)\n\t\tscb_ampdu->release = min_t(u8, scb_ampdu->release,\n\t\t\tscb_ampdu->max_rx_ampdu_bytes / 1600);\n\n\tscb_ampdu->release = min(scb_ampdu->release,\n\t\t\t\t ampdu->fifo_tb[TX_AC_BE_FIFO].\n\t\t\t\t mcs2ampdu_table[FFPLD_MAX_MCS]);\n}\n\nstatic void brcms_c_scb_ampdu_update_config_all(struct ampdu_info *ampdu)\n{\n\tbrcms_c_scb_ampdu_update_config(ampdu, &ampdu->wlc->pri_scb);\n}\n\nstatic void brcms_c_ffpld_calc_mcs2ampdu_table(struct ampdu_info *ampdu, int f)\n{\n\tint i;\n\tu32 phy_rate, dma_rate, tmp;\n\tu8 max_mpdu;\n\tstruct brcms_fifo_info *fifo = (ampdu->fifo_tb + f);\n\n\t \n\t \n\tmax_mpdu = min_t(u8, fifo->mcs2ampdu_table[FFPLD_MAX_MCS],\n\t\t\t AMPDU_NUM_MPDU_LEGACY);\n\tphy_rate = mcs_2_rate(FFPLD_MAX_MCS, true, false);\n\tdma_rate =\n\t    (((phy_rate / 100) *\n\t      (max_mpdu * FFPLD_MPDU_SIZE - fifo->ampdu_pld_size))\n\t     / (max_mpdu * FFPLD_MPDU_SIZE)) * 100;\n\tfifo->dmaxferrate = dma_rate;\n\n\t \n\tdma_rate = dma_rate >> 7;\n\tfor (i = 0; i < FFPLD_MAX_MCS; i++) {\n\t\t \n\t\tphy_rate = mcs_2_rate(i, true, false) >> 7;\n\t\tif (phy_rate > dma_rate) {\n\t\t\ttmp = ((fifo->ampdu_pld_size * phy_rate) /\n\t\t\t       ((phy_rate - dma_rate) * FFPLD_MPDU_SIZE)) + 1;\n\t\t\ttmp = min_t(u32, tmp, 255);\n\t\t\tfifo->mcs2ampdu_table[i] = (u8) tmp;\n\t\t}\n\t}\n}\n\n \nstatic int brcms_c_ffpld_check_txfunfl(struct brcms_c_info *wlc, int fid)\n{\n\tstruct ampdu_info *ampdu = wlc->ampdu;\n\tu32 phy_rate = mcs_2_rate(FFPLD_MAX_MCS, true, false);\n\tu32 txunfl_ratio;\n\tu8 max_mpdu;\n\tu32 current_ampdu_cnt = 0;\n\tu16 max_pld_size;\n\tu32 new_txunfl;\n\tstruct brcms_fifo_info *fifo = (ampdu->fifo_tb + fid);\n\tuint xmtfifo_sz;\n\tu16 cur_txunfl;\n\n\t \n\tcur_txunfl = brcms_b_read_shm(wlc->hw,\n\t\t\t\t      M_UCODE_MACSTAT +\n\t\t\t\t      offsetof(struct macstat, txfunfl[fid]));\n\tnew_txunfl = (u16) (cur_txunfl - fifo->prev_txfunfl);\n\tif (new_txunfl == 0) {\n\t\tbrcms_dbg_ht(wlc->hw->d11core,\n\t\t\t     \"TX status FRAG set but no tx underflows\\n\");\n\t\treturn -1;\n\t}\n\tfifo->prev_txfunfl = cur_txunfl;\n\n\tif (!ampdu->tx_max_funl)\n\t\treturn 1;\n\n\t \n\tif (brcms_b_xmtfifo_sz_get(wlc->hw, fid, &xmtfifo_sz))\n\t\treturn -1;\n\n\tif ((TXFIFO_SIZE_UNIT * (u32) xmtfifo_sz) <= ampdu->ffpld_rsvd)\n\t\treturn 1;\n\n\tmax_pld_size = TXFIFO_SIZE_UNIT * xmtfifo_sz - ampdu->ffpld_rsvd;\n\tfifo->accum_txfunfl += new_txunfl;\n\n\t \n\tif (fifo->accum_txfunfl < 10)\n\t\treturn 0;\n\n\tbrcms_dbg_ht(wlc->hw->d11core, \"ampdu_count %d  tx_underflows %d\\n\",\n\t\t     current_ampdu_cnt, fifo->accum_txfunfl);\n\n\t \n\n\ttxunfl_ratio = current_ampdu_cnt / fifo->accum_txfunfl;\n\n\tif (txunfl_ratio > ampdu->tx_max_funl) {\n\t\tif (current_ampdu_cnt >= FFPLD_MAX_AMPDU_CNT)\n\t\t\tfifo->accum_txfunfl = 0;\n\n\t\treturn 0;\n\t}\n\tmax_mpdu = min_t(u8, fifo->mcs2ampdu_table[FFPLD_MAX_MCS],\n\t\t\t AMPDU_NUM_MPDU_LEGACY);\n\n\t \n\n\tif (fifo->ampdu_pld_size >= max_mpdu * FFPLD_MPDU_SIZE) {\n\t\tfifo->accum_txfunfl = 0;\n\t\treturn 0;\n\t}\n\n\tif (fifo->ampdu_pld_size < max_pld_size) {\n\n\t\t \n\t\tfifo->ampdu_pld_size += FFPLD_PLD_INCR;\n\t\tif (fifo->ampdu_pld_size > max_pld_size)\n\t\t\tfifo->ampdu_pld_size = max_pld_size;\n\n\t\t \n\t\tbrcms_c_scb_ampdu_update_config_all(ampdu);\n\n\t\t \n\t\tfifo->dmaxferrate =\n\t\t    (((phy_rate / 100) *\n\t\t      (max_mpdu * FFPLD_MPDU_SIZE - fifo->ampdu_pld_size))\n\t\t     / (max_mpdu * FFPLD_MPDU_SIZE)) * 100;\n\n\t\tbrcms_dbg_ht(wlc->hw->d11core,\n\t\t\t     \"DMA estimated transfer rate %d; \"\n\t\t\t     \"pre-load size %d\\n\",\n\t\t\t     fifo->dmaxferrate, fifo->ampdu_pld_size);\n\t} else {\n\n\t\t \n\t\tif (fifo->mcs2ampdu_table[FFPLD_MAX_MCS] > 1) {\n\t\t\tif (fifo->mcs2ampdu_table[FFPLD_MAX_MCS] == 255)\n\t\t\t\tfifo->mcs2ampdu_table[FFPLD_MAX_MCS] =\n\t\t\t\t    AMPDU_NUM_MPDU_LEGACY - 1;\n\t\t\telse\n\t\t\t\tfifo->mcs2ampdu_table[FFPLD_MAX_MCS] -= 1;\n\n\t\t\t \n\t\t\tbrcms_c_ffpld_calc_mcs2ampdu_table(ampdu, fid);\n\n\t\t\t \n\t\t\tbrcms_c_scb_ampdu_update_config_all(ampdu);\n\t\t}\n\t}\n\tfifo->accum_txfunfl = 0;\n\treturn 0;\n}\n\nvoid\nbrcms_c_ampdu_tx_operational(struct brcms_c_info *wlc, u8 tid,\n\tuint max_rx_ampdu_bytes)  \n{\n\tstruct scb_ampdu *scb_ampdu;\n\tstruct ampdu_info *ampdu = wlc->ampdu;\n\tstruct scb *scb = &wlc->pri_scb;\n\tscb_ampdu = &scb->scb_ampdu;\n\n\tif (!ampdu->ini_enable[tid]) {\n\t\tbrcms_err(wlc->hw->d11core, \"%s: Rejecting tid %d\\n\",\n\t\t\t  __func__, tid);\n\t\treturn;\n\t}\n\n\tscb_ampdu->max_rx_ampdu_bytes = max_rx_ampdu_bytes;\n}\n\nvoid brcms_c_ampdu_reset_session(struct brcms_ampdu_session *session,\n\t\t\t\t struct brcms_c_info *wlc)\n{\n\tsession->wlc = wlc;\n\tskb_queue_head_init(&session->skb_list);\n\tsession->max_ampdu_len = 0;     \n\tsession->max_ampdu_frames = 0;  \n\tsession->ampdu_len = 0;\n\tsession->dma_len = 0;\n}\n\n \nint brcms_c_ampdu_add_frame(struct brcms_ampdu_session *session,\n\t\t\t    struct sk_buff *p)\n{\n\tstruct brcms_c_info *wlc = session->wlc;\n\tstruct ampdu_info *ampdu = wlc->ampdu;\n\tstruct scb *scb = &wlc->pri_scb;\n\tstruct scb_ampdu *scb_ampdu = &scb->scb_ampdu;\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(p);\n\tstruct ieee80211_tx_rate *txrate = tx_info->status.rates;\n\tstruct d11txh *txh = (struct d11txh *)p->data;\n\tunsigned ampdu_frames;\n\tu8 ndelim, tid;\n\tu8 *plcp;\n\tuint len;\n\tu16 mcl;\n\tbool fbr_iscck;\n\tbool rr;\n\n\tndelim = txh->RTSPLCPFallback[AMPDU_FBR_NULL_DELIM];\n\tplcp = (u8 *)(txh + 1);\n\tfbr_iscck = !(le16_to_cpu(txh->XtraFrameTypes) & 0x03);\n\tlen = fbr_iscck ? BRCMS_GET_CCK_PLCP_LEN(txh->FragPLCPFallback) :\n\t\t\t  BRCMS_GET_MIMO_PLCP_LEN(txh->FragPLCPFallback);\n\tlen = roundup(len, 4) + (ndelim + 1) * AMPDU_DELIMITER_LEN;\n\n\tampdu_frames = skb_queue_len(&session->skb_list);\n\tif (ampdu_frames != 0) {\n\t\tstruct sk_buff *first;\n\n\t\tif (ampdu_frames + 1 > session->max_ampdu_frames ||\n\t\t    session->ampdu_len + len > session->max_ampdu_len)\n\t\t\treturn -ENOSPC;\n\n\t\t \n\t\tfirst = skb_peek(&session->skb_list);\n\t\tif (p->priority != first->priority)\n\t\t\treturn -ENOSPC;\n\t}\n\n\t \n\tsession->ampdu_len += len;\n\tsession->dma_len += p->len;\n\n\ttid = (u8)p->priority;\n\n\t \n\tif (txrate[0].count <= ampdu->rr_retry_limit_tid[tid]) {\n\t\ttxrate[0].count++;\n\t\trr = true;\n\t} else {\n\t\ttxrate[1].count++;\n\t\trr = false;\n\t}\n\n\tif (ampdu_frames == 0) {\n\t\tu8 plcp0, plcp3, is40, sgi, mcs;\n\t\tuint fifo = le16_to_cpu(txh->TxFrameID) & TXFID_QUEUE_MASK;\n\t\tstruct brcms_fifo_info *f = &ampdu->fifo_tb[fifo];\n\n\t\tif (rr) {\n\t\t\tplcp0 = plcp[0];\n\t\t\tplcp3 = plcp[3];\n\t\t} else {\n\t\t\tplcp0 = txh->FragPLCPFallback[0];\n\t\t\tplcp3 = txh->FragPLCPFallback[3];\n\n\t\t}\n\n\t\t \n\t\tis40 = (plcp0 & MIMO_PLCP_40MHZ) ? 1 : 0;\n\t\tsgi = plcp3_issgi(plcp3) ? 1 : 0;\n\t\tmcs = plcp0 & ~MIMO_PLCP_40MHZ;\n\t\tsession->max_ampdu_len = min(scb_ampdu->max_rx_ampdu_bytes,\n\t\t\t\t\t     ampdu->max_txlen[mcs][is40][sgi]);\n\n\t\tsession->max_ampdu_frames = scb_ampdu->max_pdu;\n\t\tif (mcs_2_rate(mcs, true, false) >= f->dmaxferrate) {\n\t\t\tsession->max_ampdu_frames =\n\t\t\t\tmin_t(u16, f->mcs2ampdu_table[mcs],\n\t\t\t\t      session->max_ampdu_frames);\n\t\t}\n\t}\n\n\t \n\tmcl = le16_to_cpu(txh->MacTxControlLow);\n\tmcl &= ~TXC_AMPDU_MASK;\n\tmcl |= (TXC_AMPDU_MIDDLE << TXC_AMPDU_SHIFT);\n\tmcl &= ~(TXC_STARTMSDU | TXC_SENDRTS | TXC_SENDCTS);\n\ttxh->MacTxControlLow = cpu_to_le16(mcl);\n\ttxh->PreloadSize = 0;\t \n\n\tskb_queue_tail(&session->skb_list, p);\n\n\treturn 0;\n}\n\nvoid brcms_c_ampdu_finalize(struct brcms_ampdu_session *session)\n{\n\tstruct brcms_c_info *wlc = session->wlc;\n\tstruct ampdu_info *ampdu = wlc->ampdu;\n\tstruct sk_buff *first, *last;\n\tstruct d11txh *txh;\n\tstruct ieee80211_tx_info *tx_info;\n\tstruct ieee80211_tx_rate *txrate;\n\tu8 ndelim;\n\tu8 *plcp;\n\tuint len;\n\tuint fifo;\n\tstruct brcms_fifo_info *f;\n\tu16 mcl;\n\tbool fbr;\n\tbool fbr_iscck;\n\tstruct ieee80211_rts *rts;\n\tbool use_rts = false, use_cts = false;\n\tu16 dma_len = session->dma_len;\n\tu16 mimo_ctlchbw = PHY_TXC1_BW_20MHZ;\n\tu32 rspec = 0, rspec_fallback = 0;\n\tu32 rts_rspec = 0, rts_rspec_fallback = 0;\n\tu8 plcp0, is40, mcs;\n\tu16 mch;\n\tu8 preamble_type = BRCMS_GF_PREAMBLE;\n\tu8 fbr_preamble_type = BRCMS_GF_PREAMBLE;\n\tu8 rts_preamble_type = BRCMS_LONG_PREAMBLE;\n\tu8 rts_fbr_preamble_type = BRCMS_LONG_PREAMBLE;\n\n\tif (skb_queue_empty(&session->skb_list))\n\t\treturn;\n\n\tfirst = skb_peek(&session->skb_list);\n\tlast = skb_peek_tail(&session->skb_list);\n\n\t \n\ttxh = (struct d11txh *)last->data;\n\tfifo = le16_to_cpu(txh->TxFrameID) & TXFID_QUEUE_MASK;\n\tf = &ampdu->fifo_tb[fifo];\n\n\tmcl = le16_to_cpu(txh->MacTxControlLow);\n\tmcl &= ~TXC_AMPDU_MASK;\n\tmcl |= (TXC_AMPDU_LAST << TXC_AMPDU_SHIFT);\n\ttxh->MacTxControlLow = cpu_to_le16(mcl);\n\n\t \n\tndelim = txh->RTSPLCPFallback[AMPDU_FBR_NULL_DELIM];\n\ttxh->RTSPLCPFallback[AMPDU_FBR_NULL_DELIM] = 0;\n\tsession->ampdu_len -= ndelim * AMPDU_DELIMITER_LEN;\n\n\t \n\tfbr_iscck = ((le16_to_cpu(txh->XtraFrameTypes) & 0x3) == 0);\n\tlen = fbr_iscck ? BRCMS_GET_CCK_PLCP_LEN(txh->FragPLCPFallback) :\n\t\t\t  BRCMS_GET_MIMO_PLCP_LEN(txh->FragPLCPFallback);\n\tsession->ampdu_len -= roundup(len, 4) - len;\n\n\t \n\ttx_info = IEEE80211_SKB_CB(first);\n\ttxrate = tx_info->status.rates;\n\ttxh = (struct d11txh *)first->data;\n\tplcp = (u8 *)(txh + 1);\n\trts = (struct ieee80211_rts *)&txh->rts_frame;\n\n\tmcl = le16_to_cpu(txh->MacTxControlLow);\n\t \n\tif (first != last) {\n\t\tmcl &= ~TXC_AMPDU_MASK;\n\t\tmcl |= (TXC_AMPDU_FIRST << TXC_AMPDU_SHIFT);\n\t}\n\tmcl |= TXC_STARTMSDU;\n\tif (ieee80211_is_rts(rts->frame_control)) {\n\t\tmcl |= TXC_SENDRTS;\n\t\tuse_rts = true;\n\t}\n\tif (ieee80211_is_cts(rts->frame_control)) {\n\t\tmcl |= TXC_SENDCTS;\n\t\tuse_cts = true;\n\t}\n\ttxh->MacTxControlLow = cpu_to_le16(mcl);\n\n\tfbr = txrate[1].count > 0;\n\tif (!fbr)\n\t\tplcp0 = plcp[0];\n\telse\n\t\tplcp0 = txh->FragPLCPFallback[0];\n\n\tis40 = (plcp0 & MIMO_PLCP_40MHZ) ? 1 : 0;\n\tmcs = plcp0 & ~MIMO_PLCP_40MHZ;\n\n\tif (is40) {\n\t\tif (CHSPEC_SB_UPPER(wlc_phy_chanspec_get(wlc->band->pi)))\n\t\t\tmimo_ctlchbw = PHY_TXC1_BW_20MHZ_UP;\n\t\telse\n\t\t\tmimo_ctlchbw = PHY_TXC1_BW_20MHZ;\n\t}\n\n\t \n\trspec = RSPEC_MIMORATE;\n\trspec |= plcp[0] & ~MIMO_PLCP_40MHZ;\n\tif (plcp[0] & MIMO_PLCP_40MHZ)\n\t\trspec |= (PHY_TXC1_BW_40MHZ << RSPEC_BW_SHIFT);\n\n\tfbr_iscck = !(le16_to_cpu(txh->XtraFrameTypes) & 0x03);\n\tif (fbr_iscck) {\n\t\trspec_fallback =\n\t\t\tcck_rspec(cck_phy2mac_rate(txh->FragPLCPFallback[0]));\n\t} else {\n\t\trspec_fallback = RSPEC_MIMORATE;\n\t\trspec_fallback |= txh->FragPLCPFallback[0] & ~MIMO_PLCP_40MHZ;\n\t\tif (txh->FragPLCPFallback[0] & MIMO_PLCP_40MHZ)\n\t\t\trspec_fallback |= PHY_TXC1_BW_40MHZ << RSPEC_BW_SHIFT;\n\t}\n\n\tif (use_rts || use_cts) {\n\t\trts_rspec =\n\t\t\tbrcms_c_rspec_to_rts_rspec(wlc, rspec,\n\t\t\t\t\t\t   false, mimo_ctlchbw);\n\t\trts_rspec_fallback =\n\t\t\tbrcms_c_rspec_to_rts_rspec(wlc, rspec_fallback,\n\t\t\t\t\t\t   false, mimo_ctlchbw);\n\t}\n\n\tBRCMS_SET_MIMO_PLCP_LEN(plcp, session->ampdu_len);\n\t \n\tBRCMS_SET_MIMO_PLCP_AMPDU(plcp);\n\n\t \n\tif (txh->MModeLen) {\n\t\tu16 mmodelen = brcms_c_calc_lsig_len(wlc, rspec,\n\t\t\t\t\t\t     session->ampdu_len);\n\t\ttxh->MModeLen = cpu_to_le16(mmodelen);\n\t\tpreamble_type = BRCMS_MM_PREAMBLE;\n\t}\n\tif (txh->MModeFbrLen) {\n\t\tu16 mmfbrlen = brcms_c_calc_lsig_len(wlc, rspec_fallback,\n\t\t\t\t\t\t     session->ampdu_len);\n\t\ttxh->MModeFbrLen = cpu_to_le16(mmfbrlen);\n\t\tfbr_preamble_type = BRCMS_MM_PREAMBLE;\n\t}\n\n\t \n\tif (mcs_2_rate(mcs, true, false) >= f->dmaxferrate) {\n\t\tdma_len = min(dma_len, f->ampdu_pld_size);\n\t\ttxh->PreloadSize = cpu_to_le16(dma_len);\n\t} else {\n\t\ttxh->PreloadSize = 0;\n\t}\n\n\tmch = le16_to_cpu(txh->MacTxControlHigh);\n\n\t \n\tif (use_rts || use_cts) {\n\t\tu16 durid;\n\t\tif ((mch & TXC_PREAMBLE_RTS_MAIN_SHORT) ==\n\t\t    TXC_PREAMBLE_RTS_MAIN_SHORT)\n\t\t\trts_preamble_type = BRCMS_SHORT_PREAMBLE;\n\n\t\tif ((mch & TXC_PREAMBLE_RTS_FB_SHORT) ==\n\t\t     TXC_PREAMBLE_RTS_FB_SHORT)\n\t\t\trts_fbr_preamble_type = BRCMS_SHORT_PREAMBLE;\n\n\t\tdurid = brcms_c_compute_rtscts_dur(wlc, use_cts, rts_rspec,\n\t\t\t\t\t\t   rspec, rts_preamble_type,\n\t\t\t\t\t\t   preamble_type,\n\t\t\t\t\t\t   session->ampdu_len, true);\n\t\trts->duration = cpu_to_le16(durid);\n\t\tdurid = brcms_c_compute_rtscts_dur(wlc, use_cts,\n\t\t\t\t\t\t   rts_rspec_fallback,\n\t\t\t\t\t\t   rspec_fallback,\n\t\t\t\t\t\t   rts_fbr_preamble_type,\n\t\t\t\t\t\t   fbr_preamble_type,\n\t\t\t\t\t\t   session->ampdu_len, true);\n\t\ttxh->RTSDurFallback = cpu_to_le16(durid);\n\t\t \n\t\ttxh->TxFesTimeNormal = rts->duration;\n\t\t \n\t\ttxh->TxFesTimeFallback = txh->RTSDurFallback;\n\t}\n\n\t \n\tif (fbr) {\n\t\tmch |= TXC_AMPDU_FBR;\n\t\ttxh->MacTxControlHigh = cpu_to_le16(mch);\n\t\tBRCMS_SET_MIMO_PLCP_AMPDU(plcp);\n\t\tBRCMS_SET_MIMO_PLCP_AMPDU(txh->FragPLCPFallback);\n\t}\n\n\tbrcms_dbg_ht(wlc->hw->d11core, \"wl%d: count %d ampdu_len %d\\n\",\n\t\t     wlc->pub->unit, skb_queue_len(&session->skb_list),\n\t\t     session->ampdu_len);\n}\n\nstatic void\nbrcms_c_ampdu_rate_status(struct brcms_c_info *wlc,\n\t\t\t  struct ieee80211_tx_info *tx_info,\n\t\t\t  struct tx_status *txs, u8 mcs)\n{\n\tstruct ieee80211_tx_rate *txrate = tx_info->status.rates;\n\tint i;\n\n\t \n\tfor (i = 2; i < IEEE80211_TX_MAX_RATES; i++) {\n\t\ttxrate[i].idx = -1;\n\t\ttxrate[i].count = 0;\n\t}\n}\n\nstatic void\nbrcms_c_ampdu_dotxstatus_complete(struct ampdu_info *ampdu, struct scb *scb,\n\t\t\t      struct sk_buff *p, struct tx_status *txs,\n\t\t\t      u32 s1, u32 s2)\n{\n\tstruct scb_ampdu *scb_ampdu;\n\tstruct brcms_c_info *wlc = ampdu->wlc;\n\tstruct scb_ampdu_tid_ini *ini;\n\tu8 bitmap[8], queue, tid;\n\tstruct d11txh *txh;\n\tu8 *plcp;\n\tstruct ieee80211_hdr *h;\n\tu16 seq, start_seq = 0, bindex, index, mcl;\n\tu8 mcs = 0;\n\tbool ba_recd = false, ack_recd = false;\n\tu8 tot_mpdu = 0;\n\tuint supr_status;\n\tbool retry = true;\n\tu16 mimoantsel = 0;\n\tu8 retry_limit;\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(p);\n\n#ifdef DEBUG\n\tu8 hole[AMPDU_MAX_MPDU];\n\tmemset(hole, 0, sizeof(hole));\n#endif\n\n\tscb_ampdu = &scb->scb_ampdu;\n\ttid = (u8) (p->priority);\n\n\tini = &scb_ampdu->ini[tid];\n\tretry_limit = ampdu->retry_limit_tid[tid];\n\tmemset(bitmap, 0, sizeof(bitmap));\n\tqueue = txs->frameid & TXFID_QUEUE_MASK;\n\tsupr_status = txs->status & TX_STATUS_SUPR_MASK;\n\n\tif (txs->status & TX_STATUS_ACK_RCV) {\n\t\tWARN_ON(!(txs->status & TX_STATUS_INTERMEDIATE));\n\t\tstart_seq = txs->sequence >> SEQNUM_SHIFT;\n\t\tbitmap[0] = (txs->status & TX_STATUS_BA_BMAP03_MASK) >>\n\t\t    TX_STATUS_BA_BMAP03_SHIFT;\n\n\t\tWARN_ON(s1 & TX_STATUS_INTERMEDIATE);\n\t\tWARN_ON(!(s1 & TX_STATUS_AMPDU));\n\n\t\tbitmap[0] |=\n\t\t    (s1 & TX_STATUS_BA_BMAP47_MASK) <<\n\t\t    TX_STATUS_BA_BMAP47_SHIFT;\n\t\tbitmap[1] = (s1 >> 8) & 0xff;\n\t\tbitmap[2] = (s1 >> 16) & 0xff;\n\t\tbitmap[3] = (s1 >> 24) & 0xff;\n\n\t\tbitmap[4] = s2 & 0xff;\n\t\tbitmap[5] = (s2 >> 8) & 0xff;\n\t\tbitmap[6] = (s2 >> 16) & 0xff;\n\t\tbitmap[7] = (s2 >> 24) & 0xff;\n\n\t\tba_recd = true;\n\t} else {\n\t\tif (supr_status) {\n\t\t\tif (supr_status == TX_STATUS_SUPR_BADCH) {\n\t\t\t\tbrcms_dbg_ht(wlc->hw->d11core,\n\t\t\t\t\t  \"%s: Pkt tx suppressed, illegal channel possibly %d\\n\",\n\t\t\t\t\t  __func__, CHSPEC_CHANNEL(\n\t\t\t\t\t  wlc->default_bss->chanspec));\n\t\t\t} else {\n\t\t\t\tif (supr_status != TX_STATUS_SUPR_FRAG)\n\t\t\t\t\tbrcms_err(wlc->hw->d11core,\n\t\t\t\t\t\t  \"%s: supr_status 0x%x\\n\",\n\t\t\t\t\t\t  __func__, supr_status);\n\t\t\t}\n\t\t\t \n\t\t\tif (supr_status == TX_STATUS_SUPR_BADCH ||\n\t\t\t    supr_status == TX_STATUS_SUPR_EXPTIME) {\n\t\t\t\tretry = false;\n\t\t\t} else if (supr_status == TX_STATUS_SUPR_EXPTIME) {\n\t\t\t\t \n\t\t\t} else if (supr_status == TX_STATUS_SUPR_FRAG) {\n\t\t\t\t \n\t\t\t\tbrcms_c_ffpld_check_txfunfl(wlc, queue);\n\t\t\t}\n\t\t} else if (txs->phyerr) {\n\t\t\tbrcms_dbg_ht(wlc->hw->d11core,\n\t\t\t\t     \"%s: ampdu tx phy error (0x%x)\\n\",\n\t\t\t\t     __func__, txs->phyerr);\n\t\t}\n\t}\n\n\t \n\twhile (p) {\n\t\ttx_info = IEEE80211_SKB_CB(p);\n\t\ttxh = (struct d11txh *) p->data;\n\t\tmcl = le16_to_cpu(txh->MacTxControlLow);\n\t\tplcp = (u8 *) (txh + 1);\n\t\th = (struct ieee80211_hdr *)(plcp + D11_PHY_HDR_LEN);\n\t\tseq = le16_to_cpu(h->seq_ctrl) >> SEQNUM_SHIFT;\n\n\t\ttrace_brcms_txdesc(&wlc->hw->d11core->dev, txh, sizeof(*txh));\n\n\t\tif (tot_mpdu == 0) {\n\t\t\tmcs = plcp[0] & MIMO_PLCP_MCS_MASK;\n\t\t\tmimoantsel = le16_to_cpu(txh->ABI_MimoAntSel);\n\t\t}\n\n\t\tindex = TX_SEQ_TO_INDEX(seq);\n\t\tack_recd = false;\n\t\tif (ba_recd) {\n\t\t\tint block_acked;\n\n\t\t\tbindex = MODSUB_POW2(seq, start_seq, SEQNUM_MAX);\n\t\t\tif (bindex < AMPDU_TX_BA_MAX_WSIZE)\n\t\t\t\tblock_acked = isset(bitmap, bindex);\n\t\t\telse\n\t\t\t\tblock_acked = 0;\n\t\t\tbrcms_dbg_ht(wlc->hw->d11core,\n\t\t\t\t     \"tid %d seq %d, start_seq %d, bindex %d set %d, index %d\\n\",\n\t\t\t\t     tid, seq, start_seq, bindex,\n\t\t\t\t     block_acked, index);\n\t\t\t \n\t\t\tif (block_acked) {\n\t\t\t\tini->txretry[index] = 0;\n\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tbrcms_c_ampdu_rate_status(wlc, tx_info, txs,\n\t\t\t\t\t\t\t  mcs);\n\t\t\t\ttx_info->flags |= IEEE80211_TX_STAT_ACK;\n\t\t\t\ttx_info->flags |= IEEE80211_TX_STAT_AMPDU;\n\t\t\t\ttx_info->status.ampdu_ack_len =\n\t\t\t\t\ttx_info->status.ampdu_len = 1;\n\n\t\t\t\tskb_pull(p, D11_PHY_HDR_LEN);\n\t\t\t\tskb_pull(p, D11_TXH_LEN);\n\n\t\t\t\tieee80211_tx_status_irqsafe(wlc->pub->ieee_hw,\n\t\t\t\t\t\t\t    p);\n\t\t\t\tack_recd = true;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (!ack_recd) {\n\t\t\tif (retry && (ini->txretry[index] < (int)retry_limit)) {\n\t\t\t\tint ret;\n\t\t\t\tini->txretry[index]++;\n\t\t\t\tret = brcms_c_txfifo(wlc, queue, p);\n\t\t\t\t \n\t\t\t\tWARN_ONCE(ret, \"queue %d out of txds\\n\", queue);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tieee80211_tx_info_clear_status(tx_info);\n\t\t\t\ttx_info->status.ampdu_ack_len = 0;\n\t\t\t\ttx_info->status.ampdu_len = 1;\n\t\t\t\ttx_info->flags |=\n\t\t\t\t    IEEE80211_TX_STAT_AMPDU_NO_BACK;\n\t\t\t\tskb_pull(p, D11_PHY_HDR_LEN);\n\t\t\t\tskb_pull(p, D11_TXH_LEN);\n\t\t\t\tbrcms_dbg_ht(wlc->hw->d11core,\n\t\t\t\t\t     \"BA Timeout, seq %d\\n\",\n\t\t\t\t\t     seq);\n\t\t\t\tieee80211_tx_status_irqsafe(wlc->pub->ieee_hw,\n\t\t\t\t\t\t\t    p);\n\t\t\t}\n\t\t}\n\t\ttot_mpdu++;\n\n\t\t \n\t\tif (((mcl & TXC_AMPDU_MASK) >> TXC_AMPDU_SHIFT) ==\n\t\t    TXC_AMPDU_LAST)\n\t\t\tbreak;\n\n\t\tp = dma_getnexttxp(wlc->hw->di[queue], DMA_RANGE_TRANSMITTED);\n\t}\n\n\t \n\tbrcms_c_antsel_antsel2id(wlc->asi, mimoantsel);\n}\n\nvoid\nbrcms_c_ampdu_dotxstatus(struct ampdu_info *ampdu, struct scb *scb,\n\t\t     struct sk_buff *p, struct tx_status *txs)\n{\n\tstruct brcms_c_info *wlc = ampdu->wlc;\n\tu32 s1 = 0, s2 = 0;\n\n\t \n\tif (txs->status & TX_STATUS_ACK_RCV) {\n\t\tu8 status_delay = 0;\n\n\t\t \n\t\ts1 = bcma_read32(wlc->hw->d11core, D11REGOFFS(frmtxstatus));\n\t\twhile ((s1 & TXS_V) == 0) {\n\t\t\tudelay(1);\n\t\t\tstatus_delay++;\n\t\t\tif (status_delay > 10)\n\t\t\t\treturn;  \n\t\t\ts1 = bcma_read32(wlc->hw->d11core,\n\t\t\t\t\t D11REGOFFS(frmtxstatus));\n\t\t}\n\n\t\ts2 = bcma_read32(wlc->hw->d11core, D11REGOFFS(frmtxstatus2));\n\t}\n\n\tif (scb) {\n\t\tbrcms_c_ampdu_dotxstatus_complete(ampdu, scb, p, txs, s1, s2);\n\t} else {\n\t\t \n\t\tu8 queue = txs->frameid & TXFID_QUEUE_MASK;\n\t\tstruct d11txh *txh;\n\t\tu16 mcl;\n\t\twhile (p) {\n\t\t\ttxh = (struct d11txh *) p->data;\n\t\t\ttrace_brcms_txdesc(&wlc->hw->d11core->dev, txh,\n\t\t\t\t\t   sizeof(*txh));\n\t\t\tmcl = le16_to_cpu(txh->MacTxControlLow);\n\t\t\tbrcmu_pkt_buf_free_skb(p);\n\t\t\t \n\t\t\tif (((mcl & TXC_AMPDU_MASK) >> TXC_AMPDU_SHIFT) ==\n\t\t\t    TXC_AMPDU_LAST)\n\t\t\t\tbreak;\n\t\t\tp = dma_getnexttxp(wlc->hw->di[queue],\n\t\t\t\t\t   DMA_RANGE_TRANSMITTED);\n\t\t}\n\t}\n}\n\nvoid brcms_c_ampdu_macaddr_upd(struct brcms_c_info *wlc)\n{\n\tchar template[T_RAM_ACCESS_SZ * 2];\n\n\t \n\tmemset(template, 0, sizeof(template));\n\tmemcpy(template, wlc->pub->cur_etheraddr, ETH_ALEN);\n\tbrcms_b_write_template_ram(wlc->hw, (T_BA_TPL_BASE + 16),\n\t\t\t\t  (T_RAM_ACCESS_SZ * 2),\n\t\t\t\t  template);\n}\n\nbool brcms_c_aggregatable(struct brcms_c_info *wlc, u8 tid)\n{\n\treturn wlc->ampdu->ini_enable[tid];\n}\n\nvoid brcms_c_ampdu_shm_upd(struct ampdu_info *ampdu)\n{\n\tstruct brcms_c_info *wlc = ampdu->wlc;\n\n\t \n\tif ((ampdu->rx_factor & IEEE80211_HT_AMPDU_PARM_FACTOR) ==\n\t    IEEE80211_HT_MAX_AMPDU_64K) {\n\t\tbrcms_b_write_shm(wlc->hw, M_MIMO_MAXSYM, MIMO_MAXSYM_MAX);\n\t\tbrcms_b_write_shm(wlc->hw, M_WATCHDOG_8TU, WATCHDOG_8TU_MAX);\n\t} else {\n\t\tbrcms_b_write_shm(wlc->hw, M_MIMO_MAXSYM, MIMO_MAXSYM_DEF);\n\t\tbrcms_b_write_shm(wlc->hw, M_WATCHDOG_8TU, WATCHDOG_8TU_DEF);\n\t}\n}\n\n \nstatic void dma_cb_fn_ampdu(void *txi, void *arg_a)\n{\n\tstruct ieee80211_sta *sta = arg_a;\n\tstruct ieee80211_tx_info *tx_info = (struct ieee80211_tx_info *)txi;\n\n\tif ((tx_info->flags & IEEE80211_TX_CTL_AMPDU) &&\n\t    (tx_info->rate_driver_data[0] == sta || sta == NULL))\n\t\ttx_info->rate_driver_data[0] = NULL;\n}\n\n \nvoid brcms_c_ampdu_flush(struct brcms_c_info *wlc,\n\t\t     struct ieee80211_sta *sta, u16 tid)\n{\n\tbrcms_c_inval_dma_pkts(wlc->hw, sta, dma_cb_fn_ampdu);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}