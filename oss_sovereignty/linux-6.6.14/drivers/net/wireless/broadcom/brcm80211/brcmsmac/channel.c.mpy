{
  "module_name": "channel.c",
  "hash_id": "c5b1fe8175a04b1f3103408af006c578a8e62602a239ba9c9cbc0cdb6acbd1fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmsmac/channel.c",
  "human_readable_source": " \n\n#include <linux/types.h>\n#include <net/cfg80211.h>\n#include <net/mac80211.h>\n#include <net/regulatory.h>\n\n#include <defs.h>\n#include \"pub.h\"\n#include \"phy/phy_hal.h\"\n#include \"main.h\"\n#include \"stf.h\"\n#include \"channel.h\"\n#include \"mac80211_if.h\"\n#include \"debug.h\"\n\n \n#define QDB(n) ((n) * BRCMS_TXPWR_DB_FACTOR)\n\n#define LOCALE_MIMO_IDX_bn\t\t0\n#define LOCALE_MIMO_IDX_11n\t\t0\n\n \n#define BRCMS_MAXPWR_MIMO_TBL_SIZE\t14\n\n \n#define BAND_5G_PWR_LVLS\t5\t \n\n#define LC(id)\tLOCALE_MIMO_IDX_ ## id\n\n#define LOCALES(mimo2, mimo5) \\\n\t\t{LC(mimo2), LC(mimo5)}\n\n \n#define CHANNEL_POWER_IDX_5G(c) (((c) < 52) ? 0 : \\\n\t\t\t\t (((c) < 62) ? 1 : \\\n\t\t\t\t (((c) < 100) ? 2 : \\\n\t\t\t\t (((c) < 149) ? 3 : 4))))\n\n#define BRCM_2GHZ_2412_2462\tREG_RULE(2412-10, 2462+10, 40, 0, 19, 0)\n#define BRCM_2GHZ_2467_2472\tREG_RULE(2467-10, 2472+10, 20, 0, 19, \\\n\t\t\t\t\t NL80211_RRF_NO_IR)\n\n#define BRCM_5GHZ_5180_5240\tREG_RULE(5180-10, 5240+10, 40, 0, 21, \\\n\t\t\t\t\t NL80211_RRF_NO_IR)\n#define BRCM_5GHZ_5260_5320\tREG_RULE(5260-10, 5320+10, 40, 0, 21, \\\n\t\t\t\t\t NL80211_RRF_DFS | \\\n\t\t\t\t\t NL80211_RRF_NO_IR)\n#define BRCM_5GHZ_5500_5700\tREG_RULE(5500-10, 5700+10, 40, 0, 21, \\\n\t\t\t\t\t NL80211_RRF_DFS | \\\n\t\t\t\t\t NL80211_RRF_NO_IR)\n#define BRCM_5GHZ_5745_5825\tREG_RULE(5745-10, 5825+10, 40, 0, 21, \\\n\t\t\t\t\t NL80211_RRF_NO_IR)\n\nstatic const struct ieee80211_regdomain brcms_regdom_x2 = {\n\t.n_reg_rules = 6,\n\t.alpha2 = \"X2\",\n\t.reg_rules = {\n\t\tBRCM_2GHZ_2412_2462,\n\t\tBRCM_2GHZ_2467_2472,\n\t\tBRCM_5GHZ_5180_5240,\n\t\tBRCM_5GHZ_5260_5320,\n\t\tBRCM_5GHZ_5500_5700,\n\t\tBRCM_5GHZ_5745_5825,\n\t}\n};\n\n  \nstruct locale_mimo_info {\n\t \n\ts8 maxpwr20[BRCMS_MAXPWR_MIMO_TBL_SIZE];\n\t \n\ts8 maxpwr40[BRCMS_MAXPWR_MIMO_TBL_SIZE];\n};\n\n \nstruct country_info {\n\tconst u8 locale_mimo_2G;\t \n\tconst u8 locale_mimo_5G;\t \n};\n\nstruct brcms_regd {\n\tstruct country_info country;\n\tconst struct ieee80211_regdomain *regdomain;\n};\n\nstruct brcms_cm_info {\n\tstruct brcms_pub *pub;\n\tstruct brcms_c_info *wlc;\n\tconst struct brcms_regd *world_regd;\n};\n\n \nstatic const struct locale_mimo_info locale_bn = {\n\t{QDB(13), QDB(13), QDB(13), QDB(13), QDB(13),\n\t QDB(13), QDB(13), QDB(13), QDB(13), QDB(13),\n\t QDB(13), QDB(13), QDB(13)},\n\t{0, 0, QDB(13), QDB(13), QDB(13),\n\t QDB(13), QDB(13), QDB(13), QDB(13), QDB(13),\n\t QDB(13), 0, 0},\n};\n\nstatic const struct locale_mimo_info *g_mimo_2g_table[] = {\n\t&locale_bn\n};\n\n \nstatic const struct locale_mimo_info locale_11n = {\n\t{   50, 50, 50, QDB(15), QDB(15)},\n\t{QDB(14), QDB(15), QDB(15), QDB(15), QDB(15)},\n};\n\nstatic const struct locale_mimo_info *g_mimo_5g_table[] = {\n\t&locale_11n\n};\n\nstatic const struct brcms_regd cntry_locales[] = {\n\t \n\t{\n\t\t.country = LOCALES(bn, 11n),\n\t\t.regdomain = &brcms_regdom_x2,\n\t},\n};\n\nstatic const struct locale_mimo_info *brcms_c_get_mimo_2g(u8 locale_idx)\n{\n\tif (locale_idx >= ARRAY_SIZE(g_mimo_2g_table))\n\t\treturn NULL;\n\n\treturn g_mimo_2g_table[locale_idx];\n}\n\nstatic const struct locale_mimo_info *brcms_c_get_mimo_5g(u8 locale_idx)\n{\n\tif (locale_idx >= ARRAY_SIZE(g_mimo_5g_table))\n\t\treturn NULL;\n\n\treturn g_mimo_5g_table[locale_idx];\n}\n\n \nstatic bool brcms_c_country_valid(const char *ccode)\n{\n\t \n\tif (!((ccode[0] & 0x80) == 0 && ccode[0] >= 0x41 && ccode[0] <= 0x5A &&\n\t      (ccode[1] & 0x80) == 0 && ccode[1] >= 0x41 && ccode[1] <= 0x5A))\n\t\treturn false;\n\n\t \n\tif (!strcmp(\"AA\", ccode) ||         \n\t    !strcmp(\"ZZ\", ccode) ||         \n\t    ccode[0] == 'X' ||              \n\t    (ccode[0] == 'Q' &&             \n\t     (ccode[1] >= 'M' && ccode[1] <= 'Z')))\n\t\treturn false;\n\n\tif (!strcmp(\"NA\", ccode))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic const struct brcms_regd *brcms_world_regd(const char *regdom, int len)\n{\n\tconst struct brcms_regd *regd = NULL;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cntry_locales); i++) {\n\t\tif (!strncmp(regdom, cntry_locales[i].regdomain->alpha2, len)) {\n\t\t\tregd = &cntry_locales[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn regd;\n}\n\nstatic const struct brcms_regd *brcms_default_world_regd(void)\n{\n\treturn &cntry_locales[0];\n}\n\n \nstatic bool brcms_c_japan_ccode(const char *ccode)\n{\n\treturn (ccode[0] == 'J' &&\n\t\t(ccode[1] == 'P' || (ccode[1] >= '1' && ccode[1] <= '9')));\n}\n\nstatic void\nbrcms_c_channel_min_txpower_limits_with_local_constraint(\n\t\tstruct brcms_cm_info *wlc_cm, struct txpwr_limits *txpwr,\n\t\tu8 local_constraint_qdbm)\n{\n\tint j;\n\n\t \n\tfor (j = 0; j < WL_TX_POWER_CCK_NUM; j++)\n\t\ttxpwr->cck[j] = min(txpwr->cck[j], local_constraint_qdbm);\n\n\t \n\tfor (j = 0; j < WL_TX_POWER_OFDM_NUM; j++)\n\t\ttxpwr->ofdm[j] = min(txpwr->ofdm[j], local_constraint_qdbm);\n\n\t \n\tfor (j = 0; j < BRCMS_NUM_RATES_OFDM; j++)\n\t\ttxpwr->ofdm_cdd[j] =\n\t\t    min(txpwr->ofdm_cdd[j], local_constraint_qdbm);\n\n\t \n\tfor (j = 0; j < BRCMS_NUM_RATES_OFDM; j++)\n\t\ttxpwr->ofdm_40_siso[j] =\n\t\t    min(txpwr->ofdm_40_siso[j], local_constraint_qdbm);\n\n\t \n\tfor (j = 0; j < BRCMS_NUM_RATES_OFDM; j++)\n\t\ttxpwr->ofdm_40_cdd[j] =\n\t\t    min(txpwr->ofdm_40_cdd[j], local_constraint_qdbm);\n\n\t \n\tfor (j = 0; j < BRCMS_NUM_RATES_MCS_1_STREAM; j++)\n\t\ttxpwr->mcs_20_siso[j] =\n\t\t    min(txpwr->mcs_20_siso[j], local_constraint_qdbm);\n\n\t \n\tfor (j = 0; j < BRCMS_NUM_RATES_MCS_1_STREAM; j++)\n\t\ttxpwr->mcs_20_cdd[j] =\n\t\t    min(txpwr->mcs_20_cdd[j], local_constraint_qdbm);\n\n\t \n\tfor (j = 0; j < BRCMS_NUM_RATES_MCS_1_STREAM; j++)\n\t\ttxpwr->mcs_20_stbc[j] =\n\t\t    min(txpwr->mcs_20_stbc[j], local_constraint_qdbm);\n\n\t \n\tfor (j = 0; j < BRCMS_NUM_RATES_MCS_2_STREAM; j++)\n\t\ttxpwr->mcs_20_mimo[j] =\n\t\t    min(txpwr->mcs_20_mimo[j], local_constraint_qdbm);\n\n\t \n\tfor (j = 0; j < BRCMS_NUM_RATES_MCS_1_STREAM; j++)\n\t\ttxpwr->mcs_40_siso[j] =\n\t\t    min(txpwr->mcs_40_siso[j], local_constraint_qdbm);\n\n\t \n\tfor (j = 0; j < BRCMS_NUM_RATES_MCS_1_STREAM; j++)\n\t\ttxpwr->mcs_40_cdd[j] =\n\t\t    min(txpwr->mcs_40_cdd[j], local_constraint_qdbm);\n\n\t \n\tfor (j = 0; j < BRCMS_NUM_RATES_MCS_1_STREAM; j++)\n\t\ttxpwr->mcs_40_stbc[j] =\n\t\t    min(txpwr->mcs_40_stbc[j], local_constraint_qdbm);\n\n\t \n\tfor (j = 0; j < BRCMS_NUM_RATES_MCS_2_STREAM; j++)\n\t\ttxpwr->mcs_40_mimo[j] =\n\t\t    min(txpwr->mcs_40_mimo[j], local_constraint_qdbm);\n\n\t \n\ttxpwr->mcs32 = min(txpwr->mcs32, local_constraint_qdbm);\n\n}\n\n \nstatic void\nbrcms_c_set_country(struct brcms_cm_info *wlc_cm,\n\t\t    const struct brcms_regd *regd)\n{\n\tstruct brcms_c_info *wlc = wlc_cm->wlc;\n\n\tif ((wlc->pub->_n_enab & SUPPORT_11N) !=\n\t    wlc->protection->nmode_user)\n\t\tbrcms_c_set_nmode(wlc);\n\n\tbrcms_c_stf_ss_update(wlc, wlc->bandstate[BAND_2G_INDEX]);\n\tbrcms_c_stf_ss_update(wlc, wlc->bandstate[BAND_5G_INDEX]);\n\n\tbrcms_c_set_gmode(wlc, wlc->protection->gmode_user, false);\n\n\treturn;\n}\n\nstruct brcms_cm_info *brcms_c_channel_mgr_attach(struct brcms_c_info *wlc)\n{\n\tstruct brcms_cm_info *wlc_cm;\n\tstruct brcms_pub *pub = wlc->pub;\n\tstruct ssb_sprom *sprom = &wlc->hw->d11core->bus->sprom;\n\tconst char *ccode = sprom->alpha2;\n\tint ccode_len = sizeof(sprom->alpha2);\n\n\twlc_cm = kzalloc(sizeof(struct brcms_cm_info), GFP_ATOMIC);\n\tif (wlc_cm == NULL)\n\t\treturn NULL;\n\twlc_cm->pub = pub;\n\twlc_cm->wlc = wlc;\n\twlc->cmi = wlc_cm;\n\n\t \n\twlc_cm->world_regd = brcms_world_regd(ccode, ccode_len);\n\tif (brcms_c_country_valid(ccode))\n\t\tstrncpy(wlc->pub->srom_ccode, ccode, ccode_len);\n\n\t \n\tif (!wlc_cm->world_regd) {\n\t\twlc_cm->world_regd = brcms_default_world_regd();\n\t\tccode = wlc_cm->world_regd->regdomain->alpha2;\n\t\tccode_len = BRCM_CNTRY_BUF_SZ - 1;\n\t}\n\n\t \n\tstrncpy(wlc->country_default, ccode, ccode_len);\n\n\t \n\tstrncpy(wlc->autocountry_default, ccode, ccode_len);\n\n\tbrcms_c_set_country(wlc_cm, wlc_cm->world_regd);\n\n\treturn wlc_cm;\n}\n\nvoid brcms_c_channel_mgr_detach(struct brcms_cm_info *wlc_cm)\n{\n\tkfree(wlc_cm);\n}\n\nvoid\nbrcms_c_channel_set_chanspec(struct brcms_cm_info *wlc_cm, u16 chanspec,\n\t\t\t u8 local_constraint_qdbm)\n{\n\tstruct brcms_c_info *wlc = wlc_cm->wlc;\n\tstruct ieee80211_channel *ch = wlc->pub->ieee_hw->conf.chandef.chan;\n\tstruct txpwr_limits txpwr;\n\n\tbrcms_c_channel_reg_limits(wlc_cm, chanspec, &txpwr);\n\n\tbrcms_c_channel_min_txpower_limits_with_local_constraint(\n\t\twlc_cm, &txpwr, local_constraint_qdbm\n\t);\n\n\t \n\tif (ch->flags & IEEE80211_CHAN_NO_OFDM)\n\t\tbrcms_c_set_gmode(wlc, GMODE_LEGACY_B, false);\n\telse\n\t\tbrcms_c_set_gmode(wlc, wlc->protection->gmode_user, false);\n\n\tbrcms_b_set_chanspec(wlc->hw, chanspec,\n\t\t\t      !!(ch->flags & IEEE80211_CHAN_NO_IR),\n\t\t\t      &txpwr);\n}\n\nvoid\nbrcms_c_channel_reg_limits(struct brcms_cm_info *wlc_cm, u16 chanspec,\n\t\t       struct txpwr_limits *txpwr)\n{\n\tstruct brcms_c_info *wlc = wlc_cm->wlc;\n\tstruct ieee80211_channel *ch = wlc->pub->ieee_hw->conf.chandef.chan;\n\tuint i;\n\tuint chan;\n\tint maxpwr;\n\tint delta;\n\tconst struct country_info *country;\n\tstruct brcms_band *band;\n\tint conducted_max = BRCMS_TXPWR_MAX;\n\tconst struct locale_mimo_info *li_mimo;\n\tint maxpwr20, maxpwr40;\n\tint maxpwr_idx;\n\tuint j;\n\n\tmemset(txpwr, 0, sizeof(struct txpwr_limits));\n\n\tif (WARN_ON(!ch))\n\t\treturn;\n\n\tcountry = &wlc_cm->world_regd->country;\n\n\tchan = CHSPEC_CHANNEL(chanspec);\n\tband = wlc->bandstate[chspec_bandunit(chanspec)];\n\tli_mimo = (band->bandtype == BRCM_BAND_5G) ?\n\t    brcms_c_get_mimo_5g(country->locale_mimo_5G) :\n\t    brcms_c_get_mimo_2g(country->locale_mimo_2G);\n\n\tdelta = band->antgain;\n\n\tif (band->bandtype == BRCM_BAND_2G)\n\t\tconducted_max = QDB(22);\n\n\tmaxpwr = QDB(ch->max_power) - delta;\n\tmaxpwr = max(maxpwr, 0);\n\tmaxpwr = min(maxpwr, conducted_max);\n\n\t \n\tif (band->bandtype == BRCM_BAND_2G) {\n\t\tfor (i = 0; i < BRCMS_NUM_RATES_CCK; i++)\n\t\t\ttxpwr->cck[i] = (u8) maxpwr;\n\t}\n\n\tfor (i = 0; i < BRCMS_NUM_RATES_OFDM; i++) {\n\t\ttxpwr->ofdm[i] = (u8) maxpwr;\n\n\t\t \n\t\ttxpwr->ofdm_40_siso[i] = 0;\n\n\t\ttxpwr->ofdm_cdd[i] = (u8) maxpwr;\n\n\t\ttxpwr->ofdm_40_cdd[i] = 0;\n\t}\n\n\tdelta = 0;\n\tif (band->antgain > QDB(6))\n\t\tdelta = band->antgain - QDB(6);\t \n\n\tif (band->bandtype == BRCM_BAND_2G)\n\t\tmaxpwr_idx = (chan - 1);\n\telse\n\t\tmaxpwr_idx = CHANNEL_POWER_IDX_5G(chan);\n\n\tmaxpwr20 = li_mimo->maxpwr20[maxpwr_idx];\n\tmaxpwr40 = li_mimo->maxpwr40[maxpwr_idx];\n\n\tmaxpwr20 = maxpwr20 - delta;\n\tmaxpwr20 = max(maxpwr20, 0);\n\tmaxpwr40 = maxpwr40 - delta;\n\tmaxpwr40 = max(maxpwr40, 0);\n\n\t \n\tfor (i = 0; i < BRCMS_NUM_RATES_MCS_1_STREAM; i++) {\n\n\t\t \n\t\ttxpwr->mcs_20_siso[i] = txpwr->ofdm[i];\n\t\ttxpwr->mcs_40_siso[i] = 0;\n\t}\n\n\t \n\tfor (i = 0; i < BRCMS_NUM_RATES_MCS_1_STREAM; i++) {\n\t\ttxpwr->mcs_20_cdd[i] = (u8) maxpwr20;\n\t\ttxpwr->mcs_40_cdd[i] = (u8) maxpwr40;\n\t}\n\n\t \n\tif (li_mimo == &locale_bn) {\n\t\tmaxpwr20 = QDB(16);\n\t\tmaxpwr40 = 0;\n\n\t\tif (chan >= 3 && chan <= 11)\n\t\t\tmaxpwr40 = QDB(16);\n\n\t\tfor (i = 0; i < BRCMS_NUM_RATES_MCS_1_STREAM; i++) {\n\t\t\ttxpwr->mcs_20_siso[i] = (u8) maxpwr20;\n\t\t\ttxpwr->mcs_40_siso[i] = (u8) maxpwr40;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < BRCMS_NUM_RATES_MCS_1_STREAM; i++) {\n\t\ttxpwr->mcs_20_stbc[i] = 0;\n\t\ttxpwr->mcs_40_stbc[i] = 0;\n\t}\n\n\t \n\tfor (i = 0; i < BRCMS_NUM_RATES_MCS_2_STREAM; i++) {\n\t\ttxpwr->mcs_20_mimo[i] = (u8) maxpwr20;\n\t\ttxpwr->mcs_40_mimo[i] = (u8) maxpwr40;\n\t}\n\n\t \n\ttxpwr->mcs32 = (u8) maxpwr40;\n\n\tfor (i = 0, j = 0; i < BRCMS_NUM_RATES_OFDM; i++, j++) {\n\t\tif (txpwr->ofdm_40_cdd[i] == 0)\n\t\t\ttxpwr->ofdm_40_cdd[i] = txpwr->mcs_40_cdd[j];\n\t\tif (i == 0) {\n\t\t\ti = i + 1;\n\t\t\tif (txpwr->ofdm_40_cdd[i] == 0)\n\t\t\t\ttxpwr->ofdm_40_cdd[i] = txpwr->mcs_40_cdd[j];\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < BRCMS_NUM_RATES_MCS_1_STREAM; i++) {\n\t\tif (txpwr->mcs_40_siso[i] == 0)\n\t\t\ttxpwr->mcs_40_siso[i] = txpwr->mcs_40_cdd[i];\n\t}\n\n\tfor (i = 0, j = 0; i < BRCMS_NUM_RATES_OFDM; i++, j++) {\n\t\tif (txpwr->ofdm_40_siso[i] == 0)\n\t\t\ttxpwr->ofdm_40_siso[i] = txpwr->mcs_40_siso[j];\n\t\tif (i == 0) {\n\t\t\ti = i + 1;\n\t\t\tif (txpwr->ofdm_40_siso[i] == 0)\n\t\t\t\ttxpwr->ofdm_40_siso[i] = txpwr->mcs_40_siso[j];\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < BRCMS_NUM_RATES_MCS_1_STREAM; i++) {\n\t\tif (txpwr->mcs_20_stbc[i] == 0)\n\t\t\ttxpwr->mcs_20_stbc[i] = txpwr->mcs_20_cdd[i];\n\n\t\tif (txpwr->mcs_40_stbc[i] == 0)\n\t\t\ttxpwr->mcs_40_stbc[i] = txpwr->mcs_40_cdd[i];\n\t}\n\n\treturn;\n}\n\n \nstatic bool brcms_c_chspec_malformed(u16 chanspec)\n{\n\t \n\tif (!CHSPEC_IS5G(chanspec) && !CHSPEC_IS2G(chanspec))\n\t\treturn true;\n\t \n\tif (!CHSPEC_IS40(chanspec) && !CHSPEC_IS20(chanspec))\n\t\treturn true;\n\n\t \n\tif (CHSPEC_IS20(chanspec)) {\n\t\tif (!CHSPEC_SB_NONE(chanspec))\n\t\t\treturn true;\n\t} else if (!CHSPEC_SB_UPPER(chanspec) && !CHSPEC_SB_LOWER(chanspec)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic bool\nbrcms_c_valid_chanspec_ext(struct brcms_cm_info *wlc_cm, u16 chspec)\n{\n\tstruct brcms_c_info *wlc = wlc_cm->wlc;\n\tu8 channel = CHSPEC_CHANNEL(chspec);\n\n\t \n\tif (brcms_c_chspec_malformed(chspec)) {\n\t\tbrcms_err(wlc->hw->d11core, \"wl%d: malformed chanspec 0x%x\\n\",\n\t\t\t  wlc->pub->unit, chspec);\n\t\treturn false;\n\t}\n\n\tif (CHANNEL_BANDUNIT(wlc_cm->wlc, channel) !=\n\t    chspec_bandunit(chspec))\n\t\treturn false;\n\n\treturn true;\n}\n\nbool brcms_c_valid_chanspec_db(struct brcms_cm_info *wlc_cm, u16 chspec)\n{\n\treturn brcms_c_valid_chanspec_ext(wlc_cm, chspec);\n}\n\nstatic bool brcms_is_radar_freq(u16 center_freq)\n{\n\treturn center_freq >= 5260 && center_freq <= 5700;\n}\n\nstatic void brcms_reg_apply_radar_flags(struct wiphy *wiphy)\n{\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *ch;\n\tint i;\n\n\tsband = wiphy->bands[NL80211_BAND_5GHZ];\n\tif (!sband)\n\t\treturn;\n\n\tfor (i = 0; i < sband->n_channels; i++) {\n\t\tch = &sband->channels[i];\n\n\t\tif (!brcms_is_radar_freq(ch->center_freq))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!(ch->flags & IEEE80211_CHAN_DISABLED))\n\t\t\tch->flags |= IEEE80211_CHAN_RADAR |\n\t\t\t\t     IEEE80211_CHAN_NO_IR;\n\t}\n}\n\nstatic void\nbrcms_reg_apply_beaconing_flags(struct wiphy *wiphy,\n\t\t\t\tenum nl80211_reg_initiator initiator)\n{\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *ch;\n\tconst struct ieee80211_reg_rule *rule;\n\tint band, i;\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tsband = wiphy->bands[band];\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < sband->n_channels; i++) {\n\t\t\tch = &sband->channels[i];\n\n\t\t\tif (ch->flags &\n\t\t\t    (IEEE80211_CHAN_DISABLED | IEEE80211_CHAN_RADAR))\n\t\t\t\tcontinue;\n\n\t\t\tif (initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE) {\n\t\t\t\trule = freq_reg_info(wiphy,\n\t\t\t\t\t\t     MHZ_TO_KHZ(ch->center_freq));\n\t\t\t\tif (IS_ERR(rule))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (!(rule->flags & NL80211_RRF_NO_IR))\n\t\t\t\t\tch->flags &= ~IEEE80211_CHAN_NO_IR;\n\t\t\t} else if (ch->beacon_found) {\n\t\t\t\tch->flags &= ~IEEE80211_CHAN_NO_IR;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void brcms_reg_notifier(struct wiphy *wiphy,\n\t\t\t       struct regulatory_request *request)\n{\n\tstruct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);\n\tstruct brcms_info *wl = hw->priv;\n\tstruct brcms_c_info *wlc = wl->wlc;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *ch;\n\tint band, i;\n\tbool ch_found = false;\n\n\tbrcms_reg_apply_radar_flags(wiphy);\n\n\tif (request->initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE)\n\t\tbrcms_reg_apply_beaconing_flags(wiphy, request->initiator);\n\n\t \n\tfor (band = 0; !ch_found && band < NUM_NL80211_BANDS; band++) {\n\t\tsband = wiphy->bands[band];\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; !ch_found && i < sband->n_channels; i++) {\n\t\t\tch = &sband->channels[i];\n\n\t\t\tif (!(ch->flags & IEEE80211_CHAN_DISABLED))\n\t\t\t\tch_found = true;\n\t\t}\n\t}\n\n\tif (ch_found) {\n\t\tmboolclr(wlc->pub->radio_disabled, WL_RADIO_COUNTRY_DISABLE);\n\t} else {\n\t\tmboolset(wlc->pub->radio_disabled, WL_RADIO_COUNTRY_DISABLE);\n\t\tbrcms_err(wlc->hw->d11core,\n\t\t\t  \"wl%d: %s: no valid channel for \\\"%s\\\"\\n\",\n\t\t\t  wlc->pub->unit, __func__, request->alpha2);\n\t}\n\n\tif (wlc->pub->_nbands > 1 || wlc->band->bandtype == BRCM_BAND_2G)\n\t\twlc_phy_chanspec_ch14_widefilter_set(wlc->band->pi,\n\t\t\t\t\tbrcms_c_japan_ccode(request->alpha2));\n}\n\nvoid brcms_c_regd_init(struct brcms_c_info *wlc)\n{\n\tstruct wiphy *wiphy = wlc->wiphy;\n\tconst struct brcms_regd *regd = wlc->cmi->world_regd;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *ch;\n\tstruct brcms_chanvec sup_chan;\n\tstruct brcms_band *band;\n\tint band_idx, i;\n\n\t \n\tfor (band_idx = 0; band_idx < wlc->pub->_nbands; band_idx++) {\n\t\tband = wlc->bandstate[band_idx];\n\n\t\twlc_phy_chanspec_band_validch(band->pi, band->bandtype,\n\t\t\t\t\t      &sup_chan);\n\n\t\tif (band_idx == BAND_2G_INDEX)\n\t\t\tsband = wiphy->bands[NL80211_BAND_2GHZ];\n\t\telse\n\t\t\tsband = wiphy->bands[NL80211_BAND_5GHZ];\n\n\t\tfor (i = 0; i < sband->n_channels; i++) {\n\t\t\tch = &sband->channels[i];\n\t\t\tif (!isset(sup_chan.vec, ch->hw_value))\n\t\t\t\tch->flags |= IEEE80211_CHAN_DISABLED;\n\t\t}\n\t}\n\n\twlc->wiphy->reg_notifier = brcms_reg_notifier;\n\twlc->wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG |\n\t\t\t\t\tREGULATORY_STRICT_REG;\n\twiphy_apply_custom_regulatory(wlc->wiphy, regd->regdomain);\n\tbrcms_reg_apply_beaconing_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}