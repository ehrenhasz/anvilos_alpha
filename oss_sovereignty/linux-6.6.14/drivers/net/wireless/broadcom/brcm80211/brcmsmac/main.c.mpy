{
  "module_name": "main.c",
  "hash_id": "c4225630fd27d6e53821486452002477ebc90d4367138a43e65407a5fcf91f2e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmsmac/main.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/pci_ids.h>\n#include <linux/if_ether.h>\n#include <net/cfg80211.h>\n#include <net/mac80211.h>\n#include <brcm_hw_ids.h>\n#include <aiutils.h>\n#include <chipcommon.h>\n#include \"rate.h\"\n#include \"scb.h\"\n#include \"phy/phy_hal.h\"\n#include \"channel.h\"\n#include \"antsel.h\"\n#include \"stf.h\"\n#include \"ampdu.h\"\n#include \"mac80211_if.h\"\n#include \"ucode_loader.h\"\n#include \"main.h\"\n#include \"soc.h\"\n#include \"dma.h\"\n#include \"debug.h\"\n#include \"brcms_trace_events.h\"\n\n \n#define TIMER_INTERVAL_WATCHDOG\t\t1000\n \n#define TIMER_INTERVAL_RADIOCHK\t\t800\n\n \n#define BEACON_INTERVAL_DEFAULT\t\t100\n\n \n \n#define WL_11N_2x2\t\t\t1\n#define WL_11N_3x3\t\t\t3\n#define WL_11N_4x4\t\t\t4\n\n#define EDCF_ACI_MASK\t\t\t0x60\n#define EDCF_ACI_SHIFT\t\t\t5\n#define EDCF_ECWMIN_MASK\t\t0x0f\n#define EDCF_ECWMAX_SHIFT\t\t4\n#define EDCF_AIFSN_MASK\t\t\t0x0f\n#define EDCF_AIFSN_MAX\t\t\t15\n#define EDCF_ECWMAX_MASK\t\t0xf0\n\n#define EDCF_AC_BE_TXOP_STA\t\t0x0000\n#define EDCF_AC_BK_TXOP_STA\t\t0x0000\n#define EDCF_AC_VO_ACI_STA\t\t0x62\n#define EDCF_AC_VO_ECW_STA\t\t0x32\n#define EDCF_AC_VI_ACI_STA\t\t0x42\n#define EDCF_AC_VI_ECW_STA\t\t0x43\n#define EDCF_AC_BK_ECW_STA\t\t0xA4\n#define EDCF_AC_VI_TXOP_STA\t\t0x005e\n#define EDCF_AC_VO_TXOP_STA\t\t0x002f\n#define EDCF_AC_BE_ACI_STA\t\t0x03\n#define EDCF_AC_BE_ECW_STA\t\t0xA4\n#define EDCF_AC_BK_ACI_STA\t\t0x27\n#define EDCF_AC_VO_TXOP_AP\t\t0x002f\n\n#define EDCF_TXOP2USEC(txop)\t\t((txop) << 5)\n#define EDCF_ECW2CW(exp)\t\t((1 << (exp)) - 1)\n\n#define APHY_SYMBOL_TIME\t\t4\n#define APHY_PREAMBLE_TIME\t\t16\n#define APHY_SIGNAL_TIME\t\t4\n#define APHY_SIFS_TIME\t\t\t16\n#define APHY_SERVICE_NBITS\t\t16\n#define APHY_TAIL_NBITS\t\t\t6\n#define BPHY_SIFS_TIME\t\t\t10\n#define BPHY_PLCP_SHORT_TIME\t\t96\n\n#define PREN_PREAMBLE\t\t\t24\n#define PREN_MM_EXT\t\t\t12\n#define PREN_PREAMBLE_EXT\t\t4\n\n#define DOT11_MAC_HDR_LEN\t\t24\n#define DOT11_ACK_LEN\t\t\t10\n#define DOT11_BA_LEN\t\t\t4\n#define DOT11_OFDM_SIGNAL_EXTENSION\t6\n#define DOT11_MIN_FRAG_LEN\t\t256\n#define DOT11_RTS_LEN\t\t\t16\n#define DOT11_CTS_LEN\t\t\t10\n#define DOT11_BA_BITMAP_LEN\t\t128\n#define DOT11_MAXNUMFRAGS\t\t16\n#define DOT11_MAX_FRAG_LEN\t\t2346\n\n#define BPHY_PLCP_TIME\t\t\t192\n#define RIFS_11N_TIME\t\t\t2\n\n \n#define BCN_TMPL_LEN\t\t\t512\n\n \n#define BRCMS_BSS_HT\t\t\t0x0020\t \n\n \n#define BRCMS_HWRXOFF\t\t\t38\n\n \n#define RFDISABLE_DEFAULT\t\t10000000\n\n#define BRCMS_TEMPSENSE_PERIOD\t\t10\t \n\n \n#define SYNTHPU_DLY_APHY_US\t\t3700\n#define SYNTHPU_DLY_BPHY_US\t\t1050\n#define SYNTHPU_DLY_NPHY_US\t\t2048\n#define SYNTHPU_DLY_LPPHY_US\t\t300\n\n#define ANTCNT\t\t\t\t10\t \n\n \n#define EDCF_SHORT_S\t\t\t0\n#define EDCF_SFB_S\t\t\t4\n#define EDCF_LONG_S\t\t\t8\n#define EDCF_LFB_S\t\t\t12\n#define EDCF_SHORT_M\t\t\tBITFIELD_MASK(4)\n#define EDCF_SFB_M\t\t\tBITFIELD_MASK(4)\n#define EDCF_LONG_M\t\t\tBITFIELD_MASK(4)\n#define EDCF_LFB_M\t\t\tBITFIELD_MASK(4)\n\n#define RETRY_SHORT_DEF\t\t\t7\t \n#define RETRY_SHORT_MAX\t\t\t255\t \n#define RETRY_LONG_DEF\t\t\t4\t \n#define RETRY_SHORT_FB\t\t\t3\t \n#define RETRY_LONG_FB\t\t\t2\t \n\n#define APHY_CWMIN\t\t\t15\n#define PHY_CWMAX\t\t\t1023\n\n#define EDCF_AIFSN_MIN\t\t\t1\n\n#define FRAGNUM_MASK\t\t\t0xF\n\n#define APHY_SLOT_TIME\t\t\t9\n#define BPHY_SLOT_TIME\t\t\t20\n\n#define WL_SPURAVOID_OFF\t\t0\n#define WL_SPURAVOID_ON1\t\t1\n#define WL_SPURAVOID_ON2\t\t2\n\n \n#define BRCMS_USE_COREFLAGS\t\t0xffffffff\n\n \n#define BRCMS_PLCP_AUTO\t\t\t-1\n#define BRCMS_PLCP_SHORT\t\t0\n#define BRCMS_PLCP_LONG\t\t\t1\n\n \n#define BRCMS_PROTECTION_AUTO\t\t-1\n#define BRCMS_PROTECTION_OFF\t\t0\n#define BRCMS_PROTECTION_ON\t\t1\n#define BRCMS_PROTECTION_MMHDR_ONLY\t2\n#define BRCMS_PROTECTION_CTS_ONLY\t3\n\n \n#define BRCMS_PROTECTION_CTL_OFF\t0\n#define BRCMS_PROTECTION_CTL_LOCAL\t1\n#define BRCMS_PROTECTION_CTL_OVERLAP\t2\n\n \n#define BRCMS_N_PROTECTION_OFF\t\t0\n#define BRCMS_N_PROTECTION_OPTIONAL\t1\n#define BRCMS_N_PROTECTION_20IN40\t2\n#define BRCMS_N_PROTECTION_MIXEDMODE\t3\n\n \n#define BRCMS_N_BW_20ALL\t\t0\n#define BRCMS_N_BW_40ALL\t\t1\n#define BRCMS_N_BW_20IN2G_40IN5G\t2\n\n \n#define BRCMS_N_SGI_20\t\t\t0x01\n#define BRCMS_N_SGI_40\t\t\t0x02\n\n \n \n#define NRATE_MCS_INUSE\t\t\t0x00000080\n \n#define NRATE_RATE_MASK\t\t\t0x0000007f\n \n#define NRATE_STF_MASK\t\t\t0x0000ff00\n \n#define NRATE_STF_SHIFT\t\t\t8\n \n#define NRATE_OVERRIDE_MCS_ONLY\t\t0x40000000\n#define NRATE_SGI_MASK\t\t\t0x00800000\t \n#define NRATE_SGI_SHIFT\t\t\t23\t\t \n#define NRATE_LDPC_CODING\t\t0x00400000\t \n#define NRATE_LDPC_SHIFT\t\t22\t\t \n\n#define NRATE_STF_SISO\t\t\t0\t\t \n#define NRATE_STF_CDD\t\t\t1\t\t \n#define NRATE_STF_STBC\t\t\t2\t\t \n#define NRATE_STF_SDM\t\t\t3\t\t \n\n#define MAX_DMA_SEGS\t\t\t4\n\n \n#define NTXD\t\t\t\t64\n \n#define NRXD\t\t\t\t256\n\n \n#define TX_HEADROOM\t\t\t4\n\n \n#define NRXBUFPOST\t\t\t32\n\n \n#define RXBND\t\t\t\t8\n \n#define TXSBND\t\t\t\t8\n\n \nstruct brcms_c_bit_desc {\n\tu32 bit;\n\tconst char *name;\n};\n\n \n\n \n#define XMTFIFOTBL_STARTREV\t17\n\nstruct d11init {\n\t__le16 addr;\n\t__le16 size;\n\t__le32 value;\n};\n\nstruct edcf_acparam {\n\tu8 ACI;\n\tu8 ECW;\n\tu16 TXOP;\n} __packed;\n\n \nuint brcm_msg_level;\n\n \nstatic const u8 wme_fifo2ac[] = {\n\tIEEE80211_AC_BK,\n\tIEEE80211_AC_BE,\n\tIEEE80211_AC_VI,\n\tIEEE80211_AC_VO,\n\tIEEE80211_AC_BE,\n\tIEEE80211_AC_BE\n};\n\n \nstatic const u8 wme_ac2fifo[] = {\n\tTX_AC_VO_FIFO,\n\tTX_AC_VI_FIFO,\n\tTX_AC_BE_FIFO,\n\tTX_AC_BK_FIFO\n};\n\nstatic const u16 xmtfifo_sz[][NFIFO] = {\n\t \n\t{20, 192, 192, 21, 17, 5},\n\t \n\t{0, 0, 0, 0, 0, 0},\n\t \n\t{0, 0, 0, 0, 0, 0},\n\t \n\t{20, 192, 192, 21, 17, 5},\n\t \n\t{9, 58, 22, 14, 14, 5},\n\t \n\t{20, 192, 192, 21, 17, 5},\n\t \n\t{20, 192, 192, 21, 17, 5},\n\t \n\t{9, 58, 22, 14, 14, 5},\n\t \n\t{0, 0, 0, 0, 0, 0},\n\t \n\t{0, 0, 0, 0, 0, 0},\n\t \n\t{0, 0, 0, 0, 0, 0},\n\t \n\t{9, 58, 22, 14, 14, 5},\n};\n\n#ifdef DEBUG\nstatic const char * const fifo_names[] = {\n\t\"AC_BK\", \"AC_BE\", \"AC_VI\", \"AC_VO\", \"BCMC\", \"ATIM\" };\n#else\nstatic const char fifo_names[6][1];\n#endif\n\n#ifdef DEBUG\n \nstatic struct brcms_c_info *wlc_info_dbg = (struct brcms_c_info *) (NULL);\n#endif\n\n \nstatic const u8 ac_to_fifo_mapping[IEEE80211_NUM_ACS] = {\n\t[IEEE80211_AC_VO]\t= TX_AC_VO_FIFO,\n\t[IEEE80211_AC_VI]\t= TX_AC_VI_FIFO,\n\t[IEEE80211_AC_BE]\t= TX_AC_BE_FIFO,\n\t[IEEE80211_AC_BK]\t= TX_AC_BK_FIFO,\n};\n\n \nstatic const u8 fifo_to_ac_mapping[IEEE80211_NUM_ACS] = {\n\t[TX_AC_BK_FIFO]\t= IEEE80211_AC_BK,\n\t[TX_AC_BE_FIFO]\t= IEEE80211_AC_BE,\n\t[TX_AC_VI_FIFO]\t= IEEE80211_AC_VI,\n\t[TX_AC_VO_FIFO]\t= IEEE80211_AC_VO,\n};\n\nstatic u8 brcms_ac_to_fifo(u8 ac)\n{\n\tif (ac >= ARRAY_SIZE(ac_to_fifo_mapping))\n\t\treturn TX_AC_BE_FIFO;\n\treturn ac_to_fifo_mapping[ac];\n}\n\nstatic u8 brcms_fifo_to_ac(u8 fifo)\n{\n\tif (fifo >= ARRAY_SIZE(fifo_to_ac_mapping))\n\t\treturn IEEE80211_AC_BE;\n\treturn fifo_to_ac_mapping[fifo];\n}\n\n \nstatic u8 brcms_basic_rate(struct brcms_c_info *wlc, u32 rspec)\n{\n\tif (is_mcs_rate(rspec))\n\t\treturn wlc->band->basic_rate[mcs_table[rspec & RSPEC_RATE_MASK]\n\t\t       .leg_ofdm];\n\treturn wlc->band->basic_rate[rspec & RSPEC_RATE_MASK];\n}\n\nstatic u16 frametype(u32 rspec, u8 mimoframe)\n{\n\tif (is_mcs_rate(rspec))\n\t\treturn mimoframe;\n\treturn is_cck_rate(rspec) ? FT_CCK : FT_OFDM;\n}\n\n \nstatic u16 get_sifs(struct brcms_band *band)\n{\n\treturn band->bandtype == BRCM_BAND_5G ? APHY_SIFS_TIME :\n\t\t\t\t BPHY_SIFS_TIME;\n}\n\n \nstatic bool brcms_deviceremoved(struct brcms_c_info *wlc)\n{\n\tu32 macctrl;\n\n\tif (!wlc->hw->clk)\n\t\treturn ai_deviceremoved(wlc->hw->sih);\n\tmacctrl = bcma_read32(wlc->hw->d11core,\n\t\t\t      D11REGOFFS(maccontrol));\n\treturn (macctrl & (MCTL_PSM_JMP_0 | MCTL_IHR_EN)) != MCTL_IHR_EN;\n}\n\n \nstatic int brcms_txpktpendtot(struct brcms_c_info *wlc)\n{\n\tint i;\n\tint pending = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(wlc->hw->di); i++)\n\t\tif (wlc->hw->di[i])\n\t\t\tpending += dma_txpending(wlc->hw->di[i]);\n\treturn pending;\n}\n\nstatic bool brcms_is_mband_unlocked(struct brcms_c_info *wlc)\n{\n\treturn wlc->pub->_nbands > 1 && !wlc->bandlocked;\n}\n\nstatic int brcms_chspec_bw(u16 chanspec)\n{\n\tif (CHSPEC_IS40(chanspec))\n\t\treturn BRCMS_40_MHZ;\n\tif (CHSPEC_IS20(chanspec))\n\t\treturn BRCMS_20_MHZ;\n\n\treturn BRCMS_10_MHZ;\n}\n\nstatic void brcms_c_bsscfg_mfree(struct brcms_bss_cfg *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tkfree(cfg->current_bss);\n\tkfree(cfg);\n}\n\nstatic void brcms_c_detach_mfree(struct brcms_c_info *wlc)\n{\n\tif (wlc == NULL)\n\t\treturn;\n\n\tbrcms_c_bsscfg_mfree(wlc->bsscfg);\n\tkfree(wlc->pub);\n\tkfree(wlc->modulecb);\n\tkfree(wlc->default_bss);\n\tkfree(wlc->protection);\n\tkfree(wlc->stf);\n\tkfree(wlc->bandstate[0]);\n\tif (wlc->corestate)\n\t\tkfree(wlc->corestate->macstat_snapshot);\n\tkfree(wlc->corestate);\n\tif (wlc->hw)\n\t\tkfree(wlc->hw->bandstate[0]);\n\tkfree(wlc->hw);\n\tif (wlc->beacon)\n\t\tdev_kfree_skb_any(wlc->beacon);\n\tif (wlc->probe_resp)\n\t\tdev_kfree_skb_any(wlc->probe_resp);\n\n\tkfree(wlc);\n}\n\nstatic struct brcms_bss_cfg *brcms_c_bsscfg_malloc(uint unit)\n{\n\tstruct brcms_bss_cfg *cfg;\n\n\tcfg = kzalloc(sizeof(struct brcms_bss_cfg), GFP_ATOMIC);\n\tif (cfg == NULL)\n\t\tgoto fail;\n\n\tcfg->current_bss = kzalloc(sizeof(struct brcms_bss_info), GFP_ATOMIC);\n\tif (cfg->current_bss == NULL)\n\t\tgoto fail;\n\n\treturn cfg;\n\n fail:\n\tbrcms_c_bsscfg_mfree(cfg);\n\treturn NULL;\n}\n\nstatic struct brcms_c_info *\nbrcms_c_attach_malloc(uint unit, uint *err, uint devid)\n{\n\tstruct brcms_c_info *wlc;\n\n\twlc = kzalloc(sizeof(struct brcms_c_info), GFP_ATOMIC);\n\tif (wlc == NULL) {\n\t\t*err = 1002;\n\t\tgoto fail;\n\t}\n\n\t \n\twlc->pub = kzalloc(sizeof(struct brcms_pub), GFP_ATOMIC);\n\tif (wlc->pub == NULL) {\n\t\t*err = 1003;\n\t\tgoto fail;\n\t}\n\twlc->pub->wlc = wlc;\n\n\t \n\n\twlc->hw = kzalloc(sizeof(struct brcms_hardware), GFP_ATOMIC);\n\tif (wlc->hw == NULL) {\n\t\t*err = 1005;\n\t\tgoto fail;\n\t}\n\twlc->hw->wlc = wlc;\n\n\twlc->hw->bandstate[0] =\n\t\tkcalloc(MAXBANDS, sizeof(struct brcms_hw_band), GFP_ATOMIC);\n\tif (wlc->hw->bandstate[0] == NULL) {\n\t\t*err = 1006;\n\t\tgoto fail;\n\t} else {\n\t\tint i;\n\n\t\tfor (i = 1; i < MAXBANDS; i++)\n\t\t\twlc->hw->bandstate[i] = (struct brcms_hw_band *)\n\t\t\t    ((unsigned long)wlc->hw->bandstate[0] +\n\t\t\t     (sizeof(struct brcms_hw_band) * i));\n\t}\n\n\twlc->modulecb =\n\t\tkcalloc(BRCMS_MAXMODULES, sizeof(struct modulecb),\n\t\t\tGFP_ATOMIC);\n\tif (wlc->modulecb == NULL) {\n\t\t*err = 1009;\n\t\tgoto fail;\n\t}\n\n\twlc->default_bss = kzalloc(sizeof(struct brcms_bss_info), GFP_ATOMIC);\n\tif (wlc->default_bss == NULL) {\n\t\t*err = 1010;\n\t\tgoto fail;\n\t}\n\n\twlc->bsscfg = brcms_c_bsscfg_malloc(unit);\n\tif (wlc->bsscfg == NULL) {\n\t\t*err = 1011;\n\t\tgoto fail;\n\t}\n\n\twlc->protection = kzalloc(sizeof(struct brcms_protection),\n\t\t\t\t  GFP_ATOMIC);\n\tif (wlc->protection == NULL) {\n\t\t*err = 1016;\n\t\tgoto fail;\n\t}\n\n\twlc->stf = kzalloc(sizeof(struct brcms_stf), GFP_ATOMIC);\n\tif (wlc->stf == NULL) {\n\t\t*err = 1017;\n\t\tgoto fail;\n\t}\n\n\twlc->bandstate[0] =\n\t\tkcalloc(MAXBANDS, sizeof(struct brcms_band), GFP_ATOMIC);\n\tif (wlc->bandstate[0] == NULL) {\n\t\t*err = 1025;\n\t\tgoto fail;\n\t} else {\n\t\tint i;\n\n\t\tfor (i = 1; i < MAXBANDS; i++)\n\t\t\twlc->bandstate[i] = (struct brcms_band *)\n\t\t\t\t((unsigned long)wlc->bandstate[0]\n\t\t\t\t+ (sizeof(struct brcms_band)*i));\n\t}\n\n\twlc->corestate = kzalloc(sizeof(struct brcms_core), GFP_ATOMIC);\n\tif (wlc->corestate == NULL) {\n\t\t*err = 1026;\n\t\tgoto fail;\n\t}\n\n\twlc->corestate->macstat_snapshot =\n\t\tkzalloc(sizeof(struct macstat), GFP_ATOMIC);\n\tif (wlc->corestate->macstat_snapshot == NULL) {\n\t\t*err = 1027;\n\t\tgoto fail;\n\t}\n\n\treturn wlc;\n\n fail:\n\tbrcms_c_detach_mfree(wlc);\n\treturn NULL;\n}\n\n \nstatic void brcms_b_update_slot_timing(struct brcms_hardware *wlc_hw,\n\t\t\t\t\tbool shortslot)\n{\n\tstruct bcma_device *core = wlc_hw->d11core;\n\n\tif (shortslot) {\n\t\t \n\t\tbcma_write16(core, D11REGOFFS(ifs_slot), 0x0207);\n\t\tbrcms_b_write_shm(wlc_hw, M_DOT11_SLOT, APHY_SLOT_TIME);\n\t} else {\n\t\t \n\t\tbcma_write16(core, D11REGOFFS(ifs_slot), 0x0212);\n\t\tbrcms_b_write_shm(wlc_hw, M_DOT11_SLOT, BPHY_SLOT_TIME);\n\t}\n}\n\n \nstatic uint brcms_c_calc_frame_time(struct brcms_c_info *wlc, u32 ratespec,\n\t\t\t\t    u8 preamble_type, uint mac_len)\n{\n\tuint nsyms, dur = 0, Ndps, kNdps;\n\tuint rate = rspec2rate(ratespec);\n\n\tif (rate == 0) {\n\t\tbrcms_err(wlc->hw->d11core, \"wl%d: WAR: using rate of 1 mbps\\n\",\n\t\t\t  wlc->pub->unit);\n\t\trate = BRCM_RATE_1M;\n\t}\n\n\tif (is_mcs_rate(ratespec)) {\n\t\tuint mcs = ratespec & RSPEC_RATE_MASK;\n\t\tint tot_streams = mcs_2_txstreams(mcs) + rspec_stc(ratespec);\n\n\t\tdur = PREN_PREAMBLE + (tot_streams * PREN_PREAMBLE_EXT);\n\t\tif (preamble_type == BRCMS_MM_PREAMBLE)\n\t\t\tdur += PREN_MM_EXT;\n\t\t \n\t\tkNdps = mcs_2_rate(mcs, rspec_is40mhz(ratespec),\n\t\t\t\t   rspec_issgi(ratespec)) * 4;\n\n\t\tif (rspec_stc(ratespec) == 0)\n\t\t\tnsyms =\n\t\t\t    CEIL((APHY_SERVICE_NBITS + 8 * mac_len +\n\t\t\t\t  APHY_TAIL_NBITS) * 1000, kNdps);\n\t\telse\n\t\t\t \n\t\t\tnsyms =\n\t\t\t    2 *\n\t\t\t    CEIL((APHY_SERVICE_NBITS + 8 * mac_len +\n\t\t\t\t  APHY_TAIL_NBITS) * 1000, 2 * kNdps);\n\n\t\tdur += APHY_SYMBOL_TIME * nsyms;\n\t\tif (wlc->band->bandtype == BRCM_BAND_2G)\n\t\t\tdur += DOT11_OFDM_SIGNAL_EXTENSION;\n\t} else if (is_ofdm_rate(rate)) {\n\t\tdur = APHY_PREAMBLE_TIME;\n\t\tdur += APHY_SIGNAL_TIME;\n\t\t \n\t\tNdps = rate * 2;\n\t\t \n\t\tnsyms =\n\t\t    CEIL((APHY_SERVICE_NBITS + 8 * mac_len + APHY_TAIL_NBITS),\n\t\t\t Ndps);\n\t\tdur += APHY_SYMBOL_TIME * nsyms;\n\t\tif (wlc->band->bandtype == BRCM_BAND_2G)\n\t\t\tdur += DOT11_OFDM_SIGNAL_EXTENSION;\n\t} else {\n\t\t \n\t\tmac_len = mac_len * 8 * 2;\n\t\t \n\t\tdur = (mac_len + rate - 1) / rate;\n\t\tif (preamble_type & BRCMS_SHORT_PREAMBLE)\n\t\t\tdur += BPHY_PLCP_SHORT_TIME;\n\t\telse\n\t\t\tdur += BPHY_PLCP_TIME;\n\t}\n\treturn dur;\n}\n\nstatic void brcms_c_write_inits(struct brcms_hardware *wlc_hw,\n\t\t\t\tconst struct d11init *inits)\n{\n\tstruct bcma_device *core = wlc_hw->d11core;\n\tint i;\n\tuint offset;\n\tu16 size;\n\tu32 value;\n\n\tbrcms_dbg_info(wlc_hw->d11core, \"wl%d\\n\", wlc_hw->unit);\n\n\tfor (i = 0; inits[i].addr != cpu_to_le16(0xffff); i++) {\n\t\tsize = le16_to_cpu(inits[i].size);\n\t\toffset = le16_to_cpu(inits[i].addr);\n\t\tvalue = le32_to_cpu(inits[i].value);\n\t\tif (size == 2)\n\t\t\tbcma_write16(core, offset, value);\n\t\telse if (size == 4)\n\t\t\tbcma_write32(core, offset, value);\n\t\telse\n\t\t\tbreak;\n\t}\n}\n\nstatic void brcms_c_write_mhf(struct brcms_hardware *wlc_hw, u16 *mhfs)\n{\n\tu8 idx;\n\tstatic const u16 addr[] = {\n\t\tM_HOST_FLAGS1, M_HOST_FLAGS2, M_HOST_FLAGS3, M_HOST_FLAGS4,\n\t\tM_HOST_FLAGS5\n\t};\n\n\tfor (idx = 0; idx < MHFMAX; idx++)\n\t\tbrcms_b_write_shm(wlc_hw, addr[idx], mhfs[idx]);\n}\n\nstatic void brcms_c_ucode_bsinit(struct brcms_hardware *wlc_hw)\n{\n\tstruct brcms_ucode *ucode = &wlc_hw->wlc->wl->ucode;\n\n\t \n\tbrcms_c_write_mhf(wlc_hw, wlc_hw->band->mhfs);\n\n\t \n\tif (D11REV_IS(wlc_hw->corerev, 17) || D11REV_IS(wlc_hw->corerev, 23)) {\n\t\tif (BRCMS_ISNPHY(wlc_hw->band))\n\t\t\tbrcms_c_write_inits(wlc_hw, ucode->d11n0bsinitvals16);\n\t\telse\n\t\t\tbrcms_err(wlc_hw->d11core,\n\t\t\t\t  \"%s: wl%d: unsupported phy in corerev %d\\n\",\n\t\t\t\t  __func__, wlc_hw->unit,\n\t\t\t\t  wlc_hw->corerev);\n\t} else {\n\t\tif (D11REV_IS(wlc_hw->corerev, 24)) {\n\t\t\tif (BRCMS_ISLCNPHY(wlc_hw->band))\n\t\t\t\tbrcms_c_write_inits(wlc_hw,\n\t\t\t\t\t\t    ucode->d11lcn0bsinitvals24);\n\t\t\telse\n\t\t\t\tbrcms_err(wlc_hw->d11core,\n\t\t\t\t\t  \"%s: wl%d: unsupported phy in core rev %d\\n\",\n\t\t\t\t\t  __func__, wlc_hw->unit,\n\t\t\t\t\t  wlc_hw->corerev);\n\t\t} else {\n\t\t\tbrcms_err(wlc_hw->d11core,\n\t\t\t\t  \"%s: wl%d: unsupported corerev %d\\n\",\n\t\t\t\t  __func__, wlc_hw->unit, wlc_hw->corerev);\n\t\t}\n\t}\n}\n\nstatic void brcms_b_core_ioctl(struct brcms_hardware *wlc_hw, u32 m, u32 v)\n{\n\tstruct bcma_device *core = wlc_hw->d11core;\n\tu32 ioctl = bcma_aread32(core, BCMA_IOCTL) & ~m;\n\n\tbcma_awrite32(core, BCMA_IOCTL, ioctl | v);\n}\n\nstatic void brcms_b_core_phy_clk(struct brcms_hardware *wlc_hw, bool clk)\n{\n\tbrcms_dbg_info(wlc_hw->d11core, \"wl%d: clk %d\\n\", wlc_hw->unit, clk);\n\n\twlc_hw->phyclk = clk;\n\n\tif (OFF == clk) {\t \n\n\t\tbrcms_b_core_ioctl(wlc_hw, (SICF_PRST | SICF_FGC | SICF_GMODE),\n\t\t\t\t   (SICF_PRST | SICF_FGC));\n\t\tudelay(1);\n\t\tbrcms_b_core_ioctl(wlc_hw, (SICF_PRST | SICF_FGC), SICF_PRST);\n\t\tudelay(1);\n\n\t} else {\t\t \n\n\t\tbrcms_b_core_ioctl(wlc_hw, (SICF_PRST | SICF_FGC), SICF_FGC);\n\t\tudelay(1);\n\t\tbrcms_b_core_ioctl(wlc_hw, SICF_FGC, 0);\n\t\tudelay(1);\n\n\t}\n}\n\n \nstatic void brcms_c_setxband(struct brcms_hardware *wlc_hw, uint bandunit)\n{\n\tbrcms_dbg_mac80211(wlc_hw->d11core, \"wl%d: bandunit %d\\n\", wlc_hw->unit,\n\t\t\t   bandunit);\n\n\twlc_hw->band = wlc_hw->bandstate[bandunit];\n\n\t \n\twlc_hw->wlc->band = wlc_hw->wlc->bandstate[bandunit];\n\n\t \n\tif (wlc_hw->sbclk && !wlc_hw->noreset) {\n\t\tu32 gmode = 0;\n\n\t\tif (bandunit == 0)\n\t\t\tgmode = SICF_GMODE;\n\n\t\tbrcms_b_core_ioctl(wlc_hw, SICF_GMODE, gmode);\n\t}\n}\n\n \nstatic u32 brcms_c_setband_inact(struct brcms_c_info *wlc, uint bandunit)\n{\n\tstruct brcms_hardware *wlc_hw = wlc->hw;\n\tu32 macintmask;\n\tu32 macctrl;\n\n\tbrcms_dbg_mac80211(wlc_hw->d11core, \"wl%d\\n\", wlc_hw->unit);\n\tmacctrl = bcma_read32(wlc_hw->d11core,\n\t\t\t      D11REGOFFS(maccontrol));\n\tWARN_ON((macctrl & MCTL_EN_MAC) != 0);\n\n\t \n\tmacintmask = brcms_intrsoff(wlc->wl);\n\n\t \n\twlc_phy_switch_radio(wlc_hw->band->pi, OFF);\n\n\tbrcms_b_core_phy_clk(wlc_hw, OFF);\n\n\tbrcms_c_setxband(wlc_hw, bandunit);\n\n\treturn macintmask;\n}\n\n \nstatic bool\nbrcms_c_dotxstatus(struct brcms_c_info *wlc, struct tx_status *txs)\n{\n\tstruct sk_buff *p = NULL;\n\tuint queue = NFIFO;\n\tstruct dma_pub *dma = NULL;\n\tstruct d11txh *txh = NULL;\n\tstruct scb *scb = NULL;\n\tint tx_frame_count;\n\tuint supr_status;\n\tbool lastframe;\n\tstruct ieee80211_hdr *h;\n\tstruct ieee80211_tx_info *tx_info;\n\tstruct ieee80211_tx_rate *txrate;\n\tint i;\n\tbool fatal = true;\n\n\ttrace_brcms_txstatus(&wlc->hw->d11core->dev, txs->framelen,\n\t\t\t     txs->frameid, txs->status, txs->lasttxtime,\n\t\t\t     txs->sequence, txs->phyerr, txs->ackphyrxsh);\n\n\t \n\tif (!(txs->status & TX_STATUS_AMPDU)\n\t    && (txs->status & TX_STATUS_INTERMEDIATE)) {\n\t\tbrcms_dbg_tx(wlc->hw->d11core, \"INTERMEDIATE but not AMPDU\\n\");\n\t\tfatal = false;\n\t\tgoto out;\n\t}\n\n\tqueue = txs->frameid & TXFID_QUEUE_MASK;\n\tif (queue >= NFIFO) {\n\t\tbrcms_err(wlc->hw->d11core, \"queue %u >= NFIFO\\n\", queue);\n\t\tgoto out;\n\t}\n\n\tdma = wlc->hw->di[queue];\n\n\tp = dma_getnexttxp(wlc->hw->di[queue], DMA_RANGE_TRANSMITTED);\n\tif (p == NULL) {\n\t\tbrcms_err(wlc->hw->d11core, \"dma_getnexttxp returned null!\\n\");\n\t\tgoto out;\n\t}\n\n\ttxh = (struct d11txh *) (p->data);\n\n\tif (txs->phyerr)\n\t\tbrcms_dbg_tx(wlc->hw->d11core, \"phyerr 0x%x, rate 0x%x\\n\",\n\t\t\t     txs->phyerr, txh->MainRates);\n\n\tif (txs->frameid != le16_to_cpu(txh->TxFrameID)) {\n\t\tbrcms_err(wlc->hw->d11core, \"frameid != txh->TxFrameID\\n\");\n\t\tgoto out;\n\t}\n\ttx_info = IEEE80211_SKB_CB(p);\n\th = (struct ieee80211_hdr *)((u8 *) (txh + 1) + D11_PHY_HDR_LEN);\n\n\tif (tx_info->rate_driver_data[0])\n\t\tscb = &wlc->pri_scb;\n\n\tif (tx_info->flags & IEEE80211_TX_CTL_AMPDU) {\n\t\tbrcms_c_ampdu_dotxstatus(wlc->ampdu, scb, p, txs);\n\t\tfatal = false;\n\t\tgoto out;\n\t}\n\n\t \n\ttrace_brcms_txdesc(&wlc->hw->d11core->dev, txh, sizeof(*txh));\n\n\tsupr_status = txs->status & TX_STATUS_SUPR_MASK;\n\tif (supr_status == TX_STATUS_SUPR_BADCH) {\n\t\tunsigned xfts = le16_to_cpu(txh->XtraFrameTypes);\n\t\tbrcms_dbg_tx(wlc->hw->d11core,\n\t\t\t     \"Pkt tx suppressed, dest chan %u, current %d\\n\",\n\t\t\t     (xfts >> XFTS_CHANNEL_SHIFT) & 0xff,\n\t\t\t     CHSPEC_CHANNEL(wlc->default_bss->chanspec));\n\t}\n\n\ttx_frame_count =\n\t    (txs->status & TX_STATUS_FRM_RTX_MASK) >> TX_STATUS_FRM_RTX_SHIFT;\n\n\tlastframe = !ieee80211_has_morefrags(h->frame_control);\n\n\tif (!lastframe) {\n\t\tbrcms_err(wlc->hw->d11core, \"Not last frame!\\n\");\n\t} else {\n\t\t \n\t\tu16 sfbl,\t \n\t\t    lfbl,\t \n\t\t    fbl;\n\n\t\tif (queue < IEEE80211_NUM_ACS) {\n\t\t\tsfbl = GFIELD(wlc->wme_retries[wme_fifo2ac[queue]],\n\t\t\t\t      EDCF_SFB);\n\t\t\tlfbl = GFIELD(wlc->wme_retries[wme_fifo2ac[queue]],\n\t\t\t\t      EDCF_LFB);\n\t\t} else {\n\t\t\tsfbl = wlc->SFBL;\n\t\t\tlfbl = wlc->LFBL;\n\t\t}\n\n\t\ttxrate = tx_info->status.rates;\n\t\tif (txrate[0].flags & IEEE80211_TX_RC_USE_RTS_CTS)\n\t\t\tfbl = lfbl;\n\t\telse\n\t\t\tfbl = sfbl;\n\n\t\tieee80211_tx_info_clear_status(tx_info);\n\n\t\tif ((tx_frame_count > fbl) && (txrate[1].idx >= 0)) {\n\t\t\t \n\t\t\ttxrate[0].count = fbl;\n\t\t\ttxrate[1].count = tx_frame_count - fbl;\n\t\t} else {\n\t\t\t \n\t\t\ttxrate[0].count = tx_frame_count;\n\t\t\t \n\t\t\ttxrate[1].idx = -1;\n\t\t\ttxrate[1].count = 0;\n\t\t}\n\n\t\t \n\t\tfor (i = 2; i < IEEE80211_TX_MAX_RATES; i++) {\n\t\t\ttxrate[i].idx = -1;\n\t\t\ttxrate[i].count = 0;\n\t\t}\n\n\t\tif (txs->status & TX_STATUS_ACK_RCV)\n\t\t\ttx_info->flags |= IEEE80211_TX_STAT_ACK;\n\t}\n\n\tif (lastframe) {\n\t\t \n\t\tskb_pull(p, D11_PHY_HDR_LEN);\n\t\tskb_pull(p, D11_TXH_LEN);\n\t\tieee80211_tx_status_irqsafe(wlc->pub->ieee_hw, p);\n\t} else {\n\t\tbrcms_err(wlc->hw->d11core,\n\t\t\t  \"%s: Not last frame => not calling tx_status\\n\",\n\t\t\t  __func__);\n\t}\n\n\tfatal = false;\n\n out:\n\tif (fatal) {\n\t\tif (txh)\n\t\t\ttrace_brcms_txdesc(&wlc->hw->d11core->dev, txh,\n\t\t\t\t\t   sizeof(*txh));\n\t\tbrcmu_pkt_buf_free_skb(p);\n\t}\n\n\tif (dma && queue < NFIFO) {\n\t\tu16 ac_queue = brcms_fifo_to_ac(queue);\n\t\tif (dma->txavail > TX_HEADROOM && queue < TX_BCMC_FIFO &&\n\t\t    ieee80211_queue_stopped(wlc->pub->ieee_hw, ac_queue))\n\t\t\tieee80211_wake_queue(wlc->pub->ieee_hw, ac_queue);\n\t\tdma_kick_tx(dma);\n\t}\n\n\treturn fatal;\n}\n\n \nstatic bool\nbrcms_b_txstatus(struct brcms_hardware *wlc_hw, bool bound, bool *fatal)\n{\n\tstruct bcma_device *core;\n\tstruct tx_status txstatus, *txs;\n\tu32 s1, s2;\n\tuint n = 0;\n\t \n\tuint max_tx_num = bound ? TXSBND : -1;\n\n\ttxs = &txstatus;\n\tcore = wlc_hw->d11core;\n\t*fatal = false;\n\n\twhile (n < max_tx_num) {\n\t\ts1 = bcma_read32(core, D11REGOFFS(frmtxstatus));\n\t\tif (s1 == 0xffffffff) {\n\t\t\tbrcms_err(core, \"wl%d: %s: dead chip\\n\", wlc_hw->unit,\n\t\t\t\t  __func__);\n\t\t\t*fatal = true;\n\t\t\treturn false;\n\t\t}\n\t\t \n\t\tif (!(s1 & TXS_V))\n\t\t\tbreak;\n\n\t\ts2 = bcma_read32(core, D11REGOFFS(frmtxstatus2));\n\t\ttxs->status = s1 & TXS_STATUS_MASK;\n\t\ttxs->frameid = (s1 & TXS_FID_MASK) >> TXS_FID_SHIFT;\n\t\ttxs->sequence = s2 & TXS_SEQ_MASK;\n\t\ttxs->phyerr = (s2 & TXS_PTX_MASK) >> TXS_PTX_SHIFT;\n\t\ttxs->lasttxtime = 0;\n\n\t\t*fatal = brcms_c_dotxstatus(wlc_hw->wlc, txs);\n\t\tif (*fatal)\n\t\t\treturn false;\n\t\tn++;\n\t}\n\n\treturn n >= max_tx_num;\n}\n\nstatic void brcms_c_tbtt(struct brcms_c_info *wlc)\n{\n\tif (wlc->bsscfg->type == BRCMS_TYPE_ADHOC)\n\t\t \n\t\twlc->qvalid |= MCMD_DIRFRMQVAL;\n}\n\n \nstatic void\nbrcms_c_mhfdef(struct brcms_c_info *wlc, u16 *mhfs, u16 mhf2_init)\n{\n\tstruct brcms_hardware *wlc_hw = wlc->hw;\n\n\tmemset(mhfs, 0, MHFMAX * sizeof(u16));\n\n\tmhfs[MHF2] |= mhf2_init;\n\n\t \n\tif (wlc_hw->boardflags & BFL_NOPLLDOWN)\n\t\tmhfs[MHF1] |= MHF1_FORCEFASTCLK;\n\n\tif (BRCMS_ISNPHY(wlc_hw->band) && NREV_LT(wlc_hw->band->phyrev, 2)) {\n\t\tmhfs[MHF2] |= MHF2_NPHY40MHZ_WAR;\n\t\tmhfs[MHF1] |= MHF1_IQSWAP_WAR;\n\t}\n}\n\nstatic uint\ndmareg(uint direction, uint fifonum)\n{\n\tif (direction == DMA_TX)\n\t\treturn offsetof(struct d11regs, fifo64regs[fifonum].dmaxmt);\n\treturn offsetof(struct d11regs, fifo64regs[fifonum].dmarcv);\n}\n\nstatic bool brcms_b_attach_dmapio(struct brcms_c_info *wlc, uint j, bool wme)\n{\n\tuint i;\n\tchar name[8];\n\t \n\tu16 pio_mhf2 = 0;\n\tstruct brcms_hardware *wlc_hw = wlc->hw;\n\tuint unit = wlc_hw->unit;\n\n\t \n\tsnprintf(name, sizeof(name), \"wl%d\", unit);\n\n\tif (wlc_hw->di[0] == NULL) {\t \n\t\tint dma_attach_err = 0;\n\n\t\t \n\t\twlc_hw->di[0] = dma_attach(name, wlc,\n\t\t\t\t\t   (wme ? dmareg(DMA_TX, 0) : 0),\n\t\t\t\t\t   dmareg(DMA_RX, 0),\n\t\t\t\t\t   (wme ? NTXD : 0), NRXD,\n\t\t\t\t\t   RXBUFSZ, -1, NRXBUFPOST,\n\t\t\t\t\t   BRCMS_HWRXOFF);\n\t\tdma_attach_err |= (NULL == wlc_hw->di[0]);\n\n\t\t \n\t\twlc_hw->di[1] = dma_attach(name, wlc,\n\t\t\t\t\t   dmareg(DMA_TX, 1), 0,\n\t\t\t\t\t   NTXD, 0, 0, -1, 0, 0);\n\t\tdma_attach_err |= (NULL == wlc_hw->di[1]);\n\n\t\t \n\t\twlc_hw->di[2] = dma_attach(name, wlc,\n\t\t\t\t\t   dmareg(DMA_TX, 2), 0,\n\t\t\t\t\t   NTXD, 0, 0, -1, 0, 0);\n\t\tdma_attach_err |= (NULL == wlc_hw->di[2]);\n\t\t \n\t\twlc_hw->di[3] = dma_attach(name, wlc,\n\t\t\t\t\t   dmareg(DMA_TX, 3),\n\t\t\t\t\t   0, NTXD, 0, 0, -1,\n\t\t\t\t\t   0, 0);\n\t\tdma_attach_err |= (NULL == wlc_hw->di[3]);\n \n\n\t\tif (dma_attach_err) {\n\t\t\tbrcms_err(wlc_hw->d11core,\n\t\t\t\t  \"wl%d: wlc_attach: dma_attach failed\\n\",\n\t\t\t\t  unit);\n\t\t\treturn false;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < NFIFO; i++)\n\t\t\tif (wlc_hw->di[i])\n\t\t\t\twlc_hw->txavail[i] =\n\t\t\t\t    (uint *) dma_getvar(wlc_hw->di[i],\n\t\t\t\t\t\t\t\"&txavail\");\n\t}\n\n\t \n\tbrcms_c_mhfdef(wlc, wlc_hw->band->mhfs, pio_mhf2);\n\n\treturn true;\n}\n\nstatic void brcms_b_detach_dmapio(struct brcms_hardware *wlc_hw)\n{\n\tuint j;\n\n\tfor (j = 0; j < NFIFO; j++) {\n\t\tif (wlc_hw->di[j]) {\n\t\t\tdma_detach(wlc_hw->di[j]);\n\t\t\twlc_hw->di[j] = NULL;\n\t\t}\n\t}\n}\n\n \nstatic void brcms_b_info_init(struct brcms_hardware *wlc_hw)\n{\n\tstruct brcms_c_info *wlc = wlc_hw->wlc;\n\n\t \n\twlc->defmacintmask = DEF_MACINTMASK;\n\n\t \n\twlc_hw->shortslot = false;\n\n\twlc_hw->SFBL = RETRY_SHORT_FB;\n\twlc_hw->LFBL = RETRY_LONG_FB;\n\n\t \n\twlc_hw->SRL = RETRY_SHORT_DEF;\n\twlc_hw->LRL = RETRY_LONG_DEF;\n\twlc_hw->chanspec = ch20mhz_chspec(1);\n}\n\nstatic void brcms_b_wait_for_wake(struct brcms_hardware *wlc_hw)\n{\n\t \n\tudelay(40);\n\n\t \n\tSPINWAIT((brcms_b_read_shm(wlc_hw, M_UCODE_DBGST) ==\n\t\t  DBGST_ASLEEP), wlc_hw->wlc->fastpwrup_dly);\n}\n\n \nstatic void brcms_b_clkctl_clk(struct brcms_hardware *wlc_hw, enum bcma_clkmode mode)\n{\n\tif (ai_get_cccaps(wlc_hw->sih) & CC_CAP_PMU) {\n\t\t \n\n\t\tif (wlc_hw->clk) {\n\t\t\tif (mode == BCMA_CLKMODE_FAST) {\n\t\t\t\tbcma_set32(wlc_hw->d11core,\n\t\t\t\t\t   D11REGOFFS(clk_ctl_st),\n\t\t\t\t\t   CCS_FORCEHT);\n\n\t\t\t\tudelay(64);\n\n\t\t\t\tSPINWAIT(\n\t\t\t\t    ((bcma_read32(wlc_hw->d11core,\n\t\t\t\t      D11REGOFFS(clk_ctl_st)) &\n\t\t\t\t      CCS_HTAVAIL) == 0),\n\t\t\t\t      PMU_MAX_TRANSITION_DLY);\n\t\t\t\tWARN_ON(!(bcma_read32(wlc_hw->d11core,\n\t\t\t\t\tD11REGOFFS(clk_ctl_st)) &\n\t\t\t\t\tCCS_HTAVAIL));\n\t\t\t} else {\n\t\t\t\tif ((ai_get_pmurev(wlc_hw->sih) == 0) &&\n\t\t\t\t    (bcma_read32(wlc_hw->d11core,\n\t\t\t\t\tD11REGOFFS(clk_ctl_st)) &\n\t\t\t\t\t(CCS_FORCEHT | CCS_HTAREQ)))\n\t\t\t\t\tSPINWAIT(\n\t\t\t\t\t    ((bcma_read32(wlc_hw->d11core,\n\t\t\t\t\t      offsetof(struct d11regs,\n\t\t\t\t\t\t       clk_ctl_st)) &\n\t\t\t\t\t      CCS_HTAVAIL) == 0),\n\t\t\t\t\t      PMU_MAX_TRANSITION_DLY);\n\t\t\t\tbcma_mask32(wlc_hw->d11core,\n\t\t\t\t\tD11REGOFFS(clk_ctl_st),\n\t\t\t\t\t~CCS_FORCEHT);\n\t\t\t}\n\t\t}\n\t\twlc_hw->forcefastclk = (mode == BCMA_CLKMODE_FAST);\n\t} else {\n\n\t\t \n\n\t\twlc_hw->forcefastclk = ai_clkctl_cc(wlc_hw->sih, mode);\n\n\t\t \n\t\tif (wlc_hw->forcefastclk && wlc_hw->clk)\n\t\t\tWARN_ON(!(bcma_aread32(wlc_hw->d11core, BCMA_IOST) &\n\t\t\t\t  SISF_FCLKA));\n\n\t\t \n\t\tif (wlc_hw->forcefastclk)\n\t\t\tmboolset(wlc_hw->wake_override,\n\t\t\t\t BRCMS_WAKE_OVERRIDE_FORCEFAST);\n\t\telse\n\t\t\tmboolclr(wlc_hw->wake_override,\n\t\t\t\t BRCMS_WAKE_OVERRIDE_FORCEFAST);\n\t}\n}\n\n \nvoid\nbrcms_b_mhf(struct brcms_hardware *wlc_hw, u8 idx, u16 mask, u16 val,\n\t     int bands)\n{\n\tu16 save;\n\tu16 addr[MHFMAX] = {\n\t\tM_HOST_FLAGS1, M_HOST_FLAGS2, M_HOST_FLAGS3, M_HOST_FLAGS4,\n\t\tM_HOST_FLAGS5\n\t};\n\tstruct brcms_hw_band *band;\n\n\tif ((val & ~mask) || idx >= MHFMAX)\n\t\treturn;  \n\n\tswitch (bands) {\n\t\t \n\tcase BRCM_BAND_AUTO:\n\tcase BRCM_BAND_ALL:\n\t\tband = wlc_hw->band;\n\t\tbreak;\n\tcase BRCM_BAND_5G:\n\t\tband = wlc_hw->bandstate[BAND_5G_INDEX];\n\t\tbreak;\n\tcase BRCM_BAND_2G:\n\t\tband = wlc_hw->bandstate[BAND_2G_INDEX];\n\t\tbreak;\n\tdefault:\n\t\tband = NULL;\t \n\t}\n\n\tif (band) {\n\t\tsave = band->mhfs[idx];\n\t\tband->mhfs[idx] = (band->mhfs[idx] & ~mask) | val;\n\n\t\t \n\t\tif (wlc_hw->clk && (band->mhfs[idx] != save)\n\t\t    && (band == wlc_hw->band))\n\t\t\tbrcms_b_write_shm(wlc_hw, addr[idx],\n\t\t\t\t\t   (u16) band->mhfs[idx]);\n\t}\n\n\tif (bands == BRCM_BAND_ALL) {\n\t\twlc_hw->bandstate[0]->mhfs[idx] =\n\t\t    (wlc_hw->bandstate[0]->mhfs[idx] & ~mask) | val;\n\t\twlc_hw->bandstate[1]->mhfs[idx] =\n\t\t    (wlc_hw->bandstate[1]->mhfs[idx] & ~mask) | val;\n\t}\n}\n\n \nstatic void brcms_c_mctrl_reset(struct brcms_hardware *wlc_hw)\n{\n\t \n\twlc_hw->maccontrol = 0;\n\twlc_hw->suspended_fifos = 0;\n\twlc_hw->wake_override = 0;\n\twlc_hw->mute_override = 0;\n\tbrcms_b_mctrl(wlc_hw, ~0, MCTL_IHR_EN | MCTL_WAKE);\n}\n\n \nstatic void brcms_c_mctrl_write(struct brcms_hardware *wlc_hw)\n{\n\tu32 maccontrol = wlc_hw->maccontrol;\n\n\t \n\tif (wlc_hw->wake_override)\n\t\tmaccontrol |= MCTL_WAKE;\n\n\t \n\tif (wlc_hw->mute_override) {\n\t\tmaccontrol &= ~(MCTL_AP);\n\t\tmaccontrol |= MCTL_INFRA;\n\t}\n\n\tbcma_write32(wlc_hw->d11core, D11REGOFFS(maccontrol),\n\t\t     maccontrol);\n}\n\n \nvoid brcms_b_mctrl(struct brcms_hardware *wlc_hw, u32 mask, u32 val)\n{\n\tu32 maccontrol;\n\tu32 new_maccontrol;\n\n\tif (val & ~mask)\n\t\treturn;  \n\tmaccontrol = wlc_hw->maccontrol;\n\tnew_maccontrol = (maccontrol & ~mask) | val;\n\n\t \n\tif (new_maccontrol == maccontrol)\n\t\treturn;\n\n\t \n\twlc_hw->maccontrol = new_maccontrol;\n\n\t \n\tbrcms_c_mctrl_write(wlc_hw);\n}\n\nvoid brcms_c_ucode_wake_override_set(struct brcms_hardware *wlc_hw,\n\t\t\t\t u32 override_bit)\n{\n\tif (wlc_hw->wake_override || (wlc_hw->maccontrol & MCTL_WAKE)) {\n\t\tmboolset(wlc_hw->wake_override, override_bit);\n\t\treturn;\n\t}\n\n\tmboolset(wlc_hw->wake_override, override_bit);\n\n\tbrcms_c_mctrl_write(wlc_hw);\n\tbrcms_b_wait_for_wake(wlc_hw);\n}\n\nvoid brcms_c_ucode_wake_override_clear(struct brcms_hardware *wlc_hw,\n\t\t\t\t   u32 override_bit)\n{\n\tmboolclr(wlc_hw->wake_override, override_bit);\n\n\tif (wlc_hw->wake_override || (wlc_hw->maccontrol & MCTL_WAKE))\n\t\treturn;\n\n\tbrcms_c_mctrl_write(wlc_hw);\n}\n\n \nstatic void brcms_c_ucode_mute_override_set(struct brcms_hardware *wlc_hw)\n{\n\twlc_hw->mute_override = 1;\n\n\t \n\tif ((wlc_hw->maccontrol & (MCTL_AP | MCTL_INFRA)) == MCTL_INFRA)\n\t\treturn;\n\n\tbrcms_c_mctrl_write(wlc_hw);\n}\n\n \nstatic void brcms_c_ucode_mute_override_clear(struct brcms_hardware *wlc_hw)\n{\n\tif (wlc_hw->mute_override == 0)\n\t\treturn;\n\n\twlc_hw->mute_override = 0;\n\n\t \n\tif ((wlc_hw->maccontrol & (MCTL_AP | MCTL_INFRA)) == MCTL_INFRA)\n\t\treturn;\n\n\tbrcms_c_mctrl_write(wlc_hw);\n}\n\n \nstatic void\nbrcms_b_set_addrmatch(struct brcms_hardware *wlc_hw, int match_reg_offset,\n\t\t       const u8 *addr)\n{\n\tstruct bcma_device *core = wlc_hw->d11core;\n\tu16 mac_l;\n\tu16 mac_m;\n\tu16 mac_h;\n\n\tbrcms_dbg_rx(core, \"wl%d: brcms_b_set_addrmatch\\n\", wlc_hw->unit);\n\n\tmac_l = addr[0] | (addr[1] << 8);\n\tmac_m = addr[2] | (addr[3] << 8);\n\tmac_h = addr[4] | (addr[5] << 8);\n\n\t \n\tbcma_write16(core, D11REGOFFS(rcm_ctl),\n\t\t     RCM_INC_DATA | match_reg_offset);\n\tbcma_write16(core, D11REGOFFS(rcm_mat_data), mac_l);\n\tbcma_write16(core, D11REGOFFS(rcm_mat_data), mac_m);\n\tbcma_write16(core, D11REGOFFS(rcm_mat_data), mac_h);\n}\n\nvoid\nbrcms_b_write_template_ram(struct brcms_hardware *wlc_hw, int offset, int len,\n\t\t\t    void *buf)\n{\n\tstruct bcma_device *core = wlc_hw->d11core;\n\tu32 word;\n\t__le32 word_le;\n\t__be32 word_be;\n\tbool be_bit;\n\tbrcms_dbg_info(core, \"wl%d\\n\", wlc_hw->unit);\n\n\tbcma_write32(core, D11REGOFFS(tplatewrptr), offset);\n\n\t \n\tbe_bit = (bcma_read32(core, D11REGOFFS(maccontrol)) & MCTL_BIGEND) != 0;\n\n\twhile (len > 0) {\n\t\tmemcpy(&word, buf, sizeof(u32));\n\n\t\tif (be_bit) {\n\t\t\tword_be = cpu_to_be32(word);\n\t\t\tword = *(u32 *)&word_be;\n\t\t} else {\n\t\t\tword_le = cpu_to_le32(word);\n\t\t\tword = *(u32 *)&word_le;\n\t\t}\n\n\t\tbcma_write32(core, D11REGOFFS(tplatewrdata), word);\n\n\t\tbuf = (u8 *) buf + sizeof(u32);\n\t\tlen -= sizeof(u32);\n\t}\n}\n\nstatic void brcms_b_set_cwmin(struct brcms_hardware *wlc_hw, u16 newmin)\n{\n\twlc_hw->band->CWmin = newmin;\n\n\tbcma_write32(wlc_hw->d11core, D11REGOFFS(objaddr),\n\t\t     OBJADDR_SCR_SEL | S_DOT11_CWMIN);\n\t(void)bcma_read32(wlc_hw->d11core, D11REGOFFS(objaddr));\n\tbcma_write32(wlc_hw->d11core, D11REGOFFS(objdata), newmin);\n}\n\nstatic void brcms_b_set_cwmax(struct brcms_hardware *wlc_hw, u16 newmax)\n{\n\twlc_hw->band->CWmax = newmax;\n\n\tbcma_write32(wlc_hw->d11core, D11REGOFFS(objaddr),\n\t\t     OBJADDR_SCR_SEL | S_DOT11_CWMAX);\n\t(void)bcma_read32(wlc_hw->d11core, D11REGOFFS(objaddr));\n\tbcma_write32(wlc_hw->d11core, D11REGOFFS(objdata), newmax);\n}\n\nvoid brcms_b_bw_set(struct brcms_hardware *wlc_hw, u16 bw)\n{\n\tbool fastclk;\n\n\t \n\tfastclk = wlc_hw->forcefastclk;\n\tif (!fastclk)\n\t\tbrcms_b_clkctl_clk(wlc_hw, BCMA_CLKMODE_FAST);\n\n\twlc_phy_bw_state_set(wlc_hw->band->pi, bw);\n\n\tbrcms_b_phy_reset(wlc_hw);\n\twlc_phy_init(wlc_hw->band->pi, wlc_phy_chanspec_get(wlc_hw->band->pi));\n\n\t \n\tif (!fastclk)\n\t\tbrcms_b_clkctl_clk(wlc_hw, BCMA_CLKMODE_DYNAMIC);\n}\n\nstatic void brcms_b_upd_synthpu(struct brcms_hardware *wlc_hw)\n{\n\tu16 v;\n\tstruct brcms_c_info *wlc = wlc_hw->wlc;\n\t \n\n\tif (BRCMS_ISLCNPHY(wlc->band))\n\t\tv = SYNTHPU_DLY_LPPHY_US;\n\telse if (BRCMS_ISNPHY(wlc->band) && (NREV_GE(wlc->band->phyrev, 3)))\n\t\tv = SYNTHPU_DLY_NPHY_US;\n\telse\n\t\tv = SYNTHPU_DLY_BPHY_US;\n\n\tbrcms_b_write_shm(wlc_hw, M_SYNTHPU_DLY, v);\n}\n\nstatic void brcms_c_ucode_txant_set(struct brcms_hardware *wlc_hw)\n{\n\tu16 phyctl;\n\tu16 phytxant = wlc_hw->bmac_phytxant;\n\tu16 mask = PHY_TXC_ANT_MASK;\n\n\t \n\tphyctl = brcms_b_read_shm(wlc_hw, M_CTXPRS_BLK + C_CTX_PCTLWD_POS);\n\tphyctl = (phyctl & ~mask) | phytxant;\n\tbrcms_b_write_shm(wlc_hw, M_CTXPRS_BLK + C_CTX_PCTLWD_POS, phyctl);\n\n\t \n\tphyctl = brcms_b_read_shm(wlc_hw, M_RSP_PCTLWD);\n\tphyctl = (phyctl & ~mask) | phytxant;\n\tbrcms_b_write_shm(wlc_hw, M_RSP_PCTLWD, phyctl);\n}\n\nstatic u16 brcms_b_ofdm_ratetable_offset(struct brcms_hardware *wlc_hw,\n\t\t\t\t\t u8 rate)\n{\n\tuint i;\n\tu8 plcp_rate = 0;\n\tstruct plcp_signal_rate_lookup {\n\t\tu8 rate;\n\t\tu8 signal_rate;\n\t};\n\t \n\tconst struct plcp_signal_rate_lookup rate_lookup[] = {\n\t\t{BRCM_RATE_6M, 0xB},\n\t\t{BRCM_RATE_9M, 0xF},\n\t\t{BRCM_RATE_12M, 0xA},\n\t\t{BRCM_RATE_18M, 0xE},\n\t\t{BRCM_RATE_24M, 0x9},\n\t\t{BRCM_RATE_36M, 0xD},\n\t\t{BRCM_RATE_48M, 0x8},\n\t\t{BRCM_RATE_54M, 0xC}\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(rate_lookup); i++) {\n\t\tif (rate == rate_lookup[i].rate) {\n\t\t\tplcp_rate = rate_lookup[i].signal_rate;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\treturn 2 * brcms_b_read_shm(wlc_hw, M_RT_DIRMAP_A + (plcp_rate * 2));\n}\n\nstatic void brcms_upd_ofdm_pctl1_table(struct brcms_hardware *wlc_hw)\n{\n\tu8 rate;\n\tu8 rates[8] = {\n\t\tBRCM_RATE_6M, BRCM_RATE_9M, BRCM_RATE_12M, BRCM_RATE_18M,\n\t\tBRCM_RATE_24M, BRCM_RATE_36M, BRCM_RATE_48M, BRCM_RATE_54M\n\t};\n\tu16 entry_ptr;\n\tu16 pctl1;\n\tuint i;\n\n\tif (!BRCMS_PHY_11N_CAP(wlc_hw->band))\n\t\treturn;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(rates); i++) {\n\t\trate = rates[i];\n\n\t\tentry_ptr = brcms_b_ofdm_ratetable_offset(wlc_hw, rate);\n\n\t\t \n\t\tpctl1 =\n\t\t    brcms_b_read_shm(wlc_hw, entry_ptr + M_RT_OFDM_PCTL1_POS);\n\n\t\t \n\t\tpctl1 &= ~PHY_TXC1_MODE_MASK;\n\t\tpctl1 |= (wlc_hw->hw_stf_ss_opmode << PHY_TXC1_MODE_SHIFT);\n\n\t\t \n\t\tbrcms_b_write_shm(wlc_hw, entry_ptr + M_RT_OFDM_PCTL1_POS,\n\t\t\t\t   pctl1);\n\t}\n}\n\n \nstatic void brcms_b_bsinit(struct brcms_c_info *wlc, u16 chanspec)\n{\n\tstruct brcms_hardware *wlc_hw = wlc->hw;\n\n\tbrcms_dbg_mac80211(wlc_hw->d11core, \"wl%d: bandunit %d\\n\", wlc_hw->unit,\n\t\t\t   wlc_hw->band->bandunit);\n\n\tbrcms_c_ucode_bsinit(wlc_hw);\n\n\twlc_phy_init(wlc_hw->band->pi, chanspec);\n\n\tbrcms_c_ucode_txant_set(wlc_hw);\n\n\t \n\tbrcms_b_set_cwmin(wlc_hw, wlc_hw->band->CWmin);\n\tbrcms_b_set_cwmax(wlc_hw, wlc_hw->band->CWmax);\n\n\tbrcms_b_update_slot_timing(wlc_hw,\n\t\t\t\t   wlc_hw->band->bandtype == BRCM_BAND_5G ?\n\t\t\t\t   true : wlc_hw->shortslot);\n\n\t \n\tbrcms_b_write_shm(wlc_hw, M_PHYTYPE, (u16) wlc_hw->band->phytype);\n\tbrcms_b_write_shm(wlc_hw, M_PHYVER, (u16) wlc_hw->band->phyrev);\n\n\t \n\tbrcms_upd_ofdm_pctl1_table(wlc_hw);\n\n\tbrcms_b_upd_synthpu(wlc_hw);\n}\n\n \nvoid brcms_b_core_phypll_reset(struct brcms_hardware *wlc_hw)\n{\n\tai_cc_reg(wlc_hw->sih, offsetof(struct chipcregs, chipcontrol_addr),\n\t\t  ~0, 0);\n\tudelay(1);\n\tai_cc_reg(wlc_hw->sih, offsetof(struct chipcregs, chipcontrol_data),\n\t\t  0x4, 0);\n\tudelay(1);\n\tai_cc_reg(wlc_hw->sih, offsetof(struct chipcregs, chipcontrol_data),\n\t\t  0x4, 4);\n\tudelay(1);\n\tai_cc_reg(wlc_hw->sih, offsetof(struct chipcregs, chipcontrol_data),\n\t\t  0x4, 0);\n\tudelay(1);\n}\n\n \nvoid brcms_b_phyclk_fgc(struct brcms_hardware *wlc_hw, bool clk)\n{\n\t \n\tif (!BRCMS_ISNPHY(wlc_hw->band))\n\t\treturn;\n\n\tif (ON == clk)\n\t\tbrcms_b_core_ioctl(wlc_hw, SICF_FGC, SICF_FGC);\n\telse\n\t\tbrcms_b_core_ioctl(wlc_hw, SICF_FGC, 0);\n\n}\n\nvoid brcms_b_macphyclk_set(struct brcms_hardware *wlc_hw, bool clk)\n{\n\tif (ON == clk)\n\t\tbrcms_b_core_ioctl(wlc_hw, SICF_MPCLKE, SICF_MPCLKE);\n\telse\n\t\tbrcms_b_core_ioctl(wlc_hw, SICF_MPCLKE, 0);\n}\n\nvoid brcms_b_phy_reset(struct brcms_hardware *wlc_hw)\n{\n\tstruct brcms_phy_pub *pih = wlc_hw->band->pi;\n\tu32 phy_bw_clkbits;\n\n\tbrcms_dbg_info(wlc_hw->d11core, \"wl%d: reset phy\\n\", wlc_hw->unit);\n\n\tif (pih == NULL)\n\t\treturn;\n\n\tphy_bw_clkbits = wlc_phy_clk_bwbits(wlc_hw->band->pi);\n\n\t \n\tif (BRCMS_ISNPHY(wlc_hw->band) && NREV_GE(wlc_hw->band->phyrev, 3) &&\n\t    NREV_LE(wlc_hw->band->phyrev, 4)) {\n\t\t \n\t\tbrcms_b_core_ioctl(wlc_hw, SICF_BWMASK, phy_bw_clkbits);\n\n\t\tudelay(1);\n\n\t\t \n\t\tbrcms_b_core_phypll_reset(wlc_hw);\n\n\t\t \n\t\tbrcms_b_core_ioctl(wlc_hw, (SICF_PRST | SICF_PCLKE),\n\t\t\t\t   (SICF_PRST | SICF_PCLKE));\n\t} else {\n\t\tbrcms_b_core_ioctl(wlc_hw,\n\t\t\t\t   (SICF_PRST | SICF_PCLKE | SICF_BWMASK),\n\t\t\t\t   (SICF_PRST | SICF_PCLKE | phy_bw_clkbits));\n\t}\n\n\tudelay(2);\n\tbrcms_b_core_phy_clk(wlc_hw, ON);\n\n\twlc_phy_anacore(pih, ON);\n}\n\n \nstatic void brcms_b_setband(struct brcms_hardware *wlc_hw, uint bandunit,\n\t\t\t    u16 chanspec) {\n\tstruct brcms_c_info *wlc = wlc_hw->wlc;\n\tu32 macintmask;\n\n\t \n\tif (!bcma_core_is_enabled(wlc_hw->d11core)) {\n\t\tbcma_core_enable(wlc_hw->d11core, 0);\n\t\tbrcms_c_mctrl_reset(wlc_hw);\n\t}\n\n\tmacintmask = brcms_c_setband_inact(wlc, bandunit);\n\n\tif (!wlc_hw->up)\n\t\treturn;\n\n\tbrcms_b_core_phy_clk(wlc_hw, ON);\n\n\t \n\tbrcms_b_bsinit(wlc, chanspec);\n\n\t \n\tif (wlc->macintstatus)\n\t\twlc->macintstatus = MI_DMAINT;\n\n\t \n\tbrcms_intrsrestore(wlc->wl, macintmask);\n\n\t \n\tWARN_ON((bcma_read32(wlc_hw->d11core, D11REGOFFS(maccontrol)) &\n\t\t MCTL_EN_MAC) != 0);\n}\n\nstatic bool brcms_c_isgoodchip(struct brcms_hardware *wlc_hw)\n{\n\n\t \n\tif (!CONF_HAS(D11CONF, wlc_hw->corerev)) {\n\t\twiphy_err(wlc_hw->wlc->wiphy, \"unsupported core rev %d\\n\",\n\t\t\t  wlc_hw->corerev);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic bool brcms_c_validboardtype(struct brcms_hardware *wlc_hw)\n{\n\tuint boardrev = wlc_hw->boardrev;\n\n\t \n\tuint brt = (boardrev & 0xf000) >> 12;\n\tuint b0 = (boardrev & 0xf00) >> 8;\n\tuint b1 = (boardrev & 0xf0) >> 4;\n\tuint b2 = boardrev & 0xf;\n\n\t \n\tif (ai_get_boardvendor(wlc_hw->sih) != PCI_VENDOR_ID_BROADCOM)\n\t\treturn true;\n\n\t \n\tif (boardrev == 0)\n\t\treturn false;\n\n\tif (boardrev <= 0xff)\n\t\treturn true;\n\n\tif ((brt > 2) || (brt == 0) || (b0 > 9) || (b0 == 0) || (b1 > 9)\n\t\t|| (b2 > 9))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void brcms_c_get_macaddr(struct brcms_hardware *wlc_hw, u8 etheraddr[ETH_ALEN])\n{\n\tstruct ssb_sprom *sprom = &wlc_hw->d11core->bus->sprom;\n\n\t \n\tif (!is_zero_ether_addr(sprom->il0mac)) {\n\t\tmemcpy(etheraddr, sprom->il0mac, ETH_ALEN);\n\t\treturn;\n\t}\n\n\tif (wlc_hw->_nbands > 1)\n\t\tmemcpy(etheraddr, sprom->et1mac, ETH_ALEN);\n\telse\n\t\tmemcpy(etheraddr, sprom->il0mac, ETH_ALEN);\n}\n\n \nstatic void brcms_b_xtal(struct brcms_hardware *wlc_hw, bool want)\n{\n\tbrcms_dbg_info(wlc_hw->d11core, \"wl%d: want %d\\n\", wlc_hw->unit, want);\n\n\t \n\tif (!want && wlc_hw->pllreq)\n\t\treturn;\n\n\twlc_hw->sbclk = want;\n\tif (!wlc_hw->sbclk) {\n\t\twlc_hw->clk = false;\n\t\tif (wlc_hw->band && wlc_hw->band->pi)\n\t\t\twlc_phy_hw_clk_state_upd(wlc_hw->band->pi, false);\n\t}\n}\n\n \nstatic bool brcms_b_radio_read_hwdisabled(struct brcms_hardware *wlc_hw)\n{\n\tbool v, clk, xtal;\n\tu32 flags = 0;\n\n\txtal = wlc_hw->sbclk;\n\tif (!xtal)\n\t\tbrcms_b_xtal(wlc_hw, ON);\n\n\t \n\tclk = wlc_hw->clk;\n\tif (!clk) {\n\t\t \n\t\tif (D11REV_GE(wlc_hw->corerev, 18))\n\t\t\tflags |= SICF_PCLKE;\n\n\t\t \n\n\t\tbcma_core_enable(wlc_hw->d11core, flags);\n\t\tbrcms_c_mctrl_reset(wlc_hw);\n\t}\n\n\tv = ((bcma_read32(wlc_hw->d11core,\n\t\t\t  D11REGOFFS(phydebug)) & PDBG_RFD) != 0);\n\n\t \n\tif (!clk)\n\t\tbcma_core_disable(wlc_hw->d11core, 0);\n\n\tif (!xtal)\n\t\tbrcms_b_xtal(wlc_hw, OFF);\n\n\treturn v;\n}\n\nstatic bool wlc_dma_rxreset(struct brcms_hardware *wlc_hw, uint fifo)\n{\n\tstruct dma_pub *di = wlc_hw->di[fifo];\n\treturn dma_rxreset(di);\n}\n\n \nvoid brcms_b_corereset(struct brcms_hardware *wlc_hw, u32 flags)\n{\n\tuint i;\n\tbool fastclk;\n\n\tif (flags == BRCMS_USE_COREFLAGS)\n\t\tflags = (wlc_hw->band->pi ? wlc_hw->band->core_flags : 0);\n\n\tbrcms_dbg_info(wlc_hw->d11core, \"wl%d: core reset\\n\", wlc_hw->unit);\n\n\t \n\tfastclk = wlc_hw->forcefastclk;\n\tif (!fastclk)\n\t\tbrcms_b_clkctl_clk(wlc_hw, BCMA_CLKMODE_FAST);\n\n\t \n\tif (bcma_core_is_enabled(wlc_hw->d11core)) {\n\t\tfor (i = 0; i < NFIFO; i++)\n\t\t\tif ((wlc_hw->di[i]) && (!dma_txreset(wlc_hw->di[i])))\n\t\t\t\tbrcms_err(wlc_hw->d11core, \"wl%d: %s: \"\n\t\t\t\t\t  \"dma_txreset[%d]: cannot stop dma\\n\",\n\t\t\t\t\t   wlc_hw->unit, __func__, i);\n\n\t\tif ((wlc_hw->di[RX_FIFO])\n\t\t    && (!wlc_dma_rxreset(wlc_hw, RX_FIFO)))\n\t\t\tbrcms_err(wlc_hw->d11core, \"wl%d: %s: dma_rxreset\"\n\t\t\t\t  \"[%d]: cannot stop dma\\n\",\n\t\t\t\t  wlc_hw->unit, __func__, RX_FIFO);\n\t}\n\t \n\tif (wlc_hw->noreset) {\n\t\twlc_hw->wlc->macintstatus = 0;\t \n\t\tbrcms_b_mctrl(wlc_hw, MCTL_PSM_RUN | MCTL_EN_MAC, 0);\n\t\treturn;\n\t}\n\n\t \n\tif (D11REV_GE(wlc_hw->corerev, 18))\n\t\tflags |= SICF_PCLKE;\n\n\t \n\twlc_hw->clk = false;\n\tbcma_core_enable(wlc_hw->d11core, flags);\n\twlc_hw->clk = true;\n\tif (wlc_hw->band && wlc_hw->band->pi)\n\t\twlc_phy_hw_clk_state_upd(wlc_hw->band->pi, true);\n\n\tbrcms_c_mctrl_reset(wlc_hw);\n\n\tif (ai_get_cccaps(wlc_hw->sih) & CC_CAP_PMU)\n\t\tbrcms_b_clkctl_clk(wlc_hw, BCMA_CLKMODE_FAST);\n\n\tbrcms_b_phy_reset(wlc_hw);\n\n\t \n\tbrcms_b_core_phypll_ctl(wlc_hw, true);\n\n\t \n\twlc_hw->wlc->macintstatus = 0;\n\n\t \n\tif (!fastclk)\n\t\tbrcms_b_clkctl_clk(wlc_hw, BCMA_CLKMODE_DYNAMIC);\n}\n\n \nstatic void brcms_b_corerev_fifofixup(struct brcms_hardware *wlc_hw)\n{\n\tstruct bcma_device *core = wlc_hw->d11core;\n\tu16 fifo_nu;\n\tu16 txfifo_startblk = TXFIFO_START_BLK, txfifo_endblk;\n\tu16 txfifo_def, txfifo_def1;\n\tu16 txfifo_cmd;\n\n\t \n\ttxfifo_startblk = TXFIFO_START_BLK;\n\n\t \n\tfor (fifo_nu = 0; fifo_nu < NFIFO; fifo_nu++) {\n\n\t\ttxfifo_endblk = txfifo_startblk + wlc_hw->xmtfifo_sz[fifo_nu];\n\t\ttxfifo_def = (txfifo_startblk & 0xff) |\n\t\t    (((txfifo_endblk - 1) & 0xff) << TXFIFO_FIFOTOP_SHIFT);\n\t\ttxfifo_def1 = ((txfifo_startblk >> 8) & 0x1) |\n\t\t    ((((txfifo_endblk -\n\t\t\t1) >> 8) & 0x1) << TXFIFO_FIFOTOP_SHIFT);\n\t\ttxfifo_cmd =\n\t\t    TXFIFOCMD_RESET_MASK | (fifo_nu << TXFIFOCMD_FIFOSEL_SHIFT);\n\n\t\tbcma_write16(core, D11REGOFFS(xmtfifocmd), txfifo_cmd);\n\t\tbcma_write16(core, D11REGOFFS(xmtfifodef), txfifo_def);\n\t\tbcma_write16(core, D11REGOFFS(xmtfifodef1), txfifo_def1);\n\n\t\tbcma_write16(core, D11REGOFFS(xmtfifocmd), txfifo_cmd);\n\n\t\ttxfifo_startblk += wlc_hw->xmtfifo_sz[fifo_nu];\n\t}\n\t \n\tbrcms_b_write_shm(wlc_hw, M_FIFOSIZE0,\n\t\t\t   wlc_hw->xmtfifo_sz[TX_AC_BE_FIFO]);\n\tbrcms_b_write_shm(wlc_hw, M_FIFOSIZE1,\n\t\t\t   wlc_hw->xmtfifo_sz[TX_AC_VI_FIFO]);\n\tbrcms_b_write_shm(wlc_hw, M_FIFOSIZE2,\n\t\t\t   ((wlc_hw->xmtfifo_sz[TX_AC_VO_FIFO] << 8) | wlc_hw->\n\t\t\t    xmtfifo_sz[TX_AC_BK_FIFO]));\n\tbrcms_b_write_shm(wlc_hw, M_FIFOSIZE3,\n\t\t\t   ((wlc_hw->xmtfifo_sz[TX_ATIM_FIFO] << 8) | wlc_hw->\n\t\t\t    xmtfifo_sz[TX_BCMC_FIFO]));\n}\n\n \n\nvoid brcms_b_switch_macfreq(struct brcms_hardware *wlc_hw, u8 spurmode)\n{\n\tstruct bcma_device *core = wlc_hw->d11core;\n\n\tif ((ai_get_chip_id(wlc_hw->sih) == BCMA_CHIP_ID_BCM43224) ||\n\t    (ai_get_chip_id(wlc_hw->sih) == BCMA_CHIP_ID_BCM43225)) {\n\t\tif (spurmode == WL_SPURAVOID_ON2) {\t \n\t\t\tbcma_write16(core, D11REGOFFS(tsf_clk_frac_l), 0x2082);\n\t\t\tbcma_write16(core, D11REGOFFS(tsf_clk_frac_h), 0x8);\n\t\t} else if (spurmode == WL_SPURAVOID_ON1) {\t \n\t\t\tbcma_write16(core, D11REGOFFS(tsf_clk_frac_l), 0x5341);\n\t\t\tbcma_write16(core, D11REGOFFS(tsf_clk_frac_h), 0x8);\n\t\t} else {\t \n\t\t\tbcma_write16(core, D11REGOFFS(tsf_clk_frac_l), 0x8889);\n\t\t\tbcma_write16(core, D11REGOFFS(tsf_clk_frac_h), 0x8);\n\t\t}\n\t} else if (BRCMS_ISLCNPHY(wlc_hw->band)) {\n\t\tif (spurmode == WL_SPURAVOID_ON1) {\t \n\t\t\tbcma_write16(core, D11REGOFFS(tsf_clk_frac_l), 0x7CE0);\n\t\t\tbcma_write16(core, D11REGOFFS(tsf_clk_frac_h), 0xC);\n\t\t} else {\t \n\t\t\tbcma_write16(core, D11REGOFFS(tsf_clk_frac_l), 0xCCCD);\n\t\t\tbcma_write16(core, D11REGOFFS(tsf_clk_frac_h), 0xC);\n\t\t}\n\t}\n}\n\nvoid brcms_c_start_station(struct brcms_c_info *wlc, u8 *addr)\n{\n\tmemcpy(wlc->pub->cur_etheraddr, addr, sizeof(wlc->pub->cur_etheraddr));\n\twlc->bsscfg->type = BRCMS_TYPE_STATION;\n}\n\nvoid brcms_c_start_ap(struct brcms_c_info *wlc, u8 *addr, const u8 *bssid,\n\t\t      u8 *ssid, size_t ssid_len)\n{\n\tbrcms_c_set_ssid(wlc, ssid, ssid_len);\n\n\tmemcpy(wlc->pub->cur_etheraddr, addr, sizeof(wlc->pub->cur_etheraddr));\n\tmemcpy(wlc->bsscfg->BSSID, bssid, sizeof(wlc->bsscfg->BSSID));\n\twlc->bsscfg->type = BRCMS_TYPE_AP;\n\n\tbrcms_b_mctrl(wlc->hw, MCTL_AP | MCTL_INFRA, MCTL_AP | MCTL_INFRA);\n}\n\nvoid brcms_c_start_adhoc(struct brcms_c_info *wlc, u8 *addr)\n{\n\tmemcpy(wlc->pub->cur_etheraddr, addr, sizeof(wlc->pub->cur_etheraddr));\n\twlc->bsscfg->type = BRCMS_TYPE_ADHOC;\n\n\tbrcms_b_mctrl(wlc->hw, MCTL_AP | MCTL_INFRA, 0);\n}\n\n \nstatic void brcms_c_gpio_init(struct brcms_c_info *wlc)\n{\n\tstruct brcms_hardware *wlc_hw = wlc->hw;\n\tu32 gc, gm;\n\n\t \n\tbrcms_b_mctrl(wlc_hw, MCTL_GPOUT_SEL_MASK, 0);\n\n\t \n\n\tgc = gm = 0;\n\n\t \n\tif (wlc_hw->antsel_type == ANTSEL_2x3) {\n\t\t \n\t\tbrcms_b_mhf(wlc_hw, MHF3, MHF3_ANTSEL_EN,\n\t\t\t     MHF3_ANTSEL_EN, BRCM_BAND_ALL);\n\t\tbrcms_b_mhf(wlc_hw, MHF3, MHF3_ANTSEL_MODE,\n\t\t\t     MHF3_ANTSEL_MODE, BRCM_BAND_ALL);\n\n\t\t \n\t\twlc_phy_antsel_init(wlc_hw->band->pi, false);\n\n\t} else if (wlc_hw->antsel_type == ANTSEL_2x4) {\n\t\tgm |= gc |= (BOARD_GPIO_12 | BOARD_GPIO_13);\n\t\t \n\t\tbcma_set16(wlc_hw->d11core, D11REGOFFS(psm_gpio_oe),\n\t\t\t   (BOARD_GPIO_12 | BOARD_GPIO_13));\n\t\tbcma_set16(wlc_hw->d11core, D11REGOFFS(psm_gpio_out),\n\t\t\t   (BOARD_GPIO_12 | BOARD_GPIO_13));\n\n\t\t \n\t\tbrcms_b_mhf(wlc_hw, MHF3, MHF3_ANTSEL_EN,\n\t\t\t     MHF3_ANTSEL_EN, BRCM_BAND_ALL);\n\t\tbrcms_b_mhf(wlc_hw, MHF3, MHF3_ANTSEL_MODE, 0,\n\t\t\t     BRCM_BAND_ALL);\n\n\t\t \n\t\tbrcms_b_write_shm(wlc_hw, M_ANTSEL_CLKDIV,\n\t\t\t\t   ANTSEL_CLKDIV_4MHZ);\n\t}\n\n\t \n\tif (wlc_hw->boardflags & BFL_PACTRL)\n\t\tgm |= gc |= BOARD_GPIO_PACTRL;\n\n\t \n\tbcma_chipco_gpio_control(&wlc_hw->d11core->bus->drv_cc, gm, gc);\n}\n\nstatic void brcms_ucode_write(struct brcms_hardware *wlc_hw,\n\t\t\t      const __le32 ucode[], const size_t nbytes)\n{\n\tstruct bcma_device *core = wlc_hw->d11core;\n\tuint i;\n\tuint count;\n\n\tbrcms_dbg_info(wlc_hw->d11core, \"wl%d\\n\", wlc_hw->unit);\n\n\tcount = (nbytes / sizeof(u32));\n\n\tbcma_write32(core, D11REGOFFS(objaddr),\n\t\t     OBJADDR_AUTO_INC | OBJADDR_UCM_SEL);\n\t(void)bcma_read32(core, D11REGOFFS(objaddr));\n\tfor (i = 0; i < count; i++)\n\t\tbcma_write32(core, D11REGOFFS(objdata), le32_to_cpu(ucode[i]));\n\n}\n\nstatic void brcms_ucode_download(struct brcms_hardware *wlc_hw)\n{\n\tstruct brcms_ucode *ucode = &wlc_hw->wlc->wl->ucode;\n\n\tif (wlc_hw->ucode_loaded)\n\t\treturn;\n\n\tif (D11REV_IS(wlc_hw->corerev, 17) || D11REV_IS(wlc_hw->corerev, 23)) {\n\t\tif (BRCMS_ISNPHY(wlc_hw->band)) {\n\t\t\tbrcms_ucode_write(wlc_hw, ucode->bcm43xx_16_mimo,\n\t\t\t\t\t  ucode->bcm43xx_16_mimosz);\n\t\t\twlc_hw->ucode_loaded = true;\n\t\t} else\n\t\t\tbrcms_err(wlc_hw->d11core,\n\t\t\t\t  \"%s: wl%d: unsupported phy in corerev %d\\n\",\n\t\t\t\t  __func__, wlc_hw->unit, wlc_hw->corerev);\n\t} else if (D11REV_IS(wlc_hw->corerev, 24)) {\n\t\tif (BRCMS_ISLCNPHY(wlc_hw->band)) {\n\t\t\tbrcms_ucode_write(wlc_hw, ucode->bcm43xx_24_lcn,\n\t\t\t\t\t  ucode->bcm43xx_24_lcnsz);\n\t\t\twlc_hw->ucode_loaded = true;\n\t\t} else {\n\t\t\tbrcms_err(wlc_hw->d11core,\n\t\t\t\t  \"%s: wl%d: unsupported phy in corerev %d\\n\",\n\t\t\t\t  __func__, wlc_hw->unit, wlc_hw->corerev);\n\t\t}\n\t}\n}\n\nvoid brcms_b_txant_set(struct brcms_hardware *wlc_hw, u16 phytxant)\n{\n\t \n\twlc_hw->bmac_phytxant = phytxant;\n\n\t \n\tif (!wlc_hw->up)\n\t\treturn;\n\tbrcms_c_ucode_txant_set(wlc_hw);\n\n}\n\nu16 brcms_b_get_txant(struct brcms_hardware *wlc_hw)\n{\n\treturn (u16) wlc_hw->wlc->stf->txant;\n}\n\nvoid brcms_b_antsel_type_set(struct brcms_hardware *wlc_hw, u8 antsel_type)\n{\n\twlc_hw->antsel_type = antsel_type;\n\n\t \n\twlc_phy_antsel_type_set(wlc_hw->band->pi, antsel_type);\n}\n\nstatic void brcms_b_fifoerrors(struct brcms_hardware *wlc_hw)\n{\n\tbool fatal = false;\n\tuint unit;\n\tuint intstatus, idx;\n\tstruct bcma_device *core = wlc_hw->d11core;\n\n\tunit = wlc_hw->unit;\n\n\tfor (idx = 0; idx < NFIFO; idx++) {\n\t\t \n\t\tintstatus =\n\t\t\tbcma_read32(core,\n\t\t\t\t    D11REGOFFS(intctrlregs[idx].intstatus)) &\n\t\t\tI_ERRORS;\n\t\tif (!intstatus)\n\t\t\tcontinue;\n\n\t\tbrcms_dbg_int(core, \"wl%d: intstatus%d 0x%x\\n\",\n\t\t\t      unit, idx, intstatus);\n\n\t\tif (intstatus & I_RO) {\n\t\t\tbrcms_err(core, \"wl%d: fifo %d: receive fifo \"\n\t\t\t\t  \"overflow\\n\", unit, idx);\n\t\t\tfatal = true;\n\t\t}\n\n\t\tif (intstatus & I_PC) {\n\t\t\tbrcms_err(core, \"wl%d: fifo %d: descriptor error\\n\",\n\t\t\t\t  unit, idx);\n\t\t\tfatal = true;\n\t\t}\n\n\t\tif (intstatus & I_PD) {\n\t\t\tbrcms_err(core, \"wl%d: fifo %d: data error\\n\", unit,\n\t\t\t\t  idx);\n\t\t\tfatal = true;\n\t\t}\n\n\t\tif (intstatus & I_DE) {\n\t\t\tbrcms_err(core, \"wl%d: fifo %d: descriptor protocol \"\n\t\t\t\t  \"error\\n\", unit, idx);\n\t\t\tfatal = true;\n\t\t}\n\n\t\tif (intstatus & I_RU)\n\t\t\tbrcms_err(core, \"wl%d: fifo %d: receive descriptor \"\n\t\t\t\t  \"underflow\\n\", idx, unit);\n\n\t\tif (intstatus & I_XU) {\n\t\t\tbrcms_err(core, \"wl%d: fifo %d: transmit fifo \"\n\t\t\t\t  \"underflow\\n\", idx, unit);\n\t\t\tfatal = true;\n\t\t}\n\n\t\tif (fatal) {\n\t\t\tbrcms_fatal_error(wlc_hw->wlc->wl);  \n\t\t\tbreak;\n\t\t} else\n\t\t\tbcma_write32(core,\n\t\t\t\t     D11REGOFFS(intctrlregs[idx].intstatus),\n\t\t\t\t     intstatus);\n\t}\n}\n\nvoid brcms_c_intrson(struct brcms_c_info *wlc)\n{\n\tstruct brcms_hardware *wlc_hw = wlc->hw;\n\twlc->macintmask = wlc->defmacintmask;\n\tbcma_write32(wlc_hw->d11core, D11REGOFFS(macintmask), wlc->macintmask);\n}\n\nu32 brcms_c_intrsoff(struct brcms_c_info *wlc)\n{\n\tstruct brcms_hardware *wlc_hw = wlc->hw;\n\tu32 macintmask;\n\n\tif (!wlc_hw->clk)\n\t\treturn 0;\n\n\tmacintmask = wlc->macintmask;\t \n\n\tbcma_write32(wlc_hw->d11core, D11REGOFFS(macintmask), 0);\n\t(void)bcma_read32(wlc_hw->d11core, D11REGOFFS(macintmask));\n\tudelay(1);\t\t \n\twlc->macintmask = 0;\n\n\t \n\treturn wlc->macintstatus ? 0 : macintmask;\n}\n\nvoid brcms_c_intrsrestore(struct brcms_c_info *wlc, u32 macintmask)\n{\n\tstruct brcms_hardware *wlc_hw = wlc->hw;\n\tif (!wlc_hw->clk)\n\t\treturn;\n\n\twlc->macintmask = macintmask;\n\tbcma_write32(wlc_hw->d11core, D11REGOFFS(macintmask), wlc->macintmask);\n}\n\n \nstatic void brcms_b_tx_fifo_suspend(struct brcms_hardware *wlc_hw,\n\t\t\t\t    uint tx_fifo)\n{\n\tu8 fifo = 1 << tx_fifo;\n\n\t \n\n\t \n\tif ((wlc_hw->suspended_fifos & fifo) == fifo)\n\t\treturn;\n\n\t \n\tif (wlc_hw->suspended_fifos == 0)\n\t\tbrcms_c_ucode_wake_override_set(wlc_hw,\n\t\t\t\t\t\tBRCMS_WAKE_OVERRIDE_TXFIFO);\n\n\twlc_hw->suspended_fifos |= fifo;\n\n\tif (wlc_hw->di[tx_fifo]) {\n\t\t \n\t\tif (BRCMS_PHY_11N_CAP(wlc_hw->band))\n\t\t\tbrcms_c_suspend_mac_and_wait(wlc_hw->wlc);\n\n\t\tdma_txsuspend(wlc_hw->di[tx_fifo]);\n\n\t\tif (BRCMS_PHY_11N_CAP(wlc_hw->band))\n\t\t\tbrcms_c_enable_mac(wlc_hw->wlc);\n\t}\n}\n\nstatic void brcms_b_tx_fifo_resume(struct brcms_hardware *wlc_hw,\n\t\t\t\t   uint tx_fifo)\n{\n\t \n\t \n\tif (wlc_hw->di[tx_fifo])\n\t\tdma_txresume(wlc_hw->di[tx_fifo]);\n\n\t \n\tif (wlc_hw->suspended_fifos == 0)\n\t\treturn;\n\telse {\n\t\twlc_hw->suspended_fifos &= ~(1 << tx_fifo);\n\t\tif (wlc_hw->suspended_fifos == 0)\n\t\t\tbrcms_c_ucode_wake_override_clear(wlc_hw,\n\t\t\t\t\t\tBRCMS_WAKE_OVERRIDE_TXFIFO);\n\t}\n}\n\n \nstatic void brcms_b_mute(struct brcms_hardware *wlc_hw, bool mute_tx)\n{\n\tstatic const u8 null_ether_addr[ETH_ALEN] = {0, 0, 0, 0, 0, 0};\n\tu8 *ethaddr = wlc_hw->wlc->pub->cur_etheraddr;\n\n\tif (mute_tx) {\n\t\t \n\t\tbrcms_b_tx_fifo_suspend(wlc_hw, TX_DATA_FIFO);\n\t\tbrcms_b_tx_fifo_suspend(wlc_hw, TX_CTL_FIFO);\n\t\tbrcms_b_tx_fifo_suspend(wlc_hw, TX_AC_BK_FIFO);\n\t\tbrcms_b_tx_fifo_suspend(wlc_hw, TX_AC_VI_FIFO);\n\n\t\t \n\t\tbrcms_b_set_addrmatch(wlc_hw, RCM_MAC_OFFSET, null_ether_addr);\n\t} else {\n\t\t \n\t\tbrcms_b_tx_fifo_resume(wlc_hw, TX_DATA_FIFO);\n\t\tbrcms_b_tx_fifo_resume(wlc_hw, TX_CTL_FIFO);\n\t\tbrcms_b_tx_fifo_resume(wlc_hw, TX_AC_BK_FIFO);\n\t\tbrcms_b_tx_fifo_resume(wlc_hw, TX_AC_VI_FIFO);\n\n\t\t \n\t\tbrcms_b_set_addrmatch(wlc_hw, RCM_MAC_OFFSET, ethaddr);\n\t}\n\n\twlc_phy_mute_upd(wlc_hw->band->pi, mute_tx, 0);\n\n\tif (mute_tx)\n\t\tbrcms_c_ucode_mute_override_set(wlc_hw);\n\telse\n\t\tbrcms_c_ucode_mute_override_clear(wlc_hw);\n}\n\nvoid\nbrcms_c_mute(struct brcms_c_info *wlc, bool mute_tx)\n{\n\tbrcms_b_mute(wlc->hw, mute_tx);\n}\n\n \nstatic inline u32 wlc_intstatus(struct brcms_c_info *wlc, bool in_isr)\n{\n\tstruct brcms_hardware *wlc_hw = wlc->hw;\n\tstruct bcma_device *core = wlc_hw->d11core;\n\tu32 macintstatus, mask;\n\n\t \n\tmacintstatus = bcma_read32(core, D11REGOFFS(macintstatus));\n\tmask = in_isr ? wlc->macintmask : wlc->defmacintmask;\n\n\ttrace_brcms_macintstatus(&core->dev, in_isr, macintstatus, mask);\n\n\t \n\tif (brcms_deviceremoved(wlc))\n\t\treturn -1;\n\n\t \n\tif (macintstatus == 0xffffffff)\n\t\treturn 0;\n\n\t \n\tmacintstatus &= mask;\n\n\t \n\tif (macintstatus == 0)\n\t\treturn 0;\n\n\t \n\tbcma_write32(core, D11REGOFFS(macintmask), 0);\n\t(void)bcma_read32(core, D11REGOFFS(macintmask));\n\twlc->macintmask = 0;\n\n\t \n\tbcma_write32(core, D11REGOFFS(macintstatus), macintstatus);\n\n\t \n\tif (macintstatus & MI_DMAINT)\n\t\t \n\t\tbcma_write32(core, D11REGOFFS(intctrlregs[RX_FIFO].intstatus),\n\t\t\t     DEF_RXINTMASK);\n\n\treturn macintstatus;\n}\n\n \n \nbool brcms_c_intrsupd(struct brcms_c_info *wlc)\n{\n\tu32 macintstatus;\n\n\t \n\tmacintstatus = wlc_intstatus(wlc, false);\n\n\t \n\tif (macintstatus == 0xffffffff)\n\t\treturn false;\n\n\t \n\twlc->macintstatus |= macintstatus;\n\n\treturn true;\n}\n\n \nbool brcms_c_isr(struct brcms_c_info *wlc)\n{\n\tstruct brcms_hardware *wlc_hw = wlc->hw;\n\tu32 macintstatus;\n\n\tif (!wlc_hw->up || !wlc->macintmask)\n\t\treturn false;\n\n\t \n\tmacintstatus = wlc_intstatus(wlc, true);\n\n\tif (macintstatus == 0xffffffff) {\n\t\tbrcms_err(wlc_hw->d11core,\n\t\t\t  \"DEVICEREMOVED detected in the ISR code path\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tif (macintstatus == 0)\n\t\treturn false;\n\n\t \n\twlc->macintstatus = macintstatus;\n\n\treturn true;\n\n}\n\nvoid brcms_c_suspend_mac_and_wait(struct brcms_c_info *wlc)\n{\n\tstruct brcms_hardware *wlc_hw = wlc->hw;\n\tstruct bcma_device *core = wlc_hw->d11core;\n\tu32 mc, mi;\n\n\tbrcms_dbg_mac80211(core, \"wl%d: bandunit %d\\n\", wlc_hw->unit,\n\t\t\t   wlc_hw->band->bandunit);\n\n\t \n\twlc_hw->mac_suspend_depth++;\n\tif (wlc_hw->mac_suspend_depth > 1)\n\t\treturn;\n\n\t \n\tbrcms_c_ucode_wake_override_set(wlc_hw, BRCMS_WAKE_OVERRIDE_MACSUSPEND);\n\n\tmc = bcma_read32(core, D11REGOFFS(maccontrol));\n\n\tif (mc == 0xffffffff) {\n\t\tbrcms_err(core, \"wl%d: %s: dead chip\\n\", wlc_hw->unit,\n\t\t\t  __func__);\n\t\tbrcms_down(wlc->wl);\n\t\treturn;\n\t}\n\tWARN_ON(mc & MCTL_PSM_JMP_0);\n\tWARN_ON(!(mc & MCTL_PSM_RUN));\n\tWARN_ON(!(mc & MCTL_EN_MAC));\n\n\tmi = bcma_read32(core, D11REGOFFS(macintstatus));\n\tif (mi == 0xffffffff) {\n\t\tbrcms_err(core, \"wl%d: %s: dead chip\\n\", wlc_hw->unit,\n\t\t\t  __func__);\n\t\tbrcms_down(wlc->wl);\n\t\treturn;\n\t}\n\tWARN_ON(mi & MI_MACSSPNDD);\n\n\tbrcms_b_mctrl(wlc_hw, MCTL_EN_MAC, 0);\n\n\tSPINWAIT(!(bcma_read32(core, D11REGOFFS(macintstatus)) & MI_MACSSPNDD),\n\t\t BRCMS_MAX_MAC_SUSPEND);\n\n\tif (!(bcma_read32(core, D11REGOFFS(macintstatus)) & MI_MACSSPNDD)) {\n\t\tbrcms_err(core, \"wl%d: wlc_suspend_mac_and_wait: waited %d uS\"\n\t\t\t  \" and MI_MACSSPNDD is still not on.\\n\",\n\t\t\t  wlc_hw->unit, BRCMS_MAX_MAC_SUSPEND);\n\t\tbrcms_err(core, \"wl%d: psmdebug 0x%08x, phydebug 0x%08x, \"\n\t\t\t  \"psm_brc 0x%04x\\n\", wlc_hw->unit,\n\t\t\t  bcma_read32(core, D11REGOFFS(psmdebug)),\n\t\t\t  bcma_read32(core, D11REGOFFS(phydebug)),\n\t\t\t  bcma_read16(core, D11REGOFFS(psm_brc)));\n\t}\n\n\tmc = bcma_read32(core, D11REGOFFS(maccontrol));\n\tif (mc == 0xffffffff) {\n\t\tbrcms_err(core, \"wl%d: %s: dead chip\\n\", wlc_hw->unit,\n\t\t\t  __func__);\n\t\tbrcms_down(wlc->wl);\n\t\treturn;\n\t}\n\tWARN_ON(mc & MCTL_PSM_JMP_0);\n\tWARN_ON(!(mc & MCTL_PSM_RUN));\n\tWARN_ON(mc & MCTL_EN_MAC);\n}\n\nvoid brcms_c_enable_mac(struct brcms_c_info *wlc)\n{\n\tstruct brcms_hardware *wlc_hw = wlc->hw;\n\tstruct bcma_device *core = wlc_hw->d11core;\n\tu32 mc, mi;\n\n\tbrcms_dbg_mac80211(core, \"wl%d: bandunit %d\\n\", wlc_hw->unit,\n\t\t\t   wlc->band->bandunit);\n\n\t \n\twlc_hw->mac_suspend_depth--;\n\tif (wlc_hw->mac_suspend_depth > 0)\n\t\treturn;\n\n\tmc = bcma_read32(core, D11REGOFFS(maccontrol));\n\tWARN_ON(mc & MCTL_PSM_JMP_0);\n\tWARN_ON(mc & MCTL_EN_MAC);\n\tWARN_ON(!(mc & MCTL_PSM_RUN));\n\n\tbrcms_b_mctrl(wlc_hw, MCTL_EN_MAC, MCTL_EN_MAC);\n\tbcma_write32(core, D11REGOFFS(macintstatus), MI_MACSSPNDD);\n\n\tmc = bcma_read32(core, D11REGOFFS(maccontrol));\n\tWARN_ON(mc & MCTL_PSM_JMP_0);\n\tWARN_ON(!(mc & MCTL_EN_MAC));\n\tWARN_ON(!(mc & MCTL_PSM_RUN));\n\n\tmi = bcma_read32(core, D11REGOFFS(macintstatus));\n\tWARN_ON(mi & MI_MACSSPNDD);\n\n\tbrcms_c_ucode_wake_override_clear(wlc_hw,\n\t\t\t\t\t  BRCMS_WAKE_OVERRIDE_MACSUSPEND);\n}\n\nvoid brcms_b_band_stf_ss_set(struct brcms_hardware *wlc_hw, u8 stf_mode)\n{\n\twlc_hw->hw_stf_ss_opmode = stf_mode;\n\n\tif (wlc_hw->clk)\n\t\tbrcms_upd_ofdm_pctl1_table(wlc_hw);\n}\n\nstatic bool brcms_b_validate_chip_access(struct brcms_hardware *wlc_hw)\n{\n\tstruct bcma_device *core = wlc_hw->d11core;\n\tu32 w, val;\n\tstruct wiphy *wiphy = wlc_hw->wlc->wiphy;\n\n\t \n\n\tbcma_write32(core, D11REGOFFS(objaddr), OBJADDR_SHM_SEL | 0);\n\t(void)bcma_read32(core, D11REGOFFS(objaddr));\n\tw = bcma_read32(core, D11REGOFFS(objdata));\n\n\t \n\tbcma_write32(core, D11REGOFFS(objaddr), OBJADDR_SHM_SEL | 0);\n\t(void)bcma_read32(core, D11REGOFFS(objaddr));\n\tbcma_write32(core, D11REGOFFS(objdata), (u32) 0xaa5555aa);\n\n\tbcma_write32(core, D11REGOFFS(objaddr), OBJADDR_SHM_SEL | 0);\n\t(void)bcma_read32(core, D11REGOFFS(objaddr));\n\tval = bcma_read32(core, D11REGOFFS(objdata));\n\tif (val != (u32) 0xaa5555aa) {\n\t\twiphy_err(wiphy, \"wl%d: validate_chip_access: SHM = 0x%x, \"\n\t\t\t  \"expected 0xaa5555aa\\n\", wlc_hw->unit, val);\n\t\treturn false;\n\t}\n\n\tbcma_write32(core, D11REGOFFS(objaddr), OBJADDR_SHM_SEL | 0);\n\t(void)bcma_read32(core, D11REGOFFS(objaddr));\n\tbcma_write32(core, D11REGOFFS(objdata), (u32) 0x55aaaa55);\n\n\tbcma_write32(core, D11REGOFFS(objaddr), OBJADDR_SHM_SEL | 0);\n\t(void)bcma_read32(core, D11REGOFFS(objaddr));\n\tval = bcma_read32(core, D11REGOFFS(objdata));\n\tif (val != (u32) 0x55aaaa55) {\n\t\twiphy_err(wiphy, \"wl%d: validate_chip_access: SHM = 0x%x, \"\n\t\t\t  \"expected 0x55aaaa55\\n\", wlc_hw->unit, val);\n\t\treturn false;\n\t}\n\n\tbcma_write32(core, D11REGOFFS(objaddr), OBJADDR_SHM_SEL | 0);\n\t(void)bcma_read32(core, D11REGOFFS(objaddr));\n\tbcma_write32(core, D11REGOFFS(objdata), w);\n\n\t \n\tbcma_write32(core, D11REGOFFS(tsf_cfpstart), 0);\n\n\tw = bcma_read32(core, D11REGOFFS(maccontrol));\n\tif ((w != (MCTL_IHR_EN | MCTL_WAKE)) &&\n\t    (w != (MCTL_IHR_EN | MCTL_GMODE | MCTL_WAKE))) {\n\t\twiphy_err(wiphy, \"wl%d: validate_chip_access: maccontrol = \"\n\t\t\t  \"0x%x, expected 0x%x or 0x%x\\n\", wlc_hw->unit, w,\n\t\t\t  (MCTL_IHR_EN | MCTL_WAKE),\n\t\t\t  (MCTL_IHR_EN | MCTL_GMODE | MCTL_WAKE));\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n#define PHYPLL_WAIT_US\t100000\n\nvoid brcms_b_core_phypll_ctl(struct brcms_hardware *wlc_hw, bool on)\n{\n\tstruct bcma_device *core = wlc_hw->d11core;\n\tu32 tmp;\n\n\tbrcms_dbg_info(core, \"wl%d\\n\", wlc_hw->unit);\n\n\ttmp = 0;\n\n\tif (on) {\n\t\tif ((ai_get_chip_id(wlc_hw->sih) == BCMA_CHIP_ID_BCM4313)) {\n\t\t\tbcma_set32(core, D11REGOFFS(clk_ctl_st),\n\t\t\t\t   CCS_ERSRC_REQ_HT |\n\t\t\t\t   CCS_ERSRC_REQ_D11PLL |\n\t\t\t\t   CCS_ERSRC_REQ_PHYPLL);\n\t\t\tSPINWAIT((bcma_read32(core, D11REGOFFS(clk_ctl_st)) &\n\t\t\t\t  CCS_ERSRC_AVAIL_HT) != CCS_ERSRC_AVAIL_HT,\n\t\t\t\t PHYPLL_WAIT_US);\n\n\t\t\ttmp = bcma_read32(core, D11REGOFFS(clk_ctl_st));\n\t\t\tif ((tmp & CCS_ERSRC_AVAIL_HT) != CCS_ERSRC_AVAIL_HT)\n\t\t\t\tbrcms_err(core, \"%s: turn on PHY PLL failed\\n\",\n\t\t\t\t\t  __func__);\n\t\t} else {\n\t\t\tbcma_set32(core, D11REGOFFS(clk_ctl_st),\n\t\t\t\t   tmp | CCS_ERSRC_REQ_D11PLL |\n\t\t\t\t   CCS_ERSRC_REQ_PHYPLL);\n\t\t\tSPINWAIT((bcma_read32(core, D11REGOFFS(clk_ctl_st)) &\n\t\t\t\t  (CCS_ERSRC_AVAIL_D11PLL |\n\t\t\t\t   CCS_ERSRC_AVAIL_PHYPLL)) !=\n\t\t\t\t (CCS_ERSRC_AVAIL_D11PLL |\n\t\t\t\t  CCS_ERSRC_AVAIL_PHYPLL), PHYPLL_WAIT_US);\n\n\t\t\ttmp = bcma_read32(core, D11REGOFFS(clk_ctl_st));\n\t\t\tif ((tmp &\n\t\t\t     (CCS_ERSRC_AVAIL_D11PLL | CCS_ERSRC_AVAIL_PHYPLL))\n\t\t\t    !=\n\t\t\t    (CCS_ERSRC_AVAIL_D11PLL | CCS_ERSRC_AVAIL_PHYPLL))\n\t\t\t\tbrcms_err(core, \"%s: turn on PHY PLL failed\\n\",\n\t\t\t\t\t  __func__);\n\t\t}\n\t} else {\n\t\t \n\t\tbcma_mask32(core, D11REGOFFS(clk_ctl_st),\n\t\t\t    ~CCS_ERSRC_REQ_PHYPLL);\n\t\t(void)bcma_read32(core, D11REGOFFS(clk_ctl_st));\n\t}\n}\n\nstatic void brcms_c_coredisable(struct brcms_hardware *wlc_hw)\n{\n\tbool dev_gone;\n\n\tbrcms_dbg_info(wlc_hw->d11core, \"wl%d: disable core\\n\", wlc_hw->unit);\n\n\tdev_gone = brcms_deviceremoved(wlc_hw->wlc);\n\n\tif (dev_gone)\n\t\treturn;\n\n\tif (wlc_hw->noreset)\n\t\treturn;\n\n\t \n\twlc_phy_switch_radio(wlc_hw->band->pi, OFF);\n\n\t \n\twlc_phy_anacore(wlc_hw->band->pi, OFF);\n\n\t \n\tbrcms_b_core_phypll_ctl(wlc_hw, false);\n\n\twlc_hw->clk = false;\n\tbcma_core_disable(wlc_hw->d11core, 0);\n\twlc_phy_hw_clk_state_upd(wlc_hw->band->pi, false);\n}\n\nstatic void brcms_c_flushqueues(struct brcms_c_info *wlc)\n{\n\tstruct brcms_hardware *wlc_hw = wlc->hw;\n\tuint i;\n\n\t \n\tfor (i = 0; i < NFIFO; i++) {\n\t\tif (wlc_hw->di[i]) {\n\t\t\tdma_txreclaim(wlc_hw->di[i], DMA_RANGE_ALL);\n\t\t\tif (i < TX_BCMC_FIFO)\n\t\t\t\tieee80211_wake_queue(wlc->pub->ieee_hw,\n\t\t\t\t\t\t     brcms_fifo_to_ac(i));\n\t\t}\n\t}\n\n\t \n\tdma_rxreclaim(wlc_hw->di[RX_FIFO]);\n}\n\nstatic u16\nbrcms_b_read_objmem(struct brcms_hardware *wlc_hw, uint offset, u32 sel)\n{\n\tstruct bcma_device *core = wlc_hw->d11core;\n\tu16 objoff = D11REGOFFS(objdata);\n\n\tbcma_write32(core, D11REGOFFS(objaddr), sel | (offset >> 2));\n\t(void)bcma_read32(core, D11REGOFFS(objaddr));\n\tif (offset & 2)\n\t\tobjoff += 2;\n\n\treturn bcma_read16(core, objoff);\n}\n\nstatic void\nbrcms_b_write_objmem(struct brcms_hardware *wlc_hw, uint offset, u16 v,\n\t\t     u32 sel)\n{\n\tstruct bcma_device *core = wlc_hw->d11core;\n\tu16 objoff = D11REGOFFS(objdata);\n\n\tbcma_write32(core, D11REGOFFS(objaddr), sel | (offset >> 2));\n\t(void)bcma_read32(core, D11REGOFFS(objaddr));\n\tif (offset & 2)\n\t\tobjoff += 2;\n\n\tbcma_wflush16(core, objoff, v);\n}\n\n \nu16 brcms_b_read_shm(struct brcms_hardware *wlc_hw, uint offset)\n{\n\treturn brcms_b_read_objmem(wlc_hw, offset, OBJADDR_SHM_SEL);\n}\n\n \nvoid brcms_b_write_shm(struct brcms_hardware *wlc_hw, uint offset, u16 v)\n{\n\tbrcms_b_write_objmem(wlc_hw, offset, v, OBJADDR_SHM_SEL);\n}\n\n \nvoid\nbrcms_b_copyto_objmem(struct brcms_hardware *wlc_hw, uint offset,\n\t\t      const void *buf, int len, u32 sel)\n{\n\tu16 v;\n\tconst u8 *p = (const u8 *)buf;\n\tint i;\n\n\tif (len <= 0 || (offset & 1) || (len & 1))\n\t\treturn;\n\n\tfor (i = 0; i < len; i += 2) {\n\t\tv = p[i] | (p[i + 1] << 8);\n\t\tbrcms_b_write_objmem(wlc_hw, offset + i, v, sel);\n\t}\n}\n\n \nvoid\nbrcms_b_copyfrom_objmem(struct brcms_hardware *wlc_hw, uint offset, void *buf,\n\t\t\t int len, u32 sel)\n{\n\tu16 v;\n\tu8 *p = (u8 *) buf;\n\tint i;\n\n\tif (len <= 0 || (offset & 1) || (len & 1))\n\t\treturn;\n\n\tfor (i = 0; i < len; i += 2) {\n\t\tv = brcms_b_read_objmem(wlc_hw, offset + i, sel);\n\t\tp[i] = v & 0xFF;\n\t\tp[i + 1] = (v >> 8) & 0xFF;\n\t}\n}\n\n \nstatic void brcms_c_copyto_shm(struct brcms_c_info *wlc, uint offset,\n\t\t\tconst void *buf, int len)\n{\n\tbrcms_b_copyto_objmem(wlc->hw, offset, buf, len, OBJADDR_SHM_SEL);\n}\n\nstatic void brcms_b_retrylimit_upd(struct brcms_hardware *wlc_hw,\n\t\t\t\t   u16 SRL, u16 LRL)\n{\n\twlc_hw->SRL = SRL;\n\twlc_hw->LRL = LRL;\n\n\t \n\tif (wlc_hw->up) {\n\t\tbcma_write32(wlc_hw->d11core, D11REGOFFS(objaddr),\n\t\t\t     OBJADDR_SCR_SEL | S_DOT11_SRC_LMT);\n\t\t(void)bcma_read32(wlc_hw->d11core, D11REGOFFS(objaddr));\n\t\tbcma_write32(wlc_hw->d11core, D11REGOFFS(objdata), wlc_hw->SRL);\n\t\tbcma_write32(wlc_hw->d11core, D11REGOFFS(objaddr),\n\t\t\t     OBJADDR_SCR_SEL | S_DOT11_LRC_LMT);\n\t\t(void)bcma_read32(wlc_hw->d11core, D11REGOFFS(objaddr));\n\t\tbcma_write32(wlc_hw->d11core, D11REGOFFS(objdata), wlc_hw->LRL);\n\t}\n}\n\nstatic void brcms_b_pllreq(struct brcms_hardware *wlc_hw, bool set, u32 req_bit)\n{\n\tif (set) {\n\t\tif (mboolisset(wlc_hw->pllreq, req_bit))\n\t\t\treturn;\n\n\t\tmboolset(wlc_hw->pllreq, req_bit);\n\n\t\tif (mboolisset(wlc_hw->pllreq, BRCMS_PLLREQ_FLIP)) {\n\t\t\tif (!wlc_hw->sbclk)\n\t\t\t\tbrcms_b_xtal(wlc_hw, ON);\n\t\t}\n\t} else {\n\t\tif (!mboolisset(wlc_hw->pllreq, req_bit))\n\t\t\treturn;\n\n\t\tmboolclr(wlc_hw->pllreq, req_bit);\n\n\t\tif (mboolisset(wlc_hw->pllreq, BRCMS_PLLREQ_FLIP)) {\n\t\t\tif (wlc_hw->sbclk)\n\t\t\t\tbrcms_b_xtal(wlc_hw, OFF);\n\t\t}\n\t}\n}\n\nstatic void brcms_b_antsel_set(struct brcms_hardware *wlc_hw, u32 antsel_avail)\n{\n\twlc_hw->antsel_avail = antsel_avail;\n}\n\n \nstatic bool brcms_c_ps_allowed(struct brcms_c_info *wlc)\n{\n\t \n\treturn false;\n}\n\nstatic void brcms_c_statsupd(struct brcms_c_info *wlc)\n{\n\tint i;\n\tstruct macstat *macstats;\n#ifdef DEBUG\n\tu16 delta;\n\tu16 rxf0ovfl;\n\tu16 txfunfl[NFIFO];\n#endif\t\t\t\t \n\n\t \n\tif (!wlc->pub->up)\n\t\treturn;\n\n\tmacstats = wlc->core->macstat_snapshot;\n\n#ifdef DEBUG\n\t \n\trxf0ovfl = macstats->rxf0ovfl;\n\n\t \n\tfor (i = 0; i < NFIFO; i++)\n\t\ttxfunfl[i] = macstats->txfunfl[i];\n#endif\t\t\t\t \n\n\t \n\tbrcms_b_copyfrom_objmem(wlc->hw, M_UCODE_MACSTAT, macstats,\n\t\t\t\tsizeof(*macstats), OBJADDR_SHM_SEL);\n\n#ifdef DEBUG\n\t \n\tdelta = (u16)(macstats->rxf0ovfl - rxf0ovfl);\n\tif (delta)\n\t\tbrcms_err(wlc->hw->d11core, \"wl%d: %u rx fifo 0 overflows!\\n\",\n\t\t\t  wlc->pub->unit, delta);\n\n\t \n\tfor (i = 0; i < NFIFO; i++) {\n\t\tdelta = macstats->txfunfl[i] - txfunfl[i];\n\t\tif (delta)\n\t\t\tbrcms_err(wlc->hw->d11core,\n\t\t\t\t  \"wl%d: %u tx fifo %d underflows!\\n\",\n\t\t\t\t  wlc->pub->unit, delta, i);\n\t}\n#endif\t\t\t\t \n\n\t \n\tfor (i = 0; i < NFIFO; i++) {\n\t\tif (wlc->hw->di[i])\n\t\t\tdma_counterreset(wlc->hw->di[i]);\n\t}\n}\n\nstatic void brcms_b_reset(struct brcms_hardware *wlc_hw)\n{\n\t \n\tif (!brcms_deviceremoved(wlc_hw->wlc))\n\t\tbrcms_b_corereset(wlc_hw, BRCMS_USE_COREFLAGS);\n\n\t \n\tbrcms_c_flushqueues(wlc_hw->wlc);\n}\n\nvoid brcms_c_reset(struct brcms_c_info *wlc)\n{\n\tbrcms_dbg_info(wlc->hw->d11core, \"wl%d\\n\", wlc->pub->unit);\n\n\t \n\tbrcms_c_statsupd(wlc);\n\n\t \n\tmemset(wlc->core->macstat_snapshot, 0, sizeof(struct macstat));\n\n\tbrcms_b_reset(wlc->hw);\n}\n\nvoid brcms_c_init_scb(struct scb *scb)\n{\n\tint i;\n\n\tmemset(scb, 0, sizeof(struct scb));\n\tscb->flags = SCB_WMECAP | SCB_HTCAP;\n\tfor (i = 0; i < NUMPRIO; i++) {\n\t\tscb->seqnum[i] = 0;\n\t}\n\n\tscb->magic = SCB_MAGIC;\n}\n\n \nstatic void brcms_b_coreinit(struct brcms_c_info *wlc)\n{\n\tstruct brcms_hardware *wlc_hw = wlc->hw;\n\tstruct bcma_device *core = wlc_hw->d11core;\n\tu32 bcnint_us;\n\tuint i = 0;\n\tbool fifosz_fixup = false;\n\tint err = 0;\n\tu16 buf[NFIFO];\n\tstruct brcms_ucode *ucode = &wlc_hw->wlc->wl->ucode;\n\n\tbrcms_dbg_info(core, \"wl%d: core init\\n\", wlc_hw->unit);\n\n\t \n\tbrcms_b_mctrl(wlc_hw, ~0, (MCTL_IHR_EN | MCTL_PSM_JMP_0 | MCTL_WAKE));\n\n\tbrcms_ucode_download(wlc_hw);\n\t \n\tfifosz_fixup = true;\n\n\t \n\tbcma_write32(core, D11REGOFFS(macintstatus), -1);\n\tbrcms_b_mctrl(wlc_hw, ~0,\n\t\t       (MCTL_IHR_EN | MCTL_INFRA | MCTL_PSM_RUN | MCTL_WAKE));\n\n\t \n\tSPINWAIT(((bcma_read32(core, D11REGOFFS(macintstatus)) &\n\t\t   MI_MACSSPNDD) == 0), 1000 * 1000);\n\tif ((bcma_read32(core, D11REGOFFS(macintstatus)) & MI_MACSSPNDD) == 0)\n\t\tbrcms_err(core, \"wl%d: wlc_coreinit: ucode did not self-\"\n\t\t\t  \"suspend!\\n\", wlc_hw->unit);\n\n\tbrcms_c_gpio_init(wlc);\n\n\tbcma_aread32(core, BCMA_IOST);\n\n\tif (D11REV_IS(wlc_hw->corerev, 17) || D11REV_IS(wlc_hw->corerev, 23)) {\n\t\tif (BRCMS_ISNPHY(wlc_hw->band))\n\t\t\tbrcms_c_write_inits(wlc_hw, ucode->d11n0initvals16);\n\t\telse\n\t\t\tbrcms_err(core, \"%s: wl%d: unsupported phy in corerev\"\n\t\t\t\t  \" %d\\n\", __func__, wlc_hw->unit,\n\t\t\t\t  wlc_hw->corerev);\n\t} else if (D11REV_IS(wlc_hw->corerev, 24)) {\n\t\tif (BRCMS_ISLCNPHY(wlc_hw->band))\n\t\t\tbrcms_c_write_inits(wlc_hw, ucode->d11lcn0initvals24);\n\t\telse\n\t\t\tbrcms_err(core, \"%s: wl%d: unsupported phy in corerev\"\n\t\t\t\t  \" %d\\n\", __func__, wlc_hw->unit,\n\t\t\t\t  wlc_hw->corerev);\n\t} else {\n\t\tbrcms_err(core, \"%s: wl%d: unsupported corerev %d\\n\",\n\t\t\t  __func__, wlc_hw->unit, wlc_hw->corerev);\n\t}\n\n\t \n\tif (fifosz_fixup)\n\t\tbrcms_b_corerev_fifofixup(wlc_hw);\n\n\t \n\tbuf[TX_AC_BE_FIFO] = brcms_b_read_shm(wlc_hw, M_FIFOSIZE0);\n\tif (buf[TX_AC_BE_FIFO] != wlc_hw->xmtfifo_sz[TX_AC_BE_FIFO]) {\n\t\ti = TX_AC_BE_FIFO;\n\t\terr = -1;\n\t}\n\tbuf[TX_AC_VI_FIFO] = brcms_b_read_shm(wlc_hw, M_FIFOSIZE1);\n\tif (buf[TX_AC_VI_FIFO] != wlc_hw->xmtfifo_sz[TX_AC_VI_FIFO]) {\n\t\ti = TX_AC_VI_FIFO;\n\t\terr = -1;\n\t}\n\tbuf[TX_AC_BK_FIFO] = brcms_b_read_shm(wlc_hw, M_FIFOSIZE2);\n\tbuf[TX_AC_VO_FIFO] = (buf[TX_AC_BK_FIFO] >> 8) & 0xff;\n\tbuf[TX_AC_BK_FIFO] &= 0xff;\n\tif (buf[TX_AC_BK_FIFO] != wlc_hw->xmtfifo_sz[TX_AC_BK_FIFO]) {\n\t\ti = TX_AC_BK_FIFO;\n\t\terr = -1;\n\t}\n\tif (buf[TX_AC_VO_FIFO] != wlc_hw->xmtfifo_sz[TX_AC_VO_FIFO]) {\n\t\ti = TX_AC_VO_FIFO;\n\t\terr = -1;\n\t}\n\tbuf[TX_BCMC_FIFO] = brcms_b_read_shm(wlc_hw, M_FIFOSIZE3);\n\tbuf[TX_ATIM_FIFO] = (buf[TX_BCMC_FIFO] >> 8) & 0xff;\n\tbuf[TX_BCMC_FIFO] &= 0xff;\n\tif (buf[TX_BCMC_FIFO] != wlc_hw->xmtfifo_sz[TX_BCMC_FIFO]) {\n\t\ti = TX_BCMC_FIFO;\n\t\terr = -1;\n\t}\n\tif (buf[TX_ATIM_FIFO] != wlc_hw->xmtfifo_sz[TX_ATIM_FIFO]) {\n\t\ti = TX_ATIM_FIFO;\n\t\terr = -1;\n\t}\n\tif (err != 0)\n\t\tbrcms_err(core, \"wlc_coreinit: txfifo mismatch: ucode size %d\"\n\t\t\t  \" driver size %d index %d\\n\", buf[i],\n\t\t\t  wlc_hw->xmtfifo_sz[i], i);\n\n\t \n\tWARN_ON(bcma_read32(core, D11REGOFFS(maccontrol)) == 0xffffffff);\n\n\t \n\n\t \n\tbrcms_b_write_shm(wlc_hw, M_MBURST_SIZE, MAXTXFRAMEBURST);\n\tbrcms_b_write_shm(wlc_hw, M_MAX_ANTCNT, ANTCNT);\n\n\t \n\tbcma_write32(core, D11REGOFFS(intrcvlazy[0]), (1 << IRL_FC_SHIFT));\n\n\t \n\tbrcms_b_mctrl(wlc_hw,\n\t\t       (MCTL_INFRA | MCTL_DISCARD_PMQ | MCTL_AP),\n\t\t       (MCTL_INFRA | MCTL_DISCARD_PMQ));\n\n\t \n\tbcnint_us = 0x8000 << 10;\n\tbcma_write32(core, D11REGOFFS(tsf_cfprep),\n\t\t     (bcnint_us << CFPREP_CBI_SHIFT));\n\tbcma_write32(core, D11REGOFFS(tsf_cfpstart), bcnint_us);\n\tbcma_write32(core, D11REGOFFS(macintstatus), MI_GP1);\n\n\t \n\tbcma_write32(core, D11REGOFFS(intctrlregs[RX_FIFO].intmask),\n\t\t     DEF_RXINTMASK);\n\n\t \n\tbrcms_b_macphyclk_set(wlc_hw, ON);\n\n\t \n\twlc->fastpwrup_dly = ai_clkctl_fast_pwrup_delay(wlc_hw->sih);\n\tbcma_write16(core, D11REGOFFS(scc_fastpwrup_dly), wlc->fastpwrup_dly);\n\n\t \n\tbrcms_b_write_shm(wlc_hw, M_MACHW_VER, (u16) wlc_hw->corerev);\n\n\t \n\tbrcms_b_write_shm(wlc_hw, M_MACHW_CAP_L,\n\t\t\t   (u16) (wlc_hw->machwcap & 0xffff));\n\tbrcms_b_write_shm(wlc_hw, M_MACHW_CAP_H,\n\t\t\t   (u16) ((wlc_hw->\n\t\t\t\t      machwcap >> 16) & 0xffff));\n\n\t \n\tbcma_write32(core, D11REGOFFS(objaddr),\n\t\t     OBJADDR_SCR_SEL | S_DOT11_SRC_LMT);\n\t(void)bcma_read32(core, D11REGOFFS(objaddr));\n\tbcma_write32(core, D11REGOFFS(objdata), wlc_hw->SRL);\n\tbcma_write32(core, D11REGOFFS(objaddr),\n\t\t     OBJADDR_SCR_SEL | S_DOT11_LRC_LMT);\n\t(void)bcma_read32(core, D11REGOFFS(objaddr));\n\tbcma_write32(core, D11REGOFFS(objdata), wlc_hw->LRL);\n\n\t \n\tbrcms_b_write_shm(wlc_hw, M_SFRMTXCNTFBRTHSD, wlc_hw->SFBL);\n\tbrcms_b_write_shm(wlc_hw, M_LFRMTXCNTFBRTHSD, wlc_hw->LFBL);\n\n\tbcma_mask16(core, D11REGOFFS(ifs_ctl), 0x0FFF);\n\tbcma_write16(core, D11REGOFFS(ifs_aifsn), EDCF_AIFSN_MIN);\n\n\t \n\tfor (i = 0; i < NFIFO; i++) {\n\t\tif (wlc_hw->di[i])\n\t\t\tdma_txinit(wlc_hw->di[i]);\n\t}\n\n\t \n\tdma_rxinit(wlc_hw->di[RX_FIFO]);\n\tdma_rxfill(wlc_hw->di[RX_FIFO]);\n}\n\nstatic void brcms_b_init(struct brcms_hardware *wlc_hw, u16 chanspec)\n{\n\tu32 macintmask;\n\tbool fastclk;\n\tstruct brcms_c_info *wlc = wlc_hw->wlc;\n\n\t \n\tfastclk = wlc_hw->forcefastclk;\n\tif (!fastclk)\n\t\tbrcms_b_clkctl_clk(wlc_hw, BCMA_CLKMODE_FAST);\n\n\t \n\tmacintmask = brcms_intrsoff(wlc->wl);\n\n\t \n\tbrcms_c_setxband(wlc_hw, chspec_bandunit(chanspec));\n\twlc_phy_chanspec_radio_set(wlc_hw->band->pi, chanspec);\n\n\t \n\twlc_phy_cal_init(wlc_hw->band->pi);\n\n\t \n\tbrcms_b_coreinit(wlc);\n\n\t \n\tbrcms_b_bsinit(wlc, chanspec);\n\n\t \n\tbrcms_intrsrestore(wlc->wl, macintmask);\n\n\t \n\tmboolset(wlc_hw->wake_override, BRCMS_WAKE_OVERRIDE_MACSUSPEND);\n\n\t \n\twlc_hw->mac_suspend_depth = 1;\n\n\t \n\tif (!fastclk)\n\t\tbrcms_b_clkctl_clk(wlc_hw, BCMA_CLKMODE_DYNAMIC);\n}\n\nstatic void brcms_c_set_phy_chanspec(struct brcms_c_info *wlc,\n\t\t\t\t     u16 chanspec)\n{\n\t \n\twlc->chanspec = chanspec;\n\n\t \n\tbrcms_c_channel_set_chanspec(wlc->cmi, chanspec, BRCMS_TXPWR_MAX);\n\n\tif (wlc->stf->ss_algosel_auto)\n\t\tbrcms_c_stf_ss_algo_channel_get(wlc, &wlc->stf->ss_algo_channel,\n\t\t\t\t\t    chanspec);\n\n\tbrcms_c_stf_ss_update(wlc, wlc->band);\n}\n\nstatic void\nbrcms_default_rateset(struct brcms_c_info *wlc, struct brcms_c_rateset *rs)\n{\n\tbrcms_c_rateset_default(rs, NULL, wlc->band->phytype,\n\t\twlc->band->bandtype, false, BRCMS_RATE_MASK_FULL,\n\t\t(bool) (wlc->pub->_n_enab & SUPPORT_11N),\n\t\tbrcms_chspec_bw(wlc->default_bss->chanspec),\n\t\twlc->stf->txstreams);\n}\n\n \nstatic void brcms_c_rate_lookup_init(struct brcms_c_info *wlc,\n\t\t\t      struct brcms_c_rateset *rateset)\n{\n\tu8 rate;\n\tu8 mandatory;\n\tu8 cck_basic = 0;\n\tu8 ofdm_basic = 0;\n\tu8 *br = wlc->band->basic_rate;\n\tuint i;\n\n\t \n\tmemset(br, 0, BRCM_MAXRATE + 1);\n\n\t \n\tfor (i = 0; i < rateset->count; i++) {\n\t\t \n\t\tif (!(rateset->rates[i] & BRCMS_RATE_FLAG))\n\t\t\tcontinue;\n\n\t\t \n\t\trate = (rateset->rates[i] & BRCMS_RATE_MASK);\n\n\t\tif (rate > BRCM_MAXRATE) {\n\t\t\tbrcms_err(wlc->hw->d11core, \"brcms_c_rate_lookup_init: \"\n\t\t\t\t  \"invalid rate 0x%X in rate set\\n\",\n\t\t\t\t  rateset->rates[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbr[rate] = rate;\n\t}\n\n\t \n\n\tfor (i = 0; i < wlc->band->hw_rateset.count; i++) {\n\t\trate = wlc->band->hw_rateset.rates[i];\n\n\t\tif (br[rate] != 0) {\n\t\t\t \n\t\t\tif (is_ofdm_rate(rate))\n\t\t\t\tofdm_basic = rate;\n\t\t\telse\n\t\t\t\tcck_basic = rate;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\n\t\tbr[rate] = is_ofdm_rate(rate) ? ofdm_basic : cck_basic;\n\n\t\tif (br[rate] != 0)\n\t\t\tcontinue;\n\n\t\tif (is_ofdm_rate(rate)) {\n\t\t\t \n\t\t\tif (rate >= BRCM_RATE_24M)\n\t\t\t\tmandatory = BRCM_RATE_24M;\n\t\t\telse if (rate >= BRCM_RATE_12M)\n\t\t\t\tmandatory = BRCM_RATE_12M;\n\t\t\telse\n\t\t\t\tmandatory = BRCM_RATE_6M;\n\t\t} else {\n\t\t\t \n\t\t\tmandatory = rate;\n\t\t}\n\n\t\tbr[rate] = mandatory;\n\t}\n}\n\nstatic void brcms_c_bandinit_ordered(struct brcms_c_info *wlc,\n\t\t\t\t     u16 chanspec)\n{\n\tstruct brcms_c_rateset default_rateset;\n\tuint parkband;\n\tuint i, band_order[2];\n\n\t \n\tif (wlc->bandlocked || wlc->pub->_nbands == 1) {\n\t\t \n\t\tparkband = wlc->band->bandunit;\n\t\tband_order[0] = band_order[1] = parkband;\n\t} else {\n\t\t \n\t\tparkband = chspec_bandunit(chanspec);\n\n\t\t \n\t\tband_order[0] = parkband ^ 1;\n\t\tband_order[1] = parkband;\n\t}\n\n\t \n\tfor (i = 0; i < wlc->pub->_nbands; i++) {\n\t\tuint j = band_order[i];\n\n\t\twlc->band = wlc->bandstate[j];\n\n\t\tbrcms_default_rateset(wlc, &default_rateset);\n\n\t\t \n\t\tbrcms_c_rateset_filter(&default_rateset, &wlc->band->hw_rateset,\n\t\t\t\t   false, BRCMS_RATES_CCK_OFDM, BRCMS_RATE_MASK,\n\t\t\t\t   (bool) (wlc->pub->_n_enab & SUPPORT_11N));\n\n\t\t \n\t\tbrcms_c_rate_lookup_init(wlc, &default_rateset);\n\t}\n\n\t \n\tbrcms_c_set_phy_chanspec(wlc, chanspec);\n}\n\n \nvoid brcms_c_mac_promisc(struct brcms_c_info *wlc, uint filter_flags)\n{\n\tu32 promisc_bits = 0;\n\n\twlc->filter_flags = filter_flags;\n\n\tif (filter_flags & FIF_OTHER_BSS)\n\t\tpromisc_bits |= MCTL_PROMISC;\n\n\tif (filter_flags & FIF_BCN_PRBRESP_PROMISC)\n\t\tpromisc_bits |= MCTL_BCNS_PROMISC;\n\n\tif (filter_flags & FIF_FCSFAIL)\n\t\tpromisc_bits |= MCTL_KEEPBADFCS;\n\n\tif (filter_flags & (FIF_CONTROL | FIF_PSPOLL))\n\t\tpromisc_bits |= MCTL_KEEPCONTROL;\n\n\tbrcms_b_mctrl(wlc->hw,\n\t\tMCTL_PROMISC | MCTL_BCNS_PROMISC |\n\t\tMCTL_KEEPCONTROL | MCTL_KEEPBADFCS,\n\t\tpromisc_bits);\n}\n\n \nstatic void brcms_c_ucode_mac_upd(struct brcms_c_info *wlc)\n{\n\t \n\tif (wlc->home_chanspec == wlc_phy_chanspec_get(wlc->band->pi)) {\n\t\tif (wlc->pub->associated) {\n\t\t\t \n\t\t\tif (BRCMS_PHY_11N_CAP(wlc->band))\n\t\t\t\tbrcms_b_write_shm(wlc->hw,\n\t\t\t\t\t\tM_BCN_TXTSF_OFFSET, 0);\n\t\t}\n\t} else {\n\t\t \n\t}\n}\n\nstatic void brcms_c_write_rate_shm(struct brcms_c_info *wlc, u8 rate,\n\t\t\t\t   u8 basic_rate)\n{\n\tu8 phy_rate, index;\n\tu8 basic_phy_rate, basic_index;\n\tu16 dir_table, basic_table;\n\tu16 basic_ptr;\n\n\t \n\tdir_table = is_ofdm_rate(basic_rate) ? M_RT_DIRMAP_A : M_RT_DIRMAP_B;\n\n\t \n\tbasic_table = is_ofdm_rate(rate) ? M_RT_BBRSMAP_A : M_RT_BBRSMAP_B;\n\n\t \n\tphy_rate = rate_info[rate] & BRCMS_RATE_MASK;\n\tbasic_phy_rate = rate_info[basic_rate] & BRCMS_RATE_MASK;\n\tindex = phy_rate & 0xf;\n\tbasic_index = basic_phy_rate & 0xf;\n\n\t \n\tbasic_ptr = brcms_b_read_shm(wlc->hw, (dir_table + basic_index * 2));\n\n\t \n\tbrcms_b_write_shm(wlc->hw, (basic_table + index * 2), basic_ptr);\n}\n\nstatic const struct brcms_c_rateset *\nbrcms_c_rateset_get_hwrs(struct brcms_c_info *wlc)\n{\n\tconst struct brcms_c_rateset *rs_dflt;\n\n\tif (BRCMS_PHY_11N_CAP(wlc->band)) {\n\t\tif (wlc->band->bandtype == BRCM_BAND_5G)\n\t\t\trs_dflt = &ofdm_mimo_rates;\n\t\telse\n\t\t\trs_dflt = &cck_ofdm_mimo_rates;\n\t} else if (wlc->band->gmode)\n\t\trs_dflt = &cck_ofdm_rates;\n\telse\n\t\trs_dflt = &cck_rates;\n\n\treturn rs_dflt;\n}\n\nstatic void brcms_c_set_ratetable(struct brcms_c_info *wlc)\n{\n\tconst struct brcms_c_rateset *rs_dflt;\n\tstruct brcms_c_rateset rs;\n\tu8 rate, basic_rate;\n\tuint i;\n\n\trs_dflt = brcms_c_rateset_get_hwrs(wlc);\n\n\tbrcms_c_rateset_copy(rs_dflt, &rs);\n\tbrcms_c_rateset_mcs_upd(&rs, wlc->stf->txstreams);\n\n\t \n\tfor (i = 0; i < rs.count; i++) {\n\t\trate = rs.rates[i] & BRCMS_RATE_MASK;\n\n\t\t \n\t\tbasic_rate = brcms_basic_rate(wlc, rate);\n\t\tif (basic_rate == 0)\n\t\t\t \n\t\t\tbasic_rate = rs.rates[0] & BRCMS_RATE_MASK;\n\n\t\tbrcms_c_write_rate_shm(wlc, rate, basic_rate);\n\t}\n}\n\n \nstatic void brcms_c_bsinit(struct brcms_c_info *wlc)\n{\n\tbrcms_dbg_info(wlc->hw->d11core, \"wl%d: bandunit %d\\n\",\n\t\t       wlc->pub->unit, wlc->band->bandunit);\n\n\t \n\tbrcms_c_set_ratetable(wlc);\n\n\t \n\tbrcms_c_ucode_mac_upd(wlc);\n\n\t \n\tbrcms_c_antsel_init(wlc->asi);\n\n}\n\n \nstatic int\nbrcms_c_duty_cycle_set(struct brcms_c_info *wlc, int duty_cycle, bool isOFDM,\n\t\t   bool writeToShm)\n{\n\tint idle_busy_ratio_x_16 = 0;\n\tuint offset =\n\t    isOFDM ? M_TX_IDLE_BUSY_RATIO_X_16_OFDM :\n\t    M_TX_IDLE_BUSY_RATIO_X_16_CCK;\n\tif (duty_cycle > 100 || duty_cycle < 0) {\n\t\tbrcms_err(wlc->hw->d11core,\n\t\t\t  \"wl%d:  duty cycle value off limit\\n\",\n\t\t\t  wlc->pub->unit);\n\t\treturn -EINVAL;\n\t}\n\tif (duty_cycle)\n\t\tidle_busy_ratio_x_16 = (100 - duty_cycle) * 16 / duty_cycle;\n\t \n\tif (writeToShm)\n\t\tbrcms_b_write_shm(wlc->hw, offset, (u16) idle_busy_ratio_x_16);\n\n\tif (isOFDM)\n\t\twlc->tx_duty_cycle_ofdm = (u16) duty_cycle;\n\telse\n\t\twlc->tx_duty_cycle_cck = (u16) duty_cycle;\n\n\treturn 0;\n}\n\n \nstatic void brcms_c_set_ps_ctrl(struct brcms_c_info *wlc)\n{\n\tu32 v1, v2;\n\tbool hps;\n\tbool awake_before;\n\n\thps = brcms_c_ps_allowed(wlc);\n\n\tbrcms_dbg_mac80211(wlc->hw->d11core, \"wl%d: hps %d\\n\", wlc->pub->unit,\n\t\t\t   hps);\n\n\tv1 = bcma_read32(wlc->hw->d11core, D11REGOFFS(maccontrol));\n\tv2 = MCTL_WAKE;\n\tif (hps)\n\t\tv2 |= MCTL_HPS;\n\n\tbrcms_b_mctrl(wlc->hw, MCTL_WAKE | MCTL_HPS, v2);\n\n\tawake_before = ((v1 & MCTL_WAKE) || ((v1 & MCTL_HPS) == 0));\n\n\tif (!awake_before)\n\t\tbrcms_b_wait_for_wake(wlc->hw);\n}\n\n \nstatic void brcms_c_set_mac(struct brcms_bss_cfg *bsscfg)\n{\n\tstruct brcms_c_info *wlc = bsscfg->wlc;\n\n\t \n\tbrcms_c_set_addrmatch(wlc, RCM_MAC_OFFSET, wlc->pub->cur_etheraddr);\n\n\tbrcms_c_ampdu_macaddr_upd(wlc);\n}\n\n \nstatic void brcms_c_set_bssid(struct brcms_bss_cfg *bsscfg)\n{\n\t \n\tbrcms_c_set_addrmatch(bsscfg->wlc, RCM_BSSID_OFFSET, bsscfg->BSSID);\n}\n\nvoid brcms_c_set_ssid(struct brcms_c_info *wlc, u8 *ssid, size_t ssid_len)\n{\n\tu8 len = min_t(u8, sizeof(wlc->bsscfg->SSID), ssid_len);\n\tmemset(wlc->bsscfg->SSID, 0, sizeof(wlc->bsscfg->SSID));\n\n\tmemcpy(wlc->bsscfg->SSID, ssid, len);\n\twlc->bsscfg->SSID_len = len;\n}\n\nstatic void brcms_b_set_shortslot(struct brcms_hardware *wlc_hw, bool shortslot)\n{\n\twlc_hw->shortslot = shortslot;\n\n\tif (wlc_hw->band->bandtype == BRCM_BAND_2G && wlc_hw->up) {\n\t\tbrcms_c_suspend_mac_and_wait(wlc_hw->wlc);\n\t\tbrcms_b_update_slot_timing(wlc_hw, shortslot);\n\t\tbrcms_c_enable_mac(wlc_hw->wlc);\n\t}\n}\n\n \nstatic void brcms_c_switch_shortslot(struct brcms_c_info *wlc, bool shortslot)\n{\n\t \n\tif (wlc->shortslot_override != BRCMS_SHORTSLOT_AUTO)\n\t\tshortslot = (wlc->shortslot_override == BRCMS_SHORTSLOT_ON);\n\n\tif (wlc->shortslot == shortslot)\n\t\treturn;\n\n\twlc->shortslot = shortslot;\n\n\tbrcms_b_set_shortslot(wlc->hw, shortslot);\n}\n\nstatic void brcms_c_set_home_chanspec(struct brcms_c_info *wlc, u16 chanspec)\n{\n\tif (wlc->home_chanspec != chanspec) {\n\t\twlc->home_chanspec = chanspec;\n\n\t\tif (wlc->pub->associated)\n\t\t\twlc->bsscfg->current_bss->chanspec = chanspec;\n\t}\n}\n\nvoid\nbrcms_b_set_chanspec(struct brcms_hardware *wlc_hw, u16 chanspec,\n\t\t      bool mute_tx, struct txpwr_limits *txpwr)\n{\n\tuint bandunit;\n\n\tbrcms_dbg_mac80211(wlc_hw->d11core, \"wl%d: 0x%x\\n\", wlc_hw->unit,\n\t\t\t   chanspec);\n\n\twlc_hw->chanspec = chanspec;\n\n\t \n\tif (wlc_hw->_nbands > 1) {\n\t\tbandunit = chspec_bandunit(chanspec);\n\t\tif (wlc_hw->band->bandunit != bandunit) {\n\t\t\t \n\t\t\tif (wlc_hw->up) {\n\t\t\t\twlc_phy_chanspec_radio_set(wlc_hw->\n\t\t\t\t\t\t\t   bandstate[bandunit]->\n\t\t\t\t\t\t\t   pi, chanspec);\n\t\t\t\tbrcms_b_setband(wlc_hw, bandunit, chanspec);\n\t\t\t} else {\n\t\t\t\tbrcms_c_setxband(wlc_hw, bandunit);\n\t\t\t}\n\t\t}\n\t}\n\n\twlc_phy_initcal_enable(wlc_hw->band->pi, !mute_tx);\n\n\tif (!wlc_hw->up) {\n\t\tif (wlc_hw->clk)\n\t\t\twlc_phy_txpower_limit_set(wlc_hw->band->pi, txpwr,\n\t\t\t\t\t\t  chanspec);\n\t\twlc_phy_chanspec_radio_set(wlc_hw->band->pi, chanspec);\n\t} else {\n\t\twlc_phy_chanspec_set(wlc_hw->band->pi, chanspec);\n\t\twlc_phy_txpower_limit_set(wlc_hw->band->pi, txpwr, chanspec);\n\n\t\t \n\t\tbrcms_b_mute(wlc_hw, mute_tx);\n\t}\n}\n\n \nstatic void brcms_c_setband(struct brcms_c_info *wlc,\n\t\t\t\t\t   uint bandunit)\n{\n\twlc->band = wlc->bandstate[bandunit];\n\n\tif (!wlc->pub->up)\n\t\treturn;\n\n\t \n\tbrcms_c_set_ps_ctrl(wlc);\n\n\t \n\tbrcms_c_bsinit(wlc);\n}\n\nstatic void brcms_c_set_chanspec(struct brcms_c_info *wlc, u16 chanspec)\n{\n\tuint bandunit;\n\tu16 old_chanspec = wlc->chanspec;\n\n\tif (!brcms_c_valid_chanspec_db(wlc->cmi, chanspec)) {\n\t\tbrcms_err(wlc->hw->d11core, \"wl%d: %s: Bad channel %d\\n\",\n\t\t\t  wlc->pub->unit, __func__, CHSPEC_CHANNEL(chanspec));\n\t\treturn;\n\t}\n\n\t \n\tif (wlc->pub->_nbands > 1) {\n\t\tbandunit = chspec_bandunit(chanspec);\n\t\tif (wlc->band->bandunit != bandunit || wlc->bandinit_pending) {\n\t\t\tif (wlc->bandlocked) {\n\t\t\t\tbrcms_err(wlc->hw->d11core,\n\t\t\t\t\t  \"wl%d: %s: chspec %d band is locked!\\n\",\n\t\t\t\t\t  wlc->pub->unit, __func__,\n\t\t\t\t\t  CHSPEC_CHANNEL(chanspec));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t \n\t\t\tbrcms_c_setband(wlc, bandunit);\n\t\t}\n\t}\n\n\t \n\tbrcms_c_set_phy_chanspec(wlc, chanspec);\n\n\t \n\tif (brcms_chspec_bw(old_chanspec) != brcms_chspec_bw(chanspec)) {\n\t\tbrcms_c_antsel_init(wlc->asi);\n\n\t\t \n\t\tbrcms_c_rateset_bw_mcs_filter(&wlc->band->hw_rateset,\n\t\t\twlc->band->mimo_cap_40 ? brcms_chspec_bw(chanspec) : 0);\n\t}\n\n\t \n\tbrcms_c_ucode_mac_upd(wlc);\n}\n\n \nvoid brcms_c_beacon_phytxctl_txant_upd(struct brcms_c_info *wlc,\n\t\t\t\t       u32 bcn_rspec)\n{\n\tu16 phyctl;\n\tu16 phytxant = wlc->stf->phytxant;\n\tu16 mask = PHY_TXC_ANT_MASK;\n\n\t \n\tif (BRCMS_PHY_11N_CAP(wlc->band))\n\t\tphytxant = brcms_c_stf_phytxchain_sel(wlc, bcn_rspec);\n\n\tphyctl = brcms_b_read_shm(wlc->hw, M_BCN_PCTLWD);\n\tphyctl = (phyctl & ~mask) | phytxant;\n\tbrcms_b_write_shm(wlc->hw, M_BCN_PCTLWD, phyctl);\n}\n\n \nvoid brcms_c_protection_upd(struct brcms_c_info *wlc, uint idx, int val)\n{\n\t \n\tBCMMSG(wlc->wiphy, \"idx %d, val %d\\n\", idx, val);\n\n\tswitch (idx) {\n\tcase BRCMS_PROT_G_SPEC:\n\t\twlc->protection->_g = (bool) val;\n\t\tbreak;\n\tcase BRCMS_PROT_G_OVR:\n\t\twlc->protection->g_override = (s8) val;\n\t\tbreak;\n\tcase BRCMS_PROT_G_USER:\n\t\twlc->protection->gmode_user = (u8) val;\n\t\tbreak;\n\tcase BRCMS_PROT_OVERLAP:\n\t\twlc->protection->overlap = (s8) val;\n\t\tbreak;\n\tcase BRCMS_PROT_N_USER:\n\t\twlc->protection->nmode_user = (s8) val;\n\t\tbreak;\n\tcase BRCMS_PROT_N_CFG:\n\t\twlc->protection->n_cfg = (s8) val;\n\t\tbreak;\n\tcase BRCMS_PROT_N_CFG_OVR:\n\t\twlc->protection->n_cfg_override = (s8) val;\n\t\tbreak;\n\tcase BRCMS_PROT_N_NONGF:\n\t\twlc->protection->nongf = (bool) val;\n\t\tbreak;\n\tcase BRCMS_PROT_N_NONGF_OVR:\n\t\twlc->protection->nongf_override = (s8) val;\n\t\tbreak;\n\tcase BRCMS_PROT_N_PAM_OVR:\n\t\twlc->protection->n_pam_override = (s8) val;\n\t\tbreak;\n\tcase BRCMS_PROT_N_OBSS:\n\t\twlc->protection->n_obss = (bool) val;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n}\n\nstatic void brcms_c_ht_update_sgi_rx(struct brcms_c_info *wlc, int val)\n{\n\tif (wlc->pub->up) {\n\t\tbrcms_c_update_beacon(wlc);\n\t\tbrcms_c_update_probe_resp(wlc, true);\n\t}\n}\n\nstatic void brcms_c_ht_update_ldpc(struct brcms_c_info *wlc, s8 val)\n{\n\twlc->stf->ldpc = val;\n\n\tif (wlc->pub->up) {\n\t\tbrcms_c_update_beacon(wlc);\n\t\tbrcms_c_update_probe_resp(wlc, true);\n\t\twlc_phy_ldpc_override_set(wlc->band->pi, (val ? true : false));\n\t}\n}\n\nvoid brcms_c_wme_setparams(struct brcms_c_info *wlc, u16 aci,\n\t\t       const struct ieee80211_tx_queue_params *params,\n\t\t       bool suspend)\n{\n\tint i;\n\tstruct shm_acparams acp_shm;\n\tu16 *shm_entry;\n\n\t \n\tif (!wlc->clk) {\n\t\tbrcms_err(wlc->hw->d11core, \"wl%d: %s : no-clock\\n\",\n\t\t\t  wlc->pub->unit, __func__);\n\t\treturn;\n\t}\n\n\tmemset(&acp_shm, 0, sizeof(struct shm_acparams));\n\t \n\tacp_shm.txop = params->txop;\n\t \n\twlc->edcf_txop[aci & 0x3] = acp_shm.txop =\n\t    EDCF_TXOP2USEC(acp_shm.txop);\n\tacp_shm.aifs = (params->aifs & EDCF_AIFSN_MASK);\n\n\tif (aci == IEEE80211_AC_VI && acp_shm.txop == 0\n\t    && acp_shm.aifs < EDCF_AIFSN_MAX)\n\t\tacp_shm.aifs++;\n\n\tif (acp_shm.aifs < EDCF_AIFSN_MIN\n\t    || acp_shm.aifs > EDCF_AIFSN_MAX) {\n\t\tbrcms_err(wlc->hw->d11core, \"wl%d: edcf_setparams: bad \"\n\t\t\t  \"aifs %d\\n\", wlc->pub->unit, acp_shm.aifs);\n\t} else {\n\t\tacp_shm.cwmin = params->cw_min;\n\t\tacp_shm.cwmax = params->cw_max;\n\t\tacp_shm.cwcur = acp_shm.cwmin;\n\t\tacp_shm.bslots =\n\t\t\tbcma_read16(wlc->hw->d11core, D11REGOFFS(tsf_random)) &\n\t\t\tacp_shm.cwcur;\n\t\tacp_shm.reggap = acp_shm.bslots + acp_shm.aifs;\n\t\t \n\t\tacp_shm.status = brcms_b_read_shm(wlc->hw, (M_EDCF_QINFO +\n\t\t\t\t\t\t  wme_ac2fifo[aci] *\n\t\t\t\t\t\t  M_EDCF_QLEN +\n\t\t\t\t\t\t  M_EDCF_STATUS_OFF));\n\t\tacp_shm.status |= WME_STATUS_NEWAC;\n\n\t\t \n\t\tshm_entry = (u16 *) &acp_shm;\n\t\tfor (i = 0; i < (int)sizeof(struct shm_acparams); i += 2)\n\t\t\tbrcms_b_write_shm(wlc->hw,\n\t\t\t\t\t  M_EDCF_QINFO +\n\t\t\t\t\t  wme_ac2fifo[aci] * M_EDCF_QLEN + i,\n\t\t\t\t\t  *shm_entry++);\n\t}\n\n\tif (suspend)\n\t\tbrcms_c_suspend_mac_and_wait(wlc);\n\n\tbrcms_c_update_beacon(wlc);\n\tbrcms_c_update_probe_resp(wlc, false);\n\n\tif (suspend)\n\t\tbrcms_c_enable_mac(wlc);\n}\n\nstatic void brcms_c_edcf_setparams(struct brcms_c_info *wlc, bool suspend)\n{\n\tu16 aci;\n\tint i_ac;\n\tstruct ieee80211_tx_queue_params txq_pars;\n\tstatic const struct edcf_acparam default_edcf_acparams[] = {\n\t\t {EDCF_AC_BE_ACI_STA, EDCF_AC_BE_ECW_STA, EDCF_AC_BE_TXOP_STA},\n\t\t {EDCF_AC_BK_ACI_STA, EDCF_AC_BK_ECW_STA, EDCF_AC_BK_TXOP_STA},\n\t\t {EDCF_AC_VI_ACI_STA, EDCF_AC_VI_ECW_STA, EDCF_AC_VI_TXOP_STA},\n\t\t {EDCF_AC_VO_ACI_STA, EDCF_AC_VO_ECW_STA, EDCF_AC_VO_TXOP_STA}\n\t};  \n\tconst struct edcf_acparam *edcf_acp = &default_edcf_acparams[0];\n\n\tfor (i_ac = 0; i_ac < IEEE80211_NUM_ACS; i_ac++, edcf_acp++) {\n\t\t \n\t\taci = (edcf_acp->ACI & EDCF_ACI_MASK) >> EDCF_ACI_SHIFT;\n\n\t\t \n\t\ttxq_pars.txop = edcf_acp->TXOP;\n\t\ttxq_pars.aifs = edcf_acp->ACI;\n\n\t\t \n\t\ttxq_pars.cw_min = EDCF_ECW2CW(edcf_acp->ECW & EDCF_ECWMIN_MASK);\n\t\t \n\t\ttxq_pars.cw_max = EDCF_ECW2CW((edcf_acp->ECW & EDCF_ECWMAX_MASK)\n\t\t\t\t\t    >> EDCF_ECWMAX_SHIFT);\n\t\tbrcms_c_wme_setparams(wlc, aci, &txq_pars, suspend);\n\t}\n\n\tif (suspend) {\n\t\tbrcms_c_suspend_mac_and_wait(wlc);\n\t\tbrcms_c_enable_mac(wlc);\n\t}\n}\n\nstatic void brcms_c_radio_monitor_start(struct brcms_c_info *wlc)\n{\n\t \n\tif (wlc->radio_monitor)\n\t\treturn;\n\n\twlc->radio_monitor = true;\n\tbrcms_b_pllreq(wlc->hw, true, BRCMS_PLLREQ_RADIO_MON);\n\tbrcms_add_timer(wlc->radio_timer, TIMER_INTERVAL_RADIOCHK, true);\n}\n\nstatic bool brcms_c_radio_monitor_stop(struct brcms_c_info *wlc)\n{\n\tif (!wlc->radio_monitor)\n\t\treturn true;\n\n\twlc->radio_monitor = false;\n\tbrcms_b_pllreq(wlc->hw, false, BRCMS_PLLREQ_RADIO_MON);\n\treturn brcms_del_timer(wlc->radio_timer);\n}\n\n \nstatic void brcms_c_radio_hwdisable_upd(struct brcms_c_info *wlc)\n{\n\tif (wlc->pub->hw_off)\n\t\treturn;\n\n\tif (brcms_b_radio_read_hwdisabled(wlc->hw))\n\t\tmboolset(wlc->pub->radio_disabled, WL_RADIO_HW_DISABLE);\n\telse\n\t\tmboolclr(wlc->pub->radio_disabled, WL_RADIO_HW_DISABLE);\n}\n\n \nbool brcms_c_check_radio_disabled(struct brcms_c_info *wlc)\n{\n\tbrcms_c_radio_hwdisable_upd(wlc);\n\n\treturn mboolisset(wlc->pub->radio_disabled, WL_RADIO_HW_DISABLE) ?\n\t\t\ttrue : false;\n}\n\n \nstatic void brcms_c_radio_timer(void *arg)\n{\n\tstruct brcms_c_info *wlc = (struct brcms_c_info *) arg;\n\n\tif (brcms_deviceremoved(wlc)) {\n\t\tbrcms_err(wlc->hw->d11core, \"wl%d: %s: dead chip\\n\",\n\t\t\t  wlc->pub->unit, __func__);\n\t\tbrcms_down(wlc->wl);\n\t\treturn;\n\t}\n\n\tbrcms_c_radio_hwdisable_upd(wlc);\n}\n\n \nstatic void brcms_b_watchdog(struct brcms_c_info *wlc)\n{\n\tstruct brcms_hardware *wlc_hw = wlc->hw;\n\n\tif (!wlc_hw->up)\n\t\treturn;\n\n\t \n\twlc_hw->now++;\n\n\t \n\tbrcms_b_fifoerrors(wlc_hw);\n\n\t \n\tdma_rxfill(wlc->hw->di[RX_FIFO]);\n\n\twlc_phy_watchdog(wlc_hw->band->pi);\n}\n\n \nstatic void brcms_c_watchdog(struct brcms_c_info *wlc)\n{\n\tbrcms_dbg_info(wlc->hw->d11core, \"wl%d\\n\", wlc->pub->unit);\n\n\tif (!wlc->pub->up)\n\t\treturn;\n\n\tif (brcms_deviceremoved(wlc)) {\n\t\tbrcms_err(wlc->hw->d11core, \"wl%d: %s: dead chip\\n\",\n\t\t\t  wlc->pub->unit, __func__);\n\t\tbrcms_down(wlc->wl);\n\t\treturn;\n\t}\n\n\t \n\twlc->pub->now++;\n\n\tbrcms_c_radio_hwdisable_upd(wlc);\n\t \n\tif (wlc->pub->radio_disabled)\n\t\treturn;\n\n\tbrcms_b_watchdog(wlc);\n\n\t \n\tif ((wlc->pub->now % SW_TIMER_MAC_STAT_UPD) == 0)\n\t\tbrcms_c_statsupd(wlc);\n\n\tif (BRCMS_ISNPHY(wlc->band) &&\n\t    ((wlc->pub->now - wlc->tempsense_lasttime) >=\n\t     BRCMS_TEMPSENSE_PERIOD)) {\n\t\twlc->tempsense_lasttime = wlc->pub->now;\n\t\tbrcms_c_tempsense_upd(wlc);\n\t}\n}\n\nstatic void brcms_c_watchdog_by_timer(void *arg)\n{\n\tstruct brcms_c_info *wlc = (struct brcms_c_info *) arg;\n\n\tbrcms_c_watchdog(wlc);\n}\n\nstatic bool brcms_c_timers_init(struct brcms_c_info *wlc, int unit)\n{\n\twlc->wdtimer = brcms_init_timer(wlc->wl, brcms_c_watchdog_by_timer,\n\t\twlc, \"watchdog\");\n\tif (!wlc->wdtimer) {\n\t\twiphy_err(wlc->wiphy, \"wl%d:  wl_init_timer for wdtimer \"\n\t\t\t  \"failed\\n\", unit);\n\t\tgoto fail;\n\t}\n\n\twlc->radio_timer = brcms_init_timer(wlc->wl, brcms_c_radio_timer,\n\t\twlc, \"radio\");\n\tif (!wlc->radio_timer) {\n\t\twiphy_err(wlc->wiphy, \"wl%d:  wl_init_timer for radio_timer \"\n\t\t\t  \"failed\\n\", unit);\n\t\tgoto fail;\n\t}\n\n\treturn true;\n\n fail:\n\treturn false;\n}\n\n \nstatic void brcms_c_info_init(struct brcms_c_info *wlc, int unit)\n{\n\tint i;\n\n\t \n\twlc->chanspec = ch20mhz_chspec(1);\n\n\t \n\twlc->shortslot = false;\n\twlc->shortslot_override = BRCMS_SHORTSLOT_AUTO;\n\n\tbrcms_c_protection_upd(wlc, BRCMS_PROT_G_OVR, BRCMS_PROTECTION_AUTO);\n\tbrcms_c_protection_upd(wlc, BRCMS_PROT_G_SPEC, false);\n\n\tbrcms_c_protection_upd(wlc, BRCMS_PROT_N_CFG_OVR,\n\t\t\t       BRCMS_PROTECTION_AUTO);\n\tbrcms_c_protection_upd(wlc, BRCMS_PROT_N_CFG, BRCMS_N_PROTECTION_OFF);\n\tbrcms_c_protection_upd(wlc, BRCMS_PROT_N_NONGF_OVR,\n\t\t\t       BRCMS_PROTECTION_AUTO);\n\tbrcms_c_protection_upd(wlc, BRCMS_PROT_N_NONGF, false);\n\tbrcms_c_protection_upd(wlc, BRCMS_PROT_N_PAM_OVR, AUTO);\n\n\tbrcms_c_protection_upd(wlc, BRCMS_PROT_OVERLAP,\n\t\t\t       BRCMS_PROTECTION_CTL_OVERLAP);\n\n\t \n\twlc->include_legacy_erp = true;\n\n\twlc->stf->ant_rx_ovr = ANT_RX_DIV_DEF;\n\twlc->stf->txant = ANT_TX_DEF;\n\n\twlc->prb_resp_timeout = BRCMS_PRB_RESP_TIMEOUT;\n\n\twlc->usr_fragthresh = DOT11_DEFAULT_FRAG_LEN;\n\tfor (i = 0; i < NFIFO; i++)\n\t\twlc->fragthresh[i] = DOT11_DEFAULT_FRAG_LEN;\n\twlc->RTSThresh = DOT11_DEFAULT_RTS_LEN;\n\n\t \n\twlc->SFBL = RETRY_SHORT_FB;\n\twlc->LFBL = RETRY_LONG_FB;\n\n\t \n\twlc->SRL = RETRY_SHORT_DEF;\n\twlc->LRL = RETRY_LONG_DEF;\n\n\t \n\twlc->pub->_ampdu = AMPDU_AGG_HOST;\n}\n\nstatic uint brcms_c_attach_module(struct brcms_c_info *wlc)\n{\n\tuint err = 0;\n\tuint unit;\n\tunit = wlc->pub->unit;\n\n\twlc->asi = brcms_c_antsel_attach(wlc);\n\tif (wlc->asi == NULL) {\n\t\twiphy_err(wlc->wiphy, \"wl%d: attach: antsel_attach \"\n\t\t\t  \"failed\\n\", unit);\n\t\terr = 44;\n\t\tgoto fail;\n\t}\n\n\twlc->ampdu = brcms_c_ampdu_attach(wlc);\n\tif (wlc->ampdu == NULL) {\n\t\twiphy_err(wlc->wiphy, \"wl%d: attach: ampdu_attach \"\n\t\t\t  \"failed\\n\", unit);\n\t\terr = 50;\n\t\tgoto fail;\n\t}\n\n\tif ((brcms_c_stf_attach(wlc) != 0)) {\n\t\twiphy_err(wlc->wiphy, \"wl%d: attach: stf_attach \"\n\t\t\t  \"failed\\n\", unit);\n\t\terr = 68;\n\t\tgoto fail;\n\t}\n fail:\n\treturn err;\n}\n\nstruct brcms_pub *brcms_c_pub(struct brcms_c_info *wlc)\n{\n\treturn wlc->pub;\n}\n\n \nstatic int brcms_b_attach(struct brcms_c_info *wlc, struct bcma_device *core,\n\t\t\t  uint unit, bool piomode)\n{\n\tstruct brcms_hardware *wlc_hw;\n\tuint err = 0;\n\tuint j;\n\tbool wme = false;\n\tstruct shared_phy_params sha_params;\n\tstruct wiphy *wiphy = wlc->wiphy;\n\tstruct pci_dev *pcidev = core->bus->host_pci;\n\tstruct ssb_sprom *sprom = &core->bus->sprom;\n\n\tif (core->bus->hosttype == BCMA_HOSTTYPE_PCI)\n\t\tbrcms_dbg_info(core, \"wl%d: vendor 0x%x device 0x%x\\n\", unit,\n\t\t\t       pcidev->vendor,\n\t\t\t       pcidev->device);\n\telse\n\t\tbrcms_dbg_info(core, \"wl%d: vendor 0x%x device 0x%x\\n\", unit,\n\t\t\t       core->bus->boardinfo.vendor,\n\t\t\t       core->bus->boardinfo.type);\n\n\twme = true;\n\n\twlc_hw = wlc->hw;\n\twlc_hw->wlc = wlc;\n\twlc_hw->unit = unit;\n\twlc_hw->band = wlc_hw->bandstate[0];\n\twlc_hw->_piomode = piomode;\n\n\t \n\tbrcms_b_info_init(wlc_hw);\n\n\t \n\twlc_hw->sih = ai_attach(core->bus);\n\tif (wlc_hw->sih == NULL) {\n\t\twiphy_err(wiphy, \"wl%d: brcms_b_attach: si_attach failed\\n\",\n\t\t\t  unit);\n\t\terr = 11;\n\t\tgoto fail;\n\t}\n\n\t \n\tif (!brcms_c_chipmatch(core)) {\n\t\twiphy_err(wiphy, \"wl%d: brcms_b_attach: Unsupported device\\n\",\n\t\t\t unit);\n\t\terr = 12;\n\t\tgoto fail;\n\t}\n\n\tif (core->bus->hosttype == BCMA_HOSTTYPE_PCI) {\n\t\twlc_hw->vendorid = pcidev->vendor;\n\t\twlc_hw->deviceid = pcidev->device;\n\t} else {\n\t\twlc_hw->vendorid = core->bus->boardinfo.vendor;\n\t\twlc_hw->deviceid = core->bus->boardinfo.type;\n\t}\n\n\twlc_hw->d11core = core;\n\twlc_hw->corerev = core->id.rev;\n\n\t \n\tif (!brcms_c_isgoodchip(wlc_hw)) {\n\t\terr = 13;\n\t\tgoto fail;\n\t}\n\n\t \n\tai_clkctl_init(wlc_hw->sih);\n\n\t \n\tbrcms_b_clkctl_clk(wlc_hw, BCMA_CLKMODE_FAST);\n\tbrcms_b_corereset(wlc_hw, BRCMS_USE_COREFLAGS);\n\n\tif (!brcms_b_validate_chip_access(wlc_hw)) {\n\t\twiphy_err(wiphy, \"wl%d: brcms_b_attach: validate_chip_access \"\n\t\t\t\"failed\\n\", unit);\n\t\terr = 14;\n\t\tgoto fail;\n\t}\n\n\t \n\tj = sprom->board_rev;\n\t \n\tif (j == BOARDREV_PROMOTABLE)\n\t\tj = BOARDREV_PROMOTED;\n\twlc_hw->boardrev = (u16) j;\n\tif (!brcms_c_validboardtype(wlc_hw)) {\n\t\twiphy_err(wiphy, \"wl%d: brcms_b_attach: Unsupported Broadcom \"\n\t\t\t  \"board type (0x%x)\" \" or revision level (0x%x)\\n\",\n\t\t\t  unit, ai_get_boardtype(wlc_hw->sih),\n\t\t\t  wlc_hw->boardrev);\n\t\terr = 15;\n\t\tgoto fail;\n\t}\n\twlc_hw->sromrev = sprom->revision;\n\twlc_hw->boardflags = sprom->boardflags_lo + (sprom->boardflags_hi << 16);\n\twlc_hw->boardflags2 = sprom->boardflags2_lo + (sprom->boardflags2_hi << 16);\n\n\tif (wlc_hw->boardflags & BFL_NOPLLDOWN)\n\t\tbrcms_b_pllreq(wlc_hw, true, BRCMS_PLLREQ_SHARED);\n\n\t \n\tif (wlc_hw->deviceid == BCM43224_D11N_ID ||\n\t    wlc_hw->deviceid == BCM43224_D11N_ID_VEN1 ||\n\t    wlc_hw->deviceid == BCM43224_CHIP_ID)\n\t\t \n\t\twlc_hw->_nbands = 2;\n\telse\n\t\twlc_hw->_nbands = 1;\n\n\tif ((ai_get_chip_id(wlc_hw->sih) == BCMA_CHIP_ID_BCM43225))\n\t\twlc_hw->_nbands = 1;\n\n\t \n\twlc->vendorid = wlc_hw->vendorid;\n\twlc->deviceid = wlc_hw->deviceid;\n\twlc->pub->sih = wlc_hw->sih;\n\twlc->pub->corerev = wlc_hw->corerev;\n\twlc->pub->sromrev = wlc_hw->sromrev;\n\twlc->pub->boardrev = wlc_hw->boardrev;\n\twlc->pub->boardflags = wlc_hw->boardflags;\n\twlc->pub->boardflags2 = wlc_hw->boardflags2;\n\twlc->pub->_nbands = wlc_hw->_nbands;\n\n\twlc_hw->physhim = wlc_phy_shim_attach(wlc_hw, wlc->wl, wlc);\n\n\tif (wlc_hw->physhim == NULL) {\n\t\twiphy_err(wiphy, \"wl%d: brcms_b_attach: wlc_phy_shim_attach \"\n\t\t\t\"failed\\n\", unit);\n\t\terr = 25;\n\t\tgoto fail;\n\t}\n\n\t \n\tsha_params.sih = wlc_hw->sih;\n\tsha_params.physhim = wlc_hw->physhim;\n\tsha_params.unit = unit;\n\tsha_params.corerev = wlc_hw->corerev;\n\tsha_params.vid = wlc_hw->vendorid;\n\tsha_params.did = wlc_hw->deviceid;\n\tsha_params.chip = ai_get_chip_id(wlc_hw->sih);\n\tsha_params.chiprev = ai_get_chiprev(wlc_hw->sih);\n\tsha_params.chippkg = ai_get_chippkg(wlc_hw->sih);\n\tsha_params.sromrev = wlc_hw->sromrev;\n\tsha_params.boardtype = ai_get_boardtype(wlc_hw->sih);\n\tsha_params.boardrev = wlc_hw->boardrev;\n\tsha_params.boardflags = wlc_hw->boardflags;\n\tsha_params.boardflags2 = wlc_hw->boardflags2;\n\n\t \n\twlc_hw->phy_sh = wlc_phy_shared_attach(&sha_params);\n\tif (!wlc_hw->phy_sh) {\n\t\terr = 16;\n\t\tgoto fail;\n\t}\n\n\t \n\tfor (j = 0; j < wlc_hw->_nbands; j++) {\n\t\t \n\n\t\tbrcms_c_setxband(wlc_hw, j);\n\n\t\twlc_hw->band->bandunit = j;\n\t\twlc_hw->band->bandtype = j ? BRCM_BAND_5G : BRCM_BAND_2G;\n\t\twlc->band->bandunit = j;\n\t\twlc->band->bandtype = j ? BRCM_BAND_5G : BRCM_BAND_2G;\n\t\twlc->core->coreidx = core->core_index;\n\n\t\twlc_hw->machwcap = bcma_read32(core, D11REGOFFS(machwcap));\n\t\twlc_hw->machwcap_backup = wlc_hw->machwcap;\n\n\t\t \n\t\tWARN_ON(wlc_hw->corerev < XMTFIFOTBL_STARTREV ||\n\t\t\t(wlc_hw->corerev - XMTFIFOTBL_STARTREV) >\n\t\t\t\tARRAY_SIZE(xmtfifo_sz));\n\t\twlc_hw->xmtfifo_sz =\n\t\t    xmtfifo_sz[(wlc_hw->corerev - XMTFIFOTBL_STARTREV)];\n\t\tWARN_ON(!wlc_hw->xmtfifo_sz[0]);\n\n\t\t \n\t\twlc_hw->band->pi =\n\t\t\twlc_phy_attach(wlc_hw->phy_sh, core,\n\t\t\t\t       wlc_hw->band->bandtype,\n\t\t\t\t       wlc->wiphy);\n\t\tif (wlc_hw->band->pi == NULL) {\n\t\t\twiphy_err(wiphy, \"wl%d: brcms_b_attach: wlc_phy_\"\n\t\t\t\t  \"attach failed\\n\", unit);\n\t\t\terr = 17;\n\t\t\tgoto fail;\n\t\t}\n\n\t\twlc_phy_machwcap_set(wlc_hw->band->pi, wlc_hw->machwcap);\n\n\t\twlc_phy_get_phyversion(wlc_hw->band->pi, &wlc_hw->band->phytype,\n\t\t\t\t       &wlc_hw->band->phyrev,\n\t\t\t\t       &wlc_hw->band->radioid,\n\t\t\t\t       &wlc_hw->band->radiorev);\n\t\twlc_hw->band->abgphy_encore =\n\t\t    wlc_phy_get_encore(wlc_hw->band->pi);\n\t\twlc->band->abgphy_encore = wlc_phy_get_encore(wlc_hw->band->pi);\n\t\twlc_hw->band->core_flags =\n\t\t    wlc_phy_get_coreflags(wlc_hw->band->pi);\n\n\t\t \n\t\tif (BRCMS_ISNPHY(wlc_hw->band)) {\n\t\t\tif (NCONF_HAS(wlc_hw->band->phyrev))\n\t\t\t\tgoto good_phy;\n\t\t\telse\n\t\t\t\tgoto bad_phy;\n\t\t} else if (BRCMS_ISLCNPHY(wlc_hw->band)) {\n\t\t\tif (LCNCONF_HAS(wlc_hw->band->phyrev))\n\t\t\t\tgoto good_phy;\n\t\t\telse\n\t\t\t\tgoto bad_phy;\n\t\t} else {\n bad_phy:\n\t\t\twiphy_err(wiphy, \"wl%d: brcms_b_attach: unsupported \"\n\t\t\t\t  \"phy type/rev (%d/%d)\\n\", unit,\n\t\t\t\t  wlc_hw->band->phytype, wlc_hw->band->phyrev);\n\t\t\terr = 18;\n\t\t\tgoto fail;\n\t\t}\n\n good_phy:\n\t\t \n\t\twlc->band->pi = wlc_hw->band->pi;\n\t\twlc->band->phytype = wlc_hw->band->phytype;\n\t\twlc->band->phyrev = wlc_hw->band->phyrev;\n\t\twlc->band->radioid = wlc_hw->band->radioid;\n\t\twlc->band->radiorev = wlc_hw->band->radiorev;\n\t\tbrcms_dbg_info(core, \"wl%d: phy %u/%u radio %x/%u\\n\", unit,\n\t\t\t       wlc->band->phytype, wlc->band->phyrev,\n\t\t\t       wlc->band->radioid, wlc->band->radiorev);\n\t\t \n\t\twlc_hw->band->CWmin = APHY_CWMIN;\n\t\twlc_hw->band->CWmax = PHY_CWMAX;\n\n\t\tif (!brcms_b_attach_dmapio(wlc, j, wme)) {\n\t\t\terr = 19;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t \n\tbrcms_c_coredisable(wlc_hw);\n\n\t \n\tbcma_host_pci_down(wlc_hw->d11core->bus);\n\n\t \n\tbrcms_b_xtal(wlc_hw, OFF);\n\n\t \n\n\t \n\tbrcms_c_get_macaddr(wlc_hw, wlc_hw->etheraddr);\n\n\tif (is_broadcast_ether_addr(wlc_hw->etheraddr) ||\n\t    is_zero_ether_addr(wlc_hw->etheraddr)) {\n\t\twiphy_err(wiphy, \"wl%d: brcms_b_attach: bad macaddr\\n\",\n\t\t\t  unit);\n\t\terr = 22;\n\t\tgoto fail;\n\t}\n\n\tbrcms_dbg_info(wlc_hw->d11core, \"deviceid 0x%x nbands %d board 0x%x\\n\",\n\t\t       wlc_hw->deviceid, wlc_hw->_nbands,\n\t\t       ai_get_boardtype(wlc_hw->sih));\n\n\treturn err;\n\n fail:\n\twiphy_err(wiphy, \"wl%d: brcms_b_attach: failed with err %d\\n\", unit,\n\t\t  err);\n\treturn err;\n}\n\nstatic bool brcms_c_attach_stf_ant_init(struct brcms_c_info *wlc)\n{\n\tint aa;\n\tuint unit;\n\tint bandtype;\n\tstruct ssb_sprom *sprom = &wlc->hw->d11core->bus->sprom;\n\n\tunit = wlc->pub->unit;\n\tbandtype = wlc->band->bandtype;\n\n\t \n\tif (bandtype == BRCM_BAND_5G)\n\t\taa = sprom->ant_available_a;\n\telse\n\t\taa = sprom->ant_available_bg;\n\n\tif ((aa < 1) || (aa > 15)) {\n\t\twiphy_err(wlc->wiphy, \"wl%d: %s: Invalid antennas available in\"\n\t\t\t  \" srom (0x%x), using 3\\n\", unit, __func__, aa);\n\t\taa = 3;\n\t}\n\n\t \n\tif (aa == 1) {\n\t\twlc->stf->ant_rx_ovr = ANT_RX_DIV_FORCE_0;\n\t\twlc->stf->txant = ANT_TX_FORCE_0;\n\t} else if (aa == 2) {\n\t\twlc->stf->ant_rx_ovr = ANT_RX_DIV_FORCE_1;\n\t\twlc->stf->txant = ANT_TX_FORCE_1;\n\t} else {\n\t}\n\n\t \n\tif (bandtype == BRCM_BAND_5G)\n\t\twlc->band->antgain = sprom->antenna_gain.a1;\n\telse\n\t\twlc->band->antgain = sprom->antenna_gain.a0;\n\n\treturn true;\n}\n\nstatic void brcms_c_bss_default_init(struct brcms_c_info *wlc)\n{\n\tu16 chanspec;\n\tstruct brcms_band *band;\n\tstruct brcms_bss_info *bi = wlc->default_bss;\n\n\t \n\tmemset(bi, 0, sizeof(*bi));\n\tbi->beacon_period = BEACON_INTERVAL_DEFAULT;\n\n\t \n\tchanspec = ch20mhz_chspec(1);\n\twlc->home_chanspec = bi->chanspec = chanspec;\n\n\t \n\tband = wlc->band;\n\tif (wlc->pub->_nbands > 1 &&\n\t    band->bandunit != chspec_bandunit(chanspec))\n\t\tband = wlc->bandstate[OTHERBANDUNIT(wlc)];\n\n\t \n\tbrcms_c_rateset_default(&bi->rateset, NULL, band->phytype,\n\t\tband->bandtype, false, BRCMS_RATE_MASK_FULL,\n\t\t(bool) (wlc->pub->_n_enab & SUPPORT_11N),\n\t\tbrcms_chspec_bw(chanspec), wlc->stf->txstreams);\n\n\tif (wlc->pub->_n_enab & SUPPORT_11N)\n\t\tbi->flags |= BRCMS_BSS_HT;\n}\n\nstatic void brcms_c_update_mimo_band_bwcap(struct brcms_c_info *wlc, u8 bwcap)\n{\n\tuint i;\n\tstruct brcms_band *band;\n\n\tfor (i = 0; i < wlc->pub->_nbands; i++) {\n\t\tband = wlc->bandstate[i];\n\t\tif (band->bandtype == BRCM_BAND_5G) {\n\t\t\tif ((bwcap == BRCMS_N_BW_40ALL)\n\t\t\t    || (bwcap == BRCMS_N_BW_20IN2G_40IN5G))\n\t\t\t\tband->mimo_cap_40 = true;\n\t\t\telse\n\t\t\t\tband->mimo_cap_40 = false;\n\t\t} else {\n\t\t\tif (bwcap == BRCMS_N_BW_40ALL)\n\t\t\t\tband->mimo_cap_40 = true;\n\t\t\telse\n\t\t\t\tband->mimo_cap_40 = false;\n\t\t}\n\t}\n}\n\nstatic void brcms_c_timers_deinit(struct brcms_c_info *wlc)\n{\n\t \n\tif (wlc->wdtimer) {\n\t\tbrcms_free_timer(wlc->wdtimer);\n\t\twlc->wdtimer = NULL;\n\t}\n\tif (wlc->radio_timer) {\n\t\tbrcms_free_timer(wlc->radio_timer);\n\t\twlc->radio_timer = NULL;\n\t}\n}\n\nstatic void brcms_c_detach_module(struct brcms_c_info *wlc)\n{\n\tif (wlc->asi) {\n\t\tbrcms_c_antsel_detach(wlc->asi);\n\t\twlc->asi = NULL;\n\t}\n\n\tif (wlc->ampdu) {\n\t\tbrcms_c_ampdu_detach(wlc->ampdu);\n\t\twlc->ampdu = NULL;\n\t}\n\n\tbrcms_c_stf_detach(wlc);\n}\n\n \nstatic void brcms_b_detach(struct brcms_c_info *wlc)\n{\n\tuint i;\n\tstruct brcms_hw_band *band;\n\tstruct brcms_hardware *wlc_hw = wlc->hw;\n\n\tbrcms_b_detach_dmapio(wlc_hw);\n\n\tband = wlc_hw->band;\n\tfor (i = 0; i < wlc_hw->_nbands; i++) {\n\t\tif (band->pi) {\n\t\t\t \n\t\t\twlc_phy_detach(band->pi);\n\t\t\tband->pi = NULL;\n\t\t}\n\t\tband = wlc_hw->bandstate[OTHERBANDUNIT(wlc)];\n\t}\n\n\t \n\tkfree(wlc_hw->phy_sh);\n\n\twlc_phy_shim_detach(wlc_hw->physhim);\n\n\tif (wlc_hw->sih) {\n\t\tai_detach(wlc_hw->sih);\n\t\twlc_hw->sih = NULL;\n\t}\n}\n\n \nuint brcms_c_detach(struct brcms_c_info *wlc)\n{\n\tuint callbacks;\n\n\tif (wlc == NULL)\n\t\treturn 0;\n\n\tbrcms_b_detach(wlc);\n\n\t \n\tcallbacks = 0;\n\tif (!brcms_c_radio_monitor_stop(wlc))\n\t\tcallbacks++;\n\n\tbrcms_c_channel_mgr_detach(wlc->cmi);\n\n\tbrcms_c_timers_deinit(wlc);\n\n\tbrcms_c_detach_module(wlc);\n\n\tbrcms_c_detach_mfree(wlc);\n\treturn callbacks;\n}\n\n \nstatic void brcms_c_ap_upd(struct brcms_c_info *wlc)\n{\n\t \n\twlc->PLCPHdr_override = BRCMS_PLCP_SHORT;\n}\n\n \nstatic void brcms_b_hw_up(struct brcms_hardware *wlc_hw)\n{\n\tif (wlc_hw->wlc->pub->hw_up)\n\t\treturn;\n\n\tbrcms_dbg_info(wlc_hw->d11core, \"wl%d\\n\", wlc_hw->unit);\n\n\t \n\tbrcms_b_xtal(wlc_hw, ON);\n\tai_clkctl_init(wlc_hw->sih);\n\tbrcms_b_clkctl_clk(wlc_hw, BCMA_CLKMODE_FAST);\n\n\t \n\n\t \n\twlc_phy_por_inform(wlc_hw->band->pi);\n\n\twlc_hw->ucode_loaded = false;\n\twlc_hw->wlc->pub->hw_up = true;\n\n\tif ((wlc_hw->boardflags & BFL_FEM)\n\t    && (ai_get_chip_id(wlc_hw->sih) == BCMA_CHIP_ID_BCM4313)) {\n\t\tif (!\n\t\t    (wlc_hw->boardrev >= 0x1250\n\t\t     && (wlc_hw->boardflags & BFL_FEM_BT)))\n\t\t\tai_epa_4313war(wlc_hw->sih);\n\t}\n}\n\nstatic int brcms_b_up_prep(struct brcms_hardware *wlc_hw)\n{\n\tbrcms_dbg_info(wlc_hw->d11core, \"wl%d\\n\", wlc_hw->unit);\n\n\t \n\tbrcms_b_xtal(wlc_hw, ON);\n\tai_clkctl_init(wlc_hw->sih);\n\tbrcms_b_clkctl_clk(wlc_hw, BCMA_CLKMODE_FAST);\n\n\t \n\tbcma_host_pci_irq_ctl(wlc_hw->d11core->bus, wlc_hw->d11core,\n\t\t\t      true);\n\n\t \n\tif (brcms_b_radio_read_hwdisabled(wlc_hw)) {\n\t\t \n\t\tbcma_host_pci_down(wlc_hw->d11core->bus);\n\t\tbrcms_b_xtal(wlc_hw, OFF);\n\t\treturn -ENOMEDIUM;\n\t}\n\n\tbcma_host_pci_up(wlc_hw->d11core->bus);\n\n\t \n\tbrcms_b_corereset(wlc_hw, BRCMS_USE_COREFLAGS);\n\n\treturn 0;\n}\n\nstatic int brcms_b_up_finish(struct brcms_hardware *wlc_hw)\n{\n\twlc_hw->up = true;\n\twlc_phy_hw_state_upd(wlc_hw->band->pi, true);\n\n\t \n\tbrcms_b_clkctl_clk(wlc_hw, BCMA_CLKMODE_DYNAMIC);\n\tbrcms_intrson(wlc_hw->wlc->wl);\n\treturn 0;\n}\n\n \nstatic void brcms_c_wme_retries_write(struct brcms_c_info *wlc)\n{\n\tint ac;\n\n\t \n\tif (!wlc->clk)\n\t\treturn;\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\n\t\tbrcms_b_write_shm(wlc->hw, M_AC_TXLMT_ADDR(ac),\n\t\t\t\t  wlc->wme_retries[ac]);\n}\n\n \nint brcms_c_up(struct brcms_c_info *wlc)\n{\n\tstruct ieee80211_channel *ch;\n\n\tbrcms_dbg_info(wlc->hw->d11core, \"wl%d\\n\", wlc->pub->unit);\n\n\t \n\tif (wlc->pub->hw_off || brcms_deviceremoved(wlc))\n\t\treturn -ENOMEDIUM;\n\n\tif (!wlc->pub->hw_up) {\n\t\tbrcms_b_hw_up(wlc->hw);\n\t\twlc->pub->hw_up = true;\n\t}\n\n\tif ((wlc->pub->boardflags & BFL_FEM)\n\t    && (ai_get_chip_id(wlc->hw->sih) == BCMA_CHIP_ID_BCM4313)) {\n\t\tif (wlc->pub->boardrev >= 0x1250\n\t\t    && (wlc->pub->boardflags & BFL_FEM_BT))\n\t\t\tbrcms_b_mhf(wlc->hw, MHF5, MHF5_4313_GPIOCTRL,\n\t\t\t\tMHF5_4313_GPIOCTRL, BRCM_BAND_ALL);\n\t\telse\n\t\t\tbrcms_b_mhf(wlc->hw, MHF4, MHF4_EXTPA_ENABLE,\n\t\t\t\t    MHF4_EXTPA_ENABLE, BRCM_BAND_ALL);\n\t}\n\n\t \n\tif (!wlc->pub->radio_disabled) {\n\t\tint status = brcms_b_up_prep(wlc->hw);\n\t\tif (status == -ENOMEDIUM) {\n\t\t\tif (!mboolisset\n\t\t\t    (wlc->pub->radio_disabled, WL_RADIO_HW_DISABLE)) {\n\t\t\t\tstruct brcms_bss_cfg *bsscfg = wlc->bsscfg;\n\t\t\t\tmboolset(wlc->pub->radio_disabled,\n\t\t\t\t\t WL_RADIO_HW_DISABLE);\n\t\t\t\tif (bsscfg->type == BRCMS_TYPE_STATION ||\n\t\t\t\t    bsscfg->type == BRCMS_TYPE_ADHOC)\n\t\t\t\t\tbrcms_err(wlc->hw->d11core,\n\t\t\t\t\t\t  \"wl%d: up: rfdisable -> \"\n\t\t\t\t\t\t  \"bsscfg_disable()\\n\",\n\t\t\t\t\t\t   wlc->pub->unit);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (wlc->pub->radio_disabled) {\n\t\tbrcms_c_radio_monitor_start(wlc);\n\t\treturn 0;\n\t}\n\n\t \n\twlc->clk = true;\n\n\tbrcms_c_radio_monitor_stop(wlc);\n\n\t \n\tbrcms_b_mhf(wlc->hw, MHF1, MHF1_EDCF, MHF1_EDCF, BRCM_BAND_ALL);\n\n\tbrcms_init(wlc->wl);\n\twlc->pub->up = true;\n\n\tif (wlc->bandinit_pending) {\n\t\tch = wlc->pub->ieee_hw->conf.chandef.chan;\n\t\tbrcms_c_suspend_mac_and_wait(wlc);\n\t\tbrcms_c_set_chanspec(wlc, ch20mhz_chspec(ch->hw_value));\n\t\twlc->bandinit_pending = false;\n\t\tbrcms_c_enable_mac(wlc);\n\t}\n\n\tbrcms_b_up_finish(wlc->hw);\n\n\t \n\tbrcms_c_wme_retries_write(wlc);\n\n\t \n\tbrcms_add_timer(wlc->wdtimer, TIMER_INTERVAL_WATCHDOG, true);\n\twlc->WDarmed = true;\n\n\t \n\tbrcms_c_stf_phy_txant_upd(wlc);\n\t \n\tbrcms_c_ht_update_ldpc(wlc, wlc->stf->ldpc);\n\n\treturn 0;\n}\n\nstatic int brcms_b_bmac_down_prep(struct brcms_hardware *wlc_hw)\n{\n\tbool dev_gone;\n\tuint callbacks = 0;\n\n\tif (!wlc_hw->up)\n\t\treturn callbacks;\n\n\tdev_gone = brcms_deviceremoved(wlc_hw->wlc);\n\n\t \n\tif (dev_gone)\n\t\twlc_hw->wlc->macintmask = 0;\n\telse {\n\t\t \n\t\tbrcms_intrsoff(wlc_hw->wlc->wl);\n\n\t\t \n\t\tbrcms_b_clkctl_clk(wlc_hw, BCMA_CLKMODE_FAST);\n\t}\n\t \n\tcallbacks += wlc_phy_down(wlc_hw->band->pi);\n\n\treturn callbacks;\n}\n\nstatic int brcms_b_down_finish(struct brcms_hardware *wlc_hw)\n{\n\tuint callbacks = 0;\n\tbool dev_gone;\n\n\tif (!wlc_hw->up)\n\t\treturn callbacks;\n\n\twlc_hw->up = false;\n\twlc_phy_hw_state_upd(wlc_hw->band->pi, false);\n\n\tdev_gone = brcms_deviceremoved(wlc_hw->wlc);\n\n\tif (dev_gone) {\n\t\twlc_hw->sbclk = false;\n\t\twlc_hw->clk = false;\n\t\twlc_phy_hw_clk_state_upd(wlc_hw->band->pi, false);\n\n\t\t \n\t\tbrcms_c_flushqueues(wlc_hw->wlc);\n\t} else {\n\n\t\t \n\t\tif (bcma_core_is_enabled(wlc_hw->d11core)) {\n\t\t\tif (bcma_read32(wlc_hw->d11core,\n\t\t\t\t\tD11REGOFFS(maccontrol)) & MCTL_EN_MAC)\n\t\t\t\tbrcms_c_suspend_mac_and_wait(wlc_hw->wlc);\n\t\t\tcallbacks += brcms_reset(wlc_hw->wlc->wl);\n\t\t\tbrcms_c_coredisable(wlc_hw);\n\t\t}\n\n\t\t \n\t\tif (!wlc_hw->noreset) {\n\t\t\tbcma_host_pci_down(wlc_hw->d11core->bus);\n\t\t\tbrcms_b_xtal(wlc_hw, OFF);\n\t\t}\n\t}\n\n\treturn callbacks;\n}\n\n \nuint brcms_c_down(struct brcms_c_info *wlc)\n{\n\n\tuint callbacks = 0;\n\tint i;\n\n\tbrcms_dbg_info(wlc->hw->d11core, \"wl%d\\n\", wlc->pub->unit);\n\n\t \n\tif (wlc->going_down) {\n\t\tbrcms_err(wlc->hw->d11core,\n\t\t\t  \"wl%d: %s: Driver going down so return\\n\",\n\t\t\t  wlc->pub->unit, __func__);\n\t\treturn 0;\n\t}\n\tif (!wlc->pub->up)\n\t\treturn callbacks;\n\n\twlc->going_down = true;\n\n\tcallbacks += brcms_b_bmac_down_prep(wlc->hw);\n\n\tbrcms_deviceremoved(wlc);\n\n\t \n\tfor (i = 0; i < BRCMS_MAXMODULES; i++) {\n\t\tif (wlc->modulecb[i].down_fn)\n\t\t\tcallbacks +=\n\t\t\t    wlc->modulecb[i].down_fn(wlc->modulecb[i].hdl);\n\t}\n\n\t \n\tif (wlc->WDarmed) {\n\t\tif (!brcms_del_timer(wlc->wdtimer))\n\t\t\tcallbacks++;\n\t\twlc->WDarmed = false;\n\t}\n\n\twlc->pub->up = false;\n\n\twlc_phy_mute_upd(wlc->band->pi, false, PHY_MUTE_ALL);\n\n\tcallbacks += brcms_b_down_finish(wlc->hw);\n\n\t \n\twlc->clk = false;\n\n\twlc->going_down = false;\n\treturn callbacks;\n}\n\n \nint brcms_c_set_gmode(struct brcms_c_info *wlc, u8 gmode, bool config)\n{\n\tint ret = 0;\n\tuint i;\n\tstruct brcms_c_rateset rs;\n\t \n\t \n\ts8 shortslot = BRCMS_SHORTSLOT_AUTO;\n\tbool ofdm_basic = false;\t \n\tstruct brcms_band *band;\n\n\t \n\tif ((wlc->pub->_n_enab & SUPPORT_11N) && gmode == GMODE_LEGACY_B)\n\t\treturn -ENOTSUPP;\n\n\t \n\tif (wlc->band->bandtype == BRCM_BAND_2G)\n\t\tband = wlc->band;\n\telse if ((wlc->pub->_nbands > 1) &&\n\t\t (wlc->bandstate[OTHERBANDUNIT(wlc)]->bandtype == BRCM_BAND_2G))\n\t\tband = wlc->bandstate[OTHERBANDUNIT(wlc)];\n\telse\n\t\treturn -EINVAL;\n\n\t \n\tif (config)\n\t\tbrcms_c_protection_upd(wlc, BRCMS_PROT_G_USER, gmode);\n\n\t \n\tmemset(&rs, 0, sizeof(rs));\n\n\tswitch (gmode) {\n\tcase GMODE_LEGACY_B:\n\t\tshortslot = BRCMS_SHORTSLOT_OFF;\n\t\tbrcms_c_rateset_copy(&gphy_legacy_rates, &rs);\n\n\t\tbreak;\n\n\tcase GMODE_LRS:\n\t\tbreak;\n\n\tcase GMODE_AUTO:\n\t\t \n\t\tbreak;\n\n\tcase GMODE_ONLY:\n\t\tofdm_basic = true;\n\t\tbreak;\n\n\tcase GMODE_PERFORMANCE:\n\t\tshortslot = BRCMS_SHORTSLOT_ON;\n\t\tofdm_basic = true;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tbrcms_err(wlc->hw->d11core, \"wl%d: %s: invalid gmode %d\\n\",\n\t\t\t  wlc->pub->unit, __func__, gmode);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tband->gmode = gmode;\n\n\twlc->shortslot_override = shortslot;\n\n\t \n\tif (!rs.count)\n\t\tbrcms_c_rateset_copy(&cck_ofdm_rates, &rs);\n\n\tif (ofdm_basic) {\n\t\tfor (i = 0; i < rs.count; i++) {\n\t\t\tif (rs.rates[i] == BRCM_RATE_6M\n\t\t\t    || rs.rates[i] == BRCM_RATE_12M\n\t\t\t    || rs.rates[i] == BRCM_RATE_24M)\n\t\t\t\trs.rates[i] |= BRCMS_RATE_FLAG;\n\t\t}\n\t}\n\n\t \n\twlc->default_bss->rateset.count = rs.count;\n\tmemcpy(wlc->default_bss->rateset.rates, rs.rates,\n\t       sizeof(wlc->default_bss->rateset.rates));\n\n\treturn ret;\n}\n\nint brcms_c_set_nmode(struct brcms_c_info *wlc)\n{\n\tuint i;\n\ts32 nmode = AUTO;\n\n\tif (wlc->stf->txstreams == WL_11N_3x3)\n\t\tnmode = WL_11N_3x3;\n\telse\n\t\tnmode = WL_11N_2x2;\n\n\t \n\tbrcms_c_set_gmode(wlc, GMODE_AUTO, true);\n\tif (nmode == WL_11N_3x3)\n\t\twlc->pub->_n_enab = SUPPORT_HT;\n\telse\n\t\twlc->pub->_n_enab = SUPPORT_11N;\n\twlc->default_bss->flags |= BRCMS_BSS_HT;\n\t \n\tbrcms_c_rateset_mcs_build(&wlc->default_bss->rateset,\n\t\t\t      wlc->stf->txstreams);\n\tfor (i = 0; i < wlc->pub->_nbands; i++)\n\t\tmemcpy(wlc->bandstate[i]->hw_rateset.mcs,\n\t\t       wlc->default_bss->rateset.mcs, MCSSET_LEN);\n\n\treturn 0;\n}\n\nstatic int\nbrcms_c_set_internal_rateset(struct brcms_c_info *wlc,\n\t\t\t     struct brcms_c_rateset *rs_arg)\n{\n\tstruct brcms_c_rateset rs, new;\n\tuint bandunit;\n\n\tmemcpy(&rs, rs_arg, sizeof(struct brcms_c_rateset));\n\n\t \n\tif ((rs.count == 0) || (rs.count > BRCMS_NUMRATES))\n\t\treturn -EINVAL;\n\n\t \n\tbandunit = wlc->band->bandunit;\n\tmemcpy(&new, &rs, sizeof(struct brcms_c_rateset));\n\tif (brcms_c_rate_hwrs_filter_sort_validate\n\t    (&new, &wlc->bandstate[bandunit]->hw_rateset, true,\n\t     wlc->stf->txstreams))\n\t\tgoto good;\n\n\t \n\tif (brcms_is_mband_unlocked(wlc)) {\n\t\tbandunit = OTHERBANDUNIT(wlc);\n\t\tmemcpy(&new, &rs, sizeof(struct brcms_c_rateset));\n\t\tif (brcms_c_rate_hwrs_filter_sort_validate(&new,\n\t\t\t\t\t\t       &wlc->\n\t\t\t\t\t\t       bandstate[bandunit]->\n\t\t\t\t\t\t       hw_rateset, true,\n\t\t\t\t\t\t       wlc->stf->txstreams))\n\t\t\tgoto good;\n\t}\n\n\treturn -EBADE;\n\n good:\n\t \n\tmemcpy(&wlc->default_bss->rateset, &new,\n\t       sizeof(struct brcms_c_rateset));\n\tmemcpy(&wlc->bandstate[bandunit]->defrateset, &new,\n\t       sizeof(struct brcms_c_rateset));\n\treturn 0;\n}\n\nstatic void brcms_c_ofdm_rateset_war(struct brcms_c_info *wlc)\n{\n\twlc_phy_ofdm_rateset_war(wlc->band->pi, false);\n}\n\nint brcms_c_set_channel(struct brcms_c_info *wlc, u16 channel)\n{\n\tu16 chspec = ch20mhz_chspec(channel);\n\n\tif (channel > MAXCHANNEL)\n\t\treturn -EINVAL;\n\n\tif (!brcms_c_valid_chanspec_db(wlc->cmi, chspec))\n\t\treturn -EINVAL;\n\n\n\tif (!wlc->pub->up && brcms_is_mband_unlocked(wlc)) {\n\t\tif (wlc->band->bandunit != chspec_bandunit(chspec))\n\t\t\twlc->bandinit_pending = true;\n\t\telse\n\t\t\twlc->bandinit_pending = false;\n\t}\n\n\twlc->default_bss->chanspec = chspec;\n\t \n\tif (wlc->pub->up && (wlc_phy_chanspec_get(wlc->band->pi) != chspec)) {\n\t\tbrcms_c_set_home_chanspec(wlc, chspec);\n\t\tbrcms_c_suspend_mac_and_wait(wlc);\n\t\tbrcms_c_set_chanspec(wlc, chspec);\n\t\tbrcms_c_enable_mac(wlc);\n\t}\n\treturn 0;\n}\n\nint brcms_c_set_rate_limit(struct brcms_c_info *wlc, u16 srl, u16 lrl)\n{\n\tint ac;\n\n\tif (srl < 1 || srl > RETRY_SHORT_MAX ||\n\t    lrl < 1 || lrl > RETRY_SHORT_MAX)\n\t\treturn -EINVAL;\n\n\twlc->SRL = srl;\n\twlc->LRL = lrl;\n\n\tbrcms_b_retrylimit_upd(wlc->hw, wlc->SRL, wlc->LRL);\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\twlc->wme_retries[ac] =\tSFIELD(wlc->wme_retries[ac],\n\t\t\t\t\t       EDCF_SHORT,  wlc->SRL);\n\t\twlc->wme_retries[ac] =\tSFIELD(wlc->wme_retries[ac],\n\t\t\t\t\t       EDCF_LONG, wlc->LRL);\n\t}\n\tbrcms_c_wme_retries_write(wlc);\n\n\treturn 0;\n}\n\nvoid brcms_c_get_current_rateset(struct brcms_c_info *wlc,\n\t\t\t\t struct brcm_rateset *currs)\n{\n\tstruct brcms_c_rateset *rs;\n\n\tif (wlc->pub->associated)\n\t\trs = &wlc->bsscfg->current_bss->rateset;\n\telse\n\t\trs = &wlc->default_bss->rateset;\n\n\t \n\tcurrs->count = rs->count;\n\tmemcpy(&currs->rates, &rs->rates, rs->count);\n}\n\nint brcms_c_set_rateset(struct brcms_c_info *wlc, struct brcm_rateset *rs)\n{\n\tstruct brcms_c_rateset internal_rs;\n\tint bcmerror;\n\n\tif (rs->count > BRCMS_NUMRATES)\n\t\treturn -ENOBUFS;\n\n\tmemset(&internal_rs, 0, sizeof(internal_rs));\n\n\t \n\tinternal_rs.count = rs->count;\n\tmemcpy(&internal_rs.rates, &rs->rates, internal_rs.count);\n\n\t \n\tif (wlc->pub->_n_enab & SUPPORT_11N) {\n\t\tstruct brcms_bss_info *mcsset_bss;\n\t\tif (wlc->pub->associated)\n\t\t\tmcsset_bss = wlc->bsscfg->current_bss;\n\t\telse\n\t\t\tmcsset_bss = wlc->default_bss;\n\t\tmemcpy(internal_rs.mcs, &mcsset_bss->rateset.mcs[0],\n\t\t       MCSSET_LEN);\n\t}\n\n\tbcmerror = brcms_c_set_internal_rateset(wlc, &internal_rs);\n\tif (!bcmerror)\n\t\tbrcms_c_ofdm_rateset_war(wlc);\n\n\treturn bcmerror;\n}\n\nstatic void brcms_c_time_lock(struct brcms_c_info *wlc)\n{\n\tbcma_set32(wlc->hw->d11core, D11REGOFFS(maccontrol), MCTL_TBTTHOLD);\n\t \n\tbcma_read32(wlc->hw->d11core, D11REGOFFS(maccontrol));\n}\n\nstatic void brcms_c_time_unlock(struct brcms_c_info *wlc)\n{\n\tbcma_mask32(wlc->hw->d11core, D11REGOFFS(maccontrol), ~MCTL_TBTTHOLD);\n\t \n\tbcma_read32(wlc->hw->d11core, D11REGOFFS(maccontrol));\n}\n\nint brcms_c_set_beacon_period(struct brcms_c_info *wlc, u16 period)\n{\n\tu32 bcnint_us;\n\n\tif (period == 0)\n\t\treturn -EINVAL;\n\n\twlc->default_bss->beacon_period = period;\n\n\tbcnint_us = period << 10;\n\tbrcms_c_time_lock(wlc);\n\tbcma_write32(wlc->hw->d11core, D11REGOFFS(tsf_cfprep),\n\t\t     (bcnint_us << CFPREP_CBI_SHIFT));\n\tbcma_write32(wlc->hw->d11core, D11REGOFFS(tsf_cfpstart), bcnint_us);\n\tbrcms_c_time_unlock(wlc);\n\n\treturn 0;\n}\n\nu16 brcms_c_get_phy_type(struct brcms_c_info *wlc, int phyidx)\n{\n\treturn wlc->band->phytype;\n}\n\nvoid brcms_c_set_shortslot_override(struct brcms_c_info *wlc, s8 sslot_override)\n{\n\twlc->shortslot_override = sslot_override;\n\n\t \n\tif (wlc->band->bandtype == BRCM_BAND_5G)\n\t\treturn;\n\n\tif (wlc->pub->up && wlc->pub->associated) {\n\t\t \n\t} else if (wlc->pub->up) {\n\t\t \n\t\tbrcms_c_switch_shortslot(wlc, false);\n\t} else {\n\t\t \n\t\tif (wlc->shortslot_override == BRCMS_SHORTSLOT_AUTO)\n\t\t\twlc->shortslot = false;\n\t\telse\n\t\t\twlc->shortslot =\n\t\t\t    (wlc->shortslot_override ==\n\t\t\t     BRCMS_SHORTSLOT_ON);\n\t}\n}\n\n \nint brcms_c_module_register(struct brcms_pub *pub,\n\t\t\t    const char *name, struct brcms_info *hdl,\n\t\t\t    int (*d_fn)(void *handle))\n{\n\tstruct brcms_c_info *wlc = (struct brcms_c_info *) pub->wlc;\n\tint i;\n\n\t \n\tfor (i = 0; i < BRCMS_MAXMODULES; i++) {\n\t\tif (wlc->modulecb[i].name[0] == '\\0') {\n\t\t\tstrncpy(wlc->modulecb[i].name, name,\n\t\t\t\tsizeof(wlc->modulecb[i].name) - 1);\n\t\t\twlc->modulecb[i].hdl = hdl;\n\t\t\twlc->modulecb[i].down_fn = d_fn;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOSR;\n}\n\n \nint brcms_c_module_unregister(struct brcms_pub *pub, const char *name,\n\t\t\t      struct brcms_info *hdl)\n{\n\tstruct brcms_c_info *wlc = (struct brcms_c_info *) pub->wlc;\n\tint i;\n\n\tif (wlc == NULL)\n\t\treturn -ENODATA;\n\n\tfor (i = 0; i < BRCMS_MAXMODULES; i++) {\n\t\tif (!strcmp(wlc->modulecb[i].name, name) &&\n\t\t    (wlc->modulecb[i].hdl == hdl)) {\n\t\t\tmemset(&wlc->modulecb[i], 0, sizeof(wlc->modulecb[i]));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\treturn -ENODATA;\n}\n\nstatic bool brcms_c_chipmatch_pci(struct bcma_device *core)\n{\n\tstruct pci_dev *pcidev = core->bus->host_pci;\n\tu16 vendor = pcidev->vendor;\n\tu16 device = pcidev->device;\n\n\tif (vendor != PCI_VENDOR_ID_BROADCOM) {\n\t\tpr_err(\"unknown vendor id %04x\\n\", vendor);\n\t\treturn false;\n\t}\n\n\tif (device == BCM43224_D11N_ID_VEN1 || device == BCM43224_CHIP_ID)\n\t\treturn true;\n\tif ((device == BCM43224_D11N_ID) || (device == BCM43225_D11N2G_ID))\n\t\treturn true;\n\tif (device == BCM4313_D11N2G_ID || device == BCM4313_CHIP_ID)\n\t\treturn true;\n\tif ((device == BCM43236_D11N_ID) || (device == BCM43236_D11N2G_ID))\n\t\treturn true;\n\n\tpr_err(\"unknown device id %04x\\n\", device);\n\treturn false;\n}\n\nstatic bool brcms_c_chipmatch_soc(struct bcma_device *core)\n{\n\tstruct bcma_chipinfo *chipinfo = &core->bus->chipinfo;\n\n\tif (chipinfo->id == BCMA_CHIP_ID_BCM4716)\n\t\treturn true;\n\n\tpr_err(\"unknown chip id %04x\\n\", chipinfo->id);\n\treturn false;\n}\n\nbool brcms_c_chipmatch(struct bcma_device *core)\n{\n\tswitch (core->bus->hosttype) {\n\tcase BCMA_HOSTTYPE_PCI:\n\t\treturn brcms_c_chipmatch_pci(core);\n\tcase BCMA_HOSTTYPE_SOC:\n\t\treturn brcms_c_chipmatch_soc(core);\n\tdefault:\n\t\tpr_err(\"unknown host type: %i\\n\", core->bus->hosttype);\n\t\treturn false;\n\t}\n}\n\nu16 brcms_b_rate_shm_offset(struct brcms_hardware *wlc_hw, u8 rate)\n{\n\tu16 table_ptr;\n\tu8 phy_rate, index;\n\n\t \n\tif (is_ofdm_rate(rate))\n\t\ttable_ptr = M_RT_DIRMAP_A;\n\telse\n\t\ttable_ptr = M_RT_DIRMAP_B;\n\n\t \n\tphy_rate = rate_info[rate] & BRCMS_RATE_MASK;\n\tindex = phy_rate & 0xf;\n\n\t \n\treturn 2 * brcms_b_read_shm(wlc_hw, table_ptr + (index * 2));\n}\n\n \nstatic inline u16\nbcmc_fid_generate(struct brcms_c_info *wlc, struct brcms_bss_cfg *bsscfg,\n\t\t  struct d11txh *txh)\n{\n\tu16 frameid;\n\n\tframeid = le16_to_cpu(txh->TxFrameID) & ~(TXFID_SEQ_MASK |\n\t\t\t\t\t\t  TXFID_QUEUE_MASK);\n\tframeid |=\n\t    (((wlc->\n\t       mc_fid_counter++) << TXFID_SEQ_SHIFT) & TXFID_SEQ_MASK) |\n\t    TX_BCMC_FIFO;\n\n\treturn frameid;\n}\n\nstatic uint\nbrcms_c_calc_ack_time(struct brcms_c_info *wlc, u32 rspec,\n\t\t      u8 preamble_type)\n{\n\tuint dur = 0;\n\n\t \n\trspec = brcms_basic_rate(wlc, rspec);\n\t \n\tdur =\n\t    brcms_c_calc_frame_time(wlc, rspec, preamble_type,\n\t\t\t\t(DOT11_ACK_LEN + FCS_LEN));\n\treturn dur;\n}\n\nstatic uint\nbrcms_c_calc_cts_time(struct brcms_c_info *wlc, u32 rspec,\n\t\t      u8 preamble_type)\n{\n\treturn brcms_c_calc_ack_time(wlc, rspec, preamble_type);\n}\n\nstatic uint\nbrcms_c_calc_ba_time(struct brcms_c_info *wlc, u32 rspec,\n\t\t     u8 preamble_type)\n{\n\t \n\trspec = brcms_basic_rate(wlc, rspec);\n\t \n\treturn brcms_c_calc_frame_time(wlc, rspec, preamble_type,\n\t\t\t\t   (DOT11_BA_LEN + DOT11_BA_BITMAP_LEN +\n\t\t\t\t    FCS_LEN));\n}\n\n \nstatic u16\nbrcms_c_compute_frame_dur(struct brcms_c_info *wlc, u32 rate,\n\t\t      u8 preamble_type, uint next_frag_len)\n{\n\tu16 dur, sifs;\n\n\tsifs = get_sifs(wlc->band);\n\n\tdur = sifs;\n\tdur += (u16) brcms_c_calc_ack_time(wlc, rate, preamble_type);\n\n\tif (next_frag_len) {\n\t\t \n\t\tdur *= 2;\n\t\t \n\t\tdur += sifs;\n\t\tdur +=\n\t\t    (u16) brcms_c_calc_frame_time(wlc, rate, preamble_type,\n\t\t\t\t\t\t next_frag_len);\n\t}\n\treturn dur;\n}\n\n \nstatic uint\nbrcms_c_calc_frame_len(struct brcms_c_info *wlc, u32 ratespec,\n\t\t   u8 preamble_type, uint dur)\n{\n\tuint nsyms, mac_len, Ndps, kNdps;\n\tuint rate = rspec2rate(ratespec);\n\n\tif (is_mcs_rate(ratespec)) {\n\t\tuint mcs = ratespec & RSPEC_RATE_MASK;\n\t\tint tot_streams = mcs_2_txstreams(mcs) + rspec_stc(ratespec);\n\t\tdur -= PREN_PREAMBLE + (tot_streams * PREN_PREAMBLE_EXT);\n\t\t \n\t\tif (wlc->band->bandtype == BRCM_BAND_2G)\n\t\t\tdur -= DOT11_OFDM_SIGNAL_EXTENSION;\n\t\t \n\t\tkNdps =\tmcs_2_rate(mcs, rspec_is40mhz(ratespec),\n\t\t\t\t   rspec_issgi(ratespec)) * 4;\n\t\tnsyms = dur / APHY_SYMBOL_TIME;\n\t\tmac_len =\n\t\t    ((nsyms * kNdps) -\n\t\t     ((APHY_SERVICE_NBITS + APHY_TAIL_NBITS) * 1000)) / 8000;\n\t} else if (is_ofdm_rate(ratespec)) {\n\t\tdur -= APHY_PREAMBLE_TIME;\n\t\tdur -= APHY_SIGNAL_TIME;\n\t\t \n\t\tNdps = rate * 2;\n\t\tnsyms = dur / APHY_SYMBOL_TIME;\n\t\tmac_len =\n\t\t    ((nsyms * Ndps) -\n\t\t     (APHY_SERVICE_NBITS + APHY_TAIL_NBITS)) / 8;\n\t} else {\n\t\tif (preamble_type & BRCMS_SHORT_PREAMBLE)\n\t\t\tdur -= BPHY_PLCP_SHORT_TIME;\n\t\telse\n\t\t\tdur -= BPHY_PLCP_TIME;\n\t\tmac_len = dur * rate;\n\t\t \n\t\tmac_len = mac_len / 8 / 2;\n\t}\n\treturn mac_len;\n}\n\n \nstatic bool brcms_c_valid_rate(struct brcms_c_info *wlc, u32 rspec, int band,\n\t\t    bool verbose)\n{\n\tstruct brcms_c_rateset *hw_rateset;\n\tuint i;\n\n\tif ((band == BRCM_BAND_AUTO) || (band == wlc->band->bandtype))\n\t\thw_rateset = &wlc->band->hw_rateset;\n\telse if (wlc->pub->_nbands > 1)\n\t\thw_rateset = &wlc->bandstate[OTHERBANDUNIT(wlc)]->hw_rateset;\n\telse\n\t\t \n\t\treturn false;\n\n\t \n\tif (is_mcs_rate(rspec)) {\n\t\tif ((rspec & RSPEC_RATE_MASK) >= MCS_TABLE_SIZE)\n\t\t\tgoto error;\n\n\t\treturn isset(hw_rateset->mcs, (rspec & RSPEC_RATE_MASK));\n\t}\n\n\tfor (i = 0; i < hw_rateset->count; i++)\n\t\tif (hw_rateset->rates[i] == rspec2rate(rspec))\n\t\t\treturn true;\n error:\n\tif (verbose)\n\t\tbrcms_err(wlc->hw->d11core, \"wl%d: valid_rate: rate spec 0x%x \"\n\t\t\t  \"not in hw_rateset\\n\", wlc->pub->unit, rspec);\n\n\treturn false;\n}\n\nstatic u32\nmac80211_wlc_set_nrate(struct brcms_c_info *wlc, struct brcms_band *cur_band,\n\t\t       u32 int_val)\n{\n\tstruct bcma_device *core = wlc->hw->d11core;\n\tu8 stf = (int_val & NRATE_STF_MASK) >> NRATE_STF_SHIFT;\n\tu8 rate = int_val & NRATE_RATE_MASK;\n\tu32 rspec;\n\tbool ismcs = ((int_val & NRATE_MCS_INUSE) == NRATE_MCS_INUSE);\n\tbool issgi = ((int_val & NRATE_SGI_MASK) >> NRATE_SGI_SHIFT);\n\tbool override_mcs_only = ((int_val & NRATE_OVERRIDE_MCS_ONLY)\n\t\t\t\t  == NRATE_OVERRIDE_MCS_ONLY);\n\n\tif (!ismcs)\n\t\treturn (u32) rate;\n\n\t \n\tif ((wlc->pub->_n_enab & SUPPORT_11N) && ismcs) {\n\t\t \n\t\tif (stf > PHY_TXC1_MODE_SDM) {\n\t\t\tbrcms_err(core, \"wl%d: %s: Invalid stf\\n\",\n\t\t\t\t  wlc->pub->unit, __func__);\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tif (rate == 32) {\n\t\t\tif (!CHSPEC_IS40(wlc->home_chanspec) ||\n\t\t\t    ((stf != PHY_TXC1_MODE_SISO)\n\t\t\t     && (stf != PHY_TXC1_MODE_CDD))) {\n\t\t\t\tbrcms_err(core, \"wl%d: %s: Invalid mcs 32\\n\",\n\t\t\t\t\t  wlc->pub->unit, __func__);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\t \n\t\t} else if (rate > HIGHEST_SINGLE_STREAM_MCS) {\n\t\t\t \n\t\t\tif (stf != PHY_TXC1_MODE_SDM) {\n\t\t\t\tbrcms_dbg_mac80211(core, \"wl%d: enabling \"\n\t\t\t\t\t\t   \"SDM mode for mcs %d\\n\",\n\t\t\t\t\t\t   wlc->pub->unit, rate);\n\t\t\t\tstf = PHY_TXC1_MODE_SDM;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif ((stf > PHY_TXC1_MODE_STBC) ||\n\t\t\t    (!BRCMS_STBC_CAP_PHY(wlc)\n\t\t\t     && (stf == PHY_TXC1_MODE_STBC))) {\n\t\t\t\tbrcms_err(core, \"wl%d: %s: Invalid STBC\\n\",\n\t\t\t\t\t  wlc->pub->unit, __func__);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t} else if (is_ofdm_rate(rate)) {\n\t\tif ((stf != PHY_TXC1_MODE_CDD) && (stf != PHY_TXC1_MODE_SISO)) {\n\t\t\tbrcms_err(core, \"wl%d: %s: Invalid OFDM\\n\",\n\t\t\t\t  wlc->pub->unit, __func__);\n\t\t\tgoto done;\n\t\t}\n\t} else if (is_cck_rate(rate)) {\n\t\tif ((cur_band->bandtype != BRCM_BAND_2G)\n\t\t    || (stf != PHY_TXC1_MODE_SISO)) {\n\t\t\tbrcms_err(core, \"wl%d: %s: Invalid CCK\\n\",\n\t\t\t\t  wlc->pub->unit, __func__);\n\t\t\tgoto done;\n\t\t}\n\t} else {\n\t\tbrcms_err(core, \"wl%d: %s: Unknown rate type\\n\",\n\t\t\t  wlc->pub->unit, __func__);\n\t\tgoto done;\n\t}\n\t \n\tif ((stf != PHY_TXC1_MODE_SISO) && (wlc->stf->txstreams == 1)) {\n\t\tbrcms_err(core, \"wl%d: %s: SISO antenna but !SISO \"\n\t\t\t  \"request\\n\", wlc->pub->unit, __func__);\n\t\tgoto done;\n\t}\n\n\trspec = rate;\n\tif (ismcs) {\n\t\trspec |= RSPEC_MIMORATE;\n\t\t \n\t\tif (stf == PHY_TXC1_MODE_STBC) {\n\t\t\tu8 stc;\n\t\t\tstc = 1;\t \n\t\t\trspec |= (stc << RSPEC_STC_SHIFT);\n\t\t}\n\t}\n\n\trspec |= (stf << RSPEC_STF_SHIFT);\n\n\tif (override_mcs_only)\n\t\trspec |= RSPEC_OVERRIDE_MCS_ONLY;\n\n\tif (issgi)\n\t\trspec |= RSPEC_SHORT_GI;\n\n\tif ((rate != 0)\n\t    && !brcms_c_valid_rate(wlc, rspec, cur_band->bandtype, true))\n\t\treturn rate;\n\n\treturn rspec;\ndone:\n\treturn rate;\n}\n\n \n\nstatic void brcms_c_cck_plcp_set(struct brcms_c_info *wlc, int rate_500,\n\t\t\t     uint length, u8 *plcp)\n{\n\tu16 usec = 0;\n\tu8 le = 0;\n\n\tswitch (rate_500) {\n\tcase BRCM_RATE_1M:\n\t\tusec = length << 3;\n\t\tbreak;\n\tcase BRCM_RATE_2M:\n\t\tusec = length << 2;\n\t\tbreak;\n\tcase BRCM_RATE_5M5:\n\t\tusec = (length << 4) / 11;\n\t\tif ((length << 4) - (usec * 11) > 0)\n\t\t\tusec++;\n\t\tbreak;\n\tcase BRCM_RATE_11M:\n\t\tusec = (length << 3) / 11;\n\t\tif ((length << 3) - (usec * 11) > 0) {\n\t\t\tusec++;\n\t\t\tif ((usec * 11) - (length << 3) >= 8)\n\t\t\t\tle = D11B_PLCP_SIGNAL_LE;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbrcms_err(wlc->hw->d11core,\n\t\t\t  \"brcms_c_cck_plcp_set: unsupported rate %d\\n\",\n\t\t\t  rate_500);\n\t\trate_500 = BRCM_RATE_1M;\n\t\tusec = length << 3;\n\t\tbreak;\n\t}\n\t \n\tplcp[0] = rate_500 * 5;\t \n\t \n\tplcp[1] = (u8) (le | D11B_PLCP_SIGNAL_LOCKED);\n\t \n\tplcp[2] = usec & 0xff;\n\tplcp[3] = (usec >> 8) & 0xff;\n\t \n\tplcp[4] = 0;\n\tplcp[5] = 0;\n}\n\n \nstatic void brcms_c_compute_mimo_plcp(u32 rspec, uint length, u8 *plcp)\n{\n\tu8 mcs = (u8) (rspec & RSPEC_RATE_MASK);\n\tplcp[0] = mcs;\n\tif (rspec_is40mhz(rspec) || (mcs == 32))\n\t\tplcp[0] |= MIMO_PLCP_40MHZ;\n\tBRCMS_SET_MIMO_PLCP_LEN(plcp, length);\n\tplcp[3] = rspec_mimoplcp3(rspec);  \n\tplcp[3] |= 0x7;  \n\tplcp[4] = 0;  \n\tplcp[5] = 0;\n}\n\n \nstatic void\nbrcms_c_compute_ofdm_plcp(u32 rspec, u32 length, u8 *plcp)\n{\n\tu8 rate_signal;\n\tu32 tmp = 0;\n\tint rate = rspec2rate(rspec);\n\n\t \n\trate_signal = rate_info[rate] & BRCMS_RATE_MASK;\n\tmemset(plcp, 0, D11_PHY_HDR_LEN);\n\tD11A_PHY_HDR_SRATE((struct ofdm_phy_hdr *) plcp, rate_signal);\n\n\ttmp = (length & 0xfff) << 5;\n\tplcp[2] |= (tmp >> 16) & 0xff;\n\tplcp[1] |= (tmp >> 8) & 0xff;\n\tplcp[0] |= tmp & 0xff;\n}\n\n \nstatic void brcms_c_compute_cck_plcp(struct brcms_c_info *wlc, u32 rspec,\n\t\t\t\t uint length, u8 *plcp)\n{\n\tint rate = rspec2rate(rspec);\n\n\tbrcms_c_cck_plcp_set(wlc, rate, length, plcp);\n}\n\nstatic void\nbrcms_c_compute_plcp(struct brcms_c_info *wlc, u32 rspec,\n\t\t     uint length, u8 *plcp)\n{\n\tif (is_mcs_rate(rspec))\n\t\tbrcms_c_compute_mimo_plcp(rspec, length, plcp);\n\telse if (is_ofdm_rate(rspec))\n\t\tbrcms_c_compute_ofdm_plcp(rspec, length, plcp);\n\telse\n\t\tbrcms_c_compute_cck_plcp(wlc, rspec, length, plcp);\n}\n\n \nu16\nbrcms_c_compute_rtscts_dur(struct brcms_c_info *wlc, bool cts_only,\n\t\t\t   u32 rts_rate,\n\t\t\t   u32 frame_rate, u8 rts_preamble_type,\n\t\t\t   u8 frame_preamble_type, uint frame_len, bool ba)\n{\n\tu16 dur, sifs;\n\n\tsifs = get_sifs(wlc->band);\n\n\tif (!cts_only) {\n\t\t \n\t\tdur = 3 * sifs;\n\t\tdur +=\n\t\t    (u16) brcms_c_calc_cts_time(wlc, rts_rate,\n\t\t\t\t\t       rts_preamble_type);\n\t} else {\n\t\t \n\t\tdur = 2 * sifs;\n\t}\n\n\tdur +=\n\t    (u16) brcms_c_calc_frame_time(wlc, frame_rate, frame_preamble_type,\n\t\t\t\t\t frame_len);\n\tif (ba)\n\t\tdur +=\n\t\t    (u16) brcms_c_calc_ba_time(wlc, frame_rate,\n\t\t\t\t\t      BRCMS_SHORT_PREAMBLE);\n\telse\n\t\tdur +=\n\t\t    (u16) brcms_c_calc_ack_time(wlc, frame_rate,\n\t\t\t\t\t       frame_preamble_type);\n\treturn dur;\n}\n\nstatic u16 brcms_c_phytxctl1_calc(struct brcms_c_info *wlc, u32 rspec)\n{\n\tu16 phyctl1 = 0;\n\tu16 bw;\n\n\tif (BRCMS_ISLCNPHY(wlc->band)) {\n\t\tbw = PHY_TXC1_BW_20MHZ;\n\t} else {\n\t\tbw = rspec_get_bw(rspec);\n\t\t \n\t\tif (bw < PHY_TXC1_BW_20MHZ) {\n\t\t\tbrcms_err(wlc->hw->d11core, \"phytxctl1_calc: bw %d is \"\n\t\t\t\t  \"not supported yet, set to 20L\\n\", bw);\n\t\t\tbw = PHY_TXC1_BW_20MHZ;\n\t\t}\n\t}\n\n\tif (is_mcs_rate(rspec)) {\n\t\tuint mcs = rspec & RSPEC_RATE_MASK;\n\n\t\t \n\t\tphyctl1 = rspec_phytxbyte2(rspec);\n\t\t \n\t\tphyctl1 |= (mcs_table[mcs].tx_phy_ctl3 << 8);\n\t} else if (is_cck_rate(rspec) && !BRCMS_ISLCNPHY(wlc->band)\n\t\t   && !BRCMS_ISSSLPNPHY(wlc->band)) {\n\t\t \n\t\t \n\t\tphyctl1 = (bw | (rspec_stf(rspec) << PHY_TXC1_MODE_SHIFT));\n\t} else {\t\t \n\t\ts16 phycfg;\n\t\t \n\t\tphycfg = brcms_c_rate_legacy_phyctl(rspec2rate(rspec));\n\t\tif (phycfg == -1) {\n\t\t\tbrcms_err(wlc->hw->d11core, \"phytxctl1_calc: wrong \"\n\t\t\t\t  \"legacy OFDM/CCK rate\\n\");\n\t\t\tphycfg = 0;\n\t\t}\n\t\t \n\t\tphyctl1 =\n\t\t    (bw | (phycfg << 8) |\n\t\t     (rspec_stf(rspec) << PHY_TXC1_MODE_SHIFT));\n\t}\n\treturn phyctl1;\n}\n\n \nstatic u16\nbrcms_c_d11hdrs_mac80211(struct brcms_c_info *wlc, struct ieee80211_hw *hw,\n\t\t     struct sk_buff *p, struct scb *scb, uint frag,\n\t\t     uint nfrags, uint queue, uint next_frag_len)\n{\n\tstruct ieee80211_hdr *h;\n\tstruct d11txh *txh;\n\tu8 *plcp, plcp_fallback[D11_PHY_HDR_LEN];\n\tint len, phylen, rts_phylen;\n\tu16 mch, phyctl, xfts, mainrates;\n\tu16 seq = 0, mcl = 0, status = 0, frameid = 0;\n\tu32 rspec[2] = { BRCM_RATE_1M, BRCM_RATE_1M };\n\tu32 rts_rspec[2] = { BRCM_RATE_1M, BRCM_RATE_1M };\n\tbool use_rts = false;\n\tbool use_cts = false;\n\tbool use_rifs = false;\n\tu8 preamble_type[2] = { BRCMS_LONG_PREAMBLE, BRCMS_LONG_PREAMBLE };\n\tu8 rts_preamble_type[2] = { BRCMS_LONG_PREAMBLE, BRCMS_LONG_PREAMBLE };\n\tu8 *rts_plcp, rts_plcp_fallback[D11_PHY_HDR_LEN];\n\tstruct ieee80211_rts *rts = NULL;\n\tbool qos;\n\tuint ac;\n\tbool hwtkmic = false;\n\tu16 mimo_ctlchbw = PHY_TXC1_BW_20MHZ;\n#define ANTCFG_NONE 0xFF\n\tu8 antcfg = ANTCFG_NONE;\n\tu8 fbantcfg = ANTCFG_NONE;\n\tuint phyctl1_stf = 0;\n\tu16 durid = 0;\n\tstruct ieee80211_tx_rate *txrate[2];\n\tint k;\n\tstruct ieee80211_tx_info *tx_info;\n\tbool is_mcs;\n\tu16 mimo_txbw;\n\tu8 mimo_preamble_type;\n\n\t \n\th = (struct ieee80211_hdr *)(p->data);\n\tqos = ieee80211_is_data_qos(h->frame_control);\n\n\t \n\tlen = p->len;\n\tphylen = len + FCS_LEN;\n\n\t \n\ttx_info = IEEE80211_SKB_CB(p);\n\n\t \n\tplcp = skb_push(p, D11_PHY_HDR_LEN);\n\n\t \n\ttxh = (struct d11txh *) skb_push(p, D11_TXH_LEN);\n\tmemset(txh, 0, D11_TXH_LEN);\n\n\t \n\tif (tx_info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ) {\n\t\t \n\t\tif (queue == TX_BCMC_FIFO) {\n\t\t\tbrcms_err(wlc->hw->d11core,\n\t\t\t\t  \"wl%d: %s: ASSERT queue == TX_BCMC!\\n\",\n\t\t\t\t  wlc->pub->unit, __func__);\n\t\t\tframeid = bcmc_fid_generate(wlc, NULL, txh);\n\t\t} else {\n\t\t\t \n\t\t\tif (tx_info->flags & IEEE80211_TX_CTL_FIRST_FRAGMENT)\n\t\t\t\tscb->seqnum[p->priority]++;\n\n\t\t\t \n\t\t\tseq = le16_to_cpu(h->seq_ctrl) & FRAGNUM_MASK;\n\t\t\tseq |= (scb->seqnum[p->priority] << SEQNUM_SHIFT);\n\t\t\th->seq_ctrl = cpu_to_le16(seq);\n\n\t\t\tframeid = ((seq << TXFID_SEQ_SHIFT) & TXFID_SEQ_MASK) |\n\t\t\t    (queue & TXFID_QUEUE_MASK);\n\t\t}\n\t}\n\tframeid |= queue & TXFID_QUEUE_MASK;\n\n\t \n\tif (ieee80211_is_beacon(h->frame_control))\n\t\tmcl |= TXC_IGNOREPMQ;\n\n\ttxrate[0] = tx_info->control.rates;\n\ttxrate[1] = txrate[0] + 1;\n\n\t \n\tif (txrate[1]->idx < 0)\n\t\ttxrate[1] = txrate[0];\n\n\tfor (k = 0; k < hw->max_rates; k++) {\n\t\tis_mcs = txrate[k]->flags & IEEE80211_TX_RC_MCS ? true : false;\n\t\tif (!is_mcs) {\n\t\t\tif ((txrate[k]->idx >= 0)\n\t\t\t    && (txrate[k]->idx <\n\t\t\t\thw->wiphy->bands[tx_info->band]->n_bitrates)) {\n\t\t\t\trspec[k] =\n\t\t\t\t    hw->wiphy->bands[tx_info->band]->\n\t\t\t\t    bitrates[txrate[k]->idx].hw_value;\n\t\t\t} else {\n\t\t\t\trspec[k] = BRCM_RATE_1M;\n\t\t\t}\n\t\t} else {\n\t\t\trspec[k] = mac80211_wlc_set_nrate(wlc, wlc->band,\n\t\t\t\t\tNRATE_MCS_INUSE | txrate[k]->idx);\n\t\t}\n\n\t\t \n\t\tuse_rts |=\n\t\t    txrate[k]->\n\t\t    flags & IEEE80211_TX_RC_USE_RTS_CTS ? true : false;\n\t\tuse_cts |=\n\t\t    txrate[k]->\n\t\t    flags & IEEE80211_TX_RC_USE_CTS_PROTECT ? true : false;\n\n\n\t\t \n\t\tif (!rspec_active(rspec[k])) {\n\t\t\trspec[k] = BRCM_RATE_1M;\n\t\t} else {\n\t\t\tif (!is_multicast_ether_addr(h->addr1)) {\n\t\t\t\t \n\t\t\t\tbrcms_c_antsel_antcfg_get(wlc->asi, false,\n\t\t\t\t\tfalse, 0, 0, &antcfg, &fbantcfg);\n\t\t\t}\n\t\t}\n\t}\n\n\tphyctl1_stf = wlc->stf->ss_opmode;\n\n\tif (wlc->pub->_n_enab & SUPPORT_11N) {\n\t\tfor (k = 0; k < hw->max_rates; k++) {\n\t\t\t \n\t\t\tif (((is_mcs_rate(rspec[k]) &&\n\t\t\t      is_single_stream(rspec[k] & RSPEC_RATE_MASK)) ||\n\t\t\t     is_ofdm_rate(rspec[k]))\n\t\t\t    && ((rspec[k] & RSPEC_OVERRIDE_MCS_ONLY)\n\t\t\t\t|| !(rspec[k] & RSPEC_OVERRIDE))) {\n\t\t\t\trspec[k] &= ~(RSPEC_STF_MASK | RSPEC_STC_MASK);\n\n\t\t\t\t \n\t\t\t\tif (is_mcs_rate(rspec[k])\n\t\t\t\t    && BRCMS_STF_SS_STBC_TX(wlc, scb)) {\n\t\t\t\t\tu8 stc;\n\n\t\t\t\t\t \n\t\t\t\t\tstc = 1;\n\t\t\t\t\trspec[k] |= (PHY_TXC1_MODE_STBC <<\n\t\t\t\t\t\t\tRSPEC_STF_SHIFT) |\n\t\t\t\t\t\t    (stc << RSPEC_STC_SHIFT);\n\t\t\t\t} else\n\t\t\t\t\trspec[k] |=\n\t\t\t\t\t    (phyctl1_stf << RSPEC_STF_SHIFT);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (brcms_chspec_bw(wlc->chanspec) == BRCMS_40_MHZ) {\n\t\t\t\t \n\t\t\t\tmimo_ctlchbw = mimo_txbw =\n\t\t\t\t   CHSPEC_SB_UPPER(wlc_phy_chanspec_get(\n\t\t\t\t\t\t\t\t wlc->band->pi))\n\t\t\t\t   ? PHY_TXC1_BW_20MHZ_UP : PHY_TXC1_BW_20MHZ;\n\n\t\t\t\tif (is_mcs_rate(rspec[k])) {\n\t\t\t\t\t \n\t\t\t\t\tif ((rspec[k] & RSPEC_RATE_MASK)\n\t\t\t\t\t    == 32) {\n\t\t\t\t\t\tmimo_txbw =\n\t\t\t\t\t\t    PHY_TXC1_BW_40MHZ_DUP;\n\t\t\t\t\t\t \n\t\t\t\t\t} else if (wlc->mimo_40txbw != AUTO)\n\t\t\t\t\t\tmimo_txbw = wlc->mimo_40txbw;\n\t\t\t\t\t \n\t\t\t\t\telse if (scb->flags & SCB_IS40)\n\t\t\t\t\t\tmimo_txbw = PHY_TXC1_BW_40MHZ;\n\t\t\t\t} else if (is_ofdm_rate(rspec[k])) {\n\t\t\t\t\tif (wlc->ofdm_40txbw != AUTO)\n\t\t\t\t\t\tmimo_txbw = wlc->ofdm_40txbw;\n\t\t\t\t} else if (wlc->cck_40txbw != AUTO) {\n\t\t\t\t\tmimo_txbw = wlc->cck_40txbw;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif ((rspec[k] & RSPEC_RATE_MASK) == 32)\n\t\t\t\t\t \n\t\t\t\t\trspec[k] = RSPEC_MIMORATE;\n\n\t\t\t\tmimo_txbw = PHY_TXC1_BW_20MHZ;\n\t\t\t}\n\n\t\t\t \n\t\t\trspec[k] &= ~RSPEC_BW_MASK;\n\t\t\tif ((k == 0) || ((k > 0) && is_mcs_rate(rspec[k])))\n\t\t\t\trspec[k] |= (mimo_txbw << RSPEC_BW_SHIFT);\n\t\t\telse\n\t\t\t\trspec[k] |= (mimo_ctlchbw << RSPEC_BW_SHIFT);\n\n\t\t\t \n\t\t\trspec[k] &= ~RSPEC_SHORT_GI;\n\n\t\t\tmimo_preamble_type = BRCMS_MM_PREAMBLE;\n\t\t\tif (txrate[k]->flags & IEEE80211_TX_RC_GREEN_FIELD)\n\t\t\t\tmimo_preamble_type = BRCMS_GF_PREAMBLE;\n\n\t\t\tif ((txrate[k]->flags & IEEE80211_TX_RC_MCS)\n\t\t\t    && (!is_mcs_rate(rspec[k]))) {\n\t\t\t\tbrcms_warn(wlc->hw->d11core,\n\t\t\t\t\t   \"wl%d: %s: IEEE80211_TX_RC_MCS != is_mcs_rate(rspec)\\n\",\n\t\t\t\t\t   wlc->pub->unit, __func__);\n\t\t\t}\n\n\t\t\tif (is_mcs_rate(rspec[k])) {\n\t\t\t\tpreamble_type[k] = mimo_preamble_type;\n\n\t\t\t\t \n\t\t\t\tif ((rspec[k] & RSPEC_SHORT_GI)\n\t\t\t\t    && is_single_stream(rspec[k] &\n\t\t\t\t\t\t\tRSPEC_RATE_MASK))\n\t\t\t\t\tpreamble_type[k] = BRCMS_MM_PREAMBLE;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!is_mcs_rate(rspec[0])\n\t\t\t    && (tx_info->control.rates[0].\n\t\t\t\tflags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE))\n\t\t\t\tpreamble_type[k] = BRCMS_SHORT_PREAMBLE;\n\t\t}\n\t} else {\n\t\tfor (k = 0; k < hw->max_rates; k++) {\n\t\t\t \n\t\t\trspec[k] &= ~RSPEC_BW_MASK;\n\t\t\trspec[k] |= (PHY_TXC1_BW_20MHZ << RSPEC_BW_SHIFT);\n\n\t\t\t \n\t\t\tif (BRCMS_ISNPHY(wlc->band) && is_ofdm_rate(rspec[k])) {\n\t\t\t\trspec[k] &= ~RSPEC_STF_MASK;\n\t\t\t\trspec[k] |= phyctl1_stf << RSPEC_STF_SHIFT;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\ttxrate[0]->count = 0;\n\ttxrate[1]->count = 0;\n\n\t \n\tif ((ieee80211_is_data(h->frame_control) ||\n\t    ieee80211_is_mgmt(h->frame_control)) &&\n\t    (phylen > wlc->RTSThresh) && !is_multicast_ether_addr(h->addr1))\n\t\tuse_rts = true;\n\n\t \n\tbrcms_c_compute_plcp(wlc, rspec[0], phylen, plcp);\n\tbrcms_c_compute_plcp(wlc, rspec[1], phylen, plcp_fallback);\n\tmemcpy(&txh->FragPLCPFallback,\n\t       plcp_fallback, sizeof(txh->FragPLCPFallback));\n\n\t \n\tif (is_cck_rate(rspec[1])) {\n\t\ttxh->FragPLCPFallback[4] = phylen & 0xff;\n\t\ttxh->FragPLCPFallback[5] = (phylen & 0xff00) >> 8;\n\t}\n\n\t \n\tmainrates = is_ofdm_rate(rspec[0]) ?\n\t\t\tD11A_PHY_HDR_GRATE((struct ofdm_phy_hdr *) plcp) :\n\t\t\tplcp[0];\n\n\t \n\tif (!ieee80211_is_pspoll(h->frame_control) &&\n\t    !is_multicast_ether_addr(h->addr1) && !use_rifs) {\n\t\tdurid =\n\t\t    brcms_c_compute_frame_dur(wlc, rspec[0], preamble_type[0],\n\t\t\t\t\t  next_frag_len);\n\t\th->duration_id = cpu_to_le16(durid);\n\t} else if (use_rifs) {\n\t\t \n\t\tdurid =\n\t\t    (u16) brcms_c_calc_frame_time(wlc, rspec[0],\n\t\t\t\t\t\t preamble_type[0],\n\t\t\t\t\t\t DOT11_MAX_FRAG_LEN);\n\t\tdurid += RIFS_11N_TIME;\n\t\th->duration_id = cpu_to_le16(durid);\n\t}\n\n\t \n\tif (ieee80211_is_pspoll(h->frame_control))\n\t\ttxh->FragDurFallback = h->duration_id;\n\telse if (is_multicast_ether_addr(h->addr1) || use_rifs)\n\t\ttxh->FragDurFallback = 0;\n\telse {\n\t\tdurid = brcms_c_compute_frame_dur(wlc, rspec[1],\n\t\t\t\t\t      preamble_type[1], next_frag_len);\n\t\ttxh->FragDurFallback = cpu_to_le16(durid);\n\t}\n\n\t \n\tif (frag == 0)\n\t\tmcl |= TXC_STARTMSDU;\n\n\tif (!is_multicast_ether_addr(h->addr1))\n\t\tmcl |= TXC_IMMEDACK;\n\n\tif (wlc->band->bandtype == BRCM_BAND_5G)\n\t\tmcl |= TXC_FREQBAND_5G;\n\n\tif (CHSPEC_IS40(wlc_phy_chanspec_get(wlc->band->pi)))\n\t\tmcl |= TXC_BW_40;\n\n\t \n\tif (hwtkmic)\n\t\tmcl |= TXC_AMIC;\n\n\ttxh->MacTxControlLow = cpu_to_le16(mcl);\n\n\t \n\tmch = 0;\n\n\t \n\tif ((preamble_type[1] == BRCMS_SHORT_PREAMBLE) ||\n\t    (preamble_type[1] == BRCMS_GF_PREAMBLE)) {\n\t\tif (rspec2rate(rspec[1]) != BRCM_RATE_1M)\n\t\t\tmch |= TXC_PREAMBLE_DATA_FB_SHORT;\n\t}\n\n\t \n\tmemcpy(&txh->MacFrameControl, &h->frame_control, sizeof(u16));\n\ttxh->TxFesTimeNormal = cpu_to_le16(0);\n\n\ttxh->TxFesTimeFallback = cpu_to_le16(0);\n\n\t \n\tmemcpy(&txh->TxFrameRA, &h->addr1, ETH_ALEN);\n\n\t \n\ttxh->TxFrameID = cpu_to_le16(frameid);\n\n\t \n\ttxh->TxStatus = cpu_to_le16(status);\n\n\t \n\ttxh->MaxNMpdus = cpu_to_le16(0);\n\ttxh->MaxABytes_MRT = cpu_to_le16(0);\n\ttxh->MaxABytes_FBR = cpu_to_le16(0);\n\ttxh->MinMBytes = cpu_to_le16(0);\n\n\t \n\t \n\tif (use_rts || use_cts) {\n\t\tif (use_rts && use_cts)\n\t\t\tuse_cts = false;\n\n\t\tfor (k = 0; k < 2; k++) {\n\t\t\trts_rspec[k] = brcms_c_rspec_to_rts_rspec(wlc, rspec[k],\n\t\t\t\t\t\t\t      false,\n\t\t\t\t\t\t\t      mimo_ctlchbw);\n\t\t}\n\n\t\tif (!is_ofdm_rate(rts_rspec[0]) &&\n\t\t    !((rspec2rate(rts_rspec[0]) == BRCM_RATE_1M) ||\n\t\t      (wlc->PLCPHdr_override == BRCMS_PLCP_LONG))) {\n\t\t\trts_preamble_type[0] = BRCMS_SHORT_PREAMBLE;\n\t\t\tmch |= TXC_PREAMBLE_RTS_MAIN_SHORT;\n\t\t}\n\n\t\tif (!is_ofdm_rate(rts_rspec[1]) &&\n\t\t    !((rspec2rate(rts_rspec[1]) == BRCM_RATE_1M) ||\n\t\t      (wlc->PLCPHdr_override == BRCMS_PLCP_LONG))) {\n\t\t\trts_preamble_type[1] = BRCMS_SHORT_PREAMBLE;\n\t\t\tmch |= TXC_PREAMBLE_RTS_FB_SHORT;\n\t\t}\n\n\t\t \n\t\tif (use_cts) {\n\t\t\ttxh->MacTxControlLow |= cpu_to_le16(TXC_SENDCTS);\n\t\t} else {\n\t\t\ttxh->MacTxControlLow |= cpu_to_le16(TXC_SENDRTS);\n\t\t\ttxh->MacTxControlLow |= cpu_to_le16(TXC_LONGFRAME);\n\t\t}\n\n\t\t \n\t\trts_plcp = txh->RTSPhyHeader;\n\t\tif (use_cts)\n\t\t\trts_phylen = DOT11_CTS_LEN + FCS_LEN;\n\t\telse\n\t\t\trts_phylen = DOT11_RTS_LEN + FCS_LEN;\n\n\t\tbrcms_c_compute_plcp(wlc, rts_rspec[0], rts_phylen, rts_plcp);\n\n\t\t \n\t\tbrcms_c_compute_plcp(wlc, rts_rspec[1], rts_phylen,\n\t\t\t\t rts_plcp_fallback);\n\t\tmemcpy(&txh->RTSPLCPFallback, rts_plcp_fallback,\n\t\t       sizeof(txh->RTSPLCPFallback));\n\n\t\t \n\t\trts = (struct ieee80211_rts *)&txh->rts_frame;\n\n\t\tdurid = brcms_c_compute_rtscts_dur(wlc, use_cts, rts_rspec[0],\n\t\t\t\t\t       rspec[0], rts_preamble_type[0],\n\t\t\t\t\t       preamble_type[0], phylen, false);\n\t\trts->duration = cpu_to_le16(durid);\n\t\t \n\t\tdurid = brcms_c_compute_rtscts_dur(wlc, use_cts,\n\t\t\t\t\t       rts_rspec[1], rspec[1],\n\t\t\t\t\t       rts_preamble_type[1],\n\t\t\t\t\t       preamble_type[1], phylen, false);\n\t\ttxh->RTSDurFallback = cpu_to_le16(durid);\n\n\t\tif (use_cts) {\n\t\t\trts->frame_control = cpu_to_le16(IEEE80211_FTYPE_CTL |\n\t\t\t\t\t\t\t IEEE80211_STYPE_CTS);\n\n\t\t\tmemcpy(&rts->ra, &h->addr2, ETH_ALEN);\n\t\t} else {\n\t\t\trts->frame_control = cpu_to_le16(IEEE80211_FTYPE_CTL |\n\t\t\t\t\t\t\t IEEE80211_STYPE_RTS);\n\n\t\t\tmemcpy(&rts->ra, &h->addr1, ETH_ALEN);\n\t\t\tmemcpy(&rts->ta, &h->addr2, ETH_ALEN);\n\t\t}\n\n\t\t \n\t\tmainrates |= (is_ofdm_rate(rts_rspec[0]) ?\n\t\t\t\tD11A_PHY_HDR_GRATE(\n\t\t\t\t\t(struct ofdm_phy_hdr *) rts_plcp) :\n\t\t\t\trts_plcp[0]) << 8;\n\t} else {\n\t\tmemset(txh->RTSPhyHeader, 0, D11_PHY_HDR_LEN);\n\t\tmemset(&txh->rts_frame, 0, sizeof(struct ieee80211_rts));\n\t\tmemset(txh->RTSPLCPFallback, 0, sizeof(txh->RTSPLCPFallback));\n\t\ttxh->RTSDurFallback = 0;\n\t}\n\n#ifdef SUPPORT_40MHZ\n\t \n\tif ((tx_info->flags & IEEE80211_TX_CTL_AMPDU) && is_mcs_rate(rspec))\n\t\ttxh->RTSPLCPFallback[AMPDU_FBR_NULL_DELIM] =\n\t\t   brcm_c_ampdu_null_delim_cnt(wlc->ampdu, scb, rspec, phylen);\n\n#endif\n\n\t \n\ttxh->MacTxControlHigh = cpu_to_le16(mch);\n\n\t \n\ttxh->MainRates = cpu_to_le16(mainrates);\n\n\t \n\txfts = frametype(rspec[1], wlc->mimoft);\n\txfts |= (frametype(rts_rspec[0], wlc->mimoft) << XFTS_RTS_FT_SHIFT);\n\txfts |= (frametype(rts_rspec[1], wlc->mimoft) << XFTS_FBRRTS_FT_SHIFT);\n\txfts |= CHSPEC_CHANNEL(wlc_phy_chanspec_get(wlc->band->pi)) <<\n\t\t\t\t\t\t\t     XFTS_CHANNEL_SHIFT;\n\ttxh->XtraFrameTypes = cpu_to_le16(xfts);\n\n\t \n\tphyctl = frametype(rspec[0], wlc->mimoft);\n\tif ((preamble_type[0] == BRCMS_SHORT_PREAMBLE) ||\n\t    (preamble_type[0] == BRCMS_GF_PREAMBLE)) {\n\t\tif (rspec2rate(rspec[0]) != BRCM_RATE_1M)\n\t\t\tphyctl |= PHY_TXC_SHORT_HDR;\n\t}\n\n\t \n\tphyctl |= brcms_c_stf_d11hdrs_phyctl_txant(wlc, rspec[0]);\n\ttxh->PhyTxControlWord = cpu_to_le16(phyctl);\n\n\t \n\tif (BRCMS_PHY_11N_CAP(wlc->band)) {\n\t\tu16 phyctl1 = 0;\n\n\t\tphyctl1 = brcms_c_phytxctl1_calc(wlc, rspec[0]);\n\t\ttxh->PhyTxControlWord_1 = cpu_to_le16(phyctl1);\n\t\tphyctl1 = brcms_c_phytxctl1_calc(wlc, rspec[1]);\n\t\ttxh->PhyTxControlWord_1_Fbr = cpu_to_le16(phyctl1);\n\n\t\tif (use_rts || use_cts) {\n\t\t\tphyctl1 = brcms_c_phytxctl1_calc(wlc, rts_rspec[0]);\n\t\t\ttxh->PhyTxControlWord_1_Rts = cpu_to_le16(phyctl1);\n\t\t\tphyctl1 = brcms_c_phytxctl1_calc(wlc, rts_rspec[1]);\n\t\t\ttxh->PhyTxControlWord_1_FbrRts = cpu_to_le16(phyctl1);\n\t\t}\n\n\t\t \n\t\tif (is_mcs_rate(rspec[0]) &&\n\t\t    (preamble_type[0] == BRCMS_MM_PREAMBLE)) {\n\t\t\tu16 mmodelen =\n\t\t\t    brcms_c_calc_lsig_len(wlc, rspec[0], phylen);\n\t\t\ttxh->MModeLen = cpu_to_le16(mmodelen);\n\t\t}\n\n\t\tif (is_mcs_rate(rspec[1]) &&\n\t\t    (preamble_type[1] == BRCMS_MM_PREAMBLE)) {\n\t\t\tu16 mmodefbrlen =\n\t\t\t    brcms_c_calc_lsig_len(wlc, rspec[1], phylen);\n\t\t\ttxh->MModeFbrLen = cpu_to_le16(mmodefbrlen);\n\t\t}\n\t}\n\n\tac = skb_get_queue_mapping(p);\n\tif ((scb->flags & SCB_WMECAP) && qos && wlc->edcf_txop[ac]) {\n\t\tuint frag_dur, dur, dur_fallback;\n\n\t\t \n\t\tif (!(tx_info->flags & IEEE80211_TX_CTL_AMPDU) && frag == 0) {\n\t\t\tfrag_dur =\n\t\t\t    brcms_c_calc_frame_time(wlc, rspec[0],\n\t\t\t\t\tpreamble_type[0], phylen);\n\n\t\t\tif (rts) {\n\t\t\t\t \n\t\t\t\tdur =\n\t\t\t\t    brcms_c_calc_cts_time(wlc, rts_rspec[0],\n\t\t\t\t\t\t      rts_preamble_type[0]);\n\t\t\t\tdur_fallback =\n\t\t\t\t    brcms_c_calc_cts_time(wlc, rts_rspec[1],\n\t\t\t\t\t\t      rts_preamble_type[1]);\n\t\t\t\t \n\t\t\t\tdur += le16_to_cpu(rts->duration);\n\t\t\t\tdur_fallback +=\n\t\t\t\t\tle16_to_cpu(txh->RTSDurFallback);\n\t\t\t} else if (use_rifs) {\n\t\t\t\tdur = frag_dur;\n\t\t\t\tdur_fallback = 0;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdur = frag_dur;\n\t\t\t\tdur +=\n\t\t\t\t    brcms_c_compute_frame_dur(wlc, rspec[0],\n\t\t\t\t\t\t\t  preamble_type[0], 0);\n\n\t\t\t\tdur_fallback =\n\t\t\t\t    brcms_c_calc_frame_time(wlc, rspec[1],\n\t\t\t\t\t\t\tpreamble_type[1],\n\t\t\t\t\t\t\tphylen);\n\t\t\t\tdur_fallback +=\n\t\t\t\t    brcms_c_compute_frame_dur(wlc, rspec[1],\n\t\t\t\t\t\t\t  preamble_type[1], 0);\n\t\t\t}\n\t\t\t \n\t\t\ttxh->TxFesTimeNormal = cpu_to_le16((u16) dur);\n\t\t\t \n\t\t\ttxh->TxFesTimeFallback =\n\t\t\t\tcpu_to_le16((u16) dur_fallback);\n\n\t\t\t \n\t\t\tif (wlc->edcf_txop[ac] >= (dur - frag_dur)) {\n\t\t\t\tuint newfragthresh;\n\n\t\t\t\tnewfragthresh =\n\t\t\t\t    brcms_c_calc_frame_len(wlc,\n\t\t\t\t\trspec[0], preamble_type[0],\n\t\t\t\t\t(wlc->edcf_txop[ac] -\n\t\t\t\t\t\t(dur - frag_dur)));\n\t\t\t\t \n\t\t\t\tif (newfragthresh < DOT11_MIN_FRAG_LEN)\n\t\t\t\t\tnewfragthresh =\n\t\t\t\t\t    DOT11_MIN_FRAG_LEN;\n\t\t\t\telse if (newfragthresh >\n\t\t\t\t\t wlc->usr_fragthresh)\n\t\t\t\t\tnewfragthresh =\n\t\t\t\t\t    wlc->usr_fragthresh;\n\t\t\t\t \n\t\t\t\tif (wlc->fragthresh[queue] !=\n\t\t\t\t    (u16) newfragthresh)\n\t\t\t\t\twlc->fragthresh[queue] =\n\t\t\t\t\t    (u16) newfragthresh;\n\t\t\t} else {\n\t\t\t\tbrcms_warn(wlc->hw->d11core,\n\t\t\t\t\t   \"wl%d: %s txop invalid for rate %d\\n\",\n\t\t\t\t\t   wlc->pub->unit, fifo_names[queue],\n\t\t\t\t\t   rspec2rate(rspec[0]));\n\t\t\t}\n\n\t\t\tif (dur > wlc->edcf_txop[ac])\n\t\t\t\tbrcms_warn(wlc->hw->d11core,\n\t\t\t\t\t   \"wl%d: %s: %s txop exceeded phylen %d/%d dur %d/%d\\n\",\n\t\t\t\t\t   wlc->pub->unit, __func__,\n\t\t\t\t\t   fifo_names[queue],\n\t\t\t\t\t   phylen, wlc->fragthresh[queue],\n\t\t\t\t\t   dur, wlc->edcf_txop[ac]);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int brcms_c_tx(struct brcms_c_info *wlc, struct sk_buff *skb)\n{\n\tstruct dma_pub *dma;\n\tint fifo, ret = -ENOSPC;\n\tstruct d11txh *txh;\n\tu16 frameid = INVALIDFID;\n\n\tfifo = brcms_ac_to_fifo(skb_get_queue_mapping(skb));\n\tdma = wlc->hw->di[fifo];\n\ttxh = (struct d11txh *)(skb->data);\n\n\tif (dma->txavail == 0) {\n\t\t \n\t\tbrcms_warn(wlc->hw->d11core,\n\t\t\t   \"Received frame for tx with no space in DMA ring\\n\");\n\t\tWARN_ON(!ieee80211_queue_stopped(wlc->pub->ieee_hw,\n\t\t\t\t\t\t skb_get_queue_mapping(skb)));\n\t\treturn -ENOSPC;\n\t}\n\n\t \n\tif (fifo == TX_BCMC_FIFO)\n\t\tframeid = le16_to_cpu(txh->TxFrameID);\n\n\t \n\tif (frameid != INVALIDFID) {\n\t\t \n\t\tbrcms_b_write_shm(wlc->hw, M_BCMC_FID, frameid);\n\t}\n\n\tret = brcms_c_txfifo(wlc, fifo, skb);\n\t \n\tWARN_ON_ONCE(ret);\n\n\treturn ret;\n}\n\nbool brcms_c_sendpkt_mac80211(struct brcms_c_info *wlc, struct sk_buff *sdu,\n\t\t\t      struct ieee80211_hw *hw)\n{\n\tuint fifo;\n\tstruct scb *scb = &wlc->pri_scb;\n\n\tfifo = brcms_ac_to_fifo(skb_get_queue_mapping(sdu));\n\tbrcms_c_d11hdrs_mac80211(wlc, hw, sdu, scb, 0, 1, fifo, 0);\n\tif (!brcms_c_tx(wlc, sdu))\n\t\treturn true;\n\n\t \n\tdev_kfree_skb_any(sdu);\n\treturn false;\n}\n\nint\nbrcms_c_txfifo(struct brcms_c_info *wlc, uint fifo, struct sk_buff *p)\n{\n\tstruct dma_pub *dma = wlc->hw->di[fifo];\n\tint ret;\n\tu16 queue;\n\n\tret = dma_txfast(wlc, dma, p);\n\tif (ret\t< 0)\n\t\twiphy_err(wlc->wiphy, \"txfifo: fatal, toss frames !!!\\n\");\n\n\t \n\tqueue = skb_get_queue_mapping(p);\n\tif (dma->txavail <= TX_HEADROOM && fifo < TX_BCMC_FIFO &&\n\t    !ieee80211_queue_stopped(wlc->pub->ieee_hw, queue))\n\t\tieee80211_stop_queue(wlc->pub->ieee_hw, queue);\n\n\treturn ret;\n}\n\nu32\nbrcms_c_rspec_to_rts_rspec(struct brcms_c_info *wlc, u32 rspec,\n\t\t\t   bool use_rspec, u16 mimo_ctlchbw)\n{\n\tu32 rts_rspec = 0;\n\n\tif (use_rspec)\n\t\t \n\t\trts_rspec = rspec;\n\telse if (wlc->band->gmode && wlc->protection->_g && !is_cck_rate(rspec))\n\t\t \n\t\trts_rspec = brcms_basic_rate(wlc, BRCM_RATE_11M);\n\telse\n\t\t \n\t\trts_rspec = brcms_basic_rate(wlc, rspec);\n\n\tif (BRCMS_PHY_11N_CAP(wlc->band)) {\n\t\t \n\t\trts_rspec &= ~RSPEC_BW_MASK;\n\n\t\t \n\t\tif (rspec_is40mhz(rspec) && !is_cck_rate(rts_rspec))\n\t\t\trts_rspec |= (PHY_TXC1_BW_40MHZ_DUP << RSPEC_BW_SHIFT);\n\t\telse\n\t\t\trts_rspec |= (mimo_ctlchbw << RSPEC_BW_SHIFT);\n\n\t\t \n\t\tif (is_ofdm_rate(rts_rspec)) {\n\t\t\trts_rspec &= ~RSPEC_STF_MASK;\n\t\t\trts_rspec |= (wlc->stf->ss_opmode << RSPEC_STF_SHIFT);\n\t\t}\n\t}\n\treturn rts_rspec;\n}\n\n \nstatic void brcms_c_bcn_li_upd(struct brcms_c_info *wlc)\n{\n\t \n\tif (wlc->bcn_li_dtim == 1)\n\t\tbrcms_b_write_shm(wlc->hw, M_BCN_LI, 0);\n\telse\n\t\tbrcms_b_write_shm(wlc->hw, M_BCN_LI,\n\t\t\t      (wlc->bcn_li_dtim << 8) | wlc->bcn_li_bcn);\n}\n\nstatic void\nbrcms_b_read_tsf(struct brcms_hardware *wlc_hw, u32 *tsf_l_ptr,\n\t\t  u32 *tsf_h_ptr)\n{\n\tstruct bcma_device *core = wlc_hw->d11core;\n\n\t \n\t*tsf_l_ptr = bcma_read32(core, D11REGOFFS(tsf_timerlow));\n\t*tsf_h_ptr = bcma_read32(core, D11REGOFFS(tsf_timerhigh));\n}\n\n \nstatic u64 brcms_c_recover_tsf64(struct brcms_c_info *wlc,\n\t\t\t\t struct d11rxhdr *rxh)\n{\n\tu32 tsf_h, tsf_l;\n\tu16 rx_tsf_0_15, rx_tsf_16_31;\n\n\tbrcms_b_read_tsf(wlc->hw, &tsf_l, &tsf_h);\n\n\trx_tsf_16_31 = (u16)(tsf_l >> 16);\n\trx_tsf_0_15 = rxh->RxTSFTime;\n\n\t \n\tif ((u16)tsf_l < rx_tsf_0_15) {\n\t\trx_tsf_16_31 -= 1;\n\t\tif (rx_tsf_16_31 == 0xffff)\n\t\t\ttsf_h -= 1;\n\t}\n\n\treturn ((u64)tsf_h << 32) | (((u32)rx_tsf_16_31 << 16) + rx_tsf_0_15);\n}\n\nstatic void\nprep_mac80211_status(struct brcms_c_info *wlc, struct d11rxhdr *rxh,\n\t\t     struct sk_buff *p,\n\t\t     struct ieee80211_rx_status *rx_status)\n{\n\tint channel;\n\tu32 rspec;\n\tunsigned char *plcp;\n\n\t \n\trx_status->mactime = brcms_c_recover_tsf64(wlc, rxh);\n\trx_status->flag |= RX_FLAG_MACTIME_START;\n\n\tchannel = BRCMS_CHAN_CHANNEL(rxh->RxChan);\n\n\trx_status->band =\n\t\tchannel > 14 ? NL80211_BAND_5GHZ : NL80211_BAND_2GHZ;\n\trx_status->freq =\n\t\tieee80211_channel_to_frequency(channel, rx_status->band);\n\n\trx_status->signal = wlc_phy_rssi_compute(wlc->hw->band->pi, rxh);\n\n\t \n\t \n\trx_status->antenna =\n\t\t(rxh->PhyRxStatus_0 & PRXS0_RXANT_UPSUBBAND) ? 1 : 0;\n\n\tplcp = p->data;\n\n\trspec = brcms_c_compute_rspec(rxh, plcp);\n\tif (is_mcs_rate(rspec)) {\n\t\trx_status->rate_idx = rspec & RSPEC_RATE_MASK;\n\t\trx_status->encoding = RX_ENC_HT;\n\t\tif (rspec_is40mhz(rspec))\n\t\t\trx_status->bw = RATE_INFO_BW_40;\n\t} else {\n\t\tswitch (rspec2rate(rspec)) {\n\t\tcase BRCM_RATE_1M:\n\t\t\trx_status->rate_idx = 0;\n\t\t\tbreak;\n\t\tcase BRCM_RATE_2M:\n\t\t\trx_status->rate_idx = 1;\n\t\t\tbreak;\n\t\tcase BRCM_RATE_5M5:\n\t\t\trx_status->rate_idx = 2;\n\t\t\tbreak;\n\t\tcase BRCM_RATE_11M:\n\t\t\trx_status->rate_idx = 3;\n\t\t\tbreak;\n\t\tcase BRCM_RATE_6M:\n\t\t\trx_status->rate_idx = 4;\n\t\t\tbreak;\n\t\tcase BRCM_RATE_9M:\n\t\t\trx_status->rate_idx = 5;\n\t\t\tbreak;\n\t\tcase BRCM_RATE_12M:\n\t\t\trx_status->rate_idx = 6;\n\t\t\tbreak;\n\t\tcase BRCM_RATE_18M:\n\t\t\trx_status->rate_idx = 7;\n\t\t\tbreak;\n\t\tcase BRCM_RATE_24M:\n\t\t\trx_status->rate_idx = 8;\n\t\t\tbreak;\n\t\tcase BRCM_RATE_36M:\n\t\t\trx_status->rate_idx = 9;\n\t\t\tbreak;\n\t\tcase BRCM_RATE_48M:\n\t\t\trx_status->rate_idx = 10;\n\t\t\tbreak;\n\t\tcase BRCM_RATE_54M:\n\t\t\trx_status->rate_idx = 11;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbrcms_err(wlc->hw->d11core,\n\t\t\t\t  \"%s: Unknown rate\\n\", __func__);\n\t\t}\n\n\t\t \n\t\tif (rx_status->band == NL80211_BAND_5GHZ)\n\t\t\trx_status->rate_idx -= BRCMS_LEGACY_5G_RATE_OFFSET;\n\n\t\t \n\t\tif (is_cck_rate(rspec)) {\n\t\t\tif (rxh->PhyRxStatus_0 & PRXS0_SHORTH)\n\t\t\t\trx_status->enc_flags |= RX_ENC_FLAG_SHORTPRE;\n\t\t} else if (is_ofdm_rate(rspec)) {\n\t\t\trx_status->enc_flags |= RX_ENC_FLAG_SHORTPRE;\n\t\t} else {\n\t\t\tbrcms_err(wlc->hw->d11core, \"%s: Unknown modulation\\n\",\n\t\t\t\t  __func__);\n\t\t}\n\t}\n\n\tif (plcp3_issgi(plcp[3]))\n\t\trx_status->enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\n\tif (rxh->RxStatus1 & RXS_DECERR) {\n\t\trx_status->flag |= RX_FLAG_FAILED_PLCP_CRC;\n\t\tbrcms_err(wlc->hw->d11core, \"%s:  RX_FLAG_FAILED_PLCP_CRC\\n\",\n\t\t\t  __func__);\n\t}\n\tif (rxh->RxStatus1 & RXS_FCSERR) {\n\t\trx_status->flag |= RX_FLAG_FAILED_FCS_CRC;\n\t\tbrcms_err(wlc->hw->d11core, \"%s:  RX_FLAG_FAILED_FCS_CRC\\n\",\n\t\t\t  __func__);\n\t}\n}\n\nstatic void\nbrcms_c_recvctl(struct brcms_c_info *wlc, struct d11rxhdr *rxh,\n\t\tstruct sk_buff *p)\n{\n\tint len_mpdu;\n\tstruct ieee80211_rx_status rx_status;\n\tstruct ieee80211_hdr *hdr;\n\n\tmemset(&rx_status, 0, sizeof(rx_status));\n\tprep_mac80211_status(wlc, rxh, p, &rx_status);\n\n\t \n\tlen_mpdu = p->len - D11_PHY_HDR_LEN - FCS_LEN;\n\tskb_pull(p, D11_PHY_HDR_LEN);\n\t__skb_trim(p, len_mpdu);\n\n\t \n\tif (wlc->hw->suspended_fifos) {\n\t\thdr = (struct ieee80211_hdr *)p->data;\n\t\tif (ieee80211_is_beacon(hdr->frame_control))\n\t\t\tbrcms_b_mute(wlc->hw, false);\n\t}\n\n\tmemcpy(IEEE80211_SKB_RXCB(p), &rx_status, sizeof(rx_status));\n\tieee80211_rx_irqsafe(wlc->pub->ieee_hw, p);\n}\n\n \nu16\nbrcms_c_calc_lsig_len(struct brcms_c_info *wlc, u32 ratespec,\n\t\t      uint mac_len)\n{\n\tuint nsyms, len = 0, kNdps;\n\n\tif (is_mcs_rate(ratespec)) {\n\t\tuint mcs = ratespec & RSPEC_RATE_MASK;\n\t\tint tot_streams = (mcs_2_txstreams(mcs) + 1) +\n\t\t\t\t  rspec_stc(ratespec);\n\n\t\t \n\t\t \n\t\tkNdps = mcs_2_rate(mcs, rspec_is40mhz(ratespec),\n\t\t\t\t   rspec_issgi(ratespec)) * 4;\n\n\t\tif (rspec_stc(ratespec) == 0)\n\t\t\tnsyms =\n\t\t\t    CEIL((APHY_SERVICE_NBITS + 8 * mac_len +\n\t\t\t\t  APHY_TAIL_NBITS) * 1000, kNdps);\n\t\telse\n\t\t\t \n\t\t\tnsyms =\n\t\t\t    2 *\n\t\t\t    CEIL((APHY_SERVICE_NBITS + 8 * mac_len +\n\t\t\t\t  APHY_TAIL_NBITS) * 1000, 2 * kNdps);\n\n\t\t \n\t\tnsyms += (tot_streams + 3);\n\t\t \n\t\tlen = (3 * nsyms) - 3;\n\t}\n\n\treturn (u16) len;\n}\n\nstatic void\nbrcms_c_mod_prb_rsp_rate_table(struct brcms_c_info *wlc, uint frame_len)\n{\n\tconst struct brcms_c_rateset *rs_dflt;\n\tstruct brcms_c_rateset rs;\n\tu8 rate;\n\tu16 entry_ptr;\n\tu8 plcp[D11_PHY_HDR_LEN];\n\tu16 dur, sifs;\n\tuint i;\n\n\tsifs = get_sifs(wlc->band);\n\n\trs_dflt = brcms_c_rateset_get_hwrs(wlc);\n\n\tbrcms_c_rateset_copy(rs_dflt, &rs);\n\tbrcms_c_rateset_mcs_upd(&rs, wlc->stf->txstreams);\n\n\t \n\tfor (i = 0; i < rs.count; i++) {\n\t\trate = rs.rates[i] & BRCMS_RATE_MASK;\n\n\t\tentry_ptr = brcms_b_rate_shm_offset(wlc->hw, rate);\n\n\t\t \n\t\tbrcms_c_compute_plcp(wlc, rate, frame_len, plcp);\n\n\t\t \n\t\tdur = (u16) brcms_c_calc_frame_time(wlc, rate,\n\t\t\t\t\t\tBRCMS_LONG_PREAMBLE, frame_len);\n\t\tdur += sifs;\n\n\t\t \n\t\tbrcms_b_write_shm(wlc->hw, entry_ptr + M_RT_PRS_PLCP_POS,\n\t\t\t      (u16) (plcp[0] + (plcp[1] << 8)));\n\t\tbrcms_b_write_shm(wlc->hw, entry_ptr + M_RT_PRS_PLCP_POS + 2,\n\t\t\t      (u16) (plcp[2] + (plcp[3] << 8)));\n\t\tbrcms_b_write_shm(wlc->hw, entry_ptr + M_RT_PRS_DUR_POS, dur);\n\t}\n}\n\nint brcms_c_get_header_len(void)\n{\n\treturn TXOFF;\n}\n\nstatic void brcms_c_beacon_write(struct brcms_c_info *wlc,\n\t\t\t\t struct sk_buff *beacon, u16 tim_offset,\n\t\t\t\t u16 dtim_period, bool bcn0, bool bcn1)\n{\n\tsize_t len;\n\tstruct ieee80211_tx_info *tx_info;\n\tstruct brcms_hardware *wlc_hw = wlc->hw;\n\tstruct ieee80211_hw *ieee_hw = brcms_c_pub(wlc)->ieee_hw;\n\n\t \n\ttx_info = IEEE80211_SKB_CB(beacon);\n\n\tlen = min_t(size_t, beacon->len, BCN_TMPL_LEN);\n\twlc->bcn_rspec = ieee80211_get_tx_rate(ieee_hw, tx_info)->hw_value;\n\n\tbrcms_c_compute_plcp(wlc, wlc->bcn_rspec,\n\t\t\t     len + FCS_LEN - D11_PHY_HDR_LEN, beacon->data);\n\n\t \n\t \n\tbrcms_c_beacon_phytxctl_txant_upd(wlc, wlc->bcn_rspec);\n\n\tif (bcn0) {\n\t\t \n\t\tbrcms_b_write_template_ram(wlc_hw, T_BCN0_TPL_BASE,\n\t\t\t\t\t    (len + 3) & ~3, beacon->data);\n\n\t\t \n\t\tbrcms_b_write_shm(wlc_hw, M_BCN0_FRM_BYTESZ, (u16) len);\n\t}\n\tif (bcn1) {\n\t\t \n\t\tbrcms_b_write_template_ram(wlc_hw, T_BCN1_TPL_BASE,\n\t\t\t\t\t    (len + 3) & ~3, beacon->data);\n\n\t\t \n\t\tbrcms_b_write_shm(wlc_hw, M_BCN1_FRM_BYTESZ, (u16) len);\n\t}\n\n\tif (tim_offset != 0) {\n\t\tbrcms_b_write_shm(wlc_hw, M_TIMBPOS_INBEACON,\n\t\t\t\t  tim_offset + D11B_PHY_HDR_LEN);\n\t\tbrcms_b_write_shm(wlc_hw, M_DOT11_DTIMPERIOD, dtim_period);\n\t} else {\n\t\tbrcms_b_write_shm(wlc_hw, M_TIMBPOS_INBEACON,\n\t\t\t\t  len + D11B_PHY_HDR_LEN);\n\t\tbrcms_b_write_shm(wlc_hw, M_DOT11_DTIMPERIOD, 0);\n\t}\n}\n\nstatic void brcms_c_update_beacon_hw(struct brcms_c_info *wlc,\n\t\t\t\t     struct sk_buff *beacon, u16 tim_offset,\n\t\t\t\t     u16 dtim_period)\n{\n\tstruct brcms_hardware *wlc_hw = wlc->hw;\n\tstruct bcma_device *core = wlc_hw->d11core;\n\n\t \n\tu32 both_valid = MCMD_BCN0VLD | MCMD_BCN1VLD;\n\n\t \n\tif ((bcma_read32(core, D11REGOFFS(maccommand)) & both_valid) == both_valid)\n\t\t \n\t\tbcma_write32(core, D11REGOFFS(macintstatus), MI_BCNTPL);\n\n\tif (wlc->beacon_template_virgin) {\n\t\twlc->beacon_template_virgin = false;\n\t\tbrcms_c_beacon_write(wlc, beacon, tim_offset, dtim_period, true,\n\t\t\t\t     true);\n\t\t \n\t\tbcma_set32(core, D11REGOFFS(maccommand), MCMD_BCN0VLD);\n\t\treturn;\n\t}\n\n\t \n\tif ((bcma_read32(core, D11REGOFFS(maccommand)) & both_valid) == both_valid) {\n\t\twlc->defmacintmask |= MI_BCNTPL;\n\t\treturn;\n\t}\n\n\tif (!(bcma_read32(core, D11REGOFFS(maccommand)) & MCMD_BCN0VLD)) {\n\t\tbrcms_c_beacon_write(wlc, beacon, tim_offset, dtim_period, true,\n\t\t\t\t     false);\n\t\t \n\t\tbcma_set32(core, D11REGOFFS(maccommand), MCMD_BCN0VLD);\n\t\treturn;\n\t}\n\tif (!(bcma_read32(core, D11REGOFFS(maccommand)) & MCMD_BCN1VLD)) {\n\t\tbrcms_c_beacon_write(wlc, beacon, tim_offset, dtim_period,\n\t\t\t\t     false, true);\n\t\t \n\t\tbcma_set32(core, D11REGOFFS(maccommand), MCMD_BCN1VLD);\n\t}\n}\n\n \nvoid brcms_c_update_beacon(struct brcms_c_info *wlc)\n{\n\tstruct brcms_bss_cfg *bsscfg = wlc->bsscfg;\n\n\tif (wlc->pub->up && (bsscfg->type == BRCMS_TYPE_AP ||\n\t\t\t     bsscfg->type == BRCMS_TYPE_ADHOC)) {\n\t\t \n\t\twlc->defmacintmask &= ~MI_BCNTPL;\n\t\tif (!wlc->beacon)\n\t\t\treturn;\n\t\tbrcms_c_update_beacon_hw(wlc, wlc->beacon,\n\t\t\t\t\t wlc->beacon_tim_offset,\n\t\t\t\t\t wlc->beacon_dtim_period);\n\t}\n}\n\nvoid brcms_c_set_new_beacon(struct brcms_c_info *wlc, struct sk_buff *beacon,\n\t\t\t    u16 tim_offset, u16 dtim_period)\n{\n\tif (!beacon)\n\t\treturn;\n\tif (wlc->beacon)\n\t\tdev_kfree_skb_any(wlc->beacon);\n\twlc->beacon = beacon;\n\n\t \n\tskb_push(wlc->beacon, D11_PHY_HDR_LEN);\n\twlc->beacon_tim_offset = tim_offset;\n\twlc->beacon_dtim_period = dtim_period;\n\tbrcms_c_update_beacon(wlc);\n}\n\nvoid brcms_c_set_new_probe_resp(struct brcms_c_info *wlc,\n\t\t\t\tstruct sk_buff *probe_resp)\n{\n\tif (!probe_resp)\n\t\treturn;\n\tif (wlc->probe_resp)\n\t\tdev_kfree_skb_any(wlc->probe_resp);\n\twlc->probe_resp = probe_resp;\n\n\t \n\tskb_push(wlc->probe_resp, D11_PHY_HDR_LEN);\n\tbrcms_c_update_probe_resp(wlc, false);\n}\n\nvoid brcms_c_enable_probe_resp(struct brcms_c_info *wlc, bool enable)\n{\n\t \n\twlc->prb_resp_timeout = enable ? BRCMS_PRB_RESP_TIMEOUT : 1;\n\tbrcms_b_write_shm(wlc->hw, M_PRS_MAXTIME, wlc->prb_resp_timeout);\n\t \n}\n\n \nstatic void\nbrcms_c_shm_ssid_upd(struct brcms_c_info *wlc, struct brcms_bss_cfg *cfg)\n{\n\tu8 *ssidptr = cfg->SSID;\n\tu16 base = M_SSID;\n\tu8 ssidbuf[IEEE80211_MAX_SSID_LEN];\n\n\t \n\tmemset(ssidbuf, 0, IEEE80211_MAX_SSID_LEN);\n\tmemcpy(ssidbuf, ssidptr, cfg->SSID_len);\n\n\tbrcms_c_copyto_shm(wlc, base, ssidbuf, IEEE80211_MAX_SSID_LEN);\n\tbrcms_b_write_shm(wlc->hw, M_SSIDLEN, (u16) cfg->SSID_len);\n}\n\nstatic void\nbrcms_c_bss_update_probe_resp(struct brcms_c_info *wlc,\n\t\t\t      struct brcms_bss_cfg *cfg,\n\t\t\t      struct sk_buff *probe_resp,\n\t\t\t      bool suspend)\n{\n\tint len;\n\n\tlen = min_t(size_t, probe_resp->len, BCN_TMPL_LEN);\n\n\tif (suspend)\n\t\tbrcms_c_suspend_mac_and_wait(wlc);\n\n\t \n\tbrcms_b_write_template_ram(wlc->hw, T_PRS_TPL_BASE,\n\t\t\t\t    (len + 3) & ~3, probe_resp->data);\n\n\t \n\tbrcms_b_write_shm(wlc->hw, M_PRB_RESP_FRM_LEN, (u16) len);\n\n\t \n\tbrcms_c_shm_ssid_upd(wlc, cfg);\n\n\t \n\tbrcms_c_mod_prb_rsp_rate_table(wlc,\n\t\t\t\t      (u16)len + FCS_LEN - D11_PHY_HDR_LEN);\n\n\tif (suspend)\n\t\tbrcms_c_enable_mac(wlc);\n}\n\nvoid brcms_c_update_probe_resp(struct brcms_c_info *wlc, bool suspend)\n{\n\tstruct brcms_bss_cfg *bsscfg = wlc->bsscfg;\n\n\t \n\tif (wlc->pub->up && (bsscfg->type == BRCMS_TYPE_AP ||\n\t\t\t     bsscfg->type == BRCMS_TYPE_ADHOC)) {\n\t\tif (!wlc->probe_resp)\n\t\t\treturn;\n\t\tbrcms_c_bss_update_probe_resp(wlc, bsscfg, wlc->probe_resp,\n\t\t\t\t\t      suspend);\n\t}\n}\n\nint brcms_b_xmtfifo_sz_get(struct brcms_hardware *wlc_hw, uint fifo,\n\t\t\t   uint *blocks)\n{\n\tif (fifo >= NFIFO)\n\t\treturn -EINVAL;\n\n\t*blocks = wlc_hw->xmtfifo_sz[fifo];\n\n\treturn 0;\n}\n\nvoid\nbrcms_c_set_addrmatch(struct brcms_c_info *wlc, int match_reg_offset,\n\t\t  const u8 *addr)\n{\n\tbrcms_b_set_addrmatch(wlc->hw, match_reg_offset, addr);\n\tif (match_reg_offset == RCM_BSSID_OFFSET)\n\t\tmemcpy(wlc->bsscfg->BSSID, addr, ETH_ALEN);\n}\n\n \nvoid brcms_c_scan_start(struct brcms_c_info *wlc)\n{\n\twlc_phy_hold_upd(wlc->band->pi, PHY_HOLD_FOR_SCAN, true);\n}\n\nvoid brcms_c_scan_stop(struct brcms_c_info *wlc)\n{\n\twlc_phy_hold_upd(wlc->band->pi, PHY_HOLD_FOR_SCAN, false);\n}\n\nvoid brcms_c_associate_upd(struct brcms_c_info *wlc, bool state)\n{\n\twlc->pub->associated = state;\n}\n\n \nvoid brcms_c_inval_dma_pkts(struct brcms_hardware *hw,\n\t\t\t       struct ieee80211_sta *sta,\n\t\t\t       void (*dma_callback_fn))\n{\n\tstruct dma_pub *dmah;\n\tint i;\n\tfor (i = 0; i < NFIFO; i++) {\n\t\tdmah = hw->di[i];\n\t\tif (dmah != NULL)\n\t\t\tdma_walk_packets(dmah, dma_callback_fn, sta);\n\t}\n}\n\nint brcms_c_get_curband(struct brcms_c_info *wlc)\n{\n\treturn wlc->band->bandunit;\n}\n\nbool brcms_c_tx_flush_completed(struct brcms_c_info *wlc)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(wlc->hw->di); i++)\n\t\tif (wlc->hw->di[i])\n\t\t\tdma_kick_tx(wlc->hw->di[i]);\n\n\treturn !brcms_txpktpendtot(wlc);\n}\n\nvoid brcms_c_set_beacon_listen_interval(struct brcms_c_info *wlc, u8 interval)\n{\n\twlc->bcn_li_bcn = interval;\n\tif (wlc->pub->up)\n\t\tbrcms_c_bcn_li_upd(wlc);\n}\n\nu64 brcms_c_tsf_get(struct brcms_c_info *wlc)\n{\n\tu32 tsf_h, tsf_l;\n\tu64 tsf;\n\n\tbrcms_b_read_tsf(wlc->hw, &tsf_l, &tsf_h);\n\n\ttsf = tsf_h;\n\ttsf <<= 32;\n\ttsf |= tsf_l;\n\n\treturn tsf;\n}\n\nvoid brcms_c_tsf_set(struct brcms_c_info *wlc, u64 tsf)\n{\n\tu32 tsf_h, tsf_l;\n\n\tbrcms_c_time_lock(wlc);\n\n\ttsf_l = tsf;\n\ttsf_h = (tsf >> 32);\n\n\t \n\tbcma_write32(wlc->hw->d11core, D11REGOFFS(tsf_timerlow), tsf_l);\n\tbcma_write32(wlc->hw->d11core, D11REGOFFS(tsf_timerhigh), tsf_h);\n\n\tbrcms_c_time_unlock(wlc);\n}\n\nint brcms_c_set_tx_power(struct brcms_c_info *wlc, int txpwr)\n{\n\tuint qdbm;\n\n\t \n\tqdbm = min_t(uint, txpwr * BRCMS_TXPWR_DB_FACTOR, 0xff);\n\treturn wlc_phy_txpower_set(wlc->band->pi, qdbm, false);\n}\n\nint brcms_c_get_tx_power(struct brcms_c_info *wlc)\n{\n\tuint qdbm;\n\tbool override;\n\n\twlc_phy_txpower_get(wlc->band->pi, &qdbm, &override);\n\n\t \n\treturn (int)(qdbm / BRCMS_TXPWR_DB_FACTOR);\n}\n\n \n \nstatic void brcms_c_recv(struct brcms_c_info *wlc, struct sk_buff *p)\n{\n\tstruct d11rxhdr *rxh;\n\tstruct ieee80211_hdr *h;\n\tuint len;\n\tbool is_amsdu;\n\n\t \n\trxh = (struct d11rxhdr *) (p->data);\n\n\t \n\tskb_pull(p, BRCMS_HWRXOFF);\n\n\t \n\tif (rxh->RxStatus1 & RXS_PBPRES) {\n\t\tif (p->len < 2) {\n\t\t\tbrcms_err(wlc->hw->d11core,\n\t\t\t\t  \"wl%d: recv: rcvd runt of len %d\\n\",\n\t\t\t\t  wlc->pub->unit, p->len);\n\t\t\tgoto toss;\n\t\t}\n\t\tskb_pull(p, 2);\n\t}\n\n\th = (struct ieee80211_hdr *)(p->data + D11_PHY_HDR_LEN);\n\tlen = p->len;\n\n\tif (rxh->RxStatus1 & RXS_FCSERR) {\n\t\tif (!(wlc->filter_flags & FIF_FCSFAIL))\n\t\t\tgoto toss;\n\t}\n\n\t \n\tif (len < D11_PHY_HDR_LEN + sizeof(h->frame_control))\n\t\tgoto toss;\n\n\t \n\tis_amsdu = rxh->RxStatus2 & RXS_AMSDU_MASK;\n\tif (is_amsdu)\n\t\tgoto toss;\n\n\tbrcms_c_recvctl(wlc, rxh, p);\n\treturn;\n\n toss:\n\tbrcmu_pkt_buf_free_skb(p);\n}\n\n \n \nstatic bool\nbrcms_b_recv(struct brcms_hardware *wlc_hw, uint fifo, bool bound)\n{\n\tstruct sk_buff *p;\n\tstruct sk_buff *next = NULL;\n\tstruct sk_buff_head recv_frames;\n\n\tuint n = 0;\n\tuint bound_limit = bound ? RXBND : -1;\n\tbool morepending = false;\n\n\tskb_queue_head_init(&recv_frames);\n\n\t \n\tdo {\n\t\t \n\t\tif (n >= bound_limit)\n\t\t\tbreak;\n\n\t\tmorepending = dma_rx(wlc_hw->di[fifo], &recv_frames);\n\t\tn++;\n\t} while (morepending);\n\n\t \n\tdma_rxfill(wlc_hw->di[fifo]);\n\n\t \n\tskb_queue_walk_safe(&recv_frames, p, next) {\n\t\tstruct d11rxhdr_le *rxh_le;\n\t\tstruct d11rxhdr *rxh;\n\n\t\tskb_unlink(p, &recv_frames);\n\t\trxh_le = (struct d11rxhdr_le *)p->data;\n\t\trxh = (struct d11rxhdr *)p->data;\n\n\t\t \n\t\trxh->RxFrameSize = le16_to_cpu(rxh_le->RxFrameSize);\n\t\trxh->PhyRxStatus_0 = le16_to_cpu(rxh_le->PhyRxStatus_0);\n\t\trxh->PhyRxStatus_1 = le16_to_cpu(rxh_le->PhyRxStatus_1);\n\t\trxh->PhyRxStatus_2 = le16_to_cpu(rxh_le->PhyRxStatus_2);\n\t\trxh->PhyRxStatus_3 = le16_to_cpu(rxh_le->PhyRxStatus_3);\n\t\trxh->PhyRxStatus_4 = le16_to_cpu(rxh_le->PhyRxStatus_4);\n\t\trxh->PhyRxStatus_5 = le16_to_cpu(rxh_le->PhyRxStatus_5);\n\t\trxh->RxStatus1 = le16_to_cpu(rxh_le->RxStatus1);\n\t\trxh->RxStatus2 = le16_to_cpu(rxh_le->RxStatus2);\n\t\trxh->RxTSFTime = le16_to_cpu(rxh_le->RxTSFTime);\n\t\trxh->RxChan = le16_to_cpu(rxh_le->RxChan);\n\n\t\tbrcms_c_recv(wlc_hw->wlc, p);\n\t}\n\n\treturn morepending;\n}\n\n \nbool brcms_c_dpc(struct brcms_c_info *wlc, bool bounded)\n{\n\tu32 macintstatus;\n\tstruct brcms_hardware *wlc_hw = wlc->hw;\n\tstruct bcma_device *core = wlc_hw->d11core;\n\n\tif (brcms_deviceremoved(wlc)) {\n\t\tbrcms_err(core, \"wl%d: %s: dead chip\\n\", wlc_hw->unit,\n\t\t\t  __func__);\n\t\tbrcms_down(wlc->wl);\n\t\treturn false;\n\t}\n\n\t \n\tmacintstatus = wlc->macintstatus;\n\twlc->macintstatus = 0;\n\n\tbrcms_dbg_int(core, \"wl%d: macintstatus 0x%x\\n\",\n\t\t      wlc_hw->unit, macintstatus);\n\n\tWARN_ON(macintstatus & MI_PRQ);  \n\n\t \n\tif (macintstatus & MI_TFS) {\n\t\tbool fatal;\n\t\tif (brcms_b_txstatus(wlc->hw, bounded, &fatal))\n\t\t\twlc->macintstatus |= MI_TFS;\n\t\tif (fatal) {\n\t\t\tbrcms_err(core, \"MI_TFS: fatal\\n\");\n\t\t\tgoto fatal;\n\t\t}\n\t}\n\n\tif (macintstatus & (MI_TBTT | MI_DTIM_TBTT))\n\t\tbrcms_c_tbtt(wlc);\n\n\t \n\tif (macintstatus & MI_ATIMWINEND) {\n\t\tbrcms_dbg_info(core, \"end of ATIM window\\n\");\n\t\tbcma_set32(core, D11REGOFFS(maccommand), wlc->qvalid);\n\t\twlc->qvalid = 0;\n\t}\n\n\t \n\tif (macintstatus & MI_DMAINT)\n\t\tif (brcms_b_recv(wlc_hw, RX_FIFO, bounded))\n\t\t\twlc->macintstatus |= MI_DMAINT;\n\n\t \n\tif (macintstatus & MI_BG_NOISE)\n\t\twlc_phy_noise_sample_intr(wlc_hw->band->pi);\n\n\tif (macintstatus & MI_GP0) {\n\t\tbrcms_err(core, \"wl%d: PSM microcode watchdog fired at %d \"\n\t\t\t  \"(seconds). Resetting.\\n\", wlc_hw->unit, wlc_hw->now);\n\n\t\tprintk_once(\"%s : PSM Watchdog, chipid 0x%x, chiprev 0x%x\\n\",\n\t\t\t    __func__, ai_get_chip_id(wlc_hw->sih),\n\t\t\t    ai_get_chiprev(wlc_hw->sih));\n\t\tbrcms_fatal_error(wlc_hw->wlc->wl);\n\t}\n\n\t \n\tif (macintstatus & MI_TO)\n\t\tbcma_write32(core, D11REGOFFS(gptimer), 0);\n\n\tif (macintstatus & MI_RFDISABLE) {\n\t\tbrcms_dbg_info(core, \"wl%d: BMAC Detected a change on the\"\n\t\t\t       \" RF Disable Input\\n\", wlc_hw->unit);\n\t\tbrcms_rfkill_set_hw_state(wlc->wl);\n\t}\n\n\t \n\tif (macintstatus & MI_BCNTPL)\n\t\tbrcms_c_update_beacon(wlc);\n\n\t \n\treturn wlc->macintstatus != 0;\n\n fatal:\n\tbrcms_fatal_error(wlc_hw->wlc->wl);\n\treturn wlc->macintstatus != 0;\n}\n\nvoid brcms_c_init(struct brcms_c_info *wlc, bool mute_tx)\n{\n\tstruct bcma_device *core = wlc->hw->d11core;\n\tstruct ieee80211_channel *ch = wlc->pub->ieee_hw->conf.chandef.chan;\n\tu16 chanspec;\n\n\tbrcms_dbg_info(core, \"wl%d\\n\", wlc->pub->unit);\n\n\tchanspec = ch20mhz_chspec(ch->hw_value);\n\n\tbrcms_b_init(wlc->hw, chanspec);\n\n\t \n\tbrcms_c_bcn_li_upd(wlc);\n\n\t \n\tbrcms_c_set_mac(wlc->bsscfg);\n\tbrcms_c_set_bssid(wlc->bsscfg);\n\n\t \n\tif (wlc->pub->associated && wlc->pub->up) {\n\t\tu32 bi;\n\n\t\t \n\t\tbi = wlc->bsscfg->current_bss->beacon_period << 10;\n\t\t \n\t\tbcma_write32(core, D11REGOFFS(tsf_cfprep),\n\t\t\t     bi << CFPREP_CBI_SHIFT);\n\n\t\t \n\t\tbrcms_c_set_ps_ctrl(wlc);\n\t}\n\n\tbrcms_c_bandinit_ordered(wlc, chanspec);\n\n\t \n\tbrcms_b_write_shm(wlc->hw, M_PRS_MAXTIME, wlc->prb_resp_timeout);\n\n\t \n\tbrcms_b_write_shm(wlc->hw, M_MBURST_TXOP,\n\t\t      (wlc->\n\t\t       _rifs ? (EDCF_AC_VO_TXOP_AP << 5) : MAXFRAMEBURST_TXOP));\n\n\t \n\tbrcms_c_duty_cycle_set(wlc, wlc->tx_duty_cycle_ofdm, true, true);\n\tbrcms_c_duty_cycle_set(wlc, wlc->tx_duty_cycle_cck, false, true);\n\n\t \n\tbrcms_c_ampdu_shm_upd(wlc->ampdu);\n\n\t \n\tbrcms_c_bsinit(wlc);\n\n\t \n\tbcma_set16(core, D11REGOFFS(ifs_ctl), IFS_USEEDCF);\n\tbrcms_c_edcf_setparams(wlc, false);\n\n\t \n\tif (wlc->ucode_rev == 0) {\n\t\tu16 rev;\n\t\tu16 patch;\n\n\t\trev = brcms_b_read_shm(wlc->hw, M_BOM_REV_MAJOR);\n\t\tpatch = brcms_b_read_shm(wlc->hw, M_BOM_REV_MINOR);\n\t\twlc->ucode_rev = (rev << NBITS(u16)) | patch;\n\t\tsnprintf(wlc->wiphy->fw_version,\n\t\t\t sizeof(wlc->wiphy->fw_version), \"%u.%u\", rev, patch);\n\t}\n\n\t \n\tbrcms_c_enable_mac(wlc);\n\n\t \n\tif (mute_tx)\n\t\tbrcms_b_mute(wlc->hw, true);\n\n\t \n\tbcma_write32(core, D11REGOFFS(rfdisabledly), RFDISABLE_DEFAULT);\n\n\t \n\tif (GFIELD(wlc->wme_retries[0], EDCF_SHORT) == 0) {\n\t\t \n\t\tint ac;\n\n\t\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\n\t\t\twlc->wme_retries[ac] =\n\t\t\t    brcms_b_read_shm(wlc->hw, M_AC_TXLMT_ADDR(ac));\n\t}\n}\n\n \nstruct brcms_c_info *\nbrcms_c_attach(struct brcms_info *wl, struct bcma_device *core, uint unit,\n\t       bool piomode, uint *perr)\n{\n\tstruct brcms_c_info *wlc;\n\tuint err = 0;\n\tuint i, j;\n\tstruct brcms_pub *pub;\n\n\t \n\twlc = brcms_c_attach_malloc(unit, &err, 0);\n\tif (wlc == NULL)\n\t\tgoto fail;\n\twlc->wiphy = wl->wiphy;\n\tpub = wlc->pub;\n\n#if defined(DEBUG)\n\twlc_info_dbg = wlc;\n#endif\n\n\twlc->band = wlc->bandstate[0];\n\twlc->core = wlc->corestate;\n\twlc->wl = wl;\n\tpub->unit = unit;\n\tpub->_piomode = piomode;\n\twlc->bandinit_pending = false;\n\twlc->beacon_template_virgin = true;\n\n\t \n\tbrcms_c_info_init(wlc, unit);\n\n\t \n\tbrcms_c_ap_upd(wlc);\n\n\t \n\terr = brcms_b_attach(wlc, core, unit, piomode);\n\tif (err)\n\t\tgoto fail;\n\n\tbrcms_c_protection_upd(wlc, BRCMS_PROT_N_PAM_OVR, OFF);\n\n\tpub->phy_11ncapable = BRCMS_PHY_11N_CAP(wlc->band);\n\n\t \n\twlc->tx_duty_cycle_ofdm = 0;\n\twlc->tx_duty_cycle_cck = 0;\n\n\tbrcms_c_stf_phy_chain_calc(wlc);\n\n\t \n\tif (BRCMS_ISNPHY(wlc->band) && (wlc->stf->txstreams == 1))\n\t\twlc->stf->txant = wlc->stf->hw_txchain - 1;\n\n\t \n\twlc_phy_stf_chain_init(wlc->band->pi, wlc->stf->hw_txchain,\n\t\t\t       wlc->stf->hw_rxchain);\n\n\t \n\tfor (i = 0; i < NFIFO; i++)\n\t\twlc->core->txavail[i] = wlc->hw->txavail[i];\n\n\tmemcpy(&wlc->perm_etheraddr, &wlc->hw->etheraddr, ETH_ALEN);\n\tmemcpy(&pub->cur_etheraddr, &wlc->hw->etheraddr, ETH_ALEN);\n\n\tfor (j = 0; j < wlc->pub->_nbands; j++) {\n\t\twlc->band = wlc->bandstate[j];\n\n\t\tif (!brcms_c_attach_stf_ant_init(wlc)) {\n\t\t\terr = 24;\n\t\t\tgoto fail;\n\t\t}\n\n\t\t \n\t\twlc->band->CWmin = APHY_CWMIN;\n\t\twlc->band->CWmax = PHY_CWMAX;\n\n\t\t \n\t\tif (wlc->band->bandtype == BRCM_BAND_2G) {\n\t\t\twlc->band->gmode = GMODE_AUTO;\n\t\t\tbrcms_c_protection_upd(wlc, BRCMS_PROT_G_USER,\n\t\t\t\t\t   wlc->band->gmode);\n\t\t}\n\n\t\t \n\t\tif (BRCMS_PHY_11N_CAP(wlc->band)) {\n\t\t\tpub->_n_enab = SUPPORT_11N;\n\t\t\tbrcms_c_protection_upd(wlc, BRCMS_PROT_N_USER,\n\t\t\t\t\t\t   ((pub->_n_enab ==\n\t\t\t\t\t\t     SUPPORT_11N) ? WL_11N_2x2 :\n\t\t\t\t\t\t    WL_11N_3x3));\n\t\t}\n\n\t\t \n\t\tbrcms_default_rateset(wlc, &wlc->band->defrateset);\n\n\t\t \n\t\tbrcms_c_rateset_filter(&wlc->band->defrateset,\n\t\t\t\t   &wlc->band->hw_rateset, false,\n\t\t\t\t   BRCMS_RATES_CCK_OFDM, BRCMS_RATE_MASK,\n\t\t\t\t   (bool) (wlc->pub->_n_enab & SUPPORT_11N));\n\t}\n\n\t \n\tbrcms_c_stf_phy_txant_upd(wlc);\n\n\t \n\terr = brcms_c_attach_module(wlc);\n\tif (err != 0)\n\t\tgoto fail;\n\n\tif (!brcms_c_timers_init(wlc, unit)) {\n\t\twiphy_err(wl->wiphy, \"wl%d: %s: init_timer failed\\n\", unit,\n\t\t\t  __func__);\n\t\terr = 32;\n\t\tgoto fail;\n\t}\n\n\t \n\twlc->cmi = brcms_c_channel_mgr_attach(wlc);\n\tif (!wlc->cmi) {\n\t\twiphy_err(wl->wiphy, \"wl%d: %s: channel_mgr_attach failed\"\n\t\t\t  \"\\n\", unit, __func__);\n\t\terr = 33;\n\t\tgoto fail;\n\t}\n\n\t \n\tbrcms_c_bss_default_init(wlc);\n\n\t \n\n\twlc->bsscfg->wlc = wlc;\n\n\twlc->mimoft = FT_HT;\n\twlc->mimo_40txbw = AUTO;\n\twlc->ofdm_40txbw = AUTO;\n\twlc->cck_40txbw = AUTO;\n\tbrcms_c_update_mimo_band_bwcap(wlc, BRCMS_N_BW_20IN2G_40IN5G);\n\n\t \n\tif (BRCMS_SGI_CAP_PHY(wlc)) {\n\t\tbrcms_c_ht_update_sgi_rx(wlc, (BRCMS_N_SGI_20 |\n\t\t\t\t\t       BRCMS_N_SGI_40));\n\t} else if (BRCMS_ISSSLPNPHY(wlc->band)) {\n\t\tbrcms_c_ht_update_sgi_rx(wlc, (BRCMS_N_SGI_20 |\n\t\t\t\t\t       BRCMS_N_SGI_40));\n\t} else {\n\t\tbrcms_c_ht_update_sgi_rx(wlc, 0);\n\t}\n\n\tbrcms_b_antsel_set(wlc->hw, wlc->asi->antsel_avail);\n\n\tif (perr)\n\t\t*perr = 0;\n\n\treturn wlc;\n\n fail:\n\twiphy_err(wl->wiphy, \"wl%d: %s: failed with err %d\\n\",\n\t\t  unit, __func__, err);\n\tif (wlc)\n\t\tbrcms_c_detach(wlc);\n\n\tif (perr)\n\t\t*perr = err;\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}