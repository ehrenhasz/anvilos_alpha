{
  "module_name": "antsel.c",
  "hash_id": "75516ff25c5ebfbafd6ada01010c087b2d92e81a6697890b482e21570bd5100a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmsmac/antsel.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n#include <net/mac80211.h>\n\n#include \"types.h\"\n#include \"main.h\"\n#include \"phy_shim.h\"\n#include \"antsel.h\"\n#include \"debug.h\"\n\n#define ANT_SELCFG_AUTO\t\t0x80\t \n#define ANT_SELCFG_MASK\t\t0x33\t \n#define ANT_SELCFG_TX_UNICAST\t0\t \n#define ANT_SELCFG_RX_UNICAST\t1\t \n#define ANT_SELCFG_TX_DEF\t2\t \n#define ANT_SELCFG_RX_DEF\t3\t \n\n \n#define BRCMS_ANTSEL_11N_0(ant)\t((((ant) & ANT_SELCFG_MASK) >> 4) & 0xf)\n#define BRCMS_ANTSEL_11N_1(ant)\t(((ant) & ANT_SELCFG_MASK) & 0xf)\n#define BRCMS_ANTIDX_11N(ant)\t(((BRCMS_ANTSEL_11N_0(ant)) << 2) +\\\n\t\t\t\t(BRCMS_ANTSEL_11N_1(ant)))\n#define BRCMS_ANT_ISAUTO_11N(ant) (((ant) & ANT_SELCFG_AUTO) == ANT_SELCFG_AUTO)\n#define BRCMS_ANTSEL_11N(ant)\t((ant) & ANT_SELCFG_MASK)\n\n \n \n#define ANT_SELCFG_DEF_2x2\t0x01\t \n\n \n#define ANT_SELCFG_NUM_2x3\t3\n#define ANT_SELCFG_DEF_2x3\t0x01\t \n\n \n#define ANT_SELCFG_NUM_2x4\t4\n#define ANT_SELCFG_DEF_2x4\t0x02\t \n\nstatic const u16 mimo_2x4_div_antselpat_tbl[] = {\n\t0, 0, 0x9, 0xa,\t\t \n\t0, 0, 0x5, 0x6,\t\t \n\t0, 0, 0, 0,\t\t \n\t0, 0, 0, 0\t\t \n};\n\nstatic const u8 mimo_2x4_div_antselid_tbl[16] = {\n\t0, 0, 0, 0, 0, 2, 3, 0,\n\t0, 0, 1, 0, 0, 0, 0, 0\t \n};\n\nstatic const u16 mimo_2x3_div_antselpat_tbl[] = {\n\t16, 0, 1, 16,\t\t \n\t16, 16, 16, 16,\t\t \n\t16, 2, 16, 16,\t\t \n\t16, 16, 16, 16\t\t \n};\n\nstatic const u8 mimo_2x3_div_antselid_tbl[16] = {\n\t0, 1, 2, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0\t \n};\n\n \nstatic void\nbrcms_c_antsel_init_cfg(struct antsel_info *asi, struct brcms_antselcfg *antsel,\n\t\t    bool auto_sel)\n{\n\tif (asi->antsel_type == ANTSEL_2x3) {\n\t\tu8 antcfg_def = ANT_SELCFG_DEF_2x3 |\n\t\t    ((asi->antsel_avail && auto_sel) ? ANT_SELCFG_AUTO : 0);\n\t\tantsel->ant_config[ANT_SELCFG_TX_DEF] = antcfg_def;\n\t\tantsel->ant_config[ANT_SELCFG_TX_UNICAST] = antcfg_def;\n\t\tantsel->ant_config[ANT_SELCFG_RX_DEF] = antcfg_def;\n\t\tantsel->ant_config[ANT_SELCFG_RX_UNICAST] = antcfg_def;\n\t\tantsel->num_antcfg = ANT_SELCFG_NUM_2x3;\n\n\t} else if (asi->antsel_type == ANTSEL_2x4) {\n\n\t\tantsel->ant_config[ANT_SELCFG_TX_DEF] = ANT_SELCFG_DEF_2x4;\n\t\tantsel->ant_config[ANT_SELCFG_TX_UNICAST] = ANT_SELCFG_DEF_2x4;\n\t\tantsel->ant_config[ANT_SELCFG_RX_DEF] = ANT_SELCFG_DEF_2x4;\n\t\tantsel->ant_config[ANT_SELCFG_RX_UNICAST] = ANT_SELCFG_DEF_2x4;\n\t\tantsel->num_antcfg = ANT_SELCFG_NUM_2x4;\n\n\t} else {\t\t \n\n\t\tantsel->ant_config[ANT_SELCFG_TX_DEF] = ANT_SELCFG_DEF_2x2;\n\t\tantsel->ant_config[ANT_SELCFG_TX_UNICAST] = ANT_SELCFG_DEF_2x2;\n\t\tantsel->ant_config[ANT_SELCFG_RX_DEF] = ANT_SELCFG_DEF_2x2;\n\t\tantsel->ant_config[ANT_SELCFG_RX_UNICAST] = ANT_SELCFG_DEF_2x2;\n\t\tantsel->num_antcfg = 0;\n\t}\n}\n\nstruct antsel_info *brcms_c_antsel_attach(struct brcms_c_info *wlc)\n{\n\tstruct antsel_info *asi;\n\tstruct ssb_sprom *sprom = &wlc->hw->d11core->bus->sprom;\n\n\tasi = kzalloc(sizeof(struct antsel_info), GFP_ATOMIC);\n\tif (!asi)\n\t\treturn NULL;\n\n\tasi->wlc = wlc;\n\tasi->pub = wlc->pub;\n\tasi->antsel_type = ANTSEL_NA;\n\tasi->antsel_avail = false;\n\tasi->antsel_antswitch = sprom->antswitch;\n\n\tif ((asi->pub->sromrev >= 4) && (asi->antsel_antswitch != 0)) {\n\t\tswitch (asi->antsel_antswitch) {\n\t\tcase ANTSWITCH_TYPE_1:\n\t\tcase ANTSWITCH_TYPE_2:\n\t\tcase ANTSWITCH_TYPE_3:\n\t\t\t \n\t\t\tasi->antsel_type = ANTSEL_2x3;\n\t\t\t \n\t\t\tif ((sprom->ant_available_bg == 7) ||\n\t\t\t    (sprom->ant_available_a == 7)) {\n\t\t\t\tasi->antsel_avail = true;\n\t\t\t} else if (\n\t\t\t\tsprom->ant_available_bg == 3 ||\n\t\t\t\tsprom->ant_available_a == 3) {\n\t\t\t\tasi->antsel_avail = false;\n\t\t\t} else {\n\t\t\t\tasi->antsel_avail = false;\n\t\t\t\tbrcms_err(wlc->hw->d11core,\n\t\t\t\t\t  \"antsel_attach: 2o3 \"\n\t\t\t\t\t  \"board cfg invalid\\n\");\n\t\t\t}\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else if ((asi->pub->sromrev == 4) &&\n\t\t   (sprom->ant_available_bg == 7) &&\n\t\t   (sprom->ant_available_a == 0)) {\n\t\t \n\t\tasi->antsel_type = ANTSEL_2x3;\n\t\tasi->antsel_avail = true;\n\t} else if (asi->pub->boardflags2 & BFL2_2X4_DIV) {\n\t\tasi->antsel_type = ANTSEL_2x4;\n\t\tasi->antsel_avail = true;\n\t}\n\n\t \n\tbrcms_b_antsel_type_set(wlc->hw, asi->antsel_type);\n\n\t \n\tbrcms_c_antsel_init_cfg(asi, &asi->antcfg_11n, true);\n\tbrcms_c_antsel_init_cfg(asi, &asi->antcfg_cur, true);\n\n\treturn asi;\n}\n\nvoid brcms_c_antsel_detach(struct antsel_info *asi)\n{\n\tkfree(asi);\n}\n\n \nstatic u16 brcms_c_antsel_antcfg2antsel(struct antsel_info *asi, u8 ant_cfg)\n{\n\tu8 idx = BRCMS_ANTIDX_11N(BRCMS_ANTSEL_11N(ant_cfg));\n\tu16 mimo_antsel = 0;\n\n\tif (asi->antsel_type == ANTSEL_2x4) {\n\t\t \n\t\tmimo_antsel = (mimo_2x4_div_antselpat_tbl[idx] & 0xf);\n\t\treturn mimo_antsel;\n\n\t} else if (asi->antsel_type == ANTSEL_2x3) {\n\t\t \n\t\tmimo_antsel = (mimo_2x3_div_antselpat_tbl[idx] & 0xf);\n\t\treturn mimo_antsel;\n\t}\n\n\treturn mimo_antsel;\n}\n\n \nstatic int brcms_c_antsel_cfgupd(struct antsel_info *asi,\n\t\t\t\t struct brcms_antselcfg *antsel)\n{\n\tstruct brcms_c_info *wlc = asi->wlc;\n\tu8 ant_cfg;\n\tu16 mimo_antsel;\n\n\t \n\tant_cfg = antsel->ant_config[ANT_SELCFG_TX_DEF];\n\tmimo_antsel = brcms_c_antsel_antcfg2antsel(asi, ant_cfg);\n\tbrcms_b_write_shm(wlc->hw, M_MIMO_ANTSEL_TXDFLT, mimo_antsel);\n\t \n\tasi->antcfg_cur.ant_config[ANT_SELCFG_TX_DEF] = ant_cfg;\n\n\t \n\tant_cfg = antsel->ant_config[ANT_SELCFG_RX_DEF];\n\tmimo_antsel = brcms_c_antsel_antcfg2antsel(asi, ant_cfg);\n\tbrcms_b_write_shm(wlc->hw, M_MIMO_ANTSEL_RXDFLT, mimo_antsel);\n\t \n\tasi->antcfg_cur.ant_config[ANT_SELCFG_RX_DEF] = ant_cfg;\n\n\treturn 0;\n}\n\nvoid brcms_c_antsel_init(struct antsel_info *asi)\n{\n\tif ((asi->antsel_type == ANTSEL_2x3) ||\n\t    (asi->antsel_type == ANTSEL_2x4))\n\t\tbrcms_c_antsel_cfgupd(asi, &asi->antcfg_11n);\n}\n\n \nstatic u8 brcms_c_antsel_id2antcfg(struct antsel_info *asi, u8 id)\n{\n\tu8 antcfg = ANT_SELCFG_DEF_2x2;\n\n\tif (asi->antsel_type == ANTSEL_2x4) {\n\t\t \n\t\tantcfg = (((id & 0x2) << 3) | ((id & 0x1) + 2));\n\t\treturn antcfg;\n\n\t} else if (asi->antsel_type == ANTSEL_2x3) {\n\t\t \n\t\tantcfg = (((id & 0x02) << 4) | ((id & 0x1) + 1));\n\t\treturn antcfg;\n\t}\n\n\treturn antcfg;\n}\n\nvoid\nbrcms_c_antsel_antcfg_get(struct antsel_info *asi, bool usedef, bool sel,\n\t\t      u8 antselid, u8 fbantselid, u8 *antcfg,\n\t\t      u8 *fbantcfg)\n{\n\tu8 ant;\n\n\t \n\tif (usedef) {\n\t\t*antcfg = asi->antcfg_11n.ant_config[ANT_SELCFG_TX_DEF];\n\t\t*fbantcfg = *antcfg;\n\t\treturn;\n\t}\n\n\tif (!sel) {\n\t\t*antcfg = asi->antcfg_11n.ant_config[ANT_SELCFG_TX_UNICAST];\n\t\t*fbantcfg = *antcfg;\n\n\t} else {\n\t\tant = asi->antcfg_11n.ant_config[ANT_SELCFG_TX_UNICAST];\n\t\tif ((ant & ANT_SELCFG_AUTO) == ANT_SELCFG_AUTO) {\n\t\t\t*antcfg = brcms_c_antsel_id2antcfg(asi, antselid);\n\t\t\t*fbantcfg = brcms_c_antsel_id2antcfg(asi, fbantselid);\n\t\t} else {\n\t\t\t*antcfg =\n\t\t\t    asi->antcfg_11n.ant_config[ANT_SELCFG_TX_UNICAST];\n\t\t\t*fbantcfg = *antcfg;\n\t\t}\n\t}\n\treturn;\n}\n\n \nu8 brcms_c_antsel_antsel2id(struct antsel_info *asi, u16 antsel)\n{\n\tu8 antselid = 0;\n\n\tif (asi->antsel_type == ANTSEL_2x4) {\n\t\t \n\t\tantselid = mimo_2x4_div_antselid_tbl[(antsel & 0xf)];\n\t\treturn antselid;\n\n\t} else if (asi->antsel_type == ANTSEL_2x3) {\n\t\t \n\t\tantselid = mimo_2x3_div_antselid_tbl[(antsel & 0xf)];\n\t\treturn antselid;\n\t}\n\n\treturn antselid;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}