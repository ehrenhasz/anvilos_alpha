{
  "module_name": "led.c",
  "hash_id": "64fd1c5f09789000e52d7b1340e08614321b1459caa586010e7adf22e77b3886",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmsmac/led.c",
  "human_readable_source": "\n#include <net/mac80211.h>\n#include <linux/bcma/bcma_driver_chipcommon.h>\n#include <linux/gpio.h>\n#include <linux/gpio/driver.h>\n#include <linux/gpio/machine.h>\n#include <linux/gpio/consumer.h>\n\n#include \"mac80211_if.h\"\n#include \"pub.h\"\n#include \"main.h\"\n#include \"led.h\"\n\n\t \n#define  BRCMS_LED_NO\t\t4\n\t \n#define  BRCMS_LED_BEH_MASK\t0x7f\n\t \n#define  BRCMS_LED_AL_MASK\t0x80\n\t \n#define  BRCMS_LED_RADIO\t3\n\nstatic void brcms_radio_led_ctrl(struct brcms_info *wl, bool state)\n{\n\tif (!wl->radio_led.gpiod)\n\t\treturn;\n\n\tif (state)\n\t\tgpiod_set_value(wl->radio_led.gpiod, 1);\n\telse\n\t\tgpiod_set_value(wl->radio_led.gpiod, 0);\n}\n\n\n \nstatic void brcms_led_brightness_set(struct led_classdev *led_dev,\n\t\t\t\t   enum led_brightness brightness)\n{\n\tstruct brcms_info *wl = container_of(led_dev,\n\t\tstruct brcms_info, led_dev);\n\tbrcms_radio_led_ctrl(wl, brightness);\n}\n\nvoid brcms_led_unregister(struct brcms_info *wl)\n{\n\tif (wl->led_dev.dev)\n\t\tled_classdev_unregister(&wl->led_dev);\n\tif (wl->radio_led.gpiod)\n\t\tgpiochip_free_own_desc(wl->radio_led.gpiod);\n}\n\nint brcms_led_register(struct brcms_info *wl)\n{\n\tint i, err;\n\tstruct brcms_led *radio_led = &wl->radio_led;\n\t \n\tstruct bcma_drv_cc *cc_drv  = &wl->wlc->hw->d11core->bus->drv_cc;\n\tstruct gpio_chip *bcma_gpio = &cc_drv->gpio;\n\tstruct ssb_sprom *sprom = &wl->wlc->hw->d11core->bus->sprom;\n\tu8 *leds[] = { &sprom->gpio0,\n\t\t&sprom->gpio1,\n\t\t&sprom->gpio2,\n\t\t&sprom->gpio3 };\n\tint hwnum = -1;\n\tenum gpio_lookup_flags lflags = GPIO_ACTIVE_HIGH;\n\n\t \n\tfor (i = 0; i < BRCMS_LED_NO; i++) {\n\t\tu8 led = *leds[i];\n\t\tif ((led & BRCMS_LED_BEH_MASK) == BRCMS_LED_RADIO) {\n\t\t\thwnum = i;\n\t\t\tif (led & BRCMS_LED_AL_MASK)\n\t\t\t\tlflags = GPIO_ACTIVE_LOW;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (hwnum == -1)\n\t\treturn -ENODEV;\n\n\t \n\tradio_led->gpiod = gpiochip_request_own_desc(bcma_gpio, hwnum,\n\t\t\t\t\t\t     \"radio on\", lflags,\n\t\t\t\t\t\t     GPIOD_OUT_LOW);\n\n\tif (IS_ERR(radio_led->gpiod)) {\n\t\terr = PTR_ERR(radio_led->gpiod);\n\t\twiphy_err(wl->wiphy, \"requesting led GPIO failed (err: %d)\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\tsnprintf(wl->radio_led.name, sizeof(wl->radio_led.name),\n\t\t \"brcmsmac-%s:radio\", wiphy_name(wl->wiphy));\n\n\twl->led_dev.name = wl->radio_led.name;\n\twl->led_dev.default_trigger =\n\t\tieee80211_get_radio_led_name(wl->pub->ieee_hw);\n\twl->led_dev.brightness_set = brcms_led_brightness_set;\n\terr = led_classdev_register(wiphy_dev(wl->wiphy), &wl->led_dev);\n\n\tif (err) {\n\t\twiphy_err(wl->wiphy, \"cannot register led device: %s (err: %d)\\n\",\n\t\t\t  wl->radio_led.name, err);\n\t\treturn err;\n\t}\n\n\twiphy_info(wl->wiphy, \"registered radio enabled led device: %s\\n\",\n\t\t   wl->radio_led.name);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}