{
  "module_name": "fwvid.c",
  "hash_id": "88b61861475fdc339671a816dd877dabf204ddf15521eef5d1a2472ac692fcef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwvid.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/kmod.h>\n#include <linux/list.h>\n#include <linux/completion.h>\n#include <linux/mutex.h>\n#include <linux/printk.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n\n#include \"core.h\"\n#include \"bus.h\"\n#include \"debug.h\"\n#include \"fwvid.h\"\n\n#include \"wcc/vops.h\"\n#include \"cyw/vops.h\"\n#include \"bca/vops.h\"\n\nstruct brcmf_fwvid_entry {\n\tconst char *name;\n\tconst struct brcmf_fwvid_ops *vops;\n\tstruct list_head drvr_list;\n#if IS_MODULE(CONFIG_BRCMFMAC)\n\tstruct module *vmod;\n\tstruct completion reg_done;\n#endif\n};\n\nstatic DEFINE_MUTEX(fwvid_list_lock);\n\n#if IS_MODULE(CONFIG_BRCMFMAC)\n#define FWVID_ENTRY_INIT(_vid, _name) \\\n\t[BRCMF_FWVENDOR_ ## _vid] = { \\\n\t\t.name = #_name, \\\n\t\t.reg_done = COMPLETION_INITIALIZER(fwvid_list[BRCMF_FWVENDOR_ ## _vid].reg_done), \\\n\t\t.drvr_list = LIST_HEAD_INIT(fwvid_list[BRCMF_FWVENDOR_ ## _vid].drvr_list), \\\n\t}\n#else\n#define FWVID_ENTRY_INIT(_vid, _name) \\\n\t[BRCMF_FWVENDOR_ ## _vid] = { \\\n\t\t.name = #_name, \\\n\t\t.drvr_list = LIST_HEAD_INIT(fwvid_list[BRCMF_FWVENDOR_ ## _vid].drvr_list), \\\n\t\t.vops = _vid ## _VOPS \\\n\t}\n#endif  \n\nstatic struct brcmf_fwvid_entry fwvid_list[BRCMF_FWVENDOR_NUM] = {\n\tFWVID_ENTRY_INIT(WCC, wcc),\n\tFWVID_ENTRY_INIT(CYW, cyw),\n\tFWVID_ENTRY_INIT(BCA, bca),\n};\n\n#if IS_MODULE(CONFIG_BRCMFMAC)\nstatic int brcmf_fwvid_request_module(enum brcmf_fwvendor fwvid)\n{\n\tint ret;\n\n\tif (!fwvid_list[fwvid].vmod) {\n\t\tstruct completion *reg_done = &fwvid_list[fwvid].reg_done;\n\n\t\tmutex_unlock(&fwvid_list_lock);\n\n\t\tret = request_module(\"brcmfmac-%s\", fwvid_list[fwvid].name);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tret = wait_for_completion_interruptible(reg_done);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tmutex_lock(&fwvid_list_lock);\n\t}\n\treturn 0;\n\nfail:\n\tbrcmf_err(\"mod=%s: failed %d\\n\", fwvid_list[fwvid].name, ret);\n\treturn ret;\n}\n\nint brcmf_fwvid_register_vendor(enum brcmf_fwvendor fwvid, struct module *vmod,\n\t\t\t\tconst struct brcmf_fwvid_ops *vops)\n{\n\tif (fwvid >= BRCMF_FWVENDOR_NUM)\n\t\treturn -ERANGE;\n\n\tif (WARN_ON(!vmod) || WARN_ON(!vops) ||\n\t    WARN_ON(!vops->attach) || WARN_ON(!vops->detach))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(fwvid_list[fwvid].vmod))\n\t\treturn -EEXIST;\n\n\tbrcmf_dbg(TRACE, \"mod=%s: enter\\n\", fwvid_list[fwvid].name);\n\n\tmutex_lock(&fwvid_list_lock);\n\n\tfwvid_list[fwvid].vmod = vmod;\n\tfwvid_list[fwvid].vops = vops;\n\n\tmutex_unlock(&fwvid_list_lock);\n\n\tcomplete_all(&fwvid_list[fwvid].reg_done);\n\n\treturn 0;\n}\nBRCMF_EXPORT_SYMBOL_GPL(brcmf_fwvid_register_vendor);\n\nint brcmf_fwvid_unregister_vendor(enum brcmf_fwvendor fwvid, struct module *mod)\n{\n\tstruct brcmf_bus *bus, *tmp;\n\n\tif (fwvid >= BRCMF_FWVENDOR_NUM)\n\t\treturn -ERANGE;\n\n\tif (WARN_ON(fwvid_list[fwvid].vmod != mod))\n\t\treturn -ENOENT;\n\n\tmutex_lock(&fwvid_list_lock);\n\n\tlist_for_each_entry_safe(bus, tmp, &fwvid_list[fwvid].drvr_list, list) {\n\t\tmutex_unlock(&fwvid_list_lock);\n\n\t\tbrcmf_dbg(INFO, \"mod=%s: removing %s\\n\", fwvid_list[fwvid].name,\n\t\t\t  dev_name(bus->dev));\n\t\tbrcmf_bus_remove(bus);\n\n\t\tmutex_lock(&fwvid_list_lock);\n\t}\n\n\tfwvid_list[fwvid].vmod = NULL;\n\tfwvid_list[fwvid].vops = NULL;\n\treinit_completion(&fwvid_list[fwvid].reg_done);\n\n\tbrcmf_dbg(TRACE, \"mod=%s: exit\\n\", fwvid_list[fwvid].name);\n\tmutex_unlock(&fwvid_list_lock);\n\n\treturn 0;\n}\nBRCMF_EXPORT_SYMBOL_GPL(brcmf_fwvid_unregister_vendor);\n#else\nstatic inline int brcmf_fwvid_request_module(enum brcmf_fwvendor fwvid)\n{\n\treturn 0;\n}\n#endif\n\nint brcmf_fwvid_attach_ops(struct brcmf_pub *drvr)\n{\n\tenum brcmf_fwvendor fwvid = drvr->bus_if->fwvid;\n\tint ret;\n\n\tif (fwvid >= ARRAY_SIZE(fwvid_list))\n\t\treturn -ERANGE;\n\n\tbrcmf_dbg(TRACE, \"mod=%s: enter: dev %s\\n\", fwvid_list[fwvid].name,\n\t\t  dev_name(drvr->bus_if->dev));\n\n\tmutex_lock(&fwvid_list_lock);\n\n\tret = brcmf_fwvid_request_module(fwvid);\n\tif (ret)\n\t\treturn ret;\n\n\tdrvr->vops = fwvid_list[fwvid].vops;\n\tlist_add(&drvr->bus_if->list, &fwvid_list[fwvid].drvr_list);\n\n\tmutex_unlock(&fwvid_list_lock);\n\n\treturn ret;\n}\n\nvoid brcmf_fwvid_detach_ops(struct brcmf_pub *drvr)\n{\n\tenum brcmf_fwvendor fwvid = drvr->bus_if->fwvid;\n\n\tif (fwvid >= ARRAY_SIZE(fwvid_list))\n\t\treturn;\n\n\tbrcmf_dbg(TRACE, \"mod=%s: enter: dev %s\\n\", fwvid_list[fwvid].name,\n\t\t  dev_name(drvr->bus_if->dev));\n\n\tmutex_lock(&fwvid_list_lock);\n\n\tdrvr->vops = NULL;\n\tlist_del(&drvr->bus_if->list);\n\n\tmutex_unlock(&fwvid_list_lock);\n}\n\nconst char *brcmf_fwvid_vendor_name(struct brcmf_pub *drvr)\n{\n\treturn fwvid_list[drvr->bus_if->fwvid].name;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}