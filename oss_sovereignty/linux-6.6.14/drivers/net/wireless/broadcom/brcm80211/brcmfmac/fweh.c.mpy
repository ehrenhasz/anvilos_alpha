{
  "module_name": "fweh.c",
  "hash_id": "2dbc24be6890d3eec4eafd042ccdd77503e34b3d4ce4253d2795b02be11f3c71",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c",
  "human_readable_source": "\n \n#include <linux/netdevice.h>\n\n#include \"brcmu_wifi.h\"\n#include \"brcmu_utils.h\"\n\n#include \"cfg80211.h\"\n#include \"core.h\"\n#include \"debug.h\"\n#include \"tracepoint.h\"\n#include \"fweh.h\"\n#include \"fwil.h\"\n#include \"proto.h\"\n\n \nstruct brcmf_fweh_queue_item {\n\tstruct list_head q;\n\tenum brcmf_fweh_event_code code;\n\tu8 ifidx;\n\tu8 ifaddr[ETH_ALEN];\n\tstruct brcmf_event_msg_be emsg;\n\tu32 datalen;\n\tu8 data[];\n};\n\n \nstruct brcmf_fweh_event_name {\n\tenum brcmf_fweh_event_code code;\n\tconst char *name;\n};\n\n#ifdef DEBUG\n#define BRCMF_ENUM_DEF(id, val) \\\n\t{ val, #id },\n\n \nstatic struct brcmf_fweh_event_name fweh_event_names[] = {\n\tBRCMF_FWEH_EVENT_ENUM_DEFLIST\n};\n#undef BRCMF_ENUM_DEF\n\n \nconst char *brcmf_fweh_event_name(enum brcmf_fweh_event_code code)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(fweh_event_names); i++) {\n\t\tif (fweh_event_names[i].code == code)\n\t\t\treturn fweh_event_names[i].name;\n\t}\n\treturn \"unknown\";\n}\n#else\nconst char *brcmf_fweh_event_name(enum brcmf_fweh_event_code code)\n{\n\treturn \"nodebug\";\n}\n#endif\n\n \nstatic void brcmf_fweh_queue_event(struct brcmf_fweh_info *fweh,\n\t\t\t\t   struct brcmf_fweh_queue_item *event)\n{\n\tulong flags;\n\n\tspin_lock_irqsave(&fweh->evt_q_lock, flags);\n\tlist_add_tail(&event->q, &fweh->event_q);\n\tspin_unlock_irqrestore(&fweh->evt_q_lock, flags);\n\tschedule_work(&fweh->event_work);\n}\n\nstatic int brcmf_fweh_call_event_handler(struct brcmf_pub *drvr,\n\t\t\t\t\t struct brcmf_if *ifp,\n\t\t\t\t\t enum brcmf_fweh_event_code code,\n\t\t\t\t\t struct brcmf_event_msg *emsg,\n\t\t\t\t\t void *data)\n{\n\tstruct brcmf_fweh_info *fweh;\n\tint err = -EINVAL;\n\n\tif (ifp) {\n\t\tfweh = &ifp->drvr->fweh;\n\n\t\t \n\t\tif (fweh->evt_handler[code])\n\t\t\terr = fweh->evt_handler[code](ifp, emsg, data);\n\t\telse\n\t\t\tbphy_err(drvr, \"unhandled event %d ignored\\n\", code);\n\t} else {\n\t\tbphy_err(drvr, \"no interface object\\n\");\n\t}\n\treturn err;\n}\n\n \nstatic void brcmf_fweh_handle_if_event(struct brcmf_pub *drvr,\n\t\t\t\t       struct brcmf_event_msg *emsg,\n\t\t\t\t       void *data)\n{\n\tstruct brcmf_if_event *ifevent = data;\n\tstruct brcmf_if *ifp;\n\tbool is_p2pdev;\n\n\tbrcmf_dbg(EVENT, \"action: %u ifidx: %u bsscfgidx: %u flags: %u role: %u\\n\",\n\t\t  ifevent->action, ifevent->ifidx, ifevent->bsscfgidx,\n\t\t  ifevent->flags, ifevent->role);\n\n\t \n\tis_p2pdev = ((ifevent->flags & BRCMF_E_IF_FLAG_NOIF) &&\n\t\t     (ifevent->role == BRCMF_E_IF_ROLE_P2P_CLIENT ||\n\t\t      ((ifevent->role == BRCMF_E_IF_ROLE_STA) &&\n\t\t       (drvr->fweh.p2pdev_setup_ongoing))));\n\tif (!is_p2pdev && (ifevent->flags & BRCMF_E_IF_FLAG_NOIF)) {\n\t\tbrcmf_dbg(EVENT, \"event can be ignored\\n\");\n\t\treturn;\n\t}\n\tif (ifevent->ifidx >= BRCMF_MAX_IFS) {\n\t\tbphy_err(drvr, \"invalid interface index: %u\\n\", ifevent->ifidx);\n\t\treturn;\n\t}\n\n\tifp = drvr->iflist[ifevent->bsscfgidx];\n\n\tif (ifevent->action == BRCMF_E_IF_ADD) {\n\t\tbrcmf_dbg(EVENT, \"adding %s (%pM)\\n\", emsg->ifname,\n\t\t\t  emsg->addr);\n\t\tifp = brcmf_add_if(drvr, ifevent->bsscfgidx, ifevent->ifidx,\n\t\t\t\t   is_p2pdev, emsg->ifname, emsg->addr);\n\t\tif (IS_ERR(ifp))\n\t\t\treturn;\n\t\tif (!is_p2pdev)\n\t\t\tbrcmf_proto_add_if(drvr, ifp);\n\t\tif (!drvr->fweh.evt_handler[BRCMF_E_IF])\n\t\t\tif (brcmf_net_attach(ifp, false) < 0)\n\t\t\t\treturn;\n\t}\n\n\tif (ifp && ifevent->action == BRCMF_E_IF_CHANGE)\n\t\tbrcmf_proto_reset_if(drvr, ifp);\n\n\tbrcmf_fweh_call_event_handler(drvr, ifp, emsg->event_code, emsg,\n\t\t\t\t      data);\n\n\tif (ifp && ifevent->action == BRCMF_E_IF_DEL) {\n\t\tbool armed = brcmf_cfg80211_vif_event_armed(drvr->config);\n\n\t\t \n\t\tif (!armed)\n\t\t\tbrcmf_remove_interface(ifp, false);\n\t}\n}\n\n \nstatic struct brcmf_fweh_queue_item *\nbrcmf_fweh_dequeue_event(struct brcmf_fweh_info *fweh)\n{\n\tstruct brcmf_fweh_queue_item *event = NULL;\n\tulong flags;\n\n\tspin_lock_irqsave(&fweh->evt_q_lock, flags);\n\tif (!list_empty(&fweh->event_q)) {\n\t\tevent = list_first_entry(&fweh->event_q,\n\t\t\t\t\t struct brcmf_fweh_queue_item, q);\n\t\tlist_del(&event->q);\n\t}\n\tspin_unlock_irqrestore(&fweh->evt_q_lock, flags);\n\n\treturn event;\n}\n\n \nstatic void brcmf_fweh_event_worker(struct work_struct *work)\n{\n\tstruct brcmf_pub *drvr;\n\tstruct brcmf_if *ifp;\n\tstruct brcmf_fweh_info *fweh;\n\tstruct brcmf_fweh_queue_item *event;\n\tint err = 0;\n\tstruct brcmf_event_msg_be *emsg_be;\n\tstruct brcmf_event_msg emsg;\n\n\tfweh = container_of(work, struct brcmf_fweh_info, event_work);\n\tdrvr = container_of(fweh, struct brcmf_pub, fweh);\n\n\twhile ((event = brcmf_fweh_dequeue_event(fweh))) {\n\t\tbrcmf_dbg(EVENT, \"event %s (%u) ifidx %u bsscfg %u addr %pM\\n\",\n\t\t\t  brcmf_fweh_event_name(event->code), event->code,\n\t\t\t  event->emsg.ifidx, event->emsg.bsscfgidx,\n\t\t\t  event->emsg.addr);\n\t\tif (event->emsg.bsscfgidx >= BRCMF_MAX_IFS) {\n\t\t\tbphy_err(drvr, \"invalid bsscfg index: %u\\n\", event->emsg.bsscfgidx);\n\t\t\tgoto event_free;\n\t\t}\n\n\t\t \n\t\temsg_be = &event->emsg;\n\t\temsg.version = be16_to_cpu(emsg_be->version);\n\t\temsg.flags = be16_to_cpu(emsg_be->flags);\n\t\temsg.event_code = event->code;\n\t\temsg.status = be32_to_cpu(emsg_be->status);\n\t\temsg.reason = be32_to_cpu(emsg_be->reason);\n\t\temsg.auth_type = be32_to_cpu(emsg_be->auth_type);\n\t\temsg.datalen = be32_to_cpu(emsg_be->datalen);\n\t\tmemcpy(emsg.addr, emsg_be->addr, ETH_ALEN);\n\t\tmemcpy(emsg.ifname, emsg_be->ifname, sizeof(emsg.ifname));\n\t\temsg.ifidx = emsg_be->ifidx;\n\t\temsg.bsscfgidx = emsg_be->bsscfgidx;\n\n\t\tbrcmf_dbg(EVENT, \"  version %u flags %u status %u reason %u\\n\",\n\t\t\t  emsg.version, emsg.flags, emsg.status, emsg.reason);\n\t\tbrcmf_dbg_hex_dump(BRCMF_EVENT_ON(), event->data,\n\t\t\t\t   min_t(u32, emsg.datalen, 64),\n\t\t\t\t   \"event payload, len=%d\\n\", emsg.datalen);\n\n\t\t \n\t\tif (event->code == BRCMF_E_IF) {\n\t\t\tbrcmf_fweh_handle_if_event(drvr, &emsg, event->data);\n\t\t\tgoto event_free;\n\t\t}\n\n\t\tif (event->code == BRCMF_E_TDLS_PEER_EVENT)\n\t\t\tifp = drvr->iflist[0];\n\t\telse\n\t\t\tifp = drvr->iflist[emsg.bsscfgidx];\n\t\terr = brcmf_fweh_call_event_handler(drvr, ifp, event->code,\n\t\t\t\t\t\t    &emsg, event->data);\n\t\tif (err) {\n\t\t\tbphy_err(drvr, \"event handler failed (%d)\\n\",\n\t\t\t\t event->code);\n\t\t\terr = 0;\n\t\t}\nevent_free:\n\t\tkfree(event);\n\t}\n}\n\n \nvoid brcmf_fweh_p2pdev_setup(struct brcmf_if *ifp, bool ongoing)\n{\n\tifp->drvr->fweh.p2pdev_setup_ongoing = ongoing;\n}\n\n \nvoid brcmf_fweh_attach(struct brcmf_pub *drvr)\n{\n\tstruct brcmf_fweh_info *fweh = &drvr->fweh;\n\tINIT_WORK(&fweh->event_work, brcmf_fweh_event_worker);\n\tspin_lock_init(&fweh->evt_q_lock);\n\tINIT_LIST_HEAD(&fweh->event_q);\n}\n\n \nvoid brcmf_fweh_detach(struct brcmf_pub *drvr)\n{\n\tstruct brcmf_fweh_info *fweh = &drvr->fweh;\n\n\t \n\tif (fweh->event_work.func) {\n\t\tcancel_work_sync(&fweh->event_work);\n\t\tWARN_ON(!list_empty(&fweh->event_q));\n\t\tmemset(fweh->evt_handler, 0, sizeof(fweh->evt_handler));\n\t}\n}\n\n \nint brcmf_fweh_register(struct brcmf_pub *drvr, enum brcmf_fweh_event_code code,\n\t\t\tbrcmf_fweh_handler_t handler)\n{\n\tif (drvr->fweh.evt_handler[code]) {\n\t\tbphy_err(drvr, \"event code %d already registered\\n\", code);\n\t\treturn -ENOSPC;\n\t}\n\tdrvr->fweh.evt_handler[code] = handler;\n\tbrcmf_dbg(TRACE, \"event handler registered for %s\\n\",\n\t\t  brcmf_fweh_event_name(code));\n\treturn 0;\n}\n\n \nvoid brcmf_fweh_unregister(struct brcmf_pub *drvr,\n\t\t\t   enum brcmf_fweh_event_code code)\n{\n\tbrcmf_dbg(TRACE, \"event handler cleared for %s\\n\",\n\t\t  brcmf_fweh_event_name(code));\n\tdrvr->fweh.evt_handler[code] = NULL;\n}\n\n \nint brcmf_fweh_activate_events(struct brcmf_if *ifp)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tint i, err;\n\ts8 eventmask[BRCMF_EVENTING_MASK_LEN];\n\n\tmemset(eventmask, 0, sizeof(eventmask));\n\tfor (i = 0; i < BRCMF_E_LAST; i++) {\n\t\tif (ifp->drvr->fweh.evt_handler[i]) {\n\t\t\tbrcmf_dbg(EVENT, \"enable event %s\\n\",\n\t\t\t\t  brcmf_fweh_event_name(i));\n\t\t\tsetbit(eventmask, i);\n\t\t}\n\t}\n\n\t \n\tbrcmf_dbg(EVENT, \"enable event IF\\n\");\n\tsetbit(eventmask, BRCMF_E_IF);\n\n\terr = brcmf_fil_iovar_data_set(ifp, \"event_msgs\",\n\t\t\t\t       eventmask, BRCMF_EVENTING_MASK_LEN);\n\tif (err)\n\t\tbphy_err(drvr, \"Set event_msgs error (%d)\\n\", err);\n\n\treturn err;\n}\n\n \nvoid brcmf_fweh_process_event(struct brcmf_pub *drvr,\n\t\t\t      struct brcmf_event *event_packet,\n\t\t\t      u32 packet_len, gfp_t gfp)\n{\n\tenum brcmf_fweh_event_code code;\n\tstruct brcmf_fweh_info *fweh = &drvr->fweh;\n\tstruct brcmf_fweh_queue_item *event;\n\tvoid *data;\n\tu32 datalen;\n\n\t \n\tcode = get_unaligned_be32(&event_packet->msg.event_type);\n\tdatalen = get_unaligned_be32(&event_packet->msg.datalen);\n\tdata = &event_packet[1];\n\n\tif (code >= BRCMF_E_LAST)\n\t\treturn;\n\n\tif (code != BRCMF_E_IF && !fweh->evt_handler[code])\n\t\treturn;\n\n\tif (datalen > BRCMF_DCMD_MAXLEN ||\n\t    datalen + sizeof(*event_packet) > packet_len)\n\t\treturn;\n\n\tevent = kzalloc(sizeof(*event) + datalen, gfp);\n\tif (!event)\n\t\treturn;\n\n\tevent->code = code;\n\tevent->ifidx = event_packet->msg.ifidx;\n\n\t \n\tmemcpy(&event->emsg, &event_packet->msg, sizeof(event->emsg));\n\tmemcpy(event->data, data, datalen);\n\tevent->datalen = datalen;\n\tmemcpy(event->ifaddr, event_packet->eth.h_dest, ETH_ALEN);\n\n\tbrcmf_fweh_queue_event(fweh, event);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}