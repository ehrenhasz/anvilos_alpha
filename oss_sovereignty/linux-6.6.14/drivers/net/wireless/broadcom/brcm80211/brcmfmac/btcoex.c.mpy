{
  "module_name": "btcoex.c",
  "hash_id": "29398716eeca90f16b9d04978c165d27f8e9ee31337c8b268f4527861d512d64",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmfmac/btcoex.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include <linux/netdevice.h>\n#include <net/cfg80211.h>\n\n#include <brcmu_wifi.h>\n#include <brcmu_utils.h>\n#include <defs.h>\n#include \"core.h\"\n#include \"debug.h\"\n#include \"fwil.h\"\n#include \"fwil_types.h\"\n#include \"btcoex.h\"\n#include \"p2p.h\"\n#include \"cfg80211.h\"\n\n \n#define BRCMF_BTCOEX_OPPR_WIN_TIME   msecs_to_jiffies(2000)\n\n \n#define BRCMF_BT_DHCP_REG50 0x8022\n#define BRCMF_BT_DHCP_REG51 0\n#define BRCMF_BT_DHCP_REG64 0\n#define BRCMF_BT_DHCP_REG65 0\n#define BRCMF_BT_DHCP_REG71 0\n#define BRCMF_BT_DHCP_REG66 0x2710\n#define BRCMF_BT_DHCP_REG41 0x33\n#define BRCMF_BT_DHCP_REG68 0x190\n\n \n#define BRCMF_BT_SCO_SAMPLES 12\n\n \nenum brcmf_btcoex_state {\n\tBRCMF_BT_DHCP_IDLE,\n\tBRCMF_BT_DHCP_START,\n\tBRCMF_BT_DHCP_OPPR_WIN,\n\tBRCMF_BT_DHCP_FLAG_FORCE_TIMEOUT\n};\n\n \nstruct brcmf_btcoex_info {\n\tstruct brcmf_cfg80211_vif *vif;\n\tstruct timer_list timer;\n\tu16 timeout;\n\tbool timer_on;\n\tbool dhcp_done;\n\tenum brcmf_btcoex_state bt_state;\n\tstruct work_struct work;\n\tstruct brcmf_cfg80211_info *cfg;\n\tu32 reg66;\n\tu32 reg41;\n\tu32 reg68;\n\tbool saved_regs_part1;\n\tu32 reg50;\n\tu32 reg51;\n\tu32 reg64;\n\tu32 reg65;\n\tu32 reg71;\n\tbool saved_regs_part2;\n};\n\n \nstatic s32 brcmf_btcoex_params_write(struct brcmf_if *ifp, u32 addr, u32 data)\n{\n\tstruct {\n\t\t__le32 addr;\n\t\t__le32 data;\n\t} reg_write;\n\n\treg_write.addr = cpu_to_le32(addr);\n\treg_write.data = cpu_to_le32(data);\n\treturn brcmf_fil_iovar_data_set(ifp, \"btc_params\",\n\t\t\t\t\t&reg_write, sizeof(reg_write));\n}\n\n \nstatic s32 brcmf_btcoex_params_read(struct brcmf_if *ifp, u32 addr, u32 *data)\n{\n\t*data = addr;\n\n\treturn brcmf_fil_iovar_int_get(ifp, \"btc_params\", data);\n}\n\n \nstatic void brcmf_btcoex_boost_wifi(struct brcmf_btcoex_info *btci,\n\t\t\t\t    bool trump_sco)\n{\n\tstruct brcmf_if *ifp = brcmf_get_ifp(btci->cfg->pub, 0);\n\n\tif (trump_sco && !btci->saved_regs_part2) {\n\t\t \n\n\t\t \n\t\tbrcmf_dbg(INFO, \"new SCO/eSCO coex algo {save & override}\\n\");\n\t\tbrcmf_btcoex_params_read(ifp, 50, &btci->reg50);\n\t\tbrcmf_btcoex_params_read(ifp, 51, &btci->reg51);\n\t\tbrcmf_btcoex_params_read(ifp, 64, &btci->reg64);\n\t\tbrcmf_btcoex_params_read(ifp, 65, &btci->reg65);\n\t\tbrcmf_btcoex_params_read(ifp, 71, &btci->reg71);\n\n\t\tbtci->saved_regs_part2 = true;\n\t\tbrcmf_dbg(INFO,\n\t\t\t  \"saved bt_params[50,51,64,65,71]: 0x%x 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t  btci->reg50, btci->reg51, btci->reg64,\n\t\t\t  btci->reg65, btci->reg71);\n\n\t\t \n\t\tbrcmf_btcoex_params_write(ifp, 50, BRCMF_BT_DHCP_REG50);\n\t\tbrcmf_btcoex_params_write(ifp, 51, BRCMF_BT_DHCP_REG51);\n\t\tbrcmf_btcoex_params_write(ifp, 64, BRCMF_BT_DHCP_REG64);\n\t\tbrcmf_btcoex_params_write(ifp, 65, BRCMF_BT_DHCP_REG65);\n\t\tbrcmf_btcoex_params_write(ifp, 71, BRCMF_BT_DHCP_REG71);\n\n\t} else if (btci->saved_regs_part2) {\n\t\t \n\t\tbrcmf_dbg(INFO, \"Do new SCO/eSCO coex algo {restore}\\n\");\n\t\tbrcmf_btcoex_params_write(ifp, 50, btci->reg50);\n\t\tbrcmf_btcoex_params_write(ifp, 51, btci->reg51);\n\t\tbrcmf_btcoex_params_write(ifp, 64, btci->reg64);\n\t\tbrcmf_btcoex_params_write(ifp, 65, btci->reg65);\n\t\tbrcmf_btcoex_params_write(ifp, 71, btci->reg71);\n\n\t\tbrcmf_dbg(INFO,\n\t\t\t  \"restored bt_params[50,51,64,65,71]: 0x%x 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t  btci->reg50, btci->reg51, btci->reg64,\n\t\t\t  btci->reg65, btci->reg71);\n\n\t\tbtci->saved_regs_part2 = false;\n\t} else {\n\t\tbrcmf_dbg(INFO, \"attempted to restore not saved BTCOEX params\\n\");\n\t}\n}\n\n \nstatic bool brcmf_btcoex_is_sco_active(struct brcmf_if *ifp)\n{\n\tint ioc_res = 0;\n\tbool res = false;\n\tint sco_id_cnt = 0;\n\tu32 param27;\n\tint i;\n\n\tfor (i = 0; i < BRCMF_BT_SCO_SAMPLES; i++) {\n\t\tioc_res = brcmf_btcoex_params_read(ifp, 27, &param27);\n\n\t\tif (ioc_res < 0) {\n\t\t\tbrcmf_err(\"ioc read btc params error\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tbrcmf_dbg(INFO, \"sample[%d], btc_params 27:%x\\n\", i, param27);\n\n\t\tif ((param27 & 0x6) == 2) {  \n\t\t\tsco_id_cnt++;\n\t\t}\n\n\t\tif (sco_id_cnt > 2) {\n\t\t\tbrcmf_dbg(INFO,\n\t\t\t\t  \"sco/esco detected, pkt id_cnt:%d samples:%d\\n\",\n\t\t\t\t  sco_id_cnt, i);\n\t\t\tres = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbrcmf_dbg(TRACE, \"exit: result=%d\\n\", res);\n\treturn res;\n}\n\n \nstatic void btcmf_btcoex_save_part1(struct brcmf_btcoex_info *btci)\n{\n\tstruct brcmf_if *ifp = btci->vif->ifp;\n\n\tif (!btci->saved_regs_part1) {\n\t\t \n\t\tbrcmf_btcoex_params_read(ifp, 66, &btci->reg66);\n\t\tbrcmf_btcoex_params_read(ifp, 41, &btci->reg41);\n\t\tbrcmf_btcoex_params_read(ifp, 68, &btci->reg68);\n\t\tbtci->saved_regs_part1 = true;\n\t\tbrcmf_dbg(INFO,\n\t\t\t  \"saved btc_params regs (66,41,68) 0x%x 0x%x 0x%x\\n\",\n\t\t\t  btci->reg66, btci->reg41,\n\t\t\t  btci->reg68);\n\t}\n}\n\n \nstatic void brcmf_btcoex_restore_part1(struct brcmf_btcoex_info *btci)\n{\n\tstruct brcmf_if *ifp;\n\n\tif (btci->saved_regs_part1) {\n\t\tbtci->saved_regs_part1 = false;\n\t\tifp = btci->vif->ifp;\n\t\tbrcmf_btcoex_params_write(ifp, 66, btci->reg66);\n\t\tbrcmf_btcoex_params_write(ifp, 41, btci->reg41);\n\t\tbrcmf_btcoex_params_write(ifp, 68, btci->reg68);\n\t\tbrcmf_dbg(INFO,\n\t\t\t  \"restored btc_params regs {66,41,68} 0x%x 0x%x 0x%x\\n\",\n\t\t\t  btci->reg66, btci->reg41,\n\t\t\t  btci->reg68);\n\t}\n}\n\n \nstatic void brcmf_btcoex_timerfunc(struct timer_list *t)\n{\n\tstruct brcmf_btcoex_info *bt_local = from_timer(bt_local, t, timer);\n\tbrcmf_dbg(TRACE, \"enter\\n\");\n\n\tbt_local->timer_on = false;\n\tschedule_work(&bt_local->work);\n}\n\n \nstatic void brcmf_btcoex_handler(struct work_struct *work)\n{\n\tstruct brcmf_btcoex_info *btci;\n\tbtci = container_of(work, struct brcmf_btcoex_info, work);\n\tif (btci->timer_on) {\n\t\tbtci->timer_on = false;\n\t\tdel_timer_sync(&btci->timer);\n\t}\n\n\tswitch (btci->bt_state) {\n\tcase BRCMF_BT_DHCP_START:\n\t\t \n\t\tbrcmf_dbg(INFO, \"DHCP started\\n\");\n\t\tbtci->bt_state = BRCMF_BT_DHCP_OPPR_WIN;\n\t\tif (btci->timeout < BRCMF_BTCOEX_OPPR_WIN_TIME) {\n\t\t\tmod_timer(&btci->timer, btci->timer.expires);\n\t\t} else {\n\t\t\tbtci->timeout -= BRCMF_BTCOEX_OPPR_WIN_TIME;\n\t\t\tmod_timer(&btci->timer,\n\t\t\t\t  jiffies + BRCMF_BTCOEX_OPPR_WIN_TIME);\n\t\t}\n\t\tbtci->timer_on = true;\n\t\tbreak;\n\n\tcase BRCMF_BT_DHCP_OPPR_WIN:\n\t\tif (btci->dhcp_done) {\n\t\t\tbrcmf_dbg(INFO, \"DHCP done before T1 expiration\\n\");\n\t\t\tgoto idle;\n\t\t}\n\n\t\t \n\t\tbrcmf_dbg(INFO, \"DHCP T1:%d expired\\n\",\n\t\t\t  jiffies_to_msecs(BRCMF_BTCOEX_OPPR_WIN_TIME));\n\t\tbrcmf_btcoex_boost_wifi(btci, true);\n\n\t\tbtci->bt_state = BRCMF_BT_DHCP_FLAG_FORCE_TIMEOUT;\n\t\tmod_timer(&btci->timer, jiffies + btci->timeout);\n\t\tbtci->timer_on = true;\n\t\tbreak;\n\n\tcase BRCMF_BT_DHCP_FLAG_FORCE_TIMEOUT:\n\t\tif (btci->dhcp_done)\n\t\t\tbrcmf_dbg(INFO, \"DHCP done before T2 expiration\\n\");\n\t\telse\n\t\t\tbrcmf_dbg(INFO, \"DHCP T2:%d expired\\n\",\n\t\t\t\t  BRCMF_BT_DHCP_FLAG_FORCE_TIMEOUT);\n\n\t\tgoto idle;\n\n\tdefault:\n\t\tbrcmf_err(\"invalid state=%d !!!\\n\", btci->bt_state);\n\t\tgoto idle;\n\t}\n\n\treturn;\n\nidle:\n\tbtci->bt_state = BRCMF_BT_DHCP_IDLE;\n\tbtci->timer_on = false;\n\tbrcmf_btcoex_boost_wifi(btci, false);\n\tcfg80211_crit_proto_stopped(&btci->vif->wdev, GFP_KERNEL);\n\tbrcmf_btcoex_restore_part1(btci);\n\tbtci->vif = NULL;\n}\n\n \nint brcmf_btcoex_attach(struct brcmf_cfg80211_info *cfg)\n{\n\tstruct brcmf_btcoex_info *btci = NULL;\n\tbrcmf_dbg(TRACE, \"enter\\n\");\n\n\tbtci = kmalloc(sizeof(struct brcmf_btcoex_info), GFP_KERNEL);\n\tif (!btci)\n\t\treturn -ENOMEM;\n\n\tbtci->bt_state = BRCMF_BT_DHCP_IDLE;\n\n\t \n\tbtci->timer_on = false;\n\tbtci->timeout = BRCMF_BTCOEX_OPPR_WIN_TIME;\n\ttimer_setup(&btci->timer, brcmf_btcoex_timerfunc, 0);\n\tbtci->cfg = cfg;\n\tbtci->saved_regs_part1 = false;\n\tbtci->saved_regs_part2 = false;\n\n\tINIT_WORK(&btci->work, brcmf_btcoex_handler);\n\n\tcfg->btcoex = btci;\n\treturn 0;\n}\n\n \nvoid brcmf_btcoex_detach(struct brcmf_cfg80211_info *cfg)\n{\n\tbrcmf_dbg(TRACE, \"enter\\n\");\n\n\tif (!cfg->btcoex)\n\t\treturn;\n\n\tif (cfg->btcoex->timer_on) {\n\t\tcfg->btcoex->timer_on = false;\n\t\ttimer_shutdown_sync(&cfg->btcoex->timer);\n\t}\n\n\tcancel_work_sync(&cfg->btcoex->work);\n\n\tbrcmf_btcoex_boost_wifi(cfg->btcoex, false);\n\tbrcmf_btcoex_restore_part1(cfg->btcoex);\n\n\tkfree(cfg->btcoex);\n\tcfg->btcoex = NULL;\n}\n\nstatic void brcmf_btcoex_dhcp_start(struct brcmf_btcoex_info *btci)\n{\n\tstruct brcmf_if *ifp = btci->vif->ifp;\n\n\tbtcmf_btcoex_save_part1(btci);\n\t \n\tbrcmf_btcoex_params_write(ifp, 66, BRCMF_BT_DHCP_REG66);\n\tbrcmf_btcoex_params_write(ifp, 41, BRCMF_BT_DHCP_REG41);\n\tbrcmf_btcoex_params_write(ifp, 68, BRCMF_BT_DHCP_REG68);\n\tbtci->dhcp_done = false;\n\tbtci->bt_state = BRCMF_BT_DHCP_START;\n\tschedule_work(&btci->work);\n\tbrcmf_dbg(TRACE, \"enable BT DHCP Timer\\n\");\n}\n\nstatic void brcmf_btcoex_dhcp_end(struct brcmf_btcoex_info *btci)\n{\n\t \n\tbtci->dhcp_done = true;\n\tif (btci->timer_on) {\n\t\tbrcmf_dbg(INFO, \"disable BT DHCP Timer\\n\");\n\t\tbtci->timer_on = false;\n\t\tdel_timer_sync(&btci->timer);\n\n\t\t \n\t\tif (btci->bt_state != BRCMF_BT_DHCP_IDLE) {\n\t\t\tbrcmf_dbg(INFO, \"bt_state:%d\\n\",\n\t\t\t\t  btci->bt_state);\n\t\t\tschedule_work(&btci->work);\n\t\t}\n\t} else {\n\t\t \n\t\tbrcmf_btcoex_restore_part1(btci);\n\t}\n}\n\n \nint brcmf_btcoex_set_mode(struct brcmf_cfg80211_vif *vif,\n\t\t\t  enum brcmf_btcoex_mode mode, u16 duration)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(vif->wdev.wiphy);\n\tstruct brcmf_btcoex_info *btci = cfg->btcoex;\n\tstruct brcmf_if *ifp = brcmf_get_ifp(cfg->pub, 0);\n\n\tswitch (mode) {\n\tcase BRCMF_BTCOEX_DISABLED:\n\t\tbrcmf_dbg(INFO, \"DHCP session starts\\n\");\n\t\tif (btci->bt_state != BRCMF_BT_DHCP_IDLE)\n\t\t\treturn -EBUSY;\n\t\t \n\t\tif (brcmf_btcoex_is_sco_active(ifp)) {\n\t\t\tbtci->timeout = msecs_to_jiffies(duration);\n\t\t\tbtci->vif = vif;\n\t\t\tbrcmf_btcoex_dhcp_start(btci);\n\t\t}\n\t\tbreak;\n\n\tcase BRCMF_BTCOEX_ENABLED:\n\t\tbrcmf_dbg(INFO, \"DHCP session ends\\n\");\n\t\tif (btci->bt_state != BRCMF_BT_DHCP_IDLE &&\n\t\t    vif == btci->vif) {\n\t\t\tbrcmf_btcoex_dhcp_end(btci);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbrcmf_dbg(INFO, \"Unknown mode, ignored\\n\");\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}