{
  "module_name": "fwsignal.c",
  "hash_id": "78b37513cc2e4fb84e4062bc5fc705235f964b8f3a315c61b912ecbcc4dd9931",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/if_ether.h>\n#include <linux/spinlock.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/err.h>\n#include <linux/jiffies.h>\n#include <net/cfg80211.h>\n\n#include <brcmu_utils.h>\n#include <brcmu_wifi.h>\n#include \"core.h\"\n#include \"debug.h\"\n#include \"bus.h\"\n#include \"fwil.h\"\n#include \"fwil_types.h\"\n#include \"fweh.h\"\n#include \"fwsignal.h\"\n#include \"p2p.h\"\n#include \"cfg80211.h\"\n#include \"proto.h\"\n#include \"bcdc.h\"\n#include \"common.h\"\n\n \n\n \n#define BRCMF_FWS_TLV_DEFLIST \\\n\tBRCMF_FWS_TLV_DEF(MAC_OPEN, 1, 1) \\\n\tBRCMF_FWS_TLV_DEF(MAC_CLOSE, 2, 1) \\\n\tBRCMF_FWS_TLV_DEF(MAC_REQUEST_CREDIT, 3, 2) \\\n\tBRCMF_FWS_TLV_DEF(TXSTATUS, 4, 4) \\\n\tBRCMF_FWS_TLV_DEF(PKTTAG, 5, 4) \\\n\tBRCMF_FWS_TLV_DEF(MACDESC_ADD,\t6, 8) \\\n\tBRCMF_FWS_TLV_DEF(MACDESC_DEL, 7, 8) \\\n\tBRCMF_FWS_TLV_DEF(RSSI, 8, 1) \\\n\tBRCMF_FWS_TLV_DEF(INTERFACE_OPEN, 9, 1) \\\n\tBRCMF_FWS_TLV_DEF(INTERFACE_CLOSE, 10, 1) \\\n\tBRCMF_FWS_TLV_DEF(FIFO_CREDITBACK, 11, 6) \\\n\tBRCMF_FWS_TLV_DEF(PENDING_TRAFFIC_BMP, 12, 2) \\\n\tBRCMF_FWS_TLV_DEF(MAC_REQUEST_PACKET, 13, 3) \\\n\tBRCMF_FWS_TLV_DEF(HOST_REORDER_RXPKTS, 14, 10) \\\n\tBRCMF_FWS_TLV_DEF(TRANS_ID, 18, 6) \\\n\tBRCMF_FWS_TLV_DEF(COMP_TXSTATUS, 19, 1) \\\n\tBRCMF_FWS_TLV_DEF(FILLER, 255, 0)\n\n \n#define BRCMF_FWS_TLV_DEF(name, id, len) \\\n\tBRCMF_FWS_TYPE_ ## name =  id,\nenum brcmf_fws_tlv_type {\n\tBRCMF_FWS_TLV_DEFLIST\n\tBRCMF_FWS_TYPE_INVALID\n};\n#undef BRCMF_FWS_TLV_DEF\n\n \n#define BRCMF_FWS_TLV_DEF(name, id, len) \\\n\tBRCMF_FWS_TYPE_ ## name ## _LEN = (len),\nenum brcmf_fws_tlv_len {\n\tBRCMF_FWS_TLV_DEFLIST\n};\n#undef BRCMF_FWS_TLV_DEF\n\n \n#define BRCMF_RXREORDER_FLOWID_OFFSET\t\t0\n#define BRCMF_RXREORDER_MAXIDX_OFFSET\t\t2\n#define BRCMF_RXREORDER_FLAGS_OFFSET\t\t4\n#define BRCMF_RXREORDER_CURIDX_OFFSET\t\t6\n#define BRCMF_RXREORDER_EXPIDX_OFFSET\t\t8\n\n#define BRCMF_RXREORDER_DEL_FLOW\t\t0x01\n#define BRCMF_RXREORDER_FLUSH_ALL\t\t0x02\n#define BRCMF_RXREORDER_CURIDX_VALID\t\t0x04\n#define BRCMF_RXREORDER_EXPIDX_VALID\t\t0x08\n#define BRCMF_RXREORDER_NEW_HOLE\t\t0x10\n\n#ifdef DEBUG\n \n#define BRCMF_FWS_TLV_DEF(name, id, len) \\\n\t{ id, #name },\nstatic struct {\n\tenum brcmf_fws_tlv_type id;\n\tconst char *name;\n} brcmf_fws_tlv_names[] = {\n\tBRCMF_FWS_TLV_DEFLIST\n};\n#undef BRCMF_FWS_TLV_DEF\n\n\nstatic const char *brcmf_fws_get_tlv_name(enum brcmf_fws_tlv_type id)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(brcmf_fws_tlv_names); i++)\n\t\tif (brcmf_fws_tlv_names[i].id == id)\n\t\t\treturn brcmf_fws_tlv_names[i].name;\n\n\treturn \"INVALID\";\n}\n#else\nstatic const char *brcmf_fws_get_tlv_name(enum brcmf_fws_tlv_type id)\n{\n\treturn \"NODEBUG\";\n}\n#endif  \n\n \n#define BRCMF_FWS_TYPE_SEQ_LEN\t\t\t\t2\n\n \n#define BRCMF_FWS_FLAGS_RSSI_SIGNALS\t\t\t0x0001\n#define BRCMF_FWS_FLAGS_XONXOFF_SIGNALS\t\t\t0x0002\n#define BRCMF_FWS_FLAGS_CREDIT_STATUS_SIGNALS\t\t0x0004\n#define BRCMF_FWS_FLAGS_HOST_PROPTXSTATUS_ACTIVE\t0x0008\n#define BRCMF_FWS_FLAGS_PSQ_GENERATIONFSM_ENABLE\t0x0010\n#define BRCMF_FWS_FLAGS_PSQ_ZERO_BUFFER_ENABLE\t\t0x0020\n#define BRCMF_FWS_FLAGS_HOST_RXREORDER_ACTIVE\t\t0x0040\n\n#define BRCMF_FWS_MAC_DESC_TABLE_SIZE\t\t\t32\n#define BRCMF_FWS_MAC_DESC_ID_INVALID\t\t\t0xff\n\n#define BRCMF_FWS_HOSTIF_FLOWSTATE_OFF\t\t\t0\n#define BRCMF_FWS_HOSTIF_FLOWSTATE_ON\t\t\t1\n#define BRCMF_FWS_FLOWCONTROL_HIWATER\t\t\t128\n#define BRCMF_FWS_FLOWCONTROL_LOWATER\t\t\t64\n\n#define BRCMF_FWS_PSQ_PREC_COUNT\t\t((BRCMF_FWS_FIFO_COUNT + 1) * 2)\n#define BRCMF_FWS_PSQ_LEN\t\t\t\t256\n\n#define BRCMF_FWS_HTOD_FLAG_PKTFROMHOST\t\t\t0x01\n#define BRCMF_FWS_HTOD_FLAG_PKT_REQUESTED\t\t0x02\n\n#define BRCMF_FWS_RET_OK_NOSCHEDULE\t\t\t0\n#define BRCMF_FWS_RET_OK_SCHEDULE\t\t\t1\n\n#define BRCMF_FWS_MODE_REUSESEQ_SHIFT\t\t\t3\t \n#define BRCMF_FWS_MODE_SET_REUSESEQ(x, val)\t((x) = \\\n\t\t((x) & ~(1 << BRCMF_FWS_MODE_REUSESEQ_SHIFT)) | \\\n\t\t(((val) & 1) << BRCMF_FWS_MODE_REUSESEQ_SHIFT))\n#define BRCMF_FWS_MODE_GET_REUSESEQ(x)\t\\\n\t\t(((x) >> BRCMF_FWS_MODE_REUSESEQ_SHIFT) & 1)\n\n \nenum brcmf_fws_skb_state {\n\tBRCMF_FWS_SKBSTATE_NEW,\n\tBRCMF_FWS_SKBSTATE_DELAYED,\n\tBRCMF_FWS_SKBSTATE_SUPPRESSED,\n\tBRCMF_FWS_SKBSTATE_TIM\n};\n\n \nstruct brcmf_skbuff_cb {\n\tu16 bus_flags;\n\tu16 if_flags;\n\tu32 htod;\n\tu16 htod_seq;\n\tenum brcmf_fws_skb_state state;\n\tstruct brcmf_fws_mac_descriptor *mac;\n};\n\n \n#define brcmf_skbcb(skb)\t((struct brcmf_skbuff_cb *)((skb)->cb))\n\n \n#define BRCMF_SKB_IF_FLAGS_REQUESTED_MASK\t0x0800\n#define BRCMF_SKB_IF_FLAGS_REQUESTED_SHIFT\t11\n#define BRCMF_SKB_IF_FLAGS_SIGNAL_ONLY_MASK\t0x0400\n#define BRCMF_SKB_IF_FLAGS_SIGNAL_ONLY_SHIFT\t10\n#define BRCMF_SKB_IF_FLAGS_TRANSMIT_MASK        0x0200\n#define BRCMF_SKB_IF_FLAGS_TRANSMIT_SHIFT\t9\n#define BRCMF_SKB_IF_FLAGS_REQ_CREDIT_MASK\t0x0100\n#define BRCMF_SKB_IF_FLAGS_REQ_CREDIT_SHIFT\t8\n#define BRCMF_SKB_IF_FLAGS_IF_AP_MASK\t\t0x0080\n#define BRCMF_SKB_IF_FLAGS_IF_AP_SHIFT\t\t7\n#define BRCMF_SKB_IF_FLAGS_INDEX_MASK\t\t0x000f\n#define BRCMF_SKB_IF_FLAGS_INDEX_SHIFT\t\t0\n\n#define brcmf_skb_if_flags_set_field(skb, field, value) \\\n\tbrcmu_maskset16(&(brcmf_skbcb(skb)->if_flags), \\\n\t\t\tBRCMF_SKB_IF_FLAGS_ ## field ## _MASK, \\\n\t\t\tBRCMF_SKB_IF_FLAGS_ ## field ## _SHIFT, (value))\n#define brcmf_skb_if_flags_get_field(skb, field) \\\n\tbrcmu_maskget16(brcmf_skbcb(skb)->if_flags, \\\n\t\t\tBRCMF_SKB_IF_FLAGS_ ## field ## _MASK, \\\n\t\t\tBRCMF_SKB_IF_FLAGS_ ## field ## _SHIFT)\n\n \n#define BRCMF_SKB_HTOD_TAG_GENERATION_MASK\t\t0x80000000\n#define BRCMF_SKB_HTOD_TAG_GENERATION_SHIFT\t\t31\n#define BRCMF_SKB_HTOD_TAG_FLAGS_MASK\t\t\t0x78000000\n#define BRCMF_SKB_HTOD_TAG_FLAGS_SHIFT\t\t\t27\n#define BRCMF_SKB_HTOD_TAG_FIFO_MASK\t\t\t0x07000000\n#define BRCMF_SKB_HTOD_TAG_FIFO_SHIFT\t\t\t24\n#define BRCMF_SKB_HTOD_TAG_HSLOT_MASK\t\t\t0x00ffff00\n#define BRCMF_SKB_HTOD_TAG_HSLOT_SHIFT\t\t\t8\n#define BRCMF_SKB_HTOD_TAG_FREERUN_MASK\t\t\t0x000000ff\n#define BRCMF_SKB_HTOD_TAG_FREERUN_SHIFT\t\t0\n\n#define brcmf_skb_htod_tag_set_field(skb, field, value) \\\n\tbrcmu_maskset32(&(brcmf_skbcb(skb)->htod), \\\n\t\t\tBRCMF_SKB_HTOD_TAG_ ## field ## _MASK, \\\n\t\t\tBRCMF_SKB_HTOD_TAG_ ## field ## _SHIFT, (value))\n#define brcmf_skb_htod_tag_get_field(skb, field) \\\n\tbrcmu_maskget32(brcmf_skbcb(skb)->htod, \\\n\t\t\tBRCMF_SKB_HTOD_TAG_ ## field ## _MASK, \\\n\t\t\tBRCMF_SKB_HTOD_TAG_ ## field ## _SHIFT)\n\n#define BRCMF_SKB_HTOD_SEQ_FROMFW_MASK\t\t\t0x2000\n#define BRCMF_SKB_HTOD_SEQ_FROMFW_SHIFT\t\t\t13\n#define BRCMF_SKB_HTOD_SEQ_FROMDRV_MASK\t\t\t0x1000\n#define BRCMF_SKB_HTOD_SEQ_FROMDRV_SHIFT\t\t12\n#define BRCMF_SKB_HTOD_SEQ_NR_MASK\t\t\t0x0fff\n#define BRCMF_SKB_HTOD_SEQ_NR_SHIFT\t\t\t0\n\n#define brcmf_skb_htod_seq_set_field(skb, field, value) \\\n\tbrcmu_maskset16(&(brcmf_skbcb(skb)->htod_seq), \\\n\t\t\tBRCMF_SKB_HTOD_SEQ_ ## field ## _MASK, \\\n\t\t\tBRCMF_SKB_HTOD_SEQ_ ## field ## _SHIFT, (value))\n#define brcmf_skb_htod_seq_get_field(skb, field) \\\n\tbrcmu_maskget16(brcmf_skbcb(skb)->htod_seq, \\\n\t\t\tBRCMF_SKB_HTOD_SEQ_ ## field ## _MASK, \\\n\t\t\tBRCMF_SKB_HTOD_SEQ_ ## field ## _SHIFT)\n\n#define BRCMF_FWS_TXSTAT_GENERATION_MASK\t0x80000000\n#define BRCMF_FWS_TXSTAT_GENERATION_SHIFT\t31\n#define BRCMF_FWS_TXSTAT_FLAGS_MASK\t\t0x78000000\n#define BRCMF_FWS_TXSTAT_FLAGS_SHIFT\t\t27\n#define BRCMF_FWS_TXSTAT_FIFO_MASK\t\t0x07000000\n#define BRCMF_FWS_TXSTAT_FIFO_SHIFT\t\t24\n#define BRCMF_FWS_TXSTAT_HSLOT_MASK\t\t0x00FFFF00\n#define BRCMF_FWS_TXSTAT_HSLOT_SHIFT\t\t8\n#define BRCMF_FWS_TXSTAT_FREERUN_MASK\t\t0x000000FF\n#define BRCMF_FWS_TXSTAT_FREERUN_SHIFT\t\t0\n\n#define brcmf_txstatus_get_field(txs, field) \\\n\tbrcmu_maskget32(txs, BRCMF_FWS_TXSTAT_ ## field ## _MASK, \\\n\t\t\tBRCMF_FWS_TXSTAT_ ## field ## _SHIFT)\n\n \n#define BRCMF_FWS_BORROW_DEFER_PERIOD\t\t(HZ / 10)\n\n\n \nenum brcmf_fws_txstatus {\n\tBRCMF_FWS_TXSTATUS_DISCARD,\n\tBRCMF_FWS_TXSTATUS_CORE_SUPPRESS,\n\tBRCMF_FWS_TXSTATUS_FW_PS_SUPPRESS,\n\tBRCMF_FWS_TXSTATUS_FW_TOSSED,\n\tBRCMF_FWS_TXSTATUS_FW_DISCARD_NOACK,\n\tBRCMF_FWS_TXSTATUS_FW_SUPPRESS_ACKED,\n\tBRCMF_FWS_TXSTATUS_HOST_TOSSED\n};\n\nenum brcmf_fws_fcmode {\n\tBRCMF_FWS_FCMODE_NONE,\n\tBRCMF_FWS_FCMODE_IMPLIED_CREDIT,\n\tBRCMF_FWS_FCMODE_EXPLICIT_CREDIT\n};\n\nenum brcmf_fws_mac_desc_state {\n\tBRCMF_FWS_STATE_OPEN = 1,\n\tBRCMF_FWS_STATE_CLOSE\n};\n\n \nstruct brcmf_fws_mac_descriptor {\n\tchar name[16];\n\tu8 occupied;\n\tu8 mac_handle;\n\tu8 interface_id;\n\tu8 state;\n\tbool suppressed;\n\tu8 generation;\n\tu8 ac_bitmap;\n\tu8 requested_credit;\n\tu8 requested_packet;\n\tu8 ea[ETH_ALEN];\n\tu8 seq[BRCMF_FWS_FIFO_COUNT];\n\tstruct pktq psq;\n\tint transit_count;\n\tint suppr_transit_count;\n\tbool send_tim_signal;\n\tu8 traffic_pending_bmp;\n\tu8 traffic_lastreported_bmp;\n};\n\n#define BRCMF_FWS_HANGER_MAXITEMS\t3072\n#define BRCMF_BORROW_RATIO\t\t\t3\n\n \nenum brcmf_fws_hanger_item_state {\n\tBRCMF_FWS_HANGER_ITEM_STATE_FREE = 1,\n\tBRCMF_FWS_HANGER_ITEM_STATE_INUSE,\n\tBRCMF_FWS_HANGER_ITEM_STATE_INUSE_SUPPRESSED\n};\n\n\n \nstruct brcmf_fws_hanger_item {\n\tenum brcmf_fws_hanger_item_state state;\n\tstruct sk_buff *pkt;\n};\n\n \nstruct brcmf_fws_hanger {\n\tu32 pushed;\n\tu32 popped;\n\tu32 failed_to_push;\n\tu32 failed_to_pop;\n\tu32 failed_slotfind;\n\tu32 slot_pos;\n\tstruct brcmf_fws_hanger_item items[BRCMF_FWS_HANGER_MAXITEMS];\n};\n\nstruct brcmf_fws_macdesc_table {\n\tstruct brcmf_fws_mac_descriptor nodes[BRCMF_FWS_MAC_DESC_TABLE_SIZE];\n\tstruct brcmf_fws_mac_descriptor iface[BRCMF_MAX_IFS];\n\tstruct brcmf_fws_mac_descriptor other;\n};\n\nstruct brcmf_fws_stats {\n\tu32 tlv_parse_failed;\n\tu32 tlv_invalid_type;\n\tu32 header_only_pkt;\n\tu32 header_pulls;\n\tu32 pkt2bus;\n\tu32 send_pkts[5];\n\tu32 requested_sent[5];\n\tu32 generic_error;\n\tu32 mac_update_failed;\n\tu32 mac_ps_update_failed;\n\tu32 if_update_failed;\n\tu32 packet_request_failed;\n\tu32 credit_request_failed;\n\tu32 rollback_success;\n\tu32 rollback_failed;\n\tu32 delayq_full_error;\n\tu32 supprq_full_error;\n\tu32 txs_indicate;\n\tu32 txs_discard;\n\tu32 txs_supp_core;\n\tu32 txs_supp_ps;\n\tu32 txs_tossed;\n\tu32 txs_host_tossed;\n\tu32 bus_flow_block;\n\tu32 fws_flow_block;\n};\n\nstruct brcmf_fws_info {\n\tstruct brcmf_pub *drvr;\n\tspinlock_t spinlock;\n\tulong flags;\n\tstruct brcmf_fws_stats stats;\n\tstruct brcmf_fws_hanger hanger;\n\tenum brcmf_fws_fcmode fcmode;\n\tbool fw_signals;\n\tbool bcmc_credit_check;\n\tstruct brcmf_fws_macdesc_table desc;\n\tstruct workqueue_struct *fws_wq;\n\tstruct work_struct fws_dequeue_work;\n\tu32 fifo_enqpkt[BRCMF_FWS_FIFO_COUNT];\n\tint fifo_credit[BRCMF_FWS_FIFO_COUNT];\n\tint init_fifo_credit[BRCMF_FWS_FIFO_COUNT];\n\tint credits_borrowed[BRCMF_FWS_FIFO_AC_VO + 1]\n\t\t[BRCMF_FWS_FIFO_AC_VO + 1];\n\tint deq_node_pos[BRCMF_FWS_FIFO_COUNT];\n\tu32 fifo_credit_map;\n\tu32 fifo_delay_map;\n\tunsigned long borrow_defer_timestamp;\n\tbool bus_flow_blocked;\n\tbool creditmap_received;\n\tu8 mode;\n\tbool avoid_queueing;\n};\n\n#define BRCMF_FWS_TLV_DEF(name, id, len) \\\n\tcase BRCMF_FWS_TYPE_ ## name: \\\n\t\treturn len;\n\n \nstatic int brcmf_fws_get_tlv_len(struct brcmf_fws_info *fws,\n\t\t\t\t enum brcmf_fws_tlv_type id)\n{\n\tswitch (id) {\n\tBRCMF_FWS_TLV_DEFLIST\n\tdefault:\n\t\tfws->stats.tlv_invalid_type++;\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n#undef BRCMF_FWS_TLV_DEF\n\nstatic void brcmf_fws_lock(struct brcmf_fws_info *fws)\n\t\t__acquires(&fws->spinlock)\n{\n\tspin_lock_irqsave(&fws->spinlock, fws->flags);\n}\n\nstatic void brcmf_fws_unlock(struct brcmf_fws_info *fws)\n\t\t__releases(&fws->spinlock)\n{\n\tspin_unlock_irqrestore(&fws->spinlock, fws->flags);\n}\n\nstatic bool brcmf_fws_ifidx_match(struct sk_buff *skb, void *arg)\n{\n\tu32 ifidx = brcmf_skb_if_flags_get_field(skb, INDEX);\n\treturn ifidx == *(int *)arg;\n}\n\nstatic void brcmf_fws_hanger_init(struct brcmf_fws_hanger *hanger)\n{\n\tint i;\n\n\tmemset(hanger, 0, sizeof(*hanger));\n\tfor (i = 0; i < ARRAY_SIZE(hanger->items); i++)\n\t\thanger->items[i].state = BRCMF_FWS_HANGER_ITEM_STATE_FREE;\n}\n\nstatic u32 brcmf_fws_hanger_get_free_slot(struct brcmf_fws_hanger *h)\n{\n\tu32 i;\n\n\ti = (h->slot_pos + 1) % BRCMF_FWS_HANGER_MAXITEMS;\n\n\twhile (i != h->slot_pos) {\n\t\tif (h->items[i].state == BRCMF_FWS_HANGER_ITEM_STATE_FREE) {\n\t\t\th->slot_pos = i;\n\t\t\tgoto done;\n\t\t}\n\t\ti++;\n\t\tif (i == BRCMF_FWS_HANGER_MAXITEMS)\n\t\t\ti = 0;\n\t}\n\tbrcmf_err(\"all slots occupied\\n\");\n\th->failed_slotfind++;\n\ti = BRCMF_FWS_HANGER_MAXITEMS;\ndone:\n\treturn i;\n}\n\nstatic int brcmf_fws_hanger_pushpkt(struct brcmf_fws_hanger *h,\n\t\t\t\t    struct sk_buff *pkt, u32 slot_id)\n{\n\tif (slot_id >= BRCMF_FWS_HANGER_MAXITEMS)\n\t\treturn -ENOENT;\n\n\tif (h->items[slot_id].state != BRCMF_FWS_HANGER_ITEM_STATE_FREE) {\n\t\tbrcmf_err(\"slot is not free\\n\");\n\t\th->failed_to_push++;\n\t\treturn -EINVAL;\n\t}\n\n\th->items[slot_id].state = BRCMF_FWS_HANGER_ITEM_STATE_INUSE;\n\th->items[slot_id].pkt = pkt;\n\th->pushed++;\n\treturn 0;\n}\n\nstatic inline int brcmf_fws_hanger_poppkt(struct brcmf_fws_hanger *h,\n\t\t\t\t\t  u32 slot_id, struct sk_buff **pktout,\n\t\t\t\t\t  bool remove_item)\n{\n\tif (slot_id >= BRCMF_FWS_HANGER_MAXITEMS)\n\t\treturn -ENOENT;\n\n\tif (h->items[slot_id].state == BRCMF_FWS_HANGER_ITEM_STATE_FREE) {\n\t\tbrcmf_err(\"entry not in use\\n\");\n\t\th->failed_to_pop++;\n\t\treturn -EINVAL;\n\t}\n\n\t*pktout = h->items[slot_id].pkt;\n\tif (remove_item) {\n\t\th->items[slot_id].state = BRCMF_FWS_HANGER_ITEM_STATE_FREE;\n\t\th->items[slot_id].pkt = NULL;\n\t\th->popped++;\n\t}\n\treturn 0;\n}\n\nstatic void brcmf_fws_psq_flush(struct brcmf_fws_info *fws, struct pktq *q,\n\t\t\t\tint ifidx)\n{\n\tstruct brcmf_fws_hanger_item *hi;\n\tbool (*matchfn)(struct sk_buff *, void *) = NULL;\n\tstruct sk_buff *skb;\n\tint prec;\n\tu32 hslot;\n\n\tif (ifidx != -1)\n\t\tmatchfn = brcmf_fws_ifidx_match;\n\tfor (prec = 0; prec < q->num_prec; prec++) {\n\t\tskb = brcmu_pktq_pdeq_match(q, prec, matchfn, &ifidx);\n\t\twhile (skb) {\n\t\t\thslot = brcmf_skb_htod_tag_get_field(skb, HSLOT);\n\t\t\thi = &fws->hanger.items[hslot];\n\t\t\tWARN_ON(skb != hi->pkt);\n\t\t\thi->state = BRCMF_FWS_HANGER_ITEM_STATE_FREE;\n\t\t\tbrcmf_fws_hanger_poppkt(&fws->hanger, hslot, &skb,\n\t\t\t\t\t\ttrue);\n\t\t\tbrcmu_pkt_buf_free_skb(skb);\n\t\t\tskb = brcmu_pktq_pdeq_match(q, prec, matchfn, &ifidx);\n\t\t}\n\t}\n}\n\nstatic int brcmf_fws_hanger_mark_suppressed(struct brcmf_fws_hanger *h,\n\t\t\t\t\t    u32 slot_id)\n{\n\tif (slot_id >= BRCMF_FWS_HANGER_MAXITEMS)\n\t\treturn -ENOENT;\n\n\tif (h->items[slot_id].state == BRCMF_FWS_HANGER_ITEM_STATE_FREE) {\n\t\tbrcmf_err(\"entry not in use\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\th->items[slot_id].state = BRCMF_FWS_HANGER_ITEM_STATE_INUSE_SUPPRESSED;\n\treturn 0;\n}\n\nstatic void brcmf_fws_hanger_cleanup(struct brcmf_fws_info *fws,\n\t\t\t\t     bool (*fn)(struct sk_buff *, void *),\n\t\t\t\t     int ifidx)\n{\n\tstruct brcmf_fws_hanger *h = &fws->hanger;\n\tstruct sk_buff *skb;\n\tint i;\n\tenum brcmf_fws_hanger_item_state s;\n\n\tfor (i = 0; i < ARRAY_SIZE(h->items); i++) {\n\t\ts = h->items[i].state;\n\t\tif (s == BRCMF_FWS_HANGER_ITEM_STATE_INUSE ||\n\t\t    s == BRCMF_FWS_HANGER_ITEM_STATE_INUSE_SUPPRESSED) {\n\t\t\tskb = h->items[i].pkt;\n\t\t\tif (fn == NULL || fn(skb, &ifidx)) {\n\t\t\t\t \n\t\t\t\tif (s == BRCMF_FWS_HANGER_ITEM_STATE_INUSE)\n\t\t\t\t\tbrcmu_pkt_buf_free_skb(skb);\n\t\t\t\th->items[i].state =\n\t\t\t\t\tBRCMF_FWS_HANGER_ITEM_STATE_FREE;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void brcmf_fws_macdesc_set_name(struct brcmf_fws_info *fws,\n\t\t\t\t       struct brcmf_fws_mac_descriptor *desc)\n{\n\tif (desc == &fws->desc.other)\n\t\tstrscpy(desc->name, \"MAC-OTHER\", sizeof(desc->name));\n\telse if (desc->mac_handle)\n\t\tscnprintf(desc->name, sizeof(desc->name), \"MAC-%d:%d\",\n\t\t\t  desc->mac_handle, desc->interface_id);\n\telse\n\t\tscnprintf(desc->name, sizeof(desc->name), \"MACIF:%d\",\n\t\t\t  desc->interface_id);\n}\n\nstatic void brcmf_fws_macdesc_init(struct brcmf_fws_mac_descriptor *desc,\n\t\t\t\t   u8 *addr, u8 ifidx)\n{\n\tbrcmf_dbg(TRACE,\n\t\t  \"enter: desc %p ea=%pM, ifidx=%u\\n\", desc, addr, ifidx);\n\tdesc->occupied = 1;\n\tdesc->state = BRCMF_FWS_STATE_OPEN;\n\tdesc->requested_credit = 0;\n\tdesc->requested_packet = 0;\n\t \n\tdesc->interface_id = ifidx;\n\tdesc->ac_bitmap = 0xff;  \n\tif (addr)\n\t\tmemcpy(&desc->ea[0], addr, ETH_ALEN);\n}\n\nstatic\nvoid brcmf_fws_macdesc_deinit(struct brcmf_fws_mac_descriptor *desc)\n{\n\tbrcmf_dbg(TRACE,\n\t\t  \"enter: ea=%pM, ifidx=%u\\n\", desc->ea, desc->interface_id);\n\tdesc->occupied = 0;\n\tdesc->state = BRCMF_FWS_STATE_CLOSE;\n\tdesc->requested_credit = 0;\n\tdesc->requested_packet = 0;\n}\n\nstatic struct brcmf_fws_mac_descriptor *\nbrcmf_fws_macdesc_lookup(struct brcmf_fws_info *fws, u8 *ea)\n{\n\tstruct brcmf_fws_mac_descriptor *entry;\n\tint i;\n\n\tif (ea == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tentry = &fws->desc.nodes[0];\n\tfor (i = 0; i < ARRAY_SIZE(fws->desc.nodes); i++) {\n\t\tif (entry->occupied && !memcmp(entry->ea, ea, ETH_ALEN))\n\t\t\treturn entry;\n\t\tentry++;\n\t}\n\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic struct brcmf_fws_mac_descriptor*\nbrcmf_fws_macdesc_find(struct brcmf_fws_info *fws, struct brcmf_if *ifp, u8 *da)\n{\n\tstruct brcmf_fws_mac_descriptor *entry;\n\tbool multicast;\n\n\tmulticast = is_multicast_ether_addr(da);\n\n\t \n\tif (multicast && ifp->fws_desc) {\n\t\tentry = ifp->fws_desc;\n\t\tgoto done;\n\t}\n\n\tentry = brcmf_fws_macdesc_lookup(fws, da);\n\tif (IS_ERR(entry))\n\t\tentry = ifp->fws_desc;\n\ndone:\n\treturn entry;\n}\n\nstatic bool brcmf_fws_macdesc_closed(struct brcmf_fws_info *fws,\n\t\t\t\t     struct brcmf_fws_mac_descriptor *entry,\n\t\t\t\t     int fifo)\n{\n\tstruct brcmf_fws_mac_descriptor *if_entry;\n\tbool closed;\n\n\t \n\tif (entry->mac_handle) {\n\t\tif_entry = &fws->desc.iface[entry->interface_id];\n\t\tif (if_entry->state == BRCMF_FWS_STATE_CLOSE)\n\t\t\treturn true;\n\t}\n\t \n\tclosed = entry->state == BRCMF_FWS_STATE_CLOSE &&\n\t\t !entry->requested_credit && !entry->requested_packet;\n\n\t \n\treturn closed || !(entry->ac_bitmap & BIT(fifo));\n}\n\nstatic void brcmf_fws_macdesc_cleanup(struct brcmf_fws_info *fws,\n\t\t\t\t      struct brcmf_fws_mac_descriptor *entry,\n\t\t\t\t      int ifidx)\n{\n\tif (entry->occupied && (ifidx == -1 || ifidx == entry->interface_id)) {\n\t\tbrcmf_fws_psq_flush(fws, &entry->psq, ifidx);\n\t\tentry->occupied = !!(entry->psq.len);\n\t}\n}\n\nstatic void brcmf_fws_bus_txq_cleanup(struct brcmf_fws_info *fws,\n\t\t\t\t      bool (*fn)(struct sk_buff *, void *),\n\t\t\t\t      int ifidx)\n{\n\tstruct brcmf_fws_hanger_item *hi;\n\tstruct pktq *txq;\n\tstruct sk_buff *skb;\n\tint prec;\n\tu32 hslot;\n\n\ttxq = brcmf_bus_gettxq(fws->drvr->bus_if);\n\tif (IS_ERR(txq)) {\n\t\tbrcmf_dbg(TRACE, \"no txq to clean up\\n\");\n\t\treturn;\n\t}\n\n\tfor (prec = 0; prec < txq->num_prec; prec++) {\n\t\tskb = brcmu_pktq_pdeq_match(txq, prec, fn, &ifidx);\n\t\twhile (skb) {\n\t\t\thslot = brcmf_skb_htod_tag_get_field(skb, HSLOT);\n\t\t\thi = &fws->hanger.items[hslot];\n\t\t\tWARN_ON(skb != hi->pkt);\n\t\t\thi->state = BRCMF_FWS_HANGER_ITEM_STATE_FREE;\n\t\t\tbrcmu_pkt_buf_free_skb(skb);\n\t\t\tskb = brcmu_pktq_pdeq_match(txq, prec, fn, &ifidx);\n\t\t}\n\t}\n}\n\nstatic void brcmf_fws_cleanup(struct brcmf_fws_info *fws, int ifidx)\n{\n\tint i;\n\tstruct brcmf_fws_mac_descriptor *table;\n\tbool (*matchfn)(struct sk_buff *, void *) = NULL;\n\n\tif (fws == NULL)\n\t\treturn;\n\n\tif (ifidx != -1)\n\t\tmatchfn = brcmf_fws_ifidx_match;\n\n\t \n\ttable = &fws->desc.nodes[0];\n\tfor (i = 0; i < ARRAY_SIZE(fws->desc.nodes); i++)\n\t\tbrcmf_fws_macdesc_cleanup(fws, &table[i], ifidx);\n\n\tbrcmf_fws_macdesc_cleanup(fws, &fws->desc.other, ifidx);\n\tbrcmf_fws_bus_txq_cleanup(fws, matchfn, ifidx);\n\tbrcmf_fws_hanger_cleanup(fws, matchfn, ifidx);\n}\n\nstatic u8 brcmf_fws_hdrpush(struct brcmf_fws_info *fws, struct sk_buff *skb)\n{\n\tstruct brcmf_fws_mac_descriptor *entry = brcmf_skbcb(skb)->mac;\n\tu8 *wlh;\n\tu16 data_offset = 0;\n\tu8 fillers;\n\t__le32 pkttag = cpu_to_le32(brcmf_skbcb(skb)->htod);\n\t__le16 pktseq = cpu_to_le16(brcmf_skbcb(skb)->htod_seq);\n\n\tbrcmf_dbg(TRACE, \"enter: %s, idx=%d hslot=%d htod %X seq %X\\n\",\n\t\t  entry->name, brcmf_skb_if_flags_get_field(skb, INDEX),\n\t\t  (le32_to_cpu(pkttag) >> 8) & 0xffff,\n\t\t  brcmf_skbcb(skb)->htod, brcmf_skbcb(skb)->htod_seq);\n\tif (entry->send_tim_signal)\n\t\tdata_offset += 2 + BRCMF_FWS_TYPE_PENDING_TRAFFIC_BMP_LEN;\n\tif (BRCMF_FWS_MODE_GET_REUSESEQ(fws->mode))\n\t\tdata_offset += BRCMF_FWS_TYPE_SEQ_LEN;\n\t \n\tdata_offset += 2 + BRCMF_FWS_TYPE_PKTTAG_LEN;\n\tfillers = round_up(data_offset, 4) - data_offset;\n\tdata_offset += fillers;\n\n\tskb_push(skb, data_offset);\n\twlh = skb->data;\n\n\twlh[0] = BRCMF_FWS_TYPE_PKTTAG;\n\twlh[1] = BRCMF_FWS_TYPE_PKTTAG_LEN;\n\tmemcpy(&wlh[2], &pkttag, sizeof(pkttag));\n\tif (BRCMF_FWS_MODE_GET_REUSESEQ(fws->mode)) {\n\t\twlh[1] += BRCMF_FWS_TYPE_SEQ_LEN;\n\t\tmemcpy(&wlh[2 + BRCMF_FWS_TYPE_PKTTAG_LEN], &pktseq,\n\t\t       sizeof(pktseq));\n\t}\n\twlh += wlh[1] + 2;\n\n\tif (entry->send_tim_signal) {\n\t\tentry->send_tim_signal = false;\n\t\twlh[0] = BRCMF_FWS_TYPE_PENDING_TRAFFIC_BMP;\n\t\twlh[1] = BRCMF_FWS_TYPE_PENDING_TRAFFIC_BMP_LEN;\n\t\twlh[2] = entry->mac_handle;\n\t\twlh[3] = entry->traffic_pending_bmp;\n\t\tbrcmf_dbg(TRACE, \"adding TIM info: handle %d bmp 0x%X\\n\",\n\t\t\t  entry->mac_handle, entry->traffic_pending_bmp);\n\t\twlh += BRCMF_FWS_TYPE_PENDING_TRAFFIC_BMP_LEN + 2;\n\t\tentry->traffic_lastreported_bmp = entry->traffic_pending_bmp;\n\t}\n\tif (fillers)\n\t\tmemset(wlh, BRCMF_FWS_TYPE_FILLER, fillers);\n\n\treturn (u8)(data_offset >> 2);\n}\n\nstatic bool brcmf_fws_tim_update(struct brcmf_fws_info *fws,\n\t\t\t\t struct brcmf_fws_mac_descriptor *entry,\n\t\t\t\t int fifo, bool send_immediately)\n{\n\tstruct sk_buff *skb;\n\tstruct brcmf_skbuff_cb *skcb;\n\ts32 err;\n\tu32 len;\n\tu8 data_offset;\n\tint ifidx;\n\n\t \n\tif (brcmu_pktq_mlen(&entry->psq, 3 << (fifo * 2)) == 0)\n\t\tentry->traffic_pending_bmp &= ~NBITVAL(fifo);\n\telse\n\t\tentry->traffic_pending_bmp |= NBITVAL(fifo);\n\n\tentry->send_tim_signal = false;\n\tif (entry->traffic_lastreported_bmp != entry->traffic_pending_bmp)\n\t\tentry->send_tim_signal = true;\n\tif (send_immediately && entry->send_tim_signal &&\n\t    entry->state == BRCMF_FWS_STATE_CLOSE) {\n\t\t \n\t\t \n\t\tlen = BRCMF_FWS_TYPE_PKTTAG_LEN + 2 +\n\t\t      BRCMF_FWS_TYPE_SEQ_LEN +\n\t\t      BRCMF_FWS_TYPE_PENDING_TRAFFIC_BMP_LEN + 2 +\n\t\t      4 + fws->drvr->hdrlen;\n\t\tskb = brcmu_pkt_buf_get_skb(len);\n\t\tif (skb == NULL)\n\t\t\treturn false;\n\t\tskb_pull(skb, len);\n\t\tskcb = brcmf_skbcb(skb);\n\t\tskcb->mac = entry;\n\t\tskcb->state = BRCMF_FWS_SKBSTATE_TIM;\n\t\tskcb->htod = 0;\n\t\tskcb->htod_seq = 0;\n\t\tdata_offset = brcmf_fws_hdrpush(fws, skb);\n\t\tifidx = brcmf_skb_if_flags_get_field(skb, INDEX);\n\t\tbrcmf_fws_unlock(fws);\n\t\terr = brcmf_proto_txdata(fws->drvr, ifidx, data_offset, skb);\n\t\tbrcmf_fws_lock(fws);\n\t\tif (err)\n\t\t\tbrcmu_pkt_buf_free_skb(skb);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void\nbrcmf_fws_flow_control_check(struct brcmf_fws_info *fws, struct pktq *pq,\n\t\t\t     u8 if_id)\n{\n\tstruct brcmf_if *ifp = brcmf_get_ifp(fws->drvr, if_id);\n\n\tif (WARN_ON(!ifp))\n\t\treturn;\n\n\tif ((ifp->netif_stop & BRCMF_NETIF_STOP_REASON_FWS_FC) &&\n\t    pq->len <= BRCMF_FWS_FLOWCONTROL_LOWATER)\n\t\tbrcmf_txflowblock_if(ifp,\n\t\t\t\t     BRCMF_NETIF_STOP_REASON_FWS_FC, false);\n\tif (!(ifp->netif_stop & BRCMF_NETIF_STOP_REASON_FWS_FC) &&\n\t    pq->len >= BRCMF_FWS_FLOWCONTROL_HIWATER) {\n\t\tfws->stats.fws_flow_block++;\n\t\tbrcmf_txflowblock_if(ifp, BRCMF_NETIF_STOP_REASON_FWS_FC, true);\n\t}\n\treturn;\n}\n\nstatic int brcmf_fws_rssi_indicate(struct brcmf_fws_info *fws, s8 rssi)\n{\n\tbrcmf_dbg(CTL, \"rssi %d\\n\", rssi);\n\treturn 0;\n}\n\nstatic\nint brcmf_fws_macdesc_indicate(struct brcmf_fws_info *fws, u8 type, u8 *data)\n{\n\tstruct brcmf_fws_mac_descriptor *entry, *existing;\n\tu8 mac_handle;\n\tu8 ifidx;\n\tu8 *addr;\n\n\tmac_handle = *data++;\n\tifidx = *data++;\n\taddr = data;\n\n\tentry = &fws->desc.nodes[mac_handle & 0x1F];\n\tif (type == BRCMF_FWS_TYPE_MACDESC_DEL) {\n\t\tif (entry->occupied) {\n\t\t\tbrcmf_dbg(TRACE, \"deleting %s mac %pM\\n\",\n\t\t\t\t  entry->name, addr);\n\t\t\tbrcmf_fws_lock(fws);\n\t\t\tbrcmf_fws_macdesc_cleanup(fws, entry, -1);\n\t\t\tbrcmf_fws_macdesc_deinit(entry);\n\t\t\tbrcmf_fws_unlock(fws);\n\t\t} else\n\t\t\tfws->stats.mac_update_failed++;\n\t\treturn 0;\n\t}\n\n\texisting = brcmf_fws_macdesc_lookup(fws, addr);\n\tif (IS_ERR(existing)) {\n\t\tif (!entry->occupied) {\n\t\t\tbrcmf_fws_lock(fws);\n\t\t\tentry->mac_handle = mac_handle;\n\t\t\tbrcmf_fws_macdesc_init(entry, addr, ifidx);\n\t\t\tbrcmf_fws_macdesc_set_name(fws, entry);\n\t\t\tbrcmu_pktq_init(&entry->psq, BRCMF_FWS_PSQ_PREC_COUNT,\n\t\t\t\t\tBRCMF_FWS_PSQ_LEN);\n\t\t\tbrcmf_fws_unlock(fws);\n\t\t\tbrcmf_dbg(TRACE, \"add %s mac %pM\\n\", entry->name, addr);\n\t\t} else {\n\t\t\tfws->stats.mac_update_failed++;\n\t\t}\n\t} else {\n\t\tif (entry != existing) {\n\t\t\tbrcmf_dbg(TRACE, \"copy mac %s\\n\", existing->name);\n\t\t\tbrcmf_fws_lock(fws);\n\t\t\tmemcpy(entry, existing,\n\t\t\t       offsetof(struct brcmf_fws_mac_descriptor, psq));\n\t\t\tentry->mac_handle = mac_handle;\n\t\t\tbrcmf_fws_macdesc_deinit(existing);\n\t\t\tbrcmf_fws_macdesc_set_name(fws, entry);\n\t\t\tbrcmf_fws_unlock(fws);\n\t\t\tbrcmf_dbg(TRACE, \"relocate %s mac %pM\\n\", entry->name,\n\t\t\t\t  addr);\n\t\t} else {\n\t\t\tbrcmf_dbg(TRACE, \"use existing\\n\");\n\t\t\tWARN_ON(entry->mac_handle != mac_handle);\n\t\t\t \n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int brcmf_fws_macdesc_state_indicate(struct brcmf_fws_info *fws,\n\t\t\t\t\t    u8 type, u8 *data)\n{\n\tstruct brcmf_fws_mac_descriptor *entry;\n\tu8 mac_handle;\n\tint ret;\n\n\tmac_handle = data[0];\n\tentry = &fws->desc.nodes[mac_handle & 0x1F];\n\tif (!entry->occupied) {\n\t\tfws->stats.mac_ps_update_failed++;\n\t\treturn -ESRCH;\n\t}\n\tbrcmf_fws_lock(fws);\n\t \n\tentry->requested_credit = 0;\n\tentry->requested_packet = 0;\n\tif (type == BRCMF_FWS_TYPE_MAC_OPEN) {\n\t\tentry->state = BRCMF_FWS_STATE_OPEN;\n\t\tret = BRCMF_FWS_RET_OK_SCHEDULE;\n\t} else {\n\t\tentry->state = BRCMF_FWS_STATE_CLOSE;\n\t\tbrcmf_fws_tim_update(fws, entry, BRCMF_FWS_FIFO_AC_BK, false);\n\t\tbrcmf_fws_tim_update(fws, entry, BRCMF_FWS_FIFO_AC_BE, false);\n\t\tbrcmf_fws_tim_update(fws, entry, BRCMF_FWS_FIFO_AC_VI, false);\n\t\tbrcmf_fws_tim_update(fws, entry, BRCMF_FWS_FIFO_AC_VO, true);\n\t\tret = BRCMF_FWS_RET_OK_NOSCHEDULE;\n\t}\n\tbrcmf_fws_unlock(fws);\n\treturn ret;\n}\n\nstatic int brcmf_fws_interface_state_indicate(struct brcmf_fws_info *fws,\n\t\t\t\t\t      u8 type, u8 *data)\n{\n\tstruct brcmf_fws_mac_descriptor *entry;\n\tu8 ifidx;\n\tint ret;\n\n\tifidx = data[0];\n\n\tif (ifidx >= BRCMF_MAX_IFS) {\n\t\tret = -ERANGE;\n\t\tgoto fail;\n\t}\n\n\tentry = &fws->desc.iface[ifidx];\n\tif (!entry->occupied) {\n\t\tret = -ESRCH;\n\t\tgoto fail;\n\t}\n\n\tbrcmf_dbg(TRACE, \"%s (%d): %s\\n\", brcmf_fws_get_tlv_name(type), type,\n\t\t  entry->name);\n\tbrcmf_fws_lock(fws);\n\tswitch (type) {\n\tcase BRCMF_FWS_TYPE_INTERFACE_OPEN:\n\t\tentry->state = BRCMF_FWS_STATE_OPEN;\n\t\tret = BRCMF_FWS_RET_OK_SCHEDULE;\n\t\tbreak;\n\tcase BRCMF_FWS_TYPE_INTERFACE_CLOSE:\n\t\tentry->state = BRCMF_FWS_STATE_CLOSE;\n\t\tret = BRCMF_FWS_RET_OK_NOSCHEDULE;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbrcmf_fws_unlock(fws);\n\t\tgoto fail;\n\t}\n\tbrcmf_fws_unlock(fws);\n\treturn ret;\n\nfail:\n\tfws->stats.if_update_failed++;\n\treturn ret;\n}\n\nstatic int brcmf_fws_request_indicate(struct brcmf_fws_info *fws, u8 type,\n\t\t\t\t      u8 *data)\n{\n\tstruct brcmf_fws_mac_descriptor *entry;\n\n\tentry = &fws->desc.nodes[data[1] & 0x1F];\n\tif (!entry->occupied) {\n\t\tif (type == BRCMF_FWS_TYPE_MAC_REQUEST_CREDIT)\n\t\t\tfws->stats.credit_request_failed++;\n\t\telse\n\t\t\tfws->stats.packet_request_failed++;\n\t\treturn -ESRCH;\n\t}\n\n\tbrcmf_dbg(TRACE, \"%s (%d): %s cnt %d bmp %d\\n\",\n\t\t  brcmf_fws_get_tlv_name(type), type, entry->name,\n\t\t  data[0], data[2]);\n\tbrcmf_fws_lock(fws);\n\tif (type == BRCMF_FWS_TYPE_MAC_REQUEST_CREDIT)\n\t\tentry->requested_credit = data[0];\n\telse\n\t\tentry->requested_packet = data[0];\n\n\tentry->ac_bitmap = data[2];\n\tbrcmf_fws_unlock(fws);\n\treturn BRCMF_FWS_RET_OK_SCHEDULE;\n}\n\nstatic void\nbrcmf_fws_macdesc_use_req_credit(struct brcmf_fws_mac_descriptor *entry,\n\t\t\t\t struct sk_buff *skb)\n{\n\tif (entry->requested_credit > 0) {\n\t\tentry->requested_credit--;\n\t\tbrcmf_skb_if_flags_set_field(skb, REQUESTED, 1);\n\t\tbrcmf_skb_if_flags_set_field(skb, REQ_CREDIT, 1);\n\t\tif (entry->state != BRCMF_FWS_STATE_CLOSE)\n\t\t\tbrcmf_err(\"requested credit set while mac not closed!\\n\");\n\t} else if (entry->requested_packet > 0) {\n\t\tentry->requested_packet--;\n\t\tbrcmf_skb_if_flags_set_field(skb, REQUESTED, 1);\n\t\tbrcmf_skb_if_flags_set_field(skb, REQ_CREDIT, 0);\n\t\tif (entry->state != BRCMF_FWS_STATE_CLOSE)\n\t\t\tbrcmf_err(\"requested packet set while mac not closed!\\n\");\n\t} else {\n\t\tbrcmf_skb_if_flags_set_field(skb, REQUESTED, 0);\n\t\tbrcmf_skb_if_flags_set_field(skb, REQ_CREDIT, 0);\n\t}\n}\n\nstatic void brcmf_fws_macdesc_return_req_credit(struct sk_buff *skb)\n{\n\tstruct brcmf_fws_mac_descriptor *entry = brcmf_skbcb(skb)->mac;\n\n\tif ((brcmf_skb_if_flags_get_field(skb, REQ_CREDIT)) &&\n\t    (entry->state == BRCMF_FWS_STATE_CLOSE))\n\t\tentry->requested_credit++;\n}\n\nstatic void brcmf_fws_return_credits(struct brcmf_fws_info *fws,\n\t\t\t\t     u8 fifo, u8 credits)\n{\n\tint lender_ac;\n\tint *borrowed;\n\tint *fifo_credit;\n\n\tif (!credits)\n\t\treturn;\n\n\tfws->fifo_credit_map |= 1 << fifo;\n\n\tif (fifo > BRCMF_FWS_FIFO_AC_BK &&\n\t    fifo <= BRCMF_FWS_FIFO_AC_VO) {\n\t\tfor (lender_ac = BRCMF_FWS_FIFO_AC_VO; lender_ac >= 0;\n\t\t     lender_ac--) {\n\t\t\tborrowed = &fws->credits_borrowed[fifo][lender_ac];\n\t\t\tif (*borrowed) {\n\t\t\t\tfws->fifo_credit_map |= (1 << lender_ac);\n\t\t\t\tfifo_credit = &fws->fifo_credit[lender_ac];\n\t\t\t\tif (*borrowed >= credits) {\n\t\t\t\t\t*borrowed -= credits;\n\t\t\t\t\t*fifo_credit += credits;\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tcredits -= *borrowed;\n\t\t\t\t\t*fifo_credit += *borrowed;\n\t\t\t\t\t*borrowed = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (credits) {\n\t\tfws->fifo_credit[fifo] += credits;\n\t}\n\n\tif (fws->fifo_credit[fifo] > fws->init_fifo_credit[fifo])\n\t\tfws->fifo_credit[fifo] = fws->init_fifo_credit[fifo];\n\n}\n\nstatic void brcmf_fws_schedule_deq(struct brcmf_fws_info *fws)\n{\n\t \n\tif ((fws->fifo_credit_map & fws->fifo_delay_map) ||\n\t    (!brcmf_fws_fc_active(fws) && fws->fifo_delay_map))\n\t\tqueue_work(fws->fws_wq, &fws->fws_dequeue_work);\n}\n\nstatic int brcmf_fws_enq(struct brcmf_fws_info *fws,\n\t\t\t enum brcmf_fws_skb_state state, int fifo,\n\t\t\t struct sk_buff *p)\n{\n\tstruct brcmf_pub *drvr = fws->drvr;\n\tint prec = 2 * fifo;\n\tu32 *qfull_stat = &fws->stats.delayq_full_error;\n\tstruct brcmf_fws_mac_descriptor *entry;\n\tstruct pktq *pq;\n\tstruct sk_buff_head *queue;\n\tstruct sk_buff *p_head;\n\tstruct sk_buff *p_tail;\n\tu32 fr_new;\n\tu32 fr_compare;\n\n\tentry = brcmf_skbcb(p)->mac;\n\tif (entry == NULL) {\n\t\tbphy_err(drvr, \"no mac descriptor found for skb %p\\n\", p);\n\t\treturn -ENOENT;\n\t}\n\n\tbrcmf_dbg(DATA, \"enter: fifo %d skb %p\\n\", fifo, p);\n\tif (state == BRCMF_FWS_SKBSTATE_SUPPRESSED) {\n\t\tprec += 1;\n\t\tqfull_stat = &fws->stats.supprq_full_error;\n\n\t\t \n\t\t \n\t\tpq = &entry->psq;\n\t\tif (pktq_full(pq) || pktq_pfull(pq, prec)) {\n\t\t\t*qfull_stat += 1;\n\t\t\treturn -ENFILE;\n\t\t}\n\t\tqueue = &pq->q[prec].skblist;\n\n\t\tp_head = skb_peek(queue);\n\t\tp_tail = skb_peek_tail(queue);\n\t\tfr_new = brcmf_skb_htod_tag_get_field(p, FREERUN);\n\n\t\twhile (p_head != p_tail) {\n\t\t\tfr_compare = brcmf_skb_htod_tag_get_field(p_tail,\n\t\t\t\t\t\t\t\t  FREERUN);\n\t\t\t \n\t\t\tif (((fr_new > fr_compare) &&\n\t\t\t     ((fr_new - fr_compare) < 128)) ||\n\t\t\t    ((fr_new < fr_compare) &&\n\t\t\t     ((fr_compare - fr_new) > 128)))\n\t\t\t\tbreak;\n\t\t\tp_tail = skb_queue_prev(queue, p_tail);\n\t\t}\n\t\t \n\t\tif (p_tail == NULL) {\n\t\t\t \n\t\t\t__skb_queue_tail(queue, p);\n\t\t} else {\n\t\t\tfr_compare = brcmf_skb_htod_tag_get_field(p_tail,\n\t\t\t\t\t\t\t\t  FREERUN);\n\t\t\tif (((fr_new > fr_compare) &&\n\t\t\t     ((fr_new - fr_compare) < 128)) ||\n\t\t\t    ((fr_new < fr_compare) &&\n\t\t\t     ((fr_compare - fr_new) > 128))) {\n\t\t\t\t \n\t\t\t\t__skb_queue_after(queue, p_tail, p);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\t__skb_insert(p, p_tail->prev, p_tail, queue);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tpq->len++;\n\t\tif (pq->hi_prec < prec)\n\t\t\tpq->hi_prec = (u8) prec;\n\t} else if (brcmu_pktq_penq(&entry->psq, prec, p) == NULL) {\n\t\t*qfull_stat += 1;\n\t\treturn -ENFILE;\n\t}\n\n\t \n\tfws->fifo_delay_map |= 1 << fifo;\n\tfws->fifo_enqpkt[fifo]++;\n\n\t \n\tbrcmf_skbcb(p)->state = state;\n\n\t \n\tbrcmf_fws_tim_update(fws, entry, fifo, true);\n\tbrcmf_fws_flow_control_check(fws, &entry->psq,\n\t\t\t\t     brcmf_skb_if_flags_get_field(p, INDEX));\n\treturn 0;\n}\n\nstatic struct sk_buff *brcmf_fws_deq(struct brcmf_fws_info *fws, int fifo)\n{\n\tstruct brcmf_fws_mac_descriptor *table;\n\tstruct brcmf_fws_mac_descriptor *entry;\n\tstruct sk_buff *p;\n\tint num_nodes;\n\tint node_pos;\n\tint prec_out;\n\tint pmsk;\n\tint i;\n\n\ttable = (struct brcmf_fws_mac_descriptor *)&fws->desc;\n\tnum_nodes = sizeof(fws->desc) / sizeof(struct brcmf_fws_mac_descriptor);\n\tnode_pos = fws->deq_node_pos[fifo];\n\n\tfor (i = 0; i < num_nodes; i++) {\n\t\tentry = &table[(node_pos + i) % num_nodes];\n\t\tif (!entry->occupied ||\n\t\t    brcmf_fws_macdesc_closed(fws, entry, fifo))\n\t\t\tcontinue;\n\n\t\tif (entry->suppressed)\n\t\t\tpmsk = 2;\n\t\telse\n\t\t\tpmsk = 3;\n\t\tp = brcmu_pktq_mdeq(&entry->psq, pmsk << (fifo * 2), &prec_out);\n\t\tif (p == NULL) {\n\t\t\tif (entry->suppressed) {\n\t\t\t\tif (entry->suppr_transit_count)\n\t\t\t\t\tcontinue;\n\t\t\t\tentry->suppressed = false;\n\t\t\t\tp = brcmu_pktq_mdeq(&entry->psq,\n\t\t\t\t\t\t    1 << (fifo * 2), &prec_out);\n\t\t\t}\n\t\t}\n\t\tif  (p == NULL)\n\t\t\tcontinue;\n\n\t\tbrcmf_fws_macdesc_use_req_credit(entry, p);\n\n\t\t \n\t\tfws->deq_node_pos[fifo] = (node_pos + i + 1) % num_nodes;\n\t\tbrcmf_fws_flow_control_check(fws, &entry->psq,\n\t\t\t\t\t     brcmf_skb_if_flags_get_field(p,\n\t\t\t\t\t\t\t\t\t  INDEX)\n\t\t\t\t\t     );\n\t\t \n\t\tbrcmf_fws_tim_update(fws, entry, fifo, false);\n\n\t\t \n\t\tfws->fifo_enqpkt[fifo]--;\n\t\tif (fws->fifo_enqpkt[fifo] == 0)\n\t\t\tfws->fifo_delay_map &= ~(1 << fifo);\n\t\tgoto done;\n\t}\n\tp = NULL;\ndone:\n\tbrcmf_dbg(DATA, \"exit: fifo %d skb %p\\n\", fifo, p);\n\treturn p;\n}\n\nstatic int brcmf_fws_txstatus_suppressed(struct brcmf_fws_info *fws, int fifo,\n\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t u32 genbit, u16 seq)\n{\n\tstruct brcmf_fws_mac_descriptor *entry = brcmf_skbcb(skb)->mac;\n\tu32 hslot;\n\tint ret;\n\n\thslot = brcmf_skb_htod_tag_get_field(skb, HSLOT);\n\n\t \n\tif (!entry->suppressed) {\n\t\tentry->suppressed = true;\n\t\tentry->suppr_transit_count = entry->transit_count;\n\t\tbrcmf_dbg(DATA, \"suppress %s: transit %d\\n\",\n\t\t\t  entry->name, entry->transit_count);\n\t}\n\n\tentry->generation = genbit;\n\n\tbrcmf_skb_htod_tag_set_field(skb, GENERATION, genbit);\n\tbrcmf_skbcb(skb)->htod_seq = seq;\n\tif (brcmf_skb_htod_seq_get_field(skb, FROMFW)) {\n\t\tbrcmf_skb_htod_seq_set_field(skb, FROMDRV, 1);\n\t\tbrcmf_skb_htod_seq_set_field(skb, FROMFW, 0);\n\t} else {\n\t\tbrcmf_skb_htod_seq_set_field(skb, FROMDRV, 0);\n\t}\n\tret = brcmf_fws_enq(fws, BRCMF_FWS_SKBSTATE_SUPPRESSED, fifo, skb);\n\n\tif (ret != 0) {\n\t\t \n\t\tbrcmf_fws_hanger_poppkt(&fws->hanger, hslot, &skb, true);\n\t} else {\n\t\t \n\t\tbrcmf_fws_hanger_mark_suppressed(&fws->hanger, hslot);\n\t}\n\n\treturn ret;\n}\n\nstatic int\nbrcmf_fws_txs_process(struct brcmf_fws_info *fws, u8 flags, u32 hslot,\n\t\t      u32 genbit, u16 seq, u8 compcnt)\n{\n\tstruct brcmf_pub *drvr = fws->drvr;\n\tu32 fifo;\n\tu8 cnt = 0;\n\tint ret;\n\tbool remove_from_hanger = true;\n\tstruct sk_buff *skb;\n\tstruct brcmf_skbuff_cb *skcb;\n\tstruct brcmf_fws_mac_descriptor *entry = NULL;\n\tstruct brcmf_if *ifp;\n\n\tbrcmf_dbg(DATA, \"flags %d\\n\", flags);\n\n\tif (flags == BRCMF_FWS_TXSTATUS_DISCARD)\n\t\tfws->stats.txs_discard += compcnt;\n\telse if (flags == BRCMF_FWS_TXSTATUS_CORE_SUPPRESS) {\n\t\tfws->stats.txs_supp_core += compcnt;\n\t\tremove_from_hanger = false;\n\t} else if (flags == BRCMF_FWS_TXSTATUS_FW_PS_SUPPRESS) {\n\t\tfws->stats.txs_supp_ps += compcnt;\n\t\tremove_from_hanger = false;\n\t} else if (flags == BRCMF_FWS_TXSTATUS_FW_TOSSED)\n\t\tfws->stats.txs_tossed += compcnt;\n\telse if (flags == BRCMF_FWS_TXSTATUS_FW_DISCARD_NOACK)\n\t\tfws->stats.txs_discard += compcnt;\n\telse if (flags == BRCMF_FWS_TXSTATUS_FW_SUPPRESS_ACKED)\n\t\tfws->stats.txs_discard += compcnt;\n\telse if (flags == BRCMF_FWS_TXSTATUS_HOST_TOSSED)\n\t\tfws->stats.txs_host_tossed += compcnt;\n\telse\n\t\tbphy_err(drvr, \"unexpected txstatus\\n\");\n\n\twhile (cnt < compcnt) {\n\t\tret = brcmf_fws_hanger_poppkt(&fws->hanger, hslot, &skb,\n\t\t\t\t\t      remove_from_hanger);\n\t\tif (ret != 0) {\n\t\t\tbphy_err(drvr, \"no packet in hanger slot: hslot=%d\\n\",\n\t\t\t\t hslot);\n\t\t\tgoto cont;\n\t\t}\n\n\t\tskcb = brcmf_skbcb(skb);\n\t\tentry = skcb->mac;\n\t\tif (WARN_ON(!entry)) {\n\t\t\tbrcmu_pkt_buf_free_skb(skb);\n\t\t\tgoto cont;\n\t\t}\n\t\tentry->transit_count--;\n\t\tif (entry->suppressed && entry->suppr_transit_count)\n\t\t\tentry->suppr_transit_count--;\n\n\t\tbrcmf_dbg(DATA, \"%s flags %d htod %X seq %X\\n\", entry->name,\n\t\t\t  flags, skcb->htod, seq);\n\n\t\t \n\t\tfifo = brcmf_skb_htod_tag_get_field(skb, FIFO);\n\t\tif (fws->fcmode == BRCMF_FWS_FCMODE_IMPLIED_CREDIT ||\n\t\t    (brcmf_skb_if_flags_get_field(skb, REQ_CREDIT)) ||\n\t\t    flags == BRCMF_FWS_TXSTATUS_HOST_TOSSED) {\n\t\t\tbrcmf_fws_return_credits(fws, fifo, 1);\n\t\t\tbrcmf_fws_schedule_deq(fws);\n\t\t}\n\t\tbrcmf_fws_macdesc_return_req_credit(skb);\n\n\t\tret = brcmf_proto_hdrpull(fws->drvr, false, skb, &ifp);\n\t\tif (ret) {\n\t\t\tbrcmu_pkt_buf_free_skb(skb);\n\t\t\tgoto cont;\n\t\t}\n\t\tif (!remove_from_hanger)\n\t\t\tret = brcmf_fws_txstatus_suppressed(fws, fifo, skb,\n\t\t\t\t\t\t\t    genbit, seq);\n\t\tif (remove_from_hanger || ret)\n\t\t\tbrcmf_txfinalize(ifp, skb, true);\n\ncont:\n\t\thslot = (hslot + 1) & (BRCMF_FWS_TXSTAT_HSLOT_MASK >>\n\t\t\t\t       BRCMF_FWS_TXSTAT_HSLOT_SHIFT);\n\t\tif (BRCMF_FWS_MODE_GET_REUSESEQ(fws->mode))\n\t\t\tseq = (seq + 1) & BRCMF_SKB_HTOD_SEQ_NR_MASK;\n\n\t\tcnt++;\n\t}\n\n\treturn 0;\n}\n\nstatic int brcmf_fws_fifocreditback_indicate(struct brcmf_fws_info *fws,\n\t\t\t\t\t     u8 *data)\n{\n\tint i;\n\n\tif (fws->fcmode != BRCMF_FWS_FCMODE_EXPLICIT_CREDIT) {\n\t\tbrcmf_dbg(INFO, \"ignored\\n\");\n\t\treturn BRCMF_FWS_RET_OK_NOSCHEDULE;\n\t}\n\n\tbrcmf_dbg(DATA, \"enter: data %pM\\n\", data);\n\tbrcmf_fws_lock(fws);\n\tfor (i = 0; i < BRCMF_FWS_FIFO_COUNT; i++)\n\t\tbrcmf_fws_return_credits(fws, i, data[i]);\n\n\tbrcmf_dbg(DATA, \"map: credit %x delay %x\\n\", fws->fifo_credit_map,\n\t\t  fws->fifo_delay_map);\n\tbrcmf_fws_unlock(fws);\n\treturn BRCMF_FWS_RET_OK_SCHEDULE;\n}\n\nstatic int brcmf_fws_txstatus_indicate(struct brcmf_fws_info *fws, u8 type,\n\t\t\t\t       u8 *data)\n{\n\t__le32 status_le;\n\t__le16 seq_le;\n\tu32 status;\n\tu32 hslot;\n\tu32 genbit;\n\tu8 flags;\n\tu16 seq;\n\tu8 compcnt;\n\tu8 compcnt_offset = BRCMF_FWS_TYPE_TXSTATUS_LEN;\n\n\tmemcpy(&status_le, data, sizeof(status_le));\n\tstatus = le32_to_cpu(status_le);\n\tflags = brcmf_txstatus_get_field(status, FLAGS);\n\thslot = brcmf_txstatus_get_field(status, HSLOT);\n\tgenbit = brcmf_txstatus_get_field(status, GENERATION);\n\tif (BRCMF_FWS_MODE_GET_REUSESEQ(fws->mode)) {\n\t\tmemcpy(&seq_le, &data[BRCMF_FWS_TYPE_TXSTATUS_LEN],\n\t\t       sizeof(seq_le));\n\t\tseq = le16_to_cpu(seq_le);\n\t\tcompcnt_offset += BRCMF_FWS_TYPE_SEQ_LEN;\n\t} else {\n\t\tseq = 0;\n\t}\n\n\tif (type == BRCMF_FWS_TYPE_COMP_TXSTATUS)\n\t\tcompcnt = data[compcnt_offset];\n\telse\n\t\tcompcnt = 1;\n\tfws->stats.txs_indicate += compcnt;\n\n\tbrcmf_fws_lock(fws);\n\tbrcmf_fws_txs_process(fws, flags, hslot, genbit, seq, compcnt);\n\tbrcmf_fws_unlock(fws);\n\treturn BRCMF_FWS_RET_OK_NOSCHEDULE;\n}\n\nstatic int brcmf_fws_dbg_seqnum_check(struct brcmf_fws_info *fws, u8 *data)\n{\n\t__le32 timestamp;\n\n\tmemcpy(&timestamp, &data[2], sizeof(timestamp));\n\tbrcmf_dbg(CTL, \"received: seq %d, timestamp %d\\n\", data[1],\n\t\t  le32_to_cpu(timestamp));\n\treturn 0;\n}\n\nstatic int brcmf_fws_notify_credit_map(struct brcmf_if *ifp,\n\t\t\t\t       const struct brcmf_event_msg *e,\n\t\t\t\t       void *data)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_fws_info *fws = drvr_to_fws(drvr);\n\tint i;\n\tu8 *credits = data;\n\n\tif (e->datalen < BRCMF_FWS_FIFO_COUNT) {\n\t\tbphy_err(drvr, \"event payload too small (%d)\\n\", e->datalen);\n\t\treturn -EINVAL;\n\t}\n\n\tfws->creditmap_received = true;\n\n\tbrcmf_dbg(TRACE, \"enter: credits %pM\\n\", credits);\n\tbrcmf_fws_lock(fws);\n\tfor (i = 0; i < ARRAY_SIZE(fws->fifo_credit); i++) {\n\t\tfws->fifo_credit[i] += credits[i] - fws->init_fifo_credit[i];\n\t\tfws->init_fifo_credit[i] = credits[i];\n\t\tif (fws->fifo_credit[i] > 0)\n\t\t\tfws->fifo_credit_map |= 1 << i;\n\t\telse\n\t\t\tfws->fifo_credit_map &= ~(1 << i);\n\t\tWARN_ONCE(fws->fifo_credit[i] < 0,\n\t\t\t  \"fifo_credit[%d] is negative(%d)\\n\", i,\n\t\t\t  fws->fifo_credit[i]);\n\t}\n\tbrcmf_fws_schedule_deq(fws);\n\tbrcmf_fws_unlock(fws);\n\treturn 0;\n}\n\nstatic int brcmf_fws_notify_bcmc_credit_support(struct brcmf_if *ifp,\n\t\t\t\t\t\tconst struct brcmf_event_msg *e,\n\t\t\t\t\t\tvoid *data)\n{\n\tstruct brcmf_fws_info *fws = drvr_to_fws(ifp->drvr);\n\n\tif (fws) {\n\t\tbrcmf_fws_lock(fws);\n\t\tfws->bcmc_credit_check = true;\n\t\tbrcmf_fws_unlock(fws);\n\t}\n\treturn 0;\n}\n\nstatic void brcmf_rxreorder_get_skb_list(struct brcmf_ampdu_rx_reorder *rfi,\n\t\t\t\t\t u8 start, u8 end,\n\t\t\t\t\t struct sk_buff_head *skb_list)\n{\n\t \n\t__skb_queue_head_init(skb_list);\n\n\tif (rfi->pend_pkts == 0) {\n\t\tbrcmf_dbg(INFO, \"no packets in reorder queue\\n\");\n\t\treturn;\n\t}\n\n\tdo {\n\t\tif (rfi->pktslots[start]) {\n\t\t\t__skb_queue_tail(skb_list, rfi->pktslots[start]);\n\t\t\trfi->pktslots[start] = NULL;\n\t\t}\n\t\tstart++;\n\t\tif (start > rfi->max_idx)\n\t\t\tstart = 0;\n\t} while (start != end);\n\trfi->pend_pkts -= skb_queue_len(skb_list);\n}\n\nvoid brcmf_fws_rxreorder(struct brcmf_if *ifp, struct sk_buff *pkt)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tu8 *reorder_data;\n\tu8 flow_id, max_idx, cur_idx, exp_idx, end_idx;\n\tstruct brcmf_ampdu_rx_reorder *rfi;\n\tstruct sk_buff_head reorder_list;\n\tstruct sk_buff *pnext;\n\tu8 flags;\n\tu32 buf_size;\n\n\treorder_data = ((struct brcmf_skb_reorder_data *)pkt->cb)->reorder;\n\tflow_id = reorder_data[BRCMF_RXREORDER_FLOWID_OFFSET];\n\tflags = reorder_data[BRCMF_RXREORDER_FLAGS_OFFSET];\n\n\t \n\tif (flags == 0xFF) {\n\t\tbphy_err(drvr, \"invalid flags...so ignore this packet\\n\");\n\t\tbrcmf_netif_rx(ifp, pkt);\n\t\treturn;\n\t}\n\n\trfi = ifp->drvr->reorder_flows[flow_id];\n\tif (flags & BRCMF_RXREORDER_DEL_FLOW) {\n\t\tbrcmf_dbg(INFO, \"flow-%d: delete\\n\",\n\t\t\t  flow_id);\n\n\t\tif (rfi == NULL) {\n\t\t\tbrcmf_dbg(INFO, \"received flags to cleanup, but no flow (%d) yet\\n\",\n\t\t\t\t  flow_id);\n\t\t\tbrcmf_netif_rx(ifp, pkt);\n\t\t\treturn;\n\t\t}\n\n\t\tbrcmf_rxreorder_get_skb_list(rfi, rfi->exp_idx, rfi->exp_idx,\n\t\t\t\t\t     &reorder_list);\n\t\t \n\t\t__skb_queue_tail(&reorder_list, pkt);\n\t\tkfree(rfi);\n\t\tifp->drvr->reorder_flows[flow_id] = NULL;\n\t\tgoto netif_rx;\n\t}\n\t \n\tif (rfi == NULL) {\n\t\tbuf_size = sizeof(*rfi);\n\t\tmax_idx = reorder_data[BRCMF_RXREORDER_MAXIDX_OFFSET];\n\n\t\tbuf_size += (max_idx + 1) * sizeof(pkt);\n\n\t\t \n\t\tbrcmf_dbg(INFO, \"flow-%d: start, maxidx %d\\n\",\n\t\t\t  flow_id, max_idx);\n\t\trfi = kzalloc(buf_size, GFP_ATOMIC);\n\t\tif (rfi == NULL) {\n\t\t\tbphy_err(drvr, \"failed to alloc buffer\\n\");\n\t\t\tbrcmf_netif_rx(ifp, pkt);\n\t\t\treturn;\n\t\t}\n\n\t\tifp->drvr->reorder_flows[flow_id] = rfi;\n\t\trfi->pktslots = (struct sk_buff **)(rfi + 1);\n\t\trfi->max_idx = max_idx;\n\t}\n\tif (flags & BRCMF_RXREORDER_NEW_HOLE)  {\n\t\tif (rfi->pend_pkts) {\n\t\t\tbrcmf_rxreorder_get_skb_list(rfi, rfi->exp_idx,\n\t\t\t\t\t\t     rfi->exp_idx,\n\t\t\t\t\t\t     &reorder_list);\n\t\t\tWARN_ON(rfi->pend_pkts);\n\t\t} else {\n\t\t\t__skb_queue_head_init(&reorder_list);\n\t\t}\n\t\trfi->cur_idx = reorder_data[BRCMF_RXREORDER_CURIDX_OFFSET];\n\t\trfi->exp_idx = reorder_data[BRCMF_RXREORDER_EXPIDX_OFFSET];\n\t\trfi->max_idx = reorder_data[BRCMF_RXREORDER_MAXIDX_OFFSET];\n\t\trfi->pktslots[rfi->cur_idx] = pkt;\n\t\trfi->pend_pkts++;\n\t\tbrcmf_dbg(DATA, \"flow-%d: new hole %d (%d), pending %d\\n\",\n\t\t\t  flow_id, rfi->cur_idx, rfi->exp_idx, rfi->pend_pkts);\n\t} else if (flags & BRCMF_RXREORDER_CURIDX_VALID) {\n\t\tcur_idx = reorder_data[BRCMF_RXREORDER_CURIDX_OFFSET];\n\t\texp_idx = reorder_data[BRCMF_RXREORDER_EXPIDX_OFFSET];\n\n\t\tif ((exp_idx == rfi->exp_idx) && (cur_idx != rfi->exp_idx)) {\n\t\t\t \n\t\t\t \n\t\t\tif (rfi->pktslots[cur_idx] != NULL) {\n\t\t\t\tbrcmf_dbg(INFO, \"HOLE: ERROR buffer pending..free it\\n\");\n\t\t\t\tbrcmu_pkt_buf_free_skb(rfi->pktslots[cur_idx]);\n\t\t\t\trfi->pktslots[cur_idx] = NULL;\n\t\t\t}\n\t\t\trfi->pktslots[cur_idx] = pkt;\n\t\t\trfi->pend_pkts++;\n\t\t\trfi->cur_idx = cur_idx;\n\t\t\tbrcmf_dbg(DATA, \"flow-%d: store pkt %d (%d), pending %d\\n\",\n\t\t\t\t  flow_id, cur_idx, exp_idx, rfi->pend_pkts);\n\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t\tif (rfi->exp_idx == cur_idx) {\n\t\t\tif (rfi->pktslots[cur_idx] != NULL) {\n\t\t\t\tbrcmf_dbg(INFO, \"error buffer pending..free it\\n\");\n\t\t\t\tbrcmu_pkt_buf_free_skb(rfi->pktslots[cur_idx]);\n\t\t\t\trfi->pktslots[cur_idx] = NULL;\n\t\t\t}\n\t\t\trfi->pktslots[cur_idx] = pkt;\n\t\t\trfi->pend_pkts++;\n\n\t\t\t \n\t\t\tbrcmf_dbg(DATA, \"flow-%d: expected %d (%d), pending %d\\n\",\n\t\t\t\t  flow_id, cur_idx, exp_idx, rfi->pend_pkts);\n\n\t\t\trfi->cur_idx = cur_idx;\n\t\t\trfi->exp_idx = exp_idx;\n\n\t\t\tbrcmf_rxreorder_get_skb_list(rfi, cur_idx, exp_idx,\n\t\t\t\t\t\t     &reorder_list);\n\t\t\tbrcmf_dbg(DATA, \"flow-%d: freeing buffers %d, pending %d\\n\",\n\t\t\t\t  flow_id, skb_queue_len(&reorder_list),\n\t\t\t\t  rfi->pend_pkts);\n\t\t} else {\n\t\t\tu8 end_idx;\n\n\t\t\tbrcmf_dbg(DATA, \"flow-%d (0x%x): both moved, old %d/%d, new %d/%d\\n\",\n\t\t\t\t  flow_id, flags, rfi->cur_idx, rfi->exp_idx,\n\t\t\t\t  cur_idx, exp_idx);\n\t\t\tif (flags & BRCMF_RXREORDER_FLUSH_ALL)\n\t\t\t\tend_idx = rfi->exp_idx;\n\t\t\telse\n\t\t\t\tend_idx = exp_idx;\n\n\t\t\t \n\t\t\tbrcmf_rxreorder_get_skb_list(rfi, rfi->exp_idx, end_idx,\n\t\t\t\t\t\t     &reorder_list);\n\n\t\t\tif (exp_idx == ((cur_idx + 1) % (rfi->max_idx + 1))) {\n\t\t\t\t__skb_queue_tail(&reorder_list, pkt);\n\t\t\t} else {\n\t\t\t\trfi->pktslots[cur_idx] = pkt;\n\t\t\t\trfi->pend_pkts++;\n\t\t\t}\n\t\t\trfi->exp_idx = exp_idx;\n\t\t\trfi->cur_idx = cur_idx;\n\t\t}\n\t} else {\n\t\t \n\t\texp_idx = reorder_data[BRCMF_RXREORDER_EXPIDX_OFFSET];\n\n\t\tbrcmf_dbg(DATA, \"flow-%d (0x%x): change expected: %d -> %d\\n\",\n\t\t\t  flow_id, flags, rfi->exp_idx, exp_idx);\n\t\tif (flags & BRCMF_RXREORDER_FLUSH_ALL)\n\t\t\tend_idx =  rfi->exp_idx;\n\t\telse\n\t\t\tend_idx =  exp_idx;\n\n\t\tbrcmf_rxreorder_get_skb_list(rfi, rfi->exp_idx, end_idx,\n\t\t\t\t\t     &reorder_list);\n\t\t__skb_queue_tail(&reorder_list, pkt);\n\t\t \n\t\trfi->exp_idx = exp_idx;\n\t}\nnetif_rx:\n\tskb_queue_walk_safe(&reorder_list, pkt, pnext) {\n\t\t__skb_unlink(pkt, &reorder_list);\n\t\tbrcmf_netif_rx(ifp, pkt);\n\t}\n}\n\nvoid brcmf_fws_hdrpull(struct brcmf_if *ifp, s16 siglen, struct sk_buff *skb)\n{\n\tstruct brcmf_skb_reorder_data *rd;\n\tstruct brcmf_fws_info *fws = drvr_to_fws(ifp->drvr);\n\tu8 *signal_data;\n\ts16 data_len;\n\tu8 type;\n\tu8 len;\n\tu8 *data;\n\ts32 status;\n\ts32 err;\n\n\tbrcmf_dbg(HDRS, \"enter: ifidx %d, skblen %u, sig %d\\n\",\n\t\t  ifp->ifidx, skb->len, siglen);\n\n\tWARN_ON(siglen > skb->len);\n\n\tif (siglen > skb->len)\n\t\tsiglen = skb->len;\n\n\tif (!siglen)\n\t\treturn;\n\t \n\tif ((!fws) || (!fws->fw_signals)) {\n\t\tskb_pull(skb, siglen);\n\t\treturn;\n\t}\n\n\tfws->stats.header_pulls++;\n\tdata_len = siglen;\n\tsignal_data = skb->data;\n\n\tstatus = BRCMF_FWS_RET_OK_NOSCHEDULE;\n\twhile (data_len > 0) {\n\t\t \n\t\ttype = signal_data[0];\n\n\t\t \n\t\tif (type == BRCMF_FWS_TYPE_FILLER) {\n\t\t\tsignal_data += 1;\n\t\t\tdata_len -= 1;\n\t\t\tcontinue;\n\t\t}\n\t\tlen = signal_data[1];\n\t\tdata = signal_data + 2;\n\n\t\tbrcmf_dbg(HDRS, \"tlv type=%s (%d), len=%d (%d)\\n\",\n\t\t\t  brcmf_fws_get_tlv_name(type), type, len,\n\t\t\t  brcmf_fws_get_tlv_len(fws, type));\n\n\t\t \n\t\tif (data_len < len + 2)\n\t\t\tbreak;\n\n\t\tif (len < brcmf_fws_get_tlv_len(fws, type))\n\t\t\tbreak;\n\n\t\terr = BRCMF_FWS_RET_OK_NOSCHEDULE;\n\t\tswitch (type) {\n\t\tcase BRCMF_FWS_TYPE_HOST_REORDER_RXPKTS:\n\t\t\trd = (struct brcmf_skb_reorder_data *)skb->cb;\n\t\t\trd->reorder = data;\n\t\t\tbreak;\n\t\tcase BRCMF_FWS_TYPE_MACDESC_ADD:\n\t\tcase BRCMF_FWS_TYPE_MACDESC_DEL:\n\t\t\tbrcmf_fws_macdesc_indicate(fws, type, data);\n\t\t\tbreak;\n\t\tcase BRCMF_FWS_TYPE_MAC_OPEN:\n\t\tcase BRCMF_FWS_TYPE_MAC_CLOSE:\n\t\t\terr = brcmf_fws_macdesc_state_indicate(fws, type, data);\n\t\t\tbreak;\n\t\tcase BRCMF_FWS_TYPE_INTERFACE_OPEN:\n\t\tcase BRCMF_FWS_TYPE_INTERFACE_CLOSE:\n\t\t\terr = brcmf_fws_interface_state_indicate(fws, type,\n\t\t\t\t\t\t\t\t data);\n\t\t\tbreak;\n\t\tcase BRCMF_FWS_TYPE_MAC_REQUEST_CREDIT:\n\t\tcase BRCMF_FWS_TYPE_MAC_REQUEST_PACKET:\n\t\t\terr = brcmf_fws_request_indicate(fws, type, data);\n\t\t\tbreak;\n\t\tcase BRCMF_FWS_TYPE_TXSTATUS:\n\t\tcase BRCMF_FWS_TYPE_COMP_TXSTATUS:\n\t\t\tbrcmf_fws_txstatus_indicate(fws, type, data);\n\t\t\tbreak;\n\t\tcase BRCMF_FWS_TYPE_FIFO_CREDITBACK:\n\t\t\terr = brcmf_fws_fifocreditback_indicate(fws, data);\n\t\t\tbreak;\n\t\tcase BRCMF_FWS_TYPE_RSSI:\n\t\t\tbrcmf_fws_rssi_indicate(fws, *data);\n\t\t\tbreak;\n\t\tcase BRCMF_FWS_TYPE_TRANS_ID:\n\t\t\tbrcmf_fws_dbg_seqnum_check(fws, data);\n\t\t\tbreak;\n\t\tcase BRCMF_FWS_TYPE_PKTTAG:\n\t\tcase BRCMF_FWS_TYPE_PENDING_TRAFFIC_BMP:\n\t\tdefault:\n\t\t\tfws->stats.tlv_invalid_type++;\n\t\t\tbreak;\n\t\t}\n\t\tif (err == BRCMF_FWS_RET_OK_SCHEDULE)\n\t\t\tstatus = BRCMF_FWS_RET_OK_SCHEDULE;\n\t\tsignal_data += len + 2;\n\t\tdata_len -= len + 2;\n\t}\n\n\tif (data_len != 0)\n\t\tfws->stats.tlv_parse_failed++;\n\n\tif (status == BRCMF_FWS_RET_OK_SCHEDULE)\n\t\tbrcmf_fws_schedule_deq(fws);\n\n\t \n\tskb_pull(skb, siglen);\n\n\t \n\tif (skb->len == 0)\n\t\tfws->stats.header_only_pkt++;\n}\n\nstatic u8 brcmf_fws_precommit_skb(struct brcmf_fws_info *fws, int fifo,\n\t\t\t\t   struct sk_buff *p)\n{\n\tstruct brcmf_skbuff_cb *skcb = brcmf_skbcb(p);\n\tstruct brcmf_fws_mac_descriptor *entry = skcb->mac;\n\tu8 flags;\n\n\tif (skcb->state != BRCMF_FWS_SKBSTATE_SUPPRESSED)\n\t\tbrcmf_skb_htod_tag_set_field(p, GENERATION, entry->generation);\n\tflags = BRCMF_FWS_HTOD_FLAG_PKTFROMHOST;\n\tif (brcmf_skb_if_flags_get_field(p, REQUESTED)) {\n\t\t \n\t\tflags |= BRCMF_FWS_HTOD_FLAG_PKT_REQUESTED;\n\t}\n\tbrcmf_skb_htod_tag_set_field(p, FLAGS, flags);\n\treturn brcmf_fws_hdrpush(fws, p);\n}\n\nstatic void brcmf_fws_rollback_toq(struct brcmf_fws_info *fws,\n\t\t\t\t   struct sk_buff *skb, int fifo)\n{\n\tstruct brcmf_pub *drvr = fws->drvr;\n\tstruct brcmf_fws_mac_descriptor *entry;\n\tstruct sk_buff *pktout;\n\tint qidx, hslot;\n\tint rc = 0;\n\n\tentry = brcmf_skbcb(skb)->mac;\n\tif (entry->occupied) {\n\t\tqidx = 2 * fifo;\n\t\tif (brcmf_skbcb(skb)->state == BRCMF_FWS_SKBSTATE_SUPPRESSED)\n\t\t\tqidx++;\n\n\t\tpktout = brcmu_pktq_penq_head(&entry->psq, qidx, skb);\n\t\tif (pktout == NULL) {\n\t\t\tbphy_err(drvr, \"%s queue %d full\\n\", entry->name, qidx);\n\t\t\trc = -ENOSPC;\n\t\t}\n\t} else {\n\t\tbphy_err(drvr, \"%s entry removed\\n\", entry->name);\n\t\trc = -ENOENT;\n\t}\n\n\tif (rc) {\n\t\tfws->stats.rollback_failed++;\n\t\thslot = brcmf_skb_htod_tag_get_field(skb, HSLOT);\n\t\tbrcmf_fws_txs_process(fws, BRCMF_FWS_TXSTATUS_HOST_TOSSED,\n\t\t\t\t      hslot, 0, 0, 1);\n\t} else {\n\t\tfws->stats.rollback_success++;\n\t\tbrcmf_fws_return_credits(fws, fifo, 1);\n\t\tbrcmf_fws_macdesc_return_req_credit(skb);\n\t}\n}\n\nstatic int brcmf_fws_borrow_credit(struct brcmf_fws_info *fws,\n\t\t\t\t   int highest_lender_ac, int borrower_ac,\n\t\t\t\t   bool borrow_all)\n{\n\tint lender_ac, borrow_limit = 0;\n\n\tfor (lender_ac = 0; lender_ac <= highest_lender_ac; lender_ac++) {\n\n\t\tif (!borrow_all)\n\t\t\tborrow_limit =\n\t\t\t  fws->init_fifo_credit[lender_ac] / BRCMF_BORROW_RATIO;\n\t\telse\n\t\t\tborrow_limit = 0;\n\n\t\tif (fws->fifo_credit[lender_ac] > borrow_limit) {\n\t\t\tfws->credits_borrowed[borrower_ac][lender_ac]++;\n\t\t\tfws->fifo_credit[lender_ac]--;\n\t\t\tif (fws->fifo_credit[lender_ac] == 0)\n\t\t\t\tfws->fifo_credit_map &= ~(1 << lender_ac);\n\t\t\tfws->fifo_credit_map |= (1 << borrower_ac);\n\t\t\tbrcmf_dbg(DATA, \"borrow credit from: %d\\n\", lender_ac);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfws->fifo_credit_map &= ~(1 << borrower_ac);\n\treturn -ENAVAIL;\n}\n\nstatic int brcmf_fws_commit_skb(struct brcmf_fws_info *fws, int fifo,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct brcmf_skbuff_cb *skcb = brcmf_skbcb(skb);\n\tstruct brcmf_fws_mac_descriptor *entry;\n\tint rc;\n\tu8 ifidx;\n\tu8 data_offset;\n\n\tentry = skcb->mac;\n\tif (IS_ERR(entry))\n\t\treturn PTR_ERR(entry);\n\n\tdata_offset = brcmf_fws_precommit_skb(fws, fifo, skb);\n\tentry->transit_count++;\n\tif (entry->suppressed)\n\t\tentry->suppr_transit_count++;\n\tifidx = brcmf_skb_if_flags_get_field(skb, INDEX);\n\tbrcmf_fws_unlock(fws);\n\trc = brcmf_proto_txdata(fws->drvr, ifidx, data_offset, skb);\n\tbrcmf_fws_lock(fws);\n\tbrcmf_dbg(DATA, \"%s flags %X htod %X bus_tx %d\\n\", entry->name,\n\t\t  skcb->if_flags, skcb->htod, rc);\n\tif (rc < 0) {\n\t\tentry->transit_count--;\n\t\tif (entry->suppressed)\n\t\t\tentry->suppr_transit_count--;\n\t\t(void)brcmf_proto_hdrpull(fws->drvr, false, skb, NULL);\n\t\tgoto rollback;\n\t}\n\n\tfws->stats.pkt2bus++;\n\tfws->stats.send_pkts[fifo]++;\n\tif (brcmf_skb_if_flags_get_field(skb, REQUESTED))\n\t\tfws->stats.requested_sent[fifo]++;\n\n\treturn rc;\n\nrollback:\n\tbrcmf_fws_rollback_toq(fws, skb, fifo);\n\treturn rc;\n}\n\nstatic int brcmf_fws_assign_htod(struct brcmf_fws_info *fws, struct sk_buff *p,\n\t\t\t\t  int fifo)\n{\n\tstruct brcmf_skbuff_cb *skcb = brcmf_skbcb(p);\n\tint rc, hslot;\n\n\tskcb->htod = 0;\n\tskcb->htod_seq = 0;\n\thslot = brcmf_fws_hanger_get_free_slot(&fws->hanger);\n\tbrcmf_skb_htod_tag_set_field(p, HSLOT, hslot);\n\tbrcmf_skb_htod_tag_set_field(p, FREERUN, skcb->mac->seq[fifo]);\n\tbrcmf_skb_htod_tag_set_field(p, FIFO, fifo);\n\trc = brcmf_fws_hanger_pushpkt(&fws->hanger, p, hslot);\n\tif (!rc)\n\t\tskcb->mac->seq[fifo]++;\n\telse\n\t\tfws->stats.generic_error++;\n\treturn rc;\n}\n\nint brcmf_fws_process_skb(struct brcmf_if *ifp, struct sk_buff *skb)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_fws_info *fws = drvr_to_fws(drvr);\n\tstruct brcmf_skbuff_cb *skcb = brcmf_skbcb(skb);\n\tstruct ethhdr *eh = (struct ethhdr *)(skb->data);\n\tint fifo = BRCMF_FWS_FIFO_BCMC;\n\tbool multicast = is_multicast_ether_addr(eh->h_dest);\n\tint rc = 0;\n\n\tbrcmf_dbg(DATA, \"tx proto=0x%X\\n\", ntohs(eh->h_proto));\n\n\t \n\tskcb->if_flags = 0;\n\tskcb->state = BRCMF_FWS_SKBSTATE_NEW;\n\tbrcmf_skb_if_flags_set_field(skb, INDEX, ifp->ifidx);\n\n\t \n\tif (!multicast)\n\t\tfifo = brcmf_map_prio_to_aci(drvr->config, skb->priority);\n\n\tbrcmf_fws_lock(fws);\n\tif (fifo != BRCMF_FWS_FIFO_AC_BE && fifo < BRCMF_FWS_FIFO_BCMC)\n\t\tfws->borrow_defer_timestamp = jiffies +\n\t\t\t\t\t      BRCMF_FWS_BORROW_DEFER_PERIOD;\n\n\tskcb->mac = brcmf_fws_macdesc_find(fws, ifp, eh->h_dest);\n\tbrcmf_dbg(DATA, \"%s mac %pM multi %d fifo %d\\n\", skcb->mac->name,\n\t\t  eh->h_dest, multicast, fifo);\n\tif (!brcmf_fws_assign_htod(fws, skb, fifo)) {\n\t\tbrcmf_fws_enq(fws, BRCMF_FWS_SKBSTATE_DELAYED, fifo, skb);\n\t\tbrcmf_fws_schedule_deq(fws);\n\t} else {\n\t\tbphy_err(drvr, \"no hanger slot available\\n\");\n\t\trc = -ENOMEM;\n\t}\n\tbrcmf_fws_unlock(fws);\n\n\treturn rc;\n}\n\nvoid brcmf_fws_reset_interface(struct brcmf_if *ifp)\n{\n\tstruct brcmf_fws_mac_descriptor *entry = ifp->fws_desc;\n\n\tbrcmf_dbg(TRACE, \"enter: bsscfgidx=%d\\n\", ifp->bsscfgidx);\n\tif (!entry)\n\t\treturn;\n\n\tbrcmf_fws_macdesc_init(entry, ifp->mac_addr, ifp->ifidx);\n}\n\nvoid brcmf_fws_add_interface(struct brcmf_if *ifp)\n{\n\tstruct brcmf_fws_info *fws = drvr_to_fws(ifp->drvr);\n\tstruct brcmf_fws_mac_descriptor *entry;\n\n\tif (!ifp->ndev || !brcmf_fws_queue_skbs(fws))\n\t\treturn;\n\n\tentry = &fws->desc.iface[ifp->ifidx];\n\tifp->fws_desc = entry;\n\tbrcmf_fws_macdesc_init(entry, ifp->mac_addr, ifp->ifidx);\n\tbrcmf_fws_macdesc_set_name(fws, entry);\n\tbrcmu_pktq_init(&entry->psq, BRCMF_FWS_PSQ_PREC_COUNT,\n\t\t\tBRCMF_FWS_PSQ_LEN);\n\tbrcmf_dbg(TRACE, \"added %s\\n\", entry->name);\n}\n\nvoid brcmf_fws_del_interface(struct brcmf_if *ifp)\n{\n\tstruct brcmf_fws_mac_descriptor *entry = ifp->fws_desc;\n\tstruct brcmf_fws_info *fws = drvr_to_fws(ifp->drvr);\n\n\tif (!entry)\n\t\treturn;\n\n\tbrcmf_fws_lock(fws);\n\tifp->fws_desc = NULL;\n\tbrcmf_dbg(TRACE, \"deleting %s\\n\", entry->name);\n\tbrcmf_fws_macdesc_cleanup(fws, &fws->desc.iface[ifp->ifidx],\n\t\t\t\t  ifp->ifidx);\n\tbrcmf_fws_macdesc_deinit(entry);\n\tbrcmf_fws_cleanup(fws, ifp->ifidx);\n\tbrcmf_fws_unlock(fws);\n}\n\nstatic void brcmf_fws_dequeue_worker(struct work_struct *worker)\n{\n\tstruct brcmf_fws_info *fws;\n\tstruct brcmf_pub *drvr;\n\tstruct sk_buff *skb;\n\tint fifo;\n\tu32 hslot;\n\tu32 ifidx;\n\tint ret;\n\n\tfws = container_of(worker, struct brcmf_fws_info, fws_dequeue_work);\n\tdrvr = fws->drvr;\n\n\tbrcmf_fws_lock(fws);\n\tfor (fifo = BRCMF_FWS_FIFO_BCMC; fifo >= 0 && !fws->bus_flow_blocked;\n\t     fifo--) {\n\t\tif (!brcmf_fws_fc_active(fws)) {\n\t\t\twhile ((skb = brcmf_fws_deq(fws, fifo)) != NULL) {\n\t\t\t\thslot = brcmf_skb_htod_tag_get_field(skb,\n\t\t\t\t\t\t\t\t     HSLOT);\n\t\t\t\tbrcmf_fws_hanger_poppkt(&fws->hanger, hslot,\n\t\t\t\t\t\t\t&skb, true);\n\t\t\t\tifidx = brcmf_skb_if_flags_get_field(skb,\n\t\t\t\t\t\t\t\t     INDEX);\n\t\t\t\t \n\t\t\t\tbrcmf_fws_unlock(fws);\n\t\t\t\tret = brcmf_proto_txdata(drvr, ifidx, 0, skb);\n\t\t\t\tbrcmf_fws_lock(fws);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tbrcmf_txfinalize(brcmf_get_ifp(drvr,\n\t\t\t\t\t\t\t\t       ifidx),\n\t\t\t\t\t\t\t skb, false);\n\t\t\t\tif (fws->bus_flow_blocked)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile ((fws->fifo_credit[fifo]) ||\n\t\t       ((!fws->bcmc_credit_check) &&\n\t\t\t\t(fifo == BRCMF_FWS_FIFO_BCMC))) {\n\t\t\tskb = brcmf_fws_deq(fws, fifo);\n\t\t\tif (!skb)\n\t\t\t\tbreak;\n\t\t\tfws->fifo_credit[fifo]--;\n\t\t\tif (brcmf_fws_commit_skb(fws, fifo, skb))\n\t\t\t\tbreak;\n\t\t\tif (fws->bus_flow_blocked)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (fifo >= BRCMF_FWS_FIFO_AC_BE &&\n\t\t    fifo <= BRCMF_FWS_FIFO_AC_VO &&\n\t\t    fws->fifo_credit[fifo] == 0 &&\n\t\t    !fws->bus_flow_blocked) {\n\t\t\twhile (brcmf_fws_borrow_credit(fws,\n\t\t\t\t\t\t       fifo - 1, fifo,\n\t\t\t\t\t\t       true) == 0) {\n\t\t\t\tskb = brcmf_fws_deq(fws, fifo);\n\t\t\t\tif (!skb) {\n\t\t\t\t\tbrcmf_fws_return_credits(fws, fifo, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (brcmf_fws_commit_skb(fws, fifo, skb))\n\t\t\t\t\tbreak;\n\t\t\t\tif (fws->bus_flow_blocked)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tbrcmf_fws_unlock(fws);\n}\n\n#ifdef DEBUG\nstatic int brcmf_debugfs_fws_stats_read(struct seq_file *seq, void *data)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(seq->private);\n\tstruct brcmf_fws_stats *fwstats = &(drvr_to_fws(bus_if->drvr)->stats);\n\n\tseq_printf(seq,\n\t\t   \"header_pulls:      %u\\n\"\n\t\t   \"header_only_pkt:   %u\\n\"\n\t\t   \"tlv_parse_failed:  %u\\n\"\n\t\t   \"tlv_invalid_type:  %u\\n\"\n\t\t   \"mac_update_fails:  %u\\n\"\n\t\t   \"ps_update_fails:   %u\\n\"\n\t\t   \"if_update_fails:   %u\\n\"\n\t\t   \"pkt2bus:           %u\\n\"\n\t\t   \"generic_error:     %u\\n\"\n\t\t   \"rollback_success:  %u\\n\"\n\t\t   \"rollback_failed:   %u\\n\"\n\t\t   \"delayq_full:       %u\\n\"\n\t\t   \"supprq_full:       %u\\n\"\n\t\t   \"txs_indicate:      %u\\n\"\n\t\t   \"txs_discard:       %u\\n\"\n\t\t   \"txs_suppr_core:    %u\\n\"\n\t\t   \"txs_suppr_ps:      %u\\n\"\n\t\t   \"txs_tossed:        %u\\n\"\n\t\t   \"txs_host_tossed:   %u\\n\"\n\t\t   \"bus_flow_block:    %u\\n\"\n\t\t   \"fws_flow_block:    %u\\n\"\n\t\t   \"send_pkts:         BK:%u BE:%u VO:%u VI:%u BCMC:%u\\n\"\n\t\t   \"requested_sent:    BK:%u BE:%u VO:%u VI:%u BCMC:%u\\n\",\n\t\t   fwstats->header_pulls,\n\t\t   fwstats->header_only_pkt,\n\t\t   fwstats->tlv_parse_failed,\n\t\t   fwstats->tlv_invalid_type,\n\t\t   fwstats->mac_update_failed,\n\t\t   fwstats->mac_ps_update_failed,\n\t\t   fwstats->if_update_failed,\n\t\t   fwstats->pkt2bus,\n\t\t   fwstats->generic_error,\n\t\t   fwstats->rollback_success,\n\t\t   fwstats->rollback_failed,\n\t\t   fwstats->delayq_full_error,\n\t\t   fwstats->supprq_full_error,\n\t\t   fwstats->txs_indicate,\n\t\t   fwstats->txs_discard,\n\t\t   fwstats->txs_supp_core,\n\t\t   fwstats->txs_supp_ps,\n\t\t   fwstats->txs_tossed,\n\t\t   fwstats->txs_host_tossed,\n\t\t   fwstats->bus_flow_block,\n\t\t   fwstats->fws_flow_block,\n\t\t   fwstats->send_pkts[0], fwstats->send_pkts[1],\n\t\t   fwstats->send_pkts[2], fwstats->send_pkts[3],\n\t\t   fwstats->send_pkts[4],\n\t\t   fwstats->requested_sent[0],\n\t\t   fwstats->requested_sent[1],\n\t\t   fwstats->requested_sent[2],\n\t\t   fwstats->requested_sent[3],\n\t\t   fwstats->requested_sent[4]);\n\n\treturn 0;\n}\n#else\nstatic int brcmf_debugfs_fws_stats_read(struct seq_file *seq, void *data)\n{\n\treturn 0;\n}\n#endif\n\nstruct brcmf_fws_info *brcmf_fws_attach(struct brcmf_pub *drvr)\n{\n\tstruct brcmf_fws_info *fws;\n\tstruct brcmf_if *ifp;\n\tu32 tlv = BRCMF_FWS_FLAGS_RSSI_SIGNALS;\n\tint rc;\n\tu32 mode;\n\n\tfws = kzalloc(sizeof(*fws), GFP_KERNEL);\n\tif (!fws) {\n\t\trc = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tspin_lock_init(&fws->spinlock);\n\n\t \n\tfws->drvr = drvr;\n\tfws->fcmode = drvr->settings->fcmode;\n\n\tif (!drvr->bus_if->always_use_fws_queue &&\n\t    (fws->fcmode == BRCMF_FWS_FCMODE_NONE)) {\n\t\tfws->avoid_queueing = true;\n\t\tbrcmf_dbg(INFO, \"FWS queueing will be avoided\\n\");\n\t\treturn fws;\n\t}\n\n\tfws->fws_wq = create_singlethread_workqueue(\"brcmf_fws_wq\");\n\tif (fws->fws_wq == NULL) {\n\t\tbphy_err(drvr, \"workqueue creation failed\\n\");\n\t\trc = -EBADF;\n\t\tgoto fail;\n\t}\n\tINIT_WORK(&fws->fws_dequeue_work, brcmf_fws_dequeue_worker);\n\n\t \n\tif (fws->fcmode != BRCMF_FWS_FCMODE_NONE)\n\t\ttlv |= BRCMF_FWS_FLAGS_XONXOFF_SIGNALS |\n\t\t       BRCMF_FWS_FLAGS_CREDIT_STATUS_SIGNALS |\n\t\t       BRCMF_FWS_FLAGS_HOST_PROPTXSTATUS_ACTIVE |\n\t\t       BRCMF_FWS_FLAGS_HOST_RXREORDER_ACTIVE;\n\n\trc = brcmf_fweh_register(drvr, BRCMF_E_FIFO_CREDIT_MAP,\n\t\t\t\t brcmf_fws_notify_credit_map);\n\tif (rc < 0) {\n\t\tbphy_err(drvr, \"register credit map handler failed\\n\");\n\t\tgoto fail;\n\t}\n\trc = brcmf_fweh_register(drvr, BRCMF_E_BCMC_CREDIT_SUPPORT,\n\t\t\t\t brcmf_fws_notify_bcmc_credit_support);\n\tif (rc < 0) {\n\t\tbphy_err(drvr, \"register bcmc credit handler failed\\n\");\n\t\tbrcmf_fweh_unregister(drvr, BRCMF_E_FIFO_CREDIT_MAP);\n\t\tgoto fail;\n\t}\n\n\t \n\tfws->fw_signals = true;\n\tifp = brcmf_get_ifp(drvr, 0);\n\tif (brcmf_fil_iovar_int_set(ifp, \"tlv\", tlv)) {\n\t\tbphy_err(drvr, \"failed to set bdcv2 tlv signaling\\n\");\n\t\tfws->fcmode = BRCMF_FWS_FCMODE_NONE;\n\t\tfws->fw_signals = false;\n\t}\n\n\tif (brcmf_fil_iovar_int_set(ifp, \"ampdu_hostreorder\", 1))\n\t\tbrcmf_dbg(INFO, \"enabling AMPDU host-reorder failed\\n\");\n\n\t \n\tif (brcmf_fil_iovar_int_get(ifp, \"wlfc_mode\", &mode) == 0) {\n\t\tif (BRCMF_FWS_MODE_GET_REUSESEQ(mode)) {\n\t\t\tmode = 0;\n\t\t\tBRCMF_FWS_MODE_SET_REUSESEQ(mode, 1);\n\t\t\tif (brcmf_fil_iovar_int_set(ifp,\n\t\t\t\t\t\t    \"wlfc_mode\", mode) == 0) {\n\t\t\t\tBRCMF_FWS_MODE_SET_REUSESEQ(fws->mode, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tbrcmf_fws_hanger_init(&fws->hanger);\n\tbrcmf_fws_macdesc_init(&fws->desc.other, NULL, 0);\n\tbrcmf_fws_macdesc_set_name(fws, &fws->desc.other);\n\tbrcmf_dbg(INFO, \"added %s\\n\", fws->desc.other.name);\n\tbrcmu_pktq_init(&fws->desc.other.psq, BRCMF_FWS_PSQ_PREC_COUNT,\n\t\t\tBRCMF_FWS_PSQ_LEN);\n\n\tbrcmf_dbg(INFO, \"%s bdcv2 tlv signaling [%x]\\n\",\n\t\t  fws->fw_signals ? \"enabled\" : \"disabled\", tlv);\n\treturn fws;\n\nfail:\n\tbrcmf_fws_detach(fws);\n\treturn ERR_PTR(rc);\n}\n\nvoid brcmf_fws_detach(struct brcmf_fws_info *fws)\n{\n\tif (!fws)\n\t\treturn;\n\n\tif (fws->fws_wq)\n\t\tdestroy_workqueue(fws->fws_wq);\n\n\t \n\tbrcmf_fws_lock(fws);\n\tbrcmf_fws_cleanup(fws, -1);\n\tbrcmf_fws_unlock(fws);\n\n\t \n\tkfree(fws);\n}\n\nvoid brcmf_fws_debugfs_create(struct brcmf_pub *drvr)\n{\n\t \n\tbrcmf_debugfs_add_entry(drvr, \"fws_stats\",\n\t\t\t\tbrcmf_debugfs_fws_stats_read);\n}\n\nbool brcmf_fws_queue_skbs(struct brcmf_fws_info *fws)\n{\n\treturn !fws->avoid_queueing;\n}\n\nbool brcmf_fws_fc_active(struct brcmf_fws_info *fws)\n{\n\tif (!fws->creditmap_received)\n\t\treturn false;\n\n\treturn fws->fcmode != BRCMF_FWS_FCMODE_NONE;\n}\n\nvoid brcmf_fws_bustxcomplete(struct brcmf_fws_info *fws, struct sk_buff *skb,\n\t\t\t     bool success)\n{\n\tu32 hslot;\n\n\tif (brcmf_skbcb(skb)->state == BRCMF_FWS_SKBSTATE_TIM) {\n\t\tbrcmu_pkt_buf_free_skb(skb);\n\t\treturn;\n\t}\n\n\tif (!success) {\n\t\tbrcmf_fws_lock(fws);\n\t\thslot = brcmf_skb_htod_tag_get_field(skb, HSLOT);\n\t\tbrcmf_fws_txs_process(fws, BRCMF_FWS_TXSTATUS_HOST_TOSSED, hslot,\n\t\t\t\t      0, 0, 1);\n\t\tbrcmf_fws_unlock(fws);\n\t}\n}\n\nvoid brcmf_fws_bus_blocked(struct brcmf_pub *drvr, bool flow_blocked)\n{\n\tstruct brcmf_fws_info *fws = drvr_to_fws(drvr);\n\tstruct brcmf_if *ifp;\n\tint i;\n\n\tif (fws->avoid_queueing) {\n\t\tfor (i = 0; i < BRCMF_MAX_IFS; i++) {\n\t\t\tifp = drvr->iflist[i];\n\t\t\tif (!ifp || !ifp->ndev)\n\t\t\t\tcontinue;\n\t\t\tbrcmf_txflowblock_if(ifp, BRCMF_NETIF_STOP_REASON_FLOW,\n\t\t\t\t\t     flow_blocked);\n\t\t}\n\t} else {\n\t\tfws->bus_flow_blocked = flow_blocked;\n\t\tif (!flow_blocked)\n\t\t\tbrcmf_fws_schedule_deq(fws);\n\t\telse\n\t\t\tfws->stats.bus_flow_block++;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}