{
  "module_name": "common.c",
  "hash_id": "44ed133a26d1307c301cb99a18a49649fcb9a1a6af94b4b6231fd7e6fea1335f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/netdevice.h>\n#include <linux/module.h>\n#include <linux/firmware.h>\n#include <brcmu_wifi.h>\n#include <brcmu_utils.h>\n#include \"core.h\"\n#include \"bus.h\"\n#include \"debug.h\"\n#include \"fwil.h\"\n#include \"fwil_types.h\"\n#include \"tracepoint.h\"\n#include \"common.h\"\n#include \"of.h\"\n#include \"firmware.h\"\n#include \"chip.h\"\n\nMODULE_AUTHOR(\"Broadcom Corporation\");\nMODULE_DESCRIPTION(\"Broadcom 802.11 wireless LAN fullmac driver.\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\n#define BRCMF_DEFAULT_SCAN_CHANNEL_TIME\t40\n#define BRCMF_DEFAULT_SCAN_UNASSOC_TIME\t40\n\n \n#define BRCMF_JOIN_PREF_RSSI_BOOST\t8\n\n#define BRCMF_DEFAULT_TXGLOM_SIZE\t32   \n\nstatic int brcmf_sdiod_txglomsz = BRCMF_DEFAULT_TXGLOM_SIZE;\nmodule_param_named(txglomsz, brcmf_sdiod_txglomsz, int, 0);\nMODULE_PARM_DESC(txglomsz, \"Maximum tx packet chain size [SDIO]\");\n\n \nint brcmf_msg_level;\nmodule_param_named(debug, brcmf_msg_level, int, 0600);\nMODULE_PARM_DESC(debug, \"Level of debug output\");\n\nstatic int brcmf_p2p_enable;\nmodule_param_named(p2pon, brcmf_p2p_enable, int, 0);\nMODULE_PARM_DESC(p2pon, \"Enable legacy p2p management functionality\");\n\nstatic int brcmf_feature_disable;\nmodule_param_named(feature_disable, brcmf_feature_disable, int, 0);\nMODULE_PARM_DESC(feature_disable, \"Disable features\");\n\nstatic char brcmf_firmware_path[BRCMF_FW_ALTPATH_LEN];\nmodule_param_string(alternative_fw_path, brcmf_firmware_path,\n\t\t    BRCMF_FW_ALTPATH_LEN, 0400);\nMODULE_PARM_DESC(alternative_fw_path, \"Alternative firmware path\");\n\nstatic int brcmf_fcmode;\nmodule_param_named(fcmode, brcmf_fcmode, int, 0);\nMODULE_PARM_DESC(fcmode, \"Mode of firmware signalled flow control\");\n\nstatic int brcmf_roamoff;\nmodule_param_named(roamoff, brcmf_roamoff, int, 0400);\nMODULE_PARM_DESC(roamoff, \"Do not use internal roaming engine\");\n\nstatic int brcmf_iapp_enable;\nmodule_param_named(iapp, brcmf_iapp_enable, int, 0);\nMODULE_PARM_DESC(iapp, \"Enable partial support for the obsoleted Inter-Access Point Protocol\");\n\n#ifdef DEBUG\n \nstatic int brcmf_ignore_probe_fail;\nmodule_param_named(ignore_probe_fail, brcmf_ignore_probe_fail, int, 0);\nMODULE_PARM_DESC(ignore_probe_fail, \"always succeed probe for debugging\");\n#endif\n\nstatic struct brcmfmac_platform_data *brcmfmac_pdata;\nstruct brcmf_mp_global_t brcmf_mp_global;\n\nvoid brcmf_c_set_joinpref_default(struct brcmf_if *ifp)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_join_pref_params join_pref_params[2];\n\tint err;\n\n\t \n\tjoin_pref_params[0].type = BRCMF_JOIN_PREF_RSSI_DELTA;\n\tjoin_pref_params[0].len = 2;\n\tjoin_pref_params[0].rssi_gain = BRCMF_JOIN_PREF_RSSI_BOOST;\n\tjoin_pref_params[0].band = WLC_BAND_5G;\n\n\tjoin_pref_params[1].type = BRCMF_JOIN_PREF_RSSI;\n\tjoin_pref_params[1].len = 2;\n\tjoin_pref_params[1].rssi_gain = 0;\n\tjoin_pref_params[1].band = 0;\n\terr = brcmf_fil_iovar_data_set(ifp, \"join_pref\", join_pref_params,\n\t\t\t\t       sizeof(join_pref_params));\n\tif (err)\n\t\tbphy_err(drvr, \"Set join_pref error (%d)\\n\", err);\n}\n\nstatic int brcmf_c_download(struct brcmf_if *ifp, u16 flag,\n\t\t\t    struct brcmf_dload_data_le *dload_buf,\n\t\t\t    u32 len, const char *var)\n{\n\ts32 err;\n\n\tflag |= (DLOAD_HANDLER_VER << DLOAD_FLAG_VER_SHIFT);\n\tdload_buf->flag = cpu_to_le16(flag);\n\tdload_buf->dload_type = cpu_to_le16(DL_TYPE_CLM);\n\tdload_buf->len = cpu_to_le32(len);\n\tdload_buf->crc = cpu_to_le32(0);\n\n\terr = brcmf_fil_iovar_data_set(ifp, var, dload_buf,\n\t\t\t\t       struct_size(dload_buf, data, len));\n\n\treturn err;\n}\n\nstatic int brcmf_c_download_blob(struct brcmf_if *ifp,\n\t\t\t\t const void *data, size_t size,\n\t\t\t\t const char *loadvar, const char *statvar)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_dload_data_le *chunk_buf;\n\tu32 chunk_len;\n\tu32 datalen;\n\tu32 cumulative_len;\n\tu16 dl_flag = DL_BEGIN;\n\tu32 status;\n\ts32 err;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tchunk_buf = kzalloc(struct_size(chunk_buf, data, MAX_CHUNK_LEN),\n\t\t\t    GFP_KERNEL);\n\tif (!chunk_buf) {\n\t\terr = -ENOMEM;\n\t\treturn -ENOMEM;\n\t}\n\n\tdatalen = size;\n\tcumulative_len = 0;\n\tdo {\n\t\tif (datalen > MAX_CHUNK_LEN) {\n\t\t\tchunk_len = MAX_CHUNK_LEN;\n\t\t} else {\n\t\t\tchunk_len = datalen;\n\t\t\tdl_flag |= DL_END;\n\t\t}\n\t\tmemcpy(chunk_buf->data, data + cumulative_len, chunk_len);\n\n\t\terr = brcmf_c_download(ifp, dl_flag, chunk_buf, chunk_len,\n\t\t\t\t       loadvar);\n\n\t\tdl_flag &= ~DL_BEGIN;\n\n\t\tcumulative_len += chunk_len;\n\t\tdatalen -= chunk_len;\n\t} while ((datalen > 0) && (err == 0));\n\n\tif (err) {\n\t\tbphy_err(drvr, \"%s (%zu byte file) failed (%d)\\n\",\n\t\t\t loadvar, size, err);\n\t\t \n\t\terr = brcmf_fil_iovar_int_get(ifp, statvar, &status);\n\t\tif (err)\n\t\t\tbphy_err(drvr, \"get %s failed (%d)\\n\", statvar, err);\n\t\telse\n\t\t\tbrcmf_dbg(INFO, \"%s=%d\\n\", statvar, status);\n\t\terr = -EIO;\n\t}\n\n\tkfree(chunk_buf);\n\treturn err;\n}\n\nstatic int brcmf_c_process_clm_blob(struct brcmf_if *ifp)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_bus *bus = drvr->bus_if;\n\tconst struct firmware *fw = NULL;\n\ts32 err;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\terr = brcmf_bus_get_blob(bus, &fw, BRCMF_BLOB_CLM);\n\tif (err || !fw) {\n\t\tbrcmf_info(\"no clm_blob available (err=%d), device may have limited channels available\\n\",\n\t\t\t   err);\n\t\treturn 0;\n\t}\n\n\terr = brcmf_c_download_blob(ifp, fw->data, fw->size,\n\t\t\t\t    \"clmload\", \"clmload_status\");\n\n\trelease_firmware(fw);\n\treturn err;\n}\n\nstatic int brcmf_c_process_txcap_blob(struct brcmf_if *ifp)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_bus *bus = drvr->bus_if;\n\tconst struct firmware *fw = NULL;\n\ts32 err;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\terr = brcmf_bus_get_blob(bus, &fw, BRCMF_BLOB_TXCAP);\n\tif (err || !fw) {\n\t\tbrcmf_info(\"no txcap_blob available (err=%d)\\n\", err);\n\t\treturn 0;\n\t}\n\n\tbrcmf_info(\"TxCap blob found, loading\\n\");\n\terr = brcmf_c_download_blob(ifp, fw->data, fw->size,\n\t\t\t\t    \"txcapload\", \"txcapload_status\");\n\n\trelease_firmware(fw);\n\treturn err;\n}\n\nint brcmf_c_set_cur_etheraddr(struct brcmf_if *ifp, const u8 *addr)\n{\n\ts32 err;\n\n\terr = brcmf_fil_iovar_data_set(ifp, \"cur_etheraddr\", addr, ETH_ALEN);\n\tif (err < 0)\n\t\tbphy_err(ifp->drvr, \"Setting cur_etheraddr failed, %d\\n\", err);\n\n\treturn err;\n}\n\n \nstatic const u8 brcmf_default_mac_address[ETH_ALEN] = {\n\t0x00, 0x90, 0x4c, 0xc5, 0x12, 0x38\n};\n\nstatic int brcmf_c_process_cal_blob(struct brcmf_if *ifp)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_mp_device *settings = drvr->settings;\n\ts32 err;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tif (!settings->cal_blob || !settings->cal_size)\n\t\treturn 0;\n\n\tbrcmf_info(\"Calibration blob provided by platform, loading\\n\");\n\terr = brcmf_c_download_blob(ifp, settings->cal_blob, settings->cal_size,\n\t\t\t\t    \"calload\", \"calload_status\");\n\treturn err;\n}\n\nint brcmf_c_preinit_dcmds(struct brcmf_if *ifp)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\ts8 eventmask[BRCMF_EVENTING_MASK_LEN];\n\tu8 buf[BRCMF_DCMD_SMLEN];\n\tstruct brcmf_bus *bus;\n\tstruct brcmf_rev_info_le revinfo;\n\tstruct brcmf_rev_info *ri;\n\tchar *clmver;\n\tchar *ptr;\n\ts32 err;\n\n\tif (is_valid_ether_addr(ifp->mac_addr)) {\n\t\t \n\t\terr = brcmf_c_set_cur_etheraddr(ifp, ifp->mac_addr);\n\t\tif (err < 0)\n\t\t\tgoto done;\n\t} else {\n\t\t \n\t\terr = brcmf_fil_iovar_data_get(ifp, \"cur_etheraddr\", ifp->mac_addr,\n\t\t\t\t\t       sizeof(ifp->mac_addr));\n\t\tif (err < 0) {\n\t\t\tbphy_err(drvr, \"Retrieving cur_etheraddr failed, %d\\n\", err);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (ether_addr_equal_unaligned(ifp->mac_addr, brcmf_default_mac_address)) {\n\t\t\tbphy_err(drvr, \"Default MAC is used, replacing with random MAC to avoid conflicts\\n\");\n\t\t\teth_random_addr(ifp->mac_addr);\n\t\t\tifp->ndev->addr_assign_type = NET_ADDR_RANDOM;\n\t\t\terr = brcmf_c_set_cur_etheraddr(ifp, ifp->mac_addr);\n\t\t\tif (err < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\tmemcpy(ifp->drvr->mac, ifp->mac_addr, sizeof(ifp->drvr->mac));\n\tmemcpy(ifp->drvr->wiphy->perm_addr, ifp->drvr->mac, ETH_ALEN);\n\n\tbus = ifp->drvr->bus_if;\n\tri = &ifp->drvr->revinfo;\n\n\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_REVINFO,\n\t\t\t\t     &revinfo, sizeof(revinfo));\n\tif (err < 0) {\n\t\tbphy_err(drvr, \"retrieving revision info failed, %d\\n\", err);\n\t\tstrscpy(ri->chipname, \"UNKNOWN\", sizeof(ri->chipname));\n\t} else {\n\t\tri->vendorid = le32_to_cpu(revinfo.vendorid);\n\t\tri->deviceid = le32_to_cpu(revinfo.deviceid);\n\t\tri->radiorev = le32_to_cpu(revinfo.radiorev);\n\t\tri->corerev = le32_to_cpu(revinfo.corerev);\n\t\tri->boardid = le32_to_cpu(revinfo.boardid);\n\t\tri->boardvendor = le32_to_cpu(revinfo.boardvendor);\n\t\tri->boardrev = le32_to_cpu(revinfo.boardrev);\n\t\tri->driverrev = le32_to_cpu(revinfo.driverrev);\n\t\tri->ucoderev = le32_to_cpu(revinfo.ucoderev);\n\t\tri->bus = le32_to_cpu(revinfo.bus);\n\t\tri->phytype = le32_to_cpu(revinfo.phytype);\n\t\tri->phyrev = le32_to_cpu(revinfo.phyrev);\n\t\tri->anarev = le32_to_cpu(revinfo.anarev);\n\t\tri->chippkg = le32_to_cpu(revinfo.chippkg);\n\t\tri->nvramrev = le32_to_cpu(revinfo.nvramrev);\n\n\t\t \n\t\tif (!bus->chip) {\n\t\t\tbus->chip = le32_to_cpu(revinfo.chipnum);\n\t\t\tbus->chiprev = le32_to_cpu(revinfo.chiprev);\n\t\t}\n\t}\n\tri->result = err;\n\n\tif (bus->chip)\n\t\tbrcmf_chip_name(bus->chip, bus->chiprev,\n\t\t\t\tri->chipname, sizeof(ri->chipname));\n\n\t \n\terr = brcmf_c_process_clm_blob(ifp);\n\tif (err < 0) {\n\t\tbphy_err(drvr, \"download CLM blob file failed, %d\\n\", err);\n\t\tgoto done;\n\t}\n\n\t \n\terr = brcmf_c_process_txcap_blob(ifp);\n\tif (err < 0) {\n\t\tbphy_err(drvr, \"download TxCap blob file failed, %d\\n\", err);\n\t\tgoto done;\n\t}\n\n\t \n\terr = brcmf_c_process_cal_blob(ifp);\n\tif (err < 0) {\n\t\tbphy_err(drvr, \"download calibration blob file failed, %d\\n\", err);\n\t\tgoto done;\n\t}\n\n\t \n\tmemset(buf, 0, sizeof(buf));\n\terr = brcmf_fil_iovar_data_get(ifp, \"ver\", buf, sizeof(buf));\n\tif (err < 0) {\n\t\tbphy_err(drvr, \"Retrieving version information failed, %d\\n\",\n\t\t\t err);\n\t\tgoto done;\n\t}\n\tbuf[sizeof(buf) - 1] = '\\0';\n\tptr = (char *)buf;\n\tstrsep(&ptr, \"\\n\");\n\n\t \n\tbrcmf_info(\"Firmware: %s %s\\n\", ri->chipname, buf);\n\n\t \n\tptr = strrchr(buf, ' ');\n\tif (!ptr) {\n\t\tbphy_err(drvr, \"Retrieving version number failed\");\n\t\tgoto done;\n\t}\n\tstrscpy(ifp->drvr->fwver, ptr + 1, sizeof(ifp->drvr->fwver));\n\n\t \n\tmemset(buf, 0, sizeof(buf));\n\terr = brcmf_fil_iovar_data_get(ifp, \"clmver\", buf, sizeof(buf));\n\tif (err) {\n\t\tbrcmf_dbg(TRACE, \"retrieving clmver failed, %d\\n\", err);\n\t} else {\n\t\tbuf[sizeof(buf) - 1] = '\\0';\n\t\tclmver = (char *)buf;\n\n\t\t \n\t\tstrreplace(clmver, '\\n', ' ');\n\n\t\t \n\t\tmemcpy(ifp->drvr->clmver, clmver, sizeof(ifp->drvr->clmver));\n\n\t\tbrcmf_dbg(INFO, \"CLM version = %s\\n\", clmver);\n\t}\n\n\t \n\terr = brcmf_fil_iovar_int_set(ifp, \"mpc\", 1);\n\tif (err) {\n\t\tbphy_err(drvr, \"failed setting mpc\\n\");\n\t\tgoto done;\n\t}\n\n\tbrcmf_c_set_joinpref_default(ifp);\n\n\t \n\terr = brcmf_fil_iovar_data_get(ifp, \"event_msgs\", eventmask,\n\t\t\t\t       BRCMF_EVENTING_MASK_LEN);\n\tif (err) {\n\t\tbphy_err(drvr, \"Get event_msgs error (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\tsetbit(eventmask, BRCMF_E_IF);\n\terr = brcmf_fil_iovar_data_set(ifp, \"event_msgs\", eventmask,\n\t\t\t\t       BRCMF_EVENTING_MASK_LEN);\n\tif (err) {\n\t\tbphy_err(drvr, \"Set event_msgs error (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\t \n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_CHANNEL_TIME,\n\t\t\t\t    BRCMF_DEFAULT_SCAN_CHANNEL_TIME);\n\tif (err) {\n\t\tbphy_err(drvr, \"BRCMF_C_SET_SCAN_CHANNEL_TIME error (%d)\\n\",\n\t\t\t err);\n\t\tgoto done;\n\t}\n\n\t \n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_UNASSOC_TIME,\n\t\t\t\t    BRCMF_DEFAULT_SCAN_UNASSOC_TIME);\n\tif (err) {\n\t\tbphy_err(drvr, \"BRCMF_C_SET_SCAN_UNASSOC_TIME error (%d)\\n\",\n\t\t\t err);\n\t\tgoto done;\n\t}\n\n\t \n\t(void)brcmf_fil_iovar_int_set(ifp, \"txbf\", 1);\ndone:\n\treturn err;\n}\n\n#ifndef CONFIG_BRCM_TRACING\nvoid __brcmf_err(struct brcmf_bus *bus, const char *func, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (bus)\n\t\tdev_err(bus->dev, \"%s: %pV\", func, &vaf);\n\telse\n\t\tpr_err(\"%s: %pV\", func, &vaf);\n\n\tva_end(args);\n}\n#endif\n\n#if defined(CONFIG_BRCM_TRACING) || defined(CONFIG_BRCMDBG)\nvoid __brcmf_dbg(u32 level, const char *func, const char *fmt, ...)\n{\n\tstruct va_format vaf = {\n\t\t.fmt = fmt,\n\t};\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.va = &args;\n\tif (brcmf_msg_level & level)\n\t\tpr_debug(\"%s %pV\", func, &vaf);\n\ttrace_brcmf_dbg(level, func, &vaf);\n\tva_end(args);\n}\n#endif\n\nstatic void brcmf_mp_attach(void)\n{\n\t \n\tstrscpy(brcmf_mp_global.firmware_path, brcmf_firmware_path,\n\t\tBRCMF_FW_ALTPATH_LEN);\n\tif ((brcmfmac_pdata) && (brcmfmac_pdata->fw_alternative_path) &&\n\t    (brcmf_mp_global.firmware_path[0] == '\\0')) {\n\t\tstrscpy(brcmf_mp_global.firmware_path,\n\t\t\tbrcmfmac_pdata->fw_alternative_path,\n\t\t\tBRCMF_FW_ALTPATH_LEN);\n\t}\n}\n\nstruct brcmf_mp_device *brcmf_get_module_param(struct device *dev,\n\t\t\t\t\t       enum brcmf_bus_type bus_type,\n\t\t\t\t\t       u32 chip, u32 chiprev)\n{\n\tstruct brcmf_mp_device *settings;\n\tstruct brcmfmac_pd_device *device_pd;\n\tbool found;\n\tint i;\n\n\tbrcmf_dbg(INFO, \"Enter, bus=%d, chip=%d, rev=%d\\n\", bus_type, chip,\n\t\t  chiprev);\n\tsettings = kzalloc(sizeof(*settings), GFP_ATOMIC);\n\tif (!settings)\n\t\treturn NULL;\n\n\t \n\tsettings->p2p_enable = !!brcmf_p2p_enable;\n\tsettings->feature_disable = brcmf_feature_disable;\n\tsettings->fcmode = brcmf_fcmode;\n\tsettings->roamoff = !!brcmf_roamoff;\n\tsettings->iapp = !!brcmf_iapp_enable;\n#ifdef DEBUG\n\tsettings->ignore_probe_fail = !!brcmf_ignore_probe_fail;\n#endif\n\n\tif (bus_type == BRCMF_BUSTYPE_SDIO)\n\t\tsettings->bus.sdio.txglomsz = brcmf_sdiod_txglomsz;\n\n\t \n\tfound = false;\n\tif (brcmfmac_pdata) {\n\t\tfor (i = 0; i < brcmfmac_pdata->device_count; i++) {\n\t\t\tdevice_pd = &brcmfmac_pdata->devices[i];\n\t\t\tif ((device_pd->bus_type == bus_type) &&\n\t\t\t    (device_pd->id == chip) &&\n\t\t\t    ((device_pd->rev == chiprev) ||\n\t\t\t     (device_pd->rev == -1))) {\n\t\t\t\tbrcmf_dbg(INFO, \"Platform data for device found\\n\");\n\t\t\t\tsettings->country_codes =\n\t\t\t\t\t\tdevice_pd->country_codes;\n\t\t\t\tif (device_pd->bus_type == BRCMF_BUSTYPE_SDIO)\n\t\t\t\t\tmemcpy(&settings->bus.sdio,\n\t\t\t\t\t       &device_pd->bus.sdio,\n\t\t\t\t\t       sizeof(settings->bus.sdio));\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!found) {\n\t\t \n\t\tbrcmf_dmi_probe(settings, chip, chiprev);\n\t\tbrcmf_of_probe(dev, bus_type, settings);\n\t\tbrcmf_acpi_probe(dev, bus_type, settings);\n\t}\n\treturn settings;\n}\n\nvoid brcmf_release_module_param(struct brcmf_mp_device *module_param)\n{\n\tkfree(module_param);\n}\n\nstatic int __init brcmf_common_pd_probe(struct platform_device *pdev)\n{\n\tbrcmf_dbg(INFO, \"Enter\\n\");\n\n\tbrcmfmac_pdata = dev_get_platdata(&pdev->dev);\n\n\tif (brcmfmac_pdata->power_on)\n\t\tbrcmfmac_pdata->power_on();\n\n\treturn 0;\n}\n\nstatic int brcmf_common_pd_remove(struct platform_device *pdev)\n{\n\tbrcmf_dbg(INFO, \"Enter\\n\");\n\n\tif (brcmfmac_pdata->power_off)\n\t\tbrcmfmac_pdata->power_off();\n\n\treturn 0;\n}\n\nstatic struct platform_driver brcmf_pd = {\n\t.remove\t\t= brcmf_common_pd_remove,\n\t.driver\t\t= {\n\t\t.name\t= BRCMFMAC_PDATA_NAME,\n\t}\n};\n\nstatic int __init brcmfmac_module_init(void)\n{\n\tint err;\n\n\t \n\terr = platform_driver_probe(&brcmf_pd, brcmf_common_pd_probe);\n\tif (err == -ENODEV)\n\t\tbrcmf_dbg(INFO, \"No platform data available.\\n\");\n\n\t \n\tbrcmf_mp_attach();\n\n\t \n\terr = brcmf_core_init();\n\tif (err) {\n\t\tif (brcmfmac_pdata)\n\t\t\tplatform_driver_unregister(&brcmf_pd);\n\t}\n\n\treturn err;\n}\n\nstatic void __exit brcmfmac_module_exit(void)\n{\n\tbrcmf_core_exit();\n\tif (brcmfmac_pdata)\n\t\tplatform_driver_unregister(&brcmf_pd);\n}\n\nmodule_init(brcmfmac_module_init);\nmodule_exit(brcmfmac_module_exit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}