{
  "module_name": "fwil.c",
  "hash_id": "fe89bf17bb0d3f485fcd0a6119075783a037001e52387d23f81b437e391f0b71",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <brcmu_utils.h>\n#include <brcmu_wifi.h>\n#include \"core.h\"\n#include \"bus.h\"\n#include \"debug.h\"\n#include \"tracepoint.h\"\n#include \"xtlv.h\"\n#include \"fwil.h\"\n#include \"proto.h\"\n\n\n#define MAX_HEX_DUMP_LEN\t64\n\n#ifdef DEBUG\nstatic const char * const brcmf_fil_errstr[] = {\n\t\"BCME_OK\",\n\t\"BCME_ERROR\",\n\t\"BCME_BADARG\",\n\t\"BCME_BADOPTION\",\n\t\"BCME_NOTUP\",\n\t\"BCME_NOTDOWN\",\n\t\"BCME_NOTAP\",\n\t\"BCME_NOTSTA\",\n\t\"BCME_BADKEYIDX\",\n\t\"BCME_RADIOOFF\",\n\t\"BCME_NOTBANDLOCKED\",\n\t\"BCME_NOCLK\",\n\t\"BCME_BADRATESET\",\n\t\"BCME_BADBAND\",\n\t\"BCME_BUFTOOSHORT\",\n\t\"BCME_BUFTOOLONG\",\n\t\"BCME_BUSY\",\n\t\"BCME_NOTASSOCIATED\",\n\t\"BCME_BADSSIDLEN\",\n\t\"BCME_OUTOFRANGECHAN\",\n\t\"BCME_BADCHAN\",\n\t\"BCME_BADADDR\",\n\t\"BCME_NORESOURCE\",\n\t\"BCME_UNSUPPORTED\",\n\t\"BCME_BADLEN\",\n\t\"BCME_NOTREADY\",\n\t\"BCME_EPERM\",\n\t\"BCME_NOMEM\",\n\t\"BCME_ASSOCIATED\",\n\t\"BCME_RANGE\",\n\t\"BCME_NOTFOUND\",\n\t\"BCME_WME_NOT_ENABLED\",\n\t\"BCME_TSPEC_NOTFOUND\",\n\t\"BCME_ACM_NOTSUPPORTED\",\n\t\"BCME_NOT_WME_ASSOCIATION\",\n\t\"BCME_SDIO_ERROR\",\n\t\"BCME_DONGLE_DOWN\",\n\t\"BCME_VERSION\",\n\t\"BCME_TXFAIL\",\n\t\"BCME_RXFAIL\",\n\t\"BCME_NODEVICE\",\n\t\"BCME_NMODE_DISABLED\",\n\t\"BCME_NONRESIDENT\",\n\t\"BCME_SCANREJECT\",\n\t\"BCME_USAGE_ERROR\",\n\t\"BCME_IOCTL_ERROR\",\n\t\"BCME_SERIAL_PORT_ERR\",\n\t\"BCME_DISABLED\",\n\t\"BCME_DECERR\",\n\t\"BCME_ENCERR\",\n\t\"BCME_MICERR\",\n\t\"BCME_REPLAY\",\n\t\"BCME_IE_NOTFOUND\",\n};\n\nstatic const char *brcmf_fil_get_errstr(u32 err)\n{\n\tif (err >= ARRAY_SIZE(brcmf_fil_errstr))\n\t\treturn \"(unknown)\";\n\n\treturn brcmf_fil_errstr[err];\n}\n#else\nstatic const char *brcmf_fil_get_errstr(u32 err)\n{\n\treturn \"\";\n}\n#endif  \n\nstatic s32\nbrcmf_fil_cmd_data(struct brcmf_if *ifp, u32 cmd, void *data, u32 len, bool set)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\ts32 err, fwerr;\n\n\tif (drvr->bus_if->state != BRCMF_BUS_UP) {\n\t\tbphy_err(drvr, \"bus is down. we have nothing to do.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (data != NULL)\n\t\tlen = min_t(uint, len, BRCMF_DCMD_MAXLEN);\n\tif (set)\n\t\terr = brcmf_proto_set_dcmd(drvr, ifp->ifidx, cmd,\n\t\t\t\t\t   data, len, &fwerr);\n\telse\n\t\terr = brcmf_proto_query_dcmd(drvr, ifp->ifidx, cmd,\n\t\t\t\t\t     data, len, &fwerr);\n\n\tif (err) {\n\t\tbrcmf_dbg(FIL, \"Failed: error=%d\\n\", err);\n\t} else if (fwerr < 0) {\n\t\tbrcmf_dbg(FIL, \"Firmware error: %s (%d)\\n\",\n\t\t\t  brcmf_fil_get_errstr((u32)(-fwerr)), fwerr);\n\t\terr = -EBADE;\n\t}\n\tif (ifp->fwil_fwerr)\n\t\treturn fwerr;\n\n\treturn err;\n}\n\ns32\nbrcmf_fil_cmd_data_set(struct brcmf_if *ifp, u32 cmd, void *data, u32 len)\n{\n\ts32 err;\n\n\tmutex_lock(&ifp->drvr->proto_block);\n\n\tbrcmf_dbg(FIL, \"ifidx=%d, cmd=%d, len=%d\\n\", ifp->ifidx, cmd, len);\n\tbrcmf_dbg_hex_dump(BRCMF_FIL_ON(), data,\n\t\t\t   min_t(uint, len, MAX_HEX_DUMP_LEN), \"data\\n\");\n\n\terr = brcmf_fil_cmd_data(ifp, cmd, data, len, true);\n\tmutex_unlock(&ifp->drvr->proto_block);\n\n\treturn err;\n}\n\ns32\nbrcmf_fil_cmd_data_get(struct brcmf_if *ifp, u32 cmd, void *data, u32 len)\n{\n\ts32 err;\n\n\tmutex_lock(&ifp->drvr->proto_block);\n\terr = brcmf_fil_cmd_data(ifp, cmd, data, len, false);\n\n\tbrcmf_dbg(FIL, \"ifidx=%d, cmd=%d, len=%d, err=%d\\n\", ifp->ifidx, cmd,\n\t\t  len, err);\n\tbrcmf_dbg_hex_dump(BRCMF_FIL_ON(), data,\n\t\t\t   min_t(uint, len, MAX_HEX_DUMP_LEN), \"data\\n\");\n\n\tmutex_unlock(&ifp->drvr->proto_block);\n\n\treturn err;\n}\n\n\ns32\nbrcmf_fil_cmd_int_set(struct brcmf_if *ifp, u32 cmd, u32 data)\n{\n\ts32 err;\n\t__le32 data_le = cpu_to_le32(data);\n\n\tmutex_lock(&ifp->drvr->proto_block);\n\tbrcmf_dbg(FIL, \"ifidx=%d, cmd=%d, value=%d\\n\", ifp->ifidx, cmd, data);\n\terr = brcmf_fil_cmd_data(ifp, cmd, &data_le, sizeof(data_le), true);\n\tmutex_unlock(&ifp->drvr->proto_block);\n\n\treturn err;\n}\n\ns32\nbrcmf_fil_cmd_int_get(struct brcmf_if *ifp, u32 cmd, u32 *data)\n{\n\ts32 err;\n\t__le32 data_le = cpu_to_le32(*data);\n\n\tmutex_lock(&ifp->drvr->proto_block);\n\terr = brcmf_fil_cmd_data(ifp, cmd, &data_le, sizeof(data_le), false);\n\tmutex_unlock(&ifp->drvr->proto_block);\n\t*data = le32_to_cpu(data_le);\n\tbrcmf_dbg(FIL, \"ifidx=%d, cmd=%d, value=%d\\n\", ifp->ifidx, cmd, *data);\n\n\treturn err;\n}\n\nstatic u32\nbrcmf_create_iovar(const char *name, const char *data, u32 datalen,\n\t\t   char *buf, u32 buflen)\n{\n\tu32 len;\n\n\tlen = strlen(name) + 1;\n\n\tif ((len + datalen) > buflen)\n\t\treturn 0;\n\n\tmemcpy(buf, name, len);\n\n\t \n\tif (data && datalen)\n\t\tmemcpy(&buf[len], data, datalen);\n\n\treturn len + datalen;\n}\n\n\ns32\nbrcmf_fil_iovar_data_set(struct brcmf_if *ifp, const char *name, const void *data,\n\t\t\t u32 len)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\ts32 err;\n\tu32 buflen;\n\n\tmutex_lock(&drvr->proto_block);\n\n\tbrcmf_dbg(FIL, \"ifidx=%d, name=%s, len=%d\\n\", ifp->ifidx, name, len);\n\tbrcmf_dbg_hex_dump(BRCMF_FIL_ON(), data,\n\t\t\t   min_t(uint, len, MAX_HEX_DUMP_LEN), \"data\\n\");\n\n\tbuflen = brcmf_create_iovar(name, data, len, drvr->proto_buf,\n\t\t\t\t    sizeof(drvr->proto_buf));\n\tif (buflen) {\n\t\terr = brcmf_fil_cmd_data(ifp, BRCMF_C_SET_VAR, drvr->proto_buf,\n\t\t\t\t\t buflen, true);\n\t} else {\n\t\terr = -EPERM;\n\t\tbphy_err(drvr, \"Creating iovar failed\\n\");\n\t}\n\n\tmutex_unlock(&drvr->proto_block);\n\treturn err;\n}\n\ns32\nbrcmf_fil_iovar_data_get(struct brcmf_if *ifp, const char *name, void *data,\n\t\t\t u32 len)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\ts32 err;\n\tu32 buflen;\n\n\tmutex_lock(&drvr->proto_block);\n\n\tbuflen = brcmf_create_iovar(name, data, len, drvr->proto_buf,\n\t\t\t\t    sizeof(drvr->proto_buf));\n\tif (buflen) {\n\t\terr = brcmf_fil_cmd_data(ifp, BRCMF_C_GET_VAR, drvr->proto_buf,\n\t\t\t\t\t buflen, false);\n\t\tif (err == 0)\n\t\t\tmemcpy(data, drvr->proto_buf, len);\n\t} else {\n\t\terr = -EPERM;\n\t\tbphy_err(drvr, \"Creating iovar failed\\n\");\n\t}\n\n\tbrcmf_dbg(FIL, \"ifidx=%d, name=%s, len=%d, err=%d\\n\", ifp->ifidx, name,\n\t\t  len, err);\n\tbrcmf_dbg_hex_dump(BRCMF_FIL_ON(), data,\n\t\t\t   min_t(uint, len, MAX_HEX_DUMP_LEN), \"data\\n\");\n\n\tmutex_unlock(&drvr->proto_block);\n\treturn err;\n}\n\ns32\nbrcmf_fil_iovar_int_set(struct brcmf_if *ifp, const char *name, u32 data)\n{\n\t__le32 data_le = cpu_to_le32(data);\n\n\treturn brcmf_fil_iovar_data_set(ifp, name, &data_le, sizeof(data_le));\n}\n\ns32\nbrcmf_fil_iovar_int_get(struct brcmf_if *ifp, const char *name, u32 *data)\n{\n\t__le32 data_le = cpu_to_le32(*data);\n\ts32 err;\n\n\terr = brcmf_fil_iovar_data_get(ifp, name, &data_le, sizeof(data_le));\n\tif (err == 0)\n\t\t*data = le32_to_cpu(data_le);\n\treturn err;\n}\n\nstatic u32\nbrcmf_create_bsscfg(s32 bsscfgidx, const char *name, char *data, u32 datalen,\n\t\t    char *buf, u32 buflen)\n{\n\tconst s8 *prefix = \"bsscfg:\";\n\ts8 *p;\n\tu32 prefixlen;\n\tu32 namelen;\n\tu32 iolen;\n\t__le32 bsscfgidx_le;\n\n\tif (bsscfgidx == 0)\n\t\treturn brcmf_create_iovar(name, data, datalen, buf, buflen);\n\n\tprefixlen = strlen(prefix);\n\tnamelen = strlen(name) + 1;  \n\tiolen = prefixlen + namelen + sizeof(bsscfgidx_le) + datalen;\n\n\tif (buflen < iolen) {\n\t\tbrcmf_err(\"buffer is too short\\n\");\n\t\treturn 0;\n\t}\n\n\tp = buf;\n\n\t \n\tmemcpy(p, prefix, prefixlen);\n\tp += prefixlen;\n\n\t \n\tmemcpy(p, name, namelen);\n\tp += namelen;\n\n\t \n\tbsscfgidx_le = cpu_to_le32(bsscfgidx);\n\tmemcpy(p, &bsscfgidx_le, sizeof(bsscfgidx_le));\n\tp += sizeof(bsscfgidx_le);\n\n\t \n\tif (datalen)\n\t\tmemcpy(p, data, datalen);\n\n\treturn iolen;\n}\n\ns32\nbrcmf_fil_bsscfg_data_set(struct brcmf_if *ifp, const char *name,\n\t\t\t  void *data, u32 len)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\ts32 err;\n\tu32 buflen;\n\n\tmutex_lock(&drvr->proto_block);\n\n\tbrcmf_dbg(FIL, \"ifidx=%d, bsscfgidx=%d, name=%s, len=%d\\n\", ifp->ifidx,\n\t\t  ifp->bsscfgidx, name, len);\n\tbrcmf_dbg_hex_dump(BRCMF_FIL_ON(), data,\n\t\t\t   min_t(uint, len, MAX_HEX_DUMP_LEN), \"data\\n\");\n\n\tbuflen = brcmf_create_bsscfg(ifp->bsscfgidx, name, data, len,\n\t\t\t\t     drvr->proto_buf, sizeof(drvr->proto_buf));\n\tif (buflen) {\n\t\terr = brcmf_fil_cmd_data(ifp, BRCMF_C_SET_VAR, drvr->proto_buf,\n\t\t\t\t\t buflen, true);\n\t} else {\n\t\terr = -EPERM;\n\t\tbphy_err(drvr, \"Creating bsscfg failed\\n\");\n\t}\n\n\tmutex_unlock(&drvr->proto_block);\n\treturn err;\n}\n\ns32\nbrcmf_fil_bsscfg_data_get(struct brcmf_if *ifp, const char *name,\n\t\t\t  void *data, u32 len)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\ts32 err;\n\tu32 buflen;\n\n\tmutex_lock(&drvr->proto_block);\n\n\tbuflen = brcmf_create_bsscfg(ifp->bsscfgidx, name, data, len,\n\t\t\t\t     drvr->proto_buf, sizeof(drvr->proto_buf));\n\tif (buflen) {\n\t\terr = brcmf_fil_cmd_data(ifp, BRCMF_C_GET_VAR, drvr->proto_buf,\n\t\t\t\t\t buflen, false);\n\t\tif (err == 0)\n\t\t\tmemcpy(data, drvr->proto_buf, len);\n\t} else {\n\t\terr = -EPERM;\n\t\tbphy_err(drvr, \"Creating bsscfg failed\\n\");\n\t}\n\tbrcmf_dbg(FIL, \"ifidx=%d, bsscfgidx=%d, name=%s, len=%d, err=%d\\n\",\n\t\t  ifp->ifidx, ifp->bsscfgidx, name, len, err);\n\tbrcmf_dbg_hex_dump(BRCMF_FIL_ON(), data,\n\t\t\t   min_t(uint, len, MAX_HEX_DUMP_LEN), \"data\\n\");\n\n\tmutex_unlock(&drvr->proto_block);\n\treturn err;\n}\n\ns32\nbrcmf_fil_bsscfg_int_set(struct brcmf_if *ifp, const char *name, u32 data)\n{\n\t__le32 data_le = cpu_to_le32(data);\n\n\treturn brcmf_fil_bsscfg_data_set(ifp, name, &data_le,\n\t\t\t\t\t sizeof(data_le));\n}\n\ns32\nbrcmf_fil_bsscfg_int_get(struct brcmf_if *ifp, const char *name, u32 *data)\n{\n\t__le32 data_le = cpu_to_le32(*data);\n\ts32 err;\n\n\terr = brcmf_fil_bsscfg_data_get(ifp, name, &data_le,\n\t\t\t\t\tsizeof(data_le));\n\tif (err == 0)\n\t\t*data = le32_to_cpu(data_le);\n\treturn err;\n}\n\nstatic u32 brcmf_create_xtlv(const char *name, u16 id, char *data, u32 len,\n\t\t\t     char *buf, u32 buflen)\n{\n\tu32 iolen;\n\tu32 nmlen;\n\n\tnmlen = strlen(name) + 1;\n\tiolen = nmlen + brcmf_xtlv_data_size(len, BRCMF_XTLV_OPTION_ALIGN32);\n\n\tif (iolen > buflen) {\n\t\tbrcmf_err(\"buffer is too short\\n\");\n\t\treturn 0;\n\t}\n\n\tmemcpy(buf, name, nmlen);\n\tbrcmf_xtlv_pack_header((void *)(buf + nmlen), id, len, data,\n\t\t\t       BRCMF_XTLV_OPTION_ALIGN32);\n\n\treturn iolen;\n}\n\ns32 brcmf_fil_xtlv_data_set(struct brcmf_if *ifp, const char *name, u16 id,\n\t\t\t    void *data, u32 len)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\ts32 err;\n\tu32 buflen;\n\n\tmutex_lock(&drvr->proto_block);\n\n\tbrcmf_dbg(FIL, \"ifidx=%d, name=%s, id=%u, len=%u\\n\", ifp->ifidx, name,\n\t\t  id, len);\n\tbrcmf_dbg_hex_dump(BRCMF_FIL_ON(), data,\n\t\t\t   min_t(uint, len, MAX_HEX_DUMP_LEN), \"data\\n\");\n\n\tbuflen = brcmf_create_xtlv(name, id, data, len,\n\t\t\t\t   drvr->proto_buf, sizeof(drvr->proto_buf));\n\tif (buflen) {\n\t\terr = brcmf_fil_cmd_data(ifp, BRCMF_C_SET_VAR, drvr->proto_buf,\n\t\t\t\t\t buflen, true);\n\t} else {\n\t\terr = -EPERM;\n\t\tbphy_err(drvr, \"Creating xtlv failed\\n\");\n\t}\n\n\tmutex_unlock(&drvr->proto_block);\n\treturn err;\n}\n\ns32 brcmf_fil_xtlv_data_get(struct brcmf_if *ifp, const char *name, u16 id,\n\t\t\t    void *data, u32 len)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\ts32 err;\n\tu32 buflen;\n\n\tmutex_lock(&drvr->proto_block);\n\n\tbuflen = brcmf_create_xtlv(name, id, data, len,\n\t\t\t\t   drvr->proto_buf, sizeof(drvr->proto_buf));\n\tif (buflen) {\n\t\terr = brcmf_fil_cmd_data(ifp, BRCMF_C_GET_VAR, drvr->proto_buf,\n\t\t\t\t\t buflen, false);\n\t\tif (err == 0)\n\t\t\tmemcpy(data, drvr->proto_buf, len);\n\t} else {\n\t\terr = -EPERM;\n\t\tbphy_err(drvr, \"Creating bsscfg failed\\n\");\n\t}\n\tbrcmf_dbg(FIL, \"ifidx=%d, name=%s, id=%u, len=%u, err=%d\\n\",\n\t\t  ifp->ifidx, name, id, len, err);\n\tbrcmf_dbg_hex_dump(BRCMF_FIL_ON(), data,\n\t\t\t   min_t(uint, len, MAX_HEX_DUMP_LEN), \"data\\n\");\n\n\tmutex_unlock(&drvr->proto_block);\n\treturn err;\n}\n\ns32 brcmf_fil_xtlv_int_set(struct brcmf_if *ifp, const char *name, u16 id, u32 data)\n{\n\t__le32 data_le = cpu_to_le32(data);\n\n\treturn brcmf_fil_xtlv_data_set(ifp, name, id, &data_le,\n\t\t\t\t\t sizeof(data_le));\n}\n\ns32 brcmf_fil_xtlv_int_get(struct brcmf_if *ifp, const char *name, u16 id, u32 *data)\n{\n\t__le32 data_le = cpu_to_le32(*data);\n\ts32 err;\n\n\terr = brcmf_fil_xtlv_data_get(ifp, name, id, &data_le, sizeof(data_le));\n\tif (err == 0)\n\t\t*data = le32_to_cpu(data_le);\n\treturn err;\n}\n\ns32 brcmf_fil_xtlv_int8_get(struct brcmf_if *ifp, const char *name, u16 id, u8 *data)\n{\n\treturn brcmf_fil_xtlv_data_get(ifp, name, id, data, sizeof(*data));\n}\n\ns32 brcmf_fil_xtlv_int16_get(struct brcmf_if *ifp, const char *name, u16 id, u16 *data)\n{\n\t__le16 data_le = cpu_to_le16(*data);\n\ts32 err;\n\n\terr = brcmf_fil_xtlv_data_get(ifp, name, id, &data_le, sizeof(data_le));\n\tif (err == 0)\n\t\t*data = le16_to_cpu(data_le);\n\treturn err;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}