{
  "module_name": "sdio.c",
  "hash_id": "f2c5ac680eb51bf6ffb9a8d86b12a78e19caf89f327adb5b73c7e1440daee995",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/printk.h>\n#include <linux/pci_ids.h>\n#include <linux/netdevice.h>\n#include <linux/interrupt.h>\n#include <linux/sched/signal.h>\n#include <linux/mmc/sdio.h>\n#include <linux/mmc/sdio_ids.h>\n#include <linux/mmc/sdio_func.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/core.h>\n#include <linux/semaphore.h>\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/bcma/bcma.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <asm/unaligned.h>\n#include <defs.h>\n#include <brcmu_wifi.h>\n#include <brcmu_utils.h>\n#include <brcm_hw_ids.h>\n#include <soc.h>\n#include \"sdio.h\"\n#include \"chip.h\"\n#include \"firmware.h\"\n#include \"core.h\"\n#include \"common.h\"\n#include \"bcdc.h\"\n\n#define DCMD_RESP_TIMEOUT\tmsecs_to_jiffies(2500)\n#define CTL_DONE_TIMEOUT\tmsecs_to_jiffies(2500)\n\n \n#define DEFAULT_F2_WATERMARK    0x8\n#define CY_4373_F2_WATERMARK    0x40\n#define CY_4373_F1_MESBUSYCTRL  (CY_4373_F2_WATERMARK | SBSDIO_MESBUSYCTRL_ENAB)\n#define CY_43012_F2_WATERMARK    0x60\n#define CY_43012_MES_WATERMARK  0x50\n#define CY_43012_MESBUSYCTRL    (CY_43012_MES_WATERMARK | \\\n\t\t\t\t SBSDIO_MESBUSYCTRL_ENAB)\n#define CY_4339_F2_WATERMARK    48\n#define CY_4339_MES_WATERMARK\t80\n#define CY_4339_MESBUSYCTRL\t(CY_4339_MES_WATERMARK | \\\n\t\t\t\t SBSDIO_MESBUSYCTRL_ENAB)\n#define CY_43455_F2_WATERMARK\t0x60\n#define CY_43455_MES_WATERMARK\t0x50\n#define CY_43455_MESBUSYCTRL\t(CY_43455_MES_WATERMARK | \\\n\t\t\t\t SBSDIO_MESBUSYCTRL_ENAB)\n#define CY_435X_F2_WATERMARK\t0x40\n#define CY_435X_F1_MESBUSYCTRL\t(CY_435X_F2_WATERMARK | \\\n\t\t\t\t SBSDIO_MESBUSYCTRL_ENAB)\n\n#ifdef DEBUG\n\n#define BRCMF_TRAP_INFO_SIZE\t80\n\n#define CBUF_LEN\t(128)\n\n \n#define CONSOLE_BUFFER_MAX\t2024\n\nstruct rte_log_le {\n\t__le32 buf;\t\t \n\t__le32 buf_size;\n\t__le32 idx;\n\tchar *_buf_compat;\t \n};\n\nstruct rte_console {\n\t \n\tuint vcons_in;\n\tuint vcons_out;\n\n\t \n\tstruct rte_log_le log_le;\n\n\t \n\tuint cbuf_idx;\n\tchar cbuf[CBUF_LEN];\n};\n\n#endif\t\t\t\t \n#include <chipcommon.h>\n\n#include \"bus.h\"\n#include \"debug.h\"\n#include \"tracepoint.h\"\n\n#define TXQLEN\t\t2048\t \n#define TXHI\t\t(TXQLEN - 256)\t \n#define TXLOW\t\t(TXHI - 256)\t \n#define PRIOMASK\t7\n\n#define TXRETRIES\t2\t \n\n#define BRCMF_RXBOUND\t50\t \n\n#define BRCMF_TXBOUND\t20\t \n\n#define BRCMF_TXMINMAX\t1\t \n\n#define MEMBLOCK\t2048\t \n#define MAX_DATA_BUF\t(32 * 1024)\t \n\n#define BRCMF_FIRSTREAD\t(1 << 6)\n\n \n\n \n#define SBSDIO_DEVCTL_SETBUSY\t\t0x01\n \n#define SBSDIO_DEVCTL_SPI_INTR_SYNC\t0x02\n \n#define SBSDIO_DEVCTL_CA_INT_ONLY\t0x04\n \n#define SBSDIO_DEVCTL_PADS_ISO\t\t0x08\n \n#define SBSDIO_DEVCTL_F2WM_ENAB\t\t0x10\n \n#define SBSDIO_DEVCTL_SB_RST_CTL\t0x30\n \n#define SBSDIO_DEVCTL_RST_CORECTL\t0x00\n \n#define SBSDIO_DEVCTL_RST_BPRESET\t0x10\n \n#define SBSDIO_DEVCTL_RST_NOBPRESET\t0x20\n\n \n\n \n#define SBSDIO_CIS_BASE_COMMON\t\t0x1000\n \n#define SBSDIO_CIS_SIZE_LIMIT\t\t0x200\n \n#define SBSDIO_CIS_OFT_ADDR_MASK\t0x1FFFF\n\n \n#define SBSDIO_CIS_MANFID_TUPLE_LEN\t6\n\n#define SD_REG(field) \\\n\t\t(offsetof(struct sdpcmd_regs, field))\n\n \n \n#define SBSDIO_FORCE_ALP\t\t0x01\n \n#define SBSDIO_FORCE_HT\t\t\t0x02\n \n#define SBSDIO_FORCE_ILP\t\t0x04\n \n#define SBSDIO_ALP_AVAIL_REQ\t\t0x08\n \n#define SBSDIO_HT_AVAIL_REQ\t\t0x10\n \n#define SBSDIO_FORCE_HW_CLKREQ_OFF\t0x20\n \n#define SBSDIO_ALP_AVAIL\t\t0x40\n \n#define SBSDIO_HT_AVAIL\t\t\t0x80\n#define SBSDIO_CSR_MASK\t\t\t0x1F\n#define SBSDIO_AVBITS\t\t(SBSDIO_HT_AVAIL | SBSDIO_ALP_AVAIL)\n#define SBSDIO_ALPAV(regval)\t((regval) & SBSDIO_AVBITS)\n#define SBSDIO_HTAV(regval)\t(((regval) & SBSDIO_AVBITS) == SBSDIO_AVBITS)\n#define SBSDIO_ALPONLY(regval)\t(SBSDIO_ALPAV(regval) && !SBSDIO_HTAV(regval))\n#define SBSDIO_CLKAV(regval, alponly) \\\n\t(SBSDIO_ALPAV(regval) && (alponly ? 1 : SBSDIO_HTAV(regval)))\n\n \n#define I_SMB_SW0\t(1 << 0)\t \n#define I_SMB_SW1\t(1 << 1)\t \n#define I_SMB_SW2\t(1 << 2)\t \n#define I_SMB_SW3\t(1 << 3)\t \n#define I_SMB_SW_MASK\t0x0000000f\t \n#define I_SMB_SW_SHIFT\t0\t \n#define I_HMB_SW0\t(1 << 4)\t \n#define I_HMB_SW1\t(1 << 5)\t \n#define I_HMB_SW2\t(1 << 6)\t \n#define I_HMB_SW3\t(1 << 7)\t \n#define I_HMB_SW_MASK\t0x000000f0\t \n#define I_HMB_SW_SHIFT\t4\t \n#define I_WR_OOSYNC\t(1 << 8)\t \n#define I_RD_OOSYNC\t(1 << 9)\t \n#define\tI_PC\t\t(1 << 10)\t \n#define\tI_PD\t\t(1 << 11)\t \n#define\tI_DE\t\t(1 << 12)\t \n#define\tI_RU\t\t(1 << 13)\t \n#define\tI_RO\t\t(1 << 14)\t \n#define\tI_XU\t\t(1 << 15)\t \n#define\tI_RI\t\t(1 << 16)\t \n#define I_BUSPWR\t(1 << 17)\t \n#define I_XMTDATA_AVAIL (1 << 23)\t \n#define\tI_XI\t\t(1 << 24)\t \n#define I_RF_TERM\t(1 << 25)\t \n#define I_WF_TERM\t(1 << 26)\t \n#define I_PCMCIA_XU\t(1 << 27)\t \n#define I_SBINT\t\t(1 << 28)\t \n#define I_CHIPACTIVE\t(1 << 29)\t \n#define I_SRESET\t(1 << 30)\t \n#define I_IOE2\t\t(1U << 31)\t \n#define\tI_ERRORS\t(I_PC | I_PD | I_DE | I_RU | I_RO | I_XU)\n#define I_DMA\t\t(I_RI | I_XI | I_ERRORS)\n\n \n#define CC_CISRDY\t\t(1 << 0)\t \n#define CC_BPRESEN\t\t(1 << 1)\t \n#define CC_F2RDY\t\t(1 << 2)\t \n#define CC_CLRPADSISO\t\t(1 << 3)\t \n#define CC_XMTDATAAVAIL_MODE\t(1 << 4)\n#define CC_XMTDATAAVAIL_CTRL\t(1 << 5)\n\n \n#define SFC_RF_TERM\t(1 << 0)\t \n#define SFC_WF_TERM\t(1 << 1)\t \n#define SFC_CRC4WOOS\t(1 << 2)\t \n#define SFC_ABORTALL\t(1 << 3)\t \n\n \n\n \n#define SMB_NAK\t\t(1 << 0)\t \n#define SMB_INT_ACK\t(1 << 1)\t \n#define SMB_USE_OOB\t(1 << 2)\t \n#define SMB_DEV_INT\t(1 << 3)\t \n\n \n#define SMB_DATA_VERSION_SHIFT\t16\t \n\n \n\n \n#define I_HMB_FC_STATE\tI_HMB_SW0\t \n#define I_HMB_FC_CHANGE\tI_HMB_SW1\t \n#define I_HMB_FRAME_IND\tI_HMB_SW2\t \n#define I_HMB_HOST_INT\tI_HMB_SW3\t \n\n \n#define HMB_DATA_NAKHANDLED\t0x0001\t \n#define HMB_DATA_DEVREADY\t0x0002\t \n#define HMB_DATA_FC\t\t0x0004\t \n#define HMB_DATA_FWREADY\t0x0008\t \n#define HMB_DATA_FWHALT\t\t0x0010\t \n\n#define HMB_DATA_FCDATA_MASK\t0xff000000\n#define HMB_DATA_FCDATA_SHIFT\t24\n\n#define HMB_DATA_VERSION_MASK\t0x00ff0000\n#define HMB_DATA_VERSION_SHIFT\t16\n\n \n\n \n#define SDPCM_PROT_VERSION\t4\n\n \n#define SDPCM_SHARED_VERSION       0x0003\n#define SDPCM_SHARED_VERSION_MASK  0x00FF\n#define SDPCM_SHARED_ASSERT_BUILT  0x0100\n#define SDPCM_SHARED_ASSERT        0x0200\n#define SDPCM_SHARED_TRAP          0x0400\n\n \n#define MAX_HDR_READ\t(1 << 6)\n#define MAX_RX_DATASZ\t2048\n\n \n#undef PMU_MAX_TRANSITION_DLY\n#define PMU_MAX_TRANSITION_DLY 1000000\n\n \n#define BRCMF_INIT_CLKCTL1\t(SBSDIO_FORCE_HW_CLKREQ_OFF |\t\\\n\t\t\t\t\tSBSDIO_ALP_AVAIL_REQ)\n\n \n#define F2SYNC\t(SDIO_REQ_4BYTE | SDIO_REQ_FIXED)\n\n#define BRCMF_IDLE_ACTIVE\t0\t \n#define BRCMF_IDLE_INTERVAL\t1\n\n#define KSO_WAIT_US 50\n#define MAX_KSO_ATTEMPTS (PMU_MAX_TRANSITION_DLY/KSO_WAIT_US)\n#define BRCMF_SDIO_MAX_ACCESS_ERRORS\t5\n\n#ifdef DEBUG\n \nstruct brcmf_console {\n\tuint count;\t\t \n\tuint log_addr;\t\t \n\tstruct rte_log_le log_le;\t \n\tuint bufsize;\t\t \n\tu8 *buf;\t\t \n\tuint last;\t\t \n};\n\nstruct brcmf_trap_info {\n\t__le32\t\ttype;\n\t__le32\t\tepc;\n\t__le32\t\tcpsr;\n\t__le32\t\tspsr;\n\t__le32\t\tr0;\t \n\t__le32\t\tr1;\t \n\t__le32\t\tr2;\t \n\t__le32\t\tr3;\t \n\t__le32\t\tr4;\t \n\t__le32\t\tr5;\t \n\t__le32\t\tr6;\t \n\t__le32\t\tr7;\t \n\t__le32\t\tr8;\t \n\t__le32\t\tr9;\t \n\t__le32\t\tr10;\t \n\t__le32\t\tr11;\t \n\t__le32\t\tr12;\t \n\t__le32\t\tr13;\t \n\t__le32\t\tr14;\t \n\t__le32\t\tpc;\t \n};\n#endif\t\t\t\t \n\nstruct sdpcm_shared {\n\tu32 flags;\n\tu32 trap_addr;\n\tu32 assert_exp_addr;\n\tu32 assert_file_addr;\n\tu32 assert_line;\n\tu32 console_addr;\t \n\tu32 msgtrace_addr;\n\tu8 tag[32];\n\tu32 brpt_addr;\n};\n\nstruct sdpcm_shared_le {\n\t__le32 flags;\n\t__le32 trap_addr;\n\t__le32 assert_exp_addr;\n\t__le32 assert_file_addr;\n\t__le32 assert_line;\n\t__le32 console_addr;\t \n\t__le32 msgtrace_addr;\n\tu8 tag[32];\n\t__le32 brpt_addr;\n};\n\n \nstruct brcmf_sdio_hdrinfo {\n\tu8 seq_num;\n\tu8 channel;\n\tu16 len;\n\tu16 len_left;\n\tu16 len_nxtfrm;\n\tu8 dat_offset;\n\tbool lastfrm;\n\tu16 tail_pad;\n};\n\n \nstruct brcmf_sdio_count {\n\tuint intrcount;\t\t \n\tuint lastintrs;\t\t \n\tuint pollcnt;\t\t \n\tuint regfails;\t\t \n\tuint tx_sderrs;\t\t \n\tuint fcqueued;\t\t \n\tuint rxrtx;\t\t \n\tuint rx_toolong;\t \n\tuint rxc_errors;\t \n\tuint rx_hdrfail;\t \n\tuint rx_badhdr;\t\t \n\tuint rx_badseq;\t\t \n\tuint fc_rcvd;\t\t \n\tuint fc_xoff;\t\t \n\tuint fc_xon;\t\t \n\tuint rxglomfail;\t \n\tuint rxglomframes;\t \n\tuint rxglompkts;\t \n\tuint f2rxhdrs;\t\t \n\tuint f2rxdata;\t\t \n\tuint f2txdata;\t\t \n\tuint f1regdata;\t\t \n\tuint tickcnt;\t\t \n\tulong tx_ctlerrs;\t \n\tulong tx_ctlpkts;\t \n\tulong rx_ctlerrs;\t \n\tulong rx_ctlpkts;\t \n\tulong rx_readahead_cnt;\t \n};\n\n \n \nstruct brcmf_sdio {\n\tstruct brcmf_sdio_dev *sdiodev;\t \n\tstruct brcmf_chip *ci;\t \n\tstruct brcmf_core *sdio_core;  \n\n\tu32 hostintmask;\t \n\tatomic_t intstatus;\t \n\tatomic_t fcstate;\t \n\n\tuint blocksize;\t\t \n\tuint roundup;\t\t \n\n\tstruct pktq txq;\t \n\tu8 flowcontrol;\t \n\tu8 tx_seq;\t\t \n\tu8 tx_max;\t\t \n\n\tu8 *hdrbuf;\t\t \n\tu8 *rxhdr;\t\t \n\tu8 rx_seq;\t\t \n\tstruct brcmf_sdio_hdrinfo cur_read;\n\t\t\t\t \n\tbool rxskip;\t\t \n\tbool rxpending;\t\t \n\n\tuint rxbound;\t\t \n\tuint txbound;\t\t \n\tuint txminmax;\n\n\tstruct sk_buff *glomd;\t \n\tstruct sk_buff_head glom;  \n\n\tu8 *rxbuf;\t\t \n\tuint rxblen;\t\t \n\tu8 *rxctl;\t\t \n\tu8 *rxctl_orig;\t\t \n\tuint rxlen;\t\t \n\tspinlock_t rxctl_lock;\t \n\n\tu8 sdpcm_ver;\t \n\n\tbool intr;\t\t \n\tbool poll;\t\t \n\tatomic_t ipend;\t\t \n\tuint spurious;\t\t \n\tuint pollrate;\t\t \n\tuint polltick;\t\t \n\n#ifdef DEBUG\n\tuint console_interval;\n\tstruct brcmf_console console;\t \n\tuint console_addr;\t \n#endif\t\t\t\t \n\n\tuint clkstate;\t\t \n\ts32 idletime;\t\t \n\ts32 idlecount;\t\t \n\ts32 idleclock;\t\t \n\tbool rxflow_mode;\t \n\tbool rxflow;\t\t \n\tbool alp_only;\t\t \n\n\tu8 *ctrl_frame_buf;\n\tu16 ctrl_frame_len;\n\tbool ctrl_frame_stat;\n\tint ctrl_frame_err;\n\n\tspinlock_t txq_lock;\t\t \n\twait_queue_head_t ctrl_wait;\n\twait_queue_head_t dcmd_resp_wait;\n\n\tstruct timer_list timer;\n\tstruct completion watchdog_wait;\n\tstruct task_struct *watchdog_tsk;\n\tbool wd_active;\n\n\tstruct workqueue_struct *brcmf_wq;\n\tstruct work_struct datawork;\n\tbool dpc_triggered;\n\tbool dpc_running;\n\n\tbool txoff;\t\t \n\tstruct brcmf_sdio_count sdcnt;\n\tbool sr_enabled;  \n\tbool sleeping;\n\n\tu8 tx_hdrlen;\t\t \n\tbool txglom;\t\t \n\tu16 head_align;\t\t \n\tu16 sgentry_align;\t \n};\n\n \n#define CLK_NONE\t0\n#define CLK_SDONLY\t1\n#define CLK_PENDING\t2\n#define CLK_AVAIL\t3\n\n#ifdef DEBUG\nstatic int qcount[NUMPRIO];\n#endif\t\t\t\t \n\n#define DEFAULT_SDIO_DRIVE_STRENGTH\t6\t \n\n#define RETRYCHAN(chan) ((chan) == SDPCM_EVENT_CHANNEL)\n\n \nstatic const uint max_roundup = 512;\n\n#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT\n#define ALIGNMENT  8\n#else\n#define ALIGNMENT  4\n#endif\n\nenum brcmf_sdio_frmtype {\n\tBRCMF_SDIO_FT_NORMAL,\n\tBRCMF_SDIO_FT_SUPER,\n\tBRCMF_SDIO_FT_SUB,\n};\n\n#define SDIOD_DRVSTR_KEY(chip, pmu)     (((unsigned int)(chip) << 16) | (pmu))\n\n \nstruct sdiod_drive_str {\n\tu8 strength;\t \n\tu8 sel;\t\t \n};\n\n \nstatic const struct sdiod_drive_str sdiod_drvstr_tab1_1v8[] = {\n\t{32, 0x6},\n\t{26, 0x7},\n\t{22, 0x4},\n\t{16, 0x5},\n\t{12, 0x2},\n\t{8, 0x3},\n\t{4, 0x0},\n\t{0, 0x1}\n};\n\n \nstatic const struct sdiod_drive_str sdiod_drive_strength_tab5_1v8[] = {\n\t{6, 0x7},\n\t{5, 0x6},\n\t{4, 0x5},\n\t{3, 0x4},\n\t{2, 0x2},\n\t{1, 0x1},\n\t{0, 0x0}\n};\n\n \nstatic const struct sdiod_drive_str sdiod_drvstr_tab6_1v8[] = {\n\t{3, 0x3},\n\t{2, 0x2},\n\t{1, 0x1},\n\t{0, 0x0} };\n\n \nstatic const struct sdiod_drive_str sdiod_drvstr_tab2_3v3[] = {\n\t{16, 0x7},\n\t{12, 0x5},\n\t{8,  0x3},\n\t{4,  0x1}\n};\n\nBRCMF_FW_DEF(43143, \"brcmfmac43143-sdio\");\nBRCMF_FW_DEF(43241B0, \"brcmfmac43241b0-sdio\");\nBRCMF_FW_DEF(43241B4, \"brcmfmac43241b4-sdio\");\nBRCMF_FW_DEF(43241B5, \"brcmfmac43241b5-sdio\");\nBRCMF_FW_DEF(4329, \"brcmfmac4329-sdio\");\nBRCMF_FW_DEF(4330, \"brcmfmac4330-sdio\");\nBRCMF_FW_DEF(4334, \"brcmfmac4334-sdio\");\nBRCMF_FW_DEF(43340, \"brcmfmac43340-sdio\");\nBRCMF_FW_DEF(4335, \"brcmfmac4335-sdio\");\nBRCMF_FW_DEF(43362, \"brcmfmac43362-sdio\");\nBRCMF_FW_DEF(4339, \"brcmfmac4339-sdio\");\nBRCMF_FW_DEF(43430A0, \"brcmfmac43430a0-sdio\");\n \nBRCMF_FW_CLM_DEF(43430A1, \"brcmfmac43430-sdio\");\nBRCMF_FW_DEF(43430B0, \"brcmfmac43430b0-sdio\");\nBRCMF_FW_CLM_DEF(43439, \"brcmfmac43439-sdio\");\nBRCMF_FW_CLM_DEF(43455, \"brcmfmac43455-sdio\");\nBRCMF_FW_DEF(43456, \"brcmfmac43456-sdio\");\nBRCMF_FW_CLM_DEF(4354, \"brcmfmac4354-sdio\");\nBRCMF_FW_CLM_DEF(4356, \"brcmfmac4356-sdio\");\nBRCMF_FW_DEF(4359, \"brcmfmac4359-sdio\");\nBRCMF_FW_CLM_DEF(4373, \"brcmfmac4373-sdio\");\nBRCMF_FW_CLM_DEF(43012, \"brcmfmac43012-sdio\");\nBRCMF_FW_CLM_DEF(43752, \"brcmfmac43752-sdio\");\n\n \nMODULE_FIRMWARE(BRCMF_FW_DEFAULT_PATH \"brcmfmac*-sdio.*.txt\");\n\n \nMODULE_FIRMWARE(BRCMF_FW_DEFAULT_PATH \"brcmfmac*-sdio.*.bin\");\n\nstatic const struct brcmf_firmware_mapping brcmf_sdio_fwnames[] = {\n\tBRCMF_FW_ENTRY(BRCM_CC_43143_CHIP_ID, 0xFFFFFFFF, 43143),\n\tBRCMF_FW_ENTRY(BRCM_CC_43241_CHIP_ID, 0x0000001F, 43241B0),\n\tBRCMF_FW_ENTRY(BRCM_CC_43241_CHIP_ID, 0x00000020, 43241B4),\n\tBRCMF_FW_ENTRY(BRCM_CC_43241_CHIP_ID, 0xFFFFFFC0, 43241B5),\n\tBRCMF_FW_ENTRY(BRCM_CC_4329_CHIP_ID, 0xFFFFFFFF, 4329),\n\tBRCMF_FW_ENTRY(BRCM_CC_4330_CHIP_ID, 0xFFFFFFFF, 4330),\n\tBRCMF_FW_ENTRY(BRCM_CC_4334_CHIP_ID, 0xFFFFFFFF, 4334),\n\tBRCMF_FW_ENTRY(BRCM_CC_43340_CHIP_ID, 0xFFFFFFFF, 43340),\n\tBRCMF_FW_ENTRY(BRCM_CC_43341_CHIP_ID, 0xFFFFFFFF, 43340),\n\tBRCMF_FW_ENTRY(BRCM_CC_4335_CHIP_ID, 0xFFFFFFFF, 4335),\n\tBRCMF_FW_ENTRY(BRCM_CC_43362_CHIP_ID, 0xFFFFFFFE, 43362),\n\tBRCMF_FW_ENTRY(BRCM_CC_4339_CHIP_ID, 0xFFFFFFFF, 4339),\n\tBRCMF_FW_ENTRY(BRCM_CC_43430_CHIP_ID, 0x00000001, 43430A0),\n\tBRCMF_FW_ENTRY(BRCM_CC_43430_CHIP_ID, 0x00000002, 43430A1),\n\tBRCMF_FW_ENTRY(BRCM_CC_43430_CHIP_ID, 0xFFFFFFFC, 43430B0),\n\tBRCMF_FW_ENTRY(BRCM_CC_4345_CHIP_ID, 0x00000200, 43456),\n\tBRCMF_FW_ENTRY(BRCM_CC_4345_CHIP_ID, 0xFFFFFDC0, 43455),\n\tBRCMF_FW_ENTRY(BRCM_CC_43454_CHIP_ID, 0x00000040, 43455),\n\tBRCMF_FW_ENTRY(BRCM_CC_4354_CHIP_ID, 0xFFFFFFFF, 4354),\n\tBRCMF_FW_ENTRY(BRCM_CC_4356_CHIP_ID, 0xFFFFFFFF, 4356),\n\tBRCMF_FW_ENTRY(BRCM_CC_4359_CHIP_ID, 0xFFFFFFFF, 4359),\n\tBRCMF_FW_ENTRY(CY_CC_4373_CHIP_ID, 0xFFFFFFFF, 4373),\n\tBRCMF_FW_ENTRY(CY_CC_43012_CHIP_ID, 0xFFFFFFFF, 43012),\n\tBRCMF_FW_ENTRY(CY_CC_43439_CHIP_ID, 0xFFFFFFFF, 43439),\n\tBRCMF_FW_ENTRY(CY_CC_43752_CHIP_ID, 0xFFFFFFFF, 43752)\n};\n\n#define TXCTL_CREDITS\t2\n\nstatic void pkt_align(struct sk_buff *p, int len, int align)\n{\n\tuint datalign;\n\tdatalign = (unsigned long)(p->data);\n\tdatalign = roundup(datalign, (align)) - datalign;\n\tif (datalign)\n\t\tskb_pull(p, datalign);\n\t__skb_trim(p, len);\n}\n\n \nstatic bool data_ok(struct brcmf_sdio *bus)\n{\n\tu8 tx_rsv = 0;\n\n\t \n\tif (bus->ctrl_frame_stat)\n\t\ttx_rsv = TXCTL_CREDITS;\n\n\treturn (bus->tx_max - bus->tx_seq - tx_rsv) != 0 &&\n\t       ((bus->tx_max - bus->tx_seq - tx_rsv) & 0x80) == 0;\n\n}\n\n \nstatic bool txctl_ok(struct brcmf_sdio *bus)\n{\n\treturn (bus->tx_max - bus->tx_seq) != 0 &&\n\t       ((bus->tx_max - bus->tx_seq) & 0x80) == 0;\n}\n\nstatic int\nbrcmf_sdio_kso_control(struct brcmf_sdio *bus, bool on)\n{\n\tu8 wr_val = 0, rd_val, cmp_val, bmask;\n\tint err = 0;\n\tint err_cnt = 0;\n\tint try_cnt = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter: on=%d\\n\", on);\n\n\tsdio_retune_crc_disable(bus->sdiodev->func1);\n\n\t \n\tif (on)\n\t\tsdio_retune_hold_now(bus->sdiodev->func1);\n\n\twr_val = (on << SBSDIO_FUNC1_SLEEPCSR_KSO_SHIFT);\n\t \n\tbrcmf_sdiod_writeb(bus->sdiodev, SBSDIO_FUNC1_SLEEPCSR, wr_val, &err);\n\n\t \n\tif (!on && bus->ci->chip == CY_CC_43012_CHIP_ID)\n\t\treturn err;\n\n\tif (on) {\n\t\t \n\t\tcmp_val = SBSDIO_FUNC1_SLEEPCSR_KSO_MASK |\n\t\t\t  SBSDIO_FUNC1_SLEEPCSR_DEVON_MASK;\n\t\tbmask = cmp_val;\n\t\tusleep_range(2000, 3000);\n\t} else {\n\t\t \n\t\tcmp_val = 0;\n\t\t \n\t\tbmask = SBSDIO_FUNC1_SLEEPCSR_KSO_MASK;\n\t}\n\n\tdo {\n\t\t \n\t\trd_val = brcmf_sdiod_readb(bus->sdiodev, SBSDIO_FUNC1_SLEEPCSR,\n\t\t\t\t\t   &err);\n\t\tif (!err) {\n\t\t\tif ((rd_val & bmask) == cmp_val)\n\t\t\t\tbreak;\n\t\t\terr_cnt = 0;\n\t\t}\n\t\t \n\t\tif (err && (err_cnt++ > BRCMF_SDIO_MAX_ACCESS_ERRORS))\n\t\t\tbreak;\n\n\t\tudelay(KSO_WAIT_US);\n\t\tbrcmf_sdiod_writeb(bus->sdiodev, SBSDIO_FUNC1_SLEEPCSR, wr_val,\n\t\t\t\t   &err);\n\n\t} while (try_cnt++ < MAX_KSO_ATTEMPTS);\n\n\tif (try_cnt > 2)\n\t\tbrcmf_dbg(SDIO, \"try_cnt=%d rd_val=0x%x err=%d\\n\", try_cnt,\n\t\t\t  rd_val, err);\n\n\tif (try_cnt > MAX_KSO_ATTEMPTS)\n\t\tbrcmf_err(\"max tries: rd_val=0x%x err=%d\\n\", rd_val, err);\n\n\tif (on)\n\t\tsdio_retune_release(bus->sdiodev->func1);\n\n\tsdio_retune_crc_enable(bus->sdiodev->func1);\n\n\treturn err;\n}\n\n#define HOSTINTMASK\t\t(I_HMB_SW_MASK | I_CHIPACTIVE)\n\n \nstatic int brcmf_sdio_htclk(struct brcmf_sdio *bus, bool on, bool pendok)\n{\n\tint err;\n\tu8 clkctl, clkreq, devctl;\n\tunsigned long timeout;\n\n\tbrcmf_dbg(SDIO, \"Enter\\n\");\n\n\tclkctl = 0;\n\n\tif (bus->sr_enabled) {\n\t\tbus->clkstate = (on ? CLK_AVAIL : CLK_SDONLY);\n\t\treturn 0;\n\t}\n\n\tif (on) {\n\t\t \n\t\tclkreq =\n\t\t    bus->alp_only ? SBSDIO_ALP_AVAIL_REQ : SBSDIO_HT_AVAIL_REQ;\n\n\t\tbrcmf_sdiod_writeb(bus->sdiodev, SBSDIO_FUNC1_CHIPCLKCSR,\n\t\t\t\t   clkreq, &err);\n\t\tif (err) {\n\t\t\tbrcmf_err(\"HT Avail request error: %d\\n\", err);\n\t\t\treturn -EBADE;\n\t\t}\n\n\t\t \n\t\tclkctl = brcmf_sdiod_readb(bus->sdiodev,\n\t\t\t\t\t   SBSDIO_FUNC1_CHIPCLKCSR, &err);\n\t\tif (err) {\n\t\t\tbrcmf_err(\"HT Avail read error: %d\\n\", err);\n\t\t\treturn -EBADE;\n\t\t}\n\n\t\t \n\t\tif (!SBSDIO_CLKAV(clkctl, bus->alp_only) && pendok) {\n\t\t\t \n\t\t\tdevctl = brcmf_sdiod_readb(bus->sdiodev,\n\t\t\t\t\t\t   SBSDIO_DEVICE_CTL, &err);\n\t\t\tif (err) {\n\t\t\t\tbrcmf_err(\"Devctl error setting CA: %d\\n\", err);\n\t\t\t\treturn -EBADE;\n\t\t\t}\n\n\t\t\tdevctl |= SBSDIO_DEVCTL_CA_INT_ONLY;\n\t\t\tbrcmf_sdiod_writeb(bus->sdiodev, SBSDIO_DEVICE_CTL,\n\t\t\t\t\t   devctl, &err);\n\t\t\tbrcmf_dbg(SDIO, \"CLKCTL: set PENDING\\n\");\n\t\t\tbus->clkstate = CLK_PENDING;\n\n\t\t\treturn 0;\n\t\t} else if (bus->clkstate == CLK_PENDING) {\n\t\t\t \n\t\t\tdevctl = brcmf_sdiod_readb(bus->sdiodev,\n\t\t\t\t\t\t   SBSDIO_DEVICE_CTL, &err);\n\t\t\tdevctl &= ~SBSDIO_DEVCTL_CA_INT_ONLY;\n\t\t\tbrcmf_sdiod_writeb(bus->sdiodev, SBSDIO_DEVICE_CTL,\n\t\t\t\t\t   devctl, &err);\n\t\t}\n\n\t\t \n\t\ttimeout = jiffies +\n\t\t\t  msecs_to_jiffies(PMU_MAX_TRANSITION_DLY/1000);\n\t\twhile (!SBSDIO_CLKAV(clkctl, bus->alp_only)) {\n\t\t\tclkctl = brcmf_sdiod_readb(bus->sdiodev,\n\t\t\t\t\t\t   SBSDIO_FUNC1_CHIPCLKCSR,\n\t\t\t\t\t\t   &err);\n\t\t\tif (time_after(jiffies, timeout))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tusleep_range(5000, 10000);\n\t\t}\n\t\tif (err) {\n\t\t\tbrcmf_err(\"HT Avail request error: %d\\n\", err);\n\t\t\treturn -EBADE;\n\t\t}\n\t\tif (!SBSDIO_CLKAV(clkctl, bus->alp_only)) {\n\t\t\tbrcmf_err(\"HT Avail timeout (%d): clkctl 0x%02x\\n\",\n\t\t\t\t  PMU_MAX_TRANSITION_DLY, clkctl);\n\t\t\treturn -EBADE;\n\t\t}\n\n\t\t \n\t\tbus->clkstate = CLK_AVAIL;\n\t\tbrcmf_dbg(SDIO, \"CLKCTL: turned ON\\n\");\n\n#if defined(DEBUG)\n\t\tif (!bus->alp_only) {\n\t\t\tif (SBSDIO_ALPONLY(clkctl))\n\t\t\t\tbrcmf_err(\"HT Clock should be on\\n\");\n\t\t}\n#endif\t\t\t\t \n\n\t} else {\n\t\tclkreq = 0;\n\n\t\tif (bus->clkstate == CLK_PENDING) {\n\t\t\t \n\t\t\tdevctl = brcmf_sdiod_readb(bus->sdiodev,\n\t\t\t\t\t\t   SBSDIO_DEVICE_CTL, &err);\n\t\t\tdevctl &= ~SBSDIO_DEVCTL_CA_INT_ONLY;\n\t\t\tbrcmf_sdiod_writeb(bus->sdiodev, SBSDIO_DEVICE_CTL,\n\t\t\t\t\t   devctl, &err);\n\t\t}\n\n\t\tbus->clkstate = CLK_SDONLY;\n\t\tbrcmf_sdiod_writeb(bus->sdiodev, SBSDIO_FUNC1_CHIPCLKCSR,\n\t\t\t\t   clkreq, &err);\n\t\tbrcmf_dbg(SDIO, \"CLKCTL: turned OFF\\n\");\n\t\tif (err) {\n\t\t\tbrcmf_err(\"Failed access turning clock off: %d\\n\",\n\t\t\t\t  err);\n\t\t\treturn -EBADE;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int brcmf_sdio_sdclk(struct brcmf_sdio *bus, bool on)\n{\n\tbrcmf_dbg(SDIO, \"Enter\\n\");\n\n\tif (on)\n\t\tbus->clkstate = CLK_SDONLY;\n\telse\n\t\tbus->clkstate = CLK_NONE;\n\n\treturn 0;\n}\n\n \nstatic int brcmf_sdio_clkctl(struct brcmf_sdio *bus, uint target, bool pendok)\n{\n#ifdef DEBUG\n\tuint oldstate = bus->clkstate;\n#endif\t\t\t\t \n\n\tbrcmf_dbg(SDIO, \"Enter\\n\");\n\n\t \n\tif (bus->clkstate == target)\n\t\treturn 0;\n\n\tswitch (target) {\n\tcase CLK_AVAIL:\n\t\t \n\t\tif (bus->clkstate == CLK_NONE)\n\t\t\tbrcmf_sdio_sdclk(bus, true);\n\t\t \n\t\tbrcmf_sdio_htclk(bus, true, pendok);\n\t\tbreak;\n\n\tcase CLK_SDONLY:\n\t\t \n\t\tif (bus->clkstate == CLK_NONE)\n\t\t\tbrcmf_sdio_sdclk(bus, true);\n\t\telse if (bus->clkstate == CLK_AVAIL)\n\t\t\tbrcmf_sdio_htclk(bus, false, false);\n\t\telse\n\t\t\tbrcmf_err(\"request for %d -> %d\\n\",\n\t\t\t\t  bus->clkstate, target);\n\t\tbreak;\n\n\tcase CLK_NONE:\n\t\t \n\t\tif (bus->clkstate == CLK_AVAIL)\n\t\t\tbrcmf_sdio_htclk(bus, false, false);\n\t\t \n\t\tbrcmf_sdio_sdclk(bus, false);\n\t\tbreak;\n\t}\n#ifdef DEBUG\n\tbrcmf_dbg(SDIO, \"%d -> %d\\n\", oldstate, bus->clkstate);\n#endif\t\t\t\t \n\n\treturn 0;\n}\n\nstatic int\nbrcmf_sdio_bus_sleep(struct brcmf_sdio *bus, bool sleep, bool pendok)\n{\n\tint err = 0;\n\tu8 clkcsr;\n\n\tbrcmf_dbg(SDIO, \"Enter: request %s currently %s\\n\",\n\t\t  (sleep ? \"SLEEP\" : \"WAKE\"),\n\t\t  (bus->sleeping ? \"SLEEP\" : \"WAKE\"));\n\n\t \n\tif (bus->sr_enabled) {\n\t\t \n\t\tif (sleep == bus->sleeping)\n\t\t\tgoto end;\n\n\t\t \n\t\tif (sleep) {\n\t\t\tclkcsr = brcmf_sdiod_readb(bus->sdiodev,\n\t\t\t\t\t\t   SBSDIO_FUNC1_CHIPCLKCSR,\n\t\t\t\t\t\t   &err);\n\t\t\tif ((clkcsr & SBSDIO_CSR_MASK) == 0) {\n\t\t\t\tbrcmf_dbg(SDIO, \"no clock, set ALP\\n\");\n\t\t\t\tbrcmf_sdiod_writeb(bus->sdiodev,\n\t\t\t\t\t\t   SBSDIO_FUNC1_CHIPCLKCSR,\n\t\t\t\t\t\t   SBSDIO_ALP_AVAIL_REQ, &err);\n\t\t\t}\n\t\t\terr = brcmf_sdio_kso_control(bus, false);\n\t\t} else {\n\t\t\terr = brcmf_sdio_kso_control(bus, true);\n\t\t}\n\t\tif (err) {\n\t\t\tbrcmf_err(\"error while changing bus sleep state %d\\n\",\n\t\t\t\t  err);\n\t\t\tgoto done;\n\t\t}\n\t}\n\nend:\n\t \n\tif (sleep) {\n\t\tif (!bus->sr_enabled)\n\t\t\tbrcmf_sdio_clkctl(bus, CLK_NONE, pendok);\n\t} else {\n\t\tbrcmf_sdio_clkctl(bus, CLK_AVAIL, pendok);\n\t\tbrcmf_sdio_wd_timer(bus, true);\n\t}\n\tbus->sleeping = sleep;\n\tbrcmf_dbg(SDIO, \"new state %s\\n\",\n\t\t  (sleep ? \"SLEEP\" : \"WAKE\"));\ndone:\n\tbrcmf_dbg(SDIO, \"Exit: err=%d\\n\", err);\n\treturn err;\n\n}\n\n#ifdef DEBUG\nstatic inline bool brcmf_sdio_valid_shared_address(u32 addr)\n{\n\treturn !(addr == 0 || ((~addr >> 16) & 0xffff) == (addr & 0xffff));\n}\n\nstatic int brcmf_sdio_readshared(struct brcmf_sdio *bus,\n\t\t\t\t struct sdpcm_shared *sh)\n{\n\tu32 addr = 0;\n\tint rv;\n\tu32 shaddr = 0;\n\tstruct sdpcm_shared_le sh_le;\n\t__le32 addr_le;\n\n\tsdio_claim_host(bus->sdiodev->func1);\n\tbrcmf_sdio_bus_sleep(bus, false, false);\n\n\t \n\tshaddr = bus->ci->rambase + bus->ci->ramsize - 4;\n\tif (!bus->ci->rambase && brcmf_chip_sr_capable(bus->ci))\n\t\tshaddr -= bus->ci->srsize;\n\trv = brcmf_sdiod_ramrw(bus->sdiodev, false, shaddr,\n\t\t\t       (u8 *)&addr_le, 4);\n\tif (rv < 0)\n\t\tgoto fail;\n\n\t \n\taddr = le32_to_cpu(addr_le);\n\tif (!brcmf_sdio_valid_shared_address(addr)) {\n\t\tbrcmf_err(\"invalid sdpcm_shared address 0x%08X\\n\", addr);\n\t\trv = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tbrcmf_dbg(INFO, \"sdpcm_shared address 0x%08X\\n\", addr);\n\n\t \n\trv = brcmf_sdiod_ramrw(bus->sdiodev, false, addr, (u8 *)&sh_le,\n\t\t\t       sizeof(struct sdpcm_shared_le));\n\tif (rv < 0)\n\t\tgoto fail;\n\n\tsdio_release_host(bus->sdiodev->func1);\n\n\t \n\tsh->flags = le32_to_cpu(sh_le.flags);\n\tsh->trap_addr = le32_to_cpu(sh_le.trap_addr);\n\tsh->assert_exp_addr = le32_to_cpu(sh_le.assert_exp_addr);\n\tsh->assert_file_addr = le32_to_cpu(sh_le.assert_file_addr);\n\tsh->assert_line = le32_to_cpu(sh_le.assert_line);\n\tsh->console_addr = le32_to_cpu(sh_le.console_addr);\n\tsh->msgtrace_addr = le32_to_cpu(sh_le.msgtrace_addr);\n\n\tif ((sh->flags & SDPCM_SHARED_VERSION_MASK) > SDPCM_SHARED_VERSION) {\n\t\tbrcmf_err(\"sdpcm shared version unsupported: dhd %d dongle %d\\n\",\n\t\t\t  SDPCM_SHARED_VERSION,\n\t\t\t  sh->flags & SDPCM_SHARED_VERSION_MASK);\n\t\treturn -EPROTO;\n\t}\n\treturn 0;\n\nfail:\n\tbrcmf_err(\"unable to obtain sdpcm_shared info: rv=%d (addr=0x%x)\\n\",\n\t\t  rv, addr);\n\tsdio_release_host(bus->sdiodev->func1);\n\treturn rv;\n}\n\nstatic void brcmf_sdio_get_console_addr(struct brcmf_sdio *bus)\n{\n\tstruct sdpcm_shared sh;\n\n\tif (brcmf_sdio_readshared(bus, &sh) == 0)\n\t\tbus->console_addr = sh.console_addr;\n}\n#else\nstatic void brcmf_sdio_get_console_addr(struct brcmf_sdio *bus)\n{\n}\n#endif  \n\nstatic u32 brcmf_sdio_hostmail(struct brcmf_sdio *bus)\n{\n\tstruct brcmf_sdio_dev *sdiod = bus->sdiodev;\n\tstruct brcmf_core *core = bus->sdio_core;\n\tu32 intstatus = 0;\n\tu32 hmb_data;\n\tu8 fcbits;\n\tint ret;\n\n\tbrcmf_dbg(SDIO, \"Enter\\n\");\n\n\t \n\thmb_data = brcmf_sdiod_readl(sdiod,\n\t\t\t\t     core->base + SD_REG(tohostmailboxdata),\n\t\t\t\t     &ret);\n\n\tif (!ret)\n\t\tbrcmf_sdiod_writel(sdiod, core->base + SD_REG(tosbmailbox),\n\t\t\t\t   SMB_INT_ACK, &ret);\n\n\tbus->sdcnt.f1regdata += 2;\n\n\t \n\tif (hmb_data & HMB_DATA_FWHALT) {\n\t\tbrcmf_dbg(SDIO, \"mailbox indicates firmware halted\\n\");\n\t\tbrcmf_fw_crashed(&sdiod->func1->dev);\n\t}\n\n\t \n\tif (hmb_data & HMB_DATA_NAKHANDLED) {\n\t\tbrcmf_dbg(SDIO, \"Dongle reports NAK handled, expect rtx of %d\\n\",\n\t\t\t  bus->rx_seq);\n\t\tif (!bus->rxskip)\n\t\t\tbrcmf_err(\"unexpected NAKHANDLED!\\n\");\n\n\t\tbus->rxskip = false;\n\t\tintstatus |= I_HMB_FRAME_IND;\n\t}\n\n\t \n\tif (hmb_data & (HMB_DATA_DEVREADY | HMB_DATA_FWREADY)) {\n\t\tbus->sdpcm_ver =\n\t\t    (hmb_data & HMB_DATA_VERSION_MASK) >>\n\t\t    HMB_DATA_VERSION_SHIFT;\n\t\tif (bus->sdpcm_ver != SDPCM_PROT_VERSION)\n\t\t\tbrcmf_err(\"Version mismatch, dongle reports %d, \"\n\t\t\t\t  \"expecting %d\\n\",\n\t\t\t\t  bus->sdpcm_ver, SDPCM_PROT_VERSION);\n\t\telse\n\t\t\tbrcmf_dbg(SDIO, \"Dongle ready, protocol version %d\\n\",\n\t\t\t\t  bus->sdpcm_ver);\n\n\t\t \n\t\tbrcmf_sdio_get_console_addr(bus);\n\t}\n\n\t \n\tif (hmb_data & HMB_DATA_FC) {\n\t\tfcbits = (hmb_data & HMB_DATA_FCDATA_MASK) >>\n\t\t\t\t\t\t\tHMB_DATA_FCDATA_SHIFT;\n\n\t\tif (fcbits & ~bus->flowcontrol)\n\t\t\tbus->sdcnt.fc_xoff++;\n\n\t\tif (bus->flowcontrol & ~fcbits)\n\t\t\tbus->sdcnt.fc_xon++;\n\n\t\tbus->sdcnt.fc_rcvd++;\n\t\tbus->flowcontrol = fcbits;\n\t}\n\n\t \n\tif (hmb_data & ~(HMB_DATA_DEVREADY |\n\t\t\t HMB_DATA_NAKHANDLED |\n\t\t\t HMB_DATA_FC |\n\t\t\t HMB_DATA_FWREADY |\n\t\t\t HMB_DATA_FWHALT |\n\t\t\t HMB_DATA_FCDATA_MASK | HMB_DATA_VERSION_MASK))\n\t\tbrcmf_err(\"Unknown mailbox data content: 0x%02x\\n\",\n\t\t\t  hmb_data);\n\n\treturn intstatus;\n}\n\nstatic void brcmf_sdio_rxfail(struct brcmf_sdio *bus, bool abort, bool rtx)\n{\n\tstruct brcmf_sdio_dev *sdiod = bus->sdiodev;\n\tstruct brcmf_core *core = bus->sdio_core;\n\tuint retries = 0;\n\tu16 lastrbc;\n\tu8 hi, lo;\n\tint err;\n\n\tbrcmf_err(\"%sterminate frame%s\\n\",\n\t\t  abort ? \"abort command, \" : \"\",\n\t\t  rtx ? \", send NAK\" : \"\");\n\n\tif (abort)\n\t\tbrcmf_sdiod_abort(bus->sdiodev, bus->sdiodev->func2);\n\n\tbrcmf_sdiod_writeb(bus->sdiodev, SBSDIO_FUNC1_FRAMECTRL, SFC_RF_TERM,\n\t\t\t   &err);\n\tbus->sdcnt.f1regdata++;\n\n\t \n\tfor (lastrbc = retries = 0xffff; retries > 0; retries--) {\n\t\thi = brcmf_sdiod_readb(bus->sdiodev, SBSDIO_FUNC1_RFRAMEBCHI,\n\t\t\t\t       &err);\n\t\tlo = brcmf_sdiod_readb(bus->sdiodev, SBSDIO_FUNC1_RFRAMEBCLO,\n\t\t\t\t       &err);\n\t\tbus->sdcnt.f1regdata += 2;\n\n\t\tif ((hi == 0) && (lo == 0))\n\t\t\tbreak;\n\n\t\tif ((hi > (lastrbc >> 8)) && (lo > (lastrbc & 0x00ff))) {\n\t\t\tbrcmf_err(\"count growing: last 0x%04x now 0x%04x\\n\",\n\t\t\t\t  lastrbc, (hi << 8) + lo);\n\t\t}\n\t\tlastrbc = (hi << 8) + lo;\n\t}\n\n\tif (!retries)\n\t\tbrcmf_err(\"count never zeroed: last 0x%04x\\n\", lastrbc);\n\telse\n\t\tbrcmf_dbg(SDIO, \"flush took %d iterations\\n\", 0xffff - retries);\n\n\tif (rtx) {\n\t\tbus->sdcnt.rxrtx++;\n\t\tbrcmf_sdiod_writel(sdiod, core->base + SD_REG(tosbmailbox),\n\t\t\t\t   SMB_NAK, &err);\n\n\t\tbus->sdcnt.f1regdata++;\n\t\tif (err == 0)\n\t\t\tbus->rxskip = true;\n\t}\n\n\t \n\tbus->cur_read.len = 0;\n}\n\nstatic void brcmf_sdio_txfail(struct brcmf_sdio *bus)\n{\n\tstruct brcmf_sdio_dev *sdiodev = bus->sdiodev;\n\tu8 i, hi, lo;\n\n\t \n\tbrcmf_err(\"sdio error, abort command and terminate frame\\n\");\n\tbus->sdcnt.tx_sderrs++;\n\n\tbrcmf_sdiod_abort(sdiodev, sdiodev->func2);\n\tbrcmf_sdiod_writeb(sdiodev, SBSDIO_FUNC1_FRAMECTRL, SFC_WF_TERM, NULL);\n\tbus->sdcnt.f1regdata++;\n\n\tfor (i = 0; i < 3; i++) {\n\t\thi = brcmf_sdiod_readb(sdiodev, SBSDIO_FUNC1_WFRAMEBCHI, NULL);\n\t\tlo = brcmf_sdiod_readb(sdiodev, SBSDIO_FUNC1_WFRAMEBCLO, NULL);\n\t\tbus->sdcnt.f1regdata += 2;\n\t\tif ((hi == 0) && (lo == 0))\n\t\t\tbreak;\n\t}\n}\n\n \nstatic uint brcmf_sdio_glom_len(struct brcmf_sdio *bus)\n{\n\tstruct sk_buff *p;\n\tuint total;\n\n\ttotal = 0;\n\tskb_queue_walk(&bus->glom, p)\n\t\ttotal += p->len;\n\treturn total;\n}\n\nstatic void brcmf_sdio_free_glom(struct brcmf_sdio *bus)\n{\n\tstruct sk_buff *cur, *next;\n\n\tskb_queue_walk_safe(&bus->glom, cur, next) {\n\t\tskb_unlink(cur, &bus->glom);\n\t\tbrcmu_pkt_buf_free_skb(cur);\n\t}\n}\n\n \n#define SDPCM_HWHDR_LEN\t\t\t4\n#define SDPCM_HWEXT_LEN\t\t\t8\n#define SDPCM_SWHDR_LEN\t\t\t8\n#define SDPCM_HDRLEN\t\t\t(SDPCM_HWHDR_LEN + SDPCM_SWHDR_LEN)\n \n#define SDPCM_SEQ_MASK\t\t\t0x000000ff\n#define SDPCM_SEQ_WRAP\t\t\t256\n#define SDPCM_CHANNEL_MASK\t\t0x00000f00\n#define SDPCM_CHANNEL_SHIFT\t\t8\n#define SDPCM_CONTROL_CHANNEL\t\t0\t \n#define SDPCM_EVENT_CHANNEL\t\t1\t \n#define SDPCM_DATA_CHANNEL\t\t2\t \n#define SDPCM_GLOM_CHANNEL\t\t3\t \n#define SDPCM_TEST_CHANNEL\t\t15\t \n#define SDPCM_GLOMDESC(p)\t\t(((u8 *)p)[1] & 0x80)\n#define SDPCM_NEXTLEN_MASK\t\t0x00ff0000\n#define SDPCM_NEXTLEN_SHIFT\t\t16\n#define SDPCM_DOFFSET_MASK\t\t0xff000000\n#define SDPCM_DOFFSET_SHIFT\t\t24\n#define SDPCM_FCMASK_MASK\t\t0x000000ff\n#define SDPCM_WINDOW_MASK\t\t0x0000ff00\n#define SDPCM_WINDOW_SHIFT\t\t8\n\nstatic inline u8 brcmf_sdio_getdatoffset(u8 *swheader)\n{\n\tu32 hdrvalue;\n\thdrvalue = le32_to_cpu(*(__le32 *)swheader);\n\treturn (u8)((hdrvalue & SDPCM_DOFFSET_MASK) >> SDPCM_DOFFSET_SHIFT);\n}\n\nstatic inline bool brcmf_sdio_fromevntchan(u8 *swheader)\n{\n\tu32 hdrvalue;\n\tu8 ret;\n\n\thdrvalue = le32_to_cpu(*(__le32 *)swheader);\n\tret = (u8)((hdrvalue & SDPCM_CHANNEL_MASK) >> SDPCM_CHANNEL_SHIFT);\n\n\treturn (ret == SDPCM_EVENT_CHANNEL);\n}\n\nstatic int brcmf_sdio_hdparse(struct brcmf_sdio *bus, u8 *header,\n\t\t\t      struct brcmf_sdio_hdrinfo *rd,\n\t\t\t      enum brcmf_sdio_frmtype type)\n{\n\tu16 len, checksum;\n\tu8 rx_seq, fc, tx_seq_max;\n\tu32 swheader;\n\n\ttrace_brcmf_sdpcm_hdr(SDPCM_RX, header);\n\n\t \n\tlen = get_unaligned_le16(header);\n\tchecksum = get_unaligned_le16(header + sizeof(u16));\n\t \n\tif (!(len | checksum)) {\n\t\tbus->rxpending = false;\n\t\treturn -ENODATA;\n\t}\n\tif ((u16)(~(len ^ checksum))) {\n\t\tbrcmf_err(\"HW header checksum error\\n\");\n\t\tbus->sdcnt.rx_badhdr++;\n\t\tbrcmf_sdio_rxfail(bus, false, false);\n\t\treturn -EIO;\n\t}\n\tif (len < SDPCM_HDRLEN) {\n\t\tbrcmf_err(\"HW header length error\\n\");\n\t\treturn -EPROTO;\n\t}\n\tif (type == BRCMF_SDIO_FT_SUPER &&\n\t    (roundup(len, bus->blocksize) != rd->len)) {\n\t\tbrcmf_err(\"HW superframe header length error\\n\");\n\t\treturn -EPROTO;\n\t}\n\tif (type == BRCMF_SDIO_FT_SUB && len > rd->len) {\n\t\tbrcmf_err(\"HW subframe header length error\\n\");\n\t\treturn -EPROTO;\n\t}\n\trd->len = len;\n\n\t \n\theader += SDPCM_HWHDR_LEN;\n\tswheader = le32_to_cpu(*(__le32 *)header);\n\tif (type == BRCMF_SDIO_FT_SUPER && SDPCM_GLOMDESC(header)) {\n\t\tbrcmf_err(\"Glom descriptor found in superframe head\\n\");\n\t\trd->len = 0;\n\t\treturn -EINVAL;\n\t}\n\trx_seq = (u8)(swheader & SDPCM_SEQ_MASK);\n\trd->channel = (swheader & SDPCM_CHANNEL_MASK) >> SDPCM_CHANNEL_SHIFT;\n\tif (len > MAX_RX_DATASZ && rd->channel != SDPCM_CONTROL_CHANNEL &&\n\t    type != BRCMF_SDIO_FT_SUPER) {\n\t\tbrcmf_err(\"HW header length too long\\n\");\n\t\tbus->sdcnt.rx_toolong++;\n\t\tbrcmf_sdio_rxfail(bus, false, false);\n\t\trd->len = 0;\n\t\treturn -EPROTO;\n\t}\n\tif (type == BRCMF_SDIO_FT_SUPER && rd->channel != SDPCM_GLOM_CHANNEL) {\n\t\tbrcmf_err(\"Wrong channel for superframe\\n\");\n\t\trd->len = 0;\n\t\treturn -EINVAL;\n\t}\n\tif (type == BRCMF_SDIO_FT_SUB && rd->channel != SDPCM_DATA_CHANNEL &&\n\t    rd->channel != SDPCM_EVENT_CHANNEL) {\n\t\tbrcmf_err(\"Wrong channel for subframe\\n\");\n\t\trd->len = 0;\n\t\treturn -EINVAL;\n\t}\n\trd->dat_offset = brcmf_sdio_getdatoffset(header);\n\tif (rd->dat_offset < SDPCM_HDRLEN || rd->dat_offset > rd->len) {\n\t\tbrcmf_err(\"seq %d: bad data offset\\n\", rx_seq);\n\t\tbus->sdcnt.rx_badhdr++;\n\t\tbrcmf_sdio_rxfail(bus, false, false);\n\t\trd->len = 0;\n\t\treturn -ENXIO;\n\t}\n\tif (rd->seq_num != rx_seq) {\n\t\tbrcmf_dbg(SDIO, \"seq %d, expected %d\\n\", rx_seq, rd->seq_num);\n\t\tbus->sdcnt.rx_badseq++;\n\t\trd->seq_num = rx_seq;\n\t}\n\t \n\tif (type == BRCMF_SDIO_FT_SUB)\n\t\treturn 0;\n\trd->len_nxtfrm = (swheader & SDPCM_NEXTLEN_MASK) >> SDPCM_NEXTLEN_SHIFT;\n\tif (rd->len_nxtfrm << 4 > MAX_RX_DATASZ) {\n\t\t \n\t\tif (rd->channel != SDPCM_GLOM_CHANNEL)\n\t\t\tbrcmf_err(\"seq %d: next length error\\n\", rx_seq);\n\t\trd->len_nxtfrm = 0;\n\t}\n\tswheader = le32_to_cpu(*(__le32 *)(header + 4));\n\tfc = swheader & SDPCM_FCMASK_MASK;\n\tif (bus->flowcontrol != fc) {\n\t\tif (~bus->flowcontrol & fc)\n\t\t\tbus->sdcnt.fc_xoff++;\n\t\tif (bus->flowcontrol & ~fc)\n\t\t\tbus->sdcnt.fc_xon++;\n\t\tbus->sdcnt.fc_rcvd++;\n\t\tbus->flowcontrol = fc;\n\t}\n\ttx_seq_max = (swheader & SDPCM_WINDOW_MASK) >> SDPCM_WINDOW_SHIFT;\n\tif ((u8)(tx_seq_max - bus->tx_seq) > 0x40) {\n\t\tbrcmf_err(\"seq %d: max tx seq number error\\n\", rx_seq);\n\t\ttx_seq_max = bus->tx_seq + 2;\n\t}\n\tbus->tx_max = tx_seq_max;\n\n\treturn 0;\n}\n\nstatic inline void brcmf_sdio_update_hwhdr(u8 *header, u16 frm_length)\n{\n\t*(__le16 *)header = cpu_to_le16(frm_length);\n\t*(((__le16 *)header) + 1) = cpu_to_le16(~frm_length);\n}\n\nstatic void brcmf_sdio_hdpack(struct brcmf_sdio *bus, u8 *header,\n\t\t\t      struct brcmf_sdio_hdrinfo *hd_info)\n{\n\tu32 hdrval;\n\tu8 hdr_offset;\n\n\tbrcmf_sdio_update_hwhdr(header, hd_info->len);\n\thdr_offset = SDPCM_HWHDR_LEN;\n\n\tif (bus->txglom) {\n\t\thdrval = (hd_info->len - hdr_offset) | (hd_info->lastfrm << 24);\n\t\t*((__le32 *)(header + hdr_offset)) = cpu_to_le32(hdrval);\n\t\thdrval = (u16)hd_info->tail_pad << 16;\n\t\t*(((__le32 *)(header + hdr_offset)) + 1) = cpu_to_le32(hdrval);\n\t\thdr_offset += SDPCM_HWEXT_LEN;\n\t}\n\n\thdrval = hd_info->seq_num;\n\thdrval |= (hd_info->channel << SDPCM_CHANNEL_SHIFT) &\n\t\t  SDPCM_CHANNEL_MASK;\n\thdrval |= (hd_info->dat_offset << SDPCM_DOFFSET_SHIFT) &\n\t\t  SDPCM_DOFFSET_MASK;\n\t*((__le32 *)(header + hdr_offset)) = cpu_to_le32(hdrval);\n\t*(((__le32 *)(header + hdr_offset)) + 1) = 0;\n\ttrace_brcmf_sdpcm_hdr(SDPCM_TX + !!(bus->txglom), header);\n}\n\nstatic u8 brcmf_sdio_rxglom(struct brcmf_sdio *bus, u8 rxseq)\n{\n\tu16 dlen, totlen;\n\tu8 *dptr, num = 0;\n\tu16 sublen;\n\tstruct sk_buff *pfirst, *pnext;\n\n\tint errcode;\n\tu8 doff;\n\n\tstruct brcmf_sdio_hdrinfo rd_new;\n\n\t \n\t \n\n\tbrcmf_dbg(SDIO, \"start: glomd %p glom %p\\n\",\n\t\t  bus->glomd, skb_peek(&bus->glom));\n\n\t \n\tif (bus->glomd) {\n\t\tpfirst = pnext = NULL;\n\t\tdlen = (u16) (bus->glomd->len);\n\t\tdptr = bus->glomd->data;\n\t\tif (!dlen || (dlen & 1)) {\n\t\t\tbrcmf_err(\"bad glomd len(%d), ignore descriptor\\n\",\n\t\t\t\t  dlen);\n\t\t\tdlen = 0;\n\t\t}\n\n\t\tfor (totlen = num = 0; dlen; num++) {\n\t\t\t \n\t\t\tsublen = get_unaligned_le16(dptr);\n\t\t\tdlen -= sizeof(u16);\n\t\t\tdptr += sizeof(u16);\n\t\t\tif ((sublen < SDPCM_HDRLEN) ||\n\t\t\t    ((num == 0) && (sublen < (2 * SDPCM_HDRLEN)))) {\n\t\t\t\tbrcmf_err(\"descriptor len %d bad: %d\\n\",\n\t\t\t\t\t  num, sublen);\n\t\t\t\tpnext = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (sublen % bus->sgentry_align) {\n\t\t\t\tbrcmf_err(\"sublen %d not multiple of %d\\n\",\n\t\t\t\t\t  sublen, bus->sgentry_align);\n\t\t\t}\n\t\t\ttotlen += sublen;\n\n\t\t\t \n\t\t\tif (!dlen) {\n\t\t\t\tsublen +=\n\t\t\t\t    (roundup(totlen, bus->blocksize) - totlen);\n\t\t\t\ttotlen = roundup(totlen, bus->blocksize);\n\t\t\t}\n\n\t\t\t \n\t\t\tpnext = brcmu_pkt_buf_get_skb(sublen + bus->sgentry_align);\n\t\t\tif (pnext == NULL) {\n\t\t\t\tbrcmf_err(\"bcm_pkt_buf_get_skb failed, num %d len %d\\n\",\n\t\t\t\t\t  num, sublen);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tskb_queue_tail(&bus->glom, pnext);\n\n\t\t\t \n\t\t\tpkt_align(pnext, sublen, bus->sgentry_align);\n\t\t}\n\n\t\t \n\t\tif (pnext) {\n\t\t\tbrcmf_dbg(GLOM, \"allocated %d-byte packet chain for %d subframes\\n\",\n\t\t\t\t  totlen, num);\n\t\t\tif (BRCMF_GLOM_ON() && bus->cur_read.len &&\n\t\t\t    totlen != bus->cur_read.len) {\n\t\t\t\tbrcmf_dbg(GLOM, \"glomdesc mismatch: nextlen %d glomdesc %d rxseq %d\\n\",\n\t\t\t\t\t  bus->cur_read.len, totlen, rxseq);\n\t\t\t}\n\t\t\tpfirst = pnext = NULL;\n\t\t} else {\n\t\t\tbrcmf_sdio_free_glom(bus);\n\t\t\tnum = 0;\n\t\t}\n\n\t\t \n\t\tbrcmu_pkt_buf_free_skb(bus->glomd);\n\t\tbus->glomd = NULL;\n\t\tbus->cur_read.len = 0;\n\t}\n\n\t \n\tif (!skb_queue_empty(&bus->glom)) {\n\t\tif (BRCMF_GLOM_ON()) {\n\t\t\tbrcmf_dbg(GLOM, \"try superframe read, packet chain:\\n\");\n\t\t\tskb_queue_walk(&bus->glom, pnext) {\n\t\t\t\tbrcmf_dbg(GLOM, \"    %p: %p len 0x%04x (%d)\\n\",\n\t\t\t\t\t  pnext, (u8 *) (pnext->data),\n\t\t\t\t\t  pnext->len, pnext->len);\n\t\t\t}\n\t\t}\n\n\t\tpfirst = skb_peek(&bus->glom);\n\t\tdlen = (u16) brcmf_sdio_glom_len(bus);\n\n\t\t \n\t\tsdio_claim_host(bus->sdiodev->func1);\n\t\terrcode = brcmf_sdiod_recv_chain(bus->sdiodev,\n\t\t\t\t\t\t &bus->glom, dlen);\n\t\tsdio_release_host(bus->sdiodev->func1);\n\t\tbus->sdcnt.f2rxdata++;\n\n\t\t \n\t\tif (errcode < 0) {\n\t\t\tbrcmf_err(\"glom read of %d bytes failed: %d\\n\",\n\t\t\t\t  dlen, errcode);\n\n\t\t\tsdio_claim_host(bus->sdiodev->func1);\n\t\t\tbrcmf_sdio_rxfail(bus, true, false);\n\t\t\tbus->sdcnt.rxglomfail++;\n\t\t\tbrcmf_sdio_free_glom(bus);\n\t\t\tsdio_release_host(bus->sdiodev->func1);\n\t\t\treturn 0;\n\t\t}\n\n\t\tbrcmf_dbg_hex_dump(BRCMF_GLOM_ON(),\n\t\t\t\t   pfirst->data, min_t(int, pfirst->len, 48),\n\t\t\t\t   \"SUPERFRAME:\\n\");\n\n\t\trd_new.seq_num = rxseq;\n\t\trd_new.len = dlen;\n\t\tsdio_claim_host(bus->sdiodev->func1);\n\t\terrcode = brcmf_sdio_hdparse(bus, pfirst->data, &rd_new,\n\t\t\t\t\t     BRCMF_SDIO_FT_SUPER);\n\t\tsdio_release_host(bus->sdiodev->func1);\n\t\tbus->cur_read.len = rd_new.len_nxtfrm << 4;\n\n\t\t \n\t\tskb_pull(pfirst, rd_new.dat_offset);\n\t\tnum = 0;\n\n\t\t \n\t\tskb_queue_walk(&bus->glom, pnext) {\n\t\t\t \n\t\t\tif (errcode)\n\t\t\t\tbreak;\n\n\t\t\trd_new.len = pnext->len;\n\t\t\trd_new.seq_num = rxseq++;\n\t\t\tsdio_claim_host(bus->sdiodev->func1);\n\t\t\terrcode = brcmf_sdio_hdparse(bus, pnext->data, &rd_new,\n\t\t\t\t\t\t     BRCMF_SDIO_FT_SUB);\n\t\t\tsdio_release_host(bus->sdiodev->func1);\n\t\t\tbrcmf_dbg_hex_dump(BRCMF_GLOM_ON(),\n\t\t\t\t\t   pnext->data, 32, \"subframe:\\n\");\n\n\t\t\tnum++;\n\t\t}\n\n\t\tif (errcode) {\n\t\t\t \n\t\t\tsdio_claim_host(bus->sdiodev->func1);\n\t\t\tbrcmf_sdio_rxfail(bus, true, false);\n\t\t\tbus->sdcnt.rxglomfail++;\n\t\t\tbrcmf_sdio_free_glom(bus);\n\t\t\tsdio_release_host(bus->sdiodev->func1);\n\t\t\tbus->cur_read.len = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\n\t\tskb_queue_walk_safe(&bus->glom, pfirst, pnext) {\n\t\t\tdptr = (u8 *) (pfirst->data);\n\t\t\tsublen = get_unaligned_le16(dptr);\n\t\t\tdoff = brcmf_sdio_getdatoffset(&dptr[SDPCM_HWHDR_LEN]);\n\n\t\t\tbrcmf_dbg_hex_dump(BRCMF_BYTES_ON() && BRCMF_DATA_ON(),\n\t\t\t\t\t   dptr, pfirst->len,\n\t\t\t\t\t   \"Rx Subframe Data:\\n\");\n\n\t\t\t__skb_trim(pfirst, sublen);\n\t\t\tskb_pull(pfirst, doff);\n\n\t\t\tif (pfirst->len == 0) {\n\t\t\t\tskb_unlink(pfirst, &bus->glom);\n\t\t\t\tbrcmu_pkt_buf_free_skb(pfirst);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbrcmf_dbg_hex_dump(BRCMF_GLOM_ON(),\n\t\t\t\t\t   pfirst->data,\n\t\t\t\t\t   min_t(int, pfirst->len, 32),\n\t\t\t\t\t   \"subframe %d to stack, %p (%p/%d) nxt/lnk %p/%p\\n\",\n\t\t\t\t\t   bus->glom.qlen, pfirst, pfirst->data,\n\t\t\t\t\t   pfirst->len, pfirst->next,\n\t\t\t\t\t   pfirst->prev);\n\t\t\tskb_unlink(pfirst, &bus->glom);\n\t\t\tif (brcmf_sdio_fromevntchan(&dptr[SDPCM_HWHDR_LEN]))\n\t\t\t\tbrcmf_rx_event(bus->sdiodev->dev, pfirst);\n\t\t\telse\n\t\t\t\tbrcmf_rx_frame(bus->sdiodev->dev, pfirst,\n\t\t\t\t\t       false, false);\n\t\t\tbus->sdcnt.rxglompkts++;\n\t\t}\n\n\t\tbus->sdcnt.rxglomframes++;\n\t}\n\treturn num;\n}\n\nstatic int brcmf_sdio_dcmd_resp_wait(struct brcmf_sdio *bus, uint *condition,\n\t\t\t\t     bool *pending)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tint timeout = DCMD_RESP_TIMEOUT;\n\n\t \n\tadd_wait_queue(&bus->dcmd_resp_wait, &wait);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\n\twhile (!(*condition) && (!signal_pending(current) && timeout))\n\t\ttimeout = schedule_timeout(timeout);\n\n\tif (signal_pending(current))\n\t\t*pending = true;\n\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&bus->dcmd_resp_wait, &wait);\n\n\treturn timeout;\n}\n\nstatic int brcmf_sdio_dcmd_resp_wake(struct brcmf_sdio *bus)\n{\n\twake_up_interruptible(&bus->dcmd_resp_wait);\n\n\treturn 0;\n}\nstatic void\nbrcmf_sdio_read_control(struct brcmf_sdio *bus, u8 *hdr, uint len, uint doff)\n{\n\tuint rdlen, pad;\n\tu8 *buf = NULL, *rbuf;\n\tint sdret;\n\n\tbrcmf_dbg(SDIO, \"Enter\\n\");\n\tif (bus->rxblen)\n\t\tbuf = vzalloc(bus->rxblen);\n\tif (!buf)\n\t\tgoto done;\n\n\trbuf = bus->rxbuf;\n\tpad = ((unsigned long)rbuf % bus->head_align);\n\tif (pad)\n\t\trbuf += (bus->head_align - pad);\n\n\t \n\tmemcpy(buf, hdr, BRCMF_FIRSTREAD);\n\tif (len <= BRCMF_FIRSTREAD)\n\t\tgoto gotpkt;\n\n\t \n\trdlen = len - BRCMF_FIRSTREAD;\n\tif (bus->roundup && bus->blocksize && (rdlen > bus->blocksize)) {\n\t\tpad = bus->blocksize - (rdlen % bus->blocksize);\n\t\tif ((pad <= bus->roundup) && (pad < bus->blocksize) &&\n\t\t    ((len + pad) < bus->sdiodev->bus_if->maxctl))\n\t\t\trdlen += pad;\n\t} else if (rdlen % bus->head_align) {\n\t\trdlen += bus->head_align - (rdlen % bus->head_align);\n\t}\n\n\t \n\tif ((rdlen + BRCMF_FIRSTREAD) > bus->sdiodev->bus_if->maxctl) {\n\t\tbrcmf_err(\"%d-byte control read exceeds %d-byte buffer\\n\",\n\t\t\t  rdlen, bus->sdiodev->bus_if->maxctl);\n\t\tbrcmf_sdio_rxfail(bus, false, false);\n\t\tgoto done;\n\t}\n\n\tif ((len - doff) > bus->sdiodev->bus_if->maxctl) {\n\t\tbrcmf_err(\"%d-byte ctl frame (%d-byte ctl data) exceeds %d-byte limit\\n\",\n\t\t\t  len, len - doff, bus->sdiodev->bus_if->maxctl);\n\t\tbus->sdcnt.rx_toolong++;\n\t\tbrcmf_sdio_rxfail(bus, false, false);\n\t\tgoto done;\n\t}\n\n\t \n\tsdret = brcmf_sdiod_recv_buf(bus->sdiodev, rbuf, rdlen);\n\tbus->sdcnt.f2rxdata++;\n\n\t \n\tif (sdret < 0) {\n\t\tbrcmf_err(\"read %d control bytes failed: %d\\n\",\n\t\t\t  rdlen, sdret);\n\t\tbus->sdcnt.rxc_errors++;\n\t\tbrcmf_sdio_rxfail(bus, true, true);\n\t\tgoto done;\n\t} else\n\t\tmemcpy(buf + BRCMF_FIRSTREAD, rbuf, rdlen);\n\ngotpkt:\n\n\tbrcmf_dbg_hex_dump(BRCMF_BYTES_ON() && BRCMF_CTL_ON(),\n\t\t\t   buf, len, \"RxCtrl:\\n\");\n\n\t \n\tspin_lock_bh(&bus->rxctl_lock);\n\tif (bus->rxctl) {\n\t\tbrcmf_err(\"last control frame is being processed.\\n\");\n\t\tspin_unlock_bh(&bus->rxctl_lock);\n\t\tvfree(buf);\n\t\tgoto done;\n\t}\n\tbus->rxctl = buf + doff;\n\tbus->rxctl_orig = buf;\n\tbus->rxlen = len - doff;\n\tspin_unlock_bh(&bus->rxctl_lock);\n\ndone:\n\t \n\tbrcmf_sdio_dcmd_resp_wake(bus);\n}\n\n \nstatic void brcmf_sdio_pad(struct brcmf_sdio *bus, u16 *pad, u16 *rdlen)\n{\n\tif (bus->roundup && bus->blocksize && *rdlen > bus->blocksize) {\n\t\t*pad = bus->blocksize - (*rdlen % bus->blocksize);\n\t\tif (*pad <= bus->roundup && *pad < bus->blocksize &&\n\t\t    *rdlen + *pad + BRCMF_FIRSTREAD < MAX_RX_DATASZ)\n\t\t\t*rdlen += *pad;\n\t} else if (*rdlen % bus->head_align) {\n\t\t*rdlen += bus->head_align - (*rdlen % bus->head_align);\n\t}\n}\n\nstatic uint brcmf_sdio_readframes(struct brcmf_sdio *bus, uint maxframes)\n{\n\tstruct sk_buff *pkt;\t\t \n\tu16 pad;\t\t \n\tuint rxleft = 0;\t \n\tint ret;\t\t \n\tuint rxcount = 0;\t \n\tstruct brcmf_sdio_hdrinfo *rd = &bus->cur_read, rd_new;\n\tu8 head_read = 0;\n\n\tbrcmf_dbg(SDIO, \"Enter\\n\");\n\n\t \n\tbus->rxpending = true;\n\n\tfor (rd->seq_num = bus->rx_seq, rxleft = maxframes;\n\t     !bus->rxskip && rxleft && bus->sdiodev->state == BRCMF_SDIOD_DATA;\n\t     rd->seq_num++, rxleft--) {\n\n\t\t \n\t\tif (bus->glomd || !skb_queue_empty(&bus->glom)) {\n\t\t\tu8 cnt;\n\t\t\tbrcmf_dbg(GLOM, \"calling rxglom: glomd %p, glom %p\\n\",\n\t\t\t\t  bus->glomd, skb_peek(&bus->glom));\n\t\t\tcnt = brcmf_sdio_rxglom(bus, rd->seq_num);\n\t\t\tbrcmf_dbg(GLOM, \"rxglom returned %d\\n\", cnt);\n\t\t\trd->seq_num += cnt - 1;\n\t\t\trxleft = (rxleft > cnt) ? (rxleft - cnt) : 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\trd->len_left = rd->len;\n\t\t \n\t\tsdio_claim_host(bus->sdiodev->func1);\n\t\tif (!rd->len) {\n\t\t\tret = brcmf_sdiod_recv_buf(bus->sdiodev,\n\t\t\t\t\t\t   bus->rxhdr, BRCMF_FIRSTREAD);\n\t\t\tbus->sdcnt.f2rxhdrs++;\n\t\t\tif (ret < 0) {\n\t\t\t\tbrcmf_err(\"RXHEADER FAILED: %d\\n\",\n\t\t\t\t\t  ret);\n\t\t\t\tbus->sdcnt.rx_hdrfail++;\n\t\t\t\tbrcmf_sdio_rxfail(bus, true, true);\n\t\t\t\tsdio_release_host(bus->sdiodev->func1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbrcmf_dbg_hex_dump(BRCMF_BYTES_ON() || BRCMF_HDRS_ON(),\n\t\t\t\t\t   bus->rxhdr, SDPCM_HDRLEN,\n\t\t\t\t\t   \"RxHdr:\\n\");\n\n\t\t\tif (brcmf_sdio_hdparse(bus, bus->rxhdr, rd,\n\t\t\t\t\t       BRCMF_SDIO_FT_NORMAL)) {\n\t\t\t\tsdio_release_host(bus->sdiodev->func1);\n\t\t\t\tif (!bus->rxpending)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (rd->channel == SDPCM_CONTROL_CHANNEL) {\n\t\t\t\tbrcmf_sdio_read_control(bus, bus->rxhdr,\n\t\t\t\t\t\t\trd->len,\n\t\t\t\t\t\t\trd->dat_offset);\n\t\t\t\t \n\t\t\t\trd->len = rd->len_nxtfrm << 4;\n\t\t\t\trd->len_nxtfrm = 0;\n\t\t\t\t \n\t\t\t\trd->channel = SDPCM_EVENT_CHANNEL;\n\t\t\t\tsdio_release_host(bus->sdiodev->func1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trd->len_left = rd->len > BRCMF_FIRSTREAD ?\n\t\t\t\t       rd->len - BRCMF_FIRSTREAD : 0;\n\t\t\thead_read = BRCMF_FIRSTREAD;\n\t\t}\n\n\t\tbrcmf_sdio_pad(bus, &pad, &rd->len_left);\n\n\t\tpkt = brcmu_pkt_buf_get_skb(rd->len_left + head_read +\n\t\t\t\t\t    bus->head_align);\n\t\tif (!pkt) {\n\t\t\t \n\t\t\tbrcmf_err(\"brcmu_pkt_buf_get_skb failed\\n\");\n\t\t\tbrcmf_sdio_rxfail(bus, false,\n\t\t\t\t\t    RETRYCHAN(rd->channel));\n\t\t\tsdio_release_host(bus->sdiodev->func1);\n\t\t\tcontinue;\n\t\t}\n\t\tskb_pull(pkt, head_read);\n\t\tpkt_align(pkt, rd->len_left, bus->head_align);\n\n\t\tret = brcmf_sdiod_recv_pkt(bus->sdiodev, pkt);\n\t\tbus->sdcnt.f2rxdata++;\n\t\tsdio_release_host(bus->sdiodev->func1);\n\n\t\tif (ret < 0) {\n\t\t\tbrcmf_err(\"read %d bytes from channel %d failed: %d\\n\",\n\t\t\t\t  rd->len, rd->channel, ret);\n\t\t\tbrcmu_pkt_buf_free_skb(pkt);\n\t\t\tsdio_claim_host(bus->sdiodev->func1);\n\t\t\tbrcmf_sdio_rxfail(bus, true,\n\t\t\t\t\t    RETRYCHAN(rd->channel));\n\t\t\tsdio_release_host(bus->sdiodev->func1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (head_read) {\n\t\t\tskb_push(pkt, head_read);\n\t\t\tmemcpy(pkt->data, bus->rxhdr, head_read);\n\t\t\thead_read = 0;\n\t\t} else {\n\t\t\tmemcpy(bus->rxhdr, pkt->data, SDPCM_HDRLEN);\n\t\t\trd_new.seq_num = rd->seq_num;\n\t\t\tsdio_claim_host(bus->sdiodev->func1);\n\t\t\tif (brcmf_sdio_hdparse(bus, bus->rxhdr, &rd_new,\n\t\t\t\t\t       BRCMF_SDIO_FT_NORMAL)) {\n\t\t\t\trd->len = 0;\n\t\t\t\tbrcmf_sdio_rxfail(bus, true, true);\n\t\t\t\tsdio_release_host(bus->sdiodev->func1);\n\t\t\t\tbrcmu_pkt_buf_free_skb(pkt);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbus->sdcnt.rx_readahead_cnt++;\n\t\t\tif (rd->len != roundup(rd_new.len, 16)) {\n\t\t\t\tbrcmf_err(\"frame length mismatch:read %d, should be %d\\n\",\n\t\t\t\t\t  rd->len,\n\t\t\t\t\t  roundup(rd_new.len, 16) >> 4);\n\t\t\t\trd->len = 0;\n\t\t\t\tbrcmf_sdio_rxfail(bus, true, true);\n\t\t\t\tsdio_release_host(bus->sdiodev->func1);\n\t\t\t\tbrcmu_pkt_buf_free_skb(pkt);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsdio_release_host(bus->sdiodev->func1);\n\t\t\trd->len_nxtfrm = rd_new.len_nxtfrm;\n\t\t\trd->channel = rd_new.channel;\n\t\t\trd->dat_offset = rd_new.dat_offset;\n\n\t\t\tbrcmf_dbg_hex_dump(!(BRCMF_BYTES_ON() &&\n\t\t\t\t\t     BRCMF_DATA_ON()) &&\n\t\t\t\t\t   BRCMF_HDRS_ON(),\n\t\t\t\t\t   bus->rxhdr, SDPCM_HDRLEN,\n\t\t\t\t\t   \"RxHdr:\\n\");\n\n\t\t\tif (rd_new.channel == SDPCM_CONTROL_CHANNEL) {\n\t\t\t\tbrcmf_err(\"readahead on control packet %d?\\n\",\n\t\t\t\t\t  rd_new.seq_num);\n\t\t\t\t \n\t\t\t\trd->len = 0;\n\t\t\t\tsdio_claim_host(bus->sdiodev->func1);\n\t\t\t\tbrcmf_sdio_rxfail(bus, false, true);\n\t\t\t\tsdio_release_host(bus->sdiodev->func1);\n\t\t\t\tbrcmu_pkt_buf_free_skb(pkt);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tbrcmf_dbg_hex_dump(BRCMF_BYTES_ON() && BRCMF_DATA_ON(),\n\t\t\t\t   pkt->data, rd->len, \"Rx Data:\\n\");\n\n\t\t \n\t\tif (rd->channel == SDPCM_GLOM_CHANNEL) {\n\t\t\tif (SDPCM_GLOMDESC(&bus->rxhdr[SDPCM_HWHDR_LEN])) {\n\t\t\t\tbrcmf_dbg(GLOM, \"glom descriptor, %d bytes:\\n\",\n\t\t\t\t\t  rd->len);\n\t\t\t\tbrcmf_dbg_hex_dump(BRCMF_GLOM_ON(),\n\t\t\t\t\t\t   pkt->data, rd->len,\n\t\t\t\t\t\t   \"Glom Data:\\n\");\n\t\t\t\t__skb_trim(pkt, rd->len);\n\t\t\t\tskb_pull(pkt, SDPCM_HDRLEN);\n\t\t\t\tbus->glomd = pkt;\n\t\t\t} else {\n\t\t\t\tbrcmf_err(\"%s: glom superframe w/o \"\n\t\t\t\t\t  \"descriptor!\\n\", __func__);\n\t\t\t\tsdio_claim_host(bus->sdiodev->func1);\n\t\t\t\tbrcmf_sdio_rxfail(bus, false, false);\n\t\t\t\tsdio_release_host(bus->sdiodev->func1);\n\t\t\t}\n\t\t\t \n\t\t\trd->len = rd->len_nxtfrm << 4;\n\t\t\trd->len_nxtfrm = 0;\n\t\t\t \n\t\t\trd->channel = SDPCM_EVENT_CHANNEL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\t__skb_trim(pkt, rd->len);\n\t\tskb_pull(pkt, rd->dat_offset);\n\n\t\tif (pkt->len == 0)\n\t\t\tbrcmu_pkt_buf_free_skb(pkt);\n\t\telse if (rd->channel == SDPCM_EVENT_CHANNEL)\n\t\t\tbrcmf_rx_event(bus->sdiodev->dev, pkt);\n\t\telse\n\t\t\tbrcmf_rx_frame(bus->sdiodev->dev, pkt,\n\t\t\t\t       false, false);\n\n\t\t \n\t\trd->len = rd->len_nxtfrm << 4;\n\t\trd->len_nxtfrm = 0;\n\t\t \n\t\trd->channel = SDPCM_EVENT_CHANNEL;\n\t}\n\n\trxcount = maxframes - rxleft;\n\t \n\tif (!rxleft)\n\t\tbrcmf_dbg(DATA, \"hit rx limit of %d frames\\n\", maxframes);\n\telse\n\t\tbrcmf_dbg(DATA, \"processed %d frames\\n\", rxcount);\n\t \n\tif (bus->rxskip)\n\t\trd->seq_num--;\n\tbus->rx_seq = rd->seq_num;\n\n\treturn rxcount;\n}\n\nstatic void\nbrcmf_sdio_wait_event_wakeup(struct brcmf_sdio *bus)\n{\n\twake_up_interruptible(&bus->ctrl_wait);\n\treturn;\n}\n\nstatic int brcmf_sdio_txpkt_hdalign(struct brcmf_sdio *bus, struct sk_buff *pkt)\n{\n\tstruct brcmf_bus_stats *stats;\n\tu16 head_pad;\n\tu8 *dat_buf;\n\n\tdat_buf = (u8 *)(pkt->data);\n\n\t \n\thead_pad = ((unsigned long)dat_buf % bus->head_align);\n\tif (head_pad) {\n\t\tif (skb_headroom(pkt) < head_pad) {\n\t\t\tstats = &bus->sdiodev->bus_if->stats;\n\t\t\tatomic_inc(&stats->pktcowed);\n\t\t\tif (skb_cow_head(pkt, head_pad)) {\n\t\t\t\tatomic_inc(&stats->pktcow_failed);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\thead_pad = 0;\n\t\t}\n\t\tskb_push(pkt, head_pad);\n\t\tdat_buf = (u8 *)(pkt->data);\n\t}\n\tmemset(dat_buf, 0, head_pad + bus->tx_hdrlen);\n\treturn head_pad;\n}\n\n \n \n#define ALIGN_SKB_FLAG\t\t0x8000\n \n#define ALIGN_SKB_CHOP_LEN_MASK\t0x7fff\n\nstatic int brcmf_sdio_txpkt_prep_sg(struct brcmf_sdio *bus,\n\t\t\t\t    struct sk_buff_head *pktq,\n\t\t\t\t    struct sk_buff *pkt, u16 total_len)\n{\n\tstruct brcmf_sdio_dev *sdiodev;\n\tstruct sk_buff *pkt_pad;\n\tu16 tail_pad, tail_chop, chain_pad;\n\tunsigned int blksize;\n\tbool lastfrm;\n\tint ntail, ret;\n\n\tsdiodev = bus->sdiodev;\n\tblksize = sdiodev->func2->cur_blksize;\n\t \n\tWARN_ON(blksize % bus->sgentry_align);\n\n\t \n\tlastfrm = skb_queue_is_last(pktq, pkt);\n\ttail_pad = 0;\n\ttail_chop = pkt->len % bus->sgentry_align;\n\tif (tail_chop)\n\t\ttail_pad = bus->sgentry_align - tail_chop;\n\tchain_pad = (total_len + tail_pad) % blksize;\n\tif (lastfrm && chain_pad)\n\t\ttail_pad += blksize - chain_pad;\n\tif (skb_tailroom(pkt) < tail_pad && pkt->len > blksize) {\n\t\tpkt_pad = brcmu_pkt_buf_get_skb(tail_pad + tail_chop +\n\t\t\t\t\t\tbus->head_align);\n\t\tif (pkt_pad == NULL)\n\t\t\treturn -ENOMEM;\n\t\tret = brcmf_sdio_txpkt_hdalign(bus, pkt_pad);\n\t\tif (unlikely(ret < 0)) {\n\t\t\tkfree_skb(pkt_pad);\n\t\t\treturn ret;\n\t\t}\n\t\tmemcpy(pkt_pad->data,\n\t\t       pkt->data + pkt->len - tail_chop,\n\t\t       tail_chop);\n\t\t*(u16 *)(pkt_pad->cb) = ALIGN_SKB_FLAG + tail_chop;\n\t\tskb_trim(pkt, pkt->len - tail_chop);\n\t\tskb_trim(pkt_pad, tail_pad + tail_chop);\n\t\t__skb_queue_after(pktq, pkt, pkt_pad);\n\t} else {\n\t\tntail = pkt->data_len + tail_pad -\n\t\t\t(pkt->end - pkt->tail);\n\t\tif (skb_cloned(pkt) || ntail > 0)\n\t\t\tif (pskb_expand_head(pkt, 0, ntail, GFP_ATOMIC))\n\t\t\t\treturn -ENOMEM;\n\t\tif (skb_linearize(pkt))\n\t\t\treturn -ENOMEM;\n\t\t__skb_put(pkt, tail_pad);\n\t}\n\n\treturn tail_pad;\n}\n\n \nstatic int\nbrcmf_sdio_txpkt_prep(struct brcmf_sdio *bus, struct sk_buff_head *pktq,\n\t\t      uint chan)\n{\n\tu16 head_pad, total_len;\n\tstruct sk_buff *pkt_next;\n\tu8 txseq;\n\tint ret;\n\tstruct brcmf_sdio_hdrinfo hd_info = {0};\n\n\ttxseq = bus->tx_seq;\n\ttotal_len = 0;\n\tskb_queue_walk(pktq, pkt_next) {\n\t\t \n\t\tif (*(u16 *)(pkt_next->cb) & ALIGN_SKB_FLAG)\n\t\t\tcontinue;\n\n\t\t \n\t\tret = brcmf_sdio_txpkt_hdalign(bus, pkt_next);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\thead_pad = (u16)ret;\n\t\tif (head_pad)\n\t\t\tmemset(pkt_next->data + bus->tx_hdrlen, 0, head_pad);\n\n\t\ttotal_len += pkt_next->len;\n\n\t\thd_info.len = pkt_next->len;\n\t\thd_info.lastfrm = skb_queue_is_last(pktq, pkt_next);\n\t\tif (bus->txglom && pktq->qlen > 1) {\n\t\t\tret = brcmf_sdio_txpkt_prep_sg(bus, pktq,\n\t\t\t\t\t\t       pkt_next, total_len);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\thd_info.tail_pad = (u16)ret;\n\t\t\ttotal_len += (u16)ret;\n\t\t}\n\n\t\thd_info.channel = chan;\n\t\thd_info.dat_offset = head_pad + bus->tx_hdrlen;\n\t\thd_info.seq_num = txseq++;\n\n\t\t \n\t\tbrcmf_sdio_hdpack(bus, pkt_next->data, &hd_info);\n\n\t\tif (BRCMF_BYTES_ON() &&\n\t\t    ((BRCMF_CTL_ON() && chan == SDPCM_CONTROL_CHANNEL) ||\n\t\t     (BRCMF_DATA_ON() && chan != SDPCM_CONTROL_CHANNEL)))\n\t\t\tbrcmf_dbg_hex_dump(true, pkt_next->data, hd_info.len,\n\t\t\t\t\t   \"Tx Frame:\\n\");\n\t\telse if (BRCMF_HDRS_ON())\n\t\t\tbrcmf_dbg_hex_dump(true, pkt_next->data,\n\t\t\t\t\t   head_pad + bus->tx_hdrlen,\n\t\t\t\t\t   \"Tx Header:\\n\");\n\t}\n\t \n\tif (bus->txglom)\n\t\tbrcmf_sdio_update_hwhdr(__skb_peek(pktq)->data, total_len);\n\treturn 0;\n}\n\n \nstatic void\nbrcmf_sdio_txpkt_postp(struct brcmf_sdio *bus, struct sk_buff_head *pktq)\n{\n\tu8 *hdr;\n\tu32 dat_offset;\n\tu16 tail_pad;\n\tu16 dummy_flags, chop_len;\n\tstruct sk_buff *pkt_next, *tmp, *pkt_prev;\n\n\tskb_queue_walk_safe(pktq, pkt_next, tmp) {\n\t\tdummy_flags = *(u16 *)(pkt_next->cb);\n\t\tif (dummy_flags & ALIGN_SKB_FLAG) {\n\t\t\tchop_len = dummy_flags & ALIGN_SKB_CHOP_LEN_MASK;\n\t\t\tif (chop_len) {\n\t\t\t\tpkt_prev = pkt_next->prev;\n\t\t\t\tskb_put(pkt_prev, chop_len);\n\t\t\t}\n\t\t\t__skb_unlink(pkt_next, pktq);\n\t\t\tbrcmu_pkt_buf_free_skb(pkt_next);\n\t\t} else {\n\t\t\thdr = pkt_next->data + bus->tx_hdrlen - SDPCM_SWHDR_LEN;\n\t\t\tdat_offset = le32_to_cpu(*(__le32 *)hdr);\n\t\t\tdat_offset = (dat_offset & SDPCM_DOFFSET_MASK) >>\n\t\t\t\t     SDPCM_DOFFSET_SHIFT;\n\t\t\tskb_pull(pkt_next, dat_offset);\n\t\t\tif (bus->txglom) {\n\t\t\t\ttail_pad = le16_to_cpu(*(__le16 *)(hdr - 2));\n\t\t\t\tskb_trim(pkt_next, pkt_next->len - tail_pad);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \n \nstatic int brcmf_sdio_txpkt(struct brcmf_sdio *bus, struct sk_buff_head *pktq,\n\t\t\t    uint chan)\n{\n\tint ret;\n\tstruct sk_buff *pkt_next, *tmp;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tret = brcmf_sdio_txpkt_prep(bus, pktq, chan);\n\tif (ret)\n\t\tgoto done;\n\n\tsdio_claim_host(bus->sdiodev->func1);\n\tret = brcmf_sdiod_send_pkt(bus->sdiodev, pktq);\n\tbus->sdcnt.f2txdata++;\n\n\tif (ret < 0)\n\t\tbrcmf_sdio_txfail(bus);\n\n\tsdio_release_host(bus->sdiodev->func1);\n\ndone:\n\tbrcmf_sdio_txpkt_postp(bus, pktq);\n\tif (ret == 0)\n\t\tbus->tx_seq = (bus->tx_seq + pktq->qlen) % SDPCM_SEQ_WRAP;\n\tskb_queue_walk_safe(pktq, pkt_next, tmp) {\n\t\t__skb_unlink(pkt_next, pktq);\n\t\tbrcmf_proto_bcdc_txcomplete(bus->sdiodev->dev, pkt_next,\n\t\t\t\t\t    ret == 0);\n\t}\n\treturn ret;\n}\n\nstatic uint brcmf_sdio_sendfromq(struct brcmf_sdio *bus, uint maxframes)\n{\n\tstruct sk_buff *pkt;\n\tstruct sk_buff_head pktq;\n\tu32 intstat_addr = bus->sdio_core->base + SD_REG(intstatus);\n\tu32 intstatus = 0;\n\tint ret = 0, prec_out, i;\n\tuint cnt = 0;\n\tu8 tx_prec_map, pkt_num;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\ttx_prec_map = ~bus->flowcontrol;\n\n\t \n\tfor (cnt = 0; (cnt < maxframes) && data_ok(bus);) {\n\t\tpkt_num = 1;\n\t\tif (bus->txglom)\n\t\t\tpkt_num = min_t(u8, bus->tx_max - bus->tx_seq,\n\t\t\t\t\tbus->sdiodev->txglomsz);\n\t\tpkt_num = min_t(u32, pkt_num,\n\t\t\t\tbrcmu_pktq_mlen(&bus->txq, ~bus->flowcontrol));\n\t\t__skb_queue_head_init(&pktq);\n\t\tspin_lock_bh(&bus->txq_lock);\n\t\tfor (i = 0; i < pkt_num; i++) {\n\t\t\tpkt = brcmu_pktq_mdeq(&bus->txq, tx_prec_map,\n\t\t\t\t\t      &prec_out);\n\t\t\tif (pkt == NULL)\n\t\t\t\tbreak;\n\t\t\t__skb_queue_tail(&pktq, pkt);\n\t\t}\n\t\tspin_unlock_bh(&bus->txq_lock);\n\t\tif (i == 0)\n\t\t\tbreak;\n\n\t\tret = brcmf_sdio_txpkt(bus, &pktq, SDPCM_DATA_CHANNEL);\n\n\t\tcnt += i;\n\n\t\t \n\t\tif (!bus->intr) {\n\t\t\t \n\t\t\tsdio_claim_host(bus->sdiodev->func1);\n\t\t\tintstatus = brcmf_sdiod_readl(bus->sdiodev,\n\t\t\t\t\t\t      intstat_addr, &ret);\n\t\t\tsdio_release_host(bus->sdiodev->func1);\n\n\t\t\tbus->sdcnt.f2txdata++;\n\t\t\tif (ret != 0)\n\t\t\t\tbreak;\n\t\t\tif (intstatus & bus->hostintmask)\n\t\t\t\tatomic_set(&bus->ipend, 1);\n\t\t}\n\t}\n\n\t \n\tif ((bus->sdiodev->state == BRCMF_SDIOD_DATA) &&\n\t    bus->txoff && (pktq_len(&bus->txq) < TXLOW)) {\n\t\tbus->txoff = false;\n\t\tbrcmf_proto_bcdc_txflowblock(bus->sdiodev->dev, false);\n\t}\n\n\treturn cnt;\n}\n\nstatic int brcmf_sdio_tx_ctrlframe(struct brcmf_sdio *bus, u8 *frame, u16 len)\n{\n\tu8 doff;\n\tu16 pad;\n\tuint retries = 0;\n\tstruct brcmf_sdio_hdrinfo hd_info = {0};\n\tint ret;\n\n\tbrcmf_dbg(SDIO, \"Enter\\n\");\n\n\t \n\tframe -= bus->tx_hdrlen;\n\tlen += bus->tx_hdrlen;\n\n\t \n\tdoff = ((unsigned long)frame % bus->head_align);\n\tif (doff) {\n\t\tframe -= doff;\n\t\tlen += doff;\n\t\tmemset(frame + bus->tx_hdrlen, 0, doff);\n\t}\n\n\t \n\tpad = 0;\n\tif (bus->roundup && bus->blocksize && (len > bus->blocksize)) {\n\t\tpad = bus->blocksize - (len % bus->blocksize);\n\t\tif ((pad > bus->roundup) || (pad >= bus->blocksize))\n\t\t\tpad = 0;\n\t} else if (len % bus->head_align) {\n\t\tpad = bus->head_align - (len % bus->head_align);\n\t}\n\tlen += pad;\n\n\thd_info.len = len - pad;\n\thd_info.channel = SDPCM_CONTROL_CHANNEL;\n\thd_info.dat_offset = doff + bus->tx_hdrlen;\n\thd_info.seq_num = bus->tx_seq;\n\thd_info.lastfrm = true;\n\thd_info.tail_pad = pad;\n\tbrcmf_sdio_hdpack(bus, frame, &hd_info);\n\n\tif (bus->txglom)\n\t\tbrcmf_sdio_update_hwhdr(frame, len);\n\n\tbrcmf_dbg_hex_dump(BRCMF_BYTES_ON() && BRCMF_CTL_ON(),\n\t\t\t   frame, len, \"Tx Frame:\\n\");\n\tbrcmf_dbg_hex_dump(!(BRCMF_BYTES_ON() && BRCMF_CTL_ON()) &&\n\t\t\t   BRCMF_HDRS_ON(),\n\t\t\t   frame, min_t(u16, len, 16), \"TxHdr:\\n\");\n\n\tdo {\n\t\tret = brcmf_sdiod_send_buf(bus->sdiodev, frame, len);\n\n\t\tif (ret < 0)\n\t\t\tbrcmf_sdio_txfail(bus);\n\t\telse\n\t\t\tbus->tx_seq = (bus->tx_seq + 1) % SDPCM_SEQ_WRAP;\n\t} while (ret < 0 && retries++ < TXRETRIES);\n\n\treturn ret;\n}\n\nstatic bool brcmf_chip_is_ulp(struct brcmf_chip *ci)\n{\n\tif (ci->chip == CY_CC_43012_CHIP_ID)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic void brcmf_sdio_bus_stop(struct device *dev)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;\n\tstruct brcmf_sdio *bus = sdiodev->bus;\n\tstruct brcmf_core *core = bus->sdio_core;\n\tu32 local_hostintmask;\n\tu8 saveclk, bpreq;\n\tint err;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tif (bus->watchdog_tsk) {\n\t\tsend_sig(SIGTERM, bus->watchdog_tsk, 1);\n\t\tkthread_stop(bus->watchdog_tsk);\n\t\tbus->watchdog_tsk = NULL;\n\t}\n\n\tif (sdiodev->state != BRCMF_SDIOD_NOMEDIUM) {\n\t\tsdio_claim_host(sdiodev->func1);\n\n\t\t \n\t\tbrcmf_sdio_bus_sleep(bus, false, false);\n\n\t\t \n\t\tbrcmf_sdiod_writel(sdiodev, core->base + SD_REG(hostintmask),\n\t\t\t\t   0, NULL);\n\n\t\tlocal_hostintmask = bus->hostintmask;\n\t\tbus->hostintmask = 0;\n\n\t\t \n\t\tsaveclk = brcmf_sdiod_readb(sdiodev, SBSDIO_FUNC1_CHIPCLKCSR,\n\t\t\t\t\t    &err);\n\t\tif (!err) {\n\t\t\tbpreq = saveclk;\n\t\t\tbpreq |= brcmf_chip_is_ulp(bus->ci) ?\n\t\t\t\tSBSDIO_HT_AVAIL_REQ : SBSDIO_FORCE_HT;\n\t\t\tbrcmf_sdiod_writeb(sdiodev,\n\t\t\t\t\t   SBSDIO_FUNC1_CHIPCLKCSR,\n\t\t\t\t\t   bpreq, &err);\n\t\t}\n\t\tif (err)\n\t\t\tbrcmf_err(\"Failed to force clock for F2: err %d\\n\",\n\t\t\t\t  err);\n\n\t\t \n\t\tbrcmf_dbg(INTR, \"disable SDIO interrupts\\n\");\n\t\tsdio_disable_func(sdiodev->func2);\n\n\t\t \n\t\tbrcmf_sdiod_writel(sdiodev, core->base + SD_REG(intstatus),\n\t\t\t\t   local_hostintmask, NULL);\n\n\t\tsdio_release_host(sdiodev->func1);\n\t}\n\t \n\tbrcmu_pktq_flush(&bus->txq, true, NULL, NULL);\n\n\t \n\tbrcmu_pkt_buf_free_skb(bus->glomd);\n\tbrcmf_sdio_free_glom(bus);\n\n\t \n\tspin_lock_bh(&bus->rxctl_lock);\n\tbus->rxlen = 0;\n\tspin_unlock_bh(&bus->rxctl_lock);\n\tbrcmf_sdio_dcmd_resp_wake(bus);\n\n\t \n\tbus->rxskip = false;\n\tbus->tx_seq = bus->rx_seq = 0;\n}\n\nstatic inline void brcmf_sdio_clrintr(struct brcmf_sdio *bus)\n{\n\tstruct brcmf_sdio_dev *sdiodev;\n\tunsigned long flags;\n\n\tsdiodev = bus->sdiodev;\n\tif (sdiodev->oob_irq_requested) {\n\t\tspin_lock_irqsave(&sdiodev->irq_en_lock, flags);\n\t\tif (!sdiodev->irq_en && !atomic_read(&bus->ipend)) {\n\t\t\tenable_irq(sdiodev->settings->bus.sdio.oob_irq_nr);\n\t\t\tsdiodev->irq_en = true;\n\t\t}\n\t\tspin_unlock_irqrestore(&sdiodev->irq_en_lock, flags);\n\t}\n}\n\nstatic int brcmf_sdio_intr_rstatus(struct brcmf_sdio *bus)\n{\n\tstruct brcmf_core *core = bus->sdio_core;\n\tu32 addr;\n\tunsigned long val;\n\tint ret;\n\n\taddr = core->base + SD_REG(intstatus);\n\n\tval = brcmf_sdiod_readl(bus->sdiodev, addr, &ret);\n\tbus->sdcnt.f1regdata++;\n\tif (ret != 0)\n\t\treturn ret;\n\n\tval &= bus->hostintmask;\n\tatomic_set(&bus->fcstate, !!(val & I_HMB_FC_STATE));\n\n\t \n\tif (val) {\n\t\tbrcmf_sdiod_writel(bus->sdiodev, addr, val, &ret);\n\t\tbus->sdcnt.f1regdata++;\n\t\tatomic_or(val, &bus->intstatus);\n\t}\n\n\treturn ret;\n}\n\nstatic void brcmf_sdio_dpc(struct brcmf_sdio *bus)\n{\n\tstruct brcmf_sdio_dev *sdiod = bus->sdiodev;\n\tu32 newstatus = 0;\n\tu32 intstat_addr = bus->sdio_core->base + SD_REG(intstatus);\n\tunsigned long intstatus;\n\tuint txlimit = bus->txbound;\t \n\tuint framecnt;\t\t\t \n\tint err = 0;\n\n\tbrcmf_dbg(SDIO, \"Enter\\n\");\n\n\tsdio_claim_host(bus->sdiodev->func1);\n\n\t \n\tif (!bus->sr_enabled && bus->clkstate == CLK_PENDING) {\n\t\tu8 clkctl, devctl = 0;\n\n#ifdef DEBUG\n\t\t \n\t\tdevctl = brcmf_sdiod_readb(bus->sdiodev, SBSDIO_DEVICE_CTL,\n\t\t\t\t\t   &err);\n#endif\t\t\t\t \n\n\t\t \n\t\tclkctl = brcmf_sdiod_readb(bus->sdiodev,\n\t\t\t\t\t   SBSDIO_FUNC1_CHIPCLKCSR, &err);\n\n\t\tbrcmf_dbg(SDIO, \"DPC: PENDING, devctl 0x%02x clkctl 0x%02x\\n\",\n\t\t\t  devctl, clkctl);\n\n\t\tif (SBSDIO_HTAV(clkctl)) {\n\t\t\tdevctl = brcmf_sdiod_readb(bus->sdiodev,\n\t\t\t\t\t\t   SBSDIO_DEVICE_CTL, &err);\n\t\t\tdevctl &= ~SBSDIO_DEVCTL_CA_INT_ONLY;\n\t\t\tbrcmf_sdiod_writeb(bus->sdiodev,\n\t\t\t\t\t   SBSDIO_DEVICE_CTL, devctl, &err);\n\t\t\tbus->clkstate = CLK_AVAIL;\n\t\t}\n\t}\n\n\t \n\tbrcmf_sdio_bus_sleep(bus, false, true);\n\n\t \n\tif (atomic_read(&bus->ipend) > 0) {\n\t\tatomic_set(&bus->ipend, 0);\n\t\terr = brcmf_sdio_intr_rstatus(bus);\n\t}\n\n\t \n\tintstatus = atomic_xchg(&bus->intstatus, 0);\n\n\t \n\tif (intstatus & I_HMB_FC_CHANGE) {\n\t\tintstatus &= ~I_HMB_FC_CHANGE;\n\t\tbrcmf_sdiod_writel(sdiod, intstat_addr, I_HMB_FC_CHANGE, &err);\n\n\t\tnewstatus = brcmf_sdiod_readl(sdiod, intstat_addr, &err);\n\n\t\tbus->sdcnt.f1regdata += 2;\n\t\tatomic_set(&bus->fcstate,\n\t\t\t   !!(newstatus & (I_HMB_FC_STATE | I_HMB_FC_CHANGE)));\n\t\tintstatus |= (newstatus & bus->hostintmask);\n\t}\n\n\t \n\tif (intstatus & I_HMB_HOST_INT) {\n\t\tintstatus &= ~I_HMB_HOST_INT;\n\t\tintstatus |= brcmf_sdio_hostmail(bus);\n\t}\n\n\tsdio_release_host(bus->sdiodev->func1);\n\n\t \n\tif (intstatus & I_WR_OOSYNC) {\n\t\tbrcmf_err(\"Dongle reports WR_OOSYNC\\n\");\n\t\tintstatus &= ~I_WR_OOSYNC;\n\t}\n\n\tif (intstatus & I_RD_OOSYNC) {\n\t\tbrcmf_err(\"Dongle reports RD_OOSYNC\\n\");\n\t\tintstatus &= ~I_RD_OOSYNC;\n\t}\n\n\tif (intstatus & I_SBINT) {\n\t\tbrcmf_err(\"Dongle reports SBINT\\n\");\n\t\tintstatus &= ~I_SBINT;\n\t}\n\n\t \n\tif (intstatus & I_CHIPACTIVE) {\n\t\tbrcmf_dbg(SDIO, \"Dongle reports CHIPACTIVE\\n\");\n\t\tintstatus &= ~I_CHIPACTIVE;\n\t}\n\n\t \n\tif (bus->rxskip)\n\t\tintstatus &= ~I_HMB_FRAME_IND;\n\n\t \n\tif ((intstatus & I_HMB_FRAME_IND) && (bus->clkstate == CLK_AVAIL)) {\n\t\tbrcmf_sdio_readframes(bus, bus->rxbound);\n\t\tif (!bus->rxpending)\n\t\t\tintstatus &= ~I_HMB_FRAME_IND;\n\t}\n\n\t \n\tif (intstatus)\n\t\tatomic_or(intstatus, &bus->intstatus);\n\n\tbrcmf_sdio_clrintr(bus);\n\n\tif (bus->ctrl_frame_stat && (bus->clkstate == CLK_AVAIL) &&\n\t    txctl_ok(bus)) {\n\t\tsdio_claim_host(bus->sdiodev->func1);\n\t\tif (bus->ctrl_frame_stat) {\n\t\t\terr = brcmf_sdio_tx_ctrlframe(bus,  bus->ctrl_frame_buf,\n\t\t\t\t\t\t      bus->ctrl_frame_len);\n\t\t\tbus->ctrl_frame_err = err;\n\t\t\twmb();\n\t\t\tbus->ctrl_frame_stat = false;\n\t\t\tif (err)\n\t\t\t\tbrcmf_err(\"sdio ctrlframe tx failed err=%d\\n\",\n\t\t\t\t\t  err);\n\t\t}\n\t\tsdio_release_host(bus->sdiodev->func1);\n\t\tbrcmf_sdio_wait_event_wakeup(bus);\n\t}\n\t \n\tif ((bus->clkstate == CLK_AVAIL) && !atomic_read(&bus->fcstate) &&\n\t    brcmu_pktq_mlen(&bus->txq, ~bus->flowcontrol) && txlimit &&\n\t    data_ok(bus)) {\n\t\tframecnt = bus->rxpending ? min(txlimit, bus->txminmax) :\n\t\t\t\t\t    txlimit;\n\t\tbrcmf_sdio_sendfromq(bus, framecnt);\n\t}\n\n\tif ((bus->sdiodev->state != BRCMF_SDIOD_DATA) || (err != 0)) {\n\t\tbrcmf_err(\"failed backplane access over SDIO, halting operation\\n\");\n\t\tatomic_set(&bus->intstatus, 0);\n\t\tif (bus->ctrl_frame_stat) {\n\t\t\tsdio_claim_host(bus->sdiodev->func1);\n\t\t\tif (bus->ctrl_frame_stat) {\n\t\t\t\tbus->ctrl_frame_err = -ENODEV;\n\t\t\t\twmb();\n\t\t\t\tbus->ctrl_frame_stat = false;\n\t\t\t\tbrcmf_sdio_wait_event_wakeup(bus);\n\t\t\t}\n\t\t\tsdio_release_host(bus->sdiodev->func1);\n\t\t}\n\t} else if (atomic_read(&bus->intstatus) ||\n\t\t   atomic_read(&bus->ipend) > 0 ||\n\t\t   (!atomic_read(&bus->fcstate) &&\n\t\t    brcmu_pktq_mlen(&bus->txq, ~bus->flowcontrol) &&\n\t\t    data_ok(bus))) {\n\t\tbus->dpc_triggered = true;\n\t}\n}\n\nstatic struct pktq *brcmf_sdio_bus_gettxq(struct device *dev)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;\n\tstruct brcmf_sdio *bus = sdiodev->bus;\n\n\treturn &bus->txq;\n}\n\nstatic bool brcmf_sdio_prec_enq(struct pktq *q, struct sk_buff *pkt, int prec)\n{\n\tstruct sk_buff *p;\n\tint eprec = -1;\t\t \n\n\t \n\tif (!pktq_pfull(q, prec) && !pktq_full(q)) {\n\t\tbrcmu_pktq_penq(q, prec, pkt);\n\t\treturn true;\n\t}\n\n\t \n\tif (pktq_pfull(q, prec)) {\n\t\teprec = prec;\n\t} else if (pktq_full(q)) {\n\t\tp = brcmu_pktq_peek_tail(q, &eprec);\n\t\tif (eprec > prec)\n\t\t\treturn false;\n\t}\n\n\t \n\tif (eprec >= 0) {\n\t\t \n\t\tif (eprec == prec)\n\t\t\treturn false;\t \n\t\t \n\t\tp = brcmu_pktq_pdeq_tail(q, eprec);\n\t\tif (p == NULL)\n\t\t\tbrcmf_err(\"brcmu_pktq_pdeq_tail() failed\\n\");\n\t\tbrcmu_pkt_buf_free_skb(p);\n\t}\n\n\t \n\tp = brcmu_pktq_penq(q, prec, pkt);\n\tif (p == NULL)\n\t\tbrcmf_err(\"brcmu_pktq_penq() failed\\n\");\n\n\treturn p != NULL;\n}\n\nstatic int brcmf_sdio_bus_txdata(struct device *dev, struct sk_buff *pkt)\n{\n\tint ret = -EBADE;\n\tuint prec;\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;\n\tstruct brcmf_sdio *bus = sdiodev->bus;\n\n\tbrcmf_dbg(TRACE, \"Enter: pkt: data %p len %d\\n\", pkt->data, pkt->len);\n\tif (sdiodev->state != BRCMF_SDIOD_DATA)\n\t\treturn -EIO;\n\n\t \n\tskb_push(pkt, bus->tx_hdrlen);\n\t \n\n\t \n\tprec = brcmf_map_prio_to_prec(bus_if->drvr->config,\n\t\t\t\t      (pkt->priority & PRIOMASK));\n\n\t \n\tbrcmf_dbg(TRACE, \"deferring pktq len %d\\n\", pktq_len(&bus->txq));\n\tbus->sdcnt.fcqueued++;\n\n\t \n\tspin_lock_bh(&bus->txq_lock);\n\t \n\t*(u16 *)(pkt->cb) = 0;\n\tif (!brcmf_sdio_prec_enq(&bus->txq, pkt, prec)) {\n\t\tskb_pull(pkt, bus->tx_hdrlen);\n\t\tbrcmf_err(\"out of bus->txq !!!\\n\");\n\t\tret = -ENOSR;\n\t} else {\n\t\tret = 0;\n\t}\n\n\tif (pktq_len(&bus->txq) >= TXHI) {\n\t\tbus->txoff = true;\n\t\tbrcmf_proto_bcdc_txflowblock(dev, true);\n\t}\n\tspin_unlock_bh(&bus->txq_lock);\n\n#ifdef DEBUG\n\tif (pktq_plen(&bus->txq, prec) > qcount[prec])\n\t\tqcount[prec] = pktq_plen(&bus->txq, prec);\n#endif\n\n\tbrcmf_sdio_trigger_dpc(bus);\n\treturn ret;\n}\n\n#ifdef DEBUG\n#define CONSOLE_LINE_MAX\t192\n\nstatic int brcmf_sdio_readconsole(struct brcmf_sdio *bus)\n{\n\tstruct brcmf_console *c = &bus->console;\n\tu8 line[CONSOLE_LINE_MAX], ch;\n\tu32 n, idx, addr;\n\tint rv;\n\n\t \n\tif (bus->console_addr == 0)\n\t\treturn 0;\n\n\t \n\taddr = bus->console_addr + offsetof(struct rte_console, log_le);\n\trv = brcmf_sdiod_ramrw(bus->sdiodev, false, addr, (u8 *)&c->log_le,\n\t\t\t       sizeof(c->log_le));\n\tif (rv < 0)\n\t\treturn rv;\n\n\t \n\tif (c->buf == NULL) {\n\t\tc->bufsize = le32_to_cpu(c->log_le.buf_size);\n\t\tc->buf = kmalloc(c->bufsize, GFP_ATOMIC);\n\t\tif (c->buf == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tidx = le32_to_cpu(c->log_le.idx);\n\n\t \n\tif (idx > c->bufsize)\n\t\treturn -EBADE;\n\n\t \n\tif (idx == c->last)\n\t\treturn 0;\n\n\t \n\taddr = le32_to_cpu(c->log_le.buf);\n\trv = brcmf_sdiod_ramrw(bus->sdiodev, false, addr, c->buf, c->bufsize);\n\tif (rv < 0)\n\t\treturn rv;\n\n\twhile (c->last != idx) {\n\t\tfor (n = 0; n < CONSOLE_LINE_MAX - 2; n++) {\n\t\t\tif (c->last == idx) {\n\t\t\t\t \n\t\t\t\tif (c->last >= n)\n\t\t\t\t\tc->last -= n;\n\t\t\t\telse\n\t\t\t\t\tc->last = c->bufsize - n;\n\t\t\t\tgoto break2;\n\t\t\t}\n\t\t\tch = c->buf[c->last];\n\t\t\tc->last = (c->last + 1) % c->bufsize;\n\t\t\tif (ch == '\\n')\n\t\t\t\tbreak;\n\t\t\tline[n] = ch;\n\t\t}\n\n\t\tif (n > 0) {\n\t\t\tif (line[n - 1] == '\\r')\n\t\t\t\tn--;\n\t\t\tline[n] = 0;\n\t\t\tpr_debug(\"CONSOLE: %s\\n\", line);\n\t\t}\n\t}\nbreak2:\n\n\treturn 0;\n}\n#endif\t\t\t\t \n\nstatic int\nbrcmf_sdio_bus_txctl(struct device *dev, unsigned char *msg, uint msglen)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;\n\tstruct brcmf_sdio *bus = sdiodev->bus;\n\tint ret;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (sdiodev->state != BRCMF_SDIOD_DATA)\n\t\treturn -EIO;\n\n\t \n\tbus->ctrl_frame_buf = msg;\n\tbus->ctrl_frame_len = msglen;\n\twmb();\n\tbus->ctrl_frame_stat = true;\n\n\tbrcmf_sdio_trigger_dpc(bus);\n\twait_event_interruptible_timeout(bus->ctrl_wait, !bus->ctrl_frame_stat,\n\t\t\t\t\t CTL_DONE_TIMEOUT);\n\tret = 0;\n\tif (bus->ctrl_frame_stat) {\n\t\tsdio_claim_host(bus->sdiodev->func1);\n\t\tif (bus->ctrl_frame_stat) {\n\t\t\tbrcmf_dbg(SDIO, \"ctrl_frame timeout\\n\");\n\t\t\tbus->ctrl_frame_stat = false;\n\t\t\tret = -ETIMEDOUT;\n\t\t}\n\t\tsdio_release_host(bus->sdiodev->func1);\n\t}\n\tif (!ret) {\n\t\tbrcmf_dbg(SDIO, \"ctrl_frame complete, err=%d\\n\",\n\t\t\t  bus->ctrl_frame_err);\n\t\trmb();\n\t\tret = bus->ctrl_frame_err;\n\t}\n\n\tif (ret)\n\t\tbus->sdcnt.tx_ctlerrs++;\n\telse\n\t\tbus->sdcnt.tx_ctlpkts++;\n\n\treturn ret;\n}\n\n#ifdef DEBUG\nstatic int brcmf_sdio_dump_console(struct seq_file *seq, struct brcmf_sdio *bus,\n\t\t\t\t   struct sdpcm_shared *sh)\n{\n\tu32 addr, console_ptr, console_size, console_index;\n\tchar *conbuf = NULL;\n\t__le32 sh_val;\n\tint rv;\n\n\t \n\taddr = sh->console_addr + offsetof(struct rte_console, log_le);\n\trv = brcmf_sdiod_ramrw(bus->sdiodev, false, addr,\n\t\t\t       (u8 *)&sh_val, sizeof(u32));\n\tif (rv < 0)\n\t\treturn rv;\n\tconsole_ptr = le32_to_cpu(sh_val);\n\n\taddr = sh->console_addr + offsetof(struct rte_console, log_le.buf_size);\n\trv = brcmf_sdiod_ramrw(bus->sdiodev, false, addr,\n\t\t\t       (u8 *)&sh_val, sizeof(u32));\n\tif (rv < 0)\n\t\treturn rv;\n\tconsole_size = le32_to_cpu(sh_val);\n\n\taddr = sh->console_addr + offsetof(struct rte_console, log_le.idx);\n\trv = brcmf_sdiod_ramrw(bus->sdiodev, false, addr,\n\t\t\t       (u8 *)&sh_val, sizeof(u32));\n\tif (rv < 0)\n\t\treturn rv;\n\tconsole_index = le32_to_cpu(sh_val);\n\n\t \n\tif (console_size <= CONSOLE_BUFFER_MAX)\n\t\tconbuf = vzalloc(console_size+1);\n\n\tif (!conbuf)\n\t\treturn -ENOMEM;\n\n\t \n\tconbuf[console_size] = '\\0';\n\trv = brcmf_sdiod_ramrw(bus->sdiodev, false, console_ptr, (u8 *)conbuf,\n\t\t\t       console_size);\n\tif (rv < 0)\n\t\tgoto done;\n\n\trv = seq_write(seq, conbuf + console_index,\n\t\t       console_size - console_index);\n\tif (rv < 0)\n\t\tgoto done;\n\n\tif (console_index > 0)\n\t\trv = seq_write(seq, conbuf, console_index - 1);\n\ndone:\n\tvfree(conbuf);\n\treturn rv;\n}\n\nstatic int brcmf_sdio_trap_info(struct seq_file *seq, struct brcmf_sdio *bus,\n\t\t\t\tstruct sdpcm_shared *sh)\n{\n\tint error;\n\tstruct brcmf_trap_info tr;\n\n\tif ((sh->flags & SDPCM_SHARED_TRAP) == 0) {\n\t\tbrcmf_dbg(INFO, \"no trap in firmware\\n\");\n\t\treturn 0;\n\t}\n\n\terror = brcmf_sdiod_ramrw(bus->sdiodev, false, sh->trap_addr, (u8 *)&tr,\n\t\t\t\t  sizeof(struct brcmf_trap_info));\n\tif (error < 0)\n\t\treturn error;\n\n\tif (seq)\n\t\tseq_printf(seq,\n\t\t\t   \"dongle trap info: type 0x%x @ epc 0x%08x\\n\"\n\t\t\t   \"  cpsr 0x%08x spsr 0x%08x sp 0x%08x\\n\"\n\t\t\t   \"  lr   0x%08x pc   0x%08x offset 0x%x\\n\"\n\t\t\t   \"  r0   0x%08x r1   0x%08x r2 0x%08x r3 0x%08x\\n\"\n\t\t\t   \"  r4   0x%08x r5   0x%08x r6 0x%08x r7 0x%08x\\n\",\n\t\t\t   le32_to_cpu(tr.type), le32_to_cpu(tr.epc),\n\t\t\t   le32_to_cpu(tr.cpsr), le32_to_cpu(tr.spsr),\n\t\t\t   le32_to_cpu(tr.r13), le32_to_cpu(tr.r14),\n\t\t\t   le32_to_cpu(tr.pc), sh->trap_addr,\n\t\t\t   le32_to_cpu(tr.r0), le32_to_cpu(tr.r1),\n\t\t\t   le32_to_cpu(tr.r2), le32_to_cpu(tr.r3),\n\t\t\t   le32_to_cpu(tr.r4), le32_to_cpu(tr.r5),\n\t\t\t   le32_to_cpu(tr.r6), le32_to_cpu(tr.r7));\n\telse\n\t\tpr_debug(\"dongle trap info: type 0x%x @ epc 0x%08x\\n\"\n\t\t\t \"  cpsr 0x%08x spsr 0x%08x sp 0x%08x\\n\"\n\t\t\t \"  lr   0x%08x pc   0x%08x offset 0x%x\\n\"\n\t\t\t \"  r0   0x%08x r1   0x%08x r2 0x%08x r3 0x%08x\\n\"\n\t\t\t \"  r4   0x%08x r5   0x%08x r6 0x%08x r7 0x%08x\\n\",\n\t\t\t le32_to_cpu(tr.type), le32_to_cpu(tr.epc),\n\t\t\t le32_to_cpu(tr.cpsr), le32_to_cpu(tr.spsr),\n\t\t\t le32_to_cpu(tr.r13), le32_to_cpu(tr.r14),\n\t\t\t le32_to_cpu(tr.pc), sh->trap_addr,\n\t\t\t le32_to_cpu(tr.r0), le32_to_cpu(tr.r1),\n\t\t\t le32_to_cpu(tr.r2), le32_to_cpu(tr.r3),\n\t\t\t le32_to_cpu(tr.r4), le32_to_cpu(tr.r5),\n\t\t\t le32_to_cpu(tr.r6), le32_to_cpu(tr.r7));\n\treturn 0;\n}\n\nstatic int brcmf_sdio_assert_info(struct seq_file *seq, struct brcmf_sdio *bus,\n\t\t\t\t  struct sdpcm_shared *sh)\n{\n\tint error = 0;\n\tchar file[80] = \"?\";\n\tchar expr[80] = \"<???>\";\n\n\tif ((sh->flags & SDPCM_SHARED_ASSERT_BUILT) == 0) {\n\t\tbrcmf_dbg(INFO, \"firmware not built with -assert\\n\");\n\t\treturn 0;\n\t} else if ((sh->flags & SDPCM_SHARED_ASSERT) == 0) {\n\t\tbrcmf_dbg(INFO, \"no assert in dongle\\n\");\n\t\treturn 0;\n\t}\n\n\tsdio_claim_host(bus->sdiodev->func1);\n\tif (sh->assert_file_addr != 0) {\n\t\terror = brcmf_sdiod_ramrw(bus->sdiodev, false,\n\t\t\t\t\t  sh->assert_file_addr, (u8 *)file, 80);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\tif (sh->assert_exp_addr != 0) {\n\t\terror = brcmf_sdiod_ramrw(bus->sdiodev, false,\n\t\t\t\t\t  sh->assert_exp_addr, (u8 *)expr, 80);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\tsdio_release_host(bus->sdiodev->func1);\n\n\tseq_printf(seq, \"dongle assert: %s:%d: assert(%s)\\n\",\n\t\t   file, sh->assert_line, expr);\n\treturn 0;\n}\n\nstatic int brcmf_sdio_checkdied(struct brcmf_sdio *bus)\n{\n\tint error;\n\tstruct sdpcm_shared sh;\n\n\terror = brcmf_sdio_readshared(bus, &sh);\n\n\tif (error < 0)\n\t\treturn error;\n\n\tif ((sh.flags & SDPCM_SHARED_ASSERT_BUILT) == 0)\n\t\tbrcmf_dbg(INFO, \"firmware not built with -assert\\n\");\n\telse if (sh.flags & SDPCM_SHARED_ASSERT)\n\t\tbrcmf_err(\"assertion in dongle\\n\");\n\n\tif (sh.flags & SDPCM_SHARED_TRAP) {\n\t\tbrcmf_err(\"firmware trap in dongle\\n\");\n\t\tbrcmf_sdio_trap_info(NULL, bus, &sh);\n\t}\n\n\treturn 0;\n}\n\nstatic int brcmf_sdio_died_dump(struct seq_file *seq, struct brcmf_sdio *bus)\n{\n\tint error = 0;\n\tstruct sdpcm_shared sh;\n\n\terror = brcmf_sdio_readshared(bus, &sh);\n\tif (error < 0)\n\t\tgoto done;\n\n\terror = brcmf_sdio_assert_info(seq, bus, &sh);\n\tif (error < 0)\n\t\tgoto done;\n\n\terror = brcmf_sdio_trap_info(seq, bus, &sh);\n\tif (error < 0)\n\t\tgoto done;\n\n\terror = brcmf_sdio_dump_console(seq, bus, &sh);\n\ndone:\n\treturn error;\n}\n\nstatic int brcmf_sdio_forensic_read(struct seq_file *seq, void *data)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(seq->private);\n\tstruct brcmf_sdio *bus = bus_if->bus_priv.sdio->bus;\n\n\treturn brcmf_sdio_died_dump(seq, bus);\n}\n\nstatic int brcmf_debugfs_sdio_count_read(struct seq_file *seq, void *data)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(seq->private);\n\tstruct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;\n\tstruct brcmf_sdio_count *sdcnt = &sdiodev->bus->sdcnt;\n\n\tseq_printf(seq,\n\t\t   \"intrcount:    %u\\nlastintrs:    %u\\n\"\n\t\t   \"pollcnt:      %u\\nregfails:     %u\\n\"\n\t\t   \"tx_sderrs:    %u\\nfcqueued:     %u\\n\"\n\t\t   \"rxrtx:        %u\\nrx_toolong:   %u\\n\"\n\t\t   \"rxc_errors:   %u\\nrx_hdrfail:   %u\\n\"\n\t\t   \"rx_badhdr:    %u\\nrx_badseq:    %u\\n\"\n\t\t   \"fc_rcvd:      %u\\nfc_xoff:      %u\\n\"\n\t\t   \"fc_xon:       %u\\nrxglomfail:   %u\\n\"\n\t\t   \"rxglomframes: %u\\nrxglompkts:   %u\\n\"\n\t\t   \"f2rxhdrs:     %u\\nf2rxdata:     %u\\n\"\n\t\t   \"f2txdata:     %u\\nf1regdata:    %u\\n\"\n\t\t   \"tickcnt:      %u\\ntx_ctlerrs:   %lu\\n\"\n\t\t   \"tx_ctlpkts:   %lu\\nrx_ctlerrs:   %lu\\n\"\n\t\t   \"rx_ctlpkts:   %lu\\nrx_readahead: %lu\\n\",\n\t\t   sdcnt->intrcount, sdcnt->lastintrs,\n\t\t   sdcnt->pollcnt, sdcnt->regfails,\n\t\t   sdcnt->tx_sderrs, sdcnt->fcqueued,\n\t\t   sdcnt->rxrtx, sdcnt->rx_toolong,\n\t\t   sdcnt->rxc_errors, sdcnt->rx_hdrfail,\n\t\t   sdcnt->rx_badhdr, sdcnt->rx_badseq,\n\t\t   sdcnt->fc_rcvd, sdcnt->fc_xoff,\n\t\t   sdcnt->fc_xon, sdcnt->rxglomfail,\n\t\t   sdcnt->rxglomframes, sdcnt->rxglompkts,\n\t\t   sdcnt->f2rxhdrs, sdcnt->f2rxdata,\n\t\t   sdcnt->f2txdata, sdcnt->f1regdata,\n\t\t   sdcnt->tickcnt, sdcnt->tx_ctlerrs,\n\t\t   sdcnt->tx_ctlpkts, sdcnt->rx_ctlerrs,\n\t\t   sdcnt->rx_ctlpkts, sdcnt->rx_readahead_cnt);\n\n\treturn 0;\n}\n\nstatic void brcmf_sdio_debugfs_create(struct device *dev)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_pub *drvr = bus_if->drvr;\n\tstruct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;\n\tstruct brcmf_sdio *bus = sdiodev->bus;\n\tstruct dentry *dentry = brcmf_debugfs_get_devdir(drvr);\n\n\tif (IS_ERR_OR_NULL(dentry))\n\t\treturn;\n\n\tbus->console_interval = BRCMF_CONSOLE;\n\n\tbrcmf_debugfs_add_entry(drvr, \"forensics\", brcmf_sdio_forensic_read);\n\tbrcmf_debugfs_add_entry(drvr, \"counters\",\n\t\t\t\tbrcmf_debugfs_sdio_count_read);\n\tdebugfs_create_u32(\"console_interval\", 0644, dentry,\n\t\t\t   &bus->console_interval);\n}\n#else\nstatic int brcmf_sdio_checkdied(struct brcmf_sdio *bus)\n{\n\treturn 0;\n}\n\nstatic void brcmf_sdio_debugfs_create(struct device *dev)\n{\n}\n#endif  \n\nstatic int\nbrcmf_sdio_bus_rxctl(struct device *dev, unsigned char *msg, uint msglen)\n{\n\tint timeleft;\n\tuint rxlen = 0;\n\tbool pending;\n\tu8 *buf;\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;\n\tstruct brcmf_sdio *bus = sdiodev->bus;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (sdiodev->state != BRCMF_SDIOD_DATA)\n\t\treturn -EIO;\n\n\t \n\ttimeleft = brcmf_sdio_dcmd_resp_wait(bus, &bus->rxlen, &pending);\n\n\tspin_lock_bh(&bus->rxctl_lock);\n\trxlen = bus->rxlen;\n\tmemcpy(msg, bus->rxctl, min(msglen, rxlen));\n\tbus->rxctl = NULL;\n\tbuf = bus->rxctl_orig;\n\tbus->rxctl_orig = NULL;\n\tbus->rxlen = 0;\n\tspin_unlock_bh(&bus->rxctl_lock);\n\tvfree(buf);\n\n\tif (rxlen) {\n\t\tbrcmf_dbg(CTL, \"resumed on rxctl frame, got %d expected %d\\n\",\n\t\t\t  rxlen, msglen);\n\t} else if (timeleft == 0) {\n\t\tbrcmf_err(\"resumed on timeout\\n\");\n\t\tbrcmf_sdio_checkdied(bus);\n\t} else if (pending) {\n\t\tbrcmf_dbg(CTL, \"cancelled\\n\");\n\t\treturn -ERESTARTSYS;\n\t} else {\n\t\tbrcmf_dbg(CTL, \"resumed for unknown reason?\\n\");\n\t\tbrcmf_sdio_checkdied(bus);\n\t}\n\n\tif (rxlen)\n\t\tbus->sdcnt.rx_ctlpkts++;\n\telse\n\t\tbus->sdcnt.rx_ctlerrs++;\n\n\treturn rxlen ? (int)rxlen : -ETIMEDOUT;\n}\n\n#ifdef DEBUG\nstatic bool\nbrcmf_sdio_verifymemory(struct brcmf_sdio_dev *sdiodev, u32 ram_addr,\n\t\t\tu8 *ram_data, uint ram_sz)\n{\n\tchar *ram_cmp;\n\tint err;\n\tbool ret = true;\n\tint address;\n\tint offset;\n\tint len;\n\n\t \n\tbrcmf_dbg(INFO, \"Compare RAM dl & ul at 0x%08x; size=%d\\n\", ram_addr,\n\t\t  ram_sz);\n\tram_cmp = kmalloc(MEMBLOCK, GFP_KERNEL);\n\t \n\tif (!ram_cmp)\n\t\treturn true;\n\n\taddress = ram_addr;\n\toffset = 0;\n\twhile (offset < ram_sz) {\n\t\tlen = ((offset + MEMBLOCK) < ram_sz) ? MEMBLOCK :\n\t\t      ram_sz - offset;\n\t\terr = brcmf_sdiod_ramrw(sdiodev, false, address, ram_cmp, len);\n\t\tif (err) {\n\t\t\tbrcmf_err(\"error %d on reading %d membytes at 0x%08x\\n\",\n\t\t\t\t  err, len, address);\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t} else if (memcmp(ram_cmp, &ram_data[offset], len)) {\n\t\t\tbrcmf_err(\"Downloaded RAM image is corrupted, block offset is %d, len is %d\\n\",\n\t\t\t\t  offset, len);\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t\toffset += len;\n\t\taddress += len;\n\t}\n\n\tkfree(ram_cmp);\n\n\treturn ret;\n}\n#else\t \nstatic bool\nbrcmf_sdio_verifymemory(struct brcmf_sdio_dev *sdiodev, u32 ram_addr,\n\t\t\tu8 *ram_data, uint ram_sz)\n{\n\treturn true;\n}\n#endif\t \n\nstatic int brcmf_sdio_download_code_file(struct brcmf_sdio *bus,\n\t\t\t\t\t const struct firmware *fw)\n{\n\tint err;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\terr = brcmf_sdiod_ramrw(bus->sdiodev, true, bus->ci->rambase,\n\t\t\t\t(u8 *)fw->data, fw->size);\n\tif (err)\n\t\tbrcmf_err(\"error %d on writing %d membytes at 0x%08x\\n\",\n\t\t\t  err, (int)fw->size, bus->ci->rambase);\n\telse if (!brcmf_sdio_verifymemory(bus->sdiodev, bus->ci->rambase,\n\t\t\t\t\t  (u8 *)fw->data, fw->size))\n\t\terr = -EIO;\n\n\treturn err;\n}\n\nstatic int brcmf_sdio_download_nvram(struct brcmf_sdio *bus,\n\t\t\t\t     void *vars, u32 varsz)\n{\n\tint address;\n\tint err;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\taddress = bus->ci->ramsize - varsz + bus->ci->rambase;\n\terr = brcmf_sdiod_ramrw(bus->sdiodev, true, address, vars, varsz);\n\tif (err)\n\t\tbrcmf_err(\"error %d on writing %d nvram bytes at 0x%08x\\n\",\n\t\t\t  err, varsz, address);\n\telse if (!brcmf_sdio_verifymemory(bus->sdiodev, address, vars, varsz))\n\t\terr = -EIO;\n\n\treturn err;\n}\n\nstatic int brcmf_sdio_download_firmware(struct brcmf_sdio *bus,\n\t\t\t\t\tconst struct firmware *fw,\n\t\t\t\t\tvoid *nvram, u32 nvlen)\n{\n\tint bcmerror;\n\tu32 rstvec;\n\n\tsdio_claim_host(bus->sdiodev->func1);\n\tbrcmf_sdio_clkctl(bus, CLK_AVAIL, false);\n\n\trstvec = get_unaligned_le32(fw->data);\n\tbrcmf_dbg(SDIO, \"firmware rstvec: %x\\n\", rstvec);\n\n\tbcmerror = brcmf_sdio_download_code_file(bus, fw);\n\trelease_firmware(fw);\n\tif (bcmerror) {\n\t\tbrcmf_err(\"dongle image file download failed\\n\");\n\t\tbrcmf_fw_nvram_free(nvram);\n\t\tgoto err;\n\t}\n\n\tbcmerror = brcmf_sdio_download_nvram(bus, nvram, nvlen);\n\tbrcmf_fw_nvram_free(nvram);\n\tif (bcmerror) {\n\t\tbrcmf_err(\"dongle nvram file download failed\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\tif (!brcmf_chip_set_active(bus->ci, rstvec)) {\n\t\tbrcmf_err(\"error getting out of ARM core reset\\n\");\n\t\tbcmerror = -EIO;\n\t\tgoto err;\n\t}\n\nerr:\n\tbrcmf_sdio_clkctl(bus, CLK_SDONLY, false);\n\tsdio_release_host(bus->sdiodev->func1);\n\treturn bcmerror;\n}\n\nstatic bool brcmf_sdio_aos_no_decode(struct brcmf_sdio *bus)\n{\n\tif (bus->ci->chip == CY_CC_43012_CHIP_ID ||\n\t    bus->ci->chip == CY_CC_43752_CHIP_ID)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic void brcmf_sdio_sr_init(struct brcmf_sdio *bus)\n{\n\tint err = 0;\n\tu8 val;\n\tu8 wakeupctrl;\n\tu8 cardcap;\n\tu8 chipclkcsr;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tif (brcmf_chip_is_ulp(bus->ci)) {\n\t\twakeupctrl = SBSDIO_FUNC1_WCTRL_ALPWAIT_SHIFT;\n\t\tchipclkcsr = SBSDIO_HT_AVAIL_REQ;\n\t} else {\n\t\twakeupctrl = SBSDIO_FUNC1_WCTRL_HTWAIT_SHIFT;\n\t\tchipclkcsr = SBSDIO_FORCE_HT;\n\t}\n\n\tif (brcmf_sdio_aos_no_decode(bus)) {\n\t\tcardcap = SDIO_CCCR_BRCM_CARDCAP_CMD_NODEC;\n\t} else {\n\t\tcardcap = (SDIO_CCCR_BRCM_CARDCAP_CMD14_SUPPORT |\n\t\t\t   SDIO_CCCR_BRCM_CARDCAP_CMD14_EXT);\n\t}\n\n\tval = brcmf_sdiod_readb(bus->sdiodev, SBSDIO_FUNC1_WAKEUPCTRL, &err);\n\tif (err) {\n\t\tbrcmf_err(\"error reading SBSDIO_FUNC1_WAKEUPCTRL\\n\");\n\t\treturn;\n\t}\n\tval |= 1 << wakeupctrl;\n\tbrcmf_sdiod_writeb(bus->sdiodev, SBSDIO_FUNC1_WAKEUPCTRL, val, &err);\n\tif (err) {\n\t\tbrcmf_err(\"error writing SBSDIO_FUNC1_WAKEUPCTRL\\n\");\n\t\treturn;\n\t}\n\n\t \n\tbrcmf_sdiod_func0_wb(bus->sdiodev, SDIO_CCCR_BRCM_CARDCAP,\n\t\t\t     cardcap,\n\t\t\t     &err);\n\tif (err) {\n\t\tbrcmf_err(\"error writing SDIO_CCCR_BRCM_CARDCAP\\n\");\n\t\treturn;\n\t}\n\n\tbrcmf_sdiod_writeb(bus->sdiodev, SBSDIO_FUNC1_CHIPCLKCSR,\n\t\t\t   chipclkcsr, &err);\n\tif (err) {\n\t\tbrcmf_err(\"error writing SBSDIO_FUNC1_CHIPCLKCSR\\n\");\n\t\treturn;\n\t}\n\n\t \n\tbus->sr_enabled = true;\n\tbrcmf_dbg(INFO, \"SR enabled\\n\");\n}\n\n \nstatic int brcmf_sdio_kso_init(struct brcmf_sdio *bus)\n{\n\tstruct brcmf_core *core = bus->sdio_core;\n\tu8 val;\n\tint err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\t \n\tif (core->rev < 12)\n\t\treturn 0;\n\n\tval = brcmf_sdiod_readb(bus->sdiodev, SBSDIO_FUNC1_SLEEPCSR, &err);\n\tif (err) {\n\t\tbrcmf_err(\"error reading SBSDIO_FUNC1_SLEEPCSR\\n\");\n\t\treturn err;\n\t}\n\n\tif (!(val & SBSDIO_FUNC1_SLEEPCSR_KSO_MASK)) {\n\t\tval |= (SBSDIO_FUNC1_SLEEPCSR_KSO_EN <<\n\t\t\tSBSDIO_FUNC1_SLEEPCSR_KSO_SHIFT);\n\t\tbrcmf_sdiod_writeb(bus->sdiodev, SBSDIO_FUNC1_SLEEPCSR,\n\t\t\t\t   val, &err);\n\t\tif (err) {\n\t\t\tbrcmf_err(\"error writing SBSDIO_FUNC1_SLEEPCSR\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nstatic int brcmf_sdio_bus_preinit(struct device *dev)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;\n\tstruct brcmf_sdio *bus = sdiodev->bus;\n\tstruct brcmf_core *core = bus->sdio_core;\n\tu32 value;\n\t__le32 iovar;\n\tint err;\n\n\t \n\tif (WARN_ON(!bus_if->maxctl))\n\t\treturn -EINVAL;\n\n\t \n\tbus_if->maxctl += bus->roundup;\n\tvalue = roundup((bus_if->maxctl + SDPCM_HDRLEN), ALIGNMENT);\n\tvalue += bus->head_align;\n\tbus->rxbuf = kmalloc(value, GFP_ATOMIC);\n\tif (bus->rxbuf)\n\t\tbus->rxblen = value;\n\n\t \n\tif (core->rev < 12) {\n\t\t \n\t\tiovar = 0;\n\t\terr = brcmf_iovar_data_set(dev, \"bus:txglom\", &iovar,\n\t\t\t\t\t   sizeof(iovar));\n\t} else {\n\t\t \n\t\tvalue = sdiodev->settings->bus.sdio.sd_sgentry_align;\n\t\t \n\t\tiovar = cpu_to_le32(max_t(u32, value, ALIGNMENT));\n\t\terr = brcmf_iovar_data_set(dev, \"bus:txglomalign\", &iovar,\n\t\t\t\t\t   sizeof(iovar));\n\t}\n\n\tif (err < 0)\n\t\tgoto done;\n\n\tbus->tx_hdrlen = SDPCM_HWHDR_LEN + SDPCM_SWHDR_LEN;\n\tif (sdiodev->sg_support) {\n\t\tbus->txglom = false;\n\t\tiovar = cpu_to_le32(1);\n\t\terr = brcmf_iovar_data_set(bus->sdiodev->dev, \"bus:rxglom\",\n\t\t\t\t\t   &iovar, sizeof(iovar));\n\t\tif (err < 0) {\n\t\t\t \n\t\t\terr = 0;\n\t\t} else {\n\t\t\tbus->txglom = true;\n\t\t\tbus->tx_hdrlen += SDPCM_HWEXT_LEN;\n\t\t}\n\t}\n\tbrcmf_bus_add_txhdrlen(bus->sdiodev->dev, bus->tx_hdrlen);\n\ndone:\n\treturn err;\n}\n\nstatic size_t brcmf_sdio_bus_get_ramsize(struct device *dev)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;\n\tstruct brcmf_sdio *bus = sdiodev->bus;\n\n\treturn bus->ci->ramsize - bus->ci->srsize;\n}\n\nstatic int brcmf_sdio_bus_get_memdump(struct device *dev, void *data,\n\t\t\t\t      size_t mem_size)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;\n\tstruct brcmf_sdio *bus = sdiodev->bus;\n\tint err;\n\tint address;\n\tint offset;\n\tint len;\n\n\tbrcmf_dbg(INFO, \"dump at 0x%08x: size=%zu\\n\", bus->ci->rambase,\n\t\t  mem_size);\n\n\taddress = bus->ci->rambase;\n\toffset = err = 0;\n\tsdio_claim_host(sdiodev->func1);\n\twhile (offset < mem_size) {\n\t\tlen = ((offset + MEMBLOCK) < mem_size) ? MEMBLOCK :\n\t\t      mem_size - offset;\n\t\terr = brcmf_sdiod_ramrw(sdiodev, false, address, data, len);\n\t\tif (err) {\n\t\t\tbrcmf_err(\"error %d on reading %d membytes at 0x%08x\\n\",\n\t\t\t\t  err, len, address);\n\t\t\tgoto done;\n\t\t}\n\t\tdata += len;\n\t\toffset += len;\n\t\taddress += len;\n\t}\n\ndone:\n\tsdio_release_host(sdiodev->func1);\n\treturn err;\n}\n\nvoid brcmf_sdio_trigger_dpc(struct brcmf_sdio *bus)\n{\n\tif (!bus->dpc_triggered) {\n\t\tbus->dpc_triggered = true;\n\t\tqueue_work(bus->brcmf_wq, &bus->datawork);\n\t}\n}\n\nvoid brcmf_sdio_isr(struct brcmf_sdio *bus, bool in_isr)\n{\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tif (!bus) {\n\t\tbrcmf_err(\"bus is null pointer, exiting\\n\");\n\t\treturn;\n\t}\n\n\t \n\tbus->sdcnt.intrcount++;\n\tif (in_isr)\n\t\tatomic_set(&bus->ipend, 1);\n\telse\n\t\tif (brcmf_sdio_intr_rstatus(bus)) {\n\t\t\tbrcmf_err(\"failed backplane access\\n\");\n\t\t}\n\n\t \n\tif (!bus->intr)\n\t\tbrcmf_err(\"isr w/o interrupt configured!\\n\");\n\n\tbus->dpc_triggered = true;\n\tqueue_work(bus->brcmf_wq, &bus->datawork);\n}\n\nstatic void brcmf_sdio_bus_watchdog(struct brcmf_sdio *bus)\n{\n\tbrcmf_dbg(TIMER, \"Enter\\n\");\n\n\t \n\tif (!bus->sr_enabled &&\n\t    bus->poll && (++bus->polltick >= bus->pollrate)) {\n\t\tu32 intstatus = 0;\n\n\t\t \n\t\tbus->polltick = 0;\n\n\t\t \n\t\tif (!bus->intr ||\n\t\t    (bus->sdcnt.intrcount == bus->sdcnt.lastintrs)) {\n\n\t\t\tif (!bus->dpc_triggered) {\n\t\t\t\tu8 devpend;\n\n\t\t\t\tsdio_claim_host(bus->sdiodev->func1);\n\t\t\t\tdevpend = brcmf_sdiod_func0_rb(bus->sdiodev,\n\t\t\t\t\t\t  SDIO_CCCR_INTx, NULL);\n\t\t\t\tsdio_release_host(bus->sdiodev->func1);\n\t\t\t\tintstatus = devpend & (INTR_STATUS_FUNC1 |\n\t\t\t\t\t\t       INTR_STATUS_FUNC2);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (intstatus) {\n\t\t\t\tbus->sdcnt.pollcnt++;\n\t\t\t\tatomic_set(&bus->ipend, 1);\n\n\t\t\t\tbus->dpc_triggered = true;\n\t\t\t\tqueue_work(bus->brcmf_wq, &bus->datawork);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tbus->sdcnt.lastintrs = bus->sdcnt.intrcount;\n\t}\n#ifdef DEBUG\n\t \n\tif (bus->sdiodev->state == BRCMF_SDIOD_DATA && BRCMF_FWCON_ON() &&\n\t    bus->console_interval != 0) {\n\t\tbus->console.count += jiffies_to_msecs(BRCMF_WD_POLL);\n\t\tif (bus->console.count >= bus->console_interval) {\n\t\t\tbus->console.count -= bus->console_interval;\n\t\t\tsdio_claim_host(bus->sdiodev->func1);\n\t\t\t \n\t\t\tbrcmf_sdio_bus_sleep(bus, false, false);\n\t\t\tif (brcmf_sdio_readconsole(bus) < 0)\n\t\t\t\t \n\t\t\t\tbus->console_interval = 0;\n\t\t\tsdio_release_host(bus->sdiodev->func1);\n\t\t}\n\t}\n#endif\t\t\t\t \n\n\t \n\tif (!bus->dpc_triggered) {\n\t\trmb();\n\t\tif ((!bus->dpc_running) && (bus->idletime > 0) &&\n\t\t    (bus->clkstate == CLK_AVAIL)) {\n\t\t\tbus->idlecount++;\n\t\t\tif (bus->idlecount > bus->idletime) {\n\t\t\t\tbrcmf_dbg(SDIO, \"idle\\n\");\n\t\t\t\tsdio_claim_host(bus->sdiodev->func1);\n#ifdef DEBUG\n\t\t\t\tif (!BRCMF_FWCON_ON() ||\n\t\t\t\t    bus->console_interval == 0)\n#endif\n\t\t\t\t\tbrcmf_sdio_wd_timer(bus, false);\n\t\t\t\tbus->idlecount = 0;\n\t\t\t\tbrcmf_sdio_bus_sleep(bus, true, false);\n\t\t\t\tsdio_release_host(bus->sdiodev->func1);\n\t\t\t}\n\t\t} else {\n\t\t\tbus->idlecount = 0;\n\t\t}\n\t} else {\n\t\tbus->idlecount = 0;\n\t}\n}\n\nstatic void brcmf_sdio_dataworker(struct work_struct *work)\n{\n\tstruct brcmf_sdio *bus = container_of(work, struct brcmf_sdio,\n\t\t\t\t\t      datawork);\n\n\tbus->dpc_running = true;\n\twmb();\n\twhile (READ_ONCE(bus->dpc_triggered)) {\n\t\tbus->dpc_triggered = false;\n\t\tbrcmf_sdio_dpc(bus);\n\t\tbus->idlecount = 0;\n\t}\n\tbus->dpc_running = false;\n\tif (brcmf_sdiod_freezing(bus->sdiodev)) {\n\t\tbrcmf_sdiod_change_state(bus->sdiodev, BRCMF_SDIOD_DOWN);\n\t\tbrcmf_sdiod_try_freeze(bus->sdiodev);\n\t\tbrcmf_sdiod_change_state(bus->sdiodev, BRCMF_SDIOD_DATA);\n\t}\n}\n\nstatic void\nbrcmf_sdio_drivestrengthinit(struct brcmf_sdio_dev *sdiodev,\n\t\t\t     struct brcmf_chip *ci, u32 drivestrength)\n{\n\tconst struct sdiod_drive_str *str_tab = NULL;\n\tu32 str_mask;\n\tu32 str_shift;\n\tu32 i;\n\tu32 drivestrength_sel = 0;\n\tu32 cc_data_temp;\n\tu32 addr;\n\n\tif (!(ci->cc_caps & CC_CAP_PMU))\n\t\treturn;\n\n\tswitch (SDIOD_DRVSTR_KEY(ci->chip, ci->pmurev)) {\n\tcase SDIOD_DRVSTR_KEY(BRCM_CC_4330_CHIP_ID, 12):\n\t\tstr_tab = sdiod_drvstr_tab1_1v8;\n\t\tstr_mask = 0x00003800;\n\t\tstr_shift = 11;\n\t\tbreak;\n\tcase SDIOD_DRVSTR_KEY(BRCM_CC_4334_CHIP_ID, 17):\n\t\tstr_tab = sdiod_drvstr_tab6_1v8;\n\t\tstr_mask = 0x00001800;\n\t\tstr_shift = 11;\n\t\tbreak;\n\tcase SDIOD_DRVSTR_KEY(BRCM_CC_43143_CHIP_ID, 17):\n\t\t \n\t\ti = ARRAY_SIZE(sdiod_drvstr_tab2_3v3) - 1;\n\t\tif (drivestrength >= sdiod_drvstr_tab2_3v3[i].strength) {\n\t\t\tstr_tab = sdiod_drvstr_tab2_3v3;\n\t\t\tstr_mask = 0x00000007;\n\t\t\tstr_shift = 0;\n\t\t} else\n\t\t\tbrcmf_err(\"Invalid SDIO Drive strength for chip %s, strength=%d\\n\",\n\t\t\t\t  ci->name, drivestrength);\n\t\tbreak;\n\tcase SDIOD_DRVSTR_KEY(BRCM_CC_43362_CHIP_ID, 13):\n\t\tstr_tab = sdiod_drive_strength_tab5_1v8;\n\t\tstr_mask = 0x00003800;\n\t\tstr_shift = 11;\n\t\tbreak;\n\tdefault:\n\t\tbrcmf_dbg(INFO, \"No SDIO driver strength init needed for chip %s rev %d pmurev %d\\n\",\n\t\t\t  ci->name, ci->chiprev, ci->pmurev);\n\t\tbreak;\n\t}\n\n\tif (str_tab != NULL) {\n\t\tstruct brcmf_core *pmu = brcmf_chip_get_pmu(ci);\n\n\t\tfor (i = 0; str_tab[i].strength != 0; i++) {\n\t\t\tif (drivestrength >= str_tab[i].strength) {\n\t\t\t\tdrivestrength_sel = str_tab[i].sel;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\taddr = CORE_CC_REG(pmu->base, chipcontrol_addr);\n\t\tbrcmf_sdiod_writel(sdiodev, addr, 1, NULL);\n\t\tcc_data_temp = brcmf_sdiod_readl(sdiodev, addr, NULL);\n\t\tcc_data_temp &= ~str_mask;\n\t\tdrivestrength_sel <<= str_shift;\n\t\tcc_data_temp |= drivestrength_sel;\n\t\tbrcmf_sdiod_writel(sdiodev, addr, cc_data_temp, NULL);\n\n\t\tbrcmf_dbg(INFO, \"SDIO: %d mA (req=%d mA) drive strength selected, set to 0x%08x\\n\",\n\t\t\t  str_tab[i].strength, drivestrength, cc_data_temp);\n\t}\n}\n\nstatic int brcmf_sdio_buscoreprep(void *ctx)\n{\n\tstruct brcmf_sdio_dev *sdiodev = ctx;\n\tint err = 0;\n\tu8 clkval, clkset;\n\n\t \n\tclkset = SBSDIO_FORCE_HW_CLKREQ_OFF | SBSDIO_ALP_AVAIL_REQ;\n\tbrcmf_sdiod_writeb(sdiodev, SBSDIO_FUNC1_CHIPCLKCSR, clkset, &err);\n\tif (err) {\n\t\tbrcmf_err(\"error writing for HT off\\n\");\n\t\treturn err;\n\t}\n\n\t \n\t \n\tclkval = brcmf_sdiod_readb(sdiodev, SBSDIO_FUNC1_CHIPCLKCSR, NULL);\n\n\tif ((clkval & ~SBSDIO_AVBITS) != clkset) {\n\t\tbrcmf_err(\"ChipClkCSR access: wrote 0x%02x read 0x%02x\\n\",\n\t\t\t  clkset, clkval);\n\t\treturn -EACCES;\n\t}\n\n\tSPINWAIT(((clkval = brcmf_sdiod_readb(sdiodev, SBSDIO_FUNC1_CHIPCLKCSR,\n\t\t\t\t\t      NULL)),\n\t\t !SBSDIO_ALPAV(clkval)),\n\t\t PMU_MAX_TRANSITION_DLY);\n\n\tif (!SBSDIO_ALPAV(clkval)) {\n\t\tbrcmf_err(\"timeout on ALPAV wait, clkval 0x%02x\\n\",\n\t\t\t  clkval);\n\t\treturn -EBUSY;\n\t}\n\n\tclkset = SBSDIO_FORCE_HW_CLKREQ_OFF | SBSDIO_FORCE_ALP;\n\tbrcmf_sdiod_writeb(sdiodev, SBSDIO_FUNC1_CHIPCLKCSR, clkset, &err);\n\tudelay(65);\n\n\t \n\tbrcmf_sdiod_writeb(sdiodev, SBSDIO_FUNC1_SDIOPULLUP, 0, NULL);\n\n\treturn 0;\n}\n\nstatic void brcmf_sdio_buscore_activate(void *ctx, struct brcmf_chip *chip,\n\t\t\t\t\tu32 rstvec)\n{\n\tstruct brcmf_sdio_dev *sdiodev = ctx;\n\tstruct brcmf_core *core = sdiodev->bus->sdio_core;\n\tu32 reg_addr;\n\n\t \n\treg_addr = core->base + SD_REG(intstatus);\n\tbrcmf_sdiod_writel(sdiodev, reg_addr, 0xFFFFFFFF, NULL);\n\n\tif (rstvec)\n\t\t \n\t\tbrcmf_sdiod_ramrw(sdiodev, true, 0, (void *)&rstvec,\n\t\t\t\t  sizeof(rstvec));\n}\n\nstatic u32 brcmf_sdio_buscore_read32(void *ctx, u32 addr)\n{\n\tstruct brcmf_sdio_dev *sdiodev = ctx;\n\tu32 val, rev;\n\n\tval = brcmf_sdiod_readl(sdiodev, addr, NULL);\n\n\t \n\tif (addr == CORE_CC_REG(SI_ENUM_BASE_DEFAULT, chipid) &&\n\t    (sdiodev->func1->device == SDIO_DEVICE_ID_BROADCOM_4339 ||\n\t     sdiodev->func1->device == SDIO_DEVICE_ID_BROADCOM_4335_4339)) {\n\t\trev = (val & CID_REV_MASK) >> CID_REV_SHIFT;\n\t\tif (rev >= 2) {\n\t\t\tval &= ~CID_ID_MASK;\n\t\t\tval |= BRCM_CC_4339_CHIP_ID;\n\t\t}\n\t}\n\n\treturn val;\n}\n\nstatic void brcmf_sdio_buscore_write32(void *ctx, u32 addr, u32 val)\n{\n\tstruct brcmf_sdio_dev *sdiodev = ctx;\n\n\tbrcmf_sdiod_writel(sdiodev, addr, val, NULL);\n}\n\nstatic const struct brcmf_buscore_ops brcmf_sdio_buscore_ops = {\n\t.prepare = brcmf_sdio_buscoreprep,\n\t.activate = brcmf_sdio_buscore_activate,\n\t.read32 = brcmf_sdio_buscore_read32,\n\t.write32 = brcmf_sdio_buscore_write32,\n};\n\nstatic bool\nbrcmf_sdio_probe_attach(struct brcmf_sdio *bus)\n{\n\tstruct brcmf_sdio_dev *sdiodev;\n\tu8 clkctl = 0;\n\tint err = 0;\n\tint reg_addr;\n\tu32 reg_val;\n\tu32 drivestrength;\n\tu32 enum_base;\n\n\tsdiodev = bus->sdiodev;\n\tsdio_claim_host(sdiodev->func1);\n\n\tenum_base = brcmf_chip_enum_base(sdiodev->func1->device);\n\n\tpr_debug(\"F1 signature read @0x%08x=0x%4x\\n\", enum_base,\n\t\t brcmf_sdiod_readl(sdiodev, enum_base, NULL));\n\n\t \n\n\tbrcmf_sdiod_writeb(sdiodev, SBSDIO_FUNC1_CHIPCLKCSR, BRCMF_INIT_CLKCTL1,\n\t\t\t   &err);\n\tif (!err)\n\t\tclkctl = brcmf_sdiod_readb(sdiodev, SBSDIO_FUNC1_CHIPCLKCSR,\n\t\t\t\t\t   &err);\n\n\tif (err || ((clkctl & ~SBSDIO_AVBITS) != BRCMF_INIT_CLKCTL1)) {\n\t\tbrcmf_err(\"ChipClkCSR access: err %d wrote 0x%02x read 0x%02x\\n\",\n\t\t\t  err, BRCMF_INIT_CLKCTL1, clkctl);\n\t\tgoto fail;\n\t}\n\n\tbus->ci = brcmf_chip_attach(sdiodev, sdiodev->func1->device,\n\t\t\t\t    &brcmf_sdio_buscore_ops);\n\tif (IS_ERR(bus->ci)) {\n\t\tbrcmf_err(\"brcmf_chip_attach failed!\\n\");\n\t\tbus->ci = NULL;\n\t\tgoto fail;\n\t}\n\n\t \n\tbus->sdio_core   = brcmf_chip_get_core(bus->ci, BCMA_CORE_SDIO_DEV);\n\tif (!bus->sdio_core)\n\t\tgoto fail;\n\n\t \n\tsdiodev->cc_core = brcmf_chip_get_core(bus->ci, BCMA_CORE_CHIPCOMMON);\n\tif (!sdiodev->cc_core)\n\t\tgoto fail;\n\n\tsdiodev->settings = brcmf_get_module_param(sdiodev->dev,\n\t\t\t\t\t\t   BRCMF_BUSTYPE_SDIO,\n\t\t\t\t\t\t   bus->ci->chip,\n\t\t\t\t\t\t   bus->ci->chiprev);\n\tif (!sdiodev->settings) {\n\t\tbrcmf_err(\"Failed to get device parameters\\n\");\n\t\tgoto fail;\n\t}\n\t \n\tbus->head_align = ALIGNMENT;\n\tbus->sgentry_align = ALIGNMENT;\n\tif (sdiodev->settings->bus.sdio.sd_head_align > ALIGNMENT)\n\t\tbus->head_align = sdiodev->settings->bus.sdio.sd_head_align;\n\tif (sdiodev->settings->bus.sdio.sd_sgentry_align > ALIGNMENT)\n\t\tbus->sgentry_align =\n\t\t\t\tsdiodev->settings->bus.sdio.sd_sgentry_align;\n\n\t \n\tbrcmf_sdiod_sgtable_alloc(sdiodev);\n\n\t \n\tif (IS_ENABLED(CONFIG_PM_SLEEP) &&\n\t    (sdio_get_host_pm_caps(sdiodev->func1) & MMC_PM_KEEP_POWER) &&\n\t    ((sdio_get_host_pm_caps(sdiodev->func1) & MMC_PM_WAKE_SDIO_IRQ) ||\n\t     (sdiodev->settings->bus.sdio.oob_irq_supported)))\n\t\tsdiodev->bus_if->wowl_supported = true;\n\n\tif (brcmf_sdio_kso_init(bus)) {\n\t\tbrcmf_err(\"error enabling KSO\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (sdiodev->settings->bus.sdio.drive_strength)\n\t\tdrivestrength = sdiodev->settings->bus.sdio.drive_strength;\n\telse\n\t\tdrivestrength = DEFAULT_SDIO_DRIVE_STRENGTH;\n\tbrcmf_sdio_drivestrengthinit(sdiodev, bus->ci, drivestrength);\n\n\t \n\treg_val = brcmf_sdiod_func0_rb(sdiodev, SDIO_CCCR_BRCM_CARDCTRL, &err);\n\tif (err)\n\t\tgoto fail;\n\n\treg_val |= SDIO_CCCR_BRCM_CARDCTRL_WLANRESET;\n\n\tbrcmf_sdiod_func0_wb(sdiodev, SDIO_CCCR_BRCM_CARDCTRL, reg_val, &err);\n\tif (err)\n\t\tgoto fail;\n\n\t \n\treg_addr = CORE_CC_REG(brcmf_chip_get_pmu(bus->ci)->base, pmucontrol);\n\treg_val = brcmf_sdiod_readl(sdiodev, reg_addr, &err);\n\tif (err)\n\t\tgoto fail;\n\n\treg_val |= (BCMA_CC_PMU_CTL_RES_RELOAD << BCMA_CC_PMU_CTL_RES_SHIFT);\n\n\tbrcmf_sdiod_writel(sdiodev, reg_addr, reg_val, &err);\n\tif (err)\n\t\tgoto fail;\n\n\tsdio_release_host(sdiodev->func1);\n\n\tbrcmu_pktq_init(&bus->txq, (PRIOMASK + 1), TXQLEN);\n\n\t \n\tbus->hdrbuf = kzalloc(MAX_HDR_READ + bus->head_align, GFP_KERNEL);\n\tif (!bus->hdrbuf)\n\t\treturn false;\n\t \n\tbus->rxhdr = (u8 *) roundup((unsigned long)&bus->hdrbuf[0],\n\t\t\t\t    bus->head_align);\n\n\t \n\tbus->intr = true;\n\tbus->poll = false;\n\tif (bus->poll)\n\t\tbus->pollrate = 1;\n\n\treturn true;\n\nfail:\n\tsdio_release_host(sdiodev->func1);\n\treturn false;\n}\n\nstatic int\nbrcmf_sdio_watchdog_thread(void *data)\n{\n\tstruct brcmf_sdio *bus = (struct brcmf_sdio *)data;\n\tint wait;\n\n\tallow_signal(SIGTERM);\n\t \n\tbrcmf_sdiod_freezer_count(bus->sdiodev);\n\twhile (1) {\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\t\tbrcmf_sdiod_freezer_uncount(bus->sdiodev);\n\t\twait = wait_for_completion_interruptible(&bus->watchdog_wait);\n\t\tbrcmf_sdiod_freezer_count(bus->sdiodev);\n\t\tbrcmf_sdiod_try_freeze(bus->sdiodev);\n\t\tif (!wait) {\n\t\t\tbrcmf_sdio_bus_watchdog(bus);\n\t\t\t \n\t\t\tbus->sdcnt.tickcnt++;\n\t\t\treinit_completion(&bus->watchdog_wait);\n\t\t} else\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void\nbrcmf_sdio_watchdog(struct timer_list *t)\n{\n\tstruct brcmf_sdio *bus = from_timer(bus, t, timer);\n\n\tif (bus->watchdog_tsk) {\n\t\tcomplete(&bus->watchdog_wait);\n\t\t \n\t\tif (bus->wd_active)\n\t\t\tmod_timer(&bus->timer,\n\t\t\t\t  jiffies + BRCMF_WD_POLL);\n\t}\n}\n\nstatic int brcmf_sdio_get_blob(struct device *dev, const struct firmware **fw,\n\t\t\t       enum brcmf_blob_type type)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;\n\n\tswitch (type) {\n\tcase BRCMF_BLOB_CLM:\n\t\t*fw = sdiodev->clm_fw;\n\t\tsdiodev->clm_fw = NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOENT;\n\t}\n\n\tif (!*fw)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\nstatic int brcmf_sdio_bus_reset(struct device *dev)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;\n\n\tbrcmf_dbg(SDIO, \"Enter\\n\");\n\n\t \n\tbrcmf_sdiod_intr_unregister(sdiodev);\n\n\tbrcmf_sdiod_remove(sdiodev);\n\n\t \n\tsdio_claim_host(sdiodev->func1);\n\tmmc_hw_reset(sdiodev->func1->card);\n\tsdio_release_host(sdiodev->func1);\n\n\tbrcmf_bus_change_state(sdiodev->bus_if, BRCMF_BUS_DOWN);\n\treturn 0;\n}\n\nstatic void brcmf_sdio_bus_remove(struct device *dev)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_sdio_dev *sdiod = bus_if->bus_priv.sdio;\n\n\tdevice_release_driver(&sdiod->func2->dev);\n\tdevice_release_driver(&sdiod->func1->dev);\n}\n\nstatic const struct brcmf_bus_ops brcmf_sdio_bus_ops = {\n\t.stop = brcmf_sdio_bus_stop,\n\t.preinit = brcmf_sdio_bus_preinit,\n\t.txdata = brcmf_sdio_bus_txdata,\n\t.txctl = brcmf_sdio_bus_txctl,\n\t.rxctl = brcmf_sdio_bus_rxctl,\n\t.gettxq = brcmf_sdio_bus_gettxq,\n\t.wowl_config = brcmf_sdio_wowl_config,\n\t.get_ramsize = brcmf_sdio_bus_get_ramsize,\n\t.get_memdump = brcmf_sdio_bus_get_memdump,\n\t.get_blob = brcmf_sdio_get_blob,\n\t.debugfs_create = brcmf_sdio_debugfs_create,\n\t.reset = brcmf_sdio_bus_reset,\n\t.remove = brcmf_sdio_bus_remove,\n};\n\n#define BRCMF_SDIO_FW_CODE\t0\n#define BRCMF_SDIO_FW_NVRAM\t1\n#define BRCMF_SDIO_FW_CLM\t2\n\nstatic void brcmf_sdio_firmware_callback(struct device *dev, int err,\n\t\t\t\t\t struct brcmf_fw_request *fwreq)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_sdio_dev *sdiod = bus_if->bus_priv.sdio;\n\tstruct brcmf_sdio *bus = sdiod->bus;\n\tstruct brcmf_core *core = bus->sdio_core;\n\tconst struct firmware *code;\n\tvoid *nvram;\n\tu32 nvram_len;\n\tu8 saveclk, bpreq;\n\tu8 devctl;\n\n\tbrcmf_dbg(TRACE, \"Enter: dev=%s, err=%d\\n\", dev_name(dev), err);\n\n\tif (err)\n\t\tgoto fail;\n\n\tcode = fwreq->items[BRCMF_SDIO_FW_CODE].binary;\n\tnvram = fwreq->items[BRCMF_SDIO_FW_NVRAM].nv_data.data;\n\tnvram_len = fwreq->items[BRCMF_SDIO_FW_NVRAM].nv_data.len;\n\tsdiod->clm_fw = fwreq->items[BRCMF_SDIO_FW_CLM].binary;\n\tkfree(fwreq);\n\n\t \n\tbus->alp_only = true;\n\terr = brcmf_sdio_download_firmware(bus, code, nvram, nvram_len);\n\tif (err)\n\t\tgoto fail;\n\tbus->alp_only = false;\n\n\t \n\tbus->sdcnt.tickcnt = 0;\n\tbrcmf_sdio_wd_timer(bus, true);\n\n\tsdio_claim_host(sdiod->func1);\n\n\t \n\tbrcmf_sdio_clkctl(bus, CLK_AVAIL, false);\n\tif (bus->clkstate != CLK_AVAIL)\n\t\tgoto release;\n\n\t \n\tsaveclk = brcmf_sdiod_readb(sdiod, SBSDIO_FUNC1_CHIPCLKCSR, &err);\n\tif (!err) {\n\t\tbpreq = saveclk;\n\t\tbpreq |= brcmf_chip_is_ulp(bus->ci) ?\n\t\t\tSBSDIO_HT_AVAIL_REQ : SBSDIO_FORCE_HT;\n\t\tbrcmf_sdiod_writeb(sdiod, SBSDIO_FUNC1_CHIPCLKCSR,\n\t\t\t\t   bpreq, &err);\n\t}\n\tif (err) {\n\t\tbrcmf_err(\"Failed to force clock for F2: err %d\\n\", err);\n\t\tgoto release;\n\t}\n\n\t \n\tbrcmf_sdiod_writel(sdiod, core->base + SD_REG(tosbmailboxdata),\n\t\t\t   SDPCM_PROT_VERSION << SMB_DATA_VERSION_SHIFT, NULL);\n\n\terr = sdio_enable_func(sdiod->func2);\n\n\tbrcmf_dbg(INFO, \"enable F2: err=%d\\n\", err);\n\n\t \n\tif (!err) {\n\t\t \n\t\tbus->hostintmask = HOSTINTMASK;\n\t\tbrcmf_sdiod_writel(sdiod, core->base + SD_REG(hostintmask),\n\t\t\t\t   bus->hostintmask, NULL);\n\n\t\tswitch (sdiod->func1->device) {\n\t\tcase SDIO_DEVICE_ID_BROADCOM_CYPRESS_4373:\n\t\tcase SDIO_DEVICE_ID_BROADCOM_CYPRESS_43752:\n\t\t\tbrcmf_dbg(INFO, \"set F2 watermark to 0x%x*4 bytes\\n\",\n\t\t\t\t  CY_4373_F2_WATERMARK);\n\t\t\tbrcmf_sdiod_writeb(sdiod, SBSDIO_WATERMARK,\n\t\t\t\t\t   CY_4373_F2_WATERMARK, &err);\n\t\t\tdevctl = brcmf_sdiod_readb(sdiod, SBSDIO_DEVICE_CTL,\n\t\t\t\t\t\t   &err);\n\t\t\tdevctl |= SBSDIO_DEVCTL_F2WM_ENAB;\n\t\t\tbrcmf_sdiod_writeb(sdiod, SBSDIO_DEVICE_CTL, devctl,\n\t\t\t\t\t   &err);\n\t\t\tbrcmf_sdiod_writeb(sdiod, SBSDIO_FUNC1_MESBUSYCTRL,\n\t\t\t\t\t   CY_4373_F1_MESBUSYCTRL, &err);\n\t\t\tbreak;\n\t\tcase SDIO_DEVICE_ID_BROADCOM_CYPRESS_43012:\n\t\t\tbrcmf_dbg(INFO, \"set F2 watermark to 0x%x*4 bytes\\n\",\n\t\t\t\t  CY_43012_F2_WATERMARK);\n\t\t\tbrcmf_sdiod_writeb(sdiod, SBSDIO_WATERMARK,\n\t\t\t\t\t   CY_43012_F2_WATERMARK, &err);\n\t\t\tdevctl = brcmf_sdiod_readb(sdiod, SBSDIO_DEVICE_CTL,\n\t\t\t\t\t\t   &err);\n\t\t\tdevctl |= SBSDIO_DEVCTL_F2WM_ENAB;\n\t\t\tbrcmf_sdiod_writeb(sdiod, SBSDIO_DEVICE_CTL, devctl,\n\t\t\t\t\t   &err);\n\t\t\tbrcmf_sdiod_writeb(sdiod, SBSDIO_FUNC1_MESBUSYCTRL,\n\t\t\t\t\t   CY_43012_MESBUSYCTRL, &err);\n\t\t\tbreak;\n\t\tcase SDIO_DEVICE_ID_BROADCOM_4329:\n\t\tcase SDIO_DEVICE_ID_BROADCOM_4339:\n\t\t\tbrcmf_dbg(INFO, \"set F2 watermark to 0x%x*4 bytes\\n\",\n\t\t\t\t  CY_4339_F2_WATERMARK);\n\t\t\tbrcmf_sdiod_writeb(sdiod, SBSDIO_WATERMARK,\n\t\t\t\t\t   CY_4339_F2_WATERMARK, &err);\n\t\t\tdevctl = brcmf_sdiod_readb(sdiod, SBSDIO_DEVICE_CTL,\n\t\t\t\t\t\t   &err);\n\t\t\tdevctl |= SBSDIO_DEVCTL_F2WM_ENAB;\n\t\t\tbrcmf_sdiod_writeb(sdiod, SBSDIO_DEVICE_CTL, devctl,\n\t\t\t\t\t   &err);\n\t\t\tbrcmf_sdiod_writeb(sdiod, SBSDIO_FUNC1_MESBUSYCTRL,\n\t\t\t\t\t   CY_4339_MESBUSYCTRL, &err);\n\t\t\tbreak;\n\t\tcase SDIO_DEVICE_ID_BROADCOM_43455:\n\t\t\tbrcmf_dbg(INFO, \"set F2 watermark to 0x%x*4 bytes\\n\",\n\t\t\t\t  CY_43455_F2_WATERMARK);\n\t\t\tbrcmf_sdiod_writeb(sdiod, SBSDIO_WATERMARK,\n\t\t\t\t\t   CY_43455_F2_WATERMARK, &err);\n\t\t\tdevctl = brcmf_sdiod_readb(sdiod, SBSDIO_DEVICE_CTL,\n\t\t\t\t\t\t   &err);\n\t\t\tdevctl |= SBSDIO_DEVCTL_F2WM_ENAB;\n\t\t\tbrcmf_sdiod_writeb(sdiod, SBSDIO_DEVICE_CTL, devctl,\n\t\t\t\t\t   &err);\n\t\t\tbrcmf_sdiod_writeb(sdiod, SBSDIO_FUNC1_MESBUSYCTRL,\n\t\t\t\t\t   CY_43455_MESBUSYCTRL, &err);\n\t\t\tbreak;\n\t\tcase SDIO_DEVICE_ID_BROADCOM_4359:\n\t\tcase SDIO_DEVICE_ID_BROADCOM_4354:\n\t\tcase SDIO_DEVICE_ID_BROADCOM_4356:\n\t\t\tbrcmf_dbg(INFO, \"set F2 watermark to 0x%x*4 bytes\\n\",\n\t\t\t\t  CY_435X_F2_WATERMARK);\n\t\t\tbrcmf_sdiod_writeb(sdiod, SBSDIO_WATERMARK,\n\t\t\t\t\t   CY_435X_F2_WATERMARK, &err);\n\t\t\tdevctl = brcmf_sdiod_readb(sdiod, SBSDIO_DEVICE_CTL,\n\t\t\t\t\t\t   &err);\n\t\t\tdevctl |= SBSDIO_DEVCTL_F2WM_ENAB;\n\t\t\tbrcmf_sdiod_writeb(sdiod, SBSDIO_DEVICE_CTL, devctl,\n\t\t\t\t\t   &err);\n\t\t\tbrcmf_sdiod_writeb(sdiod, SBSDIO_FUNC1_MESBUSYCTRL,\n\t\t\t\t\t   CY_435X_F1_MESBUSYCTRL, &err);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbrcmf_sdiod_writeb(sdiod, SBSDIO_WATERMARK,\n\t\t\t\t\t   DEFAULT_F2_WATERMARK, &err);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tsdio_disable_func(sdiod->func2);\n\t\tgoto checkdied;\n\t}\n\n\tif (brcmf_chip_sr_capable(bus->ci)) {\n\t\tbrcmf_sdio_sr_init(bus);\n\t} else {\n\t\t \n\t\tbrcmf_sdiod_writeb(sdiod, SBSDIO_FUNC1_CHIPCLKCSR,\n\t\t\t\t   saveclk, &err);\n\t}\n\n\tif (err == 0) {\n\t\t \n\t\tsdiod->bus_if->dev = sdiod->dev;\n\t\tsdiod->bus_if->ops = &brcmf_sdio_bus_ops;\n\t\tsdiod->bus_if->chip = bus->ci->chip;\n\t\tsdiod->bus_if->chiprev = bus->ci->chiprev;\n\n\t\t \n\t\tbrcmf_sdiod_change_state(bus->sdiodev, BRCMF_SDIOD_DATA);\n\n\t\terr = brcmf_sdiod_intr_register(sdiod);\n\t\tif (err != 0)\n\t\t\tbrcmf_err(\"intr register failed:%d\\n\", err);\n\t}\n\n\t \n\tif (err != 0) {\n\t\tbrcmf_sdio_clkctl(bus, CLK_NONE, false);\n\t\tgoto checkdied;\n\t}\n\n\tsdio_release_host(sdiod->func1);\n\n\terr = brcmf_alloc(sdiod->dev, sdiod->settings);\n\tif (err) {\n\t\tbrcmf_err(\"brcmf_alloc failed\\n\");\n\t\tgoto claim;\n\t}\n\n\t \n\terr = brcmf_attach(sdiod->dev);\n\tif (err != 0) {\n\t\tbrcmf_err(\"brcmf_attach failed\\n\");\n\t\tgoto free;\n\t}\n\n\t \n\treturn;\n\nfree:\n\tbrcmf_free(sdiod->dev);\nclaim:\n\tsdio_claim_host(sdiod->func1);\ncheckdied:\n\tbrcmf_sdio_checkdied(bus);\nrelease:\n\tsdio_release_host(sdiod->func1);\nfail:\n\tbrcmf_dbg(TRACE, \"failed: dev=%s, err=%d\\n\", dev_name(dev), err);\n\tdevice_release_driver(&sdiod->func2->dev);\n\tdevice_release_driver(dev);\n}\n\nstatic struct brcmf_fw_request *\nbrcmf_sdio_prepare_fw_request(struct brcmf_sdio *bus)\n{\n\tstruct brcmf_fw_request *fwreq;\n\tstruct brcmf_fw_name fwnames[] = {\n\t\t{ \".bin\", bus->sdiodev->fw_name },\n\t\t{ \".txt\", bus->sdiodev->nvram_name },\n\t\t{ \".clm_blob\", bus->sdiodev->clm_name },\n\t};\n\n\tfwreq = brcmf_fw_alloc_request(bus->ci->chip, bus->ci->chiprev,\n\t\t\t\t       brcmf_sdio_fwnames,\n\t\t\t\t       ARRAY_SIZE(brcmf_sdio_fwnames),\n\t\t\t\t       fwnames, ARRAY_SIZE(fwnames));\n\tif (!fwreq)\n\t\treturn NULL;\n\n\tfwreq->items[BRCMF_SDIO_FW_CODE].type = BRCMF_FW_TYPE_BINARY;\n\tfwreq->items[BRCMF_SDIO_FW_NVRAM].type = BRCMF_FW_TYPE_NVRAM;\n\tfwreq->items[BRCMF_SDIO_FW_CLM].type = BRCMF_FW_TYPE_BINARY;\n\tfwreq->items[BRCMF_SDIO_FW_CLM].flags = BRCMF_FW_REQF_OPTIONAL;\n\tfwreq->board_types[0] = bus->sdiodev->settings->board_type;\n\n\treturn fwreq;\n}\n\nstruct brcmf_sdio *brcmf_sdio_probe(struct brcmf_sdio_dev *sdiodev)\n{\n\tint ret;\n\tstruct brcmf_sdio *bus;\n\tstruct workqueue_struct *wq;\n\tstruct brcmf_fw_request *fwreq;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\t \n\tbus = kzalloc(sizeof(struct brcmf_sdio), GFP_ATOMIC);\n\tif (!bus)\n\t\tgoto fail;\n\n\tbus->sdiodev = sdiodev;\n\tsdiodev->bus = bus;\n\tskb_queue_head_init(&bus->glom);\n\tbus->txbound = BRCMF_TXBOUND;\n\tbus->rxbound = BRCMF_RXBOUND;\n\tbus->txminmax = BRCMF_TXMINMAX;\n\tbus->tx_seq = SDPCM_SEQ_WRAP - 1;\n\n\t \n\twq = alloc_ordered_workqueue(\"brcmf_wq/%s\", WQ_MEM_RECLAIM | WQ_HIGHPRI,\n\t\t\t\t     dev_name(&sdiodev->func1->dev));\n\tif (!wq) {\n\t\tbrcmf_err(\"insufficient memory to create txworkqueue\\n\");\n\t\tgoto fail;\n\t}\n\tbrcmf_sdiod_freezer_count(sdiodev);\n\tINIT_WORK(&bus->datawork, brcmf_sdio_dataworker);\n\tbus->brcmf_wq = wq;\n\n\t \n\tif (!(brcmf_sdio_probe_attach(bus))) {\n\t\tbrcmf_err(\"brcmf_sdio_probe_attach failed\\n\");\n\t\tgoto fail;\n\t}\n\n\tspin_lock_init(&bus->rxctl_lock);\n\tspin_lock_init(&bus->txq_lock);\n\tinit_waitqueue_head(&bus->ctrl_wait);\n\tinit_waitqueue_head(&bus->dcmd_resp_wait);\n\n\t \n\ttimer_setup(&bus->timer, brcmf_sdio_watchdog, 0);\n\t \n\tinit_completion(&bus->watchdog_wait);\n\tbus->watchdog_tsk = kthread_run(brcmf_sdio_watchdog_thread,\n\t\t\t\t\tbus, \"brcmf_wdog/%s\",\n\t\t\t\t\tdev_name(&sdiodev->func1->dev));\n\tif (IS_ERR(bus->watchdog_tsk)) {\n\t\tpr_warn(\"brcmf_watchdog thread failed to start\\n\");\n\t\tbus->watchdog_tsk = NULL;\n\t}\n\t \n\tbus->dpc_triggered = false;\n\tbus->dpc_running = false;\n\n\t \n\tbus->tx_hdrlen = SDPCM_HWHDR_LEN + SDPCM_SWHDR_LEN;\n\n\t \n\tbus->blocksize = bus->sdiodev->func2->cur_blksize;\n\tbus->roundup = min(max_roundup, bus->blocksize);\n\n\tsdio_claim_host(bus->sdiodev->func1);\n\n\t \n\tsdio_disable_func(bus->sdiodev->func2);\n\n\tbus->rxflow = false;\n\n\t \n\tbrcmf_sdiod_writeb(bus->sdiodev, SBSDIO_FUNC1_CHIPCLKCSR, 0, NULL);\n\n\tsdio_release_host(bus->sdiodev->func1);\n\n\t \n\tbus->clkstate = CLK_SDONLY;\n\tbus->idletime = BRCMF_IDLE_INTERVAL;\n\tbus->idleclock = BRCMF_IDLE_ACTIVE;\n\n\t \n\tbus->sr_enabled = false;\n\n\tbrcmf_dbg(INFO, \"completed!!\\n\");\n\n\tfwreq = brcmf_sdio_prepare_fw_request(bus);\n\tif (!fwreq) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tret = brcmf_fw_get_firmwares(sdiodev->dev, fwreq,\n\t\t\t\t     brcmf_sdio_firmware_callback);\n\tif (ret != 0) {\n\t\tbrcmf_err(\"async firmware request failed: %d\\n\", ret);\n\t\tkfree(fwreq);\n\t\tgoto fail;\n\t}\n\n\treturn bus;\n\nfail:\n\tbrcmf_sdio_remove(bus);\n\treturn NULL;\n}\n\n \nvoid brcmf_sdio_remove(struct brcmf_sdio *bus)\n{\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tif (bus) {\n\t\t \n\t\tif (bus->watchdog_tsk) {\n\t\t\tsend_sig(SIGTERM, bus->watchdog_tsk, 1);\n\t\t\tkthread_stop(bus->watchdog_tsk);\n\t\t\tbus->watchdog_tsk = NULL;\n\t\t}\n\n\t\t \n\t\tbrcmf_sdiod_intr_unregister(bus->sdiodev);\n\n\t\tbrcmf_detach(bus->sdiodev->dev);\n\t\tbrcmf_free(bus->sdiodev->dev);\n\n\t\tcancel_work_sync(&bus->datawork);\n\t\tif (bus->brcmf_wq)\n\t\t\tdestroy_workqueue(bus->brcmf_wq);\n\n\t\tif (bus->ci) {\n\t\t\tif (bus->sdiodev->state != BRCMF_SDIOD_NOMEDIUM) {\n\t\t\t\tsdio_claim_host(bus->sdiodev->func1);\n\t\t\t\tbrcmf_sdio_wd_timer(bus, false);\n\t\t\t\tbrcmf_sdio_clkctl(bus, CLK_AVAIL, false);\n\t\t\t\t \n\t\t\t\tmsleep(20);\n\t\t\t\tbrcmf_chip_set_passive(bus->ci);\n\t\t\t\tbrcmf_sdio_clkctl(bus, CLK_NONE, false);\n\t\t\t\tsdio_release_host(bus->sdiodev->func1);\n\t\t\t}\n\t\t\tbrcmf_chip_detach(bus->ci);\n\t\t}\n\t\tif (bus->sdiodev->settings)\n\t\t\tbrcmf_release_module_param(bus->sdiodev->settings);\n\n\t\trelease_firmware(bus->sdiodev->clm_fw);\n\t\tbus->sdiodev->clm_fw = NULL;\n\t\tkfree(bus->rxbuf);\n\t\tkfree(bus->hdrbuf);\n\t\tkfree(bus);\n\t}\n\n\tbrcmf_dbg(TRACE, \"Disconnected\\n\");\n}\n\nvoid brcmf_sdio_wd_timer(struct brcmf_sdio *bus, bool active)\n{\n\t \n\tif (!active && bus->wd_active) {\n\t\tdel_timer_sync(&bus->timer);\n\t\tbus->wd_active = false;\n\t\treturn;\n\t}\n\n\t \n\tif (bus->sdiodev->state != BRCMF_SDIOD_DATA)\n\t\treturn;\n\n\tif (active) {\n\t\tif (!bus->wd_active) {\n\t\t\t \n\t\t\tbus->timer.expires = jiffies + BRCMF_WD_POLL;\n\t\t\tadd_timer(&bus->timer);\n\t\t\tbus->wd_active = true;\n\t\t} else {\n\t\t\t \n\t\t\tmod_timer(&bus->timer, jiffies + BRCMF_WD_POLL);\n\t\t}\n\t}\n}\n\nint brcmf_sdio_sleep(struct brcmf_sdio *bus, bool sleep)\n{\n\tint ret;\n\n\tsdio_claim_host(bus->sdiodev->func1);\n\tret = brcmf_sdio_bus_sleep(bus, sleep, false);\n\tsdio_release_host(bus->sdiodev->func1);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}