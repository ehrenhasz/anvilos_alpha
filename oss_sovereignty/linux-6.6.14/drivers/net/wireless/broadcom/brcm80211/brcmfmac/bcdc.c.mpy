{
  "module_name": "bcdc.c",
  "hash_id": "41bc1700d823f5e3eecbae87eca9bb709169f6ba223948bfac35241e3b4176f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcdc.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/types.h>\n#include <linux/netdevice.h>\n\n#include <brcmu_utils.h>\n#include <brcmu_wifi.h>\n\n#include \"core.h\"\n#include \"bus.h\"\n#include \"fwsignal.h\"\n#include \"debug.h\"\n#include \"tracepoint.h\"\n#include \"proto.h\"\n#include \"bcdc.h\"\n\nstruct brcmf_proto_bcdc_dcmd {\n\t__le32 cmd;\t \n\t__le32 len;\t \n\t__le32 flags;\t \n\t__le32 status;\t \n};\n\n \n#define BCDC_DCMD_ERROR\t\t0x01\t\t \n#define BCDC_DCMD_SET\t\t0x02\t\t \n#define BCDC_DCMD_IF_MASK\t0xF000\t\t \n#define BCDC_DCMD_IF_SHIFT\t12\n#define BCDC_DCMD_ID_MASK\t0xFFFF0000\t \n#define BCDC_DCMD_ID_SHIFT\t16\t\t \n#define BCDC_DCMD_ID(flags)\t\\\n\t(((flags) & BCDC_DCMD_ID_MASK) >> BCDC_DCMD_ID_SHIFT)\n\n \n#define\tBCDC_HEADER_LEN\t\t4\n#define BCDC_PROTO_VER\t\t2\t \n#define BCDC_FLAG_VER_MASK\t0xf0\t \n#define BCDC_FLAG_VER_SHIFT\t4\t \n#define BCDC_FLAG_SUM_GOOD\t0x04\t \n#define BCDC_FLAG_SUM_NEEDED\t0x08\t \n#define BCDC_PRIORITY_MASK\t0x7\n#define BCDC_FLAG2_IF_MASK\t0x0f\t \n#define BCDC_FLAG2_IF_SHIFT\t0\n\n#define BCDC_GET_IF_IDX(hdr) \\\n\t((int)((((hdr)->flags2) & BCDC_FLAG2_IF_MASK) >> BCDC_FLAG2_IF_SHIFT))\n#define BCDC_SET_IF_IDX(hdr, idx) \\\n\t((hdr)->flags2 = (((hdr)->flags2 & ~BCDC_FLAG2_IF_MASK) | \\\n\t((idx) << BCDC_FLAG2_IF_SHIFT)))\n\n \nstruct brcmf_proto_bcdc_header {\n\tu8 flags;\n\tu8 priority;\n\tu8 flags2;\n\tu8 data_offset;\n};\n\n \n#define BRCMF_PROT_FW_SIGNAL_MAX_TXBYTES\t12\n\n#define RETRIES 2  \n#define BUS_HEADER_LEN\t(16+64)\t\t \n#define ROUND_UP_MARGIN 2048\n\nstruct brcmf_bcdc {\n\tu16 reqid;\n\tu8 bus_header[BUS_HEADER_LEN];\n\tstruct brcmf_proto_bcdc_dcmd msg;\n\tunsigned char buf[BRCMF_DCMD_MAXLEN];\n\tstruct brcmf_fws_info *fws;\n};\n\n\nstruct brcmf_fws_info *drvr_to_fws(struct brcmf_pub *drvr)\n{\n\tstruct brcmf_bcdc *bcdc = drvr->proto->pd;\n\n\treturn bcdc->fws;\n}\n\nstatic int\nbrcmf_proto_bcdc_msg(struct brcmf_pub *drvr, int ifidx, uint cmd, void *buf,\n\t\t     uint len, bool set)\n{\n\tstruct brcmf_bcdc *bcdc = (struct brcmf_bcdc *)drvr->proto->pd;\n\tstruct brcmf_proto_bcdc_dcmd *msg = &bcdc->msg;\n\tu32 flags;\n\n\tbrcmf_dbg(BCDC, \"Enter\\n\");\n\n\tmemset(msg, 0, sizeof(struct brcmf_proto_bcdc_dcmd));\n\n\tmsg->cmd = cpu_to_le32(cmd);\n\tmsg->len = cpu_to_le32(len);\n\tflags = (++bcdc->reqid << BCDC_DCMD_ID_SHIFT);\n\tif (set)\n\t\tflags |= BCDC_DCMD_SET;\n\tflags = (flags & ~BCDC_DCMD_IF_MASK) |\n\t\t(ifidx << BCDC_DCMD_IF_SHIFT);\n\tmsg->flags = cpu_to_le32(flags);\n\n\tif (buf)\n\t\tmemcpy(bcdc->buf, buf, len);\n\n\tlen += sizeof(*msg);\n\tif (len > BRCMF_TX_IOCTL_MAX_MSG_SIZE)\n\t\tlen = BRCMF_TX_IOCTL_MAX_MSG_SIZE;\n\n\t \n\treturn brcmf_bus_txctl(drvr->bus_if, (unsigned char *)&bcdc->msg, len);\n}\n\nstatic int brcmf_proto_bcdc_cmplt(struct brcmf_pub *drvr, u32 id, u32 len)\n{\n\tint ret;\n\tstruct brcmf_bcdc *bcdc = (struct brcmf_bcdc *)drvr->proto->pd;\n\n\tbrcmf_dbg(BCDC, \"Enter\\n\");\n\tlen += sizeof(struct brcmf_proto_bcdc_dcmd);\n\tdo {\n\t\tret = brcmf_bus_rxctl(drvr->bus_if, (unsigned char *)&bcdc->msg,\n\t\t\t\t      len);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t} while (BCDC_DCMD_ID(le32_to_cpu(bcdc->msg.flags)) != id);\n\n\treturn ret;\n}\n\nstatic int\nbrcmf_proto_bcdc_query_dcmd(struct brcmf_pub *drvr, int ifidx, uint cmd,\n\t\t\t    void *buf, uint len, int *fwerr)\n{\n\tstruct brcmf_bcdc *bcdc = (struct brcmf_bcdc *)drvr->proto->pd;\n\tstruct brcmf_proto_bcdc_dcmd *msg = &bcdc->msg;\n\tvoid *info;\n\tint ret = 0, retries = 0;\n\tu32 id, flags;\n\n\tbrcmf_dbg(BCDC, \"Enter, cmd %d len %d\\n\", cmd, len);\n\n\t*fwerr = 0;\n\tret = brcmf_proto_bcdc_msg(drvr, ifidx, cmd, buf, len, false);\n\tif (ret < 0) {\n\t\tbphy_err(drvr, \"brcmf_proto_bcdc_msg failed w/status %d\\n\",\n\t\t\t ret);\n\t\tgoto done;\n\t}\n\nretry:\n\t \n\tret = brcmf_proto_bcdc_cmplt(drvr, bcdc->reqid, len);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tflags = le32_to_cpu(msg->flags);\n\tid = (flags & BCDC_DCMD_ID_MASK) >> BCDC_DCMD_ID_SHIFT;\n\n\tif ((id < bcdc->reqid) && (++retries < RETRIES))\n\t\tgoto retry;\n\tif (id != bcdc->reqid) {\n\t\tbphy_err(drvr, \"%s: unexpected request id %d (expected %d)\\n\",\n\t\t\t brcmf_ifname(brcmf_get_ifp(drvr, ifidx)), id,\n\t\t\t bcdc->reqid);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\t \n\tinfo = (void *)&bcdc->buf[0];\n\n\t \n\tif (buf) {\n\t\tif (ret < (int)len)\n\t\t\tlen = ret;\n\t\tmemcpy(buf, info, len);\n\t}\n\n\tret = 0;\n\n\t \n\tif (flags & BCDC_DCMD_ERROR)\n\t\t*fwerr = le32_to_cpu(msg->status);\ndone:\n\treturn ret;\n}\n\nstatic int\nbrcmf_proto_bcdc_set_dcmd(struct brcmf_pub *drvr, int ifidx, uint cmd,\n\t\t\t  void *buf, uint len, int *fwerr)\n{\n\tstruct brcmf_bcdc *bcdc = (struct brcmf_bcdc *)drvr->proto->pd;\n\tstruct brcmf_proto_bcdc_dcmd *msg = &bcdc->msg;\n\tint ret;\n\tu32 flags, id;\n\n\tbrcmf_dbg(BCDC, \"Enter, cmd %d len %d\\n\", cmd, len);\n\n\t*fwerr = 0;\n\tret = brcmf_proto_bcdc_msg(drvr, ifidx, cmd, buf, len, true);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tret = brcmf_proto_bcdc_cmplt(drvr, bcdc->reqid, len);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tflags = le32_to_cpu(msg->flags);\n\tid = (flags & BCDC_DCMD_ID_MASK) >> BCDC_DCMD_ID_SHIFT;\n\n\tif (id != bcdc->reqid) {\n\t\tbphy_err(drvr, \"%s: unexpected request id %d (expected %d)\\n\",\n\t\t\t brcmf_ifname(brcmf_get_ifp(drvr, ifidx)), id,\n\t\t\t bcdc->reqid);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tret = 0;\n\n\t \n\tif (flags & BCDC_DCMD_ERROR)\n\t\t*fwerr = le32_to_cpu(msg->status);\n\ndone:\n\treturn ret;\n}\n\nstatic void\nbrcmf_proto_bcdc_hdrpush(struct brcmf_pub *drvr, int ifidx, u8 offset,\n\t\t\t struct sk_buff *pktbuf)\n{\n\tstruct brcmf_proto_bcdc_header *h;\n\n\tbrcmf_dbg(BCDC, \"Enter\\n\");\n\n\t \n\tskb_push(pktbuf, BCDC_HEADER_LEN);\n\n\th = (struct brcmf_proto_bcdc_header *)(pktbuf->data);\n\n\th->flags = (BCDC_PROTO_VER << BCDC_FLAG_VER_SHIFT);\n\tif (pktbuf->ip_summed == CHECKSUM_PARTIAL)\n\t\th->flags |= BCDC_FLAG_SUM_NEEDED;\n\n\th->priority = (pktbuf->priority & BCDC_PRIORITY_MASK);\n\th->flags2 = 0;\n\th->data_offset = offset;\n\tBCDC_SET_IF_IDX(h, ifidx);\n\ttrace_brcmf_bcdchdr(pktbuf->data);\n}\n\nstatic int\nbrcmf_proto_bcdc_hdrpull(struct brcmf_pub *drvr, bool do_fws,\n\t\t\t struct sk_buff *pktbuf, struct brcmf_if **ifp)\n{\n\tstruct brcmf_proto_bcdc_header *h;\n\tstruct brcmf_if *tmp_if;\n\n\tbrcmf_dbg(BCDC, \"Enter\\n\");\n\n\t \n\tif (pktbuf->len <= BCDC_HEADER_LEN) {\n\t\tbrcmf_dbg(INFO, \"rx data too short (%d <= %d)\\n\",\n\t\t\t  pktbuf->len, BCDC_HEADER_LEN);\n\t\treturn -EBADE;\n\t}\n\n\ttrace_brcmf_bcdchdr(pktbuf->data);\n\th = (struct brcmf_proto_bcdc_header *)(pktbuf->data);\n\n\ttmp_if = brcmf_get_ifp(drvr, BCDC_GET_IF_IDX(h));\n\tif (!tmp_if) {\n\t\tbrcmf_dbg(INFO, \"no matching ifp found\\n\");\n\t\treturn -EBADE;\n\t}\n\tif (((h->flags & BCDC_FLAG_VER_MASK) >> BCDC_FLAG_VER_SHIFT) !=\n\t    BCDC_PROTO_VER) {\n\t\tbphy_err(drvr, \"%s: non-BCDC packet received, flags 0x%x\\n\",\n\t\t\t brcmf_ifname(tmp_if), h->flags);\n\t\treturn -EBADE;\n\t}\n\n\tif (h->flags & BCDC_FLAG_SUM_GOOD) {\n\t\tbrcmf_dbg(BCDC, \"%s: BDC rcv, good checksum, flags 0x%x\\n\",\n\t\t\t  brcmf_ifname(tmp_if), h->flags);\n\t\tpktbuf->ip_summed = CHECKSUM_UNNECESSARY;\n\t}\n\n\tpktbuf->priority = h->priority & BCDC_PRIORITY_MASK;\n\n\tskb_pull(pktbuf, BCDC_HEADER_LEN);\n\tif (do_fws)\n\t\tbrcmf_fws_hdrpull(tmp_if, h->data_offset << 2, pktbuf);\n\telse\n\t\tskb_pull(pktbuf, h->data_offset << 2);\n\n\tif (pktbuf->len == 0)\n\t\treturn -ENODATA;\n\n\tif (ifp != NULL)\n\t\t*ifp = tmp_if;\n\treturn 0;\n}\n\nstatic int brcmf_proto_bcdc_tx_queue_data(struct brcmf_pub *drvr, int ifidx,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct brcmf_if *ifp = brcmf_get_ifp(drvr, ifidx);\n\tstruct brcmf_bcdc *bcdc = drvr->proto->pd;\n\n\tif (!brcmf_fws_queue_skbs(bcdc->fws))\n\t\treturn brcmf_proto_txdata(drvr, ifidx, 0, skb);\n\n\treturn brcmf_fws_process_skb(ifp, skb);\n}\n\nstatic int\nbrcmf_proto_bcdc_txdata(struct brcmf_pub *drvr, int ifidx, u8 offset,\n\t\t\tstruct sk_buff *pktbuf)\n{\n\tbrcmf_proto_bcdc_hdrpush(drvr, ifidx, offset, pktbuf);\n\treturn brcmf_bus_txdata(drvr->bus_if, pktbuf);\n}\n\nvoid brcmf_proto_bcdc_txflowblock(struct device *dev, bool state)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_pub *drvr = bus_if->drvr;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tbrcmf_fws_bus_blocked(drvr, state);\n}\n\nvoid\nbrcmf_proto_bcdc_txcomplete(struct device *dev, struct sk_buff *txp,\n\t\t\t    bool success)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_bcdc *bcdc = bus_if->drvr->proto->pd;\n\tstruct brcmf_if *ifp;\n\n\t \n\tif (brcmf_fws_fc_active(bcdc->fws)) {\n\t\tbrcmf_fws_bustxcomplete(bcdc->fws, txp, success);\n\t} else {\n\t\tif (brcmf_proto_bcdc_hdrpull(bus_if->drvr, false, txp, &ifp))\n\t\t\tbrcmu_pkt_buf_free_skb(txp);\n\t\telse\n\t\t\tbrcmf_txfinalize(ifp, txp, success);\n\t}\n}\n\nstatic void\nbrcmf_proto_bcdc_configure_addr_mode(struct brcmf_pub *drvr, int ifidx,\n\t\t\t\t     enum proto_addr_mode addr_mode)\n{\n}\n\nstatic void\nbrcmf_proto_bcdc_delete_peer(struct brcmf_pub *drvr, int ifidx,\n\t\t\t     u8 peer[ETH_ALEN])\n{\n}\n\nstatic void\nbrcmf_proto_bcdc_add_tdls_peer(struct brcmf_pub *drvr, int ifidx,\n\t\t\t       u8 peer[ETH_ALEN])\n{\n}\n\nstatic void brcmf_proto_bcdc_rxreorder(struct brcmf_if *ifp,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tbrcmf_fws_rxreorder(ifp, skb);\n}\n\nstatic void\nbrcmf_proto_bcdc_add_if(struct brcmf_if *ifp)\n{\n\tbrcmf_fws_add_interface(ifp);\n}\n\nstatic void\nbrcmf_proto_bcdc_del_if(struct brcmf_if *ifp)\n{\n\tbrcmf_fws_del_interface(ifp);\n}\n\nstatic void\nbrcmf_proto_bcdc_reset_if(struct brcmf_if *ifp)\n{\n\tbrcmf_fws_reset_interface(ifp);\n}\n\nstatic int\nbrcmf_proto_bcdc_init_done(struct brcmf_pub *drvr)\n{\n\tstruct brcmf_bcdc *bcdc = drvr->proto->pd;\n\tstruct brcmf_fws_info *fws;\n\n\tfws = brcmf_fws_attach(drvr);\n\tif (IS_ERR(fws))\n\t\treturn PTR_ERR(fws);\n\n\tbcdc->fws = fws;\n\treturn 0;\n}\n\nstatic void brcmf_proto_bcdc_debugfs_create(struct brcmf_pub *drvr)\n{\n\tbrcmf_fws_debugfs_create(drvr);\n}\n\nint brcmf_proto_bcdc_attach(struct brcmf_pub *drvr)\n{\n\tstruct brcmf_bcdc *bcdc;\n\n\tbcdc = kzalloc(sizeof(*bcdc), GFP_ATOMIC);\n\tif (!bcdc)\n\t\tgoto fail;\n\n\t \n\tif ((unsigned long)(&bcdc->msg + 1) != (unsigned long)bcdc->buf) {\n\t\tbphy_err(drvr, \"struct brcmf_proto_bcdc is not correctly defined\\n\");\n\t\tgoto fail;\n\t}\n\n\tdrvr->proto->hdrpull = brcmf_proto_bcdc_hdrpull;\n\tdrvr->proto->query_dcmd = brcmf_proto_bcdc_query_dcmd;\n\tdrvr->proto->set_dcmd = brcmf_proto_bcdc_set_dcmd;\n\tdrvr->proto->tx_queue_data = brcmf_proto_bcdc_tx_queue_data;\n\tdrvr->proto->txdata = brcmf_proto_bcdc_txdata;\n\tdrvr->proto->configure_addr_mode = brcmf_proto_bcdc_configure_addr_mode;\n\tdrvr->proto->delete_peer = brcmf_proto_bcdc_delete_peer;\n\tdrvr->proto->add_tdls_peer = brcmf_proto_bcdc_add_tdls_peer;\n\tdrvr->proto->rxreorder = brcmf_proto_bcdc_rxreorder;\n\tdrvr->proto->add_if = brcmf_proto_bcdc_add_if;\n\tdrvr->proto->del_if = brcmf_proto_bcdc_del_if;\n\tdrvr->proto->reset_if = brcmf_proto_bcdc_reset_if;\n\tdrvr->proto->init_done = brcmf_proto_bcdc_init_done;\n\tdrvr->proto->debugfs_create = brcmf_proto_bcdc_debugfs_create;\n\tdrvr->proto->pd = bcdc;\n\n\tdrvr->hdrlen += BCDC_HEADER_LEN + BRCMF_PROT_FW_SIGNAL_MAX_TXBYTES;\n\tdrvr->bus_if->maxctl = BRCMF_DCMD_MAXLEN +\n\t\t\tsizeof(struct brcmf_proto_bcdc_dcmd) + ROUND_UP_MARGIN;\n\treturn 0;\n\nfail:\n\tkfree(bcdc);\n\treturn -ENOMEM;\n}\n\nvoid brcmf_proto_bcdc_detach(struct brcmf_pub *drvr)\n{\n\tstruct brcmf_bcdc *bcdc = drvr->proto->pd;\n\n\tdrvr->proto->pd = NULL;\n\tbrcmf_fws_detach(bcdc->fws);\n\tkfree(bcdc);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}