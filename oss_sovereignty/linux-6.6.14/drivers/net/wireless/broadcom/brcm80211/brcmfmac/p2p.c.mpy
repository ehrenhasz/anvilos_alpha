{
  "module_name": "p2p.c",
  "hash_id": "458908fb7fa7a558a5dbefa2034275bd76881a5a15a80cd734fecb420816a631",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/rtnetlink.h>\n#include <net/cfg80211.h>\n\n#include <brcmu_wifi.h>\n#include <brcmu_utils.h>\n#include <defs.h>\n#include \"core.h\"\n#include \"debug.h\"\n#include \"fwil.h\"\n#include \"fwil_types.h\"\n#include \"p2p.h\"\n#include \"cfg80211.h\"\n#include \"feature.h\"\n\n \n#define P2PAPI_SCAN_NPROBES 1\n#define P2PAPI_SCAN_DWELL_TIME_MS 80\n#define P2PAPI_SCAN_SOCIAL_DWELL_TIME_MS 40\n#define P2PAPI_SCAN_HOME_TIME_MS 60\n#define P2PAPI_SCAN_NPROBS_TIME_MS 30\n#define P2PAPI_SCAN_AF_SEARCH_DWELL_TIME_MS 100\n#define WL_SCAN_CONNECT_DWELL_TIME_MS 200\n#define WL_SCAN_JOIN_PROBE_INTERVAL_MS 20\n\n#define BRCMF_P2P_WILDCARD_SSID\t\t\"DIRECT-\"\n#define BRCMF_P2P_WILDCARD_SSID_LEN\t(sizeof(BRCMF_P2P_WILDCARD_SSID) - 1)\n\n#define SOCIAL_CHAN_1\t\t1\n#define SOCIAL_CHAN_2\t\t6\n#define SOCIAL_CHAN_3\t\t11\n#define IS_P2P_SOCIAL_CHANNEL(channel) ((channel == SOCIAL_CHAN_1) || \\\n\t\t\t\t\t (channel == SOCIAL_CHAN_2) || \\\n\t\t\t\t\t (channel == SOCIAL_CHAN_3))\n#define BRCMF_P2P_TEMP_CHAN\tSOCIAL_CHAN_3\n#define SOCIAL_CHAN_CNT\t\t3\n#define AF_PEER_SEARCH_CNT\t2\n\n#define BRCMF_SCB_TIMEOUT_VALUE\t20\n\n#define P2P_VER\t\t\t9\t \n#define P2P_PUB_AF_CATEGORY\t0x04\n#define P2P_PUB_AF_ACTION\t0x09\n#define P2P_AF_CATEGORY\t\t0x7f\n#define P2P_OUI\t\t\t\"\\x50\\x6F\\x9A\"\t \n#define P2P_OUI_LEN\t\t3\t\t \n\n \n#define DOT11_ACTION_HDR_LEN\t2\t \n#define DOT11_ACTION_CAT_OFF\t0\t \n#define DOT11_ACTION_ACT_OFF\t1\t \n\n#define P2P_AF_DWELL_TIME\t\t200\n#define P2P_AF_MIN_DWELL_TIME\t\t100\n#define P2P_AF_MED_DWELL_TIME\t\t400\n#define P2P_AF_LONG_DWELL_TIME\t\t1000\n#define P2P_AF_TX_MAX_RETRY\t\t5\n#define P2P_AF_MAX_WAIT_TIME\t\tmsecs_to_jiffies(2000)\n#define P2P_INVALID_CHANNEL\t\t-1\n#define P2P_CHANNEL_SYNC_RETRY\t\t5\n#define P2P_AF_FRM_SCAN_MAX_WAIT\tmsecs_to_jiffies(450)\n#define P2P_DEFAULT_SLEEP_TIME_VSDB\t200\n#define P2P_AF_RETRY_DELAY_TIME\t\t40\n\n \n#define P2P_PAF_GON_REQ\t\t0\t \n#define P2P_PAF_GON_RSP\t\t1\t \n#define P2P_PAF_GON_CONF\t2\t \n#define P2P_PAF_INVITE_REQ\t3\t \n#define P2P_PAF_INVITE_RSP\t4\t \n#define P2P_PAF_DEVDIS_REQ\t5\t \n#define P2P_PAF_DEVDIS_RSP\t6\t \n#define P2P_PAF_PROVDIS_REQ\t7\t \n#define P2P_PAF_PROVDIS_RSP\t8\t \n#define P2P_PAF_SUBTYPE_INVALID\t255\t \n\n \n#define P2P_AF_NOTICE_OF_ABSENCE\t0\t \n#define P2P_AF_PRESENCE_REQ\t\t1\t \n#define P2P_AF_PRESENCE_RSP\t\t2\t \n#define P2P_AF_GO_DISC_REQ\t\t3\t \n\n \n#define P2PSD_ACTION_CATEGORY\t\t0x04\t \n#define P2PSD_ACTION_ID_GAS_IREQ\t0x0a\t \n#define P2PSD_ACTION_ID_GAS_IRESP\t0x0b\t \n#define P2PSD_ACTION_ID_GAS_CREQ\t0x0c\t \n#define P2PSD_ACTION_ID_GAS_CRESP\t0x0d\t \n\n#define BRCMF_P2P_DISABLE_TIMEOUT\tmsecs_to_jiffies(500)\n\n \n#define CUSTOM_RETRY_MASK 0xff000000\n \nstruct brcmf_p2p_disc_st_le {\n\tu8 state;\n\t__le16 chspec;\n\t__le16 dwell;\n};\n\n \nenum brcmf_p2p_disc_state {\n\tWL_P2P_DISC_ST_SCAN,\n\tWL_P2P_DISC_ST_LISTEN,\n\tWL_P2P_DISC_ST_SEARCH\n};\n\n \nstruct brcmf_p2p_scan_le {\n\tu8 type;\n\tu8 reserved[3];\n\tunion {\n\t\tstruct brcmf_escan_params_le eparams;\n\t\tstruct brcmf_scan_params_le sparams;\n\t};\n};\n\n \nstruct brcmf_p2p_pub_act_frame {\n\tu8\tcategory;\n\tu8\taction;\n\tu8\toui[3];\n\tu8\toui_type;\n\tu8\tsubtype;\n\tu8\tdialog_token;\n\tu8\telts[];\n};\n\n \nstruct brcmf_p2p_action_frame {\n\tu8\tcategory;\n\tu8\toui[3];\n\tu8\ttype;\n\tu8\tsubtype;\n\tu8\tdialog_token;\n\tu8\telts[];\n};\n\n \nstruct brcmf_p2psd_gas_pub_act_frame {\n\tu8\tcategory;\n\tu8\taction;\n\tu8\tdialog_token;\n\tu8\tquery_data[];\n};\n\n \nstruct brcmf_config_af_params {\n\ts32 mpc_onoff;\n\tbool search_channel;\n\tbool extra_listen;\n};\n\n \nstatic bool brcmf_p2p_is_pub_action(void *frame, u32 frame_len)\n{\n\tstruct brcmf_p2p_pub_act_frame *pact_frm;\n\n\tif (frame == NULL)\n\t\treturn false;\n\n\tpact_frm = (struct brcmf_p2p_pub_act_frame *)frame;\n\tif (frame_len < sizeof(*pact_frm))\n\t\treturn false;\n\n\tif (pact_frm->category == P2P_PUB_AF_CATEGORY &&\n\t    pact_frm->action == P2P_PUB_AF_ACTION &&\n\t    pact_frm->oui_type == P2P_VER &&\n\t    memcmp(pact_frm->oui, P2P_OUI, P2P_OUI_LEN) == 0)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic bool brcmf_p2p_is_p2p_action(void *frame, u32 frame_len)\n{\n\tstruct brcmf_p2p_action_frame *act_frm;\n\n\tif (frame == NULL)\n\t\treturn false;\n\n\tact_frm = (struct brcmf_p2p_action_frame *)frame;\n\tif (frame_len < sizeof(*act_frm))\n\t\treturn false;\n\n\tif (act_frm->category == P2P_AF_CATEGORY &&\n\t    act_frm->type  == P2P_VER &&\n\t    memcmp(act_frm->oui, P2P_OUI, P2P_OUI_LEN) == 0)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic bool brcmf_p2p_is_gas_action(void *frame, u32 frame_len)\n{\n\tstruct brcmf_p2psd_gas_pub_act_frame *sd_act_frm;\n\n\tif (frame == NULL)\n\t\treturn false;\n\n\tsd_act_frm = (struct brcmf_p2psd_gas_pub_act_frame *)frame;\n\tif (frame_len < sizeof(*sd_act_frm))\n\t\treturn false;\n\n\tif (sd_act_frm->category != P2PSD_ACTION_CATEGORY)\n\t\treturn false;\n\n\tif (sd_act_frm->action == P2PSD_ACTION_ID_GAS_IREQ ||\n\t    sd_act_frm->action == P2PSD_ACTION_ID_GAS_IRESP ||\n\t    sd_act_frm->action == P2PSD_ACTION_ID_GAS_CREQ ||\n\t    sd_act_frm->action == P2PSD_ACTION_ID_GAS_CRESP)\n\t\treturn true;\n\n\treturn false;\n}\n\n \n\n#ifdef DEBUG\n\nstatic void brcmf_p2p_print_actframe(bool tx, void *frame, u32 frame_len)\n{\n\tstruct brcmf_p2p_pub_act_frame *pact_frm;\n\tstruct brcmf_p2p_action_frame *act_frm;\n\tstruct brcmf_p2psd_gas_pub_act_frame *sd_act_frm;\n\n\tif (!frame || frame_len <= 2)\n\t\treturn;\n\n\tif (brcmf_p2p_is_pub_action(frame, frame_len)) {\n\t\tpact_frm = (struct brcmf_p2p_pub_act_frame *)frame;\n\t\tswitch (pact_frm->subtype) {\n\t\tcase P2P_PAF_GON_REQ:\n\t\t\tbrcmf_dbg(TRACE, \"%s P2P Group Owner Negotiation Req Frame\\n\",\n\t\t\t\t  (tx) ? \"TX\" : \"RX\");\n\t\t\tbreak;\n\t\tcase P2P_PAF_GON_RSP:\n\t\t\tbrcmf_dbg(TRACE, \"%s P2P Group Owner Negotiation Rsp Frame\\n\",\n\t\t\t\t  (tx) ? \"TX\" : \"RX\");\n\t\t\tbreak;\n\t\tcase P2P_PAF_GON_CONF:\n\t\t\tbrcmf_dbg(TRACE, \"%s P2P Group Owner Negotiation Confirm Frame\\n\",\n\t\t\t\t  (tx) ? \"TX\" : \"RX\");\n\t\t\tbreak;\n\t\tcase P2P_PAF_INVITE_REQ:\n\t\t\tbrcmf_dbg(TRACE, \"%s P2P Invitation Request  Frame\\n\",\n\t\t\t\t  (tx) ? \"TX\" : \"RX\");\n\t\t\tbreak;\n\t\tcase P2P_PAF_INVITE_RSP:\n\t\t\tbrcmf_dbg(TRACE, \"%s P2P Invitation Response Frame\\n\",\n\t\t\t\t  (tx) ? \"TX\" : \"RX\");\n\t\t\tbreak;\n\t\tcase P2P_PAF_DEVDIS_REQ:\n\t\t\tbrcmf_dbg(TRACE, \"%s P2P Device Discoverability Request Frame\\n\",\n\t\t\t\t  (tx) ? \"TX\" : \"RX\");\n\t\t\tbreak;\n\t\tcase P2P_PAF_DEVDIS_RSP:\n\t\t\tbrcmf_dbg(TRACE, \"%s P2P Device Discoverability Response Frame\\n\",\n\t\t\t\t  (tx) ? \"TX\" : \"RX\");\n\t\t\tbreak;\n\t\tcase P2P_PAF_PROVDIS_REQ:\n\t\t\tbrcmf_dbg(TRACE, \"%s P2P Provision Discovery Request Frame\\n\",\n\t\t\t\t  (tx) ? \"TX\" : \"RX\");\n\t\t\tbreak;\n\t\tcase P2P_PAF_PROVDIS_RSP:\n\t\t\tbrcmf_dbg(TRACE, \"%s P2P Provision Discovery Response Frame\\n\",\n\t\t\t\t  (tx) ? \"TX\" : \"RX\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbrcmf_dbg(TRACE, \"%s Unknown P2P Public Action Frame\\n\",\n\t\t\t\t  (tx) ? \"TX\" : \"RX\");\n\t\t\tbreak;\n\t\t}\n\t} else if (brcmf_p2p_is_p2p_action(frame, frame_len)) {\n\t\tact_frm = (struct brcmf_p2p_action_frame *)frame;\n\t\tswitch (act_frm->subtype) {\n\t\tcase P2P_AF_NOTICE_OF_ABSENCE:\n\t\t\tbrcmf_dbg(TRACE, \"%s P2P Notice of Absence Frame\\n\",\n\t\t\t\t  (tx) ? \"TX\" : \"RX\");\n\t\t\tbreak;\n\t\tcase P2P_AF_PRESENCE_REQ:\n\t\t\tbrcmf_dbg(TRACE, \"%s P2P Presence Request Frame\\n\",\n\t\t\t\t  (tx) ? \"TX\" : \"RX\");\n\t\t\tbreak;\n\t\tcase P2P_AF_PRESENCE_RSP:\n\t\t\tbrcmf_dbg(TRACE, \"%s P2P Presence Response Frame\\n\",\n\t\t\t\t  (tx) ? \"TX\" : \"RX\");\n\t\t\tbreak;\n\t\tcase P2P_AF_GO_DISC_REQ:\n\t\t\tbrcmf_dbg(TRACE, \"%s P2P Discoverability Request Frame\\n\",\n\t\t\t\t  (tx) ? \"TX\" : \"RX\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbrcmf_dbg(TRACE, \"%s Unknown P2P Action Frame\\n\",\n\t\t\t\t  (tx) ? \"TX\" : \"RX\");\n\t\t}\n\n\t} else if (brcmf_p2p_is_gas_action(frame, frame_len)) {\n\t\tsd_act_frm = (struct brcmf_p2psd_gas_pub_act_frame *)frame;\n\t\tswitch (sd_act_frm->action) {\n\t\tcase P2PSD_ACTION_ID_GAS_IREQ:\n\t\t\tbrcmf_dbg(TRACE, \"%s P2P GAS Initial Request\\n\",\n\t\t\t\t  (tx) ? \"TX\" : \"RX\");\n\t\t\tbreak;\n\t\tcase P2PSD_ACTION_ID_GAS_IRESP:\n\t\t\tbrcmf_dbg(TRACE, \"%s P2P GAS Initial Response\\n\",\n\t\t\t\t  (tx) ? \"TX\" : \"RX\");\n\t\t\tbreak;\n\t\tcase P2PSD_ACTION_ID_GAS_CREQ:\n\t\t\tbrcmf_dbg(TRACE, \"%s P2P GAS Comeback Request\\n\",\n\t\t\t\t  (tx) ? \"TX\" : \"RX\");\n\t\t\tbreak;\n\t\tcase P2PSD_ACTION_ID_GAS_CRESP:\n\t\t\tbrcmf_dbg(TRACE, \"%s P2P GAS Comeback Response\\n\",\n\t\t\t\t  (tx) ? \"TX\" : \"RX\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbrcmf_dbg(TRACE, \"%s Unknown P2P GAS Frame\\n\",\n\t\t\t\t  (tx) ? \"TX\" : \"RX\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n#else\n\nstatic void brcmf_p2p_print_actframe(bool tx, void *frame, u32 frame_len)\n{\n}\n\n#endif\n\n\n \nstatic int brcmf_p2p_set_firmware(struct brcmf_if *ifp, u8 *p2p_mac)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\ts32 ret = 0;\n\n\tbrcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);\n\tbrcmf_fil_iovar_int_set(ifp, \"apsta\", 1);\n\tbrcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 1);\n\n\t \n\tbrcmf_fil_iovar_int_set(ifp, \"p2p_disc\", 0);\n\n\tret = brcmf_fil_iovar_data_set(ifp, \"p2p_da_override\", p2p_mac,\n\t\t\t\t       ETH_ALEN);\n\tif (ret)\n\t\tbphy_err(drvr, \"failed to update device address ret %d\\n\", ret);\n\n\treturn ret;\n}\n\n \nstatic void brcmf_p2p_generate_bss_mac(struct brcmf_p2p_info *p2p, u8 *dev_addr)\n{\n\tstruct brcmf_if *pri_ifp = p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif->ifp;\n\tbool random_addr = false;\n\tbool local_admin = false;\n\n\tif (!dev_addr || is_zero_ether_addr(dev_addr)) {\n\t\t \n\t\tif (pri_ifp->mac_addr[0] & 0x02) {\n\t\t\trandom_addr = true;\n\t\t} else {\n\t\t\tdev_addr = pri_ifp->mac_addr;\n\t\t\tlocal_admin = true;\n\t\t}\n\t}\n\n\t \n\tif (random_addr)\n\t\teth_random_addr(p2p->dev_addr);\n\telse\n\t\tmemcpy(p2p->dev_addr, dev_addr, ETH_ALEN);\n\n\tif (local_admin)\n\t\tp2p->dev_addr[0] |= 0x02;\n\n\t \n\tmemcpy(p2p->conn_int_addr, p2p->dev_addr, ETH_ALEN);\n\tp2p->conn_int_addr[0] |= 0x02;\n\tp2p->conn_int_addr[4] ^= 0x80;\n\n\tmemcpy(p2p->conn2_int_addr, p2p->dev_addr, ETH_ALEN);\n\tp2p->conn2_int_addr[0] |= 0x02;\n\tp2p->conn2_int_addr[4] ^= 0x90;\n}\n\n \nstatic bool brcmf_p2p_scan_is_p2p_request(struct cfg80211_scan_request *request)\n{\n\tstruct cfg80211_ssid *ssids = request->ssids;\n\tint i;\n\n\tfor (i = 0; i < request->n_ssids; i++) {\n\t\tif (ssids[i].ssid_len != BRCMF_P2P_WILDCARD_SSID_LEN)\n\t\t\tcontinue;\n\n\t\tbrcmf_dbg(INFO, \"comparing ssid \\\"%s\\\"\", ssids[i].ssid);\n\t\tif (!memcmp(BRCMF_P2P_WILDCARD_SSID, ssids[i].ssid,\n\t\t\t    BRCMF_P2P_WILDCARD_SSID_LEN))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic s32 brcmf_p2p_set_discover_state(struct brcmf_if *ifp, u8 state,\n\t\t\t\t\tu16 chanspec, u16 listen_ms)\n{\n\tstruct brcmf_p2p_disc_st_le discover_state;\n\ts32 ret = 0;\n\tbrcmf_dbg(TRACE, \"enter\\n\");\n\n\tdiscover_state.state = state;\n\tdiscover_state.chspec = cpu_to_le16(chanspec);\n\tdiscover_state.dwell = cpu_to_le16(listen_ms);\n\tret = brcmf_fil_bsscfg_data_set(ifp, \"p2p_state\", &discover_state,\n\t\t\t\t\tsizeof(discover_state));\n\treturn ret;\n}\n\n \nstatic s32 brcmf_p2p_deinit_discovery(struct brcmf_p2p_info *p2p)\n{\n\tstruct brcmf_cfg80211_vif *vif;\n\n\tbrcmf_dbg(TRACE, \"enter\\n\");\n\n\t \n\tvif = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif;\n\t(void)brcmf_p2p_set_discover_state(vif->ifp, WL_P2P_DISC_ST_SCAN, 0, 0);\n\n\t \n\tvif = p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif;\n\t(void)brcmf_fil_iovar_int_set(vif->ifp, \"p2p_disc\", 0);\n\n\treturn 0;\n}\n\n \nstatic int brcmf_p2p_enable_discovery(struct brcmf_p2p_info *p2p)\n{\n\tstruct brcmf_pub *drvr = p2p->cfg->pub;\n\tstruct brcmf_cfg80211_vif *vif;\n\ts32 ret = 0;\n\n\tbrcmf_dbg(TRACE, \"enter\\n\");\n\tvif = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif;\n\tif (!vif) {\n\t\tbphy_err(drvr, \"P2P config device not available\\n\");\n\t\tret = -EPERM;\n\t\tgoto exit;\n\t}\n\n\tif (test_bit(BRCMF_P2P_STATUS_ENABLED, &p2p->status)) {\n\t\tbrcmf_dbg(INFO, \"P2P config device already configured\\n\");\n\t\tgoto exit;\n\t}\n\n\t \n\tvif = p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif;\n\tret = brcmf_fil_iovar_int_set(vif->ifp, \"p2p_disc\", 1);\n\tif (ret < 0) {\n\t\tbphy_err(drvr, \"set p2p_disc error\\n\");\n\t\tgoto exit;\n\t}\n\tvif = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif;\n\tret = brcmf_p2p_set_discover_state(vif->ifp, WL_P2P_DISC_ST_SCAN, 0, 0);\n\tif (ret < 0) {\n\t\tbphy_err(drvr, \"unable to set WL_P2P_DISC_ST_SCAN\\n\");\n\t\tgoto exit;\n\t}\n\n\t \n\tret = brcmf_fil_bsscfg_int_set(vif->ifp, \"wsec\", AES_ENABLED);\n\tif (ret < 0) {\n\t\tbphy_err(drvr, \"wsec error %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tset_bit(BRCMF_P2P_STATUS_ENABLED, &p2p->status);\nexit:\n\treturn ret;\n}\n\n \nstatic s32 brcmf_p2p_escan(struct brcmf_p2p_info *p2p, u32 num_chans,\n\t\t\t   u16 chanspecs[], s32 search_state,\n\t\t\t   enum p2p_bss_type bss_type)\n{\n\tstruct brcmf_pub *drvr = p2p->cfg->pub;\n\ts32 ret = 0;\n\ts32 memsize = offsetof(struct brcmf_p2p_scan_le,\n\t\t\t       eparams.params_le.channel_list);\n\ts32 nprobes;\n\ts32 active;\n\tu32 i;\n\tu8 *memblk;\n\tstruct brcmf_cfg80211_vif *vif;\n\tstruct brcmf_p2p_scan_le *p2p_params;\n\tstruct brcmf_scan_params_le *sparams;\n\n\tmemsize += num_chans * sizeof(__le16);\n\tmemblk = kzalloc(memsize, GFP_KERNEL);\n\tif (!memblk)\n\t\treturn -ENOMEM;\n\n\tvif = p2p->bss_idx[bss_type].vif;\n\tif (vif == NULL) {\n\t\tbphy_err(drvr, \"no vif for bss type %d\\n\", bss_type);\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\tp2p_params = (struct brcmf_p2p_scan_le *)memblk;\n\tsparams = &p2p_params->eparams.params_le;\n\n\tswitch (search_state) {\n\tcase WL_P2P_DISC_ST_SEARCH:\n\t\t \n\t\tbreak;\n\tcase WL_P2P_DISC_ST_SCAN:\n\t\t \n\t\tsparams->ssid_le.SSID_len =\n\t\t\t\tcpu_to_le32(BRCMF_P2P_WILDCARD_SSID_LEN);\n\t\tmemcpy(sparams->ssid_le.SSID, BRCMF_P2P_WILDCARD_SSID,\n\t\t       BRCMF_P2P_WILDCARD_SSID_LEN);\n\t\tbreak;\n\tdefault:\n\t\tbphy_err(drvr, \" invalid search state %d\\n\", search_state);\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tbrcmf_p2p_set_discover_state(vif->ifp, search_state, 0, 0);\n\n\t \n\tp2p_params->type = 'E';\n\n\t \n\tsparams->bss_type = DOT11_BSSTYPE_ANY;\n\tsparams->scan_type = BRCMF_SCANTYPE_ACTIVE;\n\n\teth_broadcast_addr(sparams->bssid);\n\tsparams->home_time = cpu_to_le32(P2PAPI_SCAN_HOME_TIME_MS);\n\n\t \n\tif (num_chans == SOCIAL_CHAN_CNT || num_chans == (SOCIAL_CHAN_CNT + 1))\n\t\tactive = P2PAPI_SCAN_SOCIAL_DWELL_TIME_MS;\n\telse if (num_chans == AF_PEER_SEARCH_CNT)\n\t\tactive = P2PAPI_SCAN_AF_SEARCH_DWELL_TIME_MS;\n\telse if (brcmf_get_vif_state_any(p2p->cfg, BRCMF_VIF_STATUS_CONNECTED))\n\t\tactive = -1;\n\telse\n\t\tactive = P2PAPI_SCAN_DWELL_TIME_MS;\n\n\t \n\tif (num_chans == 1) {\n\t\tactive = WL_SCAN_CONNECT_DWELL_TIME_MS;\n\t\t \n\t\tnprobes = active / WL_SCAN_JOIN_PROBE_INTERVAL_MS;\n\t} else {\n\t\tnprobes = active / P2PAPI_SCAN_NPROBS_TIME_MS;\n\t}\n\n\tif (nprobes <= 0)\n\t\tnprobes = 1;\n\n\tbrcmf_dbg(INFO, \"nprobes # %d, active_time %d\\n\", nprobes, active);\n\tsparams->active_time = cpu_to_le32(active);\n\tsparams->nprobes = cpu_to_le32(nprobes);\n\tsparams->passive_time = cpu_to_le32(-1);\n\tsparams->channel_num = cpu_to_le32(num_chans &\n\t\t\t\t\t   BRCMF_SCAN_PARAMS_COUNT_MASK);\n\tfor (i = 0; i < num_chans; i++)\n\t\tsparams->channel_list[i] = cpu_to_le16(chanspecs[i]);\n\n\t \n\tp2p_params->eparams.version = cpu_to_le32(BRCMF_ESCAN_REQ_VERSION);\n\tp2p_params->eparams.action =  cpu_to_le16(WL_ESCAN_ACTION_START);\n\tp2p_params->eparams.sync_id = cpu_to_le16(0x1234);\n\t \n\tret = brcmf_fil_bsscfg_data_set(vif->ifp, \"p2p_scan\", memblk, memsize);\n\tif (!ret)\n\t\tset_bit(BRCMF_SCAN_STATUS_BUSY, &p2p->cfg->scan_status);\nexit:\n\tkfree(memblk);\n\treturn ret;\n}\n\n \nstatic s32 brcmf_p2p_run_escan(struct brcmf_cfg80211_info *cfg,\n\t\t\t       struct brcmf_if *ifp,\n\t\t\t       struct cfg80211_scan_request *request)\n{\n\tstruct brcmf_p2p_info *p2p = &cfg->p2p;\n\tstruct brcmf_pub *drvr = cfg->pub;\n\ts32 err = 0;\n\ts32 search_state = WL_P2P_DISC_ST_SCAN;\n\tstruct brcmf_cfg80211_vif *vif;\n\tstruct net_device *dev = NULL;\n\tint i, num_nodfs = 0;\n\tu16 *chanspecs;\n\n\tbrcmf_dbg(TRACE, \"enter\\n\");\n\n\tif (!request) {\n\t\terr = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (request->n_channels) {\n\t\tchanspecs = kcalloc(request->n_channels, sizeof(*chanspecs),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (!chanspecs) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t\tvif = p2p->bss_idx[P2PAPI_BSSCFG_CONNECTION].vif;\n\t\tif (vif)\n\t\t\tdev = vif->wdev.netdev;\n\t\tif (request->n_channels == 3 &&\n\t\t    request->channels[0]->hw_value == SOCIAL_CHAN_1 &&\n\t\t    request->channels[1]->hw_value == SOCIAL_CHAN_2 &&\n\t\t    request->channels[2]->hw_value == SOCIAL_CHAN_3) {\n\t\t\t \n\t\t\tsearch_state = WL_P2P_DISC_ST_SEARCH;\n\t\t\tbrcmf_dbg(INFO, \"P2P SEARCH PHASE START\\n\");\n\t\t} else if (dev != NULL &&\n\t\t\t   vif->wdev.iftype == NL80211_IFTYPE_P2P_GO) {\n\t\t\t \n\t\t\tbrcmf_dbg(INFO, \"Already a GO. Do SEARCH Only\\n\");\n\t\t\tsearch_state = WL_P2P_DISC_ST_SEARCH;\n\t\t} else {\n\t\t\tbrcmf_dbg(INFO, \"P2P SCAN STATE START\\n\");\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < request->n_channels; i++) {\n\t\t\tstruct ieee80211_channel *chan = request->channels[i];\n\n\t\t\tif (chan->flags & (IEEE80211_CHAN_RADAR |\n\t\t\t\t\t   IEEE80211_CHAN_NO_IR))\n\t\t\t\tcontinue;\n\n\t\t\tchanspecs[i] = channel_to_chanspec(&p2p->cfg->d11inf,\n\t\t\t\t\t\t\t   chan);\n\t\t\tbrcmf_dbg(INFO, \"%d: chan=%d, channel spec=%x\\n\",\n\t\t\t\t  num_nodfs, chan->hw_value, chanspecs[i]);\n\t\t\tnum_nodfs++;\n\t\t}\n\t\terr = brcmf_p2p_escan(p2p, num_nodfs, chanspecs, search_state,\n\t\t\t\t      P2PAPI_BSSCFG_DEVICE);\n\t\tkfree(chanspecs);\n\t}\nexit:\n\tif (err)\n\t\tbphy_err(drvr, \"error (%d)\\n\", err);\n\treturn err;\n}\n\n\n \nstatic s32 brcmf_p2p_find_listen_channel(const u8 *ie, u32 ie_len)\n{\n\tu8 channel_ie[5];\n\ts32 listen_channel;\n\ts32 err;\n\n\terr = cfg80211_get_p2p_attr(ie, ie_len,\n\t\t\t\t    IEEE80211_P2P_ATTR_LISTEN_CHANNEL,\n\t\t\t\t    channel_ie, sizeof(channel_ie));\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\t \n\tlisten_channel = (s32)channel_ie[3 + 1];\n\n\tif (listen_channel == SOCIAL_CHAN_1 ||\n\t    listen_channel == SOCIAL_CHAN_2 ||\n\t    listen_channel == SOCIAL_CHAN_3) {\n\t\tbrcmf_dbg(INFO, \"Found my Listen Channel %d\\n\", listen_channel);\n\t\treturn listen_channel;\n\t}\n\n\treturn -EPERM;\n}\n\n\n \nint brcmf_p2p_scan_prep(struct wiphy *wiphy,\n\t\t\tstruct cfg80211_scan_request *request,\n\t\t\tstruct brcmf_cfg80211_vif *vif)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_p2p_info *p2p = &cfg->p2p;\n\tint err;\n\n\tif (brcmf_p2p_scan_is_p2p_request(request)) {\n\t\t \n\t\terr = brcmf_p2p_find_listen_channel(request->ie,\n\t\t\t\t\t\t    request->ie_len);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tp2p->afx_hdl.my_listen_chan = err;\n\n\t\tclear_bit(BRCMF_P2P_STATUS_GO_NEG_PHASE, &p2p->status);\n\t\tbrcmf_dbg(INFO, \"P2P: GO_NEG_PHASE status cleared\\n\");\n\n\t\terr = brcmf_p2p_enable_discovery(p2p);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tcfg->escan_info.run = brcmf_p2p_run_escan;\n\t}\n\treturn 0;\n}\n\n\n \nstatic s32\nbrcmf_p2p_discover_listen(struct brcmf_p2p_info *p2p, u16 channel, u32 duration)\n{\n\tstruct brcmf_pub *drvr = p2p->cfg->pub;\n\tstruct brcmf_cfg80211_vif *vif;\n\tstruct brcmu_chan ch;\n\ts32 err = 0;\n\n\tvif = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif;\n\tif (!vif) {\n\t\tbphy_err(drvr, \"Discovery is not set, so we have nothing to do\\n\");\n\t\terr = -EPERM;\n\t\tgoto exit;\n\t}\n\n\tif (test_bit(BRCMF_P2P_STATUS_DISCOVER_LISTEN, &p2p->status)) {\n\t\tbphy_err(drvr, \"Previous LISTEN is not completed yet\\n\");\n\t\t \n\t\tgoto exit;\n\t}\n\n\tch.chnum = channel;\n\tch.bw = BRCMU_CHAN_BW_20;\n\tp2p->cfg->d11inf.encchspec(&ch);\n\terr = brcmf_p2p_set_discover_state(vif->ifp, WL_P2P_DISC_ST_LISTEN,\n\t\t\t\t\t   ch.chspec, (u16)duration);\n\tif (!err) {\n\t\tset_bit(BRCMF_P2P_STATUS_DISCOVER_LISTEN, &p2p->status);\n\t\tp2p->remain_on_channel_cookie++;\n\t}\nexit:\n\treturn err;\n}\n\n\n \nint brcmf_p2p_remain_on_channel(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t\tstruct ieee80211_channel *channel,\n\t\t\t\tunsigned int duration, u64 *cookie)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_p2p_info *p2p = &cfg->p2p;\n\ts32 err;\n\tu16 channel_nr;\n\n\tchannel_nr = ieee80211_frequency_to_channel(channel->center_freq);\n\tbrcmf_dbg(TRACE, \"Enter, channel: %d, duration ms (%d)\\n\", channel_nr,\n\t\t  duration);\n\n\terr = brcmf_p2p_enable_discovery(p2p);\n\tif (err)\n\t\tgoto exit;\n\terr = brcmf_p2p_discover_listen(p2p, channel_nr, duration);\n\tif (err)\n\t\tgoto exit;\n\n\tmemcpy(&p2p->remain_on_channel, channel, sizeof(*channel));\n\t*cookie = p2p->remain_on_channel_cookie;\n\tcfg80211_ready_on_channel(wdev, *cookie, channel, duration, GFP_KERNEL);\n\nexit:\n\treturn err;\n}\n\n\n \nint brcmf_p2p_notify_listen_complete(struct brcmf_if *ifp,\n\t\t\t\t     const struct brcmf_event_msg *e,\n\t\t\t\t     void *data)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\tstruct brcmf_p2p_info *p2p = &cfg->p2p;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (test_and_clear_bit(BRCMF_P2P_STATUS_DISCOVER_LISTEN,\n\t\t\t       &p2p->status)) {\n\t\tif (test_and_clear_bit(BRCMF_P2P_STATUS_WAITING_NEXT_AF_LISTEN,\n\t\t\t\t       &p2p->status)) {\n\t\t\tclear_bit(BRCMF_P2P_STATUS_WAITING_NEXT_ACT_FRAME,\n\t\t\t\t  &p2p->status);\n\t\t\tbrcmf_dbg(INFO, \"Listen DONE, wake up wait_next_af\\n\");\n\t\t\tcomplete(&p2p->wait_next_af);\n\t\t}\n\n\t\tcfg80211_remain_on_channel_expired(&ifp->vif->wdev,\n\t\t\t\t\t\t   p2p->remain_on_channel_cookie,\n\t\t\t\t\t\t   &p2p->remain_on_channel,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t}\n\treturn 0;\n}\n\n\n \nvoid brcmf_p2p_cancel_remain_on_channel(struct brcmf_if *ifp)\n{\n\tif (!ifp)\n\t\treturn;\n\tbrcmf_p2p_set_discover_state(ifp, WL_P2P_DISC_ST_SCAN, 0, 0);\n\tbrcmf_p2p_notify_listen_complete(ifp, NULL, NULL);\n}\n\n\n \nstatic s32 brcmf_p2p_act_frm_search(struct brcmf_p2p_info *p2p, u16 channel)\n{\n\tstruct brcmf_pub *drvr = p2p->cfg->pub;\n\ts32 err;\n\tu32 channel_cnt;\n\tu16 *default_chan_list;\n\tu32 i;\n\tstruct brcmu_chan ch;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tif (channel)\n\t\tchannel_cnt = AF_PEER_SEARCH_CNT;\n\telse\n\t\tchannel_cnt = SOCIAL_CHAN_CNT;\n\tdefault_chan_list = kcalloc(channel_cnt, sizeof(*default_chan_list),\n\t\t\t\t    GFP_KERNEL);\n\tif (default_chan_list == NULL) {\n\t\tbphy_err(drvr, \"channel list allocation failed\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\tch.bw = BRCMU_CHAN_BW_20;\n\tif (channel) {\n\t\tch.chnum = channel;\n\t\tp2p->cfg->d11inf.encchspec(&ch);\n\t\t \n\t\tfor (i = 0; i < channel_cnt; i++)\n\t\t\tdefault_chan_list[i] = ch.chspec;\n\t} else {\n\t\tch.chnum = SOCIAL_CHAN_1;\n\t\tp2p->cfg->d11inf.encchspec(&ch);\n\t\tdefault_chan_list[0] = ch.chspec;\n\t\tch.chnum = SOCIAL_CHAN_2;\n\t\tp2p->cfg->d11inf.encchspec(&ch);\n\t\tdefault_chan_list[1] = ch.chspec;\n\t\tch.chnum = SOCIAL_CHAN_3;\n\t\tp2p->cfg->d11inf.encchspec(&ch);\n\t\tdefault_chan_list[2] = ch.chspec;\n\t}\n\terr = brcmf_p2p_escan(p2p, channel_cnt, default_chan_list,\n\t\t\t      WL_P2P_DISC_ST_SEARCH, P2PAPI_BSSCFG_DEVICE);\n\tkfree(default_chan_list);\nexit:\n\treturn err;\n}\n\n\n \nstatic void brcmf_p2p_afx_handler(struct work_struct *work)\n{\n\tstruct afx_hdl *afx_hdl = container_of(work, struct afx_hdl, afx_work);\n\tstruct brcmf_p2p_info *p2p = container_of(afx_hdl,\n\t\t\t\t\t\t  struct brcmf_p2p_info,\n\t\t\t\t\t\t  afx_hdl);\n\tstruct brcmf_pub *drvr = p2p->cfg->pub;\n\ts32 err;\n\n\tif (!afx_hdl->is_active)\n\t\treturn;\n\n\tif (afx_hdl->is_listen && afx_hdl->my_listen_chan)\n\t\t \n\t\terr = brcmf_p2p_discover_listen(p2p, afx_hdl->my_listen_chan,\n\t\t\t\t\t\t100 * get_random_u32_inclusive(1, 3));\n\telse\n\t\terr = brcmf_p2p_act_frm_search(p2p, afx_hdl->peer_listen_chan);\n\n\tif (err) {\n\t\tbphy_err(drvr, \"ERROR occurred! value is (%d)\\n\", err);\n\t\tif (test_bit(BRCMF_P2P_STATUS_FINDING_COMMON_CHANNEL,\n\t\t\t     &p2p->status))\n\t\t\tcomplete(&afx_hdl->act_frm_scan);\n\t}\n}\n\n\n \nstatic s32 brcmf_p2p_af_searching_channel(struct brcmf_p2p_info *p2p)\n{\n\tstruct afx_hdl *afx_hdl = &p2p->afx_hdl;\n\tstruct brcmf_cfg80211_vif *pri_vif;\n\ts32 retry;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tpri_vif = p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif;\n\n\treinit_completion(&afx_hdl->act_frm_scan);\n\tset_bit(BRCMF_P2P_STATUS_FINDING_COMMON_CHANNEL, &p2p->status);\n\tafx_hdl->is_active = true;\n\tafx_hdl->peer_chan = P2P_INVALID_CHANNEL;\n\n\t \n\tretry = 0;\n\twhile ((retry < P2P_CHANNEL_SYNC_RETRY) &&\n\t       (afx_hdl->peer_chan == P2P_INVALID_CHANNEL)) {\n\t\tafx_hdl->is_listen = false;\n\t\tbrcmf_dbg(TRACE, \"Scheduling action frame for sending.. (%d)\\n\",\n\t\t\t  retry);\n\t\t \n\t\tschedule_work(&afx_hdl->afx_work);\n\t\twait_for_completion_timeout(&afx_hdl->act_frm_scan,\n\t\t\t\t\t    P2P_AF_FRM_SCAN_MAX_WAIT);\n\t\tif ((afx_hdl->peer_chan != P2P_INVALID_CHANNEL) ||\n\t\t    (!test_bit(BRCMF_P2P_STATUS_FINDING_COMMON_CHANNEL,\n\t\t\t       &p2p->status)))\n\t\t\tbreak;\n\n\t\tif (afx_hdl->my_listen_chan) {\n\t\t\tbrcmf_dbg(TRACE, \"Scheduling listen peer, channel=%d\\n\",\n\t\t\t\t  afx_hdl->my_listen_chan);\n\t\t\t \n\t\t\tafx_hdl->is_listen = true;\n\t\t\tschedule_work(&afx_hdl->afx_work);\n\t\t\twait_for_completion_timeout(&afx_hdl->act_frm_scan,\n\t\t\t\t\t\t    P2P_AF_FRM_SCAN_MAX_WAIT);\n\t\t}\n\t\tif ((afx_hdl->peer_chan != P2P_INVALID_CHANNEL) ||\n\t\t    (!test_bit(BRCMF_P2P_STATUS_FINDING_COMMON_CHANNEL,\n\t\t\t       &p2p->status)))\n\t\t\tbreak;\n\t\tretry++;\n\n\t\t \n\t\tif (test_bit(BRCMF_VIF_STATUS_CONNECTED, &pri_vif->sme_state) ||\n\t\t    test_bit(BRCMF_VIF_STATUS_CONNECTING, &pri_vif->sme_state))\n\t\t\tmsleep(P2P_DEFAULT_SLEEP_TIME_VSDB);\n\t}\n\n\tbrcmf_dbg(TRACE, \"Completed search/listen peer_chan=%d\\n\",\n\t\t  afx_hdl->peer_chan);\n\tafx_hdl->is_active = false;\n\n\tclear_bit(BRCMF_P2P_STATUS_FINDING_COMMON_CHANNEL, &p2p->status);\n\n\treturn afx_hdl->peer_chan;\n}\n\n\n \nbool brcmf_p2p_scan_finding_common_channel(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t\t   struct brcmf_bss_info_le *bi)\n\n{\n\tstruct brcmf_p2p_info *p2p = &cfg->p2p;\n\tstruct afx_hdl *afx_hdl = &p2p->afx_hdl;\n\tstruct brcmu_chan ch;\n\tu8 *ie;\n\ts32 err;\n\tu8 p2p_dev_addr[ETH_ALEN];\n\n\tif (!test_bit(BRCMF_P2P_STATUS_FINDING_COMMON_CHANNEL, &p2p->status))\n\t\treturn false;\n\n\tif (bi == NULL) {\n\t\tbrcmf_dbg(TRACE, \"ACTION FRAME SCAN Done\\n\");\n\t\tif (afx_hdl->peer_chan == P2P_INVALID_CHANNEL)\n\t\t\tcomplete(&afx_hdl->act_frm_scan);\n\t\treturn true;\n\t}\n\n\tie = ((u8 *)bi) + le16_to_cpu(bi->ie_offset);\n\tmemset(p2p_dev_addr, 0, sizeof(p2p_dev_addr));\n\terr = cfg80211_get_p2p_attr(ie, le32_to_cpu(bi->ie_length),\n\t\t\t\t    IEEE80211_P2P_ATTR_DEVICE_INFO,\n\t\t\t\t    p2p_dev_addr, sizeof(p2p_dev_addr));\n\tif (err < 0)\n\t\terr = cfg80211_get_p2p_attr(ie, le32_to_cpu(bi->ie_length),\n\t\t\t\t\t    IEEE80211_P2P_ATTR_DEVICE_ID,\n\t\t\t\t\t    p2p_dev_addr, sizeof(p2p_dev_addr));\n\tif ((err >= 0) &&\n\t    (ether_addr_equal(p2p_dev_addr, afx_hdl->tx_dst_addr))) {\n\t\tif (!bi->ctl_ch) {\n\t\t\tch.chspec = le16_to_cpu(bi->chanspec);\n\t\t\tcfg->d11inf.decchspec(&ch);\n\t\t\tbi->ctl_ch = ch.control_ch_num;\n\t\t}\n\t\tafx_hdl->peer_chan = bi->ctl_ch;\n\t\tbrcmf_dbg(TRACE, \"ACTION FRAME SCAN : Peer %pM found, channel : %d\\n\",\n\t\t\t  afx_hdl->tx_dst_addr, afx_hdl->peer_chan);\n\t\tcomplete(&afx_hdl->act_frm_scan);\n\t}\n\treturn true;\n}\n\n \nstatic s32 brcmf_p2p_abort_action_frame(struct brcmf_cfg80211_info *cfg)\n{\n\tstruct brcmf_p2p_info *p2p = &cfg->p2p;\n\tstruct brcmf_cfg80211_vif *vif;\n\ts32 err;\n\ts32 int_val = 1;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tvif = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif;\n\terr = brcmf_fil_bsscfg_data_set(vif->ifp, \"actframe_abort\", &int_val,\n\t\t\t\t\tsizeof(s32));\n\tif (err)\n\t\tbrcmf_err(\" aborting action frame has failed (%d)\\n\", err);\n\n\treturn err;\n}\n\n \nstatic void\nbrcmf_p2p_stop_wait_next_action_frame(struct brcmf_cfg80211_info *cfg)\n{\n\tstruct brcmf_p2p_info *p2p = &cfg->p2p;\n\tstruct brcmf_if *ifp = p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif->ifp;\n\ts32 err;\n\n\tif (test_bit(BRCMF_P2P_STATUS_SENDING_ACT_FRAME, &p2p->status) &&\n\t    (test_bit(BRCMF_P2P_STATUS_ACTION_TX_COMPLETED, &p2p->status) ||\n\t     test_bit(BRCMF_P2P_STATUS_ACTION_TX_NOACK, &p2p->status))) {\n\t\tbrcmf_dbg(TRACE, \"*** Wake UP ** abort actframe iovar\\n\");\n\t\t \n\t\tif (p2p->af_sent_channel) {\n\t\t\t \n\t\t\terr = brcmf_p2p_abort_action_frame(cfg);\n\t\t\tif (err)\n\t\t\t\tbrcmf_notify_escan_complete(cfg, ifp, true,\n\t\t\t\t\t\t\t    true);\n\t\t}\n\t} else if (test_bit(BRCMF_P2P_STATUS_WAITING_NEXT_AF_LISTEN,\n\t\t\t    &p2p->status)) {\n\t\tbrcmf_dbg(TRACE, \"*** Wake UP ** abort listen for next af frame\\n\");\n\t\t \n\t\tbrcmf_notify_escan_complete(cfg, ifp, true, true);\n\t}\n}\n\n\n \nstatic bool\nbrcmf_p2p_gon_req_collision(struct brcmf_p2p_info *p2p, u8 *mac)\n{\n\tstruct brcmf_cfg80211_info *cfg = p2p->cfg;\n\tstruct brcmf_if *ifp;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tif (!test_bit(BRCMF_P2P_STATUS_WAITING_NEXT_ACT_FRAME, &p2p->status) ||\n\t    !p2p->gon_req_action)\n\t\treturn false;\n\n\tbrcmf_dbg(TRACE, \"GO Negotiation Request COLLISION !!!\\n\");\n\t \n\tifp = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif->ifp;\n\tif (memcmp(mac, ifp->mac_addr, ETH_ALEN) < 0) {\n\t\tbrcmf_dbg(INFO, \"Block transmit gon req !!!\\n\");\n\t\tp2p->block_gon_req_tx = true;\n\t\t \n\t\tif (test_and_clear_bit(BRCMF_P2P_STATUS_FINDING_COMMON_CHANNEL,\n\t\t\t\t       &p2p->status))\n\t\t\tcomplete(&p2p->afx_hdl.act_frm_scan);\n\t\tif (test_and_clear_bit(BRCMF_P2P_STATUS_WAITING_NEXT_ACT_FRAME,\n\t\t\t\t       &p2p->status))\n\t\t\tbrcmf_p2p_stop_wait_next_action_frame(cfg);\n\t\treturn false;\n\t}\n\n\t \n\tbrcmf_dbg(INFO, \"Drop received gon req !!!\\n\");\n\n\treturn true;\n}\n\n\n \nint brcmf_p2p_notify_action_frame_rx(struct brcmf_if *ifp,\n\t\t\t\t     const struct brcmf_event_msg *e,\n\t\t\t\t     void *data)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_cfg80211_info *cfg = drvr->config;\n\tstruct brcmf_p2p_info *p2p = &cfg->p2p;\n\tstruct afx_hdl *afx_hdl = &p2p->afx_hdl;\n\tstruct wireless_dev *wdev;\n\tu32 mgmt_frame_len = e->datalen - sizeof(struct brcmf_rx_mgmt_data);\n\tstruct brcmf_rx_mgmt_data *rxframe = (struct brcmf_rx_mgmt_data *)data;\n\tu8 *frame = (u8 *)(rxframe + 1);\n\tstruct brcmf_p2p_pub_act_frame *act_frm;\n\tstruct brcmf_p2psd_gas_pub_act_frame *sd_act_frm;\n\tstruct brcmu_chan ch;\n\tstruct ieee80211_mgmt *mgmt_frame;\n\ts32 freq;\n\tu16 mgmt_type;\n\tu8 action;\n\n\tif (e->datalen < sizeof(*rxframe)) {\n\t\tbrcmf_dbg(SCAN, \"Event data to small. Ignore\\n\");\n\t\treturn 0;\n\t}\n\n\tch.chspec = be16_to_cpu(rxframe->chanspec);\n\tcfg->d11inf.decchspec(&ch);\n\t \n\tbrcmf_dbg(INFO, \"ifp->vif->mgmt_rx_reg %04x\\n\", ifp->vif->mgmt_rx_reg);\n\tmgmt_type = (IEEE80211_STYPE_ACTION & IEEE80211_FCTL_STYPE) >> 4;\n\tif ((ifp->vif->mgmt_rx_reg & BIT(mgmt_type)) == 0)\n\t\treturn 0;\n\n\tbrcmf_p2p_print_actframe(false, frame, mgmt_frame_len);\n\n\taction = P2P_PAF_SUBTYPE_INVALID;\n\tif (brcmf_p2p_is_pub_action(frame, mgmt_frame_len)) {\n\t\tact_frm = (struct brcmf_p2p_pub_act_frame *)frame;\n\t\taction = act_frm->subtype;\n\t\tif ((action == P2P_PAF_GON_REQ) &&\n\t\t    (brcmf_p2p_gon_req_collision(p2p, (u8 *)e->addr))) {\n\t\t\tif (test_bit(BRCMF_P2P_STATUS_FINDING_COMMON_CHANNEL,\n\t\t\t\t     &p2p->status) &&\n\t\t\t    (ether_addr_equal(afx_hdl->tx_dst_addr, e->addr))) {\n\t\t\t\tafx_hdl->peer_chan = ch.control_ch_num;\n\t\t\t\tbrcmf_dbg(INFO, \"GON request: Peer found, channel=%d\\n\",\n\t\t\t\t\t  afx_hdl->peer_chan);\n\t\t\t\tcomplete(&afx_hdl->act_frm_scan);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tif ((action == P2P_PAF_GON_CONF) ||\n\t\t    (action == P2P_PAF_PROVDIS_RSP))\n\t\t\tbrcmf_set_mpc(ifp, 1);\n\t\tif (action == P2P_PAF_GON_CONF) {\n\t\t\tbrcmf_dbg(TRACE, \"P2P: GO_NEG_PHASE status cleared\\n\");\n\t\t\tclear_bit(BRCMF_P2P_STATUS_GO_NEG_PHASE, &p2p->status);\n\t\t}\n\t} else if (brcmf_p2p_is_gas_action(frame, mgmt_frame_len)) {\n\t\tsd_act_frm = (struct brcmf_p2psd_gas_pub_act_frame *)frame;\n\t\taction = sd_act_frm->action;\n\t}\n\n\tif (test_bit(BRCMF_P2P_STATUS_WAITING_NEXT_ACT_FRAME, &p2p->status) &&\n\t    (p2p->next_af_subtype == action)) {\n\t\tbrcmf_dbg(TRACE, \"We got a right next frame! (%d)\\n\", action);\n\t\tclear_bit(BRCMF_P2P_STATUS_WAITING_NEXT_ACT_FRAME,\n\t\t\t  &p2p->status);\n\t\t \n\t\tbrcmf_p2p_stop_wait_next_action_frame(cfg);\n\t}\n\n\tmgmt_frame = kzalloc(offsetof(struct ieee80211_mgmt, u) +\n\t\t\t     mgmt_frame_len, GFP_KERNEL);\n\tif (!mgmt_frame) {\n\t\tbphy_err(drvr, \"No memory available for action frame\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmemcpy(mgmt_frame->da, ifp->mac_addr, ETH_ALEN);\n\tbrcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BSSID, mgmt_frame->bssid,\n\t\t\t       ETH_ALEN);\n\tmemcpy(mgmt_frame->sa, e->addr, ETH_ALEN);\n\tmgmt_frame->frame_control = cpu_to_le16(IEEE80211_STYPE_ACTION);\n\tmemcpy(mgmt_frame->u.body, frame, mgmt_frame_len);\n\tmgmt_frame_len += offsetof(struct ieee80211_mgmt, u.body);\n\n\tfreq = ieee80211_channel_to_frequency(ch.control_ch_num,\n\t\t\t\t\t      ch.band == BRCMU_CHAN_BAND_2G ?\n\t\t\t\t\t      NL80211_BAND_2GHZ :\n\t\t\t\t\t      NL80211_BAND_5GHZ);\n\n\twdev = &ifp->vif->wdev;\n\tcfg80211_rx_mgmt(wdev, freq, 0, (u8 *)mgmt_frame, mgmt_frame_len, 0);\n\n\tkfree(mgmt_frame);\n\treturn 0;\n}\n\n\n \nint brcmf_p2p_notify_action_tx_complete(struct brcmf_if *ifp,\n\t\t\t\t\tconst struct brcmf_event_msg *e,\n\t\t\t\t\tvoid *data)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\tstruct brcmf_p2p_info *p2p = &cfg->p2p;\n\n\tbrcmf_dbg(INFO, \"Enter: event %s, status=%d\\n\",\n\t\t  e->event_code == BRCMF_E_ACTION_FRAME_OFF_CHAN_COMPLETE ?\n\t\t  \"ACTION_FRAME_OFF_CHAN_COMPLETE\" : \"ACTION_FRAME_COMPLETE\",\n\t\t  e->status);\n\n\tif (!test_bit(BRCMF_P2P_STATUS_SENDING_ACT_FRAME, &p2p->status))\n\t\treturn 0;\n\n\tif (e->event_code == BRCMF_E_ACTION_FRAME_COMPLETE) {\n\t\tif (e->status == BRCMF_E_STATUS_SUCCESS) {\n\t\t\tset_bit(BRCMF_P2P_STATUS_ACTION_TX_COMPLETED,\n\t\t\t\t&p2p->status);\n\t\t\tif (!p2p->wait_for_offchan_complete)\n\t\t\t\tcomplete(&p2p->send_af_done);\n\t\t} else {\n\t\t\tset_bit(BRCMF_P2P_STATUS_ACTION_TX_NOACK, &p2p->status);\n\t\t\t \n\t\t\tbrcmf_p2p_stop_wait_next_action_frame(cfg);\n\t\t}\n\n\t} else {\n\t\tcomplete(&p2p->send_af_done);\n\t}\n\treturn 0;\n}\n\n\n \nstatic s32 brcmf_p2p_tx_action_frame(struct brcmf_p2p_info *p2p,\n\t\t\t\t     struct brcmf_fil_af_params_le *af_params)\n{\n\tstruct brcmf_pub *drvr = p2p->cfg->pub;\n\tstruct brcmf_cfg80211_vif *vif;\n\tstruct brcmf_p2p_action_frame *p2p_af;\n\ts32 err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\treinit_completion(&p2p->send_af_done);\n\tclear_bit(BRCMF_P2P_STATUS_ACTION_TX_COMPLETED, &p2p->status);\n\tclear_bit(BRCMF_P2P_STATUS_ACTION_TX_NOACK, &p2p->status);\n\n\t \n\tp2p_af = (struct brcmf_p2p_action_frame *)af_params->action_frame.data;\n\tif (p2p_af->subtype == P2P_AF_PRESENCE_RSP)\n\t\tvif = p2p->bss_idx[P2PAPI_BSSCFG_CONNECTION].vif;\n\telse\n\t\tvif = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif;\n\n\terr = brcmf_fil_bsscfg_data_set(vif->ifp, \"actframe\", af_params,\n\t\t\t\t\tsizeof(*af_params));\n\tif (err) {\n\t\tbphy_err(drvr, \" sending action frame has failed\\n\");\n\t\tgoto exit;\n\t}\n\n\tp2p->af_sent_channel = le32_to_cpu(af_params->channel);\n\tp2p->af_tx_sent_jiffies = jiffies;\n\n\tif (test_bit(BRCMF_P2P_STATUS_DISCOVER_LISTEN, &p2p->status) &&\n\t    p2p->af_sent_channel ==\n\t    ieee80211_frequency_to_channel(p2p->remain_on_channel.center_freq))\n\t\tp2p->wait_for_offchan_complete = false;\n\telse\n\t\tp2p->wait_for_offchan_complete = true;\n\n\tbrcmf_dbg(TRACE, \"Waiting for %s tx completion event\\n\",\n\t\t  (p2p->wait_for_offchan_complete) ?\n\t\t   \"off-channel\" : \"on-channel\");\n\n\twait_for_completion_timeout(&p2p->send_af_done, P2P_AF_MAX_WAIT_TIME);\n\n\tif (test_bit(BRCMF_P2P_STATUS_ACTION_TX_COMPLETED, &p2p->status)) {\n\t\tbrcmf_dbg(TRACE, \"TX action frame operation is success\\n\");\n\t} else {\n\t\terr = -EIO;\n\t\tbrcmf_dbg(TRACE, \"TX action frame operation has failed\\n\");\n\t}\n\t \n\tclear_bit(BRCMF_P2P_STATUS_ACTION_TX_COMPLETED, &p2p->status);\n\tclear_bit(BRCMF_P2P_STATUS_ACTION_TX_NOACK, &p2p->status);\n\nexit:\n\treturn err;\n}\n\n\n \nstatic s32 brcmf_p2p_pub_af_tx(struct brcmf_cfg80211_info *cfg,\n\t\t\t       struct brcmf_fil_af_params_le *af_params,\n\t\t\t       struct brcmf_config_af_params *config_af_params)\n{\n\tstruct brcmf_p2p_info *p2p = &cfg->p2p;\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_fil_action_frame_le *action_frame;\n\tstruct brcmf_p2p_pub_act_frame *act_frm;\n\ts32 err = 0;\n\tu16 ie_len;\n\n\taction_frame = &af_params->action_frame;\n\tact_frm = (struct brcmf_p2p_pub_act_frame *)(action_frame->data);\n\n\tconfig_af_params->extra_listen = true;\n\n\tswitch (act_frm->subtype) {\n\tcase P2P_PAF_GON_REQ:\n\t\tbrcmf_dbg(TRACE, \"P2P: GO_NEG_PHASE status set\\n\");\n\t\tset_bit(BRCMF_P2P_STATUS_GO_NEG_PHASE, &p2p->status);\n\t\tconfig_af_params->mpc_onoff = 0;\n\t\tconfig_af_params->search_channel = true;\n\t\tp2p->next_af_subtype = act_frm->subtype + 1;\n\t\tp2p->gon_req_action = true;\n\t\t \n\t\taf_params->dwell_time = cpu_to_le32(P2P_AF_MED_DWELL_TIME);\n\t\tbreak;\n\tcase P2P_PAF_GON_RSP:\n\t\tp2p->next_af_subtype = act_frm->subtype + 1;\n\t\t \n\t\taf_params->dwell_time = cpu_to_le32(P2P_AF_MED_DWELL_TIME);\n\t\tbreak;\n\tcase P2P_PAF_GON_CONF:\n\t\t \n\t\tbrcmf_dbg(TRACE, \"P2P: GO_NEG_PHASE status cleared\\n\");\n\t\tclear_bit(BRCMF_P2P_STATUS_GO_NEG_PHASE, &p2p->status);\n\t\t \n\t\tconfig_af_params->mpc_onoff = 1;\n\t\t \n\t\taf_params->dwell_time = cpu_to_le32(P2P_AF_MIN_DWELL_TIME);\n\t\tconfig_af_params->extra_listen = false;\n\t\tbreak;\n\tcase P2P_PAF_INVITE_REQ:\n\t\tconfig_af_params->search_channel = true;\n\t\tp2p->next_af_subtype = act_frm->subtype + 1;\n\t\t \n\t\taf_params->dwell_time = cpu_to_le32(P2P_AF_MED_DWELL_TIME);\n\t\tbreak;\n\tcase P2P_PAF_INVITE_RSP:\n\t\t \n\t\taf_params->dwell_time = cpu_to_le32(P2P_AF_MIN_DWELL_TIME);\n\t\tconfig_af_params->extra_listen = false;\n\t\tbreak;\n\tcase P2P_PAF_DEVDIS_REQ:\n\t\tconfig_af_params->search_channel = true;\n\t\tp2p->next_af_subtype = act_frm->subtype + 1;\n\t\t \n\t\taf_params->dwell_time = cpu_to_le32(P2P_AF_LONG_DWELL_TIME);\n\t\tbreak;\n\tcase P2P_PAF_DEVDIS_RSP:\n\t\t \n\t\taf_params->dwell_time = cpu_to_le32(P2P_AF_MIN_DWELL_TIME);\n\t\tconfig_af_params->extra_listen = false;\n\t\tbreak;\n\tcase P2P_PAF_PROVDIS_REQ:\n\t\tie_len = le16_to_cpu(action_frame->len) -\n\t\t\t offsetof(struct brcmf_p2p_pub_act_frame, elts);\n\t\tif (cfg80211_get_p2p_attr(&act_frm->elts[0], ie_len,\n\t\t\t\t\t  IEEE80211_P2P_ATTR_GROUP_ID,\n\t\t\t\t\t  NULL, 0) < 0)\n\t\t\tconfig_af_params->search_channel = true;\n\t\tconfig_af_params->mpc_onoff = 0;\n\t\tp2p->next_af_subtype = act_frm->subtype + 1;\n\t\t \n\t\taf_params->dwell_time = cpu_to_le32(P2P_AF_MED_DWELL_TIME);\n\t\tbreak;\n\tcase P2P_PAF_PROVDIS_RSP:\n\t\t \n\t\tp2p->next_af_subtype = P2P_PAF_GON_REQ;\n\t\t \n\t\taf_params->dwell_time = cpu_to_le32(P2P_AF_MED_DWELL_TIME);\n\t\tconfig_af_params->extra_listen = false;\n\t\tbreak;\n\tdefault:\n\t\tbphy_err(drvr, \"Unknown p2p pub act frame subtype: %d\\n\",\n\t\t\t act_frm->subtype);\n\t\terr = -EINVAL;\n\t}\n\treturn err;\n}\n\nstatic bool brcmf_p2p_check_dwell_overflow(u32 requested_dwell,\n\t\t\t\t\t   unsigned long dwell_jiffies)\n{\n\tif ((requested_dwell & CUSTOM_RETRY_MASK) &&\n\t    (jiffies_to_msecs(jiffies - dwell_jiffies) >\n\t    (requested_dwell & ~CUSTOM_RETRY_MASK))) {\n\t\tbrcmf_err(\"Action frame TX retry time over dwell time!\\n\");\n\t\treturn true;\n\t}\n\treturn false;\n}\n \nbool brcmf_p2p_send_action_frame(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t struct net_device *ndev,\n\t\t\t\t struct brcmf_fil_af_params_le *af_params)\n{\n\tstruct brcmf_p2p_info *p2p = &cfg->p2p;\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_fil_action_frame_le *action_frame;\n\tstruct brcmf_config_af_params config_af_params;\n\tstruct afx_hdl *afx_hdl = &p2p->afx_hdl;\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tu16 action_frame_len;\n\tbool ack = false;\n\tu8 category;\n\tu8 action;\n\ts32 tx_retry;\n\ts32 extra_listen_time;\n\tuint delta_ms;\n\tunsigned long dwell_jiffies = 0;\n\tbool dwell_overflow = false;\n\n\tu32 requested_dwell = le32_to_cpu(af_params->dwell_time);\n\taction_frame = &af_params->action_frame;\n\taction_frame_len = le16_to_cpu(action_frame->len);\n\n\tbrcmf_p2p_print_actframe(true, action_frame->data, action_frame_len);\n\n\t \n\t \n\t \n\taf_params->dwell_time = cpu_to_le32(P2P_AF_DWELL_TIME);\n\n\tcategory = action_frame->data[DOT11_ACTION_CAT_OFF];\n\taction = action_frame->data[DOT11_ACTION_ACT_OFF];\n\n\t \n\tp2p->next_af_subtype = P2P_PAF_SUBTYPE_INVALID;\n\tp2p->gon_req_action = false;\n\n\t \n\tconfig_af_params.mpc_onoff = -1;\n\tconfig_af_params.search_channel = false;\n\tconfig_af_params.extra_listen = false;\n\n\tif (brcmf_p2p_is_pub_action(action_frame->data, action_frame_len)) {\n\t\t \n\t\tif (brcmf_p2p_pub_af_tx(cfg, af_params, &config_af_params)) {\n\t\t\t \n\t\t\t \n\t\t\tbphy_err(drvr, \"P2P Public action frame, unknown subtype.\\n\");\n\t\t}\n\t} else if (brcmf_p2p_is_gas_action(action_frame->data,\n\t\t\t\t\t   action_frame_len)) {\n\t\t \n\t\tif (action == P2PSD_ACTION_ID_GAS_IREQ ||\n\t\t    action == P2PSD_ACTION_ID_GAS_CREQ) {\n\t\t\t \n\t\t\tconfig_af_params.search_channel = true;\n\n\t\t\t \n\t\t\t \n\t\t\tp2p->next_af_subtype = action + 1;\n\n\t\t\taf_params->dwell_time =\n\t\t\t\tcpu_to_le32(P2P_AF_MED_DWELL_TIME);\n\t\t} else if (action == P2PSD_ACTION_ID_GAS_IRESP ||\n\t\t\t   action == P2PSD_ACTION_ID_GAS_CRESP) {\n\t\t\t \n\t\t\taf_params->dwell_time =\n\t\t\t\tcpu_to_le32(P2P_AF_MIN_DWELL_TIME);\n\t\t} else {\n\t\t\tbphy_err(drvr, \"Unknown action type: %d\\n\", action);\n\t\t\tgoto exit;\n\t\t}\n\t} else if (brcmf_p2p_is_p2p_action(action_frame->data,\n\t\t\t\t\t   action_frame_len)) {\n\t\t \n\t\t \n\t} else {\n\t\tbphy_err(drvr, \"Unknown Frame: category 0x%x, action 0x%x\\n\",\n\t\t\t category, action);\n\t\treturn false;\n\t}\n\n\t \n\tif (test_bit(BRCMF_VIF_STATUS_CONNECTING,\n\t\t     &p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif->sme_state))\n\t\tmsleep(50);\n\n\t \n\tif (test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status))\n\t\tbrcmf_abort_scanning(cfg);\n\n\tmemcpy(afx_hdl->tx_dst_addr, action_frame->da, ETH_ALEN);\n\n\t \n\tif (config_af_params.mpc_onoff == 0)\n\t\tbrcmf_set_mpc(ifp, 0);\n\n\t \n\tif (p2p->next_af_subtype != P2P_PAF_SUBTYPE_INVALID) {\n\t\t \n\t\tset_bit(BRCMF_P2P_STATUS_WAITING_NEXT_ACT_FRAME, &p2p->status);\n\t}\n\n\tp2p->af_sent_channel = 0;\n\tset_bit(BRCMF_P2P_STATUS_SENDING_ACT_FRAME, &p2p->status);\n\t \n\tif (config_af_params.search_channel &&\n\t    IS_P2P_SOCIAL_CHANNEL(le32_to_cpu(af_params->channel)) &&\n\t    p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif->saved_ie.probe_req_ie_len) {\n\t\tafx_hdl = &p2p->afx_hdl;\n\t\tafx_hdl->peer_listen_chan = le32_to_cpu(af_params->channel);\n\n\t\tif (brcmf_p2p_af_searching_channel(p2p) ==\n\t\t\t\t\t\t\tP2P_INVALID_CHANNEL) {\n\t\t\tbphy_err(drvr, \"Couldn't find peer's channel.\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\t \n\t\tbrcmf_notify_escan_complete(cfg, ifp, true, true);\n\n\t\t \n\t\taf_params->channel = cpu_to_le32(afx_hdl->peer_chan);\n\t}\n\tdwell_jiffies = jiffies;\n\tdwell_overflow = brcmf_p2p_check_dwell_overflow(requested_dwell,\n\t\t\t\t\t\t\tdwell_jiffies);\n\n\ttx_retry = 0;\n\twhile (!p2p->block_gon_req_tx &&\n\t       (!ack) && (tx_retry < P2P_AF_TX_MAX_RETRY) &&\n\t\t!dwell_overflow) {\n\t\tif (af_params->channel)\n\t\t\tmsleep(P2P_AF_RETRY_DELAY_TIME);\n\n\t\tack = !brcmf_p2p_tx_action_frame(p2p, af_params);\n\t\ttx_retry++;\n\t\tdwell_overflow = brcmf_p2p_check_dwell_overflow(requested_dwell,\n\t\t\t\t\t\t\t\tdwell_jiffies);\n\t}\n\tif (!ack) {\n\t\tbphy_err(drvr, \"Failed to send Action Frame(retry %d)\\n\",\n\t\t\t tx_retry);\n\t\tclear_bit(BRCMF_P2P_STATUS_GO_NEG_PHASE, &p2p->status);\n\t}\n\nexit:\n\tclear_bit(BRCMF_P2P_STATUS_SENDING_ACT_FRAME, &p2p->status);\n\n\t \n\tif (ack && config_af_params.extra_listen && !p2p->block_gon_req_tx &&\n\t    test_bit(BRCMF_P2P_STATUS_WAITING_NEXT_ACT_FRAME, &p2p->status) &&\n\t    p2p->af_sent_channel == afx_hdl->my_listen_chan) {\n\t\tdelta_ms = jiffies_to_msecs(jiffies - p2p->af_tx_sent_jiffies);\n\t\tif (le32_to_cpu(af_params->dwell_time) > delta_ms)\n\t\t\textra_listen_time = le32_to_cpu(af_params->dwell_time) -\n\t\t\t\t\t    delta_ms;\n\t\telse\n\t\t\textra_listen_time = 0;\n\t\tif (extra_listen_time > 50) {\n\t\t\tset_bit(BRCMF_P2P_STATUS_WAITING_NEXT_AF_LISTEN,\n\t\t\t\t&p2p->status);\n\t\t\tbrcmf_dbg(INFO, \"Wait more time! actual af time:%d, calculated extra listen:%d\\n\",\n\t\t\t\t  le32_to_cpu(af_params->dwell_time),\n\t\t\t\t  extra_listen_time);\n\t\t\textra_listen_time += 100;\n\t\t\tif (!brcmf_p2p_discover_listen(p2p,\n\t\t\t\t\t\t       p2p->af_sent_channel,\n\t\t\t\t\t\t       extra_listen_time)) {\n\t\t\t\tunsigned long duration;\n\n\t\t\t\textra_listen_time += 100;\n\t\t\t\tduration = msecs_to_jiffies(extra_listen_time);\n\t\t\t\twait_for_completion_timeout(&p2p->wait_next_af,\n\t\t\t\t\t\t\t    duration);\n\t\t\t}\n\t\t\tclear_bit(BRCMF_P2P_STATUS_WAITING_NEXT_AF_LISTEN,\n\t\t\t\t  &p2p->status);\n\t\t}\n\t}\n\n\tif (p2p->block_gon_req_tx) {\n\t\t \n\t\tp2p->block_gon_req_tx = false;\n\t\tack = true;\n\t}\n\n\tclear_bit(BRCMF_P2P_STATUS_WAITING_NEXT_ACT_FRAME, &p2p->status);\n\t \n\tif (config_af_params.mpc_onoff == 1)\n\t\tbrcmf_set_mpc(ifp, 1);\n\n\treturn ack;\n}\n\n \ns32 brcmf_p2p_notify_rx_mgmt_p2p_probereq(struct brcmf_if *ifp,\n\t\t\t\t\t  const struct brcmf_event_msg *e,\n\t\t\t\t\t  void *data)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\tstruct brcmf_p2p_info *p2p = &cfg->p2p;\n\tstruct afx_hdl *afx_hdl = &p2p->afx_hdl;\n\tstruct brcmf_cfg80211_vif *vif = ifp->vif;\n\tstruct brcmf_rx_mgmt_data *rxframe = (struct brcmf_rx_mgmt_data *)data;\n\tstruct brcmu_chan ch;\n\tu8 *mgmt_frame;\n\tu32 mgmt_frame_len;\n\ts32 freq;\n\tu16 mgmt_type;\n\n\tbrcmf_dbg(INFO, \"Enter: event %d reason %d\\n\", e->event_code,\n\t\t  e->reason);\n\n\tif (e->datalen < sizeof(*rxframe)) {\n\t\tbrcmf_dbg(SCAN, \"Event data to small. Ignore\\n\");\n\t\treturn 0;\n\t}\n\n\tch.chspec = be16_to_cpu(rxframe->chanspec);\n\tcfg->d11inf.decchspec(&ch);\n\n\tif (test_bit(BRCMF_P2P_STATUS_FINDING_COMMON_CHANNEL, &p2p->status) &&\n\t    (ether_addr_equal(afx_hdl->tx_dst_addr, e->addr))) {\n\t\tafx_hdl->peer_chan = ch.control_ch_num;\n\t\tbrcmf_dbg(INFO, \"PROBE REQUEST: Peer found, channel=%d\\n\",\n\t\t\t  afx_hdl->peer_chan);\n\t\tcomplete(&afx_hdl->act_frm_scan);\n\t}\n\n\t \n\t \n\tif (e->bsscfgidx == 0)\n\t\treturn 0;\n\n\t \n\tif (test_bit(BRCMF_P2P_STATUS_GO_NEG_PHASE, &p2p->status)) {\n\t\tbrcmf_dbg(INFO, \"Filtering P2P probe_req in GO-NEG phase\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tbrcmf_dbg(INFO, \"vif->mgmt_rx_reg %04x\\n\", vif->mgmt_rx_reg);\n\tmgmt_type = (IEEE80211_STYPE_PROBE_REQ & IEEE80211_FCTL_STYPE) >> 4;\n\tif ((vif->mgmt_rx_reg & BIT(mgmt_type)) == 0)\n\t\treturn 0;\n\n\tmgmt_frame = (u8 *)(rxframe + 1);\n\tmgmt_frame_len = e->datalen - sizeof(*rxframe);\n\tfreq = ieee80211_channel_to_frequency(ch.control_ch_num,\n\t\t\t\t\t      ch.band == BRCMU_CHAN_BAND_2G ?\n\t\t\t\t\t      NL80211_BAND_2GHZ :\n\t\t\t\t\t      NL80211_BAND_5GHZ);\n\n\tcfg80211_rx_mgmt(&vif->wdev, freq, 0, mgmt_frame, mgmt_frame_len, 0);\n\n\tbrcmf_dbg(INFO, \"mgmt_frame_len (%d) , e->datalen (%d), chanspec (%04x), freq (%d)\\n\",\n\t\t  mgmt_frame_len, e->datalen, ch.chspec, freq);\n\n\treturn 0;\n}\n\n\n \nstatic void brcmf_p2p_get_current_chanspec(struct brcmf_p2p_info *p2p,\n\t\t\t\t\t   u16 *chanspec)\n{\n\tstruct brcmf_if *ifp;\n\tu8 mac_addr[ETH_ALEN];\n\tstruct brcmu_chan ch;\n\tstruct brcmf_bss_info_le *bi;\n\tu8 *buf;\n\n\tifp = p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif->ifp;\n\n\tif (brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BSSID, mac_addr,\n\t\t\t\t   ETH_ALEN) == 0) {\n\t\tbuf = kzalloc(WL_BSS_INFO_MAX, GFP_KERNEL);\n\t\tif (buf != NULL) {\n\t\t\t*(__le32 *)buf = cpu_to_le32(WL_BSS_INFO_MAX);\n\t\t\tif (brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BSS_INFO,\n\t\t\t\t\t\t   buf, WL_BSS_INFO_MAX) == 0) {\n\t\t\t\tbi = (struct brcmf_bss_info_le *)(buf + 4);\n\t\t\t\t*chanspec = le16_to_cpu(bi->chanspec);\n\t\t\t\tkfree(buf);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tkfree(buf);\n\t\t}\n\t}\n\t \n\tch.chnum = BRCMF_P2P_TEMP_CHAN;\n\tch.bw = BRCMU_CHAN_BW_20;\n\tp2p->cfg->d11inf.encchspec(&ch);\n\t*chanspec = ch.chspec;\n}\n\n \nint brcmf_p2p_ifchange(struct brcmf_cfg80211_info *cfg,\n\t\t       enum brcmf_fil_p2p_if_types if_type)\n{\n\tstruct brcmf_p2p_info *p2p = &cfg->p2p;\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_cfg80211_vif *vif;\n\tstruct brcmf_fil_p2p_if_le if_request;\n\ts32 err;\n\tu16 chanspec;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tvif = p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif;\n\tif (!vif) {\n\t\tbphy_err(drvr, \"vif for P2PAPI_BSSCFG_PRIMARY does not exist\\n\");\n\t\treturn -EPERM;\n\t}\n\tbrcmf_notify_escan_complete(cfg, vif->ifp, true, true);\n\tvif = p2p->bss_idx[P2PAPI_BSSCFG_CONNECTION].vif;\n\tif (!vif) {\n\t\tbphy_err(drvr, \"vif for P2PAPI_BSSCFG_CONNECTION does not exist\\n\");\n\t\treturn -EPERM;\n\t}\n\tbrcmf_set_mpc(vif->ifp, 0);\n\n\t \n\t \n\t \n\tbrcmf_p2p_get_current_chanspec(p2p, &chanspec);\n\n\tif_request.type = cpu_to_le16((u16)if_type);\n\tif_request.chspec = cpu_to_le16(chanspec);\n\tmemcpy(if_request.addr, p2p->conn_int_addr, sizeof(if_request.addr));\n\n\tbrcmf_cfg80211_arm_vif_event(cfg, vif);\n\terr = brcmf_fil_iovar_data_set(vif->ifp, \"p2p_ifupd\", &if_request,\n\t\t\t\t       sizeof(if_request));\n\tif (err) {\n\t\tbphy_err(drvr, \"p2p_ifupd FAILED, err=%d\\n\", err);\n\t\tbrcmf_cfg80211_arm_vif_event(cfg, NULL);\n\t\treturn err;\n\t}\n\terr = brcmf_cfg80211_wait_vif_event(cfg, BRCMF_E_IF_CHANGE,\n\t\t\t\t\t    BRCMF_VIF_EVENT_TIMEOUT);\n\tbrcmf_cfg80211_arm_vif_event(cfg, NULL);\n\tif (!err)  {\n\t\tbphy_err(drvr, \"No BRCMF_E_IF_CHANGE event received\\n\");\n\t\treturn -EIO;\n\t}\n\n\terr = brcmf_fil_cmd_int_set(vif->ifp, BRCMF_C_SET_SCB_TIMEOUT,\n\t\t\t\t    BRCMF_SCB_TIMEOUT_VALUE);\n\n\treturn err;\n}\n\nstatic int brcmf_p2p_request_p2p_if(struct brcmf_p2p_info *p2p,\n\t\t\t\t    struct brcmf_if *ifp, u8 ea[ETH_ALEN],\n\t\t\t\t    enum brcmf_fil_p2p_if_types iftype)\n{\n\tstruct brcmf_fil_p2p_if_le if_request;\n\tint err;\n\tu16 chanspec;\n\n\t \n\tbrcmf_p2p_get_current_chanspec(p2p, &chanspec);\n\n\t \n\tmemcpy(if_request.addr, ea, ETH_ALEN);\n\tif_request.type = cpu_to_le16((u16)iftype);\n\tif_request.chspec = cpu_to_le16(chanspec);\n\n\terr = brcmf_fil_iovar_data_set(ifp, \"p2p_ifadd\", &if_request,\n\t\t\t\t       sizeof(if_request));\n\n\treturn err;\n}\n\nstatic int brcmf_p2p_disable_p2p_if(struct brcmf_cfg80211_vif *vif)\n{\n\tstruct brcmf_cfg80211_info *cfg = wdev_to_cfg(&vif->wdev);\n\tstruct net_device *pri_ndev = cfg_to_ndev(cfg);\n\tstruct brcmf_if *ifp = netdev_priv(pri_ndev);\n\tconst u8 *addr = vif->wdev.netdev->dev_addr;\n\n\treturn brcmf_fil_iovar_data_set(ifp, \"p2p_ifdis\", addr, ETH_ALEN);\n}\n\nstatic int brcmf_p2p_release_p2p_if(struct brcmf_cfg80211_vif *vif)\n{\n\tstruct brcmf_cfg80211_info *cfg = wdev_to_cfg(&vif->wdev);\n\tstruct net_device *pri_ndev = cfg_to_ndev(cfg);\n\tstruct brcmf_if *ifp = netdev_priv(pri_ndev);\n\tconst u8 *addr = vif->wdev.netdev->dev_addr;\n\n\treturn brcmf_fil_iovar_data_set(ifp, \"p2p_ifdel\", addr, ETH_ALEN);\n}\n\n \nstatic struct wireless_dev *brcmf_p2p_create_p2pdev(struct brcmf_p2p_info *p2p,\n\t\t\t\t\t\t    struct wiphy *wiphy,\n\t\t\t\t\t\t    u8 *addr)\n{\n\tstruct brcmf_pub *drvr = p2p->cfg->pub;\n\tstruct brcmf_cfg80211_vif *p2p_vif;\n\tstruct brcmf_if *p2p_ifp;\n\tstruct brcmf_if *pri_ifp;\n\tint err;\n\tu32 bsscfgidx;\n\n\tif (p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tp2p_vif = brcmf_alloc_vif(p2p->cfg, NL80211_IFTYPE_P2P_DEVICE);\n\tif (IS_ERR(p2p_vif)) {\n\t\tbphy_err(drvr, \"could not create discovery vif\\n\");\n\t\treturn (struct wireless_dev *)p2p_vif;\n\t}\n\n\tpri_ifp = p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif->ifp;\n\n\t \n\tif (addr && ether_addr_equal(addr, pri_ifp->mac_addr)) {\n\t\tbphy_err(drvr, \"discovery vif must be different from primary interface\\n\");\n\t\terr = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tbrcmf_p2p_generate_bss_mac(p2p, addr);\n\tbrcmf_p2p_set_firmware(pri_ifp, p2p->dev_addr);\n\n\tbrcmf_cfg80211_arm_vif_event(p2p->cfg, p2p_vif);\n\tbrcmf_fweh_p2pdev_setup(pri_ifp, true);\n\n\t \n\terr = brcmf_fil_iovar_int_set(pri_ifp, \"p2p_disc\", 1);\n\tif (err < 0) {\n\t\tbphy_err(drvr, \"set p2p_disc error\\n\");\n\t\tbrcmf_fweh_p2pdev_setup(pri_ifp, false);\n\t\tbrcmf_cfg80211_arm_vif_event(p2p->cfg, NULL);\n\t\tgoto fail;\n\t}\n\n\t \n\terr = brcmf_cfg80211_wait_vif_event(p2p->cfg, BRCMF_E_IF_ADD,\n\t\t\t\t\t    BRCMF_VIF_EVENT_TIMEOUT);\n\tbrcmf_cfg80211_arm_vif_event(p2p->cfg, NULL);\n\tbrcmf_fweh_p2pdev_setup(pri_ifp, false);\n\tif (!err) {\n\t\tbphy_err(drvr, \"timeout occurred\\n\");\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\t \n\tp2p_ifp = p2p_vif->ifp;\n\tp2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif = p2p_vif;\n\tmemcpy(p2p_ifp->mac_addr, p2p->dev_addr, ETH_ALEN);\n\tmemcpy(&p2p_vif->wdev.address, p2p->dev_addr, sizeof(p2p->dev_addr));\n\n\t \n\terr = brcmf_fil_iovar_int_get(pri_ifp, \"p2p_dev\", &bsscfgidx);\n\tif (err < 0) {\n\t\tbphy_err(drvr, \"retrieving discover bsscfg index failed\\n\");\n\t\tgoto fail;\n\t}\n\n\tWARN_ON(p2p_ifp->bsscfgidx != bsscfgidx);\n\n\tinit_completion(&p2p->send_af_done);\n\tINIT_WORK(&p2p->afx_hdl.afx_work, brcmf_p2p_afx_handler);\n\tinit_completion(&p2p->afx_hdl.act_frm_scan);\n\tinit_completion(&p2p->wait_next_af);\n\n\treturn &p2p_vif->wdev;\n\nfail:\n\tbrcmf_free_vif(p2p_vif);\n\treturn ERR_PTR(err);\n}\n\nstatic int brcmf_p2p_get_conn_idx(struct brcmf_cfg80211_info *cfg)\n{\n\tint i;\n\tstruct brcmf_if *ifp = netdev_priv(cfg_to_ndev(cfg));\n\n\tif (!ifp)\n\t\treturn -ENODEV;\n\n\tfor (i = P2PAPI_BSSCFG_CONNECTION; i < P2PAPI_BSSCFG_MAX; i++) {\n\t\tif (!cfg->p2p.bss_idx[i].vif) {\n\t\t\tif (i == P2PAPI_BSSCFG_CONNECTION2 &&\n\t\t\t    !(brcmf_feat_is_enabled(ifp, BRCMF_FEAT_RSDB))) {\n\t\t\t\tbrcmf_err(\"Multi p2p not supported\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -EIO;\n}\n\n \nstruct wireless_dev *brcmf_p2p_add_vif(struct wiphy *wiphy, const char *name,\n\t\t\t\t       unsigned char name_assign_type,\n\t\t\t\t       enum nl80211_iftype type,\n\t\t\t\t       struct vif_params *params)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(cfg_to_ndev(cfg));\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_cfg80211_vif *vif;\n\tenum brcmf_fil_p2p_if_types iftype;\n\tint err = 0;\n\tint connidx;\n\tu8 *p2p_intf_addr;\n\n\tif (brcmf_cfg80211_vif_event_armed(cfg))\n\t\treturn ERR_PTR(-EBUSY);\n\n\tbrcmf_dbg(INFO, \"adding vif \\\"%s\\\" (type=%d)\\n\", name, type);\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tiftype = BRCMF_FIL_P2P_IF_CLIENT;\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tiftype = BRCMF_FIL_P2P_IF_GO;\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\treturn brcmf_p2p_create_p2pdev(&cfg->p2p, wiphy,\n\t\t\t\t\t       params->macaddr);\n\tdefault:\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\n\tvif = brcmf_alloc_vif(cfg, type);\n\tif (IS_ERR(vif))\n\t\treturn (struct wireless_dev *)vif;\n\tbrcmf_cfg80211_arm_vif_event(cfg, vif);\n\n\tconnidx = brcmf_p2p_get_conn_idx(cfg);\n\n\tif (connidx == P2PAPI_BSSCFG_CONNECTION)\n\t\tp2p_intf_addr = cfg->p2p.conn_int_addr;\n\telse if (connidx == P2PAPI_BSSCFG_CONNECTION2)\n\t\tp2p_intf_addr = cfg->p2p.conn2_int_addr;\n\telse\n\t\terr = -EINVAL;\n\n\tif (!err)\n\t\terr =  brcmf_p2p_request_p2p_if(&cfg->p2p, ifp,\n\t\t\t\t\t\tp2p_intf_addr, iftype);\n\n\tif (err) {\n\t\tbrcmf_err(\"request p2p interface failed\\n\");\n\t\tbrcmf_cfg80211_arm_vif_event(cfg, NULL);\n\t\tgoto fail;\n\t}\n\n\t \n\terr = brcmf_cfg80211_wait_vif_event(cfg, BRCMF_E_IF_ADD,\n\t\t\t\t\t    BRCMF_VIF_EVENT_TIMEOUT);\n\tbrcmf_cfg80211_arm_vif_event(cfg, NULL);\n\tif (!err) {\n\t\tbphy_err(drvr, \"timeout occurred\\n\");\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\t \n\tifp = vif->ifp;\n\tif (!ifp) {\n\t\tbphy_err(drvr, \"no if pointer provided\\n\");\n\t\terr = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tstrncpy(ifp->ndev->name, name, sizeof(ifp->ndev->name) - 1);\n\tifp->ndev->name_assign_type = name_assign_type;\n\terr = brcmf_net_attach(ifp, true);\n\tif (err) {\n\t\tbphy_err(drvr, \"Registering netdevice failed\\n\");\n\t\tfree_netdev(ifp->ndev);\n\t\tgoto fail;\n\t}\n\n\tcfg->p2p.bss_idx[connidx].vif = vif;\n\t \n\tbrcmf_fil_iovar_int_set(ifp, \"roam_off\", 1);\n\tif (iftype == BRCMF_FIL_P2P_IF_GO) {\n\t\t \n\t\tbrcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCB_TIMEOUT,\n\t\t\t\t      BRCMF_SCB_TIMEOUT_VALUE);\n\t}\n\treturn &ifp->vif->wdev;\n\nfail:\n\tbrcmf_free_vif(vif);\n\treturn ERR_PTR(err);\n}\n\n \nint brcmf_p2p_del_vif(struct wiphy *wiphy, struct wireless_dev *wdev)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_p2p_info *p2p = &cfg->p2p;\n\tstruct brcmf_cfg80211_vif *vif;\n\tenum nl80211_iftype iftype;\n\tbool wait_for_disable = false;\n\tint err;\n\n\tbrcmf_dbg(TRACE, \"delete P2P vif\\n\");\n\tvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\n\n\tiftype = vif->wdev.iftype;\n\tbrcmf_cfg80211_arm_vif_event(cfg, vif);\n\tswitch (iftype) {\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tif (test_bit(BRCMF_VIF_STATUS_DISCONNECTING, &vif->sme_state))\n\t\t\twait_for_disable = true;\n\t\tbreak;\n\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tif (!brcmf_p2p_disable_p2p_if(vif))\n\t\t\twait_for_disable = true;\n\t\tbreak;\n\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tif (!p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif)\n\t\t\treturn 0;\n\t\tbrcmf_p2p_cancel_remain_on_channel(vif->ifp);\n\t\tbrcmf_p2p_deinit_discovery(p2p);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\tclear_bit(BRCMF_P2P_STATUS_GO_NEG_PHASE, &p2p->status);\n\tbrcmf_dbg(INFO, \"P2P: GO_NEG_PHASE status cleared\\n\");\n\n\tif (wait_for_disable)\n\t\twait_for_completion_timeout(&cfg->vif_disabled,\n\t\t\t\t\t    BRCMF_P2P_DISABLE_TIMEOUT);\n\n\terr = 0;\n\tif (iftype != NL80211_IFTYPE_P2P_DEVICE) {\n\t\tbrcmf_vif_clear_mgmt_ies(vif);\n\t\terr = brcmf_p2p_release_p2p_if(vif);\n\t}\n\tif (!err) {\n\t\t \n\t\terr = brcmf_cfg80211_wait_vif_event(cfg, BRCMF_E_IF_DEL,\n\t\t\t\t\t\t    BRCMF_VIF_EVENT_TIMEOUT);\n\t\tif (!err)\n\t\t\terr = -EIO;\n\t\telse\n\t\t\terr = 0;\n\t}\n\tbrcmf_remove_interface(vif->ifp, true);\n\n\tbrcmf_cfg80211_arm_vif_event(cfg, NULL);\n\tif (iftype != NL80211_IFTYPE_P2P_DEVICE) {\n\t\tif (vif == p2p->bss_idx[P2PAPI_BSSCFG_CONNECTION].vif)\n\t\t\tp2p->bss_idx[P2PAPI_BSSCFG_CONNECTION].vif = NULL;\n\t\tif (vif == p2p->bss_idx[P2PAPI_BSSCFG_CONNECTION2].vif)\n\t\t\tp2p->bss_idx[P2PAPI_BSSCFG_CONNECTION2].vif = NULL;\n\t}\n\n\treturn err;\n}\n\nvoid brcmf_p2p_ifp_removed(struct brcmf_if *ifp, bool locked)\n{\n\tstruct brcmf_cfg80211_info *cfg;\n\tstruct brcmf_cfg80211_vif *vif;\n\n\tbrcmf_dbg(INFO, \"P2P: device interface removed\\n\");\n\tvif = ifp->vif;\n\tcfg = wdev_to_cfg(&vif->wdev);\n\tcfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif = NULL;\n\tif (!locked) {\n\t\trtnl_lock();\n\t\twiphy_lock(cfg->wiphy);\n\t\tcfg80211_unregister_wdev(&vif->wdev);\n\t\twiphy_unlock(cfg->wiphy);\n\t\trtnl_unlock();\n\t} else {\n\t\tcfg80211_unregister_wdev(&vif->wdev);\n\t}\n\tbrcmf_free_vif(vif);\n}\n\nint brcmf_p2p_start_device(struct wiphy *wiphy, struct wireless_dev *wdev)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_p2p_info *p2p = &cfg->p2p;\n\tstruct brcmf_cfg80211_vif *vif;\n\tint err;\n\n\tvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\n\tmutex_lock(&cfg->usr_sync);\n\terr = brcmf_p2p_enable_discovery(p2p);\n\tif (!err)\n\t\tset_bit(BRCMF_VIF_STATUS_READY, &vif->sme_state);\n\tmutex_unlock(&cfg->usr_sync);\n\treturn err;\n}\n\nvoid brcmf_p2p_stop_device(struct wiphy *wiphy, struct wireless_dev *wdev)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_p2p_info *p2p = &cfg->p2p;\n\tstruct brcmf_cfg80211_vif *vif;\n\n\tvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\n\t \n\tif (p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif == vif) {\n\t\tmutex_lock(&cfg->usr_sync);\n\t\t \n\t\t(void)brcmf_p2p_set_discover_state(vif->ifp,\n\t\t\t\t\t\t   WL_P2P_DISC_ST_SCAN, 0, 0);\n\t\tbrcmf_abort_scanning(cfg);\n\t\tclear_bit(BRCMF_VIF_STATUS_READY, &vif->sme_state);\n\t\tmutex_unlock(&cfg->usr_sync);\n\t}\n}\n\n \ns32 brcmf_p2p_attach(struct brcmf_cfg80211_info *cfg, bool p2pdev_forced)\n{\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_p2p_info *p2p;\n\tstruct brcmf_if *pri_ifp;\n\ts32 err = 0;\n\tvoid *err_ptr;\n\n\tp2p = &cfg->p2p;\n\tp2p->cfg = cfg;\n\n\tpri_ifp = brcmf_get_ifp(cfg->pub, 0);\n\tp2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif = pri_ifp->vif;\n\n\tif (p2pdev_forced) {\n\t\terr_ptr = brcmf_p2p_create_p2pdev(p2p, NULL, NULL);\n\t\tif (IS_ERR(err_ptr)) {\n\t\t\tbphy_err(drvr, \"P2P device creation failed.\\n\");\n\t\t\terr = PTR_ERR(err_ptr);\n\t\t}\n\t} else {\n\t\tp2p->p2pdev_dynamically = true;\n\t}\n\treturn err;\n}\n\n \nvoid brcmf_p2p_detach(struct brcmf_p2p_info *p2p)\n{\n\tstruct brcmf_cfg80211_vif *vif;\n\n\tvif = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif;\n\tif (vif != NULL) {\n\t\tbrcmf_p2p_cancel_remain_on_channel(vif->ifp);\n\t\tbrcmf_p2p_deinit_discovery(p2p);\n\t\tbrcmf_remove_interface(vif->ifp, false);\n\t}\n\t \n\tmemset(p2p, 0, sizeof(*p2p));\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}