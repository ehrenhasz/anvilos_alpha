{
  "module_name": "flowring.c",
  "hash_id": "9517a7d34b1fe0354ff62d146329b2df4ec369b4c50b0c80f7c0af48b9d4188e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmfmac/flowring.c",
  "human_readable_source": "\n \n\n\n#include <linux/types.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <brcmu_utils.h>\n\n#include \"core.h\"\n#include \"debug.h\"\n#include \"bus.h\"\n#include \"proto.h\"\n#include \"flowring.h\"\n#include \"msgbuf.h\"\n#include \"common.h\"\n\n\n#define BRCMF_FLOWRING_HIGH\t\t1024\n#define BRCMF_FLOWRING_LOW\t\t(BRCMF_FLOWRING_HIGH - 256)\n#define BRCMF_FLOWRING_INVALID_IFIDX\t0xff\n\n#define BRCMF_FLOWRING_HASH_AP(da, fifo, ifidx) (da[5] * 2 + fifo + ifidx * 16)\n#define BRCMF_FLOWRING_HASH_STA(fifo, ifidx) (fifo + ifidx * 16)\n\nstatic const u8 brcmf_flowring_prio2fifo[] = {\n\t0,\n\t1,\n\t1,\n\t0,\n\t2,\n\t2,\n\t3,\n\t3\n};\n\nstatic const u8 ALLFFMAC[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\n\nstatic bool\nbrcmf_flowring_is_tdls_mac(struct brcmf_flowring *flow, u8 mac[ETH_ALEN])\n{\n\tstruct brcmf_flowring_tdls_entry *search;\n\n\tsearch = flow->tdls_entry;\n\n\twhile (search) {\n\t\tif (memcmp(search->mac, mac, ETH_ALEN) == 0)\n\t\t\treturn true;\n\t\tsearch = search->next;\n\t}\n\n\treturn false;\n}\n\n\nu32 brcmf_flowring_lookup(struct brcmf_flowring *flow, u8 da[ETH_ALEN],\n\t\t\t  u8 prio, u8 ifidx)\n{\n\tstruct brcmf_flowring_hash *hash;\n\tu16 hash_idx;\n\tu32 i;\n\tbool found;\n\tbool sta;\n\tu8 fifo;\n\tu8 *mac;\n\n\tfifo = brcmf_flowring_prio2fifo[prio];\n\tsta = (flow->addr_mode[ifidx] == ADDR_INDIRECT);\n\tmac = da;\n\tif ((!sta) && (is_multicast_ether_addr(da))) {\n\t\tmac = (u8 *)ALLFFMAC;\n\t\tfifo = 0;\n\t}\n\tif ((sta) && (flow->tdls_active) &&\n\t    (brcmf_flowring_is_tdls_mac(flow, da))) {\n\t\tsta = false;\n\t}\n\thash_idx =  sta ? BRCMF_FLOWRING_HASH_STA(fifo, ifidx) :\n\t\t\t  BRCMF_FLOWRING_HASH_AP(mac, fifo, ifidx);\n\thash_idx &= (BRCMF_FLOWRING_HASHSIZE - 1);\n\tfound = false;\n\thash = flow->hash;\n\tfor (i = 0; i < BRCMF_FLOWRING_HASHSIZE; i++) {\n\t\tif ((sta || (memcmp(hash[hash_idx].mac, mac, ETH_ALEN) == 0)) &&\n\t\t    (hash[hash_idx].fifo == fifo) &&\n\t\t    (hash[hash_idx].ifidx == ifidx)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t\thash_idx++;\n\t\thash_idx &= (BRCMF_FLOWRING_HASHSIZE - 1);\n\t}\n\tif (found)\n\t\treturn hash[hash_idx].flowid;\n\n\treturn BRCMF_FLOWRING_INVALID_ID;\n}\n\n\nu32 brcmf_flowring_create(struct brcmf_flowring *flow, u8 da[ETH_ALEN],\n\t\t\t  u8 prio, u8 ifidx)\n{\n\tstruct brcmf_flowring_ring *ring;\n\tstruct brcmf_flowring_hash *hash;\n\tu16 hash_idx;\n\tu32 i;\n\tbool found;\n\tu8 fifo;\n\tbool sta;\n\tu8 *mac;\n\n\tfifo = brcmf_flowring_prio2fifo[prio];\n\tsta = (flow->addr_mode[ifidx] == ADDR_INDIRECT);\n\tmac = da;\n\tif ((!sta) && (is_multicast_ether_addr(da))) {\n\t\tmac = (u8 *)ALLFFMAC;\n\t\tfifo = 0;\n\t}\n\tif ((sta) && (flow->tdls_active) &&\n\t    (brcmf_flowring_is_tdls_mac(flow, da))) {\n\t\tsta = false;\n\t}\n\thash_idx =  sta ? BRCMF_FLOWRING_HASH_STA(fifo, ifidx) :\n\t\t\t  BRCMF_FLOWRING_HASH_AP(mac, fifo, ifidx);\n\thash_idx &= (BRCMF_FLOWRING_HASHSIZE - 1);\n\tfound = false;\n\thash = flow->hash;\n\tfor (i = 0; i < BRCMF_FLOWRING_HASHSIZE; i++) {\n\t\tif ((hash[hash_idx].ifidx == BRCMF_FLOWRING_INVALID_IFIDX) &&\n\t\t    (is_zero_ether_addr(hash[hash_idx].mac))) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t\thash_idx++;\n\t\thash_idx &= (BRCMF_FLOWRING_HASHSIZE - 1);\n\t}\n\tif (found) {\n\t\tfor (i = 0; i < flow->nrofrings; i++) {\n\t\t\tif (flow->rings[i] == NULL)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == flow->nrofrings)\n\t\t\treturn -ENOMEM;\n\n\t\tring = kzalloc(sizeof(*ring), GFP_ATOMIC);\n\t\tif (!ring)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(hash[hash_idx].mac, mac, ETH_ALEN);\n\t\thash[hash_idx].fifo = fifo;\n\t\thash[hash_idx].ifidx = ifidx;\n\t\thash[hash_idx].flowid = i;\n\n\t\tring->hash_id = hash_idx;\n\t\tring->status = RING_CLOSED;\n\t\tskb_queue_head_init(&ring->skblist);\n\t\tflow->rings[i] = ring;\n\n\t\treturn i;\n\t}\n\treturn BRCMF_FLOWRING_INVALID_ID;\n}\n\n\nu8 brcmf_flowring_tid(struct brcmf_flowring *flow, u16 flowid)\n{\n\tstruct brcmf_flowring_ring *ring;\n\n\tring = flow->rings[flowid];\n\n\treturn flow->hash[ring->hash_id].fifo;\n}\n\n\nstatic void brcmf_flowring_block(struct brcmf_flowring *flow, u16 flowid,\n\t\t\t\t bool blocked)\n{\n\tstruct brcmf_flowring_ring *ring;\n\tstruct brcmf_bus *bus_if;\n\tstruct brcmf_pub *drvr;\n\tstruct brcmf_if *ifp;\n\tbool currently_blocked;\n\tint i;\n\tu8 ifidx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&flow->block_lock, flags);\n\n\tring = flow->rings[flowid];\n\tif (ring->blocked == blocked) {\n\t\tspin_unlock_irqrestore(&flow->block_lock, flags);\n\t\treturn;\n\t}\n\tifidx = brcmf_flowring_ifidx_get(flow, flowid);\n\n\tcurrently_blocked = false;\n\tfor (i = 0; i < flow->nrofrings; i++) {\n\t\tif ((flow->rings[i]) && (i != flowid)) {\n\t\t\tring = flow->rings[i];\n\t\t\tif ((ring->status == RING_OPEN) &&\n\t\t\t    (brcmf_flowring_ifidx_get(flow, i) == ifidx)) {\n\t\t\t\tif (ring->blocked) {\n\t\t\t\t\tcurrently_blocked = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tflow->rings[flowid]->blocked = blocked;\n\tif (currently_blocked) {\n\t\tspin_unlock_irqrestore(&flow->block_lock, flags);\n\t\treturn;\n\t}\n\n\tbus_if = dev_get_drvdata(flow->dev);\n\tdrvr = bus_if->drvr;\n\tifp = brcmf_get_ifp(drvr, ifidx);\n\tbrcmf_txflowblock_if(ifp, BRCMF_NETIF_STOP_REASON_FLOW, blocked);\n\n\tspin_unlock_irqrestore(&flow->block_lock, flags);\n}\n\n\nvoid brcmf_flowring_delete(struct brcmf_flowring *flow, u16 flowid)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(flow->dev);\n\tstruct brcmf_flowring_ring *ring;\n\tstruct brcmf_if *ifp;\n\tu16 hash_idx;\n\tu8 ifidx;\n\tstruct sk_buff *skb;\n\n\tring = flow->rings[flowid];\n\tif (!ring)\n\t\treturn;\n\n\tifidx = brcmf_flowring_ifidx_get(flow, flowid);\n\tifp = brcmf_get_ifp(bus_if->drvr, ifidx);\n\n\tbrcmf_flowring_block(flow, flowid, false);\n\thash_idx = ring->hash_id;\n\tflow->hash[hash_idx].ifidx = BRCMF_FLOWRING_INVALID_IFIDX;\n\teth_zero_addr(flow->hash[hash_idx].mac);\n\tflow->rings[flowid] = NULL;\n\n\tskb = skb_dequeue(&ring->skblist);\n\twhile (skb) {\n\t\tbrcmf_txfinalize(ifp, skb, false);\n\t\tskb = skb_dequeue(&ring->skblist);\n\t}\n\n\tkfree(ring);\n}\n\n\nu32 brcmf_flowring_enqueue(struct brcmf_flowring *flow, u16 flowid,\n\t\t\t   struct sk_buff *skb)\n{\n\tstruct brcmf_flowring_ring *ring;\n\n\tring = flow->rings[flowid];\n\n\tskb_queue_tail(&ring->skblist, skb);\n\n\tif (!ring->blocked &&\n\t    (skb_queue_len(&ring->skblist) > BRCMF_FLOWRING_HIGH)) {\n\t\tbrcmf_flowring_block(flow, flowid, true);\n\t\tbrcmf_dbg(MSGBUF, \"Flowcontrol: BLOCK for ring %d\\n\", flowid);\n\t\t \n\t\tif (skb_queue_len(&ring->skblist) < BRCMF_FLOWRING_LOW)\n\t\t\tbrcmf_flowring_block(flow, flowid, false);\n\t}\n\treturn skb_queue_len(&ring->skblist);\n}\n\n\nstruct sk_buff *brcmf_flowring_dequeue(struct brcmf_flowring *flow, u16 flowid)\n{\n\tstruct brcmf_flowring_ring *ring;\n\tstruct sk_buff *skb;\n\n\tring = flow->rings[flowid];\n\tif (ring->status != RING_OPEN)\n\t\treturn NULL;\n\n\tskb = skb_dequeue(&ring->skblist);\n\n\tif (ring->blocked &&\n\t    (skb_queue_len(&ring->skblist) < BRCMF_FLOWRING_LOW)) {\n\t\tbrcmf_flowring_block(flow, flowid, false);\n\t\tbrcmf_dbg(MSGBUF, \"Flowcontrol: OPEN for ring %d\\n\", flowid);\n\t}\n\n\treturn skb;\n}\n\n\nvoid brcmf_flowring_reinsert(struct brcmf_flowring *flow, u16 flowid,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct brcmf_flowring_ring *ring;\n\n\tring = flow->rings[flowid];\n\n\tskb_queue_head(&ring->skblist, skb);\n}\n\n\nu32 brcmf_flowring_qlen(struct brcmf_flowring *flow, u16 flowid)\n{\n\tstruct brcmf_flowring_ring *ring;\n\n\tring = flow->rings[flowid];\n\tif (!ring)\n\t\treturn 0;\n\n\tif (ring->status != RING_OPEN)\n\t\treturn 0;\n\n\treturn skb_queue_len(&ring->skblist);\n}\n\n\nvoid brcmf_flowring_open(struct brcmf_flowring *flow, u16 flowid)\n{\n\tstruct brcmf_flowring_ring *ring;\n\n\tring = flow->rings[flowid];\n\tif (!ring) {\n\t\tbrcmf_err(\"Ring NULL, for flowid %d\\n\", flowid);\n\t\treturn;\n\t}\n\n\tring->status = RING_OPEN;\n}\n\n\nu8 brcmf_flowring_ifidx_get(struct brcmf_flowring *flow, u16 flowid)\n{\n\tstruct brcmf_flowring_ring *ring;\n\tu16 hash_idx;\n\n\tring = flow->rings[flowid];\n\thash_idx = ring->hash_id;\n\n\treturn flow->hash[hash_idx].ifidx;\n}\n\n\nstruct brcmf_flowring *brcmf_flowring_attach(struct device *dev, u16 nrofrings)\n{\n\tstruct brcmf_flowring *flow;\n\tu32 i;\n\n\tflow = kzalloc(sizeof(*flow), GFP_KERNEL);\n\tif (flow) {\n\t\tflow->dev = dev;\n\t\tflow->nrofrings = nrofrings;\n\t\tspin_lock_init(&flow->block_lock);\n\t\tfor (i = 0; i < ARRAY_SIZE(flow->addr_mode); i++)\n\t\t\tflow->addr_mode[i] = ADDR_INDIRECT;\n\t\tfor (i = 0; i < ARRAY_SIZE(flow->hash); i++)\n\t\t\tflow->hash[i].ifidx = BRCMF_FLOWRING_INVALID_IFIDX;\n\t\tflow->rings = kcalloc(nrofrings, sizeof(*flow->rings),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!flow->rings) {\n\t\t\tkfree(flow);\n\t\t\tflow = NULL;\n\t\t}\n\t}\n\n\treturn flow;\n}\n\n\nvoid brcmf_flowring_detach(struct brcmf_flowring *flow)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(flow->dev);\n\tstruct brcmf_pub *drvr = bus_if->drvr;\n\tstruct brcmf_flowring_tdls_entry *search;\n\tstruct brcmf_flowring_tdls_entry *remove;\n\tu16 flowid;\n\n\tfor (flowid = 0; flowid < flow->nrofrings; flowid++) {\n\t\tif (flow->rings[flowid])\n\t\t\tbrcmf_msgbuf_delete_flowring(drvr, flowid);\n\t}\n\n\tsearch = flow->tdls_entry;\n\twhile (search) {\n\t\tremove = search;\n\t\tsearch = search->next;\n\t\tkfree(remove);\n\t}\n\tkfree(flow->rings);\n\tkfree(flow);\n}\n\n\nvoid brcmf_flowring_configure_addr_mode(struct brcmf_flowring *flow, int ifidx,\n\t\t\t\t\tenum proto_addr_mode addr_mode)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(flow->dev);\n\tstruct brcmf_pub *drvr = bus_if->drvr;\n\tu32 i;\n\tu16 flowid;\n\n\tif (flow->addr_mode[ifidx] != addr_mode) {\n\t\tfor (i = 0; i < ARRAY_SIZE(flow->hash); i++) {\n\t\t\tif (flow->hash[i].ifidx == ifidx) {\n\t\t\t\tflowid = flow->hash[i].flowid;\n\t\t\t\tif (flow->rings[flowid]->status != RING_OPEN)\n\t\t\t\t\tcontinue;\n\t\t\t\tbrcmf_msgbuf_delete_flowring(drvr, flowid);\n\t\t\t}\n\t\t}\n\t\tflow->addr_mode[ifidx] = addr_mode;\n\t}\n}\n\n\nvoid brcmf_flowring_delete_peer(struct brcmf_flowring *flow, int ifidx,\n\t\t\t\tu8 peer[ETH_ALEN])\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(flow->dev);\n\tstruct brcmf_pub *drvr = bus_if->drvr;\n\tstruct brcmf_flowring_hash *hash;\n\tstruct brcmf_flowring_tdls_entry *prev;\n\tstruct brcmf_flowring_tdls_entry *search;\n\tu32 i;\n\tu16 flowid;\n\tbool sta;\n\n\tsta = (flow->addr_mode[ifidx] == ADDR_INDIRECT);\n\n\tsearch = flow->tdls_entry;\n\tprev = NULL;\n\twhile (search) {\n\t\tif (memcmp(search->mac, peer, ETH_ALEN) == 0) {\n\t\t\tsta = false;\n\t\t\tbreak;\n\t\t}\n\t\tprev = search;\n\t\tsearch = search->next;\n\t}\n\n\thash = flow->hash;\n\tfor (i = 0; i < BRCMF_FLOWRING_HASHSIZE; i++) {\n\t\tif ((sta || (memcmp(hash[i].mac, peer, ETH_ALEN) == 0)) &&\n\t\t    (hash[i].ifidx == ifidx)) {\n\t\t\tflowid = flow->hash[i].flowid;\n\t\t\tif (flow->rings[flowid]->status == RING_OPEN)\n\t\t\t\tbrcmf_msgbuf_delete_flowring(drvr, flowid);\n\t\t}\n\t}\n\n\tif (search) {\n\t\tif (prev)\n\t\t\tprev->next = search->next;\n\t\telse\n\t\t\tflow->tdls_entry = search->next;\n\t\tkfree(search);\n\t\tif (flow->tdls_entry == NULL)\n\t\t\tflow->tdls_active = false;\n\t}\n}\n\n\nvoid brcmf_flowring_add_tdls_peer(struct brcmf_flowring *flow, int ifidx,\n\t\t\t\t  u8 peer[ETH_ALEN])\n{\n\tstruct brcmf_flowring_tdls_entry *tdls_entry;\n\tstruct brcmf_flowring_tdls_entry *search;\n\n\ttdls_entry = kzalloc(sizeof(*tdls_entry), GFP_ATOMIC);\n\tif (tdls_entry == NULL)\n\t\treturn;\n\n\tmemcpy(tdls_entry->mac, peer, ETH_ALEN);\n\ttdls_entry->next = NULL;\n\tif (flow->tdls_entry == NULL) {\n\t\tflow->tdls_entry = tdls_entry;\n\t} else {\n\t\tsearch = flow->tdls_entry;\n\t\tif (memcmp(search->mac, peer, ETH_ALEN) == 0)\n\t\t\tgoto free_entry;\n\t\twhile (search->next) {\n\t\t\tsearch = search->next;\n\t\t\tif (memcmp(search->mac, peer, ETH_ALEN) == 0)\n\t\t\t\tgoto free_entry;\n\t\t}\n\t\tsearch->next = tdls_entry;\n\t}\n\n\tflow->tdls_active = true;\n\treturn;\n\nfree_entry:\n\tkfree(tdls_entry);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}