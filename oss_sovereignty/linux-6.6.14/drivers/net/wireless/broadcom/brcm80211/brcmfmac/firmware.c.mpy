{
  "module_name": "firmware.c",
  "hash_id": "eb77f09a3c01d2505cb4773be536ed12bbafed40e655e860a8c96d8e3b043ee8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c",
  "human_readable_source": "\n \n\n#include <linux/efi.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/bcm47xx_nvram.h>\n\n#include \"debug.h\"\n#include \"firmware.h\"\n#include \"core.h\"\n#include \"common.h\"\n#include \"chip.h\"\n\n#define BRCMF_FW_MAX_NVRAM_SIZE\t\t\t64000\n#define BRCMF_FW_NVRAM_DEVPATH_LEN\t\t19\t \n#define BRCMF_FW_NVRAM_PCIEDEV_LEN\t\t10\t \n#define BRCMF_FW_DEFAULT_BOARDREV\t\t\"boardrev=0xff\"\n#define BRCMF_FW_MACADDR_FMT\t\t\t\"macaddr=%pM\"\n#define BRCMF_FW_MACADDR_LEN\t\t\t(7 + ETH_ALEN * 3)\n\nenum nvram_parser_state {\n\tIDLE,\n\tKEY,\n\tVALUE,\n\tCOMMENT,\n\tEND\n};\n\n \nstruct nvram_parser {\n\tenum nvram_parser_state state;\n\tconst u8 *data;\n\tu8 *nvram;\n\tu32 nvram_len;\n\tu32 line;\n\tu32 column;\n\tu32 pos;\n\tu32 entry;\n\tbool multi_dev_v1;\n\tbool multi_dev_v2;\n\tbool boardrev_found;\n\tbool strip_mac;\n};\n\n \nstatic bool is_nvram_char(char c)\n{\n\t \n\tif (c == '#')\n\t\treturn false;\n\n\t \n\treturn (c >= 0x20 && c < 0x7f);\n}\n\nstatic bool is_whitespace(char c)\n{\n\treturn (c == ' ' || c == '\\r' || c == '\\n' || c == '\\t');\n}\n\nstatic enum nvram_parser_state brcmf_nvram_handle_idle(struct nvram_parser *nvp)\n{\n\tchar c;\n\n\tc = nvp->data[nvp->pos];\n\tif (c == '\\n')\n\t\treturn COMMENT;\n\tif (is_whitespace(c) || c == '\\0')\n\t\tgoto proceed;\n\tif (c == '#')\n\t\treturn COMMENT;\n\tif (is_nvram_char(c)) {\n\t\tnvp->entry = nvp->pos;\n\t\treturn KEY;\n\t}\n\tbrcmf_dbg(INFO, \"warning: ln=%d:col=%d: ignoring invalid character\\n\",\n\t\t  nvp->line, nvp->column);\nproceed:\n\tnvp->column++;\n\tnvp->pos++;\n\treturn IDLE;\n}\n\nstatic enum nvram_parser_state brcmf_nvram_handle_key(struct nvram_parser *nvp)\n{\n\tenum nvram_parser_state st = nvp->state;\n\tchar c;\n\n\tc = nvp->data[nvp->pos];\n\tif (c == '=') {\n\t\t \n\t\tif (strncmp(&nvp->data[nvp->entry], \"RAW1\", 4) == 0)\n\t\t\tst = COMMENT;\n\t\telse\n\t\t\tst = VALUE;\n\t\tif (strncmp(&nvp->data[nvp->entry], \"devpath\", 7) == 0)\n\t\t\tnvp->multi_dev_v1 = true;\n\t\tif (strncmp(&nvp->data[nvp->entry], \"pcie/\", 5) == 0)\n\t\t\tnvp->multi_dev_v2 = true;\n\t\tif (strncmp(&nvp->data[nvp->entry], \"boardrev\", 8) == 0)\n\t\t\tnvp->boardrev_found = true;\n\t\t \n\t\tif (nvp->strip_mac &&\n\t\t    strncmp(&nvp->data[nvp->entry], \"macaddr\", 7) == 0)\n\t\t\tst = COMMENT;\n\t} else if (!is_nvram_char(c) || c == ' ') {\n\t\tbrcmf_dbg(INFO, \"warning: ln=%d:col=%d: '=' expected, skip invalid key entry\\n\",\n\t\t\t  nvp->line, nvp->column);\n\t\treturn COMMENT;\n\t}\n\n\tnvp->column++;\n\tnvp->pos++;\n\treturn st;\n}\n\nstatic enum nvram_parser_state\nbrcmf_nvram_handle_value(struct nvram_parser *nvp)\n{\n\tchar c;\n\tchar *skv;\n\tchar *ekv;\n\tu32 cplen;\n\n\tc = nvp->data[nvp->pos];\n\tif (!is_nvram_char(c)) {\n\t\t \n\t\tekv = (u8 *)&nvp->data[nvp->pos];\n\t\tskv = (u8 *)&nvp->data[nvp->entry];\n\t\tcplen = ekv - skv;\n\t\tif (nvp->nvram_len + cplen + 1 >= BRCMF_FW_MAX_NVRAM_SIZE)\n\t\t\treturn END;\n\t\t \n\t\tmemcpy(&nvp->nvram[nvp->nvram_len], skv, cplen);\n\t\tnvp->nvram_len += cplen;\n\t\tnvp->nvram[nvp->nvram_len] = '\\0';\n\t\tnvp->nvram_len++;\n\t\treturn IDLE;\n\t}\n\tnvp->pos++;\n\tnvp->column++;\n\treturn VALUE;\n}\n\nstatic enum nvram_parser_state\nbrcmf_nvram_handle_comment(struct nvram_parser *nvp)\n{\n\tchar *eoc, *sol;\n\n\tsol = (char *)&nvp->data[nvp->pos];\n\teoc = strchr(sol, '\\n');\n\tif (!eoc) {\n\t\teoc = strchr(sol, '\\0');\n\t\tif (!eoc)\n\t\t\treturn END;\n\t}\n\n\t \n\tnvp->line++;\n\tnvp->column = 1;\n\tnvp->pos += (eoc - sol) + 1;\n\treturn IDLE;\n}\n\nstatic enum nvram_parser_state brcmf_nvram_handle_end(struct nvram_parser *nvp)\n{\n\t \n\treturn END;\n}\n\nstatic enum nvram_parser_state\n(*nv_parser_states[])(struct nvram_parser *nvp) = {\n\tbrcmf_nvram_handle_idle,\n\tbrcmf_nvram_handle_key,\n\tbrcmf_nvram_handle_value,\n\tbrcmf_nvram_handle_comment,\n\tbrcmf_nvram_handle_end\n};\n\nstatic int brcmf_init_nvram_parser(struct nvram_parser *nvp,\n\t\t\t\t   const u8 *data, size_t data_len)\n{\n\tsize_t size;\n\n\tmemset(nvp, 0, sizeof(*nvp));\n\tnvp->data = data;\n\t \n\tif (data_len > BRCMF_FW_MAX_NVRAM_SIZE)\n\t\tsize = BRCMF_FW_MAX_NVRAM_SIZE;\n\telse\n\t\tsize = data_len;\n\t \n\tsize += strlen(BRCMF_FW_DEFAULT_BOARDREV) + 1;\n\tsize += BRCMF_FW_MACADDR_LEN + 1;\n\t \n\tsize += 1 + 3 + sizeof(u32);\n\tnvp->nvram = kzalloc(size, GFP_KERNEL);\n\tif (!nvp->nvram)\n\t\treturn -ENOMEM;\n\n\tnvp->line = 1;\n\tnvp->column = 1;\n\treturn 0;\n}\n\n \nstatic void brcmf_fw_strip_multi_v1(struct nvram_parser *nvp, u16 domain_nr,\n\t\t\t\t    u16 bus_nr)\n{\n\t \n\tchar pci_path[] = \"=pci/?/?\";\n\tsize_t pci_len;\n\tchar pcie_path[] = \"=pcie/?/?\";\n\tsize_t pcie_len;\n\n\tu32 i, j;\n\tbool found;\n\tu8 *nvram;\n\tu8 id;\n\n\tnvram = kzalloc(nvp->nvram_len + 1 + 3 + sizeof(u32), GFP_KERNEL);\n\tif (!nvram)\n\t\tgoto fail;\n\n\t \n\tif (nvp->nvram_len < BRCMF_FW_NVRAM_DEVPATH_LEN + 6)\n\t\tgoto fail;\n\n\t \n\tsnprintf(pci_path, sizeof(pci_path), \"=pci/%d/%d\", domain_nr,\n\t\t bus_nr);\n\tpci_len = strlen(pci_path);\n\tsnprintf(pcie_path, sizeof(pcie_path), \"=pcie/%d/%d\", domain_nr,\n\t\t bus_nr);\n\tpcie_len = strlen(pcie_path);\n\tfound = false;\n\ti = 0;\n\twhile (i < nvp->nvram_len - BRCMF_FW_NVRAM_DEVPATH_LEN) {\n\t\t \n\t\tif (strncmp(&nvp->nvram[i], \"devpath\", 7) == 0 &&\n\t\t    (!strncmp(&nvp->nvram[i + 8], pci_path, pci_len) ||\n\t\t     !strncmp(&nvp->nvram[i + 8], pcie_path, pcie_len))) {\n\t\t\tid = nvp->nvram[i + 7] - '0';\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t\twhile (nvp->nvram[i] != 0)\n\t\t\ti++;\n\t\ti++;\n\t}\n\tif (!found)\n\t\tgoto fail;\n\n\t \n\ti = 0;\n\tj = 0;\n\twhile (i < nvp->nvram_len) {\n\t\tif ((nvp->nvram[i] - '0' == id) && (nvp->nvram[i + 1] == ':')) {\n\t\t\ti += 2;\n\t\t\tif (strncmp(&nvp->nvram[i], \"boardrev\", 8) == 0)\n\t\t\t\tnvp->boardrev_found = true;\n\t\t\twhile (nvp->nvram[i] != 0) {\n\t\t\t\tnvram[j] = nvp->nvram[i];\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tnvram[j] = 0;\n\t\t\tj++;\n\t\t}\n\t\twhile (nvp->nvram[i] != 0)\n\t\t\ti++;\n\t\ti++;\n\t}\n\tkfree(nvp->nvram);\n\tnvp->nvram = nvram;\n\tnvp->nvram_len = j;\n\treturn;\n\nfail:\n\tkfree(nvram);\n\tnvp->nvram_len = 0;\n}\n\n \nstatic void brcmf_fw_strip_multi_v2(struct nvram_parser *nvp, u16 domain_nr,\n\t\t\t\t    u16 bus_nr)\n{\n\tchar prefix[BRCMF_FW_NVRAM_PCIEDEV_LEN];\n\tsize_t len;\n\tu32 i, j;\n\tu8 *nvram;\n\n\tnvram = kzalloc(nvp->nvram_len + 1 + 3 + sizeof(u32), GFP_KERNEL);\n\tif (!nvram) {\n\t\tnvp->nvram_len = 0;\n\t\treturn;\n\t}\n\n\t \n\tsnprintf(prefix, sizeof(prefix), \"pcie/%d/%d/\", domain_nr, bus_nr);\n\tlen = strlen(prefix);\n\ti = 0;\n\tj = 0;\n\twhile (i < nvp->nvram_len - len) {\n\t\tif (strncmp(&nvp->nvram[i], prefix, len) == 0) {\n\t\t\ti += len;\n\t\t\tif (strncmp(&nvp->nvram[i], \"boardrev\", 8) == 0)\n\t\t\t\tnvp->boardrev_found = true;\n\t\t\twhile (nvp->nvram[i] != 0) {\n\t\t\t\tnvram[j] = nvp->nvram[i];\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tnvram[j] = 0;\n\t\t\tj++;\n\t\t}\n\t\twhile (nvp->nvram[i] != 0)\n\t\t\ti++;\n\t\ti++;\n\t}\n\tkfree(nvp->nvram);\n\tnvp->nvram = nvram;\n\tnvp->nvram_len = j;\n}\n\nstatic void brcmf_fw_add_defaults(struct nvram_parser *nvp)\n{\n\tif (nvp->boardrev_found)\n\t\treturn;\n\n\tmemcpy(&nvp->nvram[nvp->nvram_len], &BRCMF_FW_DEFAULT_BOARDREV,\n\t       strlen(BRCMF_FW_DEFAULT_BOARDREV));\n\tnvp->nvram_len += strlen(BRCMF_FW_DEFAULT_BOARDREV);\n\tnvp->nvram[nvp->nvram_len] = '\\0';\n\tnvp->nvram_len++;\n}\n\nstatic void brcmf_fw_add_macaddr(struct nvram_parser *nvp, u8 *mac)\n{\n\tint len;\n\n\tlen = scnprintf(&nvp->nvram[nvp->nvram_len], BRCMF_FW_MACADDR_LEN + 1,\n\t\t\tBRCMF_FW_MACADDR_FMT, mac);\n\tWARN_ON(len != BRCMF_FW_MACADDR_LEN);\n\tnvp->nvram_len += len + 1;\n}\n\n \nstatic void *brcmf_fw_nvram_strip(const u8 *data, size_t data_len,\n\t\t\t\t  u32 *new_length, u16 domain_nr, u16 bus_nr,\n\t\t\t\t  struct device *dev)\n{\n\tstruct nvram_parser nvp;\n\tu32 pad;\n\tu32 token;\n\t__le32 token_le;\n\tu8 mac[ETH_ALEN];\n\n\tif (brcmf_init_nvram_parser(&nvp, data, data_len) < 0)\n\t\treturn NULL;\n\n\tif (eth_platform_get_mac_address(dev, mac) == 0)\n\t\tnvp.strip_mac = true;\n\n\twhile (nvp.pos < data_len) {\n\t\tnvp.state = nv_parser_states[nvp.state](&nvp);\n\t\tif (nvp.state == END)\n\t\t\tbreak;\n\t}\n\tif (nvp.multi_dev_v1) {\n\t\tnvp.boardrev_found = false;\n\t\tbrcmf_fw_strip_multi_v1(&nvp, domain_nr, bus_nr);\n\t} else if (nvp.multi_dev_v2) {\n\t\tnvp.boardrev_found = false;\n\t\tbrcmf_fw_strip_multi_v2(&nvp, domain_nr, bus_nr);\n\t}\n\n\tif (nvp.nvram_len == 0) {\n\t\tkfree(nvp.nvram);\n\t\treturn NULL;\n\t}\n\n\tbrcmf_fw_add_defaults(&nvp);\n\n\tif (nvp.strip_mac)\n\t\tbrcmf_fw_add_macaddr(&nvp, mac);\n\n\tpad = nvp.nvram_len;\n\t*new_length = roundup(nvp.nvram_len + 1, 4);\n\twhile (pad != *new_length) {\n\t\tnvp.nvram[pad] = 0;\n\t\tpad++;\n\t}\n\n\ttoken = *new_length / 4;\n\ttoken = (~token << 16) | (token & 0x0000FFFF);\n\ttoken_le = cpu_to_le32(token);\n\n\tmemcpy(&nvp.nvram[*new_length], &token_le, sizeof(token_le));\n\t*new_length += sizeof(token_le);\n\n\treturn nvp.nvram;\n}\n\nvoid brcmf_fw_nvram_free(void *nvram)\n{\n\tkfree(nvram);\n}\n\nstruct brcmf_fw {\n\tstruct device *dev;\n\tstruct brcmf_fw_request *req;\n\tu32 curpos;\n\tunsigned int board_index;\n\tvoid (*done)(struct device *dev, int err, struct brcmf_fw_request *req);\n};\n\n#ifdef CONFIG_EFI\n \nstatic void brcmf_fw_fix_efi_nvram_ccode(char *data, unsigned long data_len)\n{\n\tchar *ccode;\n\n\tccode = strnstr((char *)data, \"ccode=ALL\", data_len);\n\tif (!ccode)\n\t\tccode = strnstr((char *)data, \"ccode=XV\\r\", data_len);\n\tif (!ccode)\n\t\treturn;\n\n\tccode[6] = 'X';\n\tccode[7] = '2';\n\tccode[8] = '\\r';\n}\n\nstatic u8 *brcmf_fw_nvram_from_efi(size_t *data_len_ret)\n{\n\tefi_guid_t guid = EFI_GUID(0x74b00bd9, 0x805a, 0x4d61, 0xb5, 0x1f,\n\t\t\t\t   0x43, 0x26, 0x81, 0x23, 0xd1, 0x13);\n\tunsigned long data_len = 0;\n\tefi_status_t status;\n\tu8 *data = NULL;\n\n\tif (!efi_rt_services_supported(EFI_RT_SUPPORTED_GET_VARIABLE))\n\t\treturn NULL;\n\n\tstatus = efi.get_variable(L\"nvram\", &guid, NULL, &data_len, NULL);\n\tif (status != EFI_BUFFER_TOO_SMALL)\n\t\tgoto fail;\n\n\tdata = kmalloc(data_len, GFP_KERNEL);\n\tif (!data)\n\t\tgoto fail;\n\n\tstatus = efi.get_variable(L\"nvram\", &guid, NULL, &data_len, data);\n\tif (status != EFI_SUCCESS)\n\t\tgoto fail;\n\n\tbrcmf_fw_fix_efi_nvram_ccode(data, data_len);\n\tbrcmf_info(\"Using nvram EFI variable\\n\");\n\n\t*data_len_ret = data_len;\n\treturn data;\nfail:\n\tkfree(data);\n\treturn NULL;\n}\n#else\nstatic inline u8 *brcmf_fw_nvram_from_efi(size_t *data_len) { return NULL; }\n#endif\n\nstatic void brcmf_fw_free_request(struct brcmf_fw_request *req)\n{\n\tstruct brcmf_fw_item *item;\n\tint i;\n\n\tfor (i = 0, item = &req->items[0]; i < req->n_items; i++, item++) {\n\t\tif (item->type == BRCMF_FW_TYPE_BINARY)\n\t\t\trelease_firmware(item->binary);\n\t\telse if (item->type == BRCMF_FW_TYPE_NVRAM)\n\t\t\tbrcmf_fw_nvram_free(item->nv_data.data);\n\t}\n\tkfree(req);\n}\n\nstatic int brcmf_fw_request_nvram_done(const struct firmware *fw, void *ctx)\n{\n\tstruct brcmf_fw *fwctx = ctx;\n\tstruct brcmf_fw_item *cur;\n\tbool free_bcm47xx_nvram = false;\n\tbool kfree_nvram = false;\n\tu32 nvram_length = 0;\n\tvoid *nvram = NULL;\n\tu8 *data = NULL;\n\tsize_t data_len;\n\n\tbrcmf_dbg(TRACE, \"enter: dev=%s\\n\", dev_name(fwctx->dev));\n\n\tcur = &fwctx->req->items[fwctx->curpos];\n\n\tif (fw && fw->data) {\n\t\tdata = (u8 *)fw->data;\n\t\tdata_len = fw->size;\n\t} else {\n\t\tif ((data = bcm47xx_nvram_get_contents(&data_len)))\n\t\t\tfree_bcm47xx_nvram = true;\n\t\telse if ((data = brcmf_fw_nvram_from_efi(&data_len)))\n\t\t\tkfree_nvram = true;\n\t\telse if (!(cur->flags & BRCMF_FW_REQF_OPTIONAL))\n\t\t\tgoto fail;\n\t}\n\n\tif (data)\n\t\tnvram = brcmf_fw_nvram_strip(data, data_len, &nvram_length,\n\t\t\t\t\t     fwctx->req->domain_nr,\n\t\t\t\t\t     fwctx->req->bus_nr,\n\t\t\t\t\t     fwctx->dev);\n\n\tif (free_bcm47xx_nvram)\n\t\tbcm47xx_nvram_release_contents(data);\n\tif (kfree_nvram)\n\t\tkfree(data);\n\n\trelease_firmware(fw);\n\tif (!nvram && !(cur->flags & BRCMF_FW_REQF_OPTIONAL))\n\t\tgoto fail;\n\n\tbrcmf_dbg(TRACE, \"nvram %p len %d\\n\", nvram, nvram_length);\n\tcur->nv_data.data = nvram;\n\tcur->nv_data.len = nvram_length;\n\treturn 0;\n\nfail:\n\treturn -ENOENT;\n}\n\nstatic int brcmf_fw_complete_request(const struct firmware *fw,\n\t\t\t\t     struct brcmf_fw *fwctx)\n{\n\tstruct brcmf_fw_item *cur = &fwctx->req->items[fwctx->curpos];\n\tint ret = 0;\n\n\tbrcmf_dbg(TRACE, \"firmware %s %sfound\\n\", cur->path, fw ? \"\" : \"not \");\n\n\tswitch (cur->type) {\n\tcase BRCMF_FW_TYPE_NVRAM:\n\t\tret = brcmf_fw_request_nvram_done(fw, fwctx);\n\t\tbreak;\n\tcase BRCMF_FW_TYPE_BINARY:\n\t\tif (fw)\n\t\t\tcur->binary = fw;\n\t\telse\n\t\t\tret = -ENOENT;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbrcmf_err(\"unknown fw type: %d\\n\", cur->type);\n\t\trelease_firmware(fw);\n\t\tret = -EINVAL;\n\t}\n\n\treturn (cur->flags & BRCMF_FW_REQF_OPTIONAL) ? 0 : ret;\n}\n\nstatic char *brcm_alt_fw_path(const char *path, const char *board_type)\n{\n\tchar base[BRCMF_FW_NAME_LEN];\n\tconst char *suffix;\n\tchar *ret;\n\n\tif (!board_type)\n\t\treturn NULL;\n\n\tsuffix = strrchr(path, '.');\n\tif (!suffix || suffix == path)\n\t\treturn NULL;\n\n\t \n\tstrscpy(base, path, BRCMF_FW_NAME_LEN);\n\tbase[suffix - path] = 0;\n\n\tret = kasprintf(GFP_KERNEL, \"%s.%s%s\", base, board_type, suffix);\n\tif (!ret)\n\t\tbrcmf_err(\"out of memory allocating firmware path for '%s'\\n\",\n\t\t\t  path);\n\n\tbrcmf_dbg(TRACE, \"FW alt path: %s\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int brcmf_fw_request_firmware(const struct firmware **fw,\n\t\t\t\t     struct brcmf_fw *fwctx)\n{\n\tstruct brcmf_fw_item *cur = &fwctx->req->items[fwctx->curpos];\n\tunsigned int i;\n\tint ret;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(fwctx->req->board_types); i++) {\n\t\tchar *alt_path;\n\n\t\tif (!fwctx->req->board_types[i])\n\t\t\tgoto fallback;\n\t\talt_path = brcm_alt_fw_path(cur->path,\n\t\t\t\t\t    fwctx->req->board_types[i]);\n\t\tif (!alt_path)\n\t\t\tgoto fallback;\n\n\t\tret = firmware_request_nowarn(fw, alt_path, fwctx->dev);\n\t\tkfree(alt_path);\n\t\tif (ret == 0)\n\t\t\treturn ret;\n\t}\n\nfallback:\n\treturn request_firmware(fw, cur->path, fwctx->dev);\n}\n\nstatic void brcmf_fw_request_done(const struct firmware *fw, void *ctx)\n{\n\tstruct brcmf_fw *fwctx = ctx;\n\tint ret;\n\n\tret = brcmf_fw_complete_request(fw, fwctx);\n\n\twhile (ret == 0 && ++fwctx->curpos < fwctx->req->n_items) {\n\t\tbrcmf_fw_request_firmware(&fw, fwctx);\n\t\tret = brcmf_fw_complete_request(fw, ctx);\n\t}\n\n\tif (ret) {\n\t\tbrcmf_fw_free_request(fwctx->req);\n\t\tfwctx->req = NULL;\n\t}\n\tfwctx->done(fwctx->dev, ret, fwctx->req);\n\tkfree(fwctx);\n}\n\nstatic void brcmf_fw_request_done_alt_path(const struct firmware *fw, void *ctx)\n{\n\tstruct brcmf_fw *fwctx = ctx;\n\tstruct brcmf_fw_item *first = &fwctx->req->items[0];\n\tconst char *board_type, *alt_path;\n\tint ret = 0;\n\n\tif (fw) {\n\t\tbrcmf_fw_request_done(fw, ctx);\n\t\treturn;\n\t}\n\n\t \n\tif (fwctx->board_index < ARRAY_SIZE(fwctx->req->board_types)) {\n\t\tboard_type = fwctx->req->board_types[fwctx->board_index++];\n\t\tif (!board_type)\n\t\t\tgoto fallback;\n\t\talt_path = brcm_alt_fw_path(first->path, board_type);\n\t\tif (!alt_path)\n\t\t\tgoto fallback;\n\n\t\tret = request_firmware_nowait(THIS_MODULE, true, alt_path,\n\t\t\t\t\t      fwctx->dev, GFP_KERNEL, fwctx,\n\t\t\t\t\t      brcmf_fw_request_done_alt_path);\n\t\tkfree(alt_path);\n\n\t\tif (ret < 0)\n\t\t\tbrcmf_fw_request_done(fw, ctx);\n\t\treturn;\n\t}\n\nfallback:\n\t \n\tret = request_firmware_nowait(THIS_MODULE, true, first->path,\n\t\t\t\t      fwctx->dev, GFP_KERNEL, fwctx,\n\t\t\t\t      brcmf_fw_request_done);\n\n\tif (ret < 0)\n\t\tbrcmf_fw_request_done(fw, ctx);\n}\n\nstatic bool brcmf_fw_request_is_valid(struct brcmf_fw_request *req)\n{\n\tstruct brcmf_fw_item *item;\n\tint i;\n\n\tif (!req->n_items)\n\t\treturn false;\n\n\tfor (i = 0, item = &req->items[0]; i < req->n_items; i++, item++) {\n\t\tif (!item->path)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nint brcmf_fw_get_firmwares(struct device *dev, struct brcmf_fw_request *req,\n\t\t\t   void (*fw_cb)(struct device *dev, int err,\n\t\t\t\t\t struct brcmf_fw_request *req))\n{\n\tstruct brcmf_fw_item *first = &req->items[0];\n\tstruct brcmf_fw *fwctx;\n\tchar *alt_path = NULL;\n\tint ret;\n\n\tbrcmf_dbg(TRACE, \"enter: dev=%s\\n\", dev_name(dev));\n\tif (!fw_cb)\n\t\treturn -EINVAL;\n\n\tif (!brcmf_fw_request_is_valid(req))\n\t\treturn -EINVAL;\n\n\tfwctx = kzalloc(sizeof(*fwctx), GFP_KERNEL);\n\tif (!fwctx)\n\t\treturn -ENOMEM;\n\n\tfwctx->dev = dev;\n\tfwctx->req = req;\n\tfwctx->done = fw_cb;\n\n\t \n\tif (fwctx->req->board_types[0])\n\t\talt_path = brcm_alt_fw_path(first->path,\n\t\t\t\t\t    fwctx->req->board_types[0]);\n\tif (alt_path) {\n\t\tfwctx->board_index++;\n\t\tret = request_firmware_nowait(THIS_MODULE, true, alt_path,\n\t\t\t\t\t      fwctx->dev, GFP_KERNEL, fwctx,\n\t\t\t\t\t      brcmf_fw_request_done_alt_path);\n\t\tkfree(alt_path);\n\t} else {\n\t\tret = request_firmware_nowait(THIS_MODULE, true, first->path,\n\t\t\t\t\t      fwctx->dev, GFP_KERNEL, fwctx,\n\t\t\t\t\t      brcmf_fw_request_done);\n\t}\n\tif (ret < 0)\n\t\tbrcmf_fw_request_done(NULL, fwctx);\n\n\treturn 0;\n}\n\nstruct brcmf_fw_request *\nbrcmf_fw_alloc_request(u32 chip, u32 chiprev,\n\t\t       const struct brcmf_firmware_mapping mapping_table[],\n\t\t       u32 table_size, struct brcmf_fw_name *fwnames,\n\t\t       u32 n_fwnames)\n{\n\tstruct brcmf_fw_request *fwreq;\n\tchar chipname[12];\n\tconst char *mp_path;\n\tsize_t mp_path_len;\n\tu32 i, j;\n\tchar end = '\\0';\n\n\tif (chiprev >= BITS_PER_TYPE(u32)) {\n\t\tbrcmf_err(\"Invalid chip revision %u\\n\", chiprev);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < table_size; i++) {\n\t\tif (mapping_table[i].chipid == chip &&\n\t\t    mapping_table[i].revmask & BIT(chiprev))\n\t\t\tbreak;\n\t}\n\n\tbrcmf_chip_name(chip, chiprev, chipname, sizeof(chipname));\n\n\tif (i == table_size) {\n\t\tbrcmf_err(\"Unknown chip %s\\n\", chipname);\n\t\treturn NULL;\n\t}\n\n\tfwreq = kzalloc(struct_size(fwreq, items, n_fwnames), GFP_KERNEL);\n\tif (!fwreq)\n\t\treturn NULL;\n\n\tbrcmf_info(\"using %s for chip %s\\n\",\n\t\t   mapping_table[i].fw_base, chipname);\n\n\tmp_path = brcmf_mp_global.firmware_path;\n\tmp_path_len = strnlen(mp_path, BRCMF_FW_ALTPATH_LEN);\n\tif (mp_path_len)\n\t\tend = mp_path[mp_path_len - 1];\n\n\tfwreq->n_items = n_fwnames;\n\n\tfor (j = 0; j < n_fwnames; j++) {\n\t\tfwreq->items[j].path = fwnames[j].path;\n\t\tfwnames[j].path[0] = '\\0';\n\t\t \n\t\tif (brcmf_mp_global.firmware_path[0] != '\\0') {\n\t\t\tstrscpy(fwnames[j].path, mp_path,\n\t\t\t\tBRCMF_FW_NAME_LEN);\n\n\t\t\tif (end != '/') {\n\t\t\t\tstrlcat(fwnames[j].path, \"/\",\n\t\t\t\t\tBRCMF_FW_NAME_LEN);\n\t\t\t}\n\t\t}\n\t\tstrlcat(fwnames[j].path, mapping_table[i].fw_base,\n\t\t\tBRCMF_FW_NAME_LEN);\n\t\tstrlcat(fwnames[j].path, fwnames[j].extension,\n\t\t\tBRCMF_FW_NAME_LEN);\n\t\tfwreq->items[j].path = fwnames[j].path;\n\t}\n\n\treturn fwreq;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}