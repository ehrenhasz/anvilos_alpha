{
  "module_name": "chip.c",
  "hash_id": "02067298bbfa7aa1a721aa63357b4a641879b05bb6b281164ff0b3349d6382c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/list.h>\n#include <linux/ssb/ssb_regs.h>\n#include <linux/bcma/bcma.h>\n#include <linux/bcma/bcma_regs.h>\n\n#include <defs.h>\n#include <soc.h>\n#include <brcm_hw_ids.h>\n#include <brcmu_utils.h>\n#include <chipcommon.h>\n#include \"debug.h\"\n#include \"chip.h\"\n\n \n#define SOCI_SB\t\t0\n#define SOCI_AI\t\t1\n\n \n#define DMP_DESC_TYPE_MSK\t0x0000000F\n#define  DMP_DESC_EMPTY\t\t0x00000000\n#define  DMP_DESC_VALID\t\t0x00000001\n#define  DMP_DESC_COMPONENT\t0x00000001\n#define  DMP_DESC_MASTER_PORT\t0x00000003\n#define  DMP_DESC_ADDRESS\t0x00000005\n#define  DMP_DESC_ADDRSIZE_GT32\t0x00000008\n#define  DMP_DESC_EOT\t\t0x0000000F\n\n#define DMP_COMP_DESIGNER\t0xFFF00000\n#define DMP_COMP_DESIGNER_S\t20\n#define DMP_COMP_PARTNUM\t0x000FFF00\n#define DMP_COMP_PARTNUM_S\t8\n#define DMP_COMP_CLASS\t\t0x000000F0\n#define DMP_COMP_CLASS_S\t4\n#define DMP_COMP_REVISION\t0xFF000000\n#define DMP_COMP_REVISION_S\t24\n#define DMP_COMP_NUM_SWRAP\t0x00F80000\n#define DMP_COMP_NUM_SWRAP_S\t19\n#define DMP_COMP_NUM_MWRAP\t0x0007C000\n#define DMP_COMP_NUM_MWRAP_S\t14\n#define DMP_COMP_NUM_SPORT\t0x00003E00\n#define DMP_COMP_NUM_SPORT_S\t9\n#define DMP_COMP_NUM_MPORT\t0x000001F0\n#define DMP_COMP_NUM_MPORT_S\t4\n\n#define DMP_MASTER_PORT_UID\t0x0000FF00\n#define DMP_MASTER_PORT_UID_S\t8\n#define DMP_MASTER_PORT_NUM\t0x000000F0\n#define DMP_MASTER_PORT_NUM_S\t4\n\n#define DMP_SLAVE_ADDR_BASE\t0xFFFFF000\n#define DMP_SLAVE_ADDR_BASE_S\t12\n#define DMP_SLAVE_PORT_NUM\t0x00000F00\n#define DMP_SLAVE_PORT_NUM_S\t8\n#define DMP_SLAVE_TYPE\t\t0x000000C0\n#define DMP_SLAVE_TYPE_S\t6\n#define  DMP_SLAVE_TYPE_SLAVE\t0\n#define  DMP_SLAVE_TYPE_BRIDGE\t1\n#define  DMP_SLAVE_TYPE_SWRAP\t2\n#define  DMP_SLAVE_TYPE_MWRAP\t3\n#define DMP_SLAVE_SIZE_TYPE\t0x00000030\n#define DMP_SLAVE_SIZE_TYPE_S\t4\n#define  DMP_SLAVE_SIZE_4K\t0\n#define  DMP_SLAVE_SIZE_8K\t1\n#define  DMP_SLAVE_SIZE_16K\t2\n#define  DMP_SLAVE_SIZE_DESC\t3\n\n \n#define CIB_REV_MASK\t\t0xff000000\n#define CIB_REV_SHIFT\t\t24\n\n \n#define ARMCR4_BCMA_IOCTL_CPUHALT\t0x0020\n\n \n#define D11_BCMA_IOCTL_PHYCLOCKEN\t0x0004\n#define D11_BCMA_IOCTL_PHYRESET\t\t0x0008\n\n \n \n \n#define BCM4329_CORE_BUS_BASE\t\t0x18011000\n \n#define BCM4329_CORE_SOCRAM_BASE\t0x18003000\n \n#define BCM4329_CORE_ARM_BASE\t\t0x18002000\n\n \n#define BRCMF_CHIP_MAX_MEMSIZE\t\t(4 * 1024 * 1024)\n\n#define CORE_SB(base, field) \\\n\t\t(base + SBCONFIGOFF + offsetof(struct sbconfig, field))\n#define\tSBCOREREV(sbidh) \\\n\t((((sbidh) & SSB_IDHIGH_RCHI) >> SSB_IDHIGH_RCHI_SHIFT) | \\\n\t  ((sbidh) & SSB_IDHIGH_RCLO))\n\nstruct sbconfig {\n\tu32 PAD[2];\n\tu32 sbipsflag;\t \n\tu32 PAD[3];\n\tu32 sbtpsflag;\t \n\tu32 PAD[11];\n\tu32 sbtmerrloga;\t \n\tu32 PAD;\n\tu32 sbtmerrlog;\t \n\tu32 PAD[3];\n\tu32 sbadmatch3;\t \n\tu32 PAD;\n\tu32 sbadmatch2;\t \n\tu32 PAD;\n\tu32 sbadmatch1;\t \n\tu32 PAD[7];\n\tu32 sbimstate;\t \n\tu32 sbintvec;\t \n\tu32 sbtmstatelow;\t \n\tu32 sbtmstatehigh;\t \n\tu32 sbbwa0;\t\t \n\tu32 PAD;\n\tu32 sbimconfiglow;\t \n\tu32 sbimconfighigh;\t \n\tu32 sbadmatch0;\t \n\tu32 PAD;\n\tu32 sbtmconfiglow;\t \n\tu32 sbtmconfighigh;\t \n\tu32 sbbconfig;\t \n\tu32 PAD;\n\tu32 sbbstate;\t \n\tu32 PAD[3];\n\tu32 sbactcnfg;\t \n\tu32 PAD[3];\n\tu32 sbflagst;\t \n\tu32 PAD[3];\n\tu32 sbidlow;\t\t \n\tu32 sbidhigh;\t \n};\n\n#define INVALID_RAMBASE\t\t\t((u32)(~0))\n\n \n#define SOCRAM_BANKINFO_RETNTRAM_MASK\t0x00010000\n#define SOCRAM_BANKINFO_SZMASK\t\t0x0000007f\n#define SOCRAM_BANKIDX_ROM_MASK\t\t0x00000100\n\n#define SOCRAM_BANKIDX_MEMTYPE_SHIFT\t8\n \n#define SOCRAM_MEMTYPE_RAM\t\t0\n#define SOCRAM_MEMTYPE_R0M\t\t1\n#define SOCRAM_MEMTYPE_DEVRAM\t\t2\n\n#define SOCRAM_BANKINFO_SZBASE\t\t8192\n#define SRCI_LSS_MASK\t\t0x00f00000\n#define SRCI_LSS_SHIFT\t\t20\n#define\tSRCI_SRNB_MASK\t\t0xf0\n#define\tSRCI_SRNB_MASK_EXT\t0x100\n#define\tSRCI_SRNB_SHIFT\t\t4\n#define\tSRCI_SRBSZ_MASK\t\t0xf\n#define\tSRCI_SRBSZ_SHIFT\t0\n#define SR_BSZ_BASE\t\t14\n\nstruct sbsocramregs {\n\tu32 coreinfo;\n\tu32 bwalloc;\n\tu32 extracoreinfo;\n\tu32 biststat;\n\tu32 bankidx;\n\tu32 standbyctrl;\n\n\tu32 errlogstatus;\t \n\tu32 errlogaddr;\t \n\t \n\tu32 cambankidx;\n\tu32 cambankstandbyctrl;\n\tu32 cambankpatchctrl;\n\tu32 cambankpatchtblbaseaddr;\n\tu32 cambankcmdreg;\n\tu32 cambankdatareg;\n\tu32 cambankmaskreg;\n\tu32 PAD[1];\n\tu32 bankinfo;\t \n\tu32 bankpda;\n\tu32 PAD[14];\n\tu32 extmemconfig;\n\tu32 extmemparitycsr;\n\tu32 extmemparityerrdata;\n\tu32 extmemparityerrcnt;\n\tu32 extmemwrctrlandsize;\n\tu32 PAD[84];\n\tu32 workaround;\n\tu32 pwrctl;\t\t \n\tu32 PAD[133];\n\tu32 sr_control;      \n\tu32 sr_status;       \n\tu32 sr_address;      \n\tu32 sr_data;         \n};\n\n#define SOCRAMREGOFFS(_f)\toffsetof(struct sbsocramregs, _f)\n#define SYSMEMREGOFFS(_f)\toffsetof(struct sbsocramregs, _f)\n\n#define ARMCR4_CAP\t\t(0x04)\n#define ARMCR4_BANKIDX\t\t(0x40)\n#define ARMCR4_BANKINFO\t\t(0x44)\n#define ARMCR4_BANKPDA\t\t(0x4C)\n\n#define\tARMCR4_TCBBNB_MASK\t0xf0\n#define\tARMCR4_TCBBNB_SHIFT\t4\n#define\tARMCR4_TCBANB_MASK\t0xf\n#define\tARMCR4_TCBANB_SHIFT\t0\n\n#define\tARMCR4_BSZ_MASK\t\t0x7f\n#define\tARMCR4_BSZ_MULT\t\t8192\n#define\tARMCR4_BLK_1K_MASK\t0x200\n\nstruct brcmf_core_priv {\n\tstruct brcmf_core pub;\n\tu32 wrapbase;\n\tstruct list_head list;\n\tstruct brcmf_chip_priv *chip;\n};\n\nstruct brcmf_chip_priv {\n\tstruct brcmf_chip pub;\n\tconst struct brcmf_buscore_ops *ops;\n\tvoid *ctx;\n\t \n\tstruct list_head cores;\n\tu16 num_cores;\n\n\tbool (*iscoreup)(struct brcmf_core_priv *core);\n\tvoid (*coredisable)(struct brcmf_core_priv *core, u32 prereset,\n\t\t\t    u32 reset);\n\tvoid (*resetcore)(struct brcmf_core_priv *core, u32 prereset, u32 reset,\n\t\t\t  u32 postreset);\n};\n\nstatic void brcmf_chip_sb_corerev(struct brcmf_chip_priv *ci,\n\t\t\t\t  struct brcmf_core *core)\n{\n\tu32 regdata;\n\n\tregdata = ci->ops->read32(ci->ctx, CORE_SB(core->base, sbidhigh));\n\tcore->rev = SBCOREREV(regdata);\n}\n\nstatic bool brcmf_chip_sb_iscoreup(struct brcmf_core_priv *core)\n{\n\tstruct brcmf_chip_priv *ci;\n\tu32 regdata;\n\tu32 address;\n\n\tci = core->chip;\n\taddress = CORE_SB(core->pub.base, sbtmstatelow);\n\tregdata = ci->ops->read32(ci->ctx, address);\n\tregdata &= (SSB_TMSLOW_RESET | SSB_TMSLOW_REJECT |\n\t\t    SSB_IMSTATE_REJECT | SSB_TMSLOW_CLOCK);\n\treturn SSB_TMSLOW_CLOCK == regdata;\n}\n\nstatic bool brcmf_chip_ai_iscoreup(struct brcmf_core_priv *core)\n{\n\tstruct brcmf_chip_priv *ci;\n\tu32 regdata;\n\tbool ret;\n\n\tci = core->chip;\n\tregdata = ci->ops->read32(ci->ctx, core->wrapbase + BCMA_IOCTL);\n\tret = (regdata & (BCMA_IOCTL_FGC | BCMA_IOCTL_CLK)) == BCMA_IOCTL_CLK;\n\n\tregdata = ci->ops->read32(ci->ctx, core->wrapbase + BCMA_RESET_CTL);\n\tret = ret && ((regdata & BCMA_RESET_CTL_RESET) == 0);\n\n\treturn ret;\n}\n\nstatic void brcmf_chip_sb_coredisable(struct brcmf_core_priv *core,\n\t\t\t\t      u32 prereset, u32 reset)\n{\n\tstruct brcmf_chip_priv *ci;\n\tu32 val, base;\n\n\tci = core->chip;\n\tbase = core->pub.base;\n\tval = ci->ops->read32(ci->ctx, CORE_SB(base, sbtmstatelow));\n\tif (val & SSB_TMSLOW_RESET)\n\t\treturn;\n\n\tval = ci->ops->read32(ci->ctx, CORE_SB(base, sbtmstatelow));\n\tif ((val & SSB_TMSLOW_CLOCK) != 0) {\n\t\t \n\t\tval = ci->ops->read32(ci->ctx, CORE_SB(base, sbtmstatelow));\n\t\tci->ops->write32(ci->ctx, CORE_SB(base, sbtmstatelow),\n\t\t\t\t\t val | SSB_TMSLOW_REJECT);\n\n\t\tval = ci->ops->read32(ci->ctx, CORE_SB(base, sbtmstatelow));\n\t\tudelay(1);\n\t\tSPINWAIT((ci->ops->read32(ci->ctx, CORE_SB(base, sbtmstatehigh))\n\t\t\t  & SSB_TMSHIGH_BUSY), 100000);\n\n\t\tval = ci->ops->read32(ci->ctx, CORE_SB(base, sbtmstatehigh));\n\t\tif (val & SSB_TMSHIGH_BUSY)\n\t\t\tbrcmf_err(\"core state still busy\\n\");\n\n\t\tval = ci->ops->read32(ci->ctx, CORE_SB(base, sbidlow));\n\t\tif (val & SSB_IDLOW_INITIATOR) {\n\t\t\tval = ci->ops->read32(ci->ctx,\n\t\t\t\t\t      CORE_SB(base, sbimstate));\n\t\t\tval |= SSB_IMSTATE_REJECT;\n\t\t\tci->ops->write32(ci->ctx,\n\t\t\t\t\t CORE_SB(base, sbimstate), val);\n\t\t\tval = ci->ops->read32(ci->ctx,\n\t\t\t\t\t      CORE_SB(base, sbimstate));\n\t\t\tudelay(1);\n\t\t\tSPINWAIT((ci->ops->read32(ci->ctx,\n\t\t\t\t\t\t  CORE_SB(base, sbimstate)) &\n\t\t\t\t  SSB_IMSTATE_BUSY), 100000);\n\t\t}\n\n\t\t \n\t\tval = SSB_TMSLOW_FGC | SSB_TMSLOW_CLOCK |\n\t\t      SSB_TMSLOW_REJECT | SSB_TMSLOW_RESET;\n\t\tci->ops->write32(ci->ctx, CORE_SB(base, sbtmstatelow), val);\n\t\tval = ci->ops->read32(ci->ctx, CORE_SB(base, sbtmstatelow));\n\t\tudelay(10);\n\n\t\t \n\t\tval = ci->ops->read32(ci->ctx, CORE_SB(base, sbidlow));\n\t\tif (val & SSB_IDLOW_INITIATOR) {\n\t\t\tval = ci->ops->read32(ci->ctx,\n\t\t\t\t\t      CORE_SB(base, sbimstate));\n\t\t\tval &= ~SSB_IMSTATE_REJECT;\n\t\t\tci->ops->write32(ci->ctx,\n\t\t\t\t\t CORE_SB(base, sbimstate), val);\n\t\t}\n\t}\n\n\t \n\tci->ops->write32(ci->ctx, CORE_SB(base, sbtmstatelow),\n\t\t\t (SSB_TMSLOW_REJECT | SSB_TMSLOW_RESET));\n\tudelay(1);\n}\n\nstatic void brcmf_chip_ai_coredisable(struct brcmf_core_priv *core,\n\t\t\t\t      u32 prereset, u32 reset)\n{\n\tstruct brcmf_chip_priv *ci;\n\tu32 regdata;\n\n\tci = core->chip;\n\n\t \n\tregdata = ci->ops->read32(ci->ctx, core->wrapbase + BCMA_RESET_CTL);\n\tif ((regdata & BCMA_RESET_CTL_RESET) != 0)\n\t\tgoto in_reset_configure;\n\n\t \n\tci->ops->write32(ci->ctx, core->wrapbase + BCMA_IOCTL,\n\t\t\t prereset | BCMA_IOCTL_FGC | BCMA_IOCTL_CLK);\n\tci->ops->read32(ci->ctx, core->wrapbase + BCMA_IOCTL);\n\n\t \n\tci->ops->write32(ci->ctx, core->wrapbase + BCMA_RESET_CTL,\n\t\t\t BCMA_RESET_CTL_RESET);\n\tusleep_range(10, 20);\n\n\t \n\tSPINWAIT(ci->ops->read32(ci->ctx, core->wrapbase + BCMA_RESET_CTL) !=\n\t\t BCMA_RESET_CTL_RESET, 300);\n\nin_reset_configure:\n\t \n\tci->ops->write32(ci->ctx, core->wrapbase + BCMA_IOCTL,\n\t\t\t reset | BCMA_IOCTL_FGC | BCMA_IOCTL_CLK);\n\tci->ops->read32(ci->ctx, core->wrapbase + BCMA_IOCTL);\n}\n\nstatic void brcmf_chip_sb_resetcore(struct brcmf_core_priv *core, u32 prereset,\n\t\t\t\t    u32 reset, u32 postreset)\n{\n\tstruct brcmf_chip_priv *ci;\n\tu32 regdata;\n\tu32 base;\n\n\tci = core->chip;\n\tbase = core->pub.base;\n\t \n\tbrcmf_chip_sb_coredisable(core, 0, 0);\n\n\t \n\tci->ops->write32(ci->ctx, CORE_SB(base, sbtmstatelow),\n\t\t\t SSB_TMSLOW_FGC | SSB_TMSLOW_CLOCK |\n\t\t\t SSB_TMSLOW_RESET);\n\tregdata = ci->ops->read32(ci->ctx, CORE_SB(base, sbtmstatelow));\n\tudelay(1);\n\n\t \n\tregdata = ci->ops->read32(ci->ctx, CORE_SB(base, sbtmstatehigh));\n\tif (regdata & SSB_TMSHIGH_SERR)\n\t\tci->ops->write32(ci->ctx, CORE_SB(base, sbtmstatehigh), 0);\n\n\tregdata = ci->ops->read32(ci->ctx, CORE_SB(base, sbimstate));\n\tif (regdata & (SSB_IMSTATE_IBE | SSB_IMSTATE_TO)) {\n\t\tregdata &= ~(SSB_IMSTATE_IBE | SSB_IMSTATE_TO);\n\t\tci->ops->write32(ci->ctx, CORE_SB(base, sbimstate), regdata);\n\t}\n\n\t \n\tci->ops->write32(ci->ctx, CORE_SB(base, sbtmstatelow),\n\t\t\t SSB_TMSLOW_FGC | SSB_TMSLOW_CLOCK);\n\tregdata = ci->ops->read32(ci->ctx, CORE_SB(base, sbtmstatelow));\n\tudelay(1);\n\n\t \n\tci->ops->write32(ci->ctx, CORE_SB(base, sbtmstatelow),\n\t\t\t SSB_TMSLOW_CLOCK);\n\tregdata = ci->ops->read32(ci->ctx, CORE_SB(base, sbtmstatelow));\n\tudelay(1);\n}\n\nstatic void brcmf_chip_ai_resetcore(struct brcmf_core_priv *core, u32 prereset,\n\t\t\t\t    u32 reset, u32 postreset)\n{\n\tstruct brcmf_chip_priv *ci;\n\tint count;\n\tstruct brcmf_core *d11core2 = NULL;\n\tstruct brcmf_core_priv *d11priv2 = NULL;\n\n\tci = core->chip;\n\n\t \n\tif (core->pub.id == BCMA_CORE_80211) {\n\t\td11core2 = brcmf_chip_get_d11core(&ci->pub, 1);\n\t\tif (d11core2) {\n\t\t\tbrcmf_dbg(INFO, \"found two d11 cores, reset both\\n\");\n\t\t\td11priv2 = container_of(d11core2,\n\t\t\t\t\t\tstruct brcmf_core_priv, pub);\n\t\t}\n\t}\n\n\t \n\tbrcmf_chip_ai_coredisable(core, prereset, reset);\n\tif (d11priv2)\n\t\tbrcmf_chip_ai_coredisable(d11priv2, prereset, reset);\n\n\tcount = 0;\n\twhile (ci->ops->read32(ci->ctx, core->wrapbase + BCMA_RESET_CTL) &\n\t       BCMA_RESET_CTL_RESET) {\n\t\tci->ops->write32(ci->ctx, core->wrapbase + BCMA_RESET_CTL, 0);\n\t\tcount++;\n\t\tif (count > 50)\n\t\t\tbreak;\n\t\tusleep_range(40, 60);\n\t}\n\n\tif (d11priv2) {\n\t\tcount = 0;\n\t\twhile (ci->ops->read32(ci->ctx,\n\t\t\t\t       d11priv2->wrapbase + BCMA_RESET_CTL) &\n\t\t\t\t       BCMA_RESET_CTL_RESET) {\n\t\t\tci->ops->write32(ci->ctx,\n\t\t\t\t\t d11priv2->wrapbase + BCMA_RESET_CTL,\n\t\t\t\t\t 0);\n\t\t\tcount++;\n\t\t\tif (count > 50)\n\t\t\t\tbreak;\n\t\t\tusleep_range(40, 60);\n\t\t}\n\t}\n\n\tci->ops->write32(ci->ctx, core->wrapbase + BCMA_IOCTL,\n\t\t\t postreset | BCMA_IOCTL_CLK);\n\tci->ops->read32(ci->ctx, core->wrapbase + BCMA_IOCTL);\n\n\tif (d11priv2) {\n\t\tci->ops->write32(ci->ctx, d11priv2->wrapbase + BCMA_IOCTL,\n\t\t\t\t postreset | BCMA_IOCTL_CLK);\n\t\tci->ops->read32(ci->ctx, d11priv2->wrapbase + BCMA_IOCTL);\n\t}\n}\n\nchar *brcmf_chip_name(u32 id, u32 rev, char *buf, uint len)\n{\n\tconst char *fmt;\n\n\tfmt = ((id > 0xa000) || (id < 0x4000)) ? \"BCM%d/%u\" : \"BCM%x/%u\";\n\tsnprintf(buf, len, fmt, id, rev);\n\treturn buf;\n}\n\nstatic struct brcmf_core *brcmf_chip_add_core(struct brcmf_chip_priv *ci,\n\t\t\t\t\t      u16 coreid, u32 base,\n\t\t\t\t\t      u32 wrapbase)\n{\n\tstruct brcmf_core_priv *core;\n\n\tcore = kzalloc(sizeof(*core), GFP_KERNEL);\n\tif (!core)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcore->pub.id = coreid;\n\tcore->pub.base = base;\n\tcore->chip = ci;\n\tcore->wrapbase = wrapbase;\n\n\tlist_add_tail(&core->list, &ci->cores);\n\treturn &core->pub;\n}\n\n \nstatic int brcmf_chip_cores_check(struct brcmf_chip_priv *ci)\n{\n\tstruct brcmf_core_priv *core;\n\tbool need_socram = false;\n\tbool has_socram = false;\n\tbool cpu_found = false;\n\tint idx = 1;\n\n\tlist_for_each_entry(core, &ci->cores, list) {\n\t\tbrcmf_dbg(INFO, \" [%-2d] core 0x%x:%-3d base 0x%08x wrap 0x%08x\\n\",\n\t\t\t  idx++, core->pub.id, core->pub.rev, core->pub.base,\n\t\t\t  core->wrapbase);\n\n\t\tswitch (core->pub.id) {\n\t\tcase BCMA_CORE_ARM_CM3:\n\t\t\tcpu_found = true;\n\t\t\tneed_socram = true;\n\t\t\tbreak;\n\t\tcase BCMA_CORE_INTERNAL_MEM:\n\t\t\thas_socram = true;\n\t\t\tbreak;\n\t\tcase BCMA_CORE_ARM_CR4:\n\t\t\tcpu_found = true;\n\t\t\tbreak;\n\t\tcase BCMA_CORE_ARM_CA7:\n\t\t\tcpu_found = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!cpu_found) {\n\t\tbrcmf_err(\"CPU core not detected\\n\");\n\t\treturn -ENXIO;\n\t}\n\t \n\tif (need_socram && !has_socram) {\n\t\tbrcmf_err(\"RAM core not provided with ARM CM3 core\\n\");\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic u32 brcmf_chip_core_read32(struct brcmf_core_priv *core, u16 reg)\n{\n\treturn core->chip->ops->read32(core->chip->ctx, core->pub.base + reg);\n}\n\nstatic void brcmf_chip_core_write32(struct brcmf_core_priv *core,\n\t\t\t\t    u16 reg, u32 val)\n{\n\tcore->chip->ops->write32(core->chip->ctx, core->pub.base + reg, val);\n}\n\nstatic bool brcmf_chip_socram_banksize(struct brcmf_core_priv *core, u8 idx,\n\t\t\t\t       u32 *banksize)\n{\n\tu32 bankinfo;\n\tu32 bankidx = (SOCRAM_MEMTYPE_RAM << SOCRAM_BANKIDX_MEMTYPE_SHIFT);\n\n\tbankidx |= idx;\n\tbrcmf_chip_core_write32(core, SOCRAMREGOFFS(bankidx), bankidx);\n\tbankinfo = brcmf_chip_core_read32(core, SOCRAMREGOFFS(bankinfo));\n\t*banksize = (bankinfo & SOCRAM_BANKINFO_SZMASK) + 1;\n\t*banksize *= SOCRAM_BANKINFO_SZBASE;\n\treturn !!(bankinfo & SOCRAM_BANKINFO_RETNTRAM_MASK);\n}\n\nstatic void brcmf_chip_socram_ramsize(struct brcmf_core_priv *sr, u32 *ramsize,\n\t\t\t\t      u32 *srsize)\n{\n\tu32 coreinfo;\n\tuint nb, banksize, lss;\n\tbool retent;\n\tint i;\n\n\t*ramsize = 0;\n\t*srsize = 0;\n\n\tif (WARN_ON(sr->pub.rev < 4))\n\t\treturn;\n\n\tif (!brcmf_chip_iscoreup(&sr->pub))\n\t\tbrcmf_chip_resetcore(&sr->pub, 0, 0, 0);\n\n\t \n\tcoreinfo = brcmf_chip_core_read32(sr, SOCRAMREGOFFS(coreinfo));\n\tnb = (coreinfo & SRCI_SRNB_MASK) >> SRCI_SRNB_SHIFT;\n\n\tif ((sr->pub.rev <= 7) || (sr->pub.rev == 12)) {\n\t\tbanksize = (coreinfo & SRCI_SRBSZ_MASK);\n\t\tlss = (coreinfo & SRCI_LSS_MASK) >> SRCI_LSS_SHIFT;\n\t\tif (lss != 0)\n\t\t\tnb--;\n\t\t*ramsize = nb * (1 << (banksize + SR_BSZ_BASE));\n\t\tif (lss != 0)\n\t\t\t*ramsize += (1 << ((lss - 1) + SR_BSZ_BASE));\n\t} else {\n\t\t \n\t\tif (sr->pub.rev >= 23) {\n\t\t\tnb = (coreinfo & (SRCI_SRNB_MASK | SRCI_SRNB_MASK_EXT))\n\t\t\t\t>> SRCI_SRNB_SHIFT;\n\t\t} else {\n\t\t\tnb = (coreinfo & SRCI_SRNB_MASK) >> SRCI_SRNB_SHIFT;\n\t\t}\n\t\tfor (i = 0; i < nb; i++) {\n\t\t\tretent = brcmf_chip_socram_banksize(sr, i, &banksize);\n\t\t\t*ramsize += banksize;\n\t\t\tif (retent)\n\t\t\t\t*srsize += banksize;\n\t\t}\n\t}\n\n\t \n\tswitch (sr->chip->pub.chip) {\n\tcase BRCM_CC_4334_CHIP_ID:\n\t\tif (sr->chip->pub.chiprev < 2)\n\t\t\t*srsize = (32 * 1024);\n\t\tbreak;\n\tcase BRCM_CC_43430_CHIP_ID:\n\tcase CY_CC_43439_CHIP_ID:\n\t\t \n\t\t*srsize = (64 * 1024);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic u32 brcmf_chip_sysmem_ramsize(struct brcmf_core_priv *sysmem)\n{\n\tu32 memsize = 0;\n\tu32 coreinfo;\n\tu32 idx;\n\tu32 nb;\n\tu32 banksize;\n\n\tif (!brcmf_chip_iscoreup(&sysmem->pub))\n\t\tbrcmf_chip_resetcore(&sysmem->pub, 0, 0, 0);\n\n\tcoreinfo = brcmf_chip_core_read32(sysmem, SYSMEMREGOFFS(coreinfo));\n\tnb = (coreinfo & SRCI_SRNB_MASK) >> SRCI_SRNB_SHIFT;\n\n\tfor (idx = 0; idx < nb; idx++) {\n\t\tbrcmf_chip_socram_banksize(sysmem, idx, &banksize);\n\t\tmemsize += banksize;\n\t}\n\n\treturn memsize;\n}\n\n \nstatic u32 brcmf_chip_tcm_ramsize(struct brcmf_core_priv *cr4)\n{\n\tu32 corecap;\n\tu32 memsize = 0;\n\tu32 nab;\n\tu32 nbb;\n\tu32 totb;\n\tu32 bxinfo;\n\tu32 blksize;\n\tu32 idx;\n\n\tcorecap = brcmf_chip_core_read32(cr4, ARMCR4_CAP);\n\n\tnab = (corecap & ARMCR4_TCBANB_MASK) >> ARMCR4_TCBANB_SHIFT;\n\tnbb = (corecap & ARMCR4_TCBBNB_MASK) >> ARMCR4_TCBBNB_SHIFT;\n\ttotb = nab + nbb;\n\n\tfor (idx = 0; idx < totb; idx++) {\n\t\tbrcmf_chip_core_write32(cr4, ARMCR4_BANKIDX, idx);\n\t\tbxinfo = brcmf_chip_core_read32(cr4, ARMCR4_BANKINFO);\n\t\tblksize = ARMCR4_BSZ_MULT;\n\t\tif (bxinfo & ARMCR4_BLK_1K_MASK)\n\t\t\tblksize >>= 3;\n\n\t\tmemsize += ((bxinfo & ARMCR4_BSZ_MASK) + 1) * blksize;\n\t}\n\n\treturn memsize;\n}\n\nstatic u32 brcmf_chip_tcm_rambase(struct brcmf_chip_priv *ci)\n{\n\tswitch (ci->pub.chip) {\n\tcase BRCM_CC_4345_CHIP_ID:\n\tcase BRCM_CC_43454_CHIP_ID:\n\t\treturn 0x198000;\n\tcase BRCM_CC_4335_CHIP_ID:\n\tcase BRCM_CC_4339_CHIP_ID:\n\tcase BRCM_CC_4350_CHIP_ID:\n\tcase BRCM_CC_4354_CHIP_ID:\n\tcase BRCM_CC_4356_CHIP_ID:\n\tcase BRCM_CC_43567_CHIP_ID:\n\tcase BRCM_CC_43569_CHIP_ID:\n\tcase BRCM_CC_43570_CHIP_ID:\n\tcase BRCM_CC_4358_CHIP_ID:\n\tcase BRCM_CC_43602_CHIP_ID:\n\tcase BRCM_CC_4371_CHIP_ID:\n\t\treturn 0x180000;\n\tcase BRCM_CC_43465_CHIP_ID:\n\tcase BRCM_CC_43525_CHIP_ID:\n\tcase BRCM_CC_4365_CHIP_ID:\n\tcase BRCM_CC_4366_CHIP_ID:\n\tcase BRCM_CC_43664_CHIP_ID:\n\tcase BRCM_CC_43666_CHIP_ID:\n\t\treturn 0x200000;\n\tcase BRCM_CC_4355_CHIP_ID:\n\tcase BRCM_CC_4359_CHIP_ID:\n\t\treturn (ci->pub.chiprev < 9) ? 0x180000 : 0x160000;\n\tcase BRCM_CC_4364_CHIP_ID:\n\tcase CY_CC_4373_CHIP_ID:\n\t\treturn 0x160000;\n\tcase CY_CC_43752_CHIP_ID:\n\tcase BRCM_CC_4377_CHIP_ID:\n\t\treturn 0x170000;\n\tcase BRCM_CC_4378_CHIP_ID:\n\t\treturn 0x352000;\n\tcase BRCM_CC_4387_CHIP_ID:\n\t\treturn 0x740000;\n\tdefault:\n\t\tbrcmf_err(\"unknown chip: %s\\n\", ci->pub.name);\n\t\tbreak;\n\t}\n\treturn INVALID_RAMBASE;\n}\n\nint brcmf_chip_get_raminfo(struct brcmf_chip *pub)\n{\n\tstruct brcmf_chip_priv *ci = container_of(pub, struct brcmf_chip_priv,\n\t\t\t\t\t\t  pub);\n\tstruct brcmf_core_priv *mem_core;\n\tstruct brcmf_core *mem;\n\n\tmem = brcmf_chip_get_core(&ci->pub, BCMA_CORE_ARM_CR4);\n\tif (mem) {\n\t\tmem_core = container_of(mem, struct brcmf_core_priv, pub);\n\t\tci->pub.ramsize = brcmf_chip_tcm_ramsize(mem_core);\n\t\tci->pub.rambase = brcmf_chip_tcm_rambase(ci);\n\t\tif (ci->pub.rambase == INVALID_RAMBASE) {\n\t\t\tbrcmf_err(\"RAM base not provided with ARM CR4 core\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tmem = brcmf_chip_get_core(&ci->pub, BCMA_CORE_SYS_MEM);\n\t\tif (mem) {\n\t\t\tmem_core = container_of(mem, struct brcmf_core_priv,\n\t\t\t\t\t\tpub);\n\t\t\tci->pub.ramsize = brcmf_chip_sysmem_ramsize(mem_core);\n\t\t\tci->pub.rambase = brcmf_chip_tcm_rambase(ci);\n\t\t\tif (ci->pub.rambase == INVALID_RAMBASE) {\n\t\t\t\tbrcmf_err(\"RAM base not provided with ARM CA7 core\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tmem = brcmf_chip_get_core(&ci->pub,\n\t\t\t\t\t\t  BCMA_CORE_INTERNAL_MEM);\n\t\t\tif (!mem) {\n\t\t\t\tbrcmf_err(\"No memory cores found\\n\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tmem_core = container_of(mem, struct brcmf_core_priv,\n\t\t\t\t\t\tpub);\n\t\t\tbrcmf_chip_socram_ramsize(mem_core, &ci->pub.ramsize,\n\t\t\t\t\t\t  &ci->pub.srsize);\n\t\t}\n\t}\n\tbrcmf_dbg(INFO, \"RAM: base=0x%x size=%d (0x%x) sr=%d (0x%x)\\n\",\n\t\t  ci->pub.rambase, ci->pub.ramsize, ci->pub.ramsize,\n\t\t  ci->pub.srsize, ci->pub.srsize);\n\n\tif (!ci->pub.ramsize) {\n\t\tbrcmf_err(\"RAM size is undetermined\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (ci->pub.ramsize > BRCMF_CHIP_MAX_MEMSIZE) {\n\t\tbrcmf_err(\"RAM size is incorrect\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 brcmf_chip_dmp_get_desc(struct brcmf_chip_priv *ci, u32 *eromaddr,\n\t\t\t\t   u8 *type)\n{\n\tu32 val;\n\n\t \n\tval = ci->ops->read32(ci->ctx, *eromaddr);\n\t*eromaddr += 4;\n\n\tif (!type)\n\t\treturn val;\n\n\t \n\t*type = (val & DMP_DESC_TYPE_MSK);\n\tif ((*type & ~DMP_DESC_ADDRSIZE_GT32) == DMP_DESC_ADDRESS)\n\t\t*type = DMP_DESC_ADDRESS;\n\n\treturn val;\n}\n\nstatic int brcmf_chip_dmp_get_regaddr(struct brcmf_chip_priv *ci, u32 *eromaddr,\n\t\t\t\t      u32 *regbase, u32 *wrapbase)\n{\n\tu8 desc;\n\tu32 val, szdesc;\n\tu8 stype, sztype, wraptype;\n\n\t*regbase = 0;\n\t*wrapbase = 0;\n\n\tval = brcmf_chip_dmp_get_desc(ci, eromaddr, &desc);\n\tif (desc == DMP_DESC_MASTER_PORT) {\n\t\twraptype = DMP_SLAVE_TYPE_MWRAP;\n\t} else if (desc == DMP_DESC_ADDRESS) {\n\t\t \n\t\t*eromaddr -= 4;\n\t\twraptype = DMP_SLAVE_TYPE_SWRAP;\n\t} else {\n\t\t*eromaddr -= 4;\n\t\treturn -EILSEQ;\n\t}\n\n\tdo {\n\t\t \n\t\tdo {\n\t\t\tval = brcmf_chip_dmp_get_desc(ci, eromaddr, &desc);\n\t\t\t \n\t\t\tif (desc == DMP_DESC_EOT) {\n\t\t\t\t*eromaddr -= 4;\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} while (desc != DMP_DESC_ADDRESS &&\n\t\t\t desc != DMP_DESC_COMPONENT);\n\n\t\t \n\t\tif (desc == DMP_DESC_COMPONENT) {\n\t\t\t*eromaddr -= 4;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (val & DMP_DESC_ADDRSIZE_GT32)\n\t\t\tbrcmf_chip_dmp_get_desc(ci, eromaddr, NULL);\n\n\t\tsztype = (val & DMP_SLAVE_SIZE_TYPE) >> DMP_SLAVE_SIZE_TYPE_S;\n\n\t\t \n\t\tif (sztype == DMP_SLAVE_SIZE_DESC) {\n\t\t\tszdesc = brcmf_chip_dmp_get_desc(ci, eromaddr, NULL);\n\t\t\t \n\t\t\tif (szdesc & DMP_DESC_ADDRSIZE_GT32)\n\t\t\t\tbrcmf_chip_dmp_get_desc(ci, eromaddr, NULL);\n\t\t}\n\n\t\t \n\t\tif (sztype != DMP_SLAVE_SIZE_4K &&\n\t\t    sztype != DMP_SLAVE_SIZE_8K)\n\t\t\tcontinue;\n\n\t\tstype = (val & DMP_SLAVE_TYPE) >> DMP_SLAVE_TYPE_S;\n\n\t\t \n\t\tif (*regbase == 0 && stype == DMP_SLAVE_TYPE_SLAVE)\n\t\t\t*regbase = val & DMP_SLAVE_ADDR_BASE;\n\t\tif (*wrapbase == 0 && stype == wraptype)\n\t\t\t*wrapbase = val & DMP_SLAVE_ADDR_BASE;\n\t} while (*regbase == 0 || *wrapbase == 0);\n\n\treturn 0;\n}\n\nstatic\nint brcmf_chip_dmp_erom_scan(struct brcmf_chip_priv *ci)\n{\n\tstruct brcmf_core *core;\n\tu32 eromaddr;\n\tu8 desc_type = 0;\n\tu32 val;\n\tu16 id;\n\tu8 nmw, nsw, rev;\n\tu32 base, wrap;\n\tint err;\n\n\teromaddr = ci->ops->read32(ci->ctx,\n\t\t\t\t   CORE_CC_REG(ci->pub.enum_base, eromptr));\n\n\twhile (desc_type != DMP_DESC_EOT) {\n\t\tval = brcmf_chip_dmp_get_desc(ci, &eromaddr, &desc_type);\n\t\tif (!(val & DMP_DESC_VALID))\n\t\t\tcontinue;\n\n\t\tif (desc_type == DMP_DESC_EMPTY)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (desc_type != DMP_DESC_COMPONENT)\n\t\t\tcontinue;\n\n\t\tid = (val & DMP_COMP_PARTNUM) >> DMP_COMP_PARTNUM_S;\n\n\t\t \n\t\tval = brcmf_chip_dmp_get_desc(ci, &eromaddr, &desc_type);\n\t\tif (WARN_ON((val & DMP_DESC_TYPE_MSK) != DMP_DESC_COMPONENT))\n\t\t\treturn -EFAULT;\n\n\t\t \n\t\tnmw = (val & DMP_COMP_NUM_MWRAP) >> DMP_COMP_NUM_MWRAP_S;\n\t\tnsw = (val & DMP_COMP_NUM_SWRAP) >> DMP_COMP_NUM_SWRAP_S;\n\t\trev = (val & DMP_COMP_REVISION) >> DMP_COMP_REVISION_S;\n\n\t\t \n\t\tif (nmw + nsw == 0 &&\n\t\t    id != BCMA_CORE_PMU &&\n\t\t    id != BCMA_CORE_GCI)\n\t\t\tcontinue;\n\n\t\t \n\t\terr = brcmf_chip_dmp_get_regaddr(ci, &eromaddr, &base, &wrap);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\t \n\t\tcore = brcmf_chip_add_core(ci, id, base, wrap);\n\t\tif (IS_ERR(core))\n\t\t\treturn PTR_ERR(core);\n\n\t\tcore->rev = rev;\n\t}\n\n\treturn 0;\n}\n\nu32 brcmf_chip_enum_base(u16 devid)\n{\n\treturn SI_ENUM_BASE_DEFAULT;\n}\n\nstatic int brcmf_chip_recognition(struct brcmf_chip_priv *ci)\n{\n\tstruct brcmf_core *core;\n\tu32 regdata;\n\tu32 socitype;\n\tint ret;\n\tconst u32 READ_FAILED = 0xFFFFFFFF;\n\n\t \n\tregdata = ci->ops->read32(ci->ctx,\n\t\t\t\t  CORE_CC_REG(ci->pub.enum_base, chipid));\n\tif (regdata == READ_FAILED) {\n\t\tbrcmf_err(\"MMIO read failed: 0x%08x\\n\", regdata);\n\t\treturn -ENODEV;\n\t}\n\n\tci->pub.chip = regdata & CID_ID_MASK;\n\tci->pub.chiprev = (regdata & CID_REV_MASK) >> CID_REV_SHIFT;\n\tsocitype = (regdata & CID_TYPE_MASK) >> CID_TYPE_SHIFT;\n\n\tbrcmf_chip_name(ci->pub.chip, ci->pub.chiprev,\n\t\t\tci->pub.name, sizeof(ci->pub.name));\n\tbrcmf_dbg(INFO, \"found %s chip: %s\\n\",\n\t\t  socitype == SOCI_SB ? \"SB\" : \"AXI\", ci->pub.name);\n\n\tif (socitype == SOCI_SB) {\n\t\tif (ci->pub.chip != BRCM_CC_4329_CHIP_ID) {\n\t\t\tbrcmf_err(\"SB chip is not supported\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tci->iscoreup = brcmf_chip_sb_iscoreup;\n\t\tci->coredisable = brcmf_chip_sb_coredisable;\n\t\tci->resetcore = brcmf_chip_sb_resetcore;\n\n\t\tcore = brcmf_chip_add_core(ci, BCMA_CORE_CHIPCOMMON,\n\t\t\t\t\t   SI_ENUM_BASE_DEFAULT, 0);\n\t\tbrcmf_chip_sb_corerev(ci, core);\n\t\tcore = brcmf_chip_add_core(ci, BCMA_CORE_SDIO_DEV,\n\t\t\t\t\t   BCM4329_CORE_BUS_BASE, 0);\n\t\tbrcmf_chip_sb_corerev(ci, core);\n\t\tcore = brcmf_chip_add_core(ci, BCMA_CORE_INTERNAL_MEM,\n\t\t\t\t\t   BCM4329_CORE_SOCRAM_BASE, 0);\n\t\tbrcmf_chip_sb_corerev(ci, core);\n\t\tcore = brcmf_chip_add_core(ci, BCMA_CORE_ARM_CM3,\n\t\t\t\t\t   BCM4329_CORE_ARM_BASE, 0);\n\t\tbrcmf_chip_sb_corerev(ci, core);\n\n\t\tcore = brcmf_chip_add_core(ci, BCMA_CORE_80211, 0x18001000, 0);\n\t\tbrcmf_chip_sb_corerev(ci, core);\n\t} else if (socitype == SOCI_AI) {\n\t\tci->iscoreup = brcmf_chip_ai_iscoreup;\n\t\tci->coredisable = brcmf_chip_ai_coredisable;\n\t\tci->resetcore = brcmf_chip_ai_resetcore;\n\n\t\tbrcmf_chip_dmp_erom_scan(ci);\n\t} else {\n\t\tbrcmf_err(\"chip backplane type %u is not supported\\n\",\n\t\t\t  socitype);\n\t\treturn -ENODEV;\n\t}\n\n\tret = brcmf_chip_cores_check(ci);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tbrcmf_chip_set_passive(&ci->pub);\n\n\t \n\tif (ci->ops->reset) {\n\t\tci->ops->reset(ci->ctx, &ci->pub);\n\t\tbrcmf_chip_set_passive(&ci->pub);\n\t}\n\n\treturn brcmf_chip_get_raminfo(&ci->pub);\n}\n\nstatic void brcmf_chip_disable_arm(struct brcmf_chip_priv *chip, u16 id)\n{\n\tstruct brcmf_core *core;\n\tstruct brcmf_core_priv *cpu;\n\tu32 val;\n\n\n\tcore = brcmf_chip_get_core(&chip->pub, id);\n\tif (!core)\n\t\treturn;\n\n\tswitch (id) {\n\tcase BCMA_CORE_ARM_CM3:\n\t\tbrcmf_chip_coredisable(core, 0, 0);\n\t\tbreak;\n\tcase BCMA_CORE_ARM_CR4:\n\tcase BCMA_CORE_ARM_CA7:\n\t\tcpu = container_of(core, struct brcmf_core_priv, pub);\n\n\t\t \n\t\tval = chip->ops->read32(chip->ctx, cpu->wrapbase + BCMA_IOCTL);\n\t\tval &= ARMCR4_BCMA_IOCTL_CPUHALT;\n\t\tbrcmf_chip_resetcore(core, val, ARMCR4_BCMA_IOCTL_CPUHALT,\n\t\t\t\t     ARMCR4_BCMA_IOCTL_CPUHALT);\n\t\tbreak;\n\tdefault:\n\t\tbrcmf_err(\"unknown id: %u\\n\", id);\n\t\tbreak;\n\t}\n}\n\nstatic int brcmf_chip_setup(struct brcmf_chip_priv *chip)\n{\n\tstruct brcmf_chip *pub;\n\tstruct brcmf_core_priv *cc;\n\tstruct brcmf_core *pmu;\n\tu32 base;\n\tu32 val;\n\tint ret = 0;\n\n\tpub = &chip->pub;\n\tcc = list_first_entry(&chip->cores, struct brcmf_core_priv, list);\n\tbase = cc->pub.base;\n\n\t \n\tpub->cc_caps = chip->ops->read32(chip->ctx,\n\t\t\t\t\t CORE_CC_REG(base, capabilities));\n\tpub->cc_caps_ext = chip->ops->read32(chip->ctx,\n\t\t\t\t\t     CORE_CC_REG(base,\n\t\t\t\t\t\t\t capabilities_ext));\n\n\t \n\tpmu = brcmf_chip_get_pmu(pub);  \n\tif (pub->cc_caps & CC_CAP_PMU) {\n\t\tval = chip->ops->read32(chip->ctx,\n\t\t\t\t\tCORE_CC_REG(pmu->base, pmucapabilities));\n\t\tpub->pmurev = val & PCAP_REV_MASK;\n\t\tpub->pmucaps = val;\n\t}\n\n\tbrcmf_dbg(INFO, \"ccrev=%d, pmurev=%d, pmucaps=0x%x\\n\",\n\t\t  cc->pub.rev, pub->pmurev, pub->pmucaps);\n\n\t \n\tif (chip->ops->setup)\n\t\tret = chip->ops->setup(chip->ctx, pub);\n\n\treturn ret;\n}\n\nstruct brcmf_chip *brcmf_chip_attach(void *ctx, u16 devid,\n\t\t\t\t     const struct brcmf_buscore_ops *ops)\n{\n\tstruct brcmf_chip_priv *chip;\n\tint err = 0;\n\n\tif (WARN_ON(!ops->read32))\n\t\terr = -EINVAL;\n\tif (WARN_ON(!ops->write32))\n\t\terr = -EINVAL;\n\tif (WARN_ON(!ops->prepare))\n\t\terr = -EINVAL;\n\tif (WARN_ON(!ops->activate))\n\t\terr = -EINVAL;\n\tif (err < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tchip = kzalloc(sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&chip->cores);\n\tchip->num_cores = 0;\n\tchip->ops = ops;\n\tchip->ctx = ctx;\n\tchip->pub.enum_base = brcmf_chip_enum_base(devid);\n\n\terr = ops->prepare(ctx);\n\tif (err < 0)\n\t\tgoto fail;\n\n\terr = brcmf_chip_recognition(chip);\n\tif (err < 0)\n\t\tgoto fail;\n\n\terr = brcmf_chip_setup(chip);\n\tif (err < 0)\n\t\tgoto fail;\n\n\treturn &chip->pub;\n\nfail:\n\tbrcmf_chip_detach(&chip->pub);\n\treturn ERR_PTR(err);\n}\n\nvoid brcmf_chip_detach(struct brcmf_chip *pub)\n{\n\tstruct brcmf_chip_priv *chip;\n\tstruct brcmf_core_priv *core;\n\tstruct brcmf_core_priv *tmp;\n\n\tchip = container_of(pub, struct brcmf_chip_priv, pub);\n\tlist_for_each_entry_safe(core, tmp, &chip->cores, list) {\n\t\tlist_del(&core->list);\n\t\tkfree(core);\n\t}\n\tkfree(chip);\n}\n\nstruct brcmf_core *brcmf_chip_get_d11core(struct brcmf_chip *pub, u8 unit)\n{\n\tstruct brcmf_chip_priv *chip;\n\tstruct brcmf_core_priv *core;\n\n\tchip = container_of(pub, struct brcmf_chip_priv, pub);\n\tlist_for_each_entry(core, &chip->cores, list) {\n\t\tif (core->pub.id == BCMA_CORE_80211) {\n\t\t\tif (unit-- == 0)\n\t\t\t\treturn &core->pub;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstruct brcmf_core *brcmf_chip_get_core(struct brcmf_chip *pub, u16 coreid)\n{\n\tstruct brcmf_chip_priv *chip;\n\tstruct brcmf_core_priv *core;\n\n\tchip = container_of(pub, struct brcmf_chip_priv, pub);\n\tlist_for_each_entry(core, &chip->cores, list)\n\t\tif (core->pub.id == coreid)\n\t\t\treturn &core->pub;\n\n\treturn NULL;\n}\n\nstruct brcmf_core *brcmf_chip_get_chipcommon(struct brcmf_chip *pub)\n{\n\tstruct brcmf_chip_priv *chip;\n\tstruct brcmf_core_priv *cc;\n\n\tchip = container_of(pub, struct brcmf_chip_priv, pub);\n\tcc = list_first_entry(&chip->cores, struct brcmf_core_priv, list);\n\tif (WARN_ON(!cc || cc->pub.id != BCMA_CORE_CHIPCOMMON))\n\t\treturn brcmf_chip_get_core(pub, BCMA_CORE_CHIPCOMMON);\n\treturn &cc->pub;\n}\n\nstruct brcmf_core *brcmf_chip_get_pmu(struct brcmf_chip *pub)\n{\n\tstruct brcmf_core *cc = brcmf_chip_get_chipcommon(pub);\n\tstruct brcmf_core *pmu;\n\n\t \n\tif (cc->rev >= 35 &&\n\t    pub->cc_caps_ext & BCMA_CC_CAP_EXT_AOB_PRESENT) {\n\t\tpmu = brcmf_chip_get_core(pub, BCMA_CORE_PMU);\n\t\tif (pmu)\n\t\t\treturn pmu;\n\t}\n\n\t \n\treturn cc;\n}\n\nbool brcmf_chip_iscoreup(struct brcmf_core *pub)\n{\n\tstruct brcmf_core_priv *core;\n\n\tcore = container_of(pub, struct brcmf_core_priv, pub);\n\treturn core->chip->iscoreup(core);\n}\n\nvoid brcmf_chip_coredisable(struct brcmf_core *pub, u32 prereset, u32 reset)\n{\n\tstruct brcmf_core_priv *core;\n\n\tcore = container_of(pub, struct brcmf_core_priv, pub);\n\tcore->chip->coredisable(core, prereset, reset);\n}\n\nvoid brcmf_chip_resetcore(struct brcmf_core *pub, u32 prereset, u32 reset,\n\t\t\t  u32 postreset)\n{\n\tstruct brcmf_core_priv *core;\n\n\tcore = container_of(pub, struct brcmf_core_priv, pub);\n\tcore->chip->resetcore(core, prereset, reset, postreset);\n}\n\nstatic void\nbrcmf_chip_cm3_set_passive(struct brcmf_chip_priv *chip)\n{\n\tstruct brcmf_core *core;\n\tstruct brcmf_core_priv *sr;\n\n\tbrcmf_chip_disable_arm(chip, BCMA_CORE_ARM_CM3);\n\tcore = brcmf_chip_get_core(&chip->pub, BCMA_CORE_80211);\n\tbrcmf_chip_resetcore(core, D11_BCMA_IOCTL_PHYRESET |\n\t\t\t\t   D11_BCMA_IOCTL_PHYCLOCKEN,\n\t\t\t     D11_BCMA_IOCTL_PHYCLOCKEN,\n\t\t\t     D11_BCMA_IOCTL_PHYCLOCKEN);\n\tcore = brcmf_chip_get_core(&chip->pub, BCMA_CORE_INTERNAL_MEM);\n\tbrcmf_chip_resetcore(core, 0, 0, 0);\n\n\t \n\tif (chip->pub.chip == BRCM_CC_43430_CHIP_ID ||\n\t    chip->pub.chip == CY_CC_43439_CHIP_ID) {\n\t\tsr = container_of(core, struct brcmf_core_priv, pub);\n\t\tbrcmf_chip_core_write32(sr, SOCRAMREGOFFS(bankidx), 3);\n\t\tbrcmf_chip_core_write32(sr, SOCRAMREGOFFS(bankpda), 0);\n\t}\n}\n\nstatic bool brcmf_chip_cm3_set_active(struct brcmf_chip_priv *chip)\n{\n\tstruct brcmf_core *core;\n\n\tcore = brcmf_chip_get_core(&chip->pub, BCMA_CORE_INTERNAL_MEM);\n\tif (!brcmf_chip_iscoreup(core)) {\n\t\tbrcmf_err(\"SOCRAM core is down after reset?\\n\");\n\t\treturn false;\n\t}\n\n\tchip->ops->activate(chip->ctx, &chip->pub, 0);\n\n\tcore = brcmf_chip_get_core(&chip->pub, BCMA_CORE_ARM_CM3);\n\tbrcmf_chip_resetcore(core, 0, 0, 0);\n\n\treturn true;\n}\n\nstatic inline void\nbrcmf_chip_cr4_set_passive(struct brcmf_chip_priv *chip)\n{\n\tint i;\n\tstruct brcmf_core *core;\n\n\tbrcmf_chip_disable_arm(chip, BCMA_CORE_ARM_CR4);\n\n\t \n\tfor (i = 0; (core = brcmf_chip_get_d11core(&chip->pub, i)); i++)\n\t\tbrcmf_chip_coredisable(core, D11_BCMA_IOCTL_PHYRESET |\n\t\t\t\t       D11_BCMA_IOCTL_PHYCLOCKEN,\n\t\t\t\t       D11_BCMA_IOCTL_PHYCLOCKEN);\n}\n\nstatic bool brcmf_chip_cr4_set_active(struct brcmf_chip_priv *chip, u32 rstvec)\n{\n\tstruct brcmf_core *core;\n\n\tchip->ops->activate(chip->ctx, &chip->pub, rstvec);\n\n\t \n\tcore = brcmf_chip_get_core(&chip->pub, BCMA_CORE_ARM_CR4);\n\tbrcmf_chip_resetcore(core, ARMCR4_BCMA_IOCTL_CPUHALT, 0, 0);\n\n\treturn true;\n}\n\nstatic inline void\nbrcmf_chip_ca7_set_passive(struct brcmf_chip_priv *chip)\n{\n\tstruct brcmf_core *core;\n\n\tbrcmf_chip_disable_arm(chip, BCMA_CORE_ARM_CA7);\n\n\tcore = brcmf_chip_get_core(&chip->pub, BCMA_CORE_80211);\n\tbrcmf_chip_resetcore(core, D11_BCMA_IOCTL_PHYRESET |\n\t\t\t\t   D11_BCMA_IOCTL_PHYCLOCKEN,\n\t\t\t     D11_BCMA_IOCTL_PHYCLOCKEN,\n\t\t\t     D11_BCMA_IOCTL_PHYCLOCKEN);\n}\n\nstatic bool brcmf_chip_ca7_set_active(struct brcmf_chip_priv *chip, u32 rstvec)\n{\n\tstruct brcmf_core *core;\n\n\tchip->ops->activate(chip->ctx, &chip->pub, rstvec);\n\n\t \n\tcore = brcmf_chip_get_core(&chip->pub, BCMA_CORE_ARM_CA7);\n\tbrcmf_chip_resetcore(core, ARMCR4_BCMA_IOCTL_CPUHALT, 0, 0);\n\n\treturn true;\n}\n\nvoid brcmf_chip_set_passive(struct brcmf_chip *pub)\n{\n\tstruct brcmf_chip_priv *chip;\n\tstruct brcmf_core *arm;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tchip = container_of(pub, struct brcmf_chip_priv, pub);\n\tarm = brcmf_chip_get_core(pub, BCMA_CORE_ARM_CR4);\n\tif (arm) {\n\t\tbrcmf_chip_cr4_set_passive(chip);\n\t\treturn;\n\t}\n\tarm = brcmf_chip_get_core(pub, BCMA_CORE_ARM_CA7);\n\tif (arm) {\n\t\tbrcmf_chip_ca7_set_passive(chip);\n\t\treturn;\n\t}\n\tarm = brcmf_chip_get_core(pub, BCMA_CORE_ARM_CM3);\n\tif (arm) {\n\t\tbrcmf_chip_cm3_set_passive(chip);\n\t\treturn;\n\t}\n}\n\nbool brcmf_chip_set_active(struct brcmf_chip *pub, u32 rstvec)\n{\n\tstruct brcmf_chip_priv *chip;\n\tstruct brcmf_core *arm;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tchip = container_of(pub, struct brcmf_chip_priv, pub);\n\tarm = brcmf_chip_get_core(pub, BCMA_CORE_ARM_CR4);\n\tif (arm)\n\t\treturn brcmf_chip_cr4_set_active(chip, rstvec);\n\tarm = brcmf_chip_get_core(pub, BCMA_CORE_ARM_CA7);\n\tif (arm)\n\t\treturn brcmf_chip_ca7_set_active(chip, rstvec);\n\tarm = brcmf_chip_get_core(pub, BCMA_CORE_ARM_CM3);\n\tif (arm)\n\t\treturn brcmf_chip_cm3_set_active(chip);\n\n\treturn false;\n}\n\nbool brcmf_chip_sr_capable(struct brcmf_chip *pub)\n{\n\tu32 base, addr, reg, pmu_cc3_mask = ~0;\n\tstruct brcmf_chip_priv *chip;\n\tstruct brcmf_core *pmu = brcmf_chip_get_pmu(pub);\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\t \n\tif (pub->pmurev < 17)\n\t\treturn false;\n\n\tbase = brcmf_chip_get_chipcommon(pub)->base;\n\tchip = container_of(pub, struct brcmf_chip_priv, pub);\n\n\tswitch (pub->chip) {\n\tcase BRCM_CC_4354_CHIP_ID:\n\tcase BRCM_CC_4356_CHIP_ID:\n\tcase BRCM_CC_4345_CHIP_ID:\n\tcase BRCM_CC_43454_CHIP_ID:\n\t\t \n\t\tpmu_cc3_mask = BIT(2);\n\t\tfallthrough;\n\tcase BRCM_CC_43241_CHIP_ID:\n\tcase BRCM_CC_4335_CHIP_ID:\n\tcase BRCM_CC_4339_CHIP_ID:\n\t\t \n\t\taddr = CORE_CC_REG(pmu->base, chipcontrol_addr);\n\t\tchip->ops->write32(chip->ctx, addr, 3);\n\t\taddr = CORE_CC_REG(pmu->base, chipcontrol_data);\n\t\treg = chip->ops->read32(chip->ctx, addr);\n\t\treturn (reg & pmu_cc3_mask) != 0;\n\tcase BRCM_CC_43430_CHIP_ID:\n\tcase CY_CC_43439_CHIP_ID:\n\t\taddr = CORE_CC_REG(base, sr_control1);\n\t\treg = chip->ops->read32(chip->ctx, addr);\n\t\treturn reg != 0;\n\tcase BRCM_CC_4355_CHIP_ID:\n\tcase CY_CC_4373_CHIP_ID:\n\t\t \n\t\taddr = CORE_CC_REG(base, sr_control0);\n\t\treg = chip->ops->read32(chip->ctx, addr);\n\t\treturn (reg & CC_SR_CTL0_ENABLE_MASK) != 0;\n\tcase BRCM_CC_4359_CHIP_ID:\n\tcase CY_CC_43752_CHIP_ID:\n\tcase CY_CC_43012_CHIP_ID:\n\t\taddr = CORE_CC_REG(pmu->base, retention_ctl);\n\t\treg = chip->ops->read32(chip->ctx, addr);\n\t\treturn (reg & (PMU_RCTL_MACPHY_DISABLE_MASK |\n\t\t\t       PMU_RCTL_LOGIC_DISABLE_MASK)) == 0;\n\tdefault:\n\t\taddr = CORE_CC_REG(pmu->base, pmucapabilities_ext);\n\t\treg = chip->ops->read32(chip->ctx, addr);\n\t\tif ((reg & PCAPEXT_SR_SUPPORTED_MASK) == 0)\n\t\t\treturn false;\n\n\t\taddr = CORE_CC_REG(pmu->base, retention_ctl);\n\t\treg = chip->ops->read32(chip->ctx, addr);\n\t\treturn (reg & (PMU_RCTL_MACPHY_DISABLE_MASK |\n\t\t\t       PMU_RCTL_LOGIC_DISABLE_MASK)) == 0;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}