{
  "module_name": "usb.c",
  "hash_id": "5e903532c2fa1bb2ee63d610585586da0c3eb93ac79e3f481690f78d436317a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/firmware.h>\n#include <linux/usb.h>\n#include <linux/vmalloc.h>\n\n#include <brcmu_utils.h>\n#include <brcm_hw_ids.h>\n#include <brcmu_wifi.h>\n#include \"bus.h\"\n#include \"debug.h\"\n#include \"firmware.h\"\n#include \"usb.h\"\n#include \"core.h\"\n#include \"common.h\"\n#include \"bcdc.h\"\n\n\n#define IOCTL_RESP_TIMEOUT\t\tmsecs_to_jiffies(2000)\n\n#define BRCMF_USB_RESET_GETVER_SPINWAIT\t100\t \n#define BRCMF_USB_RESET_GETVER_LOOP_CNT\t10\n\n#define BRCMF_POSTBOOT_ID\t\t0xA123   \n#define BRCMF_USB_NRXQ\t\t\t50\n#define BRCMF_USB_NTXQ\t\t\t50\n\n#define BRCMF_USB_CBCTL_WRITE\t\t0\n#define BRCMF_USB_CBCTL_READ\t\t1\n#define BRCMF_USB_MAX_PKT_SIZE\t\t1600\n\nBRCMF_FW_DEF(43143, \"brcmfmac43143\");\nBRCMF_FW_DEF(43236B, \"brcmfmac43236b\");\nBRCMF_FW_DEF(43242A, \"brcmfmac43242a\");\nBRCMF_FW_DEF(43569, \"brcmfmac43569\");\nBRCMF_FW_DEF(4373, \"brcmfmac4373\");\n\nstatic const struct brcmf_firmware_mapping brcmf_usb_fwnames[] = {\n\tBRCMF_FW_ENTRY(BRCM_CC_43143_CHIP_ID, 0xFFFFFFFF, 43143),\n\tBRCMF_FW_ENTRY(BRCM_CC_43235_CHIP_ID, 0x00000008, 43236B),\n\tBRCMF_FW_ENTRY(BRCM_CC_43236_CHIP_ID, 0x00000008, 43236B),\n\tBRCMF_FW_ENTRY(BRCM_CC_43238_CHIP_ID, 0x00000008, 43236B),\n\tBRCMF_FW_ENTRY(BRCM_CC_43242_CHIP_ID, 0xFFFFFFFF, 43242A),\n\tBRCMF_FW_ENTRY(BRCM_CC_43566_CHIP_ID, 0xFFFFFFFF, 43569),\n\tBRCMF_FW_ENTRY(BRCM_CC_43569_CHIP_ID, 0xFFFFFFFF, 43569),\n\tBRCMF_FW_ENTRY(CY_CC_4373_CHIP_ID, 0xFFFFFFFF, 4373)\n};\n\n#define TRX_MAGIC\t\t0x30524448\t \n#define TRX_MAX_OFFSET\t\t3\t\t \n#define TRX_UNCOMP_IMAGE\t0x20\t\t \n#define TRX_RDL_CHUNK\t\t1500\t\t \n#define TRX_OFFSETS_DLFWLEN_IDX\t0\n\n \n#define DL_GETSTATE\t0\t \n#define DL_CHECK_CRC\t1\t \n#define DL_GO\t\t2\t \n#define DL_START\t3\t \n#define DL_REBOOT\t4\t \n#define DL_GETVER\t5\t \n#define DL_GO_PROTECTED\t6\t \n#define DL_EXEC\t\t7\t \n#define DL_RESETCFG\t8\t \n#define DL_DEFER_RESP_OK 9\t \n\n \n#define DL_WAITING\t0\t \n#define DL_READY\t1\t \n#define DL_BAD_HDR\t2\t \n#define DL_BAD_CRC\t3\t \n#define DL_RUNNABLE\t4\t \n#define DL_START_FAIL\t5\t \n#define DL_NVRAM_TOOBIG\t6\t \n#define DL_IMAGE_TOOBIG\t7\t \n\n\nstruct trx_header_le {\n\t__le32 magic;\t\t \n\t__le32 len;\t\t \n\t__le32 crc32;\t\t \n\t__le32 flag_version;\t \n\t__le32 offsets[TRX_MAX_OFFSET];\t \n};\n\nstruct rdl_state_le {\n\t__le32 state;\n\t__le32 bytes;\n};\n\nstruct bootrom_id_le {\n\t__le32 chip;\t\t \n\t__le32 chiprev;\t\t \n\t__le32 ramsize;\t\t \n\t__le32 remapbase;\t \n\t__le32 boardtype;\t \n\t__le32 boardrev;\t \n};\n\nstruct brcmf_usb_image {\n\tstruct list_head list;\n\ts8 *fwname;\n\tu8 *image;\n\tint image_len;\n};\n\nstruct brcmf_usbdev_info {\n\tstruct brcmf_usbdev bus_pub;  \n\tspinlock_t qlock;\n\tstruct list_head rx_freeq;\n\tstruct list_head rx_postq;\n\tstruct list_head tx_freeq;\n\tstruct list_head tx_postq;\n\tuint rx_pipe, tx_pipe;\n\n\tint rx_low_watermark;\n\tint tx_low_watermark;\n\tint tx_high_watermark;\n\tint tx_freecount;\n\tbool tx_flowblock;\n\tspinlock_t tx_flowblock_lock;\n\n\tstruct brcmf_usbreq *tx_reqs;\n\tstruct brcmf_usbreq *rx_reqs;\n\n\tchar fw_name[BRCMF_FW_NAME_LEN];\n\tconst u8 *image;\t \n\tint image_len;\n\n\tstruct usb_device *usbdev;\n\tstruct device *dev;\n\tstruct completion dev_init_done;\n\n\tint ctl_in_pipe, ctl_out_pipe;\n\tstruct urb *ctl_urb;  \n\tstruct usb_ctrlrequest ctl_write;\n\tstruct usb_ctrlrequest ctl_read;\n\tu32 ctl_urb_actual_length;\n\tint ctl_urb_status;\n\tint ctl_completed;\n\twait_queue_head_t ioctl_resp_wait;\n\tulong ctl_op;\n\tu8 ifnum;\n\n\tstruct urb *bulk_urb;  \n\n\tstruct brcmf_mp_device *settings;\n};\n\nstatic void brcmf_usb_rx_refill(struct brcmf_usbdev_info *devinfo,\n\t\t\t\tstruct brcmf_usbreq  *req);\n\nstatic struct brcmf_usbdev *brcmf_usb_get_buspub(struct device *dev)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\treturn bus_if->bus_priv.usb;\n}\n\nstatic struct brcmf_usbdev_info *brcmf_usb_get_businfo(struct device *dev)\n{\n\treturn brcmf_usb_get_buspub(dev)->devinfo;\n}\n\nstatic int brcmf_usb_ioctl_resp_wait(struct brcmf_usbdev_info *devinfo)\n{\n\treturn wait_event_timeout(devinfo->ioctl_resp_wait,\n\t\t\t\t  devinfo->ctl_completed, IOCTL_RESP_TIMEOUT);\n}\n\nstatic void brcmf_usb_ioctl_resp_wake(struct brcmf_usbdev_info *devinfo)\n{\n\twake_up(&devinfo->ioctl_resp_wait);\n}\n\nstatic void\nbrcmf_usb_ctl_complete(struct brcmf_usbdev_info *devinfo, int type, int status)\n{\n\tbrcmf_dbg(USB, \"Enter, status=%d\\n\", status);\n\n\tif (unlikely(devinfo == NULL))\n\t\treturn;\n\n\tif (type == BRCMF_USB_CBCTL_READ) {\n\t\tif (status == 0)\n\t\t\tdevinfo->bus_pub.stats.rx_ctlpkts++;\n\t\telse\n\t\t\tdevinfo->bus_pub.stats.rx_ctlerrs++;\n\t} else if (type == BRCMF_USB_CBCTL_WRITE) {\n\t\tif (status == 0)\n\t\t\tdevinfo->bus_pub.stats.tx_ctlpkts++;\n\t\telse\n\t\t\tdevinfo->bus_pub.stats.tx_ctlerrs++;\n\t}\n\n\tdevinfo->ctl_urb_status = status;\n\tdevinfo->ctl_completed = true;\n\tbrcmf_usb_ioctl_resp_wake(devinfo);\n}\n\nstatic void\nbrcmf_usb_ctlread_complete(struct urb *urb)\n{\n\tstruct brcmf_usbdev_info *devinfo =\n\t\t(struct brcmf_usbdev_info *)urb->context;\n\n\tbrcmf_dbg(USB, \"Enter\\n\");\n\tdevinfo->ctl_urb_actual_length = urb->actual_length;\n\tbrcmf_usb_ctl_complete(devinfo, BRCMF_USB_CBCTL_READ,\n\t\turb->status);\n}\n\nstatic void\nbrcmf_usb_ctlwrite_complete(struct urb *urb)\n{\n\tstruct brcmf_usbdev_info *devinfo =\n\t\t(struct brcmf_usbdev_info *)urb->context;\n\n\tbrcmf_dbg(USB, \"Enter\\n\");\n\tbrcmf_usb_ctl_complete(devinfo, BRCMF_USB_CBCTL_WRITE,\n\t\turb->status);\n}\n\nstatic int\nbrcmf_usb_send_ctl(struct brcmf_usbdev_info *devinfo, u8 *buf, int len)\n{\n\tint ret;\n\tu16 size;\n\n\tbrcmf_dbg(USB, \"Enter\\n\");\n\tif (devinfo == NULL || buf == NULL ||\n\t    len == 0 || devinfo->ctl_urb == NULL)\n\t\treturn -EINVAL;\n\n\tsize = len;\n\tdevinfo->ctl_write.wLength = cpu_to_le16p(&size);\n\tdevinfo->ctl_urb->transfer_buffer_length = size;\n\tdevinfo->ctl_urb_status = 0;\n\tdevinfo->ctl_urb_actual_length = 0;\n\n\tusb_fill_control_urb(devinfo->ctl_urb,\n\t\tdevinfo->usbdev,\n\t\tdevinfo->ctl_out_pipe,\n\t\t(unsigned char *) &devinfo->ctl_write,\n\t\tbuf, size,\n\t\t(usb_complete_t)brcmf_usb_ctlwrite_complete,\n\t\tdevinfo);\n\n\tret = usb_submit_urb(devinfo->ctl_urb, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tbrcmf_err(\"usb_submit_urb failed %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int\nbrcmf_usb_recv_ctl(struct brcmf_usbdev_info *devinfo, u8 *buf, int len)\n{\n\tint ret;\n\tu16 size;\n\n\tbrcmf_dbg(USB, \"Enter\\n\");\n\tif ((devinfo == NULL) || (buf == NULL) || (len == 0)\n\t\t|| (devinfo->ctl_urb == NULL))\n\t\treturn -EINVAL;\n\n\tsize = len;\n\tdevinfo->ctl_read.wLength = cpu_to_le16p(&size);\n\tdevinfo->ctl_urb->transfer_buffer_length = size;\n\n\tdevinfo->ctl_read.bRequestType = USB_DIR_IN\n\t\t| USB_TYPE_CLASS | USB_RECIP_INTERFACE;\n\tdevinfo->ctl_read.bRequest = 1;\n\n\tusb_fill_control_urb(devinfo->ctl_urb,\n\t\tdevinfo->usbdev,\n\t\tdevinfo->ctl_in_pipe,\n\t\t(unsigned char *) &devinfo->ctl_read,\n\t\tbuf, size,\n\t\t(usb_complete_t)brcmf_usb_ctlread_complete,\n\t\tdevinfo);\n\n\tret = usb_submit_urb(devinfo->ctl_urb, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tbrcmf_err(\"usb_submit_urb failed %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int brcmf_usb_tx_ctlpkt(struct device *dev, u8 *buf, u32 len)\n{\n\tint err = 0;\n\tint timeout = 0;\n\tstruct brcmf_usbdev_info *devinfo = brcmf_usb_get_businfo(dev);\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\n\tbrcmf_dbg(USB, \"Enter\\n\");\n\n\terr = usb_autopm_get_interface(intf);\n\tif (err)\n\t\tgoto out;\n\n\tif (devinfo->bus_pub.state != BRCMFMAC_USB_STATE_UP) {\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tif (test_and_set_bit(0, &devinfo->ctl_op)) {\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tdevinfo->ctl_completed = false;\n\terr = brcmf_usb_send_ctl(devinfo, buf, len);\n\tif (err) {\n\t\tbrcmf_err(\"fail %d bytes: %d\\n\", err, len);\n\t\tclear_bit(0, &devinfo->ctl_op);\n\t\tgoto fail;\n\t}\n\ttimeout = brcmf_usb_ioctl_resp_wait(devinfo);\n\tif (!timeout) {\n\t\tbrcmf_err(\"Txctl wait timed out\\n\");\n\t\tusb_kill_urb(devinfo->ctl_urb);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\tclear_bit(0, &devinfo->ctl_op);\n\nfail:\n\tusb_autopm_put_interface(intf);\nout:\n\treturn err;\n}\n\nstatic int brcmf_usb_rx_ctlpkt(struct device *dev, u8 *buf, u32 len)\n{\n\tint err = 0;\n\tint timeout = 0;\n\tstruct brcmf_usbdev_info *devinfo = brcmf_usb_get_businfo(dev);\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\n\tbrcmf_dbg(USB, \"Enter\\n\");\n\n\terr = usb_autopm_get_interface(intf);\n\tif (err)\n\t\tgoto out;\n\n\tif (devinfo->bus_pub.state != BRCMFMAC_USB_STATE_UP) {\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tif (test_and_set_bit(0, &devinfo->ctl_op)) {\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tdevinfo->ctl_completed = false;\n\terr = brcmf_usb_recv_ctl(devinfo, buf, len);\n\tif (err) {\n\t\tbrcmf_err(\"fail %d bytes: %d\\n\", err, len);\n\t\tclear_bit(0, &devinfo->ctl_op);\n\t\tgoto fail;\n\t}\n\ttimeout = brcmf_usb_ioctl_resp_wait(devinfo);\n\terr = devinfo->ctl_urb_status;\n\tif (!timeout) {\n\t\tbrcmf_err(\"rxctl wait timed out\\n\");\n\t\tusb_kill_urb(devinfo->ctl_urb);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\tclear_bit(0, &devinfo->ctl_op);\nfail:\n\tusb_autopm_put_interface(intf);\n\tif (!err)\n\t\treturn devinfo->ctl_urb_actual_length;\nout:\n\treturn err;\n}\n\nstatic struct brcmf_usbreq *brcmf_usb_deq(struct brcmf_usbdev_info *devinfo,\n\t\t\t\t\t  struct list_head *q, int *counter)\n{\n\tunsigned long flags;\n\tstruct brcmf_usbreq  *req;\n\tspin_lock_irqsave(&devinfo->qlock, flags);\n\tif (list_empty(q)) {\n\t\tspin_unlock_irqrestore(&devinfo->qlock, flags);\n\t\treturn NULL;\n\t}\n\treq = list_entry(q->next, struct brcmf_usbreq, list);\n\tlist_del_init(q->next);\n\tif (counter)\n\t\t(*counter)--;\n\tspin_unlock_irqrestore(&devinfo->qlock, flags);\n\treturn req;\n\n}\n\nstatic void brcmf_usb_enq(struct brcmf_usbdev_info *devinfo,\n\t\t\t  struct list_head *q, struct brcmf_usbreq *req,\n\t\t\t  int *counter)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&devinfo->qlock, flags);\n\tlist_add_tail(&req->list, q);\n\tif (counter)\n\t\t(*counter)++;\n\tspin_unlock_irqrestore(&devinfo->qlock, flags);\n}\n\nstatic struct brcmf_usbreq *\nbrcmf_usbdev_qinit(struct list_head *q, int qsize)\n{\n\tint i;\n\tstruct brcmf_usbreq *req, *reqs;\n\n\treqs = kcalloc(qsize, sizeof(struct brcmf_usbreq), GFP_ATOMIC);\n\tif (reqs == NULL)\n\t\treturn NULL;\n\n\treq = reqs;\n\n\tfor (i = 0; i < qsize; i++) {\n\t\treq->urb = usb_alloc_urb(0, GFP_ATOMIC);\n\t\tif (!req->urb)\n\t\t\tgoto fail;\n\n\t\tINIT_LIST_HEAD(&req->list);\n\t\tlist_add_tail(&req->list, q);\n\t\treq++;\n\t}\n\treturn reqs;\nfail:\n\tbrcmf_err(\"fail!\\n\");\n\twhile (!list_empty(q)) {\n\t\treq = list_entry(q->next, struct brcmf_usbreq, list);\n\t\tif (req)\n\t\t\tusb_free_urb(req->urb);\n\t\tlist_del(q->next);\n\t}\n\tkfree(reqs);\n\treturn NULL;\n\n}\n\nstatic void brcmf_usb_free_q(struct list_head *q)\n{\n\tstruct brcmf_usbreq *req, *next;\n\n\tlist_for_each_entry_safe(req, next, q, list) {\n\t\tif (!req->urb) {\n\t\t\tbrcmf_err(\"bad req\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tusb_free_urb(req->urb);\n\t\tlist_del_init(&req->list);\n\t}\n}\n\nstatic void brcmf_usb_del_fromq(struct brcmf_usbdev_info *devinfo,\n\t\t\t\tstruct brcmf_usbreq *req)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&devinfo->qlock, flags);\n\tlist_del_init(&req->list);\n\tspin_unlock_irqrestore(&devinfo->qlock, flags);\n}\n\n\nstatic void brcmf_usb_tx_complete(struct urb *urb)\n{\n\tstruct brcmf_usbreq *req = (struct brcmf_usbreq *)urb->context;\n\tstruct brcmf_usbdev_info *devinfo = req->devinfo;\n\tunsigned long flags;\n\n\tbrcmf_dbg(USB, \"Enter, urb->status=%d, skb=%p\\n\", urb->status,\n\t\t  req->skb);\n\tbrcmf_usb_del_fromq(devinfo, req);\n\n\tbrcmf_proto_bcdc_txcomplete(devinfo->dev, req->skb, urb->status == 0);\n\treq->skb = NULL;\n\tbrcmf_usb_enq(devinfo, &devinfo->tx_freeq, req, &devinfo->tx_freecount);\n\tspin_lock_irqsave(&devinfo->tx_flowblock_lock, flags);\n\tif (devinfo->tx_freecount > devinfo->tx_high_watermark &&\n\t\tdevinfo->tx_flowblock) {\n\t\tbrcmf_proto_bcdc_txflowblock(devinfo->dev, false);\n\t\tdevinfo->tx_flowblock = false;\n\t}\n\tspin_unlock_irqrestore(&devinfo->tx_flowblock_lock, flags);\n}\n\nstatic void brcmf_usb_rx_complete(struct urb *urb)\n{\n\tstruct brcmf_usbreq  *req = (struct brcmf_usbreq *)urb->context;\n\tstruct brcmf_usbdev_info *devinfo = req->devinfo;\n\tstruct sk_buff *skb;\n\n\tbrcmf_dbg(USB, \"Enter, urb->status=%d\\n\", urb->status);\n\tbrcmf_usb_del_fromq(devinfo, req);\n\tskb = req->skb;\n\treq->skb = NULL;\n\n\t \n\tif (urb->status != 0 || !urb->actual_length) {\n\t\tbrcmu_pkt_buf_free_skb(skb);\n\t\tbrcmf_usb_enq(devinfo, &devinfo->rx_freeq, req, NULL);\n\t\treturn;\n\t}\n\n\tif (devinfo->bus_pub.state == BRCMFMAC_USB_STATE_UP ||\n\t    devinfo->bus_pub.state == BRCMFMAC_USB_STATE_SLEEP) {\n\t\tskb_put(skb, urb->actual_length);\n\t\tbrcmf_rx_frame(devinfo->dev, skb, true, true);\n\t\tbrcmf_usb_rx_refill(devinfo, req);\n\t\tusb_mark_last_busy(urb->dev);\n\t} else {\n\t\tbrcmu_pkt_buf_free_skb(skb);\n\t\tbrcmf_usb_enq(devinfo, &devinfo->rx_freeq, req, NULL);\n\t}\n\treturn;\n\n}\n\nstatic void brcmf_usb_rx_refill(struct brcmf_usbdev_info *devinfo,\n\t\t\t\tstruct brcmf_usbreq  *req)\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tif (!req || !devinfo)\n\t\treturn;\n\n\tskb = dev_alloc_skb(devinfo->bus_pub.bus_mtu);\n\tif (!skb) {\n\t\tbrcmf_usb_enq(devinfo, &devinfo->rx_freeq, req, NULL);\n\t\treturn;\n\t}\n\treq->skb = skb;\n\n\tusb_fill_bulk_urb(req->urb, devinfo->usbdev, devinfo->rx_pipe,\n\t\t\t  skb->data, skb_tailroom(skb), brcmf_usb_rx_complete,\n\t\t\t  req);\n\treq->devinfo = devinfo;\n\tbrcmf_usb_enq(devinfo, &devinfo->rx_postq, req, NULL);\n\n\tret = usb_submit_urb(req->urb, GFP_ATOMIC);\n\tif (ret) {\n\t\tbrcmf_usb_del_fromq(devinfo, req);\n\t\tbrcmu_pkt_buf_free_skb(req->skb);\n\t\treq->skb = NULL;\n\t\tbrcmf_usb_enq(devinfo, &devinfo->rx_freeq, req, NULL);\n\t}\n\treturn;\n}\n\nstatic void brcmf_usb_rx_fill_all(struct brcmf_usbdev_info *devinfo)\n{\n\tstruct brcmf_usbreq *req;\n\n\tif (devinfo->bus_pub.state != BRCMFMAC_USB_STATE_UP) {\n\t\tbrcmf_err(\"bus is not up=%d\\n\", devinfo->bus_pub.state);\n\t\treturn;\n\t}\n\twhile ((req = brcmf_usb_deq(devinfo, &devinfo->rx_freeq, NULL)) != NULL)\n\t\tbrcmf_usb_rx_refill(devinfo, req);\n}\n\nstatic void\nbrcmf_usb_state_change(struct brcmf_usbdev_info *devinfo, int state)\n{\n\tstruct brcmf_bus *bcmf_bus = devinfo->bus_pub.bus;\n\n\tbrcmf_dbg(USB, \"Enter, current state=%d, new state=%d\\n\",\n\t\t  devinfo->bus_pub.state, state);\n\n\tif (devinfo->bus_pub.state == state)\n\t\treturn;\n\n\tdevinfo->bus_pub.state = state;\n\n\t \n\tif (state == BRCMFMAC_USB_STATE_DOWN) {\n\t\tbrcmf_dbg(USB, \"DBUS is down\\n\");\n\t\tbrcmf_bus_change_state(bcmf_bus, BRCMF_BUS_DOWN);\n\t} else if (state == BRCMFMAC_USB_STATE_UP) {\n\t\tbrcmf_dbg(USB, \"DBUS is up\\n\");\n\t\tbrcmf_bus_change_state(bcmf_bus, BRCMF_BUS_UP);\n\t} else {\n\t\tbrcmf_dbg(USB, \"DBUS current state=%d\\n\", state);\n\t}\n}\n\nstatic int brcmf_usb_tx(struct device *dev, struct sk_buff *skb)\n{\n\tstruct brcmf_usbdev_info *devinfo = brcmf_usb_get_businfo(dev);\n\tstruct brcmf_usbreq  *req;\n\tint ret;\n\tunsigned long flags;\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\n\tret = usb_autopm_get_interface(intf);\n\tif (ret)\n\t\tgoto out;\n\n\tbrcmf_dbg(USB, \"Enter, skb=%p\\n\", skb);\n\tif (devinfo->bus_pub.state != BRCMFMAC_USB_STATE_UP) {\n\t\tret = -EIO;\n\t\tgoto fail;\n\t}\n\n\treq = brcmf_usb_deq(devinfo, &devinfo->tx_freeq,\n\t\t\t\t\t&devinfo->tx_freecount);\n\tif (!req) {\n\t\tbrcmf_err(\"no req to send\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\treq->skb = skb;\n\treq->devinfo = devinfo;\n\tusb_fill_bulk_urb(req->urb, devinfo->usbdev, devinfo->tx_pipe,\n\t\t\t  skb->data, skb->len, brcmf_usb_tx_complete, req);\n\treq->urb->transfer_flags |= URB_ZERO_PACKET;\n\tbrcmf_usb_enq(devinfo, &devinfo->tx_postq, req, NULL);\n\tret = usb_submit_urb(req->urb, GFP_ATOMIC);\n\tif (ret) {\n\t\tbrcmf_err(\"brcmf_usb_tx usb_submit_urb FAILED\\n\");\n\t\tbrcmf_usb_del_fromq(devinfo, req);\n\t\treq->skb = NULL;\n\t\tbrcmf_usb_enq(devinfo, &devinfo->tx_freeq, req,\n\t\t\t      &devinfo->tx_freecount);\n\t\tgoto fail;\n\t}\n\n\tspin_lock_irqsave(&devinfo->tx_flowblock_lock, flags);\n\tif (devinfo->tx_freecount < devinfo->tx_low_watermark &&\n\t    !devinfo->tx_flowblock) {\n\t\tbrcmf_proto_bcdc_txflowblock(dev, true);\n\t\tdevinfo->tx_flowblock = true;\n\t}\n\tspin_unlock_irqrestore(&devinfo->tx_flowblock_lock, flags);\n\nfail:\n\tusb_autopm_put_interface(intf);\nout:\n\treturn ret;\n}\n\n\nstatic int brcmf_usb_up(struct device *dev)\n{\n\tstruct brcmf_usbdev_info *devinfo = brcmf_usb_get_businfo(dev);\n\n\tbrcmf_dbg(USB, \"Enter\\n\");\n\tif (devinfo->bus_pub.state == BRCMFMAC_USB_STATE_UP)\n\t\treturn 0;\n\n\t \n\tbrcmf_usb_state_change(devinfo, BRCMFMAC_USB_STATE_UP);\n\n\tif (devinfo->ctl_urb) {\n\t\tdevinfo->ctl_in_pipe = usb_rcvctrlpipe(devinfo->usbdev, 0);\n\t\tdevinfo->ctl_out_pipe = usb_sndctrlpipe(devinfo->usbdev, 0);\n\n\t\t \n\t\tdevinfo->ctl_write.bRequestType =\n\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE;\n\t\tdevinfo->ctl_write.bRequest = 0;\n\t\tdevinfo->ctl_write.wValue = cpu_to_le16(0);\n\t\tdevinfo->ctl_write.wIndex = cpu_to_le16(devinfo->ifnum);\n\n\t\t \n\t\tdevinfo->ctl_read.bRequestType =\n\t\t\tUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE;\n\t\tdevinfo->ctl_read.bRequest = 1;\n\t\tdevinfo->ctl_read.wValue = cpu_to_le16(0);\n\t\tdevinfo->ctl_read.wIndex = cpu_to_le16(devinfo->ifnum);\n\t}\n\tbrcmf_usb_rx_fill_all(devinfo);\n\treturn 0;\n}\n\nstatic void brcmf_cancel_all_urbs(struct brcmf_usbdev_info *devinfo)\n{\n\tint i;\n\n\tif (devinfo->ctl_urb)\n\t\tusb_kill_urb(devinfo->ctl_urb);\n\tif (devinfo->bulk_urb)\n\t\tusb_kill_urb(devinfo->bulk_urb);\n\tif (devinfo->tx_reqs)\n\t\tfor (i = 0; i < devinfo->bus_pub.ntxq; i++)\n\t\t\tusb_kill_urb(devinfo->tx_reqs[i].urb);\n\tif (devinfo->rx_reqs)\n\t\tfor (i = 0; i < devinfo->bus_pub.nrxq; i++)\n\t\t\tusb_kill_urb(devinfo->rx_reqs[i].urb);\n}\n\nstatic void brcmf_usb_down(struct device *dev)\n{\n\tstruct brcmf_usbdev_info *devinfo = brcmf_usb_get_businfo(dev);\n\n\tbrcmf_dbg(USB, \"Enter\\n\");\n\tif (devinfo == NULL)\n\t\treturn;\n\n\tif (devinfo->bus_pub.state == BRCMFMAC_USB_STATE_DOWN)\n\t\treturn;\n\n\tbrcmf_usb_state_change(devinfo, BRCMFMAC_USB_STATE_DOWN);\n\n\tbrcmf_cancel_all_urbs(devinfo);\n}\n\nstatic void\nbrcmf_usb_sync_complete(struct urb *urb)\n{\n\tstruct brcmf_usbdev_info *devinfo =\n\t\t\t(struct brcmf_usbdev_info *)urb->context;\n\n\tdevinfo->ctl_completed = true;\n\tbrcmf_usb_ioctl_resp_wake(devinfo);\n}\n\nstatic int brcmf_usb_dl_cmd(struct brcmf_usbdev_info *devinfo, u8 cmd,\n\t\t\t    void *buffer, int buflen)\n{\n\tint ret;\n\tchar *tmpbuf;\n\tu16 size;\n\n\tif ((!devinfo) || (devinfo->ctl_urb == NULL))\n\t\treturn -EINVAL;\n\n\ttmpbuf = kmalloc(buflen, GFP_ATOMIC);\n\tif (!tmpbuf)\n\t\treturn -ENOMEM;\n\n\tsize = buflen;\n\tdevinfo->ctl_urb->transfer_buffer_length = size;\n\n\tdevinfo->ctl_read.wLength = cpu_to_le16p(&size);\n\tdevinfo->ctl_read.bRequestType = USB_DIR_IN | USB_TYPE_VENDOR |\n\t\tUSB_RECIP_INTERFACE;\n\tdevinfo->ctl_read.bRequest = cmd;\n\n\tusb_fill_control_urb(devinfo->ctl_urb,\n\t\tdevinfo->usbdev,\n\t\tusb_rcvctrlpipe(devinfo->usbdev, 0),\n\t\t(unsigned char *) &devinfo->ctl_read,\n\t\t(void *) tmpbuf, size,\n\t\t(usb_complete_t)brcmf_usb_sync_complete, devinfo);\n\n\tdevinfo->ctl_completed = false;\n\tret = usb_submit_urb(devinfo->ctl_urb, GFP_ATOMIC);\n\tif (ret < 0) {\n\t\tbrcmf_err(\"usb_submit_urb failed %d\\n\", ret);\n\t\tgoto finalize;\n\t}\n\n\tif (!brcmf_usb_ioctl_resp_wait(devinfo)) {\n\t\tusb_kill_urb(devinfo->ctl_urb);\n\t\tret = -ETIMEDOUT;\n\t} else {\n\t\tmemcpy(buffer, tmpbuf, buflen);\n\t}\n\nfinalize:\n\tkfree(tmpbuf);\n\treturn ret;\n}\n\nstatic bool\nbrcmf_usb_dlneeded(struct brcmf_usbdev_info *devinfo)\n{\n\tstruct bootrom_id_le id;\n\tu32 chipid, chiprev;\n\n\tbrcmf_dbg(USB, \"Enter\\n\");\n\n\tif (devinfo == NULL)\n\t\treturn false;\n\n\t \n\tid.chip = cpu_to_le32(0xDEAD);\n\tbrcmf_usb_dl_cmd(devinfo, DL_GETVER, &id, sizeof(id));\n\n\tchipid = le32_to_cpu(id.chip);\n\tchiprev = le32_to_cpu(id.chiprev);\n\n\tif ((chipid & 0x4300) == 0x4300)\n\t\tbrcmf_dbg(USB, \"chip %x rev 0x%x\\n\", chipid, chiprev);\n\telse\n\t\tbrcmf_dbg(USB, \"chip %d rev 0x%x\\n\", chipid, chiprev);\n\tif (chipid == BRCMF_POSTBOOT_ID) {\n\t\tbrcmf_dbg(USB, \"firmware already downloaded\\n\");\n\t\tbrcmf_usb_dl_cmd(devinfo, DL_RESETCFG, &id, sizeof(id));\n\t\treturn false;\n\t} else {\n\t\tdevinfo->bus_pub.devid = chipid;\n\t\tdevinfo->bus_pub.chiprev = chiprev;\n\t}\n\treturn true;\n}\n\nstatic int\nbrcmf_usb_resetcfg(struct brcmf_usbdev_info *devinfo)\n{\n\tstruct bootrom_id_le id;\n\tu32 loop_cnt;\n\tint err;\n\n\tbrcmf_dbg(USB, \"Enter\\n\");\n\n\tloop_cnt = 0;\n\tdo {\n\t\tmdelay(BRCMF_USB_RESET_GETVER_SPINWAIT);\n\t\tloop_cnt++;\n\t\tid.chip = cpu_to_le32(0xDEAD);        \n\t\terr = brcmf_usb_dl_cmd(devinfo, DL_GETVER, &id, sizeof(id));\n\t\tif ((err) && (err != -ETIMEDOUT))\n\t\t\treturn err;\n\t\tif (id.chip == cpu_to_le32(BRCMF_POSTBOOT_ID))\n\t\t\tbreak;\n\t} while (loop_cnt < BRCMF_USB_RESET_GETVER_LOOP_CNT);\n\n\tif (id.chip == cpu_to_le32(BRCMF_POSTBOOT_ID)) {\n\t\tbrcmf_dbg(USB, \"postboot chip 0x%x/rev 0x%x\\n\",\n\t\t\t  le32_to_cpu(id.chip), le32_to_cpu(id.chiprev));\n\n\t\tbrcmf_usb_dl_cmd(devinfo, DL_RESETCFG, &id, sizeof(id));\n\t\treturn 0;\n\t} else {\n\t\tbrcmf_err(\"Cannot talk to Dongle. Firmware is not UP, %d ms\\n\",\n\t\t\t  BRCMF_USB_RESET_GETVER_SPINWAIT * loop_cnt);\n\t\treturn -EINVAL;\n\t}\n}\n\n\nstatic int\nbrcmf_usb_dl_send_bulk(struct brcmf_usbdev_info *devinfo, void *buffer, int len)\n{\n\tint ret;\n\n\tif ((devinfo == NULL) || (devinfo->bulk_urb == NULL))\n\t\treturn -EINVAL;\n\n\t \n\tusb_fill_bulk_urb(devinfo->bulk_urb, devinfo->usbdev,\n\t\t\t  devinfo->tx_pipe, buffer, len,\n\t\t\t  (usb_complete_t)brcmf_usb_sync_complete, devinfo);\n\n\tdevinfo->bulk_urb->transfer_flags |= URB_ZERO_PACKET;\n\n\tdevinfo->ctl_completed = false;\n\tret = usb_submit_urb(devinfo->bulk_urb, GFP_ATOMIC);\n\tif (ret) {\n\t\tbrcmf_err(\"usb_submit_urb failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = brcmf_usb_ioctl_resp_wait(devinfo);\n\treturn (ret == 0);\n}\n\nstatic int\nbrcmf_usb_dl_writeimage(struct brcmf_usbdev_info *devinfo, u8 *fw, int fwlen)\n{\n\tunsigned int sendlen, sent, dllen;\n\tchar *bulkchunk = NULL, *dlpos;\n\tstruct rdl_state_le state;\n\tu32 rdlstate, rdlbytes;\n\tint err = 0;\n\n\tbrcmf_dbg(USB, \"Enter, fw %p, len %d\\n\", fw, fwlen);\n\n\tbulkchunk = kmalloc(TRX_RDL_CHUNK, GFP_ATOMIC);\n\tif (bulkchunk == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\t \n\tbrcmf_usb_dl_cmd(devinfo, DL_START, &state, sizeof(state));\n\n\trdlstate = le32_to_cpu(state.state);\n\trdlbytes = le32_to_cpu(state.bytes);\n\n\t \n\tif (rdlstate != DL_WAITING) {\n\t\tbrcmf_err(\"Failed to DL_START\\n\");\n\t\terr = -EINVAL;\n\t\tgoto fail;\n\t}\n\tsent = 0;\n\tdlpos = fw;\n\tdllen = fwlen;\n\n\t \n\twhile (rdlbytes != dllen) {\n\t\t \n\t\tif ((rdlbytes == sent) && (rdlbytes != dllen)) {\n\t\t\tif ((dllen-sent) < TRX_RDL_CHUNK)\n\t\t\t\tsendlen = dllen-sent;\n\t\t\telse\n\t\t\t\tsendlen = TRX_RDL_CHUNK;\n\n\t\t\t \n\t\t\tif (!(sendlen % 64))\n\t\t\t\tsendlen -= 4;\n\n\t\t\t \n\t\t\tmemcpy(bulkchunk, dlpos, sendlen);\n\t\t\tif (brcmf_usb_dl_send_bulk(devinfo, bulkchunk,\n\t\t\t\t\t\t   sendlen)) {\n\t\t\t\tbrcmf_err(\"send_bulk failed\\n\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tdlpos += sendlen;\n\t\t\tsent += sendlen;\n\t\t}\n\t\terr = brcmf_usb_dl_cmd(devinfo, DL_GETSTATE, &state,\n\t\t\t\t       sizeof(state));\n\t\tif (err) {\n\t\t\tbrcmf_err(\"DL_GETSTATE Failed\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\trdlstate = le32_to_cpu(state.state);\n\t\trdlbytes = le32_to_cpu(state.bytes);\n\n\t\t \n\t\tif (rdlstate == DL_BAD_HDR || rdlstate == DL_BAD_CRC) {\n\t\t\tbrcmf_err(\"Bad Hdr or Bad CRC state %d\\n\",\n\t\t\t\t  rdlstate);\n\t\t\terr = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\nfail:\n\tkfree(bulkchunk);\n\tbrcmf_dbg(USB, \"Exit, err=%d\\n\", err);\n\treturn err;\n}\n\nstatic int brcmf_usb_dlstart(struct brcmf_usbdev_info *devinfo, u8 *fw, int len)\n{\n\tint err;\n\n\tbrcmf_dbg(USB, \"Enter\\n\");\n\n\tif (devinfo == NULL)\n\t\treturn -EINVAL;\n\n\tif (devinfo->bus_pub.devid == 0xDEAD)\n\t\treturn -EINVAL;\n\n\terr = brcmf_usb_dl_writeimage(devinfo, fw, len);\n\tif (err == 0)\n\t\tdevinfo->bus_pub.state = BRCMFMAC_USB_STATE_DL_DONE;\n\telse\n\t\tdevinfo->bus_pub.state = BRCMFMAC_USB_STATE_DL_FAIL;\n\tbrcmf_dbg(USB, \"Exit, err=%d\\n\", err);\n\n\treturn err;\n}\n\nstatic int brcmf_usb_dlrun(struct brcmf_usbdev_info *devinfo)\n{\n\tstruct rdl_state_le state;\n\n\tbrcmf_dbg(USB, \"Enter\\n\");\n\tif (!devinfo)\n\t\treturn -EINVAL;\n\n\tif (devinfo->bus_pub.devid == 0xDEAD)\n\t\treturn -EINVAL;\n\n\t \n\tstate.state = 0;\n\tbrcmf_usb_dl_cmd(devinfo, DL_GETSTATE, &state, sizeof(state));\n\n\t \n\tif (state.state == cpu_to_le32(DL_RUNNABLE)) {\n\t\tif (brcmf_usb_dl_cmd(devinfo, DL_GO, &state, sizeof(state)))\n\t\t\treturn -ENODEV;\n\t\tif (brcmf_usb_resetcfg(devinfo))\n\t\t\treturn -ENODEV;\n\t\t \n\t} else {\n\t\tbrcmf_err(\"Dongle not runnable\\n\");\n\t\treturn -EINVAL;\n\t}\n\tbrcmf_dbg(USB, \"Exit\\n\");\n\treturn 0;\n}\n\nstatic int\nbrcmf_usb_fw_download(struct brcmf_usbdev_info *devinfo)\n{\n\tint err;\n\tstruct usb_interface *intf;\n\n\tbrcmf_dbg(USB, \"Enter\\n\");\n\tif (!devinfo) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (!devinfo->image) {\n\t\tbrcmf_err(\"No firmware!\\n\");\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tintf = to_usb_interface(devinfo->dev);\n\terr = usb_autopm_get_interface(intf);\n\tif (err)\n\t\tgoto out;\n\n\terr = brcmf_usb_dlstart(devinfo,\n\t\t(u8 *)devinfo->image, devinfo->image_len);\n\tif (err == 0)\n\t\terr = brcmf_usb_dlrun(devinfo);\n\n\tusb_autopm_put_interface(intf);\nout:\n\treturn err;\n}\n\n\nstatic void brcmf_usb_detach(struct brcmf_usbdev_info *devinfo)\n{\n\tbrcmf_dbg(USB, \"Enter, devinfo %p\\n\", devinfo);\n\n\t \n\tbrcmf_usb_free_q(&devinfo->rx_freeq);\n\tbrcmf_usb_free_q(&devinfo->tx_freeq);\n\n\tusb_free_urb(devinfo->ctl_urb);\n\tusb_free_urb(devinfo->bulk_urb);\n\n\tkfree(devinfo->tx_reqs);\n\tkfree(devinfo->rx_reqs);\n\n\tif (devinfo->settings)\n\t\tbrcmf_release_module_param(devinfo->settings);\n}\n\n\nstatic int check_file(const u8 *headers)\n{\n\tstruct trx_header_le *trx;\n\tint actual_len = -1;\n\n\tbrcmf_dbg(USB, \"Enter\\n\");\n\t \n\ttrx = (struct trx_header_le *) headers;\n\tif (trx->magic != cpu_to_le32(TRX_MAGIC))\n\t\treturn -1;\n\n\theaders += sizeof(struct trx_header_le);\n\n\tif (le32_to_cpu(trx->flag_version) & TRX_UNCOMP_IMAGE) {\n\t\tactual_len = le32_to_cpu(trx->offsets[TRX_OFFSETS_DLFWLEN_IDX]);\n\t\treturn actual_len + sizeof(struct trx_header_le);\n\t}\n\treturn -1;\n}\n\n\nstatic\nstruct brcmf_usbdev *brcmf_usb_attach(struct brcmf_usbdev_info *devinfo,\n\t\t\t\t      int nrxq, int ntxq)\n{\n\tbrcmf_dbg(USB, \"Enter\\n\");\n\n\tdevinfo->bus_pub.nrxq = nrxq;\n\tdevinfo->rx_low_watermark = nrxq / 2;\n\tdevinfo->bus_pub.devinfo = devinfo;\n\tdevinfo->bus_pub.ntxq = ntxq;\n\tdevinfo->bus_pub.state = BRCMFMAC_USB_STATE_DOWN;\n\n\t \n\tdevinfo->tx_low_watermark = ntxq / 4;\n\tdevinfo->tx_high_watermark = devinfo->tx_low_watermark * 3;\n\tdevinfo->bus_pub.bus_mtu = BRCMF_USB_MAX_PKT_SIZE;\n\n\t \n\tinit_waitqueue_head(&devinfo->ioctl_resp_wait);\n\n\t \n\tspin_lock_init(&devinfo->qlock);\n\tspin_lock_init(&devinfo->tx_flowblock_lock);\n\n\tINIT_LIST_HEAD(&devinfo->rx_freeq);\n\tINIT_LIST_HEAD(&devinfo->rx_postq);\n\n\tINIT_LIST_HEAD(&devinfo->tx_freeq);\n\tINIT_LIST_HEAD(&devinfo->tx_postq);\n\n\tdevinfo->tx_flowblock = false;\n\n\tdevinfo->rx_reqs = brcmf_usbdev_qinit(&devinfo->rx_freeq, nrxq);\n\tif (!devinfo->rx_reqs)\n\t\tgoto error;\n\n\tdevinfo->tx_reqs = brcmf_usbdev_qinit(&devinfo->tx_freeq, ntxq);\n\tif (!devinfo->tx_reqs)\n\t\tgoto error;\n\tdevinfo->tx_freecount = ntxq;\n\n\tdevinfo->ctl_urb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!devinfo->ctl_urb)\n\t\tgoto error;\n\tdevinfo->bulk_urb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!devinfo->bulk_urb)\n\t\tgoto error;\n\n\treturn &devinfo->bus_pub;\n\nerror:\n\tbrcmf_err(\"failed!\\n\");\n\tbrcmf_usb_detach(devinfo);\n\treturn NULL;\n}\n\nstatic int brcmf_usb_get_blob(struct device *dev, const struct firmware **fw,\n\t\t\t      enum brcmf_blob_type type)\n{\n\t \n\treturn -ENOENT;\n}\n\nstatic const struct brcmf_bus_ops brcmf_usb_bus_ops = {\n\t.preinit = brcmf_usb_up,\n\t.stop = brcmf_usb_down,\n\t.txdata = brcmf_usb_tx,\n\t.txctl = brcmf_usb_tx_ctlpkt,\n\t.rxctl = brcmf_usb_rx_ctlpkt,\n\t.get_blob = brcmf_usb_get_blob,\n};\n\n#define BRCMF_USB_FW_CODE\t0\n\nstatic void brcmf_usb_probe_phase2(struct device *dev, int ret,\n\t\t\t\t   struct brcmf_fw_request *fwreq)\n{\n\tstruct brcmf_bus *bus = dev_get_drvdata(dev);\n\tstruct brcmf_usbdev_info *devinfo = bus->bus_priv.usb->devinfo;\n\tconst struct firmware *fw;\n\n\tif (ret)\n\t\tgoto error;\n\n\tbrcmf_dbg(USB, \"Start fw downloading\\n\");\n\n\tfw = fwreq->items[BRCMF_USB_FW_CODE].binary;\n\tkfree(fwreq);\n\n\tret = check_file(fw->data);\n\tif (ret < 0) {\n\t\tbrcmf_err(\"invalid firmware\\n\");\n\t\trelease_firmware(fw);\n\t\tgoto error;\n\t}\n\n\tdevinfo->image = fw->data;\n\tdevinfo->image_len = fw->size;\n\n\tret = brcmf_usb_fw_download(devinfo);\n\trelease_firmware(fw);\n\tif (ret)\n\t\tgoto error;\n\n\tret = brcmf_alloc(devinfo->dev, devinfo->settings);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tret = brcmf_attach(devinfo->dev);\n\tif (ret)\n\t\tgoto error;\n\n\tcomplete(&devinfo->dev_init_done);\n\treturn;\nerror:\n\tbrcmf_dbg(TRACE, \"failed: dev=%s, err=%d\\n\", dev_name(dev), ret);\n\tcomplete(&devinfo->dev_init_done);\n\tdevice_release_driver(dev);\n}\n\nstatic struct brcmf_fw_request *\nbrcmf_usb_prepare_fw_request(struct brcmf_usbdev_info *devinfo)\n{\n\tstruct brcmf_fw_request *fwreq;\n\tstruct brcmf_fw_name fwnames[] = {\n\t\t{ \".bin\", devinfo->fw_name },\n\t};\n\n\tfwreq = brcmf_fw_alloc_request(devinfo->bus_pub.devid,\n\t\t\t\t       devinfo->bus_pub.chiprev,\n\t\t\t\t       brcmf_usb_fwnames,\n\t\t\t\t       ARRAY_SIZE(brcmf_usb_fwnames),\n\t\t\t\t       fwnames, ARRAY_SIZE(fwnames));\n\tif (!fwreq)\n\t\treturn NULL;\n\n\tfwreq->items[BRCMF_USB_FW_CODE].type = BRCMF_FW_TYPE_BINARY;\n\n\treturn fwreq;\n}\n\nstatic int brcmf_usb_probe_cb(struct brcmf_usbdev_info *devinfo,\n\t\t\t      enum brcmf_fwvendor fwvid)\n{\n\tstruct brcmf_bus *bus = NULL;\n\tstruct brcmf_usbdev *bus_pub = NULL;\n\tstruct device *dev = devinfo->dev;\n\tstruct brcmf_fw_request *fwreq;\n\tint ret;\n\n\tbrcmf_dbg(USB, \"Enter\\n\");\n\tbus_pub = brcmf_usb_attach(devinfo, BRCMF_USB_NRXQ, BRCMF_USB_NTXQ);\n\tif (!bus_pub)\n\t\treturn -ENODEV;\n\n\tbus = kzalloc(sizeof(struct brcmf_bus), GFP_ATOMIC);\n\tif (!bus) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tbus->dev = dev;\n\tbus_pub->bus = bus;\n\tbus->bus_priv.usb = bus_pub;\n\tdev_set_drvdata(dev, bus);\n\tbus->ops = &brcmf_usb_bus_ops;\n\tbus->proto_type = BRCMF_PROTO_BCDC;\n\tbus->fwvid = fwvid;\n\tbus->always_use_fws_queue = true;\n#ifdef CONFIG_PM\n\tbus->wowl_supported = true;\n#endif\n\n\tdevinfo->settings = brcmf_get_module_param(bus->dev, BRCMF_BUSTYPE_USB,\n\t\t\t\t\t\t   bus_pub->devid,\n\t\t\t\t\t\t   bus_pub->chiprev);\n\tif (!devinfo->settings) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tif (!brcmf_usb_dlneeded(devinfo)) {\n\t\tret = brcmf_alloc(devinfo->dev, devinfo->settings);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t\tret = brcmf_attach(devinfo->dev);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t\t \n\t\tcomplete(&devinfo->dev_init_done);\n\t\treturn 0;\n\t}\n\tbus->chip = bus_pub->devid;\n\tbus->chiprev = bus_pub->chiprev;\n\n\tfwreq = brcmf_usb_prepare_fw_request(devinfo);\n\tif (!fwreq) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\t \n\tret = brcmf_fw_get_firmwares(dev, fwreq, brcmf_usb_probe_phase2);\n\tif (ret) {\n\t\tbrcmf_err(\"firmware request failed: %d\\n\", ret);\n\t\tkfree(fwreq);\n\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\t \n\tbrcmf_free(devinfo->dev);\n\tkfree(bus);\n\tbrcmf_usb_detach(devinfo);\n\treturn ret;\n}\n\nstatic void\nbrcmf_usb_disconnect_cb(struct brcmf_usbdev_info *devinfo)\n{\n\tif (!devinfo)\n\t\treturn;\n\tbrcmf_dbg(USB, \"Enter, bus_pub %p\\n\", devinfo);\n\n\tbrcmf_detach(devinfo->dev);\n\tbrcmf_free(devinfo->dev);\n\tkfree(devinfo->bus_pub.bus);\n\tbrcmf_usb_detach(devinfo);\n}\n\n \nstatic const struct usb_device_id brcmf_usb_devid_table[];\n\nstatic int\nbrcmf_usb_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_device *usb = interface_to_usbdev(intf);\n\tstruct brcmf_usbdev_info *devinfo;\n\tstruct usb_interface_descriptor\t*desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tint ret = 0;\n\tu32 num_of_eps;\n\tu8 endpoint_num, ep;\n\n\tif (!id) {\n\t\tid = usb_match_id(intf, brcmf_usb_devid_table);\n\t\tif (!id) {\n\t\t\tdev_err(&intf->dev, \"Error could not find matching usb_device_id\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tbrcmf_dbg(USB, \"Enter 0x%04x:0x%04x\\n\", id->idVendor, id->idProduct);\n\n\tdevinfo = kzalloc(sizeof(*devinfo), GFP_ATOMIC);\n\tif (devinfo == NULL)\n\t\treturn -ENOMEM;\n\n\tdevinfo->usbdev = usb;\n\tdevinfo->dev = &usb->dev;\n\t \n\tinit_completion(&devinfo->dev_init_done);\n\n\tusb_set_intfdata(intf, devinfo);\n\n\tintf->needs_remote_wakeup = 1;\n\n\t \n\tif (usb->descriptor.bNumConfigurations != 1) {\n\t\tbrcmf_err(\"Number of configurations: %d not supported\\n\",\n\t\t\t  usb->descriptor.bNumConfigurations);\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tif ((usb->descriptor.bDeviceClass != USB_CLASS_VENDOR_SPEC) &&\n\t    (usb->descriptor.bDeviceClass != USB_CLASS_MISC) &&\n\t    (usb->descriptor.bDeviceClass != USB_CLASS_WIRELESS_CONTROLLER)) {\n\t\tbrcmf_err(\"Device class: 0x%x not supported\\n\",\n\t\t\t  usb->descriptor.bDeviceClass);\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tdesc = &intf->cur_altsetting->desc;\n\tif ((desc->bInterfaceClass != USB_CLASS_VENDOR_SPEC) ||\n\t    (desc->bInterfaceSubClass != 2) ||\n\t    (desc->bInterfaceProtocol != 0xff)) {\n\t\tbrcmf_err(\"non WLAN interface %d: 0x%x:0x%x:0x%x\\n\",\n\t\t\t  desc->bInterfaceNumber, desc->bInterfaceClass,\n\t\t\t  desc->bInterfaceSubClass, desc->bInterfaceProtocol);\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tnum_of_eps = desc->bNumEndpoints;\n\tfor (ep = 0; ep < num_of_eps; ep++) {\n\t\tendpoint = &intf->cur_altsetting->endpoint[ep].desc;\n\t\tendpoint_num = usb_endpoint_num(endpoint);\n\t\tif (!usb_endpoint_xfer_bulk(endpoint))\n\t\t\tcontinue;\n\t\tif (usb_endpoint_dir_in(endpoint)) {\n\t\t\tif (!devinfo->rx_pipe)\n\t\t\t\tdevinfo->rx_pipe =\n\t\t\t\t\tusb_rcvbulkpipe(usb, endpoint_num);\n\t\t} else {\n\t\t\tif (!devinfo->tx_pipe)\n\t\t\t\tdevinfo->tx_pipe =\n\t\t\t\t\tusb_sndbulkpipe(usb, endpoint_num);\n\t\t}\n\t}\n\tif (devinfo->rx_pipe == 0) {\n\t\tbrcmf_err(\"No RX (in) Bulk EP found\\n\");\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t}\n\tif (devinfo->tx_pipe == 0) {\n\t\tbrcmf_err(\"No TX (out) Bulk EP found\\n\");\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tdevinfo->ifnum = desc->bInterfaceNumber;\n\n\tif (usb->speed == USB_SPEED_SUPER_PLUS)\n\t\tbrcmf_dbg(USB, \"Broadcom super speed plus USB WLAN interface detected\\n\");\n\telse if (usb->speed == USB_SPEED_SUPER)\n\t\tbrcmf_dbg(USB, \"Broadcom super speed USB WLAN interface detected\\n\");\n\telse if (usb->speed == USB_SPEED_HIGH)\n\t\tbrcmf_dbg(USB, \"Broadcom high speed USB WLAN interface detected\\n\");\n\telse\n\t\tbrcmf_dbg(USB, \"Broadcom full speed USB WLAN interface detected\\n\");\n\n\tret = brcmf_usb_probe_cb(devinfo, id->driver_info);\n\tif (ret)\n\t\tgoto fail;\n\n\t \n\treturn 0;\n\nfail:\n\tcomplete(&devinfo->dev_init_done);\n\tkfree(devinfo);\n\tusb_set_intfdata(intf, NULL);\n\treturn ret;\n}\n\nstatic void\nbrcmf_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct brcmf_usbdev_info *devinfo;\n\n\tbrcmf_dbg(USB, \"Enter\\n\");\n\tdevinfo = (struct brcmf_usbdev_info *)usb_get_intfdata(intf);\n\n\tif (devinfo) {\n\t\twait_for_completion(&devinfo->dev_init_done);\n\t\t \n\t\tif (!usb_get_intfdata(intf))\n\t\t\tgoto done;\n\n\t\tbrcmf_usb_disconnect_cb(devinfo);\n\t\tkfree(devinfo);\n\t}\ndone:\n\tbrcmf_dbg(USB, \"Exit\\n\");\n}\n\n \nstatic int brcmf_usb_suspend(struct usb_interface *intf, pm_message_t state)\n{\n\tstruct usb_device *usb = interface_to_usbdev(intf);\n\tstruct brcmf_usbdev_info *devinfo = brcmf_usb_get_businfo(&usb->dev);\n\n\tbrcmf_dbg(USB, \"Enter\\n\");\n\tdevinfo->bus_pub.state = BRCMFMAC_USB_STATE_SLEEP;\n\tbrcmf_cancel_all_urbs(devinfo);\n\tdevice_set_wakeup_enable(devinfo->dev, true);\n\treturn 0;\n}\n\n \nstatic int brcmf_usb_resume(struct usb_interface *intf)\n{\n\tstruct usb_device *usb = interface_to_usbdev(intf);\n\tstruct brcmf_usbdev_info *devinfo = brcmf_usb_get_businfo(&usb->dev);\n\n\tbrcmf_dbg(USB, \"Enter\\n\");\n\n\tdevinfo->bus_pub.state = BRCMFMAC_USB_STATE_UP;\n\tbrcmf_usb_rx_fill_all(devinfo);\n\tdevice_set_wakeup_enable(devinfo->dev, false);\n\treturn 0;\n}\n\nstatic int brcmf_usb_reset_resume(struct usb_interface *intf)\n{\n\tstruct usb_device *usb = interface_to_usbdev(intf);\n\tstruct brcmf_usbdev_info *devinfo = brcmf_usb_get_businfo(&usb->dev);\n\tstruct brcmf_fw_request *fwreq;\n\tint ret;\n\n\tbrcmf_dbg(USB, \"Enter\\n\");\n\n\tfwreq = brcmf_usb_prepare_fw_request(devinfo);\n\tif (!fwreq)\n\t\treturn -ENOMEM;\n\n\tret = brcmf_fw_get_firmwares(&usb->dev, fwreq, brcmf_usb_probe_phase2);\n\tif (ret < 0)\n\t\tkfree(fwreq);\n\n\treturn ret;\n}\n\n#define BRCMF_USB_DEVICE(dev_id) \\\n\t{ \\\n\t\tUSB_DEVICE(BRCM_USB_VENDOR_ID_BROADCOM, dev_id), \\\n\t\t.driver_info = BRCMF_FWVENDOR_WCC \\\n\t}\n\n#define LINKSYS_USB_DEVICE(dev_id) \\\n\t{ \\\n\t\tUSB_DEVICE(BRCM_USB_VENDOR_ID_LINKSYS, dev_id), \\\n\t\t.driver_info = BRCMF_FWVENDOR_WCC \\\n\t}\n\n#define CYPRESS_USB_DEVICE(dev_id) \\\n\t{ \\\n\t\tUSB_DEVICE(CY_USB_VENDOR_ID_CYPRESS, dev_id), \\\n\t\t.driver_info = BRCMF_FWVENDOR_WCC \\\n\t}\n\nstatic const struct usb_device_id brcmf_usb_devid_table[] = {\n\tBRCMF_USB_DEVICE(BRCM_USB_43143_DEVICE_ID),\n\tBRCMF_USB_DEVICE(BRCM_USB_43236_DEVICE_ID),\n\tBRCMF_USB_DEVICE(BRCM_USB_43242_DEVICE_ID),\n\tBRCMF_USB_DEVICE(BRCM_USB_43569_DEVICE_ID),\n\tLINKSYS_USB_DEVICE(BRCM_USB_43235_LINKSYS_DEVICE_ID),\n\tCYPRESS_USB_DEVICE(CY_USB_4373_DEVICE_ID),\n\t{ USB_DEVICE(BRCM_USB_VENDOR_ID_LG, BRCM_USB_43242_LG_DEVICE_ID) },\n\t \n\tBRCMF_USB_DEVICE(BRCM_USB_BCMFW_DEVICE_ID),\n\tCYPRESS_USB_DEVICE(BRCM_USB_BCMFW_DEVICE_ID),\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(usb, brcmf_usb_devid_table);\n\nstatic struct usb_driver brcmf_usbdrvr = {\n\t.name = KBUILD_MODNAME,\n\t.probe = brcmf_usb_probe,\n\t.disconnect = brcmf_usb_disconnect,\n\t.id_table = brcmf_usb_devid_table,\n\t.suspend = brcmf_usb_suspend,\n\t.resume = brcmf_usb_resume,\n\t.reset_resume = brcmf_usb_reset_resume,\n\t.supports_autosuspend = true,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nstatic int brcmf_usb_reset_device(struct device *dev, void *notused)\n{\n\t \n\tbrcmf_dev_reset(dev->parent);\n\treturn 0;\n}\n\nvoid brcmf_usb_exit(void)\n{\n\tstruct device_driver *drv = &brcmf_usbdrvr.drvwrap.driver;\n\tint ret;\n\n\tbrcmf_dbg(USB, \"Enter\\n\");\n\tret = driver_for_each_device(drv, NULL, NULL,\n\t\t\t\t     brcmf_usb_reset_device);\n\tif (ret)\n\t\tbrcmf_err(\"failed to reset all usb devices %d\\n\", ret);\n\n\tusb_deregister(&brcmf_usbdrvr);\n}\n\nint brcmf_usb_register(void)\n{\n\tbrcmf_dbg(USB, \"Enter\\n\");\n\treturn usb_register(&brcmf_usbdrvr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}