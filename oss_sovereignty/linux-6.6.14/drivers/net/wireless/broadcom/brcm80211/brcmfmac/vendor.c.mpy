{
  "module_name": "vendor.c",
  "hash_id": "0cd093a34f53bd854cf93182409e36af79610f901174bc94672bbe2cfc1d700d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmfmac/vendor.c",
  "human_readable_source": "\n \n\n#include <linux/vmalloc.h>\n#include <net/cfg80211.h>\n#include <net/netlink.h>\n\n#include <brcmu_wifi.h>\n#include \"fwil_types.h\"\n#include \"core.h\"\n#include \"p2p.h\"\n#include \"debug.h\"\n#include \"cfg80211.h\"\n#include \"vendor.h\"\n#include \"fwil.h\"\n\nstatic int brcmf_cfg80211_vndr_cmds_dcmd_handler(struct wiphy *wiphy,\n\t\t\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t\t\t const void *data, int len)\n{\n\tstruct brcmf_cfg80211_vif *vif;\n\tstruct brcmf_if *ifp;\n\tconst struct brcmf_vndr_dcmd_hdr *cmdhdr = data;\n\tstruct sk_buff *reply;\n\tunsigned int payload, ret_len;\n\tvoid *dcmd_buf = NULL, *wr_pointer;\n\tu16 msglen, maxmsglen = PAGE_SIZE - 0x100;\n\tint ret;\n\n\tif (len < sizeof(*cmdhdr)) {\n\t\tbrcmf_err(\"vendor command too short: %d\\n\", len);\n\t\treturn -EINVAL;\n\t}\n\n\tvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\n\tifp = vif->ifp;\n\n\tbrcmf_dbg(TRACE, \"ifidx=%d, cmd=%d\\n\", ifp->ifidx, cmdhdr->cmd);\n\n\tif (cmdhdr->offset > len) {\n\t\tbrcmf_err(\"bad buffer offset %d > %d\\n\", cmdhdr->offset, len);\n\t\treturn -EINVAL;\n\t}\n\n\tlen -= cmdhdr->offset;\n\tret_len = cmdhdr->len;\n\tif (ret_len > 0 || len > 0) {\n\t\tif (len > BRCMF_DCMD_MAXLEN) {\n\t\t\tbrcmf_err(\"oversize input buffer %d\\n\", len);\n\t\t\tlen = BRCMF_DCMD_MAXLEN;\n\t\t}\n\t\tif (ret_len > BRCMF_DCMD_MAXLEN) {\n\t\t\tbrcmf_err(\"oversize return buffer %d\\n\", ret_len);\n\t\t\tret_len = BRCMF_DCMD_MAXLEN;\n\t\t}\n\t\tpayload = max_t(unsigned int, ret_len, len) + 1;\n\t\tdcmd_buf = vzalloc(payload);\n\t\tif (NULL == dcmd_buf)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(dcmd_buf, (void *)cmdhdr + cmdhdr->offset, len);\n\t\t*(char *)(dcmd_buf + len)  = '\\0';\n\t}\n\n\tif (cmdhdr->set)\n\t\tret = brcmf_fil_cmd_data_set(ifp, cmdhdr->cmd, dcmd_buf,\n\t\t\t\t\t     ret_len);\n\telse\n\t\tret = brcmf_fil_cmd_data_get(ifp, cmdhdr->cmd, dcmd_buf,\n\t\t\t\t\t     ret_len);\n\tif (ret != 0)\n\t\tgoto exit;\n\n\twr_pointer = dcmd_buf;\n\twhile (ret_len > 0) {\n\t\tmsglen = ret_len > maxmsglen ? maxmsglen : ret_len;\n\t\tret_len -= msglen;\n\t\tpayload = msglen + sizeof(msglen);\n\t\treply = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, payload);\n\t\tif (NULL == reply) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (nla_put(reply, BRCMF_NLATTR_DATA, msglen, wr_pointer) ||\n\t\t    nla_put_u16(reply, BRCMF_NLATTR_LEN, msglen)) {\n\t\t\tkfree_skb(reply);\n\t\t\tret = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = cfg80211_vendor_cmd_reply(reply);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\twr_pointer += msglen;\n\t}\n\nexit:\n\tvfree(dcmd_buf);\n\n\treturn ret;\n}\n\nconst struct wiphy_vendor_command brcmf_vendor_cmds[] = {\n\t{\n\t\t{\n\t\t\t.vendor_id = BROADCOM_OUI,\n\t\t\t.subcmd = BRCMF_VNDR_CMDS_DCMD\n\t\t},\n\t\t.flags = WIPHY_VENDOR_CMD_NEED_WDEV |\n\t\t\t WIPHY_VENDOR_CMD_NEED_NETDEV,\n\t\t.policy = VENDOR_CMD_RAW_DATA,\n\t\t.doit = brcmf_cfg80211_vndr_cmds_dcmd_handler\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}