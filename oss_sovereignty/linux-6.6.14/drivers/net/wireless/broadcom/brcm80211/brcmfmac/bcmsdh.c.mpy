{
  "module_name": "bcmsdh.c",
  "hash_id": "09c7150883a960eeed017400e005e4a857435a291e77dee8fd0e81b94a5e0ab1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c",
  "human_readable_source": "\n \n \n\n#include <linux/types.h>\n#include <linux/netdevice.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/sched.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/scatterlist.h>\n#include <linux/mmc/sdio.h>\n#include <linux/mmc/core.h>\n#include <linux/mmc/sdio_func.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/host.h>\n#include <linux/pm_runtime.h>\n#include <linux/suspend.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/acpi.h>\n#include <net/cfg80211.h>\n\n#include <defs.h>\n#include <brcm_hw_ids.h>\n#include <brcmu_utils.h>\n#include <brcmu_wifi.h>\n#include <chipcommon.h>\n#include <soc.h>\n#include \"chip.h\"\n#include \"bus.h\"\n#include \"debug.h\"\n#include \"sdio.h\"\n#include \"core.h\"\n#include \"common.h\"\n\n#define SDIOH_API_ACCESS_RETRY_LIMIT\t2\n\n#define DMA_ALIGN_MASK\t0x03\n\n#define SDIO_FUNC1_BLOCKSIZE\t\t64\n#define SDIO_FUNC2_BLOCKSIZE\t\t512\n#define SDIO_4373_FUNC2_BLOCKSIZE\t256\n#define SDIO_435X_FUNC2_BLOCKSIZE\t256\n#define SDIO_4329_FUNC2_BLOCKSIZE\t128\n \n#define SDIO_WAIT_F2RDY\t3000\n\n#define BRCMF_DEFAULT_RXGLOM_SIZE\t32   \n\nstruct brcmf_sdiod_freezer {\n\tatomic_t freezing;\n\tatomic_t thread_count;\n\tu32 frozen_count;\n\twait_queue_head_t thread_freeze;\n\tstruct completion resumed;\n};\n\nstatic irqreturn_t brcmf_sdiod_oob_irqhandler(int irq, void *dev_id)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev_id);\n\tstruct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;\n\n\tbrcmf_dbg(INTR, \"OOB intr triggered\\n\");\n\n\t \n\tif (sdiodev->irq_en) {\n\t\tdisable_irq_nosync(irq);\n\t\tsdiodev->irq_en = false;\n\t}\n\n\tbrcmf_sdio_isr(sdiodev->bus, true);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void brcmf_sdiod_ib_irqhandler(struct sdio_func *func)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(&func->dev);\n\tstruct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;\n\n\tbrcmf_dbg(INTR, \"IB intr triggered\\n\");\n\n\tbrcmf_sdio_isr(sdiodev->bus, false);\n}\n\n \nstatic void brcmf_sdiod_dummy_irqhandler(struct sdio_func *func)\n{\n}\n\nint brcmf_sdiod_intr_register(struct brcmf_sdio_dev *sdiodev)\n{\n\tstruct brcmfmac_sdio_pd *pdata;\n\tint ret = 0;\n\tu8 data;\n\tu32 addr, gpiocontrol;\n\n\tpdata = &sdiodev->settings->bus.sdio;\n\tif (pdata->oob_irq_supported) {\n\t\tbrcmf_dbg(SDIO, \"Enter, register OOB IRQ %d\\n\",\n\t\t\t  pdata->oob_irq_nr);\n\t\tspin_lock_init(&sdiodev->irq_en_lock);\n\t\tsdiodev->irq_en = true;\n\n\t\tret = request_irq(pdata->oob_irq_nr, brcmf_sdiod_oob_irqhandler,\n\t\t\t\t  pdata->oob_irq_flags, \"brcmf_oob_intr\",\n\t\t\t\t  &sdiodev->func1->dev);\n\t\tif (ret != 0) {\n\t\t\tbrcmf_err(\"request_irq failed %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tsdiodev->oob_irq_requested = true;\n\n\t\tret = enable_irq_wake(pdata->oob_irq_nr);\n\t\tif (ret != 0) {\n\t\t\tbrcmf_err(\"enable_irq_wake failed %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdisable_irq_wake(pdata->oob_irq_nr);\n\n\t\tsdio_claim_host(sdiodev->func1);\n\n\t\tif (sdiodev->bus_if->chip == BRCM_CC_43362_CHIP_ID) {\n\t\t\t \n\t\t\taddr = brcmf_chip_enum_base(sdiodev->func1->device);\n\t\t\taddr = CORE_CC_REG(addr, gpiocontrol);\n\t\t\tgpiocontrol = brcmf_sdiod_readl(sdiodev, addr, &ret);\n\t\t\tgpiocontrol |= 0x2;\n\t\t\tbrcmf_sdiod_writel(sdiodev, addr, gpiocontrol, &ret);\n\n\t\t\tbrcmf_sdiod_writeb(sdiodev, SBSDIO_GPIO_SELECT,\n\t\t\t\t\t   0xf, &ret);\n\t\t\tbrcmf_sdiod_writeb(sdiodev, SBSDIO_GPIO_OUT, 0, &ret);\n\t\t\tbrcmf_sdiod_writeb(sdiodev, SBSDIO_GPIO_EN, 0x2, &ret);\n\t\t}\n\n\t\t \n\t\tdata = brcmf_sdiod_func0_rb(sdiodev, SDIO_CCCR_IENx, &ret);\n\t\tdata |= SDIO_CCCR_IEN_FUNC1 | SDIO_CCCR_IEN_FUNC2 |\n\t\t\tSDIO_CCCR_IEN_FUNC0;\n\t\tbrcmf_sdiod_func0_wb(sdiodev, SDIO_CCCR_IENx, data, &ret);\n\n\t\t \n\t\tdata = SDIO_CCCR_BRCM_SEPINT_MASK | SDIO_CCCR_BRCM_SEPINT_OE;\n\t\tif (pdata->oob_irq_flags & IRQF_TRIGGER_HIGH)\n\t\t\tdata |= SDIO_CCCR_BRCM_SEPINT_ACT_HI;\n\t\tbrcmf_sdiod_func0_wb(sdiodev, SDIO_CCCR_BRCM_SEPINT,\n\t\t\t\t     data, &ret);\n\t\tsdio_release_host(sdiodev->func1);\n\t} else {\n\t\tbrcmf_dbg(SDIO, \"Entering\\n\");\n\t\tsdio_claim_host(sdiodev->func1);\n\t\tsdio_claim_irq(sdiodev->func1, brcmf_sdiod_ib_irqhandler);\n\t\tsdio_claim_irq(sdiodev->func2, brcmf_sdiod_dummy_irqhandler);\n\t\tsdio_release_host(sdiodev->func1);\n\t\tsdiodev->sd_irq_requested = true;\n\t}\n\n\treturn 0;\n}\n\nvoid brcmf_sdiod_intr_unregister(struct brcmf_sdio_dev *sdiodev)\n{\n\n\tbrcmf_dbg(SDIO, \"Entering oob=%d sd=%d\\n\",\n\t\t  sdiodev->oob_irq_requested,\n\t\t  sdiodev->sd_irq_requested);\n\n\tif (sdiodev->oob_irq_requested) {\n\t\tstruct brcmfmac_sdio_pd *pdata;\n\n\t\tpdata = &sdiodev->settings->bus.sdio;\n\t\tsdio_claim_host(sdiodev->func1);\n\t\tbrcmf_sdiod_func0_wb(sdiodev, SDIO_CCCR_BRCM_SEPINT, 0, NULL);\n\t\tbrcmf_sdiod_func0_wb(sdiodev, SDIO_CCCR_IENx, 0, NULL);\n\t\tsdio_release_host(sdiodev->func1);\n\n\t\tsdiodev->oob_irq_requested = false;\n\t\tfree_irq(pdata->oob_irq_nr, &sdiodev->func1->dev);\n\t\tsdiodev->irq_en = false;\n\t\tsdiodev->oob_irq_requested = false;\n\t}\n\n\tif (sdiodev->sd_irq_requested) {\n\t\tsdio_claim_host(sdiodev->func1);\n\t\tsdio_release_irq(sdiodev->func2);\n\t\tsdio_release_irq(sdiodev->func1);\n\t\tsdio_release_host(sdiodev->func1);\n\t\tsdiodev->sd_irq_requested = false;\n\t}\n}\n\nvoid brcmf_sdiod_change_state(struct brcmf_sdio_dev *sdiodev,\n\t\t\t      enum brcmf_sdiod_state state)\n{\n\tif (sdiodev->state == BRCMF_SDIOD_NOMEDIUM ||\n\t    state == sdiodev->state)\n\t\treturn;\n\n\tbrcmf_dbg(TRACE, \"%d -> %d\\n\", sdiodev->state, state);\n\tswitch (sdiodev->state) {\n\tcase BRCMF_SDIOD_DATA:\n\t\t \n\t\tbrcmf_bus_change_state(sdiodev->bus_if, BRCMF_BUS_DOWN);\n\t\tbreak;\n\tcase BRCMF_SDIOD_DOWN:\n\t\t \n\t\tif (state == BRCMF_SDIOD_DATA)\n\t\t\tbrcmf_bus_change_state(sdiodev->bus_if, BRCMF_BUS_UP);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tsdiodev->state = state;\n}\n\nstatic int brcmf_sdiod_set_backplane_window(struct brcmf_sdio_dev *sdiodev,\n\t\t\t\t\t    u32 addr)\n{\n\tu32 v, bar0 = addr & SBSDIO_SBWINDOW_MASK;\n\tint err = 0, i;\n\n\tif (bar0 == sdiodev->sbwad)\n\t\treturn 0;\n\n\tv = bar0 >> 8;\n\n\tfor (i = 0 ; i < 3 && !err ; i++, v >>= 8)\n\t\tbrcmf_sdiod_writeb(sdiodev, SBSDIO_FUNC1_SBADDRLOW + i,\n\t\t\t\t   v & 0xff, &err);\n\n\tif (!err)\n\t\tsdiodev->sbwad = bar0;\n\n\treturn err;\n}\n\nu32 brcmf_sdiod_readl(struct brcmf_sdio_dev *sdiodev, u32 addr, int *ret)\n{\n\tu32 data = 0;\n\tint retval;\n\n\tretval = brcmf_sdiod_set_backplane_window(sdiodev, addr);\n\tif (retval)\n\t\tgoto out;\n\n\taddr &= SBSDIO_SB_OFT_ADDR_MASK;\n\taddr |= SBSDIO_SB_ACCESS_2_4B_FLAG;\n\n\tdata = sdio_readl(sdiodev->func1, addr, &retval);\n\nout:\n\tif (ret)\n\t\t*ret = retval;\n\n\treturn data;\n}\n\nvoid brcmf_sdiod_writel(struct brcmf_sdio_dev *sdiodev, u32 addr,\n\t\t\tu32 data, int *ret)\n{\n\tint retval;\n\n\tretval = brcmf_sdiod_set_backplane_window(sdiodev, addr);\n\tif (retval)\n\t\tgoto out;\n\n\taddr &= SBSDIO_SB_OFT_ADDR_MASK;\n\taddr |= SBSDIO_SB_ACCESS_2_4B_FLAG;\n\n\tsdio_writel(sdiodev->func1, data, addr, &retval);\n\nout:\n\tif (ret)\n\t\t*ret = retval;\n}\n\nstatic int brcmf_sdiod_skbuff_read(struct brcmf_sdio_dev *sdiodev,\n\t\t\t\t   struct sdio_func *func, u32 addr,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tunsigned int req_sz;\n\tint err;\n\n\t \n\treq_sz = skb->len + 3;\n\treq_sz &= (uint)~3;\n\n\tswitch (func->num) {\n\tcase 1:\n\t\terr = sdio_memcpy_fromio(func, ((u8 *)(skb->data)), addr,\n\t\t\t\t\t req_sz);\n\t\tbreak;\n\tcase 2:\n\t\terr = sdio_readsb(func, ((u8 *)(skb->data)), addr, req_sz);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARN(1, \"invalid sdio function number: %d\\n\", func->num);\n\t\terr = -ENOMEDIUM;\n\t}\n\n\tif (err == -ENOMEDIUM)\n\t\tbrcmf_sdiod_change_state(sdiodev, BRCMF_SDIOD_NOMEDIUM);\n\n\treturn err;\n}\n\nstatic int brcmf_sdiod_skbuff_write(struct brcmf_sdio_dev *sdiodev,\n\t\t\t\t    struct sdio_func *func, u32 addr,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tunsigned int req_sz;\n\tint err;\n\n\t \n\treq_sz = skb->len + 3;\n\treq_sz &= (uint)~3;\n\n\terr = sdio_memcpy_toio(func, addr, ((u8 *)(skb->data)), req_sz);\n\n\tif (err == -ENOMEDIUM)\n\t\tbrcmf_sdiod_change_state(sdiodev, BRCMF_SDIOD_NOMEDIUM);\n\n\treturn err;\n}\n\nstatic int mmc_submit_one(struct mmc_data *md, struct mmc_request *mr,\n\t\t\t  struct mmc_command *mc, int sg_cnt, int req_sz,\n\t\t\t  int func_blk_sz, u32 *addr,\n\t\t\t  struct brcmf_sdio_dev *sdiodev,\n\t\t\t  struct sdio_func *func, int write)\n{\n\tint ret;\n\n\tmd->sg_len = sg_cnt;\n\tmd->blocks = req_sz / func_blk_sz;\n\tmc->arg |= (*addr & 0x1FFFF) << 9;\t \n\tmc->arg |= md->blocks & 0x1FF;\t \n\t \n\tif (func->num == 1)\n\t\t*addr += req_sz;\n\n\tmmc_set_data_timeout(md, func->card);\n\tmmc_wait_for_req(func->card->host, mr);\n\n\tret = mc->error ? mc->error : md->error;\n\tif (ret == -ENOMEDIUM) {\n\t\tbrcmf_sdiod_change_state(sdiodev, BRCMF_SDIOD_NOMEDIUM);\n\t} else if (ret != 0) {\n\t\tbrcmf_err(\"CMD53 sg block %s failed %d\\n\",\n\t\t\t  write ? \"write\" : \"read\", ret);\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int brcmf_sdiod_sglist_rw(struct brcmf_sdio_dev *sdiodev,\n\t\t\t\t struct sdio_func *func,\n\t\t\t\t bool write, u32 addr,\n\t\t\t\t struct sk_buff_head *pktlist)\n{\n\tunsigned int req_sz, func_blk_sz, sg_cnt, sg_data_sz, pkt_offset;\n\tunsigned int max_req_sz, src_offset, dst_offset;\n\tunsigned char *pkt_data, *orig_data, *dst_data;\n\tstruct sk_buff_head local_list, *target_list;\n\tstruct sk_buff *pkt_next = NULL, *src;\n\tunsigned short max_seg_cnt;\n\tstruct mmc_request mmc_req;\n\tstruct mmc_command mmc_cmd;\n\tstruct mmc_data mmc_dat;\n\tstruct scatterlist *sgl;\n\tint ret = 0;\n\n\tif (!pktlist->qlen)\n\t\treturn -EINVAL;\n\n\ttarget_list = pktlist;\n\t \n\t__skb_queue_head_init(&local_list);\n\tif (!write && sdiodev->settings->bus.sdio.broken_sg_support) {\n\t\treq_sz = 0;\n\t\tskb_queue_walk(pktlist, pkt_next)\n\t\t\treq_sz += pkt_next->len;\n\t\treq_sz = ALIGN(req_sz, func->cur_blksize);\n\t\twhile (req_sz > PAGE_SIZE) {\n\t\t\tpkt_next = brcmu_pkt_buf_get_skb(PAGE_SIZE);\n\t\t\tif (pkt_next == NULL) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\t__skb_queue_tail(&local_list, pkt_next);\n\t\t\treq_sz -= PAGE_SIZE;\n\t\t}\n\t\tpkt_next = brcmu_pkt_buf_get_skb(req_sz);\n\t\tif (pkt_next == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t\t__skb_queue_tail(&local_list, pkt_next);\n\t\ttarget_list = &local_list;\n\t}\n\n\tfunc_blk_sz = func->cur_blksize;\n\tmax_req_sz = sdiodev->max_request_size;\n\tmax_seg_cnt = min_t(unsigned short, sdiodev->max_segment_count,\n\t\t\t    target_list->qlen);\n\n\tmemset(&mmc_req, 0, sizeof(struct mmc_request));\n\tmemset(&mmc_cmd, 0, sizeof(struct mmc_command));\n\tmemset(&mmc_dat, 0, sizeof(struct mmc_data));\n\n\tmmc_dat.sg = sdiodev->sgtable.sgl;\n\tmmc_dat.blksz = func_blk_sz;\n\tmmc_dat.flags = write ? MMC_DATA_WRITE : MMC_DATA_READ;\n\tmmc_cmd.opcode = SD_IO_RW_EXTENDED;\n\tmmc_cmd.arg = write ? 1<<31 : 0;\t \n\tmmc_cmd.arg |= (func->num & 0x7) << 28;\t \n\tmmc_cmd.arg |= 1 << 27;\t\t\t \n\t \n\tmmc_cmd.arg |= (func->num == 1) ? 1 << 26 : 0;\n\tmmc_cmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_ADTC;\n\tmmc_req.cmd = &mmc_cmd;\n\tmmc_req.data = &mmc_dat;\n\n\treq_sz = 0;\n\tsg_cnt = 0;\n\tsgl = sdiodev->sgtable.sgl;\n\tskb_queue_walk(target_list, pkt_next) {\n\t\tpkt_offset = 0;\n\t\twhile (pkt_offset < pkt_next->len) {\n\t\t\tpkt_data = pkt_next->data + pkt_offset;\n\t\t\tsg_data_sz = pkt_next->len - pkt_offset;\n\t\t\tif (sg_data_sz > sdiodev->max_segment_size)\n\t\t\t\tsg_data_sz = sdiodev->max_segment_size;\n\t\t\tif (sg_data_sz > max_req_sz - req_sz)\n\t\t\t\tsg_data_sz = max_req_sz - req_sz;\n\n\t\t\tsg_set_buf(sgl, pkt_data, sg_data_sz);\n\t\t\tsg_cnt++;\n\n\t\t\tsgl = sg_next(sgl);\n\t\t\treq_sz += sg_data_sz;\n\t\t\tpkt_offset += sg_data_sz;\n\t\t\tif (req_sz >= max_req_sz || sg_cnt >= max_seg_cnt) {\n\t\t\t\tret = mmc_submit_one(&mmc_dat, &mmc_req, &mmc_cmd,\n\t\t\t\t\t\t     sg_cnt, req_sz, func_blk_sz,\n\t\t\t\t\t\t     &addr, sdiodev, func, write);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto exit_queue_walk;\n\t\t\t\treq_sz = 0;\n\t\t\t\tsg_cnt = 0;\n\t\t\t\tsgl = sdiodev->sgtable.sgl;\n\t\t\t}\n\t\t}\n\t}\n\tif (sg_cnt)\n\t\tret = mmc_submit_one(&mmc_dat, &mmc_req, &mmc_cmd,\n\t\t\t\t     sg_cnt, req_sz, func_blk_sz,\n\t\t\t\t     &addr, sdiodev, func, write);\nexit_queue_walk:\n\tif (!write && sdiodev->settings->bus.sdio.broken_sg_support) {\n\t\tsrc = __skb_peek(&local_list);\n\t\tsrc_offset = 0;\n\t\tskb_queue_walk(pktlist, pkt_next) {\n\t\t\tdst_offset = 0;\n\n\t\t\t \n\t\t\twhile (1) {\n\t\t\t\treq_sz = pkt_next->len - dst_offset;\n\t\t\t\tif (req_sz > src->len - src_offset)\n\t\t\t\t\treq_sz = src->len - src_offset;\n\n\t\t\t\torig_data = src->data + src_offset;\n\t\t\t\tdst_data = pkt_next->data + dst_offset;\n\t\t\t\tmemcpy(dst_data, orig_data, req_sz);\n\n\t\t\t\tsrc_offset += req_sz;\n\t\t\t\tif (src_offset == src->len) {\n\t\t\t\t\tsrc_offset = 0;\n\t\t\t\t\tsrc = skb_peek_next(src, &local_list);\n\t\t\t\t}\n\t\t\t\tdst_offset += req_sz;\n\t\t\t\tif (dst_offset == pkt_next->len)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\nexit:\n\tsg_init_table(sdiodev->sgtable.sgl, sdiodev->sgtable.orig_nents);\n\twhile ((pkt_next = __skb_dequeue(&local_list)) != NULL)\n\t\tbrcmu_pkt_buf_free_skb(pkt_next);\n\n\treturn ret;\n}\n\nint brcmf_sdiod_recv_buf(struct brcmf_sdio_dev *sdiodev, u8 *buf, uint nbytes)\n{\n\tstruct sk_buff *mypkt;\n\tint err;\n\n\tmypkt = brcmu_pkt_buf_get_skb(nbytes);\n\tif (!mypkt) {\n\t\tbrcmf_err(\"brcmu_pkt_buf_get_skb failed: len %d\\n\",\n\t\t\t  nbytes);\n\t\treturn -EIO;\n\t}\n\n\terr = brcmf_sdiod_recv_pkt(sdiodev, mypkt);\n\tif (!err)\n\t\tmemcpy(buf, mypkt->data, nbytes);\n\n\tbrcmu_pkt_buf_free_skb(mypkt);\n\treturn err;\n}\n\nint brcmf_sdiod_recv_pkt(struct brcmf_sdio_dev *sdiodev, struct sk_buff *pkt)\n{\n\tu32 addr = sdiodev->cc_core->base;\n\tint err = 0;\n\n\tbrcmf_dbg(SDIO, \"addr = 0x%x, size = %d\\n\", addr, pkt->len);\n\n\terr = brcmf_sdiod_set_backplane_window(sdiodev, addr);\n\tif (err)\n\t\tgoto done;\n\n\taddr &= SBSDIO_SB_OFT_ADDR_MASK;\n\taddr |= SBSDIO_SB_ACCESS_2_4B_FLAG;\n\n\terr = brcmf_sdiod_skbuff_read(sdiodev, sdiodev->func2, addr, pkt);\n\ndone:\n\treturn err;\n}\n\nint brcmf_sdiod_recv_chain(struct brcmf_sdio_dev *sdiodev,\n\t\t\t   struct sk_buff_head *pktq, uint totlen)\n{\n\tstruct sk_buff *glom_skb = NULL;\n\tstruct sk_buff *skb;\n\tu32 addr = sdiodev->cc_core->base;\n\tint err = 0;\n\n\tbrcmf_dbg(SDIO, \"addr = 0x%x, size = %d\\n\",\n\t\t  addr, pktq->qlen);\n\n\terr = brcmf_sdiod_set_backplane_window(sdiodev, addr);\n\tif (err)\n\t\tgoto done;\n\n\taddr &= SBSDIO_SB_OFT_ADDR_MASK;\n\taddr |= SBSDIO_SB_ACCESS_2_4B_FLAG;\n\n\tif (pktq->qlen == 1)\n\t\terr = brcmf_sdiod_skbuff_read(sdiodev, sdiodev->func2, addr,\n\t\t\t\t\t      __skb_peek(pktq));\n\telse if (!sdiodev->sg_support) {\n\t\tglom_skb = brcmu_pkt_buf_get_skb(totlen);\n\t\tif (!glom_skb)\n\t\t\treturn -ENOMEM;\n\t\terr = brcmf_sdiod_skbuff_read(sdiodev, sdiodev->func2, addr,\n\t\t\t\t\t      glom_skb);\n\t\tif (err)\n\t\t\tgoto done;\n\n\t\tskb_queue_walk(pktq, skb) {\n\t\t\tmemcpy(skb->data, glom_skb->data, skb->len);\n\t\t\tskb_pull(glom_skb, skb->len);\n\t\t}\n\t} else\n\t\terr = brcmf_sdiod_sglist_rw(sdiodev, sdiodev->func2, false,\n\t\t\t\t\t    addr, pktq);\n\ndone:\n\tbrcmu_pkt_buf_free_skb(glom_skb);\n\treturn err;\n}\n\nint brcmf_sdiod_send_buf(struct brcmf_sdio_dev *sdiodev, u8 *buf, uint nbytes)\n{\n\tstruct sk_buff *mypkt;\n\tu32 addr = sdiodev->cc_core->base;\n\tint err;\n\n\tmypkt = brcmu_pkt_buf_get_skb(nbytes);\n\n\tif (!mypkt) {\n\t\tbrcmf_err(\"brcmu_pkt_buf_get_skb failed: len %d\\n\",\n\t\t\t  nbytes);\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(mypkt->data, buf, nbytes);\n\n\terr = brcmf_sdiod_set_backplane_window(sdiodev, addr);\n\tif (err)\n\t\tgoto out;\n\n\taddr &= SBSDIO_SB_OFT_ADDR_MASK;\n\taddr |= SBSDIO_SB_ACCESS_2_4B_FLAG;\n\n\terr = brcmf_sdiod_skbuff_write(sdiodev, sdiodev->func2, addr, mypkt);\nout:\n\tbrcmu_pkt_buf_free_skb(mypkt);\n\n\treturn err;\n}\n\nint brcmf_sdiod_send_pkt(struct brcmf_sdio_dev *sdiodev,\n\t\t\t struct sk_buff_head *pktq)\n{\n\tstruct sk_buff *skb;\n\tu32 addr = sdiodev->cc_core->base;\n\tint err;\n\n\tbrcmf_dbg(SDIO, \"addr = 0x%x, size = %d\\n\", addr, pktq->qlen);\n\n\terr = brcmf_sdiod_set_backplane_window(sdiodev, addr);\n\tif (err)\n\t\treturn err;\n\n\taddr &= SBSDIO_SB_OFT_ADDR_MASK;\n\taddr |= SBSDIO_SB_ACCESS_2_4B_FLAG;\n\n\tif (pktq->qlen == 1 || !sdiodev->sg_support) {\n\t\tskb_queue_walk(pktq, skb) {\n\t\t\terr = brcmf_sdiod_skbuff_write(sdiodev, sdiodev->func2,\n\t\t\t\t\t\t       addr, skb);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\terr = brcmf_sdiod_sglist_rw(sdiodev, sdiodev->func2, true,\n\t\t\t\t\t    addr, pktq);\n\t}\n\n\treturn err;\n}\n\nint\nbrcmf_sdiod_ramrw(struct brcmf_sdio_dev *sdiodev, bool write, u32 address,\n\t\t  u8 *data, uint size)\n{\n\tint err = 0;\n\tstruct sk_buff *pkt;\n\tu32 sdaddr;\n\tuint dsize;\n\n\tdsize = min_t(uint, SBSDIO_SB_OFT_ADDR_LIMIT, size);\n\tpkt = dev_alloc_skb(dsize);\n\tif (!pkt) {\n\t\tbrcmf_err(\"dev_alloc_skb failed: len %d\\n\", dsize);\n\t\treturn -EIO;\n\t}\n\tpkt->priority = 0;\n\n\t \n\tsdaddr = address & SBSDIO_SB_OFT_ADDR_MASK;\n\tif ((sdaddr + size) & SBSDIO_SBWINDOW_MASK)\n\t\tdsize = (SBSDIO_SB_OFT_ADDR_LIMIT - sdaddr);\n\telse\n\t\tdsize = size;\n\n\tsdio_claim_host(sdiodev->func1);\n\n\t \n\twhile (size) {\n\t\t \n\t\terr = brcmf_sdiod_set_backplane_window(sdiodev, address);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tbrcmf_dbg(SDIO, \"%s %d bytes at offset 0x%08x in window 0x%08x\\n\",\n\t\t\t  write ? \"write\" : \"read\", dsize,\n\t\t\t  sdaddr, address & SBSDIO_SBWINDOW_MASK);\n\n\t\tsdaddr &= SBSDIO_SB_OFT_ADDR_MASK;\n\t\tsdaddr |= SBSDIO_SB_ACCESS_2_4B_FLAG;\n\n\t\tskb_put(pkt, dsize);\n\n\t\tif (write) {\n\t\t\tmemcpy(pkt->data, data, dsize);\n\t\t\terr = brcmf_sdiod_skbuff_write(sdiodev, sdiodev->func1,\n\t\t\t\t\t\t       sdaddr, pkt);\n\t\t} else {\n\t\t\terr = brcmf_sdiod_skbuff_read(sdiodev, sdiodev->func1,\n\t\t\t\t\t\t      sdaddr, pkt);\n\t\t}\n\n\t\tif (err) {\n\t\t\tbrcmf_err(\"membytes transfer failed\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (!write)\n\t\t\tmemcpy(data, pkt->data, dsize);\n\t\tskb_trim(pkt, 0);\n\n\t\t \n\t\tsize -= dsize;\n\t\tif (size) {\n\t\t\tdata += dsize;\n\t\t\taddress += dsize;\n\t\t\tsdaddr = 0;\n\t\t\tdsize = min_t(uint, SBSDIO_SB_OFT_ADDR_LIMIT, size);\n\t\t}\n\t}\n\n\tdev_kfree_skb(pkt);\n\n\tsdio_release_host(sdiodev->func1);\n\n\treturn err;\n}\n\nint brcmf_sdiod_abort(struct brcmf_sdio_dev *sdiodev, struct sdio_func *func)\n{\n\tbrcmf_dbg(SDIO, \"Enter\\n\");\n\n\t \n\tbrcmf_sdiod_func0_wb(sdiodev, SDIO_CCCR_ABORT, func->num, NULL);\n\n\tbrcmf_dbg(SDIO, \"Exit\\n\");\n\treturn 0;\n}\n\nvoid brcmf_sdiod_sgtable_alloc(struct brcmf_sdio_dev *sdiodev)\n{\n\tstruct sdio_func *func;\n\tstruct mmc_host *host;\n\tuint max_blocks;\n\tuint nents;\n\tint err;\n\n\tfunc = sdiodev->func2;\n\thost = func->card->host;\n\tsdiodev->sg_support = host->max_segs > 1;\n\tmax_blocks = min_t(uint, host->max_blk_count, 511u);\n\tsdiodev->max_request_size = min_t(uint, host->max_req_size,\n\t\t\t\t\t  max_blocks * func->cur_blksize);\n\tsdiodev->max_segment_count = min_t(uint, host->max_segs,\n\t\t\t\t\t   SG_MAX_SINGLE_ALLOC);\n\tsdiodev->max_segment_size = host->max_seg_size;\n\n\tif (!sdiodev->sg_support)\n\t\treturn;\n\n\tnents = max_t(uint, BRCMF_DEFAULT_RXGLOM_SIZE,\n\t\t      sdiodev->settings->bus.sdio.txglomsz);\n\tnents += (nents >> 4) + 1;\n\n\tWARN_ON(nents > sdiodev->max_segment_count);\n\n\tbrcmf_dbg(TRACE, \"nents=%d\\n\", nents);\n\terr = sg_alloc_table(&sdiodev->sgtable, nents, GFP_KERNEL);\n\tif (err < 0) {\n\t\tbrcmf_err(\"allocation failed: disable scatter-gather\");\n\t\tsdiodev->sg_support = false;\n\t}\n\n\tsdiodev->txglomsz = sdiodev->settings->bus.sdio.txglomsz;\n}\n\nstatic int brcmf_sdiod_freezer_attach(struct brcmf_sdio_dev *sdiodev)\n{\n\tif (!IS_ENABLED(CONFIG_PM_SLEEP))\n\t\treturn 0;\n\n\tsdiodev->freezer = kzalloc(sizeof(*sdiodev->freezer), GFP_KERNEL);\n\tif (!sdiodev->freezer)\n\t\treturn -ENOMEM;\n\tatomic_set(&sdiodev->freezer->thread_count, 0);\n\tatomic_set(&sdiodev->freezer->freezing, 0);\n\tinit_waitqueue_head(&sdiodev->freezer->thread_freeze);\n\tinit_completion(&sdiodev->freezer->resumed);\n\treturn 0;\n}\n\nstatic void brcmf_sdiod_freezer_detach(struct brcmf_sdio_dev *sdiodev)\n{\n\tif (sdiodev->freezer) {\n\t\tWARN_ON(atomic_read(&sdiodev->freezer->freezing));\n\t\tkfree(sdiodev->freezer);\n\t\tsdiodev->freezer = NULL;\n\t}\n}\n\nstatic int brcmf_sdiod_freezer_on(struct brcmf_sdio_dev *sdiodev)\n{\n\tatomic_t *expect = &sdiodev->freezer->thread_count;\n\tint res = 0;\n\n\tsdiodev->freezer->frozen_count = 0;\n\treinit_completion(&sdiodev->freezer->resumed);\n\tatomic_set(&sdiodev->freezer->freezing, 1);\n\tbrcmf_sdio_trigger_dpc(sdiodev->bus);\n\twait_event(sdiodev->freezer->thread_freeze,\n\t\t   atomic_read(expect) == sdiodev->freezer->frozen_count);\n\tsdio_claim_host(sdiodev->func1);\n\tres = brcmf_sdio_sleep(sdiodev->bus, true);\n\tsdio_release_host(sdiodev->func1);\n\treturn res;\n}\n\nstatic void brcmf_sdiod_freezer_off(struct brcmf_sdio_dev *sdiodev)\n{\n\tsdio_claim_host(sdiodev->func1);\n\tbrcmf_sdio_sleep(sdiodev->bus, false);\n\tsdio_release_host(sdiodev->func1);\n\tatomic_set(&sdiodev->freezer->freezing, 0);\n\tcomplete_all(&sdiodev->freezer->resumed);\n}\n\nbool brcmf_sdiod_freezing(struct brcmf_sdio_dev *sdiodev)\n{\n\treturn IS_ENABLED(CONFIG_PM_SLEEP) &&\n\t\tatomic_read(&sdiodev->freezer->freezing);\n}\n\nvoid brcmf_sdiod_try_freeze(struct brcmf_sdio_dev *sdiodev)\n{\n\tif (!brcmf_sdiod_freezing(sdiodev))\n\t\treturn;\n\tsdiodev->freezer->frozen_count++;\n\twake_up(&sdiodev->freezer->thread_freeze);\n\twait_for_completion(&sdiodev->freezer->resumed);\n}\n\nvoid brcmf_sdiod_freezer_count(struct brcmf_sdio_dev *sdiodev)\n{\n\tif (IS_ENABLED(CONFIG_PM_SLEEP))\n\t\tatomic_inc(&sdiodev->freezer->thread_count);\n}\n\nvoid brcmf_sdiod_freezer_uncount(struct brcmf_sdio_dev *sdiodev)\n{\n\tif (IS_ENABLED(CONFIG_PM_SLEEP))\n\t\tatomic_dec(&sdiodev->freezer->thread_count);\n}\n\nint brcmf_sdiod_remove(struct brcmf_sdio_dev *sdiodev)\n{\n\tsdiodev->state = BRCMF_SDIOD_DOWN;\n\tif (sdiodev->bus) {\n\t\tbrcmf_sdio_remove(sdiodev->bus);\n\t\tsdiodev->bus = NULL;\n\t}\n\n\tbrcmf_sdiod_freezer_detach(sdiodev);\n\n\t \n\tsdio_claim_host(sdiodev->func1);\n\tsdio_disable_func(sdiodev->func2);\n\tsdio_disable_func(sdiodev->func1);\n\tsdio_release_host(sdiodev->func1);\n\n\tsg_free_table(&sdiodev->sgtable);\n\tsdiodev->sbwad = 0;\n\n\tpm_runtime_allow(sdiodev->func1->card->host->parent);\n\treturn 0;\n}\n\nstatic void brcmf_sdiod_host_fixup(struct mmc_host *host)\n{\n\t \n\tpm_runtime_forbid(host->parent);\n\t \n\thost->caps |= MMC_CAP_NONREMOVABLE;\n}\n\nint brcmf_sdiod_probe(struct brcmf_sdio_dev *sdiodev)\n{\n\tint ret = 0;\n\tunsigned int f2_blksz = SDIO_FUNC2_BLOCKSIZE;\n\n\tsdio_claim_host(sdiodev->func1);\n\n\tret = sdio_set_block_size(sdiodev->func1, SDIO_FUNC1_BLOCKSIZE);\n\tif (ret) {\n\t\tbrcmf_err(\"Failed to set F1 blocksize\\n\");\n\t\tsdio_release_host(sdiodev->func1);\n\t\treturn ret;\n\t}\n\tswitch (sdiodev->func2->device) {\n\tcase SDIO_DEVICE_ID_BROADCOM_CYPRESS_4373:\n\t\tf2_blksz = SDIO_4373_FUNC2_BLOCKSIZE;\n\t\tbreak;\n\tcase SDIO_DEVICE_ID_BROADCOM_4359:\n\tcase SDIO_DEVICE_ID_BROADCOM_4354:\n\tcase SDIO_DEVICE_ID_BROADCOM_4356:\n\t\tf2_blksz = SDIO_435X_FUNC2_BLOCKSIZE;\n\t\tbreak;\n\tcase SDIO_DEVICE_ID_BROADCOM_4329:\n\t\tf2_blksz = SDIO_4329_FUNC2_BLOCKSIZE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tret = sdio_set_block_size(sdiodev->func2, f2_blksz);\n\tif (ret) {\n\t\tbrcmf_err(\"Failed to set F2 blocksize\\n\");\n\t\tsdio_release_host(sdiodev->func1);\n\t\treturn ret;\n\t} else {\n\t\tbrcmf_dbg(SDIO, \"set F2 blocksize to %d\\n\", f2_blksz);\n\t}\n\n\t \n\tsdiodev->func2->enable_timeout = SDIO_WAIT_F2RDY;\n\n\t \n\tret = sdio_enable_func(sdiodev->func1);\n\tsdio_release_host(sdiodev->func1);\n\tif (ret) {\n\t\tbrcmf_err(\"Failed to enable F1: err=%d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = brcmf_sdiod_freezer_attach(sdiodev);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tsdiodev->bus = brcmf_sdio_probe(sdiodev);\n\tif (!sdiodev->bus) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tbrcmf_sdiod_host_fixup(sdiodev->func2->card->host);\nout:\n\tif (ret)\n\t\tbrcmf_sdiod_remove(sdiodev);\n\n\treturn ret;\n}\n\n#define BRCMF_SDIO_DEVICE(dev_id, fw_vend) \\\n\t{ \\\n\t\tSDIO_DEVICE(SDIO_VENDOR_ID_BROADCOM, dev_id), \\\n\t\t.driver_data = BRCMF_FWVENDOR_ ## fw_vend \\\n\t}\n\n#define CYW_SDIO_DEVICE(dev_id, fw_vend) \\\n\t{ \\\n\t\tSDIO_DEVICE(SDIO_VENDOR_ID_CYPRESS, dev_id), \\\n\t\t.driver_data = BRCMF_FWVENDOR_ ## fw_vend \\\n\t}\n\n \nstatic const struct sdio_device_id brcmf_sdmmc_ids[] = {\n\tBRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_43143, WCC),\n\tBRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_43241, WCC),\n\tBRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_4329, WCC),\n\tBRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_4330, WCC),\n\tBRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_4334, WCC),\n\tBRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_43340, WCC),\n\tBRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_43341, WCC),\n\tBRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_43362, WCC),\n\tBRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_43364, WCC),\n\tBRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_4335_4339, WCC),\n\tBRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_4339, WCC),\n\tBRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_43430, WCC),\n\tBRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_43439, WCC),\n\tBRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_4345, WCC),\n\tBRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_43455, WCC),\n\tBRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_4354, WCC),\n\tBRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_4356, WCC),\n\tBRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_4359, WCC),\n\tBRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_CYPRESS_4373, CYW),\n\tBRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_CYPRESS_43012, CYW),\n\tBRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_CYPRESS_43752, CYW),\n\tBRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_CYPRESS_89359, CYW),\n\tCYW_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_CYPRESS_43439, CYW),\n\t{   }\n};\nMODULE_DEVICE_TABLE(sdio, brcmf_sdmmc_ids);\n\n\nstatic void brcmf_sdiod_acpi_save_power_manageable(struct brcmf_sdio_dev *sdiodev)\n{\n#if IS_ENABLED(CONFIG_ACPI)\n\tstruct acpi_device *adev;\n\n\tadev = ACPI_COMPANION(&sdiodev->func1->dev);\n\tif (adev)\n\t\tsdiodev->func1_power_manageable = adev->flags.power_manageable;\n\n\tadev = ACPI_COMPANION(&sdiodev->func2->dev);\n\tif (adev)\n\t\tsdiodev->func2_power_manageable = adev->flags.power_manageable;\n#endif\n}\n\nstatic void brcmf_sdiod_acpi_set_power_manageable(struct brcmf_sdio_dev *sdiodev,\n\t\t\t\t\t\t  int enable)\n{\n#if IS_ENABLED(CONFIG_ACPI)\n\tstruct acpi_device *adev;\n\n\tadev = ACPI_COMPANION(&sdiodev->func1->dev);\n\tif (adev)\n\t\tadev->flags.power_manageable = enable ? sdiodev->func1_power_manageable : 0;\n\n\tadev = ACPI_COMPANION(&sdiodev->func2->dev);\n\tif (adev)\n\t\tadev->flags.power_manageable = enable ? sdiodev->func2_power_manageable : 0;\n#endif\n}\n\nstatic int brcmf_ops_sdio_probe(struct sdio_func *func,\n\t\t\t\tconst struct sdio_device_id *id)\n{\n\tint err;\n\tstruct brcmf_sdio_dev *sdiodev;\n\tstruct brcmf_bus *bus_if;\n\n\tif (!id) {\n\t\tdev_err(&func->dev, \"Error no sdio_device_id passed for %x:%x\\n\", func->vendor, func->device);\n\t\treturn -ENODEV;\n\t}\n\n\tbrcmf_dbg(SDIO, \"Enter\\n\");\n\tbrcmf_dbg(SDIO, \"Class=%x\\n\", func->class);\n\tbrcmf_dbg(SDIO, \"sdio vendor ID: 0x%04x\\n\", func->vendor);\n\tbrcmf_dbg(SDIO, \"sdio device ID: 0x%04x\\n\", func->device);\n\tbrcmf_dbg(SDIO, \"Function#: %d\\n\", func->num);\n\n\t \n\tfunc->card->quirks |= MMC_QUIRK_LENIENT_FN0;\n\n\t \n\tif (func->num == 1)\n\t\treturn 0;\n\n\t \n\tif (func->num != 2)\n\t\treturn -ENODEV;\n\n\tbus_if = kzalloc(sizeof(struct brcmf_bus), GFP_KERNEL);\n\tif (!bus_if)\n\t\treturn -ENOMEM;\n\tsdiodev = kzalloc(sizeof(struct brcmf_sdio_dev), GFP_KERNEL);\n\tif (!sdiodev) {\n\t\tkfree(bus_if);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tsdiodev->func1 = func->card->sdio_func[0];\n\tsdiodev->func2 = func;\n\n\tsdiodev->bus_if = bus_if;\n\tbus_if->bus_priv.sdio = sdiodev;\n\tbus_if->proto_type = BRCMF_PROTO_BCDC;\n\tbus_if->fwvid = id->driver_data;\n\tdev_set_drvdata(&func->dev, bus_if);\n\tdev_set_drvdata(&sdiodev->func1->dev, bus_if);\n\tsdiodev->dev = &sdiodev->func1->dev;\n\n\tbrcmf_sdiod_acpi_save_power_manageable(sdiodev);\n\tbrcmf_sdiod_change_state(sdiodev, BRCMF_SDIOD_DOWN);\n\n\tbrcmf_dbg(SDIO, \"F2 found, calling brcmf_sdiod_probe...\\n\");\n\terr = brcmf_sdiod_probe(sdiodev);\n\tif (err) {\n\t\tbrcmf_err(\"F2 error, probe failed %d...\\n\", err);\n\t\tgoto fail;\n\t}\n\n\tbrcmf_dbg(SDIO, \"F2 init completed...\\n\");\n\treturn 0;\n\nfail:\n\tdev_set_drvdata(&func->dev, NULL);\n\tdev_set_drvdata(&sdiodev->func1->dev, NULL);\n\tkfree(sdiodev);\n\tkfree(bus_if);\n\treturn err;\n}\n\nstatic void brcmf_ops_sdio_remove(struct sdio_func *func)\n{\n\tstruct brcmf_bus *bus_if;\n\tstruct brcmf_sdio_dev *sdiodev;\n\n\tbrcmf_dbg(SDIO, \"Enter\\n\");\n\tbrcmf_dbg(SDIO, \"sdio vendor ID: 0x%04x\\n\", func->vendor);\n\tbrcmf_dbg(SDIO, \"sdio device ID: 0x%04x\\n\", func->device);\n\tbrcmf_dbg(SDIO, \"Function: %d\\n\", func->num);\n\n\tbus_if = dev_get_drvdata(&func->dev);\n\tif (bus_if) {\n\t\tsdiodev = bus_if->bus_priv.sdio;\n\n\t\t \n\t\tbrcmf_sdiod_intr_unregister(sdiodev);\n\n\t\tif (func->num != 1)\n\t\t\treturn;\n\n\t\t \n\t\tbrcmf_sdiod_remove(sdiodev);\n\n\t\tdev_set_drvdata(&sdiodev->func1->dev, NULL);\n\t\tdev_set_drvdata(&sdiodev->func2->dev, NULL);\n\n\t\tkfree(bus_if);\n\t\tkfree(sdiodev);\n\t}\n\n\tbrcmf_dbg(SDIO, \"Exit\\n\");\n}\n\nvoid brcmf_sdio_wowl_config(struct device *dev, bool enabled)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;\n\tmmc_pm_flag_t pm_caps = sdio_get_host_pm_caps(sdiodev->func1);\n\n\t \n\tif (!(pm_caps & MMC_PM_KEEP_POWER))\n\t\tgoto notsup;\n\n\tif (sdiodev->settings->bus.sdio.oob_irq_supported ||\n\t    pm_caps & MMC_PM_WAKE_SDIO_IRQ) {\n\t\t \n\t\tbrcmf_sdiod_acpi_set_power_manageable(sdiodev, !enabled);\n\t\tsdiodev->wowl_enabled = enabled;\n\t\tbrcmf_dbg(SDIO, \"Configuring WOWL, enabled=%d\\n\", enabled);\n\t\treturn;\n\t}\n\nnotsup:\n\tbrcmf_dbg(SDIO, \"WOWL not supported\\n\");\n}\n\nstatic int brcmf_ops_sdio_suspend(struct device *dev)\n{\n\tstruct sdio_func *func;\n\tstruct brcmf_bus *bus_if;\n\tstruct brcmf_sdio_dev *sdiodev;\n\tmmc_pm_flag_t sdio_flags;\n\tint ret = 0;\n\n\tfunc = container_of(dev, struct sdio_func, dev);\n\tbrcmf_dbg(SDIO, \"Enter: F%d\\n\", func->num);\n\tif (func->num != 1)\n\t\treturn 0;\n\n\n\tbus_if = dev_get_drvdata(dev);\n\tsdiodev = bus_if->bus_priv.sdio;\n\n\tif (sdiodev->wowl_enabled) {\n\t\tbrcmf_sdiod_freezer_on(sdiodev);\n\t\tbrcmf_sdio_wd_timer(sdiodev->bus, 0);\n\n\t\tsdio_flags = MMC_PM_KEEP_POWER;\n\t\tif (sdiodev->settings->bus.sdio.oob_irq_supported)\n\t\t\tenable_irq_wake(sdiodev->settings->bus.sdio.oob_irq_nr);\n\t\telse\n\t\t\tsdio_flags |= MMC_PM_WAKE_SDIO_IRQ;\n\n\t\tif (sdio_set_host_pm_flags(sdiodev->func1, sdio_flags))\n\t\t\tbrcmf_err(\"Failed to set pm_flags %x\\n\", sdio_flags);\n\n\t} else {\n\t\t \n\t\tbrcmf_sdiod_intr_unregister(sdiodev);\n\t\tret = brcmf_sdiod_remove(sdiodev);\n\t\tif (ret)\n\t\t\tbrcmf_err(\"Failed to remove device on suspend\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic int brcmf_ops_sdio_resume(struct device *dev)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;\n\tstruct sdio_func *func = container_of(dev, struct sdio_func, dev);\n\tint ret = 0;\n\n\tbrcmf_dbg(SDIO, \"Enter: F%d\\n\", func->num);\n\tif (func->num != 2)\n\t\treturn 0;\n\n\tif (!sdiodev->wowl_enabled) {\n\t\t \n\t\tret = brcmf_sdiod_probe(sdiodev);\n\t\tif (ret)\n\t\t\tbrcmf_err(\"Failed to probe device on resume\\n\");\n\t} else {\n\t\tif (sdiodev->settings->bus.sdio.oob_irq_supported)\n\t\t\tdisable_irq_wake(sdiodev->settings->bus.sdio.oob_irq_nr);\n\n\t\tbrcmf_sdiod_freezer_off(sdiodev);\n\t}\n\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(brcmf_sdio_pm_ops,\n\t\t\t\tbrcmf_ops_sdio_suspend,\n\t\t\t\tbrcmf_ops_sdio_resume);\n\nstatic struct sdio_driver brcmf_sdmmc_driver = {\n\t.probe = brcmf_ops_sdio_probe,\n\t.remove = brcmf_ops_sdio_remove,\n\t.name = KBUILD_MODNAME,\n\t.id_table = brcmf_sdmmc_ids,\n\t.drv = {\n\t\t.owner = THIS_MODULE,\n\t\t.pm = pm_sleep_ptr(&brcmf_sdio_pm_ops),\n\t\t.coredump = brcmf_dev_coredump,\n\t},\n};\n\nint brcmf_sdio_register(void)\n{\n\treturn sdio_register_driver(&brcmf_sdmmc_driver);\n}\n\nvoid brcmf_sdio_exit(void)\n{\n\tbrcmf_dbg(SDIO, \"Enter\\n\");\n\n\tsdio_unregister_driver(&brcmf_sdmmc_driver);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}