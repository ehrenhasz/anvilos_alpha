{
  "module_name": "msgbuf.c",
  "hash_id": "bd98a030bee6bd680d49edd459ff5575994c01b56177df4b762ba4a35362ec69",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/types.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n\n#include <brcmu_utils.h>\n#include <brcmu_wifi.h>\n\n#include \"core.h\"\n#include \"debug.h\"\n#include \"proto.h\"\n#include \"msgbuf.h\"\n#include \"commonring.h\"\n#include \"flowring.h\"\n#include \"bus.h\"\n#include \"tracepoint.h\"\n\n\n#define MSGBUF_IOCTL_RESP_TIMEOUT\t\tmsecs_to_jiffies(2000)\n\n#define MSGBUF_TYPE_GEN_STATUS\t\t\t0x1\n#define MSGBUF_TYPE_RING_STATUS\t\t\t0x2\n#define MSGBUF_TYPE_FLOW_RING_CREATE\t\t0x3\n#define MSGBUF_TYPE_FLOW_RING_CREATE_CMPLT\t0x4\n#define MSGBUF_TYPE_FLOW_RING_DELETE\t\t0x5\n#define MSGBUF_TYPE_FLOW_RING_DELETE_CMPLT\t0x6\n#define MSGBUF_TYPE_FLOW_RING_FLUSH\t\t0x7\n#define MSGBUF_TYPE_FLOW_RING_FLUSH_CMPLT\t0x8\n#define MSGBUF_TYPE_IOCTLPTR_REQ\t\t0x9\n#define MSGBUF_TYPE_IOCTLPTR_REQ_ACK\t\t0xA\n#define MSGBUF_TYPE_IOCTLRESP_BUF_POST\t\t0xB\n#define MSGBUF_TYPE_IOCTL_CMPLT\t\t\t0xC\n#define MSGBUF_TYPE_EVENT_BUF_POST\t\t0xD\n#define MSGBUF_TYPE_WL_EVENT\t\t\t0xE\n#define MSGBUF_TYPE_TX_POST\t\t\t0xF\n#define MSGBUF_TYPE_TX_STATUS\t\t\t0x10\n#define MSGBUF_TYPE_RXBUF_POST\t\t\t0x11\n#define MSGBUF_TYPE_RX_CMPLT\t\t\t0x12\n#define MSGBUF_TYPE_LPBK_DMAXFER\t\t0x13\n#define MSGBUF_TYPE_LPBK_DMAXFER_CMPLT\t\t0x14\n\n#define NR_TX_PKTIDS\t\t\t\t2048\n#define NR_RX_PKTIDS\t\t\t\t1024\n\n#define BRCMF_IOCTL_REQ_PKTID\t\t\t0xFFFE\n\n#define BRCMF_MSGBUF_MAX_PKT_SIZE\t\t2048\n#define BRCMF_MSGBUF_MAX_CTL_PKT_SIZE           8192\n#define BRCMF_MSGBUF_RXBUFPOST_THRESHOLD\t32\n#define BRCMF_MSGBUF_MAX_IOCTLRESPBUF_POST\t8\n#define BRCMF_MSGBUF_MAX_EVENTBUF_POST\t\t8\n\n#define BRCMF_MSGBUF_PKT_FLAGS_FRAME_802_3\t0x01\n#define BRCMF_MSGBUF_PKT_FLAGS_FRAME_802_11\t0x02\n#define BRCMF_MSGBUF_PKT_FLAGS_FRAME_MASK\t0x07\n#define BRCMF_MSGBUF_PKT_FLAGS_PRIO_SHIFT\t5\n\n#define BRCMF_MSGBUF_TX_FLUSH_CNT1\t\t32\n#define BRCMF_MSGBUF_TX_FLUSH_CNT2\t\t96\n\n#define BRCMF_MSGBUF_DELAY_TXWORKER_THRS\t96\n#define BRCMF_MSGBUF_TRICKLE_TXWORKER_THRS\t32\n#define BRCMF_MSGBUF_UPDATE_RX_PTR_THRS\t\t48\n\n#define BRCMF_MAX_TXSTATUS_WAIT_RETRIES\t\t10\n\nstruct msgbuf_common_hdr {\n\tu8\t\t\t\tmsgtype;\n\tu8\t\t\t\tifidx;\n\tu8\t\t\t\tflags;\n\tu8\t\t\t\trsvd0;\n\t__le32\t\t\t\trequest_id;\n};\n\nstruct msgbuf_ioctl_req_hdr {\n\tstruct msgbuf_common_hdr\tmsg;\n\t__le32\t\t\t\tcmd;\n\t__le16\t\t\t\ttrans_id;\n\t__le16\t\t\t\tinput_buf_len;\n\t__le16\t\t\t\toutput_buf_len;\n\t__le16\t\t\t\trsvd0[3];\n\tstruct msgbuf_buf_addr\t\treq_buf_addr;\n\t__le32\t\t\t\trsvd1[2];\n};\n\nstruct msgbuf_tx_msghdr {\n\tstruct msgbuf_common_hdr\tmsg;\n\tu8\t\t\t\ttxhdr[ETH_HLEN];\n\tu8\t\t\t\tflags;\n\tu8\t\t\t\tseg_cnt;\n\tstruct msgbuf_buf_addr\t\tmetadata_buf_addr;\n\tstruct msgbuf_buf_addr\t\tdata_buf_addr;\n\t__le16\t\t\t\tmetadata_buf_len;\n\t__le16\t\t\t\tdata_len;\n\t__le32\t\t\t\trsvd0;\n};\n\nstruct msgbuf_rx_bufpost {\n\tstruct msgbuf_common_hdr\tmsg;\n\t__le16\t\t\t\tmetadata_buf_len;\n\t__le16\t\t\t\tdata_buf_len;\n\t__le32\t\t\t\trsvd0;\n\tstruct msgbuf_buf_addr\t\tmetadata_buf_addr;\n\tstruct msgbuf_buf_addr\t\tdata_buf_addr;\n};\n\nstruct msgbuf_rx_ioctl_resp_or_event {\n\tstruct msgbuf_common_hdr\tmsg;\n\t__le16\t\t\t\thost_buf_len;\n\t__le16\t\t\t\trsvd0[3];\n\tstruct msgbuf_buf_addr\t\thost_buf_addr;\n\t__le32\t\t\t\trsvd1[4];\n};\n\nstruct msgbuf_completion_hdr {\n\t__le16\t\t\t\tstatus;\n\t__le16\t\t\t\tflow_ring_id;\n};\n\n \nstruct msgbuf_gen_status {\n\tstruct msgbuf_common_hdr\tmsg;\n\tstruct msgbuf_completion_hdr\tcompl_hdr;\n\t__le16\t\t\t\twrite_idx;\n\t__le32\t\t\t\trsvd0[3];\n};\n\n \nstruct msgbuf_ring_status {\n\tstruct msgbuf_common_hdr\tmsg;\n\tstruct msgbuf_completion_hdr\tcompl_hdr;\n\t__le16\t\t\t\twrite_idx;\n\t__le16\t\t\t\trsvd0[5];\n};\n\nstruct msgbuf_rx_event {\n\tstruct msgbuf_common_hdr\tmsg;\n\tstruct msgbuf_completion_hdr\tcompl_hdr;\n\t__le16\t\t\t\tevent_data_len;\n\t__le16\t\t\t\tseqnum;\n\t__le16\t\t\t\trsvd0[4];\n};\n\nstruct msgbuf_ioctl_resp_hdr {\n\tstruct msgbuf_common_hdr\tmsg;\n\tstruct msgbuf_completion_hdr\tcompl_hdr;\n\t__le16\t\t\t\tresp_len;\n\t__le16\t\t\t\ttrans_id;\n\t__le32\t\t\t\tcmd;\n\t__le32\t\t\t\trsvd0;\n};\n\nstruct msgbuf_tx_status {\n\tstruct msgbuf_common_hdr\tmsg;\n\tstruct msgbuf_completion_hdr\tcompl_hdr;\n\t__le16\t\t\t\tmetadata_len;\n\t__le16\t\t\t\ttx_status;\n};\n\nstruct msgbuf_rx_complete {\n\tstruct msgbuf_common_hdr\tmsg;\n\tstruct msgbuf_completion_hdr\tcompl_hdr;\n\t__le16\t\t\t\tmetadata_len;\n\t__le16\t\t\t\tdata_len;\n\t__le16\t\t\t\tdata_offset;\n\t__le16\t\t\t\tflags;\n\t__le32\t\t\t\trx_status_0;\n\t__le32\t\t\t\trx_status_1;\n\t__le32\t\t\t\trsvd0;\n};\n\nstruct msgbuf_tx_flowring_create_req {\n\tstruct msgbuf_common_hdr\tmsg;\n\tu8\t\t\t\tda[ETH_ALEN];\n\tu8\t\t\t\tsa[ETH_ALEN];\n\tu8\t\t\t\ttid;\n\tu8\t\t\t\tif_flags;\n\t__le16\t\t\t\tflow_ring_id;\n\tu8\t\t\t\ttc;\n\tu8\t\t\t\tpriority;\n\t__le16\t\t\t\tint_vector;\n\t__le16\t\t\t\tmax_items;\n\t__le16\t\t\t\tlen_item;\n\tstruct msgbuf_buf_addr\t\tflow_ring_addr;\n};\n\nstruct msgbuf_tx_flowring_delete_req {\n\tstruct msgbuf_common_hdr\tmsg;\n\t__le16\t\t\t\tflow_ring_id;\n\t__le16\t\t\t\treason;\n\t__le32\t\t\t\trsvd0[7];\n};\n\nstruct msgbuf_flowring_create_resp {\n\tstruct msgbuf_common_hdr\tmsg;\n\tstruct msgbuf_completion_hdr\tcompl_hdr;\n\t__le32\t\t\t\trsvd0[3];\n};\n\nstruct msgbuf_flowring_delete_resp {\n\tstruct msgbuf_common_hdr\tmsg;\n\tstruct msgbuf_completion_hdr\tcompl_hdr;\n\t__le32\t\t\t\trsvd0[3];\n};\n\nstruct msgbuf_flowring_flush_resp {\n\tstruct msgbuf_common_hdr\tmsg;\n\tstruct msgbuf_completion_hdr\tcompl_hdr;\n\t__le32\t\t\t\trsvd0[3];\n};\n\nstruct brcmf_msgbuf_work_item {\n\tstruct list_head queue;\n\tu32 flowid;\n\tint ifidx;\n\tu8 sa[ETH_ALEN];\n\tu8 da[ETH_ALEN];\n};\n\nstruct brcmf_msgbuf {\n\tstruct brcmf_pub *drvr;\n\n\tstruct brcmf_commonring **commonrings;\n\tstruct brcmf_commonring **flowrings;\n\tdma_addr_t *flowring_dma_handle;\n\n\tu16 max_flowrings;\n\tu16 max_submissionrings;\n\tu16 max_completionrings;\n\n\tu16 rx_dataoffset;\n\tu32 max_rxbufpost;\n\tu16 rx_metadata_offset;\n\tu32 rxbufpost;\n\n\tu32 max_ioctlrespbuf;\n\tu32 cur_ioctlrespbuf;\n\tu32 max_eventbuf;\n\tu32 cur_eventbuf;\n\n\tvoid *ioctbuf;\n\tdma_addr_t ioctbuf_handle;\n\tu32 ioctbuf_phys_hi;\n\tu32 ioctbuf_phys_lo;\n\tint ioctl_resp_status;\n\tu32 ioctl_resp_ret_len;\n\tu32 ioctl_resp_pktid;\n\n\tu16 data_seq_no;\n\tu16 ioctl_seq_no;\n\tu32 reqid;\n\twait_queue_head_t ioctl_resp_wait;\n\tbool ctl_completed;\n\n\tstruct brcmf_msgbuf_pktids *tx_pktids;\n\tstruct brcmf_msgbuf_pktids *rx_pktids;\n\tstruct brcmf_flowring *flow;\n\n\tstruct workqueue_struct *txflow_wq;\n\tstruct work_struct txflow_work;\n\tunsigned long *flow_map;\n\tunsigned long *txstatus_done_map;\n\n\tstruct work_struct flowring_work;\n\tspinlock_t flowring_work_lock;\n\tstruct list_head work_queue;\n};\n\nstruct brcmf_msgbuf_pktid {\n\tatomic_t  allocated;\n\tu16 data_offset;\n\tstruct sk_buff *skb;\n\tdma_addr_t physaddr;\n};\n\nstruct brcmf_msgbuf_pktids {\n\tu32 array_size;\n\tu32 last_allocated_idx;\n\tenum dma_data_direction direction;\n\tstruct brcmf_msgbuf_pktid *array;\n};\n\nstatic void brcmf_msgbuf_rxbuf_ioctlresp_post(struct brcmf_msgbuf *msgbuf);\n\n\nstatic struct brcmf_msgbuf_pktids *\nbrcmf_msgbuf_init_pktids(u32 nr_array_entries,\n\t\t\t enum dma_data_direction direction)\n{\n\tstruct brcmf_msgbuf_pktid *array;\n\tstruct brcmf_msgbuf_pktids *pktids;\n\n\tarray = kcalloc(nr_array_entries, sizeof(*array), GFP_KERNEL);\n\tif (!array)\n\t\treturn NULL;\n\n\tpktids = kzalloc(sizeof(*pktids), GFP_KERNEL);\n\tif (!pktids) {\n\t\tkfree(array);\n\t\treturn NULL;\n\t}\n\tpktids->array = array;\n\tpktids->array_size = nr_array_entries;\n\n\treturn pktids;\n}\n\n\nstatic int\nbrcmf_msgbuf_alloc_pktid(struct device *dev,\n\t\t\t struct brcmf_msgbuf_pktids *pktids,\n\t\t\t struct sk_buff *skb, u16 data_offset,\n\t\t\t dma_addr_t *physaddr, u32 *idx)\n{\n\tstruct brcmf_msgbuf_pktid *array;\n\tu32 count;\n\n\tarray = pktids->array;\n\n\t*physaddr = dma_map_single(dev, skb->data + data_offset,\n\t\t\t\t   skb->len - data_offset, pktids->direction);\n\n\tif (dma_mapping_error(dev, *physaddr)) {\n\t\tbrcmf_err(\"dma_map_single failed !!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t*idx = pktids->last_allocated_idx;\n\n\tcount = 0;\n\tdo {\n\t\t(*idx)++;\n\t\tif (*idx == pktids->array_size)\n\t\t\t*idx = 0;\n\t\tif (array[*idx].allocated.counter == 0)\n\t\t\tif (atomic_cmpxchg(&array[*idx].allocated, 0, 1) == 0)\n\t\t\t\tbreak;\n\t\tcount++;\n\t} while (count < pktids->array_size);\n\n\tif (count == pktids->array_size) {\n\t\tdma_unmap_single(dev, *physaddr, skb->len - data_offset,\n\t\t\t\t pktids->direction);\n\t\treturn -ENOMEM;\n\t}\n\n\tarray[*idx].data_offset = data_offset;\n\tarray[*idx].physaddr = *physaddr;\n\tarray[*idx].skb = skb;\n\n\tpktids->last_allocated_idx = *idx;\n\n\treturn 0;\n}\n\n\nstatic struct sk_buff *\nbrcmf_msgbuf_get_pktid(struct device *dev, struct brcmf_msgbuf_pktids *pktids,\n\t\t       u32 idx)\n{\n\tstruct brcmf_msgbuf_pktid *pktid;\n\tstruct sk_buff *skb;\n\n\tif (idx >= pktids->array_size) {\n\t\tbrcmf_err(\"Invalid packet id %d (max %d)\\n\", idx,\n\t\t\t  pktids->array_size);\n\t\treturn NULL;\n\t}\n\tif (pktids->array[idx].allocated.counter) {\n\t\tpktid = &pktids->array[idx];\n\t\tdma_unmap_single(dev, pktid->physaddr,\n\t\t\t\t pktid->skb->len - pktid->data_offset,\n\t\t\t\t pktids->direction);\n\t\tskb = pktid->skb;\n\t\tpktid->allocated.counter = 0;\n\t\treturn skb;\n\t} else {\n\t\tbrcmf_err(\"Invalid packet id %d (not in use)\\n\", idx);\n\t}\n\n\treturn NULL;\n}\n\n\nstatic void\nbrcmf_msgbuf_release_array(struct device *dev,\n\t\t\t   struct brcmf_msgbuf_pktids *pktids)\n{\n\tstruct brcmf_msgbuf_pktid *array;\n\tstruct brcmf_msgbuf_pktid *pktid;\n\tu32 count;\n\n\tarray = pktids->array;\n\tcount = 0;\n\tdo {\n\t\tif (array[count].allocated.counter) {\n\t\t\tpktid = &array[count];\n\t\t\tdma_unmap_single(dev, pktid->physaddr,\n\t\t\t\t\t pktid->skb->len - pktid->data_offset,\n\t\t\t\t\t pktids->direction);\n\t\t\tbrcmu_pkt_buf_free_skb(pktid->skb);\n\t\t}\n\t\tcount++;\n\t} while (count < pktids->array_size);\n\n\tkfree(array);\n\tkfree(pktids);\n}\n\n\nstatic void brcmf_msgbuf_release_pktids(struct brcmf_msgbuf *msgbuf)\n{\n\tif (msgbuf->rx_pktids)\n\t\tbrcmf_msgbuf_release_array(msgbuf->drvr->bus_if->dev,\n\t\t\t\t\t   msgbuf->rx_pktids);\n\tif (msgbuf->tx_pktids)\n\t\tbrcmf_msgbuf_release_array(msgbuf->drvr->bus_if->dev,\n\t\t\t\t\t   msgbuf->tx_pktids);\n}\n\n\nstatic int brcmf_msgbuf_tx_ioctl(struct brcmf_pub *drvr, int ifidx,\n\t\t\t\t uint cmd, void *buf, uint len)\n{\n\tstruct brcmf_msgbuf *msgbuf = (struct brcmf_msgbuf *)drvr->proto->pd;\n\tstruct brcmf_commonring *commonring;\n\tstruct msgbuf_ioctl_req_hdr *request;\n\tu16 buf_len;\n\tvoid *ret_ptr;\n\tint err;\n\n\tcommonring = msgbuf->commonrings[BRCMF_H2D_MSGRING_CONTROL_SUBMIT];\n\tbrcmf_commonring_lock(commonring);\n\tret_ptr = brcmf_commonring_reserve_for_write(commonring);\n\tif (!ret_ptr) {\n\t\tbphy_err(drvr, \"Failed to reserve space in commonring\\n\");\n\t\tbrcmf_commonring_unlock(commonring);\n\t\treturn -ENOMEM;\n\t}\n\n\tmsgbuf->reqid++;\n\n\trequest = (struct msgbuf_ioctl_req_hdr *)ret_ptr;\n\trequest->msg.msgtype = MSGBUF_TYPE_IOCTLPTR_REQ;\n\trequest->msg.ifidx = (u8)ifidx;\n\trequest->msg.flags = 0;\n\trequest->msg.request_id = cpu_to_le32(BRCMF_IOCTL_REQ_PKTID);\n\trequest->cmd = cpu_to_le32(cmd);\n\trequest->output_buf_len = cpu_to_le16(len);\n\trequest->trans_id = cpu_to_le16(msgbuf->reqid);\n\n\tbuf_len = min_t(u16, len, BRCMF_TX_IOCTL_MAX_MSG_SIZE);\n\trequest->input_buf_len = cpu_to_le16(buf_len);\n\trequest->req_buf_addr.high_addr = cpu_to_le32(msgbuf->ioctbuf_phys_hi);\n\trequest->req_buf_addr.low_addr = cpu_to_le32(msgbuf->ioctbuf_phys_lo);\n\tif (buf)\n\t\tmemcpy(msgbuf->ioctbuf, buf, buf_len);\n\telse\n\t\tmemset(msgbuf->ioctbuf, 0, buf_len);\n\n\terr = brcmf_commonring_write_complete(commonring);\n\tbrcmf_commonring_unlock(commonring);\n\n\treturn err;\n}\n\n\nstatic int brcmf_msgbuf_ioctl_resp_wait(struct brcmf_msgbuf *msgbuf)\n{\n\treturn wait_event_timeout(msgbuf->ioctl_resp_wait,\n\t\t\t\t  msgbuf->ctl_completed,\n\t\t\t\t  MSGBUF_IOCTL_RESP_TIMEOUT);\n}\n\n\nstatic void brcmf_msgbuf_ioctl_resp_wake(struct brcmf_msgbuf *msgbuf)\n{\n\tmsgbuf->ctl_completed = true;\n\twake_up(&msgbuf->ioctl_resp_wait);\n}\n\n\nstatic int brcmf_msgbuf_query_dcmd(struct brcmf_pub *drvr, int ifidx,\n\t\t\t\t   uint cmd, void *buf, uint len, int *fwerr)\n{\n\tstruct brcmf_msgbuf *msgbuf = (struct brcmf_msgbuf *)drvr->proto->pd;\n\tstruct sk_buff *skb = NULL;\n\tint timeout;\n\tint err;\n\n\tbrcmf_dbg(MSGBUF, \"ifidx=%d, cmd=%d, len=%d\\n\", ifidx, cmd, len);\n\t*fwerr = 0;\n\tmsgbuf->ctl_completed = false;\n\terr = brcmf_msgbuf_tx_ioctl(drvr, ifidx, cmd, buf, len);\n\tif (err)\n\t\treturn err;\n\n\ttimeout = brcmf_msgbuf_ioctl_resp_wait(msgbuf);\n\tif (!timeout) {\n\t\tbphy_err(drvr, \"Timeout on response for query command\\n\");\n\t\treturn -EIO;\n\t}\n\n\tskb = brcmf_msgbuf_get_pktid(msgbuf->drvr->bus_if->dev,\n\t\t\t\t     msgbuf->rx_pktids,\n\t\t\t\t     msgbuf->ioctl_resp_pktid);\n\tif (msgbuf->ioctl_resp_ret_len != 0) {\n\t\tif (!skb)\n\t\t\treturn -EBADF;\n\n\t\tmemcpy(buf, skb->data, (len < msgbuf->ioctl_resp_ret_len) ?\n\t\t\t\t       len : msgbuf->ioctl_resp_ret_len);\n\t}\n\tbrcmu_pkt_buf_free_skb(skb);\n\n\t*fwerr = msgbuf->ioctl_resp_status;\n\treturn 0;\n}\n\n\nstatic int brcmf_msgbuf_set_dcmd(struct brcmf_pub *drvr, int ifidx,\n\t\t\t\t uint cmd, void *buf, uint len, int *fwerr)\n{\n\treturn brcmf_msgbuf_query_dcmd(drvr, ifidx, cmd, buf, len, fwerr);\n}\n\n\nstatic int brcmf_msgbuf_hdrpull(struct brcmf_pub *drvr, bool do_fws,\n\t\t\t\tstruct sk_buff *skb, struct brcmf_if **ifp)\n{\n\treturn -ENODEV;\n}\n\nstatic void brcmf_msgbuf_rxreorder(struct brcmf_if *ifp, struct sk_buff *skb)\n{\n}\n\nstatic void\nbrcmf_msgbuf_remove_flowring(struct brcmf_msgbuf *msgbuf, u16 flowid)\n{\n\tu32 dma_sz;\n\tvoid *dma_buf;\n\n\tbrcmf_dbg(MSGBUF, \"Removing flowring %d\\n\", flowid);\n\n\tdma_sz = BRCMF_H2D_TXFLOWRING_MAX_ITEM * BRCMF_H2D_TXFLOWRING_ITEMSIZE;\n\tdma_buf = msgbuf->flowrings[flowid]->buf_addr;\n\tdma_free_coherent(msgbuf->drvr->bus_if->dev, dma_sz, dma_buf,\n\t\t\t  msgbuf->flowring_dma_handle[flowid]);\n\n\tbrcmf_flowring_delete(msgbuf->flow, flowid);\n}\n\n\nstatic struct brcmf_msgbuf_work_item *\nbrcmf_msgbuf_dequeue_work(struct brcmf_msgbuf *msgbuf)\n{\n\tstruct brcmf_msgbuf_work_item *work = NULL;\n\tulong flags;\n\n\tspin_lock_irqsave(&msgbuf->flowring_work_lock, flags);\n\tif (!list_empty(&msgbuf->work_queue)) {\n\t\twork = list_first_entry(&msgbuf->work_queue,\n\t\t\t\t\tstruct brcmf_msgbuf_work_item, queue);\n\t\tlist_del(&work->queue);\n\t}\n\tspin_unlock_irqrestore(&msgbuf->flowring_work_lock, flags);\n\n\treturn work;\n}\n\n\nstatic u32\nbrcmf_msgbuf_flowring_create_worker(struct brcmf_msgbuf *msgbuf,\n\t\t\t\t    struct brcmf_msgbuf_work_item *work)\n{\n\tstruct brcmf_pub *drvr = msgbuf->drvr;\n\tstruct msgbuf_tx_flowring_create_req *create;\n\tstruct brcmf_commonring *commonring;\n\tvoid *ret_ptr;\n\tu32 flowid;\n\tvoid *dma_buf;\n\tu32 dma_sz;\n\tu64 address;\n\tint err;\n\n\tflowid = work->flowid;\n\tdma_sz = BRCMF_H2D_TXFLOWRING_MAX_ITEM * BRCMF_H2D_TXFLOWRING_ITEMSIZE;\n\tdma_buf = dma_alloc_coherent(msgbuf->drvr->bus_if->dev, dma_sz,\n\t\t\t\t     &msgbuf->flowring_dma_handle[flowid],\n\t\t\t\t     GFP_KERNEL);\n\tif (!dma_buf) {\n\t\tbphy_err(drvr, \"dma_alloc_coherent failed\\n\");\n\t\tbrcmf_flowring_delete(msgbuf->flow, flowid);\n\t\treturn BRCMF_FLOWRING_INVALID_ID;\n\t}\n\n\tbrcmf_commonring_config(msgbuf->flowrings[flowid],\n\t\t\t\tBRCMF_H2D_TXFLOWRING_MAX_ITEM,\n\t\t\t\tBRCMF_H2D_TXFLOWRING_ITEMSIZE, dma_buf);\n\n\tcommonring = msgbuf->commonrings[BRCMF_H2D_MSGRING_CONTROL_SUBMIT];\n\tbrcmf_commonring_lock(commonring);\n\tret_ptr = brcmf_commonring_reserve_for_write(commonring);\n\tif (!ret_ptr) {\n\t\tbphy_err(drvr, \"Failed to reserve space in commonring\\n\");\n\t\tbrcmf_commonring_unlock(commonring);\n\t\tbrcmf_msgbuf_remove_flowring(msgbuf, flowid);\n\t\treturn BRCMF_FLOWRING_INVALID_ID;\n\t}\n\n\tcreate = (struct msgbuf_tx_flowring_create_req *)ret_ptr;\n\tcreate->msg.msgtype = MSGBUF_TYPE_FLOW_RING_CREATE;\n\tcreate->msg.ifidx = work->ifidx;\n\tcreate->msg.request_id = 0;\n\tcreate->tid = brcmf_flowring_tid(msgbuf->flow, flowid);\n\tcreate->flow_ring_id = cpu_to_le16(flowid +\n\t\t\t\t\t   BRCMF_H2D_MSGRING_FLOWRING_IDSTART);\n\tmemcpy(create->sa, work->sa, ETH_ALEN);\n\tmemcpy(create->da, work->da, ETH_ALEN);\n\taddress = (u64)msgbuf->flowring_dma_handle[flowid];\n\tcreate->flow_ring_addr.high_addr = cpu_to_le32(address >> 32);\n\tcreate->flow_ring_addr.low_addr = cpu_to_le32(address & 0xffffffff);\n\tcreate->max_items = cpu_to_le16(BRCMF_H2D_TXFLOWRING_MAX_ITEM);\n\tcreate->len_item = cpu_to_le16(BRCMF_H2D_TXFLOWRING_ITEMSIZE);\n\n\tbrcmf_dbg(MSGBUF, \"Send Flow Create Req flow ID %d for peer %pM prio %d ifindex %d\\n\",\n\t\t  flowid, work->da, create->tid, work->ifidx);\n\n\terr = brcmf_commonring_write_complete(commonring);\n\tbrcmf_commonring_unlock(commonring);\n\tif (err) {\n\t\tbphy_err(drvr, \"Failed to write commonring\\n\");\n\t\tbrcmf_msgbuf_remove_flowring(msgbuf, flowid);\n\t\treturn BRCMF_FLOWRING_INVALID_ID;\n\t}\n\n\treturn flowid;\n}\n\n\nstatic void brcmf_msgbuf_flowring_worker(struct work_struct *work)\n{\n\tstruct brcmf_msgbuf *msgbuf;\n\tstruct brcmf_msgbuf_work_item *create;\n\n\tmsgbuf = container_of(work, struct brcmf_msgbuf, flowring_work);\n\n\twhile ((create = brcmf_msgbuf_dequeue_work(msgbuf))) {\n\t\tbrcmf_msgbuf_flowring_create_worker(msgbuf, create);\n\t\tkfree(create);\n\t}\n}\n\n\nstatic u32 brcmf_msgbuf_flowring_create(struct brcmf_msgbuf *msgbuf, int ifidx,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct brcmf_msgbuf_work_item *create;\n\tstruct ethhdr *eh = (struct ethhdr *)(skb->data);\n\tu32 flowid;\n\tulong flags;\n\n\tcreate = kzalloc(sizeof(*create), GFP_ATOMIC);\n\tif (create == NULL)\n\t\treturn BRCMF_FLOWRING_INVALID_ID;\n\n\tflowid = brcmf_flowring_create(msgbuf->flow, eh->h_dest,\n\t\t\t\t       skb->priority, ifidx);\n\tif (flowid == BRCMF_FLOWRING_INVALID_ID) {\n\t\tkfree(create);\n\t\treturn flowid;\n\t}\n\n\tcreate->flowid = flowid;\n\tcreate->ifidx = ifidx;\n\tmemcpy(create->sa, eh->h_source, ETH_ALEN);\n\tmemcpy(create->da, eh->h_dest, ETH_ALEN);\n\n\tspin_lock_irqsave(&msgbuf->flowring_work_lock, flags);\n\tlist_add_tail(&create->queue, &msgbuf->work_queue);\n\tspin_unlock_irqrestore(&msgbuf->flowring_work_lock, flags);\n\tschedule_work(&msgbuf->flowring_work);\n\n\treturn flowid;\n}\n\n\nstatic void brcmf_msgbuf_txflow(struct brcmf_msgbuf *msgbuf, u16 flowid)\n{\n\tstruct brcmf_flowring *flow = msgbuf->flow;\n\tstruct brcmf_pub *drvr = msgbuf->drvr;\n\tstruct brcmf_commonring *commonring;\n\tvoid *ret_ptr;\n\tu32 count;\n\tstruct sk_buff *skb;\n\tdma_addr_t physaddr;\n\tu32 pktid;\n\tstruct msgbuf_tx_msghdr *tx_msghdr;\n\tu64 address;\n\n\tcommonring = msgbuf->flowrings[flowid];\n\tif (!brcmf_commonring_write_available(commonring))\n\t\treturn;\n\n\tbrcmf_commonring_lock(commonring);\n\n\tcount = BRCMF_MSGBUF_TX_FLUSH_CNT2 - BRCMF_MSGBUF_TX_FLUSH_CNT1;\n\twhile (brcmf_flowring_qlen(flow, flowid)) {\n\t\tskb = brcmf_flowring_dequeue(flow, flowid);\n\t\tif (skb == NULL) {\n\t\t\tbphy_err(drvr, \"No SKB, but qlen %d\\n\",\n\t\t\t\t brcmf_flowring_qlen(flow, flowid));\n\t\t\tbreak;\n\t\t}\n\t\tskb_orphan(skb);\n\t\tif (brcmf_msgbuf_alloc_pktid(msgbuf->drvr->bus_if->dev,\n\t\t\t\t\t     msgbuf->tx_pktids, skb, ETH_HLEN,\n\t\t\t\t\t     &physaddr, &pktid)) {\n\t\t\tbrcmf_flowring_reinsert(flow, flowid, skb);\n\t\t\tbphy_err(drvr, \"No PKTID available !!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tret_ptr = brcmf_commonring_reserve_for_write(commonring);\n\t\tif (!ret_ptr) {\n\t\t\tbrcmf_msgbuf_get_pktid(msgbuf->drvr->bus_if->dev,\n\t\t\t\t\t       msgbuf->tx_pktids, pktid);\n\t\t\tbrcmf_flowring_reinsert(flow, flowid, skb);\n\t\t\tbreak;\n\t\t}\n\t\tcount++;\n\n\t\ttx_msghdr = (struct msgbuf_tx_msghdr *)ret_ptr;\n\n\t\ttx_msghdr->msg.msgtype = MSGBUF_TYPE_TX_POST;\n\t\ttx_msghdr->msg.request_id = cpu_to_le32(pktid + 1);\n\t\ttx_msghdr->msg.ifidx = brcmf_flowring_ifidx_get(flow, flowid);\n\t\ttx_msghdr->flags = BRCMF_MSGBUF_PKT_FLAGS_FRAME_802_3;\n\t\ttx_msghdr->flags |= (skb->priority & 0x07) <<\n\t\t\t\t    BRCMF_MSGBUF_PKT_FLAGS_PRIO_SHIFT;\n\t\ttx_msghdr->seg_cnt = 1;\n\t\tmemcpy(tx_msghdr->txhdr, skb->data, ETH_HLEN);\n\t\ttx_msghdr->data_len = cpu_to_le16(skb->len - ETH_HLEN);\n\t\taddress = (u64)physaddr;\n\t\ttx_msghdr->data_buf_addr.high_addr = cpu_to_le32(address >> 32);\n\t\ttx_msghdr->data_buf_addr.low_addr =\n\t\t\tcpu_to_le32(address & 0xffffffff);\n\t\ttx_msghdr->metadata_buf_len = 0;\n\t\ttx_msghdr->metadata_buf_addr.high_addr = 0;\n\t\ttx_msghdr->metadata_buf_addr.low_addr = 0;\n\t\tatomic_inc(&commonring->outstanding_tx);\n\t\tif (count >= BRCMF_MSGBUF_TX_FLUSH_CNT2) {\n\t\t\tbrcmf_commonring_write_complete(commonring);\n\t\t\tcount = 0;\n\t\t}\n\t}\n\tif (count)\n\t\tbrcmf_commonring_write_complete(commonring);\n\tbrcmf_commonring_unlock(commonring);\n}\n\n\nstatic void brcmf_msgbuf_txflow_worker(struct work_struct *worker)\n{\n\tstruct brcmf_msgbuf *msgbuf;\n\tu32 flowid;\n\n\tmsgbuf = container_of(worker, struct brcmf_msgbuf, txflow_work);\n\tfor_each_set_bit(flowid, msgbuf->flow_map, msgbuf->max_flowrings) {\n\t\tclear_bit(flowid, msgbuf->flow_map);\n\t\tbrcmf_msgbuf_txflow(msgbuf, flowid);\n\t}\n}\n\n\nstatic int brcmf_msgbuf_schedule_txdata(struct brcmf_msgbuf *msgbuf, u32 flowid,\n\t\t\t\t\tbool force)\n{\n\tstruct brcmf_commonring *commonring;\n\n\tset_bit(flowid, msgbuf->flow_map);\n\tcommonring = msgbuf->flowrings[flowid];\n\tif ((force) || (atomic_read(&commonring->outstanding_tx) <\n\t\t\tBRCMF_MSGBUF_DELAY_TXWORKER_THRS))\n\t\tqueue_work(msgbuf->txflow_wq, &msgbuf->txflow_work);\n\n\treturn 0;\n}\n\n\nstatic int brcmf_msgbuf_tx_queue_data(struct brcmf_pub *drvr, int ifidx,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct brcmf_msgbuf *msgbuf = (struct brcmf_msgbuf *)drvr->proto->pd;\n\tstruct brcmf_flowring *flow = msgbuf->flow;\n\tstruct ethhdr *eh = (struct ethhdr *)(skb->data);\n\tu32 flowid;\n\tu32 queue_count;\n\tbool force;\n\n\tflowid = brcmf_flowring_lookup(flow, eh->h_dest, skb->priority, ifidx);\n\tif (flowid == BRCMF_FLOWRING_INVALID_ID) {\n\t\tflowid = brcmf_msgbuf_flowring_create(msgbuf, ifidx, skb);\n\t\tif (flowid == BRCMF_FLOWRING_INVALID_ID) {\n\t\t\treturn -ENOMEM;\n\t\t} else {\n\t\t\tbrcmf_flowring_enqueue(flow, flowid, skb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tqueue_count = brcmf_flowring_enqueue(flow, flowid, skb);\n\tforce = ((queue_count % BRCMF_MSGBUF_TRICKLE_TXWORKER_THRS) == 0);\n\tbrcmf_msgbuf_schedule_txdata(msgbuf, flowid, force);\n\n\treturn 0;\n}\n\n\nstatic void\nbrcmf_msgbuf_configure_addr_mode(struct brcmf_pub *drvr, int ifidx,\n\t\t\t\t enum proto_addr_mode addr_mode)\n{\n\tstruct brcmf_msgbuf *msgbuf = (struct brcmf_msgbuf *)drvr->proto->pd;\n\n\tbrcmf_flowring_configure_addr_mode(msgbuf->flow, ifidx, addr_mode);\n}\n\n\nstatic void\nbrcmf_msgbuf_delete_peer(struct brcmf_pub *drvr, int ifidx, u8 peer[ETH_ALEN])\n{\n\tstruct brcmf_msgbuf *msgbuf = (struct brcmf_msgbuf *)drvr->proto->pd;\n\n\tbrcmf_flowring_delete_peer(msgbuf->flow, ifidx, peer);\n}\n\n\nstatic void\nbrcmf_msgbuf_add_tdls_peer(struct brcmf_pub *drvr, int ifidx, u8 peer[ETH_ALEN])\n{\n\tstruct brcmf_msgbuf *msgbuf = (struct brcmf_msgbuf *)drvr->proto->pd;\n\n\tbrcmf_flowring_add_tdls_peer(msgbuf->flow, ifidx, peer);\n}\n\n\nstatic void\nbrcmf_msgbuf_process_ioctl_complete(struct brcmf_msgbuf *msgbuf, void *buf)\n{\n\tstruct msgbuf_ioctl_resp_hdr *ioctl_resp;\n\n\tioctl_resp = (struct msgbuf_ioctl_resp_hdr *)buf;\n\n\tmsgbuf->ioctl_resp_status =\n\t\t\t(s16)le16_to_cpu(ioctl_resp->compl_hdr.status);\n\tmsgbuf->ioctl_resp_ret_len = le16_to_cpu(ioctl_resp->resp_len);\n\tmsgbuf->ioctl_resp_pktid = le32_to_cpu(ioctl_resp->msg.request_id);\n\n\tbrcmf_msgbuf_ioctl_resp_wake(msgbuf);\n\n\tif (msgbuf->cur_ioctlrespbuf)\n\t\tmsgbuf->cur_ioctlrespbuf--;\n\tbrcmf_msgbuf_rxbuf_ioctlresp_post(msgbuf);\n}\n\n\nstatic void\nbrcmf_msgbuf_process_txstatus(struct brcmf_msgbuf *msgbuf, void *buf)\n{\n\tstruct brcmf_commonring *commonring;\n\tstruct msgbuf_tx_status *tx_status;\n\tu32 idx;\n\tstruct sk_buff *skb;\n\tu16 flowid;\n\n\ttx_status = (struct msgbuf_tx_status *)buf;\n\tidx = le32_to_cpu(tx_status->msg.request_id) - 1;\n\tflowid = le16_to_cpu(tx_status->compl_hdr.flow_ring_id);\n\tflowid -= BRCMF_H2D_MSGRING_FLOWRING_IDSTART;\n\tskb = brcmf_msgbuf_get_pktid(msgbuf->drvr->bus_if->dev,\n\t\t\t\t     msgbuf->tx_pktids, idx);\n\tif (!skb)\n\t\treturn;\n\n\tset_bit(flowid, msgbuf->txstatus_done_map);\n\tcommonring = msgbuf->flowrings[flowid];\n\tatomic_dec(&commonring->outstanding_tx);\n\n\tbrcmf_txfinalize(brcmf_get_ifp(msgbuf->drvr, tx_status->msg.ifidx),\n\t\t\t skb, true);\n}\n\n\nstatic u32 brcmf_msgbuf_rxbuf_data_post(struct brcmf_msgbuf *msgbuf, u32 count)\n{\n\tstruct brcmf_pub *drvr = msgbuf->drvr;\n\tstruct brcmf_commonring *commonring;\n\tvoid *ret_ptr;\n\tstruct sk_buff *skb;\n\tu16 alloced;\n\tu32 pktlen;\n\tdma_addr_t physaddr;\n\tstruct msgbuf_rx_bufpost *rx_bufpost;\n\tu64 address;\n\tu32 pktid;\n\tu32 i;\n\n\tcommonring = msgbuf->commonrings[BRCMF_H2D_MSGRING_RXPOST_SUBMIT];\n\tret_ptr = brcmf_commonring_reserve_for_write_multiple(commonring,\n\t\t\t\t\t\t\t      count,\n\t\t\t\t\t\t\t      &alloced);\n\tif (!ret_ptr) {\n\t\tbrcmf_dbg(MSGBUF, \"Failed to reserve space in commonring\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < alloced; i++) {\n\t\trx_bufpost = (struct msgbuf_rx_bufpost *)ret_ptr;\n\t\tmemset(rx_bufpost, 0, sizeof(*rx_bufpost));\n\n\t\tskb = brcmu_pkt_buf_get_skb(BRCMF_MSGBUF_MAX_PKT_SIZE);\n\n\t\tif (skb == NULL) {\n\t\t\tbphy_err(drvr, \"Failed to alloc SKB\\n\");\n\t\t\tbrcmf_commonring_write_cancel(commonring, alloced - i);\n\t\t\tbreak;\n\t\t}\n\n\t\tpktlen = skb->len;\n\t\tif (brcmf_msgbuf_alloc_pktid(msgbuf->drvr->bus_if->dev,\n\t\t\t\t\t     msgbuf->rx_pktids, skb, 0,\n\t\t\t\t\t     &physaddr, &pktid)) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tbphy_err(drvr, \"No PKTID available !!\\n\");\n\t\t\tbrcmf_commonring_write_cancel(commonring, alloced - i);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (msgbuf->rx_metadata_offset) {\n\t\t\taddress = (u64)physaddr;\n\t\t\trx_bufpost->metadata_buf_len =\n\t\t\t\tcpu_to_le16(msgbuf->rx_metadata_offset);\n\t\t\trx_bufpost->metadata_buf_addr.high_addr =\n\t\t\t\tcpu_to_le32(address >> 32);\n\t\t\trx_bufpost->metadata_buf_addr.low_addr =\n\t\t\t\tcpu_to_le32(address & 0xffffffff);\n\n\t\t\tskb_pull(skb, msgbuf->rx_metadata_offset);\n\t\t\tpktlen = skb->len;\n\t\t\tphysaddr += msgbuf->rx_metadata_offset;\n\t\t}\n\t\trx_bufpost->msg.msgtype = MSGBUF_TYPE_RXBUF_POST;\n\t\trx_bufpost->msg.request_id = cpu_to_le32(pktid);\n\n\t\taddress = (u64)physaddr;\n\t\trx_bufpost->data_buf_len = cpu_to_le16((u16)pktlen);\n\t\trx_bufpost->data_buf_addr.high_addr =\n\t\t\tcpu_to_le32(address >> 32);\n\t\trx_bufpost->data_buf_addr.low_addr =\n\t\t\tcpu_to_le32(address & 0xffffffff);\n\n\t\tret_ptr += brcmf_commonring_len_item(commonring);\n\t}\n\n\tif (i)\n\t\tbrcmf_commonring_write_complete(commonring);\n\n\treturn i;\n}\n\n\nstatic void\nbrcmf_msgbuf_rxbuf_data_fill(struct brcmf_msgbuf *msgbuf)\n{\n\tu32 fillbufs;\n\tu32 retcount;\n\n\tfillbufs = msgbuf->max_rxbufpost - msgbuf->rxbufpost;\n\n\twhile (fillbufs) {\n\t\tretcount = brcmf_msgbuf_rxbuf_data_post(msgbuf, fillbufs);\n\t\tif (!retcount)\n\t\t\tbreak;\n\t\tmsgbuf->rxbufpost += retcount;\n\t\tfillbufs -= retcount;\n\t}\n}\n\n\nstatic void\nbrcmf_msgbuf_update_rxbufpost_count(struct brcmf_msgbuf *msgbuf, u16 rxcnt)\n{\n\tmsgbuf->rxbufpost -= rxcnt;\n\tif (msgbuf->rxbufpost <= (msgbuf->max_rxbufpost -\n\t\t\t\t  BRCMF_MSGBUF_RXBUFPOST_THRESHOLD))\n\t\tbrcmf_msgbuf_rxbuf_data_fill(msgbuf);\n}\n\n\nstatic u32\nbrcmf_msgbuf_rxbuf_ctrl_post(struct brcmf_msgbuf *msgbuf, bool event_buf,\n\t\t\t     u32 count)\n{\n\tstruct brcmf_pub *drvr = msgbuf->drvr;\n\tstruct brcmf_commonring *commonring;\n\tvoid *ret_ptr;\n\tstruct sk_buff *skb;\n\tu16 alloced;\n\tu32 pktlen;\n\tdma_addr_t physaddr;\n\tstruct msgbuf_rx_ioctl_resp_or_event *rx_bufpost;\n\tu64 address;\n\tu32 pktid;\n\tu32 i;\n\n\tcommonring = msgbuf->commonrings[BRCMF_H2D_MSGRING_CONTROL_SUBMIT];\n\tbrcmf_commonring_lock(commonring);\n\tret_ptr = brcmf_commonring_reserve_for_write_multiple(commonring,\n\t\t\t\t\t\t\t      count,\n\t\t\t\t\t\t\t      &alloced);\n\tif (!ret_ptr) {\n\t\tbphy_err(drvr, \"Failed to reserve space in commonring\\n\");\n\t\tbrcmf_commonring_unlock(commonring);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < alloced; i++) {\n\t\trx_bufpost = (struct msgbuf_rx_ioctl_resp_or_event *)ret_ptr;\n\t\tmemset(rx_bufpost, 0, sizeof(*rx_bufpost));\n\n\t\tskb = brcmu_pkt_buf_get_skb(BRCMF_MSGBUF_MAX_CTL_PKT_SIZE);\n\n\t\tif (skb == NULL) {\n\t\t\tbphy_err(drvr, \"Failed to alloc SKB\\n\");\n\t\t\tbrcmf_commonring_write_cancel(commonring, alloced - i);\n\t\t\tbreak;\n\t\t}\n\n\t\tpktlen = skb->len;\n\t\tif (brcmf_msgbuf_alloc_pktid(msgbuf->drvr->bus_if->dev,\n\t\t\t\t\t     msgbuf->rx_pktids, skb, 0,\n\t\t\t\t\t     &physaddr, &pktid)) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tbphy_err(drvr, \"No PKTID available !!\\n\");\n\t\t\tbrcmf_commonring_write_cancel(commonring, alloced - i);\n\t\t\tbreak;\n\t\t}\n\t\tif (event_buf)\n\t\t\trx_bufpost->msg.msgtype = MSGBUF_TYPE_EVENT_BUF_POST;\n\t\telse\n\t\t\trx_bufpost->msg.msgtype =\n\t\t\t\tMSGBUF_TYPE_IOCTLRESP_BUF_POST;\n\t\trx_bufpost->msg.request_id = cpu_to_le32(pktid);\n\n\t\taddress = (u64)physaddr;\n\t\trx_bufpost->host_buf_len = cpu_to_le16((u16)pktlen);\n\t\trx_bufpost->host_buf_addr.high_addr =\n\t\t\tcpu_to_le32(address >> 32);\n\t\trx_bufpost->host_buf_addr.low_addr =\n\t\t\tcpu_to_le32(address & 0xffffffff);\n\n\t\tret_ptr += brcmf_commonring_len_item(commonring);\n\t}\n\n\tif (i)\n\t\tbrcmf_commonring_write_complete(commonring);\n\n\tbrcmf_commonring_unlock(commonring);\n\n\treturn i;\n}\n\n\nstatic void brcmf_msgbuf_rxbuf_ioctlresp_post(struct brcmf_msgbuf *msgbuf)\n{\n\tu32 count;\n\n\tcount = msgbuf->max_ioctlrespbuf - msgbuf->cur_ioctlrespbuf;\n\tcount = brcmf_msgbuf_rxbuf_ctrl_post(msgbuf, false, count);\n\tmsgbuf->cur_ioctlrespbuf += count;\n}\n\n\nstatic void brcmf_msgbuf_rxbuf_event_post(struct brcmf_msgbuf *msgbuf)\n{\n\tu32 count;\n\n\tcount = msgbuf->max_eventbuf - msgbuf->cur_eventbuf;\n\tcount = brcmf_msgbuf_rxbuf_ctrl_post(msgbuf, true, count);\n\tmsgbuf->cur_eventbuf += count;\n}\n\n\nstatic void brcmf_msgbuf_process_event(struct brcmf_msgbuf *msgbuf, void *buf)\n{\n\tstruct brcmf_pub *drvr = msgbuf->drvr;\n\tstruct msgbuf_rx_event *event;\n\tu32 idx;\n\tu16 buflen;\n\tstruct sk_buff *skb;\n\tstruct brcmf_if *ifp;\n\n\tevent = (struct msgbuf_rx_event *)buf;\n\tidx = le32_to_cpu(event->msg.request_id);\n\tbuflen = le16_to_cpu(event->event_data_len);\n\n\tif (msgbuf->cur_eventbuf)\n\t\tmsgbuf->cur_eventbuf--;\n\tbrcmf_msgbuf_rxbuf_event_post(msgbuf);\n\n\tskb = brcmf_msgbuf_get_pktid(msgbuf->drvr->bus_if->dev,\n\t\t\t\t     msgbuf->rx_pktids, idx);\n\tif (!skb)\n\t\treturn;\n\n\tif (msgbuf->rx_dataoffset)\n\t\tskb_pull(skb, msgbuf->rx_dataoffset);\n\n\tskb_trim(skb, buflen);\n\n\tifp = brcmf_get_ifp(msgbuf->drvr, event->msg.ifidx);\n\tif (!ifp || !ifp->ndev) {\n\t\tbphy_err(drvr, \"Received pkt for invalid ifidx %d\\n\",\n\t\t\t event->msg.ifidx);\n\t\tgoto exit;\n\t}\n\n\tskb->protocol = eth_type_trans(skb, ifp->ndev);\n\n\tbrcmf_fweh_process_skb(ifp->drvr, skb, 0, GFP_KERNEL);\n\nexit:\n\tbrcmu_pkt_buf_free_skb(skb);\n}\n\n\nstatic void\nbrcmf_msgbuf_process_rx_complete(struct brcmf_msgbuf *msgbuf, void *buf)\n{\n\tstruct brcmf_pub *drvr = msgbuf->drvr;\n\tstruct msgbuf_rx_complete *rx_complete;\n\tstruct sk_buff *skb;\n\tu16 data_offset;\n\tu16 buflen;\n\tu16 flags;\n\tu32 idx;\n\tstruct brcmf_if *ifp;\n\n\tbrcmf_msgbuf_update_rxbufpost_count(msgbuf, 1);\n\n\trx_complete = (struct msgbuf_rx_complete *)buf;\n\tdata_offset = le16_to_cpu(rx_complete->data_offset);\n\tbuflen = le16_to_cpu(rx_complete->data_len);\n\tidx = le32_to_cpu(rx_complete->msg.request_id);\n\tflags = le16_to_cpu(rx_complete->flags);\n\n\tskb = brcmf_msgbuf_get_pktid(msgbuf->drvr->bus_if->dev,\n\t\t\t\t     msgbuf->rx_pktids, idx);\n\tif (!skb)\n\t\treturn;\n\n\tif (data_offset)\n\t\tskb_pull(skb, data_offset);\n\telse if (msgbuf->rx_dataoffset)\n\t\tskb_pull(skb, msgbuf->rx_dataoffset);\n\n\tskb_trim(skb, buflen);\n\n\tif ((flags & BRCMF_MSGBUF_PKT_FLAGS_FRAME_MASK) ==\n\t    BRCMF_MSGBUF_PKT_FLAGS_FRAME_802_11) {\n\t\tifp = msgbuf->drvr->mon_if;\n\n\t\tif (!ifp) {\n\t\t\tbphy_err(drvr, \"Received unexpected monitor pkt\\n\");\n\t\t\tbrcmu_pkt_buf_free_skb(skb);\n\t\t\treturn;\n\t\t}\n\n\t\tbrcmf_netif_mon_rx(ifp, skb);\n\t\treturn;\n\t}\n\n\tifp = brcmf_get_ifp(msgbuf->drvr, rx_complete->msg.ifidx);\n\tif (!ifp || !ifp->ndev) {\n\t\tbphy_err(drvr, \"Received pkt for invalid ifidx %d\\n\",\n\t\t\t rx_complete->msg.ifidx);\n\t\tbrcmu_pkt_buf_free_skb(skb);\n\t\treturn;\n\t}\n\n\tskb->protocol = eth_type_trans(skb, ifp->ndev);\n\tbrcmf_netif_rx(ifp, skb);\n}\n\nstatic void brcmf_msgbuf_process_gen_status(struct brcmf_msgbuf *msgbuf,\n\t\t\t\t\t    void *buf)\n{\n\tstruct msgbuf_gen_status *gen_status = buf;\n\tstruct brcmf_pub *drvr = msgbuf->drvr;\n\tint err;\n\n\terr = le16_to_cpu(gen_status->compl_hdr.status);\n\tif (err)\n\t\tbphy_err(drvr, \"Firmware reported general error: %d\\n\", err);\n}\n\nstatic void brcmf_msgbuf_process_ring_status(struct brcmf_msgbuf *msgbuf,\n\t\t\t\t\t     void *buf)\n{\n\tstruct msgbuf_ring_status *ring_status = buf;\n\tstruct brcmf_pub *drvr = msgbuf->drvr;\n\tint err;\n\n\terr = le16_to_cpu(ring_status->compl_hdr.status);\n\tif (err) {\n\t\tint ring = le16_to_cpu(ring_status->compl_hdr.flow_ring_id);\n\n\t\tbphy_err(drvr, \"Firmware reported ring %d error: %d\\n\", ring,\n\t\t\t err);\n\t}\n}\n\nstatic void\nbrcmf_msgbuf_process_flow_ring_create_response(struct brcmf_msgbuf *msgbuf,\n\t\t\t\t\t       void *buf)\n{\n\tstruct brcmf_pub *drvr = msgbuf->drvr;\n\tstruct msgbuf_flowring_create_resp *flowring_create_resp;\n\tu16 status;\n\tu16 flowid;\n\n\tflowring_create_resp = (struct msgbuf_flowring_create_resp *)buf;\n\n\tflowid = le16_to_cpu(flowring_create_resp->compl_hdr.flow_ring_id);\n\tflowid -= BRCMF_H2D_MSGRING_FLOWRING_IDSTART;\n\tstatus =  le16_to_cpu(flowring_create_resp->compl_hdr.status);\n\n\tif (status) {\n\t\tbphy_err(drvr, \"Flowring creation failed, code %d\\n\", status);\n\t\tbrcmf_msgbuf_remove_flowring(msgbuf, flowid);\n\t\treturn;\n\t}\n\tbrcmf_dbg(MSGBUF, \"Flowring %d Create response status %d\\n\", flowid,\n\t\t  status);\n\n\tbrcmf_flowring_open(msgbuf->flow, flowid);\n\n\tbrcmf_msgbuf_schedule_txdata(msgbuf, flowid, true);\n}\n\n\nstatic void\nbrcmf_msgbuf_process_flow_ring_delete_response(struct brcmf_msgbuf *msgbuf,\n\t\t\t\t\t       void *buf)\n{\n\tstruct brcmf_pub *drvr = msgbuf->drvr;\n\tstruct msgbuf_flowring_delete_resp *flowring_delete_resp;\n\tu16 status;\n\tu16 flowid;\n\n\tflowring_delete_resp = (struct msgbuf_flowring_delete_resp *)buf;\n\n\tflowid = le16_to_cpu(flowring_delete_resp->compl_hdr.flow_ring_id);\n\tflowid -= BRCMF_H2D_MSGRING_FLOWRING_IDSTART;\n\tstatus =  le16_to_cpu(flowring_delete_resp->compl_hdr.status);\n\n\tif (status) {\n\t\tbphy_err(drvr, \"Flowring deletion failed, code %d\\n\", status);\n\t\tbrcmf_flowring_delete(msgbuf->flow, flowid);\n\t\treturn;\n\t}\n\tbrcmf_dbg(MSGBUF, \"Flowring %d Delete response status %d\\n\", flowid,\n\t\t  status);\n\n\tbrcmf_msgbuf_remove_flowring(msgbuf, flowid);\n}\n\n\nstatic void brcmf_msgbuf_process_msgtype(struct brcmf_msgbuf *msgbuf, void *buf)\n{\n\tstruct brcmf_pub *drvr = msgbuf->drvr;\n\tstruct msgbuf_common_hdr *msg;\n\n\tmsg = (struct msgbuf_common_hdr *)buf;\n\tswitch (msg->msgtype) {\n\tcase MSGBUF_TYPE_GEN_STATUS:\n\t\tbrcmf_dbg(MSGBUF, \"MSGBUF_TYPE_GEN_STATUS\\n\");\n\t\tbrcmf_msgbuf_process_gen_status(msgbuf, buf);\n\t\tbreak;\n\tcase MSGBUF_TYPE_RING_STATUS:\n\t\tbrcmf_dbg(MSGBUF, \"MSGBUF_TYPE_RING_STATUS\\n\");\n\t\tbrcmf_msgbuf_process_ring_status(msgbuf, buf);\n\t\tbreak;\n\tcase MSGBUF_TYPE_FLOW_RING_CREATE_CMPLT:\n\t\tbrcmf_dbg(MSGBUF, \"MSGBUF_TYPE_FLOW_RING_CREATE_CMPLT\\n\");\n\t\tbrcmf_msgbuf_process_flow_ring_create_response(msgbuf, buf);\n\t\tbreak;\n\tcase MSGBUF_TYPE_FLOW_RING_DELETE_CMPLT:\n\t\tbrcmf_dbg(MSGBUF, \"MSGBUF_TYPE_FLOW_RING_DELETE_CMPLT\\n\");\n\t\tbrcmf_msgbuf_process_flow_ring_delete_response(msgbuf, buf);\n\t\tbreak;\n\tcase MSGBUF_TYPE_IOCTLPTR_REQ_ACK:\n\t\tbrcmf_dbg(MSGBUF, \"MSGBUF_TYPE_IOCTLPTR_REQ_ACK\\n\");\n\t\tbreak;\n\tcase MSGBUF_TYPE_IOCTL_CMPLT:\n\t\tbrcmf_dbg(MSGBUF, \"MSGBUF_TYPE_IOCTL_CMPLT\\n\");\n\t\tbrcmf_msgbuf_process_ioctl_complete(msgbuf, buf);\n\t\tbreak;\n\tcase MSGBUF_TYPE_WL_EVENT:\n\t\tbrcmf_dbg(MSGBUF, \"MSGBUF_TYPE_WL_EVENT\\n\");\n\t\tbrcmf_msgbuf_process_event(msgbuf, buf);\n\t\tbreak;\n\tcase MSGBUF_TYPE_TX_STATUS:\n\t\tbrcmf_dbg(MSGBUF, \"MSGBUF_TYPE_TX_STATUS\\n\");\n\t\tbrcmf_msgbuf_process_txstatus(msgbuf, buf);\n\t\tbreak;\n\tcase MSGBUF_TYPE_RX_CMPLT:\n\t\tbrcmf_dbg(MSGBUF, \"MSGBUF_TYPE_RX_CMPLT\\n\");\n\t\tbrcmf_msgbuf_process_rx_complete(msgbuf, buf);\n\t\tbreak;\n\tdefault:\n\t\tbphy_err(drvr, \"Unsupported msgtype %d\\n\", msg->msgtype);\n\t\tbreak;\n\t}\n}\n\n\nstatic void brcmf_msgbuf_process_rx(struct brcmf_msgbuf *msgbuf,\n\t\t\t\t    struct brcmf_commonring *commonring)\n{\n\tvoid *buf;\n\tu16 count;\n\tu16 processed;\n\nagain:\n\tbuf = brcmf_commonring_get_read_ptr(commonring, &count);\n\tif (buf == NULL)\n\t\treturn;\n\n\tprocessed = 0;\n\twhile (count) {\n\t\tbrcmf_msgbuf_process_msgtype(msgbuf,\n\t\t\t\t\t     buf + msgbuf->rx_dataoffset);\n\t\tbuf += brcmf_commonring_len_item(commonring);\n\t\tprocessed++;\n\t\tif (processed == BRCMF_MSGBUF_UPDATE_RX_PTR_THRS) {\n\t\t\tbrcmf_commonring_read_complete(commonring, processed);\n\t\t\tprocessed = 0;\n\t\t}\n\t\tcount--;\n\t}\n\tif (processed)\n\t\tbrcmf_commonring_read_complete(commonring, processed);\n\n\tif (commonring->r_ptr == 0)\n\t\tgoto again;\n}\n\n\nint brcmf_proto_msgbuf_rx_trigger(struct device *dev)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_pub *drvr = bus_if->drvr;\n\tstruct brcmf_msgbuf *msgbuf = (struct brcmf_msgbuf *)drvr->proto->pd;\n\tstruct brcmf_commonring *commonring;\n\tvoid *buf;\n\tu32 flowid;\n\tint qlen;\n\n\tbuf = msgbuf->commonrings[BRCMF_D2H_MSGRING_RX_COMPLETE];\n\tbrcmf_msgbuf_process_rx(msgbuf, buf);\n\tbuf = msgbuf->commonrings[BRCMF_D2H_MSGRING_TX_COMPLETE];\n\tbrcmf_msgbuf_process_rx(msgbuf, buf);\n\tbuf = msgbuf->commonrings[BRCMF_D2H_MSGRING_CONTROL_COMPLETE];\n\tbrcmf_msgbuf_process_rx(msgbuf, buf);\n\n\tfor_each_set_bit(flowid, msgbuf->txstatus_done_map,\n\t\t\t msgbuf->max_flowrings) {\n\t\tclear_bit(flowid, msgbuf->txstatus_done_map);\n\t\tcommonring = msgbuf->flowrings[flowid];\n\t\tqlen = brcmf_flowring_qlen(msgbuf->flow, flowid);\n\t\tif ((qlen > BRCMF_MSGBUF_TRICKLE_TXWORKER_THRS) ||\n\t\t    ((qlen) && (atomic_read(&commonring->outstanding_tx) <\n\t\t\t\tBRCMF_MSGBUF_TRICKLE_TXWORKER_THRS)))\n\t\t\tbrcmf_msgbuf_schedule_txdata(msgbuf, flowid, true);\n\t}\n\n\treturn 0;\n}\n\n\nvoid brcmf_msgbuf_delete_flowring(struct brcmf_pub *drvr, u16 flowid)\n{\n\tstruct brcmf_msgbuf *msgbuf = (struct brcmf_msgbuf *)drvr->proto->pd;\n\tstruct msgbuf_tx_flowring_delete_req *delete;\n\tstruct brcmf_commonring *commonring;\n\tstruct brcmf_commonring *commonring_del = msgbuf->flowrings[flowid];\n\tstruct brcmf_flowring *flow = msgbuf->flow;\n\tvoid *ret_ptr;\n\tu8 ifidx;\n\tint err;\n\tint retry = BRCMF_MAX_TXSTATUS_WAIT_RETRIES;\n\n\t \n\tbrcmf_commonring_lock(commonring_del);\n\tflow->rings[flowid]->status = RING_CLOSING;\n\tbrcmf_commonring_unlock(commonring_del);\n\n\t \n\twhile (retry && atomic_read(&commonring_del->outstanding_tx)) {\n\t\tusleep_range(5000, 10000);\n\t\tretry--;\n\t}\n\tif (!retry) {\n\t\tbrcmf_err(\"timed out waiting for txstatus\\n\");\n\t\tatomic_set(&commonring_del->outstanding_tx, 0);\n\t}\n\n\t \n\tif (drvr->bus_if->state != BRCMF_BUS_UP) {\n\t\tbrcmf_dbg(MSGBUF, \"bus down, flowring will be removed\\n\");\n\t\tbrcmf_msgbuf_remove_flowring(msgbuf, flowid);\n\t\treturn;\n\t}\n\n\tcommonring = msgbuf->commonrings[BRCMF_H2D_MSGRING_CONTROL_SUBMIT];\n\tbrcmf_commonring_lock(commonring);\n\tret_ptr = brcmf_commonring_reserve_for_write(commonring);\n\tif (!ret_ptr) {\n\t\tbphy_err(drvr, \"FW unaware, flowring will be removed !!\\n\");\n\t\tbrcmf_commonring_unlock(commonring);\n\t\tbrcmf_msgbuf_remove_flowring(msgbuf, flowid);\n\t\treturn;\n\t}\n\n\tdelete = (struct msgbuf_tx_flowring_delete_req *)ret_ptr;\n\n\tifidx = brcmf_flowring_ifidx_get(msgbuf->flow, flowid);\n\n\tdelete->msg.msgtype = MSGBUF_TYPE_FLOW_RING_DELETE;\n\tdelete->msg.ifidx = ifidx;\n\tdelete->msg.request_id = 0;\n\n\tdelete->flow_ring_id = cpu_to_le16(flowid +\n\t\t\t\t\t   BRCMF_H2D_MSGRING_FLOWRING_IDSTART);\n\tdelete->reason = 0;\n\n\tbrcmf_dbg(MSGBUF, \"Send Flow Delete Req flow ID %d, ifindex %d\\n\",\n\t\t  flowid, ifidx);\n\n\terr = brcmf_commonring_write_complete(commonring);\n\tbrcmf_commonring_unlock(commonring);\n\tif (err) {\n\t\tbphy_err(drvr, \"Failed to submit RING_DELETE, flowring will be removed\\n\");\n\t\tbrcmf_msgbuf_remove_flowring(msgbuf, flowid);\n\t}\n}\n\n#ifdef DEBUG\nstatic int brcmf_msgbuf_stats_read(struct seq_file *seq, void *data)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(seq->private);\n\tstruct brcmf_pub *drvr = bus_if->drvr;\n\tstruct brcmf_msgbuf *msgbuf = (struct brcmf_msgbuf *)drvr->proto->pd;\n\tstruct brcmf_commonring *commonring;\n\tu16 i;\n\tstruct brcmf_flowring_ring *ring;\n\tstruct brcmf_flowring_hash *hash;\n\n\tcommonring = msgbuf->commonrings[BRCMF_H2D_MSGRING_CONTROL_SUBMIT];\n\tseq_printf(seq, \"h2d_ctl_submit: rp %4u, wp %4u, depth %4u\\n\",\n\t\t   commonring->r_ptr, commonring->w_ptr, commonring->depth);\n\tcommonring = msgbuf->commonrings[BRCMF_H2D_MSGRING_RXPOST_SUBMIT];\n\tseq_printf(seq, \"h2d_rx_submit:  rp %4u, wp %4u, depth %4u\\n\",\n\t\t   commonring->r_ptr, commonring->w_ptr, commonring->depth);\n\tcommonring = msgbuf->commonrings[BRCMF_D2H_MSGRING_CONTROL_COMPLETE];\n\tseq_printf(seq, \"d2h_ctl_cmplt:  rp %4u, wp %4u, depth %4u\\n\",\n\t\t   commonring->r_ptr, commonring->w_ptr, commonring->depth);\n\tcommonring = msgbuf->commonrings[BRCMF_D2H_MSGRING_TX_COMPLETE];\n\tseq_printf(seq, \"d2h_tx_cmplt:   rp %4u, wp %4u, depth %4u\\n\",\n\t\t   commonring->r_ptr, commonring->w_ptr, commonring->depth);\n\tcommonring = msgbuf->commonrings[BRCMF_D2H_MSGRING_RX_COMPLETE];\n\tseq_printf(seq, \"d2h_rx_cmplt:   rp %4u, wp %4u, depth %4u\\n\",\n\t\t   commonring->r_ptr, commonring->w_ptr, commonring->depth);\n\n\tseq_printf(seq, \"\\nh2d_flowrings: depth %u\\n\",\n\t\t   BRCMF_H2D_TXFLOWRING_MAX_ITEM);\n\tseq_puts(seq, \"Active flowrings:\\n\");\n\tfor (i = 0; i < msgbuf->flow->nrofrings; i++) {\n\t\tif (!msgbuf->flow->rings[i])\n\t\t\tcontinue;\n\t\tring = msgbuf->flow->rings[i];\n\t\tif (ring->status != RING_OPEN)\n\t\t\tcontinue;\n\t\tcommonring = msgbuf->flowrings[i];\n\t\thash = &msgbuf->flow->hash[ring->hash_id];\n\t\tseq_printf(seq, \"id %3u: rp %4u, wp %4u, qlen %4u, blocked %u\\n\"\n\t\t\t\t\"        ifidx %u, fifo %u, da %pM\\n\",\n\t\t\t\ti, commonring->r_ptr, commonring->w_ptr,\n\t\t\t\tskb_queue_len(&ring->skblist), ring->blocked,\n\t\t\t\thash->ifidx, hash->fifo, hash->mac);\n\t}\n\n\treturn 0;\n}\n#else\nstatic int brcmf_msgbuf_stats_read(struct seq_file *seq, void *data)\n{\n\treturn 0;\n}\n#endif\n\nstatic void brcmf_msgbuf_debugfs_create(struct brcmf_pub *drvr)\n{\n\tbrcmf_debugfs_add_entry(drvr, \"msgbuf_stats\", brcmf_msgbuf_stats_read);\n}\n\nint brcmf_proto_msgbuf_attach(struct brcmf_pub *drvr)\n{\n\tstruct brcmf_bus_msgbuf *if_msgbuf;\n\tstruct brcmf_msgbuf *msgbuf;\n\tu64 address;\n\tu32 count;\n\n\tif_msgbuf = drvr->bus_if->msgbuf;\n\n\tif (if_msgbuf->max_flowrings >= BRCMF_FLOWRING_HASHSIZE) {\n\t\tbphy_err(drvr, \"driver not configured for this many flowrings %d\\n\",\n\t\t\t if_msgbuf->max_flowrings);\n\t\tif_msgbuf->max_flowrings = BRCMF_FLOWRING_HASHSIZE - 1;\n\t}\n\n\tmsgbuf = kzalloc(sizeof(*msgbuf), GFP_KERNEL);\n\tif (!msgbuf)\n\t\tgoto fail;\n\n\tmsgbuf->txflow_wq = create_singlethread_workqueue(\"msgbuf_txflow\");\n\tif (msgbuf->txflow_wq == NULL) {\n\t\tbphy_err(drvr, \"workqueue creation failed\\n\");\n\t\tgoto fail;\n\t}\n\tINIT_WORK(&msgbuf->txflow_work, brcmf_msgbuf_txflow_worker);\n\tcount = BITS_TO_LONGS(if_msgbuf->max_flowrings);\n\tcount = count * sizeof(unsigned long);\n\tmsgbuf->flow_map = kzalloc(count, GFP_KERNEL);\n\tif (!msgbuf->flow_map)\n\t\tgoto fail;\n\n\tmsgbuf->txstatus_done_map = kzalloc(count, GFP_KERNEL);\n\tif (!msgbuf->txstatus_done_map)\n\t\tgoto fail;\n\n\tmsgbuf->drvr = drvr;\n\tmsgbuf->ioctbuf = dma_alloc_coherent(drvr->bus_if->dev,\n\t\t\t\t\t     BRCMF_TX_IOCTL_MAX_MSG_SIZE,\n\t\t\t\t\t     &msgbuf->ioctbuf_handle,\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!msgbuf->ioctbuf)\n\t\tgoto fail;\n\taddress = (u64)msgbuf->ioctbuf_handle;\n\tmsgbuf->ioctbuf_phys_hi = address >> 32;\n\tmsgbuf->ioctbuf_phys_lo = address & 0xffffffff;\n\n\tdrvr->proto->hdrpull = brcmf_msgbuf_hdrpull;\n\tdrvr->proto->query_dcmd = brcmf_msgbuf_query_dcmd;\n\tdrvr->proto->set_dcmd = brcmf_msgbuf_set_dcmd;\n\tdrvr->proto->tx_queue_data = brcmf_msgbuf_tx_queue_data;\n\tdrvr->proto->configure_addr_mode = brcmf_msgbuf_configure_addr_mode;\n\tdrvr->proto->delete_peer = brcmf_msgbuf_delete_peer;\n\tdrvr->proto->add_tdls_peer = brcmf_msgbuf_add_tdls_peer;\n\tdrvr->proto->rxreorder = brcmf_msgbuf_rxreorder;\n\tdrvr->proto->debugfs_create = brcmf_msgbuf_debugfs_create;\n\tdrvr->proto->pd = msgbuf;\n\n\tinit_waitqueue_head(&msgbuf->ioctl_resp_wait);\n\n\tmsgbuf->commonrings =\n\t\t(struct brcmf_commonring **)if_msgbuf->commonrings;\n\tmsgbuf->flowrings = (struct brcmf_commonring **)if_msgbuf->flowrings;\n\tmsgbuf->max_flowrings = if_msgbuf->max_flowrings;\n\tmsgbuf->flowring_dma_handle =\n\t\tkcalloc(msgbuf->max_flowrings,\n\t\t\tsizeof(*msgbuf->flowring_dma_handle), GFP_KERNEL);\n\tif (!msgbuf->flowring_dma_handle)\n\t\tgoto fail;\n\n\tmsgbuf->rx_dataoffset = if_msgbuf->rx_dataoffset;\n\tmsgbuf->max_rxbufpost = if_msgbuf->max_rxbufpost;\n\n\tmsgbuf->max_ioctlrespbuf = BRCMF_MSGBUF_MAX_IOCTLRESPBUF_POST;\n\tmsgbuf->max_eventbuf = BRCMF_MSGBUF_MAX_EVENTBUF_POST;\n\n\tmsgbuf->tx_pktids = brcmf_msgbuf_init_pktids(NR_TX_PKTIDS,\n\t\t\t\t\t\t     DMA_TO_DEVICE);\n\tif (!msgbuf->tx_pktids)\n\t\tgoto fail;\n\tmsgbuf->rx_pktids = brcmf_msgbuf_init_pktids(NR_RX_PKTIDS,\n\t\t\t\t\t\t     DMA_FROM_DEVICE);\n\tif (!msgbuf->rx_pktids)\n\t\tgoto fail;\n\n\tmsgbuf->flow = brcmf_flowring_attach(drvr->bus_if->dev,\n\t\t\t\t\t     if_msgbuf->max_flowrings);\n\tif (!msgbuf->flow)\n\t\tgoto fail;\n\n\n\tbrcmf_dbg(MSGBUF, \"Feeding buffers, rx data %d, rx event %d, rx ioctl resp %d\\n\",\n\t\t  msgbuf->max_rxbufpost, msgbuf->max_eventbuf,\n\t\t  msgbuf->max_ioctlrespbuf);\n\tcount = 0;\n\tdo {\n\t\tbrcmf_msgbuf_rxbuf_data_fill(msgbuf);\n\t\tif (msgbuf->max_rxbufpost != msgbuf->rxbufpost)\n\t\t\tmsleep(10);\n\t\telse\n\t\t\tbreak;\n\t\tcount++;\n\t} while (count < 10);\n\tbrcmf_msgbuf_rxbuf_event_post(msgbuf);\n\tbrcmf_msgbuf_rxbuf_ioctlresp_post(msgbuf);\n\n\tINIT_WORK(&msgbuf->flowring_work, brcmf_msgbuf_flowring_worker);\n\tspin_lock_init(&msgbuf->flowring_work_lock);\n\tINIT_LIST_HEAD(&msgbuf->work_queue);\n\n\treturn 0;\n\nfail:\n\tif (msgbuf) {\n\t\tkfree(msgbuf->flow_map);\n\t\tkfree(msgbuf->txstatus_done_map);\n\t\tbrcmf_msgbuf_release_pktids(msgbuf);\n\t\tkfree(msgbuf->flowring_dma_handle);\n\t\tif (msgbuf->ioctbuf)\n\t\t\tdma_free_coherent(drvr->bus_if->dev,\n\t\t\t\t\t  BRCMF_TX_IOCTL_MAX_MSG_SIZE,\n\t\t\t\t\t  msgbuf->ioctbuf,\n\t\t\t\t\t  msgbuf->ioctbuf_handle);\n\t\tif (msgbuf->txflow_wq)\n\t\t\tdestroy_workqueue(msgbuf->txflow_wq);\n\t\tkfree(msgbuf);\n\t}\n\treturn -ENOMEM;\n}\n\n\nvoid brcmf_proto_msgbuf_detach(struct brcmf_pub *drvr)\n{\n\tstruct brcmf_msgbuf *msgbuf;\n\tstruct brcmf_msgbuf_work_item *work;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (drvr->proto->pd) {\n\t\tmsgbuf = (struct brcmf_msgbuf *)drvr->proto->pd;\n\t\tcancel_work_sync(&msgbuf->flowring_work);\n\t\twhile (!list_empty(&msgbuf->work_queue)) {\n\t\t\twork = list_first_entry(&msgbuf->work_queue,\n\t\t\t\t\t\tstruct brcmf_msgbuf_work_item,\n\t\t\t\t\t\tqueue);\n\t\t\tlist_del(&work->queue);\n\t\t\tkfree(work);\n\t\t}\n\t\tkfree(msgbuf->flow_map);\n\t\tkfree(msgbuf->txstatus_done_map);\n\t\tif (msgbuf->txflow_wq)\n\t\t\tdestroy_workqueue(msgbuf->txflow_wq);\n\n\t\tbrcmf_flowring_detach(msgbuf->flow);\n\t\tdma_free_coherent(drvr->bus_if->dev,\n\t\t\t\t  BRCMF_TX_IOCTL_MAX_MSG_SIZE,\n\t\t\t\t  msgbuf->ioctbuf, msgbuf->ioctbuf_handle);\n\t\tbrcmf_msgbuf_release_pktids(msgbuf);\n\t\tkfree(msgbuf->flowring_dma_handle);\n\t\tkfree(msgbuf);\n\t\tdrvr->proto->pd = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}