{
  "module_name": "pno.c",
  "hash_id": "5c06ae65199c782ffc8a9f42e2666596788143f897f9752d53a99505ebee95f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pno.c",
  "human_readable_source": "\n \n#include <linux/netdevice.h>\n#include <linux/gcd.h>\n#include <net/cfg80211.h>\n\n#include \"core.h\"\n#include \"debug.h\"\n#include \"fwil.h\"\n#include \"fwil_types.h\"\n#include \"cfg80211.h\"\n#include \"pno.h\"\n\n#define BRCMF_PNO_VERSION\t\t2\n#define BRCMF_PNO_REPEAT\t\t4\n#define BRCMF_PNO_FREQ_EXPO_MAX\t\t3\n#define BRCMF_PNO_IMMEDIATE_SCAN_BIT\t3\n#define BRCMF_PNO_ENABLE_BD_SCAN_BIT\t5\n#define BRCMF_PNO_ENABLE_ADAPTSCAN_BIT\t6\n#define BRCMF_PNO_REPORT_SEPARATELY_BIT\t11\n#define BRCMF_PNO_SCAN_INCOMPLETE\t0\n#define BRCMF_PNO_WPA_AUTH_ANY\t\t0xFFFFFFFF\n#define BRCMF_PNO_HIDDEN_BIT\t\t2\n#define BRCMF_PNO_SCHED_SCAN_PERIOD\t30\n\n#define BRCMF_PNO_MAX_BUCKETS\t\t16\n#define GSCAN_BATCH_NO_THR_SET\t\t\t101\n#define GSCAN_RETRY_THRESHOLD\t\t\t3\n\nstruct brcmf_pno_info {\n\tint n_reqs;\n\tstruct cfg80211_sched_scan_request *reqs[BRCMF_PNO_MAX_BUCKETS];\n\tstruct mutex req_lock;\n};\n\n#define ifp_to_pno(_ifp)\t((_ifp)->drvr->config->pno)\n\nstatic int brcmf_pno_store_request(struct brcmf_pno_info *pi,\n\t\t\t\t   struct cfg80211_sched_scan_request *req)\n{\n\tif (WARN(pi->n_reqs == BRCMF_PNO_MAX_BUCKETS,\n\t\t \"pno request storage full\\n\"))\n\t\treturn -ENOSPC;\n\n\tbrcmf_dbg(SCAN, \"reqid=%llu\\n\", req->reqid);\n\tmutex_lock(&pi->req_lock);\n\tpi->reqs[pi->n_reqs++] = req;\n\tmutex_unlock(&pi->req_lock);\n\treturn 0;\n}\n\nstatic int brcmf_pno_remove_request(struct brcmf_pno_info *pi, u64 reqid)\n{\n\tint i, err = 0;\n\n\tmutex_lock(&pi->req_lock);\n\n\t \n\tif (pi->n_reqs == 0)\n\t\tgoto done;\n\n\t \n\tfor (i = 0; i < pi->n_reqs; i++) {\n\t\tif (pi->reqs[i]->reqid == reqid)\n\t\t\tbreak;\n\t}\n\t \n\tif (WARN(i == pi->n_reqs, \"reqid not found\\n\")) {\n\t\terr = -ENOENT;\n\t\tgoto done;\n\t}\n\n\tbrcmf_dbg(SCAN, \"reqid=%llu\\n\", reqid);\n\tpi->n_reqs--;\n\n\t \n\tif (!pi->n_reqs || i == pi->n_reqs)\n\t\tgoto done;\n\n\t \n\twhile (i <= pi->n_reqs - 1) {\n\t\tpi->reqs[i] = pi->reqs[i + 1];\n\t\ti++;\n\t}\n\ndone:\n\tmutex_unlock(&pi->req_lock);\n\treturn err;\n}\n\nstatic int brcmf_pno_channel_config(struct brcmf_if *ifp,\n\t\t\t\t    struct brcmf_pno_config_le *cfg)\n{\n\tcfg->reporttype = 0;\n\tcfg->flags = 0;\n\n\treturn brcmf_fil_iovar_data_set(ifp, \"pfn_cfg\", cfg, sizeof(*cfg));\n}\n\nstatic int brcmf_pno_config(struct brcmf_if *ifp, u32 scan_freq,\n\t\t\t    u32 mscan, u32 bestn)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_pno_param_le pfn_param;\n\tu16 flags;\n\tu32 pfnmem;\n\ts32 err;\n\n\tmemset(&pfn_param, 0, sizeof(pfn_param));\n\tpfn_param.version = cpu_to_le32(BRCMF_PNO_VERSION);\n\n\t \n\tflags = BIT(BRCMF_PNO_IMMEDIATE_SCAN_BIT) |\n\t\tBIT(BRCMF_PNO_ENABLE_ADAPTSCAN_BIT);\n\tpfn_param.repeat = BRCMF_PNO_REPEAT;\n\tpfn_param.exp = BRCMF_PNO_FREQ_EXPO_MAX;\n\n\t \n\tpfn_param.scan_freq = cpu_to_le32(scan_freq);\n\n\tif (mscan) {\n\t\tpfnmem = bestn;\n\n\t\t \n\t\terr = brcmf_fil_iovar_int_set(ifp, \"pfnmem\", pfnmem);\n\t\tif (err < 0) {\n\t\t\tbphy_err(drvr, \"failed to set pfnmem\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\t \n\t\terr = brcmf_fil_iovar_int_get(ifp, \"pfnmem\", &pfnmem);\n\t\tif (err < 0) {\n\t\t\tbphy_err(drvr, \"failed to get pfnmem\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tmscan = min_t(u32, mscan, pfnmem);\n\t\tpfn_param.mscan = mscan;\n\t\tpfn_param.bestn = bestn;\n\t\tflags |= BIT(BRCMF_PNO_ENABLE_BD_SCAN_BIT);\n\t\tbrcmf_dbg(INFO, \"mscan=%d, bestn=%d\\n\", mscan, bestn);\n\t}\n\n\tpfn_param.flags = cpu_to_le16(flags);\n\terr = brcmf_fil_iovar_data_set(ifp, \"pfn_set\", &pfn_param,\n\t\t\t\t       sizeof(pfn_param));\n\tif (err)\n\t\tbphy_err(drvr, \"pfn_set failed, err=%d\\n\", err);\n\nexit:\n\treturn err;\n}\n\nstatic int brcmf_pno_set_random(struct brcmf_if *ifp, struct brcmf_pno_info *pi)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_pno_macaddr_le pfn_mac;\n\tu8 *mac_addr = NULL;\n\tu8 *mac_mask = NULL;\n\tint err, i, ri;\n\n\tfor (ri = 0; ri < pi->n_reqs; ri++)\n\t\tif (pi->reqs[ri]->flags & NL80211_SCAN_FLAG_RANDOM_ADDR) {\n\t\t\tmac_addr = pi->reqs[ri]->mac_addr;\n\t\t\tmac_mask = pi->reqs[ri]->mac_addr_mask;\n\t\t\tbreak;\n\t\t}\n\n\t \n\tif (!mac_addr)\n\t\treturn 0;\n\n\tpfn_mac.version = BRCMF_PFN_MACADDR_CFG_VER;\n\tpfn_mac.flags = BRCMF_PFN_MAC_OUI_ONLY | BRCMF_PFN_SET_MAC_UNASSOC;\n\n\tmemcpy(pfn_mac.mac, mac_addr, ETH_ALEN);\n\tfor (i = 0; i < ETH_ALEN; i++) {\n\t\tpfn_mac.mac[i] &= mac_mask[i];\n\t\tpfn_mac.mac[i] |= get_random_u8() & ~(mac_mask[i]);\n\t}\n\t \n\tpfn_mac.mac[0] &= 0xFE;\n\t \n\tpfn_mac.mac[0] |= 0x02;\n\n\tbrcmf_dbg(SCAN, \"enabling random mac: reqid=%llu mac=%pM\\n\",\n\t\t  pi->reqs[ri]->reqid, pfn_mac.mac);\n\terr = brcmf_fil_iovar_data_set(ifp, \"pfn_macaddr\", &pfn_mac,\n\t\t\t\t       sizeof(pfn_mac));\n\tif (err)\n\t\tbphy_err(drvr, \"pfn_macaddr failed, err=%d\\n\", err);\n\n\treturn err;\n}\n\nstatic int brcmf_pno_add_ssid(struct brcmf_if *ifp, struct cfg80211_ssid *ssid,\n\t\t\t      bool active)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_pno_net_param_le pfn;\n\tint err;\n\n\tpfn.auth = cpu_to_le32(WLAN_AUTH_OPEN);\n\tpfn.wpa_auth = cpu_to_le32(BRCMF_PNO_WPA_AUTH_ANY);\n\tpfn.wsec = cpu_to_le32(0);\n\tpfn.infra = cpu_to_le32(1);\n\tpfn.flags = 0;\n\tif (active)\n\t\tpfn.flags = cpu_to_le32(1 << BRCMF_PNO_HIDDEN_BIT);\n\tpfn.ssid.SSID_len = cpu_to_le32(ssid->ssid_len);\n\tmemcpy(pfn.ssid.SSID, ssid->ssid, ssid->ssid_len);\n\n\tbrcmf_dbg(SCAN, \"adding ssid=%.32s (active=%d)\\n\", ssid->ssid, active);\n\terr = brcmf_fil_iovar_data_set(ifp, \"pfn_add\", &pfn, sizeof(pfn));\n\tif (err < 0)\n\t\tbphy_err(drvr, \"adding failed: err=%d\\n\", err);\n\treturn err;\n}\n\nstatic int brcmf_pno_add_bssid(struct brcmf_if *ifp, const u8 *bssid)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_pno_bssid_le bssid_cfg;\n\tint err;\n\n\tmemcpy(bssid_cfg.bssid, bssid, ETH_ALEN);\n\tbssid_cfg.flags = 0;\n\n\tbrcmf_dbg(SCAN, \"adding bssid=%pM\\n\", bssid);\n\terr = brcmf_fil_iovar_data_set(ifp, \"pfn_add_bssid\", &bssid_cfg,\n\t\t\t\t       sizeof(bssid_cfg));\n\tif (err < 0)\n\t\tbphy_err(drvr, \"adding failed: err=%d\\n\", err);\n\treturn err;\n}\n\nstatic bool brcmf_is_ssid_active(struct cfg80211_ssid *ssid,\n\t\t\t\t struct cfg80211_sched_scan_request *req)\n{\n\tint i;\n\n\tif (!ssid || !req->ssids || !req->n_ssids)\n\t\treturn false;\n\n\tfor (i = 0; i < req->n_ssids; i++) {\n\t\tif (ssid->ssid_len == req->ssids[i].ssid_len) {\n\t\t\tif (!strncmp(ssid->ssid, req->ssids[i].ssid,\n\t\t\t\t     ssid->ssid_len))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int brcmf_pno_clean(struct brcmf_if *ifp)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tint ret;\n\n\t \n\tret = brcmf_fil_iovar_int_set(ifp, \"pfn\", 0);\n\tif (ret == 0) {\n\t\t \n\t\tret = brcmf_fil_iovar_data_set(ifp, \"pfnclear\", NULL, 0);\n\t}\n\tif (ret < 0)\n\t\tbphy_err(drvr, \"failed code %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int brcmf_pno_get_bucket_channels(struct cfg80211_sched_scan_request *r,\n\t\t\t\t\t struct brcmf_pno_config_le *pno_cfg)\n{\n\tu32 n_chan = le32_to_cpu(pno_cfg->channel_num);\n\tu16 chan;\n\tint i, err = 0;\n\n\tfor (i = 0; i < r->n_channels; i++) {\n\t\tif (n_chan >= BRCMF_NUMCHANNELS) {\n\t\t\terr = -ENOSPC;\n\t\t\tgoto done;\n\t\t}\n\t\tchan = r->channels[i]->hw_value;\n\t\tbrcmf_dbg(SCAN, \"[%d] Chan : %u\\n\", n_chan, chan);\n\t\tpno_cfg->channel_list[n_chan++] = cpu_to_le16(chan);\n\t}\n\t \n\terr = n_chan;\ndone:\n\tpno_cfg->channel_num = cpu_to_le32(n_chan);\n\treturn err;\n}\n\nstatic int brcmf_pno_prep_fwconfig(struct brcmf_pno_info *pi,\n\t\t\t\t   struct brcmf_pno_config_le *pno_cfg,\n\t\t\t\t   struct brcmf_gscan_bucket_config **buckets,\n\t\t\t\t   u32 *scan_freq)\n{\n\tstruct cfg80211_sched_scan_request *sr;\n\tstruct brcmf_gscan_bucket_config *fw_buckets;\n\tint i, err, chidx;\n\n\tbrcmf_dbg(SCAN, \"n_reqs=%d\\n\", pi->n_reqs);\n\tif (WARN_ON(!pi->n_reqs))\n\t\treturn -ENODATA;\n\n\t \n\t*scan_freq = pi->reqs[0]->scan_plans[0].interval;\n\tfor (i = 1; i < pi->n_reqs; i++) {\n\t\tsr = pi->reqs[i];\n\t\t*scan_freq = gcd(sr->scan_plans[0].interval, *scan_freq);\n\t}\n\tif (*scan_freq < BRCMF_PNO_SCHED_SCAN_MIN_PERIOD) {\n\t\tbrcmf_dbg(SCAN, \"scan period too small, using minimum\\n\");\n\t\t*scan_freq = BRCMF_PNO_SCHED_SCAN_MIN_PERIOD;\n\t}\n\n\t*buckets = NULL;\n\tfw_buckets = kcalloc(pi->n_reqs, sizeof(*fw_buckets), GFP_KERNEL);\n\tif (!fw_buckets)\n\t\treturn -ENOMEM;\n\n\tmemset(pno_cfg, 0, sizeof(*pno_cfg));\n\tfor (i = 0; i < pi->n_reqs; i++) {\n\t\tsr = pi->reqs[i];\n\t\tchidx = brcmf_pno_get_bucket_channels(sr, pno_cfg);\n\t\tif (chidx < 0) {\n\t\t\terr = chidx;\n\t\t\tgoto fail;\n\t\t}\n\t\tfw_buckets[i].bucket_end_index = chidx - 1;\n\t\tfw_buckets[i].bucket_freq_multiple =\n\t\t\tsr->scan_plans[0].interval / *scan_freq;\n\t\t \n\t\tif (!fw_buckets[i].bucket_freq_multiple)\n\t\t\tfw_buckets[i].bucket_freq_multiple = 1;\n\t\tfw_buckets[i].flag = BRCMF_PNO_REPORT_NO_BATCH;\n\t}\n\n\tif (BRCMF_SCAN_ON()) {\n\t\tbrcmf_err(\"base period=%u\\n\", *scan_freq);\n\t\tfor (i = 0; i < pi->n_reqs; i++) {\n\t\t\tbrcmf_err(\"[%d] period %u max %u repeat %u flag %x idx %u\\n\",\n\t\t\t\t  i, fw_buckets[i].bucket_freq_multiple,\n\t\t\t\t  le16_to_cpu(fw_buckets[i].max_freq_multiple),\n\t\t\t\t  fw_buckets[i].repeat, fw_buckets[i].flag,\n\t\t\t\t  fw_buckets[i].bucket_end_index);\n\t\t}\n\t}\n\t*buckets = fw_buckets;\n\treturn pi->n_reqs;\n\nfail:\n\tkfree(fw_buckets);\n\treturn err;\n}\n\nstatic int brcmf_pno_config_networks(struct brcmf_if *ifp,\n\t\t\t\t     struct brcmf_pno_info *pi)\n{\n\tstruct cfg80211_sched_scan_request *r;\n\tstruct cfg80211_match_set *ms;\n\tbool active;\n\tint i, j, err = 0;\n\n\tfor (i = 0; i < pi->n_reqs; i++) {\n\t\tr = pi->reqs[i];\n\n\t\tfor (j = 0; j < r->n_match_sets; j++) {\n\t\t\tms = &r->match_sets[j];\n\t\t\tif (ms->ssid.ssid_len) {\n\t\t\t\tactive = brcmf_is_ssid_active(&ms->ssid, r);\n\t\t\t\terr = brcmf_pno_add_ssid(ifp, &ms->ssid,\n\t\t\t\t\t\t\t active);\n\t\t\t}\n\t\t\tif (!err && is_valid_ether_addr(ms->bssid))\n\t\t\t\terr = brcmf_pno_add_bssid(ifp, ms->bssid);\n\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int brcmf_pno_config_sched_scans(struct brcmf_if *ifp)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_pno_info *pi;\n\tstruct brcmf_gscan_config *gscan_cfg;\n\tstruct brcmf_gscan_bucket_config *buckets;\n\tstruct brcmf_pno_config_le pno_cfg;\n\tsize_t gsz;\n\tu32 scan_freq;\n\tint err, n_buckets;\n\n\tpi = ifp_to_pno(ifp);\n\tn_buckets = brcmf_pno_prep_fwconfig(pi, &pno_cfg, &buckets,\n\t\t\t\t\t    &scan_freq);\n\tif (n_buckets < 0)\n\t\treturn n_buckets;\n\n\tgsz = struct_size(gscan_cfg, bucket, n_buckets);\n\tgscan_cfg = kzalloc(gsz, GFP_KERNEL);\n\tif (!gscan_cfg) {\n\t\terr = -ENOMEM;\n\t\tgoto free_buckets;\n\t}\n\n\t \n\terr = brcmf_pno_clean(ifp);\n\tif  (err < 0) {\n\t\tbphy_err(drvr, \"failed error=%d\\n\", err);\n\t\tgoto free_gscan;\n\t}\n\n\t \n\terr = brcmf_pno_config(ifp, scan_freq, 0, 0);\n\tif (err < 0)\n\t\tgoto free_gscan;\n\n\terr = brcmf_pno_channel_config(ifp, &pno_cfg);\n\tif (err < 0)\n\t\tgoto clean;\n\n\tgscan_cfg->version = cpu_to_le16(BRCMF_GSCAN_CFG_VERSION);\n\tgscan_cfg->retry_threshold = GSCAN_RETRY_THRESHOLD;\n\tgscan_cfg->buffer_threshold = GSCAN_BATCH_NO_THR_SET;\n\tgscan_cfg->flags = BRCMF_GSCAN_CFG_ALL_BUCKETS_IN_1ST_SCAN;\n\n\tgscan_cfg->count_of_channel_buckets = n_buckets;\n\tmemcpy(gscan_cfg->bucket, buckets,\n\t       array_size(n_buckets, sizeof(*buckets)));\n\n\terr = brcmf_fil_iovar_data_set(ifp, \"pfn_gscan_cfg\", gscan_cfg, gsz);\n\n\tif (err < 0)\n\t\tgoto clean;\n\n\t \n\terr = brcmf_pno_set_random(ifp, pi);\n\tif (err < 0)\n\t\tgoto clean;\n\n\terr = brcmf_pno_config_networks(ifp, pi);\n\tif (err < 0)\n\t\tgoto clean;\n\n\t \n\terr = brcmf_fil_iovar_int_set(ifp, \"pfn\", 1);\n\nclean:\n\tif (err < 0)\n\t\tbrcmf_pno_clean(ifp);\nfree_gscan:\n\tkfree(gscan_cfg);\nfree_buckets:\n\tkfree(buckets);\n\treturn err;\n}\n\nint brcmf_pno_start_sched_scan(struct brcmf_if *ifp,\n\t\t\t       struct cfg80211_sched_scan_request *req)\n{\n\tstruct brcmf_pno_info *pi;\n\tint ret;\n\n\tbrcmf_dbg(TRACE, \"reqid=%llu\\n\", req->reqid);\n\n\tpi = ifp_to_pno(ifp);\n\tret = brcmf_pno_store_request(pi, req);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = brcmf_pno_config_sched_scans(ifp);\n\tif (ret < 0) {\n\t\tbrcmf_pno_remove_request(pi, req->reqid);\n\t\tif (pi->n_reqs)\n\t\t\t(void)brcmf_pno_config_sched_scans(ifp);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nint brcmf_pno_stop_sched_scan(struct brcmf_if *ifp, u64 reqid)\n{\n\tstruct brcmf_pno_info *pi;\n\tint err;\n\n\tbrcmf_dbg(TRACE, \"reqid=%llu\\n\", reqid);\n\n\tpi = ifp_to_pno(ifp);\n\n\t \n\tif (!pi->n_reqs)\n\t\treturn 0;\n\n\terr = brcmf_pno_remove_request(pi, reqid);\n\tif (err)\n\t\treturn err;\n\n\tbrcmf_pno_clean(ifp);\n\n\tif (pi->n_reqs)\n\t\t(void)brcmf_pno_config_sched_scans(ifp);\n\n\treturn 0;\n}\n\nint brcmf_pno_attach(struct brcmf_cfg80211_info *cfg)\n{\n\tstruct brcmf_pno_info *pi;\n\n\tbrcmf_dbg(TRACE, \"enter\\n\");\n\tpi = kzalloc(sizeof(*pi), GFP_KERNEL);\n\tif (!pi)\n\t\treturn -ENOMEM;\n\n\tcfg->pno = pi;\n\tmutex_init(&pi->req_lock);\n\treturn 0;\n}\n\nvoid brcmf_pno_detach(struct brcmf_cfg80211_info *cfg)\n{\n\tstruct brcmf_pno_info *pi;\n\n\tbrcmf_dbg(TRACE, \"enter\\n\");\n\tpi = cfg->pno;\n\tcfg->pno = NULL;\n\n\tWARN_ON(pi->n_reqs);\n\tmutex_destroy(&pi->req_lock);\n\tkfree(pi);\n}\n\nvoid brcmf_pno_wiphy_params(struct wiphy *wiphy, bool gscan)\n{\n\t \n\twiphy->max_sched_scan_reqs = gscan ? BRCMF_PNO_MAX_BUCKETS : 1;\n\twiphy->max_sched_scan_ssids = BRCMF_PNO_MAX_PFN_COUNT;\n\twiphy->max_match_sets = BRCMF_PNO_MAX_PFN_COUNT;\n\twiphy->max_sched_scan_ie_len = BRCMF_SCAN_IE_LEN_MAX;\n\twiphy->max_sched_scan_plan_interval = BRCMF_PNO_SCHED_SCAN_MAX_PERIOD;\n}\n\nu64 brcmf_pno_find_reqid_by_bucket(struct brcmf_pno_info *pi, u32 bucket)\n{\n\tu64 reqid = 0;\n\n\tmutex_lock(&pi->req_lock);\n\n\tif (bucket < pi->n_reqs)\n\t\treqid = pi->reqs[bucket]->reqid;\n\n\tmutex_unlock(&pi->req_lock);\n\treturn reqid;\n}\n\nu32 brcmf_pno_get_bucket_map(struct brcmf_pno_info *pi,\n\t\t\t     struct brcmf_pno_net_info_le *ni)\n{\n\tstruct cfg80211_sched_scan_request *req;\n\tstruct cfg80211_match_set *ms;\n\tu32 bucket_map = 0;\n\tint i, j;\n\n\tmutex_lock(&pi->req_lock);\n\tfor (i = 0; i < pi->n_reqs; i++) {\n\t\treq = pi->reqs[i];\n\n\t\tif (!req->n_match_sets)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < req->n_match_sets; j++) {\n\t\t\tms = &req->match_sets[j];\n\t\t\tif (ms->ssid.ssid_len == ni->SSID_len &&\n\t\t\t    !memcmp(ms->ssid.ssid, ni->SSID, ni->SSID_len)) {\n\t\t\t\tbucket_map |= BIT(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (is_valid_ether_addr(ms->bssid) &&\n\t\t\t    !memcmp(ms->bssid, ni->bssid, ETH_ALEN)) {\n\t\t\t\tbucket_map |= BIT(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&pi->req_lock);\n\treturn bucket_map;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}