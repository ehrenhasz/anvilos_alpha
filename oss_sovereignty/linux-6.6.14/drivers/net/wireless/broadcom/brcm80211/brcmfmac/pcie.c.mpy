{
  "module_name": "pcie.c",
  "hash_id": "d3951723df972f523c8d70e3f1ae96fd0362f815f79941e06c43d14867547e54",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/firmware.h>\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/bcma/bcma.h>\n#include <linux/sched.h>\n#include <linux/sched/signal.h>\n#include <linux/kthread.h>\n#include <linux/io.h>\n#include <linux/random.h>\n#include <asm/unaligned.h>\n\n#include <soc.h>\n#include <chipcommon.h>\n#include <brcmu_utils.h>\n#include <brcmu_wifi.h>\n#include <brcm_hw_ids.h>\n\n \n#define brcmf_err(bus, fmt, ...)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (IS_ENABLED(CONFIG_BRCMDBG) ||\t\t\t\\\n\t\t    IS_ENABLED(CONFIG_BRCM_TRACING) ||\t\t\t\\\n\t\t    net_ratelimit())\t\t\t\t\t\\\n\t\t\t__brcmf_err(bus, __func__, fmt, ##__VA_ARGS__);\t\\\n\t} while (0)\n\n#include \"debug.h\"\n#include \"bus.h\"\n#include \"commonring.h\"\n#include \"msgbuf.h\"\n#include \"pcie.h\"\n#include \"firmware.h\"\n#include \"chip.h\"\n#include \"core.h\"\n#include \"common.h\"\n\n\nenum brcmf_pcie_state {\n\tBRCMFMAC_PCIE_STATE_DOWN,\n\tBRCMFMAC_PCIE_STATE_UP\n};\n\nBRCMF_FW_DEF(43602, \"brcmfmac43602-pcie\");\nBRCMF_FW_DEF(4350, \"brcmfmac4350-pcie\");\nBRCMF_FW_DEF(4350C, \"brcmfmac4350c2-pcie\");\nBRCMF_FW_CLM_DEF(4355, \"brcmfmac4355-pcie\");\nBRCMF_FW_CLM_DEF(4355C1, \"brcmfmac4355c1-pcie\");\nBRCMF_FW_CLM_DEF(4356, \"brcmfmac4356-pcie\");\nBRCMF_FW_CLM_DEF(43570, \"brcmfmac43570-pcie\");\nBRCMF_FW_DEF(4358, \"brcmfmac4358-pcie\");\nBRCMF_FW_DEF(4359, \"brcmfmac4359-pcie\");\nBRCMF_FW_DEF(4359C, \"brcmfmac4359c-pcie\");\nBRCMF_FW_CLM_DEF(4364B2, \"brcmfmac4364b2-pcie\");\nBRCMF_FW_CLM_DEF(4364B3, \"brcmfmac4364b3-pcie\");\nBRCMF_FW_DEF(4365B, \"brcmfmac4365b-pcie\");\nBRCMF_FW_DEF(4365C, \"brcmfmac4365c-pcie\");\nBRCMF_FW_DEF(4366B, \"brcmfmac4366b-pcie\");\nBRCMF_FW_DEF(4366C, \"brcmfmac4366c-pcie\");\nBRCMF_FW_DEF(4371, \"brcmfmac4371-pcie\");\nBRCMF_FW_CLM_DEF(4377B3, \"brcmfmac4377b3-pcie\");\nBRCMF_FW_CLM_DEF(4378B1, \"brcmfmac4378b1-pcie\");\nBRCMF_FW_CLM_DEF(4378B3, \"brcmfmac4378b3-pcie\");\nBRCMF_FW_CLM_DEF(4387C2, \"brcmfmac4387c2-pcie\");\n\n \nMODULE_FIRMWARE(BRCMF_FW_DEFAULT_PATH \"brcmfmac*-pcie.txt\");\nMODULE_FIRMWARE(BRCMF_FW_DEFAULT_PATH \"brcmfmac*-pcie.*.txt\");\n\n \nMODULE_FIRMWARE(BRCMF_FW_DEFAULT_PATH \"brcmfmac*-pcie.*.bin\");\nMODULE_FIRMWARE(BRCMF_FW_DEFAULT_PATH \"brcmfmac*-pcie.*.clm_blob\");\nMODULE_FIRMWARE(BRCMF_FW_DEFAULT_PATH \"brcmfmac*-pcie.*.txcap_blob\");\n\nstatic const struct brcmf_firmware_mapping brcmf_pcie_fwnames[] = {\n\tBRCMF_FW_ENTRY(BRCM_CC_43602_CHIP_ID, 0xFFFFFFFF, 43602),\n\tBRCMF_FW_ENTRY(BRCM_CC_43465_CHIP_ID, 0xFFFFFFF0, 4366C),\n\tBRCMF_FW_ENTRY(BRCM_CC_4350_CHIP_ID, 0x000000FF, 4350C),\n\tBRCMF_FW_ENTRY(BRCM_CC_4350_CHIP_ID, 0xFFFFFF00, 4350),\n\tBRCMF_FW_ENTRY(BRCM_CC_43525_CHIP_ID, 0xFFFFFFF0, 4365C),\n\tBRCMF_FW_ENTRY(BRCM_CC_4355_CHIP_ID, 0x000007FF, 4355),\n\tBRCMF_FW_ENTRY(BRCM_CC_4355_CHIP_ID, 0xFFFFF800, 4355C1),  \n\tBRCMF_FW_ENTRY(BRCM_CC_4356_CHIP_ID, 0xFFFFFFFF, 4356),\n\tBRCMF_FW_ENTRY(BRCM_CC_43567_CHIP_ID, 0xFFFFFFFF, 43570),\n\tBRCMF_FW_ENTRY(BRCM_CC_43569_CHIP_ID, 0xFFFFFFFF, 43570),\n\tBRCMF_FW_ENTRY(BRCM_CC_43570_CHIP_ID, 0xFFFFFFFF, 43570),\n\tBRCMF_FW_ENTRY(BRCM_CC_4358_CHIP_ID, 0xFFFFFFFF, 4358),\n\tBRCMF_FW_ENTRY(BRCM_CC_4359_CHIP_ID, 0x000001FF, 4359),\n\tBRCMF_FW_ENTRY(BRCM_CC_4359_CHIP_ID, 0xFFFFFE00, 4359C),\n\tBRCMF_FW_ENTRY(BRCM_CC_4364_CHIP_ID, 0x0000000F, 4364B2),  \n\tBRCMF_FW_ENTRY(BRCM_CC_4364_CHIP_ID, 0xFFFFFFF0, 4364B3),  \n\tBRCMF_FW_ENTRY(BRCM_CC_4365_CHIP_ID, 0x0000000F, 4365B),\n\tBRCMF_FW_ENTRY(BRCM_CC_4365_CHIP_ID, 0xFFFFFFF0, 4365C),\n\tBRCMF_FW_ENTRY(BRCM_CC_4366_CHIP_ID, 0x0000000F, 4366B),\n\tBRCMF_FW_ENTRY(BRCM_CC_4366_CHIP_ID, 0xFFFFFFF0, 4366C),\n\tBRCMF_FW_ENTRY(BRCM_CC_43664_CHIP_ID, 0xFFFFFFF0, 4366C),\n\tBRCMF_FW_ENTRY(BRCM_CC_43666_CHIP_ID, 0xFFFFFFF0, 4366C),\n\tBRCMF_FW_ENTRY(BRCM_CC_4371_CHIP_ID, 0xFFFFFFFF, 4371),\n\tBRCMF_FW_ENTRY(BRCM_CC_4377_CHIP_ID, 0xFFFFFFFF, 4377B3),  \n\tBRCMF_FW_ENTRY(BRCM_CC_4378_CHIP_ID, 0x0000000F, 4378B1),  \n\tBRCMF_FW_ENTRY(BRCM_CC_4378_CHIP_ID, 0xFFFFFFE0, 4378B3),  \n\tBRCMF_FW_ENTRY(BRCM_CC_4387_CHIP_ID, 0xFFFFFFFF, 4387C2),  \n};\n\n#define BRCMF_PCIE_FW_UP_TIMEOUT\t\t5000  \n\n#define BRCMF_PCIE_REG_MAP_SIZE\t\t\t(32 * 1024)\n\n \n#define\tBRCMF_PCIE_BAR0_WINDOW\t\t\t0x80\n#define BRCMF_PCIE_BAR0_REG_SIZE\t\t0x1000\n#define\tBRCMF_PCIE_BAR0_WRAPPERBASE\t\t0x70\n\n#define BRCMF_PCIE_BAR0_WRAPBASE_DMP_OFFSET\t0x1000\n#define BRCMF_PCIE_BARO_PCIE_ENUM_OFFSET\t0x2000\n\n#define BRCMF_PCIE_ARMCR4REG_BANKIDX\t\t0x40\n#define BRCMF_PCIE_ARMCR4REG_BANKPDA\t\t0x4C\n\n#define BRCMF_PCIE_REG_INTSTATUS\t\t0x90\n#define BRCMF_PCIE_REG_INTMASK\t\t\t0x94\n#define BRCMF_PCIE_REG_SBMBX\t\t\t0x98\n\n#define BRCMF_PCIE_REG_LINK_STATUS_CTRL\t\t0xBC\n\n#define BRCMF_PCIE_PCIE2REG_INTMASK\t\t0x24\n#define BRCMF_PCIE_PCIE2REG_MAILBOXINT\t\t0x48\n#define BRCMF_PCIE_PCIE2REG_MAILBOXMASK\t\t0x4C\n#define BRCMF_PCIE_PCIE2REG_CONFIGADDR\t\t0x120\n#define BRCMF_PCIE_PCIE2REG_CONFIGDATA\t\t0x124\n#define BRCMF_PCIE_PCIE2REG_H2D_MAILBOX_0\t0x140\n#define BRCMF_PCIE_PCIE2REG_H2D_MAILBOX_1\t0x144\n\n#define BRCMF_PCIE_64_PCIE2REG_INTMASK\t\t0xC14\n#define BRCMF_PCIE_64_PCIE2REG_MAILBOXINT\t0xC30\n#define BRCMF_PCIE_64_PCIE2REG_MAILBOXMASK\t0xC34\n#define BRCMF_PCIE_64_PCIE2REG_H2D_MAILBOX_0\t0xA20\n#define BRCMF_PCIE_64_PCIE2REG_H2D_MAILBOX_1\t0xA24\n\n#define BRCMF_PCIE2_INTA\t\t\t0x01\n#define BRCMF_PCIE2_INTB\t\t\t0x02\n\n#define BRCMF_PCIE_INT_0\t\t\t0x01\n#define BRCMF_PCIE_INT_1\t\t\t0x02\n#define BRCMF_PCIE_INT_DEF\t\t\t(BRCMF_PCIE_INT_0 | \\\n\t\t\t\t\t\t BRCMF_PCIE_INT_1)\n\n#define BRCMF_PCIE_MB_INT_FN0_0\t\t\t0x0100\n#define BRCMF_PCIE_MB_INT_FN0_1\t\t\t0x0200\n#define\tBRCMF_PCIE_MB_INT_D2H0_DB0\t\t0x10000\n#define\tBRCMF_PCIE_MB_INT_D2H0_DB1\t\t0x20000\n#define\tBRCMF_PCIE_MB_INT_D2H1_DB0\t\t0x40000\n#define\tBRCMF_PCIE_MB_INT_D2H1_DB1\t\t0x80000\n#define\tBRCMF_PCIE_MB_INT_D2H2_DB0\t\t0x100000\n#define\tBRCMF_PCIE_MB_INT_D2H2_DB1\t\t0x200000\n#define\tBRCMF_PCIE_MB_INT_D2H3_DB0\t\t0x400000\n#define\tBRCMF_PCIE_MB_INT_D2H3_DB1\t\t0x800000\n\n#define BRCMF_PCIE_MB_INT_FN0\t\t\t(BRCMF_PCIE_MB_INT_FN0_0 | \\\n\t\t\t\t\t\t BRCMF_PCIE_MB_INT_FN0_1)\n#define BRCMF_PCIE_MB_INT_D2H_DB\t\t(BRCMF_PCIE_MB_INT_D2H0_DB0 | \\\n\t\t\t\t\t\t BRCMF_PCIE_MB_INT_D2H0_DB1 | \\\n\t\t\t\t\t\t BRCMF_PCIE_MB_INT_D2H1_DB0 | \\\n\t\t\t\t\t\t BRCMF_PCIE_MB_INT_D2H1_DB1 | \\\n\t\t\t\t\t\t BRCMF_PCIE_MB_INT_D2H2_DB0 | \\\n\t\t\t\t\t\t BRCMF_PCIE_MB_INT_D2H2_DB1 | \\\n\t\t\t\t\t\t BRCMF_PCIE_MB_INT_D2H3_DB0 | \\\n\t\t\t\t\t\t BRCMF_PCIE_MB_INT_D2H3_DB1)\n\n#define\tBRCMF_PCIE_64_MB_INT_D2H0_DB0\t\t0x1\n#define\tBRCMF_PCIE_64_MB_INT_D2H0_DB1\t\t0x2\n#define\tBRCMF_PCIE_64_MB_INT_D2H1_DB0\t\t0x4\n#define\tBRCMF_PCIE_64_MB_INT_D2H1_DB1\t\t0x8\n#define\tBRCMF_PCIE_64_MB_INT_D2H2_DB0\t\t0x10\n#define\tBRCMF_PCIE_64_MB_INT_D2H2_DB1\t\t0x20\n#define\tBRCMF_PCIE_64_MB_INT_D2H3_DB0\t\t0x40\n#define\tBRCMF_PCIE_64_MB_INT_D2H3_DB1\t\t0x80\n#define\tBRCMF_PCIE_64_MB_INT_D2H4_DB0\t\t0x100\n#define\tBRCMF_PCIE_64_MB_INT_D2H4_DB1\t\t0x200\n#define\tBRCMF_PCIE_64_MB_INT_D2H5_DB0\t\t0x400\n#define\tBRCMF_PCIE_64_MB_INT_D2H5_DB1\t\t0x800\n#define\tBRCMF_PCIE_64_MB_INT_D2H6_DB0\t\t0x1000\n#define\tBRCMF_PCIE_64_MB_INT_D2H6_DB1\t\t0x2000\n#define\tBRCMF_PCIE_64_MB_INT_D2H7_DB0\t\t0x4000\n#define\tBRCMF_PCIE_64_MB_INT_D2H7_DB1\t\t0x8000\n\n#define BRCMF_PCIE_64_MB_INT_D2H_DB\t\t(BRCMF_PCIE_64_MB_INT_D2H0_DB0 | \\\n\t\t\t\t\t\t BRCMF_PCIE_64_MB_INT_D2H0_DB1 | \\\n\t\t\t\t\t\t BRCMF_PCIE_64_MB_INT_D2H1_DB0 | \\\n\t\t\t\t\t\t BRCMF_PCIE_64_MB_INT_D2H1_DB1 | \\\n\t\t\t\t\t\t BRCMF_PCIE_64_MB_INT_D2H2_DB0 | \\\n\t\t\t\t\t\t BRCMF_PCIE_64_MB_INT_D2H2_DB1 | \\\n\t\t\t\t\t\t BRCMF_PCIE_64_MB_INT_D2H3_DB0 | \\\n\t\t\t\t\t\t BRCMF_PCIE_64_MB_INT_D2H3_DB1 | \\\n\t\t\t\t\t\t BRCMF_PCIE_64_MB_INT_D2H4_DB0 | \\\n\t\t\t\t\t\t BRCMF_PCIE_64_MB_INT_D2H4_DB1 | \\\n\t\t\t\t\t\t BRCMF_PCIE_64_MB_INT_D2H5_DB0 | \\\n\t\t\t\t\t\t BRCMF_PCIE_64_MB_INT_D2H5_DB1 | \\\n\t\t\t\t\t\t BRCMF_PCIE_64_MB_INT_D2H6_DB0 | \\\n\t\t\t\t\t\t BRCMF_PCIE_64_MB_INT_D2H6_DB1 | \\\n\t\t\t\t\t\t BRCMF_PCIE_64_MB_INT_D2H7_DB0 | \\\n\t\t\t\t\t\t BRCMF_PCIE_64_MB_INT_D2H7_DB1)\n\n#define BRCMF_PCIE_SHARED_VERSION_7\t\t7\n#define BRCMF_PCIE_MIN_SHARED_VERSION\t\t5\n#define BRCMF_PCIE_MAX_SHARED_VERSION\t\tBRCMF_PCIE_SHARED_VERSION_7\n#define BRCMF_PCIE_SHARED_VERSION_MASK\t\t0x00FF\n#define BRCMF_PCIE_SHARED_DMA_INDEX\t\t0x10000\n#define BRCMF_PCIE_SHARED_DMA_2B_IDX\t\t0x100000\n#define BRCMF_PCIE_SHARED_HOSTRDY_DB1\t\t0x10000000\n\n#define BRCMF_PCIE_FLAGS_HTOD_SPLIT\t\t0x4000\n#define BRCMF_PCIE_FLAGS_DTOH_SPLIT\t\t0x8000\n\n#define BRCMF_SHARED_MAX_RXBUFPOST_OFFSET\t34\n#define BRCMF_SHARED_RING_BASE_OFFSET\t\t52\n#define BRCMF_SHARED_RX_DATAOFFSET_OFFSET\t36\n#define BRCMF_SHARED_CONSOLE_ADDR_OFFSET\t20\n#define BRCMF_SHARED_HTOD_MB_DATA_ADDR_OFFSET\t40\n#define BRCMF_SHARED_DTOH_MB_DATA_ADDR_OFFSET\t44\n#define BRCMF_SHARED_RING_INFO_ADDR_OFFSET\t48\n#define BRCMF_SHARED_DMA_SCRATCH_LEN_OFFSET\t52\n#define BRCMF_SHARED_DMA_SCRATCH_ADDR_OFFSET\t56\n#define BRCMF_SHARED_DMA_RINGUPD_LEN_OFFSET\t64\n#define BRCMF_SHARED_DMA_RINGUPD_ADDR_OFFSET\t68\n\n#define BRCMF_RING_H2D_RING_COUNT_OFFSET\t0\n#define BRCMF_RING_D2H_RING_COUNT_OFFSET\t1\n#define BRCMF_RING_H2D_RING_MEM_OFFSET\t\t4\n#define BRCMF_RING_H2D_RING_STATE_OFFSET\t8\n\n#define BRCMF_RING_MEM_BASE_ADDR_OFFSET\t\t8\n#define BRCMF_RING_MAX_ITEM_OFFSET\t\t4\n#define BRCMF_RING_LEN_ITEMS_OFFSET\t\t6\n#define BRCMF_RING_MEM_SZ\t\t\t16\n#define BRCMF_RING_STATE_SZ\t\t\t8\n\n#define BRCMF_DEF_MAX_RXBUFPOST\t\t\t255\n\n#define BRCMF_CONSOLE_BUFADDR_OFFSET\t\t8\n#define BRCMF_CONSOLE_BUFSIZE_OFFSET\t\t12\n#define BRCMF_CONSOLE_WRITEIDX_OFFSET\t\t16\n\n#define BRCMF_DMA_D2H_SCRATCH_BUF_LEN\t\t8\n#define BRCMF_DMA_D2H_RINGUPD_BUF_LEN\t\t1024\n\n#define BRCMF_D2H_DEV_D3_ACK\t\t\t0x00000001\n#define BRCMF_D2H_DEV_DS_ENTER_REQ\t\t0x00000002\n#define BRCMF_D2H_DEV_DS_EXIT_NOTE\t\t0x00000004\n#define BRCMF_D2H_DEV_FWHALT\t\t\t0x10000000\n\n#define BRCMF_H2D_HOST_D3_INFORM\t\t0x00000001\n#define BRCMF_H2D_HOST_DS_ACK\t\t\t0x00000002\n#define BRCMF_H2D_HOST_D0_INFORM_IN_USE\t\t0x00000008\n#define BRCMF_H2D_HOST_D0_INFORM\t\t0x00000010\n\n#define BRCMF_PCIE_MBDATA_TIMEOUT\t\tmsecs_to_jiffies(2000)\n\n#define BRCMF_PCIE_CFGREG_STATUS_CMD\t\t0x4\n#define BRCMF_PCIE_CFGREG_PM_CSR\t\t0x4C\n#define BRCMF_PCIE_CFGREG_MSI_CAP\t\t0x58\n#define BRCMF_PCIE_CFGREG_MSI_ADDR_L\t\t0x5C\n#define BRCMF_PCIE_CFGREG_MSI_ADDR_H\t\t0x60\n#define BRCMF_PCIE_CFGREG_MSI_DATA\t\t0x64\n#define BRCMF_PCIE_CFGREG_LINK_STATUS_CTRL\t0xBC\n#define BRCMF_PCIE_CFGREG_LINK_STATUS_CTRL2\t0xDC\n#define BRCMF_PCIE_CFGREG_RBAR_CTRL\t\t0x228\n#define BRCMF_PCIE_CFGREG_PML1_SUB_CTRL1\t0x248\n#define BRCMF_PCIE_CFGREG_REG_BAR2_CONFIG\t0x4E0\n#define BRCMF_PCIE_CFGREG_REG_BAR3_CONFIG\t0x4F4\n#define BRCMF_PCIE_LINK_STATUS_CTRL_ASPM_ENAB\t3\n\n \n#define BRCMF_RAMSIZE_MAGIC\t\t\t0x534d4152\t \n#define BRCMF_RAMSIZE_OFFSET\t\t\t0x6c\n\n\nstruct brcmf_pcie_console {\n\tu32 base_addr;\n\tu32 buf_addr;\n\tu32 bufsize;\n\tu32 read_idx;\n\tu8 log_str[256];\n\tu8 log_idx;\n};\n\nstruct brcmf_pcie_shared_info {\n\tu32 tcm_base_address;\n\tu32 flags;\n\tstruct brcmf_pcie_ringbuf *commonrings[BRCMF_NROF_COMMON_MSGRINGS];\n\tstruct brcmf_pcie_ringbuf *flowrings;\n\tu16 max_rxbufpost;\n\tu16 max_flowrings;\n\tu16 max_submissionrings;\n\tu16 max_completionrings;\n\tu32 rx_dataoffset;\n\tu32 htod_mb_data_addr;\n\tu32 dtoh_mb_data_addr;\n\tu32 ring_info_addr;\n\tstruct brcmf_pcie_console console;\n\tvoid *scratch;\n\tdma_addr_t scratch_dmahandle;\n\tvoid *ringupd;\n\tdma_addr_t ringupd_dmahandle;\n\tu8 version;\n};\n\nstruct brcmf_pcie_core_info {\n\tu32 base;\n\tu32 wrapbase;\n};\n\n#define BRCMF_OTP_MAX_PARAM_LEN 16\n\nstruct brcmf_otp_params {\n\tchar module[BRCMF_OTP_MAX_PARAM_LEN];\n\tchar vendor[BRCMF_OTP_MAX_PARAM_LEN];\n\tchar version[BRCMF_OTP_MAX_PARAM_LEN];\n\tbool valid;\n};\n\nstruct brcmf_pciedev_info {\n\tenum brcmf_pcie_state state;\n\tbool in_irq;\n\tstruct pci_dev *pdev;\n\tchar fw_name[BRCMF_FW_NAME_LEN];\n\tchar nvram_name[BRCMF_FW_NAME_LEN];\n\tchar clm_name[BRCMF_FW_NAME_LEN];\n\tchar txcap_name[BRCMF_FW_NAME_LEN];\n\tconst struct firmware *clm_fw;\n\tconst struct firmware *txcap_fw;\n\tconst struct brcmf_pcie_reginfo *reginfo;\n\tvoid __iomem *regs;\n\tvoid __iomem *tcm;\n\tu32 ram_base;\n\tu32 ram_size;\n\tstruct brcmf_chip *ci;\n\tu32 coreid;\n\tstruct brcmf_pcie_shared_info shared;\n\twait_queue_head_t mbdata_resp_wait;\n\tbool mbdata_completed;\n\tbool irq_allocated;\n\tbool wowl_enabled;\n\tu8 dma_idx_sz;\n\tvoid *idxbuf;\n\tu32 idxbuf_sz;\n\tdma_addr_t idxbuf_dmahandle;\n\tu16 (*read_ptr)(struct brcmf_pciedev_info *devinfo, u32 mem_offset);\n\tvoid (*write_ptr)(struct brcmf_pciedev_info *devinfo, u32 mem_offset,\n\t\t\t  u16 value);\n\tstruct brcmf_mp_device *settings;\n\tstruct brcmf_otp_params otp;\n#ifdef DEBUG\n\tu32 console_interval;\n\tbool console_active;\n\tstruct timer_list timer;\n#endif\n};\n\nstruct brcmf_pcie_ringbuf {\n\tstruct brcmf_commonring commonring;\n\tdma_addr_t dma_handle;\n\tu32 w_idx_addr;\n\tu32 r_idx_addr;\n\tstruct brcmf_pciedev_info *devinfo;\n\tu8 id;\n};\n\n \nstruct brcmf_pcie_dhi_ringinfo {\n\t__le32\t\t\tringmem;\n\t__le32\t\t\th2d_w_idx_ptr;\n\t__le32\t\t\th2d_r_idx_ptr;\n\t__le32\t\t\td2h_w_idx_ptr;\n\t__le32\t\t\td2h_r_idx_ptr;\n\tstruct msgbuf_buf_addr\th2d_w_idx_hostaddr;\n\tstruct msgbuf_buf_addr\th2d_r_idx_hostaddr;\n\tstruct msgbuf_buf_addr\td2h_w_idx_hostaddr;\n\tstruct msgbuf_buf_addr\td2h_r_idx_hostaddr;\n\t__le16\t\t\tmax_flowrings;\n\t__le16\t\t\tmax_submissionrings;\n\t__le16\t\t\tmax_completionrings;\n};\n\nstatic const u32 brcmf_ring_max_item[BRCMF_NROF_COMMON_MSGRINGS] = {\n\tBRCMF_H2D_MSGRING_CONTROL_SUBMIT_MAX_ITEM,\n\tBRCMF_H2D_MSGRING_RXPOST_SUBMIT_MAX_ITEM,\n\tBRCMF_D2H_MSGRING_CONTROL_COMPLETE_MAX_ITEM,\n\tBRCMF_D2H_MSGRING_TX_COMPLETE_MAX_ITEM,\n\tBRCMF_D2H_MSGRING_RX_COMPLETE_MAX_ITEM\n};\n\nstatic const u32 brcmf_ring_itemsize_pre_v7[BRCMF_NROF_COMMON_MSGRINGS] = {\n\tBRCMF_H2D_MSGRING_CONTROL_SUBMIT_ITEMSIZE,\n\tBRCMF_H2D_MSGRING_RXPOST_SUBMIT_ITEMSIZE,\n\tBRCMF_D2H_MSGRING_CONTROL_COMPLETE_ITEMSIZE,\n\tBRCMF_D2H_MSGRING_TX_COMPLETE_ITEMSIZE_PRE_V7,\n\tBRCMF_D2H_MSGRING_RX_COMPLETE_ITEMSIZE_PRE_V7\n};\n\nstatic const u32 brcmf_ring_itemsize[BRCMF_NROF_COMMON_MSGRINGS] = {\n\tBRCMF_H2D_MSGRING_CONTROL_SUBMIT_ITEMSIZE,\n\tBRCMF_H2D_MSGRING_RXPOST_SUBMIT_ITEMSIZE,\n\tBRCMF_D2H_MSGRING_CONTROL_COMPLETE_ITEMSIZE,\n\tBRCMF_D2H_MSGRING_TX_COMPLETE_ITEMSIZE,\n\tBRCMF_D2H_MSGRING_RX_COMPLETE_ITEMSIZE\n};\n\nstruct brcmf_pcie_reginfo {\n\tu32 intmask;\n\tu32 mailboxint;\n\tu32 mailboxmask;\n\tu32 h2d_mailbox_0;\n\tu32 h2d_mailbox_1;\n\tu32 int_d2h_db;\n\tu32 int_fn0;\n};\n\nstatic const struct brcmf_pcie_reginfo brcmf_reginfo_default = {\n\t.intmask = BRCMF_PCIE_PCIE2REG_INTMASK,\n\t.mailboxint = BRCMF_PCIE_PCIE2REG_MAILBOXINT,\n\t.mailboxmask = BRCMF_PCIE_PCIE2REG_MAILBOXMASK,\n\t.h2d_mailbox_0 = BRCMF_PCIE_PCIE2REG_H2D_MAILBOX_0,\n\t.h2d_mailbox_1 = BRCMF_PCIE_PCIE2REG_H2D_MAILBOX_1,\n\t.int_d2h_db = BRCMF_PCIE_MB_INT_D2H_DB,\n\t.int_fn0 = BRCMF_PCIE_MB_INT_FN0,\n};\n\nstatic const struct brcmf_pcie_reginfo brcmf_reginfo_64 = {\n\t.intmask = BRCMF_PCIE_64_PCIE2REG_INTMASK,\n\t.mailboxint = BRCMF_PCIE_64_PCIE2REG_MAILBOXINT,\n\t.mailboxmask = BRCMF_PCIE_64_PCIE2REG_MAILBOXMASK,\n\t.h2d_mailbox_0 = BRCMF_PCIE_64_PCIE2REG_H2D_MAILBOX_0,\n\t.h2d_mailbox_1 = BRCMF_PCIE_64_PCIE2REG_H2D_MAILBOX_1,\n\t.int_d2h_db = BRCMF_PCIE_64_MB_INT_D2H_DB,\n\t.int_fn0 = 0,\n};\n\nstatic void brcmf_pcie_setup(struct device *dev, int ret,\n\t\t\t     struct brcmf_fw_request *fwreq);\nstatic struct brcmf_fw_request *\nbrcmf_pcie_prepare_fw_request(struct brcmf_pciedev_info *devinfo);\nstatic void\nbrcmf_pcie_fwcon_timer(struct brcmf_pciedev_info *devinfo, bool active);\nstatic void brcmf_pcie_debugfs_create(struct device *dev);\n\nstatic u16\nbrcmf_pcie_read_reg16(struct brcmf_pciedev_info *devinfo, u32 reg_offset)\n{\n\tvoid __iomem *address = devinfo->regs + reg_offset;\n\n\treturn ioread16(address);\n}\n\nstatic u32\nbrcmf_pcie_read_reg32(struct brcmf_pciedev_info *devinfo, u32 reg_offset)\n{\n\tvoid __iomem *address = devinfo->regs + reg_offset;\n\n\treturn (ioread32(address));\n}\n\n\nstatic void\nbrcmf_pcie_write_reg32(struct brcmf_pciedev_info *devinfo, u32 reg_offset,\n\t\t       u32 value)\n{\n\tvoid __iomem *address = devinfo->regs + reg_offset;\n\n\tiowrite32(value, address);\n}\n\n\nstatic u8\nbrcmf_pcie_read_tcm8(struct brcmf_pciedev_info *devinfo, u32 mem_offset)\n{\n\tvoid __iomem *address = devinfo->tcm + mem_offset;\n\n\treturn (ioread8(address));\n}\n\n\nstatic u16\nbrcmf_pcie_read_tcm16(struct brcmf_pciedev_info *devinfo, u32 mem_offset)\n{\n\tvoid __iomem *address = devinfo->tcm + mem_offset;\n\n\treturn (ioread16(address));\n}\n\n\nstatic void\nbrcmf_pcie_write_tcm16(struct brcmf_pciedev_info *devinfo, u32 mem_offset,\n\t\t       u16 value)\n{\n\tvoid __iomem *address = devinfo->tcm + mem_offset;\n\n\tiowrite16(value, address);\n}\n\n\nstatic u16\nbrcmf_pcie_read_idx(struct brcmf_pciedev_info *devinfo, u32 mem_offset)\n{\n\tu16 *address = devinfo->idxbuf + mem_offset;\n\n\treturn (*(address));\n}\n\n\nstatic void\nbrcmf_pcie_write_idx(struct brcmf_pciedev_info *devinfo, u32 mem_offset,\n\t\t     u16 value)\n{\n\tu16 *address = devinfo->idxbuf + mem_offset;\n\n\t*(address) = value;\n}\n\n\nstatic u32\nbrcmf_pcie_read_tcm32(struct brcmf_pciedev_info *devinfo, u32 mem_offset)\n{\n\tvoid __iomem *address = devinfo->tcm + mem_offset;\n\n\treturn (ioread32(address));\n}\n\n\nstatic void\nbrcmf_pcie_write_tcm32(struct brcmf_pciedev_info *devinfo, u32 mem_offset,\n\t\t       u32 value)\n{\n\tvoid __iomem *address = devinfo->tcm + mem_offset;\n\n\tiowrite32(value, address);\n}\n\n\nstatic u32\nbrcmf_pcie_read_ram32(struct brcmf_pciedev_info *devinfo, u32 mem_offset)\n{\n\tvoid __iomem *addr = devinfo->tcm + devinfo->ci->rambase + mem_offset;\n\n\treturn (ioread32(addr));\n}\n\n\nstatic void\nbrcmf_pcie_write_ram32(struct brcmf_pciedev_info *devinfo, u32 mem_offset,\n\t\t       u32 value)\n{\n\tvoid __iomem *addr = devinfo->tcm + devinfo->ci->rambase + mem_offset;\n\n\tiowrite32(value, addr);\n}\n\n\nstatic void\nbrcmf_pcie_copy_dev_tomem(struct brcmf_pciedev_info *devinfo, u32 mem_offset,\n\t\t\t  void *dstaddr, u32 len)\n{\n\tvoid __iomem *address = devinfo->tcm + mem_offset;\n\t__le32 *dst32;\n\t__le16 *dst16;\n\tu8 *dst8;\n\n\tif (((ulong)address & 4) || ((ulong)dstaddr & 4) || (len & 4)) {\n\t\tif (((ulong)address & 2) || ((ulong)dstaddr & 2) || (len & 2)) {\n\t\t\tdst8 = (u8 *)dstaddr;\n\t\t\twhile (len) {\n\t\t\t\t*dst8 = ioread8(address);\n\t\t\t\taddress++;\n\t\t\t\tdst8++;\n\t\t\t\tlen--;\n\t\t\t}\n\t\t} else {\n\t\t\tlen = len / 2;\n\t\t\tdst16 = (__le16 *)dstaddr;\n\t\t\twhile (len) {\n\t\t\t\t*dst16 = cpu_to_le16(ioread16(address));\n\t\t\t\taddress += 2;\n\t\t\t\tdst16++;\n\t\t\t\tlen--;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlen = len / 4;\n\t\tdst32 = (__le32 *)dstaddr;\n\t\twhile (len) {\n\t\t\t*dst32 = cpu_to_le32(ioread32(address));\n\t\t\taddress += 4;\n\t\t\tdst32++;\n\t\t\tlen--;\n\t\t}\n\t}\n}\n\n\n#define READCC32(devinfo, reg) brcmf_pcie_read_reg32(devinfo, \\\n\t\tCHIPCREGOFFS(reg))\n#define WRITECC32(devinfo, reg, value) brcmf_pcie_write_reg32(devinfo, \\\n\t\tCHIPCREGOFFS(reg), value)\n\n\nstatic void\nbrcmf_pcie_select_core(struct brcmf_pciedev_info *devinfo, u16 coreid)\n{\n\tconst struct pci_dev *pdev = devinfo->pdev;\n\tstruct brcmf_bus *bus = dev_get_drvdata(&pdev->dev);\n\tstruct brcmf_core *core;\n\tu32 bar0_win;\n\n\tcore = brcmf_chip_get_core(devinfo->ci, coreid);\n\tif (core) {\n\t\tbar0_win = core->base;\n\t\tpci_write_config_dword(pdev, BRCMF_PCIE_BAR0_WINDOW, bar0_win);\n\t\tif (pci_read_config_dword(pdev, BRCMF_PCIE_BAR0_WINDOW,\n\t\t\t\t\t  &bar0_win) == 0) {\n\t\t\tif (bar0_win != core->base) {\n\t\t\t\tbar0_win = core->base;\n\t\t\t\tpci_write_config_dword(pdev,\n\t\t\t\t\t\t       BRCMF_PCIE_BAR0_WINDOW,\n\t\t\t\t\t\t       bar0_win);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tbrcmf_err(bus, \"Unsupported core selected %x\\n\", coreid);\n\t}\n}\n\n\nstatic void brcmf_pcie_reset_device(struct brcmf_pciedev_info *devinfo)\n{\n\tstruct brcmf_core *core;\n\tu16 cfg_offset[] = { BRCMF_PCIE_CFGREG_STATUS_CMD,\n\t\t\t     BRCMF_PCIE_CFGREG_PM_CSR,\n\t\t\t     BRCMF_PCIE_CFGREG_MSI_CAP,\n\t\t\t     BRCMF_PCIE_CFGREG_MSI_ADDR_L,\n\t\t\t     BRCMF_PCIE_CFGREG_MSI_ADDR_H,\n\t\t\t     BRCMF_PCIE_CFGREG_MSI_DATA,\n\t\t\t     BRCMF_PCIE_CFGREG_LINK_STATUS_CTRL2,\n\t\t\t     BRCMF_PCIE_CFGREG_RBAR_CTRL,\n\t\t\t     BRCMF_PCIE_CFGREG_PML1_SUB_CTRL1,\n\t\t\t     BRCMF_PCIE_CFGREG_REG_BAR2_CONFIG,\n\t\t\t     BRCMF_PCIE_CFGREG_REG_BAR3_CONFIG };\n\tu32 i;\n\tu32 val;\n\tu32 lsc;\n\n\tif (!devinfo->ci)\n\t\treturn;\n\n\t \n\tbrcmf_pcie_select_core(devinfo, BCMA_CORE_PCIE2);\n\tpci_read_config_dword(devinfo->pdev, BRCMF_PCIE_REG_LINK_STATUS_CTRL,\n\t\t\t      &lsc);\n\tval = lsc & (~BRCMF_PCIE_LINK_STATUS_CTRL_ASPM_ENAB);\n\tpci_write_config_dword(devinfo->pdev, BRCMF_PCIE_REG_LINK_STATUS_CTRL,\n\t\t\t       val);\n\n\t \n\tbrcmf_pcie_select_core(devinfo, BCMA_CORE_CHIPCOMMON);\n\tWRITECC32(devinfo, watchdog, 4);\n\tmsleep(100);\n\n\t \n\tbrcmf_pcie_select_core(devinfo, BCMA_CORE_PCIE2);\n\tpci_write_config_dword(devinfo->pdev, BRCMF_PCIE_REG_LINK_STATUS_CTRL,\n\t\t\t       lsc);\n\n\tcore = brcmf_chip_get_core(devinfo->ci, BCMA_CORE_PCIE2);\n\tif (core->rev <= 13) {\n\t\tfor (i = 0; i < ARRAY_SIZE(cfg_offset); i++) {\n\t\t\tbrcmf_pcie_write_reg32(devinfo,\n\t\t\t\t\t       BRCMF_PCIE_PCIE2REG_CONFIGADDR,\n\t\t\t\t\t       cfg_offset[i]);\n\t\t\tval = brcmf_pcie_read_reg32(devinfo,\n\t\t\t\tBRCMF_PCIE_PCIE2REG_CONFIGDATA);\n\t\t\tbrcmf_dbg(PCIE, \"config offset 0x%04x, value 0x%04x\\n\",\n\t\t\t\t  cfg_offset[i], val);\n\t\t\tbrcmf_pcie_write_reg32(devinfo,\n\t\t\t\t\t       BRCMF_PCIE_PCIE2REG_CONFIGDATA,\n\t\t\t\t\t       val);\n\t\t}\n\t}\n}\n\n\nstatic void brcmf_pcie_attach(struct brcmf_pciedev_info *devinfo)\n{\n\tu32 config;\n\n\t \n\tbrcmf_pcie_select_core(devinfo, BCMA_CORE_PCIE2);\n\tbrcmf_pcie_write_reg32(devinfo, BRCMF_PCIE_PCIE2REG_CONFIGADDR, 0x4e0);\n\tconfig = brcmf_pcie_read_reg32(devinfo, BRCMF_PCIE_PCIE2REG_CONFIGDATA);\n\tbrcmf_pcie_write_reg32(devinfo, BRCMF_PCIE_PCIE2REG_CONFIGDATA, config);\n\n\tdevice_wakeup_enable(&devinfo->pdev->dev);\n}\n\n\nstatic int brcmf_pcie_enter_download_state(struct brcmf_pciedev_info *devinfo)\n{\n\tif (devinfo->ci->chip == BRCM_CC_43602_CHIP_ID) {\n\t\tbrcmf_pcie_select_core(devinfo, BCMA_CORE_ARM_CR4);\n\t\tbrcmf_pcie_write_reg32(devinfo, BRCMF_PCIE_ARMCR4REG_BANKIDX,\n\t\t\t\t       5);\n\t\tbrcmf_pcie_write_reg32(devinfo, BRCMF_PCIE_ARMCR4REG_BANKPDA,\n\t\t\t\t       0);\n\t\tbrcmf_pcie_write_reg32(devinfo, BRCMF_PCIE_ARMCR4REG_BANKIDX,\n\t\t\t\t       7);\n\t\tbrcmf_pcie_write_reg32(devinfo, BRCMF_PCIE_ARMCR4REG_BANKPDA,\n\t\t\t\t       0);\n\t}\n\treturn 0;\n}\n\n\nstatic int brcmf_pcie_exit_download_state(struct brcmf_pciedev_info *devinfo,\n\t\t\t\t\t  u32 resetintr)\n{\n\tstruct brcmf_core *core;\n\n\tif (devinfo->ci->chip == BRCM_CC_43602_CHIP_ID) {\n\t\tcore = brcmf_chip_get_core(devinfo->ci, BCMA_CORE_INTERNAL_MEM);\n\t\tbrcmf_chip_resetcore(core, 0, 0, 0);\n\t}\n\n\tif (!brcmf_chip_set_active(devinfo->ci, resetintr))\n\t\treturn -EIO;\n\treturn 0;\n}\n\n\nstatic int\nbrcmf_pcie_send_mb_data(struct brcmf_pciedev_info *devinfo, u32 htod_mb_data)\n{\n\tstruct brcmf_pcie_shared_info *shared;\n\tstruct brcmf_core *core;\n\tu32 addr;\n\tu32 cur_htod_mb_data;\n\tu32 i;\n\n\tshared = &devinfo->shared;\n\taddr = shared->htod_mb_data_addr;\n\tcur_htod_mb_data = brcmf_pcie_read_tcm32(devinfo, addr);\n\n\tif (cur_htod_mb_data != 0)\n\t\tbrcmf_dbg(PCIE, \"MB transaction is already pending 0x%04x\\n\",\n\t\t\t  cur_htod_mb_data);\n\n\ti = 0;\n\twhile (cur_htod_mb_data != 0) {\n\t\tmsleep(10);\n\t\ti++;\n\t\tif (i > 100)\n\t\t\treturn -EIO;\n\t\tcur_htod_mb_data = brcmf_pcie_read_tcm32(devinfo, addr);\n\t}\n\n\tbrcmf_pcie_write_tcm32(devinfo, addr, htod_mb_data);\n\tpci_write_config_dword(devinfo->pdev, BRCMF_PCIE_REG_SBMBX, 1);\n\n\t \n\tcore = brcmf_chip_get_core(devinfo->ci, BCMA_CORE_PCIE2);\n\tif (core->rev <= 13)\n\t\tpci_write_config_dword(devinfo->pdev, BRCMF_PCIE_REG_SBMBX, 1);\n\n\treturn 0;\n}\n\n\nstatic void brcmf_pcie_handle_mb_data(struct brcmf_pciedev_info *devinfo)\n{\n\tstruct brcmf_pcie_shared_info *shared;\n\tu32 addr;\n\tu32 dtoh_mb_data;\n\n\tshared = &devinfo->shared;\n\taddr = shared->dtoh_mb_data_addr;\n\tdtoh_mb_data = brcmf_pcie_read_tcm32(devinfo, addr);\n\n\tif (!dtoh_mb_data)\n\t\treturn;\n\n\tbrcmf_pcie_write_tcm32(devinfo, addr, 0);\n\n\tbrcmf_dbg(PCIE, \"D2H_MB_DATA: 0x%04x\\n\", dtoh_mb_data);\n\tif (dtoh_mb_data & BRCMF_D2H_DEV_DS_ENTER_REQ)  {\n\t\tbrcmf_dbg(PCIE, \"D2H_MB_DATA: DEEP SLEEP REQ\\n\");\n\t\tbrcmf_pcie_send_mb_data(devinfo, BRCMF_H2D_HOST_DS_ACK);\n\t\tbrcmf_dbg(PCIE, \"D2H_MB_DATA: sent DEEP SLEEP ACK\\n\");\n\t}\n\tif (dtoh_mb_data & BRCMF_D2H_DEV_DS_EXIT_NOTE)\n\t\tbrcmf_dbg(PCIE, \"D2H_MB_DATA: DEEP SLEEP EXIT\\n\");\n\tif (dtoh_mb_data & BRCMF_D2H_DEV_D3_ACK) {\n\t\tbrcmf_dbg(PCIE, \"D2H_MB_DATA: D3 ACK\\n\");\n\t\tdevinfo->mbdata_completed = true;\n\t\twake_up(&devinfo->mbdata_resp_wait);\n\t}\n\tif (dtoh_mb_data & BRCMF_D2H_DEV_FWHALT) {\n\t\tbrcmf_dbg(PCIE, \"D2H_MB_DATA: FW HALT\\n\");\n\t\tbrcmf_fw_crashed(&devinfo->pdev->dev);\n\t}\n}\n\n\nstatic void brcmf_pcie_bus_console_init(struct brcmf_pciedev_info *devinfo)\n{\n\tstruct brcmf_pcie_shared_info *shared;\n\tstruct brcmf_pcie_console *console;\n\tu32 addr;\n\n\tshared = &devinfo->shared;\n\tconsole = &shared->console;\n\taddr = shared->tcm_base_address + BRCMF_SHARED_CONSOLE_ADDR_OFFSET;\n\tconsole->base_addr = brcmf_pcie_read_tcm32(devinfo, addr);\n\n\taddr = console->base_addr + BRCMF_CONSOLE_BUFADDR_OFFSET;\n\tconsole->buf_addr = brcmf_pcie_read_tcm32(devinfo, addr);\n\taddr = console->base_addr + BRCMF_CONSOLE_BUFSIZE_OFFSET;\n\tconsole->bufsize = brcmf_pcie_read_tcm32(devinfo, addr);\n\n\tbrcmf_dbg(FWCON, \"Console: base %x, buf %x, size %d\\n\",\n\t\t  console->base_addr, console->buf_addr, console->bufsize);\n}\n\n \nstatic void brcmf_pcie_bus_console_read(struct brcmf_pciedev_info *devinfo,\n\t\t\t\t\tbool error)\n{\n\tstruct pci_dev *pdev = devinfo->pdev;\n\tstruct brcmf_bus *bus = dev_get_drvdata(&pdev->dev);\n\tstruct brcmf_pcie_console *console;\n\tu32 addr;\n\tu8 ch;\n\tu32 newidx;\n\n\tif (!error && !BRCMF_FWCON_ON())\n\t\treturn;\n\n\tconsole = &devinfo->shared.console;\n\tif (!console->base_addr)\n\t\treturn;\n\taddr = console->base_addr + BRCMF_CONSOLE_WRITEIDX_OFFSET;\n\tnewidx = brcmf_pcie_read_tcm32(devinfo, addr);\n\twhile (newidx != console->read_idx) {\n\t\taddr = console->buf_addr + console->read_idx;\n\t\tch = brcmf_pcie_read_tcm8(devinfo, addr);\n\t\tconsole->read_idx++;\n\t\tif (console->read_idx == console->bufsize)\n\t\t\tconsole->read_idx = 0;\n\t\tif (ch == '\\r')\n\t\t\tcontinue;\n\t\tconsole->log_str[console->log_idx] = ch;\n\t\tconsole->log_idx++;\n\t\tif ((ch != '\\n') &&\n\t\t    (console->log_idx == (sizeof(console->log_str) - 2))) {\n\t\t\tch = '\\n';\n\t\t\tconsole->log_str[console->log_idx] = ch;\n\t\t\tconsole->log_idx++;\n\t\t}\n\t\tif (ch == '\\n') {\n\t\t\tconsole->log_str[console->log_idx] = 0;\n\t\t\tif (error)\n\t\t\t\t__brcmf_err(bus, __func__, \"CONSOLE: %s\",\n\t\t\t\t\t    console->log_str);\n\t\t\telse\n\t\t\t\tpr_debug(\"CONSOLE: %s\", console->log_str);\n\t\t\tconsole->log_idx = 0;\n\t\t}\n\t}\n}\n\n\nstatic void brcmf_pcie_intr_disable(struct brcmf_pciedev_info *devinfo)\n{\n\tbrcmf_pcie_write_reg32(devinfo, devinfo->reginfo->mailboxmask, 0);\n}\n\n\nstatic void brcmf_pcie_intr_enable(struct brcmf_pciedev_info *devinfo)\n{\n\tbrcmf_pcie_write_reg32(devinfo, devinfo->reginfo->mailboxmask,\n\t\t\t       devinfo->reginfo->int_d2h_db |\n\t\t\t       devinfo->reginfo->int_fn0);\n}\n\nstatic void brcmf_pcie_hostready(struct brcmf_pciedev_info *devinfo)\n{\n\tif (devinfo->shared.flags & BRCMF_PCIE_SHARED_HOSTRDY_DB1)\n\t\tbrcmf_pcie_write_reg32(devinfo,\n\t\t\t\t       devinfo->reginfo->h2d_mailbox_1, 1);\n}\n\nstatic irqreturn_t brcmf_pcie_quick_check_isr(int irq, void *arg)\n{\n\tstruct brcmf_pciedev_info *devinfo = (struct brcmf_pciedev_info *)arg;\n\n\tif (brcmf_pcie_read_reg32(devinfo, devinfo->reginfo->mailboxint)) {\n\t\tbrcmf_pcie_intr_disable(devinfo);\n\t\tbrcmf_dbg(PCIE, \"Enter\\n\");\n\t\treturn IRQ_WAKE_THREAD;\n\t}\n\treturn IRQ_NONE;\n}\n\n\nstatic irqreturn_t brcmf_pcie_isr_thread(int irq, void *arg)\n{\n\tstruct brcmf_pciedev_info *devinfo = (struct brcmf_pciedev_info *)arg;\n\tu32 status;\n\n\tdevinfo->in_irq = true;\n\tstatus = brcmf_pcie_read_reg32(devinfo, devinfo->reginfo->mailboxint);\n\tbrcmf_dbg(PCIE, \"Enter %x\\n\", status);\n\tif (status) {\n\t\tbrcmf_pcie_write_reg32(devinfo, devinfo->reginfo->mailboxint,\n\t\t\t\t       status);\n\t\tif (status & devinfo->reginfo->int_fn0)\n\t\t\tbrcmf_pcie_handle_mb_data(devinfo);\n\t\tif (status & devinfo->reginfo->int_d2h_db) {\n\t\t\tif (devinfo->state == BRCMFMAC_PCIE_STATE_UP)\n\t\t\t\tbrcmf_proto_msgbuf_rx_trigger(\n\t\t\t\t\t\t\t&devinfo->pdev->dev);\n\t\t}\n\t}\n\tbrcmf_pcie_bus_console_read(devinfo, false);\n\tif (devinfo->state == BRCMFMAC_PCIE_STATE_UP)\n\t\tbrcmf_pcie_intr_enable(devinfo);\n\tdevinfo->in_irq = false;\n\treturn IRQ_HANDLED;\n}\n\n\nstatic int brcmf_pcie_request_irq(struct brcmf_pciedev_info *devinfo)\n{\n\tstruct pci_dev *pdev = devinfo->pdev;\n\tstruct brcmf_bus *bus = dev_get_drvdata(&pdev->dev);\n\n\tbrcmf_pcie_intr_disable(devinfo);\n\n\tbrcmf_dbg(PCIE, \"Enter\\n\");\n\n\tpci_enable_msi(pdev);\n\tif (request_threaded_irq(pdev->irq, brcmf_pcie_quick_check_isr,\n\t\t\t\t brcmf_pcie_isr_thread, IRQF_SHARED,\n\t\t\t\t \"brcmf_pcie_intr\", devinfo)) {\n\t\tpci_disable_msi(pdev);\n\t\tbrcmf_err(bus, \"Failed to request IRQ %d\\n\", pdev->irq);\n\t\treturn -EIO;\n\t}\n\tdevinfo->irq_allocated = true;\n\treturn 0;\n}\n\n\nstatic void brcmf_pcie_release_irq(struct brcmf_pciedev_info *devinfo)\n{\n\tstruct pci_dev *pdev = devinfo->pdev;\n\tstruct brcmf_bus *bus = dev_get_drvdata(&pdev->dev);\n\tu32 status;\n\tu32 count;\n\n\tif (!devinfo->irq_allocated)\n\t\treturn;\n\n\tbrcmf_pcie_intr_disable(devinfo);\n\tfree_irq(pdev->irq, devinfo);\n\tpci_disable_msi(pdev);\n\n\tmsleep(50);\n\tcount = 0;\n\twhile ((devinfo->in_irq) && (count < 20)) {\n\t\tmsleep(50);\n\t\tcount++;\n\t}\n\tif (devinfo->in_irq)\n\t\tbrcmf_err(bus, \"Still in IRQ (processing) !!!\\n\");\n\n\tstatus = brcmf_pcie_read_reg32(devinfo, devinfo->reginfo->mailboxint);\n\tbrcmf_pcie_write_reg32(devinfo, devinfo->reginfo->mailboxint, status);\n\n\tdevinfo->irq_allocated = false;\n}\n\n\nstatic int brcmf_pcie_ring_mb_write_rptr(void *ctx)\n{\n\tstruct brcmf_pcie_ringbuf *ring = (struct brcmf_pcie_ringbuf *)ctx;\n\tstruct brcmf_pciedev_info *devinfo = ring->devinfo;\n\tstruct brcmf_commonring *commonring = &ring->commonring;\n\n\tif (devinfo->state != BRCMFMAC_PCIE_STATE_UP)\n\t\treturn -EIO;\n\n\tbrcmf_dbg(PCIE, \"W r_ptr %d (%d), ring %d\\n\", commonring->r_ptr,\n\t\t  commonring->w_ptr, ring->id);\n\n\tdevinfo->write_ptr(devinfo, ring->r_idx_addr, commonring->r_ptr);\n\n\treturn 0;\n}\n\n\nstatic int brcmf_pcie_ring_mb_write_wptr(void *ctx)\n{\n\tstruct brcmf_pcie_ringbuf *ring = (struct brcmf_pcie_ringbuf *)ctx;\n\tstruct brcmf_pciedev_info *devinfo = ring->devinfo;\n\tstruct brcmf_commonring *commonring = &ring->commonring;\n\n\tif (devinfo->state != BRCMFMAC_PCIE_STATE_UP)\n\t\treturn -EIO;\n\n\tbrcmf_dbg(PCIE, \"W w_ptr %d (%d), ring %d\\n\", commonring->w_ptr,\n\t\t  commonring->r_ptr, ring->id);\n\n\tdevinfo->write_ptr(devinfo, ring->w_idx_addr, commonring->w_ptr);\n\n\treturn 0;\n}\n\n\nstatic int brcmf_pcie_ring_mb_ring_bell(void *ctx)\n{\n\tstruct brcmf_pcie_ringbuf *ring = (struct brcmf_pcie_ringbuf *)ctx;\n\tstruct brcmf_pciedev_info *devinfo = ring->devinfo;\n\n\tif (devinfo->state != BRCMFMAC_PCIE_STATE_UP)\n\t\treturn -EIO;\n\n\tbrcmf_dbg(PCIE, \"RING !\\n\");\n\t \n\tbrcmf_pcie_write_reg32(devinfo, devinfo->reginfo->h2d_mailbox_0, 1);\n\n\treturn 0;\n}\n\n\nstatic int brcmf_pcie_ring_mb_update_rptr(void *ctx)\n{\n\tstruct brcmf_pcie_ringbuf *ring = (struct brcmf_pcie_ringbuf *)ctx;\n\tstruct brcmf_pciedev_info *devinfo = ring->devinfo;\n\tstruct brcmf_commonring *commonring = &ring->commonring;\n\n\tif (devinfo->state != BRCMFMAC_PCIE_STATE_UP)\n\t\treturn -EIO;\n\n\tcommonring->r_ptr = devinfo->read_ptr(devinfo, ring->r_idx_addr);\n\n\tbrcmf_dbg(PCIE, \"R r_ptr %d (%d), ring %d\\n\", commonring->r_ptr,\n\t\t  commonring->w_ptr, ring->id);\n\n\treturn 0;\n}\n\n\nstatic int brcmf_pcie_ring_mb_update_wptr(void *ctx)\n{\n\tstruct brcmf_pcie_ringbuf *ring = (struct brcmf_pcie_ringbuf *)ctx;\n\tstruct brcmf_pciedev_info *devinfo = ring->devinfo;\n\tstruct brcmf_commonring *commonring = &ring->commonring;\n\n\tif (devinfo->state != BRCMFMAC_PCIE_STATE_UP)\n\t\treturn -EIO;\n\n\tcommonring->w_ptr = devinfo->read_ptr(devinfo, ring->w_idx_addr);\n\n\tbrcmf_dbg(PCIE, \"R w_ptr %d (%d), ring %d\\n\", commonring->w_ptr,\n\t\t  commonring->r_ptr, ring->id);\n\n\treturn 0;\n}\n\n\nstatic void *\nbrcmf_pcie_init_dmabuffer_for_device(struct brcmf_pciedev_info *devinfo,\n\t\t\t\t     u32 size, u32 tcm_dma_phys_addr,\n\t\t\t\t     dma_addr_t *dma_handle)\n{\n\tvoid *ring;\n\tu64 address;\n\n\tring = dma_alloc_coherent(&devinfo->pdev->dev, size, dma_handle,\n\t\t\t\t  GFP_KERNEL);\n\tif (!ring)\n\t\treturn NULL;\n\n\taddress = (u64)*dma_handle;\n\tbrcmf_pcie_write_tcm32(devinfo, tcm_dma_phys_addr,\n\t\t\t       address & 0xffffffff);\n\tbrcmf_pcie_write_tcm32(devinfo, tcm_dma_phys_addr + 4, address >> 32);\n\n\treturn (ring);\n}\n\n\nstatic struct brcmf_pcie_ringbuf *\nbrcmf_pcie_alloc_dma_and_ring(struct brcmf_pciedev_info *devinfo, u32 ring_id,\n\t\t\t      u32 tcm_ring_phys_addr)\n{\n\tvoid *dma_buf;\n\tdma_addr_t dma_handle;\n\tstruct brcmf_pcie_ringbuf *ring;\n\tu32 size;\n\tu32 addr;\n\tconst u32 *ring_itemsize_array;\n\n\tif (devinfo->shared.version < BRCMF_PCIE_SHARED_VERSION_7)\n\t\tring_itemsize_array = brcmf_ring_itemsize_pre_v7;\n\telse\n\t\tring_itemsize_array = brcmf_ring_itemsize;\n\n\tsize = brcmf_ring_max_item[ring_id] * ring_itemsize_array[ring_id];\n\tdma_buf = brcmf_pcie_init_dmabuffer_for_device(devinfo, size,\n\t\t\ttcm_ring_phys_addr + BRCMF_RING_MEM_BASE_ADDR_OFFSET,\n\t\t\t&dma_handle);\n\tif (!dma_buf)\n\t\treturn NULL;\n\n\taddr = tcm_ring_phys_addr + BRCMF_RING_MAX_ITEM_OFFSET;\n\tbrcmf_pcie_write_tcm16(devinfo, addr, brcmf_ring_max_item[ring_id]);\n\taddr = tcm_ring_phys_addr + BRCMF_RING_LEN_ITEMS_OFFSET;\n\tbrcmf_pcie_write_tcm16(devinfo, addr, ring_itemsize_array[ring_id]);\n\n\tring = kzalloc(sizeof(*ring), GFP_KERNEL);\n\tif (!ring) {\n\t\tdma_free_coherent(&devinfo->pdev->dev, size, dma_buf,\n\t\t\t\t  dma_handle);\n\t\treturn NULL;\n\t}\n\tbrcmf_commonring_config(&ring->commonring, brcmf_ring_max_item[ring_id],\n\t\t\t\tring_itemsize_array[ring_id], dma_buf);\n\tring->dma_handle = dma_handle;\n\tring->devinfo = devinfo;\n\tbrcmf_commonring_register_cb(&ring->commonring,\n\t\t\t\t     brcmf_pcie_ring_mb_ring_bell,\n\t\t\t\t     brcmf_pcie_ring_mb_update_rptr,\n\t\t\t\t     brcmf_pcie_ring_mb_update_wptr,\n\t\t\t\t     brcmf_pcie_ring_mb_write_rptr,\n\t\t\t\t     brcmf_pcie_ring_mb_write_wptr, ring);\n\n\treturn (ring);\n}\n\n\nstatic void brcmf_pcie_release_ringbuffer(struct device *dev,\n\t\t\t\t\t  struct brcmf_pcie_ringbuf *ring)\n{\n\tvoid *dma_buf;\n\tu32 size;\n\n\tif (!ring)\n\t\treturn;\n\n\tdma_buf = ring->commonring.buf_addr;\n\tif (dma_buf) {\n\t\tsize = ring->commonring.depth * ring->commonring.item_len;\n\t\tdma_free_coherent(dev, size, dma_buf, ring->dma_handle);\n\t}\n\tkfree(ring);\n}\n\n\nstatic void brcmf_pcie_release_ringbuffers(struct brcmf_pciedev_info *devinfo)\n{\n\tu32 i;\n\n\tfor (i = 0; i < BRCMF_NROF_COMMON_MSGRINGS; i++) {\n\t\tbrcmf_pcie_release_ringbuffer(&devinfo->pdev->dev,\n\t\t\t\t\t      devinfo->shared.commonrings[i]);\n\t\tdevinfo->shared.commonrings[i] = NULL;\n\t}\n\tkfree(devinfo->shared.flowrings);\n\tdevinfo->shared.flowrings = NULL;\n\tif (devinfo->idxbuf) {\n\t\tdma_free_coherent(&devinfo->pdev->dev,\n\t\t\t\t  devinfo->idxbuf_sz,\n\t\t\t\t  devinfo->idxbuf,\n\t\t\t\t  devinfo->idxbuf_dmahandle);\n\t\tdevinfo->idxbuf = NULL;\n\t}\n}\n\n\nstatic int brcmf_pcie_init_ringbuffers(struct brcmf_pciedev_info *devinfo)\n{\n\tstruct brcmf_bus *bus = dev_get_drvdata(&devinfo->pdev->dev);\n\tstruct brcmf_pcie_ringbuf *ring;\n\tstruct brcmf_pcie_ringbuf *rings;\n\tu32 d2h_w_idx_ptr;\n\tu32 d2h_r_idx_ptr;\n\tu32 h2d_w_idx_ptr;\n\tu32 h2d_r_idx_ptr;\n\tu32 ring_mem_ptr;\n\tu32 i;\n\tu64 address;\n\tu32 bufsz;\n\tu8 idx_offset;\n\tstruct brcmf_pcie_dhi_ringinfo ringinfo;\n\tu16 max_flowrings;\n\tu16 max_submissionrings;\n\tu16 max_completionrings;\n\n\tmemcpy_fromio(&ringinfo, devinfo->tcm + devinfo->shared.ring_info_addr,\n\t\t      sizeof(ringinfo));\n\tif (devinfo->shared.version >= 6) {\n\t\tmax_submissionrings = le16_to_cpu(ringinfo.max_submissionrings);\n\t\tmax_flowrings = le16_to_cpu(ringinfo.max_flowrings);\n\t\tmax_completionrings = le16_to_cpu(ringinfo.max_completionrings);\n\t} else {\n\t\tmax_submissionrings = le16_to_cpu(ringinfo.max_flowrings);\n\t\tmax_flowrings = max_submissionrings -\n\t\t\t\tBRCMF_NROF_H2D_COMMON_MSGRINGS;\n\t\tmax_completionrings = BRCMF_NROF_D2H_COMMON_MSGRINGS;\n\t}\n\tif (max_flowrings > 512) {\n\t\tbrcmf_err(bus, \"invalid max_flowrings(%d)\\n\", max_flowrings);\n\t\treturn -EIO;\n\t}\n\n\tif (devinfo->dma_idx_sz != 0) {\n\t\tbufsz = (max_submissionrings + max_completionrings) *\n\t\t\tdevinfo->dma_idx_sz * 2;\n\t\tdevinfo->idxbuf = dma_alloc_coherent(&devinfo->pdev->dev, bufsz,\n\t\t\t\t\t\t     &devinfo->idxbuf_dmahandle,\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!devinfo->idxbuf)\n\t\t\tdevinfo->dma_idx_sz = 0;\n\t}\n\n\tif (devinfo->dma_idx_sz == 0) {\n\t\td2h_w_idx_ptr = le32_to_cpu(ringinfo.d2h_w_idx_ptr);\n\t\td2h_r_idx_ptr = le32_to_cpu(ringinfo.d2h_r_idx_ptr);\n\t\th2d_w_idx_ptr = le32_to_cpu(ringinfo.h2d_w_idx_ptr);\n\t\th2d_r_idx_ptr = le32_to_cpu(ringinfo.h2d_r_idx_ptr);\n\t\tidx_offset = sizeof(u32);\n\t\tdevinfo->write_ptr = brcmf_pcie_write_tcm16;\n\t\tdevinfo->read_ptr = brcmf_pcie_read_tcm16;\n\t\tbrcmf_dbg(PCIE, \"Using TCM indices\\n\");\n\t} else {\n\t\tmemset(devinfo->idxbuf, 0, bufsz);\n\t\tdevinfo->idxbuf_sz = bufsz;\n\t\tidx_offset = devinfo->dma_idx_sz;\n\t\tdevinfo->write_ptr = brcmf_pcie_write_idx;\n\t\tdevinfo->read_ptr = brcmf_pcie_read_idx;\n\n\t\th2d_w_idx_ptr = 0;\n\t\taddress = (u64)devinfo->idxbuf_dmahandle;\n\t\tringinfo.h2d_w_idx_hostaddr.low_addr =\n\t\t\tcpu_to_le32(address & 0xffffffff);\n\t\tringinfo.h2d_w_idx_hostaddr.high_addr =\n\t\t\tcpu_to_le32(address >> 32);\n\n\t\th2d_r_idx_ptr = h2d_w_idx_ptr +\n\t\t\t\tmax_submissionrings * idx_offset;\n\t\taddress += max_submissionrings * idx_offset;\n\t\tringinfo.h2d_r_idx_hostaddr.low_addr =\n\t\t\tcpu_to_le32(address & 0xffffffff);\n\t\tringinfo.h2d_r_idx_hostaddr.high_addr =\n\t\t\tcpu_to_le32(address >> 32);\n\n\t\td2h_w_idx_ptr = h2d_r_idx_ptr +\n\t\t\t\tmax_submissionrings * idx_offset;\n\t\taddress += max_submissionrings * idx_offset;\n\t\tringinfo.d2h_w_idx_hostaddr.low_addr =\n\t\t\tcpu_to_le32(address & 0xffffffff);\n\t\tringinfo.d2h_w_idx_hostaddr.high_addr =\n\t\t\tcpu_to_le32(address >> 32);\n\n\t\td2h_r_idx_ptr = d2h_w_idx_ptr +\n\t\t\t\tmax_completionrings * idx_offset;\n\t\taddress += max_completionrings * idx_offset;\n\t\tringinfo.d2h_r_idx_hostaddr.low_addr =\n\t\t\tcpu_to_le32(address & 0xffffffff);\n\t\tringinfo.d2h_r_idx_hostaddr.high_addr =\n\t\t\tcpu_to_le32(address >> 32);\n\n\t\tmemcpy_toio(devinfo->tcm + devinfo->shared.ring_info_addr,\n\t\t\t    &ringinfo, sizeof(ringinfo));\n\t\tbrcmf_dbg(PCIE, \"Using host memory indices\\n\");\n\t}\n\n\tring_mem_ptr = le32_to_cpu(ringinfo.ringmem);\n\n\tfor (i = 0; i < BRCMF_NROF_H2D_COMMON_MSGRINGS; i++) {\n\t\tring = brcmf_pcie_alloc_dma_and_ring(devinfo, i, ring_mem_ptr);\n\t\tif (!ring)\n\t\t\tgoto fail;\n\t\tring->w_idx_addr = h2d_w_idx_ptr;\n\t\tring->r_idx_addr = h2d_r_idx_ptr;\n\t\tring->id = i;\n\t\tdevinfo->shared.commonrings[i] = ring;\n\n\t\th2d_w_idx_ptr += idx_offset;\n\t\th2d_r_idx_ptr += idx_offset;\n\t\tring_mem_ptr += BRCMF_RING_MEM_SZ;\n\t}\n\n\tfor (i = BRCMF_NROF_H2D_COMMON_MSGRINGS;\n\t     i < BRCMF_NROF_COMMON_MSGRINGS; i++) {\n\t\tring = brcmf_pcie_alloc_dma_and_ring(devinfo, i, ring_mem_ptr);\n\t\tif (!ring)\n\t\t\tgoto fail;\n\t\tring->w_idx_addr = d2h_w_idx_ptr;\n\t\tring->r_idx_addr = d2h_r_idx_ptr;\n\t\tring->id = i;\n\t\tdevinfo->shared.commonrings[i] = ring;\n\n\t\td2h_w_idx_ptr += idx_offset;\n\t\td2h_r_idx_ptr += idx_offset;\n\t\tring_mem_ptr += BRCMF_RING_MEM_SZ;\n\t}\n\n\tdevinfo->shared.max_flowrings = max_flowrings;\n\tdevinfo->shared.max_submissionrings = max_submissionrings;\n\tdevinfo->shared.max_completionrings = max_completionrings;\n\trings = kcalloc(max_flowrings, sizeof(*ring), GFP_KERNEL);\n\tif (!rings)\n\t\tgoto fail;\n\n\tbrcmf_dbg(PCIE, \"Nr of flowrings is %d\\n\", max_flowrings);\n\n\tfor (i = 0; i < max_flowrings; i++) {\n\t\tring = &rings[i];\n\t\tring->devinfo = devinfo;\n\t\tring->id = i + BRCMF_H2D_MSGRING_FLOWRING_IDSTART;\n\t\tbrcmf_commonring_register_cb(&ring->commonring,\n\t\t\t\t\t     brcmf_pcie_ring_mb_ring_bell,\n\t\t\t\t\t     brcmf_pcie_ring_mb_update_rptr,\n\t\t\t\t\t     brcmf_pcie_ring_mb_update_wptr,\n\t\t\t\t\t     brcmf_pcie_ring_mb_write_rptr,\n\t\t\t\t\t     brcmf_pcie_ring_mb_write_wptr,\n\t\t\t\t\t     ring);\n\t\tring->w_idx_addr = h2d_w_idx_ptr;\n\t\tring->r_idx_addr = h2d_r_idx_ptr;\n\t\th2d_w_idx_ptr += idx_offset;\n\t\th2d_r_idx_ptr += idx_offset;\n\t}\n\tdevinfo->shared.flowrings = rings;\n\n\treturn 0;\n\nfail:\n\tbrcmf_err(bus, \"Allocating ring buffers failed\\n\");\n\tbrcmf_pcie_release_ringbuffers(devinfo);\n\treturn -ENOMEM;\n}\n\n\nstatic void\nbrcmf_pcie_release_scratchbuffers(struct brcmf_pciedev_info *devinfo)\n{\n\tif (devinfo->shared.scratch)\n\t\tdma_free_coherent(&devinfo->pdev->dev,\n\t\t\t\t  BRCMF_DMA_D2H_SCRATCH_BUF_LEN,\n\t\t\t\t  devinfo->shared.scratch,\n\t\t\t\t  devinfo->shared.scratch_dmahandle);\n\tif (devinfo->shared.ringupd)\n\t\tdma_free_coherent(&devinfo->pdev->dev,\n\t\t\t\t  BRCMF_DMA_D2H_RINGUPD_BUF_LEN,\n\t\t\t\t  devinfo->shared.ringupd,\n\t\t\t\t  devinfo->shared.ringupd_dmahandle);\n}\n\nstatic int brcmf_pcie_init_scratchbuffers(struct brcmf_pciedev_info *devinfo)\n{\n\tstruct brcmf_bus *bus = dev_get_drvdata(&devinfo->pdev->dev);\n\tu64 address;\n\tu32 addr;\n\n\tdevinfo->shared.scratch =\n\t\tdma_alloc_coherent(&devinfo->pdev->dev,\n\t\t\t\t   BRCMF_DMA_D2H_SCRATCH_BUF_LEN,\n\t\t\t\t   &devinfo->shared.scratch_dmahandle,\n\t\t\t\t   GFP_KERNEL);\n\tif (!devinfo->shared.scratch)\n\t\tgoto fail;\n\n\taddr = devinfo->shared.tcm_base_address +\n\t       BRCMF_SHARED_DMA_SCRATCH_ADDR_OFFSET;\n\taddress = (u64)devinfo->shared.scratch_dmahandle;\n\tbrcmf_pcie_write_tcm32(devinfo, addr, address & 0xffffffff);\n\tbrcmf_pcie_write_tcm32(devinfo, addr + 4, address >> 32);\n\taddr = devinfo->shared.tcm_base_address +\n\t       BRCMF_SHARED_DMA_SCRATCH_LEN_OFFSET;\n\tbrcmf_pcie_write_tcm32(devinfo, addr, BRCMF_DMA_D2H_SCRATCH_BUF_LEN);\n\n\tdevinfo->shared.ringupd =\n\t\tdma_alloc_coherent(&devinfo->pdev->dev,\n\t\t\t\t   BRCMF_DMA_D2H_RINGUPD_BUF_LEN,\n\t\t\t\t   &devinfo->shared.ringupd_dmahandle,\n\t\t\t\t   GFP_KERNEL);\n\tif (!devinfo->shared.ringupd)\n\t\tgoto fail;\n\n\taddr = devinfo->shared.tcm_base_address +\n\t       BRCMF_SHARED_DMA_RINGUPD_ADDR_OFFSET;\n\taddress = (u64)devinfo->shared.ringupd_dmahandle;\n\tbrcmf_pcie_write_tcm32(devinfo, addr, address & 0xffffffff);\n\tbrcmf_pcie_write_tcm32(devinfo, addr + 4, address >> 32);\n\taddr = devinfo->shared.tcm_base_address +\n\t       BRCMF_SHARED_DMA_RINGUPD_LEN_OFFSET;\n\tbrcmf_pcie_write_tcm32(devinfo, addr, BRCMF_DMA_D2H_RINGUPD_BUF_LEN);\n\treturn 0;\n\nfail:\n\tbrcmf_err(bus, \"Allocating scratch buffers failed\\n\");\n\tbrcmf_pcie_release_scratchbuffers(devinfo);\n\treturn -ENOMEM;\n}\n\n\nstatic void brcmf_pcie_down(struct device *dev)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_pciedev *pcie_bus_dev = bus_if->bus_priv.pcie;\n\tstruct brcmf_pciedev_info *devinfo = pcie_bus_dev->devinfo;\n\n\tbrcmf_pcie_fwcon_timer(devinfo, false);\n}\n\nstatic int brcmf_pcie_preinit(struct device *dev)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_pciedev *buspub = bus_if->bus_priv.pcie;\n\n\tbrcmf_dbg(PCIE, \"Enter\\n\");\n\n\tbrcmf_pcie_intr_enable(buspub->devinfo);\n\tbrcmf_pcie_hostready(buspub->devinfo);\n\n\treturn 0;\n}\n\nstatic int brcmf_pcie_tx(struct device *dev, struct sk_buff *skb)\n{\n\treturn 0;\n}\n\n\nstatic int brcmf_pcie_tx_ctlpkt(struct device *dev, unsigned char *msg,\n\t\t\t\tuint len)\n{\n\treturn 0;\n}\n\n\nstatic int brcmf_pcie_rx_ctlpkt(struct device *dev, unsigned char *msg,\n\t\t\t\tuint len)\n{\n\treturn 0;\n}\n\n\nstatic void brcmf_pcie_wowl_config(struct device *dev, bool enabled)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_pciedev *buspub = bus_if->bus_priv.pcie;\n\tstruct brcmf_pciedev_info *devinfo = buspub->devinfo;\n\n\tbrcmf_dbg(PCIE, \"Configuring WOWL, enabled=%d\\n\", enabled);\n\tdevinfo->wowl_enabled = enabled;\n}\n\n\nstatic size_t brcmf_pcie_get_ramsize(struct device *dev)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_pciedev *buspub = bus_if->bus_priv.pcie;\n\tstruct brcmf_pciedev_info *devinfo = buspub->devinfo;\n\n\treturn devinfo->ci->ramsize - devinfo->ci->srsize;\n}\n\n\nstatic int brcmf_pcie_get_memdump(struct device *dev, void *data, size_t len)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_pciedev *buspub = bus_if->bus_priv.pcie;\n\tstruct brcmf_pciedev_info *devinfo = buspub->devinfo;\n\n\tbrcmf_dbg(PCIE, \"dump at 0x%08X: len=%zu\\n\", devinfo->ci->rambase, len);\n\tbrcmf_pcie_copy_dev_tomem(devinfo, devinfo->ci->rambase, data, len);\n\treturn 0;\n}\n\nstatic int brcmf_pcie_get_blob(struct device *dev, const struct firmware **fw,\n\t\t\t       enum brcmf_blob_type type)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_pciedev *buspub = bus_if->bus_priv.pcie;\n\tstruct brcmf_pciedev_info *devinfo = buspub->devinfo;\n\n\tswitch (type) {\n\tcase BRCMF_BLOB_CLM:\n\t\t*fw = devinfo->clm_fw;\n\t\tdevinfo->clm_fw = NULL;\n\t\tbreak;\n\tcase BRCMF_BLOB_TXCAP:\n\t\t*fw = devinfo->txcap_fw;\n\t\tdevinfo->txcap_fw = NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOENT;\n\t}\n\n\tif (!*fw)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\nstatic int brcmf_pcie_reset(struct device *dev)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_pciedev *buspub = bus_if->bus_priv.pcie;\n\tstruct brcmf_pciedev_info *devinfo = buspub->devinfo;\n\tstruct brcmf_fw_request *fwreq;\n\tint err;\n\n\tbrcmf_pcie_intr_disable(devinfo);\n\n\tbrcmf_pcie_bus_console_read(devinfo, true);\n\n\tbrcmf_detach(dev);\n\n\tbrcmf_pcie_release_irq(devinfo);\n\tbrcmf_pcie_release_scratchbuffers(devinfo);\n\tbrcmf_pcie_release_ringbuffers(devinfo);\n\tbrcmf_pcie_reset_device(devinfo);\n\n\tfwreq = brcmf_pcie_prepare_fw_request(devinfo);\n\tif (!fwreq) {\n\t\tdev_err(dev, \"Failed to prepare FW request\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\terr = brcmf_fw_get_firmwares(dev, fwreq, brcmf_pcie_setup);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to prepare FW request\\n\");\n\t\tkfree(fwreq);\n\t}\n\n\treturn err;\n}\n\nstatic const struct brcmf_bus_ops brcmf_pcie_bus_ops = {\n\t.preinit = brcmf_pcie_preinit,\n\t.txdata = brcmf_pcie_tx,\n\t.stop = brcmf_pcie_down,\n\t.txctl = brcmf_pcie_tx_ctlpkt,\n\t.rxctl = brcmf_pcie_rx_ctlpkt,\n\t.wowl_config = brcmf_pcie_wowl_config,\n\t.get_ramsize = brcmf_pcie_get_ramsize,\n\t.get_memdump = brcmf_pcie_get_memdump,\n\t.get_blob = brcmf_pcie_get_blob,\n\t.reset = brcmf_pcie_reset,\n\t.debugfs_create = brcmf_pcie_debugfs_create,\n};\n\n\nstatic void\nbrcmf_pcie_adjust_ramsize(struct brcmf_pciedev_info *devinfo, u8 *data,\n\t\t\t  u32 data_len)\n{\n\t__le32 *field;\n\tu32 newsize;\n\n\tif (data_len < BRCMF_RAMSIZE_OFFSET + 8)\n\t\treturn;\n\n\tfield = (__le32 *)&data[BRCMF_RAMSIZE_OFFSET];\n\tif (le32_to_cpup(field) != BRCMF_RAMSIZE_MAGIC)\n\t\treturn;\n\tfield++;\n\tnewsize = le32_to_cpup(field);\n\n\tbrcmf_dbg(PCIE, \"Found ramsize info in FW, adjusting to 0x%x\\n\",\n\t\t  newsize);\n\tdevinfo->ci->ramsize = newsize;\n}\n\n\nstatic int\nbrcmf_pcie_init_share_ram_info(struct brcmf_pciedev_info *devinfo,\n\t\t\t       u32 sharedram_addr)\n{\n\tstruct brcmf_bus *bus = dev_get_drvdata(&devinfo->pdev->dev);\n\tstruct brcmf_pcie_shared_info *shared;\n\tu32 addr;\n\n\tshared = &devinfo->shared;\n\tshared->tcm_base_address = sharedram_addr;\n\n\tshared->flags = brcmf_pcie_read_tcm32(devinfo, sharedram_addr);\n\tshared->version = (u8)(shared->flags & BRCMF_PCIE_SHARED_VERSION_MASK);\n\tbrcmf_dbg(PCIE, \"PCIe protocol version %d\\n\", shared->version);\n\tif ((shared->version > BRCMF_PCIE_MAX_SHARED_VERSION) ||\n\t    (shared->version < BRCMF_PCIE_MIN_SHARED_VERSION)) {\n\t\tbrcmf_err(bus, \"Unsupported PCIE version %d\\n\",\n\t\t\t  shared->version);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (shared->flags & BRCMF_PCIE_SHARED_DMA_INDEX) {\n\t\tif (shared->flags & BRCMF_PCIE_SHARED_DMA_2B_IDX)\n\t\t\tdevinfo->dma_idx_sz = sizeof(u16);\n\t\telse\n\t\t\tdevinfo->dma_idx_sz = sizeof(u32);\n\t}\n\n\taddr = sharedram_addr + BRCMF_SHARED_MAX_RXBUFPOST_OFFSET;\n\tshared->max_rxbufpost = brcmf_pcie_read_tcm16(devinfo, addr);\n\tif (shared->max_rxbufpost == 0)\n\t\tshared->max_rxbufpost = BRCMF_DEF_MAX_RXBUFPOST;\n\n\taddr = sharedram_addr + BRCMF_SHARED_RX_DATAOFFSET_OFFSET;\n\tshared->rx_dataoffset = brcmf_pcie_read_tcm32(devinfo, addr);\n\n\taddr = sharedram_addr + BRCMF_SHARED_HTOD_MB_DATA_ADDR_OFFSET;\n\tshared->htod_mb_data_addr = brcmf_pcie_read_tcm32(devinfo, addr);\n\n\taddr = sharedram_addr + BRCMF_SHARED_DTOH_MB_DATA_ADDR_OFFSET;\n\tshared->dtoh_mb_data_addr = brcmf_pcie_read_tcm32(devinfo, addr);\n\n\taddr = sharedram_addr + BRCMF_SHARED_RING_INFO_ADDR_OFFSET;\n\tshared->ring_info_addr = brcmf_pcie_read_tcm32(devinfo, addr);\n\n\tbrcmf_dbg(PCIE, \"max rx buf post %d, rx dataoffset %d\\n\",\n\t\t  shared->max_rxbufpost, shared->rx_dataoffset);\n\n\tbrcmf_pcie_bus_console_init(devinfo);\n\tbrcmf_pcie_bus_console_read(devinfo, false);\n\n\treturn 0;\n}\n\nstruct brcmf_random_seed_footer {\n\t__le32 length;\n\t__le32 magic;\n};\n\n#define BRCMF_RANDOM_SEED_MAGIC\t\t0xfeedc0de\n#define BRCMF_RANDOM_SEED_LENGTH\t0x100\n\nstatic int brcmf_pcie_download_fw_nvram(struct brcmf_pciedev_info *devinfo,\n\t\t\t\t\tconst struct firmware *fw, void *nvram,\n\t\t\t\t\tu32 nvram_len)\n{\n\tstruct brcmf_bus *bus = dev_get_drvdata(&devinfo->pdev->dev);\n\tu32 sharedram_addr;\n\tu32 sharedram_addr_written;\n\tu32 loop_counter;\n\tint err;\n\tu32 address;\n\tu32 resetintr;\n\n\tbrcmf_dbg(PCIE, \"Halt ARM.\\n\");\n\terr = brcmf_pcie_enter_download_state(devinfo);\n\tif (err)\n\t\treturn err;\n\n\tbrcmf_dbg(PCIE, \"Download FW %s\\n\", devinfo->fw_name);\n\tmemcpy_toio(devinfo->tcm + devinfo->ci->rambase,\n\t\t    (void *)fw->data, fw->size);\n\n\tresetintr = get_unaligned_le32(fw->data);\n\trelease_firmware(fw);\n\n\t \n\tbrcmf_pcie_write_ram32(devinfo, devinfo->ci->ramsize - 4, 0);\n\n\tif (nvram) {\n\t\tbrcmf_dbg(PCIE, \"Download NVRAM %s\\n\", devinfo->nvram_name);\n\t\taddress = devinfo->ci->rambase + devinfo->ci->ramsize -\n\t\t\t  nvram_len;\n\t\tmemcpy_toio(devinfo->tcm + address, nvram, nvram_len);\n\t\tbrcmf_fw_nvram_free(nvram);\n\n\t\tif (devinfo->otp.valid) {\n\t\t\tsize_t rand_len = BRCMF_RANDOM_SEED_LENGTH;\n\t\t\tstruct brcmf_random_seed_footer footer = {\n\t\t\t\t.length = cpu_to_le32(rand_len),\n\t\t\t\t.magic = cpu_to_le32(BRCMF_RANDOM_SEED_MAGIC),\n\t\t\t};\n\t\t\tvoid *randbuf;\n\n\t\t\t \n\t\t\tbrcmf_dbg(PCIE, \"Download random seed\\n\");\n\n\t\t\taddress -= sizeof(footer);\n\t\t\tmemcpy_toio(devinfo->tcm + address, &footer,\n\t\t\t\t    sizeof(footer));\n\n\t\t\taddress -= rand_len;\n\t\t\trandbuf = kzalloc(rand_len, GFP_KERNEL);\n\t\t\tget_random_bytes(randbuf, rand_len);\n\t\t\tmemcpy_toio(devinfo->tcm + address, randbuf, rand_len);\n\t\t\tkfree(randbuf);\n\t\t}\n\t} else {\n\t\tbrcmf_dbg(PCIE, \"No matching NVRAM file found %s\\n\",\n\t\t\t  devinfo->nvram_name);\n\t}\n\n\tsharedram_addr_written = brcmf_pcie_read_ram32(devinfo,\n\t\t\t\t\t\t       devinfo->ci->ramsize -\n\t\t\t\t\t\t       4);\n\tbrcmf_dbg(PCIE, \"Bring ARM in running state\\n\");\n\terr = brcmf_pcie_exit_download_state(devinfo, resetintr);\n\tif (err)\n\t\treturn err;\n\n\tbrcmf_dbg(PCIE, \"Wait for FW init\\n\");\n\tsharedram_addr = sharedram_addr_written;\n\tloop_counter = BRCMF_PCIE_FW_UP_TIMEOUT / 50;\n\twhile ((sharedram_addr == sharedram_addr_written) && (loop_counter)) {\n\t\tmsleep(50);\n\t\tsharedram_addr = brcmf_pcie_read_ram32(devinfo,\n\t\t\t\t\t\t       devinfo->ci->ramsize -\n\t\t\t\t\t\t       4);\n\t\tloop_counter--;\n\t}\n\tif (sharedram_addr == sharedram_addr_written) {\n\t\tbrcmf_err(bus, \"FW failed to initialize\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (sharedram_addr < devinfo->ci->rambase ||\n\t    sharedram_addr >= devinfo->ci->rambase + devinfo->ci->ramsize) {\n\t\tbrcmf_err(bus, \"Invalid shared RAM address 0x%08x\\n\",\n\t\t\t  sharedram_addr);\n\t\treturn -ENODEV;\n\t}\n\tbrcmf_dbg(PCIE, \"Shared RAM addr: 0x%08x\\n\", sharedram_addr);\n\n\treturn (brcmf_pcie_init_share_ram_info(devinfo, sharedram_addr));\n}\n\n\nstatic int brcmf_pcie_get_resource(struct brcmf_pciedev_info *devinfo)\n{\n\tstruct pci_dev *pdev = devinfo->pdev;\n\tstruct brcmf_bus *bus = dev_get_drvdata(&pdev->dev);\n\tint err;\n\tphys_addr_t  bar0_addr, bar1_addr;\n\tulong bar1_size;\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tbrcmf_err(bus, \"pci_enable_device failed err=%d\\n\", err);\n\t\treturn err;\n\t}\n\n\tpci_set_master(pdev);\n\n\t \n\tbar0_addr = pci_resource_start(pdev, 0);\n\t \n\tbar1_addr = pci_resource_start(pdev, 2);\n\t \n\tbar1_size = pci_resource_len(pdev, 2);\n\tif ((bar1_size == 0) || (bar1_addr == 0)) {\n\t\tbrcmf_err(bus, \"BAR1 Not enabled, device size=%ld, addr=%#016llx\\n\",\n\t\t\t  bar1_size, (unsigned long long)bar1_addr);\n\t\treturn -EINVAL;\n\t}\n\n\tdevinfo->regs = ioremap(bar0_addr, BRCMF_PCIE_REG_MAP_SIZE);\n\tdevinfo->tcm = ioremap(bar1_addr, bar1_size);\n\n\tif (!devinfo->regs || !devinfo->tcm) {\n\t\tbrcmf_err(bus, \"ioremap() failed (%p,%p)\\n\", devinfo->regs,\n\t\t\t  devinfo->tcm);\n\t\treturn -EINVAL;\n\t}\n\tbrcmf_dbg(PCIE, \"Phys addr : reg space = %p base addr %#016llx\\n\",\n\t\t  devinfo->regs, (unsigned long long)bar0_addr);\n\tbrcmf_dbg(PCIE, \"Phys addr : mem space = %p base addr %#016llx size 0x%x\\n\",\n\t\t  devinfo->tcm, (unsigned long long)bar1_addr,\n\t\t  (unsigned int)bar1_size);\n\n\treturn 0;\n}\n\n\nstatic void brcmf_pcie_release_resource(struct brcmf_pciedev_info *devinfo)\n{\n\tif (devinfo->tcm)\n\t\tiounmap(devinfo->tcm);\n\tif (devinfo->regs)\n\t\tiounmap(devinfo->regs);\n\n\tpci_disable_device(devinfo->pdev);\n}\n\n\nstatic u32 brcmf_pcie_buscore_prep_addr(const struct pci_dev *pdev, u32 addr)\n{\n\tu32 ret_addr;\n\n\tret_addr = addr & (BRCMF_PCIE_BAR0_REG_SIZE - 1);\n\taddr &= ~(BRCMF_PCIE_BAR0_REG_SIZE - 1);\n\tpci_write_config_dword(pdev, BRCMF_PCIE_BAR0_WINDOW, addr);\n\n\treturn ret_addr;\n}\n\n\nstatic u32 brcmf_pcie_buscore_read32(void *ctx, u32 addr)\n{\n\tstruct brcmf_pciedev_info *devinfo = (struct brcmf_pciedev_info *)ctx;\n\n\taddr = brcmf_pcie_buscore_prep_addr(devinfo->pdev, addr);\n\treturn brcmf_pcie_read_reg32(devinfo, addr);\n}\n\n\nstatic void brcmf_pcie_buscore_write32(void *ctx, u32 addr, u32 value)\n{\n\tstruct brcmf_pciedev_info *devinfo = (struct brcmf_pciedev_info *)ctx;\n\n\taddr = brcmf_pcie_buscore_prep_addr(devinfo->pdev, addr);\n\tbrcmf_pcie_write_reg32(devinfo, addr, value);\n}\n\n\nstatic int brcmf_pcie_buscoreprep(void *ctx)\n{\n\treturn brcmf_pcie_get_resource(ctx);\n}\n\n\nstatic int brcmf_pcie_buscore_reset(void *ctx, struct brcmf_chip *chip)\n{\n\tstruct brcmf_pciedev_info *devinfo = (struct brcmf_pciedev_info *)ctx;\n\tstruct brcmf_core *core;\n\tu32 val, reg;\n\n\tdevinfo->ci = chip;\n\tbrcmf_pcie_reset_device(devinfo);\n\n\t \n\tcore = brcmf_chip_get_core(chip, BCMA_CORE_PCIE2);\n\tif (core->rev >= 64)\n\t\treg = BRCMF_PCIE_64_PCIE2REG_MAILBOXINT;\n\telse\n\t\treg = BRCMF_PCIE_PCIE2REG_MAILBOXINT;\n\n\tval = brcmf_pcie_read_reg32(devinfo, reg);\n\tif (val != 0xffffffff)\n\t\tbrcmf_pcie_write_reg32(devinfo, reg, val);\n\n\treturn 0;\n}\n\n\nstatic void brcmf_pcie_buscore_activate(void *ctx, struct brcmf_chip *chip,\n\t\t\t\t\tu32 rstvec)\n{\n\tstruct brcmf_pciedev_info *devinfo = (struct brcmf_pciedev_info *)ctx;\n\n\tbrcmf_pcie_write_tcm32(devinfo, 0, rstvec);\n}\n\n\nstatic const struct brcmf_buscore_ops brcmf_pcie_buscore_ops = {\n\t.prepare = brcmf_pcie_buscoreprep,\n\t.reset = brcmf_pcie_buscore_reset,\n\t.activate = brcmf_pcie_buscore_activate,\n\t.read32 = brcmf_pcie_buscore_read32,\n\t.write32 = brcmf_pcie_buscore_write32,\n};\n\n#define BRCMF_OTP_SYS_VENDOR\t0x15\n#define BRCMF_OTP_BRCM_CIS\t0x80\n\n#define BRCMF_OTP_VENDOR_HDR\t0x00000008\n\nstatic int\nbrcmf_pcie_parse_otp_sys_vendor(struct brcmf_pciedev_info *devinfo,\n\t\t\t\tu8 *data, size_t size)\n{\n\tint idx = 4;\n\tconst char *chip_params;\n\tconst char *board_params;\n\tconst char *p;\n\n\t \n\tif (size < 6)\n\t\treturn -EINVAL;\n\n\tif (get_unaligned_le32(data) != BRCMF_OTP_VENDOR_HDR)\n\t\treturn -EINVAL;\n\n\tchip_params = &data[idx];\n\n\t \n\tidx += strnlen(chip_params, size - idx) + 1;\n\tif (idx >= size)\n\t\treturn -EINVAL;\n\n\tboard_params = &data[idx];\n\n\t \n\tidx += strnlen(board_params, size - idx);\n\tif (idx >= size)\n\t\treturn -EINVAL;\n\n\t \n\tbrcmf_dbg(PCIE, \"OTP: chip_params='%s' board_params='%s'\\n\",\n\t\t  chip_params, board_params);\n\n\tp = skip_spaces(board_params);\n\twhile (*p) {\n\t\tchar tag = *p++;\n\t\tconst char *end;\n\t\tsize_t len;\n\n\t\tif (*p++ != '=')  \n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tend = strchrnul(p, ' ');\n\t\tlen = end - p;\n\n\t\t \n\t\tif (len > (BRCMF_OTP_MAX_PARAM_LEN - 1))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tswitch (tag) {\n\t\tcase 'M':\n\t\t\tstrscpy(devinfo->otp.module, p, len + 1);\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tstrscpy(devinfo->otp.vendor, p, len + 1);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tstrscpy(devinfo->otp.version, p, len + 1);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tp = skip_spaces(end);\n\t}\n\n\tbrcmf_dbg(PCIE, \"OTP: module=%s vendor=%s version=%s\\n\",\n\t\t  devinfo->otp.module, devinfo->otp.vendor,\n\t\t  devinfo->otp.version);\n\n\tif (!devinfo->otp.module[0] ||\n\t    !devinfo->otp.vendor[0] ||\n\t    !devinfo->otp.version[0])\n\t\treturn -EINVAL;\n\n\tdevinfo->otp.valid = true;\n\treturn 0;\n}\n\nstatic int\nbrcmf_pcie_parse_otp(struct brcmf_pciedev_info *devinfo, u8 *otp, size_t size)\n{\n\tint p = 0;\n\tint ret = -EINVAL;\n\n\tbrcmf_dbg(PCIE, \"parse_otp size=%zd\\n\", size);\n\n\twhile (p < (size - 1)) {\n\t\tu8 type = otp[p];\n\t\tu8 length = otp[p + 1];\n\n\t\tif (type == 0)\n\t\t\tbreak;\n\n\t\tif ((p + 2 + length) > size)\n\t\t\tbreak;\n\n\t\tswitch (type) {\n\t\tcase BRCMF_OTP_SYS_VENDOR:\n\t\t\tbrcmf_dbg(PCIE, \"OTP @ 0x%x (%d): SYS_VENDOR\\n\",\n\t\t\t\t  p, length);\n\t\t\tret = brcmf_pcie_parse_otp_sys_vendor(devinfo,\n\t\t\t\t\t\t\t      &otp[p + 2],\n\t\t\t\t\t\t\t      length);\n\t\t\tbreak;\n\t\tcase BRCMF_OTP_BRCM_CIS:\n\t\t\tbrcmf_dbg(PCIE, \"OTP @ 0x%x (%d): BRCM_CIS\\n\",\n\t\t\t\t  p, length);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbrcmf_dbg(PCIE, \"OTP @ 0x%x (%d): Unknown type 0x%x\\n\",\n\t\t\t\t  p, length, type);\n\t\t\tbreak;\n\t\t}\n\n\t\tp += 2 + length;\n\t}\n\n\treturn ret;\n}\n\nstatic int brcmf_pcie_read_otp(struct brcmf_pciedev_info *devinfo)\n{\n\tconst struct pci_dev *pdev = devinfo->pdev;\n\tstruct brcmf_bus *bus = dev_get_drvdata(&pdev->dev);\n\tu32 coreid, base, words, idx, sromctl;\n\tu16 *otp;\n\tstruct brcmf_core *core;\n\tint ret;\n\n\tswitch (devinfo->ci->chip) {\n\tcase BRCM_CC_4355_CHIP_ID:\n\t\tcoreid = BCMA_CORE_CHIPCOMMON;\n\t\tbase = 0x8c0;\n\t\twords = 0xb2;\n\t\tbreak;\n\tcase BRCM_CC_4364_CHIP_ID:\n\t\tcoreid = BCMA_CORE_CHIPCOMMON;\n\t\tbase = 0x8c0;\n\t\twords = 0x1a0;\n\t\tbreak;\n\tcase BRCM_CC_4377_CHIP_ID:\n\tcase BRCM_CC_4378_CHIP_ID:\n\t\tcoreid = BCMA_CORE_GCI;\n\t\tbase = 0x1120;\n\t\twords = 0x170;\n\t\tbreak;\n\tcase BRCM_CC_4387_CHIP_ID:\n\t\tcoreid = BCMA_CORE_GCI;\n\t\tbase = 0x113c;\n\t\twords = 0x170;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn 0;\n\t}\n\n\tcore = brcmf_chip_get_core(devinfo->ci, coreid);\n\tif (!core) {\n\t\tbrcmf_err(bus, \"No OTP core\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (coreid == BCMA_CORE_CHIPCOMMON) {\n\t\t \n\t\tbrcmf_pcie_select_core(devinfo, coreid);\n\t\tsromctl = READCC32(devinfo, sromcontrol);\n\n\t\tif (!(sromctl & BCMA_CC_SROM_CONTROL_OTP_PRESENT)) {\n\t\t\t \n\t\t\tbrcmf_err(bus,\n\t\t\t\t  \"OTP unavailable, using default firmware\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tWRITECC32(devinfo, sromcontrol,\n\t\t\t  sromctl | BCMA_CC_SROM_CONTROL_OTPSEL);\n\t}\n\n\totp = kcalloc(words, sizeof(u16), GFP_KERNEL);\n\tif (!otp)\n\t\treturn -ENOMEM;\n\n\t \n\tbase = brcmf_pcie_buscore_prep_addr(devinfo->pdev, base + core->base);\n\n\tbrcmf_dbg(PCIE, \"OTP data:\\n\");\n\tfor (idx = 0; idx < words; idx++) {\n\t\totp[idx] = brcmf_pcie_read_reg16(devinfo, base + 2 * idx);\n\t\tbrcmf_dbg(PCIE, \"[%8x] 0x%04x\\n\", base + 2 * idx, otp[idx]);\n\t}\n\n\tif (coreid == BCMA_CORE_CHIPCOMMON) {\n\t\tbrcmf_pcie_select_core(devinfo, coreid);\n\t\tWRITECC32(devinfo, sromcontrol, sromctl);\n\t}\n\n\tret = brcmf_pcie_parse_otp(devinfo, (u8 *)otp, 2 * words);\n\tkfree(otp);\n\n\treturn ret;\n}\n\n#define BRCMF_PCIE_FW_CODE\t0\n#define BRCMF_PCIE_FW_NVRAM\t1\n#define BRCMF_PCIE_FW_CLM\t2\n#define BRCMF_PCIE_FW_TXCAP\t3\n\nstatic void brcmf_pcie_setup(struct device *dev, int ret,\n\t\t\t     struct brcmf_fw_request *fwreq)\n{\n\tconst struct firmware *fw;\n\tvoid *nvram;\n\tstruct brcmf_bus *bus;\n\tstruct brcmf_pciedev *pcie_bus_dev;\n\tstruct brcmf_pciedev_info *devinfo;\n\tstruct brcmf_commonring **flowrings;\n\tu32 i, nvram_len;\n\n\tbus = dev_get_drvdata(dev);\n\tpcie_bus_dev = bus->bus_priv.pcie;\n\tdevinfo = pcie_bus_dev->devinfo;\n\n\t \n\tif (ret)\n\t\tgoto fail;\n\n\tbrcmf_pcie_attach(devinfo);\n\n\tfw = fwreq->items[BRCMF_PCIE_FW_CODE].binary;\n\tnvram = fwreq->items[BRCMF_PCIE_FW_NVRAM].nv_data.data;\n\tnvram_len = fwreq->items[BRCMF_PCIE_FW_NVRAM].nv_data.len;\n\tdevinfo->clm_fw = fwreq->items[BRCMF_PCIE_FW_CLM].binary;\n\tdevinfo->txcap_fw = fwreq->items[BRCMF_PCIE_FW_TXCAP].binary;\n\tkfree(fwreq);\n\n\tret = brcmf_chip_get_raminfo(devinfo->ci);\n\tif (ret) {\n\t\tbrcmf_err(bus, \"Failed to get RAM info\\n\");\n\t\trelease_firmware(fw);\n\t\tbrcmf_fw_nvram_free(nvram);\n\t\tgoto fail;\n\t}\n\n\t \n\tbrcmf_pcie_adjust_ramsize(devinfo, (u8 *)fw->data, fw->size);\n\n\tret = brcmf_pcie_download_fw_nvram(devinfo, fw, nvram, nvram_len);\n\tif (ret)\n\t\tgoto fail;\n\n\tdevinfo->state = BRCMFMAC_PCIE_STATE_UP;\n\n\tret = brcmf_pcie_init_ringbuffers(devinfo);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = brcmf_pcie_init_scratchbuffers(devinfo);\n\tif (ret)\n\t\tgoto fail;\n\n\tbrcmf_pcie_select_core(devinfo, BCMA_CORE_PCIE2);\n\tret = brcmf_pcie_request_irq(devinfo);\n\tif (ret)\n\t\tgoto fail;\n\n\t \n\tfor (i = 0; i < BRCMF_NROF_COMMON_MSGRINGS; i++)\n\t\tbus->msgbuf->commonrings[i] =\n\t\t\t\t&devinfo->shared.commonrings[i]->commonring;\n\n\tflowrings = kcalloc(devinfo->shared.max_flowrings, sizeof(*flowrings),\n\t\t\t    GFP_KERNEL);\n\tif (!flowrings)\n\t\tgoto fail;\n\n\tfor (i = 0; i < devinfo->shared.max_flowrings; i++)\n\t\tflowrings[i] = &devinfo->shared.flowrings[i].commonring;\n\tbus->msgbuf->flowrings = flowrings;\n\n\tbus->msgbuf->rx_dataoffset = devinfo->shared.rx_dataoffset;\n\tbus->msgbuf->max_rxbufpost = devinfo->shared.max_rxbufpost;\n\tbus->msgbuf->max_flowrings = devinfo->shared.max_flowrings;\n\n\tinit_waitqueue_head(&devinfo->mbdata_resp_wait);\n\n\tret = brcmf_attach(&devinfo->pdev->dev);\n\tif (ret)\n\t\tgoto fail;\n\n\tbrcmf_pcie_bus_console_read(devinfo, false);\n\n\tbrcmf_pcie_fwcon_timer(devinfo, true);\n\n\treturn;\n\nfail:\n\tbrcmf_err(bus, \"Dongle setup failed\\n\");\n\tbrcmf_pcie_bus_console_read(devinfo, true);\n\tbrcmf_fw_crashed(dev);\n\tdevice_release_driver(dev);\n}\n\nstatic struct brcmf_fw_request *\nbrcmf_pcie_prepare_fw_request(struct brcmf_pciedev_info *devinfo)\n{\n\tstruct brcmf_fw_request *fwreq;\n\tstruct brcmf_fw_name fwnames[] = {\n\t\t{ \".bin\", devinfo->fw_name },\n\t\t{ \".txt\", devinfo->nvram_name },\n\t\t{ \".clm_blob\", devinfo->clm_name },\n\t\t{ \".txcap_blob\", devinfo->txcap_name },\n\t};\n\n\tfwreq = brcmf_fw_alloc_request(devinfo->ci->chip, devinfo->ci->chiprev,\n\t\t\t\t       brcmf_pcie_fwnames,\n\t\t\t\t       ARRAY_SIZE(brcmf_pcie_fwnames),\n\t\t\t\t       fwnames, ARRAY_SIZE(fwnames));\n\tif (!fwreq)\n\t\treturn NULL;\n\n\tfwreq->items[BRCMF_PCIE_FW_CODE].type = BRCMF_FW_TYPE_BINARY;\n\tfwreq->items[BRCMF_PCIE_FW_NVRAM].type = BRCMF_FW_TYPE_NVRAM;\n\tfwreq->items[BRCMF_PCIE_FW_NVRAM].flags = BRCMF_FW_REQF_OPTIONAL;\n\tfwreq->items[BRCMF_PCIE_FW_CLM].type = BRCMF_FW_TYPE_BINARY;\n\tfwreq->items[BRCMF_PCIE_FW_CLM].flags = BRCMF_FW_REQF_OPTIONAL;\n\tfwreq->items[BRCMF_PCIE_FW_TXCAP].type = BRCMF_FW_TYPE_BINARY;\n\tfwreq->items[BRCMF_PCIE_FW_TXCAP].flags = BRCMF_FW_REQF_OPTIONAL;\n\t \n\tfwreq->domain_nr = pci_domain_nr(devinfo->pdev->bus) + 1;\n\tfwreq->bus_nr = devinfo->pdev->bus->number;\n\n\t \n\tif (devinfo->settings->board_type &&\n\t    devinfo->settings->antenna_sku &&\n\t    devinfo->otp.valid) {\n\t\tconst struct brcmf_otp_params *otp = &devinfo->otp;\n\t\tstruct device *dev = &devinfo->pdev->dev;\n\t\tconst char **bt = fwreq->board_types;\n\n\t\tbrcmf_dbg(PCIE, \"Apple board: %s\\n\",\n\t\t\t  devinfo->settings->board_type);\n\n\t\t \n\t\tbt[0] = devm_kasprintf(dev, GFP_KERNEL, \"%s-%s-%s-%s-%s\",\n\t\t\t\t       devinfo->settings->board_type,\n\t\t\t\t       otp->module, otp->vendor, otp->version,\n\t\t\t\t       devinfo->settings->antenna_sku);\n\t\tbt[1] = devm_kasprintf(dev, GFP_KERNEL, \"%s-%s-%s-%s\",\n\t\t\t\t       devinfo->settings->board_type,\n\t\t\t\t       otp->module, otp->vendor, otp->version);\n\t\tbt[2] = devm_kasprintf(dev, GFP_KERNEL, \"%s-%s-%s\",\n\t\t\t\t       devinfo->settings->board_type,\n\t\t\t\t       otp->module, otp->vendor);\n\t\tbt[3] = devm_kasprintf(dev, GFP_KERNEL, \"%s-%s\",\n\t\t\t\t       devinfo->settings->board_type,\n\t\t\t\t       otp->module);\n\t\tbt[4] = devm_kasprintf(dev, GFP_KERNEL, \"%s-%s\",\n\t\t\t\t       devinfo->settings->board_type,\n\t\t\t\t       devinfo->settings->antenna_sku);\n\t\tbt[5] = devinfo->settings->board_type;\n\n\t\tif (!bt[0] || !bt[1] || !bt[2] || !bt[3] || !bt[4]) {\n\t\t\tkfree(fwreq);\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tbrcmf_dbg(PCIE, \"Board: %s\\n\", devinfo->settings->board_type);\n\t\tfwreq->board_types[0] = devinfo->settings->board_type;\n\t}\n\n\treturn fwreq;\n}\n\n#ifdef DEBUG\nstatic void\nbrcmf_pcie_fwcon_timer(struct brcmf_pciedev_info *devinfo, bool active)\n{\n\tif (!active) {\n\t\tif (devinfo->console_active) {\n\t\t\tdel_timer_sync(&devinfo->timer);\n\t\t\tdevinfo->console_active = false;\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tif (devinfo->state != BRCMFMAC_PCIE_STATE_UP ||\n\t    !devinfo->console_interval || !BRCMF_FWCON_ON())\n\t\treturn;\n\n\tif (!devinfo->console_active) {\n\t\tdevinfo->timer.expires = jiffies + devinfo->console_interval;\n\t\tadd_timer(&devinfo->timer);\n\t\tdevinfo->console_active = true;\n\t} else {\n\t\t \n\t\tmod_timer(&devinfo->timer, jiffies + devinfo->console_interval);\n\t}\n}\n\nstatic void\nbrcmf_pcie_fwcon(struct timer_list *t)\n{\n\tstruct brcmf_pciedev_info *devinfo = from_timer(devinfo, t, timer);\n\n\tif (!devinfo->console_active)\n\t\treturn;\n\n\tbrcmf_pcie_bus_console_read(devinfo, false);\n\n\t \n\tmod_timer(&devinfo->timer, jiffies + devinfo->console_interval);\n}\n\nstatic int brcmf_pcie_console_interval_get(void *data, u64 *val)\n{\n\tstruct brcmf_pciedev_info *devinfo = data;\n\n\t*val = devinfo->console_interval;\n\n\treturn 0;\n}\n\nstatic int brcmf_pcie_console_interval_set(void *data, u64 val)\n{\n\tstruct brcmf_pciedev_info *devinfo = data;\n\n\tif (val > MAX_CONSOLE_INTERVAL)\n\t\treturn -EINVAL;\n\n\tdevinfo->console_interval = val;\n\n\tif (!val && devinfo->console_active)\n\t\tbrcmf_pcie_fwcon_timer(devinfo, false);\n\telse if (val)\n\t\tbrcmf_pcie_fwcon_timer(devinfo, true);\n\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(brcmf_pcie_console_interval_fops,\n\t\t\tbrcmf_pcie_console_interval_get,\n\t\t\tbrcmf_pcie_console_interval_set,\n\t\t\t\"%llu\\n\");\n\nstatic void brcmf_pcie_debugfs_create(struct device *dev)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_pub *drvr = bus_if->drvr;\n\tstruct brcmf_pciedev *pcie_bus_dev = bus_if->bus_priv.pcie;\n\tstruct brcmf_pciedev_info *devinfo = pcie_bus_dev->devinfo;\n\tstruct dentry *dentry = brcmf_debugfs_get_devdir(drvr);\n\n\tif (IS_ERR_OR_NULL(dentry))\n\t\treturn;\n\n\tdevinfo->console_interval = BRCMF_CONSOLE;\n\n\tdebugfs_create_file(\"console_interval\", 0644, dentry, devinfo,\n\t\t\t    &brcmf_pcie_console_interval_fops);\n}\n\n#else\nvoid brcmf_pcie_fwcon_timer(struct brcmf_pciedev_info *devinfo, bool active)\n{\n}\n\nstatic void brcmf_pcie_debugfs_create(struct device *dev)\n{\n}\n#endif\n\n \nstatic const struct pci_device_id brcmf_pcie_devid_table[];\n\nstatic int\nbrcmf_pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tint ret;\n\tstruct brcmf_fw_request *fwreq;\n\tstruct brcmf_pciedev_info *devinfo;\n\tstruct brcmf_pciedev *pcie_bus_dev;\n\tstruct brcmf_core *core;\n\tstruct brcmf_bus *bus;\n\n\tif (!id) {\n\t\tid = pci_match_id(brcmf_pcie_devid_table, pdev);\n\t\tif (!id) {\n\t\t\tpci_err(pdev, \"Error could not find pci_device_id for %x:%x\\n\", pdev->vendor, pdev->device);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tbrcmf_dbg(PCIE, \"Enter %x:%x\\n\", pdev->vendor, pdev->device);\n\n\tret = -ENOMEM;\n\tdevinfo = kzalloc(sizeof(*devinfo), GFP_KERNEL);\n\tif (devinfo == NULL)\n\t\treturn ret;\n\n\tdevinfo->pdev = pdev;\n\tpcie_bus_dev = NULL;\n\tdevinfo->ci = brcmf_chip_attach(devinfo, pdev->device,\n\t\t\t\t\t&brcmf_pcie_buscore_ops);\n\tif (IS_ERR(devinfo->ci)) {\n\t\tret = PTR_ERR(devinfo->ci);\n\t\tdevinfo->ci = NULL;\n\t\tgoto fail;\n\t}\n\n\tcore = brcmf_chip_get_core(devinfo->ci, BCMA_CORE_PCIE2);\n\tif (core->rev >= 64)\n\t\tdevinfo->reginfo = &brcmf_reginfo_64;\n\telse\n\t\tdevinfo->reginfo = &brcmf_reginfo_default;\n\n\tpcie_bus_dev = kzalloc(sizeof(*pcie_bus_dev), GFP_KERNEL);\n\tif (pcie_bus_dev == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tdevinfo->settings = brcmf_get_module_param(&devinfo->pdev->dev,\n\t\t\t\t\t\t   BRCMF_BUSTYPE_PCIE,\n\t\t\t\t\t\t   devinfo->ci->chip,\n\t\t\t\t\t\t   devinfo->ci->chiprev);\n\tif (!devinfo->settings) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tbus = kzalloc(sizeof(*bus), GFP_KERNEL);\n\tif (!bus) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tbus->msgbuf = kzalloc(sizeof(*bus->msgbuf), GFP_KERNEL);\n\tif (!bus->msgbuf) {\n\t\tret = -ENOMEM;\n\t\tkfree(bus);\n\t\tgoto fail;\n\t}\n\n\t \n\tpcie_bus_dev->devinfo = devinfo;\n\tpcie_bus_dev->bus = bus;\n\tbus->dev = &pdev->dev;\n\tbus->bus_priv.pcie = pcie_bus_dev;\n\tbus->ops = &brcmf_pcie_bus_ops;\n\tbus->proto_type = BRCMF_PROTO_MSGBUF;\n\tbus->fwvid = id->driver_data;\n\tbus->chip = devinfo->coreid;\n\tbus->wowl_supported = pci_pme_capable(pdev, PCI_D3hot);\n\tdev_set_drvdata(&pdev->dev, bus);\n\n\tret = brcmf_alloc(&devinfo->pdev->dev, devinfo->settings);\n\tif (ret)\n\t\tgoto fail_bus;\n\n\tret = brcmf_pcie_read_otp(devinfo);\n\tif (ret) {\n\t\tbrcmf_err(bus, \"failed to parse OTP\\n\");\n\t\tgoto fail_brcmf;\n\t}\n\n#ifdef DEBUG\n\t \n\ttimer_setup(&devinfo->timer, brcmf_pcie_fwcon, 0);\n#endif\n\n\tfwreq = brcmf_pcie_prepare_fw_request(devinfo);\n\tif (!fwreq) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_brcmf;\n\t}\n\n\tret = brcmf_fw_get_firmwares(bus->dev, fwreq, brcmf_pcie_setup);\n\tif (ret < 0) {\n\t\tkfree(fwreq);\n\t\tgoto fail_brcmf;\n\t}\n\treturn 0;\n\nfail_brcmf:\n\tbrcmf_free(&devinfo->pdev->dev);\nfail_bus:\n\tkfree(bus->msgbuf);\n\tkfree(bus);\nfail:\n\tbrcmf_err(NULL, \"failed %x:%x\\n\", pdev->vendor, pdev->device);\n\tbrcmf_pcie_release_resource(devinfo);\n\tif (devinfo->ci)\n\t\tbrcmf_chip_detach(devinfo->ci);\n\tif (devinfo->settings)\n\t\tbrcmf_release_module_param(devinfo->settings);\n\tkfree(pcie_bus_dev);\n\tkfree(devinfo);\n\treturn ret;\n}\n\n\nstatic void\nbrcmf_pcie_remove(struct pci_dev *pdev)\n{\n\tstruct brcmf_pciedev_info *devinfo;\n\tstruct brcmf_bus *bus;\n\n\tbrcmf_dbg(PCIE, \"Enter\\n\");\n\n\tbus = dev_get_drvdata(&pdev->dev);\n\tif (bus == NULL)\n\t\treturn;\n\n\tdevinfo = bus->bus_priv.pcie->devinfo;\n\tbrcmf_pcie_bus_console_read(devinfo, false);\n\tbrcmf_pcie_fwcon_timer(devinfo, false);\n\n\tdevinfo->state = BRCMFMAC_PCIE_STATE_DOWN;\n\tif (devinfo->ci)\n\t\tbrcmf_pcie_intr_disable(devinfo);\n\n\tbrcmf_detach(&pdev->dev);\n\tbrcmf_free(&pdev->dev);\n\n\tkfree(bus->bus_priv.pcie);\n\tkfree(bus->msgbuf->flowrings);\n\tkfree(bus->msgbuf);\n\tkfree(bus);\n\n\tbrcmf_pcie_release_irq(devinfo);\n\tbrcmf_pcie_release_scratchbuffers(devinfo);\n\tbrcmf_pcie_release_ringbuffers(devinfo);\n\tbrcmf_pcie_reset_device(devinfo);\n\tbrcmf_pcie_release_resource(devinfo);\n\trelease_firmware(devinfo->clm_fw);\n\trelease_firmware(devinfo->txcap_fw);\n\n\tif (devinfo->ci)\n\t\tbrcmf_chip_detach(devinfo->ci);\n\tif (devinfo->settings)\n\t\tbrcmf_release_module_param(devinfo->settings);\n\n\tkfree(devinfo);\n\tdev_set_drvdata(&pdev->dev, NULL);\n}\n\n\n#ifdef CONFIG_PM\n\n\nstatic int brcmf_pcie_pm_enter_D3(struct device *dev)\n{\n\tstruct brcmf_pciedev_info *devinfo;\n\tstruct brcmf_bus *bus;\n\n\tbrcmf_dbg(PCIE, \"Enter\\n\");\n\n\tbus = dev_get_drvdata(dev);\n\tdevinfo = bus->bus_priv.pcie->devinfo;\n\n\tbrcmf_pcie_fwcon_timer(devinfo, false);\n\tbrcmf_bus_change_state(bus, BRCMF_BUS_DOWN);\n\n\tdevinfo->mbdata_completed = false;\n\tbrcmf_pcie_send_mb_data(devinfo, BRCMF_H2D_HOST_D3_INFORM);\n\n\twait_event_timeout(devinfo->mbdata_resp_wait, devinfo->mbdata_completed,\n\t\t\t   BRCMF_PCIE_MBDATA_TIMEOUT);\n\tif (!devinfo->mbdata_completed) {\n\t\tbrcmf_err(bus, \"Timeout on response for entering D3 substate\\n\");\n\t\tbrcmf_bus_change_state(bus, BRCMF_BUS_UP);\n\t\treturn -EIO;\n\t}\n\n\tdevinfo->state = BRCMFMAC_PCIE_STATE_DOWN;\n\n\treturn 0;\n}\n\n\nstatic int brcmf_pcie_pm_leave_D3(struct device *dev)\n{\n\tstruct brcmf_pciedev_info *devinfo;\n\tstruct brcmf_bus *bus;\n\tstruct pci_dev *pdev;\n\tint err;\n\n\tbrcmf_dbg(PCIE, \"Enter\\n\");\n\n\tbus = dev_get_drvdata(dev);\n\tdevinfo = bus->bus_priv.pcie->devinfo;\n\tbrcmf_dbg(PCIE, \"Enter, dev=%p, bus=%p\\n\", dev, bus);\n\n\t \n\tif (brcmf_pcie_read_reg32(devinfo, devinfo->reginfo->intmask) != 0) {\n\t\tbrcmf_dbg(PCIE, \"Try to wakeup device....\\n\");\n\t\tif (brcmf_pcie_send_mb_data(devinfo, BRCMF_H2D_HOST_D0_INFORM))\n\t\t\tgoto cleanup;\n\t\tbrcmf_dbg(PCIE, \"Hot resume, continue....\\n\");\n\t\tdevinfo->state = BRCMFMAC_PCIE_STATE_UP;\n\t\tbrcmf_pcie_select_core(devinfo, BCMA_CORE_PCIE2);\n\t\tbrcmf_bus_change_state(bus, BRCMF_BUS_UP);\n\t\tbrcmf_pcie_intr_enable(devinfo);\n\t\tbrcmf_pcie_hostready(devinfo);\n\t\tbrcmf_pcie_fwcon_timer(devinfo, true);\n\t\treturn 0;\n\t}\n\ncleanup:\n\tbrcmf_chip_detach(devinfo->ci);\n\tdevinfo->ci = NULL;\n\tpdev = devinfo->pdev;\n\tbrcmf_pcie_remove(pdev);\n\n\terr = brcmf_pcie_probe(pdev, NULL);\n\tif (err)\n\t\t__brcmf_err(NULL, __func__, \"probe after resume failed, err=%d\\n\", err);\n\n\treturn err;\n}\n\n\nstatic const struct dev_pm_ops brcmf_pciedrvr_pm = {\n\t.suspend = brcmf_pcie_pm_enter_D3,\n\t.resume = brcmf_pcie_pm_leave_D3,\n\t.freeze = brcmf_pcie_pm_enter_D3,\n\t.restore = brcmf_pcie_pm_leave_D3,\n};\n\n\n#endif  \n\n\n#define BRCMF_PCIE_DEVICE(dev_id, fw_vend) \\\n\t{ \\\n\t\tBRCM_PCIE_VENDOR_ID_BROADCOM, (dev_id), \\\n\t\tPCI_ANY_ID, PCI_ANY_ID, \\\n\t\tPCI_CLASS_NETWORK_OTHER << 8, 0xffff00, \\\n\t\tBRCMF_FWVENDOR_ ## fw_vend \\\n\t}\n#define BRCMF_PCIE_DEVICE_SUB(dev_id, subvend, subdev, fw_vend) \\\n\t{ \\\n\t\tBRCM_PCIE_VENDOR_ID_BROADCOM, (dev_id), \\\n\t\t(subvend), (subdev), \\\n\t\tPCI_CLASS_NETWORK_OTHER << 8, 0xffff00, \\\n\t\tBRCMF_FWVENDOR_ ## fw_vend \\\n\t}\n\nstatic const struct pci_device_id brcmf_pcie_devid_table[] = {\n\tBRCMF_PCIE_DEVICE(BRCM_PCIE_4350_DEVICE_ID, WCC),\n\tBRCMF_PCIE_DEVICE_SUB(0x4355, BRCM_PCIE_VENDOR_ID_BROADCOM, 0x4355, WCC),\n\tBRCMF_PCIE_DEVICE(BRCM_PCIE_4354_RAW_DEVICE_ID, WCC),\n\tBRCMF_PCIE_DEVICE(BRCM_PCIE_4355_DEVICE_ID, WCC),\n\tBRCMF_PCIE_DEVICE(BRCM_PCIE_4356_DEVICE_ID, WCC),\n\tBRCMF_PCIE_DEVICE(BRCM_PCIE_43567_DEVICE_ID, WCC),\n\tBRCMF_PCIE_DEVICE(BRCM_PCIE_43570_DEVICE_ID, WCC),\n\tBRCMF_PCIE_DEVICE(BRCM_PCIE_43570_RAW_DEVICE_ID, WCC),\n\tBRCMF_PCIE_DEVICE(BRCM_PCIE_4358_DEVICE_ID, WCC),\n\tBRCMF_PCIE_DEVICE(BRCM_PCIE_4359_DEVICE_ID, WCC),\n\tBRCMF_PCIE_DEVICE(BRCM_PCIE_43602_DEVICE_ID, WCC),\n\tBRCMF_PCIE_DEVICE(BRCM_PCIE_43602_2G_DEVICE_ID, WCC),\n\tBRCMF_PCIE_DEVICE(BRCM_PCIE_43602_5G_DEVICE_ID, WCC),\n\tBRCMF_PCIE_DEVICE(BRCM_PCIE_43602_RAW_DEVICE_ID, WCC),\n\tBRCMF_PCIE_DEVICE(BRCM_PCIE_4364_DEVICE_ID, WCC),\n\tBRCMF_PCIE_DEVICE(BRCM_PCIE_4365_DEVICE_ID, BCA),\n\tBRCMF_PCIE_DEVICE(BRCM_PCIE_4365_2G_DEVICE_ID, BCA),\n\tBRCMF_PCIE_DEVICE(BRCM_PCIE_4365_5G_DEVICE_ID, BCA),\n\tBRCMF_PCIE_DEVICE_SUB(0x4365, BRCM_PCIE_VENDOR_ID_BROADCOM, 0x4365, BCA),\n\tBRCMF_PCIE_DEVICE(BRCM_PCIE_4366_DEVICE_ID, BCA),\n\tBRCMF_PCIE_DEVICE(BRCM_PCIE_4366_2G_DEVICE_ID, BCA),\n\tBRCMF_PCIE_DEVICE(BRCM_PCIE_4366_5G_DEVICE_ID, BCA),\n\tBRCMF_PCIE_DEVICE(BRCM_PCIE_4371_DEVICE_ID, WCC),\n\tBRCMF_PCIE_DEVICE(BRCM_PCIE_43596_DEVICE_ID, CYW),\n\tBRCMF_PCIE_DEVICE(BRCM_PCIE_4377_DEVICE_ID, WCC),\n\tBRCMF_PCIE_DEVICE(BRCM_PCIE_4378_DEVICE_ID, WCC),\n\tBRCMF_PCIE_DEVICE(BRCM_PCIE_4387_DEVICE_ID, WCC),\n\n\t{   }\n};\n\n\nMODULE_DEVICE_TABLE(pci, brcmf_pcie_devid_table);\n\n\nstatic struct pci_driver brcmf_pciedrvr = {\n\t.node = {},\n\t.name = KBUILD_MODNAME,\n\t.id_table = brcmf_pcie_devid_table,\n\t.probe = brcmf_pcie_probe,\n\t.remove = brcmf_pcie_remove,\n#ifdef CONFIG_PM\n\t.driver.pm = &brcmf_pciedrvr_pm,\n#endif\n\t.driver.coredump = brcmf_dev_coredump,\n};\n\n\nint brcmf_pcie_register(void)\n{\n\tbrcmf_dbg(PCIE, \"Enter\\n\");\n\treturn pci_register_driver(&brcmf_pciedrvr);\n}\n\n\nvoid brcmf_pcie_exit(void)\n{\n\tbrcmf_dbg(PCIE, \"Enter\\n\");\n\tpci_unregister_driver(&brcmf_pciedrvr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}