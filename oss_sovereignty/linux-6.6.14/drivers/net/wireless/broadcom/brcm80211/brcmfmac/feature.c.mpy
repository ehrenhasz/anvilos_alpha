{
  "module_name": "feature.c",
  "hash_id": "d5cddcbda0f4cc0bf760fe621ba8621ab60c2c0ca689f0854203bb69afafaed0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/module.h>\n\n#include <brcm_hw_ids.h>\n#include <brcmu_wifi.h>\n#include \"core.h\"\n#include \"bus.h\"\n#include \"debug.h\"\n#include \"fwil.h\"\n#include \"fwil_types.h\"\n#include \"feature.h\"\n#include \"common.h\"\n\n#define BRCMF_FW_UNSUPPORTED\t23\n\n \n#define BRCMF_FEAT_DEF(_f) \\\n\t#_f,\nstatic const char *brcmf_feat_names[] = {\n\tBRCMF_FEAT_LIST\n};\n#undef BRCMF_FEAT_DEF\n\nstruct brcmf_feat_fwcap {\n\tenum brcmf_feat_id feature;\n\tconst char * const fwcap_id;\n};\n\nstatic const struct brcmf_feat_fwcap brcmf_fwcap_map[] = {\n\t{ BRCMF_FEAT_MBSS, \"mbss\" },\n\t{ BRCMF_FEAT_MCHAN, \"mchan\" },\n\t{ BRCMF_FEAT_P2P, \"p2p\" },\n\t{ BRCMF_FEAT_MONITOR, \"monitor\" },\n\t{ BRCMF_FEAT_MONITOR_FLAG, \"rtap\" },\n\t{ BRCMF_FEAT_MONITOR_FMT_RADIOTAP, \"rtap\" },\n\t{ BRCMF_FEAT_DOT11H, \"802.11h\" },\n\t{ BRCMF_FEAT_SAE, \"sae\" },\n\t{ BRCMF_FEAT_FWAUTH, \"idauth\" },\n};\n\n#ifdef DEBUG\n \n#define BRCMF_QUIRK_DEF(_q) \\\n\t#_q,\nstatic const char * const brcmf_quirk_names[] = {\n\tBRCMF_QUIRK_LIST\n};\n#undef BRCMF_QUIRK_DEF\n\n \nstatic int brcmf_feat_debugfs_read(struct seq_file *seq, void *data)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(seq->private);\n\tu32 feats = bus_if->drvr->feat_flags;\n\tu32 quirks = bus_if->drvr->chip_quirks;\n\tint id;\n\n\tseq_printf(seq, \"Features: %08x\\n\", feats);\n\tfor (id = 0; id < BRCMF_FEAT_LAST; id++)\n\t\tif (feats & BIT(id))\n\t\t\tseq_printf(seq, \"\\t%s\\n\", brcmf_feat_names[id]);\n\tseq_printf(seq, \"\\nQuirks:   %08x\\n\", quirks);\n\tfor (id = 0; id < BRCMF_FEAT_QUIRK_LAST; id++)\n\t\tif (quirks & BIT(id))\n\t\t\tseq_printf(seq, \"\\t%s\\n\", brcmf_quirk_names[id]);\n\treturn 0;\n}\n#else\nstatic int brcmf_feat_debugfs_read(struct seq_file *seq, void *data)\n{\n\treturn 0;\n}\n#endif  \n\nstruct brcmf_feat_fwfeat {\n\tconst char * const fwid;\n\tu32 feat_flags;\n};\n\nstatic const struct brcmf_feat_fwfeat brcmf_feat_fwfeat_map[] = {\n\t \n\t{ \"01-6cb8e269\", BIT(BRCMF_FEAT_MONITOR) },\n\t \n\t{ \"01-c47a91a4\", BIT(BRCMF_FEAT_MONITOR) },\n\t \n\t{ \"01-801fb449\", BIT(BRCMF_FEAT_MONITOR_FMT_HW_RX_HDR) },\n\t \n\t{ \"01-d2cbb8fd\", BIT(BRCMF_FEAT_MONITOR_FMT_HW_RX_HDR) },\n};\n\nstatic void brcmf_feat_firmware_overrides(struct brcmf_pub *drv)\n{\n\tconst struct brcmf_feat_fwfeat *e;\n\tu32 feat_flags = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(brcmf_feat_fwfeat_map); i++) {\n\t\te = &brcmf_feat_fwfeat_map[i];\n\t\tif (!strcmp(e->fwid, drv->fwver)) {\n\t\t\tfeat_flags = e->feat_flags;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!feat_flags)\n\t\treturn;\n\n\tfor (i = 0; i < BRCMF_FEAT_LAST; i++)\n\t\tif (feat_flags & BIT(i))\n\t\t\tbrcmf_dbg(INFO, \"enabling firmware feature: %s\\n\",\n\t\t\t\t  brcmf_feat_names[i]);\n\tdrv->feat_flags |= feat_flags;\n}\n\nstruct brcmf_feat_wlcfeat {\n\tu16 min_ver_major;\n\tu16 min_ver_minor;\n\tu32 feat_flags;\n};\n\nstatic const struct brcmf_feat_wlcfeat brcmf_feat_wlcfeat_map[] = {\n\t{ 12, 0, BIT(BRCMF_FEAT_PMKID_V2) },\n\t{ 13, 0, BIT(BRCMF_FEAT_PMKID_V3) },\n};\n\nstatic void brcmf_feat_wlc_version_overrides(struct brcmf_pub *drv)\n{\n\tstruct brcmf_if *ifp = brcmf_get_ifp(drv, 0);\n\tconst struct brcmf_feat_wlcfeat *e;\n\tstruct brcmf_wlc_version_le ver;\n\tu32 feat_flags = 0;\n\tint i, err, major, minor;\n\n\terr = brcmf_fil_iovar_data_get(ifp, \"wlc_ver\", &ver, sizeof(ver));\n\tif (err)\n\t\treturn;\n\n\tmajor = le16_to_cpu(ver.wlc_ver_major);\n\tminor = le16_to_cpu(ver.wlc_ver_minor);\n\n\tbrcmf_dbg(INFO, \"WLC version: %d.%d\\n\", major, minor);\n\n\tfor (i = 0; i < ARRAY_SIZE(brcmf_feat_wlcfeat_map); i++) {\n\t\te = &brcmf_feat_wlcfeat_map[i];\n\t\tif (major > e->min_ver_major ||\n\t\t    (major == e->min_ver_major &&\n\t\t     minor >= e->min_ver_minor)) {\n\t\t\tfeat_flags |= e->feat_flags;\n\t\t}\n\t}\n\n\tif (!feat_flags)\n\t\treturn;\n\n\tfor (i = 0; i < BRCMF_FEAT_LAST; i++)\n\t\tif (feat_flags & BIT(i))\n\t\t\tbrcmf_dbg(INFO, \"enabling firmware feature: %s\\n\",\n\t\t\t\t  brcmf_feat_names[i]);\n\tdrv->feat_flags |= feat_flags;\n}\n\n \nstatic void brcmf_feat_iovar_int_get(struct brcmf_if *ifp,\n\t\t\t\t     enum brcmf_feat_id id, char *name)\n{\n\tu32 data;\n\tint err;\n\n\t \n\tifp->fwil_fwerr = true;\n\n\terr = brcmf_fil_iovar_int_get(ifp, name, &data);\n\tif (err != -BRCMF_FW_UNSUPPORTED) {\n\t\tbrcmf_dbg(INFO, \"enabling feature: %s\\n\", brcmf_feat_names[id]);\n\t\tifp->drvr->feat_flags |= BIT(id);\n\t} else {\n\t\tbrcmf_dbg(TRACE, \"%s feature check failed: %d\\n\",\n\t\t\t  brcmf_feat_names[id], err);\n\t}\n\n\tifp->fwil_fwerr = false;\n}\n\nstatic void brcmf_feat_iovar_data_set(struct brcmf_if *ifp,\n\t\t\t\t      enum brcmf_feat_id id, char *name,\n\t\t\t\t      const void *data, size_t len)\n{\n\tint err;\n\n\t \n\tifp->fwil_fwerr = true;\n\n\terr = brcmf_fil_iovar_data_set(ifp, name, data, len);\n\tif (err != -BRCMF_FW_UNSUPPORTED) {\n\t\tbrcmf_dbg(INFO, \"enabling feature: %s\\n\", brcmf_feat_names[id]);\n\t\tifp->drvr->feat_flags |= BIT(id);\n\t} else {\n\t\tbrcmf_dbg(TRACE, \"%s feature check failed: %d\\n\",\n\t\t\t  brcmf_feat_names[id], err);\n\t}\n\n\tifp->fwil_fwerr = false;\n}\n\n#define MAX_CAPS_BUFFER_SIZE\t768\nstatic void brcmf_feat_firmware_capabilities(struct brcmf_if *ifp)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tchar caps[MAX_CAPS_BUFFER_SIZE];\n\tenum brcmf_feat_id id;\n\tint i, err;\n\n\terr = brcmf_fil_iovar_data_get(ifp, \"cap\", caps, sizeof(caps));\n\tif (err) {\n\t\tbphy_err(drvr, \"could not get firmware cap (%d)\\n\", err);\n\t\treturn;\n\t}\n\n\tbrcmf_dbg(INFO, \"[ %s]\\n\", caps);\n\n\tfor (i = 0; i < ARRAY_SIZE(brcmf_fwcap_map); i++) {\n\t\tif (strnstr(caps, brcmf_fwcap_map[i].fwcap_id, sizeof(caps))) {\n\t\t\tid = brcmf_fwcap_map[i].feature;\n\t\t\tbrcmf_dbg(INFO, \"enabling feature: %s\\n\",\n\t\t\t\t  brcmf_feat_names[id]);\n\t\t\tifp->drvr->feat_flags |= BIT(id);\n\t\t}\n\t}\n}\n\n \nstatic int brcmf_feat_fwcap_debugfs_read(struct seq_file *seq, void *data)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(seq->private);\n\tstruct brcmf_pub *drvr = bus_if->drvr;\n\tstruct brcmf_if *ifp = brcmf_get_ifp(drvr, 0);\n\tchar caps[MAX_CAPS_BUFFER_SIZE + 1] = { };\n\tchar *tmp;\n\tint err;\n\n\terr = brcmf_fil_iovar_data_get(ifp, \"cap\", caps, sizeof(caps));\n\tif (err) {\n\t\tbphy_err(drvr, \"could not get firmware cap (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tfor (tmp = caps; *tmp; tmp++) {\n\t\tif (*tmp == ' ')\n\t\t\t*tmp = '\\n';\n\t}\n\n\t \n\tseq_printf(seq, \"%s\", caps);\n\t \n\tif (tmp > caps && *(tmp - 1) != '\\n')\n\t\tseq_printf(seq, \"\\n\");\n\n\treturn 0;\n}\n\nvoid brcmf_feat_attach(struct brcmf_pub *drvr)\n{\n\tstruct brcmf_if *ifp = brcmf_get_ifp(drvr, 0);\n\tstruct brcmf_pno_macaddr_le pfn_mac;\n\tstruct brcmf_gscan_config gscan_cfg;\n\tu32 wowl_cap;\n\ts32 err;\n\n\tbrcmf_feat_firmware_capabilities(ifp);\n\tmemset(&gscan_cfg, 0, sizeof(gscan_cfg));\n\tif (drvr->bus_if->chip != BRCM_CC_43430_CHIP_ID &&\n\t    drvr->bus_if->chip != BRCM_CC_4345_CHIP_ID &&\n\t    drvr->bus_if->chip != BRCM_CC_43454_CHIP_ID &&\n\t    drvr->bus_if->chip != CY_CC_43439_CHIP_ID)\n\t\tbrcmf_feat_iovar_data_set(ifp, BRCMF_FEAT_GSCAN,\n\t\t\t\t\t  \"pfn_gscan_cfg\",\n\t\t\t\t\t  &gscan_cfg, sizeof(gscan_cfg));\n\tbrcmf_feat_iovar_int_get(ifp, BRCMF_FEAT_PNO, \"pfn\");\n\tif (drvr->bus_if->wowl_supported)\n\t\tbrcmf_feat_iovar_int_get(ifp, BRCMF_FEAT_WOWL, \"wowl\");\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL)) {\n\t\terr = brcmf_fil_iovar_int_get(ifp, \"wowl_cap\", &wowl_cap);\n\t\tif (!err) {\n\t\t\tifp->drvr->feat_flags |= BIT(BRCMF_FEAT_WOWL_ARP_ND);\n\t\t\tif (wowl_cap & BRCMF_WOWL_PFN_FOUND)\n\t\t\t\tifp->drvr->feat_flags |=\n\t\t\t\t\tBIT(BRCMF_FEAT_WOWL_ND);\n\t\t\tif (wowl_cap & BRCMF_WOWL_GTK_FAILURE)\n\t\t\t\tifp->drvr->feat_flags |=\n\t\t\t\t\tBIT(BRCMF_FEAT_WOWL_GTK);\n\t\t}\n\t}\n\t \n\tswitch (drvr->bus_if->chip) {\n\tcase BRCM_CC_4330_CHIP_ID:\n\tcase BRCM_CC_43362_CHIP_ID:\n\t\tifp->drvr->feat_flags &= ~BIT(BRCMF_FEAT_MBSS);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tbrcmf_feat_iovar_int_get(ifp, BRCMF_FEAT_RSDB, \"rsdb_mode\");\n\tbrcmf_feat_iovar_int_get(ifp, BRCMF_FEAT_TDLS, \"tdls_enable\");\n\tbrcmf_feat_iovar_int_get(ifp, BRCMF_FEAT_MFP, \"mfp\");\n\tbrcmf_feat_iovar_int_get(ifp, BRCMF_FEAT_DUMP_OBSS, \"dump_obss\");\n\n\tpfn_mac.version = BRCMF_PFN_MACADDR_CFG_VER;\n\terr = brcmf_fil_iovar_data_get(ifp, \"pfn_macaddr\", &pfn_mac,\n\t\t\t\t       sizeof(pfn_mac));\n\tif (!err)\n\t\tifp->drvr->feat_flags |= BIT(BRCMF_FEAT_SCAN_RANDOM_MAC);\n\n\tbrcmf_feat_iovar_int_get(ifp, BRCMF_FEAT_FWSUP, \"sup_wpa\");\n\tbrcmf_feat_iovar_int_get(ifp, BRCMF_FEAT_SCAN_V2, \"scan_ver\");\n\n\tif (drvr->settings->feature_disable) {\n\t\tbrcmf_dbg(INFO, \"Features: 0x%02x, disable: 0x%02x\\n\",\n\t\t\t  ifp->drvr->feat_flags,\n\t\t\t  drvr->settings->feature_disable);\n\t\tifp->drvr->feat_flags &= ~drvr->settings->feature_disable;\n\t}\n\n\tbrcmf_feat_wlc_version_overrides(drvr);\n\tbrcmf_feat_firmware_overrides(drvr);\n\n\t \n\tswitch (drvr->bus_if->chip) {\n\tcase BRCM_CC_43236_CHIP_ID:\n\t\tdrvr->chip_quirks |= BIT(BRCMF_FEAT_QUIRK_AUTO_AUTH);\n\t\tbreak;\n\tcase BRCM_CC_4329_CHIP_ID:\n\t\tdrvr->chip_quirks |= BIT(BRCMF_FEAT_QUIRK_NEED_MPC);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n\nvoid brcmf_feat_debugfs_create(struct brcmf_pub *drvr)\n{\n\tbrcmf_debugfs_add_entry(drvr, \"features\", brcmf_feat_debugfs_read);\n\tbrcmf_debugfs_add_entry(drvr, \"fwcap\", brcmf_feat_fwcap_debugfs_read);\n}\n\nbool brcmf_feat_is_enabled(struct brcmf_if *ifp, enum brcmf_feat_id id)\n{\n\treturn (ifp->drvr->feat_flags & BIT(id));\n}\n\nbool brcmf_feat_is_quirk_enabled(struct brcmf_if *ifp,\n\t\t\t\t enum brcmf_feat_quirk quirk)\n{\n\treturn (ifp->drvr->chip_quirks & BIT(quirk));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}