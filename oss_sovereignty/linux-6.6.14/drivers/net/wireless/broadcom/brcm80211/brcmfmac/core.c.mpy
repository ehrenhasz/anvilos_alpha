{
  "module_name": "core.c",
  "hash_id": "362b86c86b2332025ca9abebf5d4404bc72d66a6110c85d0932c9b22783bf08e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/etherdevice.h>\n#include <linux/module.h>\n#include <linux/inetdevice.h>\n#include <linux/property.h>\n#include <net/cfg80211.h>\n#include <net/rtnetlink.h>\n#include <net/addrconf.h>\n#include <net/ieee80211_radiotap.h>\n#include <net/ipv6.h>\n#include <brcmu_utils.h>\n#include <brcmu_wifi.h>\n\n#include \"core.h\"\n#include \"bus.h\"\n#include \"fwvid.h\"\n#include \"debug.h\"\n#include \"fwil_types.h\"\n#include \"p2p.h\"\n#include \"pno.h\"\n#include \"cfg80211.h\"\n#include \"fwil.h\"\n#include \"feature.h\"\n#include \"proto.h\"\n#include \"pcie.h\"\n#include \"common.h\"\n\n#define MAX_WAIT_FOR_8021X_TX\t\t\tmsecs_to_jiffies(950)\n\n#define BRCMF_BSSIDX_INVALID\t\t\t-1\n\n#define\tRXS_PBPRES\t\t\t\tBIT(2)\n\n#define\tD11_PHY_HDR_LEN\t\t\t\t6\n\nstruct d11rxhdr_le {\n\t__le16 RxFrameSize;\n\tu16 PAD;\n\t__le16 PhyRxStatus_0;\n\t__le16 PhyRxStatus_1;\n\t__le16 PhyRxStatus_2;\n\t__le16 PhyRxStatus_3;\n\t__le16 PhyRxStatus_4;\n\t__le16 PhyRxStatus_5;\n\t__le16 RxStatus1;\n\t__le16 RxStatus2;\n\t__le16 RxTSFTime;\n\t__le16 RxChan;\n\tu8 unknown[12];\n} __packed;\n\nstruct wlc_d11rxhdr {\n\tstruct d11rxhdr_le rxhdr;\n\t__le32 tsf_l;\n\ts8 rssi;\n\ts8 rxpwr0;\n\ts8 rxpwr1;\n\ts8 do_rssi_ma;\n\ts8 rxpwr[4];\n} __packed;\n\nchar *brcmf_ifname(struct brcmf_if *ifp)\n{\n\tif (!ifp)\n\t\treturn \"<if_null>\";\n\n\tif (ifp->ndev)\n\t\treturn ifp->ndev->name;\n\n\treturn \"<if_none>\";\n}\n\nstruct brcmf_if *brcmf_get_ifp(struct brcmf_pub *drvr, int ifidx)\n{\n\tstruct brcmf_if *ifp;\n\ts32 bsscfgidx;\n\n\tif (ifidx < 0 || ifidx >= BRCMF_MAX_IFS) {\n\t\tbphy_err(drvr, \"ifidx %d out of range\\n\", ifidx);\n\t\treturn NULL;\n\t}\n\n\tifp = NULL;\n\tbsscfgidx = drvr->if2bss[ifidx];\n\tif (bsscfgidx >= 0)\n\t\tifp = drvr->iflist[bsscfgidx];\n\n\treturn ifp;\n}\n\nvoid brcmf_configure_arp_nd_offload(struct brcmf_if *ifp, bool enable)\n{\n\ts32 err;\n\tu32 mode;\n\n\tif (enable)\n\t\tmode = BRCMF_ARP_OL_AGENT | BRCMF_ARP_OL_PEER_AUTO_REPLY;\n\telse\n\t\tmode = 0;\n\n\t \n\t \n\terr = brcmf_fil_iovar_int_set(ifp, \"arp_ol\", mode);\n\tif (err) {\n\t\tbrcmf_dbg(TRACE, \"failed to set ARP offload mode to 0x%x, err = %d\\n\",\n\t\t\t  mode, err);\n\t} else {\n\t\terr = brcmf_fil_iovar_int_set(ifp, \"arpoe\", enable);\n\t\tif (err) {\n\t\t\tbrcmf_dbg(TRACE, \"failed to configure (%d) ARP offload err = %d\\n\",\n\t\t\t\t  enable, err);\n\t\t} else {\n\t\t\tbrcmf_dbg(TRACE, \"successfully configured (%d) ARP offload to 0x%x\\n\",\n\t\t\t\t  enable, mode);\n\t\t}\n\t}\n\n\terr = brcmf_fil_iovar_int_set(ifp, \"ndoe\", enable);\n\tif (err) {\n\t\tbrcmf_dbg(TRACE, \"failed to configure (%d) ND offload err = %d\\n\",\n\t\t\t  enable, err);\n\t} else {\n\t\tbrcmf_dbg(TRACE, \"successfully configured (%d) ND offload to 0x%x\\n\",\n\t\t\t  enable, mode);\n\t}\n}\n\nstatic void _brcmf_set_multicast_list(struct work_struct *work)\n{\n\tstruct brcmf_if *ifp = container_of(work, struct brcmf_if,\n\t\t\t\t\t    multicast_work);\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct net_device *ndev;\n\tstruct netdev_hw_addr *ha;\n\tu32 cmd_value, cnt;\n\t__le32 cnt_le;\n\tchar *buf, *bufp;\n\tu32 buflen;\n\ts32 err;\n\n\tbrcmf_dbg(TRACE, \"Enter, bsscfgidx=%d\\n\", ifp->bsscfgidx);\n\n\tndev = ifp->ndev;\n\n\t \n\tcmd_value = (ndev->flags & IFF_ALLMULTI) ? true : false;\n\n\t \n\tcnt = netdev_mc_count(ndev);\n\tbuflen = sizeof(cnt) + (cnt * ETH_ALEN);\n\tbuf = kmalloc(buflen, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\tbufp = buf;\n\n\tcnt_le = cpu_to_le32(cnt);\n\tmemcpy(bufp, &cnt_le, sizeof(cnt_le));\n\tbufp += sizeof(cnt_le);\n\n\tnetdev_for_each_mc_addr(ha, ndev) {\n\t\tif (!cnt)\n\t\t\tbreak;\n\t\tmemcpy(bufp, ha->addr, ETH_ALEN);\n\t\tbufp += ETH_ALEN;\n\t\tcnt--;\n\t}\n\n\terr = brcmf_fil_iovar_data_set(ifp, \"mcast_list\", buf, buflen);\n\tif (err < 0) {\n\t\tbphy_err(drvr, \"Setting mcast_list failed, %d\\n\", err);\n\t\tcmd_value = cnt ? true : cmd_value;\n\t}\n\n\tkfree(buf);\n\n\t \n\terr = brcmf_fil_iovar_int_set(ifp, \"allmulti\", cmd_value);\n\tif (err < 0)\n\t\tbphy_err(drvr, \"Setting allmulti failed, %d\\n\", err);\n\n\t \n\tcmd_value = (ndev->flags & IFF_PROMISC) ? true : false;\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PROMISC, cmd_value);\n\tif (err < 0) {\n\t\t \n\t\tif (err == -EBADE)\n\t\t\tbphy_info_once(drvr, \"BRCMF_C_SET_PROMISC unsupported\\n\");\n\t\telse\n\t\t\tbphy_err(drvr, \"Setting BRCMF_C_SET_PROMISC failed, err=%d\\n\",\n\t\t\t\t err);\n\t}\n\tbrcmf_configure_arp_nd_offload(ifp, !cmd_value);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void _brcmf_update_ndtable(struct work_struct *work)\n{\n\tstruct brcmf_if *ifp = container_of(work, struct brcmf_if,\n\t\t\t\t\t    ndoffload_work);\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tint i, ret;\n\n\t \n\tret = brcmf_fil_iovar_data_set(ifp, \"nd_hostip_clear\", NULL, 0);\n\tif (ret) {\n\t\tbrcmf_dbg(TRACE, \"fail to clear nd ip table err:%d\\n\", ret);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < ifp->ipv6addr_idx; i++) {\n\t\tret = brcmf_fil_iovar_data_set(ifp, \"nd_hostip\",\n\t\t\t\t\t       &ifp->ipv6_addr_tbl[i],\n\t\t\t\t\t       sizeof(struct in6_addr));\n\t\tif (ret)\n\t\t\tbphy_err(drvr, \"add nd ip err %d\\n\", ret);\n\t}\n}\n#else\nstatic void _brcmf_update_ndtable(struct work_struct *work)\n{\n}\n#endif\n\nstatic int brcmf_netdev_set_mac_address(struct net_device *ndev, void *addr)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct sockaddr *sa = (struct sockaddr *)addr;\n\tint err;\n\n\tbrcmf_dbg(TRACE, \"Enter, bsscfgidx=%d\\n\", ifp->bsscfgidx);\n\n\terr = brcmf_c_set_cur_etheraddr(ifp, sa->sa_data);\n\tif (err >= 0) {\n\t\tbrcmf_dbg(TRACE, \"updated to %pM\\n\", sa->sa_data);\n\t\tmemcpy(ifp->mac_addr, sa->sa_data, ETH_ALEN);\n\t\teth_hw_addr_set(ifp->ndev, ifp->mac_addr);\n\t}\n\treturn err;\n}\n\nstatic void brcmf_netdev_set_multicast_list(struct net_device *ndev)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\n\tschedule_work(&ifp->multicast_work);\n}\n\n \nstatic bool brcmf_skb_is_iapp(struct sk_buff *skb)\n{\n\tstatic const u8 iapp_l2_update_packet[6] __aligned(2) = {\n\t\t0x00, 0x01, 0xaf, 0x81, 0x01, 0x00,\n\t};\n\tunsigned char *eth_data;\n#if !defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n\tconst u16 *a, *b;\n#endif\n\n\tif (skb->len - skb->mac_len != 6 ||\n\t    !is_multicast_ether_addr(eth_hdr(skb)->h_dest))\n\t\treturn false;\n\n\teth_data = skb_mac_header(skb) + ETH_HLEN;\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n\treturn !(((*(const u32 *)eth_data) ^ (*(const u32 *)iapp_l2_update_packet)) |\n\t\t ((*(const u16 *)(eth_data + 4)) ^ (*(const u16 *)(iapp_l2_update_packet + 4))));\n#else\n\ta = (const u16 *)eth_data;\n\tb = (const u16 *)iapp_l2_update_packet;\n\n\treturn !((a[0] ^ b[0]) | (a[1] ^ b[1]) | (a[2] ^ b[2]));\n#endif\n}\n\nstatic netdev_tx_t brcmf_netdev_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t   struct net_device *ndev)\n{\n\tint ret;\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct ethhdr *eh;\n\tint head_delta;\n\tunsigned int tx_bytes = skb->len;\n\n\tbrcmf_dbg(DATA, \"Enter, bsscfgidx=%d\\n\", ifp->bsscfgidx);\n\n\t \n\tif (drvr->bus_if->state != BRCMF_BUS_UP) {\n\t\tbphy_err(drvr, \"xmit rejected state=%d\\n\", drvr->bus_if->state);\n\t\tnetif_stop_queue(ndev);\n\t\tdev_kfree_skb(skb);\n\t\tret = -ENODEV;\n\t\tgoto done;\n\t}\n\n\t \n\tif (!drvr->settings->iapp && brcmf_skb_is_iapp(skb)) {\n\t\tdev_kfree_skb(skb);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\t \n\tif (skb_headroom(skb) < drvr->hdrlen || skb_header_cloned(skb)) {\n\t\thead_delta = max_t(int, drvr->hdrlen - skb_headroom(skb), 0);\n\n\t\tbrcmf_dbg(INFO, \"%s: insufficient headroom (%d)\\n\",\n\t\t\t  brcmf_ifname(ifp), head_delta);\n\t\tatomic_inc(&drvr->bus_if->stats.pktcowed);\n\t\tret = pskb_expand_head(skb, ALIGN(head_delta, NET_SKB_PAD), 0,\n\t\t\t\t       GFP_ATOMIC);\n\t\tif (ret < 0) {\n\t\t\tbphy_err(drvr, \"%s: failed to expand headroom\\n\",\n\t\t\t\t brcmf_ifname(ifp));\n\t\t\tatomic_inc(&drvr->bus_if->stats.pktcow_failed);\n\t\t\tdev_kfree_skb(skb);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\tif (skb->len < sizeof(*eh)) {\n\t\tret = -EINVAL;\n\t\tdev_kfree_skb(skb);\n\t\tgoto done;\n\t}\n\n\teh = (struct ethhdr *)(skb->data);\n\n\tif (eh->h_proto == htons(ETH_P_PAE))\n\t\tatomic_inc(&ifp->pend_8021x_cnt);\n\n\t \n\tif ((skb->priority == 0) || (skb->priority > 7))\n\t\tskb->priority = cfg80211_classify8021d(skb, NULL);\n\n\t \n\tsk_pacing_shift_update(skb->sk, 8);\n\n\tret = brcmf_proto_tx_queue_data(drvr, ifp->ifidx, skb);\n\tif (ret < 0)\n\t\tbrcmf_txfinalize(ifp, skb, false);\n\ndone:\n\tif (ret) {\n\t\tndev->stats.tx_dropped++;\n\t} else {\n\t\tndev->stats.tx_packets++;\n\t\tndev->stats.tx_bytes += tx_bytes;\n\t}\n\n\t \n\treturn NETDEV_TX_OK;\n}\n\nvoid brcmf_txflowblock_if(struct brcmf_if *ifp,\n\t\t\t  enum brcmf_netif_stop_reason reason, bool state)\n{\n\tunsigned long flags;\n\n\tif (!ifp || !ifp->ndev)\n\t\treturn;\n\n\tbrcmf_dbg(TRACE, \"enter: bsscfgidx=%d stop=0x%X reason=%d state=%d\\n\",\n\t\t  ifp->bsscfgidx, ifp->netif_stop, reason, state);\n\n\tspin_lock_irqsave(&ifp->netif_stop_lock, flags);\n\tif (state) {\n\t\tif (!ifp->netif_stop)\n\t\t\tnetif_stop_queue(ifp->ndev);\n\t\tifp->netif_stop |= reason;\n\t} else {\n\t\tifp->netif_stop &= ~reason;\n\t\tif (!ifp->netif_stop)\n\t\t\tnetif_wake_queue(ifp->ndev);\n\t}\n\tspin_unlock_irqrestore(&ifp->netif_stop_lock, flags);\n}\n\nvoid brcmf_netif_rx(struct brcmf_if *ifp, struct sk_buff *skb)\n{\n\t \n\tif (!ifp->drvr->settings->iapp && brcmf_skb_is_iapp(skb)) {\n\t\tbrcmu_pkt_buf_free_skb(skb);\n\t\treturn;\n\t}\n\n\tif (skb->pkt_type == PACKET_MULTICAST)\n\t\tifp->ndev->stats.multicast++;\n\n\tif (!(ifp->ndev->flags & IFF_UP)) {\n\t\tbrcmu_pkt_buf_free_skb(skb);\n\t\treturn;\n\t}\n\n\tifp->ndev->stats.rx_bytes += skb->len;\n\tifp->ndev->stats.rx_packets++;\n\n\tbrcmf_dbg(DATA, \"rx proto=0x%X\\n\", ntohs(skb->protocol));\n\tnetif_rx(skb);\n}\n\nvoid brcmf_netif_mon_rx(struct brcmf_if *ifp, struct sk_buff *skb)\n{\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MONITOR_FMT_RADIOTAP)) {\n\t\t \n\t} else if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MONITOR_FMT_HW_RX_HDR)) {\n\t\tstruct wlc_d11rxhdr *wlc_rxhdr = (struct wlc_d11rxhdr *)skb->data;\n\t\tstruct ieee80211_radiotap_header *radiotap;\n\t\tunsigned int offset;\n\t\tu16 RxStatus1;\n\n\t\tRxStatus1 = le16_to_cpu(wlc_rxhdr->rxhdr.RxStatus1);\n\n\t\toffset = sizeof(struct wlc_d11rxhdr);\n\t\t \n\t\tif (RxStatus1 & RXS_PBPRES)\n\t\t\toffset += 2;\n\t\toffset += D11_PHY_HDR_LEN;\n\n\t\tskb_pull(skb, offset);\n\n\t\t \n\t\tradiotap = skb_push(skb, sizeof(*radiotap));\n\t\tmemset(radiotap, 0, sizeof(*radiotap));\n\t\tradiotap->it_len = cpu_to_le16(sizeof(*radiotap));\n\n\t\t \n\t\tskb->len -= 4;\n\t} else {\n\t\tstruct ieee80211_radiotap_header *radiotap;\n\n\t\t \n\t\tradiotap = skb_push(skb, sizeof(*radiotap));\n\t\tmemset(radiotap, 0, sizeof(*radiotap));\n\t\tradiotap->it_len = cpu_to_le16(sizeof(*radiotap));\n\n\t\t \n\t\tskb->len -= 4;\n\t}\n\n\tskb->dev = ifp->ndev;\n\tskb_reset_mac_header(skb);\n\tskb->pkt_type = PACKET_OTHERHOST;\n\tskb->protocol = htons(ETH_P_802_2);\n\n\tbrcmf_netif_rx(ifp, skb);\n}\n\nstatic int brcmf_rx_hdrpull(struct brcmf_pub *drvr, struct sk_buff *skb,\n\t\t\t    struct brcmf_if **ifp)\n{\n\tint ret;\n\n\t \n\tret = brcmf_proto_hdrpull(drvr, true, skb, ifp);\n\n\tif (ret || !(*ifp) || !(*ifp)->ndev) {\n\t\tif (ret != -ENODATA && *ifp && (*ifp)->ndev)\n\t\t\t(*ifp)->ndev->stats.rx_errors++;\n\t\tbrcmu_pkt_buf_free_skb(skb);\n\t\treturn -ENODATA;\n\t}\n\n\tskb->protocol = eth_type_trans(skb, (*ifp)->ndev);\n\treturn 0;\n}\n\nvoid brcmf_rx_frame(struct device *dev, struct sk_buff *skb, bool handle_event,\n\t\t    bool inirq)\n{\n\tstruct brcmf_if *ifp;\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_pub *drvr = bus_if->drvr;\n\n\tbrcmf_dbg(DATA, \"Enter: %s: rxp=%p\\n\", dev_name(dev), skb);\n\n\tif (brcmf_rx_hdrpull(drvr, skb, &ifp))\n\t\treturn;\n\n\tif (brcmf_proto_is_reorder_skb(skb)) {\n\t\tbrcmf_proto_rxreorder(ifp, skb);\n\t} else {\n\t\t \n\t\tif (handle_event) {\n\t\t\tgfp_t gfp = inirq ? GFP_ATOMIC : GFP_KERNEL;\n\n\t\t\tbrcmf_fweh_process_skb(ifp->drvr, skb,\n\t\t\t\t\t       BCMILCP_SUBTYPE_VENDOR_LONG, gfp);\n\t\t}\n\t\tbrcmf_netif_rx(ifp, skb);\n\t}\n}\n\nvoid brcmf_rx_event(struct device *dev, struct sk_buff *skb)\n{\n\tstruct brcmf_if *ifp;\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_pub *drvr = bus_if->drvr;\n\n\tbrcmf_dbg(EVENT, \"Enter: %s: rxp=%p\\n\", dev_name(dev), skb);\n\n\tif (brcmf_rx_hdrpull(drvr, skb, &ifp))\n\t\treturn;\n\n\tbrcmf_fweh_process_skb(ifp->drvr, skb, 0, GFP_KERNEL);\n\tbrcmu_pkt_buf_free_skb(skb);\n}\n\nvoid brcmf_txfinalize(struct brcmf_if *ifp, struct sk_buff *txp, bool success)\n{\n\tstruct ethhdr *eh;\n\tu16 type;\n\n\teh = (struct ethhdr *)(txp->data);\n\ttype = ntohs(eh->h_proto);\n\n\tif (type == ETH_P_PAE) {\n\t\tatomic_dec(&ifp->pend_8021x_cnt);\n\t\tif (waitqueue_active(&ifp->pend_8021x_wait))\n\t\t\twake_up(&ifp->pend_8021x_wait);\n\t}\n\n\tif (!success)\n\t\tifp->ndev->stats.tx_errors++;\n\n\tbrcmu_pkt_buf_free_skb(txp);\n}\n\nstatic void brcmf_ethtool_get_drvinfo(struct net_device *ndev,\n\t\t\t\t    struct ethtool_drvinfo *info)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tchar drev[BRCMU_DOTREV_LEN] = \"n/a\";\n\n\tif (drvr->revinfo.result == 0)\n\t\tbrcmu_dotrev_str(drvr->revinfo.driverrev, drev);\n\tstrscpy(info->driver, KBUILD_MODNAME, sizeof(info->driver));\n\tstrscpy(info->version, drev, sizeof(info->version));\n\tstrscpy(info->fw_version, drvr->fwver, sizeof(info->fw_version));\n\tstrscpy(info->bus_info, dev_name(drvr->bus_if->dev),\n\t\tsizeof(info->bus_info));\n}\n\nstatic const struct ethtool_ops brcmf_ethtool_ops = {\n\t.get_drvinfo = brcmf_ethtool_get_drvinfo,\n};\n\nstatic int brcmf_netdev_stop(struct net_device *ndev)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\n\tbrcmf_dbg(TRACE, \"Enter, bsscfgidx=%d\\n\", ifp->bsscfgidx);\n\n\tbrcmf_cfg80211_down(ndev);\n\n\tbrcmf_net_setcarrier(ifp, false);\n\n\treturn 0;\n}\n\nstatic int brcmf_netdev_open(struct net_device *ndev)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_bus *bus_if = drvr->bus_if;\n\tu32 toe_ol;\n\n\tbrcmf_dbg(TRACE, \"Enter, bsscfgidx=%d\\n\", ifp->bsscfgidx);\n\n\t \n\tif (bus_if->state != BRCMF_BUS_UP) {\n\t\tbphy_err(drvr, \"failed bus is not ready\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tatomic_set(&ifp->pend_8021x_cnt, 0);\n\n\t \n\tif (brcmf_fil_iovar_int_get(ifp, \"toe_ol\", &toe_ol) >= 0\n\t    && (toe_ol & TOE_TX_CSUM_OL) != 0)\n\t\tndev->features |= NETIF_F_IP_CSUM;\n\telse\n\t\tndev->features &= ~NETIF_F_IP_CSUM;\n\n\tif (brcmf_cfg80211_up(ndev)) {\n\t\tbphy_err(drvr, \"failed to bring up cfg80211\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tnetif_carrier_off(ndev);\n\treturn 0;\n}\n\nstatic const struct net_device_ops brcmf_netdev_ops_pri = {\n\t.ndo_open = brcmf_netdev_open,\n\t.ndo_stop = brcmf_netdev_stop,\n\t.ndo_start_xmit = brcmf_netdev_start_xmit,\n\t.ndo_set_mac_address = brcmf_netdev_set_mac_address,\n\t.ndo_set_rx_mode = brcmf_netdev_set_multicast_list\n};\n\nint brcmf_net_attach(struct brcmf_if *ifp, bool locked)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct net_device *ndev;\n\ts32 err;\n\n\tbrcmf_dbg(TRACE, \"Enter, bsscfgidx=%d mac=%pM\\n\", ifp->bsscfgidx,\n\t\t  ifp->mac_addr);\n\tndev = ifp->ndev;\n\n\t \n\tndev->netdev_ops = &brcmf_netdev_ops_pri;\n\n\tndev->needed_headroom += drvr->hdrlen;\n\tndev->ethtool_ops = &brcmf_ethtool_ops;\n\n\t \n\teth_hw_addr_set(ndev, ifp->mac_addr);\n\tdev_net_set(ndev, wiphy_net(cfg_to_wiphy(drvr->config)));\n\n\tINIT_WORK(&ifp->multicast_work, _brcmf_set_multicast_list);\n\tINIT_WORK(&ifp->ndoffload_work, _brcmf_update_ndtable);\n\n\tif (locked)\n\t\terr = cfg80211_register_netdevice(ndev);\n\telse\n\t\terr = register_netdev(ndev);\n\tif (err != 0) {\n\t\tbphy_err(drvr, \"couldn't register the net device\\n\");\n\t\tgoto fail;\n\t}\n\n\tnetif_carrier_off(ndev);\n\n\tndev->priv_destructor = brcmf_cfg80211_free_netdev;\n\tbrcmf_dbg(INFO, \"%s: Broadcom Dongle Host Driver\\n\", ndev->name);\n\treturn 0;\n\nfail:\n\tdrvr->iflist[ifp->bsscfgidx] = NULL;\n\tndev->netdev_ops = NULL;\n\treturn -EBADE;\n}\n\nvoid brcmf_net_detach(struct net_device *ndev, bool locked)\n{\n\tif (ndev->reg_state == NETREG_REGISTERED) {\n\t\tif (locked)\n\t\t\tcfg80211_unregister_netdevice(ndev);\n\t\telse\n\t\t\tunregister_netdev(ndev);\n\t} else {\n\t\tbrcmf_cfg80211_free_netdev(ndev);\n\t\tfree_netdev(ndev);\n\t}\n}\n\nstatic int brcmf_net_mon_open(struct net_device *ndev)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tu32 monitor;\n\tint err;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\terr = brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_MONITOR, &monitor);\n\tif (err) {\n\t\tbphy_err(drvr, \"BRCMF_C_GET_MONITOR error (%d)\\n\", err);\n\t\treturn err;\n\t} else if (monitor) {\n\t\tbphy_err(drvr, \"Monitor mode is already enabled\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\tmonitor = 3;\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_MONITOR, monitor);\n\tif (err)\n\t\tbphy_err(drvr, \"BRCMF_C_SET_MONITOR error (%d)\\n\", err);\n\n\treturn err;\n}\n\nstatic int brcmf_net_mon_stop(struct net_device *ndev)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tu32 monitor;\n\tint err;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tmonitor = 0;\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_MONITOR, monitor);\n\tif (err)\n\t\tbphy_err(drvr, \"BRCMF_C_SET_MONITOR error (%d)\\n\", err);\n\n\treturn err;\n}\n\nstatic netdev_tx_t brcmf_net_mon_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *ndev)\n{\n\tdev_kfree_skb_any(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic const struct net_device_ops brcmf_netdev_ops_mon = {\n\t.ndo_open = brcmf_net_mon_open,\n\t.ndo_stop = brcmf_net_mon_stop,\n\t.ndo_start_xmit = brcmf_net_mon_start_xmit,\n};\n\nint brcmf_net_mon_attach(struct brcmf_if *ifp)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct net_device *ndev;\n\tint err;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tndev = ifp->ndev;\n\tndev->netdev_ops = &brcmf_netdev_ops_mon;\n\n\terr = cfg80211_register_netdevice(ndev);\n\tif (err)\n\t\tbphy_err(drvr, \"Failed to register %s device\\n\", ndev->name);\n\n\treturn err;\n}\n\nvoid brcmf_net_setcarrier(struct brcmf_if *ifp, bool on)\n{\n\tstruct net_device *ndev;\n\n\tbrcmf_dbg(TRACE, \"Enter, bsscfgidx=%d carrier=%d\\n\", ifp->bsscfgidx,\n\t\t  on);\n\n\tndev = ifp->ndev;\n\tbrcmf_txflowblock_if(ifp, BRCMF_NETIF_STOP_REASON_DISCONNECTED, !on);\n\tif (on) {\n\t\tif (!netif_carrier_ok(ndev))\n\t\t\tnetif_carrier_on(ndev);\n\n\t} else {\n\t\tif (netif_carrier_ok(ndev))\n\t\t\tnetif_carrier_off(ndev);\n\t}\n}\n\nstatic int brcmf_net_p2p_open(struct net_device *ndev)\n{\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\treturn brcmf_cfg80211_up(ndev);\n}\n\nstatic int brcmf_net_p2p_stop(struct net_device *ndev)\n{\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\treturn brcmf_cfg80211_down(ndev);\n}\n\nstatic netdev_tx_t brcmf_net_p2p_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *ndev)\n{\n\tif (skb)\n\t\tdev_kfree_skb_any(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic const struct net_device_ops brcmf_netdev_ops_p2p = {\n\t.ndo_open = brcmf_net_p2p_open,\n\t.ndo_stop = brcmf_net_p2p_stop,\n\t.ndo_start_xmit = brcmf_net_p2p_start_xmit\n};\n\nstatic int brcmf_net_p2p_attach(struct brcmf_if *ifp)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct net_device *ndev;\n\n\tbrcmf_dbg(TRACE, \"Enter, bsscfgidx=%d mac=%pM\\n\", ifp->bsscfgidx,\n\t\t  ifp->mac_addr);\n\tndev = ifp->ndev;\n\n\tndev->netdev_ops = &brcmf_netdev_ops_p2p;\n\n\t \n\teth_hw_addr_set(ndev, ifp->mac_addr);\n\n\tif (register_netdev(ndev) != 0) {\n\t\tbphy_err(drvr, \"couldn't register the p2p net device\\n\");\n\t\tgoto fail;\n\t}\n\n\tbrcmf_dbg(INFO, \"%s: Broadcom Dongle Host Driver\\n\", ndev->name);\n\n\treturn 0;\n\nfail:\n\tifp->drvr->iflist[ifp->bsscfgidx] = NULL;\n\tndev->netdev_ops = NULL;\n\treturn -EBADE;\n}\n\nstruct brcmf_if *brcmf_add_if(struct brcmf_pub *drvr, s32 bsscfgidx, s32 ifidx,\n\t\t\t      bool is_p2pdev, const char *name, u8 *mac_addr)\n{\n\tstruct brcmf_if *ifp;\n\tstruct net_device *ndev;\n\n\tbrcmf_dbg(TRACE, \"Enter, bsscfgidx=%d, ifidx=%d\\n\", bsscfgidx, ifidx);\n\n\tifp = drvr->iflist[bsscfgidx];\n\t \n\tif (ifp) {\n\t\tif (ifidx) {\n\t\t\tbphy_err(drvr, \"ERROR: netdev:%s already exists\\n\",\n\t\t\t\t ifp->ndev->name);\n\t\t\tnetif_stop_queue(ifp->ndev);\n\t\t\tbrcmf_net_detach(ifp->ndev, false);\n\t\t\tdrvr->iflist[bsscfgidx] = NULL;\n\t\t} else {\n\t\t\tbrcmf_dbg(INFO, \"netdev:%s ignore IF event\\n\",\n\t\t\t\t  ifp->ndev->name);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\tif (!drvr->settings->p2p_enable && is_p2pdev) {\n\t\t \n\t\tbrcmf_dbg(INFO, \"allocate non-netdev interface\\n\");\n\t\tifp = kzalloc(sizeof(*ifp), GFP_KERNEL);\n\t\tif (!ifp)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t} else {\n\t\tbrcmf_dbg(INFO, \"allocate netdev interface\\n\");\n\t\t \n\t\tndev = alloc_netdev(sizeof(*ifp), is_p2pdev ? \"p2p%d\" : name,\n\t\t\t\t    NET_NAME_UNKNOWN, ether_setup);\n\t\tif (!ndev)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tndev->needs_free_netdev = true;\n\t\tifp = netdev_priv(ndev);\n\t\tifp->ndev = ndev;\n\t\t \n\t\tif (drvr->if2bss[ifidx] == BRCMF_BSSIDX_INVALID)\n\t\t\tdrvr->if2bss[ifidx] = bsscfgidx;\n\t}\n\n\tifp->drvr = drvr;\n\tdrvr->iflist[bsscfgidx] = ifp;\n\tifp->ifidx = ifidx;\n\tifp->bsscfgidx = bsscfgidx;\n\n\tinit_waitqueue_head(&ifp->pend_8021x_wait);\n\tspin_lock_init(&ifp->netif_stop_lock);\n\n\tif (mac_addr != NULL)\n\t\tmemcpy(ifp->mac_addr, mac_addr, ETH_ALEN);\n\n\tbrcmf_dbg(TRACE, \" ==== pid:%x, if:%s (%pM) created ===\\n\",\n\t\t  current->pid, name, ifp->mac_addr);\n\n\treturn ifp;\n}\n\nstatic void brcmf_del_if(struct brcmf_pub *drvr, s32 bsscfgidx,\n\t\t\t bool locked)\n{\n\tstruct brcmf_if *ifp;\n\tint ifidx;\n\n\tifp = drvr->iflist[bsscfgidx];\n\tif (!ifp) {\n\t\tbphy_err(drvr, \"Null interface, bsscfgidx=%d\\n\", bsscfgidx);\n\t\treturn;\n\t}\n\tbrcmf_dbg(TRACE, \"Enter, bsscfgidx=%d, ifidx=%d\\n\", bsscfgidx,\n\t\t  ifp->ifidx);\n\tifidx = ifp->ifidx;\n\n\tif (ifp->ndev) {\n\t\tif (bsscfgidx == 0) {\n\t\t\tif (ifp->ndev->netdev_ops == &brcmf_netdev_ops_pri) {\n\t\t\t\trtnl_lock();\n\t\t\t\tbrcmf_netdev_stop(ifp->ndev);\n\t\t\t\trtnl_unlock();\n\t\t\t}\n\t\t} else {\n\t\t\tnetif_stop_queue(ifp->ndev);\n\t\t}\n\n\t\tif (ifp->ndev->netdev_ops == &brcmf_netdev_ops_pri) {\n\t\t\tcancel_work_sync(&ifp->multicast_work);\n\t\t\tcancel_work_sync(&ifp->ndoffload_work);\n\t\t}\n\t\tbrcmf_net_detach(ifp->ndev, locked);\n\t} else {\n\t\t \n\t\tbrcmf_p2p_ifp_removed(ifp, locked);\n\t\tkfree(ifp);\n\t}\n\n\tdrvr->iflist[bsscfgidx] = NULL;\n\tif (drvr->if2bss[ifidx] == bsscfgidx)\n\t\tdrvr->if2bss[ifidx] = BRCMF_BSSIDX_INVALID;\n}\n\nvoid brcmf_remove_interface(struct brcmf_if *ifp, bool locked)\n{\n\tif (!ifp || WARN_ON(ifp->drvr->iflist[ifp->bsscfgidx] != ifp))\n\t\treturn;\n\tbrcmf_dbg(TRACE, \"Enter, bsscfgidx=%d, ifidx=%d\\n\", ifp->bsscfgidx,\n\t\t  ifp->ifidx);\n\tbrcmf_proto_del_if(ifp->drvr, ifp);\n\tbrcmf_del_if(ifp->drvr, ifp->bsscfgidx, locked);\n}\n\nstatic int brcmf_psm_watchdog_notify(struct brcmf_if *ifp,\n\t\t\t\t     const struct brcmf_event_msg *evtmsg,\n\t\t\t\t     void *data)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tint err;\n\n\tbrcmf_dbg(TRACE, \"enter: bsscfgidx=%d\\n\", ifp->bsscfgidx);\n\n\tbphy_err(drvr, \"PSM's watchdog has fired!\\n\");\n\n\terr = brcmf_debug_create_memdump(ifp->drvr->bus_if, data,\n\t\t\t\t\t evtmsg->datalen);\n\tif (err)\n\t\tbphy_err(drvr, \"Failed to get memory dump, %d\\n\", err);\n\n\treturn err;\n}\n\n#ifdef CONFIG_INET\n#define ARPOL_MAX_ENTRIES\t8\nstatic int brcmf_inetaddr_changed(struct notifier_block *nb,\n\t\t\t\t  unsigned long action, void *data)\n{\n\tstruct brcmf_pub *drvr = container_of(nb, struct brcmf_pub,\n\t\t\t\t\t      inetaddr_notifier);\n\tstruct in_ifaddr *ifa = data;\n\tstruct net_device *ndev = ifa->ifa_dev->dev;\n\tstruct brcmf_if *ifp;\n\tint idx, i, ret;\n\tu32 val;\n\t__be32 addr_table[ARPOL_MAX_ENTRIES] = {0};\n\n\t \n\tfor (idx = 0; idx < BRCMF_MAX_IFS; idx++) {\n\t\tifp = drvr->iflist[idx];\n\t\tif (ifp && ifp->ndev == ndev)\n\t\t\tbreak;\n\t\tif (idx == BRCMF_MAX_IFS - 1)\n\t\t\treturn NOTIFY_DONE;\n\t}\n\n\t \n\tret = brcmf_fil_iovar_int_get(ifp, \"arpoe\", &val);\n\tif (ret)\n\t\treturn NOTIFY_OK;\n\n\t \n\tret = brcmf_fil_iovar_int_get(ifp, \"arp_version\", &val);\n\tif (ret)\n\t\tval = 1;\n\tif (val == 1)\n\t\tifp = drvr->iflist[0];\n\n\t \n\tret = brcmf_fil_iovar_data_get(ifp, \"arp_hostip\", addr_table,\n\t\t\t\t       sizeof(addr_table));\n\tif (ret) {\n\t\tbphy_err(drvr, \"fail to get arp ip table err:%d\\n\", ret);\n\t\treturn NOTIFY_OK;\n\t}\n\n\tfor (i = 0; i < ARPOL_MAX_ENTRIES; i++)\n\t\tif (ifa->ifa_address == addr_table[i])\n\t\t\tbreak;\n\n\tswitch (action) {\n\tcase NETDEV_UP:\n\t\tif (i == ARPOL_MAX_ENTRIES) {\n\t\t\tbrcmf_dbg(TRACE, \"add %pI4 to arp table\\n\",\n\t\t\t\t  &ifa->ifa_address);\n\t\t\t \n\t\t\tret = brcmf_fil_iovar_data_set(ifp, \"arp_hostip\",\n\t\t\t\t&ifa->ifa_address, sizeof(ifa->ifa_address));\n\t\t\tif (ret)\n\t\t\t\tbphy_err(drvr, \"add arp ip err %d\\n\", ret);\n\t\t}\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tif (i < ARPOL_MAX_ENTRIES) {\n\t\t\taddr_table[i] = 0;\n\t\t\tbrcmf_dbg(TRACE, \"remove %pI4 from arp table\\n\",\n\t\t\t\t  &ifa->ifa_address);\n\t\t\t \n\t\t\tret = brcmf_fil_iovar_data_set(ifp, \"arp_hostip_clear\",\n\t\t\t\t\t\t       NULL, 0);\n\t\t\tif (ret) {\n\t\t\t\tbphy_err(drvr, \"fail to clear arp ip table err:%d\\n\",\n\t\t\t\t\t ret);\n\t\t\t\treturn NOTIFY_OK;\n\t\t\t}\n\t\t\tfor (i = 0; i < ARPOL_MAX_ENTRIES; i++) {\n\t\t\t\tif (addr_table[i] == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tret = brcmf_fil_iovar_data_set(ifp, \"arp_hostip\",\n\t\t\t\t\t\t\t       &addr_table[i],\n\t\t\t\t\t\t\t       sizeof(addr_table[i]));\n\t\t\t\tif (ret)\n\t\t\t\t\tbphy_err(drvr, \"add arp ip err %d\\n\",\n\t\t\t\t\t\t ret);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n}\n#endif\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int brcmf_inet6addr_changed(struct notifier_block *nb,\n\t\t\t\t   unsigned long action, void *data)\n{\n\tstruct brcmf_pub *drvr = container_of(nb, struct brcmf_pub,\n\t\t\t\t\t      inet6addr_notifier);\n\tstruct inet6_ifaddr *ifa = data;\n\tstruct brcmf_if *ifp;\n\tint i;\n\tstruct in6_addr *table;\n\n\t \n\tifp = drvr->iflist[0];\n\tif (!ifp)\n\t\treturn NOTIFY_DONE;\n\tif (ifp->ndev != ifa->idev->dev)\n\t\treturn NOTIFY_DONE;\n\n\ttable = ifp->ipv6_addr_tbl;\n\tfor (i = 0; i < NDOL_MAX_ENTRIES; i++)\n\t\tif (ipv6_addr_equal(&ifa->addr, &table[i]))\n\t\t\tbreak;\n\n\tswitch (action) {\n\tcase NETDEV_UP:\n\t\tif (i == NDOL_MAX_ENTRIES) {\n\t\t\tif (ifp->ipv6addr_idx < NDOL_MAX_ENTRIES) {\n\t\t\t\ttable[ifp->ipv6addr_idx++] = ifa->addr;\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < NDOL_MAX_ENTRIES - 1; i++)\n\t\t\t\t\ttable[i] = table[i + 1];\n\t\t\t\ttable[NDOL_MAX_ENTRIES - 1] = ifa->addr;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tif (i < NDOL_MAX_ENTRIES) {\n\t\t\tfor (; i < ifp->ipv6addr_idx - 1; i++)\n\t\t\t\ttable[i] = table[i + 1];\n\t\t\tmemset(&table[i], 0, sizeof(table[i]));\n\t\t\tifp->ipv6addr_idx--;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tschedule_work(&ifp->ndoffload_work);\n\n\treturn NOTIFY_OK;\n}\n#endif\n\nstatic int brcmf_revinfo_read(struct seq_file *s, void *data)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(s->private);\n\tstruct brcmf_rev_info *ri = &bus_if->drvr->revinfo;\n\tchar drev[BRCMU_DOTREV_LEN];\n\tchar brev[BRCMU_BOARDREV_LEN];\n\n\tseq_printf(s, \"vendorid: 0x%04x\\n\", ri->vendorid);\n\tseq_printf(s, \"deviceid: 0x%04x\\n\", ri->deviceid);\n\tseq_printf(s, \"radiorev: %s\\n\", brcmu_dotrev_str(ri->radiorev, drev));\n\tseq_printf(s, \"chip: %s (%s)\\n\", ri->chipname,\n\t\t   brcmf_fwvid_vendor_name(bus_if->drvr));\n\tseq_printf(s, \"chippkg: %u\\n\", ri->chippkg);\n\tseq_printf(s, \"corerev: %u\\n\", ri->corerev);\n\tseq_printf(s, \"boardid: 0x%04x\\n\", ri->boardid);\n\tseq_printf(s, \"boardvendor: 0x%04x\\n\", ri->boardvendor);\n\tseq_printf(s, \"boardrev: %s\\n\", brcmu_boardrev_str(ri->boardrev, brev));\n\tseq_printf(s, \"driverrev: %s\\n\", brcmu_dotrev_str(ri->driverrev, drev));\n\tseq_printf(s, \"ucoderev: %u\\n\", ri->ucoderev);\n\tseq_printf(s, \"bus: %u\\n\", ri->bus);\n\tseq_printf(s, \"phytype: %u\\n\", ri->phytype);\n\tseq_printf(s, \"phyrev: %u\\n\", ri->phyrev);\n\tseq_printf(s, \"anarev: %u\\n\", ri->anarev);\n\tseq_printf(s, \"nvramrev: %08x\\n\", ri->nvramrev);\n\n\tseq_printf(s, \"clmver: %s\\n\", bus_if->drvr->clmver);\n\n\treturn 0;\n}\n\nstatic void brcmf_core_bus_reset(struct work_struct *work)\n{\n\tstruct brcmf_pub *drvr = container_of(work, struct brcmf_pub,\n\t\t\t\t\t      bus_reset);\n\n\tbrcmf_bus_reset(drvr->bus_if);\n}\n\nstatic ssize_t bus_reset_write(struct file *file, const char __user *user_buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct brcmf_pub *drvr = file->private_data;\n\tu8 value;\n\n\tif (kstrtou8_from_user(user_buf, count, 0, &value))\n\t\treturn -EINVAL;\n\n\tif (value != 1)\n\t\treturn -EINVAL;\n\n\tschedule_work(&drvr->bus_reset);\n\n\treturn count;\n}\n\nstatic const struct file_operations bus_reset_fops = {\n\t.open\t= simple_open,\n\t.llseek\t= no_llseek,\n\t.write\t= bus_reset_write,\n};\n\nstatic int brcmf_bus_started(struct brcmf_pub *drvr, struct cfg80211_ops *ops)\n{\n\tint ret = -1;\n\tstruct brcmf_bus *bus_if = drvr->bus_if;\n\tstruct brcmf_if *ifp;\n\tstruct brcmf_if *p2p_ifp;\n\n\tbrcmf_dbg(TRACE, \"\\n\");\n\n\t \n\tifp = brcmf_add_if(drvr, 0, 0, false, \"wlan%d\",\n\t\t\t   is_valid_ether_addr(drvr->settings->mac) ? drvr->settings->mac : NULL);\n\tif (IS_ERR(ifp))\n\t\treturn PTR_ERR(ifp);\n\n\tp2p_ifp = NULL;\n\n\t \n\tbrcmf_bus_change_state(bus_if, BRCMF_BUS_UP);\n\n\t \n\tret = brcmf_bus_preinit(bus_if);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\t \n\tret = brcmf_c_preinit_dcmds(ifp);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tbrcmf_feat_attach(drvr);\n\n\tret = brcmf_proto_init_done(drvr);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tbrcmf_proto_add_if(drvr, ifp);\n\n\tdrvr->config = brcmf_cfg80211_attach(drvr, ops,\n\t\t\t\t\t     drvr->settings->p2p_enable);\n\tif (drvr->config == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tret = brcmf_net_attach(ifp, false);\n\n\tif ((!ret) && (drvr->settings->p2p_enable)) {\n\t\tp2p_ifp = drvr->iflist[1];\n\t\tif (p2p_ifp)\n\t\t\tret = brcmf_net_p2p_attach(p2p_ifp);\n\t}\n\n\tif (ret)\n\t\tgoto fail;\n\n#ifdef CONFIG_INET\n\tdrvr->inetaddr_notifier.notifier_call = brcmf_inetaddr_changed;\n\tret = register_inetaddr_notifier(&drvr->inetaddr_notifier);\n\tif (ret)\n\t\tgoto fail;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tdrvr->inet6addr_notifier.notifier_call = brcmf_inet6addr_changed;\n\tret = register_inet6addr_notifier(&drvr->inet6addr_notifier);\n\tif (ret) {\n\t\tunregister_inetaddr_notifier(&drvr->inetaddr_notifier);\n\t\tgoto fail;\n\t}\n#endif\n#endif  \n\n\tINIT_WORK(&drvr->bus_reset, brcmf_core_bus_reset);\n\n\t \n\tbrcmf_debugfs_add_entry(drvr, \"revinfo\", brcmf_revinfo_read);\n\tdebugfs_create_file(\"reset\", 0600, brcmf_debugfs_get_devdir(drvr), drvr,\n\t\t\t    &bus_reset_fops);\n\tbrcmf_feat_debugfs_create(drvr);\n\tbrcmf_proto_debugfs_create(drvr);\n\tbrcmf_bus_debugfs_create(bus_if);\n\n\treturn 0;\n\nfail:\n\tbphy_err(drvr, \"failed: %d\\n\", ret);\n\tif (drvr->config) {\n\t\tbrcmf_cfg80211_detach(drvr->config);\n\t\tdrvr->config = NULL;\n\t}\n\tbrcmf_net_detach(ifp->ndev, false);\n\tif (p2p_ifp)\n\t\tbrcmf_net_detach(p2p_ifp->ndev, false);\n\tdrvr->iflist[0] = NULL;\n\tdrvr->iflist[1] = NULL;\n\tif (drvr->settings->ignore_probe_fail)\n\t\tret = 0;\n\n\treturn ret;\n}\n\nint brcmf_alloc(struct device *dev, struct brcmf_mp_device *settings)\n{\n\tstruct wiphy *wiphy;\n\tstruct cfg80211_ops *ops;\n\tstruct brcmf_pub *drvr = NULL;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tops = brcmf_cfg80211_get_ops(settings);\n\tif (!ops)\n\t\treturn -ENOMEM;\n\n\twiphy = wiphy_new(ops, sizeof(*drvr));\n\tif (!wiphy) {\n\t\tkfree(ops);\n\t\treturn -ENOMEM;\n\t}\n\n\tset_wiphy_dev(wiphy, dev);\n\tdrvr = wiphy_priv(wiphy);\n\tdrvr->wiphy = wiphy;\n\tdrvr->ops = ops;\n\tdrvr->bus_if = dev_get_drvdata(dev);\n\tdrvr->bus_if->drvr = drvr;\n\tdrvr->settings = settings;\n\n\treturn 0;\n}\n\nint brcmf_attach(struct device *dev)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_pub *drvr = bus_if->drvr;\n\tint ret = 0;\n\tint i;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(drvr->if2bss); i++)\n\t\tdrvr->if2bss[i] = BRCMF_BSSIDX_INVALID;\n\n\tmutex_init(&drvr->proto_block);\n\n\t \n\tdrvr->hdrlen = 0;\n\n\tret = brcmf_fwvid_attach(drvr);\n\tif (ret != 0) {\n\t\tbphy_err(drvr, \"brcmf_fwvid_attach failed\\n\");\n\t\tgoto fail;\n\t}\n\n\t \n\tret = brcmf_proto_attach(drvr);\n\tif (ret != 0) {\n\t\tbphy_err(drvr, \"brcmf_prot_attach failed\\n\");\n\t\tgoto fail;\n\t}\n\n\t \n\tbrcmf_fweh_register(drvr, BRCMF_E_PSM_WATCHDOG,\n\t\t\t    brcmf_psm_watchdog_notify);\n\n\t \n\tbrcmf_fweh_attach(drvr);\n\n\tret = brcmf_bus_started(drvr, drvr->ops);\n\tif (ret != 0) {\n\t\tbphy_err(drvr, \"dongle is not responding: err=%d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tbrcmf_detach(dev);\n\n\treturn ret;\n}\n\nvoid brcmf_bus_add_txhdrlen(struct device *dev, uint len)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_pub *drvr = bus_if->drvr;\n\n\tif (drvr) {\n\t\tdrvr->hdrlen += len;\n\t}\n}\n\nvoid brcmf_dev_reset(struct device *dev)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_pub *drvr = bus_if->drvr;\n\n\tif (drvr == NULL)\n\t\treturn;\n\n\tif (drvr->iflist[0])\n\t\tbrcmf_fil_cmd_int_set(drvr->iflist[0], BRCMF_C_TERMINATED, 1);\n}\n\nvoid brcmf_dev_coredump(struct device *dev)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\n\tif (brcmf_debug_create_memdump(bus_if, NULL, 0) < 0)\n\t\tbrcmf_dbg(TRACE, \"failed to create coredump\\n\");\n}\n\nvoid brcmf_fw_crashed(struct device *dev)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_pub *drvr = bus_if->drvr;\n\n\tbphy_err(drvr, \"Firmware has halted or crashed\\n\");\n\n\tbrcmf_dev_coredump(dev);\n\n\tif (drvr->bus_reset.func)\n\t\tschedule_work(&drvr->bus_reset);\n}\n\nvoid brcmf_detach(struct device *dev)\n{\n\ts32 i;\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_pub *drvr = bus_if->drvr;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tif (drvr == NULL)\n\t\treturn;\n\n#ifdef CONFIG_INET\n\tunregister_inetaddr_notifier(&drvr->inetaddr_notifier);\n#endif\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tunregister_inet6addr_notifier(&drvr->inet6addr_notifier);\n#endif\n\n\tbrcmf_bus_change_state(bus_if, BRCMF_BUS_DOWN);\n\t \n\tfor (i = BRCMF_MAX_IFS - 1; i > -1; i--) {\n\t\tif (drvr->iflist[i])\n\t\t\tbrcmf_remove_interface(drvr->iflist[i], false);\n\t}\n\tbrcmf_bus_stop(drvr->bus_if);\n\n\tbrcmf_fweh_detach(drvr);\n\tbrcmf_proto_detach(drvr);\n\n\tif (drvr->mon_if) {\n\t\tbrcmf_net_detach(drvr->mon_if->ndev, false);\n\t\tdrvr->mon_if = NULL;\n\t}\n\n\tif (drvr->config) {\n\t\tbrcmf_p2p_detach(&drvr->config->p2p);\n\t\tbrcmf_cfg80211_detach(drvr->config);\n\t\tdrvr->config = NULL;\n\t}\n\n\tbrcmf_fwvid_detach(drvr);\n}\n\nvoid brcmf_free(struct device *dev)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_pub *drvr = bus_if->drvr;\n\n\tif (!drvr)\n\t\treturn;\n\n\tbus_if->drvr = NULL;\n\n\tkfree(drvr->ops);\n\n\twiphy_free(drvr->wiphy);\n}\n\ns32 brcmf_iovar_data_set(struct device *dev, char *name, void *data, u32 len)\n{\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_if *ifp = bus_if->drvr->iflist[0];\n\n\treturn brcmf_fil_iovar_data_set(ifp, name, data, len);\n}\n\nstatic int brcmf_get_pend_8021x_cnt(struct brcmf_if *ifp)\n{\n\treturn atomic_read(&ifp->pend_8021x_cnt);\n}\n\nint brcmf_netdev_wait_pend8021x(struct brcmf_if *ifp)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tint err;\n\n\terr = wait_event_timeout(ifp->pend_8021x_wait,\n\t\t\t\t !brcmf_get_pend_8021x_cnt(ifp),\n\t\t\t\t MAX_WAIT_FOR_8021X_TX);\n\n\tif (!err) {\n\t\tbphy_err(drvr, \"Timed out waiting for no pending 802.1x packets\\n\");\n\t\tatomic_set(&ifp->pend_8021x_cnt, 0);\n\t}\n\n\treturn !err;\n}\n\nvoid brcmf_bus_change_state(struct brcmf_bus *bus, enum brcmf_bus_state state)\n{\n\tstruct brcmf_pub *drvr = bus->drvr;\n\tstruct net_device *ndev;\n\tint ifidx;\n\n\tbrcmf_dbg(TRACE, \"%d -> %d\\n\", bus->state, state);\n\n\tif (!drvr) {\n\t\tbrcmf_dbg(INFO, \"ignoring transition, bus not attached yet\\n\");\n\t\treturn;\n\t}\n\n\tbus->state = state;\n\n\tif (state == BRCMF_BUS_UP) {\n\t\tfor (ifidx = 0; ifidx < BRCMF_MAX_IFS; ifidx++) {\n\t\t\tif ((drvr->iflist[ifidx]) &&\n\t\t\t    (drvr->iflist[ifidx]->ndev)) {\n\t\t\t\tndev = drvr->iflist[ifidx]->ndev;\n\t\t\t\tif (netif_queue_stopped(ndev))\n\t\t\t\t\tnetif_wake_queue(ndev);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint __init brcmf_core_init(void)\n{\n\tint err;\n\n\terr = brcmf_sdio_register();\n\tif (err)\n\t\treturn err;\n\n\terr = brcmf_usb_register();\n\tif (err)\n\t\tgoto error_usb_register;\n\n\terr = brcmf_pcie_register();\n\tif (err)\n\t\tgoto error_pcie_register;\n\treturn 0;\n\nerror_pcie_register:\n\tbrcmf_usb_exit();\nerror_usb_register:\n\tbrcmf_sdio_exit();\n\treturn err;\n}\n\nvoid __exit brcmf_core_exit(void)\n{\n\tbrcmf_sdio_exit();\n\tbrcmf_usb_exit();\n\tbrcmf_pcie_exit();\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}