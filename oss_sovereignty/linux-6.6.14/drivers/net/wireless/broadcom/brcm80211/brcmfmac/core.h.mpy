{
  "module_name": "core.h",
  "hash_id": "718a6573d9de2ca025770d044755408cd1a2fd20e951e84f369cdd91c1f4ec72",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h",
  "human_readable_source": "\n \n\n \n\n#ifndef BRCMFMAC_CORE_H\n#define BRCMFMAC_CORE_H\n\n#include <net/cfg80211.h>\n#include \"fweh.h\"\n\n#if IS_MODULE(CONFIG_BRCMFMAC)\n#define BRCMF_EXPORT_SYMBOL_GPL(__sym)\tEXPORT_SYMBOL_NS_GPL(__sym, BRCMFMAC)\n#else\n#define BRCMF_EXPORT_SYMBOL_GPL(__sym)\n#endif\n\n#define TOE_TX_CSUM_OL\t\t0x00000001\n#define TOE_RX_CSUM_OL\t\t0x00000002\n\n \n#define BRCMF_MAX_IFS\t16\n\n \n#define BRCMF_DCMD_SMLEN\t256\n#define BRCMF_DCMD_MEDLEN\t1536\n#define BRCMF_DCMD_MAXLEN\t8192\n\n \n#define BRCMF_TX_IOCTL_MAX_MSG_SIZE\t(ETH_FRAME_LEN+ETH_FCS_LEN)\n\n#define BRCMF_AMPDU_RX_REORDER_MAXFLOWS\t\t256\n\n \n#define BRCMF_DRIVER_FIRMWARE_VERSION_LEN\t32\n\n#define NDOL_MAX_ENTRIES\t8\n\n \nstruct brcmf_ampdu_rx_reorder {\n\tstruct sk_buff **pktslots;\n\tu8 flow_id;\n\tu8 cur_idx;\n\tu8 exp_idx;\n\tu8 max_idx;\n\tu8 pend_pkts;\n};\n\n \nstruct brcmf_proto;\t \nstruct brcmf_fws_info;\t \nstruct brcmf_mp_device;\t \n\n \nstruct brcmf_rev_info {\n\tint result;\n\tu32 vendorid;\n\tu32 deviceid;\n\tu32 radiorev;\n\tu32 corerev;\n\tu32 boardid;\n\tu32 boardvendor;\n\tu32 boardrev;\n\tu32 driverrev;\n\tu32 ucoderev;\n\tu32 bus;\n\tchar chipname[12];\n\tu32 phytype;\n\tu32 phyrev;\n\tu32 anarev;\n\tu32 chippkg;\n\tu32 nvramrev;\n};\n\n \nstruct brcmf_pub {\n\t \n\tstruct brcmf_bus *bus_if;\n\tstruct brcmf_proto *proto;\n\tstruct wiphy *wiphy;\n\tstruct cfg80211_ops *ops;\n\tstruct brcmf_cfg80211_info *config;\n\n\t \n\tuint hdrlen;\t\t \n\n\t \n\tchar fwver[BRCMF_DRIVER_FIRMWARE_VERSION_LEN];\n\tu8 mac[ETH_ALEN];\t\t \n\n\tstruct mac_address addresses[BRCMF_MAX_IFS];\n\n\tstruct brcmf_if *iflist[BRCMF_MAX_IFS];\n\ts32 if2bss[BRCMF_MAX_IFS];\n\tstruct brcmf_if *mon_if;\n\n\tstruct mutex proto_block;\n\tunsigned char proto_buf[BRCMF_DCMD_MAXLEN];\n\n\tstruct brcmf_fweh_info fweh;\n\n\tstruct brcmf_ampdu_rx_reorder\n\t\t*reorder_flows[BRCMF_AMPDU_RX_REORDER_MAXFLOWS];\n\n\tu32 feat_flags;\n\tu32 chip_quirks;\n\n\tstruct brcmf_rev_info revinfo;\n#ifdef DEBUG\n\tstruct dentry *dbgfs_dir;\n#endif\n\n\tstruct notifier_block inetaddr_notifier;\n\tstruct notifier_block inet6addr_notifier;\n\tstruct brcmf_mp_device *settings;\n\n\tstruct work_struct bus_reset;\n\n\tu8 clmver[BRCMF_DCMD_SMLEN];\n\tu8 sta_mac_idx;\n\tconst struct brcmf_fwvid_ops *vops;\n\tvoid *vdata;\n};\n\n \nstruct brcmf_cfg80211_vif;\nstruct brcmf_fws_mac_descriptor;\n\n \nenum brcmf_netif_stop_reason {\n\tBRCMF_NETIF_STOP_REASON_FWS_FC = BIT(0),\n\tBRCMF_NETIF_STOP_REASON_FLOW = BIT(1),\n\tBRCMF_NETIF_STOP_REASON_DISCONNECTED = BIT(2)\n};\n\n \nstruct brcmf_if {\n\tstruct brcmf_pub *drvr;\n\tstruct brcmf_cfg80211_vif *vif;\n\tstruct net_device *ndev;\n\tstruct work_struct multicast_work;\n\tstruct work_struct ndoffload_work;\n\tstruct brcmf_fws_mac_descriptor *fws_desc;\n\tint ifidx;\n\ts32 bsscfgidx;\n\tu8 mac_addr[ETH_ALEN];\n\tu8 netif_stop;\n\tspinlock_t netif_stop_lock;\n\tatomic_t pend_8021x_cnt;\n\twait_queue_head_t pend_8021x_wait;\n\tstruct in6_addr ipv6_addr_tbl[NDOL_MAX_ENTRIES];\n\tu8 ipv6addr_idx;\n\tbool fwil_fwerr;\n};\n\nint brcmf_netdev_wait_pend8021x(struct brcmf_if *ifp);\n\n \nchar *brcmf_ifname(struct brcmf_if *ifp);\nstruct brcmf_if *brcmf_get_ifp(struct brcmf_pub *drvr, int ifidx);\nvoid brcmf_configure_arp_nd_offload(struct brcmf_if *ifp, bool enable);\nint brcmf_net_attach(struct brcmf_if *ifp, bool locked);\nstruct brcmf_if *brcmf_add_if(struct brcmf_pub *drvr, s32 bsscfgidx, s32 ifidx,\n\t\t\t      bool is_p2pdev, const char *name, u8 *mac_addr);\nvoid brcmf_remove_interface(struct brcmf_if *ifp, bool locked);\nvoid brcmf_txflowblock_if(struct brcmf_if *ifp,\n\t\t\t  enum brcmf_netif_stop_reason reason, bool state);\nvoid brcmf_txfinalize(struct brcmf_if *ifp, struct sk_buff *txp, bool success);\nvoid brcmf_netif_rx(struct brcmf_if *ifp, struct sk_buff *skb);\nvoid brcmf_netif_mon_rx(struct brcmf_if *ifp, struct sk_buff *skb);\nvoid brcmf_net_detach(struct net_device *ndev, bool locked);\nint brcmf_net_mon_attach(struct brcmf_if *ifp);\nvoid brcmf_net_setcarrier(struct brcmf_if *ifp, bool on);\nint __init brcmf_core_init(void);\nvoid __exit brcmf_core_exit(void);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}