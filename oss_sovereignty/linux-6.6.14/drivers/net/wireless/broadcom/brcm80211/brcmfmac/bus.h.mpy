{
  "module_name": "bus.h",
  "hash_id": "88487bb15eb2eb2cea2fe266e87872f03224a4b79d1399465e7861527aa912b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bus.h",
  "human_readable_source": "\n \n\n#ifndef BRCMFMAC_BUS_H\n#define BRCMFMAC_BUS_H\n\n#include <linux/kernel.h>\n#include <linux/firmware.h>\n#include <linux/device.h>\n#include \"debug.h\"\n\n \n#define BRCMF_H2D_MSGRING_CONTROL_SUBMIT\t0\n#define BRCMF_H2D_MSGRING_RXPOST_SUBMIT\t\t1\n#define BRCMF_H2D_MSGRING_FLOWRING_IDSTART\t2\n#define BRCMF_D2H_MSGRING_CONTROL_COMPLETE\t2\n#define BRCMF_D2H_MSGRING_TX_COMPLETE\t\t3\n#define BRCMF_D2H_MSGRING_RX_COMPLETE\t\t4\n\n\n#define BRCMF_NROF_H2D_COMMON_MSGRINGS\t\t2\n#define BRCMF_NROF_D2H_COMMON_MSGRINGS\t\t3\n#define BRCMF_NROF_COMMON_MSGRINGS\t(BRCMF_NROF_H2D_COMMON_MSGRINGS + \\\n\t\t\t\t\t BRCMF_NROF_D2H_COMMON_MSGRINGS)\n\n \n#define BRCMF_CONSOLE\t10\n\n \n#define MAX_CONSOLE_INTERVAL\t(5 * 60)\n\nenum brcmf_fwvendor {\n\tBRCMF_FWVENDOR_WCC,\n\tBRCMF_FWVENDOR_CYW,\n\tBRCMF_FWVENDOR_BCA,\n\t \n\tBRCMF_FWVENDOR_NUM,\n\tBRCMF_FWVENDOR_INVALID\n};\n\n \nenum brcmf_bus_state {\n\tBRCMF_BUS_DOWN,\t\t \n\tBRCMF_BUS_UP\t\t \n};\n\n \nenum brcmf_bus_protocol_type {\n\tBRCMF_PROTO_BCDC,\n\tBRCMF_PROTO_MSGBUF\n};\n\n \nenum brcmf_blob_type {\n\tBRCMF_BLOB_CLM,\n\tBRCMF_BLOB_TXCAP,\n};\n\nstruct brcmf_mp_device;\n\nstruct brcmf_bus_dcmd {\n\tchar *name;\n\tchar *param;\n\tint param_len;\n\tstruct list_head list;\n};\n\n \nstruct brcmf_bus_ops {\n\tint (*preinit)(struct device *dev);\n\tvoid (*stop)(struct device *dev);\n\tint (*txdata)(struct device *dev, struct sk_buff *skb);\n\tint (*txctl)(struct device *dev, unsigned char *msg, uint len);\n\tint (*rxctl)(struct device *dev, unsigned char *msg, uint len);\n\tstruct pktq * (*gettxq)(struct device *dev);\n\tvoid (*wowl_config)(struct device *dev, bool enabled);\n\tsize_t (*get_ramsize)(struct device *dev);\n\tint (*get_memdump)(struct device *dev, void *data, size_t len);\n\tint (*get_blob)(struct device *dev, const struct firmware **fw,\n\t\t\tenum brcmf_blob_type type);\n\tvoid (*debugfs_create)(struct device *dev);\n\tint (*reset)(struct device *dev);\n\tvoid (*remove)(struct device *dev);\n};\n\n\n \nstruct brcmf_bus_msgbuf {\n\tstruct brcmf_commonring *commonrings[BRCMF_NROF_COMMON_MSGRINGS];\n\tstruct brcmf_commonring **flowrings;\n\tu32 rx_dataoffset;\n\tu32 max_rxbufpost;\n\tu16 max_flowrings;\n\tu16 max_submissionrings;\n\tu16 max_completionrings;\n};\n\n\n \nstruct brcmf_bus_stats {\n\tatomic_t pktcowed;\n\tatomic_t pktcow_failed;\n};\n\n \nstruct brcmf_bus {\n\tunion {\n\t\tstruct brcmf_sdio_dev *sdio;\n\t\tstruct brcmf_usbdev *usb;\n\t\tstruct brcmf_pciedev *pcie;\n\t} bus_priv;\n\tenum brcmf_bus_protocol_type proto_type;\n\tstruct device *dev;\n\tstruct brcmf_pub *drvr;\n\tenum brcmf_bus_state state;\n\tstruct brcmf_bus_stats stats;\n\tuint maxctl;\n\tu32 chip;\n\tu32 chiprev;\n\tenum brcmf_fwvendor fwvid;\n\tbool always_use_fws_queue;\n\tbool wowl_supported;\n\n\tconst struct brcmf_bus_ops *ops;\n\tstruct brcmf_bus_msgbuf *msgbuf;\n\n\tstruct list_head list;\n};\n\n \nstatic inline int brcmf_bus_preinit(struct brcmf_bus *bus)\n{\n\tif (!bus->ops->preinit)\n\t\treturn 0;\n\treturn bus->ops->preinit(bus->dev);\n}\n\nstatic inline void brcmf_bus_stop(struct brcmf_bus *bus)\n{\n\tbus->ops->stop(bus->dev);\n}\n\nstatic inline int brcmf_bus_txdata(struct brcmf_bus *bus, struct sk_buff *skb)\n{\n\treturn bus->ops->txdata(bus->dev, skb);\n}\n\nstatic inline\nint brcmf_bus_txctl(struct brcmf_bus *bus, unsigned char *msg, uint len)\n{\n\treturn bus->ops->txctl(bus->dev, msg, len);\n}\n\nstatic inline\nint brcmf_bus_rxctl(struct brcmf_bus *bus, unsigned char *msg, uint len)\n{\n\treturn bus->ops->rxctl(bus->dev, msg, len);\n}\n\nstatic inline\nstruct pktq *brcmf_bus_gettxq(struct brcmf_bus *bus)\n{\n\tif (!bus->ops->gettxq)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn bus->ops->gettxq(bus->dev);\n}\n\nstatic inline\nvoid brcmf_bus_wowl_config(struct brcmf_bus *bus, bool enabled)\n{\n\tif (bus->ops->wowl_config)\n\t\tbus->ops->wowl_config(bus->dev, enabled);\n}\n\nstatic inline size_t brcmf_bus_get_ramsize(struct brcmf_bus *bus)\n{\n\tif (!bus->ops->get_ramsize)\n\t\treturn 0;\n\n\treturn bus->ops->get_ramsize(bus->dev);\n}\n\nstatic inline\nint brcmf_bus_get_memdump(struct brcmf_bus *bus, void *data, size_t len)\n{\n\tif (!bus->ops->get_memdump)\n\t\treturn -EOPNOTSUPP;\n\n\treturn bus->ops->get_memdump(bus->dev, data, len);\n}\n\nstatic inline\nint brcmf_bus_get_blob(struct brcmf_bus *bus, const struct firmware **fw,\n\t\t       enum brcmf_blob_type type)\n{\n\treturn bus->ops->get_blob(bus->dev, fw, type);\n}\n\nstatic inline\nvoid brcmf_bus_debugfs_create(struct brcmf_bus *bus)\n{\n\tif (!bus->ops->debugfs_create)\n\t\treturn;\n\n\treturn bus->ops->debugfs_create(bus->dev);\n}\n\nstatic inline\nint brcmf_bus_reset(struct brcmf_bus *bus)\n{\n\tif (!bus->ops->reset)\n\t\treturn -EOPNOTSUPP;\n\n\treturn bus->ops->reset(bus->dev);\n}\n\nstatic inline void brcmf_bus_remove(struct brcmf_bus *bus)\n{\n\tif (!bus->ops->remove) {\n\t\tdevice_release_driver(bus->dev);\n\t\treturn;\n\t}\n\n\tbus->ops->remove(bus->dev);\n}\n\n \n\n \nvoid brcmf_rx_frame(struct device *dev, struct sk_buff *rxp, bool handle_event,\n\t\t    bool inirq);\n \nvoid brcmf_rx_event(struct device *dev, struct sk_buff *rxp);\n\nint brcmf_alloc(struct device *dev, struct brcmf_mp_device *settings);\n \nint brcmf_attach(struct device *dev);\n \nvoid brcmf_detach(struct device *dev);\nvoid brcmf_free(struct device *dev);\n \nvoid brcmf_dev_reset(struct device *dev);\n \nvoid brcmf_dev_coredump(struct device *dev);\n \nvoid brcmf_fw_crashed(struct device *dev);\n\n \nvoid brcmf_bus_change_state(struct brcmf_bus *bus, enum brcmf_bus_state state);\n\ns32 brcmf_iovar_data_set(struct device *dev, char *name, void *data, u32 len);\nvoid brcmf_bus_add_txhdrlen(struct device *dev, uint len);\n\n#ifdef CONFIG_BRCMFMAC_SDIO\nvoid brcmf_sdio_exit(void);\nint brcmf_sdio_register(void);\n#else\nstatic inline void brcmf_sdio_exit(void) { }\nstatic inline int brcmf_sdio_register(void) { return 0; }\n#endif\n\n#ifdef CONFIG_BRCMFMAC_USB\nvoid brcmf_usb_exit(void);\nint brcmf_usb_register(void);\n#else\nstatic inline void brcmf_usb_exit(void) { }\nstatic inline int brcmf_usb_register(void) { return 0; }\n#endif\n\n#ifdef CONFIG_BRCMFMAC_PCIE\nvoid brcmf_pcie_exit(void);\nint brcmf_pcie_register(void);\n#else\nstatic inline void brcmf_pcie_exit(void) { }\nstatic inline int brcmf_pcie_register(void) { return 0; }\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}