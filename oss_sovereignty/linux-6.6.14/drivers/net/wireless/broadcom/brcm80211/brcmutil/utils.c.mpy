{
  "module_name": "utils.c",
  "hash_id": "b5986ce1f2c5042a8834001bc00ad1acfc893f32148e26ba27830b1fba3c756c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/brcmutil/utils.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/netdevice.h>\n#include <linux/module.h>\n\n#include <brcmu_utils.h>\n\nMODULE_AUTHOR(\"Broadcom Corporation\");\nMODULE_DESCRIPTION(\"Broadcom 802.11n wireless LAN driver utilities.\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\nstruct sk_buff *brcmu_pkt_buf_get_skb(uint len)\n{\n\tstruct sk_buff *skb;\n\n\tskb = dev_alloc_skb(len);\n\tif (skb) {\n\t\tskb_put(skb, len);\n\t\tskb->priority = 0;\n\t}\n\n\treturn skb;\n}\nEXPORT_SYMBOL(brcmu_pkt_buf_get_skb);\n\n \nvoid brcmu_pkt_buf_free_skb(struct sk_buff *skb)\n{\n\tif (!skb)\n\t\treturn;\n\n\tWARN_ON(skb->next);\n\tdev_kfree_skb_any(skb);\n}\nEXPORT_SYMBOL(brcmu_pkt_buf_free_skb);\n\n \nstruct sk_buff *brcmu_pktq_penq(struct pktq *pq, int prec,\n\t\t\t\t      struct sk_buff *p)\n{\n\tstruct sk_buff_head *q;\n\n\tif (pktq_full(pq) || pktq_pfull(pq, prec))\n\t\treturn NULL;\n\n\tq = &pq->q[prec].skblist;\n\tskb_queue_tail(q, p);\n\tpq->len++;\n\n\tif (pq->hi_prec < prec)\n\t\tpq->hi_prec = (u8) prec;\n\n\treturn p;\n}\nEXPORT_SYMBOL(brcmu_pktq_penq);\n\nstruct sk_buff *brcmu_pktq_penq_head(struct pktq *pq, int prec,\n\t\t\t\t\t   struct sk_buff *p)\n{\n\tstruct sk_buff_head *q;\n\n\tif (pktq_full(pq) || pktq_pfull(pq, prec))\n\t\treturn NULL;\n\n\tq = &pq->q[prec].skblist;\n\tskb_queue_head(q, p);\n\tpq->len++;\n\n\tif (pq->hi_prec < prec)\n\t\tpq->hi_prec = (u8) prec;\n\n\treturn p;\n}\nEXPORT_SYMBOL(brcmu_pktq_penq_head);\n\nstruct sk_buff *brcmu_pktq_pdeq(struct pktq *pq, int prec)\n{\n\tstruct sk_buff_head *q;\n\tstruct sk_buff *p;\n\n\tq = &pq->q[prec].skblist;\n\tp = skb_dequeue(q);\n\tif (p == NULL)\n\t\treturn NULL;\n\n\tpq->len--;\n\treturn p;\n}\nEXPORT_SYMBOL(brcmu_pktq_pdeq);\n\n \nstruct sk_buff *brcmu_pktq_pdeq_match(struct pktq *pq, int prec,\n\t\t\t\t      bool (*match_fn)(struct sk_buff *skb,\n\t\t\t\t\t\t       void *arg), void *arg)\n{\n\tstruct sk_buff_head *q;\n\tstruct sk_buff *p, *next;\n\n\tq = &pq->q[prec].skblist;\n\tskb_queue_walk_safe(q, p, next) {\n\t\tif (match_fn == NULL || match_fn(p, arg)) {\n\t\t\tskb_unlink(p, q);\n\t\t\tpq->len--;\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(brcmu_pktq_pdeq_match);\n\nstruct sk_buff *brcmu_pktq_pdeq_tail(struct pktq *pq, int prec)\n{\n\tstruct sk_buff_head *q;\n\tstruct sk_buff *p;\n\n\tq = &pq->q[prec].skblist;\n\tp = skb_dequeue_tail(q);\n\tif (p == NULL)\n\t\treturn NULL;\n\n\tpq->len--;\n\treturn p;\n}\nEXPORT_SYMBOL(brcmu_pktq_pdeq_tail);\n\nvoid\nbrcmu_pktq_pflush(struct pktq *pq, int prec, bool dir,\n\t\t  bool (*fn)(struct sk_buff *, void *), void *arg)\n{\n\tstruct sk_buff_head *q;\n\tstruct sk_buff *p, *next;\n\n\tq = &pq->q[prec].skblist;\n\tskb_queue_walk_safe(q, p, next) {\n\t\tif (fn == NULL || (*fn) (p, arg)) {\n\t\t\tskb_unlink(p, q);\n\t\t\tbrcmu_pkt_buf_free_skb(p);\n\t\t\tpq->len--;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(brcmu_pktq_pflush);\n\nvoid brcmu_pktq_flush(struct pktq *pq, bool dir,\n\t\t      bool (*fn)(struct sk_buff *, void *), void *arg)\n{\n\tint prec;\n\tfor (prec = 0; prec < pq->num_prec; prec++)\n\t\tbrcmu_pktq_pflush(pq, prec, dir, fn, arg);\n}\nEXPORT_SYMBOL(brcmu_pktq_flush);\n\nvoid brcmu_pktq_init(struct pktq *pq, int num_prec, int max_len)\n{\n\tint prec;\n\n\t \n\tmemset(pq, 0,\n\t      offsetof(struct pktq, q) + (sizeof(struct pktq_prec) * num_prec));\n\n\tpq->num_prec = (u16) num_prec;\n\n\tpq->max = (u16) max_len;\n\n\tfor (prec = 0; prec < num_prec; prec++) {\n\t\tpq->q[prec].max = pq->max;\n\t\tskb_queue_head_init(&pq->q[prec].skblist);\n\t}\n}\nEXPORT_SYMBOL(brcmu_pktq_init);\n\nstruct sk_buff *brcmu_pktq_peek_tail(struct pktq *pq, int *prec_out)\n{\n\tint prec;\n\n\tif (pktq_empty(pq))\n\t\treturn NULL;\n\n\tfor (prec = 0; prec < pq->hi_prec; prec++)\n\t\tif (!skb_queue_empty(&pq->q[prec].skblist))\n\t\t\tbreak;\n\n\tif (prec_out)\n\t\t*prec_out = prec;\n\n\treturn skb_peek_tail(&pq->q[prec].skblist);\n}\nEXPORT_SYMBOL(brcmu_pktq_peek_tail);\n\n \nint brcmu_pktq_mlen(struct pktq *pq, uint prec_bmp)\n{\n\tint prec, len;\n\n\tlen = 0;\n\n\tfor (prec = 0; prec <= pq->hi_prec; prec++)\n\t\tif (prec_bmp & (1 << prec))\n\t\t\tlen += pq->q[prec].skblist.qlen;\n\n\treturn len;\n}\nEXPORT_SYMBOL(brcmu_pktq_mlen);\n\n \nstruct sk_buff *brcmu_pktq_mdeq(struct pktq *pq, uint prec_bmp,\n\t\t\t\t      int *prec_out)\n{\n\tstruct sk_buff_head *q;\n\tstruct sk_buff *p;\n\tint prec;\n\n\tif (pktq_empty(pq))\n\t\treturn NULL;\n\n\twhile ((prec = pq->hi_prec) > 0 &&\n\t       skb_queue_empty(&pq->q[prec].skblist))\n\t\tpq->hi_prec--;\n\n\twhile ((prec_bmp & (1 << prec)) == 0 ||\n\t       skb_queue_empty(&pq->q[prec].skblist))\n\t\tif (prec-- == 0)\n\t\t\treturn NULL;\n\n\tq = &pq->q[prec].skblist;\n\tp = skb_dequeue(q);\n\tif (p == NULL)\n\t\treturn NULL;\n\n\tpq->len--;\n\n\tif (prec_out)\n\t\t*prec_out = prec;\n\n\treturn p;\n}\nEXPORT_SYMBOL(brcmu_pktq_mdeq);\n\n \nchar *brcmu_boardrev_str(u32 brev, char *buf)\n{\n\tchar c;\n\n\tif (brev < 0x100) {\n\t\tsnprintf(buf, BRCMU_BOARDREV_LEN, \"%d.%d\",\n\t\t\t (brev & 0xf0) >> 4, brev & 0xf);\n\t} else {\n\t\tc = (brev & 0xf000) == 0x1000 ? 'P' : 'A';\n\t\tsnprintf(buf, BRCMU_BOARDREV_LEN, \"%c%03x\", c, brev & 0xfff);\n\t}\n\treturn buf;\n}\nEXPORT_SYMBOL(brcmu_boardrev_str);\n\nchar *brcmu_dotrev_str(u32 dotrev, char *buf)\n{\n\tu8 dotval[4];\n\n\tif (!dotrev) {\n\t\tsnprintf(buf, BRCMU_DOTREV_LEN, \"unknown\");\n\t\treturn buf;\n\t}\n\tdotval[0] = (dotrev >> 24) & 0xFF;\n\tdotval[1] = (dotrev >> 16) & 0xFF;\n\tdotval[2] = (dotrev >> 8) & 0xFF;\n\tdotval[3] = dotrev & 0xFF;\n\n\tif (dotval[3])\n\t\tsnprintf(buf, BRCMU_DOTREV_LEN, \"%d.%d.%d.%d\", dotval[0],\n\t\t\tdotval[1], dotval[2], dotval[3]);\n\telse if (dotval[2])\n\t\tsnprintf(buf, BRCMU_DOTREV_LEN, \"%d.%d.%d\", dotval[0],\n\t\t\tdotval[1], dotval[2]);\n\telse\n\t\tsnprintf(buf, BRCMU_DOTREV_LEN, \"%d.%d\", dotval[0],\n\t\t\tdotval[1]);\n\n\treturn buf;\n}\nEXPORT_SYMBOL(brcmu_dotrev_str);\n\n#if defined(DEBUG)\n \nvoid brcmu_prpkt(const char *msg, struct sk_buff *p0)\n{\n\tstruct sk_buff *p;\n\n\tif (msg && (msg[0] != '\\0'))\n\t\tpr_debug(\"%s:\\n\", msg);\n\n\tfor (p = p0; p; p = p->next)\n\t\tprint_hex_dump_bytes(\"\", DUMP_PREFIX_OFFSET, p->data, p->len);\n}\nEXPORT_SYMBOL(brcmu_prpkt);\n\nvoid brcmu_dbg_hex_dump(const void *data, size_t size, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_debug(\"%pV\", &vaf);\n\n\tva_end(args);\n\n\tprint_hex_dump_bytes(\"\", DUMP_PREFIX_OFFSET, data, size);\n}\nEXPORT_SYMBOL(brcmu_dbg_hex_dump);\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}