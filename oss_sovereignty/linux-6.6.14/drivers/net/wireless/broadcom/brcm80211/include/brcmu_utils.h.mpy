{
  "module_name": "brcmu_utils.h",
  "hash_id": "508123acc96af11cb172d8a1fb863369a526f35c4584ce30d3df70f9f3018e8b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/brcm80211/include/brcmu_utils.h",
  "human_readable_source": "\n \n\n#ifndef\t_BRCMU_UTILS_H_\n#define\t_BRCMU_UTILS_H_\n\n#include <linux/skbuff.h>\n\n \n#define SPINWAIT(exp, us) { \\\n\tuint countdown = (us) + 9; \\\n\twhile ((exp) && (countdown >= 10)) {\\\n\t\tudelay(10); \\\n\t\tcountdown -= 10; \\\n\t} \\\n}\n\n \n#define PKTQ_LEN_DEFAULT        128\t \n#define PKTQ_MAX_PREC           16\t \n\n#define BCME_STRLEN\t\t64\t \n\n \n#define\tPKTBUFSZ\t2048\n\n#ifndef setbit\n#ifndef NBBY\t\t\t \n#define\tNBBY\t8\t\t \n#endif\t\t\t\t \n#define\tsetbit(a, i)\t(((u8 *)a)[(i)/NBBY] |= 1<<((i)%NBBY))\n#define\tclrbit(a, i)\t(((u8 *)a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))\n#define\tisset(a, i)\t(((const u8 *)a)[(i)/NBBY] & (1<<((i)%NBBY)))\n#define\tisclr(a, i)\t((((const u8 *)a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)\n#endif\t\t\t\t \n\n#define\tNBITS(type)\t(sizeof(type) * 8)\n#define NBITVAL(nbits)\t(1 << (nbits))\n#define MAXBITVAL(nbits)\t((1 << (nbits)) - 1)\n#define\tNBITMASK(nbits)\tMAXBITVAL(nbits)\n#define MAXNBVAL(nbyte)\tMAXBITVAL((nbyte) * 8)\n\n \n#define CRC16_INIT_VALUE 0xffff\t \n#define CRC16_GOOD_VALUE 0xf0b8\t \n\n \n#define ETHER_ADDR_STR_LEN\t18\n\nstruct pktq_prec {\n\tstruct sk_buff_head skblist;\n\tu16 max;\t\t \n};\n\n \nstruct pktq {\n\tu16 num_prec;\t \n\tu16 hi_prec;\t \n\tu16 max;\t \n\tu16 len;\t \n\t \n\tstruct pktq_prec q[PKTQ_MAX_PREC];\n};\n\n \n\nstatic inline int pktq_plen(struct pktq *pq, int prec)\n{\n\treturn pq->q[prec].skblist.qlen;\n}\n\nstatic inline int pktq_pavail(struct pktq *pq, int prec)\n{\n\treturn pq->q[prec].max - pq->q[prec].skblist.qlen;\n}\n\nstatic inline bool pktq_pfull(struct pktq *pq, int prec)\n{\n\treturn pq->q[prec].skblist.qlen >= pq->q[prec].max;\n}\n\nstatic inline bool pktq_pempty(struct pktq *pq, int prec)\n{\n\treturn skb_queue_empty(&pq->q[prec].skblist);\n}\n\nstatic inline struct sk_buff *pktq_ppeek(struct pktq *pq, int prec)\n{\n\treturn skb_peek(&pq->q[prec].skblist);\n}\n\nstatic inline struct sk_buff *pktq_ppeek_tail(struct pktq *pq, int prec)\n{\n\treturn skb_peek_tail(&pq->q[prec].skblist);\n}\n\nstruct sk_buff *brcmu_pktq_penq(struct pktq *pq, int prec, struct sk_buff *p);\nstruct sk_buff *brcmu_pktq_penq_head(struct pktq *pq, int prec,\n\t\t\t\t     struct sk_buff *p);\nstruct sk_buff *brcmu_pktq_pdeq(struct pktq *pq, int prec);\nstruct sk_buff *brcmu_pktq_pdeq_tail(struct pktq *pq, int prec);\nstruct sk_buff *brcmu_pktq_pdeq_match(struct pktq *pq, int prec,\n\t\t\t\t      bool (*match_fn)(struct sk_buff *p,\n\t\t\t\t\t\t       void *arg),\n\t\t\t\t      void *arg);\n\n \nstruct sk_buff *brcmu_pkt_buf_get_skb(uint len);\nvoid brcmu_pkt_buf_free_skb(struct sk_buff *skb);\n\n \n \nvoid brcmu_pktq_pflush(struct pktq *pq, int prec, bool dir,\n\t\t       bool (*fn)(struct sk_buff *, void *), void *arg);\n\n \n\nint brcmu_pktq_mlen(struct pktq *pq, uint prec_bmp);\nstruct sk_buff *brcmu_pktq_mdeq(struct pktq *pq, uint prec_bmp, int *prec_out);\n\n \n\nstatic inline int pktq_len(struct pktq *pq)\n{\n\treturn (int)pq->len;\n}\n\nstatic inline int pktq_max(struct pktq *pq)\n{\n\treturn (int)pq->max;\n}\n\nstatic inline int pktq_avail(struct pktq *pq)\n{\n\treturn (int)(pq->max - pq->len);\n}\n\nstatic inline bool pktq_full(struct pktq *pq)\n{\n\treturn pq->len >= pq->max;\n}\n\nstatic inline bool pktq_empty(struct pktq *pq)\n{\n\treturn pq->len == 0;\n}\n\nvoid brcmu_pktq_init(struct pktq *pq, int num_prec, int max_len);\n \nstruct sk_buff *brcmu_pktq_peek_tail(struct pktq *pq, int *prec_out);\nvoid brcmu_pktq_flush(struct pktq *pq, bool dir,\n\t\t      bool (*fn)(struct sk_buff *, void *), void *arg);\n\n \n \nstruct ipv4_addr;\n\n \nstatic inline void brcmu_maskset32(u32 *var, u32 mask, u8 shift, u32 value)\n{\n\tvalue = (value << shift) & mask;\n\t*var = (*var & ~mask) | value;\n}\nstatic inline u32 brcmu_maskget32(u32 var, u32 mask, u8 shift)\n{\n\treturn (var & mask) >> shift;\n}\nstatic inline void brcmu_maskset16(u16 *var, u16 mask, u8 shift, u16 value)\n{\n\tvalue = (value << shift) & mask;\n\t*var = (*var & ~mask) | value;\n}\nstatic inline u16 brcmu_maskget16(u16 var, u16 mask, u8 shift)\n{\n\treturn (var & mask) >> shift;\n}\n\n \n \n#ifdef DEBUG\nvoid brcmu_prpkt(const char *msg, struct sk_buff *p0);\n#else\n#define brcmu_prpkt(a, b)\n#endif\t\t\t\t \n\n#ifdef DEBUG\n__printf(3, 4)\nvoid brcmu_dbg_hex_dump(const void *data, size_t size, const char *fmt, ...);\n#else\n__printf(3, 4)\nstatic inline\nvoid brcmu_dbg_hex_dump(const void *data, size_t size, const char *fmt, ...)\n{\n}\n#endif\n\n#define BRCMU_BOARDREV_LEN\t8\n#define BRCMU_DOTREV_LEN\t16\n\nchar *brcmu_boardrev_str(u32 brev, char *buf);\nchar *brcmu_dotrev_str(u32 dotrev, char *buf);\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}