{
  "module_name": "sdio.c",
  "hash_id": "3fb43e4b780fa8711a43498c521e98509efe1674a797c4a852a3a5f3c4f57db3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/b43/sdio.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/sdio_func.h>\n#include <linux/mmc/sdio_ids.h>\n#include <linux/slab.h>\n#include <linux/ssb/ssb.h>\n\n#include \"sdio.h\"\n#include \"b43.h\"\n\n\n#define HNBU_CHIPID\t\t0x01\t \n\n#define B43_SDIO_BLOCK_SIZE\t64\t \n\n\nstatic const struct b43_sdio_quirk {\n\tu16 vendor;\n\tu16 device;\n\tunsigned int quirks;\n} b43_sdio_quirks[] = {\n\t{ 0x14E4, 0x4318, SSB_QUIRK_SDIO_READ_AFTER_WRITE32, },\n\t{ },\n};\n\n\nstatic unsigned int b43_sdio_get_quirks(u16 vendor, u16 device)\n{\n\tconst struct b43_sdio_quirk *q;\n\n\tfor (q = b43_sdio_quirks; q->quirks; q++) {\n\t\tif (vendor == q->vendor && device == q->device)\n\t\t\treturn q->quirks;\n\t}\n\n\treturn 0;\n}\n\nstatic void b43_sdio_interrupt_dispatcher(struct sdio_func *func)\n{\n\tstruct b43_sdio *sdio = sdio_get_drvdata(func);\n\tstruct b43_wldev *dev = sdio->irq_handler_opaque;\n\n\tif (unlikely(b43_status(dev) < B43_STAT_STARTED))\n\t\treturn;\n\n\tsdio_release_host(func);\n\tsdio->irq_handler(dev);\n\tsdio_claim_host(func);\n}\n\nint b43_sdio_request_irq(struct b43_wldev *dev,\n\t\t\t void (*handler)(struct b43_wldev *dev))\n{\n\tstruct ssb_bus *bus = dev->dev->sdev->bus;\n\tstruct sdio_func *func = bus->host_sdio;\n\tstruct b43_sdio *sdio = sdio_get_drvdata(func);\n\tint err;\n\n\tsdio->irq_handler_opaque = dev;\n\tsdio->irq_handler = handler;\n\tsdio_claim_host(func);\n\terr = sdio_claim_irq(func, b43_sdio_interrupt_dispatcher);\n\tsdio_release_host(func);\n\n\treturn err;\n}\n\nvoid b43_sdio_free_irq(struct b43_wldev *dev)\n{\n\tstruct ssb_bus *bus = dev->dev->sdev->bus;\n\tstruct sdio_func *func = bus->host_sdio;\n\tstruct b43_sdio *sdio = sdio_get_drvdata(func);\n\n\tsdio_claim_host(func);\n\tsdio_release_irq(func);\n\tsdio_release_host(func);\n\tsdio->irq_handler_opaque = NULL;\n\tsdio->irq_handler = NULL;\n}\n\nstatic int b43_sdio_probe(struct sdio_func *func,\n\t\t\t\t    const struct sdio_device_id *id)\n{\n\tstruct b43_sdio *sdio;\n\tstruct sdio_func_tuple *tuple;\n\tu16 vendor = 0, device = 0;\n\tint error;\n\n\t \n\ttuple = func->tuples;\n\twhile (tuple) {\n\t\tswitch (tuple->code) {\n\t\tcase 0x80:\n\t\t\tswitch (tuple->data[0]) {\n\t\t\tcase HNBU_CHIPID:\n\t\t\t\tif (tuple->size != 5)\n\t\t\t\t\tbreak;\n\t\t\t\tvendor = tuple->data[1] | (tuple->data[2]<<8);\n\t\t\t\tdevice = tuple->data[3] | (tuple->data[4]<<8);\n\t\t\t\tdev_info(&func->dev, \"Chip ID %04x:%04x\\n\",\n\t\t\t\t\t vendor, device);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\ttuple = tuple->next;\n\t}\n\tif (!vendor || !device) {\n\t\terror = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tsdio_claim_host(func);\n\terror = sdio_set_block_size(func, B43_SDIO_BLOCK_SIZE);\n\tif (error) {\n\t\tdev_err(&func->dev, \"failed to set block size to %u bytes,\"\n\t\t\t\" error %d\\n\", B43_SDIO_BLOCK_SIZE, error);\n\t\tgoto err_release_host;\n\t}\n\terror = sdio_enable_func(func);\n\tif (error) {\n\t\tdev_err(&func->dev, \"failed to enable func, error %d\\n\", error);\n\t\tgoto err_release_host;\n\t}\n\tsdio_release_host(func);\n\n\tsdio = kzalloc(sizeof(*sdio), GFP_KERNEL);\n\tif (!sdio) {\n\t\terror = -ENOMEM;\n\t\tdev_err(&func->dev, \"failed to allocate ssb bus\\n\");\n\t\tgoto err_disable_func;\n\t}\n\terror = ssb_bus_sdiobus_register(&sdio->ssb, func,\n\t\t\t\t\t b43_sdio_get_quirks(vendor, device));\n\tif (error) {\n\t\tdev_err(&func->dev, \"failed to register ssb sdio bus,\"\n\t\t\t\" error %d\\n\", error);\n\t\tgoto err_free_ssb;\n\t}\n\tsdio_set_drvdata(func, sdio);\n\n\treturn 0;\n\nerr_free_ssb:\n\tkfree(sdio);\nerr_disable_func:\n\tsdio_claim_host(func);\n\tsdio_disable_func(func);\nerr_release_host:\n\tsdio_release_host(func);\nout:\n\treturn error;\n}\n\nstatic void b43_sdio_remove(struct sdio_func *func)\n{\n\tstruct b43_sdio *sdio = sdio_get_drvdata(func);\n\n\tssb_bus_unregister(&sdio->ssb);\n\tsdio_claim_host(func);\n\tsdio_disable_func(func);\n\tsdio_release_host(func);\n\tkfree(sdio);\n\tsdio_set_drvdata(func, NULL);\n}\n\nstatic const struct sdio_device_id b43_sdio_ids[] = {\n\t{ SDIO_DEVICE(SDIO_VENDOR_ID_BROADCOM, SDIO_DEVICE_ID_BROADCOM_NINTENDO_WII) },\n\t{ SDIO_DEVICE(SDIO_VENDOR_ID_CGUYS, SDIO_DEVICE_ID_CGUYS_EW_CG1102GC) },\n\t{ },\n};\n\nstatic struct sdio_driver b43_sdio_driver = {\n\t.name\t\t= \"b43-sdio\",\n\t.id_table\t= b43_sdio_ids,\n\t.probe\t\t= b43_sdio_probe,\n\t.remove\t\t= b43_sdio_remove,\n};\n\nint b43_sdio_init(void)\n{\n\treturn sdio_register_driver(&b43_sdio_driver);\n}\n\nvoid b43_sdio_exit(void)\n{\n\tsdio_unregister_driver(&b43_sdio_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}