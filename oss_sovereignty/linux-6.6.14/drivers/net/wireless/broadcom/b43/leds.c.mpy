{
  "module_name": "leds.c",
  "hash_id": "82112310954ca74b0ebdc3101fa1ed5dd25e29e85a2f66485af1578b757a4916",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/b43/leds.c",
  "human_readable_source": "\n \n\n#include \"b43.h\"\n#include \"leds.h\"\n#include \"rfkill.h\"\n\n\nstatic void b43_led_turn_on(struct b43_wldev *dev, u8 led_index,\n\t\t\t    bool activelow)\n{\n\tu16 ctl;\n\n\tctl = b43_read16(dev, B43_MMIO_GPIO_CONTROL);\n\tif (activelow)\n\t\tctl &= ~(1 << led_index);\n\telse\n\t\tctl |= (1 << led_index);\n\tb43_write16(dev, B43_MMIO_GPIO_CONTROL, ctl);\n}\n\nstatic void b43_led_turn_off(struct b43_wldev *dev, u8 led_index,\n\t\t\t     bool activelow)\n{\n\tu16 ctl;\n\n\tctl = b43_read16(dev, B43_MMIO_GPIO_CONTROL);\n\tif (activelow)\n\t\tctl |= (1 << led_index);\n\telse\n\t\tctl &= ~(1 << led_index);\n\tb43_write16(dev, B43_MMIO_GPIO_CONTROL, ctl);\n}\n\nstatic void b43_led_update(struct b43_wldev *dev,\n\t\t\t   struct b43_led *led)\n{\n\tbool radio_enabled;\n\tbool turn_on;\n\n\tif (!led->wl)\n\t\treturn;\n\n\tradio_enabled = (dev->phy.radio_on && dev->radio_hw_enable);\n\n\t \n\tif (radio_enabled)\n\t\tturn_on = atomic_read(&led->state) != LED_OFF;\n\telse\n\t\tturn_on = false;\n\tif (turn_on == led->hw_state)\n\t\treturn;\n\tled->hw_state = turn_on;\n\n\tif (turn_on)\n\t\tb43_led_turn_on(dev, led->index, led->activelow);\n\telse\n\t\tb43_led_turn_off(dev, led->index, led->activelow);\n}\n\nstatic void b43_leds_work(struct work_struct *work)\n{\n\tstruct b43_leds *leds = container_of(work, struct b43_leds, work);\n\tstruct b43_wl *wl = container_of(leds, struct b43_wl, leds);\n\tstruct b43_wldev *dev;\n\n\tmutex_lock(&wl->mutex);\n\tdev = wl->current_dev;\n\tif (unlikely(!dev || b43_status(dev) < B43_STAT_STARTED))\n\t\tgoto out_unlock;\n\n\tb43_led_update(dev, &wl->leds.led_tx);\n\tb43_led_update(dev, &wl->leds.led_rx);\n\tb43_led_update(dev, &wl->leds.led_radio);\n\tb43_led_update(dev, &wl->leds.led_assoc);\n\nout_unlock:\n\tmutex_unlock(&wl->mutex);\n}\n\n \nstatic void b43_led_brightness_set(struct led_classdev *led_dev,\n\t\t\t\t   enum led_brightness brightness)\n{\n\tstruct b43_led *led = container_of(led_dev, struct b43_led, led_dev);\n\tstruct b43_wl *wl = led->wl;\n\n\tif (likely(!wl->leds.stop)) {\n\t\tatomic_set(&led->state, brightness);\n\t\tieee80211_queue_work(wl->hw, &wl->leds.work);\n\t}\n}\n\nstatic int b43_register_led(struct b43_wldev *dev, struct b43_led *led,\n\t\t\t    const char *name, const char *default_trigger,\n\t\t\t    u8 led_index, bool activelow)\n{\n\tint err;\n\n\tif (led->wl)\n\t\treturn -EEXIST;\n\tif (!default_trigger)\n\t\treturn -EINVAL;\n\tled->wl = dev->wl;\n\tled->index = led_index;\n\tled->activelow = activelow;\n\tstrscpy(led->name, name, sizeof(led->name));\n\tatomic_set(&led->state, 0);\n\n\tled->led_dev.name = led->name;\n\tled->led_dev.default_trigger = default_trigger;\n\tled->led_dev.brightness_set = b43_led_brightness_set;\n\n\terr = led_classdev_register(dev->dev->dev, &led->led_dev);\n\tif (err) {\n\t\tb43warn(dev->wl, \"LEDs: Failed to register %s\\n\", name);\n\t\tled->wl = NULL;\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void b43_unregister_led(struct b43_led *led)\n{\n\tif (!led->wl)\n\t\treturn;\n\tled_classdev_unregister(&led->led_dev);\n\tled->wl = NULL;\n}\n\nstatic void b43_map_led(struct b43_wldev *dev,\n\t\t\tu8 led_index,\n\t\t\tenum b43_led_behaviour behaviour,\n\t\t\tbool activelow)\n{\n\tstruct ieee80211_hw *hw = dev->wl->hw;\n\tchar name[B43_LED_MAX_NAME_LEN + 1];\n\n\t \n\tswitch (behaviour) {\n\tcase B43_LED_INACTIVE:\n\tcase B43_LED_OFF:\n\tcase B43_LED_ON:\n\t\tbreak;\n\tcase B43_LED_ACTIVITY:\n\tcase B43_LED_TRANSFER:\n\tcase B43_LED_APTRANSFER:\n\t\tsnprintf(name, sizeof(name),\n\t\t\t \"b43-%s::tx\", wiphy_name(hw->wiphy));\n\t\tb43_register_led(dev, &dev->wl->leds.led_tx, name,\n\t\t\t\t ieee80211_get_tx_led_name(hw),\n\t\t\t\t led_index, activelow);\n\t\tsnprintf(name, sizeof(name),\n\t\t\t \"b43-%s::rx\", wiphy_name(hw->wiphy));\n\t\tb43_register_led(dev, &dev->wl->leds.led_rx, name,\n\t\t\t\t ieee80211_get_rx_led_name(hw),\n\t\t\t\t led_index, activelow);\n\t\tbreak;\n\tcase B43_LED_RADIO_ALL:\n\tcase B43_LED_RADIO_A:\n\tcase B43_LED_RADIO_B:\n\tcase B43_LED_MODE_BG:\n\t\tsnprintf(name, sizeof(name),\n\t\t\t \"b43-%s::radio\", wiphy_name(hw->wiphy));\n\t\tb43_register_led(dev, &dev->wl->leds.led_radio, name,\n\t\t\t\t ieee80211_get_radio_led_name(hw),\n\t\t\t\t led_index, activelow);\n\t\tbreak;\n\tcase B43_LED_WEIRD:\n\tcase B43_LED_ASSOC:\n\t\tsnprintf(name, sizeof(name),\n\t\t\t \"b43-%s::assoc\", wiphy_name(hw->wiphy));\n\t\tb43_register_led(dev, &dev->wl->leds.led_assoc, name,\n\t\t\t\t ieee80211_get_assoc_led_name(hw),\n\t\t\t\t led_index, activelow);\n\t\tbreak;\n\tdefault:\n\t\tb43warn(dev->wl, \"LEDs: Unknown behaviour 0x%02X\\n\",\n\t\t\tbehaviour);\n\t\tbreak;\n\t}\n}\n\nstatic void b43_led_get_sprominfo(struct b43_wldev *dev,\n\t\t\t\t  unsigned int led_index,\n\t\t\t\t  enum b43_led_behaviour *behaviour,\n\t\t\t\t  bool *activelow)\n{\n\tu8 sprom[4];\n\n\tsprom[0] = dev->dev->bus_sprom->gpio0;\n\tsprom[1] = dev->dev->bus_sprom->gpio1;\n\tsprom[2] = dev->dev->bus_sprom->gpio2;\n\tsprom[3] = dev->dev->bus_sprom->gpio3;\n\n\tif ((sprom[0] & sprom[1] & sprom[2] & sprom[3]) == 0xff) {\n\t\t \n\t\t*activelow = false;\n\t\tswitch (led_index) {\n\t\tcase 0:\n\t\t\t*behaviour = B43_LED_ACTIVITY;\n\t\t\t*activelow = true;\n\t\t\tif (dev->dev->board_vendor == PCI_VENDOR_ID_COMPAQ)\n\t\t\t\t*behaviour = B43_LED_RADIO_ALL;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t*behaviour = B43_LED_RADIO_B;\n\t\t\tif (dev->dev->board_vendor == PCI_VENDOR_ID_ASUSTEK)\n\t\t\t\t*behaviour = B43_LED_ASSOC;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*behaviour = B43_LED_RADIO_A;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t*behaviour = B43_LED_OFF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*behaviour = B43_LED_OFF;\n\t\t\tB43_WARN_ON(1);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t \n\t\tif (sprom[led_index] == 0xff)\n\t\t\t*behaviour = B43_LED_OFF;\n\t\telse\n\t\t\t*behaviour = sprom[led_index] & B43_LED_BEHAVIOUR;\n\t\t*activelow = !!(sprom[led_index] & B43_LED_ACTIVELOW);\n\t}\n}\n\nvoid b43_leds_init(struct b43_wldev *dev)\n{\n\tstruct b43_led *led;\n\tunsigned int i;\n\tenum b43_led_behaviour behaviour;\n\tbool activelow;\n\n\t \n\tled = &dev->wl->leds.led_radio;\n\tif (led->wl) {\n\t\tif (dev->phy.radio_on && b43_is_hw_radio_enabled(dev)) {\n\t\t\tb43_led_turn_on(dev, led->index, led->activelow);\n\t\t\tled->hw_state = true;\n\t\t\tatomic_set(&led->state, 1);\n\t\t} else {\n\t\t\tb43_led_turn_off(dev, led->index, led->activelow);\n\t\t\tled->hw_state = false;\n\t\t\tatomic_set(&led->state, 0);\n\t\t}\n\t}\n\n\t \n\tled = &dev->wl->leds.led_tx;\n\tif (led->wl) {\n\t\tb43_led_turn_off(dev, led->index, led->activelow);\n\t\tled->hw_state = false;\n\t\tatomic_set(&led->state, 0);\n\t}\n\tled = &dev->wl->leds.led_rx;\n\tif (led->wl) {\n\t\tb43_led_turn_off(dev, led->index, led->activelow);\n\t\tled->hw_state = false;\n\t\tatomic_set(&led->state, 0);\n\t}\n\tled = &dev->wl->leds.led_assoc;\n\tif (led->wl) {\n\t\tb43_led_turn_off(dev, led->index, led->activelow);\n\t\tled->hw_state = false;\n\t\tatomic_set(&led->state, 0);\n\t}\n\n\t \n\tfor (i = 0; i < B43_MAX_NR_LEDS; i++) {\n\t\tb43_led_get_sprominfo(dev, i, &behaviour, &activelow);\n\t\tswitch (behaviour) {\n\t\tcase B43_LED_OFF:\n\t\t\tb43_led_turn_off(dev, i, activelow);\n\t\t\tbreak;\n\t\tcase B43_LED_ON:\n\t\t\tb43_led_turn_on(dev, i, activelow);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdev->wl->leds.stop = 0;\n}\n\nvoid b43_leds_exit(struct b43_wldev *dev)\n{\n\tstruct b43_leds *leds = &dev->wl->leds;\n\n\tb43_led_turn_off(dev, leds->led_tx.index, leds->led_tx.activelow);\n\tb43_led_turn_off(dev, leds->led_rx.index, leds->led_rx.activelow);\n\tb43_led_turn_off(dev, leds->led_assoc.index, leds->led_assoc.activelow);\n\tb43_led_turn_off(dev, leds->led_radio.index, leds->led_radio.activelow);\n}\n\nvoid b43_leds_stop(struct b43_wldev *dev)\n{\n\tstruct b43_leds *leds = &dev->wl->leds;\n\n\tleds->stop = 1;\n\tcancel_work_sync(&leds->work);\n}\n\nvoid b43_leds_register(struct b43_wldev *dev)\n{\n\tunsigned int i;\n\tenum b43_led_behaviour behaviour;\n\tbool activelow;\n\n\tINIT_WORK(&dev->wl->leds.work, b43_leds_work);\n\n\t \n\tfor (i = 0; i < B43_MAX_NR_LEDS; i++) {\n\t\tb43_led_get_sprominfo(dev, i, &behaviour, &activelow);\n\t\tb43_map_led(dev, i, behaviour, activelow);\n\t}\n}\n\nvoid b43_leds_unregister(struct b43_wl *wl)\n{\n\tstruct b43_leds *leds = &wl->leds;\n\n\tb43_unregister_led(&leds->led_tx);\n\tb43_unregister_led(&leds->led_rx);\n\tb43_unregister_led(&leds->led_assoc);\n\tb43_unregister_led(&leds->led_radio);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}