{
  "module_name": "main.c",
  "hash_id": "f64caa7eaea91ab040a627284236c1a3fb6a417a1fcb741183ceee1604675952",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/b43/main.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/if_arp.h>\n#include <linux/etherdevice.h>\n#include <linux/firmware.h>\n#include <linux/workqueue.h>\n#include <linux/skbuff.h>\n#include <linux/io.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n\n#include \"b43.h\"\n#include \"main.h\"\n#include \"debugfs.h\"\n#include \"phy_common.h\"\n#include \"phy_g.h\"\n#include \"phy_n.h\"\n#include \"dma.h\"\n#include \"pio.h\"\n#include \"sysfs.h\"\n#include \"xmit.h\"\n#include \"lo.h\"\n#include \"sdio.h\"\n#include <linux/mmc/sdio_func.h>\n\nMODULE_DESCRIPTION(\"Broadcom B43 wireless driver\");\nMODULE_AUTHOR(\"Martin Langer\");\nMODULE_AUTHOR(\"Stefano Brivio\");\nMODULE_AUTHOR(\"Michael Buesch\");\nMODULE_AUTHOR(\"G\u00e1bor Stefanik\");\nMODULE_AUTHOR(\"Rafa\u0142 Mi\u0142ecki\");\nMODULE_LICENSE(\"GPL\");\n\nMODULE_FIRMWARE(\"b43/ucode11.fw\");\nMODULE_FIRMWARE(\"b43/ucode13.fw\");\nMODULE_FIRMWARE(\"b43/ucode14.fw\");\nMODULE_FIRMWARE(\"b43/ucode15.fw\");\nMODULE_FIRMWARE(\"b43/ucode16_lp.fw\");\nMODULE_FIRMWARE(\"b43/ucode16_mimo.fw\");\nMODULE_FIRMWARE(\"b43/ucode24_lcn.fw\");\nMODULE_FIRMWARE(\"b43/ucode25_lcn.fw\");\nMODULE_FIRMWARE(\"b43/ucode25_mimo.fw\");\nMODULE_FIRMWARE(\"b43/ucode26_mimo.fw\");\nMODULE_FIRMWARE(\"b43/ucode29_mimo.fw\");\nMODULE_FIRMWARE(\"b43/ucode33_lcn40.fw\");\nMODULE_FIRMWARE(\"b43/ucode30_mimo.fw\");\nMODULE_FIRMWARE(\"b43/ucode5.fw\");\nMODULE_FIRMWARE(\"b43/ucode40.fw\");\nMODULE_FIRMWARE(\"b43/ucode42.fw\");\nMODULE_FIRMWARE(\"b43/ucode9.fw\");\n\nstatic int modparam_bad_frames_preempt;\nmodule_param_named(bad_frames_preempt, modparam_bad_frames_preempt, int, 0444);\nMODULE_PARM_DESC(bad_frames_preempt,\n\t\t \"enable(1) / disable(0) Bad Frames Preemption\");\n\nstatic char modparam_fwpostfix[16];\nmodule_param_string(fwpostfix, modparam_fwpostfix, 16, 0444);\nMODULE_PARM_DESC(fwpostfix, \"Postfix for the .fw files to load.\");\n\nstatic int modparam_hwpctl;\nmodule_param_named(hwpctl, modparam_hwpctl, int, 0444);\nMODULE_PARM_DESC(hwpctl, \"Enable hardware-side power control (default off)\");\n\nstatic int modparam_nohwcrypt;\nmodule_param_named(nohwcrypt, modparam_nohwcrypt, int, 0444);\nMODULE_PARM_DESC(nohwcrypt, \"Disable hardware encryption.\");\n\nstatic int modparam_hwtkip;\nmodule_param_named(hwtkip, modparam_hwtkip, int, 0444);\nMODULE_PARM_DESC(hwtkip, \"Enable hardware tkip.\");\n\nstatic int modparam_qos = 1;\nmodule_param_named(qos, modparam_qos, int, 0444);\nMODULE_PARM_DESC(qos, \"Enable QOS support (default on)\");\n\nstatic int modparam_btcoex = 1;\nmodule_param_named(btcoex, modparam_btcoex, int, 0444);\nMODULE_PARM_DESC(btcoex, \"Enable Bluetooth coexistence (default on)\");\n\nint b43_modparam_verbose = B43_VERBOSITY_DEFAULT;\nmodule_param_named(verbose, b43_modparam_verbose, int, 0644);\nMODULE_PARM_DESC(verbose, \"Log message verbosity: 0=error, 1=warn, 2=info(default), 3=debug\");\n\nstatic int b43_modparam_pio;\nmodule_param_named(pio, b43_modparam_pio, int, 0644);\nMODULE_PARM_DESC(pio, \"Use PIO accesses by default: 0=DMA, 1=PIO\");\n\nstatic int modparam_allhwsupport = !IS_ENABLED(CONFIG_BRCMSMAC);\nmodule_param_named(allhwsupport, modparam_allhwsupport, int, 0444);\nMODULE_PARM_DESC(allhwsupport, \"Enable support for all hardware (even it if overlaps with the brcmsmac driver)\");\n\n#ifdef CONFIG_B43_BCMA\nstatic const struct bcma_device_id b43_bcma_tbl[] = {\n\tBCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_80211, 0x11, BCMA_ANY_CLASS),\n\tBCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_80211, 0x15, BCMA_ANY_CLASS),\n\tBCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_80211, 0x17, BCMA_ANY_CLASS),\n\tBCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_80211, 0x18, BCMA_ANY_CLASS),\n\tBCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_80211, 0x1C, BCMA_ANY_CLASS),\n\tBCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_80211, 0x1D, BCMA_ANY_CLASS),\n\tBCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_80211, 0x1E, BCMA_ANY_CLASS),\n\tBCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_80211, 0x28, BCMA_ANY_CLASS),\n\tBCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_80211, 0x2A, BCMA_ANY_CLASS),\n\t{},\n};\nMODULE_DEVICE_TABLE(bcma, b43_bcma_tbl);\n#endif\n\n#ifdef CONFIG_B43_SSB\nstatic const struct ssb_device_id b43_ssb_tbl[] = {\n\tSSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 5),\n\tSSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 6),\n\tSSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 7),\n\tSSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 9),\n\tSSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 10),\n\tSSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 11),\n\tSSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 12),\n\tSSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 13),\n\tSSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 15),\n\tSSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_80211, 16),\n\t{},\n};\nMODULE_DEVICE_TABLE(ssb, b43_ssb_tbl);\n#endif\n\n \n#define RATETAB_ENT(_rateid, _flags) \\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.bitrate\t= B43_RATE_TO_BASE100KBPS(_rateid),\t\\\n\t\t.hw_value\t= (_rateid),\t\t\t\t\\\n\t\t.flags\t\t= (_flags),\t\t\t\t\\\n\t}\n\n \nstatic struct ieee80211_rate __b43_ratetable[] = {\n\tRATETAB_ENT(B43_CCK_RATE_1MB, 0),\n\tRATETAB_ENT(B43_CCK_RATE_2MB, IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATETAB_ENT(B43_CCK_RATE_5MB, IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATETAB_ENT(B43_CCK_RATE_11MB, IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATETAB_ENT(B43_OFDM_RATE_6MB, 0),\n\tRATETAB_ENT(B43_OFDM_RATE_9MB, 0),\n\tRATETAB_ENT(B43_OFDM_RATE_12MB, 0),\n\tRATETAB_ENT(B43_OFDM_RATE_18MB, 0),\n\tRATETAB_ENT(B43_OFDM_RATE_24MB, 0),\n\tRATETAB_ENT(B43_OFDM_RATE_36MB, 0),\n\tRATETAB_ENT(B43_OFDM_RATE_48MB, 0),\n\tRATETAB_ENT(B43_OFDM_RATE_54MB, 0),\n};\n\n#define b43_a_ratetable\t\t(__b43_ratetable + 4)\n#define b43_a_ratetable_size\t8\n#define b43_b_ratetable\t\t(__b43_ratetable + 0)\n#define b43_b_ratetable_size\t4\n#define b43_g_ratetable\t\t(__b43_ratetable + 0)\n#define b43_g_ratetable_size\t12\n\n#define CHAN2G(_channel, _freq, _flags) {\t\t\t\\\n\t.band\t\t\t= NL80211_BAND_2GHZ,\t\t\\\n\t.center_freq\t\t= (_freq),\t\t\t\\\n\t.hw_value\t\t= (_channel),\t\t\t\\\n\t.flags\t\t\t= (_flags),\t\t\t\\\n\t.max_antenna_gain\t= 0,\t\t\t\t\\\n\t.max_power\t\t= 30,\t\t\t\t\\\n}\nstatic struct ieee80211_channel b43_2ghz_chantable[] = {\n\tCHAN2G(1, 2412, 0),\n\tCHAN2G(2, 2417, 0),\n\tCHAN2G(3, 2422, 0),\n\tCHAN2G(4, 2427, 0),\n\tCHAN2G(5, 2432, 0),\n\tCHAN2G(6, 2437, 0),\n\tCHAN2G(7, 2442, 0),\n\tCHAN2G(8, 2447, 0),\n\tCHAN2G(9, 2452, 0),\n\tCHAN2G(10, 2457, 0),\n\tCHAN2G(11, 2462, 0),\n\tCHAN2G(12, 2467, 0),\n\tCHAN2G(13, 2472, 0),\n\tCHAN2G(14, 2484, 0),\n};\n\n \n#define b43_2ghz_chantable_limited_size\t\t11\n#undef CHAN2G\n\n#define CHAN4G(_channel, _flags) {\t\t\t\t\\\n\t.band\t\t\t= NL80211_BAND_5GHZ,\t\t\\\n\t.center_freq\t\t= 4000 + (5 * (_channel)),\t\\\n\t.hw_value\t\t= (_channel),\t\t\t\\\n\t.flags\t\t\t= (_flags),\t\t\t\\\n\t.max_antenna_gain\t= 0,\t\t\t\t\\\n\t.max_power\t\t= 30,\t\t\t\t\\\n}\n#define CHAN5G(_channel, _flags) {\t\t\t\t\\\n\t.band\t\t\t= NL80211_BAND_5GHZ,\t\t\\\n\t.center_freq\t\t= 5000 + (5 * (_channel)),\t\\\n\t.hw_value\t\t= (_channel),\t\t\t\\\n\t.flags\t\t\t= (_flags),\t\t\t\\\n\t.max_antenna_gain\t= 0,\t\t\t\t\\\n\t.max_power\t\t= 30,\t\t\t\t\\\n}\nstatic struct ieee80211_channel b43_5ghz_nphy_chantable[] = {\n\tCHAN4G(184, 0),\t\tCHAN4G(186, 0),\n\tCHAN4G(188, 0),\t\tCHAN4G(190, 0),\n\tCHAN4G(192, 0),\t\tCHAN4G(194, 0),\n\tCHAN4G(196, 0),\t\tCHAN4G(198, 0),\n\tCHAN4G(200, 0),\t\tCHAN4G(202, 0),\n\tCHAN4G(204, 0),\t\tCHAN4G(206, 0),\n\tCHAN4G(208, 0),\t\tCHAN4G(210, 0),\n\tCHAN4G(212, 0),\t\tCHAN4G(214, 0),\n\tCHAN4G(216, 0),\t\tCHAN4G(218, 0),\n\tCHAN4G(220, 0),\t\tCHAN4G(222, 0),\n\tCHAN4G(224, 0),\t\tCHAN4G(226, 0),\n\tCHAN4G(228, 0),\n\tCHAN5G(32, 0),\t\tCHAN5G(34, 0),\n\tCHAN5G(36, 0),\t\tCHAN5G(38, 0),\n\tCHAN5G(40, 0),\t\tCHAN5G(42, 0),\n\tCHAN5G(44, 0),\t\tCHAN5G(46, 0),\n\tCHAN5G(48, 0),\t\tCHAN5G(50, 0),\n\tCHAN5G(52, 0),\t\tCHAN5G(54, 0),\n\tCHAN5G(56, 0),\t\tCHAN5G(58, 0),\n\tCHAN5G(60, 0),\t\tCHAN5G(62, 0),\n\tCHAN5G(64, 0),\t\tCHAN5G(66, 0),\n\tCHAN5G(68, 0),\t\tCHAN5G(70, 0),\n\tCHAN5G(72, 0),\t\tCHAN5G(74, 0),\n\tCHAN5G(76, 0),\t\tCHAN5G(78, 0),\n\tCHAN5G(80, 0),\t\tCHAN5G(82, 0),\n\tCHAN5G(84, 0),\t\tCHAN5G(86, 0),\n\tCHAN5G(88, 0),\t\tCHAN5G(90, 0),\n\tCHAN5G(92, 0),\t\tCHAN5G(94, 0),\n\tCHAN5G(96, 0),\t\tCHAN5G(98, 0),\n\tCHAN5G(100, 0),\t\tCHAN5G(102, 0),\n\tCHAN5G(104, 0),\t\tCHAN5G(106, 0),\n\tCHAN5G(108, 0),\t\tCHAN5G(110, 0),\n\tCHAN5G(112, 0),\t\tCHAN5G(114, 0),\n\tCHAN5G(116, 0),\t\tCHAN5G(118, 0),\n\tCHAN5G(120, 0),\t\tCHAN5G(122, 0),\n\tCHAN5G(124, 0),\t\tCHAN5G(126, 0),\n\tCHAN5G(128, 0),\t\tCHAN5G(130, 0),\n\tCHAN5G(132, 0),\t\tCHAN5G(134, 0),\n\tCHAN5G(136, 0),\t\tCHAN5G(138, 0),\n\tCHAN5G(140, 0),\t\tCHAN5G(142, 0),\n\tCHAN5G(144, 0),\t\tCHAN5G(145, 0),\n\tCHAN5G(146, 0),\t\tCHAN5G(147, 0),\n\tCHAN5G(148, 0),\t\tCHAN5G(149, 0),\n\tCHAN5G(150, 0),\t\tCHAN5G(151, 0),\n\tCHAN5G(152, 0),\t\tCHAN5G(153, 0),\n\tCHAN5G(154, 0),\t\tCHAN5G(155, 0),\n\tCHAN5G(156, 0),\t\tCHAN5G(157, 0),\n\tCHAN5G(158, 0),\t\tCHAN5G(159, 0),\n\tCHAN5G(160, 0),\t\tCHAN5G(161, 0),\n\tCHAN5G(162, 0),\t\tCHAN5G(163, 0),\n\tCHAN5G(164, 0),\t\tCHAN5G(165, 0),\n\tCHAN5G(166, 0),\t\tCHAN5G(168, 0),\n\tCHAN5G(170, 0),\t\tCHAN5G(172, 0),\n\tCHAN5G(174, 0),\t\tCHAN5G(176, 0),\n\tCHAN5G(178, 0),\t\tCHAN5G(180, 0),\n\tCHAN5G(182, 0),\n};\n\nstatic struct ieee80211_channel b43_5ghz_nphy_chantable_limited[] = {\n\tCHAN5G(36, 0),\t\tCHAN5G(40, 0),\n\tCHAN5G(44, 0),\t\tCHAN5G(48, 0),\n\tCHAN5G(149, 0),\t\tCHAN5G(153, 0),\n\tCHAN5G(157, 0),\t\tCHAN5G(161, 0),\n\tCHAN5G(165, 0),\n};\n\nstatic struct ieee80211_channel b43_5ghz_aphy_chantable[] = {\n\tCHAN5G(34, 0),\t\tCHAN5G(36, 0),\n\tCHAN5G(38, 0),\t\tCHAN5G(40, 0),\n\tCHAN5G(42, 0),\t\tCHAN5G(44, 0),\n\tCHAN5G(46, 0),\t\tCHAN5G(48, 0),\n\tCHAN5G(52, 0),\t\tCHAN5G(56, 0),\n\tCHAN5G(60, 0),\t\tCHAN5G(64, 0),\n\tCHAN5G(100, 0),\t\tCHAN5G(104, 0),\n\tCHAN5G(108, 0),\t\tCHAN5G(112, 0),\n\tCHAN5G(116, 0),\t\tCHAN5G(120, 0),\n\tCHAN5G(124, 0),\t\tCHAN5G(128, 0),\n\tCHAN5G(132, 0),\t\tCHAN5G(136, 0),\n\tCHAN5G(140, 0),\t\tCHAN5G(149, 0),\n\tCHAN5G(153, 0),\t\tCHAN5G(157, 0),\n\tCHAN5G(161, 0),\t\tCHAN5G(165, 0),\n\tCHAN5G(184, 0),\t\tCHAN5G(188, 0),\n\tCHAN5G(192, 0),\t\tCHAN5G(196, 0),\n\tCHAN5G(200, 0),\t\tCHAN5G(204, 0),\n\tCHAN5G(208, 0),\t\tCHAN5G(212, 0),\n\tCHAN5G(216, 0),\n};\n#undef CHAN4G\n#undef CHAN5G\n\nstatic struct ieee80211_supported_band b43_band_5GHz_nphy = {\n\t.band\t\t= NL80211_BAND_5GHZ,\n\t.channels\t= b43_5ghz_nphy_chantable,\n\t.n_channels\t= ARRAY_SIZE(b43_5ghz_nphy_chantable),\n\t.bitrates\t= b43_a_ratetable,\n\t.n_bitrates\t= b43_a_ratetable_size,\n};\n\nstatic struct ieee80211_supported_band b43_band_5GHz_nphy_limited = {\n\t.band\t\t= NL80211_BAND_5GHZ,\n\t.channels\t= b43_5ghz_nphy_chantable_limited,\n\t.n_channels\t= ARRAY_SIZE(b43_5ghz_nphy_chantable_limited),\n\t.bitrates\t= b43_a_ratetable,\n\t.n_bitrates\t= b43_a_ratetable_size,\n};\n\nstatic struct ieee80211_supported_band b43_band_5GHz_aphy = {\n\t.band\t\t= NL80211_BAND_5GHZ,\n\t.channels\t= b43_5ghz_aphy_chantable,\n\t.n_channels\t= ARRAY_SIZE(b43_5ghz_aphy_chantable),\n\t.bitrates\t= b43_a_ratetable,\n\t.n_bitrates\t= b43_a_ratetable_size,\n};\n\nstatic struct ieee80211_supported_band b43_band_2GHz = {\n\t.band\t\t= NL80211_BAND_2GHZ,\n\t.channels\t= b43_2ghz_chantable,\n\t.n_channels\t= ARRAY_SIZE(b43_2ghz_chantable),\n\t.bitrates\t= b43_g_ratetable,\n\t.n_bitrates\t= b43_g_ratetable_size,\n};\n\nstatic struct ieee80211_supported_band b43_band_2ghz_limited = {\n\t.band\t\t= NL80211_BAND_2GHZ,\n\t.channels\t= b43_2ghz_chantable,\n\t.n_channels\t= b43_2ghz_chantable_limited_size,\n\t.bitrates\t= b43_g_ratetable,\n\t.n_bitrates\t= b43_g_ratetable_size,\n};\n\nstatic void b43_wireless_core_exit(struct b43_wldev *dev);\nstatic int b43_wireless_core_init(struct b43_wldev *dev);\nstatic struct b43_wldev * b43_wireless_core_stop(struct b43_wldev *dev);\nstatic int b43_wireless_core_start(struct b43_wldev *dev);\nstatic void b43_op_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_bss_conf *conf,\n\t\t\t\t    u64 changed);\n\nstatic int b43_ratelimit(struct b43_wl *wl)\n{\n\tif (!wl || !wl->current_dev)\n\t\treturn 1;\n\tif (b43_status(wl->current_dev) < B43_STAT_STARTED)\n\t\treturn 1;\n\t \n\treturn net_ratelimit();\n}\n\nvoid b43info(struct b43_wl *wl, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (b43_modparam_verbose < B43_VERBOSITY_INFO)\n\t\treturn;\n\tif (!b43_ratelimit(wl))\n\t\treturn;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_INFO \"b43-%s: %pV\",\n\t       (wl && wl->hw) ? wiphy_name(wl->hw->wiphy) : \"wlan\", &vaf);\n\n\tva_end(args);\n}\n\nvoid b43err(struct b43_wl *wl, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (b43_modparam_verbose < B43_VERBOSITY_ERROR)\n\t\treturn;\n\tif (!b43_ratelimit(wl))\n\t\treturn;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_ERR \"b43-%s ERROR: %pV\",\n\t       (wl && wl->hw) ? wiphy_name(wl->hw->wiphy) : \"wlan\", &vaf);\n\n\tva_end(args);\n}\n\nvoid b43warn(struct b43_wl *wl, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (b43_modparam_verbose < B43_VERBOSITY_WARN)\n\t\treturn;\n\tif (!b43_ratelimit(wl))\n\t\treturn;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"b43-%s warning: %pV\",\n\t       (wl && wl->hw) ? wiphy_name(wl->hw->wiphy) : \"wlan\", &vaf);\n\n\tva_end(args);\n}\n\nvoid b43dbg(struct b43_wl *wl, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (b43_modparam_verbose < B43_VERBOSITY_DEBUG)\n\t\treturn;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_DEBUG \"b43-%s debug: %pV\",\n\t       (wl && wl->hw) ? wiphy_name(wl->hw->wiphy) : \"wlan\", &vaf);\n\n\tva_end(args);\n}\n\nstatic void b43_ram_write(struct b43_wldev *dev, u16 offset, u32 val)\n{\n\tu32 macctl;\n\n\tB43_WARN_ON(offset % 4 != 0);\n\n\tmacctl = b43_read32(dev, B43_MMIO_MACCTL);\n\tif (macctl & B43_MACCTL_BE)\n\t\tval = swab32(val);\n\n\tb43_write32(dev, B43_MMIO_RAM_CONTROL, offset);\n\tb43_write32(dev, B43_MMIO_RAM_DATA, val);\n}\n\nstatic inline void b43_shm_control_word(struct b43_wldev *dev,\n\t\t\t\t\tu16 routing, u16 offset)\n{\n\tu32 control;\n\n\t \n\tcontrol = routing;\n\tcontrol <<= 16;\n\tcontrol |= offset;\n\tb43_write32(dev, B43_MMIO_SHM_CONTROL, control);\n}\n\nu32 b43_shm_read32(struct b43_wldev *dev, u16 routing, u16 offset)\n{\n\tu32 ret;\n\n\tif (routing == B43_SHM_SHARED) {\n\t\tB43_WARN_ON(offset & 0x0001);\n\t\tif (offset & 0x0003) {\n\t\t\t \n\t\t\tb43_shm_control_word(dev, routing, offset >> 2);\n\t\t\tret = b43_read16(dev, B43_MMIO_SHM_DATA_UNALIGNED);\n\t\t\tb43_shm_control_word(dev, routing, (offset >> 2) + 1);\n\t\t\tret |= ((u32)b43_read16(dev, B43_MMIO_SHM_DATA)) << 16;\n\n\t\t\tgoto out;\n\t\t}\n\t\toffset >>= 2;\n\t}\n\tb43_shm_control_word(dev, routing, offset);\n\tret = b43_read32(dev, B43_MMIO_SHM_DATA);\nout:\n\treturn ret;\n}\n\nu16 b43_shm_read16(struct b43_wldev *dev, u16 routing, u16 offset)\n{\n\tu16 ret;\n\n\tif (routing == B43_SHM_SHARED) {\n\t\tB43_WARN_ON(offset & 0x0001);\n\t\tif (offset & 0x0003) {\n\t\t\t \n\t\t\tb43_shm_control_word(dev, routing, offset >> 2);\n\t\t\tret = b43_read16(dev, B43_MMIO_SHM_DATA_UNALIGNED);\n\n\t\t\tgoto out;\n\t\t}\n\t\toffset >>= 2;\n\t}\n\tb43_shm_control_word(dev, routing, offset);\n\tret = b43_read16(dev, B43_MMIO_SHM_DATA);\nout:\n\treturn ret;\n}\n\nvoid b43_shm_write32(struct b43_wldev *dev, u16 routing, u16 offset, u32 value)\n{\n\tif (routing == B43_SHM_SHARED) {\n\t\tB43_WARN_ON(offset & 0x0001);\n\t\tif (offset & 0x0003) {\n\t\t\t \n\t\t\tb43_shm_control_word(dev, routing, offset >> 2);\n\t\t\tb43_write16(dev, B43_MMIO_SHM_DATA_UNALIGNED,\n\t\t\t\t    value & 0xFFFF);\n\t\t\tb43_shm_control_word(dev, routing, (offset >> 2) + 1);\n\t\t\tb43_write16(dev, B43_MMIO_SHM_DATA,\n\t\t\t\t    (value >> 16) & 0xFFFF);\n\t\t\treturn;\n\t\t}\n\t\toffset >>= 2;\n\t}\n\tb43_shm_control_word(dev, routing, offset);\n\tb43_write32(dev, B43_MMIO_SHM_DATA, value);\n}\n\nvoid b43_shm_write16(struct b43_wldev *dev, u16 routing, u16 offset, u16 value)\n{\n\tif (routing == B43_SHM_SHARED) {\n\t\tB43_WARN_ON(offset & 0x0001);\n\t\tif (offset & 0x0003) {\n\t\t\t \n\t\t\tb43_shm_control_word(dev, routing, offset >> 2);\n\t\t\tb43_write16(dev, B43_MMIO_SHM_DATA_UNALIGNED, value);\n\t\t\treturn;\n\t\t}\n\t\toffset >>= 2;\n\t}\n\tb43_shm_control_word(dev, routing, offset);\n\tb43_write16(dev, B43_MMIO_SHM_DATA, value);\n}\n\n \nu64 b43_hf_read(struct b43_wldev *dev)\n{\n\tu64 ret;\n\n\tret = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_HOSTF3);\n\tret <<= 16;\n\tret |= b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_HOSTF2);\n\tret <<= 16;\n\tret |= b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_HOSTF1);\n\n\treturn ret;\n}\n\n \nvoid b43_hf_write(struct b43_wldev *dev, u64 value)\n{\n\tu16 lo, mi, hi;\n\n\tlo = (value & 0x00000000FFFFULL);\n\tmi = (value & 0x0000FFFF0000ULL) >> 16;\n\thi = (value & 0xFFFF00000000ULL) >> 32;\n\tb43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_HOSTF1, lo);\n\tb43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_HOSTF2, mi);\n\tb43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_HOSTF3, hi);\n}\n\n \nstatic u16 b43_fwcapa_read(struct b43_wldev *dev)\n{\n\tB43_WARN_ON(!dev->fw.opensource);\n\treturn b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_FWCAPA);\n}\n\nvoid b43_tsf_read(struct b43_wldev *dev, u64 *tsf)\n{\n\tu32 low, high;\n\n\tB43_WARN_ON(dev->dev->core_rev < 3);\n\n\t \n\tlow = b43_read32(dev, B43_MMIO_REV3PLUS_TSF_LOW);\n\thigh = b43_read32(dev, B43_MMIO_REV3PLUS_TSF_HIGH);\n\n\t*tsf = high;\n\t*tsf <<= 32;\n\t*tsf |= low;\n}\n\nstatic void b43_time_lock(struct b43_wldev *dev)\n{\n\tb43_maskset32(dev, B43_MMIO_MACCTL, ~0, B43_MACCTL_TBTTHOLD);\n\t \n\tb43_read32(dev, B43_MMIO_MACCTL);\n}\n\nstatic void b43_time_unlock(struct b43_wldev *dev)\n{\n\tb43_maskset32(dev, B43_MMIO_MACCTL, ~B43_MACCTL_TBTTHOLD, 0);\n\t \n\tb43_read32(dev, B43_MMIO_MACCTL);\n}\n\nstatic void b43_tsf_write_locked(struct b43_wldev *dev, u64 tsf)\n{\n\tu32 low, high;\n\n\tB43_WARN_ON(dev->dev->core_rev < 3);\n\n\tlow = tsf;\n\thigh = (tsf >> 32);\n\t \n\tb43_write32(dev, B43_MMIO_REV3PLUS_TSF_LOW, low);\n\tb43_write32(dev, B43_MMIO_REV3PLUS_TSF_HIGH, high);\n}\n\nvoid b43_tsf_write(struct b43_wldev *dev, u64 tsf)\n{\n\tb43_time_lock(dev);\n\tb43_tsf_write_locked(dev, tsf);\n\tb43_time_unlock(dev);\n}\n\nstatic\nvoid b43_macfilter_set(struct b43_wldev *dev, u16 offset, const u8 *mac)\n{\n\tstatic const u8 zero_addr[ETH_ALEN] = { 0 };\n\tu16 data;\n\n\tif (!mac)\n\t\tmac = zero_addr;\n\n\toffset |= 0x0020;\n\tb43_write16(dev, B43_MMIO_MACFILTER_CONTROL, offset);\n\n\tdata = mac[0];\n\tdata |= mac[1] << 8;\n\tb43_write16(dev, B43_MMIO_MACFILTER_DATA, data);\n\tdata = mac[2];\n\tdata |= mac[3] << 8;\n\tb43_write16(dev, B43_MMIO_MACFILTER_DATA, data);\n\tdata = mac[4];\n\tdata |= mac[5] << 8;\n\tb43_write16(dev, B43_MMIO_MACFILTER_DATA, data);\n}\n\nstatic void b43_write_mac_bssid_templates(struct b43_wldev *dev)\n{\n\tconst u8 *mac;\n\tconst u8 *bssid;\n\tu8 mac_bssid[ETH_ALEN * 2];\n\tint i;\n\tu32 tmp;\n\n\tbssid = dev->wl->bssid;\n\tmac = dev->wl->mac_addr;\n\n\tb43_macfilter_set(dev, B43_MACFILTER_BSSID, bssid);\n\n\tmemcpy(mac_bssid, mac, ETH_ALEN);\n\tmemcpy(mac_bssid + ETH_ALEN, bssid, ETH_ALEN);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(mac_bssid); i += sizeof(u32)) {\n\t\ttmp = (u32) (mac_bssid[i + 0]);\n\t\ttmp |= (u32) (mac_bssid[i + 1]) << 8;\n\t\ttmp |= (u32) (mac_bssid[i + 2]) << 16;\n\t\ttmp |= (u32) (mac_bssid[i + 3]) << 24;\n\t\tb43_ram_write(dev, 0x20 + i, tmp);\n\t}\n}\n\nstatic void b43_upload_card_macaddress(struct b43_wldev *dev)\n{\n\tb43_write_mac_bssid_templates(dev);\n\tb43_macfilter_set(dev, B43_MACFILTER_SELF, dev->wl->mac_addr);\n}\n\nstatic void b43_set_slot_time(struct b43_wldev *dev, u16 slot_time)\n{\n\t \n\t \n\tif (b43_current_band(dev->wl) == NL80211_BAND_5GHZ)\n\t\treturn;\n\tb43_write16(dev, B43_MMIO_IFSSLOT, 510 + slot_time);\n\t \n}\n\nstatic void b43_short_slot_timing_enable(struct b43_wldev *dev)\n{\n\tb43_set_slot_time(dev, 9);\n}\n\nstatic void b43_short_slot_timing_disable(struct b43_wldev *dev)\n{\n\tb43_set_slot_time(dev, 20);\n}\n\n \nvoid b43_dummy_transmission(struct b43_wldev *dev, bool ofdm, bool pa_on)\n{\n\tstruct b43_phy *phy = &dev->phy;\n\tunsigned int i, max_loop;\n\tu16 value;\n\tu32 buffer[5] = {\n\t\t0x00000000,\n\t\t0x00D40000,\n\t\t0x00000000,\n\t\t0x01000000,\n\t\t0x00000000,\n\t};\n\n\tif (ofdm) {\n\t\tmax_loop = 0x1E;\n\t\tbuffer[0] = 0x000201CC;\n\t} else {\n\t\tmax_loop = 0xFA;\n\t\tbuffer[0] = 0x000B846E;\n\t}\n\n\tfor (i = 0; i < 5; i++)\n\t\tb43_ram_write(dev, i * 4, buffer[i]);\n\n\tb43_write16(dev, B43_MMIO_XMTSEL, 0x0000);\n\n\tif (dev->dev->core_rev < 11)\n\t\tb43_write16(dev, B43_MMIO_WEPCTL, 0x0000);\n\telse\n\t\tb43_write16(dev, B43_MMIO_WEPCTL, 0x0100);\n\n\tvalue = (ofdm ? 0x41 : 0x40);\n\tb43_write16(dev, B43_MMIO_TXE0_PHYCTL, value);\n\tif (phy->type == B43_PHYTYPE_N || phy->type == B43_PHYTYPE_LP ||\n\t    phy->type == B43_PHYTYPE_LCN)\n\t\tb43_write16(dev, B43_MMIO_TXE0_PHYCTL1, 0x1A02);\n\n\tb43_write16(dev, B43_MMIO_TXE0_WM_0, 0x0000);\n\tb43_write16(dev, B43_MMIO_TXE0_WM_1, 0x0000);\n\n\tb43_write16(dev, B43_MMIO_XMTTPLATETXPTR, 0x0000);\n\tb43_write16(dev, B43_MMIO_XMTTXCNT, 0x0014);\n\tb43_write16(dev, B43_MMIO_XMTSEL, 0x0826);\n\tb43_write16(dev, B43_MMIO_TXE0_CTL, 0x0000);\n\n\tif (!pa_on && phy->type == B43_PHYTYPE_N) {\n\t\t;  \n\t}\n\n\tswitch (phy->type) {\n\tcase B43_PHYTYPE_N:\n\tcase B43_PHYTYPE_LCN:\n\t\tb43_write16(dev, B43_MMIO_TXE0_AUX, 0x00D0);\n\t\tbreak;\n\tcase B43_PHYTYPE_LP:\n\t\tb43_write16(dev, B43_MMIO_TXE0_AUX, 0x0050);\n\t\tbreak;\n\tdefault:\n\t\tb43_write16(dev, B43_MMIO_TXE0_AUX, 0x0030);\n\t}\n\tb43_read16(dev, B43_MMIO_TXE0_AUX);\n\n\tif (phy->radio_ver == 0x2050 && phy->radio_rev <= 0x5)\n\t\tb43_radio_write16(dev, 0x0051, 0x0017);\n\tfor (i = 0x00; i < max_loop; i++) {\n\t\tvalue = b43_read16(dev, B43_MMIO_TXE0_STATUS);\n\t\tif (value & 0x0080)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\tfor (i = 0x00; i < 0x0A; i++) {\n\t\tvalue = b43_read16(dev, B43_MMIO_TXE0_STATUS);\n\t\tif (value & 0x0400)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\tfor (i = 0x00; i < 0x19; i++) {\n\t\tvalue = b43_read16(dev, B43_MMIO_IFSSTAT);\n\t\tif (!(value & 0x0100))\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\tif (phy->radio_ver == 0x2050 && phy->radio_rev <= 0x5)\n\t\tb43_radio_write16(dev, 0x0051, 0x0037);\n}\n\nstatic void key_write(struct b43_wldev *dev,\n\t\t      u8 index, u8 algorithm, const u8 *key)\n{\n\tunsigned int i;\n\tu32 offset;\n\tu16 value;\n\tu16 kidx;\n\n\t \n\tkidx = b43_kidx_to_fw(dev, index);\n\tvalue = ((kidx << 4) | algorithm);\n\tb43_shm_write16(dev, B43_SHM_SHARED,\n\t\t\tB43_SHM_SH_KEYIDXBLOCK + (kidx * 2), value);\n\n\t \n\toffset = dev->ktp + (index * B43_SEC_KEYSIZE);\n\tfor (i = 0; i < B43_SEC_KEYSIZE; i += 2) {\n\t\tvalue = key[i];\n\t\tvalue |= (u16) (key[i + 1]) << 8;\n\t\tb43_shm_write16(dev, B43_SHM_SHARED, offset + i, value);\n\t}\n}\n\nstatic void keymac_write(struct b43_wldev *dev, u8 index, const u8 *addr)\n{\n\tu32 addrtmp[2] = { 0, 0, };\n\tu8 pairwise_keys_start = B43_NR_GROUP_KEYS * 2;\n\n\tif (b43_new_kidx_api(dev))\n\t\tpairwise_keys_start = B43_NR_GROUP_KEYS;\n\n\tB43_WARN_ON(index < pairwise_keys_start);\n\t \n\tindex -= pairwise_keys_start;\n\tB43_WARN_ON(index >= B43_NR_PAIRWISE_KEYS);\n\n\tif (addr) {\n\t\taddrtmp[0] = addr[0];\n\t\taddrtmp[0] |= ((u32) (addr[1]) << 8);\n\t\taddrtmp[0] |= ((u32) (addr[2]) << 16);\n\t\taddrtmp[0] |= ((u32) (addr[3]) << 24);\n\t\taddrtmp[1] = addr[4];\n\t\taddrtmp[1] |= ((u32) (addr[5]) << 8);\n\t}\n\n\t \n\tb43_shm_write32(dev, B43_SHM_RCMTA,\n\t\t\t(index * 2) + 0, addrtmp[0]);\n\tb43_shm_write16(dev, B43_SHM_RCMTA,\n\t\t\t(index * 2) + 1, addrtmp[1]);\n}\n\n \nstatic void rx_tkip_phase1_write(struct b43_wldev *dev, u8 index, u32 iv32,\n\t\tu16 *phase1key)\n{\n\tunsigned int i;\n\tu32 offset;\n\tu8 pairwise_keys_start = B43_NR_GROUP_KEYS * 2;\n\n\tif (!modparam_hwtkip)\n\t\treturn;\n\n\tif (b43_new_kidx_api(dev))\n\t\tpairwise_keys_start = B43_NR_GROUP_KEYS;\n\n\tB43_WARN_ON(index < pairwise_keys_start);\n\t \n\tindex -= pairwise_keys_start;\n\tB43_WARN_ON(index >= B43_NR_PAIRWISE_KEYS);\n\n\tif (b43_debug(dev, B43_DBG_KEYS)) {\n\t\tb43dbg(dev->wl, \"rx_tkip_phase1_write : idx 0x%x, iv32 0x%x\\n\",\n\t\t\t\tindex, iv32);\n\t}\n\t \n\toffset = B43_SHM_SH_TKIPTSCTTAK + index * (10 + 4);\n\tfor (i = 0; i < 10; i += 2) {\n\t\tb43_shm_write16(dev, B43_SHM_SHARED, offset + i,\n\t\t\t\tphase1key ? phase1key[i / 2] : 0);\n\t}\n\tb43_shm_write16(dev, B43_SHM_SHARED, offset + i, iv32);\n\tb43_shm_write16(dev, B43_SHM_SHARED, offset + i + 2, iv32 >> 16);\n}\n\nstatic void b43_op_update_tkip_key(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_key_conf *keyconf,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   u32 iv32, u16 *phase1key)\n{\n\tstruct b43_wl *wl = hw_to_b43_wl(hw);\n\tstruct b43_wldev *dev;\n\tint index = keyconf->hw_key_idx;\n\n\tif (B43_WARN_ON(!modparam_hwtkip))\n\t\treturn;\n\n\t \n\tB43_WARN_ON(!mutex_is_locked(&wl->mutex));\n\tdev = wl->current_dev;\n\tB43_WARN_ON(!dev || b43_status(dev) < B43_STAT_INITIALIZED);\n\n\tkeymac_write(dev, index, NULL);\t \n\n\trx_tkip_phase1_write(dev, index, iv32, phase1key);\n\t \n\tif (WARN_ON(!sta))\n\t\treturn;\n\tkeymac_write(dev, index, sta->addr);\n}\n\nstatic void do_key_write(struct b43_wldev *dev,\n\t\t\t u8 index, u8 algorithm,\n\t\t\t const u8 *key, size_t key_len, const u8 *mac_addr)\n{\n\tu8 buf[B43_SEC_KEYSIZE] = { 0, };\n\tu8 pairwise_keys_start = B43_NR_GROUP_KEYS * 2;\n\n\tif (b43_new_kidx_api(dev))\n\t\tpairwise_keys_start = B43_NR_GROUP_KEYS;\n\n\tB43_WARN_ON(index >= ARRAY_SIZE(dev->key));\n\tB43_WARN_ON(key_len > B43_SEC_KEYSIZE);\n\n\tif (index >= pairwise_keys_start)\n\t\tkeymac_write(dev, index, NULL);\t \n\tif (algorithm == B43_SEC_ALGO_TKIP) {\n\t\t \n\t\trx_tkip_phase1_write(dev, index, 0xffffffff, (u16*)buf);\n\t} else if (index >= pairwise_keys_start)  \n\t\trx_tkip_phase1_write(dev, index, 0, NULL);\n\tif (key)\n\t\tmemcpy(buf, key, key_len);\n\tkey_write(dev, index, algorithm, buf);\n\tif (index >= pairwise_keys_start)\n\t\tkeymac_write(dev, index, mac_addr);\n\n\tdev->key[index].algorithm = algorithm;\n}\n\nstatic int b43_key_write(struct b43_wldev *dev,\n\t\t\t int index, u8 algorithm,\n\t\t\t const u8 *key, size_t key_len,\n\t\t\t const u8 *mac_addr,\n\t\t\t struct ieee80211_key_conf *keyconf)\n{\n\tint i;\n\tint pairwise_keys_start;\n\n\t \n\tif (algorithm == B43_SEC_ALGO_TKIP && key_len == 32)\n\t\tkey_len = 16;\n\tif (key_len > B43_SEC_KEYSIZE)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < ARRAY_SIZE(dev->key); i++) {\n\t\t \n\t\tB43_WARN_ON(dev->key[i].keyconf == keyconf);\n\t}\n\tif (index < 0) {\n\t\t \n\t\tif (b43_new_kidx_api(dev))\n\t\t\tpairwise_keys_start = B43_NR_GROUP_KEYS;\n\t\telse\n\t\t\tpairwise_keys_start = B43_NR_GROUP_KEYS * 2;\n\t\tfor (i = pairwise_keys_start;\n\t\t     i < pairwise_keys_start + B43_NR_PAIRWISE_KEYS;\n\t\t     i++) {\n\t\t\tB43_WARN_ON(i >= ARRAY_SIZE(dev->key));\n\t\t\tif (!dev->key[i].keyconf) {\n\t\t\t\t \n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (index < 0) {\n\t\t\tb43warn(dev->wl, \"Out of hardware key memory\\n\");\n\t\t\treturn -ENOSPC;\n\t\t}\n\t} else\n\t\tB43_WARN_ON(index > 3);\n\n\tdo_key_write(dev, index, algorithm, key, key_len, mac_addr);\n\tif ((index <= 3) && !b43_new_kidx_api(dev)) {\n\t\t \n\t\tB43_WARN_ON(mac_addr);\n\t\tdo_key_write(dev, index + 4, algorithm, key, key_len, NULL);\n\t}\n\tkeyconf->hw_key_idx = index;\n\tdev->key[index].keyconf = keyconf;\n\n\treturn 0;\n}\n\nstatic int b43_key_clear(struct b43_wldev *dev, int index)\n{\n\tif (B43_WARN_ON((index < 0) || (index >= ARRAY_SIZE(dev->key))))\n\t\treturn -EINVAL;\n\tdo_key_write(dev, index, B43_SEC_ALGO_NONE,\n\t\t     NULL, B43_SEC_KEYSIZE, NULL);\n\tif ((index <= 3) && !b43_new_kidx_api(dev)) {\n\t\tdo_key_write(dev, index + 4, B43_SEC_ALGO_NONE,\n\t\t\t     NULL, B43_SEC_KEYSIZE, NULL);\n\t}\n\tdev->key[index].keyconf = NULL;\n\n\treturn 0;\n}\n\nstatic void b43_clear_keys(struct b43_wldev *dev)\n{\n\tint i, count;\n\n\tif (b43_new_kidx_api(dev))\n\t\tcount = B43_NR_GROUP_KEYS + B43_NR_PAIRWISE_KEYS;\n\telse\n\t\tcount = B43_NR_GROUP_KEYS * 2 + B43_NR_PAIRWISE_KEYS;\n\tfor (i = 0; i < count; i++)\n\t\tb43_key_clear(dev, i);\n}\n\nstatic void b43_dump_keymemory(struct b43_wldev *dev)\n{\n\tunsigned int i, index, count, offset, pairwise_keys_start;\n\tu8 mac[ETH_ALEN];\n\tu16 algo;\n\tu32 rcmta0;\n\tu16 rcmta1;\n\tu64 hf;\n\tstruct b43_key *key;\n\n\tif (!b43_debug(dev, B43_DBG_KEYS))\n\t\treturn;\n\n\thf = b43_hf_read(dev);\n\tb43dbg(dev->wl, \"Hardware key memory dump:  USEDEFKEYS=%u\\n\",\n\t       !!(hf & B43_HF_USEDEFKEYS));\n\tif (b43_new_kidx_api(dev)) {\n\t\tpairwise_keys_start = B43_NR_GROUP_KEYS;\n\t\tcount = B43_NR_GROUP_KEYS + B43_NR_PAIRWISE_KEYS;\n\t} else {\n\t\tpairwise_keys_start = B43_NR_GROUP_KEYS * 2;\n\t\tcount = B43_NR_GROUP_KEYS * 2 + B43_NR_PAIRWISE_KEYS;\n\t}\n\tfor (index = 0; index < count; index++) {\n\t\tkey = &(dev->key[index]);\n\t\tprintk(KERN_DEBUG \"Key slot %02u: %s\",\n\t\t       index, (key->keyconf == NULL) ? \" \" : \"*\");\n\t\toffset = dev->ktp + (index * B43_SEC_KEYSIZE);\n\t\tfor (i = 0; i < B43_SEC_KEYSIZE; i += 2) {\n\t\t\tu16 tmp = b43_shm_read16(dev, B43_SHM_SHARED, offset + i);\n\t\t\tprintk(\"%02X%02X\", (tmp & 0xFF), ((tmp >> 8) & 0xFF));\n\t\t}\n\n\t\talgo = b43_shm_read16(dev, B43_SHM_SHARED,\n\t\t\t\t      B43_SHM_SH_KEYIDXBLOCK + (index * 2));\n\t\tprintk(\"   Algo: %04X/%02X\", algo, key->algorithm);\n\n\t\tif (index >= pairwise_keys_start) {\n\t\t\tif (key->algorithm == B43_SEC_ALGO_TKIP) {\n\t\t\t\tprintk(\"   TKIP: \");\n\t\t\t\toffset = B43_SHM_SH_TKIPTSCTTAK + (index - 4) * (10 + 4);\n\t\t\t\tfor (i = 0; i < 14; i += 2) {\n\t\t\t\t\tu16 tmp = b43_shm_read16(dev, B43_SHM_SHARED, offset + i);\n\t\t\t\t\tprintk(\"%02X%02X\", (tmp & 0xFF), ((tmp >> 8) & 0xFF));\n\t\t\t\t}\n\t\t\t}\n\t\t\trcmta0 = b43_shm_read32(dev, B43_SHM_RCMTA,\n\t\t\t\t\t\t((index - pairwise_keys_start) * 2) + 0);\n\t\t\trcmta1 = b43_shm_read16(dev, B43_SHM_RCMTA,\n\t\t\t\t\t\t((index - pairwise_keys_start) * 2) + 1);\n\t\t\t*((__le32 *)(&mac[0])) = cpu_to_le32(rcmta0);\n\t\t\t*((__le16 *)(&mac[4])) = cpu_to_le16(rcmta1);\n\t\t\tprintk(\"   MAC: %pM\", mac);\n\t\t} else\n\t\t\tprintk(\"   DEFAULT KEY\");\n\t\tprintk(\"\\n\");\n\t}\n}\n\nvoid b43_power_saving_ctl_bits(struct b43_wldev *dev, unsigned int ps_flags)\n{\n\tu32 macctl;\n\tu16 ucstat;\n\tbool hwps;\n\tbool awake;\n\tint i;\n\n\tB43_WARN_ON((ps_flags & B43_PS_ENABLED) &&\n\t\t    (ps_flags & B43_PS_DISABLED));\n\tB43_WARN_ON((ps_flags & B43_PS_AWAKE) && (ps_flags & B43_PS_ASLEEP));\n\n\tif (ps_flags & B43_PS_ENABLED) {\n\t\thwps = true;\n\t} else if (ps_flags & B43_PS_DISABLED) {\n\t\thwps = false;\n\t} else {\n\t\t \n\t\t \n\t}\n\tif (ps_flags & B43_PS_AWAKE) {\n\t\tawake = true;\n\t} else if (ps_flags & B43_PS_ASLEEP) {\n\t\tawake = false;\n\t} else {\n\t\t \n\t\t \n\t\t \n\t}\n\n \n\thwps = false;\n\tawake = true;\n\n\tmacctl = b43_read32(dev, B43_MMIO_MACCTL);\n\tif (hwps)\n\t\tmacctl |= B43_MACCTL_HWPS;\n\telse\n\t\tmacctl &= ~B43_MACCTL_HWPS;\n\tif (awake)\n\t\tmacctl |= B43_MACCTL_AWAKE;\n\telse\n\t\tmacctl &= ~B43_MACCTL_AWAKE;\n\tb43_write32(dev, B43_MMIO_MACCTL, macctl);\n\t \n\tb43_read32(dev, B43_MMIO_MACCTL);\n\tif (awake && dev->dev->core_rev >= 5) {\n\t\t \n\t\tfor (i = 0; i < 100; i++) {\n\t\t\tucstat = b43_shm_read16(dev, B43_SHM_SHARED,\n\t\t\t\t\t\tB43_SHM_SH_UCODESTAT);\n\t\t\tif (ucstat != B43_SHM_SH_UCODESTAT_SLEEP)\n\t\t\t\tbreak;\n\t\t\tudelay(10);\n\t\t}\n\t}\n}\n\n \nvoid b43_wireless_core_phy_pll_reset(struct b43_wldev *dev)\n{\n\tstruct bcma_drv_cc *bcma_cc __maybe_unused;\n\tstruct ssb_chipcommon *ssb_cc __maybe_unused;\n\n\tswitch (dev->dev->bus_type) {\n#ifdef CONFIG_B43_BCMA\n\tcase B43_BUS_BCMA:\n\t\tbcma_cc = &dev->dev->bdev->bus->drv_cc;\n\n\t\tbcma_cc_write32(bcma_cc, BCMA_CC_PMU_CHIPCTL_ADDR, 0);\n\t\tbcma_cc_mask32(bcma_cc, BCMA_CC_PMU_CHIPCTL_DATA, ~0x4);\n\t\tbcma_cc_set32(bcma_cc, BCMA_CC_PMU_CHIPCTL_DATA, 0x4);\n\t\tbcma_cc_mask32(bcma_cc, BCMA_CC_PMU_CHIPCTL_DATA, ~0x4);\n\t\tbreak;\n#endif\n#ifdef CONFIG_B43_SSB\n\tcase B43_BUS_SSB:\n\t\tssb_cc = &dev->dev->sdev->bus->chipco;\n\n\t\tchipco_write32(ssb_cc, SSB_CHIPCO_CHIPCTL_ADDR, 0);\n\t\tchipco_mask32(ssb_cc, SSB_CHIPCO_CHIPCTL_DATA, ~0x4);\n\t\tchipco_set32(ssb_cc, SSB_CHIPCO_CHIPCTL_DATA, 0x4);\n\t\tchipco_mask32(ssb_cc, SSB_CHIPCO_CHIPCTL_DATA, ~0x4);\n\t\tbreak;\n#endif\n\t}\n}\n\n#ifdef CONFIG_B43_BCMA\nstatic void b43_bcma_phy_reset(struct b43_wldev *dev)\n{\n\tu32 flags;\n\n\t \n\tflags = bcma_aread32(dev->dev->bdev, BCMA_IOCTL);\n\tflags |= B43_BCMA_IOCTL_PHY_RESET;\n\tflags |= B43_BCMA_IOCTL_PHY_BW_20MHZ;  \n\tbcma_awrite32(dev->dev->bdev, BCMA_IOCTL, flags);\n\tudelay(2);\n\n\tb43_phy_take_out_of_reset(dev);\n}\n\nstatic void b43_bcma_wireless_core_reset(struct b43_wldev *dev, bool gmode)\n{\n\tu32 req = B43_BCMA_CLKCTLST_80211_PLL_REQ |\n\t\t  B43_BCMA_CLKCTLST_PHY_PLL_REQ;\n\tu32 status = B43_BCMA_CLKCTLST_80211_PLL_ST |\n\t\t     B43_BCMA_CLKCTLST_PHY_PLL_ST;\n\tu32 flags;\n\n\tflags = B43_BCMA_IOCTL_PHY_CLKEN;\n\tif (gmode)\n\t\tflags |= B43_BCMA_IOCTL_GMODE;\n\tb43_device_enable(dev, flags);\n\n\tif (dev->phy.type == B43_PHYTYPE_AC) {\n\t\tu16 tmp;\n\n\t\ttmp = bcma_aread32(dev->dev->bdev, BCMA_IOCTL);\n\t\ttmp &= ~B43_BCMA_IOCTL_DAC;\n\t\ttmp |= 0x100;\n\t\tbcma_awrite32(dev->dev->bdev, BCMA_IOCTL, tmp);\n\n\t\ttmp = bcma_aread32(dev->dev->bdev, BCMA_IOCTL);\n\t\ttmp &= ~B43_BCMA_IOCTL_PHY_CLKEN;\n\t\tbcma_awrite32(dev->dev->bdev, BCMA_IOCTL, tmp);\n\n\t\ttmp = bcma_aread32(dev->dev->bdev, BCMA_IOCTL);\n\t\ttmp |= B43_BCMA_IOCTL_PHY_CLKEN;\n\t\tbcma_awrite32(dev->dev->bdev, BCMA_IOCTL, tmp);\n\t}\n\n\tbcma_core_set_clockmode(dev->dev->bdev, BCMA_CLKMODE_FAST);\n\tb43_bcma_phy_reset(dev);\n\tbcma_core_pll_ctl(dev->dev->bdev, req, status, true);\n}\n#endif\n\n#ifdef CONFIG_B43_SSB\nstatic void b43_ssb_wireless_core_reset(struct b43_wldev *dev, bool gmode)\n{\n\tu32 flags = 0;\n\n\tif (gmode)\n\t\tflags |= B43_TMSLOW_GMODE;\n\tflags |= B43_TMSLOW_PHYCLKEN;\n\tflags |= B43_TMSLOW_PHYRESET;\n\tif (dev->phy.type == B43_PHYTYPE_N)\n\t\tflags |= B43_TMSLOW_PHY_BANDWIDTH_20MHZ;  \n\tb43_device_enable(dev, flags);\n\tmsleep(2);\t\t \n\n\tb43_phy_take_out_of_reset(dev);\n}\n#endif\n\nvoid b43_wireless_core_reset(struct b43_wldev *dev, bool gmode)\n{\n\tu32 macctl;\n\n\tswitch (dev->dev->bus_type) {\n#ifdef CONFIG_B43_BCMA\n\tcase B43_BUS_BCMA:\n\t\tb43_bcma_wireless_core_reset(dev, gmode);\n\t\tbreak;\n#endif\n#ifdef CONFIG_B43_SSB\n\tcase B43_BUS_SSB:\n\t\tb43_ssb_wireless_core_reset(dev, gmode);\n\t\tbreak;\n#endif\n\t}\n\n\t \n\tif (dev->phy.ops)\n\t\tdev->phy.ops->switch_analog(dev, 1);\n\n\tmacctl = b43_read32(dev, B43_MMIO_MACCTL);\n\tmacctl &= ~B43_MACCTL_GMODE;\n\tif (gmode)\n\t\tmacctl |= B43_MACCTL_GMODE;\n\tmacctl |= B43_MACCTL_IHR_ENABLED;\n\tb43_write32(dev, B43_MMIO_MACCTL, macctl);\n}\n\nstatic void handle_irq_transmit_status(struct b43_wldev *dev)\n{\n\tu32 v0, v1;\n\tu16 tmp;\n\tstruct b43_txstatus stat;\n\n\twhile (1) {\n\t\tv0 = b43_read32(dev, B43_MMIO_XMITSTAT_0);\n\t\tif (!(v0 & 0x00000001))\n\t\t\tbreak;\n\t\tv1 = b43_read32(dev, B43_MMIO_XMITSTAT_1);\n\n\t\tstat.cookie = (v0 >> 16);\n\t\tstat.seq = (v1 & 0x0000FFFF);\n\t\tstat.phy_stat = ((v1 & 0x00FF0000) >> 16);\n\t\ttmp = (v0 & 0x0000FFFF);\n\t\tstat.frame_count = ((tmp & 0xF000) >> 12);\n\t\tstat.rts_count = ((tmp & 0x0F00) >> 8);\n\t\tstat.supp_reason = ((tmp & 0x001C) >> 2);\n\t\tstat.pm_indicated = !!(tmp & 0x0080);\n\t\tstat.intermediate = !!(tmp & 0x0040);\n\t\tstat.for_ampdu = !!(tmp & 0x0020);\n\t\tstat.acked = !!(tmp & 0x0002);\n\n\t\tb43_handle_txstatus(dev, &stat);\n\t}\n}\n\nstatic void drain_txstatus_queue(struct b43_wldev *dev)\n{\n\tu32 dummy;\n\n\tif (dev->dev->core_rev < 5)\n\t\treturn;\n\t \n\twhile (1) {\n\t\tdummy = b43_read32(dev, B43_MMIO_XMITSTAT_0);\n\t\tif (!(dummy & 0x00000001))\n\t\t\tbreak;\n\t\tdummy = b43_read32(dev, B43_MMIO_XMITSTAT_1);\n\t}\n}\n\nstatic u32 b43_jssi_read(struct b43_wldev *dev)\n{\n\tu32 val = 0;\n\n\tval = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_JSSI1);\n\tval <<= 16;\n\tval |= b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_JSSI0);\n\n\treturn val;\n}\n\nstatic void b43_jssi_write(struct b43_wldev *dev, u32 jssi)\n{\n\tb43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_JSSI0,\n\t\t\t(jssi & 0x0000FFFF));\n\tb43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_JSSI1,\n\t\t\t(jssi & 0xFFFF0000) >> 16);\n}\n\nstatic void b43_generate_noise_sample(struct b43_wldev *dev)\n{\n\tb43_jssi_write(dev, 0x7F7F7F7F);\n\tb43_write32(dev, B43_MMIO_MACCMD,\n\t\t    b43_read32(dev, B43_MMIO_MACCMD) | B43_MACCMD_BGNOISE);\n}\n\nstatic void b43_calculate_link_quality(struct b43_wldev *dev)\n{\n\t \n\n\tif (dev->phy.type != B43_PHYTYPE_G)\n\t\treturn;\n\tif (dev->noisecalc.calculation_running)\n\t\treturn;\n\tdev->noisecalc.calculation_running = true;\n\tdev->noisecalc.nr_samples = 0;\n\n\tb43_generate_noise_sample(dev);\n}\n\nstatic void handle_irq_noise(struct b43_wldev *dev)\n{\n\tstruct b43_phy_g *phy = dev->phy.g;\n\tu16 tmp;\n\tu8 noise[4];\n\tu8 i, j;\n\ts32 average;\n\n\t \n\n\tif (dev->phy.type != B43_PHYTYPE_G)\n\t\treturn;\n\n\t \n\n\tB43_WARN_ON(!dev->noisecalc.calculation_running);\n\t*((__le32 *)noise) = cpu_to_le32(b43_jssi_read(dev));\n\tif (noise[0] == 0x7F || noise[1] == 0x7F ||\n\t    noise[2] == 0x7F || noise[3] == 0x7F)\n\t\tgoto generate_new;\n\n\t \n\tB43_WARN_ON(dev->noisecalc.nr_samples >= 8);\n\ti = dev->noisecalc.nr_samples;\n\tnoise[0] = clamp_val(noise[0], 0, ARRAY_SIZE(phy->nrssi_lt) - 1);\n\tnoise[1] = clamp_val(noise[1], 0, ARRAY_SIZE(phy->nrssi_lt) - 1);\n\tnoise[2] = clamp_val(noise[2], 0, ARRAY_SIZE(phy->nrssi_lt) - 1);\n\tnoise[3] = clamp_val(noise[3], 0, ARRAY_SIZE(phy->nrssi_lt) - 1);\n\tdev->noisecalc.samples[i][0] = phy->nrssi_lt[noise[0]];\n\tdev->noisecalc.samples[i][1] = phy->nrssi_lt[noise[1]];\n\tdev->noisecalc.samples[i][2] = phy->nrssi_lt[noise[2]];\n\tdev->noisecalc.samples[i][3] = phy->nrssi_lt[noise[3]];\n\tdev->noisecalc.nr_samples++;\n\tif (dev->noisecalc.nr_samples == 8) {\n\t\t \n\t\taverage = 0;\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\taverage += dev->noisecalc.samples[i][j];\n\t\t}\n\t\taverage /= (8 * 4);\n\t\taverage *= 125;\n\t\taverage += 64;\n\t\taverage /= 128;\n\t\ttmp = b43_shm_read16(dev, B43_SHM_SHARED, 0x40C);\n\t\ttmp = (tmp / 128) & 0x1F;\n\t\tif (tmp >= 8)\n\t\t\taverage += 2;\n\t\telse\n\t\t\taverage -= 25;\n\t\tif (tmp == 8)\n\t\t\taverage -= 72;\n\t\telse\n\t\t\taverage -= 48;\n\n\t\tdev->stats.link_noise = average;\n\t\tdev->noisecalc.calculation_running = false;\n\t\treturn;\n\t}\ngenerate_new:\n\tb43_generate_noise_sample(dev);\n}\n\nstatic void handle_irq_tbtt_indication(struct b43_wldev *dev)\n{\n\tif (b43_is_mode(dev->wl, NL80211_IFTYPE_AP)) {\n\t\t \n\t} else {\n\t\tif (1   )\n\t\t\tb43_power_saving_ctl_bits(dev, 0);\n\t}\n\tif (b43_is_mode(dev->wl, NL80211_IFTYPE_ADHOC))\n\t\tdev->dfq_valid = true;\n}\n\nstatic void handle_irq_atim_end(struct b43_wldev *dev)\n{\n\tif (dev->dfq_valid) {\n\t\tb43_write32(dev, B43_MMIO_MACCMD,\n\t\t\t    b43_read32(dev, B43_MMIO_MACCMD)\n\t\t\t    | B43_MACCMD_DFQ_VALID);\n\t\tdev->dfq_valid = false;\n\t}\n}\n\nstatic void handle_irq_pmq(struct b43_wldev *dev)\n{\n\tu32 tmp;\n\n\t \n\n\twhile (1) {\n\t\ttmp = b43_read32(dev, B43_MMIO_PS_STATUS);\n\t\tif (!(tmp & 0x00000008))\n\t\t\tbreak;\n\t}\n\t \n\tb43_write16(dev, B43_MMIO_PS_STATUS, 0x0002);\n}\n\nstatic void b43_write_template_common(struct b43_wldev *dev,\n\t\t\t\t      const u8 *data, u16 size,\n\t\t\t\t      u16 ram_offset,\n\t\t\t\t      u16 shm_size_offset, u8 rate)\n{\n\tu32 i, tmp;\n\tstruct b43_plcp_hdr4 plcp;\n\n\tplcp.data = 0;\n\tb43_generate_plcp_hdr(&plcp, size + FCS_LEN, rate);\n\tb43_ram_write(dev, ram_offset, le32_to_cpu(plcp.data));\n\tram_offset += sizeof(u32);\n\t \n\ttmp = (u32) (data[0]) << 16;\n\ttmp |= (u32) (data[1]) << 24;\n\tb43_ram_write(dev, ram_offset, tmp);\n\tram_offset += sizeof(u32);\n\tfor (i = 2; i < size; i += sizeof(u32)) {\n\t\ttmp = (u32) (data[i + 0]);\n\t\tif (i + 1 < size)\n\t\t\ttmp |= (u32) (data[i + 1]) << 8;\n\t\tif (i + 2 < size)\n\t\t\ttmp |= (u32) (data[i + 2]) << 16;\n\t\tif (i + 3 < size)\n\t\t\ttmp |= (u32) (data[i + 3]) << 24;\n\t\tb43_ram_write(dev, ram_offset + i - 2, tmp);\n\t}\n\tb43_shm_write16(dev, B43_SHM_SHARED, shm_size_offset,\n\t\t\tsize + sizeof(struct b43_plcp_hdr6));\n}\n\n \nu8 b43_ieee80211_antenna_sanitize(struct b43_wldev *dev,\n\t\t\t\t  u8 antenna_nr)\n{\n\tu8 antenna_mask;\n\n\tif (antenna_nr == 0) {\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tif (dev->phy.gmode)\n\t\tantenna_mask = dev->dev->bus_sprom->ant_available_bg;\n\telse\n\t\tantenna_mask = dev->dev->bus_sprom->ant_available_a;\n\n\tif (!(antenna_mask & (1 << (antenna_nr - 1)))) {\n\t\t \n\t\treturn 0;\n\t}\n\n\treturn antenna_nr;\n}\n\n \nstatic u16 b43_antenna_to_phyctl(int antenna)\n{\n\tswitch (antenna) {\n\tcase B43_ANTENNA0:\n\t\treturn B43_TXH_PHY_ANT0;\n\tcase B43_ANTENNA1:\n\t\treturn B43_TXH_PHY_ANT1;\n\tcase B43_ANTENNA2:\n\t\treturn B43_TXH_PHY_ANT2;\n\tcase B43_ANTENNA3:\n\t\treturn B43_TXH_PHY_ANT3;\n\tcase B43_ANTENNA_AUTO0:\n\tcase B43_ANTENNA_AUTO1:\n\t\treturn B43_TXH_PHY_ANT01AUTO;\n\t}\n\tB43_WARN_ON(1);\n\treturn 0;\n}\n\nstatic void b43_write_beacon_template(struct b43_wldev *dev,\n\t\t\t\t      u16 ram_offset,\n\t\t\t\t      u16 shm_size_offset)\n{\n\tunsigned int i, len, variable_len;\n\tconst struct ieee80211_mgmt *bcn;\n\tconst u8 *ie;\n\tbool tim_found = false;\n\tunsigned int rate;\n\tu16 ctl;\n\tint antenna;\n\tstruct ieee80211_tx_info *info;\n\tunsigned long flags;\n\tstruct sk_buff *beacon_skb;\n\n\tspin_lock_irqsave(&dev->wl->beacon_lock, flags);\n\tinfo = IEEE80211_SKB_CB(dev->wl->current_beacon);\n\trate = ieee80211_get_tx_rate(dev->wl->hw, info)->hw_value;\n\t \n\tbeacon_skb = skb_clone(dev->wl->current_beacon, GFP_ATOMIC);\n\tspin_unlock_irqrestore(&dev->wl->beacon_lock, flags);\n\n\tif (!beacon_skb) {\n\t\tb43dbg(dev->wl, \"Could not upload beacon. \"\n\t\t       \"Failed to clone beacon skb.\");\n\t\treturn;\n\t}\n\n\tbcn = (const struct ieee80211_mgmt *)(beacon_skb->data);\n\tlen = min_t(size_t, beacon_skb->len,\n\t\t    0x200 - sizeof(struct b43_plcp_hdr6));\n\n\tb43_write_template_common(dev, (const u8 *)bcn,\n\t\t\t\t  len, ram_offset, shm_size_offset, rate);\n\n\t \n\tantenna = B43_ANTENNA_DEFAULT;\n\tantenna = b43_antenna_to_phyctl(antenna);\n\tctl = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_BEACPHYCTL);\n\t \n\tctl &= ~B43_TXH_PHY_SHORTPRMBL;\n\tctl &= ~B43_TXH_PHY_ANT;\n\tctl &= ~B43_TXH_PHY_ENC;\n\tctl |= antenna;\n\tif (b43_is_cck_rate(rate))\n\t\tctl |= B43_TXH_PHY_ENC_CCK;\n\telse\n\t\tctl |= B43_TXH_PHY_ENC_OFDM;\n\tb43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_BEACPHYCTL, ctl);\n\n\t \n\tie = bcn->u.beacon.variable;\n\tvariable_len = len - offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\tfor (i = 0; i < variable_len - 2; ) {\n\t\tuint8_t ie_id, ie_len;\n\n\t\tie_id = ie[i];\n\t\tie_len = ie[i + 1];\n\t\tif (ie_id == 5) {\n\t\t\tu16 tim_position;\n\t\t\tu16 dtim_period;\n\t\t\t \n\n\t\t\t \n\t\t\tif (variable_len < ie_len + 2 + i)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (ie_len < 4)\n\t\t\t\tbreak;\n\t\t\ttim_found = true;\n\n\t\t\ttim_position = sizeof(struct b43_plcp_hdr6);\n\t\t\ttim_position += offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\t\t\ttim_position += i;\n\n\t\t\tdtim_period = ie[i + 3];\n\n\t\t\tb43_shm_write16(dev, B43_SHM_SHARED,\n\t\t\t\t\tB43_SHM_SH_TIMBPOS, tim_position);\n\t\t\tb43_shm_write16(dev, B43_SHM_SHARED,\n\t\t\t\t\tB43_SHM_SH_DTIMPER, dtim_period);\n\t\t\tbreak;\n\t\t}\n\t\ti += ie_len + 2;\n\t}\n\tif (!tim_found) {\n\t\t \n\t\tb43_shm_write16(dev, B43_SHM_SHARED,\n\t\t\t\tB43_SHM_SH_TIMBPOS,\n\t\t\t\tlen + sizeof(struct b43_plcp_hdr6));\n\t\tb43_shm_write16(dev, B43_SHM_SHARED,\n\t\t\t\tB43_SHM_SH_DTIMPER, 0);\n\t}\n\tb43dbg(dev->wl, \"Updated beacon template at 0x%x\\n\", ram_offset);\n\n\tdev_kfree_skb_any(beacon_skb);\n}\n\nstatic void b43_upload_beacon0(struct b43_wldev *dev)\n{\n\tstruct b43_wl *wl = dev->wl;\n\n\tif (wl->beacon0_uploaded)\n\t\treturn;\n\tb43_write_beacon_template(dev, B43_SHM_SH_BT_BASE0, B43_SHM_SH_BTL0);\n\twl->beacon0_uploaded = true;\n}\n\nstatic void b43_upload_beacon1(struct b43_wldev *dev)\n{\n\tstruct b43_wl *wl = dev->wl;\n\n\tif (wl->beacon1_uploaded)\n\t\treturn;\n\tb43_write_beacon_template(dev, B43_SHM_SH_BT_BASE1, B43_SHM_SH_BTL1);\n\twl->beacon1_uploaded = true;\n}\n\nstatic void handle_irq_beacon(struct b43_wldev *dev)\n{\n\tstruct b43_wl *wl = dev->wl;\n\tu32 cmd, beacon0_valid, beacon1_valid;\n\n\tif (!b43_is_mode(wl, NL80211_IFTYPE_AP) &&\n\t    !b43_is_mode(wl, NL80211_IFTYPE_MESH_POINT) &&\n\t    !b43_is_mode(wl, NL80211_IFTYPE_ADHOC))\n\t\treturn;\n\n\t \n\n\t \n\tdev->irq_mask &= ~B43_IRQ_BEACON;\n\n\tcmd = b43_read32(dev, B43_MMIO_MACCMD);\n\tbeacon0_valid = (cmd & B43_MACCMD_BEACON0_VALID);\n\tbeacon1_valid = (cmd & B43_MACCMD_BEACON1_VALID);\n\n\t \n\tif (beacon0_valid && beacon1_valid) {\n\t\tb43_write32(dev, B43_MMIO_GEN_IRQ_REASON, B43_IRQ_BEACON);\n\t\tdev->irq_mask |= B43_IRQ_BEACON;\n\t\treturn;\n\t}\n\n\tif (unlikely(wl->beacon_templates_virgin)) {\n\t\t \n\t\twl->beacon_templates_virgin = false;\n\t\tb43_upload_beacon0(dev);\n\t\tb43_upload_beacon1(dev);\n\t\tcmd = b43_read32(dev, B43_MMIO_MACCMD);\n\t\tcmd |= B43_MACCMD_BEACON0_VALID;\n\t\tb43_write32(dev, B43_MMIO_MACCMD, cmd);\n\t} else {\n\t\tif (!beacon0_valid) {\n\t\t\tb43_upload_beacon0(dev);\n\t\t\tcmd = b43_read32(dev, B43_MMIO_MACCMD);\n\t\t\tcmd |= B43_MACCMD_BEACON0_VALID;\n\t\t\tb43_write32(dev, B43_MMIO_MACCMD, cmd);\n\t\t} else if (!beacon1_valid) {\n\t\t\tb43_upload_beacon1(dev);\n\t\t\tcmd = b43_read32(dev, B43_MMIO_MACCMD);\n\t\t\tcmd |= B43_MACCMD_BEACON1_VALID;\n\t\t\tb43_write32(dev, B43_MMIO_MACCMD, cmd);\n\t\t}\n\t}\n}\n\nstatic void b43_do_beacon_update_trigger_work(struct b43_wldev *dev)\n{\n\tu32 old_irq_mask = dev->irq_mask;\n\n\t \n\thandle_irq_beacon(dev);\n\tif (old_irq_mask != dev->irq_mask) {\n\t\t \n\t\tB43_WARN_ON(!dev->irq_mask);\n\t\tif (b43_read32(dev, B43_MMIO_GEN_IRQ_MASK)) {\n\t\t\tb43_write32(dev, B43_MMIO_GEN_IRQ_MASK, dev->irq_mask);\n\t\t} else {\n\t\t\t \n\t\t}\n\t}\n}\n\nstatic void b43_beacon_update_trigger_work(struct work_struct *work)\n{\n\tstruct b43_wl *wl = container_of(work, struct b43_wl,\n\t\t\t\t\t beacon_update_trigger);\n\tstruct b43_wldev *dev;\n\n\tmutex_lock(&wl->mutex);\n\tdev = wl->current_dev;\n\tif (likely(dev && (b43_status(dev) >= B43_STAT_INITIALIZED))) {\n\t\tif (b43_bus_host_is_sdio(dev->dev)) {\n\t\t\t \n\t\t\tb43_do_beacon_update_trigger_work(dev);\n\t\t} else {\n\t\t\tspin_lock_irq(&wl->hardirq_lock);\n\t\t\tb43_do_beacon_update_trigger_work(dev);\n\t\t\tspin_unlock_irq(&wl->hardirq_lock);\n\t\t}\n\t}\n\tmutex_unlock(&wl->mutex);\n}\n\n \nstatic void b43_update_templates(struct b43_wl *wl)\n{\n\tstruct sk_buff *beacon, *old_beacon;\n\tunsigned long flags;\n\n\t \n\n\t \n\tbeacon = ieee80211_beacon_get(wl->hw, wl->vif, 0);\n\tif (unlikely(!beacon))\n\t\treturn;\n\n\tspin_lock_irqsave(&wl->beacon_lock, flags);\n\told_beacon = wl->current_beacon;\n\twl->current_beacon = beacon;\n\twl->beacon0_uploaded = false;\n\twl->beacon1_uploaded = false;\n\tspin_unlock_irqrestore(&wl->beacon_lock, flags);\n\n\tieee80211_queue_work(wl->hw, &wl->beacon_update_trigger);\n\n\tif (old_beacon)\n\t\tdev_kfree_skb_any(old_beacon);\n}\n\nstatic void b43_set_beacon_int(struct b43_wldev *dev, u16 beacon_int)\n{\n\tb43_time_lock(dev);\n\tif (dev->dev->core_rev >= 3) {\n\t\tb43_write32(dev, B43_MMIO_TSF_CFP_REP, (beacon_int << 16));\n\t\tb43_write32(dev, B43_MMIO_TSF_CFP_START, (beacon_int << 10));\n\t} else {\n\t\tb43_write16(dev, 0x606, (beacon_int >> 6));\n\t\tb43_write16(dev, 0x610, beacon_int);\n\t}\n\tb43_time_unlock(dev);\n\tb43dbg(dev->wl, \"Set beacon interval to %u\\n\", beacon_int);\n}\n\nstatic void b43_handle_firmware_panic(struct b43_wldev *dev)\n{\n\tu16 reason;\n\n\t \n\treason = b43_shm_read16(dev, B43_SHM_SCRATCH, B43_FWPANIC_REASON_REG);\n\tb43err(dev->wl, \"Whoopsy, firmware panic! Reason: %u\\n\", reason);\n\n\tswitch (reason) {\n\tdefault:\n\t\tb43dbg(dev->wl, \"The panic reason is unknown.\\n\");\n\t\tfallthrough;\n\tcase B43_FWPANIC_DIE:\n\t\t \n\t\tbreak;\n\tcase B43_FWPANIC_RESTART:\n\t\tb43_controller_restart(dev, \"Microcode panic\");\n\t\tbreak;\n\t}\n}\n\nstatic void handle_irq_ucode_debug(struct b43_wldev *dev)\n{\n\tunsigned int i, cnt;\n\tu16 reason, marker_id, marker_line;\n\t__le16 *buf;\n\n\t \n\tif (!dev->fw.opensource)\n\t\treturn;\n\n\t \n\treason = b43_shm_read16(dev, B43_SHM_SCRATCH, B43_DEBUGIRQ_REASON_REG);\n\n\tswitch (reason) {\n\tcase B43_DEBUGIRQ_PANIC:\n\t\tb43_handle_firmware_panic(dev);\n\t\tbreak;\n\tcase B43_DEBUGIRQ_DUMP_SHM:\n\t\tif (!B43_DEBUG)\n\t\t\tbreak;  \n\t\tbuf = kmalloc(4096, GFP_ATOMIC);\n\t\tif (!buf) {\n\t\t\tb43dbg(dev->wl, \"SHM-dump: Failed to allocate memory\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tfor (i = 0; i < 4096; i += 2) {\n\t\t\tu16 tmp = b43_shm_read16(dev, B43_SHM_SHARED, i);\n\t\t\tbuf[i / 2] = cpu_to_le16(tmp);\n\t\t}\n\t\tb43info(dev->wl, \"Shared memory dump:\\n\");\n\t\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_OFFSET,\n\t\t\t       16, 2, buf, 4096, 1);\n\t\tkfree(buf);\n\t\tbreak;\n\tcase B43_DEBUGIRQ_DUMP_REGS:\n\t\tif (!B43_DEBUG)\n\t\t\tbreak;  \n\t\tb43info(dev->wl, \"Microcode register dump:\\n\");\n\t\tfor (i = 0, cnt = 0; i < 64; i++) {\n\t\t\tu16 tmp = b43_shm_read16(dev, B43_SHM_SCRATCH, i);\n\t\t\tif (cnt == 0)\n\t\t\t\tprintk(KERN_INFO);\n\t\t\tprintk(\"r%02u: 0x%04X  \", i, tmp);\n\t\t\tcnt++;\n\t\t\tif (cnt == 6) {\n\t\t\t\tprintk(\"\\n\");\n\t\t\t\tcnt = 0;\n\t\t\t}\n\t\t}\n\t\tprintk(\"\\n\");\n\t\tbreak;\n\tcase B43_DEBUGIRQ_MARKER:\n\t\tif (!B43_DEBUG)\n\t\t\tbreak;  \n\t\tmarker_id = b43_shm_read16(dev, B43_SHM_SCRATCH,\n\t\t\t\t\t   B43_MARKER_ID_REG);\n\t\tmarker_line = b43_shm_read16(dev, B43_SHM_SCRATCH,\n\t\t\t\t\t     B43_MARKER_LINE_REG);\n\t\tb43info(dev->wl, \"The firmware just executed the MARKER(%u) \"\n\t\t\t\"at line number %u\\n\",\n\t\t\tmarker_id, marker_line);\n\t\tbreak;\n\tdefault:\n\t\tb43dbg(dev->wl, \"Debug-IRQ triggered for unknown reason: %u\\n\",\n\t\t       reason);\n\t}\nout:\n\t \n\tb43_shm_write16(dev, B43_SHM_SCRATCH,\n\t\t\tB43_DEBUGIRQ_REASON_REG, B43_DEBUGIRQ_ACK);\n}\n\nstatic void b43_do_interrupt_thread(struct b43_wldev *dev)\n{\n\tu32 reason;\n\tu32 dma_reason[ARRAY_SIZE(dev->dma_reason)];\n\tu32 merged_dma_reason = 0;\n\tint i;\n\n\tif (unlikely(b43_status(dev) != B43_STAT_STARTED))\n\t\treturn;\n\n\treason = dev->irq_reason;\n\tfor (i = 0; i < ARRAY_SIZE(dma_reason); i++) {\n\t\tdma_reason[i] = dev->dma_reason[i];\n\t\tmerged_dma_reason |= dma_reason[i];\n\t}\n\n\tif (unlikely(reason & B43_IRQ_MAC_TXERR))\n\t\tb43err(dev->wl, \"MAC transmission error\\n\");\n\n\tif (unlikely(reason & B43_IRQ_PHY_TXERR)) {\n\t\tb43err(dev->wl, \"PHY transmission error\\n\");\n\t\trmb();\n\t\tif (unlikely(atomic_dec_and_test(&dev->phy.txerr_cnt))) {\n\t\t\tatomic_set(&dev->phy.txerr_cnt,\n\t\t\t\t   B43_PHY_TX_BADNESS_LIMIT);\n\t\t\tb43err(dev->wl, \"Too many PHY TX errors, \"\n\t\t\t\t\t\"restarting the controller\\n\");\n\t\t\tb43_controller_restart(dev, \"PHY TX errors\");\n\t\t}\n\t}\n\n\tif (unlikely(merged_dma_reason & (B43_DMAIRQ_FATALMASK))) {\n\t\tb43err(dev->wl,\n\t\t\t\"Fatal DMA error: 0x%08X, 0x%08X, 0x%08X, 0x%08X, 0x%08X, 0x%08X\\n\",\n\t\t\tdma_reason[0], dma_reason[1],\n\t\t\tdma_reason[2], dma_reason[3],\n\t\t\tdma_reason[4], dma_reason[5]);\n\t\tb43err(dev->wl, \"This device does not support DMA \"\n\t\t\t       \"on your system. It will now be switched to PIO.\\n\");\n\t\t \n\t\tdev->use_pio = true;\n\t\tb43_controller_restart(dev, \"DMA error\");\n\t\treturn;\n\t}\n\n\tif (unlikely(reason & B43_IRQ_UCODE_DEBUG))\n\t\thandle_irq_ucode_debug(dev);\n\tif (reason & B43_IRQ_TBTT_INDI)\n\t\thandle_irq_tbtt_indication(dev);\n\tif (reason & B43_IRQ_ATIM_END)\n\t\thandle_irq_atim_end(dev);\n\tif (reason & B43_IRQ_BEACON)\n\t\thandle_irq_beacon(dev);\n\tif (reason & B43_IRQ_PMQ)\n\t\thandle_irq_pmq(dev);\n\tif (reason & B43_IRQ_TXFIFO_FLUSH_OK) {\n\t\t; \n\t}\n\tif (reason & B43_IRQ_NOISESAMPLE_OK)\n\t\thandle_irq_noise(dev);\n\n\t \n\tif (dma_reason[0] & B43_DMAIRQ_RDESC_UFLOW) {\n\t\tif (B43_DEBUG)\n\t\t\tb43warn(dev->wl, \"RX descriptor underrun\\n\");\n\t\tb43_dma_handle_rx_overflow(dev->dma.rx_ring);\n\t}\n\tif (dma_reason[0] & B43_DMAIRQ_RX_DONE) {\n\t\tif (b43_using_pio_transfers(dev))\n\t\t\tb43_pio_rx(dev->pio.rx_queue);\n\t\telse\n\t\t\tb43_dma_rx(dev->dma.rx_ring);\n\t}\n\tB43_WARN_ON(dma_reason[1] & B43_DMAIRQ_RX_DONE);\n\tB43_WARN_ON(dma_reason[2] & B43_DMAIRQ_RX_DONE);\n\tB43_WARN_ON(dma_reason[3] & B43_DMAIRQ_RX_DONE);\n\tB43_WARN_ON(dma_reason[4] & B43_DMAIRQ_RX_DONE);\n\tB43_WARN_ON(dma_reason[5] & B43_DMAIRQ_RX_DONE);\n\n\tif (reason & B43_IRQ_TX_OK)\n\t\thandle_irq_transmit_status(dev);\n\n\t \n\tb43_write32(dev, B43_MMIO_GEN_IRQ_MASK, dev->irq_mask);\n\n#if B43_DEBUG\n\tif (b43_debug(dev, B43_DBG_VERBOSESTATS)) {\n\t\tdev->irq_count++;\n\t\tfor (i = 0; i < ARRAY_SIZE(dev->irq_bit_count); i++) {\n\t\t\tif (reason & (1 << i))\n\t\t\t\tdev->irq_bit_count[i]++;\n\t\t}\n\t}\n#endif\n}\n\n \nstatic irqreturn_t b43_interrupt_thread_handler(int irq, void *dev_id)\n{\n\tstruct b43_wldev *dev = dev_id;\n\n\tmutex_lock(&dev->wl->mutex);\n\tb43_do_interrupt_thread(dev);\n\tmutex_unlock(&dev->wl->mutex);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t b43_do_interrupt(struct b43_wldev *dev)\n{\n\tu32 reason;\n\n\t \n\n\treason = b43_read32(dev, B43_MMIO_GEN_IRQ_REASON);\n\tif (reason == 0xffffffff)\t \n\t\treturn IRQ_NONE;\n\treason &= dev->irq_mask;\n\tif (!reason)\n\t\treturn IRQ_NONE;\n\n\tdev->dma_reason[0] = b43_read32(dev, B43_MMIO_DMA0_REASON)\n\t    & 0x0001FC00;\n\tdev->dma_reason[1] = b43_read32(dev, B43_MMIO_DMA1_REASON)\n\t    & 0x0000DC00;\n\tdev->dma_reason[2] = b43_read32(dev, B43_MMIO_DMA2_REASON)\n\t    & 0x0000DC00;\n\tdev->dma_reason[3] = b43_read32(dev, B43_MMIO_DMA3_REASON)\n\t    & 0x0001DC00;\n\tdev->dma_reason[4] = b43_read32(dev, B43_MMIO_DMA4_REASON)\n\t    & 0x0000DC00;\n \n\n\t \n\tb43_write32(dev, B43_MMIO_GEN_IRQ_REASON, reason);\n\tb43_write32(dev, B43_MMIO_DMA0_REASON, dev->dma_reason[0]);\n\tb43_write32(dev, B43_MMIO_DMA1_REASON, dev->dma_reason[1]);\n\tb43_write32(dev, B43_MMIO_DMA2_REASON, dev->dma_reason[2]);\n\tb43_write32(dev, B43_MMIO_DMA3_REASON, dev->dma_reason[3]);\n\tb43_write32(dev, B43_MMIO_DMA4_REASON, dev->dma_reason[4]);\n \n\n\t \n\tb43_write32(dev, B43_MMIO_GEN_IRQ_MASK, 0);\n\t \n\tdev->irq_reason = reason;\n\n\treturn IRQ_WAKE_THREAD;\n}\n\n \nstatic irqreturn_t b43_interrupt_handler(int irq, void *dev_id)\n{\n\tstruct b43_wldev *dev = dev_id;\n\tirqreturn_t ret;\n\n\tif (unlikely(b43_status(dev) < B43_STAT_STARTED))\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&dev->wl->hardirq_lock);\n\tret = b43_do_interrupt(dev);\n\tspin_unlock(&dev->wl->hardirq_lock);\n\n\treturn ret;\n}\n\n \nstatic void b43_sdio_interrupt_handler(struct b43_wldev *dev)\n{\n\tstruct b43_wl *wl = dev->wl;\n\tirqreturn_t ret;\n\n\tmutex_lock(&wl->mutex);\n\n\tret = b43_do_interrupt(dev);\n\tif (ret == IRQ_WAKE_THREAD)\n\t\tb43_do_interrupt_thread(dev);\n\n\tmutex_unlock(&wl->mutex);\n}\n\nvoid b43_do_release_fw(struct b43_firmware_file *fw)\n{\n\trelease_firmware(fw->data);\n\tfw->data = NULL;\n\tfw->filename = NULL;\n}\n\nstatic void b43_release_firmware(struct b43_wldev *dev)\n{\n\tcomplete(&dev->fw_load_complete);\n\tb43_do_release_fw(&dev->fw.ucode);\n\tb43_do_release_fw(&dev->fw.pcm);\n\tb43_do_release_fw(&dev->fw.initvals);\n\tb43_do_release_fw(&dev->fw.initvals_band);\n}\n\nstatic void b43_print_fw_helptext(struct b43_wl *wl, bool error)\n{\n\tconst char text[] =\n\t\t\"You must go to \" \\\n\t\t\"https://wireless.wiki.kernel.org/en/users/Drivers/b43#devicefirmware \" \\\n\t\t\"and download the correct firmware for this driver version. \" \\\n\t\t\"Please carefully read all instructions on this website.\\n\";\n\n\tif (error)\n\t\tb43err(wl, text);\n\telse\n\t\tb43warn(wl, text);\n}\n\nstatic void b43_fw_cb(const struct firmware *firmware, void *context)\n{\n\tstruct b43_request_fw_context *ctx = context;\n\n\tctx->blob = firmware;\n\tcomplete(&ctx->dev->fw_load_complete);\n}\n\nint b43_do_request_fw(struct b43_request_fw_context *ctx,\n\t\t      const char *name,\n\t\t      struct b43_firmware_file *fw, bool async)\n{\n\tstruct b43_fw_header *hdr;\n\tu32 size;\n\tint err;\n\n\tif (!name) {\n\t\t \n\t\t \n\t\tb43_do_release_fw(fw);\n\t\treturn 0;\n\t}\n\tif (fw->filename) {\n\t\tif ((fw->type == ctx->req_type) &&\n\t\t    (strcmp(fw->filename, name) == 0))\n\t\t\treturn 0;  \n\t\t \n\t\t \n\t\tb43_do_release_fw(fw);\n\t}\n\n\tswitch (ctx->req_type) {\n\tcase B43_FWTYPE_PROPRIETARY:\n\t\tsnprintf(ctx->fwname, sizeof(ctx->fwname),\n\t\t\t \"b43%s/%s.fw\",\n\t\t\t modparam_fwpostfix, name);\n\t\tbreak;\n\tcase B43_FWTYPE_OPENSOURCE:\n\t\tsnprintf(ctx->fwname, sizeof(ctx->fwname),\n\t\t\t \"b43-open%s/%s.fw\",\n\t\t\t modparam_fwpostfix, name);\n\t\tbreak;\n\tdefault:\n\t\tB43_WARN_ON(1);\n\t\treturn -ENOSYS;\n\t}\n\tif (async) {\n\t\t \n\t\tinit_completion(&ctx->dev->fw_load_complete);\n\t\terr = request_firmware_nowait(THIS_MODULE, 1, ctx->fwname,\n\t\t\t\t\t      ctx->dev->dev->dev, GFP_KERNEL,\n\t\t\t\t\t      ctx, b43_fw_cb);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"Unable to load firmware\\n\");\n\t\t\treturn err;\n\t\t}\n\t\twait_for_completion(&ctx->dev->fw_load_complete);\n\t\tif (ctx->blob)\n\t\t\tgoto fw_ready;\n\t \n\t}\n\terr = request_firmware(&ctx->blob, ctx->fwname,\n\t\t\t       ctx->dev->dev->dev);\n\tif (err == -ENOENT) {\n\t\tsnprintf(ctx->errors[ctx->req_type],\n\t\t\t sizeof(ctx->errors[ctx->req_type]),\n\t\t\t \"Firmware file \\\"%s\\\" not found\\n\",\n\t\t\t ctx->fwname);\n\t\treturn err;\n\t} else if (err) {\n\t\tsnprintf(ctx->errors[ctx->req_type],\n\t\t\t sizeof(ctx->errors[ctx->req_type]),\n\t\t\t \"Firmware file \\\"%s\\\" request failed (err=%d)\\n\",\n\t\t\t ctx->fwname, err);\n\t\treturn err;\n\t}\nfw_ready:\n\tif (ctx->blob->size < sizeof(struct b43_fw_header))\n\t\tgoto err_format;\n\thdr = (struct b43_fw_header *)(ctx->blob->data);\n\tswitch (hdr->type) {\n\tcase B43_FW_TYPE_UCODE:\n\tcase B43_FW_TYPE_PCM:\n\t\tsize = be32_to_cpu(hdr->size);\n\t\tif (size != ctx->blob->size - sizeof(struct b43_fw_header))\n\t\t\tgoto err_format;\n\t\tfallthrough;\n\tcase B43_FW_TYPE_IV:\n\t\tif (hdr->ver != 1)\n\t\t\tgoto err_format;\n\t\tbreak;\n\tdefault:\n\t\tgoto err_format;\n\t}\n\n\tfw->data = ctx->blob;\n\tfw->filename = name;\n\tfw->type = ctx->req_type;\n\n\treturn 0;\n\nerr_format:\n\tsnprintf(ctx->errors[ctx->req_type],\n\t\t sizeof(ctx->errors[ctx->req_type]),\n\t\t \"Firmware file \\\"%s\\\" format error.\\n\", ctx->fwname);\n\trelease_firmware(ctx->blob);\n\n\treturn -EPROTO;\n}\n\n \nstatic int b43_try_request_fw(struct b43_request_fw_context *ctx)\n{\n\tstruct b43_wldev *dev = ctx->dev;\n\tstruct b43_firmware *fw = &ctx->dev->fw;\n\tstruct b43_phy *phy = &dev->phy;\n\tconst u8 rev = ctx->dev->dev->core_rev;\n\tconst char *filename;\n\tint err;\n\n\t \n\tfilename = NULL;\n\tswitch (rev) {\n\tcase 42:\n\t\tif (phy->type == B43_PHYTYPE_AC)\n\t\t\tfilename = \"ucode42\";\n\t\tbreak;\n\tcase 40:\n\t\tif (phy->type == B43_PHYTYPE_AC)\n\t\t\tfilename = \"ucode40\";\n\t\tbreak;\n\tcase 33:\n\t\tif (phy->type == B43_PHYTYPE_LCN40)\n\t\t\tfilename = \"ucode33_lcn40\";\n\t\tbreak;\n\tcase 30:\n\t\tif (phy->type == B43_PHYTYPE_N)\n\t\t\tfilename = \"ucode30_mimo\";\n\t\tbreak;\n\tcase 29:\n\t\tif (phy->type == B43_PHYTYPE_HT)\n\t\t\tfilename = \"ucode29_mimo\";\n\t\tbreak;\n\tcase 26:\n\t\tif (phy->type == B43_PHYTYPE_HT)\n\t\t\tfilename = \"ucode26_mimo\";\n\t\tbreak;\n\tcase 28:\n\tcase 25:\n\t\tif (phy->type == B43_PHYTYPE_N)\n\t\t\tfilename = \"ucode25_mimo\";\n\t\telse if (phy->type == B43_PHYTYPE_LCN)\n\t\t\tfilename = \"ucode25_lcn\";\n\t\tbreak;\n\tcase 24:\n\t\tif (phy->type == B43_PHYTYPE_LCN)\n\t\t\tfilename = \"ucode24_lcn\";\n\t\tbreak;\n\tcase 23:\n\t\tif (phy->type == B43_PHYTYPE_N)\n\t\t\tfilename = \"ucode16_mimo\";\n\t\tbreak;\n\tcase 16 ... 19:\n\t\tif (phy->type == B43_PHYTYPE_N)\n\t\t\tfilename = \"ucode16_mimo\";\n\t\telse if (phy->type == B43_PHYTYPE_LP)\n\t\t\tfilename = \"ucode16_lp\";\n\t\tbreak;\n\tcase 15:\n\t\tfilename = \"ucode15\";\n\t\tbreak;\n\tcase 14:\n\t\tfilename = \"ucode14\";\n\t\tbreak;\n\tcase 13:\n\t\tfilename = \"ucode13\";\n\t\tbreak;\n\tcase 11 ... 12:\n\t\tfilename = \"ucode11\";\n\t\tbreak;\n\tcase 5 ... 10:\n\t\tfilename = \"ucode5\";\n\t\tbreak;\n\t}\n\tif (!filename)\n\t\tgoto err_no_ucode;\n\terr = b43_do_request_fw(ctx, filename, &fw->ucode, true);\n\tif (err)\n\t\tgoto err_load;\n\n\t \n\tif ((rev >= 5) && (rev <= 10))\n\t\tfilename = \"pcm5\";\n\telse if (rev >= 11)\n\t\tfilename = NULL;\n\telse\n\t\tgoto err_no_pcm;\n\tfw->pcm_request_failed = false;\n\terr = b43_do_request_fw(ctx, filename, &fw->pcm, false);\n\tif (err == -ENOENT) {\n\t\t \n\t\tfw->pcm_request_failed = true;\n\t} else if (err)\n\t\tgoto err_load;\n\n\t \n\tfilename = NULL;\n\tswitch (dev->phy.type) {\n\tcase B43_PHYTYPE_G:\n\t\tif (rev == 13)\n\t\t\tfilename = \"b0g0initvals13\";\n\t\telse if (rev >= 5 && rev <= 10)\n\t\t\tfilename = \"b0g0initvals5\";\n\t\tbreak;\n\tcase B43_PHYTYPE_N:\n\t\tif (rev == 30)\n\t\t\tfilename = \"n16initvals30\";\n\t\telse if (rev == 28 || rev == 25)\n\t\t\tfilename = \"n0initvals25\";\n\t\telse if (rev == 24)\n\t\t\tfilename = \"n0initvals24\";\n\t\telse if (rev == 23)\n\t\t\tfilename = \"n0initvals16\";  \n\t\telse if (rev >= 16 && rev <= 18)\n\t\t\tfilename = \"n0initvals16\";\n\t\telse if (rev >= 11 && rev <= 12)\n\t\t\tfilename = \"n0initvals11\";\n\t\tbreak;\n\tcase B43_PHYTYPE_LP:\n\t\tif (rev >= 16 && rev <= 18)\n\t\t\tfilename = \"lp0initvals16\";\n\t\telse if (rev == 15)\n\t\t\tfilename = \"lp0initvals15\";\n\t\telse if (rev == 14)\n\t\t\tfilename = \"lp0initvals14\";\n\t\telse if (rev == 13)\n\t\t\tfilename = \"lp0initvals13\";\n\t\tbreak;\n\tcase B43_PHYTYPE_HT:\n\t\tif (rev == 29)\n\t\t\tfilename = \"ht0initvals29\";\n\t\telse if (rev == 26)\n\t\t\tfilename = \"ht0initvals26\";\n\t\tbreak;\n\tcase B43_PHYTYPE_LCN:\n\t\tif (rev == 24)\n\t\t\tfilename = \"lcn0initvals24\";\n\t\tbreak;\n\tcase B43_PHYTYPE_LCN40:\n\t\tif (rev == 33)\n\t\t\tfilename = \"lcn400initvals33\";\n\t\tbreak;\n\tcase B43_PHYTYPE_AC:\n\t\tif (rev == 42)\n\t\t\tfilename = \"ac1initvals42\";\n\t\telse if (rev == 40)\n\t\t\tfilename = \"ac0initvals40\";\n\t\tbreak;\n\t}\n\tif (!filename)\n\t\tgoto err_no_initvals;\n\terr = b43_do_request_fw(ctx, filename, &fw->initvals, false);\n\tif (err)\n\t\tgoto err_load;\n\n\t \n\tfilename = NULL;\n\tswitch (dev->phy.type) {\n\tcase B43_PHYTYPE_G:\n\t\tif (rev == 13)\n\t\t\tfilename = \"b0g0bsinitvals13\";\n\t\telse if (rev >= 5 && rev <= 10)\n\t\t\tfilename = \"b0g0bsinitvals5\";\n\t\tbreak;\n\tcase B43_PHYTYPE_N:\n\t\tif (rev == 30)\n\t\t\tfilename = \"n16bsinitvals30\";\n\t\telse if (rev == 28 || rev == 25)\n\t\t\tfilename = \"n0bsinitvals25\";\n\t\telse if (rev == 24)\n\t\t\tfilename = \"n0bsinitvals24\";\n\t\telse if (rev == 23)\n\t\t\tfilename = \"n0bsinitvals16\";  \n\t\telse if (rev >= 16 && rev <= 18)\n\t\t\tfilename = \"n0bsinitvals16\";\n\t\telse if (rev >= 11 && rev <= 12)\n\t\t\tfilename = \"n0bsinitvals11\";\n\t\tbreak;\n\tcase B43_PHYTYPE_LP:\n\t\tif (rev >= 16 && rev <= 18)\n\t\t\tfilename = \"lp0bsinitvals16\";\n\t\telse if (rev == 15)\n\t\t\tfilename = \"lp0bsinitvals15\";\n\t\telse if (rev == 14)\n\t\t\tfilename = \"lp0bsinitvals14\";\n\t\telse if (rev == 13)\n\t\t\tfilename = \"lp0bsinitvals13\";\n\t\tbreak;\n\tcase B43_PHYTYPE_HT:\n\t\tif (rev == 29)\n\t\t\tfilename = \"ht0bsinitvals29\";\n\t\telse if (rev == 26)\n\t\t\tfilename = \"ht0bsinitvals26\";\n\t\tbreak;\n\tcase B43_PHYTYPE_LCN:\n\t\tif (rev == 24)\n\t\t\tfilename = \"lcn0bsinitvals24\";\n\t\tbreak;\n\tcase B43_PHYTYPE_LCN40:\n\t\tif (rev == 33)\n\t\t\tfilename = \"lcn400bsinitvals33\";\n\t\tbreak;\n\tcase B43_PHYTYPE_AC:\n\t\tif (rev == 42)\n\t\t\tfilename = \"ac1bsinitvals42\";\n\t\telse if (rev == 40)\n\t\t\tfilename = \"ac0bsinitvals40\";\n\t\tbreak;\n\t}\n\tif (!filename)\n\t\tgoto err_no_initvals;\n\terr = b43_do_request_fw(ctx, filename, &fw->initvals_band, false);\n\tif (err)\n\t\tgoto err_load;\n\n\tfw->opensource = (ctx->req_type == B43_FWTYPE_OPENSOURCE);\n\n\treturn 0;\n\nerr_no_ucode:\n\terr = ctx->fatal_failure = -EOPNOTSUPP;\n\tb43err(dev->wl, \"The driver does not know which firmware (ucode) \"\n\t       \"is required for your device (wl-core rev %u)\\n\", rev);\n\tgoto error;\n\nerr_no_pcm:\n\terr = ctx->fatal_failure = -EOPNOTSUPP;\n\tb43err(dev->wl, \"The driver does not know which firmware (PCM) \"\n\t       \"is required for your device (wl-core rev %u)\\n\", rev);\n\tgoto error;\n\nerr_no_initvals:\n\terr = ctx->fatal_failure = -EOPNOTSUPP;\n\tb43err(dev->wl, \"The driver does not know which firmware (initvals) \"\n\t       \"is required for your device (wl-core rev %u)\\n\", rev);\n\tgoto error;\n\nerr_load:\n\t \n\tgoto error;\n\nerror:\n\tb43_release_firmware(dev);\n\treturn err;\n}\n\nstatic int b43_one_core_attach(struct b43_bus_dev *dev, struct b43_wl *wl);\nstatic void b43_one_core_detach(struct b43_bus_dev *dev);\nstatic int b43_rng_init(struct b43_wl *wl);\n\nstatic void b43_request_firmware(struct work_struct *work)\n{\n\tstruct b43_wl *wl = container_of(work,\n\t\t\t    struct b43_wl, firmware_load);\n\tstruct b43_wldev *dev = wl->current_dev;\n\tstruct b43_request_fw_context *ctx;\n\tunsigned int i;\n\tint err;\n\tconst char *errmsg;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn;\n\tctx->dev = dev;\n\n\tctx->req_type = B43_FWTYPE_PROPRIETARY;\n\terr = b43_try_request_fw(ctx);\n\tif (!err)\n\t\tgoto start_ieee80211;  \n\t \n\tif (ctx->fatal_failure)\n\t\tgoto out;\n\n\t \n\tctx->req_type = B43_FWTYPE_OPENSOURCE;\n\terr = b43_try_request_fw(ctx);\n\tif (!err)\n\t\tgoto start_ieee80211;  \n\tif(ctx->fatal_failure)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < B43_NR_FWTYPES; i++) {\n\t\terrmsg = ctx->errors[i];\n\t\tif (strlen(errmsg))\n\t\t\tb43err(dev->wl, \"%s\", errmsg);\n\t}\n\tb43_print_fw_helptext(dev->wl, 1);\n\tgoto out;\n\nstart_ieee80211:\n\twl->hw->queues = B43_QOS_QUEUE_NUM;\n\tif (!modparam_qos || dev->fw.opensource)\n\t\twl->hw->queues = 1;\n\n\terr = ieee80211_register_hw(wl->hw);\n\tif (err)\n\t\tgoto out;\n\twl->hw_registered = true;\n\tb43_leds_register(wl->current_dev);\n\n\t \n\tb43_rng_init(wl);\n\nout:\n\tkfree(ctx);\n}\n\nstatic int b43_upload_microcode(struct b43_wldev *dev)\n{\n\tstruct wiphy *wiphy = dev->wl->hw->wiphy;\n\tconst size_t hdr_len = sizeof(struct b43_fw_header);\n\tconst __be32 *data;\n\tunsigned int i, len;\n\tu16 fwrev, fwpatch, fwdate, fwtime;\n\tu32 tmp, macctl;\n\tint err = 0;\n\n\t \n\tmacctl = b43_read32(dev, B43_MMIO_MACCTL);\n\tB43_WARN_ON(macctl & B43_MACCTL_PSM_RUN);\n\tmacctl |= B43_MACCTL_PSM_JMP0;\n\tb43_write32(dev, B43_MMIO_MACCTL, macctl);\n\t \n\tfor (i = 0; i < 64; i++)\n\t\tb43_shm_write16(dev, B43_SHM_SCRATCH, i, 0);\n\tfor (i = 0; i < 4096; i += 2)\n\t\tb43_shm_write16(dev, B43_SHM_SHARED, i, 0);\n\n\t \n\tdata = (__be32 *) (dev->fw.ucode.data->data + hdr_len);\n\tlen = (dev->fw.ucode.data->size - hdr_len) / sizeof(__be32);\n\tb43_shm_control_word(dev, B43_SHM_UCODE | B43_SHM_AUTOINC_W, 0x0000);\n\tfor (i = 0; i < len; i++) {\n\t\tb43_write32(dev, B43_MMIO_SHM_DATA, be32_to_cpu(data[i]));\n\t\tudelay(10);\n\t}\n\n\tif (dev->fw.pcm.data) {\n\t\t \n\t\tdata = (__be32 *) (dev->fw.pcm.data->data + hdr_len);\n\t\tlen = (dev->fw.pcm.data->size - hdr_len) / sizeof(__be32);\n\t\tb43_shm_control_word(dev, B43_SHM_HW, 0x01EA);\n\t\tb43_write32(dev, B43_MMIO_SHM_DATA, 0x00004000);\n\t\t \n\t\tb43_shm_control_word(dev, B43_SHM_HW, 0x01EB);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tb43_write32(dev, B43_MMIO_SHM_DATA, be32_to_cpu(data[i]));\n\t\t\tudelay(10);\n\t\t}\n\t}\n\n\tb43_write32(dev, B43_MMIO_GEN_IRQ_REASON, B43_IRQ_ALL);\n\n\t \n\tb43_maskset32(dev, B43_MMIO_MACCTL, ~B43_MACCTL_PSM_JMP0,\n\t\t      B43_MACCTL_PSM_RUN);\n\n\t \n\ti = 0;\n\twhile (1) {\n\t\ttmp = b43_read32(dev, B43_MMIO_GEN_IRQ_REASON);\n\t\tif (tmp == B43_IRQ_MAC_SUSPENDED)\n\t\t\tbreak;\n\t\ti++;\n\t\tif (i >= 20) {\n\t\t\tb43err(dev->wl, \"Microcode not responding\\n\");\n\t\t\tb43_print_fw_helptext(dev->wl, 1);\n\t\t\terr = -ENODEV;\n\t\t\tgoto error;\n\t\t}\n\t\tmsleep(50);\n\t}\n\tb43_read32(dev, B43_MMIO_GEN_IRQ_REASON);\t \n\n\t \n\tfwrev = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_UCODEREV);\n\tfwpatch = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_UCODEPATCH);\n\tfwdate = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_UCODEDATE);\n\tfwtime = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_UCODETIME);\n\n\tif (fwrev <= 0x128) {\n\t\tb43err(dev->wl, \"YOUR FIRMWARE IS TOO OLD. Firmware from \"\n\t\t       \"binary drivers older than version 4.x is unsupported. \"\n\t\t       \"You must upgrade your firmware files.\\n\");\n\t\tb43_print_fw_helptext(dev->wl, 1);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\tdev->fw.rev = fwrev;\n\tdev->fw.patch = fwpatch;\n\tif (dev->fw.rev >= 598)\n\t\tdev->fw.hdr_format = B43_FW_HDR_598;\n\telse if (dev->fw.rev >= 410)\n\t\tdev->fw.hdr_format = B43_FW_HDR_410;\n\telse\n\t\tdev->fw.hdr_format = B43_FW_HDR_351;\n\tWARN_ON(dev->fw.opensource != (fwdate == 0xFFFF));\n\n\tdev->qos_enabled = dev->wl->hw->queues > 1;\n\t \n\tdev->hwcrypto_enabled = true;\n\n\tif (dev->fw.opensource) {\n\t\tu16 fwcapa;\n\n\t\t \n\t\tdev->fw.patch = fwtime;\n\t\tb43info(dev->wl, \"Loading OpenSource firmware version %u.%u\\n\",\n\t\t\tdev->fw.rev, dev->fw.patch);\n\n\t\tfwcapa = b43_fwcapa_read(dev);\n\t\tif (!(fwcapa & B43_FWCAPA_HWCRYPTO) || dev->fw.pcm_request_failed) {\n\t\t\tb43info(dev->wl, \"Hardware crypto acceleration not supported by firmware\\n\");\n\t\t\t \n\t\t\tdev->hwcrypto_enabled = false;\n\t\t}\n\t\t \n\t\tWARN(fwcapa & B43_FWCAPA_QOS, \"QoS in OpenFW not supported\\n\");\n\t} else {\n\t\tb43info(dev->wl, \"Loading firmware version %u.%u \"\n\t\t\t\"(20%.2i-%.2i-%.2i %.2i:%.2i:%.2i)\\n\",\n\t\t\tfwrev, fwpatch,\n\t\t\t(fwdate >> 12) & 0xF, (fwdate >> 8) & 0xF, fwdate & 0xFF,\n\t\t\t(fwtime >> 11) & 0x1F, (fwtime >> 5) & 0x3F, fwtime & 0x1F);\n\t\tif (dev->fw.pcm_request_failed) {\n\t\t\tb43warn(dev->wl, \"No \\\"pcm5.fw\\\" firmware file found. \"\n\t\t\t\t\"Hardware accelerated cryptography is disabled.\\n\");\n\t\t\tb43_print_fw_helptext(dev->wl, 0);\n\t\t}\n\t}\n\n\tsnprintf(wiphy->fw_version, sizeof(wiphy->fw_version), \"%u.%u\",\n\t\t\tdev->fw.rev, dev->fw.patch);\n\twiphy->hw_version = dev->dev->core_id;\n\n\tif (dev->fw.hdr_format == B43_FW_HDR_351) {\n\t\t \n\t\tb43warn(dev->wl, \"You are using an old firmware image. \"\n\t\t\t\"Support for old firmware will be removed soon \"\n\t\t\t\"(official deadline was July 2008).\\n\");\n\t\tb43_print_fw_helptext(dev->wl, 0);\n\t}\n\n\treturn 0;\n\nerror:\n\t \n\tb43_maskset32(dev, B43_MMIO_MACCTL, ~B43_MACCTL_PSM_RUN,\n\t\t      B43_MACCTL_PSM_JMP0);\n\n\treturn err;\n}\n\nstatic int b43_write_initvals(struct b43_wldev *dev,\n\t\t\t      const struct b43_iv *ivals,\n\t\t\t      size_t count,\n\t\t\t      size_t array_size)\n{\n\tconst struct b43_iv *iv;\n\tu16 offset;\n\tsize_t i;\n\tbool bit32;\n\n\tBUILD_BUG_ON(sizeof(struct b43_iv) != 6);\n\tiv = ivals;\n\tfor (i = 0; i < count; i++) {\n\t\tif (array_size < sizeof(iv->offset_size))\n\t\t\tgoto err_format;\n\t\tarray_size -= sizeof(iv->offset_size);\n\t\toffset = be16_to_cpu(iv->offset_size);\n\t\tbit32 = !!(offset & B43_IV_32BIT);\n\t\toffset &= B43_IV_OFFSET_MASK;\n\t\tif (offset >= 0x1000)\n\t\t\tgoto err_format;\n\t\tif (bit32) {\n\t\t\tu32 value;\n\n\t\t\tif (array_size < sizeof(iv->data.d32))\n\t\t\t\tgoto err_format;\n\t\t\tarray_size -= sizeof(iv->data.d32);\n\n\t\t\tvalue = get_unaligned_be32(&iv->data.d32);\n\t\t\tb43_write32(dev, offset, value);\n\n\t\t\tiv = (const struct b43_iv *)((const uint8_t *)iv +\n\t\t\t\t\t\t\tsizeof(__be16) +\n\t\t\t\t\t\t\tsizeof(__be32));\n\t\t} else {\n\t\t\tu16 value;\n\n\t\t\tif (array_size < sizeof(iv->data.d16))\n\t\t\t\tgoto err_format;\n\t\t\tarray_size -= sizeof(iv->data.d16);\n\n\t\t\tvalue = be16_to_cpu(iv->data.d16);\n\t\t\tb43_write16(dev, offset, value);\n\n\t\t\tiv = (const struct b43_iv *)((const uint8_t *)iv +\n\t\t\t\t\t\t\tsizeof(__be16) +\n\t\t\t\t\t\t\tsizeof(__be16));\n\t\t}\n\t}\n\tif (array_size)\n\t\tgoto err_format;\n\n\treturn 0;\n\nerr_format:\n\tb43err(dev->wl, \"Initial Values Firmware file-format error.\\n\");\n\tb43_print_fw_helptext(dev->wl, 1);\n\n\treturn -EPROTO;\n}\n\nstatic int b43_upload_initvals(struct b43_wldev *dev)\n{\n\tconst size_t hdr_len = sizeof(struct b43_fw_header);\n\tconst struct b43_fw_header *hdr;\n\tstruct b43_firmware *fw = &dev->fw;\n\tconst struct b43_iv *ivals;\n\tsize_t count;\n\n\thdr = (const struct b43_fw_header *)(fw->initvals.data->data);\n\tivals = (const struct b43_iv *)(fw->initvals.data->data + hdr_len);\n\tcount = be32_to_cpu(hdr->size);\n\treturn b43_write_initvals(dev, ivals, count,\n\t\t\t\t fw->initvals.data->size - hdr_len);\n}\n\nstatic int b43_upload_initvals_band(struct b43_wldev *dev)\n{\n\tconst size_t hdr_len = sizeof(struct b43_fw_header);\n\tconst struct b43_fw_header *hdr;\n\tstruct b43_firmware *fw = &dev->fw;\n\tconst struct b43_iv *ivals;\n\tsize_t count;\n\n\tif (!fw->initvals_band.data)\n\t\treturn 0;\n\n\thdr = (const struct b43_fw_header *)(fw->initvals_band.data->data);\n\tivals = (const struct b43_iv *)(fw->initvals_band.data->data + hdr_len);\n\tcount = be32_to_cpu(hdr->size);\n\treturn b43_write_initvals(dev, ivals, count,\n\t\t\t\t  fw->initvals_band.data->size - hdr_len);\n}\n\n \n\n#ifdef CONFIG_B43_SSB\nstatic struct ssb_device *b43_ssb_gpio_dev(struct b43_wldev *dev)\n{\n\tstruct ssb_bus *bus = dev->dev->sdev->bus;\n\n#ifdef CONFIG_SSB_DRIVER_PCICORE\n\treturn (bus->chipco.dev ? bus->chipco.dev : bus->pcicore.dev);\n#else\n\treturn bus->chipco.dev;\n#endif\n}\n#endif\n\nstatic int b43_gpio_init(struct b43_wldev *dev)\n{\n#ifdef CONFIG_B43_SSB\n\tstruct ssb_device *gpiodev;\n#endif\n\tu32 mask, set;\n\n\tb43_maskset32(dev, B43_MMIO_MACCTL, ~B43_MACCTL_GPOUTSMSK, 0);\n\tb43_maskset16(dev, B43_MMIO_GPIO_MASK, ~0, 0xF);\n\n\tmask = 0x0000001F;\n\tset = 0x0000000F;\n\tif (dev->dev->chip_id == 0x4301) {\n\t\tmask |= 0x0060;\n\t\tset |= 0x0060;\n\t} else if (dev->dev->chip_id == 0x5354) {\n\t\t \n\t\tset &= 0x2;  \n\t}\n\n\tif (0   ) {\n\t\tb43_write16(dev, B43_MMIO_GPIO_MASK,\n\t\t\t    b43_read16(dev, B43_MMIO_GPIO_MASK)\n\t\t\t    | 0x0100);\n\t\t \n\t\tmask |= 0x0080;\n\t\tset |= 0x0080;\n\t\t \n\t\tmask |= 0x0100;\n\t\tset |= 0x0100;\n\t}\n\tif (dev->dev->bus_sprom->boardflags_lo & B43_BFL_PACTRL) {\n\t\t \n\t\tb43_write16(dev, B43_MMIO_GPIO_MASK,\n\t\t\t    b43_read16(dev, B43_MMIO_GPIO_MASK)\n\t\t\t    | 0x0200);\n\t\tmask |= 0x0200;\n\t\tset |= 0x0200;\n\t}\n\n\tswitch (dev->dev->bus_type) {\n#ifdef CONFIG_B43_BCMA\n\tcase B43_BUS_BCMA:\n\t\tbcma_chipco_gpio_control(&dev->dev->bdev->bus->drv_cc, mask, set);\n\t\tbreak;\n#endif\n#ifdef CONFIG_B43_SSB\n\tcase B43_BUS_SSB:\n\t\tgpiodev = b43_ssb_gpio_dev(dev);\n\t\tif (gpiodev)\n\t\t\tssb_write32(gpiodev, B43_GPIO_CONTROL,\n\t\t\t\t    (ssb_read32(gpiodev, B43_GPIO_CONTROL)\n\t\t\t\t    & ~mask) | set);\n\t\tbreak;\n#endif\n\t}\n\n\treturn 0;\n}\n\n \nstatic void b43_gpio_cleanup(struct b43_wldev *dev)\n{\n#ifdef CONFIG_B43_SSB\n\tstruct ssb_device *gpiodev;\n#endif\n\n\tswitch (dev->dev->bus_type) {\n#ifdef CONFIG_B43_BCMA\n\tcase B43_BUS_BCMA:\n\t\tbcma_chipco_gpio_control(&dev->dev->bdev->bus->drv_cc, ~0, 0);\n\t\tbreak;\n#endif\n#ifdef CONFIG_B43_SSB\n\tcase B43_BUS_SSB:\n\t\tgpiodev = b43_ssb_gpio_dev(dev);\n\t\tif (gpiodev)\n\t\t\tssb_write32(gpiodev, B43_GPIO_CONTROL, 0);\n\t\tbreak;\n#endif\n\t}\n}\n\n \nvoid b43_mac_enable(struct b43_wldev *dev)\n{\n\tif (b43_debug(dev, B43_DBG_FIRMWARE)) {\n\t\tu16 fwstate;\n\n\t\tfwstate = b43_shm_read16(dev, B43_SHM_SHARED,\n\t\t\t\t\t B43_SHM_SH_UCODESTAT);\n\t\tif ((fwstate != B43_SHM_SH_UCODESTAT_SUSP) &&\n\t\t    (fwstate != B43_SHM_SH_UCODESTAT_SLEEP)) {\n\t\t\tb43err(dev->wl, \"b43_mac_enable(): The firmware \"\n\t\t\t       \"should be suspended, but current state is %u\\n\",\n\t\t\t       fwstate);\n\t\t}\n\t}\n\n\tdev->mac_suspended--;\n\tB43_WARN_ON(dev->mac_suspended < 0);\n\tif (dev->mac_suspended == 0) {\n\t\tb43_maskset32(dev, B43_MMIO_MACCTL, ~0, B43_MACCTL_ENABLED);\n\t\tb43_write32(dev, B43_MMIO_GEN_IRQ_REASON,\n\t\t\t    B43_IRQ_MAC_SUSPENDED);\n\t\t \n\t\tb43_read32(dev, B43_MMIO_MACCTL);\n\t\tb43_read32(dev, B43_MMIO_GEN_IRQ_REASON);\n\t\tb43_power_saving_ctl_bits(dev, 0);\n\t}\n}\n\n \nvoid b43_mac_suspend(struct b43_wldev *dev)\n{\n\tint i;\n\tu32 tmp;\n\n\tmight_sleep();\n\tB43_WARN_ON(dev->mac_suspended < 0);\n\n\tif (dev->mac_suspended == 0) {\n\t\tb43_power_saving_ctl_bits(dev, B43_PS_AWAKE);\n\t\tb43_maskset32(dev, B43_MMIO_MACCTL, ~B43_MACCTL_ENABLED, 0);\n\t\t \n\t\tb43_read32(dev, B43_MMIO_MACCTL);\n\t\tfor (i = 35; i; i--) {\n\t\t\ttmp = b43_read32(dev, B43_MMIO_GEN_IRQ_REASON);\n\t\t\tif (tmp & B43_IRQ_MAC_SUSPENDED)\n\t\t\t\tgoto out;\n\t\t\tudelay(10);\n\t\t}\n\t\t \n\t\tfor (i = 40; i; i--) {\n\t\t\ttmp = b43_read32(dev, B43_MMIO_GEN_IRQ_REASON);\n\t\t\tif (tmp & B43_IRQ_MAC_SUSPENDED)\n\t\t\t\tgoto out;\n\t\t\tmsleep(1);\n\t\t}\n\t\tb43err(dev->wl, \"MAC suspend failed\\n\");\n\t}\nout:\n\tdev->mac_suspended++;\n}\n\n \nvoid b43_mac_phy_clock_set(struct b43_wldev *dev, bool on)\n{\n\tu32 tmp;\n\n\tswitch (dev->dev->bus_type) {\n#ifdef CONFIG_B43_BCMA\n\tcase B43_BUS_BCMA:\n\t\ttmp = bcma_aread32(dev->dev->bdev, BCMA_IOCTL);\n\t\tif (on)\n\t\t\ttmp |= B43_BCMA_IOCTL_MACPHYCLKEN;\n\t\telse\n\t\t\ttmp &= ~B43_BCMA_IOCTL_MACPHYCLKEN;\n\t\tbcma_awrite32(dev->dev->bdev, BCMA_IOCTL, tmp);\n\t\tbreak;\n#endif\n#ifdef CONFIG_B43_SSB\n\tcase B43_BUS_SSB:\n\t\ttmp = ssb_read32(dev->dev->sdev, SSB_TMSLOW);\n\t\tif (on)\n\t\t\ttmp |= B43_TMSLOW_MACPHYCLKEN;\n\t\telse\n\t\t\ttmp &= ~B43_TMSLOW_MACPHYCLKEN;\n\t\tssb_write32(dev->dev->sdev, SSB_TMSLOW, tmp);\n\t\tbreak;\n#endif\n\t}\n}\n\n \nvoid b43_mac_switch_freq(struct b43_wldev *dev, u8 spurmode)\n{\n\tu16 chip_id = dev->dev->chip_id;\n\n\tif (chip_id == BCMA_CHIP_ID_BCM4331) {\n\t\tswitch (spurmode) {\n\t\tcase 2:  \n\t\t\tb43_write16(dev, B43_MMIO_TSF_CLK_FRAC_LOW, 0x1862);\n\t\t\tb43_write16(dev, B43_MMIO_TSF_CLK_FRAC_HIGH, 0x6);\n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\tb43_write16(dev, B43_MMIO_TSF_CLK_FRAC_LOW, 0x3e70);\n\t\t\tb43_write16(dev, B43_MMIO_TSF_CLK_FRAC_HIGH, 0x6);\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\tb43_write16(dev, B43_MMIO_TSF_CLK_FRAC_LOW, 0x6666);\n\t\t\tb43_write16(dev, B43_MMIO_TSF_CLK_FRAC_HIGH, 0x6);\n\t\t\tbreak;\n\t\t}\n\t} else if (chip_id == BCMA_CHIP_ID_BCM43131 ||\n\t    chip_id == BCMA_CHIP_ID_BCM43217 ||\n\t    chip_id == BCMA_CHIP_ID_BCM43222 ||\n\t    chip_id == BCMA_CHIP_ID_BCM43224 ||\n\t    chip_id == BCMA_CHIP_ID_BCM43225 ||\n\t    chip_id == BCMA_CHIP_ID_BCM43227 ||\n\t    chip_id == BCMA_CHIP_ID_BCM43228) {\n\t\tswitch (spurmode) {\n\t\tcase 2:  \n\t\t\tb43_write16(dev, B43_MMIO_TSF_CLK_FRAC_LOW, 0x2082);\n\t\t\tb43_write16(dev, B43_MMIO_TSF_CLK_FRAC_HIGH, 0x8);\n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\tb43_write16(dev, B43_MMIO_TSF_CLK_FRAC_LOW, 0x5341);\n\t\t\tb43_write16(dev, B43_MMIO_TSF_CLK_FRAC_HIGH, 0x8);\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\tb43_write16(dev, B43_MMIO_TSF_CLK_FRAC_LOW, 0x8889);\n\t\t\tb43_write16(dev, B43_MMIO_TSF_CLK_FRAC_HIGH, 0x8);\n\t\t\tbreak;\n\t\t}\n\t} else if (dev->phy.type == B43_PHYTYPE_LCN) {\n\t\tswitch (spurmode) {\n\t\tcase 1:  \n\t\t\tb43_write16(dev, B43_MMIO_TSF_CLK_FRAC_LOW, 0x7CE0);\n\t\t\tb43_write16(dev, B43_MMIO_TSF_CLK_FRAC_HIGH, 0xC);\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\tb43_write16(dev, B43_MMIO_TSF_CLK_FRAC_LOW, 0xCCCD);\n\t\t\tb43_write16(dev, B43_MMIO_TSF_CLK_FRAC_HIGH, 0xC);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void b43_adjust_opmode(struct b43_wldev *dev)\n{\n\tstruct b43_wl *wl = dev->wl;\n\tu32 ctl;\n\tu16 cfp_pretbtt;\n\n\tctl = b43_read32(dev, B43_MMIO_MACCTL);\n\t \n\tctl &= ~B43_MACCTL_AP;\n\tctl &= ~B43_MACCTL_KEEP_CTL;\n\tctl &= ~B43_MACCTL_KEEP_BADPLCP;\n\tctl &= ~B43_MACCTL_KEEP_BAD;\n\tctl &= ~B43_MACCTL_PROMISC;\n\tctl &= ~B43_MACCTL_BEACPROMISC;\n\tctl |= B43_MACCTL_INFRA;\n\n\tif (b43_is_mode(wl, NL80211_IFTYPE_AP) ||\n\t    b43_is_mode(wl, NL80211_IFTYPE_MESH_POINT))\n\t\tctl |= B43_MACCTL_AP;\n\telse if (b43_is_mode(wl, NL80211_IFTYPE_ADHOC))\n\t\tctl &= ~B43_MACCTL_INFRA;\n\n\tif (wl->filter_flags & FIF_CONTROL)\n\t\tctl |= B43_MACCTL_KEEP_CTL;\n\tif (wl->filter_flags & FIF_FCSFAIL)\n\t\tctl |= B43_MACCTL_KEEP_BAD;\n\tif (wl->filter_flags & FIF_PLCPFAIL)\n\t\tctl |= B43_MACCTL_KEEP_BADPLCP;\n\tif (wl->filter_flags & FIF_BCN_PRBRESP_PROMISC)\n\t\tctl |= B43_MACCTL_BEACPROMISC;\n\n\t \n\tif (dev->dev->core_rev <= 4)\n\t\tctl |= B43_MACCTL_PROMISC;\n\n\tb43_write32(dev, B43_MMIO_MACCTL, ctl);\n\n\tcfp_pretbtt = 2;\n\tif ((ctl & B43_MACCTL_INFRA) && !(ctl & B43_MACCTL_AP)) {\n\t\tif (dev->dev->chip_id == 0x4306 &&\n\t\t    dev->dev->chip_rev == 3)\n\t\t\tcfp_pretbtt = 100;\n\t\telse\n\t\t\tcfp_pretbtt = 50;\n\t}\n\tb43_write16(dev, 0x612, cfp_pretbtt);\n\n\t \n\tif (0   )\n\t\tb43_maskset32(dev, B43_MMIO_MACCTL, ~B43_MACCTL_DISCPMQ, 0);\n\telse\n\t\tb43_maskset32(dev, B43_MMIO_MACCTL, ~0, B43_MACCTL_DISCPMQ);\n}\n\nstatic void b43_rate_memory_write(struct b43_wldev *dev, u16 rate, int is_ofdm)\n{\n\tu16 offset;\n\n\tif (is_ofdm) {\n\t\toffset = 0x480;\n\t\toffset += (b43_plcp_get_ratecode_ofdm(rate) & 0x000F) * 2;\n\t} else {\n\t\toffset = 0x4C0;\n\t\toffset += (b43_plcp_get_ratecode_cck(rate) & 0x000F) * 2;\n\t}\n\tb43_shm_write16(dev, B43_SHM_SHARED, offset + 0x20,\n\t\t\tb43_shm_read16(dev, B43_SHM_SHARED, offset));\n}\n\nstatic void b43_rate_memory_init(struct b43_wldev *dev)\n{\n\tswitch (dev->phy.type) {\n\tcase B43_PHYTYPE_G:\n\tcase B43_PHYTYPE_N:\n\tcase B43_PHYTYPE_LP:\n\tcase B43_PHYTYPE_HT:\n\tcase B43_PHYTYPE_LCN:\n\t\tb43_rate_memory_write(dev, B43_OFDM_RATE_6MB, 1);\n\t\tb43_rate_memory_write(dev, B43_OFDM_RATE_9MB, 1);\n\t\tb43_rate_memory_write(dev, B43_OFDM_RATE_12MB, 1);\n\t\tb43_rate_memory_write(dev, B43_OFDM_RATE_18MB, 1);\n\t\tb43_rate_memory_write(dev, B43_OFDM_RATE_24MB, 1);\n\t\tb43_rate_memory_write(dev, B43_OFDM_RATE_36MB, 1);\n\t\tb43_rate_memory_write(dev, B43_OFDM_RATE_48MB, 1);\n\t\tb43_rate_memory_write(dev, B43_OFDM_RATE_54MB, 1);\n\t\tfallthrough;\n\tcase B43_PHYTYPE_B:\n\t\tb43_rate_memory_write(dev, B43_CCK_RATE_1MB, 0);\n\t\tb43_rate_memory_write(dev, B43_CCK_RATE_2MB, 0);\n\t\tb43_rate_memory_write(dev, B43_CCK_RATE_5MB, 0);\n\t\tb43_rate_memory_write(dev, B43_CCK_RATE_11MB, 0);\n\t\tbreak;\n\tdefault:\n\t\tB43_WARN_ON(1);\n\t}\n}\n\n \nstatic void b43_set_phytxctl_defaults(struct b43_wldev *dev)\n{\n\tu16 ctl = 0;\n\n\tctl |= B43_TXH_PHY_ENC_CCK;\n\tctl |= B43_TXH_PHY_ANT01AUTO;\n\tctl |= B43_TXH_PHY_TXPWR;\n\n\tb43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_BEACPHYCTL, ctl);\n\tb43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_ACKCTSPHYCTL, ctl);\n\tb43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_PRPHYCTL, ctl);\n}\n\n \nstatic void b43_mgmtframe_txantenna(struct b43_wldev *dev, int antenna)\n{\n\tu16 ant;\n\tu16 tmp;\n\n\tant = b43_antenna_to_phyctl(antenna);\n\n\t \n\ttmp = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_ACKCTSPHYCTL);\n\ttmp = (tmp & ~B43_TXH_PHY_ANT) | ant;\n\tb43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_ACKCTSPHYCTL, tmp);\n\t \n\ttmp = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_PRPHYCTL);\n\ttmp = (tmp & ~B43_TXH_PHY_ANT) | ant;\n\tb43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_PRPHYCTL, tmp);\n}\n\n \nstatic void b43_chip_exit(struct b43_wldev *dev)\n{\n\tb43_phy_exit(dev);\n\tb43_gpio_cleanup(dev);\n\t \n}\n\n \nstatic int b43_chip_init(struct b43_wldev *dev)\n{\n\tstruct b43_phy *phy = &dev->phy;\n\tint err;\n\tu32 macctl;\n\tu16 value16;\n\n\t \n\tmacctl = B43_MACCTL_IHR_ENABLED | B43_MACCTL_SHM_ENABLED;\n\tif (dev->phy.gmode)\n\t\tmacctl |= B43_MACCTL_GMODE;\n\tmacctl |= B43_MACCTL_INFRA;\n\tb43_write32(dev, B43_MMIO_MACCTL, macctl);\n\n\terr = b43_upload_microcode(dev);\n\tif (err)\n\t\tgoto out;\t \n\n\terr = b43_gpio_init(dev);\n\tif (err)\n\t\tgoto out;\t \n\n\terr = b43_upload_initvals(dev);\n\tif (err)\n\t\tgoto err_gpio_clean;\n\n\terr = b43_upload_initvals_band(dev);\n\tif (err)\n\t\tgoto err_gpio_clean;\n\n\t \n\tphy->ops->switch_analog(dev, 1);\n\terr = b43_phy_init(dev);\n\tif (err)\n\t\tgoto err_gpio_clean;\n\n\t \n\tif (phy->ops->interf_mitigation)\n\t\tphy->ops->interf_mitigation(dev, B43_INTERFMODE_NONE);\n\n\t \n\tif (phy->ops->set_rx_antenna)\n\t\tphy->ops->set_rx_antenna(dev, B43_ANTENNA_DEFAULT);\n\tb43_mgmtframe_txantenna(dev, B43_ANTENNA_DEFAULT);\n\n\tif (phy->type == B43_PHYTYPE_B) {\n\t\tvalue16 = b43_read16(dev, 0x005E);\n\t\tvalue16 |= 0x0004;\n\t\tb43_write16(dev, 0x005E, value16);\n\t}\n\tb43_write32(dev, 0x0100, 0x01000000);\n\tif (dev->dev->core_rev < 5)\n\t\tb43_write32(dev, 0x010C, 0x01000000);\n\n\tb43_maskset32(dev, B43_MMIO_MACCTL, ~B43_MACCTL_INFRA, 0);\n\tb43_maskset32(dev, B43_MMIO_MACCTL, ~0, B43_MACCTL_INFRA);\n\n\t \n\t \n\tb43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_PRMAXTIME, 0);\n\n\t \n\tb43_adjust_opmode(dev);\n\n\tif (dev->dev->core_rev < 3) {\n\t\tb43_write16(dev, 0x060E, 0x0000);\n\t\tb43_write16(dev, 0x0610, 0x8000);\n\t\tb43_write16(dev, 0x0604, 0x0000);\n\t\tb43_write16(dev, 0x0606, 0x0200);\n\t} else {\n\t\tb43_write32(dev, 0x0188, 0x80000000);\n\t\tb43_write32(dev, 0x018C, 0x02000000);\n\t}\n\tb43_write32(dev, B43_MMIO_GEN_IRQ_REASON, 0x00004000);\n\tb43_write32(dev, B43_MMIO_DMA0_IRQ_MASK, 0x0001FC00);\n\tb43_write32(dev, B43_MMIO_DMA1_IRQ_MASK, 0x0000DC00);\n\tb43_write32(dev, B43_MMIO_DMA2_IRQ_MASK, 0x0000DC00);\n\tb43_write32(dev, B43_MMIO_DMA3_IRQ_MASK, 0x0001DC00);\n\tb43_write32(dev, B43_MMIO_DMA4_IRQ_MASK, 0x0000DC00);\n\tb43_write32(dev, B43_MMIO_DMA5_IRQ_MASK, 0x0000DC00);\n\n\tb43_mac_phy_clock_set(dev, true);\n\n\tswitch (dev->dev->bus_type) {\n#ifdef CONFIG_B43_BCMA\n\tcase B43_BUS_BCMA:\n\t\t \n\t\tb43_write16(dev, B43_MMIO_POWERUP_DELAY, 0xE74);\n\t\tbreak;\n#endif\n#ifdef CONFIG_B43_SSB\n\tcase B43_BUS_SSB:\n\t\tb43_write16(dev, B43_MMIO_POWERUP_DELAY,\n\t\t\t    dev->dev->sdev->bus->chipco.fast_pwrup_delay);\n\t\tbreak;\n#endif\n\t}\n\n\terr = 0;\n\tb43dbg(dev->wl, \"Chip initialized\\n\");\nout:\n\treturn err;\n\nerr_gpio_clean:\n\tb43_gpio_cleanup(dev);\n\treturn err;\n}\n\nstatic void b43_periodic_every60sec(struct b43_wldev *dev)\n{\n\tconst struct b43_phy_operations *ops = dev->phy.ops;\n\n\tif (ops->pwork_60sec)\n\t\tops->pwork_60sec(dev);\n\n\t \n\tb43_phy_txpower_check(dev, B43_TXPWR_IGNORE_TIME);\n}\n\nstatic void b43_periodic_every30sec(struct b43_wldev *dev)\n{\n\t \n\tb43_calculate_link_quality(dev);\n}\n\nstatic void b43_periodic_every15sec(struct b43_wldev *dev)\n{\n\tstruct b43_phy *phy = &dev->phy;\n\tu16 wdr;\n\n\tif (dev->fw.opensource) {\n\t\t \n\t\twdr = b43_shm_read16(dev, B43_SHM_SCRATCH, B43_WATCHDOG_REG);\n\t\tif (unlikely(wdr)) {\n\t\t\tb43err(dev->wl, \"Firmware watchdog: The firmware died!\\n\");\n\t\t\tb43_controller_restart(dev, \"Firmware watchdog\");\n\t\t\treturn;\n\t\t} else {\n\t\t\tb43_shm_write16(dev, B43_SHM_SCRATCH,\n\t\t\t\t\tB43_WATCHDOG_REG, 1);\n\t\t}\n\t}\n\n\tif (phy->ops->pwork_15sec)\n\t\tphy->ops->pwork_15sec(dev);\n\n\tatomic_set(&phy->txerr_cnt, B43_PHY_TX_BADNESS_LIMIT);\n\twmb();\n\n#if B43_DEBUG\n\tif (b43_debug(dev, B43_DBG_VERBOSESTATS)) {\n\t\tunsigned int i;\n\n\t\tb43dbg(dev->wl, \"Stats: %7u IRQs/sec, %7u TX/sec, %7u RX/sec\\n\",\n\t\t       dev->irq_count / 15,\n\t\t       dev->tx_count / 15,\n\t\t       dev->rx_count / 15);\n\t\tdev->irq_count = 0;\n\t\tdev->tx_count = 0;\n\t\tdev->rx_count = 0;\n\t\tfor (i = 0; i < ARRAY_SIZE(dev->irq_bit_count); i++) {\n\t\t\tif (dev->irq_bit_count[i]) {\n\t\t\t\tb43dbg(dev->wl, \"Stats: %7u IRQ-%02u/sec (0x%08X)\\n\",\n\t\t\t\t       dev->irq_bit_count[i] / 15, i, (1 << i));\n\t\t\t\tdev->irq_bit_count[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n#endif\n}\n\nstatic void do_periodic_work(struct b43_wldev *dev)\n{\n\tunsigned int state;\n\n\tstate = dev->periodic_state;\n\tif (state % 4 == 0)\n\t\tb43_periodic_every60sec(dev);\n\tif (state % 2 == 0)\n\t\tb43_periodic_every30sec(dev);\n\tb43_periodic_every15sec(dev);\n}\n\n \nstatic void b43_periodic_work_handler(struct work_struct *work)\n{\n\tstruct b43_wldev *dev = container_of(work, struct b43_wldev,\n\t\t\t\t\t     periodic_work.work);\n\tstruct b43_wl *wl = dev->wl;\n\tunsigned long delay;\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(b43_status(dev) != B43_STAT_STARTED))\n\t\tgoto out;\n\tif (b43_debug(dev, B43_DBG_PWORK_STOP))\n\t\tgoto out_requeue;\n\n\tdo_periodic_work(dev);\n\n\tdev->periodic_state++;\nout_requeue:\n\tif (b43_debug(dev, B43_DBG_PWORK_FAST))\n\t\tdelay = msecs_to_jiffies(50);\n\telse\n\t\tdelay = round_jiffies_relative(HZ * 15);\n\tieee80211_queue_delayed_work(wl->hw, &dev->periodic_work, delay);\nout:\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic void b43_periodic_tasks_setup(struct b43_wldev *dev)\n{\n\tstruct delayed_work *work = &dev->periodic_work;\n\n\tdev->periodic_state = 0;\n\tINIT_DELAYED_WORK(work, b43_periodic_work_handler);\n\tieee80211_queue_delayed_work(dev->wl->hw, work, 0);\n}\n\n \nstatic int b43_validate_chipaccess(struct b43_wldev *dev)\n{\n\tu32 v, backup0, backup4;\n\n\tbackup0 = b43_shm_read32(dev, B43_SHM_SHARED, 0);\n\tbackup4 = b43_shm_read32(dev, B43_SHM_SHARED, 4);\n\n\t \n\tb43_shm_write32(dev, B43_SHM_SHARED, 0, 0x55AAAA55);\n\tif (b43_shm_read32(dev, B43_SHM_SHARED, 0) != 0x55AAAA55)\n\t\tgoto error;\n\tb43_shm_write32(dev, B43_SHM_SHARED, 0, 0xAA5555AA);\n\tif (b43_shm_read32(dev, B43_SHM_SHARED, 0) != 0xAA5555AA)\n\t\tgoto error;\n\n\t \n\tb43_shm_write16(dev, B43_SHM_SHARED, 0, 0x1122);\n\tb43_shm_write16(dev, B43_SHM_SHARED, 2, 0x3344);\n\tb43_shm_write16(dev, B43_SHM_SHARED, 4, 0x5566);\n\tb43_shm_write16(dev, B43_SHM_SHARED, 6, 0x7788);\n\tif (b43_shm_read32(dev, B43_SHM_SHARED, 2) != 0x55663344)\n\t\tb43warn(dev->wl, \"Unaligned 32bit SHM read access is broken\\n\");\n\tb43_shm_write32(dev, B43_SHM_SHARED, 2, 0xAABBCCDD);\n\tif (b43_shm_read16(dev, B43_SHM_SHARED, 0) != 0x1122 ||\n\t    b43_shm_read16(dev, B43_SHM_SHARED, 2) != 0xCCDD ||\n\t    b43_shm_read16(dev, B43_SHM_SHARED, 4) != 0xAABB ||\n\t    b43_shm_read16(dev, B43_SHM_SHARED, 6) != 0x7788)\n\t\tb43warn(dev->wl, \"Unaligned 32bit SHM write access is broken\\n\");\n\n\tb43_shm_write32(dev, B43_SHM_SHARED, 0, backup0);\n\tb43_shm_write32(dev, B43_SHM_SHARED, 4, backup4);\n\n\tif ((dev->dev->core_rev >= 3) && (dev->dev->core_rev <= 10)) {\n\t\t \n\t\tb43_write16(dev, B43_MMIO_TSF_CFP_START, 0xAAAA);\n\t\tb43_write32(dev, B43_MMIO_TSF_CFP_START, 0xCCCCBBBB);\n\t\tif (b43_read16(dev, B43_MMIO_TSF_CFP_START_LOW) != 0xBBBB)\n\t\t\tgoto error;\n\t\tif (b43_read16(dev, B43_MMIO_TSF_CFP_START_HIGH) != 0xCCCC)\n\t\t\tgoto error;\n\t}\n\tb43_write32(dev, B43_MMIO_TSF_CFP_START, 0);\n\n\tv = b43_read32(dev, B43_MMIO_MACCTL);\n\tv |= B43_MACCTL_GMODE;\n\tif (v != (B43_MACCTL_GMODE | B43_MACCTL_IHR_ENABLED))\n\t\tgoto error;\n\n\treturn 0;\nerror:\n\tb43err(dev->wl, \"Failed to validate the chipaccess\\n\");\n\treturn -ENODEV;\n}\n\nstatic void b43_security_init(struct b43_wldev *dev)\n{\n\tdev->ktp = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_KTP);\n\t \n\tdev->ktp *= 2;\n\t \n\tb43_write16(dev, B43_MMIO_RCMTA_COUNT, B43_NR_PAIRWISE_KEYS);\n\t \n\tb43_clear_keys(dev);\n}\n\n#ifdef CONFIG_B43_HWRNG\nstatic int b43_rng_read(struct hwrng *rng, u32 *data)\n{\n\tstruct b43_wl *wl = (struct b43_wl *)rng->priv;\n\tstruct b43_wldev *dev;\n\tint count = -ENODEV;\n\n\tmutex_lock(&wl->mutex);\n\tdev = wl->current_dev;\n\tif (likely(dev && b43_status(dev) >= B43_STAT_INITIALIZED)) {\n\t\t*data = b43_read16(dev, B43_MMIO_RNG);\n\t\tcount = sizeof(u16);\n\t}\n\tmutex_unlock(&wl->mutex);\n\n\treturn count;\n}\n#endif  \n\nstatic void b43_rng_exit(struct b43_wl *wl)\n{\n#ifdef CONFIG_B43_HWRNG\n\tif (wl->rng_initialized)\n\t\thwrng_unregister(&wl->rng);\n#endif  \n}\n\nstatic int b43_rng_init(struct b43_wl *wl)\n{\n\tint err = 0;\n\n#ifdef CONFIG_B43_HWRNG\n\tsnprintf(wl->rng_name, ARRAY_SIZE(wl->rng_name),\n\t\t \"%s_%s\", KBUILD_MODNAME, wiphy_name(wl->hw->wiphy));\n\twl->rng.name = wl->rng_name;\n\twl->rng.data_read = b43_rng_read;\n\twl->rng.priv = (unsigned long)wl;\n\twl->rng_initialized = true;\n\terr = hwrng_register(&wl->rng);\n\tif (err) {\n\t\twl->rng_initialized = false;\n\t\tb43err(wl, \"Failed to register the random \"\n\t\t       \"number generator (%d)\\n\", err);\n\t}\n#endif  \n\n\treturn err;\n}\n\nstatic void b43_tx_work(struct work_struct *work)\n{\n\tstruct b43_wl *wl = container_of(work, struct b43_wl, tx_work);\n\tstruct b43_wldev *dev;\n\tstruct sk_buff *skb;\n\tint queue_num;\n\tint err = 0;\n\n\tmutex_lock(&wl->mutex);\n\tdev = wl->current_dev;\n\tif (unlikely(!dev || b43_status(dev) < B43_STAT_STARTED)) {\n\t\tmutex_unlock(&wl->mutex);\n\t\treturn;\n\t}\n\n\tfor (queue_num = 0; queue_num < B43_QOS_QUEUE_NUM; queue_num++) {\n\t\twhile (skb_queue_len(&wl->tx_queue[queue_num])) {\n\t\t\tskb = skb_dequeue(&wl->tx_queue[queue_num]);\n\t\t\tif (b43_using_pio_transfers(dev))\n\t\t\t\terr = b43_pio_tx(dev, skb);\n\t\t\telse\n\t\t\t\terr = b43_dma_tx(dev, skb);\n\t\t\tif (err == -ENOSPC) {\n\t\t\t\twl->tx_queue_stopped[queue_num] = true;\n\t\t\t\tieee80211_stop_queue(wl->hw, queue_num);\n\t\t\t\tskb_queue_head(&wl->tx_queue[queue_num], skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(err))\n\t\t\t\tieee80211_free_txskb(wl->hw, skb);\n\t\t\terr = 0;\n\t\t}\n\n\t\tif (!err)\n\t\t\twl->tx_queue_stopped[queue_num] = false;\n\t}\n\n#if B43_DEBUG\n\tdev->tx_count++;\n#endif\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic void b43_op_tx(struct ieee80211_hw *hw,\n\t\t      struct ieee80211_tx_control *control,\n\t\t      struct sk_buff *skb)\n{\n\tstruct b43_wl *wl = hw_to_b43_wl(hw);\n\n\tif (unlikely(skb->len < 2 + 2 + 6)) {\n\t\t \n\t\tieee80211_free_txskb(hw, skb);\n\t\treturn;\n\t}\n\tB43_WARN_ON(skb_shinfo(skb)->nr_frags);\n\n\tskb_queue_tail(&wl->tx_queue[skb->queue_mapping], skb);\n\tif (!wl->tx_queue_stopped[skb->queue_mapping]) {\n\t\tieee80211_queue_work(wl->hw, &wl->tx_work);\n\t} else {\n\t\tieee80211_stop_queue(wl->hw, skb->queue_mapping);\n\t}\n}\n\nstatic void b43_qos_params_upload(struct b43_wldev *dev,\n\t\t\t\t  const struct ieee80211_tx_queue_params *p,\n\t\t\t\t  u16 shm_offset)\n{\n\tu16 params[B43_NR_QOSPARAMS];\n\tint bslots, tmp;\n\tunsigned int i;\n\n\tif (!dev->qos_enabled)\n\t\treturn;\n\n\tbslots = b43_read16(dev, B43_MMIO_RNG) & p->cw_min;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tparams[B43_QOSPARAM_TXOP] = p->txop * 32;\n\tparams[B43_QOSPARAM_CWMIN] = p->cw_min;\n\tparams[B43_QOSPARAM_CWMAX] = p->cw_max;\n\tparams[B43_QOSPARAM_CWCUR] = p->cw_min;\n\tparams[B43_QOSPARAM_AIFS] = p->aifs;\n\tparams[B43_QOSPARAM_BSLOTS] = bslots;\n\tparams[B43_QOSPARAM_REGGAP] = bslots + p->aifs;\n\n\tfor (i = 0; i < ARRAY_SIZE(params); i++) {\n\t\tif (i == B43_QOSPARAM_STATUS) {\n\t\t\ttmp = b43_shm_read16(dev, B43_SHM_SHARED,\n\t\t\t\t\t     shm_offset + (i * 2));\n\t\t\t \n\t\t\ttmp |= 0x100;\n\t\t\tb43_shm_write16(dev, B43_SHM_SHARED,\n\t\t\t\t\tshm_offset + (i * 2),\n\t\t\t\t\ttmp);\n\t\t} else {\n\t\t\tb43_shm_write16(dev, B43_SHM_SHARED,\n\t\t\t\t\tshm_offset + (i * 2),\n\t\t\t\t\tparams[i]);\n\t\t}\n\t}\n}\n\n \nstatic const u16 b43_qos_shm_offsets[] = {\n\t \n\t[0] = B43_QOS_VOICE,\n\t[1] = B43_QOS_VIDEO,\n\t[2] = B43_QOS_BESTEFFORT,\n\t[3] = B43_QOS_BACKGROUND,\n};\n\n \nstatic void b43_qos_upload_all(struct b43_wldev *dev)\n{\n\tstruct b43_wl *wl = dev->wl;\n\tstruct b43_qos_params *params;\n\tunsigned int i;\n\n\tif (!dev->qos_enabled)\n\t\treturn;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(b43_qos_shm_offsets) !=\n\t\t     ARRAY_SIZE(wl->qos_params));\n\n\tb43_mac_suspend(dev);\n\tfor (i = 0; i < ARRAY_SIZE(wl->qos_params); i++) {\n\t\tparams = &(wl->qos_params[i]);\n\t\tb43_qos_params_upload(dev, &(params->p),\n\t\t\t\t      b43_qos_shm_offsets[i]);\n\t}\n\tb43_mac_enable(dev);\n}\n\nstatic void b43_qos_clear(struct b43_wl *wl)\n{\n\tstruct b43_qos_params *params;\n\tunsigned int i;\n\n\t \n\n\tBUILD_BUG_ON(ARRAY_SIZE(b43_qos_shm_offsets) !=\n\t\t     ARRAY_SIZE(wl->qos_params));\n\n\tfor (i = 0; i < ARRAY_SIZE(wl->qos_params); i++) {\n\t\tparams = &(wl->qos_params[i]);\n\n\t\tswitch (b43_qos_shm_offsets[i]) {\n\t\tcase B43_QOS_VOICE:\n\t\t\tparams->p.txop = 0;\n\t\t\tparams->p.aifs = 2;\n\t\t\tparams->p.cw_min = 0x0001;\n\t\t\tparams->p.cw_max = 0x0001;\n\t\t\tbreak;\n\t\tcase B43_QOS_VIDEO:\n\t\t\tparams->p.txop = 0;\n\t\t\tparams->p.aifs = 2;\n\t\t\tparams->p.cw_min = 0x0001;\n\t\t\tparams->p.cw_max = 0x0001;\n\t\t\tbreak;\n\t\tcase B43_QOS_BESTEFFORT:\n\t\t\tparams->p.txop = 0;\n\t\t\tparams->p.aifs = 3;\n\t\t\tparams->p.cw_min = 0x0001;\n\t\t\tparams->p.cw_max = 0x03FF;\n\t\t\tbreak;\n\t\tcase B43_QOS_BACKGROUND:\n\t\t\tparams->p.txop = 0;\n\t\t\tparams->p.aifs = 7;\n\t\t\tparams->p.cw_min = 0x0001;\n\t\t\tparams->p.cw_max = 0x03FF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tB43_WARN_ON(1);\n\t\t}\n\t}\n}\n\n \nstatic void b43_qos_init(struct b43_wldev *dev)\n{\n\tif (!dev->qos_enabled) {\n\t\t \n\t\tb43_hf_write(dev, b43_hf_read(dev) & ~B43_HF_EDCF);\n\t\tb43_write16(dev, B43_MMIO_IFSCTL,\n\t\t\t    b43_read16(dev, B43_MMIO_IFSCTL)\n\t\t\t    & ~B43_MMIO_IFSCTL_USE_EDCF);\n\t\tb43dbg(dev->wl, \"QoS disabled\\n\");\n\t\treturn;\n\t}\n\n\t \n\tb43_qos_upload_all(dev);\n\n\t \n\tb43_hf_write(dev, b43_hf_read(dev) | B43_HF_EDCF);\n\tb43_write16(dev, B43_MMIO_IFSCTL,\n\t\t    b43_read16(dev, B43_MMIO_IFSCTL)\n\t\t    | B43_MMIO_IFSCTL_USE_EDCF);\n\tb43dbg(dev->wl, \"QoS enabled\\n\");\n}\n\nstatic int b43_op_conf_tx(struct ieee80211_hw *hw,\n\t\t\t  struct ieee80211_vif *vif,\n\t\t\t  unsigned int link_id, u16 _queue,\n\t\t\t  const struct ieee80211_tx_queue_params *params)\n{\n\tstruct b43_wl *wl = hw_to_b43_wl(hw);\n\tstruct b43_wldev *dev;\n\tunsigned int queue = (unsigned int)_queue;\n\tint err = -ENODEV;\n\n\tif (queue >= ARRAY_SIZE(wl->qos_params)) {\n\t\t \n\t\treturn 0;\n\t}\n\tBUILD_BUG_ON(ARRAY_SIZE(b43_qos_shm_offsets) !=\n\t\t     ARRAY_SIZE(wl->qos_params));\n\n\tmutex_lock(&wl->mutex);\n\tdev = wl->current_dev;\n\tif (unlikely(!dev || (b43_status(dev) < B43_STAT_INITIALIZED)))\n\t\tgoto out_unlock;\n\n\tmemcpy(&(wl->qos_params[queue].p), params, sizeof(*params));\n\tb43_mac_suspend(dev);\n\tb43_qos_params_upload(dev, &(wl->qos_params[queue].p),\n\t\t\t      b43_qos_shm_offsets[queue]);\n\tb43_mac_enable(dev);\n\terr = 0;\n\nout_unlock:\n\tmutex_unlock(&wl->mutex);\n\n\treturn err;\n}\n\nstatic int b43_op_get_stats(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_low_level_stats *stats)\n{\n\tstruct b43_wl *wl = hw_to_b43_wl(hw);\n\n\tmutex_lock(&wl->mutex);\n\tmemcpy(stats, &wl->ieee_stats, sizeof(*stats));\n\tmutex_unlock(&wl->mutex);\n\n\treturn 0;\n}\n\nstatic u64 b43_op_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct b43_wl *wl = hw_to_b43_wl(hw);\n\tstruct b43_wldev *dev;\n\tu64 tsf;\n\n\tmutex_lock(&wl->mutex);\n\tdev = wl->current_dev;\n\n\tif (dev && (b43_status(dev) >= B43_STAT_INITIALIZED))\n\t\tb43_tsf_read(dev, &tsf);\n\telse\n\t\ttsf = 0;\n\n\tmutex_unlock(&wl->mutex);\n\n\treturn tsf;\n}\n\nstatic void b43_op_set_tsf(struct ieee80211_hw *hw,\n\t\t\t   struct ieee80211_vif *vif, u64 tsf)\n{\n\tstruct b43_wl *wl = hw_to_b43_wl(hw);\n\tstruct b43_wldev *dev;\n\n\tmutex_lock(&wl->mutex);\n\tdev = wl->current_dev;\n\n\tif (dev && (b43_status(dev) >= B43_STAT_INITIALIZED))\n\t\tb43_tsf_write(dev, tsf);\n\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic const char *band_to_string(enum nl80211_band band)\n{\n\tswitch (band) {\n\tcase NL80211_BAND_5GHZ:\n\t\treturn \"5\";\n\tcase NL80211_BAND_2GHZ:\n\t\treturn \"2.4\";\n\tdefault:\n\t\tbreak;\n\t}\n\tB43_WARN_ON(1);\n\treturn \"\";\n}\n\n \nstatic int b43_switch_band(struct b43_wldev *dev,\n\t\t\t   struct ieee80211_channel *chan)\n{\n\tstruct b43_phy *phy = &dev->phy;\n\tbool gmode;\n\tu32 tmp;\n\n\tswitch (chan->band) {\n\tcase NL80211_BAND_5GHZ:\n\t\tgmode = false;\n\t\tbreak;\n\tcase NL80211_BAND_2GHZ:\n\t\tgmode = true;\n\t\tbreak;\n\tdefault:\n\t\tB43_WARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!((gmode && phy->supports_2ghz) ||\n\t      (!gmode && phy->supports_5ghz))) {\n\t\tb43err(dev->wl, \"This device doesn't support %s-GHz band\\n\",\n\t\t       band_to_string(chan->band));\n\t\treturn -ENODEV;\n\t}\n\n\tif (!!phy->gmode == !!gmode) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tb43dbg(dev->wl, \"Switching to %s GHz band\\n\",\n\t       band_to_string(chan->band));\n\n\t \n\tif (!(phy->type == B43_PHYTYPE_N && phy->rev >= 3))\n\t\tb43_software_rfkill(dev, true);\n\n\tphy->gmode = gmode;\n\tb43_phy_put_into_reset(dev);\n\tswitch (dev->dev->bus_type) {\n#ifdef CONFIG_B43_BCMA\n\tcase B43_BUS_BCMA:\n\t\ttmp = bcma_aread32(dev->dev->bdev, BCMA_IOCTL);\n\t\tif (gmode)\n\t\t\ttmp |= B43_BCMA_IOCTL_GMODE;\n\t\telse\n\t\t\ttmp &= ~B43_BCMA_IOCTL_GMODE;\n\t\tbcma_awrite32(dev->dev->bdev, BCMA_IOCTL, tmp);\n\t\tbreak;\n#endif\n#ifdef CONFIG_B43_SSB\n\tcase B43_BUS_SSB:\n\t\ttmp = ssb_read32(dev->dev->sdev, SSB_TMSLOW);\n\t\tif (gmode)\n\t\t\ttmp |= B43_TMSLOW_GMODE;\n\t\telse\n\t\t\ttmp &= ~B43_TMSLOW_GMODE;\n\t\tssb_write32(dev->dev->sdev, SSB_TMSLOW, tmp);\n\t\tbreak;\n#endif\n\t}\n\tb43_phy_take_out_of_reset(dev);\n\n\tb43_upload_initvals_band(dev);\n\n\tb43_phy_init(dev);\n\n\treturn 0;\n}\n\nstatic void b43_set_beacon_listen_interval(struct b43_wldev *dev, u16 interval)\n{\n\tinterval = min_t(u16, interval, (u16)0xFF);\n\tb43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_BCN_LI, interval);\n}\n\n \nstatic void b43_set_retry_limits(struct b43_wldev *dev,\n\t\t\t\t unsigned int short_retry,\n\t\t\t\t unsigned int long_retry)\n{\n\t \n\tshort_retry = min(short_retry, (unsigned int)0xF);\n\tlong_retry = min(long_retry, (unsigned int)0xF);\n\n\tb43_shm_write16(dev, B43_SHM_SCRATCH, B43_SHM_SC_SRLIMIT,\n\t\t\tshort_retry);\n\tb43_shm_write16(dev, B43_SHM_SCRATCH, B43_SHM_SC_LRLIMIT,\n\t\t\tlong_retry);\n}\n\nstatic int b43_op_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct b43_wl *wl = hw_to_b43_wl(hw);\n\tstruct b43_wldev *dev = wl->current_dev;\n\tstruct b43_phy *phy = &dev->phy;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tint antenna;\n\tint err = 0;\n\n\tmutex_lock(&wl->mutex);\n\tb43_mac_suspend(dev);\n\n\tif (changed & IEEE80211_CONF_CHANGE_LISTEN_INTERVAL)\n\t\tb43_set_beacon_listen_interval(dev, conf->listen_interval);\n\n\tif (changed & IEEE80211_CONF_CHANGE_CHANNEL) {\n\t\tphy->chandef = &conf->chandef;\n\t\tphy->channel = conf->chandef.chan->hw_value;\n\n\t\t \n\t\terr = b43_switch_band(dev, conf->chandef.chan);\n\t\tif (err)\n\t\t\tgoto out_mac_enable;\n\n\t\t \n\t\tb43_switch_channel(dev, phy->channel);\n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_RETRY_LIMITS)\n\t\tb43_set_retry_limits(dev, conf->short_frame_max_tx_count,\n\t\t\t\t\t  conf->long_frame_max_tx_count);\n\tchanged &= ~IEEE80211_CONF_CHANGE_RETRY_LIMITS;\n\tif (!changed)\n\t\tgoto out_mac_enable;\n\n\tdev->wl->radiotap_enabled = !!(conf->flags & IEEE80211_CONF_MONITOR);\n\n\t \n\tif (conf->power_level != 0) {\n\t\tif (conf->power_level != phy->desired_txpower) {\n\t\t\tphy->desired_txpower = conf->power_level;\n\t\t\tb43_phy_txpower_check(dev, B43_TXPWR_IGNORE_TIME |\n\t\t\t\t\t\t   B43_TXPWR_IGNORE_TSSI);\n\t\t}\n\t}\n\n\t \n\tantenna = B43_ANTENNA_DEFAULT;\n\tb43_mgmtframe_txantenna(dev, antenna);\n\tantenna = B43_ANTENNA_DEFAULT;\n\tif (phy->ops->set_rx_antenna)\n\t\tphy->ops->set_rx_antenna(dev, antenna);\n\n\tif (wl->radio_enabled != phy->radio_on) {\n\t\tif (wl->radio_enabled) {\n\t\t\tb43_software_rfkill(dev, false);\n\t\t\tb43info(dev->wl, \"Radio turned on by software\\n\");\n\t\t\tif (!dev->radio_hw_enable) {\n\t\t\t\tb43info(dev->wl, \"The hardware RF-kill button \"\n\t\t\t\t\t\"still turns the radio physically off. \"\n\t\t\t\t\t\"Press the button to turn it on.\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tb43_software_rfkill(dev, true);\n\t\t\tb43info(dev->wl, \"Radio turned off by software\\n\");\n\t\t}\n\t}\n\nout_mac_enable:\n\tb43_mac_enable(dev);\n\tmutex_unlock(&wl->mutex);\n\n\treturn err;\n}\n\nstatic void b43_update_basic_rates(struct b43_wldev *dev, u32 brates)\n{\n\tstruct ieee80211_supported_band *sband =\n\t\tdev->wl->hw->wiphy->bands[b43_current_band(dev->wl)];\n\tconst struct ieee80211_rate *rate;\n\tint i;\n\tu16 basic, direct, offset, basic_offset, rateptr;\n\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\trate = &sband->bitrates[i];\n\n\t\tif (b43_is_cck_rate(rate->hw_value)) {\n\t\t\tdirect = B43_SHM_SH_CCKDIRECT;\n\t\t\tbasic = B43_SHM_SH_CCKBASIC;\n\t\t\toffset = b43_plcp_get_ratecode_cck(rate->hw_value);\n\t\t\toffset &= 0xF;\n\t\t} else {\n\t\t\tdirect = B43_SHM_SH_OFDMDIRECT;\n\t\t\tbasic = B43_SHM_SH_OFDMBASIC;\n\t\t\toffset = b43_plcp_get_ratecode_ofdm(rate->hw_value);\n\t\t\toffset &= 0xF;\n\t\t}\n\n\t\trate = ieee80211_get_response_rate(sband, brates, rate->bitrate);\n\n\t\tif (b43_is_cck_rate(rate->hw_value)) {\n\t\t\tbasic_offset = b43_plcp_get_ratecode_cck(rate->hw_value);\n\t\t\tbasic_offset &= 0xF;\n\t\t} else {\n\t\t\tbasic_offset = b43_plcp_get_ratecode_ofdm(rate->hw_value);\n\t\t\tbasic_offset &= 0xF;\n\t\t}\n\n\t\t \n\t\trateptr = b43_shm_read16(dev, B43_SHM_SHARED,\n\t\t\t\t\t direct + 2 * basic_offset);\n\t\t \n\t\tb43_shm_write16(dev, B43_SHM_SHARED, basic + 2 * offset,\n\t\t\t\trateptr);\n\t}\n}\n\nstatic void b43_op_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_bss_conf *conf,\n\t\t\t\t    u64 changed)\n{\n\tstruct b43_wl *wl = hw_to_b43_wl(hw);\n\tstruct b43_wldev *dev;\n\n\tmutex_lock(&wl->mutex);\n\n\tdev = wl->current_dev;\n\tif (!dev || b43_status(dev) < B43_STAT_STARTED)\n\t\tgoto out_unlock_mutex;\n\n\tB43_WARN_ON(wl->vif != vif);\n\n\tif (changed & BSS_CHANGED_BSSID) {\n\t\tif (conf->bssid)\n\t\t\tmemcpy(wl->bssid, conf->bssid, ETH_ALEN);\n\t\telse\n\t\t\teth_zero_addr(wl->bssid);\n\t}\n\n\tif (b43_status(dev) >= B43_STAT_INITIALIZED) {\n\t\tif (changed & BSS_CHANGED_BEACON &&\n\t\t    (b43_is_mode(wl, NL80211_IFTYPE_AP) ||\n\t\t     b43_is_mode(wl, NL80211_IFTYPE_MESH_POINT) ||\n\t\t     b43_is_mode(wl, NL80211_IFTYPE_ADHOC)))\n\t\t\tb43_update_templates(wl);\n\n\t\tif (changed & BSS_CHANGED_BSSID)\n\t\t\tb43_write_mac_bssid_templates(dev);\n\t}\n\n\tb43_mac_suspend(dev);\n\n\t \n\tif (changed & BSS_CHANGED_BEACON_INT &&\n\t    (b43_is_mode(wl, NL80211_IFTYPE_AP) ||\n\t     b43_is_mode(wl, NL80211_IFTYPE_MESH_POINT) ||\n\t     b43_is_mode(wl, NL80211_IFTYPE_ADHOC)) &&\n\t    conf->beacon_int)\n\t\tb43_set_beacon_int(dev, conf->beacon_int);\n\n\tif (changed & BSS_CHANGED_BASIC_RATES)\n\t\tb43_update_basic_rates(dev, conf->basic_rates);\n\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\tif (conf->use_short_slot)\n\t\t\tb43_short_slot_timing_enable(dev);\n\t\telse\n\t\t\tb43_short_slot_timing_disable(dev);\n\t}\n\n\tb43_mac_enable(dev);\nout_unlock_mutex:\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic int b43_op_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t\t  struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t\t  struct ieee80211_key_conf *key)\n{\n\tstruct b43_wl *wl = hw_to_b43_wl(hw);\n\tstruct b43_wldev *dev;\n\tu8 algorithm;\n\tu8 index;\n\tint err;\n\tstatic const u8 bcast_addr[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\n\tif (modparam_nohwcrypt)\n\t\treturn -ENOSPC;  \n\n\tif ((vif->type == NL80211_IFTYPE_ADHOC ||\n\t     vif->type == NL80211_IFTYPE_MESH_POINT) &&\n\t    (key->cipher == WLAN_CIPHER_SUITE_TKIP ||\n\t     key->cipher == WLAN_CIPHER_SUITE_CCMP) &&\n\t    !(key->flags & IEEE80211_KEY_FLAG_PAIRWISE)) {\n\t\t \n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmutex_lock(&wl->mutex);\n\n\tdev = wl->current_dev;\n\terr = -ENODEV;\n\tif (!dev || b43_status(dev) < B43_STAT_INITIALIZED)\n\t\tgoto out_unlock;\n\n\tif (dev->fw.pcm_request_failed || !dev->hwcrypto_enabled) {\n\t\t \n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_unlock;\n\t}\n\n\terr = -EINVAL;\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\talgorithm = B43_SEC_ALGO_WEP40;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\talgorithm = B43_SEC_ALGO_WEP104;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\talgorithm = B43_SEC_ALGO_TKIP;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\talgorithm = B43_SEC_ALGO_AES;\n\t\tbreak;\n\tdefault:\n\t\tB43_WARN_ON(1);\n\t\tgoto out_unlock;\n\t}\n\tindex = (u8) (key->keyidx);\n\tif (index > 3)\n\t\tgoto out_unlock;\n\n\tswitch (cmd) {\n\tcase SET_KEY:\n\t\tif (algorithm == B43_SEC_ALGO_TKIP &&\n\t\t    (!(key->flags & IEEE80211_KEY_FLAG_PAIRWISE) ||\n\t\t    !modparam_hwtkip)) {\n\t\t\t \n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE) {\n\t\t\tif (WARN_ON(!sta)) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\t \n\t\t\terr = b43_key_write(dev, -1, algorithm,\n\t\t\t\t\t    key->key, key->keylen,\n\t\t\t\t\t    sta->addr, key);\n\t\t} else {\n\t\t\t \n\t\t\terr = b43_key_write(dev, index, algorithm,\n\t\t\t\t\t    key->key, key->keylen, NULL, key);\n\t\t}\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\n\t\tif (algorithm == B43_SEC_ALGO_WEP40 ||\n\t\t    algorithm == B43_SEC_ALGO_WEP104) {\n\t\t\tb43_hf_write(dev, b43_hf_read(dev) | B43_HF_USEDEFKEYS);\n\t\t} else {\n\t\t\tb43_hf_write(dev,\n\t\t\t\t     b43_hf_read(dev) & ~B43_HF_USEDEFKEYS);\n\t\t}\n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\n\t\tif (algorithm == B43_SEC_ALGO_TKIP)\n\t\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;\n\t\tbreak;\n\tcase DISABLE_KEY: {\n\t\terr = b43_key_clear(dev, key->hw_key_idx);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tB43_WARN_ON(1);\n\t}\n\nout_unlock:\n\tif (!err) {\n\t\tb43dbg(wl, \"%s hardware based encryption for keyidx: %d, \"\n\t\t       \"mac: %pM\\n\",\n\t\t       cmd == SET_KEY ? \"Using\" : \"Disabling\", key->keyidx,\n\t\t       sta ? sta->addr : bcast_addr);\n\t\tb43_dump_keymemory(dev);\n\t}\n\tmutex_unlock(&wl->mutex);\n\n\treturn err;\n}\n\nstatic void b43_op_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t    unsigned int changed, unsigned int *fflags,\n\t\t\t\t    u64 multicast)\n{\n\tstruct b43_wl *wl = hw_to_b43_wl(hw);\n\tstruct b43_wldev *dev;\n\n\tmutex_lock(&wl->mutex);\n\tdev = wl->current_dev;\n\tif (!dev) {\n\t\t*fflags = 0;\n\t\tgoto out_unlock;\n\t}\n\n\t*fflags &= FIF_ALLMULTI |\n\t\t  FIF_FCSFAIL |\n\t\t  FIF_PLCPFAIL |\n\t\t  FIF_CONTROL |\n\t\t  FIF_OTHER_BSS |\n\t\t  FIF_BCN_PRBRESP_PROMISC;\n\n\tchanged &= FIF_ALLMULTI |\n\t\t   FIF_FCSFAIL |\n\t\t   FIF_PLCPFAIL |\n\t\t   FIF_CONTROL |\n\t\t   FIF_OTHER_BSS |\n\t\t   FIF_BCN_PRBRESP_PROMISC;\n\n\twl->filter_flags = *fflags;\n\n\tif (changed && b43_status(dev) >= B43_STAT_INITIALIZED)\n\t\tb43_adjust_opmode(dev);\n\nout_unlock:\n\tmutex_unlock(&wl->mutex);\n}\n\n \nstatic struct b43_wldev * b43_wireless_core_stop(struct b43_wldev *dev)\n{\n\tstruct b43_wl *wl;\n\tstruct b43_wldev *orig_dev;\n\tu32 mask;\n\tint queue_num;\n\n\tif (!dev)\n\t\treturn NULL;\n\twl = dev->wl;\nredo:\n\tif (!dev || b43_status(dev) < B43_STAT_STARTED)\n\t\treturn dev;\n\n\t \n\tmutex_unlock(&wl->mutex);\n\tcancel_delayed_work_sync(&dev->periodic_work);\n\tcancel_work_sync(&wl->tx_work);\n\tb43_leds_stop(dev);\n\tmutex_lock(&wl->mutex);\n\tdev = wl->current_dev;\n\tif (!dev || b43_status(dev) < B43_STAT_STARTED) {\n\t\t \n\t\treturn dev;\n\t}\n\n\t \n\tb43_set_status(dev, B43_STAT_INITIALIZED);\n\tif (b43_bus_host_is_sdio(dev->dev)) {\n\t\t \n\t\tb43_write32(dev, B43_MMIO_GEN_IRQ_MASK, 0);\n\t\tb43_read32(dev, B43_MMIO_GEN_IRQ_MASK);\t \n\t} else {\n\t\tspin_lock_irq(&wl->hardirq_lock);\n\t\tb43_write32(dev, B43_MMIO_GEN_IRQ_MASK, 0);\n\t\tb43_read32(dev, B43_MMIO_GEN_IRQ_MASK);\t \n\t\tspin_unlock_irq(&wl->hardirq_lock);\n\t}\n\t \n\torig_dev = dev;\n\tmutex_unlock(&wl->mutex);\n\tif (b43_bus_host_is_sdio(dev->dev))\n\t\tb43_sdio_free_irq(dev);\n\telse\n\t\tfree_irq(dev->dev->irq, dev);\n\tmutex_lock(&wl->mutex);\n\tdev = wl->current_dev;\n\tif (!dev)\n\t\treturn dev;\n\tif (dev != orig_dev) {\n\t\tif (b43_status(dev) >= B43_STAT_STARTED)\n\t\t\tgoto redo;\n\t\treturn dev;\n\t}\n\tmask = b43_read32(dev, B43_MMIO_GEN_IRQ_MASK);\n\tB43_WARN_ON(mask != 0xFFFFFFFF && mask);\n\n\t \n\tfor (queue_num = 0; queue_num < B43_QOS_QUEUE_NUM; queue_num++) {\n\t\twhile (skb_queue_len(&wl->tx_queue[queue_num])) {\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tskb = skb_dequeue(&wl->tx_queue[queue_num]);\n\t\t\tieee80211_free_txskb(wl->hw, skb);\n\t\t}\n\t}\n\n\tb43_mac_suspend(dev);\n\tb43_leds_exit(dev);\n\tb43dbg(wl, \"Wireless interface stopped\\n\");\n\n\treturn dev;\n}\n\n \nstatic int b43_wireless_core_start(struct b43_wldev *dev)\n{\n\tint err;\n\n\tB43_WARN_ON(b43_status(dev) != B43_STAT_INITIALIZED);\n\n\tdrain_txstatus_queue(dev);\n\tif (b43_bus_host_is_sdio(dev->dev)) {\n\t\terr = b43_sdio_request_irq(dev, b43_sdio_interrupt_handler);\n\t\tif (err) {\n\t\t\tb43err(dev->wl, \"Cannot request SDIO IRQ\\n\");\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\terr = request_threaded_irq(dev->dev->irq, b43_interrupt_handler,\n\t\t\t\t\t   b43_interrupt_thread_handler,\n\t\t\t\t\t   IRQF_SHARED, KBUILD_MODNAME, dev);\n\t\tif (err) {\n\t\t\tb43err(dev->wl, \"Cannot request IRQ-%d\\n\",\n\t\t\t       dev->dev->irq);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tieee80211_wake_queues(dev->wl->hw);\n\tb43_set_status(dev, B43_STAT_STARTED);\n\n\t \n\tb43_mac_enable(dev);\n\tb43_write32(dev, B43_MMIO_GEN_IRQ_MASK, dev->irq_mask);\n\n\t \n\tb43_periodic_tasks_setup(dev);\n\n\tb43_leds_init(dev);\n\n\tb43dbg(dev->wl, \"Wireless interface started\\n\");\nout:\n\treturn err;\n}\n\nstatic char *b43_phy_name(struct b43_wldev *dev, u8 phy_type)\n{\n\tswitch (phy_type) {\n\tcase B43_PHYTYPE_A:\n\t\treturn \"A\";\n\tcase B43_PHYTYPE_B:\n\t\treturn \"B\";\n\tcase B43_PHYTYPE_G:\n\t\treturn \"G\";\n\tcase B43_PHYTYPE_N:\n\t\treturn \"N\";\n\tcase B43_PHYTYPE_LP:\n\t\treturn \"LP\";\n\tcase B43_PHYTYPE_SSLPN:\n\t\treturn \"SSLPN\";\n\tcase B43_PHYTYPE_HT:\n\t\treturn \"HT\";\n\tcase B43_PHYTYPE_LCN:\n\t\treturn \"LCN\";\n\tcase B43_PHYTYPE_LCNXN:\n\t\treturn \"LCNXN\";\n\tcase B43_PHYTYPE_LCN40:\n\t\treturn \"LCN40\";\n\tcase B43_PHYTYPE_AC:\n\t\treturn \"AC\";\n\t}\n\treturn \"UNKNOWN\";\n}\n\n \nstatic int b43_phy_versioning(struct b43_wldev *dev)\n{\n\tstruct b43_phy *phy = &dev->phy;\n\tconst u8 core_rev = dev->dev->core_rev;\n\tu32 tmp;\n\tu8 analog_type;\n\tu8 phy_type;\n\tu8 phy_rev;\n\tu16 radio_manuf;\n\tu16 radio_id;\n\tu16 radio_rev;\n\tu8 radio_ver;\n\tint unsupported = 0;\n\n\t \n\ttmp = b43_read16(dev, B43_MMIO_PHY_VER);\n\tanalog_type = (tmp & B43_PHYVER_ANALOG) >> B43_PHYVER_ANALOG_SHIFT;\n\tphy_type = (tmp & B43_PHYVER_TYPE) >> B43_PHYVER_TYPE_SHIFT;\n\tphy_rev = (tmp & B43_PHYVER_VERSION);\n\n\t \n\tif (phy_type == B43_PHYTYPE_LCNXN) {\n\t\tphy_type = B43_PHYTYPE_N;\n\t\tphy_rev += 16;\n\t}\n\n\tswitch (phy_type) {\n#ifdef CONFIG_B43_PHY_G\n\tcase B43_PHYTYPE_G:\n\t\tif (phy_rev > 9)\n\t\t\tunsupported = 1;\n\t\tbreak;\n#endif\n#ifdef CONFIG_B43_PHY_N\n\tcase B43_PHYTYPE_N:\n\t\tif (phy_rev >= 19)\n\t\t\tunsupported = 1;\n\t\tbreak;\n#endif\n#ifdef CONFIG_B43_PHY_LP\n\tcase B43_PHYTYPE_LP:\n\t\tif (phy_rev > 2)\n\t\t\tunsupported = 1;\n\t\tbreak;\n#endif\n#ifdef CONFIG_B43_PHY_HT\n\tcase B43_PHYTYPE_HT:\n\t\tif (phy_rev > 1)\n\t\t\tunsupported = 1;\n\t\tbreak;\n#endif\n#ifdef CONFIG_B43_PHY_LCN\n\tcase B43_PHYTYPE_LCN:\n\t\tif (phy_rev > 1)\n\t\t\tunsupported = 1;\n\t\tbreak;\n#endif\n#ifdef CONFIG_B43_PHY_AC\n\tcase B43_PHYTYPE_AC:\n\t\tif (phy_rev > 1)\n\t\t\tunsupported = 1;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tunsupported = 1;\n\t}\n\tif (unsupported) {\n\t\tb43err(dev->wl, \"FOUND UNSUPPORTED PHY (Analog %u, Type %d (%s), Revision %u)\\n\",\n\t\t       analog_type, phy_type, b43_phy_name(dev, phy_type),\n\t\t       phy_rev);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tb43info(dev->wl, \"Found PHY: Analog %u, Type %d (%s), Revision %u\\n\",\n\t\tanalog_type, phy_type, b43_phy_name(dev, phy_type), phy_rev);\n\n\t \n\tif (core_rev == 40 || core_rev == 42) {\n\t\tradio_manuf = 0x17F;\n\n\t\tb43_write16f(dev, B43_MMIO_RADIO24_CONTROL, 0);\n\t\tradio_rev = b43_read16(dev, B43_MMIO_RADIO24_DATA);\n\n\t\tb43_write16f(dev, B43_MMIO_RADIO24_CONTROL, 1);\n\t\tradio_id = b43_read16(dev, B43_MMIO_RADIO24_DATA);\n\n\t\tradio_ver = 0;  \n\t} else if (core_rev >= 24) {\n\t\tu16 radio24[3];\n\n\t\tfor (tmp = 0; tmp < 3; tmp++) {\n\t\t\tb43_write16f(dev, B43_MMIO_RADIO24_CONTROL, tmp);\n\t\t\tradio24[tmp] = b43_read16(dev, B43_MMIO_RADIO24_DATA);\n\t\t}\n\n\t\tradio_manuf = 0x17F;\n\t\tradio_id = (radio24[2] << 8) | radio24[1];\n\t\tradio_rev = (radio24[0] & 0xF);\n\t\tradio_ver = (radio24[0] & 0xF0) >> 4;\n\t} else {\n\t\tif (dev->dev->chip_id == 0x4317) {\n\t\t\tif (dev->dev->chip_rev == 0)\n\t\t\t\ttmp = 0x3205017F;\n\t\t\telse if (dev->dev->chip_rev == 1)\n\t\t\t\ttmp = 0x4205017F;\n\t\t\telse\n\t\t\t\ttmp = 0x5205017F;\n\t\t} else {\n\t\t\tb43_write16f(dev, B43_MMIO_RADIO_CONTROL,\n\t\t\t\t     B43_RADIOCTL_ID);\n\t\t\ttmp = b43_read16(dev, B43_MMIO_RADIO_DATA_LOW);\n\t\t\tb43_write16f(dev, B43_MMIO_RADIO_CONTROL,\n\t\t\t\t     B43_RADIOCTL_ID);\n\t\t\ttmp |= b43_read16(dev, B43_MMIO_RADIO_DATA_HIGH) << 16;\n\t\t}\n\t\tradio_manuf = (tmp & 0x00000FFF);\n\t\tradio_id = (tmp & 0x0FFFF000) >> 12;\n\t\tradio_rev = (tmp & 0xF0000000) >> 28;\n\t\tradio_ver = 0;  \n\t}\n\n\tif (radio_manuf != 0x17F  )\n\t\tunsupported = 1;\n\tswitch (phy_type) {\n\tcase B43_PHYTYPE_B:\n\t\tif ((radio_id & 0xFFF0) != 0x2050)\n\t\t\tunsupported = 1;\n\t\tbreak;\n\tcase B43_PHYTYPE_G:\n\t\tif (radio_id != 0x2050)\n\t\t\tunsupported = 1;\n\t\tbreak;\n\tcase B43_PHYTYPE_N:\n\t\tif (radio_id != 0x2055 && radio_id != 0x2056 &&\n\t\t    radio_id != 0x2057)\n\t\t\tunsupported = 1;\n\t\tif (radio_id == 0x2057 &&\n\t\t    !(radio_rev == 9 || radio_rev == 14))\n\t\t\tunsupported = 1;\n\t\tbreak;\n\tcase B43_PHYTYPE_LP:\n\t\tif (radio_id != 0x2062 && radio_id != 0x2063)\n\t\t\tunsupported = 1;\n\t\tbreak;\n\tcase B43_PHYTYPE_HT:\n\t\tif (radio_id != 0x2059)\n\t\t\tunsupported = 1;\n\t\tbreak;\n\tcase B43_PHYTYPE_LCN:\n\t\tif (radio_id != 0x2064)\n\t\t\tunsupported = 1;\n\t\tbreak;\n\tcase B43_PHYTYPE_AC:\n\t\tif (radio_id != 0x2069)\n\t\t\tunsupported = 1;\n\t\tbreak;\n\tdefault:\n\t\tB43_WARN_ON(1);\n\t}\n\tif (unsupported) {\n\t\tb43err(dev->wl,\n\t\t       \"FOUND UNSUPPORTED RADIO (Manuf 0x%X, ID 0x%X, Revision %u, Version %u)\\n\",\n\t\t       radio_manuf, radio_id, radio_rev, radio_ver);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tb43info(dev->wl,\n\t\t\"Found Radio: Manuf 0x%X, ID 0x%X, Revision %u, Version %u\\n\",\n\t\tradio_manuf, radio_id, radio_rev, radio_ver);\n\n\t \n\tphy->radio_manuf = radio_manuf;\n\tphy->radio_ver = radio_id;\n\tphy->radio_rev = radio_rev;\n\n\tphy->analog = analog_type;\n\tphy->type = phy_type;\n\tphy->rev = phy_rev;\n\n\treturn 0;\n}\n\nstatic void setup_struct_phy_for_init(struct b43_wldev *dev,\n\t\t\t\t      struct b43_phy *phy)\n{\n\tphy->hardware_power_control = !!modparam_hwpctl;\n\tphy->next_txpwr_check_time = jiffies;\n\t \n\tatomic_set(&phy->txerr_cnt, B43_PHY_TX_BADNESS_LIMIT);\n\n#if B43_DEBUG\n\tphy->phy_locked = false;\n\tphy->radio_locked = false;\n#endif\n}\n\nstatic void setup_struct_wldev_for_init(struct b43_wldev *dev)\n{\n\tdev->dfq_valid = false;\n\n\t \n\tdev->radio_hw_enable = true;\n\n\t \n\tmemset(&dev->stats, 0, sizeof(dev->stats));\n\n\tsetup_struct_phy_for_init(dev, &dev->phy);\n\n\t \n\tdev->irq_reason = 0;\n\tmemset(dev->dma_reason, 0, sizeof(dev->dma_reason));\n\tdev->irq_mask = B43_IRQ_MASKTEMPLATE;\n\tif (b43_modparam_verbose < B43_VERBOSITY_DEBUG)\n\t\tdev->irq_mask &= ~B43_IRQ_PHY_TXERR;\n\n\tdev->mac_suspended = 1;\n\n\t \n\tmemset(&dev->noisecalc, 0, sizeof(dev->noisecalc));\n}\n\nstatic void b43_bluetooth_coext_enable(struct b43_wldev *dev)\n{\n\tstruct ssb_sprom *sprom = dev->dev->bus_sprom;\n\tu64 hf;\n\n\tif (!modparam_btcoex)\n\t\treturn;\n\tif (!(sprom->boardflags_lo & B43_BFL_BTCOEXIST))\n\t\treturn;\n\tif (dev->phy.type != B43_PHYTYPE_B && !dev->phy.gmode)\n\t\treturn;\n\n\thf = b43_hf_read(dev);\n\tif (sprom->boardflags_lo & B43_BFL_BTCMOD)\n\t\thf |= B43_HF_BTCOEXALT;\n\telse\n\t\thf |= B43_HF_BTCOEX;\n\tb43_hf_write(dev, hf);\n}\n\nstatic void b43_bluetooth_coext_disable(struct b43_wldev *dev)\n{\n\tif (!modparam_btcoex)\n\t\treturn;\n\t \n}\n\nstatic void b43_imcfglo_timeouts_workaround(struct b43_wldev *dev)\n{\n\tstruct ssb_bus *bus;\n\tu32 tmp;\n\n#ifdef CONFIG_B43_SSB\n\tif (dev->dev->bus_type != B43_BUS_SSB)\n\t\treturn;\n#else\n\treturn;\n#endif\n\n\tbus = dev->dev->sdev->bus;\n\n\tif ((bus->chip_id == 0x4311 && bus->chip_rev == 2) ||\n\t    (bus->chip_id == 0x4312)) {\n\t\ttmp = ssb_read32(dev->dev->sdev, SSB_IMCFGLO);\n\t\ttmp &= ~SSB_IMCFGLO_REQTO;\n\t\ttmp &= ~SSB_IMCFGLO_SERTO;\n\t\ttmp |= 0x3;\n\t\tssb_write32(dev->dev->sdev, SSB_IMCFGLO, tmp);\n\t\tssb_commit_settings(bus);\n\t}\n}\n\nstatic void b43_set_synth_pu_delay(struct b43_wldev *dev, bool idle)\n{\n\tu16 pu_delay;\n\n\t \n\tpu_delay = 1050;\n\tif (b43_is_mode(dev->wl, NL80211_IFTYPE_ADHOC) || idle)\n\t\tpu_delay = 500;\n\tif ((dev->phy.radio_ver == 0x2050) && (dev->phy.radio_rev == 8))\n\t\tpu_delay = max(pu_delay, (u16)2400);\n\n\tb43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_SPUWKUP, pu_delay);\n}\n\n \nstatic void b43_set_pretbtt(struct b43_wldev *dev)\n{\n\tu16 pretbtt;\n\n\t \n\tif (b43_is_mode(dev->wl, NL80211_IFTYPE_ADHOC))\n\t\tpretbtt = 2;\n\telse\n\t\tpretbtt = 250;\n\tb43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_PRETBTT, pretbtt);\n\tb43_write16(dev, B43_MMIO_TSF_CFP_PRETBTT, pretbtt);\n}\n\n \n \nstatic void b43_wireless_core_exit(struct b43_wldev *dev)\n{\n\tB43_WARN_ON(dev && b43_status(dev) > B43_STAT_INITIALIZED);\n\tif (!dev || b43_status(dev) != B43_STAT_INITIALIZED)\n\t\treturn;\n\n\tb43_set_status(dev, B43_STAT_UNINIT);\n\n\t \n\tb43_maskset32(dev, B43_MMIO_MACCTL, ~B43_MACCTL_PSM_RUN,\n\t\t      B43_MACCTL_PSM_JMP0);\n\n\tswitch (dev->dev->bus_type) {\n#ifdef CONFIG_B43_BCMA\n\tcase B43_BUS_BCMA:\n\t\tbcma_host_pci_down(dev->dev->bdev->bus);\n\t\tbreak;\n#endif\n#ifdef CONFIG_B43_SSB\n\tcase B43_BUS_SSB:\n\t\t \n\t\tbreak;\n#endif\n\t}\n\n\tb43_dma_free(dev);\n\tb43_pio_free(dev);\n\tb43_chip_exit(dev);\n\tdev->phy.ops->switch_analog(dev, 0);\n\tif (dev->wl->current_beacon) {\n\t\tdev_kfree_skb_any(dev->wl->current_beacon);\n\t\tdev->wl->current_beacon = NULL;\n\t}\n\n\tb43_device_disable(dev, 0);\n\tb43_bus_may_powerdown(dev);\n}\n\n \nstatic int b43_wireless_core_init(struct b43_wldev *dev)\n{\n\tstruct ssb_sprom *sprom = dev->dev->bus_sprom;\n\tstruct b43_phy *phy = &dev->phy;\n\tint err;\n\tu64 hf;\n\n\tB43_WARN_ON(b43_status(dev) != B43_STAT_UNINIT);\n\n\terr = b43_bus_powerup(dev, 0);\n\tif (err)\n\t\tgoto out;\n\tif (!b43_device_is_enabled(dev))\n\t\tb43_wireless_core_reset(dev, phy->gmode);\n\n\t \n\tsetup_struct_wldev_for_init(dev);\n\tphy->ops->prepare_structs(dev);\n\n\t \n\tswitch (dev->dev->bus_type) {\n#ifdef CONFIG_B43_BCMA\n\tcase B43_BUS_BCMA:\n\t\tbcma_host_pci_irq_ctl(dev->dev->bdev->bus,\n\t\t\t\t      dev->dev->bdev, true);\n\t\tbcma_host_pci_up(dev->dev->bdev->bus);\n\t\tbreak;\n#endif\n#ifdef CONFIG_B43_SSB\n\tcase B43_BUS_SSB:\n\t\tssb_pcicore_dev_irqvecs_enable(&dev->dev->sdev->bus->pcicore,\n\t\t\t\t\t       dev->dev->sdev);\n\t\tbreak;\n#endif\n\t}\n\n\tb43_imcfglo_timeouts_workaround(dev);\n\tb43_bluetooth_coext_disable(dev);\n\tif (phy->ops->prepare_hardware) {\n\t\terr = phy->ops->prepare_hardware(dev);\n\t\tif (err)\n\t\t\tgoto err_busdown;\n\t}\n\terr = b43_chip_init(dev);\n\tif (err)\n\t\tgoto err_busdown;\n\tb43_shm_write16(dev, B43_SHM_SHARED,\n\t\t\tB43_SHM_SH_WLCOREREV, dev->dev->core_rev);\n\thf = b43_hf_read(dev);\n\tif (phy->type == B43_PHYTYPE_G) {\n\t\thf |= B43_HF_SYMW;\n\t\tif (phy->rev == 1)\n\t\t\thf |= B43_HF_GDCW;\n\t\tif (sprom->boardflags_lo & B43_BFL_PACTRL)\n\t\t\thf |= B43_HF_OFDMPABOOST;\n\t}\n\tif (phy->radio_ver == 0x2050) {\n\t\tif (phy->radio_rev == 6)\n\t\t\thf |= B43_HF_4318TSSI;\n\t\tif (phy->radio_rev < 6)\n\t\t\thf |= B43_HF_VCORECALC;\n\t}\n\tif (sprom->boardflags_lo & B43_BFL_XTAL_NOSLOW)\n\t\thf |= B43_HF_DSCRQ;  \n#if defined(CONFIG_B43_SSB) && defined(CONFIG_SSB_DRIVER_PCICORE)\n\tif (dev->dev->bus_type == B43_BUS_SSB &&\n\t    dev->dev->sdev->bus->bustype == SSB_BUSTYPE_PCI &&\n\t    dev->dev->sdev->bus->pcicore.dev->id.revision <= 10)\n\t\thf |= B43_HF_PCISCW;  \n#endif\n\thf &= ~B43_HF_SKCFPUP;\n\tb43_hf_write(dev, hf);\n\n\t \n\tif (dev->dev->core_rev >= 13) {\n\t\tu32 mac_hw_cap = b43_read32(dev, B43_MMIO_MAC_HW_CAP);\n\n\t\tb43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_MACHW_L,\n\t\t\t\tmac_hw_cap & 0xffff);\n\t\tb43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_MACHW_H,\n\t\t\t\t(mac_hw_cap >> 16) & 0xffff);\n\t}\n\n\tb43_set_retry_limits(dev, B43_DEFAULT_SHORT_RETRY_LIMIT,\n\t\t\t     B43_DEFAULT_LONG_RETRY_LIMIT);\n\tb43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_SFFBLIM, 3);\n\tb43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_LFFBLIM, 2);\n\n\t \n\tb43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_PRMAXTIME, 1);\n\n\tb43_rate_memory_init(dev);\n\tb43_set_phytxctl_defaults(dev);\n\n\t \n\tif (phy->type == B43_PHYTYPE_B)\n\t\tb43_shm_write16(dev, B43_SHM_SCRATCH, B43_SHM_SC_MINCONT, 0x1F);\n\telse\n\t\tb43_shm_write16(dev, B43_SHM_SCRATCH, B43_SHM_SC_MINCONT, 0xF);\n\t \n\tb43_shm_write16(dev, B43_SHM_SCRATCH, B43_SHM_SC_MAXCONT, 0x3FF);\n\n\t \n\tb43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_PHYTYPE, phy->type);\n\tb43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_PHYVER, phy->rev);\n\n\tif (b43_bus_host_is_pcmcia(dev->dev) ||\n\t    b43_bus_host_is_sdio(dev->dev)) {\n\t\tdev->__using_pio_transfers = true;\n\t\terr = b43_pio_init(dev);\n\t} else if (dev->use_pio) {\n\t\tb43warn(dev->wl, \"Forced PIO by use_pio module parameter. \"\n\t\t\t\"This should not be needed and will result in lower \"\n\t\t\t\"performance.\\n\");\n\t\tdev->__using_pio_transfers = true;\n\t\terr = b43_pio_init(dev);\n\t} else {\n\t\tdev->__using_pio_transfers = false;\n\t\terr = b43_dma_init(dev);\n\t}\n\tif (err)\n\t\tgoto err_chip_exit;\n\tb43_qos_init(dev);\n\tb43_set_synth_pu_delay(dev, 1);\n\tb43_bluetooth_coext_enable(dev);\n\n\tb43_bus_powerup(dev, !(sprom->boardflags_lo & B43_BFL_XTAL_NOSLOW));\n\tb43_upload_card_macaddress(dev);\n\tb43_security_init(dev);\n\n\tieee80211_wake_queues(dev->wl->hw);\n\n\tb43_set_status(dev, B43_STAT_INITIALIZED);\n\nout:\n\treturn err;\n\nerr_chip_exit:\n\tb43_chip_exit(dev);\nerr_busdown:\n\tb43_bus_may_powerdown(dev);\n\tB43_WARN_ON(b43_status(dev) != B43_STAT_UNINIT);\n\treturn err;\n}\n\nstatic int b43_op_add_interface(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct b43_wl *wl = hw_to_b43_wl(hw);\n\tstruct b43_wldev *dev;\n\tint err = -EOPNOTSUPP;\n\n\t \n\n\tif (vif->type != NL80211_IFTYPE_AP &&\n\t    vif->type != NL80211_IFTYPE_MESH_POINT &&\n\t    vif->type != NL80211_IFTYPE_STATION &&\n\t    vif->type != NL80211_IFTYPE_ADHOC)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&wl->mutex);\n\tif (wl->operating)\n\t\tgoto out_mutex_unlock;\n\n\tb43dbg(wl, \"Adding Interface type %d\\n\", vif->type);\n\n\tdev = wl->current_dev;\n\twl->operating = true;\n\twl->vif = vif;\n\twl->if_type = vif->type;\n\tmemcpy(wl->mac_addr, vif->addr, ETH_ALEN);\n\n\tb43_adjust_opmode(dev);\n\tb43_set_pretbtt(dev);\n\tb43_set_synth_pu_delay(dev, 0);\n\tb43_upload_card_macaddress(dev);\n\n\terr = 0;\n out_mutex_unlock:\n\tmutex_unlock(&wl->mutex);\n\n\tif (err == 0)\n\t\tb43_op_bss_info_changed(hw, vif, &vif->bss_conf, ~0);\n\n\treturn err;\n}\n\nstatic void b43_op_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct b43_wl *wl = hw_to_b43_wl(hw);\n\tstruct b43_wldev *dev = wl->current_dev;\n\n\tb43dbg(wl, \"Removing Interface type %d\\n\", vif->type);\n\n\tmutex_lock(&wl->mutex);\n\n\tB43_WARN_ON(!wl->operating);\n\tB43_WARN_ON(wl->vif != vif);\n\twl->vif = NULL;\n\n\twl->operating = false;\n\n\tb43_adjust_opmode(dev);\n\teth_zero_addr(wl->mac_addr);\n\tb43_upload_card_macaddress(dev);\n\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic int b43_op_start(struct ieee80211_hw *hw)\n{\n\tstruct b43_wl *wl = hw_to_b43_wl(hw);\n\tstruct b43_wldev *dev = wl->current_dev;\n\tint did_init = 0;\n\tint err = 0;\n\n\t \n\teth_zero_addr(wl->bssid);\n\teth_zero_addr(wl->mac_addr);\n\twl->filter_flags = 0;\n\twl->radiotap_enabled = false;\n\tb43_qos_clear(wl);\n\twl->beacon0_uploaded = false;\n\twl->beacon1_uploaded = false;\n\twl->beacon_templates_virgin = true;\n\twl->radio_enabled = true;\n\n\tmutex_lock(&wl->mutex);\n\n\tif (b43_status(dev) < B43_STAT_INITIALIZED) {\n\t\terr = b43_wireless_core_init(dev);\n\t\tif (err)\n\t\t\tgoto out_mutex_unlock;\n\t\tdid_init = 1;\n\t}\n\n\tif (b43_status(dev) < B43_STAT_STARTED) {\n\t\terr = b43_wireless_core_start(dev);\n\t\tif (err) {\n\t\t\tif (did_init)\n\t\t\t\tb43_wireless_core_exit(dev);\n\t\t\tgoto out_mutex_unlock;\n\t\t}\n\t}\n\n\t \n\twiphy_rfkill_start_polling(hw->wiphy);\n\n out_mutex_unlock:\n\tmutex_unlock(&wl->mutex);\n\n\t \n\tif (!err)\n\t\tb43_op_config(hw, ~0);\n\n\treturn err;\n}\n\nstatic void b43_op_stop(struct ieee80211_hw *hw)\n{\n\tstruct b43_wl *wl = hw_to_b43_wl(hw);\n\tstruct b43_wldev *dev = wl->current_dev;\n\n\tcancel_work_sync(&(wl->beacon_update_trigger));\n\n\tif (!dev)\n\t\tgoto out;\n\n\tmutex_lock(&wl->mutex);\n\tif (b43_status(dev) >= B43_STAT_STARTED) {\n\t\tdev = b43_wireless_core_stop(dev);\n\t\tif (!dev)\n\t\t\tgoto out_unlock;\n\t}\n\tb43_wireless_core_exit(dev);\n\twl->radio_enabled = false;\n\nout_unlock:\n\tmutex_unlock(&wl->mutex);\nout:\n\tcancel_work_sync(&(wl->txpower_adjust_work));\n}\n\nstatic int b43_op_beacon_set_tim(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_sta *sta, bool set)\n{\n\tstruct b43_wl *wl = hw_to_b43_wl(hw);\n\n\tb43_update_templates(wl);\n\n\treturn 0;\n}\n\nstatic void b43_op_sta_notify(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      enum sta_notify_cmd notify_cmd,\n\t\t\t      struct ieee80211_sta *sta)\n{\n\tstruct b43_wl *wl = hw_to_b43_wl(hw);\n\n\tB43_WARN_ON(!vif || wl->vif != vif);\n}\n\nstatic void b43_op_sw_scan_start_notifier(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  const u8 *mac_addr)\n{\n\tstruct b43_wl *wl = hw_to_b43_wl(hw);\n\tstruct b43_wldev *dev;\n\n\tmutex_lock(&wl->mutex);\n\tdev = wl->current_dev;\n\tif (dev && (b43_status(dev) >= B43_STAT_INITIALIZED)) {\n\t\t \n\t\tb43_hf_write(dev, b43_hf_read(dev) | B43_HF_SKCFPUP);\n\t}\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic void b43_op_sw_scan_complete_notifier(struct ieee80211_hw *hw,\n\t\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct b43_wl *wl = hw_to_b43_wl(hw);\n\tstruct b43_wldev *dev;\n\n\tmutex_lock(&wl->mutex);\n\tdev = wl->current_dev;\n\tif (dev && (b43_status(dev) >= B43_STAT_INITIALIZED)) {\n\t\t \n\t\tb43_hf_write(dev, b43_hf_read(dev) & ~B43_HF_SKCFPUP);\n\t}\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic int b43_op_get_survey(struct ieee80211_hw *hw, int idx,\n\t\t\t     struct survey_info *survey)\n{\n\tstruct b43_wl *wl = hw_to_b43_wl(hw);\n\tstruct b43_wldev *dev = wl->current_dev;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\n\tif (idx != 0)\n\t\treturn -ENOENT;\n\n\tsurvey->channel = conf->chandef.chan;\n\tsurvey->filled = SURVEY_INFO_NOISE_DBM;\n\tsurvey->noise = dev->stats.link_noise;\n\n\treturn 0;\n}\n\nstatic const struct ieee80211_ops b43_hw_ops = {\n\t.tx\t\t\t= b43_op_tx,\n\t.wake_tx_queue\t\t= ieee80211_handle_wake_tx_queue,\n\t.conf_tx\t\t= b43_op_conf_tx,\n\t.add_interface\t\t= b43_op_add_interface,\n\t.remove_interface\t= b43_op_remove_interface,\n\t.config\t\t\t= b43_op_config,\n\t.bss_info_changed\t= b43_op_bss_info_changed,\n\t.configure_filter\t= b43_op_configure_filter,\n\t.set_key\t\t= b43_op_set_key,\n\t.update_tkip_key\t= b43_op_update_tkip_key,\n\t.get_stats\t\t= b43_op_get_stats,\n\t.get_tsf\t\t= b43_op_get_tsf,\n\t.set_tsf\t\t= b43_op_set_tsf,\n\t.start\t\t\t= b43_op_start,\n\t.stop\t\t\t= b43_op_stop,\n\t.set_tim\t\t= b43_op_beacon_set_tim,\n\t.sta_notify\t\t= b43_op_sta_notify,\n\t.sw_scan_start\t\t= b43_op_sw_scan_start_notifier,\n\t.sw_scan_complete\t= b43_op_sw_scan_complete_notifier,\n\t.get_survey\t\t= b43_op_get_survey,\n\t.rfkill_poll\t\t= b43_rfkill_poll,\n};\n\n \nstatic void b43_chip_reset(struct work_struct *work)\n{\n\tstruct b43_wldev *dev =\n\t    container_of(work, struct b43_wldev, restart_work);\n\tstruct b43_wl *wl = dev->wl;\n\tint err = 0;\n\tint prev_status;\n\n\tmutex_lock(&wl->mutex);\n\n\tprev_status = b43_status(dev);\n\t \n\tif (prev_status >= B43_STAT_STARTED) {\n\t\tdev = b43_wireless_core_stop(dev);\n\t\tif (!dev) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (prev_status >= B43_STAT_INITIALIZED)\n\t\tb43_wireless_core_exit(dev);\n\n\t \n\tif (prev_status >= B43_STAT_INITIALIZED) {\n\t\terr = b43_wireless_core_init(dev);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\tif (prev_status >= B43_STAT_STARTED) {\n\t\terr = b43_wireless_core_start(dev);\n\t\tif (err) {\n\t\t\tb43_wireless_core_exit(dev);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tif (err)\n\t\twl->current_dev = NULL;  \n\tmutex_unlock(&wl->mutex);\n\n\tif (err) {\n\t\tb43err(wl, \"Controller restart FAILED\\n\");\n\t\treturn;\n\t}\n\n\t \n\tb43_op_config(wl->hw, ~0);\n\tif (wl->vif)\n\t\tb43_op_bss_info_changed(wl->hw, wl->vif, &wl->vif->bss_conf, ~0);\n\n\tb43info(wl, \"Controller restarted\\n\");\n}\n\nstatic int b43_setup_bands(struct b43_wldev *dev,\n\t\t\t   bool have_2ghz_phy, bool have_5ghz_phy)\n{\n\tstruct ieee80211_hw *hw = dev->wl->hw;\n\tstruct b43_phy *phy = &dev->phy;\n\tbool limited_2g;\n\tbool limited_5g;\n\n\t \n\tlimited_2g = phy->radio_ver == 0x2057 &&\n\t\t     (phy->radio_rev == 9 || phy->radio_rev == 14);\n\tlimited_5g = phy->radio_ver == 0x2057 &&\n\t\t     phy->radio_rev == 9;\n\n\tif (have_2ghz_phy)\n\t\thw->wiphy->bands[NL80211_BAND_2GHZ] = limited_2g ?\n\t\t\t&b43_band_2ghz_limited : &b43_band_2GHz;\n\tif (dev->phy.type == B43_PHYTYPE_N) {\n\t\tif (have_5ghz_phy)\n\t\t\thw->wiphy->bands[NL80211_BAND_5GHZ] = limited_5g ?\n\t\t\t\t&b43_band_5GHz_nphy_limited :\n\t\t\t\t&b43_band_5GHz_nphy;\n\t} else {\n\t\tif (have_5ghz_phy)\n\t\t\thw->wiphy->bands[NL80211_BAND_5GHZ] = &b43_band_5GHz_aphy;\n\t}\n\n\tdev->phy.supports_2ghz = have_2ghz_phy;\n\tdev->phy.supports_5ghz = have_5ghz_phy;\n\n\treturn 0;\n}\n\nstatic void b43_wireless_core_detach(struct b43_wldev *dev)\n{\n\t \n\tb43_release_firmware(dev);\n\tb43_phy_free(dev);\n}\n\nstatic void b43_supported_bands(struct b43_wldev *dev, bool *have_2ghz_phy,\n\t\t\t\tbool *have_5ghz_phy)\n{\n\tu16 dev_id = 0;\n\n#ifdef CONFIG_B43_BCMA\n\tif (dev->dev->bus_type == B43_BUS_BCMA &&\n\t    dev->dev->bdev->bus->hosttype == BCMA_HOSTTYPE_PCI)\n\t\tdev_id = dev->dev->bdev->bus->host_pci->device;\n#endif\n#ifdef CONFIG_B43_SSB\n\tif (dev->dev->bus_type == B43_BUS_SSB &&\n\t    dev->dev->sdev->bus->bustype == SSB_BUSTYPE_PCI)\n\t\tdev_id = dev->dev->sdev->bus->host_pci->device;\n#endif\n\t \n\tif (dev->dev->bus_sprom->dev_id)\n\t\tdev_id = dev->dev->bus_sprom->dev_id;\n\n\t \n\tswitch (dev_id) {\n\tcase 0x4324:  \n\tcase 0x4312:  \n\tcase 0x4319:  \n\tcase 0x4328:  \n\tcase 0x432b:  \n\tcase 0x4350:  \n\tcase 0x4353:  \n\tcase 0x0576:  \n\tcase 0x435f:  \n\tcase 0x4331:  \n\tcase 0x4359:  \n\tcase 0x43a0:  \n\tcase 0x43b1:  \n\t\t \n\t\t*have_2ghz_phy = true;\n\t\t*have_5ghz_phy = true;\n\t\treturn;\n\tcase 0x4321:  \n\t\t \n\t\tif (dev->phy.type != B43_PHYTYPE_G)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase 0x4313:  \n\tcase 0x431a:  \n\tcase 0x432a:  \n\tcase 0x432d:  \n\tcase 0x4352:  \n\tcase 0x435a:  \n\tcase 0x4333:  \n\tcase 0x43a2:  \n\tcase 0x43b3:  \n\t\t \n\t\t*have_2ghz_phy = false;\n\t\t*have_5ghz_phy = true;\n\t\treturn;\n\t}\n\n\t \n\tswitch (dev->phy.type) {\n\tcase B43_PHYTYPE_G:\n\tcase B43_PHYTYPE_N:\n\tcase B43_PHYTYPE_LP:\n\tcase B43_PHYTYPE_HT:\n\tcase B43_PHYTYPE_LCN:\n\t\t*have_2ghz_phy = true;\n\t\t*have_5ghz_phy = false;\n\t\treturn;\n\t}\n\n\tB43_WARN_ON(1);\n}\n\nstatic int b43_wireless_core_attach(struct b43_wldev *dev)\n{\n\tstruct b43_wl *wl = dev->wl;\n\tstruct b43_phy *phy = &dev->phy;\n\tint err;\n\tu32 tmp;\n\tbool have_2ghz_phy = false, have_5ghz_phy = false;\n\n\t \n\n\terr = b43_bus_powerup(dev, 0);\n\tif (err) {\n\t\tb43err(wl, \"Bus powerup failed\\n\");\n\t\tgoto out;\n\t}\n\n\tphy->do_full_init = true;\n\n\t \n\tswitch (dev->dev->bus_type) {\n#ifdef CONFIG_B43_BCMA\n\tcase B43_BUS_BCMA:\n\t\ttmp = bcma_aread32(dev->dev->bdev, BCMA_IOST);\n\t\thave_2ghz_phy = !!(tmp & B43_BCMA_IOST_2G_PHY);\n\t\thave_5ghz_phy = !!(tmp & B43_BCMA_IOST_5G_PHY);\n\t\tbreak;\n#endif\n#ifdef CONFIG_B43_SSB\n\tcase B43_BUS_SSB:\n\t\tif (dev->dev->core_rev >= 5) {\n\t\t\ttmp = ssb_read32(dev->dev->sdev, SSB_TMSHIGH);\n\t\t\thave_2ghz_phy = !!(tmp & B43_TMSHIGH_HAVE_2GHZ_PHY);\n\t\t\thave_5ghz_phy = !!(tmp & B43_TMSHIGH_HAVE_5GHZ_PHY);\n\t\t} else\n\t\t\tB43_WARN_ON(1);\n\t\tbreak;\n#endif\n\t}\n\n\tdev->phy.gmode = have_2ghz_phy;\n\tb43_wireless_core_reset(dev, dev->phy.gmode);\n\n\t \n\terr = b43_phy_versioning(dev);\n\tif (err)\n\t\tgoto err_powerdown;\n\n\t \n\tb43_supported_bands(dev, &have_2ghz_phy, &have_5ghz_phy);\n\n\t \n\tif (have_5ghz_phy) {\n\t\tswitch (dev->phy.type) {\n\t\tcase B43_PHYTYPE_G:\n\t\tcase B43_PHYTYPE_LP:\n\t\tcase B43_PHYTYPE_HT:\n\t\t\tb43warn(wl, \"5 GHz band is unsupported on this PHY\\n\");\n\t\t\thave_5ghz_phy = false;\n\t\t}\n\t}\n\n\tif (!have_2ghz_phy && !have_5ghz_phy) {\n\t\tb43err(wl, \"b43 can't support any band on this device\\n\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err_powerdown;\n\t}\n\n\terr = b43_phy_allocate(dev);\n\tif (err)\n\t\tgoto err_powerdown;\n\n\tdev->phy.gmode = have_2ghz_phy;\n\tb43_wireless_core_reset(dev, dev->phy.gmode);\n\n\terr = b43_validate_chipaccess(dev);\n\tif (err)\n\t\tgoto err_phy_free;\n\terr = b43_setup_bands(dev, have_2ghz_phy, have_5ghz_phy);\n\tif (err)\n\t\tgoto err_phy_free;\n\n\t \n\tif (!wl->current_dev)\n\t\twl->current_dev = dev;\n\tINIT_WORK(&dev->restart_work, b43_chip_reset);\n\n\tdev->phy.ops->switch_analog(dev, 0);\n\tb43_device_disable(dev, 0);\n\tb43_bus_may_powerdown(dev);\n\nout:\n\treturn err;\n\nerr_phy_free:\n\tb43_phy_free(dev);\nerr_powerdown:\n\tb43_bus_may_powerdown(dev);\n\treturn err;\n}\n\nstatic void b43_one_core_detach(struct b43_bus_dev *dev)\n{\n\tstruct b43_wldev *wldev;\n\n\t \n\n\twldev = b43_bus_get_wldev(dev);\n\tb43_debugfs_remove_device(wldev);\n\tb43_wireless_core_detach(wldev);\n\tlist_del(&wldev->list);\n\tb43_bus_set_wldev(dev, NULL);\n\tkfree(wldev);\n}\n\nstatic int b43_one_core_attach(struct b43_bus_dev *dev, struct b43_wl *wl)\n{\n\tstruct b43_wldev *wldev;\n\tint err = -ENOMEM;\n\n\twldev = kzalloc(sizeof(*wldev), GFP_KERNEL);\n\tif (!wldev)\n\t\tgoto out;\n\n\twldev->use_pio = b43_modparam_pio;\n\twldev->dev = dev;\n\twldev->wl = wl;\n\tb43_set_status(wldev, B43_STAT_UNINIT);\n\twldev->bad_frames_preempt = modparam_bad_frames_preempt;\n\tINIT_LIST_HEAD(&wldev->list);\n\n\terr = b43_wireless_core_attach(wldev);\n\tif (err)\n\t\tgoto err_kfree_wldev;\n\n\tb43_bus_set_wldev(dev, wldev);\n\tb43_debugfs_add_device(wldev);\n\n      out:\n\treturn err;\n\n      err_kfree_wldev:\n\tkfree(wldev);\n\treturn err;\n}\n\n#define IS_PDEV(pdev, _vendor, _device, _subvendor, _subdevice)\t\t( \\\n\t(pdev->vendor == PCI_VENDOR_ID_##_vendor) &&\t\t\t\\\n\t(pdev->device == _device) &&\t\t\t\t\t\\\n\t(pdev->subsystem_vendor == PCI_VENDOR_ID_##_subvendor) &&\t\\\n\t(pdev->subsystem_device == _subdevice)\t\t\t\t)\n\n#ifdef CONFIG_B43_SSB\nstatic void b43_sprom_fixup(struct ssb_bus *bus)\n{\n\tstruct pci_dev *pdev;\n\n\t \n\tif (bus->boardinfo.vendor == SSB_BOARDVENDOR_DELL &&\n\t    bus->chip_id == 0x4301 && bus->sprom.board_rev == 0x74)\n\t\tbus->sprom.boardflags_lo |= B43_BFL_BTCOEXIST;\n\tif (bus->boardinfo.vendor == PCI_VENDOR_ID_APPLE &&\n\t    bus->boardinfo.type == 0x4E && bus->sprom.board_rev > 0x40)\n\t\tbus->sprom.boardflags_lo |= B43_BFL_PACTRL;\n\tif (bus->bustype == SSB_BUSTYPE_PCI) {\n\t\tpdev = bus->host_pci;\n\t\tif (IS_PDEV(pdev, BROADCOM, 0x4318, ASUSTEK, 0x100F) ||\n\t\t    IS_PDEV(pdev, BROADCOM, 0x4320,    DELL, 0x0003) ||\n\t\t    IS_PDEV(pdev, BROADCOM, 0x4320,      HP, 0x12f8) ||\n\t\t    IS_PDEV(pdev, BROADCOM, 0x4320, LINKSYS, 0x0015) ||\n\t\t    IS_PDEV(pdev, BROADCOM, 0x4320, LINKSYS, 0x0014) ||\n\t\t    IS_PDEV(pdev, BROADCOM, 0x4320, LINKSYS, 0x0013) ||\n\t\t    IS_PDEV(pdev, BROADCOM, 0x4320, MOTOROLA, 0x7010))\n\t\t\tbus->sprom.boardflags_lo &= ~B43_BFL_BTCOEXIST;\n\t}\n}\n\nstatic void b43_wireless_exit(struct b43_bus_dev *dev, struct b43_wl *wl)\n{\n\tstruct ieee80211_hw *hw = wl->hw;\n\n\tssb_set_devtypedata(dev->sdev, NULL);\n\tieee80211_free_hw(hw);\n}\n#endif\n\nstatic struct b43_wl *b43_wireless_init(struct b43_bus_dev *dev)\n{\n\tstruct ssb_sprom *sprom = dev->bus_sprom;\n\tstruct ieee80211_hw *hw;\n\tstruct b43_wl *wl;\n\tchar chip_name[6];\n\tint queue_num;\n\n\thw = ieee80211_alloc_hw(sizeof(*wl), &b43_hw_ops);\n\tif (!hw) {\n\t\tb43err(NULL, \"Could not allocate ieee80211 device\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\twl = hw_to_b43_wl(hw);\n\n\t \n\tieee80211_hw_set(hw, RX_INCLUDES_FCS);\n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\tieee80211_hw_set(hw, MFP_CAPABLE);\n\thw->wiphy->interface_modes =\n\t\tBIT(NL80211_IFTYPE_AP) |\n\t\tBIT(NL80211_IFTYPE_MESH_POINT) |\n\t\tBIT(NL80211_IFTYPE_STATION) |\n\t\tBIT(NL80211_IFTYPE_ADHOC);\n\n\thw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;\n\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\twl->hw_registered = false;\n\thw->max_rates = 2;\n\tSET_IEEE80211_DEV(hw, dev->dev);\n\tif (is_valid_ether_addr(sprom->et1mac))\n\t\tSET_IEEE80211_PERM_ADDR(hw, sprom->et1mac);\n\telse\n\t\tSET_IEEE80211_PERM_ADDR(hw, sprom->il0mac);\n\n\t \n\twl->hw = hw;\n\tmutex_init(&wl->mutex);\n\tspin_lock_init(&wl->hardirq_lock);\n\tspin_lock_init(&wl->beacon_lock);\n\tINIT_WORK(&wl->beacon_update_trigger, b43_beacon_update_trigger_work);\n\tINIT_WORK(&wl->txpower_adjust_work, b43_phy_txpower_adjust_work);\n\tINIT_WORK(&wl->tx_work, b43_tx_work);\n\n\t \n\tfor (queue_num = 0; queue_num < B43_QOS_QUEUE_NUM; queue_num++) {\n\t\tskb_queue_head_init(&wl->tx_queue[queue_num]);\n\t\twl->tx_queue_stopped[queue_num] = false;\n\t}\n\n\tsnprintf(chip_name, ARRAY_SIZE(chip_name),\n\t\t (dev->chip_id > 0x9999) ? \"%d\" : \"%04X\", dev->chip_id);\n\tb43info(wl, \"Broadcom %s WLAN found (core revision %u)\\n\", chip_name,\n\t\tdev->core_rev);\n\treturn wl;\n}\n\n#ifdef CONFIG_B43_BCMA\nstatic int b43_bcma_probe(struct bcma_device *core)\n{\n\tstruct b43_bus_dev *dev;\n\tstruct b43_wl *wl;\n\tint err;\n\n\tif (!modparam_allhwsupport &&\n\t    (core->id.rev == 0x17 || core->id.rev == 0x18)) {\n\t\tpr_err(\"Support for cores revisions 0x17 and 0x18 disabled by module param allhwsupport=0. Try b43.allhwsupport=1\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tdev = b43_bus_dev_bcma_init(core);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\twl = b43_wireless_init(dev);\n\tif (IS_ERR(wl)) {\n\t\terr = PTR_ERR(wl);\n\t\tgoto bcma_out;\n\t}\n\n\terr = b43_one_core_attach(dev, wl);\n\tif (err)\n\t\tgoto bcma_err_wireless_exit;\n\n\t \n\tINIT_WORK(&wl->firmware_load, b43_request_firmware);\n\tschedule_work(&wl->firmware_load);\n\n\treturn err;\n\nbcma_err_wireless_exit:\n\tieee80211_free_hw(wl->hw);\nbcma_out:\n\tkfree(dev);\n\treturn err;\n}\n\nstatic void b43_bcma_remove(struct bcma_device *core)\n{\n\tstruct b43_wldev *wldev = bcma_get_drvdata(core);\n\tstruct b43_wl *wl = wldev->wl;\n\n\t \n\tcancel_work_sync(&wldev->restart_work);\n\tcancel_work_sync(&wl->firmware_load);\n\n\tB43_WARN_ON(!wl);\n\tif (!wldev->fw.ucode.data)\n\t\treturn;\t\t\t \n\tif (wl->current_dev == wldev && wl->hw_registered) {\n\t\tb43_leds_stop(wldev);\n\t\tieee80211_unregister_hw(wl->hw);\n\t}\n\n\tb43_one_core_detach(wldev->dev);\n\n\t \n\tb43_rng_exit(wl);\n\n\tb43_leds_unregister(wl);\n\tieee80211_free_hw(wl->hw);\n\tkfree(wldev->dev);\n}\n\nstatic struct bcma_driver b43_bcma_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= b43_bcma_tbl,\n\t.probe\t\t= b43_bcma_probe,\n\t.remove\t\t= b43_bcma_remove,\n};\n#endif\n\n#ifdef CONFIG_B43_SSB\nstatic\nint b43_ssb_probe(struct ssb_device *sdev, const struct ssb_device_id *id)\n{\n\tstruct b43_bus_dev *dev;\n\tstruct b43_wl *wl;\n\tint err;\n\n\tdev = b43_bus_dev_ssb_init(sdev);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\twl = ssb_get_devtypedata(sdev);\n\tif (wl) {\n\t\tb43err(NULL, \"Dual-core devices are not supported\\n\");\n\t\terr = -ENOTSUPP;\n\t\tgoto err_ssb_kfree_dev;\n\t}\n\n\tb43_sprom_fixup(sdev->bus);\n\n\twl = b43_wireless_init(dev);\n\tif (IS_ERR(wl)) {\n\t\terr = PTR_ERR(wl);\n\t\tgoto err_ssb_kfree_dev;\n\t}\n\tssb_set_devtypedata(sdev, wl);\n\tB43_WARN_ON(ssb_get_devtypedata(sdev) != wl);\n\n\terr = b43_one_core_attach(dev, wl);\n\tif (err)\n\t\tgoto err_ssb_wireless_exit;\n\n\t \n\tINIT_WORK(&wl->firmware_load, b43_request_firmware);\n\tschedule_work(&wl->firmware_load);\n\n\treturn err;\n\nerr_ssb_wireless_exit:\n\tb43_wireless_exit(dev, wl);\nerr_ssb_kfree_dev:\n\tkfree(dev);\n\treturn err;\n}\n\nstatic void b43_ssb_remove(struct ssb_device *sdev)\n{\n\tstruct b43_wl *wl = ssb_get_devtypedata(sdev);\n\tstruct b43_wldev *wldev = ssb_get_drvdata(sdev);\n\tstruct b43_bus_dev *dev = wldev->dev;\n\n\t \n\tcancel_work_sync(&wldev->restart_work);\n\tcancel_work_sync(&wl->firmware_load);\n\n\tB43_WARN_ON(!wl);\n\tif (!wldev->fw.ucode.data)\n\t\treturn;\t\t\t \n\tif (wl->current_dev == wldev && wl->hw_registered) {\n\t\tb43_leds_stop(wldev);\n\t\tieee80211_unregister_hw(wl->hw);\n\t}\n\n\tb43_one_core_detach(dev);\n\n\t \n\tb43_rng_exit(wl);\n\n\tb43_leds_unregister(wl);\n\tb43_wireless_exit(dev, wl);\n\tkfree(dev);\n}\n\nstatic struct ssb_driver b43_ssb_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= b43_ssb_tbl,\n\t.probe\t\t= b43_ssb_probe,\n\t.remove\t\t= b43_ssb_remove,\n};\n#endif  \n\n \nvoid b43_controller_restart(struct b43_wldev *dev, const char *reason)\n{\n\t \n\tif (b43_status(dev) < B43_STAT_INITIALIZED)\n\t\treturn;\n\tb43info(dev->wl, \"Controller RESET (%s) ...\\n\", reason);\n\tieee80211_queue_work(dev->wl->hw, &dev->restart_work);\n}\n\nstatic void b43_print_driverinfo(void)\n{\n\tconst char *feat_pci = \"\", *feat_nphy = \"\",\n\t\t   *feat_leds = \"\", *feat_sdio = \"\";\n\n#ifdef CONFIG_B43_PCI_AUTOSELECT\n\tfeat_pci = \"P\";\n#endif\n#ifdef CONFIG_B43_PHY_N\n\tfeat_nphy = \"N\";\n#endif\n#ifdef CONFIG_B43_LEDS\n\tfeat_leds = \"L\";\n#endif\n#ifdef CONFIG_B43_SDIO\n\tfeat_sdio = \"S\";\n#endif\n\tprintk(KERN_INFO \"Broadcom 43xx driver loaded \"\n\t       \"[ Features: %s%s%s%s ]\\n\",\n\t       feat_pci, feat_nphy, feat_leds, feat_sdio);\n}\n\nstatic int __init b43_init(void)\n{\n\tint err;\n\n\tb43_debugfs_init();\n\terr = b43_sdio_init();\n\tif (err)\n\t\tgoto err_dfs_exit;\n#ifdef CONFIG_B43_BCMA\n\terr = bcma_driver_register(&b43_bcma_driver);\n\tif (err)\n\t\tgoto err_sdio_exit;\n#endif\n#ifdef CONFIG_B43_SSB\n\terr = ssb_driver_register(&b43_ssb_driver);\n\tif (err)\n\t\tgoto err_bcma_driver_exit;\n#endif\n\tb43_print_driverinfo();\n\n\treturn err;\n\n#ifdef CONFIG_B43_SSB\nerr_bcma_driver_exit:\n#endif\n#ifdef CONFIG_B43_BCMA\n\tbcma_driver_unregister(&b43_bcma_driver);\nerr_sdio_exit:\n#endif\n\tb43_sdio_exit();\nerr_dfs_exit:\n\tb43_debugfs_exit();\n\treturn err;\n}\n\nstatic void __exit b43_exit(void)\n{\n#ifdef CONFIG_B43_SSB\n\tssb_driver_unregister(&b43_ssb_driver);\n#endif\n#ifdef CONFIG_B43_BCMA\n\tbcma_driver_unregister(&b43_bcma_driver);\n#endif\n\tb43_sdio_exit();\n\tb43_debugfs_exit();\n}\n\nmodule_init(b43_init)\nmodule_exit(b43_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}