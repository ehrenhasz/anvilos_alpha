{
  "module_name": "debugfs.c",
  "hash_id": "4ab6c9b9872dc2416fdf1657850c2f10f8b96cb05b402d83c0396395a1477a17",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/b43/debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/netdevice.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n\n#include \"b43.h\"\n#include \"main.h\"\n#include \"debugfs.h\"\n#include \"dma.h\"\n#include \"xmit.h\"\n\n\n \nstatic struct dentry *rootdir;\n\nstruct b43_debugfs_fops {\n\tssize_t (*read)(struct b43_wldev *dev, char *buf, size_t bufsize);\n\tint (*write)(struct b43_wldev *dev, const char *buf, size_t count);\n\tstruct file_operations fops;\n\t \n\tsize_t file_struct_offset;\n};\n\nstatic inline\nstruct b43_dfs_file *fops_to_dfs_file(struct b43_wldev *dev,\n\t\t\t\t      const struct b43_debugfs_fops *dfops)\n{\n\tvoid *p;\n\n\tp = dev->dfsentry;\n\tp += dfops->file_struct_offset;\n\n\treturn p;\n}\n\n\n#define fappend(fmt, x...)\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (bufsize - count)\t\t\t\t\\\n\t\t\tcount += scnprintf(buf + count,\t\t\\\n\t\t\t\t\t  bufsize - count,\t\\\n\t\t\t\t\t  fmt , ##x);\t\t\\\n\t\telse\t\t\t\t\t\t\\\n\t\t\tprintk(KERN_ERR \"b43: fappend overflow\\n\"); \\\n\t} while (0)\n\n\n \n#define B43_MAX_SHM_ROUTING\t4\n#define B43_MAX_SHM_ADDR\t0xFFFF\n\nstatic ssize_t shm16read__read_file(struct b43_wldev *dev,\n\t\t\t\t    char *buf, size_t bufsize)\n{\n\tssize_t count = 0;\n\tunsigned int routing, addr;\n\tu16 val;\n\n\trouting = dev->dfsentry->shm16read_routing_next;\n\taddr = dev->dfsentry->shm16read_addr_next;\n\tif ((routing > B43_MAX_SHM_ROUTING) ||\n\t    (addr > B43_MAX_SHM_ADDR))\n\t\treturn -EDESTADDRREQ;\n\n\tval = b43_shm_read16(dev, routing, addr);\n\tfappend(\"0x%04X\\n\", val);\n\n\treturn count;\n}\n\nstatic int shm16read__write_file(struct b43_wldev *dev,\n\t\t\t\t const char *buf, size_t count)\n{\n\tunsigned int routing, addr;\n\tint res;\n\n\tres = sscanf(buf, \"0x%X 0x%X\", &routing, &addr);\n\tif (res != 2)\n\t\treturn -EINVAL;\n\tif (routing > B43_MAX_SHM_ROUTING)\n\t\treturn -EADDRNOTAVAIL;\n\tif (addr > B43_MAX_SHM_ADDR)\n\t\treturn -EADDRNOTAVAIL;\n\tif (routing == B43_SHM_SHARED) {\n\t\tif ((addr % 2) != 0)\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tdev->dfsentry->shm16read_routing_next = routing;\n\tdev->dfsentry->shm16read_addr_next = addr;\n\n\treturn 0;\n}\n\nstatic int shm16write__write_file(struct b43_wldev *dev,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tunsigned int routing, addr, mask, set;\n\tu16 val;\n\tint res;\n\n\tres = sscanf(buf, \"0x%X 0x%X 0x%X 0x%X\",\n\t\t     &routing, &addr, &mask, &set);\n\tif (res != 4)\n\t\treturn -EINVAL;\n\tif (routing > B43_MAX_SHM_ROUTING)\n\t\treturn -EADDRNOTAVAIL;\n\tif (addr > B43_MAX_SHM_ADDR)\n\t\treturn -EADDRNOTAVAIL;\n\tif (routing == B43_SHM_SHARED) {\n\t\tif ((addr % 2) != 0)\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\tif ((mask > 0xFFFF) || (set > 0xFFFF))\n\t\treturn -E2BIG;\n\n\tif (mask == 0)\n\t\tval = 0;\n\telse\n\t\tval = b43_shm_read16(dev, routing, addr);\n\tval &= mask;\n\tval |= set;\n\tb43_shm_write16(dev, routing, addr, val);\n\n\treturn 0;\n}\n\nstatic ssize_t shm32read__read_file(struct b43_wldev *dev,\n\t\t\t\t    char *buf, size_t bufsize)\n{\n\tssize_t count = 0;\n\tunsigned int routing, addr;\n\tu32 val;\n\n\trouting = dev->dfsentry->shm32read_routing_next;\n\taddr = dev->dfsentry->shm32read_addr_next;\n\tif ((routing > B43_MAX_SHM_ROUTING) ||\n\t    (addr > B43_MAX_SHM_ADDR))\n\t\treturn -EDESTADDRREQ;\n\n\tval = b43_shm_read32(dev, routing, addr);\n\tfappend(\"0x%08X\\n\", val);\n\n\treturn count;\n}\n\nstatic int shm32read__write_file(struct b43_wldev *dev,\n\t\t\t\t const char *buf, size_t count)\n{\n\tunsigned int routing, addr;\n\tint res;\n\n\tres = sscanf(buf, \"0x%X 0x%X\", &routing, &addr);\n\tif (res != 2)\n\t\treturn -EINVAL;\n\tif (routing > B43_MAX_SHM_ROUTING)\n\t\treturn -EADDRNOTAVAIL;\n\tif (addr > B43_MAX_SHM_ADDR)\n\t\treturn -EADDRNOTAVAIL;\n\tif (routing == B43_SHM_SHARED) {\n\t\tif ((addr % 2) != 0)\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tdev->dfsentry->shm32read_routing_next = routing;\n\tdev->dfsentry->shm32read_addr_next = addr;\n\n\treturn 0;\n}\n\nstatic int shm32write__write_file(struct b43_wldev *dev,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tunsigned int routing, addr, mask, set;\n\tu32 val;\n\tint res;\n\n\tres = sscanf(buf, \"0x%X 0x%X 0x%X 0x%X\",\n\t\t     &routing, &addr, &mask, &set);\n\tif (res != 4)\n\t\treturn -EINVAL;\n\tif (routing > B43_MAX_SHM_ROUTING)\n\t\treturn -EADDRNOTAVAIL;\n\tif (addr > B43_MAX_SHM_ADDR)\n\t\treturn -EADDRNOTAVAIL;\n\tif (routing == B43_SHM_SHARED) {\n\t\tif ((addr % 2) != 0)\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\tif ((mask > 0xFFFFFFFF) || (set > 0xFFFFFFFF))\n\t\treturn -E2BIG;\n\n\tif (mask == 0)\n\t\tval = 0;\n\telse\n\t\tval = b43_shm_read32(dev, routing, addr);\n\tval &= mask;\n\tval |= set;\n\tb43_shm_write32(dev, routing, addr, val);\n\n\treturn 0;\n}\n\n \n#define B43_MAX_MMIO_ACCESS\t(0xF00 - 1)\n\nstatic ssize_t mmio16read__read_file(struct b43_wldev *dev,\n\t\t\t\t     char *buf, size_t bufsize)\n{\n\tssize_t count = 0;\n\tunsigned int addr;\n\tu16 val;\n\n\taddr = dev->dfsentry->mmio16read_next;\n\tif (addr > B43_MAX_MMIO_ACCESS)\n\t\treturn -EDESTADDRREQ;\n\n\tval = b43_read16(dev, addr);\n\tfappend(\"0x%04X\\n\", val);\n\n\treturn count;\n}\n\nstatic int mmio16read__write_file(struct b43_wldev *dev,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tunsigned int addr;\n\tint res;\n\n\tres = sscanf(buf, \"0x%X\", &addr);\n\tif (res != 1)\n\t\treturn -EINVAL;\n\tif (addr > B43_MAX_MMIO_ACCESS)\n\t\treturn -EADDRNOTAVAIL;\n\tif ((addr % 2) != 0)\n\t\treturn -EINVAL;\n\n\tdev->dfsentry->mmio16read_next = addr;\n\n\treturn 0;\n}\n\nstatic int mmio16write__write_file(struct b43_wldev *dev,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tunsigned int addr, mask, set;\n\tint res;\n\tu16 val;\n\n\tres = sscanf(buf, \"0x%X 0x%X 0x%X\", &addr, &mask, &set);\n\tif (res != 3)\n\t\treturn -EINVAL;\n\tif (addr > B43_MAX_MMIO_ACCESS)\n\t\treturn -EADDRNOTAVAIL;\n\tif ((mask > 0xFFFF) || (set > 0xFFFF))\n\t\treturn -E2BIG;\n\tif ((addr % 2) != 0)\n\t\treturn -EINVAL;\n\n\tif (mask == 0)\n\t\tval = 0;\n\telse\n\t\tval = b43_read16(dev, addr);\n\tval &= mask;\n\tval |= set;\n\tb43_write16(dev, addr, val);\n\n\treturn 0;\n}\n\nstatic ssize_t mmio32read__read_file(struct b43_wldev *dev,\n\t\t\t\t     char *buf, size_t bufsize)\n{\n\tssize_t count = 0;\n\tunsigned int addr;\n\tu32 val;\n\n\taddr = dev->dfsentry->mmio32read_next;\n\tif (addr > B43_MAX_MMIO_ACCESS)\n\t\treturn -EDESTADDRREQ;\n\n\tval = b43_read32(dev, addr);\n\tfappend(\"0x%08X\\n\", val);\n\n\treturn count;\n}\n\nstatic int mmio32read__write_file(struct b43_wldev *dev,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tunsigned int addr;\n\tint res;\n\n\tres = sscanf(buf, \"0x%X\", &addr);\n\tif (res != 1)\n\t\treturn -EINVAL;\n\tif (addr > B43_MAX_MMIO_ACCESS)\n\t\treturn -EADDRNOTAVAIL;\n\tif ((addr % 4) != 0)\n\t\treturn -EINVAL;\n\n\tdev->dfsentry->mmio32read_next = addr;\n\n\treturn 0;\n}\n\nstatic int mmio32write__write_file(struct b43_wldev *dev,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tunsigned int addr, mask, set;\n\tint res;\n\tu32 val;\n\n\tres = sscanf(buf, \"0x%X 0x%X 0x%X\", &addr, &mask, &set);\n\tif (res != 3)\n\t\treturn -EINVAL;\n\tif (addr > B43_MAX_MMIO_ACCESS)\n\t\treturn -EADDRNOTAVAIL;\n\tif ((mask > 0xFFFFFFFF) || (set > 0xFFFFFFFF))\n\t\treturn -E2BIG;\n\tif ((addr % 4) != 0)\n\t\treturn -EINVAL;\n\n\tif (mask == 0)\n\t\tval = 0;\n\telse\n\t\tval = b43_read32(dev, addr);\n\tval &= mask;\n\tval |= set;\n\tb43_write32(dev, addr, val);\n\n\treturn 0;\n}\n\nstatic ssize_t txstat_read_file(struct b43_wldev *dev,\n\t\t\t\tchar *buf, size_t bufsize)\n{\n\tstruct b43_txstatus_log *log = &dev->dfsentry->txstatlog;\n\tssize_t count = 0;\n\tint i, idx;\n\tstruct b43_txstatus *stat;\n\n\tif (log->end < 0) {\n\t\tfappend(\"Nothing transmitted, yet\\n\");\n\t\tgoto out;\n\t}\n\tfappend(\"b43 TX status reports:\\n\\n\"\n\t\t\"index | cookie | seq | phy_stat | frame_count | \"\n\t\t\"rts_count | supp_reason | pm_indicated | \"\n\t\t\"intermediate | for_ampdu | acked\\n\" \"---\\n\");\n\ti = log->end + 1;\n\tidx = 0;\n\twhile (1) {\n\t\tif (i == B43_NR_LOGGED_TXSTATUS)\n\t\t\ti = 0;\n\t\tstat = &(log->log[i]);\n\t\tif (stat->cookie) {\n\t\t\tfappend(\"%03d | \"\n\t\t\t\t\"0x%04X | 0x%04X | 0x%02X | \"\n\t\t\t\t\"0x%X | 0x%X | \"\n\t\t\t\t\"%u | %u | \"\n\t\t\t\t\"%u | %u | %u\\n\",\n\t\t\t\tidx,\n\t\t\t\tstat->cookie, stat->seq, stat->phy_stat,\n\t\t\t\tstat->frame_count, stat->rts_count,\n\t\t\t\tstat->supp_reason, stat->pm_indicated,\n\t\t\t\tstat->intermediate, stat->for_ampdu,\n\t\t\t\tstat->acked);\n\t\t\tidx++;\n\t\t}\n\t\tif (i == log->end)\n\t\t\tbreak;\n\t\ti++;\n\t}\nout:\n\n\treturn count;\n}\n\nstatic int restart_write_file(struct b43_wldev *dev,\n\t\t\t      const char *buf, size_t count)\n{\n\tint err = 0;\n\n\tif (count > 0 && buf[0] == '1') {\n\t\tb43_controller_restart(dev, \"manually restarted\");\n\t} else\n\t\terr = -EINVAL;\n\n\treturn err;\n}\n\nstatic unsigned long calc_expire_secs(unsigned long now,\n\t\t\t\t      unsigned long time,\n\t\t\t\t      unsigned long expire)\n{\n\texpire = time + expire;\n\n\tif (time_after(now, expire))\n\t\treturn 0;  \n\tif (expire < now) {\n\t\t \n\t\texpire -= MAX_JIFFY_OFFSET;\n\t\tnow -= MAX_JIFFY_OFFSET;\n\t}\n\tB43_WARN_ON(expire < now);\n\n\treturn (expire - now) / HZ;\n}\n\nstatic ssize_t loctls_read_file(struct b43_wldev *dev,\n\t\t\t\tchar *buf, size_t bufsize)\n{\n\tssize_t count = 0;\n\tstruct b43_txpower_lo_control *lo;\n\tint i, err = 0;\n\tstruct b43_lo_calib *cal;\n\tunsigned long now = jiffies;\n\tstruct b43_phy *phy = &dev->phy;\n\n\tif (phy->type != B43_PHYTYPE_G) {\n\t\tfappend(\"Device is not a G-PHY\\n\");\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\tlo = phy->g->lo_control;\n\tfappend(\"-- Local Oscillator calibration data --\\n\\n\");\n\tfappend(\"HW-power-control enabled: %d\\n\",\n\t\tdev->phy.hardware_power_control);\n\tfappend(\"TX Bias: 0x%02X,  TX Magn: 0x%02X  (expire in %lu sec)\\n\",\n\t\tlo->tx_bias, lo->tx_magn,\n\t\tcalc_expire_secs(now, lo->txctl_measured_time,\n\t\t\t\t B43_LO_TXCTL_EXPIRE));\n\tfappend(\"Power Vector: 0x%08X%08X  (expires in %lu sec)\\n\",\n\t\t(unsigned int)((lo->power_vector & 0xFFFFFFFF00000000ULL) >> 32),\n\t\t(unsigned int)(lo->power_vector & 0x00000000FFFFFFFFULL),\n\t\tcalc_expire_secs(now, lo->pwr_vec_read_time,\n\t\t\t\t B43_LO_PWRVEC_EXPIRE));\n\n\tfappend(\"\\nCalibrated settings:\\n\");\n\tlist_for_each_entry(cal, &lo->calib_list, list) {\n\t\tbool active;\n\n\t\tactive = (b43_compare_bbatt(&cal->bbatt, &phy->g->bbatt) &&\n\t\t\t  b43_compare_rfatt(&cal->rfatt, &phy->g->rfatt));\n\t\tfappend(\"BB(%d), RF(%d,%d)  ->  I=%d, Q=%d  \"\n\t\t\t\"(expires in %lu sec)%s\\n\",\n\t\t\tcal->bbatt.att,\n\t\t\tcal->rfatt.att, cal->rfatt.with_padmix,\n\t\t\tcal->ctl.i, cal->ctl.q,\n\t\t\tcalc_expire_secs(now, cal->calib_time,\n\t\t\t\t\t B43_LO_CALIB_EXPIRE),\n\t\t\tactive ? \"  ACTIVE\" : \"\");\n\t}\n\n\tfappend(\"\\nUsed RF attenuation values:  Value(WithPadmix flag)\\n\");\n\tfor (i = 0; i < lo->rfatt_list.len; i++) {\n\t\tfappend(\"%u(%d), \",\n\t\t\tlo->rfatt_list.list[i].att,\n\t\t\tlo->rfatt_list.list[i].with_padmix);\n\t}\n\tfappend(\"\\n\");\n\tfappend(\"\\nUsed Baseband attenuation values:\\n\");\n\tfor (i = 0; i < lo->bbatt_list.len; i++) {\n\t\tfappend(\"%u, \",\n\t\t\tlo->bbatt_list.list[i].att);\n\t}\n\tfappend(\"\\n\");\n\nout:\n\treturn err ? err : count;\n}\n\n#undef fappend\n\nstatic ssize_t b43_debugfs_read(struct file *file, char __user *userbuf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct b43_wldev *dev;\n\tstruct b43_debugfs_fops *dfops;\n\tstruct b43_dfs_file *dfile;\n\tssize_t ret;\n\tchar *buf;\n\tconst size_t bufsize = 1024 * 16;  \n\tconst size_t buforder = get_order(bufsize);\n\tint err = 0;\n\n\tif (!count)\n\t\treturn 0;\n\tdev = file->private_data;\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&dev->wl->mutex);\n\tif (b43_status(dev) < B43_STAT_INITIALIZED) {\n\t\terr = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tdfops = container_of(debugfs_real_fops(file),\n\t\t\t     struct b43_debugfs_fops, fops);\n\tif (!dfops->read) {\n\t\terr = -ENOSYS;\n\t\tgoto out_unlock;\n\t}\n\tdfile = fops_to_dfs_file(dev, dfops);\n\n\tif (!dfile->buffer) {\n\t\tbuf = (char *)__get_free_pages(GFP_KERNEL, buforder);\n\t\tif (!buf) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tmemset(buf, 0, bufsize);\n\t\tret = dfops->read(dev, buf, bufsize);\n\t\tif (ret <= 0) {\n\t\t\tfree_pages((unsigned long)buf, buforder);\n\t\t\terr = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tdfile->data_len = ret;\n\t\tdfile->buffer = buf;\n\t}\n\n\tret = simple_read_from_buffer(userbuf, count, ppos,\n\t\t\t\t      dfile->buffer,\n\t\t\t\t      dfile->data_len);\n\tif (*ppos >= dfile->data_len) {\n\t\tfree_pages((unsigned long)dfile->buffer, buforder);\n\t\tdfile->buffer = NULL;\n\t\tdfile->data_len = 0;\n\t}\nout_unlock:\n\tmutex_unlock(&dev->wl->mutex);\n\n\treturn err ? err : ret;\n}\n\nstatic ssize_t b43_debugfs_write(struct file *file,\n\t\t\t\t const char __user *userbuf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct b43_wldev *dev;\n\tstruct b43_debugfs_fops *dfops;\n\tchar *buf;\n\tint err = 0;\n\n\tif (!count)\n\t\treturn 0;\n\tif (count > PAGE_SIZE)\n\t\treturn -E2BIG;\n\tdev = file->private_data;\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&dev->wl->mutex);\n\tif (b43_status(dev) < B43_STAT_INITIALIZED) {\n\t\terr = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tdfops = container_of(debugfs_real_fops(file),\n\t\t\t     struct b43_debugfs_fops, fops);\n\tif (!dfops->write) {\n\t\terr = -ENOSYS;\n\t\tgoto out_unlock;\n\t}\n\n\tbuf = (char *)get_zeroed_page(GFP_KERNEL);\n\tif (!buf) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\tif (copy_from_user(buf, userbuf, count)) {\n\t\terr = -EFAULT;\n\t\tgoto out_freepage;\n\t}\n\terr = dfops->write(dev, buf, count);\n\tif (err)\n\t\tgoto out_freepage;\n\nout_freepage:\n\tfree_page((unsigned long)buf);\nout_unlock:\n\tmutex_unlock(&dev->wl->mutex);\n\n\treturn err ? err : count;\n}\n\n\n#define B43_DEBUGFS_FOPS(name, _read, _write)\t\t\t\\\n\tstatic struct b43_debugfs_fops fops_##name = {\t\t\\\n\t\t.read\t= _read,\t\t\t\t\\\n\t\t.write\t= _write,\t\t\t\t\\\n\t\t.fops\t= {\t\t\t\t\t\\\n\t\t\t.open\t= simple_open,\t\t\t\\\n\t\t\t.read\t= b43_debugfs_read,\t\t\\\n\t\t\t.write\t= b43_debugfs_write,\t\t\\\n\t\t\t.llseek = generic_file_llseek,\t\t\\\n\t\t},\t\t\t\t\t\t\\\n\t\t.file_struct_offset = offsetof(struct b43_dfsentry, \\\n\t\t\t\t\t       file_##name),\t\\\n\t}\n\nB43_DEBUGFS_FOPS(shm16read, shm16read__read_file, shm16read__write_file);\nB43_DEBUGFS_FOPS(shm16write, NULL, shm16write__write_file);\nB43_DEBUGFS_FOPS(shm32read, shm32read__read_file, shm32read__write_file);\nB43_DEBUGFS_FOPS(shm32write, NULL, shm32write__write_file);\nB43_DEBUGFS_FOPS(mmio16read, mmio16read__read_file, mmio16read__write_file);\nB43_DEBUGFS_FOPS(mmio16write, NULL, mmio16write__write_file);\nB43_DEBUGFS_FOPS(mmio32read, mmio32read__read_file, mmio32read__write_file);\nB43_DEBUGFS_FOPS(mmio32write, NULL, mmio32write__write_file);\nB43_DEBUGFS_FOPS(txstat, txstat_read_file, NULL);\nB43_DEBUGFS_FOPS(restart, NULL, restart_write_file);\nB43_DEBUGFS_FOPS(loctls, loctls_read_file, NULL);\n\n\nbool b43_debug(struct b43_wldev *dev, enum b43_dyndbg feature)\n{\n\tbool enabled;\n\n\tenabled = (dev->dfsentry && dev->dfsentry->dyn_debug[feature]);\n\tif (unlikely(enabled)) {\n\t\t \n\t\tb43_modparam_verbose = B43_VERBOSITY_MAX;\n\t}\n\n\treturn enabled;\n}\n\nstatic void b43_add_dynamic_debug(struct b43_wldev *dev)\n{\n\tstruct b43_dfsentry *e = dev->dfsentry;\n\n#define add_dyn_dbg(name, id, initstate) do {\t\t\t\\\n\te->dyn_debug[id] = (initstate);\t\t\t\t\\\n\tdebugfs_create_bool(name, 0600, e->subdir,\t\t\\\n\t\t\t    &(e->dyn_debug[id]));\t\t\\\n\t} while (0)\n\n\tadd_dyn_dbg(\"debug_xmitpower\", B43_DBG_XMITPOWER, false);\n\tadd_dyn_dbg(\"debug_dmaoverflow\", B43_DBG_DMAOVERFLOW, false);\n\tadd_dyn_dbg(\"debug_dmaverbose\", B43_DBG_DMAVERBOSE, false);\n\tadd_dyn_dbg(\"debug_pwork_fast\", B43_DBG_PWORK_FAST, false);\n\tadd_dyn_dbg(\"debug_pwork_stop\", B43_DBG_PWORK_STOP, false);\n\tadd_dyn_dbg(\"debug_lo\", B43_DBG_LO, false);\n\tadd_dyn_dbg(\"debug_firmware\", B43_DBG_FIRMWARE, false);\n\tadd_dyn_dbg(\"debug_keys\", B43_DBG_KEYS, false);\n\tadd_dyn_dbg(\"debug_verbose_stats\", B43_DBG_VERBOSESTATS, false);\n\n#undef add_dyn_dbg\n}\n\nvoid b43_debugfs_add_device(struct b43_wldev *dev)\n{\n\tstruct b43_dfsentry *e;\n\tstruct b43_txstatus_log *log;\n\tchar devdir[16];\n\n\tB43_WARN_ON(!dev);\n\te = kzalloc(sizeof(*e), GFP_KERNEL);\n\tif (!e) {\n\t\tb43err(dev->wl, \"debugfs: add device OOM\\n\");\n\t\treturn;\n\t}\n\te->dev = dev;\n\tlog = &e->txstatlog;\n\tlog->log = kcalloc(B43_NR_LOGGED_TXSTATUS,\n\t\t\t   sizeof(struct b43_txstatus), GFP_KERNEL);\n\tif (!log->log) {\n\t\tb43err(dev->wl, \"debugfs: add device txstatus OOM\\n\");\n\t\tkfree(e);\n\t\treturn;\n\t}\n\tlog->end = -1;\n\n\tdev->dfsentry = e;\n\n\tsnprintf(devdir, sizeof(devdir), \"%s\", wiphy_name(dev->wl->hw->wiphy));\n\te->subdir = debugfs_create_dir(devdir, rootdir);\n\n\te->mmio16read_next = 0xFFFF;  \n\te->mmio32read_next = 0xFFFF;  \n\te->shm16read_routing_next = 0xFFFFFFFF;  \n\te->shm16read_addr_next = 0xFFFFFFFF;  \n\te->shm32read_routing_next = 0xFFFFFFFF;  \n\te->shm32read_addr_next = 0xFFFFFFFF;  \n\n#define ADD_FILE(name, mode)\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tdebugfs_create_file(__stringify(name),\t\t\\\n\t\t\t\tmode, e->subdir, dev,\t\t\\\n\t\t\t\t&fops_##name.fops);\t\t\\\n\t} while (0)\n\n\n\tADD_FILE(shm16read, 0600);\n\tADD_FILE(shm16write, 0200);\n\tADD_FILE(shm32read, 0600);\n\tADD_FILE(shm32write, 0200);\n\tADD_FILE(mmio16read, 0600);\n\tADD_FILE(mmio16write, 0200);\n\tADD_FILE(mmio32read, 0600);\n\tADD_FILE(mmio32write, 0200);\n\tADD_FILE(txstat, 0400);\n\tADD_FILE(restart, 0200);\n\tADD_FILE(loctls, 0400);\n\n#undef ADD_FILE\n\n\tb43_add_dynamic_debug(dev);\n}\n\nvoid b43_debugfs_remove_device(struct b43_wldev *dev)\n{\n\tstruct b43_dfsentry *e;\n\n\tif (!dev)\n\t\treturn;\n\te = dev->dfsentry;\n\tif (!e)\n\t\treturn;\n\n\tdebugfs_remove(e->subdir);\n\tkfree(e->txstatlog.log);\n\tkfree(e);\n}\n\nvoid b43_debugfs_log_txstat(struct b43_wldev *dev,\n\t\t\t    const struct b43_txstatus *status)\n{\n\tstruct b43_dfsentry *e = dev->dfsentry;\n\tstruct b43_txstatus_log *log;\n\tstruct b43_txstatus *cur;\n\tint i;\n\n\tif (!e)\n\t\treturn;\n\tlog = &e->txstatlog;\n\ti = log->end + 1;\n\tif (i == B43_NR_LOGGED_TXSTATUS)\n\t\ti = 0;\n\tlog->end = i;\n\tcur = &(log->log[i]);\n\tmemcpy(cur, status, sizeof(*cur));\n}\n\nvoid b43_debugfs_init(void)\n{\n\trootdir = debugfs_create_dir(KBUILD_MODNAME, NULL);\n}\n\nvoid b43_debugfs_exit(void)\n{\n\tdebugfs_remove(rootdir);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}