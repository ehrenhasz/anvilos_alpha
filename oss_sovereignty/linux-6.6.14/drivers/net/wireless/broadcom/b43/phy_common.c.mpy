{
  "module_name": "phy_common.c",
  "hash_id": "8422361b09fea5f89483453acb568a2d4c8fd4f5713d8f5669134d50778f3498",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/b43/phy_common.c",
  "human_readable_source": "\n \n\n#include \"phy_common.h\"\n#include \"phy_g.h\"\n#include \"phy_a.h\"\n#include \"phy_n.h\"\n#include \"phy_lp.h\"\n#include \"phy_ht.h\"\n#include \"phy_lcn.h\"\n#include \"phy_ac.h\"\n#include \"b43.h\"\n#include \"main.h\"\n\n\nint b43_phy_allocate(struct b43_wldev *dev)\n{\n\tstruct b43_phy *phy = &(dev->phy);\n\tint err;\n\n\tphy->ops = NULL;\n\n\tswitch (phy->type) {\n\tcase B43_PHYTYPE_G:\n#ifdef CONFIG_B43_PHY_G\n\t\tphy->ops = &b43_phyops_g;\n#endif\n\t\tbreak;\n\tcase B43_PHYTYPE_N:\n#ifdef CONFIG_B43_PHY_N\n\t\tphy->ops = &b43_phyops_n;\n#endif\n\t\tbreak;\n\tcase B43_PHYTYPE_LP:\n#ifdef CONFIG_B43_PHY_LP\n\t\tphy->ops = &b43_phyops_lp;\n#endif\n\t\tbreak;\n\tcase B43_PHYTYPE_HT:\n#ifdef CONFIG_B43_PHY_HT\n\t\tphy->ops = &b43_phyops_ht;\n#endif\n\t\tbreak;\n\tcase B43_PHYTYPE_LCN:\n#ifdef CONFIG_B43_PHY_LCN\n\t\tphy->ops = &b43_phyops_lcn;\n#endif\n\t\tbreak;\n\tcase B43_PHYTYPE_AC:\n#ifdef CONFIG_B43_PHY_AC\n\t\tphy->ops = &b43_phyops_ac;\n#endif\n\t\tbreak;\n\t}\n\tif (B43_WARN_ON(!phy->ops))\n\t\treturn -ENODEV;\n\n\terr = phy->ops->allocate(dev);\n\tif (err)\n\t\tphy->ops = NULL;\n\n\treturn err;\n}\n\nvoid b43_phy_free(struct b43_wldev *dev)\n{\n\tdev->phy.ops->free(dev);\n\tdev->phy.ops = NULL;\n}\n\nint b43_phy_init(struct b43_wldev *dev)\n{\n\tstruct b43_phy *phy = &dev->phy;\n\tconst struct b43_phy_operations *ops = phy->ops;\n\tint err;\n\n\t \n\tif (!phy->chandef) {\n\t\tphy->chandef = &dev->wl->hw->conf.chandef;\n\t\tphy->channel = phy->chandef->chan->hw_value;\n\t}\n\n\tphy->ops->switch_analog(dev, true);\n\tb43_software_rfkill(dev, false);\n\n\terr = ops->init(dev);\n\tif (err) {\n\t\tb43err(dev->wl, \"PHY init failed\\n\");\n\t\tgoto err_block_rf;\n\t}\n\tphy->do_full_init = false;\n\n\terr = b43_switch_channel(dev, phy->channel);\n\tif (err) {\n\t\tb43err(dev->wl, \"PHY init: Channel switch to default failed\\n\");\n\t\tgoto err_phy_exit;\n\t}\n\n\treturn 0;\n\nerr_phy_exit:\n\tphy->do_full_init = true;\n\tif (ops->exit)\n\t\tops->exit(dev);\nerr_block_rf:\n\tb43_software_rfkill(dev, true);\n\n\treturn err;\n}\n\nvoid b43_phy_exit(struct b43_wldev *dev)\n{\n\tconst struct b43_phy_operations *ops = dev->phy.ops;\n\n\tb43_software_rfkill(dev, true);\n\tdev->phy.do_full_init = true;\n\tif (ops->exit)\n\t\tops->exit(dev);\n}\n\nbool b43_has_hardware_pctl(struct b43_wldev *dev)\n{\n\tif (!dev->phy.hardware_power_control)\n\t\treturn false;\n\tif (!dev->phy.ops->supports_hwpctl)\n\t\treturn false;\n\treturn dev->phy.ops->supports_hwpctl(dev);\n}\n\nvoid b43_radio_lock(struct b43_wldev *dev)\n{\n\tu32 macctl;\n\n#if B43_DEBUG\n\tB43_WARN_ON(dev->phy.radio_locked);\n\tdev->phy.radio_locked = true;\n#endif\n\n\tmacctl = b43_read32(dev, B43_MMIO_MACCTL);\n\tmacctl |= B43_MACCTL_RADIOLOCK;\n\tb43_write32(dev, B43_MMIO_MACCTL, macctl);\n\t \n\tb43_read32(dev, B43_MMIO_MACCTL);\n\tudelay(10);\n}\n\nvoid b43_radio_unlock(struct b43_wldev *dev)\n{\n\tu32 macctl;\n\n#if B43_DEBUG\n\tB43_WARN_ON(!dev->phy.radio_locked);\n\tdev->phy.radio_locked = false;\n#endif\n\n\t \n\tb43_read16(dev, B43_MMIO_PHY_VER);\n\t \n\tmacctl = b43_read32(dev, B43_MMIO_MACCTL);\n\tmacctl &= ~B43_MACCTL_RADIOLOCK;\n\tb43_write32(dev, B43_MMIO_MACCTL, macctl);\n}\n\nvoid b43_phy_lock(struct b43_wldev *dev)\n{\n#if B43_DEBUG\n\tB43_WARN_ON(dev->phy.phy_locked);\n\tdev->phy.phy_locked = true;\n#endif\n\tB43_WARN_ON(dev->dev->core_rev < 3);\n\n\tif (!b43_is_mode(dev->wl, NL80211_IFTYPE_AP))\n\t\tb43_power_saving_ctl_bits(dev, B43_PS_AWAKE);\n}\n\nvoid b43_phy_unlock(struct b43_wldev *dev)\n{\n#if B43_DEBUG\n\tB43_WARN_ON(!dev->phy.phy_locked);\n\tdev->phy.phy_locked = false;\n#endif\n\tB43_WARN_ON(dev->dev->core_rev < 3);\n\n\tif (!b43_is_mode(dev->wl, NL80211_IFTYPE_AP))\n\t\tb43_power_saving_ctl_bits(dev, 0);\n}\n\nstatic inline void assert_mac_suspended(struct b43_wldev *dev)\n{\n\tif (!B43_DEBUG)\n\t\treturn;\n\tif ((b43_status(dev) >= B43_STAT_INITIALIZED) &&\n\t    (dev->mac_suspended <= 0)) {\n\t\tb43dbg(dev->wl, \"PHY/RADIO register access with \"\n\t\t       \"enabled MAC.\\n\");\n\t\tdump_stack();\n\t}\n}\n\nu16 b43_radio_read(struct b43_wldev *dev, u16 reg)\n{\n\tassert_mac_suspended(dev);\n\tdev->phy.writes_counter = 0;\n\treturn dev->phy.ops->radio_read(dev, reg);\n}\n\nvoid b43_radio_write(struct b43_wldev *dev, u16 reg, u16 value)\n{\n\tassert_mac_suspended(dev);\n\tif (b43_bus_host_is_pci(dev->dev) &&\n\t    ++dev->phy.writes_counter > B43_MAX_WRITES_IN_ROW) {\n\t\tb43_read32(dev, B43_MMIO_MACCTL);\n\t\tdev->phy.writes_counter = 1;\n\t}\n\tdev->phy.ops->radio_write(dev, reg, value);\n}\n\nvoid b43_radio_mask(struct b43_wldev *dev, u16 offset, u16 mask)\n{\n\tb43_radio_write16(dev, offset,\n\t\t\t  b43_radio_read16(dev, offset) & mask);\n}\n\nvoid b43_radio_set(struct b43_wldev *dev, u16 offset, u16 set)\n{\n\tb43_radio_write16(dev, offset,\n\t\t\t  b43_radio_read16(dev, offset) | set);\n}\n\nvoid b43_radio_maskset(struct b43_wldev *dev, u16 offset, u16 mask, u16 set)\n{\n\tb43_radio_write16(dev, offset,\n\t\t\t  (b43_radio_read16(dev, offset) & mask) | set);\n}\n\nbool b43_radio_wait_value(struct b43_wldev *dev, u16 offset, u16 mask,\n\t\t\t  u16 value, int delay, int timeout)\n{\n\tu16 val;\n\tint i;\n\n\tfor (i = 0; i < timeout; i += delay) {\n\t\tval = b43_radio_read(dev, offset);\n\t\tif ((val & mask) == value)\n\t\t\treturn true;\n\t\tudelay(delay);\n\t}\n\treturn false;\n}\n\nu16 b43_phy_read(struct b43_wldev *dev, u16 reg)\n{\n\tassert_mac_suspended(dev);\n\tdev->phy.writes_counter = 0;\n\n\tif (dev->phy.ops->phy_read)\n\t\treturn dev->phy.ops->phy_read(dev, reg);\n\n\tb43_write16f(dev, B43_MMIO_PHY_CONTROL, reg);\n\treturn b43_read16(dev, B43_MMIO_PHY_DATA);\n}\n\nvoid b43_phy_write(struct b43_wldev *dev, u16 reg, u16 value)\n{\n\tassert_mac_suspended(dev);\n\tif (b43_bus_host_is_pci(dev->dev) &&\n\t    ++dev->phy.writes_counter > B43_MAX_WRITES_IN_ROW) {\n\t\tb43_read16(dev, B43_MMIO_PHY_VER);\n\t\tdev->phy.writes_counter = 1;\n\t}\n\n\tif (dev->phy.ops->phy_write)\n\t\treturn dev->phy.ops->phy_write(dev, reg, value);\n\n\tb43_write16f(dev, B43_MMIO_PHY_CONTROL, reg);\n\tb43_write16(dev, B43_MMIO_PHY_DATA, value);\n}\n\nvoid b43_phy_copy(struct b43_wldev *dev, u16 destreg, u16 srcreg)\n{\n\tb43_phy_write(dev, destreg, b43_phy_read(dev, srcreg));\n}\n\nvoid b43_phy_mask(struct b43_wldev *dev, u16 offset, u16 mask)\n{\n\tif (dev->phy.ops->phy_maskset) {\n\t\tassert_mac_suspended(dev);\n\t\tdev->phy.ops->phy_maskset(dev, offset, mask, 0);\n\t} else {\n\t\tb43_phy_write(dev, offset,\n\t\t\t      b43_phy_read(dev, offset) & mask);\n\t}\n}\n\nvoid b43_phy_set(struct b43_wldev *dev, u16 offset, u16 set)\n{\n\tif (dev->phy.ops->phy_maskset) {\n\t\tassert_mac_suspended(dev);\n\t\tdev->phy.ops->phy_maskset(dev, offset, 0xFFFF, set);\n\t} else {\n\t\tb43_phy_write(dev, offset,\n\t\t\t      b43_phy_read(dev, offset) | set);\n\t}\n}\n\nvoid b43_phy_maskset(struct b43_wldev *dev, u16 offset, u16 mask, u16 set)\n{\n\tif (dev->phy.ops->phy_maskset) {\n\t\tassert_mac_suspended(dev);\n\t\tdev->phy.ops->phy_maskset(dev, offset, mask, set);\n\t} else {\n\t\tb43_phy_write(dev, offset,\n\t\t\t      (b43_phy_read(dev, offset) & mask) | set);\n\t}\n}\n\nvoid b43_phy_put_into_reset(struct b43_wldev *dev)\n{\n\tu32 tmp;\n\n\tswitch (dev->dev->bus_type) {\n#ifdef CONFIG_B43_BCMA\n\tcase B43_BUS_BCMA:\n\t\ttmp = bcma_aread32(dev->dev->bdev, BCMA_IOCTL);\n\t\ttmp &= ~B43_BCMA_IOCTL_GMODE;\n\t\ttmp |= B43_BCMA_IOCTL_PHY_RESET;\n\t\ttmp |= BCMA_IOCTL_FGC;\n\t\tbcma_awrite32(dev->dev->bdev, BCMA_IOCTL, tmp);\n\t\tudelay(1);\n\n\t\ttmp = bcma_aread32(dev->dev->bdev, BCMA_IOCTL);\n\t\ttmp &= ~BCMA_IOCTL_FGC;\n\t\tbcma_awrite32(dev->dev->bdev, BCMA_IOCTL, tmp);\n\t\tudelay(1);\n\t\tbreak;\n#endif\n#ifdef CONFIG_B43_SSB\n\tcase B43_BUS_SSB:\n\t\ttmp = ssb_read32(dev->dev->sdev, SSB_TMSLOW);\n\t\ttmp &= ~B43_TMSLOW_GMODE;\n\t\ttmp |= B43_TMSLOW_PHYRESET;\n\t\ttmp |= SSB_TMSLOW_FGC;\n\t\tssb_write32(dev->dev->sdev, SSB_TMSLOW, tmp);\n\t\tusleep_range(1000, 2000);\n\n\t\ttmp = ssb_read32(dev->dev->sdev, SSB_TMSLOW);\n\t\ttmp &= ~SSB_TMSLOW_FGC;\n\t\tssb_write32(dev->dev->sdev, SSB_TMSLOW, tmp);\n\t\tusleep_range(1000, 2000);\n\n\t\tbreak;\n#endif\n\t}\n}\n\nvoid b43_phy_take_out_of_reset(struct b43_wldev *dev)\n{\n\tu32 tmp;\n\n\tswitch (dev->dev->bus_type) {\n#ifdef CONFIG_B43_BCMA\n\tcase B43_BUS_BCMA:\n\t\t \n\t\ttmp = bcma_aread32(dev->dev->bdev, BCMA_IOCTL);\n\t\ttmp &= ~B43_BCMA_IOCTL_PHY_RESET;\n\t\ttmp &= ~B43_BCMA_IOCTL_PHY_CLKEN;\n\t\ttmp |= BCMA_IOCTL_FGC;\n\t\tbcma_awrite32(dev->dev->bdev, BCMA_IOCTL, tmp);\n\t\tudelay(1);\n\n\t\t \n\t\ttmp = bcma_aread32(dev->dev->bdev, BCMA_IOCTL);\n\t\ttmp &= ~BCMA_IOCTL_FGC;\n\t\ttmp |= B43_BCMA_IOCTL_PHY_CLKEN;\n\t\tbcma_awrite32(dev->dev->bdev, BCMA_IOCTL, tmp);\n\t\tudelay(1);\n\t\tbreak;\n#endif\n#ifdef CONFIG_B43_SSB\n\tcase B43_BUS_SSB:\n\t\t \n\t\ttmp = ssb_read32(dev->dev->sdev, SSB_TMSLOW);\n\t\ttmp &= ~B43_TMSLOW_PHYRESET;\n\t\ttmp &= ~B43_TMSLOW_PHYCLKEN;\n\t\ttmp |= SSB_TMSLOW_FGC;\n\t\tssb_write32(dev->dev->sdev, SSB_TMSLOW, tmp);\n\t\tssb_read32(dev->dev->sdev, SSB_TMSLOW);  \n\t\tusleep_range(1000, 2000);\n\n\t\ttmp = ssb_read32(dev->dev->sdev, SSB_TMSLOW);\n\t\ttmp &= ~SSB_TMSLOW_FGC;\n\t\ttmp |= B43_TMSLOW_PHYCLKEN;\n\t\tssb_write32(dev->dev->sdev, SSB_TMSLOW, tmp);\n\t\tssb_read32(dev->dev->sdev, SSB_TMSLOW);  \n\t\tusleep_range(1000, 2000);\n\t\tbreak;\n#endif\n\t}\n}\n\nint b43_switch_channel(struct b43_wldev *dev, unsigned int new_channel)\n{\n\tstruct b43_phy *phy = &(dev->phy);\n\tu16 channelcookie, savedcookie;\n\tint err;\n\n\t \n\tchannelcookie = new_channel;\n\tif (b43_current_band(dev->wl) == NL80211_BAND_5GHZ)\n\t\tchannelcookie |= B43_SHM_SH_CHAN_5GHZ;\n\t \n\tif (0)\n\t\tchannelcookie |= B43_SHM_SH_CHAN_40MHZ;\n\tsavedcookie = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_CHAN);\n\tb43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_CHAN, channelcookie);\n\n\t \n\terr = phy->ops->switch_channel(dev, new_channel);\n\tif (err)\n\t\tgoto err_restore_cookie;\n\n\t \n\tmsleep(8);\n\n\treturn 0;\n\nerr_restore_cookie:\n\tb43_shm_write16(dev, B43_SHM_SHARED,\n\t\t\tB43_SHM_SH_CHAN, savedcookie);\n\n\treturn err;\n}\n\nvoid b43_software_rfkill(struct b43_wldev *dev, bool blocked)\n{\n\tstruct b43_phy *phy = &dev->phy;\n\n\tb43_mac_suspend(dev);\n\tphy->ops->software_rfkill(dev, blocked);\n\tphy->radio_on = !blocked;\n\tb43_mac_enable(dev);\n}\n\n \nvoid b43_phy_txpower_adjust_work(struct work_struct *work)\n{\n\tstruct b43_wl *wl = container_of(work, struct b43_wl,\n\t\t\t\t\t txpower_adjust_work);\n\tstruct b43_wldev *dev;\n\n\tmutex_lock(&wl->mutex);\n\tdev = wl->current_dev;\n\n\tif (likely(dev && (b43_status(dev) >= B43_STAT_STARTED)))\n\t\tdev->phy.ops->adjust_txpower(dev);\n\n\tmutex_unlock(&wl->mutex);\n}\n\nvoid b43_phy_txpower_check(struct b43_wldev *dev, unsigned int flags)\n{\n\tstruct b43_phy *phy = &dev->phy;\n\tunsigned long now = jiffies;\n\tenum b43_txpwr_result result;\n\n\tif (!(flags & B43_TXPWR_IGNORE_TIME)) {\n\t\t \n\t\tif (time_before(now, phy->next_txpwr_check_time))\n\t\t\treturn;  \n\t}\n\t \n\tphy->next_txpwr_check_time = round_jiffies(now + (HZ * 2));\n\n\tif ((dev->dev->board_vendor == SSB_BOARDVENDOR_BCM) &&\n\t    (dev->dev->board_type == SSB_BOARD_BU4306))\n\t\treturn;  \n\n\tresult = phy->ops->recalc_txpower(dev, !!(flags & B43_TXPWR_IGNORE_TSSI));\n\tif (result == B43_TXPWR_RES_DONE)\n\t\treturn;  \n\tB43_WARN_ON(result != B43_TXPWR_RES_NEED_ADJUST);\n\tB43_WARN_ON(phy->ops->adjust_txpower == NULL);\n\n\t \n\tieee80211_queue_work(dev->wl->hw, &dev->wl->txpower_adjust_work);\n}\n\nint b43_phy_shm_tssi_read(struct b43_wldev *dev, u16 shm_offset)\n{\n\tconst bool is_ofdm = (shm_offset != B43_SHM_SH_TSSI_CCK);\n\tunsigned int a, b, c, d;\n\tunsigned int average;\n\tu32 tmp;\n\n\ttmp = b43_shm_read32(dev, B43_SHM_SHARED, shm_offset);\n\ta = tmp & 0xFF;\n\tb = (tmp >> 8) & 0xFF;\n\tc = (tmp >> 16) & 0xFF;\n\td = (tmp >> 24) & 0xFF;\n\tif (a == 0 || a == B43_TSSI_MAX ||\n\t    b == 0 || b == B43_TSSI_MAX ||\n\t    c == 0 || c == B43_TSSI_MAX ||\n\t    d == 0 || d == B43_TSSI_MAX)\n\t\treturn -ENOENT;\n\t \n\ttmp = B43_TSSI_MAX | (B43_TSSI_MAX << 8) |\n\t      (B43_TSSI_MAX << 16) | (B43_TSSI_MAX << 24);\n\tb43_shm_write32(dev, B43_SHM_SHARED, shm_offset, tmp);\n\n\tif (is_ofdm) {\n\t\ta = (a + 32) & 0x3F;\n\t\tb = (b + 32) & 0x3F;\n\t\tc = (c + 32) & 0x3F;\n\t\td = (d + 32) & 0x3F;\n\t}\n\n\t \n\taverage = (a + b + c + d + 2) / 4;\n\tif (is_ofdm) {\n\t\t \n\t\tif (b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_HOSTF1)\n\t\t    & B43_HF_CCKBOOST)\n\t\t\taverage = (average >= 13) ? (average - 13) : 0;\n\t}\n\n\treturn average;\n}\n\nvoid b43_phyop_switch_analog_generic(struct b43_wldev *dev, bool on)\n{\n\tb43_write16(dev, B43_MMIO_PHY0, on ? 0 : 0xF4);\n}\n\n\nbool b43_is_40mhz(struct b43_wldev *dev)\n{\n\treturn dev->phy.chandef->width == NL80211_CHAN_WIDTH_40;\n}\n\n/* https:\nvoid b43_phy_force_clock(struct b43_wldev *dev, bool force)\n{\n\tu32 tmp;\n\n\tWARN_ON(dev->phy.type != B43_PHYTYPE_N &&\n\t\tdev->phy.type != B43_PHYTYPE_HT &&\n\t\tdev->phy.type != B43_PHYTYPE_AC);\n\n\tswitch (dev->dev->bus_type) {\n#ifdef CONFIG_B43_BCMA\n\tcase B43_BUS_BCMA:\n\t\ttmp = bcma_aread32(dev->dev->bdev, BCMA_IOCTL);\n\t\tif (force)\n\t\t\ttmp |= BCMA_IOCTL_FGC;\n\t\telse\n\t\t\ttmp &= ~BCMA_IOCTL_FGC;\n\t\tbcma_awrite32(dev->dev->bdev, BCMA_IOCTL, tmp);\n\t\tbreak;\n#endif\n#ifdef CONFIG_B43_SSB\n\tcase B43_BUS_SSB:\n\t\ttmp = ssb_read32(dev->dev->sdev, SSB_TMSLOW);\n\t\tif (force)\n\t\t\ttmp |= SSB_TMSLOW_FGC;\n\t\telse\n\t\t\ttmp &= ~SSB_TMSLOW_FGC;\n\t\tssb_write32(dev->dev->sdev, SSB_TMSLOW, tmp);\n\t\tbreak;\n#endif\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}