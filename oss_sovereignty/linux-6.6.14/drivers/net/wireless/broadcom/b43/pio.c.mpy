{
  "module_name": "pio.c",
  "hash_id": "9ecf424e3d8d584d53b9c518be25aa792e21ccc35f5acb8039d1c98099fb7ad7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/b43/pio.c",
  "human_readable_source": "\n \n\n#include \"b43.h\"\n#include \"pio.h\"\n#include \"dma.h\"\n#include \"main.h\"\n#include \"xmit.h\"\n\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n\nstatic u16 generate_cookie(struct b43_pio_txqueue *q,\n\t\t\t   struct b43_pio_txpacket *pack)\n{\n\tu16 cookie;\n\n\t \n\tcookie = (((u16)q->index + 1) << 12);\n\tcookie |= pack->index;\n\n\treturn cookie;\n}\n\nstatic\nstruct b43_pio_txqueue *parse_cookie(struct b43_wldev *dev,\n\t\t\t\t     u16 cookie,\n\t\t\t\t      struct b43_pio_txpacket **pack)\n{\n\tstruct b43_pio *pio = &dev->pio;\n\tstruct b43_pio_txqueue *q = NULL;\n\tunsigned int pack_index;\n\n\tswitch (cookie & 0xF000) {\n\tcase 0x1000:\n\t\tq = pio->tx_queue_AC_BK;\n\t\tbreak;\n\tcase 0x2000:\n\t\tq = pio->tx_queue_AC_BE;\n\t\tbreak;\n\tcase 0x3000:\n\t\tq = pio->tx_queue_AC_VI;\n\t\tbreak;\n\tcase 0x4000:\n\t\tq = pio->tx_queue_AC_VO;\n\t\tbreak;\n\tcase 0x5000:\n\t\tq = pio->tx_queue_mcast;\n\t\tbreak;\n\t}\n\tif (B43_WARN_ON(!q))\n\t\treturn NULL;\n\tpack_index = (cookie & 0x0FFF);\n\tif (B43_WARN_ON(pack_index >= ARRAY_SIZE(q->packets)))\n\t\treturn NULL;\n\t*pack = &q->packets[pack_index];\n\n\treturn q;\n}\n\nstatic u16 index_to_pioqueue_base(struct b43_wldev *dev,\n\t\t\t\t  unsigned int index)\n{\n\tstatic const u16 bases[] = {\n\t\tB43_MMIO_PIO_BASE0,\n\t\tB43_MMIO_PIO_BASE1,\n\t\tB43_MMIO_PIO_BASE2,\n\t\tB43_MMIO_PIO_BASE3,\n\t\tB43_MMIO_PIO_BASE4,\n\t\tB43_MMIO_PIO_BASE5,\n\t\tB43_MMIO_PIO_BASE6,\n\t\tB43_MMIO_PIO_BASE7,\n\t};\n\tstatic const u16 bases_rev11[] = {\n\t\tB43_MMIO_PIO11_BASE0,\n\t\tB43_MMIO_PIO11_BASE1,\n\t\tB43_MMIO_PIO11_BASE2,\n\t\tB43_MMIO_PIO11_BASE3,\n\t\tB43_MMIO_PIO11_BASE4,\n\t\tB43_MMIO_PIO11_BASE5,\n\t};\n\n\tif (dev->dev->core_rev >= 11) {\n\t\tB43_WARN_ON(index >= ARRAY_SIZE(bases_rev11));\n\t\treturn bases_rev11[index];\n\t}\n\tB43_WARN_ON(index >= ARRAY_SIZE(bases));\n\treturn bases[index];\n}\n\nstatic u16 pio_txqueue_offset(struct b43_wldev *dev)\n{\n\tif (dev->dev->core_rev >= 11)\n\t\treturn 0x18;\n\treturn 0;\n}\n\nstatic u16 pio_rxqueue_offset(struct b43_wldev *dev)\n{\n\tif (dev->dev->core_rev >= 11)\n\t\treturn 0x38;\n\treturn 8;\n}\n\nstatic struct b43_pio_txqueue *b43_setup_pioqueue_tx(struct b43_wldev *dev,\n\t\t\t\t\t\t     unsigned int index)\n{\n\tstruct b43_pio_txqueue *q;\n\tstruct b43_pio_txpacket *p;\n\tunsigned int i;\n\n\tq = kzalloc(sizeof(*q), GFP_KERNEL);\n\tif (!q)\n\t\treturn NULL;\n\tq->dev = dev;\n\tq->rev = dev->dev->core_rev;\n\tq->mmio_base = index_to_pioqueue_base(dev, index) +\n\t\t       pio_txqueue_offset(dev);\n\tq->index = index;\n\n\tq->free_packet_slots = B43_PIO_MAX_NR_TXPACKETS;\n\tif (q->rev >= 8) {\n\t\tq->buffer_size = 1920; \n\t} else {\n\t\tq->buffer_size = b43_piotx_read16(q, B43_PIO_TXQBUFSIZE);\n\t\tq->buffer_size -= 80;\n\t}\n\n\tINIT_LIST_HEAD(&q->packets_list);\n\tfor (i = 0; i < ARRAY_SIZE(q->packets); i++) {\n\t\tp = &(q->packets[i]);\n\t\tINIT_LIST_HEAD(&p->list);\n\t\tp->index = i;\n\t\tp->queue = q;\n\t\tlist_add(&p->list, &q->packets_list);\n\t}\n\n\treturn q;\n}\n\nstatic struct b43_pio_rxqueue *b43_setup_pioqueue_rx(struct b43_wldev *dev,\n\t\t\t\t\t\t     unsigned int index)\n{\n\tstruct b43_pio_rxqueue *q;\n\n\tq = kzalloc(sizeof(*q), GFP_KERNEL);\n\tif (!q)\n\t\treturn NULL;\n\tq->dev = dev;\n\tq->rev = dev->dev->core_rev;\n\tq->mmio_base = index_to_pioqueue_base(dev, index) +\n\t\t       pio_rxqueue_offset(dev);\n\n\t \n\tb43_dma_direct_fifo_rx(dev, index, 1);\n\n\treturn q;\n}\n\nstatic void b43_pio_cancel_tx_packets(struct b43_pio_txqueue *q)\n{\n\tstruct b43_pio_txpacket *pack;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(q->packets); i++) {\n\t\tpack = &(q->packets[i]);\n\t\tif (pack->skb) {\n\t\t\tieee80211_free_txskb(q->dev->wl->hw, pack->skb);\n\t\t\tpack->skb = NULL;\n\t\t}\n\t}\n}\n\nstatic void b43_destroy_pioqueue_tx(struct b43_pio_txqueue *q,\n\t\t\t\t    const char *name)\n{\n\tif (!q)\n\t\treturn;\n\tb43_pio_cancel_tx_packets(q);\n\tkfree(q);\n}\n\nstatic void b43_destroy_pioqueue_rx(struct b43_pio_rxqueue *q,\n\t\t\t\t    const char *name)\n{\n\tif (!q)\n\t\treturn;\n\tkfree(q);\n}\n\n#define destroy_queue_tx(pio, queue) do {\t\t\t\t\\\n\tb43_destroy_pioqueue_tx((pio)->queue, __stringify(queue));\t\\\n\t(pio)->queue = NULL;\t\t\t\t\t\t\\\n  } while (0)\n\n#define destroy_queue_rx(pio, queue) do {\t\t\t\t\\\n\tb43_destroy_pioqueue_rx((pio)->queue, __stringify(queue));\t\\\n\t(pio)->queue = NULL;\t\t\t\t\t\t\\\n  } while (0)\n\nvoid b43_pio_free(struct b43_wldev *dev)\n{\n\tstruct b43_pio *pio;\n\n\tif (!b43_using_pio_transfers(dev))\n\t\treturn;\n\tpio = &dev->pio;\n\n\tdestroy_queue_rx(pio, rx_queue);\n\tdestroy_queue_tx(pio, tx_queue_mcast);\n\tdestroy_queue_tx(pio, tx_queue_AC_VO);\n\tdestroy_queue_tx(pio, tx_queue_AC_VI);\n\tdestroy_queue_tx(pio, tx_queue_AC_BE);\n\tdestroy_queue_tx(pio, tx_queue_AC_BK);\n}\n\nint b43_pio_init(struct b43_wldev *dev)\n{\n\tstruct b43_pio *pio = &dev->pio;\n\tint err = -ENOMEM;\n\n\tb43_write32(dev, B43_MMIO_MACCTL, b43_read32(dev, B43_MMIO_MACCTL)\n\t\t    & ~B43_MACCTL_BE);\n\tb43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_RXPADOFF, 0);\n\n\tpio->tx_queue_AC_BK = b43_setup_pioqueue_tx(dev, 0);\n\tif (!pio->tx_queue_AC_BK)\n\t\tgoto out;\n\n\tpio->tx_queue_AC_BE = b43_setup_pioqueue_tx(dev, 1);\n\tif (!pio->tx_queue_AC_BE)\n\t\tgoto err_destroy_bk;\n\n\tpio->tx_queue_AC_VI = b43_setup_pioqueue_tx(dev, 2);\n\tif (!pio->tx_queue_AC_VI)\n\t\tgoto err_destroy_be;\n\n\tpio->tx_queue_AC_VO = b43_setup_pioqueue_tx(dev, 3);\n\tif (!pio->tx_queue_AC_VO)\n\t\tgoto err_destroy_vi;\n\n\tpio->tx_queue_mcast = b43_setup_pioqueue_tx(dev, 4);\n\tif (!pio->tx_queue_mcast)\n\t\tgoto err_destroy_vo;\n\n\tpio->rx_queue = b43_setup_pioqueue_rx(dev, 0);\n\tif (!pio->rx_queue)\n\t\tgoto err_destroy_mcast;\n\n\tb43dbg(dev->wl, \"PIO initialized\\n\");\n\terr = 0;\nout:\n\treturn err;\n\nerr_destroy_mcast:\n\tdestroy_queue_tx(pio, tx_queue_mcast);\nerr_destroy_vo:\n\tdestroy_queue_tx(pio, tx_queue_AC_VO);\nerr_destroy_vi:\n\tdestroy_queue_tx(pio, tx_queue_AC_VI);\nerr_destroy_be:\n\tdestroy_queue_tx(pio, tx_queue_AC_BE);\nerr_destroy_bk:\n\tdestroy_queue_tx(pio, tx_queue_AC_BK);\n\treturn err;\n}\n\n \nstatic struct b43_pio_txqueue *select_queue_by_priority(struct b43_wldev *dev,\n\t\t\t\t\t\t\tu8 queue_prio)\n{\n\tstruct b43_pio_txqueue *q;\n\n\tif (dev->qos_enabled) {\n\t\t \n\t\tswitch (queue_prio) {\n\t\tdefault:\n\t\t\tB43_WARN_ON(1);\n\t\t\tfallthrough;\n\t\tcase 0:\n\t\t\tq = dev->pio.tx_queue_AC_VO;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tq = dev->pio.tx_queue_AC_VI;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tq = dev->pio.tx_queue_AC_BE;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tq = dev->pio.tx_queue_AC_BK;\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tq = dev->pio.tx_queue_AC_BE;\n\n\treturn q;\n}\n\nstatic u16 tx_write_2byte_queue(struct b43_pio_txqueue *q,\n\t\t\t\tu16 ctl,\n\t\t\t\tconst void *_data,\n\t\t\t\tunsigned int data_len)\n{\n\tstruct b43_wldev *dev = q->dev;\n\tstruct b43_wl *wl = dev->wl;\n\tconst u8 *data = _data;\n\n\tctl |= B43_PIO_TXCTL_WRITELO | B43_PIO_TXCTL_WRITEHI;\n\tb43_piotx_write16(q, B43_PIO_TXCTL, ctl);\n\n\tb43_block_write(dev, data, (data_len & ~1),\n\t\t\tq->mmio_base + B43_PIO_TXDATA,\n\t\t\tsizeof(u16));\n\tif (data_len & 1) {\n\t\tu8 *tail = wl->pio_tailspace;\n\t\tBUILD_BUG_ON(sizeof(wl->pio_tailspace) < 2);\n\n\t\t \n\t\tctl &= ~B43_PIO_TXCTL_WRITEHI;\n\t\tb43_piotx_write16(q, B43_PIO_TXCTL, ctl);\n\t\ttail[0] = data[data_len - 1];\n\t\ttail[1] = 0;\n\t\tb43_block_write(dev, tail, 2,\n\t\t\t\tq->mmio_base + B43_PIO_TXDATA,\n\t\t\t\tsizeof(u16));\n\t}\n\n\treturn ctl;\n}\n\nstatic void pio_tx_frame_2byte_queue(struct b43_pio_txpacket *pack,\n\t\t\t\t     const u8 *hdr, unsigned int hdrlen)\n{\n\tstruct b43_pio_txqueue *q = pack->queue;\n\tconst char *frame = pack->skb->data;\n\tunsigned int frame_len = pack->skb->len;\n\tu16 ctl;\n\n\tctl = b43_piotx_read16(q, B43_PIO_TXCTL);\n\tctl |= B43_PIO_TXCTL_FREADY;\n\tctl &= ~B43_PIO_TXCTL_EOF;\n\n\t \n\tctl = tx_write_2byte_queue(q, ctl, hdr, hdrlen);\n\t \n\tctl = tx_write_2byte_queue(q, ctl, frame, frame_len);\n\n\tctl |= B43_PIO_TXCTL_EOF;\n\tb43_piotx_write16(q, B43_PIO_TXCTL, ctl);\n}\n\nstatic u32 tx_write_4byte_queue(struct b43_pio_txqueue *q,\n\t\t\t\tu32 ctl,\n\t\t\t\tconst void *_data,\n\t\t\t\tunsigned int data_len)\n{\n\tstruct b43_wldev *dev = q->dev;\n\tstruct b43_wl *wl = dev->wl;\n\tconst u8 *data = _data;\n\n\tctl |= B43_PIO8_TXCTL_0_7 | B43_PIO8_TXCTL_8_15 |\n\t       B43_PIO8_TXCTL_16_23 | B43_PIO8_TXCTL_24_31;\n\tb43_piotx_write32(q, B43_PIO8_TXCTL, ctl);\n\n\tb43_block_write(dev, data, (data_len & ~3),\n\t\t\tq->mmio_base + B43_PIO8_TXDATA,\n\t\t\tsizeof(u32));\n\tif (data_len & 3) {\n\t\tu8 *tail = wl->pio_tailspace;\n\t\tBUILD_BUG_ON(sizeof(wl->pio_tailspace) < 4);\n\n\t\tmemset(tail, 0, 4);\n\t\t \n\t\tctl &= ~(B43_PIO8_TXCTL_8_15 | B43_PIO8_TXCTL_16_23 |\n\t\t\t B43_PIO8_TXCTL_24_31);\n\t\tswitch (data_len & 3) {\n\t\tcase 3:\n\t\t\tctl |= B43_PIO8_TXCTL_16_23 | B43_PIO8_TXCTL_8_15;\n\t\t\ttail[0] = data[data_len - 3];\n\t\t\ttail[1] = data[data_len - 2];\n\t\t\ttail[2] = data[data_len - 1];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tctl |= B43_PIO8_TXCTL_8_15;\n\t\t\ttail[0] = data[data_len - 2];\n\t\t\ttail[1] = data[data_len - 1];\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ttail[0] = data[data_len - 1];\n\t\t\tbreak;\n\t\t}\n\t\tb43_piotx_write32(q, B43_PIO8_TXCTL, ctl);\n\t\tb43_block_write(dev, tail, 4,\n\t\t\t\tq->mmio_base + B43_PIO8_TXDATA,\n\t\t\t\tsizeof(u32));\n\t}\n\n\treturn ctl;\n}\n\nstatic void pio_tx_frame_4byte_queue(struct b43_pio_txpacket *pack,\n\t\t\t\t     const u8 *hdr, unsigned int hdrlen)\n{\n\tstruct b43_pio_txqueue *q = pack->queue;\n\tconst char *frame = pack->skb->data;\n\tunsigned int frame_len = pack->skb->len;\n\tu32 ctl;\n\n\tctl = b43_piotx_read32(q, B43_PIO8_TXCTL);\n\tctl |= B43_PIO8_TXCTL_FREADY;\n\tctl &= ~B43_PIO8_TXCTL_EOF;\n\n\t \n\tctl = tx_write_4byte_queue(q, ctl, hdr, hdrlen);\n\t \n\tctl = tx_write_4byte_queue(q, ctl, frame, frame_len);\n\n\tctl |= B43_PIO8_TXCTL_EOF;\n\tb43_piotx_write32(q, B43_PIO_TXCTL, ctl);\n}\n\nstatic int pio_tx_frame(struct b43_pio_txqueue *q,\n\t\t\tstruct sk_buff *skb)\n{\n\tstruct b43_wldev *dev = q->dev;\n\tstruct b43_wl *wl = dev->wl;\n\tstruct b43_pio_txpacket *pack;\n\tu16 cookie;\n\tint err;\n\tunsigned int hdrlen;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct b43_txhdr *txhdr = (struct b43_txhdr *)wl->pio_scratchspace;\n\n\tB43_WARN_ON(list_empty(&q->packets_list));\n\tpack = list_entry(q->packets_list.next,\n\t\t\t  struct b43_pio_txpacket, list);\n\n\tcookie = generate_cookie(q, pack);\n\thdrlen = b43_txhdr_size(dev);\n\tBUILD_BUG_ON(sizeof(wl->pio_scratchspace) < sizeof(struct b43_txhdr));\n\tB43_WARN_ON(sizeof(wl->pio_scratchspace) < hdrlen);\n\terr = b43_generate_txhdr(dev, (u8 *)txhdr, skb,\n\t\t\t\t info, cookie);\n\tif (err)\n\t\treturn err;\n\n\tif (info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM) {\n\t\t \n\t\tb43_shm_write16(dev, B43_SHM_SHARED,\n\t\t\t\tB43_SHM_SH_MCASTCOOKIE, cookie);\n\t}\n\n\tpack->skb = skb;\n\tif (q->rev >= 8)\n\t\tpio_tx_frame_4byte_queue(pack, (const u8 *)txhdr, hdrlen);\n\telse\n\t\tpio_tx_frame_2byte_queue(pack, (const u8 *)txhdr, hdrlen);\n\n\t \n\tlist_del(&pack->list);\n\n\t \n\tq->buffer_used += roundup(skb->len + hdrlen, 4);\n\tq->free_packet_slots -= 1;\n\n\treturn 0;\n}\n\nint b43_pio_tx(struct b43_wldev *dev, struct sk_buff *skb)\n{\n\tstruct b43_pio_txqueue *q;\n\tstruct ieee80211_hdr *hdr;\n\tunsigned int hdrlen, total_len;\n\tint err = 0;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\n\tif (info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM) {\n\t\t \n\t\tq = dev->pio.tx_queue_mcast;\n\t\t \n\t\thdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_MOREDATA);\n\t} else {\n\t\t \n\t\tq = select_queue_by_priority(dev, skb_get_queue_mapping(skb));\n\t}\n\n\thdrlen = b43_txhdr_size(dev);\n\ttotal_len = roundup(skb->len + hdrlen, 4);\n\n\tif (unlikely(total_len > q->buffer_size)) {\n\t\terr = -ENOBUFS;\n\t\tb43dbg(dev->wl, \"PIO: TX packet longer than queue.\\n\");\n\t\tgoto out;\n\t}\n\tif (unlikely(q->free_packet_slots == 0)) {\n\t\terr = -ENOBUFS;\n\t\tb43warn(dev->wl, \"PIO: TX packet overflow.\\n\");\n\t\tgoto out;\n\t}\n\tB43_WARN_ON(q->buffer_used > q->buffer_size);\n\n\tif (total_len > (q->buffer_size - q->buffer_used)) {\n\t\t \n\t\terr = -EBUSY;\n\t\tieee80211_stop_queue(dev->wl->hw, skb_get_queue_mapping(skb));\n\t\tq->stopped = true;\n\t\tgoto out;\n\t}\n\n\t \n\tq->queue_prio = skb_get_queue_mapping(skb);\n\n\terr = pio_tx_frame(q, skb);\n\tif (unlikely(err == -ENOKEY)) {\n\t\t \n\t\tieee80211_free_txskb(dev->wl->hw, skb);\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\tif (unlikely(err)) {\n\t\tb43err(dev->wl, \"PIO transmission failure\\n\");\n\t\tgoto out;\n\t}\n\n\tB43_WARN_ON(q->buffer_used > q->buffer_size);\n\tif (((q->buffer_size - q->buffer_used) < roundup(2 + 2 + 6, 4)) ||\n\t    (q->free_packet_slots == 0)) {\n\t\t \n\t\tieee80211_stop_queue(dev->wl->hw, skb_get_queue_mapping(skb));\n\t\tq->stopped = true;\n\t}\n\nout:\n\treturn err;\n}\n\nvoid b43_pio_handle_txstatus(struct b43_wldev *dev,\n\t\t\t     const struct b43_txstatus *status)\n{\n\tstruct b43_pio_txqueue *q;\n\tstruct b43_pio_txpacket *pack = NULL;\n\tunsigned int total_len;\n\tstruct ieee80211_tx_info *info;\n\n\tq = parse_cookie(dev, status->cookie, &pack);\n\tif (unlikely(!q))\n\t\treturn;\n\tB43_WARN_ON(!pack);\n\n\tinfo = IEEE80211_SKB_CB(pack->skb);\n\n\tb43_fill_txstatus_report(dev, info, status);\n\n\ttotal_len = pack->skb->len + b43_txhdr_size(dev);\n\ttotal_len = roundup(total_len, 4);\n\tq->buffer_used -= total_len;\n\tq->free_packet_slots += 1;\n\n\tieee80211_tx_status(dev->wl->hw, pack->skb);\n\tpack->skb = NULL;\n\tlist_add(&pack->list, &q->packets_list);\n\n\tif (q->stopped) {\n\t\tieee80211_wake_queue(dev->wl->hw, q->queue_prio);\n\t\tq->stopped = false;\n\t}\n}\n\n \nstatic bool pio_rx_frame(struct b43_pio_rxqueue *q)\n{\n\tstruct b43_wldev *dev = q->dev;\n\tstruct b43_wl *wl = dev->wl;\n\tu16 len;\n\tu32 macstat = 0;\n\tunsigned int i, padding;\n\tstruct sk_buff *skb;\n\tconst char *err_msg = NULL;\n\tstruct b43_rxhdr_fw4 *rxhdr =\n\t\t(struct b43_rxhdr_fw4 *)wl->pio_scratchspace;\n\tsize_t rxhdr_size = sizeof(*rxhdr);\n\n\tBUILD_BUG_ON(sizeof(wl->pio_scratchspace) < sizeof(*rxhdr));\n\tswitch (dev->fw.hdr_format) {\n\tcase B43_FW_HDR_410:\n\tcase B43_FW_HDR_351:\n\t\trxhdr_size -= sizeof(rxhdr->format_598) -\n\t\t\tsizeof(rxhdr->format_351);\n\t\tbreak;\n\tcase B43_FW_HDR_598:\n\t\tbreak;\n\t}\n\tmemset(rxhdr, 0, rxhdr_size);\n\n\t \n\tif (q->rev >= 8) {\n\t\tu32 ctl;\n\n\t\tctl = b43_piorx_read32(q, B43_PIO8_RXCTL);\n\t\tif (!(ctl & B43_PIO8_RXCTL_FRAMERDY))\n\t\t\treturn false;\n\t\tb43_piorx_write32(q, B43_PIO8_RXCTL,\n\t\t\t\t  B43_PIO8_RXCTL_FRAMERDY);\n\t\tfor (i = 0; i < 10; i++) {\n\t\t\tctl = b43_piorx_read32(q, B43_PIO8_RXCTL);\n\t\t\tif (ctl & B43_PIO8_RXCTL_DATARDY)\n\t\t\t\tgoto data_ready;\n\t\t\tudelay(10);\n\t\t}\n\t} else {\n\t\tu16 ctl;\n\n\t\tctl = b43_piorx_read16(q, B43_PIO_RXCTL);\n\t\tif (!(ctl & B43_PIO_RXCTL_FRAMERDY))\n\t\t\treturn false;\n\t\tb43_piorx_write16(q, B43_PIO_RXCTL,\n\t\t\t\t  B43_PIO_RXCTL_FRAMERDY);\n\t\tfor (i = 0; i < 10; i++) {\n\t\t\tctl = b43_piorx_read16(q, B43_PIO_RXCTL);\n\t\t\tif (ctl & B43_PIO_RXCTL_DATARDY)\n\t\t\t\tgoto data_ready;\n\t\t\tudelay(10);\n\t\t}\n\t}\n\tb43dbg(q->dev->wl, \"PIO RX timed out\\n\");\n\treturn true;\ndata_ready:\n\n\t \n\tif (q->rev >= 8) {\n\t\tb43_block_read(dev, rxhdr, rxhdr_size,\n\t\t\t       q->mmio_base + B43_PIO8_RXDATA,\n\t\t\t       sizeof(u32));\n\t} else {\n\t\tb43_block_read(dev, rxhdr, rxhdr_size,\n\t\t\t       q->mmio_base + B43_PIO_RXDATA,\n\t\t\t       sizeof(u16));\n\t}\n\t \n\tlen = le16_to_cpu(rxhdr->frame_len);\n\tif (unlikely(len > 0x700)) {\n\t\terr_msg = \"len > 0x700\";\n\t\tgoto rx_error;\n\t}\n\tif (unlikely(len == 0)) {\n\t\terr_msg = \"len == 0\";\n\t\tgoto rx_error;\n\t}\n\n\tswitch (dev->fw.hdr_format) {\n\tcase B43_FW_HDR_598:\n\t\tmacstat = le32_to_cpu(rxhdr->format_598.mac_status);\n\t\tbreak;\n\tcase B43_FW_HDR_410:\n\tcase B43_FW_HDR_351:\n\t\tmacstat = le32_to_cpu(rxhdr->format_351.mac_status);\n\t\tbreak;\n\t}\n\tif (macstat & B43_RX_MAC_FCSERR) {\n\t\tif (!(q->dev->wl->filter_flags & FIF_FCSFAIL)) {\n\t\t\t \n\t\t\terr_msg = \"Frame FCS error\";\n\t\t\tgoto rx_error;\n\t\t}\n\t}\n\n\t \n\tpadding = (macstat & B43_RX_MAC_PADDING) ? 2 : 0;\n\tskb = dev_alloc_skb(len + padding + 2);\n\tif (unlikely(!skb)) {\n\t\terr_msg = \"Out of memory\";\n\t\tgoto rx_error;\n\t}\n\tskb_reserve(skb, 2);\n\tskb_put(skb, len + padding);\n\tif (q->rev >= 8) {\n\t\tb43_block_read(dev, skb->data + padding, (len & ~3),\n\t\t\t       q->mmio_base + B43_PIO8_RXDATA,\n\t\t\t       sizeof(u32));\n\t\tif (len & 3) {\n\t\t\tu8 *tail = wl->pio_tailspace;\n\t\t\tBUILD_BUG_ON(sizeof(wl->pio_tailspace) < 4);\n\n\t\t\t \n\t\t\tb43_block_read(dev, tail, 4,\n\t\t\t\t       q->mmio_base + B43_PIO8_RXDATA,\n\t\t\t\t       sizeof(u32));\n\t\t\tswitch (len & 3) {\n\t\t\tcase 3:\n\t\t\t\tskb->data[len + padding - 3] = tail[0];\n\t\t\t\tskb->data[len + padding - 2] = tail[1];\n\t\t\t\tskb->data[len + padding - 1] = tail[2];\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tskb->data[len + padding - 2] = tail[0];\n\t\t\t\tskb->data[len + padding - 1] = tail[1];\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tskb->data[len + padding - 1] = tail[0];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tb43_block_read(dev, skb->data + padding, (len & ~1),\n\t\t\t       q->mmio_base + B43_PIO_RXDATA,\n\t\t\t       sizeof(u16));\n\t\tif (len & 1) {\n\t\t\tu8 *tail = wl->pio_tailspace;\n\t\t\tBUILD_BUG_ON(sizeof(wl->pio_tailspace) < 2);\n\n\t\t\t \n\t\t\tb43_block_read(dev, tail, 2,\n\t\t\t\t       q->mmio_base + B43_PIO_RXDATA,\n\t\t\t\t       sizeof(u16));\n\t\t\tskb->data[len + padding - 1] = tail[0];\n\t\t}\n\t}\n\n\tb43_rx(q->dev, skb, rxhdr);\n\n\treturn true;\n\nrx_error:\n\tif (err_msg)\n\t\tb43dbg(q->dev->wl, \"PIO RX error: %s\\n\", err_msg);\n\tif (q->rev >= 8)\n\t\tb43_piorx_write32(q, B43_PIO8_RXCTL, B43_PIO8_RXCTL_DATARDY);\n\telse\n\t\tb43_piorx_write16(q, B43_PIO_RXCTL, B43_PIO_RXCTL_DATARDY);\n\n\treturn true;\n}\n\nvoid b43_pio_rx(struct b43_pio_rxqueue *q)\n{\n\tunsigned int count = 0;\n\tbool stop;\n\n\twhile (1) {\n\t\tstop = !pio_rx_frame(q);\n\t\tif (stop)\n\t\t\tbreak;\n\t\tcond_resched();\n\t\tif (WARN_ON_ONCE(++count > 10000))\n\t\t\tbreak;\n\t}\n}\n\nstatic void b43_pio_tx_suspend_queue(struct b43_pio_txqueue *q)\n{\n\tif (q->rev >= 8) {\n\t\tb43_piotx_write32(q, B43_PIO8_TXCTL,\n\t\t\t\t  b43_piotx_read32(q, B43_PIO8_TXCTL)\n\t\t\t\t  | B43_PIO8_TXCTL_SUSPREQ);\n\t} else {\n\t\tb43_piotx_write16(q, B43_PIO_TXCTL,\n\t\t\t\t  b43_piotx_read16(q, B43_PIO_TXCTL)\n\t\t\t\t  | B43_PIO_TXCTL_SUSPREQ);\n\t}\n}\n\nstatic void b43_pio_tx_resume_queue(struct b43_pio_txqueue *q)\n{\n\tif (q->rev >= 8) {\n\t\tb43_piotx_write32(q, B43_PIO8_TXCTL,\n\t\t\t\t  b43_piotx_read32(q, B43_PIO8_TXCTL)\n\t\t\t\t  & ~B43_PIO8_TXCTL_SUSPREQ);\n\t} else {\n\t\tb43_piotx_write16(q, B43_PIO_TXCTL,\n\t\t\t\t  b43_piotx_read16(q, B43_PIO_TXCTL)\n\t\t\t\t  & ~B43_PIO_TXCTL_SUSPREQ);\n\t}\n}\n\nvoid b43_pio_tx_suspend(struct b43_wldev *dev)\n{\n\tb43_power_saving_ctl_bits(dev, B43_PS_AWAKE);\n\tb43_pio_tx_suspend_queue(dev->pio.tx_queue_AC_BK);\n\tb43_pio_tx_suspend_queue(dev->pio.tx_queue_AC_BE);\n\tb43_pio_tx_suspend_queue(dev->pio.tx_queue_AC_VI);\n\tb43_pio_tx_suspend_queue(dev->pio.tx_queue_AC_VO);\n\tb43_pio_tx_suspend_queue(dev->pio.tx_queue_mcast);\n}\n\nvoid b43_pio_tx_resume(struct b43_wldev *dev)\n{\n\tb43_pio_tx_resume_queue(dev->pio.tx_queue_mcast);\n\tb43_pio_tx_resume_queue(dev->pio.tx_queue_AC_VO);\n\tb43_pio_tx_resume_queue(dev->pio.tx_queue_AC_VI);\n\tb43_pio_tx_resume_queue(dev->pio.tx_queue_AC_BE);\n\tb43_pio_tx_resume_queue(dev->pio.tx_queue_AC_BK);\n\tb43_power_saving_ctl_bits(dev, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}