{
  "module_name": "sysfs.c",
  "hash_id": "7aacaa333a4d270602808838bae7230dbaf4b66ae9bfc02caffaef0541baad07",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/b43/sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/capability.h>\n#include <linux/io.h>\n\n#include \"b43.h\"\n#include \"sysfs.h\"\n#include \"main.h\"\n#include \"phy_common.h\"\n\n#define GENERIC_FILESIZE\t64\n\nstatic int get_integer(const char *buf, size_t count)\n{\n\tchar tmp[10 + 1] = { 0 };\n\tint ret = -EINVAL;\n\n\tif (count == 0)\n\t\tgoto out;\n\tcount = min_t(size_t, count, 10);\n\tmemcpy(tmp, buf, count);\n\tret = simple_strtol(tmp, NULL, 10);\n      out:\n\treturn ret;\n}\n\nstatic ssize_t b43_attr_interfmode_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct b43_wldev *wldev = dev_to_b43_wldev(dev);\n\tssize_t count = 0;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tmutex_lock(&wldev->wl->mutex);\n\n\tif (wldev->phy.type != B43_PHYTYPE_G) {\n\t\tmutex_unlock(&wldev->wl->mutex);\n\t\treturn -ENOSYS;\n\t}\n\n\tswitch (wldev->phy.g->interfmode) {\n\tcase B43_INTERFMODE_NONE:\n\t\tcount =\n\t\t    snprintf(buf, PAGE_SIZE,\n\t\t\t     \"0 (No Interference Mitigation)\\n\");\n\t\tbreak;\n\tcase B43_INTERFMODE_NONWLAN:\n\t\tcount =\n\t\t    snprintf(buf, PAGE_SIZE,\n\t\t\t     \"1 (Non-WLAN Interference Mitigation)\\n\");\n\t\tbreak;\n\tcase B43_INTERFMODE_MANUALWLAN:\n\t\tcount =\n\t\t    snprintf(buf, PAGE_SIZE,\n\t\t\t     \"2 (WLAN Interference Mitigation)\\n\");\n\t\tbreak;\n\tdefault:\n\t\tB43_WARN_ON(1);\n\t}\n\n\tmutex_unlock(&wldev->wl->mutex);\n\n\treturn count;\n}\n\nstatic ssize_t b43_attr_interfmode_store(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tstruct b43_wldev *wldev = dev_to_b43_wldev(dev);\n\tint err;\n\tint mode;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tmode = get_integer(buf, count);\n\tswitch (mode) {\n\tcase 0:\n\t\tmode = B43_INTERFMODE_NONE;\n\t\tbreak;\n\tcase 1:\n\t\tmode = B43_INTERFMODE_NONWLAN;\n\t\tbreak;\n\tcase 2:\n\t\tmode = B43_INTERFMODE_MANUALWLAN;\n\t\tbreak;\n\tcase 3:\n\t\tmode = B43_INTERFMODE_AUTOWLAN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&wldev->wl->mutex);\n\n\tif (wldev->phy.ops->interf_mitigation) {\n\t\terr = wldev->phy.ops->interf_mitigation(wldev, mode);\n\t\tif (err) {\n\t\t\tb43err(wldev->wl, \"Interference Mitigation not \"\n\t\t\t       \"supported by device\\n\");\n\t\t}\n\t} else\n\t\terr = -ENOSYS;\n\n\tmutex_unlock(&wldev->wl->mutex);\n\n\treturn err ? err : count;\n}\n\nstatic DEVICE_ATTR(interference, 0644,\n\t\t   b43_attr_interfmode_show, b43_attr_interfmode_store);\n\nint b43_sysfs_register(struct b43_wldev *wldev)\n{\n\tstruct device *dev = wldev->dev->dev;\n\n\tB43_WARN_ON(b43_status(wldev) != B43_STAT_INITIALIZED);\n\n\treturn device_create_file(dev, &dev_attr_interference);\n}\n\nvoid b43_sysfs_unregister(struct b43_wldev *wldev)\n{\n\tstruct device *dev = wldev->dev->dev;\n\n\tdevice_remove_file(dev, &dev_attr_interference);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}