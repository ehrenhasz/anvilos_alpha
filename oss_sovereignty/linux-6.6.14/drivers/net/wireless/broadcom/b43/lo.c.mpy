{
  "module_name": "lo.c",
  "hash_id": "d88bac10bdf03bc707f26250de7e3bb1885b261bbf5065e06d8cd996552c64fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/b43/lo.c",
  "human_readable_source": "\n \n\n#include \"b43.h\"\n#include \"lo.h\"\n#include \"phy_g.h\"\n#include \"main.h\"\n\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n\nstatic struct b43_lo_calib *b43_find_lo_calib(struct b43_txpower_lo_control *lo,\n\t\t\t\t\t      const struct b43_bbatt *bbatt,\n\t\t\t\t\t       const struct b43_rfatt *rfatt)\n{\n\tstruct b43_lo_calib *c;\n\n\tlist_for_each_entry(c, &lo->calib_list, list) {\n\t\tif (!b43_compare_bbatt(&c->bbatt, bbatt))\n\t\t\tcontinue;\n\t\tif (!b43_compare_rfatt(&c->rfatt, rfatt))\n\t\t\tcontinue;\n\t\treturn c;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic void b43_lo_write(struct b43_wldev *dev, struct b43_loctl *control)\n{\n\tstruct b43_phy *phy = &dev->phy;\n\tu16 value;\n\n\tif (B43_DEBUG) {\n\t\tif (unlikely(abs(control->i) > 16 || abs(control->q) > 16)) {\n\t\t\tb43dbg(dev->wl, \"Invalid LO control pair \"\n\t\t\t       \"(I: %d, Q: %d)\\n\", control->i, control->q);\n\t\t\tdump_stack();\n\t\t\treturn;\n\t\t}\n\t}\n\tB43_WARN_ON(phy->type != B43_PHYTYPE_G);\n\n\tvalue = (u8) (control->q);\n\tvalue |= ((u8) (control->i)) << 8;\n\tb43_phy_write(dev, B43_PHY_LO_CTL, value);\n}\n\nstatic u16 lo_measure_feedthrough(struct b43_wldev *dev,\n\t\t\t\t  u16 lna, u16 pga, u16 trsw_rx)\n{\n\tstruct b43_phy *phy = &dev->phy;\n\tu16 rfover;\n\tu16 feedthrough;\n\n\tif (phy->gmode) {\n\t\tlna <<= B43_PHY_RFOVERVAL_LNA_SHIFT;\n\t\tpga <<= B43_PHY_RFOVERVAL_PGA_SHIFT;\n\n\t\tB43_WARN_ON(lna & ~B43_PHY_RFOVERVAL_LNA);\n\t\tB43_WARN_ON(pga & ~B43_PHY_RFOVERVAL_PGA);\n \n\t\ttrsw_rx &= (B43_PHY_RFOVERVAL_TRSWRX | B43_PHY_RFOVERVAL_BW);\n\n\t\t \n\t\trfover = B43_PHY_RFOVERVAL_UNK;\n\t\trfover |= pga;\n\t\trfover |= lna;\n\t\trfover |= trsw_rx;\n\t\tif ((dev->dev->bus_sprom->boardflags_lo & B43_BFL_EXTLNA)\n\t\t    && phy->rev > 6)\n\t\t\trfover |= B43_PHY_RFOVERVAL_EXTLNA;\n\n\t\tb43_phy_write(dev, B43_PHY_PGACTL, 0xE300);\n\t\tb43_phy_write(dev, B43_PHY_RFOVERVAL, rfover);\n\t\tudelay(10);\n\t\trfover |= B43_PHY_RFOVERVAL_BW_LBW;\n\t\tb43_phy_write(dev, B43_PHY_RFOVERVAL, rfover);\n\t\tudelay(10);\n\t\trfover |= B43_PHY_RFOVERVAL_BW_LPF;\n\t\tb43_phy_write(dev, B43_PHY_RFOVERVAL, rfover);\n\t\tudelay(10);\n\t\tb43_phy_write(dev, B43_PHY_PGACTL, 0xF300);\n\t} else {\n\t\tpga |= B43_PHY_PGACTL_UNKNOWN;\n\t\tb43_phy_write(dev, B43_PHY_PGACTL, pga);\n\t\tudelay(10);\n\t\tpga |= B43_PHY_PGACTL_LOWBANDW;\n\t\tb43_phy_write(dev, B43_PHY_PGACTL, pga);\n\t\tudelay(10);\n\t\tpga |= B43_PHY_PGACTL_LPF;\n\t\tb43_phy_write(dev, B43_PHY_PGACTL, pga);\n\t}\n\tudelay(21);\n\tfeedthrough = b43_phy_read(dev, B43_PHY_LO_LEAKAGE);\n\n\t \n\tcond_resched();\n\n\treturn feedthrough;\n}\n\n \nstatic u16 lo_txctl_register_table(struct b43_wldev *dev,\n\t\t\t\t   u16 *value, u16 *pad_mix_gain)\n{\n\tstruct b43_phy *phy = &dev->phy;\n\tu16 reg, v, padmix;\n\n\tif (phy->type == B43_PHYTYPE_B) {\n\t\tv = 0x30;\n\t\tif (phy->radio_rev <= 5) {\n\t\t\treg = 0x43;\n\t\t\tpadmix = 0;\n\t\t} else {\n\t\t\treg = 0x52;\n\t\t\tpadmix = 5;\n\t\t}\n\t} else {\n\t\tif (phy->rev >= 2 && phy->radio_rev == 8) {\n\t\t\treg = 0x43;\n\t\t\tv = 0x10;\n\t\t\tpadmix = 2;\n\t\t} else {\n\t\t\treg = 0x52;\n\t\t\tv = 0x30;\n\t\t\tpadmix = 5;\n\t\t}\n\t}\n\tif (value)\n\t\t*value = v;\n\tif (pad_mix_gain)\n\t\t*pad_mix_gain = padmix;\n\n\treturn reg;\n}\n\nstatic void lo_measure_txctl_values(struct b43_wldev *dev)\n{\n\tstruct b43_phy *phy = &dev->phy;\n\tstruct b43_phy_g *gphy = phy->g;\n\tstruct b43_txpower_lo_control *lo = gphy->lo_control;\n\tu16 reg, mask;\n\tu16 trsw_rx, pga;\n\tu16 radio_pctl_reg;\n\n\tstatic const u8 tx_bias_values[] = {\n\t\t0x09, 0x08, 0x0A, 0x01, 0x00,\n\t\t0x02, 0x05, 0x04, 0x06,\n\t};\n\tstatic const u8 tx_magn_values[] = {\n\t\t0x70, 0x40,\n\t};\n\n\tif (!has_loopback_gain(phy)) {\n\t\tradio_pctl_reg = 6;\n\t\ttrsw_rx = 2;\n\t\tpga = 0;\n\t} else {\n\t\tint lb_gain;\t \n\n\t\ttrsw_rx = 0;\n\t\tlb_gain = gphy->max_lb_gain / 2;\n\t\tif (lb_gain > 10) {\n\t\t\tradio_pctl_reg = 0;\n\t\t\tpga = abs(10 - lb_gain) / 6;\n\t\t\tpga = clamp_val(pga, 0, 15);\n\t\t} else {\n\t\t\tint cmp_val;\n\t\t\tint tmp;\n\n\t\t\tpga = 0;\n\t\t\tcmp_val = 0x24;\n\t\t\tif ((phy->rev >= 2) &&\n\t\t\t    (phy->radio_ver == 0x2050) && (phy->radio_rev == 8))\n\t\t\t\tcmp_val = 0x3C;\n\t\t\ttmp = lb_gain;\n\t\t\tif ((10 - lb_gain) < cmp_val)\n\t\t\t\ttmp = (10 - lb_gain);\n\t\t\tif (tmp < 0)\n\t\t\t\ttmp += 6;\n\t\t\telse\n\t\t\t\ttmp += 3;\n\t\t\tcmp_val /= 4;\n\t\t\ttmp /= 4;\n\t\t\tif (tmp >= cmp_val)\n\t\t\t\tradio_pctl_reg = cmp_val;\n\t\t\telse\n\t\t\t\tradio_pctl_reg = tmp;\n\t\t}\n\t}\n\tb43_radio_maskset(dev, 0x43, 0xFFF0, radio_pctl_reg);\n\tb43_gphy_set_baseband_attenuation(dev, 2);\n\n\treg = lo_txctl_register_table(dev, &mask, NULL);\n\tmask = ~mask;\n\tb43_radio_mask(dev, reg, mask);\n\n\tif (has_tx_magnification(phy)) {\n\t\tint i, j;\n\t\tint feedthrough;\n\t\tint min_feedth = 0xFFFF;\n\t\tu8 tx_magn, tx_bias;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(tx_magn_values); i++) {\n\t\t\ttx_magn = tx_magn_values[i];\n\t\t\tb43_radio_maskset(dev, 0x52, 0xFF0F, tx_magn);\n\t\t\tfor (j = 0; j < ARRAY_SIZE(tx_bias_values); j++) {\n\t\t\t\ttx_bias = tx_bias_values[j];\n\t\t\t\tb43_radio_maskset(dev, 0x52, 0xFFF0, tx_bias);\n\t\t\t\tfeedthrough =\n\t\t\t\t    lo_measure_feedthrough(dev, 0, pga,\n\t\t\t\t\t\t\t   trsw_rx);\n\t\t\t\tif (feedthrough < min_feedth) {\n\t\t\t\t\tlo->tx_bias = tx_bias;\n\t\t\t\t\tlo->tx_magn = tx_magn;\n\t\t\t\t\tmin_feedth = feedthrough;\n\t\t\t\t}\n\t\t\t\tif (lo->tx_bias == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tb43_radio_write16(dev, 0x52,\n\t\t\t\t\t  (b43_radio_read16(dev, 0x52)\n\t\t\t\t\t   & 0xFF00) | lo->tx_bias | lo->\n\t\t\t\t\t  tx_magn);\n\t\t}\n\t} else {\n\t\tlo->tx_magn = 0;\n\t\tlo->tx_bias = 0;\n\t\tb43_radio_mask(dev, 0x52, 0xFFF0);\t \n\t}\n\tlo->txctl_measured_time = jiffies;\n}\n\nstatic void lo_read_power_vector(struct b43_wldev *dev)\n{\n\tstruct b43_phy *phy = &dev->phy;\n\tstruct b43_phy_g *gphy = phy->g;\n\tstruct b43_txpower_lo_control *lo = gphy->lo_control;\n\tint i;\n\tu64 tmp;\n\tu64 power_vector = 0;\n\n\tfor (i = 0; i < 8; i += 2) {\n\t\ttmp = b43_shm_read16(dev, B43_SHM_SHARED, 0x310 + i);\n\t\tpower_vector |= (tmp << (i * 8));\n\t\t \n\t\tb43_shm_write16(dev, B43_SHM_SHARED, 0x310 + i, 0);\n\t}\n\tif (power_vector)\n\t\tlo->power_vector = power_vector;\n\tlo->pwr_vec_read_time = jiffies;\n}\n\n \nstatic void lo_measure_gain_values(struct b43_wldev *dev,\n\t\t\t\t   s16 max_rx_gain, int use_trsw_rx)\n{\n\tstruct b43_phy *phy = &dev->phy;\n\tstruct b43_phy_g *gphy = phy->g;\n\tu16 tmp;\n\n\tif (max_rx_gain < 0)\n\t\tmax_rx_gain = 0;\n\n\tif (has_loopback_gain(phy)) {\n\t\tint trsw_rx_gain;\n\n\t\tif (use_trsw_rx) {\n\t\t\ttrsw_rx_gain = gphy->trsw_rx_gain / 2;\n\t\t\tif (max_rx_gain >= trsw_rx_gain) {\n\t\t\t\ttrsw_rx_gain = max_rx_gain - trsw_rx_gain;\n\t\t\t}\n\t\t} else\n\t\t\ttrsw_rx_gain = max_rx_gain;\n\t\tif (trsw_rx_gain < 9) {\n\t\t\tgphy->lna_lod_gain = 0;\n\t\t} else {\n\t\t\tgphy->lna_lod_gain = 1;\n\t\t\ttrsw_rx_gain -= 8;\n\t\t}\n\t\ttrsw_rx_gain = clamp_val(trsw_rx_gain, 0, 0x2D);\n\t\tgphy->pga_gain = trsw_rx_gain / 3;\n\t\tif (gphy->pga_gain >= 5) {\n\t\t\tgphy->pga_gain -= 5;\n\t\t\tgphy->lna_gain = 2;\n\t\t} else\n\t\t\tgphy->lna_gain = 0;\n\t} else {\n\t\tgphy->lna_gain = 0;\n\t\tgphy->trsw_rx_gain = 0x20;\n\t\tif (max_rx_gain >= 0x14) {\n\t\t\tgphy->lna_lod_gain = 1;\n\t\t\tgphy->pga_gain = 2;\n\t\t} else if (max_rx_gain >= 0x12) {\n\t\t\tgphy->lna_lod_gain = 1;\n\t\t\tgphy->pga_gain = 1;\n\t\t} else if (max_rx_gain >= 0xF) {\n\t\t\tgphy->lna_lod_gain = 1;\n\t\t\tgphy->pga_gain = 0;\n\t\t} else {\n\t\t\tgphy->lna_lod_gain = 0;\n\t\t\tgphy->pga_gain = 0;\n\t\t}\n\t}\n\n\ttmp = b43_radio_read16(dev, 0x7A);\n\tif (gphy->lna_lod_gain == 0)\n\t\ttmp &= ~0x0008;\n\telse\n\t\ttmp |= 0x0008;\n\tb43_radio_write16(dev, 0x7A, tmp);\n}\n\nstruct lo_g_saved_values {\n\tu8 old_channel;\n\n\t \n\tu16 reg_3F4;\n\tu16 reg_3E2;\n\n\t \n\tu16 phy_lo_mask;\n\tu16 phy_extg_01;\n\tu16 phy_dacctl_hwpctl;\n\tu16 phy_dacctl;\n\tu16 phy_cck_14;\n\tu16 phy_hpwr_tssictl;\n\tu16 phy_analogover;\n\tu16 phy_analogoverval;\n\tu16 phy_rfover;\n\tu16 phy_rfoverval;\n\tu16 phy_classctl;\n\tu16 phy_cck_3E;\n\tu16 phy_crs0;\n\tu16 phy_pgactl;\n\tu16 phy_cck_2A;\n\tu16 phy_syncctl;\n\tu16 phy_cck_30;\n\tu16 phy_cck_06;\n\n\t \n\tu16 radio_43;\n\tu16 radio_7A;\n\tu16 radio_52;\n};\n\nstatic void lo_measure_setup(struct b43_wldev *dev,\n\t\t\t     struct lo_g_saved_values *sav)\n{\n\tstruct ssb_sprom *sprom = dev->dev->bus_sprom;\n\tstruct b43_phy *phy = &dev->phy;\n\tstruct b43_phy_g *gphy = phy->g;\n\tstruct b43_txpower_lo_control *lo = gphy->lo_control;\n\tu16 tmp;\n\n\tif (b43_has_hardware_pctl(dev)) {\n\t\tsav->phy_lo_mask = b43_phy_read(dev, B43_PHY_LO_MASK);\n\t\tsav->phy_extg_01 = b43_phy_read(dev, B43_PHY_EXTG(0x01));\n\t\tsav->phy_dacctl_hwpctl = b43_phy_read(dev, B43_PHY_DACCTL);\n\t\tsav->phy_cck_14 = b43_phy_read(dev, B43_PHY_CCK(0x14));\n\t\tsav->phy_hpwr_tssictl = b43_phy_read(dev, B43_PHY_HPWR_TSSICTL);\n\n\t\tb43_phy_set(dev, B43_PHY_HPWR_TSSICTL, 0x100);\n\t\tb43_phy_set(dev, B43_PHY_EXTG(0x01), 0x40);\n\t\tb43_phy_set(dev, B43_PHY_DACCTL, 0x40);\n\t\tb43_phy_set(dev, B43_PHY_CCK(0x14), 0x200);\n\t}\n\tif (phy->type == B43_PHYTYPE_B &&\n\t    phy->radio_ver == 0x2050 && phy->radio_rev < 6) {\n\t\tb43_phy_write(dev, B43_PHY_CCK(0x16), 0x410);\n\t\tb43_phy_write(dev, B43_PHY_CCK(0x17), 0x820);\n\t}\n\tif (phy->rev >= 2) {\n\t\tsav->phy_analogover = b43_phy_read(dev, B43_PHY_ANALOGOVER);\n\t\tsav->phy_analogoverval =\n\t\t    b43_phy_read(dev, B43_PHY_ANALOGOVERVAL);\n\t\tsav->phy_rfover = b43_phy_read(dev, B43_PHY_RFOVER);\n\t\tsav->phy_rfoverval = b43_phy_read(dev, B43_PHY_RFOVERVAL);\n\t\tsav->phy_classctl = b43_phy_read(dev, B43_PHY_CLASSCTL);\n\t\tsav->phy_cck_3E = b43_phy_read(dev, B43_PHY_CCK(0x3E));\n\t\tsav->phy_crs0 = b43_phy_read(dev, B43_PHY_CRS0);\n\n\t\tb43_phy_mask(dev, B43_PHY_CLASSCTL, 0xFFFC);\n\t\tb43_phy_mask(dev, B43_PHY_CRS0, 0x7FFF);\n\t\tb43_phy_set(dev, B43_PHY_ANALOGOVER, 0x0003);\n\t\tb43_phy_mask(dev, B43_PHY_ANALOGOVERVAL, 0xFFFC);\n\t\tif (phy->type == B43_PHYTYPE_G) {\n\t\t\tif ((phy->rev >= 7) &&\n\t\t\t    (sprom->boardflags_lo & B43_BFL_EXTLNA)) {\n\t\t\t\tb43_phy_write(dev, B43_PHY_RFOVER, 0x933);\n\t\t\t} else {\n\t\t\t\tb43_phy_write(dev, B43_PHY_RFOVER, 0x133);\n\t\t\t}\n\t\t} else {\n\t\t\tb43_phy_write(dev, B43_PHY_RFOVER, 0);\n\t\t}\n\t\tb43_phy_write(dev, B43_PHY_CCK(0x3E), 0);\n\t}\n\tsav->reg_3F4 = b43_read16(dev, 0x3F4);\n\tsav->reg_3E2 = b43_read16(dev, 0x3E2);\n\tsav->radio_43 = b43_radio_read16(dev, 0x43);\n\tsav->radio_7A = b43_radio_read16(dev, 0x7A);\n\tsav->phy_pgactl = b43_phy_read(dev, B43_PHY_PGACTL);\n\tsav->phy_cck_2A = b43_phy_read(dev, B43_PHY_CCK(0x2A));\n\tsav->phy_syncctl = b43_phy_read(dev, B43_PHY_SYNCCTL);\n\tsav->phy_dacctl = b43_phy_read(dev, B43_PHY_DACCTL);\n\n\tif (!has_tx_magnification(phy)) {\n\t\tsav->radio_52 = b43_radio_read16(dev, 0x52);\n\t\tsav->radio_52 &= 0x00F0;\n\t}\n\tif (phy->type == B43_PHYTYPE_B) {\n\t\tsav->phy_cck_30 = b43_phy_read(dev, B43_PHY_CCK(0x30));\n\t\tsav->phy_cck_06 = b43_phy_read(dev, B43_PHY_CCK(0x06));\n\t\tb43_phy_write(dev, B43_PHY_CCK(0x30), 0x00FF);\n\t\tb43_phy_write(dev, B43_PHY_CCK(0x06), 0x3F3F);\n\t} else {\n\t\tb43_write16(dev, 0x3E2, b43_read16(dev, 0x3E2)\n\t\t\t    | 0x8000);\n\t}\n\tb43_write16(dev, 0x3F4, b43_read16(dev, 0x3F4)\n\t\t    & 0xF000);\n\n\ttmp =\n\t    (phy->type == B43_PHYTYPE_G) ? B43_PHY_LO_MASK : B43_PHY_CCK(0x2E);\n\tb43_phy_write(dev, tmp, 0x007F);\n\n\ttmp = sav->phy_syncctl;\n\tb43_phy_write(dev, B43_PHY_SYNCCTL, tmp & 0xFF7F);\n\ttmp = sav->radio_7A;\n\tb43_radio_write16(dev, 0x007A, tmp & 0xFFF0);\n\n\tb43_phy_write(dev, B43_PHY_CCK(0x2A), 0x8A3);\n\tif (phy->type == B43_PHYTYPE_G ||\n\t    (phy->type == B43_PHYTYPE_B &&\n\t     phy->radio_ver == 0x2050 && phy->radio_rev >= 6)) {\n\t\tb43_phy_write(dev, B43_PHY_CCK(0x2B), 0x1003);\n\t} else\n\t\tb43_phy_write(dev, B43_PHY_CCK(0x2B), 0x0802);\n\tif (phy->rev >= 2)\n\t\tb43_dummy_transmission(dev, false, true);\n\tb43_gphy_channel_switch(dev, 6, 0);\n\tb43_radio_read16(dev, 0x51);\t \n\tif (phy->type == B43_PHYTYPE_G)\n\t\tb43_phy_write(dev, B43_PHY_CCK(0x2F), 0);\n\n\t \n\tif (time_before(lo->txctl_measured_time,\n\t\t\tjiffies - B43_LO_TXCTL_EXPIRE))\n\t\tlo_measure_txctl_values(dev);\n\n\tif (phy->type == B43_PHYTYPE_G && phy->rev >= 3) {\n\t\tb43_phy_write(dev, B43_PHY_LO_MASK, 0xC078);\n\t} else {\n\t\tif (phy->type == B43_PHYTYPE_B)\n\t\t\tb43_phy_write(dev, B43_PHY_CCK(0x2E), 0x8078);\n\t\telse\n\t\t\tb43_phy_write(dev, B43_PHY_LO_MASK, 0x8078);\n\t}\n}\n\nstatic void lo_measure_restore(struct b43_wldev *dev,\n\t\t\t       struct lo_g_saved_values *sav)\n{\n\tstruct b43_phy *phy = &dev->phy;\n\tstruct b43_phy_g *gphy = phy->g;\n\tu16 tmp;\n\n\tif (phy->rev >= 2) {\n\t\tb43_phy_write(dev, B43_PHY_PGACTL, 0xE300);\n\t\ttmp = (gphy->pga_gain << 8);\n\t\tb43_phy_write(dev, B43_PHY_RFOVERVAL, tmp | 0xA0);\n\t\tudelay(5);\n\t\tb43_phy_write(dev, B43_PHY_RFOVERVAL, tmp | 0xA2);\n\t\tudelay(2);\n\t\tb43_phy_write(dev, B43_PHY_RFOVERVAL, tmp | 0xA3);\n\t} else {\n\t\ttmp = (gphy->pga_gain | 0xEFA0);\n\t\tb43_phy_write(dev, B43_PHY_PGACTL, tmp);\n\t}\n\tif (phy->type == B43_PHYTYPE_G) {\n\t\tif (phy->rev >= 3)\n\t\t\tb43_phy_write(dev, B43_PHY_CCK(0x2E), 0xC078);\n\t\telse\n\t\t\tb43_phy_write(dev, B43_PHY_CCK(0x2E), 0x8078);\n\t\tif (phy->rev >= 2)\n\t\t\tb43_phy_write(dev, B43_PHY_CCK(0x2F), 0x0202);\n\t\telse\n\t\t\tb43_phy_write(dev, B43_PHY_CCK(0x2F), 0x0101);\n\t}\n\tb43_write16(dev, 0x3F4, sav->reg_3F4);\n\tb43_phy_write(dev, B43_PHY_PGACTL, sav->phy_pgactl);\n\tb43_phy_write(dev, B43_PHY_CCK(0x2A), sav->phy_cck_2A);\n\tb43_phy_write(dev, B43_PHY_SYNCCTL, sav->phy_syncctl);\n\tb43_phy_write(dev, B43_PHY_DACCTL, sav->phy_dacctl);\n\tb43_radio_write16(dev, 0x43, sav->radio_43);\n\tb43_radio_write16(dev, 0x7A, sav->radio_7A);\n\tif (!has_tx_magnification(phy)) {\n\t\ttmp = sav->radio_52;\n\t\tb43_radio_maskset(dev, 0x52, 0xFF0F, tmp);\n\t}\n\tb43_write16(dev, 0x3E2, sav->reg_3E2);\n\tif (phy->type == B43_PHYTYPE_B &&\n\t    phy->radio_ver == 0x2050 && phy->radio_rev <= 5) {\n\t\tb43_phy_write(dev, B43_PHY_CCK(0x30), sav->phy_cck_30);\n\t\tb43_phy_write(dev, B43_PHY_CCK(0x06), sav->phy_cck_06);\n\t}\n\tif (phy->rev >= 2) {\n\t\tb43_phy_write(dev, B43_PHY_ANALOGOVER, sav->phy_analogover);\n\t\tb43_phy_write(dev, B43_PHY_ANALOGOVERVAL,\n\t\t\t      sav->phy_analogoverval);\n\t\tb43_phy_write(dev, B43_PHY_CLASSCTL, sav->phy_classctl);\n\t\tb43_phy_write(dev, B43_PHY_RFOVER, sav->phy_rfover);\n\t\tb43_phy_write(dev, B43_PHY_RFOVERVAL, sav->phy_rfoverval);\n\t\tb43_phy_write(dev, B43_PHY_CCK(0x3E), sav->phy_cck_3E);\n\t\tb43_phy_write(dev, B43_PHY_CRS0, sav->phy_crs0);\n\t}\n\tif (b43_has_hardware_pctl(dev)) {\n\t\ttmp = (sav->phy_lo_mask & 0xBFFF);\n\t\tb43_phy_write(dev, B43_PHY_LO_MASK, tmp);\n\t\tb43_phy_write(dev, B43_PHY_EXTG(0x01), sav->phy_extg_01);\n\t\tb43_phy_write(dev, B43_PHY_DACCTL, sav->phy_dacctl_hwpctl);\n\t\tb43_phy_write(dev, B43_PHY_CCK(0x14), sav->phy_cck_14);\n\t\tb43_phy_write(dev, B43_PHY_HPWR_TSSICTL, sav->phy_hpwr_tssictl);\n\t}\n\tb43_gphy_channel_switch(dev, sav->old_channel, 1);\n}\n\nstruct b43_lo_g_statemachine {\n\tint current_state;\n\tint nr_measured;\n\tint state_val_multiplier;\n\tu16 lowest_feedth;\n\tstruct b43_loctl min_loctl;\n};\n\n \nstatic int lo_probe_possible_loctls(struct b43_wldev *dev,\n\t\t\t\t    struct b43_loctl *probe_loctl,\n\t\t\t\t    struct b43_lo_g_statemachine *d)\n{\n\tstruct b43_phy *phy = &dev->phy;\n\tstruct b43_phy_g *gphy = phy->g;\n\tstruct b43_loctl test_loctl;\n\tstruct b43_loctl orig_loctl;\n\tstruct b43_loctl prev_loctl = {\n\t\t.i = -100,\n\t\t.q = -100,\n\t};\n\tint i;\n\tint begin, end;\n\tint found_lower = 0;\n\tu16 feedth;\n\n\tstatic const struct b43_loctl modifiers[] = {\n\t\t{.i = 1,.q = 1,},\n\t\t{.i = 1,.q = 0,},\n\t\t{.i = 1,.q = -1,},\n\t\t{.i = 0,.q = -1,},\n\t\t{.i = -1,.q = -1,},\n\t\t{.i = -1,.q = 0,},\n\t\t{.i = -1,.q = 1,},\n\t\t{.i = 0,.q = 1,},\n\t};\n\n\tif (d->current_state == 0) {\n\t\tbegin = 1;\n\t\tend = 8;\n\t} else if (d->current_state % 2 == 0) {\n\t\tbegin = d->current_state - 1;\n\t\tend = d->current_state + 1;\n\t} else {\n\t\tbegin = d->current_state - 2;\n\t\tend = d->current_state + 2;\n\t}\n\tif (begin < 1)\n\t\tbegin += 8;\n\tif (end > 8)\n\t\tend -= 8;\n\n\tmemcpy(&orig_loctl, probe_loctl, sizeof(struct b43_loctl));\n\ti = begin;\n\td->current_state = i;\n\twhile (1) {\n\t\tB43_WARN_ON(!(i >= 1 && i <= 8));\n\t\tmemcpy(&test_loctl, &orig_loctl, sizeof(struct b43_loctl));\n\t\ttest_loctl.i += modifiers[i - 1].i * d->state_val_multiplier;\n\t\ttest_loctl.q += modifiers[i - 1].q * d->state_val_multiplier;\n\t\tif ((test_loctl.i != prev_loctl.i ||\n\t\t     test_loctl.q != prev_loctl.q) &&\n\t\t    (abs(test_loctl.i) <= 16 && abs(test_loctl.q) <= 16)) {\n\t\t\tb43_lo_write(dev, &test_loctl);\n\t\t\tfeedth = lo_measure_feedthrough(dev, gphy->lna_gain,\n\t\t\t\t\t\t\tgphy->pga_gain,\n\t\t\t\t\t\t\tgphy->trsw_rx_gain);\n\t\t\tif (feedth < d->lowest_feedth) {\n\t\t\t\tmemcpy(probe_loctl, &test_loctl,\n\t\t\t\t       sizeof(struct b43_loctl));\n\t\t\t\tfound_lower = 1;\n\t\t\t\td->lowest_feedth = feedth;\n\t\t\t\tif ((d->nr_measured < 2) &&\n\t\t\t\t    !has_loopback_gain(phy))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmemcpy(&prev_loctl, &test_loctl, sizeof(prev_loctl));\n\t\tif (i == end)\n\t\t\tbreak;\n\t\tif (i == 8)\n\t\t\ti = 1;\n\t\telse\n\t\t\ti++;\n\t\td->current_state = i;\n\t}\n\n\treturn found_lower;\n}\n\nstatic void lo_probe_loctls_statemachine(struct b43_wldev *dev,\n\t\t\t\t\t struct b43_loctl *loctl,\n\t\t\t\t\t int *max_rx_gain)\n{\n\tstruct b43_phy *phy = &dev->phy;\n\tstruct b43_phy_g *gphy = phy->g;\n\tstruct b43_lo_g_statemachine d;\n\tu16 feedth;\n\tint found_lower;\n\tstruct b43_loctl probe_loctl;\n\tint max_repeat = 1, repeat_cnt = 0;\n\n\td.nr_measured = 0;\n\td.state_val_multiplier = 1;\n\tif (has_loopback_gain(phy))\n\t\td.state_val_multiplier = 3;\n\n\tmemcpy(&d.min_loctl, loctl, sizeof(struct b43_loctl));\n\tif (has_loopback_gain(phy))\n\t\tmax_repeat = 4;\n\tdo {\n\t\tb43_lo_write(dev, &d.min_loctl);\n\t\tfeedth = lo_measure_feedthrough(dev, gphy->lna_gain,\n\t\t\t\t\t\tgphy->pga_gain,\n\t\t\t\t\t\tgphy->trsw_rx_gain);\n\t\tif (feedth < 0x258) {\n\t\t\tif (feedth >= 0x12C)\n\t\t\t\t*max_rx_gain += 6;\n\t\t\telse\n\t\t\t\t*max_rx_gain += 3;\n\t\t\tfeedth = lo_measure_feedthrough(dev, gphy->lna_gain,\n\t\t\t\t\t\t\tgphy->pga_gain,\n\t\t\t\t\t\t\tgphy->trsw_rx_gain);\n\t\t}\n\t\td.lowest_feedth = feedth;\n\n\t\td.current_state = 0;\n\t\tdo {\n\t\t\tB43_WARN_ON(!\n\t\t\t\t    (d.current_state >= 0\n\t\t\t\t     && d.current_state <= 8));\n\t\t\tmemcpy(&probe_loctl, &d.min_loctl,\n\t\t\t       sizeof(struct b43_loctl));\n\t\t\tfound_lower =\n\t\t\t    lo_probe_possible_loctls(dev, &probe_loctl, &d);\n\t\t\tif (!found_lower)\n\t\t\t\tbreak;\n\t\t\tif ((probe_loctl.i == d.min_loctl.i) &&\n\t\t\t    (probe_loctl.q == d.min_loctl.q))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&d.min_loctl, &probe_loctl,\n\t\t\t       sizeof(struct b43_loctl));\n\t\t\td.nr_measured++;\n\t\t} while (d.nr_measured < 24);\n\t\tmemcpy(loctl, &d.min_loctl, sizeof(struct b43_loctl));\n\n\t\tif (has_loopback_gain(phy)) {\n\t\t\tif (d.lowest_feedth > 0x1194)\n\t\t\t\t*max_rx_gain -= 6;\n\t\t\telse if (d.lowest_feedth < 0x5DC)\n\t\t\t\t*max_rx_gain += 3;\n\t\t\tif (repeat_cnt == 0) {\n\t\t\t\tif (d.lowest_feedth <= 0x5DC) {\n\t\t\t\t\td.state_val_multiplier = 1;\n\t\t\t\t\trepeat_cnt++;\n\t\t\t\t} else\n\t\t\t\t\td.state_val_multiplier = 2;\n\t\t\t} else if (repeat_cnt == 2)\n\t\t\t\td.state_val_multiplier = 1;\n\t\t}\n\t\tlo_measure_gain_values(dev, *max_rx_gain,\n\t\t\t\t       has_loopback_gain(phy));\n\t} while (++repeat_cnt < max_repeat);\n}\n\nstatic\nstruct b43_lo_calib *b43_calibrate_lo_setting(struct b43_wldev *dev,\n\t\t\t\t\t      const struct b43_bbatt *bbatt,\n\t\t\t\t\t      const struct b43_rfatt *rfatt)\n{\n\tstruct b43_phy *phy = &dev->phy;\n\tstruct b43_phy_g *gphy = phy->g;\n\tstruct b43_loctl loctl = {\n\t\t.i = 0,\n\t\t.q = 0,\n\t};\n\tint max_rx_gain;\n\tstruct b43_lo_calib *cal;\n\tstruct lo_g_saved_values saved_regs;\n\t \n\tu16 txctl_reg;\n\tu16 txctl_value;\n\tu16 pad_mix_gain;\n\n\tsaved_regs.old_channel = phy->channel;\n\tb43_mac_suspend(dev);\n\tlo_measure_setup(dev, &saved_regs);\n\n\ttxctl_reg = lo_txctl_register_table(dev, &txctl_value, &pad_mix_gain);\n\n\tb43_radio_maskset(dev, 0x43, 0xFFF0, rfatt->att);\n\tb43_radio_maskset(dev, txctl_reg, ~txctl_value, (rfatt->with_padmix ? txctl_value :0));\n\n\tmax_rx_gain = rfatt->att * 2;\n\tmax_rx_gain += bbatt->att / 2;\n\tif (rfatt->with_padmix)\n\t\tmax_rx_gain -= pad_mix_gain;\n\tif (has_loopback_gain(phy))\n\t\tmax_rx_gain += gphy->max_lb_gain;\n\tlo_measure_gain_values(dev, max_rx_gain,\n\t\t\t       has_loopback_gain(phy));\n\n\tb43_gphy_set_baseband_attenuation(dev, bbatt->att);\n\tlo_probe_loctls_statemachine(dev, &loctl, &max_rx_gain);\n\n\tlo_measure_restore(dev, &saved_regs);\n\tb43_mac_enable(dev);\n\n\tif (b43_debug(dev, B43_DBG_LO)) {\n\t\tb43dbg(dev->wl, \"LO: Calibrated for BB(%u), RF(%u,%u) \"\n\t\t       \"=> I=%d Q=%d\\n\",\n\t\t       bbatt->att, rfatt->att, rfatt->with_padmix,\n\t\t       loctl.i, loctl.q);\n\t}\n\n\tcal = kmalloc(sizeof(*cal), GFP_KERNEL);\n\tif (!cal) {\n\t\tb43warn(dev->wl, \"LO calib: out of memory\\n\");\n\t\treturn NULL;\n\t}\n\tmemcpy(&cal->bbatt, bbatt, sizeof(*bbatt));\n\tmemcpy(&cal->rfatt, rfatt, sizeof(*rfatt));\n\tmemcpy(&cal->ctl, &loctl, sizeof(loctl));\n\tcal->calib_time = jiffies;\n\tINIT_LIST_HEAD(&cal->list);\n\n\treturn cal;\n}\n\n \nstatic\nstruct b43_lo_calib *b43_get_calib_lo_settings(struct b43_wldev *dev,\n\t\t\t\t\t       const struct b43_bbatt *bbatt,\n\t\t\t\t\t       const struct b43_rfatt *rfatt)\n{\n\tstruct b43_txpower_lo_control *lo = dev->phy.g->lo_control;\n\tstruct b43_lo_calib *c;\n\n\tc = b43_find_lo_calib(lo, bbatt, rfatt);\n\tif (c)\n\t\treturn c;\n\t \n\tc = b43_calibrate_lo_setting(dev, bbatt, rfatt);\n\tif (!c)\n\t\treturn NULL;\n\tlist_add(&c->list, &lo->calib_list);\n\n\treturn c;\n}\n\nvoid b43_gphy_dc_lt_init(struct b43_wldev *dev, bool update_all)\n{\n\tstruct b43_phy *phy = &dev->phy;\n\tstruct b43_phy_g *gphy = phy->g;\n\tstruct b43_txpower_lo_control *lo = gphy->lo_control;\n\tint i;\n\tint rf_offset, bb_offset;\n\tconst struct b43_rfatt *rfatt;\n\tconst struct b43_bbatt *bbatt;\n\tu64 power_vector;\n\tbool table_changed = false;\n\n\tBUILD_BUG_ON(B43_DC_LT_SIZE != 32);\n\tB43_WARN_ON(lo->rfatt_list.len * lo->bbatt_list.len > 64);\n\n\tpower_vector = lo->power_vector;\n\tif (!update_all && !power_vector)\n\t\treturn;  \n\n\t \n\tb43_mac_suspend(dev);\n\n\tfor (i = 0; i < B43_DC_LT_SIZE * 2; i++) {\n\t\tstruct b43_lo_calib *cal;\n\t\tint idx;\n\t\tu16 val;\n\n\t\tif (!update_all && !(power_vector & (((u64)1ULL) << i)))\n\t\t\tcontinue;\n\t\t \n\t\tbb_offset = i / lo->rfatt_list.len;\n\t\trf_offset = i % lo->rfatt_list.len;\n\t\tbbatt = &(lo->bbatt_list.list[bb_offset]);\n\t\trfatt = &(lo->rfatt_list.list[rf_offset]);\n\n\t\tcal = b43_calibrate_lo_setting(dev, bbatt, rfatt);\n\t\tif (!cal) {\n\t\t\tb43warn(dev->wl, \"LO: Could not \"\n\t\t\t\t\"calibrate DC table entry\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tval = (u8)(cal->ctl.q);\n\t\tval |= ((u8)(cal->ctl.i)) << 4;\n\t\tkfree(cal);\n\n\t\t \n\t\tidx = i / 2;\n\t\t \n\t\tif (i % 2) {\n\t\t\t \n\t\t\tlo->dc_lt[idx] = (lo->dc_lt[idx] & 0x00FF)\n\t\t\t\t\t | ((val & 0x00FF) << 8);\n\t\t} else {\n\t\t\t \n\t\t\tlo->dc_lt[idx] = (lo->dc_lt[idx] & 0xFF00)\n\t\t\t\t\t | (val & 0x00FF);\n\t\t}\n\t\ttable_changed = true;\n\t}\n\tif (table_changed) {\n\t\t \n\t\tfor (i = 0; i < B43_DC_LT_SIZE; i++)\n\t\t\tb43_phy_write(dev, 0x3A0 + i, lo->dc_lt[i]);\n\t}\n\tb43_mac_enable(dev);\n}\n\n \nstatic inline void b43_lo_fixup_rfatt(struct b43_rfatt *rf)\n{\n\tif (!rf->with_padmix)\n\t\treturn;\n\tif ((rf->att != 1) && (rf->att != 2) && (rf->att != 3))\n\t\trf->att = 4;\n}\n\nvoid b43_lo_g_adjust(struct b43_wldev *dev)\n{\n\tstruct b43_phy_g *gphy = dev->phy.g;\n\tstruct b43_lo_calib *cal;\n\tstruct b43_rfatt rf;\n\n\tmemcpy(&rf, &gphy->rfatt, sizeof(rf));\n\tb43_lo_fixup_rfatt(&rf);\n\n\tcal = b43_get_calib_lo_settings(dev, &gphy->bbatt, &rf);\n\tif (!cal)\n\t\treturn;\n\tb43_lo_write(dev, &cal->ctl);\n}\n\nvoid b43_lo_g_adjust_to(struct b43_wldev *dev,\n\t\t\tu16 rfatt, u16 bbatt, u16 tx_control)\n{\n\tstruct b43_rfatt rf;\n\tstruct b43_bbatt bb;\n\tstruct b43_lo_calib *cal;\n\n\tmemset(&rf, 0, sizeof(rf));\n\tmemset(&bb, 0, sizeof(bb));\n\trf.att = rfatt;\n\tbb.att = bbatt;\n\tb43_lo_fixup_rfatt(&rf);\n\tcal = b43_get_calib_lo_settings(dev, &bb, &rf);\n\tif (!cal)\n\t\treturn;\n\tb43_lo_write(dev, &cal->ctl);\n}\n\n \nvoid b43_lo_g_maintenance_work(struct b43_wldev *dev)\n{\n\tstruct b43_phy *phy = &dev->phy;\n\tstruct b43_phy_g *gphy = phy->g;\n\tstruct b43_txpower_lo_control *lo = gphy->lo_control;\n\tunsigned long now;\n\tunsigned long expire;\n\tstruct b43_lo_calib *cal, *tmp;\n\tbool current_item_expired = false;\n\tbool hwpctl;\n\n\tif (!lo)\n\t\treturn;\n\tnow = jiffies;\n\thwpctl = b43_has_hardware_pctl(dev);\n\n\tif (hwpctl) {\n\t\t \n\t\texpire = now - B43_LO_PWRVEC_EXPIRE;\n\t\tif (time_before(lo->pwr_vec_read_time, expire)) {\n\t\t\tlo_read_power_vector(dev);\n\t\t\tb43_gphy_dc_lt_init(dev, 0);\n\t\t}\n\t\t\n\t}\n\n\tif (hwpctl)\n\t\treturn;\n\t \n\texpire = now - B43_LO_CALIB_EXPIRE;\n\tlist_for_each_entry_safe(cal, tmp, &lo->calib_list, list) {\n\t\tif (!time_before(cal->calib_time, expire))\n\t\t\tcontinue;\n\t\t \n\t\tif (b43_compare_bbatt(&cal->bbatt, &gphy->bbatt) &&\n\t\t    b43_compare_rfatt(&cal->rfatt, &gphy->rfatt)) {\n\t\t\tB43_WARN_ON(current_item_expired);\n\t\t\tcurrent_item_expired = true;\n\t\t}\n\t\tif (b43_debug(dev, B43_DBG_LO)) {\n\t\t\tb43dbg(dev->wl, \"LO: Item BB(%u), RF(%u,%u), \"\n\t\t\t       \"I=%d, Q=%d expired\\n\",\n\t\t\t       cal->bbatt.att, cal->rfatt.att,\n\t\t\t       cal->rfatt.with_padmix,\n\t\t\t       cal->ctl.i, cal->ctl.q);\n\t\t}\n\t\tlist_del(&cal->list);\n\t\tkfree(cal);\n\t}\n\tif (current_item_expired || unlikely(list_empty(&lo->calib_list))) {\n\t\t \n\t\tif (b43_debug(dev, B43_DBG_LO))\n\t\t\tb43dbg(dev->wl, \"LO: Recalibrating current LO setting\\n\");\n\t\tcal = b43_calibrate_lo_setting(dev, &gphy->bbatt, &gphy->rfatt);\n\t\tif (cal) {\n\t\t\tlist_add(&cal->list, &lo->calib_list);\n\t\t\tb43_lo_write(dev, &cal->ctl);\n\t\t} else\n\t\t\tb43warn(dev->wl, \"Failed to recalibrate current LO setting\\n\");\n\t}\n}\n\nvoid b43_lo_g_cleanup(struct b43_wldev *dev)\n{\n\tstruct b43_txpower_lo_control *lo = dev->phy.g->lo_control;\n\tstruct b43_lo_calib *cal, *tmp;\n\n\tif (!lo)\n\t\treturn;\n\tlist_for_each_entry_safe(cal, tmp, &lo->calib_list, list) {\n\t\tlist_del(&cal->list);\n\t\tkfree(cal);\n\t}\n}\n\n \nvoid b43_lo_g_init(struct b43_wldev *dev)\n{\n\tif (b43_has_hardware_pctl(dev)) {\n\t\tlo_read_power_vector(dev);\n\t\tb43_gphy_dc_lt_init(dev, 1);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}