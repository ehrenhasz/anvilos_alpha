{
  "module_name": "xmit.c",
  "hash_id": "eb6dbfbe5345fbda89651130ff6f3f701919b05dffd8cffee54fe7db1905f5fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/broadcom/b43/xmit.c",
  "human_readable_source": "\n \n\n#include \"xmit.h\"\n#include \"phy_common.h\"\n#include \"dma.h\"\n#include \"pio.h\"\n\nstatic const struct b43_tx_legacy_rate_phy_ctl_entry b43_tx_legacy_rate_phy_ctl[] = {\n\t{ B43_CCK_RATE_1MB,\t0x0,\t\t\t0x0 },\n\t{ B43_CCK_RATE_2MB,\t0x0,\t\t\t0x1 },\n\t{ B43_CCK_RATE_5MB,\t0x0,\t\t\t0x2 },\n\t{ B43_CCK_RATE_11MB,\t0x0,\t\t\t0x3 },\n\t{ B43_OFDM_RATE_6MB,\tB43_TXH_PHY1_CRATE_1_2,\tB43_TXH_PHY1_MODUL_BPSK },\n\t{ B43_OFDM_RATE_9MB,\tB43_TXH_PHY1_CRATE_3_4,\tB43_TXH_PHY1_MODUL_BPSK },\n\t{ B43_OFDM_RATE_12MB,\tB43_TXH_PHY1_CRATE_1_2,\tB43_TXH_PHY1_MODUL_QPSK },\n\t{ B43_OFDM_RATE_18MB,\tB43_TXH_PHY1_CRATE_3_4,\tB43_TXH_PHY1_MODUL_QPSK },\n\t{ B43_OFDM_RATE_24MB,\tB43_TXH_PHY1_CRATE_1_2,\tB43_TXH_PHY1_MODUL_QAM16 },\n\t{ B43_OFDM_RATE_36MB,\tB43_TXH_PHY1_CRATE_3_4,\tB43_TXH_PHY1_MODUL_QAM16 },\n\t{ B43_OFDM_RATE_48MB,\tB43_TXH_PHY1_CRATE_2_3,\tB43_TXH_PHY1_MODUL_QAM64 },\n\t{ B43_OFDM_RATE_54MB,\tB43_TXH_PHY1_CRATE_3_4,\tB43_TXH_PHY1_MODUL_QAM64 },\n};\n\nstatic const struct b43_tx_legacy_rate_phy_ctl_entry *\nb43_tx_legacy_rate_phy_ctl_ent(u8 bitrate)\n{\n\tconst struct b43_tx_legacy_rate_phy_ctl_entry *e;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(b43_tx_legacy_rate_phy_ctl); i++) {\n\t\te = &(b43_tx_legacy_rate_phy_ctl[i]);\n\t\tif (e->bitrate == bitrate)\n\t\t\treturn e;\n\t}\n\n\tB43_WARN_ON(1);\n\treturn NULL;\n}\n\n \nstatic int b43_plcp_get_bitrate_idx_cck(struct b43_plcp_hdr6 *plcp)\n{\n\tswitch (plcp->raw[0]) {\n\tcase 0x0A:\n\t\treturn 0;\n\tcase 0x14:\n\t\treturn 1;\n\tcase 0x37:\n\t\treturn 2;\n\tcase 0x6E:\n\t\treturn 3;\n\t}\n\treturn -1;\n}\n\n \nstatic int b43_plcp_get_bitrate_idx_ofdm(struct b43_plcp_hdr6 *plcp, bool ghz5)\n{\n\t \n\tint base = ghz5 ? 0 : 4;\n\n\tswitch (plcp->raw[0] & 0xF) {\n\tcase 0xB:\n\t\treturn base + 0;\n\tcase 0xF:\n\t\treturn base + 1;\n\tcase 0xA:\n\t\treturn base + 2;\n\tcase 0xE:\n\t\treturn base + 3;\n\tcase 0x9:\n\t\treturn base + 4;\n\tcase 0xD:\n\t\treturn base + 5;\n\tcase 0x8:\n\t\treturn base + 6;\n\tcase 0xC:\n\t\treturn base + 7;\n\t}\n\treturn -1;\n}\n\nu8 b43_plcp_get_ratecode_cck(const u8 bitrate)\n{\n\tswitch (bitrate) {\n\tcase B43_CCK_RATE_1MB:\n\t\treturn 0x0A;\n\tcase B43_CCK_RATE_2MB:\n\t\treturn 0x14;\n\tcase B43_CCK_RATE_5MB:\n\t\treturn 0x37;\n\tcase B43_CCK_RATE_11MB:\n\t\treturn 0x6E;\n\t}\n\tB43_WARN_ON(1);\n\treturn 0;\n}\n\nu8 b43_plcp_get_ratecode_ofdm(const u8 bitrate)\n{\n\tswitch (bitrate) {\n\tcase B43_OFDM_RATE_6MB:\n\t\treturn 0xB;\n\tcase B43_OFDM_RATE_9MB:\n\t\treturn 0xF;\n\tcase B43_OFDM_RATE_12MB:\n\t\treturn 0xA;\n\tcase B43_OFDM_RATE_18MB:\n\t\treturn 0xE;\n\tcase B43_OFDM_RATE_24MB:\n\t\treturn 0x9;\n\tcase B43_OFDM_RATE_36MB:\n\t\treturn 0xD;\n\tcase B43_OFDM_RATE_48MB:\n\t\treturn 0x8;\n\tcase B43_OFDM_RATE_54MB:\n\t\treturn 0xC;\n\t}\n\tB43_WARN_ON(1);\n\treturn 0;\n}\n\nvoid b43_generate_plcp_hdr(struct b43_plcp_hdr4 *plcp,\n\t\t\t   const u16 octets, const u8 bitrate)\n{\n\t__u8 *raw = plcp->raw;\n\n\tif (b43_is_ofdm_rate(bitrate)) {\n\t\tu32 d;\n\n\t\td = b43_plcp_get_ratecode_ofdm(bitrate);\n\t\tB43_WARN_ON(octets & 0xF000);\n\t\td |= (octets << 5);\n\t\tplcp->data = cpu_to_le32(d);\n\t} else {\n\t\tu32 plen;\n\n\t\tplen = octets * 16 / bitrate;\n\t\tif ((octets * 16 % bitrate) > 0) {\n\t\t\tplen++;\n\t\t\tif ((bitrate == B43_CCK_RATE_11MB)\n\t\t\t    && ((octets * 8 % 11) < 4)) {\n\t\t\t\traw[1] = 0x84;\n\t\t\t} else\n\t\t\t\traw[1] = 0x04;\n\t\t} else\n\t\t\traw[1] = 0x04;\n\t\tplcp->data |= cpu_to_le32(plen << 16);\n\t\traw[0] = b43_plcp_get_ratecode_cck(bitrate);\n\t}\n}\n\n \nstatic u16 b43_generate_tx_phy_ctl1(struct b43_wldev *dev, u8 bitrate)\n{\n\tconst struct b43_phy *phy = &dev->phy;\n\tconst struct b43_tx_legacy_rate_phy_ctl_entry *e;\n\tu16 control = 0;\n\tu16 bw;\n\n\tif (phy->type == B43_PHYTYPE_LP)\n\t\tbw = B43_TXH_PHY1_BW_20;\n\telse  \n\t\tbw = B43_TXH_PHY1_BW_20;\n\n\tif (0) {  \n\t} else if (b43_is_cck_rate(bitrate) && phy->type != B43_PHYTYPE_LP) {\n\t\tcontrol = bw;\n\t} else {\n\t\tcontrol = bw;\n\t\te = b43_tx_legacy_rate_phy_ctl_ent(bitrate);\n\t\tif (e) {\n\t\t\tcontrol |= e->coding_rate;\n\t\t\tcontrol |= e->modulation;\n\t\t}\n\t\tcontrol |= B43_TXH_PHY1_MODE_SISO;\n\t}\n\n\treturn control;\n}\n\nstatic u8 b43_calc_fallback_rate(u8 bitrate, int gmode)\n{\n\tswitch (bitrate) {\n\tcase B43_CCK_RATE_1MB:\n\t\treturn B43_CCK_RATE_1MB;\n\tcase B43_CCK_RATE_2MB:\n\t\treturn B43_CCK_RATE_1MB;\n\tcase B43_CCK_RATE_5MB:\n\t\treturn B43_CCK_RATE_2MB;\n\tcase B43_CCK_RATE_11MB:\n\t\treturn B43_CCK_RATE_5MB;\n\t \n\tcase B43_OFDM_RATE_6MB:\n\t\tif (gmode)\n\t\t\treturn B43_CCK_RATE_5MB;\n\t\telse\n\t\t\treturn B43_OFDM_RATE_6MB;\n\tcase B43_OFDM_RATE_9MB:\n\t\treturn B43_OFDM_RATE_6MB;\n\tcase B43_OFDM_RATE_12MB:\n\t\treturn B43_OFDM_RATE_9MB;\n\tcase B43_OFDM_RATE_18MB:\n\t\treturn B43_OFDM_RATE_12MB;\n\tcase B43_OFDM_RATE_24MB:\n\t\treturn B43_OFDM_RATE_18MB;\n\tcase B43_OFDM_RATE_36MB:\n\t\treturn B43_OFDM_RATE_24MB;\n\tcase B43_OFDM_RATE_48MB:\n\t\treturn B43_OFDM_RATE_36MB;\n\tcase B43_OFDM_RATE_54MB:\n\t\treturn B43_OFDM_RATE_48MB;\n\t}\n\tB43_WARN_ON(1);\n\treturn 0;\n}\n\n \nint b43_generate_txhdr(struct b43_wldev *dev,\n\t\t       u8 *_txhdr,\n\t\t       struct sk_buff *skb_frag,\n\t\t       struct ieee80211_tx_info *info,\n\t\t       u16 cookie)\n{\n\tconst unsigned char *fragment_data = skb_frag->data;\n\tunsigned int fragment_len = skb_frag->len;\n\tstruct b43_txhdr *txhdr = (struct b43_txhdr *)_txhdr;\n\tconst struct b43_phy *phy = &dev->phy;\n\tconst struct ieee80211_hdr *wlhdr =\n\t    (const struct ieee80211_hdr *)fragment_data;\n\tint use_encryption = !!info->control.hw_key;\n\t__le16 fctl = wlhdr->frame_control;\n\tstruct ieee80211_rate *fbrate;\n\tu8 rate, rate_fb;\n\tint rate_ofdm, rate_fb_ofdm;\n\tunsigned int plcp_fragment_len;\n\tu32 mac_ctl = 0;\n\tu16 phy_ctl = 0;\n\tbool fill_phy_ctl1 = (phy->type == B43_PHYTYPE_LP ||\n\t\t\t      phy->type == B43_PHYTYPE_N ||\n\t\t\t      phy->type == B43_PHYTYPE_HT);\n\tu8 extra_ft = 0;\n\tstruct ieee80211_rate *txrate;\n\tstruct ieee80211_tx_rate *rates;\n\n\tmemset(txhdr, 0, sizeof(*txhdr));\n\n\ttxrate = ieee80211_get_tx_rate(dev->wl->hw, info);\n\trate = txrate ? txrate->hw_value : B43_CCK_RATE_1MB;\n\trate_ofdm = b43_is_ofdm_rate(rate);\n\tfbrate = ieee80211_get_alt_retry_rate(dev->wl->hw, info, 0) ? : txrate;\n\trate_fb = fbrate->hw_value;\n\trate_fb_ofdm = b43_is_ofdm_rate(rate_fb);\n\n\tif (rate_ofdm)\n\t\ttxhdr->phy_rate = b43_plcp_get_ratecode_ofdm(rate);\n\telse\n\t\ttxhdr->phy_rate = b43_plcp_get_ratecode_cck(rate);\n\ttxhdr->mac_frame_ctl = wlhdr->frame_control;\n\tmemcpy(txhdr->tx_receiver, wlhdr->addr1, ETH_ALEN);\n\n\t \n\tif ((rate_fb == rate) ||\n\t    (wlhdr->duration_id & cpu_to_le16(0x8000)) ||\n\t    (wlhdr->duration_id == cpu_to_le16(0))) {\n\t\t \n\t\ttxhdr->dur_fb = wlhdr->duration_id;\n\t} else {\n\t\ttxhdr->dur_fb = ieee80211_generic_frame_duration(\n\t\t\tdev->wl->hw, info->control.vif, info->band,\n\t\t\tfragment_len, fbrate);\n\t}\n\n\tplcp_fragment_len = fragment_len + FCS_LEN;\n\tif (use_encryption) {\n\t\tu8 key_idx = info->control.hw_key->hw_key_idx;\n\t\tstruct b43_key *key;\n\t\tint wlhdr_len;\n\t\tsize_t iv_len;\n\n\t\tB43_WARN_ON(key_idx >= ARRAY_SIZE(dev->key));\n\t\tkey = &(dev->key[key_idx]);\n\n\t\tif (unlikely(!key->keyconf)) {\n\t\t\t \n\t\t\treturn -ENOKEY;\n\t\t}\n\n\t\t \n\t\tplcp_fragment_len += info->control.hw_key->icv_len;\n\n\t\tkey_idx = b43_kidx_to_fw(dev, key_idx);\n\t\tmac_ctl |= (key_idx << B43_TXH_MAC_KEYIDX_SHIFT) &\n\t\t\t   B43_TXH_MAC_KEYIDX;\n\t\tmac_ctl |= (key->algorithm << B43_TXH_MAC_KEYALG_SHIFT) &\n\t\t\t   B43_TXH_MAC_KEYALG;\n\t\twlhdr_len = ieee80211_hdrlen(fctl);\n\t\tif (key->algorithm == B43_SEC_ALGO_TKIP) {\n\t\t\tu16 phase1key[5];\n\t\t\tint i;\n\t\t\t \n\t\t\tieee80211_get_tkip_p1k(info->control.hw_key, skb_frag, phase1key);\n\t\t\t \n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\ttxhdr->iv[i * 2 + 0] = phase1key[i];\n\t\t\t\ttxhdr->iv[i * 2 + 1] = phase1key[i] >> 8;\n\t\t\t}\n\t\t\t \n\t\t\tmemcpy(txhdr->iv + 10, ((u8 *) wlhdr) + wlhdr_len, 3);\n\t\t} else {\n\t\t\tiv_len = min_t(size_t, info->control.hw_key->iv_len,\n\t\t\t\t     ARRAY_SIZE(txhdr->iv));\n\t\t\tmemcpy(txhdr->iv, ((u8 *) wlhdr) + wlhdr_len, iv_len);\n\t\t}\n\t}\n\tswitch (dev->fw.hdr_format) {\n\tcase B43_FW_HDR_598:\n\t\tb43_generate_plcp_hdr((struct b43_plcp_hdr4 *)(&txhdr->format_598.plcp),\n\t\t\t\t      plcp_fragment_len, rate);\n\t\tbreak;\n\tcase B43_FW_HDR_351:\n\t\tb43_generate_plcp_hdr((struct b43_plcp_hdr4 *)(&txhdr->format_351.plcp),\n\t\t\t\t      plcp_fragment_len, rate);\n\t\tbreak;\n\tcase B43_FW_HDR_410:\n\t\tb43_generate_plcp_hdr((struct b43_plcp_hdr4 *)(&txhdr->format_410.plcp),\n\t\t\t\t      plcp_fragment_len, rate);\n\t\tbreak;\n\t}\n\tb43_generate_plcp_hdr((struct b43_plcp_hdr4 *)(&txhdr->plcp_fb),\n\t\t\t      plcp_fragment_len, rate_fb);\n\n\t \n\tif (rate_fb_ofdm)\n\t\textra_ft |= B43_TXH_EFT_FB_OFDM;\n\telse\n\t\textra_ft |= B43_TXH_EFT_FB_CCK;\n\n\t \n\ttxhdr->chan_radio_code = phy->channel;\n\n\t \n\tif (rate_ofdm)\n\t\tphy_ctl |= B43_TXH_PHY_ENC_OFDM;\n\telse\n\t\tphy_ctl |= B43_TXH_PHY_ENC_CCK;\n\tif (info->control.rates[0].flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE)\n\t\tphy_ctl |= B43_TXH_PHY_SHORTPRMBL;\n\n\tswitch (b43_ieee80211_antenna_sanitize(dev, 0)) {\n\tcase 0:  \n\t\tphy_ctl |= B43_TXH_PHY_ANT01AUTO;\n\t\tbreak;\n\tcase 1:  \n\t\tphy_ctl |= B43_TXH_PHY_ANT0;\n\t\tbreak;\n\tcase 2:  \n\t\tphy_ctl |= B43_TXH_PHY_ANT1;\n\t\tbreak;\n\tcase 3:  \n\t\tphy_ctl |= B43_TXH_PHY_ANT2;\n\t\tbreak;\n\tcase 4:  \n\t\tphy_ctl |= B43_TXH_PHY_ANT3;\n\t\tbreak;\n\tdefault:\n\t\tB43_WARN_ON(1);\n\t}\n\n\trates = info->control.rates;\n\t \n\tif (!(info->flags & IEEE80211_TX_CTL_NO_ACK))\n\t\tmac_ctl |= B43_TXH_MAC_ACK;\n\t \n\tif (info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ)\n\t\tmac_ctl |= B43_TXH_MAC_HWSEQ;\n\tif (info->flags & IEEE80211_TX_CTL_FIRST_FRAGMENT)\n\t\tmac_ctl |= B43_TXH_MAC_STMSDU;\n\tif (!phy->gmode)\n\t\tmac_ctl |= B43_TXH_MAC_5GHZ;\n\n\t \n\tif ((rates[0].flags & IEEE80211_TX_RC_USE_RTS_CTS) ||\n\t    (rates[0].count <= dev->wl->hw->conf.long_frame_max_tx_count)) {\n\t\trates[0].count = dev->wl->hw->conf.long_frame_max_tx_count;\n\t\tmac_ctl |= B43_TXH_MAC_LONGFRAME;\n\t} else {\n\t\trates[0].count = dev->wl->hw->conf.short_frame_max_tx_count;\n\t}\n\n\t \n\tif ((rates[0].flags & IEEE80211_TX_RC_USE_RTS_CTS) ||\n\t    (rates[0].flags & IEEE80211_TX_RC_USE_CTS_PROTECT)) {\n\t\tunsigned int len;\n\t\tstruct ieee80211_hdr *hdr;\n\t\tint rts_rate, rts_rate_fb;\n\t\tint rts_rate_ofdm, rts_rate_fb_ofdm;\n\t\tstruct b43_plcp_hdr6 *plcp;\n\t\tstruct ieee80211_rate *rts_cts_rate;\n\n\t\trts_cts_rate = ieee80211_get_rts_cts_rate(dev->wl->hw, info);\n\n\t\trts_rate = rts_cts_rate ? rts_cts_rate->hw_value : B43_CCK_RATE_1MB;\n\t\trts_rate_ofdm = b43_is_ofdm_rate(rts_rate);\n\t\trts_rate_fb = b43_calc_fallback_rate(rts_rate, phy->gmode);\n\t\trts_rate_fb_ofdm = b43_is_ofdm_rate(rts_rate_fb);\n\n\t\tif (rates[0].flags & IEEE80211_TX_RC_USE_CTS_PROTECT) {\n\t\t\tstruct ieee80211_cts *cts;\n\n\t\t\tswitch (dev->fw.hdr_format) {\n\t\t\tcase B43_FW_HDR_598:\n\t\t\t\tcts = (struct ieee80211_cts *)\n\t\t\t\t\t(txhdr->format_598.rts_frame);\n\t\t\t\tbreak;\n\t\t\tcase B43_FW_HDR_351:\n\t\t\t\tcts = (struct ieee80211_cts *)\n\t\t\t\t\t(txhdr->format_351.rts_frame);\n\t\t\t\tbreak;\n\t\t\tcase B43_FW_HDR_410:\n\t\t\t\tcts = (struct ieee80211_cts *)\n\t\t\t\t\t(txhdr->format_410.rts_frame);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tieee80211_ctstoself_get(dev->wl->hw, info->control.vif,\n\t\t\t\t\t\tfragment_data, fragment_len,\n\t\t\t\t\t\tinfo, cts);\n\t\t\tmac_ctl |= B43_TXH_MAC_SENDCTS;\n\t\t\tlen = sizeof(struct ieee80211_cts);\n\t\t} else {\n\t\t\tstruct ieee80211_rts *rts;\n\n\t\t\tswitch (dev->fw.hdr_format) {\n\t\t\tcase B43_FW_HDR_598:\n\t\t\t\trts = (struct ieee80211_rts *)\n\t\t\t\t\t(txhdr->format_598.rts_frame);\n\t\t\t\tbreak;\n\t\t\tcase B43_FW_HDR_351:\n\t\t\t\trts = (struct ieee80211_rts *)\n\t\t\t\t\t(txhdr->format_351.rts_frame);\n\t\t\t\tbreak;\n\t\t\tcase B43_FW_HDR_410:\n\t\t\t\trts = (struct ieee80211_rts *)\n\t\t\t\t\t(txhdr->format_410.rts_frame);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tieee80211_rts_get(dev->wl->hw, info->control.vif,\n\t\t\t\t\t  fragment_data, fragment_len,\n\t\t\t\t\t  info, rts);\n\t\t\tmac_ctl |= B43_TXH_MAC_SENDRTS;\n\t\t\tlen = sizeof(struct ieee80211_rts);\n\t\t}\n\t\tlen += FCS_LEN;\n\n\t\t \n\t\tswitch (dev->fw.hdr_format) {\n\t\tcase B43_FW_HDR_598:\n\t\t\tplcp = &txhdr->format_598.rts_plcp;\n\t\t\tbreak;\n\t\tcase B43_FW_HDR_351:\n\t\t\tplcp = &txhdr->format_351.rts_plcp;\n\t\t\tbreak;\n\t\tcase B43_FW_HDR_410:\n\t\t\tplcp = &txhdr->format_410.rts_plcp;\n\t\t\tbreak;\n\t\t}\n\t\tb43_generate_plcp_hdr((struct b43_plcp_hdr4 *)plcp,\n\t\t\t\t      len, rts_rate);\n\t\tplcp = &txhdr->rts_plcp_fb;\n\t\tb43_generate_plcp_hdr((struct b43_plcp_hdr4 *)plcp,\n\t\t\t\t      len, rts_rate_fb);\n\n\t\tswitch (dev->fw.hdr_format) {\n\t\tcase B43_FW_HDR_598:\n\t\t\thdr = (struct ieee80211_hdr *)\n\t\t\t\t(&txhdr->format_598.rts_frame);\n\t\t\tbreak;\n\t\tcase B43_FW_HDR_351:\n\t\t\thdr = (struct ieee80211_hdr *)\n\t\t\t\t(&txhdr->format_351.rts_frame);\n\t\t\tbreak;\n\t\tcase B43_FW_HDR_410:\n\t\t\thdr = (struct ieee80211_hdr *)\n\t\t\t\t(&txhdr->format_410.rts_frame);\n\t\t\tbreak;\n\t\t}\n\t\ttxhdr->rts_dur_fb = hdr->duration_id;\n\n\t\tif (rts_rate_ofdm) {\n\t\t\textra_ft |= B43_TXH_EFT_RTS_OFDM;\n\t\t\ttxhdr->phy_rate_rts =\n\t\t\t    b43_plcp_get_ratecode_ofdm(rts_rate);\n\t\t} else {\n\t\t\textra_ft |= B43_TXH_EFT_RTS_CCK;\n\t\t\ttxhdr->phy_rate_rts =\n\t\t\t    b43_plcp_get_ratecode_cck(rts_rate);\n\t\t}\n\t\tif (rts_rate_fb_ofdm)\n\t\t\textra_ft |= B43_TXH_EFT_RTSFB_OFDM;\n\t\telse\n\t\t\textra_ft |= B43_TXH_EFT_RTSFB_CCK;\n\n\t\tif (rates[0].flags & IEEE80211_TX_RC_USE_RTS_CTS &&\n\t\t    fill_phy_ctl1) {\n\t\t\ttxhdr->phy_ctl1_rts = cpu_to_le16(\n\t\t\t\tb43_generate_tx_phy_ctl1(dev, rts_rate));\n\t\t\ttxhdr->phy_ctl1_rts_fb = cpu_to_le16(\n\t\t\t\tb43_generate_tx_phy_ctl1(dev, rts_rate_fb));\n\t\t}\n\t}\n\n\t \n\tswitch (dev->fw.hdr_format) {\n\tcase B43_FW_HDR_598:\n\t\ttxhdr->format_598.cookie = cpu_to_le16(cookie);\n\t\tbreak;\n\tcase B43_FW_HDR_351:\n\t\ttxhdr->format_351.cookie = cpu_to_le16(cookie);\n\t\tbreak;\n\tcase B43_FW_HDR_410:\n\t\ttxhdr->format_410.cookie = cpu_to_le16(cookie);\n\t\tbreak;\n\t}\n\n\tif (fill_phy_ctl1) {\n\t\ttxhdr->phy_ctl1 =\n\t\t\tcpu_to_le16(b43_generate_tx_phy_ctl1(dev, rate));\n\t\ttxhdr->phy_ctl1_fb =\n\t\t\tcpu_to_le16(b43_generate_tx_phy_ctl1(dev, rate_fb));\n\t}\n\n\t \n\ttxhdr->mac_ctl = cpu_to_le32(mac_ctl);\n\ttxhdr->phy_ctl = cpu_to_le16(phy_ctl);\n\ttxhdr->extra_ft = extra_ft;\n\n\treturn 0;\n}\n\nstatic s8 b43_rssi_postprocess(struct b43_wldev *dev,\n\t\t\t       u8 in_rssi, int ofdm,\n\t\t\t       int adjust_2053, int adjust_2050)\n{\n\tstruct b43_phy *phy = &dev->phy;\n\tstruct b43_phy_g *gphy = phy->g;\n\ts32 tmp;\n\n\tswitch (phy->radio_ver) {\n\tcase 0x2050:\n\t\tif (ofdm) {\n\t\t\ttmp = in_rssi;\n\t\t\tif (tmp > 127)\n\t\t\t\ttmp -= 256;\n\t\t\ttmp *= 73;\n\t\t\ttmp /= 64;\n\t\t\tif (adjust_2050)\n\t\t\t\ttmp += 25;\n\t\t\telse\n\t\t\t\ttmp -= 3;\n\t\t} else {\n\t\t\tif (dev->dev->bus_sprom->\n\t\t\t    boardflags_lo & B43_BFL_RSSI) {\n\t\t\t\tif (in_rssi > 63)\n\t\t\t\t\tin_rssi = 63;\n\t\t\t\tB43_WARN_ON(phy->type != B43_PHYTYPE_G);\n\t\t\t\ttmp = gphy->nrssi_lt[in_rssi];\n\t\t\t\ttmp = 31 - tmp;\n\t\t\t\ttmp *= -131;\n\t\t\t\ttmp /= 128;\n\t\t\t\ttmp -= 57;\n\t\t\t} else {\n\t\t\t\ttmp = in_rssi;\n\t\t\t\ttmp = 31 - tmp;\n\t\t\t\ttmp *= -149;\n\t\t\t\ttmp /= 128;\n\t\t\t\ttmp -= 68;\n\t\t\t}\n\t\t\tif (phy->type == B43_PHYTYPE_G && adjust_2050)\n\t\t\t\ttmp += 25;\n\t\t}\n\t\tbreak;\n\tcase 0x2060:\n\t\tif (in_rssi > 127)\n\t\t\ttmp = in_rssi - 256;\n\t\telse\n\t\t\ttmp = in_rssi;\n\t\tbreak;\n\tdefault:\n\t\ttmp = in_rssi;\n\t\ttmp -= 11;\n\t\ttmp *= 103;\n\t\ttmp /= 64;\n\t\tif (adjust_2053)\n\t\t\ttmp -= 109;\n\t\telse\n\t\t\ttmp -= 83;\n\t}\n\n\treturn (s8) tmp;\n}\n\nvoid b43_rx(struct b43_wldev *dev, struct sk_buff *skb, const void *_rxhdr)\n{\n\tstruct ieee80211_rx_status status;\n\tstruct b43_plcp_hdr6 *plcp;\n\tstruct ieee80211_hdr *wlhdr;\n\tconst struct b43_rxhdr_fw4 *rxhdr = _rxhdr;\n\t__le16 fctl;\n\tu16 phystat0, phystat3;\n\tu16 chanstat, mactime;\n\tu32 macstat;\n\tu16 chanid;\n\tint padding, rate_idx;\n\n\tmemset(&status, 0, sizeof(status));\n\n\t \n\tphystat0 = le16_to_cpu(rxhdr->phy_status0);\n\tphystat3 = le16_to_cpu(rxhdr->phy_status3);\n\tswitch (dev->fw.hdr_format) {\n\tcase B43_FW_HDR_598:\n\t\tmacstat = le32_to_cpu(rxhdr->format_598.mac_status);\n\t\tmactime = le16_to_cpu(rxhdr->format_598.mac_time);\n\t\tchanstat = le16_to_cpu(rxhdr->format_598.channel);\n\t\tbreak;\n\tcase B43_FW_HDR_410:\n\tcase B43_FW_HDR_351:\n\t\tmacstat = le32_to_cpu(rxhdr->format_351.mac_status);\n\t\tmactime = le16_to_cpu(rxhdr->format_351.mac_time);\n\t\tchanstat = le16_to_cpu(rxhdr->format_351.channel);\n\t\tbreak;\n\t}\n\n\tif (unlikely(macstat & B43_RX_MAC_FCSERR)) {\n\t\tdev->wl->ieee_stats.dot11FCSErrorCount++;\n\t\tstatus.flag |= RX_FLAG_FAILED_FCS_CRC;\n\t}\n\tif (unlikely(phystat0 & (B43_RX_PHYST0_PLCPHCF | B43_RX_PHYST0_PLCPFV)))\n\t\tstatus.flag |= RX_FLAG_FAILED_PLCP_CRC;\n\tif (phystat0 & B43_RX_PHYST0_SHORTPRMBL)\n\t\tstatus.enc_flags |= RX_ENC_FLAG_SHORTPRE;\n\tif (macstat & B43_RX_MAC_DECERR) {\n\t\t \n\t\tgoto drop;\n\t}\n\n\t \n\tpadding = (macstat & B43_RX_MAC_PADDING) ? 2 : 0;\n\tif (unlikely(skb->len < (sizeof(struct b43_plcp_hdr6) + padding))) {\n\t\tb43dbg(dev->wl, \"RX: Packet size underrun (1)\\n\");\n\t\tgoto drop;\n\t}\n\tplcp = (struct b43_plcp_hdr6 *)(skb->data + padding);\n\tskb_pull(skb, sizeof(struct b43_plcp_hdr6) + padding);\n\t \n\tif (unlikely(skb->len < (2 + 2 + 6    + FCS_LEN))) {\n\t\tb43dbg(dev->wl, \"RX: Packet size underrun (2)\\n\");\n\t\tgoto drop;\n\t}\n\twlhdr = (struct ieee80211_hdr *)(skb->data);\n\tfctl = wlhdr->frame_control;\n\n\tif (macstat & B43_RX_MAC_DEC) {\n\t\tunsigned int keyidx;\n\t\tint wlhdr_len;\n\n\t\tkeyidx = ((macstat & B43_RX_MAC_KEYIDX)\n\t\t\t  >> B43_RX_MAC_KEYIDX_SHIFT);\n\t\t \n\t\tkeyidx = b43_kidx_to_raw(dev, keyidx);\n\t\tB43_WARN_ON(keyidx >= ARRAY_SIZE(dev->key));\n\n\t\tif (dev->key[keyidx].algorithm != B43_SEC_ALGO_NONE) {\n\t\t\twlhdr_len = ieee80211_hdrlen(fctl);\n\t\t\tif (unlikely(skb->len < (wlhdr_len + 3))) {\n\t\t\t\tb43dbg(dev->wl,\n\t\t\t\t       \"RX: Packet size underrun (3)\\n\");\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\tstatus.flag |= RX_FLAG_DECRYPTED;\n\t\t}\n\t}\n\n\t \n\tswitch (chanstat & B43_RX_CHAN_PHYTYPE) {\n\tcase B43_PHYTYPE_HT:\n\t\t \n\t\tstatus.signal = max_t(__s8,\n\t\t\tmax(rxhdr->phy_ht_power0, rxhdr->phy_ht_power1),\n\t\t\trxhdr->phy_ht_power2);\n\t\tbreak;\n\tcase B43_PHYTYPE_N:\n\t\t \n\t\tif (rxhdr->power0 == 16 || rxhdr->power0 == 32)\n\t\t\tstatus.signal = max(rxhdr->power1, rxhdr->power2);\n\t\telse\n\t\t\tstatus.signal = max(rxhdr->power0, rxhdr->power1);\n\t\tbreak;\n\tcase B43_PHYTYPE_B:\n\tcase B43_PHYTYPE_G:\n\tcase B43_PHYTYPE_LP:\n\t\tstatus.signal = b43_rssi_postprocess(dev, rxhdr->jssi,\n\t\t\t\t\t\t  (phystat0 & B43_RX_PHYST0_OFDM),\n\t\t\t\t\t\t  (phystat0 & B43_RX_PHYST0_GAINCTL),\n\t\t\t\t\t\t  (phystat3 & B43_RX_PHYST3_TRSTATE));\n\t\tbreak;\n\t}\n\n\tif (phystat0 & B43_RX_PHYST0_OFDM)\n\t\trate_idx = b43_plcp_get_bitrate_idx_ofdm(plcp,\n\t\t\t\t\t!!(chanstat & B43_RX_CHAN_5GHZ));\n\telse\n\t\trate_idx = b43_plcp_get_bitrate_idx_cck(plcp);\n\tif (unlikely(rate_idx == -1)) {\n\t\t \n\t\tif (!(dev->wl->filter_flags & FIF_PLCPFAIL))\n\t\t\tgoto drop;\n\t}\n\tstatus.rate_idx = rate_idx;\n\tstatus.antenna = !!(phystat0 & B43_RX_PHYST0_ANT);\n\n\t \n\tif (ieee80211_is_beacon(fctl) || dev->wl->radiotap_enabled) {\n\t\tu16 low_mactime_now;\n\n\t\tb43_tsf_read(dev, &status.mactime);\n\t\tlow_mactime_now = status.mactime;\n\t\tstatus.mactime = status.mactime & ~0xFFFFULL;\n\t\tstatus.mactime += mactime;\n\t\tif (low_mactime_now <= mactime)\n\t\t\tstatus.mactime -= 0x10000;\n\t\tstatus.flag |= RX_FLAG_MACTIME_START;\n\t}\n\n\tchanid = (chanstat & B43_RX_CHAN_ID) >> B43_RX_CHAN_ID_SHIFT;\n\tswitch (chanstat & B43_RX_CHAN_PHYTYPE) {\n\tcase B43_PHYTYPE_G:\n\t\tstatus.band = NL80211_BAND_2GHZ;\n\t\t \n\t\tif (dev->fw.rev >= 508)\n\t\t\tstatus.freq = ieee80211_channel_to_frequency(chanid, status.band);\n\t\telse\n\t\t\tstatus.freq = chanid + 2400;\n\t\tbreak;\n\tcase B43_PHYTYPE_N:\n\tcase B43_PHYTYPE_LP:\n\tcase B43_PHYTYPE_HT:\n\t\t \n\t\tif (chanstat & B43_RX_CHAN_5GHZ)\n\t\t\tstatus.band = NL80211_BAND_5GHZ;\n\t\telse\n\t\t\tstatus.band = NL80211_BAND_2GHZ;\n\t\tstatus.freq =\n\t\t\tieee80211_channel_to_frequency(chanid, status.band);\n\t\tbreak;\n\tdefault:\n\t\tB43_WARN_ON(1);\n\t\tgoto drop;\n\t}\n\n\tmemcpy(IEEE80211_SKB_RXCB(skb), &status, sizeof(status));\n\tieee80211_rx_ni(dev->wl->hw, skb);\n\n#if B43_DEBUG\n\tdev->rx_count++;\n#endif\n\treturn;\ndrop:\n\tdev_kfree_skb_any(skb);\n}\n\nvoid b43_handle_txstatus(struct b43_wldev *dev,\n\t\t\t const struct b43_txstatus *status)\n{\n\tb43_debugfs_log_txstat(dev, status);\n\n\tif (status->intermediate)\n\t\treturn;\n\tif (status->for_ampdu)\n\t\treturn;\n\tif (!status->acked)\n\t\tdev->wl->ieee_stats.dot11ACKFailureCount++;\n\tif (status->rts_count) {\n\t\tif (status->rts_count == 0xF)\t \n\t\t\tdev->wl->ieee_stats.dot11RTSFailureCount++;\n\t\telse\n\t\t\tdev->wl->ieee_stats.dot11RTSSuccessCount++;\n\t}\n\n\tif (b43_using_pio_transfers(dev))\n\t\tb43_pio_handle_txstatus(dev, status);\n\telse\n\t\tb43_dma_handle_txstatus(dev, status);\n\n\tb43_phy_txpower_check(dev, 0);\n}\n\n \nbool b43_fill_txstatus_report(struct b43_wldev *dev,\n\t\t\t      struct ieee80211_tx_info *report,\n\t\t\t      const struct b43_txstatus *status)\n{\n\tbool frame_success = true;\n\tint retry_limit;\n\n\t \n\tretry_limit = report->status.rates[0].count;\n\tieee80211_tx_info_clear_status(report);\n\n\tif (status->acked) {\n\t\t \n\t\treport->flags |= IEEE80211_TX_STAT_ACK;\n\t} else {\n\t\t \n\t\tif (!(report->flags & IEEE80211_TX_CTL_NO_ACK)) {\n\t\t\t \n\t\t\tframe_success = false;\n\t\t}\n\t}\n\tif (status->frame_count == 0) {\n\t\t \n\t\treport->status.rates[0].count = 0;\n\t} else if (status->rts_count > dev->wl->hw->conf.short_frame_max_tx_count) {\n\t\t \n\t\treport->status.rates[0].count = 0;\n\t\treport->status.rates[1].count = status->frame_count;\n\t} else {\n\t\tif (status->frame_count > retry_limit) {\n\t\t\treport->status.rates[0].count = retry_limit;\n\t\t\treport->status.rates[1].count = status->frame_count -\n\t\t\t\t\tretry_limit;\n\n\t\t} else {\n\t\t\treport->status.rates[0].count = status->frame_count;\n\t\t\treport->status.rates[1].idx = -1;\n\t\t}\n\t}\n\n\treturn frame_success;\n}\n\n \nvoid b43_tx_suspend(struct b43_wldev *dev)\n{\n\tif (b43_using_pio_transfers(dev))\n\t\tb43_pio_tx_suspend(dev);\n\telse\n\t\tb43_dma_tx_suspend(dev);\n}\n\n \nvoid b43_tx_resume(struct b43_wldev *dev)\n{\n\tif (b43_using_pio_transfers(dev))\n\t\tb43_pio_tx_resume(dev);\n\telse\n\t\tb43_dma_tx_resume(dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}