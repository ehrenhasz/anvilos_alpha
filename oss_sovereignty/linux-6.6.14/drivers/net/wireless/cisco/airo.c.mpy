{
  "module_name": "airo.c",
  "hash_id": "e8cd7feafd2bd7021ab15b8fb44de93aba08317bfcc2d6923691d25d4d3dadf0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/cisco/airo.c",
  "human_readable_source": " \n\n#include <linux/err.h>\n#include <linux/init.h>\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\n#include <linux/sched.h>\n#include <linux/ptrace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/interrupt.h>\n#include <linux/in.h>\n#include <linux/bitops.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/io.h>\n#include <asm/unaligned.h>\n\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/if_arp.h>\n#include <linux/ioport.h>\n#include <linux/pci.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n\n#include <crypto/aes.h>\n#include <crypto/skcipher.h>\n\n#include <net/cfg80211.h>\n#include <net/iw_handler.h>\n\n#include \"airo.h\"\n\n#define DRV_NAME \"airo\"\n\n#ifdef CONFIG_PCI\nstatic const struct pci_device_id card_ids[] = {\n\t{ 0x14b9, 1, PCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0x14b9, 0x4500, PCI_ANY_ID, PCI_ANY_ID },\n\t{ 0x14b9, 0x4800, PCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0x14b9, 0x0340, PCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0x14b9, 0x0350, PCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0x14b9, 0x5000, PCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0x14b9, 0xa504, PCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, card_ids);\n\nstatic int airo_pci_probe(struct pci_dev *, const struct pci_device_id *);\nstatic void airo_pci_remove(struct pci_dev *);\nstatic int __maybe_unused airo_pci_suspend(struct device *dev);\nstatic int __maybe_unused airo_pci_resume(struct device *dev);\n\nstatic SIMPLE_DEV_PM_OPS(airo_pci_pm_ops,\n\t\t\t airo_pci_suspend,\n\t\t\t airo_pci_resume);\n\nstatic struct pci_driver airo_driver = {\n\t.name      = DRV_NAME,\n\t.id_table  = card_ids,\n\t.probe     = airo_pci_probe,\n\t.remove    = airo_pci_remove,\n\t.driver.pm = &airo_pci_pm_ops,\n};\n#endif  \n\n \n#include <linux/wireless.h>\n#define WIRELESS_SPY\t\t \n\n#define CISCO_EXT\t\t \n#ifdef CISCO_EXT\n#include <linux/delay.h>\n#endif\n\n \n#define POWER_ON_DOWN\n\n \n\n#define IGNLABEL(comment) NULL\nstatic const char *statsLabels[] = {\n\t\"RxOverrun\",\n\tIGNLABEL(\"RxPlcpCrcErr\"),\n\tIGNLABEL(\"RxPlcpFormatErr\"),\n\tIGNLABEL(\"RxPlcpLengthErr\"),\n\t\"RxMacCrcErr\",\n\t\"RxMacCrcOk\",\n\t\"RxWepErr\",\n\t\"RxWepOk\",\n\t\"RetryLong\",\n\t\"RetryShort\",\n\t\"MaxRetries\",\n\t\"NoAck\",\n\t\"NoCts\",\n\t\"RxAck\",\n\t\"RxCts\",\n\t\"TxAck\",\n\t\"TxRts\",\n\t\"TxCts\",\n\t\"TxMc\",\n\t\"TxBc\",\n\t\"TxUcFrags\",\n\t\"TxUcPackets\",\n\t\"TxBeacon\",\n\t\"RxBeacon\",\n\t\"TxSinColl\",\n\t\"TxMulColl\",\n\t\"DefersNo\",\n\t\"DefersProt\",\n\t\"DefersEngy\",\n\t\"DupFram\",\n\t\"RxFragDisc\",\n\t\"TxAged\",\n\t\"RxAged\",\n\t\"LostSync-MaxRetry\",\n\t\"LostSync-MissedBeacons\",\n\t\"LostSync-ArlExceeded\",\n\t\"LostSync-Deauth\",\n\t\"LostSync-Disassoced\",\n\t\"LostSync-TsfTiming\",\n\t\"HostTxMc\",\n\t\"HostTxBc\",\n\t\"HostTxUc\",\n\t\"HostTxFail\",\n\t\"HostRxMc\",\n\t\"HostRxBc\",\n\t\"HostRxUc\",\n\t\"HostRxDiscard\",\n\tIGNLABEL(\"HmacTxMc\"),\n\tIGNLABEL(\"HmacTxBc\"),\n\tIGNLABEL(\"HmacTxUc\"),\n\tIGNLABEL(\"HmacTxFail\"),\n\tIGNLABEL(\"HmacRxMc\"),\n\tIGNLABEL(\"HmacRxBc\"),\n\tIGNLABEL(\"HmacRxUc\"),\n\tIGNLABEL(\"HmacRxDiscard\"),\n\tIGNLABEL(\"HmacRxAccepted\"),\n\t\"SsidMismatch\",\n\t\"ApMismatch\",\n\t\"RatesMismatch\",\n\t\"AuthReject\",\n\t\"AuthTimeout\",\n\t\"AssocReject\",\n\t\"AssocTimeout\",\n\tIGNLABEL(\"ReasonOutsideTable\"),\n\tIGNLABEL(\"ReasonStatus1\"),\n\tIGNLABEL(\"ReasonStatus2\"),\n\tIGNLABEL(\"ReasonStatus3\"),\n\tIGNLABEL(\"ReasonStatus4\"),\n\tIGNLABEL(\"ReasonStatus5\"),\n\tIGNLABEL(\"ReasonStatus6\"),\n\tIGNLABEL(\"ReasonStatus7\"),\n\tIGNLABEL(\"ReasonStatus8\"),\n\tIGNLABEL(\"ReasonStatus9\"),\n\tIGNLABEL(\"ReasonStatus10\"),\n\tIGNLABEL(\"ReasonStatus11\"),\n\tIGNLABEL(\"ReasonStatus12\"),\n\tIGNLABEL(\"ReasonStatus13\"),\n\tIGNLABEL(\"ReasonStatus14\"),\n\tIGNLABEL(\"ReasonStatus15\"),\n\tIGNLABEL(\"ReasonStatus16\"),\n\tIGNLABEL(\"ReasonStatus17\"),\n\tIGNLABEL(\"ReasonStatus18\"),\n\tIGNLABEL(\"ReasonStatus19\"),\n\t\"RxMan\",\n\t\"TxMan\",\n\t\"RxRefresh\",\n\t\"TxRefresh\",\n\t\"RxPoll\",\n\t\"TxPoll\",\n\t\"HostRetries\",\n\t\"LostSync-HostReq\",\n\t\"HostTxBytes\",\n\t\"HostRxBytes\",\n\t\"ElapsedUsec\",\n\t\"ElapsedSec\",\n\t\"LostSyncBetterAP\",\n\t\"PrivacyMismatch\",\n\t\"Jammed\",\n\t\"DiscRxNotWepped\",\n\t\"PhyEleMismatch\",\n\t(char*)-1 };\n#ifndef RUN_AT\n#define RUN_AT(x) (jiffies+(x))\n#endif\n\n\n \n\nstatic int rates[8];\nstatic char *ssids[3];\n\nstatic int io[4];\nstatic int irq[4];\n\nstatic\nint maxencrypt  ;  \n\nstatic int auto_wep  ;  \nstatic int aux_bap  ;  \nstatic int adhoc;\n\nstatic int probe = 1;\n\nstatic kuid_t proc_kuid;\nstatic int proc_uid  ;\n\nstatic kgid_t proc_kgid;\nstatic int proc_gid  ;\n\nstatic int airo_perm = 0555;\n\nstatic int proc_perm = 0644;\n\nMODULE_AUTHOR(\"Benjamin Reed\");\nMODULE_DESCRIPTION(\"Support for Cisco/Aironet 802.11 wireless ethernet cards.  \"\n\t\t   \"Direct support for ISA/PCI/MPI cards and support for PCMCIA when used with airo_cs.\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nmodule_param_hw_array(io, int, ioport, NULL, 0);\nmodule_param_hw_array(irq, int, irq, NULL, 0);\nmodule_param_array(rates, int, NULL, 0);\nmodule_param_array(ssids, charp, NULL, 0);\nmodule_param(auto_wep, int, 0);\nMODULE_PARM_DESC(auto_wep,\n\t\t \"If non-zero, the driver will keep looping through the authentication options until an association is made.  \"\n\t\t \"The value of auto_wep is number of the wep keys to check.  \"\n\t\t \"A value of 2 will try using the key at index 0 and index 1.\");\nmodule_param(aux_bap, int, 0);\nMODULE_PARM_DESC(aux_bap,\n\t\t \"If non-zero, the driver will switch into a mode that seems to work better for older cards with some older buses.  \"\n\t\t \"Before switching it checks that the switch is needed.\");\nmodule_param(maxencrypt, int, 0);\nMODULE_PARM_DESC(maxencrypt,\n\t\t \"The maximum speed that the card can do encryption.  \"\n\t\t \"Units are in 512kbs.  \"\n\t\t \"Zero (default) means there is no limit.  \"\n\t\t \"Older cards used to be limited to 2mbs (4).\");\nmodule_param(adhoc, int, 0);\nMODULE_PARM_DESC(adhoc, \"If non-zero, the card will start in adhoc mode.\");\nmodule_param(probe, int, 0);\nMODULE_PARM_DESC(probe, \"If zero, the driver won't start the card.\");\n\nmodule_param(proc_uid, int, 0);\nMODULE_PARM_DESC(proc_uid, \"The uid that the /proc files will belong to.\");\nmodule_param(proc_gid, int, 0);\nMODULE_PARM_DESC(proc_gid, \"The gid that the /proc files will belong to.\");\nmodule_param(airo_perm, int, 0);\nMODULE_PARM_DESC(airo_perm, \"The permission bits of /proc/[driver/]aironet.\");\nmodule_param(proc_perm, int, 0);\nMODULE_PARM_DESC(proc_perm, \"The permission bits of the files in /proc\");\n\n \nstatic int do8bitIO  ;\n\n \n#define SUCCESS 0\n#define ERROR -1\n#define NO_PACKET -2\n\n \n#define NOP2\t\t0x0000\n#define MAC_ENABLE\t0x0001\n#define MAC_DISABLE\t0x0002\n#define CMD_LOSE_SYNC\t0x0003  \n#define CMD_SOFTRESET\t0x0004\n#define HOSTSLEEP\t0x0005\n#define CMD_MAGIC_PKT\t0x0006\n#define CMD_SETWAKEMASK\t0x0007\n#define CMD_READCFG\t0x0008\n#define CMD_SETMODE\t0x0009\n#define CMD_ALLOCATETX\t0x000a\n#define CMD_TRANSMIT\t0x000b\n#define CMD_DEALLOCATETX 0x000c\n#define NOP\t\t0x0010\n#define CMD_WORKAROUND\t0x0011\n#define CMD_ALLOCATEAUX 0x0020\n#define CMD_ACCESS\t0x0021\n#define CMD_PCIBAP\t0x0022\n#define CMD_PCIAUX\t0x0023\n#define CMD_ALLOCBUF\t0x0028\n#define CMD_GETTLV\t0x0029\n#define CMD_PUTTLV\t0x002a\n#define CMD_DELTLV\t0x002b\n#define CMD_FINDNEXTTLV\t0x002c\n#define CMD_PSPNODES\t0x0030\n#define CMD_SETCW\t0x0031\n#define CMD_SETPCF\t0x0032\n#define CMD_SETPHYREG\t0x003e\n#define CMD_TXTEST\t0x003f\n#define MAC_ENABLETX\t0x0101\n#define CMD_LISTBSS\t0x0103\n#define CMD_SAVECFG\t0x0108\n#define CMD_ENABLEAUX\t0x0111\n#define CMD_WRITERID\t0x0121\n#define CMD_USEPSPNODES\t0x0130\n#define MAC_ENABLERX\t0x0201\n\n \n#define ERROR_QUALIF 0x00\n#define ERROR_ILLCMD 0x01\n#define ERROR_ILLFMT 0x02\n#define ERROR_INVFID 0x03\n#define ERROR_INVRID 0x04\n#define ERROR_LARGE 0x05\n#define ERROR_NDISABL 0x06\n#define ERROR_ALLOCBSY 0x07\n#define ERROR_NORD 0x0B\n#define ERROR_NOWR 0x0C\n#define ERROR_INVFIDTX 0x0D\n#define ERROR_TESTACT 0x0E\n#define ERROR_TAGNFND 0x12\n#define ERROR_DECODE 0x20\n#define ERROR_DESCUNAV 0x21\n#define ERROR_BADLEN 0x22\n#define ERROR_MODE 0x80\n#define ERROR_HOP 0x81\n#define ERROR_BINTER 0x82\n#define ERROR_RXMODE 0x83\n#define ERROR_MACADDR 0x84\n#define ERROR_RATES 0x85\n#define ERROR_ORDER 0x86\n#define ERROR_SCAN 0x87\n#define ERROR_AUTH 0x88\n#define ERROR_PSMODE 0x89\n#define ERROR_RTYPE 0x8A\n#define ERROR_DIVER 0x8B\n#define ERROR_SSID 0x8C\n#define ERROR_APLIST 0x8D\n#define ERROR_AUTOWAKE 0x8E\n#define ERROR_LEAP 0x8F\n\n \n#define COMMAND 0x00\n#define PARAM0 0x02\n#define PARAM1 0x04\n#define PARAM2 0x06\n#define STATUS 0x08\n#define RESP0 0x0a\n#define RESP1 0x0c\n#define RESP2 0x0e\n#define LINKSTAT 0x10\n#define SELECT0 0x18\n#define OFFSET0 0x1c\n#define RXFID 0x20\n#define TXALLOCFID 0x22\n#define TXCOMPLFID 0x24\n#define DATA0 0x36\n#define EVSTAT 0x30\n#define EVINTEN 0x32\n#define EVACK 0x34\n#define SWS0 0x28\n#define SWS1 0x2a\n#define SWS2 0x2c\n#define SWS3 0x2e\n#define AUXPAGE 0x3A\n#define AUXOFF 0x3C\n#define AUXDATA 0x3E\n\n#define FID_TX 1\n#define FID_RX 2\n \n#define AUX_OFFSET 0x800\n \n#define PKTSIZE 1840\n#define RIDSIZE 2048\n \n#define MAXTXQ 64\n\n \n#define BAP0 0  \n#define BAP1 2  \n\n \n#define COMMAND_BUSY 0x8000\n\n#define BAP_BUSY 0x8000\n#define BAP_ERR 0x4000\n#define BAP_DONE 0x2000\n\n#define PROMISC 0xffff\n#define NOPROMISC 0x0000\n\n#define EV_CMD 0x10\n#define EV_CLEARCOMMANDBUSY 0x4000\n#define EV_RX 0x01\n#define EV_TX 0x02\n#define EV_TXEXC 0x04\n#define EV_ALLOC 0x08\n#define EV_LINK 0x80\n#define EV_AWAKE 0x100\n#define EV_TXCPY 0x400\n#define EV_UNKNOWN 0x800\n#define EV_MIC 0x1000  \n#define EV_AWAKEN 0x2000\n#define STATUS_INTS (EV_AWAKE|EV_LINK|EV_TXEXC|EV_TX|EV_TXCPY|EV_RX|EV_MIC)\n\n#ifdef CHECK_UNKNOWN_INTS\n#define IGNORE_INTS (EV_CMD | EV_UNKNOWN)\n#else\n#define IGNORE_INTS (~STATUS_INTS)\n#endif\n\n \n#define RID_RW 0x20\n\n \n#define RID_CAPABILITIES 0xFF00\n#define RID_APINFO     0xFF01\n#define RID_RADIOINFO  0xFF02\n#define RID_UNKNOWN3   0xFF03\n#define RID_RSSI       0xFF04\n#define RID_CONFIG     0xFF10\n#define RID_SSID       0xFF11\n#define RID_APLIST     0xFF12\n#define RID_DRVNAME    0xFF13\n#define RID_ETHERENCAP 0xFF14\n#define RID_WEP_TEMP   0xFF15\n#define RID_WEP_PERM   0xFF16\n#define RID_MODULATION 0xFF17\n#define RID_OPTIONS    0xFF18\n#define RID_ACTUALCONFIG 0xFF20  \n#define RID_FACTORYCONFIG 0xFF21\n#define RID_UNKNOWN22  0xFF22\n#define RID_LEAPUSERNAME 0xFF23\n#define RID_LEAPPASSWORD 0xFF24\n#define RID_STATUS     0xFF50\n#define RID_BEACON_HST 0xFF51\n#define RID_BUSY_HST   0xFF52\n#define RID_RETRIES_HST 0xFF53\n#define RID_UNKNOWN54  0xFF54\n#define RID_UNKNOWN55  0xFF55\n#define RID_UNKNOWN56  0xFF56\n#define RID_MIC        0xFF57\n#define RID_STATS16    0xFF60\n#define RID_STATS16DELTA 0xFF61\n#define RID_STATS16DELTACLEAR 0xFF62\n#define RID_STATS      0xFF68\n#define RID_STATSDELTA 0xFF69\n#define RID_STATSDELTACLEAR 0xFF6A\n#define RID_ECHOTEST_RID 0xFF70\n#define RID_ECHOTEST_RESULTS 0xFF71\n#define RID_BSSLISTFIRST 0xFF72\n#define RID_BSSLISTNEXT  0xFF73\n#define RID_WPA_BSSLISTFIRST 0xFF74\n#define RID_WPA_BSSLISTNEXT  0xFF75\n\ntypedef struct {\n\tu16 cmd;\n\tu16 parm0;\n\tu16 parm1;\n\tu16 parm2;\n} Cmd;\n\ntypedef struct {\n\tu16 status;\n\tu16 rsp0;\n\tu16 rsp1;\n\tu16 rsp2;\n} Resp;\n\n \n\n \ntypedef struct WepKeyRid WepKeyRid;\nstruct WepKeyRid {\n\t__le16 len;\n\t__le16 kindex;\n\tu8 mac[ETH_ALEN];\n\t__le16 klen;\n\tu8 key[16];\n} __packed;\n\n \ntypedef struct Ssid Ssid;\nstruct Ssid {\n\t__le16 len;\n\tu8 ssid[32];\n} __packed;\n\ntypedef struct SsidRid SsidRid;\nstruct SsidRid {\n\t__le16 len;\n\tSsid ssids[3];\n} __packed;\n\ntypedef struct ModulationRid ModulationRid;\nstruct ModulationRid {\n        __le16 len;\n        __le16 modulation;\n#define MOD_DEFAULT cpu_to_le16(0)\n#define MOD_CCK cpu_to_le16(1)\n#define MOD_MOK cpu_to_le16(2)\n} __packed;\n\ntypedef struct ConfigRid ConfigRid;\nstruct ConfigRid {\n\t__le16 len;  \n\t__le16 opmode;  \n#define MODE_STA_IBSS cpu_to_le16(0)\n#define MODE_STA_ESS cpu_to_le16(1)\n#define MODE_AP cpu_to_le16(2)\n#define MODE_AP_RPTR cpu_to_le16(3)\n#define MODE_CFG_MASK cpu_to_le16(0xff)\n#define MODE_ETHERNET_HOST cpu_to_le16(0<<8)  \n#define MODE_LLC_HOST cpu_to_le16(1<<8)  \n#define MODE_AIRONET_EXTEND cpu_to_le16(1<<9)  \n#define MODE_AP_INTERFACE cpu_to_le16(1<<10)  \n#define MODE_ANTENNA_ALIGN cpu_to_le16(1<<11)  \n#define MODE_ETHER_LLC cpu_to_le16(1<<12)  \n#define MODE_LEAF_NODE cpu_to_le16(1<<13)  \n#define MODE_CF_POLLABLE cpu_to_le16(1<<14)  \n#define MODE_MIC cpu_to_le16(1<<15)  \n\t__le16 rmode;  \n#define RXMODE_BC_MC_ADDR cpu_to_le16(0)\n#define RXMODE_BC_ADDR cpu_to_le16(1)  \n#define RXMODE_ADDR cpu_to_le16(2)  \n#define RXMODE_RFMON cpu_to_le16(3)  \n#define RXMODE_RFMON_ANYBSS cpu_to_le16(4)\n#define RXMODE_LANMON cpu_to_le16(5)  \n#define RXMODE_MASK cpu_to_le16(255)\n#define RXMODE_DISABLE_802_3_HEADER cpu_to_le16(1<<8)  \n#define RXMODE_FULL_MASK (RXMODE_MASK | RXMODE_DISABLE_802_3_HEADER)\n#define RXMODE_NORMALIZED_RSSI cpu_to_le16(1<<9)  \n\t__le16 fragThresh;\n\t__le16 rtsThres;\n\tu8 macAddr[ETH_ALEN];\n\tu8 rates[8];\n\t__le16 shortRetryLimit;\n\t__le16 longRetryLimit;\n\t__le16 txLifetime;  \n\t__le16 rxLifetime;  \n\t__le16 stationary;\n\t__le16 ordering;\n\t__le16 u16deviceType;  \n\t__le16 cfpRate;\n\t__le16 cfpDuration;\n\t__le16 _reserved1[3];\n\t \n\t__le16 scanMode;\n#define SCANMODE_ACTIVE cpu_to_le16(0)\n#define SCANMODE_PASSIVE cpu_to_le16(1)\n#define SCANMODE_AIROSCAN cpu_to_le16(2)\n\t__le16 probeDelay;  \n\t__le16 probeEnergyTimeout;  \n        __le16 probeResponseTimeout;\n\t__le16 beaconListenTimeout;\n\t__le16 joinNetTimeout;\n\t__le16 authTimeout;\n\t__le16 authType;\n#define AUTH_OPEN cpu_to_le16(0x1)\n#define AUTH_ENCRYPT cpu_to_le16(0x101)\n#define AUTH_SHAREDKEY cpu_to_le16(0x102)\n#define AUTH_ALLOW_UNENCRYPTED cpu_to_le16(0x200)\n\t__le16 associationTimeout;\n\t__le16 specifiedApTimeout;\n\t__le16 offlineScanInterval;\n\t__le16 offlineScanDuration;\n\t__le16 linkLossDelay;\n\t__le16 maxBeaconLostTime;\n\t__le16 refreshInterval;\n#define DISABLE_REFRESH cpu_to_le16(0xFFFF)\n\t__le16 _reserved1a[1];\n\t \n\t__le16 powerSaveMode;\n#define POWERSAVE_CAM cpu_to_le16(0)\n#define POWERSAVE_PSP cpu_to_le16(1)\n#define POWERSAVE_PSPCAM cpu_to_le16(2)\n\t__le16 sleepForDtims;\n\t__le16 listenInterval;\n\t__le16 fastListenInterval;\n\t__le16 listenDecay;\n\t__le16 fastListenDelay;\n\t__le16 _reserved2[2];\n\t \n\t__le16 beaconPeriod;\n\t__le16 atimDuration;\n\t__le16 hopPeriod;\n\t__le16 channelSet;\n\t__le16 channel;\n\t__le16 dtimPeriod;\n\t__le16 bridgeDistance;\n\t__le16 radioID;\n\t \n\t__le16 radioType;\n#define RADIOTYPE_DEFAULT cpu_to_le16(0)\n#define RADIOTYPE_802_11 cpu_to_le16(1)\n#define RADIOTYPE_LEGACY cpu_to_le16(2)\n\tu8 rxDiversity;\n\tu8 txDiversity;\n\t__le16 txPower;\n#define TXPOWER_DEFAULT 0\n\t__le16 rssiThreshold;\n#define RSSI_DEFAULT 0\n        __le16 modulation;\n#define PREAMBLE_AUTO cpu_to_le16(0)\n#define PREAMBLE_LONG cpu_to_le16(1)\n#define PREAMBLE_SHORT cpu_to_le16(2)\n\t__le16 preamble;\n\t__le16 homeProduct;\n\t__le16 radioSpecific;\n\t \n\tu8 nodeName[16];\n\t__le16 arlThreshold;\n\t__le16 arlDecay;\n\t__le16 arlDelay;\n\t__le16 _reserved4[1];\n\t \n\tu8 magicAction;\n#define MAGIC_ACTION_STSCHG 1\n#define MAGIC_ACTION_RESUME 2\n#define MAGIC_IGNORE_MCAST (1<<8)\n#define MAGIC_IGNORE_BCAST (1<<9)\n#define MAGIC_SWITCH_TO_PSP (0<<10)\n#define MAGIC_STAY_IN_CAM (1<<10)\n\tu8 magicControl;\n\t__le16 autoWake;\n} __packed;\n\ntypedef struct StatusRid StatusRid;\nstruct StatusRid {\n\t__le16 len;\n\tu8 mac[ETH_ALEN];\n\t__le16 mode;\n\t__le16 errorCode;\n\t__le16 sigQuality;\n\t__le16 SSIDlen;\n\tchar SSID[32];\n\tchar apName[16];\n\tu8 bssid[4][ETH_ALEN];\n\t__le16 beaconPeriod;\n\t__le16 dimPeriod;\n\t__le16 atimDuration;\n\t__le16 hopPeriod;\n\t__le16 channelSet;\n\t__le16 channel;\n\t__le16 hopsToBackbone;\n\t__le16 apTotalLoad;\n\t__le16 generatedLoad;\n\t__le16 accumulatedArl;\n\t__le16 signalQuality;\n\t__le16 currentXmitRate;\n\t__le16 apDevExtensions;\n\t__le16 normalizedSignalStrength;\n\t__le16 shortPreamble;\n\tu8 apIP[4];\n\tu8 noisePercent;  \n\tu8 noisedBm;  \n\tu8 noiseAvePercent;  \n\tu8 noiseAvedBm;  \n\tu8 noiseMaxPercent;  \n\tu8 noiseMaxdBm;  \n\t__le16 load;\n\tu8 carrier[4];\n\t__le16 assocStatus;\n#define STAT_NOPACKETS 0\n#define STAT_NOCARRIERSET 10\n#define STAT_GOTCARRIERSET 11\n#define STAT_WRONGSSID 20\n#define STAT_BADCHANNEL 25\n#define STAT_BADBITRATES 30\n#define STAT_BADPRIVACY 35\n#define STAT_APFOUND 40\n#define STAT_APREJECTED 50\n#define STAT_AUTHENTICATING 60\n#define STAT_DEAUTHENTICATED 61\n#define STAT_AUTHTIMEOUT 62\n#define STAT_ASSOCIATING 70\n#define STAT_DEASSOCIATED 71\n#define STAT_ASSOCTIMEOUT 72\n#define STAT_NOTAIROAP 73\n#define STAT_ASSOCIATED 80\n#define STAT_LEAPING 90\n#define STAT_LEAPFAILED 91\n#define STAT_LEAPTIMEDOUT 92\n#define STAT_LEAPCOMPLETE 93\n} __packed;\n\ntypedef struct StatsRid StatsRid;\nstruct StatsRid {\n\t__le16 len;\n\t__le16 spacer;\n\t__le32 vals[100];\n} __packed;\n\ntypedef struct APListRid APListRid;\nstruct APListRid {\n\t__le16 len;\n\tu8 ap[4][ETH_ALEN];\n} __packed;\n\ntypedef struct CapabilityRid CapabilityRid;\nstruct CapabilityRid {\n\t__le16 len;\n\tchar oui[3];\n\tchar zero;\n\t__le16 prodNum;\n\tchar manName[32];\n\tchar prodName[16];\n\tchar prodVer[8];\n\tchar factoryAddr[ETH_ALEN];\n\tchar aironetAddr[ETH_ALEN];\n\t__le16 radioType;\n\t__le16 country;\n\tchar callid[ETH_ALEN];\n\tchar supportedRates[8];\n\tchar rxDiversity;\n\tchar txDiversity;\n\t__le16 txPowerLevels[8];\n\t__le16 hardVer;\n\t__le16 hardCap;\n\t__le16 tempRange;\n\t__le16 softVer;\n\t__le16 softSubVer;\n\t__le16 interfaceVer;\n\t__le16 softCap;\n\t__le16 bootBlockVer;\n\t__le16 requiredHard;\n\t__le16 extSoftCap;\n} __packed;\n\n \ntypedef struct BSSListRidExtra BSSListRidExtra;\nstruct BSSListRidExtra {\n  __le16 unknown[4];\n  u8 fixed[12];  \n  u8 iep[624];\n} __packed;\n\ntypedef struct BSSListRid BSSListRid;\nstruct BSSListRid {\n  __le16 len;\n  __le16 index;  \n#define RADIO_FH 1  \n#define RADIO_DS 2  \n#define RADIO_TMA 4  \n  __le16 radioType;\n  u8 bssid[ETH_ALEN];  \n  u8 zero;\n  u8 ssidLen;\n  u8 ssid[32];\n  __le16 dBm;\n#define CAP_ESS cpu_to_le16(1<<0)\n#define CAP_IBSS cpu_to_le16(1<<1)\n#define CAP_PRIVACY cpu_to_le16(1<<4)\n#define CAP_SHORTHDR cpu_to_le16(1<<5)\n  __le16 cap;\n  __le16 beaconInterval;\n  u8 rates[8];  \n  struct {  \n    __le16 dwell;\n    u8 hopSet;\n    u8 hopPattern;\n    u8 hopIndex;\n    u8 fill;\n  } fh;\n  __le16 dsChannel;\n  __le16 atimWindow;\n\n   \n  BSSListRidExtra extra;\n} __packed;\n\ntypedef struct {\n  BSSListRid bss;\n  struct list_head list;\n} BSSListElement;\n\ntypedef struct tdsRssiEntry tdsRssiEntry;\nstruct tdsRssiEntry {\n  u8 rssipct;\n  u8 rssidBm;\n} __packed;\n\ntypedef struct tdsRssiRid tdsRssiRid;\nstruct tdsRssiRid {\n  u16 len;\n  tdsRssiEntry x[256];\n} __packed;\n\ntypedef struct MICRid MICRid;\nstruct MICRid {\n\t__le16 len;\n\t__le16 state;\n\t__le16 multicastValid;\n\tu8  multicast[16];\n\t__le16 unicastValid;\n\tu8  unicast[16];\n} __packed;\n\ntypedef struct MICBuffer MICBuffer;\nstruct MICBuffer {\n\t__be16 typelen;\n\n\tunion {\n\t    u8 snap[8];\n\t    struct {\n\t\tu8 dsap;\n\t\tu8 ssap;\n\t\tu8 control;\n\t\tu8 orgcode[3];\n\t\tu8 fieldtype[2];\n\t    } llc;\n\t} u;\n\t__be32 mic;\n\t__be32 seq;\n} __packed;\n\ntypedef struct {\n\tu8 da[ETH_ALEN];\n\tu8 sa[ETH_ALEN];\n} etherHead;\n\n#define TXCTL_TXOK (1<<1)  \n#define TXCTL_TXEX (1<<2)  \n#define TXCTL_802_3 (0<<3)  \n#define TXCTL_802_11 (1<<3)  \n#define TXCTL_ETHERNET (0<<4)  \n#define TXCTL_LLC (1<<4)  \n#define TXCTL_RELEASE (0<<5)  \n#define TXCTL_NORELEASE (1<<5)  \n\n#define BUSY_FID 0x10000\n\n#ifdef CISCO_EXT\n#define AIROMAGIC\t0xa55a\n \n#ifdef SIOCIWFIRSTPRIV\n#ifdef SIOCDEVPRIVATE\n#define AIROOLDIOCTL\tSIOCDEVPRIVATE\n#define AIROOLDIDIFC \tAIROOLDIOCTL + 1\n#endif  \n#else  \n#define SIOCIWFIRSTPRIV SIOCDEVPRIVATE\n#endif  \n \n#define AIROIOCTL\tSIOCIWFIRSTPRIV\n#define AIROIDIFC \tAIROIOCTL + 1\n\n \n\n#define\tAIROGCAP  \t\t0\t \n#define AIROGCFG\t\t1        \n#define AIROGSLIST\t\t2\t \n#define AIROGVLIST\t\t3        \n#define AIROGDRVNAM\t\t4\t \n#define AIROGEHTENC\t\t5\t \n#define AIROGWEPKTMP\t\t6\n#define AIROGWEPKNV\t\t7\n#define AIROGSTAT\t\t8\n#define AIROGSTATSC32\t\t9\n#define AIROGSTATSD32\t\t10\n#define AIROGMICRID\t\t11\n#define AIROGMICSTATS\t\t12\n#define AIROGFLAGS\t\t13\n#define AIROGID\t\t\t14\n#define AIRORRID\t\t15\n#define AIRORSWVERSION\t\t17\n\n \n\n#define AIROPCAP               \tAIROGSTATSD32 + 40\n#define AIROPVLIST              AIROPCAP      + 1\n#define AIROPSLIST\t\tAIROPVLIST    + 1\n#define AIROPCFG\t\tAIROPSLIST    + 1\n#define AIROPSIDS\t\tAIROPCFG      + 1\n#define AIROPAPLIST\t\tAIROPSIDS     + 1\n#define AIROPMACON\t\tAIROPAPLIST   + 1\t \n#define AIROPMACOFF\t\tAIROPMACON    + 1 \t \n#define AIROPSTCLR\t\tAIROPMACOFF   + 1\n#define AIROPWEPKEY\t\tAIROPSTCLR    + 1\n#define AIROPWEPKEYNV\t\tAIROPWEPKEY   + 1\n#define AIROPLEAPPWD            AIROPWEPKEYNV + 1\n#define AIROPLEAPUSR            AIROPLEAPPWD  + 1\n\n \n\n#define AIROFLSHRST\t       AIROPWEPKEYNV  + 40\n#define AIROFLSHGCHR           AIROFLSHRST    + 1\n#define AIROFLSHSTFL           AIROFLSHGCHR   + 1\n#define AIROFLSHPCHR           AIROFLSHSTFL   + 1\n#define AIROFLPUTBUF           AIROFLSHPCHR   + 1\n#define AIRORESTART            AIROFLPUTBUF   + 1\n\n#define FLASHSIZE\t32768\n#define AUXMEMSIZE\t(256 * 1024)\n\ntypedef struct aironet_ioctl {\n\tunsigned short command;\t\t \n\tunsigned short len;\t\t \n\tunsigned short ridnum;\t\t \n\tunsigned char __user *data;\t \n} aironet_ioctl;\n\nstatic const char swversion[] = \"2.1\";\n#endif  \n\n#define NUM_MODULES       2\n#define MIC_MSGLEN_MAX    2400\n#define EMMH32_MSGLEN_MAX MIC_MSGLEN_MAX\n#define AIRO_DEF_MTU      2312\n\ntypedef struct {\n\tu32   size;             \n\tu8    enabled;          \n\tu32   rxSuccess;        \n\tu32   rxIncorrectMIC;   \n\tu32   rxNotMICed;       \n\tu32   rxMICPlummed;     \n\tu32   rxWrongSequence;  \n\tu32   reserve[32];\n} mic_statistics;\n\ntypedef struct {\n\t__be32 coeff[((EMMH32_MSGLEN_MAX)+3)>>2];\n\tu64 accum;\t \n\tint position;\t \n\tunion {\n\t\tu8  d8[4];\n\t\t__be32 d32;\n\t} part;\t \n} emmh32_context;\n\ntypedef struct {\n\temmh32_context seed;\t     \n\tu32\t\t rx;\t     \n\tu32\t\t tx;\t     \n\tu32\t\t window;     \n\tu8\t\t valid;\t     \n\tu8\t\t key[16];\n} miccntx;\n\ntypedef struct {\n\tmiccntx mCtx;\t\t \n\tmiccntx uCtx;\t\t \n} mic_module;\n\ntypedef struct {\n\tunsigned int  rid: 16;\n\tunsigned int  len: 15;\n\tunsigned int  valid: 1;\n\tdma_addr_t host_addr;\n} Rid;\n\ntypedef struct {\n\tunsigned int  offset: 15;\n\tunsigned int  eoc: 1;\n\tunsigned int  len: 15;\n\tunsigned int  valid: 1;\n\tdma_addr_t host_addr;\n} TxFid;\n\nstruct rx_hdr {\n\t__le16 status, len;\n\tu8 rssi[2];\n\tu8 rate;\n\tu8 freq;\n\t__le16 tmp[4];\n} __packed;\n\ntypedef struct {\n\tunsigned int  ctl: 15;\n\tunsigned int  rdy: 1;\n\tunsigned int  len: 15;\n\tunsigned int  valid: 1;\n\tdma_addr_t host_addr;\n} RxFid;\n\n \ntypedef struct {\n\tunsigned char __iomem *card_ram_off;  \n\tRxFid         rx_desc;\t\t      \n\tchar          *virtual_host_addr;     \n\tint           pending;\n} HostRxDesc;\n\n \ntypedef struct {\n\tunsigned char __iomem *card_ram_off;\t      \n\tTxFid         tx_desc;\t\t      \n\tchar          *virtual_host_addr;     \n\tint           pending;\n} HostTxDesc;\n\n \ntypedef struct {\n\tunsigned char __iomem *card_ram_off;       \n\tRid           rid_desc;\t\t   \n\tchar          *virtual_host_addr;  \n} HostRidDesc;\n\ntypedef struct {\n\tu16 sw0;\n\tu16 sw1;\n\tu16 status;\n\tu16 len;\n#define HOST_SET (1 << 0)\n#define HOST_INT_TX (1 << 1)  \n#define HOST_INT_TXERR (1 << 2)  \n#define HOST_LCC_PAYLOAD (1 << 4)  \n#define HOST_DONT_RLSE (1 << 5)  \n#define HOST_DONT_RETRY (1 << 6)  \n#define HOST_CLR_AID (1 << 7)  \n#define HOST_RTS (1 << 9)  \n#define HOST_SHORT (1 << 10)  \n\tu16 ctl;\n\tu16 aid;\n\tu16 retries;\n\tu16 fill;\n} TxCtlHdr;\n\ntypedef struct {\n        u16 ctl;\n        u16 duration;\n        char addr1[6];\n        char addr2[6];\n        char addr3[6];\n        u16 seq;\n        char addr4[6];\n} WifiHdr;\n\n\ntypedef struct {\n\tTxCtlHdr ctlhdr;\n\tu16 fill1;\n\tu16 fill2;\n\tWifiHdr wifihdr;\n\tu16 gaplen;\n\tu16 status;\n} WifiCtlHdr;\n\nstatic WifiCtlHdr wifictlhdr8023 = {\n\t.ctlhdr = {\n\t\t.ctl\t= HOST_DONT_RLSE,\n\t}\n};\n\n \n#define MAX_KEY_SIZE 13\t\t\t \n#define MIN_KEY_SIZE  5\t\t\t \ntypedef struct wep_key_t {\n\tu16\tlen;\n\tu8\tkey[16];\t \n} wep_key_t;\n\n \nstatic const struct iw_handler_def\tairo_handler_def;\n\nstatic const char version[] = \"airo.c 0.6 (Ben Reed & Javier Achirica)\";\n\nstruct airo_info;\n\nstatic int get_dec_u16(char *buffer, int *start, int limit);\nstatic void OUT4500(struct airo_info *, u16 reg, u16 value);\nstatic unsigned short IN4500(struct airo_info *, u16 reg);\nstatic u16 setup_card(struct airo_info*, struct net_device *dev, int lock);\nstatic int enable_MAC(struct airo_info *ai, int lock);\nstatic void disable_MAC(struct airo_info *ai, int lock);\nstatic void enable_interrupts(struct airo_info*);\nstatic void disable_interrupts(struct airo_info*);\nstatic u16 issuecommand(struct airo_info*, Cmd *pCmd, Resp *pRsp,\n\t\t\tbool may_sleep);\nstatic int bap_setup(struct airo_info*, u16 rid, u16 offset, int whichbap);\nstatic int aux_bap_read(struct airo_info*, __le16 *pu16Dst, int bytelen,\n\t\t\tint whichbap);\nstatic int fast_bap_read(struct airo_info*, __le16 *pu16Dst, int bytelen,\n\t\t\t int whichbap);\nstatic int bap_write(struct airo_info*, const __le16 *pu16Src, int bytelen,\n\t\t     int whichbap);\nstatic int PC4500_accessrid(struct airo_info*, u16 rid, u16 accmd);\nstatic int PC4500_readrid(struct airo_info*, u16 rid, void *pBuf, int len, int lock);\nstatic int PC4500_writerid(struct airo_info*, u16 rid, const void\n\t\t\t   *pBuf, int len, int lock);\nstatic int do_writerid(struct airo_info*, u16 rid, const void *rid_data,\n\t\t\tint len, int dummy);\nstatic u16 transmit_allocate(struct airo_info*, int lenPayload, int raw);\nstatic int transmit_802_3_packet(struct airo_info*, int len, char *pPacket,\n\t\t\t\t bool may_sleep);\nstatic int transmit_802_11_packet(struct airo_info*, int len, char *pPacket,\n\t\t\t\t  bool may_sleep);\n\nstatic int mpi_send_packet(struct net_device *dev);\nstatic void mpi_unmap_card(struct pci_dev *pci);\nstatic void mpi_receive_802_3(struct airo_info *ai);\nstatic void mpi_receive_802_11(struct airo_info *ai);\nstatic int waitbusy(struct airo_info *ai);\n\nstatic irqreturn_t airo_interrupt(int irq, void* dev_id);\nstatic int airo_thread(void *data);\nstatic void timer_func(struct net_device *dev);\nstatic int airo_siocdevprivate(struct net_device *dev, struct ifreq *rq, void __user *, int cmd);\nstatic struct iw_statistics *airo_get_wireless_stats(struct net_device *dev);\n#ifdef CISCO_EXT\nstatic int readrids(struct net_device *dev, aironet_ioctl *comp);\nstatic int writerids(struct net_device *dev, aironet_ioctl *comp);\nstatic int flashcard(struct net_device *dev, aironet_ioctl *comp);\n#endif  \nstatic void micinit(struct airo_info *ai);\nstatic int micsetup(struct airo_info *ai);\nstatic int encapsulate(struct airo_info *ai, etherHead *pPacket, MICBuffer *buffer, int len);\nstatic int decapsulate(struct airo_info *ai, MICBuffer *mic, etherHead *pPacket, u16 payLen);\n\nstatic u8 airo_rssi_to_dbm(tdsRssiEntry *rssi_rid, u8 rssi);\nstatic u8 airo_dbm_to_pct(tdsRssiEntry *rssi_rid, u8 dbm);\n\nstatic void airo_networks_free(struct airo_info *ai);\n\nstruct airo_info {\n\tstruct net_device             *dev;\n\tstruct list_head              dev_list;\n\t \n#define MAX_FIDS 6\n#define MPI_MAX_FIDS 1\n\tu32                           fids[MAX_FIDS];\n\tConfigRid config;\n\tchar keyindex; \n\tchar defindex; \n\tstruct proc_dir_entry *proc_entry;\n        spinlock_t aux_lock;\n#define FLAG_RADIO_OFF\t0\t \n#define FLAG_RADIO_DOWN\t1\t \n#define FLAG_RADIO_MASK 0x03\n#define FLAG_ENABLED\t2\n#define FLAG_ADHOC\t3\t \n#define FLAG_MIC_CAPABLE 4\n#define FLAG_UPDATE_MULTI 5\n#define FLAG_UPDATE_UNI 6\n#define FLAG_802_11\t7\n#define FLAG_PROMISC\t8\t \n#define FLAG_PENDING_XMIT 9\n#define FLAG_PENDING_XMIT11 10\n#define FLAG_MPI\t11\n#define FLAG_REGISTERED\t12\n#define FLAG_COMMIT\t13\n#define FLAG_RESET\t14\n#define FLAG_FLASHING\t15\n#define FLAG_WPA_CAPABLE\t16\n\tunsigned long flags;\n#define JOB_DIE\t0\n#define JOB_XMIT\t1\n#define JOB_XMIT11\t2\n#define JOB_STATS\t3\n#define JOB_PROMISC\t4\n#define JOB_MIC\t5\n#define JOB_EVENT\t6\n#define JOB_AUTOWEP\t7\n#define JOB_SCAN_RESULTS  9\n\tunsigned long jobs;\n\tint (*bap_read)(struct airo_info*, __le16 *pu16Dst, int bytelen,\n\t\t\tint whichbap);\n\tunsigned short *flash;\n\ttdsRssiEntry *rssi;\n\tstruct task_struct *list_bss_task;\n\tstruct task_struct *airo_thread_task;\n\tstruct semaphore sem;\n\twait_queue_head_t thr_wait;\n\tunsigned long expires;\n\tstruct {\n\t\tstruct sk_buff *skb;\n\t\tint fid;\n\t} xmit, xmit11;\n\tstruct net_device *wifidev;\n\tstruct iw_statistics\twstats;\t\t\n\tunsigned long\t\tscan_timeout;\t \n\tstruct iw_spy_data\tspy_data;\n\tstruct iw_public_data\twireless_data;\n\t \n\tstruct crypto_sync_skcipher\t*tfm;\n\tmic_module\t\tmod[2];\n\tmic_statistics\t\tmicstats;\n\tHostRxDesc rxfids[MPI_MAX_FIDS]; \n\tHostTxDesc txfids[MPI_MAX_FIDS];\n\tHostRidDesc config_desc;\n\tunsigned long ridbus; \n\tstruct sk_buff_head txq;\n\tstruct pci_dev          *pci;\n\tunsigned char\t\t__iomem *pcimem;\n\tunsigned char\t\t__iomem *pciaux;\n\tunsigned char\t\t*shared;\n\tdma_addr_t\t\tshared_dma;\n\tpm_message_t\t\tpower;\n\tSsidRid\t\t\t*SSID;\n\tAPListRid\t\tAPList;\n#define\tPCI_SHARED_LEN\t\t2*MPI_MAX_FIDS*PKTSIZE+RIDSIZE\n\tchar\t\t\tproc_name[IFNAMSIZ];\n\n\tint\t\t\twep_capable;\n\tint\t\t\tmax_wep_idx;\n\tint\t\t\tlast_auth;\n\n\t \n\tunsigned int bssListFirst;\n\tunsigned int bssListNext;\n\tunsigned int bssListRidLen;\n\n\tstruct list_head network_list;\n\tstruct list_head network_free_list;\n\tBSSListElement *networks;\n};\n\nstatic inline int bap_read(struct airo_info *ai, __le16 *pu16Dst, int bytelen,\n\t\t\t   int whichbap)\n{\n\treturn ai->bap_read(ai, pu16Dst, bytelen, whichbap);\n}\n\nstatic int setup_proc_entry(struct net_device *dev,\n\t\t\t     struct airo_info *apriv);\nstatic int takedown_proc_entry(struct net_device *dev,\n\t\t\t\tstruct airo_info *apriv);\n\nstatic int cmdreset(struct airo_info *ai);\nstatic int setflashmode(struct airo_info *ai);\nstatic int flashgchar(struct airo_info *ai, int matchbyte, int dwelltime);\nstatic int flashputbuf(struct airo_info *ai);\nstatic int flashrestart(struct airo_info *ai, struct net_device *dev);\n\n#define airo_print(type, name, fmt, args...) \\\n\tprintk(type DRV_NAME \"(%s): \" fmt \"\\n\", name, ##args)\n\n#define airo_print_info(name, fmt, args...) \\\n\tairo_print(KERN_INFO, name, fmt, ##args)\n\n#define airo_print_dbg(name, fmt, args...) \\\n\tairo_print(KERN_DEBUG, name, fmt, ##args)\n\n#define airo_print_warn(name, fmt, args...) \\\n\tairo_print(KERN_WARNING, name, fmt, ##args)\n\n#define airo_print_err(name, fmt, args...) \\\n\tairo_print(KERN_ERR, name, fmt, ##args)\n\n#define AIRO_FLASH(dev) (((struct airo_info *)dev->ml_priv)->flash)\n\n \n\nstatic int RxSeqValid(struct airo_info *ai, miccntx *context, int mcast, u32 micSeq);\nstatic void MoveWindow(miccntx *context, u32 micSeq);\nstatic void emmh32_setseed(emmh32_context *context, u8 *pkey, int keylen,\n\t\t\t   struct crypto_sync_skcipher *tfm);\nstatic void emmh32_init(emmh32_context *context);\nstatic void emmh32_update(emmh32_context *context, u8 *pOctets, int len);\nstatic void emmh32_final(emmh32_context *context, u8 digest[4]);\nstatic int flashpchar(struct airo_info *ai, int byte, int dwelltime);\n\nstatic void age_mic_context(miccntx *cur, miccntx *old, u8 *key, int key_len,\n\t\t\t    struct crypto_sync_skcipher *tfm)\n{\n\t \n\tif (cur->valid && (memcmp(cur->key, key, key_len) == 0))\n\t\treturn;\n\n\t \n\tmemcpy(old, cur, sizeof(*cur));\n\n\t \n\tmemcpy(cur->key, key, key_len);\n\tcur->window  = 33;  \n\tcur->rx      = 0;   \n\tcur->tx      = 0;   \n\tcur->valid   = 1;   \n\n\t \n\temmh32_setseed(&cur->seed, key, key_len, tfm);\n}\n\n \n\nstatic void micinit(struct airo_info *ai)\n{\n\tMICRid mic_rid;\n\n\tclear_bit(JOB_MIC, &ai->jobs);\n\tPC4500_readrid(ai, RID_MIC, &mic_rid, sizeof(mic_rid), 0);\n\tup(&ai->sem);\n\n\tai->micstats.enabled = (le16_to_cpu(mic_rid.state) & 0x00FF) ? 1 : 0;\n\tif (!ai->micstats.enabled) {\n\t\t \n\t\tai->mod[0].uCtx.valid = 0;\n\t\tai->mod[0].mCtx.valid = 0;\n\t\treturn;\n\t}\n\n\tif (mic_rid.multicastValid) {\n\t\tage_mic_context(&ai->mod[0].mCtx, &ai->mod[1].mCtx,\n\t\t                mic_rid.multicast, sizeof(mic_rid.multicast),\n\t\t                ai->tfm);\n\t}\n\n\tif (mic_rid.unicastValid) {\n\t\tage_mic_context(&ai->mod[0].uCtx, &ai->mod[1].uCtx,\n\t\t\t\tmic_rid.unicast, sizeof(mic_rid.unicast),\n\t\t\t\tai->tfm);\n\t}\n}\n\n \n\nstatic int micsetup(struct airo_info *ai)\n{\n\tint i;\n\n\tif (ai->tfm == NULL)\n\t\tai->tfm = crypto_alloc_sync_skcipher(\"ctr(aes)\", 0, 0);\n\n        if (IS_ERR(ai->tfm)) {\n                airo_print_err(ai->dev->name, \"failed to load transform for AES\");\n                ai->tfm = NULL;\n                return ERROR;\n        }\n\n\tfor (i = 0; i < NUM_MODULES; i++) {\n\t\tmemset(&ai->mod[i].mCtx, 0, sizeof(miccntx));\n\t\tmemset(&ai->mod[i].uCtx, 0, sizeof(miccntx));\n\t}\n\treturn SUCCESS;\n}\n\nstatic const u8 micsnap[] = {0xAA, 0xAA, 0x03, 0x00, 0x40, 0x96, 0x00, 0x02};\n\n \n\nstatic int encapsulate(struct airo_info *ai, etherHead *frame, MICBuffer *mic, int payLen)\n{\n\tmiccntx   *context;\n\n\t\n\t\n\n\tif (test_bit(FLAG_ADHOC, &ai->flags) && (frame->da[0] & 0x1))\n\t\tcontext = &ai->mod[0].mCtx;\n\telse\n\t\tcontext = &ai->mod[0].uCtx;\n\n\tif (!context->valid)\n\t\treturn ERROR;\n\n\tmic->typelen = htons(payLen + 16); \n\n\tmemcpy(&mic->u.snap, micsnap, sizeof(micsnap)); \n\n\t\n\tmic->seq = htonl(context->tx);\n\tcontext->tx += 2;\n\n\temmh32_init(&context->seed); \n\temmh32_update(&context->seed, frame->da, ETH_ALEN * 2); \n\temmh32_update(&context->seed, (u8*)&mic->typelen, 10); \n\temmh32_update(&context->seed, (u8*)&mic->seq, sizeof(mic->seq)); \n\temmh32_update(&context->seed, (u8*)(frame + 1), payLen); \n\temmh32_final(&context->seed, (u8*)&mic->mic);\n\n\t \n\tmic->typelen = 0; \n\treturn SUCCESS;\n}\n\ntypedef enum {\n    NONE,\n    NOMIC,\n    NOMICPLUMMED,\n    SEQUENCE,\n    INCORRECTMIC,\n} mic_error;\n\n \n\nstatic int decapsulate(struct airo_info *ai, MICBuffer *mic, etherHead *eth, u16 payLen)\n{\n\tint      i;\n\tu32      micSEQ;\n\tmiccntx  *context;\n\tu8       digest[4];\n\tmic_error micError = NONE;\n\n\t \n\n\tif (!ai->micstats.enabled) {\n\t\t\n\t\tif (memcmp ((u8*)eth + 14, micsnap, sizeof(micsnap)) == 0) {\n\t\t\tai->micstats.rxMICPlummed++;\n\t\t\treturn ERROR;\n\t\t}\n\t\treturn SUCCESS;\n\t}\n\n\tif (ntohs(mic->typelen) == 0x888E)\n\t\treturn SUCCESS;\n\n\tif (memcmp (mic->u.snap, micsnap, sizeof(micsnap)) != 0) {\n\t    \n\t\tai->micstats.rxMICPlummed++;\n\t    \treturn ERROR;\n\t}\n\n\tmicSEQ = ntohl(mic->seq);            \n\n\t\n\t\n\n\t\n\tif ((micSEQ & 1) == 0) {\n\t\tai->micstats.rxWrongSequence++;\n\t\treturn ERROR;\n\t}\n\n\tfor (i = 0; i < NUM_MODULES; i++) {\n\t\tint mcast = eth->da[0] & 1;\n\t\t\n\t\tcontext = mcast ? &ai->mod[i].mCtx : &ai->mod[i].uCtx;\n\n\t\t\n\t\tif (!context->valid) {\n\t\t\tif (i == 0)\n\t\t\t\tmicError = NOMICPLUMMED;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\n\t\tif (!mic->typelen)\n\t\t\tmic->typelen = htons(payLen + sizeof(MICBuffer) - 2);\n\n\t\temmh32_init(&context->seed);\n\t\temmh32_update(&context->seed, eth->da, ETH_ALEN*2);\n\t\temmh32_update(&context->seed, (u8 *)&mic->typelen, sizeof(mic->typelen)+sizeof(mic->u.snap));\n\t\temmh32_update(&context->seed, (u8 *)&mic->seq, sizeof(mic->seq));\n\t\temmh32_update(&context->seed, (u8 *)(eth + 1), payLen);\n\t\t\n\t\temmh32_final(&context->seed, digest);\n\n\t\tif (memcmp(digest, &mic->mic, 4)) { \n\t\t  \n\t\t\tif (i == 0)\n\t\t\t\tmicError = INCORRECTMIC;\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (RxSeqValid(ai, context, mcast, micSEQ) == SUCCESS) {\n\t\t\tai->micstats.rxSuccess++;\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tif (i == 0)\n\t\t\tmicError = SEQUENCE;\n\t}\n\n\t\n\tswitch (micError) {\n\t\tcase NOMICPLUMMED: ai->micstats.rxMICPlummed++;   break;\n\t\tcase SEQUENCE:    ai->micstats.rxWrongSequence++; break;\n\t\tcase INCORRECTMIC: ai->micstats.rxIncorrectMIC++; break;\n\t\tcase NONE:  break;\n\t\tcase NOMIC: break;\n\t}\n\treturn ERROR;\n}\n\n \n\nstatic int RxSeqValid(struct airo_info *ai, miccntx *context, int mcast, u32 micSeq)\n{\n\tu32 seq, index;\n\n\t\n\t\n\n\tif (mcast) {\n\t\tif (test_bit(FLAG_UPDATE_MULTI, &ai->flags)) {\n\t\t\tclear_bit (FLAG_UPDATE_MULTI, &ai->flags);\n\t\t\tcontext->window = (micSeq > 33) ? micSeq : 33;\n\t\t\tcontext->rx     = 0;        \n\t\t}\n\t} else if (test_bit(FLAG_UPDATE_UNI, &ai->flags)) {\n\t\tclear_bit (FLAG_UPDATE_UNI, &ai->flags);\n\t\tcontext->window = (micSeq > 33) ? micSeq : 33; \n\t\tcontext->rx     = 0;        \n\t}\n\n\t\n\tseq = micSeq - (context->window - 33);\n\n\t\n\tif ((s32)seq < 0)\n\t\treturn ERROR;\n\n\tif (seq > 64) {\n\t\t\n\t\tMoveWindow(context, micSeq);\n\t\treturn SUCCESS;\n\t}\n\n\t\n\tseq >>= 1;         \n\tindex = 1 << seq;  \n\n\tif (!(context->rx & index)) {\n\t\t\n\t\t\n\t\tcontext->rx |= index;\n\n\t\tMoveWindow(context, micSeq);\n\n\t\treturn SUCCESS;\n\t}\n\treturn ERROR;\n}\n\nstatic void MoveWindow(miccntx *context, u32 micSeq)\n{\n\tu32 shift;\n\n\t\n\tif (micSeq > context->window) {\n\t\tshift = (micSeq - context->window) >> 1;\n\n\t\t    \n\t\tif (shift < 32)\n\t\t\tcontext->rx >>= shift;\n\t\telse\n\t\t\tcontext->rx = 0;\n\n\t\tcontext->window = micSeq;      \n\t}\n}\n\n \n \n \n\n \n#define MIC_ACCUM(val)\t\\\n\tcontext->accum += (u64)(val) * be32_to_cpu(context->coeff[coeff_position++]);\n\n \nstatic void emmh32_setseed(emmh32_context *context, u8 *pkey, int keylen,\n\t\t\t   struct crypto_sync_skcipher *tfm)\n{\n   \n   \n\n\tSYNC_SKCIPHER_REQUEST_ON_STACK(req, tfm);\n\tstruct scatterlist sg;\n\tu8 iv[AES_BLOCK_SIZE] = {};\n\tint ret;\n\n\tcrypto_sync_skcipher_setkey(tfm, pkey, 16);\n\n\tmemset(context->coeff, 0, sizeof(context->coeff));\n\tsg_init_one(&sg, context->coeff, sizeof(context->coeff));\n\n\tskcipher_request_set_sync_tfm(req, tfm);\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, &sg, &sg, sizeof(context->coeff), iv);\n\n\tret = crypto_skcipher_encrypt(req);\n\tWARN_ON_ONCE(ret);\n}\n\n \nstatic void emmh32_init(emmh32_context *context)\n{\n\t \n\tcontext->accum = 0;\n\tcontext->position = 0;\n}\n\n \nstatic void emmh32_update(emmh32_context *context, u8 *pOctets, int len)\n{\n\tint\tcoeff_position, byte_position;\n\n\tif (len == 0) return;\n\n\tcoeff_position = context->position >> 2;\n\n\t \n\tbyte_position = context->position & 3;\n\tif (byte_position) {\n\t\t \n\t\tdo {\n\t\t\tif (len == 0) return;\n\t\t\tcontext->part.d8[byte_position++] = *pOctets++;\n\t\t\tcontext->position++;\n\t\t\tlen--;\n\t\t} while (byte_position < 4);\n\t\tMIC_ACCUM(ntohl(context->part.d32));\n\t}\n\n\t \n\twhile (len >= 4) {\n\t\tMIC_ACCUM(ntohl(*(__be32 *)pOctets));\n\t\tcontext->position += 4;\n\t\tpOctets += 4;\n\t\tlen -= 4;\n\t}\n\n\t \n\tbyte_position = 0;\n\twhile (len > 0) {\n\t\tcontext->part.d8[byte_position++] = *pOctets++;\n\t\tcontext->position++;\n\t\tlen--;\n\t}\n}\n\n \nstatic u32 mask32[4] = { 0x00000000L, 0xFF000000L, 0xFFFF0000L, 0xFFFFFF00L };\n\n \nstatic void emmh32_final(emmh32_context *context, u8 digest[4])\n{\n\tint\tcoeff_position, byte_position;\n\tu32\tval;\n\n\tu64 sum, utmp;\n\ts64 stmp;\n\n\tcoeff_position = context->position >> 2;\n\n\t \n\tbyte_position = context->position & 3;\n\tif (byte_position) {\n\t\t \n\t\tval = ntohl(context->part.d32);\n\t\tMIC_ACCUM(val & mask32[byte_position]);\t \n\t}\n\n\t \n\tsum = context->accum;\n\tstmp = (sum  & 0xffffffffLL) - ((sum >> 32)  * 15);\n\tutmp = (stmp & 0xffffffffLL) - ((stmp >> 32) * 15);\n\tsum = utmp & 0xffffffffLL;\n\tif (utmp > 0x10000000fLL)\n\t\tsum -= 15;\n\n\tval = (u32)sum;\n\tdigest[0] = (val>>24) & 0xFF;\n\tdigest[1] = (val>>16) & 0xFF;\n\tdigest[2] = (val>>8) & 0xFF;\n\tdigest[3] = val & 0xFF;\n}\n\nstatic int readBSSListRid(struct airo_info *ai, int first,\n\t\t      BSSListRid *list)\n{\n\tCmd cmd;\n\tResp rsp;\n\n\tif (first == 1) {\n\t\tif (ai->flags & FLAG_RADIO_MASK) return -ENETDOWN;\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tcmd.cmd = CMD_LISTBSS;\n\t\tif (down_interruptible(&ai->sem))\n\t\t\treturn -ERESTARTSYS;\n\t\tai->list_bss_task = current;\n\t\tissuecommand(ai, &cmd, &rsp, true);\n\t\tup(&ai->sem);\n\t\t \n\t\tschedule_timeout_uninterruptible(3 * HZ);\n\t\tai->list_bss_task = NULL;\n\t}\n\treturn PC4500_readrid(ai, first ? ai->bssListFirst : ai->bssListNext,\n\t\t\t    list, ai->bssListRidLen, 1);\n}\n\nstatic int readWepKeyRid(struct airo_info *ai, WepKeyRid *wkr, int temp, int lock)\n{\n\treturn PC4500_readrid(ai, temp ? RID_WEP_TEMP : RID_WEP_PERM,\n\t\t\t\twkr, sizeof(*wkr), lock);\n}\n\nstatic int writeWepKeyRid(struct airo_info *ai, WepKeyRid *wkr, int perm, int lock)\n{\n\tint rc;\n\trc = PC4500_writerid(ai, RID_WEP_TEMP, wkr, sizeof(*wkr), lock);\n\tif (rc!=SUCCESS)\n\t\tairo_print_err(ai->dev->name, \"WEP_TEMP set %x\", rc);\n\tif (perm) {\n\t\trc = PC4500_writerid(ai, RID_WEP_PERM, wkr, sizeof(*wkr), lock);\n\t\tif (rc!=SUCCESS)\n\t\t\tairo_print_err(ai->dev->name, \"WEP_PERM set %x\", rc);\n\t}\n\treturn rc;\n}\n\nstatic int readSsidRid(struct airo_info*ai, SsidRid *ssidr)\n{\n\treturn PC4500_readrid(ai, RID_SSID, ssidr, sizeof(*ssidr), 1);\n}\n\nstatic int writeSsidRid(struct airo_info*ai, SsidRid *pssidr, int lock)\n{\n\treturn PC4500_writerid(ai, RID_SSID, pssidr, sizeof(*pssidr), lock);\n}\n\nstatic int readConfigRid(struct airo_info *ai, int lock)\n{\n\tint rc;\n\tConfigRid cfg;\n\n\tif (ai->config.len)\n\t\treturn SUCCESS;\n\n\trc = PC4500_readrid(ai, RID_ACTUALCONFIG, &cfg, sizeof(cfg), lock);\n\tif (rc != SUCCESS)\n\t\treturn rc;\n\n\tai->config = cfg;\n\treturn SUCCESS;\n}\n\nstatic inline void checkThrottle(struct airo_info *ai)\n{\n\tint i;\n \n\tif (ai->config.authType != AUTH_OPEN && maxencrypt) {\n\t\tfor (i = 0; i<8; i++) {\n\t\t\tif (ai->config.rates[i] > maxencrypt) {\n\t\t\t\tai->config.rates[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int writeConfigRid(struct airo_info *ai, int lock)\n{\n\tConfigRid cfgr;\n\n\tif (!test_bit (FLAG_COMMIT, &ai->flags))\n\t\treturn SUCCESS;\n\n\tclear_bit (FLAG_COMMIT, &ai->flags);\n\tclear_bit (FLAG_RESET, &ai->flags);\n\tcheckThrottle(ai);\n\tcfgr = ai->config;\n\n\tif ((cfgr.opmode & MODE_CFG_MASK) == MODE_STA_IBSS)\n\t\tset_bit(FLAG_ADHOC, &ai->flags);\n\telse\n\t\tclear_bit(FLAG_ADHOC, &ai->flags);\n\n\treturn PC4500_writerid(ai, RID_CONFIG, &cfgr, sizeof(cfgr), lock);\n}\n\nstatic int readStatusRid(struct airo_info *ai, StatusRid *statr, int lock)\n{\n\treturn PC4500_readrid(ai, RID_STATUS, statr, sizeof(*statr), lock);\n}\n\nstatic int writeAPListRid(struct airo_info *ai, APListRid *aplr, int lock)\n{\n\treturn PC4500_writerid(ai, RID_APLIST, aplr, sizeof(*aplr), lock);\n}\n\nstatic int readCapabilityRid(struct airo_info *ai, CapabilityRid *capr, int lock)\n{\n\treturn PC4500_readrid(ai, RID_CAPABILITIES, capr, sizeof(*capr), lock);\n}\n\nstatic int readStatsRid(struct airo_info*ai, StatsRid *sr, int rid, int lock)\n{\n\treturn PC4500_readrid(ai, rid, sr, sizeof(*sr), lock);\n}\n\nstatic void try_auto_wep(struct airo_info *ai)\n{\n\tif (auto_wep && !test_bit(FLAG_RADIO_DOWN, &ai->flags)) {\n\t\tai->expires = RUN_AT(3*HZ);\n\t\twake_up_interruptible(&ai->thr_wait);\n\t}\n}\n\nstatic int airo_open(struct net_device *dev)\n{\n\tstruct airo_info *ai = dev->ml_priv;\n\tint rc = 0;\n\n\tif (test_bit(FLAG_FLASHING, &ai->flags))\n\t\treturn -EIO;\n\n\t \n\tif (test_bit(FLAG_COMMIT, &ai->flags)) {\n\t\tdisable_MAC(ai, 1);\n\t\twriteConfigRid(ai, 1);\n\t}\n\n\tif (ai->wifidev != dev) {\n\t\tclear_bit(JOB_DIE, &ai->jobs);\n\t\tai->airo_thread_task = kthread_run(airo_thread, dev, \"%s\",\n\t\t\t\t\t\t   dev->name);\n\t\tif (IS_ERR(ai->airo_thread_task))\n\t\t\treturn (int)PTR_ERR(ai->airo_thread_task);\n\n\t\trc = request_irq(dev->irq, airo_interrupt, IRQF_SHARED,\n\t\t\tdev->name, dev);\n\t\tif (rc) {\n\t\t\tairo_print_err(dev->name,\n\t\t\t\t\"register interrupt %d failed, rc %d\",\n\t\t\t\tdev->irq, rc);\n\t\t\tset_bit(JOB_DIE, &ai->jobs);\n\t\t\tkthread_stop(ai->airo_thread_task);\n\t\t\treturn rc;\n\t\t}\n\n\t\t \n\t\tclear_bit(FLAG_RADIO_DOWN, &ai->flags);\n\t\tenable_interrupts(ai);\n\n\t\ttry_auto_wep(ai);\n\t}\n\tenable_MAC(ai, 1);\n\n\tnetif_start_queue(dev);\n\treturn 0;\n}\n\nstatic netdev_tx_t mpi_start_xmit(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev)\n{\n\tint npacks, pending;\n\tunsigned long flags;\n\tstruct airo_info *ai = dev->ml_priv;\n\n\tif (!skb) {\n\t\tairo_print_err(dev->name, \"%s: skb == NULL!\",__func__);\n\t\treturn NETDEV_TX_OK;\n\t}\n\tif (skb_padto(skb, ETH_ZLEN)) {\n\t\tdev->stats.tx_dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\tnpacks = skb_queue_len (&ai->txq);\n\n\tif (npacks >= MAXTXQ - 1) {\n\t\tnetif_stop_queue (dev);\n\t\tif (npacks > MAXTXQ) {\n\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\treturn NETDEV_TX_BUSY;\n\t\t}\n\t\tskb_queue_tail (&ai->txq, skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tspin_lock_irqsave(&ai->aux_lock, flags);\n\tskb_queue_tail (&ai->txq, skb);\n\tpending = test_bit(FLAG_PENDING_XMIT, &ai->flags);\n\tspin_unlock_irqrestore(&ai->aux_lock, flags);\n\tnetif_wake_queue (dev);\n\n\tif (pending == 0) {\n\t\tset_bit(FLAG_PENDING_XMIT, &ai->flags);\n\t\tmpi_send_packet (dev);\n\t}\n\treturn NETDEV_TX_OK;\n}\n\n \n\nstatic int mpi_send_packet (struct net_device *dev)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *buffer;\n\ts16 len;\n\t__le16 *payloadLen;\n\tstruct airo_info *ai = dev->ml_priv;\n\tu8 *sendbuf;\n\n\t \n\n\tif ((skb = skb_dequeue(&ai->txq)) == NULL) {\n\t\tairo_print_err(dev->name,\n\t\t\t\"%s: Dequeue'd zero in send_packet()\",\n\t\t\t__func__);\n\t\treturn 0;\n\t}\n\n\t \n\tlen = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;\n\tbuffer = skb->data;\n\n\tai->txfids[0].tx_desc.offset = 0;\n\tai->txfids[0].tx_desc.valid = 1;\n\tai->txfids[0].tx_desc.eoc = 1;\n\tai->txfids[0].tx_desc.len =len+sizeof(WifiHdr);\n\n \n\n\tmemcpy(ai->txfids[0].virtual_host_addr,\n\t\t(char *)&wifictlhdr8023, sizeof(wifictlhdr8023));\n\n\tpayloadLen = (__le16 *)(ai->txfids[0].virtual_host_addr +\n\t\tsizeof(wifictlhdr8023));\n\tsendbuf = ai->txfids[0].virtual_host_addr +\n\t\tsizeof(wifictlhdr8023) + 2 ;\n\n\t \n\tif (test_bit(FLAG_MIC_CAPABLE, &ai->flags) && ai->micstats.enabled &&\n\t\t(ntohs(((__be16 *)buffer)[6]) != 0x888E)) {\n\t\tMICBuffer pMic;\n\n\t\tif (encapsulate(ai, (etherHead *)buffer, &pMic, len - sizeof(etherHead)) != SUCCESS)\n\t\t\treturn ERROR;\n\n\t\t*payloadLen = cpu_to_le16(len-sizeof(etherHead)+sizeof(pMic));\n\t\tai->txfids[0].tx_desc.len += sizeof(pMic);\n\t\t \n\t\tmemcpy (sendbuf, buffer, sizeof(etherHead));\n\t\tbuffer += sizeof(etherHead);\n\t\tsendbuf += sizeof(etherHead);\n\t\tmemcpy (sendbuf, &pMic, sizeof(pMic));\n\t\tsendbuf += sizeof(pMic);\n\t\tmemcpy (sendbuf, buffer, len - sizeof(etherHead));\n\t} else {\n\t\t*payloadLen = cpu_to_le16(len - sizeof(etherHead));\n\n\t\tnetif_trans_update(dev);\n\n\t\t \n\t\tmemcpy(sendbuf, buffer, len);\n\t}\n\n\tmemcpy_toio(ai->txfids[0].card_ram_off,\n\t\t&ai->txfids[0].tx_desc, sizeof(TxFid));\n\n\tOUT4500(ai, EVACK, 8);\n\n\tdev_kfree_skb_any(skb);\n\treturn 1;\n}\n\nstatic void get_tx_error(struct airo_info *ai, s32 fid)\n{\n\t__le16 status;\n\n\tif (fid < 0)\n\t\tstatus = ((WifiCtlHdr *)ai->txfids[0].virtual_host_addr)->ctlhdr.status;\n\telse {\n\t\tif (bap_setup(ai, ai->fids[fid] & 0xffff, 4, BAP0) != SUCCESS)\n\t\t\treturn;\n\t\tbap_read(ai, &status, 2, BAP0);\n\t}\n\tif (le16_to_cpu(status) & 2)  \n\t\tai->dev->stats.tx_aborted_errors++;\n\tif (le16_to_cpu(status) & 4)  \n\t\tai->dev->stats.tx_heartbeat_errors++;\n\tif (le16_to_cpu(status) & 8)  \n\t\t{ }\n\tif (le16_to_cpu(status) & 0x10)  \n\t\tai->dev->stats.tx_carrier_errors++;\n\tif (le16_to_cpu(status) & 0x20)  \n\t\t{ }\n\t \n\tif ((le16_to_cpu(status) & 2) ||\n\t     (le16_to_cpu(status) & 4)) {\n\t\tunion iwreq_data\twrqu;\n\t\tchar junk[0x18];\n\n\t\t \n\t\tbap_read(ai, (__le16 *) junk, 0x18, BAP0);\n\n\t\t \n\t\tmemcpy(wrqu.addr.sa_data, junk + 0x12, ETH_ALEN);\n\t\twrqu.addr.sa_family = ARPHRD_ETHER;\n\n\t\t \n\t\twireless_send_event(ai->dev, IWEVTXDROP, &wrqu, NULL);\n\t}\n}\n\nstatic void airo_end_xmit(struct net_device *dev, bool may_sleep)\n{\n\tu16 status;\n\tint i;\n\tstruct airo_info *priv = dev->ml_priv;\n\tstruct sk_buff *skb = priv->xmit.skb;\n\tint fid = priv->xmit.fid;\n\tu32 *fids = priv->fids;\n\n\tclear_bit(JOB_XMIT, &priv->jobs);\n\tclear_bit(FLAG_PENDING_XMIT, &priv->flags);\n\tstatus = transmit_802_3_packet(priv, fids[fid], skb->data, may_sleep);\n\tup(&priv->sem);\n\n\ti = 0;\n\tif (status == SUCCESS) {\n\t\tnetif_trans_update(dev);\n\t\tfor (; i < MAX_FIDS / 2 && (priv->fids[i] & 0xffff0000); i++);\n\t} else {\n\t\tpriv->fids[fid] &= 0xffff;\n\t\tdev->stats.tx_window_errors++;\n\t}\n\tif (i < MAX_FIDS / 2)\n\t\tnetif_wake_queue(dev);\n\tdev_kfree_skb(skb);\n}\n\nstatic netdev_tx_t airo_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\ts16 len;\n\tint i, j;\n\tstruct airo_info *priv = dev->ml_priv;\n\tu32 *fids = priv->fids;\n\n\tif (skb == NULL) {\n\t\tairo_print_err(dev->name, \"%s: skb == NULL!\", __func__);\n\t\treturn NETDEV_TX_OK;\n\t}\n\tif (skb_padto(skb, ETH_ZLEN)) {\n\t\tdev->stats.tx_dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t \n\tfor (i = 0; i < MAX_FIDS / 2 && (fids[i] & 0xffff0000); i++);\n\tfor (j = i + 1; j < MAX_FIDS / 2 && (fids[j] & 0xffff0000); j++);\n\n\tif (j >= MAX_FIDS / 2) {\n\t\tnetif_stop_queue(dev);\n\n\t\tif (i == MAX_FIDS / 2) {\n\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\treturn NETDEV_TX_BUSY;\n\t\t}\n\t}\n\t \n\tlen = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;\n         \n\tfids[i] |= (len << 16);\n\tpriv->xmit.skb = skb;\n\tpriv->xmit.fid = i;\n\tif (down_trylock(&priv->sem) != 0) {\n\t\tset_bit(FLAG_PENDING_XMIT, &priv->flags);\n\t\tnetif_stop_queue(dev);\n\t\tset_bit(JOB_XMIT, &priv->jobs);\n\t\twake_up_interruptible(&priv->thr_wait);\n\t} else\n\t\tairo_end_xmit(dev, false);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void airo_end_xmit11(struct net_device *dev, bool may_sleep)\n{\n\tu16 status;\n\tint i;\n\tstruct airo_info *priv = dev->ml_priv;\n\tstruct sk_buff *skb = priv->xmit11.skb;\n\tint fid = priv->xmit11.fid;\n\tu32 *fids = priv->fids;\n\n\tclear_bit(JOB_XMIT11, &priv->jobs);\n\tclear_bit(FLAG_PENDING_XMIT11, &priv->flags);\n\tstatus = transmit_802_11_packet(priv, fids[fid], skb->data, may_sleep);\n\tup(&priv->sem);\n\n\ti = MAX_FIDS / 2;\n\tif (status == SUCCESS) {\n\t\tnetif_trans_update(dev);\n\t\tfor (; i < MAX_FIDS && (priv->fids[i] & 0xffff0000); i++);\n\t} else {\n\t\tpriv->fids[fid] &= 0xffff;\n\t\tdev->stats.tx_window_errors++;\n\t}\n\tif (i < MAX_FIDS)\n\t\tnetif_wake_queue(dev);\n\tdev_kfree_skb(skb);\n}\n\nstatic netdev_tx_t airo_start_xmit11(struct sk_buff *skb,\n\t\t\t\t\t   struct net_device *dev)\n{\n\ts16 len;\n\tint i, j;\n\tstruct airo_info *priv = dev->ml_priv;\n\tu32 *fids = priv->fids;\n\n\tif (test_bit(FLAG_MPI, &priv->flags)) {\n\t\t \n\t\tnetif_stop_queue(dev);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (skb == NULL) {\n\t\tairo_print_err(dev->name, \"%s: skb == NULL!\", __func__);\n\t\treturn NETDEV_TX_OK;\n\t}\n\tif (skb_padto(skb, ETH_ZLEN)) {\n\t\tdev->stats.tx_dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t \n\tfor (i = MAX_FIDS / 2; i < MAX_FIDS && (fids[i] & 0xffff0000); i++);\n\tfor (j = i + 1; j < MAX_FIDS && (fids[j] & 0xffff0000); j++);\n\n\tif (j >= MAX_FIDS) {\n\t\tnetif_stop_queue(dev);\n\n\t\tif (i == MAX_FIDS) {\n\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\treturn NETDEV_TX_BUSY;\n\t\t}\n\t}\n\t \n\tlen = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;\n         \n\tfids[i] |= (len << 16);\n\tpriv->xmit11.skb = skb;\n\tpriv->xmit11.fid = i;\n\tif (down_trylock(&priv->sem) != 0) {\n\t\tset_bit(FLAG_PENDING_XMIT11, &priv->flags);\n\t\tnetif_stop_queue(dev);\n\t\tset_bit(JOB_XMIT11, &priv->jobs);\n\t\twake_up_interruptible(&priv->thr_wait);\n\t} else\n\t\tairo_end_xmit11(dev, false);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void airo_read_stats(struct net_device *dev)\n{\n\tstruct airo_info *ai = dev->ml_priv;\n\tStatsRid stats_rid;\n\t__le32 *vals = stats_rid.vals;\n\n\tclear_bit(JOB_STATS, &ai->jobs);\n\tif (ai->power.event) {\n\t\tup(&ai->sem);\n\t\treturn;\n\t}\n\treadStatsRid(ai, &stats_rid, RID_STATS, 0);\n\tup(&ai->sem);\n\n\tdev->stats.rx_packets = le32_to_cpu(vals[43]) + le32_to_cpu(vals[44]) +\n\t\t\t       le32_to_cpu(vals[45]);\n\tdev->stats.tx_packets = le32_to_cpu(vals[39]) + le32_to_cpu(vals[40]) +\n\t\t\t       le32_to_cpu(vals[41]);\n\tdev->stats.rx_bytes = le32_to_cpu(vals[92]);\n\tdev->stats.tx_bytes = le32_to_cpu(vals[91]);\n\tdev->stats.rx_errors = le32_to_cpu(vals[0]) + le32_to_cpu(vals[2]) +\n\t\t\t      le32_to_cpu(vals[3]) + le32_to_cpu(vals[4]);\n\tdev->stats.tx_errors = le32_to_cpu(vals[42]) +\n\t\t\t      dev->stats.tx_fifo_errors;\n\tdev->stats.multicast = le32_to_cpu(vals[43]);\n\tdev->stats.collisions = le32_to_cpu(vals[89]);\n\n\t \n\tdev->stats.rx_length_errors = le32_to_cpu(vals[3]);\n\tdev->stats.rx_crc_errors = le32_to_cpu(vals[4]);\n\tdev->stats.rx_frame_errors = le32_to_cpu(vals[2]);\n\tdev->stats.rx_fifo_errors = le32_to_cpu(vals[0]);\n}\n\nstatic struct net_device_stats *airo_get_stats(struct net_device *dev)\n{\n\tstruct airo_info *local =  dev->ml_priv;\n\n\tif (!test_bit(JOB_STATS, &local->jobs)) {\n\t\tset_bit(JOB_STATS, &local->jobs);\n\t\twake_up_interruptible(&local->thr_wait);\n\t}\n\n\treturn &dev->stats;\n}\n\nstatic void airo_set_promisc(struct airo_info *ai, bool may_sleep)\n{\n\tCmd cmd;\n\tResp rsp;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.cmd = CMD_SETMODE;\n\tclear_bit(JOB_PROMISC, &ai->jobs);\n\tcmd.parm0=(ai->flags&IFF_PROMISC) ? PROMISC : NOPROMISC;\n\tissuecommand(ai, &cmd, &rsp, may_sleep);\n\tup(&ai->sem);\n}\n\nstatic void airo_set_multicast_list(struct net_device *dev)\n{\n\tstruct airo_info *ai = dev->ml_priv;\n\n\tif ((dev->flags ^ ai->flags) & IFF_PROMISC) {\n\t\tchange_bit(FLAG_PROMISC, &ai->flags);\n\t\tif (down_trylock(&ai->sem) != 0) {\n\t\t\tset_bit(JOB_PROMISC, &ai->jobs);\n\t\t\twake_up_interruptible(&ai->thr_wait);\n\t\t} else\n\t\t\tairo_set_promisc(ai, false);\n\t}\n\n\tif ((dev->flags&IFF_ALLMULTI) || !netdev_mc_empty(dev)) {\n\t\t \n\t}\n}\n\nstatic int airo_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct airo_info *ai = dev->ml_priv;\n\tstruct sockaddr *addr = p;\n\n\treadConfigRid(ai, 1);\n\tmemcpy (ai->config.macAddr, addr->sa_data, dev->addr_len);\n\tset_bit (FLAG_COMMIT, &ai->flags);\n\tdisable_MAC(ai, 1);\n\twriteConfigRid (ai, 1);\n\tenable_MAC(ai, 1);\n\tdev_addr_set(ai->dev, addr->sa_data);\n\tif (ai->wifidev)\n\t\tdev_addr_set(ai->wifidev, addr->sa_data);\n\treturn 0;\n}\n\nstatic LIST_HEAD(airo_devices);\n\nstatic void add_airo_dev(struct airo_info *ai)\n{\n\t \n\tif (!ai->pci)\n\t\tlist_add_tail(&ai->dev_list, &airo_devices);\n}\n\nstatic void del_airo_dev(struct airo_info *ai)\n{\n\tif (!ai->pci)\n\t\tlist_del(&ai->dev_list);\n}\n\nstatic int airo_close(struct net_device *dev)\n{\n\tstruct airo_info *ai = dev->ml_priv;\n\n\tnetif_stop_queue(dev);\n\n\tif (ai->wifidev != dev) {\n#ifdef POWER_ON_DOWN\n\t\t \n\t\tset_bit(FLAG_RADIO_DOWN, &ai->flags);\n\t\tdisable_MAC(ai, 1);\n#endif\n\t\tdisable_interrupts(ai);\n\n\t\tfree_irq(dev->irq, dev);\n\n\t\tset_bit(JOB_DIE, &ai->jobs);\n\t\tkthread_stop(ai->airo_thread_task);\n\t}\n\treturn 0;\n}\n\nvoid stop_airo_card(struct net_device *dev, int freeres)\n{\n\tstruct airo_info *ai = dev->ml_priv;\n\n\tset_bit(FLAG_RADIO_DOWN, &ai->flags);\n\tdisable_MAC(ai, 1);\n\tdisable_interrupts(ai);\n\ttakedown_proc_entry(dev, ai);\n\tif (test_bit(FLAG_REGISTERED, &ai->flags)) {\n\t\tunregister_netdev(dev);\n\t\tif (ai->wifidev) {\n\t\t\tunregister_netdev(ai->wifidev);\n\t\t\tfree_netdev(ai->wifidev);\n\t\t\tai->wifidev = NULL;\n\t\t}\n\t\tclear_bit(FLAG_REGISTERED, &ai->flags);\n\t}\n\t \n\tif (test_bit(FLAG_MPI, &ai->flags) && !skb_queue_empty(&ai->txq)) {\n\t\tstruct sk_buff *skb = NULL;\n\t\tfor (;(skb = skb_dequeue(&ai->txq));)\n\t\t\tdev_kfree_skb(skb);\n\t}\n\n\tairo_networks_free (ai);\n\n\tkfree(ai->flash);\n\tkfree(ai->rssi);\n\tkfree(ai->SSID);\n\tif (freeres) {\n\t\t \n\t\trelease_region(dev->base_addr, 64);\n\t\tif (test_bit(FLAG_MPI, &ai->flags)) {\n\t\t\tif (ai->pci)\n\t\t\t\tmpi_unmap_card(ai->pci);\n\t\t\tif (ai->pcimem)\n\t\t\t\tiounmap(ai->pcimem);\n\t\t\tif (ai->pciaux)\n\t\t\t\tiounmap(ai->pciaux);\n\t\t\tdma_free_coherent(&ai->pci->dev, PCI_SHARED_LEN,\n\t\t\t\t\t  ai->shared, ai->shared_dma);\n\t\t}\n        }\n\tcrypto_free_sync_skcipher(ai->tfm);\n\tdel_airo_dev(ai);\n\tfree_netdev(dev);\n}\n\nEXPORT_SYMBOL(stop_airo_card);\n\nstatic int wll_header_parse(const struct sk_buff *skb, unsigned char *haddr)\n{\n\tmemcpy(haddr, skb_mac_header(skb) + 10, ETH_ALEN);\n\treturn ETH_ALEN;\n}\n\nstatic void mpi_unmap_card(struct pci_dev *pci)\n{\n\tunsigned long mem_start = pci_resource_start(pci, 1);\n\tunsigned long mem_len = pci_resource_len(pci, 1);\n\tunsigned long aux_start = pci_resource_start(pci, 2);\n\tunsigned long aux_len = AUXMEMSIZE;\n\n\trelease_mem_region(aux_start, aux_len);\n\trelease_mem_region(mem_start, mem_len);\n}\n\n \nstatic int mpi_init_descriptors (struct airo_info *ai)\n{\n\tCmd cmd;\n\tResp rsp;\n\tint i;\n\tint rc = SUCCESS;\n\n\t \n\tnetif_stop_queue(ai->dev);\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\tcmd.cmd = CMD_ALLOCATEAUX;\n\tcmd.parm0 = FID_RX;\n\tcmd.parm1 = (ai->rxfids[0].card_ram_off - ai->pciaux);\n\tcmd.parm2 = MPI_MAX_FIDS;\n\trc = issuecommand(ai, &cmd, &rsp, true);\n\tif (rc != SUCCESS) {\n\t\tairo_print_err(ai->dev->name, \"Couldn't allocate RX FID\");\n\t\treturn rc;\n\t}\n\n\tfor (i = 0; i<MPI_MAX_FIDS; i++) {\n\t\tmemcpy_toio(ai->rxfids[i].card_ram_off,\n\t\t\t&ai->rxfids[i].rx_desc, sizeof(RxFid));\n\t}\n\n\t \n\n\tmemset(&rsp, 0, sizeof(rsp));\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\tcmd.cmd = CMD_ALLOCATEAUX;\n\tcmd.parm0 = FID_TX;\n\tcmd.parm1 = (ai->txfids[0].card_ram_off - ai->pciaux);\n\tcmd.parm2 = MPI_MAX_FIDS;\n\n\tfor (i = 0; i<MPI_MAX_FIDS; i++) {\n\t\tai->txfids[i].tx_desc.valid = 1;\n\t\tmemcpy_toio(ai->txfids[i].card_ram_off,\n\t\t\t&ai->txfids[i].tx_desc, sizeof(TxFid));\n\t}\n\tai->txfids[i-1].tx_desc.eoc = 1;  \n\n\trc = issuecommand(ai, &cmd, &rsp, true);\n\tif (rc != SUCCESS) {\n\t\tairo_print_err(ai->dev->name, \"Couldn't allocate TX FID\");\n\t\treturn rc;\n\t}\n\n\t \n\tmemset(&rsp, 0, sizeof(rsp));\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\tcmd.cmd = CMD_ALLOCATEAUX;\n\tcmd.parm0 = RID_RW;\n\tcmd.parm1 = (ai->config_desc.card_ram_off - ai->pciaux);\n\tcmd.parm2 = 1;  \n\trc = issuecommand(ai, &cmd, &rsp, true);\n\tif (rc != SUCCESS) {\n\t\tairo_print_err(ai->dev->name, \"Couldn't allocate RID\");\n\t\treturn rc;\n\t}\n\n\tmemcpy_toio(ai->config_desc.card_ram_off,\n\t\t&ai->config_desc.rid_desc, sizeof(Rid));\n\n\treturn rc;\n}\n\n \nstatic int mpi_map_card(struct airo_info *ai, struct pci_dev *pci)\n{\n\tunsigned long mem_start, mem_len, aux_start, aux_len;\n\tint rc = -1;\n\tint i;\n\tdma_addr_t busaddroff;\n\tunsigned char *vpackoff;\n\tunsigned char __iomem *pciaddroff;\n\n\tmem_start = pci_resource_start(pci, 1);\n\tmem_len = pci_resource_len(pci, 1);\n\taux_start = pci_resource_start(pci, 2);\n\taux_len = AUXMEMSIZE;\n\n\tif (!request_mem_region(mem_start, mem_len, DRV_NAME)) {\n\t\tairo_print_err(\"\", \"Couldn't get region %x[%x]\",\n\t\t\t(int)mem_start, (int)mem_len);\n\t\tgoto out;\n\t}\n\tif (!request_mem_region(aux_start, aux_len, DRV_NAME)) {\n\t\tairo_print_err(\"\", \"Couldn't get region %x[%x]\",\n\t\t\t(int)aux_start, (int)aux_len);\n\t\tgoto free_region1;\n\t}\n\n\tai->pcimem = ioremap(mem_start, mem_len);\n\tif (!ai->pcimem) {\n\t\tairo_print_err(\"\", \"Couldn't map region %x[%x]\",\n\t\t\t(int)mem_start, (int)mem_len);\n\t\tgoto free_region2;\n\t}\n\tai->pciaux = ioremap(aux_start, aux_len);\n\tif (!ai->pciaux) {\n\t\tairo_print_err(\"\", \"Couldn't map region %x[%x]\",\n\t\t\t(int)aux_start, (int)aux_len);\n\t\tgoto free_memmap;\n\t}\n\n\t \n\tai->shared = dma_alloc_coherent(&pci->dev, PCI_SHARED_LEN,\n\t\t\t\t\t&ai->shared_dma, GFP_KERNEL);\n\tif (!ai->shared) {\n\t\tairo_print_err(\"\", \"Couldn't alloc_coherent %d\",\n\t\t\tPCI_SHARED_LEN);\n\t\tgoto free_auxmap;\n\t}\n\n\t \n\tbusaddroff = ai->shared_dma;\n\tpciaddroff = ai->pciaux + AUX_OFFSET;\n\tvpackoff   = ai->shared;\n\n\t \n\tfor (i = 0; i < MPI_MAX_FIDS; i++) {\n\t\tai->rxfids[i].pending = 0;\n\t\tai->rxfids[i].card_ram_off = pciaddroff;\n\t\tai->rxfids[i].virtual_host_addr = vpackoff;\n\t\tai->rxfids[i].rx_desc.host_addr = busaddroff;\n\t\tai->rxfids[i].rx_desc.valid = 1;\n\t\tai->rxfids[i].rx_desc.len = PKTSIZE;\n\t\tai->rxfids[i].rx_desc.rdy = 0;\n\n\t\tpciaddroff += sizeof(RxFid);\n\t\tbusaddroff += PKTSIZE;\n\t\tvpackoff   += PKTSIZE;\n\t}\n\n\t \n\tfor (i = 0; i < MPI_MAX_FIDS; i++) {\n\t\tai->txfids[i].card_ram_off = pciaddroff;\n\t\tai->txfids[i].virtual_host_addr = vpackoff;\n\t\tai->txfids[i].tx_desc.valid = 1;\n\t\tai->txfids[i].tx_desc.host_addr = busaddroff;\n\t\tmemcpy(ai->txfids[i].virtual_host_addr,\n\t\t\t&wifictlhdr8023, sizeof(wifictlhdr8023));\n\n\t\tpciaddroff += sizeof(TxFid);\n\t\tbusaddroff += PKTSIZE;\n\t\tvpackoff   += PKTSIZE;\n\t}\n\tai->txfids[i-1].tx_desc.eoc = 1;  \n\n\t \n\tai->config_desc.card_ram_off = pciaddroff;\n\tai->config_desc.virtual_host_addr = vpackoff;\n\tai->config_desc.rid_desc.host_addr = busaddroff;\n\tai->ridbus = busaddroff;\n\tai->config_desc.rid_desc.rid = 0;\n\tai->config_desc.rid_desc.len = RIDSIZE;\n\tai->config_desc.rid_desc.valid = 1;\n\tpciaddroff += sizeof(Rid);\n\tbusaddroff += RIDSIZE;\n\tvpackoff   += RIDSIZE;\n\n\t \n\tif (mpi_init_descriptors (ai) != SUCCESS)\n\t\tgoto free_shared;\n\n\treturn 0;\n free_shared:\n\tdma_free_coherent(&pci->dev, PCI_SHARED_LEN, ai->shared,\n\t\t\t  ai->shared_dma);\n free_auxmap:\n\tiounmap(ai->pciaux);\n free_memmap:\n\tiounmap(ai->pcimem);\n free_region2:\n\trelease_mem_region(aux_start, aux_len);\n free_region1:\n\trelease_mem_region(mem_start, mem_len);\n out:\n\treturn rc;\n}\n\nstatic const struct header_ops airo_header_ops = {\n\t.parse = wll_header_parse,\n};\n\nstatic const struct net_device_ops airo11_netdev_ops = {\n\t.ndo_open \t\t= airo_open,\n\t.ndo_stop \t\t= airo_close,\n\t.ndo_start_xmit \t= airo_start_xmit11,\n\t.ndo_get_stats \t\t= airo_get_stats,\n\t.ndo_set_mac_address\t= airo_set_mac_address,\n\t.ndo_siocdevprivate\t= airo_siocdevprivate,\n};\n\nstatic void wifi_setup(struct net_device *dev)\n{\n\tdev->netdev_ops = &airo11_netdev_ops;\n\tdev->header_ops = &airo_header_ops;\n\tdev->wireless_handlers = &airo_handler_def;\n\n\tdev->type               = ARPHRD_IEEE80211;\n\tdev->hard_header_len    = ETH_HLEN;\n\tdev->mtu                = AIRO_DEF_MTU;\n\tdev->min_mtu            = 68;\n\tdev->max_mtu            = MIC_MSGLEN_MAX;\n\tdev->addr_len           = ETH_ALEN;\n\tdev->tx_queue_len       = 100;\n\n\teth_broadcast_addr(dev->broadcast);\n\n\tdev->flags              = IFF_BROADCAST|IFF_MULTICAST;\n}\n\nstatic struct net_device *init_wifidev(struct airo_info *ai,\n\t\t\t\t\tstruct net_device *ethdev)\n{\n\tint err;\n\tstruct net_device *dev = alloc_netdev(0, \"wifi%d\", NET_NAME_UNKNOWN,\n\t\t\t\t\t      wifi_setup);\n\tif (!dev)\n\t\treturn NULL;\n\tdev->ml_priv = ethdev->ml_priv;\n\tdev->irq = ethdev->irq;\n\tdev->base_addr = ethdev->base_addr;\n\tdev->wireless_data = ethdev->wireless_data;\n\tSET_NETDEV_DEV(dev, ethdev->dev.parent);\n\teth_hw_addr_inherit(dev, ethdev);\n\terr = register_netdev(dev);\n\tif (err<0) {\n\t\tfree_netdev(dev);\n\t\treturn NULL;\n\t}\n\treturn dev;\n}\n\nstatic int reset_card(struct net_device *dev, int lock)\n{\n\tstruct airo_info *ai = dev->ml_priv;\n\n\tif (lock && down_interruptible(&ai->sem))\n\t\treturn -1;\n\twaitbusy (ai);\n\tOUT4500(ai, COMMAND, CMD_SOFTRESET);\n\tmsleep(200);\n\twaitbusy (ai);\n\tmsleep(200);\n\tif (lock)\n\t\tup(&ai->sem);\n\treturn 0;\n}\n\n#define AIRO_MAX_NETWORK_COUNT\t64\nstatic int airo_networks_allocate(struct airo_info *ai)\n{\n\tif (ai->networks)\n\t\treturn 0;\n\n\tai->networks = kcalloc(AIRO_MAX_NETWORK_COUNT, sizeof(BSSListElement),\n\t\t\t       GFP_KERNEL);\n\tif (!ai->networks) {\n\t\tairo_print_warn(\"\", \"Out of memory allocating beacons\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void airo_networks_free(struct airo_info *ai)\n{\n\tkfree(ai->networks);\n\tai->networks = NULL;\n}\n\nstatic void airo_networks_initialize(struct airo_info *ai)\n{\n\tint i;\n\n\tINIT_LIST_HEAD(&ai->network_free_list);\n\tINIT_LIST_HEAD(&ai->network_list);\n\tfor (i = 0; i < AIRO_MAX_NETWORK_COUNT; i++)\n\t\tlist_add_tail(&ai->networks[i].list,\n\t\t\t      &ai->network_free_list);\n}\n\nstatic const struct net_device_ops airo_netdev_ops = {\n\t.ndo_open\t\t= airo_open,\n\t.ndo_stop\t\t= airo_close,\n\t.ndo_start_xmit\t\t= airo_start_xmit,\n\t.ndo_get_stats\t\t= airo_get_stats,\n\t.ndo_set_rx_mode\t= airo_set_multicast_list,\n\t.ndo_set_mac_address\t= airo_set_mac_address,\n\t.ndo_siocdevprivate\t= airo_siocdevprivate,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic const struct net_device_ops mpi_netdev_ops = {\n\t.ndo_open\t\t= airo_open,\n\t.ndo_stop\t\t= airo_close,\n\t.ndo_start_xmit\t\t= mpi_start_xmit,\n\t.ndo_get_stats\t\t= airo_get_stats,\n\t.ndo_set_rx_mode\t= airo_set_multicast_list,\n\t.ndo_set_mac_address\t= airo_set_mac_address,\n\t.ndo_siocdevprivate\t= airo_siocdevprivate,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\n\nstatic struct net_device *_init_airo_card(unsigned short irq, int port,\n\t\t\t\t\t   int is_pcmcia, struct pci_dev *pci,\n\t\t\t\t\t   struct device *dmdev)\n{\n\tstruct net_device *dev;\n\tstruct airo_info *ai;\n\tint i, rc;\n\tCapabilityRid cap_rid;\n\n\t \n\tdev = alloc_netdev(sizeof(*ai), \"\", NET_NAME_UNKNOWN, ether_setup);\n\tif (!dev) {\n\t\tairo_print_err(\"\", \"Couldn't alloc_etherdev\");\n\t\treturn NULL;\n\t}\n\n\tai = dev->ml_priv = netdev_priv(dev);\n\tai->wifidev = NULL;\n\tai->flags = 1 << FLAG_RADIO_DOWN;\n\tai->jobs = 0;\n\tai->dev = dev;\n\tif (pci && (pci->device == 0x5000 || pci->device == 0xa504)) {\n\t\tairo_print_dbg(\"\", \"Found an MPI350 card\");\n\t\tset_bit(FLAG_MPI, &ai->flags);\n\t}\n\tspin_lock_init(&ai->aux_lock);\n\tsema_init(&ai->sem, 1);\n\tai->config.len = 0;\n\tai->pci = pci;\n\tinit_waitqueue_head (&ai->thr_wait);\n\tai->tfm = NULL;\n\tadd_airo_dev(ai);\n\tai->APList.len = cpu_to_le16(sizeof(struct APListRid));\n\n\tif (airo_networks_allocate (ai))\n\t\tgoto err_out_free;\n\tairo_networks_initialize (ai);\n\n\tskb_queue_head_init (&ai->txq);\n\n\t \n\tif (test_bit(FLAG_MPI,&ai->flags))\n\t\tdev->netdev_ops = &mpi_netdev_ops;\n\telse\n\t\tdev->netdev_ops = &airo_netdev_ops;\n\tdev->wireless_handlers = &airo_handler_def;\n\tai->wireless_data.spy_data = &ai->spy_data;\n\tdev->wireless_data = &ai->wireless_data;\n\tdev->irq = irq;\n\tdev->base_addr = port;\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->max_mtu = MIC_MSGLEN_MAX;\n\n\tSET_NETDEV_DEV(dev, dmdev);\n\n\treset_card (dev, 1);\n\tmsleep(400);\n\n\tif (!is_pcmcia) {\n\t\tif (!request_region(dev->base_addr, 64, DRV_NAME)) {\n\t\t\trc = -EBUSY;\n\t\t\tairo_print_err(dev->name, \"Couldn't request region\");\n\t\t\tgoto err_out_nets;\n\t\t}\n\t}\n\n\tif (test_bit(FLAG_MPI,&ai->flags)) {\n\t\tif (mpi_map_card(ai, pci)) {\n\t\t\tairo_print_err(\"\", \"Could not map memory\");\n\t\t\tgoto err_out_res;\n\t\t}\n\t}\n\n\tif (probe) {\n\t\tif (setup_card(ai, dev, 1) != SUCCESS) {\n\t\t\tairo_print_err(dev->name, \"MAC could not be enabled\");\n\t\t\trc = -EIO;\n\t\t\tgoto err_out_map;\n\t\t}\n\t} else if (!test_bit(FLAG_MPI,&ai->flags)) {\n\t\tai->bap_read = fast_bap_read;\n\t\tset_bit(FLAG_FLASHING, &ai->flags);\n\t}\n\n\tstrcpy(dev->name, \"eth%d\");\n\trc = register_netdev(dev);\n\tif (rc) {\n\t\tairo_print_err(dev->name, \"Couldn't register_netdev\");\n\t\tgoto err_out_map;\n\t}\n\tai->wifidev = init_wifidev(ai, dev);\n\tif (!ai->wifidev)\n\t\tgoto err_out_reg;\n\n\trc = readCapabilityRid(ai, &cap_rid, 1);\n\tif (rc != SUCCESS) {\n\t\trc = -EIO;\n\t\tgoto err_out_wifi;\n\t}\n\t \n\tai->wep_capable = (cap_rid.softCap & cpu_to_le16(0x02)) ? 1 : 0;\n\tai->max_wep_idx = (cap_rid.softCap & cpu_to_le16(0x80)) ? 3 : 0;\n\n\tairo_print_info(dev->name, \"Firmware version %x.%x.%02d\",\n\t                ((le16_to_cpu(cap_rid.softVer) >> 8) & 0xF),\n\t                (le16_to_cpu(cap_rid.softVer) & 0xFF),\n\t                le16_to_cpu(cap_rid.softSubVer));\n\n\t \n\t \n\tif (le16_to_cpu(cap_rid.softVer) > 0x530\n\t || (le16_to_cpu(cap_rid.softVer) == 0x530\n\t      && le16_to_cpu(cap_rid.softSubVer) >= 17)) {\n\t\tairo_print_info(ai->dev->name, \"WPA supported.\");\n\n\t\tset_bit(FLAG_WPA_CAPABLE, &ai->flags);\n\t\tai->bssListFirst = RID_WPA_BSSLISTFIRST;\n\t\tai->bssListNext = RID_WPA_BSSLISTNEXT;\n\t\tai->bssListRidLen = sizeof(BSSListRid);\n\t} else {\n\t\tairo_print_info(ai->dev->name, \"WPA unsupported with firmware \"\n\t\t\t\"versions older than 5.30.17.\");\n\n\t\tai->bssListFirst = RID_BSSLISTFIRST;\n\t\tai->bssListNext = RID_BSSLISTNEXT;\n\t\tai->bssListRidLen = sizeof(BSSListRid) - sizeof(BSSListRidExtra);\n\t}\n\n\tset_bit(FLAG_REGISTERED,&ai->flags);\n\tairo_print_info(dev->name, \"MAC enabled %pM\", dev->dev_addr);\n\n\t \n\tif (probe && !test_bit(FLAG_MPI,&ai->flags))\n\t\tfor (i = 0; i < MAX_FIDS; i++)\n\t\t\tai->fids[i] = transmit_allocate(ai, AIRO_DEF_MTU, i>=MAX_FIDS/2);\n\n\tif (setup_proc_entry(dev, dev->ml_priv) < 0)\n\t\tgoto err_out_wifi;\n\n\treturn dev;\n\nerr_out_wifi:\n\tunregister_netdev(ai->wifidev);\n\tfree_netdev(ai->wifidev);\nerr_out_reg:\n\tunregister_netdev(dev);\nerr_out_map:\n\tif (test_bit(FLAG_MPI,&ai->flags) && pci) {\n\t\tdma_free_coherent(&pci->dev, PCI_SHARED_LEN, ai->shared,\n\t\t\t\t  ai->shared_dma);\n\t\tiounmap(ai->pciaux);\n\t\tiounmap(ai->pcimem);\n\t\tmpi_unmap_card(ai->pci);\n\t}\nerr_out_res:\n\tif (!is_pcmcia)\n\t\trelease_region(dev->base_addr, 64);\nerr_out_nets:\n\tairo_networks_free(ai);\nerr_out_free:\n\tdel_airo_dev(ai);\n\tfree_netdev(dev);\n\treturn NULL;\n}\n\nstruct net_device *init_airo_card(unsigned short irq, int port, int is_pcmcia,\n\t\t\t\t  struct device *dmdev)\n{\n\treturn _init_airo_card (irq, port, is_pcmcia, NULL, dmdev);\n}\n\nEXPORT_SYMBOL(init_airo_card);\n\nstatic int waitbusy (struct airo_info *ai)\n{\n\tint delay = 0;\n\twhile ((IN4500(ai, COMMAND) & COMMAND_BUSY) && (delay < 10000)) {\n\t\tudelay (10);\n\t\tif ((++delay % 20) == 0)\n\t\t\tOUT4500(ai, EVACK, EV_CLEARCOMMANDBUSY);\n\t}\n\treturn delay < 10000;\n}\n\nint reset_airo_card(struct net_device *dev)\n{\n\tint i;\n\tstruct airo_info *ai = dev->ml_priv;\n\n\tif (reset_card (dev, 1))\n\t\treturn -1;\n\n\tif (setup_card(ai, dev, 1) != SUCCESS) {\n\t\tairo_print_err(dev->name, \"MAC could not be enabled\");\n\t\treturn -1;\n\t}\n\tairo_print_info(dev->name, \"MAC enabled %pM\", dev->dev_addr);\n\t \n\tif (!test_bit(FLAG_MPI,&ai->flags))\n\t\tfor (i = 0; i < MAX_FIDS; i++)\n\t\t\tai->fids[i] = transmit_allocate (ai, AIRO_DEF_MTU, i>=MAX_FIDS/2);\n\n\tenable_interrupts(ai);\n\tnetif_wake_queue(dev);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(reset_airo_card);\n\nstatic void airo_send_event(struct net_device *dev)\n{\n\tstruct airo_info *ai = dev->ml_priv;\n\tunion iwreq_data wrqu;\n\tStatusRid status_rid;\n\n\tclear_bit(JOB_EVENT, &ai->jobs);\n\tPC4500_readrid(ai, RID_STATUS, &status_rid, sizeof(status_rid), 0);\n\tup(&ai->sem);\n\twrqu.data.length = 0;\n\twrqu.data.flags = 0;\n\tmemcpy(wrqu.ap_addr.sa_data, status_rid.bssid[0], ETH_ALEN);\n\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\n\t \n\twireless_send_event(dev, SIOCGIWAP, &wrqu, NULL);\n}\n\nstatic void airo_process_scan_results (struct airo_info *ai)\n{\n\tunion iwreq_data\twrqu;\n\tBSSListRid bss;\n\tint rc;\n\tBSSListElement * loop_net;\n\tBSSListElement * tmp_net;\n\n\t \n\tlist_for_each_entry_safe (loop_net, tmp_net, &ai->network_list, list) {\n\t\tlist_move_tail (&loop_net->list, &ai->network_free_list);\n\t\t \n\t\tmemset (loop_net, 0, sizeof (loop_net->bss));\n\t}\n\n\t \n\trc = PC4500_readrid(ai, ai->bssListFirst, &bss, ai->bssListRidLen, 0);\n\tif ((rc) || (bss.index == cpu_to_le16(0xffff))) {\n\t\t \n\t\tgoto out;\n\t}\n\n\t \n\ttmp_net = NULL;\n\twhile ((!rc) && (bss.index != cpu_to_le16(0xffff))) {\n\t\t \n\t\tif (!list_empty(&ai->network_free_list)) {\n\t\t\ttmp_net = list_entry(ai->network_free_list.next,\n\t\t\t\t\t    BSSListElement, list);\n\t\t\tlist_del(ai->network_free_list.next);\n\t\t}\n\n\t\tif (tmp_net != NULL) {\n\t\t\tmemcpy(tmp_net, &bss, sizeof(tmp_net->bss));\n\t\t\tlist_add_tail(&tmp_net->list, &ai->network_list);\n\t\t\ttmp_net = NULL;\n\t\t}\n\n\t\t \n\t\trc = PC4500_readrid(ai, ai->bssListNext,\n\t\t\t\t    &bss, ai->bssListRidLen, 0);\n\t}\n\nout:\n\t \n\tdisable_MAC(ai, 2);\n\twriteAPListRid(ai, &ai->APList, 0);\n\tenable_MAC(ai, 0);\n\n\tai->scan_timeout = 0;\n\tclear_bit(JOB_SCAN_RESULTS, &ai->jobs);\n\tup(&ai->sem);\n\n\t \n\twrqu.data.length = 0;\n\twrqu.data.flags = 0;\n\twireless_send_event(ai->dev, SIOCGIWSCAN, &wrqu, NULL);\n}\n\nstatic int airo_thread(void *data)\n{\n\tstruct net_device *dev = data;\n\tstruct airo_info *ai = dev->ml_priv;\n\tint locked;\n\n\tset_freezable();\n\twhile (1) {\n\t\t \n\t\ttry_to_freeze();\n\n\t\tif (test_bit(JOB_DIE, &ai->jobs))\n\t\t\tbreak;\n\n\t\tif (ai->jobs) {\n\t\t\tlocked = down_interruptible(&ai->sem);\n\t\t} else {\n\t\t\twait_queue_entry_t wait;\n\n\t\t\tinit_waitqueue_entry(&wait, current);\n\t\t\tadd_wait_queue(&ai->thr_wait, &wait);\n\t\t\tfor (;;) {\n\t\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\t\tif (ai->jobs)\n\t\t\t\t\tbreak;\n\t\t\t\tif (ai->expires || ai->scan_timeout) {\n\t\t\t\t\tif (ai->scan_timeout &&\n\t\t\t\t\t\t\ttime_after_eq(jiffies, ai->scan_timeout)) {\n\t\t\t\t\t\tset_bit(JOB_SCAN_RESULTS, &ai->jobs);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (ai->expires &&\n\t\t\t\t\t\t\ttime_after_eq(jiffies, ai->expires)) {\n\t\t\t\t\t\tset_bit(JOB_AUTOWEP, &ai->jobs);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (!kthread_should_stop() &&\n\t\t\t\t\t    !freezing(current)) {\n\t\t\t\t\t\tunsigned long wake_at;\n\t\t\t\t\t\tif (!ai->expires || !ai->scan_timeout) {\n\t\t\t\t\t\t\twake_at = max(ai->expires,\n\t\t\t\t\t\t\t\tai->scan_timeout);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twake_at = min(ai->expires,\n\t\t\t\t\t\t\t\tai->scan_timeout);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tschedule_timeout(wake_at - jiffies);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else if (!kthread_should_stop() &&\n\t\t\t\t\t   !freezing(current)) {\n\t\t\t\t\tschedule();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\tremove_wait_queue(&ai->thr_wait, &wait);\n\t\t\tlocked = 1;\n\t\t}\n\n\t\tif (locked)\n\t\t\tcontinue;\n\n\t\tif (test_bit(JOB_DIE, &ai->jobs)) {\n\t\t\tup(&ai->sem);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ai->power.event || test_bit(FLAG_FLASHING, &ai->flags)) {\n\t\t\tup(&ai->sem);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_bit(JOB_XMIT, &ai->jobs))\n\t\t\tairo_end_xmit(dev, true);\n\t\telse if (test_bit(JOB_XMIT11, &ai->jobs))\n\t\t\tairo_end_xmit11(dev, true);\n\t\telse if (test_bit(JOB_STATS, &ai->jobs))\n\t\t\tairo_read_stats(dev);\n\t\telse if (test_bit(JOB_PROMISC, &ai->jobs))\n\t\t\tairo_set_promisc(ai, true);\n\t\telse if (test_bit(JOB_MIC, &ai->jobs))\n\t\t\tmicinit(ai);\n\t\telse if (test_bit(JOB_EVENT, &ai->jobs))\n\t\t\tairo_send_event(dev);\n\t\telse if (test_bit(JOB_AUTOWEP, &ai->jobs))\n\t\t\ttimer_func(dev);\n\t\telse if (test_bit(JOB_SCAN_RESULTS, &ai->jobs))\n\t\t\tairo_process_scan_results(ai);\n\t\telse   \n\t\t\tup(&ai->sem);\n\t}\n\n\treturn 0;\n}\n\nstatic int header_len(__le16 ctl)\n{\n\tu16 fc = le16_to_cpu(ctl);\n\tswitch (fc & 0xc) {\n\tcase 4:\n\t\tif ((fc & 0xe0) == 0xc0)\n\t\t\treturn 10;\t \n\t\treturn 16;\t \n\tcase 8:\n\t\tif ((fc & 0x300) == 0x300)\n\t\t\treturn 30;\t \n\t}\n\treturn 24;\n}\n\nstatic void airo_handle_cisco_mic(struct airo_info *ai)\n{\n\tif (test_bit(FLAG_MIC_CAPABLE, &ai->flags)) {\n\t\tset_bit(JOB_MIC, &ai->jobs);\n\t\twake_up_interruptible(&ai->thr_wait);\n\t}\n}\n\n \n#define STAT_NOBEACON\t0x8000  \n#define STAT_MAXRETRIES\t0x8001  \n#define STAT_MAXARL\t0x8002  \n#define STAT_FORCELOSS\t0x8003  \n#define STAT_TSFSYNC\t0x8004  \n#define STAT_DEAUTH\t0x8100  \n#define STAT_DISASSOC\t0x8200  \n#define STAT_ASSOC_FAIL\t0x8400  \n#define STAT_AUTH_FAIL\t0x0300  \n#define STAT_ASSOC\t0x0400  \n#define STAT_REASSOC    0x0600  \n\nstatic void airo_print_status(const char *devname, u16 status)\n{\n\tu8 reason = status & 0xFF;\n\n\tswitch (status & 0xFF00) {\n\tcase STAT_NOBEACON:\n\t\tswitch (status) {\n\t\tcase STAT_NOBEACON:\n\t\t\tairo_print_dbg(devname, \"link lost (missed beacons)\");\n\t\t\tbreak;\n\t\tcase STAT_MAXRETRIES:\n\t\tcase STAT_MAXARL:\n\t\t\tairo_print_dbg(devname, \"link lost (max retries)\");\n\t\t\tbreak;\n\t\tcase STAT_FORCELOSS:\n\t\t\tairo_print_dbg(devname, \"link lost (local choice)\");\n\t\t\tbreak;\n\t\tcase STAT_TSFSYNC:\n\t\t\tairo_print_dbg(devname, \"link lost (TSF sync lost)\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tairo_print_dbg(devname, \"unknown status %x\\n\", status);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase STAT_DEAUTH:\n\t\tairo_print_dbg(devname, \"deauthenticated (reason: %d)\", reason);\n\t\tbreak;\n\tcase STAT_DISASSOC:\n\t\tairo_print_dbg(devname, \"disassociated (reason: %d)\", reason);\n\t\tbreak;\n\tcase STAT_ASSOC_FAIL:\n\t\tairo_print_dbg(devname, \"association failed (reason: %d)\",\n\t\t\t       reason);\n\t\tbreak;\n\tcase STAT_AUTH_FAIL:\n\t\tairo_print_dbg(devname, \"authentication failed (reason: %d)\",\n\t\t\t       reason);\n\t\tbreak;\n\tcase STAT_ASSOC:\n\tcase STAT_REASSOC:\n\t\tbreak;\n\tdefault:\n\t\tairo_print_dbg(devname, \"unknown status %x\\n\", status);\n\t\tbreak;\n\t}\n}\n\nstatic void airo_handle_link(struct airo_info *ai)\n{\n\tunion iwreq_data wrqu;\n\tint scan_forceloss = 0;\n\tu16 status;\n\n\t \n\tstatus = le16_to_cpu(IN4500(ai, LINKSTAT));\n\tOUT4500(ai, EVACK, EV_LINK);\n\n\tif ((status == STAT_FORCELOSS) && (ai->scan_timeout > 0))\n\t\tscan_forceloss = 1;\n\n\tairo_print_status(ai->dev->name, status);\n\n\tif ((status == STAT_ASSOC) || (status == STAT_REASSOC)) {\n\t\tif (auto_wep)\n\t\t\tai->expires = 0;\n\t\tif (ai->list_bss_task)\n\t\t\twake_up_process(ai->list_bss_task);\n\t\tset_bit(FLAG_UPDATE_UNI, &ai->flags);\n\t\tset_bit(FLAG_UPDATE_MULTI, &ai->flags);\n\n\t\tset_bit(JOB_EVENT, &ai->jobs);\n\t\twake_up_interruptible(&ai->thr_wait);\n\n\t\tnetif_carrier_on(ai->dev);\n\t} else if (!scan_forceloss) {\n\t\tif (auto_wep && !ai->expires) {\n\t\t\tai->expires = RUN_AT(3*HZ);\n\t\t\twake_up_interruptible(&ai->thr_wait);\n\t\t}\n\n\t\t \n\t\teth_zero_addr(wrqu.ap_addr.sa_data);\n\t\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\t\twireless_send_event(ai->dev, SIOCGIWAP, &wrqu, NULL);\n\t\tnetif_carrier_off(ai->dev);\n\t} else {\n\t\tnetif_carrier_off(ai->dev);\n\t}\n}\n\nstatic void airo_handle_rx(struct airo_info *ai)\n{\n\tstruct sk_buff *skb = NULL;\n\t__le16 fc, v, *buffer, tmpbuf[4];\n\tu16 len, hdrlen = 0, gap, fid;\n\tstruct rx_hdr hdr;\n\tint success = 0;\n\n\tif (test_bit(FLAG_MPI, &ai->flags)) {\n\t\tif (test_bit(FLAG_802_11, &ai->flags))\n\t\t\tmpi_receive_802_11(ai);\n\t\telse\n\t\t\tmpi_receive_802_3(ai);\n\t\tOUT4500(ai, EVACK, EV_RX);\n\t\treturn;\n\t}\n\n\tfid = IN4500(ai, RXFID);\n\n\t \n\tif (test_bit(FLAG_802_11, &ai->flags)) {\n\t\tbap_setup (ai, fid, 4, BAP0);\n\t\tbap_read (ai, (__le16*)&hdr, sizeof(hdr), BAP0);\n\t\t \n\t\tif (le16_to_cpu(hdr.status) & 2)\n\t\t\thdr.len = 0;\n\t\tif (ai->wifidev == NULL)\n\t\t\thdr.len = 0;\n\t} else {\n\t\tbap_setup(ai, fid, 0x36, BAP0);\n\t\tbap_read(ai, &hdr.len, 2, BAP0);\n\t}\n\tlen = le16_to_cpu(hdr.len);\n\n\tif (len > AIRO_DEF_MTU) {\n\t\tairo_print_err(ai->dev->name, \"Bad size %d\", len);\n\t\tgoto done;\n\t}\n\tif (len == 0)\n\t\tgoto done;\n\n\tif (test_bit(FLAG_802_11, &ai->flags)) {\n\t\tbap_read(ai, &fc, sizeof (fc), BAP0);\n\t\thdrlen = header_len(fc);\n\t} else\n\t\thdrlen = ETH_ALEN * 2;\n\n\tskb = dev_alloc_skb(len + hdrlen + 2 + 2);\n\tif (!skb) {\n\t\tai->dev->stats.rx_dropped++;\n\t\tgoto done;\n\t}\n\n\tskb_reserve(skb, 2);  \n\tbuffer = skb_put(skb, len + hdrlen);\n\tif (test_bit(FLAG_802_11, &ai->flags)) {\n\t\tbuffer[0] = fc;\n\t\tbap_read(ai, buffer + 1, hdrlen - 2, BAP0);\n\t\tif (hdrlen == 24)\n\t\t\tbap_read(ai, tmpbuf, 6, BAP0);\n\n\t\tbap_read(ai, &v, sizeof(v), BAP0);\n\t\tgap = le16_to_cpu(v);\n\t\tif (gap) {\n\t\t\tif (gap <= 8) {\n\t\t\t\tbap_read(ai, tmpbuf, gap, BAP0);\n\t\t\t} else {\n\t\t\t\tairo_print_err(ai->dev->name, \"gaplen too \"\n\t\t\t\t\t\"big. Problems will follow...\");\n\t\t\t}\n\t\t}\n\t\tbap_read(ai, buffer + hdrlen/2, len, BAP0);\n\t} else {\n\t\tMICBuffer micbuf;\n\n\t\tbap_read(ai, buffer, ETH_ALEN * 2, BAP0);\n\t\tif (ai->micstats.enabled) {\n\t\t\tbap_read(ai, (__le16 *) &micbuf, sizeof (micbuf), BAP0);\n\t\t\tif (ntohs(micbuf.typelen) > 0x05DC)\n\t\t\t\tbap_setup(ai, fid, 0x44, BAP0);\n\t\t\telse {\n\t\t\t\tif (len <= sizeof (micbuf)) {\n\t\t\t\t\tdev_kfree_skb_irq(skb);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tlen -= sizeof(micbuf);\n\t\t\t\tskb_trim(skb, len + hdrlen);\n\t\t\t}\n\t\t}\n\n\t\tbap_read(ai, buffer + ETH_ALEN, len, BAP0);\n\t\tif (decapsulate(ai, &micbuf, (etherHead*) buffer, len))\n\t\t\tdev_kfree_skb_irq (skb);\n\t\telse\n\t\t\tsuccess = 1;\n\t}\n\n#ifdef WIRELESS_SPY\n\tif (success && (ai->spy_data.spy_number > 0)) {\n\t\tchar *sa;\n\t\tstruct iw_quality wstats;\n\n\t\t \n\t\tif (!test_bit(FLAG_802_11, &ai->flags)) {\n\t\t\tsa = (char *) buffer + 6;\n\t\t\tbap_setup(ai, fid, 8, BAP0);\n\t\t\tbap_read(ai, (__le16 *) hdr.rssi, 2, BAP0);\n\t\t} else\n\t\t\tsa = (char *) buffer + 10;\n\t\twstats.qual = hdr.rssi[0];\n\t\tif (ai->rssi)\n\t\t\twstats.level = 0x100 - ai->rssi[hdr.rssi[1]].rssidBm;\n\t\telse\n\t\t\twstats.level = (hdr.rssi[1] + 321) / 2;\n\t\twstats.noise = ai->wstats.qual.noise;\n\t\twstats.updated =  IW_QUAL_LEVEL_UPDATED\n\t\t\t\t| IW_QUAL_QUAL_UPDATED\n\t\t\t\t| IW_QUAL_DBM;\n\t\t \n\t\twireless_spy_update(ai->dev, sa, &wstats);\n\t}\n#endif  \n\ndone:\n\tOUT4500(ai, EVACK, EV_RX);\n\n\tif (success) {\n\t\tif (test_bit(FLAG_802_11, &ai->flags)) {\n\t\t\tskb_reset_mac_header(skb);\n\t\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\t\tskb->dev = ai->wifidev;\n\t\t\tskb->protocol = htons(ETH_P_802_2);\n\t\t} else\n\t\t\tskb->protocol = eth_type_trans(skb, ai->dev);\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\n\t\tnetif_rx(skb);\n\t}\n}\n\nstatic void airo_handle_tx(struct airo_info *ai, u16 status)\n{\n\tint i, index = -1;\n\tu16 fid;\n\n\tif (test_bit(FLAG_MPI, &ai->flags)) {\n\t\tunsigned long flags;\n\n\t\tif (status & EV_TXEXC)\n\t\t\tget_tx_error(ai, -1);\n\n\t\tspin_lock_irqsave(&ai->aux_lock, flags);\n\t\tif (!skb_queue_empty(&ai->txq)) {\n\t\t\tspin_unlock_irqrestore(&ai->aux_lock, flags);\n\t\t\tmpi_send_packet(ai->dev);\n\t\t} else {\n\t\t\tclear_bit(FLAG_PENDING_XMIT, &ai->flags);\n\t\t\tspin_unlock_irqrestore(&ai->aux_lock, flags);\n\t\t\tnetif_wake_queue(ai->dev);\n\t\t}\n\t\tOUT4500(ai, EVACK, status & (EV_TX | EV_TXCPY | EV_TXEXC));\n\t\treturn;\n\t}\n\n\tfid = IN4500(ai, TXCOMPLFID);\n\n\tfor (i = 0; i < MAX_FIDS; i++) {\n\t\tif ((ai->fids[i] & 0xffff) == fid)\n\t\t\tindex = i;\n\t}\n\n\tif (index != -1) {\n\t\tif (status & EV_TXEXC)\n\t\t\tget_tx_error(ai, index);\n\n\t\tOUT4500(ai, EVACK, status & (EV_TX | EV_TXEXC));\n\n\t\t \n\t\tai->fids[index] &= 0xffff;\n\t\tif (index < MAX_FIDS / 2) {\n\t\t\tif (!test_bit(FLAG_PENDING_XMIT, &ai->flags))\n\t\t\t\tnetif_wake_queue(ai->dev);\n\t\t} else {\n\t\t\tif (!test_bit(FLAG_PENDING_XMIT11, &ai->flags))\n\t\t\t\tnetif_wake_queue(ai->wifidev);\n\t\t}\n\t} else {\n\t\tOUT4500(ai, EVACK, status & (EV_TX | EV_TXCPY | EV_TXEXC));\n\t\tairo_print_err(ai->dev->name, \"Unallocated FID was used to xmit\");\n\t}\n}\n\nstatic irqreturn_t airo_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tu16 status, savedInterrupts = 0;\n\tstruct airo_info *ai = dev->ml_priv;\n\tint handled = 0;\n\n\tif (!netif_device_present(dev))\n\t\treturn IRQ_NONE;\n\n\tfor (;;) {\n\t\tstatus = IN4500(ai, EVSTAT);\n\t\tif (!(status & STATUS_INTS) || (status == 0xffff))\n\t\t\tbreak;\n\n\t\thandled = 1;\n\n\t\tif (status & EV_AWAKE) {\n\t\t\tOUT4500(ai, EVACK, EV_AWAKE);\n\t\t\tOUT4500(ai, EVACK, EV_AWAKE);\n\t\t}\n\n\t\tif (!savedInterrupts) {\n\t\t\tsavedInterrupts = IN4500(ai, EVINTEN);\n\t\t\tOUT4500(ai, EVINTEN, 0);\n\t\t}\n\n\t\tif (status & EV_MIC) {\n\t\t\tOUT4500(ai, EVACK, EV_MIC);\n\t\t\tairo_handle_cisco_mic(ai);\n\t\t}\n\n\t\tif (status & EV_LINK) {\n\t\t\t \n\t\t\tairo_handle_link(ai);\n\t\t}\n\n\t\t \n\t\tif (status & EV_RX)\n\t\t\tairo_handle_rx(ai);\n\n\t\t \n\t\tif (status & (EV_TX | EV_TXCPY | EV_TXEXC))\n\t\t\tairo_handle_tx(ai, status);\n\n\t\tif (status & ~STATUS_INTS & ~IGNORE_INTS) {\n\t\t\tairo_print_warn(ai->dev->name, \"Got weird status %x\",\n\t\t\t\tstatus & ~STATUS_INTS & ~IGNORE_INTS);\n\t\t}\n\t}\n\n\tif (savedInterrupts)\n\t\tOUT4500(ai, EVINTEN, savedInterrupts);\n\n\treturn IRQ_RETVAL(handled);\n}\n\n \n\n \nstatic void OUT4500(struct airo_info *ai, u16 reg, u16 val)\n{\n\tif (test_bit(FLAG_MPI,&ai->flags))\n\t\treg <<= 1;\n\tif (!do8bitIO)\n\t\toutw(val, ai->dev->base_addr + reg);\n\telse {\n\t\toutb(val & 0xff, ai->dev->base_addr + reg);\n\t\toutb(val >> 8, ai->dev->base_addr + reg + 1);\n\t}\n}\n\nstatic u16 IN4500(struct airo_info *ai, u16 reg)\n{\n\tunsigned short rc;\n\n\tif (test_bit(FLAG_MPI,&ai->flags))\n\t\treg <<= 1;\n\tif (!do8bitIO)\n\t\trc = inw(ai->dev->base_addr + reg);\n\telse {\n\t\trc = inb(ai->dev->base_addr + reg);\n\t\trc += ((int)inb(ai->dev->base_addr + reg + 1)) << 8;\n\t}\n\treturn rc;\n}\n\nstatic int enable_MAC(struct airo_info *ai, int lock)\n{\n\tint rc;\n\tCmd cmd;\n\tResp rsp;\n\n\t \n\tif (ai->flags & FLAG_RADIO_MASK) return SUCCESS;\n\n\tif (lock && down_interruptible(&ai->sem))\n\t\treturn -ERESTARTSYS;\n\n\tif (!test_bit(FLAG_ENABLED, &ai->flags)) {\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tcmd.cmd = MAC_ENABLE;\n\t\trc = issuecommand(ai, &cmd, &rsp, true);\n\t\tif (rc == SUCCESS)\n\t\t\tset_bit(FLAG_ENABLED, &ai->flags);\n\t} else\n\t\trc = SUCCESS;\n\n\tif (lock)\n\t    up(&ai->sem);\n\n\tif (rc)\n\t\tairo_print_err(ai->dev->name, \"Cannot enable MAC\");\n\telse if ((rsp.status & 0xFF00) != 0) {\n\t\tairo_print_err(ai->dev->name, \"Bad MAC enable reason=%x, \"\n\t\t\t\"rid=%x, offset=%d\", rsp.rsp0, rsp.rsp1, rsp.rsp2);\n\t\trc = ERROR;\n\t}\n\treturn rc;\n}\n\nstatic void disable_MAC(struct airo_info *ai, int lock)\n{\n        Cmd cmd;\n\tResp rsp;\n\n\tif (lock == 1 && down_interruptible(&ai->sem))\n\t\treturn;\n\n\tif (test_bit(FLAG_ENABLED, &ai->flags)) {\n\t\tif (lock != 2)  \n\t\t\tnetif_carrier_off(ai->dev);\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tcmd.cmd = MAC_DISABLE;  \n\t\tissuecommand(ai, &cmd, &rsp, true);\n\t\tclear_bit(FLAG_ENABLED, &ai->flags);\n\t}\n\tif (lock == 1)\n\t\tup(&ai->sem);\n}\n\nstatic void enable_interrupts(struct airo_info *ai)\n{\n\t \n\tOUT4500(ai, EVINTEN, STATUS_INTS);\n}\n\nstatic void disable_interrupts(struct airo_info *ai)\n{\n\tOUT4500(ai, EVINTEN, 0);\n}\n\nstatic void mpi_receive_802_3(struct airo_info *ai)\n{\n\tRxFid rxd;\n\tint len = 0;\n\tstruct sk_buff *skb;\n\tchar *buffer;\n\tint off = 0;\n\tMICBuffer micbuf;\n\n\tmemcpy_fromio(&rxd, ai->rxfids[0].card_ram_off, sizeof(rxd));\n\t \n\tif (rxd.rdy && rxd.valid == 0) {\n\t\tlen = rxd.len + 12;\n\t\tif (len < 12 || len > 2048)\n\t\t\tgoto badrx;\n\n\t\tskb = dev_alloc_skb(len);\n\t\tif (!skb) {\n\t\t\tai->dev->stats.rx_dropped++;\n\t\t\tgoto badrx;\n\t\t}\n\t\tbuffer = skb_put(skb, len);\n\t\tmemcpy(buffer, ai->rxfids[0].virtual_host_addr, ETH_ALEN * 2);\n\t\tif (ai->micstats.enabled) {\n\t\t\tmemcpy(&micbuf,\n\t\t\t\tai->rxfids[0].virtual_host_addr + ETH_ALEN * 2,\n\t\t\t\tsizeof(micbuf));\n\t\t\tif (ntohs(micbuf.typelen) <= 0x05DC) {\n\t\t\t\tif (len <= sizeof(micbuf) + ETH_ALEN * 2)\n\t\t\t\t\tgoto badmic;\n\n\t\t\t\toff = sizeof(micbuf);\n\t\t\t\tskb_trim (skb, len - off);\n\t\t\t}\n\t\t}\n\t\tmemcpy(buffer + ETH_ALEN * 2,\n\t\t\tai->rxfids[0].virtual_host_addr + ETH_ALEN * 2 + off,\n\t\t\tlen - ETH_ALEN * 2 - off);\n\t\tif (decapsulate (ai, &micbuf, (etherHead*)buffer, len - off - ETH_ALEN * 2)) {\nbadmic:\n\t\t\tdev_kfree_skb_irq (skb);\n\t\t\tgoto badrx;\n\t\t}\n#ifdef WIRELESS_SPY\n\t\tif (ai->spy_data.spy_number > 0) {\n\t\t\tchar *sa;\n\t\t\tstruct iw_quality wstats;\n\t\t\t \n\t\t\tsa = buffer + ETH_ALEN;\n\t\t\twstats.qual = 0;  \n\t\t\twstats.level = 0;\n\t\t\twstats.updated = 0;\n\t\t\t \n\t\t\twireless_spy_update(ai->dev, sa, &wstats);\n\t\t}\n#endif  \n\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tskb->protocol = eth_type_trans(skb, ai->dev);\n\t\tnetif_rx(skb);\n\t}\nbadrx:\n\tif (rxd.valid == 0) {\n\t\trxd.valid = 1;\n\t\trxd.rdy = 0;\n\t\trxd.len = PKTSIZE;\n\t\tmemcpy_toio(ai->rxfids[0].card_ram_off, &rxd, sizeof(rxd));\n\t}\n}\n\nstatic void mpi_receive_802_11(struct airo_info *ai)\n{\n\tRxFid rxd;\n\tstruct sk_buff *skb = NULL;\n\tu16 len, hdrlen = 0;\n\t__le16 fc;\n\tstruct rx_hdr hdr;\n\tu16 gap;\n\tu16 *buffer;\n\tchar *ptr = ai->rxfids[0].virtual_host_addr + 4;\n\n\tmemcpy_fromio(&rxd, ai->rxfids[0].card_ram_off, sizeof(rxd));\n\tmemcpy ((char *)&hdr, ptr, sizeof(hdr));\n\tptr += sizeof(hdr);\n\t \n\tif (le16_to_cpu(hdr.status) & 2)\n\t\thdr.len = 0;\n\tif (ai->wifidev == NULL)\n\t\thdr.len = 0;\n\tlen = le16_to_cpu(hdr.len);\n\tif (len > AIRO_DEF_MTU) {\n\t\tairo_print_err(ai->dev->name, \"Bad size %d\", len);\n\t\tgoto badrx;\n\t}\n\tif (len == 0)\n\t\tgoto badrx;\n\n\tfc = get_unaligned((__le16 *)ptr);\n\thdrlen = header_len(fc);\n\n\tskb = dev_alloc_skb(len + hdrlen + 2);\n\tif (!skb) {\n\t\tai->dev->stats.rx_dropped++;\n\t\tgoto badrx;\n\t}\n\tbuffer = skb_put(skb, len + hdrlen);\n\tmemcpy ((char *)buffer, ptr, hdrlen);\n\tptr += hdrlen;\n\tif (hdrlen == 24)\n\t\tptr += 6;\n\tgap = get_unaligned_le16(ptr);\n\tptr += sizeof(__le16);\n\tif (gap) {\n\t\tif (gap <= 8)\n\t\t\tptr += gap;\n\t\telse\n\t\t\tairo_print_err(ai->dev->name,\n\t\t\t    \"gaplen too big. Problems will follow...\");\n\t}\n\tmemcpy ((char *)buffer + hdrlen, ptr, len);\n\tptr += len;\n#ifdef IW_WIRELESS_SPY\t   \n\tif (ai->spy_data.spy_number > 0) {\n\t\tchar *sa;\n\t\tstruct iw_quality wstats;\n\t\t \n\t\tsa = (char*)buffer + 10;\n\t\twstats.qual = hdr.rssi[0];\n\t\tif (ai->rssi)\n\t\t\twstats.level = 0x100 - ai->rssi[hdr.rssi[1]].rssidBm;\n\t\telse\n\t\t\twstats.level = (hdr.rssi[1] + 321) / 2;\n\t\twstats.noise = ai->wstats.qual.noise;\n\t\twstats.updated = IW_QUAL_QUAL_UPDATED\n\t\t\t| IW_QUAL_LEVEL_UPDATED\n\t\t\t| IW_QUAL_DBM;\n\t\t \n\t\twireless_spy_update(ai->dev, sa, &wstats);\n\t}\n#endif  \n\tskb_reset_mac_header(skb);\n\tskb->pkt_type = PACKET_OTHERHOST;\n\tskb->dev = ai->wifidev;\n\tskb->protocol = htons(ETH_P_802_2);\n\tskb->ip_summed = CHECKSUM_NONE;\n\tnetif_rx(skb);\n\nbadrx:\n\tif (rxd.valid == 0) {\n\t\trxd.valid = 1;\n\t\trxd.rdy = 0;\n\t\trxd.len = PKTSIZE;\n\t\tmemcpy_toio(ai->rxfids[0].card_ram_off, &rxd, sizeof(rxd));\n\t}\n}\n\nstatic inline void set_auth_type(struct airo_info *local, int auth_type)\n{\n\tlocal->config.authType = auth_type;\n\t \n\tif (auth_type == AUTH_OPEN || auth_type == AUTH_ENCRYPT)\n\t\tlocal->last_auth = auth_type;\n}\n\nstatic int noinline_for_stack airo_readconfig(struct airo_info *ai,\n\t\t\t\t\t      struct net_device *dev, int lock)\n{\n\tint i, status;\n\t \n\ttdsRssiRid rssi_rid;\n\tCapabilityRid cap_rid;\n\n\tkfree(ai->SSID);\n\tai->SSID = NULL;\n\t \n\tstatus = readConfigRid(ai, lock);\n\tif (status != SUCCESS) return ERROR;\n\n\tstatus = readCapabilityRid(ai, &cap_rid, lock);\n\tif (status != SUCCESS) return ERROR;\n\n\tstatus = PC4500_readrid(ai, RID_RSSI, &rssi_rid, sizeof(rssi_rid), lock);\n\tif (status == SUCCESS) {\n\t\tif (ai->rssi || (ai->rssi = kmalloc(512, GFP_KERNEL)) != NULL)\n\t\t\tmemcpy(ai->rssi, (u8*)&rssi_rid + 2, 512);  \n\t}\n\telse {\n\t\tkfree(ai->rssi);\n\t\tai->rssi = NULL;\n\t\tif (cap_rid.softCap & cpu_to_le16(8))\n\t\t\tai->config.rmode |= RXMODE_NORMALIZED_RSSI;\n\t\telse\n\t\t\tairo_print_warn(ai->dev->name, \"unknown received signal \"\n\t\t\t\t\t\"level scale\");\n\t}\n\tai->config.opmode = adhoc ? MODE_STA_IBSS : MODE_STA_ESS;\n\tset_auth_type(ai, AUTH_OPEN);\n\tai->config.modulation = MOD_CCK;\n\n\tif (le16_to_cpu(cap_rid.len) >= sizeof(cap_rid) &&\n\t    (cap_rid.extSoftCap & cpu_to_le16(1)) &&\n\t    micsetup(ai) == SUCCESS) {\n\t\tai->config.opmode |= MODE_MIC;\n\t\tset_bit(FLAG_MIC_CAPABLE, &ai->flags);\n\t}\n\n\t \n\teth_hw_addr_set(dev, ai->config.macAddr);\n\n\t \n\tif (rates[0]) {\n\t\tmemset(ai->config.rates, 0, sizeof(ai->config.rates));\n\t\tfor (i = 0; i < 8 && rates[i]; i++) {\n\t\t\tai->config.rates[i] = rates[i];\n\t\t}\n\t}\n\tset_bit (FLAG_COMMIT, &ai->flags);\n\n\treturn SUCCESS;\n}\n\n\nstatic u16 setup_card(struct airo_info *ai, struct net_device *dev, int lock)\n{\n\tCmd cmd;\n\tResp rsp;\n\tint status;\n\tSsidRid mySsid;\n\t__le16 lastindex;\n\tWepKeyRid wkr;\n\tint rc;\n\n\tmemset(&mySsid, 0, sizeof(mySsid));\n\tkfree (ai->flash);\n\tai->flash = NULL;\n\n\t \n\tcmd.cmd = NOP;\n\tcmd.parm0 = cmd.parm1 = cmd.parm2 = 0;\n\tif (lock && down_interruptible(&ai->sem))\n\t\treturn ERROR;\n\tif (issuecommand(ai, &cmd, &rsp, true) != SUCCESS) {\n\t\tif (lock)\n\t\t\tup(&ai->sem);\n\t\treturn ERROR;\n\t}\n\tdisable_MAC(ai, 0);\n\n\t \n\tif (!test_bit(FLAG_MPI,&ai->flags)) {\n\t\tcmd.cmd = CMD_ENABLEAUX;\n\t\tif (issuecommand(ai, &cmd, &rsp, true) != SUCCESS) {\n\t\t\tif (lock)\n\t\t\t\tup(&ai->sem);\n\t\t\tairo_print_err(ai->dev->name, \"Error checking for AUX port\");\n\t\t\treturn ERROR;\n\t\t}\n\t\tif (!aux_bap || rsp.status & 0xff00) {\n\t\t\tai->bap_read = fast_bap_read;\n\t\t\tairo_print_dbg(ai->dev->name, \"Doing fast bap_reads\");\n\t\t} else {\n\t\t\tai->bap_read = aux_bap_read;\n\t\t\tairo_print_dbg(ai->dev->name, \"Doing AUX bap_reads\");\n\t\t}\n\t}\n\tif (lock)\n\t\tup(&ai->sem);\n\tif (ai->config.len == 0) {\n\t\tstatus = airo_readconfig(ai, dev, lock);\n\t\tif (status != SUCCESS)\n\t\t\treturn ERROR;\n\t}\n\n\t \n\tif (ssids[0]) {\n\t\tint i;\n\t\tfor (i = 0; i < 3 && ssids[i]; i++) {\n\t\t\tsize_t len = strlen(ssids[i]);\n\t\t\tif (len > 32)\n\t\t\t\tlen = 32;\n\t\t\tmySsid.ssids[i].len = cpu_to_le16(len);\n\t\t\tmemcpy(mySsid.ssids[i].ssid, ssids[i], len);\n\t\t}\n\t\tmySsid.len = cpu_to_le16(sizeof(mySsid));\n\t}\n\n\tstatus = writeConfigRid(ai, lock);\n\tif (status != SUCCESS) return ERROR;\n\n\t \n\tif (ssids[0]) {\n\t\tstatus = writeSsidRid(ai, &mySsid, lock);\n\t\tif (status != SUCCESS) return ERROR;\n\t}\n\n\tstatus = enable_MAC(ai, lock);\n\tif (status != SUCCESS)\n\t\treturn ERROR;\n\n\t \n\trc = readWepKeyRid(ai, &wkr, 1, lock);\n\tif (rc == SUCCESS) do {\n\t\tlastindex = wkr.kindex;\n\t\tif (wkr.kindex == cpu_to_le16(0xffff)) {\n\t\t\tai->defindex = wkr.mac[0];\n\t\t}\n\t\trc = readWepKeyRid(ai, &wkr, 0, lock);\n\t} while (lastindex != wkr.kindex);\n\n\ttry_auto_wep(ai);\n\n\treturn SUCCESS;\n}\n\nstatic u16 issuecommand(struct airo_info *ai, Cmd *pCmd, Resp *pRsp,\n\t\t\tbool may_sleep)\n{\n         \n\tint max_tries = 600000;\n\n\tif (IN4500(ai, EVSTAT) & EV_CMD)\n\t\tOUT4500(ai, EVACK, EV_CMD);\n\n\tOUT4500(ai, PARAM0, pCmd->parm0);\n\tOUT4500(ai, PARAM1, pCmd->parm1);\n\tOUT4500(ai, PARAM2, pCmd->parm2);\n\tOUT4500(ai, COMMAND, pCmd->cmd);\n\n\twhile (max_tries-- && (IN4500(ai, EVSTAT) & EV_CMD) == 0) {\n\t\tif ((IN4500(ai, COMMAND)) == pCmd->cmd)\n\t\t\t \n\t\t\tOUT4500(ai, COMMAND, pCmd->cmd);\n\t\tif (may_sleep && (max_tries & 255) == 0)\n\t\t\tcond_resched();\n\t}\n\n\tif (max_tries == -1) {\n\t\tairo_print_err(ai->dev->name,\n\t\t\t\"Max tries exceeded when issuing command\");\n\t\tif (IN4500(ai, COMMAND) & COMMAND_BUSY)\n\t\t\tOUT4500(ai, EVACK, EV_CLEARCOMMANDBUSY);\n\t\treturn ERROR;\n\t}\n\n\t \n\tpRsp->status = IN4500(ai, STATUS);\n\tpRsp->rsp0 = IN4500(ai, RESP0);\n\tpRsp->rsp1 = IN4500(ai, RESP1);\n\tpRsp->rsp2 = IN4500(ai, RESP2);\n\tif ((pRsp->status & 0xff00)!=0 && pCmd->cmd != CMD_SOFTRESET)\n\t\tairo_print_err(ai->dev->name,\n\t\t\t\"cmd:%x status:%x rsp0:%x rsp1:%x rsp2:%x\",\n\t\t\tpCmd->cmd, pRsp->status, pRsp->rsp0, pRsp->rsp1,\n\t\t\tpRsp->rsp2);\n\n\t \n\tif (IN4500(ai, COMMAND) & COMMAND_BUSY) {\n\t\tOUT4500(ai, EVACK, EV_CLEARCOMMANDBUSY);\n\t}\n\t \n\tOUT4500(ai, EVACK, EV_CMD);\n\n\treturn SUCCESS;\n}\n\n \nstatic int bap_setup(struct airo_info *ai, u16 rid, u16 offset, int whichbap)\n{\n\tint timeout = 50;\n\tint max_tries = 3;\n\n\tOUT4500(ai, SELECT0+whichbap, rid);\n\tOUT4500(ai, OFFSET0+whichbap, offset);\n\twhile (1) {\n\t\tint status = IN4500(ai, OFFSET0+whichbap);\n\t\tif (status & BAP_BUSY) {\n                         \n\t\t\tif (timeout--) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (status & BAP_ERR) {\n\t\t\t \n\t\t\tairo_print_err(ai->dev->name, \"BAP error %x %d\",\n\t\t\t\tstatus, whichbap);\n\t\t\treturn ERROR;\n\t\t} else if (status & BAP_DONE) {  \n\t\t\treturn SUCCESS;\n\t\t}\n\t\tif (!(max_tries--)) {\n\t\t\tairo_print_err(ai->dev->name,\n\t\t\t\t\"BAP setup error too many retries\\n\");\n\t\t\treturn ERROR;\n\t\t}\n\t\t \n\t\tOUT4500(ai, SELECT0+whichbap, rid);\n\t\tOUT4500(ai, OFFSET0+whichbap, offset);\n\t\ttimeout = 50;\n\t}\n}\n\n \nstatic u16 aux_setup(struct airo_info *ai, u16 page,\n\t\t     u16 offset, u16 *len)\n{\n\tu16 next;\n\n\tOUT4500(ai, AUXPAGE, page);\n\tOUT4500(ai, AUXOFF, 0);\n\tnext = IN4500(ai, AUXDATA);\n\t*len = IN4500(ai, AUXDATA)&0xff;\n\tif (offset != 4) OUT4500(ai, AUXOFF, offset);\n\treturn next;\n}\n\n \nstatic int aux_bap_read(struct airo_info *ai, __le16 *pu16Dst,\n\t\t\tint bytelen, int whichbap)\n{\n\tu16 len;\n\tu16 page;\n\tu16 offset;\n\tu16 next;\n\tint words;\n\tint i;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ai->aux_lock, flags);\n\tpage = IN4500(ai, SWS0+whichbap);\n\toffset = IN4500(ai, SWS2+whichbap);\n\tnext = aux_setup(ai, page, offset, &len);\n\twords = (bytelen+1)>>1;\n\n\tfor (i = 0; i<words;) {\n\t\tint count;\n\t\tcount = (len>>1) < (words-i) ? (len>>1) : (words-i);\n\t\tif (!do8bitIO)\n\t\t\tinsw(ai->dev->base_addr+DATA0+whichbap,\n\t\t\t      pu16Dst+i, count);\n\t\telse\n\t\t\tinsb(ai->dev->base_addr+DATA0+whichbap,\n\t\t\t      pu16Dst+i, count << 1);\n\t\ti += count;\n\t\tif (i<words) {\n\t\t\tnext = aux_setup(ai, next, 4, &len);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ai->aux_lock, flags);\n\treturn SUCCESS;\n}\n\n\n \nstatic int fast_bap_read(struct airo_info *ai, __le16 *pu16Dst,\n\t\t\t int bytelen, int whichbap)\n{\n\tbytelen = (bytelen + 1) & (~1);  \n\tif (!do8bitIO)\n\t\tinsw(ai->dev->base_addr+DATA0+whichbap, pu16Dst, bytelen>>1);\n\telse\n\t\tinsb(ai->dev->base_addr+DATA0+whichbap, pu16Dst, bytelen);\n\treturn SUCCESS;\n}\n\n \nstatic int bap_write(struct airo_info *ai, const __le16 *pu16Src,\n\t\t     int bytelen, int whichbap)\n{\n\tbytelen = (bytelen + 1) & (~1);  \n\tif (!do8bitIO)\n\t\toutsw(ai->dev->base_addr+DATA0+whichbap,\n\t\t       pu16Src, bytelen>>1);\n\telse\n\t\toutsb(ai->dev->base_addr+DATA0+whichbap, pu16Src, bytelen);\n\treturn SUCCESS;\n}\n\nstatic int PC4500_accessrid(struct airo_info *ai, u16 rid, u16 accmd)\n{\n\tCmd cmd;  \n\tResp rsp;  \n\tu16 status;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.cmd = accmd;\n\tcmd.parm0 = rid;\n\tstatus = issuecommand(ai, &cmd, &rsp, true);\n\tif (status != 0) return status;\n\tif ((rsp.status & 0x7F00) != 0) {\n\t\treturn (accmd << 8) + (rsp.rsp0 & 0xFF);\n\t}\n\treturn 0;\n}\n\n \nstatic int PC4500_readrid(struct airo_info *ai, u16 rid, void *pBuf, int len, int lock)\n{\n\tu16 status;\n        int rc = SUCCESS;\n\n\tif (lock) {\n\t\tif (down_interruptible(&ai->sem))\n\t\t\treturn ERROR;\n\t}\n\tif (test_bit(FLAG_MPI,&ai->flags)) {\n\t\tCmd cmd;\n\t\tResp rsp;\n\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tmemset(&rsp, 0, sizeof(rsp));\n\t\tai->config_desc.rid_desc.valid = 1;\n\t\tai->config_desc.rid_desc.len = RIDSIZE;\n\t\tai->config_desc.rid_desc.rid = 0;\n\t\tai->config_desc.rid_desc.host_addr = ai->ridbus;\n\n\t\tcmd.cmd = CMD_ACCESS;\n\t\tcmd.parm0 = rid;\n\n\t\tmemcpy_toio(ai->config_desc.card_ram_off,\n\t\t\t&ai->config_desc.rid_desc, sizeof(Rid));\n\n\t\trc = issuecommand(ai, &cmd, &rsp, true);\n\n\t\tif (rsp.status & 0x7f00)\n\t\t\trc = rsp.rsp0;\n\t\tif (!rc)\n\t\t\tmemcpy(pBuf, ai->config_desc.virtual_host_addr, len);\n\t\tgoto done;\n\t} else {\n\t\tif ((status = PC4500_accessrid(ai, rid, CMD_ACCESS))!=SUCCESS) {\n\t                rc = status;\n\t                goto done;\n\t        }\n\t\tif (bap_setup(ai, rid, 0, BAP1) != SUCCESS) {\n\t\t\trc = ERROR;\n\t                goto done;\n\t        }\n\t\t \n\t\tbap_read(ai, pBuf, 2, BAP1);\n\t\t \n\t\tlen = min(len, (int)le16_to_cpu(*(__le16*)pBuf)) - 2;\n\n\t\tif (len <= 2) {\n\t\t\tairo_print_err(ai->dev->name,\n\t\t\t\t\"Rid %x has a length of %d which is too short\",\n\t\t\t\t(int)rid, (int)len);\n\t\t\trc = ERROR;\n\t                goto done;\n\t\t}\n\t\t \n\t\trc = bap_read(ai, ((__le16*)pBuf)+1, len, BAP1);\n\t}\ndone:\n\tif (lock)\n\t\tup(&ai->sem);\n\treturn rc;\n}\n\n \nstatic int PC4500_writerid(struct airo_info *ai, u16 rid,\n\t\t\t   const void *pBuf, int len, int lock)\n{\n\tu16 status;\n\tint rc = SUCCESS;\n\n\t*(__le16*)pBuf = cpu_to_le16((u16)len);\n\n\tif (lock) {\n\t\tif (down_interruptible(&ai->sem))\n\t\t\treturn ERROR;\n\t}\n\tif (test_bit(FLAG_MPI,&ai->flags)) {\n\t\tCmd cmd;\n\t\tResp rsp;\n\n\t\tif (test_bit(FLAG_ENABLED, &ai->flags) && (RID_WEP_TEMP != rid))\n\t\t\tairo_print_err(ai->dev->name,\n\t\t\t\t\"%s: MAC should be disabled (rid=%04x)\",\n\t\t\t\t__func__, rid);\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tmemset(&rsp, 0, sizeof(rsp));\n\n\t\tai->config_desc.rid_desc.valid = 1;\n\t\tai->config_desc.rid_desc.len = *((u16 *)pBuf);\n\t\tai->config_desc.rid_desc.rid = 0;\n\n\t\tcmd.cmd = CMD_WRITERID;\n\t\tcmd.parm0 = rid;\n\n\t\tmemcpy_toio(ai->config_desc.card_ram_off,\n\t\t\t&ai->config_desc.rid_desc, sizeof(Rid));\n\n\t\tif (len < 4 || len > 2047) {\n\t\t\tairo_print_err(ai->dev->name, \"%s: len=%d\", __func__, len);\n\t\t\trc = -1;\n\t\t} else {\n\t\t\tmemcpy(ai->config_desc.virtual_host_addr,\n\t\t\t\tpBuf, len);\n\n\t\t\trc = issuecommand(ai, &cmd, &rsp, true);\n\t\t\tif ((rc & 0xff00) != 0) {\n\t\t\t\tairo_print_err(ai->dev->name, \"%s: Write rid Error %d\",\n\t\t\t\t\t\t__func__, rc);\n\t\t\t\tairo_print_err(ai->dev->name, \"%s: Cmd=%04x\",\n\t\t\t\t\t\t__func__, cmd.cmd);\n\t\t\t}\n\n\t\t\tif ((rsp.status & 0x7f00))\n\t\t\t\trc = rsp.rsp0;\n\t\t}\n\t} else {\n\t\t \n\t\tif ((status = PC4500_accessrid(ai, rid, CMD_ACCESS)) != 0) {\n\t                rc = status;\n\t                goto done;\n\t        }\n\t\t \n\t\tif (bap_setup(ai, rid, 0, BAP1) != SUCCESS) {\n\t                rc = ERROR;\n\t                goto done;\n\t        }\n\t\tbap_write(ai, pBuf, len, BAP1);\n\t\t \n\t\trc = PC4500_accessrid(ai, rid, 0x100|CMD_ACCESS);\n\t}\ndone:\n\tif (lock)\n\t\tup(&ai->sem);\n        return rc;\n}\n\n \nstatic u16 transmit_allocate(struct airo_info *ai, int lenPayload, int raw)\n{\n\tunsigned int loop = 3000;\n\tCmd cmd;\n\tResp rsp;\n\tu16 txFid;\n\t__le16 txControl;\n\n\tcmd.cmd = CMD_ALLOCATETX;\n\tcmd.parm0 = lenPayload;\n\tif (down_interruptible(&ai->sem))\n\t\treturn ERROR;\n\tif (issuecommand(ai, &cmd, &rsp, true) != SUCCESS) {\n\t\ttxFid = ERROR;\n\t\tgoto done;\n\t}\n\tif ((rsp.status & 0xFF00) != 0) {\n\t\ttxFid = ERROR;\n\t\tgoto done;\n\t}\n\t \n\twhile (((IN4500(ai, EVSTAT) & EV_ALLOC) == 0) && --loop);\n\tif (!loop) {\n\t\ttxFid = ERROR;\n\t\tgoto done;\n\t}\n\n\t \n\ttxFid = IN4500(ai, TXALLOCFID);\n\tOUT4500(ai, EVACK, EV_ALLOC);\n\n\t \n\t \n\tif (raw)\n\t\ttxControl = cpu_to_le16(TXCTL_TXOK | TXCTL_TXEX | TXCTL_802_11\n\t\t\t| TXCTL_ETHERNET | TXCTL_NORELEASE);\n\telse\n\t\ttxControl = cpu_to_le16(TXCTL_TXOK | TXCTL_TXEX | TXCTL_802_3\n\t\t\t| TXCTL_ETHERNET | TXCTL_NORELEASE);\n\tif (bap_setup(ai, txFid, 0x0008, BAP1) != SUCCESS)\n\t\ttxFid = ERROR;\n\telse\n\t\tbap_write(ai, &txControl, sizeof(txControl), BAP1);\n\ndone:\n\tup(&ai->sem);\n\n\treturn txFid;\n}\n\n \nstatic int transmit_802_3_packet(struct airo_info *ai, int len, char *pPacket,\n\t\t\t\t bool may_sleep)\n{\n\t__le16 payloadLen;\n\tCmd cmd;\n\tResp rsp;\n\tint miclen = 0;\n\tu16 txFid = len;\n\tMICBuffer pMic;\n\n\tlen >>= 16;\n\n\tif (len <= ETH_ALEN * 2) {\n\t\tairo_print_warn(ai->dev->name, \"Short packet %d\", len);\n\t\treturn ERROR;\n\t}\n\tlen -= ETH_ALEN * 2;\n\n\tif (test_bit(FLAG_MIC_CAPABLE, &ai->flags) && ai->micstats.enabled &&\n\t    (ntohs(((__be16 *)pPacket)[6]) != 0x888E)) {\n\t\tif (encapsulate(ai, (etherHead *)pPacket,&pMic, len) != SUCCESS)\n\t\t\treturn ERROR;\n\t\tmiclen = sizeof(pMic);\n\t}\n\t \n\t \n\tif (bap_setup(ai, txFid, 0x0036, BAP1) != SUCCESS) return ERROR;\n\t \n\tpayloadLen = cpu_to_le16(len + miclen);\n\tbap_write(ai, &payloadLen, sizeof(payloadLen), BAP1);\n\tbap_write(ai, (__le16*)pPacket, sizeof(etherHead), BAP1);\n\tif (miclen)\n\t\tbap_write(ai, (__le16*)&pMic, miclen, BAP1);\n\tbap_write(ai, (__le16*)(pPacket + sizeof(etherHead)), len, BAP1);\n\t \n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.cmd = CMD_TRANSMIT;\n\tcmd.parm0 = txFid;\n\tif (issuecommand(ai, &cmd, &rsp, may_sleep) != SUCCESS)\n\t\treturn ERROR;\n\tif ((rsp.status & 0xFF00) != 0) return ERROR;\n\treturn SUCCESS;\n}\n\nstatic int transmit_802_11_packet(struct airo_info *ai, int len, char *pPacket,\n\t\t\t\t  bool may_sleep)\n{\n\t__le16 fc, payloadLen;\n\tCmd cmd;\n\tResp rsp;\n\tint hdrlen;\n\tstatic u8 tail[(30-10) + 2 + 6] = {[30-10] = 6};\n\t \n\tu16 txFid = len;\n\tlen >>= 16;\n\n\tfc = *(__le16*)pPacket;\n\thdrlen = header_len(fc);\n\n\tif (len < hdrlen) {\n\t\tairo_print_warn(ai->dev->name, \"Short packet %d\", len);\n\t\treturn ERROR;\n\t}\n\n\t \n\tif (bap_setup(ai, txFid, 6, BAP1) != SUCCESS) return ERROR;\n\t \n\tpayloadLen = cpu_to_le16(len-hdrlen);\n\tbap_write(ai, &payloadLen, sizeof(payloadLen), BAP1);\n\tif (bap_setup(ai, txFid, 0x0014, BAP1) != SUCCESS) return ERROR;\n\tbap_write(ai, (__le16 *)pPacket, hdrlen, BAP1);\n\tbap_write(ai, (__le16 *)(tail + (hdrlen - 10)), 38 - hdrlen, BAP1);\n\n\tbap_write(ai, (__le16 *)(pPacket + hdrlen), len - hdrlen, BAP1);\n\t \n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.cmd = CMD_TRANSMIT;\n\tcmd.parm0 = txFid;\n\tif (issuecommand(ai, &cmd, &rsp, may_sleep) != SUCCESS)\n\t\treturn ERROR;\n\tif ((rsp.status & 0xFF00) != 0) return ERROR;\n\treturn SUCCESS;\n}\n\n \n\nstatic ssize_t proc_read(struct file *file,\n\t\t\t  char __user *buffer,\n\t\t\t  size_t len,\n\t\t\t  loff_t *offset);\n\nstatic ssize_t proc_write(struct file *file,\n\t\t\t   const char __user *buffer,\n\t\t\t   size_t len,\n\t\t\t   loff_t *offset);\nstatic int proc_close(struct inode *inode, struct file *file);\n\nstatic int proc_stats_open(struct inode *inode, struct file *file);\nstatic int proc_statsdelta_open(struct inode *inode, struct file *file);\nstatic int proc_status_open(struct inode *inode, struct file *file);\nstatic int proc_SSID_open(struct inode *inode, struct file *file);\nstatic int proc_APList_open(struct inode *inode, struct file *file);\nstatic int proc_BSSList_open(struct inode *inode, struct file *file);\nstatic int proc_config_open(struct inode *inode, struct file *file);\nstatic int proc_wepkey_open(struct inode *inode, struct file *file);\n\nstatic const struct proc_ops proc_statsdelta_ops = {\n\t.proc_read\t= proc_read,\n\t.proc_open\t= proc_statsdelta_open,\n\t.proc_release\t= proc_close,\n\t.proc_lseek\t= default_llseek,\n};\n\nstatic const struct proc_ops proc_stats_ops = {\n\t.proc_read\t= proc_read,\n\t.proc_open\t= proc_stats_open,\n\t.proc_release\t= proc_close,\n\t.proc_lseek\t= default_llseek,\n};\n\nstatic const struct proc_ops proc_status_ops = {\n\t.proc_read\t= proc_read,\n\t.proc_open\t= proc_status_open,\n\t.proc_release\t= proc_close,\n\t.proc_lseek\t= default_llseek,\n};\n\nstatic const struct proc_ops proc_SSID_ops = {\n\t.proc_read\t= proc_read,\n\t.proc_write\t= proc_write,\n\t.proc_open\t= proc_SSID_open,\n\t.proc_release\t= proc_close,\n\t.proc_lseek\t= default_llseek,\n};\n\nstatic const struct proc_ops proc_BSSList_ops = {\n\t.proc_read\t= proc_read,\n\t.proc_write\t= proc_write,\n\t.proc_open\t= proc_BSSList_open,\n\t.proc_release\t= proc_close,\n\t.proc_lseek\t= default_llseek,\n};\n\nstatic const struct proc_ops proc_APList_ops = {\n\t.proc_read\t= proc_read,\n\t.proc_write\t= proc_write,\n\t.proc_open\t= proc_APList_open,\n\t.proc_release\t= proc_close,\n\t.proc_lseek\t= default_llseek,\n};\n\nstatic const struct proc_ops proc_config_ops = {\n\t.proc_read\t= proc_read,\n\t.proc_write\t= proc_write,\n\t.proc_open\t= proc_config_open,\n\t.proc_release\t= proc_close,\n\t.proc_lseek\t= default_llseek,\n};\n\nstatic const struct proc_ops proc_wepkey_ops = {\n\t.proc_read\t= proc_read,\n\t.proc_write\t= proc_write,\n\t.proc_open\t= proc_wepkey_open,\n\t.proc_release\t= proc_close,\n\t.proc_lseek\t= default_llseek,\n};\n\nstatic struct proc_dir_entry *airo_entry;\n\nstruct proc_data {\n\tint release_buffer;\n\tint readlen;\n\tchar *rbuffer;\n\tint writelen;\n\tint maxwritelen;\n\tchar *wbuffer;\n\tvoid (*on_close) (struct inode *, struct file *);\n};\n\nstatic int setup_proc_entry(struct net_device *dev,\n\t\t\t     struct airo_info *apriv)\n{\n\tstruct proc_dir_entry *entry;\n\n\t \n\tstrcpy(apriv->proc_name, dev->name);\n\tapriv->proc_entry = proc_mkdir_mode(apriv->proc_name, airo_perm,\n\t\t\t\t\t    airo_entry);\n\tif (!apriv->proc_entry)\n\t\treturn -ENOMEM;\n\tproc_set_user(apriv->proc_entry, proc_kuid, proc_kgid);\n\n\t \n\tentry = proc_create_data(\"StatsDelta\", 0444 & proc_perm,\n\t\t\t\t apriv->proc_entry, &proc_statsdelta_ops, dev);\n\tif (!entry)\n\t\tgoto fail;\n\tproc_set_user(entry, proc_kuid, proc_kgid);\n\n\t \n\tentry = proc_create_data(\"Stats\", 0444 & proc_perm,\n\t\t\t\t apriv->proc_entry, &proc_stats_ops, dev);\n\tif (!entry)\n\t\tgoto fail;\n\tproc_set_user(entry, proc_kuid, proc_kgid);\n\n\t \n\tentry = proc_create_data(\"Status\", 0444 & proc_perm,\n\t\t\t\t apriv->proc_entry, &proc_status_ops, dev);\n\tif (!entry)\n\t\tgoto fail;\n\tproc_set_user(entry, proc_kuid, proc_kgid);\n\n\t \n\tentry = proc_create_data(\"Config\", proc_perm,\n\t\t\t\t apriv->proc_entry, &proc_config_ops, dev);\n\tif (!entry)\n\t\tgoto fail;\n\tproc_set_user(entry, proc_kuid, proc_kgid);\n\n\t \n\tentry = proc_create_data(\"SSID\", proc_perm,\n\t\t\t\t apriv->proc_entry, &proc_SSID_ops, dev);\n\tif (!entry)\n\t\tgoto fail;\n\tproc_set_user(entry, proc_kuid, proc_kgid);\n\n\t \n\tentry = proc_create_data(\"APList\", proc_perm,\n\t\t\t\t apriv->proc_entry, &proc_APList_ops, dev);\n\tif (!entry)\n\t\tgoto fail;\n\tproc_set_user(entry, proc_kuid, proc_kgid);\n\n\t \n\tentry = proc_create_data(\"BSSList\", proc_perm,\n\t\t\t\t apriv->proc_entry, &proc_BSSList_ops, dev);\n\tif (!entry)\n\t\tgoto fail;\n\tproc_set_user(entry, proc_kuid, proc_kgid);\n\n\t \n\tentry = proc_create_data(\"WepKey\", proc_perm,\n\t\t\t\t apriv->proc_entry, &proc_wepkey_ops, dev);\n\tif (!entry)\n\t\tgoto fail;\n\tproc_set_user(entry, proc_kuid, proc_kgid);\n\treturn 0;\n\nfail:\n\tremove_proc_subtree(apriv->proc_name, airo_entry);\n\treturn -ENOMEM;\n}\n\nstatic int takedown_proc_entry(struct net_device *dev,\n\t\t\t\tstruct airo_info *apriv)\n{\n\tremove_proc_subtree(apriv->proc_name, airo_entry);\n\treturn 0;\n}\n\n \n\n \nstatic ssize_t proc_read(struct file *file,\n\t\t\t  char __user *buffer,\n\t\t\t  size_t len,\n\t\t\t  loff_t *offset)\n{\n\tstruct proc_data *priv = file->private_data;\n\n\tif (!priv->rbuffer)\n\t\treturn -EINVAL;\n\n\treturn simple_read_from_buffer(buffer, len, offset, priv->rbuffer,\n\t\t\t\t\tpriv->readlen);\n}\n\n \nstatic ssize_t proc_write(struct file *file,\n\t\t\t   const char __user *buffer,\n\t\t\t   size_t len,\n\t\t\t   loff_t *offset)\n{\n\tssize_t ret;\n\tstruct proc_data *priv = file->private_data;\n\n\tif (!priv->wbuffer)\n\t\treturn -EINVAL;\n\n\tret = simple_write_to_buffer(priv->wbuffer, priv->maxwritelen, offset,\n\t\t\t\t\tbuffer, len);\n\tif (ret > 0)\n\t\tpriv->writelen = max_t(int, priv->writelen, *offset);\n\n\treturn ret;\n}\n\nstatic int proc_status_open(struct inode *inode, struct file *file)\n{\n\tstruct proc_data *data;\n\tstruct net_device *dev = pde_data(inode);\n\tstruct airo_info *apriv = dev->ml_priv;\n\tCapabilityRid cap_rid;\n\tStatusRid status_rid;\n\tu16 mode;\n\tint i;\n\n\tif ((file->private_data = kzalloc(sizeof(struct proc_data), GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\tdata = file->private_data;\n\tif ((data->rbuffer = kmalloc(2048, GFP_KERNEL)) == NULL) {\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\n\treadStatusRid(apriv, &status_rid, 1);\n\treadCapabilityRid(apriv, &cap_rid, 1);\n\n\tmode = le16_to_cpu(status_rid.mode);\n\n        i = sprintf(data->rbuffer, \"Status: %s%s%s%s%s%s%s%s%s\\n\",\n                    mode & 1 ? \"CFG \": \"\",\n                    mode & 2 ? \"ACT \": \"\",\n                    mode & 0x10 ? \"SYN \": \"\",\n                    mode & 0x20 ? \"LNK \": \"\",\n                    mode & 0x40 ? \"LEAP \": \"\",\n                    mode & 0x80 ? \"PRIV \": \"\",\n                    mode & 0x100 ? \"KEY \": \"\",\n                    mode & 0x200 ? \"WEP \": \"\",\n                    mode & 0x8000 ? \"ERR \": \"\");\n\tsprintf(data->rbuffer+i, \"Mode: %x\\n\"\n\t\t \"Signal Strength: %d\\n\"\n\t\t \"Signal Quality: %d\\n\"\n\t\t \"SSID: %-.*s\\n\"\n\t\t \"AP: %-.16s\\n\"\n\t\t \"Freq: %d\\n\"\n\t\t \"BitRate: %dmbs\\n\"\n\t\t \"Driver Version: %s\\n\"\n\t\t \"Device: %s\\nManufacturer: %s\\nFirmware Version: %s\\n\"\n\t\t \"Radio type: %x\\nCountry: %x\\nHardware Version: %x\\n\"\n\t\t \"Software Version: %x\\nSoftware Subversion: %x\\n\"\n\t\t \"Boot block version: %x\\n\",\n\t\t le16_to_cpu(status_rid.mode),\n\t\t le16_to_cpu(status_rid.normalizedSignalStrength),\n\t\t le16_to_cpu(status_rid.signalQuality),\n\t\t le16_to_cpu(status_rid.SSIDlen),\n\t\t status_rid.SSID,\n\t\t status_rid.apName,\n\t\t le16_to_cpu(status_rid.channel),\n\t\t le16_to_cpu(status_rid.currentXmitRate) / 2,\n\t\t version,\n\t\t cap_rid.prodName,\n\t\t cap_rid.manName,\n\t\t cap_rid.prodVer,\n\t\t le16_to_cpu(cap_rid.radioType),\n\t\t le16_to_cpu(cap_rid.country),\n\t\t le16_to_cpu(cap_rid.hardVer),\n\t\t le16_to_cpu(cap_rid.softVer),\n\t\t le16_to_cpu(cap_rid.softSubVer),\n\t\t le16_to_cpu(cap_rid.bootBlockVer));\n\tdata->readlen = strlen(data->rbuffer);\n\treturn 0;\n}\n\nstatic int proc_stats_rid_open(struct inode*, struct file*, u16);\nstatic int proc_statsdelta_open(struct inode *inode,\n\t\t\t\t struct file *file)\n{\n\tif (file->f_mode&FMODE_WRITE) {\n\t\treturn proc_stats_rid_open(inode, file, RID_STATSDELTACLEAR);\n\t}\n\treturn proc_stats_rid_open(inode, file, RID_STATSDELTA);\n}\n\nstatic int proc_stats_open(struct inode *inode, struct file *file)\n{\n\treturn proc_stats_rid_open(inode, file, RID_STATS);\n}\n\nstatic int proc_stats_rid_open(struct inode *inode,\n\t\t\t\tstruct file *file,\n\t\t\t\tu16 rid)\n{\n\tstruct proc_data *data;\n\tstruct net_device *dev = pde_data(inode);\n\tstruct airo_info *apriv = dev->ml_priv;\n\tStatsRid stats;\n\tint i, j;\n\t__le32 *vals = stats.vals;\n\tint len;\n\n\tif ((file->private_data = kzalloc(sizeof(struct proc_data), GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\tdata = file->private_data;\n\tif ((data->rbuffer = kmalloc(4096, GFP_KERNEL)) == NULL) {\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\n\treadStatsRid(apriv, &stats, rid, 1);\n\tlen = le16_to_cpu(stats.len);\n\n        j = 0;\n\tfor (i = 0; statsLabels[i]!=(char *)-1 && i*4<len; i++) {\n\t\tif (!statsLabels[i]) continue;\n\t\tif (j+strlen(statsLabels[i])+16>4096) {\n\t\t\tairo_print_warn(apriv->dev->name,\n\t\t\t       \"Potentially disastrous buffer overflow averted!\");\n\t\t\tbreak;\n\t\t}\n\t\tj+=sprintf(data->rbuffer+j, \"%s: %u\\n\", statsLabels[i],\n\t\t\t\tle32_to_cpu(vals[i]));\n\t}\n\tif (i*4 >= len) {\n\t\tairo_print_warn(apriv->dev->name, \"Got a short rid\");\n\t}\n\tdata->readlen = j;\n\treturn 0;\n}\n\nstatic int get_dec_u16(char *buffer, int *start, int limit)\n{\n\tu16 value;\n\tint valid = 0;\n\tfor (value = 0; *start < limit && buffer[*start] >= '0' &&\n\t\t\tbuffer[*start] <= '9'; (*start)++) {\n\t\tvalid = 1;\n\t\tvalue *= 10;\n\t\tvalue += buffer[*start] - '0';\n\t}\n\tif (!valid) return -1;\n\treturn value;\n}\n\nstatic int airo_config_commit(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *wrqu,\n\t\t\t      char *extra);\n\nstatic inline int sniffing_mode(struct airo_info *ai)\n{\n\treturn (le16_to_cpu(ai->config.rmode) & le16_to_cpu(RXMODE_MASK)) >=\n\t\tle16_to_cpu(RXMODE_RFMON);\n}\n\nstatic void proc_config_on_close(struct inode *inode, struct file *file)\n{\n\tstruct proc_data *data = file->private_data;\n\tstruct net_device *dev = pde_data(inode);\n\tstruct airo_info *ai = dev->ml_priv;\n\tchar *line;\n\n\tif (!data->writelen) return;\n\n\treadConfigRid(ai, 1);\n\tset_bit (FLAG_COMMIT, &ai->flags);\n\n\tline = data->wbuffer;\n\twhile (line[0]) {\n \n\t\tif (!strncmp(line, \"Mode: \", 6)) {\n\t\t\tline += 6;\n\t\t\tif (sniffing_mode(ai))\n\t\t\t\tset_bit (FLAG_RESET, &ai->flags);\n\t\t\tai->config.rmode &= ~RXMODE_FULL_MASK;\n\t\t\tclear_bit (FLAG_802_11, &ai->flags);\n\t\t\tai->config.opmode &= ~MODE_CFG_MASK;\n\t\t\tai->config.scanMode = SCANMODE_ACTIVE;\n\t\t\tif (line[0] == 'a') {\n\t\t\t\tai->config.opmode |= MODE_STA_IBSS;\n\t\t\t} else {\n\t\t\t\tai->config.opmode |= MODE_STA_ESS;\n\t\t\t\tif (line[0] == 'r') {\n\t\t\t\t\tai->config.rmode |= RXMODE_RFMON | RXMODE_DISABLE_802_3_HEADER;\n\t\t\t\t\tai->config.scanMode = SCANMODE_PASSIVE;\n\t\t\t\t\tset_bit (FLAG_802_11, &ai->flags);\n\t\t\t\t} else if (line[0] == 'y') {\n\t\t\t\t\tai->config.rmode |= RXMODE_RFMON_ANYBSS | RXMODE_DISABLE_802_3_HEADER;\n\t\t\t\t\tai->config.scanMode = SCANMODE_PASSIVE;\n\t\t\t\t\tset_bit (FLAG_802_11, &ai->flags);\n\t\t\t\t} else if (line[0] == 'l')\n\t\t\t\t\tai->config.rmode |= RXMODE_LANMON;\n\t\t\t}\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t}\n\n \n\t\telse if (!strncmp(line,\"Radio: \", 7)) {\n\t\t\tline += 7;\n\t\t\tif (!strncmp(line,\"off\", 3)) {\n\t\t\t\tset_bit (FLAG_RADIO_OFF, &ai->flags);\n\t\t\t} else {\n\t\t\t\tclear_bit (FLAG_RADIO_OFF, &ai->flags);\n\t\t\t}\n\t\t}\n \n\t\telse if (!strncmp(line, \"NodeName: \", 10)) {\n\t\t\tint j;\n\n\t\t\tline += 10;\n\t\t\tmemset(ai->config.nodeName, 0, 16);\n \n\t\t\tfor (j = 0; j < 16 && line[j] != '\\n'; j++) {\n\t\t\t\tai->config.nodeName[j] = line[j];\n\t\t\t}\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t}\n\n \n\t\telse if (!strncmp(line, \"PowerMode: \", 11)) {\n\t\t\tline += 11;\n\t\t\tif (!strncmp(line, \"PSPCAM\", 6)) {\n\t\t\t\tai->config.powerSaveMode = POWERSAVE_PSPCAM;\n\t\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t\t} else if (!strncmp(line, \"PSP\", 3)) {\n\t\t\t\tai->config.powerSaveMode = POWERSAVE_PSP;\n\t\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t\t} else {\n\t\t\t\tai->config.powerSaveMode = POWERSAVE_CAM;\n\t\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t\t}\n\t\t} else if (!strncmp(line, \"DataRates: \", 11)) {\n\t\t\tint v, i = 0, k = 0;  \n\n\t\t\tline += 11;\n\t\t\twhile ((v = get_dec_u16(line, &i, 3))!=-1) {\n\t\t\t\tai->config.rates[k++] = (u8)v;\n\t\t\t\tline += i + 1;\n\t\t\t\ti = 0;\n\t\t\t}\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if (!strncmp(line, \"Channel: \", 9)) {\n\t\t\tint v, i = 0;\n\t\t\tline += 9;\n\t\t\tv = get_dec_u16(line, &i, i+3);\n\t\t\tif (v != -1) {\n\t\t\t\tai->config.channelSet = cpu_to_le16(v);\n\t\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t\t}\n\t\t} else if (!strncmp(line, \"XmitPower: \", 11)) {\n\t\t\tint v, i = 0;\n\t\t\tline += 11;\n\t\t\tv = get_dec_u16(line, &i, i+3);\n\t\t\tif (v != -1) {\n\t\t\t\tai->config.txPower = cpu_to_le16(v);\n\t\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t\t}\n\t\t} else if (!strncmp(line, \"WEP: \", 5)) {\n\t\t\tline += 5;\n\t\t\tswitch(line[0]) {\n\t\t\tcase 's':\n\t\t\t\tset_auth_type(ai, AUTH_SHAREDKEY);\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tset_auth_type(ai, AUTH_ENCRYPT);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tset_auth_type(ai, AUTH_OPEN);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if (!strncmp(line, \"LongRetryLimit: \", 16)) {\n\t\t\tint v, i = 0;\n\n\t\t\tline += 16;\n\t\t\tv = get_dec_u16(line, &i, 3);\n\t\t\tv = (v<0) ? 0 : ((v>255) ? 255 : v);\n\t\t\tai->config.longRetryLimit = cpu_to_le16(v);\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if (!strncmp(line, \"ShortRetryLimit: \", 17)) {\n\t\t\tint v, i = 0;\n\n\t\t\tline += 17;\n\t\t\tv = get_dec_u16(line, &i, 3);\n\t\t\tv = (v<0) ? 0 : ((v>255) ? 255 : v);\n\t\t\tai->config.shortRetryLimit = cpu_to_le16(v);\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if (!strncmp(line, \"RTSThreshold: \", 14)) {\n\t\t\tint v, i = 0;\n\n\t\t\tline += 14;\n\t\t\tv = get_dec_u16(line, &i, 4);\n\t\t\tv = (v<0) ? 0 : ((v>AIRO_DEF_MTU) ? AIRO_DEF_MTU : v);\n\t\t\tai->config.rtsThres = cpu_to_le16(v);\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if (!strncmp(line, \"TXMSDULifetime: \", 16)) {\n\t\t\tint v, i = 0;\n\n\t\t\tline += 16;\n\t\t\tv = get_dec_u16(line, &i, 5);\n\t\t\tv = (v<0) ? 0 : v;\n\t\t\tai->config.txLifetime = cpu_to_le16(v);\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if (!strncmp(line, \"RXMSDULifetime: \", 16)) {\n\t\t\tint v, i = 0;\n\n\t\t\tline += 16;\n\t\t\tv = get_dec_u16(line, &i, 5);\n\t\t\tv = (v<0) ? 0 : v;\n\t\t\tai->config.rxLifetime = cpu_to_le16(v);\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if (!strncmp(line, \"TXDiversity: \", 13)) {\n\t\t\tai->config.txDiversity =\n\t\t\t\t(line[13]=='l') ? 1 :\n\t\t\t\t((line[13]=='r')? 2: 3);\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if (!strncmp(line, \"RXDiversity: \", 13)) {\n\t\t\tai->config.rxDiversity =\n\t\t\t\t(line[13]=='l') ? 1 :\n\t\t\t\t((line[13]=='r')? 2: 3);\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if (!strncmp(line, \"FragThreshold: \", 15)) {\n\t\t\tint v, i = 0;\n\n\t\t\tline += 15;\n\t\t\tv = get_dec_u16(line, &i, 4);\n\t\t\tv = (v<256) ? 256 : ((v>AIRO_DEF_MTU) ? AIRO_DEF_MTU : v);\n\t\t\tv = v & 0xfffe;  \n\t\t\tai->config.fragThresh = cpu_to_le16(v);\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if (!strncmp(line, \"Modulation: \", 12)) {\n\t\t\tline += 12;\n\t\t\tswitch(*line) {\n\t\t\tcase 'd':  ai->config.modulation = MOD_DEFAULT; set_bit(FLAG_COMMIT, &ai->flags); break;\n\t\t\tcase 'c':  ai->config.modulation = MOD_CCK; set_bit(FLAG_COMMIT, &ai->flags); break;\n\t\t\tcase 'm':  ai->config.modulation = MOD_MOK; set_bit(FLAG_COMMIT, &ai->flags); break;\n\t\t\tdefault: airo_print_warn(ai->dev->name, \"Unknown modulation\");\n\t\t\t}\n\t\t} else if (!strncmp(line, \"Preamble: \", 10)) {\n\t\t\tline += 10;\n\t\t\tswitch(*line) {\n\t\t\tcase 'a': ai->config.preamble = PREAMBLE_AUTO; set_bit(FLAG_COMMIT, &ai->flags); break;\n\t\t\tcase 'l': ai->config.preamble = PREAMBLE_LONG; set_bit(FLAG_COMMIT, &ai->flags); break;\n\t\t\tcase 's': ai->config.preamble = PREAMBLE_SHORT; set_bit(FLAG_COMMIT, &ai->flags); break;\n\t\t\tdefault: airo_print_warn(ai->dev->name, \"Unknown preamble\");\n\t\t\t}\n\t\t} else {\n\t\t\tairo_print_warn(ai->dev->name, \"Couldn't figure out %s\", line);\n\t\t}\n\t\twhile (line[0] && line[0] != '\\n') line++;\n\t\tif (line[0]) line++;\n\t}\n\tairo_config_commit(dev, NULL, NULL, NULL);\n}\n\nstatic const char *get_rmode(__le16 mode)\n{\n        switch(mode & RXMODE_MASK) {\n        case RXMODE_RFMON:  return \"rfmon\";\n        case RXMODE_RFMON_ANYBSS:  return \"yna (any) bss rfmon\";\n        case RXMODE_LANMON:  return \"lanmon\";\n        }\n        return \"ESS\";\n}\n\nstatic int proc_config_open(struct inode *inode, struct file *file)\n{\n\tstruct proc_data *data;\n\tstruct net_device *dev = pde_data(inode);\n\tstruct airo_info *ai = dev->ml_priv;\n\tint i;\n\t__le16 mode;\n\n\tif ((file->private_data = kzalloc(sizeof(struct proc_data), GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\tdata = file->private_data;\n\tif ((data->rbuffer = kmalloc(2048, GFP_KERNEL)) == NULL) {\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tif ((data->wbuffer = kzalloc(2048, GFP_KERNEL)) == NULL) {\n\t\tkfree (data->rbuffer);\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->maxwritelen = 2048;\n\tdata->on_close = proc_config_on_close;\n\n\treadConfigRid(ai, 1);\n\n\tmode = ai->config.opmode & MODE_CFG_MASK;\n\ti = sprintf(data->rbuffer,\n\t\t     \"Mode: %s\\n\"\n\t\t     \"Radio: %s\\n\"\n\t\t     \"NodeName: %-16s\\n\"\n\t\t     \"PowerMode: %s\\n\"\n\t\t     \"DataRates: %d %d %d %d %d %d %d %d\\n\"\n\t\t     \"Channel: %d\\n\"\n\t\t     \"XmitPower: %d\\n\",\n\t\t     mode == MODE_STA_IBSS ? \"adhoc\" :\n\t\t     mode == MODE_STA_ESS ? get_rmode(ai->config.rmode):\n\t\t     mode == MODE_AP ? \"AP\" :\n\t\t     mode == MODE_AP_RPTR ? \"AP RPTR\" : \"Error\",\n\t\t     test_bit(FLAG_RADIO_OFF, &ai->flags) ? \"off\" : \"on\",\n\t\t     ai->config.nodeName,\n\t\t     ai->config.powerSaveMode == POWERSAVE_CAM ? \"CAM\" :\n\t\t     ai->config.powerSaveMode == POWERSAVE_PSP ? \"PSP\" :\n\t\t     ai->config.powerSaveMode == POWERSAVE_PSPCAM ? \"PSPCAM\" :\n\t\t     \"Error\",\n\t\t     (int)ai->config.rates[0],\n\t\t     (int)ai->config.rates[1],\n\t\t     (int)ai->config.rates[2],\n\t\t     (int)ai->config.rates[3],\n\t\t     (int)ai->config.rates[4],\n\t\t     (int)ai->config.rates[5],\n\t\t     (int)ai->config.rates[6],\n\t\t     (int)ai->config.rates[7],\n\t\t     le16_to_cpu(ai->config.channelSet),\n\t\t     le16_to_cpu(ai->config.txPower)\n\t\t);\n\tsprintf(data->rbuffer + i,\n\t\t \"LongRetryLimit: %d\\n\"\n\t\t \"ShortRetryLimit: %d\\n\"\n\t\t \"RTSThreshold: %d\\n\"\n\t\t \"TXMSDULifetime: %d\\n\"\n\t\t \"RXMSDULifetime: %d\\n\"\n\t\t \"TXDiversity: %s\\n\"\n\t\t \"RXDiversity: %s\\n\"\n\t\t \"FragThreshold: %d\\n\"\n\t\t \"WEP: %s\\n\"\n\t\t \"Modulation: %s\\n\"\n\t\t \"Preamble: %s\\n\",\n\t\t le16_to_cpu(ai->config.longRetryLimit),\n\t\t le16_to_cpu(ai->config.shortRetryLimit),\n\t\t le16_to_cpu(ai->config.rtsThres),\n\t\t le16_to_cpu(ai->config.txLifetime),\n\t\t le16_to_cpu(ai->config.rxLifetime),\n\t\t ai->config.txDiversity == 1 ? \"left\" :\n\t\t ai->config.txDiversity == 2 ? \"right\" : \"both\",\n\t\t ai->config.rxDiversity == 1 ? \"left\" :\n\t\t ai->config.rxDiversity == 2 ? \"right\" : \"both\",\n\t\t le16_to_cpu(ai->config.fragThresh),\n\t\t ai->config.authType == AUTH_ENCRYPT ? \"encrypt\" :\n\t\t ai->config.authType == AUTH_SHAREDKEY ? \"shared\" : \"open\",\n\t\t ai->config.modulation == MOD_DEFAULT ? \"default\" :\n\t\t ai->config.modulation == MOD_CCK ? \"cck\" :\n\t\t ai->config.modulation == MOD_MOK ? \"mok\" : \"error\",\n\t\t ai->config.preamble == PREAMBLE_AUTO ? \"auto\" :\n\t\t ai->config.preamble == PREAMBLE_LONG ? \"long\" :\n\t\t ai->config.preamble == PREAMBLE_SHORT ? \"short\" : \"error\"\n\t\t);\n\tdata->readlen = strlen(data->rbuffer);\n\treturn 0;\n}\n\nstatic void proc_SSID_on_close(struct inode *inode, struct file *file)\n{\n\tstruct proc_data *data = file->private_data;\n\tstruct net_device *dev = pde_data(inode);\n\tstruct airo_info *ai = dev->ml_priv;\n\tSsidRid SSID_rid;\n\tint i;\n\tchar *p = data->wbuffer;\n\tchar *end = p + data->writelen;\n\n\tif (!data->writelen)\n\t\treturn;\n\n\t*end = '\\n';  \n\n\tmemset(&SSID_rid, 0, sizeof(SSID_rid));\n\n\tfor (i = 0; i < 3 && p < end; i++) {\n\t\tint j = 0;\n\t\t \n\t\twhile (*p != '\\n' && j < 32)\n\t\t\tSSID_rid.ssids[i].ssid[j++] = *p++;\n\t\tif (j == 0)\n\t\t\tbreak;\n\t\tSSID_rid.ssids[i].len = cpu_to_le16(j);\n\t\t \n\t\twhile (*p++ != '\\n')\n\t\t\t;\n\t}\n\tif (i)\n\t\tSSID_rid.len = cpu_to_le16(sizeof(SSID_rid));\n\tdisable_MAC(ai, 1);\n\twriteSsidRid(ai, &SSID_rid, 1);\n\tenable_MAC(ai, 1);\n}\n\nstatic void proc_APList_on_close(struct inode *inode, struct file *file)\n{\n\tstruct proc_data *data = file->private_data;\n\tstruct net_device *dev = pde_data(inode);\n\tstruct airo_info *ai = dev->ml_priv;\n\tAPListRid *APList_rid = &ai->APList;\n\tint i;\n\n\tif (!data->writelen) return;\n\n\tmemset(APList_rid, 0, sizeof(*APList_rid));\n\tAPList_rid->len = cpu_to_le16(sizeof(*APList_rid));\n\n\tfor (i = 0; i < 4 && data->writelen >= (i + 1) * 6 * 3; i++)\n\t\tmac_pton(data->wbuffer + i * 6 * 3, APList_rid->ap[i]);\n\n\tdisable_MAC(ai, 1);\n\twriteAPListRid(ai, APList_rid, 1);\n\tenable_MAC(ai, 1);\n}\n\n \nstatic int do_writerid(struct airo_info *ai, u16 rid, const void *rid_data,\n\t\t\tint len, int dummy)\n{\n\tint rc;\n\n\tdisable_MAC(ai, 1);\n\trc = PC4500_writerid(ai, rid, rid_data, len, 1);\n\tenable_MAC(ai, 1);\n\treturn rc;\n}\n\n \nstatic int get_wep_key(struct airo_info *ai, u16 index, char *buf, u16 buflen)\n{\n\tWepKeyRid wkr;\n\tint rc;\n\t__le16 lastindex;\n\n\trc = readWepKeyRid(ai, &wkr, 1, 1);\n\tif (rc != SUCCESS)\n\t\treturn -1;\n\tdo {\n\t\tlastindex = wkr.kindex;\n\t\tif (le16_to_cpu(wkr.kindex) == index) {\n\t\t\tint klen = min_t(int, buflen, le16_to_cpu(wkr.klen));\n\t\t\tmemcpy(buf, wkr.key, klen);\n\t\t\treturn klen;\n\t\t}\n\t\trc = readWepKeyRid(ai, &wkr, 0, 1);\n\t\tif (rc != SUCCESS)\n\t\t\treturn -1;\n\t} while (lastindex != wkr.kindex);\n\treturn -1;\n}\n\nstatic int get_wep_tx_idx(struct airo_info *ai)\n{\n\tWepKeyRid wkr;\n\tint rc;\n\t__le16 lastindex;\n\n\trc = readWepKeyRid(ai, &wkr, 1, 1);\n\tif (rc != SUCCESS)\n\t\treturn -1;\n\tdo {\n\t\tlastindex = wkr.kindex;\n\t\tif (wkr.kindex == cpu_to_le16(0xffff))\n\t\t\treturn wkr.mac[0];\n\t\trc = readWepKeyRid(ai, &wkr, 0, 1);\n\t\tif (rc != SUCCESS)\n\t\t\treturn -1;\n\t} while (lastindex != wkr.kindex);\n\treturn -1;\n}\n\nstatic int set_wep_key(struct airo_info *ai, u16 index, const u8 *key,\n\t\t       u16 keylen, int perm, int lock)\n{\n\tstatic const unsigned char macaddr[ETH_ALEN] = { 0x01, 0, 0, 0, 0, 0 };\n\tWepKeyRid wkr;\n\tint rc;\n\n\tif (WARN_ON(keylen == 0))\n\t\treturn -1;\n\n\tmemset(&wkr, 0, sizeof(wkr));\n\twkr.len = cpu_to_le16(sizeof(wkr));\n\twkr.kindex = cpu_to_le16(index);\n\twkr.klen = cpu_to_le16(keylen);\n\tmemcpy(wkr.key, key, keylen);\n\tmemcpy(wkr.mac, macaddr, ETH_ALEN);\n\n\tif (perm) disable_MAC(ai, lock);\n\trc = writeWepKeyRid(ai, &wkr, perm, lock);\n\tif (perm) enable_MAC(ai, lock);\n\treturn rc;\n}\n\nstatic int set_wep_tx_idx(struct airo_info *ai, u16 index, int perm, int lock)\n{\n\tWepKeyRid wkr;\n\tint rc;\n\n\tmemset(&wkr, 0, sizeof(wkr));\n\twkr.len = cpu_to_le16(sizeof(wkr));\n\twkr.kindex = cpu_to_le16(0xffff);\n\twkr.mac[0] = (char)index;\n\n\tif (perm) {\n\t\tai->defindex = (char)index;\n\t\tdisable_MAC(ai, lock);\n\t}\n\n\trc = writeWepKeyRid(ai, &wkr, perm, lock);\n\n\tif (perm)\n\t\tenable_MAC(ai, lock);\n\treturn rc;\n}\n\nstatic void proc_wepkey_on_close(struct inode *inode, struct file *file)\n{\n\tstruct proc_data *data;\n\tstruct net_device *dev = pde_data(inode);\n\tstruct airo_info *ai = dev->ml_priv;\n\tint i, rc;\n\tu8 key[16];\n\tu16 index = 0;\n\tint j = 0;\n\n\tmemset(key, 0, sizeof(key));\n\n\tdata = file->private_data;\n\tif (!data->writelen) return;\n\n\tif (data->wbuffer[0] >= '0' && data->wbuffer[0] <= '3' &&\n\t    (data->wbuffer[1] == ' ' || data->wbuffer[1] == '\\n')) {\n\t\tindex = data->wbuffer[0] - '0';\n\t\tif (data->wbuffer[1] == '\\n') {\n\t\t\trc = set_wep_tx_idx(ai, index, 1, 1);\n\t\t\tif (rc < 0) {\n\t\t\t\tairo_print_err(ai->dev->name, \"failed to set \"\n\t\t\t\t               \"WEP transmit index to %d: %d.\",\n\t\t\t\t               index, rc);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tj = 2;\n\t} else {\n\t\tairo_print_err(ai->dev->name, \"WepKey passed invalid key index\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 16*3 && data->wbuffer[i+j]; i++) {\n\t\tint val;\n\n\t\tif (i % 3 == 2)\n\t\t\tcontinue;\n\n\t\tval = hex_to_bin(data->wbuffer[i+j]);\n\t\tif (val < 0) {\n\t\t\tairo_print_err(ai->dev->name, \"WebKey passed invalid key hex\");\n\t\t\treturn;\n\t\t}\n\t\tswitch(i%3) {\n\t\tcase 0:\n\t\t\tkey[i/3] = (u8)val << 4;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tkey[i/3] |= (u8)val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trc = set_wep_key(ai, index, key, i/3, 1, 1);\n\tif (rc < 0) {\n\t\tairo_print_err(ai->dev->name, \"failed to set WEP key at index \"\n\t\t               \"%d: %d.\", index, rc);\n\t}\n}\n\nstatic int proc_wepkey_open(struct inode *inode, struct file *file)\n{\n\tstruct proc_data *data;\n\tstruct net_device *dev = pde_data(inode);\n\tstruct airo_info *ai = dev->ml_priv;\n\tchar *ptr;\n\tWepKeyRid wkr;\n\t__le16 lastindex;\n\tint j = 0;\n\tint rc;\n\n\tif ((file->private_data = kzalloc(sizeof(struct proc_data), GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\tmemset(&wkr, 0, sizeof(wkr));\n\tdata = file->private_data;\n\tif ((data->rbuffer = kzalloc(180, GFP_KERNEL)) == NULL) {\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->writelen = 0;\n\tdata->maxwritelen = 80;\n\tif ((data->wbuffer = kzalloc(80, GFP_KERNEL)) == NULL) {\n\t\tkfree (data->rbuffer);\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->on_close = proc_wepkey_on_close;\n\n\tptr = data->rbuffer;\n\tstrcpy(ptr, \"No wep keys\\n\");\n\trc = readWepKeyRid(ai, &wkr, 1, 1);\n\tif (rc == SUCCESS) do {\n\t\tlastindex = wkr.kindex;\n\t\tif (wkr.kindex == cpu_to_le16(0xffff)) {\n\t\t\tj += sprintf(ptr+j, \"Tx key = %d\\n\",\n\t\t\t\t     (int)wkr.mac[0]);\n\t\t} else {\n\t\t\tj += sprintf(ptr+j, \"Key %d set with length = %d\\n\",\n\t\t\t\t     le16_to_cpu(wkr.kindex),\n\t\t\t\t     le16_to_cpu(wkr.klen));\n\t\t}\n\t\treadWepKeyRid(ai, &wkr, 0, 1);\n\t} while ((lastindex != wkr.kindex) && (j < 180-30));\n\n\tdata->readlen = strlen(data->rbuffer);\n\treturn 0;\n}\n\nstatic int proc_SSID_open(struct inode *inode, struct file *file)\n{\n\tstruct proc_data *data;\n\tstruct net_device *dev = pde_data(inode);\n\tstruct airo_info *ai = dev->ml_priv;\n\tint i;\n\tchar *ptr;\n\tSsidRid SSID_rid;\n\n\tif ((file->private_data = kzalloc(sizeof(struct proc_data), GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\tdata = file->private_data;\n\tif ((data->rbuffer = kmalloc(104, GFP_KERNEL)) == NULL) {\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->writelen = 0;\n\tdata->maxwritelen = 33*3;\n\t \n\tif ((data->wbuffer = kzalloc(33*3 + 1, GFP_KERNEL)) == NULL) {\n\t\tkfree (data->rbuffer);\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->on_close = proc_SSID_on_close;\n\n\treadSsidRid(ai, &SSID_rid);\n\tptr = data->rbuffer;\n\tfor (i = 0; i < 3; i++) {\n\t\tint j;\n\t\tsize_t len = le16_to_cpu(SSID_rid.ssids[i].len);\n\t\tif (!len)\n\t\t\tbreak;\n\t\tif (len > 32)\n\t\t\tlen = 32;\n\t\tfor (j = 0; j < len && SSID_rid.ssids[i].ssid[j]; j++)\n\t\t\t*ptr++ = SSID_rid.ssids[i].ssid[j];\n\t\t*ptr++ = '\\n';\n\t}\n\t*ptr = '\\0';\n\tdata->readlen = strlen(data->rbuffer);\n\treturn 0;\n}\n\nstatic int proc_APList_open(struct inode *inode, struct file *file)\n{\n\tstruct proc_data *data;\n\tstruct net_device *dev = pde_data(inode);\n\tstruct airo_info *ai = dev->ml_priv;\n\tint i;\n\tchar *ptr;\n\tAPListRid *APList_rid = &ai->APList;\n\n\tif ((file->private_data = kzalloc(sizeof(struct proc_data), GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\tdata = file->private_data;\n\tif ((data->rbuffer = kmalloc(104, GFP_KERNEL)) == NULL) {\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->writelen = 0;\n\tdata->maxwritelen = 4*6*3;\n\tif ((data->wbuffer = kzalloc(data->maxwritelen, GFP_KERNEL)) == NULL) {\n\t\tkfree (data->rbuffer);\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->on_close = proc_APList_on_close;\n\n\tptr = data->rbuffer;\n\tfor (i = 0; i < 4; i++) {\n\n\t\tif (!*(int*)APList_rid->ap[i] &&\n\t\t     !*(int*)&APList_rid->ap[i][2]) break;\n\t\tptr += sprintf(ptr, \"%pM\\n\", APList_rid->ap[i]);\n\t}\n\tif (i==0) ptr += sprintf(ptr, \"Not using specific APs\\n\");\n\n\t*ptr = '\\0';\n\tdata->readlen = strlen(data->rbuffer);\n\treturn 0;\n}\n\nstatic int proc_BSSList_open(struct inode *inode, struct file *file)\n{\n\tstruct proc_data *data;\n\tstruct net_device *dev = pde_data(inode);\n\tstruct airo_info *ai = dev->ml_priv;\n\tchar *ptr;\n\tBSSListRid BSSList_rid;\n\tint rc;\n\t \n\tint doLoseSync = -1;\n\n\tif ((file->private_data = kzalloc(sizeof(struct proc_data), GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\tdata = file->private_data;\n\tif ((data->rbuffer = kmalloc(1024, GFP_KERNEL)) == NULL) {\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->writelen = 0;\n\tdata->maxwritelen = 0;\n\tdata->wbuffer = NULL;\n\tdata->on_close = NULL;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tif (!(file->f_mode & FMODE_READ)) {\n\t\t\tCmd cmd;\n\t\t\tResp rsp;\n\n\t\t\tif (ai->flags & FLAG_RADIO_MASK) {\n\t\t\t\tkfree(data->rbuffer);\n\t\t\t\tkfree(file->private_data);\n\t\t\t\treturn -ENETDOWN;\n\t\t\t}\n\t\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\t\tcmd.cmd = CMD_LISTBSS;\n\t\t\tif (down_interruptible(&ai->sem)) {\n\t\t\t\tkfree(data->rbuffer);\n\t\t\t\tkfree(file->private_data);\n\t\t\t\treturn -ERESTARTSYS;\n\t\t\t}\n\t\t\tissuecommand(ai, &cmd, &rsp, true);\n\t\t\tup(&ai->sem);\n\t\t\tdata->readlen = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tdoLoseSync = 1;\n\t}\n\tptr = data->rbuffer;\n\t \n\trc = readBSSListRid(ai, doLoseSync, &BSSList_rid);\n\twhile (rc == 0 && BSSList_rid.index != cpu_to_le16(0xffff)) {\n\t\tptr += sprintf(ptr, \"%pM %.*s rssi = %d\",\n\t\t\t       BSSList_rid.bssid,\n\t\t\t\t(int)BSSList_rid.ssidLen,\n\t\t\t\tBSSList_rid.ssid,\n\t\t\t\tle16_to_cpu(BSSList_rid.dBm));\n\t\tptr += sprintf(ptr, \" channel = %d %s %s %s %s\\n\",\n\t\t\t\tle16_to_cpu(BSSList_rid.dsChannel),\n\t\t\t\tBSSList_rid.cap & CAP_ESS ? \"ESS\" : \"\",\n\t\t\t\tBSSList_rid.cap & CAP_IBSS ? \"adhoc\" : \"\",\n\t\t\t\tBSSList_rid.cap & CAP_PRIVACY ? \"wep\" : \"\",\n\t\t\t\tBSSList_rid.cap & CAP_SHORTHDR ? \"shorthdr\" : \"\");\n\t\trc = readBSSListRid(ai, 0, &BSSList_rid);\n\t}\n\t*ptr = '\\0';\n\tdata->readlen = strlen(data->rbuffer);\n\treturn 0;\n}\n\nstatic int proc_close(struct inode *inode, struct file *file)\n{\n\tstruct proc_data *data = file->private_data;\n\n\tif (data->on_close != NULL)\n\t\tdata->on_close(inode, file);\n\tkfree(data->rbuffer);\n\tkfree(data->wbuffer);\n\tkfree(data);\n\treturn 0;\n}\n\n \nstatic void timer_func(struct net_device *dev)\n{\n\tstruct airo_info *apriv = dev->ml_priv;\n\n \n\treadConfigRid(apriv, 0);\n\tdisable_MAC(apriv, 0);\n\tswitch(apriv->config.authType) {\n\t\tcase AUTH_ENCRYPT:\n \n\t\t\tapriv->config.authType = AUTH_OPEN;\n\t\t\tbreak;\n\t\tcase AUTH_SHAREDKEY:\n\t\t\tif (apriv->keyindex < auto_wep) {\n\t\t\t\tset_wep_tx_idx(apriv, apriv->keyindex, 0, 0);\n\t\t\t\tapriv->config.authType = AUTH_SHAREDKEY;\n\t\t\t\tapriv->keyindex++;\n\t\t\t} else {\n\t\t\t         \n\t\t\t\tapriv->keyindex = 0;\n\t\t\t\tset_wep_tx_idx(apriv, apriv->defindex, 0, 0);\n\t\t\t\tapriv->config.authType = AUTH_ENCRYPT;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:   \n\t\t\tapriv->config.authType = AUTH_SHAREDKEY;\n\t}\n\tset_bit (FLAG_COMMIT, &apriv->flags);\n\twriteConfigRid(apriv, 0);\n\tenable_MAC(apriv, 0);\n\tup(&apriv->sem);\n\n \n\tclear_bit(JOB_AUTOWEP, &apriv->jobs);\n\tapriv->expires = RUN_AT(HZ*3);\n}\n\n#ifdef CONFIG_PCI\nstatic int airo_pci_probe(struct pci_dev *pdev,\n\t\t\t\t    const struct pci_device_id *pent)\n{\n\tstruct net_device *dev;\n\n\tif (pci_enable_device(pdev))\n\t\treturn -ENODEV;\n\tpci_set_master(pdev);\n\n\tif (pdev->device == 0x5000 || pdev->device == 0xa504)\n\t\t\tdev = _init_airo_card(pdev->irq, pdev->resource[0].start, 0, pdev, &pdev->dev);\n\telse\n\t\t\tdev = _init_airo_card(pdev->irq, pdev->resource[2].start, 0, pdev, &pdev->dev);\n\tif (!dev) {\n\t\tpci_disable_device(pdev);\n\t\treturn -ENODEV;\n\t}\n\n\tpci_set_drvdata(pdev, dev);\n\treturn 0;\n}\n\nstatic void airo_pci_remove(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\n\tairo_print_info(dev->name, \"Unregistering...\");\n\tstop_airo_card(dev, 1);\n\tpci_disable_device(pdev);\n}\n\nstatic int __maybe_unused airo_pci_suspend(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\tstruct airo_info *ai = dev->ml_priv;\n\tCmd cmd;\n\tResp rsp;\n\n\tif (!ai->SSID)\n\t\tai->SSID = kmalloc(sizeof(SsidRid), GFP_KERNEL);\n\tif (!ai->SSID)\n\t\treturn -ENOMEM;\n\treadSsidRid(ai, ai->SSID);\n\tmemset(&cmd, 0, sizeof(cmd));\n\t \n\tif (down_interruptible(&ai->sem))\n\t\treturn -EAGAIN;\n\tdisable_MAC(ai, 0);\n\tnetif_device_detach(dev);\n\tai->power = PMSG_SUSPEND;\n\tcmd.cmd = HOSTSLEEP;\n\tissuecommand(ai, &cmd, &rsp, true);\n\n\tdevice_wakeup_enable(dev_d);\n\treturn 0;\n}\n\nstatic int __maybe_unused airo_pci_resume(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\tstruct airo_info *ai = dev->ml_priv;\n\tpci_power_t prev_state = to_pci_dev(dev_d)->current_state;\n\n\tdevice_wakeup_disable(dev_d);\n\n\tif (prev_state != PCI_D1) {\n\t\treset_card(dev, 0);\n\t\tmpi_init_descriptors(ai);\n\t\tsetup_card(ai, dev, 0);\n\t\tclear_bit(FLAG_RADIO_OFF, &ai->flags);\n\t\tclear_bit(FLAG_PENDING_XMIT, &ai->flags);\n\t} else {\n\t\tOUT4500(ai, EVACK, EV_AWAKEN);\n\t\tOUT4500(ai, EVACK, EV_AWAKEN);\n\t\tmsleep(100);\n\t}\n\n\tset_bit(FLAG_COMMIT, &ai->flags);\n\tdisable_MAC(ai, 0);\n        msleep(200);\n\tif (ai->SSID) {\n\t\twriteSsidRid(ai, ai->SSID, 0);\n\t\tkfree(ai->SSID);\n\t\tai->SSID = NULL;\n\t}\n\twriteAPListRid(ai, &ai->APList, 0);\n\twriteConfigRid(ai, 0);\n\tenable_MAC(ai, 0);\n\tai->power = PMSG_ON;\n\tnetif_device_attach(dev);\n\tnetif_wake_queue(dev);\n\tenable_interrupts(ai);\n\tup(&ai->sem);\n\treturn 0;\n}\n#endif\n\nstatic int __init airo_init_module(void)\n{\n\tint i;\n\n\tproc_kuid = make_kuid(&init_user_ns, proc_uid);\n\tproc_kgid = make_kgid(&init_user_ns, proc_gid);\n\tif (!uid_valid(proc_kuid) || !gid_valid(proc_kgid))\n\t\treturn -EINVAL;\n\n\tairo_entry = proc_mkdir_mode(\"driver/aironet\", airo_perm, NULL);\n\n\tif (airo_entry)\n\t\tproc_set_user(airo_entry, proc_kuid, proc_kgid);\n\n\tfor (i = 0; i < 4 && io[i] && irq[i]; i++) {\n\t\tairo_print_info(\"\", \"Trying to configure ISA adapter at irq=%d \"\n\t\t\t\"io = 0x%x\", irq[i], io[i]);\n\t\tif (init_airo_card(irq[i], io[i], 0, NULL)) {\n\t\t\t  ;\n\t\t}\n\t}\n\n#ifdef CONFIG_PCI\n\tairo_print_info(\"\", \"Probing for PCI adapters\");\n\ti = pci_register_driver(&airo_driver);\n\tairo_print_info(\"\", \"Finished probing for PCI adapters\");\n\n\tif (i) {\n\t\tremove_proc_entry(\"driver/aironet\", NULL);\n\t\treturn i;\n\t}\n#endif\n\n\t \n\treturn 0;\n}\n\nstatic void __exit airo_cleanup_module(void)\n{\n\tstruct airo_info *ai;\n\twhile (!list_empty(&airo_devices)) {\n\t\tai = list_entry(airo_devices.next, struct airo_info, dev_list);\n\t\tairo_print_info(ai->dev->name, \"Unregistering...\");\n\t\tstop_airo_card(ai->dev, 1);\n\t}\n#ifdef CONFIG_PCI\n\tpci_unregister_driver(&airo_driver);\n#endif\n\tremove_proc_entry(\"driver/aironet\", NULL);\n}\n\n \n\nstatic u8 airo_rssi_to_dbm (tdsRssiEntry *rssi_rid, u8 rssi)\n{\n\tif (!rssi_rid)\n\t\treturn 0;\n\n\treturn (0x100 - rssi_rid[rssi].rssidBm);\n}\n\nstatic u8 airo_dbm_to_pct (tdsRssiEntry *rssi_rid, u8 dbm)\n{\n\tint i;\n\n\tif (!rssi_rid)\n\t\treturn 0;\n\n\tfor (i = 0; i < 256; i++)\n\t\tif (rssi_rid[i].rssidBm == dbm)\n\t\t\treturn rssi_rid[i].rssipct;\n\n\treturn 0;\n}\n\n\nstatic int airo_get_quality (StatusRid *status_rid, CapabilityRid *cap_rid)\n{\n\tint quality = 0;\n\tu16 sq;\n\n\tif ((status_rid->mode & cpu_to_le16(0x3f)) != cpu_to_le16(0x3f))\n\t\treturn 0;\n\n\tif (!(cap_rid->hardCap & cpu_to_le16(8)))\n\t\treturn 0;\n\n\tsq = le16_to_cpu(status_rid->signalQuality);\n\tif (memcmp(cap_rid->prodName, \"350\", 3))\n\t\tif (sq > 0x20)\n\t\t\tquality = 0;\n\t\telse\n\t\t\tquality = 0x20 - sq;\n\telse\n\t\tif (sq > 0xb0)\n\t\t\tquality = 0;\n\t\telse if (sq < 0x10)\n\t\t\tquality = 0xa0;\n\t\telse\n\t\t\tquality = 0xb0 - sq;\n\treturn quality;\n}\n\n#define airo_get_max_quality(cap_rid) (memcmp((cap_rid)->prodName, \"350\", 3) ? 0x20 : 0xa0)\n#define airo_get_avg_quality(cap_rid) (memcmp((cap_rid)->prodName, \"350\", 3) ? 0x10 : 0x50)\n\n \n \nstatic int airo_get_name(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *cwrq,\n\t\t\t char *extra)\n{\n\tstrcpy(cwrq->name, \"IEEE 802.11-DS\");\n\treturn 0;\n}\n\n \n \nstatic int airo_set_freq(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *wrqu,\n\t\t\t char *extra)\n{\n\tstruct iw_freq *fwrq = &wrqu->freq;\n\tstruct airo_info *local = dev->ml_priv;\n\tint rc = -EINPROGRESS;\t\t \n\n\t \n\tif (fwrq->e == 1) {\n\t\tint f = fwrq->m / 100000;\n\n\t\t \n\t\tfwrq->e = 0;\n\t\tfwrq->m = ieee80211_frequency_to_channel(f);\n\t}\n\t \n\tif (fwrq->m < 0 || fwrq->m > 1000 || fwrq->e > 0)\n\t\trc = -EOPNOTSUPP;\n\telse {\n\t\tint channel = fwrq->m;\n\t\t \n\t\tif ((channel < 1) || (channel > 14)) {\n\t\t\tairo_print_dbg(dev->name, \"New channel value of %d is invalid!\",\n\t\t\t\tfwrq->m);\n\t\t\trc = -EINVAL;\n\t\t} else {\n\t\t\treadConfigRid(local, 1);\n\t\t\t \n\t\t\tlocal->config.channelSet = cpu_to_le16(channel);\n\t\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\t}\n\t}\n\treturn rc;\n}\n\n \n \nstatic int airo_get_freq(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *wrqu,\n\t\t\t char *extra)\n{\n\tstruct iw_freq *fwrq = &wrqu->freq;\n\tstruct airo_info *local = dev->ml_priv;\n\tStatusRid status_rid;\t\t \n\tint ch;\n\n\treadConfigRid(local, 1);\n\tif ((local->config.opmode & MODE_CFG_MASK) == MODE_STA_ESS)\n\t\tstatus_rid.channel = local->config.channelSet;\n\telse\n\t\treadStatusRid(local, &status_rid, 1);\n\n\tch = le16_to_cpu(status_rid.channel);\n\tif ((ch > 0) && (ch < 15)) {\n\t\tfwrq->m = 100000 *\n\t\t\tieee80211_channel_to_frequency(ch, NL80211_BAND_2GHZ);\n\t\tfwrq->e = 1;\n\t} else {\n\t\tfwrq->m = ch;\n\t\tfwrq->e = 0;\n\t}\n\n\treturn 0;\n}\n\n \n \nstatic int airo_set_essid(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu,\n\t\t\t  char *extra)\n{\n\tstruct iw_point *dwrq = &wrqu->essid;\n\tstruct airo_info *local = dev->ml_priv;\n\tSsidRid SSID_rid;\t\t \n\n\t \n\treadSsidRid(local, &SSID_rid);\n\n\t \n\tif (dwrq->flags == 0) {\n\t\t \n\t\tmemset(&SSID_rid, 0, sizeof(SSID_rid));\n\t} else {\n\t\tunsigned index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\n\n\t\t \n\t\tif (dwrq->length > IW_ESSID_MAX_SIZE)\n\t\t\treturn -E2BIG ;\n\n\t\t \n\t\tif (index >= ARRAY_SIZE(SSID_rid.ssids))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tmemset(SSID_rid.ssids[index].ssid, 0,\n\t\t       sizeof(SSID_rid.ssids[index].ssid));\n\t\tmemcpy(SSID_rid.ssids[index].ssid, extra, dwrq->length);\n\t\tSSID_rid.ssids[index].len = cpu_to_le16(dwrq->length);\n\t}\n\tSSID_rid.len = cpu_to_le16(sizeof(SSID_rid));\n\t \n\tdisable_MAC(local, 1);\n\twriteSsidRid(local, &SSID_rid, 1);\n\tenable_MAC(local, 1);\n\n\treturn 0;\n}\n\n \n \nstatic int airo_get_essid(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu,\n\t\t\t  char *extra)\n{\n\tstruct iw_point *dwrq = &wrqu->essid;\n\tstruct airo_info *local = dev->ml_priv;\n\tStatusRid status_rid;\t\t \n\n\treadStatusRid(local, &status_rid, 1);\n\n\t \n\n\t \n\tmemcpy(extra, status_rid.SSID, le16_to_cpu(status_rid.SSIDlen));\n\t \n\n\t \n\tdwrq->length = le16_to_cpu(status_rid.SSIDlen);\n\tdwrq->flags = 1;  \n\n\treturn 0;\n}\n\n \n \nstatic int airo_set_wap(struct net_device *dev,\n\t\t\tstruct iw_request_info *info,\n\t\t\tunion iwreq_data *wrqu,\n\t\t\tchar *extra)\n{\n\tstruct sockaddr *awrq = &wrqu->ap_addr;\n\tstruct airo_info *local = dev->ml_priv;\n\tCmd cmd;\n\tResp rsp;\n\tAPListRid *APList_rid = &local->APList;\n\n\tif (awrq->sa_family != ARPHRD_ETHER)\n\t\treturn -EINVAL;\n\telse if (is_broadcast_ether_addr(awrq->sa_data) ||\n\t\t is_zero_ether_addr(awrq->sa_data)) {\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tcmd.cmd = CMD_LOSE_SYNC;\n\t\tif (down_interruptible(&local->sem))\n\t\t\treturn -ERESTARTSYS;\n\t\tissuecommand(local, &cmd, &rsp, true);\n\t\tup(&local->sem);\n\t} else {\n\t\tmemset(APList_rid, 0, sizeof(*APList_rid));\n\t\tAPList_rid->len = cpu_to_le16(sizeof(*APList_rid));\n\t\tmemcpy(APList_rid->ap[0], awrq->sa_data, ETH_ALEN);\n\t\tdisable_MAC(local, 1);\n\t\twriteAPListRid(local, APList_rid, 1);\n\t\tenable_MAC(local, 1);\n\t}\n\treturn 0;\n}\n\n \n \nstatic int airo_get_wap(struct net_device *dev,\n\t\t\tstruct iw_request_info *info,\n\t\t\tunion iwreq_data *wrqu,\n\t\t\tchar *extra)\n{\n\tstruct sockaddr *awrq = &wrqu->ap_addr;\n\tstruct airo_info *local = dev->ml_priv;\n\tStatusRid status_rid;\t\t \n\n\treadStatusRid(local, &status_rid, 1);\n\n\t \n\tmemcpy(awrq->sa_data, status_rid.bssid[0], ETH_ALEN);\n\tawrq->sa_family = ARPHRD_ETHER;\n\n\treturn 0;\n}\n\n \n \nstatic int airo_set_nick(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *wrqu,\n\t\t\t char *extra)\n{\n\tstruct iw_point *dwrq = &wrqu->data;\n\tstruct airo_info *local = dev->ml_priv;\n\n\t \n\tif (dwrq->length > 16) {\n\t\treturn -E2BIG;\n\t}\n\treadConfigRid(local, 1);\n\tmemset(local->config.nodeName, 0, sizeof(local->config.nodeName));\n\tmemcpy(local->config.nodeName, extra, dwrq->length);\n\tset_bit (FLAG_COMMIT, &local->flags);\n\n\treturn -EINPROGRESS;\t\t \n}\n\n \n \nstatic int airo_get_nick(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *wrqu,\n\t\t\t char *extra)\n{\n\tstruct iw_point *dwrq = &wrqu->data;\n\tstruct airo_info *local = dev->ml_priv;\n\n\treadConfigRid(local, 1);\n\tstrncpy(extra, local->config.nodeName, 16);\n\textra[16] = '\\0';\n\tdwrq->length = strlen(extra);\n\n\treturn 0;\n}\n\n \n \nstatic int airo_set_rate(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *wrqu,\n\t\t\t char *extra)\n{\n\tstruct iw_param *vwrq = &wrqu->bitrate;\n\tstruct airo_info *local = dev->ml_priv;\n\tCapabilityRid cap_rid;\t\t \n\tu8\tbrate = 0;\n\tint\ti;\n\n\t \n\treadCapabilityRid(local, &cap_rid, 1);\n\n\t \n\tif ((vwrq->value < 8) && (vwrq->value >= 0)) {\n\t\t \n\t\t \n\t\tbrate = cap_rid.supportedRates[vwrq->value];\n\t} else {\n\t\t \n\t\tu8\tnormvalue = (u8) (vwrq->value/500000);\n\n\t\t \n\t\tfor (i = 0 ; i < 8 ; i++) {\n\t\t\tif (normvalue == cap_rid.supportedRates[i]) {\n\t\t\t\tbrate = normvalue;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (vwrq->value == -1) {\n\t\t \n\t\tfor (i = 0 ; i < 8 ; i++) {\n\t\t\tif (cap_rid.supportedRates[i] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i != 0)\n\t\t\tbrate = cap_rid.supportedRates[i - 1];\n\t}\n\t \n\tif (brate == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\treadConfigRid(local, 1);\n\t \n\tif (vwrq->fixed == 0) {\n\t\t \n\t\tmemset(local->config.rates, 0, 8);\n\t\tfor (i = 0 ; i < 8 ; i++) {\n\t\t\tlocal->config.rates[i] = cap_rid.supportedRates[i];\n\t\t\tif (local->config.rates[i] == brate)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\t \n\t\tmemset(local->config.rates, 0, 8);\n\t\tlocal->config.rates[0] = brate;\n\t}\n\tset_bit (FLAG_COMMIT, &local->flags);\n\n\treturn -EINPROGRESS;\t\t \n}\n\n \n \nstatic int airo_get_rate(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *wrqu,\n\t\t\t char *extra)\n{\n\tstruct iw_param *vwrq = &wrqu->bitrate;\n\tstruct airo_info *local = dev->ml_priv;\n\tStatusRid status_rid;\t\t \n\tint ret;\n\n\tret = readStatusRid(local, &status_rid, 1);\n\tif (ret)\n\t\treturn -EBUSY;\n\n\tvwrq->value = le16_to_cpu(status_rid.currentXmitRate) * 500000;\n\t \n\treadConfigRid(local, 1);\n\tvwrq->fixed = (local->config.rates[1] == 0);\n\n\treturn 0;\n}\n\n \n \nstatic int airo_set_rts(struct net_device *dev,\n\t\t\tstruct iw_request_info *info,\n\t\t\tunion iwreq_data *wrqu,\n\t\t\tchar *extra)\n{\n\tstruct iw_param *vwrq = &wrqu->rts;\n\tstruct airo_info *local = dev->ml_priv;\n\tint rthr = vwrq->value;\n\n\tif (vwrq->disabled)\n\t\trthr = AIRO_DEF_MTU;\n\tif ((rthr < 0) || (rthr > AIRO_DEF_MTU)) {\n\t\treturn -EINVAL;\n\t}\n\treadConfigRid(local, 1);\n\tlocal->config.rtsThres = cpu_to_le16(rthr);\n\tset_bit (FLAG_COMMIT, &local->flags);\n\n\treturn -EINPROGRESS;\t\t \n}\n\n \n \nstatic int airo_get_rts(struct net_device *dev,\n\t\t\tstruct iw_request_info *info,\n\t\t\tunion iwreq_data *wrqu,\n\t\t\tchar *extra)\n{\n\tstruct iw_param *vwrq = &wrqu->rts;\n\tstruct airo_info *local = dev->ml_priv;\n\n\treadConfigRid(local, 1);\n\tvwrq->value = le16_to_cpu(local->config.rtsThres);\n\tvwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);\n\tvwrq->fixed = 1;\n\n\treturn 0;\n}\n\n \n \nstatic int airo_set_frag(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *vwrq = &wrqu->frag;\n\tstruct airo_info *local = dev->ml_priv;\n\tint fthr = vwrq->value;\n\n\tif (vwrq->disabled)\n\t\tfthr = AIRO_DEF_MTU;\n\tif ((fthr < 256) || (fthr > AIRO_DEF_MTU)) {\n\t\treturn -EINVAL;\n\t}\n\tfthr &= ~0x1;\t \n\treadConfigRid(local, 1);\n\tlocal->config.fragThresh = cpu_to_le16(fthr);\n\tset_bit (FLAG_COMMIT, &local->flags);\n\n\treturn -EINPROGRESS;\t\t \n}\n\n \n \nstatic int airo_get_frag(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *wrqu,\n\t\t\t char *extra)\n{\n\tstruct iw_param *vwrq = &wrqu->frag;\n\tstruct airo_info *local = dev->ml_priv;\n\n\treadConfigRid(local, 1);\n\tvwrq->value = le16_to_cpu(local->config.fragThresh);\n\tvwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);\n\tvwrq->fixed = 1;\n\n\treturn 0;\n}\n\n \n \nstatic int airo_set_mode(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *uwrq,\n\t\t\t char *extra)\n{\n\t__u32 mode = uwrq->mode;\n\tstruct airo_info *local = dev->ml_priv;\n\tint reset = 0;\n\n\treadConfigRid(local, 1);\n\tif (sniffing_mode(local))\n\t\treset = 1;\n\n\tswitch (mode) {\n\t\tcase IW_MODE_ADHOC:\n\t\t\tlocal->config.opmode &= ~MODE_CFG_MASK;\n\t\t\tlocal->config.opmode |= MODE_STA_IBSS;\n\t\t\tlocal->config.rmode &= ~RXMODE_FULL_MASK;\n\t\t\tlocal->config.scanMode = SCANMODE_ACTIVE;\n\t\t\tclear_bit (FLAG_802_11, &local->flags);\n\t\t\tbreak;\n\t\tcase IW_MODE_INFRA:\n\t\t\tlocal->config.opmode &= ~MODE_CFG_MASK;\n\t\t\tlocal->config.opmode |= MODE_STA_ESS;\n\t\t\tlocal->config.rmode &= ~RXMODE_FULL_MASK;\n\t\t\tlocal->config.scanMode = SCANMODE_ACTIVE;\n\t\t\tclear_bit (FLAG_802_11, &local->flags);\n\t\t\tbreak;\n\t\tcase IW_MODE_MASTER:\n\t\t\tlocal->config.opmode &= ~MODE_CFG_MASK;\n\t\t\tlocal->config.opmode |= MODE_AP;\n\t\t\tlocal->config.rmode &= ~RXMODE_FULL_MASK;\n\t\t\tlocal->config.scanMode = SCANMODE_ACTIVE;\n\t\t\tclear_bit (FLAG_802_11, &local->flags);\n\t\t\tbreak;\n\t\tcase IW_MODE_REPEAT:\n\t\t\tlocal->config.opmode &= ~MODE_CFG_MASK;\n\t\t\tlocal->config.opmode |= MODE_AP_RPTR;\n\t\t\tlocal->config.rmode &= ~RXMODE_FULL_MASK;\n\t\t\tlocal->config.scanMode = SCANMODE_ACTIVE;\n\t\t\tclear_bit (FLAG_802_11, &local->flags);\n\t\t\tbreak;\n\t\tcase IW_MODE_MONITOR:\n\t\t\tlocal->config.opmode &= ~MODE_CFG_MASK;\n\t\t\tlocal->config.opmode |= MODE_STA_ESS;\n\t\t\tlocal->config.rmode &= ~RXMODE_FULL_MASK;\n\t\t\tlocal->config.rmode |= RXMODE_RFMON | RXMODE_DISABLE_802_3_HEADER;\n\t\t\tlocal->config.scanMode = SCANMODE_PASSIVE;\n\t\t\tset_bit (FLAG_802_11, &local->flags);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\tif (reset)\n\t\tset_bit (FLAG_RESET, &local->flags);\n\tset_bit (FLAG_COMMIT, &local->flags);\n\n\treturn -EINPROGRESS;\t\t \n}\n\n \n \nstatic int airo_get_mode(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *uwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\treadConfigRid(local, 1);\n\t \n\tswitch (local->config.opmode & MODE_CFG_MASK) {\n\t\tcase MODE_STA_ESS:\n\t\t\tuwrq->mode = IW_MODE_INFRA;\n\t\t\tbreak;\n\t\tcase MODE_AP:\n\t\t\tuwrq->mode = IW_MODE_MASTER;\n\t\t\tbreak;\n\t\tcase MODE_AP_RPTR:\n\t\t\tuwrq->mode = IW_MODE_REPEAT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tuwrq->mode = IW_MODE_ADHOC;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int valid_index(struct airo_info *ai, int index)\n{\n\treturn (index >= 0) && (index <= ai->max_wep_idx);\n}\n\n \n \nstatic int airo_set_encode(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu,\n\t\t\t   char *extra)\n{\n\tstruct iw_point *dwrq = &wrqu->encoding;\n\tstruct airo_info *local = dev->ml_priv;\n\tint perm = (dwrq->flags & IW_ENCODE_TEMP ? 0 : 1);\n\t__le16 currentAuthType = local->config.authType;\n\tint rc = 0;\n\n\tif (!local->wep_capable)\n\t\treturn -EOPNOTSUPP;\n\n\treadConfigRid(local, 1);\n\n\t \n\tif (dwrq->length > 0) {\n\t\twep_key_t key;\n\t\tint index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\n\t\tint current_index;\n\n\t\t \n\t\tif (dwrq->length > MAX_KEY_SIZE) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcurrent_index = get_wep_tx_idx(local);\n\t\tif (current_index < 0)\n\t\t\tcurrent_index = 0;\n\n\t\t \n\t\tif (!valid_index(local, index))\n\t\t\tindex = current_index;\n\n\t\t \n\t\tif (dwrq->length > MIN_KEY_SIZE)\n\t\t\tkey.len = MAX_KEY_SIZE;\n\t\telse\n\t\t\tkey.len = MIN_KEY_SIZE;\n\t\t \n\t\tif (!(dwrq->flags & IW_ENCODE_NOKEY)) {\n\t\t\t \n\t\t\tmemset(key.key, 0, MAX_KEY_SIZE);\n\t\t\t \n\t\t\tmemcpy(key.key, extra, dwrq->length);\n\t\t\t \n\t\t\trc = set_wep_key(local, index, key.key, key.len, perm, 1);\n\t\t\tif (rc < 0) {\n\t\t\t\tairo_print_err(local->dev->name, \"failed to set\"\n\t\t\t\t               \" WEP key at index %d: %d.\",\n\t\t\t\t               index, rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif ((index == current_index) && (key.len > 0) &&\n\t\t   (local->config.authType == AUTH_OPEN))\n\t\t\tset_auth_type(local, AUTH_ENCRYPT);\n\t} else {\n\t\t \n\t\tint index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\n\t\tif (valid_index(local, index)) {\n\t\t\trc = set_wep_tx_idx(local, index, perm, 1);\n\t\t\tif (rc < 0) {\n\t\t\t\tairo_print_err(local->dev->name, \"failed to set\"\n\t\t\t\t               \" WEP transmit index to %d: %d.\",\n\t\t\t\t               index, rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (!(dwrq->flags & IW_ENCODE_MODE))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t \n\tif (dwrq->flags & IW_ENCODE_DISABLED)\n\t\tset_auth_type(local, AUTH_OPEN);\t \n\tif (dwrq->flags & IW_ENCODE_RESTRICTED)\n\t\tset_auth_type(local, AUTH_SHAREDKEY);\t \n\tif (dwrq->flags & IW_ENCODE_OPEN)\n\t\tset_auth_type(local, AUTH_ENCRYPT);\t \n\t \n\tif (local->config.authType != currentAuthType)\n\t\tset_bit (FLAG_COMMIT, &local->flags);\n\treturn -EINPROGRESS;\t\t \n}\n\n \n \nstatic int airo_get_encode(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu,\n\t\t\t   char *extra)\n{\n\tstruct iw_point *dwrq = &wrqu->encoding;\n\tstruct airo_info *local = dev->ml_priv;\n\tint index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\n\tint wep_key_len;\n\tu8 buf[16];\n\n\tif (!local->wep_capable)\n\t\treturn -EOPNOTSUPP;\n\n\treadConfigRid(local, 1);\n\n\t \n\tswitch(local->config.authType)\t{\n\t\tcase AUTH_ENCRYPT:\n\t\t\tdwrq->flags = IW_ENCODE_OPEN;\n\t\t\tbreak;\n\t\tcase AUTH_SHAREDKEY:\n\t\t\tdwrq->flags = IW_ENCODE_RESTRICTED;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase AUTH_OPEN:\n\t\t\tdwrq->flags = IW_ENCODE_DISABLED;\n\t\t\tbreak;\n\t}\n\t \n\tdwrq->flags |= IW_ENCODE_NOKEY;\n\tmemset(extra, 0, 16);\n\n\t \n\tif (!valid_index(local, index)) {\n\t\tindex = get_wep_tx_idx(local);\n\t\tif (index < 0)\n\t\t\tindex = 0;\n\t}\n\tdwrq->flags |= index + 1;\n\n\t \n\twep_key_len = get_wep_key(local, index, &buf[0], sizeof(buf));\n\tif (wep_key_len < 0) {\n\t\tdwrq->length = 0;\n\t} else {\n\t\tdwrq->length = wep_key_len;\n\t\tmemcpy(extra, buf, dwrq->length);\n\t}\n\n\treturn 0;\n}\n\n \n \nstatic int airo_set_encodeext(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu,\n\t\t\t    char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tstruct iw_point *encoding = &wrqu->encoding;\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\n\tint perm = (encoding->flags & IW_ENCODE_TEMP ? 0 : 1);\n\t__le16 currentAuthType = local->config.authType;\n\tint idx, key_len, alg = ext->alg, set_key = 1, rc;\n\twep_key_t key;\n\n\tif (!local->wep_capable)\n\t\treturn -EOPNOTSUPP;\n\n\treadConfigRid(local, 1);\n\n\t \n\tidx = encoding->flags & IW_ENCODE_INDEX;\n\tif (idx) {\n\t\tif (!valid_index(local, idx - 1))\n\t\t\treturn -EINVAL;\n\t\tidx--;\n\t} else {\n\t\tidx = get_wep_tx_idx(local);\n\t\tif (idx < 0)\n\t\t\tidx = 0;\n\t}\n\n\tif (encoding->flags & IW_ENCODE_DISABLED)\n\t\talg = IW_ENCODE_ALG_NONE;\n\n\tif (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {\n\t\t \n\t\trc = set_wep_tx_idx(local, idx, perm, 1);\n\t\tif (rc < 0) {\n\t\t\tairo_print_err(local->dev->name, \"failed to set \"\n\t\t\t               \"WEP transmit index to %d: %d.\",\n\t\t\t               idx, rc);\n\t\t\treturn rc;\n\t\t}\n\t\tset_key = ext->key_len > 0 ? 1 : 0;\n\t}\n\n\tif (set_key) {\n\t\t \n\t\tmemset(key.key, 0, MAX_KEY_SIZE);\n\t\tswitch (alg) {\n\t\tcase IW_ENCODE_ALG_NONE:\n\t\t\tkey.len = 0;\n\t\t\tbreak;\n\t\tcase IW_ENCODE_ALG_WEP:\n\t\t\tif (ext->key_len > MIN_KEY_SIZE) {\n\t\t\t\tkey.len = MAX_KEY_SIZE;\n\t\t\t} else if (ext->key_len > 0) {\n\t\t\t\tkey.len = MIN_KEY_SIZE;\n\t\t\t} else {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tkey_len = min (ext->key_len, key.len);\n\t\t\tmemcpy(key.key, ext->key, key_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (key.len == 0) {\n\t\t\trc = set_wep_tx_idx(local, idx, perm, 1);\n\t\t\tif (rc < 0) {\n\t\t\t\tairo_print_err(local->dev->name,\n\t\t\t\t\t       \"failed to set WEP transmit index to %d: %d.\",\n\t\t\t\t\t       idx, rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\trc = set_wep_key(local, idx, key.key, key.len, perm, 1);\n\t\t\tif (rc < 0) {\n\t\t\t\tairo_print_err(local->dev->name,\n\t\t\t\t\t       \"failed to set WEP key at index %d: %d.\",\n\t\t\t\t\t       idx, rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (encoding->flags & IW_ENCODE_DISABLED)\n\t\tset_auth_type(local, AUTH_OPEN);\t \n\tif (encoding->flags & IW_ENCODE_RESTRICTED)\n\t\tset_auth_type(local, AUTH_SHAREDKEY);\t \n\tif (encoding->flags & IW_ENCODE_OPEN)\n\t\tset_auth_type(local, AUTH_ENCRYPT);\n\t \n\tif (local->config.authType != currentAuthType)\n\t\tset_bit (FLAG_COMMIT, &local->flags);\n\n\treturn -EINPROGRESS;\n}\n\n\n \n \nstatic int airo_get_encodeext(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu,\n\t\t\t    char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tstruct iw_point *encoding = &wrqu->encoding;\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\n\tint idx, max_key_len, wep_key_len;\n\tu8 buf[16];\n\n\tif (!local->wep_capable)\n\t\treturn -EOPNOTSUPP;\n\n\treadConfigRid(local, 1);\n\n\tmax_key_len = encoding->length - sizeof(*ext);\n\tif (max_key_len < 0)\n\t\treturn -EINVAL;\n\n\tidx = encoding->flags & IW_ENCODE_INDEX;\n\tif (idx) {\n\t\tif (!valid_index(local, idx - 1))\n\t\t\treturn -EINVAL;\n\t\tidx--;\n\t} else {\n\t\tidx = get_wep_tx_idx(local);\n\t\tif (idx < 0)\n\t\t\tidx = 0;\n\t}\n\n\tencoding->flags = idx + 1;\n\tmemset(ext, 0, sizeof(*ext));\n\n\t \n\tswitch(local->config.authType) {\n\t\tcase AUTH_ENCRYPT:\n\t\t\tencoding->flags = IW_ENCODE_ALG_WEP | IW_ENCODE_ENABLED;\n\t\t\tbreak;\n\t\tcase AUTH_SHAREDKEY:\n\t\t\tencoding->flags = IW_ENCODE_ALG_WEP | IW_ENCODE_ENABLED;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase AUTH_OPEN:\n\t\t\tencoding->flags = IW_ENCODE_ALG_NONE | IW_ENCODE_DISABLED;\n\t\t\tbreak;\n\t}\n\t \n\tencoding->flags |= IW_ENCODE_NOKEY;\n\tmemset(extra, 0, 16);\n\n\t \n\twep_key_len = get_wep_key(local, idx, &buf[0], sizeof(buf));\n\tif (wep_key_len < 0) {\n\t\text->key_len = 0;\n\t} else {\n\t\text->key_len = wep_key_len;\n\t\tmemcpy(extra, buf, ext->key_len);\n\t}\n\n\treturn 0;\n}\n\n\n \n \nstatic int airo_set_auth(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tstruct iw_param *param = &wrqu->param;\n\t__le16 currentAuthType = local->config.authType;\n\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_KEY_MGMT:\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\t\t \n\t\tbreak;\n\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\tif (param->value) {\n\t\t\t \n\t\t\tif (currentAuthType == AUTH_OPEN)\n\t\t\t\tset_auth_type(local, AUTH_ENCRYPT);\n\t\t} else {\n\t\t\tset_auth_type(local, AUTH_OPEN);\n\t\t}\n\n\t\t \n\t\tif (local->config.authType != currentAuthType)\n\t\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\tbreak;\n\n\tcase IW_AUTH_80211_AUTH_ALG: {\n\t\t\tif (param->value & IW_AUTH_ALG_SHARED_KEY) {\n\t\t\t\tset_auth_type(local, AUTH_SHAREDKEY);\n\t\t\t} else if (param->value & IW_AUTH_ALG_OPEN_SYSTEM) {\n\t\t\t\t \n\t\t\t\tset_auth_type(local, local->last_auth);\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\t\t\tif (local->config.authType != currentAuthType)\n\t\t\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\t\tbreak;\n\t\t}\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\t \n\t\tif (param->value > 0)\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn -EINPROGRESS;\n}\n\n\n \n \nstatic int airo_get_auth(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tstruct iw_param *param = &wrqu->param;\n\t__le16 currentAuthType = local->config.authType;\n\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\tswitch (currentAuthType) {\n\t\tcase AUTH_SHAREDKEY:\n\t\tcase AUTH_ENCRYPT:\n\t\t\tparam->value = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparam->value = 0;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tswitch (currentAuthType) {\n\t\tcase AUTH_SHAREDKEY:\n\t\t\tparam->value = IW_AUTH_ALG_SHARED_KEY;\n\t\t\tbreak;\n\t\tcase AUTH_ENCRYPT:\n\t\tdefault:\n\t\t\tparam->value = IW_AUTH_ALG_OPEN_SYSTEM;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tparam->value = 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n\n \n \nstatic int airo_set_txpow(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu,\n\t\t\t  char *extra)\n{\n\tstruct iw_param *vwrq = &wrqu->txpower;\n\tstruct airo_info *local = dev->ml_priv;\n\tCapabilityRid cap_rid;\t\t \n\tint i;\n\tint rc = -EINVAL;\n\t__le16 v = cpu_to_le16(vwrq->value);\n\n\treadCapabilityRid(local, &cap_rid, 1);\n\n\tif (vwrq->disabled) {\n\t\tset_bit (FLAG_RADIO_OFF, &local->flags);\n\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\treturn -EINPROGRESS;\t\t \n\t}\n\tif (vwrq->flags != IW_TXPOW_MWATT) {\n\t\treturn -EINVAL;\n\t}\n\tclear_bit (FLAG_RADIO_OFF, &local->flags);\n\tfor (i = 0; i < 8 && cap_rid.txPowerLevels[i]; i++)\n\t\tif (v == cap_rid.txPowerLevels[i]) {\n\t\t\treadConfigRid(local, 1);\n\t\t\tlocal->config.txPower = v;\n\t\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\t\trc = -EINPROGRESS;\t \n\t\t\tbreak;\n\t\t}\n\treturn rc;\n}\n\n \n \nstatic int airo_get_txpow(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu,\n\t\t\t  char *extra)\n{\n\tstruct iw_param *vwrq = &wrqu->txpower;\n\tstruct airo_info *local = dev->ml_priv;\n\n\treadConfigRid(local, 1);\n\tvwrq->value = le16_to_cpu(local->config.txPower);\n\tvwrq->fixed = 1;\t \n\tvwrq->disabled = test_bit(FLAG_RADIO_OFF, &local->flags);\n\tvwrq->flags = IW_TXPOW_MWATT;\n\n\treturn 0;\n}\n\n \n \nstatic int airo_set_retry(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu,\n\t\t\t  char *extra)\n{\n\tstruct iw_param *vwrq = &wrqu->retry;\n\tstruct airo_info *local = dev->ml_priv;\n\tint rc = -EINVAL;\n\n\tif (vwrq->disabled) {\n\t\treturn -EINVAL;\n\t}\n\treadConfigRid(local, 1);\n\tif (vwrq->flags & IW_RETRY_LIMIT) {\n\t\t__le16 v = cpu_to_le16(vwrq->value);\n\t\tif (vwrq->flags & IW_RETRY_LONG)\n\t\t\tlocal->config.longRetryLimit = v;\n\t\telse if (vwrq->flags & IW_RETRY_SHORT)\n\t\t\tlocal->config.shortRetryLimit = v;\n\t\telse {\n\t\t\t \n\t\t\tlocal->config.longRetryLimit = v;\n\t\t\tlocal->config.shortRetryLimit = v;\n\t\t}\n\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\trc = -EINPROGRESS;\t\t \n\t}\n\tif (vwrq->flags & IW_RETRY_LIFETIME) {\n\t\tlocal->config.txLifetime = cpu_to_le16(vwrq->value / 1024);\n\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\trc = -EINPROGRESS;\t\t \n\t}\n\treturn rc;\n}\n\n \n \nstatic int airo_get_retry(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu,\n\t\t\t  char *extra)\n{\n\tstruct iw_param *vwrq = &wrqu->retry;\n\tstruct airo_info *local = dev->ml_priv;\n\n\tvwrq->disabled = 0;       \n\n\treadConfigRid(local, 1);\n\t \n\tif ((vwrq->flags & IW_RETRY_TYPE) == IW_RETRY_LIFETIME) {\n\t\tvwrq->flags = IW_RETRY_LIFETIME;\n\t\tvwrq->value = le16_to_cpu(local->config.txLifetime) * 1024;\n\t} else if ((vwrq->flags & IW_RETRY_LONG)) {\n\t\tvwrq->flags = IW_RETRY_LIMIT | IW_RETRY_LONG;\n\t\tvwrq->value = le16_to_cpu(local->config.longRetryLimit);\n\t} else {\n\t\tvwrq->flags = IW_RETRY_LIMIT;\n\t\tvwrq->value = le16_to_cpu(local->config.shortRetryLimit);\n\t\tif (local->config.shortRetryLimit != local->config.longRetryLimit)\n\t\t\tvwrq->flags |= IW_RETRY_SHORT;\n\t}\n\n\treturn 0;\n}\n\n \n \nstatic int airo_get_range(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu,\n\t\t\t  char *extra)\n{\n\tstruct iw_point *dwrq = &wrqu->data;\n\tstruct airo_info *local = dev->ml_priv;\n\tstruct iw_range *range = (struct iw_range *) extra;\n\tCapabilityRid cap_rid;\t\t \n\tint\t\ti;\n\tint\t\tk;\n\n\treadCapabilityRid(local, &cap_rid, 1);\n\n\tdwrq->length = sizeof(struct iw_range);\n\tmemset(range, 0, sizeof(*range));\n\trange->min_nwid = 0x0000;\n\trange->max_nwid = 0x0000;\n\trange->num_channels = 14;\n\t \n\tk = 0;\n\tfor (i = 0; i < 14; i++) {\n\t\trange->freq[k].i = i + 1;  \n\t\trange->freq[k].m = 100000 *\n\t\t     ieee80211_channel_to_frequency(i + 1, NL80211_BAND_2GHZ);\n\t\trange->freq[k++].e = 1;\t \n\t}\n\trange->num_frequency = k;\n\n\trange->sensitivity = 65535;\n\n\t \n\tif (local->rssi)\n\t\trange->max_qual.qual = 100;\t \n\telse\n\t\trange->max_qual.qual = airo_get_max_quality(&cap_rid);\n\trange->max_qual.level = 0x100 - 120;\t \n\trange->max_qual.noise = 0x100 - 120;\t \n\n\t \n\t \n\tif (local->rssi) {\n\t\trange->avg_qual.qual = 50;\t\t \n\t\trange->avg_qual.level = 0x100 - 70;\t \n\t} else {\n\t\trange->avg_qual.qual = airo_get_avg_quality(&cap_rid);\n\t\trange->avg_qual.level = 0x100 - 80;\t \n\t}\n\trange->avg_qual.noise = 0x100 - 85;\t\t \n\n\tfor (i = 0 ; i < 8 ; i++) {\n\t\trange->bitrate[i] = cap_rid.supportedRates[i] * 500000;\n\t\tif (range->bitrate[i] == 0)\n\t\t\tbreak;\n\t}\n\trange->num_bitrates = i;\n\n\t \n\tif (i > 2)\n\t\trange->throughput = 5000 * 1000;\n\telse\n\t\trange->throughput = 1500 * 1000;\n\n\trange->min_rts = 0;\n\trange->max_rts = AIRO_DEF_MTU;\n\trange->min_frag = 256;\n\trange->max_frag = AIRO_DEF_MTU;\n\n\tif (cap_rid.softCap & cpu_to_le16(2)) {\n\t\t \n\t\trange->encoding_size[0] = 5;\n\t\t \n\t\tif (cap_rid.softCap & cpu_to_le16(0x100)) {\n\t\t\trange->encoding_size[1] = 13;\n\t\t\trange->num_encoding_sizes = 2;\n\t\t} else\n\t\t\trange->num_encoding_sizes = 1;\n\t\trange->max_encoding_tokens =\n\t\t\tcap_rid.softCap & cpu_to_le16(0x80) ? 4 : 1;\n\t} else {\n\t\trange->num_encoding_sizes = 0;\n\t\trange->max_encoding_tokens = 0;\n\t}\n\trange->min_pmp = 0;\n\trange->max_pmp = 5000000;\t \n\trange->min_pmt = 0;\n\trange->max_pmt = 65535 * 1024;\t \n\trange->pmp_flags = IW_POWER_PERIOD;\n\trange->pmt_flags = IW_POWER_TIMEOUT;\n\trange->pm_capa = IW_POWER_PERIOD | IW_POWER_TIMEOUT | IW_POWER_ALL_R;\n\n\t \n\tfor (i = 0 ; i < 8 ; i++) {\n\t\trange->txpower[i] = le16_to_cpu(cap_rid.txPowerLevels[i]);\n\t\tif (range->txpower[i] == 0)\n\t\t\tbreak;\n\t}\n\trange->num_txpower = i;\n\trange->txpower_capa = IW_TXPOW_MWATT;\n\trange->we_version_source = 19;\n\trange->we_version_compiled = WIRELESS_EXT;\n\trange->retry_capa = IW_RETRY_LIMIT | IW_RETRY_LIFETIME;\n\trange->retry_flags = IW_RETRY_LIMIT;\n\trange->r_time_flags = IW_RETRY_LIFETIME;\n\trange->min_retry = 1;\n\trange->max_retry = 65535;\n\trange->min_r_time = 1024;\n\trange->max_r_time = 65535 * 1024;\n\n\t \n\trange->event_capa[0] = (IW_EVENT_CAPA_K_0 |\n\t\t\t\tIW_EVENT_CAPA_MASK(SIOCGIWTHRSPY) |\n\t\t\t\tIW_EVENT_CAPA_MASK(SIOCGIWAP) |\n\t\t\t\tIW_EVENT_CAPA_MASK(SIOCGIWSCAN));\n\trange->event_capa[1] = IW_EVENT_CAPA_K_1;\n\trange->event_capa[4] = IW_EVENT_CAPA_MASK(IWEVTXDROP);\n\treturn 0;\n}\n\n \n \nstatic int airo_set_power(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *vwrq = &wrqu->power;\n\tstruct airo_info *local = dev->ml_priv;\n\n\treadConfigRid(local, 1);\n\tif (vwrq->disabled) {\n\t\tif (sniffing_mode(local))\n\t\t\treturn -EINVAL;\n\t\tlocal->config.powerSaveMode = POWERSAVE_CAM;\n\t\tlocal->config.rmode &= ~RXMODE_MASK;\n\t\tlocal->config.rmode |= RXMODE_BC_MC_ADDR;\n\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\treturn -EINPROGRESS;\t\t \n\t}\n\tif ((vwrq->flags & IW_POWER_TYPE) == IW_POWER_TIMEOUT) {\n\t\tlocal->config.fastListenDelay = cpu_to_le16((vwrq->value + 500) / 1024);\n\t\tlocal->config.powerSaveMode = POWERSAVE_PSPCAM;\n\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t} else if ((vwrq->flags & IW_POWER_TYPE) == IW_POWER_PERIOD) {\n\t\tlocal->config.fastListenInterval =\n\t\tlocal->config.listenInterval =\n\t\t\tcpu_to_le16((vwrq->value + 500) / 1024);\n\t\tlocal->config.powerSaveMode = POWERSAVE_PSPCAM;\n\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t}\n\tswitch (vwrq->flags & IW_POWER_MODE) {\n\t\tcase IW_POWER_UNICAST_R:\n\t\t\tif (sniffing_mode(local))\n\t\t\t\treturn -EINVAL;\n\t\t\tlocal->config.rmode &= ~RXMODE_MASK;\n\t\t\tlocal->config.rmode |= RXMODE_ADDR;\n\t\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\t\tbreak;\n\t\tcase IW_POWER_ALL_R:\n\t\t\tif (sniffing_mode(local))\n\t\t\t\treturn -EINVAL;\n\t\t\tlocal->config.rmode &= ~RXMODE_MASK;\n\t\t\tlocal->config.rmode |= RXMODE_BC_MC_ADDR;\n\t\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\t\tbreak;\n\t\tcase IW_POWER_ON:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\t \n\t \n\treturn -EINPROGRESS;\t\t \n}\n\n \n \nstatic int airo_get_power(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu,\n\t\t\t  char *extra)\n{\n\tstruct iw_param *vwrq = &wrqu->power;\n\tstruct airo_info *local = dev->ml_priv;\n\t__le16 mode;\n\n\treadConfigRid(local, 1);\n\tmode = local->config.powerSaveMode;\n\tif ((vwrq->disabled = (mode == POWERSAVE_CAM)))\n\t\treturn 0;\n\tif ((vwrq->flags & IW_POWER_TYPE) == IW_POWER_TIMEOUT) {\n\t\tvwrq->value = le16_to_cpu(local->config.fastListenDelay) * 1024;\n\t\tvwrq->flags = IW_POWER_TIMEOUT;\n\t} else {\n\t\tvwrq->value = le16_to_cpu(local->config.fastListenInterval) * 1024;\n\t\tvwrq->flags = IW_POWER_PERIOD;\n\t}\n\tif ((local->config.rmode & RXMODE_MASK) == RXMODE_ADDR)\n\t\tvwrq->flags |= IW_POWER_UNICAST_R;\n\telse\n\t\tvwrq->flags |= IW_POWER_ALL_R;\n\n\treturn 0;\n}\n\n \n \nstatic int airo_set_sens(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *wrqu,\n\t\t\t char *extra)\n{\n\tstruct iw_param *vwrq = &wrqu->sens;\n\tstruct airo_info *local = dev->ml_priv;\n\n\treadConfigRid(local, 1);\n\tlocal->config.rssiThreshold =\n\t\tcpu_to_le16(vwrq->disabled ? RSSI_DEFAULT : vwrq->value);\n\tset_bit (FLAG_COMMIT, &local->flags);\n\n\treturn -EINPROGRESS;\t\t \n}\n\n \n \nstatic int airo_get_sens(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *wrqu,\n\t\t\t char *extra)\n{\n\tstruct iw_param *vwrq = &wrqu->sens;\n\tstruct airo_info *local = dev->ml_priv;\n\n\treadConfigRid(local, 1);\n\tvwrq->value = le16_to_cpu(local->config.rssiThreshold);\n\tvwrq->disabled = (vwrq->value == 0);\n\tvwrq->fixed = 1;\n\n\treturn 0;\n}\n\n \n \nstatic int airo_get_aplist(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu,\n\t\t\t   char *extra)\n{\n\tstruct iw_point *dwrq = &wrqu->data;\n\tstruct airo_info *local = dev->ml_priv;\n\tstruct sockaddr *address = (struct sockaddr *) extra;\n\tstruct iw_quality *qual;\n\tBSSListRid BSSList;\n\tint i;\n\tint loseSync = capable(CAP_NET_ADMIN) ? 1: -1;\n\n\tqual = kmalloc_array(IW_MAX_AP, sizeof(*qual), GFP_KERNEL);\n\tif (!qual)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < IW_MAX_AP; i++) {\n\t\tu16 dBm;\n\t\tif (readBSSListRid(local, loseSync, &BSSList))\n\t\t\tbreak;\n\t\tloseSync = 0;\n\t\tmemcpy(address[i].sa_data, BSSList.bssid, ETH_ALEN);\n\t\taddress[i].sa_family = ARPHRD_ETHER;\n\t\tdBm = le16_to_cpu(BSSList.dBm);\n\t\tif (local->rssi) {\n\t\t\tqual[i].level = 0x100 - dBm;\n\t\t\tqual[i].qual = airo_dbm_to_pct(local->rssi, dBm);\n\t\t\tqual[i].updated = IW_QUAL_QUAL_UPDATED\n\t\t\t\t\t| IW_QUAL_LEVEL_UPDATED\n\t\t\t\t\t| IW_QUAL_DBM;\n\t\t} else {\n\t\t\tqual[i].level = (dBm + 321) / 2;\n\t\t\tqual[i].qual = 0;\n\t\t\tqual[i].updated = IW_QUAL_QUAL_INVALID\n\t\t\t\t\t| IW_QUAL_LEVEL_UPDATED\n\t\t\t\t\t| IW_QUAL_DBM;\n\t\t}\n\t\tqual[i].noise = local->wstats.qual.noise;\n\t\tif (BSSList.index == cpu_to_le16(0xffff))\n\t\t\tbreak;\n\t}\n\tif (!i) {\n\t\tStatusRid status_rid;\t\t \n\t\treadStatusRid(local, &status_rid, 1);\n\t\tfor (i = 0;\n\t\t     i < min(IW_MAX_AP, 4) &&\n\t\t\t     (status_rid.bssid[i][0]\n\t\t\t      & status_rid.bssid[i][1]\n\t\t\t      & status_rid.bssid[i][2]\n\t\t\t      & status_rid.bssid[i][3]\n\t\t\t      & status_rid.bssid[i][4]\n\t\t\t      & status_rid.bssid[i][5])!=0xff &&\n\t\t\t     (status_rid.bssid[i][0]\n\t\t\t      | status_rid.bssid[i][1]\n\t\t\t      | status_rid.bssid[i][2]\n\t\t\t      | status_rid.bssid[i][3]\n\t\t\t      | status_rid.bssid[i][4]\n\t\t\t      | status_rid.bssid[i][5]);\n\t\t     i++) {\n\t\t\tmemcpy(address[i].sa_data,\n\t\t\t       status_rid.bssid[i], ETH_ALEN);\n\t\t\taddress[i].sa_family = ARPHRD_ETHER;\n\t\t}\n\t} else {\n\t\tdwrq->flags = 1;  \n\t\tmemcpy(extra + sizeof(struct sockaddr) * i, qual,\n\t\t       sizeof(struct iw_quality) * i);\n\t}\n\tdwrq->length = i;\n\n\tkfree(qual);\n\treturn 0;\n}\n\n \n \nstatic int airo_set_scan(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *wrqu,\n\t\t\t char *extra)\n{\n\tstruct airo_info *ai = dev->ml_priv;\n\tCmd cmd;\n\tResp rsp;\n\tint wake = 0;\n\tAPListRid APList_rid_empty;\n\n\t \n\tif (ai->flags & FLAG_RADIO_MASK) return -ENETDOWN;\n\n\tif (down_interruptible(&ai->sem))\n\t\treturn -ERESTARTSYS;\n\n\t \n\tif (ai->scan_timeout > 0)\n\t\tgoto out;\n\n\t \n\tmemset(&APList_rid_empty, 0, sizeof(APList_rid_empty));\n\tAPList_rid_empty.len = cpu_to_le16(sizeof(APList_rid_empty));\n\tdisable_MAC(ai, 2);\n\twriteAPListRid(ai, &APList_rid_empty, 0);\n\tenable_MAC(ai, 0);\n\n\t \n\tai->scan_timeout = RUN_AT(3*HZ);\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.cmd = CMD_LISTBSS;\n\tissuecommand(ai, &cmd, &rsp, true);\n\twake = 1;\n\nout:\n\tup(&ai->sem);\n\tif (wake)\n\t\twake_up_interruptible(&ai->thr_wait);\n\treturn 0;\n}\n\n \n \nstatic inline char *airo_translate_scan(struct net_device *dev,\n\t\t\t\t\tstruct iw_request_info *info,\n\t\t\t\t\tchar *current_ev,\n\t\t\t\t\tchar *end_buf,\n\t\t\t\t\tBSSListRid *bss)\n{\n\tstruct airo_info *ai = dev->ml_priv;\n\tstruct iw_event\t\tiwe;\t\t \n\t__le16\t\t\tcapabilities;\n\tchar *\t\t\tcurrent_val;\t \n\tint\t\t\ti;\n\tchar *\t\tbuf;\n\tu16 dBm;\n\n\t \n\tiwe.cmd = SIOCGIWAP;\n\tiwe.u.ap_addr.sa_family = ARPHRD_ETHER;\n\tmemcpy(iwe.u.ap_addr.sa_data, bss->bssid, ETH_ALEN);\n\tcurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\n\t\t\t\t\t  &iwe, IW_EV_ADDR_LEN);\n\n\t \n\n\t \n\tiwe.u.data.length = bss->ssidLen;\n\tif (iwe.u.data.length > 32)\n\t\tiwe.u.data.length = 32;\n\tiwe.cmd = SIOCGIWESSID;\n\tiwe.u.data.flags = 1;\n\tcurrent_ev = iwe_stream_add_point(info, current_ev, end_buf,\n\t\t\t\t\t  &iwe, bss->ssid);\n\n\t \n\tiwe.cmd = SIOCGIWMODE;\n\tcapabilities = bss->cap;\n\tif (capabilities & (CAP_ESS | CAP_IBSS)) {\n\t\tif (capabilities & CAP_ESS)\n\t\t\tiwe.u.mode = IW_MODE_MASTER;\n\t\telse\n\t\t\tiwe.u.mode = IW_MODE_ADHOC;\n\t\tcurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\n\t\t\t\t\t\t  &iwe, IW_EV_UINT_LEN);\n\t}\n\n\t \n\tiwe.cmd = SIOCGIWFREQ;\n\tiwe.u.freq.m = le16_to_cpu(bss->dsChannel);\n\tiwe.u.freq.m = 100000 *\n\t      ieee80211_channel_to_frequency(iwe.u.freq.m, NL80211_BAND_2GHZ);\n\tiwe.u.freq.e = 1;\n\tcurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\n\t\t\t\t\t  &iwe, IW_EV_FREQ_LEN);\n\n\tdBm = le16_to_cpu(bss->dBm);\n\n\t \n\tiwe.cmd = IWEVQUAL;\n\tif (ai->rssi) {\n\t\tiwe.u.qual.level = 0x100 - dBm;\n\t\tiwe.u.qual.qual = airo_dbm_to_pct(ai->rssi, dBm);\n\t\tiwe.u.qual.updated = IW_QUAL_QUAL_UPDATED\n\t\t\t\t| IW_QUAL_LEVEL_UPDATED\n\t\t\t\t| IW_QUAL_DBM;\n\t} else {\n\t\tiwe.u.qual.level = (dBm + 321) / 2;\n\t\tiwe.u.qual.qual = 0;\n\t\tiwe.u.qual.updated = IW_QUAL_QUAL_INVALID\n\t\t\t\t| IW_QUAL_LEVEL_UPDATED\n\t\t\t\t| IW_QUAL_DBM;\n\t}\n\tiwe.u.qual.noise = ai->wstats.qual.noise;\n\tcurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\n\t\t\t\t\t  &iwe, IW_EV_QUAL_LEN);\n\n\t \n\tiwe.cmd = SIOCGIWENCODE;\n\tif (capabilities & CAP_PRIVACY)\n\t\tiwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;\n\telse\n\t\tiwe.u.data.flags = IW_ENCODE_DISABLED;\n\tiwe.u.data.length = 0;\n\tcurrent_ev = iwe_stream_add_point(info, current_ev, end_buf,\n\t\t\t\t\t  &iwe, bss->ssid);\n\n\t \n\tcurrent_val = current_ev + iwe_stream_lcp_len(info);\n\n\tiwe.cmd = SIOCGIWRATE;\n\t \n\tiwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;\n\t \n\tfor (i = 0 ; i < 8 ; i++) {\n\t\t \n\t\tif (bss->rates[i] == 0)\n\t\t\tbreak;\n\t\t \n\t\tiwe.u.bitrate.value = ((bss->rates[i] & 0x7f) * 500000);\n\t\t \n\t\tcurrent_val = iwe_stream_add_value(info, current_ev,\n\t\t\t\t\t\t   current_val, end_buf,\n\t\t\t\t\t\t   &iwe, IW_EV_PARAM_LEN);\n\t}\n\t \n\tif ((current_val - current_ev) > iwe_stream_lcp_len(info))\n\t\tcurrent_ev = current_val;\n\n\t \n\tbuf = kmalloc(30, GFP_KERNEL);\n\tif (buf) {\n\t\tiwe.cmd = IWEVCUSTOM;\n\t\tsprintf(buf, \"bcn_int=%d\", bss->beaconInterval);\n\t\tiwe.u.data.length = strlen(buf);\n\t\tcurrent_ev = iwe_stream_add_point(info, current_ev, end_buf,\n\t\t\t\t\t\t  &iwe, buf);\n\t\tkfree(buf);\n\t}\n\n\t \n\tif (test_bit(FLAG_WPA_CAPABLE, &ai->flags)) {\n\t\tunsigned int num_null_ies = 0;\n\t\tu16 length = sizeof (bss->extra.iep);\n\t\tu8 *ie = (void *)&bss->extra.iep;\n\n\t\twhile ((length >= 2) && (num_null_ies < 2)) {\n\t\t\tif (2 + ie[1] > length) {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (ie[0]) {\n\t\t\tcase WLAN_EID_SSID:\n\t\t\t\t \n\t\t\t\tif (!ie[1])\n\t\t\t\t\tnum_null_ies++;\n\t\t\t\tbreak;\n\n\t\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\t\tif (ie[1] >= 4 &&\n\t\t\t\t    ie[2] == 0x00 &&\n\t\t\t\t    ie[3] == 0x50 &&\n\t\t\t\t    ie[4] == 0xf2 &&\n\t\t\t\t    ie[5] == 0x01) {\n\t\t\t\t\tiwe.cmd = IWEVGENIE;\n\t\t\t\t\t \n\t\t\t\t\tiwe.u.data.length = min(ie[1] + 2,\n\t\t\t\t\t\t\t\t64);\n\t\t\t\t\tcurrent_ev = iwe_stream_add_point(\n\t\t\t\t\t\t\tinfo, current_ev,\n\t\t\t\t\t\t\tend_buf, &iwe, ie);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase WLAN_EID_RSN:\n\t\t\t\tiwe.cmd = IWEVGENIE;\n\t\t\t\t \n\t\t\t\tiwe.u.data.length = min(ie[1] + 2, 64);\n\t\t\t\tcurrent_ev = iwe_stream_add_point(\n\t\t\t\t\tinfo, current_ev, end_buf,\n\t\t\t\t\t&iwe, ie);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlength -= 2 + ie[1];\n\t\t\tie += 2 + ie[1];\n\t\t}\n\t}\n\treturn current_ev;\n}\n\n \n \nstatic int airo_get_scan(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *wrqu,\n\t\t\t char *extra)\n{\n\tstruct iw_point *dwrq = &wrqu->data;\n\tstruct airo_info *ai = dev->ml_priv;\n\tBSSListElement *net;\n\tint err = 0;\n\tchar *current_ev = extra;\n\n\t \n\tif (ai->scan_timeout > 0)\n\t\treturn -EAGAIN;\n\n\tif (down_interruptible(&ai->sem))\n\t\treturn -EAGAIN;\n\n\tlist_for_each_entry (net, &ai->network_list, list) {\n\t\t \n\t\tcurrent_ev = airo_translate_scan(dev, info, current_ev,\n\t\t\t\t\t\t extra + dwrq->length,\n\t\t\t\t\t\t &net->bss);\n\n\t\t \n\t\tif ((extra + dwrq->length - current_ev) <= IW_EV_ADDR_LEN) {\n\t\t\t \n\t\t\terr = -E2BIG;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tdwrq->length = (current_ev - extra);\n\tdwrq->flags = 0;\t \n\nout:\n\tup(&ai->sem);\n\treturn err;\n}\n\n \n \nstatic int airo_config_commit(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\t \n\t\t\t      union iwreq_data *wrqu,\t\t \n\t\t\t      char *extra)\t\t\t \n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\tif (!test_bit (FLAG_COMMIT, &local->flags))\n\t\treturn 0;\n\n\t \n\tdisable_MAC(local, 1);\n\tif (test_bit (FLAG_RESET, &local->flags)) {\n\t\tSsidRid SSID_rid;\n\n\t\treadSsidRid(local, &SSID_rid);\n\t\tif (test_bit(FLAG_MPI,&local->flags))\n\t\t\tsetup_card(local, dev, 1);\n\t\telse\n\t\t\treset_airo_card(dev);\n\t\tdisable_MAC(local, 1);\n\t\twriteSsidRid(local, &SSID_rid, 1);\n\t\twriteAPListRid(local, &local->APList, 1);\n\t}\n\tif (down_interruptible(&local->sem))\n\t\treturn -ERESTARTSYS;\n\twriteConfigRid(local, 0);\n\tenable_MAC(local, 0);\n\tif (test_bit (FLAG_RESET, &local->flags))\n\t\tairo_set_promisc(local, true);\n\telse\n\t\tup(&local->sem);\n\n\treturn 0;\n}\n\n \n \n\nstatic const struct iw_priv_args airo_private_args[] = {\n \n  { AIROIOCTL, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | sizeof (aironet_ioctl),\n    IW_PRIV_TYPE_BYTE | 2047, \"airoioctl\" },\n  { AIROIDIFC, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | sizeof (aironet_ioctl),\n    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"airoidifc\" },\n};\n\nstatic const iw_handler\t\tairo_handler[] =\n{\n\tIW_HANDLER(SIOCSIWCOMMIT,\tairo_config_commit),\n\tIW_HANDLER(SIOCGIWNAME,\t\tairo_get_name),\n\tIW_HANDLER(SIOCSIWFREQ,\t\tairo_set_freq),\n\tIW_HANDLER(SIOCGIWFREQ,\t\tairo_get_freq),\n\tIW_HANDLER(SIOCSIWMODE,\t\tairo_set_mode),\n\tIW_HANDLER(SIOCGIWMODE,\t\tairo_get_mode),\n\tIW_HANDLER(SIOCSIWSENS,\t\tairo_set_sens),\n\tIW_HANDLER(SIOCGIWSENS,\t\tairo_get_sens),\n\tIW_HANDLER(SIOCGIWRANGE,\tairo_get_range),\n\tIW_HANDLER(SIOCSIWSPY,\t\tiw_handler_set_spy),\n\tIW_HANDLER(SIOCGIWSPY,\t\tiw_handler_get_spy),\n\tIW_HANDLER(SIOCSIWTHRSPY,\tiw_handler_set_thrspy),\n\tIW_HANDLER(SIOCGIWTHRSPY,\tiw_handler_get_thrspy),\n\tIW_HANDLER(SIOCSIWAP,\t\tairo_set_wap),\n\tIW_HANDLER(SIOCGIWAP,\t\tairo_get_wap),\n\tIW_HANDLER(SIOCGIWAPLIST,\tairo_get_aplist),\n\tIW_HANDLER(SIOCSIWSCAN,\t\tairo_set_scan),\n\tIW_HANDLER(SIOCGIWSCAN,\t\tairo_get_scan),\n\tIW_HANDLER(SIOCSIWESSID,\tairo_set_essid),\n\tIW_HANDLER(SIOCGIWESSID,\tairo_get_essid),\n\tIW_HANDLER(SIOCSIWNICKN,\tairo_set_nick),\n\tIW_HANDLER(SIOCGIWNICKN,\tairo_get_nick),\n\tIW_HANDLER(SIOCSIWRATE,\t\tairo_set_rate),\n\tIW_HANDLER(SIOCGIWRATE,\t\tairo_get_rate),\n\tIW_HANDLER(SIOCSIWRTS,\t\tairo_set_rts),\n\tIW_HANDLER(SIOCGIWRTS,\t\tairo_get_rts),\n\tIW_HANDLER(SIOCSIWFRAG,\t\tairo_set_frag),\n\tIW_HANDLER(SIOCGIWFRAG,\t\tairo_get_frag),\n\tIW_HANDLER(SIOCSIWTXPOW,\tairo_set_txpow),\n\tIW_HANDLER(SIOCGIWTXPOW,\tairo_get_txpow),\n\tIW_HANDLER(SIOCSIWRETRY,\tairo_set_retry),\n\tIW_HANDLER(SIOCGIWRETRY,\tairo_get_retry),\n\tIW_HANDLER(SIOCSIWENCODE,\tairo_set_encode),\n\tIW_HANDLER(SIOCGIWENCODE,\tairo_get_encode),\n\tIW_HANDLER(SIOCSIWPOWER,\tairo_set_power),\n\tIW_HANDLER(SIOCGIWPOWER,\tairo_get_power),\n\tIW_HANDLER(SIOCSIWAUTH,\t\tairo_set_auth),\n\tIW_HANDLER(SIOCGIWAUTH,\t\tairo_get_auth),\n\tIW_HANDLER(SIOCSIWENCODEEXT,\tairo_set_encodeext),\n\tIW_HANDLER(SIOCGIWENCODEEXT,\tairo_get_encodeext),\n};\n\n \nstatic const iw_handler\t\tairo_private_handler[] =\n{\n\tNULL,\t\t\t\t \n};\n\nstatic const struct iw_handler_def\tairo_handler_def =\n{\n\t.num_standard\t= ARRAY_SIZE(airo_handler),\n\t.num_private\t= ARRAY_SIZE(airo_private_handler),\n\t.num_private_args = ARRAY_SIZE(airo_private_args),\n\t.standard\t= airo_handler,\n\t.private\t= airo_private_handler,\n\t.private_args\t= airo_private_args,\n\t.get_wireless_stats = airo_get_wireless_stats,\n};\n\n \nstatic int airo_siocdevprivate(struct net_device *dev, struct ifreq *rq,\n\t\t\t       void __user *data, int cmd)\n{\n\tint rc = 0;\n\tstruct airo_info *ai = dev->ml_priv;\n\n\tif (ai->power.event)\n\t\treturn 0;\n\n\tswitch (cmd) {\n#ifdef CISCO_EXT\n\tcase AIROIDIFC:\n#ifdef AIROOLDIDIFC\n\tcase AIROOLDIDIFC:\n#endif\n\t{\n\t\tint val = AIROMAGIC;\n\t\taironet_ioctl com;\n\t\tif (copy_from_user(&com, data, sizeof(com)))\n\t\t\trc = -EFAULT;\n\t\telse if (copy_to_user(com.data, (char *)&val, sizeof(val)))\n\t\t\trc = -EFAULT;\n\t}\n\tbreak;\n\n\tcase AIROIOCTL:\n#ifdef AIROOLDIOCTL\n\tcase AIROOLDIOCTL:\n#endif\n\t\t \n\t{\n\t\taironet_ioctl com;\n\t\tif (copy_from_user(&com, data, sizeof(com))) {\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (com.command == AIRORSWVERSION) {\n\t\t\tif (copy_to_user(com.data, swversion, sizeof(swversion)))\n\t\t\t\trc = -EFAULT;\n\t\t\telse\n\t\t\t\trc = 0;\n\t\t}\n\t\telse if (com.command <= AIRORRID)\n\t\t\trc = readrids(dev,&com);\n\t\telse if (com.command >= AIROPCAP && com.command <= (AIROPLEAPUSR+2))\n\t\t\trc = writerids(dev,&com);\n\t\telse if (com.command >= AIROFLSHRST && com.command <= AIRORESTART)\n\t\t\trc = flashcard(dev,&com);\n\t\telse\n\t\t\trc = -EINVAL;       \n\t}\n\tbreak;\n#endif  \n\n\t\n\tdefault:\n\t\trc = -EOPNOTSUPP;\n\t}\n\treturn rc;\n}\n\n \nstatic void airo_read_wireless_stats(struct airo_info *local)\n{\n\tStatusRid status_rid;\n\tStatsRid stats_rid;\n\tCapabilityRid cap_rid;\n\t__le32 *vals = stats_rid.vals;\n\n\t \n\tif (local->power.event)\n\t\treturn;\n\n\treadCapabilityRid(local, &cap_rid, 0);\n\treadStatusRid(local, &status_rid, 0);\n\treadStatsRid(local, &stats_rid, RID_STATS, 0);\n\n\t \n\tlocal->wstats.status = le16_to_cpu(status_rid.mode);\n\n\t \n\tif (local->rssi) {\n\t\tlocal->wstats.qual.level =\n\t\t\tairo_rssi_to_dbm(local->rssi,\n\t\t\t\t\t le16_to_cpu(status_rid.sigQuality));\n\t\t \n\t\tlocal->wstats.qual.qual =\n\t\t\tle16_to_cpu(status_rid.normalizedSignalStrength);\n\t} else {\n\t\tlocal->wstats.qual.level =\n\t\t\t(le16_to_cpu(status_rid.normalizedSignalStrength) + 321) / 2;\n\t\tlocal->wstats.qual.qual = airo_get_quality(&status_rid, &cap_rid);\n\t}\n\tif (le16_to_cpu(status_rid.len) >= 124) {\n\t\tlocal->wstats.qual.noise = 0x100 - status_rid.noisedBm;\n\t\tlocal->wstats.qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;\n\t} else {\n\t\tlocal->wstats.qual.noise = 0;\n\t\tlocal->wstats.qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED | IW_QUAL_NOISE_INVALID | IW_QUAL_DBM;\n\t}\n\n\t \n\tlocal->wstats.discard.nwid = le32_to_cpu(vals[56]) +\n\t\t\t\t     le32_to_cpu(vals[57]) +\n\t\t\t\t     le32_to_cpu(vals[58]);  \n\tlocal->wstats.discard.code = le32_to_cpu(vals[6]); \n\tlocal->wstats.discard.fragment = le32_to_cpu(vals[30]);\n\tlocal->wstats.discard.retries = le32_to_cpu(vals[10]);\n\tlocal->wstats.discard.misc = le32_to_cpu(vals[1]) +\n\t\t\t\t     le32_to_cpu(vals[32]);\n\tlocal->wstats.miss.beacon = le32_to_cpu(vals[34]);\n}\n\nstatic struct iw_statistics *airo_get_wireless_stats(struct net_device *dev)\n{\n\tstruct airo_info *local =  dev->ml_priv;\n\n\tif (!down_interruptible(&local->sem)) {\n\t\tairo_read_wireless_stats(local);\n\t\tup(&local->sem);\n\t}\n\treturn &local->wstats;\n}\n\n#ifdef CISCO_EXT\n \nstatic int readrids(struct net_device *dev, aironet_ioctl *comp)\n{\n\tunsigned short ridcode;\n\tunsigned char *iobuf;\n\tint len;\n\tstruct airo_info *ai = dev->ml_priv;\n\n\tif (test_bit(FLAG_FLASHING, &ai->flags))\n\t\treturn -EIO;\n\n\tswitch(comp->command)\n\t{\n\tcase AIROGCAP:      ridcode = RID_CAPABILITIES; break;\n\tcase AIROGCFG:      ridcode = RID_CONFIG;\n\t\tif (test_bit(FLAG_COMMIT, &ai->flags)) {\n\t\t\tdisable_MAC (ai, 1);\n\t\t\twriteConfigRid (ai, 1);\n\t\t\tenable_MAC(ai, 1);\n\t\t}\n\t\tbreak;\n\tcase AIROGSLIST:    ridcode = RID_SSID;         break;\n\tcase AIROGVLIST:    ridcode = RID_APLIST;       break;\n\tcase AIROGDRVNAM:   ridcode = RID_DRVNAME;      break;\n\tcase AIROGEHTENC:   ridcode = RID_ETHERENCAP;   break;\n\tcase AIROGWEPKTMP:  ridcode = RID_WEP_TEMP;\tbreak;\n\tcase AIROGWEPKNV:   ridcode = RID_WEP_PERM;\tbreak;\n\tcase AIROGSTAT:     ridcode = RID_STATUS;       break;\n\tcase AIROGSTATSD32: ridcode = RID_STATSDELTA;   break;\n\tcase AIROGSTATSC32: ridcode = RID_STATS;        break;\n\tcase AIROGMICSTATS:\n\t\tif (copy_to_user(comp->data, &ai->micstats,\n\t\t\t\t min((int)comp->len, (int)sizeof(ai->micstats))))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase AIRORRID:      ridcode = comp->ridnum;     break;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (ridcode == RID_WEP_TEMP || ridcode == RID_WEP_PERM) {\n\t\t \n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((iobuf = kzalloc(RIDSIZE, GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\n\tPC4500_readrid(ai, ridcode, iobuf, RIDSIZE, 1);\n\t \n\tlen = comp->len;\n\n\tif (copy_to_user(comp->data, iobuf, min(len, (int)RIDSIZE))) {\n\t\tkfree (iobuf);\n\t\treturn -EFAULT;\n\t}\n\tkfree (iobuf);\n\treturn 0;\n}\n\n \n\nstatic int writerids(struct net_device *dev, aironet_ioctl *comp)\n{\n\tstruct airo_info *ai = dev->ml_priv;\n\tint  ridcode;\n        int  enabled;\n\tint (*writer)(struct airo_info *, u16 rid, const void *, int, int);\n\tunsigned char *iobuf;\n\n\t \n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (test_bit(FLAG_FLASHING, &ai->flags))\n\t\treturn -EIO;\n\n\tridcode = 0;\n\twriter = do_writerid;\n\n\tswitch(comp->command)\n\t{\n\tcase AIROPSIDS:     ridcode = RID_SSID;         break;\n\tcase AIROPCAP:      ridcode = RID_CAPABILITIES; break;\n\tcase AIROPAPLIST:   ridcode = RID_APLIST;       break;\n\tcase AIROPCFG: ai->config.len = 0;\n\t\t\t    clear_bit(FLAG_COMMIT, &ai->flags);\n\t\t\t    ridcode = RID_CONFIG;       break;\n\tcase AIROPWEPKEYNV: ridcode = RID_WEP_PERM;     break;\n\tcase AIROPLEAPUSR:  ridcode = RID_LEAPUSERNAME; break;\n\tcase AIROPLEAPPWD:  ridcode = RID_LEAPPASSWORD; break;\n\tcase AIROPWEPKEY:   ridcode = RID_WEP_TEMP; writer = PC4500_writerid;\n\t\tbreak;\n\tcase AIROPLEAPUSR+1: ridcode = 0xFF2A;          break;\n\tcase AIROPLEAPUSR+2: ridcode = 0xFF2B;          break;\n\n\t\t \n\tcase AIROPMACON:\n\t\tif (enable_MAC(ai, 1) != 0)\n\t\t\treturn -EIO;\n\t\treturn 0;\n\n\t\t \n\tcase AIROPMACOFF:\n\t\tdisable_MAC(ai, 1);\n\t\treturn 0;\n\n\t\t \n\tcase AIROPSTCLR:\n\t\tif ((iobuf = kmalloc(RIDSIZE, GFP_KERNEL)) == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tPC4500_readrid(ai, RID_STATSDELTACLEAR, iobuf, RIDSIZE, 1);\n\n\t\tenabled = ai->micstats.enabled;\n\t\tmemset(&ai->micstats, 0, sizeof(ai->micstats));\n\t\tai->micstats.enabled = enabled;\n\n\t\tif (copy_to_user(comp->data, iobuf,\n\t\t\t\t min((int)comp->len, (int)RIDSIZE))) {\n\t\t\tkfree (iobuf);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tkfree (iobuf);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\t \n\t}\n\tif (comp->len > RIDSIZE)\n\t\treturn -EINVAL;\n\n\tif ((iobuf = kmalloc(RIDSIZE, GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(iobuf, comp->data, comp->len)) {\n\t\tkfree (iobuf);\n\t\treturn -EFAULT;\n\t}\n\n\tif (comp->command == AIROPCFG) {\n\t\tConfigRid *cfg = (ConfigRid *)iobuf;\n\n\t\tif (test_bit(FLAG_MIC_CAPABLE, &ai->flags))\n\t\t\tcfg->opmode |= MODE_MIC;\n\n\t\tif ((cfg->opmode & MODE_CFG_MASK) == MODE_STA_IBSS)\n\t\t\tset_bit (FLAG_ADHOC, &ai->flags);\n\t\telse\n\t\t\tclear_bit (FLAG_ADHOC, &ai->flags);\n\t}\n\n\tif ((*writer)(ai, ridcode, iobuf, comp->len, 1)) {\n\t\tkfree (iobuf);\n\t\treturn -EIO;\n\t}\n\tkfree (iobuf);\n\treturn 0;\n}\n\n \n\n \n\nstatic int flashcard(struct net_device *dev, aironet_ioctl *comp)\n{\n\tint z;\n\n\t \n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch(comp->command)\n\t{\n\tcase AIROFLSHRST:\n\t\treturn cmdreset((struct airo_info *)dev->ml_priv);\n\n\tcase AIROFLSHSTFL:\n\t\tif (!AIRO_FLASH(dev) &&\n\t\t    (AIRO_FLASH(dev) = kmalloc(FLASHSIZE, GFP_KERNEL)) == NULL)\n\t\t\treturn -ENOMEM;\n\t\treturn setflashmode((struct airo_info *)dev->ml_priv);\n\n\tcase AIROFLSHGCHR:  \n\t\tif (comp->len != sizeof(int))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&z, comp->data, comp->len))\n\t\t\treturn -EFAULT;\n\t\treturn flashgchar((struct airo_info *)dev->ml_priv, z, 8000);\n\n\tcase AIROFLSHPCHR:  \n\t\tif (comp->len != sizeof(int))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&z, comp->data, comp->len))\n\t\t\treturn -EFAULT;\n\t\treturn flashpchar((struct airo_info *)dev->ml_priv, z, 8000);\n\n\tcase AIROFLPUTBUF:  \n\t\tif (!AIRO_FLASH(dev))\n\t\t\treturn -ENOMEM;\n\t\tif (comp->len > FLASHSIZE)\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(AIRO_FLASH(dev), comp->data, comp->len))\n\t\t\treturn -EFAULT;\n\n\t\tflashputbuf((struct airo_info *)dev->ml_priv);\n\t\treturn 0;\n\n\tcase AIRORESTART:\n\t\tif (flashrestart((struct airo_info *)dev->ml_priv, dev))\n\t\t\treturn -EIO;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\n#define FLASH_COMMAND  0x7e7e\n\n \n\nstatic int cmdreset(struct airo_info *ai)\n{\n\tdisable_MAC(ai, 1);\n\n\tif (!waitbusy (ai)) {\n\t\tairo_print_info(ai->dev->name, \"Waitbusy hang before RESET\");\n\t\treturn -EBUSY;\n\t}\n\n\tOUT4500(ai, COMMAND, CMD_SOFTRESET);\n\n\tssleep(1);\t\t\t \n\n\tif (!waitbusy (ai)) {\n\t\tairo_print_info(ai->dev->name, \"Waitbusy hang AFTER RESET\");\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int setflashmode (struct airo_info *ai)\n{\n\tset_bit (FLAG_FLASHING, &ai->flags);\n\n\tOUT4500(ai, SWS0, FLASH_COMMAND);\n\tOUT4500(ai, SWS1, FLASH_COMMAND);\n\tif (probe) {\n\t\tOUT4500(ai, SWS0, FLASH_COMMAND);\n\t\tOUT4500(ai, COMMAND, 0x10);\n\t} else {\n\t\tOUT4500(ai, SWS2, FLASH_COMMAND);\n\t\tOUT4500(ai, SWS3, FLASH_COMMAND);\n\t\tOUT4500(ai, COMMAND, 0);\n\t}\n\tmsleep(500);\t\t \n\n\tif (!waitbusy(ai)) {\n\t\tclear_bit (FLAG_FLASHING, &ai->flags);\n\t\tairo_print_info(ai->dev->name, \"Waitbusy hang after setflash mode\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int flashpchar(struct airo_info *ai, int byte, int dwelltime)\n{\n\tint echo;\n\tint waittime;\n\n\tbyte |= 0x8000;\n\n\tif (dwelltime == 0)\n\t\tdwelltime = 200;\n\n\twaittime = dwelltime;\n\n\t \n\twhile ((IN4500 (ai, SWS0) & 0x8000) && waittime > 0) {\n\t\tudelay (50);\n\t\twaittime -= 50;\n\t}\n\n\t \n\tif (waittime <= 0) {\n\t\tairo_print_info(ai->dev->name, \"flash putchar busywait timeout!\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tdo {\n\t\tOUT4500(ai, SWS0, byte);\n\t\tudelay(50);\n\t\tdwelltime -= 50;\n\t\techo = IN4500(ai, SWS1);\n\t} while (dwelltime >= 0 && echo != byte);\n\n\tOUT4500(ai, SWS1, 0);\n\n\treturn (echo == byte) ? 0 : -EIO;\n}\n\n \nstatic int flashgchar(struct airo_info *ai, int matchbyte, int dwelltime)\n{\n\tint           rchar;\n\tunsigned char rbyte = 0;\n\n\tdo {\n\t\trchar = IN4500(ai, SWS1);\n\n\t\tif (dwelltime && !(0x8000 & rchar)) {\n\t\t\tdwelltime -= 10;\n\t\t\tmdelay(10);\n\t\t\tcontinue;\n\t\t}\n\t\trbyte = 0xff & rchar;\n\n\t\tif ((rbyte == matchbyte) && (0x8000 & rchar)) {\n\t\t\tOUT4500(ai, SWS1, 0);\n\t\t\treturn 0;\n\t\t}\n\t\tif (rbyte == 0x81 || rbyte == 0x82 || rbyte == 0x83 || rbyte == 0x1a || 0xffff == rchar)\n\t\t\tbreak;\n\t\tOUT4500(ai, SWS1, 0);\n\n\t} while (dwelltime > 0);\n\treturn -EIO;\n}\n\n \n\nstatic int flashputbuf(struct airo_info *ai)\n{\n\tint            nwords;\n\n\t \n\tif (test_bit(FLAG_MPI,&ai->flags))\n\t\tmemcpy_toio(ai->pciaux + 0x8000, ai->flash, FLASHSIZE);\n\telse {\n\t\tOUT4500(ai, AUXPAGE, 0x100);\n\t\tOUT4500(ai, AUXOFF, 0);\n\n\t\tfor (nwords = 0; nwords != FLASHSIZE / 2; nwords++) {\n\t\t\tOUT4500(ai, AUXDATA, ai->flash[nwords] & 0xffff);\n\t\t}\n\t}\n\tOUT4500(ai, SWS0, 0x8000);\n\n\treturn 0;\n}\n\n \nstatic int flashrestart(struct airo_info *ai, struct net_device *dev)\n{\n\tint    i, status;\n\n\tssleep(1);\t\t\t \n\tclear_bit (FLAG_FLASHING, &ai->flags);\n\tif (test_bit(FLAG_MPI, &ai->flags)) {\n\t\tstatus = mpi_init_descriptors(ai);\n\t\tif (status != SUCCESS)\n\t\t\treturn status;\n\t}\n\tstatus = setup_card(ai, dev, 1);\n\n\tif (!test_bit(FLAG_MPI,&ai->flags))\n\t\tfor (i = 0; i < MAX_FIDS; i++) {\n\t\t\tai->fids[i] = transmit_allocate\n\t\t\t\t(ai, AIRO_DEF_MTU, i >= MAX_FIDS / 2);\n\t\t}\n\n\tssleep(1);\t\t\t \n\treturn status;\n}\n#endif  \n\n \n\nmodule_init(airo_init_module);\nmodule_exit(airo_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}