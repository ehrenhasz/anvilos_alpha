{
  "module_name": "airo_cs.c",
  "hash_id": "c011dc8f0f9b12d55878d85c7cb38dc4a14d52ceeffa94d65be577fea96925f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/cisco/airo_cs.c",
  "human_readable_source": " \n\n#ifdef __IN_PCMCIA_PACKAGE__\n#include <pcmcia/k_compat.h>\n#endif\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/netdevice.h>\n\n#include <pcmcia/cistpl.h>\n#include <pcmcia/cisreg.h>\n#include <pcmcia/ds.h>\n\n#include <linux/io.h>\n\n#include \"airo.h\"\n\n\n \n\nMODULE_AUTHOR(\"Benjamin Reed\");\nMODULE_DESCRIPTION(\"Support for Cisco/Aironet 802.11 wireless ethernet \"\n\t\t   \"cards.  This is the module that links the PCMCIA card \"\n\t\t   \"with the airo module.\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\n \n\nstatic int airo_config(struct pcmcia_device *link);\nstatic void airo_release(struct pcmcia_device *link);\n\nstatic void airo_detach(struct pcmcia_device *p_dev);\n\nstruct local_info {\n\tstruct net_device *eth_dev;\n};\n\nstatic int airo_probe(struct pcmcia_device *p_dev)\n{\n\tstruct local_info *local;\n\n\tdev_dbg(&p_dev->dev, \"airo_attach()\\n\");\n\n\t \n\tlocal = kzalloc(sizeof(*local), GFP_KERNEL);\n\tif (!local)\n\t\treturn -ENOMEM;\n\n\tp_dev->priv = local;\n\n\treturn airo_config(p_dev);\n}  \n\nstatic void airo_detach(struct pcmcia_device *link)\n{\n\tdev_dbg(&link->dev, \"airo_detach\\n\");\n\n\tairo_release(link);\n\n\tif (((struct local_info *)link->priv)->eth_dev) {\n\t\tstop_airo_card(((struct local_info *)link->priv)->eth_dev,\n\t\t\t       0);\n\t}\n\t((struct local_info *)link->priv)->eth_dev = NULL;\n\n\tkfree(link->priv);\n}  \n\nstatic int airo_cs_config_check(struct pcmcia_device *p_dev, void *priv_data)\n{\n\tif (p_dev->config_index == 0)\n\t\treturn -EINVAL;\n\n\treturn pcmcia_request_io(p_dev);\n}\n\n\nstatic int airo_config(struct pcmcia_device *link)\n{\n\tint ret;\n\n\tdev_dbg(&link->dev, \"airo_config\\n\");\n\n\tlink->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_VPP |\n\t\tCONF_AUTO_AUDIO | CONF_AUTO_SET_IO;\n\n\tret = pcmcia_loop_config(link, airo_cs_config_check, NULL);\n\tif (ret)\n\t\tgoto failed;\n\n\tif (!link->irq)\n\t\tgoto failed;\n\n\tret = pcmcia_enable_device(link);\n\tif (ret)\n\t\tgoto failed;\n\t((struct local_info *)link->priv)->eth_dev =\n\t\tinit_airo_card(link->irq,\n\t\t\t       link->resource[0]->start, 1, &link->dev);\n\tif (!((struct local_info *)link->priv)->eth_dev)\n\t\tgoto failed;\n\n\treturn 0;\n\n failed:\n\tairo_release(link);\n\treturn -ENODEV;\n}  \n\nstatic void airo_release(struct pcmcia_device *link)\n{\n\tdev_dbg(&link->dev, \"airo_release\\n\");\n\tpcmcia_disable_device(link);\n}\n\nstatic int airo_suspend(struct pcmcia_device *link)\n{\n\tstruct local_info *local = link->priv;\n\n\tnetif_device_detach(local->eth_dev);\n\n\treturn 0;\n}\n\nstatic int airo_resume(struct pcmcia_device *link)\n{\n\tstruct local_info *local = link->priv;\n\n\tif (link->open) {\n\t\treset_airo_card(local->eth_dev);\n\t\tnetif_device_attach(local->eth_dev);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pcmcia_device_id airo_ids[] = {\n\tPCMCIA_DEVICE_MANF_CARD(0x015f, 0x000a),\n\tPCMCIA_DEVICE_MANF_CARD(0x015f, 0x0005),\n\tPCMCIA_DEVICE_MANF_CARD(0x015f, 0x0007),\n\tPCMCIA_DEVICE_MANF_CARD(0x0105, 0x0007),\n\tPCMCIA_DEVICE_NULL,\n};\nMODULE_DEVICE_TABLE(pcmcia, airo_ids);\n\nstatic struct pcmcia_driver airo_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"airo_cs\",\n\t.probe\t\t= airo_probe,\n\t.remove\t\t= airo_detach,\n\t.id_table       = airo_ids,\n\t.suspend\t= airo_suspend,\n\t.resume\t\t= airo_resume,\n};\nmodule_pcmcia_driver(airo_driver);\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}