{
  "module_name": "virt_wifi.c",
  "hash_id": "8efa5a1cb61be8e6941ac6d130f74a625cecf50dc99ef97f2d410b5f2529e3b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/virtual/virt_wifi.c",
  "human_readable_source": "\n \n\n#include <net/cfg80211.h>\n#include <net/rtnetlink.h>\n#include <linux/etherdevice.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n\nstatic struct wiphy *common_wiphy;\n\nstruct virt_wifi_wiphy_priv {\n\tstruct delayed_work scan_result;\n\tstruct cfg80211_scan_request *scan_request;\n\tbool being_deleted;\n};\n\nstatic struct ieee80211_channel channel_2ghz = {\n\t.band = NL80211_BAND_2GHZ,\n\t.center_freq = 2432,\n\t.hw_value = 2432,\n\t.max_power = 20,\n};\n\nstatic struct ieee80211_rate bitrates_2ghz[] = {\n\t{ .bitrate = 10 },\n\t{ .bitrate = 20 },\n\t{ .bitrate = 55 },\n\t{ .bitrate = 110 },\n\t{ .bitrate = 60 },\n\t{ .bitrate = 120 },\n\t{ .bitrate = 240 },\n};\n\nstatic struct ieee80211_supported_band band_2ghz = {\n\t.channels = &channel_2ghz,\n\t.bitrates = bitrates_2ghz,\n\t.band = NL80211_BAND_2GHZ,\n\t.n_channels = 1,\n\t.n_bitrates = ARRAY_SIZE(bitrates_2ghz),\n\t.ht_cap = {\n\t\t.ht_supported = true,\n\t\t.cap = IEEE80211_HT_CAP_SUP_WIDTH_20_40 |\n\t\t       IEEE80211_HT_CAP_GRN_FLD |\n\t\t       IEEE80211_HT_CAP_SGI_20 |\n\t\t       IEEE80211_HT_CAP_SGI_40 |\n\t\t       IEEE80211_HT_CAP_DSSSCCK40,\n\t\t.ampdu_factor = 0x3,\n\t\t.ampdu_density = 0x6,\n\t\t.mcs = {\n\t\t\t.rx_mask = {0xff, 0xff},\n\t\t\t.tx_params = IEEE80211_HT_MCS_TX_DEFINED,\n\t\t},\n\t},\n};\n\nstatic struct ieee80211_channel channel_5ghz = {\n\t.band = NL80211_BAND_5GHZ,\n\t.center_freq = 5240,\n\t.hw_value = 5240,\n\t.max_power = 20,\n};\n\nstatic struct ieee80211_rate bitrates_5ghz[] = {\n\t{ .bitrate = 60 },\n\t{ .bitrate = 120 },\n\t{ .bitrate = 240 },\n};\n\n#define RX_MCS_MAP (IEEE80211_VHT_MCS_SUPPORT_0_9 << 0 | \\\n\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 2 | \\\n\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 4 | \\\n\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 6 | \\\n\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 8 | \\\n\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 10 | \\\n\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 12 | \\\n\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 14)\n\n#define TX_MCS_MAP (IEEE80211_VHT_MCS_SUPPORT_0_9 << 0 | \\\n\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 2 | \\\n\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 4 | \\\n\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 6 | \\\n\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 8 | \\\n\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 10 | \\\n\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 12 | \\\n\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 14)\n\nstatic struct ieee80211_supported_band band_5ghz = {\n\t.channels = &channel_5ghz,\n\t.bitrates = bitrates_5ghz,\n\t.band = NL80211_BAND_5GHZ,\n\t.n_channels = 1,\n\t.n_bitrates = ARRAY_SIZE(bitrates_5ghz),\n\t.ht_cap = {\n\t\t.ht_supported = true,\n\t\t.cap = IEEE80211_HT_CAP_SUP_WIDTH_20_40 |\n\t\t       IEEE80211_HT_CAP_GRN_FLD |\n\t\t       IEEE80211_HT_CAP_SGI_20 |\n\t\t       IEEE80211_HT_CAP_SGI_40 |\n\t\t       IEEE80211_HT_CAP_DSSSCCK40,\n\t\t.ampdu_factor = 0x3,\n\t\t.ampdu_density = 0x6,\n\t\t.mcs = {\n\t\t\t.rx_mask = {0xff, 0xff},\n\t\t\t.tx_params = IEEE80211_HT_MCS_TX_DEFINED,\n\t\t},\n\t},\n\t.vht_cap = {\n\t\t.vht_supported = true,\n\t\t.cap = IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454 |\n\t\t       IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ |\n\t\t       IEEE80211_VHT_CAP_RXLDPC |\n\t\t       IEEE80211_VHT_CAP_SHORT_GI_80 |\n\t\t       IEEE80211_VHT_CAP_SHORT_GI_160 |\n\t\t       IEEE80211_VHT_CAP_TXSTBC |\n\t\t       IEEE80211_VHT_CAP_RXSTBC_1 |\n\t\t       IEEE80211_VHT_CAP_RXSTBC_2 |\n\t\t       IEEE80211_VHT_CAP_RXSTBC_3 |\n\t\t       IEEE80211_VHT_CAP_RXSTBC_4 |\n\t\t       IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK,\n\t\t.vht_mcs = {\n\t\t\t.rx_mcs_map = cpu_to_le16(RX_MCS_MAP),\n\t\t\t.tx_mcs_map = cpu_to_le16(TX_MCS_MAP),\n\t\t}\n\t},\n};\n\n \nstatic u8 fake_router_bssid[ETH_ALEN] __ro_after_init = {};\n\nstatic void virt_wifi_inform_bss(struct wiphy *wiphy)\n{\n\tu64 tsf = div_u64(ktime_get_boottime_ns(), 1000);\n\tstruct cfg80211_bss *informed_bss;\n\tstatic const struct {\n\t\tu8 tag;\n\t\tu8 len;\n\t\tu8 ssid[8];\n\t} __packed ssid = {\n\t\t.tag = WLAN_EID_SSID,\n\t\t.len = 8,\n\t\t.ssid = \"VirtWifi\",\n\t};\n\n\tinformed_bss = cfg80211_inform_bss(wiphy, &channel_5ghz,\n\t\t\t\t\t   CFG80211_BSS_FTYPE_PRESP,\n\t\t\t\t\t   fake_router_bssid, tsf,\n\t\t\t\t\t   WLAN_CAPABILITY_ESS, 0,\n\t\t\t\t\t   (void *)&ssid, sizeof(ssid),\n\t\t\t\t\t   DBM_TO_MBM(-50), GFP_KERNEL);\n\tcfg80211_put_bss(wiphy, informed_bss);\n}\n\n \nstatic int virt_wifi_scan(struct wiphy *wiphy,\n\t\t\t  struct cfg80211_scan_request *request)\n{\n\tstruct virt_wifi_wiphy_priv *priv = wiphy_priv(wiphy);\n\n\twiphy_debug(wiphy, \"scan\\n\");\n\n\tif (priv->scan_request || priv->being_deleted)\n\t\treturn -EBUSY;\n\n\tpriv->scan_request = request;\n\tschedule_delayed_work(&priv->scan_result, HZ * 2);\n\n\treturn 0;\n}\n\n \nstatic void virt_wifi_scan_result(struct work_struct *work)\n{\n\tstruct virt_wifi_wiphy_priv *priv =\n\t\tcontainer_of(work, struct virt_wifi_wiphy_priv,\n\t\t\t     scan_result.work);\n\tstruct wiphy *wiphy = priv_to_wiphy(priv);\n\tstruct cfg80211_scan_info scan_info = { .aborted = false };\n\n\tvirt_wifi_inform_bss(wiphy);\n\n\t \n\tcfg80211_scan_done(priv->scan_request, &scan_info);\n\tpriv->scan_request = NULL;\n}\n\n \nstatic void virt_wifi_cancel_scan(struct wiphy *wiphy)\n{\n\tstruct virt_wifi_wiphy_priv *priv = wiphy_priv(wiphy);\n\n\tcancel_delayed_work_sync(&priv->scan_result);\n\t \n\tif (priv->scan_request) {\n\t\tstruct cfg80211_scan_info scan_info = { .aborted = true };\n\t\t \n\t\tcfg80211_scan_done(priv->scan_request, &scan_info);\n\t\tpriv->scan_request = NULL;\n\t}\n}\n\nstruct virt_wifi_netdev_priv {\n\tstruct delayed_work connect;\n\tstruct net_device *lowerdev;\n\tstruct net_device *upperdev;\n\tu32 tx_packets;\n\tu32 tx_failed;\n\tu8 connect_requested_bss[ETH_ALEN];\n\tbool is_up;\n\tbool is_connected;\n\tbool being_deleted;\n};\n\n \nstatic int virt_wifi_connect(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t     struct cfg80211_connect_params *sme)\n{\n\tstruct virt_wifi_netdev_priv *priv = netdev_priv(netdev);\n\tbool could_schedule;\n\n\tif (priv->being_deleted || !priv->is_up)\n\t\treturn -EBUSY;\n\n\tcould_schedule = schedule_delayed_work(&priv->connect, HZ * 2);\n\tif (!could_schedule)\n\t\treturn -EBUSY;\n\n\tif (sme->bssid) {\n\t\tether_addr_copy(priv->connect_requested_bss, sme->bssid);\n\t} else {\n\t\tvirt_wifi_inform_bss(wiphy);\n\t\teth_zero_addr(priv->connect_requested_bss);\n\t}\n\n\twiphy_debug(wiphy, \"connect\\n\");\n\n\treturn 0;\n}\n\n \nstatic void virt_wifi_connect_complete(struct work_struct *work)\n{\n\tstruct virt_wifi_netdev_priv *priv =\n\t\tcontainer_of(work, struct virt_wifi_netdev_priv, connect.work);\n\tu8 *requested_bss = priv->connect_requested_bss;\n\tbool right_addr = ether_addr_equal(requested_bss, fake_router_bssid);\n\tu16 status = WLAN_STATUS_SUCCESS;\n\n\tif (is_zero_ether_addr(requested_bss))\n\t\trequested_bss = NULL;\n\n\tif (!priv->is_up || (requested_bss && !right_addr))\n\t\tstatus = WLAN_STATUS_UNSPECIFIED_FAILURE;\n\telse\n\t\tpriv->is_connected = true;\n\n\t \n\tcfg80211_connect_result(priv->upperdev, requested_bss, NULL, 0, NULL, 0,\n\t\t\t\tstatus, GFP_KERNEL);\n\tnetif_carrier_on(priv->upperdev);\n}\n\n \nstatic void virt_wifi_cancel_connect(struct net_device *netdev)\n{\n\tstruct virt_wifi_netdev_priv *priv = netdev_priv(netdev);\n\n\t \n\tif (cancel_delayed_work_sync(&priv->connect)) {\n\t\t \n\t\tcfg80211_connect_result(priv->upperdev,\n\t\t\t\t\tpriv->connect_requested_bss, NULL, 0,\n\t\t\t\t\tNULL, 0,\n\t\t\t\t\tWLAN_STATUS_UNSPECIFIED_FAILURE,\n\t\t\t\t\tGFP_KERNEL);\n\t}\n}\n\n \nstatic int virt_wifi_disconnect(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t\tu16 reason_code)\n{\n\tstruct virt_wifi_netdev_priv *priv = netdev_priv(netdev);\n\n\tif (priv->being_deleted)\n\t\treturn -EBUSY;\n\n\twiphy_debug(wiphy, \"disconnect\\n\");\n\tvirt_wifi_cancel_connect(netdev);\n\n\tcfg80211_disconnected(netdev, reason_code, NULL, 0, true, GFP_KERNEL);\n\tpriv->is_connected = false;\n\tnetif_carrier_off(netdev);\n\n\treturn 0;\n}\n\n \nstatic int virt_wifi_get_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t const u8 *mac, struct station_info *sinfo)\n{\n\tstruct virt_wifi_netdev_priv *priv = netdev_priv(dev);\n\n\twiphy_debug(wiphy, \"get_station\\n\");\n\n\tif (!priv->is_connected || !ether_addr_equal(mac, fake_router_bssid))\n\t\treturn -ENOENT;\n\n\tsinfo->filled = BIT_ULL(NL80211_STA_INFO_TX_PACKETS) |\n\t\tBIT_ULL(NL80211_STA_INFO_TX_FAILED) |\n\t\tBIT_ULL(NL80211_STA_INFO_SIGNAL) |\n\t\tBIT_ULL(NL80211_STA_INFO_TX_BITRATE);\n\tsinfo->tx_packets = priv->tx_packets;\n\tsinfo->tx_failed = priv->tx_failed;\n\t \n\tsinfo->signal = -50;\n\tsinfo->txrate = (struct rate_info) {\n\t\t.legacy = 10,  \n\t};\n\treturn 0;\n}\n\n \nstatic int virt_wifi_dump_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  int idx, u8 *mac, struct station_info *sinfo)\n{\n\tstruct virt_wifi_netdev_priv *priv = netdev_priv(dev);\n\n\twiphy_debug(wiphy, \"dump_station\\n\");\n\n\tif (idx != 0 || !priv->is_connected)\n\t\treturn -ENOENT;\n\n\tether_addr_copy(mac, fake_router_bssid);\n\treturn virt_wifi_get_station(wiphy, dev, fake_router_bssid, sinfo);\n}\n\nstatic const struct cfg80211_ops virt_wifi_cfg80211_ops = {\n\t.scan = virt_wifi_scan,\n\n\t.connect = virt_wifi_connect,\n\t.disconnect = virt_wifi_disconnect,\n\n\t.get_station = virt_wifi_get_station,\n\t.dump_station = virt_wifi_dump_station,\n};\n\n \nstatic struct wiphy *virt_wifi_make_wiphy(void)\n{\n\tstruct wiphy *wiphy;\n\tstruct virt_wifi_wiphy_priv *priv;\n\tint err;\n\n\twiphy = wiphy_new(&virt_wifi_cfg80211_ops, sizeof(*priv));\n\n\tif (!wiphy)\n\t\treturn NULL;\n\n\twiphy->max_scan_ssids = 4;\n\twiphy->max_scan_ie_len = 1000;\n\twiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;\n\n\twiphy->bands[NL80211_BAND_2GHZ] = &band_2ghz;\n\twiphy->bands[NL80211_BAND_5GHZ] = &band_5ghz;\n\twiphy->bands[NL80211_BAND_60GHZ] = NULL;\n\n\twiphy->interface_modes = BIT(NL80211_IFTYPE_STATION);\n\n\tpriv = wiphy_priv(wiphy);\n\tpriv->being_deleted = false;\n\tpriv->scan_request = NULL;\n\tINIT_DELAYED_WORK(&priv->scan_result, virt_wifi_scan_result);\n\n\terr = wiphy_register(wiphy);\n\tif (err < 0) {\n\t\twiphy_free(wiphy);\n\t\treturn NULL;\n\t}\n\n\treturn wiphy;\n}\n\n \nstatic void virt_wifi_destroy_wiphy(struct wiphy *wiphy)\n{\n\tstruct virt_wifi_wiphy_priv *priv;\n\n\tWARN(!wiphy, \"%s called with null wiphy\", __func__);\n\tif (!wiphy)\n\t\treturn;\n\n\tpriv = wiphy_priv(wiphy);\n\tpriv->being_deleted = true;\n\tvirt_wifi_cancel_scan(wiphy);\n\n\tif (wiphy->registered)\n\t\twiphy_unregister(wiphy);\n\twiphy_free(wiphy);\n}\n\n \nstatic netdev_tx_t virt_wifi_start_xmit(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev)\n{\n\tstruct virt_wifi_netdev_priv *priv = netdev_priv(dev);\n\n\tpriv->tx_packets++;\n\tif (!priv->is_connected) {\n\t\tpriv->tx_failed++;\n\t\treturn NET_XMIT_DROP;\n\t}\n\n\tskb->dev = priv->lowerdev;\n\treturn dev_queue_xmit(skb);\n}\n\n \nstatic int virt_wifi_net_device_open(struct net_device *dev)\n{\n\tstruct virt_wifi_netdev_priv *priv = netdev_priv(dev);\n\n\tpriv->is_up = true;\n\treturn 0;\n}\n\n \nstatic int virt_wifi_net_device_stop(struct net_device *dev)\n{\n\tstruct virt_wifi_netdev_priv *n_priv = netdev_priv(dev);\n\n\tn_priv->is_up = false;\n\n\tif (!dev->ieee80211_ptr)\n\t\treturn 0;\n\n\tvirt_wifi_cancel_scan(dev->ieee80211_ptr->wiphy);\n\tvirt_wifi_cancel_connect(dev);\n\tnetif_carrier_off(dev);\n\n\treturn 0;\n}\n\nstatic int virt_wifi_net_device_get_iflink(const struct net_device *dev)\n{\n\tstruct virt_wifi_netdev_priv *priv = netdev_priv(dev);\n\n\treturn priv->lowerdev->ifindex;\n}\n\nstatic const struct net_device_ops virt_wifi_ops = {\n\t.ndo_start_xmit = virt_wifi_start_xmit,\n\t.ndo_open\t= virt_wifi_net_device_open,\n\t.ndo_stop\t= virt_wifi_net_device_stop,\n\t.ndo_get_iflink = virt_wifi_net_device_get_iflink,\n};\n\n \nstatic void virt_wifi_net_device_destructor(struct net_device *dev)\n{\n\t \n\tkfree(dev->ieee80211_ptr);\n\tdev->ieee80211_ptr = NULL;\n}\n\n \nstatic void virt_wifi_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->netdev_ops = &virt_wifi_ops;\n\tdev->needs_free_netdev  = true;\n}\n\n \nstatic rx_handler_result_t virt_wifi_rx_handler(struct sk_buff **pskb)\n{\n\tstruct sk_buff *skb = *pskb;\n\tstruct virt_wifi_netdev_priv *priv =\n\t\trcu_dereference(skb->dev->rx_handler_data);\n\n\tif (!priv->is_connected)\n\t\treturn RX_HANDLER_PASS;\n\n\t \n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(&priv->upperdev->dev, \"can't skb_share_check\\n\");\n\t\treturn RX_HANDLER_CONSUMED;\n\t}\n\n\t*pskb = skb;\n\tskb->dev = priv->upperdev;\n\tskb->pkt_type = PACKET_HOST;\n\treturn RX_HANDLER_ANOTHER;\n}\n\n \nstatic int virt_wifi_newlink(struct net *src_net, struct net_device *dev,\n\t\t\t     struct nlattr *tb[], struct nlattr *data[],\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct virt_wifi_netdev_priv *priv = netdev_priv(dev);\n\tint err;\n\n\tif (!tb[IFLA_LINK])\n\t\treturn -EINVAL;\n\n\tnetif_carrier_off(dev);\n\n\tpriv->upperdev = dev;\n\tpriv->lowerdev = __dev_get_by_index(src_net,\n\t\t\t\t\t    nla_get_u32(tb[IFLA_LINK]));\n\n\tif (!priv->lowerdev)\n\t\treturn -ENODEV;\n\tif (!tb[IFLA_MTU])\n\t\tdev->mtu = priv->lowerdev->mtu;\n\telse if (dev->mtu > priv->lowerdev->mtu)\n\t\treturn -EINVAL;\n\n\terr = netdev_rx_handler_register(priv->lowerdev, virt_wifi_rx_handler,\n\t\t\t\t\t priv);\n\tif (err) {\n\t\tdev_err(&priv->lowerdev->dev,\n\t\t\t\"can't netdev_rx_handler_register: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\teth_hw_addr_inherit(dev, priv->lowerdev);\n\tnetif_stacked_transfer_operstate(priv->lowerdev, dev);\n\n\tSET_NETDEV_DEV(dev, &priv->lowerdev->dev);\n\tdev->ieee80211_ptr = kzalloc(sizeof(*dev->ieee80211_ptr), GFP_KERNEL);\n\n\tif (!dev->ieee80211_ptr) {\n\t\terr = -ENOMEM;\n\t\tgoto remove_handler;\n\t}\n\n\tdev->ieee80211_ptr->iftype = NL80211_IFTYPE_STATION;\n\tdev->ieee80211_ptr->wiphy = common_wiphy;\n\n\terr = register_netdevice(dev);\n\tif (err) {\n\t\tdev_err(&priv->lowerdev->dev, \"can't register_netdevice: %d\\n\",\n\t\t\terr);\n\t\tgoto free_wireless_dev;\n\t}\n\n\terr = netdev_upper_dev_link(priv->lowerdev, dev, extack);\n\tif (err) {\n\t\tdev_err(&priv->lowerdev->dev, \"can't netdev_upper_dev_link: %d\\n\",\n\t\t\terr);\n\t\tgoto unregister_netdev;\n\t}\n\n\tdev->priv_destructor = virt_wifi_net_device_destructor;\n\tpriv->being_deleted = false;\n\tpriv->is_connected = false;\n\tpriv->is_up = false;\n\tINIT_DELAYED_WORK(&priv->connect, virt_wifi_connect_complete);\n\t__module_get(THIS_MODULE);\n\n\treturn 0;\nunregister_netdev:\n\tunregister_netdevice(dev);\nfree_wireless_dev:\n\tkfree(dev->ieee80211_ptr);\n\tdev->ieee80211_ptr = NULL;\nremove_handler:\n\tnetdev_rx_handler_unregister(priv->lowerdev);\n\n\treturn err;\n}\n\n \nstatic void virt_wifi_dellink(struct net_device *dev,\n\t\t\t      struct list_head *head)\n{\n\tstruct virt_wifi_netdev_priv *priv = netdev_priv(dev);\n\n\tif (dev->ieee80211_ptr)\n\t\tvirt_wifi_cancel_scan(dev->ieee80211_ptr->wiphy);\n\n\tpriv->being_deleted = true;\n\tvirt_wifi_cancel_connect(dev);\n\tnetif_carrier_off(dev);\n\n\tnetdev_rx_handler_unregister(priv->lowerdev);\n\tnetdev_upper_dev_unlink(priv->lowerdev, dev);\n\n\tunregister_netdevice_queue(dev, head);\n\tmodule_put(THIS_MODULE);\n\n\t \n}\n\nstatic struct rtnl_link_ops virt_wifi_link_ops = {\n\t.kind\t\t= \"virt_wifi\",\n\t.setup\t\t= virt_wifi_setup,\n\t.newlink\t= virt_wifi_newlink,\n\t.dellink\t= virt_wifi_dellink,\n\t.priv_size\t= sizeof(struct virt_wifi_netdev_priv),\n};\n\nstatic bool netif_is_virt_wifi_dev(const struct net_device *dev)\n{\n\treturn rcu_access_pointer(dev->rx_handler) == virt_wifi_rx_handler;\n}\n\nstatic int virt_wifi_event(struct notifier_block *this, unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstruct net_device *lower_dev = netdev_notifier_info_to_dev(ptr);\n\tstruct virt_wifi_netdev_priv *priv;\n\tstruct net_device *upper_dev;\n\tLIST_HEAD(list_kill);\n\n\tif (!netif_is_virt_wifi_dev(lower_dev))\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_UNREGISTER:\n\t\tpriv = rtnl_dereference(lower_dev->rx_handler_data);\n\t\tif (!priv)\n\t\t\treturn NOTIFY_DONE;\n\n\t\tupper_dev = priv->upperdev;\n\n\t\tupper_dev->rtnl_link_ops->dellink(upper_dev, &list_kill);\n\t\tunregister_netdevice_many(&list_kill);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block virt_wifi_notifier = {\n\t.notifier_call = virt_wifi_event,\n};\n\n \nstatic int __init virt_wifi_init_module(void)\n{\n\tint err;\n\n\t \n\teth_random_addr(fake_router_bssid);\n\n\terr = register_netdevice_notifier(&virt_wifi_notifier);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOMEM;\n\tcommon_wiphy = virt_wifi_make_wiphy();\n\tif (!common_wiphy)\n\t\tgoto notifier;\n\n\terr = rtnl_link_register(&virt_wifi_link_ops);\n\tif (err)\n\t\tgoto destroy_wiphy;\n\n\treturn 0;\n\ndestroy_wiphy:\n\tvirt_wifi_destroy_wiphy(common_wiphy);\nnotifier:\n\tunregister_netdevice_notifier(&virt_wifi_notifier);\n\treturn err;\n}\n\n \nstatic void __exit virt_wifi_cleanup_module(void)\n{\n\t \n\trtnl_link_unregister(&virt_wifi_link_ops);\n\tvirt_wifi_destroy_wiphy(common_wiphy);\n\tunregister_netdevice_notifier(&virt_wifi_notifier);\n}\n\nmodule_init(virt_wifi_init_module);\nmodule_exit(virt_wifi_cleanup_module);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Cody Schuffelen <schuffelen@google.com>\");\nMODULE_DESCRIPTION(\"Driver for a wireless wrapper of ethernet devices\");\nMODULE_ALIAS_RTNL_LINK(\"virt_wifi\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}