{
  "module_name": "mac80211_hwsim.c",
  "hash_id": "b2e92db165b12ebd5b0b0009e2e9167d96c73807bf8cc723baba18f0bccfdeb4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/virtual/mac80211_hwsim.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <net/dst.h>\n#include <net/xfrm.h>\n#include <net/mac80211.h>\n#include <net/ieee80211_radiotap.h>\n#include <linux/if_arp.h>\n#include <linux/rtnetlink.h>\n#include <linux/etherdevice.h>\n#include <linux/platform_device.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/ktime.h>\n#include <net/genetlink.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <linux/rhashtable.h>\n#include <linux/nospec.h>\n#include <linux/virtio.h>\n#include <linux/virtio_ids.h>\n#include <linux/virtio_config.h>\n#include \"mac80211_hwsim.h\"\n\n#define WARN_QUEUE 100\n#define MAX_QUEUE 200\n\nMODULE_AUTHOR(\"Jouni Malinen\");\nMODULE_DESCRIPTION(\"Software simulator of 802.11 radio(s) for mac80211\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int radios = 2;\nmodule_param(radios, int, 0444);\nMODULE_PARM_DESC(radios, \"Number of simulated radios\");\n\nstatic int channels = 1;\nmodule_param(channels, int, 0444);\nMODULE_PARM_DESC(channels, \"Number of concurrent channels\");\n\nstatic bool paged_rx = false;\nmodule_param(paged_rx, bool, 0644);\nMODULE_PARM_DESC(paged_rx, \"Use paged SKBs for RX instead of linear ones\");\n\nstatic bool rctbl = false;\nmodule_param(rctbl, bool, 0444);\nMODULE_PARM_DESC(rctbl, \"Handle rate control table\");\n\nstatic bool support_p2p_device = true;\nmodule_param(support_p2p_device, bool, 0444);\nMODULE_PARM_DESC(support_p2p_device, \"Support P2P-Device interface type\");\n\nstatic bool mlo;\nmodule_param(mlo, bool, 0444);\nMODULE_PARM_DESC(mlo, \"Support MLO\");\n\n \nenum hwsim_regtest {\n\tHWSIM_REGTEST_DISABLED = 0,\n\tHWSIM_REGTEST_DRIVER_REG_FOLLOW = 1,\n\tHWSIM_REGTEST_DRIVER_REG_ALL = 2,\n\tHWSIM_REGTEST_DIFF_COUNTRY = 3,\n\tHWSIM_REGTEST_WORLD_ROAM = 4,\n\tHWSIM_REGTEST_CUSTOM_WORLD = 5,\n\tHWSIM_REGTEST_CUSTOM_WORLD_2 = 6,\n\tHWSIM_REGTEST_STRICT_FOLLOW = 7,\n\tHWSIM_REGTEST_STRICT_ALL = 8,\n\tHWSIM_REGTEST_STRICT_AND_DRIVER_REG = 9,\n\tHWSIM_REGTEST_ALL = 10,\n};\n\n \nstatic int regtest = HWSIM_REGTEST_DISABLED;\nmodule_param(regtest, int, 0444);\nMODULE_PARM_DESC(regtest, \"The type of regulatory test we want to run\");\n\nstatic const char *hwsim_alpha2s[] = {\n\t\"FI\",\n\t\"AL\",\n\t\"US\",\n\t\"DE\",\n\t\"JP\",\n\t\"AL\",\n};\n\nstatic const struct ieee80211_regdomain hwsim_world_regdom_custom_01 = {\n\t.n_reg_rules = 5,\n\t.alpha2 =  \"99\",\n\t.reg_rules = {\n\t\tREG_RULE(2412-10, 2462+10, 40, 0, 20, 0),\n\t\tREG_RULE(2484-10, 2484+10, 40, 0, 20, 0),\n\t\tREG_RULE(5150-10, 5240+10, 40, 0, 30, 0),\n\t\tREG_RULE(5745-10, 5825+10, 40, 0, 30, 0),\n\t\tREG_RULE(5855-10, 5925+10, 40, 0, 33, 0),\n\t}\n};\n\nstatic const struct ieee80211_regdomain hwsim_world_regdom_custom_02 = {\n\t.n_reg_rules = 3,\n\t.alpha2 =  \"99\",\n\t.reg_rules = {\n\t\tREG_RULE(2412-10, 2462+10, 40, 0, 20, 0),\n\t\tREG_RULE(5725-10, 5850+10, 40, 0, 30,\n\t\t\t NL80211_RRF_NO_IR),\n\t\tREG_RULE(5855-10, 5925+10, 40, 0, 33, 0),\n\t}\n};\n\nstatic const struct ieee80211_regdomain hwsim_world_regdom_custom_03 = {\n\t.n_reg_rules = 6,\n\t.alpha2 =  \"99\",\n\t.reg_rules = {\n\t\tREG_RULE(2412 - 10, 2462 + 10, 40, 0, 20, 0),\n\t\tREG_RULE(2484 - 10, 2484 + 10, 40, 0, 20, 0),\n\t\tREG_RULE(5150 - 10, 5240 + 10, 40, 0, 30, 0),\n\t\tREG_RULE(5745 - 10, 5825 + 10, 40, 0, 30, 0),\n\t\tREG_RULE(5855 - 10, 5925 + 10, 40, 0, 33, 0),\n\t\tREG_RULE(5955 - 10, 7125 + 10, 320, 0, 33, 0),\n\t}\n};\n\nstatic const struct ieee80211_regdomain *hwsim_world_regdom_custom[] = {\n\t&hwsim_world_regdom_custom_01,\n\t&hwsim_world_regdom_custom_02,\n\t&hwsim_world_regdom_custom_03,\n};\n\nstruct hwsim_vif_priv {\n\tu32 magic;\n\tu8 bssid[ETH_ALEN];\n\tbool assoc;\n\tbool bcn_en;\n\tu16 aid;\n};\n\n#define HWSIM_VIF_MAGIC\t0x69537748\n\nstatic inline void hwsim_check_magic(struct ieee80211_vif *vif)\n{\n\tstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\n\tWARN(vp->magic != HWSIM_VIF_MAGIC,\n\t     \"Invalid VIF (%p) magic %#x, %pM, %d/%d\\n\",\n\t     vif, vp->magic, vif->addr, vif->type, vif->p2p);\n}\n\nstatic inline void hwsim_set_magic(struct ieee80211_vif *vif)\n{\n\tstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\n\tvp->magic = HWSIM_VIF_MAGIC;\n}\n\nstatic inline void hwsim_clear_magic(struct ieee80211_vif *vif)\n{\n\tstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\n\tvp->magic = 0;\n}\n\nstruct hwsim_sta_priv {\n\tu32 magic;\n\tunsigned int last_link;\n\tu16 active_links_rx;\n};\n\n#define HWSIM_STA_MAGIC\t0x6d537749\n\nstatic inline void hwsim_check_sta_magic(struct ieee80211_sta *sta)\n{\n\tstruct hwsim_sta_priv *sp = (void *)sta->drv_priv;\n\tWARN_ON(sp->magic != HWSIM_STA_MAGIC);\n}\n\nstatic inline void hwsim_set_sta_magic(struct ieee80211_sta *sta)\n{\n\tstruct hwsim_sta_priv *sp = (void *)sta->drv_priv;\n\tsp->magic = HWSIM_STA_MAGIC;\n}\n\nstatic inline void hwsim_clear_sta_magic(struct ieee80211_sta *sta)\n{\n\tstruct hwsim_sta_priv *sp = (void *)sta->drv_priv;\n\tsp->magic = 0;\n}\n\nstruct hwsim_chanctx_priv {\n\tu32 magic;\n};\n\n#define HWSIM_CHANCTX_MAGIC 0x6d53774a\n\nstatic inline void hwsim_check_chanctx_magic(struct ieee80211_chanctx_conf *c)\n{\n\tstruct hwsim_chanctx_priv *cp = (void *)c->drv_priv;\n\tWARN_ON(cp->magic != HWSIM_CHANCTX_MAGIC);\n}\n\nstatic inline void hwsim_set_chanctx_magic(struct ieee80211_chanctx_conf *c)\n{\n\tstruct hwsim_chanctx_priv *cp = (void *)c->drv_priv;\n\tcp->magic = HWSIM_CHANCTX_MAGIC;\n}\n\nstatic inline void hwsim_clear_chanctx_magic(struct ieee80211_chanctx_conf *c)\n{\n\tstruct hwsim_chanctx_priv *cp = (void *)c->drv_priv;\n\tcp->magic = 0;\n}\n\nstatic unsigned int hwsim_net_id;\n\nstatic DEFINE_IDA(hwsim_netgroup_ida);\n\nstruct hwsim_net {\n\tint netgroup;\n\tu32 wmediumd;\n};\n\nstatic inline int hwsim_net_get_netgroup(struct net *net)\n{\n\tstruct hwsim_net *hwsim_net = net_generic(net, hwsim_net_id);\n\n\treturn hwsim_net->netgroup;\n}\n\nstatic inline int hwsim_net_set_netgroup(struct net *net)\n{\n\tstruct hwsim_net *hwsim_net = net_generic(net, hwsim_net_id);\n\n\thwsim_net->netgroup = ida_alloc(&hwsim_netgroup_ida, GFP_KERNEL);\n\treturn hwsim_net->netgroup >= 0 ? 0 : -ENOMEM;\n}\n\nstatic inline u32 hwsim_net_get_wmediumd(struct net *net)\n{\n\tstruct hwsim_net *hwsim_net = net_generic(net, hwsim_net_id);\n\n\treturn hwsim_net->wmediumd;\n}\n\nstatic inline void hwsim_net_set_wmediumd(struct net *net, u32 portid)\n{\n\tstruct hwsim_net *hwsim_net = net_generic(net, hwsim_net_id);\n\n\thwsim_net->wmediumd = portid;\n}\n\nstatic struct class *hwsim_class;\n\nstatic struct net_device *hwsim_mon;  \n\n#define CHAN2G(_freq)  { \\\n\t.band = NL80211_BAND_2GHZ, \\\n\t.center_freq = (_freq), \\\n\t.hw_value = (_freq), \\\n}\n\n#define CHAN5G(_freq) { \\\n\t.band = NL80211_BAND_5GHZ, \\\n\t.center_freq = (_freq), \\\n\t.hw_value = (_freq), \\\n}\n\n#define CHAN6G(_freq) { \\\n\t.band = NL80211_BAND_6GHZ, \\\n\t.center_freq = (_freq), \\\n\t.hw_value = (_freq), \\\n}\n\nstatic const struct ieee80211_channel hwsim_channels_2ghz[] = {\n\tCHAN2G(2412),  \n\tCHAN2G(2417),  \n\tCHAN2G(2422),  \n\tCHAN2G(2427),  \n\tCHAN2G(2432),  \n\tCHAN2G(2437),  \n\tCHAN2G(2442),  \n\tCHAN2G(2447),  \n\tCHAN2G(2452),  \n\tCHAN2G(2457),  \n\tCHAN2G(2462),  \n\tCHAN2G(2467),  \n\tCHAN2G(2472),  \n\tCHAN2G(2484),  \n};\n\nstatic const struct ieee80211_channel hwsim_channels_5ghz[] = {\n\tCHAN5G(5180),  \n\tCHAN5G(5200),  \n\tCHAN5G(5220),  \n\tCHAN5G(5240),  \n\n\tCHAN5G(5260),  \n\tCHAN5G(5280),  \n\tCHAN5G(5300),  \n\tCHAN5G(5320),  \n\n\tCHAN5G(5500),  \n\tCHAN5G(5520),  \n\tCHAN5G(5540),  \n\tCHAN5G(5560),  \n\tCHAN5G(5580),  \n\tCHAN5G(5600),  \n\tCHAN5G(5620),  \n\tCHAN5G(5640),  \n\tCHAN5G(5660),  \n\tCHAN5G(5680),  \n\tCHAN5G(5700),  \n\n\tCHAN5G(5745),  \n\tCHAN5G(5765),  \n\tCHAN5G(5785),  \n\tCHAN5G(5805),  \n\tCHAN5G(5825),  \n\tCHAN5G(5845),  \n\n\tCHAN5G(5855),  \n\tCHAN5G(5860),  \n\tCHAN5G(5865),  \n\tCHAN5G(5870),  \n\n\tCHAN5G(5875),  \n\tCHAN5G(5880),  \n\tCHAN5G(5885),  \n\tCHAN5G(5890),  \n\tCHAN5G(5895),  \n\tCHAN5G(5900),  \n\tCHAN5G(5905),  \n\n\tCHAN5G(5910),  \n\tCHAN5G(5915),  \n\tCHAN5G(5920),  \n\tCHAN5G(5925),  \n};\n\nstatic const struct ieee80211_channel hwsim_channels_6ghz[] = {\n\tCHAN6G(5955),  \n\tCHAN6G(5975),  \n\tCHAN6G(5995),  \n\tCHAN6G(6015),  \n\tCHAN6G(6035),  \n\tCHAN6G(6055),  \n\tCHAN6G(6075),  \n\tCHAN6G(6095),  \n\tCHAN6G(6115),  \n\tCHAN6G(6135),  \n\tCHAN6G(6155),  \n\tCHAN6G(6175),  \n\tCHAN6G(6195),  \n\tCHAN6G(6215),  \n\tCHAN6G(6235),  \n\tCHAN6G(6255),  \n\tCHAN6G(6275),  \n\tCHAN6G(6295),  \n\tCHAN6G(6315),  \n\tCHAN6G(6335),  \n\tCHAN6G(6355),  \n\tCHAN6G(6375),  \n\tCHAN6G(6395),  \n\tCHAN6G(6415),  \n\tCHAN6G(6435),  \n\tCHAN6G(6455),  \n\tCHAN6G(6475),  \n\tCHAN6G(6495),  \n\tCHAN6G(6515),  \n\tCHAN6G(6535),  \n\tCHAN6G(6555),  \n\tCHAN6G(6575),  \n\tCHAN6G(6595),  \n\tCHAN6G(6615),  \n\tCHAN6G(6635),  \n\tCHAN6G(6655),  \n\tCHAN6G(6675),  \n\tCHAN6G(6695),  \n\tCHAN6G(6715),  \n\tCHAN6G(6735),  \n\tCHAN6G(6755),  \n\tCHAN6G(6775),  \n\tCHAN6G(6795),  \n\tCHAN6G(6815),  \n\tCHAN6G(6835),  \n\tCHAN6G(6855),  \n\tCHAN6G(6875),  \n\tCHAN6G(6895),  \n\tCHAN6G(6915),  \n\tCHAN6G(6935),  \n\tCHAN6G(6955),  \n\tCHAN6G(6975),  \n\tCHAN6G(6995),  \n\tCHAN6G(7015),  \n\tCHAN6G(7035),  \n\tCHAN6G(7055),  \n\tCHAN6G(7075),  \n\tCHAN6G(7095),  \n\tCHAN6G(7115),  \n};\n\n#define NUM_S1G_CHANS_US 51\nstatic struct ieee80211_channel hwsim_channels_s1g[NUM_S1G_CHANS_US];\n\nstatic const struct ieee80211_sta_s1g_cap hwsim_s1g_cap = {\n\t.s1g = true,\n\t.cap = { S1G_CAP0_SGI_1MHZ | S1G_CAP0_SGI_2MHZ,\n\t\t 0,\n\t\t 0,\n\t\t S1G_CAP3_MAX_MPDU_LEN,\n\t\t 0,\n\t\t S1G_CAP5_AMPDU,\n\t\t 0,\n\t\t S1G_CAP7_DUP_1MHZ,\n\t\t S1G_CAP8_TWT_RESPOND | S1G_CAP8_TWT_REQUEST,\n\t\t 0},\n\t.nss_mcs = { 0xfc | 1,  \n\t \n\t\t     0,\n\t \n\t \n\t\t     0xfa,\n\t \n\t \n\t\t     0x80,\n\t \n\t \n\t \n\t\t     0 },\n};\n\nstatic void hwsim_init_s1g_channels(struct ieee80211_channel *chans)\n{\n\tint ch, freq;\n\n\tfor (ch = 0; ch < NUM_S1G_CHANS_US; ch++) {\n\t\tfreq = 902000 + (ch + 1) * 500;\n\t\tchans[ch].band = NL80211_BAND_S1GHZ;\n\t\tchans[ch].center_freq = KHZ_TO_MHZ(freq);\n\t\tchans[ch].freq_offset = freq % 1000;\n\t\tchans[ch].hw_value = ch + 1;\n\t}\n}\n\nstatic const struct ieee80211_rate hwsim_rates[] = {\n\t{ .bitrate = 10 },\n\t{ .bitrate = 20, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 55, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 110, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 60 },\n\t{ .bitrate = 90 },\n\t{ .bitrate = 120 },\n\t{ .bitrate = 180 },\n\t{ .bitrate = 240 },\n\t{ .bitrate = 360 },\n\t{ .bitrate = 480 },\n\t{ .bitrate = 540 }\n};\n\n#define DEFAULT_RX_RSSI -50\n\nstatic const u32 hwsim_ciphers[] = {\n\tWLAN_CIPHER_SUITE_WEP40,\n\tWLAN_CIPHER_SUITE_WEP104,\n\tWLAN_CIPHER_SUITE_TKIP,\n\tWLAN_CIPHER_SUITE_CCMP,\n\tWLAN_CIPHER_SUITE_CCMP_256,\n\tWLAN_CIPHER_SUITE_GCMP,\n\tWLAN_CIPHER_SUITE_GCMP_256,\n\tWLAN_CIPHER_SUITE_AES_CMAC,\n\tWLAN_CIPHER_SUITE_BIP_CMAC_256,\n\tWLAN_CIPHER_SUITE_BIP_GMAC_128,\n\tWLAN_CIPHER_SUITE_BIP_GMAC_256,\n};\n\n#define OUI_QCA 0x001374\n#define QCA_NL80211_SUBCMD_TEST 1\nenum qca_nl80211_vendor_subcmds {\n\tQCA_WLAN_VENDOR_ATTR_TEST = 8,\n\tQCA_WLAN_VENDOR_ATTR_MAX = QCA_WLAN_VENDOR_ATTR_TEST\n};\n\nstatic const struct nla_policy\nhwsim_vendor_test_policy[QCA_WLAN_VENDOR_ATTR_MAX + 1] = {\n\t[QCA_WLAN_VENDOR_ATTR_MAX] = { .type = NLA_U32 },\n};\n\nstatic int mac80211_hwsim_vendor_cmd_test(struct wiphy *wiphy,\n\t\t\t\t\t  struct wireless_dev *wdev,\n\t\t\t\t\t  const void *data, int data_len)\n{\n\tstruct sk_buff *skb;\n\tstruct nlattr *tb[QCA_WLAN_VENDOR_ATTR_MAX + 1];\n\tint err;\n\tu32 val;\n\n\terr = nla_parse_deprecated(tb, QCA_WLAN_VENDOR_ATTR_MAX, data,\n\t\t\t\t   data_len, hwsim_vendor_test_policy, NULL);\n\tif (err)\n\t\treturn err;\n\tif (!tb[QCA_WLAN_VENDOR_ATTR_TEST])\n\t\treturn -EINVAL;\n\tval = nla_get_u32(tb[QCA_WLAN_VENDOR_ATTR_TEST]);\n\twiphy_dbg(wiphy, \"%s: test=%u\\n\", __func__, val);\n\n\t \n\tskb = cfg80211_vendor_event_alloc(wiphy, wdev, 100, 0, GFP_KERNEL);\n\tif (skb) {\n\t\t \n\n\t\t \n\t\tnla_put_u32(skb, QCA_WLAN_VENDOR_ATTR_TEST, val + 1);\n\n\t\t \n\t\tcfg80211_vendor_event(skb, GFP_KERNEL);\n\t}\n\n\t \n\tskb = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, 10);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\t \n\tnla_put_u32(skb, QCA_WLAN_VENDOR_ATTR_TEST, val + 2);\n\n\treturn cfg80211_vendor_cmd_reply(skb);\n}\n\nstatic struct wiphy_vendor_command mac80211_hwsim_vendor_commands[] = {\n\t{\n\t\t.info = { .vendor_id = OUI_QCA,\n\t\t\t  .subcmd = QCA_NL80211_SUBCMD_TEST },\n\t\t.flags = WIPHY_VENDOR_CMD_NEED_NETDEV,\n\t\t.doit = mac80211_hwsim_vendor_cmd_test,\n\t\t.policy = hwsim_vendor_test_policy,\n\t\t.maxattr = QCA_WLAN_VENDOR_ATTR_MAX,\n\t}\n};\n\n \nstatic const struct nl80211_vendor_cmd_info mac80211_hwsim_vendor_events[] = {\n\t{ .vendor_id = OUI_QCA, .subcmd = 1 },\n};\n\nstatic DEFINE_SPINLOCK(hwsim_radio_lock);\nstatic LIST_HEAD(hwsim_radios);\nstatic struct rhashtable hwsim_radios_rht;\nstatic int hwsim_radio_idx;\nstatic int hwsim_radios_generation = 1;\n\nstatic struct platform_driver mac80211_hwsim_driver = {\n\t.driver = {\n\t\t.name = \"mac80211_hwsim\",\n\t},\n};\n\nstruct mac80211_hwsim_link_data {\n\tu32 link_id;\n\tu64 beacon_int\t ;\n\tstruct hrtimer beacon_timer;\n};\n\nstruct mac80211_hwsim_data {\n\tstruct list_head list;\n\tstruct rhash_head rht;\n\tstruct ieee80211_hw *hw;\n\tstruct device *dev;\n\tstruct ieee80211_supported_band bands[NUM_NL80211_BANDS];\n\tstruct ieee80211_channel channels_2ghz[ARRAY_SIZE(hwsim_channels_2ghz)];\n\tstruct ieee80211_channel channels_5ghz[ARRAY_SIZE(hwsim_channels_5ghz)];\n\tstruct ieee80211_channel channels_6ghz[ARRAY_SIZE(hwsim_channels_6ghz)];\n\tstruct ieee80211_channel channels_s1g[ARRAY_SIZE(hwsim_channels_s1g)];\n\tstruct ieee80211_rate rates[ARRAY_SIZE(hwsim_rates)];\n\tstruct ieee80211_iface_combination if_combination;\n\tstruct ieee80211_iface_limit if_limits[3];\n\tint n_if_limits;\n\n\tu32 ciphers[ARRAY_SIZE(hwsim_ciphers)];\n\n\tstruct mac_address addresses[2];\n\tint channels, idx;\n\tbool use_chanctx;\n\tbool destroy_on_close;\n\tu32 portid;\n\tchar alpha2[2];\n\tconst struct ieee80211_regdomain *regd;\n\n\tstruct ieee80211_channel *tmp_chan;\n\tstruct ieee80211_channel *roc_chan;\n\tu32 roc_duration;\n\tstruct delayed_work roc_start;\n\tstruct delayed_work roc_done;\n\tstruct delayed_work hw_scan;\n\tstruct cfg80211_scan_request *hw_scan_request;\n\tstruct ieee80211_vif *hw_scan_vif;\n\tint scan_chan_idx;\n\tu8 scan_addr[ETH_ALEN];\n\tstruct {\n\t\tstruct ieee80211_channel *channel;\n\t\tunsigned long next_start, start, end;\n\t} survey_data[ARRAY_SIZE(hwsim_channels_2ghz) +\n\t\t      ARRAY_SIZE(hwsim_channels_5ghz) +\n\t\t      ARRAY_SIZE(hwsim_channels_6ghz)];\n\n\tstruct ieee80211_channel *channel;\n\tenum nl80211_chan_width bw;\n\tunsigned int rx_filter;\n\tbool started, idle, scanning;\n\tstruct mutex mutex;\n\tenum ps_mode {\n\t\tPS_DISABLED, PS_ENABLED, PS_AUTO_POLL, PS_MANUAL_POLL\n\t} ps;\n\tbool ps_poll_pending;\n\tstruct dentry *debugfs;\n\n\tatomic_t pending_cookie;\n\tstruct sk_buff_head pending;\t \n\t \n\tu64 group;\n\n\t \n\tint netgroup;\n\t \n\tu32 wmediumd;\n\n\t \n\ts64 tsf_offset;\n\ts64 bcn_delta;\n\t \n\tu64 abs_bcn_ts;\n\n\t \n\tu64 tx_pkts;\n\tu64 rx_pkts;\n\tu64 tx_bytes;\n\tu64 rx_bytes;\n\tu64 tx_dropped;\n\tu64 tx_failed;\n\n\t \n\tint rx_rssi;\n\n\t \n\tstruct cfg80211_pmsr_capabilities pmsr_capa;\n\tstruct cfg80211_pmsr_request *pmsr_request;\n\tstruct wireless_dev *pmsr_request_wdev;\n\n\tstruct mac80211_hwsim_link_data link_data[IEEE80211_MLD_MAX_NUM_LINKS];\n};\n\nstatic const struct rhashtable_params hwsim_rht_params = {\n\t.nelem_hint = 2,\n\t.automatic_shrinking = true,\n\t.key_len = ETH_ALEN,\n\t.key_offset = offsetof(struct mac80211_hwsim_data, addresses[1]),\n\t.head_offset = offsetof(struct mac80211_hwsim_data, rht),\n};\n\nstruct hwsim_radiotap_hdr {\n\tstruct ieee80211_radiotap_header hdr;\n\t__le64 rt_tsft;\n\tu8 rt_flags;\n\tu8 rt_rate;\n\t__le16 rt_channel;\n\t__le16 rt_chbitmask;\n} __packed;\n\nstruct hwsim_radiotap_ack_hdr {\n\tstruct ieee80211_radiotap_header hdr;\n\tu8 rt_flags;\n\tu8 pad;\n\t__le16 rt_channel;\n\t__le16 rt_chbitmask;\n} __packed;\n\nstatic struct mac80211_hwsim_data *get_hwsim_data_ref_from_addr(const u8 *addr)\n{\n\treturn rhashtable_lookup_fast(&hwsim_radios_rht, addr, hwsim_rht_params);\n}\n\n \nstatic struct genl_family hwsim_genl_family;\n\nenum hwsim_multicast_groups {\n\tHWSIM_MCGRP_CONFIG,\n};\n\nstatic const struct genl_multicast_group hwsim_mcgrps[] = {\n\t[HWSIM_MCGRP_CONFIG] = { .name = \"config\", },\n};\n\n \n\nstatic const struct nla_policy\nhwsim_rate_info_policy[HWSIM_RATE_INFO_ATTR_MAX + 1] = {\n\t[HWSIM_RATE_INFO_ATTR_FLAGS] = { .type = NLA_U8 },\n\t[HWSIM_RATE_INFO_ATTR_MCS] = { .type = NLA_U8 },\n\t[HWSIM_RATE_INFO_ATTR_LEGACY] = { .type = NLA_U16 },\n\t[HWSIM_RATE_INFO_ATTR_NSS] = { .type = NLA_U8 },\n\t[HWSIM_RATE_INFO_ATTR_BW] = { .type = NLA_U8 },\n\t[HWSIM_RATE_INFO_ATTR_HE_GI] = { .type = NLA_U8 },\n\t[HWSIM_RATE_INFO_ATTR_HE_DCM] = { .type = NLA_U8 },\n\t[HWSIM_RATE_INFO_ATTR_HE_RU_ALLOC] = { .type = NLA_U8 },\n\t[HWSIM_RATE_INFO_ATTR_N_BOUNDED_CH] = { .type = NLA_U8 },\n\t[HWSIM_RATE_INFO_ATTR_EHT_GI] = { .type = NLA_U8 },\n\t[HWSIM_RATE_INFO_ATTR_EHT_RU_ALLOC] = { .type = NLA_U8 },\n};\n\nstatic const struct nla_policy\nhwsim_ftm_result_policy[NL80211_PMSR_FTM_RESP_ATTR_MAX + 1] = {\n\t[NL80211_PMSR_FTM_RESP_ATTR_FAIL_REASON] = { .type = NLA_U32 },\n\t[NL80211_PMSR_FTM_RESP_ATTR_BURST_INDEX] = { .type = NLA_U16 },\n\t[NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_ATTEMPTS] = { .type = NLA_U32 },\n\t[NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_SUCCESSES] = { .type = NLA_U32 },\n\t[NL80211_PMSR_FTM_RESP_ATTR_BUSY_RETRY_TIME] = { .type = NLA_U8 },\n\t[NL80211_PMSR_FTM_RESP_ATTR_NUM_BURSTS_EXP] = { .type = NLA_U8 },\n\t[NL80211_PMSR_FTM_RESP_ATTR_BURST_DURATION] = { .type = NLA_U8 },\n\t[NL80211_PMSR_FTM_RESP_ATTR_FTMS_PER_BURST] = { .type = NLA_U8 },\n\t[NL80211_PMSR_FTM_RESP_ATTR_RSSI_AVG] = { .type = NLA_U32 },\n\t[NL80211_PMSR_FTM_RESP_ATTR_RSSI_SPREAD] = { .type = NLA_U32 },\n\t[NL80211_PMSR_FTM_RESP_ATTR_TX_RATE] = NLA_POLICY_NESTED(hwsim_rate_info_policy),\n\t[NL80211_PMSR_FTM_RESP_ATTR_RX_RATE] = NLA_POLICY_NESTED(hwsim_rate_info_policy),\n\t[NL80211_PMSR_FTM_RESP_ATTR_RTT_AVG] = { .type = NLA_U64 },\n\t[NL80211_PMSR_FTM_RESP_ATTR_RTT_VARIANCE] = { .type = NLA_U64 },\n\t[NL80211_PMSR_FTM_RESP_ATTR_RTT_SPREAD] = { .type = NLA_U64 },\n\t[NL80211_PMSR_FTM_RESP_ATTR_DIST_AVG] = { .type = NLA_U64 },\n\t[NL80211_PMSR_FTM_RESP_ATTR_DIST_VARIANCE] = { .type = NLA_U64 },\n\t[NL80211_PMSR_FTM_RESP_ATTR_DIST_SPREAD] = { .type = NLA_U64 },\n\t[NL80211_PMSR_FTM_RESP_ATTR_LCI] = { .type = NLA_STRING },\n\t[NL80211_PMSR_FTM_RESP_ATTR_CIVICLOC] = { .type = NLA_STRING },\n};\n\nstatic const struct nla_policy\nhwsim_pmsr_resp_type_policy[NL80211_PMSR_TYPE_MAX + 1] = {\n\t[NL80211_PMSR_TYPE_FTM] = NLA_POLICY_NESTED(hwsim_ftm_result_policy),\n};\n\nstatic const struct nla_policy\nhwsim_pmsr_resp_policy[NL80211_PMSR_RESP_ATTR_MAX + 1] = {\n\t[NL80211_PMSR_RESP_ATTR_STATUS] = { .type = NLA_U32 },\n\t[NL80211_PMSR_RESP_ATTR_HOST_TIME] = { .type = NLA_U64 },\n\t[NL80211_PMSR_RESP_ATTR_AP_TSF] = { .type = NLA_U64 },\n\t[NL80211_PMSR_RESP_ATTR_FINAL] = { .type = NLA_FLAG },\n\t[NL80211_PMSR_RESP_ATTR_DATA] = NLA_POLICY_NESTED(hwsim_pmsr_resp_type_policy),\n};\n\nstatic const struct nla_policy\nhwsim_pmsr_peer_result_policy[NL80211_PMSR_PEER_ATTR_MAX + 1] = {\n\t[NL80211_PMSR_PEER_ATTR_ADDR] = NLA_POLICY_ETH_ADDR_COMPAT,\n\t[NL80211_PMSR_PEER_ATTR_CHAN] = { .type = NLA_REJECT },\n\t[NL80211_PMSR_PEER_ATTR_REQ] = { .type = NLA_REJECT },\n\t[NL80211_PMSR_PEER_ATTR_RESP] = NLA_POLICY_NESTED(hwsim_pmsr_resp_policy),\n};\n\nstatic const struct nla_policy\nhwsim_pmsr_peers_result_policy[NL80211_PMSR_ATTR_MAX + 1] = {\n\t[NL80211_PMSR_ATTR_MAX_PEERS] = { .type = NLA_REJECT },\n\t[NL80211_PMSR_ATTR_REPORT_AP_TSF] = { .type = NLA_REJECT },\n\t[NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR] = { .type = NLA_REJECT },\n\t[NL80211_PMSR_ATTR_TYPE_CAPA] = { .type = NLA_REJECT },\n\t[NL80211_PMSR_ATTR_PEERS] = NLA_POLICY_NESTED_ARRAY(hwsim_pmsr_peer_result_policy),\n};\n\nstatic const struct nla_policy\nhwsim_ftm_capa_policy[NL80211_PMSR_FTM_CAPA_ATTR_MAX + 1] = {\n\t[NL80211_PMSR_FTM_CAPA_ATTR_ASAP] = { .type = NLA_FLAG },\n\t[NL80211_PMSR_FTM_CAPA_ATTR_NON_ASAP] = { .type = NLA_FLAG },\n\t[NL80211_PMSR_FTM_CAPA_ATTR_REQ_LCI] = { .type = NLA_FLAG },\n\t[NL80211_PMSR_FTM_CAPA_ATTR_REQ_CIVICLOC] = { .type = NLA_FLAG },\n\t[NL80211_PMSR_FTM_CAPA_ATTR_PREAMBLES] = { .type = NLA_U32 },\n\t[NL80211_PMSR_FTM_CAPA_ATTR_BANDWIDTHS] = { .type = NLA_U32 },\n\t[NL80211_PMSR_FTM_CAPA_ATTR_MAX_BURSTS_EXPONENT] = NLA_POLICY_MAX(NLA_U8, 15),\n\t[NL80211_PMSR_FTM_CAPA_ATTR_MAX_FTMS_PER_BURST] = NLA_POLICY_MAX(NLA_U8, 31),\n\t[NL80211_PMSR_FTM_CAPA_ATTR_TRIGGER_BASED] = { .type = NLA_FLAG },\n\t[NL80211_PMSR_FTM_CAPA_ATTR_NON_TRIGGER_BASED] = { .type = NLA_FLAG },\n};\n\nstatic const struct nla_policy\nhwsim_pmsr_capa_type_policy[NL80211_PMSR_TYPE_MAX + 1] = {\n\t[NL80211_PMSR_TYPE_FTM] = NLA_POLICY_NESTED(hwsim_ftm_capa_policy),\n};\n\nstatic const struct nla_policy\nhwsim_pmsr_capa_policy[NL80211_PMSR_ATTR_MAX + 1] = {\n\t[NL80211_PMSR_ATTR_MAX_PEERS] = { .type = NLA_U32 },\n\t[NL80211_PMSR_ATTR_REPORT_AP_TSF] = { .type = NLA_FLAG },\n\t[NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR] = { .type = NLA_FLAG },\n\t[NL80211_PMSR_ATTR_TYPE_CAPA] = NLA_POLICY_NESTED(hwsim_pmsr_capa_type_policy),\n\t[NL80211_PMSR_ATTR_PEERS] = { .type = NLA_REJECT },  \n};\n\nstatic const struct nla_policy hwsim_genl_policy[HWSIM_ATTR_MAX + 1] = {\n\t[HWSIM_ATTR_ADDR_RECEIVER] = NLA_POLICY_ETH_ADDR_COMPAT,\n\t[HWSIM_ATTR_ADDR_TRANSMITTER] = NLA_POLICY_ETH_ADDR_COMPAT,\n\t[HWSIM_ATTR_FRAME] = { .type = NLA_BINARY,\n\t\t\t       .len = IEEE80211_MAX_DATA_LEN },\n\t[HWSIM_ATTR_FLAGS] = { .type = NLA_U32 },\n\t[HWSIM_ATTR_RX_RATE] = { .type = NLA_U32 },\n\t[HWSIM_ATTR_SIGNAL] = { .type = NLA_U32 },\n\t[HWSIM_ATTR_TX_INFO] = { .type = NLA_BINARY,\n\t\t\t\t .len = IEEE80211_TX_MAX_RATES *\n\t\t\t\t\tsizeof(struct hwsim_tx_rate)},\n\t[HWSIM_ATTR_COOKIE] = { .type = NLA_U64 },\n\t[HWSIM_ATTR_CHANNELS] = { .type = NLA_U32 },\n\t[HWSIM_ATTR_RADIO_ID] = { .type = NLA_U32 },\n\t[HWSIM_ATTR_REG_HINT_ALPHA2] = { .type = NLA_STRING, .len = 2 },\n\t[HWSIM_ATTR_REG_CUSTOM_REG] = { .type = NLA_U32 },\n\t[HWSIM_ATTR_REG_STRICT_REG] = { .type = NLA_FLAG },\n\t[HWSIM_ATTR_SUPPORT_P2P_DEVICE] = { .type = NLA_FLAG },\n\t[HWSIM_ATTR_USE_CHANCTX] = { .type = NLA_FLAG },\n\t[HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE] = { .type = NLA_FLAG },\n\t[HWSIM_ATTR_RADIO_NAME] = { .type = NLA_STRING },\n\t[HWSIM_ATTR_NO_VIF] = { .type = NLA_FLAG },\n\t[HWSIM_ATTR_FREQ] = { .type = NLA_U32 },\n\t[HWSIM_ATTR_TX_INFO_FLAGS] = { .type = NLA_BINARY },\n\t[HWSIM_ATTR_PERM_ADDR] = NLA_POLICY_ETH_ADDR_COMPAT,\n\t[HWSIM_ATTR_IFTYPE_SUPPORT] = { .type = NLA_U32 },\n\t[HWSIM_ATTR_CIPHER_SUPPORT] = { .type = NLA_BINARY },\n\t[HWSIM_ATTR_MLO_SUPPORT] = { .type = NLA_FLAG },\n\t[HWSIM_ATTR_PMSR_SUPPORT] = NLA_POLICY_NESTED(hwsim_pmsr_capa_policy),\n\t[HWSIM_ATTR_PMSR_RESULT] = NLA_POLICY_NESTED(hwsim_pmsr_peers_result_policy),\n};\n\n#if IS_REACHABLE(CONFIG_VIRTIO)\n\n \nstatic struct virtqueue *hwsim_vqs[HWSIM_NUM_VQS];\nstatic bool hwsim_virtio_enabled;\nstatic DEFINE_SPINLOCK(hwsim_virtio_lock);\n\nstatic void hwsim_virtio_rx_work(struct work_struct *work);\nstatic DECLARE_WORK(hwsim_virtio_rx, hwsim_virtio_rx_work);\n\nstatic int hwsim_tx_virtio(struct mac80211_hwsim_data *data,\n\t\t\t   struct sk_buff *skb)\n{\n\tstruct scatterlist sg[1];\n\tunsigned long flags;\n\tint err;\n\n\tspin_lock_irqsave(&hwsim_virtio_lock, flags);\n\tif (!hwsim_virtio_enabled) {\n\t\terr = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\tsg_init_one(sg, skb->head, skb_end_offset(skb));\n\terr = virtqueue_add_outbuf(hwsim_vqs[HWSIM_VQ_TX], sg, 1, skb,\n\t\t\t\t   GFP_ATOMIC);\n\tif (err)\n\t\tgoto out_free;\n\tvirtqueue_kick(hwsim_vqs[HWSIM_VQ_TX]);\n\tspin_unlock_irqrestore(&hwsim_virtio_lock, flags);\n\treturn 0;\n\nout_free:\n\tspin_unlock_irqrestore(&hwsim_virtio_lock, flags);\n\tnlmsg_free(skb);\n\treturn err;\n}\n#else\n \nextern int hwsim_tx_virtio(struct mac80211_hwsim_data *data,\n\t\t\t   struct sk_buff *skb);\n#define hwsim_virtio_enabled false\n#endif\n\nstatic int hwsim_get_chanwidth(enum nl80211_chan_width bw)\n{\n\tswitch (bw) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\tcase NL80211_CHAN_WIDTH_20:\n\t\treturn 20;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\treturn 40;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\treturn 80;\n\tcase NL80211_CHAN_WIDTH_80P80:\n\tcase NL80211_CHAN_WIDTH_160:\n\t\treturn 160;\n\tcase NL80211_CHAN_WIDTH_320:\n\t\treturn 320;\n\tcase NL80211_CHAN_WIDTH_5:\n\t\treturn 5;\n\tcase NL80211_CHAN_WIDTH_10:\n\t\treturn 10;\n\tcase NL80211_CHAN_WIDTH_1:\n\t\treturn 1;\n\tcase NL80211_CHAN_WIDTH_2:\n\t\treturn 2;\n\tcase NL80211_CHAN_WIDTH_4:\n\t\treturn 4;\n\tcase NL80211_CHAN_WIDTH_8:\n\t\treturn 8;\n\tcase NL80211_CHAN_WIDTH_16:\n\t\treturn 16;\n\t}\n\n\treturn INT_MAX;\n}\n\nstatic void mac80211_hwsim_tx_frame(struct ieee80211_hw *hw,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    struct ieee80211_channel *chan);\n\n \nstatic void hwsim_send_ps_poll(void *dat, u8 *mac, struct ieee80211_vif *vif)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\tstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_pspoll *pspoll;\n\n\tif (!vp->assoc)\n\t\treturn;\n\n\twiphy_dbg(data->hw->wiphy,\n\t\t  \"%s: send PS-Poll to %pM for aid %d\\n\",\n\t\t  __func__, vp->bssid, vp->aid);\n\n\tskb = dev_alloc_skb(sizeof(*pspoll));\n\tif (!skb)\n\t\treturn;\n\tpspoll = skb_put(skb, sizeof(*pspoll));\n\tpspoll->frame_control = cpu_to_le16(IEEE80211_FTYPE_CTL |\n\t\t\t\t\t    IEEE80211_STYPE_PSPOLL |\n\t\t\t\t\t    IEEE80211_FCTL_PM);\n\tpspoll->aid = cpu_to_le16(0xc000 | vp->aid);\n\tmemcpy(pspoll->bssid, vp->bssid, ETH_ALEN);\n\tmemcpy(pspoll->ta, mac, ETH_ALEN);\n\n\trcu_read_lock();\n\tmac80211_hwsim_tx_frame(data->hw, skb,\n\t\t\t\trcu_dereference(vif->bss_conf.chanctx_conf)->def.chan);\n\trcu_read_unlock();\n}\n\nstatic void hwsim_send_nullfunc(struct mac80211_hwsim_data *data, u8 *mac,\n\t\t\t\tstruct ieee80211_vif *vif, int ps)\n{\n\tstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_tx_info *cb;\n\n\tif (!vp->assoc)\n\t\treturn;\n\n\twiphy_dbg(data->hw->wiphy,\n\t\t  \"%s: send data::nullfunc to %pM ps=%d\\n\",\n\t\t  __func__, vp->bssid, ps);\n\n\tskb = dev_alloc_skb(sizeof(*hdr));\n\tif (!skb)\n\t\treturn;\n\thdr = skb_put(skb, sizeof(*hdr) - ETH_ALEN);\n\thdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |\n\t\t\t\t\t IEEE80211_STYPE_NULLFUNC |\n\t\t\t\t\t IEEE80211_FCTL_TODS |\n\t\t\t\t\t (ps ? IEEE80211_FCTL_PM : 0));\n\thdr->duration_id = cpu_to_le16(0);\n\tmemcpy(hdr->addr1, vp->bssid, ETH_ALEN);\n\tmemcpy(hdr->addr2, mac, ETH_ALEN);\n\tmemcpy(hdr->addr3, vp->bssid, ETH_ALEN);\n\n\tcb = IEEE80211_SKB_CB(skb);\n\tcb->control.rates[0].count = 1;\n\tcb->control.rates[1].idx = -1;\n\n\trcu_read_lock();\n\tmac80211_hwsim_tx_frame(data->hw, skb,\n\t\t\t\trcu_dereference(vif->bss_conf.chanctx_conf)->def.chan);\n\trcu_read_unlock();\n}\n\n\nstatic void hwsim_send_nullfunc_ps(void *dat, u8 *mac,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\thwsim_send_nullfunc(data, mac, vif, 1);\n}\n\nstatic void hwsim_send_nullfunc_no_ps(void *dat, u8 *mac,\n\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\thwsim_send_nullfunc(data, mac, vif, 0);\n}\n\nstatic int hwsim_fops_ps_read(void *dat, u64 *val)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\t*val = data->ps;\n\treturn 0;\n}\n\nstatic int hwsim_fops_ps_write(void *dat, u64 val)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\tenum ps_mode old_ps;\n\n\tif (val != PS_DISABLED && val != PS_ENABLED && val != PS_AUTO_POLL &&\n\t    val != PS_MANUAL_POLL)\n\t\treturn -EINVAL;\n\n\tif (val == PS_MANUAL_POLL) {\n\t\tif (data->ps != PS_ENABLED)\n\t\t\treturn -EINVAL;\n\t\tlocal_bh_disable();\n\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\tdata->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\t\thwsim_send_ps_poll, data);\n\t\tlocal_bh_enable();\n\t\treturn 0;\n\t}\n\told_ps = data->ps;\n\tdata->ps = val;\n\n\tlocal_bh_disable();\n\tif (old_ps == PS_DISABLED && val != PS_DISABLED) {\n\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\tdata->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\t\thwsim_send_nullfunc_ps, data);\n\t} else if (old_ps != PS_DISABLED && val == PS_DISABLED) {\n\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\tdata->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\t\thwsim_send_nullfunc_no_ps, data);\n\t}\n\tlocal_bh_enable();\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(hwsim_fops_ps, hwsim_fops_ps_read, hwsim_fops_ps_write,\n\t\t\t \"%llu\\n\");\n\nstatic int hwsim_write_simulate_radar(void *dat, u64 val)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\n\tieee80211_radar_detected(data->hw);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(hwsim_simulate_radar, NULL,\n\t\t\t hwsim_write_simulate_radar, \"%llu\\n\");\n\nstatic int hwsim_fops_group_read(void *dat, u64 *val)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\t*val = data->group;\n\treturn 0;\n}\n\nstatic int hwsim_fops_group_write(void *dat, u64 val)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\tdata->group = val;\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(hwsim_fops_group,\n\t\t\t hwsim_fops_group_read, hwsim_fops_group_write,\n\t\t\t \"%llx\\n\");\n\nstatic int hwsim_fops_rx_rssi_read(void *dat, u64 *val)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\t*val = data->rx_rssi;\n\treturn 0;\n}\n\nstatic int hwsim_fops_rx_rssi_write(void *dat, u64 val)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\tint rssi = (int)val;\n\n\tif (rssi >= 0 || rssi < -100)\n\t\treturn -EINVAL;\n\n\tdata->rx_rssi = rssi;\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(hwsim_fops_rx_rssi,\n\t\t\t hwsim_fops_rx_rssi_read, hwsim_fops_rx_rssi_write,\n\t\t\t \"%lld\\n\");\n\nstatic netdev_tx_t hwsim_mon_xmit(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev)\n{\n\t \n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic inline u64 mac80211_hwsim_get_tsf_raw(void)\n{\n\treturn ktime_to_us(ktime_get_real());\n}\n\nstatic __le64 __mac80211_hwsim_get_tsf(struct mac80211_hwsim_data *data)\n{\n\tu64 now = mac80211_hwsim_get_tsf_raw();\n\treturn cpu_to_le64(now + data->tsf_offset);\n}\n\nstatic u64 mac80211_hwsim_get_tsf(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\treturn le64_to_cpu(__mac80211_hwsim_get_tsf(data));\n}\n\nstatic void mac80211_hwsim_set_tsf(struct ieee80211_hw *hw,\n\t\tstruct ieee80211_vif *vif, u64 tsf)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tu64 now = mac80211_hwsim_get_tsf(hw, vif);\n\t \n\tu32 bcn_int = data->link_data[0].beacon_int;\n\tu64 delta = abs(tsf - now);\n\n\t \n\tif (tsf > now) {\n\t\tdata->tsf_offset += delta;\n\t\tdata->bcn_delta = do_div(delta, bcn_int);\n\t} else {\n\t\tdata->tsf_offset -= delta;\n\t\tdata->bcn_delta = -(s64)do_div(delta, bcn_int);\n\t}\n}\n\nstatic void mac80211_hwsim_monitor_rx(struct ieee80211_hw *hw,\n\t\t\t\t      struct sk_buff *tx_skb,\n\t\t\t\t      struct ieee80211_channel *chan)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tstruct sk_buff *skb;\n\tstruct hwsim_radiotap_hdr *hdr;\n\tu16 flags, bitrate;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx_skb);\n\tstruct ieee80211_rate *txrate = ieee80211_get_tx_rate(hw, info);\n\n\tif (!txrate)\n\t\tbitrate = 0;\n\telse\n\t\tbitrate = txrate->bitrate;\n\n\tif (!netif_running(hwsim_mon))\n\t\treturn;\n\n\tskb = skb_copy_expand(tx_skb, sizeof(*hdr), 0, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn;\n\n\thdr = skb_push(skb, sizeof(*hdr));\n\thdr->hdr.it_version = PKTHDR_RADIOTAP_VERSION;\n\thdr->hdr.it_pad = 0;\n\thdr->hdr.it_len = cpu_to_le16(sizeof(*hdr));\n\thdr->hdr.it_present = cpu_to_le32((1 << IEEE80211_RADIOTAP_FLAGS) |\n\t\t\t\t\t  (1 << IEEE80211_RADIOTAP_RATE) |\n\t\t\t\t\t  (1 << IEEE80211_RADIOTAP_TSFT) |\n\t\t\t\t\t  (1 << IEEE80211_RADIOTAP_CHANNEL));\n\thdr->rt_tsft = __mac80211_hwsim_get_tsf(data);\n\thdr->rt_flags = 0;\n\thdr->rt_rate = bitrate / 5;\n\thdr->rt_channel = cpu_to_le16(chan->center_freq);\n\tflags = IEEE80211_CHAN_2GHZ;\n\tif (txrate && txrate->flags & IEEE80211_RATE_ERP_G)\n\t\tflags |= IEEE80211_CHAN_OFDM;\n\telse\n\t\tflags |= IEEE80211_CHAN_CCK;\n\thdr->rt_chbitmask = cpu_to_le16(flags);\n\n\tskb->dev = hwsim_mon;\n\tskb_reset_mac_header(skb);\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\tskb->pkt_type = PACKET_OTHERHOST;\n\tskb->protocol = htons(ETH_P_802_2);\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\tnetif_rx(skb);\n}\n\n\nstatic void mac80211_hwsim_monitor_ack(struct ieee80211_channel *chan,\n\t\t\t\t       const u8 *addr)\n{\n\tstruct sk_buff *skb;\n\tstruct hwsim_radiotap_ack_hdr *hdr;\n\tu16 flags;\n\tstruct ieee80211_hdr *hdr11;\n\n\tif (!netif_running(hwsim_mon))\n\t\treturn;\n\n\tskb = dev_alloc_skb(100);\n\tif (skb == NULL)\n\t\treturn;\n\n\thdr = skb_put(skb, sizeof(*hdr));\n\thdr->hdr.it_version = PKTHDR_RADIOTAP_VERSION;\n\thdr->hdr.it_pad = 0;\n\thdr->hdr.it_len = cpu_to_le16(sizeof(*hdr));\n\thdr->hdr.it_present = cpu_to_le32((1 << IEEE80211_RADIOTAP_FLAGS) |\n\t\t\t\t\t  (1 << IEEE80211_RADIOTAP_CHANNEL));\n\thdr->rt_flags = 0;\n\thdr->pad = 0;\n\thdr->rt_channel = cpu_to_le16(chan->center_freq);\n\tflags = IEEE80211_CHAN_2GHZ;\n\thdr->rt_chbitmask = cpu_to_le16(flags);\n\n\thdr11 = skb_put(skb, 10);\n\thdr11->frame_control = cpu_to_le16(IEEE80211_FTYPE_CTL |\n\t\t\t\t\t   IEEE80211_STYPE_ACK);\n\thdr11->duration_id = cpu_to_le16(0);\n\tmemcpy(hdr11->addr1, addr, ETH_ALEN);\n\n\tskb->dev = hwsim_mon;\n\tskb_reset_mac_header(skb);\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\tskb->pkt_type = PACKET_OTHERHOST;\n\tskb->protocol = htons(ETH_P_802_2);\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\tnetif_rx(skb);\n}\n\nstruct mac80211_hwsim_addr_match_data {\n\tu8 addr[ETH_ALEN];\n\tbool ret;\n};\n\nstatic void mac80211_hwsim_addr_iter(void *data, u8 *mac,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tint i;\n\tstruct mac80211_hwsim_addr_match_data *md = data;\n\n\tif (memcmp(mac, md->addr, ETH_ALEN) == 0) {\n\t\tmd->ret = true;\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(vif->link_conf); i++) {\n\t\tstruct ieee80211_bss_conf *conf;\n\n\t\tconf = rcu_dereference(vif->link_conf[i]);\n\t\tif (!conf)\n\t\t\tcontinue;\n\n\t\tif (memcmp(conf->addr, md->addr, ETH_ALEN) == 0) {\n\t\t\tmd->ret = true;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic bool mac80211_hwsim_addr_match(struct mac80211_hwsim_data *data,\n\t\t\t\t      const u8 *addr)\n{\n\tstruct mac80211_hwsim_addr_match_data md = {\n\t\t.ret = false,\n\t};\n\n\tif (data->scanning && memcmp(addr, data->scan_addr, ETH_ALEN) == 0)\n\t\treturn true;\n\n\tmemcpy(md.addr, addr, ETH_ALEN);\n\n\tieee80211_iterate_active_interfaces_atomic(data->hw,\n\t\t\t\t\t\t   IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\t\t   mac80211_hwsim_addr_iter,\n\t\t\t\t\t\t   &md);\n\n\treturn md.ret;\n}\n\nstatic bool hwsim_ps_rx_ok(struct mac80211_hwsim_data *data,\n\t\t\t   struct sk_buff *skb)\n{\n\tswitch (data->ps) {\n\tcase PS_DISABLED:\n\t\treturn true;\n\tcase PS_ENABLED:\n\t\treturn false;\n\tcase PS_AUTO_POLL:\n\t\t \n\t\treturn true;\n\tcase PS_MANUAL_POLL:\n\t\t \n\t\tif (data->ps_poll_pending &&\n\t\t    mac80211_hwsim_addr_match(data, skb->data + 4)) {\n\t\t\tdata->ps_poll_pending = false;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int hwsim_unicast_netgroup(struct mac80211_hwsim_data *data,\n\t\t\t\t  struct sk_buff *skb, int portid)\n{\n\tstruct net *net;\n\tbool found = false;\n\tint res = -ENOENT;\n\n\trcu_read_lock();\n\tfor_each_net_rcu(net) {\n\t\tif (data->netgroup == hwsim_net_get_netgroup(net)) {\n\t\t\tres = genlmsg_unicast(net, skb, portid);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!found)\n\t\tnlmsg_free(skb);\n\n\treturn res;\n}\n\nstatic void mac80211_hwsim_config_mac_nl(struct ieee80211_hw *hw,\n\t\t\t\t\t const u8 *addr, bool add)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tu32 _portid = READ_ONCE(data->wmediumd);\n\tstruct sk_buff *skb;\n\tvoid *msg_head;\n\n\tWARN_ON(!is_valid_ether_addr(addr));\n\n\tif (!_portid && !hwsim_virtio_enabled)\n\t\treturn;\n\n\tskb = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tmsg_head = genlmsg_put(skb, 0, 0, &hwsim_genl_family, 0,\n\t\t\t       add ? HWSIM_CMD_ADD_MAC_ADDR :\n\t\t\t\t     HWSIM_CMD_DEL_MAC_ADDR);\n\tif (!msg_head) {\n\t\tpr_debug(\"mac80211_hwsim: problem with msg_head\\n\");\n\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put(skb, HWSIM_ATTR_ADDR_TRANSMITTER,\n\t\t    ETH_ALEN, data->addresses[1].addr))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put(skb, HWSIM_ATTR_ADDR_RECEIVER, ETH_ALEN, addr))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(skb, msg_head);\n\n\tif (hwsim_virtio_enabled)\n\t\thwsim_tx_virtio(data, skb);\n\telse\n\t\thwsim_unicast_netgroup(data, skb, _portid);\n\treturn;\nnla_put_failure:\n\tnlmsg_free(skb);\n}\n\nstatic inline u16 trans_tx_rate_flags_ieee2hwsim(struct ieee80211_tx_rate *rate)\n{\n\tu16 result = 0;\n\n\tif (rate->flags & IEEE80211_TX_RC_USE_RTS_CTS)\n\t\tresult |= MAC80211_HWSIM_TX_RC_USE_RTS_CTS;\n\tif (rate->flags & IEEE80211_TX_RC_USE_CTS_PROTECT)\n\t\tresult |= MAC80211_HWSIM_TX_RC_USE_CTS_PROTECT;\n\tif (rate->flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE)\n\t\tresult |= MAC80211_HWSIM_TX_RC_USE_SHORT_PREAMBLE;\n\tif (rate->flags & IEEE80211_TX_RC_MCS)\n\t\tresult |= MAC80211_HWSIM_TX_RC_MCS;\n\tif (rate->flags & IEEE80211_TX_RC_GREEN_FIELD)\n\t\tresult |= MAC80211_HWSIM_TX_RC_GREEN_FIELD;\n\tif (rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\n\t\tresult |= MAC80211_HWSIM_TX_RC_40_MHZ_WIDTH;\n\tif (rate->flags & IEEE80211_TX_RC_DUP_DATA)\n\t\tresult |= MAC80211_HWSIM_TX_RC_DUP_DATA;\n\tif (rate->flags & IEEE80211_TX_RC_SHORT_GI)\n\t\tresult |= MAC80211_HWSIM_TX_RC_SHORT_GI;\n\tif (rate->flags & IEEE80211_TX_RC_VHT_MCS)\n\t\tresult |= MAC80211_HWSIM_TX_RC_VHT_MCS;\n\tif (rate->flags & IEEE80211_TX_RC_80_MHZ_WIDTH)\n\t\tresult |= MAC80211_HWSIM_TX_RC_80_MHZ_WIDTH;\n\tif (rate->flags & IEEE80211_TX_RC_160_MHZ_WIDTH)\n\t\tresult |= MAC80211_HWSIM_TX_RC_160_MHZ_WIDTH;\n\n\treturn result;\n}\n\nstatic void mac80211_hwsim_tx_frame_nl(struct ieee80211_hw *hw,\n\t\t\t\t       struct sk_buff *my_skb,\n\t\t\t\t       int dst_portid,\n\t\t\t\t       struct ieee80211_channel *channel)\n{\n\tstruct sk_buff *skb;\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) my_skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(my_skb);\n\tvoid *msg_head;\n\tunsigned int hwsim_flags = 0;\n\tint i;\n\tstruct hwsim_tx_rate tx_attempts[IEEE80211_TX_MAX_RATES];\n\tstruct hwsim_tx_rate_flag tx_attempts_flags[IEEE80211_TX_MAX_RATES];\n\tuintptr_t cookie;\n\n\tif (data->ps != PS_DISABLED)\n\t\thdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);\n\t \n\tif (skb_queue_len(&data->pending) >= MAX_QUEUE) {\n\t\t \n\t\twhile (skb_queue_len(&data->pending) >= WARN_QUEUE) {\n\t\t\tieee80211_free_txskb(hw, skb_dequeue(&data->pending));\n\t\t\tdata->tx_dropped++;\n\t\t}\n\t}\n\n\tskb = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\tgoto nla_put_failure;\n\n\tmsg_head = genlmsg_put(skb, 0, 0, &hwsim_genl_family, 0,\n\t\t\t       HWSIM_CMD_FRAME);\n\tif (msg_head == NULL) {\n\t\tpr_debug(\"mac80211_hwsim: problem with msg_head\\n\");\n\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put(skb, HWSIM_ATTR_ADDR_TRANSMITTER,\n\t\t    ETH_ALEN, data->addresses[1].addr))\n\t\tgoto nla_put_failure;\n\n\t \n\tif (nla_put(skb, HWSIM_ATTR_FRAME, my_skb->len, my_skb->data))\n\t\tgoto nla_put_failure;\n\n\t \n\n\tif (info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS)\n\t\thwsim_flags |= HWSIM_TX_CTL_REQ_TX_STATUS;\n\n\tif (info->flags & IEEE80211_TX_CTL_NO_ACK)\n\t\thwsim_flags |= HWSIM_TX_CTL_NO_ACK;\n\n\tif (nla_put_u32(skb, HWSIM_ATTR_FLAGS, hwsim_flags))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, HWSIM_ATTR_FREQ, channel->center_freq))\n\t\tgoto nla_put_failure;\n\n\t \n\n\tfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {\n\t\ttx_attempts[i].idx = info->status.rates[i].idx;\n\t\ttx_attempts_flags[i].idx = info->status.rates[i].idx;\n\t\ttx_attempts[i].count = info->status.rates[i].count;\n\t\ttx_attempts_flags[i].flags =\n\t\t\t\ttrans_tx_rate_flags_ieee2hwsim(\n\t\t\t\t\t\t&info->status.rates[i]);\n\t}\n\n\tif (nla_put(skb, HWSIM_ATTR_TX_INFO,\n\t\t    sizeof(struct hwsim_tx_rate)*IEEE80211_TX_MAX_RATES,\n\t\t    tx_attempts))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put(skb, HWSIM_ATTR_TX_INFO_FLAGS,\n\t\t    sizeof(struct hwsim_tx_rate_flag) * IEEE80211_TX_MAX_RATES,\n\t\t    tx_attempts_flags))\n\t\tgoto nla_put_failure;\n\n\t \n\tcookie = atomic_inc_return(&data->pending_cookie);\n\tinfo->rate_driver_data[0] = (void *)cookie;\n\tif (nla_put_u64_64bit(skb, HWSIM_ATTR_COOKIE, cookie, HWSIM_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(skb, msg_head);\n\n\tif (hwsim_virtio_enabled) {\n\t\tif (hwsim_tx_virtio(data, skb))\n\t\t\tgoto err_free_txskb;\n\t} else {\n\t\tif (hwsim_unicast_netgroup(data, skb, dst_portid))\n\t\t\tgoto err_free_txskb;\n\t}\n\n\t \n\tskb_queue_tail(&data->pending, my_skb);\n\tdata->tx_pkts++;\n\tdata->tx_bytes += my_skb->len;\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(skb);\nerr_free_txskb:\n\tpr_debug(\"mac80211_hwsim: error occurred in %s\\n\", __func__);\n\tieee80211_free_txskb(hw, my_skb);\n\tdata->tx_failed++;\n}\n\nstatic bool hwsim_chans_compat(struct ieee80211_channel *c1,\n\t\t\t       struct ieee80211_channel *c2)\n{\n\tif (!c1 || !c2)\n\t\treturn false;\n\n\treturn c1->center_freq == c2->center_freq;\n}\n\nstruct tx_iter_data {\n\tstruct ieee80211_channel *channel;\n\tbool receive;\n};\n\nstatic void mac80211_hwsim_tx_iter(void *_data, u8 *addr,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct tx_iter_data *data = _data;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vif->link_conf); i++) {\n\t\tstruct ieee80211_bss_conf *conf;\n\t\tstruct ieee80211_chanctx_conf *chanctx;\n\n\t\tconf = rcu_dereference(vif->link_conf[i]);\n\t\tif (!conf)\n\t\t\tcontinue;\n\n\t\tchanctx = rcu_dereference(conf->chanctx_conf);\n\t\tif (!chanctx)\n\t\t\tcontinue;\n\n\t\tif (!hwsim_chans_compat(data->channel, chanctx->def.chan))\n\t\t\tcontinue;\n\n\t\tdata->receive = true;\n\t\treturn;\n\t}\n}\n\nstatic void mac80211_hwsim_add_vendor_rtap(struct sk_buff *skb)\n{\n\t \n#ifdef HWSIM_RADIOTAP_OUI\n\tstruct ieee80211_radiotap_vendor_tlv *rtap;\n\tstatic const char vendor_data[8] = \"ABCDEFGH\";\n\n\t\n\tBUILD_BUG_ON(sizeof(vendor_data) % 4);\n\t \n\tskb_reset_mac_header(skb);\n\n\t \n\trtap = skb_push(skb, sizeof(*rtap) + sizeof(vendor_data));\n\n\trtap->len = cpu_to_le16(sizeof(*rtap) -\n\t\t\t\tsizeof(struct ieee80211_radiotap_tlv) +\n\t\t\t\tsizeof(vendor_data));\n\trtap->type = cpu_to_le16(IEEE80211_RADIOTAP_VENDOR_NAMESPACE);\n\n\trtap->content.oui[0] = HWSIM_RADIOTAP_OUI[0];\n\trtap->content.oui[1] = HWSIM_RADIOTAP_OUI[1];\n\trtap->content.oui[2] = HWSIM_RADIOTAP_OUI[2];\n\trtap->content.oui_subtype = 127;\n\t \n\trtap->content.reserved = 0;\n\trtap->content.vendor_type = 0;\n\tmemcpy(rtap->content.data, vendor_data, sizeof(vendor_data));\n\n\tIEEE80211_SKB_RXCB(skb)->flag |= RX_FLAG_RADIOTAP_TLV_AT_END;\n#endif\n}\n\nstatic void mac80211_hwsim_rx(struct mac80211_hwsim_data *data,\n\t\t\t      struct ieee80211_rx_status *rx_status,\n\t\t\t      struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\n\tif (!ieee80211_has_morefrags(hdr->frame_control) &&\n\t    !is_multicast_ether_addr(hdr->addr1) &&\n\t    (ieee80211_is_mgmt(hdr->frame_control) ||\n\t     ieee80211_is_data(hdr->frame_control))) {\n\t\tstruct ieee80211_sta *sta;\n\t\tunsigned int link_id;\n\n\t\trcu_read_lock();\n\t\tsta = ieee80211_find_sta_by_link_addrs(data->hw, hdr->addr2,\n\t\t\t\t\t\t       hdr->addr1, &link_id);\n\t\tif (sta) {\n\t\t\tstruct hwsim_sta_priv *sp = (void *)sta->drv_priv;\n\n\t\t\tif (ieee80211_has_pm(hdr->frame_control))\n\t\t\t\tsp->active_links_rx &= ~BIT(link_id);\n\t\t\telse\n\t\t\t\tsp->active_links_rx |= BIT(link_id);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tmemcpy(IEEE80211_SKB_RXCB(skb), rx_status, sizeof(*rx_status));\n\n\tmac80211_hwsim_add_vendor_rtap(skb);\n\n\tdata->rx_pkts++;\n\tdata->rx_bytes += skb->len;\n\tieee80211_rx_irqsafe(data->hw, skb);\n}\n\nstatic bool mac80211_hwsim_tx_frame_no_nl(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t  struct ieee80211_channel *chan)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv, *data2;\n\tbool ack = false;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_rx_status rx_status;\n\tu64 now;\n\n\tmemset(&rx_status, 0, sizeof(rx_status));\n\trx_status.flag |= RX_FLAG_MACTIME_START;\n\trx_status.freq = chan->center_freq;\n\trx_status.freq_offset = chan->freq_offset ? 1 : 0;\n\trx_status.band = chan->band;\n\tif (info->control.rates[0].flags & IEEE80211_TX_RC_VHT_MCS) {\n\t\trx_status.rate_idx =\n\t\t\tieee80211_rate_get_vht_mcs(&info->control.rates[0]);\n\t\trx_status.nss =\n\t\t\tieee80211_rate_get_vht_nss(&info->control.rates[0]);\n\t\trx_status.encoding = RX_ENC_VHT;\n\t} else {\n\t\trx_status.rate_idx = info->control.rates[0].idx;\n\t\tif (info->control.rates[0].flags & IEEE80211_TX_RC_MCS)\n\t\t\trx_status.encoding = RX_ENC_HT;\n\t}\n\tif (info->control.rates[0].flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\n\t\trx_status.bw = RATE_INFO_BW_40;\n\telse if (info->control.rates[0].flags & IEEE80211_TX_RC_80_MHZ_WIDTH)\n\t\trx_status.bw = RATE_INFO_BW_80;\n\telse if (info->control.rates[0].flags & IEEE80211_TX_RC_160_MHZ_WIDTH)\n\t\trx_status.bw = RATE_INFO_BW_160;\n\telse\n\t\trx_status.bw = RATE_INFO_BW_20;\n\tif (info->control.rates[0].flags & IEEE80211_TX_RC_SHORT_GI)\n\t\trx_status.enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\t \n\trx_status.signal = data->rx_rssi;\n\tif (info->control.vif)\n\t\trx_status.signal += info->control.vif->bss_conf.txpower;\n\n\tif (data->ps != PS_DISABLED)\n\t\thdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);\n\n\t \n\tskb_orphan(skb);\n\tskb_dst_drop(skb);\n\tskb->mark = 0;\n\tskb_ext_reset(skb);\n\tnf_reset_ct(skb);\n\n\t \n\tif (ieee80211_is_beacon(hdr->frame_control) ||\n\t    ieee80211_is_probe_resp(hdr->frame_control)) {\n\t\trx_status.boottime_ns = ktime_get_boottime_ns();\n\t\tnow = data->abs_bcn_ts;\n\t} else {\n\t\tnow = mac80211_hwsim_get_tsf_raw();\n\t}\n\n\t \n\tspin_lock(&hwsim_radio_lock);\n\tlist_for_each_entry(data2, &hwsim_radios, list) {\n\t\tstruct sk_buff *nskb;\n\t\tstruct tx_iter_data tx_iter_data = {\n\t\t\t.receive = false,\n\t\t\t.channel = chan,\n\t\t};\n\n\t\tif (data == data2)\n\t\t\tcontinue;\n\n\t\tif (!data2->started || (data2->idle && !data2->tmp_chan) ||\n\t\t    !hwsim_ps_rx_ok(data2, skb))\n\t\t\tcontinue;\n\n\t\tif (!(data->group & data2->group))\n\t\t\tcontinue;\n\n\t\tif (data->netgroup != data2->netgroup)\n\t\t\tcontinue;\n\n\t\tif (!hwsim_chans_compat(chan, data2->tmp_chan) &&\n\t\t    !hwsim_chans_compat(chan, data2->channel)) {\n\t\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\t\tdata2->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\tmac80211_hwsim_tx_iter, &tx_iter_data);\n\t\t\tif (!tx_iter_data.receive)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (skb->len < PAGE_SIZE && paged_rx) {\n\t\t\tstruct page *page = alloc_page(GFP_ATOMIC);\n\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\tnskb = dev_alloc_skb(128);\n\t\t\tif (!nskb) {\n\t\t\t\t__free_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmemcpy(page_address(page), skb->data, skb->len);\n\t\t\tskb_add_rx_frag(nskb, 0, page, 0, skb->len, skb->len);\n\t\t} else {\n\t\t\tnskb = skb_copy(skb, GFP_ATOMIC);\n\t\t\tif (!nskb)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (mac80211_hwsim_addr_match(data2, hdr->addr1))\n\t\t\tack = true;\n\n\t\trx_status.mactime = now + data2->tsf_offset;\n\n\t\tmac80211_hwsim_rx(data2, &rx_status, nskb);\n\t}\n\tspin_unlock(&hwsim_radio_lock);\n\n\treturn ack;\n}\n\nstatic struct ieee80211_bss_conf *\nmac80211_hwsim_select_tx_link(struct mac80211_hwsim_data *data,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_sta *sta,\n\t\t\t      struct ieee80211_hdr *hdr,\n\t\t\t      struct ieee80211_link_sta **link_sta)\n{\n\tstruct hwsim_sta_priv *sp = (void *)sta->drv_priv;\n\tint i;\n\n\tif (!ieee80211_vif_is_mld(vif))\n\t\treturn &vif->bss_conf;\n\n\tWARN_ON(is_multicast_ether_addr(hdr->addr1));\n\n\tif (WARN_ON_ONCE(!sta || !sta->valid_links))\n\t\treturn &vif->bss_conf;\n\n\tfor (i = 0; i < ARRAY_SIZE(vif->link_conf); i++) {\n\t\tstruct ieee80211_bss_conf *bss_conf;\n\t\tunsigned int link_id;\n\n\t\t \n\t\tlink_id = (sp->last_link + i + 1) % ARRAY_SIZE(vif->link_conf);\n\n\t\tif (!(vif->active_links & BIT(link_id)))\n\t\t\tcontinue;\n\n\t\tif (!(sp->active_links_rx & BIT(link_id)))\n\t\t\tcontinue;\n\n\t\t*link_sta = rcu_dereference(sta->link[link_id]);\n\t\tif (!*link_sta)\n\t\t\tcontinue;\n\n\t\tbss_conf = rcu_dereference(vif->link_conf[link_id]);\n\t\tif (WARN_ON_ONCE(!bss_conf))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!rcu_access_pointer(bss_conf->chanctx_conf))\n\t\t\tcontinue;\n\n\t\tsp->last_link = link_id;\n\t\treturn bss_conf;\n\t}\n\n\treturn NULL;\n}\n\nstatic void mac80211_hwsim_tx(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_tx_control *control,\n\t\t\t      struct sk_buff *skb)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tstruct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_channel *channel;\n\tbool ack;\n\tenum nl80211_chan_width confbw = NL80211_CHAN_WIDTH_20_NOHT;\n\tu32 _portid, i;\n\n\tif (WARN_ON(skb->len < 10)) {\n\t\t \n\t\tieee80211_free_txskb(hw, skb);\n\t\treturn;\n\t}\n\n\tif (!data->use_chanctx) {\n\t\tchannel = data->channel;\n\t\tconfbw = data->bw;\n\t} else if (txi->hw_queue == 4) {\n\t\tchannel = data->tmp_chan;\n\t} else {\n\t\tu8 link = u32_get_bits(IEEE80211_SKB_CB(skb)->control.flags,\n\t\t\t\t       IEEE80211_TX_CTRL_MLO_LINK);\n\t\tstruct ieee80211_vif *vif = txi->control.vif;\n\t\tstruct ieee80211_link_sta *link_sta = NULL;\n\t\tstruct ieee80211_sta *sta = control->sta;\n\t\tstruct ieee80211_bss_conf *bss_conf;\n\n\t\tif (link != IEEE80211_LINK_UNSPECIFIED) {\n\t\t\tbss_conf = rcu_dereference(txi->control.vif->link_conf[link]);\n\t\t\tif (sta)\n\t\t\t\tlink_sta = rcu_dereference(sta->link[link]);\n\t\t} else {\n\t\t\tbss_conf = mac80211_hwsim_select_tx_link(data, vif, sta,\n\t\t\t\t\t\t\t\t hdr, &link_sta);\n\t\t}\n\n\t\tif (unlikely(!bss_conf)) {\n\t\t\t \n\t\t\tWARN(link != IEEE80211_LINK_UNSPECIFIED || !sta || !sta->mlo,\n\t\t\t     \"link:%d, sta:%pM, sta->mlo:%d\\n\",\n\t\t\t     link, sta ? sta->addr : NULL, sta ? sta->mlo : -1);\n\t\t\tieee80211_free_txskb(hw, skb);\n\t\t\treturn;\n\t\t}\n\n\t\tif (sta && sta->mlo) {\n\t\t\tif (WARN_ON(!link_sta)) {\n\t\t\t\tieee80211_free_txskb(hw, skb);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t \n\t\t\tether_addr_copy(hdr->addr1, link_sta->addr);\n\t\t\tether_addr_copy(hdr->addr2, bss_conf->addr);\n\t\t\t \n\t\t\tif (!ieee80211_has_tods(hdr->frame_control) &&\n\t\t\t    !ieee80211_has_fromds(hdr->frame_control)) {\n\t\t\t\tif (ether_addr_equal(hdr->addr3, sta->addr))\n\t\t\t\t\tether_addr_copy(hdr->addr3, link_sta->addr);\n\t\t\t\telse if (ether_addr_equal(hdr->addr3, vif->addr))\n\t\t\t\t\tether_addr_copy(hdr->addr3, bss_conf->addr);\n\t\t\t}\n\t\t\t \n\t\t}\n\n\t\tchanctx_conf = rcu_dereference(bss_conf->chanctx_conf);\n\t\tif (chanctx_conf) {\n\t\t\tchannel = chanctx_conf->def.chan;\n\t\t\tconfbw = chanctx_conf->def.width;\n\t\t} else {\n\t\t\tchannel = NULL;\n\t\t}\n\t}\n\n\tif (WARN(!channel, \"TX w/o channel - queue = %d\\n\", txi->hw_queue)) {\n\t\tieee80211_free_txskb(hw, skb);\n\t\treturn;\n\t}\n\n\tif (data->idle && !data->tmp_chan) {\n\t\twiphy_dbg(hw->wiphy, \"Trying to TX when idle - reject\\n\");\n\t\tieee80211_free_txskb(hw, skb);\n\t\treturn;\n\t}\n\n\tif (txi->control.vif)\n\t\thwsim_check_magic(txi->control.vif);\n\tif (control->sta)\n\t\thwsim_check_sta_magic(control->sta);\n\n\tif (ieee80211_hw_check(hw, SUPPORTS_RC_TABLE))\n\t\tieee80211_get_tx_rates(txi->control.vif, control->sta, skb,\n\t\t\t\t       txi->control.rates,\n\t\t\t\t       ARRAY_SIZE(txi->control.rates));\n\n\tfor (i = 0; i < ARRAY_SIZE(txi->control.rates); i++) {\n\t\tu16 rflags = txi->control.rates[i].flags;\n\t\t \n\t\tenum nl80211_chan_width bw = data->bw;\n\n\t\tif (txi->control.rates[i].idx == -1)\n\t\t\tbreak;\n\n\t\tif (rflags & IEEE80211_TX_RC_40_MHZ_WIDTH)\n\t\t\tbw = NL80211_CHAN_WIDTH_40;\n\t\telse if (rflags & IEEE80211_TX_RC_80_MHZ_WIDTH)\n\t\t\tbw = NL80211_CHAN_WIDTH_80;\n\t\telse if (rflags & IEEE80211_TX_RC_160_MHZ_WIDTH)\n\t\t\tbw = NL80211_CHAN_WIDTH_160;\n\n\t\tif (WARN_ON(hwsim_get_chanwidth(bw) > hwsim_get_chanwidth(confbw)))\n\t\t\treturn;\n\t}\n\n\tif (skb->len >= 24 + 8 &&\n\t    ieee80211_is_probe_resp(hdr->frame_control)) {\n\t\t \n\t\tstruct ieee80211_mgmt *mgmt;\n\t\tstruct ieee80211_rate *txrate;\n\t\t \n\t\tint bitrate = 100;\n\t\tu64 ts;\n\n\t\tmgmt = (struct ieee80211_mgmt *)skb->data;\n\t\ttxrate = ieee80211_get_tx_rate(hw, txi);\n\t\tif (txrate)\n\t\t\tbitrate = txrate->bitrate;\n\t\tts = mac80211_hwsim_get_tsf_raw();\n\t\tmgmt->u.probe_resp.timestamp =\n\t\t\tcpu_to_le64(ts + data->tsf_offset +\n\t\t\t\t    24 * 8 * 10 / bitrate);\n\t}\n\n\tmac80211_hwsim_monitor_rx(hw, skb, channel);\n\n\t \n\t_portid = READ_ONCE(data->wmediumd);\n\n\tif (_portid || hwsim_virtio_enabled)\n\t\treturn mac80211_hwsim_tx_frame_nl(hw, skb, _portid, channel);\n\n\t \n\tdata->tx_pkts++;\n\tdata->tx_bytes += skb->len;\n\tack = mac80211_hwsim_tx_frame_no_nl(hw, skb, channel);\n\n\tif (ack && skb->len >= 16)\n\t\tmac80211_hwsim_monitor_ack(channel, hdr->addr2);\n\n\tieee80211_tx_info_clear_status(txi);\n\n\t \n\ttxi->control.rates[0].count = 1;\n\ttxi->control.rates[1].idx = -1;\n\n\tif (!(txi->flags & IEEE80211_TX_CTL_NO_ACK) && ack)\n\t\ttxi->flags |= IEEE80211_TX_STAT_ACK;\n\tieee80211_tx_status_irqsafe(hw, skb);\n}\n\n\nstatic int mac80211_hwsim_start(struct ieee80211_hw *hw)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\twiphy_dbg(hw->wiphy, \"%s\\n\", __func__);\n\tdata->started = true;\n\treturn 0;\n}\n\n\nstatic void mac80211_hwsim_stop(struct ieee80211_hw *hw)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tint i;\n\n\tdata->started = false;\n\n\tfor (i = 0; i < ARRAY_SIZE(data->link_data); i++)\n\t\thrtimer_cancel(&data->link_data[i].beacon_timer);\n\n\twhile (!skb_queue_empty(&data->pending))\n\t\tieee80211_free_txskb(hw, skb_dequeue(&data->pending));\n\n\twiphy_dbg(hw->wiphy, \"%s\\n\", __func__);\n}\n\n\nstatic int mac80211_hwsim_add_interface(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif)\n{\n\twiphy_dbg(hw->wiphy, \"%s (type=%d mac_addr=%pM)\\n\",\n\t\t  __func__, ieee80211_vif_type_p2p(vif),\n\t\t  vif->addr);\n\thwsim_set_magic(vif);\n\n\tif (vif->type != NL80211_IFTYPE_MONITOR)\n\t\tmac80211_hwsim_config_mac_nl(hw, vif->addr, true);\n\n\tvif->cab_queue = 0;\n\tvif->hw_queue[IEEE80211_AC_VO] = 0;\n\tvif->hw_queue[IEEE80211_AC_VI] = 1;\n\tvif->hw_queue[IEEE80211_AC_BE] = 2;\n\tvif->hw_queue[IEEE80211_AC_BK] = 3;\n\n\treturn 0;\n}\n\n\nstatic int mac80211_hwsim_change_interface(struct ieee80211_hw *hw,\n\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t   enum nl80211_iftype newtype,\n\t\t\t\t\t   bool newp2p)\n{\n\tnewtype = ieee80211_iftype_p2p(newtype, newp2p);\n\twiphy_dbg(hw->wiphy,\n\t\t  \"%s (old type=%d, new type=%d, mac_addr=%pM)\\n\",\n\t\t  __func__, ieee80211_vif_type_p2p(vif),\n\t\t    newtype, vif->addr);\n\thwsim_check_magic(vif);\n\n\t \n\tvif->cab_queue = 0;\n\n\treturn 0;\n}\n\nstatic void mac80211_hwsim_remove_interface(\n\tstruct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\twiphy_dbg(hw->wiphy, \"%s (type=%d mac_addr=%pM)\\n\",\n\t\t  __func__, ieee80211_vif_type_p2p(vif),\n\t\t  vif->addr);\n\thwsim_check_magic(vif);\n\thwsim_clear_magic(vif);\n\tif (vif->type != NL80211_IFTYPE_MONITOR)\n\t\tmac80211_hwsim_config_mac_nl(hw, vif->addr, false);\n}\n\nstatic void mac80211_hwsim_tx_frame(struct ieee80211_hw *hw,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    struct ieee80211_channel *chan)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tu32 _portid = READ_ONCE(data->wmediumd);\n\n\tif (ieee80211_hw_check(hw, SUPPORTS_RC_TABLE)) {\n\t\tstruct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);\n\t\tieee80211_get_tx_rates(txi->control.vif, NULL, skb,\n\t\t\t\t       txi->control.rates,\n\t\t\t\t       ARRAY_SIZE(txi->control.rates));\n\t}\n\n\tmac80211_hwsim_monitor_rx(hw, skb, chan);\n\n\tif (_portid || hwsim_virtio_enabled)\n\t\treturn mac80211_hwsim_tx_frame_nl(hw, skb, _portid, chan);\n\n\tdata->tx_pkts++;\n\tdata->tx_bytes += skb->len;\n\tmac80211_hwsim_tx_frame_no_nl(hw, skb, chan);\n\tdev_kfree_skb(skb);\n}\n\nstatic void __mac80211_hwsim_beacon_tx(struct ieee80211_bss_conf *link_conf,\n\t\t\t\t       struct mac80211_hwsim_data *data,\n\t\t\t\t       struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_rate *txrate;\n\tstruct ieee80211_mgmt *mgmt;\n\t \n\tint bitrate = 100;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tif (ieee80211_hw_check(hw, SUPPORTS_RC_TABLE))\n\t\tieee80211_get_tx_rates(vif, NULL, skb,\n\t\t\t\t       info->control.rates,\n\t\t\t\t       ARRAY_SIZE(info->control.rates));\n\n\ttxrate = ieee80211_get_tx_rate(hw, info);\n\tif (txrate)\n\t\tbitrate = txrate->bitrate;\n\n\tmgmt = (struct ieee80211_mgmt *) skb->data;\n\t \n\tdata->abs_bcn_ts = mac80211_hwsim_get_tsf_raw();\n\tif (ieee80211_is_s1g_beacon(mgmt->frame_control)) {\n\t\tstruct ieee80211_ext *ext = (void *) mgmt;\n\n\t\text->u.s1g_beacon.timestamp = cpu_to_le32(data->abs_bcn_ts +\n\t\t\t\t\t\t\t  data->tsf_offset +\n\t\t\t\t\t\t\t  10 * 8 * 10 /\n\t\t\t\t\t\t\t  bitrate);\n\t} else {\n\t\tmgmt->u.beacon.timestamp = cpu_to_le64(data->abs_bcn_ts +\n\t\t\t\t\t\t       data->tsf_offset +\n\t\t\t\t\t\t       24 * 8 * 10 /\n\t\t\t\t\t\t       bitrate);\n\t}\n\n\tmac80211_hwsim_tx_frame(hw, skb,\n\t\t\trcu_dereference(link_conf->chanctx_conf)->def.chan);\n}\n\nstatic void mac80211_hwsim_beacon_tx(void *arg, u8 *mac,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct mac80211_hwsim_link_data *link_data = arg;\n\tu32 link_id = link_data->link_id;\n\tstruct ieee80211_bss_conf *link_conf;\n\tstruct mac80211_hwsim_data *data =\n\t\tcontainer_of(link_data, struct mac80211_hwsim_data,\n\t\t\t     link_data[link_id]);\n\tstruct ieee80211_hw *hw = data->hw;\n\tstruct sk_buff *skb;\n\n\thwsim_check_magic(vif);\n\n\tlink_conf = rcu_dereference(vif->link_conf[link_id]);\n\tif (!link_conf)\n\t\treturn;\n\n\tif (vif->type != NL80211_IFTYPE_AP &&\n\t    vif->type != NL80211_IFTYPE_MESH_POINT &&\n\t    vif->type != NL80211_IFTYPE_ADHOC &&\n\t    vif->type != NL80211_IFTYPE_OCB)\n\t\treturn;\n\n\tif (vif->mbssid_tx_vif && vif->mbssid_tx_vif != vif)\n\t\treturn;\n\n\tif (vif->bss_conf.ema_ap) {\n\t\tstruct ieee80211_ema_beacons *ema;\n\t\tu8 i = 0;\n\n\t\tema = ieee80211_beacon_get_template_ema_list(hw, vif, link_id);\n\t\tif (!ema || !ema->cnt)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < ema->cnt; i++) {\n\t\t\t__mac80211_hwsim_beacon_tx(link_conf, data, hw, vif,\n\t\t\t\t\t\t   ema->bcn[i].skb);\n\t\t\tema->bcn[i].skb = NULL;  \n\t\t}\n\t\tieee80211_beacon_free_ema_list(ema);\n\t} else {\n\t\tskb = ieee80211_beacon_get(hw, vif, link_id);\n\t\tif (!skb)\n\t\t\treturn;\n\n\t\t__mac80211_hwsim_beacon_tx(link_conf, data, hw, vif, skb);\n\t}\n\n\twhile ((skb = ieee80211_get_buffered_bc(hw, vif)) != NULL) {\n\t\tmac80211_hwsim_tx_frame(hw, skb,\n\t\t\trcu_dereference(link_conf->chanctx_conf)->def.chan);\n\t}\n\n\tif (link_conf->csa_active && ieee80211_beacon_cntdwn_is_complete(vif))\n\t\tieee80211_csa_finish(vif);\n}\n\nstatic enum hrtimer_restart\nmac80211_hwsim_beacon(struct hrtimer *timer)\n{\n\tstruct mac80211_hwsim_link_data *link_data =\n\t\tcontainer_of(timer, struct mac80211_hwsim_link_data, beacon_timer);\n\tstruct mac80211_hwsim_data *data =\n\t\tcontainer_of(link_data, struct mac80211_hwsim_data,\n\t\t\t     link_data[link_data->link_id]);\n\tstruct ieee80211_hw *hw = data->hw;\n\tu64 bcn_int = link_data->beacon_int;\n\n\tif (!data->started)\n\t\treturn HRTIMER_NORESTART;\n\n\tieee80211_iterate_active_interfaces_atomic(\n\t\thw, IEEE80211_IFACE_ITER_NORMAL,\n\t\tmac80211_hwsim_beacon_tx, link_data);\n\n\t \n\tif (data->bcn_delta) {\n\t\tbcn_int -= data->bcn_delta;\n\t\tdata->bcn_delta = 0;\n\t}\n\thrtimer_forward_now(&link_data->beacon_timer,\n\t\t\t    ns_to_ktime(bcn_int * NSEC_PER_USEC));\n\treturn HRTIMER_RESTART;\n}\n\nstatic const char * const hwsim_chanwidths[] = {\n\t[NL80211_CHAN_WIDTH_5] = \"ht5\",\n\t[NL80211_CHAN_WIDTH_10] = \"ht10\",\n\t[NL80211_CHAN_WIDTH_20_NOHT] = \"noht\",\n\t[NL80211_CHAN_WIDTH_20] = \"ht20\",\n\t[NL80211_CHAN_WIDTH_40] = \"ht40\",\n\t[NL80211_CHAN_WIDTH_80] = \"vht80\",\n\t[NL80211_CHAN_WIDTH_80P80] = \"vht80p80\",\n\t[NL80211_CHAN_WIDTH_160] = \"vht160\",\n\t[NL80211_CHAN_WIDTH_1] = \"1MHz\",\n\t[NL80211_CHAN_WIDTH_2] = \"2MHz\",\n\t[NL80211_CHAN_WIDTH_4] = \"4MHz\",\n\t[NL80211_CHAN_WIDTH_8] = \"8MHz\",\n\t[NL80211_CHAN_WIDTH_16] = \"16MHz\",\n};\n\nstatic int mac80211_hwsim_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tstatic const char *smps_modes[IEEE80211_SMPS_NUM_MODES] = {\n\t\t[IEEE80211_SMPS_AUTOMATIC] = \"auto\",\n\t\t[IEEE80211_SMPS_OFF] = \"off\",\n\t\t[IEEE80211_SMPS_STATIC] = \"static\",\n\t\t[IEEE80211_SMPS_DYNAMIC] = \"dynamic\",\n\t};\n\tint idx;\n\n\tif (conf->chandef.chan)\n\t\twiphy_dbg(hw->wiphy,\n\t\t\t  \"%s (freq=%d(%d - %d)/%s idle=%d ps=%d smps=%s)\\n\",\n\t\t\t  __func__,\n\t\t\t  conf->chandef.chan->center_freq,\n\t\t\t  conf->chandef.center_freq1,\n\t\t\t  conf->chandef.center_freq2,\n\t\t\t  hwsim_chanwidths[conf->chandef.width],\n\t\t\t  !!(conf->flags & IEEE80211_CONF_IDLE),\n\t\t\t  !!(conf->flags & IEEE80211_CONF_PS),\n\t\t\t  smps_modes[conf->smps_mode]);\n\telse\n\t\twiphy_dbg(hw->wiphy,\n\t\t\t  \"%s (freq=0 idle=%d ps=%d smps=%s)\\n\",\n\t\t\t  __func__,\n\t\t\t  !!(conf->flags & IEEE80211_CONF_IDLE),\n\t\t\t  !!(conf->flags & IEEE80211_CONF_PS),\n\t\t\t  smps_modes[conf->smps_mode]);\n\n\tdata->idle = !!(conf->flags & IEEE80211_CONF_IDLE);\n\n\tWARN_ON(conf->chandef.chan && data->use_chanctx);\n\n\tmutex_lock(&data->mutex);\n\tif (data->scanning && conf->chandef.chan) {\n\t\tfor (idx = 0; idx < ARRAY_SIZE(data->survey_data); idx++) {\n\t\t\tif (data->survey_data[idx].channel == data->channel) {\n\t\t\t\tdata->survey_data[idx].start =\n\t\t\t\t\tdata->survey_data[idx].next_start;\n\t\t\t\tdata->survey_data[idx].end = jiffies;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdata->channel = conf->chandef.chan;\n\t\tdata->bw = conf->chandef.width;\n\n\t\tfor (idx = 0; idx < ARRAY_SIZE(data->survey_data); idx++) {\n\t\t\tif (data->survey_data[idx].channel &&\n\t\t\t    data->survey_data[idx].channel != data->channel)\n\t\t\t\tcontinue;\n\t\t\tdata->survey_data[idx].channel = data->channel;\n\t\t\tdata->survey_data[idx].next_start = jiffies;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tdata->channel = conf->chandef.chan;\n\t\tdata->bw = conf->chandef.width;\n\t}\n\tmutex_unlock(&data->mutex);\n\n\tfor (idx = 0; idx < ARRAY_SIZE(data->link_data); idx++) {\n\t\tstruct mac80211_hwsim_link_data *link_data =\n\t\t\t&data->link_data[idx];\n\n\t\tif (!data->started || !link_data->beacon_int) {\n\t\t\thrtimer_cancel(&link_data->beacon_timer);\n\t\t} else if (!hrtimer_is_queued(&link_data->beacon_timer)) {\n\t\t\tu64 tsf = mac80211_hwsim_get_tsf(hw, NULL);\n\t\t\tu32 bcn_int = link_data->beacon_int;\n\t\t\tu64 until_tbtt = bcn_int - do_div(tsf, bcn_int);\n\n\t\t\thrtimer_start(&link_data->beacon_timer,\n\t\t\t\t      ns_to_ktime(until_tbtt * NSEC_PER_USEC),\n\t\t\t\t      HRTIMER_MODE_REL_SOFT);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nstatic void mac80211_hwsim_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t\t    unsigned int changed_flags,\n\t\t\t\t\t    unsigned int *total_flags,u64 multicast)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\n\twiphy_dbg(hw->wiphy, \"%s\\n\", __func__);\n\n\tdata->rx_filter = 0;\n\tif (*total_flags & FIF_ALLMULTI)\n\t\tdata->rx_filter |= FIF_ALLMULTI;\n\tif (*total_flags & FIF_MCAST_ACTION)\n\t\tdata->rx_filter |= FIF_MCAST_ACTION;\n\n\t*total_flags = data->rx_filter;\n}\n\nstatic void mac80211_hwsim_bcn_en_iter(void *data, u8 *mac,\n\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tunsigned int *count = data;\n\tstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\n\n\tif (vp->bcn_en)\n\t\t(*count)++;\n}\n\nstatic void mac80211_hwsim_vif_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t\t    u64 changed)\n{\n\tstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\n\n\thwsim_check_magic(vif);\n\n\twiphy_dbg(hw->wiphy, \"%s(changed=0x%llx vif->addr=%pM)\\n\",\n\t\t  __func__, changed, vif->addr);\n\n\tif (changed & BSS_CHANGED_ASSOC) {\n\t\twiphy_dbg(hw->wiphy, \"  ASSOC: assoc=%d aid=%d\\n\",\n\t\t\t  vif->cfg.assoc, vif->cfg.aid);\n\t\tvp->assoc = vif->cfg.assoc;\n\t\tvp->aid = vif->cfg.aid;\n\t}\n}\n\nstatic void mac80211_hwsim_link_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t\t     struct ieee80211_bss_conf *info,\n\t\t\t\t\t     u64 changed)\n{\n\tstruct hwsim_vif_priv *vp = (void *)vif->drv_priv;\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tunsigned int link_id = info->link_id;\n\tstruct mac80211_hwsim_link_data *link_data = &data->link_data[link_id];\n\n\thwsim_check_magic(vif);\n\n\twiphy_dbg(hw->wiphy, \"%s(changed=0x%llx vif->addr=%pM, link id %u)\\n\",\n\t\t  __func__, (unsigned long long)changed, vif->addr, link_id);\n\n\tif (changed & BSS_CHANGED_BSSID) {\n\t\twiphy_dbg(hw->wiphy, \"%s: BSSID changed: %pM\\n\",\n\t\t\t  __func__, info->bssid);\n\t\tmemcpy(vp->bssid, info->bssid, ETH_ALEN);\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON_ENABLED) {\n\t\twiphy_dbg(hw->wiphy, \"  BCN EN: %d (BI=%u)\\n\",\n\t\t\t  info->enable_beacon, info->beacon_int);\n\t\tvp->bcn_en = info->enable_beacon;\n\t\tif (data->started &&\n\t\t    !hrtimer_is_queued(&link_data->beacon_timer) &&\n\t\t    info->enable_beacon) {\n\t\t\tu64 tsf, until_tbtt;\n\t\t\tu32 bcn_int;\n\t\t\tlink_data->beacon_int = info->beacon_int * 1024;\n\t\t\ttsf = mac80211_hwsim_get_tsf(hw, vif);\n\t\t\tbcn_int = link_data->beacon_int;\n\t\t\tuntil_tbtt = bcn_int - do_div(tsf, bcn_int);\n\n\t\t\thrtimer_start(&link_data->beacon_timer,\n\t\t\t\t      ns_to_ktime(until_tbtt * NSEC_PER_USEC),\n\t\t\t\t      HRTIMER_MODE_REL_SOFT);\n\t\t} else if (!info->enable_beacon) {\n\t\t\tunsigned int count = 0;\n\t\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\t\tdata->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\tmac80211_hwsim_bcn_en_iter, &count);\n\t\t\twiphy_dbg(hw->wiphy, \"  beaconing vifs remaining: %u\",\n\t\t\t\t  count);\n\t\t\tif (count == 0) {\n\t\t\t\thrtimer_cancel(&link_data->beacon_timer);\n\t\t\t\tlink_data->beacon_int = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_CTS_PROT) {\n\t\twiphy_dbg(hw->wiphy, \"  ERP_CTS_PROT: %d\\n\",\n\t\t\t  info->use_cts_prot);\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_PREAMBLE) {\n\t\twiphy_dbg(hw->wiphy, \"  ERP_PREAMBLE: %d\\n\",\n\t\t\t  info->use_short_preamble);\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\twiphy_dbg(hw->wiphy, \"  ERP_SLOT: %d\\n\", info->use_short_slot);\n\t}\n\n\tif (changed & BSS_CHANGED_HT) {\n\t\twiphy_dbg(hw->wiphy, \"  HT: op_mode=0x%x\\n\",\n\t\t\t  info->ht_operation_mode);\n\t}\n\n\tif (changed & BSS_CHANGED_BASIC_RATES) {\n\t\twiphy_dbg(hw->wiphy, \"  BASIC_RATES: 0x%llx\\n\",\n\t\t\t  (unsigned long long) info->basic_rates);\n\t}\n\n\tif (changed & BSS_CHANGED_TXPOWER)\n\t\twiphy_dbg(hw->wiphy, \"  TX Power: %d dBm\\n\", info->txpower);\n}\n\nstatic void\nmac80211_hwsim_sta_rc_update(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_sta *sta,\n\t\t\t     u32 changed)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tu32 bw = U32_MAX;\n\tint link_id;\n\n\trcu_read_lock();\n\tfor (link_id = 0;\n\t     link_id < ARRAY_SIZE(vif->link_conf);\n\t     link_id++) {\n\t\tenum nl80211_chan_width confbw = NL80211_CHAN_WIDTH_20_NOHT;\n\t\tstruct ieee80211_bss_conf *vif_conf;\n\t\tstruct ieee80211_link_sta *link_sta;\n\n\t\tlink_sta = rcu_dereference(sta->link[link_id]);\n\n\t\tif (!link_sta)\n\t\t\tcontinue;\n\n\t\tswitch (link_sta->bandwidth) {\n#define C(_bw) case IEEE80211_STA_RX_BW_##_bw: bw = _bw; break\n\t\tC(20);\n\t\tC(40);\n\t\tC(80);\n\t\tC(160);\n\t\tC(320);\n#undef C\n\t\t}\n\n\t\tif (!data->use_chanctx) {\n\t\t\tconfbw = data->bw;\n\t\t} else {\n\t\t\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\n\t\t\tvif_conf = rcu_dereference(vif->link_conf[link_id]);\n\t\t\tif (WARN_ON(!vif_conf))\n\t\t\t\tcontinue;\n\n\t\t\tchanctx_conf = rcu_dereference(vif_conf->chanctx_conf);\n\n\t\t\tif (!WARN_ON(!chanctx_conf))\n\t\t\t\tconfbw = chanctx_conf->def.width;\n\t\t}\n\n\t\tWARN(bw > hwsim_get_chanwidth(confbw),\n\t\t     \"intf %pM [link=%d]: bad STA %pM bandwidth %d MHz (%d) > channel config %d MHz (%d)\\n\",\n\t\t     vif->addr, link_id, sta->addr, bw, sta->deflink.bandwidth,\n\t\t     hwsim_get_chanwidth(data->bw), data->bw);\n\n\n\t}\n\trcu_read_unlock();\n\n\n}\n\nstatic int mac80211_hwsim_sta_add(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_sta *sta)\n{\n\tstruct hwsim_sta_priv *sp = (void *)sta->drv_priv;\n\n\thwsim_check_magic(vif);\n\thwsim_set_sta_magic(sta);\n\tmac80211_hwsim_sta_rc_update(hw, vif, sta, 0);\n\n\tif (sta->valid_links) {\n\t\tWARN(hweight16(sta->valid_links) > 1,\n\t\t     \"expect to add STA with single link, have 0x%x\\n\",\n\t\t     sta->valid_links);\n\t\tsp->active_links_rx = sta->valid_links;\n\t}\n\n\treturn 0;\n}\n\nstatic int mac80211_hwsim_sta_remove(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_sta *sta)\n{\n\thwsim_check_magic(vif);\n\thwsim_clear_sta_magic(sta);\n\n\treturn 0;\n}\n\nstatic int mac80211_hwsim_sta_state(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_sta *sta,\n\t\t\t\t    enum ieee80211_sta_state old_state,\n\t\t\t\t    enum ieee80211_sta_state new_state)\n{\n\tif (new_state == IEEE80211_STA_NOTEXIST)\n\t\treturn mac80211_hwsim_sta_remove(hw, vif, sta);\n\n\tif (old_state == IEEE80211_STA_NOTEXIST)\n\t\treturn mac80211_hwsim_sta_add(hw, vif, sta);\n\n\t \n\tif (vif->type == NL80211_IFTYPE_STATION &&\n\t    new_state == IEEE80211_STA_AUTHORIZED && !sta->tdls)\n\t\tieee80211_set_active_links_async(vif,\n\t\t\t\t\t\t ieee80211_vif_usable_links(vif));\n\n\treturn 0;\n}\n\nstatic void mac80211_hwsim_sta_notify(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      enum sta_notify_cmd cmd,\n\t\t\t\t      struct ieee80211_sta *sta)\n{\n\thwsim_check_magic(vif);\n\n\tswitch (cmd) {\n\tcase STA_NOTIFY_SLEEP:\n\tcase STA_NOTIFY_AWAKE:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Invalid sta notify: %d\\n\", cmd);\n\t\tbreak;\n\t}\n}\n\nstatic int mac80211_hwsim_set_tim(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t  bool set)\n{\n\thwsim_check_sta_magic(sta);\n\treturn 0;\n}\n\nstatic int mac80211_hwsim_conf_tx(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  unsigned int link_id, u16 queue,\n\t\t\t\t  const struct ieee80211_tx_queue_params *params)\n{\n\twiphy_dbg(hw->wiphy,\n\t\t  \"%s (queue=%d txop=%d cw_min=%d cw_max=%d aifs=%d)\\n\",\n\t\t  __func__, queue,\n\t\t  params->txop, params->cw_min,\n\t\t  params->cw_max, params->aifs);\n\treturn 0;\n}\n\nstatic int mac80211_hwsim_get_survey(struct ieee80211_hw *hw, int idx,\n\t\t\t\t     struct survey_info *survey)\n{\n\tstruct mac80211_hwsim_data *hwsim = hw->priv;\n\n\tif (idx < 0 || idx >= ARRAY_SIZE(hwsim->survey_data))\n\t\treturn -ENOENT;\n\n\tmutex_lock(&hwsim->mutex);\n\tsurvey->channel = hwsim->survey_data[idx].channel;\n\tif (!survey->channel) {\n\t\tmutex_unlock(&hwsim->mutex);\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tsurvey->filled = SURVEY_INFO_NOISE_DBM |\n\t\t\t SURVEY_INFO_TIME |\n\t\t\t SURVEY_INFO_TIME_BUSY;\n\tsurvey->noise = -92;\n\tsurvey->time =\n\t\tjiffies_to_msecs(hwsim->survey_data[idx].end -\n\t\t\t\t hwsim->survey_data[idx].start);\n\t \n\tsurvey->time_busy = survey->time/8;\n\tmutex_unlock(&hwsim->mutex);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_NL80211_TESTMODE\n \n\n \nenum hwsim_testmode_attr {\n\t__HWSIM_TM_ATTR_INVALID\t= 0,\n\tHWSIM_TM_ATTR_CMD\t= 1,\n\tHWSIM_TM_ATTR_PS\t= 2,\n\n\t \n\t__HWSIM_TM_ATTR_AFTER_LAST,\n\tHWSIM_TM_ATTR_MAX\t= __HWSIM_TM_ATTR_AFTER_LAST - 1\n};\n\nenum hwsim_testmode_cmd {\n\tHWSIM_TM_CMD_SET_PS\t\t= 0,\n\tHWSIM_TM_CMD_GET_PS\t\t= 1,\n\tHWSIM_TM_CMD_STOP_QUEUES\t= 2,\n\tHWSIM_TM_CMD_WAKE_QUEUES\t= 3,\n};\n\nstatic const struct nla_policy hwsim_testmode_policy[HWSIM_TM_ATTR_MAX + 1] = {\n\t[HWSIM_TM_ATTR_CMD] = { .type = NLA_U32 },\n\t[HWSIM_TM_ATTR_PS] = { .type = NLA_U32 },\n};\n\nstatic int mac80211_hwsim_testmode_cmd(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       void *data, int len)\n{\n\tstruct mac80211_hwsim_data *hwsim = hw->priv;\n\tstruct nlattr *tb[HWSIM_TM_ATTR_MAX + 1];\n\tstruct sk_buff *skb;\n\tint err, ps;\n\n\terr = nla_parse_deprecated(tb, HWSIM_TM_ATTR_MAX, data, len,\n\t\t\t\t   hwsim_testmode_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[HWSIM_TM_ATTR_CMD])\n\t\treturn -EINVAL;\n\n\tswitch (nla_get_u32(tb[HWSIM_TM_ATTR_CMD])) {\n\tcase HWSIM_TM_CMD_SET_PS:\n\t\tif (!tb[HWSIM_TM_ATTR_PS])\n\t\t\treturn -EINVAL;\n\t\tps = nla_get_u32(tb[HWSIM_TM_ATTR_PS]);\n\t\treturn hwsim_fops_ps_write(hwsim, ps);\n\tcase HWSIM_TM_CMD_GET_PS:\n\t\tskb = cfg80211_testmode_alloc_reply_skb(hw->wiphy,\n\t\t\t\t\t\tnla_total_size(sizeof(u32)));\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\t\tif (nla_put_u32(skb, HWSIM_TM_ATTR_PS, hwsim->ps))\n\t\t\tgoto nla_put_failure;\n\t\treturn cfg80211_testmode_reply(skb);\n\tcase HWSIM_TM_CMD_STOP_QUEUES:\n\t\tieee80211_stop_queues(hw);\n\t\treturn 0;\n\tcase HWSIM_TM_CMD_WAKE_QUEUES:\n\t\tieee80211_wake_queues(hw);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n nla_put_failure:\n\tkfree_skb(skb);\n\treturn -ENOBUFS;\n}\n#endif\n\nstatic int mac80211_hwsim_ampdu_action(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_ampdu_params *params)\n{\n\tstruct ieee80211_sta *sta = params->sta;\n\tenum ieee80211_ampdu_mlme_action action = params->action;\n\tu16 tid = params->tid;\n\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_TX_START:\n\t\treturn IEEE80211_AMPDU_TX_START_IMMEDIATE;\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\t\tieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_START:\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic void mac80211_hwsim_flush(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t u32 queues, bool drop)\n{\n\t \n}\n\nstatic void hw_scan_work(struct work_struct *work)\n{\n\tstruct mac80211_hwsim_data *hwsim =\n\t\tcontainer_of(work, struct mac80211_hwsim_data, hw_scan.work);\n\tstruct cfg80211_scan_request *req = hwsim->hw_scan_request;\n\tint dwell, i;\n\n\tmutex_lock(&hwsim->mutex);\n\tif (hwsim->scan_chan_idx >= req->n_channels) {\n\t\tstruct cfg80211_scan_info info = {\n\t\t\t.aborted = false,\n\t\t};\n\n\t\twiphy_dbg(hwsim->hw->wiphy, \"hw scan complete\\n\");\n\t\tieee80211_scan_completed(hwsim->hw, &info);\n\t\thwsim->hw_scan_request = NULL;\n\t\thwsim->hw_scan_vif = NULL;\n\t\thwsim->tmp_chan = NULL;\n\t\tmutex_unlock(&hwsim->mutex);\n\t\tmac80211_hwsim_config_mac_nl(hwsim->hw, hwsim->scan_addr,\n\t\t\t\t\t     false);\n\t\treturn;\n\t}\n\n\twiphy_dbg(hwsim->hw->wiphy, \"hw scan %d MHz\\n\",\n\t\t  req->channels[hwsim->scan_chan_idx]->center_freq);\n\n\thwsim->tmp_chan = req->channels[hwsim->scan_chan_idx];\n\tif (hwsim->tmp_chan->flags & (IEEE80211_CHAN_NO_IR |\n\t\t\t\t      IEEE80211_CHAN_RADAR) ||\n\t    !req->n_ssids) {\n\t\tdwell = 120;\n\t} else {\n\t\tdwell = 30;\n\t\t \n\t\tfor (i = 0; i < req->n_ssids; i++) {\n\t\t\tstruct sk_buff *probe;\n\t\t\tstruct ieee80211_mgmt *mgmt;\n\n\t\t\tprobe = ieee80211_probereq_get(hwsim->hw,\n\t\t\t\t\t\t       hwsim->scan_addr,\n\t\t\t\t\t\t       req->ssids[i].ssid,\n\t\t\t\t\t\t       req->ssids[i].ssid_len,\n\t\t\t\t\t\t       req->ie_len);\n\t\t\tif (!probe)\n\t\t\t\tcontinue;\n\n\t\t\tmgmt = (struct ieee80211_mgmt *) probe->data;\n\t\t\tmemcpy(mgmt->da, req->bssid, ETH_ALEN);\n\t\t\tmemcpy(mgmt->bssid, req->bssid, ETH_ALEN);\n\n\t\t\tif (req->ie_len)\n\t\t\t\tskb_put_data(probe, req->ie, req->ie_len);\n\n\t\t\trcu_read_lock();\n\t\t\tif (!ieee80211_tx_prepare_skb(hwsim->hw,\n\t\t\t\t\t\t      hwsim->hw_scan_vif,\n\t\t\t\t\t\t      probe,\n\t\t\t\t\t\t      hwsim->tmp_chan->band,\n\t\t\t\t\t\t      NULL)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tkfree_skb(probe);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlocal_bh_disable();\n\t\t\tmac80211_hwsim_tx_frame(hwsim->hw, probe,\n\t\t\t\t\t\thwsim->tmp_chan);\n\t\t\trcu_read_unlock();\n\t\t\tlocal_bh_enable();\n\t\t}\n\t}\n\tieee80211_queue_delayed_work(hwsim->hw, &hwsim->hw_scan,\n\t\t\t\t     msecs_to_jiffies(dwell));\n\thwsim->survey_data[hwsim->scan_chan_idx].channel = hwsim->tmp_chan;\n\thwsim->survey_data[hwsim->scan_chan_idx].start = jiffies;\n\thwsim->survey_data[hwsim->scan_chan_idx].end =\n\t\tjiffies + msecs_to_jiffies(dwell);\n\thwsim->scan_chan_idx++;\n\tmutex_unlock(&hwsim->mutex);\n}\n\nstatic int mac80211_hwsim_hw_scan(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_scan_request *hw_req)\n{\n\tstruct mac80211_hwsim_data *hwsim = hw->priv;\n\tstruct cfg80211_scan_request *req = &hw_req->req;\n\n\tmutex_lock(&hwsim->mutex);\n\tif (WARN_ON(hwsim->tmp_chan || hwsim->hw_scan_request)) {\n\t\tmutex_unlock(&hwsim->mutex);\n\t\treturn -EBUSY;\n\t}\n\thwsim->hw_scan_request = req;\n\thwsim->hw_scan_vif = vif;\n\thwsim->scan_chan_idx = 0;\n\tif (req->flags & NL80211_SCAN_FLAG_RANDOM_ADDR)\n\t\tget_random_mask_addr(hwsim->scan_addr,\n\t\t\t\t     hw_req->req.mac_addr,\n\t\t\t\t     hw_req->req.mac_addr_mask);\n\telse\n\t\tmemcpy(hwsim->scan_addr, vif->addr, ETH_ALEN);\n\tmemset(hwsim->survey_data, 0, sizeof(hwsim->survey_data));\n\tmutex_unlock(&hwsim->mutex);\n\n\tmac80211_hwsim_config_mac_nl(hw, hwsim->scan_addr, true);\n\twiphy_dbg(hw->wiphy, \"hwsim hw_scan request\\n\");\n\n\tieee80211_queue_delayed_work(hwsim->hw, &hwsim->hw_scan, 0);\n\n\treturn 0;\n}\n\nstatic void mac80211_hwsim_cancel_hw_scan(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct mac80211_hwsim_data *hwsim = hw->priv;\n\tstruct cfg80211_scan_info info = {\n\t\t.aborted = true,\n\t};\n\n\twiphy_dbg(hw->wiphy, \"hwsim cancel_hw_scan\\n\");\n\n\tcancel_delayed_work_sync(&hwsim->hw_scan);\n\n\tmutex_lock(&hwsim->mutex);\n\tieee80211_scan_completed(hwsim->hw, &info);\n\thwsim->tmp_chan = NULL;\n\thwsim->hw_scan_request = NULL;\n\thwsim->hw_scan_vif = NULL;\n\tmutex_unlock(&hwsim->mutex);\n}\n\nstatic void mac80211_hwsim_sw_scan(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   const u8 *mac_addr)\n{\n\tstruct mac80211_hwsim_data *hwsim = hw->priv;\n\n\tmutex_lock(&hwsim->mutex);\n\n\tif (hwsim->scanning) {\n\t\tpr_debug(\"two hwsim sw_scans detected!\\n\");\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"hwsim sw_scan request, prepping stuff\\n\");\n\n\tmemcpy(hwsim->scan_addr, mac_addr, ETH_ALEN);\n\tmac80211_hwsim_config_mac_nl(hw, hwsim->scan_addr, true);\n\thwsim->scanning = true;\n\tmemset(hwsim->survey_data, 0, sizeof(hwsim->survey_data));\n\nout:\n\tmutex_unlock(&hwsim->mutex);\n}\n\nstatic void mac80211_hwsim_sw_scan_complete(struct ieee80211_hw *hw,\n\t\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct mac80211_hwsim_data *hwsim = hw->priv;\n\n\tmutex_lock(&hwsim->mutex);\n\n\tpr_debug(\"hwsim sw_scan_complete\\n\");\n\thwsim->scanning = false;\n\tmac80211_hwsim_config_mac_nl(hw, hwsim->scan_addr, false);\n\teth_zero_addr(hwsim->scan_addr);\n\n\tmutex_unlock(&hwsim->mutex);\n}\n\nstatic void hw_roc_start(struct work_struct *work)\n{\n\tstruct mac80211_hwsim_data *hwsim =\n\t\tcontainer_of(work, struct mac80211_hwsim_data, roc_start.work);\n\n\tmutex_lock(&hwsim->mutex);\n\n\twiphy_dbg(hwsim->hw->wiphy, \"hwsim ROC begins\\n\");\n\thwsim->tmp_chan = hwsim->roc_chan;\n\tieee80211_ready_on_channel(hwsim->hw);\n\n\tieee80211_queue_delayed_work(hwsim->hw, &hwsim->roc_done,\n\t\t\t\t     msecs_to_jiffies(hwsim->roc_duration));\n\n\tmutex_unlock(&hwsim->mutex);\n}\n\nstatic void hw_roc_done(struct work_struct *work)\n{\n\tstruct mac80211_hwsim_data *hwsim =\n\t\tcontainer_of(work, struct mac80211_hwsim_data, roc_done.work);\n\n\tmutex_lock(&hwsim->mutex);\n\tieee80211_remain_on_channel_expired(hwsim->hw);\n\thwsim->tmp_chan = NULL;\n\tmutex_unlock(&hwsim->mutex);\n\n\twiphy_dbg(hwsim->hw->wiphy, \"hwsim ROC expired\\n\");\n}\n\nstatic int mac80211_hwsim_roc(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_channel *chan,\n\t\t\t      int duration,\n\t\t\t      enum ieee80211_roc_type type)\n{\n\tstruct mac80211_hwsim_data *hwsim = hw->priv;\n\n\tmutex_lock(&hwsim->mutex);\n\tif (WARN_ON(hwsim->tmp_chan || hwsim->hw_scan_request)) {\n\t\tmutex_unlock(&hwsim->mutex);\n\t\treturn -EBUSY;\n\t}\n\n\thwsim->roc_chan = chan;\n\thwsim->roc_duration = duration;\n\tmutex_unlock(&hwsim->mutex);\n\n\twiphy_dbg(hw->wiphy, \"hwsim ROC (%d MHz, %d ms)\\n\",\n\t\t  chan->center_freq, duration);\n\tieee80211_queue_delayed_work(hw, &hwsim->roc_start, HZ/50);\n\n\treturn 0;\n}\n\nstatic int mac80211_hwsim_croc(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif)\n{\n\tstruct mac80211_hwsim_data *hwsim = hw->priv;\n\n\tcancel_delayed_work_sync(&hwsim->roc_start);\n\tcancel_delayed_work_sync(&hwsim->roc_done);\n\n\tmutex_lock(&hwsim->mutex);\n\thwsim->tmp_chan = NULL;\n\tmutex_unlock(&hwsim->mutex);\n\n\twiphy_dbg(hw->wiphy, \"hwsim ROC canceled\\n\");\n\n\treturn 0;\n}\n\nstatic int mac80211_hwsim_add_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_chanctx_conf *ctx)\n{\n\thwsim_set_chanctx_magic(ctx);\n\twiphy_dbg(hw->wiphy,\n\t\t  \"add channel context control: %d MHz/width: %d/cfreqs:%d/%d MHz\\n\",\n\t\t  ctx->def.chan->center_freq, ctx->def.width,\n\t\t  ctx->def.center_freq1, ctx->def.center_freq2);\n\treturn 0;\n}\n\nstatic void mac80211_hwsim_remove_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_chanctx_conf *ctx)\n{\n\twiphy_dbg(hw->wiphy,\n\t\t  \"remove channel context control: %d MHz/width: %d/cfreqs:%d/%d MHz\\n\",\n\t\t  ctx->def.chan->center_freq, ctx->def.width,\n\t\t  ctx->def.center_freq1, ctx->def.center_freq2);\n\thwsim_check_chanctx_magic(ctx);\n\thwsim_clear_chanctx_magic(ctx);\n}\n\nstatic void mac80211_hwsim_change_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_chanctx_conf *ctx,\n\t\t\t\t\t  u32 changed)\n{\n\thwsim_check_chanctx_magic(ctx);\n\twiphy_dbg(hw->wiphy,\n\t\t  \"change channel context control: %d MHz/width: %d/cfreqs:%d/%d MHz\\n\",\n\t\t  ctx->def.chan->center_freq, ctx->def.width,\n\t\t  ctx->def.center_freq1, ctx->def.center_freq2);\n}\n\nstatic int mac80211_hwsim_assign_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t\t     struct ieee80211_bss_conf *link_conf,\n\t\t\t\t\t     struct ieee80211_chanctx_conf *ctx)\n{\n\thwsim_check_magic(vif);\n\thwsim_check_chanctx_magic(ctx);\n\n\t \n\tif (vif->type == NL80211_IFTYPE_STATION && vif->cfg.assoc) {\n\t\tstruct sk_buff *skb;\n\n\t\tskb = ieee80211_nullfunc_get(hw, vif, link_conf->link_id, true);\n\t\tif (skb) {\n\t\t\tlocal_bh_disable();\n\t\t\tmac80211_hwsim_tx_frame(hw, skb, ctx->def.chan);\n\t\t\tlocal_bh_enable();\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void mac80211_hwsim_unassign_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\t\tstruct ieee80211_bss_conf *link_conf,\n\t\t\t\t\t\tstruct ieee80211_chanctx_conf *ctx)\n{\n\thwsim_check_magic(vif);\n\thwsim_check_chanctx_magic(ctx);\n\n\t \n\tif (vif->type == NL80211_IFTYPE_STATION && vif->cfg.assoc) {\n\t\tstruct sk_buff *skb;\n\n\t\tskb = ieee80211_nullfunc_get(hw, vif, link_conf->link_id, true);\n\t\tif (skb) {\n\t\t\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\n\t\t\thdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);\n\n\t\t\tlocal_bh_disable();\n\t\t\tmac80211_hwsim_tx_frame(hw, skb, ctx->def.chan);\n\t\t\tlocal_bh_enable();\n\t\t}\n\t}\n}\n\nstatic const char mac80211_hwsim_gstrings_stats[][ETH_GSTRING_LEN] = {\n\t\"tx_pkts_nic\",\n\t\"tx_bytes_nic\",\n\t\"rx_pkts_nic\",\n\t\"rx_bytes_nic\",\n\t\"d_tx_dropped\",\n\t\"d_tx_failed\",\n\t\"d_ps_mode\",\n\t\"d_group\",\n};\n\n#define MAC80211_HWSIM_SSTATS_LEN ARRAY_SIZE(mac80211_hwsim_gstrings_stats)\n\nstatic void mac80211_hwsim_get_et_strings(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  u32 sset, u8 *data)\n{\n\tif (sset == ETH_SS_STATS)\n\t\tmemcpy(data, mac80211_hwsim_gstrings_stats,\n\t\t       sizeof(mac80211_hwsim_gstrings_stats));\n}\n\nstatic int mac80211_hwsim_get_et_sset_count(struct ieee80211_hw *hw,\n\t\t\t\t\t    struct ieee80211_vif *vif, int sset)\n{\n\tif (sset == ETH_SS_STATS)\n\t\treturn MAC80211_HWSIM_SSTATS_LEN;\n\treturn 0;\n}\n\nstatic void mac80211_hwsim_get_et_stats(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tstruct ethtool_stats *stats, u64 *data)\n{\n\tstruct mac80211_hwsim_data *ar = hw->priv;\n\tint i = 0;\n\n\tdata[i++] = ar->tx_pkts;\n\tdata[i++] = ar->tx_bytes;\n\tdata[i++] = ar->rx_pkts;\n\tdata[i++] = ar->rx_bytes;\n\tdata[i++] = ar->tx_dropped;\n\tdata[i++] = ar->tx_failed;\n\tdata[i++] = ar->ps;\n\tdata[i++] = ar->group;\n\n\tWARN_ON(i != MAC80211_HWSIM_SSTATS_LEN);\n}\n\nstatic int mac80211_hwsim_tx_last_beacon(struct ieee80211_hw *hw)\n{\n\treturn 1;\n}\n\nstatic int mac80211_hwsim_set_rts_threshold(struct ieee80211_hw *hw, u32 value)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int mac80211_hwsim_change_vif_links(struct ieee80211_hw *hw,\n\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t   u16 old_links, u16 new_links,\n\t\t\t\t\t   struct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS])\n{\n\tunsigned long rem = old_links & ~new_links;\n\tunsigned long add = new_links & ~old_links;\n\tint i;\n\n\tif (!old_links)\n\t\trem |= BIT(0);\n\tif (!new_links)\n\t\tadd |= BIT(0);\n\n\tfor_each_set_bit(i, &rem, IEEE80211_MLD_MAX_NUM_LINKS)\n\t\tmac80211_hwsim_config_mac_nl(hw, old[i]->addr, false);\n\n\tfor_each_set_bit(i, &add, IEEE80211_MLD_MAX_NUM_LINKS) {\n\t\tstruct ieee80211_bss_conf *link_conf;\n\n\t\tlink_conf = link_conf_dereference_protected(vif, i);\n\t\tif (WARN_ON(!link_conf))\n\t\t\tcontinue;\n\n\t\tmac80211_hwsim_config_mac_nl(hw, link_conf->addr, true);\n\t}\n\n\treturn 0;\n}\n\nstatic int mac80211_hwsim_change_sta_links(struct ieee80211_hw *hw,\n\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t\t   u16 old_links, u16 new_links)\n{\n\tstruct hwsim_sta_priv *sp = (void *)sta->drv_priv;\n\n\thwsim_check_sta_magic(sta);\n\n\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\tsp->active_links_rx = new_links;\n\n\treturn 0;\n}\n\nstatic int mac80211_hwsim_send_pmsr_ftm_request_peer(struct sk_buff *msg,\n\t\t\t\t\t\t     struct cfg80211_pmsr_ftm_request_peer *request)\n{\n\tstruct nlattr *ftm;\n\n\tif (!request->requested)\n\t\treturn -EINVAL;\n\n\tftm = nla_nest_start(msg, NL80211_PMSR_TYPE_FTM);\n\tif (!ftm)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE, request->preamble))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u16(msg, NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD, request->burst_period))\n\t\treturn -ENOBUFS;\n\n\tif (request->asap && nla_put_flag(msg, NL80211_PMSR_FTM_REQ_ATTR_ASAP))\n\t\treturn -ENOBUFS;\n\n\tif (request->request_lci && nla_put_flag(msg, NL80211_PMSR_FTM_REQ_ATTR_REQUEST_LCI))\n\t\treturn -ENOBUFS;\n\n\tif (request->request_civicloc &&\n\t    nla_put_flag(msg, NL80211_PMSR_FTM_REQ_ATTR_REQUEST_CIVICLOC))\n\t\treturn -ENOBUFS;\n\n\tif (request->trigger_based && nla_put_flag(msg, NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED))\n\t\treturn -ENOBUFS;\n\n\tif (request->non_trigger_based &&\n\t    nla_put_flag(msg, NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED))\n\t\treturn -ENOBUFS;\n\n\tif (request->lmr_feedback && nla_put_flag(msg, NL80211_PMSR_FTM_REQ_ATTR_LMR_FEEDBACK))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u8(msg, NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP, request->num_bursts_exp))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u8(msg, NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION, request->burst_duration))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u8(msg, NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST, request->ftms_per_burst))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u8(msg, NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES, request->ftmr_retries))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u8(msg, NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION, request->burst_duration))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u8(msg, NL80211_PMSR_FTM_REQ_ATTR_BSS_COLOR, request->bss_color))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, ftm);\n\n\treturn 0;\n}\n\nstatic int mac80211_hwsim_send_pmsr_request_peer(struct sk_buff *msg,\n\t\t\t\t\t\t struct cfg80211_pmsr_request_peer *request)\n{\n\tstruct nlattr *peer, *chandef, *req, *data;\n\tint err;\n\n\tpeer = nla_nest_start(msg, NL80211_PMSR_ATTR_PEERS);\n\tif (!peer)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put(msg, NL80211_PMSR_PEER_ATTR_ADDR, ETH_ALEN,\n\t\t    request->addr))\n\t\treturn -ENOBUFS;\n\n\tchandef = nla_nest_start(msg, NL80211_PMSR_PEER_ATTR_CHAN);\n\tif (!chandef)\n\t\treturn -ENOBUFS;\n\n\terr = nl80211_send_chandef(msg, &request->chandef);\n\tif (err)\n\t\treturn err;\n\n\tnla_nest_end(msg, chandef);\n\n\treq = nla_nest_start(msg, NL80211_PMSR_PEER_ATTR_REQ);\n\tif (!req)\n\t\treturn -ENOBUFS;\n\n\tif (request->report_ap_tsf && nla_put_flag(msg, NL80211_PMSR_REQ_ATTR_GET_AP_TSF))\n\t\treturn -ENOBUFS;\n\n\tdata = nla_nest_start(msg, NL80211_PMSR_REQ_ATTR_DATA);\n\tif (!data)\n\t\treturn -ENOBUFS;\n\n\terr = mac80211_hwsim_send_pmsr_ftm_request_peer(msg, &request->ftm);\n\tif (err)\n\t\treturn err;\n\n\tnla_nest_end(msg, data);\n\tnla_nest_end(msg, req);\n\tnla_nest_end(msg, peer);\n\n\treturn 0;\n}\n\nstatic int mac80211_hwsim_send_pmsr_request(struct sk_buff *msg,\n\t\t\t\t\t    struct cfg80211_pmsr_request *request)\n{\n\tstruct nlattr *pmsr;\n\tint err;\n\n\tpmsr = nla_nest_start(msg, NL80211_ATTR_PEER_MEASUREMENTS);\n\tif (!pmsr)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_TIMEOUT, request->timeout))\n\t\treturn -ENOBUFS;\n\n\tif (!is_zero_ether_addr(request->mac_addr)) {\n\t\tif (nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, request->mac_addr))\n\t\t\treturn -ENOBUFS;\n\t\tif (nla_put(msg, NL80211_ATTR_MAC_MASK, ETH_ALEN, request->mac_addr_mask))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\tfor (int i = 0; i < request->n_peers; i++) {\n\t\terr = mac80211_hwsim_send_pmsr_request_peer(msg, &request->peers[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tnla_nest_end(msg, pmsr);\n\n\treturn 0;\n}\n\nstatic int mac80211_hwsim_start_pmsr(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct cfg80211_pmsr_request *request)\n{\n\tstruct mac80211_hwsim_data *data;\n\tstruct sk_buff *skb = NULL;\n\tstruct nlattr *pmsr;\n\tvoid *msg_head;\n\tu32 _portid;\n\tint err = 0;\n\n\tdata = hw->priv;\n\t_portid = READ_ONCE(data->wmediumd);\n\tif (!_portid && !hwsim_virtio_enabled)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&data->mutex);\n\n\tif (data->pmsr_request) {\n\t\terr = -EBUSY;\n\t\tgoto out_free;\n\t}\n\n\tskb = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\n\tif (!skb) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tmsg_head = genlmsg_put(skb, 0, 0, &hwsim_genl_family, 0, HWSIM_CMD_START_PMSR);\n\n\tif (nla_put(skb, HWSIM_ATTR_ADDR_TRANSMITTER,\n\t\t    ETH_ALEN, data->addresses[1].addr)) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tpmsr = nla_nest_start(skb, HWSIM_ATTR_PMSR_REQUEST);\n\tif (!pmsr) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\terr = mac80211_hwsim_send_pmsr_request(skb, request);\n\tif (err)\n\t\tgoto out_free;\n\n\tnla_nest_end(skb, pmsr);\n\n\tgenlmsg_end(skb, msg_head);\n\tif (hwsim_virtio_enabled)\n\t\thwsim_tx_virtio(data, skb);\n\telse\n\t\thwsim_unicast_netgroup(data, skb, _portid);\n\n\tdata->pmsr_request = request;\n\tdata->pmsr_request_wdev = ieee80211_vif_to_wdev(vif);\n\nout_free:\n\tif (err && skb)\n\t\tnlmsg_free(skb);\n\n\tmutex_unlock(&data->mutex);\n\treturn err;\n}\n\nstatic void mac80211_hwsim_abort_pmsr(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct cfg80211_pmsr_request *request)\n{\n\tstruct mac80211_hwsim_data *data;\n\tstruct sk_buff *skb = NULL;\n\tstruct nlattr *pmsr;\n\tvoid *msg_head;\n\tu32 _portid;\n\tint err = 0;\n\n\tdata = hw->priv;\n\t_portid = READ_ONCE(data->wmediumd);\n\tif (!_portid && !hwsim_virtio_enabled)\n\t\treturn;\n\n\tmutex_lock(&data->mutex);\n\n\tif (data->pmsr_request != request) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tskb = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmsg_head = genlmsg_put(skb, 0, 0, &hwsim_genl_family, 0, HWSIM_CMD_ABORT_PMSR);\n\n\tif (nla_put(skb, HWSIM_ATTR_ADDR_TRANSMITTER, ETH_ALEN, data->addresses[1].addr))\n\t\tgoto out;\n\n\tpmsr = nla_nest_start(skb, HWSIM_ATTR_PMSR_REQUEST);\n\tif (!pmsr) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = mac80211_hwsim_send_pmsr_request(skb, request);\n\tif (err)\n\t\tgoto out;\n\n\terr = nla_nest_end(skb, pmsr);\n\tif (err)\n\t\tgoto out;\n\n\tgenlmsg_end(skb, msg_head);\n\tif (hwsim_virtio_enabled)\n\t\thwsim_tx_virtio(data, skb);\n\telse\n\t\thwsim_unicast_netgroup(data, skb, _portid);\n\nout:\n\tif (err && skb)\n\t\tnlmsg_free(skb);\n\n\tmutex_unlock(&data->mutex);\n}\n\nstatic int mac80211_hwsim_parse_rate_info(struct nlattr *rateattr,\n\t\t\t\t\t  struct rate_info *rate_info,\n\t\t\t\t\t  struct genl_info *info)\n{\n\tstruct nlattr *tb[HWSIM_RATE_INFO_ATTR_MAX + 1];\n\tint ret;\n\n\tret = nla_parse_nested(tb, HWSIM_RATE_INFO_ATTR_MAX,\n\t\t\t       rateattr, hwsim_rate_info_policy, info->extack);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tb[HWSIM_RATE_INFO_ATTR_FLAGS])\n\t\trate_info->flags = nla_get_u8(tb[HWSIM_RATE_INFO_ATTR_FLAGS]);\n\n\tif (tb[HWSIM_RATE_INFO_ATTR_MCS])\n\t\trate_info->mcs = nla_get_u8(tb[HWSIM_RATE_INFO_ATTR_MCS]);\n\n\tif (tb[HWSIM_RATE_INFO_ATTR_LEGACY])\n\t\trate_info->legacy = nla_get_u16(tb[HWSIM_RATE_INFO_ATTR_LEGACY]);\n\n\tif (tb[HWSIM_RATE_INFO_ATTR_NSS])\n\t\trate_info->nss = nla_get_u8(tb[HWSIM_RATE_INFO_ATTR_NSS]);\n\n\tif (tb[HWSIM_RATE_INFO_ATTR_BW])\n\t\trate_info->bw = nla_get_u8(tb[HWSIM_RATE_INFO_ATTR_BW]);\n\n\tif (tb[HWSIM_RATE_INFO_ATTR_HE_GI])\n\t\trate_info->he_gi = nla_get_u8(tb[HWSIM_RATE_INFO_ATTR_HE_GI]);\n\n\tif (tb[HWSIM_RATE_INFO_ATTR_HE_DCM])\n\t\trate_info->he_dcm = nla_get_u8(tb[HWSIM_RATE_INFO_ATTR_HE_DCM]);\n\n\tif (tb[HWSIM_RATE_INFO_ATTR_HE_RU_ALLOC])\n\t\trate_info->he_ru_alloc =\n\t\t\tnla_get_u8(tb[HWSIM_RATE_INFO_ATTR_HE_RU_ALLOC]);\n\n\tif (tb[HWSIM_RATE_INFO_ATTR_N_BOUNDED_CH])\n\t\trate_info->n_bonded_ch = nla_get_u8(tb[HWSIM_RATE_INFO_ATTR_N_BOUNDED_CH]);\n\n\tif (tb[HWSIM_RATE_INFO_ATTR_EHT_GI])\n\t\trate_info->eht_gi = nla_get_u8(tb[HWSIM_RATE_INFO_ATTR_EHT_GI]);\n\n\tif (tb[HWSIM_RATE_INFO_ATTR_EHT_RU_ALLOC])\n\t\trate_info->eht_ru_alloc = nla_get_u8(tb[HWSIM_RATE_INFO_ATTR_EHT_RU_ALLOC]);\n\n\treturn 0;\n}\n\nstatic int mac80211_hwsim_parse_ftm_result(struct nlattr *ftm,\n\t\t\t\t\t   struct cfg80211_pmsr_ftm_result *result,\n\t\t\t\t\t   struct genl_info *info)\n{\n\tstruct nlattr *tb[NL80211_PMSR_FTM_RESP_ATTR_MAX + 1];\n\tint ret;\n\n\tret = nla_parse_nested(tb, NL80211_PMSR_FTM_RESP_ATTR_MAX,\n\t\t\t       ftm, hwsim_ftm_result_policy, info->extack);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tb[NL80211_PMSR_FTM_RESP_ATTR_FAIL_REASON])\n\t\tresult->failure_reason = nla_get_u32(tb[NL80211_PMSR_FTM_RESP_ATTR_FAIL_REASON]);\n\n\tif (tb[NL80211_PMSR_FTM_RESP_ATTR_BURST_INDEX])\n\t\tresult->burst_index = nla_get_u16(tb[NL80211_PMSR_FTM_RESP_ATTR_BURST_INDEX]);\n\n\tif (tb[NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_ATTEMPTS]) {\n\t\tresult->num_ftmr_attempts_valid = 1;\n\t\tresult->num_ftmr_attempts =\n\t\t\tnla_get_u32(tb[NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_ATTEMPTS]);\n\t}\n\n\tif (tb[NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_SUCCESSES]) {\n\t\tresult->num_ftmr_successes_valid = 1;\n\t\tresult->num_ftmr_successes =\n\t\t\tnla_get_u32(tb[NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_SUCCESSES]);\n\t}\n\n\tif (tb[NL80211_PMSR_FTM_RESP_ATTR_BUSY_RETRY_TIME])\n\t\tresult->busy_retry_time =\n\t\t\tnla_get_u8(tb[NL80211_PMSR_FTM_RESP_ATTR_BUSY_RETRY_TIME]);\n\n\tif (tb[NL80211_PMSR_FTM_RESP_ATTR_NUM_BURSTS_EXP])\n\t\tresult->num_bursts_exp = nla_get_u8(tb[NL80211_PMSR_FTM_RESP_ATTR_NUM_BURSTS_EXP]);\n\n\tif (tb[NL80211_PMSR_FTM_RESP_ATTR_BURST_DURATION])\n\t\tresult->burst_duration = nla_get_u8(tb[NL80211_PMSR_FTM_RESP_ATTR_BURST_DURATION]);\n\n\tif (tb[NL80211_PMSR_FTM_RESP_ATTR_FTMS_PER_BURST])\n\t\tresult->ftms_per_burst = nla_get_u8(tb[NL80211_PMSR_FTM_RESP_ATTR_FTMS_PER_BURST]);\n\n\tif (tb[NL80211_PMSR_FTM_RESP_ATTR_RSSI_AVG]) {\n\t\tresult->rssi_avg_valid = 1;\n\t\tresult->rssi_avg = nla_get_s32(tb[NL80211_PMSR_FTM_RESP_ATTR_RSSI_AVG]);\n\t}\n\tif (tb[NL80211_PMSR_FTM_RESP_ATTR_RSSI_SPREAD]) {\n\t\tresult->rssi_spread_valid = 1;\n\t\tresult->rssi_spread =\n\t\t\tnla_get_s32(tb[NL80211_PMSR_FTM_RESP_ATTR_RSSI_SPREAD]);\n\t}\n\n\tif (tb[NL80211_PMSR_FTM_RESP_ATTR_TX_RATE]) {\n\t\tresult->tx_rate_valid = 1;\n\t\tret = mac80211_hwsim_parse_rate_info(tb[NL80211_PMSR_FTM_RESP_ATTR_TX_RATE],\n\t\t\t\t\t\t     &result->tx_rate, info);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (tb[NL80211_PMSR_FTM_RESP_ATTR_RX_RATE]) {\n\t\tresult->rx_rate_valid = 1;\n\t\tret = mac80211_hwsim_parse_rate_info(tb[NL80211_PMSR_FTM_RESP_ATTR_RX_RATE],\n\t\t\t\t\t\t     &result->rx_rate, info);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (tb[NL80211_PMSR_FTM_RESP_ATTR_RTT_AVG]) {\n\t\tresult->rtt_avg_valid = 1;\n\t\tresult->rtt_avg =\n\t\t\tnla_get_u64(tb[NL80211_PMSR_FTM_RESP_ATTR_RTT_AVG]);\n\t}\n\tif (tb[NL80211_PMSR_FTM_RESP_ATTR_RTT_VARIANCE]) {\n\t\tresult->rtt_variance_valid = 1;\n\t\tresult->rtt_variance =\n\t\t\tnla_get_u64(tb[NL80211_PMSR_FTM_RESP_ATTR_RTT_VARIANCE]);\n\t}\n\tif (tb[NL80211_PMSR_FTM_RESP_ATTR_RTT_SPREAD]) {\n\t\tresult->rtt_spread_valid = 1;\n\t\tresult->rtt_spread =\n\t\t\tnla_get_u64(tb[NL80211_PMSR_FTM_RESP_ATTR_RTT_SPREAD]);\n\t}\n\tif (tb[NL80211_PMSR_FTM_RESP_ATTR_DIST_AVG]) {\n\t\tresult->dist_avg_valid = 1;\n\t\tresult->dist_avg =\n\t\t\tnla_get_u64(tb[NL80211_PMSR_FTM_RESP_ATTR_DIST_AVG]);\n\t}\n\tif (tb[NL80211_PMSR_FTM_RESP_ATTR_DIST_VARIANCE]) {\n\t\tresult->dist_variance_valid = 1;\n\t\tresult->dist_variance =\n\t\t\tnla_get_u64(tb[NL80211_PMSR_FTM_RESP_ATTR_DIST_VARIANCE]);\n\t}\n\tif (tb[NL80211_PMSR_FTM_RESP_ATTR_DIST_SPREAD]) {\n\t\tresult->dist_spread_valid = 1;\n\t\tresult->dist_spread =\n\t\t\tnla_get_u64(tb[NL80211_PMSR_FTM_RESP_ATTR_DIST_SPREAD]);\n\t}\n\n\tif (tb[NL80211_PMSR_FTM_RESP_ATTR_LCI]) {\n\t\tresult->lci = nla_data(tb[NL80211_PMSR_FTM_RESP_ATTR_LCI]);\n\t\tresult->lci_len = nla_len(tb[NL80211_PMSR_FTM_RESP_ATTR_LCI]);\n\t}\n\n\tif (tb[NL80211_PMSR_FTM_RESP_ATTR_CIVICLOC]) {\n\t\tresult->civicloc = nla_data(tb[NL80211_PMSR_FTM_RESP_ATTR_CIVICLOC]);\n\t\tresult->civicloc_len = nla_len(tb[NL80211_PMSR_FTM_RESP_ATTR_CIVICLOC]);\n\t}\n\n\treturn 0;\n}\n\nstatic int mac80211_hwsim_parse_pmsr_resp(struct nlattr *resp,\n\t\t\t\t\t  struct cfg80211_pmsr_result *result,\n\t\t\t\t\t  struct genl_info *info)\n{\n\tstruct nlattr *tb[NL80211_PMSR_RESP_ATTR_MAX + 1];\n\tstruct nlattr *pmsr;\n\tint rem;\n\tint ret;\n\n\tret = nla_parse_nested(tb, NL80211_PMSR_RESP_ATTR_MAX, resp, hwsim_pmsr_resp_policy,\n\t\t\t       info->extack);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tb[NL80211_PMSR_RESP_ATTR_STATUS])\n\t\tresult->status = nla_get_u32(tb[NL80211_PMSR_RESP_ATTR_STATUS]);\n\n\tif (tb[NL80211_PMSR_RESP_ATTR_HOST_TIME])\n\t\tresult->host_time = nla_get_u64(tb[NL80211_PMSR_RESP_ATTR_HOST_TIME]);\n\n\tif (tb[NL80211_PMSR_RESP_ATTR_AP_TSF]) {\n\t\tresult->ap_tsf_valid = 1;\n\t\tresult->ap_tsf = nla_get_u64(tb[NL80211_PMSR_RESP_ATTR_AP_TSF]);\n\t}\n\n\tresult->final = !!tb[NL80211_PMSR_RESP_ATTR_FINAL];\n\n\tif (!tb[NL80211_PMSR_RESP_ATTR_DATA])\n\t\treturn 0;\n\n\tnla_for_each_nested(pmsr, tb[NL80211_PMSR_RESP_ATTR_DATA], rem) {\n\t\tswitch (nla_type(pmsr)) {\n\t\tcase NL80211_PMSR_TYPE_FTM:\n\t\t\tresult->type = NL80211_PMSR_TYPE_FTM;\n\t\t\tret = mac80211_hwsim_parse_ftm_result(pmsr, &result->ftm, info);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_ATTR(info->extack, pmsr, \"Unknown pmsr resp type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mac80211_hwsim_parse_pmsr_result(struct nlattr *peer,\n\t\t\t\t\t    struct cfg80211_pmsr_result *result,\n\t\t\t\t\t    struct genl_info *info)\n{\n\tstruct nlattr *tb[NL80211_PMSR_PEER_ATTR_MAX + 1];\n\tint ret;\n\n\tif (!peer)\n\t\treturn -EINVAL;\n\n\tret = nla_parse_nested(tb, NL80211_PMSR_PEER_ATTR_MAX, peer,\n\t\t\t       hwsim_pmsr_peer_result_policy, info->extack);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tb[NL80211_PMSR_PEER_ATTR_ADDR])\n\t\tmemcpy(result->addr, nla_data(tb[NL80211_PMSR_PEER_ATTR_ADDR]),\n\t\t       ETH_ALEN);\n\n\tif (tb[NL80211_PMSR_PEER_ATTR_RESP]) {\n\t\tret = mac80211_hwsim_parse_pmsr_resp(tb[NL80211_PMSR_PEER_ATTR_RESP], result, info);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n};\n\nstatic int hwsim_pmsr_report_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct mac80211_hwsim_data *data;\n\tstruct nlattr *peers, *peer;\n\tstruct nlattr *reqattr;\n\tconst u8 *src;\n\tint err;\n\tint rem;\n\n\tif (!info->attrs[HWSIM_ATTR_ADDR_TRANSMITTER])\n\t\treturn -EINVAL;\n\n\tsrc = nla_data(info->attrs[HWSIM_ATTR_ADDR_TRANSMITTER]);\n\tdata = get_hwsim_data_ref_from_addr(src);\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&data->mutex);\n\tif (!data->pmsr_request) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\treqattr = info->attrs[HWSIM_ATTR_PMSR_RESULT];\n\tif (!reqattr) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpeers = nla_find_nested(reqattr, NL80211_PMSR_ATTR_PEERS);\n\tif (!peers) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tnla_for_each_nested(peer, peers, rem) {\n\t\tstruct cfg80211_pmsr_result result;\n\n\t\terr = mac80211_hwsim_parse_pmsr_result(peer, &result, info);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tcfg80211_pmsr_report(data->pmsr_request_wdev,\n\t\t\t\t     data->pmsr_request, &result, GFP_KERNEL);\n\t}\n\n\tcfg80211_pmsr_complete(data->pmsr_request_wdev, data->pmsr_request, GFP_KERNEL);\n\n\terr = 0;\nout:\n\tdata->pmsr_request = NULL;\n\tdata->pmsr_request_wdev = NULL;\n\n\tmutex_unlock(&data->mutex);\n\treturn err;\n}\n\n#define HWSIM_COMMON_OPS\t\t\t\t\t\\\n\t.tx = mac80211_hwsim_tx,\t\t\t\t\\\n\t.wake_tx_queue = ieee80211_handle_wake_tx_queue,\t\\\n\t.start = mac80211_hwsim_start,\t\t\t\t\\\n\t.stop = mac80211_hwsim_stop,\t\t\t\t\\\n\t.add_interface = mac80211_hwsim_add_interface,\t\t\\\n\t.change_interface = mac80211_hwsim_change_interface,\t\\\n\t.remove_interface = mac80211_hwsim_remove_interface,\t\\\n\t.config = mac80211_hwsim_config,\t\t\t\\\n\t.configure_filter = mac80211_hwsim_configure_filter,\t\\\n\t.vif_cfg_changed = mac80211_hwsim_vif_info_changed,\t\\\n\t.link_info_changed = mac80211_hwsim_link_info_changed,  \\\n\t.tx_last_beacon = mac80211_hwsim_tx_last_beacon,\t\\\n\t.sta_notify = mac80211_hwsim_sta_notify,\t\t\\\n\t.sta_rc_update = mac80211_hwsim_sta_rc_update,\t\t\\\n\t.conf_tx = mac80211_hwsim_conf_tx,\t\t\t\\\n\t.get_survey = mac80211_hwsim_get_survey,\t\t\\\n\tCFG80211_TESTMODE_CMD(mac80211_hwsim_testmode_cmd)\t\\\n\t.ampdu_action = mac80211_hwsim_ampdu_action,\t\t\\\n\t.flush = mac80211_hwsim_flush,\t\t\t\t\\\n\t.get_et_sset_count = mac80211_hwsim_get_et_sset_count,\t\\\n\t.get_et_stats = mac80211_hwsim_get_et_stats,\t\t\\\n\t.get_et_strings = mac80211_hwsim_get_et_strings,\t\\\n\t.start_pmsr = mac80211_hwsim_start_pmsr,\t\t\\\n\t.abort_pmsr = mac80211_hwsim_abort_pmsr,\n\n#define HWSIM_NON_MLO_OPS\t\t\t\t\t\\\n\t.sta_add = mac80211_hwsim_sta_add,\t\t\t\\\n\t.sta_remove = mac80211_hwsim_sta_remove,\t\t\\\n\t.set_tim = mac80211_hwsim_set_tim,\t\t\t\\\n\t.get_tsf = mac80211_hwsim_get_tsf,\t\t\t\\\n\t.set_tsf = mac80211_hwsim_set_tsf,\n\nstatic const struct ieee80211_ops mac80211_hwsim_ops = {\n\tHWSIM_COMMON_OPS\n\tHWSIM_NON_MLO_OPS\n\t.sw_scan_start = mac80211_hwsim_sw_scan,\n\t.sw_scan_complete = mac80211_hwsim_sw_scan_complete,\n};\n\n#define HWSIM_CHANCTX_OPS\t\t\t\t\t\\\n\t.hw_scan = mac80211_hwsim_hw_scan,\t\t\t\\\n\t.cancel_hw_scan = mac80211_hwsim_cancel_hw_scan,\t\\\n\t.remain_on_channel = mac80211_hwsim_roc,\t\t\\\n\t.cancel_remain_on_channel = mac80211_hwsim_croc,\t\\\n\t.add_chanctx = mac80211_hwsim_add_chanctx,\t\t\\\n\t.remove_chanctx = mac80211_hwsim_remove_chanctx,\t\\\n\t.change_chanctx = mac80211_hwsim_change_chanctx,\t\\\n\t.assign_vif_chanctx = mac80211_hwsim_assign_vif_chanctx,\\\n\t.unassign_vif_chanctx = mac80211_hwsim_unassign_vif_chanctx,\n\nstatic const struct ieee80211_ops mac80211_hwsim_mchan_ops = {\n\tHWSIM_COMMON_OPS\n\tHWSIM_NON_MLO_OPS\n\tHWSIM_CHANCTX_OPS\n};\n\nstatic const struct ieee80211_ops mac80211_hwsim_mlo_ops = {\n\tHWSIM_COMMON_OPS\n\tHWSIM_CHANCTX_OPS\n\t.set_rts_threshold = mac80211_hwsim_set_rts_threshold,\n\t.change_vif_links = mac80211_hwsim_change_vif_links,\n\t.change_sta_links = mac80211_hwsim_change_sta_links,\n\t.sta_state = mac80211_hwsim_sta_state,\n};\n\nstruct hwsim_new_radio_params {\n\tunsigned int channels;\n\tconst char *reg_alpha2;\n\tconst struct ieee80211_regdomain *regd;\n\tbool reg_strict;\n\tbool p2p_device;\n\tbool use_chanctx;\n\tbool destroy_on_close;\n\tconst char *hwname;\n\tbool no_vif;\n\tconst u8 *perm_addr;\n\tu32 iftypes;\n\tu32 *ciphers;\n\tu8 n_ciphers;\n\tbool mlo;\n\tconst struct cfg80211_pmsr_capabilities *pmsr_capa;\n};\n\nstatic void hwsim_mcast_config_msg(struct sk_buff *mcast_skb,\n\t\t\t\t   struct genl_info *info)\n{\n\tif (info)\n\t\tgenl_notify(&hwsim_genl_family, mcast_skb, info,\n\t\t\t    HWSIM_MCGRP_CONFIG, GFP_KERNEL);\n\telse\n\t\tgenlmsg_multicast(&hwsim_genl_family, mcast_skb, 0,\n\t\t\t\t  HWSIM_MCGRP_CONFIG, GFP_KERNEL);\n}\n\nstatic int append_radio_msg(struct sk_buff *skb, int id,\n\t\t\t    struct hwsim_new_radio_params *param)\n{\n\tint ret;\n\n\tret = nla_put_u32(skb, HWSIM_ATTR_RADIO_ID, id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (param->channels) {\n\t\tret = nla_put_u32(skb, HWSIM_ATTR_CHANNELS, param->channels);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (param->reg_alpha2) {\n\t\tret = nla_put(skb, HWSIM_ATTR_REG_HINT_ALPHA2, 2,\n\t\t\t      param->reg_alpha2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (param->regd) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(hwsim_world_regdom_custom); i++) {\n\t\t\tif (hwsim_world_regdom_custom[i] != param->regd)\n\t\t\t\tcontinue;\n\n\t\t\tret = nla_put_u32(skb, HWSIM_ATTR_REG_CUSTOM_REG, i);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (param->reg_strict) {\n\t\tret = nla_put_flag(skb, HWSIM_ATTR_REG_STRICT_REG);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (param->p2p_device) {\n\t\tret = nla_put_flag(skb, HWSIM_ATTR_SUPPORT_P2P_DEVICE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (param->use_chanctx) {\n\t\tret = nla_put_flag(skb, HWSIM_ATTR_USE_CHANCTX);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (param->hwname) {\n\t\tret = nla_put(skb, HWSIM_ATTR_RADIO_NAME,\n\t\t\t      strlen(param->hwname), param->hwname);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void hwsim_mcast_new_radio(int id, struct genl_info *info,\n\t\t\t\t  struct hwsim_new_radio_params *param)\n{\n\tstruct sk_buff *mcast_skb;\n\tvoid *data;\n\n\tmcast_skb = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!mcast_skb)\n\t\treturn;\n\n\tdata = genlmsg_put(mcast_skb, 0, 0, &hwsim_genl_family, 0,\n\t\t\t   HWSIM_CMD_NEW_RADIO);\n\tif (!data)\n\t\tgoto out_err;\n\n\tif (append_radio_msg(mcast_skb, id, param) < 0)\n\t\tgoto out_err;\n\n\tgenlmsg_end(mcast_skb, data);\n\n\thwsim_mcast_config_msg(mcast_skb, info);\n\treturn;\n\nout_err:\n\tnlmsg_free(mcast_skb);\n}\n\nstatic const struct ieee80211_sband_iftype_data sband_capa_2ghz[] = {\n\t{\n\t\t.types_mask = BIT(NL80211_IFTYPE_STATION),\n\t\t.he_cap = {\n\t\t\t.has_he = true,\n\t\t\t.he_cap_elem = {\n\t\t\t\t.mac_cap_info[0] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP0_HTC_HE,\n\t\t\t\t.mac_cap_info[1] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,\n\t\t\t\t.mac_cap_info[2] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP2_BSR |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP2_MU_CASCADING |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP2_ACK_EN,\n\t\t\t\t.mac_cap_info[3] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP3_OMI_CONTROL |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_3,\n\t\t\t\t.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU,\n\t\t\t\t.phy_cap_info[1] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS,\n\t\t\t\t.phy_cap_info[2] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_UL_MU_PARTIAL_MU_MIMO,\n\n\t\t\t\t \n\t\t\t},\n\t\t\t.he_mcs_nss_supp = {\n\t\t\t\t.rx_mcs_80 = cpu_to_le16(0xfffa),\n\t\t\t\t.tx_mcs_80 = cpu_to_le16(0xfffa),\n\t\t\t\t.rx_mcs_160 = cpu_to_le16(0xffff),\n\t\t\t\t.tx_mcs_160 = cpu_to_le16(0xffff),\n\t\t\t\t.rx_mcs_80p80 = cpu_to_le16(0xffff),\n\t\t\t\t.tx_mcs_80p80 = cpu_to_le16(0xffff),\n\t\t\t},\n\t\t},\n\t\t.eht_cap = {\n\t\t\t.has_eht = true,\n\t\t\t.eht_cap_elem = {\n\t\t\t\t.mac_cap_info[0] =\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP0_EPCS_PRIO_ACCESS |\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP0_OM_CONTROL |\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP0_TRIG_TXOP_SHARING_MODE1,\n\t\t\t\t.phy_cap_info[0] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_242_TONE_RU_GT20MHZ |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_NDP_4_EHT_LFT_32_GI |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_PARTIAL_BW_UL_MU_MIMO |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_SU_BEAMFORMER |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_SU_BEAMFORMEE,\n\t\t\t\t.phy_cap_info[3] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_NG_16_SU_FEEDBACK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_NG_16_MU_FEEDBACK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_CODEBOOK_4_2_SU_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_CODEBOOK_7_5_MU_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_TRIG_SU_BF_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_TRIG_MU_BF_PART_BW_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_TRIG_CQI_FDBK,\n\t\t\t\t.phy_cap_info[4] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_PART_BW_DL_MU_MIMO |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_PSR_SR_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_POWER_BOOST_FACT_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_EHT_MU_PPDU_4_EHT_LTF_08_GI |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_MAX_NC_MASK,\n\t\t\t\t.phy_cap_info[5] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_NON_TRIG_CQI_FEEDBACK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_TX_LESS_242_TONE_RU_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_RX_LESS_242_TONE_RU_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_PPE_THRESHOLD_PRESENT |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_COMMON_NOMINAL_PKT_PAD_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_MAX_NUM_SUPP_EHT_LTF_MASK,\n\t\t\t\t.phy_cap_info[6] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP6_MAX_NUM_SUPP_EHT_LTF_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP6_MCS15_SUPP_MASK,\n\t\t\t\t.phy_cap_info[7] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP7_20MHZ_STA_RX_NDP_WIDER_BW,\n\t\t\t},\n\n\t\t\t \n\t\t\t.eht_mcs_nss_supp = {\n\t\t\t\t \n\t\t\t\t.only_20mhz = {\n\t\t\t\t\t.rx_tx_mcs7_max_nss = 0x88,\n\t\t\t\t\t.rx_tx_mcs9_max_nss = 0x88,\n\t\t\t\t\t.rx_tx_mcs11_max_nss = 0x88,\n\t\t\t\t\t.rx_tx_mcs13_max_nss = 0x88,\n\t\t\t\t},\n\t\t\t},\n\t\t\t \n\t\t},\n\t},\n\t{\n\t\t.types_mask = BIT(NL80211_IFTYPE_AP),\n\t\t.he_cap = {\n\t\t\t.has_he = true,\n\t\t\t.he_cap_elem = {\n\t\t\t\t.mac_cap_info[0] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP0_HTC_HE,\n\t\t\t\t.mac_cap_info[1] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,\n\t\t\t\t.mac_cap_info[2] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP2_BSR |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP2_MU_CASCADING |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP2_ACK_EN,\n\t\t\t\t.mac_cap_info[3] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP3_OMI_CONTROL |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_3,\n\t\t\t\t.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU,\n\t\t\t\t.phy_cap_info[1] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS,\n\t\t\t\t.phy_cap_info[2] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_UL_MU_PARTIAL_MU_MIMO,\n\n\t\t\t\t \n\t\t\t},\n\t\t\t.he_mcs_nss_supp = {\n\t\t\t\t.rx_mcs_80 = cpu_to_le16(0xfffa),\n\t\t\t\t.tx_mcs_80 = cpu_to_le16(0xfffa),\n\t\t\t\t.rx_mcs_160 = cpu_to_le16(0xffff),\n\t\t\t\t.tx_mcs_160 = cpu_to_le16(0xffff),\n\t\t\t\t.rx_mcs_80p80 = cpu_to_le16(0xffff),\n\t\t\t\t.tx_mcs_80p80 = cpu_to_le16(0xffff),\n\t\t\t},\n\t\t},\n\t\t.eht_cap = {\n\t\t\t.has_eht = true,\n\t\t\t.eht_cap_elem = {\n\t\t\t\t.mac_cap_info[0] =\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP0_EPCS_PRIO_ACCESS |\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP0_OM_CONTROL |\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP0_TRIG_TXOP_SHARING_MODE1,\n\t\t\t\t.phy_cap_info[0] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_242_TONE_RU_GT20MHZ |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_NDP_4_EHT_LFT_32_GI |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_PARTIAL_BW_UL_MU_MIMO |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_SU_BEAMFORMER |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_SU_BEAMFORMEE,\n\t\t\t\t.phy_cap_info[3] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_NG_16_SU_FEEDBACK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_NG_16_MU_FEEDBACK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_CODEBOOK_4_2_SU_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_CODEBOOK_7_5_MU_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_TRIG_SU_BF_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_TRIG_MU_BF_PART_BW_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_TRIG_CQI_FDBK,\n\t\t\t\t.phy_cap_info[4] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_PART_BW_DL_MU_MIMO |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_PSR_SR_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_POWER_BOOST_FACT_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_EHT_MU_PPDU_4_EHT_LTF_08_GI |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_MAX_NC_MASK,\n\t\t\t\t.phy_cap_info[5] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_NON_TRIG_CQI_FEEDBACK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_TX_LESS_242_TONE_RU_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_RX_LESS_242_TONE_RU_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_PPE_THRESHOLD_PRESENT |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_COMMON_NOMINAL_PKT_PAD_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_MAX_NUM_SUPP_EHT_LTF_MASK,\n\t\t\t\t.phy_cap_info[6] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP6_MAX_NUM_SUPP_EHT_LTF_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP6_MCS15_SUPP_MASK,\n\t\t\t\t.phy_cap_info[7] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP7_20MHZ_STA_RX_NDP_WIDER_BW,\n\t\t\t},\n\n\t\t\t \n\t\t\t.eht_mcs_nss_supp = {\n\t\t\t\t \n\t\t\t\t.only_20mhz = {\n\t\t\t\t\t.rx_tx_mcs7_max_nss = 0x88,\n\t\t\t\t\t.rx_tx_mcs9_max_nss = 0x88,\n\t\t\t\t\t.rx_tx_mcs11_max_nss = 0x88,\n\t\t\t\t\t.rx_tx_mcs13_max_nss = 0x88,\n\t\t\t\t},\n\t\t\t},\n\t\t\t \n\t\t},\n\t},\n#ifdef CONFIG_MAC80211_MESH\n\t{\n\t\t.types_mask = BIT(NL80211_IFTYPE_MESH_POINT),\n\t\t.he_cap = {\n\t\t\t.has_he = true,\n\t\t\t.he_cap_elem = {\n\t\t\t\t.mac_cap_info[0] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP0_HTC_HE,\n\t\t\t\t.mac_cap_info[1] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,\n\t\t\t\t.mac_cap_info[2] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP2_ACK_EN,\n\t\t\t\t.mac_cap_info[3] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP3_OMI_CONTROL |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_3,\n\t\t\t\t.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU,\n\t\t\t\t.phy_cap_info[1] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS,\n\t\t\t\t.phy_cap_info[2] = 0,\n\n\t\t\t\t \n\t\t\t},\n\t\t\t.he_mcs_nss_supp = {\n\t\t\t\t.rx_mcs_80 = cpu_to_le16(0xfffa),\n\t\t\t\t.tx_mcs_80 = cpu_to_le16(0xfffa),\n\t\t\t\t.rx_mcs_160 = cpu_to_le16(0xffff),\n\t\t\t\t.tx_mcs_160 = cpu_to_le16(0xffff),\n\t\t\t\t.rx_mcs_80p80 = cpu_to_le16(0xffff),\n\t\t\t\t.tx_mcs_80p80 = cpu_to_le16(0xffff),\n\t\t\t},\n\t\t},\n\t},\n#endif\n};\n\nstatic const struct ieee80211_sband_iftype_data sband_capa_5ghz[] = {\n\t{\n\t\t \n\t\t.types_mask = BIT(NL80211_IFTYPE_STATION),\n\t\t.he_cap = {\n\t\t\t.has_he = true,\n\t\t\t.he_cap_elem = {\n\t\t\t\t.mac_cap_info[0] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP0_HTC_HE,\n\t\t\t\t.mac_cap_info[1] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,\n\t\t\t\t.mac_cap_info[2] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP2_BSR |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP2_MU_CASCADING |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP2_ACK_EN,\n\t\t\t\t.mac_cap_info[3] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP3_OMI_CONTROL |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_3,\n\t\t\t\t.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU,\n\t\t\t\t.phy_cap_info[0] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G,\n\t\t\t\t.phy_cap_info[1] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS,\n\t\t\t\t.phy_cap_info[2] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_UL_MU_PARTIAL_MU_MIMO,\n\n\t\t\t\t \n\t\t\t},\n\t\t\t.he_mcs_nss_supp = {\n\t\t\t\t.rx_mcs_80 = cpu_to_le16(0xfffa),\n\t\t\t\t.tx_mcs_80 = cpu_to_le16(0xfffa),\n\t\t\t\t.rx_mcs_160 = cpu_to_le16(0xfffa),\n\t\t\t\t.tx_mcs_160 = cpu_to_le16(0xfffa),\n\t\t\t\t.rx_mcs_80p80 = cpu_to_le16(0xfffa),\n\t\t\t\t.tx_mcs_80p80 = cpu_to_le16(0xfffa),\n\t\t\t},\n\t\t},\n\t\t.eht_cap = {\n\t\t\t.has_eht = true,\n\t\t\t.eht_cap_elem = {\n\t\t\t\t.mac_cap_info[0] =\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP0_EPCS_PRIO_ACCESS |\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP0_OM_CONTROL |\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP0_TRIG_TXOP_SHARING_MODE1,\n\t\t\t\t.phy_cap_info[0] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_242_TONE_RU_GT20MHZ |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_NDP_4_EHT_LFT_32_GI |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_PARTIAL_BW_UL_MU_MIMO |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_SU_BEAMFORMER |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_SU_BEAMFORMEE |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_BEAMFORMEE_SS_80MHZ_MASK,\n\t\t\t\t.phy_cap_info[1] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP1_BEAMFORMEE_SS_80MHZ_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP1_BEAMFORMEE_SS_160MHZ_MASK,\n\t\t\t\t.phy_cap_info[2] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP2_SOUNDING_DIM_80MHZ_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP2_SOUNDING_DIM_160MHZ_MASK,\n\t\t\t\t.phy_cap_info[3] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_NG_16_SU_FEEDBACK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_NG_16_MU_FEEDBACK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_CODEBOOK_4_2_SU_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_CODEBOOK_7_5_MU_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_TRIG_SU_BF_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_TRIG_MU_BF_PART_BW_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_TRIG_CQI_FDBK,\n\t\t\t\t.phy_cap_info[4] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_PART_BW_DL_MU_MIMO |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_PSR_SR_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_POWER_BOOST_FACT_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_EHT_MU_PPDU_4_EHT_LTF_08_GI |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_MAX_NC_MASK,\n\t\t\t\t.phy_cap_info[5] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_NON_TRIG_CQI_FEEDBACK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_TX_LESS_242_TONE_RU_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_RX_LESS_242_TONE_RU_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_PPE_THRESHOLD_PRESENT |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_COMMON_NOMINAL_PKT_PAD_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_MAX_NUM_SUPP_EHT_LTF_MASK,\n\t\t\t\t.phy_cap_info[6] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP6_MAX_NUM_SUPP_EHT_LTF_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP6_MCS15_SUPP_MASK,\n\t\t\t\t.phy_cap_info[7] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP7_20MHZ_STA_RX_NDP_WIDER_BW |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP7_NON_OFDMA_UL_MU_MIMO_80MHZ |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP7_NON_OFDMA_UL_MU_MIMO_160MHZ |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP7_MU_BEAMFORMER_80MHZ |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP7_MU_BEAMFORMER_160MHZ,\n\t\t\t},\n\n\t\t\t \n\t\t\t.eht_mcs_nss_supp = {\n\t\t\t\t \n\t\t\t\t.bw._80 = {\n\t\t\t\t\t.rx_tx_mcs9_max_nss = 0x88,\n\t\t\t\t\t.rx_tx_mcs11_max_nss = 0x88,\n\t\t\t\t\t.rx_tx_mcs13_max_nss = 0x88,\n\t\t\t\t},\n\t\t\t\t.bw._160 = {\n\t\t\t\t\t.rx_tx_mcs9_max_nss = 0x88,\n\t\t\t\t\t.rx_tx_mcs11_max_nss = 0x88,\n\t\t\t\t\t.rx_tx_mcs13_max_nss = 0x88,\n\t\t\t\t},\n\t\t\t},\n\t\t\t \n\t\t},\n\t},\n\t{\n\t\t.types_mask = BIT(NL80211_IFTYPE_AP),\n\t\t.he_cap = {\n\t\t\t.has_he = true,\n\t\t\t.he_cap_elem = {\n\t\t\t\t.mac_cap_info[0] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP0_HTC_HE,\n\t\t\t\t.mac_cap_info[1] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,\n\t\t\t\t.mac_cap_info[2] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP2_BSR |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP2_MU_CASCADING |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP2_ACK_EN,\n\t\t\t\t.mac_cap_info[3] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP3_OMI_CONTROL |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_3,\n\t\t\t\t.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU,\n\t\t\t\t.phy_cap_info[0] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G,\n\t\t\t\t.phy_cap_info[1] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS,\n\t\t\t\t.phy_cap_info[2] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_UL_MU_PARTIAL_MU_MIMO,\n\n\t\t\t\t \n\t\t\t},\n\t\t\t.he_mcs_nss_supp = {\n\t\t\t\t.rx_mcs_80 = cpu_to_le16(0xfffa),\n\t\t\t\t.tx_mcs_80 = cpu_to_le16(0xfffa),\n\t\t\t\t.rx_mcs_160 = cpu_to_le16(0xfffa),\n\t\t\t\t.tx_mcs_160 = cpu_to_le16(0xfffa),\n\t\t\t\t.rx_mcs_80p80 = cpu_to_le16(0xfffa),\n\t\t\t\t.tx_mcs_80p80 = cpu_to_le16(0xfffa),\n\t\t\t},\n\t\t},\n\t\t.eht_cap = {\n\t\t\t.has_eht = true,\n\t\t\t.eht_cap_elem = {\n\t\t\t\t.mac_cap_info[0] =\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP0_EPCS_PRIO_ACCESS |\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP0_OM_CONTROL |\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP0_TRIG_TXOP_SHARING_MODE1,\n\t\t\t\t.phy_cap_info[0] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_242_TONE_RU_GT20MHZ |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_NDP_4_EHT_LFT_32_GI |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_PARTIAL_BW_UL_MU_MIMO |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_SU_BEAMFORMER |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_SU_BEAMFORMEE |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_BEAMFORMEE_SS_80MHZ_MASK,\n\t\t\t\t.phy_cap_info[1] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP1_BEAMFORMEE_SS_80MHZ_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP1_BEAMFORMEE_SS_160MHZ_MASK,\n\t\t\t\t.phy_cap_info[2] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP2_SOUNDING_DIM_80MHZ_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP2_SOUNDING_DIM_160MHZ_MASK,\n\t\t\t\t.phy_cap_info[3] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_NG_16_SU_FEEDBACK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_NG_16_MU_FEEDBACK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_CODEBOOK_4_2_SU_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_CODEBOOK_7_5_MU_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_TRIG_SU_BF_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_TRIG_MU_BF_PART_BW_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_TRIG_CQI_FDBK,\n\t\t\t\t.phy_cap_info[4] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_PART_BW_DL_MU_MIMO |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_PSR_SR_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_POWER_BOOST_FACT_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_EHT_MU_PPDU_4_EHT_LTF_08_GI |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_MAX_NC_MASK,\n\t\t\t\t.phy_cap_info[5] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_NON_TRIG_CQI_FEEDBACK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_TX_LESS_242_TONE_RU_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_RX_LESS_242_TONE_RU_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_PPE_THRESHOLD_PRESENT |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_COMMON_NOMINAL_PKT_PAD_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_MAX_NUM_SUPP_EHT_LTF_MASK,\n\t\t\t\t.phy_cap_info[6] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP6_MAX_NUM_SUPP_EHT_LTF_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP6_MCS15_SUPP_MASK,\n\t\t\t\t.phy_cap_info[7] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP7_20MHZ_STA_RX_NDP_WIDER_BW |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP7_NON_OFDMA_UL_MU_MIMO_80MHZ |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP7_NON_OFDMA_UL_MU_MIMO_160MHZ |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP7_MU_BEAMFORMER_80MHZ |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP7_MU_BEAMFORMER_160MHZ,\n\t\t\t},\n\n\t\t\t \n\t\t\t.eht_mcs_nss_supp = {\n\t\t\t\t \n\t\t\t\t.bw._80 = {\n\t\t\t\t\t.rx_tx_mcs9_max_nss = 0x88,\n\t\t\t\t\t.rx_tx_mcs11_max_nss = 0x88,\n\t\t\t\t\t.rx_tx_mcs13_max_nss = 0x88,\n\t\t\t\t},\n\t\t\t\t.bw._160 = {\n\t\t\t\t\t.rx_tx_mcs9_max_nss = 0x88,\n\t\t\t\t\t.rx_tx_mcs11_max_nss = 0x88,\n\t\t\t\t\t.rx_tx_mcs13_max_nss = 0x88,\n\t\t\t\t},\n\t\t\t},\n\t\t\t \n\t\t},\n\t},\n#ifdef CONFIG_MAC80211_MESH\n\t{\n\t\t \n\t\t.types_mask = BIT(NL80211_IFTYPE_MESH_POINT),\n\t\t.he_cap = {\n\t\t\t.has_he = true,\n\t\t\t.he_cap_elem = {\n\t\t\t\t.mac_cap_info[0] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP0_HTC_HE,\n\t\t\t\t.mac_cap_info[1] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,\n\t\t\t\t.mac_cap_info[2] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP2_ACK_EN,\n\t\t\t\t.mac_cap_info[3] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP3_OMI_CONTROL |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_3,\n\t\t\t\t.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU,\n\t\t\t\t.phy_cap_info[0] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G,\n\t\t\t\t.phy_cap_info[1] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS,\n\t\t\t\t.phy_cap_info[2] = 0,\n\n\t\t\t\t \n\t\t\t},\n\t\t\t.he_mcs_nss_supp = {\n\t\t\t\t.rx_mcs_80 = cpu_to_le16(0xfffa),\n\t\t\t\t.tx_mcs_80 = cpu_to_le16(0xfffa),\n\t\t\t\t.rx_mcs_160 = cpu_to_le16(0xfffa),\n\t\t\t\t.tx_mcs_160 = cpu_to_le16(0xfffa),\n\t\t\t\t.rx_mcs_80p80 = cpu_to_le16(0xfffa),\n\t\t\t\t.tx_mcs_80p80 = cpu_to_le16(0xfffa),\n\t\t\t},\n\t\t},\n\t},\n#endif\n};\n\nstatic const struct ieee80211_sband_iftype_data sband_capa_6ghz[] = {\n\t{\n\t\t \n\t\t.types_mask = BIT(NL80211_IFTYPE_STATION),\n\t\t.he_6ghz_capa = {\n\t\t\t.capa = cpu_to_le16(IEEE80211_HE_6GHZ_CAP_MIN_MPDU_START |\n\t\t\t\t\t    IEEE80211_HE_6GHZ_CAP_MAX_AMPDU_LEN_EXP |\n\t\t\t\t\t    IEEE80211_HE_6GHZ_CAP_MAX_MPDU_LEN |\n\t\t\t\t\t    IEEE80211_HE_6GHZ_CAP_SM_PS |\n\t\t\t\t\t    IEEE80211_HE_6GHZ_CAP_RD_RESPONDER |\n\t\t\t\t\t    IEEE80211_HE_6GHZ_CAP_TX_ANTPAT_CONS |\n\t\t\t\t\t    IEEE80211_HE_6GHZ_CAP_RX_ANTPAT_CONS),\n\t\t},\n\t\t.he_cap = {\n\t\t\t.has_he = true,\n\t\t\t.he_cap_elem = {\n\t\t\t\t.mac_cap_info[0] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP0_HTC_HE,\n\t\t\t\t.mac_cap_info[1] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,\n\t\t\t\t.mac_cap_info[2] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP2_BSR |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP2_MU_CASCADING |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP2_ACK_EN,\n\t\t\t\t.mac_cap_info[3] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP3_OMI_CONTROL |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_3,\n\t\t\t\t.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU,\n\t\t\t\t.phy_cap_info[0] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G,\n\t\t\t\t.phy_cap_info[1] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS,\n\t\t\t\t.phy_cap_info[2] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_UL_MU_PARTIAL_MU_MIMO,\n\n\t\t\t\t \n\t\t\t},\n\t\t\t.he_mcs_nss_supp = {\n\t\t\t\t.rx_mcs_80 = cpu_to_le16(0xfffa),\n\t\t\t\t.tx_mcs_80 = cpu_to_le16(0xfffa),\n\t\t\t\t.rx_mcs_160 = cpu_to_le16(0xfffa),\n\t\t\t\t.tx_mcs_160 = cpu_to_le16(0xfffa),\n\t\t\t\t.rx_mcs_80p80 = cpu_to_le16(0xfffa),\n\t\t\t\t.tx_mcs_80p80 = cpu_to_le16(0xfffa),\n\t\t\t},\n\t\t},\n\t\t.eht_cap = {\n\t\t\t.has_eht = true,\n\t\t\t.eht_cap_elem = {\n\t\t\t\t.mac_cap_info[0] =\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP0_EPCS_PRIO_ACCESS |\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP0_OM_CONTROL |\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP0_TRIG_TXOP_SHARING_MODE1,\n\t\t\t\t.phy_cap_info[0] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_320MHZ_IN_6GHZ |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_242_TONE_RU_GT20MHZ |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_NDP_4_EHT_LFT_32_GI |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_PARTIAL_BW_UL_MU_MIMO |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_SU_BEAMFORMER |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_SU_BEAMFORMEE |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_BEAMFORMEE_SS_80MHZ_MASK,\n\t\t\t\t.phy_cap_info[1] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP1_BEAMFORMEE_SS_80MHZ_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP1_BEAMFORMEE_SS_160MHZ_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP1_BEAMFORMEE_SS_320MHZ_MASK,\n\t\t\t\t.phy_cap_info[2] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP2_SOUNDING_DIM_80MHZ_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP2_SOUNDING_DIM_160MHZ_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP2_SOUNDING_DIM_320MHZ_MASK,\n\t\t\t\t.phy_cap_info[3] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_NG_16_SU_FEEDBACK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_NG_16_MU_FEEDBACK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_CODEBOOK_4_2_SU_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_CODEBOOK_7_5_MU_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_TRIG_SU_BF_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_TRIG_MU_BF_PART_BW_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_TRIG_CQI_FDBK,\n\t\t\t\t.phy_cap_info[4] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_PART_BW_DL_MU_MIMO |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_PSR_SR_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_POWER_BOOST_FACT_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_EHT_MU_PPDU_4_EHT_LTF_08_GI |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_MAX_NC_MASK,\n\t\t\t\t.phy_cap_info[5] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_NON_TRIG_CQI_FEEDBACK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_TX_LESS_242_TONE_RU_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_RX_LESS_242_TONE_RU_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_PPE_THRESHOLD_PRESENT |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_COMMON_NOMINAL_PKT_PAD_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_MAX_NUM_SUPP_EHT_LTF_MASK,\n\t\t\t\t.phy_cap_info[6] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP6_MAX_NUM_SUPP_EHT_LTF_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP6_MCS15_SUPP_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP6_EHT_DUP_6GHZ_SUPP,\n\t\t\t\t.phy_cap_info[7] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP7_20MHZ_STA_RX_NDP_WIDER_BW |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP7_NON_OFDMA_UL_MU_MIMO_80MHZ |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP7_NON_OFDMA_UL_MU_MIMO_160MHZ |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP7_NON_OFDMA_UL_MU_MIMO_320MHZ |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP7_MU_BEAMFORMER_80MHZ |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP7_MU_BEAMFORMER_160MHZ |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP7_MU_BEAMFORMER_320MHZ,\n\t\t\t},\n\n\t\t\t \n\t\t\t.eht_mcs_nss_supp = {\n\t\t\t\t \n\t\t\t\t.bw._80 = {\n\t\t\t\t\t.rx_tx_mcs9_max_nss = 0x88,\n\t\t\t\t\t.rx_tx_mcs11_max_nss = 0x88,\n\t\t\t\t\t.rx_tx_mcs13_max_nss = 0x88,\n\t\t\t\t},\n\t\t\t\t.bw._160 = {\n\t\t\t\t\t.rx_tx_mcs9_max_nss = 0x88,\n\t\t\t\t\t.rx_tx_mcs11_max_nss = 0x88,\n\t\t\t\t\t.rx_tx_mcs13_max_nss = 0x88,\n\t\t\t\t},\n\t\t\t\t.bw._320 = {\n\t\t\t\t\t.rx_tx_mcs9_max_nss = 0x88,\n\t\t\t\t\t.rx_tx_mcs11_max_nss = 0x88,\n\t\t\t\t\t.rx_tx_mcs13_max_nss = 0x88,\n\t\t\t\t},\n\t\t\t},\n\t\t\t \n\t\t},\n\t},\n\t{\n\t\t.types_mask = BIT(NL80211_IFTYPE_AP),\n\t\t.he_6ghz_capa = {\n\t\t\t.capa = cpu_to_le16(IEEE80211_HE_6GHZ_CAP_MIN_MPDU_START |\n\t\t\t\t\t    IEEE80211_HE_6GHZ_CAP_MAX_AMPDU_LEN_EXP |\n\t\t\t\t\t    IEEE80211_HE_6GHZ_CAP_MAX_MPDU_LEN |\n\t\t\t\t\t    IEEE80211_HE_6GHZ_CAP_SM_PS |\n\t\t\t\t\t    IEEE80211_HE_6GHZ_CAP_RD_RESPONDER |\n\t\t\t\t\t    IEEE80211_HE_6GHZ_CAP_TX_ANTPAT_CONS |\n\t\t\t\t\t    IEEE80211_HE_6GHZ_CAP_RX_ANTPAT_CONS),\n\t\t},\n\t\t.he_cap = {\n\t\t\t.has_he = true,\n\t\t\t.he_cap_elem = {\n\t\t\t\t.mac_cap_info[0] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP0_HTC_HE,\n\t\t\t\t.mac_cap_info[1] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,\n\t\t\t\t.mac_cap_info[2] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP2_BSR |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP2_MU_CASCADING |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP2_ACK_EN,\n\t\t\t\t.mac_cap_info[3] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP3_OMI_CONTROL |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_3,\n\t\t\t\t.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU,\n\t\t\t\t.phy_cap_info[0] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G,\n\t\t\t\t.phy_cap_info[1] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS,\n\t\t\t\t.phy_cap_info[2] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP2_UL_MU_PARTIAL_MU_MIMO,\n\n\t\t\t\t \n\t\t\t},\n\t\t\t.he_mcs_nss_supp = {\n\t\t\t\t.rx_mcs_80 = cpu_to_le16(0xfffa),\n\t\t\t\t.tx_mcs_80 = cpu_to_le16(0xfffa),\n\t\t\t\t.rx_mcs_160 = cpu_to_le16(0xfffa),\n\t\t\t\t.tx_mcs_160 = cpu_to_le16(0xfffa),\n\t\t\t\t.rx_mcs_80p80 = cpu_to_le16(0xfffa),\n\t\t\t\t.tx_mcs_80p80 = cpu_to_le16(0xfffa),\n\t\t\t},\n\t\t},\n\t\t.eht_cap = {\n\t\t\t.has_eht = true,\n\t\t\t.eht_cap_elem = {\n\t\t\t\t.mac_cap_info[0] =\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP0_EPCS_PRIO_ACCESS |\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP0_OM_CONTROL |\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP0_TRIG_TXOP_SHARING_MODE1,\n\t\t\t\t.phy_cap_info[0] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_320MHZ_IN_6GHZ |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_242_TONE_RU_GT20MHZ |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_NDP_4_EHT_LFT_32_GI |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_PARTIAL_BW_UL_MU_MIMO |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_SU_BEAMFORMER |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_SU_BEAMFORMEE |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP0_BEAMFORMEE_SS_80MHZ_MASK,\n\t\t\t\t.phy_cap_info[1] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP1_BEAMFORMEE_SS_80MHZ_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP1_BEAMFORMEE_SS_160MHZ_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP1_BEAMFORMEE_SS_320MHZ_MASK,\n\t\t\t\t.phy_cap_info[2] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP2_SOUNDING_DIM_80MHZ_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP2_SOUNDING_DIM_160MHZ_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP2_SOUNDING_DIM_320MHZ_MASK,\n\t\t\t\t.phy_cap_info[3] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_NG_16_SU_FEEDBACK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_NG_16_MU_FEEDBACK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_CODEBOOK_4_2_SU_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_CODEBOOK_7_5_MU_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_TRIG_SU_BF_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_TRIG_MU_BF_PART_BW_FDBK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP3_TRIG_CQI_FDBK,\n\t\t\t\t.phy_cap_info[4] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_PART_BW_DL_MU_MIMO |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_PSR_SR_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_POWER_BOOST_FACT_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_EHT_MU_PPDU_4_EHT_LTF_08_GI |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP4_MAX_NC_MASK,\n\t\t\t\t.phy_cap_info[5] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_NON_TRIG_CQI_FEEDBACK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_TX_LESS_242_TONE_RU_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_RX_LESS_242_TONE_RU_SUPP |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_PPE_THRESHOLD_PRESENT |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_COMMON_NOMINAL_PKT_PAD_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP5_MAX_NUM_SUPP_EHT_LTF_MASK,\n\t\t\t\t.phy_cap_info[6] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP6_MAX_NUM_SUPP_EHT_LTF_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP6_MCS15_SUPP_MASK |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP6_EHT_DUP_6GHZ_SUPP,\n\t\t\t\t.phy_cap_info[7] =\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP7_20MHZ_STA_RX_NDP_WIDER_BW |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP7_NON_OFDMA_UL_MU_MIMO_80MHZ |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP7_NON_OFDMA_UL_MU_MIMO_160MHZ |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP7_NON_OFDMA_UL_MU_MIMO_320MHZ |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP7_MU_BEAMFORMER_80MHZ |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP7_MU_BEAMFORMER_160MHZ |\n\t\t\t\t\tIEEE80211_EHT_PHY_CAP7_MU_BEAMFORMER_320MHZ,\n\t\t\t},\n\n\t\t\t \n\t\t\t.eht_mcs_nss_supp = {\n\t\t\t\t \n\t\t\t\t.bw._80 = {\n\t\t\t\t\t.rx_tx_mcs9_max_nss = 0x88,\n\t\t\t\t\t.rx_tx_mcs11_max_nss = 0x88,\n\t\t\t\t\t.rx_tx_mcs13_max_nss = 0x88,\n\t\t\t\t},\n\t\t\t\t.bw._160 = {\n\t\t\t\t\t.rx_tx_mcs9_max_nss = 0x88,\n\t\t\t\t\t.rx_tx_mcs11_max_nss = 0x88,\n\t\t\t\t\t.rx_tx_mcs13_max_nss = 0x88,\n\t\t\t\t},\n\t\t\t\t.bw._320 = {\n\t\t\t\t\t.rx_tx_mcs9_max_nss = 0x88,\n\t\t\t\t\t.rx_tx_mcs11_max_nss = 0x88,\n\t\t\t\t\t.rx_tx_mcs13_max_nss = 0x88,\n\t\t\t\t},\n\t\t\t},\n\t\t\t \n\t\t},\n\t},\n#ifdef CONFIG_MAC80211_MESH\n\t{\n\t\t \n\t\t.types_mask = BIT(NL80211_IFTYPE_MESH_POINT),\n\t\t.he_6ghz_capa = {\n\t\t\t.capa = cpu_to_le16(IEEE80211_HE_6GHZ_CAP_MIN_MPDU_START |\n\t\t\t\t\t    IEEE80211_HE_6GHZ_CAP_MAX_AMPDU_LEN_EXP |\n\t\t\t\t\t    IEEE80211_HE_6GHZ_CAP_MAX_MPDU_LEN |\n\t\t\t\t\t    IEEE80211_HE_6GHZ_CAP_SM_PS |\n\t\t\t\t\t    IEEE80211_HE_6GHZ_CAP_RD_RESPONDER |\n\t\t\t\t\t    IEEE80211_HE_6GHZ_CAP_TX_ANTPAT_CONS |\n\t\t\t\t\t    IEEE80211_HE_6GHZ_CAP_RX_ANTPAT_CONS),\n\t\t},\n\t\t.he_cap = {\n\t\t\t.has_he = true,\n\t\t\t.he_cap_elem = {\n\t\t\t\t.mac_cap_info[0] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP0_HTC_HE,\n\t\t\t\t.mac_cap_info[1] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP1_MULTI_TID_AGG_RX_QOS_8,\n\t\t\t\t.mac_cap_info[2] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP2_ACK_EN,\n\t\t\t\t.mac_cap_info[3] =\n\t\t\t\t\tIEEE80211_HE_MAC_CAP3_OMI_CONTROL |\n\t\t\t\t\tIEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_3,\n\t\t\t\t.mac_cap_info[4] = IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU,\n\t\t\t\t.phy_cap_info[0] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G,\n\t\t\t\t.phy_cap_info[1] =\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP1_MIDAMBLE_RX_TX_MAX_NSTS,\n\t\t\t\t.phy_cap_info[2] = 0,\n\n\t\t\t\t \n\t\t\t},\n\t\t\t.he_mcs_nss_supp = {\n\t\t\t\t.rx_mcs_80 = cpu_to_le16(0xfffa),\n\t\t\t\t.tx_mcs_80 = cpu_to_le16(0xfffa),\n\t\t\t\t.rx_mcs_160 = cpu_to_le16(0xfffa),\n\t\t\t\t.tx_mcs_160 = cpu_to_le16(0xfffa),\n\t\t\t\t.rx_mcs_80p80 = cpu_to_le16(0xfffa),\n\t\t\t\t.tx_mcs_80p80 = cpu_to_le16(0xfffa),\n\t\t\t},\n\t\t},\n\t},\n#endif\n};\n\nstatic void mac80211_hwsim_sband_capab(struct ieee80211_supported_band *sband)\n{\n\tu16 n_iftype_data;\n\n\tif (sband->band == NL80211_BAND_2GHZ) {\n\t\tn_iftype_data = ARRAY_SIZE(sband_capa_2ghz);\n\t\tsband->iftype_data =\n\t\t\t(struct ieee80211_sband_iftype_data *)sband_capa_2ghz;\n\t} else if (sband->band == NL80211_BAND_5GHZ) {\n\t\tn_iftype_data = ARRAY_SIZE(sband_capa_5ghz);\n\t\tsband->iftype_data =\n\t\t\t(struct ieee80211_sband_iftype_data *)sband_capa_5ghz;\n\t} else if (sband->band == NL80211_BAND_6GHZ) {\n\t\tn_iftype_data = ARRAY_SIZE(sband_capa_6ghz);\n\t\tsband->iftype_data =\n\t\t\t(struct ieee80211_sband_iftype_data *)sband_capa_6ghz;\n\t} else {\n\t\treturn;\n\t}\n\n\tsband->n_iftype_data = n_iftype_data;\n}\n\n#ifdef CONFIG_MAC80211_MESH\n#define HWSIM_MESH_BIT BIT(NL80211_IFTYPE_MESH_POINT)\n#else\n#define HWSIM_MESH_BIT 0\n#endif\n\n#define HWSIM_DEFAULT_IF_LIMIT \\\n\t(BIT(NL80211_IFTYPE_STATION) | \\\n\t BIT(NL80211_IFTYPE_P2P_CLIENT) | \\\n\t BIT(NL80211_IFTYPE_AP) | \\\n\t BIT(NL80211_IFTYPE_P2P_GO) | \\\n\t HWSIM_MESH_BIT)\n\n#define HWSIM_IFTYPE_SUPPORT_MASK \\\n\t(BIT(NL80211_IFTYPE_STATION) | \\\n\t BIT(NL80211_IFTYPE_AP) | \\\n\t BIT(NL80211_IFTYPE_P2P_CLIENT) | \\\n\t BIT(NL80211_IFTYPE_P2P_GO) | \\\n\t BIT(NL80211_IFTYPE_ADHOC) | \\\n\t BIT(NL80211_IFTYPE_MESH_POINT) | \\\n\t BIT(NL80211_IFTYPE_OCB))\n\nstatic int mac80211_hwsim_new_radio(struct genl_info *info,\n\t\t\t\t    struct hwsim_new_radio_params *param)\n{\n\tint err;\n\tu8 addr[ETH_ALEN];\n\tstruct mac80211_hwsim_data *data;\n\tstruct ieee80211_hw *hw;\n\tenum nl80211_band band;\n\tconst struct ieee80211_ops *ops = &mac80211_hwsim_ops;\n\tstruct net *net;\n\tint idx, i;\n\tint n_limits = 0;\n\n\tif (WARN_ON(param->channels > 1 && !param->use_chanctx))\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\tidx = hwsim_radio_idx++;\n\tspin_unlock_bh(&hwsim_radio_lock);\n\n\tif (param->mlo)\n\t\tops = &mac80211_hwsim_mlo_ops;\n\telse if (param->use_chanctx)\n\t\tops = &mac80211_hwsim_mchan_ops;\n\thw = ieee80211_alloc_hw_nm(sizeof(*data), ops, param->hwname);\n\tif (!hw) {\n\t\tpr_debug(\"mac80211_hwsim: ieee80211_alloc_hw failed\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\t \n\tparam->hwname = wiphy_name(hw->wiphy);\n\n\tif (info)\n\t\tnet = genl_info_net(info);\n\telse\n\t\tnet = &init_net;\n\twiphy_net_set(hw->wiphy, net);\n\n\tdata = hw->priv;\n\tdata->hw = hw;\n\n\tdata->dev = device_create(hwsim_class, NULL, 0, hw, \"hwsim%d\", idx);\n\tif (IS_ERR(data->dev)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"mac80211_hwsim: device_create failed (%ld)\\n\",\n\t\t       PTR_ERR(data->dev));\n\t\terr = -ENOMEM;\n\t\tgoto failed_drvdata;\n\t}\n\tdata->dev->driver = &mac80211_hwsim_driver.driver;\n\terr = device_bind_driver(data->dev);\n\tif (err != 0) {\n\t\tpr_debug(\"mac80211_hwsim: device_bind_driver failed (%d)\\n\",\n\t\t       err);\n\t\tgoto failed_bind;\n\t}\n\n\tskb_queue_head_init(&data->pending);\n\n\tSET_IEEE80211_DEV(hw, data->dev);\n\tif (!param->perm_addr) {\n\t\teth_zero_addr(addr);\n\t\taddr[0] = 0x02;\n\t\taddr[3] = idx >> 8;\n\t\taddr[4] = idx;\n\t\tmemcpy(data->addresses[0].addr, addr, ETH_ALEN);\n\t\t \n\t\tmemcpy(data->addresses[1].addr, addr, ETH_ALEN);\n\t\tdata->addresses[1].addr[0] |= 0x40;\n\t\thw->wiphy->n_addresses = 2;\n\t\thw->wiphy->addresses = data->addresses;\n\t\t \n\t} else {\n\t\tmemcpy(data->addresses[0].addr, param->perm_addr, ETH_ALEN);\n\t\t \n\t\tmemcpy(data->addresses[1].addr, param->perm_addr, ETH_ALEN);\n\t\thw->wiphy->n_addresses = 2;\n\t\thw->wiphy->addresses = data->addresses;\n\t}\n\n\tdata->channels = param->channels;\n\tdata->use_chanctx = param->use_chanctx;\n\tdata->idx = idx;\n\tdata->destroy_on_close = param->destroy_on_close;\n\tif (info)\n\t\tdata->portid = info->snd_portid;\n\n\t \n\tif (param->iftypes & BIT(NL80211_IFTYPE_ADHOC)) {\n\t\tdata->if_limits[n_limits].max = 1;\n\t\tdata->if_limits[n_limits].types = BIT(NL80211_IFTYPE_ADHOC);\n\t\tn_limits++;\n\t}\n\n\tif (param->iftypes & HWSIM_DEFAULT_IF_LIMIT) {\n\t\tdata->if_limits[n_limits].max = 2048;\n\t\t \n\t\tdata->if_limits[n_limits].types =\n\t\t\t\t\tHWSIM_DEFAULT_IF_LIMIT & param->iftypes;\n\t\tn_limits++;\n\t}\n\n\tif (param->iftypes & BIT(NL80211_IFTYPE_P2P_DEVICE)) {\n\t\tdata->if_limits[n_limits].max = 1;\n\t\tdata->if_limits[n_limits].types =\n\t\t\t\t\t\tBIT(NL80211_IFTYPE_P2P_DEVICE);\n\t\tn_limits++;\n\t}\n\n\tif (data->use_chanctx) {\n\t\thw->wiphy->max_scan_ssids = 255;\n\t\thw->wiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;\n\t\thw->wiphy->max_remain_on_channel_duration = 1000;\n\t\tdata->if_combination.radar_detect_widths = 0;\n\t\tdata->if_combination.num_different_channels = data->channels;\n\t} else {\n\t\tdata->if_combination.num_different_channels = 1;\n\t\tdata->if_combination.radar_detect_widths =\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_5) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_10) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_20_NOHT) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_20) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_40) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_80) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_160);\n\t}\n\n\tif (!n_limits) {\n\t\terr = -EINVAL;\n\t\tgoto failed_hw;\n\t}\n\n\tdata->if_combination.max_interfaces = 0;\n\tfor (i = 0; i < n_limits; i++)\n\t\tdata->if_combination.max_interfaces +=\n\t\t\tdata->if_limits[i].max;\n\n\tdata->if_combination.n_limits = n_limits;\n\tdata->if_combination.limits = data->if_limits;\n\n\t \n\tif (data->if_combination.max_interfaces > 1) {\n\t\thw->wiphy->iface_combinations = &data->if_combination;\n\t\thw->wiphy->n_iface_combinations = 1;\n\t}\n\n\tif (param->ciphers) {\n\t\tmemcpy(data->ciphers, param->ciphers,\n\t\t       param->n_ciphers * sizeof(u32));\n\t\thw->wiphy->cipher_suites = data->ciphers;\n\t\thw->wiphy->n_cipher_suites = param->n_ciphers;\n\t}\n\n\thw->wiphy->mbssid_max_interfaces = 8;\n\thw->wiphy->ema_max_profile_periodicity = 3;\n\n\tdata->rx_rssi = DEFAULT_RX_RSSI;\n\n\tINIT_DELAYED_WORK(&data->roc_start, hw_roc_start);\n\tINIT_DELAYED_WORK(&data->roc_done, hw_roc_done);\n\tINIT_DELAYED_WORK(&data->hw_scan, hw_scan_work);\n\n\thw->queues = 5;\n\thw->offchannel_tx_hw_queue = 4;\n\n\tieee80211_hw_set(hw, SUPPORT_FAST_XMIT);\n\tieee80211_hw_set(hw, CHANCTX_STA_CSA);\n\tieee80211_hw_set(hw, SUPPORTS_HT_CCK_RATES);\n\tieee80211_hw_set(hw, QUEUE_CONTROL);\n\tieee80211_hw_set(hw, WANT_MONITOR_VIF);\n\tieee80211_hw_set(hw, AMPDU_AGGREGATION);\n\tieee80211_hw_set(hw, MFP_CAPABLE);\n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\tieee80211_hw_set(hw, SUPPORTS_PS);\n\tieee80211_hw_set(hw, REPORTS_TX_ACK_STATUS);\n\tieee80211_hw_set(hw, TDLS_WIDER_BW);\n\tieee80211_hw_set(hw, SUPPORTS_MULTI_BSSID);\n\n\tif (param->mlo) {\n\t\thw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_MLO;\n\t\tieee80211_hw_set(hw, HAS_RATE_CONTROL);\n\t\tieee80211_hw_set(hw, SUPPORTS_DYNAMIC_PS);\n\t\tieee80211_hw_set(hw, CONNECTION_MONITOR);\n\t\tieee80211_hw_set(hw, AP_LINK_PS);\n\t} else {\n\t\tieee80211_hw_set(hw, HOST_BROADCAST_PS_BUFFERING);\n\t\tieee80211_hw_set(hw, PS_NULLFUNC_STACK);\n\t\tif (rctbl)\n\t\t\tieee80211_hw_set(hw, SUPPORTS_RC_TABLE);\n\t}\n\n\thw->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;\n\thw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS |\n\t\t\t    WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL |\n\t\t\t    WIPHY_FLAG_AP_UAPSD |\n\t\t\t    WIPHY_FLAG_SUPPORTS_5_10_MHZ |\n\t\t\t    WIPHY_FLAG_HAS_CHANNEL_SWITCH;\n\thw->wiphy->features |= NL80211_FEATURE_ACTIVE_MONITOR |\n\t\t\t       NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE |\n\t\t\t       NL80211_FEATURE_STATIC_SMPS |\n\t\t\t       NL80211_FEATURE_DYNAMIC_SMPS |\n\t\t\t       NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR;\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_VHT_IBSS);\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_BEACON_PROTECTION);\n\twiphy_ext_feature_set(hw->wiphy,\n\t\t\t      NL80211_EXT_FEATURE_MULTICAST_REGISTRATIONS);\n\twiphy_ext_feature_set(hw->wiphy,\n\t\t\t      NL80211_EXT_FEATURE_BEACON_RATE_LEGACY);\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER);\n\n\twiphy_ext_feature_set(hw->wiphy,\n\t\t\t      NL80211_EXT_FEATURE_SCAN_MIN_PREQ_CONTENT);\n\n\thw->wiphy->interface_modes = param->iftypes;\n\n\t \n\thw->vif_data_size = sizeof(struct hwsim_vif_priv);\n\thw->sta_data_size = sizeof(struct hwsim_sta_priv);\n\thw->chanctx_data_size = sizeof(struct hwsim_chanctx_priv);\n\n\tmemcpy(data->channels_2ghz, hwsim_channels_2ghz,\n\t\tsizeof(hwsim_channels_2ghz));\n\tmemcpy(data->channels_5ghz, hwsim_channels_5ghz,\n\t\tsizeof(hwsim_channels_5ghz));\n\tmemcpy(data->channels_6ghz, hwsim_channels_6ghz,\n\t\tsizeof(hwsim_channels_6ghz));\n\tmemcpy(data->channels_s1g, hwsim_channels_s1g,\n\t       sizeof(hwsim_channels_s1g));\n\tmemcpy(data->rates, hwsim_rates, sizeof(hwsim_rates));\n\n\tfor (band = NL80211_BAND_2GHZ; band < NUM_NL80211_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband = &data->bands[band];\n\n\t\tsband->band = band;\n\n\t\tswitch (band) {\n\t\tcase NL80211_BAND_2GHZ:\n\t\t\tsband->channels = data->channels_2ghz;\n\t\t\tsband->n_channels = ARRAY_SIZE(hwsim_channels_2ghz);\n\t\t\tsband->bitrates = data->rates;\n\t\t\tsband->n_bitrates = ARRAY_SIZE(hwsim_rates);\n\t\t\tbreak;\n\t\tcase NL80211_BAND_5GHZ:\n\t\t\tsband->channels = data->channels_5ghz;\n\t\t\tsband->n_channels = ARRAY_SIZE(hwsim_channels_5ghz);\n\t\t\tsband->bitrates = data->rates + 4;\n\t\t\tsband->n_bitrates = ARRAY_SIZE(hwsim_rates) - 4;\n\n\t\t\tsband->vht_cap.vht_supported = true;\n\t\t\tsband->vht_cap.cap =\n\t\t\t\tIEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454 |\n\t\t\t\tIEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ |\n\t\t\t\tIEEE80211_VHT_CAP_RXLDPC |\n\t\t\t\tIEEE80211_VHT_CAP_SHORT_GI_80 |\n\t\t\t\tIEEE80211_VHT_CAP_SHORT_GI_160 |\n\t\t\t\tIEEE80211_VHT_CAP_TXSTBC |\n\t\t\t\tIEEE80211_VHT_CAP_RXSTBC_4 |\n\t\t\t\tIEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK;\n\t\t\tsband->vht_cap.vht_mcs.rx_mcs_map =\n\t\t\t\tcpu_to_le16(IEEE80211_VHT_MCS_SUPPORT_0_9 << 0 |\n\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 2 |\n\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 4 |\n\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 6 |\n\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 8 |\n\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 10 |\n\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 12 |\n\t\t\t\t\t    IEEE80211_VHT_MCS_SUPPORT_0_9 << 14);\n\t\t\tsband->vht_cap.vht_mcs.tx_mcs_map =\n\t\t\t\tsband->vht_cap.vht_mcs.rx_mcs_map;\n\t\t\tbreak;\n\t\tcase NL80211_BAND_6GHZ:\n\t\t\tsband->channels = data->channels_6ghz;\n\t\t\tsband->n_channels = ARRAY_SIZE(hwsim_channels_6ghz);\n\t\t\tsband->bitrates = data->rates + 4;\n\t\t\tsband->n_bitrates = ARRAY_SIZE(hwsim_rates) - 4;\n\t\t\tbreak;\n\t\tcase NL80211_BAND_S1GHZ:\n\t\t\tmemcpy(&sband->s1g_cap, &hwsim_s1g_cap,\n\t\t\t       sizeof(sband->s1g_cap));\n\t\t\tsband->channels = data->channels_s1g;\n\t\t\tsband->n_channels = ARRAY_SIZE(hwsim_channels_s1g);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (band != NL80211_BAND_6GHZ){\n\t\t\tsband->ht_cap.ht_supported = true;\n\t\t\tsband->ht_cap.cap = IEEE80211_HT_CAP_SUP_WIDTH_20_40 |\n\t\t\t\t\t    IEEE80211_HT_CAP_GRN_FLD |\n\t\t\t\t\t    IEEE80211_HT_CAP_SGI_20 |\n\t\t\t\t\t    IEEE80211_HT_CAP_SGI_40 |\n\t\t\t\t\t    IEEE80211_HT_CAP_DSSSCCK40;\n\t\t\tsband->ht_cap.ampdu_factor = 0x3;\n\t\t\tsband->ht_cap.ampdu_density = 0x6;\n\t\t\tmemset(&sband->ht_cap.mcs, 0,\n\t\t\t       sizeof(sband->ht_cap.mcs));\n\t\t\tsband->ht_cap.mcs.rx_mask[0] = 0xff;\n\t\t\tsband->ht_cap.mcs.rx_mask[1] = 0xff;\n\t\t\tsband->ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\n\t\t}\n\n\t\tmac80211_hwsim_sband_capab(sband);\n\n\t\thw->wiphy->bands[band] = sband;\n\t}\n\n\t \n\tdata->group = 1;\n\tmutex_init(&data->mutex);\n\n\tdata->netgroup = hwsim_net_get_netgroup(net);\n\tdata->wmediumd = hwsim_net_get_wmediumd(net);\n\n\t \n\thw->max_rates = 4;\n\thw->max_rate_tries = 11;\n\n\thw->wiphy->vendor_commands = mac80211_hwsim_vendor_commands;\n\thw->wiphy->n_vendor_commands =\n\t\tARRAY_SIZE(mac80211_hwsim_vendor_commands);\n\thw->wiphy->vendor_events = mac80211_hwsim_vendor_events;\n\thw->wiphy->n_vendor_events = ARRAY_SIZE(mac80211_hwsim_vendor_events);\n\n\tif (param->reg_strict)\n\t\thw->wiphy->regulatory_flags |= REGULATORY_STRICT_REG;\n\tif (param->regd) {\n\t\tdata->regd = param->regd;\n\t\thw->wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;\n\t\twiphy_apply_custom_regulatory(hw->wiphy, param->regd);\n\t\t \n\t\tschedule_timeout_interruptible(1);\n\t}\n\n\tif (param->no_vif)\n\t\tieee80211_hw_set(hw, NO_AUTO_VIF);\n\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\tfor (i = 0; i < ARRAY_SIZE(data->link_data); i++) {\n\t\thrtimer_init(&data->link_data[i].beacon_timer, CLOCK_MONOTONIC,\n\t\t\t     HRTIMER_MODE_ABS_SOFT);\n\t\tdata->link_data[i].beacon_timer.function =\n\t\t\tmac80211_hwsim_beacon;\n\t\tdata->link_data[i].link_id = i;\n\t}\n\n\terr = ieee80211_register_hw(hw);\n\tif (err < 0) {\n\t\tpr_debug(\"mac80211_hwsim: ieee80211_register_hw failed (%d)\\n\",\n\t\t       err);\n\t\tgoto failed_hw;\n\t}\n\n\twiphy_dbg(hw->wiphy, \"hwaddr %pM registered\\n\", hw->wiphy->perm_addr);\n\n\tif (param->reg_alpha2) {\n\t\tdata->alpha2[0] = param->reg_alpha2[0];\n\t\tdata->alpha2[1] = param->reg_alpha2[1];\n\t\tregulatory_hint(hw->wiphy, param->reg_alpha2);\n\t}\n\n\tdata->debugfs = debugfs_create_dir(\"hwsim\", hw->wiphy->debugfsdir);\n\tdebugfs_create_file(\"ps\", 0666, data->debugfs, data, &hwsim_fops_ps);\n\tdebugfs_create_file(\"group\", 0666, data->debugfs, data,\n\t\t\t    &hwsim_fops_group);\n\tdebugfs_create_file(\"rx_rssi\", 0666, data->debugfs, data,\n\t\t\t    &hwsim_fops_rx_rssi);\n\tif (!data->use_chanctx)\n\t\tdebugfs_create_file(\"dfs_simulate_radar\", 0222,\n\t\t\t\t    data->debugfs,\n\t\t\t\t    data, &hwsim_simulate_radar);\n\n\tif (param->pmsr_capa) {\n\t\tdata->pmsr_capa = *param->pmsr_capa;\n\t\thw->wiphy->pmsr_capa = &data->pmsr_capa;\n\t}\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\terr = rhashtable_insert_fast(&hwsim_radios_rht, &data->rht,\n\t\t\t\t     hwsim_rht_params);\n\tif (err < 0) {\n\t\tif (info) {\n\t\t\tGENL_SET_ERR_MSG(info, \"perm addr already present\");\n\t\t\tNL_SET_BAD_ATTR(info->extack,\n\t\t\t\t\tinfo->attrs[HWSIM_ATTR_PERM_ADDR]);\n\t\t}\n\t\tspin_unlock_bh(&hwsim_radio_lock);\n\t\tgoto failed_final_insert;\n\t}\n\n\tlist_add_tail(&data->list, &hwsim_radios);\n\thwsim_radios_generation++;\n\tspin_unlock_bh(&hwsim_radio_lock);\n\n\thwsim_mcast_new_radio(idx, info, param);\n\n\treturn idx;\n\nfailed_final_insert:\n\tdebugfs_remove_recursive(data->debugfs);\n\tieee80211_unregister_hw(data->hw);\nfailed_hw:\n\tdevice_release_driver(data->dev);\nfailed_bind:\n\tdevice_unregister(data->dev);\nfailed_drvdata:\n\tieee80211_free_hw(hw);\nfailed:\n\treturn err;\n}\n\nstatic void hwsim_mcast_del_radio(int id, const char *hwname,\n\t\t\t\t  struct genl_info *info)\n{\n\tstruct sk_buff *skb;\n\tvoid *data;\n\tint ret;\n\n\tskb = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn;\n\n\tdata = genlmsg_put(skb, 0, 0, &hwsim_genl_family, 0,\n\t\t\t   HWSIM_CMD_DEL_RADIO);\n\tif (!data)\n\t\tgoto error;\n\n\tret = nla_put_u32(skb, HWSIM_ATTR_RADIO_ID, id);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = nla_put(skb, HWSIM_ATTR_RADIO_NAME, strlen(hwname),\n\t\t      hwname);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tgenlmsg_end(skb, data);\n\n\thwsim_mcast_config_msg(skb, info);\n\n\treturn;\n\nerror:\n\tnlmsg_free(skb);\n}\n\nstatic void mac80211_hwsim_del_radio(struct mac80211_hwsim_data *data,\n\t\t\t\t     const char *hwname,\n\t\t\t\t     struct genl_info *info)\n{\n\thwsim_mcast_del_radio(data->idx, hwname, info);\n\tdebugfs_remove_recursive(data->debugfs);\n\tieee80211_unregister_hw(data->hw);\n\tdevice_release_driver(data->dev);\n\tdevice_unregister(data->dev);\n\tieee80211_free_hw(data->hw);\n}\n\nstatic int mac80211_hwsim_get_radio(struct sk_buff *skb,\n\t\t\t\t    struct mac80211_hwsim_data *data,\n\t\t\t\t    u32 portid, u32 seq,\n\t\t\t\t    struct netlink_callback *cb, int flags)\n{\n\tvoid *hdr;\n\tstruct hwsim_new_radio_params param = { };\n\tint res = -EMSGSIZE;\n\n\thdr = genlmsg_put(skb, portid, seq, &hwsim_genl_family, flags,\n\t\t\t  HWSIM_CMD_GET_RADIO);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (cb)\n\t\tgenl_dump_check_consistent(cb, hdr);\n\n\tif (data->alpha2[0] && data->alpha2[1])\n\t\tparam.reg_alpha2 = data->alpha2;\n\n\tparam.reg_strict = !!(data->hw->wiphy->regulatory_flags &\n\t\t\t\t\tREGULATORY_STRICT_REG);\n\tparam.p2p_device = !!(data->hw->wiphy->interface_modes &\n\t\t\t\t\tBIT(NL80211_IFTYPE_P2P_DEVICE));\n\tparam.use_chanctx = data->use_chanctx;\n\tparam.regd = data->regd;\n\tparam.channels = data->channels;\n\tparam.hwname = wiphy_name(data->hw->wiphy);\n\tparam.pmsr_capa = &data->pmsr_capa;\n\n\tres = append_radio_msg(skb, data->idx, &param);\n\tif (res < 0)\n\t\tgoto out_err;\n\n\tgenlmsg_end(skb, hdr);\n\treturn 0;\n\nout_err:\n\tgenlmsg_cancel(skb, hdr);\n\treturn res;\n}\n\nstatic void mac80211_hwsim_free(void)\n{\n\tstruct mac80211_hwsim_data *data;\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\twhile ((data = list_first_entry_or_null(&hwsim_radios,\n\t\t\t\t\t\tstruct mac80211_hwsim_data,\n\t\t\t\t\t\tlist))) {\n\t\tlist_del(&data->list);\n\t\tspin_unlock_bh(&hwsim_radio_lock);\n\t\tmac80211_hwsim_del_radio(data, wiphy_name(data->hw->wiphy),\n\t\t\t\t\t NULL);\n\t\tspin_lock_bh(&hwsim_radio_lock);\n\t}\n\tspin_unlock_bh(&hwsim_radio_lock);\n\tclass_destroy(hwsim_class);\n}\n\nstatic const struct net_device_ops hwsim_netdev_ops = {\n\t.ndo_start_xmit \t= hwsim_mon_xmit,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic void hwsim_mon_setup(struct net_device *dev)\n{\n\tu8 addr[ETH_ALEN];\n\n\tdev->netdev_ops = &hwsim_netdev_ops;\n\tdev->needs_free_netdev = true;\n\tether_setup(dev);\n\tdev->priv_flags |= IFF_NO_QUEUE;\n\tdev->type = ARPHRD_IEEE80211_RADIOTAP;\n\teth_zero_addr(addr);\n\taddr[0] = 0x12;\n\teth_hw_addr_set(dev, addr);\n}\n\nstatic void hwsim_register_wmediumd(struct net *net, u32 portid)\n{\n\tstruct mac80211_hwsim_data *data;\n\n\thwsim_net_set_wmediumd(net, portid);\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\tlist_for_each_entry(data, &hwsim_radios, list) {\n\t\tif (data->netgroup == hwsim_net_get_netgroup(net))\n\t\t\tdata->wmediumd = portid;\n\t}\n\tspin_unlock_bh(&hwsim_radio_lock);\n}\n\nstatic int hwsim_tx_info_frame_received_nl(struct sk_buff *skb_2,\n\t\t\t\t\t   struct genl_info *info)\n{\n\n\tstruct ieee80211_hdr *hdr;\n\tstruct mac80211_hwsim_data *data2;\n\tstruct ieee80211_tx_info *txi;\n\tstruct hwsim_tx_rate *tx_attempts;\n\tu64 ret_skb_cookie;\n\tstruct sk_buff *skb, *tmp;\n\tconst u8 *src;\n\tunsigned int hwsim_flags;\n\tint i;\n\tunsigned long flags;\n\tbool found = false;\n\n\tif (!info->attrs[HWSIM_ATTR_ADDR_TRANSMITTER] ||\n\t    !info->attrs[HWSIM_ATTR_FLAGS] ||\n\t    !info->attrs[HWSIM_ATTR_COOKIE] ||\n\t    !info->attrs[HWSIM_ATTR_SIGNAL] ||\n\t    !info->attrs[HWSIM_ATTR_TX_INFO])\n\t\tgoto out;\n\n\tsrc = (void *)nla_data(info->attrs[HWSIM_ATTR_ADDR_TRANSMITTER]);\n\thwsim_flags = nla_get_u32(info->attrs[HWSIM_ATTR_FLAGS]);\n\tret_skb_cookie = nla_get_u64(info->attrs[HWSIM_ATTR_COOKIE]);\n\n\tdata2 = get_hwsim_data_ref_from_addr(src);\n\tif (!data2)\n\t\tgoto out;\n\n\tif (!hwsim_virtio_enabled) {\n\t\tif (hwsim_net_get_netgroup(genl_info_net(info)) !=\n\t\t    data2->netgroup)\n\t\t\tgoto out;\n\n\t\tif (info->snd_portid != data2->wmediumd)\n\t\t\tgoto out;\n\t}\n\n\t \n\tspin_lock_irqsave(&data2->pending.lock, flags);\n\tskb_queue_walk_safe(&data2->pending, skb, tmp) {\n\t\tuintptr_t skb_cookie;\n\n\t\ttxi = IEEE80211_SKB_CB(skb);\n\t\tskb_cookie = (uintptr_t)txi->rate_driver_data[0];\n\n\t\tif (skb_cookie == ret_skb_cookie) {\n\t\t\t__skb_unlink(skb, &data2->pending);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&data2->pending.lock, flags);\n\n\t \n\tif (!found)\n\t\tgoto out;\n\n\t \n\n\ttx_attempts = (struct hwsim_tx_rate *)nla_data(\n\t\t       info->attrs[HWSIM_ATTR_TX_INFO]);\n\n\t \n\ttxi = IEEE80211_SKB_CB(skb);\n\n\tieee80211_tx_info_clear_status(txi);\n\n\tfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {\n\t\ttxi->status.rates[i].idx = tx_attempts[i].idx;\n\t\ttxi->status.rates[i].count = tx_attempts[i].count;\n\t}\n\n\ttxi->status.ack_signal = nla_get_u32(info->attrs[HWSIM_ATTR_SIGNAL]);\n\n\tif (!(hwsim_flags & HWSIM_TX_CTL_NO_ACK) &&\n\t   (hwsim_flags & HWSIM_TX_STAT_ACK)) {\n\t\tif (skb->len >= 16) {\n\t\t\thdr = (struct ieee80211_hdr *) skb->data;\n\t\t\tmac80211_hwsim_monitor_ack(data2->channel,\n\t\t\t\t\t\t   hdr->addr2);\n\t\t}\n\t\ttxi->flags |= IEEE80211_TX_STAT_ACK;\n\t}\n\n\tif (hwsim_flags & HWSIM_TX_CTL_NO_ACK)\n\t\ttxi->flags |= IEEE80211_TX_STAT_NOACK_TRANSMITTED;\n\n\tieee80211_tx_status_irqsafe(data2->hw, skb);\n\treturn 0;\nout:\n\treturn -EINVAL;\n\n}\n\nstatic int hwsim_cloned_frame_received_nl(struct sk_buff *skb_2,\n\t\t\t\t\t  struct genl_info *info)\n{\n\tstruct mac80211_hwsim_data *data2;\n\tstruct ieee80211_rx_status rx_status;\n\tstruct ieee80211_hdr *hdr;\n\tconst u8 *dst;\n\tint frame_data_len;\n\tvoid *frame_data;\n\tstruct sk_buff *skb = NULL;\n\tstruct ieee80211_channel *channel = NULL;\n\n\tif (!info->attrs[HWSIM_ATTR_ADDR_RECEIVER] ||\n\t    !info->attrs[HWSIM_ATTR_FRAME] ||\n\t    !info->attrs[HWSIM_ATTR_RX_RATE] ||\n\t    !info->attrs[HWSIM_ATTR_SIGNAL])\n\t\tgoto out;\n\n\tdst = (void *)nla_data(info->attrs[HWSIM_ATTR_ADDR_RECEIVER]);\n\tframe_data_len = nla_len(info->attrs[HWSIM_ATTR_FRAME]);\n\tframe_data = (void *)nla_data(info->attrs[HWSIM_ATTR_FRAME]);\n\n\tif (frame_data_len < sizeof(struct ieee80211_hdr_3addr) ||\n\t    frame_data_len > IEEE80211_MAX_DATA_LEN)\n\t\tgoto err;\n\n\t \n\tskb = alloc_skb(frame_data_len, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto err;\n\n\t \n\tskb_put_data(skb, frame_data, frame_data_len);\n\n\tdata2 = get_hwsim_data_ref_from_addr(dst);\n\tif (!data2)\n\t\tgoto out;\n\n\tif (data2->use_chanctx) {\n\t\tif (data2->tmp_chan)\n\t\t\tchannel = data2->tmp_chan;\n\t} else {\n\t\tchannel = data2->channel;\n\t}\n\n\tif (!hwsim_virtio_enabled) {\n\t\tif (hwsim_net_get_netgroup(genl_info_net(info)) !=\n\t\t    data2->netgroup)\n\t\t\tgoto out;\n\n\t\tif (info->snd_portid != data2->wmediumd)\n\t\t\tgoto out;\n\t}\n\n\t \n\n\tif ((data2->idle && !data2->tmp_chan) || !data2->started)\n\t\tgoto out;\n\n\t \n\tmemset(&rx_status, 0, sizeof(rx_status));\n\tif (info->attrs[HWSIM_ATTR_FREQ]) {\n\t\tstruct tx_iter_data iter_data = {};\n\n\t\t \n\t\trx_status.freq = nla_get_u32(info->attrs[HWSIM_ATTR_FREQ]);\n\n\t\titer_data.channel = ieee80211_get_channel(data2->hw->wiphy,\n\t\t\t\t\t\t\t  rx_status.freq);\n\t\tif (!iter_data.channel)\n\t\t\tgoto out;\n\t\trx_status.band = iter_data.channel->band;\n\n\t\tmutex_lock(&data2->mutex);\n\t\tif (!hwsim_chans_compat(iter_data.channel, channel)) {\n\t\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\t\tdata2->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\tmac80211_hwsim_tx_iter, &iter_data);\n\t\t\tif (!iter_data.receive) {\n\t\t\t\tmutex_unlock(&data2->mutex);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&data2->mutex);\n\t} else if (!channel) {\n\t\tgoto out;\n\t} else {\n\t\trx_status.freq = channel->center_freq;\n\t\trx_status.band = channel->band;\n\t}\n\n\trx_status.rate_idx = nla_get_u32(info->attrs[HWSIM_ATTR_RX_RATE]);\n\tif (rx_status.rate_idx >= data2->hw->wiphy->bands[rx_status.band]->n_bitrates)\n\t\tgoto out;\n\trx_status.signal = nla_get_u32(info->attrs[HWSIM_ATTR_SIGNAL]);\n\n\thdr = (void *)skb->data;\n\n\tif (ieee80211_is_beacon(hdr->frame_control) ||\n\t    ieee80211_is_probe_resp(hdr->frame_control))\n\t\trx_status.boottime_ns = ktime_get_boottime_ns();\n\n\tmac80211_hwsim_rx(data2, &rx_status, skb);\n\n\treturn 0;\nerr:\n\tpr_debug(\"mac80211_hwsim: error occurred in %s\\n\", __func__);\nout:\n\tdev_kfree_skb(skb);\n\treturn -EINVAL;\n}\n\nstatic int hwsim_register_received_nl(struct sk_buff *skb_2,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct net *net = genl_info_net(info);\n\tstruct mac80211_hwsim_data *data;\n\tint chans = 1;\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\tlist_for_each_entry(data, &hwsim_radios, list)\n\t\tchans = max(chans, data->channels);\n\tspin_unlock_bh(&hwsim_radio_lock);\n\n\t \n\tif (chans > 1)\n\t\treturn -EOPNOTSUPP;\n\n\tif (hwsim_net_get_wmediumd(net))\n\t\treturn -EBUSY;\n\n\thwsim_register_wmediumd(net, info->snd_portid);\n\n\tpr_debug(\"mac80211_hwsim: received a REGISTER, \"\n\t       \"switching to wmediumd mode with pid %d\\n\", info->snd_portid);\n\n\treturn 0;\n}\n\n \nstatic bool hwsim_known_ciphers(const u32 *ciphers, int n_ciphers)\n{\n\tint i;\n\n\tfor (i = 0; i < n_ciphers; i++) {\n\t\tint j;\n\t\tint found = 0;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(hwsim_ciphers); j++) {\n\t\t\tif (ciphers[i] == hwsim_ciphers[j]) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int parse_ftm_capa(const struct nlattr *ftm_capa, struct cfg80211_pmsr_capabilities *out,\n\t\t\t  struct genl_info *info)\n{\n\tstruct nlattr *tb[NL80211_PMSR_FTM_CAPA_ATTR_MAX + 1];\n\tint ret;\n\n\tret = nla_parse_nested(tb, NL80211_PMSR_FTM_CAPA_ATTR_MAX, ftm_capa, hwsim_ftm_capa_policy,\n\t\t\t       NULL);\n\tif (ret) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack, ftm_capa, \"malformed FTM capability\");\n\t\treturn -EINVAL;\n\t}\n\n\tout->ftm.supported = 1;\n\tif (tb[NL80211_PMSR_FTM_CAPA_ATTR_PREAMBLES])\n\t\tout->ftm.preambles = nla_get_u32(tb[NL80211_PMSR_FTM_CAPA_ATTR_PREAMBLES]);\n\tif (tb[NL80211_PMSR_FTM_CAPA_ATTR_BANDWIDTHS])\n\t\tout->ftm.bandwidths = nla_get_u32(tb[NL80211_PMSR_FTM_CAPA_ATTR_BANDWIDTHS]);\n\tif (tb[NL80211_PMSR_FTM_CAPA_ATTR_MAX_BURSTS_EXPONENT])\n\t\tout->ftm.max_bursts_exponent =\n\t\t\tnla_get_u8(tb[NL80211_PMSR_FTM_CAPA_ATTR_MAX_BURSTS_EXPONENT]);\n\tif (tb[NL80211_PMSR_FTM_CAPA_ATTR_MAX_FTMS_PER_BURST])\n\t\tout->ftm.max_ftms_per_burst =\n\t\t\tnla_get_u8(tb[NL80211_PMSR_FTM_CAPA_ATTR_MAX_FTMS_PER_BURST]);\n\tout->ftm.asap = !!tb[NL80211_PMSR_FTM_CAPA_ATTR_ASAP];\n\tout->ftm.non_asap = !!tb[NL80211_PMSR_FTM_CAPA_ATTR_NON_ASAP];\n\tout->ftm.request_lci = !!tb[NL80211_PMSR_FTM_CAPA_ATTR_REQ_LCI];\n\tout->ftm.request_civicloc = !!tb[NL80211_PMSR_FTM_CAPA_ATTR_REQ_CIVICLOC];\n\tout->ftm.trigger_based = !!tb[NL80211_PMSR_FTM_CAPA_ATTR_TRIGGER_BASED];\n\tout->ftm.non_trigger_based = !!tb[NL80211_PMSR_FTM_CAPA_ATTR_NON_TRIGGER_BASED];\n\n\treturn 0;\n}\n\nstatic int parse_pmsr_capa(const struct nlattr *pmsr_capa, struct cfg80211_pmsr_capabilities *out,\n\t\t\t   struct genl_info *info)\n{\n\tstruct nlattr *tb[NL80211_PMSR_ATTR_MAX + 1];\n\tstruct nlattr *nla;\n\tint size;\n\tint ret;\n\n\tret = nla_parse_nested(tb, NL80211_PMSR_ATTR_MAX, pmsr_capa, hwsim_pmsr_capa_policy, NULL);\n\tif (ret) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack, pmsr_capa, \"malformed PMSR capability\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tb[NL80211_PMSR_ATTR_MAX_PEERS])\n\t\tout->max_peers = nla_get_u32(tb[NL80211_PMSR_ATTR_MAX_PEERS]);\n\tout->report_ap_tsf = !!tb[NL80211_PMSR_ATTR_REPORT_AP_TSF];\n\tout->randomize_mac_addr = !!tb[NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR];\n\n\tif (!tb[NL80211_PMSR_ATTR_TYPE_CAPA]) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack, tb[NL80211_PMSR_ATTR_TYPE_CAPA],\n\t\t\t\t    \"malformed PMSR type\");\n\t\treturn -EINVAL;\n\t}\n\n\tnla_for_each_nested(nla, tb[NL80211_PMSR_ATTR_TYPE_CAPA], size) {\n\t\tswitch (nla_type(nla)) {\n\t\tcase NL80211_PMSR_TYPE_FTM:\n\t\t\tparse_ftm_capa(nla, out, info);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_ATTR(info->extack, nla, \"unsupported measurement type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int hwsim_new_radio_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct hwsim_new_radio_params param = { 0 };\n\tconst char *hwname = NULL;\n\tint ret;\n\n\tparam.reg_strict = info->attrs[HWSIM_ATTR_REG_STRICT_REG];\n\tparam.p2p_device = info->attrs[HWSIM_ATTR_SUPPORT_P2P_DEVICE];\n\tparam.channels = channels;\n\tparam.destroy_on_close =\n\t\tinfo->attrs[HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE];\n\n\tif (info->attrs[HWSIM_ATTR_CHANNELS])\n\t\tparam.channels = nla_get_u32(info->attrs[HWSIM_ATTR_CHANNELS]);\n\n\tif (param.channels < 1) {\n\t\tGENL_SET_ERR_MSG(info, \"must have at least one channel\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[HWSIM_ATTR_NO_VIF])\n\t\tparam.no_vif = true;\n\n\tif (info->attrs[HWSIM_ATTR_USE_CHANCTX])\n\t\tparam.use_chanctx = true;\n\telse\n\t\tparam.use_chanctx = (param.channels > 1);\n\n\tif (info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2])\n\t\tparam.reg_alpha2 =\n\t\t\tnla_data(info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2]);\n\n\tif (info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]) {\n\t\tu32 idx = nla_get_u32(info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]);\n\n\t\tif (idx >= ARRAY_SIZE(hwsim_world_regdom_custom))\n\t\t\treturn -EINVAL;\n\n\t\tidx = array_index_nospec(idx,\n\t\t\t\t\t ARRAY_SIZE(hwsim_world_regdom_custom));\n\t\tparam.regd = hwsim_world_regdom_custom[idx];\n\t}\n\n\tif (info->attrs[HWSIM_ATTR_PERM_ADDR]) {\n\t\tif (!is_valid_ether_addr(\n\t\t\t\tnla_data(info->attrs[HWSIM_ATTR_PERM_ADDR]))) {\n\t\t\tGENL_SET_ERR_MSG(info,\"MAC is no valid source addr\");\n\t\t\tNL_SET_BAD_ATTR(info->extack,\n\t\t\t\t\tinfo->attrs[HWSIM_ATTR_PERM_ADDR]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tparam.perm_addr = nla_data(info->attrs[HWSIM_ATTR_PERM_ADDR]);\n\t}\n\n\tif (info->attrs[HWSIM_ATTR_IFTYPE_SUPPORT]) {\n\t\tparam.iftypes =\n\t\t\tnla_get_u32(info->attrs[HWSIM_ATTR_IFTYPE_SUPPORT]);\n\n\t\tif (param.iftypes & ~HWSIM_IFTYPE_SUPPORT_MASK) {\n\t\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t\t    info->attrs[HWSIM_ATTR_IFTYPE_SUPPORT],\n\t\t\t\t\t    \"cannot support more iftypes than kernel\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tparam.iftypes = HWSIM_IFTYPE_SUPPORT_MASK;\n\t}\n\n\t \n\tif (param.p2p_device ||\n\t    param.iftypes & BIT(NL80211_IFTYPE_P2P_DEVICE)) {\n\t\tparam.iftypes |= BIT(NL80211_IFTYPE_P2P_DEVICE);\n\t\tparam.p2p_device = true;\n\t}\n\n\tif (info->attrs[HWSIM_ATTR_CIPHER_SUPPORT]) {\n\t\tu32 len = nla_len(info->attrs[HWSIM_ATTR_CIPHER_SUPPORT]);\n\n\t\tparam.ciphers =\n\t\t\tnla_data(info->attrs[HWSIM_ATTR_CIPHER_SUPPORT]);\n\n\t\tif (len % sizeof(u32)) {\n\t\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t\t    info->attrs[HWSIM_ATTR_CIPHER_SUPPORT],\n\t\t\t\t\t    \"bad cipher list length\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tparam.n_ciphers = len / sizeof(u32);\n\n\t\tif (param.n_ciphers > ARRAY_SIZE(hwsim_ciphers)) {\n\t\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t\t    info->attrs[HWSIM_ATTR_CIPHER_SUPPORT],\n\t\t\t\t\t    \"too many ciphers specified\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!hwsim_known_ciphers(param.ciphers, param.n_ciphers)) {\n\t\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t\t    info->attrs[HWSIM_ATTR_CIPHER_SUPPORT],\n\t\t\t\t\t    \"unsupported ciphers specified\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tparam.mlo = info->attrs[HWSIM_ATTR_MLO_SUPPORT];\n\n\tif (param.mlo)\n\t\tparam.use_chanctx = true;\n\n\tif (info->attrs[HWSIM_ATTR_RADIO_NAME]) {\n\t\thwname = kstrndup((char *)nla_data(info->attrs[HWSIM_ATTR_RADIO_NAME]),\n\t\t\t\t  nla_len(info->attrs[HWSIM_ATTR_RADIO_NAME]),\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!hwname)\n\t\t\treturn -ENOMEM;\n\t\tparam.hwname = hwname;\n\t}\n\n\tif (info->attrs[HWSIM_ATTR_PMSR_SUPPORT]) {\n\t\tstruct cfg80211_pmsr_capabilities *pmsr_capa;\n\n\t\tpmsr_capa = kmalloc(sizeof(*pmsr_capa), GFP_KERNEL);\n\t\tif (!pmsr_capa) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\t\tparam.pmsr_capa = pmsr_capa;\n\n\t\tret = parse_pmsr_capa(info->attrs[HWSIM_ATTR_PMSR_SUPPORT], pmsr_capa, info);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\n\tret = mac80211_hwsim_new_radio(info, &param);\n\nout_free:\n\tkfree(hwname);\n\tkfree(param.pmsr_capa);\n\treturn ret;\n}\n\nstatic int hwsim_del_radio_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct mac80211_hwsim_data *data;\n\ts64 idx = -1;\n\tconst char *hwname = NULL;\n\n\tif (info->attrs[HWSIM_ATTR_RADIO_ID]) {\n\t\tidx = nla_get_u32(info->attrs[HWSIM_ATTR_RADIO_ID]);\n\t} else if (info->attrs[HWSIM_ATTR_RADIO_NAME]) {\n\t\thwname = kstrndup((char *)nla_data(info->attrs[HWSIM_ATTR_RADIO_NAME]),\n\t\t\t\t  nla_len(info->attrs[HWSIM_ATTR_RADIO_NAME]),\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!hwname)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\tlist_for_each_entry(data, &hwsim_radios, list) {\n\t\tif (idx >= 0) {\n\t\t\tif (data->idx != idx)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (!hwname ||\n\t\t\t    strcmp(hwname, wiphy_name(data->hw->wiphy)))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (!net_eq(wiphy_net(data->hw->wiphy), genl_info_net(info)))\n\t\t\tcontinue;\n\n\t\tlist_del(&data->list);\n\t\trhashtable_remove_fast(&hwsim_radios_rht, &data->rht,\n\t\t\t\t       hwsim_rht_params);\n\t\thwsim_radios_generation++;\n\t\tspin_unlock_bh(&hwsim_radio_lock);\n\t\tmac80211_hwsim_del_radio(data, wiphy_name(data->hw->wiphy),\n\t\t\t\t\t info);\n\t\tkfree(hwname);\n\t\treturn 0;\n\t}\n\tspin_unlock_bh(&hwsim_radio_lock);\n\n\tkfree(hwname);\n\treturn -ENODEV;\n}\n\nstatic int hwsim_get_radio_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct mac80211_hwsim_data *data;\n\tstruct sk_buff *skb;\n\tint idx, res = -ENODEV;\n\n\tif (!info->attrs[HWSIM_ATTR_RADIO_ID])\n\t\treturn -EINVAL;\n\tidx = nla_get_u32(info->attrs[HWSIM_ATTR_RADIO_ID]);\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\tlist_for_each_entry(data, &hwsim_radios, list) {\n\t\tif (data->idx != idx)\n\t\t\tcontinue;\n\n\t\tif (!net_eq(wiphy_net(data->hw->wiphy), genl_info_net(info)))\n\t\t\tcontinue;\n\n\t\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\t\tif (!skb) {\n\t\t\tres = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tres = mac80211_hwsim_get_radio(skb, data, info->snd_portid,\n\t\t\t\t\t       info->snd_seq, NULL, 0);\n\t\tif (res < 0) {\n\t\t\tnlmsg_free(skb);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tres = genlmsg_reply(skb, info);\n\t\tbreak;\n\t}\n\nout_err:\n\tspin_unlock_bh(&hwsim_radio_lock);\n\n\treturn res;\n}\n\nstatic int hwsim_dump_radio_nl(struct sk_buff *skb,\n\t\t\t       struct netlink_callback *cb)\n{\n\tint last_idx = cb->args[0] - 1;\n\tstruct mac80211_hwsim_data *data = NULL;\n\tint res = 0;\n\tvoid *hdr;\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\tcb->seq = hwsim_radios_generation;\n\n\tif (last_idx >= hwsim_radio_idx-1)\n\t\tgoto done;\n\n\tlist_for_each_entry(data, &hwsim_radios, list) {\n\t\tif (data->idx <= last_idx)\n\t\t\tcontinue;\n\n\t\tif (!net_eq(wiphy_net(data->hw->wiphy), sock_net(skb->sk)))\n\t\t\tcontinue;\n\n\t\tres = mac80211_hwsim_get_radio(skb, data,\n\t\t\t\t\t       NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t       cb->nlh->nlmsg_seq, cb,\n\t\t\t\t\t       NLM_F_MULTI);\n\t\tif (res < 0)\n\t\t\tbreak;\n\n\t\tlast_idx = data->idx;\n\t}\n\n\tcb->args[0] = last_idx + 1;\n\n\t \n\tif (skb->len == 0 && cb->prev_seq && cb->seq != cb->prev_seq) {\n\t\thdr = genlmsg_put(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t  cb->nlh->nlmsg_seq, &hwsim_genl_family,\n\t\t\t\t  NLM_F_MULTI, HWSIM_CMD_GET_RADIO);\n\t\tif (hdr) {\n\t\t\tgenl_dump_check_consistent(cb, hdr);\n\t\t\tgenlmsg_end(skb, hdr);\n\t\t} else {\n\t\t\tres = -EMSGSIZE;\n\t\t}\n\t}\n\ndone:\n\tspin_unlock_bh(&hwsim_radio_lock);\n\treturn res ?: skb->len;\n}\n\n \nstatic const struct genl_small_ops hwsim_ops[] = {\n\t{\n\t\t.cmd = HWSIM_CMD_REGISTER,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = hwsim_register_received_nl,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = HWSIM_CMD_FRAME,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = hwsim_cloned_frame_received_nl,\n\t},\n\t{\n\t\t.cmd = HWSIM_CMD_TX_INFO_FRAME,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = hwsim_tx_info_frame_received_nl,\n\t},\n\t{\n\t\t.cmd = HWSIM_CMD_NEW_RADIO,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = hwsim_new_radio_nl,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = HWSIM_CMD_DEL_RADIO,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = hwsim_del_radio_nl,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = HWSIM_CMD_GET_RADIO,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = hwsim_get_radio_nl,\n\t\t.dumpit = hwsim_dump_radio_nl,\n\t},\n\t{\n\t\t.cmd = HWSIM_CMD_REPORT_PMSR,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = hwsim_pmsr_report_nl,\n\t},\n};\n\nstatic struct genl_family hwsim_genl_family __ro_after_init = {\n\t.name = \"MAC80211_HWSIM\",\n\t.version = 1,\n\t.maxattr = HWSIM_ATTR_MAX,\n\t.policy = hwsim_genl_policy,\n\t.netnsok = true,\n\t.module = THIS_MODULE,\n\t.small_ops = hwsim_ops,\n\t.n_small_ops = ARRAY_SIZE(hwsim_ops),\n\t.resv_start_op = HWSIM_CMD_REPORT_PMSR + 1, \n\t.mcgrps = hwsim_mcgrps,\n\t.n_mcgrps = ARRAY_SIZE(hwsim_mcgrps),\n};\n\nstatic void remove_user_radios(u32 portid)\n{\n\tstruct mac80211_hwsim_data *entry, *tmp;\n\tLIST_HEAD(list);\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\tlist_for_each_entry_safe(entry, tmp, &hwsim_radios, list) {\n\t\tif (entry->destroy_on_close && entry->portid == portid) {\n\t\t\tlist_move(&entry->list, &list);\n\t\t\trhashtable_remove_fast(&hwsim_radios_rht, &entry->rht,\n\t\t\t\t\t       hwsim_rht_params);\n\t\t\thwsim_radios_generation++;\n\t\t}\n\t}\n\tspin_unlock_bh(&hwsim_radio_lock);\n\n\tlist_for_each_entry_safe(entry, tmp, &list, list) {\n\t\tlist_del(&entry->list);\n\t\tmac80211_hwsim_del_radio(entry, wiphy_name(entry->hw->wiphy),\n\t\t\t\t\t NULL);\n\t}\n}\n\nstatic int mac80211_hwsim_netlink_notify(struct notifier_block *nb,\n\t\t\t\t\t unsigned long state,\n\t\t\t\t\t void *_notify)\n{\n\tstruct netlink_notify *notify = _notify;\n\n\tif (state != NETLINK_URELEASE)\n\t\treturn NOTIFY_DONE;\n\n\tremove_user_radios(notify->portid);\n\n\tif (notify->portid == hwsim_net_get_wmediumd(notify->net)) {\n\t\tprintk(KERN_INFO \"mac80211_hwsim: wmediumd released netlink\"\n\t\t       \" socket, switching to perfect channel medium\\n\");\n\t\thwsim_register_wmediumd(notify->net, 0);\n\t}\n\treturn NOTIFY_DONE;\n\n}\n\nstatic struct notifier_block hwsim_netlink_notifier = {\n\t.notifier_call = mac80211_hwsim_netlink_notify,\n};\n\nstatic int __init hwsim_init_netlink(void)\n{\n\tint rc;\n\n\tprintk(KERN_INFO \"mac80211_hwsim: initializing netlink\\n\");\n\n\trc = genl_register_family(&hwsim_genl_family);\n\tif (rc)\n\t\tgoto failure;\n\n\trc = netlink_register_notifier(&hwsim_netlink_notifier);\n\tif (rc) {\n\t\tgenl_unregister_family(&hwsim_genl_family);\n\t\tgoto failure;\n\t}\n\n\treturn 0;\n\nfailure:\n\tpr_debug(\"mac80211_hwsim: error occurred in %s\\n\", __func__);\n\treturn -EINVAL;\n}\n\nstatic __net_init int hwsim_init_net(struct net *net)\n{\n\treturn hwsim_net_set_netgroup(net);\n}\n\nstatic void __net_exit hwsim_exit_net(struct net *net)\n{\n\tstruct mac80211_hwsim_data *data, *tmp;\n\tLIST_HEAD(list);\n\n\tspin_lock_bh(&hwsim_radio_lock);\n\tlist_for_each_entry_safe(data, tmp, &hwsim_radios, list) {\n\t\tif (!net_eq(wiphy_net(data->hw->wiphy), net))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (data->netgroup == hwsim_net_get_netgroup(&init_net))\n\t\t\tcontinue;\n\n\t\tlist_move(&data->list, &list);\n\t\trhashtable_remove_fast(&hwsim_radios_rht, &data->rht,\n\t\t\t\t       hwsim_rht_params);\n\t\thwsim_radios_generation++;\n\t}\n\tspin_unlock_bh(&hwsim_radio_lock);\n\n\tlist_for_each_entry_safe(data, tmp, &list, list) {\n\t\tlist_del(&data->list);\n\t\tmac80211_hwsim_del_radio(data,\n\t\t\t\t\t wiphy_name(data->hw->wiphy),\n\t\t\t\t\t NULL);\n\t}\n\n\tida_free(&hwsim_netgroup_ida, hwsim_net_get_netgroup(net));\n}\n\nstatic struct pernet_operations hwsim_net_ops = {\n\t.init = hwsim_init_net,\n\t.exit = hwsim_exit_net,\n\t.id   = &hwsim_net_id,\n\t.size = sizeof(struct hwsim_net),\n};\n\nstatic void hwsim_exit_netlink(void)\n{\n\t \n\tnetlink_unregister_notifier(&hwsim_netlink_notifier);\n\t \n\tgenl_unregister_family(&hwsim_genl_family);\n}\n\n#if IS_REACHABLE(CONFIG_VIRTIO)\nstatic void hwsim_virtio_tx_done(struct virtqueue *vq)\n{\n\tunsigned int len;\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hwsim_virtio_lock, flags);\n\twhile ((skb = virtqueue_get_buf(vq, &len)))\n\t\tdev_kfree_skb_irq(skb);\n\tspin_unlock_irqrestore(&hwsim_virtio_lock, flags);\n}\n\nstatic int hwsim_virtio_handle_cmd(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct genlmsghdr *gnlh;\n\tstruct nlattr *tb[HWSIM_ATTR_MAX + 1];\n\tstruct genl_info info = {};\n\tint err;\n\n\tnlh = nlmsg_hdr(skb);\n\tgnlh = nlmsg_data(nlh);\n\n\tif (skb->len < nlh->nlmsg_len)\n\t\treturn -EINVAL;\n\n\terr = genlmsg_parse(nlh, &hwsim_genl_family, tb, HWSIM_ATTR_MAX,\n\t\t\t    hwsim_genl_policy, NULL);\n\tif (err) {\n\t\tpr_err_ratelimited(\"hwsim: genlmsg_parse returned %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tinfo.attrs = tb;\n\n\tswitch (gnlh->cmd) {\n\tcase HWSIM_CMD_FRAME:\n\t\thwsim_cloned_frame_received_nl(skb, &info);\n\t\tbreak;\n\tcase HWSIM_CMD_TX_INFO_FRAME:\n\t\thwsim_tx_info_frame_received_nl(skb, &info);\n\t\tbreak;\n\tcase HWSIM_CMD_REPORT_PMSR:\n\t\thwsim_pmsr_report_nl(skb, &info);\n\t\tbreak;\n\tdefault:\n\t\tpr_err_ratelimited(\"hwsim: invalid cmd: %d\\n\", gnlh->cmd);\n\t\treturn -EPROTO;\n\t}\n\treturn 0;\n}\n\nstatic void hwsim_virtio_rx_work(struct work_struct *work)\n{\n\tstruct virtqueue *vq;\n\tunsigned int len;\n\tstruct sk_buff *skb;\n\tstruct scatterlist sg[1];\n\tint err;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hwsim_virtio_lock, flags);\n\tif (!hwsim_virtio_enabled)\n\t\tgoto out_unlock;\n\n\tskb = virtqueue_get_buf(hwsim_vqs[HWSIM_VQ_RX], &len);\n\tif (!skb)\n\t\tgoto out_unlock;\n\tspin_unlock_irqrestore(&hwsim_virtio_lock, flags);\n\n\tskb->data = skb->head;\n\tskb_reset_tail_pointer(skb);\n\tskb_put(skb, len);\n\thwsim_virtio_handle_cmd(skb);\n\n\tspin_lock_irqsave(&hwsim_virtio_lock, flags);\n\tif (!hwsim_virtio_enabled) {\n\t\tdev_kfree_skb_irq(skb);\n\t\tgoto out_unlock;\n\t}\n\tvq = hwsim_vqs[HWSIM_VQ_RX];\n\tsg_init_one(sg, skb->head, skb_end_offset(skb));\n\terr = virtqueue_add_inbuf(vq, sg, 1, skb, GFP_ATOMIC);\n\tif (WARN(err, \"virtqueue_add_inbuf returned %d\\n\", err))\n\t\tdev_kfree_skb_irq(skb);\n\telse\n\t\tvirtqueue_kick(vq);\n\tschedule_work(&hwsim_virtio_rx);\n\nout_unlock:\n\tspin_unlock_irqrestore(&hwsim_virtio_lock, flags);\n}\n\nstatic void hwsim_virtio_rx_done(struct virtqueue *vq)\n{\n\tschedule_work(&hwsim_virtio_rx);\n}\n\nstatic int init_vqs(struct virtio_device *vdev)\n{\n\tvq_callback_t *callbacks[HWSIM_NUM_VQS] = {\n\t\t[HWSIM_VQ_TX] = hwsim_virtio_tx_done,\n\t\t[HWSIM_VQ_RX] = hwsim_virtio_rx_done,\n\t};\n\tconst char *names[HWSIM_NUM_VQS] = {\n\t\t[HWSIM_VQ_TX] = \"tx\",\n\t\t[HWSIM_VQ_RX] = \"rx\",\n\t};\n\n\treturn virtio_find_vqs(vdev, HWSIM_NUM_VQS,\n\t\t\t       hwsim_vqs, callbacks, names, NULL);\n}\n\nstatic int fill_vq(struct virtqueue *vq)\n{\n\tint i, err;\n\tstruct sk_buff *skb;\n\tstruct scatterlist sg[1];\n\n\tfor (i = 0; i < virtqueue_get_vring_size(vq); i++) {\n\t\tskb = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\n\t\tsg_init_one(sg, skb->head, skb_end_offset(skb));\n\t\terr = virtqueue_add_inbuf(vq, sg, 1, skb, GFP_KERNEL);\n\t\tif (err) {\n\t\t\tnlmsg_free(skb);\n\t\t\treturn err;\n\t\t}\n\t}\n\tvirtqueue_kick(vq);\n\treturn 0;\n}\n\nstatic void remove_vqs(struct virtio_device *vdev)\n{\n\tint i;\n\n\tvirtio_reset_device(vdev);\n\n\tfor (i = 0; i < ARRAY_SIZE(hwsim_vqs); i++) {\n\t\tstruct virtqueue *vq = hwsim_vqs[i];\n\t\tstruct sk_buff *skb;\n\n\t\twhile ((skb = virtqueue_detach_unused_buf(vq)))\n\t\t\tnlmsg_free(skb);\n\t}\n\n\tvdev->config->del_vqs(vdev);\n}\n\nstatic int hwsim_virtio_probe(struct virtio_device *vdev)\n{\n\tint err;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hwsim_virtio_lock, flags);\n\tif (hwsim_virtio_enabled) {\n\t\tspin_unlock_irqrestore(&hwsim_virtio_lock, flags);\n\t\treturn -EEXIST;\n\t}\n\tspin_unlock_irqrestore(&hwsim_virtio_lock, flags);\n\n\terr = init_vqs(vdev);\n\tif (err)\n\t\treturn err;\n\n\tvirtio_device_ready(vdev);\n\n\terr = fill_vq(hwsim_vqs[HWSIM_VQ_RX]);\n\tif (err)\n\t\tgoto out_remove;\n\n\tspin_lock_irqsave(&hwsim_virtio_lock, flags);\n\thwsim_virtio_enabled = true;\n\tspin_unlock_irqrestore(&hwsim_virtio_lock, flags);\n\n\tschedule_work(&hwsim_virtio_rx);\n\treturn 0;\n\nout_remove:\n\tremove_vqs(vdev);\n\treturn err;\n}\n\nstatic void hwsim_virtio_remove(struct virtio_device *vdev)\n{\n\thwsim_virtio_enabled = false;\n\n\tcancel_work_sync(&hwsim_virtio_rx);\n\n\tremove_vqs(vdev);\n}\n\n \nstatic const struct virtio_device_id id_table[] = {\n\t{ VIRTIO_ID_MAC80211_HWSIM, VIRTIO_DEV_ANY_ID },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(virtio, id_table);\n\nstatic struct virtio_driver virtio_hwsim = {\n\t.driver.name = KBUILD_MODNAME,\n\t.driver.owner = THIS_MODULE,\n\t.id_table = id_table,\n\t.probe = hwsim_virtio_probe,\n\t.remove = hwsim_virtio_remove,\n};\n\nstatic int hwsim_register_virtio_driver(void)\n{\n\treturn register_virtio_driver(&virtio_hwsim);\n}\n\nstatic void hwsim_unregister_virtio_driver(void)\n{\n\tunregister_virtio_driver(&virtio_hwsim);\n}\n#else\nstatic inline int hwsim_register_virtio_driver(void)\n{\n\treturn 0;\n}\n\nstatic inline void hwsim_unregister_virtio_driver(void)\n{\n}\n#endif\n\nstatic int __init init_mac80211_hwsim(void)\n{\n\tint i, err;\n\n\tif (radios < 0 || radios > 100)\n\t\treturn -EINVAL;\n\n\tif (channels < 1)\n\t\treturn -EINVAL;\n\n\terr = rhashtable_init(&hwsim_radios_rht, &hwsim_rht_params);\n\tif (err)\n\t\treturn err;\n\n\terr = register_pernet_device(&hwsim_net_ops);\n\tif (err)\n\t\tgoto out_free_rht;\n\n\terr = platform_driver_register(&mac80211_hwsim_driver);\n\tif (err)\n\t\tgoto out_unregister_pernet;\n\n\terr = hwsim_init_netlink();\n\tif (err)\n\t\tgoto out_unregister_driver;\n\n\terr = hwsim_register_virtio_driver();\n\tif (err)\n\t\tgoto out_exit_netlink;\n\n\thwsim_class = class_create(\"mac80211_hwsim\");\n\tif (IS_ERR(hwsim_class)) {\n\t\terr = PTR_ERR(hwsim_class);\n\t\tgoto out_exit_virtio;\n\t}\n\n\thwsim_init_s1g_channels(hwsim_channels_s1g);\n\n\tfor (i = 0; i < radios; i++) {\n\t\tstruct hwsim_new_radio_params param = { 0 };\n\n\t\tparam.channels = channels;\n\n\t\tswitch (regtest) {\n\t\tcase HWSIM_REGTEST_DIFF_COUNTRY:\n\t\t\tif (i < ARRAY_SIZE(hwsim_alpha2s))\n\t\t\t\tparam.reg_alpha2 = hwsim_alpha2s[i];\n\t\t\tbreak;\n\t\tcase HWSIM_REGTEST_DRIVER_REG_FOLLOW:\n\t\t\tif (!i)\n\t\t\t\tparam.reg_alpha2 = hwsim_alpha2s[0];\n\t\t\tbreak;\n\t\tcase HWSIM_REGTEST_STRICT_ALL:\n\t\t\tparam.reg_strict = true;\n\t\t\tfallthrough;\n\t\tcase HWSIM_REGTEST_DRIVER_REG_ALL:\n\t\t\tparam.reg_alpha2 = hwsim_alpha2s[0];\n\t\t\tbreak;\n\t\tcase HWSIM_REGTEST_WORLD_ROAM:\n\t\t\tif (i == 0)\n\t\t\t\tparam.regd = &hwsim_world_regdom_custom_01;\n\t\t\tbreak;\n\t\tcase HWSIM_REGTEST_CUSTOM_WORLD:\n\t\t\tparam.regd = &hwsim_world_regdom_custom_01;\n\t\t\tbreak;\n\t\tcase HWSIM_REGTEST_CUSTOM_WORLD_2:\n\t\t\tif (i == 0)\n\t\t\t\tparam.regd = &hwsim_world_regdom_custom_01;\n\t\t\telse if (i == 1)\n\t\t\t\tparam.regd = &hwsim_world_regdom_custom_02;\n\t\t\tbreak;\n\t\tcase HWSIM_REGTEST_STRICT_FOLLOW:\n\t\t\tif (i == 0) {\n\t\t\t\tparam.reg_strict = true;\n\t\t\t\tparam.reg_alpha2 = hwsim_alpha2s[0];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HWSIM_REGTEST_STRICT_AND_DRIVER_REG:\n\t\t\tif (i == 0) {\n\t\t\t\tparam.reg_strict = true;\n\t\t\t\tparam.reg_alpha2 = hwsim_alpha2s[0];\n\t\t\t} else if (i == 1) {\n\t\t\t\tparam.reg_alpha2 = hwsim_alpha2s[1];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HWSIM_REGTEST_ALL:\n\t\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tparam.regd = &hwsim_world_regdom_custom_01;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tparam.regd = &hwsim_world_regdom_custom_02;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tparam.reg_alpha2 = hwsim_alpha2s[0];\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tparam.reg_alpha2 = hwsim_alpha2s[1];\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tparam.reg_strict = true;\n\t\t\t\tparam.reg_alpha2 = hwsim_alpha2s[2];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tparam.p2p_device = support_p2p_device;\n\t\tparam.mlo = mlo;\n\t\tparam.use_chanctx = channels > 1 || mlo;\n\t\tparam.iftypes = HWSIM_IFTYPE_SUPPORT_MASK;\n\t\tif (param.p2p_device)\n\t\t\tparam.iftypes |= BIT(NL80211_IFTYPE_P2P_DEVICE);\n\n\t\terr = mac80211_hwsim_new_radio(NULL, &param);\n\t\tif (err < 0)\n\t\t\tgoto out_free_radios;\n\t}\n\n\thwsim_mon = alloc_netdev(0, \"hwsim%d\", NET_NAME_UNKNOWN,\n\t\t\t\t hwsim_mon_setup);\n\tif (hwsim_mon == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free_radios;\n\t}\n\n\trtnl_lock();\n\terr = dev_alloc_name(hwsim_mon, hwsim_mon->name);\n\tif (err < 0) {\n\t\trtnl_unlock();\n\t\tgoto out_free_mon;\n\t}\n\n\terr = register_netdevice(hwsim_mon);\n\tif (err < 0) {\n\t\trtnl_unlock();\n\t\tgoto out_free_mon;\n\t}\n\trtnl_unlock();\n\n\treturn 0;\n\nout_free_mon:\n\tfree_netdev(hwsim_mon);\nout_free_radios:\n\tmac80211_hwsim_free();\nout_exit_virtio:\n\thwsim_unregister_virtio_driver();\nout_exit_netlink:\n\thwsim_exit_netlink();\nout_unregister_driver:\n\tplatform_driver_unregister(&mac80211_hwsim_driver);\nout_unregister_pernet:\n\tunregister_pernet_device(&hwsim_net_ops);\nout_free_rht:\n\trhashtable_destroy(&hwsim_radios_rht);\n\treturn err;\n}\nmodule_init(init_mac80211_hwsim);\n\nstatic void __exit exit_mac80211_hwsim(void)\n{\n\tpr_debug(\"mac80211_hwsim: unregister radios\\n\");\n\n\thwsim_unregister_virtio_driver();\n\thwsim_exit_netlink();\n\n\tmac80211_hwsim_free();\n\n\trhashtable_destroy(&hwsim_radios_rht);\n\tunregister_netdev(hwsim_mon);\n\tplatform_driver_unregister(&mac80211_hwsim_driver);\n\tunregister_pernet_device(&hwsim_net_ops);\n}\nmodule_exit(exit_mac80211_hwsim);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}