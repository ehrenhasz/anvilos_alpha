{
  "module_name": "wlan.c",
  "hash_id": "dc225182475c005b0559e43d1e3f34f0fdf0dfcb40961e204c1b29176150074b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/microchip/wilc1000/wlan.c",
  "human_readable_source": "\n \n\n#include <linux/if_ether.h>\n#include <linux/ip.h>\n#include <net/dsfield.h>\n#include \"cfg80211.h\"\n#include \"wlan_cfg.h\"\n\n#define WAKE_UP_TRIAL_RETRY\t\t10000\n\nstatic inline bool is_wilc1000(u32 id)\n{\n\treturn (id & (~WILC_CHIP_REV_FIELD)) == WILC_1000_BASE_ID;\n}\n\nstatic inline void acquire_bus(struct wilc *wilc, enum bus_acquire acquire)\n{\n\tmutex_lock(&wilc->hif_cs);\n\tif (acquire == WILC_BUS_ACQUIRE_AND_WAKEUP && wilc->power_save_mode)\n\t\tchip_wakeup(wilc);\n}\n\nstatic inline void release_bus(struct wilc *wilc, enum bus_release release)\n{\n\tif (release == WILC_BUS_RELEASE_ALLOW_SLEEP && wilc->power_save_mode)\n\t\tchip_allow_sleep(wilc);\n\tmutex_unlock(&wilc->hif_cs);\n}\n\nstatic void wilc_wlan_txq_remove(struct wilc *wilc, u8 q_num,\n\t\t\t\t struct txq_entry_t *tqe)\n{\n\tlist_del(&tqe->list);\n\twilc->txq_entries -= 1;\n\twilc->txq[q_num].count--;\n}\n\nstatic struct txq_entry_t *\nwilc_wlan_txq_remove_from_head(struct wilc *wilc, u8 q_num)\n{\n\tstruct txq_entry_t *tqe = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wilc->txq_spinlock, flags);\n\n\tif (!list_empty(&wilc->txq[q_num].txq_head.list)) {\n\t\ttqe = list_first_entry(&wilc->txq[q_num].txq_head.list,\n\t\t\t\t       struct txq_entry_t, list);\n\t\tlist_del(&tqe->list);\n\t\twilc->txq_entries -= 1;\n\t\twilc->txq[q_num].count--;\n\t}\n\tspin_unlock_irqrestore(&wilc->txq_spinlock, flags);\n\treturn tqe;\n}\n\nstatic void wilc_wlan_txq_add_to_tail(struct net_device *dev, u8 q_num,\n\t\t\t\t      struct txq_entry_t *tqe)\n{\n\tunsigned long flags;\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc *wilc = vif->wilc;\n\n\tspin_lock_irqsave(&wilc->txq_spinlock, flags);\n\n\tlist_add_tail(&tqe->list, &wilc->txq[q_num].txq_head.list);\n\twilc->txq_entries += 1;\n\twilc->txq[q_num].count++;\n\n\tspin_unlock_irqrestore(&wilc->txq_spinlock, flags);\n\n\tcomplete(&wilc->txq_event);\n}\n\nstatic void wilc_wlan_txq_add_to_head(struct wilc_vif *vif, u8 q_num,\n\t\t\t\t      struct txq_entry_t *tqe)\n{\n\tunsigned long flags;\n\tstruct wilc *wilc = vif->wilc;\n\n\tmutex_lock(&wilc->txq_add_to_head_cs);\n\n\tspin_lock_irqsave(&wilc->txq_spinlock, flags);\n\n\tlist_add(&tqe->list, &wilc->txq[q_num].txq_head.list);\n\twilc->txq_entries += 1;\n\twilc->txq[q_num].count++;\n\n\tspin_unlock_irqrestore(&wilc->txq_spinlock, flags);\n\tmutex_unlock(&wilc->txq_add_to_head_cs);\n\tcomplete(&wilc->txq_event);\n}\n\n#define NOT_TCP_ACK\t\t\t(-1)\n\nstatic inline void add_tcp_session(struct wilc_vif *vif, u32 src_prt,\n\t\t\t\t   u32 dst_prt, u32 seq)\n{\n\tstruct tcp_ack_filter *f = &vif->ack_filter;\n\n\tif (f->tcp_session < 2 * MAX_TCP_SESSION) {\n\t\tf->ack_session_info[f->tcp_session].seq_num = seq;\n\t\tf->ack_session_info[f->tcp_session].bigger_ack_num = 0;\n\t\tf->ack_session_info[f->tcp_session].src_port = src_prt;\n\t\tf->ack_session_info[f->tcp_session].dst_port = dst_prt;\n\t\tf->tcp_session++;\n\t}\n}\n\nstatic inline void update_tcp_session(struct wilc_vif *vif, u32 index, u32 ack)\n{\n\tstruct tcp_ack_filter *f = &vif->ack_filter;\n\n\tif (index < 2 * MAX_TCP_SESSION &&\n\t    ack > f->ack_session_info[index].bigger_ack_num)\n\t\tf->ack_session_info[index].bigger_ack_num = ack;\n}\n\nstatic inline void add_tcp_pending_ack(struct wilc_vif *vif, u32 ack,\n\t\t\t\t       u32 session_index,\n\t\t\t\t       struct txq_entry_t *txqe)\n{\n\tstruct tcp_ack_filter *f = &vif->ack_filter;\n\tu32 i = f->pending_base + f->pending_acks_idx;\n\n\tif (i < MAX_PENDING_ACKS) {\n\t\tf->pending_acks[i].ack_num = ack;\n\t\tf->pending_acks[i].txqe = txqe;\n\t\tf->pending_acks[i].session_index = session_index;\n\t\ttxqe->ack_idx = i;\n\t\tf->pending_acks_idx++;\n\t}\n}\n\nstatic inline void tcp_process(struct net_device *dev, struct txq_entry_t *tqe)\n{\n\tvoid *buffer = tqe->buffer;\n\tconst struct ethhdr *eth_hdr_ptr = buffer;\n\tint i;\n\tunsigned long flags;\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc *wilc = vif->wilc;\n\tstruct tcp_ack_filter *f = &vif->ack_filter;\n\tconst struct iphdr *ip_hdr_ptr;\n\tconst struct tcphdr *tcp_hdr_ptr;\n\tu32 ihl, total_length, data_offset;\n\n\tspin_lock_irqsave(&wilc->txq_spinlock, flags);\n\n\tif (eth_hdr_ptr->h_proto != htons(ETH_P_IP))\n\t\tgoto out;\n\n\tip_hdr_ptr = buffer + ETH_HLEN;\n\n\tif (ip_hdr_ptr->protocol != IPPROTO_TCP)\n\t\tgoto out;\n\n\tihl = ip_hdr_ptr->ihl << 2;\n\ttcp_hdr_ptr = buffer + ETH_HLEN + ihl;\n\ttotal_length = ntohs(ip_hdr_ptr->tot_len);\n\n\tdata_offset = tcp_hdr_ptr->doff << 2;\n\tif (total_length == (ihl + data_offset)) {\n\t\tu32 seq_no, ack_no;\n\n\t\tseq_no = ntohl(tcp_hdr_ptr->seq);\n\t\tack_no = ntohl(tcp_hdr_ptr->ack_seq);\n\t\tfor (i = 0; i < f->tcp_session; i++) {\n\t\t\tu32 j = f->ack_session_info[i].seq_num;\n\n\t\t\tif (i < 2 * MAX_TCP_SESSION &&\n\t\t\t    j == seq_no) {\n\t\t\t\tupdate_tcp_session(vif, i, ack_no);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == f->tcp_session)\n\t\t\tadd_tcp_session(vif, 0, 0, seq_no);\n\n\t\tadd_tcp_pending_ack(vif, ack_no, i, tqe);\n\t}\n\nout:\n\tspin_unlock_irqrestore(&wilc->txq_spinlock, flags);\n}\n\nstatic void wilc_wlan_txq_filter_dup_tcp_ack(struct net_device *dev)\n{\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc *wilc = vif->wilc;\n\tstruct tcp_ack_filter *f = &vif->ack_filter;\n\tu32 i = 0;\n\tu32 dropped = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wilc->txq_spinlock, flags);\n\tfor (i = f->pending_base;\n\t     i < (f->pending_base + f->pending_acks_idx); i++) {\n\t\tu32 index;\n\t\tu32 bigger_ack_num;\n\n\t\tif (i >= MAX_PENDING_ACKS)\n\t\t\tbreak;\n\n\t\tindex = f->pending_acks[i].session_index;\n\n\t\tif (index >= 2 * MAX_TCP_SESSION)\n\t\t\tbreak;\n\n\t\tbigger_ack_num = f->ack_session_info[index].bigger_ack_num;\n\n\t\tif (f->pending_acks[i].ack_num < bigger_ack_num) {\n\t\t\tstruct txq_entry_t *tqe;\n\n\t\t\ttqe = f->pending_acks[i].txqe;\n\t\t\tif (tqe) {\n\t\t\t\twilc_wlan_txq_remove(wilc, tqe->q_num, tqe);\n\t\t\t\ttqe->status = 1;\n\t\t\t\tif (tqe->tx_complete_func)\n\t\t\t\t\ttqe->tx_complete_func(tqe->priv,\n\t\t\t\t\t\t\t      tqe->status);\n\t\t\t\tkfree(tqe);\n\t\t\t\tdropped++;\n\t\t\t}\n\t\t}\n\t}\n\tf->pending_acks_idx = 0;\n\tf->tcp_session = 0;\n\n\tif (f->pending_base == 0)\n\t\tf->pending_base = MAX_TCP_SESSION;\n\telse\n\t\tf->pending_base = 0;\n\n\tspin_unlock_irqrestore(&wilc->txq_spinlock, flags);\n\n\twhile (dropped > 0) {\n\t\twait_for_completion_timeout(&wilc->txq_event,\n\t\t\t\t\t    msecs_to_jiffies(1));\n\t\tdropped--;\n\t}\n}\n\nvoid wilc_enable_tcp_ack_filter(struct wilc_vif *vif, bool value)\n{\n\tvif->ack_filter.enabled = value;\n}\n\nstatic int wilc_wlan_txq_add_cfg_pkt(struct wilc_vif *vif, u8 *buffer,\n\t\t\t\t     u32 buffer_size)\n{\n\tstruct txq_entry_t *tqe;\n\tstruct wilc *wilc = vif->wilc;\n\n\tnetdev_dbg(vif->ndev, \"Adding config packet ...\\n\");\n\tif (wilc->quit) {\n\t\tnetdev_dbg(vif->ndev, \"Return due to clear function\\n\");\n\t\tcomplete(&wilc->cfg_event);\n\t\treturn 0;\n\t}\n\n\ttqe = kmalloc(sizeof(*tqe), GFP_ATOMIC);\n\tif (!tqe) {\n\t\tcomplete(&wilc->cfg_event);\n\t\treturn 0;\n\t}\n\n\ttqe->type = WILC_CFG_PKT;\n\ttqe->buffer = buffer;\n\ttqe->buffer_size = buffer_size;\n\ttqe->tx_complete_func = NULL;\n\ttqe->priv = NULL;\n\ttqe->q_num = AC_VO_Q;\n\ttqe->ack_idx = NOT_TCP_ACK;\n\ttqe->vif = vif;\n\n\twilc_wlan_txq_add_to_head(vif, AC_VO_Q, tqe);\n\n\treturn 1;\n}\n\nstatic bool is_ac_q_limit(struct wilc *wl, u8 q_num)\n{\n\tu8 factors[NQUEUES] = {1, 1, 1, 1};\n\tu16 i;\n\tunsigned long flags;\n\tstruct wilc_tx_queue_status *q = &wl->tx_q_limit;\n\tu8 end_index;\n\tu8 q_limit;\n\tbool ret = false;\n\n\tspin_lock_irqsave(&wl->txq_spinlock, flags);\n\tif (!q->initialized) {\n\t\tfor (i = 0; i < AC_BUFFER_SIZE; i++)\n\t\t\tq->buffer[i] = i % NQUEUES;\n\n\t\tfor (i = 0; i < NQUEUES; i++) {\n\t\t\tq->cnt[i] = AC_BUFFER_SIZE * factors[i] / NQUEUES;\n\t\t\tq->sum += q->cnt[i];\n\t\t}\n\t\tq->end_index = AC_BUFFER_SIZE - 1;\n\t\tq->initialized = 1;\n\t}\n\n\tend_index = q->end_index;\n\tq->cnt[q->buffer[end_index]] -= factors[q->buffer[end_index]];\n\tq->cnt[q_num] += factors[q_num];\n\tq->sum += (factors[q_num] - factors[q->buffer[end_index]]);\n\n\tq->buffer[end_index] = q_num;\n\tif (end_index > 0)\n\t\tq->end_index--;\n\telse\n\t\tq->end_index = AC_BUFFER_SIZE - 1;\n\n\tif (!q->sum)\n\t\tq_limit = 1;\n\telse\n\t\tq_limit = (q->cnt[q_num] * FLOW_CONTROL_UPPER_THRESHOLD / q->sum) + 1;\n\n\tif (wl->txq[q_num].count <= q_limit)\n\t\tret = true;\n\n\tspin_unlock_irqrestore(&wl->txq_spinlock, flags);\n\n\treturn ret;\n}\n\nstatic inline u8 ac_classify(struct wilc *wilc, struct sk_buff *skb)\n{\n\tu8 q_num = AC_BE_Q;\n\tu8 dscp;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tdscp = ipv4_get_dsfield(ip_hdr(skb)) & 0xfc;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tdscp = ipv6_get_dsfield(ipv6_hdr(skb)) & 0xfc;\n\t\tbreak;\n\tdefault:\n\t\treturn q_num;\n\t}\n\n\tswitch (dscp) {\n\tcase 0x08:\n\tcase 0x20:\n\tcase 0x40:\n\t\tq_num = AC_BK_Q;\n\t\tbreak;\n\tcase 0x80:\n\tcase 0xA0:\n\tcase 0x28:\n\t\tq_num = AC_VI_Q;\n\t\tbreak;\n\tcase 0xC0:\n\tcase 0xD0:\n\tcase 0xE0:\n\tcase 0x88:\n\tcase 0xB8:\n\t\tq_num = AC_VO_Q;\n\t\tbreak;\n\t}\n\n\treturn q_num;\n}\n\nstatic inline int ac_balance(struct wilc *wl, u8 *ratio)\n{\n\tu8 i, max_count = 0;\n\n\tif (!ratio)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < NQUEUES; i++)\n\t\tif (wl->txq[i].fw.count > max_count)\n\t\t\tmax_count = wl->txq[i].fw.count;\n\n\tfor (i = 0; i < NQUEUES; i++)\n\t\tratio[i] = max_count - wl->txq[i].fw.count;\n\n\treturn 0;\n}\n\nstatic inline void ac_update_fw_ac_pkt_info(struct wilc *wl, u32 reg)\n{\n\twl->txq[AC_BK_Q].fw.count = FIELD_GET(BK_AC_COUNT_FIELD, reg);\n\twl->txq[AC_BE_Q].fw.count = FIELD_GET(BE_AC_COUNT_FIELD, reg);\n\twl->txq[AC_VI_Q].fw.count = FIELD_GET(VI_AC_COUNT_FIELD, reg);\n\twl->txq[AC_VO_Q].fw.count = FIELD_GET(VO_AC_COUNT_FIELD, reg);\n\n\twl->txq[AC_BK_Q].fw.acm = FIELD_GET(BK_AC_ACM_STAT_FIELD, reg);\n\twl->txq[AC_BE_Q].fw.acm = FIELD_GET(BE_AC_ACM_STAT_FIELD, reg);\n\twl->txq[AC_VI_Q].fw.acm = FIELD_GET(VI_AC_ACM_STAT_FIELD, reg);\n\twl->txq[AC_VO_Q].fw.acm = FIELD_GET(VO_AC_ACM_STAT_FIELD, reg);\n}\n\nstatic inline u8 ac_change(struct wilc *wilc, u8 *ac)\n{\n\tdo {\n\t\tif (wilc->txq[*ac].fw.acm == 0)\n\t\t\treturn 0;\n\t\t(*ac)++;\n\t} while (*ac < NQUEUES);\n\n\treturn 1;\n}\n\nint wilc_wlan_txq_add_net_pkt(struct net_device *dev,\n\t\t\t      struct tx_complete_data *tx_data, u8 *buffer,\n\t\t\t      u32 buffer_size,\n\t\t\t      void (*tx_complete_fn)(void *, int))\n{\n\tstruct txq_entry_t *tqe;\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc *wilc;\n\tu8 q_num;\n\n\twilc = vif->wilc;\n\n\tif (wilc->quit) {\n\t\ttx_complete_fn(tx_data, 0);\n\t\treturn 0;\n\t}\n\n\tif (!wilc->initialized) {\n\t\ttx_complete_fn(tx_data, 0);\n\t\treturn 0;\n\t}\n\n\ttqe = kmalloc(sizeof(*tqe), GFP_ATOMIC);\n\n\tif (!tqe) {\n\t\ttx_complete_fn(tx_data, 0);\n\t\treturn 0;\n\t}\n\ttqe->type = WILC_NET_PKT;\n\ttqe->buffer = buffer;\n\ttqe->buffer_size = buffer_size;\n\ttqe->tx_complete_func = tx_complete_fn;\n\ttqe->priv = tx_data;\n\ttqe->vif = vif;\n\n\tq_num = ac_classify(wilc, tx_data->skb);\n\ttqe->q_num = q_num;\n\tif (ac_change(wilc, &q_num)) {\n\t\ttx_complete_fn(tx_data, 0);\n\t\tkfree(tqe);\n\t\treturn 0;\n\t}\n\n\tif (is_ac_q_limit(wilc, q_num)) {\n\t\ttqe->ack_idx = NOT_TCP_ACK;\n\t\tif (vif->ack_filter.enabled)\n\t\t\ttcp_process(dev, tqe);\n\t\twilc_wlan_txq_add_to_tail(dev, q_num, tqe);\n\t} else {\n\t\ttx_complete_fn(tx_data, 0);\n\t\tkfree(tqe);\n\t}\n\n\treturn wilc->txq_entries;\n}\n\nint wilc_wlan_txq_add_mgmt_pkt(struct net_device *dev, void *priv, u8 *buffer,\n\t\t\t       u32 buffer_size,\n\t\t\t       void (*tx_complete_fn)(void *, int))\n{\n\tstruct txq_entry_t *tqe;\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc *wilc;\n\n\twilc = vif->wilc;\n\n\tif (wilc->quit) {\n\t\ttx_complete_fn(priv, 0);\n\t\treturn 0;\n\t}\n\n\tif (!wilc->initialized) {\n\t\ttx_complete_fn(priv, 0);\n\t\treturn 0;\n\t}\n\ttqe = kmalloc(sizeof(*tqe), GFP_ATOMIC);\n\n\tif (!tqe) {\n\t\ttx_complete_fn(priv, 0);\n\t\treturn 0;\n\t}\n\ttqe->type = WILC_MGMT_PKT;\n\ttqe->buffer = buffer;\n\ttqe->buffer_size = buffer_size;\n\ttqe->tx_complete_func = tx_complete_fn;\n\ttqe->priv = priv;\n\ttqe->q_num = AC_BE_Q;\n\ttqe->ack_idx = NOT_TCP_ACK;\n\ttqe->vif = vif;\n\twilc_wlan_txq_add_to_tail(dev, AC_VO_Q, tqe);\n\treturn 1;\n}\n\nstatic struct txq_entry_t *wilc_wlan_txq_get_first(struct wilc *wilc, u8 q_num)\n{\n\tstruct txq_entry_t *tqe = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wilc->txq_spinlock, flags);\n\n\tif (!list_empty(&wilc->txq[q_num].txq_head.list))\n\t\ttqe = list_first_entry(&wilc->txq[q_num].txq_head.list,\n\t\t\t\t       struct txq_entry_t, list);\n\n\tspin_unlock_irqrestore(&wilc->txq_spinlock, flags);\n\n\treturn tqe;\n}\n\nstatic struct txq_entry_t *wilc_wlan_txq_get_next(struct wilc *wilc,\n\t\t\t\t\t\t  struct txq_entry_t *tqe,\n\t\t\t\t\t\t  u8 q_num)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wilc->txq_spinlock, flags);\n\n\tif (!list_is_last(&tqe->list, &wilc->txq[q_num].txq_head.list))\n\t\ttqe = list_next_entry(tqe, list);\n\telse\n\t\ttqe = NULL;\n\tspin_unlock_irqrestore(&wilc->txq_spinlock, flags);\n\n\treturn tqe;\n}\n\nstatic void wilc_wlan_rxq_add(struct wilc *wilc, struct rxq_entry_t *rqe)\n{\n\tif (wilc->quit)\n\t\treturn;\n\n\tmutex_lock(&wilc->rxq_cs);\n\tlist_add_tail(&rqe->list, &wilc->rxq_head.list);\n\tmutex_unlock(&wilc->rxq_cs);\n}\n\nstatic struct rxq_entry_t *wilc_wlan_rxq_remove(struct wilc *wilc)\n{\n\tstruct rxq_entry_t *rqe = NULL;\n\n\tmutex_lock(&wilc->rxq_cs);\n\tif (!list_empty(&wilc->rxq_head.list)) {\n\t\trqe = list_first_entry(&wilc->rxq_head.list, struct rxq_entry_t,\n\t\t\t\t       list);\n\t\tlist_del(&rqe->list);\n\t}\n\tmutex_unlock(&wilc->rxq_cs);\n\treturn rqe;\n}\n\nvoid chip_allow_sleep(struct wilc *wilc)\n{\n\tu32 reg = 0;\n\tconst struct wilc_hif_func *hif_func = wilc->hif_func;\n\tu32 wakeup_reg, wakeup_bit;\n\tu32 to_host_from_fw_reg, to_host_from_fw_bit;\n\tu32 from_host_to_fw_reg, from_host_to_fw_bit;\n\tu32 trials = 100;\n\tint ret;\n\n\tif (wilc->io_type == WILC_HIF_SDIO) {\n\t\twakeup_reg = WILC_SDIO_WAKEUP_REG;\n\t\twakeup_bit = WILC_SDIO_WAKEUP_BIT;\n\t\tfrom_host_to_fw_reg = WILC_SDIO_HOST_TO_FW_REG;\n\t\tfrom_host_to_fw_bit = WILC_SDIO_HOST_TO_FW_BIT;\n\t\tto_host_from_fw_reg = WILC_SDIO_FW_TO_HOST_REG;\n\t\tto_host_from_fw_bit = WILC_SDIO_FW_TO_HOST_BIT;\n\t} else {\n\t\twakeup_reg = WILC_SPI_WAKEUP_REG;\n\t\twakeup_bit = WILC_SPI_WAKEUP_BIT;\n\t\tfrom_host_to_fw_reg = WILC_SPI_HOST_TO_FW_REG;\n\t\tfrom_host_to_fw_bit = WILC_SPI_HOST_TO_FW_BIT;\n\t\tto_host_from_fw_reg = WILC_SPI_FW_TO_HOST_REG;\n\t\tto_host_from_fw_bit = WILC_SPI_FW_TO_HOST_BIT;\n\t}\n\n\twhile (--trials) {\n\t\tret = hif_func->hif_read_reg(wilc, to_host_from_fw_reg, &reg);\n\t\tif (ret)\n\t\t\treturn;\n\t\tif ((reg & to_host_from_fw_bit) == 0)\n\t\t\tbreak;\n\t}\n\tif (!trials)\n\t\tpr_warn(\"FW not responding\\n\");\n\n\t \n\tret = hif_func->hif_read_reg(wilc, wakeup_reg, &reg);\n\tif (ret)\n\t\treturn;\n\tif (reg & wakeup_bit) {\n\t\treg &= ~wakeup_bit;\n\t\tret = hif_func->hif_write_reg(wilc, wakeup_reg, reg);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tret = hif_func->hif_read_reg(wilc, from_host_to_fw_reg, &reg);\n\tif (ret)\n\t\treturn;\n\tif (reg & from_host_to_fw_bit) {\n\t\treg &= ~from_host_to_fw_bit;\n\t\tret = hif_func->hif_write_reg(wilc, from_host_to_fw_reg, reg);\n\t\tif (ret)\n\t\t\treturn;\n\n\t}\n}\nEXPORT_SYMBOL_GPL(chip_allow_sleep);\n\nvoid chip_wakeup(struct wilc *wilc)\n{\n\tu32 ret = 0;\n\tu32 clk_status_val = 0, trials = 0;\n\tu32 wakeup_reg, wakeup_bit;\n\tu32 clk_status_reg, clk_status_bit;\n\tu32 from_host_to_fw_reg, from_host_to_fw_bit;\n\tconst struct wilc_hif_func *hif_func = wilc->hif_func;\n\n\tif (wilc->io_type == WILC_HIF_SDIO) {\n\t\twakeup_reg = WILC_SDIO_WAKEUP_REG;\n\t\twakeup_bit = WILC_SDIO_WAKEUP_BIT;\n\t\tclk_status_reg = WILC_SDIO_CLK_STATUS_REG;\n\t\tclk_status_bit = WILC_SDIO_CLK_STATUS_BIT;\n\t\tfrom_host_to_fw_reg = WILC_SDIO_HOST_TO_FW_REG;\n\t\tfrom_host_to_fw_bit = WILC_SDIO_HOST_TO_FW_BIT;\n\t} else {\n\t\twakeup_reg = WILC_SPI_WAKEUP_REG;\n\t\twakeup_bit = WILC_SPI_WAKEUP_BIT;\n\t\tclk_status_reg = WILC_SPI_CLK_STATUS_REG;\n\t\tclk_status_bit = WILC_SPI_CLK_STATUS_BIT;\n\t\tfrom_host_to_fw_reg = WILC_SPI_HOST_TO_FW_REG;\n\t\tfrom_host_to_fw_bit = WILC_SPI_HOST_TO_FW_BIT;\n\t}\n\n\t \n\tret = hif_func->hif_write_reg(wilc, from_host_to_fw_reg,\n\t\t\t\t      from_host_to_fw_bit);\n\tif (ret)\n\t\treturn;\n\n\t \n\tret = hif_func->hif_write_reg(wilc, wakeup_reg,\n\t\t\t\t      wakeup_bit);\n\tif (ret)\n\t\treturn;\n\n\twhile (trials < WAKE_UP_TRIAL_RETRY) {\n\t\tret = hif_func->hif_read_reg(wilc, clk_status_reg,\n\t\t\t\t\t     &clk_status_val);\n\t\tif (ret) {\n\t\t\tpr_err(\"Bus error %d %x\\n\", ret, clk_status_val);\n\t\t\treturn;\n\t\t}\n\t\tif (clk_status_val & clk_status_bit)\n\t\t\tbreak;\n\n\t\ttrials++;\n\t}\n\tif (trials >= WAKE_UP_TRIAL_RETRY) {\n\t\tpr_err(\"Failed to wake-up the chip\\n\");\n\t\treturn;\n\t}\n\t \n\tif (wilc->io_type == WILC_HIF_SPI)\n\t\twilc->hif_func->hif_reset(wilc);\n}\nEXPORT_SYMBOL_GPL(chip_wakeup);\n\nvoid host_wakeup_notify(struct wilc *wilc)\n{\n\tacquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY);\n\twilc->hif_func->hif_write_reg(wilc, WILC_CORTUS_INTERRUPT_2, 1);\n\trelease_bus(wilc, WILC_BUS_RELEASE_ONLY);\n}\nEXPORT_SYMBOL_GPL(host_wakeup_notify);\n\nvoid host_sleep_notify(struct wilc *wilc)\n{\n\tacquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY);\n\twilc->hif_func->hif_write_reg(wilc, WILC_CORTUS_INTERRUPT_1, 1);\n\trelease_bus(wilc, WILC_BUS_RELEASE_ONLY);\n}\nEXPORT_SYMBOL_GPL(host_sleep_notify);\n\nint wilc_wlan_handle_txq(struct wilc *wilc, u32 *txq_count)\n{\n\tint i, entries = 0;\n\tu8 k, ac;\n\tu32 sum;\n\tu32 reg;\n\tu8 ac_desired_ratio[NQUEUES] = {0, 0, 0, 0};\n\tu8 ac_preserve_ratio[NQUEUES] = {1, 1, 1, 1};\n\tu8 *num_pkts_to_add;\n\tu8 vmm_entries_ac[WILC_VMM_TBL_SIZE];\n\tu32 offset = 0;\n\tbool max_size_over = 0, ac_exist = 0;\n\tint vmm_sz = 0;\n\tstruct txq_entry_t *tqe_q[NQUEUES];\n\tint ret = 0;\n\tint counter;\n\tint timeout;\n\tu32 *vmm_table = wilc->vmm_table;\n\tu8 ac_pkt_num_to_chip[NQUEUES] = {0, 0, 0, 0};\n\tconst struct wilc_hif_func *func;\n\tint srcu_idx;\n\tu8 *txb = wilc->tx_buffer;\n\tstruct wilc_vif *vif;\n\n\tif (wilc->quit)\n\t\tgoto out_update_cnt;\n\n\tif (ac_balance(wilc, ac_desired_ratio))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&wilc->txq_add_to_head_cs);\n\n\tsrcu_idx = srcu_read_lock(&wilc->srcu);\n\tlist_for_each_entry_rcu(vif, &wilc->vif_list, list)\n\t\twilc_wlan_txq_filter_dup_tcp_ack(vif->ndev);\n\tsrcu_read_unlock(&wilc->srcu, srcu_idx);\n\n\tfor (ac = 0; ac < NQUEUES; ac++)\n\t\ttqe_q[ac] = wilc_wlan_txq_get_first(wilc, ac);\n\n\ti = 0;\n\tsum = 0;\n\tmax_size_over = 0;\n\tnum_pkts_to_add = ac_desired_ratio;\n\tdo {\n\t\tac_exist = 0;\n\t\tfor (ac = 0; (ac < NQUEUES) && (!max_size_over); ac++) {\n\t\t\tif (!tqe_q[ac])\n\t\t\t\tcontinue;\n\n\t\t\tac_exist = 1;\n\t\t\tfor (k = 0; (k < num_pkts_to_add[ac]) &&\n\t\t\t     (!max_size_over) && tqe_q[ac]; k++) {\n\t\t\t\tif (i >= (WILC_VMM_TBL_SIZE - 1)) {\n\t\t\t\t\tmax_size_over = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (tqe_q[ac]->type == WILC_CFG_PKT)\n\t\t\t\t\tvmm_sz = ETH_CONFIG_PKT_HDR_OFFSET;\n\t\t\t\telse if (tqe_q[ac]->type == WILC_NET_PKT)\n\t\t\t\t\tvmm_sz = ETH_ETHERNET_HDR_OFFSET;\n\t\t\t\telse\n\t\t\t\t\tvmm_sz = HOST_HDR_OFFSET;\n\n\t\t\t\tvmm_sz += tqe_q[ac]->buffer_size;\n\t\t\t\tvmm_sz = ALIGN(vmm_sz, 4);\n\n\t\t\t\tif ((sum + vmm_sz) > WILC_TX_BUFF_SIZE) {\n\t\t\t\t\tmax_size_over = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvmm_table[i] = vmm_sz / 4;\n\t\t\t\tif (tqe_q[ac]->type == WILC_CFG_PKT)\n\t\t\t\t\tvmm_table[i] |= BIT(10);\n\n\t\t\t\tcpu_to_le32s(&vmm_table[i]);\n\t\t\t\tvmm_entries_ac[i] = ac;\n\n\t\t\t\ti++;\n\t\t\t\tsum += vmm_sz;\n\t\t\t\ttqe_q[ac] = wilc_wlan_txq_get_next(wilc,\n\t\t\t\t\t\t\t\t   tqe_q[ac],\n\t\t\t\t\t\t\t\t   ac);\n\t\t\t}\n\t\t}\n\t\tnum_pkts_to_add = ac_preserve_ratio;\n\t} while (!max_size_over && ac_exist);\n\n\tif (i == 0)\n\t\tgoto out_unlock;\n\tvmm_table[i] = 0x0;\n\n\tacquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP);\n\tcounter = 0;\n\tfunc = wilc->hif_func;\n\tdo {\n\t\tret = func->hif_read_reg(wilc, WILC_HOST_TX_CTRL, &reg);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif ((reg & 0x1) == 0) {\n\t\t\tac_update_fw_ac_pkt_info(wilc, reg);\n\t\t\tbreak;\n\t\t}\n\n\t\tcounter++;\n\t\tif (counter > 200) {\n\t\t\tcounter = 0;\n\t\t\tret = func->hif_write_reg(wilc, WILC_HOST_TX_CTRL, 0);\n\t\t\tbreak;\n\t\t}\n\t} while (!wilc->quit);\n\n\tif (ret)\n\t\tgoto out_release_bus;\n\n\ttimeout = 200;\n\tdo {\n\t\tret = func->hif_block_tx(wilc,\n\t\t\t\t\t WILC_VMM_TBL_RX_SHADOW_BASE,\n\t\t\t\t\t (u8 *)vmm_table,\n\t\t\t\t\t ((i + 1) * 4));\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = func->hif_write_reg(wilc, WILC_HOST_VMM_CTL, 0x2);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tdo {\n\t\t\tret = func->hif_read_reg(wilc, WILC_HOST_VMM_CTL, &reg);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (FIELD_GET(WILC_VMM_ENTRY_AVAILABLE, reg)) {\n\t\t\t\tentries = FIELD_GET(WILC_VMM_ENTRY_COUNT, reg);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (--timeout);\n\t\tif (timeout <= 0) {\n\t\t\tret = func->hif_write_reg(wilc, WILC_HOST_VMM_CTL, 0x0);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (entries == 0) {\n\t\t\tret = func->hif_read_reg(wilc, WILC_HOST_TX_CTRL, &reg);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\treg &= ~BIT(0);\n\t\t\tret = func->hif_write_reg(wilc, WILC_HOST_TX_CTRL, reg);\n\t\t}\n\t} while (0);\n\n\tif (ret)\n\t\tgoto out_release_bus;\n\n\tif (entries == 0) {\n\t\t \n\t\tret = WILC_VMM_ENTRY_FULL_RETRY;\n\t\tgoto out_release_bus;\n\t}\n\n\trelease_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP);\n\n\toffset = 0;\n\ti = 0;\n\tdo {\n\t\tstruct txq_entry_t *tqe;\n\t\tu32 header, buffer_offset;\n\t\tchar *bssid;\n\t\tu8 mgmt_ptk = 0;\n\n\t\tif (vmm_table[i] == 0 || vmm_entries_ac[i] >= NQUEUES)\n\t\t\tbreak;\n\n\t\ttqe = wilc_wlan_txq_remove_from_head(wilc, vmm_entries_ac[i]);\n\t\tif (!tqe)\n\t\t\tbreak;\n\n\t\tac_pkt_num_to_chip[vmm_entries_ac[i]]++;\n\t\tvif = tqe->vif;\n\n\t\tle32_to_cpus(&vmm_table[i]);\n\t\tvmm_sz = FIELD_GET(WILC_VMM_BUFFER_SIZE, vmm_table[i]);\n\t\tvmm_sz *= 4;\n\n\t\tif (tqe->type == WILC_MGMT_PKT)\n\t\t\tmgmt_ptk = 1;\n\n\t\theader = (FIELD_PREP(WILC_VMM_HDR_TYPE, tqe->type) |\n\t\t\t  FIELD_PREP(WILC_VMM_HDR_MGMT_FIELD, mgmt_ptk) |\n\t\t\t  FIELD_PREP(WILC_VMM_HDR_PKT_SIZE, tqe->buffer_size) |\n\t\t\t  FIELD_PREP(WILC_VMM_HDR_BUFF_SIZE, vmm_sz));\n\n\t\tcpu_to_le32s(&header);\n\t\tmemcpy(&txb[offset], &header, 4);\n\t\tif (tqe->type == WILC_CFG_PKT) {\n\t\t\tbuffer_offset = ETH_CONFIG_PKT_HDR_OFFSET;\n\t\t} else if (tqe->type == WILC_NET_PKT) {\n\t\t\tint prio = tqe->q_num;\n\n\t\t\tbssid = tqe->vif->bssid;\n\t\t\tbuffer_offset = ETH_ETHERNET_HDR_OFFSET;\n\t\t\tmemcpy(&txb[offset + 4], &prio, sizeof(prio));\n\t\t\tmemcpy(&txb[offset + 8], bssid, 6);\n\t\t} else {\n\t\t\tbuffer_offset = HOST_HDR_OFFSET;\n\t\t}\n\n\t\tmemcpy(&txb[offset + buffer_offset],\n\t\t       tqe->buffer, tqe->buffer_size);\n\t\toffset += vmm_sz;\n\t\ti++;\n\t\ttqe->status = 1;\n\t\tif (tqe->tx_complete_func)\n\t\t\ttqe->tx_complete_func(tqe->priv, tqe->status);\n\t\tif (tqe->ack_idx != NOT_TCP_ACK &&\n\t\t    tqe->ack_idx < MAX_PENDING_ACKS)\n\t\t\tvif->ack_filter.pending_acks[tqe->ack_idx].txqe = NULL;\n\t\tkfree(tqe);\n\t} while (--entries);\n\tfor (i = 0; i < NQUEUES; i++)\n\t\twilc->txq[i].fw.count += ac_pkt_num_to_chip[i];\n\n\tacquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP);\n\n\tret = func->hif_clear_int_ext(wilc, ENABLE_TX_VMM);\n\tif (ret)\n\t\tgoto out_release_bus;\n\n\tret = func->hif_block_tx_ext(wilc, 0, txb, offset);\n\nout_release_bus:\n\trelease_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP);\n\nout_unlock:\n\tmutex_unlock(&wilc->txq_add_to_head_cs);\n\nout_update_cnt:\n\t*txq_count = wilc->txq_entries;\n\treturn ret;\n}\n\nstatic void wilc_wlan_handle_rx_buff(struct wilc *wilc, u8 *buffer, int size)\n{\n\tint offset = 0;\n\tu32 header;\n\tu32 pkt_len, pkt_offset, tp_len;\n\tint is_cfg_packet;\n\tu8 *buff_ptr;\n\n\tdo {\n\t\tbuff_ptr = buffer + offset;\n\t\theader = get_unaligned_le32(buff_ptr);\n\n\t\tis_cfg_packet = FIELD_GET(WILC_PKT_HDR_CONFIG_FIELD, header);\n\t\tpkt_offset = FIELD_GET(WILC_PKT_HDR_OFFSET_FIELD, header);\n\t\ttp_len = FIELD_GET(WILC_PKT_HDR_TOTAL_LEN_FIELD, header);\n\t\tpkt_len = FIELD_GET(WILC_PKT_HDR_LEN_FIELD, header);\n\n\t\tif (pkt_len == 0 || tp_len == 0)\n\t\t\tbreak;\n\n\t\tif (pkt_offset & IS_MANAGMEMENT) {\n\t\t\tbuff_ptr += HOST_HDR_OFFSET;\n\t\t\twilc_wfi_mgmt_rx(wilc, buff_ptr, pkt_len,\n\t\t\t\t\t pkt_offset & IS_MGMT_AUTH_PKT);\n\t\t} else {\n\t\t\tif (!is_cfg_packet) {\n\t\t\t\twilc_frmw_to_host(wilc, buff_ptr, pkt_len,\n\t\t\t\t\t\t  pkt_offset);\n\t\t\t} else {\n\t\t\t\tstruct wilc_cfg_rsp rsp;\n\n\t\t\t\tbuff_ptr += pkt_offset;\n\n\t\t\t\twilc_wlan_cfg_indicate_rx(wilc, buff_ptr,\n\t\t\t\t\t\t\t  pkt_len,\n\t\t\t\t\t\t\t  &rsp);\n\t\t\t\tif (rsp.type == WILC_CFG_RSP) {\n\t\t\t\t\tif (wilc->cfg_seq_no == rsp.seq_no)\n\t\t\t\t\t\tcomplete(&wilc->cfg_event);\n\t\t\t\t} else if (rsp.type == WILC_CFG_RSP_STATUS) {\n\t\t\t\t\twilc_mac_indicate(wilc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\toffset += tp_len;\n\t} while (offset < size);\n}\n\nstatic void wilc_wlan_handle_rxq(struct wilc *wilc)\n{\n\tint size;\n\tu8 *buffer;\n\tstruct rxq_entry_t *rqe;\n\n\twhile (!wilc->quit) {\n\t\trqe = wilc_wlan_rxq_remove(wilc);\n\t\tif (!rqe)\n\t\t\tbreak;\n\n\t\tbuffer = rqe->buffer;\n\t\tsize = rqe->buffer_size;\n\t\twilc_wlan_handle_rx_buff(wilc, buffer, size);\n\n\t\tkfree(rqe);\n\t}\n\tif (wilc->quit)\n\t\tcomplete(&wilc->cfg_event);\n}\n\nstatic void wilc_unknown_isr_ext(struct wilc *wilc)\n{\n\twilc->hif_func->hif_clear_int_ext(wilc, 0);\n}\n\nstatic void wilc_wlan_handle_isr_ext(struct wilc *wilc, u32 int_status)\n{\n\tu32 offset = wilc->rx_buffer_offset;\n\tu8 *buffer = NULL;\n\tu32 size;\n\tu32 retries = 0;\n\tint ret = 0;\n\tstruct rxq_entry_t *rqe;\n\n\tsize = FIELD_GET(WILC_INTERRUPT_DATA_SIZE, int_status) << 2;\n\n\twhile (!size && retries < 10) {\n\t\twilc->hif_func->hif_read_size(wilc, &size);\n\t\tsize = FIELD_GET(WILC_INTERRUPT_DATA_SIZE, size) << 2;\n\t\tretries++;\n\t}\n\n\tif (size <= 0)\n\t\treturn;\n\n\tif (WILC_RX_BUFF_SIZE - offset < size)\n\t\toffset = 0;\n\n\tbuffer = &wilc->rx_buffer[offset];\n\n\twilc->hif_func->hif_clear_int_ext(wilc, DATA_INT_CLR | ENABLE_RX_VMM);\n\tret = wilc->hif_func->hif_block_rx_ext(wilc, 0, buffer, size);\n\tif (ret)\n\t\treturn;\n\n\toffset += size;\n\twilc->rx_buffer_offset = offset;\n\trqe = kmalloc(sizeof(*rqe), GFP_KERNEL);\n\tif (!rqe)\n\t\treturn;\n\n\trqe->buffer = buffer;\n\trqe->buffer_size = size;\n\twilc_wlan_rxq_add(wilc, rqe);\n\twilc_wlan_handle_rxq(wilc);\n}\n\nvoid wilc_handle_isr(struct wilc *wilc)\n{\n\tu32 int_status;\n\n\tacquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP);\n\twilc->hif_func->hif_read_int(wilc, &int_status);\n\n\tif (int_status & DATA_INT_EXT)\n\t\twilc_wlan_handle_isr_ext(wilc, int_status);\n\n\tif (!(int_status & (ALL_INT_EXT)))\n\t\twilc_unknown_isr_ext(wilc);\n\n\trelease_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP);\n}\nEXPORT_SYMBOL_GPL(wilc_handle_isr);\n\nint wilc_wlan_firmware_download(struct wilc *wilc, const u8 *buffer,\n\t\t\t\tu32 buffer_size)\n{\n\tu32 offset;\n\tu32 addr, size, size2, blksz;\n\tu8 *dma_buffer;\n\tint ret = 0;\n\tu32 reg = 0;\n\n\tblksz = BIT(12);\n\n\tdma_buffer = kmalloc(blksz, GFP_KERNEL);\n\tif (!dma_buffer)\n\t\treturn -EIO;\n\n\toffset = 0;\n\tpr_debug(\"%s: Downloading firmware size = %d\\n\", __func__, buffer_size);\n\n\tacquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP);\n\n\twilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);\n\treg &= ~BIT(10);\n\tret = wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);\n\twilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);\n\tif (reg & BIT(10))\n\t\tpr_err(\"%s: Failed to reset\\n\", __func__);\n\n\trelease_bus(wilc, WILC_BUS_RELEASE_ONLY);\n\tdo {\n\t\taddr = get_unaligned_le32(&buffer[offset]);\n\t\tsize = get_unaligned_le32(&buffer[offset + 4]);\n\t\tacquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP);\n\t\toffset += 8;\n\t\twhile (((int)size) && (offset < buffer_size)) {\n\t\t\tif (size <= blksz)\n\t\t\t\tsize2 = size;\n\t\t\telse\n\t\t\t\tsize2 = blksz;\n\n\t\t\tmemcpy(dma_buffer, &buffer[offset], size2);\n\t\t\tret = wilc->hif_func->hif_block_tx(wilc, addr,\n\t\t\t\t\t\t\t   dma_buffer, size2);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\taddr += size2;\n\t\t\toffset += size2;\n\t\t\tsize -= size2;\n\t\t}\n\t\trelease_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP);\n\n\t\tif (ret) {\n\t\t\tpr_err(\"%s Bus error\\n\", __func__);\n\t\t\tgoto fail;\n\t\t}\n\t\tpr_debug(\"%s Offset = %d\\n\", __func__, offset);\n\t} while (offset < buffer_size);\n\nfail:\n\n\tkfree(dma_buffer);\n\n\treturn ret;\n}\n\nint wilc_wlan_start(struct wilc *wilc)\n{\n\tu32 reg = 0;\n\tint ret;\n\tu32 chipid;\n\n\tif (wilc->io_type == WILC_HIF_SDIO) {\n\t\treg = 0;\n\t\treg |= BIT(3);\n\t} else if (wilc->io_type == WILC_HIF_SPI) {\n\t\treg = 1;\n\t}\n\tacquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY);\n\tret = wilc->hif_func->hif_write_reg(wilc, WILC_VMM_CORE_CFG, reg);\n\tif (ret)\n\t\tgoto release;\n\n\treg = 0;\n\tif (wilc->io_type == WILC_HIF_SDIO && wilc->dev_irq_num)\n\t\treg |= WILC_HAVE_SDIO_IRQ_GPIO;\n\n\tret = wilc->hif_func->hif_write_reg(wilc, WILC_GP_REG_1, reg);\n\tif (ret)\n\t\tgoto release;\n\n\twilc->hif_func->hif_sync_ext(wilc, NUM_INT_EXT);\n\n\tret = wilc->hif_func->hif_read_reg(wilc, WILC_CHIPID, &chipid);\n\tif (ret)\n\t\tgoto release;\n\n\twilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);\n\tif ((reg & BIT(10)) == BIT(10)) {\n\t\treg &= ~BIT(10);\n\t\twilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);\n\t\twilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);\n\t}\n\n\treg |= BIT(10);\n\tret = wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);\n\twilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);\n\nrelease:\n\trelease_bus(wilc, WILC_BUS_RELEASE_ONLY);\n\treturn ret;\n}\n\nint wilc_wlan_stop(struct wilc *wilc, struct wilc_vif *vif)\n{\n\tu32 reg = 0;\n\tint ret;\n\n\tacquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP);\n\n\tret = wilc->hif_func->hif_read_reg(wilc, WILC_GP_REG_0, &reg);\n\tif (ret) {\n\t\tnetdev_err(vif->ndev, \"Error while reading reg\\n\");\n\t\tgoto release;\n\t}\n\n\tret = wilc->hif_func->hif_write_reg(wilc, WILC_GP_REG_0,\n\t\t\t\t\t(reg | WILC_ABORT_REQ_BIT));\n\tif (ret) {\n\t\tnetdev_err(vif->ndev, \"Error while writing reg\\n\");\n\t\tgoto release;\n\t}\n\n\tret = wilc->hif_func->hif_read_reg(wilc, WILC_FW_HOST_COMM, &reg);\n\tif (ret) {\n\t\tnetdev_err(vif->ndev, \"Error while reading reg\\n\");\n\t\tgoto release;\n\t}\n\treg = BIT(0);\n\n\tret = wilc->hif_func->hif_write_reg(wilc, WILC_FW_HOST_COMM, reg);\n\tif (ret) {\n\t\tnetdev_err(vif->ndev, \"Error while writing reg\\n\");\n\t\tgoto release;\n\t}\n\n\tret = 0;\nrelease:\n\t \n\trelease_bus(wilc, WILC_BUS_RELEASE_ONLY);\n\n\treturn ret;\n}\n\nvoid wilc_wlan_cleanup(struct net_device *dev)\n{\n\tstruct txq_entry_t *tqe;\n\tstruct rxq_entry_t *rqe;\n\tu8 ac;\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc *wilc = vif->wilc;\n\n\twilc->quit = 1;\n\tfor (ac = 0; ac < NQUEUES; ac++) {\n\t\twhile ((tqe = wilc_wlan_txq_remove_from_head(wilc, ac))) {\n\t\t\tif (tqe->tx_complete_func)\n\t\t\t\ttqe->tx_complete_func(tqe->priv, 0);\n\t\t\tkfree(tqe);\n\t\t}\n\t}\n\n\twhile ((rqe = wilc_wlan_rxq_remove(wilc)))\n\t\tkfree(rqe);\n\n\tkfree(wilc->vmm_table);\n\twilc->vmm_table = NULL;\n\tkfree(wilc->rx_buffer);\n\twilc->rx_buffer = NULL;\n\tkfree(wilc->tx_buffer);\n\twilc->tx_buffer = NULL;\n\twilc->hif_func->hif_deinit(wilc);\n}\n\nstatic int wilc_wlan_cfg_commit(struct wilc_vif *vif, int type,\n\t\t\t\tu32 drv_handler)\n{\n\tstruct wilc *wilc = vif->wilc;\n\tstruct wilc_cfg_frame *cfg = &wilc->cfg_frame;\n\tint t_len = wilc->cfg_frame_offset + sizeof(struct wilc_cfg_cmd_hdr);\n\n\tif (type == WILC_CFG_SET)\n\t\tcfg->hdr.cmd_type = 'W';\n\telse\n\t\tcfg->hdr.cmd_type = 'Q';\n\n\tcfg->hdr.seq_no = wilc->cfg_seq_no % 256;\n\tcfg->hdr.total_len = cpu_to_le16(t_len);\n\tcfg->hdr.driver_handler = cpu_to_le32(drv_handler);\n\twilc->cfg_seq_no = cfg->hdr.seq_no;\n\n\tif (!wilc_wlan_txq_add_cfg_pkt(vif, (u8 *)&cfg->hdr, t_len))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nint wilc_wlan_cfg_set(struct wilc_vif *vif, int start, u16 wid, u8 *buffer,\n\t\t      u32 buffer_size, int commit, u32 drv_handler)\n{\n\tu32 offset;\n\tint ret_size;\n\tstruct wilc *wilc = vif->wilc;\n\n\tmutex_lock(&wilc->cfg_cmd_lock);\n\n\tif (start)\n\t\twilc->cfg_frame_offset = 0;\n\n\toffset = wilc->cfg_frame_offset;\n\tret_size = wilc_wlan_cfg_set_wid(wilc->cfg_frame.frame, offset,\n\t\t\t\t\t wid, buffer, buffer_size);\n\toffset += ret_size;\n\twilc->cfg_frame_offset = offset;\n\n\tif (!commit) {\n\t\tmutex_unlock(&wilc->cfg_cmd_lock);\n\t\treturn ret_size;\n\t}\n\n\tnetdev_dbg(vif->ndev, \"%s: seqno[%d]\\n\", __func__, wilc->cfg_seq_no);\n\n\tif (wilc_wlan_cfg_commit(vif, WILC_CFG_SET, drv_handler))\n\t\tret_size = 0;\n\n\tif (!wait_for_completion_timeout(&wilc->cfg_event,\n\t\t\t\t\t WILC_CFG_PKTS_TIMEOUT)) {\n\t\tnetdev_dbg(vif->ndev, \"%s: Timed Out\\n\", __func__);\n\t\tret_size = 0;\n\t}\n\n\twilc->cfg_frame_offset = 0;\n\twilc->cfg_seq_no += 1;\n\tmutex_unlock(&wilc->cfg_cmd_lock);\n\n\treturn ret_size;\n}\n\nint wilc_wlan_cfg_get(struct wilc_vif *vif, int start, u16 wid, int commit,\n\t\t      u32 drv_handler)\n{\n\tu32 offset;\n\tint ret_size;\n\tstruct wilc *wilc = vif->wilc;\n\n\tmutex_lock(&wilc->cfg_cmd_lock);\n\n\tif (start)\n\t\twilc->cfg_frame_offset = 0;\n\n\toffset = wilc->cfg_frame_offset;\n\tret_size = wilc_wlan_cfg_get_wid(wilc->cfg_frame.frame, offset, wid);\n\toffset += ret_size;\n\twilc->cfg_frame_offset = offset;\n\n\tif (!commit) {\n\t\tmutex_unlock(&wilc->cfg_cmd_lock);\n\t\treturn ret_size;\n\t}\n\n\tif (wilc_wlan_cfg_commit(vif, WILC_CFG_QUERY, drv_handler))\n\t\tret_size = 0;\n\n\tif (!wait_for_completion_timeout(&wilc->cfg_event,\n\t\t\t\t\t WILC_CFG_PKTS_TIMEOUT)) {\n\t\tnetdev_dbg(vif->ndev, \"%s: Timed Out\\n\", __func__);\n\t\tret_size = 0;\n\t}\n\twilc->cfg_frame_offset = 0;\n\twilc->cfg_seq_no += 1;\n\tmutex_unlock(&wilc->cfg_cmd_lock);\n\n\treturn ret_size;\n}\n\nint wilc_send_config_pkt(struct wilc_vif *vif, u8 mode, struct wid *wids,\n\t\t\t u32 count)\n{\n\tint i;\n\tint ret = 0;\n\tu32 drv = wilc_get_vif_idx(vif);\n\n\tif (mode == WILC_GET_CFG) {\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (!wilc_wlan_cfg_get(vif, !i,\n\t\t\t\t\t       wids[i].id,\n\t\t\t\t\t       (i == count - 1),\n\t\t\t\t\t       drv)) {\n\t\t\t\tret = -ETIMEDOUT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < count; i++) {\n\t\t\twids[i].size = wilc_wlan_cfg_get_val(vif->wilc,\n\t\t\t\t\t\t\t     wids[i].id,\n\t\t\t\t\t\t\t     wids[i].val,\n\t\t\t\t\t\t\t     wids[i].size);\n\t\t}\n\t} else if (mode == WILC_SET_CFG) {\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (!wilc_wlan_cfg_set(vif, !i,\n\t\t\t\t\t       wids[i].id,\n\t\t\t\t\t       wids[i].val,\n\t\t\t\t\t       wids[i].size,\n\t\t\t\t\t       (i == count - 1),\n\t\t\t\t\t       drv)) {\n\t\t\t\tret = -ETIMEDOUT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int init_chip(struct net_device *dev)\n{\n\tu32 chipid;\n\tu32 reg;\n\tint ret = 0;\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc *wilc = vif->wilc;\n\n\tacquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY);\n\n\tchipid = wilc_get_chipid(wilc, true);\n\n\tif ((chipid & 0xfff) != 0xa0) {\n\t\tret = wilc->hif_func->hif_read_reg(wilc,\n\t\t\t\t\t\t   WILC_CORTUS_RESET_MUX_SEL,\n\t\t\t\t\t\t   &reg);\n\t\tif (ret) {\n\t\t\tnetdev_err(dev, \"fail read reg 0x1118\\n\");\n\t\t\tgoto release;\n\t\t}\n\t\treg |= BIT(0);\n\t\tret = wilc->hif_func->hif_write_reg(wilc,\n\t\t\t\t\t\t    WILC_CORTUS_RESET_MUX_SEL,\n\t\t\t\t\t\t    reg);\n\t\tif (ret) {\n\t\t\tnetdev_err(dev, \"fail write reg 0x1118\\n\");\n\t\t\tgoto release;\n\t\t}\n\t\tret = wilc->hif_func->hif_write_reg(wilc,\n\t\t\t\t\t\t    WILC_CORTUS_BOOT_REGISTER,\n\t\t\t\t\t\t    WILC_CORTUS_BOOT_FROM_IRAM);\n\t\tif (ret) {\n\t\t\tnetdev_err(dev, \"fail write reg 0xc0000\\n\");\n\t\t\tgoto release;\n\t\t}\n\t}\n\nrelease:\n\trelease_bus(wilc, WILC_BUS_RELEASE_ONLY);\n\n\treturn ret;\n}\n\nu32 wilc_get_chipid(struct wilc *wilc, bool update)\n{\n\tu32 chipid = 0;\n\tu32 rfrevid = 0;\n\n\tif (wilc->chipid == 0 || update) {\n\t\twilc->hif_func->hif_read_reg(wilc, WILC_CHIPID, &chipid);\n\t\twilc->hif_func->hif_read_reg(wilc, WILC_RF_REVISION_ID,\n\t\t\t\t\t     &rfrevid);\n\t\tif (!is_wilc1000(chipid)) {\n\t\t\twilc->chipid = 0;\n\t\t\treturn wilc->chipid;\n\t\t}\n\t\tif (chipid == WILC_1000_BASE_ID_2A) {  \n\t\t\tif (rfrevid != 0x1)\n\t\t\t\tchipid = WILC_1000_BASE_ID_2A_REV1;\n\t\t} else if (chipid == WILC_1000_BASE_ID_2B) {  \n\t\t\tif (rfrevid == 0x4)\n\t\t\t\tchipid = WILC_1000_BASE_ID_2B_REV1;\n\t\t\telse if (rfrevid != 0x3)\n\t\t\t\tchipid = WILC_1000_BASE_ID_2B_REV2;\n\t\t}\n\n\t\twilc->chipid = chipid;\n\t}\n\treturn wilc->chipid;\n}\n\nint wilc_wlan_init(struct net_device *dev)\n{\n\tint ret = 0;\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc *wilc;\n\n\twilc = vif->wilc;\n\n\twilc->quit = 0;\n\n\tif (!wilc->hif_func->hif_is_init(wilc)) {\n\t\tacquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY);\n\t\tret = wilc->hif_func->hif_init(wilc, false);\n\t\trelease_bus(wilc, WILC_BUS_RELEASE_ONLY);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\tif (!wilc->vmm_table)\n\t\twilc->vmm_table = kcalloc(WILC_VMM_TBL_SIZE, sizeof(u32), GFP_KERNEL);\n\n\tif (!wilc->vmm_table) {\n\t\tret = -ENOBUFS;\n\t\tgoto fail;\n\t}\n\n\tif (!wilc->tx_buffer)\n\t\twilc->tx_buffer = kmalloc(WILC_TX_BUFF_SIZE, GFP_KERNEL);\n\n\tif (!wilc->tx_buffer) {\n\t\tret = -ENOBUFS;\n\t\tgoto fail;\n\t}\n\n\tif (!wilc->rx_buffer)\n\t\twilc->rx_buffer = kmalloc(WILC_RX_BUFF_SIZE, GFP_KERNEL);\n\n\tif (!wilc->rx_buffer) {\n\t\tret = -ENOBUFS;\n\t\tgoto fail;\n\t}\n\n\tif (init_chip(dev)) {\n\t\tret = -EIO;\n\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tkfree(wilc->vmm_table);\n\twilc->vmm_table = NULL;\n\tkfree(wilc->rx_buffer);\n\twilc->rx_buffer = NULL;\n\tkfree(wilc->tx_buffer);\n\twilc->tx_buffer = NULL;\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}