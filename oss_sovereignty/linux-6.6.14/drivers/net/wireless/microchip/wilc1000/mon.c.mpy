{
  "module_name": "mon.c",
  "hash_id": "4129d99252e36643bf3323dfdf6f84f1714d80756ea476dbb2e59ae086a91749",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/microchip/wilc1000/mon.c",
  "human_readable_source": "\n \n\n#include \"cfg80211.h\"\n\nstruct wilc_wfi_radiotap_hdr {\n\tstruct ieee80211_radiotap_header hdr;\n\tu8 rate;\n} __packed;\n\nstruct wilc_wfi_radiotap_cb_hdr {\n\tstruct ieee80211_radiotap_header hdr;\n\tu8 rate;\n\tu8 dump;\n\tu16 tx_flags;\n} __packed;\n\n#define TX_RADIOTAP_PRESENT ((1 << IEEE80211_RADIOTAP_RATE) |\t\\\n\t\t\t     (1 << IEEE80211_RADIOTAP_TX_FLAGS))\n\nvoid wilc_wfi_monitor_rx(struct net_device *mon_dev, u8 *buff, u32 size)\n{\n\tu32 header, pkt_offset;\n\tstruct sk_buff *skb = NULL;\n\tstruct wilc_wfi_radiotap_hdr *hdr;\n\tstruct wilc_wfi_radiotap_cb_hdr *cb_hdr;\n\n\tif (!mon_dev)\n\t\treturn;\n\n\tif (!netif_running(mon_dev))\n\t\treturn;\n\n\t \n\theader = get_unaligned_le32(buff - HOST_HDR_OFFSET);\n\t \n\tpkt_offset = FIELD_GET(WILC_PKT_HDR_OFFSET_FIELD, header);\n\n\tif (pkt_offset & IS_MANAGMEMENT_CALLBACK) {\n\t\t \n\n\t\tskb = dev_alloc_skb(size + sizeof(*cb_hdr));\n\t\tif (!skb)\n\t\t\treturn;\n\n\t\tskb_put_data(skb, buff, size);\n\n\t\tcb_hdr = skb_push(skb, sizeof(*cb_hdr));\n\t\tmemset(cb_hdr, 0, sizeof(*cb_hdr));\n\n\t\tcb_hdr->hdr.it_version = 0;  \n\n\t\tcb_hdr->hdr.it_len = cpu_to_le16(sizeof(*cb_hdr));\n\n\t\tcb_hdr->hdr.it_present = cpu_to_le32(TX_RADIOTAP_PRESENT);\n\n\t\tcb_hdr->rate = 5;\n\n\t\tif (pkt_offset & IS_MGMT_STATUS_SUCCES)\t{\n\t\t\t \n\t\t\tcb_hdr->tx_flags = IEEE80211_RADIOTAP_F_TX_RTS;\n\t\t} else {\n\t\t\tcb_hdr->tx_flags = IEEE80211_RADIOTAP_F_TX_FAIL;\n\t\t}\n\n\t} else {\n\t\tskb = dev_alloc_skb(size + sizeof(*hdr));\n\n\t\tif (!skb)\n\t\t\treturn;\n\n\t\tskb_put_data(skb, buff, size);\n\t\thdr = skb_push(skb, sizeof(*hdr));\n\t\tmemset(hdr, 0, sizeof(struct wilc_wfi_radiotap_hdr));\n\t\thdr->hdr.it_version = 0;  \n\t\thdr->hdr.it_len = cpu_to_le16(sizeof(*hdr));\n\t\thdr->hdr.it_present = cpu_to_le32\n\t\t\t\t(1 << IEEE80211_RADIOTAP_RATE);\n\t\thdr->rate = 5;\n\t}\n\n\tskb->dev = mon_dev;\n\tskb_reset_mac_header(skb);\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\tskb->pkt_type = PACKET_OTHERHOST;\n\tskb->protocol = htons(ETH_P_802_2);\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\n\tnetif_rx(skb);\n}\n\nstruct tx_complete_mon_data {\n\tint size;\n\tvoid *buff;\n};\n\nstatic void mgmt_tx_complete(void *priv, int status)\n{\n\tstruct tx_complete_mon_data *pv_data = priv;\n\t \n\tkfree(pv_data->buff);\n\n\tkfree(pv_data);\n}\n\nstatic int mon_mgmt_tx(struct net_device *dev, const u8 *buf, size_t len)\n{\n\tstruct tx_complete_mon_data *mgmt_tx = NULL;\n\n\tif (!dev)\n\t\treturn -EFAULT;\n\n\tnetif_stop_queue(dev);\n\tmgmt_tx = kmalloc(sizeof(*mgmt_tx), GFP_ATOMIC);\n\tif (!mgmt_tx)\n\t\treturn -ENOMEM;\n\n\tmgmt_tx->buff = kmemdup(buf, len, GFP_ATOMIC);\n\tif (!mgmt_tx->buff) {\n\t\tkfree(mgmt_tx);\n\t\treturn -ENOMEM;\n\t}\n\n\tmgmt_tx->size = len;\n\n\twilc_wlan_txq_add_mgmt_pkt(dev, mgmt_tx, mgmt_tx->buff, mgmt_tx->size,\n\t\t\t\t   mgmt_tx_complete);\n\n\tnetif_wake_queue(dev);\n\treturn 0;\n}\n\nstatic netdev_tx_t wilc_wfi_mon_xmit(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev)\n{\n\tu32 rtap_len, ret = 0;\n\tstruct wilc_wfi_mon_priv  *mon_priv;\n\tstruct sk_buff *skb2;\n\tstruct wilc_wfi_radiotap_cb_hdr *cb_hdr;\n\tu8 srcadd[ETH_ALEN];\n\tu8 bssid[ETH_ALEN];\n\n\tmon_priv = netdev_priv(dev);\n\tif (!mon_priv)\n\t\treturn -EFAULT;\n\n\trtap_len = ieee80211_get_radiotap_len(skb->data);\n\tif (skb->len < rtap_len)\n\t\treturn -1;\n\n\tskb_pull(skb, rtap_len);\n\n\tif (skb->data[0] == 0xc0 && is_broadcast_ether_addr(&skb->data[4])) {\n\t\tskb2 = dev_alloc_skb(skb->len + sizeof(*cb_hdr));\n\t\tif (!skb2)\n\t\t\treturn -ENOMEM;\n\n\t\tskb_put_data(skb2, skb->data, skb->len);\n\n\t\tcb_hdr = skb_push(skb2, sizeof(*cb_hdr));\n\t\tmemset(cb_hdr, 0, sizeof(struct wilc_wfi_radiotap_cb_hdr));\n\n\t\tcb_hdr->hdr.it_version = 0;  \n\n\t\tcb_hdr->hdr.it_len = cpu_to_le16(sizeof(*cb_hdr));\n\n\t\tcb_hdr->hdr.it_present = cpu_to_le32(TX_RADIOTAP_PRESENT);\n\n\t\tcb_hdr->rate = 5;\n\t\tcb_hdr->tx_flags = 0x0004;\n\n\t\tskb2->dev = dev;\n\t\tskb_reset_mac_header(skb2);\n\t\tskb2->ip_summed = CHECKSUM_UNNECESSARY;\n\t\tskb2->pkt_type = PACKET_OTHERHOST;\n\t\tskb2->protocol = htons(ETH_P_802_2);\n\t\tmemset(skb2->cb, 0, sizeof(skb2->cb));\n\n\t\tnetif_rx(skb2);\n\n\t\treturn 0;\n\t}\n\tskb->dev = mon_priv->real_ndev;\n\n\tether_addr_copy(srcadd, &skb->data[10]);\n\tether_addr_copy(bssid, &skb->data[16]);\n\t \n\tif (!(memcmp(srcadd, bssid, 6))) {\n\t\tret = mon_mgmt_tx(mon_priv->real_ndev, skb->data, skb->len);\n\t\tif (ret)\n\t\t\tnetdev_err(dev, \"fail to mgmt tx\\n\");\n\t\tdev_kfree_skb(skb);\n\t} else {\n\t\tret = wilc_mac_xmit(skb, mon_priv->real_ndev);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct net_device_ops wilc_wfi_netdev_ops = {\n\t.ndo_start_xmit         = wilc_wfi_mon_xmit,\n\n};\n\nstruct net_device *wilc_wfi_init_mon_interface(struct wilc *wl,\n\t\t\t\t\t       const char *name,\n\t\t\t\t\t       struct net_device *real_dev)\n{\n\tstruct wilc_wfi_mon_priv *priv;\n\n\t \n\tif (wl->monitor_dev)\n\t\treturn wl->monitor_dev;\n\n\twl->monitor_dev = alloc_etherdev(sizeof(struct wilc_wfi_mon_priv));\n\tif (!wl->monitor_dev)\n\t\treturn NULL;\n\n\twl->monitor_dev->type = ARPHRD_IEEE80211_RADIOTAP;\n\tstrscpy(wl->monitor_dev->name, name, IFNAMSIZ);\n\twl->monitor_dev->netdev_ops = &wilc_wfi_netdev_ops;\n\twl->monitor_dev->needs_free_netdev = true;\n\n\tif (register_netdevice(wl->monitor_dev)) {\n\t\tnetdev_err(real_dev, \"register_netdevice failed\\n\");\n\t\tfree_netdev(wl->monitor_dev);\n\t\treturn NULL;\n\t}\n\tpriv = netdev_priv(wl->monitor_dev);\n\n\tpriv->real_ndev = real_dev;\n\n\treturn wl->monitor_dev;\n}\n\nvoid wilc_wfi_deinit_mon_interface(struct wilc *wl, bool rtnl_locked)\n{\n\tif (!wl->monitor_dev)\n\t\treturn;\n\n\tif (rtnl_locked)\n\t\tunregister_netdevice(wl->monitor_dev);\n\telse\n\t\tunregister_netdev(wl->monitor_dev);\n\twl->monitor_dev = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}