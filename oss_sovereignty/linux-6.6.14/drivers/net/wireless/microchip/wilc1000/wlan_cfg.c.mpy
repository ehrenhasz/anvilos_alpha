{
  "module_name": "wlan_cfg.c",
  "hash_id": "b08964a09282ed695b7f8e0af25a08d7c97c160979263a1a5a054dcf9ded7cf9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/microchip/wilc1000/wlan_cfg.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include \"wlan_if.h\"\n#include \"wlan.h\"\n#include \"wlan_cfg.h\"\n#include \"netdev.h\"\n\nenum cfg_cmd_type {\n\tCFG_BYTE_CMD\t= 0,\n\tCFG_HWORD_CMD\t= 1,\n\tCFG_WORD_CMD\t= 2,\n\tCFG_STR_CMD\t= 3,\n\tCFG_BIN_CMD\t= 4\n};\n\nstatic const struct wilc_cfg_byte g_cfg_byte[] = {\n\t{WID_STATUS, 0},\n\t{WID_RSSI, 0},\n\t{WID_LINKSPEED, 0},\n\t{WID_TX_POWER, 0},\n\t{WID_WOWLAN_TRIGGER, 0},\n\t{WID_NIL, 0}\n};\n\nstatic const struct wilc_cfg_hword g_cfg_hword[] = {\n\t{WID_NIL, 0}\n};\n\nstatic const struct wilc_cfg_word g_cfg_word[] = {\n\t{WID_FAILED_COUNT, 0},\n\t{WID_RECEIVED_FRAGMENT_COUNT, 0},\n\t{WID_SUCCESS_FRAME_COUNT, 0},\n\t{WID_GET_INACTIVE_TIME, 0},\n\t{WID_NIL, 0}\n\n};\n\nstatic const struct wilc_cfg_str g_cfg_str[] = {\n\t{WID_FIRMWARE_VERSION, NULL},\n\t{WID_MAC_ADDR, NULL},\n\t{WID_ASSOC_RES_INFO, NULL},\n\t{WID_NIL, NULL}\n};\n\n#define WILC_RESP_MSG_TYPE_CONFIG_REPLY\t\t'R'\n#define WILC_RESP_MSG_TYPE_STATUS_INFO\t\t'I'\n#define WILC_RESP_MSG_TYPE_NETWORK_INFO\t\t'N'\n#define WILC_RESP_MSG_TYPE_SCAN_COMPLETE\t'S'\n\n \n\nstatic int wilc_wlan_cfg_set_byte(u8 *frame, u32 offset, u16 id, u8 val8)\n{\n\tif ((offset + 4) >= WILC_MAX_CFG_FRAME_SIZE)\n\t\treturn 0;\n\n\tput_unaligned_le16(id, &frame[offset]);\n\tput_unaligned_le16(1, &frame[offset + 2]);\n\tframe[offset + 4] = val8;\n\treturn 5;\n}\n\nstatic int wilc_wlan_cfg_set_hword(u8 *frame, u32 offset, u16 id, u16 val16)\n{\n\tif ((offset + 5) >= WILC_MAX_CFG_FRAME_SIZE)\n\t\treturn 0;\n\n\tput_unaligned_le16(id, &frame[offset]);\n\tput_unaligned_le16(2, &frame[offset + 2]);\n\tput_unaligned_le16(val16, &frame[offset + 4]);\n\n\treturn 6;\n}\n\nstatic int wilc_wlan_cfg_set_word(u8 *frame, u32 offset, u16 id, u32 val32)\n{\n\tif ((offset + 7) >= WILC_MAX_CFG_FRAME_SIZE)\n\t\treturn 0;\n\n\tput_unaligned_le16(id, &frame[offset]);\n\tput_unaligned_le16(4, &frame[offset + 2]);\n\tput_unaligned_le32(val32, &frame[offset + 4]);\n\n\treturn 8;\n}\n\nstatic int wilc_wlan_cfg_set_str(u8 *frame, u32 offset, u16 id, u8 *str,\n\t\t\t\t u32 size)\n{\n\tif ((offset + size + 4) >= WILC_MAX_CFG_FRAME_SIZE)\n\t\treturn 0;\n\n\tput_unaligned_le16(id, &frame[offset]);\n\tput_unaligned_le16(size, &frame[offset + 2]);\n\tif (str && size != 0)\n\t\tmemcpy(&frame[offset + 4], str, size);\n\n\treturn (size + 4);\n}\n\nstatic int wilc_wlan_cfg_set_bin(u8 *frame, u32 offset, u16 id, u8 *b, u32 size)\n{\n\tu32 i;\n\tu8 checksum = 0;\n\n\tif ((offset + size + 5) >= WILC_MAX_CFG_FRAME_SIZE)\n\t\treturn 0;\n\n\tput_unaligned_le16(id, &frame[offset]);\n\tput_unaligned_le16(size, &frame[offset + 2]);\n\n\tif ((b) && size != 0) {\n\t\tmemcpy(&frame[offset + 4], b, size);\n\t\tfor (i = 0; i < size; i++)\n\t\t\tchecksum += frame[offset + i + 4];\n\t}\n\n\tframe[offset + size + 4] = checksum;\n\n\treturn (size + 5);\n}\n\n \n\nstatic void wilc_wlan_parse_response_frame(struct wilc *wl, u8 *info, int size)\n{\n\tu16 wid;\n\tu32 len = 0, i = 0;\n\tstruct wilc_cfg *cfg = &wl->cfg;\n\n\twhile (size > 0) {\n\t\ti = 0;\n\t\twid = get_unaligned_le16(info);\n\n\t\tswitch (FIELD_GET(WILC_WID_TYPE, wid)) {\n\t\tcase WID_CHAR:\n\t\t\twhile (cfg->b[i].id != WID_NIL && cfg->b[i].id != wid)\n\t\t\t\ti++;\n\n\t\t\tif (cfg->b[i].id == wid)\n\t\t\t\tcfg->b[i].val = info[4];\n\n\t\t\tlen = 3;\n\t\t\tbreak;\n\n\t\tcase WID_SHORT:\n\t\t\twhile (cfg->hw[i].id != WID_NIL && cfg->hw[i].id != wid)\n\t\t\t\ti++;\n\n\t\t\tif (cfg->hw[i].id == wid)\n\t\t\t\tcfg->hw[i].val = get_unaligned_le16(&info[4]);\n\n\t\t\tlen = 4;\n\t\t\tbreak;\n\n\t\tcase WID_INT:\n\t\t\twhile (cfg->w[i].id != WID_NIL && cfg->w[i].id != wid)\n\t\t\t\ti++;\n\n\t\t\tif (cfg->w[i].id == wid)\n\t\t\t\tcfg->w[i].val = get_unaligned_le32(&info[4]);\n\n\t\t\tlen = 6;\n\t\t\tbreak;\n\n\t\tcase WID_STR:\n\t\t\twhile (cfg->s[i].id != WID_NIL && cfg->s[i].id != wid)\n\t\t\t\ti++;\n\n\t\t\tif (cfg->s[i].id == wid)\n\t\t\t\tmemcpy(cfg->s[i].str, &info[2],\n\t\t\t\t       get_unaligned_le16(&info[2]) + 2);\n\n\t\t\tlen = 2 + get_unaligned_le16(&info[2]);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tsize -= (2 + len);\n\t\tinfo += (2 + len);\n\t}\n}\n\nstatic void wilc_wlan_parse_info_frame(struct wilc *wl, u8 *info)\n{\n\tu32 wid, len;\n\n\twid = get_unaligned_le16(info);\n\n\tlen = info[2];\n\n\tif (len == 1 && wid == WID_STATUS) {\n\t\tint i = 0;\n\n\t\twhile (wl->cfg.b[i].id != WID_NIL &&\n\t\t       wl->cfg.b[i].id != wid)\n\t\t\ti++;\n\n\t\tif (wl->cfg.b[i].id == wid)\n\t\t\twl->cfg.b[i].val = info[3];\n\t}\n}\n\n \n\nint wilc_wlan_cfg_set_wid(u8 *frame, u32 offset, u16 id, u8 *buf, int size)\n{\n\tu8 type = FIELD_GET(WILC_WID_TYPE, id);\n\tint ret = 0;\n\n\tswitch (type) {\n\tcase CFG_BYTE_CMD:\n\t\tif (size >= 1)\n\t\t\tret = wilc_wlan_cfg_set_byte(frame, offset, id, *buf);\n\t\tbreak;\n\n\tcase CFG_HWORD_CMD:\n\t\tif (size >= 2)\n\t\t\tret = wilc_wlan_cfg_set_hword(frame, offset, id,\n\t\t\t\t\t\t      *((u16 *)buf));\n\t\tbreak;\n\n\tcase CFG_WORD_CMD:\n\t\tif (size >= 4)\n\t\t\tret = wilc_wlan_cfg_set_word(frame, offset, id,\n\t\t\t\t\t\t     *((u32 *)buf));\n\t\tbreak;\n\n\tcase CFG_STR_CMD:\n\t\tret = wilc_wlan_cfg_set_str(frame, offset, id, buf, size);\n\t\tbreak;\n\n\tcase CFG_BIN_CMD:\n\t\tret = wilc_wlan_cfg_set_bin(frame, offset, id, buf, size);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nint wilc_wlan_cfg_get_wid(u8 *frame, u32 offset, u16 id)\n{\n\tif ((offset + 2) >= WILC_MAX_CFG_FRAME_SIZE)\n\t\treturn 0;\n\n\tput_unaligned_le16(id, &frame[offset]);\n\n\treturn 2;\n}\n\nint wilc_wlan_cfg_get_val(struct wilc *wl, u16 wid, u8 *buffer,\n\t\t\t  u32 buffer_size)\n{\n\tu8 type = FIELD_GET(WILC_WID_TYPE, wid);\n\tint i, ret = 0;\n\tstruct wilc_cfg *cfg = &wl->cfg;\n\n\ti = 0;\n\tif (type == CFG_BYTE_CMD) {\n\t\twhile (cfg->b[i].id != WID_NIL && cfg->b[i].id != wid)\n\t\t\ti++;\n\n\t\tif (cfg->b[i].id == wid) {\n\t\t\tmemcpy(buffer, &cfg->b[i].val, 1);\n\t\t\tret = 1;\n\t\t}\n\t} else if (type == CFG_HWORD_CMD) {\n\t\twhile (cfg->hw[i].id != WID_NIL && cfg->hw[i].id != wid)\n\t\t\ti++;\n\n\t\tif (cfg->hw[i].id == wid) {\n\t\t\tmemcpy(buffer, &cfg->hw[i].val, 2);\n\t\t\tret = 2;\n\t\t}\n\t} else if (type == CFG_WORD_CMD) {\n\t\twhile (cfg->w[i].id != WID_NIL && cfg->w[i].id != wid)\n\t\t\ti++;\n\n\t\tif (cfg->w[i].id == wid) {\n\t\t\tmemcpy(buffer, &cfg->w[i].val, 4);\n\t\t\tret = 4;\n\t\t}\n\t} else if (type == CFG_STR_CMD) {\n\t\twhile (cfg->s[i].id != WID_NIL && cfg->s[i].id != wid)\n\t\t\ti++;\n\n\t\tif (cfg->s[i].id == wid) {\n\t\t\tu16 size = get_unaligned_le16(cfg->s[i].str);\n\n\t\t\tif (buffer_size >= size) {\n\t\t\t\tmemcpy(buffer, &cfg->s[i].str[2], size);\n\t\t\t\tret = size;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid wilc_wlan_cfg_indicate_rx(struct wilc *wilc, u8 *frame, int size,\n\t\t\t       struct wilc_cfg_rsp *rsp)\n{\n\tu8 msg_type;\n\tu8 msg_id;\n\n\tmsg_type = frame[0];\n\tmsg_id = frame[1];       \n\tframe += 4;\n\tsize -= 4;\n\trsp->type = 0;\n\n\tswitch (msg_type) {\n\tcase WILC_RESP_MSG_TYPE_CONFIG_REPLY:\n\t\twilc_wlan_parse_response_frame(wilc, frame, size);\n\t\trsp->type = WILC_CFG_RSP;\n\t\trsp->seq_no = msg_id;\n\t\tbreak;\n\n\tcase WILC_RESP_MSG_TYPE_STATUS_INFO:\n\t\twilc_wlan_parse_info_frame(wilc, frame);\n\t\trsp->type = WILC_CFG_RSP_STATUS;\n\t\trsp->seq_no = msg_id;\n\t\t \n\t\twilc_gnrl_async_info_received(wilc, frame - 4, size + 4);\n\t\tbreak;\n\n\tcase WILC_RESP_MSG_TYPE_NETWORK_INFO:\n\t\twilc_network_info_received(wilc, frame - 4, size + 4);\n\t\tbreak;\n\n\tcase WILC_RESP_MSG_TYPE_SCAN_COMPLETE:\n\t\twilc_scan_complete_received(wilc, frame - 4, size + 4);\n\t\tbreak;\n\n\tdefault:\n\t\trsp->seq_no = msg_id;\n\t\tbreak;\n\t}\n}\n\nint wilc_wlan_cfg_init(struct wilc *wl)\n{\n\tstruct wilc_cfg_str_vals *str_vals;\n\tint i = 0;\n\n\twl->cfg.b = kmemdup(g_cfg_byte, sizeof(g_cfg_byte), GFP_KERNEL);\n\tif (!wl->cfg.b)\n\t\treturn -ENOMEM;\n\n\twl->cfg.hw = kmemdup(g_cfg_hword, sizeof(g_cfg_hword), GFP_KERNEL);\n\tif (!wl->cfg.hw)\n\t\tgoto out_b;\n\n\twl->cfg.w = kmemdup(g_cfg_word, sizeof(g_cfg_word), GFP_KERNEL);\n\tif (!wl->cfg.w)\n\t\tgoto out_hw;\n\n\twl->cfg.s = kmemdup(g_cfg_str, sizeof(g_cfg_str), GFP_KERNEL);\n\tif (!wl->cfg.s)\n\t\tgoto out_w;\n\n\tstr_vals = kzalloc(sizeof(*str_vals), GFP_KERNEL);\n\tif (!str_vals)\n\t\tgoto out_s;\n\n\twl->cfg.str_vals = str_vals;\n\t \n\twl->cfg.s[i].id = WID_FIRMWARE_VERSION;\n\twl->cfg.s[i].str = str_vals->firmware_version;\n\ti++;\n\twl->cfg.s[i].id = WID_MAC_ADDR;\n\twl->cfg.s[i].str = str_vals->mac_address;\n\ti++;\n\twl->cfg.s[i].id = WID_ASSOC_RES_INFO;\n\twl->cfg.s[i].str = str_vals->assoc_rsp;\n\ti++;\n\twl->cfg.s[i].id = WID_NIL;\n\twl->cfg.s[i].str = NULL;\n\treturn 0;\n\nout_s:\n\tkfree(wl->cfg.s);\nout_w:\n\tkfree(wl->cfg.w);\nout_hw:\n\tkfree(wl->cfg.hw);\nout_b:\n\tkfree(wl->cfg.b);\n\treturn -ENOMEM;\n}\n\nvoid wilc_wlan_cfg_deinit(struct wilc *wl)\n{\n\tkfree(wl->cfg.b);\n\tkfree(wl->cfg.hw);\n\tkfree(wl->cfg.w);\n\tkfree(wl->cfg.s);\n\tkfree(wl->cfg.str_vals);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}