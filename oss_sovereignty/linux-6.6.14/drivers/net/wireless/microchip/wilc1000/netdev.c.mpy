{
  "module_name": "netdev.c",
  "hash_id": "c0905a3c26188733684f70ef1d2de4f11b45428a57c2fe9a8abe3aca00f553dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/microchip/wilc1000/netdev.c",
  "human_readable_source": "\n \n\n#include <linux/irq.h>\n#include <linux/kthread.h>\n#include <linux/firmware.h>\n#include <linux/netdevice.h>\n#include <linux/inetdevice.h>\n\n#include \"cfg80211.h\"\n#include \"wlan_cfg.h\"\n\n#define WILC_MULTICAST_TABLE_SIZE\t8\n#define WILC_MAX_FW_VERSION_STR_SIZE\t50\n\n \n#define WILC1000_API_VER\t\t1\n\n#define WILC1000_FW_PREFIX\t\t\"atmel/wilc1000_wifi_firmware-\"\n#define __WILC1000_FW(api)\t\tWILC1000_FW_PREFIX #api \".bin\"\n#define WILC1000_FW(api)\t\t__WILC1000_FW(api)\n\nstatic irqreturn_t isr_uh_routine(int irq, void *user_data)\n{\n\tstruct wilc *wilc = user_data;\n\n\tif (wilc->close) {\n\t\tpr_err(\"Can't handle UH interrupt\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t isr_bh_routine(int irq, void *userdata)\n{\n\tstruct wilc *wilc = userdata;\n\n\tif (wilc->close) {\n\t\tpr_err(\"Can't handle BH interrupt\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\twilc_handle_isr(wilc);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int init_irq(struct net_device *dev)\n{\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc *wl = vif->wilc;\n\tint ret;\n\n\tret = request_threaded_irq(wl->dev_irq_num, isr_uh_routine,\n\t\t\t\t   isr_bh_routine,\n\t\t\t\t   IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t   dev->name, wl);\n\tif (ret) {\n\t\tnetdev_err(dev, \"Failed to request IRQ [%d]\\n\", ret);\n\t\treturn ret;\n\t}\n\tnetdev_dbg(dev, \"IRQ request succeeded IRQ-NUM= %d\\n\", wl->dev_irq_num);\n\n\treturn 0;\n}\n\nstatic void deinit_irq(struct net_device *dev)\n{\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc *wilc = vif->wilc;\n\n\t \n\tif (wilc->dev_irq_num)\n\t\tfree_irq(wilc->dev_irq_num, wilc);\n}\n\nvoid wilc_mac_indicate(struct wilc *wilc)\n{\n\ts8 status;\n\n\twilc_wlan_cfg_get_val(wilc, WID_STATUS, &status, 1);\n\tif (wilc->mac_status == WILC_MAC_STATUS_INIT) {\n\t\twilc->mac_status = status;\n\t\tcomplete(&wilc->sync_event);\n\t} else {\n\t\twilc->mac_status = status;\n\t}\n}\n\nstatic struct net_device *get_if_handler(struct wilc *wilc, u8 *mac_header)\n{\n\tstruct net_device *ndev = NULL;\n\tstruct wilc_vif *vif;\n\tstruct ieee80211_hdr *h = (struct ieee80211_hdr *)mac_header;\n\n\tlist_for_each_entry_rcu(vif, &wilc->vif_list, list) {\n\t\tif (vif->iftype == WILC_STATION_MODE)\n\t\t\tif (ether_addr_equal_unaligned(h->addr2, vif->bssid)) {\n\t\t\t\tndev = vif->ndev;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\tif (vif->iftype == WILC_AP_MODE)\n\t\t\tif (ether_addr_equal_unaligned(h->addr1, vif->bssid)) {\n\t\t\t\tndev = vif->ndev;\n\t\t\t\tgoto out;\n\t\t\t}\n\t}\nout:\n\treturn ndev;\n}\n\nvoid wilc_wlan_set_bssid(struct net_device *wilc_netdev, const u8 *bssid,\n\t\t\t u8 mode)\n{\n\tstruct wilc_vif *vif = netdev_priv(wilc_netdev);\n\n\tif (bssid)\n\t\tether_addr_copy(vif->bssid, bssid);\n\telse\n\t\teth_zero_addr(vif->bssid);\n\n\tvif->iftype = mode;\n}\n\nint wilc_wlan_get_num_conn_ifcs(struct wilc *wilc)\n{\n\tint srcu_idx;\n\tu8 ret_val = 0;\n\tstruct wilc_vif *vif;\n\n\tsrcu_idx = srcu_read_lock(&wilc->srcu);\n\tlist_for_each_entry_rcu(vif, &wilc->vif_list, list) {\n\t\tif (!is_zero_ether_addr(vif->bssid))\n\t\t\tret_val++;\n\t}\n\tsrcu_read_unlock(&wilc->srcu, srcu_idx);\n\treturn ret_val;\n}\n\nstatic int wilc_txq_task(void *vp)\n{\n\tint ret;\n\tu32 txq_count;\n\tstruct wilc *wl = vp;\n\n\tcomplete(&wl->txq_thread_started);\n\twhile (1) {\n\t\twait_for_completion(&wl->txq_event);\n\n\t\tif (wl->close) {\n\t\t\tcomplete(&wl->txq_thread_started);\n\n\t\t\twhile (!kthread_should_stop())\n\t\t\t\tschedule();\n\t\t\tbreak;\n\t\t}\n\t\tdo {\n\t\t\tret = wilc_wlan_handle_txq(wl, &txq_count);\n\t\t\tif (txq_count < FLOW_CONTROL_LOWER_THRESHOLD) {\n\t\t\t\tint srcu_idx;\n\t\t\t\tstruct wilc_vif *ifc;\n\n\t\t\t\tsrcu_idx = srcu_read_lock(&wl->srcu);\n\t\t\t\tlist_for_each_entry_rcu(ifc, &wl->vif_list,\n\t\t\t\t\t\t\tlist) {\n\t\t\t\t\tif (ifc->mac_opened && ifc->ndev)\n\t\t\t\t\t\tnetif_wake_queue(ifc->ndev);\n\t\t\t\t}\n\t\t\t\tsrcu_read_unlock(&wl->srcu, srcu_idx);\n\t\t\t}\n\t\t} while (ret == WILC_VMM_ENTRY_FULL_RETRY && !wl->close);\n\t}\n\treturn 0;\n}\n\nstatic int wilc_wlan_get_firmware(struct net_device *dev)\n{\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc *wilc = vif->wilc;\n\tint chip_id;\n\tconst struct firmware *wilc_fw;\n\tint ret;\n\n\tchip_id = wilc_get_chipid(wilc, false);\n\n\tnetdev_info(dev, \"ChipID [%x] loading firmware [%s]\\n\", chip_id,\n\t\t    WILC1000_FW(WILC1000_API_VER));\n\n\tret = request_firmware(&wilc_fw, WILC1000_FW(WILC1000_API_VER),\n\t\t\t       wilc->dev);\n\tif (ret != 0) {\n\t\tnetdev_err(dev, \"%s - firmware not available\\n\",\n\t\t\t   WILC1000_FW(WILC1000_API_VER));\n\t\treturn -EINVAL;\n\t}\n\twilc->firmware = wilc_fw;\n\n\treturn 0;\n}\n\nstatic int wilc_start_firmware(struct net_device *dev)\n{\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc *wilc = vif->wilc;\n\tint ret = 0;\n\n\tret = wilc_wlan_start(wilc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!wait_for_completion_timeout(&wilc->sync_event,\n\t\t\t\t\t msecs_to_jiffies(5000)))\n\t\treturn -ETIME;\n\n\treturn 0;\n}\n\nstatic int wilc1000_firmware_download(struct net_device *dev)\n{\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc *wilc = vif->wilc;\n\tint ret = 0;\n\n\tif (!wilc->firmware) {\n\t\tnetdev_err(dev, \"Firmware buffer is NULL\\n\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tret = wilc_wlan_firmware_download(wilc, wilc->firmware->data,\n\t\t\t\t\t  wilc->firmware->size);\n\tif (ret)\n\t\treturn ret;\n\n\trelease_firmware(wilc->firmware);\n\twilc->firmware = NULL;\n\n\tnetdev_dbg(dev, \"Download Succeeded\\n\");\n\n\treturn 0;\n}\n\nstatic int wilc_init_fw_config(struct net_device *dev, struct wilc_vif *vif)\n{\n\tstruct wilc_priv *priv = &vif->priv;\n\tstruct host_if_drv *hif_drv;\n\tu8 b;\n\tu16 hw;\n\tu32 w;\n\n\tnetdev_dbg(dev, \"Start configuring Firmware\\n\");\n\thif_drv = (struct host_if_drv *)priv->hif_drv;\n\tnetdev_dbg(dev, \"Host = %p\\n\", hif_drv);\n\n\tw = vif->iftype;\n\tcpu_to_le32s(&w);\n\tif (!wilc_wlan_cfg_set(vif, 1, WID_SET_OPERATION_MODE, (u8 *)&w, 4,\n\t\t\t       0, 0))\n\t\tgoto fail;\n\n\tb = WILC_FW_BSS_TYPE_INFRA;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_BSS_TYPE, &b, 1, 0, 0))\n\t\tgoto fail;\n\n\tb = WILC_FW_TX_RATE_AUTO;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_CURRENT_TX_RATE, &b, 1, 0, 0))\n\t\tgoto fail;\n\n\tb = WILC_FW_OPER_MODE_G_MIXED_11B_2;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_11G_OPERATING_MODE, &b, 1, 0, 0))\n\t\tgoto fail;\n\n\tb = WILC_FW_PREAMBLE_SHORT;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_PREAMBLE, &b, 1, 0, 0))\n\t\tgoto fail;\n\n\tb = WILC_FW_11N_PROT_AUTO;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_11N_PROT_MECH, &b, 1, 0, 0))\n\t\tgoto fail;\n\n\tb = WILC_FW_ACTIVE_SCAN;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_SCAN_TYPE, &b, 1, 0, 0))\n\t\tgoto fail;\n\n\tb = WILC_FW_SITE_SURVEY_OFF;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_SITE_SURVEY, &b, 1, 0, 0))\n\t\tgoto fail;\n\n\thw = 0xffff;\n\tcpu_to_le16s(&hw);\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_RTS_THRESHOLD, (u8 *)&hw, 2, 0, 0))\n\t\tgoto fail;\n\n\thw = 2346;\n\tcpu_to_le16s(&hw);\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_FRAG_THRESHOLD, (u8 *)&hw, 2, 0, 0))\n\t\tgoto fail;\n\n\tb = 0;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_BCAST_SSID, &b, 1, 0, 0))\n\t\tgoto fail;\n\n\tb = 1;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_QOS_ENABLE, &b, 1, 0, 0))\n\t\tgoto fail;\n\n\tb = WILC_FW_NO_POWERSAVE;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_POWER_MANAGEMENT, &b, 1, 0, 0))\n\t\tgoto fail;\n\n\tb = WILC_FW_SEC_NO;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_11I_MODE, &b, 1, 0, 0))\n\t\tgoto fail;\n\n\tb = WILC_FW_AUTH_OPEN_SYSTEM;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_AUTH_TYPE, &b, 1, 0, 0))\n\t\tgoto fail;\n\n\tb = 3;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_LISTEN_INTERVAL, &b, 1, 0, 0))\n\t\tgoto fail;\n\n\tb = 3;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_DTIM_PERIOD, &b, 1, 0, 0))\n\t\tgoto fail;\n\n\tb = WILC_FW_ACK_POLICY_NORMAL;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_ACK_POLICY, &b, 1, 0, 0))\n\t\tgoto fail;\n\n\tb = 0;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_USER_CONTROL_ON_TX_POWER, &b, 1,\n\t\t\t       0, 0))\n\t\tgoto fail;\n\n\tb = 48;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_TX_POWER_LEVEL_11A, &b, 1, 0, 0))\n\t\tgoto fail;\n\n\tb = 28;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_TX_POWER_LEVEL_11B, &b, 1, 0, 0))\n\t\tgoto fail;\n\n\thw = 100;\n\tcpu_to_le16s(&hw);\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_BEACON_INTERVAL, (u8 *)&hw, 2, 0, 0))\n\t\tgoto fail;\n\n\tb = WILC_FW_REKEY_POLICY_DISABLE;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_REKEY_POLICY, &b, 1, 0, 0))\n\t\tgoto fail;\n\n\tw = 84600;\n\tcpu_to_le32s(&w);\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_REKEY_PERIOD, (u8 *)&w, 4, 0, 0))\n\t\tgoto fail;\n\n\tw = 500;\n\tcpu_to_le32s(&w);\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_REKEY_PACKET_COUNT, (u8 *)&w, 4, 0,\n\t\t\t       0))\n\t\tgoto fail;\n\n\tb = 1;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_SHORT_SLOT_ALLOWED, &b, 1, 0,\n\t\t\t       0))\n\t\tgoto fail;\n\n\tb = WILC_FW_ERP_PROT_SELF_CTS;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_11N_ERP_PROT_TYPE, &b, 1, 0, 0))\n\t\tgoto fail;\n\n\tb = 1;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_11N_ENABLE, &b, 1, 0, 0))\n\t\tgoto fail;\n\n\tb = WILC_FW_11N_OP_MODE_HT_MIXED;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_11N_OPERATING_MODE, &b, 1, 0, 0))\n\t\tgoto fail;\n\n\tb = 1;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_11N_TXOP_PROT_DISABLE, &b, 1, 0, 0))\n\t\tgoto fail;\n\n\tb = WILC_FW_OBBS_NONHT_DETECT_PROTECT_REPORT;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_11N_OBSS_NONHT_DETECTION, &b, 1,\n\t\t\t       0, 0))\n\t\tgoto fail;\n\n\tb = WILC_FW_HT_PROT_RTS_CTS_NONHT;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_11N_HT_PROT_TYPE, &b, 1, 0, 0))\n\t\tgoto fail;\n\n\tb = 0;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_11N_RIFS_PROT_ENABLE, &b, 1, 0,\n\t\t\t       0))\n\t\tgoto fail;\n\n\tb = 7;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_11N_CURRENT_TX_MCS, &b, 1, 0, 0))\n\t\tgoto fail;\n\n\tb = 1;\n\tif (!wilc_wlan_cfg_set(vif, 0, WID_11N_IMMEDIATE_BA_ENABLED, &b, 1,\n\t\t\t       1, 1))\n\t\tgoto fail;\n\n\treturn 0;\n\nfail:\n\treturn -EINVAL;\n}\n\nstatic void wlan_deinitialize_threads(struct net_device *dev)\n{\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc *wl = vif->wilc;\n\n\twl->close = 1;\n\n\tcomplete(&wl->txq_event);\n\n\tif (wl->txq_thread) {\n\t\tkthread_stop(wl->txq_thread);\n\t\twl->txq_thread = NULL;\n\t}\n}\n\nstatic void wilc_wlan_deinitialize(struct net_device *dev)\n{\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc *wl = vif->wilc;\n\n\tif (!wl) {\n\t\tnetdev_err(dev, \"wl is NULL\\n\");\n\t\treturn;\n\t}\n\n\tif (wl->initialized) {\n\t\tnetdev_info(dev, \"Deinitializing wilc1000...\\n\");\n\n\t\tif (!wl->dev_irq_num &&\n\t\t    wl->hif_func->disable_interrupt) {\n\t\t\tmutex_lock(&wl->hif_cs);\n\t\t\twl->hif_func->disable_interrupt(wl);\n\t\t\tmutex_unlock(&wl->hif_cs);\n\t\t}\n\t\tcomplete(&wl->txq_event);\n\n\t\twlan_deinitialize_threads(dev);\n\t\tdeinit_irq(dev);\n\n\t\twilc_wlan_stop(wl, vif);\n\t\twilc_wlan_cleanup(dev);\n\n\t\twl->initialized = false;\n\n\t\tnetdev_dbg(dev, \"wilc1000 deinitialization Done\\n\");\n\t} else {\n\t\tnetdev_dbg(dev, \"wilc1000 is not initialized\\n\");\n\t}\n}\n\nstatic int wlan_initialize_threads(struct net_device *dev)\n{\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc *wilc = vif->wilc;\n\n\twilc->txq_thread = kthread_run(wilc_txq_task, (void *)wilc,\n\t\t\t\t       \"%s-tx\", dev->name);\n\tif (IS_ERR(wilc->txq_thread)) {\n\t\tnetdev_err(dev, \"couldn't create TXQ thread\\n\");\n\t\twilc->close = 1;\n\t\treturn PTR_ERR(wilc->txq_thread);\n\t}\n\twait_for_completion(&wilc->txq_thread_started);\n\n\treturn 0;\n}\n\nstatic int wilc_wlan_initialize(struct net_device *dev, struct wilc_vif *vif)\n{\n\tint ret = 0;\n\tstruct wilc *wl = vif->wilc;\n\n\tif (!wl->initialized) {\n\t\twl->mac_status = WILC_MAC_STATUS_INIT;\n\t\twl->close = 0;\n\n\t\tret = wilc_wlan_init(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = wlan_initialize_threads(dev);\n\t\tif (ret)\n\t\t\tgoto fail_wilc_wlan;\n\n\t\tif (wl->dev_irq_num && init_irq(dev)) {\n\t\t\tret = -EIO;\n\t\t\tgoto fail_threads;\n\t\t}\n\n\t\tif (!wl->dev_irq_num &&\n\t\t    wl->hif_func->enable_interrupt &&\n\t\t    wl->hif_func->enable_interrupt(wl)) {\n\t\t\tret = -EIO;\n\t\t\tgoto fail_irq_init;\n\t\t}\n\n\t\tret = wilc_wlan_get_firmware(dev);\n\t\tif (ret)\n\t\t\tgoto fail_irq_enable;\n\n\t\tret = wilc1000_firmware_download(dev);\n\t\tif (ret)\n\t\t\tgoto fail_irq_enable;\n\n\t\tret = wilc_start_firmware(dev);\n\t\tif (ret)\n\t\t\tgoto fail_irq_enable;\n\n\t\tif (wilc_wlan_cfg_get(vif, 1, WID_FIRMWARE_VERSION, 1, 0)) {\n\t\t\tint size;\n\t\t\tchar firmware_ver[WILC_MAX_FW_VERSION_STR_SIZE];\n\n\t\t\tsize = wilc_wlan_cfg_get_val(wl, WID_FIRMWARE_VERSION,\n\t\t\t\t\t\t     firmware_ver,\n\t\t\t\t\t\t     sizeof(firmware_ver));\n\t\t\tfirmware_ver[size] = '\\0';\n\t\t\tnetdev_dbg(dev, \"Firmware Ver = %s\\n\", firmware_ver);\n\t\t}\n\n\t\tret = wilc_init_fw_config(dev, vif);\n\t\tif (ret) {\n\t\t\tnetdev_err(dev, \"Failed to configure firmware\\n\");\n\t\t\tgoto fail_fw_start;\n\t\t}\n\t\twl->initialized = true;\n\t\treturn 0;\n\nfail_fw_start:\n\t\twilc_wlan_stop(wl, vif);\n\nfail_irq_enable:\n\t\tif (!wl->dev_irq_num &&\n\t\t    wl->hif_func->disable_interrupt)\n\t\t\twl->hif_func->disable_interrupt(wl);\nfail_irq_init:\n\t\tif (wl->dev_irq_num)\n\t\t\tdeinit_irq(dev);\nfail_threads:\n\t\twlan_deinitialize_threads(dev);\nfail_wilc_wlan:\n\t\twilc_wlan_cleanup(dev);\n\t\tnetdev_err(dev, \"WLAN initialization FAILED\\n\");\n\t} else {\n\t\tnetdev_dbg(dev, \"wilc1000 already initialized\\n\");\n\t}\n\treturn ret;\n}\n\nstatic int mac_init_fn(struct net_device *ndev)\n{\n\tnetif_start_queue(ndev);\n\tnetif_stop_queue(ndev);\n\n\treturn 0;\n}\n\nstatic int wilc_mac_open(struct net_device *ndev)\n{\n\tstruct wilc_vif *vif = netdev_priv(ndev);\n\tstruct wilc *wl = vif->wilc;\n\tint ret = 0;\n\tstruct mgmt_frame_regs mgmt_regs = {};\n\tu8 addr[ETH_ALEN] __aligned(2);\n\n\tif (!wl || !wl->dev) {\n\t\tnetdev_err(ndev, \"device not ready\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tnetdev_dbg(ndev, \"MAC OPEN[%p]\\n\", ndev);\n\n\tret = wilc_init_host_int(ndev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = wilc_wlan_initialize(ndev, vif);\n\tif (ret) {\n\t\twilc_deinit_host_int(ndev);\n\t\treturn ret;\n\t}\n\n\twilc_set_operation_mode(vif, wilc_get_vif_idx(vif), vif->iftype,\n\t\t\t\tvif->idx);\n\n\tif (is_valid_ether_addr(ndev->dev_addr)) {\n\t\tether_addr_copy(addr, ndev->dev_addr);\n\t\twilc_set_mac_address(vif, addr);\n\t} else {\n\t\twilc_get_mac_address(vif, addr);\n\t\teth_hw_addr_set(ndev, addr);\n\t}\n\tnetdev_dbg(ndev, \"Mac address: %pM\\n\", ndev->dev_addr);\n\n\tif (!is_valid_ether_addr(ndev->dev_addr)) {\n\t\tnetdev_err(ndev, \"Wrong MAC address\\n\");\n\t\twilc_deinit_host_int(ndev);\n\t\twilc_wlan_deinitialize(ndev);\n\t\treturn -EINVAL;\n\t}\n\n\tmgmt_regs.interface_stypes = vif->mgmt_reg_stypes;\n\t \n\tvif->mgmt_reg_stypes = 0;\n\twilc_update_mgmt_frame_registrations(vif->ndev->ieee80211_ptr->wiphy,\n\t\t\t\t\t     vif->ndev->ieee80211_ptr,\n\t\t\t\t\t     &mgmt_regs);\n\tnetif_wake_queue(ndev);\n\twl->open_ifcs++;\n\tvif->mac_opened = 1;\n\treturn 0;\n}\n\nstatic struct net_device_stats *mac_stats(struct net_device *dev)\n{\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\n\treturn &vif->netstats;\n}\n\nstatic int wilc_set_mac_addr(struct net_device *dev, void *p)\n{\n\tint result;\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tstruct wilc *wilc = vif->wilc;\n\tstruct sockaddr *addr = (struct sockaddr *)p;\n\tunsigned char mac_addr[ETH_ALEN];\n\tstruct wilc_vif *tmp_vif;\n\tint srcu_idx;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (!vif->mac_opened) {\n\t\teth_commit_mac_addr_change(dev, p);\n\t\treturn 0;\n\t}\n\n\t \n\n\tsrcu_idx = srcu_read_lock(&wilc->srcu);\n\tlist_for_each_entry_rcu(tmp_vif, &wilc->vif_list, list) {\n\t\twilc_get_mac_address(tmp_vif, mac_addr);\n\t\tif (ether_addr_equal(addr->sa_data, mac_addr)) {\n\t\t\tif (vif != tmp_vif) {\n\t\t\t\tsrcu_read_unlock(&wilc->srcu, srcu_idx);\n\t\t\t\treturn -EADDRNOTAVAIL;\n\t\t\t}\n\t\t\tsrcu_read_unlock(&wilc->srcu, srcu_idx);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tsrcu_read_unlock(&wilc->srcu, srcu_idx);\n\n\tresult = wilc_set_mac_address(vif, (u8 *)addr->sa_data);\n\tif (result)\n\t\treturn result;\n\n\teth_commit_mac_addr_change(dev, p);\n\treturn result;\n}\n\nstatic void wilc_set_multicast_list(struct net_device *dev)\n{\n\tstruct netdev_hw_addr *ha;\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\tint i;\n\tu8 *mc_list;\n\tu8 *cur_mc;\n\n\tif (dev->flags & IFF_PROMISC)\n\t\treturn;\n\n\tif (dev->flags & IFF_ALLMULTI ||\n\t    dev->mc.count > WILC_MULTICAST_TABLE_SIZE) {\n\t\twilc_setup_multicast_filter(vif, 0, 0, NULL);\n\t\treturn;\n\t}\n\n\tif (dev->mc.count == 0) {\n\t\twilc_setup_multicast_filter(vif, 1, 0, NULL);\n\t\treturn;\n\t}\n\n\tmc_list = kmalloc_array(dev->mc.count, ETH_ALEN, GFP_ATOMIC);\n\tif (!mc_list)\n\t\treturn;\n\n\tcur_mc = mc_list;\n\ti = 0;\n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\tmemcpy(cur_mc, ha->addr, ETH_ALEN);\n\t\tnetdev_dbg(dev, \"Entry[%d]: %pM\\n\", i, cur_mc);\n\t\ti++;\n\t\tcur_mc += ETH_ALEN;\n\t}\n\n\tif (wilc_setup_multicast_filter(vif, 1, dev->mc.count, mc_list))\n\t\tkfree(mc_list);\n}\n\nstatic void wilc_tx_complete(void *priv, int status)\n{\n\tstruct tx_complete_data *pv_data = priv;\n\n\tdev_kfree_skb(pv_data->skb);\n\tkfree(pv_data);\n}\n\nnetdev_tx_t wilc_mac_xmit(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct wilc_vif *vif = netdev_priv(ndev);\n\tstruct wilc *wilc = vif->wilc;\n\tstruct tx_complete_data *tx_data = NULL;\n\tint queue_count;\n\n\tif (skb->dev != ndev) {\n\t\tnetdev_err(ndev, \"Packet not destined to this device\\n\");\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\ttx_data = kmalloc(sizeof(*tx_data), GFP_ATOMIC);\n\tif (!tx_data) {\n\t\tdev_kfree_skb(skb);\n\t\tnetif_wake_queue(ndev);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\ttx_data->buff = skb->data;\n\ttx_data->size = skb->len;\n\ttx_data->skb  = skb;\n\n\tvif->netstats.tx_packets++;\n\tvif->netstats.tx_bytes += tx_data->size;\n\tqueue_count = wilc_wlan_txq_add_net_pkt(ndev, tx_data,\n\t\t\t\t\t\ttx_data->buff, tx_data->size,\n\t\t\t\t\t\twilc_tx_complete);\n\n\tif (queue_count > FLOW_CONTROL_UPPER_THRESHOLD) {\n\t\tint srcu_idx;\n\t\tstruct wilc_vif *vif;\n\n\t\tsrcu_idx = srcu_read_lock(&wilc->srcu);\n\t\tlist_for_each_entry_rcu(vif, &wilc->vif_list, list) {\n\t\t\tif (vif->mac_opened)\n\t\t\t\tnetif_stop_queue(vif->ndev);\n\t\t}\n\t\tsrcu_read_unlock(&wilc->srcu, srcu_idx);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int wilc_mac_close(struct net_device *ndev)\n{\n\tstruct wilc_vif *vif = netdev_priv(ndev);\n\tstruct wilc *wl = vif->wilc;\n\n\tnetdev_dbg(ndev, \"Mac close\\n\");\n\n\tif (wl->open_ifcs > 0)\n\t\twl->open_ifcs--;\n\telse\n\t\treturn 0;\n\n\tif (vif->ndev) {\n\t\tnetif_stop_queue(vif->ndev);\n\n\t\twilc_handle_disconnect(vif);\n\t\twilc_deinit_host_int(vif->ndev);\n\t}\n\n\tif (wl->open_ifcs == 0) {\n\t\tnetdev_dbg(ndev, \"Deinitializing wilc1000\\n\");\n\t\twl->close = 1;\n\t\twilc_wlan_deinitialize(ndev);\n\t}\n\n\tvif->mac_opened = 0;\n\n\treturn 0;\n}\n\nvoid wilc_frmw_to_host(struct wilc *wilc, u8 *buff, u32 size,\n\t\t       u32 pkt_offset)\n{\n\tunsigned int frame_len = 0;\n\tint stats;\n\tunsigned char *buff_to_send = NULL;\n\tstruct sk_buff *skb;\n\tstruct net_device *wilc_netdev;\n\tstruct wilc_vif *vif;\n\n\tif (!wilc)\n\t\treturn;\n\n\twilc_netdev = get_if_handler(wilc, buff);\n\tif (!wilc_netdev)\n\t\treturn;\n\n\tbuff += pkt_offset;\n\tvif = netdev_priv(wilc_netdev);\n\n\tif (size > 0) {\n\t\tframe_len = size;\n\t\tbuff_to_send = buff;\n\n\t\tskb = dev_alloc_skb(frame_len);\n\t\tif (!skb)\n\t\t\treturn;\n\n\t\tskb->dev = wilc_netdev;\n\n\t\tskb_put_data(skb, buff_to_send, frame_len);\n\n\t\tskb->protocol = eth_type_trans(skb, wilc_netdev);\n\t\tvif->netstats.rx_packets++;\n\t\tvif->netstats.rx_bytes += frame_len;\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\tstats = netif_rx(skb);\n\t\tnetdev_dbg(wilc_netdev, \"netif_rx ret value is: %d\\n\", stats);\n\t}\n}\n\nvoid wilc_wfi_mgmt_rx(struct wilc *wilc, u8 *buff, u32 size, bool is_auth)\n{\n\tint srcu_idx;\n\tstruct wilc_vif *vif;\n\n\tsrcu_idx = srcu_read_lock(&wilc->srcu);\n\tlist_for_each_entry_rcu(vif, &wilc->vif_list, list) {\n\t\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)buff;\n\t\tu16 type = le16_to_cpup((__le16 *)buff);\n\t\tu32 type_bit = BIT(type >> 4);\n\t\tu32 auth_bit = BIT(IEEE80211_STYPE_AUTH >> 4);\n\n\t\tif ((vif->mgmt_reg_stypes & auth_bit &&\n\t\t     ieee80211_is_auth(mgmt->frame_control)) &&\n\t\t    vif->iftype == WILC_STATION_MODE && is_auth) {\n\t\t\twilc_wfi_mgmt_frame_rx(vif, buff, size);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (vif->priv.p2p_listen_state &&\n\t\t    vif->mgmt_reg_stypes & type_bit)\n\t\t\twilc_wfi_p2p_rx(vif, buff, size);\n\n\t\tif (vif->monitor_flag)\n\t\t\twilc_wfi_monitor_rx(wilc->monitor_dev, buff, size);\n\t}\n\tsrcu_read_unlock(&wilc->srcu, srcu_idx);\n}\n\nstatic const struct net_device_ops wilc_netdev_ops = {\n\t.ndo_init = mac_init_fn,\n\t.ndo_open = wilc_mac_open,\n\t.ndo_stop = wilc_mac_close,\n\t.ndo_set_mac_address = wilc_set_mac_addr,\n\t.ndo_start_xmit = wilc_mac_xmit,\n\t.ndo_get_stats = mac_stats,\n\t.ndo_set_rx_mode  = wilc_set_multicast_list,\n};\n\nvoid wilc_netdev_cleanup(struct wilc *wilc)\n{\n\tstruct wilc_vif *vif;\n\tint srcu_idx, ifc_cnt = 0;\n\n\tif (!wilc)\n\t\treturn;\n\n\tif (wilc->firmware) {\n\t\trelease_firmware(wilc->firmware);\n\t\twilc->firmware = NULL;\n\t}\n\n\tsrcu_idx = srcu_read_lock(&wilc->srcu);\n\tlist_for_each_entry_rcu(vif, &wilc->vif_list, list) {\n\t\tif (vif->ndev)\n\t\t\tunregister_netdev(vif->ndev);\n\t}\n\tsrcu_read_unlock(&wilc->srcu, srcu_idx);\n\n\twilc_wfi_deinit_mon_interface(wilc, false);\n\tdestroy_workqueue(wilc->hif_workqueue);\n\n\twhile (ifc_cnt < WILC_NUM_CONCURRENT_IFC) {\n\t\tmutex_lock(&wilc->vif_mutex);\n\t\tif (wilc->vif_num <= 0) {\n\t\t\tmutex_unlock(&wilc->vif_mutex);\n\t\t\tbreak;\n\t\t}\n\t\tvif = wilc_get_wl_to_vif(wilc);\n\t\tif (!IS_ERR(vif))\n\t\t\tlist_del_rcu(&vif->list);\n\n\t\twilc->vif_num--;\n\t\tmutex_unlock(&wilc->vif_mutex);\n\t\tsynchronize_srcu(&wilc->srcu);\n\t\tifc_cnt++;\n\t}\n\n\twilc_wlan_cfg_deinit(wilc);\n\twlan_deinit_locks(wilc);\n\twiphy_unregister(wilc->wiphy);\n\twiphy_free(wilc->wiphy);\n}\nEXPORT_SYMBOL_GPL(wilc_netdev_cleanup);\n\nstatic u8 wilc_get_available_idx(struct wilc *wl)\n{\n\tint idx = 0;\n\tstruct wilc_vif *vif;\n\tint srcu_idx;\n\n\tsrcu_idx = srcu_read_lock(&wl->srcu);\n\tlist_for_each_entry_rcu(vif, &wl->vif_list, list) {\n\t\tif (vif->idx == 0)\n\t\t\tidx = 1;\n\t\telse\n\t\t\tidx = 0;\n\t}\n\tsrcu_read_unlock(&wl->srcu, srcu_idx);\n\treturn idx;\n}\n\nstruct wilc_vif *wilc_netdev_ifc_init(struct wilc *wl, const char *name,\n\t\t\t\t      int vif_type, enum nl80211_iftype type,\n\t\t\t\t      bool rtnl_locked)\n{\n\tstruct net_device *ndev;\n\tstruct wilc_vif *vif;\n\tint ret;\n\n\tndev = alloc_etherdev(sizeof(*vif));\n\tif (!ndev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvif = netdev_priv(ndev);\n\tndev->ieee80211_ptr = &vif->priv.wdev;\n\tstrcpy(ndev->name, name);\n\tvif->wilc = wl;\n\tvif->ndev = ndev;\n\tndev->ml_priv = vif;\n\n\tndev->netdev_ops = &wilc_netdev_ops;\n\n\tSET_NETDEV_DEV(ndev, wiphy_dev(wl->wiphy));\n\n\tvif->priv.wdev.wiphy = wl->wiphy;\n\tvif->priv.wdev.netdev = ndev;\n\tvif->priv.wdev.iftype = type;\n\tvif->priv.dev = ndev;\n\n\tif (rtnl_locked)\n\t\tret = cfg80211_register_netdevice(ndev);\n\telse\n\t\tret = register_netdev(ndev);\n\n\tif (ret) {\n\t\tret = -EFAULT;\n\t\tgoto error;\n\t}\n\n\twl->hif_workqueue = alloc_ordered_workqueue(\"%s-wq\", WQ_MEM_RECLAIM,\n\t\t\t\t\t\t    ndev->name);\n\tif (!wl->hif_workqueue) {\n\t\tret = -ENOMEM;\n\t\tgoto unregister_netdev;\n\t}\n\n\tndev->needs_free_netdev = true;\n\tvif->iftype = vif_type;\n\tvif->idx = wilc_get_available_idx(wl);\n\tvif->mac_opened = 0;\n\tmutex_lock(&wl->vif_mutex);\n\tlist_add_tail_rcu(&vif->list, &wl->vif_list);\n\twl->vif_num += 1;\n\tmutex_unlock(&wl->vif_mutex);\n\tsynchronize_srcu(&wl->srcu);\n\n\treturn vif;\n\nunregister_netdev:\n\tif (rtnl_locked)\n\t\tcfg80211_unregister_netdevice(ndev);\n\telse\n\t\tunregister_netdev(ndev);\n  error:\n\tfree_netdev(ndev);\n\treturn ERR_PTR(ret);\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(WILC1000_FW(WILC1000_API_VER));\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}