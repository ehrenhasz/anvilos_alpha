{
  "module_name": "spi.c",
  "hash_id": "3cd5358f6699592c32b88b47332ce86382863438df3d1c5f460ba9597ae67a70",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/microchip/wilc1000/spi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/spi/spi.h>\n#include <linux/crc7.h>\n#include <linux/crc-itu-t.h>\n#include <linux/gpio/consumer.h>\n\n#include \"netdev.h\"\n#include \"cfg80211.h\"\n\n#define SPI_MODALIAS\t\t\"wilc1000_spi\"\n\nstatic bool enable_crc7;\t \nmodule_param(enable_crc7, bool, 0644);\nMODULE_PARM_DESC(enable_crc7,\n\t\t \"Enable CRC7 checksum to protect command transfers\\n\"\n\t\t \"\\t\\t\\tagainst corruption during the SPI transfer.\\n\"\n\t\t \"\\t\\t\\tCommand transfers are short and the CPU-cycle cost\\n\"\n\t\t \"\\t\\t\\tof enabling this is small.\");\n\nstatic bool enable_crc16;\t \nmodule_param(enable_crc16, bool, 0644);\nMODULE_PARM_DESC(enable_crc16,\n\t\t \"Enable CRC16 checksum to protect data transfers\\n\"\n\t\t \"\\t\\t\\tagainst corruption during the SPI transfer.\\n\"\n\t\t \"\\t\\t\\tData transfers can be large and the CPU-cycle cost\\n\"\n\t\t \"\\t\\t\\tof enabling this may be substantial.\");\n\n \n#define WILC_SPI_RSP_HDR_EXTRA_DATA\t8\n\nstruct wilc_spi {\n\tbool isinit;\t\t \n\tbool probing_crc;\t \n\tbool crc7_enabled;\t \n\tbool crc16_enabled;\t \n\tstruct wilc_gpios {\n\t\tstruct gpio_desc *enable;\t \n\t\tstruct gpio_desc *reset;\t \n\t} gpios;\n};\n\nstatic const struct wilc_hif_func wilc_hif_spi;\n\nstatic int wilc_spi_reset(struct wilc *wilc);\n\n \n\n#define CMD_DMA_WRITE\t\t\t\t0xc1\n#define CMD_DMA_READ\t\t\t\t0xc2\n#define CMD_INTERNAL_WRITE\t\t\t0xc3\n#define CMD_INTERNAL_READ\t\t\t0xc4\n#define CMD_TERMINATE\t\t\t\t0xc5\n#define CMD_REPEAT\t\t\t\t0xc6\n#define CMD_DMA_EXT_WRITE\t\t\t0xc7\n#define CMD_DMA_EXT_READ\t\t\t0xc8\n#define CMD_SINGLE_WRITE\t\t\t0xc9\n#define CMD_SINGLE_READ\t\t\t\t0xca\n#define CMD_RESET\t\t\t\t0xcf\n\n#define SPI_RETRY_MAX_LIMIT\t\t\t10\n#define SPI_ENABLE_VMM_RETRY_LIMIT\t\t2\n\n \n#define RSP_START_FIELD\t\t\t\tGENMASK(7, 4)\n#define RSP_TYPE_FIELD\t\t\t\tGENMASK(3, 0)\n\n \n#define RSP_START_TAG\t\t\t\t0xc\n#define RSP_TYPE_FIRST_PACKET\t\t\t0x1\n#define RSP_TYPE_INNER_PACKET\t\t\t0x2\n#define RSP_TYPE_LAST_PACKET\t\t\t0x3\n#define RSP_STATE_NO_ERROR\t\t\t0x00\n\n#define PROTOCOL_REG_PKT_SZ_MASK\t\tGENMASK(6, 4)\n#define PROTOCOL_REG_CRC16_MASK\t\t\tGENMASK(3, 3)\n#define PROTOCOL_REG_CRC7_MASK\t\t\tGENMASK(2, 2)\n\n \n#define DATA_PKT_LOG_SZ_MIN\t\t\t8\t \n#define DATA_PKT_LOG_SZ_MAX\t\t\t13\t \n\n \n#define DATA_PKT_LOG_SZ\t\t\t\tDATA_PKT_LOG_SZ_MAX\n#define DATA_PKT_SZ\t\t\t\t(1 << DATA_PKT_LOG_SZ)\n\n#define WILC_SPI_COMMAND_STAT_SUCCESS\t\t0\n#define WILC_GET_RESP_HDR_START(h)\t\t(((h) >> 4) & 0xf)\n\nstruct wilc_spi_cmd {\n\tu8 cmd_type;\n\tunion {\n\t\tstruct {\n\t\t\tu8 addr[3];\n\t\t\tu8 crc[];\n\t\t} __packed simple_cmd;\n\t\tstruct {\n\t\t\tu8 addr[3];\n\t\t\tu8 size[2];\n\t\t\tu8 crc[];\n\t\t} __packed dma_cmd;\n\t\tstruct {\n\t\t\tu8 addr[3];\n\t\t\tu8 size[3];\n\t\t\tu8 crc[];\n\t\t} __packed dma_cmd_ext;\n\t\tstruct {\n\t\t\tu8 addr[2];\n\t\t\t__be32 data;\n\t\t\tu8 crc[];\n\t\t} __packed internal_w_cmd;\n\t\tstruct {\n\t\t\tu8 addr[3];\n\t\t\t__be32 data;\n\t\t\tu8 crc[];\n\t\t} __packed w_cmd;\n\t} u;\n} __packed;\n\nstruct wilc_spi_read_rsp_data {\n\tu8 header;\n\tu8 data[4];\n\tu8 crc[];\n} __packed;\n\nstruct wilc_spi_rsp_data {\n\tu8 rsp_cmd_type;\n\tu8 status;\n\tu8 data[];\n} __packed;\n\nstruct wilc_spi_special_cmd_rsp {\n\tu8 skip_byte;\n\tu8 rsp_cmd_type;\n\tu8 status;\n} __packed;\n\nstatic int wilc_parse_gpios(struct wilc *wilc)\n{\n\tstruct spi_device *spi = to_spi_device(wilc->dev);\n\tstruct wilc_spi *spi_priv = wilc->bus_data;\n\tstruct wilc_gpios *gpios = &spi_priv->gpios;\n\n\t \n\tgpios->enable = devm_gpiod_get_optional(&spi->dev,\n\t\t\t\t\t\t\"enable\", GPIOD_OUT_LOW);\n\t \n\tif (gpios->enable) {\n\t\t \n\t\tgpios->reset = devm_gpiod_get(&spi->dev,\n\t\t\t\t\t      \"reset\", GPIOD_OUT_HIGH);\n\t\tif (IS_ERR(gpios->reset)) {\n\t\t\tdev_err(&spi->dev, \"missing reset gpio.\\n\");\n\t\t\treturn PTR_ERR(gpios->reset);\n\t\t}\n\t} else {\n\t\tgpios->reset = devm_gpiod_get_optional(&spi->dev,\n\t\t\t\t\t\t       \"reset\", GPIOD_OUT_HIGH);\n\t}\n\treturn 0;\n}\n\nstatic void wilc_wlan_power(struct wilc *wilc, bool on)\n{\n\tstruct wilc_spi *spi_priv = wilc->bus_data;\n\tstruct wilc_gpios *gpios = &spi_priv->gpios;\n\n\tif (on) {\n\t\t \n\t\tgpiod_set_value(gpios->enable, 1);\n\t\tmdelay(5);\n\t\t \n\t\tgpiod_set_value(gpios->reset, 1);\n\t} else {\n\t\t \n\t\tgpiod_set_value(gpios->reset, 0);\n\t\t \n\t\tgpiod_set_value(gpios->enable, 0);\n\t}\n}\n\nstatic int wilc_bus_probe(struct spi_device *spi)\n{\n\tint ret;\n\tstruct wilc *wilc;\n\tstruct wilc_spi *spi_priv;\n\n\tspi_priv = kzalloc(sizeof(*spi_priv), GFP_KERNEL);\n\tif (!spi_priv)\n\t\treturn -ENOMEM;\n\n\tret = wilc_cfg80211_init(&wilc, &spi->dev, WILC_HIF_SPI, &wilc_hif_spi);\n\tif (ret)\n\t\tgoto free;\n\n\tspi_set_drvdata(spi, wilc);\n\twilc->dev = &spi->dev;\n\twilc->bus_data = spi_priv;\n\twilc->dev_irq_num = spi->irq;\n\n\tret = wilc_parse_gpios(wilc);\n\tif (ret < 0)\n\t\tgoto netdev_cleanup;\n\n\twilc->rtc_clk = devm_clk_get_optional(&spi->dev, \"rtc\");\n\tif (IS_ERR(wilc->rtc_clk)) {\n\t\tret = PTR_ERR(wilc->rtc_clk);\n\t\tgoto netdev_cleanup;\n\t}\n\tclk_prepare_enable(wilc->rtc_clk);\n\n\treturn 0;\n\nnetdev_cleanup:\n\twilc_netdev_cleanup(wilc);\nfree:\n\tkfree(spi_priv);\n\treturn ret;\n}\n\nstatic void wilc_bus_remove(struct spi_device *spi)\n{\n\tstruct wilc *wilc = spi_get_drvdata(spi);\n\tstruct wilc_spi *spi_priv = wilc->bus_data;\n\n\tclk_disable_unprepare(wilc->rtc_clk);\n\twilc_netdev_cleanup(wilc);\n\tkfree(spi_priv);\n}\n\nstatic const struct of_device_id wilc_of_match[] = {\n\t{ .compatible = \"microchip,wilc1000\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, wilc_of_match);\n\nstatic const struct spi_device_id wilc_spi_id[] = {\n\t{ \"wilc1000\", 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(spi, wilc_spi_id);\n\nstatic struct spi_driver wilc_spi_driver = {\n\t.driver = {\n\t\t.name = SPI_MODALIAS,\n\t\t.of_match_table = wilc_of_match,\n\t},\n\t.id_table = wilc_spi_id,\n\t.probe =  wilc_bus_probe,\n\t.remove = wilc_bus_remove,\n};\nmodule_spi_driver(wilc_spi_driver);\nMODULE_LICENSE(\"GPL\");\n\nstatic int wilc_spi_tx(struct wilc *wilc, u8 *b, u32 len)\n{\n\tstruct spi_device *spi = to_spi_device(wilc->dev);\n\tint ret;\n\tstruct spi_message msg;\n\n\tif (len > 0 && b) {\n\t\tstruct spi_transfer tr = {\n\t\t\t.tx_buf = b,\n\t\t\t.len = len,\n\t\t\t.delay = {\n\t\t\t\t.value = 0,\n\t\t\t\t.unit = SPI_DELAY_UNIT_USECS\n\t\t\t},\n\t\t};\n\t\tchar *r_buffer = kzalloc(len, GFP_KERNEL);\n\n\t\tif (!r_buffer)\n\t\t\treturn -ENOMEM;\n\n\t\ttr.rx_buf = r_buffer;\n\t\tdev_dbg(&spi->dev, \"Request writing %d bytes\\n\", len);\n\n\t\tmemset(&msg, 0, sizeof(msg));\n\t\tspi_message_init(&msg);\n\t\tmsg.spi = spi;\n\t\tspi_message_add_tail(&tr, &msg);\n\n\t\tret = spi_sync(spi, &msg);\n\t\tif (ret < 0)\n\t\t\tdev_err(&spi->dev, \"SPI transaction failed\\n\");\n\n\t\tkfree(r_buffer);\n\t} else {\n\t\tdev_err(&spi->dev,\n\t\t\t\"can't write data with the following length: %d\\n\",\n\t\t\tlen);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int wilc_spi_rx(struct wilc *wilc, u8 *rb, u32 rlen)\n{\n\tstruct spi_device *spi = to_spi_device(wilc->dev);\n\tint ret;\n\n\tif (rlen > 0) {\n\t\tstruct spi_message msg;\n\t\tstruct spi_transfer tr = {\n\t\t\t.rx_buf = rb,\n\t\t\t.len = rlen,\n\t\t\t.delay = {\n\t\t\t\t.value = 0,\n\t\t\t\t.unit = SPI_DELAY_UNIT_USECS\n\t\t\t},\n\n\t\t};\n\t\tchar *t_buffer = kzalloc(rlen, GFP_KERNEL);\n\n\t\tif (!t_buffer)\n\t\t\treturn -ENOMEM;\n\n\t\ttr.tx_buf = t_buffer;\n\n\t\tmemset(&msg, 0, sizeof(msg));\n\t\tspi_message_init(&msg);\n\t\tmsg.spi = spi;\n\t\tspi_message_add_tail(&tr, &msg);\n\n\t\tret = spi_sync(spi, &msg);\n\t\tif (ret < 0)\n\t\t\tdev_err(&spi->dev, \"SPI transaction failed\\n\");\n\t\tkfree(t_buffer);\n\t} else {\n\t\tdev_err(&spi->dev,\n\t\t\t\"can't read data with the following length: %u\\n\",\n\t\t\trlen);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int wilc_spi_tx_rx(struct wilc *wilc, u8 *wb, u8 *rb, u32 rlen)\n{\n\tstruct spi_device *spi = to_spi_device(wilc->dev);\n\tint ret;\n\n\tif (rlen > 0) {\n\t\tstruct spi_message msg;\n\t\tstruct spi_transfer tr = {\n\t\t\t.rx_buf = rb,\n\t\t\t.tx_buf = wb,\n\t\t\t.len = rlen,\n\t\t\t.bits_per_word = 8,\n\t\t\t.delay = {\n\t\t\t\t.value = 0,\n\t\t\t\t.unit = SPI_DELAY_UNIT_USECS\n\t\t\t},\n\n\t\t};\n\n\t\tmemset(&msg, 0, sizeof(msg));\n\t\tspi_message_init(&msg);\n\t\tmsg.spi = spi;\n\n\t\tspi_message_add_tail(&tr, &msg);\n\t\tret = spi_sync(spi, &msg);\n\t\tif (ret < 0)\n\t\t\tdev_err(&spi->dev, \"SPI transaction failed\\n\");\n\t} else {\n\t\tdev_err(&spi->dev,\n\t\t\t\"can't read data with the following length: %u\\n\",\n\t\t\trlen);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int spi_data_write(struct wilc *wilc, u8 *b, u32 sz)\n{\n\tstruct spi_device *spi = to_spi_device(wilc->dev);\n\tstruct wilc_spi *spi_priv = wilc->bus_data;\n\tint ix, nbytes;\n\tint result = 0;\n\tu8 cmd, order, crc[2];\n\tu16 crc_calc;\n\n\t \n\tix = 0;\n\tdo {\n\t\tif (sz <= DATA_PKT_SZ) {\n\t\t\tnbytes = sz;\n\t\t\torder = 0x3;\n\t\t} else {\n\t\t\tnbytes = DATA_PKT_SZ;\n\t\t\tif (ix == 0)\n\t\t\t\torder = 0x1;\n\t\t\telse\n\t\t\t\torder = 0x02;\n\t\t}\n\n\t\t \n\t\tcmd = 0xf0;\n\t\tcmd |= order;\n\n\t\tif (wilc_spi_tx(wilc, &cmd, 1)) {\n\t\t\tdev_err(&spi->dev,\n\t\t\t\t\"Failed data block cmd write, bus error...\\n\");\n\t\t\tresult = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (wilc_spi_tx(wilc, &b[ix], nbytes)) {\n\t\t\tdev_err(&spi->dev,\n\t\t\t\t\"Failed data block write, bus error...\\n\");\n\t\t\tresult = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (spi_priv->crc16_enabled) {\n\t\t\tcrc_calc = crc_itu_t(0xffff, &b[ix], nbytes);\n\t\t\tcrc[0] = crc_calc >> 8;\n\t\t\tcrc[1] = crc_calc;\n\t\t\tif (wilc_spi_tx(wilc, crc, 2)) {\n\t\t\t\tdev_err(&spi->dev, \"Failed data block crc write, bus error...\\n\");\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tix += nbytes;\n\t\tsz -= nbytes;\n\t} while (sz);\n\n\treturn result;\n}\n\n \nstatic u8 wilc_get_crc7(u8 *buffer, u32 len)\n{\n\treturn crc7_be(0xfe, buffer, len);\n}\n\nstatic int wilc_spi_single_read(struct wilc *wilc, u8 cmd, u32 adr, void *b,\n\t\t\t\tu8 clockless)\n{\n\tstruct spi_device *spi = to_spi_device(wilc->dev);\n\tstruct wilc_spi *spi_priv = wilc->bus_data;\n\tu8 wb[32], rb[32];\n\tint cmd_len, resp_len, i;\n\tu16 crc_calc, crc_recv;\n\tstruct wilc_spi_cmd *c;\n\tstruct wilc_spi_rsp_data *r;\n\tstruct wilc_spi_read_rsp_data *r_data;\n\n\tmemset(wb, 0x0, sizeof(wb));\n\tmemset(rb, 0x0, sizeof(rb));\n\tc = (struct wilc_spi_cmd *)wb;\n\tc->cmd_type = cmd;\n\tif (cmd == CMD_SINGLE_READ) {\n\t\tc->u.simple_cmd.addr[0] = adr >> 16;\n\t\tc->u.simple_cmd.addr[1] = adr >> 8;\n\t\tc->u.simple_cmd.addr[2] = adr;\n\t} else if (cmd == CMD_INTERNAL_READ) {\n\t\tc->u.simple_cmd.addr[0] = adr >> 8;\n\t\tif (clockless == 1)\n\t\t\tc->u.simple_cmd.addr[0] |= BIT(7);\n\t\tc->u.simple_cmd.addr[1] = adr;\n\t\tc->u.simple_cmd.addr[2] = 0x0;\n\t} else {\n\t\tdev_err(&spi->dev, \"cmd [%x] not supported\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\tcmd_len = offsetof(struct wilc_spi_cmd, u.simple_cmd.crc);\n\tresp_len = sizeof(*r) + sizeof(*r_data) + WILC_SPI_RSP_HDR_EXTRA_DATA;\n\n\tif (spi_priv->crc7_enabled) {\n\t\tc->u.simple_cmd.crc[0] = wilc_get_crc7(wb, cmd_len);\n\t\tcmd_len += 1;\n\t\tresp_len += 2;\n\t}\n\n\tif (cmd_len + resp_len > ARRAY_SIZE(wb)) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"spi buffer size too small (%d) (%d) (%zu)\\n\",\n\t\t\tcmd_len, resp_len, ARRAY_SIZE(wb));\n\t\treturn -EINVAL;\n\t}\n\n\tif (wilc_spi_tx_rx(wilc, wb, rb, cmd_len + resp_len)) {\n\t\tdev_err(&spi->dev, \"Failed cmd write, bus error...\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tr = (struct wilc_spi_rsp_data *)&rb[cmd_len];\n\tif (r->rsp_cmd_type != cmd && !clockless) {\n\t\tif (!spi_priv->probing_crc)\n\t\t\tdev_err(&spi->dev,\n\t\t\t\t\"Failed cmd, cmd (%02x), resp (%02x)\\n\",\n\t\t\t\tcmd, r->rsp_cmd_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (r->status != WILC_SPI_COMMAND_STAT_SUCCESS && !clockless) {\n\t\tdev_err(&spi->dev, \"Failed cmd state response state (%02x)\\n\",\n\t\t\tr->status);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < WILC_SPI_RSP_HDR_EXTRA_DATA; ++i)\n\t\tif (WILC_GET_RESP_HDR_START(r->data[i]) == 0xf)\n\t\t\tbreak;\n\n\tif (i >= WILC_SPI_RSP_HDR_EXTRA_DATA) {\n\t\tdev_err(&spi->dev, \"Error, data start missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tr_data = (struct wilc_spi_read_rsp_data *)&r->data[i];\n\n\tif (b)\n\t\tmemcpy(b, r_data->data, 4);\n\n\tif (!clockless && spi_priv->crc16_enabled) {\n\t\tcrc_recv = (r_data->crc[0] << 8) | r_data->crc[1];\n\t\tcrc_calc = crc_itu_t(0xffff, r_data->data, 4);\n\t\tif (crc_recv != crc_calc) {\n\t\t\tdev_err(&spi->dev, \"%s: bad CRC 0x%04x \"\n\t\t\t\t\"(calculated 0x%04x)\\n\", __func__,\n\t\t\t\tcrc_recv, crc_calc);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int wilc_spi_write_cmd(struct wilc *wilc, u8 cmd, u32 adr, u32 data,\n\t\t\t      u8 clockless)\n{\n\tstruct spi_device *spi = to_spi_device(wilc->dev);\n\tstruct wilc_spi *spi_priv = wilc->bus_data;\n\tu8 wb[32], rb[32];\n\tint cmd_len, resp_len;\n\tstruct wilc_spi_cmd *c;\n\tstruct wilc_spi_rsp_data *r;\n\n\tmemset(wb, 0x0, sizeof(wb));\n\tmemset(rb, 0x0, sizeof(rb));\n\tc = (struct wilc_spi_cmd *)wb;\n\tc->cmd_type = cmd;\n\tif (cmd == CMD_INTERNAL_WRITE) {\n\t\tc->u.internal_w_cmd.addr[0] = adr >> 8;\n\t\tif (clockless == 1)\n\t\t\tc->u.internal_w_cmd.addr[0] |= BIT(7);\n\n\t\tc->u.internal_w_cmd.addr[1] = adr;\n\t\tc->u.internal_w_cmd.data = cpu_to_be32(data);\n\t\tcmd_len = offsetof(struct wilc_spi_cmd, u.internal_w_cmd.crc);\n\t\tif (spi_priv->crc7_enabled)\n\t\t\tc->u.internal_w_cmd.crc[0] = wilc_get_crc7(wb, cmd_len);\n\t} else if (cmd == CMD_SINGLE_WRITE) {\n\t\tc->u.w_cmd.addr[0] = adr >> 16;\n\t\tc->u.w_cmd.addr[1] = adr >> 8;\n\t\tc->u.w_cmd.addr[2] = adr;\n\t\tc->u.w_cmd.data = cpu_to_be32(data);\n\t\tcmd_len = offsetof(struct wilc_spi_cmd, u.w_cmd.crc);\n\t\tif (spi_priv->crc7_enabled)\n\t\t\tc->u.w_cmd.crc[0] = wilc_get_crc7(wb, cmd_len);\n\t} else {\n\t\tdev_err(&spi->dev, \"write cmd [%x] not supported\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\tif (spi_priv->crc7_enabled)\n\t\tcmd_len += 1;\n\n\tresp_len = sizeof(*r);\n\n\tif (cmd_len + resp_len > ARRAY_SIZE(wb)) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"spi buffer size too small (%d) (%d) (%zu)\\n\",\n\t\t\tcmd_len, resp_len, ARRAY_SIZE(wb));\n\t\treturn -EINVAL;\n\t}\n\n\tif (wilc_spi_tx_rx(wilc, wb, rb, cmd_len + resp_len)) {\n\t\tdev_err(&spi->dev, \"Failed cmd write, bus error...\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tr = (struct wilc_spi_rsp_data *)&rb[cmd_len];\n\t \n\tif (r->rsp_cmd_type != cmd && !clockless) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"Failed cmd response, cmd (%02x), resp (%02x)\\n\",\n\t\t\tcmd, r->rsp_cmd_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (r->status != WILC_SPI_COMMAND_STAT_SUCCESS && !clockless) {\n\t\tdev_err(&spi->dev, \"Failed cmd state response state (%02x)\\n\",\n\t\t\tr->status);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int wilc_spi_dma_rw(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz)\n{\n\tstruct spi_device *spi = to_spi_device(wilc->dev);\n\tstruct wilc_spi *spi_priv = wilc->bus_data;\n\tu16 crc_recv, crc_calc;\n\tu8 wb[32], rb[32];\n\tint cmd_len, resp_len;\n\tint retry, ix = 0;\n\tu8 crc[2];\n\tstruct wilc_spi_cmd *c;\n\tstruct wilc_spi_rsp_data *r;\n\n\tmemset(wb, 0x0, sizeof(wb));\n\tmemset(rb, 0x0, sizeof(rb));\n\tc = (struct wilc_spi_cmd *)wb;\n\tc->cmd_type = cmd;\n\tif (cmd == CMD_DMA_WRITE || cmd == CMD_DMA_READ) {\n\t\tc->u.dma_cmd.addr[0] = adr >> 16;\n\t\tc->u.dma_cmd.addr[1] = adr >> 8;\n\t\tc->u.dma_cmd.addr[2] = adr;\n\t\tc->u.dma_cmd.size[0] = sz >> 8;\n\t\tc->u.dma_cmd.size[1] = sz;\n\t\tcmd_len = offsetof(struct wilc_spi_cmd, u.dma_cmd.crc);\n\t\tif (spi_priv->crc7_enabled)\n\t\t\tc->u.dma_cmd.crc[0] = wilc_get_crc7(wb, cmd_len);\n\t} else if (cmd == CMD_DMA_EXT_WRITE || cmd == CMD_DMA_EXT_READ) {\n\t\tc->u.dma_cmd_ext.addr[0] = adr >> 16;\n\t\tc->u.dma_cmd_ext.addr[1] = adr >> 8;\n\t\tc->u.dma_cmd_ext.addr[2] = adr;\n\t\tc->u.dma_cmd_ext.size[0] = sz >> 16;\n\t\tc->u.dma_cmd_ext.size[1] = sz >> 8;\n\t\tc->u.dma_cmd_ext.size[2] = sz;\n\t\tcmd_len = offsetof(struct wilc_spi_cmd, u.dma_cmd_ext.crc);\n\t\tif (spi_priv->crc7_enabled)\n\t\t\tc->u.dma_cmd_ext.crc[0] = wilc_get_crc7(wb, cmd_len);\n\t} else {\n\t\tdev_err(&spi->dev, \"dma read write cmd [%x] not supported\\n\",\n\t\t\tcmd);\n\t\treturn -EINVAL;\n\t}\n\tif (spi_priv->crc7_enabled)\n\t\tcmd_len += 1;\n\n\tresp_len = sizeof(*r);\n\n\tif (cmd_len + resp_len > ARRAY_SIZE(wb)) {\n\t\tdev_err(&spi->dev, \"spi buffer size too small (%d)(%d) (%zu)\\n\",\n\t\t\tcmd_len, resp_len, ARRAY_SIZE(wb));\n\t\treturn -EINVAL;\n\t}\n\n\tif (wilc_spi_tx_rx(wilc, wb, rb, cmd_len + resp_len)) {\n\t\tdev_err(&spi->dev, \"Failed cmd write, bus error...\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tr = (struct wilc_spi_rsp_data *)&rb[cmd_len];\n\tif (r->rsp_cmd_type != cmd) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"Failed cmd response, cmd (%02x), resp (%02x)\\n\",\n\t\t\tcmd, r->rsp_cmd_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (r->status != WILC_SPI_COMMAND_STAT_SUCCESS) {\n\t\tdev_err(&spi->dev, \"Failed cmd state response state (%02x)\\n\",\n\t\t\tr->status);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cmd == CMD_DMA_WRITE || cmd == CMD_DMA_EXT_WRITE)\n\t\treturn 0;\n\n\twhile (sz > 0) {\n\t\tint nbytes;\n\t\tu8 rsp;\n\n\t\tnbytes = min_t(u32, sz, DATA_PKT_SZ);\n\n\t\t \n\t\tretry = 100;\n\t\tdo {\n\t\t\tif (wilc_spi_rx(wilc, &rsp, 1)) {\n\t\t\t\tdev_err(&spi->dev,\n\t\t\t\t\t\"Failed resp read, bus err\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (WILC_GET_RESP_HDR_START(rsp) == 0xf)\n\t\t\t\tbreak;\n\t\t} while (retry--);\n\n\t\t \n\t\tif (wilc_spi_rx(wilc, &b[ix], nbytes)) {\n\t\t\tdev_err(&spi->dev,\n\t\t\t\t\"Failed block read, bus err\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (spi_priv->crc16_enabled) {\n\t\t\tif (wilc_spi_rx(wilc, crc, 2)) {\n\t\t\t\tdev_err(&spi->dev,\n\t\t\t\t\t\"Failed block CRC read, bus err\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcrc_recv = (crc[0] << 8) | crc[1];\n\t\t\tcrc_calc = crc_itu_t(0xffff, &b[ix], nbytes);\n\t\t\tif (crc_recv != crc_calc) {\n\t\t\t\tdev_err(&spi->dev, \"%s: bad CRC 0x%04x \"\n\t\t\t\t\t\"(calculated 0x%04x)\\n\", __func__,\n\t\t\t\t\tcrc_recv, crc_calc);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tix += nbytes;\n\t\tsz -= nbytes;\n\t}\n\treturn 0;\n}\n\nstatic int wilc_spi_special_cmd(struct wilc *wilc, u8 cmd)\n{\n\tstruct spi_device *spi = to_spi_device(wilc->dev);\n\tstruct wilc_spi *spi_priv = wilc->bus_data;\n\tu8 wb[32], rb[32];\n\tint cmd_len, resp_len = 0;\n\tstruct wilc_spi_cmd *c;\n\tstruct wilc_spi_special_cmd_rsp *r;\n\n\tif (cmd != CMD_TERMINATE && cmd != CMD_REPEAT && cmd != CMD_RESET)\n\t\treturn -EINVAL;\n\n\tmemset(wb, 0x0, sizeof(wb));\n\tmemset(rb, 0x0, sizeof(rb));\n\tc = (struct wilc_spi_cmd *)wb;\n\tc->cmd_type = cmd;\n\n\tif (cmd == CMD_RESET)\n\t\tmemset(c->u.simple_cmd.addr, 0xFF, 3);\n\n\tcmd_len = offsetof(struct wilc_spi_cmd, u.simple_cmd.crc);\n\tresp_len = sizeof(*r);\n\n\tif (spi_priv->crc7_enabled) {\n\t\tc->u.simple_cmd.crc[0] = wilc_get_crc7(wb, cmd_len);\n\t\tcmd_len += 1;\n\t}\n\tif (cmd_len + resp_len > ARRAY_SIZE(wb)) {\n\t\tdev_err(&spi->dev, \"spi buffer size too small (%d) (%d) (%zu)\\n\",\n\t\t\tcmd_len, resp_len, ARRAY_SIZE(wb));\n\t\treturn -EINVAL;\n\t}\n\n\tif (wilc_spi_tx_rx(wilc, wb, rb, cmd_len + resp_len)) {\n\t\tdev_err(&spi->dev, \"Failed cmd write, bus error...\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tr = (struct wilc_spi_special_cmd_rsp *)&rb[cmd_len];\n\tif (r->rsp_cmd_type != cmd) {\n\t\tif (!spi_priv->probing_crc)\n\t\t\tdev_err(&spi->dev,\n\t\t\t\t\"Failed cmd response, cmd (%02x), resp (%02x)\\n\",\n\t\t\t\tcmd, r->rsp_cmd_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (r->status != WILC_SPI_COMMAND_STAT_SUCCESS) {\n\t\tdev_err(&spi->dev, \"Failed cmd state response state (%02x)\\n\",\n\t\t\tr->status);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void wilc_spi_reset_cmd_sequence(struct wilc *wl, u8 attempt, u32 addr)\n{\n\tstruct spi_device *spi = to_spi_device(wl->dev);\n\tstruct wilc_spi *spi_priv = wl->bus_data;\n\n\tif (!spi_priv->probing_crc)\n\t\tdev_err(&spi->dev, \"Reset and retry %d %x\\n\", attempt, addr);\n\n\tusleep_range(1000, 1100);\n\twilc_spi_reset(wl);\n\tusleep_range(1000, 1100);\n}\n\nstatic int wilc_spi_read_reg(struct wilc *wilc, u32 addr, u32 *data)\n{\n\tstruct spi_device *spi = to_spi_device(wilc->dev);\n\tint result;\n\tu8 cmd = CMD_SINGLE_READ;\n\tu8 clockless = 0;\n\tu8 i;\n\n\tif (addr <= WILC_SPI_CLOCKLESS_ADDR_LIMIT) {\n\t\t \n\t\tcmd = CMD_INTERNAL_READ;\n\t\tclockless = 1;\n\t}\n\n\tfor (i = 0; i < SPI_RETRY_MAX_LIMIT; i++) {\n\t\tresult = wilc_spi_single_read(wilc, cmd, addr, data, clockless);\n\t\tif (!result) {\n\t\t\tle32_to_cpus(data);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (clockless)\n\t\t\tbreak;\n\n\t\tdev_err(&spi->dev, \"Failed cmd, read reg (%08x)...\\n\", addr);\n\t\twilc_spi_reset_cmd_sequence(wilc, i, addr);\n\t}\n\n\treturn result;\n}\n\nstatic int wilc_spi_read(struct wilc *wilc, u32 addr, u8 *buf, u32 size)\n{\n\tstruct spi_device *spi = to_spi_device(wilc->dev);\n\tint result;\n\tu8 i;\n\n\tif (size <= 4)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < SPI_RETRY_MAX_LIMIT; i++) {\n\t\tresult = wilc_spi_dma_rw(wilc, CMD_DMA_EXT_READ, addr,\n\t\t\t\t\t buf, size);\n\t\tif (!result)\n\t\t\treturn 0;\n\n\t\tdev_err(&spi->dev, \"Failed cmd, read block (%08x)...\\n\", addr);\n\n\t\twilc_spi_reset_cmd_sequence(wilc, i, addr);\n\t}\n\n\treturn result;\n}\n\nstatic int spi_internal_write(struct wilc *wilc, u32 adr, u32 dat)\n{\n\tstruct spi_device *spi = to_spi_device(wilc->dev);\n\tint result;\n\tu8 i;\n\n\tfor (i = 0; i < SPI_RETRY_MAX_LIMIT; i++) {\n\t\tresult = wilc_spi_write_cmd(wilc, CMD_INTERNAL_WRITE, adr,\n\t\t\t\t\t    dat, 0);\n\t\tif (!result)\n\t\t\treturn 0;\n\t\tdev_err(&spi->dev, \"Failed internal write cmd...\\n\");\n\n\t\twilc_spi_reset_cmd_sequence(wilc, i, adr);\n\t}\n\n\treturn result;\n}\n\nstatic int spi_internal_read(struct wilc *wilc, u32 adr, u32 *data)\n{\n\tstruct spi_device *spi = to_spi_device(wilc->dev);\n\tstruct wilc_spi *spi_priv = wilc->bus_data;\n\tint result;\n\tu8 i;\n\n\tfor (i = 0; i < SPI_RETRY_MAX_LIMIT; i++) {\n\t\tresult = wilc_spi_single_read(wilc, CMD_INTERNAL_READ, adr,\n\t\t\t\t\t      data, 0);\n\t\tif (!result) {\n\t\t\tle32_to_cpus(data);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!spi_priv->probing_crc)\n\t\t\tdev_err(&spi->dev, \"Failed internal read cmd...\\n\");\n\n\t\twilc_spi_reset_cmd_sequence(wilc, i, adr);\n\t}\n\n\treturn result;\n}\n\n \n\nstatic int wilc_spi_write_reg(struct wilc *wilc, u32 addr, u32 data)\n{\n\tstruct spi_device *spi = to_spi_device(wilc->dev);\n\tint result;\n\tu8 cmd = CMD_SINGLE_WRITE;\n\tu8 clockless = 0;\n\tu8 i;\n\n\tif (addr <= WILC_SPI_CLOCKLESS_ADDR_LIMIT) {\n\t\t \n\t\tcmd = CMD_INTERNAL_WRITE;\n\t\tclockless = 1;\n\t}\n\n\tfor (i = 0; i < SPI_RETRY_MAX_LIMIT; i++) {\n\t\tresult = wilc_spi_write_cmd(wilc, cmd, addr, data, clockless);\n\t\tif (!result)\n\t\t\treturn 0;\n\n\t\tdev_err(&spi->dev, \"Failed cmd, write reg (%08x)...\\n\", addr);\n\n\t\tif (clockless)\n\t\t\tbreak;\n\n\t\twilc_spi_reset_cmd_sequence(wilc, i, addr);\n\t}\n\treturn result;\n}\n\nstatic int spi_data_rsp(struct wilc *wilc, u8 cmd)\n{\n\tstruct spi_device *spi = to_spi_device(wilc->dev);\n\tint result, i;\n\tu8 rsp[4];\n\n\t \n\tresult = wilc_spi_rx(wilc, rsp, sizeof(rsp));\n\tif (result) {\n\t\tdev_err(&spi->dev, \"Failed bus error...\\n\");\n\t\treturn result;\n\t}\n\n\tfor (i = sizeof(rsp) - 2; i >= 0; --i)\n\t\tif (FIELD_GET(RSP_START_FIELD, rsp[i]) == RSP_START_TAG)\n\t\t\tbreak;\n\n\tif (i < 0) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"Data packet response missing (%02x %02x %02x %02x)\\n\",\n\t\t\trsp[0], rsp[1], rsp[2], rsp[3]);\n\t\treturn -1;\n\t}\n\n\t \n\n\tif (FIELD_GET(RSP_TYPE_FIELD, rsp[i]) != RSP_TYPE_LAST_PACKET\n\t    || rsp[i + 1] != RSP_STATE_NO_ERROR) {\n\t\tdev_err(&spi->dev, \"Data response error (%02x %02x)\\n\",\n\t\t\trsp[i], rsp[i + 1]);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int wilc_spi_write(struct wilc *wilc, u32 addr, u8 *buf, u32 size)\n{\n\tstruct spi_device *spi = to_spi_device(wilc->dev);\n\tint result;\n\tu8 i;\n\n\t \n\tif (size <= 4)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < SPI_RETRY_MAX_LIMIT; i++) {\n\t\tresult = wilc_spi_dma_rw(wilc, CMD_DMA_EXT_WRITE, addr,\n\t\t\t\t\t NULL, size);\n\t\tif (result) {\n\t\t\tdev_err(&spi->dev,\n\t\t\t\t\"Failed cmd, write block (%08x)...\\n\", addr);\n\t\t\twilc_spi_reset_cmd_sequence(wilc, i, addr);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tresult = spi_data_write(wilc, buf, size);\n\t\tif (result) {\n\t\t\tdev_err(&spi->dev, \"Failed block data write...\\n\");\n\t\t\twilc_spi_reset_cmd_sequence(wilc, i, addr);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tresult = spi_data_rsp(wilc, CMD_DMA_EXT_WRITE);\n\t\tif (result) {\n\t\t\tdev_err(&spi->dev, \"Failed block data rsp...\\n\");\n\t\t\twilc_spi_reset_cmd_sequence(wilc, i, addr);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\treturn result;\n}\n\n \n\nstatic int wilc_spi_reset(struct wilc *wilc)\n{\n\tstruct spi_device *spi = to_spi_device(wilc->dev);\n\tstruct wilc_spi *spi_priv = wilc->bus_data;\n\tint result;\n\n\tresult = wilc_spi_special_cmd(wilc, CMD_RESET);\n\tif (result && !spi_priv->probing_crc)\n\t\tdev_err(&spi->dev, \"Failed cmd reset\\n\");\n\n\treturn result;\n}\n\nstatic bool wilc_spi_is_init(struct wilc *wilc)\n{\n\tstruct wilc_spi *spi_priv = wilc->bus_data;\n\n\treturn spi_priv->isinit;\n}\n\nstatic int wilc_spi_deinit(struct wilc *wilc)\n{\n\tstruct wilc_spi *spi_priv = wilc->bus_data;\n\n\tspi_priv->isinit = false;\n\twilc_wlan_power(wilc, false);\n\treturn 0;\n}\n\nstatic int wilc_spi_init(struct wilc *wilc, bool resume)\n{\n\tstruct spi_device *spi = to_spi_device(wilc->dev);\n\tstruct wilc_spi *spi_priv = wilc->bus_data;\n\tu32 reg;\n\tu32 chipid;\n\tint ret, i;\n\n\tif (spi_priv->isinit) {\n\t\t \n\t\tret = wilc_spi_read_reg(wilc, WILC_CHIPID, &chipid);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\n\t\tdev_err(&spi->dev, \"Fail cmd read chip id...\\n\");\n\t}\n\n\twilc_wlan_power(wilc, true);\n\n\t \n\n\t \n\tspi_priv->probing_crc = true;\n\tspi_priv->crc7_enabled = enable_crc7;\n\tspi_priv->crc16_enabled = false;  \n\tfor (i = 0; i < 2; ++i) {\n\t\tret = spi_internal_read(wilc, WILC_SPI_PROTOCOL_OFFSET, &reg);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tspi_priv->crc7_enabled = !enable_crc7;\n\t}\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed with CRC7 on and off.\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\treg &= ~(PROTOCOL_REG_CRC7_MASK | PROTOCOL_REG_CRC16_MASK);\n\tif (enable_crc7)\n\t\treg |= PROTOCOL_REG_CRC7_MASK;\n\tif (enable_crc16)\n\t\treg |= PROTOCOL_REG_CRC16_MASK;\n\n\t \n\tBUILD_BUG_ON(DATA_PKT_LOG_SZ < DATA_PKT_LOG_SZ_MIN\n\t\t     || DATA_PKT_LOG_SZ > DATA_PKT_LOG_SZ_MAX);\n\treg &= ~PROTOCOL_REG_PKT_SZ_MASK;\n\treg |= FIELD_PREP(PROTOCOL_REG_PKT_SZ_MASK,\n\t\t\t  DATA_PKT_LOG_SZ - DATA_PKT_LOG_SZ_MIN);\n\n\t \n\tret = spi_internal_write(wilc, WILC_SPI_PROTOCOL_OFFSET, reg);\n\tif (ret) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"[wilc spi %d]: Failed internal write reg\\n\",\n\t\t\t__LINE__);\n\t\treturn ret;\n\t}\n\t \n\tspi_priv->crc7_enabled = enable_crc7;\n\tspi_priv->crc16_enabled = enable_crc16;\n\n\t \n\tspi_internal_read(wilc, WILC_SPI_PROTOCOL_OFFSET, &reg);\n\n\tspi_priv->probing_crc = false;\n\n\t \n\tret = wilc_spi_read_reg(wilc, WILC_CHIPID, &chipid);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Fail cmd read chip id...\\n\");\n\t\treturn ret;\n\t}\n\n\tspi_priv->isinit = true;\n\n\treturn 0;\n}\n\nstatic int wilc_spi_read_size(struct wilc *wilc, u32 *size)\n{\n\tint ret;\n\n\tret = spi_internal_read(wilc,\n\t\t\t\tWILC_SPI_INT_STATUS - WILC_SPI_REG_BASE, size);\n\t*size = FIELD_GET(IRQ_DMA_WD_CNT_MASK, *size);\n\n\treturn ret;\n}\n\nstatic int wilc_spi_read_int(struct wilc *wilc, u32 *int_status)\n{\n\treturn spi_internal_read(wilc, WILC_SPI_INT_STATUS - WILC_SPI_REG_BASE,\n\t\t\t\t int_status);\n}\n\nstatic int wilc_spi_clear_int_ext(struct wilc *wilc, u32 val)\n{\n\tint ret;\n\tint retry = SPI_ENABLE_VMM_RETRY_LIMIT;\n\tu32 check;\n\n\twhile (retry) {\n\t\tret = spi_internal_write(wilc,\n\t\t\t\t\t WILC_SPI_INT_CLEAR - WILC_SPI_REG_BASE,\n\t\t\t\t\t val);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = spi_internal_read(wilc,\n\t\t\t\t\tWILC_SPI_INT_CLEAR - WILC_SPI_REG_BASE,\n\t\t\t\t\t&check);\n\t\tif (ret || ((check & EN_VMM) == (val & EN_VMM)))\n\t\t\tbreak;\n\n\t\tretry--;\n\t}\n\treturn ret;\n}\n\nstatic int wilc_spi_sync_ext(struct wilc *wilc, int nint)\n{\n\tstruct spi_device *spi = to_spi_device(wilc->dev);\n\tu32 reg;\n\tint ret, i;\n\n\tif (nint > MAX_NUM_INT) {\n\t\tdev_err(&spi->dev, \"Too many interrupts (%d)...\\n\", nint);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = wilc_spi_read_reg(wilc, WILC_PIN_MUX_0, &reg);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed read reg (%08x)...\\n\",\n\t\t\tWILC_PIN_MUX_0);\n\t\treturn ret;\n\t}\n\treg |= BIT(8);\n\tret = wilc_spi_write_reg(wilc, WILC_PIN_MUX_0, reg);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed write reg (%08x)...\\n\",\n\t\t\tWILC_PIN_MUX_0);\n\t\treturn ret;\n\t}\n\n\t \n\tret = wilc_spi_read_reg(wilc, WILC_INTR_ENABLE, &reg);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed read reg (%08x)...\\n\",\n\t\t\tWILC_INTR_ENABLE);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; (i < 5) && (nint > 0); i++, nint--)\n\t\treg |= (BIT((27 + i)));\n\n\tret = wilc_spi_write_reg(wilc, WILC_INTR_ENABLE, reg);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed write reg (%08x)...\\n\",\n\t\t\tWILC_INTR_ENABLE);\n\t\treturn ret;\n\t}\n\tif (nint) {\n\t\tret = wilc_spi_read_reg(wilc, WILC_INTR2_ENABLE, &reg);\n\t\tif (ret) {\n\t\t\tdev_err(&spi->dev, \"Failed read reg (%08x)...\\n\",\n\t\t\t\tWILC_INTR2_ENABLE);\n\t\t\treturn ret;\n\t\t}\n\n\t\tfor (i = 0; (i < 3) && (nint > 0); i++, nint--)\n\t\t\treg |= BIT(i);\n\n\t\tret = wilc_spi_write_reg(wilc, WILC_INTR2_ENABLE, reg);\n\t\tif (ret) {\n\t\t\tdev_err(&spi->dev, \"Failed write reg (%08x)...\\n\",\n\t\t\t\tWILC_INTR2_ENABLE);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic const struct wilc_hif_func wilc_hif_spi = {\n\t.hif_init = wilc_spi_init,\n\t.hif_deinit = wilc_spi_deinit,\n\t.hif_read_reg = wilc_spi_read_reg,\n\t.hif_write_reg = wilc_spi_write_reg,\n\t.hif_block_rx = wilc_spi_read,\n\t.hif_block_tx = wilc_spi_write,\n\t.hif_read_int = wilc_spi_read_int,\n\t.hif_clear_int_ext = wilc_spi_clear_int_ext,\n\t.hif_read_size = wilc_spi_read_size,\n\t.hif_block_tx_ext = wilc_spi_write,\n\t.hif_block_rx_ext = wilc_spi_read,\n\t.hif_sync_ext = wilc_spi_sync_ext,\n\t.hif_reset = wilc_spi_reset,\n\t.hif_is_init = wilc_spi_is_init,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}