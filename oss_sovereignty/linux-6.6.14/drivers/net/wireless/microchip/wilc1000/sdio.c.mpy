{
  "module_name": "sdio.c",
  "hash_id": "bb4f98ad303999e9298660fc0cee3389e020a45b26e3ca934d05a65f2d742d9b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/microchip/wilc1000/sdio.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/mmc/sdio_func.h>\n#include <linux/mmc/sdio_ids.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/sdio.h>\n#include <linux/of_irq.h>\n\n#include \"netdev.h\"\n#include \"cfg80211.h\"\n\n#define SDIO_MODALIAS \"wilc1000_sdio\"\n\nstatic const struct sdio_device_id wilc_sdio_ids[] = {\n\t{ SDIO_DEVICE(SDIO_VENDOR_ID_MICROCHIP_WILC, SDIO_DEVICE_ID_MICROCHIP_WILC1000) },\n\t{ },\n};\nMODULE_DEVICE_TABLE(sdio, wilc_sdio_ids);\n\n#define WILC_SDIO_BLOCK_SIZE 512\n\nstruct wilc_sdio {\n\tbool irq_gpio;\n\tu32 block_size;\n\tbool isinit;\n\tu8 *cmd53_buf;\n};\n\nstruct sdio_cmd52 {\n\tu32 read_write:\t\t1;\n\tu32 function:\t\t3;\n\tu32 raw:\t\t1;\n\tu32 address:\t\t17;\n\tu32 data:\t\t8;\n};\n\nstruct sdio_cmd53 {\n\tu32 read_write:\t\t1;\n\tu32 function:\t\t3;\n\tu32 block_mode:\t\t1;\n\tu32 increment:\t\t1;\n\tu32 address:\t\t17;\n\tu32 count:\t\t9;\n\tu8 *buffer;\n\tu32 block_size;\n\tbool use_global_buf;\n};\n\nstatic const struct wilc_hif_func wilc_hif_sdio;\n\nstatic void wilc_sdio_interrupt(struct sdio_func *func)\n{\n\tsdio_release_host(func);\n\twilc_handle_isr(sdio_get_drvdata(func));\n\tsdio_claim_host(func);\n}\n\nstatic int wilc_sdio_cmd52(struct wilc *wilc, struct sdio_cmd52 *cmd)\n{\n\tstruct sdio_func *func = container_of(wilc->dev, struct sdio_func, dev);\n\tint ret;\n\tu8 data;\n\n\tsdio_claim_host(func);\n\n\tfunc->num = cmd->function;\n\tif (cmd->read_write) {   \n\t\tif (cmd->raw) {\n\t\t\tsdio_writeb(func, cmd->data, cmd->address, &ret);\n\t\t\tdata = sdio_readb(func, cmd->address, &ret);\n\t\t\tcmd->data = data;\n\t\t} else {\n\t\t\tsdio_writeb(func, cmd->data, cmd->address, &ret);\n\t\t}\n\t} else {         \n\t\tdata = sdio_readb(func, cmd->address, &ret);\n\t\tcmd->data = data;\n\t}\n\n\tsdio_release_host(func);\n\n\tif (ret)\n\t\tdev_err(&func->dev, \"%s..failed, err(%d)\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int wilc_sdio_cmd53(struct wilc *wilc, struct sdio_cmd53 *cmd)\n{\n\tstruct sdio_func *func = container_of(wilc->dev, struct sdio_func, dev);\n\tint size, ret;\n\tstruct wilc_sdio *sdio_priv = wilc->bus_data;\n\tu8 *buf = cmd->buffer;\n\n\tsdio_claim_host(func);\n\n\tfunc->num = cmd->function;\n\tfunc->cur_blksize = cmd->block_size;\n\tif (cmd->block_mode)\n\t\tsize = cmd->count * cmd->block_size;\n\telse\n\t\tsize = cmd->count;\n\n\tif (cmd->use_global_buf) {\n\t\tif (size > sizeof(u32))\n\t\t\treturn -EINVAL;\n\n\t\tbuf = sdio_priv->cmd53_buf;\n\t}\n\n\tif (cmd->read_write) {   \n\t\tif (cmd->use_global_buf)\n\t\t\tmemcpy(buf, cmd->buffer, size);\n\n\t\tret = sdio_memcpy_toio(func, cmd->address, buf, size);\n\t} else {         \n\t\tret = sdio_memcpy_fromio(func, buf, cmd->address, size);\n\n\t\tif (cmd->use_global_buf)\n\t\t\tmemcpy(cmd->buffer, buf, size);\n\t}\n\n\tsdio_release_host(func);\n\n\tif (ret)\n\t\tdev_err(&func->dev, \"%s..failed, err(%d)\\n\", __func__,  ret);\n\n\treturn ret;\n}\n\nstatic int wilc_sdio_probe(struct sdio_func *func,\n\t\t\t   const struct sdio_device_id *id)\n{\n\tstruct wilc *wilc;\n\tint ret;\n\tstruct wilc_sdio *sdio_priv;\n\n\tsdio_priv = kzalloc(sizeof(*sdio_priv), GFP_KERNEL);\n\tif (!sdio_priv)\n\t\treturn -ENOMEM;\n\n\tsdio_priv->cmd53_buf = kzalloc(sizeof(u32), GFP_KERNEL);\n\tif (!sdio_priv->cmd53_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tret = wilc_cfg80211_init(&wilc, &func->dev, WILC_HIF_SDIO,\n\t\t\t\t &wilc_hif_sdio);\n\tif (ret)\n\t\tgoto free;\n\n\tif (IS_ENABLED(CONFIG_WILC1000_HW_OOB_INTR)) {\n\t\tstruct device_node *np = func->card->dev.of_node;\n\t\tint irq_num = of_irq_get(np, 0);\n\n\t\tif (irq_num > 0) {\n\t\t\twilc->dev_irq_num = irq_num;\n\t\t\tsdio_priv->irq_gpio = true;\n\t\t}\n\t}\n\n\tsdio_set_drvdata(func, wilc);\n\twilc->bus_data = sdio_priv;\n\twilc->dev = &func->dev;\n\n\twilc->rtc_clk = devm_clk_get_optional(&func->card->dev, \"rtc\");\n\tif (IS_ERR(wilc->rtc_clk)) {\n\t\tret = PTR_ERR(wilc->rtc_clk);\n\t\tgoto dispose_irq;\n\t}\n\tclk_prepare_enable(wilc->rtc_clk);\n\n\tdev_info(&func->dev, \"Driver Initializing success\\n\");\n\treturn 0;\n\ndispose_irq:\n\tirq_dispose_mapping(wilc->dev_irq_num);\n\twilc_netdev_cleanup(wilc);\nfree:\n\tkfree(sdio_priv->cmd53_buf);\n\tkfree(sdio_priv);\n\treturn ret;\n}\n\nstatic void wilc_sdio_remove(struct sdio_func *func)\n{\n\tstruct wilc *wilc = sdio_get_drvdata(func);\n\tstruct wilc_sdio *sdio_priv = wilc->bus_data;\n\n\tclk_disable_unprepare(wilc->rtc_clk);\n\twilc_netdev_cleanup(wilc);\n\tkfree(sdio_priv->cmd53_buf);\n\tkfree(sdio_priv);\n}\n\nstatic int wilc_sdio_reset(struct wilc *wilc)\n{\n\tstruct sdio_cmd52 cmd;\n\tint ret;\n\tstruct sdio_func *func = dev_to_sdio_func(wilc->dev);\n\n\tcmd.read_write = 1;\n\tcmd.function = 0;\n\tcmd.raw = 0;\n\tcmd.address = SDIO_CCCR_ABORT;\n\tcmd.data = WILC_SDIO_CCCR_ABORT_RESET;\n\tret = wilc_sdio_cmd52(wilc, &cmd);\n\tif (ret) {\n\t\tdev_err(&func->dev, \"Fail cmd 52, reset cmd ...\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic bool wilc_sdio_is_init(struct wilc *wilc)\n{\n\tstruct wilc_sdio *sdio_priv = wilc->bus_data;\n\n\treturn sdio_priv->isinit;\n}\n\nstatic int wilc_sdio_suspend(struct device *dev)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(dev);\n\tstruct wilc *wilc = sdio_get_drvdata(func);\n\tint ret;\n\n\tdev_info(dev, \"sdio suspend\\n\");\n\tchip_wakeup(wilc);\n\n\tif (!IS_ERR(wilc->rtc_clk))\n\t\tclk_disable_unprepare(wilc->rtc_clk);\n\n\tif (wilc->suspend_event) {\n\t\thost_sleep_notify(wilc);\n\t\tchip_allow_sleep(wilc);\n\t}\n\n\tret = wilc_sdio_reset(wilc);\n\tif (ret) {\n\t\tdev_err(&func->dev, \"Fail reset sdio\\n\");\n\t\treturn ret;\n\t}\n\tsdio_claim_host(func);\n\n\treturn 0;\n}\n\nstatic int wilc_sdio_enable_interrupt(struct wilc *dev)\n{\n\tstruct sdio_func *func = container_of(dev->dev, struct sdio_func, dev);\n\tint ret = 0;\n\n\tsdio_claim_host(func);\n\tret = sdio_claim_irq(func, wilc_sdio_interrupt);\n\tsdio_release_host(func);\n\n\tif (ret < 0) {\n\t\tdev_err(&func->dev, \"can't claim sdio_irq, err(%d)\\n\", ret);\n\t\tret = -EIO;\n\t}\n\treturn ret;\n}\n\nstatic void wilc_sdio_disable_interrupt(struct wilc *dev)\n{\n\tstruct sdio_func *func = container_of(dev->dev, struct sdio_func, dev);\n\tint ret;\n\n\tsdio_claim_host(func);\n\tret = sdio_release_irq(func);\n\tif (ret < 0)\n\t\tdev_err(&func->dev, \"can't release sdio_irq, err(%d)\\n\", ret);\n\tsdio_release_host(func);\n}\n\n \n\nstatic int wilc_sdio_set_func0_csa_address(struct wilc *wilc, u32 adr)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(wilc->dev);\n\tstruct sdio_cmd52 cmd;\n\tint ret;\n\n\t \n\tcmd.read_write = 1;\n\tcmd.function = 0;\n\tcmd.raw = 0;\n\tcmd.address = WILC_SDIO_FBR_CSA_REG;\n\tcmd.data = (u8)adr;\n\tret = wilc_sdio_cmd52(wilc, &cmd);\n\tif (ret) {\n\t\tdev_err(&func->dev, \"Failed cmd52, set %04x data...\\n\",\n\t\t\tcmd.address);\n\t\treturn ret;\n\t}\n\n\tcmd.address = WILC_SDIO_FBR_CSA_REG + 1;\n\tcmd.data = (u8)(adr >> 8);\n\tret = wilc_sdio_cmd52(wilc, &cmd);\n\tif (ret) {\n\t\tdev_err(&func->dev, \"Failed cmd52, set %04x data...\\n\",\n\t\t\tcmd.address);\n\t\treturn ret;\n\t}\n\n\tcmd.address = WILC_SDIO_FBR_CSA_REG + 2;\n\tcmd.data = (u8)(adr >> 16);\n\tret = wilc_sdio_cmd52(wilc, &cmd);\n\tif (ret) {\n\t\tdev_err(&func->dev, \"Failed cmd52, set %04x data...\\n\",\n\t\t\tcmd.address);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int wilc_sdio_set_block_size(struct wilc *wilc, u8 func_num,\n\t\t\t\t    u32 block_size)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(wilc->dev);\n\tstruct sdio_cmd52 cmd;\n\tint ret;\n\n\tcmd.read_write = 1;\n\tcmd.function = 0;\n\tcmd.raw = 0;\n\tcmd.address = SDIO_FBR_BASE(func_num) + SDIO_CCCR_BLKSIZE;\n\tcmd.data = (u8)block_size;\n\tret = wilc_sdio_cmd52(wilc, &cmd);\n\tif (ret) {\n\t\tdev_err(&func->dev, \"Failed cmd52, set %04x data...\\n\",\n\t\t\tcmd.address);\n\t\treturn ret;\n\t}\n\n\tcmd.address = SDIO_FBR_BASE(func_num) + SDIO_CCCR_BLKSIZE +  1;\n\tcmd.data = (u8)(block_size >> 8);\n\tret = wilc_sdio_cmd52(wilc, &cmd);\n\tif (ret) {\n\t\tdev_err(&func->dev, \"Failed cmd52, set %04x data...\\n\",\n\t\t\tcmd.address);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int wilc_sdio_write_reg(struct wilc *wilc, u32 addr, u32 data)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(wilc->dev);\n\tstruct wilc_sdio *sdio_priv = wilc->bus_data;\n\tint ret;\n\n\tcpu_to_le32s(&data);\n\n\tif (addr >= 0xf0 && addr <= 0xff) {  \n\t\tstruct sdio_cmd52 cmd;\n\n\t\tcmd.read_write = 1;\n\t\tcmd.function = 0;\n\t\tcmd.raw = 0;\n\t\tcmd.address = addr;\n\t\tcmd.data = data;\n\t\tret = wilc_sdio_cmd52(wilc, &cmd);\n\t\tif (ret)\n\t\t\tdev_err(&func->dev,\n\t\t\t\t\"Failed cmd 52, read reg (%08x) ...\\n\", addr);\n\t} else {\n\t\tstruct sdio_cmd53 cmd;\n\n\t\t \n\t\tret = wilc_sdio_set_func0_csa_address(wilc, addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcmd.read_write = 1;\n\t\tcmd.function = 0;\n\t\tcmd.address = WILC_SDIO_FBR_DATA_REG;\n\t\tcmd.block_mode = 0;\n\t\tcmd.increment = 1;\n\t\tcmd.count = sizeof(u32);\n\t\tcmd.buffer = (u8 *)&data;\n\t\tcmd.use_global_buf = true;\n\t\tcmd.block_size = sdio_priv->block_size;\n\t\tret = wilc_sdio_cmd53(wilc, &cmd);\n\t\tif (ret)\n\t\t\tdev_err(&func->dev,\n\t\t\t\t\"Failed cmd53, write reg (%08x)...\\n\", addr);\n\t}\n\n\treturn ret;\n}\n\nstatic int wilc_sdio_write(struct wilc *wilc, u32 addr, u8 *buf, u32 size)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(wilc->dev);\n\tstruct wilc_sdio *sdio_priv = wilc->bus_data;\n\tu32 block_size = sdio_priv->block_size;\n\tstruct sdio_cmd53 cmd;\n\tint nblk, nleft, ret;\n\n\tcmd.read_write = 1;\n\tif (addr > 0) {\n\t\t \n\t\tcmd.function = 0;\n\t\tcmd.address = WILC_SDIO_FBR_DATA_REG;\n\t} else {\n\t\t \n\t\tcmd.function = 1;\n\t\tcmd.address = WILC_SDIO_F1_DATA_REG;\n\t}\n\n\tsize = ALIGN(size, 4);\n\tnblk = size / block_size;\n\tnleft = size % block_size;\n\n\tcmd.use_global_buf = false;\n\tif (nblk > 0) {\n\t\tcmd.block_mode = 1;\n\t\tcmd.increment = 1;\n\t\tcmd.count = nblk;\n\t\tcmd.buffer = buf;\n\t\tcmd.block_size = block_size;\n\t\tif (addr > 0) {\n\t\t\tret = wilc_sdio_set_func0_csa_address(wilc, addr);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tret = wilc_sdio_cmd53(wilc, &cmd);\n\t\tif (ret) {\n\t\t\tdev_err(&func->dev,\n\t\t\t\t\"Failed cmd53 [%x], block send...\\n\", addr);\n\t\t\treturn ret;\n\t\t}\n\t\tif (addr > 0)\n\t\t\taddr += nblk * block_size;\n\t\tbuf += nblk * block_size;\n\t}\n\n\tif (nleft > 0) {\n\t\tcmd.block_mode = 0;\n\t\tcmd.increment = 1;\n\t\tcmd.count = nleft;\n\t\tcmd.buffer = buf;\n\n\t\tcmd.block_size = block_size;\n\n\t\tif (addr > 0) {\n\t\t\tret = wilc_sdio_set_func0_csa_address(wilc, addr);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tret = wilc_sdio_cmd53(wilc, &cmd);\n\t\tif (ret) {\n\t\t\tdev_err(&func->dev,\n\t\t\t\t\"Failed cmd53 [%x], bytes send...\\n\", addr);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int wilc_sdio_read_reg(struct wilc *wilc, u32 addr, u32 *data)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(wilc->dev);\n\tstruct wilc_sdio *sdio_priv = wilc->bus_data;\n\tint ret;\n\n\tif (addr >= 0xf0 && addr <= 0xff) {  \n\t\tstruct sdio_cmd52 cmd;\n\n\t\tcmd.read_write = 0;\n\t\tcmd.function = 0;\n\t\tcmd.raw = 0;\n\t\tcmd.address = addr;\n\t\tret = wilc_sdio_cmd52(wilc, &cmd);\n\t\tif (ret) {\n\t\t\tdev_err(&func->dev,\n\t\t\t\t\"Failed cmd 52, read reg (%08x) ...\\n\", addr);\n\t\t\treturn ret;\n\t\t}\n\t\t*data = cmd.data;\n\t} else {\n\t\tstruct sdio_cmd53 cmd;\n\n\t\tret = wilc_sdio_set_func0_csa_address(wilc, addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcmd.read_write = 0;\n\t\tcmd.function = 0;\n\t\tcmd.address = WILC_SDIO_FBR_DATA_REG;\n\t\tcmd.block_mode = 0;\n\t\tcmd.increment = 1;\n\t\tcmd.count = sizeof(u32);\n\t\tcmd.buffer = (u8 *)data;\n\t\tcmd.use_global_buf = true;\n\n\t\tcmd.block_size = sdio_priv->block_size;\n\t\tret = wilc_sdio_cmd53(wilc, &cmd);\n\t\tif (ret) {\n\t\t\tdev_err(&func->dev,\n\t\t\t\t\"Failed cmd53, read reg (%08x)...\\n\", addr);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tle32_to_cpus(data);\n\treturn 0;\n}\n\nstatic int wilc_sdio_read(struct wilc *wilc, u32 addr, u8 *buf, u32 size)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(wilc->dev);\n\tstruct wilc_sdio *sdio_priv = wilc->bus_data;\n\tu32 block_size = sdio_priv->block_size;\n\tstruct sdio_cmd53 cmd;\n\tint nblk, nleft, ret;\n\n\tcmd.read_write = 0;\n\tif (addr > 0) {\n\t\t \n\t\tcmd.function = 0;\n\t\tcmd.address = WILC_SDIO_FBR_DATA_REG;\n\t} else {\n\t\t \n\t\tcmd.function = 1;\n\t\tcmd.address = WILC_SDIO_F1_DATA_REG;\n\t}\n\n\tsize = ALIGN(size, 4);\n\tnblk = size / block_size;\n\tnleft = size % block_size;\n\n\tcmd.use_global_buf = false;\n\tif (nblk > 0) {\n\t\tcmd.block_mode = 1;\n\t\tcmd.increment = 1;\n\t\tcmd.count = nblk;\n\t\tcmd.buffer = buf;\n\t\tcmd.block_size = block_size;\n\t\tif (addr > 0) {\n\t\t\tret = wilc_sdio_set_func0_csa_address(wilc, addr);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tret = wilc_sdio_cmd53(wilc, &cmd);\n\t\tif (ret) {\n\t\t\tdev_err(&func->dev,\n\t\t\t\t\"Failed cmd53 [%x], block read...\\n\", addr);\n\t\t\treturn ret;\n\t\t}\n\t\tif (addr > 0)\n\t\t\taddr += nblk * block_size;\n\t\tbuf += nblk * block_size;\n\t}        \n\n\tif (nleft > 0) {\n\t\tcmd.block_mode = 0;\n\t\tcmd.increment = 1;\n\t\tcmd.count = nleft;\n\t\tcmd.buffer = buf;\n\n\t\tcmd.block_size = block_size;\n\n\t\tif (addr > 0) {\n\t\t\tret = wilc_sdio_set_func0_csa_address(wilc, addr);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tret = wilc_sdio_cmd53(wilc, &cmd);\n\t\tif (ret) {\n\t\t\tdev_err(&func->dev,\n\t\t\t\t\"Failed cmd53 [%x], bytes read...\\n\", addr);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int wilc_sdio_deinit(struct wilc *wilc)\n{\n\tstruct wilc_sdio *sdio_priv = wilc->bus_data;\n\n\tsdio_priv->isinit = false;\n\treturn 0;\n}\n\nstatic int wilc_sdio_init(struct wilc *wilc, bool resume)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(wilc->dev);\n\tstruct wilc_sdio *sdio_priv = wilc->bus_data;\n\tstruct sdio_cmd52 cmd;\n\tint loop, ret;\n\tu32 chipid;\n\n\t \n\tcmd.read_write = 1;\n\tcmd.function = 0;\n\tcmd.raw = 1;\n\tcmd.address = SDIO_FBR_BASE(1);\n\tcmd.data = SDIO_FBR_ENABLE_CSA;\n\tret = wilc_sdio_cmd52(wilc, &cmd);\n\tif (ret) {\n\t\tdev_err(&func->dev, \"Fail cmd 52, enable csa...\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = wilc_sdio_set_block_size(wilc, 0, WILC_SDIO_BLOCK_SIZE);\n\tif (ret) {\n\t\tdev_err(&func->dev, \"Fail cmd 52, set func 0 block size...\\n\");\n\t\treturn ret;\n\t}\n\tsdio_priv->block_size = WILC_SDIO_BLOCK_SIZE;\n\n\t \n\tcmd.read_write = 1;\n\tcmd.function = 0;\n\tcmd.raw = 1;\n\tcmd.address = SDIO_CCCR_IOEx;\n\tcmd.data = WILC_SDIO_CCCR_IO_EN_FUNC1;\n\tret = wilc_sdio_cmd52(wilc, &cmd);\n\tif (ret) {\n\t\tdev_err(&func->dev,\n\t\t\t\"Fail cmd 52, set IOE register...\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tcmd.read_write = 0;\n\tcmd.function = 0;\n\tcmd.raw = 0;\n\tcmd.address = SDIO_CCCR_IORx;\n\tloop = 3;\n\tdo {\n\t\tcmd.data = 0;\n\t\tret = wilc_sdio_cmd52(wilc, &cmd);\n\t\tif (ret) {\n\t\t\tdev_err(&func->dev,\n\t\t\t\t\"Fail cmd 52, get IOR register...\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tif (cmd.data == WILC_SDIO_CCCR_IO_EN_FUNC1)\n\t\t\tbreak;\n\t} while (loop--);\n\n\tif (loop <= 0) {\n\t\tdev_err(&func->dev, \"Fail func 1 is not ready...\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = wilc_sdio_set_block_size(wilc, 1, WILC_SDIO_BLOCK_SIZE);\n\tif (ret) {\n\t\tdev_err(&func->dev, \"Fail set func 1 block size...\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tcmd.read_write = 1;\n\tcmd.function = 0;\n\tcmd.raw = 1;\n\tcmd.address = SDIO_CCCR_IENx;\n\tcmd.data = WILC_SDIO_CCCR_IEN_MASTER | WILC_SDIO_CCCR_IEN_FUNC1;\n\tret = wilc_sdio_cmd52(wilc, &cmd);\n\tif (ret) {\n\t\tdev_err(&func->dev, \"Fail cmd 52, set IEN register...\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (!resume) {\n\t\tret = wilc_sdio_read_reg(wilc, WILC_CHIPID, &chipid);\n\t\tif (ret) {\n\t\t\tdev_err(&func->dev, \"Fail cmd read chip id...\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tdev_err(&func->dev, \"chipid (%08x)\\n\", chipid);\n\t}\n\n\tsdio_priv->isinit = true;\n\treturn 0;\n}\n\nstatic int wilc_sdio_read_size(struct wilc *wilc, u32 *size)\n{\n\tu32 tmp;\n\tstruct sdio_cmd52 cmd;\n\n\t \n\tcmd.read_write = 0;\n\tcmd.function = 0;\n\tcmd.raw = 0;\n\tcmd.address = WILC_SDIO_INTERRUPT_DATA_SZ_REG;\n\tcmd.data = 0;\n\twilc_sdio_cmd52(wilc, &cmd);\n\ttmp = cmd.data;\n\n\tcmd.address = WILC_SDIO_INTERRUPT_DATA_SZ_REG + 1;\n\tcmd.data = 0;\n\twilc_sdio_cmd52(wilc, &cmd);\n\ttmp |= (cmd.data << 8);\n\n\t*size = tmp;\n\treturn 0;\n}\n\nstatic int wilc_sdio_read_int(struct wilc *wilc, u32 *int_status)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(wilc->dev);\n\tstruct wilc_sdio *sdio_priv = wilc->bus_data;\n\tu32 tmp;\n\tu8 irq_flags;\n\tstruct sdio_cmd52 cmd;\n\n\twilc_sdio_read_size(wilc, &tmp);\n\n\t \n\tif (!sdio_priv->irq_gpio) {\n\t\tcmd.function = 1;\n\t\tcmd.address = WILC_SDIO_EXT_IRQ_FLAG_REG;\n\t} else {\n\t\tcmd.function = 0;\n\t\tcmd.address = WILC_SDIO_IRQ_FLAG_REG;\n\t}\n\tcmd.raw = 0;\n\tcmd.read_write = 0;\n\tcmd.data = 0;\n\twilc_sdio_cmd52(wilc, &cmd);\n\tirq_flags = cmd.data;\n\ttmp |= FIELD_PREP(IRG_FLAGS_MASK, cmd.data);\n\n\tif (FIELD_GET(UNHANDLED_IRQ_MASK, irq_flags))\n\t\tdev_err(&func->dev, \"Unexpected interrupt (1) int=%lx\\n\",\n\t\t\tFIELD_GET(UNHANDLED_IRQ_MASK, irq_flags));\n\n\t*int_status = tmp;\n\n\treturn 0;\n}\n\nstatic int wilc_sdio_clear_int_ext(struct wilc *wilc, u32 val)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(wilc->dev);\n\tstruct wilc_sdio *sdio_priv = wilc->bus_data;\n\tint ret;\n\tu32 reg = 0;\n\n\tif (sdio_priv->irq_gpio)\n\t\treg = val & (BIT(MAX_NUM_INT) - 1);\n\n\t \n\tif (val & SEL_VMM_TBL0)\n\t\treg |= BIT(5);\n\t \n\tif (val & SEL_VMM_TBL1)\n\t\treg |= BIT(6);\n\t \n\tif (val & EN_VMM)\n\t\treg |= BIT(7);\n\tif (reg) {\n\t\tstruct sdio_cmd52 cmd;\n\n\t\tcmd.read_write = 1;\n\t\tcmd.function = 0;\n\t\tcmd.raw = 0;\n\t\tcmd.address = WILC_SDIO_IRQ_CLEAR_FLAG_REG;\n\t\tcmd.data = reg;\n\n\t\tret = wilc_sdio_cmd52(wilc, &cmd);\n\t\tif (ret) {\n\t\t\tdev_err(&func->dev,\n\t\t\t\t\"Failed cmd52, set (%02x) data (%d) ...\\n\",\n\t\t\t\tcmd.address, __LINE__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int wilc_sdio_sync_ext(struct wilc *wilc, int nint)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(wilc->dev);\n\tstruct wilc_sdio *sdio_priv = wilc->bus_data;\n\tu32 reg;\n\n\tif (nint > MAX_NUM_INT) {\n\t\tdev_err(&func->dev, \"Too many interrupts (%d)...\\n\", nint);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (wilc_sdio_read_reg(wilc, WILC_MISC, &reg)) {\n\t\tdev_err(&func->dev, \"Failed read misc reg...\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treg &= ~BIT(8);\n\tif (wilc_sdio_write_reg(wilc, WILC_MISC, reg)) {\n\t\tdev_err(&func->dev, \"Failed write misc reg...\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sdio_priv->irq_gpio) {\n\t\tu32 reg;\n\t\tint ret, i;\n\n\t\t \n\t\tret = wilc_sdio_read_reg(wilc, WILC_PIN_MUX_0, &reg);\n\t\tif (ret) {\n\t\t\tdev_err(&func->dev, \"Failed read reg (%08x)...\\n\",\n\t\t\t\tWILC_PIN_MUX_0);\n\t\t\treturn ret;\n\t\t}\n\t\treg |= BIT(8);\n\t\tret = wilc_sdio_write_reg(wilc, WILC_PIN_MUX_0, reg);\n\t\tif (ret) {\n\t\t\tdev_err(&func->dev, \"Failed write reg (%08x)...\\n\",\n\t\t\t\tWILC_PIN_MUX_0);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = wilc_sdio_read_reg(wilc, WILC_INTR_ENABLE, &reg);\n\t\tif (ret) {\n\t\t\tdev_err(&func->dev, \"Failed read reg (%08x)...\\n\",\n\t\t\t\tWILC_INTR_ENABLE);\n\t\t\treturn ret;\n\t\t}\n\n\t\tfor (i = 0; (i < 5) && (nint > 0); i++, nint--)\n\t\t\treg |= BIT((27 + i));\n\t\tret = wilc_sdio_write_reg(wilc, WILC_INTR_ENABLE, reg);\n\t\tif (ret) {\n\t\t\tdev_err(&func->dev, \"Failed write reg (%08x)...\\n\",\n\t\t\t\tWILC_INTR_ENABLE);\n\t\t\treturn ret;\n\t\t}\n\t\tif (nint) {\n\t\t\tret = wilc_sdio_read_reg(wilc, WILC_INTR2_ENABLE, &reg);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&func->dev,\n\t\t\t\t\t\"Failed read reg (%08x)...\\n\",\n\t\t\t\t\tWILC_INTR2_ENABLE);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tfor (i = 0; (i < 3) && (nint > 0); i++, nint--)\n\t\t\t\treg |= BIT(i);\n\n\t\t\tret = wilc_sdio_write_reg(wilc, WILC_INTR2_ENABLE, reg);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&func->dev,\n\t\t\t\t\t\"Failed write reg (%08x)...\\n\",\n\t\t\t\t\tWILC_INTR2_ENABLE);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic const struct wilc_hif_func wilc_hif_sdio = {\n\t.hif_init = wilc_sdio_init,\n\t.hif_deinit = wilc_sdio_deinit,\n\t.hif_read_reg = wilc_sdio_read_reg,\n\t.hif_write_reg = wilc_sdio_write_reg,\n\t.hif_block_rx = wilc_sdio_read,\n\t.hif_block_tx = wilc_sdio_write,\n\t.hif_read_int = wilc_sdio_read_int,\n\t.hif_clear_int_ext = wilc_sdio_clear_int_ext,\n\t.hif_read_size = wilc_sdio_read_size,\n\t.hif_block_tx_ext = wilc_sdio_write,\n\t.hif_block_rx_ext = wilc_sdio_read,\n\t.hif_sync_ext = wilc_sdio_sync_ext,\n\t.enable_interrupt = wilc_sdio_enable_interrupt,\n\t.disable_interrupt = wilc_sdio_disable_interrupt,\n\t.hif_reset = wilc_sdio_reset,\n\t.hif_is_init = wilc_sdio_is_init,\n};\n\nstatic int wilc_sdio_resume(struct device *dev)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(dev);\n\tstruct wilc *wilc = sdio_get_drvdata(func);\n\n\tdev_info(dev, \"sdio resume\\n\");\n\tsdio_release_host(func);\n\tchip_wakeup(wilc);\n\twilc_sdio_init(wilc, true);\n\n\tif (wilc->suspend_event)\n\t\thost_wakeup_notify(wilc);\n\n\tchip_allow_sleep(wilc);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id wilc_of_match[] = {\n\t{ .compatible = \"microchip,wilc1000\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, wilc_of_match);\n\nstatic const struct dev_pm_ops wilc_sdio_pm_ops = {\n\t.suspend = wilc_sdio_suspend,\n\t.resume = wilc_sdio_resume,\n};\n\nstatic struct sdio_driver wilc_sdio_driver = {\n\t.name\t\t= SDIO_MODALIAS,\n\t.id_table\t= wilc_sdio_ids,\n\t.probe\t\t= wilc_sdio_probe,\n\t.remove\t\t= wilc_sdio_remove,\n\t.drv = {\n\t\t.pm = &wilc_sdio_pm_ops,\n\t\t.of_match_table = wilc_of_match,\n\t}\n};\nmodule_driver(wilc_sdio_driver,\n\t      sdio_register_driver,\n\t      sdio_unregister_driver);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}