{
  "module_name": "rsi_91x_coex.c",
  "hash_id": "9478d6acce9d7ee9f0847396a3dd624ff7ffd5eeed34047909f287ccdbeb7a6d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/rsi/rsi_91x_coex.c",
  "human_readable_source": " \n\n#include \"rsi_main.h\"\n#include \"rsi_coex.h\"\n#include \"rsi_mgmt.h\"\n#include \"rsi_hal.h\"\n\nstatic enum rsi_coex_queues rsi_coex_determine_coex_q\n\t\t\t(struct rsi_coex_ctrl_block *coex_cb)\n{\n\tenum rsi_coex_queues q_num = RSI_COEX_Q_INVALID;\n\n\tif (skb_queue_len(&coex_cb->coex_tx_qs[RSI_COEX_Q_COMMON]) > 0)\n\t\tq_num = RSI_COEX_Q_COMMON;\n\tif (skb_queue_len(&coex_cb->coex_tx_qs[RSI_COEX_Q_BT]) > 0)\n\t\tq_num = RSI_COEX_Q_BT;\n\tif (skb_queue_len(&coex_cb->coex_tx_qs[RSI_COEX_Q_WLAN]) > 0)\n\t\tq_num = RSI_COEX_Q_WLAN;\n\n\treturn q_num;\n}\n\nstatic void rsi_coex_sched_tx_pkts(struct rsi_coex_ctrl_block *coex_cb)\n{\n\tenum rsi_coex_queues coex_q = RSI_COEX_Q_INVALID;\n\tstruct sk_buff *skb;\n\n\tdo {\n\t\tcoex_q = rsi_coex_determine_coex_q(coex_cb);\n\t\trsi_dbg(INFO_ZONE, \"queue = %d\\n\", coex_q);\n\n\t\tif (coex_q == RSI_COEX_Q_BT) {\n\t\t\tskb = skb_dequeue(&coex_cb->coex_tx_qs[RSI_COEX_Q_BT]);\n\t\t\trsi_send_bt_pkt(coex_cb->priv, skb);\n\t\t}\n\t} while (coex_q != RSI_COEX_Q_INVALID);\n}\n\nstatic void rsi_coex_scheduler_thread(struct rsi_common *common)\n{\n\tstruct rsi_coex_ctrl_block *coex_cb = common->coex_cb;\n\tu32 timeout = EVENT_WAIT_FOREVER;\n\n\tdo {\n\t\trsi_wait_event(&coex_cb->coex_tx_thread.event, timeout);\n\t\trsi_reset_event(&coex_cb->coex_tx_thread.event);\n\n\t\trsi_coex_sched_tx_pkts(coex_cb);\n\t} while (atomic_read(&coex_cb->coex_tx_thread.thread_done) == 0);\n\n\tkthread_complete_and_exit(&coex_cb->coex_tx_thread.completion, 0);\n}\n\nint rsi_coex_recv_pkt(struct rsi_common *common, u8 *msg)\n{\n\tu8 msg_type = msg[RSI_RX_DESC_MSG_TYPE_OFFSET];\n\n\tswitch (msg_type) {\n\tcase COMMON_CARD_READY_IND:\n\t\trsi_dbg(INFO_ZONE, \"common card ready received\\n\");\n\t\tcommon->hibernate_resume = false;\n\t\trsi_handle_card_ready(common, msg);\n\t\tbreak;\n\tcase SLEEP_NOTIFY_IND:\n\t\trsi_dbg(INFO_ZONE, \"sleep notify received\\n\");\n\t\trsi_mgmt_pkt_recv(common, msg);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int rsi_map_coex_q(u8 hal_queue)\n{\n\tswitch (hal_queue) {\n\tcase RSI_COEX_Q:\n\t\treturn RSI_COEX_Q_COMMON;\n\tcase RSI_WLAN_Q:\n\t\treturn RSI_COEX_Q_WLAN;\n\tcase RSI_BT_Q:\n\t\treturn RSI_COEX_Q_BT;\n\t}\n\treturn RSI_COEX_Q_INVALID;\n}\n\nint rsi_coex_send_pkt(void *priv, struct sk_buff *skb, u8 hal_queue)\n{\n\tstruct rsi_common *common = priv;\n\tstruct rsi_coex_ctrl_block *coex_cb = common->coex_cb;\n\tstruct skb_info *tx_params = NULL;\n\tenum rsi_coex_queues coex_q;\n\tint status;\n\n\tcoex_q = rsi_map_coex_q(hal_queue);\n\tif (coex_q == RSI_COEX_Q_INVALID) {\n\t\trsi_dbg(ERR_ZONE, \"Invalid coex queue\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (coex_q != RSI_COEX_Q_COMMON &&\n\t    coex_q != RSI_COEX_Q_WLAN) {\n\t\tskb_queue_tail(&coex_cb->coex_tx_qs[coex_q], skb);\n\t\trsi_set_event(&coex_cb->coex_tx_thread.event);\n\t\treturn 0;\n\t}\n\tif (common->iface_down) {\n\t\ttx_params =\n\t\t\t(struct skb_info *)&IEEE80211_SKB_CB(skb)->driver_data;\n\n\t\tif (!(tx_params->flags & INTERNAL_MGMT_PKT)) {\n\t\t\trsi_indicate_tx_status(common->priv, skb, -EINVAL);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tif (skb->priority == MGMT_SOFT_Q)\n\t\tstatus = rsi_send_mgmt_pkt(common, skb);\n\telse\n\t\tstatus = rsi_send_data_pkt(common, skb);\n\n\treturn status;\n}\n\nint rsi_coex_attach(struct rsi_common *common)\n{\n\tstruct rsi_coex_ctrl_block *coex_cb;\n\tint cnt;\n\n\tcoex_cb = kzalloc(sizeof(*coex_cb), GFP_KERNEL);\n\tif (!coex_cb)\n\t\treturn -ENOMEM;\n\n\tcommon->coex_cb = (void *)coex_cb;\n\tcoex_cb->priv = common;\n\n\t \n\tfor (cnt = 0; cnt < NUM_COEX_TX_QUEUES; cnt++)\n\t\tskb_queue_head_init(&coex_cb->coex_tx_qs[cnt]);\n\trsi_init_event(&coex_cb->coex_tx_thread.event);\n\n\t \n\tif (rsi_create_kthread(common,\n\t\t\t       &coex_cb->coex_tx_thread,\n\t\t\t       rsi_coex_scheduler_thread,\n\t\t\t       \"Coex-Tx-Thread\")) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Unable to init tx thrd\\n\", __func__);\n\t\tkfree(coex_cb);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nvoid rsi_coex_detach(struct rsi_common *common)\n{\n\tstruct rsi_coex_ctrl_block *coex_cb = common->coex_cb;\n\tint cnt;\n\n\trsi_kill_thread(&coex_cb->coex_tx_thread);\n\n\tfor (cnt = 0; cnt < NUM_COEX_TX_QUEUES; cnt++)\n\t\tskb_queue_purge(&coex_cb->coex_tx_qs[cnt]);\n\n\tkfree(coex_cb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}