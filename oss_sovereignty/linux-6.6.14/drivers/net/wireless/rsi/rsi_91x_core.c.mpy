{
  "module_name": "rsi_91x_core.c",
  "hash_id": "d9f2dbf7d502074504b04450f62801292a250c90214664ce380f7bf822fee1e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/rsi/rsi_91x_core.c",
  "human_readable_source": " \n\n#include \"rsi_mgmt.h\"\n#include \"rsi_common.h\"\n#include \"rsi_hal.h\"\n#include \"rsi_coex.h\"\n\n \nstatic u8 rsi_determine_min_weight_queue(struct rsi_common *common)\n{\n\tstruct wmm_qinfo *tx_qinfo = common->tx_qinfo;\n\tu32 q_len = 0;\n\tu8 ii = 0;\n\n\tfor (ii = 0; ii < NUM_EDCA_QUEUES; ii++) {\n\t\tq_len = skb_queue_len(&common->tx_queue[ii]);\n\t\tif ((tx_qinfo[ii].pkt_contended) && q_len) {\n\t\t\tcommon->min_weight = tx_qinfo[ii].weight;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ii;\n}\n\n \nstatic bool rsi_recalculate_weights(struct rsi_common *common)\n{\n\tstruct wmm_qinfo *tx_qinfo = common->tx_qinfo;\n\tbool recontend_queue = false;\n\tu8 ii = 0;\n\tu32 q_len = 0;\n\n\tfor (ii = 0; ii < NUM_EDCA_QUEUES; ii++) {\n\t\tq_len = skb_queue_len(&common->tx_queue[ii]);\n\t\t \n\t\tif (q_len) {\n\t\t\tif (tx_qinfo[ii].pkt_contended) {\n\t\t\t\ttx_qinfo[ii].weight =\n\t\t\t\t((tx_qinfo[ii].weight > common->min_weight) ?\n\t\t\t\t tx_qinfo[ii].weight - common->min_weight : 0);\n\t\t\t} else {\n\t\t\t\ttx_qinfo[ii].pkt_contended = 1;\n\t\t\t\ttx_qinfo[ii].weight = tx_qinfo[ii].wme_params;\n\t\t\t\trecontend_queue = true;\n\t\t\t}\n\t\t} else {  \n\t\t\ttx_qinfo[ii].weight = 0;\n\t\t\ttx_qinfo[ii].pkt_contended = 0;\n\t\t}\n\t}\n\n\treturn recontend_queue;\n}\n\n \nstatic u32 rsi_get_num_pkts_dequeue(struct rsi_common *common, u8 q_num)\n{\n\tstruct rsi_hw *adapter = common->priv;\n\tstruct sk_buff *skb;\n\tu32 pkt_cnt = 0;\n\ts16 txop = common->tx_qinfo[q_num].txop * 32;\n\t__le16 r_txop;\n\tstruct ieee80211_rate rate;\n\tstruct ieee80211_hdr *wh;\n\tstruct ieee80211_vif *vif;\n\n\trate.bitrate = RSI_RATE_MCS0 * 5 * 10;  \n\tif (q_num == VI_Q)\n\t\ttxop = ((txop << 5) / 80);\n\n\tif (skb_queue_len(&common->tx_queue[q_num]))\n\t\tskb = skb_peek(&common->tx_queue[q_num]);\n\telse\n\t\treturn 0;\n\n\tdo {\n\t\twh = (struct ieee80211_hdr *)skb->data;\n\t\tvif = rsi_get_vif(adapter, wh->addr2);\n\t\tr_txop = ieee80211_generic_frame_duration(adapter->hw,\n\t\t\t\t\t\t\t  vif,\n\t\t\t\t\t\t\t  common->band,\n\t\t\t\t\t\t\t  skb->len, &rate);\n\t\ttxop -= le16_to_cpu(r_txop);\n\t\tpkt_cnt += 1;\n\t\t \n\t\tif (skb_queue_len(&common->tx_queue[q_num]) - pkt_cnt)\n\t\t\tskb = skb->next;\n\t\telse\n\t\t\tbreak;\n\n\t} while (txop > 0);\n\n\treturn pkt_cnt;\n}\n\n \nstatic u8 rsi_core_determine_hal_queue(struct rsi_common *common)\n{\n\tbool recontend_queue = false;\n\tu32 q_len = 0;\n\tu8 q_num = INVALID_QUEUE;\n\tu8 ii = 0;\n\n\tif (skb_queue_len(&common->tx_queue[MGMT_BEACON_Q])) {\n\t\tq_num = MGMT_BEACON_Q;\n\t\treturn q_num;\n\t}\n\tif (skb_queue_len(&common->tx_queue[MGMT_SOFT_Q])) {\n\t\tif (!common->mgmt_q_block)\n\t\t\tq_num = MGMT_SOFT_Q;\n\t\treturn q_num;\n\t}\n\n\tif (common->hw_data_qs_blocked)\n\t\treturn q_num;\n\n\tif (common->pkt_cnt != 0) {\n\t\t--common->pkt_cnt;\n\t\treturn common->selected_qnum;\n\t}\n\nget_queue_num:\n\trecontend_queue = false;\n\n\tq_num = rsi_determine_min_weight_queue(common);\n\n\tii = q_num;\n\n\t \n\tfor (; ii < NUM_EDCA_QUEUES; ii++) {\n\t\tq_len = skb_queue_len(&common->tx_queue[ii]);\n\t\tif (((common->tx_qinfo[ii].pkt_contended) &&\n\t\t     (common->tx_qinfo[ii].weight < common->min_weight)) &&\n\t\t      q_len) {\n\t\t\tcommon->min_weight = common->tx_qinfo[ii].weight;\n\t\t\tq_num = ii;\n\t\t}\n\t}\n\n\tif (q_num < NUM_EDCA_QUEUES)\n\t\tcommon->tx_qinfo[q_num].pkt_contended = 0;\n\n\t \n\trecontend_queue = rsi_recalculate_weights(common);\n\n\tq_len = skb_queue_len(&common->tx_queue[q_num]);\n\tif (!q_len) {\n\t\t \n\t\tif (recontend_queue)\n\t\t\tgoto get_queue_num;\n\n\t\treturn INVALID_QUEUE;\n\t}\n\n\tcommon->selected_qnum = q_num;\n\tq_len = skb_queue_len(&common->tx_queue[q_num]);\n\n\tif (q_num == VO_Q || q_num == VI_Q) {\n\t\tcommon->pkt_cnt = rsi_get_num_pkts_dequeue(common, q_num);\n\t\tcommon->pkt_cnt -= 1;\n\t}\n\n\treturn q_num;\n}\n\n \nstatic void rsi_core_queue_pkt(struct rsi_common *common,\n\t\t\t       struct sk_buff *skb)\n{\n\tu8 q_num = skb->priority;\n\tif (q_num >= NUM_SOFT_QUEUES) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Invalid Queue Number: q_num = %d\\n\",\n\t\t\t__func__, q_num);\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n\tskb_queue_tail(&common->tx_queue[q_num], skb);\n}\n\n \nstatic struct sk_buff *rsi_core_dequeue_pkt(struct rsi_common *common,\n\t\t\t\t\t    u8 q_num)\n{\n\tif (q_num >= NUM_SOFT_QUEUES) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Invalid Queue Number: q_num = %d\\n\",\n\t\t\t__func__, q_num);\n\t\treturn NULL;\n\t}\n\n\treturn skb_dequeue(&common->tx_queue[q_num]);\n}\n\n \nvoid rsi_core_qos_processor(struct rsi_common *common)\n{\n\tstruct rsi_hw *adapter = common->priv;\n\tstruct sk_buff *skb;\n\tunsigned long tstamp_1, tstamp_2;\n\tu8 q_num;\n\tint status;\n\n\ttstamp_1 = jiffies;\n\twhile (1) {\n\t\tq_num = rsi_core_determine_hal_queue(common);\n\t\trsi_dbg(DATA_TX_ZONE,\n\t\t\t\"%s: Queue number = %d\\n\", __func__, q_num);\n\n\t\tif (q_num == INVALID_QUEUE) {\n\t\t\trsi_dbg(DATA_TX_ZONE, \"%s: No More Pkt\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tif (common->hibernate_resume)\n\t\t\tbreak;\n\n\t\tmutex_lock(&common->tx_lock);\n\n\t\tstatus = adapter->check_hw_queue_status(adapter, q_num);\n\t\tif ((status <= 0)) {\n\t\t\tmutex_unlock(&common->tx_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((q_num < MGMT_SOFT_Q) &&\n\t\t    ((skb_queue_len(&common->tx_queue[q_num])) <=\n\t\t      MIN_DATA_QUEUE_WATER_MARK)) {\n\t\t\tif (ieee80211_queue_stopped(adapter->hw, WME_AC(q_num)))\n\t\t\t\tieee80211_wake_queue(adapter->hw,\n\t\t\t\t\t\t     WME_AC(q_num));\n\t\t}\n\n\t\tskb = rsi_core_dequeue_pkt(common, q_num);\n\t\tif (skb == NULL) {\n\t\t\trsi_dbg(ERR_ZONE, \"skb null\\n\");\n\t\t\tmutex_unlock(&common->tx_lock);\n\t\t\tbreak;\n\t\t}\n\t\tif (q_num == MGMT_BEACON_Q) {\n\t\t\tstatus = rsi_send_pkt_to_bus(common, skb);\n\t\t\tdev_kfree_skb(skb);\n\t\t} else {\n#ifdef CONFIG_RSI_COEX\n\t\t\tif (common->coex_mode > 1) {\n\t\t\t\tstatus = rsi_coex_send_pkt(common, skb,\n\t\t\t\t\t\t\t   RSI_WLAN_Q);\n\t\t\t} else {\n#endif\n\t\t\t\tif (q_num == MGMT_SOFT_Q)\n\t\t\t\t\tstatus = rsi_send_mgmt_pkt(common, skb);\n\t\t\t\telse\n\t\t\t\t\tstatus = rsi_send_data_pkt(common, skb);\n#ifdef CONFIG_RSI_COEX\n\t\t\t}\n#endif\n\t\t}\n\n\t\tif (status) {\n\t\t\tmutex_unlock(&common->tx_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tcommon->tx_stats.total_tx_pkt_send[q_num]++;\n\n\t\ttstamp_2 = jiffies;\n\t\tmutex_unlock(&common->tx_lock);\n\n\t\tif (time_after(tstamp_2, tstamp_1 + (300 * HZ) / 1000))\n\t\t\tschedule();\n\t}\n}\n\nstruct rsi_sta *rsi_find_sta(struct rsi_common *common, u8 *mac_addr)\n{\n\tint i;\n\n\tfor (i = 0; i < common->max_stations; i++) {\n\t\tif (!common->stations[i].sta)\n\t\t\tcontinue;\n\t\tif (!(memcmp(common->stations[i].sta->addr,\n\t\t\t     mac_addr, ETH_ALEN)))\n\t\t\treturn &common->stations[i];\n\t}\n\treturn NULL;\n}\n\nstruct ieee80211_vif *rsi_get_vif(struct rsi_hw *adapter, u8 *mac)\n{\n\tstruct ieee80211_vif *vif;\n\tint i;\n\n\tfor (i = 0; i < RSI_MAX_VIFS; i++) {\n\t\tvif = adapter->vifs[i];\n\t\tif (!vif)\n\t\t\tcontinue;\n\t\tif (!memcmp(vif->addr, mac, ETH_ALEN))\n\t\t\treturn vif;\n\t}\n\treturn NULL;\n}\n\n \nvoid rsi_core_xmit(struct rsi_common *common, struct sk_buff *skb)\n{\n\tstruct rsi_hw *adapter = common->priv;\n\tstruct ieee80211_tx_info *info;\n\tstruct skb_info *tx_params;\n\tstruct ieee80211_hdr *wh = NULL;\n\tstruct ieee80211_vif *vif;\n\tu8 q_num, tid = 0;\n\tstruct rsi_sta *rsta = NULL;\n\n\tif ((!skb) || (!skb->len)) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Null skb/zero Length packet\\n\",\n\t\t\t__func__);\n\t\tgoto xmit_fail;\n\t}\n\tif (common->fsm_state != FSM_MAC_INIT_DONE) {\n\t\trsi_dbg(ERR_ZONE, \"%s: FSM state not open\\n\", __func__);\n\t\tgoto xmit_fail;\n\t}\n\tif (common->wow_flags & RSI_WOW_ENABLED) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Blocking Tx_packets when WOWLAN is enabled\\n\",\n\t\t\t__func__);\n\t\tgoto xmit_fail;\n\t}\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\ttx_params = (struct skb_info *)info->driver_data;\n\t \n\ttx_params->have_key = !!info->control.hw_key;\n\twh = (struct ieee80211_hdr *)&skb->data[0];\n\ttx_params->sta_id = 0;\n\n\tvif = rsi_get_vif(adapter, wh->addr2);\n\tif (!vif)\n\t\tgoto xmit_fail;\n\ttx_params->vif = vif;\n\ttx_params->vap_id = ((struct vif_priv *)vif->drv_priv)->vap_id;\n\tif ((ieee80211_is_mgmt(wh->frame_control)) ||\n\t    (ieee80211_is_ctl(wh->frame_control)) ||\n\t    (ieee80211_is_qos_nullfunc(wh->frame_control))) {\n\t\tif (ieee80211_is_assoc_req(wh->frame_control) ||\n\t\t    ieee80211_is_reassoc_req(wh->frame_control)) {\n\t\t\tstruct ieee80211_bss_conf *bss = &vif->bss_conf;\n\n\t\t\tcommon->eapol4_confirm = false;\n\t\t\trsi_hal_send_sta_notify_frame(common,\n\t\t\t\t\t\t      RSI_IFTYPE_STATION,\n\t\t\t\t\t\t      STA_CONNECTED, bss->bssid,\n\t\t\t\t\t\t      bss->qos, vif->cfg.aid,\n\t\t\t\t\t\t      0,\n\t\t\t\t\t\t      vif);\n\t\t}\n\n\t\tq_num = MGMT_SOFT_Q;\n\t\tskb->priority = q_num;\n\n\t\tif (rsi_prepare_mgmt_desc(common, skb)) {\n\t\t\trsi_dbg(ERR_ZONE, \"Failed to prepare desc\\n\");\n\t\t\tgoto xmit_fail;\n\t\t}\n\t} else {\n\t\tif (ieee80211_is_data_qos(wh->frame_control)) {\n\t\t\tu8 *qos = ieee80211_get_qos_ctl(wh);\n\n\t\t\ttid = *qos & IEEE80211_QOS_CTL_TID_MASK;\n\t\t\tskb->priority = TID_TO_WME_AC(tid);\n\t\t} else {\n\t\t\ttid = IEEE80211_NONQOS_TID;\n\t\t\tskb->priority = BE_Q;\n\t\t}\n\n\t\tq_num = skb->priority;\n\t\ttx_params->tid = tid;\n\n\t\tif (((vif->type == NL80211_IFTYPE_AP) ||\n\t\t     (vif->type == NL80211_IFTYPE_P2P_GO)) &&\n\t\t    (!is_broadcast_ether_addr(wh->addr1)) &&\n\t\t    (!is_multicast_ether_addr(wh->addr1))) {\n\t\t\trsta = rsi_find_sta(common, wh->addr1);\n\t\t\tif (!rsta)\n\t\t\t\tgoto xmit_fail;\n\t\t\ttx_params->sta_id = rsta->sta_id;\n\t\t} else {\n\t\t\ttx_params->sta_id = 0;\n\t\t}\n\n\t\tif (rsta) {\n\t\t\t \n\t\t\tif (!rsta->start_tx_aggr[tid]) {\n\t\t\t\trsta->start_tx_aggr[tid] = true;\n\t\t\t\tieee80211_start_tx_ba_session(rsta->sta,\n\t\t\t\t\t\t\t      tid, 0);\n\t\t\t}\n\t\t}\n\n\t\tif (IEEE80211_SKB_CB(skb)->control.flags &\n\t\t    IEEE80211_TX_CTRL_PORT_CTRL_PROTO) {\n\t\t\tq_num = MGMT_SOFT_Q;\n\t\t\tskb->priority = q_num;\n\t\t}\n\t\tif (rsi_prepare_data_desc(common, skb)) {\n\t\t\trsi_dbg(ERR_ZONE, \"Failed to prepare data desc\\n\");\n\t\t\tgoto xmit_fail;\n\t\t}\n\t}\n\n\tif ((q_num < MGMT_SOFT_Q) &&\n\t    ((skb_queue_len(&common->tx_queue[q_num]) + 1) >=\n\t     DATA_QUEUE_WATER_MARK)) {\n\t\trsi_dbg(ERR_ZONE, \"%s: sw queue full\\n\", __func__);\n\t\tif (!ieee80211_queue_stopped(adapter->hw, WME_AC(q_num)))\n\t\t\tieee80211_stop_queue(adapter->hw, WME_AC(q_num));\n\t\trsi_set_event(&common->tx_thread.event);\n\t\tgoto xmit_fail;\n\t}\n\n\trsi_core_queue_pkt(common, skb);\n\trsi_dbg(DATA_TX_ZONE, \"%s: ===> Scheduling TX thread <===\\n\", __func__);\n\trsi_set_event(&common->tx_thread.event);\n\n\treturn;\n\nxmit_fail:\n\trsi_dbg(ERR_ZONE, \"%s: Failed to queue packet\\n\", __func__);\n\t \n\tieee80211_free_txskb(common->priv->hw, skb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}