{
  "module_name": "rsi_91x_main.c",
  "hash_id": "28a775679b7bf5423ef8702faa18a64c46192a52006c8f7b45b3b36876201fac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/rsi/rsi_91x_main.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/firmware.h>\n#include <net/rsi_91x.h>\n#include \"rsi_mgmt.h\"\n#include \"rsi_common.h\"\n#include \"rsi_coex.h\"\n#include \"rsi_hal.h\"\n#include \"rsi_usb.h\"\n\nu32 rsi_zone_enabled =  \n\t\t\tERR_ZONE |\n\t\t\t0;\nEXPORT_SYMBOL_GPL(rsi_zone_enabled);\n\n#ifdef CONFIG_RSI_COEX\nstatic struct rsi_proto_ops g_proto_ops = {\n\t.coex_send_pkt = rsi_coex_send_pkt,\n\t.get_host_intf = rsi_get_host_intf,\n\t.set_bt_context = rsi_set_bt_context,\n};\n#endif\n\n \nvoid rsi_dbg(u32 zone, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (zone & rsi_zone_enabled)\n\t\tpr_info(\"%pV\", &vaf);\n\tva_end(args);\n}\nEXPORT_SYMBOL_GPL(rsi_dbg);\n\nstatic char *opmode_str(int oper_mode)\n{\n\tswitch (oper_mode) {\n\tcase DEV_OPMODE_WIFI_ALONE:\n\t\treturn \"Wi-Fi alone\";\n\tcase DEV_OPMODE_BT_ALONE:\n\t\treturn \"BT EDR alone\";\n\tcase DEV_OPMODE_BT_LE_ALONE:\n\t\treturn \"BT LE alone\";\n\tcase DEV_OPMODE_BT_DUAL:\n\t\treturn \"BT Dual\";\n\tcase DEV_OPMODE_STA_BT:\n\t\treturn \"Wi-Fi STA + BT EDR\";\n\tcase DEV_OPMODE_STA_BT_LE:\n\t\treturn \"Wi-Fi STA + BT LE\";\n\tcase DEV_OPMODE_STA_BT_DUAL:\n\t\treturn \"Wi-Fi STA + BT DUAL\";\n\tcase DEV_OPMODE_AP_BT:\n\t\treturn \"Wi-Fi AP + BT EDR\";\n\tcase DEV_OPMODE_AP_BT_DUAL:\n\t\treturn \"Wi-Fi AP + BT DUAL\";\n\t}\n\n\treturn \"Unknown\";\n}\n\nvoid rsi_print_version(struct rsi_common *common)\n{\n\trsi_dbg(ERR_ZONE, \"================================================\\n\");\n\trsi_dbg(ERR_ZONE, \"================ RSI Version Info ==============\\n\");\n\trsi_dbg(ERR_ZONE, \"================================================\\n\");\n\trsi_dbg(ERR_ZONE, \"FW Version\\t: %d.%d.%d\\n\",\n\t\tcommon->lmac_ver.major, common->lmac_ver.minor,\n\t\tcommon->lmac_ver.release_num);\n\trsi_dbg(ERR_ZONE, \"Operating mode\\t: %d [%s]\",\n\t\tcommon->oper_mode, opmode_str(common->oper_mode));\n\trsi_dbg(ERR_ZONE, \"Firmware file\\t: %s\", common->priv->fw_file_name);\n\trsi_dbg(ERR_ZONE, \"================================================\\n\");\n}\n\n \nstatic struct sk_buff *rsi_prepare_skb(struct rsi_common *common,\n\t\t\t\t       u8 *buffer,\n\t\t\t\t       u32 pkt_len,\n\t\t\t\t       u8 extended_desc)\n{\n\tstruct sk_buff *skb = NULL;\n\tu8 payload_offset;\n\n\tif (WARN(!pkt_len, \"%s: Dummy pkt received\", __func__))\n\t\treturn NULL;\n\n\tif (pkt_len > (RSI_RCV_BUFFER_LEN * 4)) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Pkt size > max rx buf size %d\\n\",\n\t\t\t__func__, pkt_len);\n\t\tpkt_len = RSI_RCV_BUFFER_LEN * 4;\n\t}\n\n\tpkt_len -= extended_desc;\n\tskb = dev_alloc_skb(pkt_len + FRAME_DESC_SZ);\n\tif (skb == NULL)\n\t\treturn NULL;\n\n\tpayload_offset = (extended_desc + FRAME_DESC_SZ);\n\tskb_put(skb, pkt_len);\n\tmemcpy((skb->data), (buffer + payload_offset), skb->len);\n\n\treturn skb;\n}\n\n \nint rsi_read_pkt(struct rsi_common *common, u8 *rx_pkt, s32 rcv_pkt_len)\n{\n\tu8 *frame_desc = NULL, extended_desc = 0;\n\tu32 index, length = 0, queueno = 0;\n\tu16 actual_length = 0, offset;\n\tstruct sk_buff *skb = NULL;\n#ifdef CONFIG_RSI_COEX\n\tu8 bt_pkt_type;\n#endif\n\n\tindex = 0;\n\tdo {\n\t\tframe_desc = &rx_pkt[index];\n\t\tactual_length = *(u16 *)&frame_desc[0];\n\t\toffset = *(u16 *)&frame_desc[2];\n\t\tif (!rcv_pkt_len && offset >\n\t\t\tRSI_MAX_RX_USB_PKT_SIZE - FRAME_DESC_SZ)\n\t\t\tgoto fail;\n\n\t\tqueueno = rsi_get_queueno(frame_desc, offset);\n\t\tlength = rsi_get_length(frame_desc, offset);\n\n\t\t \n\t\tif (queueno == RSI_WIFI_DATA_Q || queueno == RSI_WIFI_MGMT_Q)\n\t\t\textended_desc = rsi_get_extended_desc(frame_desc,\n\t\t\t\t\t\t\t      offset);\n\n\t\tswitch (queueno) {\n\t\tcase RSI_COEX_Q:\n#ifdef CONFIG_RSI_COEX\n\t\t\tif (common->coex_mode > 1)\n\t\t\t\trsi_coex_recv_pkt(common, frame_desc + offset);\n\t\t\telse\n#endif\n\t\t\t\trsi_mgmt_pkt_recv(common,\n\t\t\t\t\t\t  (frame_desc + offset));\n\t\t\tbreak;\n\n\t\tcase RSI_WIFI_DATA_Q:\n\t\t\tskb = rsi_prepare_skb(common,\n\t\t\t\t\t      (frame_desc + offset),\n\t\t\t\t\t      length,\n\t\t\t\t\t      extended_desc);\n\t\t\tif (skb == NULL)\n\t\t\t\tgoto fail;\n\n\t\t\trsi_indicate_pkt_to_os(common, skb);\n\t\t\tbreak;\n\n\t\tcase RSI_WIFI_MGMT_Q:\n\t\t\trsi_mgmt_pkt_recv(common, (frame_desc + offset));\n\t\t\tbreak;\n\n#ifdef CONFIG_RSI_COEX\n\t\tcase RSI_BT_MGMT_Q:\n\t\tcase RSI_BT_DATA_Q:\n#define BT_RX_PKT_TYPE_OFST\t14\n#define BT_CARD_READY_IND\t0x89\n\t\t\tbt_pkt_type = frame_desc[offset + BT_RX_PKT_TYPE_OFST];\n\t\t\tif (bt_pkt_type == BT_CARD_READY_IND) {\n\t\t\t\trsi_dbg(INFO_ZONE, \"BT Card ready recvd\\n\");\n\t\t\t\tif (common->fsm_state == FSM_MAC_INIT_DONE)\n\t\t\t\t\trsi_attach_bt(common);\n\t\t\t\telse\n\t\t\t\t\tcommon->bt_defer_attach = true;\n\t\t\t} else {\n\t\t\t\tif (common->bt_adapter)\n\t\t\t\t\trsi_bt_ops.recv_pkt(common->bt_adapter,\n\t\t\t\t\t\t\tframe_desc + offset);\n\t\t\t}\n\t\t\tbreak;\n#endif\n\n\t\tdefault:\n\t\t\trsi_dbg(ERR_ZONE, \"%s: pkt from invalid queue: %d\\n\",\n\t\t\t\t__func__,   queueno);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tindex  += actual_length;\n\t\trcv_pkt_len -= actual_length;\n\t} while (rcv_pkt_len > 0);\n\n\treturn 0;\nfail:\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(rsi_read_pkt);\n\n \nstatic void rsi_tx_scheduler_thread(struct rsi_common *common)\n{\n\tstruct rsi_hw *adapter = common->priv;\n\tu32 timeout = EVENT_WAIT_FOREVER;\n\n\tdo {\n\t\tif (adapter->determine_event_timeout)\n\t\t\ttimeout = adapter->determine_event_timeout(adapter);\n\t\trsi_wait_event(&common->tx_thread.event, timeout);\n\t\trsi_reset_event(&common->tx_thread.event);\n\n\t\tif (common->init_done)\n\t\t\trsi_core_qos_processor(common);\n\t} while (atomic_read(&common->tx_thread.thread_done) == 0);\n\tkthread_complete_and_exit(&common->tx_thread.completion, 0);\n}\n\n#ifdef CONFIG_RSI_COEX\nenum rsi_host_intf rsi_get_host_intf(void *priv)\n{\n\tstruct rsi_common *common = priv;\n\n\treturn common->priv->rsi_host_intf;\n}\n\nvoid rsi_set_bt_context(void *priv, void *bt_context)\n{\n\tstruct rsi_common *common = priv;\n\n\tcommon->bt_adapter = bt_context;\n}\n#endif\n\nvoid rsi_attach_bt(struct rsi_common *common)\n{\n#ifdef CONFIG_RSI_COEX\n\tif (rsi_bt_ops.attach(common, &g_proto_ops))\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"Failed to attach BT module\\n\");\n#endif\n}\n\n \nstruct rsi_hw *rsi_91x_init(u16 oper_mode)\n{\n\tstruct rsi_hw *adapter = NULL;\n\tstruct rsi_common *common = NULL;\n\tu8 ii = 0;\n\n\tadapter = kzalloc(sizeof(*adapter), GFP_KERNEL);\n\tif (!adapter)\n\t\treturn NULL;\n\n\tadapter->priv = kzalloc(sizeof(*common), GFP_KERNEL);\n\tif (adapter->priv == NULL) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in allocation of memory\\n\",\n\t\t\t__func__);\n\t\tkfree(adapter);\n\t\treturn NULL;\n\t} else {\n\t\tcommon = adapter->priv;\n\t\tcommon->priv = adapter;\n\t}\n\n\tfor (ii = 0; ii < NUM_SOFT_QUEUES; ii++)\n\t\tskb_queue_head_init(&common->tx_queue[ii]);\n\n\trsi_init_event(&common->tx_thread.event);\n\tmutex_init(&common->mutex);\n\tmutex_init(&common->tx_lock);\n\tmutex_init(&common->rx_lock);\n\tmutex_init(&common->tx_bus_mutex);\n\n\tif (rsi_create_kthread(common,\n\t\t\t       &common->tx_thread,\n\t\t\t       rsi_tx_scheduler_thread,\n\t\t\t       \"Tx-Thread\")) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Unable to init tx thrd\\n\", __func__);\n\t\tgoto err;\n\t}\n\n\trsi_default_ps_params(adapter);\n\tinit_bgscan_params(common);\n\tspin_lock_init(&adapter->ps_lock);\n\ttimer_setup(&common->roc_timer, rsi_roc_timeout, 0);\n\tinit_completion(&common->wlan_init_completion);\n\tadapter->device_model = RSI_DEV_9113;\n\tcommon->oper_mode = oper_mode;\n\n\t \n\tswitch (common->oper_mode) {\n\tcase DEV_OPMODE_STA_BT_DUAL:\n\tcase DEV_OPMODE_STA_BT:\n\tcase DEV_OPMODE_STA_BT_LE:\n\tcase DEV_OPMODE_BT_ALONE:\n\tcase DEV_OPMODE_BT_LE_ALONE:\n\tcase DEV_OPMODE_BT_DUAL:\n\t\tcommon->coex_mode = 2;\n\t\tbreak;\n\tcase DEV_OPMODE_AP_BT_DUAL:\n\tcase DEV_OPMODE_AP_BT:\n\t\tcommon->coex_mode = 4;\n\t\tbreak;\n\tcase DEV_OPMODE_WIFI_ALONE:\n\t\tcommon->coex_mode = 1;\n\t\tbreak;\n\tdefault:\n\t\tcommon->oper_mode = 1;\n\t\tcommon->coex_mode = 1;\n\t}\n\trsi_dbg(INFO_ZONE, \"%s: oper_mode = %d, coex_mode = %d\\n\",\n\t\t__func__, common->oper_mode, common->coex_mode);\n\n\tadapter->device_model = RSI_DEV_9113;\n#ifdef CONFIG_RSI_COEX\n\tif (common->coex_mode > 1) {\n\t\tif (rsi_coex_attach(common)) {\n\t\t\trsi_dbg(ERR_ZONE, \"Failed to init coex module\\n\");\n\t\t\trsi_kill_thread(&common->tx_thread);\n\t\t\tgoto err;\n\t\t}\n\t}\n#endif\n\n\tcommon->init_done = true;\n\treturn adapter;\n\nerr:\n\tkfree(common);\n\tkfree(adapter);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(rsi_91x_init);\n\n \nvoid rsi_91x_deinit(struct rsi_hw *adapter)\n{\n\tstruct rsi_common *common = adapter->priv;\n\tu8 ii;\n\n\trsi_dbg(INFO_ZONE, \"%s: Performing deinit os ops\\n\", __func__);\n\n\trsi_kill_thread(&common->tx_thread);\n\n\tfor (ii = 0; ii < NUM_SOFT_QUEUES; ii++)\n\t\tskb_queue_purge(&common->tx_queue[ii]);\n\n#ifdef CONFIG_RSI_COEX\n\tif (common->coex_mode > 1) {\n\t\tif (common->bt_adapter) {\n\t\t\trsi_bt_ops.detach(common->bt_adapter);\n\t\t\tcommon->bt_adapter = NULL;\n\t\t}\n\t\trsi_coex_detach(common);\n\t}\n#endif\n\n\tcommon->init_done = false;\n\n\tkfree(common);\n\tkfree(adapter->rsi_dev);\n\tkfree(adapter);\n}\nEXPORT_SYMBOL_GPL(rsi_91x_deinit);\n\n \nstatic int rsi_91x_hal_module_init(void)\n{\n\trsi_dbg(INIT_ZONE, \"%s: Module init called\\n\", __func__);\n\treturn 0;\n}\n\n \nstatic void rsi_91x_hal_module_exit(void)\n{\n\trsi_dbg(INIT_ZONE, \"%s: Module exit called\\n\", __func__);\n}\n\nmodule_init(rsi_91x_hal_module_init);\nmodule_exit(rsi_91x_hal_module_exit);\nMODULE_AUTHOR(\"Redpine Signals Inc\");\nMODULE_DESCRIPTION(\"Station driver for RSI 91x devices\");\nMODULE_VERSION(\"0.1\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}