{
  "module_name": "rsi_91x_usb.c",
  "hash_id": "51b1b1674ccaa51b6f7c21020578e2dac27d84632e3c4dfa4afefc72fb6349cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/rsi/rsi_91x_usb.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <net/rsi_91x.h>\n#include \"rsi_usb.h\"\n#include \"rsi_hal.h\"\n#include \"rsi_coex.h\"\n\n \nstatic u16 dev_oper_mode = DEV_OPMODE_STA_BT_DUAL;\nmodule_param(dev_oper_mode, ushort, 0444);\nMODULE_PARM_DESC(dev_oper_mode, DEV_OPMODE_PARAM_DESC);\n\nstatic int rsi_rx_urb_submit(struct rsi_hw *adapter, u8 ep_num, gfp_t flags);\n\n \nstatic int rsi_usb_card_write(struct rsi_hw *adapter,\n\t\t\t      u8 *buf,\n\t\t\t      u16 len,\n\t\t\t      u8 endpoint)\n{\n\tstruct rsi_91x_usbdev *dev = adapter->rsi_dev;\n\tint status;\n\tu8 *seg = dev->tx_buffer;\n\tint transfer;\n\tint ep = dev->bulkout_endpoint_addr[endpoint - 1];\n\n\tmemset(seg, 0, len + RSI_USB_TX_HEAD_ROOM);\n\tmemcpy(seg + RSI_USB_TX_HEAD_ROOM, buf, len);\n\tlen += RSI_USB_TX_HEAD_ROOM;\n\ttransfer = len;\n\tstatus = usb_bulk_msg(dev->usbdev,\n\t\t\t      usb_sndbulkpipe(dev->usbdev, ep),\n\t\t\t      (void *)seg,\n\t\t\t      (int)len,\n\t\t\t      &transfer,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\n\tif (status < 0) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"Card write failed with error code :%10d\\n\", status);\n\t\tdev->write_fail = 1;\n\t}\n\treturn status;\n}\n\n \nstatic int rsi_write_multiple(struct rsi_hw *adapter,\n\t\t\t      u8 endpoint,\n\t\t\t      u8 *data,\n\t\t\t      u32 count)\n{\n\tstruct rsi_91x_usbdev *dev;\n\n\tif (!adapter)\n\t\treturn -ENODEV;\n\n\tif (endpoint == 0)\n\t\treturn -EINVAL;\n\n\tdev = adapter->rsi_dev;\n\tif (dev->write_fail)\n\t\treturn -ENETDOWN;\n\n\treturn rsi_usb_card_write(adapter, data, count, endpoint);\n}\n\n \nstatic int rsi_find_bulk_in_and_out_endpoints(struct usb_interface *interface,\n\t\t\t\t\t      struct rsi_hw *adapter)\n{\n\tstruct rsi_91x_usbdev *dev = adapter->rsi_dev;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\t__le16 buffer_size;\n\tint ii, bin_found = 0, bout_found = 0;\n\n\tiface_desc = interface->cur_altsetting;\n\n\tfor (ii = 0; ii < iface_desc->desc.bNumEndpoints; ++ii) {\n\t\tendpoint = &(iface_desc->endpoint[ii].desc);\n\n\t\tif (!dev->bulkin_endpoint_addr[bin_found] &&\n\t\t    (endpoint->bEndpointAddress & USB_DIR_IN) &&\n\t\t    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\t    USB_ENDPOINT_XFER_BULK)) {\n\t\t\tbuffer_size = endpoint->wMaxPacketSize;\n\t\t\tdev->bulkin_size[bin_found] = buffer_size;\n\t\t\tdev->bulkin_endpoint_addr[bin_found] =\n\t\t\t\tendpoint->bEndpointAddress;\n\t\t\tbin_found++;\n\t\t}\n\n\t\tif (!dev->bulkout_endpoint_addr[bout_found] &&\n\t\t    !(endpoint->bEndpointAddress & USB_DIR_IN) &&\n\t\t    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\t    USB_ENDPOINT_XFER_BULK)) {\n\t\t\tbuffer_size = endpoint->wMaxPacketSize;\n\t\t\tdev->bulkout_endpoint_addr[bout_found] =\n\t\t\t\tendpoint->bEndpointAddress;\n\t\t\tdev->bulkout_size[bout_found] = buffer_size;\n\t\t\tbout_found++;\n\t\t}\n\n\t\tif (bin_found >= MAX_BULK_EP || bout_found >= MAX_BULK_EP)\n\t\t\tbreak;\n\t}\n\n\tif (!(dev->bulkin_endpoint_addr[0] && dev->bulkout_endpoint_addr[0])) {\n\t\tdev_err(&interface->dev, \"missing wlan bulk endpoints\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (adapter->priv->coex_mode > 1) {\n\t\tif (!dev->bulkin_endpoint_addr[1]) {\n\t\t\tdev_err(&interface->dev, \"missing bt bulk-in endpoint\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#define RSI_USB_REQ_OUT\t(USB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE)\n#define RSI_USB_REQ_IN\t(USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE)\n\n \nstatic int rsi_usb_reg_read(struct usb_device *usbdev,\n\t\t\t    u32 reg,\n\t\t\t    u16 *value,\n\t\t\t    u16 len)\n{\n\tu8 *buf;\n\tint status = -ENOMEM;\n\n\tif (len > RSI_USB_CTRL_BUF_SIZE)\n\t\treturn -EINVAL;\n\n\tbuf  = kmalloc(RSI_USB_CTRL_BUF_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn status;\n\n\tstatus = usb_control_msg(usbdev,\n\t\t\t\t usb_rcvctrlpipe(usbdev, 0),\n\t\t\t\t USB_VENDOR_REGISTER_READ,\n\t\t\t\t RSI_USB_REQ_IN,\n\t\t\t\t ((reg & 0xffff0000) >> 16), (reg & 0xffff),\n\t\t\t\t (void *)buf,\n\t\t\t\t len,\n\t\t\t\t USB_CTRL_GET_TIMEOUT);\n\n\t*value = (buf[0] | (buf[1] << 8));\n\tif (status < 0) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Reg read failed with error code :%d\\n\",\n\t\t\t__func__, status);\n\t}\n\tkfree(buf);\n\n\treturn status;\n}\n\n \nstatic int rsi_usb_reg_write(struct usb_device *usbdev,\n\t\t\t     u32 reg,\n\t\t\t     u32 value,\n\t\t\t     u16 len)\n{\n\tu8 *usb_reg_buf;\n\tint status = -ENOMEM;\n\n\tif (len > RSI_USB_CTRL_BUF_SIZE)\n\t\treturn -EINVAL;\n\n\tusb_reg_buf  = kmalloc(RSI_USB_CTRL_BUF_SIZE, GFP_KERNEL);\n\tif (!usb_reg_buf)\n\t\treturn status;\n\n\tusb_reg_buf[0] = (cpu_to_le32(value) & 0x00ff);\n\tusb_reg_buf[1] = (cpu_to_le32(value) & 0xff00) >> 8;\n\tusb_reg_buf[2] = (cpu_to_le32(value) & 0x00ff0000) >> 16;\n\tusb_reg_buf[3] = (cpu_to_le32(value) & 0xff000000) >> 24;\n\n\tstatus = usb_control_msg(usbdev,\n\t\t\t\t usb_sndctrlpipe(usbdev, 0),\n\t\t\t\t USB_VENDOR_REGISTER_WRITE,\n\t\t\t\t RSI_USB_REQ_OUT,\n\t\t\t\t ((cpu_to_le32(reg) & 0xffff0000) >> 16),\n\t\t\t\t (cpu_to_le32(reg) & 0xffff),\n\t\t\t\t (void *)usb_reg_buf,\n\t\t\t\t len,\n\t\t\t\t USB_CTRL_SET_TIMEOUT);\n\tif (status < 0) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Reg write failed with error code :%d\\n\",\n\t\t\t__func__, status);\n\t}\n\tkfree(usb_reg_buf);\n\n\treturn status;\n}\n\n \nstatic void rsi_rx_done_handler(struct urb *urb)\n{\n\tstruct rx_usb_ctrl_block *rx_cb = urb->context;\n\tstruct rsi_91x_usbdev *dev = (struct rsi_91x_usbdev *)rx_cb->data;\n\tint status = -EINVAL;\n\n\tif (!rx_cb->rx_skb)\n\t\treturn;\n\n\tif (urb->status) {\n\t\tdev_kfree_skb(rx_cb->rx_skb);\n\t\trx_cb->rx_skb = NULL;\n\t\treturn;\n\t}\n\n\tif (urb->actual_length <= 0 ||\n\t    urb->actual_length > rx_cb->rx_skb->len) {\n\t\trsi_dbg(INFO_ZONE, \"%s: Invalid packet length = %d\\n\",\n\t\t\t__func__, urb->actual_length);\n\t\tgoto out;\n\t}\n\tif (skb_queue_len(&dev->rx_q) >= RSI_MAX_RX_PKTS) {\n\t\trsi_dbg(INFO_ZONE, \"Max RX packets reached\\n\");\n\t\tgoto out;\n\t}\n\tskb_trim(rx_cb->rx_skb, urb->actual_length);\n\tskb_queue_tail(&dev->rx_q, rx_cb->rx_skb);\n\n\trsi_set_event(&dev->rx_thread.event);\n\tstatus = 0;\n\nout:\n\tif (rsi_rx_urb_submit(dev->priv, rx_cb->ep_num, GFP_ATOMIC))\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in urb submission\", __func__);\n\n\tif (status) {\n\t\tdev_kfree_skb(rx_cb->rx_skb);\n\t\trx_cb->rx_skb = NULL;\n\t}\n}\n\nstatic void rsi_rx_urb_kill(struct rsi_hw *adapter, u8 ep_num)\n{\n\tstruct rsi_91x_usbdev *dev = adapter->rsi_dev;\n\tstruct rx_usb_ctrl_block *rx_cb = &dev->rx_cb[ep_num - 1];\n\tstruct urb *urb = rx_cb->rx_urb;\n\n\tusb_kill_urb(urb);\n}\n\n \nstatic int rsi_rx_urb_submit(struct rsi_hw *adapter, u8 ep_num, gfp_t mem_flags)\n{\n\tstruct rsi_91x_usbdev *dev = adapter->rsi_dev;\n\tstruct rx_usb_ctrl_block *rx_cb = &dev->rx_cb[ep_num - 1];\n\tstruct urb *urb = rx_cb->rx_urb;\n\tint status;\n\tstruct sk_buff *skb;\n\tu8 dword_align_bytes = 0;\n\n\tskb = dev_alloc_skb(RSI_MAX_RX_USB_PKT_SIZE);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tskb_reserve(skb, MAX_DWORD_ALIGN_BYTES);\n\tskb_put(skb, RSI_MAX_RX_USB_PKT_SIZE - MAX_DWORD_ALIGN_BYTES);\n\tdword_align_bytes = (unsigned long)skb->data & 0x3f;\n\tif (dword_align_bytes > 0)\n\t\tskb_push(skb, dword_align_bytes);\n\turb->transfer_buffer = skb->data;\n\trx_cb->rx_skb = skb;\n\n\tusb_fill_bulk_urb(urb,\n\t\t\t  dev->usbdev,\n\t\t\t  usb_rcvbulkpipe(dev->usbdev,\n\t\t\t  dev->bulkin_endpoint_addr[ep_num - 1]),\n\t\t\t  urb->transfer_buffer,\n\t\t\t  skb->len,\n\t\t\t  rsi_rx_done_handler,\n\t\t\t  rx_cb);\n\n\tstatus = usb_submit_urb(urb, mem_flags);\n\tif (status) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in urb submission\\n\", __func__);\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn status;\n}\n\nstatic int rsi_usb_read_register_multiple(struct rsi_hw *adapter, u32 addr,\n\t\t\t\t\t  u8 *data, u16 count)\n{\n\tstruct rsi_91x_usbdev *dev = adapter->rsi_dev;\n\tu8 *buf;\n\tu16 transfer;\n\tint status;\n\n\tif (!addr)\n\t\treturn -EINVAL;\n\n\tbuf = kzalloc(RSI_USB_BUF_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\twhile (count) {\n\t\ttransfer = min_t(u16, count, RSI_USB_BUF_SIZE);\n\t\tstatus = usb_control_msg(dev->usbdev,\n\t\t\t\t\t usb_rcvctrlpipe(dev->usbdev, 0),\n\t\t\t\t\t USB_VENDOR_REGISTER_READ,\n\t\t\t\t\t RSI_USB_REQ_IN,\n\t\t\t\t\t ((addr & 0xffff0000) >> 16),\n\t\t\t\t\t (addr & 0xffff), (void *)buf,\n\t\t\t\t\t transfer, USB_CTRL_GET_TIMEOUT);\n\t\tif (status < 0) {\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"Reg read failed with error code :%d\\n\",\n\t\t\t\t status);\n\t\t\tkfree(buf);\n\t\t\treturn status;\n\t\t}\n\t\tmemcpy(data, buf, transfer);\n\t\tcount -= transfer;\n\t\tdata += transfer;\n\t\taddr += transfer;\n\t}\n\tkfree(buf);\n\treturn 0;\n}\n\n \nstatic int rsi_usb_write_register_multiple(struct rsi_hw *adapter, u32 addr,\n\t\t\t\t\t   u8 *data, u16 count)\n{\n\tstruct rsi_91x_usbdev *dev = adapter->rsi_dev;\n\tu8 *buf;\n\tu16 transfer;\n\tint status = 0;\n\n\tbuf = kzalloc(RSI_USB_BUF_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\twhile (count) {\n\t\ttransfer = min_t(u16, count, RSI_USB_BUF_SIZE);\n\t\tmemcpy(buf, data, transfer);\n\t\tstatus = usb_control_msg(dev->usbdev,\n\t\t\t\t\t usb_sndctrlpipe(dev->usbdev, 0),\n\t\t\t\t\t USB_VENDOR_REGISTER_WRITE,\n\t\t\t\t\t RSI_USB_REQ_OUT,\n\t\t\t\t\t ((addr & 0xffff0000) >> 16),\n\t\t\t\t\t (addr & 0xffff),\n\t\t\t\t\t (void *)buf,\n\t\t\t\t\t transfer,\n\t\t\t\t\t USB_CTRL_SET_TIMEOUT);\n\t\tif (status < 0) {\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"Reg write failed with error code :%d\\n\",\n\t\t\t\tstatus);\n\t\t\tkfree(buf);\n\t\t\treturn status;\n\t\t}\n\t\tcount -= transfer;\n\t\tdata += transfer;\n\t\taddr += transfer;\n\t}\n\n\tkfree(buf);\n\treturn 0;\n}\n\n \nstatic int rsi_usb_host_intf_write_pkt(struct rsi_hw *adapter,\n\t\t\t\t       u8 *pkt,\n\t\t\t\t       u32 len)\n{\n\tu32 queueno = ((pkt[1] >> 4) & 0x7);\n\tu8 endpoint;\n\n\tendpoint = ((queueno == RSI_WIFI_MGMT_Q || queueno == RSI_WIFI_DATA_Q ||\n\t\t     queueno == RSI_COEX_Q) ? WLAN_EP : BT_EP);\n\n\treturn rsi_write_multiple(adapter,\n\t\t\t\t  endpoint,\n\t\t\t\t  (u8 *)pkt,\n\t\t\t\t  len);\n}\n\nstatic int rsi_usb_master_reg_read(struct rsi_hw *adapter, u32 reg,\n\t\t\t\t   u32 *value, u16 len)\n{\n\tstruct usb_device *usbdev =\n\t\t((struct rsi_91x_usbdev *)adapter->rsi_dev)->usbdev;\n\tu16 temp;\n\tint ret;\n\n\tret = rsi_usb_reg_read(usbdev, reg, &temp, len);\n\tif (ret < 0)\n\t\treturn ret;\n\t*value = temp;\n\n\treturn 0;\n}\n\nstatic int rsi_usb_master_reg_write(struct rsi_hw *adapter,\n\t\t\t\t    unsigned long reg,\n\t\t\t\t    unsigned long value, u16 len)\n{\n\tstruct usb_device *usbdev =\n\t\t((struct rsi_91x_usbdev *)adapter->rsi_dev)->usbdev;\n\n\treturn rsi_usb_reg_write(usbdev, reg, value, len);\n}\n\nstatic int rsi_usb_load_data_master_write(struct rsi_hw *adapter,\n\t\t\t\t\t  u32 base_address,\n\t\t\t\t\t  u32 instructions_sz, u16 block_size,\n\t\t\t\t\t  u8 *ta_firmware)\n{\n\tu16 num_blocks;\n\tu32 cur_indx, i;\n\tu8 temp_buf[256];\n\tint status;\n\n\tnum_blocks = instructions_sz / block_size;\n\trsi_dbg(INFO_ZONE, \"num_blocks: %d\\n\", num_blocks);\n\n\tfor (cur_indx = 0, i = 0; i < num_blocks; i++, cur_indx += block_size) {\n\t\tmemcpy(temp_buf, ta_firmware + cur_indx, block_size);\n\t\tstatus = rsi_usb_write_register_multiple(adapter, base_address,\n\t\t\t\t\t\t\t (u8 *)(temp_buf),\n\t\t\t\t\t\t\t block_size);\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\trsi_dbg(INFO_ZONE, \"%s: loading block: %d\\n\", __func__, i);\n\t\tbase_address += block_size;\n\t}\n\n\tif (instructions_sz % block_size) {\n\t\tmemset(temp_buf, 0, block_size);\n\t\tmemcpy(temp_buf, ta_firmware + cur_indx,\n\t\t       instructions_sz % block_size);\n\t\tstatus = rsi_usb_write_register_multiple\n\t\t\t\t\t\t(adapter, base_address,\n\t\t\t\t\t\t (u8 *)temp_buf,\n\t\t\t\t\t\t instructions_sz % block_size);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\trsi_dbg(INFO_ZONE,\n\t\t\t\"Written Last Block in Address 0x%x Successfully\\n\",\n\t\t\tcur_indx);\n\t}\n\treturn 0;\n}\n\nstatic struct rsi_host_intf_ops usb_host_intf_ops = {\n\t.write_pkt\t\t= rsi_usb_host_intf_write_pkt,\n\t.read_reg_multiple\t= rsi_usb_read_register_multiple,\n\t.write_reg_multiple\t= rsi_usb_write_register_multiple,\n\t.master_reg_read\t= rsi_usb_master_reg_read,\n\t.master_reg_write\t= rsi_usb_master_reg_write,\n\t.load_data_master_write\t= rsi_usb_load_data_master_write,\n};\n\n \nstatic void rsi_deinit_usb_interface(struct rsi_hw *adapter)\n{\n\tstruct rsi_91x_usbdev *dev = adapter->rsi_dev;\n\n\trsi_kill_thread(&dev->rx_thread);\n\n\tusb_free_urb(dev->rx_cb[0].rx_urb);\n\tif (adapter->priv->coex_mode > 1)\n\t\tusb_free_urb(dev->rx_cb[1].rx_urb);\n\n\tkfree(dev->tx_buffer);\n}\n\nstatic int rsi_usb_init_rx(struct rsi_hw *adapter)\n{\n\tstruct rsi_91x_usbdev *dev = adapter->rsi_dev;\n\tstruct rx_usb_ctrl_block *rx_cb;\n\tu8 idx, num_rx_cb;\n\n\tnum_rx_cb = (adapter->priv->coex_mode > 1 ? 2 : 1);\n\n\tfor (idx = 0; idx < num_rx_cb; idx++) {\n\t\trx_cb = &dev->rx_cb[idx];\n\n\t\trx_cb->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!rx_cb->rx_urb) {\n\t\t\trsi_dbg(ERR_ZONE, \"Failed alloc rx urb[%d]\\n\", idx);\n\t\t\tgoto err;\n\t\t}\n\t\trx_cb->ep_num = idx + 1;\n\t\trx_cb->data = (void *)dev;\n\t}\n\tskb_queue_head_init(&dev->rx_q);\n\trsi_init_event(&dev->rx_thread.event);\n\tif (rsi_create_kthread(adapter->priv, &dev->rx_thread,\n\t\t\t       rsi_usb_rx_thread, \"RX-Thread\")) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Unable to init rx thrd\\n\", __func__);\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tusb_free_urb(dev->rx_cb[0].rx_urb);\n\tif (adapter->priv->coex_mode > 1)\n\t\tusb_free_urb(dev->rx_cb[1].rx_urb);\n\n\treturn -1;\n}\n\n \nstatic int rsi_init_usb_interface(struct rsi_hw *adapter,\n\t\t\t\t  struct usb_interface *pfunction)\n{\n\tstruct rsi_91x_usbdev *rsi_dev;\n\tint status;\n\n\trsi_dev = kzalloc(sizeof(*rsi_dev), GFP_KERNEL);\n\tif (!rsi_dev)\n\t\treturn -ENOMEM;\n\n\tadapter->rsi_dev = rsi_dev;\n\trsi_dev->usbdev = interface_to_usbdev(pfunction);\n\trsi_dev->priv = (void *)adapter;\n\n\tif (rsi_find_bulk_in_and_out_endpoints(pfunction, adapter)) {\n\t\tstatus = -EINVAL;\n\t\tgoto fail_eps;\n\t}\n\n\tadapter->device = &pfunction->dev;\n\tusb_set_intfdata(pfunction, adapter);\n\n\trsi_dev->tx_buffer = kmalloc(2048, GFP_KERNEL);\n\tif (!rsi_dev->tx_buffer) {\n\t\tstatus = -ENOMEM;\n\t\tgoto fail_eps;\n\t}\n\n\tif (rsi_usb_init_rx(adapter)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to init RX handle\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto fail_rx;\n\t}\n\n\trsi_dev->tx_blk_size = 252;\n\tadapter->block_size = rsi_dev->tx_blk_size;\n\n\t \n\tadapter->check_hw_queue_status = rsi_usb_check_queue_status;\n\tadapter->determine_event_timeout = rsi_usb_event_timeout;\n\tadapter->rsi_host_intf = RSI_HOST_INTF_USB;\n\tadapter->host_intf_ops = &usb_host_intf_ops;\n\n#ifdef CONFIG_RSI_DEBUGFS\n\t \n\tadapter->num_debugfs_entries = (MAX_DEBUGFS_ENTRIES - 1);\n#endif\n\n\trsi_dbg(INIT_ZONE, \"%s: Enabled the interface\\n\", __func__);\n\treturn 0;\n\nfail_rx:\n\tkfree(rsi_dev->tx_buffer);\n\nfail_eps:\n\n\treturn status;\n}\n\nstatic int usb_ulp_read_write(struct rsi_hw *adapter, u16 addr, u32 data,\n\t\t\t      u16 len_in_bits)\n{\n\tint ret;\n\n\tret = rsi_usb_master_reg_write\n\t\t\t(adapter, RSI_GSPI_DATA_REG1,\n\t\t\t ((addr << 6) | ((data >> 16) & 0xffff)), 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = rsi_usb_master_reg_write(adapter, RSI_GSPI_DATA_REG0,\n\t\t\t\t       (data & 0xffff), 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\trsi_usb_master_reg_write(adapter, RSI_GSPI_CTRL_REG0,\n\t\t\t\t RSI_GSPI_CTRL_REG0_VALUE, 2);\n\n\tret = rsi_usb_master_reg_write(adapter, RSI_GSPI_CTRL_REG1,\n\t\t\t\t       ((len_in_bits - 1) | RSI_GSPI_TRIG), 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmsleep(20);\n\n\treturn 0;\n}\n\nstatic int rsi_reset_card(struct rsi_hw *adapter)\n{\n\tint ret;\n\n\trsi_dbg(INFO_ZONE, \"Resetting Card...\\n\");\n\trsi_usb_master_reg_write(adapter, RSI_TA_HOLD_REG, 0xE, 4);\n\n\t \n\tmsleep(100);\n\n\tret = rsi_usb_master_reg_write(adapter, SWBL_REGOUT,\n\t\t\t\t       RSI_FW_WDT_DISABLE_REQ,\n\t\t\t\t       RSI_COMMON_REG_SIZE);\n\tif (ret < 0) {\n\t\trsi_dbg(ERR_ZONE, \"Disabling firmware watchdog timer failed\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (adapter->device_model != RSI_DEV_9116) {\n\t\tret = usb_ulp_read_write(adapter, RSI_WATCH_DOG_TIMER_1,\n\t\t\t\t\t RSI_ULP_WRITE_2, 32);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\tret = usb_ulp_read_write(adapter, RSI_WATCH_DOG_TIMER_2,\n\t\t\t\t\t RSI_ULP_WRITE_0, 32);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\tret = usb_ulp_read_write(adapter, RSI_WATCH_DOG_DELAY_TIMER_1,\n\t\t\t\t\t RSI_ULP_WRITE_50, 32);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\tret = usb_ulp_read_write(adapter, RSI_WATCH_DOG_DELAY_TIMER_2,\n\t\t\t\t\t RSI_ULP_WRITE_0, 32);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\tret = usb_ulp_read_write(adapter, RSI_WATCH_DOG_TIMER_ENABLE,\n\t\t\t\t\t RSI_ULP_TIMER_ENABLE, 32);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t} else {\n\t\tret = rsi_usb_master_reg_write(adapter,\n\t\t\t\t\t       NWP_WWD_INTERRUPT_TIMER,\n\t\t\t\t\t       NWP_WWD_INT_TIMER_CLKS,\n\t\t\t\t\t       RSI_9116_REG_SIZE);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\tret = rsi_usb_master_reg_write(adapter,\n\t\t\t\t\t       NWP_WWD_SYSTEM_RESET_TIMER,\n\t\t\t\t\t       NWP_WWD_SYS_RESET_TIMER_CLKS,\n\t\t\t\t\t       RSI_9116_REG_SIZE);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\tret = rsi_usb_master_reg_write(adapter,\n\t\t\t\t\t       NWP_WWD_MODE_AND_RSTART,\n\t\t\t\t\t       NWP_WWD_TIMER_DISABLE,\n\t\t\t\t\t       RSI_9116_REG_SIZE);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t}\n\n\trsi_dbg(INFO_ZONE, \"Reset card done\\n\");\n\treturn ret;\n\nfail:\n\trsi_dbg(ERR_ZONE, \"Reset card failed\\n\");\n\treturn ret;\n}\n\n \nstatic int rsi_probe(struct usb_interface *pfunction,\n\t\t     const struct usb_device_id *id)\n{\n\tstruct rsi_hw *adapter;\n\tstruct rsi_91x_usbdev *dev;\n\tu16 fw_status;\n\tint status;\n\n\trsi_dbg(INIT_ZONE, \"%s: Init function called\\n\", __func__);\n\n\tadapter = rsi_91x_init(dev_oper_mode);\n\tif (!adapter) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed to init os intf ops\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\tadapter->rsi_host_intf = RSI_HOST_INTF_USB;\n\n\tstatus = rsi_init_usb_interface(adapter, pfunction);\n\tif (status) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed to init usb interface\\n\",\n\t\t\t__func__);\n\t\tgoto err;\n\t}\n\n\trsi_dbg(ERR_ZONE, \"%s: Initialized os intf ops\\n\", __func__);\n\n\tif (id->idProduct == RSI_USB_PID_9113) {\n\t\trsi_dbg(INIT_ZONE, \"%s: 9113 module detected\\n\", __func__);\n\t\tadapter->device_model = RSI_DEV_9113;\n\t} else if (id->idProduct == RSI_USB_PID_9116) {\n\t\trsi_dbg(INIT_ZONE, \"%s: 9116 module detected\\n\", __func__);\n\t\tadapter->device_model = RSI_DEV_9116;\n\t} else {\n\t\trsi_dbg(ERR_ZONE, \"%s: Unsupported RSI device id 0x%x\\n\",\n\t\t\t__func__, id->idProduct);\n\t\tstatus = -ENODEV;\n\t\tgoto err1;\n\t}\n\n\tdev = adapter->rsi_dev;\n\n\tstatus = rsi_usb_reg_read(dev->usbdev, FW_STATUS_REG, &fw_status, 2);\n\tif (status < 0)\n\t\tgoto err1;\n\telse\n\t\tfw_status &= 1;\n\n\tif (!fw_status) {\n\t\trsi_dbg(INIT_ZONE, \"Loading firmware...\\n\");\n\t\tstatus = rsi_hal_device_init(adapter);\n\t\tif (status) {\n\t\t\trsi_dbg(ERR_ZONE, \"%s: Failed in device init\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto err1;\n\t\t}\n\t\trsi_dbg(INIT_ZONE, \"%s: Device Init Done\\n\", __func__);\n\t}\n\n\tstatus = rsi_rx_urb_submit(adapter, WLAN_EP, GFP_KERNEL);\n\tif (status)\n\t\tgoto err1;\n\n\tif (adapter->priv->coex_mode > 1) {\n\t\tstatus = rsi_rx_urb_submit(adapter, BT_EP, GFP_KERNEL);\n\t\tif (status)\n\t\t\tgoto err_kill_wlan_urb;\n\t}\n\n\treturn 0;\n\nerr_kill_wlan_urb:\n\trsi_rx_urb_kill(adapter, WLAN_EP);\nerr1:\n\trsi_deinit_usb_interface(adapter);\nerr:\n\trsi_91x_deinit(adapter);\n\trsi_dbg(ERR_ZONE, \"%s: Failed in probe...Exiting\\n\", __func__);\n\treturn status;\n}\n\n \nstatic void rsi_disconnect(struct usb_interface *pfunction)\n{\n\tstruct rsi_hw *adapter = usb_get_intfdata(pfunction);\n\n\tif (!adapter)\n\t\treturn;\n\n\trsi_mac80211_detach(adapter);\n\n\tif (IS_ENABLED(CONFIG_RSI_COEX) && adapter->priv->coex_mode > 1 &&\n\t    adapter->priv->bt_adapter) {\n\t\trsi_bt_ops.detach(adapter->priv->bt_adapter);\n\t\tadapter->priv->bt_adapter = NULL;\n\t}\n\n\tif (adapter->priv->coex_mode > 1)\n\t\trsi_rx_urb_kill(adapter, BT_EP);\n\trsi_rx_urb_kill(adapter, WLAN_EP);\n\n\trsi_reset_card(adapter);\n\trsi_deinit_usb_interface(adapter);\n\trsi_91x_deinit(adapter);\n\n\trsi_dbg(INFO_ZONE, \"%s: Deinitialization completed\\n\", __func__);\n}\n\n#ifdef CONFIG_PM\nstatic int rsi_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\t \n\treturn -ENOSYS;\n}\n\nstatic int rsi_resume(struct usb_interface *intf)\n{\n\t \n\treturn -ENOSYS;\n}\n#endif\n\nstatic const struct usb_device_id rsi_dev_table[] = {\n\t{ USB_DEVICE(RSI_USB_VENDOR_ID, RSI_USB_PID_9113) },\n\t{ USB_DEVICE(RSI_USB_VENDOR_ID, RSI_USB_PID_9116) },\n\t{  },\n};\n\nstatic struct usb_driver rsi_driver = {\n\t.name       = \"RSI-USB WLAN\",\n\t.probe      = rsi_probe,\n\t.disconnect = rsi_disconnect,\n\t.id_table   = rsi_dev_table,\n#ifdef CONFIG_PM\n\t.suspend    = rsi_suspend,\n\t.resume     = rsi_resume,\n#endif\n};\n\nmodule_usb_driver(rsi_driver);\n\nMODULE_AUTHOR(\"Redpine Signals Inc\");\nMODULE_DESCRIPTION(\"Common USB layer for RSI drivers\");\nMODULE_DEVICE_TABLE(usb, rsi_dev_table);\nMODULE_FIRMWARE(FIRMWARE_RSI9113);\nMODULE_VERSION(\"0.1\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}