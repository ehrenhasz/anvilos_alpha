{
  "module_name": "rsi_91x_hal.c",
  "hash_id": "80cdd77ea9ffdaf149363995953a784f283e00de6bc5dc7aa677f1eb5b5189cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/rsi/rsi_91x_hal.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n#include <net/bluetooth/bluetooth.h>\n#include \"rsi_mgmt.h\"\n#include \"rsi_hal.h\"\n#include \"rsi_sdio.h\"\n#include \"rsi_common.h\"\n\n \nstatic struct ta_metadata metadata_flash_content[] = {\n\t{\"flash_content\", 0x00010000},\n\t{\"rsi/rs9113_wlan_qspi.rps\", 0x00010000},\n\t{\"rsi/rs9113_wlan_bt_dual_mode.rps\", 0x00010000},\n\t{\"flash_content\", 0x00010000},\n\t{\"rsi/rs9113_ap_bt_dual_mode.rps\", 0x00010000},\n\n};\n\nstatic struct ta_metadata metadata[] = {{\"pmemdata_dummy\", 0x00000000},\n\t{\"rsi/rs9116_wlan.rps\", 0x00000000},\n\t{\"rsi/rs9116_wlan_bt_classic.rps\", 0x00000000},\n\t{\"rsi/pmemdata_dummy\", 0x00000000},\n\t{\"rsi/rs9116_wlan_bt_classic.rps\", 0x00000000}\n};\n\nint rsi_send_pkt_to_bus(struct rsi_common *common, struct sk_buff *skb)\n{\n\tstruct rsi_hw *adapter = common->priv;\n\tint status;\n\n\tif (common->coex_mode > 1)\n\t\tmutex_lock(&common->tx_bus_mutex);\n\n\tstatus = adapter->host_intf_ops->write_pkt(common->priv,\n\t\t\t\t\t\t   skb->data, skb->len);\n\n\tif (common->coex_mode > 1)\n\t\tmutex_unlock(&common->tx_bus_mutex);\n\n\treturn status;\n}\n\nint rsi_prepare_mgmt_desc(struct rsi_common *common, struct sk_buff *skb)\n{\n\tstruct rsi_hw *adapter = common->priv;\n\tstruct ieee80211_hdr *wh = NULL;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_conf *conf = &adapter->hw->conf;\n\tstruct ieee80211_vif *vif;\n\tstruct rsi_mgmt_desc *mgmt_desc;\n\tstruct skb_info *tx_params;\n\tstruct rsi_xtended_desc *xtend_desc = NULL;\n\tu8 header_size;\n\tu32 dword_align_bytes = 0;\n\n\tif (skb->len > MAX_MGMT_PKT_SIZE) {\n\t\trsi_dbg(INFO_ZONE, \"%s: Dropping mgmt pkt > 512\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\ttx_params = (struct skb_info *)info->driver_data;\n\tvif = tx_params->vif;\n\n\t \n\theader_size = FRAME_DESC_SZ + sizeof(struct rsi_xtended_desc);\n\tif (header_size > skb_headroom(skb)) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Failed to add extended descriptor\\n\",\n\t\t\t__func__);\n\t\treturn -ENOSPC;\n\t}\n\tskb_push(skb, header_size);\n\tdword_align_bytes = ((unsigned long)skb->data & 0x3f);\n\tif (dword_align_bytes > skb_headroom(skb)) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Failed to add dword align\\n\", __func__);\n\t\treturn -ENOSPC;\n\t}\n\tskb_push(skb, dword_align_bytes);\n\theader_size += dword_align_bytes;\n\n\ttx_params->internal_hdr_size = header_size;\n\tmemset(&skb->data[0], 0, header_size);\n\twh = (struct ieee80211_hdr *)&skb->data[header_size];\n\n\tmgmt_desc = (struct rsi_mgmt_desc *)skb->data;\n\txtend_desc = (struct rsi_xtended_desc *)&skb->data[FRAME_DESC_SZ];\n\n\trsi_set_len_qno(&mgmt_desc->len_qno, (skb->len - FRAME_DESC_SZ),\n\t\t\tRSI_WIFI_MGMT_Q);\n\tmgmt_desc->frame_type = TX_DOT11_MGMT;\n\tmgmt_desc->header_len = MIN_802_11_HDR_LEN;\n\tmgmt_desc->xtend_desc_size = header_size - FRAME_DESC_SZ;\n\n\tif (ieee80211_is_probe_req(wh->frame_control))\n\t\tmgmt_desc->frame_info = cpu_to_le16(RSI_INSERT_SEQ_IN_FW);\n\tmgmt_desc->frame_info |= cpu_to_le16(RATE_INFO_ENABLE);\n\tif (is_broadcast_ether_addr(wh->addr1))\n\t\tmgmt_desc->frame_info |= cpu_to_le16(RSI_BROADCAST_PKT);\n\n\tmgmt_desc->seq_ctrl =\n\t\tcpu_to_le16(IEEE80211_SEQ_TO_SN(le16_to_cpu(wh->seq_ctrl)));\n\tif ((common->band == NL80211_BAND_2GHZ) && !common->p2p_enabled)\n\t\tmgmt_desc->rate_info = cpu_to_le16(RSI_RATE_1);\n\telse\n\t\tmgmt_desc->rate_info = cpu_to_le16(RSI_RATE_6);\n\n\tif (conf_is_ht40(conf))\n\t\tmgmt_desc->bbp_info = cpu_to_le16(FULL40M_ENABLE);\n\n\tif (ieee80211_is_probe_resp(wh->frame_control)) {\n\t\tmgmt_desc->misc_flags |= (RSI_ADD_DELTA_TSF_VAP_ID |\n\t\t\t\t\t  RSI_FETCH_RETRY_CNT_FRM_HST);\n#define PROBE_RESP_RETRY_CNT\t3\n\t\txtend_desc->retry_cnt = PROBE_RESP_RETRY_CNT;\n\t}\n\n\tif (((vif->type == NL80211_IFTYPE_AP) ||\n\t     (vif->type == NL80211_IFTYPE_P2P_GO)) &&\n\t    (ieee80211_is_action(wh->frame_control))) {\n\t\tstruct rsi_sta *rsta = rsi_find_sta(common, wh->addr1);\n\n\t\tif (rsta)\n\t\t\tmgmt_desc->sta_id = tx_params->sta_id;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\tmgmt_desc->rate_info |=\n\t\tcpu_to_le16((tx_params->vap_id << RSI_DESC_VAP_ID_OFST) &\n\t\t\t    RSI_DESC_VAP_ID_MASK);\n\n\treturn 0;\n}\n\n \nint rsi_prepare_data_desc(struct rsi_common *common, struct sk_buff *skb)\n{\n\tstruct rsi_hw *adapter = common->priv;\n\tstruct ieee80211_vif *vif;\n\tstruct ieee80211_hdr *wh = NULL;\n\tstruct ieee80211_tx_info *info;\n\tstruct skb_info *tx_params;\n\tstruct rsi_data_desc *data_desc;\n\tstruct rsi_xtended_desc *xtend_desc;\n\tu8 ieee80211_size = MIN_802_11_HDR_LEN;\n\tu8 header_size;\n\tu8 vap_id = 0;\n\tu8 dword_align_bytes;\n\tbool tx_eapol;\n\tu16 seq_num;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tvif = info->control.vif;\n\ttx_params = (struct skb_info *)info->driver_data;\n\n\ttx_eapol = IEEE80211_SKB_CB(skb)->control.flags &\n\t\t   IEEE80211_TX_CTRL_PORT_CTRL_PROTO;\n\n\theader_size = FRAME_DESC_SZ + sizeof(struct rsi_xtended_desc);\n\tif (header_size > skb_headroom(skb)) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Unable to send pkt\\n\", __func__);\n\t\treturn -ENOSPC;\n\t}\n\tskb_push(skb, header_size);\n\tdword_align_bytes = ((unsigned long)skb->data & 0x3f);\n\tif (header_size > skb_headroom(skb)) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Not enough headroom\\n\", __func__);\n\t\treturn -ENOSPC;\n\t}\n\tskb_push(skb, dword_align_bytes);\n\theader_size += dword_align_bytes;\n\n\ttx_params->internal_hdr_size = header_size;\n\tdata_desc = (struct rsi_data_desc *)skb->data;\n\tmemset(data_desc, 0, header_size);\n\n\txtend_desc = (struct rsi_xtended_desc *)&skb->data[FRAME_DESC_SZ];\n\twh = (struct ieee80211_hdr *)&skb->data[header_size];\n\tseq_num = IEEE80211_SEQ_TO_SN(le16_to_cpu(wh->seq_ctrl));\n\n\tdata_desc->xtend_desc_size = header_size - FRAME_DESC_SZ;\n\n\tif (ieee80211_is_data_qos(wh->frame_control)) {\n\t\tieee80211_size += 2;\n\t\tdata_desc->mac_flags |= cpu_to_le16(RSI_QOS_ENABLE);\n\t}\n\n\tif (((vif->type == NL80211_IFTYPE_STATION) ||\n\t     (vif->type == NL80211_IFTYPE_P2P_CLIENT)) &&\n\t    (adapter->ps_state == PS_ENABLED))\n\t\twh->frame_control |= cpu_to_le16(RSI_SET_PS_ENABLE);\n\n\tif ((!(info->flags & IEEE80211_TX_INTFL_DONT_ENCRYPT)) &&\n\t    tx_params->have_key) {\n\t\tif (rsi_is_cipher_wep(common))\n\t\t\tieee80211_size += 4;\n\t\telse\n\t\t\tieee80211_size += 8;\n\t\tdata_desc->mac_flags |= cpu_to_le16(RSI_ENCRYPT_PKT);\n\t}\n\trsi_set_len_qno(&data_desc->len_qno, (skb->len - FRAME_DESC_SZ),\n\t\t\tRSI_WIFI_DATA_Q);\n\tdata_desc->header_len = ieee80211_size;\n\n\tif (common->rate_config[common->band].fixed_enabled) {\n\t\t \n\t\tu16 fixed_rate = common->rate_config[common->band].fixed_hw_rate;\n\n\t\tdata_desc->frame_info = cpu_to_le16(RATE_INFO_ENABLE);\n\t\tdata_desc->rate_info = cpu_to_le16(fixed_rate);\n\n\t\tif (conf_is_ht40(&common->priv->hw->conf))\n\t\t\tdata_desc->bbp_info = cpu_to_le16(FULL40M_ENABLE);\n\n\t\tif (common->vif_info[0].sgi && (fixed_rate & 0x100)) {\n\t\t        \n\t\t\tdata_desc->rate_info |=\n\t\t\t\tcpu_to_le16(ENABLE_SHORTGI_RATE);\n\t\t}\n\t}\n\n\tif (tx_eapol) {\n\t\trsi_dbg(INFO_ZONE, \"*** Tx EAPOL ***\\n\");\n\n\t\tdata_desc->frame_info = cpu_to_le16(RATE_INFO_ENABLE);\n\t\tif (common->band == NL80211_BAND_5GHZ)\n\t\t\tdata_desc->rate_info = cpu_to_le16(RSI_RATE_6);\n\t\telse\n\t\t\tdata_desc->rate_info = cpu_to_le16(RSI_RATE_1);\n\t\tdata_desc->mac_flags |= cpu_to_le16(RSI_REKEY_PURPOSE);\n\t\tdata_desc->misc_flags |= RSI_FETCH_RETRY_CNT_FRM_HST;\n#define EAPOL_RETRY_CNT 15\n\t\txtend_desc->retry_cnt = EAPOL_RETRY_CNT;\n\n\t\tif (common->eapol4_confirm)\n\t\t\tskb->priority = VO_Q;\n\t\telse\n\t\t\trsi_set_len_qno(&data_desc->len_qno,\n\t\t\t\t\t(skb->len - FRAME_DESC_SZ),\n\t\t\t\t\tRSI_WIFI_MGMT_Q);\n\t\tif (((skb->len - header_size) == EAPOL4_PACKET_LEN) ||\n\t\t    ((skb->len - header_size) == EAPOL4_PACKET_LEN - 2)) {\n\t\t\tdata_desc->misc_flags |=\n\t\t\t\tRSI_DESC_REQUIRE_CFM_TO_HOST;\n\t\t\txtend_desc->confirm_frame_type = EAPOL4_CONFIRM;\n\t\t}\n\t}\n\n\tdata_desc->mac_flags |= cpu_to_le16(seq_num & 0xfff);\n\tdata_desc->qid_tid = ((skb->priority & 0xf) |\n\t\t\t      ((tx_params->tid & 0xf) << 4));\n\tdata_desc->sta_id = tx_params->sta_id;\n\n\tif ((is_broadcast_ether_addr(wh->addr1)) ||\n\t    (is_multicast_ether_addr(wh->addr1))) {\n\t\tdata_desc->frame_info = cpu_to_le16(RATE_INFO_ENABLE);\n\t\tdata_desc->frame_info |= cpu_to_le16(RSI_BROADCAST_PKT);\n\t\tdata_desc->sta_id = vap_id;\n\n\t\tif ((vif->type == NL80211_IFTYPE_AP) ||\n\t\t    (vif->type == NL80211_IFTYPE_P2P_GO)) {\n\t\t\tif (common->band == NL80211_BAND_5GHZ)\n\t\t\t\tdata_desc->rate_info = cpu_to_le16(RSI_RATE_6);\n\t\t\telse\n\t\t\t\tdata_desc->rate_info = cpu_to_le16(RSI_RATE_1);\n\t\t}\n\t}\n\tif (((vif->type == NL80211_IFTYPE_AP) ||\n\t     (vif->type == NL80211_IFTYPE_P2P_GO)) &&\n\t    (ieee80211_has_moredata(wh->frame_control)))\n\t\tdata_desc->frame_info |= cpu_to_le16(MORE_DATA_PRESENT);\n\n\tdata_desc->rate_info |=\n\t\tcpu_to_le16((tx_params->vap_id << RSI_DESC_VAP_ID_OFST) &\n\t\t\t    RSI_DESC_VAP_ID_MASK);\n\n\treturn 0;\n}\n\n \nint rsi_send_data_pkt(struct rsi_common *common, struct sk_buff *skb)\n{\n\tstruct rsi_hw *adapter = common->priv;\n\tstruct ieee80211_vif *vif;\n\tstruct ieee80211_tx_info *info;\n\tint status = -EINVAL;\n\n\tif (!skb)\n\t\treturn 0;\n\tif (common->iface_down)\n\t\tgoto err;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tif (!info->control.vif)\n\t\tgoto err;\n\tvif = info->control.vif;\n\n\tif (((vif->type == NL80211_IFTYPE_STATION) ||\n\t     (vif->type == NL80211_IFTYPE_P2P_CLIENT)) &&\n\t    (!vif->cfg.assoc))\n\t\tgoto err;\n\n\tstatus = rsi_send_pkt_to_bus(common, skb);\n\tif (status)\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed to write pkt\\n\", __func__);\n\nerr:\n\t++common->tx_stats.total_tx_pkt_freed[skb->priority];\n\trsi_indicate_tx_status(adapter, skb, status);\n\treturn status;\n}\n\n \nint rsi_send_mgmt_pkt(struct rsi_common *common,\n\t\t      struct sk_buff *skb)\n{\n\tstruct rsi_hw *adapter = common->priv;\n\tstruct ieee80211_hdr *wh;\n\tstruct ieee80211_tx_info *info;\n\tstruct skb_info *tx_params;\n\tstruct rsi_mgmt_desc *mgmt_desc;\n\tstruct rsi_xtended_desc *xtend_desc;\n\tint status = -E2BIG;\n\tu8 header_size;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\ttx_params = (struct skb_info *)info->driver_data;\n\theader_size = tx_params->internal_hdr_size;\n\n\tif (tx_params->flags & INTERNAL_MGMT_PKT) {\n\t\tstatus = adapter->host_intf_ops->write_pkt(common->priv,\n\t\t\t\t\t\t\t   (u8 *)skb->data,\n\t\t\t\t\t\t\t   skb->len);\n\t\tif (status) {\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"%s: Failed to write the packet\\n\", __func__);\n\t\t}\n\t\tdev_kfree_skb(skb);\n\t\treturn status;\n\t}\n\n\twh = (struct ieee80211_hdr *)&skb->data[header_size];\n\tmgmt_desc = (struct rsi_mgmt_desc *)skb->data;\n\txtend_desc = (struct rsi_xtended_desc *)&skb->data[FRAME_DESC_SZ];\n\n\t \n\tif (ieee80211_is_probe_req(wh->frame_control) &&\n\t    !info->control.vif->cfg.assoc) {\n\t\trsi_dbg(INFO_ZONE,\n\t\t\t\"%s: blocking mgmt queue\\n\", __func__);\n\t\tmgmt_desc->misc_flags = RSI_DESC_REQUIRE_CFM_TO_HOST;\n\t\txtend_desc->confirm_frame_type = PROBEREQ_CONFIRM;\n\t\tcommon->mgmt_q_block = true;\n\t\trsi_dbg(INFO_ZONE, \"Mgmt queue blocked\\n\");\n\t}\n\n\tstatus = rsi_send_pkt_to_bus(common, skb);\n\tif (status)\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed to write the packet\\n\", __func__);\n\n\trsi_indicate_tx_status(common->priv, skb, status);\n\treturn status;\n}\n\nint rsi_send_bt_pkt(struct rsi_common *common, struct sk_buff *skb)\n{\n\tint status = -EINVAL;\n\tu8 header_size = 0;\n\tstruct rsi_bt_desc *bt_desc;\n\tu8 queueno = ((skb->data[1] >> 4) & 0xf);\n\n\tif (queueno == RSI_BT_MGMT_Q) {\n\t\tstatus = rsi_send_pkt_to_bus(common, skb);\n\t\tif (status)\n\t\t\trsi_dbg(ERR_ZONE, \"%s: Failed to write bt mgmt pkt\\n\",\n\t\t\t\t__func__);\n\t\tgoto out;\n\t}\n\theader_size = FRAME_DESC_SZ;\n\tif (header_size > skb_headroom(skb)) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Not enough headroom\\n\", __func__);\n\t\tstatus = -ENOSPC;\n\t\tgoto out;\n\t}\n\tskb_push(skb, header_size);\n\tmemset(skb->data, 0, header_size);\n\tbt_desc = (struct rsi_bt_desc *)skb->data;\n\n\trsi_set_len_qno(&bt_desc->len_qno, (skb->len - FRAME_DESC_SZ),\n\t\t\tRSI_BT_DATA_Q);\n\tbt_desc->bt_pkt_type = cpu_to_le16(bt_cb(skb)->pkt_type);\n\n\tstatus = rsi_send_pkt_to_bus(common, skb);\n\tif (status)\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed to write bt pkt\\n\", __func__);\n\nout:\n\tdev_kfree_skb(skb);\n\treturn status;\n}\n\nint rsi_prepare_beacon(struct rsi_common *common, struct sk_buff *skb)\n{\n\tstruct rsi_hw *adapter = common->priv;\n\tstruct rsi_data_desc *bcn_frm;\n\tstruct ieee80211_hw *hw = common->priv->hw;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tstruct ieee80211_vif *vif;\n\tstruct sk_buff *mac_bcn;\n\tu8 vap_id = 0, i;\n\tu16 tim_offset = 0;\n\n\tfor (i = 0; i < RSI_MAX_VIFS; i++) {\n\t\tvif = adapter->vifs[i];\n\t\tif (!vif)\n\t\t\tcontinue;\n\t\tif ((vif->type == NL80211_IFTYPE_AP) ||\n\t\t    (vif->type == NL80211_IFTYPE_P2P_GO))\n\t\t\tbreak;\n\t}\n\tif (!vif)\n\t\treturn -EINVAL;\n\tmac_bcn = ieee80211_beacon_get_tim(adapter->hw,\n\t\t\t\t\t   vif,\n\t\t\t\t\t   &tim_offset, NULL, 0);\n\tif (!mac_bcn) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to get beacon from mac80211\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcommon->beacon_cnt++;\n\tbcn_frm = (struct rsi_data_desc *)skb->data;\n\trsi_set_len_qno(&bcn_frm->len_qno, mac_bcn->len, RSI_WIFI_DATA_Q);\n\tbcn_frm->header_len = MIN_802_11_HDR_LEN;\n\tbcn_frm->frame_info = cpu_to_le16(RSI_DATA_DESC_MAC_BBP_INFO |\n\t\t\t\t\t  RSI_DATA_DESC_NO_ACK_IND |\n\t\t\t\t\t  RSI_DATA_DESC_BEACON_FRAME |\n\t\t\t\t\t  RSI_DATA_DESC_INSERT_TSF |\n\t\t\t\t\t  RSI_DATA_DESC_INSERT_SEQ_NO |\n\t\t\t\t\t  RATE_INFO_ENABLE);\n\tbcn_frm->rate_info = cpu_to_le16(vap_id << 14);\n\tbcn_frm->qid_tid = BEACON_HW_Q;\n\n\tif (conf_is_ht40_plus(conf)) {\n\t\tbcn_frm->bbp_info = cpu_to_le16(LOWER_20_ENABLE);\n\t\tbcn_frm->bbp_info |= cpu_to_le16(LOWER_20_ENABLE >> 12);\n\t} else if (conf_is_ht40_minus(conf)) {\n\t\tbcn_frm->bbp_info = cpu_to_le16(UPPER_20_ENABLE);\n\t\tbcn_frm->bbp_info |= cpu_to_le16(UPPER_20_ENABLE >> 12);\n\t}\n\n\tif (common->band == NL80211_BAND_2GHZ)\n\t\tbcn_frm->rate_info |= cpu_to_le16(RSI_RATE_1);\n\telse\n\t\tbcn_frm->rate_info |= cpu_to_le16(RSI_RATE_6);\n\n\tif (mac_bcn->data[tim_offset + 2] == 0)\n\t\tbcn_frm->frame_info |= cpu_to_le16(RSI_DATA_DESC_DTIM_BEACON);\n\n\tmemcpy(&skb->data[FRAME_DESC_SZ], mac_bcn->data, mac_bcn->len);\n\tskb_put(skb, mac_bcn->len + FRAME_DESC_SZ);\n\n\tdev_kfree_skb(mac_bcn);\n\n\treturn 0;\n}\n\nstatic void bl_cmd_timeout(struct timer_list *t)\n{\n\tstruct rsi_hw *adapter = from_timer(adapter, t, bl_cmd_timer);\n\n\tadapter->blcmd_timer_expired = true;\n\tdel_timer(&adapter->bl_cmd_timer);\n}\n\nstatic int bl_start_cmd_timer(struct rsi_hw *adapter, u32 timeout)\n{\n\ttimer_setup(&adapter->bl_cmd_timer, bl_cmd_timeout, 0);\n\tadapter->bl_cmd_timer.expires = (msecs_to_jiffies(timeout) + jiffies);\n\n\tadapter->blcmd_timer_expired = false;\n\tadd_timer(&adapter->bl_cmd_timer);\n\n\treturn 0;\n}\n\nstatic int bl_stop_cmd_timer(struct rsi_hw *adapter)\n{\n\tadapter->blcmd_timer_expired = false;\n\tif (timer_pending(&adapter->bl_cmd_timer))\n\t\tdel_timer(&adapter->bl_cmd_timer);\n\n\treturn 0;\n}\n\nstatic int bl_write_cmd(struct rsi_hw *adapter, u8 cmd, u8 exp_resp,\n\t\t\tu16 *cmd_resp)\n{\n\tstruct rsi_host_intf_ops *hif_ops = adapter->host_intf_ops;\n\tu32 regin_val = 0, regout_val = 0;\n\tu32 regin_input = 0;\n\tu8 output = 0;\n\tint status;\n\n\tregin_input = (REGIN_INPUT | adapter->priv->coex_mode);\n\n\twhile (!adapter->blcmd_timer_expired) {\n\t\tregin_val = 0;\n\t\tstatus = hif_ops->master_reg_read(adapter, SWBL_REGIN,\n\t\t\t\t\t\t  &regin_val, 2);\n\t\tif (status < 0) {\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"%s: Command %0x REGIN reading failed..\\n\",\n\t\t\t\t__func__, cmd);\n\t\t\treturn status;\n\t\t}\n\t\tmdelay(1);\n\t\tif ((regin_val >> 12) != REGIN_VALID)\n\t\t\tbreak;\n\t}\n\tif (adapter->blcmd_timer_expired) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Command %0x REGIN reading timed out..\\n\",\n\t\t\t__func__, cmd);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\trsi_dbg(INFO_ZONE,\n\t\t\"Issuing write to Regin val:%0x sending cmd:%0x\\n\",\n\t\tregin_val, (cmd | regin_input << 8));\n\tstatus = hif_ops->master_reg_write(adapter, SWBL_REGIN,\n\t\t\t\t\t   (cmd | regin_input << 8), 2);\n\tif (status < 0)\n\t\treturn status;\n\tmdelay(1);\n\n\tif (cmd == LOAD_HOSTED_FW || cmd == JUMP_TO_ZERO_PC) {\n\t\t \n\t\treturn 0;\n\t}\n\n\twhile (!adapter->blcmd_timer_expired) {\n\t\tregout_val = 0;\n\t\tstatus = hif_ops->master_reg_read(adapter, SWBL_REGOUT,\n\t\t\t\t\t     &regout_val, 2);\n\t\tif (status < 0) {\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"%s: Command %0x REGOUT reading failed..\\n\",\n\t\t\t\t__func__, cmd);\n\t\t\treturn status;\n\t\t}\n\t\tmdelay(1);\n\t\tif ((regout_val >> 8) == REGOUT_VALID)\n\t\t\tbreak;\n\t}\n\tif (adapter->blcmd_timer_expired) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Command %0x REGOUT reading timed out..\\n\",\n\t\t\t__func__, cmd);\n\t\treturn status;\n\t}\n\n\t*cmd_resp = ((u16 *)&regout_val)[0] & 0xffff;\n\n\toutput = ((u8 *)&regout_val)[0] & 0xff;\n\n\tstatus = hif_ops->master_reg_write(adapter, SWBL_REGOUT,\n\t\t\t\t\t   (cmd | REGOUT_INVALID << 8), 2);\n\tif (status < 0) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Command %0x REGOUT writing failed..\\n\",\n\t\t\t__func__, cmd);\n\t\treturn status;\n\t}\n\tmdelay(1);\n\n\tif (output != exp_resp) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Recvd resp %x for cmd %0x\\n\",\n\t\t\t__func__, output, cmd);\n\t\treturn -EINVAL;\n\t}\n\trsi_dbg(INFO_ZONE,\n\t\t\"%s: Recvd Expected resp %x for cmd %0x\\n\",\n\t\t__func__, output, cmd);\n\n\treturn 0;\n}\n\nstatic int bl_cmd(struct rsi_hw *adapter, u8 cmd, u8 exp_resp, char *str)\n{\n\tu16 regout_val = 0;\n\tu32 timeout;\n\tint status;\n\n\tif ((cmd == EOF_REACHED) || (cmd == PING_VALID) || (cmd == PONG_VALID))\n\t\ttimeout = BL_BURN_TIMEOUT;\n\telse\n\t\ttimeout = BL_CMD_TIMEOUT;\n\n\tbl_start_cmd_timer(adapter, timeout);\n\tstatus = bl_write_cmd(adapter, cmd, exp_resp, &regout_val);\n\tif (status < 0) {\n\t\tbl_stop_cmd_timer(adapter);\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Command %s (%0x) writing failed..\\n\",\n\t\t\t__func__, str, cmd);\n\t\treturn status;\n\t}\n\tbl_stop_cmd_timer(adapter);\n\treturn 0;\n}\n\n#define CHECK_SUM_OFFSET 20\n#define LEN_OFFSET 8\n#define ADDR_OFFSET 16\nstatic int bl_write_header(struct rsi_hw *adapter, u8 *flash_content,\n\t\t\t   u32 content_size)\n{\n\tstruct rsi_host_intf_ops *hif_ops = adapter->host_intf_ops;\n\tstruct bl_header *bl_hdr;\n\tu32 write_addr, write_len;\n\tint status;\n\n\tbl_hdr = kzalloc(sizeof(*bl_hdr), GFP_KERNEL);\n\tif (!bl_hdr)\n\t\treturn -ENOMEM;\n\n\tbl_hdr->flags = 0;\n\tbl_hdr->image_no = cpu_to_le32(adapter->priv->coex_mode);\n\tbl_hdr->check_sum =\n\t\tcpu_to_le32(*(u32 *)&flash_content[CHECK_SUM_OFFSET]);\n\tbl_hdr->flash_start_address =\n\t\tcpu_to_le32(*(u32 *)&flash_content[ADDR_OFFSET]);\n\tbl_hdr->flash_len = cpu_to_le32(*(u32 *)&flash_content[LEN_OFFSET]);\n\twrite_len = sizeof(struct bl_header);\n\n\tif (adapter->rsi_host_intf == RSI_HOST_INTF_USB) {\n\t\twrite_addr = PING_BUFFER_ADDRESS;\n\t\tstatus = hif_ops->write_reg_multiple(adapter, write_addr,\n\t\t\t\t\t\t (u8 *)bl_hdr, write_len);\n\t\tif (status < 0) {\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"%s: Failed to load Version/CRC structure\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\twrite_addr = PING_BUFFER_ADDRESS >> 16;\n\t\tstatus = hif_ops->master_access_msword(adapter, write_addr);\n\t\tif (status < 0) {\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"%s: Unable to set ms word to common reg\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto fail;\n\t\t}\n\t\twrite_addr = RSI_SD_REQUEST_MASTER |\n\t\t\t     (PING_BUFFER_ADDRESS & 0xFFFF);\n\t\tstatus = hif_ops->write_reg_multiple(adapter, write_addr,\n\t\t\t\t\t\t (u8 *)bl_hdr, write_len);\n\t\tif (status < 0) {\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"%s: Failed to load Version/CRC structure\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tstatus = 0;\nfail:\n\tkfree(bl_hdr);\n\treturn status;\n}\n\nstatic u32 read_flash_capacity(struct rsi_hw *adapter)\n{\n\tu32 flash_sz = 0;\n\n\tif ((adapter->host_intf_ops->master_reg_read(adapter, FLASH_SIZE_ADDR,\n\t\t\t\t\t\t     &flash_sz, 2)) < 0) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Flash size reading failed..\\n\",\n\t\t\t__func__);\n\t\treturn 0;\n\t}\n\trsi_dbg(INIT_ZONE, \"Flash capacity: %d KiloBytes\\n\", flash_sz);\n\n\treturn (flash_sz * 1024);  \n}\n\nstatic int ping_pong_write(struct rsi_hw *adapter, u8 cmd, u8 *addr, u32 size)\n{\n\tstruct rsi_host_intf_ops *hif_ops = adapter->host_intf_ops;\n\tu32 block_size = adapter->block_size;\n\tu32 cmd_addr;\n\tu16 cmd_resp, cmd_req;\n\tu8 *str;\n\tint status;\n\n\tif (cmd == PING_WRITE) {\n\t\tcmd_addr = PING_BUFFER_ADDRESS;\n\t\tcmd_resp = PONG_AVAIL;\n\t\tcmd_req = PING_VALID;\n\t\tstr = \"PING_VALID\";\n\t} else {\n\t\tcmd_addr = PONG_BUFFER_ADDRESS;\n\t\tcmd_resp = PING_AVAIL;\n\t\tcmd_req = PONG_VALID;\n\t\tstr = \"PONG_VALID\";\n\t}\n\n\tstatus = hif_ops->load_data_master_write(adapter, cmd_addr, size,\n\t\t\t\t\t    block_size, addr);\n\tif (status) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Unable to write blk at addr %0x\\n\",\n\t\t\t__func__, *addr);\n\t\treturn status;\n\t}\n\n\tstatus = bl_cmd(adapter, cmd_req, cmd_resp, str);\n\tif (status)\n\t\treturn status;\n\n\treturn 0;\n}\n\nstatic int auto_fw_upgrade(struct rsi_hw *adapter, u8 *flash_content,\n\t\t\t   u32 content_size)\n{\n\tu8 cmd;\n\tu32 temp_content_size, num_flash, index;\n\tu32 flash_start_address;\n\tint status;\n\n\tif (content_size > MAX_FLASH_FILE_SIZE) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Flash Content size is more than 400K %u\\n\",\n\t\t\t__func__, MAX_FLASH_FILE_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tflash_start_address = *(u32 *)&flash_content[FLASH_START_ADDRESS];\n\trsi_dbg(INFO_ZONE, \"flash start address: %08x\\n\", flash_start_address);\n\n\tif (flash_start_address < FW_IMAGE_MIN_ADDRESS) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Fw image Flash Start Address is less than 64K\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (flash_start_address % FLASH_SECTOR_SIZE) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Flash Start Address is not multiple of 4K\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((flash_start_address + content_size) > adapter->flash_capacity) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Flash Content will cross max flash size\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\ttemp_content_size  = content_size;\n\tnum_flash = content_size / FLASH_WRITE_CHUNK_SIZE;\n\n\trsi_dbg(INFO_ZONE, \"content_size: %d, num_flash: %d\\n\",\n\t\tcontent_size, num_flash);\n\n\tfor (index = 0; index <= num_flash; index++) {\n\t\trsi_dbg(INFO_ZONE, \"flash index: %d\\n\", index);\n\t\tif (index != num_flash) {\n\t\t\tcontent_size = FLASH_WRITE_CHUNK_SIZE;\n\t\t\trsi_dbg(INFO_ZONE, \"QSPI content_size:%d\\n\",\n\t\t\t\tcontent_size);\n\t\t} else {\n\t\t\tcontent_size =\n\t\t\t\ttemp_content_size % FLASH_WRITE_CHUNK_SIZE;\n\t\t\trsi_dbg(INFO_ZONE,\n\t\t\t\t\"Writing last sector content_size:%d\\n\",\n\t\t\t\tcontent_size);\n\t\t\tif (!content_size) {\n\t\t\t\trsi_dbg(INFO_ZONE, \"instruction size zero\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (index % 2)\n\t\t\tcmd = PING_WRITE;\n\t\telse\n\t\t\tcmd = PONG_WRITE;\n\n\t\tstatus = ping_pong_write(adapter, cmd, flash_content,\n\t\t\t\t\t content_size);\n\t\tif (status) {\n\t\t\trsi_dbg(ERR_ZONE, \"%s: Unable to load %d block\\n\",\n\t\t\t\t__func__, index);\n\t\t\treturn status;\n\t\t}\n\n\t\trsi_dbg(INFO_ZONE,\n\t\t\t\"%s: Successfully loaded %d instructions\\n\",\n\t\t\t__func__, index);\n\t\tflash_content += content_size;\n\t}\n\n\tstatus = bl_cmd(adapter, EOF_REACHED, FW_LOADING_SUCCESSFUL,\n\t\t\t\"EOF_REACHED\");\n\tif (status)\n\t\treturn status;\n\n\trsi_dbg(INFO_ZONE, \"FW loading is done and FW is running..\\n\");\n\treturn 0;\n}\n\nstatic int rsi_hal_prepare_fwload(struct rsi_hw *adapter)\n{\n\tstruct rsi_host_intf_ops *hif_ops = adapter->host_intf_ops;\n\tu32 regout_val = 0;\n\tint status;\n\n\tbl_start_cmd_timer(adapter, BL_CMD_TIMEOUT);\n\n\twhile (!adapter->blcmd_timer_expired) {\n\t\tstatus = hif_ops->master_reg_read(adapter, SWBL_REGOUT,\n\t\t\t\t\t\t  &regout_val,\n\t\t\t\t\t\t  RSI_COMMON_REG_SIZE);\n\t\tif (status < 0) {\n\t\t\tbl_stop_cmd_timer(adapter);\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"%s: REGOUT read failed\\n\", __func__);\n\t\t\treturn status;\n\t\t}\n\t\tmdelay(1);\n\t\tif ((regout_val >> 8) == REGOUT_VALID)\n\t\t\tbreak;\n\t}\n\tif (adapter->blcmd_timer_expired) {\n\t\trsi_dbg(ERR_ZONE, \"%s: REGOUT read timedout\\n\", __func__);\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Soft boot loader not present\\n\", __func__);\n\t\treturn -ETIMEDOUT;\n\t}\n\tbl_stop_cmd_timer(adapter);\n\n\trsi_dbg(INFO_ZONE, \"Received Board Version Number: %x\\n\",\n\t\t(regout_val & 0xff));\n\n\tstatus = hif_ops->master_reg_write(adapter, SWBL_REGOUT,\n\t\t\t\t\t   (REGOUT_INVALID |\n\t\t\t\t\t    REGOUT_INVALID << 8),\n\t\t\t\t\t   RSI_COMMON_REG_SIZE);\n\tif (status < 0)\n\t\trsi_dbg(ERR_ZONE, \"%s: REGOUT writing failed..\\n\", __func__);\n\telse\n\t\trsi_dbg(INFO_ZONE,\n\t\t\t\"===> Device is ready to load firmware <===\\n\");\n\n\treturn status;\n}\n\nstatic int rsi_load_9113_firmware(struct rsi_hw *adapter)\n{\n\tstruct rsi_common *common = adapter->priv;\n\tconst struct firmware *fw_entry = NULL;\n\tu32 content_size;\n\tu16 tmp_regout_val = 0;\n\tstruct ta_metadata *metadata_p;\n\tint status;\n\n\tstatus = bl_cmd(adapter, AUTO_READ_MODE, CMD_PASS,\n\t\t\t\"AUTO_READ_CMD\");\n\tif (status < 0)\n\t\treturn status;\n\n\tadapter->flash_capacity = read_flash_capacity(adapter);\n\tif (adapter->flash_capacity <= 0) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Unable to read flash size from EEPROM\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tmetadata_p = &metadata_flash_content[adapter->priv->coex_mode];\n\n\trsi_dbg(INIT_ZONE, \"%s: Loading file %s\\n\", __func__, metadata_p->name);\n\tadapter->fw_file_name = metadata_p->name;\n\n\tstatus = request_firmware(&fw_entry, metadata_p->name, adapter->device);\n\tif (status < 0) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed to open file %s\\n\",\n\t\t\t__func__, metadata_p->name);\n\t\treturn status;\n\t}\n\tcontent_size = fw_entry->size;\n\trsi_dbg(INFO_ZONE, \"FW Length = %d bytes\\n\", content_size);\n\n\t \n\tcommon->lmac_ver.ver.info.fw_ver[0] =\n\t\tfw_entry->data[LMAC_VER_OFFSET_9113] & 0xFF;\n\tcommon->lmac_ver.ver.info.fw_ver[1] =\n\t\tfw_entry->data[LMAC_VER_OFFSET_9113 + 1] & 0xFF;\n\tcommon->lmac_ver.major =\n\t\tfw_entry->data[LMAC_VER_OFFSET_9113 + 2] & 0xFF;\n\tcommon->lmac_ver.release_num =\n\t\tfw_entry->data[LMAC_VER_OFFSET_9113 + 3] & 0xFF;\n\tcommon->lmac_ver.minor =\n\t\tfw_entry->data[LMAC_VER_OFFSET_9113 + 4] & 0xFF;\n\tcommon->lmac_ver.patch_num = 0;\n\trsi_print_version(common);\n\n\tstatus = bl_write_header(adapter, (u8 *)fw_entry->data, content_size);\n\tif (status) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: RPS Image header loading failed\\n\",\n\t\t\t__func__);\n\t\tgoto fail;\n\t}\n\n\tbl_start_cmd_timer(adapter, BL_CMD_TIMEOUT);\n\tstatus = bl_write_cmd(adapter, CHECK_CRC, CMD_PASS, &tmp_regout_val);\n\tif (status) {\n\t\tbl_stop_cmd_timer(adapter);\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: CHECK_CRC Command writing failed..\\n\",\n\t\t\t__func__);\n\t\tif ((tmp_regout_val & 0xff) == CMD_FAIL) {\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"CRC Fail.. Proceeding to Upgrade mode\\n\");\n\t\t\tgoto fw_upgrade;\n\t\t}\n\t}\n\tbl_stop_cmd_timer(adapter);\n\n\tstatus = bl_cmd(adapter, POLLING_MODE, CMD_PASS, \"POLLING_MODE\");\n\tif (status)\n\t\tgoto fail;\n\nload_image_cmd:\n\tstatus = bl_cmd(adapter, LOAD_HOSTED_FW, LOADING_INITIATED,\n\t\t\t\"LOAD_HOSTED_FW\");\n\tif (status)\n\t\tgoto fail;\n\trsi_dbg(INFO_ZONE, \"Load Image command passed..\\n\");\n\tgoto success;\n\nfw_upgrade:\n\tstatus = bl_cmd(adapter, BURN_HOSTED_FW, SEND_RPS_FILE, \"FW_UPGRADE\");\n\tif (status)\n\t\tgoto fail;\n\n\trsi_dbg(INFO_ZONE, \"Burn Command Pass.. Upgrading the firmware\\n\");\n\n\tstatus = auto_fw_upgrade(adapter, (u8 *)fw_entry->data, content_size);\n\tif (status == 0) {\n\t\trsi_dbg(ERR_ZONE, \"Firmware upgradation Done\\n\");\n\t\tgoto load_image_cmd;\n\t}\n\trsi_dbg(ERR_ZONE, \"Firmware upgrade failed\\n\");\n\n\tstatus = bl_cmd(adapter, AUTO_READ_MODE, CMD_PASS,\n\t\t\t\"AUTO_READ_MODE\");\n\tif (status)\n\t\tgoto fail;\n\nsuccess:\n\trsi_dbg(ERR_ZONE, \"***** Firmware Loading successful *****\\n\");\n\trelease_firmware(fw_entry);\n\treturn 0;\n\nfail:\n\trsi_dbg(ERR_ZONE, \"##### Firmware loading failed #####\\n\");\n\trelease_firmware(fw_entry);\n\treturn status;\n}\n\nstatic int rsi_load_9116_firmware(struct rsi_hw *adapter)\n{\n\tstruct rsi_common *common = adapter->priv;\n\tstruct rsi_host_intf_ops *hif_ops = adapter->host_intf_ops;\n\tconst struct firmware *fw_entry;\n\tstruct ta_metadata *metadata_p;\n\tu8 *ta_firmware, *fw_p;\n\tstruct bootload_ds bootload_ds;\n\tu32 instructions_sz, base_address;\n\tu16 block_size = adapter->block_size;\n\tu32 dest, len;\n\tint status, cnt;\n\n\trsi_dbg(INIT_ZONE, \"***** Load 9116 TA Instructions *****\\n\");\n\n\tif (adapter->rsi_host_intf == RSI_HOST_INTF_USB) {\n\t\tstatus = bl_cmd(adapter, POLLING_MODE, CMD_PASS,\n\t\t\t\t\"POLLING_MODE\");\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\tstatus = hif_ops->master_reg_write(adapter, MEM_ACCESS_CTRL_FROM_HOST,\n\t\t\t\t\t   RAM_384K_ACCESS_FROM_TA,\n\t\t\t\t\t   RSI_9116_REG_SIZE);\n\tif (status < 0) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Unable to access full RAM memory\\n\",\n\t\t\t__func__);\n\t\treturn status;\n\t}\n\n\tmetadata_p = &metadata[adapter->priv->coex_mode];\n\trsi_dbg(INIT_ZONE, \"%s: loading file %s\\n\", __func__, metadata_p->name);\n\tstatus = request_firmware(&fw_entry, metadata_p->name, adapter->device);\n\tif (status < 0) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed to open file %s\\n\",\n\t\t\t__func__, metadata_p->name);\n\t\treturn status;\n\t}\n\n\tta_firmware = kmemdup(fw_entry->data, fw_entry->size, GFP_KERNEL);\n\tif (!ta_firmware) {\n\t\tstatus = -ENOMEM;\n\t\tgoto fail_release_fw;\n\t}\n\tfw_p = ta_firmware;\n\tinstructions_sz = fw_entry->size;\n\trsi_dbg(INFO_ZONE, \"FW Length = %d bytes\\n\", instructions_sz);\n\n\tcommon->lmac_ver.major = ta_firmware[LMAC_VER_OFFSET_9116];\n\tcommon->lmac_ver.minor = ta_firmware[LMAC_VER_OFFSET_9116 + 1];\n\tcommon->lmac_ver.release_num = ta_firmware[LMAC_VER_OFFSET_9116 + 2];\n\tcommon->lmac_ver.patch_num = ta_firmware[LMAC_VER_OFFSET_9116 + 3];\n\tcommon->lmac_ver.ver.info.fw_ver[0] =\n\t\tta_firmware[LMAC_VER_OFFSET_9116 + 4];\n\n\tif (instructions_sz % FW_ALIGN_SIZE)\n\t\tinstructions_sz +=\n\t\t\t(FW_ALIGN_SIZE - (instructions_sz % FW_ALIGN_SIZE));\n\trsi_dbg(INFO_ZONE, \"instructions_sz : %d\\n\", instructions_sz);\n\n\tif (*(u16 *)fw_p == RSI_9116_FW_MAGIC_WORD) {\n\t\tmemcpy(&bootload_ds, fw_p, sizeof(struct bootload_ds));\n\t\tfw_p += le16_to_cpu(bootload_ds.offset);\n\t\trsi_dbg(INFO_ZONE, \"FW start = %x\\n\", *(u32 *)fw_p);\n\n\t\tcnt = 0;\n\t\tdo {\n\t\t\trsi_dbg(ERR_ZONE, \"%s: Loading chunk %d\\n\",\n\t\t\t\t__func__, cnt);\n\n\t\t\tdest = le32_to_cpu(bootload_ds.bl_entry[cnt].dst_addr);\n\t\t\tlen = le32_to_cpu(bootload_ds.bl_entry[cnt].control) &\n\t\t\t      RSI_BL_CTRL_LEN_MASK;\n\t\t\trsi_dbg(INFO_ZONE, \"length %d destination %x\\n\",\n\t\t\t\tlen, dest);\n\n\t\t\tstatus = hif_ops->load_data_master_write(adapter, dest,\n\t\t\t\t\t\t\t\t len,\n\t\t\t\t\t\t\t\t block_size,\n\t\t\t\t\t\t\t\t fw_p);\n\t\t\tif (status < 0) {\n\t\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\t\"Failed to load chunk %d\\n\", cnt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfw_p += len;\n\t\t\tif (le32_to_cpu(bootload_ds.bl_entry[cnt].control) &\n\t\t\t    RSI_BL_CTRL_LAST_ENTRY)\n\t\t\t\tbreak;\n\t\t\tcnt++;\n\t\t} while (1);\n\t} else {\n\t\tbase_address = metadata_p->address;\n\t\tstatus = hif_ops->load_data_master_write(adapter,\n\t\t\t\t\t\t\t base_address,\n\t\t\t\t\t\t\t instructions_sz,\n\t\t\t\t\t\t\t block_size,\n\t\t\t\t\t\t\t ta_firmware);\n\t}\n\tif (status) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Unable to load %s blk\\n\",\n\t\t\t__func__, metadata_p->name);\n\t\tgoto fail_free_fw;\n\t}\n\n\trsi_dbg(INIT_ZONE, \"%s: Successfully loaded %s instructions\\n\",\n\t\t__func__, metadata_p->name);\n\n\tif (adapter->rsi_host_intf == RSI_HOST_INTF_SDIO) {\n\t\tif (hif_ops->ta_reset(adapter))\n\t\t\trsi_dbg(ERR_ZONE, \"Unable to put ta in reset\\n\");\n\t} else {\n\t\tif (bl_cmd(adapter, JUMP_TO_ZERO_PC,\n\t\t\t   CMD_PASS, \"JUMP_TO_ZERO\") < 0)\n\t\t\trsi_dbg(INFO_ZONE, \"Jump to zero command failed\\n\");\n\t\telse\n\t\t\trsi_dbg(INFO_ZONE, \"Jump to zero command successful\\n\");\n\t}\n\nfail_free_fw:\n\tkfree(ta_firmware);\nfail_release_fw:\n\trelease_firmware(fw_entry);\n\n\treturn status;\n}\n\nint rsi_hal_device_init(struct rsi_hw *adapter)\n{\n\tstruct rsi_common *common = adapter->priv;\n\tint status;\n\n\tswitch (adapter->device_model) {\n\tcase RSI_DEV_9113:\n\t\tstatus = rsi_hal_prepare_fwload(adapter);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tif (rsi_load_9113_firmware(adapter)) {\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"%s: Failed to load TA instructions\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase RSI_DEV_9116:\n\t\tstatus = rsi_hal_prepare_fwload(adapter);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tif (rsi_load_9116_firmware(adapter)) {\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"%s: Failed to load firmware to 9116 device\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tcommon->fsm_state = FSM_CARD_NOT_READY;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rsi_hal_device_init);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}