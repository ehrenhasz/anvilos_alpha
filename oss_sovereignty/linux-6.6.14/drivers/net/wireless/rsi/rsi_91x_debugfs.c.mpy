{
  "module_name": "rsi_91x_debugfs.c",
  "hash_id": "bf4eaf6b33c5c8b6674ba3c83923c5639d1cad05e3bb5a381c200df607b802a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/rsi/rsi_91x_debugfs.c",
  "human_readable_source": " \n\n#include \"rsi_debugfs.h\"\n#include \"rsi_sdio.h\"\n\n \nstatic int rsi_sdio_stats_read(struct seq_file *seq, void *data)\n{\n\tstruct rsi_common *common = seq->private;\n\tstruct rsi_hw *adapter = common->priv;\n\tstruct rsi_91x_sdiodev *dev = adapter->rsi_dev;\n\n\tseq_printf(seq, \"total_sdio_interrupts: %d\\n\",\n\t\t   dev->rx_info.sdio_int_counter);\n\tseq_printf(seq, \"sdio_msdu_pending_intr_count: %d\\n\",\n\t\t   dev->rx_info.total_sdio_msdu_pending_intr);\n\tseq_printf(seq, \"sdio_buff_full_count : %d\\n\",\n\t\t   dev->rx_info.buf_full_counter);\n\tseq_printf(seq, \"sdio_buf_semi_full_count %d\\n\",\n\t\t   dev->rx_info.buf_semi_full_counter);\n\tseq_printf(seq, \"sdio_unknown_intr_count: %d\\n\",\n\t\t   dev->rx_info.total_sdio_unknown_intr);\n\t \n\tseq_printf(seq, \"BUFFER FULL STATUS  : %d\\n\",\n\t\t   dev->rx_info.buffer_full);\n\tseq_printf(seq, \"SEMI BUFFER FULL STATUS  : %d\\n\",\n\t\t   dev->rx_info.semi_buffer_full);\n\tseq_printf(seq, \"MGMT BUFFER FULL STATUS  : %d\\n\",\n\t\t   dev->rx_info.mgmt_buffer_full);\n\tseq_printf(seq, \"BUFFER FULL COUNTER  : %d\\n\",\n\t\t   dev->rx_info.buf_full_counter);\n\tseq_printf(seq, \"BUFFER SEMI FULL COUNTER  : %d\\n\",\n\t\t   dev->rx_info.buf_semi_full_counter);\n\tseq_printf(seq, \"MGMT BUFFER FULL COUNTER  : %d\\n\",\n\t\t   dev->rx_info.mgmt_buf_full_counter);\n\n\treturn 0;\n}\n\n \nstatic int rsi_sdio_stats_open(struct inode *inode,\n\t\t\t       struct file *file)\n{\n\treturn single_open(file, rsi_sdio_stats_read, inode->i_private);\n}\n\n \nstatic int rsi_version_read(struct seq_file *seq, void *data)\n{\n\tstruct rsi_common *common = seq->private;\n\n\tseq_printf(seq, \"LMAC   : %d.%d.%d.%d\\n\",\n\t\t   common->lmac_ver.major,\n\t\t   common->lmac_ver.minor,\n\t\t   common->lmac_ver.release_num,\n\t\t   common->lmac_ver.patch_num);\n\n\treturn 0;\n}\n\n \nstatic int rsi_version_open(struct inode *inode,\n\t\t\t\t struct file *file)\n{\n\treturn single_open(file, rsi_version_read, inode->i_private);\n}\n\n \nstatic int rsi_stats_read(struct seq_file *seq, void *data)\n{\n\tstruct rsi_common *common = seq->private;\n\n\tstatic const unsigned char fsm_state[][32] = {\n\t\t\"FSM_FW_NOT_LOADED\",\n\t\t\"FSM_CARD_NOT_READY\",\n\t\t\"FSM_COMMON_DEV_PARAMS_SENT\",\n\t\t\"FSM_BOOT_PARAMS_SENT\",\n\t\t\"FSM_EEPROM_READ_MAC_ADDR\",\n\t\t\"FSM_EEPROM_READ_RF_TYPE\",\n\t\t\"FSM_RESET_MAC_SENT\",\n\t\t\"FSM_RADIO_CAPS_SENT\",\n\t\t\"FSM_BB_RF_PROG_SENT\",\n\t\t\"FSM_MAC_INIT_DONE\"\n\t};\n\tseq_puts(seq, \"==> RSI STA DRIVER STATUS <==\\n\");\n\tseq_puts(seq, \"DRIVER_FSM_STATE: \");\n\n\tBUILD_BUG_ON(ARRAY_SIZE(fsm_state) != NUM_FSM_STATES);\n\n\tif (common->fsm_state <= FSM_MAC_INIT_DONE)\n\t\tseq_printf(seq, \"%s\", fsm_state[common->fsm_state]);\n\n\tseq_printf(seq, \"(%d)\\n\\n\", common->fsm_state);\n\n\t \n\tseq_printf(seq, \"total_mgmt_pkt_send : %d\\n\",\n\t\t   common->tx_stats.total_tx_pkt_send[MGMT_SOFT_Q]);\n\tseq_printf(seq, \"total_mgmt_pkt_queued : %d\\n\",\n\t\t   skb_queue_len(&common->tx_queue[MGMT_SOFT_Q]));\n\tseq_printf(seq, \"total_mgmt_pkt_freed  : %d\\n\",\n\t\t   common->tx_stats.total_tx_pkt_freed[MGMT_SOFT_Q]);\n\n\t \n\tseq_printf(seq, \"total_data_vo_pkt_send: %8d\\t\",\n\t\t   common->tx_stats.total_tx_pkt_send[VO_Q]);\n\tseq_printf(seq, \"total_data_vo_pkt_queued:  %8d\\t\",\n\t\t   skb_queue_len(&common->tx_queue[VO_Q]));\n\tseq_printf(seq, \"total_vo_pkt_freed: %8d\\n\",\n\t\t   common->tx_stats.total_tx_pkt_freed[VO_Q]);\n\tseq_printf(seq, \"total_data_vi_pkt_send: %8d\\t\",\n\t\t   common->tx_stats.total_tx_pkt_send[VI_Q]);\n\tseq_printf(seq, \"total_data_vi_pkt_queued:  %8d\\t\",\n\t\t   skb_queue_len(&common->tx_queue[VI_Q]));\n\tseq_printf(seq, \"total_vi_pkt_freed: %8d\\n\",\n\t\t   common->tx_stats.total_tx_pkt_freed[VI_Q]);\n\tseq_printf(seq,  \"total_data_be_pkt_send: %8d\\t\",\n\t\t   common->tx_stats.total_tx_pkt_send[BE_Q]);\n\tseq_printf(seq, \"total_data_be_pkt_queued:  %8d\\t\",\n\t\t   skb_queue_len(&common->tx_queue[BE_Q]));\n\tseq_printf(seq, \"total_be_pkt_freed: %8d\\n\",\n\t\t   common->tx_stats.total_tx_pkt_freed[BE_Q]);\n\tseq_printf(seq, \"total_data_bk_pkt_send: %8d\\t\",\n\t\t   common->tx_stats.total_tx_pkt_send[BK_Q]);\n\tseq_printf(seq, \"total_data_bk_pkt_queued:  %8d\\t\",\n\t\t   skb_queue_len(&common->tx_queue[BK_Q]));\n\tseq_printf(seq, \"total_bk_pkt_freed: %8d\\n\",\n\t\t   common->tx_stats.total_tx_pkt_freed[BK_Q]);\n\n\tseq_puts(seq, \"\\n\");\n\treturn 0;\n}\n\n \nstatic int rsi_stats_open(struct inode *inode,\n\t\t\t  struct file *file)\n{\n\treturn single_open(file, rsi_stats_read, inode->i_private);\n}\n\n \nstatic int rsi_debug_zone_read(struct seq_file *seq, void *data)\n{\n\trsi_dbg(FSM_ZONE, \"%x: rsi_enabled zone\", rsi_zone_enabled);\n\tseq_printf(seq, \"The zones available are %#x\\n\",\n\t\t   rsi_zone_enabled);\n\treturn 0;\n}\n\n \nstatic int rsi_debug_read(struct inode *inode,\n\t\t\t  struct file *file)\n{\n\treturn single_open(file, rsi_debug_zone_read, inode->i_private);\n}\n\n \nstatic ssize_t rsi_debug_zone_write(struct file *filp,\n\t\t\t\t    const char __user *buff,\n\t\t\t\t    size_t len,\n\t\t\t\t    loff_t *data)\n{\n\tunsigned long dbg_zone;\n\tint ret;\n\n\tif (!len)\n\t\treturn 0;\n\n\tret = kstrtoul_from_user(buff, len, 16, &dbg_zone);\n\n\tif (ret)\n\t\treturn ret;\n\n\trsi_zone_enabled = dbg_zone;\n\treturn len;\n}\n\n#define FOPS(fopen) { \\\n\t.owner = THIS_MODULE, \\\n\t.open = (fopen), \\\n\t.read = seq_read, \\\n\t.llseek = seq_lseek, \\\n}\n\n#define FOPS_RW(fopen, fwrite) { \\\n\t.owner = THIS_MODULE, \\\n\t.open = (fopen), \\\n\t.read = seq_read, \\\n\t.llseek = seq_lseek, \\\n\t.write = (fwrite), \\\n}\n\nstatic const struct rsi_dbg_files dev_debugfs_files[] = {\n\t{\"version\", 0644, FOPS(rsi_version_open),},\n\t{\"stats\", 0644, FOPS(rsi_stats_open),},\n\t{\"debug_zone\", 0666, FOPS_RW(rsi_debug_read, rsi_debug_zone_write),},\n\t{\"sdio_stats\", 0644, FOPS(rsi_sdio_stats_open),},\n};\n\n \nint rsi_init_dbgfs(struct rsi_hw *adapter)\n{\n\tstruct rsi_common *common = adapter->priv;\n\tstruct rsi_debugfs *dev_dbgfs;\n\tchar devdir[6];\n\tint ii;\n\tconst struct rsi_dbg_files *files;\n\n\tdev_dbgfs = kzalloc(sizeof(*dev_dbgfs), GFP_KERNEL);\n\tif (!dev_dbgfs)\n\t\treturn -ENOMEM;\n\n\tadapter->dfsentry = dev_dbgfs;\n\n\tsnprintf(devdir, sizeof(devdir), \"%s\",\n\t\t wiphy_name(adapter->hw->wiphy));\n\n\tdev_dbgfs->subdir = debugfs_create_dir(devdir, NULL);\n\n\tfor (ii = 0; ii < adapter->num_debugfs_entries; ii++) {\n\t\tfiles = &dev_debugfs_files[ii];\n\t\tdev_dbgfs->rsi_files[ii] =\n\t\tdebugfs_create_file(files->name,\n\t\t\t\t    files->perms,\n\t\t\t\t    dev_dbgfs->subdir,\n\t\t\t\t    common,\n\t\t\t\t    &files->fops);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rsi_init_dbgfs);\n\n \nvoid rsi_remove_dbgfs(struct rsi_hw *adapter)\n{\n\tstruct rsi_debugfs *dev_dbgfs = adapter->dfsentry;\n\n\tif (!dev_dbgfs)\n\t\treturn;\n\n\tdebugfs_remove_recursive(dev_dbgfs->subdir);\n}\nEXPORT_SYMBOL_GPL(rsi_remove_dbgfs);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}