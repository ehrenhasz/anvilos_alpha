{
  "module_name": "rsi_91x_sdio.c",
  "hash_id": "0c44bf5f4c599f4084061485d909a084220576e3e3e574bd0adfd6fcc1985dc9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/rsi/rsi_91x_sdio.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include \"rsi_sdio.h\"\n#include \"rsi_common.h\"\n#include \"rsi_coex.h\"\n#include \"rsi_hal.h\"\n\n \nstatic u16 dev_oper_mode = DEV_OPMODE_STA_BT_DUAL;\nmodule_param(dev_oper_mode, ushort, 0444);\nMODULE_PARM_DESC(dev_oper_mode, DEV_OPMODE_PARAM_DESC);\n\n \nstatic u32 rsi_sdio_set_cmd52_arg(bool rw,\n\t\t\t\t  u8 func,\n\t\t\t\t  u8 raw,\n\t\t\t\t  u32 address,\n\t\t\t\t  u8 writedata)\n{\n\treturn ((rw & 1) << 31) | ((func & 0x7) << 28) |\n\t\t((raw & 1) << 27) | (1 << 26) |\n\t\t((address & 0x1FFFF) << 9) | (1 << 8) |\n\t\t(writedata & 0xFF);\n}\n\n \nstatic int rsi_cmd52writebyte(struct mmc_card *card,\n\t\t\t      u32 address,\n\t\t\t      u8 byte)\n{\n\tstruct mmc_command io_cmd;\n\tu32 arg;\n\n\tmemset(&io_cmd, 0, sizeof(io_cmd));\n\targ = rsi_sdio_set_cmd52_arg(1, 0, 0, address, byte);\n\tio_cmd.opcode = SD_IO_RW_DIRECT;\n\tio_cmd.arg = arg;\n\tio_cmd.flags = MMC_RSP_R5 | MMC_CMD_AC;\n\n\treturn mmc_wait_for_cmd(card->host, &io_cmd, 0);\n}\n\n \nstatic int rsi_cmd52readbyte(struct mmc_card *card,\n\t\t\t     u32 address,\n\t\t\t     u8 *byte)\n{\n\tstruct mmc_command io_cmd;\n\tu32 arg;\n\tint err;\n\n\tmemset(&io_cmd, 0, sizeof(io_cmd));\n\targ = rsi_sdio_set_cmd52_arg(0, 0, 0, address, 0);\n\tio_cmd.opcode = SD_IO_RW_DIRECT;\n\tio_cmd.arg = arg;\n\tio_cmd.flags = MMC_RSP_R5 | MMC_CMD_AC;\n\n\terr = mmc_wait_for_cmd(card->host, &io_cmd, 0);\n\tif ((!err) && (byte))\n\t\t*byte =  io_cmd.resp[0] & 0xFF;\n\treturn err;\n}\n\n \nstatic int rsi_issue_sdiocommand(struct sdio_func *func,\n\t\t\t\t u32 opcode,\n\t\t\t\t u32 arg,\n\t\t\t\t u32 flags,\n\t\t\t\t u32 *resp)\n{\n\tstruct mmc_command cmd;\n\tstruct mmc_host *host;\n\tint err;\n\n\thost = func->card->host;\n\n\tmemset(&cmd, 0, sizeof(struct mmc_command));\n\tcmd.opcode = opcode;\n\tcmd.arg = arg;\n\tcmd.flags = flags;\n\terr = mmc_wait_for_cmd(host, &cmd, 3);\n\n\tif ((!err) && (resp))\n\t\t*resp = cmd.resp[0];\n\n\treturn err;\n}\n\n \nstatic void rsi_handle_interrupt(struct sdio_func *function)\n{\n\tstruct rsi_hw *adapter = sdio_get_drvdata(function);\n\tstruct rsi_91x_sdiodev *dev = adapter->rsi_dev;\n\n\tif (adapter->priv->fsm_state == FSM_FW_NOT_LOADED)\n\t\treturn;\n\n\trsi_set_event(&dev->rx_thread.event);\n}\n\n \nstatic void rsi_reset_card(struct sdio_func *pfunction)\n{\n\tint ret = 0;\n\tint err;\n\tstruct mmc_card *card = pfunction->card;\n\tstruct mmc_host *host = card->host;\n\tu8 cmd52_resp;\n\tu32 clock, resp, i;\n\tu16 rca;\n\n\t \n\tret = rsi_cmd52writebyte(pfunction->card,\n\t\t\t\t SDIO_CCCR_ABORT,\n\t\t\t\t (1 << 3));\n\n\t \n\tif (ret != -ETIMEDOUT)\n\t\trsi_dbg(ERR_ZONE, \"%s: Reset failed : %d\\n\", __func__, ret);\n\n\t \n\tmsleep(20);\n\n\t \n\thost->ios.chip_select = MMC_CS_DONTCARE;\n\thost->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;\n\thost->ios.power_mode = MMC_POWER_UP;\n\thost->ios.bus_width = MMC_BUS_WIDTH_1;\n\thost->ios.timing = MMC_TIMING_LEGACY;\n\thost->ops->set_ios(host, &host->ios);\n\n\t \n\tmsleep(20);\n\n\thost->ios.clock = host->f_min;\n\thost->ios.power_mode = MMC_POWER_ON;\n\thost->ops->set_ios(host, &host->ios);\n\n\t \n\tmsleep(20);\n\n\t \n\thost->ios.chip_select = MMC_CS_HIGH;\n\thost->ops->set_ios(host, &host->ios);\n\tmsleep(20);\n\terr = rsi_issue_sdiocommand(pfunction,\n\t\t\t\t    MMC_GO_IDLE_STATE,\n\t\t\t\t    0,\n\t\t\t\t    (MMC_RSP_NONE | MMC_CMD_BC),\n\t\t\t\t    NULL);\n\thost->ios.chip_select = MMC_CS_DONTCARE;\n\thost->ops->set_ios(host, &host->ios);\n\tmsleep(20);\n\thost->use_spi_crc = 0;\n\n\tif (err)\n\t\trsi_dbg(ERR_ZONE, \"%s: CMD0 failed : %d\\n\", __func__, err);\n\n\t \n\terr = rsi_issue_sdiocommand(pfunction,\tSD_IO_SEND_OP_COND, 0,\n\t\t\t\t    (MMC_RSP_R4 | MMC_CMD_BCR), &resp);\n\tif (err)\n\t\trsi_dbg(ERR_ZONE, \"%s: CMD5 failed : %d\\n\",\n\t\t\t__func__, err);\n\tcard->ocr = resp;\n\t \n\tfor (i = 0; i < 100; i++) {\n\t\terr = rsi_issue_sdiocommand(pfunction, SD_IO_SEND_OP_COND,\n\t\t\t\t\t    card->ocr,\n\t\t\t\t\t    (MMC_RSP_R4 | MMC_CMD_BCR), &resp);\n\t\tif (err) {\n\t\t\trsi_dbg(ERR_ZONE, \"%s: CMD5 failed : %d\\n\",\n\t\t\t\t__func__, err);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (resp & MMC_CARD_BUSY)\n\t\t\tbreak;\n\t\tmsleep(20);\n\t}\n\n\tif ((i == 100) || (err)) {\n\t\trsi_dbg(ERR_ZONE, \"%s: card in not ready : %d %d\\n\",\n\t\t\t__func__, i, err);\n\t\treturn;\n\t}\n\n\t \n\terr = rsi_issue_sdiocommand(pfunction,\n\t\t\t\t    SD_SEND_RELATIVE_ADDR,\n\t\t\t\t    0,\n\t\t\t\t    (MMC_RSP_R6 | MMC_CMD_BCR),\n\t\t\t\t    &resp);\n\tif (err) {\n\t\trsi_dbg(ERR_ZONE, \"%s: CMD3 failed : %d\\n\", __func__, err);\n\t\treturn;\n\t}\n\trca = resp >> 16;\n\thost->ios.bus_mode = MMC_BUSMODE_PUSHPULL;\n\thost->ops->set_ios(host, &host->ios);\n\n\t \n\terr = rsi_issue_sdiocommand(pfunction,\n\t\t\t\t    MMC_SELECT_CARD,\n\t\t\t\t    (rca << 16),\n\t\t\t\t    (MMC_RSP_R1 | MMC_CMD_AC),\n\t\t\t\t    NULL);\n\tif (err) {\n\t\trsi_dbg(ERR_ZONE, \"%s: CMD7 failed : %d\\n\", __func__, err);\n\t\treturn;\n\t}\n\n\t \n\tif (card->host->caps & MMC_CAP_SD_HIGHSPEED) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Set high speed mode\\n\", __func__);\n\t\terr = rsi_cmd52readbyte(card, SDIO_CCCR_SPEED, &cmd52_resp);\n\t\tif (err) {\n\t\t\trsi_dbg(ERR_ZONE, \"%s: CCCR speed reg read failed: %d\\n\",\n\t\t\t\t__func__, err);\n\t\t} else {\n\t\t\terr = rsi_cmd52writebyte(card,\n\t\t\t\t\t\t SDIO_CCCR_SPEED,\n\t\t\t\t\t\t (cmd52_resp | SDIO_SPEED_EHS));\n\t\t\tif (err) {\n\t\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\t\"%s: CCR speed regwrite failed %d\\n\",\n\t\t\t\t\t__func__, err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\thost->ios.timing = MMC_TIMING_SD_HS;\n\t\t\thost->ops->set_ios(host, &host->ios);\n\t\t}\n\t}\n\n\t \n\tif (mmc_card_hs(card))\n\t\tclock = 50000000;\n\telse\n\t\tclock = card->cis.max_dtr;\n\n\tif (clock > host->f_max)\n\t\tclock = host->f_max;\n\n\thost->ios.clock = clock;\n\thost->ops->set_ios(host, &host->ios);\n\n\tif (card->host->caps & MMC_CAP_4_BIT_DATA) {\n\t\t \n\t\terr = rsi_cmd52writebyte(card,\n\t\t\t\t\t SDIO_CCCR_IF,\n\t\t\t\t\t (SDIO_BUS_CD_DISABLE |\n\t\t\t\t\t  SDIO_BUS_WIDTH_4BIT));\n\t\tif (err) {\n\t\t\trsi_dbg(ERR_ZONE, \"%s: Set bus mode failed : %d\\n\",\n\t\t\t\t__func__, err);\n\t\t\treturn;\n\t\t}\n\t\thost->ios.bus_width = MMC_BUS_WIDTH_4;\n\t\thost->ops->set_ios(host, &host->ios);\n\t}\n}\n\n \nstatic void rsi_setclock(struct rsi_hw *adapter, u32 freq)\n{\n\tstruct rsi_91x_sdiodev *dev = adapter->rsi_dev;\n\tstruct mmc_host *host = dev->pfunction->card->host;\n\tu32 clock;\n\n\tclock = freq * 1000;\n\tif (clock > host->f_max)\n\t\tclock = host->f_max;\n\thost->ios.clock = clock;\n\thost->ops->set_ios(host, &host->ios);\n}\n\n \nstatic int rsi_setblocklength(struct rsi_hw *adapter, u32 length)\n{\n\tstruct rsi_91x_sdiodev *dev = adapter->rsi_dev;\n\tint status;\n\trsi_dbg(INIT_ZONE, \"%s: Setting the block length\\n\", __func__);\n\n\tstatus = sdio_set_block_size(dev->pfunction, length);\n\tdev->pfunction->max_blksize = 256;\n\tadapter->block_size = dev->pfunction->max_blksize;\n\n\trsi_dbg(INFO_ZONE,\n\t\t\"%s: Operational blk length is %d\\n\", __func__, length);\n\treturn status;\n}\n\n \nstatic int rsi_setupcard(struct rsi_hw *adapter)\n{\n\tstruct rsi_91x_sdiodev *dev = adapter->rsi_dev;\n\tint status = 0;\n\n\trsi_setclock(adapter, 50000);\n\n\tdev->tx_blk_size = 256;\n\tstatus = rsi_setblocklength(adapter, dev->tx_blk_size);\n\tif (status)\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Unable to set block length\\n\", __func__);\n\treturn status;\n}\n\n \nint rsi_sdio_read_register(struct rsi_hw *adapter,\n\t\t\t   u32 addr,\n\t\t\t   u8 *data)\n{\n\tstruct rsi_91x_sdiodev *dev = adapter->rsi_dev;\n\tu8 fun_num = 0;\n\tint status;\n\n\tif (likely(dev->sdio_irq_task != current))\n\t\tsdio_claim_host(dev->pfunction);\n\n\tif (fun_num == 0)\n\t\t*data = sdio_f0_readb(dev->pfunction, addr, &status);\n\telse\n\t\t*data = sdio_readb(dev->pfunction, addr, &status);\n\n\tif (likely(dev->sdio_irq_task != current))\n\t\tsdio_release_host(dev->pfunction);\n\n\treturn status;\n}\n\n \nint rsi_sdio_write_register(struct rsi_hw *adapter,\n\t\t\t    u8 function,\n\t\t\t    u32 addr,\n\t\t\t    u8 *data)\n{\n\tstruct rsi_91x_sdiodev *dev = adapter->rsi_dev;\n\tint status = 0;\n\n\tif (likely(dev->sdio_irq_task != current))\n\t\tsdio_claim_host(dev->pfunction);\n\n\tif (function == 0)\n\t\tsdio_f0_writeb(dev->pfunction, *data, addr, &status);\n\telse\n\t\tsdio_writeb(dev->pfunction, *data, addr, &status);\n\n\tif (likely(dev->sdio_irq_task != current))\n\t\tsdio_release_host(dev->pfunction);\n\n\treturn status;\n}\n\n \nvoid rsi_sdio_ack_intr(struct rsi_hw *adapter, u8 int_bit)\n{\n\tint status;\n\tstatus = rsi_sdio_write_register(adapter,\n\t\t\t\t\t 1,\n\t\t\t\t\t (SDIO_FUN1_INTR_CLR_REG |\n\t\t\t\t\t  RSI_SD_REQUEST_MASTER),\n\t\t\t\t\t &int_bit);\n\tif (status)\n\t\trsi_dbg(ERR_ZONE, \"%s: unable to send ack\\n\", __func__);\n}\n\n\n\n \nstatic int rsi_sdio_read_register_multiple(struct rsi_hw *adapter,\n\t\t\t\t\t   u32 addr,\n\t\t\t\t\t   u8 *data,\n\t\t\t\t\t   u16 count)\n{\n\tstruct rsi_91x_sdiodev *dev = adapter->rsi_dev;\n\tu32 status;\n\n\tif (likely(dev->sdio_irq_task != current))\n\t\tsdio_claim_host(dev->pfunction);\n\n\tstatus =  sdio_readsb(dev->pfunction, data, addr, count);\n\n\tif (likely(dev->sdio_irq_task != current))\n\t\tsdio_release_host(dev->pfunction);\n\n\tif (status != 0)\n\t\trsi_dbg(ERR_ZONE, \"%s: Synch Cmd53 read failed\\n\", __func__);\n\treturn status;\n}\n\n \nint rsi_sdio_write_register_multiple(struct rsi_hw *adapter,\n\t\t\t\t     u32 addr,\n\t\t\t\t     u8 *data,\n\t\t\t\t     u16 count)\n{\n\tstruct rsi_91x_sdiodev *dev = adapter->rsi_dev;\n\tint status;\n\n\tif (dev->write_fail > 1) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Stopping card writes\\n\", __func__);\n\t\treturn 0;\n\t} else if (dev->write_fail == 1) {\n\t\t \n\t\trsi_dbg(ERR_ZONE, \"%s: Continue card writes\\n\", __func__);\n\t\tdev->write_fail++;\n\t}\n\n\tif (likely(dev->sdio_irq_task != current))\n\t\tsdio_claim_host(dev->pfunction);\n\n\tstatus = sdio_writesb(dev->pfunction, addr, data, count);\n\n\tif (likely(dev->sdio_irq_task != current))\n\t\tsdio_release_host(dev->pfunction);\n\n\tif (status) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Synch Cmd53 write failed %d\\n\",\n\t\t\t__func__, status);\n\t\tdev->write_fail = 2;\n\t} else {\n\t\tmemcpy(dev->prev_desc, data, FRAME_DESC_SZ);\n\t}\n\treturn status;\n}\n\nstatic int rsi_sdio_load_data_master_write(struct rsi_hw *adapter,\n\t\t\t\t\t   u32 base_address,\n\t\t\t\t\t   u32 instructions_sz,\n\t\t\t\t\t   u16 block_size,\n\t\t\t\t\t   u8 *ta_firmware)\n{\n\tu32 num_blocks, offset, i;\n\tu16 msb_address, lsb_address;\n\tu8 *temp_buf;\n\tint status;\n\n\tnum_blocks = instructions_sz / block_size;\n\tmsb_address = base_address >> 16;\n\n\trsi_dbg(INFO_ZONE, \"ins_size: %d, num_blocks: %d\\n\",\n\t\tinstructions_sz, num_blocks);\n\n\ttemp_buf = kmalloc(block_size, GFP_KERNEL);\n\tif (!temp_buf)\n\t\treturn -ENOMEM;\n\n\t \n\tstatus = rsi_sdio_master_access_msword(adapter, msb_address);\n\tif (status < 0) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Unable to set ms word reg\\n\", __func__);\n\t\tgoto out_free;\n\t}\n\n\tfor (offset = 0, i = 0; i < num_blocks; i++, offset += block_size) {\n\t\tmemcpy(temp_buf, ta_firmware + offset, block_size);\n\t\tlsb_address = (u16)base_address;\n\t\tstatus = rsi_sdio_write_register_multiple\n\t\t\t\t\t(adapter,\n\t\t\t\t\t lsb_address | RSI_SD_REQUEST_MASTER,\n\t\t\t\t\t temp_buf, block_size);\n\t\tif (status < 0) {\n\t\t\trsi_dbg(ERR_ZONE, \"%s: failed to write\\n\", __func__);\n\t\t\tgoto out_free;\n\t\t}\n\t\trsi_dbg(INFO_ZONE, \"%s: loading block: %d\\n\", __func__, i);\n\t\tbase_address += block_size;\n\n\t\tif ((base_address >> 16) != msb_address) {\n\t\t\tmsb_address += 1;\n\n\t\t\t \n\t\t\tstatus = rsi_sdio_master_access_msword(adapter,\n\t\t\t\t\t\t\t       msb_address);\n\t\t\tif (status < 0) {\n\t\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\t\"%s: Unable to set ms word reg\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (instructions_sz % block_size) {\n\t\tmemset(temp_buf, 0, block_size);\n\t\tmemcpy(temp_buf, ta_firmware + offset,\n\t\t       instructions_sz % block_size);\n\t\tlsb_address = (u16)base_address;\n\t\tstatus = rsi_sdio_write_register_multiple\n\t\t\t\t\t(adapter,\n\t\t\t\t\t lsb_address | RSI_SD_REQUEST_MASTER,\n\t\t\t\t\t temp_buf,\n\t\t\t\t\t instructions_sz % block_size);\n\t\tif (status < 0)\n\t\t\tgoto out_free;\n\t\trsi_dbg(INFO_ZONE,\n\t\t\t\"Written Last Block in Address 0x%x Successfully\\n\",\n\t\t\toffset | RSI_SD_REQUEST_MASTER);\n\t}\n\n\tstatus = 0;\nout_free:\n\tkfree(temp_buf);\n\treturn status;\n}\n\n#define FLASH_SIZE_ADDR                 0x04000016\nstatic int rsi_sdio_master_reg_read(struct rsi_hw *adapter, u32 addr,\n\t\t\t\t    u32 *read_buf, u16 size)\n{\n\tu32 addr_on_bus, *data;\n\tu16 ms_addr;\n\tint status;\n\n\tdata = kzalloc(RSI_MASTER_REG_BUF_SIZE, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tms_addr = (addr >> 16);\n\tstatus = rsi_sdio_master_access_msword(adapter, ms_addr);\n\tif (status < 0) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Unable to set ms word to common reg\\n\",\n\t\t\t__func__);\n\t\tgoto err;\n\t}\n\taddr &= 0xFFFF;\n\n\taddr_on_bus = (addr & 0xFF000000);\n\tif ((addr_on_bus == (FLASH_SIZE_ADDR & 0xFF000000)) ||\n\t    (addr_on_bus == 0x0))\n\t\taddr_on_bus = (addr & ~(0x3));\n\telse\n\t\taddr_on_bus = addr;\n\n\t \n\tstatus = rsi_sdio_read_register_multiple\n\t\t\t\t\t(adapter,\n\t\t\t\t\t (addr_on_bus | RSI_SD_REQUEST_MASTER),\n\t\t\t\t\t (u8 *)data, 4);\n\tif (status < 0) {\n\t\trsi_dbg(ERR_ZONE, \"%s: AHB register read failed\\n\", __func__);\n\t\tgoto err;\n\t}\n\tif (size == 2) {\n\t\tif ((addr & 0x3) == 0)\n\t\t\t*read_buf = *data;\n\t\telse\n\t\t\t*read_buf  = (*data >> 16);\n\t\t*read_buf = (*read_buf & 0xFFFF);\n\t} else if (size == 1) {\n\t\tif ((addr & 0x3) == 0)\n\t\t\t*read_buf = *data;\n\t\telse if ((addr & 0x3) == 1)\n\t\t\t*read_buf = (*data >> 8);\n\t\telse if ((addr & 0x3) == 2)\n\t\t\t*read_buf = (*data >> 16);\n\t\telse\n\t\t\t*read_buf = (*data >> 24);\n\t\t*read_buf = (*read_buf & 0xFF);\n\t} else {\n\t\t*read_buf = *data;\n\t}\n\nerr:\n\tkfree(data);\n\treturn status;\n}\n\nstatic int rsi_sdio_master_reg_write(struct rsi_hw *adapter,\n\t\t\t\t     unsigned long addr,\n\t\t\t\t     unsigned long data, u16 size)\n{\n\tunsigned long *data_aligned;\n\tint status;\n\n\tdata_aligned = kzalloc(RSI_MASTER_REG_BUF_SIZE, GFP_KERNEL);\n\tif (!data_aligned)\n\t\treturn -ENOMEM;\n\n\tif (size == 2) {\n\t\t*data_aligned = ((data << 16) | (data & 0xFFFF));\n\t} else if (size == 1) {\n\t\tu32 temp_data = data & 0xFF;\n\n\t\t*data_aligned = ((temp_data << 24) | (temp_data << 16) |\n\t\t\t\t (temp_data << 8) | temp_data);\n\t} else {\n\t\t*data_aligned = data;\n\t}\n\tsize = 4;\n\n\tstatus = rsi_sdio_master_access_msword(adapter, (addr >> 16));\n\tif (status < 0) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Unable to set ms word to common reg\\n\",\n\t\t\t__func__);\n\t\tkfree(data_aligned);\n\t\treturn -EIO;\n\t}\n\taddr = addr & 0xFFFF;\n\n\t \n\tstatus = rsi_sdio_write_register_multiple\n\t\t\t\t\t(adapter,\n\t\t\t\t\t (addr | RSI_SD_REQUEST_MASTER),\n\t\t\t\t\t (u8 *)data_aligned, size);\n\tif (status < 0)\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Unable to do AHB reg write\\n\", __func__);\n\n\tkfree(data_aligned);\n\treturn status;\n}\n\n \nstatic int rsi_sdio_host_intf_write_pkt(struct rsi_hw *adapter,\n\t\t\t\t\tu8 *pkt,\n\t\t\t\t\tu32 len)\n{\n\tstruct rsi_91x_sdiodev *dev = adapter->rsi_dev;\n\tu32 block_size = dev->tx_blk_size;\n\tu32 num_blocks, address, length;\n\tu32 queueno;\n\tint status;\n\n\tqueueno = ((pkt[1] >> 4) & 0xf);\n\tif (queueno == RSI_BT_MGMT_Q || queueno == RSI_BT_DATA_Q)\n\t\tqueueno = RSI_BT_Q;\n\n\tnum_blocks = len / block_size;\n\n\tif (len % block_size)\n\t\tnum_blocks++;\n\n\taddress = (num_blocks * block_size | (queueno << 12));\n\tlength  = num_blocks * block_size;\n\n\tstatus = rsi_sdio_write_register_multiple(adapter,\n\t\t\t\t\t\t  address,\n\t\t\t\t\t\t  (u8 *)pkt,\n\t\t\t\t\t\t  length);\n\tif (status)\n\t\trsi_dbg(ERR_ZONE, \"%s: Unable to write onto the card: %d\\n\",\n\t\t\t__func__, status);\n\trsi_dbg(DATA_TX_ZONE, \"%s: Successfully written onto card\\n\", __func__);\n\treturn status;\n}\n\n \nint rsi_sdio_host_intf_read_pkt(struct rsi_hw *adapter,\n\t\t\t\tu8 *pkt,\n\t\t\t\tu32 length)\n{\n\tint status = -EINVAL;\n\n\tif (!length) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Pkt size is zero\\n\", __func__);\n\t\treturn status;\n\t}\n\n\tstatus = rsi_sdio_read_register_multiple(adapter,\n\t\t\t\t\t\t length,\n\t\t\t\t\t\t (u8 *)pkt,\n\t\t\t\t\t\t length);  \n\n\tif (status)\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed to read frame: %d\\n\", __func__,\n\t\t\tstatus);\n\treturn status;\n}\n\n \nstatic int rsi_init_sdio_interface(struct rsi_hw *adapter,\n\t\t\t\t   struct sdio_func *pfunction)\n{\n\tstruct rsi_91x_sdiodev *rsi_91x_dev;\n\tint status;\n\n\trsi_91x_dev = kzalloc(sizeof(*rsi_91x_dev), GFP_KERNEL);\n\tif (!rsi_91x_dev)\n\t\treturn -ENOMEM;\n\n\tadapter->rsi_dev = rsi_91x_dev;\n\n\tsdio_claim_host(pfunction);\n\n\tpfunction->enable_timeout = 100;\n\tstatus = sdio_enable_func(pfunction);\n\tif (status) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed to enable interface\\n\", __func__);\n\t\tsdio_release_host(pfunction);\n\t\treturn status;\n\t}\n\n\trsi_dbg(INIT_ZONE, \"%s: Enabled the interface\\n\", __func__);\n\n\trsi_91x_dev->pfunction = pfunction;\n\tadapter->device = &pfunction->dev;\n\n\tsdio_set_drvdata(pfunction, adapter);\n\n\tstatus = rsi_setupcard(adapter);\n\tif (status) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed to setup card\\n\", __func__);\n\t\tgoto fail;\n\t}\n\n\trsi_dbg(INIT_ZONE, \"%s: Setup card successfully\\n\", __func__);\n\n\tstatus = rsi_init_sdio_slave_regs(adapter);\n\tif (status) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed to init slave regs\\n\", __func__);\n\t\tgoto fail;\n\t}\n\tsdio_release_host(pfunction);\n\n\tadapter->determine_event_timeout = rsi_sdio_determine_event_timeout;\n\tadapter->check_hw_queue_status = rsi_sdio_check_buffer_status;\n\n#ifdef CONFIG_RSI_DEBUGFS\n\tadapter->num_debugfs_entries = MAX_DEBUGFS_ENTRIES;\n#endif\n\treturn 0;\nfail:\n\tsdio_disable_func(pfunction);\n\tsdio_release_host(pfunction);\n\treturn status;\n}\n\nstatic int rsi_sdio_reinit_device(struct rsi_hw *adapter)\n{\n\tstruct rsi_91x_sdiodev *sdev = adapter->rsi_dev;\n\tstruct sdio_func *pfunction = sdev->pfunction;\n\tint ii;\n\n\tfor (ii = 0; ii < NUM_SOFT_QUEUES; ii++)\n\t\tskb_queue_purge(&adapter->priv->tx_queue[ii]);\n\n\t \n\tsdio_claim_host(pfunction);\n\n\tsdio_release_irq(pfunction);\n\trsi_reset_card(pfunction);\n\n\tsdio_enable_func(pfunction);\n\trsi_setupcard(adapter);\n\trsi_init_sdio_slave_regs(adapter);\n\tsdio_claim_irq(pfunction, rsi_handle_interrupt);\n\trsi_hal_device_init(adapter);\n\n\tsdio_release_host(pfunction);\n\n\treturn 0;\n}\n\nstatic int rsi_sdio_ta_reset(struct rsi_hw *adapter)\n{\n\tint status;\n\tu32 addr;\n\tu8 *data;\n\n\tdata = kzalloc(RSI_9116_REG_SIZE, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tstatus = rsi_sdio_master_access_msword(adapter, TA_BASE_ADDR);\n\tif (status < 0) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"Unable to set ms word to common reg\\n\");\n\t\tgoto err;\n\t}\n\n\trsi_dbg(INIT_ZONE, \"%s: Bring TA out of reset\\n\", __func__);\n\tput_unaligned_le32(TA_HOLD_THREAD_VALUE, data);\n\taddr = TA_HOLD_THREAD_REG | RSI_SD_REQUEST_MASTER;\n\tstatus = rsi_sdio_write_register_multiple(adapter, addr,\n\t\t\t\t\t\t  (u8 *)data,\n\t\t\t\t\t\t  RSI_9116_REG_SIZE);\n\tif (status < 0) {\n\t\trsi_dbg(ERR_ZONE, \"Unable to hold TA threads\\n\");\n\t\tgoto err;\n\t}\n\n\tput_unaligned_le32(TA_SOFT_RST_CLR, data);\n\taddr = TA_SOFT_RESET_REG | RSI_SD_REQUEST_MASTER;\n\tstatus = rsi_sdio_write_register_multiple(adapter, addr,\n\t\t\t\t\t\t  (u8 *)data,\n\t\t\t\t\t\t  RSI_9116_REG_SIZE);\n\tif (status < 0) {\n\t\trsi_dbg(ERR_ZONE, \"Unable to get TA out of reset\\n\");\n\t\tgoto err;\n\t}\n\n\tput_unaligned_le32(TA_PC_ZERO, data);\n\taddr = TA_TH0_PC_REG | RSI_SD_REQUEST_MASTER;\n\tstatus = rsi_sdio_write_register_multiple(adapter, addr,\n\t\t\t\t\t\t  (u8 *)data,\n\t\t\t\t\t\t  RSI_9116_REG_SIZE);\n\tif (status < 0) {\n\t\trsi_dbg(ERR_ZONE, \"Unable to Reset TA PC value\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tput_unaligned_le32(TA_RELEASE_THREAD_VALUE, data);\n\taddr = TA_RELEASE_THREAD_REG | RSI_SD_REQUEST_MASTER;\n\tstatus = rsi_sdio_write_register_multiple(adapter, addr,\n\t\t\t\t\t\t  (u8 *)data,\n\t\t\t\t\t\t  RSI_9116_REG_SIZE);\n\tif (status < 0) {\n\t\trsi_dbg(ERR_ZONE, \"Unable to release TA threads\\n\");\n\t\tgoto err;\n\t}\n\n\tstatus = rsi_sdio_master_access_msword(adapter, MISC_CFG_BASE_ADDR);\n\tif (status < 0) {\n\t\trsi_dbg(ERR_ZONE, \"Unable to set ms word to common reg\\n\");\n\t\tgoto err;\n\t}\n\trsi_dbg(INIT_ZONE, \"***** TA Reset done *****\\n\");\n\nerr:\n\tkfree(data);\n\treturn status;\n}\n\nstatic struct rsi_host_intf_ops sdio_host_intf_ops = {\n\t.write_pkt\t\t= rsi_sdio_host_intf_write_pkt,\n\t.read_pkt\t\t= rsi_sdio_host_intf_read_pkt,\n\t.master_access_msword\t= rsi_sdio_master_access_msword,\n\t.read_reg_multiple\t= rsi_sdio_read_register_multiple,\n\t.write_reg_multiple\t= rsi_sdio_write_register_multiple,\n\t.master_reg_read\t= rsi_sdio_master_reg_read,\n\t.master_reg_write\t= rsi_sdio_master_reg_write,\n\t.load_data_master_write\t= rsi_sdio_load_data_master_write,\n\t.reinit_device          = rsi_sdio_reinit_device,\n\t.ta_reset\t\t= rsi_sdio_ta_reset,\n};\n\n \nstatic int rsi_probe(struct sdio_func *pfunction,\n\t\t     const struct sdio_device_id *id)\n{\n\tstruct rsi_hw *adapter;\n\tstruct rsi_91x_sdiodev *sdev;\n\tint status = -EINVAL;\n\n\trsi_dbg(INIT_ZONE, \"%s: Init function called\\n\", __func__);\n\n\tadapter = rsi_91x_init(dev_oper_mode);\n\tif (!adapter) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed to init os intf ops\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\tadapter->rsi_host_intf = RSI_HOST_INTF_SDIO;\n\tadapter->host_intf_ops = &sdio_host_intf_ops;\n\n\tif (rsi_init_sdio_interface(adapter, pfunction)) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed to init sdio interface\\n\",\n\t\t\t__func__);\n\t\tstatus = -EIO;\n\t\tgoto fail_free_adapter;\n\t}\n\n\tif (pfunction->device == SDIO_DEVICE_ID_RSI_9113) {\n\t\trsi_dbg(ERR_ZONE, \"%s: 9113 module detected\\n\", __func__);\n\t\tadapter->device_model = RSI_DEV_9113;\n\t} else  if (pfunction->device == SDIO_DEVICE_ID_RSI_9116) {\n\t\trsi_dbg(ERR_ZONE, \"%s: 9116 module detected\\n\", __func__);\n\t\tadapter->device_model = RSI_DEV_9116;\n\t} else {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Unsupported RSI device id 0x%x\\n\", __func__,\n\t\t\tpfunction->device);\n\t\tgoto fail_free_adapter;\n\t}\n\n\tsdev = adapter->rsi_dev;\n\trsi_init_event(&sdev->rx_thread.event);\n\tstatus = rsi_create_kthread(adapter->priv, &sdev->rx_thread,\n\t\t\t\t    rsi_sdio_rx_thread, \"SDIO-RX-Thread\");\n\tif (status) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Unable to init rx thrd\\n\", __func__);\n\t\tgoto fail_kill_thread;\n\t}\n\n\tsdio_claim_host(pfunction);\n\tif (sdio_claim_irq(pfunction, rsi_handle_interrupt)) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed to request IRQ\\n\", __func__);\n\t\tsdio_release_host(pfunction);\n\t\tstatus = -EIO;\n\t\tgoto fail_claim_irq;\n\t}\n\tsdio_release_host(pfunction);\n\trsi_dbg(INIT_ZONE, \"%s: Registered Interrupt handler\\n\", __func__);\n\n\tif (rsi_hal_device_init(adapter)) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed in device init\\n\", __func__);\n\t\tstatus = -EINVAL;\n\t\tgoto fail_dev_init;\n\t}\n\trsi_dbg(INFO_ZONE, \"===> RSI Device Init Done <===\\n\");\n\n\tif (rsi_sdio_master_access_msword(adapter, MISC_CFG_BASE_ADDR)) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Unable to set ms word reg\\n\", __func__);\n\t\tstatus = -EIO;\n\t\tgoto fail_dev_init;\n\t}\n\n\tadapter->priv->hibernate_resume = false;\n\tadapter->priv->reinit_hw = false;\n\treturn 0;\n\nfail_dev_init:\n\tsdio_claim_host(pfunction);\n\tsdio_release_irq(pfunction);\n\tsdio_release_host(pfunction);\nfail_claim_irq:\n\trsi_kill_thread(&sdev->rx_thread);\nfail_kill_thread:\n\tsdio_claim_host(pfunction);\n\tsdio_disable_func(pfunction);\n\tsdio_release_host(pfunction);\nfail_free_adapter:\n\trsi_91x_deinit(adapter);\n\trsi_dbg(ERR_ZONE, \"%s: Failed in probe...Exiting\\n\", __func__);\n\treturn status;\n}\n\nstatic void ulp_read_write(struct rsi_hw *adapter, u16 addr, u32 data,\n\t\t\t   u16 len_in_bits)\n{\n\trsi_sdio_master_reg_write(adapter, RSI_GSPI_DATA_REG1,\n\t\t\t\t  ((addr << 6) | ((data >> 16) & 0xffff)), 2);\n\trsi_sdio_master_reg_write(adapter, RSI_GSPI_DATA_REG0,\n\t\t\t\t  (data & 0xffff), 2);\n\trsi_sdio_master_reg_write(adapter, RSI_GSPI_CTRL_REG0,\n\t\t\t\t  RSI_GSPI_CTRL_REG0_VALUE, 2);\n\trsi_sdio_master_reg_write(adapter, RSI_GSPI_CTRL_REG1,\n\t\t\t\t  ((len_in_bits - 1) | RSI_GSPI_TRIG), 2);\n\tmsleep(20);\n}\n\n \nstatic void rsi_reset_chip(struct rsi_hw *adapter)\n{\n\tu8 *data;\n\tu8 sdio_interrupt_status = 0;\n\tu8 request = 1;\n\tint ret;\n\n\tdata = kzalloc(sizeof(u32), GFP_KERNEL);\n\tif (!data)\n\t\treturn;\n\n\trsi_dbg(INFO_ZONE, \"Writing disable to wakeup register\\n\");\n\tret =  rsi_sdio_write_register(adapter, 0, SDIO_WAKEUP_REG, &request);\n\tif (ret < 0) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Failed to write SDIO wakeup register\\n\", __func__);\n\t\tgoto err;\n\t}\n\tmsleep(20);\n\tret =  rsi_sdio_read_register(adapter, RSI_FN1_INT_REGISTER,\n\t\t\t\t      &sdio_interrupt_status);\n\tif (ret < 0) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed to Read Intr Status Register\\n\",\n\t\t\t__func__);\n\t\tgoto err;\n\t}\n\trsi_dbg(INFO_ZONE, \"%s: Intr Status Register value = %d\\n\",\n\t\t__func__, sdio_interrupt_status);\n\n\t \n\tif (rsi_sdio_master_access_msword(adapter, TA_BASE_ADDR)) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Unable to set ms word to common reg\\n\",\n\t\t\t__func__);\n\t\tgoto err;\n\t}\n\n\tput_unaligned_le32(TA_HOLD_THREAD_VALUE, data);\n\tif (rsi_sdio_write_register_multiple(adapter, TA_HOLD_THREAD_REG |\n\t\t\t\t\t     RSI_SD_REQUEST_MASTER,\n\t\t\t\t\t     data, 4)) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Unable to hold Thread-Arch processor threads\\n\",\n\t\t\t__func__);\n\t\tgoto err;\n\t}\n\n\t \n\tmsleep(100);\n\tif (adapter->device_model != RSI_DEV_9116) {\n\t\tulp_read_write(adapter, RSI_ULP_RESET_REG, RSI_ULP_WRITE_0, 32);\n\t\tulp_read_write(adapter,\n\t\t\t       RSI_WATCH_DOG_TIMER_1, RSI_ULP_WRITE_2, 32);\n\t\tulp_read_write(adapter, RSI_WATCH_DOG_TIMER_2, RSI_ULP_WRITE_0,\n\t\t\t       32);\n\t\tulp_read_write(adapter, RSI_WATCH_DOG_DELAY_TIMER_1,\n\t\t\t       RSI_ULP_WRITE_50, 32);\n\t\tulp_read_write(adapter, RSI_WATCH_DOG_DELAY_TIMER_2,\n\t\t\t       RSI_ULP_WRITE_0, 32);\n\t\tulp_read_write(adapter, RSI_WATCH_DOG_TIMER_ENABLE,\n\t\t\t       RSI_ULP_TIMER_ENABLE, 32);\n\t} else {\n\t\tif ((rsi_sdio_master_reg_write(adapter,\n\t\t\t\t\t       NWP_WWD_INTERRUPT_TIMER,\n\t\t\t\t\t       NWP_WWD_INT_TIMER_CLKS,\n\t\t\t\t\t       RSI_9116_REG_SIZE)) < 0) {\n\t\t\trsi_dbg(ERR_ZONE, \"Failed to write to intr timer\\n\");\n\t\t}\n\t\tif ((rsi_sdio_master_reg_write(adapter,\n\t\t\t\t\t       NWP_WWD_SYSTEM_RESET_TIMER,\n\t\t\t\t\t       NWP_WWD_SYS_RESET_TIMER_CLKS,\n\t\t\t\t\t       RSI_9116_REG_SIZE)) < 0) {\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"Failed to write to system reset timer\\n\");\n\t\t}\n\t\tif ((rsi_sdio_master_reg_write(adapter,\n\t\t\t\t\t       NWP_WWD_MODE_AND_RSTART,\n\t\t\t\t\t       NWP_WWD_TIMER_DISABLE,\n\t\t\t\t\t       RSI_9116_REG_SIZE)) < 0) {\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"Failed to write to mode and restart\\n\");\n\t\t}\n\t\trsi_dbg(ERR_ZONE, \"***** Watch Dog Reset Successful *****\\n\");\n\t}\n\t \n\tmsleep(500);\nerr:\n\tkfree(data);\n\treturn;\n}\n\n \nstatic void rsi_disconnect(struct sdio_func *pfunction)\n{\n\tstruct rsi_hw *adapter = sdio_get_drvdata(pfunction);\n\tstruct rsi_91x_sdiodev *dev;\n\n\tif (!adapter)\n\t\treturn;\n\n\tdev = adapter->rsi_dev;\n\n\trsi_kill_thread(&dev->rx_thread);\n\tsdio_claim_host(pfunction);\n\tsdio_release_irq(pfunction);\n\tsdio_release_host(pfunction);\n\tmdelay(10);\n\n\trsi_mac80211_detach(adapter);\n\tmdelay(10);\n\n\tif (IS_ENABLED(CONFIG_RSI_COEX) && adapter->priv->coex_mode > 1 &&\n\t    adapter->priv->bt_adapter) {\n\t\trsi_bt_ops.detach(adapter->priv->bt_adapter);\n\t\tadapter->priv->bt_adapter = NULL;\n\t}\n\n\t \n\trsi_reset_chip(adapter);\n\n\t \n\tsdio_claim_host(pfunction);\n\trsi_reset_card(pfunction);\n\tsdio_disable_func(pfunction);\n\tsdio_release_host(pfunction);\n\tdev->write_fail = 2;\n\trsi_91x_deinit(adapter);\n\trsi_dbg(ERR_ZONE, \"##### RSI SDIO device disconnected #####\\n\");\n\n}\n\n#ifdef CONFIG_PM\nstatic int rsi_set_sdio_pm_caps(struct rsi_hw *adapter)\n{\n\tstruct rsi_91x_sdiodev *dev = adapter->rsi_dev;\n\tstruct sdio_func *func = dev->pfunction;\n\tint ret;\n\n\tret = sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);\n\tif (ret)\n\t\trsi_dbg(ERR_ZONE, \"Set sdio keep pwr flag failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int rsi_sdio_disable_interrupts(struct sdio_func *pfunc)\n{\n\tstruct rsi_hw *adapter = sdio_get_drvdata(pfunc);\n\tu8 isr_status = 0, data = 0;\n\tint ret;\n\tunsigned long t1;\n\n\trsi_dbg(INFO_ZONE, \"Waiting for interrupts to be cleared..\");\n\tt1 = jiffies;\n\tdo {\n\t\trsi_sdio_read_register(adapter, RSI_FN1_INT_REGISTER,\n\t\t\t\t       &isr_status);\n\t\trsi_dbg(INFO_ZONE, \".\");\n\t} while ((isr_status) && (jiffies_to_msecs(jiffies - t1) < 20));\n\trsi_dbg(INFO_ZONE, \"Interrupts cleared\\n\");\n\n\tsdio_claim_host(pfunc);\n\tret = rsi_cmd52readbyte(pfunc->card, RSI_INT_ENABLE_REGISTER, &data);\n\tif (ret < 0) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Failed to read int enable register\\n\",\n\t\t\t__func__);\n\t\tgoto done;\n\t}\n\n\tdata &= RSI_INT_ENABLE_MASK;\n\tret = rsi_cmd52writebyte(pfunc->card, RSI_INT_ENABLE_REGISTER, data);\n\tif (ret < 0) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Failed to write to int enable register\\n\",\n\t\t\t__func__);\n\t\tgoto done;\n\t}\n\tret = rsi_cmd52readbyte(pfunc->card, RSI_INT_ENABLE_REGISTER, &data);\n\tif (ret < 0) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Failed to read int enable register\\n\",\n\t\t\t__func__);\n\t\tgoto done;\n\t}\n\trsi_dbg(INFO_ZONE, \"int enable reg content = %x\\n\", data);\n\ndone:\n\tsdio_release_host(pfunc);\n\treturn ret;\n}\n\nstatic int rsi_sdio_enable_interrupts(struct sdio_func *pfunc)\n{\n\tu8 data;\n\tint ret;\n\tstruct rsi_hw *adapter = sdio_get_drvdata(pfunc);\n\tstruct rsi_common *common = adapter->priv;\n\n\tsdio_claim_host(pfunc);\n\tret = rsi_cmd52readbyte(pfunc->card, RSI_INT_ENABLE_REGISTER, &data);\n\tif (ret < 0) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Failed to read int enable register\\n\", __func__);\n\t\tgoto done;\n\t}\n\n\tdata |= ~RSI_INT_ENABLE_MASK & 0xff;\n\n\tret = rsi_cmd52writebyte(pfunc->card, RSI_INT_ENABLE_REGISTER, data);\n\tif (ret < 0) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Failed to write to int enable register\\n\",\n\t\t\t__func__);\n\t\tgoto done;\n\t}\n\n\tif ((common->wow_flags & RSI_WOW_ENABLED) &&\n\t    (common->wow_flags & RSI_WOW_NO_CONNECTION))\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"##### Device can not wake up through WLAN\\n\");\n\n\tret = rsi_cmd52readbyte(pfunc->card, RSI_INT_ENABLE_REGISTER, &data);\n\tif (ret < 0) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Failed to read int enable register\\n\", __func__);\n\t\tgoto done;\n\t}\n\trsi_dbg(INFO_ZONE, \"int enable reg content = %x\\n\", data);\n\ndone:\n\tsdio_release_host(pfunc);\n\treturn ret;\n}\n\nstatic int rsi_suspend(struct device *dev)\n{\n\tint ret;\n\tstruct sdio_func *pfunction = dev_to_sdio_func(dev);\n\tstruct rsi_hw *adapter = sdio_get_drvdata(pfunction);\n\tstruct rsi_common *common;\n\n\tif (!adapter) {\n\t\trsi_dbg(ERR_ZONE, \"Device is not ready\\n\");\n\t\treturn -ENODEV;\n\t}\n\tcommon = adapter->priv;\n\trsi_sdio_disable_interrupts(pfunction);\n\n\tret = rsi_set_sdio_pm_caps(adapter);\n\tif (ret)\n\t\trsi_dbg(INFO_ZONE,\n\t\t\t\"Setting power management caps failed\\n\");\n\tcommon->fsm_state = FSM_CARD_NOT_READY;\n\n\treturn 0;\n}\n\nstatic int rsi_resume(struct device *dev)\n{\n\tstruct sdio_func *pfunction = dev_to_sdio_func(dev);\n\tstruct rsi_hw *adapter = sdio_get_drvdata(pfunction);\n\tstruct rsi_common *common = adapter->priv;\n\n\tcommon->fsm_state = FSM_MAC_INIT_DONE;\n\trsi_sdio_enable_interrupts(pfunction);\n\n\treturn 0;\n}\n\nstatic int rsi_freeze(struct device *dev)\n{\n\tint ret;\n\tstruct sdio_func *pfunction = dev_to_sdio_func(dev);\n\tstruct rsi_hw *adapter = sdio_get_drvdata(pfunction);\n\tstruct rsi_common *common;\n\tstruct rsi_91x_sdiodev *sdev;\n\n\trsi_dbg(INFO_ZONE, \"SDIO Bus freeze ===>\\n\");\n\n\tif (!adapter) {\n\t\trsi_dbg(ERR_ZONE, \"Device is not ready\\n\");\n\t\treturn -ENODEV;\n\t}\n\tcommon = adapter->priv;\n\tsdev = adapter->rsi_dev;\n\n\tif ((common->wow_flags & RSI_WOW_ENABLED) &&\n\t    (common->wow_flags & RSI_WOW_NO_CONNECTION))\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"##### Device can not wake up through WLAN\\n\");\n\n\tif (IS_ENABLED(CONFIG_RSI_COEX) && common->coex_mode > 1 &&\n\t    common->bt_adapter) {\n\t\trsi_bt_ops.detach(common->bt_adapter);\n\t\tcommon->bt_adapter = NULL;\n\t}\n\n\tret = rsi_sdio_disable_interrupts(pfunction);\n\n\tif (sdev->write_fail)\n\t\trsi_dbg(INFO_ZONE, \"###### Device is not ready #######\\n\");\n\n\tret = rsi_set_sdio_pm_caps(adapter);\n\tif (ret)\n\t\trsi_dbg(INFO_ZONE, \"Setting power management caps failed\\n\");\n\n\trsi_dbg(INFO_ZONE, \"***** RSI module freezed *****\\n\");\n\n\treturn 0;\n}\n\nstatic int rsi_thaw(struct device *dev)\n{\n\tstruct sdio_func *pfunction = dev_to_sdio_func(dev);\n\tstruct rsi_hw *adapter = sdio_get_drvdata(pfunction);\n\tstruct rsi_common *common = adapter->priv;\n\n\trsi_dbg(ERR_ZONE, \"SDIO Bus thaw =====>\\n\");\n\n\tcommon->hibernate_resume = true;\n\tcommon->fsm_state = FSM_CARD_NOT_READY;\n\tcommon->iface_down = true;\n\n\trsi_sdio_enable_interrupts(pfunction);\n\n\trsi_dbg(INFO_ZONE, \"***** RSI module thaw done *****\\n\");\n\n\treturn 0;\n}\n\nstatic void rsi_shutdown(struct device *dev)\n{\n\tstruct sdio_func *pfunction = dev_to_sdio_func(dev);\n\tstruct rsi_hw *adapter = sdio_get_drvdata(pfunction);\n\tstruct rsi_91x_sdiodev *sdev = adapter->rsi_dev;\n\tstruct ieee80211_hw *hw = adapter->hw;\n\n\trsi_dbg(ERR_ZONE, \"SDIO Bus shutdown =====>\\n\");\n\n\tif (hw && hw->wiphy && hw->wiphy->wowlan_config) {\n\t\tif (rsi_config_wowlan(adapter, hw->wiphy->wowlan_config))\n\t\t\trsi_dbg(ERR_ZONE, \"Failed to configure WoWLAN\\n\");\n\t}\n\n\tif (IS_ENABLED(CONFIG_RSI_COEX) && adapter->priv->coex_mode > 1 &&\n\t    adapter->priv->bt_adapter) {\n\t\trsi_bt_ops.detach(adapter->priv->bt_adapter);\n\t\tadapter->priv->bt_adapter = NULL;\n\t}\n\n\trsi_sdio_disable_interrupts(sdev->pfunction);\n\n\tif (sdev->write_fail)\n\t\trsi_dbg(INFO_ZONE, \"###### Device is not ready #######\\n\");\n\n\trsi_dbg(INFO_ZONE, \"***** RSI module shut down *****\\n\");\n}\n\nstatic int rsi_restore(struct device *dev)\n{\n\tstruct sdio_func *pfunction = dev_to_sdio_func(dev);\n\tstruct rsi_hw *adapter = sdio_get_drvdata(pfunction);\n\tstruct rsi_common *common = adapter->priv;\n\n\trsi_dbg(INFO_ZONE, \"SDIO Bus restore ======>\\n\");\n\tcommon->hibernate_resume = true;\n\tcommon->fsm_state = FSM_FW_NOT_LOADED;\n\tcommon->iface_down = true;\n\n\tadapter->sc_nvifs = 0;\n\tadapter->ps_state = PS_NONE;\n\n\tcommon->wow_flags = 0;\n\tcommon->iface_down = false;\n\n\trsi_dbg(INFO_ZONE, \"RSI module restored\\n\");\n\n\treturn 0;\n}\nstatic const struct dev_pm_ops rsi_pm_ops = {\n\t.suspend = rsi_suspend,\n\t.resume_noirq = rsi_resume,\n\t.freeze = rsi_freeze,\n\t.thaw = rsi_thaw,\n\t.restore = rsi_restore,\n};\n#endif\n\nstatic const struct sdio_device_id rsi_dev_table[] =  {\n\t{ SDIO_DEVICE(SDIO_VENDOR_ID_RSI, SDIO_DEVICE_ID_RSI_9113) },\n\t{ SDIO_DEVICE(SDIO_VENDOR_ID_RSI, SDIO_DEVICE_ID_RSI_9116) },\n\t{  },\n};\n\nstatic struct sdio_driver rsi_driver = {\n\t.name       = \"RSI-SDIO WLAN\",\n\t.probe      = rsi_probe,\n\t.remove     = rsi_disconnect,\n\t.id_table   = rsi_dev_table,\n#ifdef CONFIG_PM\n\t.drv = {\n\t\t.pm = &rsi_pm_ops,\n\t\t.shutdown   = rsi_shutdown,\n\t}\n#endif\n};\n\n \nstatic int rsi_module_init(void)\n{\n\tint ret;\n\n\tret = sdio_register_driver(&rsi_driver);\n\trsi_dbg(INIT_ZONE, \"%s: Registering driver\\n\", __func__);\n\treturn ret;\n}\n\n \nstatic void rsi_module_exit(void)\n{\n\tsdio_unregister_driver(&rsi_driver);\n\trsi_dbg(INFO_ZONE, \"%s: Unregistering driver\\n\", __func__);\n}\n\nmodule_init(rsi_module_init);\nmodule_exit(rsi_module_exit);\n\nMODULE_AUTHOR(\"Redpine Signals Inc\");\nMODULE_DESCRIPTION(\"Common SDIO layer for RSI drivers\");\nMODULE_DEVICE_TABLE(sdio, rsi_dev_table);\nMODULE_FIRMWARE(FIRMWARE_RSI9113);\nMODULE_VERSION(\"0.1\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}