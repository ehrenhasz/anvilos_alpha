{
  "module_name": "rsi_91x_mac80211.c",
  "hash_id": "d376277796f8dbaa4f0f231bb45fc7d585f409c1ef834e552c399f3b3d92ed29",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/rsi/rsi_91x_mac80211.c",
  "human_readable_source": " \n\n#include <linux/etherdevice.h>\n#include \"rsi_debugfs.h\"\n#include \"rsi_mgmt.h\"\n#include \"rsi_sdio.h\"\n#include \"rsi_common.h\"\n#include \"rsi_ps.h\"\n\nstatic const struct ieee80211_channel rsi_2ghz_channels[] = {\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2412,\n\t  .hw_value = 1 },  \n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2417,\n\t  .hw_value = 2 },  \n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2422,\n\t  .hw_value = 3 },  \n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2427,\n\t  .hw_value = 4 },  \n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2432,\n\t  .hw_value = 5 },  \n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2437,\n\t  .hw_value = 6 },  \n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2442,\n\t  .hw_value = 7 },  \n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2447,\n\t  .hw_value = 8 },  \n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2452,\n\t  .hw_value = 9 },  \n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2457,\n\t  .hw_value = 10 },  \n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2462,\n\t  .hw_value = 11 },  \n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2467,\n\t  .hw_value = 12 },  \n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2472,\n\t  .hw_value = 13 },  \n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2484,\n\t  .hw_value = 14 },  \n};\n\nstatic const struct ieee80211_channel rsi_5ghz_channels[] = {\n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5180,\n\t  .hw_value = 36,  },  \n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5200,\n\t  .hw_value = 40, },  \n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5220,\n\t  .hw_value = 44, },  \n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5240,\n\t  .hw_value = 48, },  \n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5260,\n\t  .hw_value = 52, },  \n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5280,\n\t  .hw_value = 56, },  \n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5300,\n\t  .hw_value = 60, },  \n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5320,\n\t  .hw_value = 64, },  \n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5500,\n\t  .hw_value = 100, },  \n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5520,\n\t  .hw_value = 104, },  \n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5540,\n\t  .hw_value = 108, },  \n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5560,\n\t  .hw_value = 112, },  \n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5580,\n\t  .hw_value = 116, },  \n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5600,\n\t  .hw_value = 120, },  \n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5620,\n\t  .hw_value = 124, },  \n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5640,\n\t  .hw_value = 128, },  \n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5660,\n\t  .hw_value = 132, },  \n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5680,\n\t  .hw_value = 136, },  \n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5700,\n\t  .hw_value = 140, },  \n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5745,\n\t  .hw_value = 149, },  \n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5765,\n\t  .hw_value = 153, },  \n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5785,\n\t  .hw_value = 157, },  \n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5805,\n\t  .hw_value = 161, },  \n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5825,\n\t  .hw_value = 165, },  \n};\n\nstruct ieee80211_rate rsi_rates[12] = {\n\t{ .bitrate = STD_RATE_01  * 5, .hw_value = RSI_RATE_1 },\n\t{ .bitrate = STD_RATE_02  * 5, .hw_value = RSI_RATE_2 },\n\t{ .bitrate = STD_RATE_5_5 * 5, .hw_value = RSI_RATE_5_5 },\n\t{ .bitrate = STD_RATE_11  * 5, .hw_value = RSI_RATE_11 },\n\t{ .bitrate = STD_RATE_06  * 5, .hw_value = RSI_RATE_6 },\n\t{ .bitrate = STD_RATE_09  * 5, .hw_value = RSI_RATE_9 },\n\t{ .bitrate = STD_RATE_12  * 5, .hw_value = RSI_RATE_12 },\n\t{ .bitrate = STD_RATE_18  * 5, .hw_value = RSI_RATE_18 },\n\t{ .bitrate = STD_RATE_24  * 5, .hw_value = RSI_RATE_24 },\n\t{ .bitrate = STD_RATE_36  * 5, .hw_value = RSI_RATE_36 },\n\t{ .bitrate = STD_RATE_48  * 5, .hw_value = RSI_RATE_48 },\n\t{ .bitrate = STD_RATE_54  * 5, .hw_value = RSI_RATE_54 },\n};\n\nconst u16 rsi_mcsrates[8] = {\n\tRSI_RATE_MCS0, RSI_RATE_MCS1, RSI_RATE_MCS2, RSI_RATE_MCS3,\n\tRSI_RATE_MCS4, RSI_RATE_MCS5, RSI_RATE_MCS6, RSI_RATE_MCS7\n};\n\nstatic const u32 rsi_max_ap_stas[16] = {\n\t32,\t \n\t0,\t \n\t0,\t \n\t0,\t \n\t4,\t \n\t32,\t \n\t0,\t \n\t0,\t \n\t4,\t \n\t0,\t \n\t0,\t \n\t0,\t \n\t1,\t \n\t4,\t \n};\n\nstatic const struct ieee80211_iface_limit rsi_iface_limits[] = {\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_STATION),\n\t},\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_AP) |\n\t\t\tBIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\t\tBIT(NL80211_IFTYPE_P2P_GO),\n\t},\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_P2P_DEVICE),\n\t},\n};\n\nstatic const struct ieee80211_iface_combination rsi_iface_combinations[] = {\n\t{\n\t\t.num_different_channels = 1,\n\t\t.max_interfaces = 3,\n\t\t.limits = rsi_iface_limits,\n\t\t.n_limits = ARRAY_SIZE(rsi_iface_limits),\n\t},\n};\n\n \n\nbool rsi_is_cipher_wep(struct rsi_common *common)\n{\n\tif (((common->secinfo.gtk_cipher == WLAN_CIPHER_SUITE_WEP104) ||\n\t     (common->secinfo.gtk_cipher == WLAN_CIPHER_SUITE_WEP40)) &&\n\t    (!common->secinfo.ptk_cipher))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n \nstatic int rsi_register_rates_channels(struct rsi_hw *adapter, int band)\n{\n\tstruct ieee80211_supported_band *sbands = &adapter->sbands[band];\n\tvoid *channels = NULL;\n\n\tif (band == NL80211_BAND_2GHZ) {\n\t\tchannels = kmemdup(rsi_2ghz_channels, sizeof(rsi_2ghz_channels),\n\t\t\t\t   GFP_KERNEL);\n\t\tif (!channels)\n\t\t\treturn -ENOMEM;\n\t\tsbands->band = NL80211_BAND_2GHZ;\n\t\tsbands->n_channels = ARRAY_SIZE(rsi_2ghz_channels);\n\t\tsbands->bitrates = rsi_rates;\n\t\tsbands->n_bitrates = ARRAY_SIZE(rsi_rates);\n\t} else {\n\t\tchannels = kmemdup(rsi_5ghz_channels, sizeof(rsi_5ghz_channels),\n\t\t\t\t   GFP_KERNEL);\n\t\tif (!channels)\n\t\t\treturn -ENOMEM;\n\t\tsbands->band = NL80211_BAND_5GHZ;\n\t\tsbands->n_channels = ARRAY_SIZE(rsi_5ghz_channels);\n\t\tsbands->bitrates = &rsi_rates[4];\n\t\tsbands->n_bitrates = ARRAY_SIZE(rsi_rates) - 4;\n\t}\n\n\tsbands->channels = channels;\n\n\tmemset(&sbands->ht_cap, 0, sizeof(struct ieee80211_sta_ht_cap));\n\tsbands->ht_cap.ht_supported = true;\n\tsbands->ht_cap.cap = (IEEE80211_HT_CAP_SUP_WIDTH_20_40 |\n\t\t\t      IEEE80211_HT_CAP_SGI_20 |\n\t\t\t      IEEE80211_HT_CAP_SGI_40);\n\tsbands->ht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_16K;\n\tsbands->ht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_NONE;\n\tsbands->ht_cap.mcs.rx_mask[0] = 0xff;\n\tsbands->ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\n\t \n\treturn 0;\n}\n\nstatic int rsi_mac80211_hw_scan_start(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_scan_request *hw_req)\n{\n\tstruct cfg80211_scan_request *scan_req = &hw_req->req;\n\tstruct rsi_hw *adapter = hw->priv;\n\tstruct rsi_common *common = adapter->priv;\n\n\trsi_dbg(INFO_ZONE, \"***** Hardware scan start *****\\n\");\n\tcommon->mac_ops_resumed = false;\n\n\tif (common->fsm_state != FSM_MAC_INIT_DONE)\n\t\treturn -ENODEV;\n\n\tif ((common->wow_flags & RSI_WOW_ENABLED) ||\n\t    scan_req->n_channels == 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (common->bgscan_en)\n\t\treturn -EBUSY;\n\n\t \n\tif (!vif->cfg.assoc)\n\t\treturn 1;\n\n\tmutex_lock(&common->mutex);\n\tcommon->hwscan = scan_req;\n\tif (!rsi_send_bgscan_params(common, RSI_START_BGSCAN)) {\n\t\tif (!rsi_send_bgscan_probe_req(common, vif)) {\n\t\t\trsi_dbg(INFO_ZONE, \"Background scan started...\\n\");\n\t\t\tcommon->bgscan_en = true;\n\t\t}\n\t}\n\tmutex_unlock(&common->mutex);\n\n\treturn 0;\n}\n\nstatic void rsi_mac80211_cancel_hw_scan(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct rsi_hw *adapter = hw->priv;\n\tstruct rsi_common *common = adapter->priv;\n\tstruct cfg80211_scan_info info;\n\n\trsi_dbg(INFO_ZONE, \"***** Hardware scan stop *****\\n\");\n\tmutex_lock(&common->mutex);\n\n\tif (common->bgscan_en) {\n\t\tif (!rsi_send_bgscan_params(common, RSI_STOP_BGSCAN))\n\t\t\tcommon->bgscan_en = false;\n\t\tinfo.aborted = false;\n\t\tieee80211_scan_completed(adapter->hw, &info);\n\t\trsi_dbg(INFO_ZONE, \"Back ground scan cancelled\\n\");\n\t}\n\tcommon->hwscan = NULL;\n\tmutex_unlock(&common->mutex);\n}\n\n \nvoid rsi_mac80211_detach(struct rsi_hw *adapter)\n{\n\tstruct ieee80211_hw *hw = adapter->hw;\n\tenum nl80211_band band;\n\n\tif (hw) {\n\t\tieee80211_stop_queues(hw);\n\t\tieee80211_unregister_hw(hw);\n\t\tieee80211_free_hw(hw);\n\t\tadapter->hw = NULL;\n\t}\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\t\t\t&adapter->sbands[band];\n\n\t\tkfree(sband->channels);\n\t}\n\n#ifdef CONFIG_RSI_DEBUGFS\n\trsi_remove_dbgfs(adapter);\n\tkfree(adapter->dfsentry);\n#endif\n}\nEXPORT_SYMBOL_GPL(rsi_mac80211_detach);\n\n \nvoid rsi_indicate_tx_status(struct rsi_hw *adapter,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    int status)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct skb_info *tx_params;\n\n\tif (!adapter->hw) {\n\t\trsi_dbg(ERR_ZONE, \"##### No MAC #####\\n\");\n\t\treturn;\n\t}\n\n\tif (!status)\n\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\n\ttx_params = (struct skb_info *)info->driver_data;\n\tskb_pull(skb, tx_params->internal_hdr_size);\n\tmemset(info->driver_data, 0, IEEE80211_TX_INFO_DRIVER_DATA_SIZE);\n\n\tieee80211_tx_status_irqsafe(adapter->hw, skb);\n}\n\n \nstatic void rsi_mac80211_tx(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_tx_control *control,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct rsi_hw *adapter = hw->priv;\n\tstruct rsi_common *common = adapter->priv;\n\tstruct ieee80211_hdr *wlh = (struct ieee80211_hdr *)skb->data;\n\n\tif (ieee80211_is_auth(wlh->frame_control))\n\t\tcommon->mac_ops_resumed = false;\n\n\trsi_core_xmit(common, skb);\n}\n\n \nstatic int rsi_mac80211_start(struct ieee80211_hw *hw)\n{\n\tstruct rsi_hw *adapter = hw->priv;\n\tstruct rsi_common *common = adapter->priv;\n\n\trsi_dbg(ERR_ZONE, \"===> Interface UP <===\\n\");\n\tmutex_lock(&common->mutex);\n\tif (common->hibernate_resume) {\n\t\tcommon->reinit_hw = true;\n\t\tadapter->host_intf_ops->reinit_device(adapter);\n\t\twait_for_completion(&adapter->priv->wlan_init_completion);\n\t}\n\tcommon->iface_down = false;\n\twiphy_rfkill_start_polling(hw->wiphy);\n\trsi_send_rx_filter_frame(common, 0);\n\tmutex_unlock(&common->mutex);\n\n\treturn 0;\n}\n\n \nstatic void rsi_mac80211_stop(struct ieee80211_hw *hw)\n{\n\tstruct rsi_hw *adapter = hw->priv;\n\tstruct rsi_common *common = adapter->priv;\n\n\trsi_dbg(ERR_ZONE, \"===> Interface DOWN <===\\n\");\n\tmutex_lock(&common->mutex);\n\tcommon->iface_down = true;\n\twiphy_rfkill_stop_polling(hw->wiphy);\n\n\t \n\trsi_send_rx_filter_frame(common, 0xffff);\n\n\tmutex_unlock(&common->mutex);\n}\n\nstatic int rsi_map_intf_mode(enum nl80211_iftype vif_type)\n{\n\tswitch (vif_type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\treturn RSI_OPMODE_STA;\n\tcase NL80211_IFTYPE_AP:\n\t\treturn RSI_OPMODE_AP;\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\treturn RSI_OPMODE_P2P_CLIENT;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\treturn RSI_OPMODE_P2P_CLIENT;\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\treturn RSI_OPMODE_P2P_GO;\n\tdefault:\n\t\treturn RSI_OPMODE_UNSUPPORTED;\n\t}\n}\n\n \nstatic int rsi_mac80211_add_interface(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct rsi_hw *adapter = hw->priv;\n\tstruct rsi_common *common = adapter->priv;\n\tstruct vif_priv *vif_info = (struct vif_priv *)vif->drv_priv;\n\tenum opmode intf_mode;\n\tenum vap_status vap_status;\n\tint vap_idx = -1, i;\n\n\tvif->driver_flags |= IEEE80211_VIF_SUPPORTS_UAPSD;\n\tmutex_lock(&common->mutex);\n\n\tintf_mode = rsi_map_intf_mode(vif->type);\n\tif (intf_mode == RSI_OPMODE_UNSUPPORTED) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Interface type %d not supported\\n\", __func__,\n\t\t\tvif->type);\n\t\tmutex_unlock(&common->mutex);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif ((vif->type == NL80211_IFTYPE_P2P_DEVICE) ||\n\t    (vif->type == NL80211_IFTYPE_P2P_CLIENT) ||\n\t    (vif->type == NL80211_IFTYPE_P2P_GO))\n\t\tcommon->p2p_enabled = true;\n\n\t \n\tfor (i = 0; i < RSI_MAX_VIFS; i++) {\n\t\tif (!adapter->vifs[i] ||\n\t\t    !memcmp(vif->addr, adapter->vifs[i]->addr, ETH_ALEN)) {\n\t\t\tvap_idx = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (vap_idx < 0) {\n\t\trsi_dbg(ERR_ZONE, \"Reject: Max VAPs reached\\n\");\n\t\tmutex_unlock(&common->mutex);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tvif_info->vap_id = vap_idx;\n\tadapter->vifs[vap_idx] = vif;\n\tadapter->sc_nvifs++;\n\tvap_status = VAP_ADD;\n\n\tif (rsi_set_vap_capabilities(common, intf_mode, vif->addr,\n\t\t\t\t     vif_info->vap_id, vap_status)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to set VAP capabilities\\n\");\n\t\tmutex_unlock(&common->mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((vif->type == NL80211_IFTYPE_AP) ||\n\t    (vif->type == NL80211_IFTYPE_P2P_GO)) {\n\t\trsi_send_rx_filter_frame(common, DISALLOW_BEACONS);\n\t\tfor (i = 0; i < common->max_stations; i++)\n\t\t\tcommon->stations[i].sta = NULL;\n\t}\n\n\tmutex_unlock(&common->mutex);\n\n\treturn 0;\n}\n\n \nstatic void rsi_mac80211_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct rsi_hw *adapter = hw->priv;\n\tstruct rsi_common *common = adapter->priv;\n\tenum opmode opmode;\n\tint i;\n\n\trsi_dbg(INFO_ZONE, \"Remove Interface Called\\n\");\n\n\tmutex_lock(&common->mutex);\n\n\tif (adapter->sc_nvifs <= 0) {\n\t\tmutex_unlock(&common->mutex);\n\t\treturn;\n\t}\n\n\topmode = rsi_map_intf_mode(vif->type);\n\tif (opmode == RSI_OPMODE_UNSUPPORTED) {\n\t\trsi_dbg(ERR_ZONE, \"Opmode error : %d\\n\", opmode);\n\t\tmutex_unlock(&common->mutex);\n\t\treturn;\n\t}\n\tfor (i = 0; i < RSI_MAX_VIFS; i++) {\n\t\tif (!adapter->vifs[i])\n\t\t\tcontinue;\n\t\tif (vif == adapter->vifs[i]) {\n\t\t\trsi_set_vap_capabilities(common, opmode, vif->addr,\n\t\t\t\t\t\t i, VAP_DELETE);\n\t\t\tadapter->sc_nvifs--;\n\t\t\tadapter->vifs[i] = NULL;\n\t\t}\n\t}\n\tmutex_unlock(&common->mutex);\n}\n\n \nstatic int rsi_channel_change(struct ieee80211_hw *hw)\n{\n\tstruct rsi_hw *adapter = hw->priv;\n\tstruct rsi_common *common = adapter->priv;\n\tint status = -EOPNOTSUPP;\n\tstruct ieee80211_channel *curchan = hw->conf.chandef.chan;\n\tu16 channel = curchan->hw_value;\n\tstruct ieee80211_vif *vif;\n\tbool assoc = false;\n\tint i;\n\n\trsi_dbg(INFO_ZONE,\n\t\t\"%s: Set channel: %d MHz type: %d channel_no %d\\n\",\n\t\t__func__, curchan->center_freq,\n\t\tcurchan->flags, channel);\n\n\tfor (i = 0; i < RSI_MAX_VIFS; i++) {\n\t\tvif = adapter->vifs[i];\n\t\tif (!vif)\n\t\t\tcontinue;\n\t\tif (vif->type == NL80211_IFTYPE_STATION) {\n\t\t\tif (vif->cfg.assoc) {\n\t\t\t\tassoc = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (assoc) {\n\t\tif (!common->hw_data_qs_blocked &&\n\t\t    (rsi_get_connected_channel(vif) != channel)) {\n\t\t\trsi_dbg(INFO_ZONE, \"blk data q %d\\n\", channel);\n\t\t\tif (!rsi_send_block_unblock_frame(common, true))\n\t\t\t\tcommon->hw_data_qs_blocked = true;\n\t\t}\n\t}\n\n\tstatus = rsi_band_check(common, curchan);\n\tif (!status)\n\t\tstatus = rsi_set_channel(adapter->priv, curchan);\n\n\tif (assoc) {\n\t\tif (common->hw_data_qs_blocked &&\n\t\t    (rsi_get_connected_channel(vif) == channel)) {\n\t\t\trsi_dbg(INFO_ZONE, \"unblk data q %d\\n\", channel);\n\t\t\tif (!rsi_send_block_unblock_frame(common, false))\n\t\t\t\tcommon->hw_data_qs_blocked = false;\n\t\t}\n\t}\n\n\treturn status;\n}\n\n \nstatic int rsi_config_power(struct ieee80211_hw *hw)\n{\n\tstruct rsi_hw *adapter = hw->priv;\n\tstruct rsi_common *common = adapter->priv;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\n\tif (adapter->sc_nvifs <= 0) {\n\t\trsi_dbg(ERR_ZONE, \"%s: No virtual interface found\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\trsi_dbg(INFO_ZONE,\n\t\t\"%s: Set tx power: %d dBM\\n\", __func__, conf->power_level);\n\n\tif (conf->power_level == common->tx_power)\n\t\treturn 0;\n\n\tcommon->tx_power = conf->power_level;\n\n\treturn rsi_send_radio_params_update(common);\n}\n\n \nstatic int rsi_mac80211_config(struct ieee80211_hw *hw,\n\t\t\t       u32 changed)\n{\n\tstruct rsi_hw *adapter = hw->priv;\n\tstruct rsi_common *common = adapter->priv;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tint status = -EOPNOTSUPP;\n\n\tmutex_lock(&common->mutex);\n\n\tif (changed & IEEE80211_CONF_CHANGE_CHANNEL)\n\t\tstatus = rsi_channel_change(hw);\n\n\t \n\tif (changed & IEEE80211_CONF_CHANGE_POWER) {\n\t\trsi_dbg(INFO_ZONE, \"%s: Configuring Power\\n\", __func__);\n\t\tstatus = rsi_config_power(hw);\n\t}\n\n\t \n\tif ((changed & IEEE80211_CONF_CHANGE_PS) &&\n\t    !common->mac_ops_resumed) {\n\t\tstruct ieee80211_vif *vif, *sta_vif = NULL;\n\t\tunsigned long flags;\n\t\tint i, set_ps = 1;\n\n\t\tfor (i = 0; i < RSI_MAX_VIFS; i++) {\n\t\t\tvif = adapter->vifs[i];\n\t\t\tif (!vif)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif ((vif->type == NL80211_IFTYPE_AP) ||\n\t\t\t    (vif->type == NL80211_IFTYPE_P2P_GO)) {\n\t\t\t\tset_ps = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((vif->type == NL80211_IFTYPE_STATION ||\n\t\t\t     vif->type == NL80211_IFTYPE_P2P_CLIENT) &&\n\t\t\t    (!sta_vif || vif->cfg.assoc))\n\t\t\t\tsta_vif = vif;\n\t\t}\n\t\tif (set_ps && sta_vif) {\n\t\t\tspin_lock_irqsave(&adapter->ps_lock, flags);\n\t\t\tif (conf->flags & IEEE80211_CONF_PS)\n\t\t\t\trsi_enable_ps(adapter, sta_vif);\n\t\t\telse\n\t\t\t\trsi_disable_ps(adapter, sta_vif);\n\t\t\tspin_unlock_irqrestore(&adapter->ps_lock, flags);\n\t\t}\n\t}\n\n\t \n\tif (changed & WIPHY_PARAM_RTS_THRESHOLD) {\n\t\trsi_dbg(INFO_ZONE, \"RTS threshold\\n\");\n\t\tif ((common->rts_threshold) <= IEEE80211_MAX_RTS_THRESHOLD) {\n\t\t\trsi_dbg(INFO_ZONE,\n\t\t\t\t\"%s: Sending vap updates....\\n\", __func__);\n\t\t\tstatus = rsi_send_vap_dynamic_update(common);\n\t\t}\n\t}\n\tmutex_unlock(&common->mutex);\n\n\treturn status;\n}\n\n \nu16 rsi_get_connected_channel(struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_bss_conf *bss;\n\tstruct ieee80211_channel *channel;\n\n\tif (!vif)\n\t\treturn 0;\n\n\tbss = &vif->bss_conf;\n\tchannel = bss->chandef.chan;\n\n\tif (!channel)\n\t\treturn 0;\n\n\treturn channel->hw_value;\n}\n\nstatic void rsi_switch_channel(struct rsi_hw *adapter,\n\t\t\t       struct ieee80211_vif *vif)\n{\n\tstruct rsi_common *common = adapter->priv;\n\tstruct ieee80211_channel *channel;\n\n\tif (common->iface_down)\n\t\treturn;\n\tif (!vif)\n\t\treturn;\n\n\tchannel = vif->bss_conf.chandef.chan;\n\n\tif (!channel)\n\t\treturn;\n\n\trsi_band_check(common, channel);\n\trsi_set_channel(common, channel);\n\trsi_dbg(INFO_ZONE, \"Switched to channel - %d\\n\", channel->hw_value);\n}\n\n \nstatic void rsi_mac80211_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  struct ieee80211_bss_conf *bss_conf,\n\t\t\t\t\t  u64 changed)\n{\n\tstruct rsi_hw *adapter = hw->priv;\n\tstruct rsi_common *common = adapter->priv;\n\tstruct ieee80211_bss_conf *bss = &vif->bss_conf;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tu16 rx_filter_word = 0;\n\n\tmutex_lock(&common->mutex);\n\tif (changed & BSS_CHANGED_ASSOC) {\n\t\trsi_dbg(INFO_ZONE, \"%s: Changed Association status: %d\\n\",\n\t\t\t__func__, vif->cfg.assoc);\n\t\tif (vif->cfg.assoc) {\n\t\t\t \n\t\t\trx_filter_word = (ALLOW_DATA_ASSOC_PEER |\n\t\t\t\t\t  ALLOW_CTRL_ASSOC_PEER |\n\t\t\t\t\t  ALLOW_MGMT_ASSOC_PEER);\n\t\t\trsi_send_rx_filter_frame(common, rx_filter_word);\n\t\t}\n\t\trsi_inform_bss_status(common,\n\t\t\t\t      RSI_OPMODE_STA,\n\t\t\t\t      vif->cfg.assoc,\n\t\t\t\t      bss_conf->bssid,\n\t\t\t\t      bss_conf->qos,\n\t\t\t\t      vif->cfg.aid,\n\t\t\t\t      NULL, 0,\n\t\t\t\t      bss_conf->assoc_capability, vif);\n\t\tadapter->ps_info.dtim_interval_duration = bss->dtim_period;\n\t\tadapter->ps_info.listen_interval = conf->listen_interval;\n\n\t\t \n\t\tif (vif->cfg.assoc) {\n\t\t\tif (common->uapsd_bitmap) {\n\t\t\t\trsi_dbg(INFO_ZONE, \"Configuring UAPSD\\n\");\n\t\t\t\trsi_conf_uapsd(adapter, vif);\n\t\t\t}\n\t\t} else {\n\t\t\tcommon->uapsd_bitmap = 0;\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_CQM) {\n\t\tcommon->cqm_info.last_cqm_event_rssi = 0;\n\t\tcommon->cqm_info.rssi_thold = bss_conf->cqm_rssi_thold;\n\t\tcommon->cqm_info.rssi_hyst = bss_conf->cqm_rssi_hyst;\n\t\trsi_dbg(INFO_ZONE, \"RSSI threshold & hysteresis are: %d %d\\n\",\n\t\t\tcommon->cqm_info.rssi_thold,\n\t\t\tcommon->cqm_info.rssi_hyst);\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON_INT) {\n\t\trsi_dbg(INFO_ZONE, \"%s: Changed Beacon interval: %d\\n\",\n\t\t\t__func__, bss_conf->beacon_int);\n\t\tif (common->beacon_interval != bss->beacon_int) {\n\t\t\tcommon->beacon_interval = bss->beacon_int;\n\t\t\tif (vif->type == NL80211_IFTYPE_AP) {\n\t\t\t\tstruct vif_priv *vif_info = (struct vif_priv *)vif->drv_priv;\n\n\t\t\t\trsi_set_vap_capabilities(common, RSI_OPMODE_AP,\n\t\t\t\t\t\t\t vif->addr, vif_info->vap_id,\n\t\t\t\t\t\t\t VAP_UPDATE);\n\t\t\t}\n\t\t}\n\t\tadapter->ps_info.listen_interval =\n\t\t\tbss->beacon_int * adapter->ps_info.num_bcns_per_lis_int;\n\t}\n\n\tif ((changed & BSS_CHANGED_BEACON_ENABLED) &&\n\t    ((vif->type == NL80211_IFTYPE_AP) ||\n\t     (vif->type == NL80211_IFTYPE_P2P_GO))) {\n\t\tif (bss->enable_beacon) {\n\t\t\trsi_dbg(INFO_ZONE, \"===> BEACON ENABLED <===\\n\");\n\t\t\tcommon->beacon_enabled = 1;\n\t\t} else {\n\t\t\trsi_dbg(INFO_ZONE, \"===> BEACON DISABLED <===\\n\");\n\t\t\tcommon->beacon_enabled = 0;\n\t\t}\n\t}\n\n\tmutex_unlock(&common->mutex);\n}\n\n \nstatic void rsi_mac80211_conf_filter(struct ieee80211_hw *hw,\n\t\t\t\t     u32 changed_flags,\n\t\t\t\t     u32 *total_flags,\n\t\t\t\t     u64 multicast)\n{\n\t \n\t*total_flags &= RSI_SUPP_FILTERS;\n}\n\n \nstatic int rsi_mac80211_conf_tx(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tunsigned int link_id, u16 queue,\n\t\t\t\tconst struct ieee80211_tx_queue_params *params)\n{\n\tstruct rsi_hw *adapter = hw->priv;\n\tstruct rsi_common *common = adapter->priv;\n\tu8 idx = 0;\n\n\tif (queue >= IEEE80211_NUM_ACS)\n\t\treturn 0;\n\n\trsi_dbg(INFO_ZONE,\n\t\t\"%s: Conf queue %d, aifs: %d, cwmin: %d cwmax: %d, txop: %d\\n\",\n\t\t__func__, queue, params->aifs,\n\t\tparams->cw_min, params->cw_max, params->txop);\n\n\tmutex_lock(&common->mutex);\n\t \n\tswitch (queue) {\n\tcase IEEE80211_AC_VO:\n\t\tidx = VO_Q;\n\t\tbreak;\n\tcase IEEE80211_AC_VI:\n\t\tidx = VI_Q;\n\t\tbreak;\n\tcase IEEE80211_AC_BE:\n\t\tidx = BE_Q;\n\t\tbreak;\n\tcase IEEE80211_AC_BK:\n\t\tidx = BK_Q;\n\t\tbreak;\n\tdefault:\n\t\tidx = BE_Q;\n\t\tbreak;\n\t}\n\n\tmemcpy(&common->edca_params[idx],\n\t       params,\n\t       sizeof(struct ieee80211_tx_queue_params));\n\n\tif (params->uapsd)\n\t\tcommon->uapsd_bitmap |= idx;\n\telse\n\t\tcommon->uapsd_bitmap &= (~idx);\n\n\tmutex_unlock(&common->mutex);\n\n\treturn 0;\n}\n\n \nstatic int rsi_hal_key_config(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_key_conf *key,\n\t\t\t      struct ieee80211_sta *sta)\n{\n\tstruct rsi_hw *adapter = hw->priv;\n\tstruct rsi_sta *rsta = NULL;\n\tint status;\n\tu8 key_type;\n\ts16 sta_id = 0;\n\n\tif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)\n\t\tkey_type = RSI_PAIRWISE_KEY;\n\telse\n\t\tkey_type = RSI_GROUP_KEY;\n\n\trsi_dbg(ERR_ZONE, \"%s: Cipher 0x%x key_type: %d key_len: %d\\n\",\n\t\t__func__, key->cipher, key_type, key->keylen);\n\n\tif ((vif->type == NL80211_IFTYPE_AP) ||\n\t    (vif->type == NL80211_IFTYPE_P2P_GO)) {\n\t\tif (sta) {\n\t\t\trsta = rsi_find_sta(adapter->priv, sta->addr);\n\t\t\tif (rsta)\n\t\t\t\tsta_id = rsta->sta_id;\n\t\t}\n\t\tadapter->priv->key = key;\n\t} else {\n\t\tif ((key->cipher == WLAN_CIPHER_SUITE_WEP104) ||\n\t\t    (key->cipher == WLAN_CIPHER_SUITE_WEP40)) {\n\t\t\tstatus = rsi_hal_load_key(adapter->priv,\n\t\t\t\t\t\t  key->key,\n\t\t\t\t\t\t  key->keylen,\n\t\t\t\t\t\t  RSI_PAIRWISE_KEY,\n\t\t\t\t\t\t  key->keyidx,\n\t\t\t\t\t\t  key->cipher,\n\t\t\t\t\t\t  sta_id,\n\t\t\t\t\t\t  vif);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t}\n\t}\n\n\tstatus = rsi_hal_load_key(adapter->priv,\n\t\t\t\t  key->key,\n\t\t\t\t  key->keylen,\n\t\t\t\t  key_type,\n\t\t\t\t  key->keyidx,\n\t\t\t\t  key->cipher,\n\t\t\t\t  sta_id,\n\t\t\t\t  vif);\n\tif (status)\n\t\treturn status;\n\n\tif (vif->type == NL80211_IFTYPE_STATION &&\n\t    (key->cipher == WLAN_CIPHER_SUITE_WEP104 ||\n\t     key->cipher == WLAN_CIPHER_SUITE_WEP40)) {\n\t\tif (!rsi_send_block_unblock_frame(adapter->priv, false))\n\t\t\tadapter->priv->hw_data_qs_blocked = false;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int rsi_mac80211_set_key(struct ieee80211_hw *hw,\n\t\t\t\tenum set_key_cmd cmd,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\tstruct ieee80211_key_conf *key)\n{\n\tstruct rsi_hw *adapter = hw->priv;\n\tstruct rsi_common *common = adapter->priv;\n\tstruct security_info *secinfo = &common->secinfo;\n\tint status;\n\n\tmutex_lock(&common->mutex);\n\tswitch (cmd) {\n\tcase SET_KEY:\n\t\tstatus = rsi_hal_key_config(hw, vif, key, sta);\n\t\tif (status) {\n\t\t\tmutex_unlock(&common->mutex);\n\t\t\treturn status;\n\t\t}\n\n\t\tif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)\n\t\t\tsecinfo->ptk_cipher = key->cipher;\n\t\telse\n\t\t\tsecinfo->gtk_cipher = key->cipher;\n\n\t\tkey->hw_key_idx = key->keyidx;\n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\n\n\t\trsi_dbg(ERR_ZONE, \"%s: RSI set_key\\n\", __func__);\n\t\tbreak;\n\n\tcase DISABLE_KEY:\n\t\trsi_dbg(ERR_ZONE, \"%s: RSI del key\\n\", __func__);\n\t\tmemset(key, 0, sizeof(struct ieee80211_key_conf));\n\t\tstatus = rsi_hal_key_config(hw, vif, key, sta);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&common->mutex);\n\treturn status;\n}\n\n \nstatic int rsi_mac80211_ampdu_action(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_ampdu_params *params)\n{\n\tint status = -EOPNOTSUPP;\n\tstruct rsi_hw *adapter = hw->priv;\n\tstruct rsi_common *common = adapter->priv;\n\tstruct rsi_sta *rsta = NULL;\n\tu16 seq_no = 0, seq_start = 0;\n\tu8 ii = 0;\n\tstruct ieee80211_sta *sta = params->sta;\n\tu8 sta_id = 0;\n\tenum ieee80211_ampdu_mlme_action action = params->action;\n\tu16 tid = params->tid;\n\tu16 *ssn = &params->ssn;\n\tu8 buf_size = params->buf_size;\n\n\tfor (ii = 0; ii < RSI_MAX_VIFS; ii++) {\n\t\tif (vif == adapter->vifs[ii])\n\t\t\tbreak;\n\t}\n\n\tif (ii >= RSI_MAX_VIFS)\n\t\treturn status;\n\n\tmutex_lock(&common->mutex);\n\n\tif (ssn != NULL)\n\t\tseq_no = *ssn;\n\n\tif ((vif->type == NL80211_IFTYPE_AP) ||\n\t    (vif->type == NL80211_IFTYPE_P2P_GO)) {\n\t\trsta = rsi_find_sta(common, sta->addr);\n\t\tif (!rsta) {\n\t\t\trsi_dbg(ERR_ZONE, \"No station mapped\\n\");\n\t\t\tstatus = 0;\n\t\t\tgoto unlock;\n\t\t}\n\t\tsta_id = rsta->sta_id;\n\t}\n\n\trsi_dbg(INFO_ZONE,\n\t\t\"%s: AMPDU action tid=%d ssn=0x%x, buf_size=%d sta_id=%d\\n\",\n\t\t__func__, tid, seq_no, buf_size, sta_id);\n\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_RX_START:\n\t\tstatus = rsi_send_aggregation_params_frame(common,\n\t\t\t\t\t\t\t   tid,\n\t\t\t\t\t\t\t   seq_no,\n\t\t\t\t\t\t\t   buf_size,\n\t\t\t\t\t\t\t   STA_RX_ADDBA_DONE,\n\t\t\t\t\t\t\t   sta_id);\n\t\tbreak;\n\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\tstatus = rsi_send_aggregation_params_frame(common,\n\t\t\t\t\t\t\t   tid,\n\t\t\t\t\t\t\t   0,\n\t\t\t\t\t\t\t   buf_size,\n\t\t\t\t\t\t\t   STA_RX_DELBA,\n\t\t\t\t\t\t\t   sta_id);\n\t\tbreak;\n\n\tcase IEEE80211_AMPDU_TX_START:\n\t\tif ((vif->type == NL80211_IFTYPE_STATION) ||\n\t\t    (vif->type == NL80211_IFTYPE_P2P_CLIENT))\n\t\t\tcommon->vif_info[ii].seq_start = seq_no;\n\t\telse if ((vif->type == NL80211_IFTYPE_AP) ||\n\t\t\t (vif->type == NL80211_IFTYPE_P2P_GO))\n\t\t\trsta->seq_start[tid] = seq_no;\n\t\tstatus = IEEE80211_AMPDU_TX_START_IMMEDIATE;\n\t\tbreak;\n\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\t\tstatus = rsi_send_aggregation_params_frame(common,\n\t\t\t\t\t\t\t   tid,\n\t\t\t\t\t\t\t   seq_no,\n\t\t\t\t\t\t\t   buf_size,\n\t\t\t\t\t\t\t   STA_TX_DELBA,\n\t\t\t\t\t\t\t   sta_id);\n\t\tif (!status)\n\t\t\tieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\t\tbreak;\n\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\tif ((vif->type == NL80211_IFTYPE_STATION) ||\n\t\t    (vif->type == NL80211_IFTYPE_P2P_CLIENT))\n\t\t\tseq_start = common->vif_info[ii].seq_start;\n\t\telse if ((vif->type == NL80211_IFTYPE_AP) ||\n\t\t\t (vif->type == NL80211_IFTYPE_P2P_GO))\n\t\t\tseq_start = rsta->seq_start[tid];\n\t\tstatus = rsi_send_aggregation_params_frame(common,\n\t\t\t\t\t\t\t   tid,\n\t\t\t\t\t\t\t   seq_start,\n\t\t\t\t\t\t\t   buf_size,\n\t\t\t\t\t\t\t   STA_TX_ADDBA_DONE,\n\t\t\t\t\t\t\t   sta_id);\n\t\tbreak;\n\n\tdefault:\n\t\trsi_dbg(ERR_ZONE, \"%s: Unknown AMPDU action\\n\", __func__);\n\t\tbreak;\n\t}\n\nunlock:\n\tmutex_unlock(&common->mutex);\n\treturn status;\n}\n\n \nstatic int rsi_mac80211_set_rts_threshold(struct ieee80211_hw *hw,\n\t\t\t\t\t  u32 value)\n{\n\tstruct rsi_hw *adapter = hw->priv;\n\tstruct rsi_common *common = adapter->priv;\n\n\tmutex_lock(&common->mutex);\n\tcommon->rts_threshold = value;\n\tmutex_unlock(&common->mutex);\n\n\treturn 0;\n}\n\n \nstatic int rsi_mac80211_set_rate_mask(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      const struct cfg80211_bitrate_mask *mask)\n{\n\tconst unsigned int mcs_offset = ARRAY_SIZE(rsi_rates);\n\tstruct rsi_hw *adapter = hw->priv;\n\tstruct rsi_common *common = adapter->priv;\n\tint i;\n\n\tmutex_lock(&common->mutex);\n\n\tfor (i = 0; i < ARRAY_SIZE(common->rate_config); i++) {\n\t\tstruct rsi_rate_config *cfg = &common->rate_config[i];\n\t\tu32 bm;\n\n\t\tbm = mask->control[i].legacy | (mask->control[i].ht_mcs[0] << mcs_offset);\n\t\tif (hweight32(bm) == 1) {  \n\t\t\tint rate_index = ffs(bm) - 1;\n\n\t\t\tif (rate_index < mcs_offset)\n\t\t\t\tcfg->fixed_hw_rate = rsi_rates[rate_index].hw_value;\n\t\t\telse\n\t\t\t\tcfg->fixed_hw_rate = rsi_mcsrates[rate_index - mcs_offset];\n\t\t\tcfg->fixed_enabled = true;\n\t\t} else {\n\t\t\tcfg->configured_mask = bm;\n\t\t\tcfg->fixed_enabled = false;\n\t\t}\n\t}\n\n\tmutex_unlock(&common->mutex);\n\n\treturn 0;\n}\n\n \nstatic void rsi_perform_cqm(struct rsi_common *common,\n\t\t\t    u8 *bssid,\n\t\t\t    s8 rssi,\n\t\t\t    struct ieee80211_vif *vif)\n{\n\ts8 last_event = common->cqm_info.last_cqm_event_rssi;\n\tint thold = common->cqm_info.rssi_thold;\n\tu32 hyst = common->cqm_info.rssi_hyst;\n\tenum nl80211_cqm_rssi_threshold_event event;\n\n\tif (rssi < thold && (last_event == 0 || rssi < (last_event - hyst)))\n\t\tevent = NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW;\n\telse if (rssi > thold &&\n\t\t (last_event == 0 || rssi > (last_event + hyst)))\n\t\tevent = NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH;\n\telse\n\t\treturn;\n\n\tcommon->cqm_info.last_cqm_event_rssi = rssi;\n\trsi_dbg(INFO_ZONE, \"CQM: Notifying event: %d\\n\", event);\n\tieee80211_cqm_rssi_notify(vif, event, rssi, GFP_KERNEL);\n\n\treturn;\n}\n\n \nstatic void rsi_fill_rx_status(struct ieee80211_hw *hw,\n\t\t\t       struct sk_buff *skb,\n\t\t\t       struct rsi_common *common,\n\t\t\t       struct ieee80211_rx_status *rxs)\n{\n\tstruct rsi_hw *adapter = common->priv;\n\tstruct ieee80211_vif *vif;\n\tstruct ieee80211_bss_conf *bss = NULL;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct skb_info *rx_params = (struct skb_info *)info->driver_data;\n\tstruct ieee80211_hdr *hdr;\n\tchar rssi = rx_params->rssi;\n\tu8 hdrlen = 0;\n\tu8 channel = rx_params->channel;\n\ts32 freq;\n\tint i;\n\n\thdr = ((struct ieee80211_hdr *)(skb->data));\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\n\tmemset(info, 0, sizeof(struct ieee80211_tx_info));\n\n\trxs->signal = -(rssi);\n\n\trxs->band = common->band;\n\n\tfreq = ieee80211_channel_to_frequency(channel, rxs->band);\n\n\tif (freq)\n\t\trxs->freq = freq;\n\n\tif (ieee80211_has_protected(hdr->frame_control)) {\n\t\tif (rsi_is_cipher_wep(common)) {\n\t\t\tmemmove(skb->data + 4, skb->data, hdrlen);\n\t\t\tskb_pull(skb, 4);\n\t\t} else {\n\t\t\tmemmove(skb->data + 8, skb->data, hdrlen);\n\t\t\tskb_pull(skb, 8);\n\t\t\trxs->flag |= RX_FLAG_MMIC_STRIPPED;\n\t\t}\n\t\trxs->flag |= RX_FLAG_DECRYPTED;\n\t\trxs->flag |= RX_FLAG_IV_STRIPPED;\n\t}\n\n\tfor (i = 0; i < RSI_MAX_VIFS; i++) {\n\t\tvif = adapter->vifs[i];\n\t\tif (!vif)\n\t\t\tcontinue;\n\t\tif (vif->type == NL80211_IFTYPE_STATION) {\n\t\t\tbss = &vif->bss_conf;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!bss)\n\t\treturn;\n\t \n\tif (vif->cfg.assoc && !(memcmp(bss->bssid, hdr->addr2, ETH_ALEN))) {\n\t\tif (ieee80211_is_beacon(hdr->frame_control))\n\t\t\trsi_perform_cqm(common, hdr->addr2, rxs->signal, vif);\n\t}\n\n\treturn;\n}\n\n \nvoid rsi_indicate_pkt_to_os(struct rsi_common *common,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct rsi_hw *adapter = common->priv;\n\tstruct ieee80211_hw *hw = adapter->hw;\n\tstruct ieee80211_rx_status *rx_status = IEEE80211_SKB_RXCB(skb);\n\n\tif ((common->iface_down) || (!adapter->sc_nvifs)) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n\t \n\trsi_fill_rx_status(hw, skb, common, rx_status);\n\n\tieee80211_rx_irqsafe(hw, skb);\n}\n\n \nstatic int rsi_mac80211_sta_add(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta)\n{\n\tstruct rsi_hw *adapter = hw->priv;\n\tstruct rsi_common *common = adapter->priv;\n\tbool sta_exist = false;\n\tstruct rsi_sta *rsta;\n\tint status = 0;\n\n\trsi_dbg(INFO_ZONE, \"Station Add: %pM\\n\", sta->addr);\n\n\tmutex_lock(&common->mutex);\n\n\tif ((vif->type == NL80211_IFTYPE_AP) ||\n\t    (vif->type == NL80211_IFTYPE_P2P_GO)) {\n\t\tu8 cnt;\n\t\tint sta_idx = -1;\n\t\tint free_index = -1;\n\n\t\t \n\t\tif (common->num_stations >= common->max_stations) {\n\t\t\trsi_dbg(ERR_ZONE, \"Reject: Max Stations exists\\n\");\n\t\t\tstatus = -EOPNOTSUPP;\n\t\t\tgoto unlock;\n\t\t}\n\t\tfor (cnt = 0; cnt < common->max_stations; cnt++) {\n\t\t\trsta = &common->stations[cnt];\n\n\t\t\tif (!rsta->sta) {\n\t\t\t\tif (free_index < 0)\n\t\t\t\t\tfree_index = cnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!memcmp(rsta->sta->addr, sta->addr, ETH_ALEN)) {\n\t\t\t\trsi_dbg(INFO_ZONE, \"Station exists\\n\");\n\t\t\t\tsta_idx = cnt;\n\t\t\t\tsta_exist = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!sta_exist) {\n\t\t\tif (free_index >= 0)\n\t\t\t\tsta_idx = free_index;\n\t\t}\n\t\tif (sta_idx < 0) {\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"%s: Some problem reaching here...\\n\",\n\t\t\t\t__func__);\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\t\trsta = &common->stations[sta_idx];\n\t\trsta->sta = sta;\n\t\trsta->sta_id = sta_idx;\n\t\tfor (cnt = 0; cnt < IEEE80211_NUM_TIDS; cnt++)\n\t\t\trsta->start_tx_aggr[cnt] = false;\n\t\tfor (cnt = 0; cnt < IEEE80211_NUM_TIDS; cnt++)\n\t\t\trsta->seq_start[cnt] = 0;\n\t\tif (!sta_exist) {\n\t\t\trsi_dbg(INFO_ZONE, \"New Station\\n\");\n\n\t\t\t \n\t\t\trsi_dbg(INFO_ZONE, \"Indicate bss status to device\\n\");\n\t\t\trsi_inform_bss_status(common, RSI_OPMODE_AP, 1,\n\t\t\t\t\t      sta->addr, sta->wme, sta->aid,\n\t\t\t\t\t      sta, sta_idx, 0, vif);\n\n\t\t\tif (common->key) {\n\t\t\t\tstruct ieee80211_key_conf *key = common->key;\n\n\t\t\t\tif ((key->cipher == WLAN_CIPHER_SUITE_WEP104) ||\n\t\t\t\t    (key->cipher == WLAN_CIPHER_SUITE_WEP40))\n\t\t\t\t\trsi_hal_load_key(adapter->priv,\n\t\t\t\t\t\t\t key->key,\n\t\t\t\t\t\t\t key->keylen,\n\t\t\t\t\t\t\t RSI_PAIRWISE_KEY,\n\t\t\t\t\t\t\t key->keyidx,\n\t\t\t\t\t\t\t key->cipher,\n\t\t\t\t\t\t\t sta_idx,\n\t\t\t\t\t\t\t vif);\n\t\t\t}\n\n\t\t\tcommon->num_stations++;\n\t\t}\n\t}\n\n\tif ((vif->type == NL80211_IFTYPE_STATION) ||\n\t    (vif->type == NL80211_IFTYPE_P2P_CLIENT)) {\n\t\tcommon->bitrate_mask[common->band] = sta->deflink.supp_rates[common->band];\n\t\tcommon->vif_info[0].is_ht = sta->deflink.ht_cap.ht_supported;\n\t\tif (sta->deflink.ht_cap.ht_supported) {\n\t\t\tcommon->bitrate_mask[NL80211_BAND_2GHZ] =\n\t\t\t\t\tsta->deflink.supp_rates[NL80211_BAND_2GHZ];\n\t\t\tif ((sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ||\n\t\t\t    (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_40))\n\t\t\t\tcommon->vif_info[0].sgi = true;\n\t\t\tieee80211_start_tx_ba_session(sta, 0, 0);\n\t\t}\n\t}\n\nunlock:\n\tmutex_unlock(&common->mutex);\n\n\treturn status;\n}\n\n \nstatic int rsi_mac80211_sta_remove(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_sta *sta)\n{\n\tstruct rsi_hw *adapter = hw->priv;\n\tstruct rsi_common *common = adapter->priv;\n\tstruct ieee80211_bss_conf *bss = &vif->bss_conf;\n\tstruct rsi_sta *rsta;\n\n\trsi_dbg(INFO_ZONE, \"Station Remove: %pM\\n\", sta->addr);\n\n\tmutex_lock(&common->mutex);\n\n\tif ((vif->type == NL80211_IFTYPE_AP) ||\n\t    (vif->type == NL80211_IFTYPE_P2P_GO)) {\n\t\tu8 sta_idx, cnt;\n\n\t\t \n\t\trsi_dbg(INFO_ZONE, \"Indicate bss status to device\\n\");\n\t\tfor (sta_idx = 0; sta_idx < common->max_stations; sta_idx++) {\n\t\t\trsta = &common->stations[sta_idx];\n\n\t\t\tif (!rsta->sta)\n\t\t\t\tcontinue;\n\t\t\tif (!memcmp(rsta->sta->addr, sta->addr, ETH_ALEN)) {\n\t\t\t\trsi_inform_bss_status(common, RSI_OPMODE_AP, 0,\n\t\t\t\t\t\t      sta->addr, sta->wme,\n\t\t\t\t\t\t      sta->aid, sta, sta_idx,\n\t\t\t\t\t\t      0, vif);\n\t\t\t\trsta->sta = NULL;\n\t\t\t\trsta->sta_id = -1;\n\t\t\t\tfor (cnt = 0; cnt < IEEE80211_NUM_TIDS; cnt++)\n\t\t\t\t\trsta->start_tx_aggr[cnt] = false;\n\t\t\t\tif (common->num_stations > 0)\n\t\t\t\t\tcommon->num_stations--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (sta_idx >= common->max_stations)\n\t\t\trsi_dbg(ERR_ZONE, \"%s: No station found\\n\", __func__);\n\t}\n\n\tif ((vif->type == NL80211_IFTYPE_STATION) ||\n\t    (vif->type == NL80211_IFTYPE_P2P_CLIENT)) {\n\t\t \n\t\tmemcpy((u8 *)bss->bssid, (u8 *)sta->addr, ETH_ALEN);\n\t\tbss->qos = sta->wme;\n\t\tcommon->bitrate_mask[NL80211_BAND_2GHZ] = 0;\n\t\tcommon->bitrate_mask[NL80211_BAND_5GHZ] = 0;\n\t\tcommon->vif_info[0].is_ht = false;\n\t\tcommon->vif_info[0].sgi = false;\n\t\tcommon->vif_info[0].seq_start = 0;\n\t\tcommon->secinfo.ptk_cipher = 0;\n\t\tcommon->secinfo.gtk_cipher = 0;\n\t\tif (!common->iface_down)\n\t\t\trsi_send_rx_filter_frame(common, 0);\n\t}\n\tmutex_unlock(&common->mutex);\n\t\n\treturn 0;\n}\n\n \nstatic int rsi_mac80211_set_antenna(struct ieee80211_hw *hw,\n\t\t\t\t    u32 tx_ant, u32 rx_ant)\n{\n\tstruct rsi_hw *adapter = hw->priv;\n\tstruct rsi_common *common = adapter->priv;\n\tu8 antenna = 0;\n\n\tif (tx_ant > 1 || rx_ant > 1) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"Invalid antenna selection (tx: %d, rx:%d)\\n\",\n\t\t\ttx_ant, rx_ant);\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"Use 0 for int_ant, 1 for ext_ant\\n\");\n\t\treturn -EINVAL; \n\t}\n\n\trsi_dbg(INFO_ZONE, \"%s: Antenna map Tx %x Rx %d\\n\",\n\t\t\t__func__, tx_ant, rx_ant);\n\n\tmutex_lock(&common->mutex);\n\n\tantenna = tx_ant ? ANTENNA_SEL_UFL : ANTENNA_SEL_INT;\n\tif (common->ant_in_use != antenna)\n\t\tif (rsi_set_antenna(common, antenna))\n\t\t\tgoto fail_set_antenna;\n\n\trsi_dbg(INFO_ZONE, \"(%s) Antenna path configured successfully\\n\",\n\t\ttx_ant ? \"UFL\" : \"INT\");\n\n\tcommon->ant_in_use = antenna;\n\t\n\tmutex_unlock(&common->mutex);\n\t\n\treturn 0;\n\nfail_set_antenna:\n\trsi_dbg(ERR_ZONE, \"%s: Failed.\\n\", __func__);\n\tmutex_unlock(&common->mutex);\n\treturn -EINVAL;\n}\n\n \nstatic int rsi_mac80211_get_antenna(struct ieee80211_hw *hw,\n\t\t\t\t    u32 *tx_ant, u32 *rx_ant)\n{\n\tstruct rsi_hw *adapter = hw->priv;\n\tstruct rsi_common *common = adapter->priv;\n\n\tmutex_lock(&common->mutex);\n\n\t*tx_ant = (common->ant_in_use == ANTENNA_SEL_UFL) ? 1 : 0;\n\t*rx_ant = 0;\n\n\tmutex_unlock(&common->mutex);\n\t\n\treturn 0;\t\n}\n\nstatic int rsi_map_region_code(enum nl80211_dfs_regions region_code)\n{\n\tswitch (region_code) {\n\tcase NL80211_DFS_FCC:\n\t\treturn RSI_REGION_FCC;\n\tcase NL80211_DFS_ETSI:\n\t\treturn RSI_REGION_ETSI;\n\tcase NL80211_DFS_JP:\n\t\treturn RSI_REGION_TELEC;\n\tcase NL80211_DFS_UNSET:\n\t\treturn RSI_REGION_WORLD;\n\t}\n\treturn RSI_REGION_WORLD;\n}\n\nstatic void rsi_reg_notify(struct wiphy *wiphy,\n\t\t\t   struct regulatory_request *request)\n{\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *ch;\n\tstruct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);\n\tstruct rsi_hw * adapter = hw->priv; \n\tstruct rsi_common *common = adapter->priv;\n\tint i;\n\t\n\tmutex_lock(&common->mutex);\n\n\trsi_dbg(INFO_ZONE, \"country = %s dfs_region = %d\\n\",\n\t\trequest->alpha2, request->dfs_region);\n\n\tif (common->num_supp_bands > 1) {\n\t\tsband = wiphy->bands[NL80211_BAND_5GHZ];\n\n\t\tfor (i = 0; i < sband->n_channels; i++) {\n\t\t\tch = &sband->channels[i];\n\t\t\tif (ch->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\tif (ch->flags & IEEE80211_CHAN_RADAR)\n\t\t\t\tch->flags |= IEEE80211_CHAN_NO_IR;\n\t\t}\n\t}\n\tadapter->dfs_region = rsi_map_region_code(request->dfs_region);\n\trsi_dbg(INFO_ZONE, \"RSI region code = %d\\n\", adapter->dfs_region);\n\t\n\tadapter->country[0] = request->alpha2[0];\n\tadapter->country[1] = request->alpha2[1];\n\n\tmutex_unlock(&common->mutex);\n}\n\nstatic void rsi_mac80211_rfkill_poll(struct ieee80211_hw *hw)\n{\n\tstruct rsi_hw *adapter = hw->priv;\n\tstruct rsi_common *common = adapter->priv;\n\n\tmutex_lock(&common->mutex);\n\tif (common->fsm_state != FSM_MAC_INIT_DONE)\n\t\twiphy_rfkill_set_hw_state(hw->wiphy, true);\n\telse\n\t\twiphy_rfkill_set_hw_state(hw->wiphy, false);\n\tmutex_unlock(&common->mutex);\n}\n\nstatic void rsi_resume_conn_channel(struct rsi_common *common)\n{\n\tstruct rsi_hw *adapter = common->priv;\n\tstruct ieee80211_vif *vif;\n\tint cnt;\n\n\tfor (cnt = 0; cnt < RSI_MAX_VIFS; cnt++) {\n\t\tvif = adapter->vifs[cnt];\n\t\tif (!vif)\n\t\t\tcontinue;\n\n\t\tif ((vif->type == NL80211_IFTYPE_AP) ||\n\t\t    (vif->type == NL80211_IFTYPE_P2P_GO)) {\n\t\t\trsi_switch_channel(adapter, vif);\n\t\t\tbreak;\n\t\t}\n\t\tif (((vif->type == NL80211_IFTYPE_STATION) ||\n\t\t     (vif->type == NL80211_IFTYPE_P2P_CLIENT)) &&\n\t\t    vif->cfg.assoc) {\n\t\t\trsi_switch_channel(adapter, vif);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid rsi_roc_timeout(struct timer_list *t)\n{\n\tstruct rsi_common *common = from_timer(common, t, roc_timer);\n\n\trsi_dbg(INFO_ZONE, \"Remain on channel expired\\n\");\n\n\tmutex_lock(&common->mutex);\n\tieee80211_remain_on_channel_expired(common->priv->hw);\n\n\tif (timer_pending(&common->roc_timer))\n\t\tdel_timer(&common->roc_timer);\n\n\trsi_resume_conn_channel(common);\n\tmutex_unlock(&common->mutex);\n}\n\nstatic int rsi_mac80211_roc(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_channel *chan, int duration,\n\t\t\t    enum ieee80211_roc_type type)\n{\n\tstruct rsi_hw *adapter = hw->priv;\n\tstruct rsi_common *common = adapter->priv;\n\tint status = 0;\n\n\trsi_dbg(INFO_ZONE, \"***** Remain on channel *****\\n\");\n\n\tmutex_lock(&common->mutex);\n\trsi_dbg(INFO_ZONE, \"%s: channel: %d duration: %dms\\n\",\n\t\t__func__, chan->hw_value, duration);\n\n\tif (timer_pending(&common->roc_timer)) {\n\t\trsi_dbg(INFO_ZONE, \"Stop on-going ROC\\n\");\n\t\tdel_timer(&common->roc_timer);\n\t}\n\tcommon->roc_timer.expires = msecs_to_jiffies(duration) + jiffies;\n\tadd_timer(&common->roc_timer);\n\n\t \n\tif (rsi_band_check(common, chan)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to set band\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (rsi_set_channel(common, chan)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to set the channel\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcommon->roc_vif = vif;\n\tieee80211_ready_on_channel(hw);\n\trsi_dbg(INFO_ZONE, \"%s: Ready on channel :%d\\n\",\n\t\t__func__, chan->hw_value);\n\nout:\n\tmutex_unlock(&common->mutex);\n\n\treturn status;\n}\n\nstatic int rsi_mac80211_cancel_roc(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct rsi_hw *adapter = hw->priv;\n\tstruct rsi_common *common = adapter->priv;\n\n\trsi_dbg(INFO_ZONE, \"Cancel remain on channel\\n\");\n\n\tmutex_lock(&common->mutex);\n\tif (!timer_pending(&common->roc_timer)) {\n\t\tmutex_unlock(&common->mutex);\n\t\treturn 0;\n\t}\n\n\tdel_timer(&common->roc_timer);\n\n\trsi_resume_conn_channel(common);\n\tmutex_unlock(&common->mutex);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic const struct wiphy_wowlan_support rsi_wowlan_support = {\n\t.flags = WIPHY_WOWLAN_ANY |\n\t\t WIPHY_WOWLAN_MAGIC_PKT |\n\t\t WIPHY_WOWLAN_DISCONNECT |\n\t\t WIPHY_WOWLAN_GTK_REKEY_FAILURE  |\n\t\t WIPHY_WOWLAN_SUPPORTS_GTK_REKEY |\n\t\t WIPHY_WOWLAN_EAP_IDENTITY_REQ   |\n\t\t WIPHY_WOWLAN_4WAY_HANDSHAKE,\n};\n\nstatic u16 rsi_wow_map_triggers(struct rsi_common *common,\n\t\t\t\tstruct cfg80211_wowlan *wowlan)\n{\n\tu16 wow_triggers = 0;\n\n\trsi_dbg(INFO_ZONE, \"Mapping wowlan triggers\\n\");\n\n\tif (wowlan->any)\n\t\twow_triggers |= RSI_WOW_ANY;\n\tif (wowlan->magic_pkt)\n\t\twow_triggers |= RSI_WOW_MAGIC_PKT;\n\tif (wowlan->disconnect)\n\t\twow_triggers |= RSI_WOW_DISCONNECT;\n\tif (wowlan->gtk_rekey_failure || wowlan->eap_identity_req ||\n\t    wowlan->four_way_handshake)\n\t\twow_triggers |= RSI_WOW_GTK_REKEY;\n\n\treturn wow_triggers;\n}\n\nint rsi_config_wowlan(struct rsi_hw *adapter, struct cfg80211_wowlan *wowlan)\n{\n\tstruct rsi_common *common = adapter->priv;\n\tstruct ieee80211_vif *vif = adapter->vifs[0];\n\tu16 triggers = 0;\n\tu16 rx_filter_word = 0;\n\n\trsi_dbg(INFO_ZONE, \"Config WoWLAN to device\\n\");\n\n\tif (!vif)\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(!wowlan)) {\n\t\trsi_dbg(ERR_ZONE, \"WoW triggers not enabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcommon->wow_flags |= RSI_WOW_ENABLED;\n\ttriggers = rsi_wow_map_triggers(common, wowlan);\n\tif (!triggers) {\n\t\trsi_dbg(ERR_ZONE, \"%s:No valid WoW triggers\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tif (!vif->cfg.assoc) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"Cannot configure WoWLAN (Station not connected)\\n\");\n\t\tcommon->wow_flags |= RSI_WOW_NO_CONNECTION;\n\t\treturn 0;\n\t}\n\trsi_dbg(INFO_ZONE, \"TRIGGERS %x\\n\", triggers);\n\n\tif (common->coex_mode > 1)\n\t\trsi_disable_ps(adapter, adapter->vifs[0]);\n\n\trsi_send_wowlan_request(common, triggers, 1);\n\n\t \n\trsi_send_vap_dynamic_update(common);\n\n\trx_filter_word = (ALLOW_DATA_ASSOC_PEER | DISALLOW_BEACONS);\n\trsi_send_rx_filter_frame(common, rx_filter_word);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rsi_config_wowlan);\n\nstatic int rsi_mac80211_suspend(struct ieee80211_hw *hw,\n\t\t\t\tstruct cfg80211_wowlan *wowlan)\n{\n\tstruct rsi_hw *adapter = hw->priv;\n\tstruct rsi_common *common = adapter->priv;\n\n\trsi_dbg(INFO_ZONE, \"%s: mac80211 suspend\\n\", __func__);\n\tmutex_lock(&common->mutex);\n\tif (rsi_config_wowlan(adapter, wowlan)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to configure WoWLAN\\n\");\n\t\tmutex_unlock(&common->mutex);\n\t\treturn 1;\n\t}\n\tmutex_unlock(&common->mutex);\n\n\treturn 0;\n}\n\nstatic int rsi_mac80211_resume(struct ieee80211_hw *hw)\n{\n\tu16 rx_filter_word = 0;\n\tstruct rsi_hw *adapter = hw->priv;\n\tstruct rsi_common *common = adapter->priv;\n\n\tcommon->wow_flags = 0;\n\n\trsi_dbg(INFO_ZONE, \"%s: mac80211 resume\\n\", __func__);\n\n\tif (common->hibernate_resume) {\n\t\tcommon->mac_ops_resumed = true;\n\t\t \n\t\treturn 1;\n\t}\n\n\tmutex_lock(&common->mutex);\n\trsi_send_wowlan_request(common, 0, 0);\n\n\trx_filter_word = (ALLOW_DATA_ASSOC_PEER | ALLOW_CTRL_ASSOC_PEER |\n\t\t\t  ALLOW_MGMT_ASSOC_PEER);\n\trsi_send_rx_filter_frame(common, rx_filter_word);\n\tmutex_unlock(&common->mutex);\n\n\treturn 0;\n}\n\n#endif\n\nstatic const struct ieee80211_ops mac80211_ops = {\n\t.tx = rsi_mac80211_tx,\n\t.wake_tx_queue = ieee80211_handle_wake_tx_queue,\n\t.start = rsi_mac80211_start,\n\t.stop = rsi_mac80211_stop,\n\t.add_interface = rsi_mac80211_add_interface,\n\t.remove_interface = rsi_mac80211_remove_interface,\n\t.config = rsi_mac80211_config,\n\t.bss_info_changed = rsi_mac80211_bss_info_changed,\n\t.conf_tx = rsi_mac80211_conf_tx,\n\t.configure_filter = rsi_mac80211_conf_filter,\n\t.set_key = rsi_mac80211_set_key,\n\t.set_rts_threshold = rsi_mac80211_set_rts_threshold,\n\t.set_bitrate_mask = rsi_mac80211_set_rate_mask,\n\t.ampdu_action = rsi_mac80211_ampdu_action,\n\t.sta_add = rsi_mac80211_sta_add,\n\t.sta_remove = rsi_mac80211_sta_remove,\n\t.set_antenna = rsi_mac80211_set_antenna,\n\t.get_antenna = rsi_mac80211_get_antenna,\n\t.rfkill_poll = rsi_mac80211_rfkill_poll,\n\t.remain_on_channel = rsi_mac80211_roc,\n\t.cancel_remain_on_channel = rsi_mac80211_cancel_roc,\n#ifdef CONFIG_PM\n\t.suspend = rsi_mac80211_suspend,\n\t.resume  = rsi_mac80211_resume,\n#endif\n\t.hw_scan = rsi_mac80211_hw_scan_start,\n\t.cancel_hw_scan = rsi_mac80211_cancel_hw_scan,\n};\n\n \nint rsi_mac80211_attach(struct rsi_common *common)\n{\n\tint status = 0;\n\tstruct ieee80211_hw *hw = NULL;\n\tstruct wiphy *wiphy = NULL;\n\tstruct rsi_hw *adapter = common->priv;\n\tu8 addr_mask[ETH_ALEN] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x3};\n\n\trsi_dbg(INIT_ZONE, \"%s: Performing mac80211 attach\\n\", __func__);\n\n\thw = ieee80211_alloc_hw(sizeof(struct rsi_hw), &mac80211_ops);\n\tif (!hw) {\n\t\trsi_dbg(ERR_ZONE, \"%s: ieee80211 hw alloc failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\twiphy = hw->wiphy;\n\n\tSET_IEEE80211_DEV(hw, adapter->device);\n\n\thw->priv = adapter;\n\tadapter->hw = hw;\n\n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\tieee80211_hw_set(hw, HAS_RATE_CONTROL);\n\tieee80211_hw_set(hw, AMPDU_AGGREGATION);\n\tieee80211_hw_set(hw, SUPPORTS_PS);\n\tieee80211_hw_set(hw, SUPPORTS_DYNAMIC_PS);\n\n\thw->queues = MAX_HW_QUEUES;\n\thw->extra_tx_headroom = RSI_NEEDED_HEADROOM;\n\n\thw->max_rates = 1;\n\thw->max_rate_tries = MAX_RETRIES;\n\thw->uapsd_queues = RSI_IEEE80211_UAPSD_QUEUES;\n\thw->uapsd_max_sp_len = IEEE80211_WMM_IE_STA_QOSINFO_SP_ALL;\n\n\thw->max_tx_aggregation_subframes = RSI_MAX_TX_AGGR_FRMS;\n\thw->max_rx_aggregation_subframes = RSI_MAX_RX_AGGR_FRMS;\n\thw->rate_control_algorithm = \"AARF\";\n\n\tSET_IEEE80211_PERM_ADDR(hw, common->mac_addr);\n\tether_addr_copy(hw->wiphy->addr_mask, addr_mask);\n\n\twiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t BIT(NL80211_IFTYPE_AP) |\n\t\t\t\t BIT(NL80211_IFTYPE_P2P_DEVICE) |\n\t\t\t\t BIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\t\t\t BIT(NL80211_IFTYPE_P2P_GO);\n\n\twiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;\n\twiphy->retry_short = RETRY_SHORT;\n\twiphy->retry_long  = RETRY_LONG;\n\twiphy->frag_threshold = IEEE80211_MAX_FRAG_THRESHOLD;\n\twiphy->rts_threshold = IEEE80211_MAX_RTS_THRESHOLD;\n\twiphy->flags = 0;\n\n\twiphy->available_antennas_rx = 1;\n\twiphy->available_antennas_tx = 1;\n\n\tstatus = rsi_register_rates_channels(adapter, NL80211_BAND_2GHZ);\n\tif (status)\n\t\treturn status;\n\twiphy->bands[NL80211_BAND_2GHZ] =\n\t\t&adapter->sbands[NL80211_BAND_2GHZ];\n\tif (common->num_supp_bands > 1) {\n\t\tstatus = rsi_register_rates_channels(adapter,\n\t\t\t\t\t\t     NL80211_BAND_5GHZ);\n\t\tif (status)\n\t\t\treturn status;\n\t\twiphy->bands[NL80211_BAND_5GHZ] =\n\t\t\t&adapter->sbands[NL80211_BAND_5GHZ];\n\t}\n\n\t \n\twiphy->max_ap_assoc_sta = rsi_max_ap_stas[common->oper_mode - 1];\n\tcommon->max_stations = wiphy->max_ap_assoc_sta;\n\trsi_dbg(ERR_ZONE, \"Max Stations Allowed = %d\\n\", common->max_stations);\n\thw->sta_data_size = sizeof(struct rsi_sta);\n\n\twiphy->max_scan_ssids = RSI_MAX_SCAN_SSIDS;\n\twiphy->max_scan_ie_len = RSI_MAX_SCAN_IE_LEN;\n\twiphy->flags = WIPHY_FLAG_REPORTS_OBSS;\n\twiphy->flags |= WIPHY_FLAG_AP_UAPSD;\n\twiphy->features |= NL80211_FEATURE_INACTIVITY_TIMER;\n\twiphy->reg_notifier = rsi_reg_notify;\n\n#ifdef CONFIG_PM\n\twiphy->wowlan = &rsi_wowlan_support;\n#endif\n\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\t \n\twiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;\n\twiphy->flags |= WIPHY_FLAG_OFFCHAN_TX;\n\twiphy->max_remain_on_channel_duration = 10000;\n\thw->max_listen_interval = 10;\n\twiphy->iface_combinations = rsi_iface_combinations;\n\twiphy->n_iface_combinations = ARRAY_SIZE(rsi_iface_combinations);\n\n\tif (common->coex_mode > 1)\n\t\twiphy->flags |= WIPHY_FLAG_PS_ON_BY_DEFAULT;\n\n\tstatus = ieee80211_register_hw(hw);\n\tif (status)\n\t\treturn status;\n\n\treturn rsi_init_dbgfs(adapter);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}