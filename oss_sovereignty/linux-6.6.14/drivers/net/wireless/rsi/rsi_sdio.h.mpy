{
  "module_name": "rsi_sdio.h",
  "hash_id": "38300016033c147c62054333f8d31bb6f2ede2499b4d97ee5711d3291292f872",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/rsi/rsi_sdio.h",
  "human_readable_source": " \n\n#ifndef __RSI_SDIO_INTF__\n#define __RSI_SDIO_INTF__\n\n#include <linux/mmc/card.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/sdio_func.h>\n#include <linux/mmc/sdio.h>\n#include <linux/mmc/sd.h>\n#include <linux/mmc/sdio_ids.h>\n#include \"rsi_main.h\"\n\nenum sdio_interrupt_type {\n\tBUFFER_FULL         = 0x0,\n\tBUFFER_AVAILABLE    = 0x2,\n\tFIRMWARE_ASSERT_IND = 0x3,\n\tMSDU_PACKET_PENDING = 0x4,\n\tUNKNOWN_INT         = 0XE\n};\n\n \n#define PKT_BUFF_SEMI_FULL                      0\n#define PKT_BUFF_FULL                           1\n#define PKT_MGMT_BUFF_FULL                      2\n#define MSDU_PKT_PENDING                        3\n#define RECV_NUM_BLOCKS                         4\n \n#define PKT_BUFF_AVAILABLE                      1\n#define FW_ASSERT_IND                           2\n\n#define RSI_MASTER_REG_BUF_SIZE\t\t\t12\n\n#define RSI_DEVICE_BUFFER_STATUS_REGISTER       0xf3\n#define RSI_FN1_INT_REGISTER                    0xf9\n#define RSI_INT_ENABLE_REGISTER\t\t\t0x04\n#define RSI_INT_ENABLE_MASK\t\t\t0xfc\n#define RSI_SD_REQUEST_MASTER                   0x10000\n\n \n#define SDIO_RX_NUM_BLOCKS_REG                  0x000F1\n#define SDIO_FW_STATUS_REG                      0x000F2\n#define SDIO_NXT_RD_DELAY2                      0x000F5\n#define SDIO_MASTER_ACCESS_MSBYTE               0x000FA\n#define SDIO_MASTER_ACCESS_LSBYTE               0x000FB\n#define SDIO_READ_START_LVL                     0x000FC\n#define SDIO_READ_FIFO_CTL                      0x000FD\n#define SDIO_WRITE_FIFO_CTL                     0x000FE\n#define SDIO_WAKEUP_REG\t\t\t\t0x000FF\n#define SDIO_FUN1_INTR_CLR_REG                  0x0008\n#define SDIO_REG_HIGH_SPEED                     0x0013\n\n#define RSI_GET_SDIO_INTERRUPT_TYPE(_I, TYPE)      \\\n\t{\t\t\t\t\t   \\\n\t\tTYPE =                             \\\n\t\t(_I & (1 << PKT_BUFF_AVAILABLE)) ? \\\n\t\tBUFFER_AVAILABLE :\t\t   \\\n\t\t(_I & (1 << MSDU_PKT_PENDING)) ?   \\\n\t\tMSDU_PACKET_PENDING :              \\\n\t\t(_I & (1 << FW_ASSERT_IND)) ?      \\\n\t\tFIRMWARE_ASSERT_IND : UNKNOWN_INT; \\\n\t}\n\n \n#define TA_SOFT_RESET_REG            0x0004\n#define TA_TH0_PC_REG                0x0400\n#define TA_HOLD_THREAD_REG           0x0844\n#define TA_RELEASE_THREAD_REG        0x0848\n\n#define TA_SOFT_RST_CLR              0\n#define TA_SOFT_RST_SET              BIT(0)\n#define TA_PC_ZERO                   0\n#define TA_HOLD_THREAD_VALUE         0xF\n#define TA_RELEASE_THREAD_VALUE      0xF\n#define TA_BASE_ADDR                 0x2200\n#define MISC_CFG_BASE_ADDR           0x4105\n\nstruct receive_info {\n\tbool buffer_full;\n\tbool semi_buffer_full;\n\tbool mgmt_buffer_full;\n\tu32 mgmt_buf_full_counter;\n\tu32 buf_semi_full_counter;\n\tu8 watch_bufferfull_count;\n\tu32 sdio_intr_status_zero;\n\tu32 sdio_int_counter;\n\tu32 total_sdio_msdu_pending_intr;\n\tu32 total_sdio_unknown_intr;\n\tu32 buf_full_counter;\n\tu32 buf_available_counter;\n};\n\nstruct rsi_91x_sdiodev {\n\tstruct sdio_func *pfunction;\n\tstruct task_struct *sdio_irq_task;\n\tstruct receive_info rx_info;\n\tu32 next_read_delay;\n\tu32 sdio_high_speed_enable;\n\tu8 sdio_clock_speed;\n\tu32 cardcapability;\n\tu8 prev_desc[16];\n\tu16 tx_blk_size;\n\tu8 write_fail;\n\tbool buff_status_updated;\n\tstruct rsi_thread rx_thread;\n\tu8 pktbuffer[8192] __aligned(4);\n};\n\nint rsi_init_sdio_slave_regs(struct rsi_hw *adapter);\nint rsi_sdio_read_register(struct rsi_hw *adapter, u32 addr, u8 *data);\nint rsi_sdio_host_intf_read_pkt(struct rsi_hw *adapter, u8 *pkt, u32 length);\nint rsi_sdio_write_register(struct rsi_hw *adapter, u8 function,\n\t\t\t    u32 addr, u8 *data);\nint rsi_sdio_write_register_multiple(struct rsi_hw *adapter, u32 addr,\n\t\t\t\t     u8 *data, u16 count);\nint rsi_sdio_master_access_msword(struct rsi_hw *adapter, u16 ms_word);\nvoid rsi_sdio_ack_intr(struct rsi_hw *adapter, u8 int_bit);\nint rsi_sdio_determine_event_timeout(struct rsi_hw *adapter);\nint rsi_sdio_check_buffer_status(struct rsi_hw *adapter, u8 q_num);\nvoid rsi_sdio_rx_thread(struct rsi_common *common);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}