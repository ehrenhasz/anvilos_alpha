{
  "module_name": "rsi_91x_sdio_ops.c",
  "hash_id": "bf486e26e345b611c7a0dfd6e6d724725581592e957bebf2cbd5b67265cc29b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/rsi/rsi_91x_sdio_ops.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n#include <net/rsi_91x.h>\n#include \"rsi_sdio.h\"\n#include \"rsi_common.h\"\n\n \nint rsi_sdio_master_access_msword(struct rsi_hw *adapter, u16 ms_word)\n{\n\tu8 byte;\n\tu8 function = 0;\n\tint status = 0;\n\n\tbyte = (u8)(ms_word & 0x00FF);\n\n\trsi_dbg(INIT_ZONE,\n\t\t\"%s: MASTER_ACCESS_MSBYTE:0x%x\\n\", __func__, byte);\n\n\tstatus = rsi_sdio_write_register(adapter,\n\t\t\t\t\t function,\n\t\t\t\t\t SDIO_MASTER_ACCESS_MSBYTE,\n\t\t\t\t\t &byte);\n\tif (status) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: fail to access MASTER_ACCESS_MSBYTE\\n\",\n\t\t\t__func__);\n\t\treturn -1;\n\t}\n\n\tbyte = (u8)(ms_word >> 8);\n\n\trsi_dbg(INIT_ZONE, \"%s:MASTER_ACCESS_LSBYTE:0x%x\\n\", __func__, byte);\n\tstatus = rsi_sdio_write_register(adapter,\n\t\t\t\t\t function,\n\t\t\t\t\t SDIO_MASTER_ACCESS_LSBYTE,\n\t\t\t\t\t &byte);\n\treturn status;\n}\n\nstatic void rsi_rx_handler(struct rsi_hw *adapter);\n\nvoid rsi_sdio_rx_thread(struct rsi_common *common)\n{\n\tstruct rsi_hw *adapter = common->priv;\n\tstruct rsi_91x_sdiodev *sdev = adapter->rsi_dev;\n\n\tdo {\n\t\trsi_wait_event(&sdev->rx_thread.event, EVENT_WAIT_FOREVER);\n\t\trsi_reset_event(&sdev->rx_thread.event);\n\t\trsi_rx_handler(adapter);\n\t} while (!atomic_read(&sdev->rx_thread.thread_done));\n\n\trsi_dbg(INFO_ZONE, \"%s: Terminated SDIO RX thread\\n\", __func__);\n\tatomic_inc(&sdev->rx_thread.thread_done);\n\tkthread_complete_and_exit(&sdev->rx_thread.completion, 0);\n}\n\n \nstatic int rsi_process_pkt(struct rsi_common *common)\n{\n\tstruct rsi_hw *adapter = common->priv;\n\tstruct rsi_91x_sdiodev *dev = adapter->rsi_dev;\n\tu8 num_blks = 0;\n\tu32 rcv_pkt_len = 0;\n\tint status = 0;\n\tu8 value = 0;\n\n\tnum_blks = ((adapter->interrupt_status & 1) |\n\t\t\t((adapter->interrupt_status >> RECV_NUM_BLOCKS) << 1));\n\n\tif (!num_blks) {\n\t\tstatus = rsi_sdio_read_register(adapter,\n\t\t\t\t\t\tSDIO_RX_NUM_BLOCKS_REG,\n\t\t\t\t\t\t&value);\n\t\tif (status) {\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"%s: Failed to read pkt length from the card:\\n\",\n\t\t\t\t__func__);\n\t\t\treturn status;\n\t\t}\n\t\tnum_blks = value & 0x1f;\n\t}\n\n\tif (dev->write_fail == 2)\n\t\trsi_sdio_ack_intr(common->priv, (1 << MSDU_PKT_PENDING));\n\n\tif (unlikely(!num_blks)) {\n\t\tdev->write_fail = 2;\n\t\treturn -1;\n\t}\n\n\trcv_pkt_len = (num_blks * 256);\n\n\tstatus = rsi_sdio_host_intf_read_pkt(adapter, dev->pktbuffer,\n\t\t\t\t\t     rcv_pkt_len);\n\tif (status) {\n\t\trsi_dbg(ERR_ZONE, \"%s: Failed to read packet from card\\n\",\n\t\t\t__func__);\n\t\treturn status;\n\t}\n\n\tstatus = rsi_read_pkt(common, dev->pktbuffer, rcv_pkt_len);\n\tif (status) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to read the packet\\n\");\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\n \nint rsi_init_sdio_slave_regs(struct rsi_hw *adapter)\n{\n\tstruct rsi_91x_sdiodev *dev = adapter->rsi_dev;\n\tu8 function = 0;\n\tu8 byte;\n\tint status = 0;\n\n\tif (dev->next_read_delay) {\n\t\tbyte = dev->next_read_delay;\n\t\tstatus = rsi_sdio_write_register(adapter,\n\t\t\t\t\t\t function,\n\t\t\t\t\t\t SDIO_NXT_RD_DELAY2,\n\t\t\t\t\t\t &byte);\n\t\tif (status) {\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"%s: Failed to write SDIO_NXT_RD_DELAY2\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (dev->sdio_high_speed_enable) {\n\t\trsi_dbg(INIT_ZONE, \"%s: Enabling SDIO High speed\\n\", __func__);\n\t\tbyte = 0x3;\n\n\t\tstatus = rsi_sdio_write_register(adapter,\n\t\t\t\t\t\t function,\n\t\t\t\t\t\t SDIO_REG_HIGH_SPEED,\n\t\t\t\t\t\t &byte);\n\t\tif (status) {\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"%s: Failed to enable SDIO high speed\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t \n\trsi_dbg(INIT_ZONE, \"%s: Initializing SDIO read start level\\n\", __func__);\n\tbyte = 0x24;\n\n\tstatus = rsi_sdio_write_register(adapter,\n\t\t\t\t\t function,\n\t\t\t\t\t SDIO_READ_START_LVL,\n\t\t\t\t\t &byte);\n\tif (status) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Failed to write SDIO_READ_START_LVL\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\trsi_dbg(INIT_ZONE, \"%s: Initializing FIFO ctrl registers\\n\", __func__);\n\tbyte = (128 - 32);\n\n\tstatus = rsi_sdio_write_register(adapter,\n\t\t\t\t\t function,\n\t\t\t\t\t SDIO_READ_FIFO_CTL,\n\t\t\t\t\t &byte);\n\tif (status) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Failed to write SDIO_READ_FIFO_CTL\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tbyte = 32;\n\tstatus = rsi_sdio_write_register(adapter,\n\t\t\t\t\t function,\n\t\t\t\t\t SDIO_WRITE_FIFO_CTL,\n\t\t\t\t\t &byte);\n\tif (status) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Failed to write SDIO_WRITE_FIFO_CTL\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void rsi_rx_handler(struct rsi_hw *adapter)\n{\n\tstruct rsi_common *common = adapter->priv;\n\tstruct rsi_91x_sdiodev *dev = adapter->rsi_dev;\n\tint status;\n\tu8 isr_status = 0;\n\tu8 fw_status = 0;\n\n\tdev->rx_info.sdio_int_counter++;\n\n\tdo {\n\t\tmutex_lock(&common->rx_lock);\n\t\tstatus = rsi_sdio_read_register(common->priv,\n\t\t\t\t\t\tRSI_FN1_INT_REGISTER,\n\t\t\t\t\t\t&isr_status);\n\t\tif (status) {\n\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\"%s: Failed to Read Intr Status Register\\n\",\n\t\t\t\t__func__);\n\t\t\tmutex_unlock(&common->rx_lock);\n\t\t\treturn;\n\t\t}\n\t\tadapter->interrupt_status = isr_status;\n\n\t\tif (isr_status == 0) {\n\t\t\trsi_set_event(&common->tx_thread.event);\n\t\t\tdev->rx_info.sdio_intr_status_zero++;\n\t\t\tmutex_unlock(&common->rx_lock);\n\t\t\treturn;\n\t\t}\n\n\t\trsi_dbg(ISR_ZONE, \"%s: Intr_status = %x %d %d\\n\",\n\t\t\t__func__, isr_status, (1 << MSDU_PKT_PENDING),\n\t\t\t(1 << FW_ASSERT_IND));\n\n\t\tif (isr_status & BIT(PKT_BUFF_AVAILABLE)) {\n\t\t\tstatus = rsi_sdio_check_buffer_status(adapter, 0);\n\t\t\tif (status < 0)\n\t\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\t\"%s: Failed to check buffer status\\n\",\n\t\t\t\t\t__func__);\n\t\t\trsi_sdio_ack_intr(common->priv,\n\t\t\t\t\t  BIT(PKT_BUFF_AVAILABLE));\n\t\t\trsi_set_event(&common->tx_thread.event);\n\n\t\t\trsi_dbg(ISR_ZONE, \"%s: ==> BUFFER_AVAILABLE <==\\n\",\n\t\t\t\t__func__);\n\t\t\tdev->buff_status_updated = true;\n\n\t\t\tisr_status &= ~BIT(PKT_BUFF_AVAILABLE);\n\t\t}\n\n\t\tif (isr_status & BIT(FW_ASSERT_IND)) {\n\t\t\trsi_dbg(ERR_ZONE, \"%s: ==> FIRMWARE Assert <==\\n\",\n\t\t\t\t__func__);\n\t\t\tstatus = rsi_sdio_read_register(common->priv,\n\t\t\t\t\t\t\tSDIO_FW_STATUS_REG,\n\t\t\t\t\t\t\t&fw_status);\n\t\t\tif (status) {\n\t\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\t\"%s: Failed to read f/w reg\\n\",\n\t\t\t\t\t__func__);\n\t\t\t} else {\n\t\t\t\trsi_dbg(ERR_ZONE,\n\t\t\t\t\t\"%s: Firmware Status is 0x%x\\n\",\n\t\t\t\t\t__func__, fw_status);\n\t\t\t\trsi_sdio_ack_intr(common->priv,\n\t\t\t\t\t\t  BIT(FW_ASSERT_IND));\n\t\t\t}\n\n\t\t\tcommon->fsm_state = FSM_CARD_NOT_READY;\n\n\t\t\tisr_status &= ~BIT(FW_ASSERT_IND);\n\t\t}\n\n\t\tif (isr_status & BIT(MSDU_PKT_PENDING)) {\n\t\t\trsi_dbg(ISR_ZONE, \"Pkt pending interrupt\\n\");\n\t\t\tdev->rx_info.total_sdio_msdu_pending_intr++;\n\n\t\t\tstatus = rsi_process_pkt(common);\n\t\t\tif (status) {\n\t\t\t\trsi_dbg(ERR_ZONE, \"%s: Failed to read pkt\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tmutex_unlock(&common->rx_lock);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tisr_status &= ~BIT(MSDU_PKT_PENDING);\n\t\t}\n\n\t\tif (isr_status) {\n\t\t\trsi_sdio_ack_intr(common->priv, isr_status);\n\t\t\tdev->rx_info.total_sdio_unknown_intr++;\n\t\t\tisr_status = 0;\n\t\t\trsi_dbg(ISR_ZONE, \"Unknown Interrupt %x\\n\",\n\t\t\t\tisr_status);\n\t\t}\n\n\t\tmutex_unlock(&common->rx_lock);\n\t} while (1);\n}\n\n \nint rsi_sdio_check_buffer_status(struct rsi_hw *adapter, u8 q_num)\n{\n\tstruct rsi_common *common = adapter->priv;\n\tstruct rsi_91x_sdiodev *dev = adapter->rsi_dev;\n\tu8 buf_status = 0;\n\tint status = 0;\n\tstatic int counter = 4;\n\n\tif (!dev->buff_status_updated && counter) {\n\t\tcounter--;\n\t\tgoto out;\n\t}\n\n\tdev->buff_status_updated = false;\n\tstatus = rsi_sdio_read_register(common->priv,\n\t\t\t\t\tRSI_DEVICE_BUFFER_STATUS_REGISTER,\n\t\t\t\t\t&buf_status);\n\n\tif (status) {\n\t\trsi_dbg(ERR_ZONE,\n\t\t\t\"%s: Failed to read status register\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tif (buf_status & (BIT(PKT_MGMT_BUFF_FULL))) {\n\t\tif (!dev->rx_info.mgmt_buffer_full)\n\t\t\tdev->rx_info.mgmt_buf_full_counter++;\n\t\tdev->rx_info.mgmt_buffer_full = true;\n\t} else {\n\t\tdev->rx_info.mgmt_buffer_full = false;\n\t}\n\n\tif (buf_status & (BIT(PKT_BUFF_FULL))) {\n\t\tif (!dev->rx_info.buffer_full)\n\t\t\tdev->rx_info.buf_full_counter++;\n\t\tdev->rx_info.buffer_full = true;\n\t} else {\n\t\tdev->rx_info.buffer_full = false;\n\t}\n\n\tif (buf_status & (BIT(PKT_BUFF_SEMI_FULL))) {\n\t\tif (!dev->rx_info.semi_buffer_full)\n\t\t\tdev->rx_info.buf_semi_full_counter++;\n\t\tdev->rx_info.semi_buffer_full = true;\n\t} else {\n\t\tdev->rx_info.semi_buffer_full = false;\n\t}\n\n\tif (dev->rx_info.mgmt_buffer_full || dev->rx_info.buf_full_counter)\n\t\tcounter = 1;\n\telse\n\t\tcounter = 4;\n\nout:\n\tif ((q_num == MGMT_SOFT_Q) && (dev->rx_info.mgmt_buffer_full))\n\t\treturn QUEUE_FULL;\n\n\tif ((q_num < MGMT_SOFT_Q) && (dev->rx_info.buffer_full))\n\t\treturn QUEUE_FULL;\n\n\treturn QUEUE_NOT_FULL;\n}\n\n \nint rsi_sdio_determine_event_timeout(struct rsi_hw *adapter)\n{\n\tstruct rsi_91x_sdiodev *dev = adapter->rsi_dev;\n\n\t \n\tif (dev->rx_info.buffer_full)\n\t\treturn 2;\n\n\treturn EVENT_WAIT_FOREVER;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}