{
  "module_name": "testmode.c",
  "hash_id": "1aef592cd98ee50f7da9225913d7d93f7d62750a92c55a372ff20e3602639c6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/testmode.c",
  "human_readable_source": "\n \n\n#include <linux/random.h>\n#include \"mt76.h\"\n\nconst struct nla_policy mt76_tm_policy[NUM_MT76_TM_ATTRS] = {\n\t[MT76_TM_ATTR_RESET] = { .type = NLA_FLAG },\n\t[MT76_TM_ATTR_STATE] = { .type = NLA_U8 },\n\t[MT76_TM_ATTR_TX_COUNT] = { .type = NLA_U32 },\n\t[MT76_TM_ATTR_TX_LENGTH] = { .type = NLA_U32 },\n\t[MT76_TM_ATTR_TX_RATE_MODE] = { .type = NLA_U8 },\n\t[MT76_TM_ATTR_TX_RATE_NSS] = { .type = NLA_U8 },\n\t[MT76_TM_ATTR_TX_RATE_IDX] = { .type = NLA_U8 },\n\t[MT76_TM_ATTR_TX_RATE_SGI] = { .type = NLA_U8 },\n\t[MT76_TM_ATTR_TX_RATE_LDPC] = { .type = NLA_U8 },\n\t[MT76_TM_ATTR_TX_RATE_STBC] = { .type = NLA_U8 },\n\t[MT76_TM_ATTR_TX_LTF] = { .type = NLA_U8 },\n\t[MT76_TM_ATTR_TX_ANTENNA] = { .type = NLA_U8 },\n\t[MT76_TM_ATTR_TX_SPE_IDX] = { .type = NLA_U8 },\n\t[MT76_TM_ATTR_TX_POWER_CONTROL] = { .type = NLA_U8 },\n\t[MT76_TM_ATTR_TX_POWER] = { .type = NLA_NESTED },\n\t[MT76_TM_ATTR_TX_DUTY_CYCLE] = { .type = NLA_U8 },\n\t[MT76_TM_ATTR_TX_IPG] = { .type = NLA_U32 },\n\t[MT76_TM_ATTR_TX_TIME] = { .type = NLA_U32 },\n\t[MT76_TM_ATTR_FREQ_OFFSET] = { .type = NLA_U32 },\n\t[MT76_TM_ATTR_DRV_DATA] = { .type = NLA_NESTED },\n};\nEXPORT_SYMBOL_GPL(mt76_tm_policy);\n\nvoid mt76_testmode_tx_pending(struct mt76_phy *phy)\n{\n\tstruct mt76_testmode_data *td = &phy->test;\n\tstruct mt76_dev *dev = phy->dev;\n\tstruct mt76_wcid *wcid = &dev->global_wcid;\n\tstruct sk_buff *skb = td->tx_skb;\n\tstruct mt76_queue *q;\n\tu16 tx_queued_limit;\n\tint qid;\n\n\tif (!skb || !td->tx_pending)\n\t\treturn;\n\n\tqid = skb_get_queue_mapping(skb);\n\tq = phy->q_tx[qid];\n\n\ttx_queued_limit = td->tx_queued_limit ? td->tx_queued_limit : 1000;\n\n\tspin_lock_bh(&q->lock);\n\n\twhile (td->tx_pending > 0 &&\n\t       td->tx_queued - td->tx_done < tx_queued_limit &&\n\t       q->queued < q->ndesc / 2) {\n\t\tint ret;\n\n\t\tret = dev->queue_ops->tx_queue_skb(dev, q, qid, skb_get(skb),\n\t\t\t\t\t\t   wcid, NULL);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\ttd->tx_pending--;\n\t\ttd->tx_queued++;\n\t}\n\n\tdev->queue_ops->kick(dev, q);\n\n\tspin_unlock_bh(&q->lock);\n}\n\nstatic u32\nmt76_testmode_max_mpdu_len(struct mt76_phy *phy, u8 tx_rate_mode)\n{\n\tswitch (tx_rate_mode) {\n\tcase MT76_TM_TX_MODE_HT:\n\t\treturn IEEE80211_MAX_MPDU_LEN_HT_7935;\n\tcase MT76_TM_TX_MODE_VHT:\n\tcase MT76_TM_TX_MODE_HE_SU:\n\tcase MT76_TM_TX_MODE_HE_EXT_SU:\n\tcase MT76_TM_TX_MODE_HE_TB:\n\tcase MT76_TM_TX_MODE_HE_MU:\n\t\tif (phy->sband_5g.sband.vht_cap.cap &\n\t\t    IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991)\n\t\t\treturn IEEE80211_MAX_MPDU_LEN_VHT_7991;\n\t\treturn IEEE80211_MAX_MPDU_LEN_VHT_11454;\n\tcase MT76_TM_TX_MODE_CCK:\n\tcase MT76_TM_TX_MODE_OFDM:\n\tdefault:\n\t\treturn IEEE80211_MAX_FRAME_LEN;\n\t}\n}\n\nstatic void\nmt76_testmode_free_skb(struct mt76_phy *phy)\n{\n\tstruct mt76_testmode_data *td = &phy->test;\n\n\tdev_kfree_skb(td->tx_skb);\n\ttd->tx_skb = NULL;\n}\n\nint mt76_testmode_alloc_skb(struct mt76_phy *phy, u32 len)\n{\n#define MT_TXP_MAX_LEN\t4095\n\tu16 fc = IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA |\n\t\t IEEE80211_FCTL_FROMDS;\n\tstruct mt76_testmode_data *td = &phy->test;\n\tstruct sk_buff **frag_tail, *head;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_hdr *hdr;\n\tu32 max_len, head_len;\n\tint nfrags, i;\n\n\tmax_len = mt76_testmode_max_mpdu_len(phy, td->tx_rate_mode);\n\tif (len > max_len)\n\t\tlen = max_len;\n\telse if (len < sizeof(struct ieee80211_hdr))\n\t\tlen = sizeof(struct ieee80211_hdr);\n\n\tnfrags = len / MT_TXP_MAX_LEN;\n\thead_len = nfrags ? MT_TXP_MAX_LEN : len;\n\n\tif (len > IEEE80211_MAX_FRAME_LEN)\n\t\tfc |= IEEE80211_STYPE_QOS_DATA;\n\n\thead = alloc_skb(head_len, GFP_KERNEL);\n\tif (!head)\n\t\treturn -ENOMEM;\n\n\thdr = __skb_put_zero(head, sizeof(*hdr));\n\thdr->frame_control = cpu_to_le16(fc);\n\tmemcpy(hdr->addr1, td->addr[0], ETH_ALEN);\n\tmemcpy(hdr->addr2, td->addr[1], ETH_ALEN);\n\tmemcpy(hdr->addr3, td->addr[2], ETH_ALEN);\n\tskb_set_queue_mapping(head, IEEE80211_AC_BE);\n\tget_random_bytes(__skb_put(head, head_len - sizeof(*hdr)),\n\t\t\t head_len - sizeof(*hdr));\n\n\tinfo = IEEE80211_SKB_CB(head);\n\tinfo->flags = IEEE80211_TX_CTL_INJECTED |\n\t\t      IEEE80211_TX_CTL_NO_ACK |\n\t\t      IEEE80211_TX_CTL_NO_PS_BUFFER;\n\n\tinfo->hw_queue |= FIELD_PREP(MT_TX_HW_QUEUE_PHY, phy->band_idx);\n\tfrag_tail = &skb_shinfo(head)->frag_list;\n\n\tfor (i = 0; i < nfrags; i++) {\n\t\tstruct sk_buff *frag;\n\t\tu16 frag_len;\n\n\t\tif (i == nfrags - 1)\n\t\t\tfrag_len = len % MT_TXP_MAX_LEN;\n\t\telse\n\t\t\tfrag_len = MT_TXP_MAX_LEN;\n\n\t\tfrag = alloc_skb(frag_len, GFP_KERNEL);\n\t\tif (!frag) {\n\t\t\tmt76_testmode_free_skb(phy);\n\t\t\tdev_kfree_skb(head);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tget_random_bytes(__skb_put(frag, frag_len), frag_len);\n\t\thead->len += frag->len;\n\t\thead->data_len += frag->len;\n\n\t\t*frag_tail = frag;\n\t\tfrag_tail = &(*frag_tail)->next;\n\t}\n\n\tmt76_testmode_free_skb(phy);\n\ttd->tx_skb = head;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mt76_testmode_alloc_skb);\n\nstatic int\nmt76_testmode_tx_init(struct mt76_phy *phy)\n{\n\tstruct mt76_testmode_data *td = &phy->test;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_tx_rate *rate;\n\tu8 max_nss = hweight8(phy->antenna_mask);\n\tint ret;\n\n\tret = mt76_testmode_alloc_skb(phy, td->tx_mpdu_len);\n\tif (ret)\n\t\treturn ret;\n\n\tif (td->tx_rate_mode > MT76_TM_TX_MODE_VHT)\n\t\tgoto out;\n\n\tif (td->tx_antenna_mask)\n\t\tmax_nss = min_t(u8, max_nss, hweight8(td->tx_antenna_mask));\n\n\tinfo = IEEE80211_SKB_CB(td->tx_skb);\n\trate = &info->control.rates[0];\n\trate->count = 1;\n\trate->idx = td->tx_rate_idx;\n\n\tswitch (td->tx_rate_mode) {\n\tcase MT76_TM_TX_MODE_CCK:\n\t\tif (phy->chandef.chan->band != NL80211_BAND_2GHZ)\n\t\t\treturn -EINVAL;\n\n\t\tif (rate->idx > 4)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase MT76_TM_TX_MODE_OFDM:\n\t\tif (phy->chandef.chan->band != NL80211_BAND_2GHZ)\n\t\t\tbreak;\n\n\t\tif (rate->idx > 8)\n\t\t\treturn -EINVAL;\n\n\t\trate->idx += 4;\n\t\tbreak;\n\tcase MT76_TM_TX_MODE_HT:\n\t\tif (rate->idx > 8 * max_nss &&\n\t\t\t!(rate->idx == 32 &&\n\t\t\t  phy->chandef.width >= NL80211_CHAN_WIDTH_40))\n\t\t\treturn -EINVAL;\n\n\t\trate->flags |= IEEE80211_TX_RC_MCS;\n\t\tbreak;\n\tcase MT76_TM_TX_MODE_VHT:\n\t\tif (rate->idx > 9)\n\t\t\treturn -EINVAL;\n\n\t\tif (td->tx_rate_nss > max_nss)\n\t\t\treturn -EINVAL;\n\n\t\tieee80211_rate_set_vht(rate, td->tx_rate_idx, td->tx_rate_nss);\n\t\trate->flags |= IEEE80211_TX_RC_VHT_MCS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (td->tx_rate_sgi)\n\t\trate->flags |= IEEE80211_TX_RC_SHORT_GI;\n\n\tif (td->tx_rate_ldpc)\n\t\tinfo->flags |= IEEE80211_TX_CTL_LDPC;\n\n\tif (td->tx_rate_stbc)\n\t\tinfo->flags |= IEEE80211_TX_CTL_STBC;\n\n\tif (td->tx_rate_mode >= MT76_TM_TX_MODE_HT) {\n\t\tswitch (phy->chandef.width) {\n\t\tcase NL80211_CHAN_WIDTH_40:\n\t\t\trate->flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\n\t\t\tbreak;\n\t\tcase NL80211_CHAN_WIDTH_80:\n\t\t\trate->flags |= IEEE80211_TX_RC_80_MHZ_WIDTH;\n\t\t\tbreak;\n\t\tcase NL80211_CHAN_WIDTH_80P80:\n\t\tcase NL80211_CHAN_WIDTH_160:\n\t\t\trate->flags |= IEEE80211_TX_RC_160_MHZ_WIDTH;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\treturn 0;\n}\n\nstatic void\nmt76_testmode_tx_start(struct mt76_phy *phy)\n{\n\tstruct mt76_testmode_data *td = &phy->test;\n\tstruct mt76_dev *dev = phy->dev;\n\n\ttd->tx_queued = 0;\n\ttd->tx_done = 0;\n\ttd->tx_pending = td->tx_count;\n\tmt76_worker_schedule(&dev->tx_worker);\n}\n\nstatic void\nmt76_testmode_tx_stop(struct mt76_phy *phy)\n{\n\tstruct mt76_testmode_data *td = &phy->test;\n\tstruct mt76_dev *dev = phy->dev;\n\n\tmt76_worker_disable(&dev->tx_worker);\n\n\ttd->tx_pending = 0;\n\n\tmt76_worker_enable(&dev->tx_worker);\n\n\twait_event_timeout(dev->tx_wait, td->tx_done == td->tx_queued,\n\t\t\t   MT76_TM_TIMEOUT * HZ);\n\n\tmt76_testmode_free_skb(phy);\n}\n\nstatic inline void\nmt76_testmode_param_set(struct mt76_testmode_data *td, u16 idx)\n{\n\ttd->param_set[idx / 32] |= BIT(idx % 32);\n}\n\nstatic inline bool\nmt76_testmode_param_present(struct mt76_testmode_data *td, u16 idx)\n{\n\treturn td->param_set[idx / 32] & BIT(idx % 32);\n}\n\nstatic void\nmt76_testmode_init_defaults(struct mt76_phy *phy)\n{\n\tstruct mt76_testmode_data *td = &phy->test;\n\n\tif (td->tx_mpdu_len > 0)\n\t\treturn;\n\n\ttd->tx_mpdu_len = 1024;\n\ttd->tx_count = 1;\n\ttd->tx_rate_mode = MT76_TM_TX_MODE_OFDM;\n\ttd->tx_rate_nss = 1;\n\n\tmemcpy(td->addr[0], phy->macaddr, ETH_ALEN);\n\tmemcpy(td->addr[1], phy->macaddr, ETH_ALEN);\n\tmemcpy(td->addr[2], phy->macaddr, ETH_ALEN);\n}\n\nstatic int\n__mt76_testmode_set_state(struct mt76_phy *phy, enum mt76_testmode_state state)\n{\n\tenum mt76_testmode_state prev_state = phy->test.state;\n\tstruct mt76_dev *dev = phy->dev;\n\tint err;\n\n\tif (prev_state == MT76_TM_STATE_TX_FRAMES)\n\t\tmt76_testmode_tx_stop(phy);\n\n\tif (state == MT76_TM_STATE_TX_FRAMES) {\n\t\terr = mt76_testmode_tx_init(phy);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = dev->test_ops->set_state(phy, state);\n\tif (err) {\n\t\tif (state == MT76_TM_STATE_TX_FRAMES)\n\t\t\tmt76_testmode_tx_stop(phy);\n\n\t\treturn err;\n\t}\n\n\tif (state == MT76_TM_STATE_TX_FRAMES)\n\t\tmt76_testmode_tx_start(phy);\n\telse if (state == MT76_TM_STATE_RX_FRAMES) {\n\t\tmemset(&phy->test.rx_stats, 0, sizeof(phy->test.rx_stats));\n\t}\n\n\tphy->test.state = state;\n\n\treturn 0;\n}\n\nint mt76_testmode_set_state(struct mt76_phy *phy, enum mt76_testmode_state state)\n{\n\tstruct mt76_testmode_data *td = &phy->test;\n\tstruct ieee80211_hw *hw = phy->hw;\n\n\tif (state == td->state && state == MT76_TM_STATE_OFF)\n\t\treturn 0;\n\n\tif (state > MT76_TM_STATE_OFF &&\n\t    (!test_bit(MT76_STATE_RUNNING, &phy->state) ||\n\t     !(hw->conf.flags & IEEE80211_CONF_MONITOR)))\n\t\treturn -ENOTCONN;\n\n\tif (state != MT76_TM_STATE_IDLE &&\n\t    td->state != MT76_TM_STATE_IDLE) {\n\t\tint ret;\n\n\t\tret = __mt76_testmode_set_state(phy, MT76_TM_STATE_IDLE);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn __mt76_testmode_set_state(phy, state);\n\n}\nEXPORT_SYMBOL(mt76_testmode_set_state);\n\nstatic int\nmt76_tm_get_u8(struct nlattr *attr, u8 *dest, u8 min, u8 max)\n{\n\tu8 val;\n\n\tif (!attr)\n\t\treturn 0;\n\n\tval = nla_get_u8(attr);\n\tif (val < min || val > max)\n\t\treturn -EINVAL;\n\n\t*dest = val;\n\treturn 0;\n}\n\nint mt76_testmode_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t      void *data, int len)\n{\n\tstruct mt76_phy *phy = hw->priv;\n\tstruct mt76_dev *dev = phy->dev;\n\tstruct mt76_testmode_data *td = &phy->test;\n\tstruct nlattr *tb[NUM_MT76_TM_ATTRS];\n\tu32 state;\n\tint err;\n\tint i;\n\n\tif (!dev->test_ops)\n\t\treturn -EOPNOTSUPP;\n\n\terr = nla_parse_deprecated(tb, MT76_TM_ATTR_MAX, data, len,\n\t\t\t\t   mt76_tm_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\terr = -EINVAL;\n\n\tmutex_lock(&dev->mutex);\n\n\tif (tb[MT76_TM_ATTR_RESET]) {\n\t\tmt76_testmode_set_state(phy, MT76_TM_STATE_OFF);\n\t\tmemset(td, 0, sizeof(*td));\n\t}\n\n\tmt76_testmode_init_defaults(phy);\n\n\tif (tb[MT76_TM_ATTR_TX_COUNT])\n\t\ttd->tx_count = nla_get_u32(tb[MT76_TM_ATTR_TX_COUNT]);\n\n\tif (tb[MT76_TM_ATTR_TX_RATE_IDX])\n\t\ttd->tx_rate_idx = nla_get_u8(tb[MT76_TM_ATTR_TX_RATE_IDX]);\n\n\tif (mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_RATE_MODE], &td->tx_rate_mode,\n\t\t\t   0, MT76_TM_TX_MODE_MAX) ||\n\t    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_RATE_NSS], &td->tx_rate_nss,\n\t\t\t   1, hweight8(phy->antenna_mask)) ||\n\t    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_RATE_SGI], &td->tx_rate_sgi, 0, 2) ||\n\t    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_RATE_LDPC], &td->tx_rate_ldpc, 0, 1) ||\n\t    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_RATE_STBC], &td->tx_rate_stbc, 0, 1) ||\n\t    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_LTF], &td->tx_ltf, 0, 2) ||\n\t    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_ANTENNA],\n\t\t\t   &td->tx_antenna_mask, 0, 0xff) ||\n\t    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_SPE_IDX], &td->tx_spe_idx, 0, 27) ||\n\t    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_DUTY_CYCLE],\n\t\t\t   &td->tx_duty_cycle, 0, 99) ||\n\t    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_POWER_CONTROL],\n\t\t\t   &td->tx_power_control, 0, 1))\n\t\tgoto out;\n\n\tif (tb[MT76_TM_ATTR_TX_LENGTH]) {\n\t\tu32 val = nla_get_u32(tb[MT76_TM_ATTR_TX_LENGTH]);\n\n\t\tif (val > mt76_testmode_max_mpdu_len(phy, td->tx_rate_mode) ||\n\t\t    val < sizeof(struct ieee80211_hdr))\n\t\t\tgoto out;\n\n\t\ttd->tx_mpdu_len = val;\n\t}\n\n\tif (tb[MT76_TM_ATTR_TX_IPG])\n\t\ttd->tx_ipg = nla_get_u32(tb[MT76_TM_ATTR_TX_IPG]);\n\n\tif (tb[MT76_TM_ATTR_TX_TIME])\n\t\ttd->tx_time = nla_get_u32(tb[MT76_TM_ATTR_TX_TIME]);\n\n\tif (tb[MT76_TM_ATTR_FREQ_OFFSET])\n\t\ttd->freq_offset = nla_get_u32(tb[MT76_TM_ATTR_FREQ_OFFSET]);\n\n\tif (tb[MT76_TM_ATTR_STATE]) {\n\t\tstate = nla_get_u32(tb[MT76_TM_ATTR_STATE]);\n\t\tif (state > MT76_TM_STATE_MAX)\n\t\t\tgoto out;\n\t} else {\n\t\tstate = td->state;\n\t}\n\n\tif (tb[MT76_TM_ATTR_TX_POWER]) {\n\t\tstruct nlattr *cur;\n\t\tint idx = 0;\n\t\tint rem;\n\n\t\tnla_for_each_nested(cur, tb[MT76_TM_ATTR_TX_POWER], rem) {\n\t\t\tif (nla_len(cur) != 1 ||\n\t\t\t    idx >= ARRAY_SIZE(td->tx_power))\n\t\t\t\tgoto out;\n\n\t\t\ttd->tx_power[idx++] = nla_get_u8(cur);\n\t\t}\n\t}\n\n\tif (tb[MT76_TM_ATTR_MAC_ADDRS]) {\n\t\tstruct nlattr *cur;\n\t\tint idx = 0;\n\t\tint rem;\n\n\t\tnla_for_each_nested(cur, tb[MT76_TM_ATTR_MAC_ADDRS], rem) {\n\t\t\tif (nla_len(cur) != ETH_ALEN || idx >= 3)\n\t\t\t\tgoto out;\n\n\t\t\tmemcpy(td->addr[idx], nla_data(cur), ETH_ALEN);\n\t\t\tidx++;\n\t\t}\n\t}\n\n\tif (dev->test_ops->set_params) {\n\t\terr = dev->test_ops->set_params(phy, tb, state);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tfor (i = MT76_TM_ATTR_STATE; i < ARRAY_SIZE(tb); i++)\n\t\tif (tb[i])\n\t\t\tmt76_testmode_param_set(td, i);\n\n\terr = 0;\n\tif (tb[MT76_TM_ATTR_STATE])\n\t\terr = mt76_testmode_set_state(phy, state);\n\nout:\n\tmutex_unlock(&dev->mutex);\n\n\treturn err;\n}\nEXPORT_SYMBOL(mt76_testmode_cmd);\n\nstatic int\nmt76_testmode_dump_stats(struct mt76_phy *phy, struct sk_buff *msg)\n{\n\tstruct mt76_testmode_data *td = &phy->test;\n\tstruct mt76_dev *dev = phy->dev;\n\tu64 rx_packets = 0;\n\tu64 rx_fcs_error = 0;\n\tint i;\n\n\tif (dev->test_ops->dump_stats) {\n\t\tint ret;\n\n\t\tret = dev->test_ops->dump_stats(phy, msg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(td->rx_stats.packets); i++) {\n\t\trx_packets += td->rx_stats.packets[i];\n\t\trx_fcs_error += td->rx_stats.fcs_error[i];\n\t}\n\n\tif (nla_put_u32(msg, MT76_TM_STATS_ATTR_TX_PENDING, td->tx_pending) ||\n\t    nla_put_u32(msg, MT76_TM_STATS_ATTR_TX_QUEUED, td->tx_queued) ||\n\t    nla_put_u32(msg, MT76_TM_STATS_ATTR_TX_DONE, td->tx_done) ||\n\t    nla_put_u64_64bit(msg, MT76_TM_STATS_ATTR_RX_PACKETS, rx_packets,\n\t\t\t      MT76_TM_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(msg, MT76_TM_STATS_ATTR_RX_FCS_ERROR, rx_fcs_error,\n\t\t\t      MT76_TM_STATS_ATTR_PAD))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nint mt76_testmode_dump(struct ieee80211_hw *hw, struct sk_buff *msg,\n\t\t       struct netlink_callback *cb, void *data, int len)\n{\n\tstruct mt76_phy *phy = hw->priv;\n\tstruct mt76_dev *dev = phy->dev;\n\tstruct mt76_testmode_data *td = &phy->test;\n\tstruct nlattr *tb[NUM_MT76_TM_ATTRS] = {};\n\tint err = 0;\n\tvoid *a;\n\tint i;\n\n\tif (!dev->test_ops)\n\t\treturn -EOPNOTSUPP;\n\n\tif (cb->args[2]++ > 0)\n\t\treturn -ENOENT;\n\n\tif (data) {\n\t\terr = nla_parse_deprecated(tb, MT76_TM_ATTR_MAX, data, len,\n\t\t\t\t\t   mt76_tm_policy, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmutex_lock(&dev->mutex);\n\n\tif (tb[MT76_TM_ATTR_STATS]) {\n\t\terr = -EINVAL;\n\n\t\ta = nla_nest_start(msg, MT76_TM_ATTR_STATS);\n\t\tif (a) {\n\t\t\terr = mt76_testmode_dump_stats(phy, msg);\n\t\t\tnla_nest_end(msg, a);\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tmt76_testmode_init_defaults(phy);\n\n\terr = -EMSGSIZE;\n\tif (nla_put_u32(msg, MT76_TM_ATTR_STATE, td->state))\n\t\tgoto out;\n\n\tif (dev->test_mtd.name &&\n\t    (nla_put_string(msg, MT76_TM_ATTR_MTD_PART, dev->test_mtd.name) ||\n\t     nla_put_u32(msg, MT76_TM_ATTR_MTD_OFFSET, dev->test_mtd.offset)))\n\t\tgoto out;\n\n\tif (nla_put_u32(msg, MT76_TM_ATTR_TX_COUNT, td->tx_count) ||\n\t    nla_put_u32(msg, MT76_TM_ATTR_TX_LENGTH, td->tx_mpdu_len) ||\n\t    nla_put_u8(msg, MT76_TM_ATTR_TX_RATE_MODE, td->tx_rate_mode) ||\n\t    nla_put_u8(msg, MT76_TM_ATTR_TX_RATE_NSS, td->tx_rate_nss) ||\n\t    nla_put_u8(msg, MT76_TM_ATTR_TX_RATE_IDX, td->tx_rate_idx) ||\n\t    nla_put_u8(msg, MT76_TM_ATTR_TX_RATE_SGI, td->tx_rate_sgi) ||\n\t    nla_put_u8(msg, MT76_TM_ATTR_TX_RATE_LDPC, td->tx_rate_ldpc) ||\n\t    nla_put_u8(msg, MT76_TM_ATTR_TX_RATE_STBC, td->tx_rate_stbc) ||\n\t    (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_LTF) &&\n\t     nla_put_u8(msg, MT76_TM_ATTR_TX_LTF, td->tx_ltf)) ||\n\t    (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_ANTENNA) &&\n\t     nla_put_u8(msg, MT76_TM_ATTR_TX_ANTENNA, td->tx_antenna_mask)) ||\n\t    (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_SPE_IDX) &&\n\t     nla_put_u8(msg, MT76_TM_ATTR_TX_SPE_IDX, td->tx_spe_idx)) ||\n\t    (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_DUTY_CYCLE) &&\n\t     nla_put_u8(msg, MT76_TM_ATTR_TX_DUTY_CYCLE, td->tx_duty_cycle)) ||\n\t    (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_IPG) &&\n\t     nla_put_u32(msg, MT76_TM_ATTR_TX_IPG, td->tx_ipg)) ||\n\t    (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_TIME) &&\n\t     nla_put_u32(msg, MT76_TM_ATTR_TX_TIME, td->tx_time)) ||\n\t    (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_POWER_CONTROL) &&\n\t     nla_put_u8(msg, MT76_TM_ATTR_TX_POWER_CONTROL, td->tx_power_control)) ||\n\t    (mt76_testmode_param_present(td, MT76_TM_ATTR_FREQ_OFFSET) &&\n\t     nla_put_u8(msg, MT76_TM_ATTR_FREQ_OFFSET, td->freq_offset)))\n\t\tgoto out;\n\n\tif (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_POWER)) {\n\t\ta = nla_nest_start(msg, MT76_TM_ATTR_TX_POWER);\n\t\tif (!a)\n\t\t\tgoto out;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(td->tx_power); i++)\n\t\t\tif (nla_put_u8(msg, i, td->tx_power[i]))\n\t\t\t\tgoto out;\n\n\t\tnla_nest_end(msg, a);\n\t}\n\n\tif (mt76_testmode_param_present(td, MT76_TM_ATTR_MAC_ADDRS)) {\n\t\ta = nla_nest_start(msg, MT76_TM_ATTR_MAC_ADDRS);\n\t\tif (!a)\n\t\t\tgoto out;\n\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tif (nla_put(msg, i, ETH_ALEN, td->addr[i]))\n\t\t\t\tgoto out;\n\n\t\tnla_nest_end(msg, a);\n\t}\n\n\terr = 0;\n\nout:\n\tmutex_unlock(&dev->mutex);\n\n\treturn err;\n}\nEXPORT_SYMBOL(mt76_testmode_dump);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}