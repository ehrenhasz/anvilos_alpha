{
  "module_name": "main.c",
  "hash_id": "19b92b62e61a017a6eb82ac17f1c945058c88b78a9dd62264b5ad2cedaf681d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7603/main.c",
  "human_readable_source": "\n\n#include <linux/etherdevice.h>\n#include <linux/platform_device.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include \"mt7603.h\"\n#include \"mac.h\"\n#include \"eeprom.h\"\n\nstatic int\nmt7603_start(struct ieee80211_hw *hw)\n{\n\tstruct mt7603_dev *dev = hw->priv;\n\n\tmt7603_mac_reset_counters(dev);\n\tmt7603_mac_start(dev);\n\tdev->mphy.survey_time = ktime_get_boottime();\n\tset_bit(MT76_STATE_RUNNING, &dev->mphy.state);\n\tmt7603_mac_work(&dev->mphy.mac_work.work);\n\n\treturn 0;\n}\n\nstatic void\nmt7603_stop(struct ieee80211_hw *hw)\n{\n\tstruct mt7603_dev *dev = hw->priv;\n\n\tclear_bit(MT76_STATE_RUNNING, &dev->mphy.state);\n\tcancel_delayed_work_sync(&dev->mphy.mac_work);\n\tmt7603_mac_stop(dev);\n}\n\nstatic int\nmt7603_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct mt7603_vif *mvif = (struct mt7603_vif *)vif->drv_priv;\n\tstruct mt7603_dev *dev = hw->priv;\n\tstruct mt76_txq *mtxq;\n\tu8 bc_addr[ETH_ALEN];\n\tint idx;\n\tint ret = 0;\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tmvif->idx = __ffs64(~dev->mt76.vif_mask);\n\tif (mvif->idx >= MT7603_MAX_INTERFACES) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tmt76_wr(dev, MT_MAC_ADDR0(mvif->idx),\n\t\tget_unaligned_le32(vif->addr));\n\tmt76_wr(dev, MT_MAC_ADDR1(mvif->idx),\n\t\t(get_unaligned_le16(vif->addr + 4) |\n\t\t MT_MAC_ADDR1_VALID));\n\n\tif (vif->type == NL80211_IFTYPE_AP) {\n\t\tmt76_wr(dev, MT_BSSID0(mvif->idx),\n\t\t\tget_unaligned_le32(vif->addr));\n\t\tmt76_wr(dev, MT_BSSID1(mvif->idx),\n\t\t\t(get_unaligned_le16(vif->addr + 4) |\n\t\t\t MT_BSSID1_VALID));\n\t}\n\n\tidx = MT7603_WTBL_RESERVED - 1 - mvif->idx;\n\tdev->mt76.vif_mask |= BIT_ULL(mvif->idx);\n\tINIT_LIST_HEAD(&mvif->sta.wcid.poll_list);\n\tmvif->sta.wcid.idx = idx;\n\tmvif->sta.wcid.hw_key_idx = -1;\n\tmvif->sta.vif = mvif;\n\tmt76_packet_id_init(&mvif->sta.wcid);\n\n\teth_broadcast_addr(bc_addr);\n\tmt7603_wtbl_init(dev, idx, mvif->idx, bc_addr);\n\n\tmtxq = (struct mt76_txq *)vif->txq->drv_priv;\n\tmtxq->wcid = idx;\n\trcu_assign_pointer(dev->mt76.wcid[idx], &mvif->sta.wcid);\n\nout:\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn ret;\n}\n\nstatic void\nmt7603_remove_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct mt7603_vif *mvif = (struct mt7603_vif *)vif->drv_priv;\n\tstruct mt7603_sta *msta = &mvif->sta;\n\tstruct mt7603_dev *dev = hw->priv;\n\tint idx = msta->wcid.idx;\n\n\tmt76_wr(dev, MT_MAC_ADDR0(mvif->idx), 0);\n\tmt76_wr(dev, MT_MAC_ADDR1(mvif->idx), 0);\n\tmt76_wr(dev, MT_BSSID0(mvif->idx), 0);\n\tmt76_wr(dev, MT_BSSID1(mvif->idx), 0);\n\tmt7603_beacon_set_timer(dev, mvif->idx, 0);\n\n\trcu_assign_pointer(dev->mt76.wcid[idx], NULL);\n\n\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\tif (!list_empty(&msta->wcid.poll_list))\n\t\tlist_del_init(&msta->wcid.poll_list);\n\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\n\tmutex_lock(&dev->mt76.mutex);\n\tdev->mt76.vif_mask &= ~BIT_ULL(mvif->idx);\n\tmutex_unlock(&dev->mt76.mutex);\n\n\tmt76_packet_id_flush(&dev->mt76, &mvif->sta.wcid);\n}\n\nvoid mt7603_init_edcca(struct mt7603_dev *dev)\n{\n\t \n\tmt76_rmw_field(dev, MT_RXTD(8), MT_RXTD_8_LOWER_SIGNAL, 0x23);\n\n\t \n\tmt76_rr(dev, MT_MIB_STAT_ED);\n\n\tif (dev->ed_monitor)\n\t\tmt76_set(dev, MT_MIB_CTL, MT_MIB_CTL_ED_TIME);\n\telse\n\t\tmt76_clear(dev, MT_MIB_CTL, MT_MIB_CTL_ED_TIME);\n\n\tdev->ed_strict_mode = 0xff;\n\tdev->ed_strong_signal = 0;\n\tdev->ed_time = ktime_get_boottime();\n\n\tmt7603_edcca_set_strict(dev, false);\n}\n\nstatic int\nmt7603_set_channel(struct ieee80211_hw *hw, struct cfg80211_chan_def *def)\n{\n\tstruct mt7603_dev *dev = hw->priv;\n\tu8 *rssi_data = (u8 *)dev->mt76.eeprom.data;\n\tint idx, ret;\n\tu8 bw = MT_BW_20;\n\tbool failed = false;\n\n\tieee80211_stop_queues(hw);\n\tcancel_delayed_work_sync(&dev->mphy.mac_work);\n\ttasklet_disable(&dev->mt76.pre_tbtt_tasklet);\n\n\tmutex_lock(&dev->mt76.mutex);\n\tset_bit(MT76_RESET, &dev->mphy.state);\n\n\tmt7603_beacon_set_timer(dev, -1, 0);\n\tmt76_set_channel(&dev->mphy);\n\tmt7603_mac_stop(dev);\n\n\tif (def->width == NL80211_CHAN_WIDTH_40)\n\t\tbw = MT_BW_40;\n\n\tdev->mphy.chandef = *def;\n\tmt76_rmw_field(dev, MT_AGG_BWCR, MT_AGG_BWCR_BW, bw);\n\tret = mt7603_mcu_set_channel(dev);\n\tif (ret) {\n\t\tfailed = true;\n\t\tgoto out;\n\t}\n\n\tif (def->chan->band == NL80211_BAND_5GHZ) {\n\t\tidx = 1;\n\t\trssi_data += MT_EE_RSSI_OFFSET_5G;\n\t} else {\n\t\tidx = 0;\n\t\trssi_data += MT_EE_RSSI_OFFSET_2G;\n\t}\n\n\tmemcpy(dev->rssi_offset, rssi_data, sizeof(dev->rssi_offset));\n\n\tidx |= (def->chan -\n\t\tmt76_hw(dev)->wiphy->bands[def->chan->band]->channels) << 1;\n\tmt76_wr(dev, MT_WF_RMAC_CH_FREQ, idx);\n\tmt7603_mac_set_timing(dev);\n\tmt7603_mac_start(dev);\n\n\tclear_bit(MT76_RESET, &dev->mphy.state);\n\n\tmt76_txq_schedule_all(&dev->mphy);\n\n\tieee80211_queue_delayed_work(mt76_hw(dev), &dev->mphy.mac_work,\n\t\t\t\t     msecs_to_jiffies(MT7603_WATCHDOG_TIME));\n\n\t \n\tmt76_clear(dev, MT_MIB_CTL, MT_MIB_CTL_READ_CLR_DIS);\n\tmt76_set(dev, MT_MIB_CTL,\n\t\t MT_MIB_CTL_CCA_NAV_TX | MT_MIB_CTL_PSCCA_TIME);\n\tmt76_rr(dev, MT_MIB_STAT_CCA);\n\tmt7603_cca_stats_reset(dev);\n\n\tdev->mphy.survey_time = ktime_get_boottime();\n\n\tmt7603_init_edcca(dev);\n\nout:\n\tif (!(mt76_hw(dev)->conf.flags & IEEE80211_CONF_OFFCHANNEL))\n\t\tmt7603_beacon_set_timer(dev, -1, dev->mt76.beacon_int);\n\tmutex_unlock(&dev->mt76.mutex);\n\n\ttasklet_enable(&dev->mt76.pre_tbtt_tasklet);\n\n\tif (failed)\n\t\tmt7603_mac_work(&dev->mphy.mac_work.work);\n\n\tieee80211_wake_queues(hw);\n\n\treturn ret;\n}\n\nstatic int mt7603_set_sar_specs(struct ieee80211_hw *hw,\n\t\t\t\tconst struct cfg80211_sar_specs *sar)\n{\n\tstruct mt7603_dev *dev = hw->priv;\n\tstruct mt76_phy *mphy = &dev->mphy;\n\tint err;\n\n\tif (!cfg80211_chandef_valid(&mphy->chandef))\n\t\treturn -EINVAL;\n\n\terr = mt76_init_sar_power(hw, sar);\n\tif (err)\n\t\treturn err;\n\n\treturn mt7603_set_channel(hw, &mphy->chandef);\n}\n\nstatic int\nmt7603_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct mt7603_dev *dev = hw->priv;\n\tint ret = 0;\n\n\tif (changed & (IEEE80211_CONF_CHANGE_CHANNEL |\n\t\t       IEEE80211_CONF_CHANGE_POWER))\n\t\tret = mt7603_set_channel(hw, &hw->conf.chandef);\n\n\tif (changed & IEEE80211_CONF_CHANGE_MONITOR) {\n\t\tmutex_lock(&dev->mt76.mutex);\n\n\t\tif (!(hw->conf.flags & IEEE80211_CONF_MONITOR))\n\t\t\tdev->rxfilter |= MT_WF_RFCR_DROP_OTHER_UC;\n\t\telse\n\t\t\tdev->rxfilter &= ~MT_WF_RFCR_DROP_OTHER_UC;\n\n\t\tmt76_wr(dev, MT_WF_RFCR, dev->rxfilter);\n\n\t\tmutex_unlock(&dev->mt76.mutex);\n\t}\n\n\treturn ret;\n}\n\nstatic void\nmt7603_configure_filter(struct ieee80211_hw *hw, unsigned int changed_flags,\n\t\t\tunsigned int *total_flags, u64 multicast)\n{\n\tstruct mt7603_dev *dev = hw->priv;\n\tu32 flags = 0;\n\n#define MT76_FILTER(_flag, _hw) do { \\\n\t\tflags |= *total_flags & FIF_##_flag;\t\t\t\\\n\t\tdev->rxfilter &= ~(_hw);\t\t\t\t\\\n\t\tdev->rxfilter |= !(flags & FIF_##_flag) * (_hw);\t\\\n\t} while (0)\n\n\tdev->rxfilter &= ~(MT_WF_RFCR_DROP_OTHER_BSS |\n\t\t\t   MT_WF_RFCR_DROP_OTHER_BEACON |\n\t\t\t   MT_WF_RFCR_DROP_FRAME_REPORT |\n\t\t\t   MT_WF_RFCR_DROP_PROBEREQ |\n\t\t\t   MT_WF_RFCR_DROP_MCAST_FILTERED |\n\t\t\t   MT_WF_RFCR_DROP_MCAST |\n\t\t\t   MT_WF_RFCR_DROP_BCAST |\n\t\t\t   MT_WF_RFCR_DROP_DUPLICATE |\n\t\t\t   MT_WF_RFCR_DROP_A2_BSSID |\n\t\t\t   MT_WF_RFCR_DROP_UNWANTED_CTL |\n\t\t\t   MT_WF_RFCR_DROP_STBC_MULTI);\n\n\tMT76_FILTER(OTHER_BSS, MT_WF_RFCR_DROP_OTHER_TIM |\n\t\t\t       MT_WF_RFCR_DROP_A3_MAC |\n\t\t\t       MT_WF_RFCR_DROP_A3_BSSID);\n\n\tMT76_FILTER(FCSFAIL, MT_WF_RFCR_DROP_FCSFAIL);\n\n\tMT76_FILTER(CONTROL, MT_WF_RFCR_DROP_CTS |\n\t\t\t     MT_WF_RFCR_DROP_RTS |\n\t\t\t     MT_WF_RFCR_DROP_CTL_RSV |\n\t\t\t     MT_WF_RFCR_DROP_NDPA);\n\n\t*total_flags = flags;\n\tmt76_wr(dev, MT_WF_RFCR, dev->rxfilter);\n}\n\nstatic void\nmt7603_bss_info_changed(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_bss_conf *info, u64 changed)\n{\n\tstruct mt7603_dev *dev = hw->priv;\n\tstruct mt7603_vif *mvif = (struct mt7603_vif *)vif->drv_priv;\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tif (changed & (BSS_CHANGED_ASSOC | BSS_CHANGED_BSSID)) {\n\t\tif (vif->cfg.assoc || vif->cfg.ibss_joined) {\n\t\t\tmt76_wr(dev, MT_BSSID0(mvif->idx),\n\t\t\t\tget_unaligned_le32(info->bssid));\n\t\t\tmt76_wr(dev, MT_BSSID1(mvif->idx),\n\t\t\t\t(get_unaligned_le16(info->bssid + 4) |\n\t\t\t\t MT_BSSID1_VALID));\n\t\t} else {\n\t\t\tmt76_wr(dev, MT_BSSID0(mvif->idx), 0);\n\t\t\tmt76_wr(dev, MT_BSSID1(mvif->idx), 0);\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\tint slottime = info->use_short_slot ? 9 : 20;\n\n\t\tif (slottime != dev->slottime) {\n\t\t\tdev->slottime = slottime;\n\t\t\tmt7603_mac_set_timing(dev);\n\t\t}\n\t}\n\n\tif (changed & (BSS_CHANGED_BEACON_ENABLED | BSS_CHANGED_BEACON_INT)) {\n\t\tint beacon_int = !!info->enable_beacon * info->beacon_int;\n\n\t\ttasklet_disable(&dev->mt76.pre_tbtt_tasklet);\n\t\tmt7603_beacon_set_timer(dev, mvif->idx, beacon_int);\n\t\ttasklet_enable(&dev->mt76.pre_tbtt_tasklet);\n\t}\n\n\tmutex_unlock(&dev->mt76.mutex);\n}\n\nint\nmt7603_sta_add(struct mt76_dev *mdev, struct ieee80211_vif *vif,\n\t       struct ieee80211_sta *sta)\n{\n\tstruct mt7603_dev *dev = container_of(mdev, struct mt7603_dev, mt76);\n\tstruct mt7603_sta *msta = (struct mt7603_sta *)sta->drv_priv;\n\tstruct mt7603_vif *mvif = (struct mt7603_vif *)vif->drv_priv;\n\tint idx;\n\tint ret = 0;\n\n\tidx = mt76_wcid_alloc(dev->mt76.wcid_mask, MT7603_WTBL_STA - 1);\n\tif (idx < 0)\n\t\treturn -ENOSPC;\n\n\tINIT_LIST_HEAD(&msta->wcid.poll_list);\n\t__skb_queue_head_init(&msta->psq);\n\tmsta->ps = ~0;\n\tmsta->smps = ~0;\n\tmsta->wcid.sta = 1;\n\tmsta->wcid.idx = idx;\n\tmsta->vif = mvif;\n\tmt7603_wtbl_init(dev, idx, mvif->idx, sta->addr);\n\tmt7603_wtbl_set_ps(dev, msta, false);\n\n\tif (vif->type == NL80211_IFTYPE_AP)\n\t\tset_bit(MT_WCID_FLAG_CHECK_PS, &msta->wcid.flags);\n\n\treturn ret;\n}\n\nvoid\nmt7603_sta_assoc(struct mt76_dev *mdev, struct ieee80211_vif *vif,\n\t\t struct ieee80211_sta *sta)\n{\n\tstruct mt7603_dev *dev = container_of(mdev, struct mt7603_dev, mt76);\n\n\tmt7603_wtbl_update_cap(dev, sta);\n}\n\nvoid\nmt7603_sta_remove(struct mt76_dev *mdev, struct ieee80211_vif *vif,\n\t\t  struct ieee80211_sta *sta)\n{\n\tstruct mt7603_dev *dev = container_of(mdev, struct mt7603_dev, mt76);\n\tstruct mt7603_vif *mvif = (struct mt7603_vif *)vif->drv_priv;\n\tstruct mt7603_sta *msta = (struct mt7603_sta *)sta->drv_priv;\n\tstruct mt76_wcid *wcid = (struct mt76_wcid *)sta->drv_priv;\n\n\tspin_lock_bh(&dev->ps_lock);\n\t__skb_queue_purge(&msta->psq);\n\tmt7603_filter_tx(dev, mvif->idx, wcid->idx, true);\n\tspin_unlock_bh(&dev->ps_lock);\n\n\tspin_lock_bh(&mdev->sta_poll_lock);\n\tif (!list_empty(&msta->wcid.poll_list))\n\t\tlist_del_init(&msta->wcid.poll_list);\n\tspin_unlock_bh(&mdev->sta_poll_lock);\n\n\tmt7603_wtbl_clear(dev, wcid->idx);\n}\n\nstatic void\nmt7603_ps_tx_list(struct mt7603_dev *dev, struct sk_buff_head *list)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = __skb_dequeue(list)) != NULL) {\n\t\tint qid = skb_get_queue_mapping(skb);\n\n\t\tmt76_tx_queue_skb_raw(dev, dev->mphy.q_tx[qid], skb, 0);\n\t}\n}\n\nvoid\nmt7603_sta_ps(struct mt76_dev *mdev, struct ieee80211_sta *sta, bool ps)\n{\n\tstruct mt7603_dev *dev = container_of(mdev, struct mt7603_dev, mt76);\n\tstruct mt7603_sta *msta = (struct mt7603_sta *)sta->drv_priv;\n\tstruct sk_buff_head list;\n\n\tmt76_stop_tx_queues(&dev->mphy, sta, true);\n\tmt7603_wtbl_set_ps(dev, msta, ps);\n\tif (ps)\n\t\treturn;\n\n\t__skb_queue_head_init(&list);\n\n\tspin_lock_bh(&dev->ps_lock);\n\tskb_queue_splice_tail_init(&msta->psq, &list);\n\tspin_unlock_bh(&dev->ps_lock);\n\n\tmt7603_ps_tx_list(dev, &list);\n}\n\nstatic void\nmt7603_ps_set_more_data(struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr;\n\n\thdr = (struct ieee80211_hdr *)&skb->data[MT_TXD_SIZE];\n\thdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_MOREDATA);\n}\n\nstatic void\nmt7603_release_buffered_frames(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_sta *sta,\n\t\t\t       u16 tids, int nframes,\n\t\t\t       enum ieee80211_frame_release_type reason,\n\t\t\t       bool more_data)\n{\n\tstruct mt7603_dev *dev = hw->priv;\n\tstruct mt7603_sta *msta = (struct mt7603_sta *)sta->drv_priv;\n\tstruct sk_buff_head list;\n\tstruct sk_buff *skb, *tmp;\n\n\t__skb_queue_head_init(&list);\n\n\tmt7603_wtbl_set_ps(dev, msta, false);\n\n\tspin_lock_bh(&dev->ps_lock);\n\tskb_queue_walk_safe(&msta->psq, skb, tmp) {\n\t\tif (!nframes)\n\t\t\tbreak;\n\n\t\tif (!(tids & BIT(skb->priority)))\n\t\t\tcontinue;\n\n\t\tskb_set_queue_mapping(skb, MT_TXQ_PSD);\n\t\t__skb_unlink(skb, &msta->psq);\n\t\tmt7603_ps_set_more_data(skb);\n\t\t__skb_queue_tail(&list, skb);\n\t\tnframes--;\n\t}\n\tspin_unlock_bh(&dev->ps_lock);\n\n\tif (!skb_queue_empty(&list))\n\t\tieee80211_sta_eosp(sta);\n\n\tmt7603_ps_tx_list(dev, &list);\n\n\tif (nframes)\n\t\tmt76_release_buffered_frames(hw, sta, tids, nframes, reason,\n\t\t\t\t\t     more_data);\n}\n\nstatic int\nmt7603_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t       struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t       struct ieee80211_key_conf *key)\n{\n\tstruct mt7603_dev *dev = hw->priv;\n\tstruct mt7603_vif *mvif = (struct mt7603_vif *)vif->drv_priv;\n\tstruct mt7603_sta *msta = sta ? (struct mt7603_sta *)sta->drv_priv :\n\t\t\t\t  &mvif->sta;\n\tstruct mt76_wcid *wcid = &msta->wcid;\n\tint idx = key->keyidx;\n\n\t \n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif ((vif->type == NL80211_IFTYPE_ADHOC ||\n\t     vif->type == NL80211_IFTYPE_MESH_POINT) &&\n\t    (key->cipher == WLAN_CIPHER_SUITE_TKIP ||\n\t     key->cipher == WLAN_CIPHER_SUITE_CCMP) &&\n\t    !(key->flags & IEEE80211_KEY_FLAG_PAIRWISE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (cmd != SET_KEY) {\n\t\tif (idx == wcid->hw_key_idx)\n\t\t\twcid->hw_key_idx = -1;\n\n\t\treturn 0;\n\t}\n\n\tkey->hw_key_idx = wcid->idx;\n\twcid->hw_key_idx = idx;\n\tmt76_wcid_key_setup(&dev->mt76, wcid, key);\n\n\treturn mt7603_wtbl_set_key(dev, wcid->idx, key);\n}\n\nstatic int\nmt7603_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t       unsigned int link_id, u16 queue,\n\t       const struct ieee80211_tx_queue_params *params)\n{\n\tstruct mt7603_dev *dev = hw->priv;\n\tu16 cw_min = (1 << 5) - 1;\n\tu16 cw_max = (1 << 10) - 1;\n\tu32 val;\n\n\tqueue = dev->mphy.q_tx[queue]->hw_idx;\n\n\tif (params->cw_min)\n\t\tcw_min = params->cw_min;\n\tif (params->cw_max)\n\t\tcw_max = params->cw_max;\n\n\tmutex_lock(&dev->mt76.mutex);\n\tmt7603_mac_stop(dev);\n\n\tval = mt76_rr(dev, MT_WMM_TXOP(queue));\n\tval &= ~(MT_WMM_TXOP_MASK << MT_WMM_TXOP_SHIFT(queue));\n\tval |= params->txop << MT_WMM_TXOP_SHIFT(queue);\n\tmt76_wr(dev, MT_WMM_TXOP(queue), val);\n\n\tval = mt76_rr(dev, MT_WMM_AIFSN);\n\tval &= ~(MT_WMM_AIFSN_MASK << MT_WMM_AIFSN_SHIFT(queue));\n\tval |= params->aifs << MT_WMM_AIFSN_SHIFT(queue);\n\tmt76_wr(dev, MT_WMM_AIFSN, val);\n\n\tval = mt76_rr(dev, MT_WMM_CWMIN);\n\tval &= ~(MT_WMM_CWMIN_MASK << MT_WMM_CWMIN_SHIFT(queue));\n\tval |= cw_min << MT_WMM_CWMIN_SHIFT(queue);\n\tmt76_wr(dev, MT_WMM_CWMIN, val);\n\n\tval = mt76_rr(dev, MT_WMM_CWMAX(queue));\n\tval &= ~(MT_WMM_CWMAX_MASK << MT_WMM_CWMAX_SHIFT(queue));\n\tval |= cw_max << MT_WMM_CWMAX_SHIFT(queue);\n\tmt76_wr(dev, MT_WMM_CWMAX(queue), val);\n\n\tmt7603_mac_start(dev);\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn 0;\n}\n\nstatic void\nmt7603_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t     u32 queues, bool drop)\n{\n}\n\nstatic int\nmt7603_ampdu_action(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t    struct ieee80211_ampdu_params *params)\n{\n\tenum ieee80211_ampdu_mlme_action action = params->action;\n\tstruct mt7603_dev *dev = hw->priv;\n\tstruct ieee80211_sta *sta = params->sta;\n\tstruct ieee80211_txq *txq = sta->txq[params->tid];\n\tstruct mt7603_sta *msta = (struct mt7603_sta *)sta->drv_priv;\n\tu16 tid = params->tid;\n\tu16 ssn = params->ssn;\n\tu8 ba_size = params->buf_size;\n\tstruct mt76_txq *mtxq;\n\tint ret = 0;\n\n\tif (!txq)\n\t\treturn -EINVAL;\n\n\tmtxq = (struct mt76_txq *)txq->drv_priv;\n\n\tmutex_lock(&dev->mt76.mutex);\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_RX_START:\n\t\tmt76_rx_aggr_start(&dev->mt76, &msta->wcid, tid, ssn,\n\t\t\t\t   params->buf_size);\n\t\tmt7603_mac_rx_ba_reset(dev, sta->addr, tid);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\tmt76_rx_aggr_stop(&dev->mt76, &msta->wcid, tid);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\tmtxq->aggr = true;\n\t\tmtxq->send_bar = false;\n\t\tmt7603_mac_tx_ba_reset(dev, msta->wcid.idx, tid, ba_size);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\t\tmtxq->aggr = false;\n\t\tmt7603_mac_tx_ba_reset(dev, msta->wcid.idx, tid, -1);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_START:\n\t\tmtxq->agg_ssn = IEEE80211_SN_TO_SEQ(ssn);\n\t\tret = IEEE80211_AMPDU_TX_START_IMMEDIATE;\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\t\tmtxq->aggr = false;\n\t\tmt7603_mac_tx_ba_reset(dev, msta->wcid.idx, tid, -1);\n\t\tieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\t\tbreak;\n\t}\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn ret;\n}\n\nstatic void\nmt7603_sta_rate_tbl_update(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_sta *sta)\n{\n\tstruct mt7603_dev *dev = hw->priv;\n\tstruct mt7603_sta *msta = (struct mt7603_sta *)sta->drv_priv;\n\tstruct ieee80211_sta_rates *sta_rates = rcu_dereference(sta->rates);\n\tint i;\n\n\tif (!sta_rates)\n\t\treturn;\n\n\tspin_lock_bh(&dev->mt76.lock);\n\tfor (i = 0; i < ARRAY_SIZE(msta->rates); i++) {\n\t\tmsta->rates[i].idx = sta_rates->rate[i].idx;\n\t\tmsta->rates[i].count = sta_rates->rate[i].count;\n\t\tmsta->rates[i].flags = sta_rates->rate[i].flags;\n\n\t\tif (msta->rates[i].idx < 0 || !msta->rates[i].count)\n\t\t\tbreak;\n\t}\n\tmsta->n_rates = i;\n\tmt7603_wtbl_set_rates(dev, msta, NULL, msta->rates);\n\tmsta->rate_probe = false;\n\tmt7603_wtbl_set_smps(dev, msta,\n\t\t\t     sta->deflink.smps_mode == IEEE80211_SMPS_DYNAMIC);\n\tspin_unlock_bh(&dev->mt76.lock);\n}\n\nstatic void\nmt7603_set_coverage_class(struct ieee80211_hw *hw, s16 coverage_class)\n{\n\tstruct mt7603_dev *dev = hw->priv;\n\n\tmutex_lock(&dev->mt76.mutex);\n\tdev->coverage_class = max_t(s16, coverage_class, 0);\n\tmt7603_mac_set_timing(dev);\n\tmutex_unlock(&dev->mt76.mutex);\n}\n\nstatic void mt7603_tx(struct ieee80211_hw *hw,\n\t\t      struct ieee80211_tx_control *control,\n\t\t      struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_vif *vif = info->control.vif;\n\tstruct mt7603_dev *dev = hw->priv;\n\tstruct mt76_wcid *wcid = &dev->global_sta.wcid;\n\n\tif (control->sta) {\n\t\tstruct mt7603_sta *msta;\n\n\t\tmsta = (struct mt7603_sta *)control->sta->drv_priv;\n\t\twcid = &msta->wcid;\n\t} else if (vif) {\n\t\tstruct mt7603_vif *mvif;\n\n\t\tmvif = (struct mt7603_vif *)vif->drv_priv;\n\t\twcid = &mvif->sta.wcid;\n\t}\n\n\tmt76_tx(&dev->mphy, control->sta, wcid, skb);\n}\n\nconst struct ieee80211_ops mt7603_ops = {\n\t.tx = mt7603_tx,\n\t.start = mt7603_start,\n\t.stop = mt7603_stop,\n\t.add_interface = mt7603_add_interface,\n\t.remove_interface = mt7603_remove_interface,\n\t.config = mt7603_config,\n\t.configure_filter = mt7603_configure_filter,\n\t.bss_info_changed = mt7603_bss_info_changed,\n\t.sta_state = mt76_sta_state,\n\t.sta_pre_rcu_remove = mt76_sta_pre_rcu_remove,\n\t.set_key = mt7603_set_key,\n\t.conf_tx = mt7603_conf_tx,\n\t.sw_scan_start = mt76_sw_scan,\n\t.sw_scan_complete = mt76_sw_scan_complete,\n\t.flush = mt7603_flush,\n\t.ampdu_action = mt7603_ampdu_action,\n\t.get_txpower = mt76_get_txpower,\n\t.wake_tx_queue = mt76_wake_tx_queue,\n\t.sta_rate_tbl_update = mt7603_sta_rate_tbl_update,\n\t.release_buffered_frames = mt7603_release_buffered_frames,\n\t.set_coverage_class = mt7603_set_coverage_class,\n\t.set_tim = mt76_set_tim,\n\t.get_survey = mt76_get_survey,\n\t.get_antenna = mt76_get_antenna,\n\t.set_sar_specs = mt7603_set_sar_specs,\n};\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\nstatic int __init mt7603_init(void)\n{\n\tint ret;\n\n\tret = platform_driver_register(&mt76_wmac_driver);\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_PCI\n\tret = pci_register_driver(&mt7603_pci_driver);\n\tif (ret)\n\t\tplatform_driver_unregister(&mt76_wmac_driver);\n#endif\n\treturn ret;\n}\n\nstatic void __exit mt7603_exit(void)\n{\n#ifdef CONFIG_PCI\n\tpci_unregister_driver(&mt7603_pci_driver);\n#endif\n\tplatform_driver_unregister(&mt76_wmac_driver);\n}\n\nmodule_init(mt7603_init);\nmodule_exit(mt7603_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}