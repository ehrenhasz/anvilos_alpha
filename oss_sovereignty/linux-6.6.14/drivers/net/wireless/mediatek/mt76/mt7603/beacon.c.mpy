{
  "module_name": "beacon.c",
  "hash_id": "34c3439328b79a5c64e707fa1e7b562e2d086c9a580bd902410b8ea4e618f19f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7603/beacon.c",
  "human_readable_source": "\n\n#include \"mt7603.h\"\n\nstruct beacon_bc_data {\n\tstruct mt7603_dev *dev;\n\tstruct sk_buff_head q;\n\tstruct sk_buff *tail[MT7603_MAX_INTERFACES];\n\tint count[MT7603_MAX_INTERFACES];\n};\n\nstatic void\nmt7603_mac_stuck_beacon_recovery(struct mt7603_dev *dev)\n{\n\tif (dev->beacon_check % 5 != 4)\n\t\treturn;\n\n\tmt76_clear(dev, MT_WPDMA_GLO_CFG, MT_WPDMA_GLO_CFG_TX_DMA_EN);\n\tmt76_set(dev, MT_SCH_4, MT_SCH_4_RESET);\n\tmt76_clear(dev, MT_SCH_4, MT_SCH_4_RESET);\n\tmt76_set(dev, MT_WPDMA_GLO_CFG, MT_WPDMA_GLO_CFG_TX_DMA_EN);\n\n\tmt76_set(dev, MT_WF_CFG_OFF_WOCCR, MT_WF_CFG_OFF_WOCCR_TMAC_GC_DIS);\n\tmt76_set(dev, MT_ARB_SCR, MT_ARB_SCR_TX_DISABLE);\n\tmt76_clear(dev, MT_ARB_SCR, MT_ARB_SCR_TX_DISABLE);\n\tmt76_clear(dev, MT_WF_CFG_OFF_WOCCR, MT_WF_CFG_OFF_WOCCR_TMAC_GC_DIS);\n}\n\nstatic void\nmt7603_update_beacon_iter(void *priv, u8 *mac, struct ieee80211_vif *vif)\n{\n\tstruct mt7603_dev *dev = (struct mt7603_dev *)priv;\n\tstruct mt76_dev *mdev = &dev->mt76;\n\tstruct mt7603_vif *mvif = (struct mt7603_vif *)vif->drv_priv;\n\tstruct sk_buff *skb = NULL;\n\tu32 om_idx = mvif->idx;\n\tu32 val;\n\n\tif (!(mdev->beacon_mask & BIT(mvif->idx)))\n\t\treturn;\n\n\tskb = ieee80211_beacon_get(mt76_hw(dev), vif, 0);\n\tif (!skb)\n\t\treturn;\n\n\tif (om_idx)\n\t\tom_idx |= 0x10;\n\tval = MT_DMA_FQCR0_BUSY | MT_DMA_FQCR0_MODE |\n\t\tFIELD_PREP(MT_DMA_FQCR0_TARGET_BSS, om_idx) |\n\t\tFIELD_PREP(MT_DMA_FQCR0_DEST_PORT_ID, 3) |\n\t\tFIELD_PREP(MT_DMA_FQCR0_DEST_QUEUE_ID, 8);\n\n\tspin_lock_bh(&dev->ps_lock);\n\n\tmt76_wr(dev, MT_DMA_FQCR0, val |\n\t\tFIELD_PREP(MT_DMA_FQCR0_TARGET_QID, MT_TX_HW_QUEUE_BCN));\n\tif (!mt76_poll(dev, MT_DMA_FQCR0, MT_DMA_FQCR0_BUSY, 0, 5000)) {\n\t\tdev->beacon_check = MT7603_WATCHDOG_TIMEOUT;\n\t\tgoto out;\n\t}\n\n\tmt76_wr(dev, MT_DMA_FQCR0, val |\n\t\tFIELD_PREP(MT_DMA_FQCR0_TARGET_QID, MT_TX_HW_QUEUE_BMC));\n\tif (!mt76_poll(dev, MT_DMA_FQCR0, MT_DMA_FQCR0_BUSY, 0, 5000)) {\n\t\tdev->beacon_check = MT7603_WATCHDOG_TIMEOUT;\n\t\tgoto out;\n\t}\n\n\tmt76_tx_queue_skb(dev, dev->mphy.q_tx[MT_TXQ_BEACON],\n\t\t\t  MT_TXQ_BEACON, skb, &mvif->sta.wcid, NULL);\n\nout:\n\tspin_unlock_bh(&dev->ps_lock);\n}\n\nstatic void\nmt7603_add_buffered_bc(void *priv, u8 *mac, struct ieee80211_vif *vif)\n{\n\tstruct beacon_bc_data *data = priv;\n\tstruct mt7603_dev *dev = data->dev;\n\tstruct mt7603_vif *mvif = (struct mt7603_vif *)vif->drv_priv;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *skb;\n\n\tif (!(dev->mt76.beacon_mask & BIT(mvif->idx)))\n\t\treturn;\n\n\tskb = ieee80211_get_buffered_bc(mt76_hw(dev), vif);\n\tif (!skb)\n\t\treturn;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tinfo->control.vif = vif;\n\tinfo->flags |= IEEE80211_TX_CTL_ASSIGN_SEQ;\n\tmt76_skb_set_moredata(skb, true);\n\t__skb_queue_tail(&data->q, skb);\n\tdata->tail[mvif->idx] = skb;\n\tdata->count[mvif->idx]++;\n}\n\nvoid mt7603_pre_tbtt_tasklet(struct tasklet_struct *t)\n{\n\tstruct mt7603_dev *dev = from_tasklet(dev, t, mt76.pre_tbtt_tasklet);\n\tstruct mt76_dev *mdev = &dev->mt76;\n\tstruct mt76_queue *q;\n\tstruct beacon_bc_data data = {};\n\tstruct sk_buff *skb;\n\tint i, nframes;\n\n\tif (mt76_hw(dev)->conf.flags & IEEE80211_CONF_OFFCHANNEL)\n\t\treturn;\n\n\tdata.dev = dev;\n\t__skb_queue_head_init(&data.q);\n\n\t \n\tmt76_wr(dev, MT_WF_ARB_CAB_FLUSH, GENMASK(30, 16) | BIT(0));\n\n\tmt76_queue_tx_cleanup(dev, dev->mphy.q_tx[MT_TXQ_CAB], false);\n\tmt76_queue_tx_cleanup(dev, dev->mphy.q_tx[MT_TXQ_BEACON], false);\n\n\tif (dev->mphy.q_tx[MT_TXQ_BEACON]->queued > 0)\n\t\tdev->beacon_check++;\n\telse\n\t\tdev->beacon_check = 0;\n\tmt7603_mac_stuck_beacon_recovery(dev);\n\n\tq = dev->mphy.q_tx[MT_TXQ_BEACON];\n\tspin_lock(&q->lock);\n\tieee80211_iterate_active_interfaces_atomic(mt76_hw(dev),\n\t\tIEEE80211_IFACE_ITER_RESUME_ALL,\n\t\tmt7603_update_beacon_iter, dev);\n\tmt76_queue_kick(dev, q);\n\tspin_unlock(&q->lock);\n\n\tmt76_csa_check(mdev);\n\tif (mdev->csa_complete)\n\t\treturn;\n\n\tq = dev->mphy.q_tx[MT_TXQ_CAB];\n\tdo {\n\t\tnframes = skb_queue_len(&data.q);\n\t\tieee80211_iterate_active_interfaces_atomic(mt76_hw(dev),\n\t\t\tIEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\tmt7603_add_buffered_bc, &data);\n\t} while (nframes != skb_queue_len(&data.q) &&\n\t\t skb_queue_len(&data.q) < 8);\n\n\tif (skb_queue_empty(&data.q))\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(data.tail); i++) {\n\t\tif (!data.tail[i])\n\t\t\tcontinue;\n\n\t\tmt76_skb_set_moredata(data.tail[i], false);\n\t}\n\n\tspin_lock(&q->lock);\n\twhile ((skb = __skb_dequeue(&data.q)) != NULL) {\n\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\t\tstruct ieee80211_vif *vif = info->control.vif;\n\t\tstruct mt7603_vif *mvif = (struct mt7603_vif *)vif->drv_priv;\n\n\t\tmt76_tx_queue_skb(dev, q, MT_TXQ_CAB, skb, &mvif->sta.wcid, NULL);\n\t}\n\tmt76_queue_kick(dev, q);\n\tspin_unlock(&q->lock);\n\n\tfor (i = 0; i < ARRAY_SIZE(data.count); i++)\n\t\tmt76_wr(dev, MT_WF_ARB_CAB_COUNT_B0_REG(i),\n\t\t\tdata.count[i] << MT_WF_ARB_CAB_COUNT_B0_SHIFT(i));\n\n\tmt76_wr(dev, MT_WF_ARB_CAB_START,\n\t\tMT_WF_ARB_CAB_START_BSSn(0) |\n\t\t(MT_WF_ARB_CAB_START_BSS0n(1) *\n\t\t ((1 << (MT7603_MAX_INTERFACES - 1)) - 1)));\n}\n\nvoid mt7603_beacon_set_timer(struct mt7603_dev *dev, int idx, int intval)\n{\n\tu32 pre_tbtt = MT7603_PRE_TBTT_TIME / 64;\n\n\tif (idx >= 0) {\n\t\tif (intval)\n\t\t\tdev->mt76.beacon_mask |= BIT(idx);\n\t\telse\n\t\t\tdev->mt76.beacon_mask &= ~BIT(idx);\n\t}\n\n\tif (!dev->mt76.beacon_mask || (!intval && idx < 0)) {\n\t\tmt7603_irq_disable(dev, MT_INT_MAC_IRQ3);\n\t\tmt76_clear(dev, MT_ARB_SCR, MT_ARB_SCR_BCNQ_OPMODE_MASK);\n\t\tmt76_wr(dev, MT_HW_INT_MASK(3), 0);\n\t\treturn;\n\t}\n\n\tif (intval)\n\t\tdev->mt76.beacon_int = intval;\n\tmt76_wr(dev, MT_TBTT,\n\t\tFIELD_PREP(MT_TBTT_PERIOD, intval) | MT_TBTT_CAL_ENABLE);\n\n\tmt76_wr(dev, MT_TBTT_TIMER_CFG, 0x99);  \n\n\tmt76_rmw_field(dev, MT_ARB_SCR, MT_ARB_SCR_BCNQ_OPMODE_MASK,\n\t\t       MT_BCNQ_OPMODE_AP);\n\tmt76_clear(dev, MT_ARB_SCR, MT_ARB_SCR_TBTT_BCN_PRIO);\n\tmt76_set(dev, MT_ARB_SCR, MT_ARB_SCR_TBTT_BCAST_PRIO);\n\n\tmt76_wr(dev, MT_PRE_TBTT, pre_tbtt);\n\n\tmt76_set(dev, MT_HW_INT_MASK(3),\n\t\t MT_HW_INT3_PRE_TBTT0 | MT_HW_INT3_TBTT0);\n\n\tmt76_set(dev, MT_WF_ARB_BCN_START,\n\t\t MT_WF_ARB_BCN_START_BSSn(0) |\n\t\t ((dev->mt76.beacon_mask >> 1) *\n\t\t  MT_WF_ARB_BCN_START_BSS0n(1)));\n\tmt7603_irq_enable(dev, MT_INT_MAC_IRQ3);\n\n\tif (dev->mt76.beacon_mask & ~BIT(0))\n\t\tmt76_set(dev, MT_LPON_SBTOR(0), MT_LPON_SBTOR_SUB_BSS_EN);\n\telse\n\t\tmt76_clear(dev, MT_LPON_SBTOR(0), MT_LPON_SBTOR_SUB_BSS_EN);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}