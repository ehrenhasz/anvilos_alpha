{
  "module_name": "eeprom.c",
  "hash_id": "1b7e2f9b364aa6d4df41e592a01aa19a1ab68085a08f93a7c036f3ec1181342a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7603/eeprom.c",
  "human_readable_source": "\n\n#include <linux/of.h>\n#include \"mt7603.h\"\n#include \"eeprom.h\"\n\nstatic int\nmt7603_efuse_read(struct mt7603_dev *dev, u32 base, u16 addr, u8 *data)\n{\n\tu32 val;\n\tint i;\n\n\tval = mt76_rr(dev, base + MT_EFUSE_CTRL);\n\tval &= ~(MT_EFUSE_CTRL_AIN |\n\t\t MT_EFUSE_CTRL_MODE);\n\tval |= FIELD_PREP(MT_EFUSE_CTRL_AIN, addr & ~0xf);\n\tval |= MT_EFUSE_CTRL_KICK;\n\tmt76_wr(dev, base + MT_EFUSE_CTRL, val);\n\n\tif (!mt76_poll(dev, base + MT_EFUSE_CTRL, MT_EFUSE_CTRL_KICK, 0, 1000))\n\t\treturn -ETIMEDOUT;\n\n\tudelay(2);\n\n\tval = mt76_rr(dev, base + MT_EFUSE_CTRL);\n\tif ((val & MT_EFUSE_CTRL_AOUT) == MT_EFUSE_CTRL_AOUT ||\n\t    WARN_ON_ONCE(!(val & MT_EFUSE_CTRL_VALID))) {\n\t\tmemset(data, 0xff, 16);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tval = mt76_rr(dev, base + MT_EFUSE_RDATA(i));\n\t\tput_unaligned_le32(val, data + 4 * i);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmt7603_efuse_init(struct mt7603_dev *dev)\n{\n\tu32 base = mt7603_reg_map(dev, MT_EFUSE_BASE);\n\tint len = MT7603_EEPROM_SIZE;\n\tvoid *buf;\n\tint ret, i;\n\n\tif (mt76_rr(dev, base + MT_EFUSE_BASE_CTRL) & MT_EFUSE_BASE_CTRL_EMPTY)\n\t\treturn 0;\n\n\tdev->mt76.otp.data = devm_kzalloc(dev->mt76.dev, len, GFP_KERNEL);\n\tdev->mt76.otp.size = len;\n\tif (!dev->mt76.otp.data)\n\t\treturn -ENOMEM;\n\n\tbuf = dev->mt76.otp.data;\n\tfor (i = 0; i + 16 <= len; i += 16) {\n\t\tret = mt7603_efuse_read(dev, base, i, buf + i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic bool\nmt7603_has_cal_free_data(struct mt7603_dev *dev, u8 *efuse)\n{\n\tif (!efuse[MT_EE_TEMP_SENSOR_CAL])\n\t\treturn false;\n\n\tif (get_unaligned_le16(efuse + MT_EE_TX_POWER_0_START_2G) == 0)\n\t\treturn false;\n\n\tif (get_unaligned_le16(efuse + MT_EE_TX_POWER_1_START_2G) == 0)\n\t\treturn false;\n\n\tif (!efuse[MT_EE_CP_FT_VERSION])\n\t\treturn false;\n\n\tif (!efuse[MT_EE_XTAL_FREQ_OFFSET])\n\t\treturn false;\n\n\tif (!efuse[MT_EE_XTAL_WF_RFCAL])\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void\nmt7603_apply_cal_free_data(struct mt7603_dev *dev, u8 *efuse)\n{\n\tstatic const u8 cal_free_bytes[] = {\n\t\tMT_EE_TEMP_SENSOR_CAL,\n\t\tMT_EE_CP_FT_VERSION,\n\t\tMT_EE_XTAL_FREQ_OFFSET,\n\t\tMT_EE_XTAL_WF_RFCAL,\n\t\t \n\t\tMT_EE_TX_POWER_0_START_2G,\n\t\tMT_EE_TX_POWER_0_START_2G + 1,\n\t\tMT_EE_TX_POWER_1_START_2G,\n\t\tMT_EE_TX_POWER_1_START_2G + 1,\n\t};\n\tstruct device_node *np = dev->mt76.dev->of_node;\n\tu8 *eeprom = dev->mt76.eeprom.data;\n\tint n = ARRAY_SIZE(cal_free_bytes);\n\tint i;\n\n\tif (!np || !of_property_read_bool(np, \"mediatek,eeprom-merge-otp\"))\n\t\treturn;\n\n\tif (!mt7603_has_cal_free_data(dev, efuse))\n\t\treturn;\n\n\tif (is_mt7628(dev))\n\t\tn -= 4;\n\n\tfor (i = 0; i < n; i++) {\n\t\tint offset = cal_free_bytes[i];\n\n\t\teeprom[offset] = efuse[offset];\n\t}\n}\n\nstatic int\nmt7603_eeprom_load(struct mt7603_dev *dev)\n{\n\tint ret;\n\n\tret = mt76_eeprom_init(&dev->mt76, MT7603_EEPROM_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn mt7603_efuse_init(dev);\n}\n\nstatic int mt7603_check_eeprom(struct mt76_dev *dev)\n{\n\tu16 val = get_unaligned_le16(dev->eeprom.data);\n\n\tswitch (val) {\n\tcase 0x7628:\n\tcase 0x7603:\n\tcase 0x7600:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic inline bool is_mt7688(struct mt7603_dev *dev)\n{\n\treturn mt76_rr(dev, MT_EFUSE_BASE + 0x64) & BIT(4);\n}\n\nint mt7603_eeprom_init(struct mt7603_dev *dev)\n{\n\tu8 *eeprom;\n\tint ret;\n\n\tret = mt7603_eeprom_load(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (dev->mt76.otp.data) {\n\t\tif (mt7603_check_eeprom(&dev->mt76) == 0)\n\t\t\tmt7603_apply_cal_free_data(dev, dev->mt76.otp.data);\n\t\telse\n\t\t\tmemcpy(dev->mt76.eeprom.data, dev->mt76.otp.data,\n\t\t\t       MT7603_EEPROM_SIZE);\n\t}\n\n\teeprom = (u8 *)dev->mt76.eeprom.data;\n\tdev->mphy.cap.has_2ghz = true;\n\tmemcpy(dev->mphy.macaddr, eeprom + MT_EE_MAC_ADDR, ETH_ALEN);\n\n\t \n\tdev->mphy.antenna_mask = 3;\n\tif (FIELD_GET(MT_EE_NIC_CONF_0_RX_PATH, eeprom[MT_EE_NIC_CONF_0]) == 1 ||\n\t    FIELD_GET(MT_EE_NIC_CONF_0_TX_PATH, eeprom[MT_EE_NIC_CONF_0]) == 1 ||\n\t    is_mt7688(dev))\n\t\tdev->mphy.antenna_mask = 1;\n\n\tmt76_eeprom_override(&dev->mphy);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}