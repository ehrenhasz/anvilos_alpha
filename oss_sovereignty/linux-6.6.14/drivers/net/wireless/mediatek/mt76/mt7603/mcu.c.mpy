{
  "module_name": "mcu.c",
  "hash_id": "0ba24458f731d523f0d0410f9faf185c6b79966cb8efcf0b41dfaa35d6d12ac6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7603/mcu.c",
  "human_readable_source": "\n\n#include <linux/firmware.h>\n#include \"mt7603.h\"\n#include \"mcu.h\"\n#include \"eeprom.h\"\n\n#define MCU_SKB_RESERVE\t8\n\nstruct mt7603_fw_trailer {\n\tchar fw_ver[10];\n\tchar build_date[15];\n\t__le32 dl_len;\n} __packed;\n\nstatic int\nmt7603_mcu_parse_response(struct mt76_dev *mdev, int cmd,\n\t\t\t  struct sk_buff *skb, int seq)\n{\n\tstruct mt7603_dev *dev = container_of(mdev, struct mt7603_dev, mt76);\n\tstruct mt7603_mcu_rxd *rxd;\n\n\tif (!skb) {\n\t\tdev_err(mdev->dev, \"MCU message %02x (seq %d) timed out\\n\",\n\t\t\tabs(cmd), seq);\n\t\tdev->mcu_hang = MT7603_WATCHDOG_TIMEOUT;\n\t\treturn -ETIMEDOUT;\n\t}\n\n\trxd = (struct mt7603_mcu_rxd *)skb->data;\n\tif (seq != rxd->seq)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic int\nmt7603_mcu_skb_send_msg(struct mt76_dev *mdev, struct sk_buff *skb,\n\t\t\tint cmd, int *wait_seq)\n{\n\tstruct mt7603_dev *dev = container_of(mdev, struct mt7603_dev, mt76);\n\tint hdrlen = dev->mcu_running ? sizeof(struct mt7603_mcu_txd) : 12;\n\tstruct mt7603_mcu_txd *txd;\n\tu8 seq;\n\n\tmdev->mcu.timeout = 3 * HZ;\n\n\tseq = ++mdev->mcu.msg_seq & 0xf;\n\tif (!seq)\n\t\tseq = ++mdev->mcu.msg_seq & 0xf;\n\n\ttxd = (struct mt7603_mcu_txd *)skb_push(skb, hdrlen);\n\n\ttxd->len = cpu_to_le16(skb->len);\n\tif (cmd == -MCU_CMD_FW_SCATTER)\n\t\ttxd->pq_id = cpu_to_le16(MCU_PORT_QUEUE_FW);\n\telse\n\t\ttxd->pq_id = cpu_to_le16(MCU_PORT_QUEUE);\n\ttxd->pkt_type = MCU_PKT_ID;\n\ttxd->seq = seq;\n\n\tif (cmd < 0) {\n\t\ttxd->cid = -cmd;\n\t\ttxd->set_query = MCU_Q_NA;\n\t} else {\n\t\ttxd->cid = MCU_CMD_EXT_CID;\n\t\ttxd->ext_cid = cmd;\n\t\ttxd->set_query = MCU_Q_SET;\n\t\ttxd->ext_cid_ack = 1;\n\t}\n\n\tif (wait_seq)\n\t\t*wait_seq = seq;\n\n\treturn mt76_tx_queue_skb_raw(dev, mdev->q_mcu[MT_MCUQ_WM], skb, 0);\n}\n\nstatic int\nmt7603_mcu_init_download(struct mt7603_dev *dev, u32 addr, u32 len)\n{\n\tstruct {\n\t\t__le32 addr;\n\t\t__le32 len;\n\t\t__le32 mode;\n\t} req = {\n\t\t.addr = cpu_to_le32(addr),\n\t\t.len = cpu_to_le32(len),\n\t\t.mode = cpu_to_le32(BIT(31)),\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, -MCU_CMD_TARGET_ADDRESS_LEN_REQ,\n\t\t\t\t &req, sizeof(req), true);\n}\n\nstatic int\nmt7603_mcu_start_firmware(struct mt7603_dev *dev, u32 addr)\n{\n\tstruct {\n\t\t__le32 override;\n\t\t__le32 addr;\n\t} req = {\n\t\t.override = cpu_to_le32(addr ? 1 : 0),\n\t\t.addr = cpu_to_le32(addr),\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, -MCU_CMD_FW_START_REQ, &req,\n\t\t\t\t sizeof(req), true);\n}\n\nstatic int\nmt7603_mcu_restart(struct mt76_dev *dev)\n{\n\treturn mt76_mcu_send_msg(dev, -MCU_CMD_RESTART_DL_REQ, NULL, 0, true);\n}\n\nstatic int mt7603_load_firmware(struct mt7603_dev *dev)\n{\n\tconst struct firmware *fw;\n\tconst struct mt7603_fw_trailer *hdr;\n\tconst char *firmware;\n\tint dl_len;\n\tu32 addr, val;\n\tint ret;\n\n\tif (is_mt7628(dev)) {\n\t\tif (mt76xx_rev(dev) == MT7628_REV_E1)\n\t\t\tfirmware = MT7628_FIRMWARE_E1;\n\t\telse\n\t\t\tfirmware = MT7628_FIRMWARE_E2;\n\t} else {\n\t\tif (mt76xx_rev(dev) < MT7603_REV_E2)\n\t\t\tfirmware = MT7603_FIRMWARE_E1;\n\t\telse\n\t\t\tfirmware = MT7603_FIRMWARE_E2;\n\t}\n\n\tret = request_firmware(&fw, firmware, dev->mt76.dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!fw || !fw->data || fw->size < sizeof(*hdr)) {\n\t\tdev_err(dev->mt76.dev, \"Invalid firmware\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\thdr = (const struct mt7603_fw_trailer *)(fw->data + fw->size -\n\t\t\t\t\t\t sizeof(*hdr));\n\n\tdev_info(dev->mt76.dev, \"Firmware Version: %.10s\\n\", hdr->fw_ver);\n\tdev_info(dev->mt76.dev, \"Build Time: %.15s\\n\", hdr->build_date);\n\n\taddr = mt7603_reg_map(dev, 0x50012498);\n\tmt76_wr(dev, addr, 0x5);\n\tmt76_wr(dev, addr, 0x5);\n\tudelay(1);\n\n\t \n\tmt76_rmw(dev, MT_SCH_4, MT_SCH_4_FORCE_QID,\n\t\t MT_SCH_4_BYPASS | FIELD_PREP(MT_SCH_4_FORCE_QID, 5));\n\n\tval = mt76_rr(dev, MT_TOP_MISC2);\n\tif (val & BIT(1)) {\n\t\tdev_info(dev->mt76.dev, \"Firmware already running...\\n\");\n\t\tgoto running;\n\t}\n\n\tif (!mt76_poll_msec(dev, MT_TOP_MISC2, BIT(0) | BIT(1), BIT(0), 500)) {\n\t\tdev_err(dev->mt76.dev, \"Timeout waiting for ROM code to become ready\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tdl_len = le32_to_cpu(hdr->dl_len) + 4;\n\tret = mt7603_mcu_init_download(dev, MCU_FIRMWARE_ADDRESS, dl_len);\n\tif (ret) {\n\t\tdev_err(dev->mt76.dev, \"Download request failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = mt76_mcu_send_firmware(&dev->mt76, -MCU_CMD_FW_SCATTER,\n\t\t\t\t     fw->data, dl_len);\n\tif (ret) {\n\t\tdev_err(dev->mt76.dev, \"Failed to send firmware to device\\n\");\n\t\tgoto out;\n\t}\n\n\tret = mt7603_mcu_start_firmware(dev, MCU_FIRMWARE_ADDRESS);\n\tif (ret) {\n\t\tdev_err(dev->mt76.dev, \"Failed to start firmware\\n\");\n\t\tgoto out;\n\t}\n\n\tif (!mt76_poll_msec(dev, MT_TOP_MISC2, BIT(1), BIT(1), 500)) {\n\t\tdev_err(dev->mt76.dev, \"Timeout waiting for firmware to initialize\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\nrunning:\n\tmt76_clear(dev, MT_SCH_4, MT_SCH_4_FORCE_QID | MT_SCH_4_BYPASS);\n\n\tmt76_set(dev, MT_SCH_4, BIT(8));\n\tmt76_clear(dev, MT_SCH_4, BIT(8));\n\n\tdev->mcu_running = true;\n\tsnprintf(dev->mt76.hw->wiphy->fw_version,\n\t\t sizeof(dev->mt76.hw->wiphy->fw_version),\n\t\t \"%.10s-%.15s\", hdr->fw_ver, hdr->build_date);\n\tdev_info(dev->mt76.dev, \"firmware init done\\n\");\n\nout:\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\nint mt7603_mcu_init(struct mt7603_dev *dev)\n{\n\tstatic const struct mt76_mcu_ops mt7603_mcu_ops = {\n\t\t.headroom = sizeof(struct mt7603_mcu_txd),\n\t\t.mcu_skb_send_msg = mt7603_mcu_skb_send_msg,\n\t\t.mcu_parse_response = mt7603_mcu_parse_response,\n\t};\n\n\tdev->mt76.mcu_ops = &mt7603_mcu_ops;\n\treturn mt7603_load_firmware(dev);\n}\n\nvoid mt7603_mcu_exit(struct mt7603_dev *dev)\n{\n\tmt7603_mcu_restart(&dev->mt76);\n\tskb_queue_purge(&dev->mt76.mcu.res_q);\n}\n\nint mt7603_mcu_set_eeprom(struct mt7603_dev *dev)\n{\n\tstatic const u16 req_fields[] = {\n#define WORD(_start)\t\t\t\\\n\t\t_start,\t\t\t\\\n\t\t_start + 1\n#define GROUP_2G(_start)\t\t\\\n\t\tWORD(_start),\t\t\\\n\t\tWORD(_start + 2),\t\\\n\t\tWORD(_start + 4)\n\n\t\tMT_EE_NIC_CONF_0 + 1,\n\t\tWORD(MT_EE_NIC_CONF_1),\n\t\tMT_EE_WIFI_RF_SETTING,\n\t\tMT_EE_TX_POWER_DELTA_BW40,\n\t\tMT_EE_TX_POWER_DELTA_BW80 + 1,\n\t\tMT_EE_TX_POWER_EXT_PA_5G,\n\t\tMT_EE_TEMP_SENSOR_CAL,\n\t\tGROUP_2G(MT_EE_TX_POWER_0_START_2G),\n\t\tGROUP_2G(MT_EE_TX_POWER_1_START_2G),\n\t\tWORD(MT_EE_TX_POWER_CCK),\n\t\tWORD(MT_EE_TX_POWER_OFDM_2G_6M),\n\t\tWORD(MT_EE_TX_POWER_OFDM_2G_24M),\n\t\tWORD(MT_EE_TX_POWER_OFDM_2G_54M),\n\t\tWORD(MT_EE_TX_POWER_HT_BPSK_QPSK),\n\t\tWORD(MT_EE_TX_POWER_HT_16_64_QAM),\n\t\tWORD(MT_EE_TX_POWER_HT_64_QAM),\n\t\tMT_EE_ELAN_RX_MODE_GAIN,\n\t\tMT_EE_ELAN_RX_MODE_NF,\n\t\tMT_EE_ELAN_RX_MODE_P1DB,\n\t\tMT_EE_ELAN_BYPASS_MODE_GAIN,\n\t\tMT_EE_ELAN_BYPASS_MODE_NF,\n\t\tMT_EE_ELAN_BYPASS_MODE_P1DB,\n\t\tWORD(MT_EE_STEP_NUM_NEG_6_7),\n\t\tWORD(MT_EE_STEP_NUM_NEG_4_5),\n\t\tWORD(MT_EE_STEP_NUM_NEG_2_3),\n\t\tWORD(MT_EE_STEP_NUM_NEG_0_1),\n\t\tWORD(MT_EE_REF_STEP_24G),\n\t\tWORD(MT_EE_STEP_NUM_PLUS_1_2),\n\t\tWORD(MT_EE_STEP_NUM_PLUS_3_4),\n\t\tWORD(MT_EE_STEP_NUM_PLUS_5_6),\n\t\tMT_EE_STEP_NUM_PLUS_7,\n\t\tMT_EE_XTAL_FREQ_OFFSET,\n\t\tMT_EE_XTAL_TRIM_2_COMP,\n\t\tMT_EE_XTAL_TRIM_3_COMP,\n\t\tMT_EE_XTAL_WF_RFCAL,\n\n\t\t \n\t\tWORD(0x24),\n\t\t0x34,\n\t\t0x39,\n\t\t0x3b,\n\t\tWORD(0x42),\n\t\tWORD(0x9e),\n\t\t0xf2,\n\t\tWORD(0xf8),\n\t\t0xfa,\n\t\t0x12e,\n\t\tWORD(0x130), WORD(0x132), WORD(0x134), WORD(0x136),\n\t\tWORD(0x138), WORD(0x13a), WORD(0x13c), WORD(0x13e),\n\n#undef GROUP_2G\n#undef WORD\n\n\t};\n\tstruct req_data {\n\t\t__le16 addr;\n\t\tu8 val;\n\t\tu8 pad;\n\t} __packed;\n\tstruct {\n\t\tu8 buffer_mode;\n\t\tu8 len;\n\t\tu8 pad[2];\n\t} req_hdr = {\n\t\t.buffer_mode = 1,\n\t\t.len = ARRAY_SIZE(req_fields) - 1,\n\t};\n\tconst int size = 0xff * sizeof(struct req_data);\n\tu8 *req, *eep = (u8 *)dev->mt76.eeprom.data;\n\tint i, ret, len = sizeof(req_hdr) + size;\n\tstruct req_data *data;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(req_fields) * sizeof(*data) > size);\n\n\treq = kmalloc(len, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tmemcpy(req, &req_hdr, sizeof(req_hdr));\n\tdata = (struct req_data *)(req + sizeof(req_hdr));\n\tmemset(data, 0, size);\n\tfor (i = 0; i < ARRAY_SIZE(req_fields); i++) {\n\t\tdata[i].addr = cpu_to_le16(req_fields[i]);\n\t\tdata[i].val = eep[req_fields[i]];\n\t}\n\n\tret = mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD_EFUSE_BUFFER_MODE,\n\t\t\t\treq, len, true);\n\tkfree(req);\n\n\treturn ret;\n}\n\nstatic int mt7603_mcu_set_tx_power(struct mt7603_dev *dev)\n{\n\tstruct {\n\t\tu8 center_channel;\n\t\tu8 tssi;\n\t\tu8 temp_comp;\n\t\tu8 target_power[2];\n\t\tu8 rate_power_delta[14];\n\t\tu8 bw_power_delta;\n\t\tu8 ch_power_delta[6];\n\t\tu8 temp_comp_power[17];\n\t\tu8 reserved;\n\t} req = {\n\t\t.center_channel = dev->mphy.chandef.chan->hw_value,\n#define EEP_VAL(n) ((u8 *)dev->mt76.eeprom.data)[n]\n\t\t.tssi = EEP_VAL(MT_EE_NIC_CONF_1 + 1),\n\t\t.temp_comp = EEP_VAL(MT_EE_NIC_CONF_1),\n\t\t.target_power = {\n\t\t\tEEP_VAL(MT_EE_TX_POWER_0_START_2G + 2),\n\t\t\tEEP_VAL(MT_EE_TX_POWER_1_START_2G + 2)\n\t\t},\n\t\t.bw_power_delta = EEP_VAL(MT_EE_TX_POWER_DELTA_BW40),\n\t\t.ch_power_delta = {\n\t\t\tEEP_VAL(MT_EE_TX_POWER_0_START_2G + 3),\n\t\t\tEEP_VAL(MT_EE_TX_POWER_0_START_2G + 4),\n\t\t\tEEP_VAL(MT_EE_TX_POWER_0_START_2G + 5),\n\t\t\tEEP_VAL(MT_EE_TX_POWER_1_START_2G + 3),\n\t\t\tEEP_VAL(MT_EE_TX_POWER_1_START_2G + 4),\n\t\t\tEEP_VAL(MT_EE_TX_POWER_1_START_2G + 5)\n\t\t},\n#undef EEP_VAL\n\t};\n\tu8 *eep = (u8 *)dev->mt76.eeprom.data;\n\n\tmemcpy(req.rate_power_delta, eep + MT_EE_TX_POWER_CCK,\n\t       sizeof(req.rate_power_delta));\n\n\tmemcpy(req.temp_comp_power, eep + MT_EE_STEP_NUM_NEG_6_7,\n\t       sizeof(req.temp_comp_power));\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD_SET_TX_POWER_CTRL,\n\t\t\t\t &req, sizeof(req), true);\n}\n\nint mt7603_mcu_set_channel(struct mt7603_dev *dev)\n{\n\tstruct cfg80211_chan_def *chandef = &dev->mphy.chandef;\n\tstruct ieee80211_hw *hw = mt76_hw(dev);\n\tint n_chains = hweight8(dev->mphy.antenna_mask);\n\tstruct {\n\t\tu8 control_chan;\n\t\tu8 center_chan;\n\t\tu8 bw;\n\t\tu8 tx_streams;\n\t\tu8 rx_streams;\n\t\tu8 _res0[7];\n\t\tu8 txpower[21];\n\t\tu8 _res1[3];\n\t} req = {\n\t\t.control_chan = chandef->chan->hw_value,\n\t\t.center_chan = chandef->chan->hw_value,\n\t\t.bw = MT_BW_20,\n\t\t.tx_streams = n_chains,\n\t\t.rx_streams = n_chains,\n\t};\n\ts8 tx_power = hw->conf.power_level * 2;\n\tint i, ret;\n\n\tif (dev->mphy.chandef.width == NL80211_CHAN_WIDTH_40) {\n\t\treq.bw = MT_BW_40;\n\t\tif (chandef->center_freq1 > chandef->chan->center_freq)\n\t\t\treq.center_chan += 2;\n\t\telse\n\t\t\treq.center_chan -= 2;\n\t}\n\n\ttx_power = mt76_get_sar_power(&dev->mphy, chandef->chan, tx_power);\n\tif (dev->mphy.antenna_mask == 3)\n\t\ttx_power -= 6;\n\ttx_power = min(tx_power, dev->tx_power_limit);\n\n\tdev->mphy.txpower_cur = tx_power;\n\n\tfor (i = 0; i < ARRAY_SIZE(req.txpower); i++)\n\t\treq.txpower[i] = tx_power;\n\n\tret = mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD_CHANNEL_SWITCH, &req,\n\t\t\t\tsizeof(req), true);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mt7603_mcu_set_tx_power(dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}