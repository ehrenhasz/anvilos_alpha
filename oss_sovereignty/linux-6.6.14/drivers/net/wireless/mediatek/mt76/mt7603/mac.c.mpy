{
  "module_name": "mac.c",
  "hash_id": "99ecf653964ac84785ff3d37bb2969406369de7615b5f04d581d4ccab902fdcf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7603/mac.c",
  "human_readable_source": "\n\n#include <linux/etherdevice.h>\n#include <linux/timekeeping.h>\n#include \"mt7603.h\"\n#include \"mac.h\"\n#include \"../trace.h\"\n\n#define MT_PSE_PAGE_SIZE\t128\n\nstatic u32\nmt7603_ac_queue_mask0(u32 mask)\n{\n\tu32 ret = 0;\n\n\tret |= GENMASK(3, 0) * !!(mask & BIT(0));\n\tret |= GENMASK(8, 5) * !!(mask & BIT(1));\n\tret |= GENMASK(13, 10) * !!(mask & BIT(2));\n\tret |= GENMASK(19, 16) * !!(mask & BIT(3));\n\treturn ret;\n}\n\nstatic void\nmt76_stop_tx_ac(struct mt7603_dev *dev, u32 mask)\n{\n\tmt76_set(dev, MT_WF_ARB_TX_STOP_0, mt7603_ac_queue_mask0(mask));\n}\n\nstatic void\nmt76_start_tx_ac(struct mt7603_dev *dev, u32 mask)\n{\n\tmt76_set(dev, MT_WF_ARB_TX_START_0, mt7603_ac_queue_mask0(mask));\n}\n\nvoid mt7603_mac_reset_counters(struct mt7603_dev *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < 2; i++)\n\t\tmt76_rr(dev, MT_TX_AGG_CNT(i));\n\n\tmemset(dev->mphy.aggr_stats, 0, sizeof(dev->mphy.aggr_stats));\n}\n\nvoid mt7603_mac_set_timing(struct mt7603_dev *dev)\n{\n\tu32 cck = FIELD_PREP(MT_TIMEOUT_VAL_PLCP, 231) |\n\t\t  FIELD_PREP(MT_TIMEOUT_VAL_CCA, 48);\n\tu32 ofdm = FIELD_PREP(MT_TIMEOUT_VAL_PLCP, 60) |\n\t\t   FIELD_PREP(MT_TIMEOUT_VAL_CCA, 24);\n\tint offset = 3 * dev->coverage_class;\n\tu32 reg_offset = FIELD_PREP(MT_TIMEOUT_VAL_PLCP, offset) |\n\t\t\t FIELD_PREP(MT_TIMEOUT_VAL_CCA, offset);\n\tbool is_5ghz = dev->mphy.chandef.chan->band == NL80211_BAND_5GHZ;\n\tint sifs;\n\tu32 val;\n\n\tif (is_5ghz)\n\t\tsifs = 16;\n\telse\n\t\tsifs = 10;\n\n\tmt76_set(dev, MT_ARB_SCR,\n\t\t MT_ARB_SCR_TX_DISABLE | MT_ARB_SCR_RX_DISABLE);\n\tudelay(1);\n\n\tmt76_wr(dev, MT_TIMEOUT_CCK, cck + reg_offset);\n\tmt76_wr(dev, MT_TIMEOUT_OFDM, ofdm + reg_offset);\n\tmt76_wr(dev, MT_IFS,\n\t\tFIELD_PREP(MT_IFS_EIFS, 360) |\n\t\tFIELD_PREP(MT_IFS_RIFS, 2) |\n\t\tFIELD_PREP(MT_IFS_SIFS, sifs) |\n\t\tFIELD_PREP(MT_IFS_SLOT, dev->slottime));\n\n\tif (dev->slottime < 20 || is_5ghz)\n\t\tval = MT7603_CFEND_RATE_DEFAULT;\n\telse\n\t\tval = MT7603_CFEND_RATE_11B;\n\n\tmt76_rmw_field(dev, MT_AGG_CONTROL, MT_AGG_CONTROL_CFEND_RATE, val);\n\n\tmt76_clear(dev, MT_ARB_SCR,\n\t\t   MT_ARB_SCR_TX_DISABLE | MT_ARB_SCR_RX_DISABLE);\n}\n\nstatic void\nmt7603_wtbl_update(struct mt7603_dev *dev, int idx, u32 mask)\n{\n\tmt76_rmw(dev, MT_WTBL_UPDATE, MT_WTBL_UPDATE_WLAN_IDX,\n\t\t FIELD_PREP(MT_WTBL_UPDATE_WLAN_IDX, idx) | mask);\n\n\tmt76_poll(dev, MT_WTBL_UPDATE, MT_WTBL_UPDATE_BUSY, 0, 5000);\n}\n\nstatic u32\nmt7603_wtbl1_addr(int idx)\n{\n\treturn MT_WTBL1_BASE + idx * MT_WTBL1_SIZE;\n}\n\nstatic u32\nmt7603_wtbl2_addr(int idx)\n{\n\t \n\treturn MT_PCIE_REMAP_BASE_1 + idx * MT_WTBL2_SIZE;\n}\n\nstatic u32\nmt7603_wtbl3_addr(int idx)\n{\n\tu32 base = mt7603_wtbl2_addr(MT7603_WTBL_SIZE);\n\n\treturn base + idx * MT_WTBL3_SIZE;\n}\n\nstatic u32\nmt7603_wtbl4_addr(int idx)\n{\n\tu32 base = mt7603_wtbl3_addr(MT7603_WTBL_SIZE);\n\n\treturn base + idx * MT_WTBL4_SIZE;\n}\n\nvoid mt7603_wtbl_init(struct mt7603_dev *dev, int idx, int vif,\n\t\t      const u8 *mac_addr)\n{\n\tconst void *_mac = mac_addr;\n\tu32 addr = mt7603_wtbl1_addr(idx);\n\tu32 w0 = 0, w1 = 0;\n\tint i;\n\n\tif (_mac) {\n\t\tw0 = FIELD_PREP(MT_WTBL1_W0_ADDR_HI,\n\t\t\t\tget_unaligned_le16(_mac + 4));\n\t\tw1 = FIELD_PREP(MT_WTBL1_W1_ADDR_LO,\n\t\t\t\tget_unaligned_le32(_mac));\n\t}\n\n\tif (vif < 0)\n\t\tvif = 0;\n\telse\n\t\tw0 |= MT_WTBL1_W0_RX_CHECK_A1;\n\tw0 |= FIELD_PREP(MT_WTBL1_W0_MUAR_IDX, vif);\n\n\tmt76_poll(dev, MT_WTBL_UPDATE, MT_WTBL_UPDATE_BUSY, 0, 5000);\n\n\tmt76_set(dev, addr + 0 * 4, w0);\n\tmt76_set(dev, addr + 1 * 4, w1);\n\tmt76_set(dev, addr + 2 * 4, MT_WTBL1_W2_ADMISSION_CONTROL);\n\n\tmt76_stop_tx_ac(dev, GENMASK(3, 0));\n\taddr = mt7603_wtbl2_addr(idx);\n\tfor (i = 0; i < MT_WTBL2_SIZE; i += 4)\n\t\tmt76_wr(dev, addr + i, 0);\n\tmt7603_wtbl_update(dev, idx, MT_WTBL_UPDATE_WTBL2);\n\tmt76_start_tx_ac(dev, GENMASK(3, 0));\n\n\taddr = mt7603_wtbl3_addr(idx);\n\tfor (i = 0; i < MT_WTBL3_SIZE; i += 4)\n\t\tmt76_wr(dev, addr + i, 0);\n\n\taddr = mt7603_wtbl4_addr(idx);\n\tfor (i = 0; i < MT_WTBL4_SIZE; i += 4)\n\t\tmt76_wr(dev, addr + i, 0);\n\n\tmt7603_wtbl_update(dev, idx, MT_WTBL_UPDATE_ADM_COUNT_CLEAR);\n}\n\nstatic void\nmt7603_wtbl_set_skip_tx(struct mt7603_dev *dev, int idx, bool enabled)\n{\n\tu32 addr = mt7603_wtbl1_addr(idx);\n\tu32 val = mt76_rr(dev, addr + 3 * 4);\n\n\tval &= ~MT_WTBL1_W3_SKIP_TX;\n\tval |= enabled * MT_WTBL1_W3_SKIP_TX;\n\n\tmt76_wr(dev, addr + 3 * 4, val);\n}\n\nvoid mt7603_filter_tx(struct mt7603_dev *dev, int mac_idx, int idx, bool abort)\n{\n\tu32 flush_mask;\n\tint i, port, queue;\n\n\tif (abort) {\n\t\tport = 3;  \n\t\tqueue = 8;  \n\t} else {\n\t\tport = 0;  \n\t\tqueue = 1;  \n\t}\n\n\tmt7603_wtbl_set_skip_tx(dev, idx, true);\n\n\tmt76_wr(dev, MT_TX_ABORT, MT_TX_ABORT_EN |\n\t\t\tFIELD_PREP(MT_TX_ABORT_WCID, idx));\n\n\tflush_mask = MT_WF_ARB_TX_FLUSH_AC0 |\n\t\t     MT_WF_ARB_TX_FLUSH_AC1 |\n\t\t     MT_WF_ARB_TX_FLUSH_AC2 |\n\t\t     MT_WF_ARB_TX_FLUSH_AC3;\n\tflush_mask <<= mac_idx;\n\n\tmt76_wr(dev, MT_WF_ARB_TX_FLUSH_0, flush_mask);\n\tmt76_poll(dev, MT_WF_ARB_TX_FLUSH_0, flush_mask, 0, 20000);\n\tmt76_wr(dev, MT_WF_ARB_TX_START_0, flush_mask);\n\n\tmt76_wr(dev, MT_TX_ABORT, 0);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tmt76_wr(dev, MT_DMA_FQCR0, MT_DMA_FQCR0_BUSY |\n\t\t\tFIELD_PREP(MT_DMA_FQCR0_TARGET_WCID, idx) |\n\t\t\tFIELD_PREP(MT_DMA_FQCR0_TARGET_QID, i) |\n\t\t\tFIELD_PREP(MT_DMA_FQCR0_DEST_PORT_ID, port) |\n\t\t\tFIELD_PREP(MT_DMA_FQCR0_DEST_QUEUE_ID, queue));\n\n\t\tmt76_poll(dev, MT_DMA_FQCR0, MT_DMA_FQCR0_BUSY, 0, 5000);\n\t}\n\n\tWARN_ON_ONCE(mt76_rr(dev, MT_DMA_FQCR0) & MT_DMA_FQCR0_BUSY);\n\n\tmt7603_wtbl_set_skip_tx(dev, idx, false);\n}\n\nvoid mt7603_wtbl_set_smps(struct mt7603_dev *dev, struct mt7603_sta *sta,\n\t\t\t  bool enabled)\n{\n\tu32 addr = mt7603_wtbl1_addr(sta->wcid.idx);\n\n\tif (sta->smps == enabled)\n\t\treturn;\n\n\tmt76_rmw_field(dev, addr + 2 * 4, MT_WTBL1_W2_SMPS, enabled);\n\tsta->smps = enabled;\n}\n\nvoid mt7603_wtbl_set_ps(struct mt7603_dev *dev, struct mt7603_sta *sta,\n\t\t\tbool enabled)\n{\n\tint idx = sta->wcid.idx;\n\tu32 addr;\n\n\tspin_lock_bh(&dev->ps_lock);\n\n\tif (sta->ps == enabled)\n\t\tgoto out;\n\n\tmt76_wr(dev, MT_PSE_RTA,\n\t\tFIELD_PREP(MT_PSE_RTA_TAG_ID, idx) |\n\t\tFIELD_PREP(MT_PSE_RTA_PORT_ID, 0) |\n\t\tFIELD_PREP(MT_PSE_RTA_QUEUE_ID, 1) |\n\t\tFIELD_PREP(MT_PSE_RTA_REDIRECT_EN, enabled) |\n\t\tMT_PSE_RTA_WRITE | MT_PSE_RTA_BUSY);\n\n\tmt76_poll(dev, MT_PSE_RTA, MT_PSE_RTA_BUSY, 0, 5000);\n\n\tif (enabled)\n\t\tmt7603_filter_tx(dev, sta->vif->idx, idx, false);\n\n\taddr = mt7603_wtbl1_addr(idx);\n\tmt76_set(dev, MT_WTBL1_OR, MT_WTBL1_OR_PSM_WRITE);\n\tmt76_rmw(dev, addr + 3 * 4, MT_WTBL1_W3_POWER_SAVE,\n\t\t enabled * MT_WTBL1_W3_POWER_SAVE);\n\tmt76_clear(dev, MT_WTBL1_OR, MT_WTBL1_OR_PSM_WRITE);\n\tsta->ps = enabled;\n\nout:\n\tspin_unlock_bh(&dev->ps_lock);\n}\n\nvoid mt7603_wtbl_clear(struct mt7603_dev *dev, int idx)\n{\n\tint wtbl2_frame_size = MT_PSE_PAGE_SIZE / MT_WTBL2_SIZE;\n\tint wtbl2_frame = idx / wtbl2_frame_size;\n\tint wtbl2_entry = idx % wtbl2_frame_size;\n\n\tint wtbl3_base_frame = MT_WTBL3_OFFSET / MT_PSE_PAGE_SIZE;\n\tint wtbl3_frame_size = MT_PSE_PAGE_SIZE / MT_WTBL3_SIZE;\n\tint wtbl3_frame = wtbl3_base_frame + idx / wtbl3_frame_size;\n\tint wtbl3_entry = (idx % wtbl3_frame_size) * 2;\n\n\tint wtbl4_base_frame = MT_WTBL4_OFFSET / MT_PSE_PAGE_SIZE;\n\tint wtbl4_frame_size = MT_PSE_PAGE_SIZE / MT_WTBL4_SIZE;\n\tint wtbl4_frame = wtbl4_base_frame + idx / wtbl4_frame_size;\n\tint wtbl4_entry = idx % wtbl4_frame_size;\n\n\tu32 addr = MT_WTBL1_BASE + idx * MT_WTBL1_SIZE;\n\tint i;\n\n\tmt76_poll(dev, MT_WTBL_UPDATE, MT_WTBL_UPDATE_BUSY, 0, 5000);\n\n\tmt76_wr(dev, addr + 0 * 4,\n\t\tMT_WTBL1_W0_RX_CHECK_A1 |\n\t\tMT_WTBL1_W0_RX_CHECK_A2 |\n\t\tMT_WTBL1_W0_RX_VALID);\n\tmt76_wr(dev, addr + 1 * 4, 0);\n\tmt76_wr(dev, addr + 2 * 4, 0);\n\n\tmt76_set(dev, MT_WTBL1_OR, MT_WTBL1_OR_PSM_WRITE);\n\n\tmt76_wr(dev, addr + 3 * 4,\n\t\tFIELD_PREP(MT_WTBL1_W3_WTBL2_FRAME_ID, wtbl2_frame) |\n\t\tFIELD_PREP(MT_WTBL1_W3_WTBL2_ENTRY_ID, wtbl2_entry) |\n\t\tFIELD_PREP(MT_WTBL1_W3_WTBL4_FRAME_ID, wtbl4_frame) |\n\t\tMT_WTBL1_W3_I_PSM | MT_WTBL1_W3_KEEP_I_PSM);\n\tmt76_wr(dev, addr + 4 * 4,\n\t\tFIELD_PREP(MT_WTBL1_W4_WTBL3_FRAME_ID, wtbl3_frame) |\n\t\tFIELD_PREP(MT_WTBL1_W4_WTBL3_ENTRY_ID, wtbl3_entry) |\n\t\tFIELD_PREP(MT_WTBL1_W4_WTBL4_ENTRY_ID, wtbl4_entry));\n\n\tmt76_clear(dev, MT_WTBL1_OR, MT_WTBL1_OR_PSM_WRITE);\n\n\taddr = mt7603_wtbl2_addr(idx);\n\n\t \n\tmt76_wr(dev, addr + (15 * 4), 0);\n\n\tmt76_stop_tx_ac(dev, GENMASK(3, 0));\n\tfor (i = 2; i <= 4; i++)\n\t\tmt76_wr(dev, addr + (i * 4), 0);\n\tmt7603_wtbl_update(dev, idx, MT_WTBL_UPDATE_WTBL2);\n\tmt76_start_tx_ac(dev, GENMASK(3, 0));\n\n\tmt7603_wtbl_update(dev, idx, MT_WTBL_UPDATE_RX_COUNT_CLEAR);\n\tmt7603_wtbl_update(dev, idx, MT_WTBL_UPDATE_TX_COUNT_CLEAR);\n\tmt7603_wtbl_update(dev, idx, MT_WTBL_UPDATE_ADM_COUNT_CLEAR);\n}\n\nvoid mt7603_wtbl_update_cap(struct mt7603_dev *dev, struct ieee80211_sta *sta)\n{\n\tstruct mt7603_sta *msta = (struct mt7603_sta *)sta->drv_priv;\n\tint idx = msta->wcid.idx;\n\tu8 ampdu_density;\n\tu32 addr;\n\tu32 val;\n\n\taddr = mt7603_wtbl1_addr(idx);\n\n\tampdu_density = sta->deflink.ht_cap.ampdu_density;\n\tif (ampdu_density < IEEE80211_HT_MPDU_DENSITY_4)\n\t\tampdu_density = IEEE80211_HT_MPDU_DENSITY_4;\n\n\tval = mt76_rr(dev, addr + 2 * 4);\n\tval &= MT_WTBL1_W2_KEY_TYPE | MT_WTBL1_W2_ADMISSION_CONTROL;\n\tval |= FIELD_PREP(MT_WTBL1_W2_AMPDU_FACTOR,\n\t\t\t  sta->deflink.ht_cap.ampdu_factor) |\n\t       FIELD_PREP(MT_WTBL1_W2_MPDU_DENSITY,\n\t\t\t  sta->deflink.ht_cap.ampdu_density) |\n\t       MT_WTBL1_W2_TXS_BAF_REPORT;\n\n\tif (sta->deflink.ht_cap.cap)\n\t\tval |= MT_WTBL1_W2_HT;\n\tif (sta->deflink.vht_cap.cap)\n\t\tval |= MT_WTBL1_W2_VHT;\n\n\tmt76_wr(dev, addr + 2 * 4, val);\n\n\taddr = mt7603_wtbl2_addr(idx);\n\tval = mt76_rr(dev, addr + 9 * 4);\n\tval &= ~(MT_WTBL2_W9_SHORT_GI_20 | MT_WTBL2_W9_SHORT_GI_40 |\n\t\t MT_WTBL2_W9_SHORT_GI_80);\n\tif (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_20)\n\t\tval |= MT_WTBL2_W9_SHORT_GI_20;\n\tif (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_40)\n\t\tval |= MT_WTBL2_W9_SHORT_GI_40;\n\tmt76_wr(dev, addr + 9 * 4, val);\n}\n\nvoid mt7603_mac_rx_ba_reset(struct mt7603_dev *dev, void *addr, u8 tid)\n{\n\tmt76_wr(dev, MT_BA_CONTROL_0, get_unaligned_le32(addr));\n\tmt76_wr(dev, MT_BA_CONTROL_1,\n\t\t(get_unaligned_le16(addr + 4) |\n\t\t FIELD_PREP(MT_BA_CONTROL_1_TID, tid) |\n\t\t MT_BA_CONTROL_1_RESET));\n}\n\nvoid mt7603_mac_tx_ba_reset(struct mt7603_dev *dev, int wcid, int tid,\n\t\t\t    int ba_size)\n{\n\tu32 addr = mt7603_wtbl2_addr(wcid);\n\tu32 tid_mask = FIELD_PREP(MT_WTBL2_W15_BA_EN_TIDS, BIT(tid)) |\n\t\t       (MT_WTBL2_W15_BA_WIN_SIZE <<\n\t\t\t(tid * MT_WTBL2_W15_BA_WIN_SIZE_SHIFT));\n\tu32 tid_val;\n\tint i;\n\n\tif (ba_size < 0) {\n\t\t \n\t\tmt76_clear(dev, addr + (15 * 4), tid_mask);\n\t\treturn;\n\t}\n\n\tfor (i = 7; i > 0; i--) {\n\t\tif (ba_size >= MT_AGG_SIZE_LIMIT(i))\n\t\t\tbreak;\n\t}\n\n\ttid_val = FIELD_PREP(MT_WTBL2_W15_BA_EN_TIDS, BIT(tid)) |\n\t\t  i << (tid * MT_WTBL2_W15_BA_WIN_SIZE_SHIFT);\n\n\tmt76_rmw(dev, addr + (15 * 4), tid_mask, tid_val);\n}\n\nvoid mt7603_mac_sta_poll(struct mt7603_dev *dev)\n{\n\tstatic const u8 ac_to_tid[4] = {\n\t\t[IEEE80211_AC_BE] = 0,\n\t\t[IEEE80211_AC_BK] = 1,\n\t\t[IEEE80211_AC_VI] = 4,\n\t\t[IEEE80211_AC_VO] = 6\n\t};\n\tstruct ieee80211_sta *sta;\n\tstruct mt7603_sta *msta;\n\tu32 total_airtime = 0;\n\tu32 airtime[4];\n\tu32 addr;\n\tint i;\n\n\trcu_read_lock();\n\n\twhile (1) {\n\t\tbool clear = false;\n\n\t\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\t\tif (list_empty(&dev->mt76.sta_poll_list)) {\n\t\t\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tmsta = list_first_entry(&dev->mt76.sta_poll_list,\n\t\t\t\t\tstruct mt7603_sta, wcid.poll_list);\n\t\tlist_del_init(&msta->wcid.poll_list);\n\t\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\n\t\taddr = mt7603_wtbl4_addr(msta->wcid.idx);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tu32 airtime_last = msta->tx_airtime_ac[i];\n\n\t\t\tmsta->tx_airtime_ac[i] = mt76_rr(dev, addr + i * 8);\n\t\t\tairtime[i] = msta->tx_airtime_ac[i] - airtime_last;\n\t\t\tairtime[i] *= 32;\n\t\t\ttotal_airtime += airtime[i];\n\n\t\t\tif (msta->tx_airtime_ac[i] & BIT(22))\n\t\t\t\tclear = true;\n\t\t}\n\n\t\tif (clear) {\n\t\t\tmt7603_wtbl_update(dev, msta->wcid.idx,\n\t\t\t\t\t   MT_WTBL_UPDATE_ADM_COUNT_CLEAR);\n\t\t\tmemset(msta->tx_airtime_ac, 0,\n\t\t\t       sizeof(msta->tx_airtime_ac));\n\t\t}\n\n\t\tif (!msta->wcid.sta)\n\t\t\tcontinue;\n\n\t\tsta = container_of((void *)msta, struct ieee80211_sta, drv_priv);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tstruct mt76_queue *q = dev->mphy.q_tx[i];\n\t\t\tu8 qidx = q->hw_idx;\n\t\t\tu8 tid = ac_to_tid[i];\n\t\t\tu32 txtime = airtime[qidx];\n\n\t\t\tif (!txtime)\n\t\t\t\tcontinue;\n\n\t\t\tieee80211_sta_register_airtime(sta, tid, txtime, 0);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\tif (!total_airtime)\n\t\treturn;\n\n\tspin_lock_bh(&dev->mt76.cc_lock);\n\tdev->mphy.chan_state->cc_tx += total_airtime;\n\tspin_unlock_bh(&dev->mt76.cc_lock);\n}\n\nstatic struct mt76_wcid *\nmt7603_rx_get_wcid(struct mt7603_dev *dev, u8 idx, bool unicast)\n{\n\tstruct mt7603_sta *sta;\n\tstruct mt76_wcid *wcid;\n\n\tif (idx >= MT7603_WTBL_SIZE)\n\t\treturn NULL;\n\n\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n\tif (unicast || !wcid)\n\t\treturn wcid;\n\n\tif (!wcid->sta)\n\t\treturn NULL;\n\n\tsta = container_of(wcid, struct mt7603_sta, wcid);\n\tif (!sta->vif)\n\t\treturn NULL;\n\n\treturn &sta->vif->sta.wcid;\n}\n\nint\nmt7603_mac_fill_rx(struct mt7603_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt76_rx_status *status = (struct mt76_rx_status *)skb->cb;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_hdr *hdr;\n\t__le32 *rxd = (__le32 *)skb->data;\n\tu32 rxd0 = le32_to_cpu(rxd[0]);\n\tu32 rxd1 = le32_to_cpu(rxd[1]);\n\tu32 rxd2 = le32_to_cpu(rxd[2]);\n\tbool unicast = rxd1 & MT_RXD1_NORMAL_U2M;\n\tbool insert_ccmp_hdr = false;\n\tbool remove_pad;\n\tint idx;\n\tint i;\n\n\tmemset(status, 0, sizeof(*status));\n\n\ti = FIELD_GET(MT_RXD1_NORMAL_CH_FREQ, rxd1);\n\tsband = (i & 1) ? &dev->mphy.sband_5g.sband : &dev->mphy.sband_2g.sband;\n\ti >>= 1;\n\n\tidx = FIELD_GET(MT_RXD2_NORMAL_WLAN_IDX, rxd2);\n\tstatus->wcid = mt7603_rx_get_wcid(dev, idx, unicast);\n\n\tstatus->band = sband->band;\n\tif (i < sband->n_channels)\n\t\tstatus->freq = sband->channels[i].center_freq;\n\n\tif (rxd2 & MT_RXD2_NORMAL_FCS_ERR)\n\t\tstatus->flag |= RX_FLAG_FAILED_FCS_CRC;\n\n\tif (rxd2 & MT_RXD2_NORMAL_TKIP_MIC_ERR)\n\t\tstatus->flag |= RX_FLAG_MMIC_ERROR;\n\n\t \n\tif (rxd2 & MT_RXD2_NORMAL_ICV_ERR)\n\t\tstatus->flag |= RX_FLAG_ONLY_MONITOR;\n\n\tif (FIELD_GET(MT_RXD2_NORMAL_SEC_MODE, rxd2) != 0 &&\n\t    !(rxd2 & (MT_RXD2_NORMAL_CLM | MT_RXD2_NORMAL_CM))) {\n\t\tstatus->flag |= RX_FLAG_DECRYPTED;\n\t\tstatus->flag |= RX_FLAG_IV_STRIPPED;\n\t\tstatus->flag |= RX_FLAG_MMIC_STRIPPED | RX_FLAG_MIC_STRIPPED;\n\t}\n\n\tremove_pad = rxd1 & MT_RXD1_NORMAL_HDR_OFFSET;\n\n\tif (rxd2 & MT_RXD2_NORMAL_MAX_LEN_ERROR)\n\t\treturn -EINVAL;\n\n\tif (!sband->channels)\n\t\treturn -EINVAL;\n\n\trxd += 4;\n\tif (rxd0 & MT_RXD0_NORMAL_GROUP_4) {\n\t\trxd += 4;\n\t\tif ((u8 *)rxd - skb->data >= skb->len)\n\t\t\treturn -EINVAL;\n\t}\n\tif (rxd0 & MT_RXD0_NORMAL_GROUP_1) {\n\t\tu8 *data = (u8 *)rxd;\n\n\t\tif (status->flag & RX_FLAG_DECRYPTED) {\n\t\t\tswitch (FIELD_GET(MT_RXD2_NORMAL_SEC_MODE, rxd2)) {\n\t\t\tcase MT_CIPHER_AES_CCMP:\n\t\t\tcase MT_CIPHER_CCMP_CCX:\n\t\t\tcase MT_CIPHER_CCMP_256:\n\t\t\t\tinsert_ccmp_hdr =\n\t\t\t\t\tFIELD_GET(MT_RXD2_NORMAL_FRAG, rxd2);\n\t\t\t\tfallthrough;\n\t\t\tcase MT_CIPHER_TKIP:\n\t\t\tcase MT_CIPHER_TKIP_NO_MIC:\n\t\t\tcase MT_CIPHER_GCMP:\n\t\t\tcase MT_CIPHER_GCMP_256:\n\t\t\t\tstatus->iv[0] = data[5];\n\t\t\t\tstatus->iv[1] = data[4];\n\t\t\t\tstatus->iv[2] = data[3];\n\t\t\t\tstatus->iv[3] = data[2];\n\t\t\t\tstatus->iv[4] = data[1];\n\t\t\t\tstatus->iv[5] = data[0];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\trxd += 4;\n\t\tif ((u8 *)rxd - skb->data >= skb->len)\n\t\t\treturn -EINVAL;\n\t}\n\tif (rxd0 & MT_RXD0_NORMAL_GROUP_2) {\n\t\tstatus->timestamp = le32_to_cpu(rxd[0]);\n\t\tstatus->flag |= RX_FLAG_MACTIME_START;\n\n\t\tif (!(rxd2 & (MT_RXD2_NORMAL_NON_AMPDU_SUB |\n\t\t\t      MT_RXD2_NORMAL_NON_AMPDU))) {\n\t\t\tstatus->flag |= RX_FLAG_AMPDU_DETAILS;\n\n\t\t\t \n\t\t\tif (dev->rx_ampdu_ts != status->timestamp) {\n\t\t\t\tif (!++dev->ampdu_ref)\n\t\t\t\t\tdev->ampdu_ref++;\n\t\t\t}\n\t\t\tdev->rx_ampdu_ts = status->timestamp;\n\n\t\t\tstatus->ampdu_ref = dev->ampdu_ref;\n\t\t}\n\n\t\trxd += 2;\n\t\tif ((u8 *)rxd - skb->data >= skb->len)\n\t\t\treturn -EINVAL;\n\t}\n\tif (rxd0 & MT_RXD0_NORMAL_GROUP_3) {\n\t\tu32 rxdg0 = le32_to_cpu(rxd[0]);\n\t\tu32 rxdg3 = le32_to_cpu(rxd[3]);\n\t\tbool cck = false;\n\n\t\ti = FIELD_GET(MT_RXV1_TX_RATE, rxdg0);\n\t\tswitch (FIELD_GET(MT_RXV1_TX_MODE, rxdg0)) {\n\t\tcase MT_PHY_TYPE_CCK:\n\t\t\tcck = true;\n\t\t\tfallthrough;\n\t\tcase MT_PHY_TYPE_OFDM:\n\t\t\ti = mt76_get_rate(&dev->mt76, sband, i, cck);\n\t\t\tbreak;\n\t\tcase MT_PHY_TYPE_HT_GF:\n\t\tcase MT_PHY_TYPE_HT:\n\t\t\tstatus->encoding = RX_ENC_HT;\n\t\t\tif (i > 15)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (rxdg0 & MT_RXV1_HT_SHORT_GI)\n\t\t\tstatus->enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\t\tif (rxdg0 & MT_RXV1_HT_AD_CODE)\n\t\t\tstatus->enc_flags |= RX_ENC_FLAG_LDPC;\n\n\t\tstatus->enc_flags |= RX_ENC_FLAG_STBC_MASK *\n\t\t\t\t    FIELD_GET(MT_RXV1_HT_STBC, rxdg0);\n\n\t\tstatus->rate_idx = i;\n\n\t\tstatus->chains = dev->mphy.antenna_mask;\n\t\tstatus->chain_signal[0] = FIELD_GET(MT_RXV4_IB_RSSI0, rxdg3) +\n\t\t\t\t\t  dev->rssi_offset[0];\n\t\tstatus->chain_signal[1] = FIELD_GET(MT_RXV4_IB_RSSI1, rxdg3) +\n\t\t\t\t\t  dev->rssi_offset[1];\n\n\t\tif (FIELD_GET(MT_RXV1_FRAME_MODE, rxdg0) == 1)\n\t\t\tstatus->bw = RATE_INFO_BW_40;\n\n\t\trxd += 6;\n\t\tif ((u8 *)rxd - skb->data >= skb->len)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tskb_pull(skb, (u8 *)rxd - skb->data + 2 * remove_pad);\n\n\tif (insert_ccmp_hdr) {\n\t\tu8 key_id = FIELD_GET(MT_RXD1_NORMAL_KEY_ID, rxd1);\n\n\t\tmt76_insert_ccmp_hdr(skb, key_id);\n\t}\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\tif (!status->wcid || !ieee80211_is_data_qos(hdr->frame_control))\n\t\treturn 0;\n\n\tstatus->aggr = unicast &&\n\t\t       !ieee80211_is_qos_nullfunc(hdr->frame_control);\n\tstatus->qos_ctl = *ieee80211_get_qos_ctl(hdr);\n\tstatus->seqno = IEEE80211_SEQ_TO_SN(le16_to_cpu(hdr->seq_ctrl));\n\n\treturn 0;\n}\n\nstatic u16\nmt7603_mac_tx_rate_val(struct mt7603_dev *dev,\n\t\t       const struct ieee80211_tx_rate *rate, bool stbc, u8 *bw)\n{\n\tu8 phy, nss, rate_idx;\n\tu16 rateval;\n\n\t*bw = 0;\n\tif (rate->flags & IEEE80211_TX_RC_MCS) {\n\t\trate_idx = rate->idx;\n\t\tnss = 1 + (rate->idx >> 3);\n\t\tphy = MT_PHY_TYPE_HT;\n\t\tif (rate->flags & IEEE80211_TX_RC_GREEN_FIELD)\n\t\t\tphy = MT_PHY_TYPE_HT_GF;\n\t\tif (rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\n\t\t\t*bw = 1;\n\t} else {\n\t\tconst struct ieee80211_rate *r;\n\t\tint band = dev->mphy.chandef.chan->band;\n\t\tu16 val;\n\n\t\tnss = 1;\n\t\tr = &mt76_hw(dev)->wiphy->bands[band]->bitrates[rate->idx];\n\t\tif (rate->flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE)\n\t\t\tval = r->hw_value_short;\n\t\telse\n\t\t\tval = r->hw_value;\n\n\t\tphy = val >> 8;\n\t\trate_idx = val & 0xff;\n\t}\n\n\trateval = (FIELD_PREP(MT_TX_RATE_IDX, rate_idx) |\n\t\t   FIELD_PREP(MT_TX_RATE_MODE, phy));\n\n\tif (stbc && nss == 1)\n\t\trateval |= MT_TX_RATE_STBC;\n\n\treturn rateval;\n}\n\nvoid mt7603_wtbl_set_rates(struct mt7603_dev *dev, struct mt7603_sta *sta,\n\t\t\t   struct ieee80211_tx_rate *probe_rate,\n\t\t\t   struct ieee80211_tx_rate *rates)\n{\n\tstruct ieee80211_tx_rate *ref;\n\tint wcid = sta->wcid.idx;\n\tu32 addr = mt7603_wtbl2_addr(wcid);\n\tbool stbc = false;\n\tint n_rates = sta->n_rates;\n\tu8 bw, bw_prev, bw_idx = 0;\n\tu16 val[4];\n\tu16 probe_val;\n\tu32 w9 = mt76_rr(dev, addr + 9 * 4);\n\tbool rateset;\n\tint i, k;\n\n\tif (!mt76_poll(dev, MT_WTBL_UPDATE, MT_WTBL_UPDATE_BUSY, 0, 5000))\n\t\treturn;\n\n\tfor (i = n_rates; i < 4; i++)\n\t\trates[i] = rates[n_rates - 1];\n\n\trateset = !(sta->rate_set_tsf & BIT(0));\n\tmemcpy(sta->rateset[rateset].rates, rates,\n\t       sizeof(sta->rateset[rateset].rates));\n\tif (probe_rate) {\n\t\tsta->rateset[rateset].probe_rate = *probe_rate;\n\t\tref = &sta->rateset[rateset].probe_rate;\n\t} else {\n\t\tsta->rateset[rateset].probe_rate.idx = -1;\n\t\tref = &sta->rateset[rateset].rates[0];\n\t}\n\n\trates = sta->rateset[rateset].rates;\n\tfor (i = 0; i < ARRAY_SIZE(sta->rateset[rateset].rates); i++) {\n\t\t \n\t\tif ((ref->flags ^ rates[i].flags) & IEEE80211_TX_RC_SHORT_GI)\n\t\t\trates[i].flags ^= IEEE80211_TX_RC_SHORT_GI;\n\n\t\tfor (k = 0; k < i; k++) {\n\t\t\tif (rates[i].idx != rates[k].idx)\n\t\t\t\tcontinue;\n\t\t\tif ((rates[i].flags ^ rates[k].flags) &\n\t\t\t    IEEE80211_TX_RC_40_MHZ_WIDTH)\n\t\t\t\tcontinue;\n\n\t\t\tif (!rates[i].idx)\n\t\t\t\tcontinue;\n\n\t\t\trates[i].idx--;\n\t\t}\n\t}\n\n\tw9 &= MT_WTBL2_W9_SHORT_GI_20 | MT_WTBL2_W9_SHORT_GI_40 |\n\t      MT_WTBL2_W9_SHORT_GI_80;\n\n\tval[0] = mt7603_mac_tx_rate_val(dev, &rates[0], stbc, &bw);\n\tbw_prev = bw;\n\n\tif (probe_rate) {\n\t\tprobe_val = mt7603_mac_tx_rate_val(dev, probe_rate, stbc, &bw);\n\t\tif (bw)\n\t\t\tbw_idx = 1;\n\t\telse\n\t\t\tbw_prev = 0;\n\t} else {\n\t\tprobe_val = val[0];\n\t}\n\n\tw9 |= FIELD_PREP(MT_WTBL2_W9_CC_BW_SEL, bw);\n\tw9 |= FIELD_PREP(MT_WTBL2_W9_BW_CAP, bw);\n\n\tval[1] = mt7603_mac_tx_rate_val(dev, &rates[1], stbc, &bw);\n\tif (bw_prev) {\n\t\tbw_idx = 3;\n\t\tbw_prev = bw;\n\t}\n\n\tval[2] = mt7603_mac_tx_rate_val(dev, &rates[2], stbc, &bw);\n\tif (bw_prev) {\n\t\tbw_idx = 5;\n\t\tbw_prev = bw;\n\t}\n\n\tval[3] = mt7603_mac_tx_rate_val(dev, &rates[3], stbc, &bw);\n\tif (bw_prev)\n\t\tbw_idx = 7;\n\n\tw9 |= FIELD_PREP(MT_WTBL2_W9_CHANGE_BW_RATE,\n\t\t       bw_idx ? bw_idx - 1 : 7);\n\n\tmt76_wr(dev, MT_WTBL_RIUCR0, w9);\n\n\tmt76_wr(dev, MT_WTBL_RIUCR1,\n\t\tFIELD_PREP(MT_WTBL_RIUCR1_RATE0, probe_val) |\n\t\tFIELD_PREP(MT_WTBL_RIUCR1_RATE1, val[0]) |\n\t\tFIELD_PREP(MT_WTBL_RIUCR1_RATE2_LO, val[1]));\n\n\tmt76_wr(dev, MT_WTBL_RIUCR2,\n\t\tFIELD_PREP(MT_WTBL_RIUCR2_RATE2_HI, val[1] >> 8) |\n\t\tFIELD_PREP(MT_WTBL_RIUCR2_RATE3, val[1]) |\n\t\tFIELD_PREP(MT_WTBL_RIUCR2_RATE4, val[2]) |\n\t\tFIELD_PREP(MT_WTBL_RIUCR2_RATE5_LO, val[2]));\n\n\tmt76_wr(dev, MT_WTBL_RIUCR3,\n\t\tFIELD_PREP(MT_WTBL_RIUCR3_RATE5_HI, val[2] >> 4) |\n\t\tFIELD_PREP(MT_WTBL_RIUCR3_RATE6, val[3]) |\n\t\tFIELD_PREP(MT_WTBL_RIUCR3_RATE7, val[3]));\n\n\tmt76_set(dev, MT_LPON_T0CR, MT_LPON_T0CR_MODE);  \n\tsta->rate_set_tsf = (mt76_rr(dev, MT_LPON_UTTR0) & ~BIT(0)) | rateset;\n\n\tmt76_wr(dev, MT_WTBL_UPDATE,\n\t\tFIELD_PREP(MT_WTBL_UPDATE_WLAN_IDX, wcid) |\n\t\tMT_WTBL_UPDATE_RATE_UPDATE |\n\t\tMT_WTBL_UPDATE_TX_COUNT_CLEAR);\n\n\tif (!(sta->wcid.tx_info & MT_WCID_TX_INFO_SET))\n\t\tmt76_poll(dev, MT_WTBL_UPDATE, MT_WTBL_UPDATE_BUSY, 0, 5000);\n\n\tsta->rate_count = 2 * MT7603_RATE_RETRY * n_rates;\n\tsta->wcid.tx_info |= MT_WCID_TX_INFO_SET;\n}\n\nstatic enum mt76_cipher_type\nmt7603_mac_get_key_info(struct ieee80211_key_conf *key, u8 *key_data)\n{\n\tmemset(key_data, 0, 32);\n\tif (!key)\n\t\treturn MT_CIPHER_NONE;\n\n\tif (key->keylen > 32)\n\t\treturn MT_CIPHER_NONE;\n\n\tmemcpy(key_data, key->key, key->keylen);\n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\treturn MT_CIPHER_WEP40;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\treturn MT_CIPHER_WEP104;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t \n\t\tmemcpy(key_data + 16, key->key + 24, 8);\n\t\tmemcpy(key_data + 24, key->key + 16, 8);\n\t\treturn MT_CIPHER_TKIP;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\treturn MT_CIPHER_AES_CCMP;\n\tdefault:\n\t\treturn MT_CIPHER_NONE;\n\t}\n}\n\nint mt7603_wtbl_set_key(struct mt7603_dev *dev, int wcid,\n\t\t\tstruct ieee80211_key_conf *key)\n{\n\tenum mt76_cipher_type cipher;\n\tu32 addr = mt7603_wtbl3_addr(wcid);\n\tu8 key_data[32];\n\tint key_len = sizeof(key_data);\n\n\tcipher = mt7603_mac_get_key_info(key, key_data);\n\tif (cipher == MT_CIPHER_NONE && key)\n\t\treturn -EOPNOTSUPP;\n\n\tif (key && (cipher == MT_CIPHER_WEP40 || cipher == MT_CIPHER_WEP104)) {\n\t\taddr += key->keyidx * 16;\n\t\tkey_len = 16;\n\t}\n\n\tmt76_wr_copy(dev, addr, key_data, key_len);\n\n\taddr = mt7603_wtbl1_addr(wcid);\n\tmt76_rmw_field(dev, addr + 2 * 4, MT_WTBL1_W2_KEY_TYPE, cipher);\n\tif (key)\n\t\tmt76_rmw_field(dev, addr, MT_WTBL1_W0_KEY_IDX, key->keyidx);\n\tmt76_rmw_field(dev, addr, MT_WTBL1_W0_RX_KEY_VALID, !!key);\n\n\treturn 0;\n}\n\nstatic int\nmt7603_mac_write_txwi(struct mt7603_dev *dev, __le32 *txwi,\n\t\t      struct sk_buff *skb, enum mt76_txq_id qid,\n\t\t      struct mt76_wcid *wcid, struct ieee80211_sta *sta,\n\t\t      int pid, struct ieee80211_key_conf *key)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_tx_rate *rate = &info->control.rates[0];\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct ieee80211_bar *bar = (struct ieee80211_bar *)skb->data;\n\tstruct ieee80211_vif *vif = info->control.vif;\n\tstruct mt76_queue *q = dev->mphy.q_tx[qid];\n\tstruct mt7603_vif *mvif;\n\tint wlan_idx;\n\tint hdr_len = ieee80211_get_hdrlen_from_skb(skb);\n\tint tx_count = 8;\n\tu8 frame_type, frame_subtype;\n\tu16 fc = le16_to_cpu(hdr->frame_control);\n\tu16 seqno = 0;\n\tu8 vif_idx = 0;\n\tu32 val;\n\tu8 bw;\n\n\tif (vif) {\n\t\tmvif = (struct mt7603_vif *)vif->drv_priv;\n\t\tvif_idx = mvif->idx;\n\t\tif (vif_idx && qid >= MT_TXQ_BEACON)\n\t\t\tvif_idx += 0x10;\n\t}\n\n\tif (sta) {\n\t\tstruct mt7603_sta *msta = (struct mt7603_sta *)sta->drv_priv;\n\n\t\ttx_count = msta->rate_count;\n\t}\n\n\tif (wcid)\n\t\twlan_idx = wcid->idx;\n\telse\n\t\twlan_idx = MT7603_WTBL_RESERVED;\n\n\tframe_type = (fc & IEEE80211_FCTL_FTYPE) >> 2;\n\tframe_subtype = (fc & IEEE80211_FCTL_STYPE) >> 4;\n\n\tval = FIELD_PREP(MT_TXD0_TX_BYTES, skb->len + MT_TXD_SIZE) |\n\t      FIELD_PREP(MT_TXD0_Q_IDX, q->hw_idx);\n\ttxwi[0] = cpu_to_le32(val);\n\n\tval = MT_TXD1_LONG_FORMAT |\n\t      FIELD_PREP(MT_TXD1_OWN_MAC, vif_idx) |\n\t      FIELD_PREP(MT_TXD1_TID,\n\t\t\t skb->priority & IEEE80211_QOS_CTL_TID_MASK) |\n\t      FIELD_PREP(MT_TXD1_HDR_FORMAT, MT_HDR_FORMAT_802_11) |\n\t      FIELD_PREP(MT_TXD1_HDR_INFO, hdr_len / 2) |\n\t      FIELD_PREP(MT_TXD1_WLAN_IDX, wlan_idx) |\n\t      FIELD_PREP(MT_TXD1_PROTECTED, !!key);\n\ttxwi[1] = cpu_to_le32(val);\n\n\tif (info->flags & IEEE80211_TX_CTL_NO_ACK)\n\t\ttxwi[1] |= cpu_to_le32(MT_TXD1_NO_ACK);\n\n\tval = FIELD_PREP(MT_TXD2_FRAME_TYPE, frame_type) |\n\t      FIELD_PREP(MT_TXD2_SUB_TYPE, frame_subtype) |\n\t      FIELD_PREP(MT_TXD2_MULTICAST,\n\t\t\t is_multicast_ether_addr(hdr->addr1));\n\ttxwi[2] = cpu_to_le32(val);\n\n\tif (!(info->flags & IEEE80211_TX_CTL_AMPDU))\n\t\ttxwi[2] |= cpu_to_le32(MT_TXD2_BA_DISABLE);\n\n\ttxwi[4] = 0;\n\n\tval = MT_TXD5_TX_STATUS_HOST | MT_TXD5_SW_POWER_MGMT |\n\t      FIELD_PREP(MT_TXD5_PID, pid);\n\ttxwi[5] = cpu_to_le32(val);\n\n\ttxwi[6] = 0;\n\n\tif (rate->idx >= 0 && rate->count &&\n\t    !(info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE)) {\n\t\tbool stbc = info->flags & IEEE80211_TX_CTL_STBC;\n\t\tu16 rateval = mt7603_mac_tx_rate_val(dev, rate, stbc, &bw);\n\n\t\ttxwi[2] |= cpu_to_le32(MT_TXD2_FIX_RATE);\n\n\t\tval = MT_TXD6_FIXED_BW |\n\t\t      FIELD_PREP(MT_TXD6_BW, bw) |\n\t\t      FIELD_PREP(MT_TXD6_TX_RATE, rateval);\n\t\ttxwi[6] |= cpu_to_le32(val);\n\n\t\tif (rate->flags & IEEE80211_TX_RC_SHORT_GI)\n\t\t\ttxwi[6] |= cpu_to_le32(MT_TXD6_SGI);\n\n\t\tif (!(rate->flags & IEEE80211_TX_RC_MCS))\n\t\t\ttxwi[2] |= cpu_to_le32(MT_TXD2_BA_DISABLE);\n\n\t\ttx_count = rate->count;\n\t}\n\n\t \n\tif (qid >= MT_TXQ_BEACON)\n\t\ttx_count = 0x1f;\n\n\tval = FIELD_PREP(MT_TXD3_REM_TX_COUNT, tx_count) |\n\t\t  MT_TXD3_SN_VALID;\n\n\tif (ieee80211_is_data_qos(hdr->frame_control))\n\t\tseqno = le16_to_cpu(hdr->seq_ctrl);\n\telse if (ieee80211_is_back_req(hdr->frame_control))\n\t\tseqno = le16_to_cpu(bar->start_seq_num);\n\telse\n\t\tval &= ~MT_TXD3_SN_VALID;\n\n\tval |= FIELD_PREP(MT_TXD3_SEQ, seqno >> 4);\n\n\ttxwi[3] = cpu_to_le32(val);\n\n\tif (key) {\n\t\tu64 pn = atomic64_inc_return(&key->tx_pn);\n\n\t\ttxwi[3] |= cpu_to_le32(MT_TXD3_PN_VALID);\n\t\ttxwi[4] = cpu_to_le32(pn & GENMASK(31, 0));\n\t\ttxwi[5] |= cpu_to_le32(FIELD_PREP(MT_TXD5_PN_HIGH, pn >> 32));\n\t}\n\n\ttxwi[7] = 0;\n\n\treturn 0;\n}\n\nint mt7603_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,\n\t\t\t  enum mt76_txq_id qid, struct mt76_wcid *wcid,\n\t\t\t  struct ieee80211_sta *sta,\n\t\t\t  struct mt76_tx_info *tx_info)\n{\n\tstruct mt7603_dev *dev = container_of(mdev, struct mt7603_dev, mt76);\n\tstruct mt7603_sta *msta = container_of(wcid, struct mt7603_sta, wcid);\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx_info->skb);\n\tstruct ieee80211_key_conf *key = info->control.hw_key;\n\tint pid;\n\n\tif (!wcid)\n\t\twcid = &dev->global_sta.wcid;\n\n\tif (sta) {\n\t\tmsta = (struct mt7603_sta *)sta->drv_priv;\n\n\t\tif ((info->flags & (IEEE80211_TX_CTL_NO_PS_BUFFER |\n\t\t\t\t    IEEE80211_TX_CTL_CLEAR_PS_FILT)) ||\n\t\t    (info->control.flags & IEEE80211_TX_CTRL_PS_RESPONSE))\n\t\t\tmt7603_wtbl_set_ps(dev, msta, false);\n\n\t\tmt76_tx_check_agg_ssn(sta, tx_info->skb);\n\t}\n\n\tpid = mt76_tx_status_skb_add(mdev, wcid, tx_info->skb);\n\n\tif (info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE) {\n\t\tspin_lock_bh(&dev->mt76.lock);\n\t\tmt7603_wtbl_set_rates(dev, msta, &info->control.rates[0],\n\t\t\t\t      msta->rates);\n\t\tmsta->rate_probe = true;\n\t\tspin_unlock_bh(&dev->mt76.lock);\n\t}\n\n\tmt7603_mac_write_txwi(dev, txwi_ptr, tx_info->skb, qid, wcid,\n\t\t\t      sta, pid, key);\n\n\treturn 0;\n}\n\nstatic bool\nmt7603_fill_txs(struct mt7603_dev *dev, struct mt7603_sta *sta,\n\t\tstruct ieee80211_tx_info *info, __le32 *txs_data)\n{\n\tstruct ieee80211_supported_band *sband;\n\tstruct mt7603_rate_set *rs;\n\tint first_idx = 0, last_idx;\n\tu32 rate_set_tsf;\n\tu32 final_rate;\n\tu32 final_rate_flags;\n\tbool rs_idx;\n\tbool ack_timeout;\n\tbool fixed_rate;\n\tbool probe;\n\tbool ampdu;\n\tbool cck = false;\n\tint count;\n\tu32 txs;\n\tint idx;\n\tint i;\n\n\tfixed_rate = info->status.rates[0].count;\n\tprobe = !!(info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE);\n\n\ttxs = le32_to_cpu(txs_data[4]);\n\tampdu = !fixed_rate && (txs & MT_TXS4_AMPDU);\n\tcount = FIELD_GET(MT_TXS4_TX_COUNT, txs);\n\tlast_idx = FIELD_GET(MT_TXS4_LAST_TX_RATE, txs);\n\n\ttxs = le32_to_cpu(txs_data[0]);\n\tfinal_rate = FIELD_GET(MT_TXS0_TX_RATE, txs);\n\tack_timeout = txs & MT_TXS0_ACK_TIMEOUT;\n\n\tif (!ampdu && (txs & MT_TXS0_RTS_TIMEOUT))\n\t\treturn false;\n\n\tif (txs & MT_TXS0_QUEUE_TIMEOUT)\n\t\treturn false;\n\n\tif (!ack_timeout)\n\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\n\tinfo->status.ampdu_len = 1;\n\tinfo->status.ampdu_ack_len = !!(info->flags &\n\t\t\t\t\tIEEE80211_TX_STAT_ACK);\n\n\tif (ampdu || (info->flags & IEEE80211_TX_CTL_AMPDU))\n\t\tinfo->flags |= IEEE80211_TX_STAT_AMPDU | IEEE80211_TX_CTL_AMPDU;\n\n\tfirst_idx = max_t(int, 0, last_idx - (count - 1) / MT7603_RATE_RETRY);\n\n\tif (fixed_rate && !probe) {\n\t\tinfo->status.rates[0].count = count;\n\t\ti = 0;\n\t\tgoto out;\n\t}\n\n\trate_set_tsf = READ_ONCE(sta->rate_set_tsf);\n\trs_idx = !((u32)(le32_get_bits(txs_data[1], MT_TXS1_F0_TIMESTAMP) -\n\t\t\t rate_set_tsf) < 1000000);\n\trs_idx ^= rate_set_tsf & BIT(0);\n\trs = &sta->rateset[rs_idx];\n\n\tif (!first_idx && rs->probe_rate.idx >= 0) {\n\t\tinfo->status.rates[0] = rs->probe_rate;\n\n\t\tspin_lock_bh(&dev->mt76.lock);\n\t\tif (sta->rate_probe) {\n\t\t\tmt7603_wtbl_set_rates(dev, sta, NULL,\n\t\t\t\t\t      sta->rates);\n\t\t\tsta->rate_probe = false;\n\t\t}\n\t\tspin_unlock_bh(&dev->mt76.lock);\n\t} else {\n\t\tinfo->status.rates[0] = rs->rates[first_idx / 2];\n\t}\n\tinfo->status.rates[0].count = 0;\n\n\tfor (i = 0, idx = first_idx; count && idx <= last_idx; idx++) {\n\t\tstruct ieee80211_tx_rate *cur_rate;\n\t\tint cur_count;\n\n\t\tcur_rate = &rs->rates[idx / 2];\n\t\tcur_count = min_t(int, MT7603_RATE_RETRY, count);\n\t\tcount -= cur_count;\n\n\t\tif (idx && (cur_rate->idx != info->status.rates[i].idx ||\n\t\t\t    cur_rate->flags != info->status.rates[i].flags)) {\n\t\t\ti++;\n\t\t\tif (i == ARRAY_SIZE(info->status.rates)) {\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tinfo->status.rates[i] = *cur_rate;\n\t\t\tinfo->status.rates[i].count = 0;\n\t\t}\n\n\t\tinfo->status.rates[i].count += cur_count;\n\t}\n\nout:\n\tfinal_rate_flags = info->status.rates[i].flags;\n\n\tswitch (FIELD_GET(MT_TX_RATE_MODE, final_rate)) {\n\tcase MT_PHY_TYPE_CCK:\n\t\tcck = true;\n\t\tfallthrough;\n\tcase MT_PHY_TYPE_OFDM:\n\t\tif (dev->mphy.chandef.chan->band == NL80211_BAND_5GHZ)\n\t\t\tsband = &dev->mphy.sband_5g.sband;\n\t\telse\n\t\t\tsband = &dev->mphy.sband_2g.sband;\n\t\tfinal_rate &= GENMASK(5, 0);\n\t\tfinal_rate = mt76_get_rate(&dev->mt76, sband, final_rate,\n\t\t\t\t\t   cck);\n\t\tfinal_rate_flags = 0;\n\t\tbreak;\n\tcase MT_PHY_TYPE_HT_GF:\n\tcase MT_PHY_TYPE_HT:\n\t\tfinal_rate_flags |= IEEE80211_TX_RC_MCS;\n\t\tfinal_rate &= GENMASK(5, 0);\n\t\tif (final_rate > 15)\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tinfo->status.rates[i].idx = final_rate;\n\tinfo->status.rates[i].flags = final_rate_flags;\n\n\treturn true;\n}\n\nstatic bool\nmt7603_mac_add_txs_skb(struct mt7603_dev *dev, struct mt7603_sta *sta, int pid,\n\t\t       __le32 *txs_data)\n{\n\tstruct mt76_dev *mdev = &dev->mt76;\n\tstruct sk_buff_head list;\n\tstruct sk_buff *skb;\n\n\tif (pid < MT_PACKET_ID_FIRST)\n\t\treturn false;\n\n\ttrace_mac_txdone(mdev, sta->wcid.idx, pid);\n\n\tmt76_tx_status_lock(mdev, &list);\n\tskb = mt76_tx_status_skb_get(mdev, &sta->wcid, pid, &list);\n\tif (skb) {\n\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\n\t\tif (!mt7603_fill_txs(dev, sta, info, txs_data)) {\n\t\t\tinfo->status.rates[0].count = 0;\n\t\t\tinfo->status.rates[0].idx = -1;\n\t\t}\n\n\t\tmt76_tx_status_skb_done(mdev, skb, &list);\n\t}\n\tmt76_tx_status_unlock(mdev, &list);\n\n\treturn !!skb;\n}\n\nvoid mt7603_mac_add_txs(struct mt7603_dev *dev, void *data)\n{\n\tstruct ieee80211_tx_info info = {};\n\tstruct ieee80211_sta *sta = NULL;\n\tstruct mt7603_sta *msta = NULL;\n\tstruct mt76_wcid *wcid;\n\t__le32 *txs_data = data;\n\tu8 wcidx;\n\tu8 pid;\n\n\tpid = le32_get_bits(txs_data[4], MT_TXS4_PID);\n\twcidx = le32_get_bits(txs_data[3], MT_TXS3_WCID);\n\n\tif (pid == MT_PACKET_ID_NO_ACK)\n\t\treturn;\n\n\tif (wcidx >= MT7603_WTBL_SIZE)\n\t\treturn;\n\n\trcu_read_lock();\n\n\twcid = rcu_dereference(dev->mt76.wcid[wcidx]);\n\tif (!wcid)\n\t\tgoto out;\n\n\tmsta = container_of(wcid, struct mt7603_sta, wcid);\n\tsta = wcid_to_sta(wcid);\n\n\tif (list_empty(&msta->wcid.poll_list)) {\n\t\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\t\tlist_add_tail(&msta->wcid.poll_list, &dev->mt76.sta_poll_list);\n\t\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\t}\n\n\tif (mt7603_mac_add_txs_skb(dev, msta, pid, txs_data))\n\t\tgoto out;\n\n\tif (wcidx >= MT7603_WTBL_STA || !sta)\n\t\tgoto out;\n\n\tif (mt7603_fill_txs(dev, msta, &info, txs_data)) {\n\t\tspin_lock_bh(&dev->mt76.rx_lock);\n\t\tieee80211_tx_status_noskb(mt76_hw(dev), sta, &info);\n\t\tspin_unlock_bh(&dev->mt76.rx_lock);\n\t}\n\nout:\n\trcu_read_unlock();\n}\n\nvoid mt7603_tx_complete_skb(struct mt76_dev *mdev, struct mt76_queue_entry *e)\n{\n\tstruct mt7603_dev *dev = container_of(mdev, struct mt7603_dev, mt76);\n\tstruct sk_buff *skb = e->skb;\n\n\tif (!e->txwi) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\n\tdev->tx_hang_check = 0;\n\tmt76_tx_complete_skb(mdev, e->wcid, skb);\n}\n\nstatic bool\nwait_for_wpdma(struct mt7603_dev *dev)\n{\n\treturn mt76_poll(dev, MT_WPDMA_GLO_CFG,\n\t\t\t MT_WPDMA_GLO_CFG_TX_DMA_BUSY |\n\t\t\t MT_WPDMA_GLO_CFG_RX_DMA_BUSY,\n\t\t\t 0, 1000);\n}\n\nstatic void mt7603_pse_reset(struct mt7603_dev *dev)\n{\n\t \n\tif (!dev->reset_cause[RESET_CAUSE_RESET_FAILED])\n\t\tmt76_clear(dev, MT_MCU_DEBUG_RESET, MT_MCU_DEBUG_RESET_PSE_S);\n\n\t \n\tmt76_set(dev, MT_MCU_DEBUG_RESET, MT_MCU_DEBUG_RESET_PSE);\n\n\tif (!mt76_poll_msec(dev, MT_MCU_DEBUG_RESET,\n\t\t\t    MT_MCU_DEBUG_RESET_PSE_S,\n\t\t\t    MT_MCU_DEBUG_RESET_PSE_S, 500)) {\n\t\tdev->reset_cause[RESET_CAUSE_RESET_FAILED]++;\n\t\tmt76_clear(dev, MT_MCU_DEBUG_RESET, MT_MCU_DEBUG_RESET_PSE);\n\t} else {\n\t\tdev->reset_cause[RESET_CAUSE_RESET_FAILED] = 0;\n\t\tmt76_clear(dev, MT_MCU_DEBUG_RESET, MT_MCU_DEBUG_RESET_QUEUES);\n\t}\n\n\tif (dev->reset_cause[RESET_CAUSE_RESET_FAILED] >= 3)\n\t\tdev->reset_cause[RESET_CAUSE_RESET_FAILED] = 0;\n}\n\nvoid mt7603_mac_dma_start(struct mt7603_dev *dev)\n{\n\tmt7603_mac_start(dev);\n\n\twait_for_wpdma(dev);\n\tusleep_range(50, 100);\n\n\tmt76_set(dev, MT_WPDMA_GLO_CFG,\n\t\t (MT_WPDMA_GLO_CFG_TX_DMA_EN |\n\t\t  MT_WPDMA_GLO_CFG_RX_DMA_EN |\n\t\t  FIELD_PREP(MT_WPDMA_GLO_CFG_DMA_BURST_SIZE, 3) |\n\t\t  MT_WPDMA_GLO_CFG_TX_WRITEBACK_DONE));\n\n\tmt7603_irq_enable(dev, MT_INT_RX_DONE_ALL | MT_INT_TX_DONE_ALL);\n}\n\nvoid mt7603_mac_start(struct mt7603_dev *dev)\n{\n\tmt76_clear(dev, MT_ARB_SCR,\n\t\t   MT_ARB_SCR_TX_DISABLE | MT_ARB_SCR_RX_DISABLE);\n\tmt76_wr(dev, MT_WF_ARB_TX_START_0, ~0);\n\tmt76_set(dev, MT_WF_ARB_RQCR, MT_WF_ARB_RQCR_RX_START);\n}\n\nvoid mt7603_mac_stop(struct mt7603_dev *dev)\n{\n\tmt76_set(dev, MT_ARB_SCR,\n\t\t MT_ARB_SCR_TX_DISABLE | MT_ARB_SCR_RX_DISABLE);\n\tmt76_wr(dev, MT_WF_ARB_TX_START_0, 0);\n\tmt76_clear(dev, MT_WF_ARB_RQCR, MT_WF_ARB_RQCR_RX_START);\n}\n\nvoid mt7603_pse_client_reset(struct mt7603_dev *dev)\n{\n\tu32 addr;\n\n\taddr = mt7603_reg_map(dev, MT_CLIENT_BASE_PHYS_ADDR +\n\t\t\t\t   MT_CLIENT_RESET_TX);\n\n\t \n\tmt76_clear(dev, addr,\n\t\t   MT_CLIENT_RESET_TX_R_E_1 |\n\t\t   MT_CLIENT_RESET_TX_R_E_2 |\n\t\t   MT_CLIENT_RESET_TX_R_E_1_S |\n\t\t   MT_CLIENT_RESET_TX_R_E_2_S);\n\n\t \n\tmt76_set(dev, addr, MT_CLIENT_RESET_TX_R_E_1);\n\tmt76_poll_msec(dev, addr, MT_CLIENT_RESET_TX_R_E_1_S,\n\t\t       MT_CLIENT_RESET_TX_R_E_1_S, 500);\n\n\tmt76_set(dev, addr, MT_CLIENT_RESET_TX_R_E_2);\n\tmt76_set(dev, MT_WPDMA_GLO_CFG, MT_WPDMA_GLO_CFG_SW_RESET);\n\n\t \n\tmt76_poll_msec(dev, addr, MT_CLIENT_RESET_TX_R_E_2_S,\n\t\t       MT_CLIENT_RESET_TX_R_E_2_S, 500);\n\n\t \n\tmt76_clear(dev, addr,\n\t\t   MT_CLIENT_RESET_TX_R_E_1 |\n\t\t   MT_CLIENT_RESET_TX_R_E_2);\n}\n\nstatic void mt7603_dma_sched_reset(struct mt7603_dev *dev)\n{\n\tif (!is_mt7628(dev))\n\t\treturn;\n\n\tmt76_set(dev, MT_SCH_4, MT_SCH_4_RESET);\n\tmt76_clear(dev, MT_SCH_4, MT_SCH_4_RESET);\n}\n\nstatic void mt7603_mac_watchdog_reset(struct mt7603_dev *dev)\n{\n\tint beacon_int = dev->mt76.beacon_int;\n\tu32 mask = dev->mt76.mmio.irqmask;\n\tint i;\n\n\tieee80211_stop_queues(dev->mt76.hw);\n\tset_bit(MT76_RESET, &dev->mphy.state);\n\n\t \n\tmt76_txq_schedule_all(&dev->mphy);\n\n\tmt76_worker_disable(&dev->mt76.tx_worker);\n\ttasklet_disable(&dev->mt76.pre_tbtt_tasklet);\n\tnapi_disable(&dev->mt76.napi[0]);\n\tnapi_disable(&dev->mt76.napi[1]);\n\tnapi_disable(&dev->mt76.tx_napi);\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tmt7603_beacon_set_timer(dev, -1, 0);\n\n\tmt7603_mac_stop(dev);\n\n\tmt76_clear(dev, MT_WPDMA_GLO_CFG,\n\t\t   MT_WPDMA_GLO_CFG_RX_DMA_EN | MT_WPDMA_GLO_CFG_TX_DMA_EN |\n\t\t   MT_WPDMA_GLO_CFG_TX_WRITEBACK_DONE);\n\tusleep_range(1000, 2000);\n\n\tmt7603_irq_disable(dev, mask);\n\n\tmt7603_pse_client_reset(dev);\n\n\tmt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[MT_MCUQ_WM], true);\n\tfor (i = 0; i < __MT_TXQ_MAX; i++)\n\t\tmt76_queue_tx_cleanup(dev, dev->mphy.q_tx[i], true);\n\n\tmt7603_dma_sched_reset(dev);\n\n\tmt76_tx_status_check(&dev->mt76, true);\n\n\tmt76_for_each_q_rx(&dev->mt76, i) {\n\t\tmt76_queue_rx_reset(dev, i);\n\t}\n\n\tif (dev->reset_cause[RESET_CAUSE_RESET_FAILED] ||\n\t    dev->cur_reset_cause == RESET_CAUSE_RX_PSE_BUSY)\n\t\tmt7603_pse_reset(dev);\n\n\tif (!dev->reset_cause[RESET_CAUSE_RESET_FAILED]) {\n\t\tmt7603_mac_dma_start(dev);\n\n\t\tmt7603_irq_enable(dev, mask);\n\n\t\tclear_bit(MT76_RESET, &dev->mphy.state);\n\t}\n\n\tmutex_unlock(&dev->mt76.mutex);\n\n\tmt76_worker_enable(&dev->mt76.tx_worker);\n\n\ttasklet_enable(&dev->mt76.pre_tbtt_tasklet);\n\tmt7603_beacon_set_timer(dev, -1, beacon_int);\n\n\tlocal_bh_disable();\n\tnapi_enable(&dev->mt76.tx_napi);\n\tnapi_schedule(&dev->mt76.tx_napi);\n\n\tnapi_enable(&dev->mt76.napi[0]);\n\tnapi_schedule(&dev->mt76.napi[0]);\n\n\tnapi_enable(&dev->mt76.napi[1]);\n\tnapi_schedule(&dev->mt76.napi[1]);\n\tlocal_bh_enable();\n\n\tieee80211_wake_queues(dev->mt76.hw);\n\tmt76_txq_schedule_all(&dev->mphy);\n}\n\nstatic u32 mt7603_dma_debug(struct mt7603_dev *dev, u8 index)\n{\n\tu32 val;\n\n\tmt76_wr(dev, MT_WPDMA_DEBUG,\n\t\tFIELD_PREP(MT_WPDMA_DEBUG_IDX, index) |\n\t\tMT_WPDMA_DEBUG_SEL);\n\n\tval = mt76_rr(dev, MT_WPDMA_DEBUG);\n\treturn FIELD_GET(MT_WPDMA_DEBUG_VALUE, val);\n}\n\nstatic bool mt7603_rx_fifo_busy(struct mt7603_dev *dev)\n{\n\tif (is_mt7628(dev))\n\t\treturn mt7603_dma_debug(dev, 9) & BIT(9);\n\n\treturn mt7603_dma_debug(dev, 2) & BIT(8);\n}\n\nstatic bool mt7603_rx_dma_busy(struct mt7603_dev *dev)\n{\n\tif (!(mt76_rr(dev, MT_WPDMA_GLO_CFG) & MT_WPDMA_GLO_CFG_RX_DMA_BUSY))\n\t\treturn false;\n\n\treturn mt7603_rx_fifo_busy(dev);\n}\n\nstatic bool mt7603_tx_dma_busy(struct mt7603_dev *dev)\n{\n\tu32 val;\n\n\tif (!(mt76_rr(dev, MT_WPDMA_GLO_CFG) & MT_WPDMA_GLO_CFG_TX_DMA_BUSY))\n\t\treturn false;\n\n\tval = mt7603_dma_debug(dev, 9);\n\treturn (val & BIT(8)) && (val & 0xf) != 0xf;\n}\n\nstatic bool mt7603_tx_hang(struct mt7603_dev *dev)\n{\n\tstruct mt76_queue *q;\n\tu32 dma_idx, prev_dma_idx;\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tq = dev->mphy.q_tx[i];\n\n\t\tif (!q->queued)\n\t\t\tcontinue;\n\n\t\tprev_dma_idx = dev->tx_dma_idx[i];\n\t\tdma_idx = readl(&q->regs->dma_idx);\n\t\tdev->tx_dma_idx[i] = dma_idx;\n\n\t\tif (dma_idx == prev_dma_idx &&\n\t\t    dma_idx != readl(&q->regs->cpu_idx))\n\t\t\tbreak;\n\t}\n\n\treturn i < 4;\n}\n\nstatic bool mt7603_rx_pse_busy(struct mt7603_dev *dev)\n{\n\tu32 addr, val;\n\n\tif (mt7603_rx_fifo_busy(dev))\n\t\tgoto out;\n\n\taddr = mt7603_reg_map(dev, MT_CLIENT_BASE_PHYS_ADDR + MT_CLIENT_STATUS);\n\tmt76_wr(dev, addr, 3);\n\tval = mt76_rr(dev, addr) >> 16;\n\n\tif (!(val & BIT(0)))\n\t\treturn false;\n\n\tif (is_mt7628(dev))\n\t\tval &= 0xa000;\n\telse\n\t\tval &= 0x8000;\n\tif (!val)\n\t\treturn false;\n\nout:\n\tif (mt76_rr(dev, MT_INT_SOURCE_CSR) &\n\t    (MT_INT_RX_DONE(0) | MT_INT_RX_DONE(1)))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\nmt7603_watchdog_check(struct mt7603_dev *dev, u8 *counter,\n\t\t      enum mt7603_reset_cause cause,\n\t\t      bool (*check)(struct mt7603_dev *dev))\n{\n\tif (dev->reset_test == cause + 1) {\n\t\tdev->reset_test = 0;\n\t\tgoto trigger;\n\t}\n\n\tif (check) {\n\t\tif (!check(dev) && *counter < MT7603_WATCHDOG_TIMEOUT) {\n\t\t\t*counter = 0;\n\t\t\treturn false;\n\t\t}\n\n\t\t(*counter)++;\n\t}\n\n\tif (*counter < MT7603_WATCHDOG_TIMEOUT)\n\t\treturn false;\ntrigger:\n\tdev->cur_reset_cause = cause;\n\tdev->reset_cause[cause]++;\n\treturn true;\n}\n\nvoid mt7603_update_channel(struct mt76_phy *mphy)\n{\n\tstruct mt7603_dev *dev = container_of(mphy->dev, struct mt7603_dev, mt76);\n\tstruct mt76_channel_state *state;\n\n\tstate = mphy->chan_state;\n\tstate->cc_busy += mt76_rr(dev, MT_MIB_STAT_CCA);\n}\n\nvoid\nmt7603_edcca_set_strict(struct mt7603_dev *dev, bool val)\n{\n\tu32 rxtd_6 = 0xd7c80000;\n\n\tif (val == dev->ed_strict_mode)\n\t\treturn;\n\n\tdev->ed_strict_mode = val;\n\n\t \n\tif (!dev->ed_monitor)\n\t\trxtd_6 |= FIELD_PREP(MT_RXTD_6_CCAED_TH, 0x34);\n\telse\n\t\trxtd_6 |= FIELD_PREP(MT_RXTD_6_CCAED_TH, 0x7d);\n\n\tif (dev->ed_monitor && !dev->ed_strict_mode)\n\t\trxtd_6 |= FIELD_PREP(MT_RXTD_6_ACI_TH, 0x0f);\n\telse\n\t\trxtd_6 |= FIELD_PREP(MT_RXTD_6_ACI_TH, 0x10);\n\n\tmt76_wr(dev, MT_RXTD(6), rxtd_6);\n\n\tmt76_rmw_field(dev, MT_RXTD(13), MT_RXTD_13_ACI_TH_EN,\n\t\t       dev->ed_monitor && !dev->ed_strict_mode);\n}\n\nstatic void\nmt7603_edcca_check(struct mt7603_dev *dev)\n{\n\tu32 val = mt76_rr(dev, MT_AGC(41));\n\tktime_t cur_time;\n\tint rssi0, rssi1;\n\tu32 active;\n\tu32 ed_busy;\n\n\tif (!dev->ed_monitor)\n\t\treturn;\n\n\trssi0 = FIELD_GET(MT_AGC_41_RSSI_0, val);\n\tif (rssi0 > 128)\n\t\trssi0 -= 256;\n\n\tif (dev->mphy.antenna_mask & BIT(1)) {\n\t\trssi1 = FIELD_GET(MT_AGC_41_RSSI_1, val);\n\t\tif (rssi1 > 128)\n\t\t\trssi1 -= 256;\n\t} else {\n\t\trssi1 = rssi0;\n\t}\n\n\tif (max(rssi0, rssi1) >= -40 &&\n\t    dev->ed_strong_signal < MT7603_EDCCA_BLOCK_TH)\n\t\tdev->ed_strong_signal++;\n\telse if (dev->ed_strong_signal > 0)\n\t\tdev->ed_strong_signal--;\n\n\tcur_time = ktime_get_boottime();\n\ted_busy = mt76_rr(dev, MT_MIB_STAT_ED) & MT_MIB_STAT_ED_MASK;\n\n\tactive = ktime_to_us(ktime_sub(cur_time, dev->ed_time));\n\tdev->ed_time = cur_time;\n\n\tif (!active)\n\t\treturn;\n\n\tif (100 * ed_busy / active > 90) {\n\t\tif (dev->ed_trigger < 0)\n\t\t\tdev->ed_trigger = 0;\n\t\tdev->ed_trigger++;\n\t} else {\n\t\tif (dev->ed_trigger > 0)\n\t\t\tdev->ed_trigger = 0;\n\t\tdev->ed_trigger--;\n\t}\n\n\tif (dev->ed_trigger > MT7603_EDCCA_BLOCK_TH ||\n\t    dev->ed_strong_signal < MT7603_EDCCA_BLOCK_TH / 2) {\n\t\tmt7603_edcca_set_strict(dev, true);\n\t} else if (dev->ed_trigger < -MT7603_EDCCA_BLOCK_TH) {\n\t\tmt7603_edcca_set_strict(dev, false);\n\t}\n\n\tif (dev->ed_trigger > MT7603_EDCCA_BLOCK_TH)\n\t\tdev->ed_trigger = MT7603_EDCCA_BLOCK_TH;\n\telse if (dev->ed_trigger < -MT7603_EDCCA_BLOCK_TH)\n\t\tdev->ed_trigger = -MT7603_EDCCA_BLOCK_TH;\n}\n\nvoid mt7603_cca_stats_reset(struct mt7603_dev *dev)\n{\n\tmt76_set(dev, MT_PHYCTRL(2), MT_PHYCTRL_2_STATUS_RESET);\n\tmt76_clear(dev, MT_PHYCTRL(2), MT_PHYCTRL_2_STATUS_RESET);\n\tmt76_set(dev, MT_PHYCTRL(2), MT_PHYCTRL_2_STATUS_EN);\n}\n\nstatic void\nmt7603_adjust_sensitivity(struct mt7603_dev *dev)\n{\n\tu32 agc0 = dev->agc0, agc3 = dev->agc3;\n\tu32 adj;\n\n\tif (!dev->sensitivity || dev->sensitivity < -100) {\n\t\tdev->sensitivity = 0;\n\t} else if (dev->sensitivity <= -84) {\n\t\tadj = 7 + (dev->sensitivity + 92) / 2;\n\n\t\tagc0 = 0x56f0076f;\n\t\tagc0 |= adj << 12;\n\t\tagc0 |= adj << 16;\n\t\tagc3 = 0x81d0d5e3;\n\t} else if (dev->sensitivity <= -72) {\n\t\tadj = 7 + (dev->sensitivity + 80) / 2;\n\n\t\tagc0 = 0x6af0006f;\n\t\tagc0 |= adj << 8;\n\t\tagc0 |= adj << 12;\n\t\tagc0 |= adj << 16;\n\n\t\tagc3 = 0x8181d5e3;\n\t} else {\n\t\tif (dev->sensitivity > -54)\n\t\t\tdev->sensitivity = -54;\n\n\t\tadj = 7 + (dev->sensitivity + 80) / 2;\n\n\t\tagc0 = 0x7ff0000f;\n\t\tagc0 |= adj << 4;\n\t\tagc0 |= adj << 8;\n\t\tagc0 |= adj << 12;\n\t\tagc0 |= adj << 16;\n\n\t\tagc3 = 0x818181e3;\n\t}\n\n\tmt76_wr(dev, MT_AGC(0), agc0);\n\tmt76_wr(dev, MT_AGC1(0), agc0);\n\n\tmt76_wr(dev, MT_AGC(3), agc3);\n\tmt76_wr(dev, MT_AGC1(3), agc3);\n}\n\nstatic void\nmt7603_false_cca_check(struct mt7603_dev *dev)\n{\n\tint pd_cck, pd_ofdm, mdrdy_cck, mdrdy_ofdm;\n\tint false_cca;\n\tint min_signal;\n\tu32 val;\n\n\tif (!dev->dynamic_sensitivity)\n\t\treturn;\n\n\tval = mt76_rr(dev, MT_PHYCTRL_STAT_PD);\n\tpd_cck = FIELD_GET(MT_PHYCTRL_STAT_PD_CCK, val);\n\tpd_ofdm = FIELD_GET(MT_PHYCTRL_STAT_PD_OFDM, val);\n\n\tval = mt76_rr(dev, MT_PHYCTRL_STAT_MDRDY);\n\tmdrdy_cck = FIELD_GET(MT_PHYCTRL_STAT_MDRDY_CCK, val);\n\tmdrdy_ofdm = FIELD_GET(MT_PHYCTRL_STAT_MDRDY_OFDM, val);\n\n\tdev->false_cca_ofdm = pd_ofdm - mdrdy_ofdm;\n\tdev->false_cca_cck = pd_cck - mdrdy_cck;\n\n\tmt7603_cca_stats_reset(dev);\n\n\tmin_signal = mt76_get_min_avg_rssi(&dev->mt76, false);\n\tif (!min_signal) {\n\t\tdev->sensitivity = 0;\n\t\tdev->last_cca_adj = jiffies;\n\t\tgoto out;\n\t}\n\n\tmin_signal -= 15;\n\n\tfalse_cca = dev->false_cca_ofdm + dev->false_cca_cck;\n\tif (false_cca > 600 &&\n\t    dev->sensitivity < -100 + dev->sensitivity_limit) {\n\t\tif (!dev->sensitivity)\n\t\t\tdev->sensitivity = -92;\n\t\telse\n\t\t\tdev->sensitivity += 2;\n\t\tdev->last_cca_adj = jiffies;\n\t} else if (false_cca < 100 ||\n\t\t   time_after(jiffies, dev->last_cca_adj + 10 * HZ)) {\n\t\tdev->last_cca_adj = jiffies;\n\t\tif (!dev->sensitivity)\n\t\t\tgoto out;\n\n\t\tdev->sensitivity -= 2;\n\t}\n\n\tif (dev->sensitivity && dev->sensitivity > min_signal) {\n\t\tdev->sensitivity = min_signal;\n\t\tdev->last_cca_adj = jiffies;\n\t}\n\nout:\n\tmt7603_adjust_sensitivity(dev);\n}\n\nvoid mt7603_mac_work(struct work_struct *work)\n{\n\tstruct mt7603_dev *dev = container_of(work, struct mt7603_dev,\n\t\t\t\t\t      mphy.mac_work.work);\n\tbool reset = false;\n\tint i, idx;\n\n\tmt76_tx_status_check(&dev->mt76, false);\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tdev->mphy.mac_work_count++;\n\tmt76_update_survey(&dev->mphy);\n\tmt7603_edcca_check(dev);\n\n\tfor (i = 0, idx = 0; i < 2; i++) {\n\t\tu32 val = mt76_rr(dev, MT_TX_AGG_CNT(i));\n\n\t\tdev->mphy.aggr_stats[idx++] += val & 0xffff;\n\t\tdev->mphy.aggr_stats[idx++] += val >> 16;\n\t}\n\n\tif (dev->mphy.mac_work_count == 10)\n\t\tmt7603_false_cca_check(dev);\n\n\tif (mt7603_watchdog_check(dev, &dev->rx_pse_check,\n\t\t\t\t  RESET_CAUSE_RX_PSE_BUSY,\n\t\t\t\t  mt7603_rx_pse_busy) ||\n\t    mt7603_watchdog_check(dev, &dev->beacon_check,\n\t\t\t\t  RESET_CAUSE_BEACON_STUCK,\n\t\t\t\t  NULL) ||\n\t    mt7603_watchdog_check(dev, &dev->tx_hang_check,\n\t\t\t\t  RESET_CAUSE_TX_HANG,\n\t\t\t\t  mt7603_tx_hang) ||\n\t    mt7603_watchdog_check(dev, &dev->tx_dma_check,\n\t\t\t\t  RESET_CAUSE_TX_BUSY,\n\t\t\t\t  mt7603_tx_dma_busy) ||\n\t    mt7603_watchdog_check(dev, &dev->rx_dma_check,\n\t\t\t\t  RESET_CAUSE_RX_BUSY,\n\t\t\t\t  mt7603_rx_dma_busy) ||\n\t    mt7603_watchdog_check(dev, &dev->mcu_hang,\n\t\t\t\t  RESET_CAUSE_MCU_HANG,\n\t\t\t\t  NULL) ||\n\t    dev->reset_cause[RESET_CAUSE_RESET_FAILED]) {\n\t\tdev->beacon_check = 0;\n\t\tdev->tx_dma_check = 0;\n\t\tdev->tx_hang_check = 0;\n\t\tdev->rx_dma_check = 0;\n\t\tdev->rx_pse_check = 0;\n\t\tdev->mcu_hang = 0;\n\t\tdev->rx_dma_idx = ~0;\n\t\tmemset(dev->tx_dma_idx, 0xff, sizeof(dev->tx_dma_idx));\n\t\treset = true;\n\t\tdev->mphy.mac_work_count = 0;\n\t}\n\n\tif (dev->mphy.mac_work_count >= 10)\n\t\tdev->mphy.mac_work_count = 0;\n\n\tmutex_unlock(&dev->mt76.mutex);\n\n\tif (reset)\n\t\tmt7603_mac_watchdog_reset(dev);\n\n\tieee80211_queue_delayed_work(mt76_hw(dev), &dev->mphy.mac_work,\n\t\t\t\t     msecs_to_jiffies(MT7603_WATCHDOG_TIME));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}