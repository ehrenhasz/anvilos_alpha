{
  "module_name": "dma.c",
  "hash_id": "e6b28ca146d177c710ab9d776b347067cd5a05334445e99fb1dc16179b485d17",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7603/dma.c",
  "human_readable_source": "\n\n#include \"mt7603.h\"\n#include \"mac.h\"\n#include \"../dma.h\"\n\nstatic void\nmt7603_rx_loopback_skb(struct mt7603_dev *dev, struct sk_buff *skb)\n{\n\tstatic const u8 tid_to_ac[8] = {\n\t\tIEEE80211_AC_BE,\n\t\tIEEE80211_AC_BK,\n\t\tIEEE80211_AC_BK,\n\t\tIEEE80211_AC_BE,\n\t\tIEEE80211_AC_VI,\n\t\tIEEE80211_AC_VI,\n\t\tIEEE80211_AC_VO,\n\t\tIEEE80211_AC_VO\n\t};\n\t__le32 *txd = (__le32 *)skb->data;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_sta *sta;\n\tstruct mt7603_sta *msta;\n\tstruct mt76_wcid *wcid;\n\tvoid *priv;\n\tint idx;\n\tu32 val;\n\tu8 tid = 0;\n\n\tif (skb->len < MT_TXD_SIZE + sizeof(struct ieee80211_hdr))\n\t\tgoto free;\n\n\tval = le32_to_cpu(txd[1]);\n\tidx = FIELD_GET(MT_TXD1_WLAN_IDX, val);\n\tskb->priority = FIELD_GET(MT_TXD1_TID, val);\n\n\tif (idx >= MT7603_WTBL_STA - 1)\n\t\tgoto free;\n\n\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n\tif (!wcid)\n\t\tgoto free;\n\n\tpriv = msta = container_of(wcid, struct mt7603_sta, wcid);\n\tval = le32_to_cpu(txd[0]);\n\tval &= ~(MT_TXD0_P_IDX | MT_TXD0_Q_IDX);\n\tval |= FIELD_PREP(MT_TXD0_Q_IDX, MT_TX_HW_QUEUE_MGMT);\n\ttxd[0] = cpu_to_le32(val);\n\n\tsta = container_of(priv, struct ieee80211_sta, drv_priv);\n\thdr = (struct ieee80211_hdr *)&skb->data[MT_TXD_SIZE];\n\tif (ieee80211_is_data_qos(hdr->frame_control))\n\t\ttid = *ieee80211_get_qos_ctl(hdr) &\n\t\t      IEEE80211_QOS_CTL_TAG1D_MASK;\n\tskb_set_queue_mapping(skb, tid_to_ac[tid]);\n\tieee80211_sta_set_buffered(sta, tid, true);\n\n\tspin_lock_bh(&dev->ps_lock);\n\t__skb_queue_tail(&msta->psq, skb);\n\tif (skb_queue_len(&msta->psq) >= 64) {\n\t\tskb = __skb_dequeue(&msta->psq);\n\t\tdev_kfree_skb(skb);\n\t}\n\tspin_unlock_bh(&dev->ps_lock);\n\treturn;\n\nfree:\n\tdev_kfree_skb(skb);\n}\n\nvoid mt7603_queue_rx_skb(struct mt76_dev *mdev, enum mt76_rxq_id q,\n\t\t\t struct sk_buff *skb, u32 *info)\n{\n\tstruct mt7603_dev *dev = container_of(mdev, struct mt7603_dev, mt76);\n\t__le32 *rxd = (__le32 *)skb->data;\n\t__le32 *end = (__le32 *)&skb->data[skb->len];\n\tenum rx_pkt_type type;\n\n\ttype = le32_get_bits(rxd[0], MT_RXD0_PKT_TYPE);\n\n\tif (q == MT_RXQ_MCU) {\n\t\tif (type == PKT_TYPE_RX_EVENT)\n\t\t\tmt76_mcu_rx_event(&dev->mt76, skb);\n\t\telse\n\t\t\tmt7603_rx_loopback_skb(dev, skb);\n\t\treturn;\n\t}\n\n\tswitch (type) {\n\tcase PKT_TYPE_TXS:\n\t\tfor (rxd++; rxd + 5 <= end; rxd += 5)\n\t\t\tmt7603_mac_add_txs(dev, rxd);\n\t\tdev_kfree_skb(skb);\n\t\tbreak;\n\tcase PKT_TYPE_RX_EVENT:\n\t\tmt76_mcu_rx_event(&dev->mt76, skb);\n\t\treturn;\n\tcase PKT_TYPE_NORMAL:\n\t\tif (mt7603_mac_fill_rx(dev, skb) == 0) {\n\t\t\tmt76_rx(&dev->mt76, q, skb);\n\t\t\treturn;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdev_kfree_skb(skb);\n\t\tbreak;\n\t}\n}\n\nstatic int\nmt7603_init_rx_queue(struct mt7603_dev *dev, struct mt76_queue *q,\n\t\t     int idx, int n_desc, int bufsize)\n{\n\tint err;\n\n\terr = mt76_queue_alloc(dev, q, idx, n_desc, bufsize,\n\t\t\t       MT_RX_RING_BASE);\n\tif (err < 0)\n\t\treturn err;\n\n\tmt7603_irq_enable(dev, MT_INT_RX_DONE(idx));\n\n\treturn 0;\n}\n\nstatic int mt7603_poll_tx(struct napi_struct *napi, int budget)\n{\n\tstruct mt7603_dev *dev;\n\tint i;\n\n\tdev = container_of(napi, struct mt7603_dev, mt76.tx_napi);\n\tdev->tx_dma_check = 0;\n\n\tmt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[MT_MCUQ_WM], false);\n\tfor (i = MT_TXQ_PSD; i >= 0; i--)\n\t\tmt76_queue_tx_cleanup(dev, dev->mphy.q_tx[i], false);\n\n\tif (napi_complete_done(napi, 0))\n\t\tmt7603_irq_enable(dev, MT_INT_TX_DONE_ALL);\n\n\tmt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[MT_MCUQ_WM], false);\n\tfor (i = MT_TXQ_PSD; i >= 0; i--)\n\t\tmt76_queue_tx_cleanup(dev, dev->mphy.q_tx[i], false);\n\n\tmt7603_mac_sta_poll(dev);\n\n\tmt76_worker_schedule(&dev->mt76.tx_worker);\n\n\treturn 0;\n}\n\nint mt7603_dma_init(struct mt7603_dev *dev)\n{\n\tstatic const u8 wmm_queue_map[] = {\n\t\t[IEEE80211_AC_BK] = 0,\n\t\t[IEEE80211_AC_BE] = 1,\n\t\t[IEEE80211_AC_VI] = 2,\n\t\t[IEEE80211_AC_VO] = 3,\n\t};\n\tint ret;\n\tint i;\n\n\tmt76_dma_attach(&dev->mt76);\n\n\tmt76_clear(dev, MT_WPDMA_GLO_CFG,\n\t\t   MT_WPDMA_GLO_CFG_TX_DMA_EN |\n\t\t   MT_WPDMA_GLO_CFG_RX_DMA_EN |\n\t\t   MT_WPDMA_GLO_CFG_DMA_BURST_SIZE |\n\t\t   MT_WPDMA_GLO_CFG_TX_WRITEBACK_DONE);\n\n\tmt76_wr(dev, MT_WPDMA_RST_IDX, ~0);\n\tmt7603_pse_client_reset(dev);\n\n\tfor (i = 0; i < ARRAY_SIZE(wmm_queue_map); i++) {\n\t\tret = mt76_init_tx_queue(&dev->mphy, i, wmm_queue_map[i],\n\t\t\t\t\t MT7603_TX_RING_SIZE, MT_TX_RING_BASE, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = mt76_init_tx_queue(&dev->mphy, MT_TXQ_PSD, MT_TX_HW_QUEUE_MGMT,\n\t\t\t\t MT7603_PSD_RING_SIZE, MT_TX_RING_BASE, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt76_init_mcu_queue(&dev->mt76, MT_MCUQ_WM, MT_TX_HW_QUEUE_MCU,\n\t\t\t\t  MT_MCU_RING_SIZE, MT_TX_RING_BASE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt76_init_tx_queue(&dev->mphy, MT_TXQ_BEACON, MT_TX_HW_QUEUE_BCN,\n\t\t\t\t MT_MCU_RING_SIZE, MT_TX_RING_BASE, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt76_init_tx_queue(&dev->mphy, MT_TXQ_CAB, MT_TX_HW_QUEUE_BMC,\n\t\t\t\t MT_MCU_RING_SIZE, MT_TX_RING_BASE, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tmt7603_irq_enable(dev,\n\t\t\t  MT_INT_TX_DONE(IEEE80211_AC_VO) |\n\t\t\t  MT_INT_TX_DONE(IEEE80211_AC_VI) |\n\t\t\t  MT_INT_TX_DONE(IEEE80211_AC_BE) |\n\t\t\t  MT_INT_TX_DONE(IEEE80211_AC_BK) |\n\t\t\t  MT_INT_TX_DONE(MT_TX_HW_QUEUE_MGMT) |\n\t\t\t  MT_INT_TX_DONE(MT_TX_HW_QUEUE_MCU) |\n\t\t\t  MT_INT_TX_DONE(MT_TX_HW_QUEUE_BCN) |\n\t\t\t  MT_INT_TX_DONE(MT_TX_HW_QUEUE_BMC));\n\n\tret = mt7603_init_rx_queue(dev, &dev->mt76.q_rx[MT_RXQ_MCU], 1,\n\t\t\t\t   MT7603_MCU_RX_RING_SIZE, MT_RX_BUF_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7603_init_rx_queue(dev, &dev->mt76.q_rx[MT_RXQ_MAIN], 0,\n\t\t\t\t   MT7603_RX_RING_SIZE, MT_RX_BUF_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\tmt76_wr(dev, MT_DELAY_INT_CFG, 0);\n\tret = mt76_init_queues(dev, mt76_dma_rx_poll);\n\tif (ret)\n\t\treturn ret;\n\n\tnetif_napi_add_tx(&dev->mt76.tx_napi_dev, &dev->mt76.tx_napi,\n\t\t\t  mt7603_poll_tx);\n\tnapi_enable(&dev->mt76.tx_napi);\n\n\treturn 0;\n}\n\nvoid mt7603_dma_cleanup(struct mt7603_dev *dev)\n{\n\tmt76_clear(dev, MT_WPDMA_GLO_CFG,\n\t\t   MT_WPDMA_GLO_CFG_TX_DMA_EN |\n\t\t   MT_WPDMA_GLO_CFG_RX_DMA_EN |\n\t\t   MT_WPDMA_GLO_CFG_TX_WRITEBACK_DONE);\n\n\tmt76_dma_cleanup(&dev->mt76);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}