{
  "module_name": "mt76x02_mcu.c",
  "hash_id": "fe0ea7f8ab2679cdabb2698a921b22eaadf7ea1d47c9f8c4c8e776b00cf2550c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt76x02_mcu.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/firmware.h>\n#include <linux/delay.h>\n\n#include \"mt76x02_mcu.h\"\n\nint mt76x02_mcu_parse_response(struct mt76_dev *mdev, int cmd,\n\t\t\t       struct sk_buff *skb, int seq)\n{\n\tstruct mt76x02_dev *dev = container_of(mdev, struct mt76x02_dev, mt76);\n\tu32 *rxfce;\n\n\tif (!skb) {\n\t\tdev_err(mdev->dev, \"MCU message %02x (seq %d) timed out\\n\",\n\t\t\tabs(cmd), seq);\n\t\tdev->mcu_timeout = 1;\n\t\treturn -ETIMEDOUT;\n\t}\n\n\trxfce = (u32 *)skb->cb;\n\tif (seq != FIELD_GET(MT_RX_FCE_INFO_CMD_SEQ, *rxfce))\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76x02_mcu_parse_response);\n\nint mt76x02_mcu_msg_send(struct mt76_dev *mdev, int cmd, const void *data,\n\t\t\t int len, bool wait_resp)\n{\n\tstruct mt76x02_dev *dev = container_of(mdev, struct mt76x02_dev, mt76);\n\tunsigned long expires = jiffies + HZ;\n\tstruct sk_buff *skb;\n\tu32 tx_info;\n\tint ret;\n\tu8 seq;\n\n\tif (dev->mcu_timeout)\n\t\treturn -EIO;\n\n\tskb = mt76_mcu_msg_alloc(mdev, data, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&mdev->mcu.mutex);\n\n\tseq = ++mdev->mcu.msg_seq & 0xf;\n\tif (!seq)\n\t\tseq = ++mdev->mcu.msg_seq & 0xf;\n\n\ttx_info = MT_MCU_MSG_TYPE_CMD |\n\t\t  FIELD_PREP(MT_MCU_MSG_CMD_TYPE, cmd) |\n\t\t  FIELD_PREP(MT_MCU_MSG_CMD_SEQ, seq) |\n\t\t  FIELD_PREP(MT_MCU_MSG_PORT, CPU_TX_PORT) |\n\t\t  FIELD_PREP(MT_MCU_MSG_LEN, skb->len);\n\n\tret = mt76_tx_queue_skb_raw(dev, mdev->q_mcu[MT_MCUQ_WM], skb, tx_info);\n\tif (ret)\n\t\tgoto out;\n\n\twhile (wait_resp) {\n\t\tskb = mt76_mcu_get_response(&dev->mt76, expires);\n\t\tret = mt76x02_mcu_parse_response(mdev, cmd, skb, seq);\n\t\tdev_kfree_skb(skb);\n\t\tif (ret != -EAGAIN)\n\t\t\tbreak;\n\t}\n\nout:\n\tmutex_unlock(&mdev->mcu.mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mt76x02_mcu_msg_send);\n\nint mt76x02_mcu_function_select(struct mt76x02_dev *dev, enum mcu_function func,\n\t\t\t\tu32 val)\n{\n\tstruct {\n\t\t__le32 id;\n\t\t__le32 value;\n\t} __packed __aligned(4) msg = {\n\t\t.id = cpu_to_le32(func),\n\t\t.value = cpu_to_le32(val),\n\t};\n\tbool wait = false;\n\n\tif (func != Q_SELECT)\n\t\twait = true;\n\n\treturn mt76_mcu_send_msg(&dev->mt76, CMD_FUN_SET_OP, &msg,\n\t\t\t\t sizeof(msg), wait);\n}\nEXPORT_SYMBOL_GPL(mt76x02_mcu_function_select);\n\nint mt76x02_mcu_set_radio_state(struct mt76x02_dev *dev, bool on)\n{\n\tstruct {\n\t\t__le32 mode;\n\t\t__le32 level;\n\t} __packed __aligned(4) msg = {\n\t\t.mode = cpu_to_le32(on ? RADIO_ON : RADIO_OFF),\n\t\t.level = cpu_to_le32(0),\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, CMD_POWER_SAVING_OP, &msg,\n\t\t\t\t sizeof(msg), false);\n}\nEXPORT_SYMBOL_GPL(mt76x02_mcu_set_radio_state);\n\nint mt76x02_mcu_calibrate(struct mt76x02_dev *dev, int type, u32 param)\n{\n\tstruct {\n\t\t__le32 id;\n\t\t__le32 value;\n\t} __packed __aligned(4) msg = {\n\t\t.id = cpu_to_le32(type),\n\t\t.value = cpu_to_le32(param),\n\t};\n\tbool is_mt76x2e = mt76_is_mmio(&dev->mt76) && is_mt76x2(dev);\n\tint ret;\n\n\tif (is_mt76x2e)\n\t\tmt76_rmw(dev, MT_MCU_COM_REG0, BIT(31), 0);\n\n\tret = mt76_mcu_send_msg(&dev->mt76, CMD_CALIBRATION_OP, &msg,\n\t\t\t\tsizeof(msg), true);\n\tif (ret)\n\t\treturn ret;\n\n\tif (is_mt76x2e &&\n\t    WARN_ON(!mt76_poll_msec(dev, MT_MCU_COM_REG0,\n\t\t\t\t    BIT(31), BIT(31), 100)))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76x02_mcu_calibrate);\n\nint mt76x02_mcu_cleanup(struct mt76x02_dev *dev)\n{\n\tstruct sk_buff *skb;\n\n\tmt76_wr(dev, MT_MCU_INT_LEVEL, 1);\n\tusleep_range(20000, 30000);\n\n\twhile ((skb = skb_dequeue(&dev->mt76.mcu.res_q)) != NULL)\n\t\tdev_kfree_skb(skb);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76x02_mcu_cleanup);\n\nvoid mt76x02_set_ethtool_fwver(struct mt76x02_dev *dev,\n\t\t\t       const struct mt76x02_fw_header *h)\n{\n\tu16 bld = le16_to_cpu(h->build_ver);\n\tu16 ver = le16_to_cpu(h->fw_ver);\n\n\tsnprintf(dev->mt76.hw->wiphy->fw_version,\n\t\t sizeof(dev->mt76.hw->wiphy->fw_version),\n\t\t \"%d.%d.%02d-b%x\",\n\t\t (ver >> 12) & 0xf, (ver >> 8) & 0xf, ver & 0xf, bld);\n}\nEXPORT_SYMBOL_GPL(mt76x02_set_ethtool_fwver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}