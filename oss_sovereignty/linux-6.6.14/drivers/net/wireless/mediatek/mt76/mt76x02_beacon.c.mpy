{
  "module_name": "mt76x02_beacon.c",
  "hash_id": "42a7fc59b632f02053e3f2c953597d60b9bd473b09815b5fbd5bc344372b8c3b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt76x02_beacon.c",
  "human_readable_source": "\n \n\n#include \"mt76x02.h\"\n\nstatic void mt76x02_set_beacon_offsets(struct mt76x02_dev *dev)\n{\n\tu32 regs[4] = {};\n\tu16 val;\n\tint i;\n\n\tfor (i = 0; i < dev->beacon_ops->nslots; i++) {\n\t\tval = i * dev->beacon_ops->slot_size;\n\t\tregs[i / 4] |= (val / 64) << (8 * (i % 4));\n\t}\n\n\tfor (i = 0; i < 4; i++)\n\t\tmt76_wr(dev, MT_BCN_OFFSET(i), regs[i]);\n}\n\nstatic int\nmt76x02_write_beacon(struct mt76x02_dev *dev, int offset, struct sk_buff *skb)\n{\n\tint beacon_len = dev->beacon_ops->slot_size;\n\n\tif (WARN_ON_ONCE(beacon_len < skb->len + sizeof(struct mt76x02_txwi)))\n\t\treturn -ENOSPC;\n\n\t \n\tif (mt76_is_usb(&dev->mt76)) {\n\t\tstruct mt76x02_txwi *txwi;\n\n\t\ttxwi = (struct mt76x02_txwi *)(skb->data - sizeof(*txwi));\n\t\tmt76x02_mac_write_txwi(dev, txwi, skb, NULL, NULL, skb->len);\n\t\tskb_push(skb, sizeof(*txwi));\n\t} else {\n\t\tstruct mt76x02_txwi txwi;\n\n\t\tmt76x02_mac_write_txwi(dev, &txwi, skb, NULL, NULL, skb->len);\n\t\tmt76_wr_copy(dev, offset, &txwi, sizeof(txwi));\n\t\toffset += sizeof(txwi);\n\t}\n\n\tmt76_wr_copy(dev, offset, skb->data, skb->len);\n\treturn 0;\n}\n\nvoid mt76x02_mac_set_beacon(struct mt76x02_dev *dev,\n\t\t\t    struct sk_buff *skb)\n{\n\tint bcn_len = dev->beacon_ops->slot_size;\n\tint bcn_addr = MT_BEACON_BASE + (bcn_len * dev->beacon_data_count);\n\n\tif (!mt76x02_write_beacon(dev, bcn_addr, skb)) {\n\t\tif (!dev->beacon_data_count)\n\t\t\tdev->beacon_hang_check++;\n\t\tdev->beacon_data_count++;\n\t}\n\tdev_kfree_skb(skb);\n}\nEXPORT_SYMBOL_GPL(mt76x02_mac_set_beacon);\n\nvoid mt76x02_mac_set_beacon_enable(struct mt76x02_dev *dev,\n\t\t\t\t   struct ieee80211_vif *vif, bool enable)\n{\n\tstruct mt76x02_vif *mvif = (struct mt76x02_vif *)vif->drv_priv;\n\tu8 old_mask = dev->mt76.beacon_mask;\n\n\tmt76x02_pre_tbtt_enable(dev, false);\n\n\tif (!dev->mt76.beacon_mask)\n\t\tdev->tbtt_count = 0;\n\n\tdev->beacon_hang_check = 0;\n\tif (enable) {\n\t\tdev->mt76.beacon_mask |= BIT(mvif->idx);\n\t} else {\n\t\tdev->mt76.beacon_mask &= ~BIT(mvif->idx);\n\t}\n\n\tif (!!old_mask == !!dev->mt76.beacon_mask)\n\t\tgoto out;\n\n\tif (dev->mt76.beacon_mask)\n\t\tmt76_set(dev, MT_BEACON_TIME_CFG,\n\t\t\t MT_BEACON_TIME_CFG_BEACON_TX |\n\t\t\t MT_BEACON_TIME_CFG_TBTT_EN |\n\t\t\t MT_BEACON_TIME_CFG_TIMER_EN);\n\telse\n\t\tmt76_clear(dev, MT_BEACON_TIME_CFG,\n\t\t\t   MT_BEACON_TIME_CFG_BEACON_TX |\n\t\t\t   MT_BEACON_TIME_CFG_TBTT_EN |\n\t\t\t   MT_BEACON_TIME_CFG_TIMER_EN);\n\tmt76x02_beacon_enable(dev, !!dev->mt76.beacon_mask);\n\nout:\n\tmt76x02_pre_tbtt_enable(dev, true);\n}\n\nvoid\nmt76x02_resync_beacon_timer(struct mt76x02_dev *dev)\n{\n\tu32 timer_val = dev->mt76.beacon_int << 4;\n\n\tdev->tbtt_count++;\n\n\t \n\tif (dev->tbtt_count < 63)\n\t\treturn;\n\n\t \n\tif (dev->tbtt_count == 63)\n\t\ttimer_val -= 1;\n\n\tmt76_rmw_field(dev, MT_BEACON_TIME_CFG,\n\t\t       MT_BEACON_TIME_CFG_INTVAL, timer_val);\n\n\tif (dev->tbtt_count >= 64)\n\t\tdev->tbtt_count = 0;\n}\nEXPORT_SYMBOL_GPL(mt76x02_resync_beacon_timer);\n\nvoid\nmt76x02_update_beacon_iter(void *priv, u8 *mac, struct ieee80211_vif *vif)\n{\n\tstruct mt76x02_dev *dev = (struct mt76x02_dev *)priv;\n\tstruct mt76x02_vif *mvif = (struct mt76x02_vif *)vif->drv_priv;\n\tstruct sk_buff *skb = NULL;\n\n\tif (!(dev->mt76.beacon_mask & BIT(mvif->idx)))\n\t\treturn;\n\n\tskb = ieee80211_beacon_get(mt76_hw(dev), vif, 0);\n\tif (!skb)\n\t\treturn;\n\n\tmt76x02_mac_set_beacon(dev, skb);\n}\nEXPORT_SYMBOL_GPL(mt76x02_update_beacon_iter);\n\nstatic void\nmt76x02_add_buffered_bc(void *priv, u8 *mac, struct ieee80211_vif *vif)\n{\n\tstruct beacon_bc_data *data = priv;\n\tstruct mt76x02_dev *dev = data->dev;\n\tstruct mt76x02_vif *mvif = (struct mt76x02_vif *)vif->drv_priv;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *skb;\n\n\tif (!(dev->mt76.beacon_mask & BIT(mvif->idx)))\n\t\treturn;\n\n\tskb = ieee80211_get_buffered_bc(mt76_hw(dev), vif);\n\tif (!skb)\n\t\treturn;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tinfo->control.vif = vif;\n\tinfo->flags |= IEEE80211_TX_CTL_ASSIGN_SEQ;\n\tmt76_skb_set_moredata(skb, true);\n\t__skb_queue_tail(&data->q, skb);\n\tdata->tail[mvif->idx] = skb;\n}\n\nvoid\nmt76x02_enqueue_buffered_bc(struct mt76x02_dev *dev,\n\t\t\t    struct beacon_bc_data *data,\n\t\t\t    int max_nframes)\n{\n\tint i, nframes;\n\n\tdata->dev = dev;\n\t__skb_queue_head_init(&data->q);\n\n\tdo {\n\t\tnframes = skb_queue_len(&data->q);\n\t\tieee80211_iterate_active_interfaces_atomic(mt76_hw(dev),\n\t\t\tIEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\tmt76x02_add_buffered_bc, data);\n\t} while (nframes != skb_queue_len(&data->q) &&\n\t\t skb_queue_len(&data->q) < max_nframes);\n\n\tif (!skb_queue_len(&data->q))\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(data->tail); i++) {\n\t\tif (!data->tail[i])\n\t\t\tcontinue;\n\t\tmt76_skb_set_moredata(data->tail[i], false);\n\t}\n}\nEXPORT_SYMBOL_GPL(mt76x02_enqueue_buffered_bc);\n\nvoid mt76x02_init_beacon_config(struct mt76x02_dev *dev)\n{\n\tmt76_clear(dev, MT_BEACON_TIME_CFG, (MT_BEACON_TIME_CFG_TIMER_EN |\n\t\t\t\t\t     MT_BEACON_TIME_CFG_TBTT_EN |\n\t\t\t\t\t     MT_BEACON_TIME_CFG_BEACON_TX));\n\tmt76_set(dev, MT_BEACON_TIME_CFG, MT_BEACON_TIME_CFG_SYNC_MODE);\n\tmt76_wr(dev, MT_BCN_BYPASS_MASK, 0xffff);\n\tmt76x02_set_beacon_offsets(dev);\n}\nEXPORT_SYMBOL_GPL(mt76x02_init_beacon_config);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}