{
  "module_name": "mt792x_acpi_sar.c",
  "hash_id": "450ed4df85b0f90989c2579ff099d2296a40157409a17d49432baaba9355edde",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt792x_acpi_sar.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include \"mt792x.h\"\n\nstatic int\nmt792x_acpi_read(struct mt792x_dev *dev, u8 *method, u8 **tbl, u32 *len)\n{\n\tstruct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER, NULL };\n\tstruct mt76_dev *mdev = &dev->mt76;\n\tunion acpi_object *sar_root;\n\tacpi_handle root, handle;\n\tacpi_status status;\n\tu32 i = 0;\n\tint ret;\n\n\troot = ACPI_HANDLE(mdev->dev);\n\tif (!root)\n\t\treturn -EOPNOTSUPP;\n\n\tstatus = acpi_get_handle(root, method, &handle);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\tstatus = acpi_evaluate_object(handle, NULL, NULL, &buf);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\tsar_root = buf.pointer;\n\tif (sar_root->type != ACPI_TYPE_PACKAGE ||\n\t    sar_root->package.count < 4 ||\n\t    sar_root->package.elements[0].type != ACPI_TYPE_INTEGER) {\n\t\tdev_err(mdev->dev, \"sar cnt = %d\\n\",\n\t\t\tsar_root->package.count);\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tif (!*tbl) {\n\t\t*tbl = devm_kzalloc(mdev->dev, sar_root->package.count,\n\t\t\t\t    GFP_KERNEL);\n\t\tif (!*tbl) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (len)\n\t\t*len = sar_root->package.count;\n\n\tfor (i = 0; i < sar_root->package.count; i++) {\n\t\tunion acpi_object *sar_unit = &sar_root->package.elements[i];\n\n\t\tif (sar_unit->type != ACPI_TYPE_INTEGER)\n\t\t\tbreak;\n\n\t\t*(*tbl + i) = (u8)sar_unit->integer.value;\n\t}\n\n\tret = i == sar_root->package.count ? 0 : -EINVAL;\nfree:\n\tkfree(sar_root);\n\n\treturn ret;\n}\n\n \nstatic void\nmt792x_asar_acpi_read_mtcl(struct mt792x_dev *dev, u8 **table, u8 *version)\n{\n\tif (mt792x_acpi_read(dev, MT792x_ACPI_MTCL, table, NULL) < 0)\n\t\t*version = 1;\n\telse\n\t\t*version = 2;\n}\n\n \nstatic int\nmt792x_asar_acpi_read_mtds(struct mt792x_dev *dev, u8 **table, u8 version)\n{\n\tint len, ret, sarlen, prelen, tblcnt;\n\tbool enable;\n\n\tret = mt792x_acpi_read(dev, MT792x_ACPI_MTDS, table, &len);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tswitch (version) {\n\tcase 1:\n\t\tenable = ((struct mt792x_asar_dyn *)*table)->enable;\n\t\tsarlen = sizeof(struct mt792x_asar_dyn_limit);\n\t\tprelen = sizeof(struct mt792x_asar_dyn);\n\t\tbreak;\n\tcase 2:\n\t\tenable = ((struct mt792x_asar_dyn_v2 *)*table)->enable;\n\t\tsarlen = sizeof(struct mt792x_asar_dyn_limit_v2);\n\t\tprelen = sizeof(struct mt792x_asar_dyn_v2);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ttblcnt = (len - prelen) / sarlen;\n\tif (!enable ||\n\t    tblcnt > MT792x_ASAR_MAX_DYN || tblcnt < MT792x_ASAR_MIN_DYN)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int\nmt792x_asar_acpi_read_mtgs(struct mt792x_dev *dev, u8 **table, u8 version)\n{\n\tint len, ret, sarlen, prelen, tblcnt;\n\n\tret = mt792x_acpi_read(dev, MT792x_ACPI_MTGS, table, &len);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tswitch (version) {\n\tcase 1:\n\t\tsarlen = sizeof(struct mt792x_asar_geo_limit);\n\t\tprelen = sizeof(struct mt792x_asar_geo);\n\t\tbreak;\n\tcase 2:\n\t\tsarlen = sizeof(struct mt792x_asar_geo_limit_v2);\n\t\tprelen = sizeof(struct mt792x_asar_geo_v2);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ttblcnt = (len - prelen) / sarlen;\n\tif (tblcnt > MT792x_ASAR_MAX_GEO || tblcnt < MT792x_ASAR_MIN_GEO)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int\nmt792x_asar_acpi_read_mtfg(struct mt792x_dev *dev, u8 **table)\n{\n\tint len, ret;\n\n\tret = mt792x_acpi_read(dev, MT792x_ACPI_MTFG, table, &len);\n\tif (ret)\n\t\treturn ret;\n\n\tif (len < MT792x_ASAR_MIN_FG)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint mt792x_init_acpi_sar(struct mt792x_dev *dev)\n{\n\tstruct mt792x_acpi_sar *asar;\n\tint ret;\n\n\tasar = devm_kzalloc(dev->mt76.dev, sizeof(*asar), GFP_KERNEL);\n\tif (!asar)\n\t\treturn -ENOMEM;\n\n\tmt792x_asar_acpi_read_mtcl(dev, (u8 **)&asar->countrylist, &asar->ver);\n\n\t \n\tret = mt792x_asar_acpi_read_mtds(dev, (u8 **)&asar->dyn, asar->ver);\n\tif (ret) {\n\t\tdevm_kfree(dev->mt76.dev, asar->dyn);\n\t\tdevm_kfree(dev->mt76.dev, asar->countrylist);\n\t\tdevm_kfree(dev->mt76.dev, asar);\n\n\t\treturn ret;\n\t}\n\n\t \n\tret = mt792x_asar_acpi_read_mtgs(dev, (u8 **)&asar->geo, asar->ver);\n\tif (ret) {\n\t\tdevm_kfree(dev->mt76.dev, asar->geo);\n\t\tasar->geo = NULL;\n\t}\n\n\t \n\tret = mt792x_asar_acpi_read_mtfg(dev, (u8 **)&asar->fg);\n\tif (ret) {\n\t\tdevm_kfree(dev->mt76.dev, asar->fg);\n\t\tasar->fg = NULL;\n\t}\n\tdev->phy.acpisar = asar;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt792x_init_acpi_sar);\n\nstatic s8\nmt792x_asar_get_geo_pwr(struct mt792x_phy *phy,\n\t\t\tenum nl80211_band band, s8 dyn_power)\n{\n\tstruct mt792x_acpi_sar *asar = phy->acpisar;\n\tstruct mt792x_asar_geo_band *band_pwr;\n\ts8 geo_power;\n\tu8 idx, max;\n\n\tif (!asar->geo)\n\t\treturn dyn_power;\n\n\tswitch (phy->mt76->dev->region) {\n\tcase NL80211_DFS_FCC:\n\t\tidx = 0;\n\t\tbreak;\n\tcase NL80211_DFS_ETSI:\n\t\tidx = 1;\n\t\tbreak;\n\tdefault:  \n\t\tidx = 2;\n\t\tbreak;\n\t}\n\n\tif (asar->ver == 1) {\n\t\tband_pwr = &asar->geo->tbl[idx].band[0];\n\t\tmax = ARRAY_SIZE(asar->geo->tbl[idx].band);\n\t} else {\n\t\tband_pwr = &asar->geo_v2->tbl[idx].band[0];\n\t\tmax = ARRAY_SIZE(asar->geo_v2->tbl[idx].band);\n\t}\n\n\tswitch (band) {\n\tcase NL80211_BAND_2GHZ:\n\t\tidx = 0;\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\tidx = 1;\n\t\tbreak;\n\tcase NL80211_BAND_6GHZ:\n\t\tidx = 2;\n\t\tbreak;\n\tdefault:\n\t\treturn dyn_power;\n\t}\n\n\tif (idx >= max)\n\t\treturn dyn_power;\n\n\tgeo_power = (band_pwr + idx)->pwr;\n\tdyn_power += (band_pwr + idx)->offset;\n\n\treturn min(geo_power, dyn_power);\n}\n\nstatic s8\nmt792x_asar_range_pwr(struct mt792x_phy *phy,\n\t\t      const struct cfg80211_sar_freq_ranges *range,\n\t\t      u8 idx)\n{\n\tconst struct cfg80211_sar_capa *capa = phy->mt76->hw->wiphy->sar_capa;\n\tstruct mt792x_acpi_sar *asar = phy->acpisar;\n\tu8 *limit, band, max;\n\n\tif (!capa)\n\t\treturn 127;\n\n\tif (asar->ver == 1) {\n\t\tlimit = &asar->dyn->tbl[0].frp[0];\n\t\tmax = ARRAY_SIZE(asar->dyn->tbl[0].frp);\n\t} else {\n\t\tlimit = &asar->dyn_v2->tbl[0].frp[0];\n\t\tmax = ARRAY_SIZE(asar->dyn_v2->tbl[0].frp);\n\t}\n\n\tif (idx >= max)\n\t\treturn 127;\n\n\tif (range->start_freq >= 5945)\n\t\tband = NL80211_BAND_6GHZ;\n\telse if (range->start_freq >= 5150)\n\t\tband = NL80211_BAND_5GHZ;\n\telse\n\t\tband = NL80211_BAND_2GHZ;\n\n\treturn mt792x_asar_get_geo_pwr(phy, band, limit[idx]);\n}\n\nint mt792x_init_acpi_sar_power(struct mt792x_phy *phy, bool set_default)\n{\n\tconst struct cfg80211_sar_capa *capa = phy->mt76->hw->wiphy->sar_capa;\n\tint i;\n\n\tif (!phy->acpisar)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < capa->num_freq_ranges; i++) {\n\t\tstruct mt76_freq_range_power *frp = &phy->mt76->frp[i];\n\n\t\tfrp->range = set_default ? &capa->freq_ranges[i] : frp->range;\n\t\tif (!frp->range)\n\t\t\tcontinue;\n\n\t\tfrp->power = min_t(s8, set_default ? 127 : frp->power,\n\t\t\t\t   mt792x_asar_range_pwr(phy, frp->range, i));\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt792x_init_acpi_sar_power);\n\nu8 mt792x_acpi_get_flags(struct mt792x_phy *phy)\n{\n\tstruct mt792x_acpi_sar *acpisar = phy->acpisar;\n\tstruct mt792x_asar_fg *fg;\n\tstruct {\n\t\tu8 acpi_idx;\n\t\tu8 chip_idx;\n\t} map[] = {\n\t\t{ 1, 1 },\n\t\t{ 4, 2 },\n\t};\n\tu8 flags = BIT(0);\n\tint i, j;\n\n\tif (!acpisar)\n\t\treturn 0;\n\n\tfg = acpisar->fg;\n\tif (!fg)\n\t\treturn flags;\n\n\t \n\tfor (i = 0; i < fg->nr_flag; i++) {\n\t\tfor (j = 0; j < ARRAY_SIZE(map); j++) {\n\t\t\tif (fg->flag[i] == map[j].acpi_idx) {\n\t\t\t\tflags |= BIT(map[j].chip_idx);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn flags;\n}\nEXPORT_SYMBOL_GPL(mt792x_acpi_get_flags);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}