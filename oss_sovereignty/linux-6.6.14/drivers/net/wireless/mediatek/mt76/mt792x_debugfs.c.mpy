{
  "module_name": "mt792x_debugfs.c",
  "hash_id": "613e997997651a1d13c265726ce833ed5ee1477f6d77a24fe31dceb5a6129af0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt792x_debugfs.c",
  "human_readable_source": "\n \n\n#include \"mt792x.h\"\n\nstatic void\nmt792x_ampdu_stat_read_phy(struct mt792x_phy *phy,\n\t\t\t   struct seq_file *file)\n{\n\tstruct mt792x_dev *dev = file->private;\n\tint bound[15], range[4], i;\n\n\tif (!phy)\n\t\treturn;\n\n\tmt792x_mac_update_mib_stats(phy);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(range); i++)\n\t\trange[i] = mt76_rr(dev, MT_MIB_ARNG(0, i));\n\n\tfor (i = 0; i < ARRAY_SIZE(bound); i++)\n\t\tbound[i] = MT_MIB_ARNCR_RANGE(range[i / 4], i % 4) + 1;\n\n\tseq_puts(file, \"\\nPhy0\\n\");\n\n\tseq_printf(file, \"Length: %8d | \", bound[0]);\n\tfor (i = 0; i < ARRAY_SIZE(bound) - 1; i++)\n\t\tseq_printf(file, \"%3d  %3d | \", bound[i] + 1, bound[i + 1]);\n\n\tseq_puts(file, \"\\nCount:  \");\n\tfor (i = 0; i < ARRAY_SIZE(bound); i++)\n\t\tseq_printf(file, \"%8d | \", phy->mt76->aggr_stats[i]);\n\tseq_puts(file, \"\\n\");\n\n\tseq_printf(file, \"BA miss count: %d\\n\", phy->mib.ba_miss_cnt);\n}\n\nint mt792x_tx_stats_show(struct seq_file *file, void *data)\n{\n\tstruct mt792x_dev *dev = file->private;\n\tstruct mt792x_phy *phy = &dev->phy;\n\tstruct mt76_mib_stats *mib = &phy->mib;\n\tint i;\n\n\tmt792x_mutex_acquire(dev);\n\n\tmt792x_ampdu_stat_read_phy(phy, file);\n\n\tseq_puts(file, \"Tx MSDU stat:\\n\");\n\tfor (i = 0; i < ARRAY_SIZE(mib->tx_amsdu); i++) {\n\t\tseq_printf(file, \"AMSDU pack count of %d MSDU in TXD: %8d \",\n\t\t\t   i + 1, mib->tx_amsdu[i]);\n\t\tif (mib->tx_amsdu_cnt)\n\t\t\tseq_printf(file, \"(%3d%%)\\n\",\n\t\t\t\t   mib->tx_amsdu[i] * 100 / mib->tx_amsdu_cnt);\n\t\telse\n\t\t\tseq_puts(file, \"\\n\");\n\t}\n\n\tmt792x_mutex_release(dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt792x_tx_stats_show);\n\nint mt792x_queues_acq(struct seq_file *s, void *data)\n{\n\tstruct mt792x_dev *dev = dev_get_drvdata(s->private);\n\tint i;\n\n\tmt792x_mutex_acquire(dev);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tu32 ctrl, val, qlen = 0;\n\t\tint j;\n\n\t\tval = mt76_rr(dev, MT_PLE_AC_QEMPTY(i));\n\t\tctrl = BIT(31) | BIT(11) | (i << 24);\n\n\t\tfor (j = 0; j < 32; j++) {\n\t\t\tif (val & BIT(j))\n\t\t\t\tcontinue;\n\n\t\t\tmt76_wr(dev, MT_PLE_FL_Q0_CTRL, ctrl | j);\n\t\t\tqlen += mt76_get_field(dev, MT_PLE_FL_Q3_CTRL,\n\t\t\t\t\t       GENMASK(11, 0));\n\t\t}\n\t\tseq_printf(s, \"AC%d: queued=%d\\n\", i, qlen);\n\t}\n\n\tmt792x_mutex_release(dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt792x_queues_acq);\n\nint mt792x_queues_read(struct seq_file *s, void *data)\n{\n\tstruct mt792x_dev *dev = dev_get_drvdata(s->private);\n\tstruct {\n\t\tstruct mt76_queue *q;\n\t\tchar *queue;\n\t} queue_map[] = {\n\t\t{ dev->mphy.q_tx[MT_TXQ_BE],\t \"WFDMA0\" },\n\t\t{ dev->mt76.q_mcu[MT_MCUQ_WM],\t \"MCUWM\"  },\n\t\t{ dev->mt76.q_mcu[MT_MCUQ_FWDL], \"MCUFWQ\" },\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(queue_map); i++) {\n\t\tstruct mt76_queue *q = queue_map[i].q;\n\n\t\tif (!q)\n\t\t\tcontinue;\n\n\t\tseq_printf(s,\n\t\t\t   \"%s:\tqueued=%d head=%d tail=%d\\n\",\n\t\t\t   queue_map[i].queue, q->queued, q->head,\n\t\t\t   q->tail);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt792x_queues_read);\n\nint mt792x_pm_stats(struct seq_file *s, void *data)\n{\n\tstruct mt792x_dev *dev = dev_get_drvdata(s->private);\n\tstruct mt76_connac_pm *pm = &dev->pm;\n\n\tunsigned long awake_time = pm->stats.awake_time;\n\tunsigned long doze_time = pm->stats.doze_time;\n\n\tif (!test_bit(MT76_STATE_PM, &dev->mphy.state))\n\t\tawake_time += jiffies - pm->stats.last_wake_event;\n\telse\n\t\tdoze_time += jiffies - pm->stats.last_doze_event;\n\n\tseq_printf(s, \"awake time: %14u\\ndoze time: %15u\\n\",\n\t\t   jiffies_to_msecs(awake_time),\n\t\t   jiffies_to_msecs(doze_time));\n\n\tseq_printf(s, \"low power wakes: %9d\\n\", pm->stats.lp_wake);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt792x_pm_stats);\n\nint mt792x_pm_idle_timeout_set(void *data, u64 val)\n{\n\tstruct mt792x_dev *dev = data;\n\n\tdev->pm.idle_timeout = msecs_to_jiffies(val);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt792x_pm_idle_timeout_set);\n\nint mt792x_pm_idle_timeout_get(void *data, u64 *val)\n{\n\tstruct mt792x_dev *dev = data;\n\n\t*val = jiffies_to_msecs(dev->pm.idle_timeout);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt792x_pm_idle_timeout_get);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}