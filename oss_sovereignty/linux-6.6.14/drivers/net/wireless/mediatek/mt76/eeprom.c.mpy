{
  "module_name": "eeprom.c",
  "hash_id": "4a616df8b765c2cb693e3852f0b18ab35ad97a619172d2a3910561267a26b7c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/eeprom.c",
  "human_readable_source": "\n \n#include <linux/of.h>\n#include <linux/of_net.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/etherdevice.h>\n#include \"mt76.h\"\n\nstatic int mt76_get_of_eeprom_data(struct mt76_dev *dev, void *eep, int len)\n{\n\tstruct device_node *np = dev->dev->of_node;\n\tconst void *data;\n\tint size;\n\n\tdata = of_get_property(np, \"mediatek,eeprom-data\", &size);\n\tif (!data)\n\t\treturn -ENOENT;\n\n\tif (size > len)\n\t\treturn -EINVAL;\n\n\tmemcpy(eep, data, size);\n\n\treturn 0;\n}\n\nstatic int mt76_get_of_epprom_from_mtd(struct mt76_dev *dev, void *eep, int offset, int len)\n{\n#ifdef CONFIG_MTD\n\tstruct device_node *np = dev->dev->of_node;\n\tstruct mtd_info *mtd;\n\tconst __be32 *list;\n\tconst char *part;\n\tphandle phandle;\n\tsize_t retlen;\n\tint size;\n\tint ret;\n\n\tlist = of_get_property(np, \"mediatek,mtd-eeprom\", &size);\n\tif (!list)\n\t\treturn -ENOENT;\n\n\tphandle = be32_to_cpup(list++);\n\tif (!phandle)\n\t\treturn -ENOENT;\n\n\tnp = of_find_node_by_phandle(phandle);\n\tif (!np)\n\t\treturn -EINVAL;\n\n\tpart = of_get_property(np, \"label\", NULL);\n\tif (!part)\n\t\tpart = np->name;\n\n\tmtd = get_mtd_device_nm(part);\n\tif (IS_ERR(mtd)) {\n\t\tret =  PTR_ERR(mtd);\n\t\tgoto out_put_node;\n\t}\n\n\tif (size <= sizeof(*list)) {\n\t\tret = -EINVAL;\n\t\tgoto out_put_node;\n\t}\n\n\toffset += be32_to_cpup(list);\n\tret = mtd_read(mtd, offset, len, &retlen, eep);\n\tput_mtd_device(mtd);\n\tif (mtd_is_bitflip(ret))\n\t\tret = 0;\n\tif (ret) {\n\t\tdev_err(dev->dev, \"reading EEPROM from mtd %s failed: %i\\n\",\n\t\t\tpart, ret);\n\t\tgoto out_put_node;\n\t}\n\n\tif (retlen < len) {\n\t\tret = -EINVAL;\n\t\tgoto out_put_node;\n\t}\n\n\tif (of_property_read_bool(dev->dev->of_node, \"big-endian\")) {\n\t\tu8 *data = (u8 *)eep;\n\t\tint i;\n\n\t\t \n\t\tfor (i = 0; i < round_down(len, 2); i += 2)\n\t\t\tput_unaligned_le16(get_unaligned_be16(&data[i]),\n\t\t\t\t\t   &data[i]);\n\t}\n\n#ifdef CONFIG_NL80211_TESTMODE\n\tdev->test_mtd.name = devm_kstrdup(dev->dev, part, GFP_KERNEL);\n\tdev->test_mtd.offset = offset;\n#endif\n\nout_put_node:\n\tof_node_put(np);\n\treturn ret;\n#else\n\treturn -ENOENT;\n#endif\n}\n\nstatic int mt76_get_of_eeprom_from_nvmem(struct mt76_dev *dev, void *eep, int len)\n{\n\tstruct device_node *np = dev->dev->of_node;\n\tstruct nvmem_cell *cell;\n\tconst void *data;\n\tsize_t retlen;\n\tint ret = 0;\n\n\tcell = of_nvmem_cell_get(np, \"eeprom\");\n\tif (IS_ERR(cell))\n\t\treturn PTR_ERR(cell);\n\n\tdata = nvmem_cell_read(cell, &retlen);\n\tnvmem_cell_put(cell);\n\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tif (retlen < len) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tmemcpy(eep, data, len);\n\nexit:\n\tkfree(data);\n\n\treturn ret;\n}\n\nint mt76_get_of_eeprom(struct mt76_dev *dev, void *eep, int offset, int len)\n{\n\tstruct device_node *np = dev->dev->of_node;\n\tint ret;\n\n\tif (!np)\n\t\treturn -ENOENT;\n\n\tret = mt76_get_of_eeprom_data(dev, eep, len);\n\tif (!ret)\n\t\treturn 0;\n\n\tret = mt76_get_of_epprom_from_mtd(dev, eep, offset, len);\n\tif (!ret)\n\t\treturn 0;\n\n\treturn mt76_get_of_eeprom_from_nvmem(dev, eep, len);\n}\nEXPORT_SYMBOL_GPL(mt76_get_of_eeprom);\n\nvoid\nmt76_eeprom_override(struct mt76_phy *phy)\n{\n\tstruct mt76_dev *dev = phy->dev;\n\tstruct device_node *np = dev->dev->of_node;\n\n\tof_get_mac_address(np, phy->macaddr);\n\n\tif (!is_valid_ether_addr(phy->macaddr)) {\n\t\teth_random_addr(phy->macaddr);\n\t\tdev_info(dev->dev,\n\t\t\t \"Invalid MAC address, using random address %pM\\n\",\n\t\t\t phy->macaddr);\n\t}\n}\nEXPORT_SYMBOL_GPL(mt76_eeprom_override);\n\nstatic bool mt76_string_prop_find(struct property *prop, const char *str)\n{\n\tconst char *cp = NULL;\n\n\tif (!prop || !str || !str[0])\n\t\treturn false;\n\n\twhile ((cp = of_prop_next_string(prop, cp)) != NULL)\n\t\tif (!strcasecmp(cp, str))\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct device_node *\nmt76_find_power_limits_node(struct mt76_dev *dev)\n{\n\tstruct device_node *np = dev->dev->of_node;\n\tconst char *const region_names[] = {\n\t\t[NL80211_DFS_UNSET] = \"ww\",\n\t\t[NL80211_DFS_ETSI] = \"etsi\",\n\t\t[NL80211_DFS_FCC] = \"fcc\",\n\t\t[NL80211_DFS_JP] = \"jp\",\n\t};\n\tstruct device_node *cur, *fallback = NULL;\n\tconst char *region_name = NULL;\n\n\tif (dev->region < ARRAY_SIZE(region_names))\n\t\tregion_name = region_names[dev->region];\n\n\tnp = of_get_child_by_name(np, \"power-limits\");\n\tif (!np)\n\t\treturn NULL;\n\n\tfor_each_child_of_node(np, cur) {\n\t\tstruct property *country = of_find_property(cur, \"country\", NULL);\n\t\tstruct property *regd = of_find_property(cur, \"regdomain\", NULL);\n\n\t\tif (!country && !regd) {\n\t\t\tfallback = cur;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mt76_string_prop_find(country, dev->alpha2) ||\n\t\t    mt76_string_prop_find(regd, region_name)) {\n\t\t\tof_node_put(np);\n\t\t\treturn cur;\n\t\t}\n\t}\n\n\tof_node_put(np);\n\treturn fallback;\n}\n\nstatic const __be32 *\nmt76_get_of_array(struct device_node *np, char *name, size_t *len, int min)\n{\n\tstruct property *prop = of_find_property(np, name, NULL);\n\n\tif (!prop || !prop->value || prop->length < min * 4)\n\t\treturn NULL;\n\n\t*len = prop->length;\n\n\treturn prop->value;\n}\n\nstatic struct device_node *\nmt76_find_channel_node(struct device_node *np, struct ieee80211_channel *chan)\n{\n\tstruct device_node *cur;\n\tconst __be32 *val;\n\tsize_t len;\n\n\tfor_each_child_of_node(np, cur) {\n\t\tval = mt76_get_of_array(cur, \"channels\", &len, 2);\n\t\tif (!val)\n\t\t\tcontinue;\n\n\t\twhile (len >= 2 * sizeof(*val)) {\n\t\t\tif (chan->hw_value >= be32_to_cpu(val[0]) &&\n\t\t\t    chan->hw_value <= be32_to_cpu(val[1]))\n\t\t\t\treturn cur;\n\n\t\t\tval += 2;\n\t\t\tlen -= 2 * sizeof(*val);\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic s8\nmt76_get_txs_delta(struct device_node *np, u8 nss)\n{\n\tconst __be32 *val;\n\tsize_t len;\n\n\tval = mt76_get_of_array(np, \"txs-delta\", &len, nss);\n\tif (!val)\n\t\treturn 0;\n\n\treturn be32_to_cpu(val[nss - 1]);\n}\n\nstatic void\nmt76_apply_array_limit(s8 *pwr, size_t pwr_len, const __be32 *data,\n\t\t       s8 target_power, s8 nss_delta, s8 *max_power)\n{\n\tint i;\n\n\tif (!data)\n\t\treturn;\n\n\tfor (i = 0; i < pwr_len; i++) {\n\t\tpwr[i] = min_t(s8, target_power,\n\t\t\t       be32_to_cpu(data[i]) + nss_delta);\n\t\t*max_power = max(*max_power, pwr[i]);\n\t}\n}\n\nstatic void\nmt76_apply_multi_array_limit(s8 *pwr, size_t pwr_len, s8 pwr_num,\n\t\t\t     const __be32 *data, size_t len, s8 target_power,\n\t\t\t     s8 nss_delta, s8 *max_power)\n{\n\tint i, cur;\n\n\tif (!data)\n\t\treturn;\n\n\tlen /= 4;\n\tcur = be32_to_cpu(data[0]);\n\tfor (i = 0; i < pwr_num; i++) {\n\t\tif (len < pwr_len + 1)\n\t\t\tbreak;\n\n\t\tmt76_apply_array_limit(pwr + pwr_len * i, pwr_len, data + 1,\n\t\t\t\t       target_power, nss_delta, max_power);\n\t\tif (--cur > 0)\n\t\t\tcontinue;\n\n\t\tdata += pwr_len + 1;\n\t\tlen -= pwr_len + 1;\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\tcur = be32_to_cpu(data[0]);\n\t}\n}\n\ns8 mt76_get_rate_power_limits(struct mt76_phy *phy,\n\t\t\t      struct ieee80211_channel *chan,\n\t\t\t      struct mt76_power_limits *dest,\n\t\t\t      s8 target_power)\n{\n\tstruct mt76_dev *dev = phy->dev;\n\tstruct device_node *np;\n\tconst __be32 *val;\n\tchar name[16];\n\tu32 mcs_rates = dev->drv->mcs_rates;\n\tu32 ru_rates = ARRAY_SIZE(dest->ru[0]);\n\tchar band;\n\tsize_t len;\n\ts8 max_power = 0;\n\ts8 txs_delta;\n\n\tif (!mcs_rates)\n\t\tmcs_rates = 10;\n\n\tmemset(dest, target_power, sizeof(*dest));\n\n\tif (!IS_ENABLED(CONFIG_OF))\n\t\treturn target_power;\n\n\tnp = mt76_find_power_limits_node(dev);\n\tif (!np)\n\t\treturn target_power;\n\n\tswitch (chan->band) {\n\tcase NL80211_BAND_2GHZ:\n\t\tband = '2';\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\tband = '5';\n\t\tbreak;\n\tcase NL80211_BAND_6GHZ:\n\t\tband = '6';\n\t\tbreak;\n\tdefault:\n\t\treturn target_power;\n\t}\n\n\tsnprintf(name, sizeof(name), \"txpower-%cg\", band);\n\tnp = of_get_child_by_name(np, name);\n\tif (!np)\n\t\treturn target_power;\n\n\tnp = mt76_find_channel_node(np, chan);\n\tif (!np)\n\t\treturn target_power;\n\n\ttxs_delta = mt76_get_txs_delta(np, hweight8(phy->antenna_mask));\n\n\tval = mt76_get_of_array(np, \"rates-cck\", &len, ARRAY_SIZE(dest->cck));\n\tmt76_apply_array_limit(dest->cck, ARRAY_SIZE(dest->cck), val,\n\t\t\t       target_power, txs_delta, &max_power);\n\n\tval = mt76_get_of_array(np, \"rates-ofdm\",\n\t\t\t\t&len, ARRAY_SIZE(dest->ofdm));\n\tmt76_apply_array_limit(dest->ofdm, ARRAY_SIZE(dest->ofdm), val,\n\t\t\t       target_power, txs_delta, &max_power);\n\n\tval = mt76_get_of_array(np, \"rates-mcs\", &len, mcs_rates + 1);\n\tmt76_apply_multi_array_limit(dest->mcs[0], ARRAY_SIZE(dest->mcs[0]),\n\t\t\t\t     ARRAY_SIZE(dest->mcs), val, len,\n\t\t\t\t     target_power, txs_delta, &max_power);\n\n\tval = mt76_get_of_array(np, \"rates-ru\", &len, ru_rates + 1);\n\tmt76_apply_multi_array_limit(dest->ru[0], ARRAY_SIZE(dest->ru[0]),\n\t\t\t\t     ARRAY_SIZE(dest->ru), val, len,\n\t\t\t\t     target_power, txs_delta, &max_power);\n\n\treturn max_power;\n}\nEXPORT_SYMBOL_GPL(mt76_get_rate_power_limits);\n\nint\nmt76_eeprom_init(struct mt76_dev *dev, int len)\n{\n\tdev->eeprom.size = len;\n\tdev->eeprom.data = devm_kzalloc(dev->dev, len, GFP_KERNEL);\n\tif (!dev->eeprom.data)\n\t\treturn -ENOMEM;\n\n\treturn !mt76_get_of_eeprom(dev, dev->eeprom.data, 0, len);\n}\nEXPORT_SYMBOL_GPL(mt76_eeprom_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}