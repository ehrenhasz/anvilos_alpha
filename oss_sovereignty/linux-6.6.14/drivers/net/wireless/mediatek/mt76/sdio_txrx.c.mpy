{
  "module_name": "sdio_txrx.c",
  "hash_id": "631f3da634af0fcb57278b267eb47358a16afab93acd41f4e83fab20a31c41a0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/sdio_txrx.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n\n#include <linux/mmc/host.h>\n#include <linux/mmc/sdio_ids.h>\n#include <linux/mmc/sdio_func.h>\n\n#include \"trace.h\"\n#include \"sdio.h\"\n#include \"mt76.h\"\n\nstatic int mt76s_refill_sched_quota(struct mt76_dev *dev, u32 *data)\n{\n\tu32 ple_ac_data_quota[] = {\n\t\tFIELD_GET(TXQ_CNT_L, data[4]),  \n\t\tFIELD_GET(TXQ_CNT_H, data[3]),  \n\t\tFIELD_GET(TXQ_CNT_L, data[3]),  \n\t\tFIELD_GET(TXQ_CNT_H, data[2]),  \n\t};\n\tu32 pse_ac_data_quota[] = {\n\t\tFIELD_GET(TXQ_CNT_H, data[1]),  \n\t\tFIELD_GET(TXQ_CNT_L, data[1]),  \n\t\tFIELD_GET(TXQ_CNT_H, data[0]),  \n\t\tFIELD_GET(TXQ_CNT_L, data[0]),  \n\t};\n\tu32 pse_mcu_quota = FIELD_GET(TXQ_CNT_L, data[2]);\n\tu32 pse_data_quota = 0, ple_data_quota = 0;\n\tstruct mt76_sdio *sdio = &dev->sdio;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pse_ac_data_quota); i++) {\n\t\tpse_data_quota += pse_ac_data_quota[i];\n\t\tple_data_quota += ple_ac_data_quota[i];\n\t}\n\n\tif (!pse_data_quota && !ple_data_quota && !pse_mcu_quota)\n\t\treturn 0;\n\n\tsdio->sched.pse_mcu_quota += pse_mcu_quota;\n\tsdio->sched.pse_data_quota += pse_data_quota;\n\tsdio->sched.ple_data_quota += ple_data_quota;\n\n\treturn pse_data_quota + ple_data_quota + pse_mcu_quota;\n}\n\nstatic struct sk_buff *\nmt76s_build_rx_skb(void *data, int data_len, int buf_len)\n{\n\tint len = min_t(int, data_len, MT_SKB_HEAD_LEN);\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(len, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_put_data(skb, data, len);\n\tif (data_len > len) {\n\t\tstruct page *page;\n\n\t\tdata += len;\n\t\tpage = virt_to_head_page(data);\n\t\tskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags,\n\t\t\t\tpage, data - page_address(page),\n\t\t\t\tdata_len - len, buf_len);\n\t\tget_page(page);\n\t}\n\n\treturn skb;\n}\n\nstatic int\nmt76s_rx_run_queue(struct mt76_dev *dev, enum mt76_rxq_id qid,\n\t\t   struct mt76s_intr *intr)\n{\n\tstruct mt76_queue *q = &dev->q_rx[qid];\n\tstruct mt76_sdio *sdio = &dev->sdio;\n\tint len = 0, err, i;\n\tstruct page *page;\n\tu8 *buf, *end;\n\n\tfor (i = 0; i < intr->rx.num[qid]; i++)\n\t\tlen += round_up(intr->rx.len[qid][i] + 4, 4);\n\n\tif (!len)\n\t\treturn 0;\n\n\tif (len > sdio->func->cur_blksize)\n\t\tlen = roundup(len, sdio->func->cur_blksize);\n\n\tpage = __dev_alloc_pages(GFP_KERNEL, get_order(len));\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tbuf = page_address(page);\n\n\tsdio_claim_host(sdio->func);\n\terr = sdio_readsb(sdio->func, buf, MCR_WRDR(qid), len);\n\tsdio_release_host(sdio->func);\n\n\tif (err < 0) {\n\t\tdev_err(dev->dev, \"sdio read data failed:%d\\n\", err);\n\t\tput_page(page);\n\t\treturn err;\n\t}\n\n\tend = buf + len;\n\ti = 0;\n\n\twhile (i < intr->rx.num[qid] && buf < end) {\n\t\tint index = (q->head + i) % q->ndesc;\n\t\tstruct mt76_queue_entry *e = &q->entry[index];\n\t\t__le32 *rxd = (__le32 *)buf;\n\n\t\t \n\t\tlen = le32_get_bits(rxd[0], GENMASK(15, 0));\n\n\t\t \n\t\tif (!dev->drv->rx_check || dev->drv->rx_check(dev, buf, len)) {\n\t\t\te->skb = mt76s_build_rx_skb(buf, len,\n\t\t\t\t\t\t    round_up(len + 4, 4));\n\t\t\tif (!e->skb)\n\t\t\t\tbreak;\n\n\t\t\tif (q->queued + i + 1 == q->ndesc)\n\t\t\t\tbreak;\n\t\t\ti++;\n\t\t}\n\t\tbuf += round_up(len + 4, 4);\n\t}\n\tput_page(page);\n\n\tspin_lock_bh(&q->lock);\n\tq->head = (q->head + i) % q->ndesc;\n\tq->queued += i;\n\tspin_unlock_bh(&q->lock);\n\n\treturn i;\n}\n\nstatic int mt76s_rx_handler(struct mt76_dev *dev)\n{\n\tstruct mt76_sdio *sdio = &dev->sdio;\n\tstruct mt76s_intr intr;\n\tint nframes = 0, ret;\n\n\tret = sdio->parse_irq(dev, &intr);\n\tif (ret)\n\t\treturn ret;\n\n\ttrace_dev_irq(dev, intr.isr, 0);\n\n\tif (intr.isr & WHIER_RX0_DONE_INT_EN) {\n\t\tret = mt76s_rx_run_queue(dev, 0, &intr);\n\t\tif (ret > 0) {\n\t\t\tmt76_worker_schedule(&sdio->net_worker);\n\t\t\tnframes += ret;\n\t\t}\n\t}\n\n\tif (intr.isr & WHIER_RX1_DONE_INT_EN) {\n\t\tret = mt76s_rx_run_queue(dev, 1, &intr);\n\t\tif (ret > 0) {\n\t\t\tmt76_worker_schedule(&sdio->net_worker);\n\t\t\tnframes += ret;\n\t\t}\n\t}\n\n\tnframes += !!mt76s_refill_sched_quota(dev, intr.tx.wtqcr);\n\n\treturn nframes;\n}\n\nstatic int\nmt76s_tx_pick_quota(struct mt76_sdio *sdio, bool mcu, int buf_sz,\n\t\t    int *pse_size, int *ple_size)\n{\n\tint pse_sz;\n\n\tpse_sz = DIV_ROUND_UP(buf_sz + sdio->sched.deficit,\n\t\t\t      sdio->sched.pse_page_size);\n\n\tif (mcu && sdio->hw_ver == MT76_CONNAC2_SDIO)\n\t\tpse_sz = 1;\n\n\tif (mcu) {\n\t\tif (sdio->sched.pse_mcu_quota < *pse_size + pse_sz)\n\t\t\treturn -EBUSY;\n\t} else {\n\t\tif (sdio->sched.pse_data_quota < *pse_size + pse_sz ||\n\t\t    sdio->sched.ple_data_quota < *ple_size + 1)\n\t\t\treturn -EBUSY;\n\n\t\t*ple_size = *ple_size + 1;\n\t}\n\t*pse_size = *pse_size + pse_sz;\n\n\treturn 0;\n}\n\nstatic void\nmt76s_tx_update_quota(struct mt76_sdio *sdio, bool mcu, int pse_size,\n\t\t      int ple_size)\n{\n\tif (mcu) {\n\t\tsdio->sched.pse_mcu_quota -= pse_size;\n\t} else {\n\t\tsdio->sched.pse_data_quota -= pse_size;\n\t\tsdio->sched.ple_data_quota -= ple_size;\n\t}\n}\n\nstatic int __mt76s_xmit_queue(struct mt76_dev *dev, u8 *data, int len)\n{\n\tstruct mt76_sdio *sdio = &dev->sdio;\n\tint err;\n\n\tif (len > sdio->func->cur_blksize)\n\t\tlen = roundup(len, sdio->func->cur_blksize);\n\n\tsdio_claim_host(sdio->func);\n\terr = sdio_writesb(sdio->func, MCR_WTDR1, data, len);\n\tsdio_release_host(sdio->func);\n\n\tif (err)\n\t\tdev_err(dev->dev, \"sdio write failed: %d\\n\", err);\n\n\treturn err;\n}\n\nstatic int mt76s_tx_run_queue(struct mt76_dev *dev, struct mt76_queue *q)\n{\n\tint err, nframes = 0, len = 0, pse_sz = 0, ple_sz = 0;\n\tbool mcu = q == dev->q_mcu[MT_MCUQ_WM];\n\tstruct mt76_sdio *sdio = &dev->sdio;\n\tu8 pad;\n\n\twhile (q->first != q->head) {\n\t\tstruct mt76_queue_entry *e = &q->entry[q->first];\n\t\tstruct sk_buff *iter;\n\n\t\tsmp_rmb();\n\n\t\tif (test_bit(MT76_MCU_RESET, &dev->phy.state))\n\t\t\tgoto next;\n\n\t\tif (!test_bit(MT76_STATE_MCU_RUNNING, &dev->phy.state)) {\n\t\t\t__skb_put_zero(e->skb, 4);\n\t\t\terr = __skb_grow(e->skb, roundup(e->skb->len,\n\t\t\t\t\t\t\t sdio->func->cur_blksize));\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\terr = __mt76s_xmit_queue(dev, e->skb->data,\n\t\t\t\t\t\t e->skb->len);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tgoto next;\n\t\t}\n\n\t\tpad = roundup(e->skb->len, 4) - e->skb->len;\n\t\tif (len + e->skb->len + pad + 4 > dev->sdio.xmit_buf_sz)\n\t\t\tbreak;\n\n\t\tif (mt76s_tx_pick_quota(sdio, mcu, e->buf_sz, &pse_sz,\n\t\t\t\t\t&ple_sz))\n\t\t\tbreak;\n\n\t\tmemcpy(sdio->xmit_buf + len, e->skb->data, skb_headlen(e->skb));\n\t\tlen += skb_headlen(e->skb);\n\t\tnframes++;\n\n\t\tskb_walk_frags(e->skb, iter) {\n\t\t\tmemcpy(sdio->xmit_buf + len, iter->data, iter->len);\n\t\t\tlen += iter->len;\n\t\t\tnframes++;\n\t\t}\n\n\t\tif (unlikely(pad)) {\n\t\t\tmemset(sdio->xmit_buf + len, 0, pad);\n\t\t\tlen += pad;\n\t\t}\nnext:\n\t\tq->first = (q->first + 1) % q->ndesc;\n\t\te->done = true;\n\t}\n\n\tif (nframes) {\n\t\tmemset(sdio->xmit_buf + len, 0, 4);\n\t\terr = __mt76s_xmit_queue(dev, sdio->xmit_buf, len + 4);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tmt76s_tx_update_quota(sdio, mcu, pse_sz, ple_sz);\n\n\tmt76_worker_schedule(&sdio->status_worker);\n\n\treturn nframes;\n}\n\nvoid mt76s_txrx_worker(struct mt76_sdio *sdio)\n{\n\tstruct mt76_dev *dev = container_of(sdio, struct mt76_dev, sdio);\n\tint i, nframes, ret;\n\n\t \n\tsdio_claim_host(sdio->func);\n\tsdio_writel(sdio->func, WHLPCR_INT_EN_CLR, MCR_WHLPCR, NULL);\n\tsdio_release_host(sdio->func);\n\n\tdo {\n\t\tnframes = 0;\n\n\t\t \n\t\tfor (i = 0; i <= MT_TXQ_PSD; i++) {\n\t\t\tret = mt76s_tx_run_queue(dev, dev->phy.q_tx[i]);\n\t\t\tif (ret > 0)\n\t\t\t\tnframes += ret;\n\t\t}\n\t\tret = mt76s_tx_run_queue(dev, dev->q_mcu[MT_MCUQ_WM]);\n\t\tif (ret > 0)\n\t\t\tnframes += ret;\n\n\t\t \n\t\tret = mt76s_rx_handler(dev);\n\t\tif (ret > 0)\n\t\t\tnframes += ret;\n\n\t\tif (test_bit(MT76_MCU_RESET, &dev->phy.state) ||\n\t\t    test_bit(MT76_STATE_SUSPEND, &dev->phy.state)) {\n\t\t\tif (!mt76s_txqs_empty(dev))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\twake_up(&sdio->wait);\n\t\t}\n\t} while (nframes > 0);\n\n\t \n\tsdio_claim_host(sdio->func);\n\tsdio_writel(sdio->func, WHLPCR_INT_EN_SET, MCR_WHLPCR, NULL);\n\tsdio_release_host(sdio->func);\n}\nEXPORT_SYMBOL_GPL(mt76s_txrx_worker);\n\nvoid mt76s_sdio_irq(struct sdio_func *func)\n{\n\tstruct mt76_dev *dev = sdio_get_drvdata(func);\n\tstruct mt76_sdio *sdio = &dev->sdio;\n\n\tif (!test_bit(MT76_STATE_INITIALIZED, &dev->phy.state) ||\n\t    test_bit(MT76_MCU_RESET, &dev->phy.state))\n\t\treturn;\n\n\tsdio_writel(sdio->func, WHLPCR_INT_EN_CLR, MCR_WHLPCR, NULL);\n\tmt76_worker_schedule(&sdio->txrx_worker);\n}\nEXPORT_SYMBOL_GPL(mt76s_sdio_irq);\n\nbool mt76s_txqs_empty(struct mt76_dev *dev)\n{\n\tstruct mt76_queue *q;\n\tint i;\n\n\tfor (i = 0; i <= MT_TXQ_PSD + 1; i++) {\n\t\tif (i <= MT_TXQ_PSD)\n\t\t\tq = dev->phy.q_tx[i];\n\t\telse\n\t\t\tq = dev->q_mcu[MT_MCUQ_WM];\n\n\t\tif (q->first != q->head)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(mt76s_txqs_empty);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}