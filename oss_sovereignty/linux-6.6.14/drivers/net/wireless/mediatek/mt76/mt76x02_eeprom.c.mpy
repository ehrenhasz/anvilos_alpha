{
  "module_name": "mt76x02_eeprom.c",
  "hash_id": "344c5b8954962976a092c6794eee358d091e213e575581c34fc97a088afd7e7c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt76x02_eeprom.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n\n#include \"mt76x02_eeprom.h\"\n\nstatic int\nmt76x02_efuse_read(struct mt76x02_dev *dev, u16 addr, u8 *data,\n\t\t   enum mt76x02_eeprom_modes mode)\n{\n\tu32 val;\n\tint i;\n\n\tval = mt76_rr(dev, MT_EFUSE_CTRL);\n\tval &= ~(MT_EFUSE_CTRL_AIN |\n\t\t MT_EFUSE_CTRL_MODE);\n\tval |= FIELD_PREP(MT_EFUSE_CTRL_AIN, addr & ~0xf);\n\tval |= FIELD_PREP(MT_EFUSE_CTRL_MODE, mode);\n\tval |= MT_EFUSE_CTRL_KICK;\n\tmt76_wr(dev, MT_EFUSE_CTRL, val);\n\n\tif (!mt76_poll_msec(dev, MT_EFUSE_CTRL, MT_EFUSE_CTRL_KICK, 0, 1000))\n\t\treturn -ETIMEDOUT;\n\n\tudelay(2);\n\n\tval = mt76_rr(dev, MT_EFUSE_CTRL);\n\tif ((val & MT_EFUSE_CTRL_AOUT) == MT_EFUSE_CTRL_AOUT) {\n\t\tmemset(data, 0xff, 16);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tval = mt76_rr(dev, MT_EFUSE_DATA(i));\n\t\tput_unaligned_le32(val, data + 4 * i);\n\t}\n\n\treturn 0;\n}\n\nint mt76x02_eeprom_copy(struct mt76x02_dev *dev,\n\t\t\tenum mt76x02_eeprom_field field,\n\t\t\tvoid *dest, int len)\n{\n\tif (field + len > dev->mt76.eeprom.size)\n\t\treturn -1;\n\n\tmemcpy(dest, dev->mt76.eeprom.data + field, len);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76x02_eeprom_copy);\n\nint mt76x02_get_efuse_data(struct mt76x02_dev *dev, u16 base, void *buf,\n\t\t\t   int len, enum mt76x02_eeprom_modes mode)\n{\n\tint ret, i;\n\n\tfor (i = 0; i + 16 <= len; i += 16) {\n\t\tret = mt76x02_efuse_read(dev, base + i, buf + i, mode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76x02_get_efuse_data);\n\nvoid mt76x02_eeprom_parse_hw_cap(struct mt76x02_dev *dev)\n{\n\tu16 val = mt76x02_eeprom_get(dev, MT_EE_NIC_CONF_0);\n\n\tswitch (FIELD_GET(MT_EE_NIC_CONF_0_BOARD_TYPE, val)) {\n\tcase BOARD_TYPE_5GHZ:\n\t\tdev->mphy.cap.has_5ghz = true;\n\t\tbreak;\n\tcase BOARD_TYPE_2GHZ:\n\t\tdev->mphy.cap.has_2ghz = true;\n\t\tbreak;\n\tdefault:\n\t\tdev->mphy.cap.has_2ghz = true;\n\t\tdev->mphy.cap.has_5ghz = true;\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(mt76x02_eeprom_parse_hw_cap);\n\nbool mt76x02_ext_pa_enabled(struct mt76x02_dev *dev, enum nl80211_band band)\n{\n\tu16 conf0 = mt76x02_eeprom_get(dev, MT_EE_NIC_CONF_0);\n\n\tif (band == NL80211_BAND_5GHZ)\n\t\treturn !(conf0 & MT_EE_NIC_CONF_0_PA_INT_5G);\n\telse\n\t\treturn !(conf0 & MT_EE_NIC_CONF_0_PA_INT_2G);\n}\nEXPORT_SYMBOL_GPL(mt76x02_ext_pa_enabled);\n\nvoid mt76x02_get_rx_gain(struct mt76x02_dev *dev, enum nl80211_band band,\n\t\t\t u16 *rssi_offset, s8 *lna_2g, s8 *lna_5g)\n{\n\tu16 val;\n\n\tval = mt76x02_eeprom_get(dev, MT_EE_LNA_GAIN);\n\t*lna_2g = val & 0xff;\n\tlna_5g[0] = val >> 8;\n\n\tval = mt76x02_eeprom_get(dev, MT_EE_RSSI_OFFSET_2G_1);\n\tlna_5g[1] = val >> 8;\n\n\tval = mt76x02_eeprom_get(dev, MT_EE_RSSI_OFFSET_5G_1);\n\tlna_5g[2] = val >> 8;\n\n\tif (!mt76x02_field_valid(lna_5g[1]))\n\t\tlna_5g[1] = lna_5g[0];\n\n\tif (!mt76x02_field_valid(lna_5g[2]))\n\t\tlna_5g[2] = lna_5g[0];\n\n\tif (band == NL80211_BAND_2GHZ)\n\t\t*rssi_offset = mt76x02_eeprom_get(dev, MT_EE_RSSI_OFFSET_2G_0);\n\telse\n\t\t*rssi_offset = mt76x02_eeprom_get(dev, MT_EE_RSSI_OFFSET_5G_0);\n}\nEXPORT_SYMBOL_GPL(mt76x02_get_rx_gain);\n\nu8 mt76x02_get_lna_gain(struct mt76x02_dev *dev,\n\t\t\ts8 *lna_2g, s8 *lna_5g,\n\t\t\tstruct ieee80211_channel *chan)\n{\n\tu8 lna;\n\n\tif (chan->band == NL80211_BAND_2GHZ)\n\t\tlna = *lna_2g;\n\telse if (chan->hw_value <= 64)\n\t\tlna = lna_5g[0];\n\telse if (chan->hw_value <= 128)\n\t\tlna = lna_5g[1];\n\telse\n\t\tlna = lna_5g[2];\n\n\treturn lna != 0xff ? lna : 0;\n}\nEXPORT_SYMBOL_GPL(mt76x02_get_lna_gain);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}