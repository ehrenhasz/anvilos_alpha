{
  "module_name": "mt76x02_mmio.c",
  "hash_id": "929deb817d5312b4d9a5df4a536fb2fb12c7476d18e79d08f6f54b39210e42bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt76x02_mmio.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/irq.h>\n\n#include \"mt76x02.h\"\n#include \"mt76x02_mcu.h\"\n#include \"trace.h\"\n\nstatic void mt76x02_pre_tbtt_tasklet(struct tasklet_struct *t)\n{\n\tstruct mt76x02_dev *dev = from_tasklet(dev, t, mt76.pre_tbtt_tasklet);\n\tstruct mt76_dev *mdev = &dev->mt76;\n\tstruct mt76_queue *q = dev->mphy.q_tx[MT_TXQ_PSD];\n\tstruct beacon_bc_data data = {};\n\tstruct sk_buff *skb;\n\tint i;\n\n\tif (mt76_hw(dev)->conf.flags & IEEE80211_CONF_OFFCHANNEL)\n\t\treturn;\n\n\tmt76x02_resync_beacon_timer(dev);\n\n\t \n\tmt76_set(dev, MT_BCN_BYPASS_MASK, 0xffff);\n\tdev->beacon_data_count = 0;\n\n\tieee80211_iterate_active_interfaces_atomic(mt76_hw(dev),\n\t\tIEEE80211_IFACE_ITER_RESUME_ALL,\n\t\tmt76x02_update_beacon_iter, dev);\n\n\tmt76_wr(dev, MT_BCN_BYPASS_MASK,\n\t\t0xff00 | ~(0xff00 >> dev->beacon_data_count));\n\n\tmt76_csa_check(mdev);\n\n\tif (mdev->csa_complete)\n\t\treturn;\n\n\tmt76x02_enqueue_buffered_bc(dev, &data, 8);\n\n\tif (!skb_queue_len(&data.q))\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(data.tail); i++) {\n\t\tif (!data.tail[i])\n\t\t\tcontinue;\n\n\t\tmt76_skb_set_moredata(data.tail[i], false);\n\t}\n\n\tspin_lock(&q->lock);\n\twhile ((skb = __skb_dequeue(&data.q)) != NULL) {\n\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\t\tstruct ieee80211_vif *vif = info->control.vif;\n\t\tstruct mt76x02_vif *mvif = (struct mt76x02_vif *)vif->drv_priv;\n\n\t\tmt76_tx_queue_skb(dev, q, MT_TXQ_PSD, skb, &mvif->group_wcid,\n\t\t\t\t  NULL);\n\t}\n\tspin_unlock(&q->lock);\n}\n\nstatic void mt76x02e_pre_tbtt_enable(struct mt76x02_dev *dev, bool en)\n{\n\tif (en)\n\t\ttasklet_enable(&dev->mt76.pre_tbtt_tasklet);\n\telse\n\t\ttasklet_disable(&dev->mt76.pre_tbtt_tasklet);\n}\n\nstatic void mt76x02e_beacon_enable(struct mt76x02_dev *dev, bool en)\n{\n\tmt76_rmw_field(dev, MT_INT_TIMER_EN, MT_INT_TIMER_EN_PRE_TBTT_EN, en);\n\tif (en)\n\t\tmt76x02_irq_enable(dev, MT_INT_PRE_TBTT | MT_INT_TBTT);\n\telse\n\t\tmt76x02_irq_disable(dev, MT_INT_PRE_TBTT | MT_INT_TBTT);\n}\n\nvoid mt76x02e_init_beacon_config(struct mt76x02_dev *dev)\n{\n\tstatic const struct mt76x02_beacon_ops beacon_ops = {\n\t\t.nslots = 8,\n\t\t.slot_size = 1024,\n\t\t.pre_tbtt_enable = mt76x02e_pre_tbtt_enable,\n\t\t.beacon_enable = mt76x02e_beacon_enable,\n\t};\n\n\tdev->beacon_ops = &beacon_ops;\n\n\t \n\tmt76_rmw_field(dev, MT_INT_TIMER_CFG, MT_INT_TIMER_CFG_PRE_TBTT,\n\t\t       8 << 4);\n\tmt76_rmw_field(dev, MT_INT_TIMER_CFG, MT_INT_TIMER_CFG_GP_TIMER,\n\t\t       MT_DFS_GP_INTERVAL);\n\tmt76_wr(dev, MT_INT_TIMER_EN, 0);\n\n\tmt76x02_init_beacon_config(dev);\n}\nEXPORT_SYMBOL_GPL(mt76x02e_init_beacon_config);\n\nstatic int\nmt76x02_init_rx_queue(struct mt76x02_dev *dev, struct mt76_queue *q,\n\t\t      int idx, int n_desc, int bufsize)\n{\n\tint err;\n\n\terr = mt76_queue_alloc(dev, q, idx, n_desc, bufsize,\n\t\t\t       MT_RX_RING_BASE);\n\tif (err < 0)\n\t\treturn err;\n\n\tmt76x02_irq_enable(dev, MT_INT_RX_DONE(idx));\n\n\treturn 0;\n}\n\nstatic void mt76x02_process_tx_status_fifo(struct mt76x02_dev *dev)\n{\n\tstruct mt76x02_tx_status stat;\n\tu8 update = 1;\n\n\twhile (kfifo_get(&dev->txstatus_fifo, &stat))\n\t\tmt76x02_send_tx_status(dev, &stat, &update);\n}\n\nstatic void mt76x02_tx_worker(struct mt76_worker *w)\n{\n\tstruct mt76x02_dev *dev;\n\n\tdev = container_of(w, struct mt76x02_dev, mt76.tx_worker);\n\n\tmt76x02_mac_poll_tx_status(dev, false);\n\tmt76x02_process_tx_status_fifo(dev);\n\n\tmt76_txq_schedule_all(&dev->mphy);\n}\n\nstatic int mt76x02_poll_tx(struct napi_struct *napi, int budget)\n{\n\tstruct mt76x02_dev *dev = container_of(napi, struct mt76x02_dev,\n\t\t\t\t\t       mt76.tx_napi);\n\tint i;\n\n\tmt76x02_mac_poll_tx_status(dev, false);\n\n\tmt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[MT_MCUQ_WM], false);\n\tfor (i = MT_TXQ_PSD; i >= 0; i--)\n\t\tmt76_queue_tx_cleanup(dev, dev->mphy.q_tx[i], false);\n\n\tif (napi_complete_done(napi, 0))\n\t\tmt76x02_irq_enable(dev, MT_INT_TX_DONE_ALL);\n\n\tmt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[MT_MCUQ_WM], false);\n\tfor (i = MT_TXQ_PSD; i >= 0; i--)\n\t\tmt76_queue_tx_cleanup(dev, dev->mphy.q_tx[i], false);\n\n\tmt76_worker_schedule(&dev->mt76.tx_worker);\n\n\treturn 0;\n}\n\nint mt76x02_dma_init(struct mt76x02_dev *dev)\n{\n\tstruct mt76_txwi_cache __maybe_unused *t;\n\tint i, ret, fifo_size;\n\tstruct mt76_queue *q;\n\tvoid *status_fifo;\n\n\tBUILD_BUG_ON(sizeof(struct mt76x02_rxwi) > MT_RX_HEADROOM);\n\n\tfifo_size = roundup_pow_of_two(32 * sizeof(struct mt76x02_tx_status));\n\tstatus_fifo = devm_kzalloc(dev->mt76.dev, fifo_size, GFP_KERNEL);\n\tif (!status_fifo)\n\t\treturn -ENOMEM;\n\n\tdev->mt76.tx_worker.fn = mt76x02_tx_worker;\n\ttasklet_setup(&dev->mt76.pre_tbtt_tasklet, mt76x02_pre_tbtt_tasklet);\n\n\tspin_lock_init(&dev->txstatus_fifo_lock);\n\tkfifo_init(&dev->txstatus_fifo, status_fifo, fifo_size);\n\n\tmt76_dma_attach(&dev->mt76);\n\n\tmt76_wr(dev, MT_WPDMA_RST_IDX, ~0);\n\n\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\tret = mt76_init_tx_queue(&dev->mphy, i, mt76_ac_to_hwq(i),\n\t\t\t\t\t MT76x02_TX_RING_SIZE,\n\t\t\t\t\t MT_TX_RING_BASE, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = mt76_init_tx_queue(&dev->mphy, MT_TXQ_PSD, MT_TX_HW_QUEUE_MGMT,\n\t\t\t\t MT76x02_PSD_RING_SIZE, MT_TX_RING_BASE, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt76_init_mcu_queue(&dev->mt76, MT_MCUQ_WM, MT_TX_HW_QUEUE_MCU,\n\t\t\t\t  MT_MCU_RING_SIZE, MT_TX_RING_BASE);\n\tif (ret)\n\t\treturn ret;\n\n\tmt76x02_irq_enable(dev,\n\t\t\t   MT_INT_TX_DONE(IEEE80211_AC_VO) |\n\t\t\t   MT_INT_TX_DONE(IEEE80211_AC_VI) |\n\t\t\t   MT_INT_TX_DONE(IEEE80211_AC_BE) |\n\t\t\t   MT_INT_TX_DONE(IEEE80211_AC_BK) |\n\t\t\t   MT_INT_TX_DONE(MT_TX_HW_QUEUE_MGMT) |\n\t\t\t   MT_INT_TX_DONE(MT_TX_HW_QUEUE_MCU));\n\n\tret = mt76x02_init_rx_queue(dev, &dev->mt76.q_rx[MT_RXQ_MCU], 1,\n\t\t\t\t    MT_MCU_RING_SIZE, MT_RX_BUF_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\tq = &dev->mt76.q_rx[MT_RXQ_MAIN];\n\tq->buf_offset = MT_RX_HEADROOM - sizeof(struct mt76x02_rxwi);\n\tret = mt76x02_init_rx_queue(dev, q, 0, MT76X02_RX_RING_SIZE,\n\t\t\t\t    MT_RX_BUF_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt76_init_queues(dev, mt76_dma_rx_poll);\n\tif (ret)\n\t\treturn ret;\n\n\tnetif_napi_add_tx(&dev->mt76.tx_napi_dev, &dev->mt76.tx_napi,\n\t\t\t  mt76x02_poll_tx);\n\tnapi_enable(&dev->mt76.tx_napi);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76x02_dma_init);\n\nvoid mt76x02_rx_poll_complete(struct mt76_dev *mdev, enum mt76_rxq_id q)\n{\n\tstruct mt76x02_dev *dev;\n\n\tdev = container_of(mdev, struct mt76x02_dev, mt76);\n\tmt76x02_irq_enable(dev, MT_INT_RX_DONE(q));\n}\nEXPORT_SYMBOL_GPL(mt76x02_rx_poll_complete);\n\nirqreturn_t mt76x02_irq_handler(int irq, void *dev_instance)\n{\n\tstruct mt76x02_dev *dev = dev_instance;\n\tu32 intr, mask;\n\n\tintr = mt76_rr(dev, MT_INT_SOURCE_CSR);\n\tintr &= dev->mt76.mmio.irqmask;\n\tmt76_wr(dev, MT_INT_SOURCE_CSR, intr);\n\n\tif (!test_bit(MT76_STATE_INITIALIZED, &dev->mphy.state))\n\t\treturn IRQ_NONE;\n\n\ttrace_dev_irq(&dev->mt76, intr, dev->mt76.mmio.irqmask);\n\n\tmask = intr & (MT_INT_RX_DONE_ALL | MT_INT_GPTIMER);\n\tif (intr & (MT_INT_TX_DONE_ALL | MT_INT_TX_STAT))\n\t\tmask |= MT_INT_TX_DONE_ALL;\n\n\tmt76x02_irq_disable(dev, mask);\n\n\tif (intr & MT_INT_RX_DONE(0))\n\t\tnapi_schedule(&dev->mt76.napi[0]);\n\n\tif (intr & MT_INT_RX_DONE(1))\n\t\tnapi_schedule(&dev->mt76.napi[1]);\n\n\tif (intr & MT_INT_PRE_TBTT)\n\t\ttasklet_schedule(&dev->mt76.pre_tbtt_tasklet);\n\n\t \n\tif (intr & MT_INT_TBTT) {\n\t\tif (dev->mt76.csa_complete)\n\t\t\tmt76_csa_finish(&dev->mt76);\n\t\telse\n\t\t\tmt76_queue_kick(dev, dev->mphy.q_tx[MT_TXQ_PSD]);\n\t}\n\n\tif (intr & MT_INT_TX_STAT)\n\t\tmt76x02_mac_poll_tx_status(dev, true);\n\n\tif (intr & (MT_INT_TX_STAT | MT_INT_TX_DONE_ALL))\n\t\tnapi_schedule(&dev->mt76.tx_napi);\n\n\tif (intr & MT_INT_GPTIMER)\n\t\ttasklet_schedule(&dev->dfs_pd.dfs_tasklet);\n\n\treturn IRQ_HANDLED;\n}\nEXPORT_SYMBOL_GPL(mt76x02_irq_handler);\n\nstatic void mt76x02_dma_enable(struct mt76x02_dev *dev)\n{\n\tu32 val;\n\n\tmt76_wr(dev, MT_MAC_SYS_CTRL, MT_MAC_SYS_CTRL_ENABLE_TX);\n\tmt76x02_wait_for_wpdma(&dev->mt76, 1000);\n\tusleep_range(50, 100);\n\n\tval = FIELD_PREP(MT_WPDMA_GLO_CFG_DMA_BURST_SIZE, 3) |\n\t      MT_WPDMA_GLO_CFG_TX_DMA_EN |\n\t      MT_WPDMA_GLO_CFG_RX_DMA_EN;\n\tmt76_set(dev, MT_WPDMA_GLO_CFG, val);\n\tmt76_clear(dev, MT_WPDMA_GLO_CFG,\n\t\t   MT_WPDMA_GLO_CFG_TX_WRITEBACK_DONE);\n}\n\nvoid mt76x02_dma_disable(struct mt76x02_dev *dev)\n{\n\tu32 val = mt76_rr(dev, MT_WPDMA_GLO_CFG);\n\n\tval &= MT_WPDMA_GLO_CFG_DMA_BURST_SIZE |\n\t       MT_WPDMA_GLO_CFG_BIG_ENDIAN |\n\t       MT_WPDMA_GLO_CFG_HDR_SEG_LEN;\n\tval |= MT_WPDMA_GLO_CFG_TX_WRITEBACK_DONE;\n\tmt76_wr(dev, MT_WPDMA_GLO_CFG, val);\n}\nEXPORT_SYMBOL_GPL(mt76x02_dma_disable);\n\nvoid mt76x02_mac_start(struct mt76x02_dev *dev)\n{\n\tmt76x02_mac_reset_counters(dev);\n\tmt76x02_dma_enable(dev);\n\tmt76_wr(dev, MT_RX_FILTR_CFG, dev->mt76.rxfilter);\n\tmt76_wr(dev, MT_MAC_SYS_CTRL,\n\t\tMT_MAC_SYS_CTRL_ENABLE_TX |\n\t\tMT_MAC_SYS_CTRL_ENABLE_RX);\n\tmt76x02_irq_enable(dev,\n\t\t\t   MT_INT_RX_DONE_ALL | MT_INT_TX_DONE_ALL |\n\t\t\t   MT_INT_TX_STAT);\n}\nEXPORT_SYMBOL_GPL(mt76x02_mac_start);\n\nstatic bool mt76x02_tx_hang(struct mt76x02_dev *dev)\n{\n\tu32 dma_idx, prev_dma_idx;\n\tstruct mt76_queue *q;\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tq = dev->mphy.q_tx[i];\n\n\t\tprev_dma_idx = dev->mt76.tx_dma_idx[i];\n\t\tdma_idx = readl(&q->regs->dma_idx);\n\t\tdev->mt76.tx_dma_idx[i] = dma_idx;\n\n\t\tif (!q->queued || prev_dma_idx != dma_idx) {\n\t\t\tdev->tx_hang_check[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (++dev->tx_hang_check[i] >= MT_TX_HANG_TH)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void mt76x02_key_sync(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_sta *sta,\n\t\t\t     struct ieee80211_key_conf *key, void *data)\n{\n\tstruct mt76x02_dev *dev = hw->priv;\n\tstruct mt76_wcid *wcid;\n\n\tif (!sta)\n\t\treturn;\n\n\twcid = (struct mt76_wcid *)sta->drv_priv;\n\n\tif (wcid->hw_key_idx != key->keyidx || wcid->sw_iv)\n\t\treturn;\n\n\tmt76x02_mac_wcid_sync_pn(dev, wcid->idx, key);\n}\n\nstatic void mt76x02_reset_state(struct mt76x02_dev *dev)\n{\n\tint i;\n\n\tlockdep_assert_held(&dev->mt76.mutex);\n\n\tclear_bit(MT76_STATE_RUNNING, &dev->mphy.state);\n\n\trcu_read_lock();\n\tieee80211_iter_keys_rcu(dev->mt76.hw, NULL, mt76x02_key_sync, NULL);\n\trcu_read_unlock();\n\n\tfor (i = 0; i < MT76x02_N_WCIDS; i++) {\n\t\tstruct ieee80211_sta *sta;\n\t\tstruct ieee80211_vif *vif;\n\t\tstruct mt76x02_sta *msta;\n\t\tstruct mt76_wcid *wcid;\n\t\tvoid *priv;\n\n\t\twcid = rcu_dereference_protected(dev->mt76.wcid[i],\n\t\t\t\t\tlockdep_is_held(&dev->mt76.mutex));\n\t\tif (!wcid)\n\t\t\tcontinue;\n\n\t\trcu_assign_pointer(dev->mt76.wcid[i], NULL);\n\n\t\tpriv = msta = container_of(wcid, struct mt76x02_sta, wcid);\n\t\tsta = container_of(priv, struct ieee80211_sta, drv_priv);\n\n\t\tpriv = msta->vif;\n\t\tvif = container_of(priv, struct ieee80211_vif, drv_priv);\n\n\t\t__mt76_sta_remove(&dev->mt76, vif, sta);\n\t\tmemset(msta, 0, sizeof(*msta));\n\t}\n\n\tdev->mt76.vif_mask = 0;\n\tdev->mt76.beacon_mask = 0;\n}\n\nstatic void mt76x02_watchdog_reset(struct mt76x02_dev *dev)\n{\n\tu32 mask = dev->mt76.mmio.irqmask;\n\tbool restart = dev->mt76.mcu_ops->mcu_restart;\n\tint i;\n\n\tieee80211_stop_queues(dev->mt76.hw);\n\tset_bit(MT76_RESET, &dev->mphy.state);\n\n\ttasklet_disable(&dev->mt76.pre_tbtt_tasklet);\n\tmt76_worker_disable(&dev->mt76.tx_worker);\n\tnapi_disable(&dev->mt76.tx_napi);\n\n\tmt76_for_each_q_rx(&dev->mt76, i) {\n\t\tnapi_disable(&dev->mt76.napi[i]);\n\t}\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tdev->mcu_timeout = 0;\n\tif (restart)\n\t\tmt76x02_reset_state(dev);\n\n\tif (dev->mt76.beacon_mask)\n\t\tmt76_clear(dev, MT_BEACON_TIME_CFG,\n\t\t\t   MT_BEACON_TIME_CFG_BEACON_TX |\n\t\t\t   MT_BEACON_TIME_CFG_TBTT_EN);\n\n\tmt76x02_irq_disable(dev, mask);\n\n\t \n\tmt76_clear(dev, MT_TXOP_CTRL_CFG, MT_TXOP_ED_CCA_EN);\n\tmt76_wr(dev, MT_MAC_SYS_CTRL, 0);\n\tmt76_clear(dev, MT_WPDMA_GLO_CFG,\n\t\t   MT_WPDMA_GLO_CFG_TX_DMA_EN | MT_WPDMA_GLO_CFG_RX_DMA_EN);\n\tusleep_range(5000, 10000);\n\tmt76_wr(dev, MT_INT_SOURCE_CSR, 0xffffffff);\n\n\t \n\tmt76_set(dev, 0x734, 0x3);\n\n\tif (restart)\n\t\tmt76_mcu_restart(dev);\n\n\tmt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[MT_MCUQ_WM], true);\n\tfor (i = 0; i < __MT_TXQ_MAX; i++)\n\t\tmt76_queue_tx_cleanup(dev, dev->mphy.q_tx[i], true);\n\n\tmt76_for_each_q_rx(&dev->mt76, i) {\n\t\tmt76_queue_rx_reset(dev, i);\n\t}\n\n\tmt76_tx_status_check(&dev->mt76, true);\n\n\tmt76x02_mac_start(dev);\n\n\tif (dev->ed_monitor)\n\t\tmt76_set(dev, MT_TXOP_CTRL_CFG, MT_TXOP_ED_CCA_EN);\n\n\tif (dev->mt76.beacon_mask && !restart)\n\t\tmt76_set(dev, MT_BEACON_TIME_CFG,\n\t\t\t MT_BEACON_TIME_CFG_BEACON_TX |\n\t\t\t MT_BEACON_TIME_CFG_TBTT_EN);\n\n\tmt76x02_irq_enable(dev, mask);\n\n\tmutex_unlock(&dev->mt76.mutex);\n\n\tclear_bit(MT76_RESET, &dev->mphy.state);\n\n\tmt76_worker_enable(&dev->mt76.tx_worker);\n\ttasklet_enable(&dev->mt76.pre_tbtt_tasklet);\n\n\tlocal_bh_disable();\n\tnapi_enable(&dev->mt76.tx_napi);\n\tnapi_schedule(&dev->mt76.tx_napi);\n\n\tmt76_for_each_q_rx(&dev->mt76, i) {\n\t\tnapi_enable(&dev->mt76.napi[i]);\n\t\tnapi_schedule(&dev->mt76.napi[i]);\n\t}\n\tlocal_bh_enable();\n\n\tif (restart) {\n\t\tset_bit(MT76_RESTART, &dev->mphy.state);\n\t\tmt76x02_mcu_function_select(dev, Q_SELECT, 1);\n\t\tieee80211_restart_hw(dev->mt76.hw);\n\t} else {\n\t\tieee80211_wake_queues(dev->mt76.hw);\n\t\tmt76_txq_schedule_all(&dev->mphy);\n\t}\n}\n\nvoid mt76x02_reconfig_complete(struct ieee80211_hw *hw,\n\t\t\t       enum ieee80211_reconfig_type reconfig_type)\n{\n\tstruct mt76x02_dev *dev = hw->priv;\n\n\tif (reconfig_type != IEEE80211_RECONFIG_TYPE_RESTART)\n\t\treturn;\n\n\tclear_bit(MT76_RESTART, &dev->mphy.state);\n}\nEXPORT_SYMBOL_GPL(mt76x02_reconfig_complete);\n\nstatic void mt76x02_check_tx_hang(struct mt76x02_dev *dev)\n{\n\tif (test_bit(MT76_RESTART, &dev->mphy.state))\n\t\treturn;\n\n\tif (!mt76x02_tx_hang(dev) && !dev->mcu_timeout)\n\t\treturn;\n\n\tmt76x02_watchdog_reset(dev);\n\n\tdev->tx_hang_reset++;\n\tmemset(dev->tx_hang_check, 0, sizeof(dev->tx_hang_check));\n\tmemset(dev->mt76.tx_dma_idx, 0xff,\n\t       sizeof(dev->mt76.tx_dma_idx));\n}\n\nvoid mt76x02_wdt_work(struct work_struct *work)\n{\n\tstruct mt76x02_dev *dev = container_of(work, struct mt76x02_dev,\n\t\t\t\t\t       wdt_work.work);\n\n\tmt76x02_check_tx_hang(dev);\n\n\tieee80211_queue_delayed_work(mt76_hw(dev), &dev->wdt_work,\n\t\t\t\t     MT_WATCHDOG_TIME);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}