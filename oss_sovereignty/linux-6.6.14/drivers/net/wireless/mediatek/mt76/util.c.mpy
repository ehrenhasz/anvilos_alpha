{
  "module_name": "util.c",
  "hash_id": "938159bc7ebd9cd9e18f387aae2eeb806a627611a1548c293046162756f2b18d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/util.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include \"mt76.h\"\n\nbool __mt76_poll(struct mt76_dev *dev, u32 offset, u32 mask, u32 val,\n\t\t int timeout)\n{\n\tu32 cur;\n\n\ttimeout /= 10;\n\tdo {\n\t\tcur = __mt76_rr(dev, offset) & mask;\n\t\tif (cur == val)\n\t\t\treturn true;\n\n\t\tudelay(10);\n\t} while (timeout-- > 0);\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(__mt76_poll);\n\nbool ____mt76_poll_msec(struct mt76_dev *dev, u32 offset, u32 mask, u32 val,\n\t\t\tint timeout, int tick)\n{\n\tu32 cur;\n\n\ttimeout /= tick;\n\tdo {\n\t\tcur = __mt76_rr(dev, offset) & mask;\n\t\tif (cur == val)\n\t\t\treturn true;\n\n\t\tusleep_range(1000 * tick, 2000 * tick);\n\t} while (timeout-- > 0);\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(____mt76_poll_msec);\n\nint mt76_wcid_alloc(u32 *mask, int size)\n{\n\tint i, idx = 0, cur;\n\n\tfor (i = 0; i < DIV_ROUND_UP(size, 32); i++) {\n\t\tidx = ffs(~mask[i]);\n\t\tif (!idx)\n\t\t\tcontinue;\n\n\t\tidx--;\n\t\tcur = i * 32 + idx;\n\t\tif (cur >= size)\n\t\t\tbreak;\n\n\t\tmask[i] |= BIT(idx);\n\t\treturn cur;\n\t}\n\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(mt76_wcid_alloc);\n\nint mt76_get_min_avg_rssi(struct mt76_dev *dev, bool ext_phy)\n{\n\tstruct mt76_wcid *wcid;\n\tint i, j, min_rssi = 0;\n\ts8 cur_rssi;\n\n\tlocal_bh_disable();\n\trcu_read_lock();\n\n\tfor (i = 0; i < ARRAY_SIZE(dev->wcid_mask); i++) {\n\t\tu32 mask = dev->wcid_mask[i];\n\t\tu32 phy_mask = dev->wcid_phy_mask[i];\n\n\t\tif (!mask)\n\t\t\tcontinue;\n\n\t\tfor (j = i * 32; mask; j++, mask >>= 1, phy_mask >>= 1) {\n\t\t\tif (!(mask & 1))\n\t\t\t\tcontinue;\n\n\t\t\tif (!!(phy_mask & 1) != ext_phy)\n\t\t\t\tcontinue;\n\n\t\t\twcid = rcu_dereference(dev->wcid[j]);\n\t\t\tif (!wcid)\n\t\t\t\tcontinue;\n\n\t\t\tspin_lock(&dev->rx_lock);\n\t\t\tif (wcid->inactive_count++ < 5)\n\t\t\t\tcur_rssi = -ewma_signal_read(&wcid->rssi);\n\t\t\telse\n\t\t\t\tcur_rssi = 0;\n\t\t\tspin_unlock(&dev->rx_lock);\n\n\t\t\tif (cur_rssi < min_rssi)\n\t\t\t\tmin_rssi = cur_rssi;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\tlocal_bh_enable();\n\n\treturn min_rssi;\n}\nEXPORT_SYMBOL_GPL(mt76_get_min_avg_rssi);\n\nint __mt76_worker_fn(void *ptr)\n{\n\tstruct mt76_worker *w = ptr;\n\n\twhile (!kthread_should_stop()) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tif (kthread_should_park()) {\n\t\t\tkthread_parkme();\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!test_and_clear_bit(MT76_WORKER_SCHEDULED, &w->state)) {\n\t\t\tschedule();\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_bit(MT76_WORKER_RUNNING, &w->state);\n\t\tset_current_state(TASK_RUNNING);\n\t\tw->fn(w);\n\t\tcond_resched();\n\t\tclear_bit(MT76_WORKER_RUNNING, &w->state);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__mt76_worker_fn);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}