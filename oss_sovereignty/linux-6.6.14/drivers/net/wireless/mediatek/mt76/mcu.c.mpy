{
  "module_name": "mcu.c",
  "hash_id": "bdacd4e3386a78a463bf15da32456130c0634e658d912e07b61e3c72647885e4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mcu.c",
  "human_readable_source": "\n \n\n#include \"mt76.h\"\n\nstruct sk_buff *\n__mt76_mcu_msg_alloc(struct mt76_dev *dev, const void *data,\n\t\t     int len, int data_len, gfp_t gfp)\n{\n\tconst struct mt76_mcu_ops *ops = dev->mcu_ops;\n\tstruct sk_buff *skb;\n\n\tlen = max_t(int, len, data_len);\n\tlen = ops->headroom + len + ops->tailroom;\n\n\tskb = alloc_skb(len, gfp);\n\tif (!skb)\n\t\treturn NULL;\n\n\tmemset(skb->head, 0, len);\n\tskb_reserve(skb, ops->headroom);\n\n\tif (data && data_len)\n\t\tskb_put_data(skb, data, data_len);\n\n\treturn skb;\n}\nEXPORT_SYMBOL_GPL(__mt76_mcu_msg_alloc);\n\nstruct sk_buff *mt76_mcu_get_response(struct mt76_dev *dev,\n\t\t\t\t      unsigned long expires)\n{\n\tunsigned long timeout;\n\n\tif (!time_is_after_jiffies(expires))\n\t\treturn NULL;\n\n\ttimeout = expires - jiffies;\n\twait_event_timeout(dev->mcu.wait,\n\t\t\t   (!skb_queue_empty(&dev->mcu.res_q) ||\n\t\t\t    test_bit(MT76_MCU_RESET, &dev->phy.state)),\n\t\t\t   timeout);\n\treturn skb_dequeue(&dev->mcu.res_q);\n}\nEXPORT_SYMBOL_GPL(mt76_mcu_get_response);\n\nvoid mt76_mcu_rx_event(struct mt76_dev *dev, struct sk_buff *skb)\n{\n\tskb_queue_tail(&dev->mcu.res_q, skb);\n\twake_up(&dev->mcu.wait);\n}\nEXPORT_SYMBOL_GPL(mt76_mcu_rx_event);\n\nint mt76_mcu_send_and_get_msg(struct mt76_dev *dev, int cmd, const void *data,\n\t\t\t      int len, bool wait_resp, struct sk_buff **ret_skb)\n{\n\tstruct sk_buff *skb;\n\n\tif (dev->mcu_ops->mcu_send_msg)\n\t\treturn dev->mcu_ops->mcu_send_msg(dev, cmd, data, len, wait_resp);\n\n\tskb = mt76_mcu_msg_alloc(dev, data, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\treturn mt76_mcu_skb_send_and_get_msg(dev, skb, cmd, wait_resp, ret_skb);\n}\nEXPORT_SYMBOL_GPL(mt76_mcu_send_and_get_msg);\n\nint mt76_mcu_skb_send_and_get_msg(struct mt76_dev *dev, struct sk_buff *skb,\n\t\t\t\t  int cmd, bool wait_resp,\n\t\t\t\t  struct sk_buff **ret_skb)\n{\n\tunsigned long expires;\n\tint ret, seq;\n\n\tif (ret_skb)\n\t\t*ret_skb = NULL;\n\n\tmutex_lock(&dev->mcu.mutex);\n\n\tret = dev->mcu_ops->mcu_skb_send_msg(dev, skb, cmd, &seq);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!wait_resp) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\texpires = jiffies + dev->mcu.timeout;\n\n\tdo {\n\t\tskb = mt76_mcu_get_response(dev, expires);\n\t\tret = dev->mcu_ops->mcu_parse_response(dev, cmd, skb, seq);\n\t\tif (!ret && ret_skb)\n\t\t\t*ret_skb = skb;\n\t\telse\n\t\t\tdev_kfree_skb(skb);\n\t} while (ret == -EAGAIN);\n\nout:\n\tmutex_unlock(&dev->mcu.mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mt76_mcu_skb_send_and_get_msg);\n\nint __mt76_mcu_send_firmware(struct mt76_dev *dev, int cmd, const void *data,\n\t\t\t     int len, int max_len)\n{\n\tint err, cur_len;\n\n\twhile (len > 0) {\n\t\tcur_len = min_t(int, max_len, len);\n\n\t\terr = mt76_mcu_send_msg(dev, cmd, data, cur_len, false);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tdata += cur_len;\n\t\tlen -= cur_len;\n\n\t\tif (dev->queue_ops->tx_cleanup)\n\t\t\tdev->queue_ops->tx_cleanup(dev,\n\t\t\t\t\t\t   dev->q_mcu[MT_MCUQ_FWDL],\n\t\t\t\t\t\t   false);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__mt76_mcu_send_firmware);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}