{
  "module_name": "mt792x_core.c",
  "hash_id": "b0466c8bb9d05879cd63ec94d51ab3c48b9861be9ca4a4f7b5127407377dde81",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt792x_core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/firmware.h>\n\n#include \"mt792x.h\"\n#include \"dma.h\"\n\nstatic const struct ieee80211_iface_limit if_limits[] = {\n\t{\n\t\t.max = MT792x_MAX_INTERFACES,\n\t\t.types = BIT(NL80211_IFTYPE_STATION)\n\t},\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_AP)\n\t}\n};\n\nstatic const struct ieee80211_iface_combination if_comb[] = {\n\t{\n\t\t.limits = if_limits,\n\t\t.n_limits = ARRAY_SIZE(if_limits),\n\t\t.max_interfaces = MT792x_MAX_INTERFACES,\n\t\t.num_different_channels = 1,\n\t\t.beacon_int_infra_match = true,\n\t},\n};\n\nstatic const struct ieee80211_iface_limit if_limits_chanctx[] = {\n\t{\n\t\t.max = 2,\n\t\t.types = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t BIT(NL80211_IFTYPE_P2P_CLIENT)\n\t},\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_AP) |\n\t\t\t BIT(NL80211_IFTYPE_P2P_GO)\n\t}\n};\n\nstatic const struct ieee80211_iface_combination if_comb_chanctx[] = {\n\t{\n\t\t.limits = if_limits_chanctx,\n\t\t.n_limits = ARRAY_SIZE(if_limits_chanctx),\n\t\t.max_interfaces = 2,\n\t\t.num_different_channels = 2,\n\t\t.beacon_int_infra_match = false,\n\t}\n};\n\nvoid mt792x_tx(struct ieee80211_hw *hw, struct ieee80211_tx_control *control,\n\t       struct sk_buff *skb)\n{\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\tstruct mt76_phy *mphy = hw->priv;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_vif *vif = info->control.vif;\n\tstruct mt76_wcid *wcid = &dev->mt76.global_wcid;\n\tint qid;\n\n\tif (control->sta) {\n\t\tstruct mt792x_sta *sta;\n\n\t\tsta = (struct mt792x_sta *)control->sta->drv_priv;\n\t\twcid = &sta->wcid;\n\t}\n\n\tif (vif && !control->sta) {\n\t\tstruct mt792x_vif *mvif;\n\n\t\tmvif = (struct mt792x_vif *)vif->drv_priv;\n\t\twcid = &mvif->sta.wcid;\n\t}\n\n\tif (mt76_connac_pm_ref(mphy, &dev->pm)) {\n\t\tmt76_tx(mphy, control->sta, wcid, skb);\n\t\tmt76_connac_pm_unref(mphy, &dev->pm);\n\t\treturn;\n\t}\n\n\tqid = skb_get_queue_mapping(skb);\n\tif (qid >= MT_TXQ_PSD) {\n\t\tqid = IEEE80211_AC_BE;\n\t\tskb_set_queue_mapping(skb, qid);\n\t}\n\n\tmt76_connac_pm_queue_skb(hw, &dev->pm, wcid, skb);\n}\nEXPORT_SYMBOL_GPL(mt792x_tx);\n\nvoid mt792x_remove_interface(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tstruct mt792x_sta *msta = &mvif->sta;\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\tstruct mt792x_phy *phy = mt792x_hw_phy(hw);\n\tint idx = msta->wcid.idx;\n\n\tmt792x_mutex_acquire(dev);\n\tmt76_connac_free_pending_tx_skbs(&dev->pm, &msta->wcid);\n\tmt76_connac_mcu_uni_add_dev(&dev->mphy, vif, &mvif->sta.wcid, false);\n\n\trcu_assign_pointer(dev->mt76.wcid[idx], NULL);\n\n\tdev->mt76.vif_mask &= ~BIT_ULL(mvif->mt76.idx);\n\tphy->omac_mask &= ~BIT_ULL(mvif->mt76.omac_idx);\n\tmt792x_mutex_release(dev);\n\n\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\tif (!list_empty(&msta->wcid.poll_list))\n\t\tlist_del_init(&msta->wcid.poll_list);\n\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\n\tmt76_packet_id_flush(&dev->mt76, &msta->wcid);\n}\nEXPORT_SYMBOL_GPL(mt792x_remove_interface);\n\nint mt792x_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t   unsigned int link_id, u16 queue,\n\t\t   const struct ieee80211_tx_queue_params *params)\n{\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\n\t \n\tqueue = mt76_connac_lmac_mapping(queue);\n\tmvif->queue_params[queue] = *params;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt792x_conf_tx);\n\nint mt792x_get_stats(struct ieee80211_hw *hw,\n\t\t     struct ieee80211_low_level_stats *stats)\n{\n\tstruct mt792x_phy *phy = mt792x_hw_phy(hw);\n\tstruct mt76_mib_stats *mib = &phy->mib;\n\n\tmt792x_mutex_acquire(phy->dev);\n\n\tstats->dot11RTSSuccessCount = mib->rts_cnt;\n\tstats->dot11RTSFailureCount = mib->rts_retries_cnt;\n\tstats->dot11FCSErrorCount = mib->fcs_err_cnt;\n\tstats->dot11ACKFailureCount = mib->ack_fail_cnt;\n\n\tmt792x_mutex_release(phy->dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt792x_get_stats);\n\nu64 mt792x_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\tu8 omac_idx = mvif->mt76.omac_idx;\n\tunion {\n\t\tu64 t64;\n\t\tu32 t32[2];\n\t} tsf;\n\tu16 n;\n\n\tmt792x_mutex_acquire(dev);\n\n\tn = omac_idx > HW_BSSID_MAX ? HW_BSSID_0 : omac_idx;\n\t \n\tmt76_set(dev, MT_LPON_TCR(0, n), MT_LPON_TCR_SW_MODE);\n\ttsf.t32[0] = mt76_rr(dev, MT_LPON_UTTR0(0));\n\ttsf.t32[1] = mt76_rr(dev, MT_LPON_UTTR1(0));\n\n\tmt792x_mutex_release(dev);\n\n\treturn tsf.t64;\n}\nEXPORT_SYMBOL_GPL(mt792x_get_tsf);\n\nvoid mt792x_set_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t    u64 timestamp)\n{\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\tu8 omac_idx = mvif->mt76.omac_idx;\n\tunion {\n\t\tu64 t64;\n\t\tu32 t32[2];\n\t} tsf = { .t64 = timestamp, };\n\tu16 n;\n\n\tmt792x_mutex_acquire(dev);\n\n\tn = omac_idx > HW_BSSID_MAX ? HW_BSSID_0 : omac_idx;\n\tmt76_wr(dev, MT_LPON_UTTR0(0), tsf.t32[0]);\n\tmt76_wr(dev, MT_LPON_UTTR1(0), tsf.t32[1]);\n\t \n\tmt76_set(dev, MT_LPON_TCR(0, n), MT_LPON_TCR_SW_WRITE);\n\n\tmt792x_mutex_release(dev);\n}\nEXPORT_SYMBOL_GPL(mt792x_set_tsf);\n\nvoid mt792x_tx_worker(struct mt76_worker *w)\n{\n\tstruct mt792x_dev *dev = container_of(w, struct mt792x_dev,\n\t\t\t\t\t      mt76.tx_worker);\n\n\tif (!mt76_connac_pm_ref(&dev->mphy, &dev->pm)) {\n\t\tqueue_work(dev->mt76.wq, &dev->pm.wake_work);\n\t\treturn;\n\t}\n\n\tmt76_txq_schedule_all(&dev->mphy);\n\tmt76_connac_pm_unref(&dev->mphy, &dev->pm);\n}\nEXPORT_SYMBOL_GPL(mt792x_tx_worker);\n\nvoid mt792x_roc_timer(struct timer_list *timer)\n{\n\tstruct mt792x_phy *phy = from_timer(phy, timer, roc_timer);\n\n\tieee80211_queue_work(phy->mt76->hw, &phy->roc_work);\n}\nEXPORT_SYMBOL_GPL(mt792x_roc_timer);\n\nvoid mt792x_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t  u32 queues, bool drop)\n{\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\n\twait_event_timeout(dev->mt76.tx_wait,\n\t\t\t   !mt76_has_tx_pending(&dev->mphy), HZ / 2);\n}\nEXPORT_SYMBOL_GPL(mt792x_flush);\n\nint mt792x_assign_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_bss_conf *link_conf,\n\t\t\t      struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\n\tmutex_lock(&dev->mt76.mutex);\n\tmvif->mt76.ctx = ctx;\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt792x_assign_vif_chanctx);\n\nvoid mt792x_unassign_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_bss_conf *link_conf,\n\t\t\t\t struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\n\tmutex_lock(&dev->mt76.mutex);\n\tmvif->mt76.ctx = NULL;\n\tmutex_unlock(&dev->mt76.mutex);\n}\nEXPORT_SYMBOL_GPL(mt792x_unassign_vif_chanctx);\n\nvoid mt792x_set_wakeup(struct ieee80211_hw *hw, bool enabled)\n{\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\tstruct mt76_dev *mdev = &dev->mt76;\n\n\tdevice_set_wakeup_enable(mdev->dev, enabled);\n}\nEXPORT_SYMBOL_GPL(mt792x_set_wakeup);\n\nstatic const char mt792x_gstrings_stats[][ETH_GSTRING_LEN] = {\n\t \n\t\"tx_ampdu_cnt\",\n\t\"tx_mpdu_attempts\",\n\t\"tx_mpdu_success\",\n\t\"tx_pkt_ebf_cnt\",\n\t\"tx_pkt_ibf_cnt\",\n\t\"tx_ampdu_len:0-1\",\n\t\"tx_ampdu_len:2-10\",\n\t\"tx_ampdu_len:11-19\",\n\t\"tx_ampdu_len:20-28\",\n\t\"tx_ampdu_len:29-37\",\n\t\"tx_ampdu_len:38-46\",\n\t\"tx_ampdu_len:47-55\",\n\t\"tx_ampdu_len:56-79\",\n\t\"tx_ampdu_len:80-103\",\n\t\"tx_ampdu_len:104-127\",\n\t\"tx_ampdu_len:128-151\",\n\t\"tx_ampdu_len:152-175\",\n\t\"tx_ampdu_len:176-199\",\n\t\"tx_ampdu_len:200-223\",\n\t\"tx_ampdu_len:224-247\",\n\t\"ba_miss_count\",\n\t\"tx_beamformer_ppdu_iBF\",\n\t\"tx_beamformer_ppdu_eBF\",\n\t\"tx_beamformer_rx_feedback_all\",\n\t\"tx_beamformer_rx_feedback_he\",\n\t\"tx_beamformer_rx_feedback_vht\",\n\t\"tx_beamformer_rx_feedback_ht\",\n\t\"tx_msdu_pack_1\",\n\t\"tx_msdu_pack_2\",\n\t\"tx_msdu_pack_3\",\n\t\"tx_msdu_pack_4\",\n\t\"tx_msdu_pack_5\",\n\t\"tx_msdu_pack_6\",\n\t\"tx_msdu_pack_7\",\n\t\"tx_msdu_pack_8\",\n\t \n\t\"rx_mpdu_cnt\",\n\t\"rx_ampdu_cnt\",\n\t\"rx_ampdu_bytes_cnt\",\n\t\"rx_ba_cnt\",\n\t \n\t\"v_tx_mode_cck\",\n\t\"v_tx_mode_ofdm\",\n\t\"v_tx_mode_ht\",\n\t\"v_tx_mode_ht_gf\",\n\t\"v_tx_mode_vht\",\n\t\"v_tx_mode_he_su\",\n\t\"v_tx_mode_he_ext_su\",\n\t\"v_tx_mode_he_tb\",\n\t\"v_tx_mode_he_mu\",\n\t\"v_tx_mode_eht_su\",\n\t\"v_tx_mode_eht_trig\",\n\t\"v_tx_mode_eht_mu\",\n\t\"v_tx_bw_20\",\n\t\"v_tx_bw_40\",\n\t\"v_tx_bw_80\",\n\t\"v_tx_bw_160\",\n\t\"v_tx_mcs_0\",\n\t\"v_tx_mcs_1\",\n\t\"v_tx_mcs_2\",\n\t\"v_tx_mcs_3\",\n\t\"v_tx_mcs_4\",\n\t\"v_tx_mcs_5\",\n\t\"v_tx_mcs_6\",\n\t\"v_tx_mcs_7\",\n\t\"v_tx_mcs_8\",\n\t\"v_tx_mcs_9\",\n\t\"v_tx_mcs_10\",\n\t\"v_tx_mcs_11\",\n\t\"v_tx_mcs_12\",\n\t\"v_tx_mcs_13\",\n\t\"v_tx_nss_1\",\n\t\"v_tx_nss_2\",\n\t\"v_tx_nss_3\",\n\t\"v_tx_nss_4\",\n};\n\nvoid mt792x_get_et_strings(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t   u32 sset, u8 *data)\n{\n\tif (sset != ETH_SS_STATS)\n\t\treturn;\n\n\tmemcpy(data, mt792x_gstrings_stats, sizeof(mt792x_gstrings_stats));\n\n\tdata += sizeof(mt792x_gstrings_stats);\n\tpage_pool_ethtool_stats_get_strings(data);\n}\nEXPORT_SYMBOL_GPL(mt792x_get_et_strings);\n\nint mt792x_get_et_sset_count(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t     int sset)\n{\n\tif (sset != ETH_SS_STATS)\n\t\treturn 0;\n\n\treturn ARRAY_SIZE(mt792x_gstrings_stats) +\n\t       page_pool_ethtool_stats_get_count();\n}\nEXPORT_SYMBOL_GPL(mt792x_get_et_sset_count);\n\nstatic void\nmt792x_ethtool_worker(void *wi_data, struct ieee80211_sta *sta)\n{\n\tstruct mt792x_sta *msta = (struct mt792x_sta *)sta->drv_priv;\n\tstruct mt76_ethtool_worker_info *wi = wi_data;\n\n\tif (msta->vif->mt76.idx != wi->idx)\n\t\treturn;\n\n\tmt76_ethtool_worker(wi, &msta->wcid.stats, true);\n}\n\nvoid mt792x_get_et_stats(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t struct ethtool_stats *stats, u64 *data)\n{\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tint stats_size = ARRAY_SIZE(mt792x_gstrings_stats);\n\tstruct mt792x_phy *phy = mt792x_hw_phy(hw);\n\tstruct mt792x_dev *dev = phy->dev;\n\tstruct mt76_mib_stats *mib = &phy->mib;\n\tstruct mt76_ethtool_worker_info wi = {\n\t\t.data = data,\n\t\t.idx = mvif->mt76.idx,\n\t};\n\tint i, ei = 0;\n\n\tmt792x_mutex_acquire(dev);\n\n\tmt792x_mac_update_mib_stats(phy);\n\n\tdata[ei++] = mib->tx_ampdu_cnt;\n\tdata[ei++] = mib->tx_mpdu_attempts_cnt;\n\tdata[ei++] = mib->tx_mpdu_success_cnt;\n\tdata[ei++] = mib->tx_pkt_ebf_cnt;\n\tdata[ei++] = mib->tx_pkt_ibf_cnt;\n\n\t \n\tfor (i = 0; i < 15; i++)\n\t\tdata[ei++] = phy->mt76->aggr_stats[i];\n\n\tdata[ei++] = phy->mib.ba_miss_cnt;\n\n\t \n\tdata[ei++] = mib->tx_bf_ibf_ppdu_cnt;\n\tdata[ei++] = mib->tx_bf_ebf_ppdu_cnt;\n\n\t \n\tdata[ei++] = mib->tx_bf_rx_fb_all_cnt;\n\tdata[ei++] = mib->tx_bf_rx_fb_he_cnt;\n\tdata[ei++] = mib->tx_bf_rx_fb_vht_cnt;\n\tdata[ei++] = mib->tx_bf_rx_fb_ht_cnt;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(mib->tx_amsdu); i++)\n\t\tdata[ei++] = mib->tx_amsdu[i];\n\n\t \n\tdata[ei++] = mib->rx_mpdu_cnt;\n\tdata[ei++] = mib->rx_ampdu_cnt;\n\tdata[ei++] = mib->rx_ampdu_bytes_cnt;\n\tdata[ei++] = mib->rx_ba_cnt;\n\n\t \n\twi.initial_stat_idx = ei;\n\tieee80211_iterate_stations_atomic(hw, mt792x_ethtool_worker, &wi);\n\n\tmt792x_mutex_release(dev);\n\n\tif (!wi.sta_count)\n\t\treturn;\n\n\tei += wi.worker_stat_count;\n\n\tmt76_ethtool_page_pool_stats(&dev->mt76, &data[ei], &ei);\n\tstats_size += page_pool_ethtool_stats_get_count();\n\n\tif (ei != stats_size)\n\t\tdev_err(dev->mt76.dev, \"ei: %d  SSTATS_LEN: %d\", ei,\n\t\t\tstats_size);\n}\nEXPORT_SYMBOL_GPL(mt792x_get_et_stats);\n\nvoid mt792x_sta_statistics(struct ieee80211_hw *hw,\n\t\t\t   struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_sta *sta,\n\t\t\t   struct station_info *sinfo)\n{\n\tstruct mt792x_sta *msta = (struct mt792x_sta *)sta->drv_priv;\n\tstruct rate_info *txrate = &msta->wcid.rate;\n\n\tif (!txrate->legacy && !txrate->flags)\n\t\treturn;\n\n\tif (txrate->legacy) {\n\t\tsinfo->txrate.legacy = txrate->legacy;\n\t} else {\n\t\tsinfo->txrate.mcs = txrate->mcs;\n\t\tsinfo->txrate.nss = txrate->nss;\n\t\tsinfo->txrate.bw = txrate->bw;\n\t\tsinfo->txrate.he_gi = txrate->he_gi;\n\t\tsinfo->txrate.he_dcm = txrate->he_dcm;\n\t\tsinfo->txrate.he_ru_alloc = txrate->he_ru_alloc;\n\t}\n\tsinfo->tx_failed = msta->wcid.stats.tx_failed;\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_FAILED);\n\n\tsinfo->tx_retries = msta->wcid.stats.tx_retries;\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_RETRIES);\n\n\tsinfo->txrate.flags = txrate->flags;\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);\n\n\tsinfo->ack_signal = (s8)msta->ack_signal;\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL);\n\n\tsinfo->avg_ack_signal = -(s8)ewma_avg_signal_read(&msta->avg_ack_signal);\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL_AVG);\n}\nEXPORT_SYMBOL_GPL(mt792x_sta_statistics);\n\nvoid mt792x_set_coverage_class(struct ieee80211_hw *hw, s16 coverage_class)\n{\n\tstruct mt792x_phy *phy = mt792x_hw_phy(hw);\n\tstruct mt792x_dev *dev = phy->dev;\n\n\tmt792x_mutex_acquire(dev);\n\n\tphy->coverage_class = max_t(s16, coverage_class, 0);\n\tmt792x_mac_set_timeing(phy);\n\n\tmt792x_mutex_release(dev);\n}\nEXPORT_SYMBOL_GPL(mt792x_set_coverage_class);\n\nint mt792x_init_wiphy(struct ieee80211_hw *hw)\n{\n\tstruct mt792x_phy *phy = mt792x_hw_phy(hw);\n\tstruct mt792x_dev *dev = phy->dev;\n\tstruct wiphy *wiphy = hw->wiphy;\n\n\thw->queues = 4;\n\tif (dev->has_eht) {\n\t\thw->max_rx_aggregation_subframes = IEEE80211_MAX_AMPDU_BUF_EHT;\n\t\thw->max_tx_aggregation_subframes = IEEE80211_MAX_AMPDU_BUF_EHT;\n\t} else {\n\t\thw->max_rx_aggregation_subframes = IEEE80211_MAX_AMPDU_BUF_HE;\n\t\thw->max_tx_aggregation_subframes = IEEE80211_MAX_AMPDU_BUF_HE;\n\t}\n\thw->netdev_features = NETIF_F_RXCSUM;\n\n\thw->radiotap_timestamp.units_pos =\n\t\tIEEE80211_RADIOTAP_TIMESTAMP_UNIT_US;\n\n\tphy->slottime = 9;\n\n\thw->sta_data_size = sizeof(struct mt792x_sta);\n\thw->vif_data_size = sizeof(struct mt792x_vif);\n\n\tif (dev->fw_features & MT792x_FW_CAP_CNM) {\n\t\twiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;\n\t\twiphy->iface_combinations = if_comb_chanctx;\n\t\twiphy->n_iface_combinations = ARRAY_SIZE(if_comb_chanctx);\n\t} else {\n\t\twiphy->flags &= ~WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;\n\t\twiphy->iface_combinations = if_comb;\n\t\twiphy->n_iface_combinations = ARRAY_SIZE(if_comb);\n\t}\n\twiphy->flags &= ~(WIPHY_FLAG_IBSS_RSN | WIPHY_FLAG_4ADDR_AP |\n\t\t\t  WIPHY_FLAG_4ADDR_STATION);\n\twiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t BIT(NL80211_IFTYPE_AP) |\n\t\t\t\t BIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\t\t\t BIT(NL80211_IFTYPE_P2P_GO);\n\twiphy->max_remain_on_channel_duration = 5000;\n\twiphy->max_scan_ie_len = MT76_CONNAC_SCAN_IE_LEN;\n\twiphy->max_scan_ssids = 4;\n\twiphy->max_sched_scan_plan_interval =\n\t\tMT76_CONNAC_MAX_TIME_SCHED_SCAN_INTERVAL;\n\twiphy->max_sched_scan_ie_len = IEEE80211_MAX_DATA_LEN;\n\twiphy->max_sched_scan_ssids = MT76_CONNAC_MAX_SCHED_SCAN_SSID;\n\twiphy->max_match_sets = MT76_CONNAC_MAX_SCAN_MATCH;\n\twiphy->max_sched_scan_reqs = 1;\n\twiphy->flags |= WIPHY_FLAG_HAS_CHANNEL_SWITCH |\n\t\t\tWIPHY_FLAG_SPLIT_SCAN_6GHZ;\n\n\twiphy->features |= NL80211_FEATURE_SCHED_SCAN_RANDOM_MAC_ADDR |\n\t\t\t   NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR;\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_SET_SCAN_DWELL);\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_BEACON_RATE_LEGACY);\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_BEACON_RATE_HT);\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_BEACON_RATE_VHT);\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_BEACON_RATE_HE);\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT);\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_CAN_REPLACE_PTK0);\n\n\tieee80211_hw_set(hw, SINGLE_SCAN_ON_ALL_BANDS);\n\tieee80211_hw_set(hw, HAS_RATE_CONTROL);\n\tieee80211_hw_set(hw, SUPPORTS_TX_ENCAP_OFFLOAD);\n\tieee80211_hw_set(hw, SUPPORTS_RX_DECAP_OFFLOAD);\n\tieee80211_hw_set(hw, WANT_MONITOR_VIF);\n\tieee80211_hw_set(hw, SUPPORTS_PS);\n\tieee80211_hw_set(hw, SUPPORTS_DYNAMIC_PS);\n\tieee80211_hw_set(hw, SUPPORTS_VHT_EXT_NSS_BW);\n\tieee80211_hw_set(hw, CONNECTION_MONITOR);\n\n\tif (dev->pm.enable)\n\t\tieee80211_hw_set(hw, CONNECTION_MONITOR);\n\n\thw->max_tx_fragments = 4;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt792x_init_wiphy);\n\nstatic u8\nmt792x_get_offload_capability(struct device *dev, const char *fw_wm)\n{\n\tconst struct mt76_connac2_fw_trailer *hdr;\n\tstruct mt792x_realease_info *rel_info;\n\tconst struct firmware *fw;\n\tint ret, i, offset = 0;\n\tconst u8 *data, *end;\n\tu8 offload_caps = 0;\n\n\tret = request_firmware(&fw, fw_wm, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!fw || !fw->data || fw->size < sizeof(*hdr)) {\n\t\tdev_err(dev, \"Invalid firmware\\n\");\n\t\tgoto out;\n\t}\n\n\tdata = fw->data;\n\thdr = (const void *)(fw->data + fw->size - sizeof(*hdr));\n\n\tfor (i = 0; i < hdr->n_region; i++) {\n\t\tconst struct mt76_connac2_fw_region *region;\n\n\t\tregion = (const void *)((const u8 *)hdr -\n\t\t\t\t\t(hdr->n_region - i) * sizeof(*region));\n\t\toffset += le32_to_cpu(region->len);\n\t}\n\n\tdata += offset + 16;\n\trel_info = (struct mt792x_realease_info *)data;\n\tdata += sizeof(*rel_info);\n\tend = data + le16_to_cpu(rel_info->len);\n\n\twhile (data < end) {\n\t\trel_info = (struct mt792x_realease_info *)data;\n\t\tdata += sizeof(*rel_info);\n\n\t\tif (rel_info->tag == MT792x_FW_TAG_FEATURE) {\n\t\t\tstruct mt792x_fw_features *features;\n\n\t\t\tfeatures = (struct mt792x_fw_features *)data;\n\t\t\toffload_caps = features->data;\n\t\t\tbreak;\n\t\t}\n\n\t\tdata += le16_to_cpu(rel_info->len) + rel_info->pad_len;\n\t}\n\nout:\n\trelease_firmware(fw);\n\n\treturn offload_caps;\n}\n\nstruct ieee80211_ops *\nmt792x_get_mac80211_ops(struct device *dev,\n\t\t\tconst struct ieee80211_ops *mac80211_ops,\n\t\t\tvoid *drv_data, u8 *fw_features)\n{\n\tstruct ieee80211_ops *ops;\n\n\tops = devm_kmemdup(dev, mac80211_ops, sizeof(struct ieee80211_ops),\n\t\t\t   GFP_KERNEL);\n\tif (!ops)\n\t\treturn NULL;\n\n\t*fw_features = mt792x_get_offload_capability(dev, drv_data);\n\tif (!(*fw_features & MT792x_FW_CAP_CNM)) {\n\t\tops->remain_on_channel = NULL;\n\t\tops->cancel_remain_on_channel = NULL;\n\t\tops->add_chanctx = NULL;\n\t\tops->remove_chanctx = NULL;\n\t\tops->change_chanctx = NULL;\n\t\tops->assign_vif_chanctx = NULL;\n\t\tops->unassign_vif_chanctx = NULL;\n\t\tops->mgd_prepare_tx = NULL;\n\t\tops->mgd_complete_tx = NULL;\n\t}\n\treturn ops;\n}\nEXPORT_SYMBOL_GPL(mt792x_get_mac80211_ops);\n\nint mt792x_init_wcid(struct mt792x_dev *dev)\n{\n\tint idx;\n\n\t \n\tidx = mt76_wcid_alloc(dev->mt76.wcid_mask, MT792x_WTBL_STA - 1);\n\tif (idx)\n\t\treturn -ENOSPC;\n\n\tdev->mt76.global_wcid.idx = idx;\n\tdev->mt76.global_wcid.hw_key_idx = -1;\n\tdev->mt76.global_wcid.tx_info |= MT_WCID_TX_INFO_SET;\n\trcu_assign_pointer(dev->mt76.wcid[idx], &dev->mt76.global_wcid);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt792x_init_wcid);\n\nint mt792x_mcu_drv_pmctrl(struct mt792x_dev *dev)\n{\n\tstruct mt76_phy *mphy = &dev->mt76.phy;\n\tstruct mt76_connac_pm *pm = &dev->pm;\n\tint err = 0;\n\n\tmutex_lock(&pm->mutex);\n\n\tif (!test_bit(MT76_STATE_PM, &mphy->state))\n\t\tgoto out;\n\n\terr = __mt792x_mcu_drv_pmctrl(dev);\nout:\n\tmutex_unlock(&pm->mutex);\n\n\tif (err)\n\t\tmt792x_reset(&dev->mt76);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mt792x_mcu_drv_pmctrl);\n\nint mt792x_mcu_fw_pmctrl(struct mt792x_dev *dev)\n{\n\tstruct mt76_phy *mphy = &dev->mt76.phy;\n\tstruct mt76_connac_pm *pm = &dev->pm;\n\tint err = 0;\n\n\tmutex_lock(&pm->mutex);\n\n\tif (mt76_connac_skip_fw_pmctrl(mphy, pm))\n\t\tgoto out;\n\n\terr = __mt792x_mcu_fw_pmctrl(dev);\nout:\n\tmutex_unlock(&pm->mutex);\n\n\tif (err)\n\t\tmt792x_reset(&dev->mt76);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mt792x_mcu_fw_pmctrl);\n\nint __mt792xe_mcu_drv_pmctrl(struct mt792x_dev *dev)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < MT792x_DRV_OWN_RETRY_COUNT; i++) {\n\t\tmt76_wr(dev, MT_CONN_ON_LPCTL, PCIE_LPCR_HOST_CLR_OWN);\n\t\tif (mt76_poll_msec_tick(dev, MT_CONN_ON_LPCTL,\n\t\t\t\t\tPCIE_LPCR_HOST_OWN_SYNC, 0, 50, 1))\n\t\t\tbreak;\n\t}\n\n\tif (i == MT792x_DRV_OWN_RETRY_COUNT) {\n\t\tdev_err(dev->mt76.dev, \"driver own failed\\n\");\n\t\terr = -EIO;\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(__mt792xe_mcu_drv_pmctrl);\n\nint mt792xe_mcu_drv_pmctrl(struct mt792x_dev *dev)\n{\n\tstruct mt76_phy *mphy = &dev->mt76.phy;\n\tstruct mt76_connac_pm *pm = &dev->pm;\n\tint err;\n\n\terr = __mt792xe_mcu_drv_pmctrl(dev);\n\tif (err < 0)\n\t\tgoto out;\n\n\tmt792x_wpdma_reinit_cond(dev);\n\tclear_bit(MT76_STATE_PM, &mphy->state);\n\n\tpm->stats.last_wake_event = jiffies;\n\tpm->stats.doze_time += pm->stats.last_wake_event -\n\t\t\t       pm->stats.last_doze_event;\nout:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mt792xe_mcu_drv_pmctrl);\n\nint mt792xe_mcu_fw_pmctrl(struct mt792x_dev *dev)\n{\n\tstruct mt76_phy *mphy = &dev->mt76.phy;\n\tstruct mt76_connac_pm *pm = &dev->pm;\n\tint i;\n\n\tfor (i = 0; i < MT792x_DRV_OWN_RETRY_COUNT; i++) {\n\t\tmt76_wr(dev, MT_CONN_ON_LPCTL, PCIE_LPCR_HOST_SET_OWN);\n\t\tif (mt76_poll_msec_tick(dev, MT_CONN_ON_LPCTL,\n\t\t\t\t\tPCIE_LPCR_HOST_OWN_SYNC, 4, 50, 1))\n\t\t\tbreak;\n\t}\n\n\tif (i == MT792x_DRV_OWN_RETRY_COUNT) {\n\t\tdev_err(dev->mt76.dev, \"firmware own failed\\n\");\n\t\tclear_bit(MT76_STATE_PM, &mphy->state);\n\t\treturn -EIO;\n\t}\n\n\tpm->stats.last_doze_event = jiffies;\n\tpm->stats.awake_time += pm->stats.last_doze_event -\n\t\t\t\tpm->stats.last_wake_event;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt792xe_mcu_fw_pmctrl);\n\nint mt792x_load_firmware(struct mt792x_dev *dev)\n{\n\tint ret;\n\n\tret = mt76_connac2_load_patch(&dev->mt76, mt792x_patch_name(dev));\n\tif (ret)\n\t\treturn ret;\n\n\tif (mt76_is_sdio(&dev->mt76)) {\n\t\t \n\t\tret = __mt792x_mcu_fw_pmctrl(dev);\n\t\tif (!ret)\n\t\t\tret = __mt792x_mcu_drv_pmctrl(dev);\n\t}\n\n\tret = mt76_connac2_load_ram(&dev->mt76, mt792x_ram_name(dev), NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!mt76_poll_msec(dev, MT_CONN_ON_MISC, MT_TOP_MISC2_FW_N9_RDY,\n\t\t\t    MT_TOP_MISC2_FW_N9_RDY, 1500)) {\n\t\tdev_err(dev->mt76.dev, \"Timeout for initializing firmware\\n\");\n\n\t\treturn -EIO;\n\t}\n\n#ifdef CONFIG_PM\n\tdev->mt76.hw->wiphy->wowlan = &mt76_connac_wowlan_support;\n#endif  \n\n\tdev_dbg(dev->mt76.dev, \"Firmware init done\\n\");\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt792x_load_firmware);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Lorenzo Bianconi <lorenzo@kernel.org>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}