{
  "module_name": "debugfs.c",
  "hash_id": "28e8706fe88884bd54d511bbca87631814252d68e765b9303853ddaaa9ecd799",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7915/debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/relay.h>\n#include \"mt7915.h\"\n#include \"eeprom.h\"\n#include \"mcu.h\"\n#include \"mac.h\"\n\n#define FW_BIN_LOG_MAGIC\t0x44e98caf\n\n \n\nstruct hw_queue_map {\n\tconst char *name;\n\tu8 index;\n\tu8 pid;\n\tu8 qid;\n};\n\nstatic int\nmt7915_implicit_txbf_set(void *data, u64 val)\n{\n\tstruct mt7915_dev *dev = data;\n\n\t \n\tdev->ibf = !!val;\n\n\treturn mt7915_mcu_set_txbf(dev, MT_BF_TYPE_UPDATE);\n}\n\nstatic int\nmt7915_implicit_txbf_get(void *data, u64 *val)\n{\n\tstruct mt7915_dev *dev = data;\n\n\t*val = dev->ibf;\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_implicit_txbf, mt7915_implicit_txbf_get,\n\t\t\t mt7915_implicit_txbf_set, \"%lld\\n\");\n\n \nstatic ssize_t\nmt7915_sys_recovery_set(struct file *file, const char __user *user_buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct mt7915_phy *phy = file->private_data;\n\tstruct mt7915_dev *dev = phy->dev;\n\tbool band = phy->mt76->band_idx;\n\tchar buf[16];\n\tint ret = 0;\n\tu16 val;\n\n\tif (count >= sizeof(buf))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, user_buf, count))\n\t\treturn -EFAULT;\n\n\tif (count && buf[count - 1] == '\\n')\n\t\tbuf[count - 1] = '\\0';\n\telse\n\t\tbuf[count] = '\\0';\n\n\tif (kstrtou16(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tswitch (val) {\n\t \n\tcase SER_QUERY:\n\t\tret = mt7915_mcu_set_ser(dev, 0, 0, band);\n\t\tbreak;\n\tcase SER_SET_RECOVER_L1:\n\tcase SER_SET_RECOVER_L2:\n\tcase SER_SET_RECOVER_L3_RX_ABORT:\n\tcase SER_SET_RECOVER_L3_TX_ABORT:\n\tcase SER_SET_RECOVER_L3_TX_DISABLE:\n\tcase SER_SET_RECOVER_L3_BF:\n\t\tret = mt7915_mcu_set_ser(dev, SER_ENABLE, BIT(val), band);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = mt7915_mcu_set_ser(dev, SER_RECOVER, val, band);\n\t\tbreak;\n\n\t \n\tcase SER_SET_RECOVER_FULL:\n\t\tmt76_set(dev, MT_WFDMA0_MCU_HOST_INT_ENA, MT_MCU_CMD_WDT_MASK);\n\t\tret = mt7915_mcu_set_ser(dev, 1, 3, band);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdev->recovery.state |= MT_MCU_CMD_WDT_MASK;\n\t\tmt7915_reset(dev);\n\t\tbreak;\n\n\t \n\tcase SER_SET_SYSTEM_ASSERT:\n\t\tmt76_wr(dev, MT_MCU_WM_CIRQ_EINT_MASK_CLR_ADDR, BIT(18));\n\t\tmt76_wr(dev, MT_MCU_WM_CIRQ_EINT_SOFT_ADDR, BIT(18));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret ? ret : count;\n}\n\nstatic ssize_t\nmt7915_sys_recovery_get(struct file *file, char __user *user_buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct mt7915_phy *phy = file->private_data;\n\tstruct mt7915_dev *dev = phy->dev;\n\tchar *buff;\n\tint desc = 0;\n\tssize_t ret;\n\tstatic const size_t bufsz = 1024;\n\n\tbuff = kmalloc(bufsz, GFP_KERNEL);\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\t \n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"Please echo the correct value ...\\n\");\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"0: grab firmware transient SER state\\n\");\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"1: trigger system error L1 recovery\\n\");\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"2: trigger system error L2 recovery\\n\");\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"3: trigger system error L3 rx abort\\n\");\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"4: trigger system error L3 tx abort\\n\");\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"5: trigger system error L3 tx disable\\n\");\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"6: trigger system error L3 bf recovery\\n\");\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"7: trigger system error full recovery\\n\");\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"8: trigger firmware crash\\n\");\n\n\t \n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"\\nlet's dump firmware SER statistics...\\n\");\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"::E  R , SER_STATUS        = 0x%08x\\n\",\n\t\t\t  mt76_rr(dev, MT_SWDEF_SER_STATS));\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"::E  R , SER_PLE_ERR       = 0x%08x\\n\",\n\t\t\t  mt76_rr(dev, MT_SWDEF_PLE_STATS));\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"::E  R , SER_PLE_ERR_1     = 0x%08x\\n\",\n\t\t\t  mt76_rr(dev, MT_SWDEF_PLE1_STATS));\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"::E  R , SER_PLE_ERR_AMSDU = 0x%08x\\n\",\n\t\t\t  mt76_rr(dev, MT_SWDEF_PLE_AMSDU_STATS));\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"::E  R , SER_PSE_ERR       = 0x%08x\\n\",\n\t\t\t  mt76_rr(dev, MT_SWDEF_PSE_STATS));\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"::E  R , SER_PSE_ERR_1     = 0x%08x\\n\",\n\t\t\t  mt76_rr(dev, MT_SWDEF_PSE1_STATS));\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"::E  R , SER_LMAC_WISR6_B0 = 0x%08x\\n\",\n\t\t\t  mt76_rr(dev, MT_SWDEF_LAMC_WISR6_BN0_STATS));\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"::E  R , SER_LMAC_WISR6_B1 = 0x%08x\\n\",\n\t\t\t  mt76_rr(dev, MT_SWDEF_LAMC_WISR6_BN1_STATS));\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"::E  R , SER_LMAC_WISR7_B0 = 0x%08x\\n\",\n\t\t\t  mt76_rr(dev, MT_SWDEF_LAMC_WISR7_BN0_STATS));\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"::E  R , SER_LMAC_WISR7_B1 = 0x%08x\\n\",\n\t\t\t  mt76_rr(dev, MT_SWDEF_LAMC_WISR7_BN1_STATS));\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"\\nSYS_RESET_COUNT: WM %d, WA %d\\n\",\n\t\t\t  dev->recovery.wm_reset_count,\n\t\t\t  dev->recovery.wa_reset_count);\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buff, desc);\n\tkfree(buff);\n\treturn ret;\n}\n\nstatic const struct file_operations mt7915_sys_recovery_ops = {\n\t.write = mt7915_sys_recovery_set,\n\t.read = mt7915_sys_recovery_get,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic int\nmt7915_radar_trigger(void *data, u64 val)\n{\n\tstruct mt7915_dev *dev = data;\n\n\tif (val > MT_RX_SEL2)\n\t\treturn -EINVAL;\n\n\treturn mt76_connac_mcu_rdd_cmd(&dev->mt76, RDD_RADAR_EMULATE,\n\t\t\t\t       val, 0, 0);\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_radar_trigger, NULL,\n\t\t\t mt7915_radar_trigger, \"%lld\\n\");\n\nstatic int\nmt7915_muru_debug_set(void *data, u64 val)\n{\n\tstruct mt7915_dev *dev = data;\n\n\tdev->muru_debug = val;\n\tmt7915_mcu_muru_debug_set(dev, dev->muru_debug);\n\n\treturn 0;\n}\n\nstatic int\nmt7915_muru_debug_get(void *data, u64 *val)\n{\n\tstruct mt7915_dev *dev = data;\n\n\t*val = dev->muru_debug;\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_muru_debug, mt7915_muru_debug_get,\n\t\t\t mt7915_muru_debug_set, \"%lld\\n\");\n\nstatic int mt7915_muru_stats_show(struct seq_file *file, void *data)\n{\n\tstruct mt7915_phy *phy = file->private;\n\tstruct mt7915_dev *dev = phy->dev;\n\tstatic const char * const dl_non_he_type[] = {\n\t\t\"CCK\", \"OFDM\", \"HT MIX\", \"HT GF\",\n\t\t\"VHT SU\", \"VHT 2MU\", \"VHT 3MU\", \"VHT 4MU\"\n\t};\n\tstatic const char * const dl_he_type[] = {\n\t\t\"HE SU\", \"HE EXT\", \"HE 2MU\", \"HE 3MU\", \"HE 4MU\",\n\t\t\"HE 2RU\", \"HE 3RU\", \"HE 4RU\", \"HE 5-8RU\", \"HE 9-16RU\",\n\t\t\"HE >16RU\"\n\t};\n\tstatic const char * const ul_he_type[] = {\n\t\t\"HE 2MU\", \"HE 3MU\", \"HE 4MU\", \"HE SU\", \"HE 2RU\",\n\t\t\"HE 3RU\", \"HE 4RU\", \"HE 5-8RU\", \"HE 9-16RU\", \"HE >16RU\"\n\t};\n\tint ret, i;\n\tu64 total_ppdu_cnt, sub_total_cnt;\n\n\tif (!dev->muru_debug) {\n\t\tseq_puts(file, \"Please enable muru_debug first.\\n\");\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tret = mt7915_mcu_muru_debug_get(phy);\n\tif (ret)\n\t\tgoto exit;\n\n\t \n\tseq_puts(file, \"[Non-HE]\\nDownlink\\nData Type:  \");\n\n\tfor (i = 0; i < 5; i++)\n\t\tseq_printf(file, \"%8s | \", dl_non_he_type[i]);\n\n\tseq_puts(file, \"\\nTotal Count:\");\n\tseq_printf(file, \"%8u | %8u | %8u | %8u | %8u | \",\n\t\t   phy->mib.dl_cck_cnt,\n\t\t   phy->mib.dl_ofdm_cnt,\n\t\t   phy->mib.dl_htmix_cnt,\n\t\t   phy->mib.dl_htgf_cnt,\n\t\t   phy->mib.dl_vht_su_cnt);\n\n\tseq_puts(file, \"\\nDownlink MU-MIMO\\nData Type:  \");\n\n\tfor (i = 5; i < 8; i++)\n\t\tseq_printf(file, \"%8s | \", dl_non_he_type[i]);\n\n\tseq_puts(file, \"\\nTotal Count:\");\n\tseq_printf(file, \"%8u | %8u | %8u | \",\n\t\t   phy->mib.dl_vht_2mu_cnt,\n\t\t   phy->mib.dl_vht_3mu_cnt,\n\t\t   phy->mib.dl_vht_4mu_cnt);\n\n\tsub_total_cnt = phy->mib.dl_vht_2mu_cnt +\n\t\t\tphy->mib.dl_vht_3mu_cnt +\n\t\t\tphy->mib.dl_vht_4mu_cnt;\n\n\tseq_printf(file, \"\\nTotal non-HE MU-MIMO DL PPDU count: %lld\",\n\t\t   sub_total_cnt);\n\n\ttotal_ppdu_cnt = sub_total_cnt +\n\t\t\t phy->mib.dl_cck_cnt +\n\t\t\t phy->mib.dl_ofdm_cnt +\n\t\t\t phy->mib.dl_htmix_cnt +\n\t\t\t phy->mib.dl_htgf_cnt +\n\t\t\t phy->mib.dl_vht_su_cnt;\n\n\tseq_printf(file, \"\\nAll non-HE DL PPDU count: %lld\", total_ppdu_cnt);\n\n\t \n\tseq_puts(file, \"\\n\\n[HE]\\nDownlink\\nData Type:  \");\n\n\tfor (i = 0; i < 2; i++)\n\t\tseq_printf(file, \"%8s | \", dl_he_type[i]);\n\n\tseq_puts(file, \"\\nTotal Count:\");\n\tseq_printf(file, \"%8u | %8u | \",\n\t\t   phy->mib.dl_he_su_cnt, phy->mib.dl_he_ext_su_cnt);\n\n\tseq_puts(file, \"\\nDownlink MU-MIMO\\nData Type:  \");\n\n\tfor (i = 2; i < 5; i++)\n\t\tseq_printf(file, \"%8s | \", dl_he_type[i]);\n\n\tseq_puts(file, \"\\nTotal Count:\");\n\tseq_printf(file, \"%8u | %8u | %8u | \",\n\t\t   phy->mib.dl_he_2mu_cnt, phy->mib.dl_he_3mu_cnt,\n\t\t   phy->mib.dl_he_4mu_cnt);\n\n\tseq_puts(file, \"\\nDownlink OFDMA\\nData Type:  \");\n\n\tfor (i = 5; i < 11; i++)\n\t\tseq_printf(file, \"%8s | \", dl_he_type[i]);\n\n\tseq_puts(file, \"\\nTotal Count:\");\n\tseq_printf(file, \"%8u | %8u | %8u | %8u | %9u | %8u | \",\n\t\t   phy->mib.dl_he_2ru_cnt,\n\t\t   phy->mib.dl_he_3ru_cnt,\n\t\t   phy->mib.dl_he_4ru_cnt,\n\t\t   phy->mib.dl_he_5to8ru_cnt,\n\t\t   phy->mib.dl_he_9to16ru_cnt,\n\t\t   phy->mib.dl_he_gtr16ru_cnt);\n\n\tsub_total_cnt = phy->mib.dl_he_2mu_cnt +\n\t\t\tphy->mib.dl_he_3mu_cnt +\n\t\t\tphy->mib.dl_he_4mu_cnt;\n\ttotal_ppdu_cnt = sub_total_cnt;\n\n\tseq_printf(file, \"\\nTotal HE MU-MIMO DL PPDU count: %lld\",\n\t\t   sub_total_cnt);\n\n\tsub_total_cnt = phy->mib.dl_he_2ru_cnt +\n\t\t\tphy->mib.dl_he_3ru_cnt +\n\t\t\tphy->mib.dl_he_4ru_cnt +\n\t\t\tphy->mib.dl_he_5to8ru_cnt +\n\t\t\tphy->mib.dl_he_9to16ru_cnt +\n\t\t\tphy->mib.dl_he_gtr16ru_cnt;\n\ttotal_ppdu_cnt += sub_total_cnt;\n\n\tseq_printf(file, \"\\nTotal HE OFDMA DL PPDU count: %lld\",\n\t\t   sub_total_cnt);\n\n\ttotal_ppdu_cnt += phy->mib.dl_he_su_cnt + phy->mib.dl_he_ext_su_cnt;\n\n\tseq_printf(file, \"\\nAll HE DL PPDU count: %lld\", total_ppdu_cnt);\n\n\t \n\tseq_puts(file, \"\\n\\nUplink\");\n\tseq_puts(file, \"\\nTrigger-based Uplink MU-MIMO\\nData Type:  \");\n\n\tfor (i = 0; i < 3; i++)\n\t\tseq_printf(file, \"%8s | \", ul_he_type[i]);\n\n\tseq_puts(file, \"\\nTotal Count:\");\n\tseq_printf(file, \"%8u | %8u | %8u | \",\n\t\t   phy->mib.ul_hetrig_2mu_cnt,\n\t\t   phy->mib.ul_hetrig_3mu_cnt,\n\t\t   phy->mib.ul_hetrig_4mu_cnt);\n\n\tseq_puts(file, \"\\nTrigger-based Uplink OFDMA\\nData Type:  \");\n\n\tfor (i = 3; i < 10; i++)\n\t\tseq_printf(file, \"%8s | \", ul_he_type[i]);\n\n\tseq_puts(file, \"\\nTotal Count:\");\n\tseq_printf(file, \"%8u | %8u | %8u | %8u | %8u | %9u |  %7u | \",\n\t\t   phy->mib.ul_hetrig_su_cnt,\n\t\t   phy->mib.ul_hetrig_2ru_cnt,\n\t\t   phy->mib.ul_hetrig_3ru_cnt,\n\t\t   phy->mib.ul_hetrig_4ru_cnt,\n\t\t   phy->mib.ul_hetrig_5to8ru_cnt,\n\t\t   phy->mib.ul_hetrig_9to16ru_cnt,\n\t\t   phy->mib.ul_hetrig_gtr16ru_cnt);\n\n\tsub_total_cnt = phy->mib.ul_hetrig_2mu_cnt +\n\t\t\tphy->mib.ul_hetrig_3mu_cnt +\n\t\t\tphy->mib.ul_hetrig_4mu_cnt;\n\ttotal_ppdu_cnt = sub_total_cnt;\n\n\tseq_printf(file, \"\\nTotal HE MU-MIMO UL TB PPDU count: %lld\",\n\t\t   sub_total_cnt);\n\n\tsub_total_cnt = phy->mib.ul_hetrig_2ru_cnt +\n\t\t\tphy->mib.ul_hetrig_3ru_cnt +\n\t\t\tphy->mib.ul_hetrig_4ru_cnt +\n\t\t\tphy->mib.ul_hetrig_5to8ru_cnt +\n\t\t\tphy->mib.ul_hetrig_9to16ru_cnt +\n\t\t\tphy->mib.ul_hetrig_gtr16ru_cnt;\n\ttotal_ppdu_cnt += sub_total_cnt;\n\n\tseq_printf(file, \"\\nTotal HE OFDMA UL TB PPDU count: %lld\",\n\t\t   sub_total_cnt);\n\n\ttotal_ppdu_cnt += phy->mib.ul_hetrig_su_cnt;\n\n\tseq_printf(file, \"\\nAll HE UL TB PPDU count: %lld\\n\", total_ppdu_cnt);\n\nexit:\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn ret;\n}\nDEFINE_SHOW_ATTRIBUTE(mt7915_muru_stats);\n\nstatic int\nmt7915_rdd_monitor(struct seq_file *s, void *data)\n{\n\tstruct mt7915_dev *dev = dev_get_drvdata(s->private);\n\tstruct cfg80211_chan_def *chandef = &dev->rdd2_chandef;\n\tconst char *bw;\n\tint ret = 0;\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tif (!cfg80211_chandef_valid(chandef)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!dev->rdd2_phy) {\n\t\tseq_puts(s, \"not running\\n\");\n\t\tgoto out;\n\t}\n\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tbw = \"40\";\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\tbw = \"80\";\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_160:\n\t\tbw = \"160\";\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80P80:\n\t\tbw = \"80P80\";\n\t\tbreak;\n\tdefault:\n\t\tbw = \"20\";\n\t\tbreak;\n\t}\n\n\tseq_printf(s, \"channel %d (%d MHz) width %s MHz center1: %d MHz\\n\",\n\t\t   chandef->chan->hw_value, chandef->chan->center_freq,\n\t\t   bw, chandef->center_freq1);\nout:\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn ret;\n}\n\nstatic int\nmt7915_fw_debug_wm_set(void *data, u64 val)\n{\n\tstruct mt7915_dev *dev = data;\n\tenum {\n\t\tDEBUG_TXCMD = 62,\n\t\tDEBUG_CMD_RPT_TX,\n\t\tDEBUG_CMD_RPT_TRIG,\n\t\tDEBUG_SPL,\n\t\tDEBUG_RPT_RX,\n\t} debug;\n\tbool tx, rx, en;\n\tint ret;\n\n\tdev->fw.debug_wm = val ? MCU_FW_LOG_TO_HOST : 0;\n\n\tif (dev->fw.debug_bin)\n\t\tval = 16;\n\telse\n\t\tval = dev->fw.debug_wm;\n\n\ttx = dev->fw.debug_wm || (dev->fw.debug_bin & BIT(1));\n\trx = dev->fw.debug_wm || (dev->fw.debug_bin & BIT(2));\n\ten = dev->fw.debug_wm || (dev->fw.debug_bin & BIT(0));\n\n\tret = mt7915_mcu_fw_log_2_host(dev, MCU_FW_LOG_WM, val);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (debug = DEBUG_TXCMD; debug <= DEBUG_RPT_RX; debug++) {\n\t\tif (debug == DEBUG_RPT_RX)\n\t\t\tval = en && rx;\n\t\telse\n\t\t\tval = en && tx;\n\n\t\tret = mt7915_mcu_fw_dbg_ctrl(dev, debug, val);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t \n\tmt76_clear(dev, MT_CPU_UTIL_CTRL, BIT(0));\n\tmt76_wr(dev, MT_DIC_CMD_REG_CMD, BIT(2) | BIT(13) | !dev->fw.debug_wm);\n\tmt76_wr(dev, MT_MCU_WM_CIRQ_IRQ_MASK_CLR_ADDR, BIT(5));\n\tmt76_wr(dev, MT_MCU_WM_CIRQ_IRQ_SOFT_ADDR, BIT(5));\n\nout:\n\tif (ret)\n\t\tdev->fw.debug_wm = 0;\n\n\treturn ret;\n}\n\nstatic int\nmt7915_fw_debug_wm_get(void *data, u64 *val)\n{\n\tstruct mt7915_dev *dev = data;\n\n\t*val = dev->fw.debug_wm;\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_fw_debug_wm, mt7915_fw_debug_wm_get,\n\t\t\t mt7915_fw_debug_wm_set, \"%lld\\n\");\n\nstatic int\nmt7915_fw_debug_wa_set(void *data, u64 val)\n{\n\tstruct mt7915_dev *dev = data;\n\tint ret;\n\n\tdev->fw.debug_wa = val ? MCU_FW_LOG_TO_HOST : 0;\n\n\tret = mt7915_mcu_fw_log_2_host(dev, MCU_FW_LOG_WA, dev->fw.debug_wa);\n\tif (ret)\n\t\tgoto out;\n\n\tret = mt7915_mcu_wa_cmd(dev, MCU_WA_PARAM_CMD(SET),\n\t\t\t\tMCU_WA_PARAM_PDMA_RX, !!dev->fw.debug_wa, 0);\nout:\n\tif (ret)\n\t\tdev->fw.debug_wa = 0;\n\n\treturn ret;\n}\n\nstatic int\nmt7915_fw_debug_wa_get(void *data, u64 *val)\n{\n\tstruct mt7915_dev *dev = data;\n\n\t*val = dev->fw.debug_wa;\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_fw_debug_wa, mt7915_fw_debug_wa_get,\n\t\t\t mt7915_fw_debug_wa_set, \"%lld\\n\");\n\nstatic struct dentry *\ncreate_buf_file_cb(const char *filename, struct dentry *parent, umode_t mode,\n\t\t   struct rchan_buf *buf, int *is_global)\n{\n\tstruct dentry *f;\n\n\tf = debugfs_create_file(\"fwlog_data\", mode, parent, buf,\n\t\t\t\t&relay_file_operations);\n\tif (IS_ERR(f))\n\t\treturn NULL;\n\n\t*is_global = 1;\n\n\treturn f;\n}\n\nstatic int\nremove_buf_file_cb(struct dentry *f)\n{\n\tdebugfs_remove(f);\n\n\treturn 0;\n}\n\nstatic int\nmt7915_fw_debug_bin_set(void *data, u64 val)\n{\n\tstatic struct rchan_callbacks relay_cb = {\n\t\t.create_buf_file = create_buf_file_cb,\n\t\t.remove_buf_file = remove_buf_file_cb,\n\t};\n\tstruct mt7915_dev *dev = data;\n\n\tif (!dev->relay_fwlog)\n\t\tdev->relay_fwlog = relay_open(\"fwlog_data\", dev->debugfs_dir,\n\t\t\t\t\t    1500, 512, &relay_cb, NULL);\n\tif (!dev->relay_fwlog)\n\t\treturn -ENOMEM;\n\n\tdev->fw.debug_bin = val;\n\n\trelay_reset(dev->relay_fwlog);\n\n\treturn mt7915_fw_debug_wm_set(dev, dev->fw.debug_wm);\n}\n\nstatic int\nmt7915_fw_debug_bin_get(void *data, u64 *val)\n{\n\tstruct mt7915_dev *dev = data;\n\n\t*val = dev->fw.debug_bin;\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_fw_debug_bin, mt7915_fw_debug_bin_get,\n\t\t\t mt7915_fw_debug_bin_set, \"%lld\\n\");\n\nstatic int\nmt7915_fw_util_wm_show(struct seq_file *file, void *data)\n{\n\tstruct mt7915_dev *dev = file->private;\n\n\tseq_printf(file, \"Program counter: 0x%x\\n\", mt76_rr(dev, MT_WM_MCU_PC));\n\n\tif (dev->fw.debug_wm) {\n\t\tseq_printf(file, \"Busy: %u%%  Peak busy: %u%%\\n\",\n\t\t\t   mt76_rr(dev, MT_CPU_UTIL_BUSY_PCT),\n\t\t\t   mt76_rr(dev, MT_CPU_UTIL_PEAK_BUSY_PCT));\n\t\tseq_printf(file, \"Idle count: %u  Peak idle count: %u\\n\",\n\t\t\t   mt76_rr(dev, MT_CPU_UTIL_IDLE_CNT),\n\t\t\t   mt76_rr(dev, MT_CPU_UTIL_PEAK_IDLE_CNT));\n\t}\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(mt7915_fw_util_wm);\n\nstatic int\nmt7915_fw_util_wa_show(struct seq_file *file, void *data)\n{\n\tstruct mt7915_dev *dev = file->private;\n\n\tseq_printf(file, \"Program counter: 0x%x\\n\", mt76_rr(dev, MT_WA_MCU_PC));\n\n\tif (dev->fw.debug_wa)\n\t\treturn mt7915_mcu_wa_cmd(dev, MCU_WA_PARAM_CMD(QUERY),\n\t\t\t\t\t MCU_WA_PARAM_CPU_UTIL, 0, 0);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(mt7915_fw_util_wa);\n\nstatic void\nmt7915_ampdu_stat_read_phy(struct mt7915_phy *phy,\n\t\t\t   struct seq_file *file)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tbool ext_phy = phy != &dev->phy;\n\tint bound[15], range[4], i;\n\tu8 band = phy->mt76->band_idx;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(range); i++)\n\t\trange[i] = mt76_rr(dev, MT_MIB_ARNG(band, i));\n\n\tfor (i = 0; i < ARRAY_SIZE(bound); i++)\n\t\tbound[i] = MT_MIB_ARNCR_RANGE(range[i / 4], i % 4) + 1;\n\n\tseq_printf(file, \"\\nPhy %d, Phy band %d\\n\", ext_phy, band);\n\n\tseq_printf(file, \"Length: %8d | \", bound[0]);\n\tfor (i = 0; i < ARRAY_SIZE(bound) - 1; i++)\n\t\tseq_printf(file, \"%3d -%3d | \",\n\t\t\t   bound[i] + 1, bound[i + 1]);\n\n\tseq_puts(file, \"\\nCount:  \");\n\tfor (i = 0; i < ARRAY_SIZE(bound); i++)\n\t\tseq_printf(file, \"%8d | \", phy->mt76->aggr_stats[i]);\n\tseq_puts(file, \"\\n\");\n\n\tseq_printf(file, \"BA miss count: %d\\n\", phy->mib.ba_miss_cnt);\n}\n\nstatic void\nmt7915_txbf_stat_read_phy(struct mt7915_phy *phy, struct seq_file *s)\n{\n\tstruct mt76_mib_stats *mib = &phy->mib;\n\tstatic const char * const bw[] = {\n\t\t\"BW20\", \"BW40\", \"BW80\", \"BW160\"\n\t};\n\n\t \n\tseq_puts(s, \"\\nTx Beamformer applied PPDU counts: \");\n\n\tseq_printf(s, \"iBF: %d, eBF: %d\\n\",\n\t\t   mib->tx_bf_ibf_ppdu_cnt,\n\t\t   mib->tx_bf_ebf_ppdu_cnt);\n\n\t \n\tseq_puts(s, \"Tx Beamformer Rx feedback statistics: \");\n\n\tseq_printf(s, \"All: %d, HE: %d, VHT: %d, HT: %d, \",\n\t\t   mib->tx_bf_rx_fb_all_cnt,\n\t\t   mib->tx_bf_rx_fb_he_cnt,\n\t\t   mib->tx_bf_rx_fb_vht_cnt,\n\t\t   mib->tx_bf_rx_fb_ht_cnt);\n\n\tseq_printf(s, \"%s, NC: %d, NR: %d\\n\",\n\t\t   bw[mib->tx_bf_rx_fb_bw],\n\t\t   mib->tx_bf_rx_fb_nc_cnt,\n\t\t   mib->tx_bf_rx_fb_nr_cnt);\n\n\t \n\tseq_printf(s, \"Tx Beamformee successful feedback frames: %d\\n\",\n\t\t   mib->tx_bf_fb_cpl_cnt);\n\tseq_printf(s, \"Tx Beamformee feedback triggered counts: %d\\n\",\n\t\t   mib->tx_bf_fb_trig_cnt);\n\n\t \n\tseq_printf(s, \"Tx multi-user Beamforming counts: %d\\n\",\n\t\t   mib->tx_bf_cnt);\n\tseq_printf(s, \"Tx multi-user MPDU counts: %d\\n\", mib->tx_mu_mpdu_cnt);\n\tseq_printf(s, \"Tx multi-user successful MPDU counts: %d\\n\",\n\t\t   mib->tx_mu_acked_mpdu_cnt);\n\tseq_printf(s, \"Tx single-user successful MPDU counts: %d\\n\",\n\t\t   mib->tx_su_acked_mpdu_cnt);\n\n\tseq_puts(s, \"\\n\");\n}\n\nstatic int\nmt7915_tx_stats_show(struct seq_file *file, void *data)\n{\n\tstruct mt7915_phy *phy = file->private;\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct mt76_mib_stats *mib = &phy->mib;\n\tint i;\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tmt7915_ampdu_stat_read_phy(phy, file);\n\tmt7915_mac_update_stats(phy);\n\tmt7915_txbf_stat_read_phy(phy, file);\n\n\t \n\tseq_puts(file, \"Tx MSDU statistics:\\n\");\n\tfor (i = 0; i < ARRAY_SIZE(mib->tx_amsdu); i++) {\n\t\tseq_printf(file, \"AMSDU pack count of %d MSDU in TXD: %8d \",\n\t\t\t   i + 1, mib->tx_amsdu[i]);\n\t\tif (mib->tx_amsdu_cnt)\n\t\t\tseq_printf(file, \"(%3d%%)\\n\",\n\t\t\t\t   mib->tx_amsdu[i] * 100 / mib->tx_amsdu_cnt);\n\t\telse\n\t\t\tseq_puts(file, \"\\n\");\n\t}\n\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(mt7915_tx_stats);\n\nstatic void\nmt7915_hw_queue_read(struct seq_file *s, u32 size,\n\t\t     const struct hw_queue_map *map)\n{\n\tstruct mt7915_phy *phy = s->private;\n\tstruct mt7915_dev *dev = phy->dev;\n\tu32 i, val;\n\n\tval = mt76_rr(dev, MT_FL_Q_EMPTY);\n\tfor (i = 0; i < size; i++) {\n\t\tu32 ctrl, head, tail, queued;\n\n\t\tif (val & BIT(map[i].index))\n\t\t\tcontinue;\n\n\t\tctrl = BIT(31) | (map[i].pid << 10) | ((u32)map[i].qid << 24);\n\t\tmt76_wr(dev, MT_FL_Q0_CTRL, ctrl);\n\n\t\thead = mt76_get_field(dev, MT_FL_Q2_CTRL,\n\t\t\t\t      GENMASK(11, 0));\n\t\ttail = mt76_get_field(dev, MT_FL_Q2_CTRL,\n\t\t\t\t      GENMASK(27, 16));\n\t\tqueued = mt76_get_field(dev, MT_FL_Q3_CTRL,\n\t\t\t\t\tGENMASK(11, 0));\n\n\t\tseq_printf(s, \"\\t%s: \", map[i].name);\n\t\tseq_printf(s, \"queued:0x%03x head:0x%03x tail:0x%03x\\n\",\n\t\t\t   queued, head, tail);\n\t}\n}\n\nstatic void\nmt7915_sta_hw_queue_read(void *data, struct ieee80211_sta *sta)\n{\n\tstruct mt7915_sta *msta = (struct mt7915_sta *)sta->drv_priv;\n\tstruct mt7915_dev *dev = msta->vif->phy->dev;\n\tstruct seq_file *s = data;\n\tu8 ac;\n\n\tfor (ac = 0; ac < 4; ac++) {\n\t\tu32 qlen, ctrl, val;\n\t\tu32 idx = msta->wcid.idx >> 5;\n\t\tu8 offs = msta->wcid.idx & GENMASK(4, 0);\n\n\t\tctrl = BIT(31) | BIT(11) | (ac << 24);\n\t\tval = mt76_rr(dev, MT_PLE_AC_QEMPTY(ac, idx));\n\n\t\tif (val & BIT(offs))\n\t\t\tcontinue;\n\n\t\tmt76_wr(dev, MT_FL_Q0_CTRL, ctrl | msta->wcid.idx);\n\t\tqlen = mt76_get_field(dev, MT_FL_Q3_CTRL,\n\t\t\t\t      GENMASK(11, 0));\n\t\tseq_printf(s, \"\\tSTA %pM wcid %d: AC%d%d queued:%d\\n\",\n\t\t\t   sta->addr, msta->wcid.idx,\n\t\t\t   msta->vif->mt76.wmm_idx, ac, qlen);\n\t}\n}\n\nstatic int\nmt7915_hw_queues_show(struct seq_file *file, void *data)\n{\n\tstruct mt7915_phy *phy = file->private;\n\tstruct mt7915_dev *dev = phy->dev;\n\tstatic const struct hw_queue_map ple_queue_map[] = {\n\t\t{ \"CPU_Q0\",  0,  1, MT_CTX0\t      },\n\t\t{ \"CPU_Q1\",  1,  1, MT_CTX0 + 1\t      },\n\t\t{ \"CPU_Q2\",  2,  1, MT_CTX0 + 2\t      },\n\t\t{ \"CPU_Q3\",  3,  1, MT_CTX0 + 3\t      },\n\t\t{ \"ALTX_Q0\", 8,  2, MT_LMAC_ALTX0     },\n\t\t{ \"BMC_Q0\",  9,  2, MT_LMAC_BMC0      },\n\t\t{ \"BCN_Q0\",  10, 2, MT_LMAC_BCN0      },\n\t\t{ \"PSMP_Q0\", 11, 2, MT_LMAC_PSMP0     },\n\t\t{ \"ALTX_Q1\", 12, 2, MT_LMAC_ALTX0 + 4 },\n\t\t{ \"BMC_Q1\",  13, 2, MT_LMAC_BMC0  + 4 },\n\t\t{ \"BCN_Q1\",  14, 2, MT_LMAC_BCN0  + 4 },\n\t\t{ \"PSMP_Q1\", 15, 2, MT_LMAC_PSMP0 + 4 },\n\t};\n\tstatic const struct hw_queue_map pse_queue_map[] = {\n\t\t{ \"CPU Q0\",  0,  1, MT_CTX0\t      },\n\t\t{ \"CPU Q1\",  1,  1, MT_CTX0 + 1\t      },\n\t\t{ \"CPU Q2\",  2,  1, MT_CTX0 + 2\t      },\n\t\t{ \"CPU Q3\",  3,  1, MT_CTX0 + 3\t      },\n\t\t{ \"HIF_Q0\",  8,  0, MT_HIF0\t      },\n\t\t{ \"HIF_Q1\",  9,  0, MT_HIF0 + 1\t      },\n\t\t{ \"HIF_Q2\",  10, 0, MT_HIF0 + 2\t      },\n\t\t{ \"HIF_Q3\",  11, 0, MT_HIF0 + 3\t      },\n\t\t{ \"HIF_Q4\",  12, 0, MT_HIF0 + 4\t      },\n\t\t{ \"HIF_Q5\",  13, 0, MT_HIF0 + 5\t      },\n\t\t{ \"LMAC_Q\",  16, 2, 0\t\t      },\n\t\t{ \"MDP_TXQ\", 17, 2, 1\t\t      },\n\t\t{ \"MDP_RXQ\", 18, 2, 2\t\t      },\n\t\t{ \"SEC_TXQ\", 19, 2, 3\t\t      },\n\t\t{ \"SEC_RXQ\", 20, 2, 4\t\t      },\n\t};\n\tu32 val, head, tail;\n\n\t \n\tval = mt76_rr(dev, MT_PLE_FREEPG_CNT);\n\thead = mt76_get_field(dev, MT_PLE_FREEPG_HEAD_TAIL, GENMASK(11, 0));\n\ttail = mt76_get_field(dev, MT_PLE_FREEPG_HEAD_TAIL, GENMASK(27, 16));\n\tseq_puts(file, \"PLE page info:\\n\");\n\tseq_printf(file,\n\t\t   \"\\tTotal free page: 0x%08x head: 0x%03x tail: 0x%03x\\n\",\n\t\t   val, head, tail);\n\n\tval = mt76_rr(dev, MT_PLE_PG_HIF_GROUP);\n\thead = mt76_get_field(dev, MT_PLE_HIF_PG_INFO, GENMASK(11, 0));\n\ttail = mt76_get_field(dev, MT_PLE_HIF_PG_INFO, GENMASK(27, 16));\n\tseq_printf(file, \"\\tHIF free page: 0x%03x res: 0x%03x used: 0x%03x\\n\",\n\t\t   val, head, tail);\n\n\tseq_puts(file, \"PLE non-empty queue info:\\n\");\n\tmt7915_hw_queue_read(file, ARRAY_SIZE(ple_queue_map),\n\t\t\t     &ple_queue_map[0]);\n\n\t \n\tieee80211_iterate_stations_atomic(phy->mt76->hw,\n\t\t\t\t\t  mt7915_sta_hw_queue_read, file);\n\t \n\tseq_puts(file, \"PSE non-empty queue info:\\n\");\n\tmt7915_hw_queue_read(file, ARRAY_SIZE(pse_queue_map),\n\t\t\t     &pse_queue_map[0]);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(mt7915_hw_queues);\n\nstatic int\nmt7915_xmit_queues_show(struct seq_file *file, void *data)\n{\n\tstruct mt7915_phy *phy = file->private;\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct {\n\t\tstruct mt76_queue *q;\n\t\tchar *queue;\n\t} queue_map[] = {\n\t\t{ phy->mt76->q_tx[MT_TXQ_BE],\t \"   MAIN\"  },\n\t\t{ dev->mt76.q_mcu[MT_MCUQ_WM],\t \"  MCUWM\"  },\n\t\t{ dev->mt76.q_mcu[MT_MCUQ_WA],\t \"  MCUWA\"  },\n\t\t{ dev->mt76.q_mcu[MT_MCUQ_FWDL], \"MCUFWDL\" },\n\t};\n\tint i;\n\n\tseq_puts(file, \"     queue | hw-queued |      head |      tail |\\n\");\n\tfor (i = 0; i < ARRAY_SIZE(queue_map); i++) {\n\t\tstruct mt76_queue *q = queue_map[i].q;\n\n\t\tif (!q)\n\t\t\tcontinue;\n\n\t\tseq_printf(file, \"   %s | %9d | %9d | %9d |\\n\",\n\t\t\t   queue_map[i].queue, q->queued, q->head,\n\t\t\t   q->tail);\n\t}\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(mt7915_xmit_queues);\n\n#define mt7915_txpower_puts(rate)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tlen += scnprintf(buf + len, sz - len, \"%-16s:\", #rate \" (TMAC)\");\t\\\n\tfor (i = 0; i < mt7915_sku_group_len[SKU_##rate]; i++, offs++)\t\t\\\n\t\tlen += scnprintf(buf + len, sz - len, \" %6d\", txpwr[offs]);\t\\\n\tlen += scnprintf(buf + len, sz - len, \"\\n\");\t\t\t\t\\\n})\n\n#define mt7915_txpower_sets(rate, pwr, flag)\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\toffs += len;\t\t\t\t\t\t\\\n\tlen = mt7915_sku_group_len[rate];\t\t\t\\\n\tif (mode == flag) {\t\t\t\t\t\\\n\t\tfor (i = 0; i < len; i++)\t\t\t\\\n\t\t\treq.txpower_sku[offs + i] = pwr;\t\\\n\t}\t\t\t\t\t\t\t\\\n})\n\nstatic ssize_t\nmt7915_rate_txpower_get(struct file *file, char __user *user_buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct mt7915_phy *phy = file->private_data;\n\tstruct mt7915_dev *dev = phy->dev;\n\ts8 txpwr[MT7915_SKU_RATE_NUM];\n\tstatic const size_t sz = 2048;\n\tu8 band = phy->mt76->band_idx;\n\tint i, offs = 0, len = 0;\n\tssize_t ret;\n\tchar *buf;\n\tu32 reg;\n\n\tbuf = kzalloc(sz, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = mt7915_mcu_get_txpower_sku(phy, txpwr, sizeof(txpwr));\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tlen += scnprintf(buf + len, sz - len,\n\t\t\t \"\\nPhy%d Tx power table (channel %d)\\n\",\n\t\t\t phy != &dev->phy, phy->mt76->chandef.chan->hw_value);\n\tlen += scnprintf(buf + len, sz - len, \"%-16s  %6s %6s %6s %6s\\n\",\n\t\t\t \" \", \"1m\", \"2m\", \"5m\", \"11m\");\n\tmt7915_txpower_puts(CCK);\n\n\tlen += scnprintf(buf + len, sz - len,\n\t\t\t \"%-16s  %6s %6s %6s %6s %6s %6s %6s %6s\\n\",\n\t\t\t \" \", \"6m\", \"9m\", \"12m\", \"18m\", \"24m\", \"36m\", \"48m\",\n\t\t\t \"54m\");\n\tmt7915_txpower_puts(OFDM);\n\n\tlen += scnprintf(buf + len, sz - len,\n\t\t\t \"%-16s  %6s %6s %6s %6s %6s %6s %6s %6s\\n\",\n\t\t\t \" \", \"mcs0\", \"mcs1\", \"mcs2\", \"mcs3\", \"mcs4\",\n\t\t\t \"mcs5\", \"mcs6\", \"mcs7\");\n\tmt7915_txpower_puts(HT_BW20);\n\n\tlen += scnprintf(buf + len, sz - len,\n\t\t\t \"%-16s  %6s %6s %6s %6s %6s %6s %6s %6s %6s\\n\",\n\t\t\t \" \", \"mcs0\", \"mcs1\", \"mcs2\", \"mcs3\", \"mcs4\", \"mcs5\",\n\t\t\t \"mcs6\", \"mcs7\", \"mcs32\");\n\tmt7915_txpower_puts(HT_BW40);\n\n\tlen += scnprintf(buf + len, sz - len,\n\t\t\t \"%-16s  %6s %6s %6s %6s %6s %6s %6s %6s %6s %6s %6s %6s\\n\",\n\t\t\t \" \", \"mcs0\", \"mcs1\", \"mcs2\", \"mcs3\", \"mcs4\", \"mcs5\",\n\t\t\t \"mcs6\", \"mcs7\", \"mcs8\", \"mcs9\", \"mcs10\", \"mcs11\");\n\tmt7915_txpower_puts(VHT_BW20);\n\tmt7915_txpower_puts(VHT_BW40);\n\tmt7915_txpower_puts(VHT_BW80);\n\tmt7915_txpower_puts(VHT_BW160);\n\tmt7915_txpower_puts(HE_RU26);\n\tmt7915_txpower_puts(HE_RU52);\n\tmt7915_txpower_puts(HE_RU106);\n\tmt7915_txpower_puts(HE_RU242);\n\tmt7915_txpower_puts(HE_RU484);\n\tmt7915_txpower_puts(HE_RU996);\n\tmt7915_txpower_puts(HE_RU2x996);\n\n\treg = is_mt7915(&dev->mt76) ? MT_WF_PHY_TPC_CTRL_STAT(band) :\n\t      MT_WF_PHY_TPC_CTRL_STAT_MT7916(band);\n\n\tlen += scnprintf(buf + len, sz - len, \"\\nTx power (bbp)  : %6ld\\n\",\n\t\t\t mt76_get_field(dev, reg, MT_WF_PHY_TPC_POWER));\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, len);\n\nout:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic ssize_t\nmt7915_rate_txpower_set(struct file *file, const char __user *user_buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct mt7915_phy *phy = file->private_data;\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct mt76_phy *mphy = phy->mt76;\n\tstruct mt7915_mcu_txpower_sku req = {\n\t\t.format_id = TX_POWER_LIMIT_TABLE,\n\t\t.band_idx = phy->mt76->band_idx,\n\t};\n\tchar buf[100];\n\tint i, ret, pwr160 = 0, pwr80 = 0, pwr40 = 0, pwr20 = 0;\n\tenum mac80211_rx_encoding mode;\n\tu32 offs = 0, len = 0;\n\n\tif (count >= sizeof(buf))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, user_buf, count))\n\t\treturn -EFAULT;\n\n\tif (count && buf[count - 1] == '\\n')\n\t\tbuf[count - 1] = '\\0';\n\telse\n\t\tbuf[count] = '\\0';\n\n\tif (sscanf(buf, \"%u %u %u %u %u\",\n\t\t   &mode, &pwr160, &pwr80, &pwr40, &pwr20) != 5) {\n\t\tdev_warn(dev->mt76.dev,\n\t\t\t \"per bandwidth power limit: Mode BW160 BW80 BW40 BW20\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (mode > RX_ENC_HE)\n\t\treturn -EINVAL;\n\n\tif (pwr160)\n\t\tpwr160 = mt7915_get_power_bound(phy, pwr160);\n\tif (pwr80)\n\t\tpwr80 = mt7915_get_power_bound(phy, pwr80);\n\tif (pwr40)\n\t\tpwr40 = mt7915_get_power_bound(phy, pwr40);\n\tif (pwr20)\n\t\tpwr20 = mt7915_get_power_bound(phy, pwr20);\n\n\tif (pwr160 < 0 || pwr80 < 0 || pwr40 < 0 || pwr20 < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mt76.mutex);\n\tret = mt7915_mcu_get_txpower_sku(phy, req.txpower_sku,\n\t\t\t\t\t sizeof(req.txpower_sku));\n\tif (ret)\n\t\tgoto out;\n\n\tmt7915_txpower_sets(SKU_CCK, pwr20, RX_ENC_LEGACY);\n\tmt7915_txpower_sets(SKU_OFDM, pwr20, RX_ENC_LEGACY);\n\tif (mode == RX_ENC_LEGACY)\n\t\tgoto skip;\n\n\tmt7915_txpower_sets(SKU_HT_BW20, pwr20, RX_ENC_HT);\n\tmt7915_txpower_sets(SKU_HT_BW40, pwr40, RX_ENC_HT);\n\tif (mode == RX_ENC_HT)\n\t\tgoto skip;\n\n\tmt7915_txpower_sets(SKU_VHT_BW20, pwr20, RX_ENC_VHT);\n\tmt7915_txpower_sets(SKU_VHT_BW40, pwr40, RX_ENC_VHT);\n\tmt7915_txpower_sets(SKU_VHT_BW80, pwr80, RX_ENC_VHT);\n\tmt7915_txpower_sets(SKU_VHT_BW160, pwr160, RX_ENC_VHT);\n\tif (mode == RX_ENC_VHT)\n\t\tgoto skip;\n\n\tmt7915_txpower_sets(SKU_HE_RU26, pwr20, RX_ENC_HE + 1);\n\tmt7915_txpower_sets(SKU_HE_RU52, pwr20, RX_ENC_HE + 1);\n\tmt7915_txpower_sets(SKU_HE_RU106, pwr20, RX_ENC_HE + 1);\n\tmt7915_txpower_sets(SKU_HE_RU242, pwr20, RX_ENC_HE);\n\tmt7915_txpower_sets(SKU_HE_RU484, pwr40, RX_ENC_HE);\n\tmt7915_txpower_sets(SKU_HE_RU996, pwr80, RX_ENC_HE);\n\tmt7915_txpower_sets(SKU_HE_RU2x996, pwr160, RX_ENC_HE);\nskip:\n\tret = mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(TX_POWER_FEATURE_CTRL),\n\t\t\t\t&req, sizeof(req), true);\n\tif (ret)\n\t\tgoto out;\n\n\tmphy->txpower_cur = max(mphy->txpower_cur,\n\t\t\t\tmax(pwr160, max(pwr80, max(pwr40, pwr20))));\nout:\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn ret ? ret : count;\n}\n\nstatic const struct file_operations mt7915_rate_txpower_fops = {\n\t.write = mt7915_rate_txpower_set,\n\t.read = mt7915_rate_txpower_get,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic int\nmt7915_twt_stats(struct seq_file *s, void *data)\n{\n\tstruct mt7915_dev *dev = dev_get_drvdata(s->private);\n\tstruct mt7915_twt_flow *iter;\n\n\trcu_read_lock();\n\n\tseq_puts(s, \"     wcid |       id |    flags |      exp | mantissa\");\n\tseq_puts(s, \" | duration |            tsf |\\n\");\n\tlist_for_each_entry_rcu(iter, &dev->twt_list, list)\n\t\tseq_printf(s,\n\t\t\t\"%9d | %8d | %5c%c%c%c | %8d | %8d | %8d | %14lld |\\n\",\n\t\t\titer->wcid, iter->id,\n\t\t\titer->sched ? 's' : 'u',\n\t\t\titer->protection ? 'p' : '-',\n\t\t\titer->trigger ? 't' : '-',\n\t\t\titer->flowtype ? '-' : 'a',\n\t\t\titer->exp, iter->mantissa,\n\t\t\titer->duration, iter->tsf);\n\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\n \nstatic int\nmt7915_rf_regval_get(void *data, u64 *val)\n{\n\tstruct mt7915_dev *dev = data;\n\tu32 regval;\n\tint ret;\n\n\tret = mt7915_mcu_rf_regval(dev, dev->mt76.debugfs_reg, &regval, false);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = regval;\n\n\treturn 0;\n}\n\nstatic int\nmt7915_rf_regval_set(void *data, u64 val)\n{\n\tstruct mt7915_dev *dev = data;\n\tu32 val32 = val;\n\n\treturn mt7915_mcu_rf_regval(dev, dev->mt76.debugfs_reg, &val32, true);\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_rf_regval, mt7915_rf_regval_get,\n\t\t\t mt7915_rf_regval_set, \"0x%08llx\\n\");\n\nint mt7915_init_debugfs(struct mt7915_phy *phy)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tbool ext_phy = phy != &dev->phy;\n\tstruct dentry *dir;\n\n\tdir = mt76_register_debugfs_fops(phy->mt76, NULL);\n\tif (!dir)\n\t\treturn -ENOMEM;\n\tdebugfs_create_file(\"muru_debug\", 0600, dir, dev, &fops_muru_debug);\n\tdebugfs_create_file(\"muru_stats\", 0400, dir, phy,\n\t\t\t    &mt7915_muru_stats_fops);\n\tdebugfs_create_file(\"hw-queues\", 0400, dir, phy,\n\t\t\t    &mt7915_hw_queues_fops);\n\tdebugfs_create_file(\"xmit-queues\", 0400, dir, phy,\n\t\t\t    &mt7915_xmit_queues_fops);\n\tdebugfs_create_file(\"tx_stats\", 0400, dir, phy, &mt7915_tx_stats_fops);\n\tdebugfs_create_file(\"sys_recovery\", 0600, dir, phy,\n\t\t\t    &mt7915_sys_recovery_ops);\n\tdebugfs_create_file(\"fw_debug_wm\", 0600, dir, dev, &fops_fw_debug_wm);\n\tdebugfs_create_file(\"fw_debug_wa\", 0600, dir, dev, &fops_fw_debug_wa);\n\tdebugfs_create_file(\"fw_debug_bin\", 0600, dir, dev, &fops_fw_debug_bin);\n\tdebugfs_create_file(\"fw_util_wm\", 0400, dir, dev,\n\t\t\t    &mt7915_fw_util_wm_fops);\n\tdebugfs_create_file(\"fw_util_wa\", 0400, dir, dev,\n\t\t\t    &mt7915_fw_util_wa_fops);\n\tdebugfs_create_file(\"implicit_txbf\", 0600, dir, dev,\n\t\t\t    &fops_implicit_txbf);\n\tdebugfs_create_file(\"txpower_sku\", 0400, dir, phy,\n\t\t\t    &mt7915_rate_txpower_fops);\n\tdebugfs_create_devm_seqfile(dev->mt76.dev, \"twt_stats\", dir,\n\t\t\t\t    mt7915_twt_stats);\n\tdebugfs_create_file(\"rf_regval\", 0600, dir, dev, &fops_rf_regval);\n\n\tif (!dev->dbdc_support || phy->mt76->band_idx) {\n\t\tdebugfs_create_u32(\"dfs_hw_pattern\", 0400, dir,\n\t\t\t\t   &dev->hw_pattern);\n\t\tdebugfs_create_file(\"radar_trigger\", 0200, dir, dev,\n\t\t\t\t    &fops_radar_trigger);\n\t\tdebugfs_create_devm_seqfile(dev->mt76.dev, \"rdd_monitor\", dir,\n\t\t\t\t\t    mt7915_rdd_monitor);\n\t}\n\n\tif (!ext_phy)\n\t\tdev->debugfs_dir = dir;\n\n\treturn 0;\n}\n\nstatic void\nmt7915_debugfs_write_fwlog(struct mt7915_dev *dev, const void *hdr, int hdrlen,\n\t\t\t const void *data, int len)\n{\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long flags;\n\tvoid *dest;\n\n\tspin_lock_irqsave(&lock, flags);\n\tdest = relay_reserve(dev->relay_fwlog, hdrlen + len + 4);\n\tif (dest) {\n\t\t*(u32 *)dest = hdrlen + len;\n\t\tdest += 4;\n\n\t\tif (hdrlen) {\n\t\t\tmemcpy(dest, hdr, hdrlen);\n\t\t\tdest += hdrlen;\n\t\t}\n\n\t\tmemcpy(dest, data, len);\n\t\trelay_flush(dev->relay_fwlog);\n\t}\n\tspin_unlock_irqrestore(&lock, flags);\n}\n\nvoid mt7915_debugfs_rx_fw_monitor(struct mt7915_dev *dev, const void *data, int len)\n{\n\tstruct {\n\t\t__le32 magic;\n\t\t__le32 timestamp;\n\t\t__le16 msg_type;\n\t\t__le16 len;\n\t} hdr = {\n\t\t.magic = cpu_to_le32(FW_BIN_LOG_MAGIC),\n\t\t.msg_type = cpu_to_le16(PKT_TYPE_RX_FW_MONITOR),\n\t};\n\n\tif (!dev->relay_fwlog)\n\t\treturn;\n\n\thdr.timestamp = cpu_to_le32(mt76_rr(dev, MT_LPON_FRCR(0)));\n\thdr.len = *(__le16 *)data;\n\tmt7915_debugfs_write_fwlog(dev, &hdr, sizeof(hdr), data, len);\n}\n\nbool mt7915_debugfs_rx_log(struct mt7915_dev *dev, const void *data, int len)\n{\n\tif (get_unaligned_le32(data) != FW_BIN_LOG_MAGIC)\n\t\treturn false;\n\n\tif (dev->relay_fwlog)\n\t\tmt7915_debugfs_write_fwlog(dev, NULL, 0, data, len);\n\n\treturn true;\n}\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n \n\nstatic ssize_t mt7915_sta_fixed_rate_set(struct file *file,\n\t\t\t\t\t const char __user *user_buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_sta *sta = file->private_data;\n\tstruct mt7915_sta *msta = (struct mt7915_sta *)sta->drv_priv;\n\tstruct mt7915_dev *dev = msta->vif->phy->dev;\n\tstruct ieee80211_vif *vif;\n\tstruct sta_phy phy = {};\n\tchar buf[100];\n\tint ret;\n\tu32 field;\n\tu8 i, gi, he_ltf;\n\n\tif (count >= sizeof(buf))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, user_buf, count))\n\t\treturn -EFAULT;\n\n\tif (count && buf[count - 1] == '\\n')\n\t\tbuf[count - 1] = '\\0';\n\telse\n\t\tbuf[count] = '\\0';\n\n\t \n\tif (sscanf(buf, \"%hhu %hhu %hhu %hhu %hhu %hhu %hhu %hhu\",\n\t\t   &phy.type, &phy.bw, &phy.nss, &phy.mcs, &gi,\n\t\t   &phy.ldpc, &phy.stbc, &he_ltf) != 8) {\n\t\tdev_warn(dev->mt76.dev,\n\t\t\t \"format: Mode BW NSS MCS (HE)GI LDPC STBC HE_LTF\\n\");\n\t\tfield = RATE_PARAM_AUTO;\n\t\tgoto out;\n\t}\n\n\tphy.ldpc = (phy.bw || phy.ldpc) * GENMASK(2, 0);\n\tfor (i = 0; i <= phy.bw; i++) {\n\t\tphy.sgi |= gi << (i << sta->deflink.he_cap.has_he);\n\t\tphy.he_ltf |= he_ltf << (i << sta->deflink.he_cap.has_he);\n\t}\n\tfield = RATE_PARAM_FIXED;\n\nout:\n\tvif = container_of((void *)msta->vif, struct ieee80211_vif, drv_priv);\n\tret = mt7915_mcu_set_fixed_rate_ctrl(dev, vif, sta, &phy, field);\n\tif (ret)\n\t\treturn -EFAULT;\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_fixed_rate = {\n\t.write = mt7915_sta_fixed_rate_set,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic int\nmt7915_queues_show(struct seq_file *s, void *data)\n{\n\tstruct ieee80211_sta *sta = s->private;\n\n\tmt7915_sta_hw_queue_read(s, sta);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(mt7915_queues);\n\nvoid mt7915_sta_add_debugfs(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_sta *sta, struct dentry *dir)\n{\n\tdebugfs_create_file(\"fixed_rate\", 0600, dir, sta, &fops_fixed_rate);\n\tdebugfs_create_file(\"hw-queues\", 0400, dir, sta, &mt7915_queues_fops);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}