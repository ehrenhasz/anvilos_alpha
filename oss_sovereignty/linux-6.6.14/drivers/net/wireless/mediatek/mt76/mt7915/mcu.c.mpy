{
  "module_name": "mcu.c",
  "hash_id": "27ae3250620c61f2e1087d6cc76ab40a1e3544dc05e169ddfb1af3655b15355b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7915/mcu.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include \"mt7915.h\"\n#include \"mcu.h\"\n#include \"mac.h\"\n#include \"eeprom.h\"\n\n#define fw_name(_dev, name, ...)\t({\t\t\t\\\n\tchar *_fw;\t\t\t\t\t\t\\\n\tswitch (mt76_chip(&(_dev)->mt76)) {\t\t\t\\\n\tcase 0x7915:\t\t\t\t\t\t\\\n\t\t_fw = MT7915_##name;\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\\\n\tcase 0x7981:\t\t\t\t\t\t\\\n\t\t_fw = MT7981_##name;\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\\\n\tcase 0x7986:\t\t\t\t\t\t\\\n\t\t_fw = MT7986_##name##__VA_ARGS__;\t\t\\\n\t\tbreak;\t\t\t\t\t\t\\\n\tdefault:\t\t\t\t\t\t\\\n\t\t_fw = MT7916_##name;\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\t_fw;\t\t\t\t\t\t\t\\\n})\n\n#define fw_name_var(_dev, name)\t\t(mt7915_check_adie(dev, false) ?\t\\\n\t\t\t\t\t fw_name(_dev, name) :\t\t\t\\\n\t\t\t\t\t fw_name(_dev, name, _MT7975))\n\n#define MCU_PATCH_ADDRESS\t\t0x200000\n\n#define HE_PHY(p, c)\t\t\tu8_get_bits(c, IEEE80211_HE_PHY_##p)\n#define HE_MAC(m, c)\t\t\tu8_get_bits(c, IEEE80211_HE_MAC_##m)\n\nstatic bool sr_scene_detect = true;\nmodule_param(sr_scene_detect, bool, 0644);\nMODULE_PARM_DESC(sr_scene_detect, \"Enable firmware scene detection algorithm\");\n\nstatic u8\nmt7915_mcu_get_sta_nss(u16 mcs_map)\n{\n\tu8 nss;\n\n\tfor (nss = 8; nss > 0; nss--) {\n\t\tu8 nss_mcs = (mcs_map >> (2 * (nss - 1))) & 3;\n\n\t\tif (nss_mcs != IEEE80211_VHT_MCS_NOT_SUPPORTED)\n\t\t\tbreak;\n\t}\n\n\treturn nss - 1;\n}\n\nstatic void\nmt7915_mcu_set_sta_he_mcs(struct ieee80211_sta *sta, __le16 *he_mcs,\n\t\t\t  u16 mcs_map)\n{\n\tstruct mt7915_sta *msta = (struct mt7915_sta *)sta->drv_priv;\n\tstruct mt7915_dev *dev = msta->vif->phy->dev;\n\tenum nl80211_band band = msta->vif->phy->mt76->chandef.chan->band;\n\tconst u16 *mask = msta->vif->bitrate_mask.control[band].he_mcs;\n\tint nss, max_nss = sta->deflink.rx_nss > 3 ? 4 : sta->deflink.rx_nss;\n\n\tfor (nss = 0; nss < max_nss; nss++) {\n\t\tint mcs;\n\n\t\tswitch ((mcs_map >> (2 * nss)) & 0x3) {\n\t\tcase IEEE80211_HE_MCS_SUPPORT_0_11:\n\t\t\tmcs = GENMASK(11, 0);\n\t\t\tbreak;\n\t\tcase IEEE80211_HE_MCS_SUPPORT_0_9:\n\t\t\tmcs = GENMASK(9, 0);\n\t\t\tbreak;\n\t\tcase IEEE80211_HE_MCS_SUPPORT_0_7:\n\t\t\tmcs = GENMASK(7, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmcs = 0;\n\t\t}\n\n\t\tmcs = mcs ? fls(mcs & mask[nss]) - 1 : -1;\n\n\t\tswitch (mcs) {\n\t\tcase 0 ... 7:\n\t\t\tmcs = IEEE80211_HE_MCS_SUPPORT_0_7;\n\t\t\tbreak;\n\t\tcase 8 ... 9:\n\t\t\tmcs = IEEE80211_HE_MCS_SUPPORT_0_9;\n\t\t\tbreak;\n\t\tcase 10 ... 11:\n\t\t\tmcs = IEEE80211_HE_MCS_SUPPORT_0_11;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmcs = IEEE80211_HE_MCS_NOT_SUPPORTED;\n\t\t\tbreak;\n\t\t}\n\t\tmcs_map &= ~(0x3 << (nss * 2));\n\t\tmcs_map |= mcs << (nss * 2);\n\n\t\t \n\t\tif (is_mt7915(&dev->mt76) && nss > 1 &&\n\t\t    sta->deflink.bandwidth == IEEE80211_STA_RX_BW_160)\n\t\t\tbreak;\n\t}\n\n\t*he_mcs = cpu_to_le16(mcs_map);\n}\n\nstatic void\nmt7915_mcu_set_sta_vht_mcs(struct ieee80211_sta *sta, __le16 *vht_mcs,\n\t\t\t   const u16 *mask)\n{\n\tstruct mt7915_sta *msta = (struct mt7915_sta *)sta->drv_priv;\n\tstruct mt7915_dev *dev = msta->vif->phy->dev;\n\tu16 mcs_map = le16_to_cpu(sta->deflink.vht_cap.vht_mcs.rx_mcs_map);\n\tint nss, max_nss = sta->deflink.rx_nss > 3 ? 4 : sta->deflink.rx_nss;\n\tu16 mcs;\n\n\tfor (nss = 0; nss < max_nss; nss++, mcs_map >>= 2) {\n\t\tswitch (mcs_map & 0x3) {\n\t\tcase IEEE80211_VHT_MCS_SUPPORT_0_9:\n\t\t\tmcs = GENMASK(9, 0);\n\t\t\tbreak;\n\t\tcase IEEE80211_VHT_MCS_SUPPORT_0_8:\n\t\t\tmcs = GENMASK(8, 0);\n\t\t\tbreak;\n\t\tcase IEEE80211_VHT_MCS_SUPPORT_0_7:\n\t\t\tmcs = GENMASK(7, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmcs = 0;\n\t\t}\n\n\t\tvht_mcs[nss] = cpu_to_le16(mcs & mask[nss]);\n\n\t\t \n\t\tif (is_mt7915(&dev->mt76) && nss > 1 &&\n\t\t    sta->deflink.bandwidth == IEEE80211_STA_RX_BW_160)\n\t\t\tbreak;\n\t}\n}\n\nstatic void\nmt7915_mcu_set_sta_ht_mcs(struct ieee80211_sta *sta, u8 *ht_mcs,\n\t\t\t  const u8 *mask)\n{\n\tint nss, max_nss = sta->deflink.rx_nss > 3 ? 4 : sta->deflink.rx_nss;\n\n\tfor (nss = 0; nss < max_nss; nss++)\n\t\tht_mcs[nss] = sta->deflink.ht_cap.mcs.rx_mask[nss] & mask[nss];\n}\n\nstatic int\nmt7915_mcu_parse_response(struct mt76_dev *mdev, int cmd,\n\t\t\t  struct sk_buff *skb, int seq)\n{\n\tstruct mt76_connac2_mcu_rxd *rxd;\n\tint ret = 0;\n\n\tif (!skb) {\n\t\tdev_err(mdev->dev, \"Message %08x (seq %d) timeout\\n\",\n\t\t\tcmd, seq);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\trxd = (struct mt76_connac2_mcu_rxd *)skb->data;\n\tif (seq != rxd->seq &&\n\t    !(rxd->eid == MCU_CMD_EXT_CID &&\n\t      rxd->ext_eid == MCU_EXT_EVENT_WA_TX_STAT))\n\t\treturn -EAGAIN;\n\n\tif (cmd == MCU_CMD(PATCH_SEM_CONTROL)) {\n\t\tskb_pull(skb, sizeof(*rxd) - 4);\n\t\tret = *skb->data;\n\t} else if (cmd == MCU_EXT_CMD(THERMAL_CTRL)) {\n\t\tskb_pull(skb, sizeof(*rxd) + 4);\n\t\tret = le32_to_cpu(*(__le32 *)skb->data);\n\t} else {\n\t\tskb_pull(skb, sizeof(struct mt76_connac2_mcu_rxd));\n\t}\n\n\treturn ret;\n}\n\nstatic int\nmt7915_mcu_send_message(struct mt76_dev *mdev, struct sk_buff *skb,\n\t\t\tint cmd, int *wait_seq)\n{\n\tstruct mt7915_dev *dev = container_of(mdev, struct mt7915_dev, mt76);\n\tenum mt76_mcuq_id qid;\n\tint ret;\n\n\tret = mt76_connac2_mcu_fill_message(mdev, skb, cmd, wait_seq);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cmd == MCU_CMD(FW_SCATTER))\n\t\tqid = MT_MCUQ_FWDL;\n\telse if (test_bit(MT76_STATE_MCU_RUNNING, &dev->mphy.state))\n\t\tqid = MT_MCUQ_WA;\n\telse\n\t\tqid = MT_MCUQ_WM;\n\n\treturn mt76_tx_queue_skb_raw(dev, mdev->q_mcu[qid], skb, 0);\n}\n\nint mt7915_mcu_wa_cmd(struct mt7915_dev *dev, int cmd, u32 a1, u32 a2, u32 a3)\n{\n\tstruct {\n\t\t__le32 args[3];\n\t} req = {\n\t\t.args = {\n\t\t\tcpu_to_le32(a1),\n\t\t\tcpu_to_le32(a2),\n\t\t\tcpu_to_le32(a3),\n\t\t},\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, cmd, &req, sizeof(req), false);\n}\n\nstatic void\nmt7915_mcu_csa_finish(void *priv, u8 *mac, struct ieee80211_vif *vif)\n{\n\tif (vif->bss_conf.csa_active)\n\t\tieee80211_csa_finish(vif);\n}\n\nstatic void\nmt7915_mcu_rx_csa_notify(struct mt7915_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt76_phy *mphy = &dev->mt76.phy;\n\tstruct mt7915_mcu_csa_notify *c;\n\n\tc = (struct mt7915_mcu_csa_notify *)skb->data;\n\n\tif (c->band_idx > MT_BAND1)\n\t\treturn;\n\n\tif ((c->band_idx && !dev->phy.mt76->band_idx) &&\n\t    dev->mt76.phys[MT_BAND1])\n\t\tmphy = dev->mt76.phys[MT_BAND1];\n\n\tieee80211_iterate_active_interfaces_atomic(mphy->hw,\n\t\t\tIEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\tmt7915_mcu_csa_finish, mphy->hw);\n}\n\nstatic void\nmt7915_mcu_rx_thermal_notify(struct mt7915_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt76_phy *mphy = &dev->mt76.phy;\n\tstruct mt7915_mcu_thermal_notify *t;\n\tstruct mt7915_phy *phy;\n\n\tt = (struct mt7915_mcu_thermal_notify *)skb->data;\n\tif (t->ctrl.ctrl_id != THERMAL_PROTECT_ENABLE)\n\t\treturn;\n\n\tif (t->ctrl.band_idx > MT_BAND1)\n\t\treturn;\n\n\tif ((t->ctrl.band_idx && !dev->phy.mt76->band_idx) &&\n\t    dev->mt76.phys[MT_BAND1])\n\t\tmphy = dev->mt76.phys[MT_BAND1];\n\n\tphy = (struct mt7915_phy *)mphy->priv;\n\tphy->throttle_state = t->ctrl.duty.duty_cycle;\n}\n\nstatic void\nmt7915_mcu_rx_radar_detected(struct mt7915_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt76_phy *mphy = &dev->mt76.phy;\n\tstruct mt7915_mcu_rdd_report *r;\n\n\tr = (struct mt7915_mcu_rdd_report *)skb->data;\n\n\tif (r->band_idx > MT_RX_SEL2)\n\t\treturn;\n\n\tif ((r->band_idx && !dev->phy.mt76->band_idx) &&\n\t    dev->mt76.phys[MT_BAND1])\n\t\tmphy = dev->mt76.phys[MT_BAND1];\n\n\tif (r->band_idx == MT_RX_SEL2)\n\t\tcfg80211_background_radar_event(mphy->hw->wiphy,\n\t\t\t\t\t\t&dev->rdd2_chandef,\n\t\t\t\t\t\tGFP_ATOMIC);\n\telse\n\t\tieee80211_radar_detected(mphy->hw);\n\tdev->hw_pattern++;\n}\n\nstatic void\nmt7915_mcu_rx_log_message(struct mt7915_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt76_connac2_mcu_rxd *rxd;\n\tint len = skb->len - sizeof(*rxd);\n\tconst char *data, *type;\n\n\trxd = (struct mt76_connac2_mcu_rxd *)skb->data;\n\tdata = (char *)&rxd[1];\n\n\tswitch (rxd->s2d_index) {\n\tcase 0:\n\t\tif (mt7915_debugfs_rx_log(dev, data, len))\n\t\t\treturn;\n\n\t\ttype = \"WM\";\n\t\tbreak;\n\tcase 2:\n\t\ttype = \"WA\";\n\t\tbreak;\n\tdefault:\n\t\ttype = \"unknown\";\n\t\tbreak;\n\t}\n\n\twiphy_info(mt76_hw(dev)->wiphy, \"%s: %.*s\", type, len, data);\n}\n\nstatic void\nmt7915_mcu_cca_finish(void *priv, u8 *mac, struct ieee80211_vif *vif)\n{\n\tif (!vif->bss_conf.color_change_active)\n\t\treturn;\n\n\tieee80211_color_change_finish(vif);\n}\n\nstatic void\nmt7915_mcu_rx_bcc_notify(struct mt7915_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt76_phy *mphy = &dev->mt76.phy;\n\tstruct mt7915_mcu_bcc_notify *b;\n\n\tb = (struct mt7915_mcu_bcc_notify *)skb->data;\n\n\tif (b->band_idx > MT_BAND1)\n\t\treturn;\n\n\tif ((b->band_idx && !dev->phy.mt76->band_idx) &&\n\t    dev->mt76.phys[MT_BAND1])\n\t\tmphy = dev->mt76.phys[MT_BAND1];\n\n\tieee80211_iterate_active_interfaces_atomic(mphy->hw,\n\t\t\tIEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\tmt7915_mcu_cca_finish, mphy->hw);\n}\n\nstatic void\nmt7915_mcu_rx_ext_event(struct mt7915_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt76_connac2_mcu_rxd *rxd;\n\n\trxd = (struct mt76_connac2_mcu_rxd *)skb->data;\n\tswitch (rxd->ext_eid) {\n\tcase MCU_EXT_EVENT_THERMAL_PROTECT:\n\t\tmt7915_mcu_rx_thermal_notify(dev, skb);\n\t\tbreak;\n\tcase MCU_EXT_EVENT_RDD_REPORT:\n\t\tmt7915_mcu_rx_radar_detected(dev, skb);\n\t\tbreak;\n\tcase MCU_EXT_EVENT_CSA_NOTIFY:\n\t\tmt7915_mcu_rx_csa_notify(dev, skb);\n\t\tbreak;\n\tcase MCU_EXT_EVENT_FW_LOG_2_HOST:\n\t\tmt7915_mcu_rx_log_message(dev, skb);\n\t\tbreak;\n\tcase MCU_EXT_EVENT_BCC_NOTIFY:\n\t\tmt7915_mcu_rx_bcc_notify(dev, skb);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\nmt7915_mcu_rx_unsolicited_event(struct mt7915_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt76_connac2_mcu_rxd *rxd;\n\n\trxd = (struct mt76_connac2_mcu_rxd *)skb->data;\n\tswitch (rxd->eid) {\n\tcase MCU_EVENT_EXT:\n\t\tmt7915_mcu_rx_ext_event(dev, skb);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tdev_kfree_skb(skb);\n}\n\nvoid mt7915_mcu_rx_event(struct mt7915_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt76_connac2_mcu_rxd *rxd;\n\n\trxd = (struct mt76_connac2_mcu_rxd *)skb->data;\n\tif ((rxd->ext_eid == MCU_EXT_EVENT_THERMAL_PROTECT ||\n\t     rxd->ext_eid == MCU_EXT_EVENT_FW_LOG_2_HOST ||\n\t     rxd->ext_eid == MCU_EXT_EVENT_ASSERT_DUMP ||\n\t     rxd->ext_eid == MCU_EXT_EVENT_PS_SYNC ||\n\t     rxd->ext_eid == MCU_EXT_EVENT_BCC_NOTIFY ||\n\t     !rxd->seq) &&\n\t     !(rxd->eid == MCU_CMD_EXT_CID &&\n\t       rxd->ext_eid == MCU_EXT_EVENT_WA_TX_STAT))\n\t\tmt7915_mcu_rx_unsolicited_event(dev, skb);\n\telse\n\t\tmt76_mcu_rx_event(&dev->mt76, skb);\n}\n\nstatic struct tlv *\nmt7915_mcu_add_nested_subtlv(struct sk_buff *skb, int sub_tag, int sub_len,\n\t\t\t     __le16 *sub_ntlv, __le16 *len)\n{\n\tstruct tlv *ptlv, tlv = {\n\t\t.tag = cpu_to_le16(sub_tag),\n\t\t.len = cpu_to_le16(sub_len),\n\t};\n\n\tptlv = skb_put(skb, sub_len);\n\tmemcpy(ptlv, &tlv, sizeof(tlv));\n\n\tle16_add_cpu(sub_ntlv, 1);\n\tle16_add_cpu(len, sub_len);\n\n\treturn ptlv;\n}\n\n \nstruct mt7915_he_obss_narrow_bw_ru_data {\n\tbool tolerated;\n};\n\nstatic void mt7915_check_he_obss_narrow_bw_ru_iter(struct wiphy *wiphy,\n\t\t\t\t\t\t   struct cfg80211_bss *bss,\n\t\t\t\t\t\t   void *_data)\n{\n\tstruct mt7915_he_obss_narrow_bw_ru_data *data = _data;\n\tconst struct element *elem;\n\n\trcu_read_lock();\n\telem = ieee80211_bss_get_elem(bss, WLAN_EID_EXT_CAPABILITY);\n\n\tif (!elem || elem->datalen <= 10 ||\n\t    !(elem->data[10] &\n\t      WLAN_EXT_CAPA10_OBSS_NARROW_BW_RU_TOLERANCE_SUPPORT))\n\t\tdata->tolerated = false;\n\n\trcu_read_unlock();\n}\n\nstatic bool mt7915_check_he_obss_narrow_bw_ru(struct ieee80211_hw *hw,\n\t\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct mt7915_he_obss_narrow_bw_ru_data iter_data = {\n\t\t.tolerated = true,\n\t};\n\n\tif (!(vif->bss_conf.chandef.chan->flags & IEEE80211_CHAN_RADAR))\n\t\treturn false;\n\n\tcfg80211_bss_iter(hw->wiphy, &vif->bss_conf.chandef,\n\t\t\t  mt7915_check_he_obss_narrow_bw_ru_iter,\n\t\t\t  &iter_data);\n\n\t \n\treturn !iter_data.tolerated;\n}\n\nstatic void\nmt7915_mcu_bss_rfch_tlv(struct sk_buff *skb, struct ieee80211_vif *vif,\n\t\t\tstruct mt7915_phy *phy)\n{\n\tstruct cfg80211_chan_def *chandef = &phy->mt76->chandef;\n\tstruct bss_info_rf_ch *ch;\n\tstruct tlv *tlv;\n\tint freq1 = chandef->center_freq1;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, BSS_INFO_RF_CH, sizeof(*ch));\n\n\tch = (struct bss_info_rf_ch *)tlv;\n\tch->pri_ch = chandef->chan->hw_value;\n\tch->center_ch0 = ieee80211_frequency_to_channel(freq1);\n\tch->bw = mt76_connac_chan_bw(chandef);\n\n\tif (chandef->width == NL80211_CHAN_WIDTH_80P80) {\n\t\tint freq2 = chandef->center_freq2;\n\n\t\tch->center_ch1 = ieee80211_frequency_to_channel(freq2);\n\t}\n\n\tif (vif->bss_conf.he_support && vif->type == NL80211_IFTYPE_STATION) {\n\t\tstruct mt76_phy *mphy = phy->mt76;\n\n\t\tch->he_ru26_block =\n\t\t\tmt7915_check_he_obss_narrow_bw_ru(mphy->hw, vif);\n\t\tch->he_all_disable = false;\n\t} else {\n\t\tch->he_all_disable = true;\n\t}\n}\n\nstatic void\nmt7915_mcu_bss_ra_tlv(struct sk_buff *skb, struct ieee80211_vif *vif,\n\t\t      struct mt7915_phy *phy)\n{\n\tint max_nss = hweight8(phy->mt76->antenna_mask);\n\tstruct bss_info_ra *ra;\n\tstruct tlv *tlv;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, BSS_INFO_RA, sizeof(*ra));\n\n\tra = (struct bss_info_ra *)tlv;\n\tra->op_mode = vif->type == NL80211_IFTYPE_AP;\n\tra->adhoc_en = vif->type == NL80211_IFTYPE_ADHOC;\n\tra->short_preamble = true;\n\tra->tx_streams = max_nss;\n\tra->rx_streams = max_nss;\n\tra->algo = 4;\n\tra->train_up_rule = 2;\n\tra->train_up_high_thres = 110;\n\tra->train_up_rule_rssi = -70;\n\tra->low_traffic_thres = 2;\n\tra->phy_cap = cpu_to_le32(0xfdf);\n\tra->interval = cpu_to_le32(500);\n\tra->fast_interval = cpu_to_le32(100);\n}\n\nstatic void\nmt7915_mcu_bss_he_tlv(struct sk_buff *skb, struct ieee80211_vif *vif,\n\t\t      struct mt7915_phy *phy)\n{\n#define DEFAULT_HE_PE_DURATION\t\t4\n#define DEFAULT_HE_DURATION_RTS_THRES\t1023\n\tconst struct ieee80211_sta_he_cap *cap;\n\tstruct bss_info_he *he;\n\tstruct tlv *tlv;\n\n\tcap = mt76_connac_get_he_phy_cap(phy->mt76, vif);\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, BSS_INFO_HE_BASIC, sizeof(*he));\n\n\the = (struct bss_info_he *)tlv;\n\the->he_pe_duration = vif->bss_conf.htc_trig_based_pkt_ext;\n\tif (!he->he_pe_duration)\n\t\the->he_pe_duration = DEFAULT_HE_PE_DURATION;\n\n\the->he_rts_thres = cpu_to_le16(vif->bss_conf.frame_time_rts_th);\n\tif (!he->he_rts_thres)\n\t\the->he_rts_thres = cpu_to_le16(DEFAULT_HE_DURATION_RTS_THRES);\n\n\the->max_nss_mcs[CMD_HE_MCS_BW80] = cap->he_mcs_nss_supp.tx_mcs_80;\n\the->max_nss_mcs[CMD_HE_MCS_BW160] = cap->he_mcs_nss_supp.tx_mcs_160;\n\the->max_nss_mcs[CMD_HE_MCS_BW8080] = cap->he_mcs_nss_supp.tx_mcs_80p80;\n}\n\nstatic void\nmt7915_mcu_bss_hw_amsdu_tlv(struct sk_buff *skb)\n{\n#define TXD_CMP_MAP1\t\tGENMASK(15, 0)\n#define TXD_CMP_MAP2\t\t(GENMASK(31, 0) & ~BIT(23))\n\tstruct bss_info_hw_amsdu *amsdu;\n\tstruct tlv *tlv;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, BSS_INFO_HW_AMSDU, sizeof(*amsdu));\n\n\tamsdu = (struct bss_info_hw_amsdu *)tlv;\n\tamsdu->cmp_bitmap_0 = cpu_to_le32(TXD_CMP_MAP1);\n\tamsdu->cmp_bitmap_1 = cpu_to_le32(TXD_CMP_MAP2);\n\tamsdu->trig_thres = cpu_to_le16(2);\n\tamsdu->enable = true;\n}\n\nstatic void\nmt7915_mcu_bss_bmc_tlv(struct sk_buff *skb, struct mt7915_phy *phy)\n{\n\tstruct bss_info_bmc_rate *bmc;\n\tstruct cfg80211_chan_def *chandef = &phy->mt76->chandef;\n\tenum nl80211_band band = chandef->chan->band;\n\tstruct tlv *tlv;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, BSS_INFO_BMC_RATE, sizeof(*bmc));\n\n\tbmc = (struct bss_info_bmc_rate *)tlv;\n\tif (band == NL80211_BAND_2GHZ) {\n\t\tbmc->short_preamble = true;\n\t} else {\n\t\tbmc->bc_trans = cpu_to_le16(0x2000);\n\t\tbmc->mc_trans = cpu_to_le16(0x2080);\n\t}\n}\n\nstatic int\nmt7915_mcu_muar_config(struct mt7915_phy *phy, struct ieee80211_vif *vif,\n\t\t       bool bssid, bool enable)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tu32 idx = mvif->mt76.omac_idx - REPEATER_BSSID_START;\n\tu32 mask = phy->omac_mask >> 32 & ~BIT(idx);\n\tconst u8 *addr = vif->addr;\n\tstruct {\n\t\tu8 mode;\n\t\tu8 force_clear;\n\t\tu8 clear_bitmap[8];\n\t\tu8 entry_count;\n\t\tu8 write;\n\t\tu8 band;\n\n\t\tu8 index;\n\t\tu8 bssid;\n\t\tu8 addr[ETH_ALEN];\n\t} __packed req = {\n\t\t.mode = !!mask || enable,\n\t\t.entry_count = 1,\n\t\t.write = 1,\n\t\t.band = phy->mt76->band_idx,\n\t\t.index = idx * 2 + bssid,\n\t};\n\n\tif (bssid)\n\t\taddr = vif->bss_conf.bssid;\n\n\tif (enable)\n\t\tether_addr_copy(req.addr, addr);\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(MUAR_UPDATE), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nint mt7915_mcu_add_bss_info(struct mt7915_phy *phy,\n\t\t\t    struct ieee80211_vif *vif, int enable)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct sk_buff *skb;\n\n\tif (mvif->mt76.omac_idx >= REPEATER_BSSID_START) {\n\t\tmt7915_mcu_muar_config(phy, vif, false, enable);\n\t\tmt7915_mcu_muar_config(phy, vif, true, enable);\n\t}\n\n\tskb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->mt76, NULL,\n\t\t\t\t\t      MT7915_BSS_UPDATE_MAX_SIZE);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\t \n\tif (enable)\n\t\tmt76_connac_mcu_bss_omac_tlv(skb, vif);\n\n\tmt76_connac_mcu_bss_basic_tlv(skb, vif, NULL, phy->mt76,\n\t\t\t\t      mvif->sta.wcid.idx, enable);\n\n\tif (vif->type == NL80211_IFTYPE_MONITOR)\n\t\tgoto out;\n\n\tif (enable) {\n\t\tmt7915_mcu_bss_rfch_tlv(skb, vif, phy);\n\t\tmt7915_mcu_bss_bmc_tlv(skb, phy);\n\t\tmt7915_mcu_bss_ra_tlv(skb, vif, phy);\n\t\tmt7915_mcu_bss_hw_amsdu_tlv(skb);\n\n\t\tif (vif->bss_conf.he_support)\n\t\t\tmt7915_mcu_bss_he_tlv(skb, vif, phy);\n\n\t\tif (mvif->mt76.omac_idx >= EXT_BSSID_START &&\n\t\t    mvif->mt76.omac_idx < REPEATER_BSSID_START)\n\t\t\tmt76_connac_mcu_bss_ext_tlv(skb, &mvif->mt76);\n\t}\nout:\n\treturn mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t     MCU_EXT_CMD(BSS_INFO_UPDATE), true);\n}\n\n \nint mt7915_mcu_add_tx_ba(struct mt7915_dev *dev,\n\t\t\t struct ieee80211_ampdu_params *params,\n\t\t\t bool enable)\n{\n\tstruct mt7915_sta *msta = (struct mt7915_sta *)params->sta->drv_priv;\n\tstruct mt7915_vif *mvif = msta->vif;\n\n\tif (enable && !params->amsdu)\n\t\tmsta->wcid.amsdu = false;\n\n\treturn mt76_connac_mcu_sta_ba(&dev->mt76, &mvif->mt76, params,\n\t\t\t\t      MCU_EXT_CMD(STA_REC_UPDATE),\n\t\t\t\t      enable, true);\n}\n\nint mt7915_mcu_add_rx_ba(struct mt7915_dev *dev,\n\t\t\t struct ieee80211_ampdu_params *params,\n\t\t\t bool enable)\n{\n\tstruct mt7915_sta *msta = (struct mt7915_sta *)params->sta->drv_priv;\n\tstruct mt7915_vif *mvif = msta->vif;\n\n\treturn mt76_connac_mcu_sta_ba(&dev->mt76, &mvif->mt76, params,\n\t\t\t\t      MCU_EXT_CMD(STA_REC_UPDATE),\n\t\t\t\t      enable, false);\n}\n\nstatic void\nmt7915_mcu_sta_he_tlv(struct sk_buff *skb, struct ieee80211_sta *sta,\n\t\t      struct ieee80211_vif *vif)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct ieee80211_he_cap_elem *elem = &sta->deflink.he_cap.he_cap_elem;\n\tstruct ieee80211_he_mcs_nss_supp mcs_map;\n\tstruct sta_rec_he *he;\n\tstruct tlv *tlv;\n\tu32 cap = 0;\n\n\tif (!sta->deflink.he_cap.has_he)\n\t\treturn;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_HE, sizeof(*he));\n\n\the = (struct sta_rec_he *)tlv;\n\n\tif (elem->mac_cap_info[0] & IEEE80211_HE_MAC_CAP0_HTC_HE)\n\t\tcap |= STA_REC_HE_CAP_HTC;\n\n\tif (elem->mac_cap_info[2] & IEEE80211_HE_MAC_CAP2_BSR)\n\t\tcap |= STA_REC_HE_CAP_BSR;\n\n\tif (elem->mac_cap_info[3] & IEEE80211_HE_MAC_CAP3_OMI_CONTROL)\n\t\tcap |= STA_REC_HE_CAP_OM;\n\n\tif (elem->mac_cap_info[4] & IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU)\n\t\tcap |= STA_REC_HE_CAP_AMSDU_IN_AMPDU;\n\n\tif (elem->mac_cap_info[4] & IEEE80211_HE_MAC_CAP4_BQR)\n\t\tcap |= STA_REC_HE_CAP_BQR;\n\n\tif (elem->phy_cap_info[0] &\n\t    (IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_RU_MAPPING_IN_2G |\n\t     IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_RU_MAPPING_IN_5G))\n\t\tcap |= STA_REC_HE_CAP_BW20_RU242_SUPPORT;\n\n\tif (mvif->cap.he_ldpc &&\n\t    (elem->phy_cap_info[1] &\n\t     IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD))\n\t\tcap |= STA_REC_HE_CAP_LDPC;\n\n\tif (elem->phy_cap_info[1] &\n\t    IEEE80211_HE_PHY_CAP1_HE_LTF_AND_GI_FOR_HE_PPDUS_0_8US)\n\t\tcap |= STA_REC_HE_CAP_SU_PPDU_1LTF_8US_GI;\n\n\tif (elem->phy_cap_info[2] &\n\t    IEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US)\n\t\tcap |= STA_REC_HE_CAP_NDP_4LTF_3DOT2MS_GI;\n\n\tif (elem->phy_cap_info[2] &\n\t    IEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ)\n\t\tcap |= STA_REC_HE_CAP_LE_EQ_80M_TX_STBC;\n\n\tif (elem->phy_cap_info[2] &\n\t    IEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ)\n\t\tcap |= STA_REC_HE_CAP_LE_EQ_80M_RX_STBC;\n\n\tif (elem->phy_cap_info[6] &\n\t    IEEE80211_HE_PHY_CAP6_TRIG_CQI_FB)\n\t\tcap |= STA_REC_HE_CAP_TRIG_CQI_FK;\n\n\tif (elem->phy_cap_info[6] &\n\t    IEEE80211_HE_PHY_CAP6_PARTIAL_BW_EXT_RANGE)\n\t\tcap |= STA_REC_HE_CAP_PARTIAL_BW_EXT_RANGE;\n\n\tif (elem->phy_cap_info[7] &\n\t    IEEE80211_HE_PHY_CAP7_HE_SU_MU_PPDU_4XLTF_AND_08_US_GI)\n\t\tcap |= STA_REC_HE_CAP_SU_MU_PPDU_4LTF_8US_GI;\n\n\tif (elem->phy_cap_info[7] &\n\t    IEEE80211_HE_PHY_CAP7_STBC_TX_ABOVE_80MHZ)\n\t\tcap |= STA_REC_HE_CAP_GT_80M_TX_STBC;\n\n\tif (elem->phy_cap_info[7] &\n\t    IEEE80211_HE_PHY_CAP7_STBC_RX_ABOVE_80MHZ)\n\t\tcap |= STA_REC_HE_CAP_GT_80M_RX_STBC;\n\n\tif (elem->phy_cap_info[8] &\n\t    IEEE80211_HE_PHY_CAP8_HE_ER_SU_PPDU_4XLTF_AND_08_US_GI)\n\t\tcap |= STA_REC_HE_CAP_ER_SU_PPDU_4LTF_8US_GI;\n\n\tif (elem->phy_cap_info[8] &\n\t    IEEE80211_HE_PHY_CAP8_HE_ER_SU_1XLTF_AND_08_US_GI)\n\t\tcap |= STA_REC_HE_CAP_ER_SU_PPDU_1LTF_8US_GI;\n\n\tif (elem->phy_cap_info[9] &\n\t    IEEE80211_HE_PHY_CAP9_TX_1024_QAM_LESS_THAN_242_TONE_RU)\n\t\tcap |= STA_REC_HE_CAP_TX_1024QAM_UNDER_RU242;\n\n\tif (elem->phy_cap_info[9] &\n\t    IEEE80211_HE_PHY_CAP9_RX_1024_QAM_LESS_THAN_242_TONE_RU)\n\t\tcap |= STA_REC_HE_CAP_RX_1024QAM_UNDER_RU242;\n\n\the->he_cap = cpu_to_le32(cap);\n\n\tmcs_map = sta->deflink.he_cap.he_mcs_nss_supp;\n\tswitch (sta->deflink.bandwidth) {\n\tcase IEEE80211_STA_RX_BW_160:\n\t\tif (elem->phy_cap_info[0] &\n\t\t    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G)\n\t\t\tmt7915_mcu_set_sta_he_mcs(sta,\n\t\t\t\t\t\t  &he->max_nss_mcs[CMD_HE_MCS_BW8080],\n\t\t\t\t\t\t  le16_to_cpu(mcs_map.rx_mcs_80p80));\n\n\t\tmt7915_mcu_set_sta_he_mcs(sta,\n\t\t\t\t\t  &he->max_nss_mcs[CMD_HE_MCS_BW160],\n\t\t\t\t\t  le16_to_cpu(mcs_map.rx_mcs_160));\n\t\tfallthrough;\n\tdefault:\n\t\tmt7915_mcu_set_sta_he_mcs(sta,\n\t\t\t\t\t  &he->max_nss_mcs[CMD_HE_MCS_BW80],\n\t\t\t\t\t  le16_to_cpu(mcs_map.rx_mcs_80));\n\t\tbreak;\n\t}\n\n\the->t_frame_dur =\n\t\tHE_MAC(CAP1_TF_MAC_PAD_DUR_MASK, elem->mac_cap_info[1]);\n\the->max_ampdu_exp =\n\t\tHE_MAC(CAP3_MAX_AMPDU_LEN_EXP_MASK, elem->mac_cap_info[3]);\n\n\the->bw_set =\n\t\tHE_PHY(CAP0_CHANNEL_WIDTH_SET_MASK, elem->phy_cap_info[0]);\n\the->device_class =\n\t\tHE_PHY(CAP1_DEVICE_CLASS_A, elem->phy_cap_info[1]);\n\the->punc_pream_rx =\n\t\tHE_PHY(CAP1_PREAMBLE_PUNC_RX_MASK, elem->phy_cap_info[1]);\n\n\the->dcm_tx_mode =\n\t\tHE_PHY(CAP3_DCM_MAX_CONST_TX_MASK, elem->phy_cap_info[3]);\n\the->dcm_tx_max_nss =\n\t\tHE_PHY(CAP3_DCM_MAX_TX_NSS_2, elem->phy_cap_info[3]);\n\the->dcm_rx_mode =\n\t\tHE_PHY(CAP3_DCM_MAX_CONST_RX_MASK, elem->phy_cap_info[3]);\n\the->dcm_rx_max_nss =\n\t\tHE_PHY(CAP3_DCM_MAX_RX_NSS_2, elem->phy_cap_info[3]);\n\the->dcm_rx_max_nss =\n\t\tHE_PHY(CAP8_DCM_MAX_RU_MASK, elem->phy_cap_info[8]);\n\n\the->pkt_ext = 2;\n}\n\nstatic void\nmt7915_mcu_sta_muru_tlv(struct mt7915_dev *dev, struct sk_buff *skb,\n\t\t\tstruct ieee80211_sta *sta, struct ieee80211_vif *vif)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct ieee80211_he_cap_elem *elem = &sta->deflink.he_cap.he_cap_elem;\n\tstruct sta_rec_muru *muru;\n\tstruct tlv *tlv;\n\n\tif (vif->type != NL80211_IFTYPE_STATION &&\n\t    vif->type != NL80211_IFTYPE_AP)\n\t\treturn;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_MURU, sizeof(*muru));\n\n\tmuru = (struct sta_rec_muru *)tlv;\n\n\tmuru->cfg.mimo_dl_en = mvif->cap.he_mu_ebfer ||\n\t\t\t       mvif->cap.vht_mu_ebfer ||\n\t\t\t       mvif->cap.vht_mu_ebfee;\n\tif (!is_mt7915(&dev->mt76))\n\t\tmuru->cfg.mimo_ul_en = true;\n\tmuru->cfg.ofdma_dl_en = true;\n\n\tif (sta->deflink.vht_cap.vht_supported)\n\t\tmuru->mimo_dl.vht_mu_bfee =\n\t\t\t!!(sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE);\n\n\tif (!sta->deflink.he_cap.has_he)\n\t\treturn;\n\n\tmuru->mimo_dl.partial_bw_dl_mimo =\n\t\tHE_PHY(CAP6_PARTIAL_BANDWIDTH_DL_MUMIMO, elem->phy_cap_info[6]);\n\n\tmuru->mimo_ul.full_ul_mimo =\n\t\tHE_PHY(CAP2_UL_MU_FULL_MU_MIMO, elem->phy_cap_info[2]);\n\tmuru->mimo_ul.partial_ul_mimo =\n\t\tHE_PHY(CAP2_UL_MU_PARTIAL_MU_MIMO, elem->phy_cap_info[2]);\n\n\tmuru->ofdma_dl.punc_pream_rx =\n\t\tHE_PHY(CAP1_PREAMBLE_PUNC_RX_MASK, elem->phy_cap_info[1]);\n\tmuru->ofdma_dl.he_20m_in_40m_2g =\n\t\tHE_PHY(CAP8_20MHZ_IN_40MHZ_HE_PPDU_IN_2G, elem->phy_cap_info[8]);\n\tmuru->ofdma_dl.he_20m_in_160m =\n\t\tHE_PHY(CAP8_20MHZ_IN_160MHZ_HE_PPDU, elem->phy_cap_info[8]);\n\tmuru->ofdma_dl.he_80m_in_160m =\n\t\tHE_PHY(CAP8_80MHZ_IN_160MHZ_HE_PPDU, elem->phy_cap_info[8]);\n\n\tmuru->ofdma_ul.t_frame_dur =\n\t\tHE_MAC(CAP1_TF_MAC_PAD_DUR_MASK, elem->mac_cap_info[1]);\n\tmuru->ofdma_ul.mu_cascading =\n\t\tHE_MAC(CAP2_MU_CASCADING, elem->mac_cap_info[2]);\n\tmuru->ofdma_ul.uo_ra =\n\t\tHE_MAC(CAP3_OFDMA_RA, elem->mac_cap_info[3]);\n}\n\nstatic void\nmt7915_mcu_sta_ht_tlv(struct sk_buff *skb, struct ieee80211_sta *sta)\n{\n\tstruct sta_rec_ht *ht;\n\tstruct tlv *tlv;\n\n\tif (!sta->deflink.ht_cap.ht_supported)\n\t\treturn;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_HT, sizeof(*ht));\n\n\tht = (struct sta_rec_ht *)tlv;\n\tht->ht_cap = cpu_to_le16(sta->deflink.ht_cap.cap);\n}\n\nstatic void\nmt7915_mcu_sta_vht_tlv(struct sk_buff *skb, struct ieee80211_sta *sta)\n{\n\tstruct sta_rec_vht *vht;\n\tstruct tlv *tlv;\n\n\tif (!sta->deflink.vht_cap.vht_supported)\n\t\treturn;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_VHT, sizeof(*vht));\n\n\tvht = (struct sta_rec_vht *)tlv;\n\tvht->vht_cap = cpu_to_le32(sta->deflink.vht_cap.cap);\n\tvht->vht_rx_mcs_map = sta->deflink.vht_cap.vht_mcs.rx_mcs_map;\n\tvht->vht_tx_mcs_map = sta->deflink.vht_cap.vht_mcs.tx_mcs_map;\n}\n\nstatic void\nmt7915_mcu_sta_amsdu_tlv(struct mt7915_dev *dev, struct sk_buff *skb,\n\t\t\t struct ieee80211_vif *vif, struct ieee80211_sta *sta)\n{\n\tstruct mt7915_sta *msta = (struct mt7915_sta *)sta->drv_priv;\n\tstruct sta_rec_amsdu *amsdu;\n\tstruct tlv *tlv;\n\n\tif (vif->type != NL80211_IFTYPE_STATION &&\n\t    vif->type != NL80211_IFTYPE_AP)\n\t\treturn;\n\n\tif (!sta->deflink.agg.max_amsdu_len)\n\t    return;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_HW_AMSDU, sizeof(*amsdu));\n\tamsdu = (struct sta_rec_amsdu *)tlv;\n\tamsdu->max_amsdu_num = 8;\n\tamsdu->amsdu_en = true;\n\tmsta->wcid.amsdu = true;\n\n\tswitch (sta->deflink.agg.max_amsdu_len) {\n\tcase IEEE80211_MAX_MPDU_LEN_VHT_11454:\n\t\tif (!is_mt7915(&dev->mt76)) {\n\t\t\tamsdu->max_mpdu_size =\n\t\t\t\tIEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454;\n\t\t\treturn;\n\t\t}\n\t\tfallthrough;\n\tcase IEEE80211_MAX_MPDU_LEN_HT_7935:\n\tcase IEEE80211_MAX_MPDU_LEN_VHT_7991:\n\t\tamsdu->max_mpdu_size = IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991;\n\t\treturn;\n\tdefault:\n\t\tamsdu->max_mpdu_size = IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_3895;\n\t\treturn;\n\t}\n}\n\nstatic int\nmt7915_mcu_sta_wtbl_tlv(struct mt7915_dev *dev, struct sk_buff *skb,\n\t\t\tstruct ieee80211_vif *vif, struct ieee80211_sta *sta)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct mt7915_sta *msta;\n\tstruct wtbl_req_hdr *wtbl_hdr;\n\tstruct mt76_wcid *wcid;\n\tstruct tlv *tlv;\n\n\tmsta = sta ? (struct mt7915_sta *)sta->drv_priv : &mvif->sta;\n\twcid = sta ? &msta->wcid : NULL;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_WTBL, sizeof(struct tlv));\n\twtbl_hdr = mt76_connac_mcu_alloc_wtbl_req(&dev->mt76, &msta->wcid,\n\t\t\t\t\t\t  WTBL_RESET_AND_SET, tlv,\n\t\t\t\t\t\t  &skb);\n\tif (IS_ERR(wtbl_hdr))\n\t\treturn PTR_ERR(wtbl_hdr);\n\n\tmt76_connac_mcu_wtbl_generic_tlv(&dev->mt76, skb, vif, sta, tlv,\n\t\t\t\t\t wtbl_hdr);\n\tmt76_connac_mcu_wtbl_hdr_trans_tlv(skb, vif, wcid, tlv, wtbl_hdr);\n\tif (sta)\n\t\tmt76_connac_mcu_wtbl_ht_tlv(&dev->mt76, skb, sta, tlv,\n\t\t\t\t\t    wtbl_hdr, mvif->cap.ht_ldpc,\n\t\t\t\t\t    mvif->cap.vht_ldpc);\n\n\treturn 0;\n}\n\nstatic inline bool\nmt7915_is_ebf_supported(struct mt7915_phy *phy, struct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_sta *sta, bool bfee)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tint sts = hweight16(phy->mt76->chainmask);\n\n\tif (vif->type != NL80211_IFTYPE_STATION &&\n\t    vif->type != NL80211_IFTYPE_AP)\n\t\treturn false;\n\n\tif (!bfee && sts < 2)\n\t\treturn false;\n\n\tif (sta->deflink.he_cap.has_he) {\n\t\tstruct ieee80211_he_cap_elem *pe = &sta->deflink.he_cap.he_cap_elem;\n\n\t\tif (bfee)\n\t\t\treturn mvif->cap.he_su_ebfee &&\n\t\t\t       HE_PHY(CAP3_SU_BEAMFORMER, pe->phy_cap_info[3]);\n\t\telse\n\t\t\treturn mvif->cap.he_su_ebfer &&\n\t\t\t       HE_PHY(CAP4_SU_BEAMFORMEE, pe->phy_cap_info[4]);\n\t}\n\n\tif (sta->deflink.vht_cap.vht_supported) {\n\t\tu32 cap = sta->deflink.vht_cap.cap;\n\n\t\tif (bfee)\n\t\t\treturn mvif->cap.vht_su_ebfee &&\n\t\t\t       (cap & IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE);\n\t\telse\n\t\t\treturn mvif->cap.vht_su_ebfer &&\n\t\t\t       (cap & IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE);\n\t}\n\n\treturn false;\n}\n\nstatic void\nmt7915_mcu_sta_sounding_rate(struct sta_rec_bf *bf)\n{\n\tbf->sounding_phy = MT_PHY_TYPE_OFDM;\n\tbf->ndp_rate = 0;\t\t\t\t \n\tbf->ndpa_rate = MT7915_CFEND_RATE_DEFAULT;\t \n\tbf->rept_poll_rate = MT7915_CFEND_RATE_DEFAULT;\t \n}\n\nstatic void\nmt7915_mcu_sta_bfer_ht(struct ieee80211_sta *sta, struct mt7915_phy *phy,\n\t\t       struct sta_rec_bf *bf)\n{\n\tstruct ieee80211_mcs_info *mcs = &sta->deflink.ht_cap.mcs;\n\tu8 n = 0;\n\n\tbf->tx_mode = MT_PHY_TYPE_HT;\n\n\tif ((mcs->tx_params & IEEE80211_HT_MCS_TX_RX_DIFF) &&\n\t    (mcs->tx_params & IEEE80211_HT_MCS_TX_DEFINED))\n\t\tn = FIELD_GET(IEEE80211_HT_MCS_TX_MAX_STREAMS_MASK,\n\t\t\t      mcs->tx_params);\n\telse if (mcs->rx_mask[3])\n\t\tn = 3;\n\telse if (mcs->rx_mask[2])\n\t\tn = 2;\n\telse if (mcs->rx_mask[1])\n\t\tn = 1;\n\n\tbf->nrow = hweight8(phy->mt76->chainmask) - 1;\n\tbf->ncol = min_t(u8, bf->nrow, n);\n\tbf->ibf_ncol = n;\n}\n\nstatic void\nmt7915_mcu_sta_bfer_vht(struct ieee80211_sta *sta, struct mt7915_phy *phy,\n\t\t\tstruct sta_rec_bf *bf, bool explicit)\n{\n\tstruct ieee80211_sta_vht_cap *pc = &sta->deflink.vht_cap;\n\tstruct ieee80211_sta_vht_cap *vc = &phy->mt76->sband_5g.sband.vht_cap;\n\tu16 mcs_map = le16_to_cpu(pc->vht_mcs.rx_mcs_map);\n\tu8 nss_mcs = mt7915_mcu_get_sta_nss(mcs_map);\n\tu8 tx_ant = hweight8(phy->mt76->chainmask) - 1;\n\n\tbf->tx_mode = MT_PHY_TYPE_VHT;\n\n\tif (explicit) {\n\t\tu8 sts, snd_dim;\n\n\t\tmt7915_mcu_sta_sounding_rate(bf);\n\n\t\tsts = FIELD_GET(IEEE80211_VHT_CAP_BEAMFORMEE_STS_MASK,\n\t\t\t\tpc->cap);\n\t\tsnd_dim = FIELD_GET(IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MASK,\n\t\t\t\t    vc->cap);\n\t\tbf->nrow = min_t(u8, min_t(u8, snd_dim, sts), tx_ant);\n\t\tbf->ncol = min_t(u8, nss_mcs, bf->nrow);\n\t\tbf->ibf_ncol = bf->ncol;\n\n\t\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_160)\n\t\t\tbf->nrow = 1;\n\t} else {\n\t\tbf->nrow = tx_ant;\n\t\tbf->ncol = min_t(u8, nss_mcs, bf->nrow);\n\t\tbf->ibf_ncol = nss_mcs;\n\n\t\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_160)\n\t\t\tbf->ibf_nrow = 1;\n\t}\n}\n\nstatic void\nmt7915_mcu_sta_bfer_he(struct ieee80211_sta *sta, struct ieee80211_vif *vif,\n\t\t       struct mt7915_phy *phy, struct sta_rec_bf *bf)\n{\n\tstruct ieee80211_sta_he_cap *pc = &sta->deflink.he_cap;\n\tstruct ieee80211_he_cap_elem *pe = &pc->he_cap_elem;\n\tconst struct ieee80211_sta_he_cap *vc =\n\t\tmt76_connac_get_he_phy_cap(phy->mt76, vif);\n\tconst struct ieee80211_he_cap_elem *ve = &vc->he_cap_elem;\n\tu16 mcs_map = le16_to_cpu(pc->he_mcs_nss_supp.rx_mcs_80);\n\tu8 nss_mcs = mt7915_mcu_get_sta_nss(mcs_map);\n\tu8 snd_dim, sts;\n\n\tbf->tx_mode = MT_PHY_TYPE_HE_SU;\n\n\tmt7915_mcu_sta_sounding_rate(bf);\n\n\tbf->trigger_su = HE_PHY(CAP6_TRIG_SU_BEAMFORMING_FB,\n\t\t\t\tpe->phy_cap_info[6]);\n\tbf->trigger_mu = HE_PHY(CAP6_TRIG_MU_BEAMFORMING_PARTIAL_BW_FB,\n\t\t\t\tpe->phy_cap_info[6]);\n\tsnd_dim = HE_PHY(CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_MASK,\n\t\t\t ve->phy_cap_info[5]);\n\tsts = HE_PHY(CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_MASK,\n\t\t     pe->phy_cap_info[4]);\n\tbf->nrow = min_t(u8, snd_dim, sts);\n\tbf->ncol = min_t(u8, nss_mcs, bf->nrow);\n\tbf->ibf_ncol = bf->ncol;\n\n\tif (sta->deflink.bandwidth != IEEE80211_STA_RX_BW_160)\n\t\treturn;\n\n\t \n\tif (pe->phy_cap_info[0] &\n\t    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G) {\n\t\tmcs_map = le16_to_cpu(pc->he_mcs_nss_supp.rx_mcs_160);\n\t\tnss_mcs = mt7915_mcu_get_sta_nss(mcs_map);\n\n\t\tbf->ncol_gt_bw80 = nss_mcs;\n\t}\n\n\tif (pe->phy_cap_info[0] &\n\t    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G) {\n\t\tmcs_map = le16_to_cpu(pc->he_mcs_nss_supp.rx_mcs_80p80);\n\t\tnss_mcs = mt7915_mcu_get_sta_nss(mcs_map);\n\n\t\tif (bf->ncol_gt_bw80)\n\t\t\tbf->ncol_gt_bw80 = min_t(u8, bf->ncol_gt_bw80, nss_mcs);\n\t\telse\n\t\t\tbf->ncol_gt_bw80 = nss_mcs;\n\t}\n\n\tsnd_dim = HE_PHY(CAP5_BEAMFORMEE_NUM_SND_DIM_ABOVE_80MHZ_MASK,\n\t\t\t ve->phy_cap_info[5]);\n\tsts = HE_PHY(CAP4_BEAMFORMEE_MAX_STS_ABOVE_80MHZ_MASK,\n\t\t     pe->phy_cap_info[4]);\n\n\tbf->nrow_gt_bw80 = min_t(int, snd_dim, sts);\n}\n\nstatic void\nmt7915_mcu_sta_bfer_tlv(struct mt7915_dev *dev, struct sk_buff *skb,\n\t\t\tstruct ieee80211_vif *vif, struct ieee80211_sta *sta)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct mt7915_phy *phy = mvif->phy;\n\tint tx_ant = hweight8(phy->mt76->chainmask) - 1;\n\tstruct sta_rec_bf *bf;\n\tstruct tlv *tlv;\n\tconst u8 matrix[4][4] = {\n\t\t{0, 0, 0, 0},\n\t\t{1, 1, 0, 0},\t \n\t\t{2, 4, 4, 0},\t \n\t\t{3, 5, 6, 0}\t \n\t};\n\tbool ebf;\n\n\tif (!(sta->deflink.ht_cap.ht_supported || sta->deflink.he_cap.has_he))\n\t\treturn;\n\n\tebf = mt7915_is_ebf_supported(phy, vif, sta, false);\n\tif (!ebf && !dev->ibf)\n\t\treturn;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_BF, sizeof(*bf));\n\tbf = (struct sta_rec_bf *)tlv;\n\n\t \n\tif (sta->deflink.he_cap.has_he && ebf)\n\t\tmt7915_mcu_sta_bfer_he(sta, vif, phy, bf);\n\telse if (sta->deflink.vht_cap.vht_supported)\n\t\tmt7915_mcu_sta_bfer_vht(sta, phy, bf, ebf);\n\telse if (sta->deflink.ht_cap.ht_supported)\n\t\tmt7915_mcu_sta_bfer_ht(sta, phy, bf);\n\telse\n\t\treturn;\n\n\tbf->bf_cap = ebf ? ebf : dev->ibf << 1;\n\tbf->bw = sta->deflink.bandwidth;\n\tbf->ibf_dbw = sta->deflink.bandwidth;\n\tbf->ibf_nrow = tx_ant;\n\n\tif (!ebf && sta->deflink.bandwidth <= IEEE80211_STA_RX_BW_40 && !bf->ncol)\n\t\tbf->ibf_timeout = 0x48;\n\telse\n\t\tbf->ibf_timeout = 0x18;\n\n\tif (ebf && bf->nrow != tx_ant)\n\t\tbf->mem_20m = matrix[tx_ant][bf->ncol];\n\telse\n\t\tbf->mem_20m = matrix[bf->nrow][bf->ncol];\n\n\tswitch (sta->deflink.bandwidth) {\n\tcase IEEE80211_STA_RX_BW_160:\n\tcase IEEE80211_STA_RX_BW_80:\n\t\tbf->mem_total = bf->mem_20m * 2;\n\t\tbreak;\n\tcase IEEE80211_STA_RX_BW_40:\n\t\tbf->mem_total = bf->mem_20m;\n\t\tbreak;\n\tcase IEEE80211_STA_RX_BW_20:\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\nmt7915_mcu_sta_bfee_tlv(struct mt7915_dev *dev, struct sk_buff *skb,\n\t\t\tstruct ieee80211_vif *vif, struct ieee80211_sta *sta)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct mt7915_phy *phy = mvif->phy;\n\tint tx_ant = hweight8(phy->mt76->chainmask) - 1;\n\tstruct sta_rec_bfee *bfee;\n\tstruct tlv *tlv;\n\tu8 nrow = 0;\n\n\tif (!(sta->deflink.vht_cap.vht_supported || sta->deflink.he_cap.has_he))\n\t\treturn;\n\n\tif (!mt7915_is_ebf_supported(phy, vif, sta, true))\n\t\treturn;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_BFEE, sizeof(*bfee));\n\tbfee = (struct sta_rec_bfee *)tlv;\n\n\tif (sta->deflink.he_cap.has_he) {\n\t\tstruct ieee80211_he_cap_elem *pe = &sta->deflink.he_cap.he_cap_elem;\n\n\t\tnrow = HE_PHY(CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_MASK,\n\t\t\t      pe->phy_cap_info[5]);\n\t} else if (sta->deflink.vht_cap.vht_supported) {\n\t\tstruct ieee80211_sta_vht_cap *pc = &sta->deflink.vht_cap;\n\n\t\tnrow = FIELD_GET(IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MASK,\n\t\t\t\t pc->cap);\n\t}\n\n\t \n\tbfee->fb_identity_matrix = (nrow == 1 && tx_ant == 2);\n}\n\nstatic enum mcu_mmps_mode\nmt7915_mcu_get_mmps_mode(enum ieee80211_smps_mode smps)\n{\n\tswitch (smps) {\n\tcase IEEE80211_SMPS_OFF:\n\t\treturn MCU_MMPS_DISABLE;\n\tcase IEEE80211_SMPS_STATIC:\n\t\treturn MCU_MMPS_STATIC;\n\tcase IEEE80211_SMPS_DYNAMIC:\n\t\treturn MCU_MMPS_DYNAMIC;\n\tdefault:\n\t\treturn MCU_MMPS_DISABLE;\n\t}\n}\n\nint mt7915_mcu_set_fixed_rate_ctrl(struct mt7915_dev *dev,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   void *data, u32 field)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct mt7915_sta *msta = (struct mt7915_sta *)sta->drv_priv;\n\tstruct sta_phy *phy = data;\n\tstruct sta_rec_ra_fixed *ra;\n\tstruct sk_buff *skb;\n\tstruct tlv *tlv;\n\n\tskb = mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->mt76,\n\t\t\t\t\t    &msta->wcid);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_RA_UPDATE, sizeof(*ra));\n\tra = (struct sta_rec_ra_fixed *)tlv;\n\n\tswitch (field) {\n\tcase RATE_PARAM_AUTO:\n\t\tbreak;\n\tcase RATE_PARAM_FIXED:\n\tcase RATE_PARAM_FIXED_MCS:\n\tcase RATE_PARAM_FIXED_GI:\n\tcase RATE_PARAM_FIXED_HE_LTF:\n\t\tif (phy)\n\t\t\tra->phy = *phy;\n\t\tbreak;\n\tcase RATE_PARAM_MMPS_UPDATE:\n\t\tra->mmps_mode = mt7915_mcu_get_mmps_mode(sta->deflink.smps_mode);\n\t\tbreak;\n\tcase RATE_PARAM_SPE_UPDATE:\n\t\tra->spe_idx = *(u8 *)data;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tra->field = cpu_to_le32(field);\n\n\treturn mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t     MCU_EXT_CMD(STA_REC_UPDATE), true);\n}\n\nint mt7915_mcu_add_smps(struct mt7915_dev *dev, struct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_sta *sta)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct mt7915_sta *msta = (struct mt7915_sta *)sta->drv_priv;\n\tstruct wtbl_req_hdr *wtbl_hdr;\n\tstruct tlv *sta_wtbl;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->mt76,\n\t\t\t\t\t    &msta->wcid);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tsta_wtbl = mt76_connac_mcu_add_tlv(skb, STA_REC_WTBL,\n\t\t\t\t\t   sizeof(struct tlv));\n\twtbl_hdr = mt76_connac_mcu_alloc_wtbl_req(&dev->mt76, &msta->wcid,\n\t\t\t\t\t\t  WTBL_SET, sta_wtbl, &skb);\n\tif (IS_ERR(wtbl_hdr))\n\t\treturn PTR_ERR(wtbl_hdr);\n\n\tmt76_connac_mcu_wtbl_smps_tlv(skb, sta, sta_wtbl, wtbl_hdr);\n\n\tret = mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t    MCU_EXT_CMD(STA_REC_UPDATE), true);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mt7915_mcu_set_fixed_rate_ctrl(dev, vif, sta, NULL,\n\t\t\t\t\t      RATE_PARAM_MMPS_UPDATE);\n}\n\nstatic int\nmt7915_mcu_set_spe_idx(struct mt7915_dev *dev, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_sta *sta)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct mt76_phy *mphy = mvif->phy->mt76;\n\tu8 spe_idx = mt76_connac_spe_idx(mphy->antenna_mask);\n\n\treturn mt7915_mcu_set_fixed_rate_ctrl(dev, vif, sta, &spe_idx,\n\t\t\t\t\t      RATE_PARAM_SPE_UPDATE);\n}\n\nstatic int\nmt7915_mcu_add_rate_ctrl_fixed(struct mt7915_dev *dev,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_sta *sta)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct cfg80211_chan_def *chandef = &mvif->phy->mt76->chandef;\n\tstruct cfg80211_bitrate_mask *mask = &mvif->bitrate_mask;\n\tenum nl80211_band band = chandef->chan->band;\n\tstruct sta_phy phy = {};\n\tint ret, nrates = 0;\n\n#define __sta_phy_bitrate_mask_check(_mcs, _gi, _ht, _he)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\\\n\t\tu8 i, gi = mask->control[band]._gi;\t\t\t\t\\\n\t\tgi = (_he) ? gi : gi == NL80211_TXRATE_FORCE_SGI;\t\t\\\n\t\tfor (i = 0; i <= sta->deflink.bandwidth; i++) {\t\t\t\\\n\t\t\tphy.sgi |= gi << (i << (_he));\t\t\t\t\\\n\t\t\tphy.he_ltf |= mask->control[band].he_ltf << (i << (_he));\\\n\t\t}\t\t\t\t\t\t\t\t\\\n\t\tfor (i = 0; i < ARRAY_SIZE(mask->control[band]._mcs); i++) {\t\\\n\t\t\tif (!mask->control[band]._mcs[i])\t\t\t\\\n\t\t\t\tcontinue;\t\t\t\t\t\\\n\t\t\tnrates += hweight16(mask->control[band]._mcs[i]);\t\\\n\t\t\tphy.mcs = ffs(mask->control[band]._mcs[i]) - 1;\t\t\\\n\t\t\tif (_ht)\t\t\t\t\t\t\\\n\t\t\t\tphy.mcs += 8 * i;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\n\tif (sta->deflink.he_cap.has_he) {\n\t\t__sta_phy_bitrate_mask_check(he_mcs, he_gi, 0, 1);\n\t} else if (sta->deflink.vht_cap.vht_supported) {\n\t\t__sta_phy_bitrate_mask_check(vht_mcs, gi, 0, 0);\n\t} else if (sta->deflink.ht_cap.ht_supported) {\n\t\t__sta_phy_bitrate_mask_check(ht_mcs, gi, 1, 0);\n\t} else {\n\t\tnrates = hweight32(mask->control[band].legacy);\n\t\tphy.mcs = ffs(mask->control[band].legacy) - 1;\n\t}\n#undef __sta_phy_bitrate_mask_check\n\n\t \n\tif (mask->control[band].gi == NL80211_TXRATE_DEFAULT_GI &&\n\t    mask->control[band].he_gi == GENMASK(7, 0) &&\n\t    mask->control[band].he_ltf == GENMASK(7, 0) &&\n\t    nrates != 1)\n\t\treturn 0;\n\n\t \n\tif (nrates == 1) {\n\t\tret = mt7915_mcu_set_fixed_rate_ctrl(dev, vif, sta, &phy,\n\t\t\t\t\t\t     RATE_PARAM_FIXED_MCS);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (mask->control[band].gi != NL80211_TXRATE_DEFAULT_GI ||\n\t    mask->control[band].he_gi != GENMASK(7, 0)) {\n\t\tstruct mt7915_sta *msta = (struct mt7915_sta *)sta->drv_priv;\n\t\tu32 addr;\n\n\t\t \n\t\taddr = mt7915_mac_wtbl_lmac_addr(dev, msta->wcid.idx, 7);\n\t\tif (sta->deflink.he_cap.has_he)\n\t\t\tmt76_rmw_field(dev, addr, GENMASK(31, 24), phy.sgi);\n\t\telse\n\t\t\tmt76_rmw_field(dev, addr, GENMASK(15, 12), phy.sgi);\n\n\t\tret = mt7915_mcu_set_fixed_rate_ctrl(dev, vif, sta, &phy,\n\t\t\t\t\t\t     RATE_PARAM_FIXED_GI);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (mask->control[band].he_ltf != GENMASK(7, 0)) {\n\t\tret = mt7915_mcu_set_fixed_rate_ctrl(dev, vif, sta, &phy,\n\t\t\t\t\t\t     RATE_PARAM_FIXED_HE_LTF);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn mt7915_mcu_set_spe_idx(dev, vif, sta);\n}\n\nstatic void\nmt7915_mcu_sta_rate_ctrl_tlv(struct sk_buff *skb, struct mt7915_dev *dev,\n\t\t\t     struct ieee80211_vif *vif, struct ieee80211_sta *sta)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct mt76_phy *mphy = mvif->phy->mt76;\n\tstruct cfg80211_chan_def *chandef = &mphy->chandef;\n\tstruct cfg80211_bitrate_mask *mask = &mvif->bitrate_mask;\n\tenum nl80211_band band = chandef->chan->band;\n\tstruct sta_rec_ra *ra;\n\tstruct tlv *tlv;\n\tu32 supp_rate = sta->deflink.supp_rates[band];\n\tu32 cap = sta->wme ? STA_CAP_WMM : 0;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_RA, sizeof(*ra));\n\tra = (struct sta_rec_ra *)tlv;\n\n\tra->valid = true;\n\tra->auto_rate = true;\n\tra->phy_mode = mt76_connac_get_phy_mode(mphy, vif, band, sta);\n\tra->channel = chandef->chan->hw_value;\n\tra->bw = sta->deflink.bandwidth;\n\tra->phy.bw = sta->deflink.bandwidth;\n\tra->mmps_mode = mt7915_mcu_get_mmps_mode(sta->deflink.smps_mode);\n\n\tif (supp_rate) {\n\t\tsupp_rate &= mask->control[band].legacy;\n\t\tra->rate_len = hweight32(supp_rate);\n\n\t\tif (band == NL80211_BAND_2GHZ) {\n\t\t\tra->supp_mode = MODE_CCK;\n\t\t\tra->supp_cck_rate = supp_rate & GENMASK(3, 0);\n\n\t\t\tif (ra->rate_len > 4) {\n\t\t\t\tra->supp_mode |= MODE_OFDM;\n\t\t\t\tra->supp_ofdm_rate = supp_rate >> 4;\n\t\t\t}\n\t\t} else {\n\t\t\tra->supp_mode = MODE_OFDM;\n\t\t\tra->supp_ofdm_rate = supp_rate;\n\t\t}\n\t}\n\n\tif (sta->deflink.ht_cap.ht_supported) {\n\t\tra->supp_mode |= MODE_HT;\n\t\tra->af = sta->deflink.ht_cap.ampdu_factor;\n\t\tra->ht_gf = !!(sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_GRN_FLD);\n\n\t\tcap |= STA_CAP_HT;\n\t\tif (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_20)\n\t\t\tcap |= STA_CAP_SGI_20;\n\t\tif (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_40)\n\t\t\tcap |= STA_CAP_SGI_40;\n\t\tif (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_TX_STBC)\n\t\t\tcap |= STA_CAP_TX_STBC;\n\t\tif (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_RX_STBC)\n\t\t\tcap |= STA_CAP_RX_STBC;\n\t\tif (mvif->cap.ht_ldpc &&\n\t\t    (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_LDPC_CODING))\n\t\t\tcap |= STA_CAP_LDPC;\n\n\t\tmt7915_mcu_set_sta_ht_mcs(sta, ra->ht_mcs,\n\t\t\t\t\t  mask->control[band].ht_mcs);\n\t\tra->supp_ht_mcs = *(__le32 *)ra->ht_mcs;\n\t}\n\n\tif (sta->deflink.vht_cap.vht_supported) {\n\t\tu8 af;\n\n\t\tra->supp_mode |= MODE_VHT;\n\t\taf = FIELD_GET(IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK,\n\t\t\t       sta->deflink.vht_cap.cap);\n\t\tra->af = max_t(u8, ra->af, af);\n\n\t\tcap |= STA_CAP_VHT;\n\t\tif (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_SHORT_GI_80)\n\t\t\tcap |= STA_CAP_VHT_SGI_80;\n\t\tif (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_SHORT_GI_160)\n\t\t\tcap |= STA_CAP_VHT_SGI_160;\n\t\tif (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_TXSTBC)\n\t\t\tcap |= STA_CAP_VHT_TX_STBC;\n\t\tif (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_RXSTBC_1)\n\t\t\tcap |= STA_CAP_VHT_RX_STBC;\n\t\tif (mvif->cap.vht_ldpc &&\n\t\t    (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_RXLDPC))\n\t\t\tcap |= STA_CAP_VHT_LDPC;\n\n\t\tmt7915_mcu_set_sta_vht_mcs(sta, ra->supp_vht_mcs,\n\t\t\t\t\t   mask->control[band].vht_mcs);\n\t}\n\n\tif (sta->deflink.he_cap.has_he) {\n\t\tra->supp_mode |= MODE_HE;\n\t\tcap |= STA_CAP_HE;\n\n\t\tif (sta->deflink.he_6ghz_capa.capa)\n\t\t\tra->af = le16_get_bits(sta->deflink.he_6ghz_capa.capa,\n\t\t\t\t\t       IEEE80211_HE_6GHZ_CAP_MAX_AMPDU_LEN_EXP);\n\t}\n\n\tra->sta_cap = cpu_to_le32(cap);\n}\n\nint mt7915_mcu_add_rate_ctrl(struct mt7915_dev *dev, struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_sta *sta, bool changed)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct mt7915_sta *msta = (struct mt7915_sta *)sta->drv_priv;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->mt76,\n\t\t\t\t\t    &msta->wcid);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\t \n\tif (changed)\n\t\tmt7915_mcu_sta_he_tlv(skb, sta, vif);\n\n\t \n\tmt7915_mcu_sta_rate_ctrl_tlv(skb, dev, vif, sta);\n\n\tret = mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t    MCU_EXT_CMD(STA_REC_UPDATE), true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn mt7915_mcu_add_rate_ctrl_fixed(dev, vif, sta);\n}\n\nstatic int\nmt7915_mcu_add_group(struct mt7915_dev *dev, struct ieee80211_vif *vif,\n\t\t     struct ieee80211_sta *sta)\n{\n#define MT_STA_BSS_GROUP\t\t1\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct mt7915_sta *msta;\n\tstruct {\n\t\t__le32 action;\n\t\tu8 wlan_idx_lo;\n\t\tu8 status;\n\t\tu8 wlan_idx_hi;\n\t\tu8 rsv0[5];\n\t\t__le32 val;\n\t\tu8 rsv1[8];\n\t} __packed req = {\n\t\t.action = cpu_to_le32(MT_STA_BSS_GROUP),\n\t\t.val = cpu_to_le32(mvif->mt76.idx % 16),\n\t};\n\n\tmsta = sta ? (struct mt7915_sta *)sta->drv_priv : &mvif->sta;\n\treq.wlan_idx_lo = to_wcid_lo(msta->wcid.idx);\n\treq.wlan_idx_hi = to_wcid_hi(msta->wcid.idx);\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(SET_DRR_CTRL), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nint mt7915_mcu_add_sta(struct mt7915_dev *dev, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_sta *sta, bool enable)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct mt7915_sta *msta;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tmsta = sta ? (struct mt7915_sta *)sta->drv_priv : &mvif->sta;\n\n\tskb = mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->mt76,\n\t\t\t\t\t    &msta->wcid);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\t \n\tmt76_connac_mcu_sta_basic_tlv(&dev->mt76, skb, vif, sta, enable,\n\t\t\t\t      !rcu_access_pointer(dev->mt76.wcid[msta->wcid.idx]));\n\tif (!enable)\n\t\tgoto out;\n\n\t \n\tif (sta) {\n\t\t \n\t\tmt7915_mcu_sta_bfer_tlv(dev, skb, vif, sta);\n\t\t \n\t\tmt7915_mcu_sta_ht_tlv(skb, sta);\n\t\t \n\t\tmt7915_mcu_sta_vht_tlv(skb, sta);\n\t\t \n\t\tmt76_connac_mcu_sta_uapsd(skb, vif, sta);\n\t}\n\n\tret = mt7915_mcu_sta_wtbl_tlv(dev, skb, vif, sta);\n\tif (ret) {\n\t\tdev_kfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tif (sta) {\n\t\t \n\t\tmt7915_mcu_sta_amsdu_tlv(dev, skb, vif, sta);\n\t\t \n\t\tmt7915_mcu_sta_he_tlv(skb, sta, vif);\n\t\t \n\t\tmt7915_mcu_sta_muru_tlv(dev, skb, sta, vif);\n\t\t \n\t\tmt7915_mcu_sta_bfee_tlv(dev, skb, vif, sta);\n\t}\n\n\tret = mt7915_mcu_add_group(dev, vif, sta);\n\tif (ret) {\n\t\tdev_kfree_skb(skb);\n\t\treturn ret;\n\t}\nout:\n\tret = mt76_connac_mcu_sta_wed_update(&dev->mt76, skb);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t     MCU_EXT_CMD(STA_REC_UPDATE), true);\n}\n\nint mt7915_mcu_wed_enable_rx_stats(struct mt7915_dev *dev)\n{\n#ifdef CONFIG_NET_MEDIATEK_SOC_WED\n\tstruct mtk_wed_device *wed = &dev->mt76.mmio.wed;\n\tstruct {\n\t\t__le32 args[2];\n\t} req = {\n\t\t.args[0] = cpu_to_le32(1),\n\t\t.args[1] = cpu_to_le32(6),\n\t};\n\n\treturn mtk_wed_device_update_msg(wed, MTK_WED_WO_CMD_RXCNT_CTRL,\n\t\t\t\t\t &req, sizeof(req));\n#else\n\treturn 0;\n#endif\n}\n\nint mt7915_mcu_add_dev_info(struct mt7915_phy *phy,\n\t\t\t    struct ieee80211_vif *vif, bool enable)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct {\n\t\tstruct req_hdr {\n\t\t\tu8 omac_idx;\n\t\t\tu8 band_idx;\n\t\t\t__le16 tlv_num;\n\t\t\tu8 is_tlv_append;\n\t\t\tu8 rsv[3];\n\t\t} __packed hdr;\n\t\tstruct req_tlv {\n\t\t\t__le16 tag;\n\t\t\t__le16 len;\n\t\t\tu8 active;\n\t\t\tu8 band_idx;\n\t\t\tu8 omac_addr[ETH_ALEN];\n\t\t} __packed tlv;\n\t} data = {\n\t\t.hdr = {\n\t\t\t.omac_idx = mvif->mt76.omac_idx,\n\t\t\t.band_idx = mvif->mt76.band_idx,\n\t\t\t.tlv_num = cpu_to_le16(1),\n\t\t\t.is_tlv_append = 1,\n\t\t},\n\t\t.tlv = {\n\t\t\t.tag = cpu_to_le16(DEV_INFO_ACTIVE),\n\t\t\t.len = cpu_to_le16(sizeof(struct req_tlv)),\n\t\t\t.active = enable,\n\t\t\t.band_idx = mvif->mt76.band_idx,\n\t\t},\n\t};\n\n\tif (mvif->mt76.omac_idx >= REPEATER_BSSID_START)\n\t\treturn mt7915_mcu_muar_config(phy, vif, false, enable);\n\n\tmemcpy(data.tlv.omac_addr, vif->addr, ETH_ALEN);\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(DEV_INFO_UPDATE),\n\t\t\t\t &data, sizeof(data), true);\n}\n\nstatic void\nmt7915_mcu_beacon_cntdwn(struct ieee80211_vif *vif, struct sk_buff *rskb,\n\t\t\t struct sk_buff *skb, struct bss_info_bcn *bcn,\n\t\t\t struct ieee80211_mutable_offsets *offs)\n{\n\tstruct bss_info_bcn_cntdwn *info;\n\tstruct tlv *tlv;\n\tint sub_tag;\n\n\tif (!offs->cntdwn_counter_offs[0])\n\t\treturn;\n\n\tsub_tag = vif->bss_conf.csa_active ? BSS_INFO_BCN_CSA : BSS_INFO_BCN_BCC;\n\ttlv = mt7915_mcu_add_nested_subtlv(rskb, sub_tag, sizeof(*info),\n\t\t\t\t\t   &bcn->sub_ntlv, &bcn->len);\n\tinfo = (struct bss_info_bcn_cntdwn *)tlv;\n\tinfo->cnt = skb->data[offs->cntdwn_counter_offs[0]];\n}\n\nstatic void\nmt7915_mcu_beacon_mbss(struct sk_buff *rskb, struct sk_buff *skb,\n\t\t       struct ieee80211_vif *vif, struct bss_info_bcn *bcn,\n\t\t       struct ieee80211_mutable_offsets *offs)\n{\n\tstruct bss_info_bcn_mbss *mbss;\n\tconst struct element *elem;\n\tstruct tlv *tlv;\n\n\tif (!vif->bss_conf.bssid_indicator)\n\t\treturn;\n\n\ttlv = mt7915_mcu_add_nested_subtlv(rskb, BSS_INFO_BCN_MBSSID,\n\t\t\t\t\t   sizeof(*mbss), &bcn->sub_ntlv,\n\t\t\t\t\t   &bcn->len);\n\n\tmbss = (struct bss_info_bcn_mbss *)tlv;\n\tmbss->offset[0] = cpu_to_le16(offs->tim_offset);\n\tmbss->bitmap = cpu_to_le32(1);\n\n\tfor_each_element_id(elem, WLAN_EID_MULTIPLE_BSSID,\n\t\t\t    &skb->data[offs->mbssid_off],\n\t\t\t    skb->len - offs->mbssid_off) {\n\t\tconst struct element *sub_elem;\n\n\t\tif (elem->datalen < 2)\n\t\t\tcontinue;\n\n\t\tfor_each_element(sub_elem, elem->data + 1, elem->datalen - 1) {\n\t\t\tconst struct ieee80211_bssid_index *idx;\n\t\t\tconst u8 *idx_ie;\n\n\t\t\tif (sub_elem->id || sub_elem->datalen < 4)\n\t\t\t\tcontinue;  \n\n\t\t\t \n\t\t\tidx_ie = cfg80211_find_ie(WLAN_EID_MULTI_BSSID_IDX,\n\t\t\t\t\t\t  sub_elem->data,\n\t\t\t\t\t\t  sub_elem->datalen);\n\t\t\tif (!idx_ie || idx_ie[1] < sizeof(*idx))\n\t\t\t\tcontinue;\n\n\t\t\tidx = (void *)(idx_ie + 2);\n\t\t\tif (!idx->bssid_index || idx->bssid_index > 31)\n\t\t\t\tcontinue;\n\n\t\t\tmbss->offset[idx->bssid_index] =\n\t\t\t\tcpu_to_le16(idx_ie - skb->data);\n\t\t\tmbss->bitmap |= cpu_to_le32(BIT(idx->bssid_index));\n\t\t}\n\t}\n}\n\nstatic void\nmt7915_mcu_beacon_cont(struct mt7915_dev *dev, struct ieee80211_vif *vif,\n\t\t       struct sk_buff *rskb, struct sk_buff *skb,\n\t\t       struct bss_info_bcn *bcn,\n\t\t       struct ieee80211_mutable_offsets *offs)\n{\n\tstruct mt76_wcid *wcid = &dev->mt76.global_wcid;\n\tstruct bss_info_bcn_cont *cont;\n\tstruct tlv *tlv;\n\tu8 *buf;\n\tint len = sizeof(*cont) + MT_TXD_SIZE + skb->len;\n\n\tlen = (len & 0x3) ? ((len | 0x3) + 1) : len;\n\ttlv = mt7915_mcu_add_nested_subtlv(rskb, BSS_INFO_BCN_CONTENT,\n\t\t\t\t\t   len, &bcn->sub_ntlv, &bcn->len);\n\n\tcont = (struct bss_info_bcn_cont *)tlv;\n\tcont->pkt_len = cpu_to_le16(MT_TXD_SIZE + skb->len);\n\tcont->tim_ofs = cpu_to_le16(offs->tim_offset);\n\n\tif (offs->cntdwn_counter_offs[0]) {\n\t\tu16 offset = offs->cntdwn_counter_offs[0];\n\n\t\tif (vif->bss_conf.csa_active)\n\t\t\tcont->csa_ofs = cpu_to_le16(offset - 4);\n\t\tif (vif->bss_conf.color_change_active)\n\t\t\tcont->bcc_ofs = cpu_to_le16(offset - 3);\n\t}\n\n\tbuf = (u8 *)tlv + sizeof(*cont);\n\tmt7915_mac_write_txwi(&dev->mt76, (__le32 *)buf, skb, wcid, 0, NULL,\n\t\t\t      0, BSS_CHANGED_BEACON);\n\tmemcpy(buf + MT_TXD_SIZE, skb->data, skb->len);\n}\n\nint\nmt7915_mcu_add_inband_discov(struct mt7915_dev *dev, struct ieee80211_vif *vif,\n\t\t\t     u32 changed)\n{\n#define OFFLOAD_TX_MODE_SU\tBIT(0)\n#define OFFLOAD_TX_MODE_MU\tBIT(1)\n\tstruct ieee80211_hw *hw = mt76_hw(dev);\n\tstruct mt7915_phy *phy = mt7915_hw_phy(hw);\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct cfg80211_chan_def *chandef = &mvif->phy->mt76->chandef;\n\tenum nl80211_band band = chandef->chan->band;\n\tstruct mt76_wcid *wcid = &dev->mt76.global_wcid;\n\tstruct bss_info_bcn *bcn;\n\tstruct bss_info_inband_discovery *discov;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *rskb, *skb = NULL;\n\tstruct tlv *tlv, *sub_tlv;\n\tbool ext_phy = phy != &dev->phy;\n\tu8 *buf, interval;\n\tint len;\n\n\tif (vif->bss_conf.nontransmitted)\n\t\treturn 0;\n\n\trskb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->mt76, NULL,\n\t\t\t\t\t       MT7915_MAX_BSS_OFFLOAD_SIZE);\n\tif (IS_ERR(rskb))\n\t\treturn PTR_ERR(rskb);\n\n\ttlv = mt76_connac_mcu_add_tlv(rskb, BSS_INFO_OFFLOAD, sizeof(*bcn));\n\tbcn = (struct bss_info_bcn *)tlv;\n\tbcn->enable = true;\n\n\tif (changed & BSS_CHANGED_FILS_DISCOVERY &&\n\t    vif->bss_conf.fils_discovery.max_interval) {\n\t\tinterval = vif->bss_conf.fils_discovery.max_interval;\n\t\tskb = ieee80211_get_fils_discovery_tmpl(hw, vif);\n\t} else if (changed & BSS_CHANGED_UNSOL_BCAST_PROBE_RESP &&\n\t\t   vif->bss_conf.unsol_bcast_probe_resp_interval) {\n\t\tinterval = vif->bss_conf.unsol_bcast_probe_resp_interval;\n\t\tskb = ieee80211_get_unsol_bcast_probe_resp_tmpl(hw, vif);\n\t}\n\n\tif (!skb) {\n\t\tdev_kfree_skb(rskb);\n\t\treturn -EINVAL;\n\t}\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tinfo->control.vif = vif;\n\tinfo->band = band;\n\tinfo->hw_queue |= FIELD_PREP(MT_TX_HW_QUEUE_PHY, ext_phy);\n\n\tlen = sizeof(*discov) + MT_TXD_SIZE + skb->len;\n\tlen = (len & 0x3) ? ((len | 0x3) + 1) : len;\n\n\tif (skb->len > MT7915_MAX_BEACON_SIZE) {\n\t\tdev_err(dev->mt76.dev, \"inband discovery size limit exceed\\n\");\n\t\tdev_kfree_skb(rskb);\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tsub_tlv = mt7915_mcu_add_nested_subtlv(rskb, BSS_INFO_BCN_DISCOV,\n\t\t\t\t\t       len, &bcn->sub_ntlv, &bcn->len);\n\tdiscov = (struct bss_info_inband_discovery *)sub_tlv;\n\tdiscov->tx_mode = OFFLOAD_TX_MODE_SU;\n\t \n\tdiscov->tx_type = !!(changed & BSS_CHANGED_FILS_DISCOVERY);\n\tdiscov->tx_interval = interval;\n\tdiscov->prob_rsp_len = cpu_to_le16(MT_TXD_SIZE + skb->len);\n\tdiscov->enable = true;\n\n\tbuf = (u8 *)sub_tlv + sizeof(*discov);\n\n\tmt7915_mac_write_txwi(&dev->mt76, (__le32 *)buf, skb, wcid, 0, NULL,\n\t\t\t      0, changed);\n\tmemcpy(buf + MT_TXD_SIZE, skb->data, skb->len);\n\n\tdev_kfree_skb(skb);\n\n\treturn mt76_mcu_skb_send_msg(&phy->dev->mt76, rskb,\n\t\t\t\t     MCU_EXT_CMD(BSS_INFO_UPDATE), true);\n}\n\nint mt7915_mcu_add_beacon(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t  int en, u32 changed)\n{\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tstruct mt7915_phy *phy = mt7915_hw_phy(hw);\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct ieee80211_mutable_offsets offs;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *skb, *rskb;\n\tstruct tlv *tlv;\n\tstruct bss_info_bcn *bcn;\n\tint len = MT7915_MAX_BSS_OFFLOAD_SIZE;\n\tbool ext_phy = phy != &dev->phy;\n\n\tif (vif->bss_conf.nontransmitted)\n\t\treturn 0;\n\n\trskb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->mt76,\n\t\t\t\t\t       NULL, len);\n\tif (IS_ERR(rskb))\n\t\treturn PTR_ERR(rskb);\n\n\ttlv = mt76_connac_mcu_add_tlv(rskb, BSS_INFO_OFFLOAD, sizeof(*bcn));\n\tbcn = (struct bss_info_bcn *)tlv;\n\tbcn->enable = en;\n\n\tif (!en)\n\t\tgoto out;\n\n\tskb = ieee80211_beacon_get_template(hw, vif, &offs, 0);\n\tif (!skb) {\n\t\tdev_kfree_skb(rskb);\n\t\treturn -EINVAL;\n\t}\n\n\tif (skb->len > MT7915_MAX_BEACON_SIZE) {\n\t\tdev_err(dev->mt76.dev, \"Bcn size limit exceed\\n\");\n\t\tdev_kfree_skb(rskb);\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tinfo->hw_queue = FIELD_PREP(MT_TX_HW_QUEUE_PHY, ext_phy);\n\n\tmt7915_mcu_beacon_cntdwn(vif, rskb, skb, bcn, &offs);\n\tmt7915_mcu_beacon_mbss(rskb, skb, vif, bcn, &offs);\n\tmt7915_mcu_beacon_cont(dev, vif, rskb, skb, bcn, &offs);\n\tdev_kfree_skb(skb);\n\nout:\n\treturn mt76_mcu_skb_send_msg(&phy->dev->mt76, rskb,\n\t\t\t\t     MCU_EXT_CMD(BSS_INFO_UPDATE), true);\n}\n\nstatic int mt7915_driver_own(struct mt7915_dev *dev, u8 band)\n{\n\tmt76_wr(dev, MT_TOP_LPCR_HOST_BAND(band), MT_TOP_LPCR_HOST_DRV_OWN);\n\tif (!mt76_poll_msec(dev, MT_TOP_LPCR_HOST_BAND(band),\n\t\t\t    MT_TOP_LPCR_HOST_FW_OWN_STAT, 0, 500)) {\n\t\tdev_err(dev->mt76.dev, \"Timeout for driver own\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tmt76_wr(dev, MT_TOP_LPCR_HOST_BAND_IRQ_STAT(band),\n\t\tMT_TOP_LPCR_HOST_BAND_STAT);\n\n\treturn 0;\n}\n\nstatic int\nmt7915_firmware_state(struct mt7915_dev *dev, bool wa)\n{\n\tu32 state = FIELD_PREP(MT_TOP_MISC_FW_STATE,\n\t\t\t       wa ? FW_STATE_RDY : FW_STATE_FW_DOWNLOAD);\n\n\tif (!mt76_poll_msec(dev, MT_TOP_MISC, MT_TOP_MISC_FW_STATE,\n\t\t\t    state, 1000)) {\n\t\tdev_err(dev->mt76.dev, \"Timeout for initializing firmware\\n\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int mt7915_load_firmware(struct mt7915_dev *dev)\n{\n\tint ret;\n\n\t \n\tif (mt7915_firmware_state(dev, false)) {\n\t\t \n\t\tmt76_connac_mcu_restart(&dev->mt76);\n\t\tret = mt7915_firmware_state(dev, false);\n\t\tif (ret) {\n\t\t\tdev_err(dev->mt76.dev,\n\t\t\t\t\"Firmware is not ready for download\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = mt76_connac2_load_patch(&dev->mt76, fw_name_var(dev, ROM_PATCH));\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt76_connac2_load_ram(&dev->mt76, fw_name_var(dev, FIRMWARE_WM),\n\t\t\t\t    fw_name(dev, FIRMWARE_WA));\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7915_firmware_state(dev, true);\n\tif (ret)\n\t\treturn ret;\n\n\tmt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[MT_MCUQ_FWDL], false);\n\n\tdev_dbg(dev->mt76.dev, \"Firmware init done\\n\");\n\n\treturn 0;\n}\n\nint mt7915_mcu_fw_log_2_host(struct mt7915_dev *dev, u8 type, u8 ctrl)\n{\n\tstruct {\n\t\tu8 ctrl_val;\n\t\tu8 pad[3];\n\t} data = {\n\t\t.ctrl_val = ctrl\n\t};\n\n\tif (type == MCU_FW_LOG_WA)\n\t\treturn mt76_mcu_send_msg(&dev->mt76, MCU_WA_EXT_CMD(FW_LOG_2_HOST),\n\t\t\t\t\t &data, sizeof(data), true);\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(FW_LOG_2_HOST), &data,\n\t\t\t\t sizeof(data), true);\n}\n\nint mt7915_mcu_fw_dbg_ctrl(struct mt7915_dev *dev, u32 module, u8 level)\n{\n\tstruct {\n\t\tu8 ver;\n\t\tu8 pad;\n\t\t__le16 len;\n\t\tu8 level;\n\t\tu8 rsv[3];\n\t\t__le32 module_idx;\n\t} data = {\n\t\t.module_idx = cpu_to_le32(module),\n\t\t.level = level,\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(FW_DBG_CTRL), &data,\n\t\t\t\t sizeof(data), false);\n}\n\nint mt7915_mcu_muru_debug_set(struct mt7915_dev *dev, bool enabled)\n{\n\tstruct {\n\t\t__le32 cmd;\n\t\tu8 enable;\n\t} data = {\n\t\t.cmd = cpu_to_le32(MURU_SET_TXC_TX_STATS_EN),\n\t\t.enable = enabled,\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(MURU_CTRL), &data,\n\t\t\t\tsizeof(data), false);\n}\n\nint mt7915_mcu_muru_debug_get(struct mt7915_phy *phy)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct sk_buff *skb;\n\tstruct mt7915_mcu_muru_stats *mu_stats;\n\tint ret;\n\n\tstruct {\n\t\t__le32 cmd;\n\t\tu8 band_idx;\n\t} req = {\n\t\t.cmd = cpu_to_le32(MURU_GET_TXC_TX_STATS),\n\t\t.band_idx = phy->mt76->band_idx,\n\t};\n\n\tret = mt76_mcu_send_and_get_msg(&dev->mt76, MCU_EXT_CMD(MURU_CTRL),\n\t\t\t\t\t&req, sizeof(req), true, &skb);\n\tif (ret)\n\t\treturn ret;\n\n\tmu_stats = (struct mt7915_mcu_muru_stats *)(skb->data);\n\n\t \n#define __dl_u32(s)\t phy->mib.dl_##s += le32_to_cpu(mu_stats->dl.s)\n#define __ul_u32(s)\t phy->mib.ul_##s += le32_to_cpu(mu_stats->ul.s)\n\t__dl_u32(cck_cnt);\n\t__dl_u32(ofdm_cnt);\n\t__dl_u32(htmix_cnt);\n\t__dl_u32(htgf_cnt);\n\t__dl_u32(vht_su_cnt);\n\t__dl_u32(vht_2mu_cnt);\n\t__dl_u32(vht_3mu_cnt);\n\t__dl_u32(vht_4mu_cnt);\n\t__dl_u32(he_su_cnt);\n\t__dl_u32(he_2ru_cnt);\n\t__dl_u32(he_2mu_cnt);\n\t__dl_u32(he_3ru_cnt);\n\t__dl_u32(he_3mu_cnt);\n\t__dl_u32(he_4ru_cnt);\n\t__dl_u32(he_4mu_cnt);\n\t__dl_u32(he_5to8ru_cnt);\n\t__dl_u32(he_9to16ru_cnt);\n\t__dl_u32(he_gtr16ru_cnt);\n\n\t__ul_u32(hetrig_su_cnt);\n\t__ul_u32(hetrig_2ru_cnt);\n\t__ul_u32(hetrig_3ru_cnt);\n\t__ul_u32(hetrig_4ru_cnt);\n\t__ul_u32(hetrig_5to8ru_cnt);\n\t__ul_u32(hetrig_9to16ru_cnt);\n\t__ul_u32(hetrig_gtr16ru_cnt);\n\t__ul_u32(hetrig_2mu_cnt);\n\t__ul_u32(hetrig_3mu_cnt);\n\t__ul_u32(hetrig_4mu_cnt);\n#undef __dl_u32\n#undef __ul_u32\n\n\tdev_kfree_skb(skb);\n\n\treturn 0;\n}\n\nstatic int mt7915_mcu_set_mwds(struct mt7915_dev *dev, bool enabled)\n{\n\tstruct {\n\t\tu8 enable;\n\t\tu8 _rsv[3];\n\t} __packed req = {\n\t\t.enable = enabled\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_WA_EXT_CMD(MWDS_SUPPORT), &req,\n\t\t\t\t sizeof(req), false);\n}\n\nint mt7915_mcu_set_muru_ctrl(struct mt7915_dev *dev, u32 cmd, u32 val)\n{\n\tstruct {\n\t\t__le32 cmd;\n\t\tu8 val[4];\n\t} __packed req = {\n\t\t.cmd = cpu_to_le32(cmd),\n\t};\n\n\tput_unaligned_le32(val, req.val);\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(MURU_CTRL), &req,\n\t\t\t\t sizeof(req), false);\n}\n\nstatic int\nmt7915_mcu_init_rx_airtime(struct mt7915_dev *dev)\n{\n#define RX_AIRTIME_FEATURE_CTRL\t\t1\n#define RX_AIRTIME_BITWISE_CTRL\t\t2\n#define RX_AIRTIME_CLEAR_EN\t1\n\tstruct {\n\t\t__le16 field;\n\t\t__le16 sub_field;\n\t\t__le32 set_status;\n\t\t__le32 get_status;\n\t\tu8 _rsv[12];\n\n\t\tbool airtime_en;\n\t\tbool mibtime_en;\n\t\tbool earlyend_en;\n\t\tu8 _rsv1[9];\n\n\t\tbool airtime_clear;\n\t\tbool mibtime_clear;\n\t\tu8 _rsv2[98];\n\t} __packed req = {\n\t\t.field = cpu_to_le16(RX_AIRTIME_BITWISE_CTRL),\n\t\t.sub_field = cpu_to_le16(RX_AIRTIME_CLEAR_EN),\n\t\t.airtime_clear = true,\n\t};\n\tint ret;\n\n\tret = mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(RX_AIRTIME_CTRL), &req,\n\t\t\t\tsizeof(req), true);\n\tif (ret)\n\t\treturn ret;\n\n\treq.field = cpu_to_le16(RX_AIRTIME_FEATURE_CTRL);\n\treq.sub_field = cpu_to_le16(RX_AIRTIME_CLEAR_EN);\n\treq.airtime_en = true;\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(RX_AIRTIME_CTRL), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nstatic int mt7915_red_set_watermark(struct mt7915_dev *dev)\n{\n#define RED_GLOBAL_TOKEN_WATERMARK 2\n\tstruct {\n\t\t__le32 args[3];\n\t\tu8 cmd;\n\t\tu8 version;\n\t\tu8 __rsv1[4];\n\t\t__le16 len;\n\t\t__le16 high_mark;\n\t\t__le16 low_mark;\n\t\tu8 __rsv2[12];\n\t} __packed req = {\n\t\t.args[0] = cpu_to_le32(MCU_WA_PARAM_RED_SETTING),\n\t\t.cmd = RED_GLOBAL_TOKEN_WATERMARK,\n\t\t.len = cpu_to_le16(sizeof(req) - sizeof(req.args)),\n\t\t.high_mark = cpu_to_le16(MT7915_HW_TOKEN_SIZE - 256),\n\t\t.low_mark = cpu_to_le16(MT7915_HW_TOKEN_SIZE - 256 - 1536),\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_WA_PARAM_CMD(SET), &req,\n\t\t\t\t sizeof(req), false);\n}\n\nstatic int mt7915_mcu_set_red(struct mt7915_dev *dev, bool enabled)\n{\n#define RED_DISABLE\t\t0\n#define RED_BY_WA_ENABLE\t2\n\tint ret;\n\tu32 red_type = enabled ? RED_BY_WA_ENABLE : RED_DISABLE;\n\t__le32 req = cpu_to_le32(red_type);\n\n\tif (enabled) {\n\t\tret = mt7915_red_set_watermark(dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(RED_ENABLE), &req,\n\t\t\t\tsizeof(req), false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn mt7915_mcu_wa_cmd(dev, MCU_WA_PARAM_CMD(SET),\n\t\t\t\t MCU_WA_PARAM_RED, enabled, 0);\n}\n\nint mt7915_mcu_init_firmware(struct mt7915_dev *dev)\n{\n\tint ret;\n\n\t \n\tmt76_wr(dev, MT_SWDEF_MODE, MT_SWDEF_NORMAL_MODE);\n\n\tret = mt7915_driver_own(dev, 0);\n\tif (ret)\n\t\treturn ret;\n\t \n\tif (dev->hif2) {\n\t\tret = mt7915_driver_own(dev, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = mt7915_load_firmware(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tset_bit(MT76_STATE_MCU_RUNNING, &dev->mphy.state);\n\tret = mt7915_mcu_fw_log_2_host(dev, MCU_FW_LOG_WM, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7915_mcu_fw_log_2_host(dev, MCU_FW_LOG_WA, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((mtk_wed_device_active(&dev->mt76.mmio.wed) &&\n\t     is_mt7915(&dev->mt76)) ||\n\t    !mtk_wed_get_rx_capa(&dev->mt76.mmio.wed))\n\t\tmt7915_mcu_wa_cmd(dev, MCU_WA_PARAM_CMD(CAPABILITY), 0, 0, 0);\n\n\tret = mt7915_mcu_set_mwds(dev, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7915_mcu_set_muru_ctrl(dev, MURU_SET_PLATFORM_TYPE,\n\t\t\t\t       MURU_PLATFORM_TYPE_PERF_LEVEL_2);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7915_mcu_init_rx_airtime(dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mt7915_mcu_set_red(dev, mtk_wed_device_active(&dev->mt76.mmio.wed));\n}\n\nint mt7915_mcu_init(struct mt7915_dev *dev)\n{\n\tstatic const struct mt76_mcu_ops mt7915_mcu_ops = {\n\t\t.headroom = sizeof(struct mt76_connac2_mcu_txd),\n\t\t.mcu_skb_send_msg = mt7915_mcu_send_message,\n\t\t.mcu_parse_response = mt7915_mcu_parse_response,\n\t};\n\n\tdev->mt76.mcu_ops = &mt7915_mcu_ops;\n\n\treturn mt7915_mcu_init_firmware(dev);\n}\n\nvoid mt7915_mcu_exit(struct mt7915_dev *dev)\n{\n\tmt76_connac_mcu_restart(&dev->mt76);\n\tif (mt7915_firmware_state(dev, false)) {\n\t\tdev_err(dev->mt76.dev, \"Failed to exit mcu\\n\");\n\t\tgoto out;\n\t}\n\n\tmt76_wr(dev, MT_TOP_LPCR_HOST_BAND(0), MT_TOP_LPCR_HOST_FW_OWN);\n\tif (dev->hif2)\n\t\tmt76_wr(dev, MT_TOP_LPCR_HOST_BAND(1),\n\t\t\tMT_TOP_LPCR_HOST_FW_OWN);\nout:\n\tskb_queue_purge(&dev->mt76.mcu.res_q);\n}\n\nstatic int\nmt7915_mcu_set_rx_hdr_trans_blacklist(struct mt7915_dev *dev, int band)\n{\n\tstruct {\n\t\tu8 operation;\n\t\tu8 count;\n\t\tu8 _rsv[2];\n\t\tu8 index;\n\t\tu8 enable;\n\t\t__le16 etype;\n\t} req = {\n\t\t.operation = 1,\n\t\t.count = 1,\n\t\t.enable = 1,\n\t\t.etype = cpu_to_le16(ETH_P_PAE),\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(RX_HDR_TRANS),\n\t\t\t\t &req, sizeof(req), false);\n}\n\nint mt7915_mcu_set_mac(struct mt7915_dev *dev, int band,\n\t\t       bool enable, bool hdr_trans)\n{\n\tstruct {\n\t\tu8 operation;\n\t\tu8 enable;\n\t\tu8 check_bssid;\n\t\tu8 insert_vlan;\n\t\tu8 remove_vlan;\n\t\tu8 tid;\n\t\tu8 mode;\n\t\tu8 rsv;\n\t} __packed req_trans = {\n\t\t.enable = hdr_trans,\n\t};\n\tstruct {\n\t\tu8 enable;\n\t\tu8 band;\n\t\tu8 rsv[2];\n\t} __packed req_mac = {\n\t\t.enable = enable,\n\t\t.band = band,\n\t};\n\tint ret;\n\n\tret = mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(RX_HDR_TRANS),\n\t\t\t\t&req_trans, sizeof(req_trans), false);\n\tif (ret)\n\t\treturn ret;\n\n\tif (hdr_trans)\n\t\tmt7915_mcu_set_rx_hdr_trans_blacklist(dev, band);\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(MAC_INIT_CTRL),\n\t\t\t\t &req_mac, sizeof(req_mac), true);\n}\n\nint mt7915_mcu_update_edca(struct mt7915_dev *dev, void *param)\n{\n\tstruct mt7915_mcu_tx *req = (struct mt7915_mcu_tx *)param;\n\tu8 num = req->total;\n\tsize_t len = sizeof(*req) -\n\t\t     (IEEE80211_NUM_ACS - num) * sizeof(struct edca);\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(EDCA_UPDATE), req,\n\t\t\t\t len, true);\n}\n\nint mt7915_mcu_set_tx(struct mt7915_dev *dev, struct ieee80211_vif *vif)\n{\n#define TX_CMD_MODE\t\t1\n\tstruct mt7915_mcu_tx req = {\n\t\t.valid = true,\n\t\t.mode = TX_CMD_MODE,\n\t\t.total = IEEE80211_NUM_ACS,\n\t};\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tint ac;\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tstruct ieee80211_tx_queue_params *q = &mvif->queue_params[ac];\n\t\tstruct edca *e = &req.edca[ac];\n\n\t\te->set = WMM_PARAM_SET;\n\t\te->queue = ac + mvif->mt76.wmm_idx * MT76_CONNAC_MAX_WMM_SETS;\n\t\te->aifs = q->aifs;\n\t\te->txop = cpu_to_le16(q->txop);\n\n\t\tif (q->cw_min)\n\t\t\te->cw_min = fls(q->cw_min);\n\t\telse\n\t\t\te->cw_min = 5;\n\n\t\tif (q->cw_max)\n\t\t\te->cw_max = cpu_to_le16(fls(q->cw_max));\n\t\telse\n\t\t\te->cw_max = cpu_to_le16(10);\n\t}\n\n\treturn mt7915_mcu_update_edca(dev, &req);\n}\n\nint mt7915_mcu_set_fcc5_lpn(struct mt7915_dev *dev, int val)\n{\n\tstruct {\n\t\t__le32 tag;\n\t\t__le16 min_lpn;\n\t\tu8 rsv[2];\n\t} __packed req = {\n\t\t.tag = cpu_to_le32(0x1),\n\t\t.min_lpn = cpu_to_le16(val),\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(SET_RDD_TH), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nint mt7915_mcu_set_pulse_th(struct mt7915_dev *dev,\n\t\t\t    const struct mt7915_dfs_pulse *pulse)\n{\n\tstruct {\n\t\t__le32 tag;\n\n\t\t__le32 max_width;\t\t \n\t\t__le32 max_pwr;\t\t\t \n\t\t__le32 min_pwr;\t\t\t \n\t\t__le32 min_stgr_pri;\t\t \n\t\t__le32 max_stgr_pri;\t\t \n\t\t__le32 min_cr_pri;\t\t \n\t\t__le32 max_cr_pri;\t\t \n\t} __packed req = {\n\t\t.tag = cpu_to_le32(0x3),\n\n#define __req_field(field) .field = cpu_to_le32(pulse->field)\n\t\t__req_field(max_width),\n\t\t__req_field(max_pwr),\n\t\t__req_field(min_pwr),\n\t\t__req_field(min_stgr_pri),\n\t\t__req_field(max_stgr_pri),\n\t\t__req_field(min_cr_pri),\n\t\t__req_field(max_cr_pri),\n#undef __req_field\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(SET_RDD_TH), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nint mt7915_mcu_set_radar_th(struct mt7915_dev *dev, int index,\n\t\t\t    const struct mt7915_dfs_pattern *pattern)\n{\n\tstruct {\n\t\t__le32 tag;\n\t\t__le16 radar_type;\n\n\t\tu8 enb;\n\t\tu8 stgr;\n\t\tu8 min_crpn;\n\t\tu8 max_crpn;\n\t\tu8 min_crpr;\n\t\tu8 min_pw;\n\t\t__le32 min_pri;\n\t\t__le32 max_pri;\n\t\tu8 max_pw;\n\t\tu8 min_crbn;\n\t\tu8 max_crbn;\n\t\tu8 min_stgpn;\n\t\tu8 max_stgpn;\n\t\tu8 min_stgpr;\n\t\tu8 rsv[2];\n\t\t__le32 min_stgpr_diff;\n\t} __packed req = {\n\t\t.tag = cpu_to_le32(0x2),\n\t\t.radar_type = cpu_to_le16(index),\n\n#define __req_field_u8(field) .field = pattern->field\n#define __req_field_u32(field) .field = cpu_to_le32(pattern->field)\n\t\t__req_field_u8(enb),\n\t\t__req_field_u8(stgr),\n\t\t__req_field_u8(min_crpn),\n\t\t__req_field_u8(max_crpn),\n\t\t__req_field_u8(min_crpr),\n\t\t__req_field_u8(min_pw),\n\t\t__req_field_u32(min_pri),\n\t\t__req_field_u32(max_pri),\n\t\t__req_field_u8(max_pw),\n\t\t__req_field_u8(min_crbn),\n\t\t__req_field_u8(max_crbn),\n\t\t__req_field_u8(min_stgpn),\n\t\t__req_field_u8(max_stgpn),\n\t\t__req_field_u8(min_stgpr),\n\t\t__req_field_u32(min_stgpr_diff),\n#undef __req_field_u8\n#undef __req_field_u32\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(SET_RDD_TH), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nstatic int\nmt7915_mcu_background_chain_ctrl(struct mt7915_phy *phy,\n\t\t\t\t struct cfg80211_chan_def *chandef,\n\t\t\t\t int cmd)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct mt76_phy *mphy = phy->mt76;\n\tstruct ieee80211_channel *chan = mphy->chandef.chan;\n\tint freq = mphy->chandef.center_freq1;\n\tstruct mt7915_mcu_background_chain_ctrl req = {\n\t\t.monitor_scan_type = 2,  \n\t};\n\n\tif (!chandef && cmd != CH_SWITCH_BACKGROUND_SCAN_STOP)\n\t\treturn -EINVAL;\n\n\tif (!cfg80211_chandef_valid(&mphy->chandef))\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase CH_SWITCH_BACKGROUND_SCAN_START: {\n\t\treq.chan = chan->hw_value;\n\t\treq.central_chan = ieee80211_frequency_to_channel(freq);\n\t\treq.bw = mt76_connac_chan_bw(&mphy->chandef);\n\t\treq.monitor_chan = chandef->chan->hw_value;\n\t\treq.monitor_central_chan =\n\t\t\tieee80211_frequency_to_channel(chandef->center_freq1);\n\t\treq.monitor_bw = mt76_connac_chan_bw(chandef);\n\t\treq.band_idx = phy->mt76->band_idx;\n\t\treq.scan_mode = 1;\n\t\tbreak;\n\t}\n\tcase CH_SWITCH_BACKGROUND_SCAN_RUNNING:\n\t\treq.monitor_chan = chandef->chan->hw_value;\n\t\treq.monitor_central_chan =\n\t\t\tieee80211_frequency_to_channel(chandef->center_freq1);\n\t\treq.band_idx = phy->mt76->band_idx;\n\t\treq.scan_mode = 2;\n\t\tbreak;\n\tcase CH_SWITCH_BACKGROUND_SCAN_STOP:\n\t\treq.chan = chan->hw_value;\n\t\treq.central_chan = ieee80211_frequency_to_channel(freq);\n\t\treq.bw = mt76_connac_chan_bw(&mphy->chandef);\n\t\treq.tx_stream = hweight8(mphy->antenna_mask);\n\t\treq.rx_stream = mphy->antenna_mask;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treq.band = chandef ? chandef->chan->band == NL80211_BAND_5GHZ : 1;\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(OFFCH_SCAN_CTRL),\n\t\t\t\t &req, sizeof(req), false);\n}\n\nint mt7915_mcu_rdd_background_enable(struct mt7915_phy *phy,\n\t\t\t\t     struct cfg80211_chan_def *chandef)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tint err, region;\n\n\tif (!chandef) {  \n\t\terr = mt76_connac_mcu_rdd_cmd(&dev->mt76, RDD_STOP, MT_RX_SEL2,\n\t\t\t\t\t      0, 0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn mt7915_mcu_background_chain_ctrl(phy, NULL,\n\t\t\t\tCH_SWITCH_BACKGROUND_SCAN_STOP);\n\t}\n\n\terr = mt7915_mcu_background_chain_ctrl(phy, chandef,\n\t\t\t\t\t       CH_SWITCH_BACKGROUND_SCAN_START);\n\tif (err)\n\t\treturn err;\n\n\tswitch (dev->mt76.region) {\n\tcase NL80211_DFS_ETSI:\n\t\tregion = 0;\n\t\tbreak;\n\tcase NL80211_DFS_JP:\n\t\tregion = 2;\n\t\tbreak;\n\tcase NL80211_DFS_FCC:\n\tdefault:\n\t\tregion = 1;\n\t\tbreak;\n\t}\n\n\treturn mt76_connac_mcu_rdd_cmd(&dev->mt76, RDD_START, MT_RX_SEL2,\n\t\t\t\t       0, region);\n}\n\nint mt7915_mcu_set_chan_info(struct mt7915_phy *phy, int cmd)\n{\n\tstatic const u8 ch_band[] = {\n\t\t[NL80211_BAND_2GHZ] = 0,\n\t\t[NL80211_BAND_5GHZ] = 1,\n\t\t[NL80211_BAND_6GHZ] = 2,\n\t};\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct cfg80211_chan_def *chandef = &phy->mt76->chandef;\n\tint freq1 = chandef->center_freq1;\n\tu8 band = phy->mt76->band_idx;\n\tstruct {\n\t\tu8 control_ch;\n\t\tu8 center_ch;\n\t\tu8 bw;\n\t\tu8 tx_path_num;\n\t\tu8 rx_path;\t \n\t\tu8 switch_reason;\n\t\tu8 band_idx;\n\t\tu8 center_ch2;\t \n\t\t__le16 cac_case;\n\t\tu8 channel_band;\n\t\tu8 rsv0;\n\t\t__le32 outband_freq;\n\t\tu8 txpower_drop;\n\t\tu8 ap_bw;\n\t\tu8 ap_center_ch;\n\t\tu8 rsv1[57];\n\t} __packed req = {\n\t\t.control_ch = chandef->chan->hw_value,\n\t\t.center_ch = ieee80211_frequency_to_channel(freq1),\n\t\t.bw = mt76_connac_chan_bw(chandef),\n\t\t.tx_path_num = hweight16(phy->mt76->chainmask),\n\t\t.rx_path = phy->mt76->chainmask >> (dev->chainshift * band),\n\t\t.band_idx = band,\n\t\t.channel_band = ch_band[chandef->chan->band],\n\t};\n\n#ifdef CONFIG_NL80211_TESTMODE\n\tif (phy->mt76->test.tx_antenna_mask &&\n\t    mt76_testmode_enabled(phy->mt76)) {\n\t\treq.tx_path_num = fls(phy->mt76->test.tx_antenna_mask);\n\t\treq.rx_path = phy->mt76->test.tx_antenna_mask;\n\t}\n#endif\n\n\tif (mt76_connac_spe_idx(phy->mt76->antenna_mask))\n\t\treq.tx_path_num = fls(phy->mt76->antenna_mask);\n\n\tif (phy->mt76->hw->conf.flags & IEEE80211_CONF_MONITOR)\n\t\treq.switch_reason = CH_SWITCH_NORMAL;\n\telse if (phy->mt76->hw->conf.flags & IEEE80211_CONF_OFFCHANNEL ||\n\t\t phy->mt76->hw->conf.flags & IEEE80211_CONF_IDLE)\n\t\treq.switch_reason = CH_SWITCH_SCAN_BYPASS_DPD;\n\telse if (!cfg80211_reg_can_beacon(phy->mt76->hw->wiphy, chandef,\n\t\t\t\t\t  NL80211_IFTYPE_AP))\n\t\treq.switch_reason = CH_SWITCH_DFS;\n\telse\n\t\treq.switch_reason = CH_SWITCH_NORMAL;\n\n\tif (cmd == MCU_EXT_CMD(CHANNEL_SWITCH))\n\t\treq.rx_path = hweight8(req.rx_path);\n\n\tif (chandef->width == NL80211_CHAN_WIDTH_80P80) {\n\t\tint freq2 = chandef->center_freq2;\n\n\t\treq.center_ch2 = ieee80211_frequency_to_channel(freq2);\n\t}\n\n\treturn mt76_mcu_send_msg(&dev->mt76, cmd, &req, sizeof(req), true);\n}\n\nstatic int mt7915_mcu_set_eeprom_flash(struct mt7915_dev *dev)\n{\n#define MAX_PAGE_IDX_MASK\tGENMASK(7, 5)\n#define PAGE_IDX_MASK\t\tGENMASK(4, 2)\n#define PER_PAGE_SIZE\t\t0x400\n\tstruct mt7915_mcu_eeprom req = { .buffer_mode = EE_MODE_BUFFER };\n\tu16 eeprom_size = mt7915_eeprom_size(dev);\n\tu8 total = DIV_ROUND_UP(eeprom_size, PER_PAGE_SIZE);\n\tu8 *eep = (u8 *)dev->mt76.eeprom.data;\n\tint eep_len;\n\tint i;\n\n\tfor (i = 0; i < total; i++, eep += eep_len) {\n\t\tstruct sk_buff *skb;\n\t\tint ret;\n\n\t\tif (i == total - 1 && !!(eeprom_size % PER_PAGE_SIZE))\n\t\t\teep_len = eeprom_size % PER_PAGE_SIZE;\n\t\telse\n\t\t\teep_len = PER_PAGE_SIZE;\n\n\t\tskb = mt76_mcu_msg_alloc(&dev->mt76, NULL,\n\t\t\t\t\t sizeof(req) + eep_len);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\n\t\treq.format = FIELD_PREP(MAX_PAGE_IDX_MASK, total - 1) |\n\t\t\t     FIELD_PREP(PAGE_IDX_MASK, i) | EE_FORMAT_WHOLE;\n\t\treq.len = cpu_to_le16(eep_len);\n\n\t\tskb_put_data(skb, &req, sizeof(req));\n\t\tskb_put_data(skb, eep, eep_len);\n\n\t\tret = mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t\t    MCU_EXT_CMD(EFUSE_BUFFER_MODE), true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint mt7915_mcu_set_eeprom(struct mt7915_dev *dev)\n{\n\tstruct mt7915_mcu_eeprom req = {\n\t\t.buffer_mode = EE_MODE_EFUSE,\n\t\t.format = EE_FORMAT_WHOLE,\n\t};\n\n\tif (dev->flash_mode)\n\t\treturn mt7915_mcu_set_eeprom_flash(dev);\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(EFUSE_BUFFER_MODE),\n\t\t\t\t &req, sizeof(req), true);\n}\n\nint mt7915_mcu_get_eeprom(struct mt7915_dev *dev, u32 offset)\n{\n\tstruct mt7915_mcu_eeprom_info req = {\n\t\t.addr = cpu_to_le32(round_down(offset,\n\t\t\t\t    MT7915_EEPROM_BLOCK_SIZE)),\n\t};\n\tstruct mt7915_mcu_eeprom_info *res;\n\tstruct sk_buff *skb;\n\tint ret;\n\tu8 *buf;\n\n\tret = mt76_mcu_send_and_get_msg(&dev->mt76,\n\t\t\t\t\tMCU_EXT_QUERY(EFUSE_ACCESS),\n\t\t\t\t\t&req, sizeof(req), true, &skb);\n\tif (ret)\n\t\treturn ret;\n\n\tres = (struct mt7915_mcu_eeprom_info *)skb->data;\n\tbuf = dev->mt76.eeprom.data + le32_to_cpu(res->addr);\n\tmemcpy(buf, res->data, MT7915_EEPROM_BLOCK_SIZE);\n\tdev_kfree_skb(skb);\n\n\treturn 0;\n}\n\nint mt7915_mcu_get_eeprom_free_block(struct mt7915_dev *dev, u8 *block_num)\n{\n\tstruct {\n\t\tu8 _rsv;\n\t\tu8 version;\n\t\tu8 die_idx;\n\t\tu8 _rsv2;\n\t} __packed req = {\n\t\t.version = 1,\n\t};\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tret = mt76_mcu_send_and_get_msg(&dev->mt76,\n\t\t\t\t\tMCU_EXT_QUERY(EFUSE_FREE_BLOCK),\n\t\t\t\t\t&req, sizeof(req), true, &skb);\n\tif (ret)\n\t\treturn ret;\n\n\t*block_num = *(u8 *)skb->data;\n\tdev_kfree_skb(skb);\n\n\treturn 0;\n}\n\nstatic int mt7915_mcu_set_pre_cal(struct mt7915_dev *dev, u8 idx,\n\t\t\t\t  u8 *data, u32 len, int cmd)\n{\n\tstruct {\n\t\tu8 dir;\n\t\tu8 valid;\n\t\t__le16 bitmap;\n\t\ts8 precal;\n\t\tu8 action;\n\t\tu8 band;\n\t\tu8 idx;\n\t\tu8 rsv[4];\n\t\t__le32 len;\n\t} req = {};\n\tstruct sk_buff *skb;\n\n\tskb = mt76_mcu_msg_alloc(&dev->mt76, NULL, sizeof(req) + len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\treq.idx = idx;\n\treq.len = cpu_to_le32(len);\n\tskb_put_data(skb, &req, sizeof(req));\n\tskb_put_data(skb, data, len);\n\n\treturn mt76_mcu_skb_send_msg(&dev->mt76, skb, cmd, false);\n}\n\nint mt7915_mcu_apply_group_cal(struct mt7915_dev *dev)\n{\n\tu8 idx = 0, *cal = dev->cal, *eep = dev->mt76.eeprom.data;\n\tu32 total = MT_EE_CAL_GROUP_SIZE;\n\n\tif (!(eep[MT_EE_DO_PRE_CAL] & MT_EE_WIFI_CAL_GROUP))\n\t\treturn 0;\n\n\t \n\twhile (total > 0) {\n\t\tint ret, len;\n\n\t\tlen = min_t(u32, total, MT_EE_CAL_UNIT);\n\n\t\tret = mt7915_mcu_set_pre_cal(dev, idx, cal, len,\n\t\t\t\t\t     MCU_EXT_CMD(GROUP_PRE_CAL_INFO));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ttotal -= len;\n\t\tcal += len;\n\t\tidx++;\n\t}\n\n\treturn 0;\n}\n\nstatic int mt7915_find_freq_idx(const u16 *freqs, int n_freqs, u16 cur)\n{\n\tint i;\n\n\tfor (i = 0; i < n_freqs; i++)\n\t\tif (cur == freqs[i])\n\t\t\treturn i;\n\n\treturn -1;\n}\n\nstatic int mt7915_dpd_freq_idx(u16 freq, u8 bw)\n{\n\tstatic const u16 freq_list[] = {\n\t\t5180, 5200, 5220, 5240,\n\t\t5260, 5280, 5300, 5320,\n\t\t5500, 5520, 5540, 5560,\n\t\t5580, 5600, 5620, 5640,\n\t\t5660, 5680, 5700, 5745,\n\t\t5765, 5785, 5805, 5825\n\t};\n\tint offset_2g = ARRAY_SIZE(freq_list);\n\tint idx;\n\n\tif (freq < 4000) {\n\t\tif (freq < 2432)\n\t\t\treturn offset_2g;\n\t\tif (freq < 2457)\n\t\t\treturn offset_2g + 1;\n\n\t\treturn offset_2g + 2;\n\t}\n\n\tif (bw == NL80211_CHAN_WIDTH_80P80 || bw == NL80211_CHAN_WIDTH_160)\n\t\treturn -1;\n\n\tif (bw != NL80211_CHAN_WIDTH_20) {\n\t\tidx = mt7915_find_freq_idx(freq_list, ARRAY_SIZE(freq_list),\n\t\t\t\t\t   freq + 10);\n\t\tif (idx >= 0)\n\t\t\treturn idx;\n\n\t\tidx = mt7915_find_freq_idx(freq_list, ARRAY_SIZE(freq_list),\n\t\t\t\t\t   freq - 10);\n\t\tif (idx >= 0)\n\t\t\treturn idx;\n\t}\n\n\treturn mt7915_find_freq_idx(freq_list, ARRAY_SIZE(freq_list), freq);\n}\n\nint mt7915_mcu_apply_tx_dpd(struct mt7915_phy *phy)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct cfg80211_chan_def *chandef = &phy->mt76->chandef;\n\tu16 total = 2, center_freq = chandef->center_freq1;\n\tu8 *cal = dev->cal, *eep = dev->mt76.eeprom.data;\n\tint idx;\n\n\tif (!(eep[MT_EE_DO_PRE_CAL] & MT_EE_WIFI_CAL_DPD))\n\t\treturn 0;\n\n\tidx = mt7915_dpd_freq_idx(center_freq, chandef->width);\n\tif (idx < 0)\n\t\treturn -EINVAL;\n\n\t \n\tidx = idx * 2;\n\tcal += MT_EE_CAL_GROUP_SIZE;\n\n\twhile (total--) {\n\t\tint ret;\n\n\t\tcal += (idx * MT_EE_CAL_UNIT);\n\t\tret = mt7915_mcu_set_pre_cal(dev, idx, cal, MT_EE_CAL_UNIT,\n\t\t\t\t\t     MCU_EXT_CMD(DPD_PRE_CAL_INFO));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tidx++;\n\t}\n\n\treturn 0;\n}\n\nint mt7915_mcu_get_chan_mib_info(struct mt7915_phy *phy, bool chan_switch)\n{\n\tstruct mt76_channel_state *state = phy->mt76->chan_state;\n\tstruct mt76_channel_state *state_ts = &phy->state_ts;\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct mt7915_mcu_mib *res, req[5];\n\tstruct sk_buff *skb;\n\tstatic const u32 *offs;\n\tint i, ret, len, offs_cc;\n\tu64 cc_tx;\n\n\t \n\tif (is_mt7915(&dev->mt76)) {\n\t\tstatic const u32 chip_offs[] = {\n\t\t\tMIB_NON_WIFI_TIME,\n\t\t\tMIB_TX_TIME,\n\t\t\tMIB_RX_TIME,\n\t\t\tMIB_OBSS_AIRTIME,\n\t\t\tMIB_TXOP_INIT_COUNT,\n\t\t};\n\t\tlen = ARRAY_SIZE(chip_offs);\n\t\toffs = chip_offs;\n\t\toffs_cc = 20;\n\t} else {\n\t\tstatic const u32 chip_offs[] = {\n\t\t\tMIB_NON_WIFI_TIME_V2,\n\t\t\tMIB_TX_TIME_V2,\n\t\t\tMIB_RX_TIME_V2,\n\t\t\tMIB_OBSS_AIRTIME_V2\n\t\t};\n\t\tlen = ARRAY_SIZE(chip_offs);\n\t\toffs = chip_offs;\n\t\toffs_cc = 0;\n\t}\n\n\tfor (i = 0; i < len; i++) {\n\t\treq[i].band = cpu_to_le32(phy->mt76->band_idx);\n\t\treq[i].offs = cpu_to_le32(offs[i]);\n\t}\n\n\tret = mt76_mcu_send_and_get_msg(&dev->mt76, MCU_EXT_CMD(GET_MIB_INFO),\n\t\t\t\t\treq, len * sizeof(req[0]), true, &skb);\n\tif (ret)\n\t\treturn ret;\n\n\tres = (struct mt7915_mcu_mib *)(skb->data + offs_cc);\n\n#define __res_u64(s) le64_to_cpu(res[s].data)\n\t \n\tcc_tx = is_mt7915(&dev->mt76) ? __res_u64(1) - __res_u64(4) : __res_u64(1);\n\n\tif (chan_switch)\n\t\tgoto out;\n\n\tstate->cc_tx += cc_tx - state_ts->cc_tx;\n\tstate->cc_bss_rx += __res_u64(2) - state_ts->cc_bss_rx;\n\tstate->cc_rx += __res_u64(2) + __res_u64(3) - state_ts->cc_rx;\n\tstate->cc_busy += __res_u64(0) + cc_tx + __res_u64(2) + __res_u64(3) -\n\t\t\t  state_ts->cc_busy;\n\nout:\n\tstate_ts->cc_tx = cc_tx;\n\tstate_ts->cc_bss_rx = __res_u64(2);\n\tstate_ts->cc_rx = __res_u64(2) + __res_u64(3);\n\tstate_ts->cc_busy = __res_u64(0) + cc_tx + __res_u64(2) + __res_u64(3);\n#undef __res_u64\n\n\tdev_kfree_skb(skb);\n\n\treturn 0;\n}\n\nint mt7915_mcu_get_temperature(struct mt7915_phy *phy)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct {\n\t\tu8 ctrl_id;\n\t\tu8 action;\n\t\tu8 band_idx;\n\t\tu8 rsv[5];\n\t} req = {\n\t\t.ctrl_id = THERMAL_SENSOR_TEMP_QUERY,\n\t\t.band_idx = phy->mt76->band_idx,\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(THERMAL_CTRL), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nint mt7915_mcu_set_thermal_throttling(struct mt7915_phy *phy, u8 state)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct mt7915_mcu_thermal_ctrl req = {\n\t\t.band_idx = phy->mt76->band_idx,\n\t\t.ctrl_id = THERMAL_PROTECT_DUTY_CONFIG,\n\t};\n\tint level, ret;\n\n\t \n\tfor (level = 0; level < 4; level++) {\n\t\treq.duty.duty_level = level;\n\t\treq.duty.duty_cycle = state;\n\t\tstate /= 2;\n\n\t\tret = mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(THERMAL_PROT),\n\t\t\t\t\t&req, sizeof(req), false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nint mt7915_mcu_set_thermal_protect(struct mt7915_phy *phy)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct {\n\t\tstruct mt7915_mcu_thermal_ctrl ctrl;\n\n\t\t__le32 trigger_temp;\n\t\t__le32 restore_temp;\n\t\t__le16 sustain_time;\n\t\tu8 rsv[2];\n\t} __packed req = {\n\t\t.ctrl = {\n\t\t\t.band_idx = phy->mt76->band_idx,\n\t\t\t.type.protect_type = 1,\n\t\t\t.type.trigger_type = 1,\n\t\t},\n\t};\n\tint ret;\n\n\treq.ctrl.ctrl_id = THERMAL_PROTECT_DISABLE;\n\tret = mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(THERMAL_PROT),\n\t\t\t\t&req, sizeof(req.ctrl), false);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treq.ctrl.ctrl_id = THERMAL_PROTECT_ENABLE;\n\t \n\treq.restore_temp = cpu_to_le32(phy->throttle_temp[0] - 10);\n\treq.trigger_temp = cpu_to_le32(phy->throttle_temp[1]);\n\treq.sustain_time = cpu_to_le16(10);\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(THERMAL_PROT),\n\t\t\t\t &req, sizeof(req), false);\n}\n\nint mt7915_mcu_set_txpower_frame_min(struct mt7915_phy *phy, s8 txpower)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct {\n\t\tu8 format_id;\n\t\tu8 rsv;\n\t\tu8 band_idx;\n\t\ts8 txpower_min;\n\t} __packed req = {\n\t\t.format_id = TX_POWER_LIMIT_FRAME_MIN,\n\t\t.band_idx = phy->mt76->band_idx,\n\t\t.txpower_min = txpower * 2,  \n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76,\n\t\t\t\t MCU_EXT_CMD(TX_POWER_FEATURE_CTRL), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nint mt7915_mcu_set_txpower_frame(struct mt7915_phy *phy,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_sta *sta, s8 txpower)\n{\n\tstruct mt7915_sta *msta = (struct mt7915_sta *)sta->drv_priv;\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct mt76_phy *mphy = phy->mt76;\n\tstruct {\n\t\tu8 format_id;\n\t\tu8 rsv[3];\n\t\tu8 band_idx;\n\t\ts8 txpower_max;\n\t\t__le16 wcid;\n\t\ts8 txpower_offs[48];\n\t} __packed req = {\n\t\t.format_id = TX_POWER_LIMIT_FRAME,\n\t\t.band_idx = phy->mt76->band_idx,\n\t\t.txpower_max = DIV_ROUND_UP(mphy->txpower_cur, 2),\n\t\t.wcid = cpu_to_le16(msta->wcid.idx),\n\t};\n\tint ret;\n\ts8 txpower_sku[MT7915_SKU_RATE_NUM];\n\n\tret = mt7915_mcu_get_txpower_sku(phy, txpower_sku, sizeof(txpower_sku));\n\tif (ret)\n\t\treturn ret;\n\n\ttxpower = mt7915_get_power_bound(phy, txpower);\n\tif (txpower > mphy->txpower_cur || txpower < 0)\n\t\treturn -EINVAL;\n\n\tif (txpower) {\n\t\tu32 offs, len, i;\n\n\t\tif (sta->deflink.ht_cap.ht_supported) {\n\t\t\tconst u8 *sku_len = mt7915_sku_group_len;\n\n\t\t\toffs = sku_len[SKU_CCK] + sku_len[SKU_OFDM];\n\t\t\tlen = sku_len[SKU_HT_BW20] + sku_len[SKU_HT_BW40];\n\n\t\t\tif (sta->deflink.vht_cap.vht_supported) {\n\t\t\t\toffs += len;\n\t\t\t\tlen = sku_len[SKU_VHT_BW20] * 4;\n\n\t\t\t\tif (sta->deflink.he_cap.has_he) {\n\t\t\t\t\toffs += len + sku_len[SKU_HE_RU26] * 3;\n\t\t\t\t\tlen = sku_len[SKU_HE_RU242] * 4;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < len; i++, offs++)\n\t\t\treq.txpower_offs[i] =\n\t\t\t\tDIV_ROUND_UP(txpower - txpower_sku[offs], 2);\n\t}\n\n\treturn mt76_mcu_send_msg(&dev->mt76,\n\t\t\t\t MCU_EXT_CMD(TX_POWER_FEATURE_CTRL), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nint mt7915_mcu_set_txpower_sku(struct mt7915_phy *phy)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct mt76_phy *mphy = phy->mt76;\n\tstruct ieee80211_hw *hw = mphy->hw;\n\tstruct mt7915_mcu_txpower_sku req = {\n\t\t.format_id = TX_POWER_LIMIT_TABLE,\n\t\t.band_idx = phy->mt76->band_idx,\n\t};\n\tstruct mt76_power_limits limits_array;\n\ts8 *la = (s8 *)&limits_array;\n\tint i, idx;\n\tint tx_power;\n\n\ttx_power = mt7915_get_power_bound(phy, hw->conf.power_level);\n\ttx_power = mt76_get_rate_power_limits(mphy, mphy->chandef.chan,\n\t\t\t\t\t      &limits_array, tx_power);\n\tmphy->txpower_cur = tx_power;\n\n\tfor (i = 0, idx = 0; i < ARRAY_SIZE(mt7915_sku_group_len); i++) {\n\t\tu8 mcs_num, len = mt7915_sku_group_len[i];\n\t\tint j;\n\n\t\tif (i >= SKU_HT_BW20 && i <= SKU_VHT_BW160) {\n\t\t\tmcs_num = 10;\n\n\t\t\tif (i == SKU_HT_BW20 || i == SKU_VHT_BW20)\n\t\t\t\tla = (s8 *)&limits_array + 12;\n\t\t} else {\n\t\t\tmcs_num = len;\n\t\t}\n\n\t\tfor (j = 0; j < min_t(u8, mcs_num, len); j++)\n\t\t\treq.txpower_sku[idx + j] = la[j];\n\n\t\tla += mcs_num;\n\t\tidx += len;\n\t}\n\n\treturn mt76_mcu_send_msg(&dev->mt76,\n\t\t\t\t MCU_EXT_CMD(TX_POWER_FEATURE_CTRL), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nint mt7915_mcu_get_txpower_sku(struct mt7915_phy *phy, s8 *txpower, int len)\n{\n#define RATE_POWER_INFO\t2\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct {\n\t\tu8 format_id;\n\t\tu8 category;\n\t\tu8 band_idx;\n\t\tu8 _rsv;\n\t} __packed req = {\n\t\t.format_id = TX_POWER_LIMIT_INFO,\n\t\t.category = RATE_POWER_INFO,\n\t\t.band_idx = phy->mt76->band_idx,\n\t};\n\ts8 txpower_sku[MT7915_SKU_RATE_NUM][2];\n\tstruct sk_buff *skb;\n\tint ret, i;\n\n\tret = mt76_mcu_send_and_get_msg(&dev->mt76,\n\t\t\t\t\tMCU_EXT_CMD(TX_POWER_FEATURE_CTRL),\n\t\t\t\t\t&req, sizeof(req), true, &skb);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(txpower_sku, skb->data + 4, sizeof(txpower_sku));\n\tfor (i = 0; i < len; i++)\n\t\ttxpower[i] = txpower_sku[i][req.band_idx];\n\n\tdev_kfree_skb(skb);\n\n\treturn 0;\n}\n\nint mt7915_mcu_set_test_param(struct mt7915_dev *dev, u8 param, bool test_mode,\n\t\t\t      u8 en)\n{\n\tstruct {\n\t\tu8 test_mode_en;\n\t\tu8 param_idx;\n\t\tu8 _rsv[2];\n\n\t\tu8 enable;\n\t\tu8 _rsv2[3];\n\n\t\tu8 pad[8];\n\t} __packed req = {\n\t\t.test_mode_en = test_mode,\n\t\t.param_idx = param,\n\t\t.enable = en,\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(ATE_CTRL), &req,\n\t\t\t\t sizeof(req), false);\n}\n\nint mt7915_mcu_set_sku_en(struct mt7915_phy *phy, bool enable)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct mt7915_sku {\n\t\tu8 format_id;\n\t\tu8 sku_enable;\n\t\tu8 band_idx;\n\t\tu8 rsv;\n\t} __packed req = {\n\t\t.format_id = TX_POWER_LIMIT_ENABLE,\n\t\t.band_idx = phy->mt76->band_idx,\n\t\t.sku_enable = enable,\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76,\n\t\t\t\t MCU_EXT_CMD(TX_POWER_FEATURE_CTRL), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nint mt7915_mcu_set_ser(struct mt7915_dev *dev, u8 action, u8 set, u8 band)\n{\n\tstruct {\n\t\tu8 action;\n\t\tu8 set;\n\t\tu8 band;\n\t\tu8 rsv;\n\t} req = {\n\t\t.action = action,\n\t\t.set = set,\n\t\t.band = band,\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(SET_SER_TRIGGER),\n\t\t\t\t &req, sizeof(req), false);\n}\n\nint mt7915_mcu_set_txbf(struct mt7915_dev *dev, u8 action)\n{\n\tstruct {\n\t\tu8 action;\n\t\tunion {\n\t\t\tstruct {\n\t\t\t\tu8 snd_mode;\n\t\t\t\tu8 sta_num;\n\t\t\t\tu8 rsv;\n\t\t\t\tu8 wlan_idx[4];\n\t\t\t\t__le32 snd_period;\t \n\t\t\t} __packed snd;\n\t\t\tstruct {\n\t\t\t\tbool ebf;\n\t\t\t\tbool ibf;\n\t\t\t\tu8 rsv;\n\t\t\t} __packed type;\n\t\t\tstruct {\n\t\t\t\tu8 bf_num;\n\t\t\t\tu8 bf_bitmap;\n\t\t\t\tu8 bf_sel[8];\n\t\t\t\tu8 rsv[5];\n\t\t\t} __packed mod;\n\t\t};\n\t} __packed req = {\n\t\t.action = action,\n\t};\n\n#define MT_BF_PROCESSING\t4\n\tswitch (action) {\n\tcase MT_BF_SOUNDING_ON:\n\t\treq.snd.snd_mode = MT_BF_PROCESSING;\n\t\tbreak;\n\tcase MT_BF_TYPE_UPDATE:\n\t\treq.type.ebf = true;\n\t\treq.type.ibf = dev->ibf;\n\t\tbreak;\n\tcase MT_BF_MODULE_UPDATE:\n\t\treq.mod.bf_num = 2;\n\t\treq.mod.bf_bitmap = GENMASK(1, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(TXBF_ACTION), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nstatic int\nmt7915_mcu_enable_obss_spr(struct mt7915_phy *phy, u8 action, u8 val)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct mt7915_mcu_sr_ctrl req = {\n\t\t.action = action,\n\t\t.argnum = 1,\n\t\t.band_idx = phy->mt76->band_idx,\n\t\t.val = cpu_to_le32(val),\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(SET_SPR), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nstatic int\nmt7915_mcu_set_obss_spr_pd(struct mt7915_phy *phy,\n\t\t\t   struct ieee80211_he_obss_pd *he_obss_pd)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct {\n\t\tstruct mt7915_mcu_sr_ctrl ctrl;\n\t\tstruct {\n\t\t\tu8 pd_th_non_srg;\n\t\t\tu8 pd_th_srg;\n\t\t\tu8 period_offs;\n\t\t\tu8 rcpi_src;\n\t\t\t__le16 obss_pd_min;\n\t\t\t__le16 obss_pd_min_srg;\n\t\t\tu8 resp_txpwr_mode;\n\t\t\tu8 txpwr_restrict_mode;\n\t\t\tu8 txpwr_ref;\n\t\t\tu8 rsv[3];\n\t\t} __packed param;\n\t} __packed req = {\n\t\t.ctrl = {\n\t\t\t.action = SPR_SET_PARAM,\n\t\t\t.argnum = 9,\n\t\t\t.band_idx = phy->mt76->band_idx,\n\t\t},\n\t};\n\tint ret;\n\tu8 max_th = 82, non_srg_max_th = 62;\n\n\t \n\tret = mt7915_mcu_enable_obss_spr(phy, SPR_ENABLE_DPD, false);\n\tif (ret)\n\t\treturn ret;\n\n\tif (he_obss_pd->sr_ctrl &\n\t    IEEE80211_HE_SPR_NON_SRG_OBSS_PD_SR_DISALLOWED)\n\t\treq.param.pd_th_non_srg = max_th;\n\telse if (he_obss_pd->sr_ctrl & IEEE80211_HE_SPR_NON_SRG_OFFSET_PRESENT)\n\t\treq.param.pd_th_non_srg  = max_th - he_obss_pd->non_srg_max_offset;\n\telse\n\t\treq.param.pd_th_non_srg  = non_srg_max_th;\n\n\tif (he_obss_pd->sr_ctrl & IEEE80211_HE_SPR_SRG_INFORMATION_PRESENT)\n\t\treq.param.pd_th_srg = max_th - he_obss_pd->max_offset;\n\n\treq.param.obss_pd_min = cpu_to_le16(82);\n\treq.param.obss_pd_min_srg = cpu_to_le16(82);\n\treq.param.txpwr_restrict_mode = 2;\n\treq.param.txpwr_ref = 21;\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(SET_SPR), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nstatic int\nmt7915_mcu_set_obss_spr_siga(struct mt7915_phy *phy, struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_he_obss_pd *he_obss_pd)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct mt7915_dev *dev = phy->dev;\n\tu8 omac = mvif->mt76.omac_idx;\n\tstruct {\n\t\tstruct mt7915_mcu_sr_ctrl ctrl;\n\t\tstruct {\n\t\t\tu8 omac;\n\t\t\tu8 rsv[3];\n\t\t\tu8 flag[20];\n\t\t} __packed siga;\n\t} __packed req = {\n\t\t.ctrl = {\n\t\t\t.action = SPR_SET_SIGA,\n\t\t\t.argnum = 1,\n\t\t\t.band_idx = phy->mt76->band_idx,\n\t\t},\n\t\t.siga = {\n\t\t\t.omac = omac > HW_BSSID_MAX ? omac - 12 : omac,\n\t\t},\n\t};\n\tint ret;\n\n\tif (he_obss_pd->sr_ctrl & IEEE80211_HE_SPR_HESIGA_SR_VAL15_ALLOWED)\n\t\treq.siga.flag[req.siga.omac] = 0xf;\n\telse\n\t\treturn 0;\n\n\t \n\tret = mt7915_mcu_enable_obss_spr(phy, SPR_ENABLE_MODE, 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(SET_SPR), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nstatic int\nmt7915_mcu_set_obss_spr_bitmap(struct mt7915_phy *phy,\n\t\t\t       struct ieee80211_he_obss_pd *he_obss_pd)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct {\n\t\tstruct mt7915_mcu_sr_ctrl ctrl;\n\t\tstruct {\n\t\t\t__le32 color_l[2];\n\t\t\t__le32 color_h[2];\n\t\t\t__le32 bssid_l[2];\n\t\t\t__le32 bssid_h[2];\n\t\t} __packed bitmap;\n\t} __packed req = {\n\t\t.ctrl = {\n\t\t\t.action = SPR_SET_SRG_BITMAP,\n\t\t\t.argnum = 4,\n\t\t\t.band_idx = phy->mt76->band_idx,\n\t\t},\n\t};\n\tu32 bitmap;\n\n\tmemcpy(&bitmap, he_obss_pd->bss_color_bitmap, sizeof(bitmap));\n\treq.bitmap.color_l[req.ctrl.band_idx] = cpu_to_le32(bitmap);\n\n\tmemcpy(&bitmap, he_obss_pd->bss_color_bitmap + 4, sizeof(bitmap));\n\treq.bitmap.color_h[req.ctrl.band_idx] = cpu_to_le32(bitmap);\n\n\tmemcpy(&bitmap, he_obss_pd->partial_bssid_bitmap, sizeof(bitmap));\n\treq.bitmap.bssid_l[req.ctrl.band_idx] = cpu_to_le32(bitmap);\n\n\tmemcpy(&bitmap, he_obss_pd->partial_bssid_bitmap + 4, sizeof(bitmap));\n\treq.bitmap.bssid_h[req.ctrl.band_idx] = cpu_to_le32(bitmap);\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(SET_SPR), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nint mt7915_mcu_add_obss_spr(struct mt7915_phy *phy, struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_he_obss_pd *he_obss_pd)\n{\n\tint ret;\n\n\t \n\tret = mt7915_mcu_enable_obss_spr(phy, SPR_ENABLE_SD, sr_scene_detect);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (sr_scene_detect && !he_obss_pd->enable)\n\t\treturn 0;\n\n\t \n\tret = mt7915_mcu_enable_obss_spr(phy, SPR_ENABLE, he_obss_pd->enable);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sr_scene_detect || !he_obss_pd->enable)\n\t\treturn 0;\n\n\tret = mt7915_mcu_enable_obss_spr(phy, SPR_ENABLE_TX, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mt7915_mcu_set_obss_spr_pd(phy, he_obss_pd);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mt7915_mcu_set_obss_spr_siga(phy, vif, he_obss_pd);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn mt7915_mcu_set_obss_spr_bitmap(phy, he_obss_pd);\n}\n\nint mt7915_mcu_get_rx_rate(struct mt7915_phy *phy, struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_sta *sta, struct rate_info *rate)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct mt7915_sta *msta = (struct mt7915_sta *)sta->drv_priv;\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct mt76_phy *mphy = phy->mt76;\n\tstruct {\n\t\tu8 category;\n\t\tu8 band;\n\t\t__le16 wcid;\n\t} __packed req = {\n\t\t.category = MCU_PHY_STATE_CONTENTION_RX_RATE,\n\t\t.band = mvif->mt76.band_idx,\n\t\t.wcid = cpu_to_le16(msta->wcid.idx),\n\t};\n\tstruct ieee80211_supported_band *sband;\n\tstruct mt7915_mcu_phy_rx_info *res;\n\tstruct sk_buff *skb;\n\tint ret;\n\tbool cck = false;\n\n\tret = mt76_mcu_send_and_get_msg(&dev->mt76, MCU_EXT_CMD(PHY_STAT_INFO),\n\t\t\t\t\t&req, sizeof(req), true, &skb);\n\tif (ret)\n\t\treturn ret;\n\n\tres = (struct mt7915_mcu_phy_rx_info *)skb->data;\n\n\trate->mcs = res->rate;\n\trate->nss = res->nsts + 1;\n\n\tswitch (res->mode) {\n\tcase MT_PHY_TYPE_CCK:\n\t\tcck = true;\n\t\tfallthrough;\n\tcase MT_PHY_TYPE_OFDM:\n\t\tif (mphy->chandef.chan->band == NL80211_BAND_5GHZ)\n\t\t\tsband = &mphy->sband_5g.sband;\n\t\telse if (mphy->chandef.chan->band == NL80211_BAND_6GHZ)\n\t\t\tsband = &mphy->sband_6g.sband;\n\t\telse\n\t\t\tsband = &mphy->sband_2g.sband;\n\n\t\trate->mcs = mt76_get_rate(&dev->mt76, sband, rate->mcs, cck);\n\t\trate->legacy = sband->bitrates[rate->mcs].bitrate;\n\t\tbreak;\n\tcase MT_PHY_TYPE_HT:\n\tcase MT_PHY_TYPE_HT_GF:\n\t\tif (rate->mcs > 31) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\trate->flags = RATE_INFO_FLAGS_MCS;\n\t\tif (res->gi)\n\t\t\trate->flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t\tbreak;\n\tcase MT_PHY_TYPE_VHT:\n\t\tif (rate->mcs > 9) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\trate->flags = RATE_INFO_FLAGS_VHT_MCS;\n\t\tif (res->gi)\n\t\t\trate->flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t\tbreak;\n\tcase MT_PHY_TYPE_HE_SU:\n\tcase MT_PHY_TYPE_HE_EXT_SU:\n\tcase MT_PHY_TYPE_HE_TB:\n\tcase MT_PHY_TYPE_HE_MU:\n\t\tif (res->gi > NL80211_RATE_INFO_HE_GI_3_2 || rate->mcs > 11) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\trate->he_gi = res->gi;\n\t\trate->flags = RATE_INFO_FLAGS_HE_MCS;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tswitch (res->bw) {\n\tcase IEEE80211_STA_RX_BW_160:\n\t\trate->bw = RATE_INFO_BW_160;\n\t\tbreak;\n\tcase IEEE80211_STA_RX_BW_80:\n\t\trate->bw = RATE_INFO_BW_80;\n\t\tbreak;\n\tcase IEEE80211_STA_RX_BW_40:\n\t\trate->bw = RATE_INFO_BW_40;\n\t\tbreak;\n\tdefault:\n\t\trate->bw = RATE_INFO_BW_20;\n\t\tbreak;\n\t}\n\nout:\n\tdev_kfree_skb(skb);\n\n\treturn ret;\n}\n\nint mt7915_mcu_update_bss_color(struct mt7915_dev *dev, struct ieee80211_vif *vif,\n\t\t\t\tstruct cfg80211_he_bss_color *he_bss_color)\n{\n\tint len = sizeof(struct sta_req_hdr) + sizeof(struct bss_info_color);\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct bss_info_color *bss_color;\n\tstruct sk_buff *skb;\n\tstruct tlv *tlv;\n\n\tskb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->mt76,\n\t\t\t\t\t      NULL, len);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, BSS_INFO_BSS_COLOR,\n\t\t\t\t      sizeof(*bss_color));\n\tbss_color = (struct bss_info_color *)tlv;\n\tbss_color->disable = !he_bss_color->enabled;\n\tbss_color->color = he_bss_color->color;\n\n\treturn mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t     MCU_EXT_CMD(BSS_INFO_UPDATE), true);\n}\n\n#define TWT_AGRT_TRIGGER\tBIT(0)\n#define TWT_AGRT_ANNOUNCE\tBIT(1)\n#define TWT_AGRT_PROTECT\tBIT(2)\n\nint mt7915_mcu_twt_agrt_update(struct mt7915_dev *dev,\n\t\t\t       struct mt7915_vif *mvif,\n\t\t\t       struct mt7915_twt_flow *flow,\n\t\t\t       int cmd)\n{\n\tstruct {\n\t\tu8 tbl_idx;\n\t\tu8 cmd;\n\t\tu8 own_mac_idx;\n\t\tu8 flowid;  \n\t\t__le16 peer_id;  \n\t\tu8 duration;  \n\t\tu8 bss_idx;\n\t\t__le64 start_tsf;\n\t\t__le16 mantissa;\n\t\tu8 exponent;\n\t\tu8 is_ap;\n\t\tu8 agrt_params;\n\t\tu8 rsv[23];\n\t} __packed req = {\n\t\t.tbl_idx = flow->table_id,\n\t\t.cmd = cmd,\n\t\t.own_mac_idx = mvif->mt76.omac_idx,\n\t\t.flowid = flow->id,\n\t\t.peer_id = cpu_to_le16(flow->wcid),\n\t\t.duration = flow->duration,\n\t\t.bss_idx = mvif->mt76.idx,\n\t\t.start_tsf = cpu_to_le64(flow->tsf),\n\t\t.mantissa = flow->mantissa,\n\t\t.exponent = flow->exp,\n\t\t.is_ap = true,\n\t};\n\n\tif (flow->protection)\n\t\treq.agrt_params |= TWT_AGRT_PROTECT;\n\tif (!flow->flowtype)\n\t\treq.agrt_params |= TWT_AGRT_ANNOUNCE;\n\tif (flow->trigger)\n\t\treq.agrt_params |= TWT_AGRT_TRIGGER;\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(TWT_AGRT_UPDATE),\n\t\t\t\t &req, sizeof(req), true);\n}\n\nint mt7915_mcu_wed_wa_tx_stats(struct mt7915_dev *dev, u16 wlan_idx)\n{\n\tstruct {\n\t\t__le32 cmd;\n\t\t__le32 num;\n\t\t__le32 __rsv;\n\t\t__le16 wlan_idx;\n\t} req = {\n\t\t.cmd = cpu_to_le32(0x15),\n\t\t.num = cpu_to_le32(1),\n\t\t.wlan_idx = cpu_to_le16(wlan_idx),\n\t};\n\tstruct mt7915_mcu_wa_tx_stat {\n\t\t__le16 wlan_idx;\n\t\tu8 __rsv[2];\n\n\t\t \n\t\t__le32 tx_bytes;\n\t\t__le32 tx_packets;\n\t} *res;\n\tstruct mt76_wcid *wcid;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tret = mt76_mcu_send_and_get_msg(&dev->mt76, MCU_WA_PARAM_CMD(QUERY),\n\t\t\t\t\t&req, sizeof(req), true, &skb);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!is_mt7915(&dev->mt76))\n\t\tskb_pull(skb, 4);\n\n\tres = (struct mt7915_mcu_wa_tx_stat *)skb->data;\n\n\tif (le16_to_cpu(res->wlan_idx) != wlan_idx) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trcu_read_lock();\n\n\twcid = rcu_dereference(dev->mt76.wcid[wlan_idx]);\n\tif (wcid)\n\t\twcid->stats.tx_packets += le32_to_cpu(res->tx_packets);\n\telse\n\t\tret = -EINVAL;\n\n\trcu_read_unlock();\nout:\n\tdev_kfree_skb(skb);\n\n\treturn ret;\n}\n\nint mt7915_mcu_rf_regval(struct mt7915_dev *dev, u32 regidx, u32 *val, bool set)\n{\n\tstruct {\n\t\t__le32 idx;\n\t\t__le32 ofs;\n\t\t__le32 data;\n\t} __packed req = {\n\t\t.idx = cpu_to_le32(u32_get_bits(regidx, GENMASK(31, 24))),\n\t\t.ofs = cpu_to_le32(u32_get_bits(regidx, GENMASK(23, 0))),\n\t\t.data = set ? cpu_to_le32(*val) : 0,\n\t};\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tif (set)\n\t\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(RF_REG_ACCESS),\n\t\t\t\t\t &req, sizeof(req), false);\n\n\tret = mt76_mcu_send_and_get_msg(&dev->mt76, MCU_EXT_QUERY(RF_REG_ACCESS),\n\t\t\t\t\t&req, sizeof(req), true, &skb);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = le32_to_cpu(*(__le32 *)(skb->data + 8));\n\tdev_kfree_skb(skb);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}