{
  "module_name": "soc.c",
  "hash_id": "4be7de55cd408d3439484d478097ded01a56ff90e71a7e0f6df68cb394dd4195",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7915/soc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/of.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_gpio.h>\n#include <linux/iopoll.h>\n#include <linux/reset.h>\n#include <linux/of_net.h>\n#include <linux/clk.h>\n\n#include \"mt7915.h\"\n\n#define MT7981_CON_INFRA_VERSION 0x02090000\n#define MT7986_CON_INFRA_VERSION 0x02070000\n\n \n#define MT_INFRACFG_CONN2AP_SLPPROT\t0x0d0\n#define MT_INFRACFG_AP2CONN_SLPPROT\t0x0d4\n\n#define MT_INFRACFG_RX_EN_MASK\t\tBIT(16)\n#define MT_INFRACFG_TX_RDY_MASK\t\tBIT(4)\n#define MT_INFRACFG_TX_EN_MASK\t\tBIT(0)\n\n \n#define MT_TOP_POS_FAST_CTRL\t\t0x114\n#define MT_TOP_POS_FAST_EN_MASK\t\tBIT(3)\n\n#define MT_TOP_POS_SKU\t\t\t0x21c\n#define MT_TOP_POS_SKU_MASK\t\tGENMASK(31, 28)\n#define MT_TOP_POS_SKU_ADIE_DBDC_MASK\tBIT(2)\n\nenum {\n\tADIE_SB,\n\tADIE_DBDC\n};\n\nstatic int\nmt76_wmac_spi_read(struct mt7915_dev *dev, u8 adie, u32 addr, u32 *val)\n{\n\tint ret;\n\tu32 cur;\n\n\tret = read_poll_timeout(mt76_rr, cur, !(cur & MT_TOP_SPI_POLLING_BIT),\n\t\t\t\tUSEC_PER_MSEC, 50 * USEC_PER_MSEC, false,\n\t\t\t\tdev, MT_TOP_SPI_BUSY_CR(adie));\n\tif (ret)\n\t\treturn ret;\n\n\tmt76_wr(dev, MT_TOP_SPI_ADDR_CR(adie),\n\t\tMT_TOP_SPI_READ_ADDR_FORMAT | addr);\n\tmt76_wr(dev, MT_TOP_SPI_WRITE_DATA_CR(adie), 0);\n\n\tret = read_poll_timeout(mt76_rr, cur, !(cur & MT_TOP_SPI_POLLING_BIT),\n\t\t\t\tUSEC_PER_MSEC, 50 * USEC_PER_MSEC, false,\n\t\t\t\tdev, MT_TOP_SPI_BUSY_CR(adie));\n\tif (ret)\n\t\treturn ret;\n\n\t*val = mt76_rr(dev, MT_TOP_SPI_READ_DATA_CR(adie));\n\n\treturn 0;\n}\n\nstatic int\nmt76_wmac_spi_write(struct mt7915_dev *dev, u8 adie, u32 addr, u32 val)\n{\n\tint ret;\n\tu32 cur;\n\n\tret = read_poll_timeout(mt76_rr, cur, !(cur & MT_TOP_SPI_POLLING_BIT),\n\t\t\t\tUSEC_PER_MSEC, 50 * USEC_PER_MSEC, false,\n\t\t\t\tdev, MT_TOP_SPI_BUSY_CR(adie));\n\tif (ret)\n\t\treturn ret;\n\n\tmt76_wr(dev, MT_TOP_SPI_ADDR_CR(adie),\n\t\tMT_TOP_SPI_WRITE_ADDR_FORMAT | addr);\n\tmt76_wr(dev, MT_TOP_SPI_WRITE_DATA_CR(adie), val);\n\n\treturn read_poll_timeout(mt76_rr, cur, !(cur & MT_TOP_SPI_POLLING_BIT),\n\t\t\t\t USEC_PER_MSEC, 50 * USEC_PER_MSEC, false,\n\t\t\t\t dev, MT_TOP_SPI_BUSY_CR(adie));\n}\n\nstatic int\nmt76_wmac_spi_rmw(struct mt7915_dev *dev, u8 adie,\n\t\t  u32 addr, u32 mask, u32 val)\n{\n\tu32 cur, ret;\n\n\tret = mt76_wmac_spi_read(dev, adie, addr, &cur);\n\tif (ret)\n\t\treturn ret;\n\n\tcur &= ~mask;\n\tcur |= val;\n\n\treturn mt76_wmac_spi_write(dev, adie, addr, cur);\n}\n\nstatic int\nmt7986_wmac_adie_efuse_read(struct mt7915_dev *dev, u8 adie,\n\t\t\t    u32 addr, u32 *data)\n{\n\tint ret, temp;\n\tu32 val, mask;\n\n\tret = mt76_wmac_spi_write(dev, adie, MT_ADIE_EFUSE_CFG,\n\t\t\t\t  MT_ADIE_EFUSE_CTRL_MASK);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt76_wmac_spi_rmw(dev, adie, MT_ADIE_EFUSE2_CTRL, BIT(30), 0x0);\n\tif (ret)\n\t\treturn ret;\n\n\tmask = (MT_ADIE_EFUSE_MODE_MASK | MT_ADIE_EFUSE_ADDR_MASK |\n\t\tMT_ADIE_EFUSE_KICK_MASK);\n\tval = FIELD_PREP(MT_ADIE_EFUSE_MODE_MASK, 0) |\n\t      FIELD_PREP(MT_ADIE_EFUSE_ADDR_MASK, addr) |\n\t      FIELD_PREP(MT_ADIE_EFUSE_KICK_MASK, 1);\n\tret = mt76_wmac_spi_rmw(dev, adie, MT_ADIE_EFUSE2_CTRL, mask, val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = read_poll_timeout(mt76_wmac_spi_read, temp,\n\t\t\t\t!temp && !FIELD_GET(MT_ADIE_EFUSE_KICK_MASK, val),\n\t\t\t\tUSEC_PER_MSEC, 50 * USEC_PER_MSEC, false,\n\t\t\t\tdev, adie, MT_ADIE_EFUSE2_CTRL, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt76_wmac_spi_read(dev, adie, MT_ADIE_EFUSE2_CTRL, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (FIELD_GET(MT_ADIE_EFUSE_VALID_MASK, val) == 1)\n\t\tret = mt76_wmac_spi_read(dev, adie, MT_ADIE_EFUSE_RDATA0,\n\t\t\t\t\t data);\n\n\treturn ret;\n}\n\nstatic inline void mt76_wmac_spi_lock(struct mt7915_dev *dev)\n{\n\tu32 cur;\n\n\tread_poll_timeout(mt76_rr, cur,\n\t\t\t  FIELD_GET(MT_SEMA_RFSPI_STATUS_MASK, cur),\n\t\t\t  1000, 1000 * MSEC_PER_SEC, false, dev,\n\t\t\t  MT_SEMA_RFSPI_STATUS);\n}\n\nstatic inline void mt76_wmac_spi_unlock(struct mt7915_dev *dev)\n{\n\tmt76_wr(dev, MT_SEMA_RFSPI_RELEASE, 1);\n}\n\nstatic u32 mt76_wmac_rmw(void __iomem *base, u32 offset, u32 mask, u32 val)\n{\n\tval |= readl(base + offset) & ~mask;\n\twritel(val, base + offset);\n\n\treturn val;\n}\n\nstatic u8 mt798x_wmac_check_adie_type(struct mt7915_dev *dev)\n{\n\tu32 val;\n\n\t \n\tif (is_mt7981(&dev->mt76))\n\t\treturn ADIE_DBDC;\n\n\tval = readl(dev->sku + MT_TOP_POS_SKU);\n\n\treturn FIELD_GET(MT_TOP_POS_SKU_ADIE_DBDC_MASK, val);\n}\n\nstatic int mt7986_wmac_consys_reset(struct mt7915_dev *dev, bool enable)\n{\n\tif (!enable)\n\t\treturn reset_control_assert(dev->rstc);\n\n\tmt76_wmac_rmw(dev->sku, MT_TOP_POS_FAST_CTRL,\n\t\t      MT_TOP_POS_FAST_EN_MASK,\n\t\t      FIELD_PREP(MT_TOP_POS_FAST_EN_MASK, 0x1));\n\n\treturn reset_control_deassert(dev->rstc);\n}\n\nstatic int mt7986_wmac_gpio_setup(struct mt7915_dev *dev)\n{\n\tstruct pinctrl_state *state;\n\tstruct pinctrl *pinctrl;\n\tint ret;\n\tu8 type;\n\n\ttype = mt798x_wmac_check_adie_type(dev);\n\tpinctrl = devm_pinctrl_get(dev->mt76.dev);\n\tif (IS_ERR(pinctrl))\n\t\treturn PTR_ERR(pinctrl);\n\n\tswitch (type) {\n\tcase ADIE_SB:\n\t\tstate = pinctrl_lookup_state(pinctrl, \"default\");\n\t\tif (IS_ERR_OR_NULL(state))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase ADIE_DBDC:\n\t\tstate = pinctrl_lookup_state(pinctrl, \"dbdc\");\n\t\tif (IS_ERR_OR_NULL(state))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = pinctrl_select_state(pinctrl, state);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(500, 1000);\n\n\treturn 0;\n}\n\nstatic int mt7986_wmac_consys_lockup(struct mt7915_dev *dev, bool enable)\n{\n\tint ret;\n\tu32 cur;\n\n\tmt76_wmac_rmw(dev->dcm, MT_INFRACFG_AP2CONN_SLPPROT,\n\t\t      MT_INFRACFG_RX_EN_MASK,\n\t\t      FIELD_PREP(MT_INFRACFG_RX_EN_MASK, enable));\n\tret = read_poll_timeout(readl, cur, !(cur & MT_INFRACFG_RX_EN_MASK),\n\t\t\t\tUSEC_PER_MSEC, 50 * USEC_PER_MSEC, false,\n\t\t\t\tdev->dcm + MT_INFRACFG_AP2CONN_SLPPROT);\n\tif (ret)\n\t\treturn ret;\n\n\tmt76_wmac_rmw(dev->dcm, MT_INFRACFG_AP2CONN_SLPPROT,\n\t\t      MT_INFRACFG_TX_EN_MASK,\n\t\t      FIELD_PREP(MT_INFRACFG_TX_EN_MASK, enable));\n\tret = read_poll_timeout(readl, cur, !(cur & MT_INFRACFG_TX_RDY_MASK),\n\t\t\t\tUSEC_PER_MSEC, 50 * USEC_PER_MSEC, false,\n\t\t\t\tdev->dcm + MT_INFRACFG_AP2CONN_SLPPROT);\n\tif (ret)\n\t\treturn ret;\n\n\tmt76_wmac_rmw(dev->dcm, MT_INFRACFG_CONN2AP_SLPPROT,\n\t\t      MT_INFRACFG_RX_EN_MASK,\n\t\t      FIELD_PREP(MT_INFRACFG_RX_EN_MASK, enable));\n\tmt76_wmac_rmw(dev->dcm, MT_INFRACFG_CONN2AP_SLPPROT,\n\t\t      MT_INFRACFG_TX_EN_MASK,\n\t\t      FIELD_PREP(MT_INFRACFG_TX_EN_MASK, enable));\n\n\treturn 0;\n}\n\nstatic int mt798x_wmac_coninfra_check(struct mt7915_dev *dev)\n{\n\tu32 cur;\n\tu32 con_infra_version;\n\n\tif (is_mt7981(&dev->mt76)) {\n\t\tcon_infra_version = MT7981_CON_INFRA_VERSION;\n\t} else if (is_mt7986(&dev->mt76)) {\n\t\tcon_infra_version = MT7986_CON_INFRA_VERSION;\n\t} else {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\treturn read_poll_timeout(mt76_rr, cur, (cur == con_infra_version),\n\t\t\t\t USEC_PER_MSEC, 50 * USEC_PER_MSEC,\n\t\t\t\t false, dev, MT_CONN_INFRA_BASE);\n}\n\nstatic int mt798x_wmac_coninfra_setup(struct mt7915_dev *dev)\n{\n\tstruct device *pdev = dev->mt76.dev;\n\tstruct reserved_mem *rmem;\n\tstruct device_node *np;\n\tu32 val;\n\n\tnp = of_parse_phandle(pdev->of_node, \"memory-region\", 0);\n\tif (!np)\n\t\treturn -EINVAL;\n\n\trmem = of_reserved_mem_lookup(np);\n\tof_node_put(np);\n\tif (!rmem)\n\t\treturn -EINVAL;\n\n\tval = (rmem->base >> 16) & MT_TOP_MCU_EMI_BASE_MASK;\n\n\tif (is_mt7986(&dev->mt76)) {\n\t\t \n\t\tmt76_rmw_field(dev, MT_INFRA_CKGEN_BUS,\n\t\t\t       MT_INFRA_CKGEN_BUS_RDY_SEL_MASK, 0x1);\n\t\tmt76_rmw_field(dev, MT_INFRA_CKGEN_BUS,\n\t\t\t       MT_INFRA_CKGEN_BUS_RDY_SEL_MASK, 0x1);\n\t}\n\n\tmt76_rmw_field(dev, MT_TOP_MCU_EMI_BASE,\n\t\t       MT_TOP_MCU_EMI_BASE_MASK, val);\n\n\tif (is_mt7981(&dev->mt76)) {\n\t\tmt76_rmw_field(dev, MT_TOP_WF_AP_PERI_BASE,\n\t\t\t       MT_TOP_WF_AP_PERI_BASE_MASK, 0x300d0000 >> 16);\n\n\t\tmt76_rmw_field(dev, MT_TOP_EFUSE_BASE,\n\t\t\t       MT_TOP_EFUSE_BASE_MASK, 0x11f20000 >> 16);\n\t}\n\n\tmt76_wr(dev, MT_INFRA_BUS_EMI_START, rmem->base);\n\tmt76_wr(dev, MT_INFRA_BUS_EMI_END, rmem->size);\n\n\tmt76_rr(dev, MT_CONN_INFRA_EFUSE);\n\n\t \n\tmt76_wr(dev, MT_TOP_RGU_SYSRAM_PDN, 0);\n\tmt76_wr(dev, MT_TOP_RGU_SYSRAM_SLP, 1);\n\n\treturn 0;\n}\n\nstatic int mt798x_wmac_sku_setup(struct mt7915_dev *dev, u32 *adie_type)\n{\n\tint ret;\n\tu32 adie_main = 0, adie_ext = 0;\n\n\tmt76_rmw_field(dev, MT_CONN_INFRA_ADIE_RESET,\n\t\t       MT_CONN_INFRA_ADIE1_RESET_MASK, 0x1);\n\n\tif (is_mt7986(&dev->mt76)) {\n\t\tmt76_rmw_field(dev, MT_CONN_INFRA_ADIE_RESET,\n\t\t\t       MT_CONN_INFRA_ADIE2_RESET_MASK, 0x1);\n\t}\n\n\tmt76_wmac_spi_lock(dev);\n\n\tret = mt76_wmac_spi_read(dev, 0, MT_ADIE_CHIP_ID, &adie_main);\n\tif (ret)\n\t\tgoto out;\n\n\tif (is_mt7986(&dev->mt76)) {\n\t\tret = mt76_wmac_spi_read(dev, 1, MT_ADIE_CHIP_ID, &adie_ext);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t*adie_type = FIELD_GET(MT_ADIE_CHIP_ID_MASK, adie_main) |\n\t\t     (MT_ADIE_CHIP_ID_MASK & adie_ext);\n\nout:\n\tmt76_wmac_spi_unlock(dev);\n\n\treturn 0;\n}\n\nstatic inline u16 mt7986_adie_idx(u8 adie, u32 adie_type)\n{\n\tif (adie == 0)\n\t\treturn u32_get_bits(adie_type, MT_ADIE_IDX0);\n\telse\n\t\treturn u32_get_bits(adie_type, MT_ADIE_IDX1);\n}\n\nstatic inline bool is_7975(struct mt7915_dev *dev, u8 adie, u32 adie_type)\n{\n\treturn mt7986_adie_idx(adie, adie_type) == 0x7975;\n}\n\nstatic inline bool is_7976(struct mt7915_dev *dev, u8 adie, u32 adie_type)\n{\n\treturn mt7986_adie_idx(adie, adie_type) == 0x7976;\n}\n\nstatic int mt7986_wmac_adie_thermal_cal(struct mt7915_dev *dev, u8 adie)\n{\n\tint ret;\n\tu32 data, val;\n\n\tret = mt7986_wmac_adie_efuse_read(dev, adie, MT_ADIE_THADC_ANALOG,\n\t\t\t\t\t  &data);\n\tif (ret || FIELD_GET(MT_ADIE_ANA_EN_MASK, data)) {\n\t\tval = FIELD_GET(MT_ADIE_VRPI_SEL_EFUSE_MASK, data);\n\t\tret = mt76_wmac_spi_rmw(dev, adie, MT_ADIE_RG_TOP_THADC_BG,\n\t\t\t\t\tMT_ADIE_VRPI_SEL_CR_MASK,\n\t\t\t\t\tFIELD_PREP(MT_ADIE_VRPI_SEL_CR_MASK, val));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval = FIELD_GET(MT_ADIE_PGA_GAIN_EFUSE_MASK, data);\n\t\tret = mt76_wmac_spi_rmw(dev, adie, MT_ADIE_RG_TOP_THADC,\n\t\t\t\t\tMT_ADIE_PGA_GAIN_MASK,\n\t\t\t\t\tFIELD_PREP(MT_ADIE_PGA_GAIN_MASK, val));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = mt7986_wmac_adie_efuse_read(dev, adie, MT_ADIE_THADC_SLOP,\n\t\t\t\t\t  &data);\n\tif (ret || FIELD_GET(MT_ADIE_ANA_EN_MASK, data)) {\n\t\tval = FIELD_GET(MT_ADIE_LDO_CTRL_EFUSE_MASK, data);\n\n\t\treturn mt76_wmac_spi_rmw(dev, adie, MT_ADIE_RG_TOP_THADC,\n\t\t\t\t\t MT_ADIE_LDO_CTRL_MASK,\n\t\t\t\t\t FIELD_PREP(MT_ADIE_LDO_CTRL_MASK, val));\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmt7986_read_efuse_xo_trim_7976(struct mt7915_dev *dev, u8 adie,\n\t\t\t       bool is_40m, int *result)\n{\n\tint ret;\n\tu32 data, addr;\n\n\taddr = is_40m ? MT_ADIE_XTAL_AXM_40M_OSC : MT_ADIE_XTAL_AXM_80M_OSC;\n\tret = mt7986_wmac_adie_efuse_read(dev, adie, addr, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!FIELD_GET(MT_ADIE_XO_TRIM_EN_MASK, data)) {\n\t\t*result = 64;\n\t} else {\n\t\t*result = FIELD_GET(MT_ADIE_TRIM_MASK, data);\n\t\taddr = is_40m ? MT_ADIE_XTAL_TRIM1_40M_OSC :\n\t\t\t\tMT_ADIE_XTAL_TRIM1_80M_OSC;\n\t\tret = mt7986_wmac_adie_efuse_read(dev, adie, addr, &data);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (FIELD_GET(MT_ADIE_XO_TRIM_EN_MASK, data) &&\n\t\t    FIELD_GET(MT_ADIE_XTAL_DECREASE_MASK, data))\n\t\t\t*result -= FIELD_GET(MT_ADIE_EFUSE_TRIM_MASK, data);\n\t\telse if (FIELD_GET(MT_ADIE_XO_TRIM_EN_MASK, data))\n\t\t\t*result += FIELD_GET(MT_ADIE_EFUSE_TRIM_MASK, data);\n\n\t\t*result = max(0, min(127, *result));\n\t}\n\n\treturn 0;\n}\n\nstatic int mt7986_wmac_adie_xtal_trim_7976(struct mt7915_dev *dev, u8 adie)\n{\n\tint ret, trim_80m, trim_40m;\n\tu32 data, val, mode;\n\n\tret = mt7986_wmac_adie_efuse_read(dev, adie, MT_ADIE_XO_TRIM_FLOW,\n\t\t\t\t\t  &data);\n\tif (ret || !FIELD_GET(BIT(1), data))\n\t\treturn 0;\n\n\tret = mt7986_read_efuse_xo_trim_7976(dev, adie, false, &trim_80m);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7986_read_efuse_xo_trim_7976(dev, adie, true, &trim_40m);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt76_wmac_spi_read(dev, adie, MT_ADIE_RG_STRAP_PIN_IN, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmode = FIELD_PREP(GENMASK(6, 4), val);\n\tif (!mode || mode == 0x2) {\n\t\tret = mt76_wmac_spi_rmw(dev, adie, MT_ADIE_XTAL_C1,\n\t\t\t\t\tGENMASK(31, 24),\n\t\t\t\t\tFIELD_PREP(GENMASK(31, 24), trim_80m));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = mt76_wmac_spi_rmw(dev, adie, MT_ADIE_XTAL_C2,\n\t\t\t\t\tGENMASK(31, 24),\n\t\t\t\t\tFIELD_PREP(GENMASK(31, 24), trim_80m));\n\t} else if (mode == 0x3 || mode == 0x4 || mode == 0x6) {\n\t\tret = mt76_wmac_spi_rmw(dev, adie, MT_ADIE_XTAL_C1,\n\t\t\t\t\tGENMASK(23, 16),\n\t\t\t\t\tFIELD_PREP(GENMASK(23, 16), trim_40m));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = mt76_wmac_spi_rmw(dev, adie, MT_ADIE_XTAL_C2,\n\t\t\t\t\tGENMASK(23, 16),\n\t\t\t\t\tFIELD_PREP(GENMASK(23, 16), trim_40m));\n\t}\n\n\treturn ret;\n}\n\nstatic int mt798x_wmac_adie_patch_7976(struct mt7915_dev *dev, u8 adie)\n{\n\tu32 id, version, rg_xo_01, rg_xo_03;\n\tint ret;\n\n\tret = mt76_wmac_spi_read(dev, adie, MT_ADIE_CHIP_ID, &id);\n\tif (ret)\n\t\treturn ret;\n\n\tversion = FIELD_GET(MT_ADIE_VERSION_MASK, id);\n\n\tret = mt76_wmac_spi_write(dev, adie, MT_ADIE_RG_TOP_THADC, 0x4a563b00);\n\tif (ret)\n\t\treturn ret;\n\n\tif (version == 0x8a00 || version == 0x8a10 || version == 0x8b00) {\n\t\trg_xo_01 = 0x1d59080f;\n\t\trg_xo_03 = 0x34c00fe0;\n\t} else {\n\t\tif (is_mt7981(&dev->mt76)) {\n\t\t\trg_xo_01 = 0x1959c80f;\n\t\t} else if (is_mt7986(&dev->mt76)) {\n\t\t\trg_xo_01 = 0x1959f80f;\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\trg_xo_03 = 0x34d00fe0;\n\t}\n\n\tret = mt76_wmac_spi_write(dev, adie, MT_ADIE_RG_XO_01, rg_xo_01);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mt76_wmac_spi_write(dev, adie, MT_ADIE_RG_XO_03, rg_xo_03);\n}\n\nstatic int\nmt7986_read_efuse_xo_trim_7975(struct mt7915_dev *dev, u8 adie,\n\t\t\t       u32 addr, u32 *result)\n{\n\tint ret;\n\tu32 data;\n\n\tret = mt7986_wmac_adie_efuse_read(dev, adie, addr, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((data & MT_ADIE_XO_TRIM_EN_MASK)) {\n\t\tif ((data & MT_ADIE_XTAL_DECREASE_MASK))\n\t\t\t*result -= (data & MT_ADIE_EFUSE_TRIM_MASK);\n\t\telse\n\t\t\t*result += (data & MT_ADIE_EFUSE_TRIM_MASK);\n\n\t\t*result = (*result & MT_ADIE_TRIM_MASK);\n\t}\n\n\treturn 0;\n}\n\nstatic int mt7986_wmac_adie_xtal_trim_7975(struct mt7915_dev *dev, u8 adie)\n{\n\tint ret;\n\tu32 data, result = 0, value;\n\n\tret = mt7986_wmac_adie_efuse_read(dev, adie, MT_ADIE_7975_XTAL_EN,\n\t\t\t\t\t  &data);\n\tif (ret || !(data & BIT(1)))\n\t\treturn 0;\n\n\tret = mt7986_wmac_adie_efuse_read(dev, adie, MT_ADIE_7975_XTAL_CAL,\n\t\t\t\t\t  &data);\n\tif (ret)\n\t\treturn ret;\n\n\tif (data & MT_ADIE_XO_TRIM_EN_MASK)\n\t\tresult = (data & MT_ADIE_TRIM_MASK);\n\n\tret = mt7986_read_efuse_xo_trim_7975(dev, adie, MT_ADIE_7975_XO_TRIM2,\n\t\t\t\t\t     &result);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7986_read_efuse_xo_trim_7975(dev, adie, MT_ADIE_7975_XO_TRIM3,\n\t\t\t\t\t     &result);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7986_read_efuse_xo_trim_7975(dev, adie, MT_ADIE_7975_XO_TRIM4,\n\t\t\t\t\t     &result);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tvalue = FIELD_GET(MT_ADIE_7975_XO_CTRL2_C1_MASK, result) |\n\t\tFIELD_GET(MT_ADIE_7975_XO_CTRL2_C2_MASK, result);\n\tret = mt76_wmac_spi_rmw(dev, adie, MT_ADIE_7975_XO_CTRL2,\n\t\t\t\tMT_ADIE_7975_XO_CTRL2_MASK, value);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt76_wmac_spi_read(dev, adie, MT_ADIE_7975_XTAL, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tif (value & MT_ADIE_7975_XTAL_EN_MASK) {\n\t\tret = mt76_wmac_spi_rmw(dev, adie, MT_ADIE_7975_XO_2,\n\t\t\t\t\tMT_ADIE_7975_XO_2_FIX_EN, 0x0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn mt76_wmac_spi_rmw(dev, adie, MT_ADIE_7975_XO_CTRL6,\n\t\t\t\t MT_ADIE_7975_XO_CTRL6_MASK, 0x1);\n}\n\nstatic int mt7986_wmac_adie_patch_7975(struct mt7915_dev *dev, u8 adie)\n{\n\tint ret;\n\n\t \n\tret = mt76_wmac_spi_write(dev, adie, 0x348, 0x00000002);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt76_wmac_spi_write(dev, adie, 0x378, 0x00000002);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt76_wmac_spi_write(dev, adie, 0x3a8, 0x00000002);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt76_wmac_spi_write(dev, adie, 0x3d8, 0x00000002);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mt76_wmac_spi_write(dev, adie, 0xa1c, 0x30000aaa);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mt76_wmac_spi_write(dev, adie, 0xa84, 0x8470008a);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (is_mt7981(&dev->mt76)) {\n\t\tret = mt76_wmac_spi_write(dev, adie, 0x074, 0x00000007);\n\t} else if (is_mt7986(&dev->mt76)) {\n\t\tret = mt76_wmac_spi_write(dev, adie, 0x074, 0x00000002);\n\t} else {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mt76_wmac_spi_write(dev, adie, 0xaa4, 0x01001fc0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mt76_wmac_spi_write(dev, adie, 0x070, 0x00000005);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mt76_wmac_spi_write(dev, adie, 0x344, 0x00000088);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt76_wmac_spi_write(dev, adie, 0x374, 0x00000088);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt76_wmac_spi_write(dev, adie, 0x3a4, 0x00000088);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt76_wmac_spi_write(dev, adie, 0x3d4, 0x00000088);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mt76_wmac_spi_write(dev, adie, 0xa80, 0x44d07000);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mt76_wmac_spi_write(dev, adie, 0xa88, 0x3900aaaa);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mt76_wmac_spi_write(dev, adie, 0x2c4, 0x00000000);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (is_mt7986(&dev->mt76))\n\t\treturn mt76_wmac_spi_write(dev, adie, 0x2c8, 0x00000072);\n\n\treturn ret;\n}\n\nstatic int mt7986_wmac_adie_cfg(struct mt7915_dev *dev, u8 adie, u32 adie_type)\n{\n\tint ret;\n\n\tmt76_wmac_spi_lock(dev);\n\tret = mt76_wmac_spi_write(dev, adie, MT_ADIE_CLK_EN, ~0);\n\tif (ret)\n\t\tgoto out;\n\n\tif (is_7975(dev, adie, adie_type)) {\n\t\tret = mt76_wmac_spi_rmw(dev, adie, MT_ADIE_7975_COCLK,\n\t\t\t\t\tBIT(1), 0x1);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = mt7986_wmac_adie_thermal_cal(dev, adie);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = mt7986_wmac_adie_xtal_trim_7975(dev, adie);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = mt7986_wmac_adie_patch_7975(dev, adie);\n\t} else if (is_7976(dev, adie, adie_type)) {\n\t\tif (mt798x_wmac_check_adie_type(dev) == ADIE_DBDC) {\n\t\t\tret = mt76_wmac_spi_write(dev, adie,\n\t\t\t\t\t\t  MT_ADIE_WRI_CK_SEL, 0x1c);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tret = mt7986_wmac_adie_thermal_cal(dev, adie);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = mt7986_wmac_adie_xtal_trim_7976(dev, adie);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = mt798x_wmac_adie_patch_7976(dev, adie);\n\t}\nout:\n\tmt76_wmac_spi_unlock(dev);\n\n\treturn ret;\n}\n\nstatic int\nmt7986_wmac_afe_cal(struct mt7915_dev *dev, u8 adie, bool dbdc, u32 adie_type)\n{\n\tint ret;\n\tu8 idx;\n\tu32 txcal;\n\n\tmt76_wmac_spi_lock(dev);\n\tif (is_7975(dev, adie, adie_type))\n\t\tret = mt76_wmac_spi_write(dev, adie,\n\t\t\t\t\t  MT_AFE_RG_ENCAL_WBTAC_IF_SW,\n\t\t\t\t\t  0x80000000);\n\telse\n\t\tret = mt76_wmac_spi_write(dev, adie,\n\t\t\t\t\t  MT_AFE_RG_ENCAL_WBTAC_IF_SW,\n\t\t\t\t\t  0x88888005);\n\tif (ret)\n\t\tgoto out;\n\n\tidx = dbdc ? ADIE_DBDC : adie;\n\n\tmt76_rmw_field(dev, MT_AFE_DIG_EN_01(idx),\n\t\t       MT_AFE_RG_WBG_EN_RCK_MASK, 0x1);\n\tusleep_range(60, 100);\n\n\tmt76_rmw(dev, MT_AFE_DIG_EN_01(idx),\n\t\t MT_AFE_RG_WBG_EN_RCK_MASK, 0x0);\n\n\tmt76_rmw_field(dev, MT_AFE_DIG_EN_03(idx),\n\t\t       MT_AFE_RG_WBG_EN_BPLL_UP_MASK, 0x1);\n\tusleep_range(30, 100);\n\n\tmt76_rmw_field(dev, MT_AFE_DIG_EN_03(idx),\n\t\t       MT_AFE_RG_WBG_EN_WPLL_UP_MASK, 0x1);\n\tusleep_range(60, 100);\n\n\ttxcal = (MT_AFE_RG_WBG_EN_TXCAL_BT |\n\t\t      MT_AFE_RG_WBG_EN_TXCAL_WF0 |\n\t\t      MT_AFE_RG_WBG_EN_TXCAL_WF1 |\n\t\t      MT_AFE_RG_WBG_EN_TXCAL_WF2 |\n\t\t      MT_AFE_RG_WBG_EN_TXCAL_WF3);\n\tif (is_mt7981(&dev->mt76))\n\t\ttxcal |= MT_AFE_RG_WBG_EN_TXCAL_WF4;\n\n\tmt76_set(dev, MT_AFE_DIG_EN_01(idx), txcal);\n\tusleep_range(800, 1000);\n\n\tmt76_clear(dev, MT_AFE_DIG_EN_01(idx), txcal);\n\tmt76_rmw(dev, MT_AFE_DIG_EN_03(idx),\n\t\t MT_AFE_RG_WBG_EN_PLL_UP_MASK, 0x0);\n\n\tret = mt76_wmac_spi_write(dev, adie, MT_AFE_RG_ENCAL_WBTAC_IF_SW,\n\t\t\t\t  0x5);\n\nout:\n\tmt76_wmac_spi_unlock(dev);\n\n\treturn ret;\n}\n\nstatic void mt7986_wmac_subsys_pll_initial(struct mt7915_dev *dev, u8 band)\n{\n\tmt76_rmw(dev, MT_AFE_PLL_STB_TIME(band),\n\t\t MT_AFE_PLL_STB_TIME_MASK, MT_AFE_PLL_STB_TIME_VAL);\n\n\tmt76_rmw(dev, MT_AFE_DIG_EN_02(band),\n\t\t MT_AFE_PLL_CFG_MASK, MT_AFE_PLL_CFG_VAL);\n\n\tmt76_rmw(dev, MT_AFE_DIG_TOP_01(band),\n\t\t MT_AFE_DIG_TOP_01_MASK, MT_AFE_DIG_TOP_01_VAL);\n}\n\nstatic void mt7986_wmac_subsys_setting(struct mt7915_dev *dev)\n{\n\t \n\tmt7986_wmac_subsys_pll_initial(dev, 0);\n\tmt7986_wmac_subsys_pll_initial(dev, 1);\n\n\t \n\tmt76_rmw(dev, MT_CONN_INFRA_OSC_RC_EN,\n\t\t MT_CONN_INFRA_OSC_RC_EN_MASK, 0x0);\n\tmt76_rmw(dev, MT_CONN_INFRA_OSC_CTRL,\n\t\t MT_CONN_INFRA_OSC_STB_TIME_MASK, 0x80706);\n\n\t \n\tmt76_rmw(dev, MT_TOP_WFSYS_PWR,\n\t\t MT_TOP_PWR_ACK_MASK | MT_TOP_PWR_KEY_MASK,\n\t\t MT_TOP_PWR_KEY);\n}\n\nstatic int mt7986_wmac_bus_timeout(struct mt7915_dev *dev)\n{\n\tmt76_rmw_field(dev, MT_INFRA_BUS_OFF_TIMEOUT,\n\t\t       MT_INFRA_BUS_TIMEOUT_LIMIT_MASK, 0x2);\n\n\tmt76_rmw_field(dev, MT_INFRA_BUS_OFF_TIMEOUT,\n\t\t       MT_INFRA_BUS_TIMEOUT_EN_MASK, 0xf);\n\n\tmt76_rmw_field(dev, MT_INFRA_BUS_ON_TIMEOUT,\n\t\t       MT_INFRA_BUS_TIMEOUT_LIMIT_MASK, 0xc);\n\n\tmt76_rmw_field(dev, MT_INFRA_BUS_ON_TIMEOUT,\n\t\t       MT_INFRA_BUS_TIMEOUT_EN_MASK, 0xf);\n\n\treturn mt798x_wmac_coninfra_check(dev);\n}\n\nstatic void mt7986_wmac_clock_enable(struct mt7915_dev *dev, u32 adie_type)\n{\n\tu32 cur;\n\n\tmt76_rmw_field(dev, MT_INFRA_CKGEN_BUS_WPLL_DIV_1,\n\t\t       MT_INFRA_CKGEN_DIV_SEL_MASK, 0x1);\n\n\tmt76_rmw_field(dev, MT_INFRA_CKGEN_BUS_WPLL_DIV_2,\n\t\t       MT_INFRA_CKGEN_DIV_SEL_MASK, 0x1);\n\n\tmt76_rmw_field(dev, MT_INFRA_CKGEN_BUS_WPLL_DIV_1,\n\t\t       MT_INFRA_CKGEN_DIV_EN_MASK, 0x1);\n\n\tmt76_rmw_field(dev, MT_INFRA_CKGEN_BUS_WPLL_DIV_2,\n\t\t       MT_INFRA_CKGEN_DIV_EN_MASK, 0x1);\n\n\tmt76_rmw_field(dev, MT_INFRA_CKGEN_RFSPI_WPLL_DIV,\n\t\t       MT_INFRA_CKGEN_DIV_SEL_MASK, 0x8);\n\n\tmt76_rmw_field(dev, MT_INFRA_CKGEN_RFSPI_WPLL_DIV,\n\t\t       MT_INFRA_CKGEN_DIV_EN_MASK, 0x1);\n\n\tmt76_rmw_field(dev, MT_INFRA_CKGEN_BUS,\n\t\t       MT_INFRA_CKGEN_BUS_CLK_SEL_MASK, 0x0);\n\n\tmt76_rmw_field(dev, MT_CONN_INFRA_HW_CTRL,\n\t\t       MT_CONN_INFRA_HW_CTRL_MASK, 0x1);\n\n\tmt76_rmw(dev, MT_TOP_CONN_INFRA_WAKEUP,\n\t\t MT_TOP_CONN_INFRA_WAKEUP_MASK, 0x1);\n\n\tusleep_range(900, 1000);\n\n\tmt76_wmac_spi_lock(dev);\n\tif (is_7975(dev, 0, adie_type) || is_7976(dev, 0, adie_type)) {\n\t\tmt76_rmw_field(dev, MT_ADIE_SLP_CTRL_CK0(0),\n\t\t\t       MT_SLP_CTRL_EN_MASK, 0x1);\n\n\t\tread_poll_timeout(mt76_rr, cur, !(cur & MT_SLP_CTRL_BSY_MASK),\n\t\t\t\t  USEC_PER_MSEC, 50 * USEC_PER_MSEC, false,\n\t\t\t\t  dev, MT_ADIE_SLP_CTRL_CK0(0));\n\t}\n\tif (is_7975(dev, 1, adie_type) || is_7976(dev, 1, adie_type)) {\n\t\tmt76_rmw_field(dev, MT_ADIE_SLP_CTRL_CK0(1),\n\t\t\t       MT_SLP_CTRL_EN_MASK, 0x1);\n\n\t\tread_poll_timeout(mt76_rr, cur, !(cur & MT_SLP_CTRL_BSY_MASK),\n\t\t\t\t  USEC_PER_MSEC, 50 * USEC_PER_MSEC, false,\n\t\t\t\t  dev, MT_ADIE_SLP_CTRL_CK0(0));\n\t}\n\tmt76_wmac_spi_unlock(dev);\n\n\tmt76_rmw(dev, MT_TOP_CONN_INFRA_WAKEUP,\n\t\t MT_TOP_CONN_INFRA_WAKEUP_MASK, 0x0);\n\tusleep_range(900, 1000);\n}\n\nstatic int mt7986_wmac_top_wfsys_wakeup(struct mt7915_dev *dev, bool enable)\n{\n\tmt76_rmw_field(dev, MT_TOP_WFSYS_WAKEUP,\n\t\t       MT_TOP_WFSYS_WAKEUP_MASK, enable);\n\n\tusleep_range(900, 1000);\n\n\tif (!enable)\n\t\treturn 0;\n\n\treturn mt798x_wmac_coninfra_check(dev);\n}\n\nstatic int mt7986_wmac_wm_enable(struct mt7915_dev *dev, bool enable)\n{\n\tu32 cur;\n\n\tif (is_mt7986(&dev->mt76))\n\t\tmt76_wr(dev, MT_CONNINFRA_SKU_DEC_ADDR, 0);\n\n\tmt76_rmw_field(dev, MT7986_TOP_WM_RESET,\n\t\t       MT7986_TOP_WM_RESET_MASK, enable);\n\tif (!enable)\n\t\treturn 0;\n\n\treturn read_poll_timeout(mt76_rr, cur, (cur == 0x1d1e),\n\t\t\t\t USEC_PER_MSEC, 5000 * USEC_PER_MSEC, false,\n\t\t\t\t dev, MT_TOP_CFG_ON_ROM_IDX);\n}\n\nstatic int mt7986_wmac_wfsys_poweron(struct mt7915_dev *dev, bool enable)\n{\n\tu32 mask = MT_TOP_PWR_EN_MASK | MT_TOP_PWR_KEY_MASK;\n\tu32 cur;\n\n\tmt76_rmw(dev, MT_TOP_WFSYS_PWR, mask,\n\t\t MT_TOP_PWR_KEY | FIELD_PREP(MT_TOP_PWR_EN_MASK, enable));\n\n\treturn read_poll_timeout(mt76_rr, cur,\n\t\t(FIELD_GET(MT_TOP_WFSYS_RESET_STATUS_MASK, cur) == enable),\n\t\tUSEC_PER_MSEC, 50 * USEC_PER_MSEC, false,\n\t\tdev, MT_TOP_WFSYS_RESET_STATUS);\n}\n\nstatic int mt7986_wmac_wfsys_setting(struct mt7915_dev *dev)\n{\n\tint ret;\n\tu32 cur;\n\n\t \n\tmt76_rmw(dev, MT_CONN_INFRA_WF_SLP_PROT,\n\t\t MT_CONN_INFRA_WF_SLP_PROT_MASK, 0x0);\n\n\tret = mt7986_wmac_wfsys_poweron(dev, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = read_poll_timeout(mt76_rr, cur,\n\t\t\t\t!(cur & MT_CONN_INFRA_CONN_WF_MASK),\n\t\t\t\tUSEC_PER_MSEC, 50 * USEC_PER_MSEC, false,\n\t\t\t\tdev, MT_CONN_INFRA_WF_SLP_PROT_RDY);\n\tif (ret)\n\t\treturn ret;\n\n\tret = read_poll_timeout(mt76_rr, cur, !(cur & MT_SLP_WFDMA2CONN_MASK),\n\t\t\t\tUSEC_PER_MSEC, 50 * USEC_PER_MSEC, false,\n\t\t\t\tdev, MT_SLP_STATUS);\n\tif (ret)\n\t\treturn ret;\n\n\treturn read_poll_timeout(mt76_rr, cur, (cur == 0x02060000),\n\t\t\t\t USEC_PER_MSEC, 50 * USEC_PER_MSEC, false,\n\t\t\t\t dev, MT_TOP_CFG_IP_VERSION_ADDR);\n}\n\nstatic void mt7986_wmac_wfsys_set_timeout(struct mt7915_dev *dev)\n{\n\tu32 mask = MT_MCU_BUS_TIMEOUT_SET_MASK |\n\t\t   MT_MCU_BUS_TIMEOUT_CG_EN_MASK |\n\t\t   MT_MCU_BUS_TIMEOUT_EN_MASK;\n\tu32 val = FIELD_PREP(MT_MCU_BUS_TIMEOUT_SET_MASK, 1) |\n\t\t  FIELD_PREP(MT_MCU_BUS_TIMEOUT_CG_EN_MASK, 1) |\n\t\t  FIELD_PREP(MT_MCU_BUS_TIMEOUT_EN_MASK, 1);\n\n\tmt76_rmw(dev, MT_MCU_BUS_TIMEOUT, mask, val);\n\n\tmt76_wr(dev, MT_MCU_BUS_REMAP, 0x810f0000);\n\n\tmask = MT_MCU_BUS_DBG_TIMEOUT_SET_MASK |\n\t       MT_MCU_BUS_DBG_TIMEOUT_CK_EN_MASK |\n\t       MT_MCU_BUS_DBG_TIMEOUT_EN_MASK;\n\tval = FIELD_PREP(MT_MCU_BUS_DBG_TIMEOUT_SET_MASK, 0x3aa) |\n\t      FIELD_PREP(MT_MCU_BUS_DBG_TIMEOUT_CK_EN_MASK, 1) |\n\t      FIELD_PREP(MT_MCU_BUS_DBG_TIMEOUT_EN_MASK, 1);\n\n\tmt76_rmw(dev, MT_MCU_BUS_DBG_TIMEOUT, mask, val);\n}\n\nstatic int mt7986_wmac_sku_update(struct mt7915_dev *dev, u32 adie_type)\n{\n\tu32 val;\n\n\tif (is_7976(dev, 0, adie_type) && is_7976(dev, 1, adie_type))\n\t\tval = 0xf;\n\telse if (is_7975(dev, 0, adie_type) && is_7975(dev, 1, adie_type))\n\t\tval = 0xd;\n\telse if (is_7976(dev, 0, adie_type))\n\t\tval = 0x7;\n\telse if (is_7975(dev, 1, adie_type))\n\t\tval = 0x8;\n\telse if (is_7976(dev, 1, adie_type))\n\t\tval = 0xa;\n\telse\n\t\treturn -EINVAL;\n\n\tmt76_wmac_rmw(dev->sku, MT_TOP_POS_SKU, MT_TOP_POS_SKU_MASK,\n\t\t      FIELD_PREP(MT_TOP_POS_SKU_MASK, val));\n\n\tmt76_wr(dev, MT_CONNINFRA_SKU_DEC_ADDR, val);\n\n\treturn 0;\n}\n\nstatic int\nmt7986_wmac_adie_setup(struct mt7915_dev *dev, u8 adie, u32 adie_type)\n{\n\tint ret;\n\n\tif (!(is_7975(dev, adie, adie_type) || is_7976(dev, adie, adie_type)))\n\t\treturn 0;\n\n\tret = mt7986_wmac_adie_cfg(dev, adie, adie_type);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7986_wmac_afe_cal(dev, adie, false, adie_type);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!adie && (mt798x_wmac_check_adie_type(dev) == ADIE_DBDC))\n\t\tret = mt7986_wmac_afe_cal(dev, adie, true, adie_type);\n\n\treturn ret;\n}\n\nstatic int mt7986_wmac_subsys_powerup(struct mt7915_dev *dev, u32 adie_type)\n{\n\tint ret;\n\n\tmt7986_wmac_subsys_setting(dev);\n\n\tret = mt7986_wmac_bus_timeout(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmt7986_wmac_clock_enable(dev, adie_type);\n\n\treturn 0;\n}\n\nstatic int mt7986_wmac_wfsys_powerup(struct mt7915_dev *dev)\n{\n\tint ret;\n\n\tret = mt7986_wmac_wm_enable(dev, false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7986_wmac_wfsys_setting(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmt7986_wmac_wfsys_set_timeout(dev);\n\n\treturn mt7986_wmac_wm_enable(dev, true);\n}\n\nint mt7986_wmac_enable(struct mt7915_dev *dev)\n{\n\tint ret;\n\tu32 adie_type;\n\n\tret = mt7986_wmac_consys_reset(dev, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7986_wmac_gpio_setup(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7986_wmac_consys_lockup(dev, false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt798x_wmac_coninfra_check(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt798x_wmac_coninfra_setup(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt798x_wmac_sku_setup(dev, &adie_type);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7986_wmac_adie_setup(dev, 0, adie_type);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (is_mt7986(&dev->mt76)) {\n\t\tret = mt7986_wmac_adie_setup(dev, 1, adie_type);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = mt7986_wmac_subsys_powerup(dev, adie_type);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7986_wmac_top_wfsys_wakeup(dev, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7986_wmac_wfsys_powerup(dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mt7986_wmac_sku_update(dev, adie_type);\n}\n\nvoid mt7986_wmac_disable(struct mt7915_dev *dev)\n{\n\tu32 cur;\n\n\tmt7986_wmac_top_wfsys_wakeup(dev, true);\n\n\t \n\tmt76_rmw_field(dev, MT_CONN_INFRA_WF_SLP_PROT,\n\t\t       MT_CONN_INFRA_WF_SLP_PROT_MASK, 0x1);\n\n\t \n\tread_poll_timeout(mt76_rr, cur, !(cur ^ MT_CONN_INFRA_CONN),\n\t\t\t  USEC_PER_MSEC, 50 * USEC_PER_MSEC, false,\n\t\t\t  dev, MT_CONN_INFRA_WF_SLP_PROT_RDY);\n\n\tmt7986_wmac_wfsys_poweron(dev, false);\n\n\t \n\tmt76_rmw_field(dev, MT_AFE_DIG_EN_02(0), MT_AFE_MCU_BPLL_CFG_MASK, 0x2);\n\tmt76_rmw_field(dev, MT_AFE_DIG_EN_02(0), MT_AFE_WPLL_CFG_MASK, 0x2);\n\n\t \n\tmt76_rmw_field(dev, MT_CONN_INFRA_EMI_REQ,\n\t\t       MT_CONN_INFRA_EMI_REQ_MASK, 0x1);\n\tmt76_rmw_field(dev, MT_CONN_INFRA_EMI_REQ,\n\t\t       MT_CONN_INFRA_EMI_REQ_MASK, 0x0);\n\tmt76_rmw_field(dev, MT_CONN_INFRA_EMI_REQ,\n\t\t       MT_CONN_INFRA_INFRA_REQ_MASK, 0x1);\n\tmt76_rmw_field(dev, MT_CONN_INFRA_EMI_REQ,\n\t\t       MT_CONN_INFRA_INFRA_REQ_MASK, 0x0);\n\n\tmt7986_wmac_top_wfsys_wakeup(dev, false);\n\tmt7986_wmac_consys_lockup(dev, true);\n\tmt7986_wmac_consys_reset(dev, false);\n}\n\nstatic int mt798x_wmac_init(struct mt7915_dev *dev)\n{\n\tstruct device *pdev = dev->mt76.dev;\n\tstruct platform_device *pfdev = to_platform_device(pdev);\n\tstruct clk *mcu_clk, *ap_conn_clk;\n\n\tmcu_clk = devm_clk_get(pdev, \"mcu\");\n\tif (IS_ERR(mcu_clk))\n\t\tdev_err(pdev, \"mcu clock not found\\n\");\n\telse if (clk_prepare_enable(mcu_clk))\n\t\tdev_err(pdev, \"mcu clock configuration failed\\n\");\n\n\tap_conn_clk = devm_clk_get(pdev, \"ap2conn\");\n\tif (IS_ERR(ap_conn_clk))\n\t\tdev_err(pdev, \"ap2conn clock not found\\n\");\n\telse if (clk_prepare_enable(ap_conn_clk))\n\t\tdev_err(pdev, \"ap2conn clock configuration failed\\n\");\n\n\tdev->dcm = devm_platform_ioremap_resource(pfdev, 1);\n\tif (IS_ERR(dev->dcm))\n\t\treturn PTR_ERR(dev->dcm);\n\n\tdev->sku = devm_platform_ioremap_resource(pfdev, 2);\n\tif (IS_ERR(dev->sku))\n\t\treturn PTR_ERR(dev->sku);\n\n\tdev->rstc = devm_reset_control_get(pdev, \"consys\");\n\tif (IS_ERR(dev->rstc))\n\t\treturn PTR_ERR(dev->rstc);\n\n\treturn 0;\n}\n\nstatic int mt798x_wmac_probe(struct platform_device *pdev)\n{\n\tvoid __iomem *mem_base;\n\tstruct mt7915_dev *dev;\n\tstruct mt76_dev *mdev;\n\tint irq, ret;\n\tu32 chip_id;\n\n\tchip_id = (uintptr_t)of_device_get_match_data(&pdev->dev);\n\n\tmem_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mem_base)) {\n\t\tdev_err(&pdev->dev, \"Failed to get memory resource\\n\");\n\t\treturn PTR_ERR(mem_base);\n\t}\n\n\tdev = mt7915_mmio_probe(&pdev->dev, mem_base, chip_id);\n\tif (IS_ERR(dev))\n\t\treturn PTR_ERR(dev);\n\n\tmdev = &dev->mt76;\n\tret = mt7915_mmio_wed_init(dev, pdev, false, &irq);\n\tif (ret < 0)\n\t\tgoto free_device;\n\n\tif (!ret) {\n\t\tirq = platform_get_irq(pdev, 0);\n\t\tif (irq < 0) {\n\t\t\tret = irq;\n\t\t\tgoto free_device;\n\t\t}\n\t}\n\n\tret = devm_request_irq(mdev->dev, irq, mt7915_irq_handler,\n\t\t\t       IRQF_SHARED, KBUILD_MODNAME, dev);\n\tif (ret)\n\t\tgoto free_device;\n\n\tret = mt798x_wmac_init(dev);\n\tif (ret)\n\t\tgoto free_irq;\n\n\tmt7915_wfsys_reset(dev);\n\n\tret = mt7915_register_device(dev);\n\tif (ret)\n\t\tgoto free_irq;\n\n\treturn 0;\n\nfree_irq:\n\tdevm_free_irq(mdev->dev, irq, dev);\nfree_device:\n\tif (mtk_wed_device_active(&mdev->mmio.wed))\n\t\tmtk_wed_device_detach(&mdev->mmio.wed);\n\tmt76_free_device(mdev);\n\n\treturn ret;\n}\n\nstatic int mt798x_wmac_remove(struct platform_device *pdev)\n{\n\tstruct mt7915_dev *dev = platform_get_drvdata(pdev);\n\n\tmt7915_unregister_device(dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mt798x_wmac_of_match[] = {\n\t{ .compatible = \"mediatek,mt7981-wmac\", .data = (u32 *)0x7981 },\n\t{ .compatible = \"mediatek,mt7986-wmac\", .data = (u32 *)0x7986 },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, mt798x_wmac_of_match);\n\nstruct platform_driver mt798x_wmac_driver = {\n\t.driver = {\n\t\t.name = \"mt798x-wmac\",\n\t\t.of_match_table = mt798x_wmac_of_match,\n\t},\n\t.probe = mt798x_wmac_probe,\n\t.remove = mt798x_wmac_remove,\n};\n\nMODULE_FIRMWARE(MT7986_FIRMWARE_WA);\nMODULE_FIRMWARE(MT7986_FIRMWARE_WM);\nMODULE_FIRMWARE(MT7986_FIRMWARE_WM_MT7975);\nMODULE_FIRMWARE(MT7986_ROM_PATCH);\nMODULE_FIRMWARE(MT7986_ROM_PATCH_MT7975);\n\nMODULE_FIRMWARE(MT7981_FIRMWARE_WA);\nMODULE_FIRMWARE(MT7981_FIRMWARE_WM);\nMODULE_FIRMWARE(MT7981_ROM_PATCH);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}