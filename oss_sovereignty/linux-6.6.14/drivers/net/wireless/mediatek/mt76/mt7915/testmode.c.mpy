{
  "module_name": "testmode.c",
  "hash_id": "50652bee7ad9861f25cab6a0aa70ceedf88ed32223e411eb0478c6300fc3b0d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7915/testmode.c",
  "human_readable_source": "\n \n\n#include \"mt7915.h\"\n#include \"mac.h\"\n#include \"mcu.h\"\n#include \"testmode.h\"\n\nenum {\n\tTM_CHANGED_TXPOWER,\n\tTM_CHANGED_FREQ_OFFSET,\n\n\t \n\tNUM_TM_CHANGED\n};\n\nstatic const u8 tm_change_map[] = {\n\t[TM_CHANGED_TXPOWER] = MT76_TM_ATTR_TX_POWER,\n\t[TM_CHANGED_FREQ_OFFSET] = MT76_TM_ATTR_FREQ_OFFSET,\n};\n\nstruct reg_band {\n\tu32 band[2];\n};\n\n#define REG_BAND(_list, _reg) \\\n\t\t{ _list.band[0] = MT_##_reg(0);\t\\\n\t\t  _list.band[1] = MT_##_reg(1); }\n#define REG_BAND_IDX(_list, _reg, _idx) \\\n\t\t{ _list.band[0] = MT_##_reg(0, _idx);\t\\\n\t\t  _list.band[1] = MT_##_reg(1, _idx); }\n\n#define TM_REG_MAX_ID\t17\nstatic struct reg_band reg_backup_list[TM_REG_MAX_ID];\n\n\nstatic int\nmt7915_tm_set_tx_power(struct mt7915_phy *phy)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct mt76_phy *mphy = phy->mt76;\n\tstruct cfg80211_chan_def *chandef = &mphy->chandef;\n\tint freq = chandef->center_freq1;\n\tint ret;\n\tstruct {\n\t\tu8 format_id;\n\t\tu8 band_idx;\n\t\ts8 tx_power;\n\t\tu8 ant_idx;\t \n\t\tu8 center_chan;\n\t\tu8 rsv[3];\n\t} __packed req = {\n\t\t.format_id = 0xf,\n\t\t.band_idx = phy->mt76->band_idx,\n\t\t.center_chan = ieee80211_frequency_to_channel(freq),\n\t};\n\tu8 *tx_power = NULL;\n\n\tif (phy->mt76->test.state != MT76_TM_STATE_OFF)\n\t\ttx_power = phy->mt76->test.tx_power;\n\n\t \n\tif (tx_power && tx_power[0])\n\t\treq.tx_power = tx_power[0];\n\n\tret = mt76_mcu_send_msg(&dev->mt76,\n\t\t\t\tMCU_EXT_CMD(TX_POWER_FEATURE_CTRL),\n\t\t\t\t&req, sizeof(req), false);\n\n\treturn ret;\n}\n\nstatic int\nmt7915_tm_set_freq_offset(struct mt7915_phy *phy, bool en, u32 val)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct mt7915_tm_cmd req = {\n\t\t.testmode_en = en,\n\t\t.param_idx = MCU_ATE_SET_FREQ_OFFSET,\n\t\t.param.freq.band = phy->mt76->band_idx,\n\t\t.param.freq.freq_offset = cpu_to_le32(val),\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(ATE_CTRL), &req,\n\t\t\t\t sizeof(req), false);\n}\n\nstatic int\nmt7915_tm_mode_ctrl(struct mt7915_dev *dev, bool enable)\n{\n\tstruct {\n\t\tu8 format_id;\n\t\tbool enable;\n\t\tu8 rsv[2];\n\t} __packed req = {\n\t\t.format_id = 0x6,\n\t\t.enable = enable,\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76,\n\t\t\t\t MCU_EXT_CMD(TX_POWER_FEATURE_CTRL),\n\t\t\t\t &req, sizeof(req), false);\n}\n\nstatic int\nmt7915_tm_set_trx(struct mt7915_phy *phy, int type, bool en)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct mt7915_tm_cmd req = {\n\t\t.testmode_en = 1,\n\t\t.param_idx = MCU_ATE_SET_TRX,\n\t\t.param.trx.type = type,\n\t\t.param.trx.enable = en,\n\t\t.param.trx.band = phy->mt76->band_idx,\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(ATE_CTRL), &req,\n\t\t\t\t sizeof(req), false);\n}\n\nstatic int\nmt7915_tm_clean_hwq(struct mt7915_phy *phy, u8 wcid)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct mt7915_tm_cmd req = {\n\t\t.testmode_en = 1,\n\t\t.param_idx = MCU_ATE_CLEAN_TXQUEUE,\n\t\t.param.clean.wcid = wcid,\n\t\t.param.clean.band = phy->mt76->band_idx,\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(ATE_CTRL), &req,\n\t\t\t\t sizeof(req), false);\n}\n\nstatic int\nmt7915_tm_set_slot_time(struct mt7915_phy *phy, u8 slot_time, u8 sifs)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct mt7915_tm_cmd req = {\n\t\t.testmode_en = !(phy->mt76->test.state == MT76_TM_STATE_OFF),\n\t\t.param_idx = MCU_ATE_SET_SLOT_TIME,\n\t\t.param.slot.slot_time = slot_time,\n\t\t.param.slot.sifs = sifs,\n\t\t.param.slot.rifs = 2,\n\t\t.param.slot.eifs = cpu_to_le16(60),\n\t\t.param.slot.band = phy->mt76->band_idx,\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(ATE_CTRL), &req,\n\t\t\t\t sizeof(req), false);\n}\n\nstatic int\nmt7915_tm_set_tam_arb(struct mt7915_phy *phy, bool enable, bool mu)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tu32 op_mode;\n\n\tif (!enable)\n\t\top_mode = TAM_ARB_OP_MODE_NORMAL;\n\telse if (mu)\n\t\top_mode = TAM_ARB_OP_MODE_TEST;\n\telse\n\t\top_mode = TAM_ARB_OP_MODE_FORCE_SU;\n\n\treturn mt7915_mcu_set_muru_ctrl(dev, MURU_SET_ARB_OP_MODE, op_mode);\n}\n\nstatic int\nmt7915_tm_set_wmm_qid(struct mt7915_phy *phy, u8 qid, u8 aifs, u8 cw_min,\n\t\t      u16 cw_max, u16 txop)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)phy->monitor_vif->drv_priv;\n\tstruct mt7915_mcu_tx req = { .total = 1 };\n\tstruct edca *e = &req.edca[0];\n\n\te->queue = qid + mvif->mt76.wmm_idx * MT76_CONNAC_MAX_WMM_SETS;\n\te->set = WMM_PARAM_SET;\n\n\te->aifs = aifs;\n\te->cw_min = cw_min;\n\te->cw_max = cpu_to_le16(cw_max);\n\te->txop = cpu_to_le16(txop);\n\n\treturn mt7915_mcu_update_edca(phy->dev, &req);\n}\n\nstatic int\nmt7915_tm_set_ipg_params(struct mt7915_phy *phy, u32 ipg, u8 mode)\n{\n#define TM_DEFAULT_SIFS\t10\n#define TM_MAX_SIFS\t127\n#define TM_MAX_AIFSN\t0xf\n#define TM_MIN_AIFSN\t0x1\n#define BBP_PROC_TIME\t1500\n\tstruct mt7915_dev *dev = phy->dev;\n\tu8 sig_ext = (mode == MT76_TM_TX_MODE_CCK) ? 0 : 6;\n\tu8 slot_time = 9, sifs = TM_DEFAULT_SIFS;\n\tu8 aifsn = TM_MIN_AIFSN;\n\tu8 band = phy->mt76->band_idx;\n\tu32 i2t_time, tr2t_time, txv_time;\n\tu16 cw = 0;\n\n\tif (ipg < sig_ext + slot_time + sifs)\n\t\tipg = 0;\n\n\tif (!ipg)\n\t\tgoto done;\n\n\tipg -= sig_ext;\n\n\tif (ipg <= (TM_MAX_SIFS + slot_time)) {\n\t\tsifs = ipg - slot_time;\n\t} else {\n\t\tu32 val = (ipg + slot_time) / slot_time;\n\n\t\twhile (val >>= 1)\n\t\t\tcw++;\n\n\t\tif (cw > 16)\n\t\t\tcw = 16;\n\n\t\tipg -= ((1 << cw) - 1) * slot_time;\n\n\t\taifsn = ipg / slot_time;\n\t\tif (aifsn > TM_MAX_AIFSN)\n\t\t\taifsn = TM_MAX_AIFSN;\n\n\t\tipg -= aifsn * slot_time;\n\n\t\tif (ipg > TM_DEFAULT_SIFS)\n\t\t\tsifs = min_t(u32, ipg, TM_MAX_SIFS);\n\t}\ndone:\n\ttxv_time = mt76_get_field(dev, MT_TMAC_ATCR(band),\n\t\t\t\t  MT_TMAC_ATCR_TXV_TOUT);\n\ttxv_time *= 50;\t \n\n\ti2t_time = (slot_time * 1000 - txv_time - BBP_PROC_TIME) / 50;\n\ttr2t_time = (sifs * 1000 - txv_time - BBP_PROC_TIME) / 50;\n\n\tmt76_set(dev, MT_TMAC_TRCR0(band),\n\t\t FIELD_PREP(MT_TMAC_TRCR0_TR2T_CHK, tr2t_time) |\n\t\t FIELD_PREP(MT_TMAC_TRCR0_I2T_CHK, i2t_time));\n\n\tmt7915_tm_set_slot_time(phy, slot_time, sifs);\n\n\treturn mt7915_tm_set_wmm_qid(phy,\n\t\t\t\t     mt76_connac_lmac_mapping(IEEE80211_AC_BE),\n\t\t\t\t     aifsn, cw, cw, 0);\n}\n\nstatic int\nmt7915_tm_set_tx_len(struct mt7915_phy *phy, u32 tx_time)\n{\n\tstruct mt76_phy *mphy = phy->mt76;\n\tstruct mt76_testmode_data *td = &mphy->test;\n\tstruct ieee80211_supported_band *sband;\n\tstruct rate_info rate = {};\n\tu16 flags = 0, tx_len;\n\tu32 bitrate;\n\tint ret;\n\n\tif (!tx_time)\n\t\treturn 0;\n\n\trate.mcs = td->tx_rate_idx;\n\trate.nss = td->tx_rate_nss;\n\n\tswitch (td->tx_rate_mode) {\n\tcase MT76_TM_TX_MODE_CCK:\n\tcase MT76_TM_TX_MODE_OFDM:\n\t\tif (mphy->chandef.chan->band == NL80211_BAND_5GHZ)\n\t\t\tsband = &mphy->sband_5g.sband;\n\t\telse if (mphy->chandef.chan->band == NL80211_BAND_6GHZ)\n\t\t\tsband = &mphy->sband_6g.sband;\n\t\telse\n\t\t\tsband = &mphy->sband_2g.sband;\n\n\t\trate.legacy = sband->bitrates[rate.mcs].bitrate;\n\t\tbreak;\n\tcase MT76_TM_TX_MODE_HT:\n\t\trate.mcs += rate.nss * 8;\n\t\tflags |= RATE_INFO_FLAGS_MCS;\n\n\t\tif (td->tx_rate_sgi)\n\t\t\tflags |= RATE_INFO_FLAGS_SHORT_GI;\n\t\tbreak;\n\tcase MT76_TM_TX_MODE_VHT:\n\t\tflags |= RATE_INFO_FLAGS_VHT_MCS;\n\n\t\tif (td->tx_rate_sgi)\n\t\t\tflags |= RATE_INFO_FLAGS_SHORT_GI;\n\t\tbreak;\n\tcase MT76_TM_TX_MODE_HE_SU:\n\tcase MT76_TM_TX_MODE_HE_EXT_SU:\n\tcase MT76_TM_TX_MODE_HE_TB:\n\tcase MT76_TM_TX_MODE_HE_MU:\n\t\trate.he_gi = td->tx_rate_sgi;\n\t\tflags |= RATE_INFO_FLAGS_HE_MCS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\trate.flags = flags;\n\n\tswitch (mphy->chandef.width) {\n\tcase NL80211_CHAN_WIDTH_160:\n\tcase NL80211_CHAN_WIDTH_80P80:\n\t\trate.bw = RATE_INFO_BW_160;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\trate.bw = RATE_INFO_BW_80;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\trate.bw = RATE_INFO_BW_40;\n\t\tbreak;\n\tdefault:\n\t\trate.bw = RATE_INFO_BW_20;\n\t\tbreak;\n\t}\n\n\tbitrate = cfg80211_calculate_bitrate(&rate);\n\ttx_len = bitrate * tx_time / 10 / 8;\n\n\tret = mt76_testmode_alloc_skb(phy->mt76, tx_len);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void\nmt7915_tm_reg_backup_restore(struct mt7915_phy *phy)\n{\n\tint n_regs = ARRAY_SIZE(reg_backup_list);\n\tstruct mt7915_dev *dev = phy->dev;\n\tu32 *b = phy->test.reg_backup;\n\tu8 band = phy->mt76->band_idx;\n\tint i;\n\n\tREG_BAND_IDX(reg_backup_list[0], AGG_PCR0, 0);\n\tREG_BAND_IDX(reg_backup_list[1], AGG_PCR0, 1);\n\tREG_BAND_IDX(reg_backup_list[2], AGG_AWSCR0, 0);\n\tREG_BAND_IDX(reg_backup_list[3], AGG_AWSCR0, 1);\n\tREG_BAND_IDX(reg_backup_list[4], AGG_AWSCR0, 2);\n\tREG_BAND_IDX(reg_backup_list[5], AGG_AWSCR0, 3);\n\tREG_BAND(reg_backup_list[6], AGG_MRCR);\n\tREG_BAND(reg_backup_list[7], TMAC_TFCR0);\n\tREG_BAND(reg_backup_list[8], TMAC_TCR0);\n\tREG_BAND(reg_backup_list[9], AGG_ATCR1);\n\tREG_BAND(reg_backup_list[10], AGG_ATCR3);\n\tREG_BAND(reg_backup_list[11], TMAC_TRCR0);\n\tREG_BAND(reg_backup_list[12], TMAC_ICR0);\n\tREG_BAND_IDX(reg_backup_list[13], ARB_DRNGR0, 0);\n\tREG_BAND_IDX(reg_backup_list[14], ARB_DRNGR0, 1);\n\tREG_BAND(reg_backup_list[15], WF_RFCR);\n\tREG_BAND(reg_backup_list[16], WF_RFCR1);\n\n\tif (phy->mt76->test.state == MT76_TM_STATE_OFF) {\n\t\tfor (i = 0; i < n_regs; i++)\n\t\t\tmt76_wr(dev, reg_backup_list[i].band[band], b[i]);\n\t\treturn;\n\t}\n\n\tif (!b) {\n\t\tb = devm_kzalloc(dev->mt76.dev, 4 * n_regs, GFP_KERNEL);\n\t\tif (!b)\n\t\t\treturn;\n\n\t\tphy->test.reg_backup = b;\n\t\tfor (i = 0; i < n_regs; i++)\n\t\t\tb[i] = mt76_rr(dev, reg_backup_list[i].band[band]);\n\t}\n\n\tmt76_clear(dev, MT_AGG_PCR0(band, 0), MT_AGG_PCR0_MM_PROT |\n\t\t   MT_AGG_PCR0_GF_PROT | MT_AGG_PCR0_ERP_PROT |\n\t\t   MT_AGG_PCR0_VHT_PROT | MT_AGG_PCR0_BW20_PROT |\n\t\t   MT_AGG_PCR0_BW40_PROT | MT_AGG_PCR0_BW80_PROT);\n\tmt76_set(dev, MT_AGG_PCR0(band, 0), MT_AGG_PCR0_PTA_WIN_DIS);\n\n\tmt76_wr(dev, MT_AGG_PCR0(band, 1), MT_AGG_PCR1_RTS0_NUM_THRES |\n\t\tMT_AGG_PCR1_RTS0_LEN_THRES);\n\n\tmt76_clear(dev, MT_AGG_MRCR(band), MT_AGG_MRCR_BAR_CNT_LIMIT |\n\t\t   MT_AGG_MRCR_LAST_RTS_CTS_RN | MT_AGG_MRCR_RTS_FAIL_LIMIT |\n\t\t   MT_AGG_MRCR_TXCMD_RTS_FAIL_LIMIT);\n\n\tmt76_rmw(dev, MT_AGG_MRCR(band), MT_AGG_MRCR_RTS_FAIL_LIMIT |\n\t\t MT_AGG_MRCR_TXCMD_RTS_FAIL_LIMIT,\n\t\t FIELD_PREP(MT_AGG_MRCR_RTS_FAIL_LIMIT, 1) |\n\t\t FIELD_PREP(MT_AGG_MRCR_TXCMD_RTS_FAIL_LIMIT, 1));\n\n\tmt76_wr(dev, MT_TMAC_TFCR0(band), 0);\n\tmt76_clear(dev, MT_TMAC_TCR0(band), MT_TMAC_TCR0_TBTT_STOP_CTRL);\n\n\t \n\tmt76_wr(dev, MT_WF_RFCR(band), 0xcf70a);\n\tmt76_wr(dev, MT_WF_RFCR1(band), 0);\n}\n\nstatic void\nmt7915_tm_init(struct mt7915_phy *phy, bool en)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\n\tif (!test_bit(MT76_STATE_RUNNING, &phy->mt76->state))\n\t\treturn;\n\n\tmt7915_mcu_set_sku_en(phy, !en);\n\n\tmt7915_tm_mode_ctrl(dev, en);\n\tmt7915_tm_reg_backup_restore(phy);\n\tmt7915_tm_set_trx(phy, TM_MAC_TXRX, !en);\n\n\tmt7915_mcu_add_bss_info(phy, phy->monitor_vif, en);\n\tmt7915_mcu_add_sta(dev, phy->monitor_vif, NULL, en);\n\n\tif (!en)\n\t\tmt7915_tm_set_tam_arb(phy, en, 0);\n}\n\nstatic void\nmt7915_tm_update_channel(struct mt7915_phy *phy)\n{\n\tmutex_unlock(&phy->dev->mt76.mutex);\n\tmt7915_set_channel(phy);\n\tmutex_lock(&phy->dev->mt76.mutex);\n\n\tmt7915_mcu_set_chan_info(phy, MCU_EXT_CMD(SET_RX_PATH));\n}\n\nstatic void\nmt7915_tm_set_tx_frames(struct mt7915_phy *phy, bool en)\n{\n\tstruct mt76_testmode_data *td = &phy->mt76->test;\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct ieee80211_tx_info *info;\n\tu8 duty_cycle = td->tx_duty_cycle;\n\tu32 tx_time = td->tx_time;\n\tu32 ipg = td->tx_ipg;\n\n\tmt7915_tm_set_trx(phy, TM_MAC_RX_RXV, false);\n\tmt7915_tm_clean_hwq(phy, dev->mt76.global_wcid.idx);\n\n\tif (en) {\n\t\tmt7915_tm_update_channel(phy);\n\n\t\tif (td->tx_spe_idx)\n\t\t\tphy->test.spe_idx = td->tx_spe_idx;\n\t\telse\n\t\t\tphy->test.spe_idx = mt76_connac_spe_idx(td->tx_antenna_mask);\n\t}\n\n\tmt7915_tm_set_tam_arb(phy, en,\n\t\t\t      td->tx_rate_mode == MT76_TM_TX_MODE_HE_MU);\n\n\t \n\tif (duty_cycle && tx_time && !ipg) {\n\t\tipg = tx_time * 100 / duty_cycle - tx_time;\n\t} else if (duty_cycle && !tx_time && ipg) {\n\t\tif (duty_cycle < 100)\n\t\t\ttx_time = duty_cycle * ipg / (100 - duty_cycle);\n\t}\n\n\tmt7915_tm_set_ipg_params(phy, ipg, td->tx_rate_mode);\n\tmt7915_tm_set_tx_len(phy, tx_time);\n\n\tif (ipg)\n\t\ttd->tx_queued_limit = MT76_TM_TIMEOUT * 1000000 / ipg / 2;\n\n\tif (!en || !td->tx_skb)\n\t\treturn;\n\n\tinfo = IEEE80211_SKB_CB(td->tx_skb);\n\tinfo->control.vif = phy->monitor_vif;\n\n\tmt7915_tm_set_trx(phy, TM_MAC_TX, en);\n}\n\nstatic void\nmt7915_tm_set_rx_frames(struct mt7915_phy *phy, bool en)\n{\n\tmt7915_tm_set_trx(phy, TM_MAC_RX_RXV, false);\n\n\tif (en) {\n\t\tstruct mt7915_dev *dev = phy->dev;\n\n\t\tmt7915_tm_update_channel(phy);\n\n\t\t \n\t\tmt76_rr(dev, MT_MIB_SDR3(phy->mt76->band_idx));\n\t\tmt7915_tm_set_trx(phy, TM_MAC_RX_RXV, en);\n\t}\n}\n\nstatic int\nmt7915_tm_rf_switch_mode(struct mt7915_dev *dev, u32 oper)\n{\n\tstruct mt7915_tm_rf_test req = {\n\t\t.op.op_mode = cpu_to_le32(oper),\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(RF_TEST), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nstatic int\nmt7915_tm_set_tx_cont(struct mt7915_phy *phy, bool en)\n{\n#define TX_CONT_START\t0x05\n#define TX_CONT_STOP\t0x06\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct cfg80211_chan_def *chandef = &phy->mt76->chandef;\n\tint freq1 = ieee80211_frequency_to_channel(chandef->center_freq1);\n\tstruct mt76_testmode_data *td = &phy->mt76->test;\n\tu32 func_idx = en ? TX_CONT_START : TX_CONT_STOP;\n\tu8 rate_idx = td->tx_rate_idx, mode;\n\tu8 band = phy->mt76->band_idx;\n\tu16 rateval;\n\tstruct mt7915_tm_rf_test req = {\n\t\t.action = 1,\n\t\t.icap_len = 120,\n\t\t.op.rf.func_idx = cpu_to_le32(func_idx),\n\t};\n\tstruct tm_tx_cont *tx_cont = &req.op.rf.param.tx_cont;\n\n\ttx_cont->control_ch = chandef->chan->hw_value;\n\ttx_cont->center_ch = freq1;\n\ttx_cont->tx_ant = td->tx_antenna_mask;\n\ttx_cont->band = band;\n\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_40:\n\t\ttx_cont->bw = CMD_CBW_40MHZ;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\ttx_cont->bw = CMD_CBW_80MHZ;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80P80:\n\t\ttx_cont->bw = CMD_CBW_8080MHZ;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_160:\n\t\ttx_cont->bw = CMD_CBW_160MHZ;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_5:\n\t\ttx_cont->bw = CMD_CBW_5MHZ;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_10:\n\t\ttx_cont->bw = CMD_CBW_10MHZ;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_20:\n\t\ttx_cont->bw = CMD_CBW_20MHZ;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\ttx_cont->bw = CMD_CBW_20MHZ;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!en) {\n\t\treq.op.rf.param.func_data = cpu_to_le32(band);\n\t\tgoto out;\n\t}\n\n\tif (td->tx_rate_mode <= MT76_TM_TX_MODE_OFDM) {\n\t\tstruct ieee80211_supported_band *sband;\n\t\tu8 idx = rate_idx;\n\n\t\tif (chandef->chan->band == NL80211_BAND_5GHZ)\n\t\t\tsband = &phy->mt76->sband_5g.sband;\n\t\telse if (chandef->chan->band == NL80211_BAND_6GHZ)\n\t\t\tsband = &phy->mt76->sband_6g.sband;\n\t\telse\n\t\t\tsband = &phy->mt76->sband_2g.sband;\n\n\t\tif (td->tx_rate_mode == MT76_TM_TX_MODE_OFDM)\n\t\t\tidx += 4;\n\t\trate_idx = sband->bitrates[idx].hw_value & 0xff;\n\t}\n\n\tswitch (td->tx_rate_mode) {\n\tcase MT76_TM_TX_MODE_CCK:\n\t\tmode = MT_PHY_TYPE_CCK;\n\t\tbreak;\n\tcase MT76_TM_TX_MODE_OFDM:\n\t\tmode = MT_PHY_TYPE_OFDM;\n\t\tbreak;\n\tcase MT76_TM_TX_MODE_HT:\n\t\tmode = MT_PHY_TYPE_HT;\n\t\tbreak;\n\tcase MT76_TM_TX_MODE_VHT:\n\t\tmode = MT_PHY_TYPE_VHT;\n\t\tbreak;\n\tcase MT76_TM_TX_MODE_HE_SU:\n\t\tmode = MT_PHY_TYPE_HE_SU;\n\t\tbreak;\n\tcase MT76_TM_TX_MODE_HE_EXT_SU:\n\t\tmode = MT_PHY_TYPE_HE_EXT_SU;\n\t\tbreak;\n\tcase MT76_TM_TX_MODE_HE_TB:\n\t\tmode = MT_PHY_TYPE_HE_TB;\n\t\tbreak;\n\tcase MT76_TM_TX_MODE_HE_MU:\n\t\tmode = MT_PHY_TYPE_HE_MU;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\trateval =  mode << 6 | rate_idx;\n\ttx_cont->rateval = cpu_to_le16(rateval);\n\nout:\n\tif (!en) {\n\t\tint ret;\n\n\t\tret = mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(RF_TEST), &req,\n\t\t\t\t\tsizeof(req), true);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn mt7915_tm_rf_switch_mode(dev, RF_OPER_NORMAL);\n\t}\n\n\tmt7915_tm_rf_switch_mode(dev, RF_OPER_RF_TEST);\n\tmt7915_tm_update_channel(phy);\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(RF_TEST), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nstatic void\nmt7915_tm_update_params(struct mt7915_phy *phy, u32 changed)\n{\n\tstruct mt76_testmode_data *td = &phy->mt76->test;\n\tbool en = phy->mt76->test.state != MT76_TM_STATE_OFF;\n\n\tif (changed & BIT(TM_CHANGED_FREQ_OFFSET))\n\t\tmt7915_tm_set_freq_offset(phy, en, en ? td->freq_offset : 0);\n\tif (changed & BIT(TM_CHANGED_TXPOWER))\n\t\tmt7915_tm_set_tx_power(phy);\n}\n\nstatic int\nmt7915_tm_set_state(struct mt76_phy *mphy, enum mt76_testmode_state state)\n{\n\tstruct mt76_testmode_data *td = &mphy->test;\n\tstruct mt7915_phy *phy = mphy->priv;\n\tenum mt76_testmode_state prev_state = td->state;\n\n\tmphy->test.state = state;\n\n\tif (prev_state == MT76_TM_STATE_TX_FRAMES ||\n\t    state == MT76_TM_STATE_TX_FRAMES)\n\t\tmt7915_tm_set_tx_frames(phy, state == MT76_TM_STATE_TX_FRAMES);\n\telse if (prev_state == MT76_TM_STATE_RX_FRAMES ||\n\t\t state == MT76_TM_STATE_RX_FRAMES)\n\t\tmt7915_tm_set_rx_frames(phy, state == MT76_TM_STATE_RX_FRAMES);\n\telse if (prev_state == MT76_TM_STATE_TX_CONT ||\n\t\t state == MT76_TM_STATE_TX_CONT)\n\t\tmt7915_tm_set_tx_cont(phy, state == MT76_TM_STATE_TX_CONT);\n\telse if (prev_state == MT76_TM_STATE_OFF ||\n\t\t state == MT76_TM_STATE_OFF)\n\t\tmt7915_tm_init(phy, !(state == MT76_TM_STATE_OFF));\n\n\tif ((state == MT76_TM_STATE_IDLE &&\n\t     prev_state == MT76_TM_STATE_OFF) ||\n\t    (state == MT76_TM_STATE_OFF &&\n\t     prev_state == MT76_TM_STATE_IDLE)) {\n\t\tu32 changed = 0;\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(tm_change_map); i++) {\n\t\t\tu16 cur = tm_change_map[i];\n\n\t\t\tif (td->param_set[cur / 32] & BIT(cur % 32))\n\t\t\t\tchanged |= BIT(i);\n\t\t}\n\n\t\tmt7915_tm_update_params(phy, changed);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmt7915_tm_set_params(struct mt76_phy *mphy, struct nlattr **tb,\n\t\t     enum mt76_testmode_state new_state)\n{\n\tstruct mt76_testmode_data *td = &mphy->test;\n\tstruct mt7915_phy *phy = mphy->priv;\n\tstruct mt7915_dev *dev = phy->dev;\n\tu32 chainmask = mphy->chainmask, changed = 0;\n\tbool ext_phy = phy != &dev->phy;\n\tint i;\n\n\tBUILD_BUG_ON(NUM_TM_CHANGED >= 32);\n\n\tif (new_state == MT76_TM_STATE_OFF ||\n\t    td->state == MT76_TM_STATE_OFF)\n\t\treturn 0;\n\n\tchainmask = ext_phy ? chainmask >> dev->chainshift : chainmask;\n\tif (td->tx_antenna_mask > chainmask)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(tm_change_map); i++) {\n\t\tif (tb[tm_change_map[i]])\n\t\t\tchanged |= BIT(i);\n\t}\n\n\tmt7915_tm_update_params(phy, changed);\n\n\treturn 0;\n}\n\nstatic int\nmt7915_tm_dump_stats(struct mt76_phy *mphy, struct sk_buff *msg)\n{\n\tstruct mt7915_phy *phy = mphy->priv;\n\tstruct mt7915_dev *dev = phy->dev;\n\tenum mt76_rxq_id q;\n\tvoid *rx, *rssi;\n\tu16 fcs_err;\n\tint i;\n\tu32 cnt;\n\n\trx = nla_nest_start(msg, MT76_TM_STATS_ATTR_LAST_RX);\n\tif (!rx)\n\t\treturn -ENOMEM;\n\n\tif (nla_put_s32(msg, MT76_TM_RX_ATTR_FREQ_OFFSET, phy->test.last_freq_offset))\n\t\treturn -ENOMEM;\n\n\trssi = nla_nest_start(msg, MT76_TM_RX_ATTR_RCPI);\n\tif (!rssi)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(phy->test.last_rcpi); i++)\n\t\tif (nla_put_u8(msg, i, phy->test.last_rcpi[i]))\n\t\t\treturn -ENOMEM;\n\n\tnla_nest_end(msg, rssi);\n\n\trssi = nla_nest_start(msg, MT76_TM_RX_ATTR_IB_RSSI);\n\tif (!rssi)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(phy->test.last_ib_rssi); i++)\n\t\tif (nla_put_s8(msg, i, phy->test.last_ib_rssi[i]))\n\t\t\treturn -ENOMEM;\n\n\tnla_nest_end(msg, rssi);\n\n\trssi = nla_nest_start(msg, MT76_TM_RX_ATTR_WB_RSSI);\n\tif (!rssi)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(phy->test.last_wb_rssi); i++)\n\t\tif (nla_put_s8(msg, i, phy->test.last_wb_rssi[i]))\n\t\t\treturn -ENOMEM;\n\n\tnla_nest_end(msg, rssi);\n\n\tif (nla_put_u8(msg, MT76_TM_RX_ATTR_SNR, phy->test.last_snr))\n\t\treturn -ENOMEM;\n\n\tnla_nest_end(msg, rx);\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR3(phy->mt76->band_idx));\n\tfcs_err = is_mt7915(&dev->mt76) ? FIELD_GET(MT_MIB_SDR3_FCS_ERR_MASK, cnt) :\n\t\tFIELD_GET(MT_MIB_SDR3_FCS_ERR_MASK_MT7916, cnt);\n\n\tq = phy->mt76->band_idx ? MT_RXQ_BAND1 : MT_RXQ_MAIN;\n\tmphy->test.rx_stats.packets[q] += fcs_err;\n\tmphy->test.rx_stats.fcs_error[q] += fcs_err;\n\n\treturn 0;\n}\n\nconst struct mt76_testmode_ops mt7915_testmode_ops = {\n\t.set_state = mt7915_tm_set_state,\n\t.set_params = mt7915_tm_set_params,\n\t.dump_stats = mt7915_tm_dump_stats,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}