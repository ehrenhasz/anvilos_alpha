{
  "module_name": "pci.c",
  "hash_id": "b4cae4aa1c7becfe59f39a70b1b05c1d6a1bd842b5956511c7c128c5cad298c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7915/pci.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#include \"mt7915.h\"\n#include \"mac.h\"\n#include \"../trace.h\"\n\nstatic LIST_HEAD(hif_list);\nstatic DEFINE_SPINLOCK(hif_lock);\nstatic u32 hif_idx;\n\nstatic const struct pci_device_id mt7915_pci_device_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MEDIATEK, 0x7915) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MEDIATEK, 0x7906) },\n\t{ },\n};\n\nstatic const struct pci_device_id mt7915_hif_device_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MEDIATEK, 0x7916) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MEDIATEK, 0x790a) },\n\t{ },\n};\n\nstatic struct mt7915_hif *mt7915_pci_get_hif2(u32 idx)\n{\n\tstruct mt7915_hif *hif;\n\tu32 val;\n\n\tspin_lock_bh(&hif_lock);\n\n\tlist_for_each_entry(hif, &hif_list, list) {\n\t\tval = readl(hif->regs + MT_PCIE_RECOG_ID);\n\t\tval &= MT_PCIE_RECOG_ID_MASK;\n\t\tif (val != idx)\n\t\t\tcontinue;\n\n\t\tget_device(hif->dev);\n\t\tgoto out;\n\t}\n\thif = NULL;\n\nout:\n\tspin_unlock_bh(&hif_lock);\n\n\treturn hif;\n}\n\nstatic void mt7915_put_hif2(struct mt7915_hif *hif)\n{\n\tif (!hif)\n\t\treturn;\n\n\tput_device(hif->dev);\n}\n\nstatic struct mt7915_hif *mt7915_pci_init_hif2(struct pci_dev *pdev)\n{\n\tstruct pci_dev *tmp_pdev;\n\n\thif_idx++;\n\n\ttmp_pdev = pci_get_device(PCI_VENDOR_ID_MEDIATEK, 0x7916, NULL);\n\tif (!tmp_pdev) {\n\t\ttmp_pdev = pci_get_device(PCI_VENDOR_ID_MEDIATEK, 0x790a, NULL);\n\t\tif (!tmp_pdev)\n\t\t\treturn NULL;\n\t}\n\tpci_dev_put(tmp_pdev);\n\n\twritel(hif_idx | MT_PCIE_RECOG_ID_SEM,\n\t       pcim_iomap_table(pdev)[0] + MT_PCIE_RECOG_ID);\n\n\treturn mt7915_pci_get_hif2(hif_idx);\n}\n\nstatic int mt7915_pci_hif2_probe(struct pci_dev *pdev)\n{\n\tstruct mt7915_hif *hif;\n\n\thif = devm_kzalloc(&pdev->dev, sizeof(*hif), GFP_KERNEL);\n\tif (!hif)\n\t\treturn -ENOMEM;\n\n\thif->dev = &pdev->dev;\n\thif->regs = pcim_iomap_table(pdev)[0];\n\thif->irq = pdev->irq;\n\tspin_lock_bh(&hif_lock);\n\tlist_add(&hif->list, &hif_list);\n\tspin_unlock_bh(&hif_lock);\n\tpci_set_drvdata(pdev, hif);\n\n\treturn 0;\n}\n\nstatic int mt7915_pci_probe(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *id)\n{\n\tstruct mt7915_hif *hif2 = NULL;\n\tstruct mt7915_dev *dev;\n\tstruct mt76_dev *mdev;\n\tint irq;\n\tint ret;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pcim_iomap_regions(pdev, BIT(0), pci_name(pdev));\n\tif (ret)\n\t\treturn ret;\n\n\tpci_set_master(pdev);\n\n\tret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\tmt76_pci_disable_aspm(pdev);\n\n\tif (id->device == 0x7916 || id->device == 0x790a)\n\t\treturn mt7915_pci_hif2_probe(pdev);\n\n\tdev = mt7915_mmio_probe(&pdev->dev, pcim_iomap_table(pdev)[0],\n\t\t\t\tid->device);\n\tif (IS_ERR(dev))\n\t\treturn PTR_ERR(dev);\n\n\tmdev = &dev->mt76;\n\tmt7915_wfsys_reset(dev);\n\thif2 = mt7915_pci_init_hif2(pdev);\n\n\tret = mt7915_mmio_wed_init(dev, pdev, true, &irq);\n\tif (ret < 0)\n\t\tgoto free_wed_or_irq_vector;\n\n\tif (!ret) {\n\t\thif2 = mt7915_pci_init_hif2(pdev);\n\n\t\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_ALL_TYPES);\n\t\tif (ret < 0)\n\t\t\tgoto free_device;\n\n\t\tirq = pdev->irq;\n\t}\n\n\tret = devm_request_irq(mdev->dev, irq, mt7915_irq_handler,\n\t\t\t       IRQF_SHARED, KBUILD_MODNAME, dev);\n\tif (ret)\n\t\tgoto free_wed_or_irq_vector;\n\n\t \n\tmt76_wr(dev, MT_PCIE_MAC_INT_ENABLE, 0xff);\n\n\tif (hif2) {\n\t\tdev->hif2 = hif2;\n\n\t\tmt76_wr(dev, MT_INT1_MASK_CSR, 0);\n\t\t \n\t\tif (is_mt7915(mdev))\n\t\t\tmt76_wr(dev, MT_PCIE1_MAC_INT_ENABLE, 0xff);\n\t\telse\n\t\t\tmt76_wr(dev, MT_PCIE1_MAC_INT_ENABLE_MT7916, 0xff);\n\n\t\tret = devm_request_irq(mdev->dev, dev->hif2->irq,\n\t\t\t\t       mt7915_irq_handler, IRQF_SHARED,\n\t\t\t\t       KBUILD_MODNAME \"-hif\", dev);\n\t\tif (ret)\n\t\t\tgoto free_hif2;\n\t}\n\n\tret = mt7915_register_device(dev);\n\tif (ret)\n\t\tgoto free_hif2_irq;\n\n\treturn 0;\n\nfree_hif2_irq:\n\tif (dev->hif2)\n\t\tdevm_free_irq(mdev->dev, dev->hif2->irq, dev);\nfree_hif2:\n\tif (dev->hif2)\n\t\tput_device(dev->hif2->dev);\n\tdevm_free_irq(mdev->dev, irq, dev);\nfree_wed_or_irq_vector:\n\tif (mtk_wed_device_active(&mdev->mmio.wed))\n\t\tmtk_wed_device_detach(&mdev->mmio.wed);\n\telse\n\t\tpci_free_irq_vectors(pdev);\nfree_device:\n\tmt76_free_device(&dev->mt76);\n\n\treturn ret;\n}\n\nstatic void mt7915_hif_remove(struct pci_dev *pdev)\n{\n\tstruct mt7915_hif *hif = pci_get_drvdata(pdev);\n\n\tlist_del(&hif->list);\n}\n\nstatic void mt7915_pci_remove(struct pci_dev *pdev)\n{\n\tstruct mt76_dev *mdev;\n\tstruct mt7915_dev *dev;\n\n\tmdev = pci_get_drvdata(pdev);\n\tdev = container_of(mdev, struct mt7915_dev, mt76);\n\tmt7915_put_hif2(dev->hif2);\n\tmt7915_unregister_device(dev);\n}\n\nstruct pci_driver mt7915_hif_driver = {\n\t.name\t\t= KBUILD_MODNAME \"_hif\",\n\t.id_table\t= mt7915_hif_device_table,\n\t.probe\t\t= mt7915_pci_probe,\n\t.remove\t\t= mt7915_hif_remove,\n};\n\nstruct pci_driver mt7915_pci_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= mt7915_pci_device_table,\n\t.probe\t\t= mt7915_pci_probe,\n\t.remove\t\t= mt7915_pci_remove,\n};\n\nMODULE_DEVICE_TABLE(pci, mt7915_pci_device_table);\nMODULE_DEVICE_TABLE(pci, mt7915_hif_device_table);\nMODULE_FIRMWARE(MT7915_FIRMWARE_WA);\nMODULE_FIRMWARE(MT7915_FIRMWARE_WM);\nMODULE_FIRMWARE(MT7915_ROM_PATCH);\nMODULE_FIRMWARE(MT7916_FIRMWARE_WA);\nMODULE_FIRMWARE(MT7916_FIRMWARE_WM);\nMODULE_FIRMWARE(MT7916_ROM_PATCH);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}