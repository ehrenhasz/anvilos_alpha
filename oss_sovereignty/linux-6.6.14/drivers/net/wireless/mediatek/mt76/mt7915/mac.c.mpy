{
  "module_name": "mac.c",
  "hash_id": "7e6150dffe6dc729106adc86e95187695293e6082775eab74f3afef3ecc6d2d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7915/mac.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/timekeeping.h>\n#include \"coredump.h\"\n#include \"mt7915.h\"\n#include \"../dma.h\"\n#include \"mac.h\"\n#include \"mcu.h\"\n\n#define to_rssi(field, rcpi)\t((FIELD_GET(field, rcpi) - 220) / 2)\n\nstatic const struct mt7915_dfs_radar_spec etsi_radar_specs = {\n\t.pulse_th = { 110, -10, -80, 40, 5200, 128, 5200 },\n\t.radar_pattern = {\n\t\t[5] =  { 1, 0,  6, 32, 28, 0,  990, 5010, 17, 1, 1 },\n\t\t[6] =  { 1, 0,  9, 32, 28, 0,  615, 5010, 27, 1, 1 },\n\t\t[7] =  { 1, 0, 15, 32, 28, 0,  240,  445, 27, 1, 1 },\n\t\t[8] =  { 1, 0, 12, 32, 28, 0,  240,  510, 42, 1, 1 },\n\t\t[9] =  { 1, 1,  0,  0,  0, 0, 2490, 3343, 14, 0, 0, 12, 32, 28, { }, 126 },\n\t\t[10] = { 1, 1,  0,  0,  0, 0, 2490, 3343, 14, 0, 0, 15, 32, 24, { }, 126 },\n\t\t[11] = { 1, 1,  0,  0,  0, 0,  823, 2510, 14, 0, 0, 18, 32, 28, { },  54 },\n\t\t[12] = { 1, 1,  0,  0,  0, 0,  823, 2510, 14, 0, 0, 27, 32, 24, { },  54 },\n\t},\n};\n\nstatic const struct mt7915_dfs_radar_spec fcc_radar_specs = {\n\t.pulse_th = { 110, -10, -80, 40, 5200, 128, 5200 },\n\t.radar_pattern = {\n\t\t[0] = { 1, 0,  8,  32, 28, 0, 508, 3076, 13, 1,  1 },\n\t\t[1] = { 1, 0, 12,  32, 28, 0, 140,  240, 17, 1,  1 },\n\t\t[2] = { 1, 0,  8,  32, 28, 0, 190,  510, 22, 1,  1 },\n\t\t[3] = { 1, 0,  6,  32, 28, 0, 190,  510, 32, 1,  1 },\n\t\t[4] = { 1, 0,  9, 255, 28, 0, 323,  343, 13, 1, 32 },\n\t},\n};\n\nstatic const struct mt7915_dfs_radar_spec jp_radar_specs = {\n\t.pulse_th = { 110, -10, -80, 40, 5200, 128, 5200 },\n\t.radar_pattern = {\n\t\t[0] =  { 1, 0,  8,  32, 28, 0,  508, 3076,  13, 1,  1 },\n\t\t[1] =  { 1, 0, 12,  32, 28, 0,  140,  240,  17, 1,  1 },\n\t\t[2] =  { 1, 0,  8,  32, 28, 0,  190,  510,  22, 1,  1 },\n\t\t[3] =  { 1, 0,  6,  32, 28, 0,  190,  510,  32, 1,  1 },\n\t\t[4] =  { 1, 0,  9, 255, 28, 0,  323,  343,  13, 1, 32 },\n\t\t[13] = { 1, 0,  7,  32, 28, 0, 3836, 3856,  14, 1,  1 },\n\t\t[14] = { 1, 0,  6,  32, 28, 0,  615, 5010, 110, 1,  1 },\n\t\t[15] = { 1, 1,  0,   0,  0, 0,   15, 5010, 110, 0,  0, 12, 32, 28 },\n\t},\n};\n\nstatic struct mt76_wcid *mt7915_rx_get_wcid(struct mt7915_dev *dev,\n\t\t\t\t\t    u16 idx, bool unicast)\n{\n\tstruct mt7915_sta *sta;\n\tstruct mt76_wcid *wcid;\n\n\tif (idx >= ARRAY_SIZE(dev->mt76.wcid))\n\t\treturn NULL;\n\n\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n\tif (unicast || !wcid)\n\t\treturn wcid;\n\n\tif (!wcid->sta)\n\t\treturn NULL;\n\n\tsta = container_of(wcid, struct mt7915_sta, wcid);\n\tif (!sta->vif)\n\t\treturn NULL;\n\n\treturn &sta->vif->sta.wcid;\n}\n\nbool mt7915_mac_wtbl_update(struct mt7915_dev *dev, int idx, u32 mask)\n{\n\tmt76_rmw(dev, MT_WTBL_UPDATE, MT_WTBL_UPDATE_WLAN_IDX,\n\t\t FIELD_PREP(MT_WTBL_UPDATE_WLAN_IDX, idx) | mask);\n\n\treturn mt76_poll(dev, MT_WTBL_UPDATE, MT_WTBL_UPDATE_BUSY,\n\t\t\t 0, 5000);\n}\n\nu32 mt7915_mac_wtbl_lmac_addr(struct mt7915_dev *dev, u16 wcid, u8 dw)\n{\n\tmt76_wr(dev, MT_WTBLON_TOP_WDUCR,\n\t\tFIELD_PREP(MT_WTBLON_TOP_WDUCR_GROUP, (wcid >> 7)));\n\n\treturn MT_WTBL_LMAC_OFFS(wcid, dw);\n}\n\nstatic void mt7915_mac_sta_poll(struct mt7915_dev *dev)\n{\n\tstatic const u8 ac_to_tid[] = {\n\t\t[IEEE80211_AC_BE] = 0,\n\t\t[IEEE80211_AC_BK] = 1,\n\t\t[IEEE80211_AC_VI] = 4,\n\t\t[IEEE80211_AC_VO] = 6\n\t};\n\tstruct ieee80211_sta *sta;\n\tstruct mt7915_sta *msta;\n\tstruct rate_info *rate;\n\tu32 tx_time[IEEE80211_NUM_ACS], rx_time[IEEE80211_NUM_ACS];\n\tLIST_HEAD(sta_poll_list);\n\tint i;\n\n\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\tlist_splice_init(&dev->mt76.sta_poll_list, &sta_poll_list);\n\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\n\trcu_read_lock();\n\n\twhile (true) {\n\t\tbool clear = false;\n\t\tu32 addr, val;\n\t\tu16 idx;\n\t\ts8 rssi[4];\n\t\tu8 bw;\n\n\t\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\t\tif (list_empty(&sta_poll_list)) {\n\t\t\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\t\t\tbreak;\n\t\t}\n\t\tmsta = list_first_entry(&sta_poll_list,\n\t\t\t\t\tstruct mt7915_sta, wcid.poll_list);\n\t\tlist_del_init(&msta->wcid.poll_list);\n\t\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\n\t\tidx = msta->wcid.idx;\n\n\t\t \n\t\taddr = mt7915_mac_wtbl_lmac_addr(dev, idx, 20);\n\n\t\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\t\tu32 tx_last = msta->airtime_ac[i];\n\t\t\tu32 rx_last = msta->airtime_ac[i + 4];\n\n\t\t\tmsta->airtime_ac[i] = mt76_rr(dev, addr);\n\t\t\tmsta->airtime_ac[i + 4] = mt76_rr(dev, addr + 4);\n\n\t\t\ttx_time[i] = msta->airtime_ac[i] - tx_last;\n\t\t\trx_time[i] = msta->airtime_ac[i + 4] - rx_last;\n\n\t\t\tif ((tx_last | rx_last) & BIT(30))\n\t\t\t\tclear = true;\n\n\t\t\taddr += 8;\n\t\t}\n\n\t\tif (clear) {\n\t\t\tmt7915_mac_wtbl_update(dev, idx,\n\t\t\t\t\t       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);\n\t\t\tmemset(msta->airtime_ac, 0, sizeof(msta->airtime_ac));\n\t\t}\n\n\t\tif (!msta->wcid.sta)\n\t\t\tcontinue;\n\n\t\tsta = container_of((void *)msta, struct ieee80211_sta,\n\t\t\t\t   drv_priv);\n\t\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\t\tu8 queue = mt76_connac_lmac_mapping(i);\n\t\t\tu32 tx_cur = tx_time[queue];\n\t\t\tu32 rx_cur = rx_time[queue];\n\t\t\tu8 tid = ac_to_tid[i];\n\n\t\t\tif (!tx_cur && !rx_cur)\n\t\t\t\tcontinue;\n\n\t\t\tieee80211_sta_register_airtime(sta, tid, tx_cur,\n\t\t\t\t\t\t       rx_cur);\n\t\t}\n\n\t\t \n\t\trate = &msta->wcid.rate;\n\t\taddr = mt7915_mac_wtbl_lmac_addr(dev, idx, 7);\n\t\tval = mt76_rr(dev, addr);\n\n\t\tswitch (rate->bw) {\n\t\tcase RATE_INFO_BW_160:\n\t\t\tbw = IEEE80211_STA_RX_BW_160;\n\t\t\tbreak;\n\t\tcase RATE_INFO_BW_80:\n\t\t\tbw = IEEE80211_STA_RX_BW_80;\n\t\t\tbreak;\n\t\tcase RATE_INFO_BW_40:\n\t\t\tbw = IEEE80211_STA_RX_BW_40;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbw = IEEE80211_STA_RX_BW_20;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rate->flags & RATE_INFO_FLAGS_HE_MCS) {\n\t\t\tu8 offs = 24 + 2 * bw;\n\n\t\t\trate->he_gi = (val & (0x3 << offs)) >> offs;\n\t\t} else if (rate->flags &\n\t\t\t   (RATE_INFO_FLAGS_VHT_MCS | RATE_INFO_FLAGS_MCS)) {\n\t\t\tif (val & BIT(12 + bw))\n\t\t\t\trate->flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t\t\telse\n\t\t\t\trate->flags &= ~RATE_INFO_FLAGS_SHORT_GI;\n\t\t}\n\n\t\t \n\t\taddr = mt7915_mac_wtbl_lmac_addr(dev, idx, 30);\n\t\tval = mt76_rr(dev, addr);\n\n\t\trssi[0] = to_rssi(GENMASK(7, 0), val);\n\t\trssi[1] = to_rssi(GENMASK(15, 8), val);\n\t\trssi[2] = to_rssi(GENMASK(23, 16), val);\n\t\trssi[3] = to_rssi(GENMASK(31, 14), val);\n\n\t\tmsta->ack_signal =\n\t\t\tmt76_rx_signal(msta->vif->phy->mt76->antenna_mask, rssi);\n\n\t\tewma_avg_signal_add(&msta->avg_ack_signal, -msta->ack_signal);\n\t}\n\n\trcu_read_unlock();\n}\n\nvoid mt7915_mac_enable_rtscts(struct mt7915_dev *dev,\n\t\t\t      struct ieee80211_vif *vif, bool enable)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tu32 addr;\n\n\taddr = mt7915_mac_wtbl_lmac_addr(dev, mvif->sta.wcid.idx, 5);\n\tif (enable)\n\t\tmt76_set(dev, addr, BIT(5));\n\telse\n\t\tmt76_clear(dev, addr, BIT(5));\n}\n\nstatic void\nmt7915_wed_check_ppe(struct mt7915_dev *dev, struct mt76_queue *q,\n\t\t     struct mt7915_sta *msta, struct sk_buff *skb,\n\t\t     u32 info)\n{\n\tstruct ieee80211_vif *vif;\n\tstruct wireless_dev *wdev;\n\n\tif (!msta || !msta->vif)\n\t\treturn;\n\n\tif (!mt76_queue_is_wed_rx(q))\n\t\treturn;\n\n\tif (!(info & MT_DMA_INFO_PPE_VLD))\n\t\treturn;\n\n\tvif = container_of((void *)msta->vif, struct ieee80211_vif,\n\t\t\t   drv_priv);\n\twdev = ieee80211_vif_to_wdev(vif);\n\tskb->dev = wdev->netdev;\n\n\tmtk_wed_device_ppe_check(&dev->mt76.mmio.wed, skb,\n\t\t\t\t FIELD_GET(MT_DMA_PPE_CPU_REASON, info),\n\t\t\t\t FIELD_GET(MT_DMA_PPE_ENTRY, info));\n}\n\nstatic int\nmt7915_mac_fill_rx(struct mt7915_dev *dev, struct sk_buff *skb,\n\t\t   enum mt76_rxq_id q, u32 *info)\n{\n\tstruct mt76_rx_status *status = (struct mt76_rx_status *)skb->cb;\n\tstruct mt76_phy *mphy = &dev->mt76.phy;\n\tstruct mt7915_phy *phy = &dev->phy;\n\tstruct ieee80211_supported_band *sband;\n\t__le32 *rxd = (__le32 *)skb->data;\n\t__le32 *rxv = NULL;\n\tu32 rxd0 = le32_to_cpu(rxd[0]);\n\tu32 rxd1 = le32_to_cpu(rxd[1]);\n\tu32 rxd2 = le32_to_cpu(rxd[2]);\n\tu32 rxd3 = le32_to_cpu(rxd[3]);\n\tu32 rxd4 = le32_to_cpu(rxd[4]);\n\tu32 csum_mask = MT_RXD0_NORMAL_IP_SUM | MT_RXD0_NORMAL_UDP_TCP_SUM;\n\tbool unicast, insert_ccmp_hdr = false;\n\tu8 remove_pad, amsdu_info;\n\tu8 mode = 0, qos_ctl = 0;\n\tstruct mt7915_sta *msta = NULL;\n\tu32 csum_status = *(u32 *)skb->cb;\n\tbool hdr_trans;\n\tu16 hdr_gap;\n\tu16 seq_ctrl = 0;\n\t__le16 fc = 0;\n\tint idx;\n\n\tmemset(status, 0, sizeof(*status));\n\n\tif ((rxd1 & MT_RXD1_NORMAL_BAND_IDX) && !phy->mt76->band_idx) {\n\t\tmphy = dev->mt76.phys[MT_BAND1];\n\t\tif (!mphy)\n\t\t\treturn -EINVAL;\n\n\t\tphy = mphy->priv;\n\t\tstatus->phy_idx = 1;\n\t}\n\n\tif (!test_bit(MT76_STATE_RUNNING, &mphy->state))\n\t\treturn -EINVAL;\n\n\tif (rxd2 & MT_RXD2_NORMAL_AMSDU_ERR)\n\t\treturn -EINVAL;\n\n\thdr_trans = rxd2 & MT_RXD2_NORMAL_HDR_TRANS;\n\tif (hdr_trans && (rxd1 & MT_RXD1_NORMAL_CM))\n\t\treturn -EINVAL;\n\n\t \n\tif (rxd1 & MT_RXD1_NORMAL_ICV_ERR)\n\t\tstatus->flag |= RX_FLAG_ONLY_MONITOR;\n\n\tunicast = FIELD_GET(MT_RXD3_NORMAL_ADDR_TYPE, rxd3) == MT_RXD3_NORMAL_U2M;\n\tidx = FIELD_GET(MT_RXD1_NORMAL_WLAN_IDX, rxd1);\n\tstatus->wcid = mt7915_rx_get_wcid(dev, idx, unicast);\n\n\tif (status->wcid) {\n\t\tmsta = container_of(status->wcid, struct mt7915_sta, wcid);\n\t\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\t\tif (list_empty(&msta->wcid.poll_list))\n\t\t\tlist_add_tail(&msta->wcid.poll_list,\n\t\t\t\t      &dev->mt76.sta_poll_list);\n\t\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\t}\n\n\tstatus->freq = mphy->chandef.chan->center_freq;\n\tstatus->band = mphy->chandef.chan->band;\n\tif (status->band == NL80211_BAND_5GHZ)\n\t\tsband = &mphy->sband_5g.sband;\n\telse if (status->band == NL80211_BAND_6GHZ)\n\t\tsband = &mphy->sband_6g.sband;\n\telse\n\t\tsband = &mphy->sband_2g.sband;\n\n\tif (!sband->channels)\n\t\treturn -EINVAL;\n\n\tif ((rxd0 & csum_mask) == csum_mask &&\n\t    !(csum_status & (BIT(0) | BIT(2) | BIT(3))))\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tif (rxd1 & MT_RXD1_NORMAL_FCS_ERR)\n\t\tstatus->flag |= RX_FLAG_FAILED_FCS_CRC;\n\n\tif (rxd1 & MT_RXD1_NORMAL_TKIP_MIC_ERR)\n\t\tstatus->flag |= RX_FLAG_MMIC_ERROR;\n\n\tif (FIELD_GET(MT_RXD1_NORMAL_SEC_MODE, rxd1) != 0 &&\n\t    !(rxd1 & (MT_RXD1_NORMAL_CLM | MT_RXD1_NORMAL_CM))) {\n\t\tstatus->flag |= RX_FLAG_DECRYPTED;\n\t\tstatus->flag |= RX_FLAG_IV_STRIPPED;\n\t\tstatus->flag |= RX_FLAG_MMIC_STRIPPED | RX_FLAG_MIC_STRIPPED;\n\t}\n\n\tremove_pad = FIELD_GET(MT_RXD2_NORMAL_HDR_OFFSET, rxd2);\n\n\tif (rxd2 & MT_RXD2_NORMAL_MAX_LEN_ERROR)\n\t\treturn -EINVAL;\n\n\trxd += 6;\n\tif (rxd1 & MT_RXD1_NORMAL_GROUP_4) {\n\t\tu32 v0 = le32_to_cpu(rxd[0]);\n\t\tu32 v2 = le32_to_cpu(rxd[2]);\n\n\t\tfc = cpu_to_le16(FIELD_GET(MT_RXD6_FRAME_CONTROL, v0));\n\t\tqos_ctl = FIELD_GET(MT_RXD8_QOS_CTL, v2);\n\t\tseq_ctrl = FIELD_GET(MT_RXD8_SEQ_CTRL, v2);\n\n\t\trxd += 4;\n\t\tif ((u8 *)rxd - skb->data >= skb->len)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (rxd1 & MT_RXD1_NORMAL_GROUP_1) {\n\t\tu8 *data = (u8 *)rxd;\n\n\t\tif (status->flag & RX_FLAG_DECRYPTED) {\n\t\t\tswitch (FIELD_GET(MT_RXD1_NORMAL_SEC_MODE, rxd1)) {\n\t\t\tcase MT_CIPHER_AES_CCMP:\n\t\t\tcase MT_CIPHER_CCMP_CCX:\n\t\t\tcase MT_CIPHER_CCMP_256:\n\t\t\t\tinsert_ccmp_hdr =\n\t\t\t\t\tFIELD_GET(MT_RXD2_NORMAL_FRAG, rxd2);\n\t\t\t\tfallthrough;\n\t\t\tcase MT_CIPHER_TKIP:\n\t\t\tcase MT_CIPHER_TKIP_NO_MIC:\n\t\t\tcase MT_CIPHER_GCMP:\n\t\t\tcase MT_CIPHER_GCMP_256:\n\t\t\t\tstatus->iv[0] = data[5];\n\t\t\t\tstatus->iv[1] = data[4];\n\t\t\t\tstatus->iv[2] = data[3];\n\t\t\t\tstatus->iv[3] = data[2];\n\t\t\t\tstatus->iv[4] = data[1];\n\t\t\t\tstatus->iv[5] = data[0];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trxd += 4;\n\t\tif ((u8 *)rxd - skb->data >= skb->len)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (rxd1 & MT_RXD1_NORMAL_GROUP_2) {\n\t\tstatus->timestamp = le32_to_cpu(rxd[0]);\n\t\tstatus->flag |= RX_FLAG_MACTIME_START;\n\n\t\tif (!(rxd2 & MT_RXD2_NORMAL_NON_AMPDU)) {\n\t\t\tstatus->flag |= RX_FLAG_AMPDU_DETAILS;\n\n\t\t\t \n\t\t\tif (phy->rx_ampdu_ts != status->timestamp) {\n\t\t\t\tif (!++phy->ampdu_ref)\n\t\t\t\t\tphy->ampdu_ref++;\n\t\t\t}\n\t\t\tphy->rx_ampdu_ts = status->timestamp;\n\n\t\t\tstatus->ampdu_ref = phy->ampdu_ref;\n\t\t}\n\n\t\trxd += 2;\n\t\tif ((u8 *)rxd - skb->data >= skb->len)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (rxd1 & MT_RXD1_NORMAL_GROUP_3) {\n\t\tu32 v0, v1;\n\t\tint ret;\n\n\t\trxv = rxd;\n\t\trxd += 2;\n\t\tif ((u8 *)rxd - skb->data >= skb->len)\n\t\t\treturn -EINVAL;\n\n\t\tv0 = le32_to_cpu(rxv[0]);\n\t\tv1 = le32_to_cpu(rxv[1]);\n\n\t\tif (v0 & MT_PRXV_HT_AD_CODE)\n\t\t\tstatus->enc_flags |= RX_ENC_FLAG_LDPC;\n\n\t\tstatus->chains = mphy->antenna_mask;\n\t\tstatus->chain_signal[0] = to_rssi(MT_PRXV_RCPI0, v1);\n\t\tstatus->chain_signal[1] = to_rssi(MT_PRXV_RCPI1, v1);\n\t\tstatus->chain_signal[2] = to_rssi(MT_PRXV_RCPI2, v1);\n\t\tstatus->chain_signal[3] = to_rssi(MT_PRXV_RCPI3, v1);\n\n\t\t \n\t\tif (rxd1 & MT_RXD1_NORMAL_GROUP_5) {\n\t\t\trxd += 18;\n\t\t\tif ((u8 *)rxd - skb->data >= skb->len)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!is_mt7915(&dev->mt76) || (rxd1 & MT_RXD1_NORMAL_GROUP_5)) {\n\t\t\tret = mt76_connac2_mac_fill_rx_rate(&dev->mt76, status,\n\t\t\t\t\t\t\t    sband, rxv, &mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tamsdu_info = FIELD_GET(MT_RXD4_NORMAL_PAYLOAD_FORMAT, rxd4);\n\tstatus->amsdu = !!amsdu_info;\n\tif (status->amsdu) {\n\t\tstatus->first_amsdu = amsdu_info == MT_RXD4_FIRST_AMSDU_FRAME;\n\t\tstatus->last_amsdu = amsdu_info == MT_RXD4_LAST_AMSDU_FRAME;\n\t}\n\n\thdr_gap = (u8 *)rxd - skb->data + 2 * remove_pad;\n\tif (hdr_trans && ieee80211_has_morefrags(fc)) {\n\t\tstruct ieee80211_vif *vif;\n\t\tint err;\n\n\t\tif (!msta || !msta->vif)\n\t\t\treturn -EINVAL;\n\n\t\tvif = container_of((void *)msta->vif, struct ieee80211_vif,\n\t\t\t\t   drv_priv);\n\t\terr = mt76_connac2_reverse_frag0_hdr_trans(vif, skb, hdr_gap);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\thdr_trans = false;\n\t} else {\n\t\tint pad_start = 0;\n\n\t\tskb_pull(skb, hdr_gap);\n\t\tif (!hdr_trans && status->amsdu) {\n\t\t\tpad_start = ieee80211_get_hdrlen_from_skb(skb);\n\t\t} else if (hdr_trans && (rxd2 & MT_RXD2_NORMAL_HDR_TRANS_ERROR)) {\n\t\t\t \n\t\t\tpad_start = 12;\n\t\t\tif (get_unaligned_be16(skb->data + pad_start) == ETH_P_8021Q)\n\t\t\t\tpad_start += 4;\n\t\t\telse\n\t\t\t\tpad_start = 0;\n\t\t}\n\n\t\tif (pad_start) {\n\t\t\tmemmove(skb->data + 2, skb->data, pad_start);\n\t\t\tskb_pull(skb, 2);\n\t\t}\n\t}\n\n\tif (!hdr_trans) {\n\t\tstruct ieee80211_hdr *hdr;\n\n\t\tif (insert_ccmp_hdr) {\n\t\t\tu8 key_id = FIELD_GET(MT_RXD1_NORMAL_KEY_ID, rxd1);\n\n\t\t\tmt76_insert_ccmp_hdr(skb, key_id);\n\t\t}\n\n\t\thdr = mt76_skb_get_hdr(skb);\n\t\tfc = hdr->frame_control;\n\t\tif (ieee80211_is_data_qos(fc)) {\n\t\t\tseq_ctrl = le16_to_cpu(hdr->seq_ctrl);\n\t\t\tqos_ctl = *ieee80211_get_qos_ctl(hdr);\n\t\t}\n\t} else {\n\t\tstatus->flag |= RX_FLAG_8023;\n\t\tmt7915_wed_check_ppe(dev, &dev->mt76.q_rx[q], msta, skb,\n\t\t\t\t     *info);\n\t}\n\n\tif (rxv && mode >= MT_PHY_TYPE_HE_SU && !(status->flag & RX_FLAG_8023))\n\t\tmt76_connac2_mac_decode_he_radiotap(&dev->mt76, skb, rxv, mode);\n\n\tif (!status->wcid || !ieee80211_is_data_qos(fc))\n\t\treturn 0;\n\n\tstatus->aggr = unicast &&\n\t\t       !ieee80211_is_qos_nullfunc(fc);\n\tstatus->qos_ctl = qos_ctl;\n\tstatus->seqno = IEEE80211_SEQ_TO_SN(seq_ctrl);\n\n\treturn 0;\n}\n\nstatic void\nmt7915_mac_fill_rx_vector(struct mt7915_dev *dev, struct sk_buff *skb)\n{\n#ifdef CONFIG_NL80211_TESTMODE\n\tstruct mt7915_phy *phy = &dev->phy;\n\t__le32 *rxd = (__le32 *)skb->data;\n\t__le32 *rxv_hdr = rxd + 2;\n\t__le32 *rxv = rxd + 4;\n\tu32 rcpi, ib_rssi, wb_rssi, v20, v21;\n\tu8 band_idx;\n\ts32 foe;\n\tu8 snr;\n\tint i;\n\n\tband_idx = le32_get_bits(rxv_hdr[1], MT_RXV_HDR_BAND_IDX);\n\tif (band_idx && !phy->mt76->band_idx) {\n\t\tphy = mt7915_ext_phy(dev);\n\t\tif (!phy)\n\t\t\tgoto out;\n\t}\n\n\trcpi = le32_to_cpu(rxv[6]);\n\tib_rssi = le32_to_cpu(rxv[7]);\n\twb_rssi = le32_to_cpu(rxv[8]) >> 5;\n\n\tfor (i = 0; i < 4; i++, rcpi >>= 8, ib_rssi >>= 8, wb_rssi >>= 9) {\n\t\tif (i == 3)\n\t\t\twb_rssi = le32_to_cpu(rxv[9]);\n\n\t\tphy->test.last_rcpi[i] = rcpi & 0xff;\n\t\tphy->test.last_ib_rssi[i] = ib_rssi & 0xff;\n\t\tphy->test.last_wb_rssi[i] = wb_rssi & 0xff;\n\t}\n\n\tv20 = le32_to_cpu(rxv[20]);\n\tv21 = le32_to_cpu(rxv[21]);\n\n\tfoe = FIELD_GET(MT_CRXV_FOE_LO, v20) |\n\t      (FIELD_GET(MT_CRXV_FOE_HI, v21) << MT_CRXV_FOE_SHIFT);\n\n\tsnr = FIELD_GET(MT_CRXV_SNR, v20) - 16;\n\n\tphy->test.last_freq_offset = foe;\n\tphy->test.last_snr = snr;\nout:\n#endif\n\tdev_kfree_skb(skb);\n}\n\nstatic void\nmt7915_mac_write_txwi_tm(struct mt7915_phy *phy, __le32 *txwi,\n\t\t\t struct sk_buff *skb)\n{\n#ifdef CONFIG_NL80211_TESTMODE\n\tstruct mt76_testmode_data *td = &phy->mt76->test;\n\tconst struct ieee80211_rate *r;\n\tu8 bw, mode, nss = td->tx_rate_nss;\n\tu8 rate_idx = td->tx_rate_idx;\n\tu16 rateval = 0;\n\tu32 val;\n\tbool cck = false;\n\tint band;\n\n\tif (skb != phy->mt76->test.tx_skb)\n\t\treturn;\n\n\tswitch (td->tx_rate_mode) {\n\tcase MT76_TM_TX_MODE_HT:\n\t\tnss = 1 + (rate_idx >> 3);\n\t\tmode = MT_PHY_TYPE_HT;\n\t\tbreak;\n\tcase MT76_TM_TX_MODE_VHT:\n\t\tmode = MT_PHY_TYPE_VHT;\n\t\tbreak;\n\tcase MT76_TM_TX_MODE_HE_SU:\n\t\tmode = MT_PHY_TYPE_HE_SU;\n\t\tbreak;\n\tcase MT76_TM_TX_MODE_HE_EXT_SU:\n\t\tmode = MT_PHY_TYPE_HE_EXT_SU;\n\t\tbreak;\n\tcase MT76_TM_TX_MODE_HE_TB:\n\t\tmode = MT_PHY_TYPE_HE_TB;\n\t\tbreak;\n\tcase MT76_TM_TX_MODE_HE_MU:\n\t\tmode = MT_PHY_TYPE_HE_MU;\n\t\tbreak;\n\tcase MT76_TM_TX_MODE_CCK:\n\t\tcck = true;\n\t\tfallthrough;\n\tcase MT76_TM_TX_MODE_OFDM:\n\t\tband = phy->mt76->chandef.chan->band;\n\t\tif (band == NL80211_BAND_2GHZ && !cck)\n\t\t\trate_idx += 4;\n\n\t\tr = &phy->mt76->hw->wiphy->bands[band]->bitrates[rate_idx];\n\t\tval = cck ? r->hw_value_short : r->hw_value;\n\n\t\tmode = val >> 8;\n\t\trate_idx = val & 0xff;\n\t\tbreak;\n\tdefault:\n\t\tmode = MT_PHY_TYPE_OFDM;\n\t\tbreak;\n\t}\n\n\tswitch (phy->mt76->chandef.width) {\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tbw = 1;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\tbw = 2;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80P80:\n\tcase NL80211_CHAN_WIDTH_160:\n\t\tbw = 3;\n\t\tbreak;\n\tdefault:\n\t\tbw = 0;\n\t\tbreak;\n\t}\n\n\tif (td->tx_rate_stbc && nss == 1) {\n\t\tnss++;\n\t\trateval |= MT_TX_RATE_STBC;\n\t}\n\n\trateval |= FIELD_PREP(MT_TX_RATE_IDX, rate_idx) |\n\t\t   FIELD_PREP(MT_TX_RATE_MODE, mode) |\n\t\t   FIELD_PREP(MT_TX_RATE_NSS, nss - 1);\n\n\ttxwi[2] |= cpu_to_le32(MT_TXD2_FIX_RATE);\n\n\tle32p_replace_bits(&txwi[3], 1, MT_TXD3_REM_TX_COUNT);\n\tif (td->tx_rate_mode < MT76_TM_TX_MODE_HT)\n\t\ttxwi[3] |= cpu_to_le32(MT_TXD3_BA_DISABLE);\n\n\tval = MT_TXD6_FIXED_BW |\n\t      FIELD_PREP(MT_TXD6_BW, bw) |\n\t      FIELD_PREP(MT_TXD6_TX_RATE, rateval) |\n\t      FIELD_PREP(MT_TXD6_SGI, td->tx_rate_sgi);\n\n\t \n\tif (mode >= MT_PHY_TYPE_HE_SU)\n\t\tval |= FIELD_PREP(MT_TXD6_HELTF, td->tx_ltf);\n\n\tif (td->tx_rate_ldpc || (bw > 0 && mode >= MT_PHY_TYPE_HE_SU))\n\t\tval |= MT_TXD6_LDPC;\n\n\ttxwi[3] &= ~cpu_to_le32(MT_TXD3_SN_VALID);\n\ttxwi[6] |= cpu_to_le32(val);\n\ttxwi[7] |= cpu_to_le32(FIELD_PREP(MT_TXD7_SPE_IDX,\n\t\t\t\t\t  phy->test.spe_idx));\n#endif\n}\n\nvoid mt7915_mac_write_txwi(struct mt76_dev *dev, __le32 *txwi,\n\t\t\t   struct sk_buff *skb, struct mt76_wcid *wcid, int pid,\n\t\t\t   struct ieee80211_key_conf *key,\n\t\t\t   enum mt76_txq_id qid, u32 changed)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tu8 phy_idx = (info->hw_queue & MT_TX_HW_QUEUE_PHY) >> 2;\n\tstruct mt76_phy *mphy = &dev->phy;\n\n\tif (phy_idx && dev->phys[MT_BAND1])\n\t\tmphy = dev->phys[MT_BAND1];\n\n\tmt76_connac2_mac_write_txwi(dev, txwi, skb, wcid, key, pid, qid, changed);\n\n\tif (mt76_testmode_enabled(mphy))\n\t\tmt7915_mac_write_txwi_tm(mphy->priv, txwi, skb);\n}\n\nint mt7915_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,\n\t\t\t  enum mt76_txq_id qid, struct mt76_wcid *wcid,\n\t\t\t  struct ieee80211_sta *sta,\n\t\t\t  struct mt76_tx_info *tx_info)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx_info->skb->data;\n\tstruct mt7915_dev *dev = container_of(mdev, struct mt7915_dev, mt76);\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx_info->skb);\n\tstruct ieee80211_key_conf *key = info->control.hw_key;\n\tstruct ieee80211_vif *vif = info->control.vif;\n\tstruct mt76_connac_fw_txp *txp;\n\tstruct mt76_txwi_cache *t;\n\tint id, i, nbuf = tx_info->nbuf - 1;\n\tu8 *txwi = (u8 *)txwi_ptr;\n\tint pid;\n\n\tif (unlikely(tx_info->skb->len <= ETH_HLEN))\n\t\treturn -EINVAL;\n\n\tif (!wcid)\n\t\twcid = &dev->mt76.global_wcid;\n\n\tif (sta) {\n\t\tstruct mt7915_sta *msta;\n\n\t\tmsta = (struct mt7915_sta *)sta->drv_priv;\n\n\t\tif (time_after(jiffies, msta->jiffies + HZ / 4)) {\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;\n\t\t\tmsta->jiffies = jiffies;\n\t\t}\n\t}\n\n\tt = (struct mt76_txwi_cache *)(txwi + mdev->drv->txwi_size);\n\tt->skb = tx_info->skb;\n\n\tid = mt76_token_consume(mdev, &t);\n\tif (id < 0)\n\t\treturn id;\n\n\tpid = mt76_tx_status_skb_add(mdev, wcid, tx_info->skb);\n\tmt7915_mac_write_txwi(mdev, txwi_ptr, tx_info->skb, wcid, pid, key,\n\t\t\t      qid, 0);\n\n\ttxp = (struct mt76_connac_fw_txp *)(txwi + MT_TXD_SIZE);\n\tfor (i = 0; i < nbuf; i++) {\n\t\ttxp->buf[i] = cpu_to_le32(tx_info->buf[i + 1].addr);\n\t\ttxp->len[i] = cpu_to_le16(tx_info->buf[i + 1].len);\n\t}\n\ttxp->nbuf = nbuf;\n\n\ttxp->flags = cpu_to_le16(MT_CT_INFO_APPLY_TXD | MT_CT_INFO_FROM_HOST);\n\n\tif (!key)\n\t\ttxp->flags |= cpu_to_le16(MT_CT_INFO_NONE_CIPHER_FRAME);\n\n\tif (!(info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP) &&\n\t    ieee80211_is_mgmt(hdr->frame_control))\n\t\ttxp->flags |= cpu_to_le16(MT_CT_INFO_MGMT_FRAME);\n\n\tif (vif) {\n\t\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\n\t\ttxp->bss_idx = mvif->mt76.idx;\n\t}\n\n\ttxp->token = cpu_to_le16(id);\n\tif (test_bit(MT_WCID_FLAG_4ADDR, &wcid->flags))\n\t\ttxp->rept_wds_wcid = cpu_to_le16(wcid->idx);\n\telse\n\t\ttxp->rept_wds_wcid = cpu_to_le16(0x3ff);\n\ttx_info->skb = NULL;\n\n\t \n\ttx_info->buf[1].len = MT_CT_PARSE_LEN;\n\ttx_info->buf[1].skip_unmap = true;\n\ttx_info->nbuf = MT_CT_DMA_BUF_NUM;\n\n\treturn 0;\n}\n\nu32 mt7915_wed_init_buf(void *ptr, dma_addr_t phys, int token_id)\n{\n\tstruct mt76_connac_fw_txp *txp = ptr + MT_TXD_SIZE;\n\t__le32 *txwi = ptr;\n\tu32 val;\n\n\tmemset(ptr, 0, MT_TXD_SIZE + sizeof(*txp));\n\n\tval = FIELD_PREP(MT_TXD0_TX_BYTES, MT_TXD_SIZE) |\n\t      FIELD_PREP(MT_TXD0_PKT_FMT, MT_TX_TYPE_CT);\n\ttxwi[0] = cpu_to_le32(val);\n\n\tval = MT_TXD1_LONG_FORMAT |\n\t      FIELD_PREP(MT_TXD1_HDR_FORMAT, MT_HDR_FORMAT_802_3);\n\ttxwi[1] = cpu_to_le32(val);\n\n\ttxp->token = cpu_to_le16(token_id);\n\ttxp->nbuf = 1;\n\ttxp->buf[0] = cpu_to_le32(phys + MT_TXD_SIZE + sizeof(*txp));\n\n\treturn MT_TXD_SIZE + sizeof(*txp);\n}\n\nstatic void\nmt7915_mac_tx_free_prepare(struct mt7915_dev *dev)\n{\n\tstruct mt76_dev *mdev = &dev->mt76;\n\tstruct mt76_phy *mphy_ext = mdev->phys[MT_BAND1];\n\n\t \n\tmt76_queue_tx_cleanup(dev, dev->mphy.q_tx[MT_TXQ_PSD], false);\n\tmt76_queue_tx_cleanup(dev, dev->mphy.q_tx[MT_TXQ_BE], false);\n\tif (mphy_ext) {\n\t\tmt76_queue_tx_cleanup(dev, mphy_ext->q_tx[MT_TXQ_PSD], false);\n\t\tmt76_queue_tx_cleanup(dev, mphy_ext->q_tx[MT_TXQ_BE], false);\n\t}\n}\n\nstatic void\nmt7915_mac_tx_free_done(struct mt7915_dev *dev,\n\t\t\tstruct list_head *free_list, bool wake)\n{\n\tstruct sk_buff *skb, *tmp;\n\n\tmt7915_mac_sta_poll(dev);\n\n\tif (wake)\n\t\tmt76_set_tx_blocked(&dev->mt76, false);\n\n\tmt76_worker_schedule(&dev->mt76.tx_worker);\n\n\tlist_for_each_entry_safe(skb, tmp, free_list, list) {\n\t\tskb_list_del_init(skb);\n\t\tnapi_consume_skb(skb, 1);\n\t}\n}\n\nstatic void\nmt7915_mac_tx_free(struct mt7915_dev *dev, void *data, int len)\n{\n\tstruct mt76_connac_tx_free *free = data;\n\t__le32 *tx_info = (__le32 *)(data + sizeof(*free));\n\tstruct mt76_dev *mdev = &dev->mt76;\n\tstruct mt76_txwi_cache *txwi;\n\tstruct ieee80211_sta *sta = NULL;\n\tstruct mt76_wcid *wcid = NULL;\n\tLIST_HEAD(free_list);\n\tvoid *end = data + len;\n\tbool v3, wake = false;\n\tu16 total, count = 0;\n\tu32 txd = le32_to_cpu(free->txd);\n\t__le32 *cur_info;\n\n\tmt7915_mac_tx_free_prepare(dev);\n\n\ttotal = le16_get_bits(free->ctrl, MT_TX_FREE_MSDU_CNT);\n\tv3 = (FIELD_GET(MT_TX_FREE_VER, txd) == 0x4);\n\n\tfor (cur_info = tx_info; count < total; cur_info++) {\n\t\tu32 msdu, info;\n\t\tu8 i;\n\n\t\tif (WARN_ON_ONCE((void *)cur_info >= end))\n\t\t\treturn;\n\n\t\t \n\t\tinfo = le32_to_cpu(*cur_info);\n\t\tif (info & MT_TX_FREE_PAIR) {\n\t\t\tstruct mt7915_sta *msta;\n\t\t\tu16 idx;\n\n\t\t\tidx = FIELD_GET(MT_TX_FREE_WLAN_ID, info);\n\t\t\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n\t\t\tsta = wcid_to_sta(wcid);\n\t\t\tif (!sta)\n\t\t\t\tcontinue;\n\n\t\t\tmsta = container_of(wcid, struct mt7915_sta, wcid);\n\t\t\tspin_lock_bh(&mdev->sta_poll_lock);\n\t\t\tif (list_empty(&msta->wcid.poll_list))\n\t\t\t\tlist_add_tail(&msta->wcid.poll_list,\n\t\t\t\t\t      &mdev->sta_poll_list);\n\t\t\tspin_unlock_bh(&mdev->sta_poll_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!mtk_wed_device_active(&mdev->mmio.wed) && wcid) {\n\t\t\tu32 tx_retries = 0, tx_failed = 0;\n\n\t\t\tif (v3 && (info & MT_TX_FREE_MPDU_HEADER_V3)) {\n\t\t\t\ttx_retries =\n\t\t\t\t\tFIELD_GET(MT_TX_FREE_COUNT_V3, info) - 1;\n\t\t\t\ttx_failed = tx_retries +\n\t\t\t\t\t!!FIELD_GET(MT_TX_FREE_STAT_V3, info);\n\t\t\t} else if (!v3 && (info & MT_TX_FREE_MPDU_HEADER)) {\n\t\t\t\ttx_retries =\n\t\t\t\t\tFIELD_GET(MT_TX_FREE_COUNT, info) - 1;\n\t\t\t\ttx_failed = tx_retries +\n\t\t\t\t\t!!FIELD_GET(MT_TX_FREE_STAT, info);\n\t\t\t}\n\t\t\twcid->stats.tx_retries += tx_retries;\n\t\t\twcid->stats.tx_failed += tx_failed;\n\t\t}\n\n\t\tif (v3 && (info & MT_TX_FREE_MPDU_HEADER_V3))\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < 1 + v3; i++) {\n\t\t\tif (v3) {\n\t\t\t\tmsdu = (info >> (15 * i)) & MT_TX_FREE_MSDU_ID_V3;\n\t\t\t\tif (msdu == MT_TX_FREE_MSDU_ID_V3)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tmsdu = FIELD_GET(MT_TX_FREE_MSDU_ID, info);\n\t\t\t}\n\t\t\tcount++;\n\t\t\ttxwi = mt76_token_release(mdev, msdu, &wake);\n\t\t\tif (!txwi)\n\t\t\t\tcontinue;\n\n\t\t\tmt76_connac2_txwi_free(mdev, txwi, sta, &free_list);\n\t\t}\n\t}\n\n\tmt7915_mac_tx_free_done(dev, &free_list, wake);\n}\n\nstatic void\nmt7915_mac_tx_free_v0(struct mt7915_dev *dev, void *data, int len)\n{\n\tstruct mt76_connac_tx_free *free = data;\n\t__le16 *info = (__le16 *)(data + sizeof(*free));\n\tstruct mt76_dev *mdev = &dev->mt76;\n\tvoid *end = data + len;\n\tLIST_HEAD(free_list);\n\tbool wake = false;\n\tu8 i, count;\n\n\tmt7915_mac_tx_free_prepare(dev);\n\n\tcount = FIELD_GET(MT_TX_FREE_MSDU_CNT_V0, le16_to_cpu(free->ctrl));\n\tif (WARN_ON_ONCE((void *)&info[count] > end))\n\t\treturn;\n\n\tfor (i = 0; i < count; i++) {\n\t\tstruct mt76_txwi_cache *txwi;\n\t\tu16 msdu = le16_to_cpu(info[i]);\n\n\t\ttxwi = mt76_token_release(mdev, msdu, &wake);\n\t\tif (!txwi)\n\t\t\tcontinue;\n\n\t\tmt76_connac2_txwi_free(mdev, txwi, NULL, &free_list);\n\t}\n\n\tmt7915_mac_tx_free_done(dev, &free_list, wake);\n}\n\nstatic void mt7915_mac_add_txs(struct mt7915_dev *dev, void *data)\n{\n\tstruct mt7915_sta *msta = NULL;\n\tstruct mt76_wcid *wcid;\n\t__le32 *txs_data = data;\n\tu16 wcidx;\n\tu8 pid;\n\n\twcidx = le32_get_bits(txs_data[2], MT_TXS2_WCID);\n\tpid = le32_get_bits(txs_data[3], MT_TXS3_PID);\n\n\tif (pid < MT_PACKET_ID_WED)\n\t\treturn;\n\n\tif (wcidx >= mt7915_wtbl_size(dev))\n\t\treturn;\n\n\trcu_read_lock();\n\n\twcid = rcu_dereference(dev->mt76.wcid[wcidx]);\n\tif (!wcid)\n\t\tgoto out;\n\n\tmsta = container_of(wcid, struct mt7915_sta, wcid);\n\n\tif (pid == MT_PACKET_ID_WED)\n\t\tmt76_connac2_mac_fill_txs(&dev->mt76, wcid, txs_data);\n\telse\n\t\tmt76_connac2_mac_add_txs_skb(&dev->mt76, wcid, pid, txs_data);\n\n\tif (!wcid->sta)\n\t\tgoto out;\n\n\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\tif (list_empty(&msta->wcid.poll_list))\n\t\tlist_add_tail(&msta->wcid.poll_list, &dev->mt76.sta_poll_list);\n\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\nout:\n\trcu_read_unlock();\n}\n\nbool mt7915_rx_check(struct mt76_dev *mdev, void *data, int len)\n{\n\tstruct mt7915_dev *dev = container_of(mdev, struct mt7915_dev, mt76);\n\t__le32 *rxd = (__le32 *)data;\n\t__le32 *end = (__le32 *)&rxd[len / 4];\n\tenum rx_pkt_type type;\n\n\ttype = le32_get_bits(rxd[0], MT_RXD0_PKT_TYPE);\n\n\tswitch (type) {\n\tcase PKT_TYPE_TXRX_NOTIFY:\n\t\tmt7915_mac_tx_free(dev, data, len);\n\t\treturn false;\n\tcase PKT_TYPE_TXRX_NOTIFY_V0:\n\t\tmt7915_mac_tx_free_v0(dev, data, len);\n\t\treturn false;\n\tcase PKT_TYPE_TXS:\n\t\tfor (rxd += 2; rxd + 8 <= end; rxd += 8)\n\t\t\tmt7915_mac_add_txs(dev, rxd);\n\t\treturn false;\n\tcase PKT_TYPE_RX_FW_MONITOR:\n\t\tmt7915_debugfs_rx_fw_monitor(dev, data, len);\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nvoid mt7915_queue_rx_skb(struct mt76_dev *mdev, enum mt76_rxq_id q,\n\t\t\t struct sk_buff *skb, u32 *info)\n{\n\tstruct mt7915_dev *dev = container_of(mdev, struct mt7915_dev, mt76);\n\t__le32 *rxd = (__le32 *)skb->data;\n\t__le32 *end = (__le32 *)&skb->data[skb->len];\n\tenum rx_pkt_type type;\n\n\ttype = le32_get_bits(rxd[0], MT_RXD0_PKT_TYPE);\n\n\tswitch (type) {\n\tcase PKT_TYPE_TXRX_NOTIFY:\n\t\tmt7915_mac_tx_free(dev, skb->data, skb->len);\n\t\tnapi_consume_skb(skb, 1);\n\t\tbreak;\n\tcase PKT_TYPE_TXRX_NOTIFY_V0:\n\t\tmt7915_mac_tx_free_v0(dev, skb->data, skb->len);\n\t\tnapi_consume_skb(skb, 1);\n\t\tbreak;\n\tcase PKT_TYPE_RX_EVENT:\n\t\tmt7915_mcu_rx_event(dev, skb);\n\t\tbreak;\n\tcase PKT_TYPE_TXRXV:\n\t\tmt7915_mac_fill_rx_vector(dev, skb);\n\t\tbreak;\n\tcase PKT_TYPE_TXS:\n\t\tfor (rxd += 2; rxd + 8 <= end; rxd += 8)\n\t\t\tmt7915_mac_add_txs(dev, rxd);\n\t\tdev_kfree_skb(skb);\n\t\tbreak;\n\tcase PKT_TYPE_RX_FW_MONITOR:\n\t\tmt7915_debugfs_rx_fw_monitor(dev, skb->data, skb->len);\n\t\tdev_kfree_skb(skb);\n\t\tbreak;\n\tcase PKT_TYPE_NORMAL:\n\t\tif (!mt7915_mac_fill_rx(dev, skb, q, info)) {\n\t\t\tmt76_rx(&dev->mt76, q, skb);\n\t\t\treturn;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdev_kfree_skb(skb);\n\t\tbreak;\n\t}\n}\n\nvoid mt7915_mac_cca_stats_reset(struct mt7915_phy *phy)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tu32 reg = MT_WF_PHY_RX_CTRL1(phy->mt76->band_idx);\n\n\tmt76_clear(dev, reg, MT_WF_PHY_RX_CTRL1_STSCNT_EN);\n\tmt76_set(dev, reg, BIT(11) | BIT(9));\n}\n\nvoid mt7915_mac_reset_counters(struct mt7915_phy *phy)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tmt76_rr(dev, MT_TX_AGG_CNT(phy->mt76->band_idx, i));\n\t\tmt76_rr(dev, MT_TX_AGG_CNT2(phy->mt76->band_idx, i));\n\t}\n\n\tphy->mt76->survey_time = ktime_get_boottime();\n\tmemset(phy->mt76->aggr_stats, 0, sizeof(phy->mt76->aggr_stats));\n\n\t \n\tmt76_set(dev, MT_WF_RMAC_MIB_AIRTIME0(phy->mt76->band_idx),\n\t\t MT_WF_RMAC_MIB_RXTIME_CLR);\n\n\tmt7915_mcu_get_chan_mib_info(phy, true);\n}\n\nvoid mt7915_mac_set_timing(struct mt7915_phy *phy)\n{\n\ts16 coverage_class = phy->coverage_class;\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct mt7915_phy *ext_phy = mt7915_ext_phy(dev);\n\tu32 val, reg_offset;\n\tu32 cck = FIELD_PREP(MT_TIMEOUT_VAL_PLCP, 231) |\n\t\t  FIELD_PREP(MT_TIMEOUT_VAL_CCA, 48);\n\tu32 ofdm = FIELD_PREP(MT_TIMEOUT_VAL_PLCP, 60) |\n\t\t   FIELD_PREP(MT_TIMEOUT_VAL_CCA, 28);\n\tu8 band = phy->mt76->band_idx;\n\tint eifs_ofdm = 360, sifs = 10, offset;\n\tbool a_band = !(phy->mt76->chandef.chan->band == NL80211_BAND_2GHZ);\n\n\tif (!test_bit(MT76_STATE_RUNNING, &phy->mt76->state))\n\t\treturn;\n\n\tif (ext_phy)\n\t\tcoverage_class = max_t(s16, dev->phy.coverage_class,\n\t\t\t\t       ext_phy->coverage_class);\n\n\tmt76_set(dev, MT_ARB_SCR(band),\n\t\t MT_ARB_SCR_TX_DISABLE | MT_ARB_SCR_RX_DISABLE);\n\tudelay(1);\n\n\toffset = 3 * coverage_class;\n\treg_offset = FIELD_PREP(MT_TIMEOUT_VAL_PLCP, offset) |\n\t\t     FIELD_PREP(MT_TIMEOUT_VAL_CCA, offset);\n\n\tif (!is_mt7915(&dev->mt76)) {\n\t\tif (!a_band) {\n\t\t\tmt76_wr(dev, MT_TMAC_ICR1(band),\n\t\t\t\tFIELD_PREP(MT_IFS_EIFS_CCK, 314));\n\t\t\teifs_ofdm = 78;\n\t\t} else {\n\t\t\teifs_ofdm = 84;\n\t\t}\n\t} else if (a_band) {\n\t\tsifs = 16;\n\t}\n\n\tmt76_wr(dev, MT_TMAC_CDTR(band), cck + reg_offset);\n\tmt76_wr(dev, MT_TMAC_ODTR(band), ofdm + reg_offset);\n\tmt76_wr(dev, MT_TMAC_ICR0(band),\n\t\tFIELD_PREP(MT_IFS_EIFS_OFDM, eifs_ofdm) |\n\t\tFIELD_PREP(MT_IFS_RIFS, 2) |\n\t\tFIELD_PREP(MT_IFS_SIFS, sifs) |\n\t\tFIELD_PREP(MT_IFS_SLOT, phy->slottime));\n\n\tif (phy->slottime < 20 || a_band)\n\t\tval = MT7915_CFEND_RATE_DEFAULT;\n\telse\n\t\tval = MT7915_CFEND_RATE_11B;\n\n\tmt76_rmw_field(dev, MT_AGG_ACR0(band), MT_AGG_ACR_CFEND_RATE, val);\n\tmt76_clear(dev, MT_ARB_SCR(band),\n\t\t   MT_ARB_SCR_TX_DISABLE | MT_ARB_SCR_RX_DISABLE);\n}\n\nvoid mt7915_mac_enable_nf(struct mt7915_dev *dev, bool band)\n{\n\tu32 reg;\n\n\treg = is_mt7915(&dev->mt76) ? MT_WF_PHY_RXTD12(band) :\n\t\t\t\t      MT_WF_PHY_RXTD12_MT7916(band);\n\tmt76_set(dev, reg,\n\t\t MT_WF_PHY_RXTD12_IRPI_SW_CLR_ONLY |\n\t\t MT_WF_PHY_RXTD12_IRPI_SW_CLR);\n\n\treg = is_mt7915(&dev->mt76) ? MT_WF_PHY_RX_CTRL1(band) :\n\t\t\t\t      MT_WF_PHY_RX_CTRL1_MT7916(band);\n\tmt76_set(dev, reg, FIELD_PREP(MT_WF_PHY_RX_CTRL1_IPI_EN, 0x5));\n}\n\nstatic u8\nmt7915_phy_get_nf(struct mt7915_phy *phy, int idx)\n{\n\tstatic const u8 nf_power[] = { 92, 89, 86, 83, 80, 75, 70, 65, 60, 55, 52 };\n\tstruct mt7915_dev *dev = phy->dev;\n\tu32 val, sum = 0, n = 0;\n\tint nss, i;\n\n\tfor (nss = 0; nss < hweight8(phy->mt76->chainmask); nss++) {\n\t\tu32 reg = is_mt7915(&dev->mt76) ?\n\t\t\tMT_WF_IRPI_NSS(0, nss + (idx << dev->dbdc_support)) :\n\t\t\tMT_WF_IRPI_NSS_MT7916(idx, nss);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(nf_power); i++, reg += 4) {\n\t\t\tval = mt76_rr(dev, reg);\n\t\t\tsum += val * nf_power[i];\n\t\t\tn += val;\n\t\t}\n\t}\n\n\tif (!n)\n\t\treturn 0;\n\n\treturn sum / n;\n}\n\nvoid mt7915_update_channel(struct mt76_phy *mphy)\n{\n\tstruct mt7915_phy *phy = (struct mt7915_phy *)mphy->priv;\n\tstruct mt76_channel_state *state = mphy->chan_state;\n\tint nf;\n\n\tmt7915_mcu_get_chan_mib_info(phy, false);\n\n\tnf = mt7915_phy_get_nf(phy, phy->mt76->band_idx);\n\tif (!phy->noise)\n\t\tphy->noise = nf << 4;\n\telse if (nf)\n\t\tphy->noise += nf - (phy->noise >> 4);\n\n\tstate->noise = -(phy->noise >> 4);\n}\n\nstatic bool\nmt7915_wait_reset_state(struct mt7915_dev *dev, u32 state)\n{\n\tbool ret;\n\n\tret = wait_event_timeout(dev->reset_wait,\n\t\t\t\t (READ_ONCE(dev->recovery.state) & state),\n\t\t\t\t MT7915_RESET_TIMEOUT);\n\n\tWARN(!ret, \"Timeout waiting for MCU reset state %x\\n\", state);\n\treturn ret;\n}\n\nstatic void\nmt7915_update_vif_beacon(void *priv, u8 *mac, struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_hw *hw = priv;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_AP:\n\t\tmt7915_mcu_add_beacon(hw, vif, vif->bss_conf.enable_beacon,\n\t\t\t\t      BSS_CHANGED_BEACON_ENABLED);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\nmt7915_update_beacons(struct mt7915_dev *dev)\n{\n\tstruct mt76_phy *mphy_ext = dev->mt76.phys[MT_BAND1];\n\n\tieee80211_iterate_active_interfaces(dev->mt76.hw,\n\t\tIEEE80211_IFACE_ITER_RESUME_ALL,\n\t\tmt7915_update_vif_beacon, dev->mt76.hw);\n\n\tif (!mphy_ext)\n\t\treturn;\n\n\tieee80211_iterate_active_interfaces(mphy_ext->hw,\n\t\tIEEE80211_IFACE_ITER_RESUME_ALL,\n\t\tmt7915_update_vif_beacon, mphy_ext->hw);\n}\n\nstatic int\nmt7915_mac_restart(struct mt7915_dev *dev)\n{\n\tstruct mt7915_phy *phy2;\n\tstruct mt76_phy *ext_phy;\n\tstruct mt76_dev *mdev = &dev->mt76;\n\tint i, ret;\n\n\text_phy = dev->mt76.phys[MT_BAND1];\n\tphy2 = ext_phy ? ext_phy->priv : NULL;\n\n\tif (dev->hif2) {\n\t\tmt76_wr(dev, MT_INT1_MASK_CSR, 0x0);\n\t\tmt76_wr(dev, MT_INT1_SOURCE_CSR, ~0);\n\t}\n\n\tif (dev_is_pci(mdev->dev)) {\n\t\tmt76_wr(dev, MT_PCIE_MAC_INT_ENABLE, 0x0);\n\t\tif (dev->hif2) {\n\t\t\tif (is_mt7915(mdev))\n\t\t\t\tmt76_wr(dev, MT_PCIE1_MAC_INT_ENABLE, 0x0);\n\t\t\telse\n\t\t\t\tmt76_wr(dev, MT_PCIE1_MAC_INT_ENABLE_MT7916, 0x0);\n\t\t}\n\t}\n\n\tset_bit(MT76_RESET, &dev->mphy.state);\n\tset_bit(MT76_MCU_RESET, &dev->mphy.state);\n\twake_up(&dev->mt76.mcu.wait);\n\tif (ext_phy) {\n\t\tset_bit(MT76_RESET, &ext_phy->state);\n\t\tset_bit(MT76_MCU_RESET, &ext_phy->state);\n\t}\n\n\t \n\tmt76_txq_schedule_all(&dev->mphy);\n\tif (ext_phy)\n\t\tmt76_txq_schedule_all(ext_phy);\n\n\t \n\tmt76_worker_disable(&dev->mt76.tx_worker);\n\tmt76_for_each_q_rx(mdev, i) {\n\t\tif (mdev->q_rx[i].ndesc)\n\t\t\tnapi_disable(&dev->mt76.napi[i]);\n\t}\n\tnapi_disable(&dev->mt76.tx_napi);\n\n\t \n\tmt76_connac2_tx_token_put(&dev->mt76);\n\tidr_init(&dev->mt76.token);\n\n\tmt7915_dma_reset(dev, true);\n\n\tlocal_bh_disable();\n\tmt76_for_each_q_rx(mdev, i) {\n\t\tif (mdev->q_rx[i].ndesc) {\n\t\t\tnapi_enable(&dev->mt76.napi[i]);\n\t\t\tnapi_schedule(&dev->mt76.napi[i]);\n\t\t}\n\t}\n\tlocal_bh_enable();\n\tclear_bit(MT76_MCU_RESET, &dev->mphy.state);\n\tclear_bit(MT76_STATE_MCU_RUNNING, &dev->mphy.state);\n\n\tmt76_wr(dev, MT_INT_MASK_CSR, dev->mt76.mmio.irqmask);\n\tmt76_wr(dev, MT_INT_SOURCE_CSR, ~0);\n\n\tif (dev->hif2) {\n\t\tmt76_wr(dev, MT_INT1_MASK_CSR, dev->mt76.mmio.irqmask);\n\t\tmt76_wr(dev, MT_INT1_SOURCE_CSR, ~0);\n\t}\n\tif (dev_is_pci(mdev->dev)) {\n\t\tmt76_wr(dev, MT_PCIE_MAC_INT_ENABLE, 0xff);\n\t\tif (dev->hif2) {\n\t\t\tif (is_mt7915(mdev))\n\t\t\t\tmt76_wr(dev, MT_PCIE1_MAC_INT_ENABLE, 0xff);\n\t\t\telse\n\t\t\t\tmt76_wr(dev, MT_PCIE1_MAC_INT_ENABLE_MT7916, 0xff);\n\t\t}\n\t}\n\n\t \n\tret = mt7915_mcu_init_firmware(dev);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = mt7915_mcu_set_eeprom(dev);\n\tif (ret)\n\t\tgoto out;\n\n\tmt7915_mac_init(dev);\n\tmt7915_init_txpower(dev, &dev->mphy.sband_2g.sband);\n\tmt7915_init_txpower(dev, &dev->mphy.sband_5g.sband);\n\tret = mt7915_txbf_init(dev);\n\n\tif (test_bit(MT76_STATE_RUNNING, &dev->mphy.state)) {\n\t\tret = mt7915_run(dev->mphy.hw);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (ext_phy && test_bit(MT76_STATE_RUNNING, &ext_phy->state)) {\n\t\tret = mt7915_run(ext_phy->hw);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\t \n\tclear_bit(MT76_RESET, &dev->mphy.state);\n\tif (phy2)\n\t\tclear_bit(MT76_RESET, &phy2->mt76->state);\n\n\tlocal_bh_disable();\n\tnapi_enable(&dev->mt76.tx_napi);\n\tnapi_schedule(&dev->mt76.tx_napi);\n\tlocal_bh_enable();\n\n\tmt76_worker_enable(&dev->mt76.tx_worker);\n\n\treturn ret;\n}\n\nstatic void\nmt7915_mac_full_reset(struct mt7915_dev *dev)\n{\n\tstruct mt76_phy *ext_phy;\n\tint i;\n\n\text_phy = dev->mt76.phys[MT_BAND1];\n\n\tdev->recovery.hw_full_reset = true;\n\n\twake_up(&dev->mt76.mcu.wait);\n\tieee80211_stop_queues(mt76_hw(dev));\n\tif (ext_phy)\n\t\tieee80211_stop_queues(ext_phy->hw);\n\n\tcancel_delayed_work_sync(&dev->mphy.mac_work);\n\tif (ext_phy)\n\t\tcancel_delayed_work_sync(&ext_phy->mac_work);\n\n\tmutex_lock(&dev->mt76.mutex);\n\tfor (i = 0; i < 10; i++) {\n\t\tif (!mt7915_mac_restart(dev))\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&dev->mt76.mutex);\n\n\tif (i == 10)\n\t\tdev_err(dev->mt76.dev, \"chip full reset failed\\n\");\n\n\tieee80211_restart_hw(mt76_hw(dev));\n\tif (ext_phy)\n\t\tieee80211_restart_hw(ext_phy->hw);\n\n\tieee80211_wake_queues(mt76_hw(dev));\n\tif (ext_phy)\n\t\tieee80211_wake_queues(ext_phy->hw);\n\n\tdev->recovery.hw_full_reset = false;\n\tieee80211_queue_delayed_work(mt76_hw(dev), &dev->mphy.mac_work,\n\t\t\t\t     MT7915_WATCHDOG_TIME);\n\tif (ext_phy)\n\t\tieee80211_queue_delayed_work(ext_phy->hw,\n\t\t\t\t\t     &ext_phy->mac_work,\n\t\t\t\t\t     MT7915_WATCHDOG_TIME);\n}\n\n \nvoid mt7915_mac_reset_work(struct work_struct *work)\n{\n\tstruct mt7915_phy *phy2;\n\tstruct mt76_phy *ext_phy;\n\tstruct mt7915_dev *dev;\n\tint i;\n\n\tdev = container_of(work, struct mt7915_dev, reset_work);\n\text_phy = dev->mt76.phys[MT_BAND1];\n\tphy2 = ext_phy ? ext_phy->priv : NULL;\n\n\t \n\tif (dev->recovery.restart) {\n\t\t \n\t\tmt76_clear(dev, MT_WFDMA0_MCU_HOST_INT_ENA,\n\t\t\t   MT_MCU_CMD_WDT_MASK);\n\n\t\tif (READ_ONCE(dev->recovery.state) & MT_MCU_CMD_WA_WDT)\n\t\t\tdev->recovery.wa_reset_count++;\n\t\telse\n\t\t\tdev->recovery.wm_reset_count++;\n\n\t\tmt7915_mac_full_reset(dev);\n\n\t\t \n\t\tmt7915_irq_enable(dev, MT_INT_MCU_CMD);\n\t\tmt7915_irq_disable(dev, 0);\n\n\t\t \n\t\tmt76_set(dev, MT_WFDMA0_MCU_HOST_INT_ENA, MT_MCU_CMD_WDT_MASK);\n\n\t\tdev->recovery.state = MT_MCU_CMD_NORMAL_STATE;\n\t\tdev->recovery.restart = false;\n\t\treturn;\n\t}\n\n\t \n\tif (!(READ_ONCE(dev->recovery.state) & MT_MCU_CMD_STOP_DMA))\n\t\treturn;\n\n\tif (mtk_wed_device_active(&dev->mt76.mmio.wed)) {\n\t\tmtk_wed_device_stop(&dev->mt76.mmio.wed);\n\t\tif (!is_mt798x(&dev->mt76))\n\t\t\tmt76_wr(dev, MT_INT_WED_MASK_CSR, 0);\n\t}\n\n\tieee80211_stop_queues(mt76_hw(dev));\n\tif (ext_phy)\n\t\tieee80211_stop_queues(ext_phy->hw);\n\n\tset_bit(MT76_RESET, &dev->mphy.state);\n\tset_bit(MT76_MCU_RESET, &dev->mphy.state);\n\twake_up(&dev->mt76.mcu.wait);\n\tcancel_delayed_work_sync(&dev->mphy.mac_work);\n\tif (phy2) {\n\t\tset_bit(MT76_RESET, &phy2->mt76->state);\n\t\tcancel_delayed_work_sync(&phy2->mt76->mac_work);\n\t}\n\tmt76_worker_disable(&dev->mt76.tx_worker);\n\tmt76_for_each_q_rx(&dev->mt76, i)\n\t\tnapi_disable(&dev->mt76.napi[i]);\n\tnapi_disable(&dev->mt76.tx_napi);\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tmt76_wr(dev, MT_MCU_INT_EVENT, MT_MCU_INT_EVENT_DMA_STOPPED);\n\n\tif (mt7915_wait_reset_state(dev, MT_MCU_CMD_RESET_DONE)) {\n\t\tmt7915_dma_reset(dev, false);\n\n\t\tmt76_connac2_tx_token_put(&dev->mt76);\n\t\tidr_init(&dev->mt76.token);\n\n\t\tmt76_wr(dev, MT_MCU_INT_EVENT, MT_MCU_INT_EVENT_DMA_INIT);\n\t\tmt7915_wait_reset_state(dev, MT_MCU_CMD_RECOVERY_DONE);\n\t}\n\n\tmt76_wr(dev, MT_MCU_INT_EVENT, MT_MCU_INT_EVENT_RESET_DONE);\n\tmt7915_wait_reset_state(dev, MT_MCU_CMD_NORMAL_STATE);\n\n\t \n\tmt7915_dma_start(dev, false, false);\n\n\tclear_bit(MT76_MCU_RESET, &dev->mphy.state);\n\tclear_bit(MT76_RESET, &dev->mphy.state);\n\tif (phy2)\n\t\tclear_bit(MT76_RESET, &phy2->mt76->state);\n\n\tlocal_bh_disable();\n\tmt76_for_each_q_rx(&dev->mt76, i) {\n\t\tnapi_enable(&dev->mt76.napi[i]);\n\t\tnapi_schedule(&dev->mt76.napi[i]);\n\t}\n\tlocal_bh_enable();\n\n\ttasklet_schedule(&dev->mt76.irq_tasklet);\n\n\tmt76_worker_enable(&dev->mt76.tx_worker);\n\n\tlocal_bh_disable();\n\tnapi_enable(&dev->mt76.tx_napi);\n\tnapi_schedule(&dev->mt76.tx_napi);\n\tlocal_bh_enable();\n\n\tieee80211_wake_queues(mt76_hw(dev));\n\tif (ext_phy)\n\t\tieee80211_wake_queues(ext_phy->hw);\n\n\tmutex_unlock(&dev->mt76.mutex);\n\n\tmt7915_update_beacons(dev);\n\n\tieee80211_queue_delayed_work(mt76_hw(dev), &dev->mphy.mac_work,\n\t\t\t\t     MT7915_WATCHDOG_TIME);\n\tif (phy2)\n\t\tieee80211_queue_delayed_work(ext_phy->hw,\n\t\t\t\t\t     &phy2->mt76->mac_work,\n\t\t\t\t\t     MT7915_WATCHDOG_TIME);\n}\n\n \nvoid mt7915_mac_dump_work(struct work_struct *work)\n{\n\tconst struct mt7915_mem_region *mem_region;\n\tstruct mt7915_crash_data *crash_data;\n\tstruct mt7915_dev *dev;\n\tstruct mt7915_mem_hdr *hdr;\n\tsize_t buf_len;\n\tint i;\n\tu32 num;\n\tu8 *buf;\n\n\tdev = container_of(work, struct mt7915_dev, dump_work);\n\n\tmutex_lock(&dev->dump_mutex);\n\n\tcrash_data = mt7915_coredump_new(dev);\n\tif (!crash_data) {\n\t\tmutex_unlock(&dev->dump_mutex);\n\t\tgoto skip_coredump;\n\t}\n\n\tmem_region = mt7915_coredump_get_mem_layout(dev, &num);\n\tif (!mem_region || !crash_data->memdump_buf_len) {\n\t\tmutex_unlock(&dev->dump_mutex);\n\t\tgoto skip_memdump;\n\t}\n\n\tbuf = crash_data->memdump_buf;\n\tbuf_len = crash_data->memdump_buf_len;\n\n\t \n\tmemset(buf, 0, buf_len);\n\tfor (i = 0; i < num; i++) {\n\t\tif (mem_region->len > buf_len) {\n\t\t\tdev_warn(dev->mt76.dev, \"%s len %lu is too large\\n\",\n\t\t\t\t mem_region->name,\n\t\t\t\t (unsigned long)mem_region->len);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\thdr = (void *)buf;\n\t\tbuf += sizeof(*hdr);\n\t\tbuf_len -= sizeof(*hdr);\n\n\t\tmt7915_memcpy_fromio(dev, buf, mem_region->start,\n\t\t\t\t     mem_region->len);\n\n\t\thdr->start = mem_region->start;\n\t\thdr->len = mem_region->len;\n\n\t\tif (!mem_region->len)\n\t\t\t \n\t\t\tbreak;\n\n\t\tbuf += mem_region->len;\n\t\tbuf_len -= mem_region->len;\n\n\t\tmem_region++;\n\t}\n\n\tmutex_unlock(&dev->dump_mutex);\n\nskip_memdump:\n\tmt7915_coredump_submit(dev);\nskip_coredump:\n\tqueue_work(dev->mt76.wq, &dev->reset_work);\n}\n\nvoid mt7915_reset(struct mt7915_dev *dev)\n{\n\tif (!dev->recovery.hw_init_done)\n\t\treturn;\n\n\tif (dev->recovery.hw_full_reset)\n\t\treturn;\n\n\t \n\tif (READ_ONCE(dev->recovery.state) & MT_MCU_CMD_WDT_MASK) {\n\t\tdev->recovery.restart = true;\n\t\tdev_info(dev->mt76.dev,\n\t\t\t \"%s indicated firmware crash, attempting recovery\\n\",\n\t\t\t wiphy_name(dev->mt76.hw->wiphy));\n\n\t\tmt7915_irq_disable(dev, MT_INT_MCU_CMD);\n\t\tqueue_work(dev->mt76.wq, &dev->dump_work);\n\t\treturn;\n\t}\n\n\tqueue_work(dev->mt76.wq, &dev->reset_work);\n\twake_up(&dev->reset_wait);\n}\n\nvoid mt7915_mac_update_stats(struct mt7915_phy *phy)\n{\n\tstruct mt76_mib_stats *mib = &phy->mib;\n\tstruct mt7915_dev *dev = phy->dev;\n\tint i, aggr0 = 0, aggr1, cnt;\n\tu8 band = phy->mt76->band_idx;\n\tu32 val;\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR3(band));\n\tmib->fcs_err_cnt += is_mt7915(&dev->mt76) ?\n\t\tFIELD_GET(MT_MIB_SDR3_FCS_ERR_MASK, cnt) :\n\t\tFIELD_GET(MT_MIB_SDR3_FCS_ERR_MASK_MT7916, cnt);\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR4(band));\n\tmib->rx_fifo_full_cnt += FIELD_GET(MT_MIB_SDR4_RX_FIFO_FULL_MASK, cnt);\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR5(band));\n\tmib->rx_mpdu_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR6(band));\n\tmib->channel_idle_cnt += FIELD_GET(MT_MIB_SDR6_CHANNEL_IDL_CNT_MASK, cnt);\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR7(band));\n\tmib->rx_vector_mismatch_cnt +=\n\t\tFIELD_GET(MT_MIB_SDR7_RX_VECTOR_MISMATCH_CNT_MASK, cnt);\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR8(band));\n\tmib->rx_delimiter_fail_cnt +=\n\t\tFIELD_GET(MT_MIB_SDR8_RX_DELIMITER_FAIL_CNT_MASK, cnt);\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR10(band));\n\tmib->rx_mrdy_cnt += is_mt7915(&dev->mt76) ?\n\t\tFIELD_GET(MT_MIB_SDR10_MRDY_COUNT_MASK, cnt) :\n\t\tFIELD_GET(MT_MIB_SDR10_MRDY_COUNT_MASK_MT7916, cnt);\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR11(band));\n\tmib->rx_len_mismatch_cnt +=\n\t\tFIELD_GET(MT_MIB_SDR11_RX_LEN_MISMATCH_CNT_MASK, cnt);\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR12(band));\n\tmib->tx_ampdu_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR13(band));\n\tmib->tx_stop_q_empty_cnt +=\n\t\tFIELD_GET(MT_MIB_SDR13_TX_STOP_Q_EMPTY_CNT_MASK, cnt);\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR14(band));\n\tmib->tx_mpdu_attempts_cnt += is_mt7915(&dev->mt76) ?\n\t\tFIELD_GET(MT_MIB_SDR14_TX_MPDU_ATTEMPTS_CNT_MASK, cnt) :\n\t\tFIELD_GET(MT_MIB_SDR14_TX_MPDU_ATTEMPTS_CNT_MASK_MT7916, cnt);\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR15(band));\n\tmib->tx_mpdu_success_cnt += is_mt7915(&dev->mt76) ?\n\t\tFIELD_GET(MT_MIB_SDR15_TX_MPDU_SUCCESS_CNT_MASK, cnt) :\n\t\tFIELD_GET(MT_MIB_SDR15_TX_MPDU_SUCCESS_CNT_MASK_MT7916, cnt);\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR16(band));\n\tmib->primary_cca_busy_time +=\n\t\tFIELD_GET(MT_MIB_SDR16_PRIMARY_CCA_BUSY_TIME_MASK, cnt);\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR17(band));\n\tmib->secondary_cca_busy_time +=\n\t\tFIELD_GET(MT_MIB_SDR17_SECONDARY_CCA_BUSY_TIME_MASK, cnt);\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR18(band));\n\tmib->primary_energy_detect_time +=\n\t\tFIELD_GET(MT_MIB_SDR18_PRIMARY_ENERGY_DETECT_TIME_MASK, cnt);\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR19(band));\n\tmib->cck_mdrdy_time += FIELD_GET(MT_MIB_SDR19_CCK_MDRDY_TIME_MASK, cnt);\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR20(band));\n\tmib->ofdm_mdrdy_time +=\n\t\tFIELD_GET(MT_MIB_SDR20_OFDM_VHT_MDRDY_TIME_MASK, cnt);\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR21(band));\n\tmib->green_mdrdy_time +=\n\t\tFIELD_GET(MT_MIB_SDR21_GREEN_MDRDY_TIME_MASK, cnt);\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR22(band));\n\tmib->rx_ampdu_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR23(band));\n\tmib->rx_ampdu_bytes_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR24(band));\n\tmib->rx_ampdu_valid_subframe_cnt += is_mt7915(&dev->mt76) ?\n\t\tFIELD_GET(MT_MIB_SDR24_RX_AMPDU_SF_CNT_MASK, cnt) :\n\t\tFIELD_GET(MT_MIB_SDR24_RX_AMPDU_SF_CNT_MASK_MT7916, cnt);\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR25(band));\n\tmib->rx_ampdu_valid_subframe_bytes_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR27(band));\n\tmib->tx_rwp_fail_cnt +=\n\t\tFIELD_GET(MT_MIB_SDR27_TX_RWP_FAIL_CNT_MASK, cnt);\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR28(band));\n\tmib->tx_rwp_need_cnt +=\n\t\tFIELD_GET(MT_MIB_SDR28_TX_RWP_NEED_CNT_MASK, cnt);\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR29(band));\n\tmib->rx_pfdrop_cnt += is_mt7915(&dev->mt76) ?\n\t\tFIELD_GET(MT_MIB_SDR29_RX_PFDROP_CNT_MASK, cnt) :\n\t\tFIELD_GET(MT_MIB_SDR29_RX_PFDROP_CNT_MASK_MT7916, cnt);\n\n\tcnt = mt76_rr(dev, MT_MIB_SDRVEC(band));\n\tmib->rx_vec_queue_overflow_drop_cnt += is_mt7915(&dev->mt76) ?\n\t\tFIELD_GET(MT_MIB_SDR30_RX_VEC_QUEUE_OVERFLOW_DROP_CNT_MASK, cnt) :\n\t\tFIELD_GET(MT_MIB_SDR30_RX_VEC_QUEUE_OVERFLOW_DROP_CNT_MASK_MT7916, cnt);\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR31(band));\n\tmib->rx_ba_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_SDRMUBF(band));\n\tmib->tx_bf_cnt += FIELD_GET(MT_MIB_MU_BF_TX_CNT, cnt);\n\n\tcnt = mt76_rr(dev, MT_MIB_DR8(band));\n\tmib->tx_mu_mpdu_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_DR9(band));\n\tmib->tx_mu_acked_mpdu_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_DR11(band));\n\tmib->tx_su_acked_mpdu_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_ETBF_PAR_RPT0(band));\n\tmib->tx_bf_rx_fb_bw = FIELD_GET(MT_ETBF_PAR_RPT0_FB_BW, cnt);\n\tmib->tx_bf_rx_fb_nc_cnt += FIELD_GET(MT_ETBF_PAR_RPT0_FB_NC, cnt);\n\tmib->tx_bf_rx_fb_nr_cnt += FIELD_GET(MT_ETBF_PAR_RPT0_FB_NR, cnt);\n\n\tfor (i = 0; i < ARRAY_SIZE(mib->tx_amsdu); i++) {\n\t\tcnt = mt76_rr(dev, MT_PLE_AMSDU_PACK_MSDU_CNT(i));\n\t\tmib->tx_amsdu[i] += cnt;\n\t\tmib->tx_amsdu_cnt += cnt;\n\t}\n\n\tif (is_mt7915(&dev->mt76)) {\n\t\tfor (i = 0, aggr1 = aggr0 + 8; i < 4; i++) {\n\t\t\tval = mt76_rr(dev, MT_MIB_MB_SDR1(band, (i << 4)));\n\t\t\tmib->ba_miss_cnt +=\n\t\t\t\tFIELD_GET(MT_MIB_BA_MISS_COUNT_MASK, val);\n\t\t\tmib->ack_fail_cnt +=\n\t\t\t\tFIELD_GET(MT_MIB_ACK_FAIL_COUNT_MASK, val);\n\n\t\t\tval = mt76_rr(dev, MT_MIB_MB_SDR0(band, (i << 4)));\n\t\t\tmib->rts_cnt += FIELD_GET(MT_MIB_RTS_COUNT_MASK, val);\n\t\t\tmib->rts_retries_cnt +=\n\t\t\t\tFIELD_GET(MT_MIB_RTS_RETRIES_COUNT_MASK, val);\n\n\t\t\tval = mt76_rr(dev, MT_TX_AGG_CNT(band, i));\n\t\t\tphy->mt76->aggr_stats[aggr0++] += val & 0xffff;\n\t\t\tphy->mt76->aggr_stats[aggr0++] += val >> 16;\n\n\t\t\tval = mt76_rr(dev, MT_TX_AGG_CNT2(band, i));\n\t\t\tphy->mt76->aggr_stats[aggr1++] += val & 0xffff;\n\t\t\tphy->mt76->aggr_stats[aggr1++] += val >> 16;\n\t\t}\n\n\t\tcnt = mt76_rr(dev, MT_MIB_SDR32(band));\n\t\tmib->tx_pkt_ebf_cnt += FIELD_GET(MT_MIB_SDR32_TX_PKT_EBF_CNT, cnt);\n\n\t\tcnt = mt76_rr(dev, MT_MIB_SDR33(band));\n\t\tmib->tx_pkt_ibf_cnt += FIELD_GET(MT_MIB_SDR33_TX_PKT_IBF_CNT, cnt);\n\n\t\tcnt = mt76_rr(dev, MT_ETBF_TX_APP_CNT(band));\n\t\tmib->tx_bf_ibf_ppdu_cnt += FIELD_GET(MT_ETBF_TX_IBF_CNT, cnt);\n\t\tmib->tx_bf_ebf_ppdu_cnt += FIELD_GET(MT_ETBF_TX_EBF_CNT, cnt);\n\n\t\tcnt = mt76_rr(dev, MT_ETBF_TX_NDP_BFRP(band));\n\t\tmib->tx_bf_fb_cpl_cnt += FIELD_GET(MT_ETBF_TX_FB_CPL, cnt);\n\t\tmib->tx_bf_fb_trig_cnt += FIELD_GET(MT_ETBF_TX_FB_TRI, cnt);\n\n\t\tcnt = mt76_rr(dev, MT_ETBF_RX_FB_CNT(band));\n\t\tmib->tx_bf_rx_fb_all_cnt += FIELD_GET(MT_ETBF_RX_FB_ALL, cnt);\n\t\tmib->tx_bf_rx_fb_he_cnt += FIELD_GET(MT_ETBF_RX_FB_HE, cnt);\n\t\tmib->tx_bf_rx_fb_vht_cnt += FIELD_GET(MT_ETBF_RX_FB_VHT, cnt);\n\t\tmib->tx_bf_rx_fb_ht_cnt += FIELD_GET(MT_ETBF_RX_FB_HT, cnt);\n\t} else {\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\t \n\t\t\tval = mt76_rr(dev, MT_MIB_MB_SDR0(band, (i << 2)));\n\t\t\tmib->rts_cnt += FIELD_GET(GENMASK(15, 0), val);\n\t\t\tmib->rts_cnt += FIELD_GET(GENMASK(31, 16), val);\n\n\t\t\t \n\t\t\tval = mt76_rr(dev, MT_MIB_MB_SDR1(band, (i << 2)));\n\t\t\tmib->rts_retries_cnt += FIELD_GET(GENMASK(15, 0), val);\n\t\t\tmib->rts_retries_cnt += FIELD_GET(GENMASK(31, 16), val);\n\n\t\t\t \n\t\t\tval = mt76_rr(dev, MT_MIB_MB_SDR2(band, (i << 2)));\n\t\t\tmib->ba_miss_cnt += FIELD_GET(GENMASK(15, 0), val);\n\t\t\tmib->ba_miss_cnt += FIELD_GET(GENMASK(31, 16), val);\n\n\t\t\t \n\t\t\tval = mt76_rr(dev, MT_MIB_MB_BFTF(band, (i << 2)));\n\t\t\tmib->ack_fail_cnt += FIELD_GET(GENMASK(15, 0), val);\n\t\t\tmib->ack_fail_cnt += FIELD_GET(GENMASK(31, 16), val);\n\t\t}\n\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tval = mt76_rr(dev, MT_TX_AGG_CNT(band, i));\n\t\t\tphy->mt76->aggr_stats[aggr0++] += FIELD_GET(GENMASK(15, 0), val);\n\t\t\tphy->mt76->aggr_stats[aggr0++] += FIELD_GET(GENMASK(31, 16), val);\n\t\t}\n\n\t\tcnt = mt76_rr(dev, MT_MIB_SDR32(band));\n\t\tmib->tx_pkt_ibf_cnt += FIELD_GET(MT_MIB_SDR32_TX_PKT_IBF_CNT, cnt);\n\t\tmib->tx_bf_ibf_ppdu_cnt += FIELD_GET(MT_MIB_SDR32_TX_PKT_IBF_CNT, cnt);\n\t\tmib->tx_pkt_ebf_cnt += FIELD_GET(MT_MIB_SDR32_TX_PKT_EBF_CNT, cnt);\n\t\tmib->tx_bf_ebf_ppdu_cnt += FIELD_GET(MT_MIB_SDR32_TX_PKT_EBF_CNT, cnt);\n\n\t\tcnt = mt76_rr(dev, MT_MIB_BFCR7(band));\n\t\tmib->tx_bf_fb_cpl_cnt += FIELD_GET(MT_MIB_BFCR7_BFEE_TX_FB_CPL, cnt);\n\n\t\tcnt = mt76_rr(dev, MT_MIB_BFCR2(band));\n\t\tmib->tx_bf_fb_trig_cnt += FIELD_GET(MT_MIB_BFCR2_BFEE_TX_FB_TRIG, cnt);\n\n\t\tcnt = mt76_rr(dev, MT_MIB_BFCR0(band));\n\t\tmib->tx_bf_rx_fb_vht_cnt += FIELD_GET(MT_MIB_BFCR0_RX_FB_VHT, cnt);\n\t\tmib->tx_bf_rx_fb_all_cnt += FIELD_GET(MT_MIB_BFCR0_RX_FB_VHT, cnt);\n\t\tmib->tx_bf_rx_fb_ht_cnt += FIELD_GET(MT_MIB_BFCR0_RX_FB_HT, cnt);\n\t\tmib->tx_bf_rx_fb_all_cnt += FIELD_GET(MT_MIB_BFCR0_RX_FB_HT, cnt);\n\n\t\tcnt = mt76_rr(dev, MT_MIB_BFCR1(band));\n\t\tmib->tx_bf_rx_fb_he_cnt += FIELD_GET(MT_MIB_BFCR1_RX_FB_HE, cnt);\n\t\tmib->tx_bf_rx_fb_all_cnt += FIELD_GET(MT_MIB_BFCR1_RX_FB_HE, cnt);\n\t}\n}\n\nstatic void mt7915_mac_severe_check(struct mt7915_phy *phy)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tu32 trb;\n\n\tif (!phy->omac_mask)\n\t\treturn;\n\n\t \n\ttrb = mt76_rr(dev, MT_TRB_RXPSR0(phy->mt76->band_idx));\n\n\tif ((FIELD_GET(MT_TRB_RXPSR0_RX_RMAC_PTR, trb) !=\n\t     FIELD_GET(MT_TRB_RXPSR0_RX_WTBL_PTR, trb)) &&\n\t    (FIELD_GET(MT_TRB_RXPSR0_RX_RMAC_PTR, phy->trb_ts) !=\n\t     FIELD_GET(MT_TRB_RXPSR0_RX_WTBL_PTR, phy->trb_ts)) &&\n\t    trb == phy->trb_ts)\n\t\tmt7915_mcu_set_ser(dev, SER_RECOVER, SER_SET_RECOVER_L3_RX_ABORT,\n\t\t\t\t   phy->mt76->band_idx);\n\n\tphy->trb_ts = trb;\n}\n\nvoid mt7915_mac_sta_rc_work(struct work_struct *work)\n{\n\tstruct mt7915_dev *dev = container_of(work, struct mt7915_dev, rc_work);\n\tstruct ieee80211_sta *sta;\n\tstruct ieee80211_vif *vif;\n\tstruct mt7915_sta *msta;\n\tu32 changed;\n\tLIST_HEAD(list);\n\n\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\tlist_splice_init(&dev->sta_rc_list, &list);\n\n\twhile (!list_empty(&list)) {\n\t\tmsta = list_first_entry(&list, struct mt7915_sta, rc_list);\n\t\tlist_del_init(&msta->rc_list);\n\t\tchanged = msta->changed;\n\t\tmsta->changed = 0;\n\t\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\n\t\tsta = container_of((void *)msta, struct ieee80211_sta, drv_priv);\n\t\tvif = container_of((void *)msta->vif, struct ieee80211_vif, drv_priv);\n\n\t\tif (changed & (IEEE80211_RC_SUPP_RATES_CHANGED |\n\t\t\t       IEEE80211_RC_NSS_CHANGED |\n\t\t\t       IEEE80211_RC_BW_CHANGED))\n\t\t\tmt7915_mcu_add_rate_ctrl(dev, vif, sta, true);\n\n\t\tif (changed & IEEE80211_RC_SMPS_CHANGED)\n\t\t\tmt7915_mcu_add_smps(dev, vif, sta);\n\n\t\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\t}\n\n\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n}\n\nvoid mt7915_mac_work(struct work_struct *work)\n{\n\tstruct mt7915_phy *phy;\n\tstruct mt76_phy *mphy;\n\n\tmphy = (struct mt76_phy *)container_of(work, struct mt76_phy,\n\t\t\t\t\t       mac_work.work);\n\tphy = mphy->priv;\n\n\tmutex_lock(&mphy->dev->mutex);\n\n\tmt76_update_survey(mphy);\n\tif (++mphy->mac_work_count == 5) {\n\t\tmphy->mac_work_count = 0;\n\n\t\tmt7915_mac_update_stats(phy);\n\t\tmt7915_mac_severe_check(phy);\n\n\t\tif (phy->dev->muru_debug)\n\t\t\tmt7915_mcu_muru_debug_get(phy);\n\t}\n\n\tmutex_unlock(&mphy->dev->mutex);\n\n\tmt76_tx_status_check(mphy->dev, false);\n\n\tieee80211_queue_delayed_work(mphy->hw, &mphy->mac_work,\n\t\t\t\t     MT7915_WATCHDOG_TIME);\n}\n\nstatic void mt7915_dfs_stop_radar_detector(struct mt7915_phy *phy)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\n\tif (phy->rdd_state & BIT(0))\n\t\tmt76_connac_mcu_rdd_cmd(&dev->mt76, RDD_STOP, 0,\n\t\t\t\t\tMT_RX_SEL0, 0);\n\tif (phy->rdd_state & BIT(1))\n\t\tmt76_connac_mcu_rdd_cmd(&dev->mt76, RDD_STOP, 1,\n\t\t\t\t\tMT_RX_SEL0, 0);\n}\n\nstatic int mt7915_dfs_start_rdd(struct mt7915_dev *dev, int chain)\n{\n\tint err, region;\n\n\tswitch (dev->mt76.region) {\n\tcase NL80211_DFS_ETSI:\n\t\tregion = 0;\n\t\tbreak;\n\tcase NL80211_DFS_JP:\n\t\tregion = 2;\n\t\tbreak;\n\tcase NL80211_DFS_FCC:\n\tdefault:\n\t\tregion = 1;\n\t\tbreak;\n\t}\n\n\terr = mt76_connac_mcu_rdd_cmd(&dev->mt76, RDD_START, chain,\n\t\t\t\t      MT_RX_SEL0, region);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (is_mt7915(&dev->mt76)) {\n\t\terr = mt76_connac_mcu_rdd_cmd(&dev->mt76, RDD_SET_WF_ANT, chain,\n\t\t\t\t\t      0, dev->dbdc_support ? 2 : 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn mt76_connac_mcu_rdd_cmd(&dev->mt76, RDD_DET_MODE, chain,\n\t\t\t\t       MT_RX_SEL0, 1);\n}\n\nstatic int mt7915_dfs_start_radar_detector(struct mt7915_phy *phy)\n{\n\tstruct cfg80211_chan_def *chandef = &phy->mt76->chandef;\n\tstruct mt7915_dev *dev = phy->dev;\n\tint err;\n\n\t \n\terr = mt76_connac_mcu_rdd_cmd(&dev->mt76, RDD_CAC_START,\n\t\t\t\t      phy->mt76->band_idx, MT_RX_SEL0, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = mt7915_dfs_start_rdd(dev, phy->mt76->band_idx);\n\tif (err < 0)\n\t\treturn err;\n\n\tphy->rdd_state |= BIT(phy->mt76->band_idx);\n\n\tif (!is_mt7915(&dev->mt76))\n\t\treturn 0;\n\n\tif (chandef->width == NL80211_CHAN_WIDTH_160 ||\n\t    chandef->width == NL80211_CHAN_WIDTH_80P80) {\n\t\terr = mt7915_dfs_start_rdd(dev, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tphy->rdd_state |= BIT(1);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmt7915_dfs_init_radar_specs(struct mt7915_phy *phy)\n{\n\tconst struct mt7915_dfs_radar_spec *radar_specs;\n\tstruct mt7915_dev *dev = phy->dev;\n\tint err, i;\n\n\tswitch (dev->mt76.region) {\n\tcase NL80211_DFS_FCC:\n\t\tradar_specs = &fcc_radar_specs;\n\t\terr = mt7915_mcu_set_fcc5_lpn(dev, 8);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tcase NL80211_DFS_ETSI:\n\t\tradar_specs = &etsi_radar_specs;\n\t\tbreak;\n\tcase NL80211_DFS_JP:\n\t\tradar_specs = &jp_radar_specs;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(radar_specs->radar_pattern); i++) {\n\t\terr = mt7915_mcu_set_radar_th(dev, i,\n\t\t\t\t\t      &radar_specs->radar_pattern[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn mt7915_mcu_set_pulse_th(dev, &radar_specs->pulse_th);\n}\n\nint mt7915_dfs_init_radar_detector(struct mt7915_phy *phy)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tenum mt76_dfs_state dfs_state, prev_state;\n\tint err;\n\n\tprev_state = phy->mt76->dfs_state;\n\tdfs_state = mt76_phy_dfs_state(phy->mt76);\n\n\tif (prev_state == dfs_state)\n\t\treturn 0;\n\n\tif (prev_state == MT_DFS_STATE_UNKNOWN)\n\t\tmt7915_dfs_stop_radar_detector(phy);\n\n\tif (dfs_state == MT_DFS_STATE_DISABLED)\n\t\tgoto stop;\n\n\tif (prev_state <= MT_DFS_STATE_DISABLED) {\n\t\terr = mt7915_dfs_init_radar_specs(phy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = mt7915_dfs_start_radar_detector(phy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tphy->mt76->dfs_state = MT_DFS_STATE_CAC;\n\t}\n\n\tif (dfs_state == MT_DFS_STATE_CAC)\n\t\treturn 0;\n\n\terr = mt76_connac_mcu_rdd_cmd(&dev->mt76, RDD_CAC_END,\n\t\t\t\t      phy->mt76->band_idx, MT_RX_SEL0, 0);\n\tif (err < 0) {\n\t\tphy->mt76->dfs_state = MT_DFS_STATE_UNKNOWN;\n\t\treturn err;\n\t}\n\n\tphy->mt76->dfs_state = MT_DFS_STATE_ACTIVE;\n\treturn 0;\n\nstop:\n\terr = mt76_connac_mcu_rdd_cmd(&dev->mt76, RDD_NORMAL_START,\n\t\t\t\t      phy->mt76->band_idx, MT_RX_SEL0, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (is_mt7915(&dev->mt76)) {\n\t\terr = mt76_connac_mcu_rdd_cmd(&dev->mt76, RDD_SET_WF_ANT,\n\t\t\t\t\t      phy->mt76->band_idx, 0,\n\t\t\t\t\t      dev->dbdc_support ? 2 : 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tmt7915_dfs_stop_radar_detector(phy);\n\tphy->mt76->dfs_state = MT_DFS_STATE_DISABLED;\n\n\treturn 0;\n}\n\nstatic int\nmt7915_mac_twt_duration_align(int duration)\n{\n\treturn duration << 8;\n}\n\nstatic u64\nmt7915_mac_twt_sched_list_add(struct mt7915_dev *dev,\n\t\t\t      struct mt7915_twt_flow *flow)\n{\n\tstruct mt7915_twt_flow *iter, *iter_next;\n\tu32 duration = flow->duration << 8;\n\tu64 start_tsf;\n\n\titer = list_first_entry_or_null(&dev->twt_list,\n\t\t\t\t\tstruct mt7915_twt_flow, list);\n\tif (!iter || !iter->sched || iter->start_tsf > duration) {\n\t\t \n\t\tlist_add(&flow->list, &dev->twt_list);\n\t\treturn 0;\n\t}\n\n\tlist_for_each_entry_safe(iter, iter_next, &dev->twt_list, list) {\n\t\tstart_tsf = iter->start_tsf +\n\t\t\t    mt7915_mac_twt_duration_align(iter->duration);\n\t\tif (list_is_last(&iter->list, &dev->twt_list))\n\t\t\tbreak;\n\n\t\tif (!iter_next->sched ||\n\t\t    iter_next->start_tsf > start_tsf + duration) {\n\t\t\tlist_add(&flow->list, &iter->list);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tlist_add_tail(&flow->list, &dev->twt_list);\nout:\n\treturn start_tsf;\n}\n\nstatic int mt7915_mac_check_twt_req(struct ieee80211_twt_setup *twt)\n{\n\tstruct ieee80211_twt_params *twt_agrt;\n\tu64 interval, duration;\n\tu16 mantissa;\n\tu8 exp;\n\n\t \n\tif (twt->control & IEEE80211_TWT_CONTROL_NEG_TYPE_BROADCAST)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (twt->control & IEEE80211_TWT_CONTROL_WAKE_DUR_UNIT)\n\t\treturn -EOPNOTSUPP;\n\n\ttwt_agrt = (struct ieee80211_twt_params *)twt->params;\n\n\t \n\tif (!(twt_agrt->req_type & cpu_to_le16(IEEE80211_TWT_REQTYPE_IMPLICIT)))\n\t\treturn -EOPNOTSUPP;\n\n\texp = FIELD_GET(IEEE80211_TWT_REQTYPE_WAKE_INT_EXP,\n\t\t\tle16_to_cpu(twt_agrt->req_type));\n\tmantissa = le16_to_cpu(twt_agrt->mantissa);\n\tduration = twt_agrt->min_twt_dur << 8;\n\n\tinterval = (u64)mantissa << exp;\n\tif (interval < duration)\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic bool\nmt7915_mac_twt_param_equal(struct mt7915_sta *msta,\n\t\t\t   struct ieee80211_twt_params *twt_agrt)\n{\n\tu16 type = le16_to_cpu(twt_agrt->req_type);\n\tu8 exp;\n\tint i;\n\n\texp = FIELD_GET(IEEE80211_TWT_REQTYPE_WAKE_INT_EXP, type);\n\tfor (i = 0; i < MT7915_MAX_STA_TWT_AGRT; i++) {\n\t\tstruct mt7915_twt_flow *f;\n\n\t\tif (!(msta->twt.flowid_mask & BIT(i)))\n\t\t\tcontinue;\n\n\t\tf = &msta->twt.flow[i];\n\t\tif (f->duration == twt_agrt->min_twt_dur &&\n\t\t    f->mantissa == twt_agrt->mantissa &&\n\t\t    f->exp == exp &&\n\t\t    f->protection == !!(type & IEEE80211_TWT_REQTYPE_PROTECTION) &&\n\t\t    f->flowtype == !!(type & IEEE80211_TWT_REQTYPE_FLOWTYPE) &&\n\t\t    f->trigger == !!(type & IEEE80211_TWT_REQTYPE_TRIGGER))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid mt7915_mac_add_twt_setup(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_sta *sta,\n\t\t\t      struct ieee80211_twt_setup *twt)\n{\n\tenum ieee80211_twt_setup_cmd setup_cmd = TWT_SETUP_CMD_REJECT;\n\tstruct mt7915_sta *msta = (struct mt7915_sta *)sta->drv_priv;\n\tstruct ieee80211_twt_params *twt_agrt = (void *)twt->params;\n\tu16 req_type = le16_to_cpu(twt_agrt->req_type);\n\tenum ieee80211_twt_setup_cmd sta_setup_cmd;\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tstruct mt7915_twt_flow *flow;\n\tint flowid, table_id;\n\tu8 exp;\n\n\tif (mt7915_mac_check_twt_req(twt))\n\t\tgoto out;\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tif (dev->twt.n_agrt == MT7915_MAX_TWT_AGRT)\n\t\tgoto unlock;\n\n\tif (hweight8(msta->twt.flowid_mask) == ARRAY_SIZE(msta->twt.flow))\n\t\tgoto unlock;\n\n\tif (twt_agrt->min_twt_dur < MT7915_MIN_TWT_DUR) {\n\t\tsetup_cmd = TWT_SETUP_CMD_DICTATE;\n\t\ttwt_agrt->min_twt_dur = MT7915_MIN_TWT_DUR;\n\t\tgoto unlock;\n\t}\n\n\tflowid = ffs(~msta->twt.flowid_mask) - 1;\n\ttwt_agrt->req_type &= ~cpu_to_le16(IEEE80211_TWT_REQTYPE_FLOWID);\n\ttwt_agrt->req_type |= le16_encode_bits(flowid,\n\t\t\t\t\t       IEEE80211_TWT_REQTYPE_FLOWID);\n\n\ttable_id = ffs(~dev->twt.table_mask) - 1;\n\texp = FIELD_GET(IEEE80211_TWT_REQTYPE_WAKE_INT_EXP, req_type);\n\tsta_setup_cmd = FIELD_GET(IEEE80211_TWT_REQTYPE_SETUP_CMD, req_type);\n\n\tif (mt7915_mac_twt_param_equal(msta, twt_agrt))\n\t\tgoto unlock;\n\n\tflow = &msta->twt.flow[flowid];\n\tmemset(flow, 0, sizeof(*flow));\n\tINIT_LIST_HEAD(&flow->list);\n\tflow->wcid = msta->wcid.idx;\n\tflow->table_id = table_id;\n\tflow->id = flowid;\n\tflow->duration = twt_agrt->min_twt_dur;\n\tflow->mantissa = twt_agrt->mantissa;\n\tflow->exp = exp;\n\tflow->protection = !!(req_type & IEEE80211_TWT_REQTYPE_PROTECTION);\n\tflow->flowtype = !!(req_type & IEEE80211_TWT_REQTYPE_FLOWTYPE);\n\tflow->trigger = !!(req_type & IEEE80211_TWT_REQTYPE_TRIGGER);\n\n\tif (sta_setup_cmd == TWT_SETUP_CMD_REQUEST ||\n\t    sta_setup_cmd == TWT_SETUP_CMD_SUGGEST) {\n\t\tu64 interval = (u64)le16_to_cpu(twt_agrt->mantissa) << exp;\n\t\tu64 flow_tsf, curr_tsf;\n\t\tu32 rem;\n\n\t\tflow->sched = true;\n\t\tflow->start_tsf = mt7915_mac_twt_sched_list_add(dev, flow);\n\t\tcurr_tsf = __mt7915_get_tsf(hw, msta->vif);\n\t\tdiv_u64_rem(curr_tsf - flow->start_tsf, interval, &rem);\n\t\tflow_tsf = curr_tsf + interval - rem;\n\t\ttwt_agrt->twt = cpu_to_le64(flow_tsf);\n\t} else {\n\t\tlist_add_tail(&flow->list, &dev->twt_list);\n\t}\n\tflow->tsf = le64_to_cpu(twt_agrt->twt);\n\n\tif (mt7915_mcu_twt_agrt_update(dev, msta->vif, flow, MCU_TWT_AGRT_ADD))\n\t\tgoto unlock;\n\n\tsetup_cmd = TWT_SETUP_CMD_ACCEPT;\n\tdev->twt.table_mask |= BIT(table_id);\n\tmsta->twt.flowid_mask |= BIT(flowid);\n\tdev->twt.n_agrt++;\n\nunlock:\n\tmutex_unlock(&dev->mt76.mutex);\nout:\n\ttwt_agrt->req_type &= ~cpu_to_le16(IEEE80211_TWT_REQTYPE_SETUP_CMD);\n\ttwt_agrt->req_type |=\n\t\tle16_encode_bits(setup_cmd, IEEE80211_TWT_REQTYPE_SETUP_CMD);\n\ttwt->control = (twt->control & IEEE80211_TWT_CONTROL_WAKE_DUR_UNIT) |\n\t\t       (twt->control & IEEE80211_TWT_CONTROL_RX_DISABLED);\n}\n\nvoid mt7915_mac_twt_teardown_flow(struct mt7915_dev *dev,\n\t\t\t\t  struct mt7915_sta *msta,\n\t\t\t\t  u8 flowid)\n{\n\tstruct mt7915_twt_flow *flow;\n\n\tlockdep_assert_held(&dev->mt76.mutex);\n\n\tif (flowid >= ARRAY_SIZE(msta->twt.flow))\n\t\treturn;\n\n\tif (!(msta->twt.flowid_mask & BIT(flowid)))\n\t\treturn;\n\n\tflow = &msta->twt.flow[flowid];\n\tif (mt7915_mcu_twt_agrt_update(dev, msta->vif, flow,\n\t\t\t\t       MCU_TWT_AGRT_DELETE))\n\t\treturn;\n\n\tlist_del_init(&flow->list);\n\tmsta->twt.flowid_mask &= ~BIT(flowid);\n\tdev->twt.table_mask &= ~BIT(flow->table_id);\n\tdev->twt.n_agrt--;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}