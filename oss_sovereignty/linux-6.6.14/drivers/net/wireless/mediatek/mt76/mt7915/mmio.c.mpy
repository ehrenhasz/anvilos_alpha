{
  "module_name": "mmio.c",
  "hash_id": "b832b2bb5ac0c2ba2671717f3a574a18eebc1f2363450e51d92bf5536083c1b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7915/mmio.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/rtnetlink.h>\n#include <linux/pci.h>\n\n#include \"mt7915.h\"\n#include \"mac.h\"\n#include \"mcu.h\"\n#include \"../trace.h\"\n#include \"../dma.h\"\n\nstatic bool wed_enable;\nmodule_param(wed_enable, bool, 0644);\nMODULE_PARM_DESC(wed_enable, \"Enable Wireless Ethernet Dispatch support\");\n\nstatic const u32 mt7915_reg[] = {\n\t[INT_SOURCE_CSR]\t\t= 0xd7010,\n\t[INT_MASK_CSR]\t\t\t= 0xd7014,\n\t[INT1_SOURCE_CSR]\t\t= 0xd7088,\n\t[INT1_MASK_CSR]\t\t\t= 0xd708c,\n\t[INT_MCU_CMD_SOURCE]\t\t= 0xd51f0,\n\t[INT_MCU_CMD_EVENT]\t\t= 0x3108,\n\t[WFDMA0_ADDR]\t\t\t= 0xd4000,\n\t[WFDMA0_PCIE1_ADDR]\t\t= 0xd8000,\n\t[WFDMA_EXT_CSR_ADDR]\t\t= 0xd7000,\n\t[CBTOP1_PHY_END]\t\t= 0x77ffffff,\n\t[INFRA_MCU_ADDR_END]\t\t= 0x7c3fffff,\n\t[FW_ASSERT_STAT_ADDR]\t\t= 0x219848,\n\t[FW_EXCEPT_TYPE_ADDR]\t\t= 0x21987c,\n\t[FW_EXCEPT_COUNT_ADDR]\t\t= 0x219848,\n\t[FW_CIRQ_COUNT_ADDR]\t\t= 0x216f94,\n\t[FW_CIRQ_IDX_ADDR]\t\t= 0x216ef8,\n\t[FW_CIRQ_LISR_ADDR]\t\t= 0x2170ac,\n\t[FW_TASK_ID_ADDR]\t\t= 0x216f90,\n\t[FW_TASK_IDX_ADDR]\t\t= 0x216f9c,\n\t[FW_TASK_QID1_ADDR]\t\t= 0x219680,\n\t[FW_TASK_QID2_ADDR]\t\t= 0x219760,\n\t[FW_TASK_START_ADDR]\t\t= 0x219558,\n\t[FW_TASK_END_ADDR]\t\t= 0x219554,\n\t[FW_TASK_SIZE_ADDR]\t\t= 0x219560,\n\t[FW_LAST_MSG_ID_ADDR]\t\t= 0x216f70,\n\t[FW_EINT_INFO_ADDR]\t\t= 0x219818,\n\t[FW_SCHED_INFO_ADDR]\t\t= 0x219828,\n\t[SWDEF_BASE_ADDR]\t\t= 0x41f200,\n\t[TXQ_WED_RING_BASE]\t\t= 0xd7300,\n\t[RXQ_WED_RING_BASE]\t\t= 0xd7410,\n\t[RXQ_WED_DATA_RING_BASE]\t= 0xd4500,\n};\n\nstatic const u32 mt7916_reg[] = {\n\t[INT_SOURCE_CSR]\t\t= 0xd4200,\n\t[INT_MASK_CSR]\t\t\t= 0xd4204,\n\t[INT1_SOURCE_CSR]\t\t= 0xd8200,\n\t[INT1_MASK_CSR]\t\t\t= 0xd8204,\n\t[INT_MCU_CMD_SOURCE]\t\t= 0xd41f0,\n\t[INT_MCU_CMD_EVENT]\t\t= 0x2108,\n\t[WFDMA0_ADDR]\t\t\t= 0xd4000,\n\t[WFDMA0_PCIE1_ADDR]\t\t= 0xd8000,\n\t[WFDMA_EXT_CSR_ADDR]\t\t= 0xd7000,\n\t[CBTOP1_PHY_END]\t\t= 0x7fffffff,\n\t[INFRA_MCU_ADDR_END]\t\t= 0x7c085fff,\n\t[FW_ASSERT_STAT_ADDR]\t\t= 0x02204c14,\n\t[FW_EXCEPT_TYPE_ADDR]\t\t= 0x022051a4,\n\t[FW_EXCEPT_COUNT_ADDR]\t\t= 0x022050bc,\n\t[FW_CIRQ_COUNT_ADDR]\t\t= 0x022001ac,\n\t[FW_CIRQ_IDX_ADDR]\t\t= 0x02204f84,\n\t[FW_CIRQ_LISR_ADDR]\t\t= 0x022050d0,\n\t[FW_TASK_ID_ADDR]\t\t= 0x0220406c,\n\t[FW_TASK_IDX_ADDR]\t\t= 0x0220500c,\n\t[FW_TASK_QID1_ADDR]\t\t= 0x022028c8,\n\t[FW_TASK_QID2_ADDR]\t\t= 0x02202a38,\n\t[FW_TASK_START_ADDR]\t\t= 0x0220286c,\n\t[FW_TASK_END_ADDR]\t\t= 0x02202870,\n\t[FW_TASK_SIZE_ADDR]\t\t= 0x02202878,\n\t[FW_LAST_MSG_ID_ADDR]\t\t= 0x02204fe8,\n\t[FW_EINT_INFO_ADDR]\t\t= 0x0220525c,\n\t[FW_SCHED_INFO_ADDR]\t\t= 0x0220516c,\n\t[SWDEF_BASE_ADDR]\t\t= 0x411400,\n\t[TXQ_WED_RING_BASE]\t\t= 0xd7300,\n\t[RXQ_WED_RING_BASE]\t\t= 0xd7410,\n\t[RXQ_WED_DATA_RING_BASE]\t= 0xd4540,\n};\n\nstatic const u32 mt7986_reg[] = {\n\t[INT_SOURCE_CSR]\t\t= 0x24200,\n\t[INT_MASK_CSR]\t\t\t= 0x24204,\n\t[INT1_SOURCE_CSR]\t\t= 0x28200,\n\t[INT1_MASK_CSR]\t\t\t= 0x28204,\n\t[INT_MCU_CMD_SOURCE]\t\t= 0x241f0,\n\t[INT_MCU_CMD_EVENT]\t\t= 0x54000108,\n\t[WFDMA0_ADDR]\t\t\t= 0x24000,\n\t[WFDMA0_PCIE1_ADDR]\t\t= 0x28000,\n\t[WFDMA_EXT_CSR_ADDR]\t\t= 0x27000,\n\t[CBTOP1_PHY_END]\t\t= 0x7fffffff,\n\t[INFRA_MCU_ADDR_END]\t\t= 0x7c085fff,\n\t[FW_ASSERT_STAT_ADDR]\t\t= 0x02204b54,\n\t[FW_EXCEPT_TYPE_ADDR]\t\t= 0x022050dc,\n\t[FW_EXCEPT_COUNT_ADDR]\t\t= 0x02204ffc,\n\t[FW_CIRQ_COUNT_ADDR]\t\t= 0x022001ac,\n\t[FW_CIRQ_IDX_ADDR]\t\t= 0x02204ec4,\n\t[FW_CIRQ_LISR_ADDR]\t\t= 0x02205010,\n\t[FW_TASK_ID_ADDR]\t\t= 0x02204fac,\n\t[FW_TASK_IDX_ADDR]\t\t= 0x02204f4c,\n\t[FW_TASK_QID1_ADDR]\t\t= 0x02202814,\n\t[FW_TASK_QID2_ADDR]\t\t= 0x02202984,\n\t[FW_TASK_START_ADDR]\t\t= 0x022027b8,\n\t[FW_TASK_END_ADDR]\t\t= 0x022027bc,\n\t[FW_TASK_SIZE_ADDR]\t\t= 0x022027c4,\n\t[FW_LAST_MSG_ID_ADDR]\t\t= 0x02204f28,\n\t[FW_EINT_INFO_ADDR]\t\t= 0x02205194,\n\t[FW_SCHED_INFO_ADDR]\t\t= 0x022051a4,\n\t[SWDEF_BASE_ADDR]\t\t= 0x411400,\n\t[TXQ_WED_RING_BASE]\t\t= 0x24420,\n\t[RXQ_WED_RING_BASE]\t\t= 0x24520,\n\t[RXQ_WED_DATA_RING_BASE]\t= 0x24540,\n};\n\nstatic const u32 mt7915_offs[] = {\n\t[TMAC_CDTR]\t\t= 0x090,\n\t[TMAC_ODTR]\t\t= 0x094,\n\t[TMAC_ATCR]\t\t= 0x098,\n\t[TMAC_TRCR0]\t\t= 0x09c,\n\t[TMAC_ICR0]\t\t= 0x0a4,\n\t[TMAC_ICR1]\t\t= 0x0b4,\n\t[TMAC_CTCR0]\t\t= 0x0f4,\n\t[TMAC_TFCR0]\t\t= 0x1e0,\n\t[MDP_BNRCFR0]\t\t= 0x070,\n\t[MDP_BNRCFR1]\t\t= 0x074,\n\t[ARB_DRNGR0]\t\t= 0x194,\n\t[ARB_SCR]\t\t= 0x080,\n\t[RMAC_MIB_AIRTIME14]\t= 0x3b8,\n\t[AGG_AWSCR0]\t\t= 0x05c,\n\t[AGG_PCR0]\t\t= 0x06c,\n\t[AGG_ACR0]\t\t= 0x084,\n\t[AGG_ACR4]\t\t= 0x08c,\n\t[AGG_MRCR]\t\t= 0x098,\n\t[AGG_ATCR1]\t\t= 0x0f0,\n\t[AGG_ATCR3]\t\t= 0x0f4,\n\t[LPON_UTTR0]\t\t= 0x080,\n\t[LPON_UTTR1]\t\t= 0x084,\n\t[LPON_FRCR]\t\t= 0x314,\n\t[MIB_SDR3]\t\t= 0x014,\n\t[MIB_SDR4]\t\t= 0x018,\n\t[MIB_SDR5]\t\t= 0x01c,\n\t[MIB_SDR7]\t\t= 0x024,\n\t[MIB_SDR8]\t\t= 0x028,\n\t[MIB_SDR9]\t\t= 0x02c,\n\t[MIB_SDR10]\t\t= 0x030,\n\t[MIB_SDR11]\t\t= 0x034,\n\t[MIB_SDR12]\t\t= 0x038,\n\t[MIB_SDR13]\t\t= 0x03c,\n\t[MIB_SDR14]\t\t= 0x040,\n\t[MIB_SDR15]\t\t= 0x044,\n\t[MIB_SDR16]\t\t= 0x048,\n\t[MIB_SDR17]\t\t= 0x04c,\n\t[MIB_SDR18]\t\t= 0x050,\n\t[MIB_SDR19]\t\t= 0x054,\n\t[MIB_SDR20]\t\t= 0x058,\n\t[MIB_SDR21]\t\t= 0x05c,\n\t[MIB_SDR22]\t\t= 0x060,\n\t[MIB_SDR23]\t\t= 0x064,\n\t[MIB_SDR24]\t\t= 0x068,\n\t[MIB_SDR25]\t\t= 0x06c,\n\t[MIB_SDR27]\t\t= 0x074,\n\t[MIB_SDR28]\t\t= 0x078,\n\t[MIB_SDR29]\t\t= 0x07c,\n\t[MIB_SDRVEC]\t\t= 0x080,\n\t[MIB_SDR31]\t\t= 0x084,\n\t[MIB_SDR32]\t\t= 0x088,\n\t[MIB_SDRMUBF]\t\t= 0x090,\n\t[MIB_DR8]\t\t= 0x0c0,\n\t[MIB_DR9]\t\t= 0x0c4,\n\t[MIB_DR11]\t\t= 0x0cc,\n\t[MIB_MB_SDR0]\t\t= 0x100,\n\t[MIB_MB_SDR1]\t\t= 0x104,\n\t[TX_AGG_CNT]\t\t= 0x0a8,\n\t[TX_AGG_CNT2]\t\t= 0x164,\n\t[MIB_ARNG]\t\t= 0x4b8,\n\t[WTBLON_TOP_WDUCR]\t= 0x0,\n\t[WTBL_UPDATE]\t\t= 0x030,\n\t[PLE_FL_Q_EMPTY]\t= 0x0b0,\n\t[PLE_FL_Q_CTRL]\t\t= 0x1b0,\n\t[PLE_AC_QEMPTY]\t\t= 0x500,\n\t[PLE_FREEPG_CNT]\t= 0x100,\n\t[PLE_FREEPG_HEAD_TAIL]\t= 0x104,\n\t[PLE_PG_HIF_GROUP]\t= 0x110,\n\t[PLE_HIF_PG_INFO]\t= 0x114,\n\t[AC_OFFSET]\t\t= 0x040,\n\t[ETBF_PAR_RPT0]\t\t= 0x068,\n};\n\nstatic const u32 mt7916_offs[] = {\n\t[TMAC_CDTR]\t\t= 0x0c8,\n\t[TMAC_ODTR]\t\t= 0x0cc,\n\t[TMAC_ATCR]\t\t= 0x00c,\n\t[TMAC_TRCR0]\t\t= 0x010,\n\t[TMAC_ICR0]\t\t= 0x014,\n\t[TMAC_ICR1]\t\t= 0x018,\n\t[TMAC_CTCR0]\t\t= 0x114,\n\t[TMAC_TFCR0]\t\t= 0x0e4,\n\t[MDP_BNRCFR0]\t\t= 0x090,\n\t[MDP_BNRCFR1]\t\t= 0x094,\n\t[ARB_DRNGR0]\t\t= 0x1e0,\n\t[ARB_SCR]\t\t= 0x000,\n\t[RMAC_MIB_AIRTIME14]\t= 0x0398,\n\t[AGG_AWSCR0]\t\t= 0x030,\n\t[AGG_PCR0]\t\t= 0x040,\n\t[AGG_ACR0]\t\t= 0x054,\n\t[AGG_ACR4]\t\t= 0x05c,\n\t[AGG_MRCR]\t\t= 0x068,\n\t[AGG_ATCR1]\t\t= 0x1a8,\n\t[AGG_ATCR3]\t\t= 0x080,\n\t[LPON_UTTR0]\t\t= 0x360,\n\t[LPON_UTTR1]\t\t= 0x364,\n\t[LPON_FRCR]\t\t= 0x37c,\n\t[MIB_SDR3]\t\t= 0x698,\n\t[MIB_SDR4]\t\t= 0x788,\n\t[MIB_SDR5]\t\t= 0x780,\n\t[MIB_SDR7]\t\t= 0x5a8,\n\t[MIB_SDR8]\t\t= 0x78c,\n\t[MIB_SDR9]\t\t= 0x024,\n\t[MIB_SDR10]\t\t= 0x76c,\n\t[MIB_SDR11]\t\t= 0x790,\n\t[MIB_SDR12]\t\t= 0x558,\n\t[MIB_SDR13]\t\t= 0x560,\n\t[MIB_SDR14]\t\t= 0x564,\n\t[MIB_SDR15]\t\t= 0x568,\n\t[MIB_SDR16]\t\t= 0x7fc,\n\t[MIB_SDR17]\t\t= 0x800,\n\t[MIB_SDR18]\t\t= 0x030,\n\t[MIB_SDR19]\t\t= 0x5ac,\n\t[MIB_SDR20]\t\t= 0x5b0,\n\t[MIB_SDR21]\t\t= 0x5b4,\n\t[MIB_SDR22]\t\t= 0x770,\n\t[MIB_SDR23]\t\t= 0x774,\n\t[MIB_SDR24]\t\t= 0x778,\n\t[MIB_SDR25]\t\t= 0x77c,\n\t[MIB_SDR27]\t\t= 0x080,\n\t[MIB_SDR28]\t\t= 0x084,\n\t[MIB_SDR29]\t\t= 0x650,\n\t[MIB_SDRVEC]\t\t= 0x5a8,\n\t[MIB_SDR31]\t\t= 0x55c,\n\t[MIB_SDR32]\t\t= 0x7a8,\n\t[MIB_SDRMUBF]\t\t= 0x7ac,\n\t[MIB_DR8]\t\t= 0x56c,\n\t[MIB_DR9]\t\t= 0x570,\n\t[MIB_DR11]\t\t= 0x574,\n\t[MIB_MB_SDR0]\t\t= 0x688,\n\t[MIB_MB_SDR1]\t\t= 0x690,\n\t[TX_AGG_CNT]\t\t= 0x7dc,\n\t[TX_AGG_CNT2]\t\t= 0x7ec,\n\t[MIB_ARNG]\t\t= 0x0b0,\n\t[WTBLON_TOP_WDUCR]\t= 0x200,\n\t[WTBL_UPDATE]\t\t= 0x230,\n\t[PLE_FL_Q_EMPTY]\t= 0x360,\n\t[PLE_FL_Q_CTRL]\t\t= 0x3e0,\n\t[PLE_AC_QEMPTY]\t\t= 0x600,\n\t[PLE_FREEPG_CNT]\t= 0x380,\n\t[PLE_FREEPG_HEAD_TAIL]\t= 0x384,\n\t[PLE_PG_HIF_GROUP]\t= 0x00c,\n\t[PLE_HIF_PG_INFO]\t= 0x388,\n\t[AC_OFFSET]\t\t= 0x080,\n\t[ETBF_PAR_RPT0]\t\t= 0x100,\n};\n\nstatic const struct mt76_connac_reg_map mt7915_reg_map[] = {\n\t{ 0x00400000, 0x80000, 0x10000 },  \n\t{ 0x00410000, 0x90000, 0x10000 },  \n\t{ 0x40000000, 0x70000, 0x10000 },  \n\t{ 0x54000000, 0x02000, 0x01000 },  \n\t{ 0x55000000, 0x03000, 0x01000 },  \n\t{ 0x58000000, 0x06000, 0x01000 },  \n\t{ 0x59000000, 0x07000, 0x01000 },  \n\t{ 0x7c000000, 0xf0000, 0x10000 },  \n\t{ 0x7c020000, 0xd0000, 0x10000 },  \n\t{ 0x80020000, 0xb0000, 0x10000 },  \n\t{ 0x81020000, 0xc0000, 0x10000 },  \n\t{ 0x820c0000, 0x08000, 0x04000 },  \n\t{ 0x820c8000, 0x0c000, 0x02000 },  \n\t{ 0x820cc000, 0x0e000, 0x02000 },  \n\t{ 0x820ce000, 0x21c00, 0x00200 },  \n\t{ 0x820cf000, 0x22000, 0x01000 },  \n\t{ 0x820d0000, 0x30000, 0x10000 },  \n\t{ 0x820e0000, 0x20000, 0x00400 },  \n\t{ 0x820e1000, 0x20400, 0x00200 },  \n\t{ 0x820e2000, 0x20800, 0x00400 },  \n\t{ 0x820e3000, 0x20c00, 0x00400 },  \n\t{ 0x820e4000, 0x21000, 0x00400 },  \n\t{ 0x820e5000, 0x21400, 0x00800 },  \n\t{ 0x820e7000, 0x21e00, 0x00200 },  \n\t{ 0x820e9000, 0x23400, 0x00200 },  \n\t{ 0x820ea000, 0x24000, 0x00200 },  \n\t{ 0x820eb000, 0x24200, 0x00400 },  \n\t{ 0x820ec000, 0x24600, 0x00200 },  \n\t{ 0x820ed000, 0x24800, 0x00800 },  \n\t{ 0x820f0000, 0xa0000, 0x00400 },  \n\t{ 0x820f1000, 0xa0600, 0x00200 },  \n\t{ 0x820f2000, 0xa0800, 0x00400 },  \n\t{ 0x820f3000, 0xa0c00, 0x00400 },  \n\t{ 0x820f4000, 0xa1000, 0x00400 },  \n\t{ 0x820f5000, 0xa1400, 0x00800 },  \n\t{ 0x820f7000, 0xa1e00, 0x00200 },  \n\t{ 0x820f9000, 0xa3400, 0x00200 },  \n\t{ 0x820fa000, 0xa4000, 0x00200 },  \n\t{ 0x820fb000, 0xa4200, 0x00400 },  \n\t{ 0x820fc000, 0xa4600, 0x00200 },  \n\t{ 0x820fd000, 0xa4800, 0x00800 },  \n\t{ 0x0, 0x0, 0x0 },  \n};\n\nstatic const struct mt76_connac_reg_map mt7916_reg_map[] = {\n\t{ 0x54000000, 0x02000, 0x01000 },  \n\t{ 0x55000000, 0x03000, 0x01000 },  \n\t{ 0x56000000, 0x04000, 0x01000 },  \n\t{ 0x57000000, 0x05000, 0x01000 },  \n\t{ 0x58000000, 0x06000, 0x01000 },  \n\t{ 0x59000000, 0x07000, 0x01000 },  \n\t{ 0x820c0000, 0x08000, 0x04000 },  \n\t{ 0x820c8000, 0x0c000, 0x02000 },  \n\t{ 0x820cc000, 0x0e000, 0x02000 },  \n\t{ 0x820e0000, 0x20000, 0x00400 },  \n\t{ 0x820e1000, 0x20400, 0x00200 },  \n\t{ 0x820e2000, 0x20800, 0x00400 },  \n\t{ 0x820e3000, 0x20c00, 0x00400 },  \n\t{ 0x820e4000, 0x21000, 0x00400 },  \n\t{ 0x820e5000, 0x21400, 0x00800 },  \n\t{ 0x820ce000, 0x21c00, 0x00200 },  \n\t{ 0x820e7000, 0x21e00, 0x00200 },  \n\t{ 0x820cf000, 0x22000, 0x01000 },  \n\t{ 0x820e9000, 0x23400, 0x00200 },  \n\t{ 0x820ea000, 0x24000, 0x00200 },  \n\t{ 0x820eb000, 0x24200, 0x00400 },  \n\t{ 0x820ec000, 0x24600, 0x00200 },  \n\t{ 0x820ed000, 0x24800, 0x00800 },  \n\t{ 0x820ca000, 0x26000, 0x02000 },  \n\t{ 0x820d0000, 0x30000, 0x10000 },  \n\t{ 0x00400000, 0x80000, 0x10000 },  \n\t{ 0x00410000, 0x90000, 0x10000 },  \n\t{ 0x820f0000, 0xa0000, 0x00400 },  \n\t{ 0x820f1000, 0xa0600, 0x00200 },  \n\t{ 0x820f2000, 0xa0800, 0x00400 },  \n\t{ 0x820f3000, 0xa0c00, 0x00400 },  \n\t{ 0x820f4000, 0xa1000, 0x00400 },  \n\t{ 0x820f5000, 0xa1400, 0x00800 },  \n\t{ 0x820f7000, 0xa1e00, 0x00200 },  \n\t{ 0x820f9000, 0xa3400, 0x00200 },  \n\t{ 0x820fa000, 0xa4000, 0x00200 },  \n\t{ 0x820fb000, 0xa4200, 0x00400 },  \n\t{ 0x820fc000, 0xa4600, 0x00200 },  \n\t{ 0x820fd000, 0xa4800, 0x00800 },  \n\t{ 0x820c4000, 0xa8000, 0x01000 },  \n\t{ 0x820b0000, 0xae000, 0x01000 },  \n\t{ 0x80020000, 0xb0000, 0x10000 },  \n\t{ 0x81020000, 0xc0000, 0x10000 },  \n\t{ 0x0, 0x0, 0x0 },  \n};\n\nstatic const struct mt76_connac_reg_map mt7986_reg_map[] = {\n\t{ 0x54000000, 0x402000, 0x01000 },  \n\t{ 0x55000000, 0x403000, 0x01000 },  \n\t{ 0x56000000, 0x404000, 0x01000 },  \n\t{ 0x57000000, 0x405000, 0x01000 },  \n\t{ 0x58000000, 0x406000, 0x01000 },  \n\t{ 0x59000000, 0x407000, 0x01000 },  \n\t{ 0x820c0000, 0x408000, 0x04000 },  \n\t{ 0x820c8000, 0x40c000, 0x02000 },  \n\t{ 0x820cc000, 0x40e000, 0x02000 },  \n\t{ 0x820e0000, 0x420000, 0x00400 },  \n\t{ 0x820e1000, 0x420400, 0x00200 },  \n\t{ 0x820e2000, 0x420800, 0x00400 },  \n\t{ 0x820e3000, 0x420c00, 0x00400 },  \n\t{ 0x820e4000, 0x421000, 0x00400 },  \n\t{ 0x820e5000, 0x421400, 0x00800 },  \n\t{ 0x820ce000, 0x421c00, 0x00200 },  \n\t{ 0x820e7000, 0x421e00, 0x00200 },  \n\t{ 0x820cf000, 0x422000, 0x01000 },  \n\t{ 0x820e9000, 0x423400, 0x00200 },  \n\t{ 0x820ea000, 0x424000, 0x00200 },  \n\t{ 0x820eb000, 0x424200, 0x00400 },  \n\t{ 0x820ec000, 0x424600, 0x00200 },  \n\t{ 0x820ed000, 0x424800, 0x00800 },  \n\t{ 0x820ca000, 0x426000, 0x02000 },  \n\t{ 0x820d0000, 0x430000, 0x10000 },  \n\t{ 0x00400000, 0x480000, 0x10000 },  \n\t{ 0x00410000, 0x490000, 0x10000 },  \n\t{ 0x820f0000, 0x4a0000, 0x00400 },  \n\t{ 0x820f1000, 0x4a0600, 0x00200 },  \n\t{ 0x820f2000, 0x4a0800, 0x00400 },  \n\t{ 0x820f3000, 0x4a0c00, 0x00400 },  \n\t{ 0x820f4000, 0x4a1000, 0x00400 },  \n\t{ 0x820f5000, 0x4a1400, 0x00800 },  \n\t{ 0x820f7000, 0x4a1e00, 0x00200 },  \n\t{ 0x820f9000, 0x4a3400, 0x00200 },  \n\t{ 0x820fa000, 0x4a4000, 0x00200 },  \n\t{ 0x820fb000, 0x4a4200, 0x00400 },  \n\t{ 0x820fc000, 0x4a4600, 0x00200 },  \n\t{ 0x820fd000, 0x4a4800, 0x00800 },  \n\t{ 0x820c4000, 0x4a8000, 0x01000 },  \n\t{ 0x820b0000, 0x4ae000, 0x01000 },  \n\t{ 0x80020000, 0x4b0000, 0x10000 },  \n\t{ 0x81020000, 0x4c0000, 0x10000 },  \n\t{ 0x89000000, 0x4d0000, 0x01000 },  \n\t{ 0x89010000, 0x4d1000, 0x01000 },  \n\t{ 0x89020000, 0x4d2000, 0x01000 },  \n\t{ 0x89030000, 0x4d3000, 0x01000 },  \n\t{ 0x80010000, 0x4d4000, 0x01000 },  \n\t{ 0x0, 0x0, 0x0 },  \n};\n\nstatic u32 mt7915_reg_map_l1(struct mt7915_dev *dev, u32 addr)\n{\n\tu32 offset = FIELD_GET(MT_HIF_REMAP_L1_OFFSET, addr);\n\tu32 base = FIELD_GET(MT_HIF_REMAP_L1_BASE, addr);\n\tu32 l1_remap;\n\n\tif (is_mt798x(&dev->mt76))\n\t\treturn MT_CONN_INFRA_OFFSET(addr);\n\n\tl1_remap = is_mt7915(&dev->mt76) ?\n\t\t   MT_HIF_REMAP_L1 : MT_HIF_REMAP_L1_MT7916;\n\n\tdev->bus_ops->rmw(&dev->mt76, l1_remap,\n\t\t\t  MT_HIF_REMAP_L1_MASK,\n\t\t\t  FIELD_PREP(MT_HIF_REMAP_L1_MASK, base));\n\t \n\tdev->bus_ops->rr(&dev->mt76, l1_remap);\n\n\treturn MT_HIF_REMAP_BASE_L1 + offset;\n}\n\nstatic u32 mt7915_reg_map_l2(struct mt7915_dev *dev, u32 addr)\n{\n\tu32 offset, base;\n\n\tif (is_mt7915(&dev->mt76)) {\n\t\toffset = FIELD_GET(MT_HIF_REMAP_L2_OFFSET, addr);\n\t\tbase = FIELD_GET(MT_HIF_REMAP_L2_BASE, addr);\n\n\t\tdev->bus_ops->rmw(&dev->mt76, MT_HIF_REMAP_L2,\n\t\t\t\t  MT_HIF_REMAP_L2_MASK,\n\t\t\t\t  FIELD_PREP(MT_HIF_REMAP_L2_MASK, base));\n\n\t\t \n\t\tdev->bus_ops->rr(&dev->mt76, MT_HIF_REMAP_L2);\n\t} else {\n\t\tu32 ofs = is_mt798x(&dev->mt76) ? 0x400000 : 0;\n\n\t\toffset = FIELD_GET(MT_HIF_REMAP_L2_OFFSET_MT7916, addr);\n\t\tbase = FIELD_GET(MT_HIF_REMAP_L2_BASE_MT7916, addr);\n\n\t\tdev->bus_ops->rmw(&dev->mt76, MT_HIF_REMAP_L2_MT7916 + ofs,\n\t\t\t\t  MT_HIF_REMAP_L2_MASK_MT7916,\n\t\t\t\t  FIELD_PREP(MT_HIF_REMAP_L2_MASK_MT7916, base));\n\n\t\t \n\t\tdev->bus_ops->rr(&dev->mt76, MT_HIF_REMAP_L2_MT7916 + ofs);\n\n\t\toffset += (MT_HIF_REMAP_BASE_L2_MT7916 + ofs);\n\t}\n\n\treturn offset;\n}\n\nstatic u32 __mt7915_reg_addr(struct mt7915_dev *dev, u32 addr)\n{\n\tint i;\n\n\tif (addr < 0x100000)\n\t\treturn addr;\n\n\tif (!dev->reg.map) {\n\t\tdev_err(dev->mt76.dev, \"err: reg_map is null\\n\");\n\t\treturn addr;\n\t}\n\n\tfor (i = 0; i < dev->reg.map_size; i++) {\n\t\tu32 ofs;\n\n\t\tif (addr < dev->reg.map[i].phys)\n\t\t\tcontinue;\n\n\t\tofs = addr - dev->reg.map[i].phys;\n\t\tif (ofs > dev->reg.map[i].size)\n\t\t\tcontinue;\n\n\t\treturn dev->reg.map[i].maps + ofs;\n\t}\n\n\tif ((addr >= MT_INFRA_BASE && addr < MT_WFSYS0_PHY_START) ||\n\t    (addr >= MT_WFSYS0_PHY_START && addr < MT_WFSYS1_PHY_START) ||\n\t    (addr >= MT_WFSYS1_PHY_START && addr <= MT_WFSYS1_PHY_END))\n\t\treturn mt7915_reg_map_l1(dev, addr);\n\n\tif (dev_is_pci(dev->mt76.dev) &&\n\t    ((addr >= MT_CBTOP1_PHY_START && addr <= MT_CBTOP1_PHY_END) ||\n\t    addr >= MT_CBTOP2_PHY_START))\n\t\treturn mt7915_reg_map_l1(dev, addr);\n\n\t \n\tif (addr >= MT_INFRA_MCU_START && addr <= MT_INFRA_MCU_END) {\n\t\taddr = addr - MT_INFRA_MCU_START + MT_INFRA_BASE;\n\t\treturn mt7915_reg_map_l1(dev, addr);\n\t}\n\n\treturn mt7915_reg_map_l2(dev, addr);\n}\n\nvoid mt7915_memcpy_fromio(struct mt7915_dev *dev, void *buf, u32 offset,\n\t\t\t  size_t len)\n{\n\tu32 addr = __mt7915_reg_addr(dev, offset);\n\n\tmemcpy_fromio(buf, dev->mt76.mmio.regs + addr, len);\n}\n\nstatic u32 mt7915_rr(struct mt76_dev *mdev, u32 offset)\n{\n\tstruct mt7915_dev *dev = container_of(mdev, struct mt7915_dev, mt76);\n\tu32 addr = __mt7915_reg_addr(dev, offset);\n\n\treturn dev->bus_ops->rr(mdev, addr);\n}\n\nstatic void mt7915_wr(struct mt76_dev *mdev, u32 offset, u32 val)\n{\n\tstruct mt7915_dev *dev = container_of(mdev, struct mt7915_dev, mt76);\n\tu32 addr = __mt7915_reg_addr(dev, offset);\n\n\tdev->bus_ops->wr(mdev, addr, val);\n}\n\nstatic u32 mt7915_rmw(struct mt76_dev *mdev, u32 offset, u32 mask, u32 val)\n{\n\tstruct mt7915_dev *dev = container_of(mdev, struct mt7915_dev, mt76);\n\tu32 addr = __mt7915_reg_addr(dev, offset);\n\n\treturn dev->bus_ops->rmw(mdev, addr, mask, val);\n}\n\n#ifdef CONFIG_NET_MEDIATEK_SOC_WED\nstatic int mt7915_mmio_wed_offload_enable(struct mtk_wed_device *wed)\n{\n\tstruct mt7915_dev *dev;\n\n\tdev = container_of(wed, struct mt7915_dev, mt76.mmio.wed);\n\n\tspin_lock_bh(&dev->mt76.token_lock);\n\tdev->mt76.token_size = wed->wlan.token_start;\n\tspin_unlock_bh(&dev->mt76.token_lock);\n\n\treturn !wait_event_timeout(dev->mt76.tx_wait,\n\t\t\t\t   !dev->mt76.wed_token_count, HZ);\n}\n\nstatic void mt7915_mmio_wed_offload_disable(struct mtk_wed_device *wed)\n{\n\tstruct mt7915_dev *dev;\n\n\tdev = container_of(wed, struct mt7915_dev, mt76.mmio.wed);\n\n\tspin_lock_bh(&dev->mt76.token_lock);\n\tdev->mt76.token_size = MT7915_TOKEN_SIZE;\n\tspin_unlock_bh(&dev->mt76.token_lock);\n}\n\nstatic void mt7915_mmio_wed_release_rx_buf(struct mtk_wed_device *wed)\n{\n\tstruct mt7915_dev *dev;\n\tint i;\n\n\tdev = container_of(wed, struct mt7915_dev, mt76.mmio.wed);\n\tfor (i = 0; i < dev->mt76.rx_token_size; i++) {\n\t\tstruct mt76_txwi_cache *t;\n\n\t\tt = mt76_rx_token_release(&dev->mt76, i);\n\t\tif (!t || !t->ptr)\n\t\t\tcontinue;\n\n\t\tmt76_put_page_pool_buf(t->ptr, false);\n\t\tt->ptr = NULL;\n\n\t\tmt76_put_rxwi(&dev->mt76, t);\n\t}\n\n\tmt76_free_pending_rxwi(&dev->mt76);\n}\n\nstatic u32 mt7915_mmio_wed_init_rx_buf(struct mtk_wed_device *wed, int size)\n{\n\tstruct mtk_rxbm_desc *desc = wed->rx_buf_ring.desc;\n\tstruct mt76_txwi_cache *t = NULL;\n\tstruct mt7915_dev *dev;\n\tstruct mt76_queue *q;\n\tint i, len;\n\n\tdev = container_of(wed, struct mt7915_dev, mt76.mmio.wed);\n\tq = &dev->mt76.q_rx[MT_RXQ_MAIN];\n\tlen = SKB_WITH_OVERHEAD(q->buf_size);\n\n\tfor (i = 0; i < size; i++) {\n\t\tenum dma_data_direction dir;\n\t\tdma_addr_t addr;\n\t\tu32 offset;\n\t\tint token;\n\t\tvoid *buf;\n\n\t\tt = mt76_get_rxwi(&dev->mt76);\n\t\tif (!t)\n\t\t\tgoto unmap;\n\n\t\tbuf = mt76_get_page_pool_buf(q, &offset, q->buf_size);\n\t\tif (!buf)\n\t\t\tgoto unmap;\n\n\t\taddr = page_pool_get_dma_addr(virt_to_head_page(buf)) + offset;\n\t\tdir = page_pool_get_dma_dir(q->page_pool);\n\t\tdma_sync_single_for_device(dev->mt76.dma_dev, addr, len, dir);\n\n\t\tdesc->buf0 = cpu_to_le32(addr);\n\t\ttoken = mt76_rx_token_consume(&dev->mt76, buf, t, addr);\n\t\tif (token < 0) {\n\t\t\tmt76_put_page_pool_buf(buf, false);\n\t\t\tgoto unmap;\n\t\t}\n\n\t\tdesc->token |= cpu_to_le32(FIELD_PREP(MT_DMA_CTL_TOKEN,\n\t\t\t\t\t\t      token));\n\t\tdesc++;\n\t}\n\n\treturn 0;\n\nunmap:\n\tif (t)\n\t\tmt76_put_rxwi(&dev->mt76, t);\n\tmt7915_mmio_wed_release_rx_buf(wed);\n\treturn -ENOMEM;\n}\n\nstatic void mt7915_mmio_wed_update_rx_stats(struct mtk_wed_device *wed,\n\t\t\t\t\t    struct mtk_wed_wo_rx_stats *stats)\n{\n\tint idx = le16_to_cpu(stats->wlan_idx);\n\tstruct mt7915_dev *dev;\n\tstruct mt76_wcid *wcid;\n\n\tdev = container_of(wed, struct mt7915_dev, mt76.mmio.wed);\n\n\tif (idx >= mt7915_wtbl_size(dev))\n\t\treturn;\n\n\trcu_read_lock();\n\n\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n\tif (wcid) {\n\t\twcid->stats.rx_bytes += le32_to_cpu(stats->rx_byte_cnt);\n\t\twcid->stats.rx_packets += le32_to_cpu(stats->rx_pkt_cnt);\n\t\twcid->stats.rx_errors += le32_to_cpu(stats->rx_err_cnt);\n\t\twcid->stats.rx_drops += le32_to_cpu(stats->rx_drop_cnt);\n\t}\n\n\trcu_read_unlock();\n}\n\nstatic int mt7915_mmio_wed_reset(struct mtk_wed_device *wed)\n{\n\tstruct mt76_dev *mdev = container_of(wed, struct mt76_dev, mmio.wed);\n\tstruct mt7915_dev *dev = container_of(mdev, struct mt7915_dev, mt76);\n\tstruct mt76_phy *mphy = &dev->mphy;\n\tint ret;\n\n\tASSERT_RTNL();\n\n\tif (test_and_set_bit(MT76_STATE_WED_RESET, &mphy->state))\n\t\treturn -EBUSY;\n\n\tret = mt7915_mcu_set_ser(dev, SER_RECOVER, SER_SET_RECOVER_L1,\n\t\t\t\t mphy->band_idx);\n\tif (ret)\n\t\tgoto out;\n\n\trtnl_unlock();\n\tif (!wait_for_completion_timeout(&mdev->mmio.wed_reset, 20 * HZ)) {\n\t\tdev_err(mdev->dev, \"wed reset timeout\\n\");\n\t\tret = -ETIMEDOUT;\n\t}\n\trtnl_lock();\nout:\n\tclear_bit(MT76_STATE_WED_RESET, &mphy->state);\n\n\treturn ret;\n}\n\nstatic void mt7915_mmio_wed_reset_complete(struct mtk_wed_device *wed)\n{\n\tstruct mt76_dev *dev = container_of(wed, struct mt76_dev, mmio.wed);\n\n\tcomplete(&dev->mmio.wed_reset_complete);\n}\n#endif\n\nint mt7915_mmio_wed_init(struct mt7915_dev *dev, void *pdev_ptr,\n\t\t\t bool pci, int *irq)\n{\n#ifdef CONFIG_NET_MEDIATEK_SOC_WED\n\tstruct mtk_wed_device *wed = &dev->mt76.mmio.wed;\n\tint ret;\n\n\tif (!wed_enable)\n\t\treturn 0;\n\n\tif (pci) {\n\t\tstruct pci_dev *pci_dev = pdev_ptr;\n\n\t\twed->wlan.pci_dev = pci_dev;\n\t\twed->wlan.bus_type = MTK_WED_BUS_PCIE;\n\t\twed->wlan.base = devm_ioremap(dev->mt76.dev,\n\t\t\t\t\t      pci_resource_start(pci_dev, 0),\n\t\t\t\t\t      pci_resource_len(pci_dev, 0));\n\t\twed->wlan.phy_base = pci_resource_start(pci_dev, 0);\n\t\twed->wlan.wpdma_int = pci_resource_start(pci_dev, 0) +\n\t\t\t\t      MT_INT_WED_SOURCE_CSR;\n\t\twed->wlan.wpdma_mask = pci_resource_start(pci_dev, 0) +\n\t\t\t\t       MT_INT_WED_MASK_CSR;\n\t\twed->wlan.wpdma_phys = pci_resource_start(pci_dev, 0) +\n\t\t\t\t       MT_WFDMA_EXT_CSR_BASE;\n\t\twed->wlan.wpdma_tx = pci_resource_start(pci_dev, 0) +\n\t\t\t\t     MT_TXQ_WED_RING_BASE;\n\t\twed->wlan.wpdma_txfree = pci_resource_start(pci_dev, 0) +\n\t\t\t\t\t MT_RXQ_WED_RING_BASE;\n\t\twed->wlan.wpdma_rx_glo = pci_resource_start(pci_dev, 0) +\n\t\t\t\t\t MT_WPDMA_GLO_CFG;\n\t\twed->wlan.wpdma_rx = pci_resource_start(pci_dev, 0) +\n\t\t\t\t     MT_RXQ_WED_DATA_RING_BASE;\n\t} else {\n\t\tstruct platform_device *plat_dev = pdev_ptr;\n\t\tstruct resource *res;\n\n\t\tres = platform_get_resource(plat_dev, IORESOURCE_MEM, 0);\n\t\tif (!res)\n\t\t\treturn 0;\n\n\t\twed->wlan.platform_dev = plat_dev;\n\t\twed->wlan.bus_type = MTK_WED_BUS_AXI;\n\t\twed->wlan.base = devm_ioremap(dev->mt76.dev, res->start,\n\t\t\t\t\t      resource_size(res));\n\t\twed->wlan.phy_base = res->start;\n\t\twed->wlan.wpdma_int = res->start + MT_INT_SOURCE_CSR;\n\t\twed->wlan.wpdma_mask = res->start + MT_INT_MASK_CSR;\n\t\twed->wlan.wpdma_tx = res->start + MT_TXQ_WED_RING_BASE;\n\t\twed->wlan.wpdma_txfree = res->start + MT_RXQ_WED_RING_BASE;\n\t\twed->wlan.wpdma_rx_glo = res->start + MT_WPDMA_GLO_CFG;\n\t\twed->wlan.wpdma_rx = res->start + MT_RXQ_WED_DATA_RING_BASE;\n\t}\n\twed->wlan.nbuf = MT7915_HW_TOKEN_SIZE;\n\twed->wlan.tx_tbit[0] = is_mt7915(&dev->mt76) ? 4 : 30;\n\twed->wlan.tx_tbit[1] = is_mt7915(&dev->mt76) ? 5 : 31;\n\twed->wlan.txfree_tbit = is_mt798x(&dev->mt76) ? 2 : 1;\n\twed->wlan.token_start = MT7915_TOKEN_SIZE - wed->wlan.nbuf;\n\twed->wlan.wcid_512 = !is_mt7915(&dev->mt76);\n\n\twed->wlan.rx_nbuf = 65536;\n\twed->wlan.rx_npkt = MT7915_WED_RX_TOKEN_SIZE;\n\twed->wlan.rx_size = SKB_WITH_OVERHEAD(MT_RX_BUF_SIZE);\n\tif (is_mt7915(&dev->mt76)) {\n\t\twed->wlan.rx_tbit[0] = 16;\n\t\twed->wlan.rx_tbit[1] = 17;\n\t} else if (is_mt798x(&dev->mt76)) {\n\t\twed->wlan.rx_tbit[0] = 22;\n\t\twed->wlan.rx_tbit[1] = 23;\n\t} else {\n\t\twed->wlan.rx_tbit[0] = 18;\n\t\twed->wlan.rx_tbit[1] = 19;\n\t}\n\n\twed->wlan.init_buf = mt7915_wed_init_buf;\n\twed->wlan.offload_enable = mt7915_mmio_wed_offload_enable;\n\twed->wlan.offload_disable = mt7915_mmio_wed_offload_disable;\n\twed->wlan.init_rx_buf = mt7915_mmio_wed_init_rx_buf;\n\twed->wlan.release_rx_buf = mt7915_mmio_wed_release_rx_buf;\n\twed->wlan.update_wo_rx_stats = mt7915_mmio_wed_update_rx_stats;\n\twed->wlan.reset = mt7915_mmio_wed_reset;\n\twed->wlan.reset_complete = mt7915_mmio_wed_reset_complete;\n\n\tdev->mt76.rx_token_size = wed->wlan.rx_npkt;\n\n\tif (mtk_wed_device_attach(wed))\n\t\treturn 0;\n\n\t*irq = wed->irq;\n\tdev->mt76.dma_dev = wed->dev;\n\n\tret = dma_set_mask(wed->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\treturn 1;\n#else\n\treturn 0;\n#endif\n}\n\nstatic int mt7915_mmio_init(struct mt76_dev *mdev,\n\t\t\t    void __iomem *mem_base,\n\t\t\t    u32 device_id)\n{\n\tstruct mt76_bus_ops *bus_ops;\n\tstruct mt7915_dev *dev;\n\n\tdev = container_of(mdev, struct mt7915_dev, mt76);\n\tmt76_mmio_init(&dev->mt76, mem_base);\n\n\tswitch (device_id) {\n\tcase 0x7915:\n\t\tdev->reg.reg_rev = mt7915_reg;\n\t\tdev->reg.offs_rev = mt7915_offs;\n\t\tdev->reg.map = mt7915_reg_map;\n\t\tdev->reg.map_size = ARRAY_SIZE(mt7915_reg_map);\n\t\tbreak;\n\tcase 0x7906:\n\t\tdev->reg.reg_rev = mt7916_reg;\n\t\tdev->reg.offs_rev = mt7916_offs;\n\t\tdev->reg.map = mt7916_reg_map;\n\t\tdev->reg.map_size = ARRAY_SIZE(mt7916_reg_map);\n\t\tbreak;\n\tcase 0x7981:\n\tcase 0x7986:\n\t\tdev->reg.reg_rev = mt7986_reg;\n\t\tdev->reg.offs_rev = mt7916_offs;\n\t\tdev->reg.map = mt7986_reg_map;\n\t\tdev->reg.map_size = ARRAY_SIZE(mt7986_reg_map);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev->bus_ops = dev->mt76.bus;\n\tbus_ops = devm_kmemdup(dev->mt76.dev, dev->bus_ops, sizeof(*bus_ops),\n\t\t\t       GFP_KERNEL);\n\tif (!bus_ops)\n\t\treturn -ENOMEM;\n\n\tbus_ops->rr = mt7915_rr;\n\tbus_ops->wr = mt7915_wr;\n\tbus_ops->rmw = mt7915_rmw;\n\tdev->mt76.bus = bus_ops;\n\n\tmdev->rev = (device_id << 16) |\n\t\t    (mt76_rr(dev, MT_HW_REV) & 0xff);\n\tdev_dbg(mdev->dev, \"ASIC revision: %04x\\n\", mdev->rev);\n\n\treturn 0;\n}\n\nvoid mt7915_dual_hif_set_irq_mask(struct mt7915_dev *dev,\n\t\t\t\t  bool write_reg,\n\t\t\t\t  u32 clear, u32 set)\n{\n\tstruct mt76_dev *mdev = &dev->mt76;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mdev->mmio.irq_lock, flags);\n\n\tmdev->mmio.irqmask &= ~clear;\n\tmdev->mmio.irqmask |= set;\n\n\tif (write_reg) {\n\t\tif (mtk_wed_device_active(&mdev->mmio.wed))\n\t\t\tmtk_wed_device_irq_set_mask(&mdev->mmio.wed,\n\t\t\t\t\t\t    mdev->mmio.irqmask);\n\t\telse\n\t\t\tmt76_wr(dev, MT_INT_MASK_CSR, mdev->mmio.irqmask);\n\t\tmt76_wr(dev, MT_INT1_MASK_CSR, mdev->mmio.irqmask);\n\t}\n\n\tspin_unlock_irqrestore(&mdev->mmio.irq_lock, flags);\n}\n\nstatic void mt7915_rx_poll_complete(struct mt76_dev *mdev,\n\t\t\t\t    enum mt76_rxq_id q)\n{\n\tstruct mt7915_dev *dev = container_of(mdev, struct mt7915_dev, mt76);\n\n\tmt7915_irq_enable(dev, MT_INT_RX(q));\n}\n\n \nstatic void mt7915_irq_tasklet(struct tasklet_struct *t)\n{\n\tstruct mt7915_dev *dev = from_tasklet(dev, t, mt76.irq_tasklet);\n\tstruct mtk_wed_device *wed = &dev->mt76.mmio.wed;\n\tu32 intr, intr1, mask;\n\n\tif (mtk_wed_device_active(wed)) {\n\t\tmtk_wed_device_irq_set_mask(wed, 0);\n\t\tif (dev->hif2)\n\t\t\tmt76_wr(dev, MT_INT1_MASK_CSR, 0);\n\t\tintr = mtk_wed_device_irq_get(wed, dev->mt76.mmio.irqmask);\n\t} else {\n\t\tmt76_wr(dev, MT_INT_MASK_CSR, 0);\n\t\tif (dev->hif2)\n\t\t\tmt76_wr(dev, MT_INT1_MASK_CSR, 0);\n\n\t\tintr = mt76_rr(dev, MT_INT_SOURCE_CSR);\n\t\tintr &= dev->mt76.mmio.irqmask;\n\t\tmt76_wr(dev, MT_INT_SOURCE_CSR, intr);\n\t}\n\n\tif (dev->hif2) {\n\t\tintr1 = mt76_rr(dev, MT_INT1_SOURCE_CSR);\n\t\tintr1 &= dev->mt76.mmio.irqmask;\n\t\tmt76_wr(dev, MT_INT1_SOURCE_CSR, intr1);\n\n\t\tintr |= intr1;\n\t}\n\n\ttrace_dev_irq(&dev->mt76, intr, dev->mt76.mmio.irqmask);\n\n\tmask = intr & MT_INT_RX_DONE_ALL;\n\tif (intr & MT_INT_TX_DONE_MCU)\n\t\tmask |= MT_INT_TX_DONE_MCU;\n\n\tmt7915_irq_disable(dev, mask);\n\n\tif (intr & MT_INT_TX_DONE_MCU)\n\t\tnapi_schedule(&dev->mt76.tx_napi);\n\n\tif (intr & MT_INT_RX(MT_RXQ_MAIN))\n\t\tnapi_schedule(&dev->mt76.napi[MT_RXQ_MAIN]);\n\n\tif (intr & MT_INT_RX(MT_RXQ_BAND1))\n\t\tnapi_schedule(&dev->mt76.napi[MT_RXQ_BAND1]);\n\n\tif (intr & MT_INT_RX(MT_RXQ_MCU))\n\t\tnapi_schedule(&dev->mt76.napi[MT_RXQ_MCU]);\n\n\tif (intr & MT_INT_RX(MT_RXQ_MCU_WA))\n\t\tnapi_schedule(&dev->mt76.napi[MT_RXQ_MCU_WA]);\n\n\tif (!is_mt7915(&dev->mt76) &&\n\t    (intr & MT_INT_RX(MT_RXQ_MAIN_WA)))\n\t\tnapi_schedule(&dev->mt76.napi[MT_RXQ_MAIN_WA]);\n\n\tif (intr & MT_INT_RX(MT_RXQ_BAND1_WA))\n\t\tnapi_schedule(&dev->mt76.napi[MT_RXQ_BAND1_WA]);\n\n\tif (intr & MT_INT_MCU_CMD) {\n\t\tu32 val = mt76_rr(dev, MT_MCU_CMD);\n\n\t\tmt76_wr(dev, MT_MCU_CMD, val);\n\t\tif (val & (MT_MCU_CMD_ERROR_MASK | MT_MCU_CMD_WDT_MASK)) {\n\t\t\tdev->recovery.state = val;\n\t\t\tmt7915_reset(dev);\n\t\t}\n\t}\n}\n\nirqreturn_t mt7915_irq_handler(int irq, void *dev_instance)\n{\n\tstruct mt7915_dev *dev = dev_instance;\n\tstruct mtk_wed_device *wed = &dev->mt76.mmio.wed;\n\n\tif (mtk_wed_device_active(wed))\n\t\tmtk_wed_device_irq_set_mask(wed, 0);\n\telse\n\t\tmt76_wr(dev, MT_INT_MASK_CSR, 0);\n\n\tif (dev->hif2)\n\t\tmt76_wr(dev, MT_INT1_MASK_CSR, 0);\n\n\tif (!test_bit(MT76_STATE_INITIALIZED, &dev->mphy.state))\n\t\treturn IRQ_NONE;\n\n\ttasklet_schedule(&dev->mt76.irq_tasklet);\n\n\treturn IRQ_HANDLED;\n}\n\nstruct mt7915_dev *mt7915_mmio_probe(struct device *pdev,\n\t\t\t\t     void __iomem *mem_base, u32 device_id)\n{\n\tstatic const struct mt76_driver_ops drv_ops = {\n\t\t \n\t\t.txwi_size = MT_TXD_SIZE + sizeof(struct mt76_connac_fw_txp),\n\t\t.drv_flags = MT_DRV_TXWI_NO_FREE | MT_DRV_HW_MGMT_TXQ |\n\t\t\t     MT_DRV_AMSDU_OFFLOAD,\n\t\t.survey_flags = SURVEY_INFO_TIME_TX |\n\t\t\t\tSURVEY_INFO_TIME_RX |\n\t\t\t\tSURVEY_INFO_TIME_BSS_RX,\n\t\t.token_size = MT7915_TOKEN_SIZE,\n\t\t.tx_prepare_skb = mt7915_tx_prepare_skb,\n\t\t.tx_complete_skb = mt76_connac_tx_complete_skb,\n\t\t.rx_skb = mt7915_queue_rx_skb,\n\t\t.rx_check = mt7915_rx_check,\n\t\t.rx_poll_complete = mt7915_rx_poll_complete,\n\t\t.sta_add = mt7915_mac_sta_add,\n\t\t.sta_remove = mt7915_mac_sta_remove,\n\t\t.update_survey = mt7915_update_channel,\n\t};\n\tstruct mt7915_dev *dev;\n\tstruct mt76_dev *mdev;\n\tint ret;\n\n\tmdev = mt76_alloc_device(pdev, sizeof(*dev), &mt7915_ops, &drv_ops);\n\tif (!mdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdev = container_of(mdev, struct mt7915_dev, mt76);\n\n\tret = mt7915_mmio_init(mdev, mem_base, device_id);\n\tif (ret)\n\t\tgoto error;\n\n\ttasklet_setup(&mdev->irq_tasklet, mt7915_irq_tasklet);\n\n\treturn dev;\n\nerror:\n\tmt76_free_device(&dev->mt76);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic int __init mt7915_init(void)\n{\n\tint ret;\n\n\tret = pci_register_driver(&mt7915_hif_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_register_driver(&mt7915_pci_driver);\n\tif (ret)\n\t\tgoto error_pci;\n\n\tif (IS_ENABLED(CONFIG_MT798X_WMAC)) {\n\t\tret = platform_driver_register(&mt798x_wmac_driver);\n\t\tif (ret)\n\t\t\tgoto error_wmac;\n\t}\n\n\treturn 0;\n\nerror_wmac:\n\tpci_unregister_driver(&mt7915_pci_driver);\nerror_pci:\n\tpci_unregister_driver(&mt7915_hif_driver);\n\n\treturn ret;\n}\n\nstatic void __exit mt7915_exit(void)\n{\n\tif (IS_ENABLED(CONFIG_MT798X_WMAC))\n\t\tplatform_driver_unregister(&mt798x_wmac_driver);\n\n\tpci_unregister_driver(&mt7915_pci_driver);\n\tpci_unregister_driver(&mt7915_hif_driver);\n}\n\nmodule_init(mt7915_init);\nmodule_exit(mt7915_exit);\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}