{
  "module_name": "init.c",
  "hash_id": "0ab484379191f42fc341b9c01e2d4a8802f981f2b1a0c4551d7b2ba4a77514a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7915/init.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/of.h>\n#include <linux/thermal.h>\n#include \"mt7915.h\"\n#include \"mac.h\"\n#include \"mcu.h\"\n#include \"coredump.h\"\n#include \"eeprom.h\"\n\nstatic const struct ieee80211_iface_limit if_limits[] = {\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_ADHOC)\n\t}, {\n\t\t.max = 16,\n\t\t.types = BIT(NL80211_IFTYPE_AP)\n#ifdef CONFIG_MAC80211_MESH\n\t\t\t | BIT(NL80211_IFTYPE_MESH_POINT)\n#endif\n\t}, {\n\t\t.max = MT7915_MAX_INTERFACES,\n\t\t.types = BIT(NL80211_IFTYPE_STATION)\n\t}\n};\n\nstatic const struct ieee80211_iface_combination if_comb[] = {\n\t{\n\t\t.limits = if_limits,\n\t\t.n_limits = ARRAY_SIZE(if_limits),\n\t\t.max_interfaces = MT7915_MAX_INTERFACES,\n\t\t.num_different_channels = 1,\n\t\t.beacon_int_infra_match = true,\n\t\t.radar_detect_widths = BIT(NL80211_CHAN_WIDTH_20_NOHT) |\n\t\t\t\t       BIT(NL80211_CHAN_WIDTH_20) |\n\t\t\t\t       BIT(NL80211_CHAN_WIDTH_40) |\n\t\t\t\t       BIT(NL80211_CHAN_WIDTH_80) |\n\t\t\t\t       BIT(NL80211_CHAN_WIDTH_160),\n\t}\n};\n\nstatic ssize_t mt7915_thermal_temp_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct mt7915_phy *phy = dev_get_drvdata(dev);\n\tint i = to_sensor_dev_attr(attr)->index;\n\tint temperature;\n\n\tswitch (i) {\n\tcase 0:\n\t\ttemperature = mt7915_mcu_get_temperature(phy);\n\t\tif (temperature < 0)\n\t\t\treturn temperature;\n\t\t \n\t\treturn sprintf(buf, \"%u\\n\", temperature * 1000);\n\tcase 1:\n\tcase 2:\n\t\treturn sprintf(buf, \"%u\\n\",\n\t\t\t       phy->throttle_temp[i - 1] * 1000);\n\tcase 3:\n\t\treturn sprintf(buf, \"%hhu\\n\", phy->throttle_state);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic ssize_t mt7915_thermal_temp_store(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tstruct mt7915_phy *phy = dev_get_drvdata(dev);\n\tint ret, i = to_sensor_dev_attr(attr)->index;\n\tlong val;\n\n\tret = kstrtol(buf, 10, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&phy->dev->mt76.mutex);\n\tval = clamp_val(DIV_ROUND_CLOSEST(val, 1000), 60, 130);\n\n\tif ((i - 1 == MT7915_CRIT_TEMP_IDX &&\n\t     val > phy->throttle_temp[MT7915_MAX_TEMP_IDX]) ||\n\t    (i - 1 == MT7915_MAX_TEMP_IDX &&\n\t     val < phy->throttle_temp[MT7915_CRIT_TEMP_IDX])) {\n\t\tdev_err(phy->dev->mt76.dev,\n\t\t\t\"temp1_max shall be greater than temp1_crit.\");\n\t\tmutex_unlock(&phy->dev->mt76.mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tphy->throttle_temp[i - 1] = val;\n\tmutex_unlock(&phy->dev->mt76.mutex);\n\n\tret = mt7915_mcu_set_thermal_protect(phy);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, mt7915_thermal_temp, 0);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_crit, mt7915_thermal_temp, 1);\nstatic SENSOR_DEVICE_ATTR_RW(temp1_max, mt7915_thermal_temp, 2);\nstatic SENSOR_DEVICE_ATTR_RO(throttle1, mt7915_thermal_temp, 3);\n\nstatic struct attribute *mt7915_hwmon_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\t&sensor_dev_attr_throttle1.dev_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(mt7915_hwmon);\n\nstatic int\nmt7915_thermal_get_max_throttle_state(struct thermal_cooling_device *cdev,\n\t\t\t\t      unsigned long *state)\n{\n\t*state = MT7915_CDEV_THROTTLE_MAX;\n\n\treturn 0;\n}\n\nstatic int\nmt7915_thermal_get_cur_throttle_state(struct thermal_cooling_device *cdev,\n\t\t\t\t      unsigned long *state)\n{\n\tstruct mt7915_phy *phy = cdev->devdata;\n\n\t*state = phy->cdev_state;\n\n\treturn 0;\n}\n\nstatic int\nmt7915_thermal_set_cur_throttle_state(struct thermal_cooling_device *cdev,\n\t\t\t\t      unsigned long state)\n{\n\tstruct mt7915_phy *phy = cdev->devdata;\n\tu8 throttling = MT7915_THERMAL_THROTTLE_MAX - state;\n\tint ret;\n\n\tif (state > MT7915_CDEV_THROTTLE_MAX) {\n\t\tdev_err(phy->dev->mt76.dev,\n\t\t\t\"please specify a valid throttling state\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (state == phy->cdev_state)\n\t\treturn 0;\n\n\t \n\tret = mt7915_mcu_set_thermal_throttling(phy, throttling);\n\tif (ret)\n\t\treturn ret;\n\n\tphy->cdev_state = state;\n\n\treturn 0;\n}\n\nstatic const struct thermal_cooling_device_ops mt7915_thermal_ops = {\n\t.get_max_state = mt7915_thermal_get_max_throttle_state,\n\t.get_cur_state = mt7915_thermal_get_cur_throttle_state,\n\t.set_cur_state = mt7915_thermal_set_cur_throttle_state,\n};\n\nstatic void mt7915_unregister_thermal(struct mt7915_phy *phy)\n{\n\tstruct wiphy *wiphy = phy->mt76->hw->wiphy;\n\n\tif (!phy->cdev)\n\t\treturn;\n\n\tsysfs_remove_link(&wiphy->dev.kobj, \"cooling_device\");\n\tthermal_cooling_device_unregister(phy->cdev);\n}\n\nstatic int mt7915_thermal_init(struct mt7915_phy *phy)\n{\n\tstruct wiphy *wiphy = phy->mt76->hw->wiphy;\n\tstruct thermal_cooling_device *cdev;\n\tstruct device *hwmon;\n\tconst char *name;\n\n\tname = devm_kasprintf(&wiphy->dev, GFP_KERNEL, \"mt7915_%s\",\n\t\t\t      wiphy_name(wiphy));\n\n\tcdev = thermal_cooling_device_register(name, phy, &mt7915_thermal_ops);\n\tif (!IS_ERR(cdev)) {\n\t\tif (sysfs_create_link(&wiphy->dev.kobj, &cdev->device.kobj,\n\t\t\t\t      \"cooling_device\") < 0)\n\t\t\tthermal_cooling_device_unregister(cdev);\n\t\telse\n\t\t\tphy->cdev = cdev;\n\t}\n\n\t \n\tphy->throttle_temp[MT7915_CRIT_TEMP_IDX] = MT7915_CRIT_TEMP;\n\tphy->throttle_temp[MT7915_MAX_TEMP_IDX] = MT7915_MAX_TEMP;\n\n\tif (!IS_REACHABLE(CONFIG_HWMON))\n\t\treturn 0;\n\n\thwmon = devm_hwmon_device_register_with_groups(&wiphy->dev, name, phy,\n\t\t\t\t\t\t       mt7915_hwmon_groups);\n\tif (IS_ERR(hwmon))\n\t\treturn PTR_ERR(hwmon);\n\n\treturn 0;\n}\n\nstatic void mt7915_led_set_config(struct led_classdev *led_cdev,\n\t\t\t\t  u8 delay_on, u8 delay_off)\n{\n\tstruct mt7915_dev *dev;\n\tstruct mt76_phy *mphy;\n\tu32 val;\n\n\tmphy = container_of(led_cdev, struct mt76_phy, leds.cdev);\n\tdev = container_of(mphy->dev, struct mt7915_dev, mt76);\n\n\t \n\tval = FIELD_PREP(MT_LED_STATUS_DURATION, 0xffff) |\n\t      FIELD_PREP(MT_LED_STATUS_OFF, delay_off) |\n\t      FIELD_PREP(MT_LED_STATUS_ON, delay_on);\n\tmt76_wr(dev, MT_LED_STATUS_0(mphy->band_idx), val);\n\tmt76_wr(dev, MT_LED_STATUS_1(mphy->band_idx), val);\n\n\t \n\tmt76_wr(dev, MT_LED_EN(mphy->band_idx), 1);\n\n\t \n\tval = MT_LED_CTRL_KICK;\n\tif (dev->mphy.leds.al)\n\t\tval |= MT_LED_CTRL_POLARITY;\n\tif (mphy->band_idx)\n\t\tval |= MT_LED_CTRL_BAND;\n\n\tmt76_wr(dev, MT_LED_CTRL(mphy->band_idx), val);\n\tmt76_clear(dev, MT_LED_CTRL(mphy->band_idx), MT_LED_CTRL_KICK);\n}\n\nstatic int mt7915_led_set_blink(struct led_classdev *led_cdev,\n\t\t\t\tunsigned long *delay_on,\n\t\t\t\tunsigned long *delay_off)\n{\n\tu16 delta_on = 0, delta_off = 0;\n\n#define HW_TICK\t\t10\n#define TO_HW_TICK(_t)\t(((_t) > HW_TICK) ? ((_t) / HW_TICK) : HW_TICK)\n\n\tif (*delay_on)\n\t\tdelta_on = TO_HW_TICK(*delay_on);\n\tif (*delay_off)\n\t\tdelta_off = TO_HW_TICK(*delay_off);\n\n\tmt7915_led_set_config(led_cdev, delta_on, delta_off);\n\n\treturn 0;\n}\n\nstatic void mt7915_led_set_brightness(struct led_classdev *led_cdev,\n\t\t\t\t      enum led_brightness brightness)\n{\n\tif (!brightness)\n\t\tmt7915_led_set_config(led_cdev, 0, 0xff);\n\telse\n\t\tmt7915_led_set_config(led_cdev, 0xff, 0);\n}\n\nvoid mt7915_init_txpower(struct mt7915_dev *dev,\n\t\t\t struct ieee80211_supported_band *sband)\n{\n\tint i, n_chains = hweight8(dev->mphy.antenna_mask);\n\tint nss_delta = mt76_tx_power_nss_delta(n_chains);\n\tint pwr_delta = mt7915_eeprom_get_power_delta(dev, sband->band);\n\tstruct mt76_power_limits limits;\n\n\tfor (i = 0; i < sband->n_channels; i++) {\n\t\tstruct ieee80211_channel *chan = &sband->channels[i];\n\t\tu32 target_power = 0;\n\t\tint j;\n\n\t\tfor (j = 0; j < n_chains; j++) {\n\t\t\tu32 val;\n\n\t\t\tval = mt7915_eeprom_get_target_power(dev, chan, j);\n\t\t\ttarget_power = max(target_power, val);\n\t\t}\n\n\t\ttarget_power += pwr_delta;\n\t\ttarget_power = mt76_get_rate_power_limits(&dev->mphy, chan,\n\t\t\t\t\t\t\t  &limits,\n\t\t\t\t\t\t\t  target_power);\n\t\ttarget_power += nss_delta;\n\t\ttarget_power = DIV_ROUND_UP(target_power, 2);\n\t\tchan->max_power = min_t(int, chan->max_reg_power,\n\t\t\t\t\ttarget_power);\n\t\tchan->orig_mpwr = target_power;\n\t}\n}\n\nstatic void\nmt7915_regd_notifier(struct wiphy *wiphy,\n\t\t     struct regulatory_request *request)\n{\n\tstruct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tstruct mt76_phy *mphy = hw->priv;\n\tstruct mt7915_phy *phy = mphy->priv;\n\n\tmemcpy(dev->mt76.alpha2, request->alpha2, sizeof(dev->mt76.alpha2));\n\tdev->mt76.region = request->dfs_region;\n\n\tif (dev->mt76.region == NL80211_DFS_UNSET)\n\t\tmt7915_mcu_rdd_background_enable(phy, NULL);\n\n\tmt7915_init_txpower(dev, &mphy->sband_2g.sband);\n\tmt7915_init_txpower(dev, &mphy->sband_5g.sband);\n\tmt7915_init_txpower(dev, &mphy->sband_6g.sband);\n\n\tmphy->dfs_state = MT_DFS_STATE_UNKNOWN;\n\tmt7915_dfs_init_radar_detector(phy);\n}\n\nstatic void\nmt7915_init_wiphy(struct mt7915_phy *phy)\n{\n\tstruct mt76_phy *mphy = phy->mt76;\n\tstruct ieee80211_hw *hw = mphy->hw;\n\tstruct mt76_dev *mdev = &phy->dev->mt76;\n\tstruct wiphy *wiphy = hw->wiphy;\n\tstruct mt7915_dev *dev = phy->dev;\n\n\thw->queues = 4;\n\thw->max_rx_aggregation_subframes = IEEE80211_MAX_AMPDU_BUF_HE;\n\thw->max_tx_aggregation_subframes = IEEE80211_MAX_AMPDU_BUF_HE;\n\thw->netdev_features = NETIF_F_RXCSUM;\n\n\thw->radiotap_timestamp.units_pos =\n\t\tIEEE80211_RADIOTAP_TIMESTAMP_UNIT_US;\n\n\tphy->slottime = 9;\n\n\thw->sta_data_size = sizeof(struct mt7915_sta);\n\thw->vif_data_size = sizeof(struct mt7915_vif);\n\n\twiphy->iface_combinations = if_comb;\n\twiphy->n_iface_combinations = ARRAY_SIZE(if_comb);\n\twiphy->reg_notifier = mt7915_regd_notifier;\n\twiphy->flags |= WIPHY_FLAG_HAS_CHANNEL_SWITCH;\n\twiphy->mbssid_max_interfaces = 16;\n\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_BSS_COLOR);\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_VHT_IBSS);\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_BEACON_RATE_LEGACY);\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_BEACON_RATE_HT);\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_BEACON_RATE_VHT);\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_BEACON_RATE_HE);\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_UNSOL_BCAST_PROBE_RESP);\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_FILS_DISCOVERY);\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT);\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_CAN_REPLACE_PTK0);\n\n\tif (!is_mt7915(&dev->mt76))\n\t\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_STA_TX_PWR);\n\n\tif (!mdev->dev->of_node ||\n\t    !of_property_read_bool(mdev->dev->of_node,\n\t\t\t\t   \"mediatek,disable-radar-background\"))\n\t\twiphy_ext_feature_set(wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_RADAR_BACKGROUND);\n\n\tieee80211_hw_set(hw, HAS_RATE_CONTROL);\n\tieee80211_hw_set(hw, SUPPORTS_TX_ENCAP_OFFLOAD);\n\tieee80211_hw_set(hw, SUPPORTS_RX_DECAP_OFFLOAD);\n\tieee80211_hw_set(hw, SUPPORTS_MULTI_BSSID);\n\tieee80211_hw_set(hw, WANT_MONITOR_VIF);\n\n\thw->max_tx_fragments = 4;\n\n\tif (phy->mt76->cap.has_2ghz) {\n\t\tphy->mt76->sband_2g.sband.ht_cap.cap |=\n\t\t\tIEEE80211_HT_CAP_LDPC_CODING |\n\t\t\tIEEE80211_HT_CAP_MAX_AMSDU;\n\t\tphy->mt76->sband_2g.sband.ht_cap.ampdu_density =\n\t\t\tIEEE80211_HT_MPDU_DENSITY_4;\n\t}\n\n\tif (phy->mt76->cap.has_5ghz) {\n\t\tstruct ieee80211_sta_vht_cap *vht_cap;\n\n\t\tvht_cap = &phy->mt76->sband_5g.sband.vht_cap;\n\t\tphy->mt76->sband_5g.sband.ht_cap.cap |=\n\t\t\tIEEE80211_HT_CAP_LDPC_CODING |\n\t\t\tIEEE80211_HT_CAP_MAX_AMSDU;\n\t\tphy->mt76->sband_5g.sband.ht_cap.ampdu_density =\n\t\t\tIEEE80211_HT_MPDU_DENSITY_4;\n\n\t\tif (is_mt7915(&dev->mt76)) {\n\t\t\tvht_cap->cap |=\n\t\t\t\tIEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991 |\n\t\t\t\tIEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK;\n\n\t\t\tif (!dev->dbdc_support)\n\t\t\t\tvht_cap->cap |=\n\t\t\t\t\tIEEE80211_VHT_CAP_SHORT_GI_160 |\n\t\t\t\t\tFIELD_PREP(IEEE80211_VHT_CAP_EXT_NSS_BW_MASK, 1);\n\t\t} else {\n\t\t\tvht_cap->cap |=\n\t\t\t\tIEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454 |\n\t\t\t\tIEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK;\n\n\t\t\t \n\t\t\tvht_cap->cap |=\n\t\t\t\tIEEE80211_VHT_CAP_SHORT_GI_160 |\n\t\t\t\tIEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ;\n\t\t}\n\n\t\tif (!is_mt7915(&dev->mt76) || !dev->dbdc_support)\n\t\t\tieee80211_hw_set(hw, SUPPORTS_VHT_EXT_NSS_BW);\n\t}\n\n\tmt76_set_stream_caps(phy->mt76, true);\n\tmt7915_set_stream_vht_txbf_caps(phy);\n\tmt7915_set_stream_he_caps(phy);\n\n\twiphy->available_antennas_rx = phy->mt76->antenna_mask;\n\twiphy->available_antennas_tx = phy->mt76->antenna_mask;\n\n\t \n\tif (IS_ENABLED(CONFIG_MT76_LEDS)) {\n\t\tmphy->leds.cdev.brightness_set = mt7915_led_set_brightness;\n\t\tmphy->leds.cdev.blink_set = mt7915_led_set_blink;\n\t}\n}\n\nstatic void\nmt7915_mac_init_band(struct mt7915_dev *dev, u8 band)\n{\n\tu32 mask, set;\n\n\tmt76_rmw_field(dev, MT_TMAC_CTCR0(band),\n\t\t       MT_TMAC_CTCR0_INS_DDLMT_REFTIME, 0x3f);\n\tmt76_set(dev, MT_TMAC_CTCR0(band),\n\t\t MT_TMAC_CTCR0_INS_DDLMT_VHT_SMPDU_EN |\n\t\t MT_TMAC_CTCR0_INS_DDLMT_EN);\n\n\tmask = MT_MDP_RCFR0_MCU_RX_MGMT |\n\t       MT_MDP_RCFR0_MCU_RX_CTL_NON_BAR |\n\t       MT_MDP_RCFR0_MCU_RX_CTL_BAR;\n\tset = FIELD_PREP(MT_MDP_RCFR0_MCU_RX_MGMT, MT_MDP_TO_HIF) |\n\t      FIELD_PREP(MT_MDP_RCFR0_MCU_RX_CTL_NON_BAR, MT_MDP_TO_HIF) |\n\t      FIELD_PREP(MT_MDP_RCFR0_MCU_RX_CTL_BAR, MT_MDP_TO_HIF);\n\tmt76_rmw(dev, MT_MDP_BNRCFR0(band), mask, set);\n\n\tmask = MT_MDP_RCFR1_MCU_RX_BYPASS |\n\t       MT_MDP_RCFR1_RX_DROPPED_UCAST |\n\t       MT_MDP_RCFR1_RX_DROPPED_MCAST;\n\tset = FIELD_PREP(MT_MDP_RCFR1_MCU_RX_BYPASS, MT_MDP_TO_HIF) |\n\t      FIELD_PREP(MT_MDP_RCFR1_RX_DROPPED_UCAST, MT_MDP_TO_HIF) |\n\t      FIELD_PREP(MT_MDP_RCFR1_RX_DROPPED_MCAST, MT_MDP_TO_HIF);\n\tmt76_rmw(dev, MT_MDP_BNRCFR1(band), mask, set);\n\n\tmt76_rmw_field(dev, MT_DMA_DCR0(band), MT_DMA_DCR0_MAX_RX_LEN, 0x680);\n\n\t \n\tmt76_clear(dev, MT_DMA_DCR0(band), MT_DMA_DCR0_RXD_G5_EN);\n\n\t \n\tmt76_wr(dev, MT_WF_RMAC_RSVD0(band), MT_WF_RMAC_RSVD0_EIFS_CLR);\n\n\t \n\tmt76_clear(dev, MT_WF_RMAC_MIB_AIRTIME1(band),\n\t\t   MT_WF_RMAC_MIB_NONQOSD_BACKOFF);\n\tmt76_clear(dev, MT_WF_RMAC_MIB_AIRTIME3(band),\n\t\t   MT_WF_RMAC_MIB_QOS01_BACKOFF);\n\tmt76_clear(dev, MT_WF_RMAC_MIB_AIRTIME4(band),\n\t\t   MT_WF_RMAC_MIB_QOS23_BACKOFF);\n\n\t \n\tmask = MT_WF_RMAC_MIB_OBSS_BACKOFF | MT_WF_RMAC_MIB_ED_OFFSET;\n\tset = FIELD_PREP(MT_WF_RMAC_MIB_OBSS_BACKOFF, 0) |\n\t      FIELD_PREP(MT_WF_RMAC_MIB_ED_OFFSET, 4);\n\tmt76_rmw(dev, MT_WF_RMAC_MIB_AIRTIME0(band), mask, set);\n\n\t \n\tmask = MT_WTBLOFF_TOP_RSCR_RCPI_MODE | MT_WTBLOFF_TOP_RSCR_RCPI_PARAM;\n\tset = FIELD_PREP(MT_WTBLOFF_TOP_RSCR_RCPI_MODE, 0) |\n\t      FIELD_PREP(MT_WTBLOFF_TOP_RSCR_RCPI_PARAM, 0x3);\n\tmt76_rmw(dev, MT_WTBLOFF_TOP_RSCR(band), mask, set);\n\n\t \n\tif (mtk_wed_device_active(&dev->mt76.mmio.wed))\n\t\tmt76_set(dev, MT_AGG_ACR4(band), MT_AGG_ACR_PPDU_TXS2H);\n}\n\nstatic void\nmt7915_init_led_mux(struct mt7915_dev *dev)\n{\n\tif (!IS_ENABLED(CONFIG_MT76_LEDS))\n\t\treturn;\n\n\tif (dev->dbdc_support) {\n\t\tswitch (mt76_chip(&dev->mt76)) {\n\t\tcase 0x7915:\n\t\t\tmt76_rmw_field(dev, MT_LED_GPIO_MUX2,\n\t\t\t\t       GENMASK(11, 8), 4);\n\t\t\tmt76_rmw_field(dev, MT_LED_GPIO_MUX3,\n\t\t\t\t       GENMASK(11, 8), 4);\n\t\t\tbreak;\n\t\tcase 0x7986:\n\t\t\tmt76_rmw_field(dev, MT_LED_GPIO_MUX0,\n\t\t\t\t       GENMASK(7, 4), 1);\n\t\t\tmt76_rmw_field(dev, MT_LED_GPIO_MUX0,\n\t\t\t\t       GENMASK(11, 8), 1);\n\t\t\tbreak;\n\t\tcase 0x7916:\n\t\t\tmt76_rmw_field(dev, MT_LED_GPIO_MUX1,\n\t\t\t\t       GENMASK(27, 24), 3);\n\t\t\tmt76_rmw_field(dev, MT_LED_GPIO_MUX1,\n\t\t\t\t       GENMASK(31, 28), 3);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else if (dev->mphy.leds.pin) {\n\t\tswitch (mt76_chip(&dev->mt76)) {\n\t\tcase 0x7915:\n\t\t\tmt76_rmw_field(dev, MT_LED_GPIO_MUX3,\n\t\t\t\t       GENMASK(11, 8), 4);\n\t\t\tbreak;\n\t\tcase 0x7986:\n\t\t\tmt76_rmw_field(dev, MT_LED_GPIO_MUX0,\n\t\t\t\t       GENMASK(11, 8), 1);\n\t\t\tbreak;\n\t\tcase 0x7916:\n\t\t\tmt76_rmw_field(dev, MT_LED_GPIO_MUX1,\n\t\t\t\t       GENMASK(31, 28), 3);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (mt76_chip(&dev->mt76)) {\n\t\tcase 0x7915:\n\t\t\tmt76_rmw_field(dev, MT_LED_GPIO_MUX2,\n\t\t\t\t       GENMASK(11, 8), 4);\n\t\t\tbreak;\n\t\tcase 0x7986:\n\t\t\tmt76_rmw_field(dev, MT_LED_GPIO_MUX0,\n\t\t\t\t       GENMASK(7, 4), 1);\n\t\t\tbreak;\n\t\tcase 0x7916:\n\t\t\tmt76_rmw_field(dev, MT_LED_GPIO_MUX1,\n\t\t\t\t       GENMASK(27, 24), 3);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid mt7915_mac_init(struct mt7915_dev *dev)\n{\n\tint i;\n\tu32 rx_len = is_mt7915(&dev->mt76) ? 0x400 : 0x680;\n\n\t \n\tif (!is_mt7915(&dev->mt76) && dev->hif2)\n\t\tmt76_rmw(dev, MT_WF_PP_TOP_RXQ_WFDMA_CF_5, 0,\n\t\t\t MT_WF_PP_TOP_RXQ_QID6_WFDMA_HIF_SEL_MASK);\n\n\tmt76_rmw_field(dev, MT_MDP_DCR1, MT_MDP_DCR1_MAX_RX_LEN, rx_len);\n\n\tif (!is_mt7915(&dev->mt76))\n\t\tmt76_clear(dev, MT_MDP_DCR2, MT_MDP_DCR2_RX_TRANS_SHORT);\n\telse\n\t\tmt76_clear(dev, MT_PLE_HOST_RPT0, MT_PLE_HOST_RPT0_TX_LATENCY);\n\n\t \n\tmt76_set(dev, MT_MDP_DCR0, MT_MDP_DCR0_DAMSDU_EN);\n\n\tfor (i = 0; i < mt7915_wtbl_size(dev); i++)\n\t\tmt7915_mac_wtbl_update(dev, i,\n\t\t\t\t       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);\n\tfor (i = 0; i < 2; i++)\n\t\tmt7915_mac_init_band(dev, i);\n\n\tmt7915_init_led_mux(dev);\n}\n\nint mt7915_txbf_init(struct mt7915_dev *dev)\n{\n\tint ret;\n\n\tif (dev->dbdc_support) {\n\t\tret = mt7915_mcu_set_txbf(dev, MT_BF_MODULE_UPDATE);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = mt7915_mcu_set_txbf(dev, MT_BF_SOUNDING_ON);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn mt7915_mcu_set_txbf(dev, MT_BF_TYPE_UPDATE);\n}\n\nstatic struct mt7915_phy *\nmt7915_alloc_ext_phy(struct mt7915_dev *dev)\n{\n\tstruct mt7915_phy *phy;\n\tstruct mt76_phy *mphy;\n\n\tif (!dev->dbdc_support)\n\t\treturn NULL;\n\n\tmphy = mt76_alloc_phy(&dev->mt76, sizeof(*phy), &mt7915_ops, MT_BAND1);\n\tif (!mphy)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tphy = mphy->priv;\n\tphy->dev = dev;\n\tphy->mt76 = mphy;\n\n\t \n\tphy->mt76->band_idx = 1;\n\n\treturn phy;\n}\n\nstatic int\nmt7915_register_ext_phy(struct mt7915_dev *dev, struct mt7915_phy *phy)\n{\n\tstruct mt76_phy *mphy = phy->mt76;\n\tint ret;\n\n\tINIT_DELAYED_WORK(&mphy->mac_work, mt7915_mac_work);\n\n\tmt7915_eeprom_parse_hw_cap(dev, phy);\n\n\tmemcpy(mphy->macaddr, dev->mt76.eeprom.data + MT_EE_MAC_ADDR2,\n\t       ETH_ALEN);\n\t \n\tif (!is_valid_ether_addr(mphy->macaddr)) {\n\t\tmemcpy(mphy->macaddr, dev->mt76.eeprom.data + MT_EE_MAC_ADDR,\n\t\t       ETH_ALEN);\n\t\tmphy->macaddr[0] |= 2;\n\t\tmphy->macaddr[0] ^= BIT(7);\n\t}\n\tmt76_eeprom_override(mphy);\n\n\t \n\tmt7915_init_wiphy(phy);\n\n\tret = mt76_register_phy(mphy, true, mt76_rates,\n\t\t\t\tARRAY_SIZE(mt76_rates));\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7915_thermal_init(phy);\n\tif (ret)\n\t\tgoto unreg;\n\n\tmt7915_init_debugfs(phy);\n\n\treturn 0;\n\nunreg:\n\tmt76_unregister_phy(mphy);\n\treturn ret;\n}\n\nstatic void mt7915_init_work(struct work_struct *work)\n{\n\tstruct mt7915_dev *dev = container_of(work, struct mt7915_dev,\n\t\t\t\t init_work);\n\n\tmt7915_mcu_set_eeprom(dev);\n\tmt7915_mac_init(dev);\n\tmt7915_init_txpower(dev, &dev->mphy.sband_2g.sband);\n\tmt7915_init_txpower(dev, &dev->mphy.sband_5g.sband);\n\tmt7915_init_txpower(dev, &dev->mphy.sband_6g.sband);\n\tmt7915_txbf_init(dev);\n}\n\nvoid mt7915_wfsys_reset(struct mt7915_dev *dev)\n{\n#define MT_MCU_DUMMY_RANDOM\tGENMASK(15, 0)\n#define MT_MCU_DUMMY_DEFAULT\tGENMASK(31, 16)\n\n\tif (is_mt7915(&dev->mt76)) {\n\t\tu32 val = MT_TOP_PWR_KEY | MT_TOP_PWR_SW_PWR_ON | MT_TOP_PWR_PWR_ON;\n\n\t\tmt76_wr(dev, MT_MCU_WFDMA0_DUMMY_CR, MT_MCU_DUMMY_RANDOM);\n\n\t\t \n\t\tval |= MT_TOP_PWR_SW_RST;\n\t\tmt76_wr(dev, MT_TOP_PWR_CTRL, val);\n\n\t\t \n\t\tval &= ~MT_TOP_PWR_SW_RST;\n\t\tmt76_wr(dev, MT_TOP_PWR_CTRL, val);\n\n\t\t \n\t\tval |= MT_TOP_PWR_SW_RST;\n\t\tmt76_wr(dev, MT_TOP_PWR_CTRL, val);\n\n\t\t \n\t\tval &= ~MT_TOP_PWR_SW_RST;\n\t\tval |= MT_TOP_PWR_HW_CTRL;\n\t\tmt76_wr(dev, MT_TOP_PWR_CTRL, val);\n\n\t\t \n\t\tif (!mt76_poll_msec(dev, MT_MCU_WFDMA0_DUMMY_CR,\n\t\t\t\t    MT_MCU_DUMMY_DEFAULT, MT_MCU_DUMMY_DEFAULT,\n\t\t\t\t    1000)) {\n\t\t\tdev_err(dev->mt76.dev, \"wifi subsystem reset failure\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tmt76_clear(dev, MT_TOP_MISC, MT_TOP_MISC_FW_STATE);\n\n\t\tmsleep(100);\n\t} else if (is_mt798x(&dev->mt76)) {\n\t\tmt7986_wmac_disable(dev);\n\t\tmsleep(20);\n\n\t\tmt7986_wmac_enable(dev);\n\t\tmsleep(20);\n\t} else {\n\t\tmt76_set(dev, MT_WF_SUBSYS_RST, 0x1);\n\t\tmsleep(20);\n\n\t\tmt76_clear(dev, MT_WF_SUBSYS_RST, 0x1);\n\t\tmsleep(20);\n\t}\n}\n\nstatic bool mt7915_band_config(struct mt7915_dev *dev)\n{\n\tbool ret = true;\n\n\tdev->phy.mt76->band_idx = 0;\n\n\tif (is_mt798x(&dev->mt76)) {\n\t\tu32 sku = mt7915_check_adie(dev, true);\n\n\t\t \n\t\tif (sku == MT7975_ONE_ADIE || sku == MT7976_ONE_ADIE) {\n\t\t\tdev->phy.mt76->band_idx = 1;\n\t\t\tret = false;\n\t\t}\n\t} else {\n\t\tret = is_mt7915(&dev->mt76) ?\n\t\t      !!(mt76_rr(dev, MT_HW_BOUND) & BIT(5)) : true;\n\t}\n\n\treturn ret;\n}\n\nstatic int\nmt7915_init_hardware(struct mt7915_dev *dev, struct mt7915_phy *phy2)\n{\n\tint ret, idx;\n\n\tmt76_wr(dev, MT_INT_MASK_CSR, 0);\n\tmt76_wr(dev, MT_INT_SOURCE_CSR, ~0);\n\n\tINIT_WORK(&dev->init_work, mt7915_init_work);\n\n\tret = mt7915_dma_init(dev, phy2);\n\tif (ret)\n\t\treturn ret;\n\n\tset_bit(MT76_STATE_INITIALIZED, &dev->mphy.state);\n\n\tret = mt7915_mcu_init(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7915_eeprom_init(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (dev->flash_mode) {\n\t\tret = mt7915_mcu_apply_group_cal(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tidx = mt76_wcid_alloc(dev->mt76.wcid_mask, MT7915_WTBL_STA);\n\tif (idx)\n\t\treturn -ENOSPC;\n\n\tdev->mt76.global_wcid.idx = idx;\n\tdev->mt76.global_wcid.hw_key_idx = -1;\n\tdev->mt76.global_wcid.tx_info |= MT_WCID_TX_INFO_SET;\n\trcu_assign_pointer(dev->mt76.wcid[idx], &dev->mt76.global_wcid);\n\n\treturn 0;\n}\n\nvoid mt7915_set_stream_vht_txbf_caps(struct mt7915_phy *phy)\n{\n\tint sts;\n\tu32 *cap;\n\n\tif (!phy->mt76->cap.has_5ghz)\n\t\treturn;\n\n\tsts = hweight8(phy->mt76->chainmask);\n\tcap = &phy->mt76->sband_5g.sband.vht_cap.cap;\n\n\t*cap |= IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE |\n\t\tIEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE |\n\t\tFIELD_PREP(IEEE80211_VHT_CAP_BEAMFORMEE_STS_MASK,\n\t\t\t   sts - 1);\n\n\t*cap &= ~(IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MASK |\n\t\t  IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE |\n\t\t  IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE);\n\n\tif (sts < 2)\n\t\treturn;\n\n\t*cap |= IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE |\n\t\tIEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE |\n\t\tFIELD_PREP(IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MASK,\n\t\t\t   sts - 1);\n}\n\nstatic void\nmt7915_set_stream_he_txbf_caps(struct mt7915_phy *phy,\n\t\t\t       struct ieee80211_sta_he_cap *he_cap, int vif)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tstruct ieee80211_he_cap_elem *elem = &he_cap->he_cap_elem;\n\tint sts = hweight8(phy->mt76->chainmask);\n\tu8 c, sts_160 = sts;\n\n\t \n\tif (is_mt7915(&dev->mt76)) {\n\t\tif (!dev->dbdc_support)\n\t\t\tsts_160 /= 2;\n\t\telse\n\t\t\tsts_160 = 0;\n\t}\n\n#ifdef CONFIG_MAC80211_MESH\n\tif (vif == NL80211_IFTYPE_MESH_POINT)\n\t\treturn;\n#endif\n\n\telem->phy_cap_info[3] &= ~IEEE80211_HE_PHY_CAP3_SU_BEAMFORMER;\n\telem->phy_cap_info[4] &= ~IEEE80211_HE_PHY_CAP4_MU_BEAMFORMER;\n\n\tc = IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_MASK;\n\tif (sts_160)\n\t\tc |= IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_ABOVE_80MHZ_MASK;\n\telem->phy_cap_info[5] &= ~c;\n\n\tc = IEEE80211_HE_PHY_CAP6_TRIG_SU_BEAMFORMING_FB |\n\t    IEEE80211_HE_PHY_CAP6_TRIG_MU_BEAMFORMING_PARTIAL_BW_FB;\n\telem->phy_cap_info[6] &= ~c;\n\n\telem->phy_cap_info[7] &= ~IEEE80211_HE_PHY_CAP7_MAX_NC_MASK;\n\n\tc = IEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US;\n\tif (!is_mt7915(&dev->mt76))\n\t\tc |= IEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO |\n\t\t     IEEE80211_HE_PHY_CAP2_UL_MU_PARTIAL_MU_MIMO;\n\telem->phy_cap_info[2] |= c;\n\n\tc = IEEE80211_HE_PHY_CAP4_SU_BEAMFORMEE |\n\t    IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_4;\n\tif (sts_160)\n\t\tc |= IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_ABOVE_80MHZ_4;\n\telem->phy_cap_info[4] |= c;\n\n\t \n\tc = IEEE80211_HE_PHY_CAP6_CODEBOOK_SIZE_42_SU |\n\t    IEEE80211_HE_PHY_CAP6_CODEBOOK_SIZE_75_MU;\n\n\tif (vif == NL80211_IFTYPE_STATION)\n\t\tc |= IEEE80211_HE_PHY_CAP6_PARTIAL_BANDWIDTH_DL_MUMIMO;\n\n\telem->phy_cap_info[6] |= c;\n\n\tif (sts < 2)\n\t\treturn;\n\n\t \n\telem->phy_cap_info[7] |= min_t(int, sts - 1, 2) << 3;\n\n\tif (vif != NL80211_IFTYPE_AP)\n\t\treturn;\n\n\telem->phy_cap_info[3] |= IEEE80211_HE_PHY_CAP3_SU_BEAMFORMER;\n\telem->phy_cap_info[4] |= IEEE80211_HE_PHY_CAP4_MU_BEAMFORMER;\n\n\tc = FIELD_PREP(IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_MASK,\n\t\t       sts - 1);\n\tif (sts_160)\n\t\tc |= FIELD_PREP(IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_ABOVE_80MHZ_MASK,\n\t\t\t\tsts_160 - 1);\n\telem->phy_cap_info[5] |= c;\n\n\tc = IEEE80211_HE_PHY_CAP6_TRIG_SU_BEAMFORMING_FB |\n\t    IEEE80211_HE_PHY_CAP6_TRIG_MU_BEAMFORMING_PARTIAL_BW_FB;\n\telem->phy_cap_info[6] |= c;\n\n\tif (!is_mt7915(&dev->mt76)) {\n\t\tc = IEEE80211_HE_PHY_CAP7_STBC_TX_ABOVE_80MHZ |\n\t\t    IEEE80211_HE_PHY_CAP7_STBC_RX_ABOVE_80MHZ;\n\t\telem->phy_cap_info[7] |= c;\n\t}\n}\n\nstatic int\nmt7915_init_he_caps(struct mt7915_phy *phy, enum nl80211_band band,\n\t\t    struct ieee80211_sband_iftype_data *data)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tint i, idx = 0, nss = hweight8(phy->mt76->antenna_mask);\n\tu16 mcs_map = 0;\n\tu16 mcs_map_160 = 0;\n\tu8 nss_160;\n\n\tif (!is_mt7915(&dev->mt76))\n\t\tnss_160 = nss;\n\telse if (!dev->dbdc_support)\n\t\t \n\t\tnss_160 = nss / 2;\n\telse\n\t\t \n\t\tnss_160 = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (i < nss)\n\t\t\tmcs_map |= (IEEE80211_HE_MCS_SUPPORT_0_11 << (i * 2));\n\t\telse\n\t\t\tmcs_map |= (IEEE80211_HE_MCS_NOT_SUPPORTED << (i * 2));\n\n\t\tif (i < nss_160)\n\t\t\tmcs_map_160 |= (IEEE80211_HE_MCS_SUPPORT_0_11 << (i * 2));\n\t\telse\n\t\t\tmcs_map_160 |= (IEEE80211_HE_MCS_NOT_SUPPORTED << (i * 2));\n\t}\n\n\tfor (i = 0; i < NUM_NL80211_IFTYPES; i++) {\n\t\tstruct ieee80211_sta_he_cap *he_cap = &data[idx].he_cap;\n\t\tstruct ieee80211_he_cap_elem *he_cap_elem =\n\t\t\t\t&he_cap->he_cap_elem;\n\t\tstruct ieee80211_he_mcs_nss_supp *he_mcs =\n\t\t\t\t&he_cap->he_mcs_nss_supp;\n\n\t\tswitch (i) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\tcase NL80211_IFTYPE_AP:\n#ifdef CONFIG_MAC80211_MESH\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n#endif\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tdata[idx].types_mask = BIT(i);\n\t\the_cap->has_he = true;\n\n\t\the_cap_elem->mac_cap_info[0] =\n\t\t\tIEEE80211_HE_MAC_CAP0_HTC_HE;\n\t\the_cap_elem->mac_cap_info[3] =\n\t\t\tIEEE80211_HE_MAC_CAP3_OMI_CONTROL |\n\t\t\tIEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_3;\n\t\the_cap_elem->mac_cap_info[4] =\n\t\t\tIEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU;\n\n\t\tif (band == NL80211_BAND_2GHZ)\n\t\t\the_cap_elem->phy_cap_info[0] =\n\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G;\n\t\telse if (nss_160)\n\t\t\the_cap_elem->phy_cap_info[0] =\n\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |\n\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G;\n\t\telse\n\t\t\the_cap_elem->phy_cap_info[0] =\n\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G;\n\n\t\the_cap_elem->phy_cap_info[1] =\n\t\t\tIEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD;\n\t\the_cap_elem->phy_cap_info[2] =\n\t\t\tIEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ |\n\t\t\tIEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ;\n\n\t\tswitch (i) {\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\the_cap_elem->mac_cap_info[0] |=\n\t\t\t\tIEEE80211_HE_MAC_CAP0_TWT_RES;\n\t\t\the_cap_elem->mac_cap_info[2] |=\n\t\t\t\tIEEE80211_HE_MAC_CAP2_BSR;\n\t\t\the_cap_elem->mac_cap_info[4] |=\n\t\t\t\tIEEE80211_HE_MAC_CAP4_BQR;\n\t\t\the_cap_elem->mac_cap_info[5] |=\n\t\t\t\tIEEE80211_HE_MAC_CAP5_OM_CTRL_UL_MU_DATA_DIS_RX;\n\t\t\the_cap_elem->phy_cap_info[3] |=\n\t\t\t\tIEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_QPSK |\n\t\t\t\tIEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_QPSK;\n\t\t\the_cap_elem->phy_cap_info[6] |=\n\t\t\t\tIEEE80211_HE_PHY_CAP6_PARTIAL_BW_EXT_RANGE |\n\t\t\t\tIEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT;\n\t\t\the_cap_elem->phy_cap_info[9] |=\n\t\t\t\tIEEE80211_HE_PHY_CAP9_TX_1024_QAM_LESS_THAN_242_TONE_RU |\n\t\t\t\tIEEE80211_HE_PHY_CAP9_RX_1024_QAM_LESS_THAN_242_TONE_RU;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\the_cap_elem->mac_cap_info[1] |=\n\t\t\t\tIEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US;\n\n\t\t\tif (band == NL80211_BAND_2GHZ)\n\t\t\t\the_cap_elem->phy_cap_info[0] |=\n\t\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_RU_MAPPING_IN_2G;\n\t\t\telse\n\t\t\t\the_cap_elem->phy_cap_info[0] |=\n\t\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_RU_MAPPING_IN_5G;\n\n\t\t\the_cap_elem->phy_cap_info[1] |=\n\t\t\t\tIEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |\n\t\t\t\tIEEE80211_HE_PHY_CAP1_HE_LTF_AND_GI_FOR_HE_PPDUS_0_8US;\n\t\t\the_cap_elem->phy_cap_info[3] |=\n\t\t\t\tIEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_QPSK |\n\t\t\t\tIEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_QPSK;\n\t\t\the_cap_elem->phy_cap_info[6] |=\n\t\t\t\tIEEE80211_HE_PHY_CAP6_TRIG_CQI_FB |\n\t\t\t\tIEEE80211_HE_PHY_CAP6_PARTIAL_BW_EXT_RANGE |\n\t\t\t\tIEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT;\n\t\t\the_cap_elem->phy_cap_info[7] |=\n\t\t\t\tIEEE80211_HE_PHY_CAP7_POWER_BOOST_FACTOR_SUPP |\n\t\t\t\tIEEE80211_HE_PHY_CAP7_HE_SU_MU_PPDU_4XLTF_AND_08_US_GI;\n\t\t\the_cap_elem->phy_cap_info[8] |=\n\t\t\t\tIEEE80211_HE_PHY_CAP8_20MHZ_IN_40MHZ_HE_PPDU_IN_2G |\n\t\t\t\tIEEE80211_HE_PHY_CAP8_DCM_MAX_RU_484;\n\t\t\tif (nss_160)\n\t\t\t\the_cap_elem->phy_cap_info[8] |=\n\t\t\t\t\tIEEE80211_HE_PHY_CAP8_20MHZ_IN_160MHZ_HE_PPDU |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP8_80MHZ_IN_160MHZ_HE_PPDU;\n\t\t\the_cap_elem->phy_cap_info[9] |=\n\t\t\t\tIEEE80211_HE_PHY_CAP9_LONGER_THAN_16_SIGB_OFDM_SYM |\n\t\t\t\tIEEE80211_HE_PHY_CAP9_NON_TRIGGERED_CQI_FEEDBACK |\n\t\t\t\tIEEE80211_HE_PHY_CAP9_TX_1024_QAM_LESS_THAN_242_TONE_RU |\n\t\t\t\tIEEE80211_HE_PHY_CAP9_RX_1024_QAM_LESS_THAN_242_TONE_RU |\n\t\t\t\tIEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_COMP_SIGB |\n\t\t\t\tIEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_NON_COMP_SIGB;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(he_mcs, 0, sizeof(*he_mcs));\n\t\the_mcs->rx_mcs_80 = cpu_to_le16(mcs_map);\n\t\the_mcs->tx_mcs_80 = cpu_to_le16(mcs_map);\n\t\the_mcs->rx_mcs_160 = cpu_to_le16(mcs_map_160);\n\t\the_mcs->tx_mcs_160 = cpu_to_le16(mcs_map_160);\n\n\t\tmt7915_set_stream_he_txbf_caps(phy, he_cap, i);\n\n\t\tmemset(he_cap->ppe_thres, 0, sizeof(he_cap->ppe_thres));\n\t\tif (he_cap_elem->phy_cap_info[6] &\n\t\t    IEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT) {\n\t\t\tmt76_connac_gen_ppe_thresh(he_cap->ppe_thres, nss);\n\t\t} else {\n\t\t\the_cap_elem->phy_cap_info[9] |=\n\t\t\t\tu8_encode_bits(IEEE80211_HE_PHY_CAP9_NOMINAL_PKT_PADDING_16US,\n\t\t\t\t\t       IEEE80211_HE_PHY_CAP9_NOMINAL_PKT_PADDING_MASK);\n\t\t}\n\n\t\tif (band == NL80211_BAND_6GHZ) {\n\t\t\tu16 cap = IEEE80211_HE_6GHZ_CAP_TX_ANTPAT_CONS |\n\t\t\t\t  IEEE80211_HE_6GHZ_CAP_RX_ANTPAT_CONS;\n\n\t\t\tcap |= u16_encode_bits(IEEE80211_HT_MPDU_DENSITY_2,\n\t\t\t\t\t       IEEE80211_HE_6GHZ_CAP_MIN_MPDU_START) |\n\t\t\t       u16_encode_bits(IEEE80211_VHT_MAX_AMPDU_1024K,\n\t\t\t\t\t       IEEE80211_HE_6GHZ_CAP_MAX_AMPDU_LEN_EXP) |\n\t\t\t       u16_encode_bits(IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454,\n\t\t\t\t\t       IEEE80211_HE_6GHZ_CAP_MAX_MPDU_LEN);\n\n\t\t\tdata[idx].he_6ghz_capa.capa = cpu_to_le16(cap);\n\t\t}\n\n\t\tidx++;\n\t}\n\n\treturn idx;\n}\n\nvoid mt7915_set_stream_he_caps(struct mt7915_phy *phy)\n{\n\tstruct ieee80211_sband_iftype_data *data;\n\tstruct ieee80211_supported_band *band;\n\tint n;\n\n\tif (phy->mt76->cap.has_2ghz) {\n\t\tdata = phy->iftype[NL80211_BAND_2GHZ];\n\t\tn = mt7915_init_he_caps(phy, NL80211_BAND_2GHZ, data);\n\n\t\tband = &phy->mt76->sband_2g.sband;\n\t\tband->iftype_data = data;\n\t\tband->n_iftype_data = n;\n\t}\n\n\tif (phy->mt76->cap.has_5ghz) {\n\t\tdata = phy->iftype[NL80211_BAND_5GHZ];\n\t\tn = mt7915_init_he_caps(phy, NL80211_BAND_5GHZ, data);\n\n\t\tband = &phy->mt76->sband_5g.sband;\n\t\tband->iftype_data = data;\n\t\tband->n_iftype_data = n;\n\t}\n\n\tif (phy->mt76->cap.has_6ghz) {\n\t\tdata = phy->iftype[NL80211_BAND_6GHZ];\n\t\tn = mt7915_init_he_caps(phy, NL80211_BAND_6GHZ, data);\n\n\t\tband = &phy->mt76->sband_6g.sband;\n\t\tband->iftype_data = data;\n\t\tband->n_iftype_data = n;\n\t}\n}\n\nstatic void mt7915_unregister_ext_phy(struct mt7915_dev *dev)\n{\n\tstruct mt7915_phy *phy = mt7915_ext_phy(dev);\n\tstruct mt76_phy *mphy = dev->mt76.phys[MT_BAND1];\n\n\tif (!phy)\n\t\treturn;\n\n\tmt7915_unregister_thermal(phy);\n\tmt76_unregister_phy(mphy);\n\tieee80211_free_hw(mphy->hw);\n}\n\nstatic void mt7915_stop_hardware(struct mt7915_dev *dev)\n{\n\tmt7915_mcu_exit(dev);\n\tmt76_connac2_tx_token_put(&dev->mt76);\n\tmt7915_dma_cleanup(dev);\n\ttasklet_disable(&dev->mt76.irq_tasklet);\n\n\tif (is_mt798x(&dev->mt76))\n\t\tmt7986_wmac_disable(dev);\n}\n\nint mt7915_register_device(struct mt7915_dev *dev)\n{\n\tstruct mt7915_phy *phy2;\n\tint ret;\n\n\tdev->phy.dev = dev;\n\tdev->phy.mt76 = &dev->mt76.phy;\n\tdev->mt76.phy.priv = &dev->phy;\n\tINIT_WORK(&dev->rc_work, mt7915_mac_sta_rc_work);\n\tINIT_DELAYED_WORK(&dev->mphy.mac_work, mt7915_mac_work);\n\tINIT_LIST_HEAD(&dev->sta_rc_list);\n\tINIT_LIST_HEAD(&dev->twt_list);\n\n\tinit_waitqueue_head(&dev->reset_wait);\n\tINIT_WORK(&dev->reset_work, mt7915_mac_reset_work);\n\tINIT_WORK(&dev->dump_work, mt7915_mac_dump_work);\n\tmutex_init(&dev->dump_mutex);\n\n\tdev->dbdc_support = mt7915_band_config(dev);\n\n\tphy2 = mt7915_alloc_ext_phy(dev);\n\tif (IS_ERR(phy2))\n\t\treturn PTR_ERR(phy2);\n\n\tret = mt7915_init_hardware(dev, phy2);\n\tif (ret)\n\t\tgoto free_phy2;\n\n\tmt7915_init_wiphy(&dev->phy);\n\n#ifdef CONFIG_NL80211_TESTMODE\n\tdev->mt76.test_ops = &mt7915_testmode_ops;\n#endif\n\n\tret = mt76_register_device(&dev->mt76, true, mt76_rates,\n\t\t\t\t   ARRAY_SIZE(mt76_rates));\n\tif (ret)\n\t\tgoto stop_hw;\n\n\tret = mt7915_thermal_init(&dev->phy);\n\tif (ret)\n\t\tgoto unreg_dev;\n\n\tieee80211_queue_work(mt76_hw(dev), &dev->init_work);\n\n\tif (phy2) {\n\t\tret = mt7915_register_ext_phy(dev, phy2);\n\t\tif (ret)\n\t\t\tgoto unreg_thermal;\n\t}\n\n\tdev->recovery.hw_init_done = true;\n\n\tret = mt7915_init_debugfs(&dev->phy);\n\tif (ret)\n\t\tgoto unreg_thermal;\n\n\tret = mt7915_coredump_register(dev);\n\tif (ret)\n\t\tgoto unreg_thermal;\n\n\treturn 0;\n\nunreg_thermal:\n\tmt7915_unregister_thermal(&dev->phy);\nunreg_dev:\n\tmt76_unregister_device(&dev->mt76);\nstop_hw:\n\tmt7915_stop_hardware(dev);\nfree_phy2:\n\tif (phy2)\n\t\tieee80211_free_hw(phy2->mt76->hw);\n\treturn ret;\n}\n\nvoid mt7915_unregister_device(struct mt7915_dev *dev)\n{\n\tmt7915_unregister_ext_phy(dev);\n\tmt7915_coredump_unregister(dev);\n\tmt7915_unregister_thermal(&dev->phy);\n\tmt76_unregister_device(&dev->mt76);\n\tmt7915_stop_hardware(dev);\n\n\tmt76_free_device(&dev->mt76);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}