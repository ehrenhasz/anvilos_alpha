{
  "module_name": "main.c",
  "hash_id": "317261e15e5ec791ae93dfa232f462a7b4ef32208325e5c42d8bc064da25060d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7915/main.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/platform_device.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include \"mt7915.h\"\n#include \"mcu.h\"\n\nstatic bool mt7915_dev_running(struct mt7915_dev *dev)\n{\n\tstruct mt7915_phy *phy;\n\n\tif (test_bit(MT76_STATE_RUNNING, &dev->mphy.state))\n\t\treturn true;\n\n\tphy = mt7915_ext_phy(dev);\n\n\treturn phy && test_bit(MT76_STATE_RUNNING, &phy->mt76->state);\n}\n\nint mt7915_run(struct ieee80211_hw *hw)\n{\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tstruct mt7915_phy *phy = mt7915_hw_phy(hw);\n\tbool running;\n\tint ret;\n\n\trunning = mt7915_dev_running(dev);\n\n\tif (!running) {\n\t\tret = mt76_connac_mcu_set_pm(&dev->mt76,\n\t\t\t\t\t     dev->phy.mt76->band_idx, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = mt7915_mcu_set_mac(dev, dev->phy.mt76->band_idx,\n\t\t\t\t\t true, true);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tmt7915_mac_enable_nf(dev, dev->phy.mt76->band_idx);\n\t}\n\n\tif (phy != &dev->phy) {\n\t\tret = mt76_connac_mcu_set_pm(&dev->mt76,\n\t\t\t\t\t     phy->mt76->band_idx, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = mt7915_mcu_set_mac(dev, phy->mt76->band_idx,\n\t\t\t\t\t true, true);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tmt7915_mac_enable_nf(dev, phy->mt76->band_idx);\n\t}\n\n\tret = mt7915_mcu_set_thermal_throttling(phy,\n\t\t\t\t\t\tMT7915_THERMAL_THROTTLE_MAX);\n\n\tif (ret)\n\t\tgoto out;\n\n\tret = mt7915_mcu_set_thermal_protect(phy);\n\n\tif (ret)\n\t\tgoto out;\n\n\tret = mt76_connac_mcu_set_rts_thresh(&dev->mt76, 0x92b,\n\t\t\t\t\t     phy->mt76->band_idx);\n\tif (ret)\n\t\tgoto out;\n\n\tret = mt7915_mcu_set_sku_en(phy, true);\n\tif (ret)\n\t\tgoto out;\n\n\tret = mt7915_mcu_set_chan_info(phy, MCU_EXT_CMD(SET_RX_PATH));\n\tif (ret)\n\t\tgoto out;\n\n\tset_bit(MT76_STATE_RUNNING, &phy->mt76->state);\n\n\tif (!mt76_testmode_enabled(phy->mt76))\n\t\tieee80211_queue_delayed_work(hw, &phy->mt76->mac_work,\n\t\t\t\t\t     MT7915_WATCHDOG_TIME);\n\n\tif (!running)\n\t\tmt7915_mac_reset_counters(phy);\n\nout:\n\treturn ret;\n}\n\nstatic int mt7915_start(struct ieee80211_hw *hw)\n{\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tint ret;\n\n\tflush_work(&dev->init_work);\n\n\tmutex_lock(&dev->mt76.mutex);\n\tret = mt7915_run(hw);\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn ret;\n}\n\nstatic void mt7915_stop(struct ieee80211_hw *hw)\n{\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tstruct mt7915_phy *phy = mt7915_hw_phy(hw);\n\n\tcancel_delayed_work_sync(&phy->mt76->mac_work);\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tmt76_testmode_reset(phy->mt76, true);\n\n\tclear_bit(MT76_STATE_RUNNING, &phy->mt76->state);\n\n\tif (phy != &dev->phy) {\n\t\tmt76_connac_mcu_set_pm(&dev->mt76, phy->mt76->band_idx, 1);\n\t\tmt7915_mcu_set_mac(dev, phy->mt76->band_idx, false, false);\n\t}\n\n\tif (!mt7915_dev_running(dev)) {\n\t\tmt76_connac_mcu_set_pm(&dev->mt76, dev->phy.mt76->band_idx, 1);\n\t\tmt7915_mcu_set_mac(dev, dev->phy.mt76->band_idx, false, false);\n\t}\n\n\tmutex_unlock(&dev->mt76.mutex);\n}\n\nstatic inline int get_free_idx(u32 mask, u8 start, u8 end)\n{\n\treturn ffs(~mask & GENMASK(end, start));\n}\n\nstatic int get_omac_idx(enum nl80211_iftype type, u64 mask)\n{\n\tint i;\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_STATION:\n\t\t \n\t\ti = get_free_idx(mask, HW_BSSID_1, HW_BSSID_3);\n\t\tif (i)\n\t\t\treturn i - 1;\n\n\t\tif (type != NL80211_IFTYPE_STATION)\n\t\t\tbreak;\n\n\t\ti = get_free_idx(mask, EXT_BSSID_1, EXT_BSSID_MAX);\n\t\tif (i)\n\t\t\treturn i - 1;\n\n\t\tif (~mask & BIT(HW_BSSID_0))\n\t\t\treturn HW_BSSID_0;\n\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_AP:\n\t\t \n\t\tif (~mask & BIT(HW_BSSID_0))\n\t\t\treturn HW_BSSID_0;\n\n\t\ti = get_free_idx(mask, EXT_BSSID_1, EXT_BSSID_MAX);\n\t\tif (i)\n\t\t\treturn i - 1;\n\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\treturn -1;\n}\n\nstatic void mt7915_init_bitrate_mask(struct ieee80211_vif *vif)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mvif->bitrate_mask.control); i++) {\n\t\tmvif->bitrate_mask.control[i].gi = NL80211_TXRATE_DEFAULT_GI;\n\t\tmvif->bitrate_mask.control[i].he_gi = 0xff;\n\t\tmvif->bitrate_mask.control[i].he_ltf = 0xff;\n\t\tmvif->bitrate_mask.control[i].legacy = GENMASK(31, 0);\n\t\tmemset(mvif->bitrate_mask.control[i].ht_mcs, 0xff,\n\t\t       sizeof(mvif->bitrate_mask.control[i].ht_mcs));\n\t\tmemset(mvif->bitrate_mask.control[i].vht_mcs, 0xff,\n\t\t       sizeof(mvif->bitrate_mask.control[i].vht_mcs));\n\t\tmemset(mvif->bitrate_mask.control[i].he_mcs, 0xff,\n\t\t       sizeof(mvif->bitrate_mask.control[i].he_mcs));\n\t}\n}\n\nstatic int mt7915_add_interface(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tstruct mt7915_phy *phy = mt7915_hw_phy(hw);\n\tstruct mt76_txq *mtxq;\n\tbool ext_phy = phy != &dev->phy;\n\tint idx, ret = 0;\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tmt76_testmode_reset(phy->mt76, true);\n\n\tif (vif->type == NL80211_IFTYPE_MONITOR &&\n\t    is_zero_ether_addr(vif->addr))\n\t\tphy->monitor_vif = vif;\n\n\tmvif->mt76.idx = __ffs64(~dev->mt76.vif_mask);\n\tif (mvif->mt76.idx >= (MT7915_MAX_INTERFACES << dev->dbdc_support)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tidx = get_omac_idx(vif->type, phy->omac_mask);\n\tif (idx < 0) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\tmvif->mt76.omac_idx = idx;\n\tmvif->phy = phy;\n\tmvif->mt76.band_idx = phy->mt76->band_idx;\n\n\tmvif->mt76.wmm_idx = vif->type != NL80211_IFTYPE_AP;\n\tif (ext_phy)\n\t\tmvif->mt76.wmm_idx += 2;\n\n\tret = mt7915_mcu_add_dev_info(phy, vif, true);\n\tif (ret)\n\t\tgoto out;\n\n\tdev->mt76.vif_mask |= BIT_ULL(mvif->mt76.idx);\n\tphy->omac_mask |= BIT_ULL(mvif->mt76.omac_idx);\n\n\tidx = MT7915_WTBL_RESERVED - mvif->mt76.idx;\n\n\tINIT_LIST_HEAD(&mvif->sta.rc_list);\n\tINIT_LIST_HEAD(&mvif->sta.wcid.poll_list);\n\tmvif->sta.wcid.idx = idx;\n\tmvif->sta.wcid.phy_idx = ext_phy;\n\tmvif->sta.wcid.hw_key_idx = -1;\n\tmvif->sta.wcid.tx_info |= MT_WCID_TX_INFO_SET;\n\tmt76_packet_id_init(&mvif->sta.wcid);\n\n\tmt7915_mac_wtbl_update(dev, idx,\n\t\t\t       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);\n\n\tif (vif->txq) {\n\t\tmtxq = (struct mt76_txq *)vif->txq->drv_priv;\n\t\tmtxq->wcid = idx;\n\t}\n\n\tif (vif->type != NL80211_IFTYPE_AP &&\n\t    (!mvif->mt76.omac_idx || mvif->mt76.omac_idx > 3))\n\t\tvif->offload_flags = 0;\n\tvif->offload_flags |= IEEE80211_OFFLOAD_ENCAP_4ADDR;\n\n\tmt7915_init_bitrate_mask(vif);\n\tmemset(&mvif->cap, -1, sizeof(mvif->cap));\n\n\tmt7915_mcu_add_bss_info(phy, vif, true);\n\tmt7915_mcu_add_sta(dev, vif, NULL, true);\n\trcu_assign_pointer(dev->mt76.wcid[idx], &mvif->sta.wcid);\n\nout:\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn ret;\n}\n\nstatic void mt7915_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct mt7915_sta *msta = &mvif->sta;\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tstruct mt7915_phy *phy = mt7915_hw_phy(hw);\n\tint idx = msta->wcid.idx;\n\n\tmt7915_mcu_add_bss_info(phy, vif, false);\n\tmt7915_mcu_add_sta(dev, vif, NULL, false);\n\n\tmutex_lock(&dev->mt76.mutex);\n\tmt76_testmode_reset(phy->mt76, true);\n\tmutex_unlock(&dev->mt76.mutex);\n\n\tif (vif == phy->monitor_vif)\n\t\tphy->monitor_vif = NULL;\n\n\tmt7915_mcu_add_dev_info(phy, vif, false);\n\n\trcu_assign_pointer(dev->mt76.wcid[idx], NULL);\n\n\tmutex_lock(&dev->mt76.mutex);\n\tdev->mt76.vif_mask &= ~BIT_ULL(mvif->mt76.idx);\n\tphy->omac_mask &= ~BIT_ULL(mvif->mt76.omac_idx);\n\tmutex_unlock(&dev->mt76.mutex);\n\n\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\tif (!list_empty(&msta->wcid.poll_list))\n\t\tlist_del_init(&msta->wcid.poll_list);\n\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\n\tmt76_packet_id_flush(&dev->mt76, &msta->wcid);\n}\n\nint mt7915_set_channel(struct mt7915_phy *phy)\n{\n\tstruct mt7915_dev *dev = phy->dev;\n\tint ret;\n\n\tcancel_delayed_work_sync(&phy->mt76->mac_work);\n\n\tmutex_lock(&dev->mt76.mutex);\n\tset_bit(MT76_RESET, &phy->mt76->state);\n\n\tmt76_set_channel(phy->mt76);\n\n\tif (dev->flash_mode) {\n\t\tret = mt7915_mcu_apply_tx_dpd(phy);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = mt7915_mcu_set_chan_info(phy, MCU_EXT_CMD(CHANNEL_SWITCH));\n\tif (ret)\n\t\tgoto out;\n\n\tmt7915_mac_set_timing(phy);\n\tret = mt7915_dfs_init_radar_detector(phy);\n\tmt7915_mac_cca_stats_reset(phy);\n\n\tmt7915_mac_reset_counters(phy);\n\tphy->noise = 0;\n\nout:\n\tclear_bit(MT76_RESET, &phy->mt76->state);\n\tmutex_unlock(&dev->mt76.mutex);\n\n\tmt76_txq_schedule_all(phy->mt76);\n\n\tif (!mt76_testmode_enabled(phy->mt76))\n\t\tieee80211_queue_delayed_work(phy->mt76->hw,\n\t\t\t\t\t     &phy->mt76->mac_work,\n\t\t\t\t\t     MT7915_WATCHDOG_TIME);\n\n\treturn ret;\n}\n\nstatic int mt7915_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t\t  struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t\t  struct ieee80211_key_conf *key)\n{\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tstruct mt7915_phy *phy = mt7915_hw_phy(hw);\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct mt7915_sta *msta = sta ? (struct mt7915_sta *)sta->drv_priv :\n\t\t\t\t  &mvif->sta;\n\tstruct mt76_wcid *wcid = &msta->wcid;\n\tu8 *wcid_keyidx = &wcid->hw_key_idx;\n\tint idx = key->keyidx;\n\tint err = 0;\n\n\t \n\tif ((vif->type == NL80211_IFTYPE_ADHOC ||\n\t     vif->type == NL80211_IFTYPE_MESH_POINT) &&\n\t    (key->cipher == WLAN_CIPHER_SUITE_TKIP ||\n\t     key->cipher == WLAN_CIPHER_SUITE_CCMP) &&\n\t    !(key->flags & IEEE80211_KEY_FLAG_PAIRWISE))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\twcid_keyidx = &wcid->hw_key_idx2;\n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIE;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\tcase WLAN_CIPHER_SUITE_SMS4:\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tif (cmd == SET_KEY && !sta && !mvif->mt76.cipher) {\n\t\tmvif->mt76.cipher = mt76_connac_mcu_get_cipher(key->cipher);\n\t\tmt7915_mcu_add_bss_info(phy, vif, true);\n\t}\n\n\tif (cmd == SET_KEY) {\n\t\t*wcid_keyidx = idx;\n\t} else {\n\t\tif (idx == *wcid_keyidx)\n\t\t\t*wcid_keyidx = -1;\n\t\tgoto out;\n\t}\n\n\tmt76_wcid_key_setup(&dev->mt76, wcid, key);\n\terr = mt76_connac_mcu_add_key(&dev->mt76, vif, &msta->bip,\n\t\t\t\t      key, MCU_EXT_CMD(STA_REC_UPDATE),\n\t\t\t\t      &msta->wcid, cmd);\nout:\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn err;\n}\n\nstatic int mt7915_set_sar_specs(struct ieee80211_hw *hw,\n\t\t\t\tconst struct cfg80211_sar_specs *sar)\n{\n\tstruct mt7915_phy *phy = mt7915_hw_phy(hw);\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tint err = -EINVAL;\n\n\tmutex_lock(&dev->mt76.mutex);\n\tif (!cfg80211_chandef_valid(&phy->mt76->chandef))\n\t\tgoto out;\n\n\terr = mt76_init_sar_power(hw, sar);\n\tif (err)\n\t\tgoto out;\n\n\terr = mt7915_mcu_set_txpower_sku(phy);\nout:\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn err;\n}\n\nstatic int mt7915_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tstruct mt7915_phy *phy = mt7915_hw_phy(hw);\n\tint ret;\n\n\tif (changed & IEEE80211_CONF_CHANGE_CHANNEL) {\n#ifdef CONFIG_NL80211_TESTMODE\n\t\tif (phy->mt76->test.state != MT76_TM_STATE_OFF) {\n\t\t\tmutex_lock(&dev->mt76.mutex);\n\t\t\tmt76_testmode_reset(phy->mt76, false);\n\t\t\tmutex_unlock(&dev->mt76.mutex);\n\t\t}\n#endif\n\t\tieee80211_stop_queues(hw);\n\t\tret = mt7915_set_channel(phy);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tieee80211_wake_queues(hw);\n\t}\n\n\tif (changed & (IEEE80211_CONF_CHANGE_POWER |\n\t\t       IEEE80211_CONF_CHANGE_CHANNEL)) {\n\t\tret = mt7915_mcu_set_txpower_sku(phy);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tif (changed & IEEE80211_CONF_CHANGE_MONITOR) {\n\t\tbool enabled = !!(hw->conf.flags & IEEE80211_CONF_MONITOR);\n\t\tbool band = phy->mt76->band_idx;\n\n\t\tif (!enabled)\n\t\t\tphy->rxfilter |= MT_WF_RFCR_DROP_OTHER_UC;\n\t\telse\n\t\t\tphy->rxfilter &= ~MT_WF_RFCR_DROP_OTHER_UC;\n\n\t\tmt76_rmw_field(dev, MT_DMA_DCR0(band), MT_DMA_DCR0_RXD_G5_EN,\n\t\t\t       enabled);\n\t\tmt76_testmode_reset(phy->mt76, true);\n\t\tmt76_wr(dev, MT_WF_RFCR(band), phy->rxfilter);\n\t}\n\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn 0;\n}\n\nstatic int\nmt7915_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t       unsigned int link_id, u16 queue,\n\t       const struct ieee80211_tx_queue_params *params)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\n\t \n\tqueue = mt76_connac_lmac_mapping(queue);\n\tmvif->queue_params[queue] = *params;\n\n\treturn 0;\n}\n\nstatic void mt7915_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t    unsigned int changed_flags,\n\t\t\t\t    unsigned int *total_flags,\n\t\t\t\t    u64 multicast)\n{\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tstruct mt7915_phy *phy = mt7915_hw_phy(hw);\n\tbool band = phy->mt76->band_idx;\n\tu32 ctl_flags = MT_WF_RFCR1_DROP_ACK |\n\t\t\tMT_WF_RFCR1_DROP_BF_POLL |\n\t\t\tMT_WF_RFCR1_DROP_BA |\n\t\t\tMT_WF_RFCR1_DROP_CFEND |\n\t\t\tMT_WF_RFCR1_DROP_CFACK;\n\tu32 flags = 0;\n\n#define MT76_FILTER(_flag, _hw) do {\t\t\t\t\t\\\n\t\tflags |= *total_flags & FIF_##_flag;\t\t\t\\\n\t\tphy->rxfilter &= ~(_hw);\t\t\t\t\\\n\t\tphy->rxfilter |= !(flags & FIF_##_flag) * (_hw);\t\\\n\t} while (0)\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tphy->rxfilter &= ~(MT_WF_RFCR_DROP_OTHER_BSS |\n\t\t\t   MT_WF_RFCR_DROP_OTHER_BEACON |\n\t\t\t   MT_WF_RFCR_DROP_FRAME_REPORT |\n\t\t\t   MT_WF_RFCR_DROP_PROBEREQ |\n\t\t\t   MT_WF_RFCR_DROP_MCAST_FILTERED |\n\t\t\t   MT_WF_RFCR_DROP_MCAST |\n\t\t\t   MT_WF_RFCR_DROP_BCAST |\n\t\t\t   MT_WF_RFCR_DROP_DUPLICATE |\n\t\t\t   MT_WF_RFCR_DROP_A2_BSSID |\n\t\t\t   MT_WF_RFCR_DROP_UNWANTED_CTL |\n\t\t\t   MT_WF_RFCR_DROP_STBC_MULTI);\n\n\tMT76_FILTER(OTHER_BSS, MT_WF_RFCR_DROP_OTHER_TIM |\n\t\t\t       MT_WF_RFCR_DROP_A3_MAC |\n\t\t\t       MT_WF_RFCR_DROP_A3_BSSID);\n\n\tMT76_FILTER(FCSFAIL, MT_WF_RFCR_DROP_FCSFAIL);\n\n\tMT76_FILTER(CONTROL, MT_WF_RFCR_DROP_CTS |\n\t\t\t     MT_WF_RFCR_DROP_RTS |\n\t\t\t     MT_WF_RFCR_DROP_CTL_RSV |\n\t\t\t     MT_WF_RFCR_DROP_NDPA);\n\n\t*total_flags = flags;\n\tmt76_wr(dev, MT_WF_RFCR(band), phy->rxfilter);\n\n\tif (*total_flags & FIF_CONTROL)\n\t\tmt76_clear(dev, MT_WF_RFCR1(band), ctl_flags);\n\telse\n\t\tmt76_set(dev, MT_WF_RFCR1(band), ctl_flags);\n\n\tmutex_unlock(&dev->mt76.mutex);\n}\n\nstatic void\nmt7915_update_bss_color(struct ieee80211_hw *hw,\n\t\t\tstruct ieee80211_vif *vif,\n\t\t\tstruct cfg80211_he_bss_color *bss_color)\n{\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_AP: {\n\t\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\n\t\tif (mvif->mt76.omac_idx > HW_BSSID_MAX)\n\t\t\treturn;\n\t\tfallthrough;\n\t}\n\tcase NL80211_IFTYPE_STATION:\n\t\tmt7915_mcu_update_bss_color(dev, vif, bss_color);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void mt7915_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_bss_conf *info,\n\t\t\t\t    u64 changed)\n{\n\tstruct mt7915_phy *phy = mt7915_hw_phy(hw);\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tint set_bss_info = -1, set_sta = -1;\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\t \n\tif (changed & BSS_CHANGED_BSSID &&\n\t    vif->type == NL80211_IFTYPE_STATION)\n\t\tset_bss_info = set_sta = !is_zero_ether_addr(info->bssid);\n\tif (changed & BSS_CHANGED_ASSOC)\n\t\tset_bss_info = vif->cfg.assoc;\n\tif (changed & BSS_CHANGED_BEACON_ENABLED &&\n\t    vif->type != NL80211_IFTYPE_AP)\n\t\tset_bss_info = set_sta = info->enable_beacon;\n\n\tif (set_bss_info == 1)\n\t\tmt7915_mcu_add_bss_info(phy, vif, true);\n\tif (set_sta == 1)\n\t\tmt7915_mcu_add_sta(dev, vif, NULL, true);\n\n\tif (changed & BSS_CHANGED_ERP_CTS_PROT)\n\t\tmt7915_mac_enable_rtscts(dev, vif, info->use_cts_prot);\n\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\tint slottime = info->use_short_slot ? 9 : 20;\n\n\t\tif (slottime != phy->slottime) {\n\t\t\tphy->slottime = slottime;\n\t\t\tmt7915_mac_set_timing(phy);\n\t\t}\n\t}\n\n\t \n\tif (changed & (BSS_CHANGED_QOS | BSS_CHANGED_BEACON_ENABLED))\n\t\tmt7915_mcu_set_tx(dev, vif);\n\n\tif (changed & BSS_CHANGED_HE_OBSS_PD)\n\t\tmt7915_mcu_add_obss_spr(phy, vif, &info->he_obss_pd);\n\n\tif (changed & BSS_CHANGED_HE_BSS_COLOR)\n\t\tmt7915_update_bss_color(hw, vif, &info->he_bss_color);\n\n\tif (changed & (BSS_CHANGED_BEACON |\n\t\t       BSS_CHANGED_BEACON_ENABLED))\n\t\tmt7915_mcu_add_beacon(hw, vif, info->enable_beacon, changed);\n\n\tif (changed & (BSS_CHANGED_UNSOL_BCAST_PROBE_RESP |\n\t\t       BSS_CHANGED_FILS_DISCOVERY))\n\t\tmt7915_mcu_add_inband_discov(dev, vif, changed);\n\n\tif (set_bss_info == 0)\n\t\tmt7915_mcu_add_bss_info(phy, vif, false);\n\tif (set_sta == 0)\n\t\tmt7915_mcu_add_sta(dev, vif, NULL, false);\n\n\tmutex_unlock(&dev->mt76.mutex);\n}\n\nstatic void\nmt7915_vif_check_caps(struct mt7915_phy *phy, struct ieee80211_vif *vif)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct mt7915_vif_cap *vc = &mvif->cap;\n\n\tvc->ht_ldpc = vif->bss_conf.ht_ldpc;\n\tvc->vht_ldpc = vif->bss_conf.vht_ldpc;\n\tvc->vht_su_ebfer = vif->bss_conf.vht_su_beamformer;\n\tvc->vht_su_ebfee = vif->bss_conf.vht_su_beamformee;\n\tvc->vht_mu_ebfer = vif->bss_conf.vht_mu_beamformer;\n\tvc->vht_mu_ebfee = vif->bss_conf.vht_mu_beamformee;\n\tvc->he_ldpc = vif->bss_conf.he_ldpc;\n\tvc->he_su_ebfer = vif->bss_conf.he_su_beamformer;\n\tvc->he_su_ebfee = vif->bss_conf.he_su_beamformee;\n\tvc->he_mu_ebfer = vif->bss_conf.he_mu_beamformer;\n}\n\nstatic int\nmt7915_start_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\tstruct ieee80211_bss_conf *link_conf)\n{\n\tstruct mt7915_phy *phy = mt7915_hw_phy(hw);\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tint err;\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tmt7915_vif_check_caps(phy, vif);\n\n\terr = mt7915_mcu_add_bss_info(phy, vif, true);\n\tif (err)\n\t\tgoto out;\n\terr = mt7915_mcu_add_sta(dev, vif, NULL, true);\nout:\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn err;\n}\n\nstatic void\nmt7915_stop_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t       struct ieee80211_bss_conf *link_conf)\n{\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\n\tmutex_lock(&dev->mt76.mutex);\n\tmt7915_mcu_add_sta(dev, vif, NULL, false);\n\tmutex_unlock(&dev->mt76.mutex);\n}\n\nstatic void\nmt7915_channel_switch_beacon(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct cfg80211_chan_def *chandef)\n{\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\n\tmutex_lock(&dev->mt76.mutex);\n\tmt7915_mcu_add_beacon(hw, vif, true, BSS_CHANGED_BEACON);\n\tmutex_unlock(&dev->mt76.mutex);\n}\n\nint mt7915_mac_sta_add(struct mt76_dev *mdev, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_sta *sta)\n{\n\tstruct mt7915_dev *dev = container_of(mdev, struct mt7915_dev, mt76);\n\tstruct mt7915_sta *msta = (struct mt7915_sta *)sta->drv_priv;\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tbool ext_phy = mvif->phy != &dev->phy;\n\tint ret, idx;\n\n\tidx = mt76_wcid_alloc(dev->mt76.wcid_mask, MT7915_WTBL_STA);\n\tif (idx < 0)\n\t\treturn -ENOSPC;\n\n\tINIT_LIST_HEAD(&msta->rc_list);\n\tINIT_LIST_HEAD(&msta->wcid.poll_list);\n\tmsta->vif = mvif;\n\tmsta->wcid.sta = 1;\n\tmsta->wcid.idx = idx;\n\tmsta->wcid.phy_idx = ext_phy;\n\tmsta->wcid.tx_info |= MT_WCID_TX_INFO_SET;\n\tmsta->jiffies = jiffies;\n\n\tewma_avg_signal_init(&msta->avg_ack_signal);\n\n\tmt7915_mac_wtbl_update(dev, idx,\n\t\t\t       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);\n\n\tret = mt7915_mcu_add_sta(dev, vif, sta, true);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mt7915_mcu_add_rate_ctrl(dev, vif, sta, false);\n}\n\nvoid mt7915_mac_sta_remove(struct mt76_dev *mdev, struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_sta *sta)\n{\n\tstruct mt7915_dev *dev = container_of(mdev, struct mt7915_dev, mt76);\n\tstruct mt7915_sta *msta = (struct mt7915_sta *)sta->drv_priv;\n\tint i;\n\n\tmt7915_mcu_add_sta(dev, vif, sta, false);\n\n\tmt7915_mac_wtbl_update(dev, msta->wcid.idx,\n\t\t\t       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);\n\n\tfor (i = 0; i < ARRAY_SIZE(msta->twt.flow); i++)\n\t\tmt7915_mac_twt_teardown_flow(dev, msta, i);\n\n\tspin_lock_bh(&mdev->sta_poll_lock);\n\tif (!list_empty(&msta->wcid.poll_list))\n\t\tlist_del_init(&msta->wcid.poll_list);\n\tif (!list_empty(&msta->rc_list))\n\t\tlist_del_init(&msta->rc_list);\n\tspin_unlock_bh(&mdev->sta_poll_lock);\n}\n\nstatic void mt7915_tx(struct ieee80211_hw *hw,\n\t\t      struct ieee80211_tx_control *control,\n\t\t      struct sk_buff *skb)\n{\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tstruct mt76_phy *mphy = hw->priv;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_vif *vif = info->control.vif;\n\tstruct mt76_wcid *wcid = &dev->mt76.global_wcid;\n\n\tif (control->sta) {\n\t\tstruct mt7915_sta *sta;\n\n\t\tsta = (struct mt7915_sta *)control->sta->drv_priv;\n\t\twcid = &sta->wcid;\n\t}\n\n\tif (vif && !control->sta) {\n\t\tstruct mt7915_vif *mvif;\n\n\t\tmvif = (struct mt7915_vif *)vif->drv_priv;\n\t\twcid = &mvif->sta.wcid;\n\t}\n\n\tmt76_tx(mphy, control->sta, wcid, skb);\n}\n\nstatic int mt7915_set_rts_threshold(struct ieee80211_hw *hw, u32 val)\n{\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tstruct mt7915_phy *phy = mt7915_hw_phy(hw);\n\tint ret;\n\n\tmutex_lock(&dev->mt76.mutex);\n\tret = mt76_connac_mcu_set_rts_thresh(&dev->mt76, val,\n\t\t\t\t\t     phy->mt76->band_idx);\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn ret;\n}\n\nstatic int\nmt7915_ampdu_action(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t    struct ieee80211_ampdu_params *params)\n{\n\tenum ieee80211_ampdu_mlme_action action = params->action;\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tstruct ieee80211_sta *sta = params->sta;\n\tstruct ieee80211_txq *txq = sta->txq[params->tid];\n\tstruct mt7915_sta *msta = (struct mt7915_sta *)sta->drv_priv;\n\tu16 tid = params->tid;\n\tu16 ssn = params->ssn;\n\tstruct mt76_txq *mtxq;\n\tint ret = 0;\n\n\tif (!txq)\n\t\treturn -EINVAL;\n\n\tmtxq = (struct mt76_txq *)txq->drv_priv;\n\n\tmutex_lock(&dev->mt76.mutex);\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_RX_START:\n\t\tmt76_rx_aggr_start(&dev->mt76, &msta->wcid, tid, ssn,\n\t\t\t\t   params->buf_size);\n\t\tret = mt7915_mcu_add_rx_ba(dev, params, true);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\tmt76_rx_aggr_stop(&dev->mt76, &msta->wcid, tid);\n\t\tret = mt7915_mcu_add_rx_ba(dev, params, false);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\tmtxq->aggr = true;\n\t\tmtxq->send_bar = false;\n\t\tret = mt7915_mcu_add_tx_ba(dev, params, true);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\t\tmtxq->aggr = false;\n\t\tclear_bit(tid, &msta->wcid.ampdu_state);\n\t\tret = mt7915_mcu_add_tx_ba(dev, params, false);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_START:\n\t\tset_bit(tid, &msta->wcid.ampdu_state);\n\t\tret = IEEE80211_AMPDU_TX_START_IMMEDIATE;\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\t\tmtxq->aggr = false;\n\t\tclear_bit(tid, &msta->wcid.ampdu_state);\n\t\tret = mt7915_mcu_add_tx_ba(dev, params, false);\n\t\tieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\t\tbreak;\n\t}\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn ret;\n}\n\nstatic int\nmt7915_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t       struct ieee80211_sta *sta)\n{\n\treturn mt76_sta_state(hw, vif, sta, IEEE80211_STA_NOTEXIST,\n\t\t\t      IEEE80211_STA_NONE);\n}\n\nstatic int\nmt7915_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t  struct ieee80211_sta *sta)\n{\n\treturn mt76_sta_state(hw, vif, sta, IEEE80211_STA_NONE,\n\t\t\t      IEEE80211_STA_NOTEXIST);\n}\n\nstatic int\nmt7915_get_stats(struct ieee80211_hw *hw,\n\t\t struct ieee80211_low_level_stats *stats)\n{\n\tstruct mt7915_phy *phy = mt7915_hw_phy(hw);\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tstruct mt76_mib_stats *mib = &phy->mib;\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tstats->dot11RTSSuccessCount = mib->rts_cnt;\n\tstats->dot11RTSFailureCount = mib->rts_retries_cnt;\n\tstats->dot11FCSErrorCount = mib->fcs_err_cnt;\n\tstats->dot11ACKFailureCount = mib->ack_fail_cnt;\n\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn 0;\n}\n\nu64 __mt7915_get_tsf(struct ieee80211_hw *hw, struct mt7915_vif *mvif)\n{\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tstruct mt7915_phy *phy = mt7915_hw_phy(hw);\n\tbool band = phy->mt76->band_idx;\n\tunion {\n\t\tu64 t64;\n\t\tu32 t32[2];\n\t} tsf;\n\tu16 n;\n\n\tlockdep_assert_held(&dev->mt76.mutex);\n\n\tn = mvif->mt76.omac_idx > HW_BSSID_MAX ? HW_BSSID_0\n\t\t\t\t\t       : mvif->mt76.omac_idx;\n\t \n\tif (is_mt7915(&dev->mt76))\n\t\tmt76_rmw(dev, MT_LPON_TCR(band, n), MT_LPON_TCR_SW_MODE,\n\t\t\t MT_LPON_TCR_SW_READ);\n\telse\n\t\tmt76_rmw(dev, MT_LPON_TCR_MT7916(band, n), MT_LPON_TCR_SW_MODE,\n\t\t\t MT_LPON_TCR_SW_READ);\n\ttsf.t32[0] = mt76_rr(dev, MT_LPON_UTTR0(band));\n\ttsf.t32[1] = mt76_rr(dev, MT_LPON_UTTR1(band));\n\n\treturn tsf.t64;\n}\n\nstatic u64\nmt7915_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tu64 ret;\n\n\tmutex_lock(&dev->mt76.mutex);\n\tret = __mt7915_get_tsf(hw, mvif);\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn ret;\n}\n\nstatic void\nmt7915_set_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t       u64 timestamp)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tstruct mt7915_phy *phy = mt7915_hw_phy(hw);\n\tbool band = phy->mt76->band_idx;\n\tunion {\n\t\tu64 t64;\n\t\tu32 t32[2];\n\t} tsf = { .t64 = timestamp, };\n\tu16 n;\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tn = mvif->mt76.omac_idx > HW_BSSID_MAX ? HW_BSSID_0\n\t\t\t\t\t       : mvif->mt76.omac_idx;\n\tmt76_wr(dev, MT_LPON_UTTR0(band), tsf.t32[0]);\n\tmt76_wr(dev, MT_LPON_UTTR1(band), tsf.t32[1]);\n\t \n\tif (is_mt7915(&dev->mt76))\n\t\tmt76_rmw(dev, MT_LPON_TCR(band, n), MT_LPON_TCR_SW_MODE,\n\t\t\t MT_LPON_TCR_SW_WRITE);\n\telse\n\t\tmt76_rmw(dev, MT_LPON_TCR_MT7916(band, n), MT_LPON_TCR_SW_MODE,\n\t\t\t MT_LPON_TCR_SW_WRITE);\n\n\tmutex_unlock(&dev->mt76.mutex);\n}\n\nstatic void\nmt7915_offset_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t  s64 timestamp)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tstruct mt7915_phy *phy = mt7915_hw_phy(hw);\n\tbool band = phy->mt76->band_idx;\n\tunion {\n\t\tu64 t64;\n\t\tu32 t32[2];\n\t} tsf = { .t64 = timestamp, };\n\tu16 n;\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tn = mvif->mt76.omac_idx > HW_BSSID_MAX ? HW_BSSID_0\n\t\t\t\t\t       : mvif->mt76.omac_idx;\n\tmt76_wr(dev, MT_LPON_UTTR0(band), tsf.t32[0]);\n\tmt76_wr(dev, MT_LPON_UTTR1(band), tsf.t32[1]);\n\t \n\tif (is_mt7915(&dev->mt76))\n\t\tmt76_rmw(dev, MT_LPON_TCR(band, n), MT_LPON_TCR_SW_MODE,\n\t\t\t MT_LPON_TCR_SW_ADJUST);\n\telse\n\t\tmt76_rmw(dev, MT_LPON_TCR_MT7916(band, n), MT_LPON_TCR_SW_MODE,\n\t\t\t MT_LPON_TCR_SW_ADJUST);\n\n\tmutex_unlock(&dev->mt76.mutex);\n}\n\nstatic void\nmt7915_set_coverage_class(struct ieee80211_hw *hw, s16 coverage_class)\n{\n\tstruct mt7915_phy *phy = mt7915_hw_phy(hw);\n\tstruct mt7915_dev *dev = phy->dev;\n\n\tmutex_lock(&dev->mt76.mutex);\n\tphy->coverage_class = max_t(s16, coverage_class, 0);\n\tmt7915_mac_set_timing(phy);\n\tmutex_unlock(&dev->mt76.mutex);\n}\n\nstatic int\nmt7915_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)\n{\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tstruct mt7915_phy *phy = mt7915_hw_phy(hw);\n\tint max_nss = hweight8(hw->wiphy->available_antennas_tx);\n\tu8 chainshift = dev->chainshift;\n\tu8 band = phy->mt76->band_idx;\n\n\tif (!tx_ant || tx_ant != rx_ant || ffs(tx_ant) > max_nss)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tphy->mt76->antenna_mask = tx_ant;\n\n\t \n\tif ((is_mt7916(&dev->mt76) || is_mt7981(&dev->mt76)) &&\n\t    band && hweight8(tx_ant) == max_nss)\n\t\tphy->mt76->chainmask = (dev->chainmask >> chainshift) << chainshift;\n\telse\n\t\tphy->mt76->chainmask = tx_ant << (chainshift * band);\n\n\tmt76_set_stream_caps(phy->mt76, true);\n\tmt7915_set_stream_vht_txbf_caps(phy);\n\tmt7915_set_stream_he_caps(phy);\n\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn 0;\n}\n\nstatic void mt7915_sta_statistics(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t  struct station_info *sinfo)\n{\n\tstruct mt7915_phy *phy = mt7915_hw_phy(hw);\n\tstruct mt7915_sta *msta = (struct mt7915_sta *)sta->drv_priv;\n\tstruct rate_info *txrate = &msta->wcid.rate;\n\tstruct rate_info rxrate = {};\n\n\tif (is_mt7915(&phy->dev->mt76) &&\n\t    !mt7915_mcu_get_rx_rate(phy, vif, sta, &rxrate)) {\n\t\tsinfo->rxrate = rxrate;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_BITRATE);\n\t}\n\n\tif (txrate->legacy || txrate->flags) {\n\t\tif (txrate->legacy) {\n\t\t\tsinfo->txrate.legacy = txrate->legacy;\n\t\t} else {\n\t\t\tsinfo->txrate.mcs = txrate->mcs;\n\t\t\tsinfo->txrate.nss = txrate->nss;\n\t\t\tsinfo->txrate.bw = txrate->bw;\n\t\t\tsinfo->txrate.he_gi = txrate->he_gi;\n\t\t\tsinfo->txrate.he_dcm = txrate->he_dcm;\n\t\t\tsinfo->txrate.he_ru_alloc = txrate->he_ru_alloc;\n\t\t}\n\t\tsinfo->txrate.flags = txrate->flags;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);\n\t}\n\n\t \n\tif (mtk_wed_device_active(&phy->dev->mt76.mmio.wed)) {\n\t\tsinfo->tx_bytes = msta->wcid.stats.tx_bytes;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BYTES64);\n\n\t\tif (!mt7915_mcu_wed_wa_tx_stats(phy->dev, msta->wcid.idx)) {\n\t\t\tsinfo->tx_packets = msta->wcid.stats.tx_packets;\n\t\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_PACKETS);\n\t\t}\n\n\t\tif (mtk_wed_get_rx_capa(&phy->dev->mt76.mmio.wed)) {\n\t\t\tsinfo->rx_bytes = msta->wcid.stats.rx_bytes;\n\t\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_BYTES64);\n\n\t\t\tsinfo->rx_packets = msta->wcid.stats.rx_packets;\n\t\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_PACKETS);\n\t\t}\n\t}\n\n\tsinfo->tx_failed = msta->wcid.stats.tx_failed;\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_FAILED);\n\n\tsinfo->tx_retries = msta->wcid.stats.tx_retries;\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_RETRIES);\n\n\tsinfo->ack_signal = (s8)msta->ack_signal;\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL);\n\n\tsinfo->avg_ack_signal = -(s8)ewma_avg_signal_read(&msta->avg_ack_signal);\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL_AVG);\n}\n\nstatic void mt7915_sta_rc_work(void *data, struct ieee80211_sta *sta)\n{\n\tstruct mt7915_sta *msta = (struct mt7915_sta *)sta->drv_priv;\n\tstruct mt7915_dev *dev = msta->vif->phy->dev;\n\tu32 *changed = data;\n\n\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\tmsta->changed |= *changed;\n\tif (list_empty(&msta->rc_list))\n\t\tlist_add_tail(&msta->rc_list, &dev->sta_rc_list);\n\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n}\n\nstatic void mt7915_sta_rc_update(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t u32 changed)\n{\n\tstruct mt7915_phy *phy = mt7915_hw_phy(hw);\n\tstruct mt7915_dev *dev = phy->dev;\n\n\tmt7915_sta_rc_work(&changed, sta);\n\tieee80211_queue_work(hw, &dev->rc_work);\n}\n\nstatic int\nmt7915_set_bitrate_mask(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tconst struct cfg80211_bitrate_mask *mask)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct mt7915_phy *phy = mt7915_hw_phy(hw);\n\tstruct mt7915_dev *dev = phy->dev;\n\tu32 changed = IEEE80211_RC_SUPP_RATES_CHANGED;\n\n\tmvif->bitrate_mask = *mask;\n\n\t \n\tieee80211_iterate_stations_atomic(hw, mt7915_sta_rc_work, &changed);\n\tieee80211_queue_work(hw, &dev->rc_work);\n\n\treturn 0;\n}\n\nstatic void mt7915_sta_set_4addr(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t bool enabled)\n{\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tstruct mt7915_sta *msta = (struct mt7915_sta *)sta->drv_priv;\n\n\tif (enabled)\n\t\tset_bit(MT_WCID_FLAG_4ADDR, &msta->wcid.flags);\n\telse\n\t\tclear_bit(MT_WCID_FLAG_4ADDR, &msta->wcid.flags);\n\n\tmt76_connac_mcu_wtbl_update_hdr_trans(&dev->mt76, vif, sta);\n}\n\nstatic void mt7915_sta_set_decap_offload(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t bool enabled)\n{\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tstruct mt7915_sta *msta = (struct mt7915_sta *)sta->drv_priv;\n\n\tif (enabled)\n\t\tset_bit(MT_WCID_FLAG_HDR_TRANS, &msta->wcid.flags);\n\telse\n\t\tclear_bit(MT_WCID_FLAG_HDR_TRANS, &msta->wcid.flags);\n\n\tmt76_connac_mcu_wtbl_update_hdr_trans(&dev->mt76, vif, sta);\n}\n\nstatic int mt7915_sta_set_txpwr(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta)\n{\n\tstruct mt7915_phy *phy = mt7915_hw_phy(hw);\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\ts16 txpower = sta->deflink.txpwr.power;\n\tint ret;\n\n\tif (sta->deflink.txpwr.type == NL80211_TX_POWER_AUTOMATIC)\n\t\ttxpower = 0;\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\t \n\tret = mt7915_mcu_set_txpower_frame_min(phy, 0);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = mt7915_mcu_set_txpower_frame(phy, vif, sta, txpower);\n\nout:\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn ret;\n}\n\nstatic const char mt7915_gstrings_stats[][ETH_GSTRING_LEN] = {\n\t\"tx_ampdu_cnt\",\n\t\"tx_stop_q_empty_cnt\",\n\t\"tx_mpdu_attempts\",\n\t\"tx_mpdu_success\",\n\t\"tx_rwp_fail_cnt\",\n\t\"tx_rwp_need_cnt\",\n\t\"tx_pkt_ebf_cnt\",\n\t\"tx_pkt_ibf_cnt\",\n\t\"tx_ampdu_len:0-1\",\n\t\"tx_ampdu_len:2-10\",\n\t\"tx_ampdu_len:11-19\",\n\t\"tx_ampdu_len:20-28\",\n\t\"tx_ampdu_len:29-37\",\n\t\"tx_ampdu_len:38-46\",\n\t\"tx_ampdu_len:47-55\",\n\t\"tx_ampdu_len:56-79\",\n\t\"tx_ampdu_len:80-103\",\n\t\"tx_ampdu_len:104-127\",\n\t\"tx_ampdu_len:128-151\",\n\t\"tx_ampdu_len:152-175\",\n\t\"tx_ampdu_len:176-199\",\n\t\"tx_ampdu_len:200-223\",\n\t\"tx_ampdu_len:224-247\",\n\t\"ba_miss_count\",\n\t\"tx_beamformer_ppdu_iBF\",\n\t\"tx_beamformer_ppdu_eBF\",\n\t\"tx_beamformer_rx_feedback_all\",\n\t\"tx_beamformer_rx_feedback_he\",\n\t\"tx_beamformer_rx_feedback_vht\",\n\t\"tx_beamformer_rx_feedback_ht\",\n\t\"tx_beamformer_rx_feedback_bw\",  \n\t\"tx_beamformer_rx_feedback_nc\",\n\t\"tx_beamformer_rx_feedback_nr\",\n\t\"tx_beamformee_ok_feedback_pkts\",\n\t\"tx_beamformee_feedback_trig\",\n\t\"tx_mu_beamforming\",\n\t\"tx_mu_mpdu\",\n\t\"tx_mu_successful_mpdu\",\n\t\"tx_su_successful_mpdu\",\n\t\"tx_msdu_pack_1\",\n\t\"tx_msdu_pack_2\",\n\t\"tx_msdu_pack_3\",\n\t\"tx_msdu_pack_4\",\n\t\"tx_msdu_pack_5\",\n\t\"tx_msdu_pack_6\",\n\t\"tx_msdu_pack_7\",\n\t\"tx_msdu_pack_8\",\n\n\t \n\t\"rx_fifo_full_cnt\",\n\t\"rx_mpdu_cnt\",\n\t\"channel_idle_cnt\",\n\t\"primary_cca_busy_time\",\n\t\"secondary_cca_busy_time\",\n\t\"primary_energy_detect_time\",\n\t\"cck_mdrdy_time\",\n\t\"ofdm_mdrdy_time\",\n\t\"green_mdrdy_time\",\n\t\"rx_vector_mismatch_cnt\",\n\t\"rx_delimiter_fail_cnt\",\n\t\"rx_mrdy_cnt\",\n\t\"rx_len_mismatch_cnt\",\n\t\"rx_ampdu_cnt\",\n\t\"rx_ampdu_bytes_cnt\",\n\t\"rx_ampdu_valid_subframe_cnt\",\n\t\"rx_ampdu_valid_subframe_b_cnt\",\n\t\"rx_pfdrop_cnt\",\n\t\"rx_vec_queue_overflow_drop_cnt\",\n\t\"rx_ba_cnt\",\n\n\t \n\t\"dl_cck_cnt\",\n\t\"dl_ofdm_cnt\",\n\t\"dl_htmix_cnt\",\n\t\"dl_htgf_cnt\",\n\t\"dl_vht_su_cnt\",\n\t\"dl_vht_2mu_cnt\",\n\t\"dl_vht_3mu_cnt\",\n\t\"dl_vht_4mu_cnt\",\n\t\"dl_he_su_cnt\",\n\t\"dl_he_ext_su_cnt\",\n\t\"dl_he_2ru_cnt\",\n\t\"dl_he_2mu_cnt\",\n\t\"dl_he_3ru_cnt\",\n\t\"dl_he_3mu_cnt\",\n\t\"dl_he_4ru_cnt\",\n\t\"dl_he_4mu_cnt\",\n\t\"dl_he_5to8ru_cnt\",\n\t\"dl_he_9to16ru_cnt\",\n\t\"dl_he_gtr16ru_cnt\",\n\n\t\"ul_hetrig_su_cnt\",\n\t\"ul_hetrig_2ru_cnt\",\n\t\"ul_hetrig_3ru_cnt\",\n\t\"ul_hetrig_4ru_cnt\",\n\t\"ul_hetrig_5to8ru_cnt\",\n\t\"ul_hetrig_9to16ru_cnt\",\n\t\"ul_hetrig_gtr16ru_cnt\",\n\t\"ul_hetrig_2mu_cnt\",\n\t\"ul_hetrig_3mu_cnt\",\n\t\"ul_hetrig_4mu_cnt\",\n\n\t \n\t\"v_tx_mode_cck\",\n\t\"v_tx_mode_ofdm\",\n\t\"v_tx_mode_ht\",\n\t\"v_tx_mode_ht_gf\",\n\t\"v_tx_mode_vht\",\n\t\"v_tx_mode_he_su\",\n\t\"v_tx_mode_he_ext_su\",\n\t\"v_tx_mode_he_tb\",\n\t\"v_tx_mode_he_mu\",\n\t\"v_tx_bw_20\",\n\t\"v_tx_bw_40\",\n\t\"v_tx_bw_80\",\n\t\"v_tx_bw_160\",\n\t\"v_tx_mcs_0\",\n\t\"v_tx_mcs_1\",\n\t\"v_tx_mcs_2\",\n\t\"v_tx_mcs_3\",\n\t\"v_tx_mcs_4\",\n\t\"v_tx_mcs_5\",\n\t\"v_tx_mcs_6\",\n\t\"v_tx_mcs_7\",\n\t\"v_tx_mcs_8\",\n\t\"v_tx_mcs_9\",\n\t\"v_tx_mcs_10\",\n\t\"v_tx_mcs_11\",\n\t\"v_tx_nss_1\",\n\t\"v_tx_nss_2\",\n\t\"v_tx_nss_3\",\n\t\"v_tx_nss_4\",\n};\n\n#define MT7915_SSTATS_LEN ARRAY_SIZE(mt7915_gstrings_stats)\n\n \nstatic\nvoid mt7915_get_et_strings(struct ieee80211_hw *hw,\n\t\t\t   struct ieee80211_vif *vif,\n\t\t\t   u32 sset, u8 *data)\n{\n\tif (sset != ETH_SS_STATS)\n\t\treturn;\n\n\tmemcpy(data, mt7915_gstrings_stats, sizeof(mt7915_gstrings_stats));\n\tdata += sizeof(mt7915_gstrings_stats);\n\tpage_pool_ethtool_stats_get_strings(data);\n}\n\nstatic\nint mt7915_get_et_sset_count(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif, int sset)\n{\n\tif (sset != ETH_SS_STATS)\n\t\treturn 0;\n\n\treturn MT7915_SSTATS_LEN + page_pool_ethtool_stats_get_count();\n}\n\nstatic void mt7915_ethtool_worker(void *wi_data, struct ieee80211_sta *sta)\n{\n\tstruct mt76_ethtool_worker_info *wi = wi_data;\n\tstruct mt7915_sta *msta = (struct mt7915_sta *)sta->drv_priv;\n\n\tif (msta->vif->mt76.idx != wi->idx)\n\t\treturn;\n\n\tmt76_ethtool_worker(wi, &msta->wcid.stats, false);\n}\n\nstatic\nvoid mt7915_get_et_stats(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t struct ethtool_stats *stats, u64 *data)\n{\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tstruct mt7915_phy *phy = mt7915_hw_phy(hw);\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct mt76_mib_stats *mib = &phy->mib;\n\tstruct mt76_ethtool_worker_info wi = {\n\t\t.data = data,\n\t\t.idx = mvif->mt76.idx,\n\t};\n\t \n\tint i, ei = 0, stats_size;\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tmt7915_mac_update_stats(phy);\n\n\tdata[ei++] = mib->tx_ampdu_cnt;\n\tdata[ei++] = mib->tx_stop_q_empty_cnt;\n\tdata[ei++] = mib->tx_mpdu_attempts_cnt;\n\tdata[ei++] = mib->tx_mpdu_success_cnt;\n\tdata[ei++] = mib->tx_rwp_fail_cnt;\n\tdata[ei++] = mib->tx_rwp_need_cnt;\n\tdata[ei++] = mib->tx_pkt_ebf_cnt;\n\tdata[ei++] = mib->tx_pkt_ibf_cnt;\n\n\t \n\tfor (i = 0; i < 15  ; i++)\n\t\tdata[ei++] = phy->mt76->aggr_stats[i];\n\n\tdata[ei++] = phy->mib.ba_miss_cnt;\n\n\t \n\tdata[ei++] = mib->tx_bf_ibf_ppdu_cnt;\n\tdata[ei++] = mib->tx_bf_ebf_ppdu_cnt;\n\n\t \n\tdata[ei++] = mib->tx_bf_rx_fb_all_cnt;\n\tdata[ei++] = mib->tx_bf_rx_fb_he_cnt;\n\tdata[ei++] = mib->tx_bf_rx_fb_vht_cnt;\n\tdata[ei++] = mib->tx_bf_rx_fb_ht_cnt;\n\n\tdata[ei++] = mib->tx_bf_rx_fb_bw;\n\tdata[ei++] = mib->tx_bf_rx_fb_nc_cnt;\n\tdata[ei++] = mib->tx_bf_rx_fb_nr_cnt;\n\n\t \n\tdata[ei++] = mib->tx_bf_fb_cpl_cnt;\n\tdata[ei++] = mib->tx_bf_fb_trig_cnt;\n\n\t \n\tdata[ei++] = mib->tx_bf_cnt;\n\tdata[ei++] = mib->tx_mu_mpdu_cnt;\n\tdata[ei++] = mib->tx_mu_acked_mpdu_cnt;\n\tdata[ei++] = mib->tx_su_acked_mpdu_cnt;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(mib->tx_amsdu); i++)\n\t\tdata[ei++] = mib->tx_amsdu[i];\n\n\t \n\tdata[ei++] = mib->rx_fifo_full_cnt;\n\tdata[ei++] = mib->rx_mpdu_cnt;\n\tdata[ei++] = mib->channel_idle_cnt;\n\tdata[ei++] = mib->primary_cca_busy_time;\n\tdata[ei++] = mib->secondary_cca_busy_time;\n\tdata[ei++] = mib->primary_energy_detect_time;\n\tdata[ei++] = mib->cck_mdrdy_time;\n\tdata[ei++] = mib->ofdm_mdrdy_time;\n\tdata[ei++] = mib->green_mdrdy_time;\n\tdata[ei++] = mib->rx_vector_mismatch_cnt;\n\tdata[ei++] = mib->rx_delimiter_fail_cnt;\n\tdata[ei++] = mib->rx_mrdy_cnt;\n\tdata[ei++] = mib->rx_len_mismatch_cnt;\n\tdata[ei++] = mib->rx_ampdu_cnt;\n\tdata[ei++] = mib->rx_ampdu_bytes_cnt;\n\tdata[ei++] = mib->rx_ampdu_valid_subframe_cnt;\n\tdata[ei++] = mib->rx_ampdu_valid_subframe_bytes_cnt;\n\tdata[ei++] = mib->rx_pfdrop_cnt;\n\tdata[ei++] = mib->rx_vec_queue_overflow_drop_cnt;\n\tdata[ei++] = mib->rx_ba_cnt;\n\n\tdata[ei++] = mib->dl_cck_cnt;\n\tdata[ei++] = mib->dl_ofdm_cnt;\n\tdata[ei++] = mib->dl_htmix_cnt;\n\tdata[ei++] = mib->dl_htgf_cnt;\n\tdata[ei++] = mib->dl_vht_su_cnt;\n\tdata[ei++] = mib->dl_vht_2mu_cnt;\n\tdata[ei++] = mib->dl_vht_3mu_cnt;\n\tdata[ei++] = mib->dl_vht_4mu_cnt;\n\tdata[ei++] = mib->dl_he_su_cnt;\n\tdata[ei++] = mib->dl_he_ext_su_cnt;\n\tdata[ei++] = mib->dl_he_2ru_cnt;\n\tdata[ei++] = mib->dl_he_2mu_cnt;\n\tdata[ei++] = mib->dl_he_3ru_cnt;\n\tdata[ei++] = mib->dl_he_3mu_cnt;\n\tdata[ei++] = mib->dl_he_4ru_cnt;\n\tdata[ei++] = mib->dl_he_4mu_cnt;\n\tdata[ei++] = mib->dl_he_5to8ru_cnt;\n\tdata[ei++] = mib->dl_he_9to16ru_cnt;\n\tdata[ei++] = mib->dl_he_gtr16ru_cnt;\n\n\tdata[ei++] = mib->ul_hetrig_su_cnt;\n\tdata[ei++] = mib->ul_hetrig_2ru_cnt;\n\tdata[ei++] = mib->ul_hetrig_3ru_cnt;\n\tdata[ei++] = mib->ul_hetrig_4ru_cnt;\n\tdata[ei++] = mib->ul_hetrig_5to8ru_cnt;\n\tdata[ei++] = mib->ul_hetrig_9to16ru_cnt;\n\tdata[ei++] = mib->ul_hetrig_gtr16ru_cnt;\n\tdata[ei++] = mib->ul_hetrig_2mu_cnt;\n\tdata[ei++] = mib->ul_hetrig_3mu_cnt;\n\tdata[ei++] = mib->ul_hetrig_4mu_cnt;\n\n\t \n\twi.initial_stat_idx = ei;\n\tieee80211_iterate_stations_atomic(hw, mt7915_ethtool_worker, &wi);\n\n\tmutex_unlock(&dev->mt76.mutex);\n\n\tif (wi.sta_count == 0)\n\t\treturn;\n\n\tei += wi.worker_stat_count;\n\n\tmt76_ethtool_page_pool_stats(&dev->mt76, &data[ei], &ei);\n\n\tstats_size = MT7915_SSTATS_LEN + page_pool_ethtool_stats_get_count();\n\tif (ei != stats_size)\n\t\tdev_err(dev->mt76.dev, \"ei: %d size: %d\", ei, stats_size);\n}\n\nstatic void\nmt7915_twt_teardown_request(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_sta *sta,\n\t\t\t    u8 flowid)\n{\n\tstruct mt7915_sta *msta = (struct mt7915_sta *)sta->drv_priv;\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\n\tmutex_lock(&dev->mt76.mutex);\n\tmt7915_mac_twt_teardown_flow(dev, msta, flowid);\n\tmutex_unlock(&dev->mt76.mutex);\n}\n\nstatic int\nmt7915_set_radar_background(struct ieee80211_hw *hw,\n\t\t\t    struct cfg80211_chan_def *chandef)\n{\n\tstruct mt7915_phy *phy = mt7915_hw_phy(hw);\n\tstruct mt7915_dev *dev = phy->dev;\n\tint ret = -EINVAL;\n\tbool running;\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tif (dev->mt76.region == NL80211_DFS_UNSET)\n\t\tgoto out;\n\n\tif (dev->rdd2_phy && dev->rdd2_phy != phy) {\n\t\t \n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\trunning = dev->rdd2_phy &&\n\t\t  cfg80211_chandef_valid(&dev->rdd2_chandef) &&\n\t\t  !!(dev->rdd2_chandef.chan->flags & IEEE80211_CHAN_RADAR);\n\n\tif (!chandef || running ||\n\t    !(chandef->chan->flags & IEEE80211_CHAN_RADAR)) {\n\t\tret = mt7915_mcu_rdd_background_enable(phy, NULL);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (!running)\n\t\t\tgoto update_phy;\n\t}\n\n\tret = mt7915_mcu_rdd_background_enable(phy, chandef);\n\tif (ret)\n\t\tgoto out;\n\nupdate_phy:\n\tdev->rdd2_phy = chandef ? phy : NULL;\n\tif (chandef)\n\t\tdev->rdd2_chandef = *chandef;\nout:\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_NET_MEDIATEK_SOC_WED\nstatic int\nmt7915_net_fill_forward_path(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_sta *sta,\n\t\t\t     struct net_device_path_ctx *ctx,\n\t\t\t     struct net_device_path *path)\n{\n\tstruct mt7915_vif *mvif = (struct mt7915_vif *)vif->drv_priv;\n\tstruct mt7915_sta *msta = (struct mt7915_sta *)sta->drv_priv;\n\tstruct mt7915_dev *dev = mt7915_hw_dev(hw);\n\tstruct mt7915_phy *phy = mt7915_hw_phy(hw);\n\tstruct mtk_wed_device *wed = &dev->mt76.mmio.wed;\n\n\tif (!mtk_wed_device_active(wed))\n\t\treturn -ENODEV;\n\n\tif (msta->wcid.idx > 0xff)\n\t\treturn -EIO;\n\n\tpath->type = DEV_PATH_MTK_WDMA;\n\tpath->dev = ctx->dev;\n\tpath->mtk_wdma.wdma_idx = wed->wdma_idx;\n\tpath->mtk_wdma.bss = mvif->mt76.idx;\n\tpath->mtk_wdma.wcid = is_mt7915(&dev->mt76) ? msta->wcid.idx : 0x3ff;\n\tpath->mtk_wdma.queue = phy != &dev->phy;\n\n\tctx->dev = NULL;\n\n\treturn 0;\n}\n#endif\n\nconst struct ieee80211_ops mt7915_ops = {\n\t.tx = mt7915_tx,\n\t.start = mt7915_start,\n\t.stop = mt7915_stop,\n\t.add_interface = mt7915_add_interface,\n\t.remove_interface = mt7915_remove_interface,\n\t.config = mt7915_config,\n\t.conf_tx = mt7915_conf_tx,\n\t.configure_filter = mt7915_configure_filter,\n\t.bss_info_changed = mt7915_bss_info_changed,\n\t.start_ap = mt7915_start_ap,\n\t.stop_ap = mt7915_stop_ap,\n\t.sta_add = mt7915_sta_add,\n\t.sta_remove = mt7915_sta_remove,\n\t.sta_pre_rcu_remove = mt76_sta_pre_rcu_remove,\n\t.sta_rc_update = mt7915_sta_rc_update,\n\t.set_key = mt7915_set_key,\n\t.ampdu_action = mt7915_ampdu_action,\n\t.set_rts_threshold = mt7915_set_rts_threshold,\n\t.wake_tx_queue = mt76_wake_tx_queue,\n\t.sw_scan_start = mt76_sw_scan,\n\t.sw_scan_complete = mt76_sw_scan_complete,\n\t.release_buffered_frames = mt76_release_buffered_frames,\n\t.get_txpower = mt76_get_txpower,\n\t.set_sar_specs = mt7915_set_sar_specs,\n\t.channel_switch_beacon = mt7915_channel_switch_beacon,\n\t.get_stats = mt7915_get_stats,\n\t.get_et_sset_count = mt7915_get_et_sset_count,\n\t.get_et_stats = mt7915_get_et_stats,\n\t.get_et_strings = mt7915_get_et_strings,\n\t.get_tsf = mt7915_get_tsf,\n\t.set_tsf = mt7915_set_tsf,\n\t.offset_tsf = mt7915_offset_tsf,\n\t.get_survey = mt76_get_survey,\n\t.get_antenna = mt76_get_antenna,\n\t.set_antenna = mt7915_set_antenna,\n\t.set_bitrate_mask = mt7915_set_bitrate_mask,\n\t.set_coverage_class = mt7915_set_coverage_class,\n\t.sta_statistics = mt7915_sta_statistics,\n\t.sta_set_txpwr = mt7915_sta_set_txpwr,\n\t.sta_set_4addr = mt7915_sta_set_4addr,\n\t.sta_set_decap_offload = mt7915_sta_set_decap_offload,\n\t.add_twt_setup = mt7915_mac_add_twt_setup,\n\t.twt_teardown_request = mt7915_twt_teardown_request,\n\tCFG80211_TESTMODE_CMD(mt76_testmode_cmd)\n\tCFG80211_TESTMODE_DUMP(mt76_testmode_dump)\n#ifdef CONFIG_MAC80211_DEBUGFS\n\t.sta_add_debugfs = mt7915_sta_add_debugfs,\n#endif\n\t.set_radar_background = mt7915_set_radar_background,\n#ifdef CONFIG_NET_MEDIATEK_SOC_WED\n\t.net_fill_forward_path = mt7915_net_fill_forward_path,\n#endif\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}