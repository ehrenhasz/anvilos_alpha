{
  "module_name": "mac.c",
  "hash_id": "ea5b540ba9b2d05828673cc79b46e800df555aa2e64712686145674004a9c5ef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7996/mac.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/timekeeping.h>\n#include \"coredump.h\"\n#include \"mt7996.h\"\n#include \"../dma.h\"\n#include \"mac.h\"\n#include \"mcu.h\"\n\n#define to_rssi(field, rcpi)\t((FIELD_GET(field, rcpi) - 220) / 2)\n\nstatic const struct mt7996_dfs_radar_spec etsi_radar_specs = {\n\t.pulse_th = { 110, -10, -80, 40, 5200, 128, 5200 },\n\t.radar_pattern = {\n\t\t[5] =  { 1, 0,  6, 32, 28, 0,  990, 5010, 17, 1, 1 },\n\t\t[6] =  { 1, 0,  9, 32, 28, 0,  615, 5010, 27, 1, 1 },\n\t\t[7] =  { 1, 0, 15, 32, 28, 0,  240,  445, 27, 1, 1 },\n\t\t[8] =  { 1, 0, 12, 32, 28, 0,  240,  510, 42, 1, 1 },\n\t\t[9] =  { 1, 1,  0,  0,  0, 0, 2490, 3343, 14, 0, 0, 12, 32, 28, { }, 126 },\n\t\t[10] = { 1, 1,  0,  0,  0, 0, 2490, 3343, 14, 0, 0, 15, 32, 24, { }, 126 },\n\t\t[11] = { 1, 1,  0,  0,  0, 0,  823, 2510, 14, 0, 0, 18, 32, 28, { },  54 },\n\t\t[12] = { 1, 1,  0,  0,  0, 0,  823, 2510, 14, 0, 0, 27, 32, 24, { },  54 },\n\t},\n};\n\nstatic const struct mt7996_dfs_radar_spec fcc_radar_specs = {\n\t.pulse_th = { 110, -10, -80, 40, 5200, 128, 5200 },\n\t.radar_pattern = {\n\t\t[0] = { 1, 0,  8,  32, 28, 0, 508, 3076, 13, 1,  1 },\n\t\t[1] = { 1, 0, 12,  32, 28, 0, 140,  240, 17, 1,  1 },\n\t\t[2] = { 1, 0,  8,  32, 28, 0, 190,  510, 22, 1,  1 },\n\t\t[3] = { 1, 0,  6,  32, 28, 0, 190,  510, 32, 1,  1 },\n\t\t[4] = { 1, 0,  9, 255, 28, 0, 323,  343, 13, 1, 32 },\n\t},\n};\n\nstatic const struct mt7996_dfs_radar_spec jp_radar_specs = {\n\t.pulse_th = { 110, -10, -80, 40, 5200, 128, 5200 },\n\t.radar_pattern = {\n\t\t[0] =  { 1, 0,  8,  32, 28, 0,  508, 3076,  13, 1,  1 },\n\t\t[1] =  { 1, 0, 12,  32, 28, 0,  140,  240,  17, 1,  1 },\n\t\t[2] =  { 1, 0,  8,  32, 28, 0,  190,  510,  22, 1,  1 },\n\t\t[3] =  { 1, 0,  6,  32, 28, 0,  190,  510,  32, 1,  1 },\n\t\t[4] =  { 1, 0,  9, 255, 28, 0,  323,  343,  13, 1, 32 },\n\t\t[13] = { 1, 0,  7,  32, 28, 0, 3836, 3856,  14, 1,  1 },\n\t\t[14] = { 1, 0,  6,  32, 28, 0,  615, 5010, 110, 1,  1 },\n\t\t[15] = { 1, 1,  0,   0,  0, 0,   15, 5010, 110, 0,  0, 12, 32, 28 },\n\t},\n};\n\nstatic struct mt76_wcid *mt7996_rx_get_wcid(struct mt7996_dev *dev,\n\t\t\t\t\t    u16 idx, bool unicast)\n{\n\tstruct mt7996_sta *sta;\n\tstruct mt76_wcid *wcid;\n\n\tif (idx >= ARRAY_SIZE(dev->mt76.wcid))\n\t\treturn NULL;\n\n\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n\tif (unicast || !wcid)\n\t\treturn wcid;\n\n\tif (!wcid->sta)\n\t\treturn NULL;\n\n\tsta = container_of(wcid, struct mt7996_sta, wcid);\n\tif (!sta->vif)\n\t\treturn NULL;\n\n\treturn &sta->vif->sta.wcid;\n}\n\nbool mt7996_mac_wtbl_update(struct mt7996_dev *dev, int idx, u32 mask)\n{\n\tmt76_rmw(dev, MT_WTBL_UPDATE, MT_WTBL_UPDATE_WLAN_IDX,\n\t\t FIELD_PREP(MT_WTBL_UPDATE_WLAN_IDX, idx) | mask);\n\n\treturn mt76_poll(dev, MT_WTBL_UPDATE, MT_WTBL_UPDATE_BUSY,\n\t\t\t 0, 5000);\n}\n\nu32 mt7996_mac_wtbl_lmac_addr(struct mt7996_dev *dev, u16 wcid, u8 dw)\n{\n\tmt76_wr(dev, MT_WTBLON_TOP_WDUCR,\n\t\tFIELD_PREP(MT_WTBLON_TOP_WDUCR_GROUP, (wcid >> 7)));\n\n\treturn MT_WTBL_LMAC_OFFS(wcid, dw);\n}\n\nstatic void mt7996_mac_sta_poll(struct mt7996_dev *dev)\n{\n\tstatic const u8 ac_to_tid[] = {\n\t\t[IEEE80211_AC_BE] = 0,\n\t\t[IEEE80211_AC_BK] = 1,\n\t\t[IEEE80211_AC_VI] = 4,\n\t\t[IEEE80211_AC_VO] = 6\n\t};\n\tstruct ieee80211_sta *sta;\n\tstruct mt7996_sta *msta;\n\tstruct rate_info *rate;\n\tu32 tx_time[IEEE80211_NUM_ACS], rx_time[IEEE80211_NUM_ACS];\n\tLIST_HEAD(sta_poll_list);\n\tint i;\n\n\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\tlist_splice_init(&dev->mt76.sta_poll_list, &sta_poll_list);\n\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\n\trcu_read_lock();\n\n\twhile (true) {\n\t\tbool clear = false;\n\t\tu32 addr, val;\n\t\tu16 idx;\n\t\ts8 rssi[4];\n\t\tu8 bw;\n\n\t\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\t\tif (list_empty(&sta_poll_list)) {\n\t\t\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\t\t\tbreak;\n\t\t}\n\t\tmsta = list_first_entry(&sta_poll_list,\n\t\t\t\t\tstruct mt7996_sta, wcid.poll_list);\n\t\tlist_del_init(&msta->wcid.poll_list);\n\t\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\n\t\tidx = msta->wcid.idx;\n\n\t\t \n\t\taddr = mt7996_mac_wtbl_lmac_addr(dev, idx, 20);\n\n\t\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\t\tu32 tx_last = msta->airtime_ac[i];\n\t\t\tu32 rx_last = msta->airtime_ac[i + 4];\n\n\t\t\tmsta->airtime_ac[i] = mt76_rr(dev, addr);\n\t\t\tmsta->airtime_ac[i + 4] = mt76_rr(dev, addr + 4);\n\n\t\t\ttx_time[i] = msta->airtime_ac[i] - tx_last;\n\t\t\trx_time[i] = msta->airtime_ac[i + 4] - rx_last;\n\n\t\t\tif ((tx_last | rx_last) & BIT(30))\n\t\t\t\tclear = true;\n\n\t\t\taddr += 8;\n\t\t}\n\n\t\tif (clear) {\n\t\t\tmt7996_mac_wtbl_update(dev, idx,\n\t\t\t\t\t       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);\n\t\t\tmemset(msta->airtime_ac, 0, sizeof(msta->airtime_ac));\n\t\t}\n\n\t\tif (!msta->wcid.sta)\n\t\t\tcontinue;\n\n\t\tsta = container_of((void *)msta, struct ieee80211_sta,\n\t\t\t\t   drv_priv);\n\t\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\t\tu8 q = mt76_connac_lmac_mapping(i);\n\t\t\tu32 tx_cur = tx_time[q];\n\t\t\tu32 rx_cur = rx_time[q];\n\t\t\tu8 tid = ac_to_tid[i];\n\n\t\t\tif (!tx_cur && !rx_cur)\n\t\t\t\tcontinue;\n\n\t\t\tieee80211_sta_register_airtime(sta, tid, tx_cur, rx_cur);\n\t\t}\n\n\t\t \n\t\trate = &msta->wcid.rate;\n\n\t\tswitch (rate->bw) {\n\t\tcase RATE_INFO_BW_320:\n\t\t\tbw = IEEE80211_STA_RX_BW_320;\n\t\t\tbreak;\n\t\tcase RATE_INFO_BW_160:\n\t\t\tbw = IEEE80211_STA_RX_BW_160;\n\t\t\tbreak;\n\t\tcase RATE_INFO_BW_80:\n\t\t\tbw = IEEE80211_STA_RX_BW_80;\n\t\t\tbreak;\n\t\tcase RATE_INFO_BW_40:\n\t\t\tbw = IEEE80211_STA_RX_BW_40;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbw = IEEE80211_STA_RX_BW_20;\n\t\t\tbreak;\n\t\t}\n\n\t\taddr = mt7996_mac_wtbl_lmac_addr(dev, idx, 6);\n\t\tval = mt76_rr(dev, addr);\n\t\tif (rate->flags & RATE_INFO_FLAGS_EHT_MCS) {\n\t\t\taddr = mt7996_mac_wtbl_lmac_addr(dev, idx, 5);\n\t\t\tval = mt76_rr(dev, addr);\n\t\t\trate->eht_gi = FIELD_GET(GENMASK(25, 24), val);\n\t\t} else if (rate->flags & RATE_INFO_FLAGS_HE_MCS) {\n\t\t\tu8 offs = 24 + 2 * bw;\n\n\t\t\trate->he_gi = (val & (0x3 << offs)) >> offs;\n\t\t} else if (rate->flags &\n\t\t\t   (RATE_INFO_FLAGS_VHT_MCS | RATE_INFO_FLAGS_MCS)) {\n\t\t\tif (val & BIT(12 + bw))\n\t\t\t\trate->flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t\t\telse\n\t\t\t\trate->flags &= ~RATE_INFO_FLAGS_SHORT_GI;\n\t\t}\n\n\t\t \n\t\taddr = mt7996_mac_wtbl_lmac_addr(dev, idx, 34);\n\t\tval = mt76_rr(dev, addr);\n\n\t\trssi[0] = to_rssi(GENMASK(7, 0), val);\n\t\trssi[1] = to_rssi(GENMASK(15, 8), val);\n\t\trssi[2] = to_rssi(GENMASK(23, 16), val);\n\t\trssi[3] = to_rssi(GENMASK(31, 14), val);\n\n\t\tmsta->ack_signal =\n\t\t\tmt76_rx_signal(msta->vif->phy->mt76->antenna_mask, rssi);\n\n\t\tewma_avg_signal_add(&msta->avg_ack_signal, -msta->ack_signal);\n\t}\n\n\trcu_read_unlock();\n}\n\nvoid mt7996_mac_enable_rtscts(struct mt7996_dev *dev,\n\t\t\t      struct ieee80211_vif *vif, bool enable)\n{\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tu32 addr;\n\n\taddr = mt7996_mac_wtbl_lmac_addr(dev, mvif->sta.wcid.idx, 5);\n\tif (enable)\n\t\tmt76_set(dev, addr, BIT(5));\n\telse\n\t\tmt76_clear(dev, addr, BIT(5));\n}\n\nvoid mt7996_mac_set_fixed_rate_table(struct mt7996_dev *dev,\n\t\t\t\t     u8 tbl_idx, u16 rate_idx)\n{\n\tu32 ctrl = MT_WTBL_ITCR_WR | MT_WTBL_ITCR_EXEC | tbl_idx;\n\n\tmt76_wr(dev, MT_WTBL_ITDR0, rate_idx);\n\t \n\tmt76_wr(dev, MT_WTBL_ITDR1, MT_WTBL_SPE_IDX_SEL);\n\tmt76_wr(dev, MT_WTBL_ITCR, ctrl);\n}\n\n \nstatic int mt7996_reverse_frag0_hdr_trans(struct sk_buff *skb, u16 hdr_gap)\n{\n\tstruct mt76_rx_status *status = (struct mt76_rx_status *)skb->cb;\n\tstruct ethhdr *eth_hdr = (struct ethhdr *)(skb->data + hdr_gap);\n\tstruct mt7996_sta *msta = (struct mt7996_sta *)status->wcid;\n\t__le32 *rxd = (__le32 *)skb->data;\n\tstruct ieee80211_sta *sta;\n\tstruct ieee80211_vif *vif;\n\tstruct ieee80211_hdr hdr;\n\tu16 frame_control;\n\n\tif (le32_get_bits(rxd[3], MT_RXD3_NORMAL_ADDR_TYPE) !=\n\t    MT_RXD3_NORMAL_U2M)\n\t\treturn -EINVAL;\n\n\tif (!(le32_to_cpu(rxd[1]) & MT_RXD1_NORMAL_GROUP_4))\n\t\treturn -EINVAL;\n\n\tif (!msta || !msta->vif)\n\t\treturn -EINVAL;\n\n\tsta = container_of((void *)msta, struct ieee80211_sta, drv_priv);\n\tvif = container_of((void *)msta->vif, struct ieee80211_vif, drv_priv);\n\n\t \n\tframe_control = le32_get_bits(rxd[8], MT_RXD8_FRAME_CONTROL);\n\thdr.frame_control = cpu_to_le16(frame_control);\n\thdr.seq_ctrl = cpu_to_le16(le32_get_bits(rxd[10], MT_RXD10_SEQ_CTRL));\n\thdr.duration_id = 0;\n\n\tether_addr_copy(hdr.addr1, vif->addr);\n\tether_addr_copy(hdr.addr2, sta->addr);\n\tswitch (frame_control & (IEEE80211_FCTL_TODS |\n\t\t\t\t IEEE80211_FCTL_FROMDS)) {\n\tcase 0:\n\t\tether_addr_copy(hdr.addr3, vif->bss_conf.bssid);\n\t\tbreak;\n\tcase IEEE80211_FCTL_FROMDS:\n\t\tether_addr_copy(hdr.addr3, eth_hdr->h_source);\n\t\tbreak;\n\tcase IEEE80211_FCTL_TODS:\n\t\tether_addr_copy(hdr.addr3, eth_hdr->h_dest);\n\t\tbreak;\n\tcase IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS:\n\t\tether_addr_copy(hdr.addr3, eth_hdr->h_dest);\n\t\tether_addr_copy(hdr.addr4, eth_hdr->h_source);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tskb_pull(skb, hdr_gap + sizeof(struct ethhdr) - 2);\n\tif (eth_hdr->h_proto == cpu_to_be16(ETH_P_AARP) ||\n\t    eth_hdr->h_proto == cpu_to_be16(ETH_P_IPX))\n\t\tether_addr_copy(skb_push(skb, ETH_ALEN), bridge_tunnel_header);\n\telse if (be16_to_cpu(eth_hdr->h_proto) >= ETH_P_802_3_MIN)\n\t\tether_addr_copy(skb_push(skb, ETH_ALEN), rfc1042_header);\n\telse\n\t\tskb_pull(skb, 2);\n\n\tif (ieee80211_has_order(hdr.frame_control))\n\t\tmemcpy(skb_push(skb, IEEE80211_HT_CTL_LEN), &rxd[11],\n\t\t       IEEE80211_HT_CTL_LEN);\n\tif (ieee80211_is_data_qos(hdr.frame_control)) {\n\t\t__le16 qos_ctrl;\n\n\t\tqos_ctrl = cpu_to_le16(le32_get_bits(rxd[10], MT_RXD10_QOS_CTL));\n\t\tmemcpy(skb_push(skb, IEEE80211_QOS_CTL_LEN), &qos_ctrl,\n\t\t       IEEE80211_QOS_CTL_LEN);\n\t}\n\n\tif (ieee80211_has_a4(hdr.frame_control))\n\t\tmemcpy(skb_push(skb, sizeof(hdr)), &hdr, sizeof(hdr));\n\telse\n\t\tmemcpy(skb_push(skb, sizeof(hdr) - 6), &hdr, sizeof(hdr) - 6);\n\n\treturn 0;\n}\n\nstatic int\nmt7996_mac_fill_rx_rate(struct mt7996_dev *dev,\n\t\t\tstruct mt76_rx_status *status,\n\t\t\tstruct ieee80211_supported_band *sband,\n\t\t\t__le32 *rxv, u8 *mode)\n{\n\tu32 v0, v2;\n\tu8 stbc, gi, bw, dcm, nss;\n\tint i, idx;\n\tbool cck = false;\n\n\tv0 = le32_to_cpu(rxv[0]);\n\tv2 = le32_to_cpu(rxv[2]);\n\n\tidx = FIELD_GET(MT_PRXV_TX_RATE, v0);\n\ti = idx;\n\tnss = FIELD_GET(MT_PRXV_NSTS, v0) + 1;\n\n\tstbc = FIELD_GET(MT_PRXV_HT_STBC, v2);\n\tgi = FIELD_GET(MT_PRXV_HT_SHORT_GI, v2);\n\t*mode = FIELD_GET(MT_PRXV_TX_MODE, v2);\n\tdcm = FIELD_GET(MT_PRXV_DCM, v2);\n\tbw = FIELD_GET(MT_PRXV_FRAME_MODE, v2);\n\n\tswitch (*mode) {\n\tcase MT_PHY_TYPE_CCK:\n\t\tcck = true;\n\t\tfallthrough;\n\tcase MT_PHY_TYPE_OFDM:\n\t\ti = mt76_get_rate(&dev->mt76, sband, i, cck);\n\t\tbreak;\n\tcase MT_PHY_TYPE_HT_GF:\n\tcase MT_PHY_TYPE_HT:\n\t\tstatus->encoding = RX_ENC_HT;\n\t\tif (gi)\n\t\t\tstatus->enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\t\tif (i > 31)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase MT_PHY_TYPE_VHT:\n\t\tstatus->nss = nss;\n\t\tstatus->encoding = RX_ENC_VHT;\n\t\tif (gi)\n\t\t\tstatus->enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\t\tif (i > 11)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase MT_PHY_TYPE_HE_MU:\n\tcase MT_PHY_TYPE_HE_SU:\n\tcase MT_PHY_TYPE_HE_EXT_SU:\n\tcase MT_PHY_TYPE_HE_TB:\n\t\tstatus->nss = nss;\n\t\tstatus->encoding = RX_ENC_HE;\n\t\ti &= GENMASK(3, 0);\n\n\t\tif (gi <= NL80211_RATE_INFO_HE_GI_3_2)\n\t\t\tstatus->he_gi = gi;\n\n\t\tstatus->he_dcm = dcm;\n\t\tbreak;\n\tcase MT_PHY_TYPE_EHT_SU:\n\tcase MT_PHY_TYPE_EHT_TRIG:\n\tcase MT_PHY_TYPE_EHT_MU:\n\t\tstatus->nss = nss;\n\t\tstatus->encoding = RX_ENC_EHT;\n\t\ti &= GENMASK(3, 0);\n\n\t\tif (gi <= NL80211_RATE_INFO_EHT_GI_3_2)\n\t\t\tstatus->eht.gi = gi;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tstatus->rate_idx = i;\n\n\tswitch (bw) {\n\tcase IEEE80211_STA_RX_BW_20:\n\t\tbreak;\n\tcase IEEE80211_STA_RX_BW_40:\n\t\tif (*mode & MT_PHY_TYPE_HE_EXT_SU &&\n\t\t    (idx & MT_PRXV_TX_ER_SU_106T)) {\n\t\t\tstatus->bw = RATE_INFO_BW_HE_RU;\n\t\t\tstatus->he_ru =\n\t\t\t\tNL80211_RATE_INFO_HE_RU_ALLOC_106;\n\t\t} else {\n\t\t\tstatus->bw = RATE_INFO_BW_40;\n\t\t}\n\t\tbreak;\n\tcase IEEE80211_STA_RX_BW_80:\n\t\tstatus->bw = RATE_INFO_BW_80;\n\t\tbreak;\n\tcase IEEE80211_STA_RX_BW_160:\n\t\tstatus->bw = RATE_INFO_BW_160;\n\t\tbreak;\n\t \n\tcase IEEE80211_STA_RX_BW_320:\n\tcase IEEE80211_STA_RX_BW_320 + 1:\n\t\tstatus->bw = RATE_INFO_BW_320;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tstatus->enc_flags |= RX_ENC_FLAG_STBC_MASK * stbc;\n\tif (*mode < MT_PHY_TYPE_HE_SU && gi)\n\t\tstatus->enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\n\treturn 0;\n}\n\nstatic int\nmt7996_mac_fill_rx(struct mt7996_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt76_rx_status *status = (struct mt76_rx_status *)skb->cb;\n\tstruct mt76_phy *mphy = &dev->mt76.phy;\n\tstruct mt7996_phy *phy = &dev->phy;\n\tstruct ieee80211_supported_band *sband;\n\t__le32 *rxd = (__le32 *)skb->data;\n\t__le32 *rxv = NULL;\n\tu32 rxd0 = le32_to_cpu(rxd[0]);\n\tu32 rxd1 = le32_to_cpu(rxd[1]);\n\tu32 rxd2 = le32_to_cpu(rxd[2]);\n\tu32 rxd3 = le32_to_cpu(rxd[3]);\n\tu32 rxd4 = le32_to_cpu(rxd[4]);\n\tu32 csum_mask = MT_RXD0_NORMAL_IP_SUM | MT_RXD0_NORMAL_UDP_TCP_SUM;\n\tu32 csum_status = *(u32 *)skb->cb;\n\tu32 mesh_mask = MT_RXD0_MESH | MT_RXD0_MHCP;\n\tbool is_mesh = (rxd0 & mesh_mask) == mesh_mask;\n\tbool unicast, insert_ccmp_hdr = false;\n\tu8 remove_pad, amsdu_info, band_idx;\n\tu8 mode = 0, qos_ctl = 0;\n\tbool hdr_trans;\n\tu16 hdr_gap;\n\tu16 seq_ctrl = 0;\n\t__le16 fc = 0;\n\tint idx;\n\n\tmemset(status, 0, sizeof(*status));\n\n\tband_idx = FIELD_GET(MT_RXD1_NORMAL_BAND_IDX, rxd1);\n\tmphy = dev->mt76.phys[band_idx];\n\tphy = mphy->priv;\n\tstatus->phy_idx = mphy->band_idx;\n\n\tif (!test_bit(MT76_STATE_RUNNING, &mphy->state))\n\t\treturn -EINVAL;\n\n\tif (rxd2 & MT_RXD2_NORMAL_AMSDU_ERR)\n\t\treturn -EINVAL;\n\n\thdr_trans = rxd2 & MT_RXD2_NORMAL_HDR_TRANS;\n\tif (hdr_trans && (rxd1 & MT_RXD1_NORMAL_CM))\n\t\treturn -EINVAL;\n\n\t \n\tif (rxd1 & MT_RXD1_NORMAL_ICV_ERR)\n\t\tstatus->flag |= RX_FLAG_ONLY_MONITOR;\n\n\tunicast = FIELD_GET(MT_RXD3_NORMAL_ADDR_TYPE, rxd3) == MT_RXD3_NORMAL_U2M;\n\tidx = FIELD_GET(MT_RXD1_NORMAL_WLAN_IDX, rxd1);\n\tstatus->wcid = mt7996_rx_get_wcid(dev, idx, unicast);\n\n\tif (status->wcid) {\n\t\tstruct mt7996_sta *msta;\n\n\t\tmsta = container_of(status->wcid, struct mt7996_sta, wcid);\n\t\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\t\tif (list_empty(&msta->wcid.poll_list))\n\t\t\tlist_add_tail(&msta->wcid.poll_list,\n\t\t\t\t      &dev->mt76.sta_poll_list);\n\t\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\t}\n\n\tstatus->freq = mphy->chandef.chan->center_freq;\n\tstatus->band = mphy->chandef.chan->band;\n\tif (status->band == NL80211_BAND_5GHZ)\n\t\tsband = &mphy->sband_5g.sband;\n\telse if (status->band == NL80211_BAND_6GHZ)\n\t\tsband = &mphy->sband_6g.sband;\n\telse\n\t\tsband = &mphy->sband_2g.sband;\n\n\tif (!sband->channels)\n\t\treturn -EINVAL;\n\n\tif ((rxd0 & csum_mask) == csum_mask &&\n\t    !(csum_status & (BIT(0) | BIT(2) | BIT(3))))\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tif (rxd1 & MT_RXD3_NORMAL_FCS_ERR)\n\t\tstatus->flag |= RX_FLAG_FAILED_FCS_CRC;\n\n\tif (rxd1 & MT_RXD1_NORMAL_TKIP_MIC_ERR)\n\t\tstatus->flag |= RX_FLAG_MMIC_ERROR;\n\n\tif (FIELD_GET(MT_RXD2_NORMAL_SEC_MODE, rxd2) != 0 &&\n\t    !(rxd1 & (MT_RXD1_NORMAL_CLM | MT_RXD1_NORMAL_CM))) {\n\t\tstatus->flag |= RX_FLAG_DECRYPTED;\n\t\tstatus->flag |= RX_FLAG_IV_STRIPPED;\n\t\tstatus->flag |= RX_FLAG_MMIC_STRIPPED | RX_FLAG_MIC_STRIPPED;\n\t}\n\n\tremove_pad = FIELD_GET(MT_RXD2_NORMAL_HDR_OFFSET, rxd2);\n\n\tif (rxd2 & MT_RXD2_NORMAL_MAX_LEN_ERROR)\n\t\treturn -EINVAL;\n\n\trxd += 8;\n\tif (rxd1 & MT_RXD1_NORMAL_GROUP_4) {\n\t\tu32 v0 = le32_to_cpu(rxd[0]);\n\t\tu32 v2 = le32_to_cpu(rxd[2]);\n\n\t\tfc = cpu_to_le16(FIELD_GET(MT_RXD8_FRAME_CONTROL, v0));\n\t\tqos_ctl = FIELD_GET(MT_RXD10_QOS_CTL, v2);\n\t\tseq_ctrl = FIELD_GET(MT_RXD10_SEQ_CTRL, v2);\n\n\t\trxd += 4;\n\t\tif ((u8 *)rxd - skb->data >= skb->len)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (rxd1 & MT_RXD1_NORMAL_GROUP_1) {\n\t\tu8 *data = (u8 *)rxd;\n\n\t\tif (status->flag & RX_FLAG_DECRYPTED) {\n\t\t\tswitch (FIELD_GET(MT_RXD2_NORMAL_SEC_MODE, rxd2)) {\n\t\t\tcase MT_CIPHER_AES_CCMP:\n\t\t\tcase MT_CIPHER_CCMP_CCX:\n\t\t\tcase MT_CIPHER_CCMP_256:\n\t\t\t\tinsert_ccmp_hdr =\n\t\t\t\t\tFIELD_GET(MT_RXD2_NORMAL_FRAG, rxd2);\n\t\t\t\tfallthrough;\n\t\t\tcase MT_CIPHER_TKIP:\n\t\t\tcase MT_CIPHER_TKIP_NO_MIC:\n\t\t\tcase MT_CIPHER_GCMP:\n\t\t\tcase MT_CIPHER_GCMP_256:\n\t\t\t\tstatus->iv[0] = data[5];\n\t\t\t\tstatus->iv[1] = data[4];\n\t\t\t\tstatus->iv[2] = data[3];\n\t\t\t\tstatus->iv[3] = data[2];\n\t\t\t\tstatus->iv[4] = data[1];\n\t\t\t\tstatus->iv[5] = data[0];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trxd += 4;\n\t\tif ((u8 *)rxd - skb->data >= skb->len)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (rxd1 & MT_RXD1_NORMAL_GROUP_2) {\n\t\tstatus->timestamp = le32_to_cpu(rxd[0]);\n\t\tstatus->flag |= RX_FLAG_MACTIME_START;\n\n\t\tif (!(rxd2 & MT_RXD2_NORMAL_NON_AMPDU)) {\n\t\t\tstatus->flag |= RX_FLAG_AMPDU_DETAILS;\n\n\t\t\t \n\t\t\tif (phy->rx_ampdu_ts != status->timestamp) {\n\t\t\t\tif (!++phy->ampdu_ref)\n\t\t\t\t\tphy->ampdu_ref++;\n\t\t\t}\n\t\t\tphy->rx_ampdu_ts = status->timestamp;\n\n\t\t\tstatus->ampdu_ref = phy->ampdu_ref;\n\t\t}\n\n\t\trxd += 4;\n\t\tif ((u8 *)rxd - skb->data >= skb->len)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (rxd1 & MT_RXD1_NORMAL_GROUP_3) {\n\t\tu32 v3;\n\t\tint ret;\n\n\t\trxv = rxd;\n\t\trxd += 4;\n\t\tif ((u8 *)rxd - skb->data >= skb->len)\n\t\t\treturn -EINVAL;\n\n\t\tv3 = le32_to_cpu(rxv[3]);\n\n\t\tstatus->chains = mphy->antenna_mask;\n\t\tstatus->chain_signal[0] = to_rssi(MT_PRXV_RCPI0, v3);\n\t\tstatus->chain_signal[1] = to_rssi(MT_PRXV_RCPI1, v3);\n\t\tstatus->chain_signal[2] = to_rssi(MT_PRXV_RCPI2, v3);\n\t\tstatus->chain_signal[3] = to_rssi(MT_PRXV_RCPI3, v3);\n\n\t\t \n\t\tif (rxd1 & MT_RXD1_NORMAL_GROUP_5) {\n\t\t\trxd += 24;\n\t\t\tif ((u8 *)rxd - skb->data >= skb->len)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = mt7996_mac_fill_rx_rate(dev, status, sband, rxv, &mode);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tamsdu_info = FIELD_GET(MT_RXD4_NORMAL_PAYLOAD_FORMAT, rxd4);\n\tstatus->amsdu = !!amsdu_info;\n\tif (status->amsdu) {\n\t\tstatus->first_amsdu = amsdu_info == MT_RXD4_FIRST_AMSDU_FRAME;\n\t\tstatus->last_amsdu = amsdu_info == MT_RXD4_LAST_AMSDU_FRAME;\n\t}\n\n\thdr_gap = (u8 *)rxd - skb->data + 2 * remove_pad;\n\tif (hdr_trans && ieee80211_has_morefrags(fc)) {\n\t\tif (mt7996_reverse_frag0_hdr_trans(skb, hdr_gap))\n\t\t\treturn -EINVAL;\n\t\thdr_trans = false;\n\t} else {\n\t\tint pad_start = 0;\n\n\t\tskb_pull(skb, hdr_gap);\n\t\tif (!hdr_trans && status->amsdu && !(ieee80211_has_a4(fc) && is_mesh)) {\n\t\t\tpad_start = ieee80211_get_hdrlen_from_skb(skb);\n\t\t} else if (hdr_trans && (rxd2 & MT_RXD2_NORMAL_HDR_TRANS_ERROR)) {\n\t\t\t \n\t\t\tpad_start = 12;\n\t\t\tif (get_unaligned_be16(skb->data + pad_start) == ETH_P_8021Q)\n\t\t\t\tpad_start += 4;\n\t\t\telse\n\t\t\t\tpad_start = 0;\n\t\t}\n\n\t\tif (pad_start) {\n\t\t\tmemmove(skb->data + 2, skb->data, pad_start);\n\t\t\tskb_pull(skb, 2);\n\t\t}\n\t}\n\n\tif (!hdr_trans) {\n\t\tstruct ieee80211_hdr *hdr;\n\n\t\tif (insert_ccmp_hdr) {\n\t\t\tu8 key_id = FIELD_GET(MT_RXD1_NORMAL_KEY_ID, rxd1);\n\n\t\t\tmt76_insert_ccmp_hdr(skb, key_id);\n\t\t}\n\n\t\thdr = mt76_skb_get_hdr(skb);\n\t\tfc = hdr->frame_control;\n\t\tif (ieee80211_is_data_qos(fc)) {\n\t\t\tu8 *qos = ieee80211_get_qos_ctl(hdr);\n\n\t\t\tseq_ctrl = le16_to_cpu(hdr->seq_ctrl);\n\t\t\tqos_ctl = *qos;\n\n\t\t\t \n\t\t\tif (ieee80211_has_a4(fc) && is_mesh && status->amsdu)\n\t\t\t\t*qos &= ~IEEE80211_QOS_CTL_A_MSDU_PRESENT;\n\t\t}\n\t} else {\n\t\tstatus->flag |= RX_FLAG_8023;\n\t}\n\n\tif (rxv && mode >= MT_PHY_TYPE_HE_SU && !(status->flag & RX_FLAG_8023))\n\t\tmt76_connac3_mac_decode_he_radiotap(skb, rxv, mode);\n\n\tif (!status->wcid || !ieee80211_is_data_qos(fc))\n\t\treturn 0;\n\n\tstatus->aggr = unicast &&\n\t\t       !ieee80211_is_qos_nullfunc(fc);\n\tstatus->qos_ctl = qos_ctl;\n\tstatus->seqno = IEEE80211_SEQ_TO_SN(seq_ctrl);\n\n\treturn 0;\n}\n\nstatic void\nmt7996_mac_write_txwi_8023(struct mt7996_dev *dev, __le32 *txwi,\n\t\t\t   struct sk_buff *skb, struct mt76_wcid *wcid)\n{\n\tu8 tid = skb->priority & IEEE80211_QOS_CTL_TID_MASK;\n\tu8 fc_type, fc_stype;\n\tu16 ethertype;\n\tbool wmm = false;\n\tu32 val;\n\n\tif (wcid->sta) {\n\t\tstruct ieee80211_sta *sta;\n\n\t\tsta = container_of((void *)wcid, struct ieee80211_sta, drv_priv);\n\t\twmm = sta->wme;\n\t}\n\n\tval = FIELD_PREP(MT_TXD1_HDR_FORMAT, MT_HDR_FORMAT_802_3) |\n\t      FIELD_PREP(MT_TXD1_TID, tid);\n\n\tethertype = get_unaligned_be16(&skb->data[12]);\n\tif (ethertype >= ETH_P_802_3_MIN)\n\t\tval |= MT_TXD1_ETH_802_3;\n\n\ttxwi[1] |= cpu_to_le32(val);\n\n\tfc_type = IEEE80211_FTYPE_DATA >> 2;\n\tfc_stype = wmm ? IEEE80211_STYPE_QOS_DATA >> 4 : 0;\n\n\tval = FIELD_PREP(MT_TXD2_FRAME_TYPE, fc_type) |\n\t      FIELD_PREP(MT_TXD2_SUB_TYPE, fc_stype);\n\n\ttxwi[2] |= cpu_to_le32(val);\n}\n\nstatic void\nmt7996_mac_write_txwi_80211(struct mt7996_dev *dev, __le32 *txwi,\n\t\t\t    struct sk_buff *skb, struct ieee80211_key_conf *key)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tbool multicast = is_multicast_ether_addr(hdr->addr1);\n\tu8 tid = skb->priority & IEEE80211_QOS_CTL_TID_MASK;\n\t__le16 fc = hdr->frame_control;\n\tu8 fc_type, fc_stype;\n\tu32 val;\n\n\tif (ieee80211_is_action(fc) &&\n\t    mgmt->u.action.category == WLAN_CATEGORY_BACK &&\n\t    mgmt->u.action.u.addba_req.action_code == WLAN_ACTION_ADDBA_REQ)\n\t\ttid = MT_TX_ADDBA;\n\telse if (ieee80211_is_mgmt(hdr->frame_control))\n\t\ttid = MT_TX_NORMAL;\n\n\tval = FIELD_PREP(MT_TXD1_HDR_FORMAT, MT_HDR_FORMAT_802_11) |\n\t      FIELD_PREP(MT_TXD1_HDR_INFO,\n\t\t\t ieee80211_get_hdrlen_from_skb(skb) / 2) |\n\t      FIELD_PREP(MT_TXD1_TID, tid);\n\n\tif (!ieee80211_is_data(fc) || multicast ||\n\t    info->flags & IEEE80211_TX_CTL_USE_MINRATE)\n\t\tval |= MT_TXD1_FIXED_RATE;\n\n\tif (key && multicast && ieee80211_is_robust_mgmt_frame(skb) &&\n\t    key->cipher == WLAN_CIPHER_SUITE_AES_CMAC) {\n\t\tval |= MT_TXD1_BIP;\n\t\ttxwi[3] &= ~cpu_to_le32(MT_TXD3_PROTECT_FRAME);\n\t}\n\n\ttxwi[1] |= cpu_to_le32(val);\n\n\tfc_type = (le16_to_cpu(fc) & IEEE80211_FCTL_FTYPE) >> 2;\n\tfc_stype = (le16_to_cpu(fc) & IEEE80211_FCTL_STYPE) >> 4;\n\n\tval = FIELD_PREP(MT_TXD2_FRAME_TYPE, fc_type) |\n\t      FIELD_PREP(MT_TXD2_SUB_TYPE, fc_stype);\n\n\ttxwi[2] |= cpu_to_le32(val);\n\n\ttxwi[3] |= cpu_to_le32(FIELD_PREP(MT_TXD3_BCM, multicast));\n\tif (ieee80211_is_beacon(fc)) {\n\t\ttxwi[3] &= ~cpu_to_le32(MT_TXD3_SW_POWER_MGMT);\n\t\ttxwi[3] |= cpu_to_le32(MT_TXD3_REM_TX_COUNT);\n\t}\n\n\tif (info->flags & IEEE80211_TX_CTL_INJECTED) {\n\t\tu16 seqno = le16_to_cpu(hdr->seq_ctrl);\n\n\t\tif (ieee80211_is_back_req(hdr->frame_control)) {\n\t\t\tstruct ieee80211_bar *bar;\n\n\t\t\tbar = (struct ieee80211_bar *)skb->data;\n\t\t\tseqno = le16_to_cpu(bar->start_seq_num);\n\t\t}\n\n\t\tval = MT_TXD3_SN_VALID |\n\t\t      FIELD_PREP(MT_TXD3_SEQ, IEEE80211_SEQ_TO_SN(seqno));\n\t\ttxwi[3] |= cpu_to_le32(val);\n\t\ttxwi[3] &= ~cpu_to_le32(MT_TXD3_HW_AMSDU);\n\t}\n}\n\nvoid mt7996_mac_write_txwi(struct mt7996_dev *dev, __le32 *txwi,\n\t\t\t   struct sk_buff *skb, struct mt76_wcid *wcid,\n\t\t\t   struct ieee80211_key_conf *key, int pid,\n\t\t\t   enum mt76_txq_id qid, u32 changed)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_vif *vif = info->control.vif;\n\tu8 band_idx = (info->hw_queue & MT_TX_HW_QUEUE_PHY) >> 2;\n\tu8 p_fmt, q_idx, omac_idx = 0, wmm_idx = 0;\n\tbool is_8023 = info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP;\n\tstruct mt76_vif *mvif;\n\tu16 tx_count = 15;\n\tu32 val;\n\tbool inband_disc = !!(changed & (BSS_CHANGED_UNSOL_BCAST_PROBE_RESP |\n\t\t\t\t\t BSS_CHANGED_FILS_DISCOVERY));\n\tbool beacon = !!(changed & (BSS_CHANGED_BEACON |\n\t\t\t\t    BSS_CHANGED_BEACON_ENABLED)) && (!inband_disc);\n\n\tmvif = vif ? (struct mt76_vif *)vif->drv_priv : NULL;\n\tif (mvif) {\n\t\tomac_idx = mvif->omac_idx;\n\t\twmm_idx = mvif->wmm_idx;\n\t\tband_idx = mvif->band_idx;\n\t}\n\n\tif (inband_disc) {\n\t\tp_fmt = MT_TX_TYPE_FW;\n\t\tq_idx = MT_LMAC_ALTX0;\n\t} else if (beacon) {\n\t\tp_fmt = MT_TX_TYPE_FW;\n\t\tq_idx = MT_LMAC_BCN0;\n\t} else if (qid >= MT_TXQ_PSD) {\n\t\tp_fmt = MT_TX_TYPE_CT;\n\t\tq_idx = MT_LMAC_ALTX0;\n\t} else {\n\t\tp_fmt = MT_TX_TYPE_CT;\n\t\tq_idx = wmm_idx * MT7996_MAX_WMM_SETS +\n\t\t\tmt76_connac_lmac_mapping(skb_get_queue_mapping(skb));\n\t}\n\n\tval = FIELD_PREP(MT_TXD0_TX_BYTES, skb->len + MT_TXD_SIZE) |\n\t      FIELD_PREP(MT_TXD0_PKT_FMT, p_fmt) |\n\t      FIELD_PREP(MT_TXD0_Q_IDX, q_idx);\n\ttxwi[0] = cpu_to_le32(val);\n\n\tval = FIELD_PREP(MT_TXD1_WLAN_IDX, wcid->idx) |\n\t      FIELD_PREP(MT_TXD1_OWN_MAC, omac_idx);\n\n\tif (band_idx)\n\t\tval |= FIELD_PREP(MT_TXD1_TGID, band_idx);\n\n\ttxwi[1] = cpu_to_le32(val);\n\ttxwi[2] = 0;\n\n\tval = MT_TXD3_SW_POWER_MGMT |\n\t      FIELD_PREP(MT_TXD3_REM_TX_COUNT, tx_count);\n\tif (key)\n\t\tval |= MT_TXD3_PROTECT_FRAME;\n\tif (info->flags & IEEE80211_TX_CTL_NO_ACK)\n\t\tval |= MT_TXD3_NO_ACK;\n\tif (wcid->amsdu)\n\t\tval |= MT_TXD3_HW_AMSDU;\n\n\ttxwi[3] = cpu_to_le32(val);\n\ttxwi[4] = 0;\n\n\tval = FIELD_PREP(MT_TXD5_PID, pid);\n\tif (pid >= MT_PACKET_ID_FIRST)\n\t\tval |= MT_TXD5_TX_STATUS_HOST;\n\ttxwi[5] = cpu_to_le32(val);\n\n\tval = MT_TXD6_DIS_MAT | MT_TXD6_DAS |\n\t      FIELD_PREP(MT_TXD6_MSDU_CNT, 1);\n\ttxwi[6] = cpu_to_le32(val);\n\ttxwi[7] = 0;\n\n\tif (is_8023)\n\t\tmt7996_mac_write_txwi_8023(dev, txwi, skb, wcid);\n\telse\n\t\tmt7996_mac_write_txwi_80211(dev, txwi, skb, key);\n\n\tif (txwi[1] & cpu_to_le32(MT_TXD1_FIXED_RATE)) {\n\t\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\t\tbool mcast = ieee80211_is_data(hdr->frame_control) &&\n\t\t\t     is_multicast_ether_addr(hdr->addr1);\n\t\tu8 idx = MT7996_BASIC_RATES_TBL;\n\n\t\tif (mvif) {\n\t\t\tif (mcast && mvif->mcast_rates_idx)\n\t\t\t\tidx = mvif->mcast_rates_idx;\n\t\t\telse if (beacon && mvif->beacon_rates_idx)\n\t\t\t\tidx = mvif->beacon_rates_idx;\n\t\t\telse\n\t\t\t\tidx = mvif->basic_rates_idx;\n\t\t}\n\n\t\ttxwi[6] |= cpu_to_le32(FIELD_PREP(MT_TXD6_TX_RATE, idx));\n\t\ttxwi[3] |= cpu_to_le32(MT_TXD3_BA_DISABLE);\n\t}\n}\n\nint mt7996_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,\n\t\t\t  enum mt76_txq_id qid, struct mt76_wcid *wcid,\n\t\t\t  struct ieee80211_sta *sta,\n\t\t\t  struct mt76_tx_info *tx_info)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx_info->skb->data;\n\tstruct mt7996_dev *dev = container_of(mdev, struct mt7996_dev, mt76);\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx_info->skb);\n\tstruct ieee80211_key_conf *key = info->control.hw_key;\n\tstruct ieee80211_vif *vif = info->control.vif;\n\tstruct mt76_connac_txp_common *txp;\n\tstruct mt76_txwi_cache *t;\n\tint id, i, pid, nbuf = tx_info->nbuf - 1;\n\tbool is_8023 = info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP;\n\tu8 *txwi = (u8 *)txwi_ptr;\n\n\tif (unlikely(tx_info->skb->len <= ETH_HLEN))\n\t\treturn -EINVAL;\n\n\tif (!wcid)\n\t\twcid = &dev->mt76.global_wcid;\n\n\tif (sta) {\n\t\tstruct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;\n\n\t\tif (time_after(jiffies, msta->jiffies + HZ / 4)) {\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;\n\t\t\tmsta->jiffies = jiffies;\n\t\t}\n\t}\n\n\tt = (struct mt76_txwi_cache *)(txwi + mdev->drv->txwi_size);\n\tt->skb = tx_info->skb;\n\n\tid = mt76_token_consume(mdev, &t);\n\tif (id < 0)\n\t\treturn id;\n\n\tpid = mt76_tx_status_skb_add(mdev, wcid, tx_info->skb);\n\tmt7996_mac_write_txwi(dev, txwi_ptr, tx_info->skb, wcid, key,\n\t\t\t      pid, qid, 0);\n\n\ttxp = (struct mt76_connac_txp_common *)(txwi + MT_TXD_SIZE);\n\tfor (i = 0; i < nbuf; i++) {\n\t\ttxp->fw.buf[i] = cpu_to_le32(tx_info->buf[i + 1].addr);\n\t\ttxp->fw.len[i] = cpu_to_le16(tx_info->buf[i + 1].len);\n\t}\n\ttxp->fw.nbuf = nbuf;\n\n\ttxp->fw.flags =\n\t\tcpu_to_le16(MT_CT_INFO_FROM_HOST | MT_CT_INFO_APPLY_TXD);\n\n\tif (!key)\n\t\ttxp->fw.flags |= cpu_to_le16(MT_CT_INFO_NONE_CIPHER_FRAME);\n\n\tif (!is_8023 && ieee80211_is_mgmt(hdr->frame_control))\n\t\ttxp->fw.flags |= cpu_to_le16(MT_CT_INFO_MGMT_FRAME);\n\n\tif (vif) {\n\t\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\n\t\ttxp->fw.bss_idx = mvif->mt76.idx;\n\t}\n\n\ttxp->fw.token = cpu_to_le16(id);\n\ttxp->fw.rept_wds_wcid = cpu_to_le16(sta ? wcid->idx : 0xfff);\n\n\ttx_info->skb = NULL;\n\n\t \n\ttx_info->buf[1].len = MT_CT_PARSE_LEN;\n\ttx_info->buf[1].skip_unmap = true;\n\ttx_info->nbuf = MT_CT_DMA_BUF_NUM;\n\n\treturn 0;\n}\n\nstatic void\nmt7996_tx_check_aggr(struct ieee80211_sta *sta, __le32 *txwi)\n{\n\tstruct mt7996_sta *msta;\n\tu16 fc, tid;\n\tu32 val;\n\n\tif (!sta || !(sta->deflink.ht_cap.ht_supported || sta->deflink.he_cap.has_he))\n\t\treturn;\n\n\ttid = le32_get_bits(txwi[1], MT_TXD1_TID);\n\tif (tid >= 6)  \n\t\treturn;\n\n\tval = le32_to_cpu(txwi[2]);\n\tfc = FIELD_GET(MT_TXD2_FRAME_TYPE, val) << 2 |\n\t     FIELD_GET(MT_TXD2_SUB_TYPE, val) << 4;\n\tif (unlikely(fc != (IEEE80211_FTYPE_DATA | IEEE80211_STYPE_QOS_DATA)))\n\t\treturn;\n\n\tmsta = (struct mt7996_sta *)sta->drv_priv;\n\tif (!test_and_set_bit(tid, &msta->wcid.ampdu_state))\n\t\tieee80211_start_tx_ba_session(sta, tid, 0);\n}\n\nstatic void\nmt7996_txwi_free(struct mt7996_dev *dev, struct mt76_txwi_cache *t,\n\t\t struct ieee80211_sta *sta, struct list_head *free_list)\n{\n\tstruct mt76_dev *mdev = &dev->mt76;\n\tstruct mt76_wcid *wcid;\n\t__le32 *txwi;\n\tu16 wcid_idx;\n\n\tmt76_connac_txp_skb_unmap(mdev, t);\n\tif (!t->skb)\n\t\tgoto out;\n\n\ttxwi = (__le32 *)mt76_get_txwi_ptr(mdev, t);\n\tif (sta) {\n\t\twcid = (struct mt76_wcid *)sta->drv_priv;\n\t\twcid_idx = wcid->idx;\n\n\t\tif (likely(t->skb->protocol != cpu_to_be16(ETH_P_PAE)))\n\t\t\tmt7996_tx_check_aggr(sta, txwi);\n\t} else {\n\t\twcid_idx = le32_get_bits(txwi[9], MT_TXD9_WLAN_IDX);\n\t}\n\n\t__mt76_tx_complete_skb(mdev, wcid_idx, t->skb, free_list);\n\nout:\n\tt->skb = NULL;\n\tmt76_put_txwi(mdev, t);\n}\n\nstatic void\nmt7996_mac_tx_free(struct mt7996_dev *dev, void *data, int len)\n{\n\t__le32 *tx_free = (__le32 *)data, *cur_info;\n\tstruct mt76_dev *mdev = &dev->mt76;\n\tstruct mt76_phy *phy2 = mdev->phys[MT_BAND1];\n\tstruct mt76_phy *phy3 = mdev->phys[MT_BAND2];\n\tstruct mt76_txwi_cache *txwi;\n\tstruct ieee80211_sta *sta = NULL;\n\tLIST_HEAD(free_list);\n\tstruct sk_buff *skb, *tmp;\n\tvoid *end = data + len;\n\tbool wake = false;\n\tu16 total, count = 0;\n\n\t \n\tmt76_queue_tx_cleanup(dev, dev->mphy.q_tx[MT_TXQ_PSD], false);\n\tmt76_queue_tx_cleanup(dev, dev->mphy.q_tx[MT_TXQ_BE], false);\n\tif (phy2) {\n\t\tmt76_queue_tx_cleanup(dev, phy2->q_tx[MT_TXQ_PSD], false);\n\t\tmt76_queue_tx_cleanup(dev, phy2->q_tx[MT_TXQ_BE], false);\n\t}\n\tif (phy3) {\n\t\tmt76_queue_tx_cleanup(dev, phy3->q_tx[MT_TXQ_PSD], false);\n\t\tmt76_queue_tx_cleanup(dev, phy3->q_tx[MT_TXQ_BE], false);\n\t}\n\n\tif (WARN_ON_ONCE(le32_get_bits(tx_free[1], MT_TXFREE1_VER) < 4))\n\t\treturn;\n\n\ttotal = le32_get_bits(tx_free[0], MT_TXFREE0_MSDU_CNT);\n\tfor (cur_info = &tx_free[2]; count < total; cur_info++) {\n\t\tu32 msdu, info;\n\t\tu8 i;\n\n\t\tif (WARN_ON_ONCE((void *)cur_info >= end))\n\t\t\treturn;\n\t\t \n\t\tinfo = le32_to_cpu(*cur_info);\n\t\tif (info & MT_TXFREE_INFO_PAIR) {\n\t\t\tstruct mt7996_sta *msta;\n\t\t\tstruct mt76_wcid *wcid;\n\t\t\tu16 idx;\n\n\t\t\tidx = FIELD_GET(MT_TXFREE_INFO_WLAN_ID, info);\n\t\t\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n\t\t\tsta = wcid_to_sta(wcid);\n\t\t\tif (!sta)\n\t\t\t\tcontinue;\n\n\t\t\tmsta = container_of(wcid, struct mt7996_sta, wcid);\n\t\t\tspin_lock_bh(&mdev->sta_poll_lock);\n\t\t\tif (list_empty(&msta->wcid.poll_list))\n\t\t\t\tlist_add_tail(&msta->wcid.poll_list,\n\t\t\t\t\t      &mdev->sta_poll_list);\n\t\t\tspin_unlock_bh(&mdev->sta_poll_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (info & MT_TXFREE_INFO_HEADER)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tmsdu = (info >> (15 * i)) & MT_TXFREE_INFO_MSDU_ID;\n\t\t\tif (msdu == MT_TXFREE_INFO_MSDU_ID)\n\t\t\t\tcontinue;\n\n\t\t\tcount++;\n\t\t\ttxwi = mt76_token_release(mdev, msdu, &wake);\n\t\t\tif (!txwi)\n\t\t\t\tcontinue;\n\n\t\t\tmt7996_txwi_free(dev, txwi, sta, &free_list);\n\t\t}\n\t}\n\n\tmt7996_mac_sta_poll(dev);\n\n\tif (wake)\n\t\tmt76_set_tx_blocked(&dev->mt76, false);\n\n\tmt76_worker_schedule(&dev->mt76.tx_worker);\n\n\tlist_for_each_entry_safe(skb, tmp, &free_list, list) {\n\t\tskb_list_del_init(skb);\n\t\tnapi_consume_skb(skb, 1);\n\t}\n}\n\nstatic bool\nmt7996_mac_add_txs_skb(struct mt7996_dev *dev, struct mt76_wcid *wcid,\n\t\t       int pid, __le32 *txs_data)\n{\n\tstruct mt76_sta_stats *stats = &wcid->stats;\n\tstruct ieee80211_supported_band *sband;\n\tstruct mt76_dev *mdev = &dev->mt76;\n\tstruct mt76_phy *mphy;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff_head list;\n\tstruct rate_info rate = {};\n\tstruct sk_buff *skb;\n\tbool cck = false;\n\tu32 txrate, txs, mode, stbc;\n\n\tmt76_tx_status_lock(mdev, &list);\n\tskb = mt76_tx_status_skb_get(mdev, wcid, pid, &list);\n\tif (!skb)\n\t\tgoto out_no_skb;\n\n\ttxs = le32_to_cpu(txs_data[0]);\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tif (!(txs & MT_TXS0_ACK_ERROR_MASK))\n\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\n\tinfo->status.ampdu_len = 1;\n\tinfo->status.ampdu_ack_len = !!(info->flags &\n\t\t\t\t\tIEEE80211_TX_STAT_ACK);\n\n\tinfo->status.rates[0].idx = -1;\n\n\ttxrate = FIELD_GET(MT_TXS0_TX_RATE, txs);\n\n\trate.mcs = FIELD_GET(MT_TX_RATE_IDX, txrate);\n\trate.nss = FIELD_GET(MT_TX_RATE_NSS, txrate) + 1;\n\tstbc = le32_get_bits(txs_data[3], MT_TXS3_RATE_STBC);\n\n\tif (stbc && rate.nss > 1)\n\t\trate.nss >>= 1;\n\n\tif (rate.nss - 1 < ARRAY_SIZE(stats->tx_nss))\n\t\tstats->tx_nss[rate.nss - 1]++;\n\tif (rate.mcs < ARRAY_SIZE(stats->tx_mcs))\n\t\tstats->tx_mcs[rate.mcs]++;\n\n\tmode = FIELD_GET(MT_TX_RATE_MODE, txrate);\n\tswitch (mode) {\n\tcase MT_PHY_TYPE_CCK:\n\t\tcck = true;\n\t\tfallthrough;\n\tcase MT_PHY_TYPE_OFDM:\n\t\tmphy = mt76_dev_phy(mdev, wcid->phy_idx);\n\n\t\tif (mphy->chandef.chan->band == NL80211_BAND_5GHZ)\n\t\t\tsband = &mphy->sband_5g.sband;\n\t\telse if (mphy->chandef.chan->band == NL80211_BAND_6GHZ)\n\t\t\tsband = &mphy->sband_6g.sband;\n\t\telse\n\t\t\tsband = &mphy->sband_2g.sband;\n\n\t\trate.mcs = mt76_get_rate(mphy->dev, sband, rate.mcs, cck);\n\t\trate.legacy = sband->bitrates[rate.mcs].bitrate;\n\t\tbreak;\n\tcase MT_PHY_TYPE_HT:\n\tcase MT_PHY_TYPE_HT_GF:\n\t\tif (rate.mcs > 31)\n\t\t\tgoto out;\n\n\t\trate.flags = RATE_INFO_FLAGS_MCS;\n\t\tif (wcid->rate.flags & RATE_INFO_FLAGS_SHORT_GI)\n\t\t\trate.flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t\tbreak;\n\tcase MT_PHY_TYPE_VHT:\n\t\tif (rate.mcs > 9)\n\t\t\tgoto out;\n\n\t\trate.flags = RATE_INFO_FLAGS_VHT_MCS;\n\t\tbreak;\n\tcase MT_PHY_TYPE_HE_SU:\n\tcase MT_PHY_TYPE_HE_EXT_SU:\n\tcase MT_PHY_TYPE_HE_TB:\n\tcase MT_PHY_TYPE_HE_MU:\n\t\tif (rate.mcs > 11)\n\t\t\tgoto out;\n\n\t\trate.he_gi = wcid->rate.he_gi;\n\t\trate.he_dcm = FIELD_GET(MT_TX_RATE_DCM, txrate);\n\t\trate.flags = RATE_INFO_FLAGS_HE_MCS;\n\t\tbreak;\n\tcase MT_PHY_TYPE_EHT_SU:\n\tcase MT_PHY_TYPE_EHT_TRIG:\n\tcase MT_PHY_TYPE_EHT_MU:\n\t\tif (rate.mcs > 13)\n\t\t\tgoto out;\n\n\t\trate.eht_gi = wcid->rate.eht_gi;\n\t\trate.flags = RATE_INFO_FLAGS_EHT_MCS;\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tstats->tx_mode[mode]++;\n\n\tswitch (FIELD_GET(MT_TXS0_BW, txs)) {\n\tcase IEEE80211_STA_RX_BW_320:\n\t\trate.bw = RATE_INFO_BW_320;\n\t\tstats->tx_bw[4]++;\n\t\tbreak;\n\tcase IEEE80211_STA_RX_BW_160:\n\t\trate.bw = RATE_INFO_BW_160;\n\t\tstats->tx_bw[3]++;\n\t\tbreak;\n\tcase IEEE80211_STA_RX_BW_80:\n\t\trate.bw = RATE_INFO_BW_80;\n\t\tstats->tx_bw[2]++;\n\t\tbreak;\n\tcase IEEE80211_STA_RX_BW_40:\n\t\trate.bw = RATE_INFO_BW_40;\n\t\tstats->tx_bw[1]++;\n\t\tbreak;\n\tdefault:\n\t\trate.bw = RATE_INFO_BW_20;\n\t\tstats->tx_bw[0]++;\n\t\tbreak;\n\t}\n\twcid->rate = rate;\n\nout:\n\tmt76_tx_status_skb_done(mdev, skb, &list);\n\nout_no_skb:\n\tmt76_tx_status_unlock(mdev, &list);\n\n\treturn !!skb;\n}\n\nstatic void mt7996_mac_add_txs(struct mt7996_dev *dev, void *data)\n{\n\tstruct mt7996_sta *msta = NULL;\n\tstruct mt76_wcid *wcid;\n\t__le32 *txs_data = data;\n\tu16 wcidx;\n\tu8 pid;\n\n\tif (le32_get_bits(txs_data[0], MT_TXS0_TXS_FORMAT) > 1)\n\t\treturn;\n\n\twcidx = le32_get_bits(txs_data[2], MT_TXS2_WCID);\n\tpid = le32_get_bits(txs_data[3], MT_TXS3_PID);\n\n\tif (pid < MT_PACKET_ID_FIRST)\n\t\treturn;\n\n\tif (wcidx >= mt7996_wtbl_size(dev))\n\t\treturn;\n\n\trcu_read_lock();\n\n\twcid = rcu_dereference(dev->mt76.wcid[wcidx]);\n\tif (!wcid)\n\t\tgoto out;\n\n\tmsta = container_of(wcid, struct mt7996_sta, wcid);\n\n\tmt7996_mac_add_txs_skb(dev, wcid, pid, txs_data);\n\n\tif (!wcid->sta)\n\t\tgoto out;\n\n\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\tif (list_empty(&msta->wcid.poll_list))\n\t\tlist_add_tail(&msta->wcid.poll_list, &dev->mt76.sta_poll_list);\n\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\nout:\n\trcu_read_unlock();\n}\n\nbool mt7996_rx_check(struct mt76_dev *mdev, void *data, int len)\n{\n\tstruct mt7996_dev *dev = container_of(mdev, struct mt7996_dev, mt76);\n\t__le32 *rxd = (__le32 *)data;\n\t__le32 *end = (__le32 *)&rxd[len / 4];\n\tenum rx_pkt_type type;\n\n\ttype = le32_get_bits(rxd[0], MT_RXD0_PKT_TYPE);\n\tif (type != PKT_TYPE_NORMAL) {\n\t\tu32 sw_type = le32_get_bits(rxd[0], MT_RXD0_SW_PKT_TYPE_MASK);\n\n\t\tif (unlikely((sw_type & MT_RXD0_SW_PKT_TYPE_MAP) ==\n\t\t\t     MT_RXD0_SW_PKT_TYPE_FRAME))\n\t\t\treturn true;\n\t}\n\n\tswitch (type) {\n\tcase PKT_TYPE_TXRX_NOTIFY:\n\t\tmt7996_mac_tx_free(dev, data, len);\n\t\treturn false;\n\tcase PKT_TYPE_TXS:\n\t\tfor (rxd += 4; rxd + 8 <= end; rxd += 8)\n\t\t\tmt7996_mac_add_txs(dev, rxd);\n\t\treturn false;\n\tcase PKT_TYPE_RX_FW_MONITOR:\n\t\tmt7996_debugfs_rx_fw_monitor(dev, data, len);\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nvoid mt7996_queue_rx_skb(struct mt76_dev *mdev, enum mt76_rxq_id q,\n\t\t\t struct sk_buff *skb, u32 *info)\n{\n\tstruct mt7996_dev *dev = container_of(mdev, struct mt7996_dev, mt76);\n\t__le32 *rxd = (__le32 *)skb->data;\n\t__le32 *end = (__le32 *)&skb->data[skb->len];\n\tenum rx_pkt_type type;\n\n\ttype = le32_get_bits(rxd[0], MT_RXD0_PKT_TYPE);\n\tif (type != PKT_TYPE_NORMAL) {\n\t\tu32 sw_type = le32_get_bits(rxd[0], MT_RXD0_SW_PKT_TYPE_MASK);\n\n\t\tif (unlikely((sw_type & MT_RXD0_SW_PKT_TYPE_MAP) ==\n\t\t\t     MT_RXD0_SW_PKT_TYPE_FRAME))\n\t\t\ttype = PKT_TYPE_NORMAL;\n\t}\n\n\tswitch (type) {\n\tcase PKT_TYPE_TXRX_NOTIFY:\n\t\tmt7996_mac_tx_free(dev, skb->data, skb->len);\n\t\tnapi_consume_skb(skb, 1);\n\t\tbreak;\n\tcase PKT_TYPE_RX_EVENT:\n\t\tmt7996_mcu_rx_event(dev, skb);\n\t\tbreak;\n\tcase PKT_TYPE_TXS:\n\t\tfor (rxd += 4; rxd + 8 <= end; rxd += 8)\n\t\t\tmt7996_mac_add_txs(dev, rxd);\n\t\tdev_kfree_skb(skb);\n\t\tbreak;\n\tcase PKT_TYPE_RX_FW_MONITOR:\n\t\tmt7996_debugfs_rx_fw_monitor(dev, skb->data, skb->len);\n\t\tdev_kfree_skb(skb);\n\t\tbreak;\n\tcase PKT_TYPE_NORMAL:\n\t\tif (!mt7996_mac_fill_rx(dev, skb)) {\n\t\t\tmt76_rx(&dev->mt76, q, skb);\n\t\t\treturn;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdev_kfree_skb(skb);\n\t\tbreak;\n\t}\n}\n\nvoid mt7996_mac_cca_stats_reset(struct mt7996_phy *phy)\n{\n\tstruct mt7996_dev *dev = phy->dev;\n\tu32 reg = MT_WF_PHYRX_BAND_RX_CTRL1(phy->mt76->band_idx);\n\n\tmt76_clear(dev, reg, MT_WF_PHYRX_BAND_RX_CTRL1_STSCNT_EN);\n\tmt76_set(dev, reg, BIT(11) | BIT(9));\n}\n\nvoid mt7996_mac_reset_counters(struct mt7996_phy *phy)\n{\n\tstruct mt7996_dev *dev = phy->dev;\n\tu8 band_idx = phy->mt76->band_idx;\n\tint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tmt76_rr(dev, MT_TX_AGG_CNT(band_idx, i));\n\n\tphy->mt76->survey_time = ktime_get_boottime();\n\n\tmemset(phy->mt76->aggr_stats, 0, sizeof(phy->mt76->aggr_stats));\n\n\t \n\tmt76_set(dev, MT_WF_RMAC_MIB_AIRTIME0(band_idx),\n\t\t MT_WF_RMAC_MIB_RXTIME_CLR);\n\n\tmt7996_mcu_get_chan_mib_info(phy, true);\n}\n\nvoid mt7996_mac_set_coverage_class(struct mt7996_phy *phy)\n{\n\ts16 coverage_class = phy->coverage_class;\n\tstruct mt7996_dev *dev = phy->dev;\n\tstruct mt7996_phy *phy2 = mt7996_phy2(dev);\n\tstruct mt7996_phy *phy3 = mt7996_phy3(dev);\n\tu32 reg_offset;\n\tu32 cck = FIELD_PREP(MT_TIMEOUT_VAL_PLCP, 231) |\n\t\t  FIELD_PREP(MT_TIMEOUT_VAL_CCA, 48);\n\tu32 ofdm = FIELD_PREP(MT_TIMEOUT_VAL_PLCP, 60) |\n\t\t   FIELD_PREP(MT_TIMEOUT_VAL_CCA, 28);\n\tu8 band_idx = phy->mt76->band_idx;\n\tint offset;\n\n\tif (!test_bit(MT76_STATE_RUNNING, &phy->mt76->state))\n\t\treturn;\n\n\tif (phy2)\n\t\tcoverage_class = max_t(s16, dev->phy.coverage_class,\n\t\t\t\t       phy2->coverage_class);\n\n\tif (phy3)\n\t\tcoverage_class = max_t(s16, coverage_class,\n\t\t\t\t       phy3->coverage_class);\n\n\toffset = 3 * coverage_class;\n\treg_offset = FIELD_PREP(MT_TIMEOUT_VAL_PLCP, offset) |\n\t\t     FIELD_PREP(MT_TIMEOUT_VAL_CCA, offset);\n\n\tmt76_wr(dev, MT_TMAC_CDTR(band_idx), cck + reg_offset);\n\tmt76_wr(dev, MT_TMAC_ODTR(band_idx), ofdm + reg_offset);\n}\n\nvoid mt7996_mac_enable_nf(struct mt7996_dev *dev, u8 band)\n{\n\tmt76_set(dev, MT_WF_PHYRX_CSD_BAND_RXTD12(band),\n\t\t MT_WF_PHYRX_CSD_BAND_RXTD12_IRPI_SW_CLR_ONLY |\n\t\t MT_WF_PHYRX_CSD_BAND_RXTD12_IRPI_SW_CLR);\n\n\tmt76_set(dev, MT_WF_PHYRX_BAND_RX_CTRL1(band),\n\t\t FIELD_PREP(MT_WF_PHYRX_BAND_RX_CTRL1_IPI_EN, 0x5));\n}\n\nstatic u8\nmt7996_phy_get_nf(struct mt7996_phy *phy, u8 band_idx)\n{\n\tstatic const u8 nf_power[] = { 92, 89, 86, 83, 80, 75, 70, 65, 60, 55, 52 };\n\tstruct mt7996_dev *dev = phy->dev;\n\tu32 val, sum = 0, n = 0;\n\tint ant, i;\n\n\tfor (ant = 0; ant < hweight8(phy->mt76->antenna_mask); ant++) {\n\t\tu32 reg = MT_WF_PHYRX_CSD_IRPI(band_idx, ant);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(nf_power); i++, reg += 4) {\n\t\t\tval = mt76_rr(dev, reg);\n\t\t\tsum += val * nf_power[i];\n\t\t\tn += val;\n\t\t}\n\t}\n\n\treturn n ? sum / n : 0;\n}\n\nvoid mt7996_update_channel(struct mt76_phy *mphy)\n{\n\tstruct mt7996_phy *phy = (struct mt7996_phy *)mphy->priv;\n\tstruct mt76_channel_state *state = mphy->chan_state;\n\tint nf;\n\n\tmt7996_mcu_get_chan_mib_info(phy, false);\n\n\tnf = mt7996_phy_get_nf(phy, mphy->band_idx);\n\tif (!phy->noise)\n\t\tphy->noise = nf << 4;\n\telse if (nf)\n\t\tphy->noise += nf - (phy->noise >> 4);\n\n\tstate->noise = -(phy->noise >> 4);\n}\n\nstatic bool\nmt7996_wait_reset_state(struct mt7996_dev *dev, u32 state)\n{\n\tbool ret;\n\n\tret = wait_event_timeout(dev->reset_wait,\n\t\t\t\t (READ_ONCE(dev->recovery.state) & state),\n\t\t\t\t MT7996_RESET_TIMEOUT);\n\n\tWARN(!ret, \"Timeout waiting for MCU reset state %x\\n\", state);\n\treturn ret;\n}\n\nstatic void\nmt7996_update_vif_beacon(void *priv, u8 *mac, struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_hw *hw = priv;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_AP:\n\t\tmt7996_mcu_add_beacon(hw, vif, vif->bss_conf.enable_beacon);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\nmt7996_update_beacons(struct mt7996_dev *dev)\n{\n\tstruct mt76_phy *phy2, *phy3;\n\n\tieee80211_iterate_active_interfaces(dev->mt76.hw,\n\t\t\t\t\t    IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\t\t\t    mt7996_update_vif_beacon, dev->mt76.hw);\n\n\tphy2 = dev->mt76.phys[MT_BAND1];\n\tif (!phy2)\n\t\treturn;\n\n\tieee80211_iterate_active_interfaces(phy2->hw,\n\t\t\t\t\t    IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\t\t\t    mt7996_update_vif_beacon, phy2->hw);\n\n\tphy3 = dev->mt76.phys[MT_BAND2];\n\tif (!phy3)\n\t\treturn;\n\n\tieee80211_iterate_active_interfaces(phy3->hw,\n\t\t\t\t\t    IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\t\t\t    mt7996_update_vif_beacon, phy3->hw);\n}\n\nvoid mt7996_tx_token_put(struct mt7996_dev *dev)\n{\n\tstruct mt76_txwi_cache *txwi;\n\tint id;\n\n\tspin_lock_bh(&dev->mt76.token_lock);\n\tidr_for_each_entry(&dev->mt76.token, txwi, id) {\n\t\tmt7996_txwi_free(dev, txwi, NULL, NULL);\n\t\tdev->mt76.token_count--;\n\t}\n\tspin_unlock_bh(&dev->mt76.token_lock);\n\tidr_destroy(&dev->mt76.token);\n}\n\nstatic int\nmt7996_mac_restart(struct mt7996_dev *dev)\n{\n\tstruct mt7996_phy *phy2, *phy3;\n\tstruct mt76_dev *mdev = &dev->mt76;\n\tint i, ret;\n\n\tphy2 = mt7996_phy2(dev);\n\tphy3 = mt7996_phy3(dev);\n\n\tif (dev->hif2) {\n\t\tmt76_wr(dev, MT_INT1_MASK_CSR, 0x0);\n\t\tmt76_wr(dev, MT_INT1_SOURCE_CSR, ~0);\n\t}\n\n\tif (dev_is_pci(mdev->dev)) {\n\t\tmt76_wr(dev, MT_PCIE_MAC_INT_ENABLE, 0x0);\n\t\tif (dev->hif2)\n\t\t\tmt76_wr(dev, MT_PCIE1_MAC_INT_ENABLE, 0x0);\n\t}\n\n\tset_bit(MT76_RESET, &dev->mphy.state);\n\tset_bit(MT76_MCU_RESET, &dev->mphy.state);\n\twake_up(&dev->mt76.mcu.wait);\n\tif (phy2) {\n\t\tset_bit(MT76_RESET, &phy2->mt76->state);\n\t\tset_bit(MT76_MCU_RESET, &phy2->mt76->state);\n\t}\n\tif (phy3) {\n\t\tset_bit(MT76_RESET, &phy3->mt76->state);\n\t\tset_bit(MT76_MCU_RESET, &phy3->mt76->state);\n\t}\n\n\t \n\tmt76_txq_schedule_all(&dev->mphy);\n\tif (phy2)\n\t\tmt76_txq_schedule_all(phy2->mt76);\n\tif (phy3)\n\t\tmt76_txq_schedule_all(phy3->mt76);\n\n\t \n\tmt76_worker_disable(&dev->mt76.tx_worker);\n\tmt76_for_each_q_rx(mdev, i) {\n\t\tif (mdev->q_rx[i].ndesc)\n\t\t\tnapi_disable(&dev->mt76.napi[i]);\n\t}\n\tnapi_disable(&dev->mt76.tx_napi);\n\n\t \n\tmt7996_tx_token_put(dev);\n\tidr_init(&dev->mt76.token);\n\n\tmt7996_dma_reset(dev, true);\n\n\tlocal_bh_disable();\n\tmt76_for_each_q_rx(mdev, i) {\n\t\tif (mdev->q_rx[i].ndesc) {\n\t\t\tnapi_enable(&dev->mt76.napi[i]);\n\t\t\tnapi_schedule(&dev->mt76.napi[i]);\n\t\t}\n\t}\n\tlocal_bh_enable();\n\tclear_bit(MT76_MCU_RESET, &dev->mphy.state);\n\tclear_bit(MT76_STATE_MCU_RUNNING, &dev->mphy.state);\n\n\tmt76_wr(dev, MT_INT_MASK_CSR, dev->mt76.mmio.irqmask);\n\tmt76_wr(dev, MT_INT_SOURCE_CSR, ~0);\n\tif (dev->hif2) {\n\t\tmt76_wr(dev, MT_INT1_MASK_CSR, dev->mt76.mmio.irqmask);\n\t\tmt76_wr(dev, MT_INT1_SOURCE_CSR, ~0);\n\t}\n\tif (dev_is_pci(mdev->dev)) {\n\t\tmt76_wr(dev, MT_PCIE_MAC_INT_ENABLE, 0xff);\n\t\tif (dev->hif2)\n\t\t\tmt76_wr(dev, MT_PCIE1_MAC_INT_ENABLE, 0xff);\n\t}\n\n\t \n\tret = mt7996_mcu_init_firmware(dev);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = mt7996_mcu_set_eeprom(dev);\n\tif (ret)\n\t\tgoto out;\n\n\tmt7996_mac_init(dev);\n\tmt7996_init_txpower(dev, &dev->mphy.sband_2g.sband);\n\tmt7996_init_txpower(dev, &dev->mphy.sband_5g.sband);\n\tmt7996_init_txpower(dev, &dev->mphy.sband_6g.sband);\n\tret = mt7996_txbf_init(dev);\n\n\tif (test_bit(MT76_STATE_RUNNING, &dev->mphy.state)) {\n\t\tret = mt7996_run(dev->mphy.hw);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (phy2 && test_bit(MT76_STATE_RUNNING, &phy2->mt76->state)) {\n\t\tret = mt7996_run(phy2->mt76->hw);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (phy3 && test_bit(MT76_STATE_RUNNING, &phy3->mt76->state)) {\n\t\tret = mt7996_run(phy3->mt76->hw);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\t \n\tclear_bit(MT76_RESET, &dev->mphy.state);\n\tif (phy2)\n\t\tclear_bit(MT76_RESET, &phy2->mt76->state);\n\tif (phy3)\n\t\tclear_bit(MT76_RESET, &phy3->mt76->state);\n\n\tlocal_bh_disable();\n\tnapi_enable(&dev->mt76.tx_napi);\n\tnapi_schedule(&dev->mt76.tx_napi);\n\tlocal_bh_enable();\n\n\tmt76_worker_enable(&dev->mt76.tx_worker);\n\treturn ret;\n}\n\nstatic void\nmt7996_mac_full_reset(struct mt7996_dev *dev)\n{\n\tstruct mt7996_phy *phy2, *phy3;\n\tint i;\n\n\tphy2 = mt7996_phy2(dev);\n\tphy3 = mt7996_phy3(dev);\n\tdev->recovery.hw_full_reset = true;\n\n\twake_up(&dev->mt76.mcu.wait);\n\tieee80211_stop_queues(mt76_hw(dev));\n\tif (phy2)\n\t\tieee80211_stop_queues(phy2->mt76->hw);\n\tif (phy3)\n\t\tieee80211_stop_queues(phy3->mt76->hw);\n\n\tcancel_delayed_work_sync(&dev->mphy.mac_work);\n\tif (phy2)\n\t\tcancel_delayed_work_sync(&phy2->mt76->mac_work);\n\tif (phy3)\n\t\tcancel_delayed_work_sync(&phy3->mt76->mac_work);\n\n\tmutex_lock(&dev->mt76.mutex);\n\tfor (i = 0; i < 10; i++) {\n\t\tif (!mt7996_mac_restart(dev))\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&dev->mt76.mutex);\n\n\tif (i == 10)\n\t\tdev_err(dev->mt76.dev, \"chip full reset failed\\n\");\n\n\tieee80211_restart_hw(mt76_hw(dev));\n\tif (phy2)\n\t\tieee80211_restart_hw(phy2->mt76->hw);\n\tif (phy3)\n\t\tieee80211_restart_hw(phy3->mt76->hw);\n\n\tieee80211_wake_queues(mt76_hw(dev));\n\tif (phy2)\n\t\tieee80211_wake_queues(phy2->mt76->hw);\n\tif (phy3)\n\t\tieee80211_wake_queues(phy3->mt76->hw);\n\n\tdev->recovery.hw_full_reset = false;\n\tieee80211_queue_delayed_work(mt76_hw(dev),\n\t\t\t\t     &dev->mphy.mac_work,\n\t\t\t\t     MT7996_WATCHDOG_TIME);\n\tif (phy2)\n\t\tieee80211_queue_delayed_work(phy2->mt76->hw,\n\t\t\t\t\t     &phy2->mt76->mac_work,\n\t\t\t\t\t     MT7996_WATCHDOG_TIME);\n\tif (phy3)\n\t\tieee80211_queue_delayed_work(phy3->mt76->hw,\n\t\t\t\t\t     &phy3->mt76->mac_work,\n\t\t\t\t\t     MT7996_WATCHDOG_TIME);\n}\n\nvoid mt7996_mac_reset_work(struct work_struct *work)\n{\n\tstruct mt7996_phy *phy2, *phy3;\n\tstruct mt7996_dev *dev;\n\tint i;\n\n\tdev = container_of(work, struct mt7996_dev, reset_work);\n\tphy2 = mt7996_phy2(dev);\n\tphy3 = mt7996_phy3(dev);\n\n\t \n\tif (dev->recovery.restart) {\n\t\t \n\t\tmt76_clear(dev, MT_WFDMA0_MCU_HOST_INT_ENA,\n\t\t\t   MT_MCU_CMD_WDT_MASK);\n\n\t\tif (READ_ONCE(dev->recovery.state) & MT_MCU_CMD_WA_WDT)\n\t\t\tdev->recovery.wa_reset_count++;\n\t\telse\n\t\t\tdev->recovery.wm_reset_count++;\n\n\t\tmt7996_mac_full_reset(dev);\n\n\t\t \n\t\tmt7996_irq_enable(dev, MT_INT_MCU_CMD);\n\t\tmt7996_irq_disable(dev, 0);\n\n\t\t \n\t\tmt76_set(dev, MT_WFDMA0_MCU_HOST_INT_ENA, MT_MCU_CMD_WDT_MASK);\n\n\t\tdev->recovery.state = MT_MCU_CMD_NORMAL_STATE;\n\t\tdev->recovery.restart = false;\n\t\treturn;\n\t}\n\n\tif (!(READ_ONCE(dev->recovery.state) & MT_MCU_CMD_STOP_DMA))\n\t\treturn;\n\n\tdev_info(dev->mt76.dev,\"\\n%s L1 SER recovery start.\",\n\t\t wiphy_name(dev->mt76.hw->wiphy));\n\tieee80211_stop_queues(mt76_hw(dev));\n\tif (phy2)\n\t\tieee80211_stop_queues(phy2->mt76->hw);\n\tif (phy3)\n\t\tieee80211_stop_queues(phy3->mt76->hw);\n\n\tset_bit(MT76_RESET, &dev->mphy.state);\n\tset_bit(MT76_MCU_RESET, &dev->mphy.state);\n\twake_up(&dev->mt76.mcu.wait);\n\tcancel_delayed_work_sync(&dev->mphy.mac_work);\n\tif (phy2) {\n\t\tset_bit(MT76_RESET, &phy2->mt76->state);\n\t\tcancel_delayed_work_sync(&phy2->mt76->mac_work);\n\t}\n\tif (phy3) {\n\t\tset_bit(MT76_RESET, &phy3->mt76->state);\n\t\tcancel_delayed_work_sync(&phy3->mt76->mac_work);\n\t}\n\tmt76_worker_disable(&dev->mt76.tx_worker);\n\tmt76_for_each_q_rx(&dev->mt76, i)\n\t\tnapi_disable(&dev->mt76.napi[i]);\n\tnapi_disable(&dev->mt76.tx_napi);\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tmt76_wr(dev, MT_MCU_INT_EVENT, MT_MCU_INT_EVENT_DMA_STOPPED);\n\n\tif (mt7996_wait_reset_state(dev, MT_MCU_CMD_RESET_DONE)) {\n\t\tmt7996_dma_reset(dev, false);\n\n\t\tmt7996_tx_token_put(dev);\n\t\tidr_init(&dev->mt76.token);\n\n\t\tmt76_wr(dev, MT_MCU_INT_EVENT, MT_MCU_INT_EVENT_DMA_INIT);\n\t\tmt7996_wait_reset_state(dev, MT_MCU_CMD_RECOVERY_DONE);\n\t}\n\n\tmt76_wr(dev, MT_MCU_INT_EVENT, MT_MCU_INT_EVENT_RESET_DONE);\n\tmt7996_wait_reset_state(dev, MT_MCU_CMD_NORMAL_STATE);\n\n\t \n\tmt7996_dma_start(dev, false);\n\n\tclear_bit(MT76_MCU_RESET, &dev->mphy.state);\n\tclear_bit(MT76_RESET, &dev->mphy.state);\n\tif (phy2)\n\t\tclear_bit(MT76_RESET, &phy2->mt76->state);\n\tif (phy3)\n\t\tclear_bit(MT76_RESET, &phy3->mt76->state);\n\n\tlocal_bh_disable();\n\tmt76_for_each_q_rx(&dev->mt76, i) {\n\t\tnapi_enable(&dev->mt76.napi[i]);\n\t\tnapi_schedule(&dev->mt76.napi[i]);\n\t}\n\tlocal_bh_enable();\n\n\ttasklet_schedule(&dev->mt76.irq_tasklet);\n\n\tmt76_worker_enable(&dev->mt76.tx_worker);\n\n\tlocal_bh_disable();\n\tnapi_enable(&dev->mt76.tx_napi);\n\tnapi_schedule(&dev->mt76.tx_napi);\n\tlocal_bh_enable();\n\n\tieee80211_wake_queues(mt76_hw(dev));\n\tif (phy2)\n\t\tieee80211_wake_queues(phy2->mt76->hw);\n\tif (phy3)\n\t\tieee80211_wake_queues(phy3->mt76->hw);\n\n\tmutex_unlock(&dev->mt76.mutex);\n\n\tmt7996_update_beacons(dev);\n\n\tieee80211_queue_delayed_work(mt76_hw(dev), &dev->mphy.mac_work,\n\t\t\t\t     MT7996_WATCHDOG_TIME);\n\tif (phy2)\n\t\tieee80211_queue_delayed_work(phy2->mt76->hw,\n\t\t\t\t\t     &phy2->mt76->mac_work,\n\t\t\t\t\t     MT7996_WATCHDOG_TIME);\n\tif (phy3)\n\t\tieee80211_queue_delayed_work(phy3->mt76->hw,\n\t\t\t\t\t     &phy3->mt76->mac_work,\n\t\t\t\t\t     MT7996_WATCHDOG_TIME);\n\tdev_info(dev->mt76.dev,\"\\n%s L1 SER recovery completed.\",\n\t\t wiphy_name(dev->mt76.hw->wiphy));\n}\n\n \nvoid mt7996_mac_dump_work(struct work_struct *work)\n{\n\tconst struct mt7996_mem_region *mem_region;\n\tstruct mt7996_crash_data *crash_data;\n\tstruct mt7996_dev *dev;\n\tstruct mt7996_mem_hdr *hdr;\n\tsize_t buf_len;\n\tint i;\n\tu32 num;\n\tu8 *buf;\n\n\tdev = container_of(work, struct mt7996_dev, dump_work);\n\n\tmutex_lock(&dev->dump_mutex);\n\n\tcrash_data = mt7996_coredump_new(dev);\n\tif (!crash_data) {\n\t\tmutex_unlock(&dev->dump_mutex);\n\t\tgoto skip_coredump;\n\t}\n\n\tmem_region = mt7996_coredump_get_mem_layout(dev, &num);\n\tif (!mem_region || !crash_data->memdump_buf_len) {\n\t\tmutex_unlock(&dev->dump_mutex);\n\t\tgoto skip_memdump;\n\t}\n\n\tbuf = crash_data->memdump_buf;\n\tbuf_len = crash_data->memdump_buf_len;\n\n\t \n\tmemset(buf, 0, buf_len);\n\tfor (i = 0; i < num; i++) {\n\t\tif (mem_region->len > buf_len) {\n\t\t\tdev_warn(dev->mt76.dev, \"%s len %zu is too large\\n\",\n\t\t\t\t mem_region->name, mem_region->len);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\thdr = (void *)buf;\n\t\tbuf += sizeof(*hdr);\n\t\tbuf_len -= sizeof(*hdr);\n\n\t\tmt7996_memcpy_fromio(dev, buf, mem_region->start,\n\t\t\t\t     mem_region->len);\n\n\t\thdr->start = mem_region->start;\n\t\thdr->len = mem_region->len;\n\n\t\tif (!mem_region->len)\n\t\t\t \n\t\t\tbreak;\n\n\t\tbuf += mem_region->len;\n\t\tbuf_len -= mem_region->len;\n\n\t\tmem_region++;\n\t}\n\n\tmutex_unlock(&dev->dump_mutex);\n\nskip_memdump:\n\tmt7996_coredump_submit(dev);\nskip_coredump:\n\tqueue_work(dev->mt76.wq, &dev->reset_work);\n}\n\nvoid mt7996_reset(struct mt7996_dev *dev)\n{\n\tif (!dev->recovery.hw_init_done)\n\t\treturn;\n\n\tif (dev->recovery.hw_full_reset)\n\t\treturn;\n\n\t \n\tif (READ_ONCE(dev->recovery.state) & MT_MCU_CMD_WDT_MASK) {\n\t\tdev->recovery.restart = true;\n\t\tdev_info(dev->mt76.dev,\n\t\t\t \"%s indicated firmware crash, attempting recovery\\n\",\n\t\t\t wiphy_name(dev->mt76.hw->wiphy));\n\n\t\tmt7996_irq_disable(dev, MT_INT_MCU_CMD);\n\t\tqueue_work(dev->mt76.wq, &dev->dump_work);\n\t\treturn;\n\t}\n\n\tqueue_work(dev->mt76.wq, &dev->reset_work);\n\twake_up(&dev->reset_wait);\n}\n\nvoid mt7996_mac_update_stats(struct mt7996_phy *phy)\n{\n\tstruct mt76_mib_stats *mib = &phy->mib;\n\tstruct mt7996_dev *dev = phy->dev;\n\tu8 band_idx = phy->mt76->band_idx;\n\tu32 cnt;\n\tint i;\n\n\tcnt = mt76_rr(dev, MT_MIB_RSCR1(band_idx));\n\tmib->fcs_err_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_RSCR33(band_idx));\n\tmib->rx_fifo_full_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_RSCR31(band_idx));\n\tmib->rx_mpdu_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR6(band_idx));\n\tmib->channel_idle_cnt += FIELD_GET(MT_MIB_SDR6_CHANNEL_IDL_CNT_MASK, cnt);\n\n\tcnt = mt76_rr(dev, MT_MIB_RVSR0(band_idx));\n\tmib->rx_vector_mismatch_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_RSCR35(band_idx));\n\tmib->rx_delimiter_fail_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_RSCR36(band_idx));\n\tmib->rx_len_mismatch_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_TSCR0(band_idx));\n\tmib->tx_ampdu_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_TSCR2(band_idx));\n\tmib->tx_stop_q_empty_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_TSCR3(band_idx));\n\tmib->tx_mpdu_attempts_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_TSCR4(band_idx));\n\tmib->tx_mpdu_success_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_RSCR27(band_idx));\n\tmib->rx_ampdu_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_RSCR28(band_idx));\n\tmib->rx_ampdu_bytes_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_RSCR29(band_idx));\n\tmib->rx_ampdu_valid_subframe_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_RSCR30(band_idx));\n\tmib->rx_ampdu_valid_subframe_bytes_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR27(band_idx));\n\tmib->tx_rwp_fail_cnt += FIELD_GET(MT_MIB_SDR27_TX_RWP_FAIL_CNT, cnt);\n\n\tcnt = mt76_rr(dev, MT_MIB_SDR28(band_idx));\n\tmib->tx_rwp_need_cnt += FIELD_GET(MT_MIB_SDR28_TX_RWP_NEED_CNT, cnt);\n\n\tcnt = mt76_rr(dev, MT_UMIB_RPDCR(band_idx));\n\tmib->rx_pfdrop_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_RVSR1(band_idx));\n\tmib->rx_vec_queue_overflow_drop_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_TSCR1(band_idx));\n\tmib->rx_ba_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_BSCR0(band_idx));\n\tmib->tx_bf_ebf_ppdu_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_BSCR1(band_idx));\n\tmib->tx_bf_ibf_ppdu_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_BSCR2(band_idx));\n\tmib->tx_mu_bf_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_TSCR5(band_idx));\n\tmib->tx_mu_mpdu_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_TSCR6(band_idx));\n\tmib->tx_mu_acked_mpdu_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_TSCR7(band_idx));\n\tmib->tx_su_acked_mpdu_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_BSCR3(band_idx));\n\tmib->tx_bf_rx_fb_ht_cnt += cnt;\n\tmib->tx_bf_rx_fb_all_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_BSCR4(band_idx));\n\tmib->tx_bf_rx_fb_vht_cnt += cnt;\n\tmib->tx_bf_rx_fb_all_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_BSCR5(band_idx));\n\tmib->tx_bf_rx_fb_he_cnt += cnt;\n\tmib->tx_bf_rx_fb_all_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_BSCR6(band_idx));\n\tmib->tx_bf_rx_fb_eht_cnt += cnt;\n\tmib->tx_bf_rx_fb_all_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_ETBF_RX_FB_CONT(band_idx));\n\tmib->tx_bf_rx_fb_bw = FIELD_GET(MT_ETBF_RX_FB_BW, cnt);\n\tmib->tx_bf_rx_fb_nc_cnt += FIELD_GET(MT_ETBF_RX_FB_NC, cnt);\n\tmib->tx_bf_rx_fb_nr_cnt += FIELD_GET(MT_ETBF_RX_FB_NR, cnt);\n\n\tcnt = mt76_rr(dev, MT_MIB_BSCR7(band_idx));\n\tmib->tx_bf_fb_trig_cnt += cnt;\n\n\tcnt = mt76_rr(dev, MT_MIB_BSCR17(band_idx));\n\tmib->tx_bf_fb_cpl_cnt += cnt;\n\n\tfor (i = 0; i < ARRAY_SIZE(mib->tx_amsdu); i++) {\n\t\tcnt = mt76_rr(dev, MT_PLE_AMSDU_PACK_MSDU_CNT(i));\n\t\tmib->tx_amsdu[i] += cnt;\n\t\tmib->tx_amsdu_cnt += cnt;\n\t}\n\n\t \n\tcnt = mt76_rr(dev, MT_MIB_BTSCR5(band_idx));\n\tmib->rts_cnt += cnt;\n\n\t \n\tcnt = mt76_rr(dev, MT_MIB_BTSCR6(band_idx));\n\tmib->rts_retries_cnt += cnt;\n\n\t \n\tcnt = mt76_rr(dev, MT_MIB_BTSCR0(band_idx));\n\tmib->ba_miss_cnt += cnt;\n\n\t \n\tcnt = mt76_rr(dev, MT_MIB_BFTFCR(band_idx));\n\tmib->ack_fail_cnt += cnt;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tcnt = mt76_rr(dev, MT_TX_AGG_CNT(band_idx, i));\n\t\tphy->mt76->aggr_stats[i] += cnt;\n\t}\n}\n\nvoid mt7996_mac_sta_rc_work(struct work_struct *work)\n{\n\tstruct mt7996_dev *dev = container_of(work, struct mt7996_dev, rc_work);\n\tstruct ieee80211_sta *sta;\n\tstruct ieee80211_vif *vif;\n\tstruct mt7996_sta *msta;\n\tu32 changed;\n\tLIST_HEAD(list);\n\n\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\tlist_splice_init(&dev->sta_rc_list, &list);\n\n\twhile (!list_empty(&list)) {\n\t\tmsta = list_first_entry(&list, struct mt7996_sta, rc_list);\n\t\tlist_del_init(&msta->rc_list);\n\t\tchanged = msta->changed;\n\t\tmsta->changed = 0;\n\t\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\n\t\tsta = container_of((void *)msta, struct ieee80211_sta, drv_priv);\n\t\tvif = container_of((void *)msta->vif, struct ieee80211_vif, drv_priv);\n\n\t\tif (changed & (IEEE80211_RC_SUPP_RATES_CHANGED |\n\t\t\t       IEEE80211_RC_NSS_CHANGED |\n\t\t\t       IEEE80211_RC_BW_CHANGED))\n\t\t\tmt7996_mcu_add_rate_ctrl(dev, vif, sta, true);\n\n\t\t \n\n\t\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\t}\n\n\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n}\n\nvoid mt7996_mac_work(struct work_struct *work)\n{\n\tstruct mt7996_phy *phy;\n\tstruct mt76_phy *mphy;\n\n\tmphy = (struct mt76_phy *)container_of(work, struct mt76_phy,\n\t\t\t\t\t       mac_work.work);\n\tphy = mphy->priv;\n\n\tmutex_lock(&mphy->dev->mutex);\n\n\tmt76_update_survey(mphy);\n\tif (++mphy->mac_work_count == 5) {\n\t\tmphy->mac_work_count = 0;\n\n\t\tmt7996_mac_update_stats(phy);\n\t}\n\n\tmutex_unlock(&mphy->dev->mutex);\n\n\tmt76_tx_status_check(mphy->dev, false);\n\n\tieee80211_queue_delayed_work(mphy->hw, &mphy->mac_work,\n\t\t\t\t     MT7996_WATCHDOG_TIME);\n}\n\nstatic void mt7996_dfs_stop_radar_detector(struct mt7996_phy *phy)\n{\n\tstruct mt7996_dev *dev = phy->dev;\n\n\tif (phy->rdd_state & BIT(0))\n\t\tmt7996_mcu_rdd_cmd(dev, RDD_STOP, 0,\n\t\t\t\t   MT_RX_SEL0, 0);\n\tif (phy->rdd_state & BIT(1))\n\t\tmt7996_mcu_rdd_cmd(dev, RDD_STOP, 1,\n\t\t\t\t   MT_RX_SEL0, 0);\n}\n\nstatic int mt7996_dfs_start_rdd(struct mt7996_dev *dev, int chain)\n{\n\tint err, region;\n\n\tswitch (dev->mt76.region) {\n\tcase NL80211_DFS_ETSI:\n\t\tregion = 0;\n\t\tbreak;\n\tcase NL80211_DFS_JP:\n\t\tregion = 2;\n\t\tbreak;\n\tcase NL80211_DFS_FCC:\n\tdefault:\n\t\tregion = 1;\n\t\tbreak;\n\t}\n\n\terr = mt7996_mcu_rdd_cmd(dev, RDD_START, chain,\n\t\t\t\t MT_RX_SEL0, region);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn mt7996_mcu_rdd_cmd(dev, RDD_DET_MODE, chain,\n\t\t\t\t MT_RX_SEL0, 1);\n}\n\nstatic int mt7996_dfs_start_radar_detector(struct mt7996_phy *phy)\n{\n\tstruct cfg80211_chan_def *chandef = &phy->mt76->chandef;\n\tstruct mt7996_dev *dev = phy->dev;\n\tu8 band_idx = phy->mt76->band_idx;\n\tint err;\n\n\t \n\terr = mt7996_mcu_rdd_cmd(dev, RDD_CAC_START, band_idx,\n\t\t\t\t MT_RX_SEL0, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = mt7996_dfs_start_rdd(dev, band_idx);\n\tif (err < 0)\n\t\treturn err;\n\n\tphy->rdd_state |= BIT(band_idx);\n\n\tif (chandef->width == NL80211_CHAN_WIDTH_160 ||\n\t    chandef->width == NL80211_CHAN_WIDTH_80P80) {\n\t\terr = mt7996_dfs_start_rdd(dev, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tphy->rdd_state |= BIT(1);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmt7996_dfs_init_radar_specs(struct mt7996_phy *phy)\n{\n\tconst struct mt7996_dfs_radar_spec *radar_specs;\n\tstruct mt7996_dev *dev = phy->dev;\n\tint err, i;\n\n\tswitch (dev->mt76.region) {\n\tcase NL80211_DFS_FCC:\n\t\tradar_specs = &fcc_radar_specs;\n\t\terr = mt7996_mcu_set_fcc5_lpn(dev, 8);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tcase NL80211_DFS_ETSI:\n\t\tradar_specs = &etsi_radar_specs;\n\t\tbreak;\n\tcase NL80211_DFS_JP:\n\t\tradar_specs = &jp_radar_specs;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(radar_specs->radar_pattern); i++) {\n\t\terr = mt7996_mcu_set_radar_th(dev, i,\n\t\t\t\t\t      &radar_specs->radar_pattern[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn mt7996_mcu_set_pulse_th(dev, &radar_specs->pulse_th);\n}\n\nint mt7996_dfs_init_radar_detector(struct mt7996_phy *phy)\n{\n\tstruct mt7996_dev *dev = phy->dev;\n\tenum mt76_dfs_state dfs_state, prev_state;\n\tint err;\n\n\tprev_state = phy->mt76->dfs_state;\n\tdfs_state = mt76_phy_dfs_state(phy->mt76);\n\n\tif (prev_state == dfs_state)\n\t\treturn 0;\n\n\tif (prev_state == MT_DFS_STATE_UNKNOWN)\n\t\tmt7996_dfs_stop_radar_detector(phy);\n\n\tif (dfs_state == MT_DFS_STATE_DISABLED)\n\t\tgoto stop;\n\n\tif (prev_state <= MT_DFS_STATE_DISABLED) {\n\t\terr = mt7996_dfs_init_radar_specs(phy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = mt7996_dfs_start_radar_detector(phy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tphy->mt76->dfs_state = MT_DFS_STATE_CAC;\n\t}\n\n\tif (dfs_state == MT_DFS_STATE_CAC)\n\t\treturn 0;\n\n\terr = mt7996_mcu_rdd_cmd(dev, RDD_CAC_END,\n\t\t\t\t phy->mt76->band_idx, MT_RX_SEL0, 0);\n\tif (err < 0) {\n\t\tphy->mt76->dfs_state = MT_DFS_STATE_UNKNOWN;\n\t\treturn err;\n\t}\n\n\tphy->mt76->dfs_state = MT_DFS_STATE_ACTIVE;\n\treturn 0;\n\nstop:\n\terr = mt7996_mcu_rdd_cmd(dev, RDD_NORMAL_START,\n\t\t\t\t phy->mt76->band_idx, MT_RX_SEL0, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tmt7996_dfs_stop_radar_detector(phy);\n\tphy->mt76->dfs_state = MT_DFS_STATE_DISABLED;\n\n\treturn 0;\n}\n\nstatic int\nmt7996_mac_twt_duration_align(int duration)\n{\n\treturn duration << 8;\n}\n\nstatic u64\nmt7996_mac_twt_sched_list_add(struct mt7996_dev *dev,\n\t\t\t      struct mt7996_twt_flow *flow)\n{\n\tstruct mt7996_twt_flow *iter, *iter_next;\n\tu32 duration = flow->duration << 8;\n\tu64 start_tsf;\n\n\titer = list_first_entry_or_null(&dev->twt_list,\n\t\t\t\t\tstruct mt7996_twt_flow, list);\n\tif (!iter || !iter->sched || iter->start_tsf > duration) {\n\t\t \n\t\tlist_add(&flow->list, &dev->twt_list);\n\t\treturn 0;\n\t}\n\n\tlist_for_each_entry_safe(iter, iter_next, &dev->twt_list, list) {\n\t\tstart_tsf = iter->start_tsf +\n\t\t\t    mt7996_mac_twt_duration_align(iter->duration);\n\t\tif (list_is_last(&iter->list, &dev->twt_list))\n\t\t\tbreak;\n\n\t\tif (!iter_next->sched ||\n\t\t    iter_next->start_tsf > start_tsf + duration) {\n\t\t\tlist_add(&flow->list, &iter->list);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tlist_add_tail(&flow->list, &dev->twt_list);\nout:\n\treturn start_tsf;\n}\n\nstatic int mt7996_mac_check_twt_req(struct ieee80211_twt_setup *twt)\n{\n\tstruct ieee80211_twt_params *twt_agrt;\n\tu64 interval, duration;\n\tu16 mantissa;\n\tu8 exp;\n\n\t \n\tif (twt->control & IEEE80211_TWT_CONTROL_NEG_TYPE_BROADCAST)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (twt->control & IEEE80211_TWT_CONTROL_WAKE_DUR_UNIT)\n\t\treturn -EOPNOTSUPP;\n\n\ttwt_agrt = (struct ieee80211_twt_params *)twt->params;\n\n\t \n\tif (!(twt_agrt->req_type & cpu_to_le16(IEEE80211_TWT_REQTYPE_IMPLICIT)))\n\t\treturn -EOPNOTSUPP;\n\n\texp = FIELD_GET(IEEE80211_TWT_REQTYPE_WAKE_INT_EXP,\n\t\t\tle16_to_cpu(twt_agrt->req_type));\n\tmantissa = le16_to_cpu(twt_agrt->mantissa);\n\tduration = twt_agrt->min_twt_dur << 8;\n\n\tinterval = (u64)mantissa << exp;\n\tif (interval < duration)\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nvoid mt7996_mac_add_twt_setup(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_sta *sta,\n\t\t\t      struct ieee80211_twt_setup *twt)\n{\n\tenum ieee80211_twt_setup_cmd setup_cmd = TWT_SETUP_CMD_REJECT;\n\tstruct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;\n\tstruct ieee80211_twt_params *twt_agrt = (void *)twt->params;\n\tu16 req_type = le16_to_cpu(twt_agrt->req_type);\n\tenum ieee80211_twt_setup_cmd sta_setup_cmd;\n\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\tstruct mt7996_twt_flow *flow;\n\tint flowid, table_id;\n\tu8 exp;\n\n\tif (mt7996_mac_check_twt_req(twt))\n\t\tgoto out;\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tif (dev->twt.n_agrt == MT7996_MAX_TWT_AGRT)\n\t\tgoto unlock;\n\n\tif (hweight8(msta->twt.flowid_mask) == ARRAY_SIZE(msta->twt.flow))\n\t\tgoto unlock;\n\n\tflowid = ffs(~msta->twt.flowid_mask) - 1;\n\tle16p_replace_bits(&twt_agrt->req_type, flowid,\n\t\t\t   IEEE80211_TWT_REQTYPE_FLOWID);\n\n\ttable_id = ffs(~dev->twt.table_mask) - 1;\n\texp = FIELD_GET(IEEE80211_TWT_REQTYPE_WAKE_INT_EXP, req_type);\n\tsta_setup_cmd = FIELD_GET(IEEE80211_TWT_REQTYPE_SETUP_CMD, req_type);\n\n\tflow = &msta->twt.flow[flowid];\n\tmemset(flow, 0, sizeof(*flow));\n\tINIT_LIST_HEAD(&flow->list);\n\tflow->wcid = msta->wcid.idx;\n\tflow->table_id = table_id;\n\tflow->id = flowid;\n\tflow->duration = twt_agrt->min_twt_dur;\n\tflow->mantissa = twt_agrt->mantissa;\n\tflow->exp = exp;\n\tflow->protection = !!(req_type & IEEE80211_TWT_REQTYPE_PROTECTION);\n\tflow->flowtype = !!(req_type & IEEE80211_TWT_REQTYPE_FLOWTYPE);\n\tflow->trigger = !!(req_type & IEEE80211_TWT_REQTYPE_TRIGGER);\n\n\tif (sta_setup_cmd == TWT_SETUP_CMD_REQUEST ||\n\t    sta_setup_cmd == TWT_SETUP_CMD_SUGGEST) {\n\t\tu64 interval = (u64)le16_to_cpu(twt_agrt->mantissa) << exp;\n\t\tu64 flow_tsf, curr_tsf;\n\t\tu32 rem;\n\n\t\tflow->sched = true;\n\t\tflow->start_tsf = mt7996_mac_twt_sched_list_add(dev, flow);\n\t\tcurr_tsf = __mt7996_get_tsf(hw, msta->vif);\n\t\tdiv_u64_rem(curr_tsf - flow->start_tsf, interval, &rem);\n\t\tflow_tsf = curr_tsf + interval - rem;\n\t\ttwt_agrt->twt = cpu_to_le64(flow_tsf);\n\t} else {\n\t\tlist_add_tail(&flow->list, &dev->twt_list);\n\t}\n\tflow->tsf = le64_to_cpu(twt_agrt->twt);\n\n\tif (mt7996_mcu_twt_agrt_update(dev, msta->vif, flow, MCU_TWT_AGRT_ADD))\n\t\tgoto unlock;\n\n\tsetup_cmd = TWT_SETUP_CMD_ACCEPT;\n\tdev->twt.table_mask |= BIT(table_id);\n\tmsta->twt.flowid_mask |= BIT(flowid);\n\tdev->twt.n_agrt++;\n\nunlock:\n\tmutex_unlock(&dev->mt76.mutex);\nout:\n\tle16p_replace_bits(&twt_agrt->req_type, setup_cmd,\n\t\t\t   IEEE80211_TWT_REQTYPE_SETUP_CMD);\n\ttwt->control = (twt->control & IEEE80211_TWT_CONTROL_WAKE_DUR_UNIT) |\n\t\t       (twt->control & IEEE80211_TWT_CONTROL_RX_DISABLED);\n}\n\nvoid mt7996_mac_twt_teardown_flow(struct mt7996_dev *dev,\n\t\t\t\t  struct mt7996_sta *msta,\n\t\t\t\t  u8 flowid)\n{\n\tstruct mt7996_twt_flow *flow;\n\n\tlockdep_assert_held(&dev->mt76.mutex);\n\n\tif (flowid >= ARRAY_SIZE(msta->twt.flow))\n\t\treturn;\n\n\tif (!(msta->twt.flowid_mask & BIT(flowid)))\n\t\treturn;\n\n\tflow = &msta->twt.flow[flowid];\n\tif (mt7996_mcu_twt_agrt_update(dev, msta->vif, flow,\n\t\t\t\t       MCU_TWT_AGRT_DELETE))\n\t\treturn;\n\n\tlist_del_init(&flow->list);\n\tmsta->twt.flowid_mask &= ~BIT(flowid);\n\tdev->twt.table_mask &= ~BIT(flow->table_id);\n\tdev->twt.n_agrt--;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}