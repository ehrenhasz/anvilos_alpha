{
  "module_name": "mmio.c",
  "hash_id": "cd5c3e014908ef3dabf029bccfc9d1513dde90d897eec8aafa5d857f2af8fc5f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7996/mmio.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#include \"mt7996.h\"\n#include \"mac.h\"\n#include \"../trace.h\"\n\nstatic const struct __base mt7996_reg_base[] = {\n\t[WF_AGG_BASE]\t\t= { { 0x820e2000, 0x820f2000, 0x830e2000 } },\n\t[WF_ARB_BASE]\t\t= { { 0x820e3000, 0x820f3000, 0x830e3000 } },\n\t[WF_TMAC_BASE]\t\t= { { 0x820e4000, 0x820f4000, 0x830e4000 } },\n\t[WF_RMAC_BASE]\t\t= { { 0x820e5000, 0x820f5000, 0x830e5000 } },\n\t[WF_DMA_BASE]\t\t= { { 0x820e7000, 0x820f7000, 0x830e7000 } },\n\t[WF_WTBLOFF_BASE]\t= { { 0x820e9000, 0x820f9000, 0x830e9000 } },\n\t[WF_ETBF_BASE]\t\t= { { 0x820ea000, 0x820fa000, 0x830ea000 } },\n\t[WF_LPON_BASE]\t\t= { { 0x820eb000, 0x820fb000, 0x830eb000 } },\n\t[WF_MIB_BASE]\t\t= { { 0x820ed000, 0x820fd000, 0x830ed000 } },\n\t[WF_RATE_BASE]\t\t= { { 0x820ee000, 0x820fe000, 0x830ee000 } },\n};\n\nstatic const struct __map mt7996_reg_map[] = {\n\t{ 0x54000000, 0x02000, 0x1000 },  \n\t{ 0x55000000, 0x03000, 0x1000 },  \n\t{ 0x56000000, 0x04000, 0x1000 },  \n\t{ 0x57000000, 0x05000, 0x1000 },  \n\t{ 0x58000000, 0x06000, 0x1000 },  \n\t{ 0x59000000, 0x07000, 0x1000 },  \n\t{ 0x820c0000, 0x08000, 0x4000 },  \n\t{ 0x820c8000, 0x0c000, 0x2000 },  \n\t{ 0x820cc000, 0x0e000, 0x1000 },  \n\t{ 0x74030000, 0x10000, 0x1000 },  \n\t{ 0x820e0000, 0x20000, 0x0400 },  \n\t{ 0x820e1000, 0x20400, 0x0200 },  \n\t{ 0x820e2000, 0x20800, 0x0400 },  \n\t{ 0x820e3000, 0x20c00, 0x0400 },  \n\t{ 0x820e4000, 0x21000, 0x0400 },  \n\t{ 0x820e5000, 0x21400, 0x0800 },  \n\t{ 0x820ce000, 0x21c00, 0x0200 },  \n\t{ 0x820e7000, 0x21e00, 0x0200 },  \n\t{ 0x820cf000, 0x22000, 0x1000 },  \n\t{ 0x820e9000, 0x23400, 0x0200 },  \n\t{ 0x820ea000, 0x24000, 0x0200 },  \n\t{ 0x820eb000, 0x24200, 0x0400 },  \n\t{ 0x820ec000, 0x24600, 0x0200 },  \n\t{ 0x820ed000, 0x24800, 0x0800 },  \n\t{ 0x820ca000, 0x26000, 0x2000 },  \n\t{ 0x820d0000, 0x30000, 0x10000 },  \n\t{ 0x40000000, 0x70000, 0x10000 },  \n\t{ 0x00400000, 0x80000, 0x10000 },  \n\t{ 0x00410000, 0x90000, 0x10000 },  \n\t{ 0x820f0000, 0xa0000, 0x0400 },  \n\t{ 0x820f1000, 0xa0600, 0x0200 },  \n\t{ 0x820f2000, 0xa0800, 0x0400 },  \n\t{ 0x820f3000, 0xa0c00, 0x0400 },  \n\t{ 0x820f4000, 0xa1000, 0x0400 },  \n\t{ 0x820f5000, 0xa1400, 0x0800 },  \n\t{ 0x820f7000, 0xa1e00, 0x0200 },  \n\t{ 0x820f9000, 0xa3400, 0x0200 },  \n\t{ 0x820fa000, 0xa4000, 0x0200 },  \n\t{ 0x820fb000, 0xa4200, 0x0400 },  \n\t{ 0x820fc000, 0xa4600, 0x0200 },  \n\t{ 0x820fd000, 0xa4800, 0x0800 },  \n\t{ 0x820cc000, 0xa5000, 0x2000 },  \n\t{ 0x820c4000, 0xa8000, 0x4000 },  \n\t{ 0x820b0000, 0xae000, 0x1000 },  \n\t{ 0x80020000, 0xb0000, 0x10000 },  \n\t{ 0x81020000, 0xc0000, 0x10000 },  \n\t{ 0x7c020000, 0xd0000, 0x10000 },  \n\t{ 0x7c060000, 0xe0000, 0x10000 },  \n\t{ 0x7c000000, 0xf0000, 0x10000 },  \n\t{ 0x0, 0x0, 0x0 },  \n};\n\nstatic u32 mt7996_reg_map_l1(struct mt7996_dev *dev, u32 addr)\n{\n\tu32 offset = FIELD_GET(MT_HIF_REMAP_L1_OFFSET, addr);\n\tu32 base = FIELD_GET(MT_HIF_REMAP_L1_BASE, addr);\n\n\tdev->reg_l1_backup = dev->bus_ops->rr(&dev->mt76, MT_HIF_REMAP_L1);\n\tdev->bus_ops->rmw(&dev->mt76, MT_HIF_REMAP_L1,\n\t\t\t  MT_HIF_REMAP_L1_MASK,\n\t\t\t  FIELD_PREP(MT_HIF_REMAP_L1_MASK, base));\n\t \n\tdev->bus_ops->rr(&dev->mt76, MT_HIF_REMAP_L1);\n\n\treturn MT_HIF_REMAP_BASE_L1 + offset;\n}\n\nstatic u32 mt7996_reg_map_l2(struct mt7996_dev *dev, u32 addr)\n{\n\tu32 offset = FIELD_GET(MT_HIF_REMAP_L2_OFFSET, addr);\n\tu32 base = FIELD_GET(MT_HIF_REMAP_L2_BASE, addr);\n\n\tdev->reg_l2_backup = dev->bus_ops->rr(&dev->mt76, MT_HIF_REMAP_L2);\n\tdev->bus_ops->rmw(&dev->mt76, MT_HIF_REMAP_L2,\n\t\t\t  MT_HIF_REMAP_L2_MASK,\n\t\t\t  FIELD_PREP(MT_HIF_REMAP_L2_MASK, base));\n\t \n\tdev->bus_ops->rr(&dev->mt76, MT_HIF_REMAP_L2);\n\n\treturn MT_HIF_REMAP_BASE_L2 + offset;\n}\n\nstatic void mt7996_reg_remap_restore(struct mt7996_dev *dev)\n{\n\t \n\tif (unlikely(dev->reg_l1_backup)) {\n\t\tdev->bus_ops->wr(&dev->mt76, MT_HIF_REMAP_L1, dev->reg_l1_backup);\n\t\tdev->reg_l1_backup = 0;\n\t}\n\n\tif (dev->reg_l2_backup) {\n\t\tdev->bus_ops->wr(&dev->mt76, MT_HIF_REMAP_L2, dev->reg_l2_backup);\n\t\tdev->reg_l2_backup = 0;\n\t}\n}\n\nstatic u32 __mt7996_reg_addr(struct mt7996_dev *dev, u32 addr)\n{\n\tint i;\n\n\tmt7996_reg_remap_restore(dev);\n\n\tif (addr < 0x100000)\n\t\treturn addr;\n\n\tfor (i = 0; i < dev->reg.map_size; i++) {\n\t\tu32 ofs;\n\n\t\tif (addr < dev->reg.map[i].phys)\n\t\t\tcontinue;\n\n\t\tofs = addr - dev->reg.map[i].phys;\n\t\tif (ofs > dev->reg.map[i].size)\n\t\t\tcontinue;\n\n\t\treturn dev->reg.map[i].mapped + ofs;\n\t}\n\n\tif ((addr >= MT_INFRA_BASE && addr < MT_WFSYS0_PHY_START) ||\n\t    (addr >= MT_WFSYS0_PHY_START && addr < MT_WFSYS1_PHY_START) ||\n\t    (addr >= MT_WFSYS1_PHY_START && addr <= MT_WFSYS1_PHY_END))\n\t\treturn mt7996_reg_map_l1(dev, addr);\n\n\tif (dev_is_pci(dev->mt76.dev) &&\n\t    ((addr >= MT_CBTOP1_PHY_START && addr <= MT_CBTOP1_PHY_END) ||\n\t    addr >= MT_CBTOP2_PHY_START))\n\t\treturn mt7996_reg_map_l1(dev, addr);\n\n\t \n\tif (addr >= MT_INFRA_MCU_START && addr <= MT_INFRA_MCU_END) {\n\t\taddr = addr - MT_INFRA_MCU_START + MT_INFRA_BASE;\n\t\treturn mt7996_reg_map_l1(dev, addr);\n\t}\n\n\treturn mt7996_reg_map_l2(dev, addr);\n}\n\nvoid mt7996_memcpy_fromio(struct mt7996_dev *dev, void *buf, u32 offset,\n\t\t\t  size_t len)\n{\n\tu32 addr = __mt7996_reg_addr(dev, offset);\n\n\tmemcpy_fromio(buf, dev->mt76.mmio.regs + addr, len);\n}\n\nstatic u32 mt7996_rr(struct mt76_dev *mdev, u32 offset)\n{\n\tstruct mt7996_dev *dev = container_of(mdev, struct mt7996_dev, mt76);\n\n\treturn dev->bus_ops->rr(mdev, __mt7996_reg_addr(dev, offset));\n}\n\nstatic void mt7996_wr(struct mt76_dev *mdev, u32 offset, u32 val)\n{\n\tstruct mt7996_dev *dev = container_of(mdev, struct mt7996_dev, mt76);\n\n\tdev->bus_ops->wr(mdev, __mt7996_reg_addr(dev, offset), val);\n}\n\nstatic u32 mt7996_rmw(struct mt76_dev *mdev, u32 offset, u32 mask, u32 val)\n{\n\tstruct mt7996_dev *dev = container_of(mdev, struct mt7996_dev, mt76);\n\n\treturn dev->bus_ops->rmw(mdev, __mt7996_reg_addr(dev, offset), mask, val);\n}\n\nstatic int mt7996_mmio_init(struct mt76_dev *mdev,\n\t\t\t    void __iomem *mem_base,\n\t\t\t    u32 device_id)\n{\n\tstruct mt76_bus_ops *bus_ops;\n\tstruct mt7996_dev *dev;\n\n\tdev = container_of(mdev, struct mt7996_dev, mt76);\n\tmt76_mmio_init(&dev->mt76, mem_base);\n\n\tswitch (device_id) {\n\tcase 0x7990:\n\t\tdev->reg.base = mt7996_reg_base;\n\t\tdev->reg.map = mt7996_reg_map;\n\t\tdev->reg.map_size = ARRAY_SIZE(mt7996_reg_map);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev->bus_ops = dev->mt76.bus;\n\tbus_ops = devm_kmemdup(dev->mt76.dev, dev->bus_ops, sizeof(*bus_ops),\n\t\t\t       GFP_KERNEL);\n\tif (!bus_ops)\n\t\treturn -ENOMEM;\n\n\tbus_ops->rr = mt7996_rr;\n\tbus_ops->wr = mt7996_wr;\n\tbus_ops->rmw = mt7996_rmw;\n\tdev->mt76.bus = bus_ops;\n\n\tmdev->rev = (device_id << 16) | (mt76_rr(dev, MT_HW_REV) & 0xff);\n\n\tdev_dbg(mdev->dev, \"ASIC revision: %04x\\n\", mdev->rev);\n\n\treturn 0;\n}\n\nvoid mt7996_dual_hif_set_irq_mask(struct mt7996_dev *dev, bool write_reg,\n\t\t\t\t  u32 clear, u32 set)\n{\n\tstruct mt76_dev *mdev = &dev->mt76;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mdev->mmio.irq_lock, flags);\n\n\tmdev->mmio.irqmask &= ~clear;\n\tmdev->mmio.irqmask |= set;\n\n\tif (write_reg) {\n\t\tmt76_wr(dev, MT_INT_MASK_CSR, mdev->mmio.irqmask);\n\t\tmt76_wr(dev, MT_INT1_MASK_CSR, mdev->mmio.irqmask);\n\t}\n\n\tspin_unlock_irqrestore(&mdev->mmio.irq_lock, flags);\n}\n\nstatic void mt7996_rx_poll_complete(struct mt76_dev *mdev,\n\t\t\t\t    enum mt76_rxq_id q)\n{\n\tstruct mt7996_dev *dev = container_of(mdev, struct mt7996_dev, mt76);\n\n\tmt7996_irq_enable(dev, MT_INT_RX(q));\n}\n\n \nstatic void mt7996_irq_tasklet(struct tasklet_struct *t)\n{\n\tstruct mt7996_dev *dev = from_tasklet(dev, t, mt76.irq_tasklet);\n\tu32 i, intr, mask, intr1;\n\n\tmt76_wr(dev, MT_INT_MASK_CSR, 0);\n\tif (dev->hif2)\n\t\tmt76_wr(dev, MT_INT1_MASK_CSR, 0);\n\n\tintr = mt76_rr(dev, MT_INT_SOURCE_CSR);\n\tintr &= dev->mt76.mmio.irqmask;\n\tmt76_wr(dev, MT_INT_SOURCE_CSR, intr);\n\n\tif (dev->hif2) {\n\t\tintr1 = mt76_rr(dev, MT_INT1_SOURCE_CSR);\n\t\tintr1 &= dev->mt76.mmio.irqmask;\n\t\tmt76_wr(dev, MT_INT1_SOURCE_CSR, intr1);\n\n\t\tintr |= intr1;\n\t}\n\n\ttrace_dev_irq(&dev->mt76, intr, dev->mt76.mmio.irqmask);\n\n\tmask = intr & MT_INT_RX_DONE_ALL;\n\tif (intr & MT_INT_TX_DONE_MCU)\n\t\tmask |= MT_INT_TX_DONE_MCU;\n\tmt7996_irq_disable(dev, mask);\n\n\tif (intr & MT_INT_TX_DONE_MCU)\n\t\tnapi_schedule(&dev->mt76.tx_napi);\n\n\tfor (i = 0; i < __MT_RXQ_MAX; i++) {\n\t\tif ((intr & MT_INT_RX(i)))\n\t\t\tnapi_schedule(&dev->mt76.napi[i]);\n\t}\n\n\tif (intr & MT_INT_MCU_CMD) {\n\t\tu32 val = mt76_rr(dev, MT_MCU_CMD);\n\n\t\tmt76_wr(dev, MT_MCU_CMD, val);\n\t\tif (val & (MT_MCU_CMD_ERROR_MASK | MT_MCU_CMD_WDT_MASK)) {\n\t\t\tdev->recovery.state = val;\n\t\t\tmt7996_reset(dev);\n\t\t}\n\t}\n}\n\nirqreturn_t mt7996_irq_handler(int irq, void *dev_instance)\n{\n\tstruct mt7996_dev *dev = dev_instance;\n\n\tmt76_wr(dev, MT_INT_MASK_CSR, 0);\n\tif (dev->hif2)\n\t\tmt76_wr(dev, MT_INT1_MASK_CSR, 0);\n\n\tif (!test_bit(MT76_STATE_INITIALIZED, &dev->mphy.state))\n\t\treturn IRQ_NONE;\n\n\ttasklet_schedule(&dev->mt76.irq_tasklet);\n\n\treturn IRQ_HANDLED;\n}\n\nstruct mt7996_dev *mt7996_mmio_probe(struct device *pdev,\n\t\t\t\t     void __iomem *mem_base, u32 device_id)\n{\n\tstatic const struct mt76_driver_ops drv_ops = {\n\t\t \n\t\t.txwi_size = MT_TXD_SIZE + sizeof(struct mt76_connac_fw_txp),\n\t\t.drv_flags = MT_DRV_TXWI_NO_FREE |\n\t\t\t     MT_DRV_AMSDU_OFFLOAD |\n\t\t\t     MT_DRV_HW_MGMT_TXQ,\n\t\t.survey_flags = SURVEY_INFO_TIME_TX |\n\t\t\t\tSURVEY_INFO_TIME_RX |\n\t\t\t\tSURVEY_INFO_TIME_BSS_RX,\n\t\t.token_size = MT7996_TOKEN_SIZE,\n\t\t.tx_prepare_skb = mt7996_tx_prepare_skb,\n\t\t.tx_complete_skb = mt76_connac_tx_complete_skb,\n\t\t.rx_skb = mt7996_queue_rx_skb,\n\t\t.rx_check = mt7996_rx_check,\n\t\t.rx_poll_complete = mt7996_rx_poll_complete,\n\t\t.sta_add = mt7996_mac_sta_add,\n\t\t.sta_remove = mt7996_mac_sta_remove,\n\t\t.update_survey = mt7996_update_channel,\n\t};\n\tstruct mt7996_dev *dev;\n\tstruct mt76_dev *mdev;\n\tint ret;\n\n\tmdev = mt76_alloc_device(pdev, sizeof(*dev), &mt7996_ops, &drv_ops);\n\tif (!mdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdev = container_of(mdev, struct mt7996_dev, mt76);\n\n\tret = mt7996_mmio_init(mdev, mem_base, device_id);\n\tif (ret)\n\t\tgoto error;\n\n\ttasklet_setup(&mdev->irq_tasklet, mt7996_irq_tasklet);\n\n\tmt76_wr(dev, MT_INT_MASK_CSR, 0);\n\n\treturn dev;\n\nerror:\n\tmt76_free_device(&dev->mt76);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic int __init mt7996_init(void)\n{\n\tint ret;\n\n\tret = pci_register_driver(&mt7996_hif_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_register_driver(&mt7996_pci_driver);\n\tif (ret)\n\t\tpci_unregister_driver(&mt7996_hif_driver);\n\n\treturn ret;\n}\n\nstatic void __exit mt7996_exit(void)\n{\n\tpci_unregister_driver(&mt7996_pci_driver);\n\tpci_unregister_driver(&mt7996_hif_driver);\n}\n\nmodule_init(mt7996_init);\nmodule_exit(mt7996_exit);\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}