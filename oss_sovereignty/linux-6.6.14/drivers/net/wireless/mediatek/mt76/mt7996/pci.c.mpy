{
  "module_name": "pci.c",
  "hash_id": "a266368a375632eed57de3f26ec9bde65c60ec3a4135eb3b5520fa2a2b604aa5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7996/pci.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#include \"mt7996.h\"\n#include \"mac.h\"\n#include \"../trace.h\"\n\nstatic LIST_HEAD(hif_list);\nstatic DEFINE_SPINLOCK(hif_lock);\nstatic u32 hif_idx;\n\nstatic const struct pci_device_id mt7996_pci_device_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MEDIATEK, 0x7990) },\n\t{ },\n};\n\nstatic const struct pci_device_id mt7996_hif_device_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MEDIATEK, 0x7991) },\n\t{ },\n};\n\nstatic struct mt7996_hif *mt7996_pci_get_hif2(u32 idx)\n{\n\tstruct mt7996_hif *hif;\n\tu32 val;\n\n\tspin_lock_bh(&hif_lock);\n\n\tlist_for_each_entry(hif, &hif_list, list) {\n\t\tval = readl(hif->regs + MT_PCIE_RECOG_ID);\n\t\tval &= MT_PCIE_RECOG_ID_MASK;\n\t\tif (val != idx)\n\t\t\tcontinue;\n\n\t\tget_device(hif->dev);\n\t\tgoto out;\n\t}\n\thif = NULL;\n\nout:\n\tspin_unlock_bh(&hif_lock);\n\n\treturn hif;\n}\n\nstatic void mt7996_put_hif2(struct mt7996_hif *hif)\n{\n\tif (!hif)\n\t\treturn;\n\n\tput_device(hif->dev);\n}\n\nstatic struct mt7996_hif *mt7996_pci_init_hif2(struct pci_dev *pdev)\n{\n\thif_idx++;\n\tif (!pci_get_device(PCI_VENDOR_ID_MEDIATEK, 0x7991, NULL))\n\t\treturn NULL;\n\n\twritel(hif_idx | MT_PCIE_RECOG_ID_SEM,\n\t       pcim_iomap_table(pdev)[0] + MT_PCIE_RECOG_ID);\n\n\treturn mt7996_pci_get_hif2(hif_idx);\n}\n\nstatic int mt7996_pci_hif2_probe(struct pci_dev *pdev)\n{\n\tstruct mt7996_hif *hif;\n\n\thif = devm_kzalloc(&pdev->dev, sizeof(*hif), GFP_KERNEL);\n\tif (!hif)\n\t\treturn -ENOMEM;\n\n\thif->dev = &pdev->dev;\n\thif->regs = pcim_iomap_table(pdev)[0];\n\thif->irq = pdev->irq;\n\tspin_lock_bh(&hif_lock);\n\tlist_add(&hif->list, &hif_list);\n\tspin_unlock_bh(&hif_lock);\n\tpci_set_drvdata(pdev, hif);\n\n\treturn 0;\n}\n\nstatic int mt7996_pci_probe(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *id)\n{\n\tstruct pci_dev *hif2_dev;\n\tstruct mt7996_dev *dev;\n\tstruct mt76_dev *mdev;\n\tstruct mt7996_hif *hif2;\n\tint irq, ret;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pcim_iomap_regions(pdev, BIT(0), pci_name(pdev));\n\tif (ret)\n\t\treturn ret;\n\n\tpci_set_master(pdev);\n\n\tret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\tmt76_pci_disable_aspm(pdev);\n\n\tif (id->device == 0x7991)\n\t\treturn mt7996_pci_hif2_probe(pdev);\n\n\tdev = mt7996_mmio_probe(&pdev->dev, pcim_iomap_table(pdev)[0],\n\t\t\t\tid->device);\n\tif (IS_ERR(dev))\n\t\treturn PTR_ERR(dev);\n\n\tmdev = &dev->mt76;\n\tmt7996_wfsys_reset(dev);\n\thif2 = mt7996_pci_init_hif2(pdev);\n\n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_ALL_TYPES);\n\tif (ret < 0)\n\t\tgoto free_device;\n\n\tirq = pdev->irq;\n\tret = devm_request_irq(mdev->dev, irq, mt7996_irq_handler,\n\t\t\t       IRQF_SHARED, KBUILD_MODNAME, dev);\n\tif (ret)\n\t\tgoto free_irq_vector;\n\n\tmt76_wr(dev, MT_INT_MASK_CSR, 0);\n\t \n\tmt76_wr(dev, MT_PCIE_MAC_INT_ENABLE, 0xff);\n\n\tif (hif2) {\n\t\thif2_dev = container_of(hif2->dev, struct pci_dev, dev);\n\t\tdev->hif2 = hif2;\n\n\t\tret = pci_alloc_irq_vectors(hif2_dev, 1, 1, PCI_IRQ_ALL_TYPES);\n\t\tif (ret < 0)\n\t\t\tgoto free_hif2;\n\n\t\tdev->hif2->irq = hif2_dev->irq;\n\t\tret = devm_request_irq(mdev->dev, dev->hif2->irq,\n\t\t\t\t       mt7996_irq_handler, IRQF_SHARED,\n\t\t\t\t       KBUILD_MODNAME \"-hif\", dev);\n\t\tif (ret)\n\t\t\tgoto free_hif2_irq_vector;\n\n\t\tmt76_wr(dev, MT_INT1_MASK_CSR, 0);\n\t\t \n\t\tmt76_wr(dev, MT_PCIE1_MAC_INT_ENABLE, 0xff);\n\t}\n\n\tret = mt7996_register_device(dev);\n\tif (ret)\n\t\tgoto free_hif2_irq;\n\n\treturn 0;\n\nfree_hif2_irq:\n\tif (dev->hif2)\n\t\tdevm_free_irq(mdev->dev, dev->hif2->irq, dev);\nfree_hif2_irq_vector:\n\tif (dev->hif2)\n\t\tpci_free_irq_vectors(hif2_dev);\nfree_hif2:\n\tif (dev->hif2)\n\t\tput_device(dev->hif2->dev);\n\tdevm_free_irq(mdev->dev, irq, dev);\nfree_irq_vector:\n\tpci_free_irq_vectors(pdev);\nfree_device:\n\tmt76_free_device(&dev->mt76);\n\n\treturn ret;\n}\n\nstatic void mt7996_hif_remove(struct pci_dev *pdev)\n{\n\tstruct mt7996_hif *hif = pci_get_drvdata(pdev);\n\n\tlist_del(&hif->list);\n}\n\nstatic void mt7996_pci_remove(struct pci_dev *pdev)\n{\n\tstruct mt76_dev *mdev;\n\tstruct mt7996_dev *dev;\n\n\tmdev = pci_get_drvdata(pdev);\n\tdev = container_of(mdev, struct mt7996_dev, mt76);\n\tmt7996_put_hif2(dev->hif2);\n\tmt7996_unregister_device(dev);\n}\n\nstruct pci_driver mt7996_hif_driver = {\n\t.name\t\t= KBUILD_MODNAME \"_hif\",\n\t.id_table\t= mt7996_hif_device_table,\n\t.probe\t\t= mt7996_pci_probe,\n\t.remove\t\t= mt7996_hif_remove,\n};\n\nstruct pci_driver mt7996_pci_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= mt7996_pci_device_table,\n\t.probe\t\t= mt7996_pci_probe,\n\t.remove\t\t= mt7996_pci_remove,\n};\n\nMODULE_DEVICE_TABLE(pci, mt7996_pci_device_table);\nMODULE_DEVICE_TABLE(pci, mt7996_hif_device_table);\nMODULE_FIRMWARE(MT7996_FIRMWARE_WA);\nMODULE_FIRMWARE(MT7996_FIRMWARE_WM);\nMODULE_FIRMWARE(MT7996_FIRMWARE_DSP);\nMODULE_FIRMWARE(MT7996_ROM_PATCH);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}