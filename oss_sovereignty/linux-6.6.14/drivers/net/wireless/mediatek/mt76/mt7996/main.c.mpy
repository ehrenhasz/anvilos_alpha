{
  "module_name": "main.c",
  "hash_id": "8accf0d8be44a22415cf7db3cd4deafb823c97a99e5fc163f0ef9a309b4e5556",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7996/main.c",
  "human_readable_source": "\n \n\n#include \"mt7996.h\"\n#include \"mcu.h\"\n#include \"mac.h\"\n\nstatic bool mt7996_dev_running(struct mt7996_dev *dev)\n{\n\tstruct mt7996_phy *phy;\n\n\tif (test_bit(MT76_STATE_RUNNING, &dev->mphy.state))\n\t\treturn true;\n\n\tphy = mt7996_phy2(dev);\n\tif (phy && test_bit(MT76_STATE_RUNNING, &phy->mt76->state))\n\t\treturn true;\n\n\tphy = mt7996_phy3(dev);\n\n\treturn phy && test_bit(MT76_STATE_RUNNING, &phy->mt76->state);\n}\n\nint mt7996_run(struct ieee80211_hw *hw)\n{\n\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\tstruct mt7996_phy *phy = mt7996_hw_phy(hw);\n\tbool running;\n\tint ret;\n\n\trunning = mt7996_dev_running(dev);\n\tif (!running) {\n\t\tret = mt7996_mcu_set_hdr_trans(dev, true);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tmt7996_mac_enable_nf(dev, phy->mt76->band_idx);\n\n\tret = mt7996_mcu_set_rts_thresh(phy, 0x92b);\n\tif (ret)\n\t\tgoto out;\n\n\tret = mt7996_mcu_set_radio_en(phy, true);\n\tif (ret)\n\t\tgoto out;\n\n\tret = mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_RX_PATH);\n\tif (ret)\n\t\tgoto out;\n\n\tset_bit(MT76_STATE_RUNNING, &phy->mt76->state);\n\n\tieee80211_queue_delayed_work(hw, &phy->mt76->mac_work,\n\t\t\t\t     MT7996_WATCHDOG_TIME);\n\n\tif (!running)\n\t\tmt7996_mac_reset_counters(phy);\n\nout:\n\treturn ret;\n}\n\nstatic int mt7996_start(struct ieee80211_hw *hw)\n{\n\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\tint ret;\n\n\tflush_work(&dev->init_work);\n\n\tmutex_lock(&dev->mt76.mutex);\n\tret = mt7996_run(hw);\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn ret;\n}\n\nstatic void mt7996_stop(struct ieee80211_hw *hw)\n{\n\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\tstruct mt7996_phy *phy = mt7996_hw_phy(hw);\n\n\tcancel_delayed_work_sync(&phy->mt76->mac_work);\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tmt7996_mcu_set_radio_en(phy, false);\n\n\tclear_bit(MT76_STATE_RUNNING, &phy->mt76->state);\n\n\tmutex_unlock(&dev->mt76.mutex);\n}\n\nstatic inline int get_free_idx(u32 mask, u8 start, u8 end)\n{\n\treturn ffs(~mask & GENMASK(end, start));\n}\n\nstatic int get_omac_idx(enum nl80211_iftype type, u64 mask)\n{\n\tint i;\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_STATION:\n\t\t \n\t\ti = get_free_idx(mask, HW_BSSID_1, HW_BSSID_3);\n\t\tif (i)\n\t\t\treturn i - 1;\n\n\t\tif (type != NL80211_IFTYPE_STATION)\n\t\t\tbreak;\n\n\t\ti = get_free_idx(mask, EXT_BSSID_1, EXT_BSSID_MAX);\n\t\tif (i)\n\t\t\treturn i - 1;\n\n\t\tif (~mask & BIT(HW_BSSID_0))\n\t\t\treturn HW_BSSID_0;\n\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_AP:\n\t\t \n\t\tif (~mask & BIT(HW_BSSID_0))\n\t\t\treturn HW_BSSID_0;\n\n\t\ti = get_free_idx(mask, EXT_BSSID_1, EXT_BSSID_MAX);\n\t\tif (i)\n\t\t\treturn i - 1;\n\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\treturn -1;\n}\n\nstatic void mt7996_init_bitrate_mask(struct ieee80211_vif *vif)\n{\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mvif->bitrate_mask.control); i++) {\n\t\tmvif->bitrate_mask.control[i].gi = NL80211_TXRATE_DEFAULT_GI;\n\t\tmvif->bitrate_mask.control[i].he_gi = 0xff;\n\t\tmvif->bitrate_mask.control[i].he_ltf = 0xff;\n\t\tmvif->bitrate_mask.control[i].legacy = GENMASK(31, 0);\n\t\tmemset(mvif->bitrate_mask.control[i].ht_mcs, 0xff,\n\t\t       sizeof(mvif->bitrate_mask.control[i].ht_mcs));\n\t\tmemset(mvif->bitrate_mask.control[i].vht_mcs, 0xff,\n\t\t       sizeof(mvif->bitrate_mask.control[i].vht_mcs));\n\t\tmemset(mvif->bitrate_mask.control[i].he_mcs, 0xff,\n\t\t       sizeof(mvif->bitrate_mask.control[i].he_mcs));\n\t}\n}\n\nstatic int mt7996_add_interface(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\tstruct mt7996_phy *phy = mt7996_hw_phy(hw);\n\tstruct mt76_txq *mtxq;\n\tu8 band_idx = phy->mt76->band_idx;\n\tint idx, ret = 0;\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tif (vif->type == NL80211_IFTYPE_MONITOR &&\n\t    is_zero_ether_addr(vif->addr))\n\t\tphy->monitor_vif = vif;\n\n\tmvif->mt76.idx = __ffs64(~dev->mt76.vif_mask);\n\tif (mvif->mt76.idx >= mt7996_max_interface_num(dev)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tidx = get_omac_idx(vif->type, phy->omac_mask);\n\tif (idx < 0) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\tmvif->mt76.omac_idx = idx;\n\tmvif->phy = phy;\n\tmvif->mt76.band_idx = band_idx;\n\tmvif->mt76.wmm_idx = vif->type != NL80211_IFTYPE_AP;\n\n\tret = mt7996_mcu_add_dev_info(phy, vif, true);\n\tif (ret)\n\t\tgoto out;\n\n\tdev->mt76.vif_mask |= BIT_ULL(mvif->mt76.idx);\n\tphy->omac_mask |= BIT_ULL(mvif->mt76.omac_idx);\n\n\tidx = MT7996_WTBL_RESERVED - mvif->mt76.idx;\n\n\tINIT_LIST_HEAD(&mvif->sta.rc_list);\n\tINIT_LIST_HEAD(&mvif->sta.wcid.poll_list);\n\tmvif->sta.wcid.idx = idx;\n\tmvif->sta.wcid.phy_idx = band_idx;\n\tmvif->sta.wcid.hw_key_idx = -1;\n\tmvif->sta.wcid.tx_info |= MT_WCID_TX_INFO_SET;\n\tmt76_packet_id_init(&mvif->sta.wcid);\n\n\tmt7996_mac_wtbl_update(dev, idx,\n\t\t\t       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);\n\n\tif (vif->txq) {\n\t\tmtxq = (struct mt76_txq *)vif->txq->drv_priv;\n\t\tmtxq->wcid = idx;\n\t}\n\n\tif (vif->type != NL80211_IFTYPE_AP &&\n\t    (!mvif->mt76.omac_idx || mvif->mt76.omac_idx > 3))\n\t\tvif->offload_flags = 0;\n\tvif->offload_flags |= IEEE80211_OFFLOAD_ENCAP_4ADDR;\n\n\tif (phy->mt76->chandef.chan->band != NL80211_BAND_2GHZ)\n\t\tmvif->mt76.basic_rates_idx = MT7996_BASIC_RATES_TBL + 4;\n\telse\n\t\tmvif->mt76.basic_rates_idx = MT7996_BASIC_RATES_TBL;\n\n\tmt7996_init_bitrate_mask(vif);\n\n\tmt7996_mcu_add_bss_info(phy, vif, true);\n\tmt7996_mcu_add_sta(dev, vif, NULL, true);\n\trcu_assign_pointer(dev->mt76.wcid[idx], &mvif->sta.wcid);\n\nout:\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn ret;\n}\n\nstatic void mt7996_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tstruct mt7996_sta *msta = &mvif->sta;\n\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\tstruct mt7996_phy *phy = mt7996_hw_phy(hw);\n\tint idx = msta->wcid.idx;\n\n\tmt7996_mcu_add_bss_info(phy, vif, false);\n\tmt7996_mcu_add_sta(dev, vif, NULL, false);\n\n\tif (vif == phy->monitor_vif)\n\t\tphy->monitor_vif = NULL;\n\n\tmt7996_mcu_add_dev_info(phy, vif, false);\n\n\trcu_assign_pointer(dev->mt76.wcid[idx], NULL);\n\n\tmutex_lock(&dev->mt76.mutex);\n\tdev->mt76.vif_mask &= ~BIT_ULL(mvif->mt76.idx);\n\tphy->omac_mask &= ~BIT_ULL(mvif->mt76.omac_idx);\n\tmutex_unlock(&dev->mt76.mutex);\n\n\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\tif (!list_empty(&msta->wcid.poll_list))\n\t\tlist_del_init(&msta->wcid.poll_list);\n\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\n\tmt76_packet_id_flush(&dev->mt76, &msta->wcid);\n}\n\nint mt7996_set_channel(struct mt7996_phy *phy)\n{\n\tstruct mt7996_dev *dev = phy->dev;\n\tint ret;\n\n\tcancel_delayed_work_sync(&phy->mt76->mac_work);\n\n\tmutex_lock(&dev->mt76.mutex);\n\tset_bit(MT76_RESET, &phy->mt76->state);\n\n\tmt76_set_channel(phy->mt76);\n\n\tret = mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_SWITCH);\n\tif (ret)\n\t\tgoto out;\n\n\tret = mt7996_dfs_init_radar_detector(phy);\n\tmt7996_mac_cca_stats_reset(phy);\n\n\tmt7996_mac_reset_counters(phy);\n\tphy->noise = 0;\n\nout:\n\tclear_bit(MT76_RESET, &phy->mt76->state);\n\tmutex_unlock(&dev->mt76.mutex);\n\n\tmt76_txq_schedule_all(phy->mt76);\n\n\tieee80211_queue_delayed_work(phy->mt76->hw,\n\t\t\t\t     &phy->mt76->mac_work,\n\t\t\t\t     MT7996_WATCHDOG_TIME);\n\n\treturn ret;\n}\n\nstatic int mt7996_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t\t  struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t\t  struct ieee80211_key_conf *key)\n{\n\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\tstruct mt7996_phy *phy = mt7996_hw_phy(hw);\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tstruct mt7996_sta *msta = sta ? (struct mt7996_sta *)sta->drv_priv :\n\t\t\t\t  &mvif->sta;\n\tstruct mt76_wcid *wcid = &msta->wcid;\n\tu8 *wcid_keyidx = &wcid->hw_key_idx;\n\tint idx = key->keyidx;\n\tint err = 0;\n\n\t \n\tif ((vif->type == NL80211_IFTYPE_ADHOC ||\n\t     vif->type == NL80211_IFTYPE_MESH_POINT) &&\n\t    (key->cipher == WLAN_CIPHER_SUITE_TKIP ||\n\t     key->cipher == WLAN_CIPHER_SUITE_CCMP) &&\n\t    !(key->flags & IEEE80211_KEY_FLAG_PAIRWISE))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\twcid_keyidx = &wcid->hw_key_idx2;\n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIE;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\tcase WLAN_CIPHER_SUITE_SMS4:\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tif (cmd == SET_KEY && !sta && !mvif->mt76.cipher) {\n\t\tmvif->mt76.cipher = mt76_connac_mcu_get_cipher(key->cipher);\n\t\tmt7996_mcu_add_bss_info(phy, vif, true);\n\t}\n\n\tif (cmd == SET_KEY) {\n\t\t*wcid_keyidx = idx;\n\t} else {\n\t\tif (idx == *wcid_keyidx)\n\t\t\t*wcid_keyidx = -1;\n\t\tgoto out;\n\t}\n\n\tmt76_wcid_key_setup(&dev->mt76, wcid, key);\n\terr = mt7996_mcu_add_key(&dev->mt76, vif, &msta->bip,\n\t\t\t\t key, MCU_WMWA_UNI_CMD(STA_REC_UPDATE),\n\t\t\t\t &msta->wcid, cmd);\nout:\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn err;\n}\n\nstatic int mt7996_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\tstruct mt7996_phy *phy = mt7996_hw_phy(hw);\n\tint ret;\n\n\tif (changed & IEEE80211_CONF_CHANGE_CHANNEL) {\n\t\tieee80211_stop_queues(hw);\n\t\tret = mt7996_set_channel(phy);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tieee80211_wake_queues(hw);\n\t}\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tif (changed & IEEE80211_CONF_CHANGE_MONITOR) {\n\t\tbool enabled = !!(hw->conf.flags & IEEE80211_CONF_MONITOR);\n\n\t\tif (!enabled)\n\t\t\tphy->rxfilter |= MT_WF_RFCR_DROP_OTHER_UC;\n\t\telse\n\t\t\tphy->rxfilter &= ~MT_WF_RFCR_DROP_OTHER_UC;\n\n\t\tmt76_rmw_field(dev, MT_DMA_DCR0(phy->mt76->band_idx),\n\t\t\t       MT_DMA_DCR0_RXD_G5_EN, enabled);\n\t\tmt76_wr(dev, MT_WF_RFCR(phy->mt76->band_idx), phy->rxfilter);\n\t}\n\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn 0;\n}\n\nstatic int\nmt7996_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t       unsigned int link_id, u16 queue,\n\t       const struct ieee80211_tx_queue_params *params)\n{\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tconst u8 mq_to_aci[] = {\n\t\t[IEEE80211_AC_VO] = 3,\n\t\t[IEEE80211_AC_VI] = 2,\n\t\t[IEEE80211_AC_BE] = 0,\n\t\t[IEEE80211_AC_BK] = 1,\n\t};\n\n\t \n\tmvif->queue_params[mq_to_aci[queue]] = *params;\n\t \n\n\treturn 0;\n}\n\nstatic void mt7996_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t    unsigned int changed_flags,\n\t\t\t\t    unsigned int *total_flags,\n\t\t\t\t    u64 multicast)\n{\n\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\tstruct mt7996_phy *phy = mt7996_hw_phy(hw);\n\tu32 ctl_flags = MT_WF_RFCR1_DROP_ACK |\n\t\t\tMT_WF_RFCR1_DROP_BF_POLL |\n\t\t\tMT_WF_RFCR1_DROP_BA |\n\t\t\tMT_WF_RFCR1_DROP_CFEND |\n\t\t\tMT_WF_RFCR1_DROP_CFACK;\n\tu32 flags = 0;\n\n#define MT76_FILTER(_flag, _hw) do {\t\t\t\t\t\\\n\t\tflags |= *total_flags & FIF_##_flag;\t\t\t\\\n\t\tphy->rxfilter &= ~(_hw);\t\t\t\t\\\n\t\tphy->rxfilter |= !(flags & FIF_##_flag) * (_hw);\t\\\n\t} while (0)\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tphy->rxfilter &= ~(MT_WF_RFCR_DROP_OTHER_BSS |\n\t\t\t   MT_WF_RFCR_DROP_OTHER_BEACON |\n\t\t\t   MT_WF_RFCR_DROP_FRAME_REPORT |\n\t\t\t   MT_WF_RFCR_DROP_PROBEREQ |\n\t\t\t   MT_WF_RFCR_DROP_MCAST_FILTERED |\n\t\t\t   MT_WF_RFCR_DROP_MCAST |\n\t\t\t   MT_WF_RFCR_DROP_BCAST |\n\t\t\t   MT_WF_RFCR_DROP_DUPLICATE |\n\t\t\t   MT_WF_RFCR_DROP_A2_BSSID |\n\t\t\t   MT_WF_RFCR_DROP_UNWANTED_CTL |\n\t\t\t   MT_WF_RFCR_DROP_STBC_MULTI);\n\n\tMT76_FILTER(OTHER_BSS, MT_WF_RFCR_DROP_OTHER_TIM |\n\t\t\t       MT_WF_RFCR_DROP_A3_MAC |\n\t\t\t       MT_WF_RFCR_DROP_A3_BSSID);\n\n\tMT76_FILTER(FCSFAIL, MT_WF_RFCR_DROP_FCSFAIL);\n\n\tMT76_FILTER(CONTROL, MT_WF_RFCR_DROP_CTS |\n\t\t\t     MT_WF_RFCR_DROP_RTS |\n\t\t\t     MT_WF_RFCR_DROP_CTL_RSV |\n\t\t\t     MT_WF_RFCR_DROP_NDPA);\n\n\t*total_flags = flags;\n\tmt76_wr(dev, MT_WF_RFCR(phy->mt76->band_idx), phy->rxfilter);\n\n\tif (*total_flags & FIF_CONTROL)\n\t\tmt76_clear(dev, MT_WF_RFCR1(phy->mt76->band_idx), ctl_flags);\n\telse\n\t\tmt76_set(dev, MT_WF_RFCR1(phy->mt76->band_idx), ctl_flags);\n\n\tmutex_unlock(&dev->mt76.mutex);\n}\n\nstatic void\nmt7996_update_bss_color(struct ieee80211_hw *hw,\n\t\t\tstruct ieee80211_vif *vif,\n\t\t\tstruct cfg80211_he_bss_color *bss_color)\n{\n\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_AP: {\n\t\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\n\t\tif (mvif->mt76.omac_idx > HW_BSSID_MAX)\n\t\t\treturn;\n\t\tfallthrough;\n\t}\n\tcase NL80211_IFTYPE_STATION:\n\t\tmt7996_mcu_update_bss_color(dev, vif, bss_color);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic u8\nmt7996_get_rates_table(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       bool beacon, bool mcast)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct mt76_phy *mphy = hw->priv;\n\tu16 rate;\n\tu8 i, idx, ht;\n\n\trate = mt76_connac2_mac_tx_rate_val(mphy, vif, beacon, mcast);\n\tht = FIELD_GET(MT_TX_RATE_MODE, rate) > MT_PHY_TYPE_OFDM;\n\n\tif (beacon && ht) {\n\t\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\n\t\t \n\t\tidx = MT7996_BEACON_RATES_TBL + 2 * (mvif->idx % 20);\n\t\tmt7996_mac_set_fixed_rate_table(dev, idx, rate);\n\t\treturn idx;\n\t}\n\n\tidx = FIELD_GET(MT_TX_RATE_IDX, rate);\n\tfor (i = 0; i < ARRAY_SIZE(mt76_rates); i++)\n\t\tif ((mt76_rates[i].hw_value & GENMASK(7, 0)) == idx)\n\t\t\treturn MT7996_BASIC_RATES_TBL + i;\n\n\treturn mvif->basic_rates_idx;\n}\n\nstatic void\nmt7996_update_mu_group(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_bss_conf *info)\n{\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\tu8 band = mvif->mt76.band_idx;\n\tu32 *mu;\n\n\tmu = (u32 *)info->mu_group.membership;\n\tmt76_wr(dev, MT_WF_PHYRX_BAND_GID_TAB_VLD0(band), mu[0]);\n\tmt76_wr(dev, MT_WF_PHYRX_BAND_GID_TAB_VLD1(band), mu[1]);\n\n\tmu = (u32 *)info->mu_group.position;\n\tmt76_wr(dev, MT_WF_PHYRX_BAND_GID_TAB_POS0(band), mu[0]);\n\tmt76_wr(dev, MT_WF_PHYRX_BAND_GID_TAB_POS1(band), mu[1]);\n\tmt76_wr(dev, MT_WF_PHYRX_BAND_GID_TAB_POS2(band), mu[2]);\n\tmt76_wr(dev, MT_WF_PHYRX_BAND_GID_TAB_POS3(band), mu[3]);\n}\n\nstatic void mt7996_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_bss_conf *info,\n\t\t\t\t    u64 changed)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct mt7996_phy *phy = mt7996_hw_phy(hw);\n\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\t \n\tif (changed & BSS_CHANGED_BSSID &&\n\t    vif->type == NL80211_IFTYPE_STATION) {\n\t\tbool join = !is_zero_ether_addr(info->bssid);\n\n\t\tmt7996_mcu_add_bss_info(phy, vif, join);\n\t\tmt7996_mcu_add_sta(dev, vif, NULL, join);\n\t}\n\n\tif (changed & BSS_CHANGED_ASSOC)\n\t\tmt7996_mcu_add_bss_info(phy, vif, vif->cfg.assoc);\n\n\tif (changed & BSS_CHANGED_ERP_CTS_PROT)\n\t\tmt7996_mac_enable_rtscts(dev, vif, info->use_cts_prot);\n\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\tint slottime = info->use_short_slot ? 9 : 20;\n\n\t\tif (slottime != phy->slottime) {\n\t\t\tphy->slottime = slottime;\n\t\t\tmt7996_mcu_set_timing(phy, vif);\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_MCAST_RATE)\n\t\tmvif->mcast_rates_idx =\n\t\t\tmt7996_get_rates_table(hw, vif, false, true);\n\n\tif (changed & BSS_CHANGED_BASIC_RATES)\n\t\tmvif->basic_rates_idx =\n\t\t\tmt7996_get_rates_table(hw, vif, false, false);\n\n\tif (changed & BSS_CHANGED_BEACON_ENABLED && info->enable_beacon) {\n\t\tmt7996_mcu_add_bss_info(phy, vif, true);\n\t\tmt7996_mcu_add_sta(dev, vif, NULL, true);\n\t}\n\n\t \n\tif (changed & (BSS_CHANGED_QOS | BSS_CHANGED_BEACON_ENABLED))\n\t\tmt7996_mcu_set_tx(dev, vif);\n\n\tif (changed & BSS_CHANGED_HE_OBSS_PD)\n\t\tmt7996_mcu_add_obss_spr(phy, vif, &info->he_obss_pd);\n\n\tif (changed & BSS_CHANGED_HE_BSS_COLOR)\n\t\tmt7996_update_bss_color(hw, vif, &info->he_bss_color);\n\n\tif (changed & (BSS_CHANGED_BEACON |\n\t\t       BSS_CHANGED_BEACON_ENABLED)) {\n\t\tmvif->beacon_rates_idx =\n\t\t\tmt7996_get_rates_table(hw, vif, true, false);\n\n\t\tmt7996_mcu_add_beacon(hw, vif, info->enable_beacon);\n\t}\n\n\tif (changed & (BSS_CHANGED_UNSOL_BCAST_PROBE_RESP |\n\t\t       BSS_CHANGED_FILS_DISCOVERY))\n\t\tmt7996_mcu_beacon_inband_discov(dev, vif, changed);\n\n\tif (changed & BSS_CHANGED_MU_GROUPS)\n\t\tmt7996_update_mu_group(hw, vif, info);\n\n\tmutex_unlock(&dev->mt76.mutex);\n}\n\nstatic void\nmt7996_channel_switch_beacon(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct cfg80211_chan_def *chandef)\n{\n\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\n\tmutex_lock(&dev->mt76.mutex);\n\tmt7996_mcu_add_beacon(hw, vif, true);\n\tmutex_unlock(&dev->mt76.mutex);\n}\n\nint mt7996_mac_sta_add(struct mt76_dev *mdev, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_sta *sta)\n{\n\tstruct mt7996_dev *dev = container_of(mdev, struct mt7996_dev, mt76);\n\tstruct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tu8 band_idx = mvif->phy->mt76->band_idx;\n\tint ret, idx;\n\n\tidx = mt76_wcid_alloc(dev->mt76.wcid_mask, MT7996_WTBL_STA);\n\tif (idx < 0)\n\t\treturn -ENOSPC;\n\n\tINIT_LIST_HEAD(&msta->rc_list);\n\tINIT_LIST_HEAD(&msta->wcid.poll_list);\n\tmsta->vif = mvif;\n\tmsta->wcid.sta = 1;\n\tmsta->wcid.idx = idx;\n\tmsta->wcid.phy_idx = band_idx;\n\tmsta->wcid.tx_info |= MT_WCID_TX_INFO_SET;\n\tmsta->jiffies = jiffies;\n\n\tewma_avg_signal_init(&msta->avg_ack_signal);\n\n\tmt7996_mac_wtbl_update(dev, idx,\n\t\t\t       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);\n\n\tret = mt7996_mcu_add_sta(dev, vif, sta, true);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mt7996_mcu_add_rate_ctrl(dev, vif, sta, false);\n}\n\nvoid mt7996_mac_sta_remove(struct mt76_dev *mdev, struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_sta *sta)\n{\n\tstruct mt7996_dev *dev = container_of(mdev, struct mt7996_dev, mt76);\n\tstruct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;\n\tint i;\n\n\tmt7996_mcu_add_sta(dev, vif, sta, false);\n\n\tmt7996_mac_wtbl_update(dev, msta->wcid.idx,\n\t\t\t       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);\n\n\tfor (i = 0; i < ARRAY_SIZE(msta->twt.flow); i++)\n\t\tmt7996_mac_twt_teardown_flow(dev, msta, i);\n\n\tspin_lock_bh(&mdev->sta_poll_lock);\n\tif (!list_empty(&msta->wcid.poll_list))\n\t\tlist_del_init(&msta->wcid.poll_list);\n\tif (!list_empty(&msta->rc_list))\n\t\tlist_del_init(&msta->rc_list);\n\tspin_unlock_bh(&mdev->sta_poll_lock);\n}\n\nstatic void mt7996_tx(struct ieee80211_hw *hw,\n\t\t      struct ieee80211_tx_control *control,\n\t\t      struct sk_buff *skb)\n{\n\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\tstruct mt76_phy *mphy = hw->priv;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_vif *vif = info->control.vif;\n\tstruct mt76_wcid *wcid = &dev->mt76.global_wcid;\n\n\tif (control->sta) {\n\t\tstruct mt7996_sta *sta;\n\n\t\tsta = (struct mt7996_sta *)control->sta->drv_priv;\n\t\twcid = &sta->wcid;\n\t}\n\n\tif (vif && !control->sta) {\n\t\tstruct mt7996_vif *mvif;\n\n\t\tmvif = (struct mt7996_vif *)vif->drv_priv;\n\t\twcid = &mvif->sta.wcid;\n\t}\n\n\tmt76_tx(mphy, control->sta, wcid, skb);\n}\n\nstatic int mt7996_set_rts_threshold(struct ieee80211_hw *hw, u32 val)\n{\n\tstruct mt7996_phy *phy = mt7996_hw_phy(hw);\n\tint ret;\n\n\tmutex_lock(&phy->dev->mt76.mutex);\n\tret = mt7996_mcu_set_rts_thresh(phy, val);\n\tmutex_unlock(&phy->dev->mt76.mutex);\n\n\treturn ret;\n}\n\nstatic int\nmt7996_ampdu_action(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t    struct ieee80211_ampdu_params *params)\n{\n\tenum ieee80211_ampdu_mlme_action action = params->action;\n\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\tstruct ieee80211_sta *sta = params->sta;\n\tstruct ieee80211_txq *txq = sta->txq[params->tid];\n\tstruct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;\n\tu16 tid = params->tid;\n\tu16 ssn = params->ssn;\n\tstruct mt76_txq *mtxq;\n\tint ret = 0;\n\n\tif (!txq)\n\t\treturn -EINVAL;\n\n\tmtxq = (struct mt76_txq *)txq->drv_priv;\n\n\tmutex_lock(&dev->mt76.mutex);\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_RX_START:\n\t\tmt76_rx_aggr_start(&dev->mt76, &msta->wcid, tid, ssn,\n\t\t\t\t   params->buf_size);\n\t\tret = mt7996_mcu_add_rx_ba(dev, params, true);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\tmt76_rx_aggr_stop(&dev->mt76, &msta->wcid, tid);\n\t\tret = mt7996_mcu_add_rx_ba(dev, params, false);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\tmtxq->aggr = true;\n\t\tmtxq->send_bar = false;\n\t\tret = mt7996_mcu_add_tx_ba(dev, params, true);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\t\tmtxq->aggr = false;\n\t\tclear_bit(tid, &msta->wcid.ampdu_state);\n\t\tret = mt7996_mcu_add_tx_ba(dev, params, false);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_START:\n\t\tset_bit(tid, &msta->wcid.ampdu_state);\n\t\tret = IEEE80211_AMPDU_TX_START_IMMEDIATE;\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\t\tmtxq->aggr = false;\n\t\tclear_bit(tid, &msta->wcid.ampdu_state);\n\t\tret = mt7996_mcu_add_tx_ba(dev, params, false);\n\t\tieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\t\tbreak;\n\t}\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn ret;\n}\n\nstatic int\nmt7996_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t       struct ieee80211_sta *sta)\n{\n\treturn mt76_sta_state(hw, vif, sta, IEEE80211_STA_NOTEXIST,\n\t\t\t      IEEE80211_STA_NONE);\n}\n\nstatic int\nmt7996_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t  struct ieee80211_sta *sta)\n{\n\treturn mt76_sta_state(hw, vif, sta, IEEE80211_STA_NONE,\n\t\t\t      IEEE80211_STA_NOTEXIST);\n}\n\nstatic int\nmt7996_get_stats(struct ieee80211_hw *hw,\n\t\t struct ieee80211_low_level_stats *stats)\n{\n\tstruct mt7996_phy *phy = mt7996_hw_phy(hw);\n\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\tstruct mt76_mib_stats *mib = &phy->mib;\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tstats->dot11RTSSuccessCount = mib->rts_cnt;\n\tstats->dot11RTSFailureCount = mib->rts_retries_cnt;\n\tstats->dot11FCSErrorCount = mib->fcs_err_cnt;\n\tstats->dot11ACKFailureCount = mib->ack_fail_cnt;\n\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn 0;\n}\n\nu64 __mt7996_get_tsf(struct ieee80211_hw *hw, struct mt7996_vif *mvif)\n{\n\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\tstruct mt7996_phy *phy = mt7996_hw_phy(hw);\n\tunion {\n\t\tu64 t64;\n\t\tu32 t32[2];\n\t} tsf;\n\tu16 n;\n\n\tlockdep_assert_held(&dev->mt76.mutex);\n\n\tn = mvif->mt76.omac_idx > HW_BSSID_MAX ? HW_BSSID_0\n\t\t\t\t\t       : mvif->mt76.omac_idx;\n\t \n\tmt76_rmw(dev, MT_LPON_TCR(phy->mt76->band_idx, n), MT_LPON_TCR_SW_MODE,\n\t\t MT_LPON_TCR_SW_READ);\n\ttsf.t32[0] = mt76_rr(dev, MT_LPON_UTTR0(phy->mt76->band_idx));\n\ttsf.t32[1] = mt76_rr(dev, MT_LPON_UTTR1(phy->mt76->band_idx));\n\n\treturn tsf.t64;\n}\n\nstatic u64\nmt7996_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\tu64 ret;\n\n\tmutex_lock(&dev->mt76.mutex);\n\tret = __mt7996_get_tsf(hw, mvif);\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn ret;\n}\n\nstatic void\nmt7996_set_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t       u64 timestamp)\n{\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\tstruct mt7996_phy *phy = mt7996_hw_phy(hw);\n\tunion {\n\t\tu64 t64;\n\t\tu32 t32[2];\n\t} tsf = { .t64 = timestamp, };\n\tu16 n;\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tn = mvif->mt76.omac_idx > HW_BSSID_MAX ? HW_BSSID_0\n\t\t\t\t\t       : mvif->mt76.omac_idx;\n\tmt76_wr(dev, MT_LPON_UTTR0(phy->mt76->band_idx), tsf.t32[0]);\n\tmt76_wr(dev, MT_LPON_UTTR1(phy->mt76->band_idx), tsf.t32[1]);\n\t \n\tmt76_rmw(dev, MT_LPON_TCR(phy->mt76->band_idx, n), MT_LPON_TCR_SW_MODE,\n\t\t MT_LPON_TCR_SW_WRITE);\n\n\tmutex_unlock(&dev->mt76.mutex);\n}\n\nstatic void\nmt7996_offset_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t  s64 timestamp)\n{\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\tstruct mt7996_phy *phy = mt7996_hw_phy(hw);\n\tunion {\n\t\tu64 t64;\n\t\tu32 t32[2];\n\t} tsf = { .t64 = timestamp, };\n\tu16 n;\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tn = mvif->mt76.omac_idx > HW_BSSID_MAX ? HW_BSSID_0\n\t\t\t\t\t       : mvif->mt76.omac_idx;\n\tmt76_wr(dev, MT_LPON_UTTR0(phy->mt76->band_idx), tsf.t32[0]);\n\tmt76_wr(dev, MT_LPON_UTTR1(phy->mt76->band_idx), tsf.t32[1]);\n\t \n\tmt76_rmw(dev, MT_LPON_TCR(phy->mt76->band_idx, n), MT_LPON_TCR_SW_MODE,\n\t\t MT_LPON_TCR_SW_ADJUST);\n\n\tmutex_unlock(&dev->mt76.mutex);\n}\n\nstatic void\nmt7996_set_coverage_class(struct ieee80211_hw *hw, s16 coverage_class)\n{\n\tstruct mt7996_phy *phy = mt7996_hw_phy(hw);\n\tstruct mt7996_dev *dev = phy->dev;\n\n\tmutex_lock(&dev->mt76.mutex);\n\tphy->coverage_class = max_t(s16, coverage_class, 0);\n\tmt7996_mac_set_coverage_class(phy);\n\tmutex_unlock(&dev->mt76.mutex);\n}\n\nstatic int\nmt7996_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)\n{\n\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\tstruct mt7996_phy *phy = mt7996_hw_phy(hw);\n\tint max_nss = hweight8(hw->wiphy->available_antennas_tx);\n\tu8 band_idx = phy->mt76->band_idx, shift = dev->chainshift[band_idx];\n\n\tif (!tx_ant || tx_ant != rx_ant || ffs(tx_ant) > max_nss)\n\t\treturn -EINVAL;\n\n\tif ((BIT(hweight8(tx_ant)) - 1) != tx_ant)\n\t\ttx_ant = BIT(ffs(tx_ant) - 1) - 1;\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tphy->mt76->antenna_mask = tx_ant;\n\n\t \n\tif (hweight8(tx_ant) == max_nss && band_idx < MT_BAND2)\n\t\tphy->mt76->chainmask = ((dev->chainmask >> shift) &\n\t\t\t\t\t(BIT(dev->chainshift[band_idx + 1] - shift) - 1)) << shift;\n\telse if (hweight8(tx_ant) == max_nss)\n\t\tphy->mt76->chainmask = (dev->chainmask >> shift) << shift;\n\telse\n\t\tphy->mt76->chainmask = tx_ant << shift;\n\n\tmt76_set_stream_caps(phy->mt76, true);\n\tmt7996_set_stream_vht_txbf_caps(phy);\n\tmt7996_set_stream_he_eht_caps(phy);\n\n\t \n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn 0;\n}\n\nstatic void mt7996_sta_statistics(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t  struct station_info *sinfo)\n{\n\tstruct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;\n\tstruct rate_info *txrate = &msta->wcid.rate;\n\n\tif (txrate->legacy || txrate->flags) {\n\t\tif (txrate->legacy) {\n\t\t\tsinfo->txrate.legacy = txrate->legacy;\n\t\t} else {\n\t\t\tsinfo->txrate.mcs = txrate->mcs;\n\t\t\tsinfo->txrate.nss = txrate->nss;\n\t\t\tsinfo->txrate.bw = txrate->bw;\n\t\t\tsinfo->txrate.he_gi = txrate->he_gi;\n\t\t\tsinfo->txrate.he_dcm = txrate->he_dcm;\n\t\t\tsinfo->txrate.he_ru_alloc = txrate->he_ru_alloc;\n\t\t}\n\t\tsinfo->txrate.flags = txrate->flags;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);\n\t}\n\tsinfo->txrate.flags = txrate->flags;\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);\n\n\tsinfo->ack_signal = (s8)msta->ack_signal;\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL);\n\n\tsinfo->avg_ack_signal = -(s8)ewma_avg_signal_read(&msta->avg_ack_signal);\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL_AVG);\n}\n\nstatic void mt7996_sta_rc_work(void *data, struct ieee80211_sta *sta)\n{\n\tstruct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;\n\tstruct mt7996_dev *dev = msta->vif->phy->dev;\n\tu32 *changed = data;\n\n\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\tmsta->changed |= *changed;\n\tif (list_empty(&msta->rc_list))\n\t\tlist_add_tail(&msta->rc_list, &dev->sta_rc_list);\n\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n}\n\nstatic void mt7996_sta_rc_update(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t u32 changed)\n{\n\tstruct mt7996_phy *phy = mt7996_hw_phy(hw);\n\tstruct mt7996_dev *dev = phy->dev;\n\n\tmt7996_sta_rc_work(&changed, sta);\n\tieee80211_queue_work(hw, &dev->rc_work);\n}\n\nstatic int\nmt7996_set_bitrate_mask(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tconst struct cfg80211_bitrate_mask *mask)\n{\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tstruct mt7996_phy *phy = mt7996_hw_phy(hw);\n\tstruct mt7996_dev *dev = phy->dev;\n\tu32 changed = IEEE80211_RC_SUPP_RATES_CHANGED;\n\n\tmvif->bitrate_mask = *mask;\n\n\t \n\tieee80211_iterate_stations_atomic(hw, mt7996_sta_rc_work, &changed);\n\tieee80211_queue_work(hw, &dev->rc_work);\n\n\treturn 0;\n}\n\nstatic void mt7996_sta_set_4addr(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t bool enabled)\n{\n\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\tstruct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;\n\n\tif (enabled)\n\t\tset_bit(MT_WCID_FLAG_4ADDR, &msta->wcid.flags);\n\telse\n\t\tclear_bit(MT_WCID_FLAG_4ADDR, &msta->wcid.flags);\n\n\tmt7996_mcu_wtbl_update_hdr_trans(dev, vif, sta);\n}\n\nstatic void mt7996_sta_set_decap_offload(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t\t bool enabled)\n{\n\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\tstruct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;\n\n\tif (enabled)\n\t\tset_bit(MT_WCID_FLAG_HDR_TRANS, &msta->wcid.flags);\n\telse\n\t\tclear_bit(MT_WCID_FLAG_HDR_TRANS, &msta->wcid.flags);\n\n\tmt7996_mcu_wtbl_update_hdr_trans(dev, vif, sta);\n}\n\nstatic const char mt7996_gstrings_stats[][ETH_GSTRING_LEN] = {\n\t\"tx_ampdu_cnt\",\n\t\"tx_stop_q_empty_cnt\",\n\t\"tx_mpdu_attempts\",\n\t\"tx_mpdu_success\",\n\t\"tx_rwp_fail_cnt\",\n\t\"tx_rwp_need_cnt\",\n\t\"tx_pkt_ebf_cnt\",\n\t\"tx_pkt_ibf_cnt\",\n\t\"tx_ampdu_len:0-1\",\n\t\"tx_ampdu_len:2-10\",\n\t\"tx_ampdu_len:11-19\",\n\t\"tx_ampdu_len:20-28\",\n\t\"tx_ampdu_len:29-37\",\n\t\"tx_ampdu_len:38-46\",\n\t\"tx_ampdu_len:47-55\",\n\t\"tx_ampdu_len:56-79\",\n\t\"tx_ampdu_len:80-103\",\n\t\"tx_ampdu_len:104-127\",\n\t\"tx_ampdu_len:128-151\",\n\t\"tx_ampdu_len:152-175\",\n\t\"tx_ampdu_len:176-199\",\n\t\"tx_ampdu_len:200-223\",\n\t\"tx_ampdu_len:224-247\",\n\t\"ba_miss_count\",\n\t\"tx_beamformer_ppdu_iBF\",\n\t\"tx_beamformer_ppdu_eBF\",\n\t\"tx_beamformer_rx_feedback_all\",\n\t\"tx_beamformer_rx_feedback_he\",\n\t\"tx_beamformer_rx_feedback_vht\",\n\t\"tx_beamformer_rx_feedback_ht\",\n\t\"tx_beamformer_rx_feedback_bw\",  \n\t\"tx_beamformer_rx_feedback_nc\",\n\t\"tx_beamformer_rx_feedback_nr\",\n\t\"tx_beamformee_ok_feedback_pkts\",\n\t\"tx_beamformee_feedback_trig\",\n\t\"tx_mu_beamforming\",\n\t\"tx_mu_mpdu\",\n\t\"tx_mu_successful_mpdu\",\n\t\"tx_su_successful_mpdu\",\n\t\"tx_msdu_pack_1\",\n\t\"tx_msdu_pack_2\",\n\t\"tx_msdu_pack_3\",\n\t\"tx_msdu_pack_4\",\n\t\"tx_msdu_pack_5\",\n\t\"tx_msdu_pack_6\",\n\t\"tx_msdu_pack_7\",\n\t\"tx_msdu_pack_8\",\n\n\t \n\t\"rx_fifo_full_cnt\",\n\t\"rx_mpdu_cnt\",\n\t\"channel_idle_cnt\",\n\t\"rx_vector_mismatch_cnt\",\n\t\"rx_delimiter_fail_cnt\",\n\t\"rx_len_mismatch_cnt\",\n\t\"rx_ampdu_cnt\",\n\t\"rx_ampdu_bytes_cnt\",\n\t\"rx_ampdu_valid_subframe_cnt\",\n\t\"rx_ampdu_valid_subframe_b_cnt\",\n\t\"rx_pfdrop_cnt\",\n\t\"rx_vec_queue_overflow_drop_cnt\",\n\t\"rx_ba_cnt\",\n\n\t \n\t\"v_tx_mode_cck\",\n\t\"v_tx_mode_ofdm\",\n\t\"v_tx_mode_ht\",\n\t\"v_tx_mode_ht_gf\",\n\t\"v_tx_mode_vht\",\n\t\"v_tx_mode_he_su\",\n\t\"v_tx_mode_he_ext_su\",\n\t\"v_tx_mode_he_tb\",\n\t\"v_tx_mode_he_mu\",\n\t\"v_tx_mode_eht_su\",\n\t\"v_tx_mode_eht_trig\",\n\t\"v_tx_mode_eht_mu\",\n\t\"v_tx_bw_20\",\n\t\"v_tx_bw_40\",\n\t\"v_tx_bw_80\",\n\t\"v_tx_bw_160\",\n\t\"v_tx_bw_320\",\n\t\"v_tx_mcs_0\",\n\t\"v_tx_mcs_1\",\n\t\"v_tx_mcs_2\",\n\t\"v_tx_mcs_3\",\n\t\"v_tx_mcs_4\",\n\t\"v_tx_mcs_5\",\n\t\"v_tx_mcs_6\",\n\t\"v_tx_mcs_7\",\n\t\"v_tx_mcs_8\",\n\t\"v_tx_mcs_9\",\n\t\"v_tx_mcs_10\",\n\t\"v_tx_mcs_11\",\n\t\"v_tx_mcs_12\",\n\t\"v_tx_mcs_13\",\n\t\"v_tx_nss_1\",\n\t\"v_tx_nss_2\",\n\t\"v_tx_nss_3\",\n\t\"v_tx_nss_4\",\n};\n\n#define MT7996_SSTATS_LEN ARRAY_SIZE(mt7996_gstrings_stats)\n\n \nstatic\nvoid mt7996_get_et_strings(struct ieee80211_hw *hw,\n\t\t\t   struct ieee80211_vif *vif,\n\t\t\t   u32 sset, u8 *data)\n{\n\tif (sset == ETH_SS_STATS)\n\t\tmemcpy(data, mt7996_gstrings_stats,\n\t\t       sizeof(mt7996_gstrings_stats));\n}\n\nstatic\nint mt7996_get_et_sset_count(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif, int sset)\n{\n\tif (sset == ETH_SS_STATS)\n\t\treturn MT7996_SSTATS_LEN;\n\n\treturn 0;\n}\n\nstatic void mt7996_ethtool_worker(void *wi_data, struct ieee80211_sta *sta)\n{\n\tstruct mt76_ethtool_worker_info *wi = wi_data;\n\tstruct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;\n\n\tif (msta->vif->mt76.idx != wi->idx)\n\t\treturn;\n\n\tmt76_ethtool_worker(wi, &msta->wcid.stats, true);\n}\n\nstatic\nvoid mt7996_get_et_stats(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t struct ethtool_stats *stats, u64 *data)\n{\n\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\tstruct mt7996_phy *phy = mt7996_hw_phy(hw);\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tstruct mt76_mib_stats *mib = &phy->mib;\n\tstruct mt76_ethtool_worker_info wi = {\n\t\t.data = data,\n\t\t.idx = mvif->mt76.idx,\n\t};\n\t \n\tint i, ei = 0;\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tmt7996_mac_update_stats(phy);\n\n\tdata[ei++] = mib->tx_ampdu_cnt;\n\tdata[ei++] = mib->tx_stop_q_empty_cnt;\n\tdata[ei++] = mib->tx_mpdu_attempts_cnt;\n\tdata[ei++] = mib->tx_mpdu_success_cnt;\n\tdata[ei++] = mib->tx_rwp_fail_cnt;\n\tdata[ei++] = mib->tx_rwp_need_cnt;\n\tdata[ei++] = mib->tx_bf_ebf_ppdu_cnt;\n\tdata[ei++] = mib->tx_bf_ibf_ppdu_cnt;\n\n\t \n\tfor (i = 0; i < 15  ; i++)\n\t\tdata[ei++] = phy->mt76->aggr_stats[i];\n\tdata[ei++] = phy->mib.ba_miss_cnt;\n\n\t \n\tdata[ei++] = mib->tx_bf_ibf_ppdu_cnt;\n\tdata[ei++] = mib->tx_bf_ebf_ppdu_cnt;\n\n\t \n\tdata[ei++] = mib->tx_bf_rx_fb_all_cnt;\n\tdata[ei++] = mib->tx_bf_rx_fb_he_cnt;\n\tdata[ei++] = mib->tx_bf_rx_fb_vht_cnt;\n\tdata[ei++] = mib->tx_bf_rx_fb_ht_cnt;\n\n\tdata[ei++] = mib->tx_bf_rx_fb_bw;\n\tdata[ei++] = mib->tx_bf_rx_fb_nc_cnt;\n\tdata[ei++] = mib->tx_bf_rx_fb_nr_cnt;\n\n\t \n\tdata[ei++] = mib->tx_bf_fb_cpl_cnt;\n\tdata[ei++] = mib->tx_bf_fb_trig_cnt;\n\n\t \n\tdata[ei++] = mib->tx_mu_bf_cnt;\n\tdata[ei++] = mib->tx_mu_mpdu_cnt;\n\tdata[ei++] = mib->tx_mu_acked_mpdu_cnt;\n\tdata[ei++] = mib->tx_su_acked_mpdu_cnt;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(mib->tx_amsdu); i++)\n\t\tdata[ei++] = mib->tx_amsdu[i];\n\n\t \n\tdata[ei++] = mib->rx_fifo_full_cnt;\n\tdata[ei++] = mib->rx_mpdu_cnt;\n\tdata[ei++] = mib->channel_idle_cnt;\n\tdata[ei++] = mib->rx_vector_mismatch_cnt;\n\tdata[ei++] = mib->rx_delimiter_fail_cnt;\n\tdata[ei++] = mib->rx_len_mismatch_cnt;\n\tdata[ei++] = mib->rx_ampdu_cnt;\n\tdata[ei++] = mib->rx_ampdu_bytes_cnt;\n\tdata[ei++] = mib->rx_ampdu_valid_subframe_cnt;\n\tdata[ei++] = mib->rx_ampdu_valid_subframe_bytes_cnt;\n\tdata[ei++] = mib->rx_pfdrop_cnt;\n\tdata[ei++] = mib->rx_vec_queue_overflow_drop_cnt;\n\tdata[ei++] = mib->rx_ba_cnt;\n\n\t \n\twi.initial_stat_idx = ei;\n\tieee80211_iterate_stations_atomic(hw, mt7996_ethtool_worker, &wi);\n\n\tmutex_unlock(&dev->mt76.mutex);\n\n\tif (wi.sta_count == 0)\n\t\treturn;\n\n\tei += wi.worker_stat_count;\n\tif (ei != MT7996_SSTATS_LEN)\n\t\tdev_err(dev->mt76.dev, \"ei: %d  MT7996_SSTATS_LEN: %d\",\n\t\t\tei, (int)MT7996_SSTATS_LEN);\n}\n\nstatic void\nmt7996_twt_teardown_request(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_sta *sta,\n\t\t\t    u8 flowid)\n{\n\tstruct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;\n\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\n\tmutex_lock(&dev->mt76.mutex);\n\tmt7996_mac_twt_teardown_flow(dev, msta, flowid);\n\tmutex_unlock(&dev->mt76.mutex);\n}\n\nstatic int\nmt7996_set_radar_background(struct ieee80211_hw *hw,\n\t\t\t    struct cfg80211_chan_def *chandef)\n{\n\tstruct mt7996_phy *phy = mt7996_hw_phy(hw);\n\tstruct mt7996_dev *dev = phy->dev;\n\tint ret = -EINVAL;\n\tbool running;\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tif (dev->mt76.region == NL80211_DFS_UNSET)\n\t\tgoto out;\n\n\tif (dev->rdd2_phy && dev->rdd2_phy != phy) {\n\t\t \n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\trunning = dev->rdd2_phy &&\n\t\t  cfg80211_chandef_valid(&dev->rdd2_chandef) &&\n\t\t  !!(dev->rdd2_chandef.chan->flags & IEEE80211_CHAN_RADAR);\n\n\tif (!chandef || running ||\n\t    !(chandef->chan->flags & IEEE80211_CHAN_RADAR)) {\n\t\tret = mt7996_mcu_rdd_background_enable(phy, NULL);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (!running)\n\t\t\tgoto update_phy;\n\t}\n\n\tret = mt7996_mcu_rdd_background_enable(phy, chandef);\n\tif (ret)\n\t\tgoto out;\n\nupdate_phy:\n\tdev->rdd2_phy = chandef ? phy : NULL;\n\tif (chandef)\n\t\tdev->rdd2_chandef = *chandef;\nout:\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn ret;\n}\n\nconst struct ieee80211_ops mt7996_ops = {\n\t.tx = mt7996_tx,\n\t.start = mt7996_start,\n\t.stop = mt7996_stop,\n\t.add_interface = mt7996_add_interface,\n\t.remove_interface = mt7996_remove_interface,\n\t.config = mt7996_config,\n\t.conf_tx = mt7996_conf_tx,\n\t.configure_filter = mt7996_configure_filter,\n\t.bss_info_changed = mt7996_bss_info_changed,\n\t.sta_add = mt7996_sta_add,\n\t.sta_remove = mt7996_sta_remove,\n\t.sta_pre_rcu_remove = mt76_sta_pre_rcu_remove,\n\t.sta_rc_update = mt7996_sta_rc_update,\n\t.set_key = mt7996_set_key,\n\t.ampdu_action = mt7996_ampdu_action,\n\t.set_rts_threshold = mt7996_set_rts_threshold,\n\t.wake_tx_queue = mt76_wake_tx_queue,\n\t.sw_scan_start = mt76_sw_scan,\n\t.sw_scan_complete = mt76_sw_scan_complete,\n\t.release_buffered_frames = mt76_release_buffered_frames,\n\t.get_txpower = mt76_get_txpower,\n\t.channel_switch_beacon = mt7996_channel_switch_beacon,\n\t.get_stats = mt7996_get_stats,\n\t.get_et_sset_count = mt7996_get_et_sset_count,\n\t.get_et_stats = mt7996_get_et_stats,\n\t.get_et_strings = mt7996_get_et_strings,\n\t.get_tsf = mt7996_get_tsf,\n\t.set_tsf = mt7996_set_tsf,\n\t.offset_tsf = mt7996_offset_tsf,\n\t.get_survey = mt76_get_survey,\n\t.get_antenna = mt76_get_antenna,\n\t.set_antenna = mt7996_set_antenna,\n\t.set_bitrate_mask = mt7996_set_bitrate_mask,\n\t.set_coverage_class = mt7996_set_coverage_class,\n\t.sta_statistics = mt7996_sta_statistics,\n\t.sta_set_4addr = mt7996_sta_set_4addr,\n\t.sta_set_decap_offload = mt7996_sta_set_decap_offload,\n\t.add_twt_setup = mt7996_mac_add_twt_setup,\n\t.twt_teardown_request = mt7996_twt_teardown_request,\n#ifdef CONFIG_MAC80211_DEBUGFS\n\t.sta_add_debugfs = mt7996_sta_add_debugfs,\n#endif\n\t.set_radar_background = mt7996_set_radar_background,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}