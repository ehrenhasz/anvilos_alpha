{
  "module_name": "mcu.c",
  "hash_id": "c9dc754e155814826df42684e256ea80776fee17f3a17cfe41cb7115b9002e0f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7996/mcu.c",
  "human_readable_source": "\n \n\n#include <linux/firmware.h>\n#include <linux/fs.h>\n#include \"mt7996.h\"\n#include \"mcu.h\"\n#include \"mac.h\"\n#include \"eeprom.h\"\n\nstruct mt7996_patch_hdr {\n\tchar build_date[16];\n\tchar platform[4];\n\t__be32 hw_sw_ver;\n\t__be32 patch_ver;\n\t__be16 checksum;\n\tu16 reserved;\n\tstruct {\n\t\t__be32 patch_ver;\n\t\t__be32 subsys;\n\t\t__be32 feature;\n\t\t__be32 n_region;\n\t\t__be32 crc;\n\t\tu32 reserved[11];\n\t} desc;\n} __packed;\n\nstruct mt7996_patch_sec {\n\t__be32 type;\n\t__be32 offs;\n\t__be32 size;\n\tunion {\n\t\t__be32 spec[13];\n\t\tstruct {\n\t\t\t__be32 addr;\n\t\t\t__be32 len;\n\t\t\t__be32 sec_key_idx;\n\t\t\t__be32 align_len;\n\t\t\tu32 reserved[9];\n\t\t} info;\n\t};\n} __packed;\n\nstruct mt7996_fw_trailer {\n\tu8 chip_id;\n\tu8 eco_code;\n\tu8 n_region;\n\tu8 format_ver;\n\tu8 format_flag;\n\tu8 reserved[2];\n\tchar fw_ver[10];\n\tchar build_date[15];\n\tu32 crc;\n} __packed;\n\nstruct mt7996_fw_region {\n\t__le32 decomp_crc;\n\t__le32 decomp_len;\n\t__le32 decomp_blk_sz;\n\tu8 reserved[4];\n\t__le32 addr;\n\t__le32 len;\n\tu8 feature_set;\n\tu8 reserved1[15];\n} __packed;\n\n#define MCU_PATCH_ADDRESS\t\t0x200000\n\n#define HE_PHY(p, c)\t\t\tu8_get_bits(c, IEEE80211_HE_PHY_##p)\n#define HE_MAC(m, c)\t\t\tu8_get_bits(c, IEEE80211_HE_MAC_##m)\n#define EHT_PHY(p, c)\t\t\tu8_get_bits(c, IEEE80211_EHT_PHY_##p)\n\nstatic bool sr_scene_detect = true;\nmodule_param(sr_scene_detect, bool, 0644);\nMODULE_PARM_DESC(sr_scene_detect, \"Enable firmware scene detection algorithm\");\n\nstatic u8\nmt7996_mcu_get_sta_nss(u16 mcs_map)\n{\n\tu8 nss;\n\n\tfor (nss = 8; nss > 0; nss--) {\n\t\tu8 nss_mcs = (mcs_map >> (2 * (nss - 1))) & 3;\n\n\t\tif (nss_mcs != IEEE80211_VHT_MCS_NOT_SUPPORTED)\n\t\t\tbreak;\n\t}\n\n\treturn nss - 1;\n}\n\nstatic void\nmt7996_mcu_set_sta_he_mcs(struct ieee80211_sta *sta, __le16 *he_mcs,\n\t\t\t  u16 mcs_map)\n{\n\tstruct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;\n\tenum nl80211_band band = msta->vif->phy->mt76->chandef.chan->band;\n\tconst u16 *mask = msta->vif->bitrate_mask.control[band].he_mcs;\n\tint nss, max_nss = sta->deflink.rx_nss > 3 ? 4 : sta->deflink.rx_nss;\n\n\tfor (nss = 0; nss < max_nss; nss++) {\n\t\tint mcs;\n\n\t\tswitch ((mcs_map >> (2 * nss)) & 0x3) {\n\t\tcase IEEE80211_HE_MCS_SUPPORT_0_11:\n\t\t\tmcs = GENMASK(11, 0);\n\t\t\tbreak;\n\t\tcase IEEE80211_HE_MCS_SUPPORT_0_9:\n\t\t\tmcs = GENMASK(9, 0);\n\t\t\tbreak;\n\t\tcase IEEE80211_HE_MCS_SUPPORT_0_7:\n\t\t\tmcs = GENMASK(7, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmcs = 0;\n\t\t}\n\n\t\tmcs = mcs ? fls(mcs & mask[nss]) - 1 : -1;\n\n\t\tswitch (mcs) {\n\t\tcase 0 ... 7:\n\t\t\tmcs = IEEE80211_HE_MCS_SUPPORT_0_7;\n\t\t\tbreak;\n\t\tcase 8 ... 9:\n\t\t\tmcs = IEEE80211_HE_MCS_SUPPORT_0_9;\n\t\t\tbreak;\n\t\tcase 10 ... 11:\n\t\t\tmcs = IEEE80211_HE_MCS_SUPPORT_0_11;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmcs = IEEE80211_HE_MCS_NOT_SUPPORTED;\n\t\t\tbreak;\n\t\t}\n\t\tmcs_map &= ~(0x3 << (nss * 2));\n\t\tmcs_map |= mcs << (nss * 2);\n\t}\n\n\t*he_mcs = cpu_to_le16(mcs_map);\n}\n\nstatic void\nmt7996_mcu_set_sta_vht_mcs(struct ieee80211_sta *sta, __le16 *vht_mcs,\n\t\t\t   const u16 *mask)\n{\n\tu16 mcs, mcs_map = le16_to_cpu(sta->deflink.vht_cap.vht_mcs.rx_mcs_map);\n\tint nss, max_nss = sta->deflink.rx_nss > 3 ? 4 : sta->deflink.rx_nss;\n\n\tfor (nss = 0; nss < max_nss; nss++, mcs_map >>= 2) {\n\t\tswitch (mcs_map & 0x3) {\n\t\tcase IEEE80211_VHT_MCS_SUPPORT_0_9:\n\t\t\tmcs = GENMASK(9, 0);\n\t\t\tbreak;\n\t\tcase IEEE80211_VHT_MCS_SUPPORT_0_8:\n\t\t\tmcs = GENMASK(8, 0);\n\t\t\tbreak;\n\t\tcase IEEE80211_VHT_MCS_SUPPORT_0_7:\n\t\t\tmcs = GENMASK(7, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmcs = 0;\n\t\t}\n\n\t\tvht_mcs[nss] = cpu_to_le16(mcs & mask[nss]);\n\t}\n}\n\nstatic void\nmt7996_mcu_set_sta_ht_mcs(struct ieee80211_sta *sta, u8 *ht_mcs,\n\t\t\t  const u8 *mask)\n{\n\tint nss, max_nss = sta->deflink.rx_nss > 3 ? 4 : sta->deflink.rx_nss;\n\n\tfor (nss = 0; nss < max_nss; nss++)\n\t\tht_mcs[nss] = sta->deflink.ht_cap.mcs.rx_mask[nss] & mask[nss];\n}\n\nstatic int\nmt7996_mcu_parse_response(struct mt76_dev *mdev, int cmd,\n\t\t\t  struct sk_buff *skb, int seq)\n{\n\tstruct mt7996_mcu_rxd *rxd;\n\tstruct mt7996_mcu_uni_event *event;\n\tint mcu_cmd = FIELD_GET(__MCU_CMD_FIELD_ID, cmd);\n\tint ret = 0;\n\n\tif (!skb) {\n\t\tdev_err(mdev->dev, \"Message %08x (seq %d) timeout\\n\",\n\t\t\tcmd, seq);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\trxd = (struct mt7996_mcu_rxd *)skb->data;\n\tif (seq != rxd->seq)\n\t\treturn -EAGAIN;\n\n\tif (cmd == MCU_CMD(PATCH_SEM_CONTROL)) {\n\t\tskb_pull(skb, sizeof(*rxd) - 4);\n\t\tret = *skb->data;\n\t} else if ((rxd->option & MCU_UNI_CMD_EVENT) &&\n\t\t    rxd->eid == MCU_UNI_EVENT_RESULT) {\n\t\tskb_pull(skb, sizeof(*rxd));\n\t\tevent = (struct mt7996_mcu_uni_event *)skb->data;\n\t\tret = le32_to_cpu(event->status);\n\t\t \n\t\tif (mcu_cmd != event->cid)\n\t\t\tret = -EAGAIN;\n\t} else {\n\t\tskb_pull(skb, sizeof(struct mt7996_mcu_rxd));\n\t}\n\n\treturn ret;\n}\n\nstatic int\nmt7996_mcu_send_message(struct mt76_dev *mdev, struct sk_buff *skb,\n\t\t\tint cmd, int *wait_seq)\n{\n\tstruct mt7996_dev *dev = container_of(mdev, struct mt7996_dev, mt76);\n\tint txd_len, mcu_cmd = FIELD_GET(__MCU_CMD_FIELD_ID, cmd);\n\tstruct mt76_connac2_mcu_uni_txd *uni_txd;\n\tstruct mt76_connac2_mcu_txd *mcu_txd;\n\tenum mt76_mcuq_id qid;\n\t__le32 *txd;\n\tu32 val;\n\tu8 seq;\n\n\tmdev->mcu.timeout = 20 * HZ;\n\n\tseq = ++dev->mt76.mcu.msg_seq & 0xf;\n\tif (!seq)\n\t\tseq = ++dev->mt76.mcu.msg_seq & 0xf;\n\n\tif (cmd == MCU_CMD(FW_SCATTER)) {\n\t\tqid = MT_MCUQ_FWDL;\n\t\tgoto exit;\n\t}\n\n\ttxd_len = cmd & __MCU_CMD_FIELD_UNI ? sizeof(*uni_txd) : sizeof(*mcu_txd);\n\ttxd = (__le32 *)skb_push(skb, txd_len);\n\tif (test_bit(MT76_STATE_MCU_RUNNING, &dev->mphy.state))\n\t\tqid = MT_MCUQ_WA;\n\telse\n\t\tqid = MT_MCUQ_WM;\n\n\tval = FIELD_PREP(MT_TXD0_TX_BYTES, skb->len) |\n\t      FIELD_PREP(MT_TXD0_PKT_FMT, MT_TX_TYPE_CMD) |\n\t      FIELD_PREP(MT_TXD0_Q_IDX, MT_TX_MCU_PORT_RX_Q0);\n\ttxd[0] = cpu_to_le32(val);\n\n\tval = FIELD_PREP(MT_TXD1_HDR_FORMAT, MT_HDR_FORMAT_CMD);\n\ttxd[1] = cpu_to_le32(val);\n\n\tif (cmd & __MCU_CMD_FIELD_UNI) {\n\t\tuni_txd = (struct mt76_connac2_mcu_uni_txd *)txd;\n\t\tuni_txd->len = cpu_to_le16(skb->len - sizeof(uni_txd->txd));\n\t\tuni_txd->cid = cpu_to_le16(mcu_cmd);\n\t\tuni_txd->s2d_index = MCU_S2D_H2CN;\n\t\tuni_txd->pkt_type = MCU_PKT_ID;\n\t\tuni_txd->seq = seq;\n\n\t\tif (cmd & __MCU_CMD_FIELD_QUERY)\n\t\t\tuni_txd->option = MCU_CMD_UNI_QUERY_ACK;\n\t\telse\n\t\t\tuni_txd->option = MCU_CMD_UNI_EXT_ACK;\n\n\t\tif ((cmd & __MCU_CMD_FIELD_WA) && (cmd & __MCU_CMD_FIELD_WM))\n\t\t\tuni_txd->s2d_index = MCU_S2D_H2CN;\n\t\telse if (cmd & __MCU_CMD_FIELD_WA)\n\t\t\tuni_txd->s2d_index = MCU_S2D_H2C;\n\t\telse if (cmd & __MCU_CMD_FIELD_WM)\n\t\t\tuni_txd->s2d_index = MCU_S2D_H2N;\n\n\t\tgoto exit;\n\t}\n\n\tmcu_txd = (struct mt76_connac2_mcu_txd *)txd;\n\tmcu_txd->len = cpu_to_le16(skb->len - sizeof(mcu_txd->txd));\n\tmcu_txd->pq_id = cpu_to_le16(MCU_PQ_ID(MT_TX_PORT_IDX_MCU,\n\t\t\t\t\t       MT_TX_MCU_PORT_RX_Q0));\n\tmcu_txd->pkt_type = MCU_PKT_ID;\n\tmcu_txd->seq = seq;\n\n\tmcu_txd->cid = FIELD_GET(__MCU_CMD_FIELD_ID, cmd);\n\tmcu_txd->set_query = MCU_Q_NA;\n\tmcu_txd->ext_cid = FIELD_GET(__MCU_CMD_FIELD_EXT_ID, cmd);\n\tif (mcu_txd->ext_cid) {\n\t\tmcu_txd->ext_cid_ack = 1;\n\n\t\tif (cmd & __MCU_CMD_FIELD_QUERY)\n\t\t\tmcu_txd->set_query = MCU_Q_QUERY;\n\t\telse\n\t\t\tmcu_txd->set_query = MCU_Q_SET;\n\t}\n\n\tif (cmd & __MCU_CMD_FIELD_WA)\n\t\tmcu_txd->s2d_index = MCU_S2D_H2C;\n\telse\n\t\tmcu_txd->s2d_index = MCU_S2D_H2N;\n\nexit:\n\tif (wait_seq)\n\t\t*wait_seq = seq;\n\n\treturn mt76_tx_queue_skb_raw(dev, mdev->q_mcu[qid], skb, 0);\n}\n\nint mt7996_mcu_wa_cmd(struct mt7996_dev *dev, int cmd, u32 a1, u32 a2, u32 a3)\n{\n\tstruct {\n\t\t__le32 args[3];\n\t} req = {\n\t\t.args = {\n\t\t\tcpu_to_le32(a1),\n\t\t\tcpu_to_le32(a2),\n\t\t\tcpu_to_le32(a3),\n\t\t},\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, cmd, &req, sizeof(req), false);\n}\n\nstatic void\nmt7996_mcu_csa_finish(void *priv, u8 *mac, struct ieee80211_vif *vif)\n{\n\tif (vif->bss_conf.csa_active)\n\t\tieee80211_csa_finish(vif);\n}\n\nstatic void\nmt7996_mcu_rx_radar_detected(struct mt7996_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt76_phy *mphy = &dev->mt76.phy;\n\tstruct mt7996_mcu_rdd_report *r;\n\n\tr = (struct mt7996_mcu_rdd_report *)skb->data;\n\n\tif (r->band_idx >= ARRAY_SIZE(dev->mt76.phys))\n\t\treturn;\n\n\tif (dev->rdd2_phy && r->band_idx == MT_RX_SEL2)\n\t\tmphy = dev->rdd2_phy->mt76;\n\telse\n\t\tmphy = dev->mt76.phys[r->band_idx];\n\n\tif (!mphy)\n\t\treturn;\n\n\tif (r->band_idx == MT_RX_SEL2)\n\t\tcfg80211_background_radar_event(mphy->hw->wiphy,\n\t\t\t\t\t\t&dev->rdd2_chandef,\n\t\t\t\t\t\tGFP_ATOMIC);\n\telse\n\t\tieee80211_radar_detected(mphy->hw);\n\tdev->hw_pattern++;\n}\n\nstatic void\nmt7996_mcu_rx_log_message(struct mt7996_dev *dev, struct sk_buff *skb)\n{\n#define UNI_EVENT_FW_LOG_FORMAT 0\n\tstruct mt7996_mcu_rxd *rxd = (struct mt7996_mcu_rxd *)skb->data;\n\tconst char *data = (char *)&rxd[1] + 4, *type;\n\tstruct tlv *tlv = (struct tlv *)data;\n\tint len;\n\n\tif (!(rxd->option & MCU_UNI_CMD_EVENT)) {\n\t\tlen = skb->len - sizeof(*rxd);\n\t\tdata = (char *)&rxd[1];\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(tlv->tag) != UNI_EVENT_FW_LOG_FORMAT)\n\t\treturn;\n\n\tdata += sizeof(*tlv) + 4;\n\tlen = le16_to_cpu(tlv->len) - sizeof(*tlv) - 4;\n\nout:\n\tswitch (rxd->s2d_index) {\n\tcase 0:\n\t\tif (mt7996_debugfs_rx_log(dev, data, len))\n\t\t\treturn;\n\n\t\ttype = \"WM\";\n\t\tbreak;\n\tcase 2:\n\t\ttype = \"WA\";\n\t\tbreak;\n\tdefault:\n\t\ttype = \"unknown\";\n\t\tbreak;\n\t}\n\n\twiphy_info(mt76_hw(dev)->wiphy, \"%s: %.*s\", type, len, data);\n}\n\nstatic void\nmt7996_mcu_cca_finish(void *priv, u8 *mac, struct ieee80211_vif *vif)\n{\n\tif (!vif->bss_conf.color_change_active)\n\t\treturn;\n\n\tieee80211_color_change_finish(vif);\n}\n\nstatic void\nmt7996_mcu_ie_countdown(struct mt7996_dev *dev, struct sk_buff *skb)\n{\n#define UNI_EVENT_IE_COUNTDOWN_CSA 0\n#define UNI_EVENT_IE_COUNTDOWN_BCC 1\n\tstruct header {\n\t\tu8 band;\n\t\tu8 rsv[3];\n\t};\n\tstruct mt76_phy *mphy = &dev->mt76.phy;\n\tstruct mt7996_mcu_rxd *rxd = (struct mt7996_mcu_rxd *)skb->data;\n\tconst char *data = (char *)&rxd[1], *tail;\n\tstruct header *hdr = (struct header *)data;\n\tstruct tlv *tlv = (struct tlv *)(data + 4);\n\n\tif (hdr->band >= ARRAY_SIZE(dev->mt76.phys))\n\t\treturn;\n\n\tif (hdr->band && dev->mt76.phys[hdr->band])\n\t\tmphy = dev->mt76.phys[hdr->band];\n\n\ttail = skb->data + skb->len;\n\tdata += sizeof(struct header);\n\twhile (data + sizeof(struct tlv) < tail && le16_to_cpu(tlv->len)) {\n\t\tswitch (le16_to_cpu(tlv->tag)) {\n\t\tcase UNI_EVENT_IE_COUNTDOWN_CSA:\n\t\t\tieee80211_iterate_active_interfaces_atomic(mphy->hw,\n\t\t\t\t\tIEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\t\t\tmt7996_mcu_csa_finish, mphy->hw);\n\t\t\tbreak;\n\t\tcase UNI_EVENT_IE_COUNTDOWN_BCC:\n\t\t\tieee80211_iterate_active_interfaces_atomic(mphy->hw,\n\t\t\t\t\tIEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\t\t\tmt7996_mcu_cca_finish, mphy->hw);\n\t\t\tbreak;\n\t\t}\n\n\t\tdata += le16_to_cpu(tlv->len);\n\t\ttlv = (struct tlv *)data;\n\t}\n}\n\nstatic void\nmt7996_mcu_rx_ext_event(struct mt7996_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt7996_mcu_rxd *rxd = (struct mt7996_mcu_rxd *)skb->data;\n\n\tswitch (rxd->ext_eid) {\n\tcase MCU_EXT_EVENT_FW_LOG_2_HOST:\n\t\tmt7996_mcu_rx_log_message(dev, skb);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\nmt7996_mcu_rx_unsolicited_event(struct mt7996_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt7996_mcu_rxd *rxd = (struct mt7996_mcu_rxd *)skb->data;\n\n\tswitch (rxd->eid) {\n\tcase MCU_EVENT_EXT:\n\t\tmt7996_mcu_rx_ext_event(dev, skb);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tdev_kfree_skb(skb);\n}\n\nstatic void\nmt7996_mcu_uni_rx_unsolicited_event(struct mt7996_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt7996_mcu_rxd *rxd = (struct mt7996_mcu_rxd *)skb->data;\n\n\tswitch (rxd->eid) {\n\tcase MCU_UNI_EVENT_FW_LOG_2_HOST:\n\t\tmt7996_mcu_rx_log_message(dev, skb);\n\t\tbreak;\n\tcase MCU_UNI_EVENT_IE_COUNTDOWN:\n\t\tmt7996_mcu_ie_countdown(dev, skb);\n\t\tbreak;\n\tcase MCU_UNI_EVENT_RDD_REPORT:\n\t\tmt7996_mcu_rx_radar_detected(dev, skb);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tdev_kfree_skb(skb);\n}\n\nvoid mt7996_mcu_rx_event(struct mt7996_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt7996_mcu_rxd *rxd = (struct mt7996_mcu_rxd *)skb->data;\n\n\tif (rxd->option & MCU_UNI_CMD_UNSOLICITED_EVENT) {\n\t\tmt7996_mcu_uni_rx_unsolicited_event(dev, skb);\n\t\treturn;\n\t}\n\n\t \n\tif (rxd->ext_eid == MCU_EXT_EVENT_FW_LOG_2_HOST ||\n\t    !rxd->seq)\n\t\tmt7996_mcu_rx_unsolicited_event(dev, skb);\n\telse\n\t\tmt76_mcu_rx_event(&dev->mt76, skb);\n}\n\nstatic struct tlv *\nmt7996_mcu_add_uni_tlv(struct sk_buff *skb, u16 tag, u16 len)\n{\n\tstruct tlv *ptlv, tlv = {\n\t\t.tag = cpu_to_le16(tag),\n\t\t.len = cpu_to_le16(len),\n\t};\n\n\tptlv = skb_put(skb, len);\n\tmemcpy(ptlv, &tlv, sizeof(tlv));\n\n\treturn ptlv;\n}\n\nstatic void\nmt7996_mcu_bss_rfch_tlv(struct sk_buff *skb, struct ieee80211_vif *vif,\n\t\t\tstruct mt7996_phy *phy)\n{\n\tstatic const u8 rlm_ch_band[] = {\n\t\t[NL80211_BAND_2GHZ] = 1,\n\t\t[NL80211_BAND_5GHZ] = 2,\n\t\t[NL80211_BAND_6GHZ] = 3,\n\t};\n\tstruct cfg80211_chan_def *chandef = &phy->mt76->chandef;\n\tstruct bss_rlm_tlv *ch;\n\tstruct tlv *tlv;\n\tint freq1 = chandef->center_freq1;\n\n\ttlv = mt7996_mcu_add_uni_tlv(skb, UNI_BSS_INFO_RLM, sizeof(*ch));\n\n\tch = (struct bss_rlm_tlv *)tlv;\n\tch->control_channel = chandef->chan->hw_value;\n\tch->center_chan = ieee80211_frequency_to_channel(freq1);\n\tch->bw = mt76_connac_chan_bw(chandef);\n\tch->tx_streams = hweight8(phy->mt76->antenna_mask);\n\tch->rx_streams = hweight8(phy->mt76->antenna_mask);\n\tch->band = rlm_ch_band[chandef->chan->band];\n\n\tif (chandef->width == NL80211_CHAN_WIDTH_80P80) {\n\t\tint freq2 = chandef->center_freq2;\n\n\t\tch->center_chan2 = ieee80211_frequency_to_channel(freq2);\n\t}\n}\n\nstatic void\nmt7996_mcu_bss_ra_tlv(struct sk_buff *skb, struct ieee80211_vif *vif,\n\t\t      struct mt7996_phy *phy)\n{\n\tstruct bss_ra_tlv *ra;\n\tstruct tlv *tlv;\n\n\ttlv = mt7996_mcu_add_uni_tlv(skb, UNI_BSS_INFO_RA, sizeof(*ra));\n\n\tra = (struct bss_ra_tlv *)tlv;\n\tra->short_preamble = true;\n}\n\nstatic void\nmt7996_mcu_bss_he_tlv(struct sk_buff *skb, struct ieee80211_vif *vif,\n\t\t      struct mt7996_phy *phy)\n{\n#define DEFAULT_HE_PE_DURATION\t\t4\n#define DEFAULT_HE_DURATION_RTS_THRES\t1023\n\tconst struct ieee80211_sta_he_cap *cap;\n\tstruct bss_info_uni_he *he;\n\tstruct tlv *tlv;\n\n\tcap = mt76_connac_get_he_phy_cap(phy->mt76, vif);\n\n\ttlv = mt7996_mcu_add_uni_tlv(skb, UNI_BSS_INFO_HE_BASIC, sizeof(*he));\n\n\the = (struct bss_info_uni_he *)tlv;\n\the->he_pe_duration = vif->bss_conf.htc_trig_based_pkt_ext;\n\tif (!he->he_pe_duration)\n\t\the->he_pe_duration = DEFAULT_HE_PE_DURATION;\n\n\the->he_rts_thres = cpu_to_le16(vif->bss_conf.frame_time_rts_th);\n\tif (!he->he_rts_thres)\n\t\the->he_rts_thres = cpu_to_le16(DEFAULT_HE_DURATION_RTS_THRES);\n\n\the->max_nss_mcs[CMD_HE_MCS_BW80] = cap->he_mcs_nss_supp.tx_mcs_80;\n\the->max_nss_mcs[CMD_HE_MCS_BW160] = cap->he_mcs_nss_supp.tx_mcs_160;\n\the->max_nss_mcs[CMD_HE_MCS_BW8080] = cap->he_mcs_nss_supp.tx_mcs_80p80;\n}\n\nstatic void\nmt7996_mcu_bss_bmc_tlv(struct sk_buff *skb, struct ieee80211_vif *vif,\n\t\t       struct mt7996_phy *phy)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct bss_rate_tlv *bmc;\n\tstruct cfg80211_chan_def *chandef = &phy->mt76->chandef;\n\tenum nl80211_band band = chandef->chan->band;\n\tstruct tlv *tlv;\n\tu8 idx = mvif->mcast_rates_idx ?\n\t\t mvif->mcast_rates_idx : mvif->basic_rates_idx;\n\n\ttlv = mt7996_mcu_add_uni_tlv(skb, UNI_BSS_INFO_RATE, sizeof(*bmc));\n\n\tbmc = (struct bss_rate_tlv *)tlv;\n\n\tbmc->short_preamble = (band == NL80211_BAND_2GHZ);\n\tbmc->bc_fixed_rate = idx;\n\tbmc->mc_fixed_rate = idx;\n}\n\nstatic void\nmt7996_mcu_bss_txcmd_tlv(struct sk_buff *skb, bool en)\n{\n\tstruct bss_txcmd_tlv *txcmd;\n\tstruct tlv *tlv;\n\n\ttlv = mt7996_mcu_add_uni_tlv(skb, UNI_BSS_INFO_TXCMD, sizeof(*txcmd));\n\n\ttxcmd = (struct bss_txcmd_tlv *)tlv;\n\ttxcmd->txcmd_mode = en;\n}\n\nstatic void\nmt7996_mcu_bss_mld_tlv(struct sk_buff *skb, struct ieee80211_vif *vif)\n{\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tstruct bss_mld_tlv *mld;\n\tstruct tlv *tlv;\n\n\ttlv = mt7996_mcu_add_uni_tlv(skb, UNI_BSS_INFO_MLD, sizeof(*mld));\n\n\tmld = (struct bss_mld_tlv *)tlv;\n\tmld->group_mld_id = 0xff;\n\tmld->own_mld_id = mvif->mt76.idx;\n\tmld->remap_idx = 0xff;\n}\n\nstatic void\nmt7996_mcu_bss_sec_tlv(struct sk_buff *skb, struct ieee80211_vif *vif)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct bss_sec_tlv *sec;\n\tstruct tlv *tlv;\n\n\ttlv = mt7996_mcu_add_uni_tlv(skb, UNI_BSS_INFO_SEC, sizeof(*sec));\n\n\tsec = (struct bss_sec_tlv *)tlv;\n\tsec->cipher = mvif->cipher;\n}\n\nstatic int\nmt7996_mcu_muar_config(struct mt7996_phy *phy, struct ieee80211_vif *vif,\n\t\t       bool bssid, bool enable)\n{\n#define UNI_MUAR_ENTRY 2\n\tstruct mt7996_dev *dev = phy->dev;\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tu32 idx = mvif->mt76.omac_idx - REPEATER_BSSID_START;\n\tconst u8 *addr = vif->addr;\n\n\tstruct {\n\t\tstruct {\n\t\t\tu8 band;\n\t\t\tu8 __rsv[3];\n\t\t} hdr;\n\n\t\t__le16 tag;\n\t\t__le16 len;\n\n\t\tbool smesh;\n\t\tu8 bssid;\n\t\tu8 index;\n\t\tu8 entry_add;\n\t\tu8 addr[ETH_ALEN];\n\t\tu8 __rsv[2];\n\t} __packed req = {\n\t\t.hdr.band = phy->mt76->band_idx,\n\t\t.tag = cpu_to_le16(UNI_MUAR_ENTRY),\n\t\t.len = cpu_to_le16(sizeof(req) - sizeof(req.hdr)),\n\t\t.smesh = false,\n\t\t.index = idx * 2 + bssid,\n\t\t.entry_add = true,\n\t};\n\n\tif (bssid)\n\t\taddr = vif->bss_conf.bssid;\n\n\tif (enable)\n\t\tmemcpy(req.addr, addr, ETH_ALEN);\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(REPT_MUAR), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nstatic void\nmt7996_mcu_bss_ifs_timing_tlv(struct sk_buff *skb, struct ieee80211_vif *vif)\n{\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tstruct mt7996_phy *phy = mvif->phy;\n\tstruct bss_ifs_time_tlv *ifs_time;\n\tstruct tlv *tlv;\n\tbool is_2ghz = phy->mt76->chandef.chan->band == NL80211_BAND_2GHZ;\n\n\ttlv = mt7996_mcu_add_uni_tlv(skb, UNI_BSS_INFO_IFS_TIME, sizeof(*ifs_time));\n\n\tifs_time = (struct bss_ifs_time_tlv *)tlv;\n\tifs_time->slot_valid = true;\n\tifs_time->sifs_valid = true;\n\tifs_time->rifs_valid = true;\n\tifs_time->eifs_valid = true;\n\n\tifs_time->slot_time = cpu_to_le16(phy->slottime);\n\tifs_time->sifs_time = cpu_to_le16(10);\n\tifs_time->rifs_time = cpu_to_le16(2);\n\tifs_time->eifs_time = cpu_to_le16(is_2ghz ? 78 : 84);\n\n\tif (is_2ghz) {\n\t\tifs_time->eifs_cck_valid = true;\n\t\tifs_time->eifs_cck_time = cpu_to_le16(314);\n\t}\n}\n\nstatic int\nmt7996_mcu_bss_basic_tlv(struct sk_buff *skb,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t struct ieee80211_sta *sta,\n\t\t\t struct mt76_phy *phy, u16 wlan_idx,\n\t\t\t bool enable)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct cfg80211_chan_def *chandef = &phy->chandef;\n\tstruct mt76_connac_bss_basic_tlv *bss;\n\tu32 type = CONNECTION_INFRA_AP;\n\tu16 sta_wlan_idx = wlan_idx;\n\tstruct tlv *tlv;\n\tint idx;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (enable) {\n\t\t\trcu_read_lock();\n\t\t\tif (!sta)\n\t\t\t\tsta = ieee80211_find_sta(vif,\n\t\t\t\t\t\t\t vif->bss_conf.bssid);\n\t\t\t \n\t\t\tif (sta) {\n\t\t\t\tstruct mt76_wcid *wcid;\n\n\t\t\t\twcid = (struct mt76_wcid *)sta->drv_priv;\n\t\t\t\tsta_wlan_idx = wcid->idx;\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t}\n\t\ttype = CONNECTION_INFRA_STA;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\ttype = CONNECTION_IBSS_ADHOC;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\ttlv = mt7996_mcu_add_uni_tlv(skb, UNI_BSS_INFO_BASIC, sizeof(*bss));\n\n\tbss = (struct mt76_connac_bss_basic_tlv *)tlv;\n\tbss->bcn_interval = cpu_to_le16(vif->bss_conf.beacon_int);\n\tbss->dtim_period = vif->bss_conf.dtim_period;\n\tbss->bmc_tx_wlan_idx = cpu_to_le16(wlan_idx);\n\tbss->sta_idx = cpu_to_le16(sta_wlan_idx);\n\tbss->conn_type = cpu_to_le32(type);\n\tbss->omac_idx = mvif->omac_idx;\n\tbss->band_idx = mvif->band_idx;\n\tbss->wmm_idx = mvif->wmm_idx;\n\tbss->conn_state = !enable;\n\tbss->active = enable;\n\n\tidx = mvif->omac_idx > EXT_BSSID_START ? HW_BSSID_0 : mvif->omac_idx;\n\tbss->hw_bss_idx = idx;\n\n\tif (vif->type == NL80211_IFTYPE_MONITOR) {\n\t\tmemcpy(bss->bssid, phy->macaddr, ETH_ALEN);\n\t\treturn 0;\n\t}\n\n\tmemcpy(bss->bssid, vif->bss_conf.bssid, ETH_ALEN);\n\tbss->bcn_interval = cpu_to_le16(vif->bss_conf.beacon_int);\n\tbss->dtim_period = vif->bss_conf.dtim_period;\n\tbss->phymode = mt76_connac_get_phy_mode(phy, vif,\n\t\t\t\t\t\tchandef->chan->band, NULL);\n\tbss->phymode_ext = mt76_connac_get_phy_mode_ext(phy, vif,\n\t\t\t\t\t\t\tchandef->chan->band);\n\n\treturn 0;\n}\n\nstatic struct sk_buff *\n__mt7996_mcu_alloc_bss_req(struct mt76_dev *dev, struct mt76_vif *mvif, int len)\n{\n\tstruct bss_req_hdr hdr = {\n\t\t.bss_idx = mvif->idx,\n\t};\n\tstruct sk_buff *skb;\n\n\tskb = mt76_mcu_msg_alloc(dev, NULL, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tskb_put_data(skb, &hdr, sizeof(hdr));\n\n\treturn skb;\n}\n\nint mt7996_mcu_add_bss_info(struct mt7996_phy *phy,\n\t\t\t    struct ieee80211_vif *vif, int enable)\n{\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tstruct mt7996_dev *dev = phy->dev;\n\tstruct sk_buff *skb;\n\n\tif (mvif->mt76.omac_idx >= REPEATER_BSSID_START) {\n\t\tmt7996_mcu_muar_config(phy, vif, false, enable);\n\t\tmt7996_mcu_muar_config(phy, vif, true, enable);\n\t}\n\n\tskb = __mt7996_mcu_alloc_bss_req(&dev->mt76, &mvif->mt76,\n\t\t\t\t\t MT7996_BSS_UPDATE_MAX_SIZE);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\t \n\tmt7996_mcu_bss_basic_tlv(skb, vif, NULL, phy->mt76,\n\t\t\t\t mvif->sta.wcid.idx, enable);\n\tmt7996_mcu_bss_sec_tlv(skb, vif);\n\n\tif (vif->type == NL80211_IFTYPE_MONITOR)\n\t\tgoto out;\n\n\tif (enable) {\n\t\tmt7996_mcu_bss_rfch_tlv(skb, vif, phy);\n\t\tmt7996_mcu_bss_bmc_tlv(skb, vif, phy);\n\t\tmt7996_mcu_bss_ra_tlv(skb, vif, phy);\n\t\tmt7996_mcu_bss_txcmd_tlv(skb, true);\n\t\tmt7996_mcu_bss_ifs_timing_tlv(skb, vif);\n\n\t\tif (vif->bss_conf.he_support)\n\t\t\tmt7996_mcu_bss_he_tlv(skb, vif, phy);\n\n\t\t \n\t\tmt7996_mcu_bss_mld_tlv(skb, vif);\n\t}\nout:\n\treturn mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t     MCU_WMWA_UNI_CMD(BSS_INFO_UPDATE), true);\n}\n\nint mt7996_mcu_set_timing(struct mt7996_phy *phy, struct ieee80211_vif *vif)\n{\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tstruct mt7996_dev *dev = phy->dev;\n\tstruct sk_buff *skb;\n\n\tskb = __mt7996_mcu_alloc_bss_req(&dev->mt76, &mvif->mt76,\n\t\t\t\t\t MT7996_BSS_UPDATE_MAX_SIZE);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tmt7996_mcu_bss_ifs_timing_tlv(skb, vif);\n\n\treturn mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t     MCU_WMWA_UNI_CMD(BSS_INFO_UPDATE), true);\n}\n\nstatic int\nmt7996_mcu_sta_ba(struct mt76_dev *dev, struct mt76_vif *mvif,\n\t\t  struct ieee80211_ampdu_params *params,\n\t\t  bool enable, bool tx)\n{\n\tstruct mt76_wcid *wcid = (struct mt76_wcid *)params->sta->drv_priv;\n\tstruct sta_rec_ba_uni *ba;\n\tstruct sk_buff *skb;\n\tstruct tlv *tlv;\n\n\tskb = __mt76_connac_mcu_alloc_sta_req(dev, mvif, wcid,\n\t\t\t\t\t      MT7996_STA_UPDATE_MAX_SIZE);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_BA, sizeof(*ba));\n\n\tba = (struct sta_rec_ba_uni *)tlv;\n\tba->ba_type = tx ? MT_BA_TYPE_ORIGINATOR : MT_BA_TYPE_RECIPIENT;\n\tba->winsize = cpu_to_le16(params->buf_size);\n\tba->ssn = cpu_to_le16(params->ssn);\n\tba->ba_en = enable << params->tid;\n\tba->amsdu = params->amsdu;\n\tba->tid = params->tid;\n\n\treturn mt76_mcu_skb_send_msg(dev, skb,\n\t\t\t\t     MCU_WMWA_UNI_CMD(STA_REC_UPDATE), true);\n}\n\n \nint mt7996_mcu_add_tx_ba(struct mt7996_dev *dev,\n\t\t\t struct ieee80211_ampdu_params *params,\n\t\t\t bool enable)\n{\n\tstruct mt7996_sta *msta = (struct mt7996_sta *)params->sta->drv_priv;\n\tstruct mt7996_vif *mvif = msta->vif;\n\n\tif (enable && !params->amsdu)\n\t\tmsta->wcid.amsdu = false;\n\n\treturn mt7996_mcu_sta_ba(&dev->mt76, &mvif->mt76, params,\n\t\t\t\t enable, true);\n}\n\nint mt7996_mcu_add_rx_ba(struct mt7996_dev *dev,\n\t\t\t struct ieee80211_ampdu_params *params,\n\t\t\t bool enable)\n{\n\tstruct mt7996_sta *msta = (struct mt7996_sta *)params->sta->drv_priv;\n\tstruct mt7996_vif *mvif = msta->vif;\n\n\treturn mt7996_mcu_sta_ba(&dev->mt76, &mvif->mt76, params,\n\t\t\t\t enable, false);\n}\n\nstatic void\nmt7996_mcu_sta_he_tlv(struct sk_buff *skb, struct ieee80211_sta *sta)\n{\n\tstruct ieee80211_he_cap_elem *elem = &sta->deflink.he_cap.he_cap_elem;\n\tstruct ieee80211_he_mcs_nss_supp mcs_map;\n\tstruct sta_rec_he_v2 *he;\n\tstruct tlv *tlv;\n\tint i = 0;\n\n\tif (!sta->deflink.he_cap.has_he)\n\t\treturn;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_HE_V2, sizeof(*he));\n\n\the = (struct sta_rec_he_v2 *)tlv;\n\tfor (i = 0; i < 11; i++) {\n\t\tif (i < 6)\n\t\t\the->he_mac_cap[i] = elem->mac_cap_info[i];\n\t\the->he_phy_cap[i] = elem->phy_cap_info[i];\n\t}\n\n\tmcs_map = sta->deflink.he_cap.he_mcs_nss_supp;\n\tswitch (sta->deflink.bandwidth) {\n\tcase IEEE80211_STA_RX_BW_160:\n\t\tif (elem->phy_cap_info[0] &\n\t\t    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G)\n\t\t\tmt7996_mcu_set_sta_he_mcs(sta,\n\t\t\t\t\t\t  &he->max_nss_mcs[CMD_HE_MCS_BW8080],\n\t\t\t\t\t\t  le16_to_cpu(mcs_map.rx_mcs_80p80));\n\n\t\tmt7996_mcu_set_sta_he_mcs(sta,\n\t\t\t\t\t  &he->max_nss_mcs[CMD_HE_MCS_BW160],\n\t\t\t\t\t  le16_to_cpu(mcs_map.rx_mcs_160));\n\t\tfallthrough;\n\tdefault:\n\t\tmt7996_mcu_set_sta_he_mcs(sta,\n\t\t\t\t\t  &he->max_nss_mcs[CMD_HE_MCS_BW80],\n\t\t\t\t\t  le16_to_cpu(mcs_map.rx_mcs_80));\n\t\tbreak;\n\t}\n\n\the->pkt_ext = 2;\n}\n\nstatic void\nmt7996_mcu_sta_he_6g_tlv(struct sk_buff *skb, struct ieee80211_sta *sta)\n{\n\tstruct sta_rec_he_6g_capa *he_6g;\n\tstruct tlv *tlv;\n\n\tif (!sta->deflink.he_6ghz_capa.capa)\n\t\treturn;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_HE_6G, sizeof(*he_6g));\n\n\the_6g = (struct sta_rec_he_6g_capa *)tlv;\n\the_6g->capa = sta->deflink.he_6ghz_capa.capa;\n}\n\nstatic void\nmt7996_mcu_sta_eht_tlv(struct sk_buff *skb, struct ieee80211_sta *sta)\n{\n\tstruct ieee80211_eht_mcs_nss_supp *mcs_map;\n\tstruct ieee80211_eht_cap_elem_fixed *elem;\n\tstruct sta_rec_eht *eht;\n\tstruct tlv *tlv;\n\n\tif (!sta->deflink.eht_cap.has_eht)\n\t\treturn;\n\n\tmcs_map = &sta->deflink.eht_cap.eht_mcs_nss_supp;\n\telem = &sta->deflink.eht_cap.eht_cap_elem;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_EHT, sizeof(*eht));\n\n\teht = (struct sta_rec_eht *)tlv;\n\teht->tid_bitmap = 0xff;\n\teht->mac_cap = cpu_to_le16(*(u16 *)elem->mac_cap_info);\n\teht->phy_cap = cpu_to_le64(*(u64 *)elem->phy_cap_info);\n\teht->phy_cap_ext = cpu_to_le64(elem->phy_cap_info[8]);\n\n\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_20)\n\t\tmemcpy(eht->mcs_map_bw20, &mcs_map->only_20mhz, sizeof(eht->mcs_map_bw20));\n\tmemcpy(eht->mcs_map_bw80, &mcs_map->bw._80, sizeof(eht->mcs_map_bw80));\n\tmemcpy(eht->mcs_map_bw160, &mcs_map->bw._160, sizeof(eht->mcs_map_bw160));\n\tmemcpy(eht->mcs_map_bw320, &mcs_map->bw._320, sizeof(eht->mcs_map_bw320));\n}\n\nstatic void\nmt7996_mcu_sta_ht_tlv(struct sk_buff *skb, struct ieee80211_sta *sta)\n{\n\tstruct sta_rec_ht *ht;\n\tstruct tlv *tlv;\n\n\tif (!sta->deflink.ht_cap.ht_supported)\n\t\treturn;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_HT, sizeof(*ht));\n\n\tht = (struct sta_rec_ht *)tlv;\n\tht->ht_cap = cpu_to_le16(sta->deflink.ht_cap.cap);\n}\n\nstatic void\nmt7996_mcu_sta_vht_tlv(struct sk_buff *skb, struct ieee80211_sta *sta)\n{\n\tstruct sta_rec_vht *vht;\n\tstruct tlv *tlv;\n\n\t \n\tif (!sta->deflink.he_6ghz_capa.capa && !sta->deflink.vht_cap.vht_supported)\n\t\treturn;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_VHT, sizeof(*vht));\n\n\tvht = (struct sta_rec_vht *)tlv;\n\tvht->vht_cap = cpu_to_le32(sta->deflink.vht_cap.cap);\n\tvht->vht_rx_mcs_map = sta->deflink.vht_cap.vht_mcs.rx_mcs_map;\n\tvht->vht_tx_mcs_map = sta->deflink.vht_cap.vht_mcs.tx_mcs_map;\n}\n\nstatic void\nmt7996_mcu_sta_amsdu_tlv(struct mt7996_dev *dev, struct sk_buff *skb,\n\t\t\t struct ieee80211_vif *vif, struct ieee80211_sta *sta)\n{\n\tstruct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;\n\tstruct sta_rec_amsdu *amsdu;\n\tstruct tlv *tlv;\n\n\tif (vif->type != NL80211_IFTYPE_STATION &&\n\t    vif->type != NL80211_IFTYPE_MESH_POINT &&\n\t    vif->type != NL80211_IFTYPE_AP)\n\t\treturn;\n\n\tif (!sta->deflink.agg.max_amsdu_len)\n\t\treturn;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_HW_AMSDU, sizeof(*amsdu));\n\tamsdu = (struct sta_rec_amsdu *)tlv;\n\tamsdu->max_amsdu_num = 8;\n\tamsdu->amsdu_en = true;\n\tmsta->wcid.amsdu = true;\n\n\tswitch (sta->deflink.agg.max_amsdu_len) {\n\tcase IEEE80211_MAX_MPDU_LEN_VHT_11454:\n\t\tamsdu->max_mpdu_size =\n\t\t\tIEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454;\n\t\treturn;\n\tcase IEEE80211_MAX_MPDU_LEN_HT_7935:\n\tcase IEEE80211_MAX_MPDU_LEN_VHT_7991:\n\t\tamsdu->max_mpdu_size = IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991;\n\t\treturn;\n\tdefault:\n\t\tamsdu->max_mpdu_size = IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_3895;\n\t\treturn;\n\t}\n}\n\nstatic void\nmt7996_mcu_sta_muru_tlv(struct mt7996_dev *dev, struct sk_buff *skb,\n\t\t\tstruct ieee80211_vif *vif, struct ieee80211_sta *sta)\n{\n\tstruct ieee80211_he_cap_elem *elem = &sta->deflink.he_cap.he_cap_elem;\n\tstruct sta_rec_muru *muru;\n\tstruct tlv *tlv;\n\n\tif (vif->type != NL80211_IFTYPE_STATION &&\n\t    vif->type != NL80211_IFTYPE_AP)\n\t\treturn;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_MURU, sizeof(*muru));\n\n\tmuru = (struct sta_rec_muru *)tlv;\n\tmuru->cfg.mimo_dl_en = vif->bss_conf.eht_mu_beamformer ||\n\t\t\t       vif->bss_conf.he_mu_beamformer ||\n\t\t\t       vif->bss_conf.vht_mu_beamformer ||\n\t\t\t       vif->bss_conf.vht_mu_beamformee;\n\tmuru->cfg.ofdma_dl_en = true;\n\n\tif (sta->deflink.vht_cap.vht_supported)\n\t\tmuru->mimo_dl.vht_mu_bfee =\n\t\t\t!!(sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE);\n\n\tif (!sta->deflink.he_cap.has_he)\n\t\treturn;\n\n\tmuru->mimo_dl.partial_bw_dl_mimo =\n\t\tHE_PHY(CAP6_PARTIAL_BANDWIDTH_DL_MUMIMO, elem->phy_cap_info[6]);\n\n\tmuru->mimo_ul.full_ul_mimo =\n\t\tHE_PHY(CAP2_UL_MU_FULL_MU_MIMO, elem->phy_cap_info[2]);\n\tmuru->mimo_ul.partial_ul_mimo =\n\t\tHE_PHY(CAP2_UL_MU_PARTIAL_MU_MIMO, elem->phy_cap_info[2]);\n\n\tmuru->ofdma_dl.punc_pream_rx =\n\t\tHE_PHY(CAP1_PREAMBLE_PUNC_RX_MASK, elem->phy_cap_info[1]);\n\tmuru->ofdma_dl.he_20m_in_40m_2g =\n\t\tHE_PHY(CAP8_20MHZ_IN_40MHZ_HE_PPDU_IN_2G, elem->phy_cap_info[8]);\n\tmuru->ofdma_dl.he_20m_in_160m =\n\t\tHE_PHY(CAP8_20MHZ_IN_160MHZ_HE_PPDU, elem->phy_cap_info[8]);\n\tmuru->ofdma_dl.he_80m_in_160m =\n\t\tHE_PHY(CAP8_80MHZ_IN_160MHZ_HE_PPDU, elem->phy_cap_info[8]);\n\n\tmuru->ofdma_ul.t_frame_dur =\n\t\tHE_MAC(CAP1_TF_MAC_PAD_DUR_MASK, elem->mac_cap_info[1]);\n\tmuru->ofdma_ul.mu_cascading =\n\t\tHE_MAC(CAP2_MU_CASCADING, elem->mac_cap_info[2]);\n\tmuru->ofdma_ul.uo_ra =\n\t\tHE_MAC(CAP3_OFDMA_RA, elem->mac_cap_info[3]);\n}\n\nstatic inline bool\nmt7996_is_ebf_supported(struct mt7996_phy *phy, struct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_sta *sta, bool bfee)\n{\n\tint sts = hweight16(phy->mt76->chainmask);\n\n\tif (vif->type != NL80211_IFTYPE_STATION &&\n\t    vif->type != NL80211_IFTYPE_AP)\n\t\treturn false;\n\n\tif (!bfee && sts < 2)\n\t\treturn false;\n\n\tif (sta->deflink.eht_cap.has_eht) {\n\t\tstruct ieee80211_sta_eht_cap *pc = &sta->deflink.eht_cap;\n\t\tstruct ieee80211_eht_cap_elem_fixed *pe = &pc->eht_cap_elem;\n\n\t\tif (bfee)\n\t\t\treturn vif->bss_conf.eht_su_beamformee &&\n\t\t\t       EHT_PHY(CAP0_SU_BEAMFORMEE, pe->phy_cap_info[0]);\n\t\telse\n\t\t\treturn vif->bss_conf.eht_su_beamformer &&\n\t\t\t       EHT_PHY(CAP0_SU_BEAMFORMER, pe->phy_cap_info[0]);\n\t}\n\n\tif (sta->deflink.he_cap.has_he) {\n\t\tstruct ieee80211_he_cap_elem *pe = &sta->deflink.he_cap.he_cap_elem;\n\n\t\tif (bfee)\n\t\t\treturn vif->bss_conf.he_su_beamformee &&\n\t\t\t       HE_PHY(CAP3_SU_BEAMFORMER, pe->phy_cap_info[3]);\n\t\telse\n\t\t\treturn vif->bss_conf.he_su_beamformer &&\n\t\t\t       HE_PHY(CAP4_SU_BEAMFORMEE, pe->phy_cap_info[4]);\n\t}\n\n\tif (sta->deflink.vht_cap.vht_supported) {\n\t\tu32 cap = sta->deflink.vht_cap.cap;\n\n\t\tif (bfee)\n\t\t\treturn vif->bss_conf.vht_su_beamformee &&\n\t\t\t       (cap & IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE);\n\t\telse\n\t\t\treturn vif->bss_conf.vht_su_beamformer &&\n\t\t\t       (cap & IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE);\n\t}\n\n\treturn false;\n}\n\nstatic void\nmt7996_mcu_sta_sounding_rate(struct sta_rec_bf *bf)\n{\n\tbf->sounding_phy = MT_PHY_TYPE_OFDM;\n\tbf->ndp_rate = 0;\t\t\t\t \n\tbf->ndpa_rate = MT7996_CFEND_RATE_DEFAULT;\t \n\tbf->rept_poll_rate = MT7996_CFEND_RATE_DEFAULT;\t \n}\n\nstatic void\nmt7996_mcu_sta_bfer_ht(struct ieee80211_sta *sta, struct mt7996_phy *phy,\n\t\t       struct sta_rec_bf *bf)\n{\n\tstruct ieee80211_mcs_info *mcs = &sta->deflink.ht_cap.mcs;\n\tu8 n = 0;\n\n\tbf->tx_mode = MT_PHY_TYPE_HT;\n\n\tif ((mcs->tx_params & IEEE80211_HT_MCS_TX_RX_DIFF) &&\n\t    (mcs->tx_params & IEEE80211_HT_MCS_TX_DEFINED))\n\t\tn = FIELD_GET(IEEE80211_HT_MCS_TX_MAX_STREAMS_MASK,\n\t\t\t      mcs->tx_params);\n\telse if (mcs->rx_mask[3])\n\t\tn = 3;\n\telse if (mcs->rx_mask[2])\n\t\tn = 2;\n\telse if (mcs->rx_mask[1])\n\t\tn = 1;\n\n\tbf->nrow = hweight8(phy->mt76->antenna_mask) - 1;\n\tbf->ncol = min_t(u8, bf->nrow, n);\n\tbf->ibf_ncol = n;\n}\n\nstatic void\nmt7996_mcu_sta_bfer_vht(struct ieee80211_sta *sta, struct mt7996_phy *phy,\n\t\t\tstruct sta_rec_bf *bf, bool explicit)\n{\n\tstruct ieee80211_sta_vht_cap *pc = &sta->deflink.vht_cap;\n\tstruct ieee80211_sta_vht_cap *vc = &phy->mt76->sband_5g.sband.vht_cap;\n\tu16 mcs_map = le16_to_cpu(pc->vht_mcs.rx_mcs_map);\n\tu8 nss_mcs = mt7996_mcu_get_sta_nss(mcs_map);\n\tu8 tx_ant = hweight8(phy->mt76->antenna_mask) - 1;\n\n\tbf->tx_mode = MT_PHY_TYPE_VHT;\n\n\tif (explicit) {\n\t\tu8 sts, snd_dim;\n\n\t\tmt7996_mcu_sta_sounding_rate(bf);\n\n\t\tsts = FIELD_GET(IEEE80211_VHT_CAP_BEAMFORMEE_STS_MASK,\n\t\t\t\tpc->cap);\n\t\tsnd_dim = FIELD_GET(IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MASK,\n\t\t\t\t    vc->cap);\n\t\tbf->nrow = min_t(u8, min_t(u8, snd_dim, sts), tx_ant);\n\t\tbf->ncol = min_t(u8, nss_mcs, bf->nrow);\n\t\tbf->ibf_ncol = bf->ncol;\n\n\t\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_160)\n\t\t\tbf->nrow = 1;\n\t} else {\n\t\tbf->nrow = tx_ant;\n\t\tbf->ncol = min_t(u8, nss_mcs, bf->nrow);\n\t\tbf->ibf_ncol = nss_mcs;\n\n\t\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_160)\n\t\t\tbf->ibf_nrow = 1;\n\t}\n}\n\nstatic void\nmt7996_mcu_sta_bfer_he(struct ieee80211_sta *sta, struct ieee80211_vif *vif,\n\t\t       struct mt7996_phy *phy, struct sta_rec_bf *bf)\n{\n\tstruct ieee80211_sta_he_cap *pc = &sta->deflink.he_cap;\n\tstruct ieee80211_he_cap_elem *pe = &pc->he_cap_elem;\n\tconst struct ieee80211_sta_he_cap *vc =\n\t\tmt76_connac_get_he_phy_cap(phy->mt76, vif);\n\tconst struct ieee80211_he_cap_elem *ve = &vc->he_cap_elem;\n\tu16 mcs_map = le16_to_cpu(pc->he_mcs_nss_supp.rx_mcs_80);\n\tu8 nss_mcs = mt7996_mcu_get_sta_nss(mcs_map);\n\tu8 snd_dim, sts;\n\n\tbf->tx_mode = MT_PHY_TYPE_HE_SU;\n\n\tmt7996_mcu_sta_sounding_rate(bf);\n\n\tbf->trigger_su = HE_PHY(CAP6_TRIG_SU_BEAMFORMING_FB,\n\t\t\t\tpe->phy_cap_info[6]);\n\tbf->trigger_mu = HE_PHY(CAP6_TRIG_MU_BEAMFORMING_PARTIAL_BW_FB,\n\t\t\t\tpe->phy_cap_info[6]);\n\tsnd_dim = HE_PHY(CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_MASK,\n\t\t\t ve->phy_cap_info[5]);\n\tsts = HE_PHY(CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_MASK,\n\t\t     pe->phy_cap_info[4]);\n\tbf->nrow = min_t(u8, snd_dim, sts);\n\tbf->ncol = min_t(u8, nss_mcs, bf->nrow);\n\tbf->ibf_ncol = bf->ncol;\n\n\tif (sta->deflink.bandwidth != IEEE80211_STA_RX_BW_160)\n\t\treturn;\n\n\t \n\tif (pe->phy_cap_info[0] &\n\t    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G) {\n\t\tmcs_map = le16_to_cpu(pc->he_mcs_nss_supp.rx_mcs_160);\n\t\tnss_mcs = mt7996_mcu_get_sta_nss(mcs_map);\n\n\t\tbf->ncol_gt_bw80 = nss_mcs;\n\t}\n\n\tif (pe->phy_cap_info[0] &\n\t    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G) {\n\t\tmcs_map = le16_to_cpu(pc->he_mcs_nss_supp.rx_mcs_80p80);\n\t\tnss_mcs = mt7996_mcu_get_sta_nss(mcs_map);\n\n\t\tif (bf->ncol_gt_bw80)\n\t\t\tbf->ncol_gt_bw80 = min_t(u8, bf->ncol_gt_bw80, nss_mcs);\n\t\telse\n\t\t\tbf->ncol_gt_bw80 = nss_mcs;\n\t}\n\n\tsnd_dim = HE_PHY(CAP5_BEAMFORMEE_NUM_SND_DIM_ABOVE_80MHZ_MASK,\n\t\t\t ve->phy_cap_info[5]);\n\tsts = HE_PHY(CAP4_BEAMFORMEE_MAX_STS_ABOVE_80MHZ_MASK,\n\t\t     pe->phy_cap_info[4]);\n\n\tbf->nrow_gt_bw80 = min_t(int, snd_dim, sts);\n}\n\nstatic void\nmt7996_mcu_sta_bfer_eht(struct ieee80211_sta *sta, struct ieee80211_vif *vif,\n\t\t\tstruct mt7996_phy *phy, struct sta_rec_bf *bf)\n{\n\tstruct ieee80211_sta_eht_cap *pc = &sta->deflink.eht_cap;\n\tstruct ieee80211_eht_cap_elem_fixed *pe = &pc->eht_cap_elem;\n\tstruct ieee80211_eht_mcs_nss_supp *eht_nss = &pc->eht_mcs_nss_supp;\n\tconst struct ieee80211_sta_eht_cap *vc =\n\t\tmt76_connac_get_eht_phy_cap(phy->mt76, vif);\n\tconst struct ieee80211_eht_cap_elem_fixed *ve = &vc->eht_cap_elem;\n\tu8 nss_mcs = u8_get_bits(eht_nss->bw._80.rx_tx_mcs9_max_nss,\n\t\t\t\t IEEE80211_EHT_MCS_NSS_RX) - 1;\n\tu8 snd_dim, sts;\n\n\tbf->tx_mode = MT_PHY_TYPE_EHT_MU;\n\n\tmt7996_mcu_sta_sounding_rate(bf);\n\n\tbf->trigger_su = EHT_PHY(CAP3_TRIG_SU_BF_FDBK, pe->phy_cap_info[3]);\n\tbf->trigger_mu = EHT_PHY(CAP3_TRIG_MU_BF_PART_BW_FDBK, pe->phy_cap_info[3]);\n\tsnd_dim = EHT_PHY(CAP2_SOUNDING_DIM_80MHZ_MASK, ve->phy_cap_info[2]);\n\tsts = EHT_PHY(CAP0_BEAMFORMEE_SS_80MHZ_MASK, pe->phy_cap_info[0]) +\n\t      (EHT_PHY(CAP1_BEAMFORMEE_SS_80MHZ_MASK, pe->phy_cap_info[1]) << 1);\n\tbf->nrow = min_t(u8, snd_dim, sts);\n\tbf->ncol = min_t(u8, nss_mcs, bf->nrow);\n\tbf->ibf_ncol = bf->ncol;\n\n\tif (sta->deflink.bandwidth < IEEE80211_STA_RX_BW_160)\n\t\treturn;\n\n\tswitch (sta->deflink.bandwidth) {\n\tcase IEEE80211_STA_RX_BW_160:\n\t\tsnd_dim = EHT_PHY(CAP2_SOUNDING_DIM_160MHZ_MASK, ve->phy_cap_info[2]);\n\t\tsts = EHT_PHY(CAP1_BEAMFORMEE_SS_160MHZ_MASK, pe->phy_cap_info[1]);\n\t\tnss_mcs = u8_get_bits(eht_nss->bw._160.rx_tx_mcs9_max_nss,\n\t\t\t\t      IEEE80211_EHT_MCS_NSS_RX) - 1;\n\n\t\tbf->nrow_gt_bw80 = min_t(u8, snd_dim, sts);\n\t\tbf->ncol_gt_bw80 = nss_mcs;\n\t\tbreak;\n\tcase IEEE80211_STA_RX_BW_320:\n\t\tsnd_dim = EHT_PHY(CAP2_SOUNDING_DIM_320MHZ_MASK, ve->phy_cap_info[2]) +\n\t\t\t  (EHT_PHY(CAP3_SOUNDING_DIM_320MHZ_MASK,\n\t\t\t\t   ve->phy_cap_info[3]) << 1);\n\t\tsts = EHT_PHY(CAP1_BEAMFORMEE_SS_320MHZ_MASK, pe->phy_cap_info[1]);\n\t\tnss_mcs = u8_get_bits(eht_nss->bw._320.rx_tx_mcs9_max_nss,\n\t\t\t\t      IEEE80211_EHT_MCS_NSS_RX) - 1;\n\n\t\tbf->nrow_gt_bw80 = min_t(u8, snd_dim, sts) << 4;\n\t\tbf->ncol_gt_bw80 = nss_mcs << 4;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\nmt7996_mcu_sta_bfer_tlv(struct mt7996_dev *dev, struct sk_buff *skb,\n\t\t\tstruct ieee80211_vif *vif, struct ieee80211_sta *sta)\n{\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tstruct mt7996_phy *phy = mvif->phy;\n\tint tx_ant = hweight8(phy->mt76->chainmask) - 1;\n\tstruct sta_rec_bf *bf;\n\tstruct tlv *tlv;\n\tconst u8 matrix[4][4] = {\n\t\t{0, 0, 0, 0},\n\t\t{1, 1, 0, 0},\t \n\t\t{2, 4, 4, 0},\t \n\t\t{3, 5, 6, 0}\t \n\t};\n\tbool ebf;\n\n\tif (!(sta->deflink.ht_cap.ht_supported || sta->deflink.he_cap.has_he))\n\t\treturn;\n\n\tebf = mt7996_is_ebf_supported(phy, vif, sta, false);\n\tif (!ebf && !dev->ibf)\n\t\treturn;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_BF, sizeof(*bf));\n\tbf = (struct sta_rec_bf *)tlv;\n\n\t \n\tif (sta->deflink.eht_cap.has_eht && ebf)\n\t\tmt7996_mcu_sta_bfer_eht(sta, vif, phy, bf);\n\telse if (sta->deflink.he_cap.has_he && ebf)\n\t\tmt7996_mcu_sta_bfer_he(sta, vif, phy, bf);\n\telse if (sta->deflink.vht_cap.vht_supported)\n\t\tmt7996_mcu_sta_bfer_vht(sta, phy, bf, ebf);\n\telse if (sta->deflink.ht_cap.ht_supported)\n\t\tmt7996_mcu_sta_bfer_ht(sta, phy, bf);\n\telse\n\t\treturn;\n\n\tbf->bf_cap = ebf ? ebf : dev->ibf << 1;\n\tbf->bw = sta->deflink.bandwidth;\n\tbf->ibf_dbw = sta->deflink.bandwidth;\n\tbf->ibf_nrow = tx_ant;\n\n\tif (!ebf && sta->deflink.bandwidth <= IEEE80211_STA_RX_BW_40 && !bf->ncol)\n\t\tbf->ibf_timeout = 0x48;\n\telse\n\t\tbf->ibf_timeout = 0x18;\n\n\tif (ebf && bf->nrow != tx_ant)\n\t\tbf->mem_20m = matrix[tx_ant][bf->ncol];\n\telse\n\t\tbf->mem_20m = matrix[bf->nrow][bf->ncol];\n\n\tswitch (sta->deflink.bandwidth) {\n\tcase IEEE80211_STA_RX_BW_160:\n\tcase IEEE80211_STA_RX_BW_80:\n\t\tbf->mem_total = bf->mem_20m * 2;\n\t\tbreak;\n\tcase IEEE80211_STA_RX_BW_40:\n\t\tbf->mem_total = bf->mem_20m;\n\t\tbreak;\n\tcase IEEE80211_STA_RX_BW_20:\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\nmt7996_mcu_sta_bfee_tlv(struct mt7996_dev *dev, struct sk_buff *skb,\n\t\t\tstruct ieee80211_vif *vif, struct ieee80211_sta *sta)\n{\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tstruct mt7996_phy *phy = mvif->phy;\n\tint tx_ant = hweight8(phy->mt76->antenna_mask) - 1;\n\tstruct sta_rec_bfee *bfee;\n\tstruct tlv *tlv;\n\tu8 nrow = 0;\n\n\tif (!(sta->deflink.vht_cap.vht_supported || sta->deflink.he_cap.has_he))\n\t\treturn;\n\n\tif (!mt7996_is_ebf_supported(phy, vif, sta, true))\n\t\treturn;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_BFEE, sizeof(*bfee));\n\tbfee = (struct sta_rec_bfee *)tlv;\n\n\tif (sta->deflink.he_cap.has_he) {\n\t\tstruct ieee80211_he_cap_elem *pe = &sta->deflink.he_cap.he_cap_elem;\n\n\t\tnrow = HE_PHY(CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_MASK,\n\t\t\t      pe->phy_cap_info[5]);\n\t} else if (sta->deflink.vht_cap.vht_supported) {\n\t\tstruct ieee80211_sta_vht_cap *pc = &sta->deflink.vht_cap;\n\n\t\tnrow = FIELD_GET(IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MASK,\n\t\t\t\t pc->cap);\n\t}\n\n\t \n\tbfee->fb_identity_matrix = (nrow == 1 && tx_ant == 2);\n}\n\nstatic void\nmt7996_mcu_sta_phy_tlv(struct mt7996_dev *dev, struct sk_buff *skb,\n\t\t       struct ieee80211_vif *vif, struct ieee80211_sta *sta)\n{\n\tstruct sta_rec_phy *phy;\n\tstruct tlv *tlv;\n\tu8 af = 0, mm = 0;\n\n\tif (!sta->deflink.ht_cap.ht_supported && !sta->deflink.he_6ghz_capa.capa)\n\t\treturn;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_PHY, sizeof(*phy));\n\n\tphy = (struct sta_rec_phy *)tlv;\n\tif (sta->deflink.ht_cap.ht_supported) {\n\t\taf = sta->deflink.ht_cap.ampdu_factor;\n\t\tmm = sta->deflink.ht_cap.ampdu_density;\n\t}\n\n\tif (sta->deflink.vht_cap.vht_supported) {\n\t\tu8 vht_af = FIELD_GET(IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK,\n\t\t\t\t      sta->deflink.vht_cap.cap);\n\n\t\taf = max_t(u8, af, vht_af);\n\t}\n\n\tif (sta->deflink.he_6ghz_capa.capa) {\n\t\taf = le16_get_bits(sta->deflink.he_6ghz_capa.capa,\n\t\t\t\t   IEEE80211_HE_6GHZ_CAP_MAX_AMPDU_LEN_EXP);\n\t\tmm = le16_get_bits(sta->deflink.he_6ghz_capa.capa,\n\t\t\t\t   IEEE80211_HE_6GHZ_CAP_MIN_MPDU_START);\n\t}\n\n\tphy->ampdu = FIELD_PREP(IEEE80211_HT_AMPDU_PARM_FACTOR, af) |\n\t\t     FIELD_PREP(IEEE80211_HT_AMPDU_PARM_DENSITY, mm);\n\tphy->max_ampdu_len = af;\n}\n\nstatic void\nmt7996_mcu_sta_hdrt_tlv(struct mt7996_dev *dev, struct sk_buff *skb)\n{\n\tstruct sta_rec_hdrt *hdrt;\n\tstruct tlv *tlv;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_HDRT, sizeof(*hdrt));\n\n\thdrt = (struct sta_rec_hdrt *)tlv;\n\thdrt->hdrt_mode = 1;\n}\n\nstatic void\nmt7996_mcu_sta_hdr_trans_tlv(struct mt7996_dev *dev, struct sk_buff *skb,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_sta *sta)\n{\n\tstruct sta_rec_hdr_trans *hdr_trans;\n\tstruct mt76_wcid *wcid;\n\tstruct tlv *tlv;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_HDR_TRANS, sizeof(*hdr_trans));\n\thdr_trans = (struct sta_rec_hdr_trans *)tlv;\n\thdr_trans->dis_rx_hdr_tran = true;\n\n\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\thdr_trans->to_ds = true;\n\telse\n\t\thdr_trans->from_ds = true;\n\n\twcid = (struct mt76_wcid *)sta->drv_priv;\n\tif (!wcid)\n\t\treturn;\n\n\thdr_trans->dis_rx_hdr_tran = !test_bit(MT_WCID_FLAG_HDR_TRANS, &wcid->flags);\n\tif (test_bit(MT_WCID_FLAG_4ADDR, &wcid->flags)) {\n\t\thdr_trans->to_ds = true;\n\t\thdr_trans->from_ds = true;\n\t}\n\n\tif (vif->type == NL80211_IFTYPE_MESH_POINT) {\n\t\thdr_trans->to_ds = true;\n\t\thdr_trans->from_ds = true;\n\t\thdr_trans->mesh = true;\n\t}\n}\n\nstatic enum mcu_mmps_mode\nmt7996_mcu_get_mmps_mode(enum ieee80211_smps_mode smps)\n{\n\tswitch (smps) {\n\tcase IEEE80211_SMPS_OFF:\n\t\treturn MCU_MMPS_DISABLE;\n\tcase IEEE80211_SMPS_STATIC:\n\t\treturn MCU_MMPS_STATIC;\n\tcase IEEE80211_SMPS_DYNAMIC:\n\t\treturn MCU_MMPS_DYNAMIC;\n\tdefault:\n\t\treturn MCU_MMPS_DISABLE;\n\t}\n}\n\nint mt7996_mcu_set_fixed_rate_ctrl(struct mt7996_dev *dev,\n\t\t\t\t   void *data, u16 version)\n{\n\tstruct ra_fixed_rate *req;\n\tstruct uni_header hdr;\n\tstruct sk_buff *skb;\n\tstruct tlv *tlv;\n\tint len;\n\n\tlen = sizeof(hdr) + sizeof(*req);\n\n\tskb = mt76_mcu_msg_alloc(&dev->mt76, NULL, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_data(skb, &hdr, sizeof(hdr));\n\n\ttlv = mt7996_mcu_add_uni_tlv(skb, UNI_RA_FIXED_RATE, sizeof(*req));\n\treq = (struct ra_fixed_rate *)tlv;\n\treq->version = cpu_to_le16(version);\n\tmemcpy(&req->rate, data, sizeof(req->rate));\n\n\treturn mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t     MCU_WM_UNI_CMD(RA), true);\n}\n\nstatic void\nmt7996_mcu_sta_rate_ctrl_tlv(struct sk_buff *skb, struct mt7996_dev *dev,\n\t\t\t     struct ieee80211_vif *vif, struct ieee80211_sta *sta)\n{\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tstruct mt76_phy *mphy = mvif->phy->mt76;\n\tstruct cfg80211_chan_def *chandef = &mphy->chandef;\n\tstruct cfg80211_bitrate_mask *mask = &mvif->bitrate_mask;\n\tenum nl80211_band band = chandef->chan->band;\n\tstruct sta_rec_ra *ra;\n\tstruct tlv *tlv;\n\tu32 supp_rate = sta->deflink.supp_rates[band];\n\tu32 cap = sta->wme ? STA_CAP_WMM : 0;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_RA, sizeof(*ra));\n\tra = (struct sta_rec_ra *)tlv;\n\n\tra->valid = true;\n\tra->auto_rate = true;\n\tra->phy_mode = mt76_connac_get_phy_mode(mphy, vif, band, sta);\n\tra->channel = chandef->chan->hw_value;\n\tra->bw = (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_320) ?\n\t\t CMD_CBW_320MHZ : sta->deflink.bandwidth;\n\tra->phy.bw = ra->bw;\n\tra->mmps_mode = mt7996_mcu_get_mmps_mode(sta->deflink.smps_mode);\n\n\tif (supp_rate) {\n\t\tsupp_rate &= mask->control[band].legacy;\n\t\tra->rate_len = hweight32(supp_rate);\n\n\t\tif (band == NL80211_BAND_2GHZ) {\n\t\t\tra->supp_mode = MODE_CCK;\n\t\t\tra->supp_cck_rate = supp_rate & GENMASK(3, 0);\n\n\t\t\tif (ra->rate_len > 4) {\n\t\t\t\tra->supp_mode |= MODE_OFDM;\n\t\t\t\tra->supp_ofdm_rate = supp_rate >> 4;\n\t\t\t}\n\t\t} else {\n\t\t\tra->supp_mode = MODE_OFDM;\n\t\t\tra->supp_ofdm_rate = supp_rate;\n\t\t}\n\t}\n\n\tif (sta->deflink.ht_cap.ht_supported) {\n\t\tra->supp_mode |= MODE_HT;\n\t\tra->af = sta->deflink.ht_cap.ampdu_factor;\n\t\tra->ht_gf = !!(sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_GRN_FLD);\n\n\t\tcap |= STA_CAP_HT;\n\t\tif (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_20)\n\t\t\tcap |= STA_CAP_SGI_20;\n\t\tif (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_40)\n\t\t\tcap |= STA_CAP_SGI_40;\n\t\tif (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_TX_STBC)\n\t\t\tcap |= STA_CAP_TX_STBC;\n\t\tif (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_RX_STBC)\n\t\t\tcap |= STA_CAP_RX_STBC;\n\t\tif (vif->bss_conf.ht_ldpc &&\n\t\t    (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_LDPC_CODING))\n\t\t\tcap |= STA_CAP_LDPC;\n\n\t\tmt7996_mcu_set_sta_ht_mcs(sta, ra->ht_mcs,\n\t\t\t\t\t  mask->control[band].ht_mcs);\n\t\tra->supp_ht_mcs = *(__le32 *)ra->ht_mcs;\n\t}\n\n\tif (sta->deflink.vht_cap.vht_supported) {\n\t\tu8 af;\n\n\t\tra->supp_mode |= MODE_VHT;\n\t\taf = FIELD_GET(IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK,\n\t\t\t       sta->deflink.vht_cap.cap);\n\t\tra->af = max_t(u8, ra->af, af);\n\n\t\tcap |= STA_CAP_VHT;\n\t\tif (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_SHORT_GI_80)\n\t\t\tcap |= STA_CAP_VHT_SGI_80;\n\t\tif (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_SHORT_GI_160)\n\t\t\tcap |= STA_CAP_VHT_SGI_160;\n\t\tif (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_TXSTBC)\n\t\t\tcap |= STA_CAP_VHT_TX_STBC;\n\t\tif (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_RXSTBC_1)\n\t\t\tcap |= STA_CAP_VHT_RX_STBC;\n\t\tif (vif->bss_conf.vht_ldpc &&\n\t\t    (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_RXLDPC))\n\t\t\tcap |= STA_CAP_VHT_LDPC;\n\n\t\tmt7996_mcu_set_sta_vht_mcs(sta, ra->supp_vht_mcs,\n\t\t\t\t\t   mask->control[band].vht_mcs);\n\t}\n\n\tif (sta->deflink.he_cap.has_he) {\n\t\tra->supp_mode |= MODE_HE;\n\t\tcap |= STA_CAP_HE;\n\n\t\tif (sta->deflink.he_6ghz_capa.capa)\n\t\t\tra->af = le16_get_bits(sta->deflink.he_6ghz_capa.capa,\n\t\t\t\t\t       IEEE80211_HE_6GHZ_CAP_MAX_AMPDU_LEN_EXP);\n\t}\n\tra->sta_cap = cpu_to_le32(cap);\n}\n\nint mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev, struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_sta *sta, bool changed)\n{\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tstruct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;\n\tstruct sk_buff *skb;\n\n\tskb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->mt76,\n\t\t\t\t\t      &msta->wcid,\n\t\t\t\t\t      MT7996_STA_UPDATE_MAX_SIZE);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\t \n\tif (changed)\n\t\tmt7996_mcu_sta_he_tlv(skb, sta);\n\n\t \n\tmt7996_mcu_sta_rate_ctrl_tlv(skb, dev, vif, sta);\n\n\treturn mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t     MCU_WMWA_UNI_CMD(STA_REC_UPDATE), true);\n}\n\nstatic int\nmt7996_mcu_add_group(struct mt7996_dev *dev, struct ieee80211_vif *vif,\n\t\t     struct ieee80211_sta *sta)\n{\n#define MT_STA_BSS_GROUP\t\t1\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tstruct mt7996_sta *msta;\n\tstruct {\n\t\tu8 __rsv1[4];\n\n\t\t__le16 tag;\n\t\t__le16 len;\n\t\t__le16 wlan_idx;\n\t\tu8 __rsv2[2];\n\t\t__le32 action;\n\t\t__le32 val;\n\t\tu8 __rsv3[8];\n\t} __packed req = {\n\t\t.tag = cpu_to_le16(UNI_VOW_DRR_CTRL),\n\t\t.len = cpu_to_le16(sizeof(req) - 4),\n\t\t.action = cpu_to_le32(MT_STA_BSS_GROUP),\n\t\t.val = cpu_to_le32(mvif->mt76.idx % 16),\n\t};\n\n\tmsta = sta ? (struct mt7996_sta *)sta->drv_priv : &mvif->sta;\n\treq.wlan_idx = cpu_to_le16(msta->wcid.idx);\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(VOW), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nint mt7996_mcu_add_sta(struct mt7996_dev *dev, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_sta *sta, bool enable)\n{\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tstruct mt7996_sta *msta;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tmsta = sta ? (struct mt7996_sta *)sta->drv_priv : &mvif->sta;\n\n\tskb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->mt76,\n\t\t\t\t\t      &msta->wcid,\n\t\t\t\t\t      MT7996_STA_UPDATE_MAX_SIZE);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\t \n\tmt76_connac_mcu_sta_basic_tlv(&dev->mt76, skb, vif, sta, enable,\n\t\t\t\t      !rcu_access_pointer(dev->mt76.wcid[msta->wcid.idx]));\n\tif (!enable)\n\t\tgoto out;\n\n\t \n\tif (sta) {\n\t\t \n\t\tmt7996_mcu_sta_phy_tlv(dev, skb, vif, sta);\n\t\t \n\t\tmt7996_mcu_sta_hdrt_tlv(dev, skb);\n\t\t \n\t\tmt7996_mcu_sta_bfer_tlv(dev, skb, vif, sta);\n\t\t \n\t\tmt7996_mcu_sta_ht_tlv(skb, sta);\n\t\t \n\t\tmt7996_mcu_sta_vht_tlv(skb, sta);\n\t\t \n\t\tmt76_connac_mcu_sta_uapsd(skb, vif, sta);\n\t\t \n\t\tmt7996_mcu_sta_amsdu_tlv(dev, skb, vif, sta);\n\t\t \n\t\tmt7996_mcu_sta_he_tlv(skb, sta);\n\t\t \n\t\tmt7996_mcu_sta_he_6g_tlv(skb, sta);\n\t\t \n\t\tmt7996_mcu_sta_eht_tlv(skb, sta);\n\t\t \n\t\tmt7996_mcu_sta_muru_tlv(dev, skb, vif, sta);\n\t\t \n\t\tmt7996_mcu_sta_bfee_tlv(dev, skb, vif, sta);\n\t\t \n\t\tmt7996_mcu_sta_hdr_trans_tlv(dev, skb, vif, sta);\n\t}\n\n\tret = mt7996_mcu_add_group(dev, vif, sta);\n\tif (ret) {\n\t\tdev_kfree_skb(skb);\n\t\treturn ret;\n\t}\nout:\n\treturn mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t     MCU_WMWA_UNI_CMD(STA_REC_UPDATE), true);\n}\n\nstatic int\nmt7996_mcu_sta_key_tlv(struct mt76_wcid *wcid,\n\t\t       struct mt76_connac_sta_key_conf *sta_key_conf,\n\t\t       struct sk_buff *skb,\n\t\t       struct ieee80211_key_conf *key,\n\t\t       enum set_key_cmd cmd)\n{\n\tstruct sta_rec_sec_uni *sec;\n\tstruct tlv *tlv;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_KEY_V2, sizeof(*sec));\n\tsec = (struct sta_rec_sec_uni *)tlv;\n\tsec->add = cmd;\n\n\tif (cmd == SET_KEY) {\n\t\tstruct sec_key_uni *sec_key;\n\t\tu8 cipher;\n\n\t\tcipher = mt76_connac_mcu_get_cipher(key->cipher);\n\t\tif (cipher == MCU_CIPHER_NONE)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tsec_key = &sec->key[0];\n\t\tsec_key->cipher_len = sizeof(*sec_key);\n\n\t\tif (cipher == MCU_CIPHER_BIP_CMAC_128) {\n\t\t\tsec_key->wlan_idx = cpu_to_le16(wcid->idx);\n\t\t\tsec_key->cipher_id = MCU_CIPHER_AES_CCMP;\n\t\t\tsec_key->key_id = sta_key_conf->keyidx;\n\t\t\tsec_key->key_len = 16;\n\t\t\tmemcpy(sec_key->key, sta_key_conf->key, 16);\n\n\t\t\tsec_key = &sec->key[1];\n\t\t\tsec_key->wlan_idx = cpu_to_le16(wcid->idx);\n\t\t\tsec_key->cipher_id = MCU_CIPHER_BIP_CMAC_128;\n\t\t\tsec_key->cipher_len = sizeof(*sec_key);\n\t\t\tsec_key->key_len = 16;\n\t\t\tmemcpy(sec_key->key, key->key, 16);\n\t\t\tsec->n_cipher = 2;\n\t\t} else {\n\t\t\tsec_key->wlan_idx = cpu_to_le16(wcid->idx);\n\t\t\tsec_key->cipher_id = cipher;\n\t\t\tsec_key->key_id = key->keyidx;\n\t\t\tsec_key->key_len = key->keylen;\n\t\t\tmemcpy(sec_key->key, key->key, key->keylen);\n\n\t\t\tif (cipher == MCU_CIPHER_TKIP) {\n\t\t\t\t \n\t\t\t\tmemcpy(sec_key->key + 16, key->key + 24, 8);\n\t\t\t\tmemcpy(sec_key->key + 24, key->key + 16, 8);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (cipher == MCU_CIPHER_AES_CCMP) {\n\t\t\t\tmemcpy(sta_key_conf->key, key->key, key->keylen);\n\t\t\t\tsta_key_conf->keyidx = key->keyidx;\n\t\t\t}\n\n\t\t\tsec->n_cipher = 1;\n\t\t}\n\t} else {\n\t\tsec->n_cipher = 0;\n\t}\n\n\treturn 0;\n}\n\nint mt7996_mcu_add_key(struct mt76_dev *dev, struct ieee80211_vif *vif,\n\t\t       struct mt76_connac_sta_key_conf *sta_key_conf,\n\t\t       struct ieee80211_key_conf *key, int mcu_cmd,\n\t\t       struct mt76_wcid *wcid, enum set_key_cmd cmd)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = __mt76_connac_mcu_alloc_sta_req(dev, mvif, wcid,\n\t\t\t\t\t      MT7996_STA_UPDATE_MAX_SIZE);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tret = mt7996_mcu_sta_key_tlv(wcid, sta_key_conf, skb, key, cmd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mt76_mcu_skb_send_msg(dev, skb, mcu_cmd, true);\n}\n\nint mt7996_mcu_add_dev_info(struct mt7996_phy *phy,\n\t\t\t    struct ieee80211_vif *vif, bool enable)\n{\n\tstruct mt7996_dev *dev = phy->dev;\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tstruct {\n\t\tstruct req_hdr {\n\t\t\tu8 omac_idx;\n\t\t\tu8 band_idx;\n\t\t\tu8 __rsv[2];\n\t\t} __packed hdr;\n\t\tstruct req_tlv {\n\t\t\t__le16 tag;\n\t\t\t__le16 len;\n\t\t\tu8 active;\n\t\t\tu8 __rsv;\n\t\t\tu8 omac_addr[ETH_ALEN];\n\t\t} __packed tlv;\n\t} data = {\n\t\t.hdr = {\n\t\t\t.omac_idx = mvif->mt76.omac_idx,\n\t\t\t.band_idx = mvif->mt76.band_idx,\n\t\t},\n\t\t.tlv = {\n\t\t\t.tag = cpu_to_le16(DEV_INFO_ACTIVE),\n\t\t\t.len = cpu_to_le16(sizeof(struct req_tlv)),\n\t\t\t.active = enable,\n\t\t},\n\t};\n\n\tif (mvif->mt76.omac_idx >= REPEATER_BSSID_START)\n\t\treturn mt7996_mcu_muar_config(phy, vif, false, enable);\n\n\tmemcpy(data.tlv.omac_addr, vif->addr, ETH_ALEN);\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_WMWA_UNI_CMD(DEV_INFO_UPDATE),\n\t\t\t\t &data, sizeof(data), true);\n}\n\nstatic void\nmt7996_mcu_beacon_cntdwn(struct ieee80211_vif *vif, struct sk_buff *rskb,\n\t\t\t struct sk_buff *skb,\n\t\t\t struct ieee80211_mutable_offsets *offs)\n{\n\tstruct bss_bcn_cntdwn_tlv *info;\n\tstruct tlv *tlv;\n\tu16 tag;\n\n\tif (!offs->cntdwn_counter_offs[0])\n\t\treturn;\n\n\ttag = vif->bss_conf.csa_active ? UNI_BSS_INFO_BCN_CSA : UNI_BSS_INFO_BCN_BCC;\n\n\ttlv = mt7996_mcu_add_uni_tlv(rskb, tag, sizeof(*info));\n\n\tinfo = (struct bss_bcn_cntdwn_tlv *)tlv;\n\tinfo->cnt = skb->data[offs->cntdwn_counter_offs[0]];\n}\n\nstatic void\nmt7996_mcu_beacon_cont(struct mt7996_dev *dev, struct ieee80211_vif *vif,\n\t\t       struct sk_buff *rskb, struct sk_buff *skb,\n\t\t       struct bss_bcn_content_tlv *bcn,\n\t\t       struct ieee80211_mutable_offsets *offs)\n{\n\tstruct mt76_wcid *wcid = &dev->mt76.global_wcid;\n\tu8 *buf;\n\n\tbcn->pkt_len = cpu_to_le16(MT_TXD_SIZE + skb->len);\n\tbcn->tim_ie_pos = cpu_to_le16(offs->tim_offset);\n\n\tif (offs->cntdwn_counter_offs[0]) {\n\t\tu16 offset = offs->cntdwn_counter_offs[0];\n\n\t\tif (vif->bss_conf.csa_active)\n\t\t\tbcn->csa_ie_pos = cpu_to_le16(offset - 4);\n\t\tif (vif->bss_conf.color_change_active)\n\t\t\tbcn->bcc_ie_pos = cpu_to_le16(offset - 3);\n\t}\n\n\tbuf = (u8 *)bcn + sizeof(*bcn);\n\tmt7996_mac_write_txwi(dev, (__le32 *)buf, skb, wcid, NULL, 0, 0,\n\t\t\t      BSS_CHANGED_BEACON);\n\n\tmemcpy(buf + MT_TXD_SIZE, skb->data, skb->len);\n}\n\nint mt7996_mcu_add_beacon(struct ieee80211_hw *hw,\n\t\t\t  struct ieee80211_vif *vif, int en)\n{\n\tstruct mt7996_dev *dev = mt7996_hw_dev(hw);\n\tstruct mt7996_phy *phy = mt7996_hw_phy(hw);\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tstruct ieee80211_mutable_offsets offs;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *skb, *rskb;\n\tstruct tlv *tlv;\n\tstruct bss_bcn_content_tlv *bcn;\n\tint len;\n\n\trskb = __mt7996_mcu_alloc_bss_req(&dev->mt76, &mvif->mt76,\n\t\t\t\t\t  MT7996_MAX_BSS_OFFLOAD_SIZE);\n\tif (IS_ERR(rskb))\n\t\treturn PTR_ERR(rskb);\n\n\tskb = ieee80211_beacon_get_template(hw, vif, &offs, 0);\n\tif (!skb) {\n\t\tdev_kfree_skb(rskb);\n\t\treturn -EINVAL;\n\t}\n\n\tif (skb->len > MT7996_MAX_BEACON_SIZE) {\n\t\tdev_err(dev->mt76.dev, \"Bcn size limit exceed\\n\");\n\t\tdev_kfree_skb(rskb);\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tinfo->hw_queue |= FIELD_PREP(MT_TX_HW_QUEUE_PHY, phy->mt76->band_idx);\n\n\tlen = sizeof(*bcn) + MT_TXD_SIZE + skb->len;\n\ttlv = mt7996_mcu_add_uni_tlv(rskb, UNI_BSS_INFO_BCN_CONTENT, len);\n\tbcn = (struct bss_bcn_content_tlv *)tlv;\n\tbcn->enable = en;\n\tif (!en)\n\t\tgoto out;\n\n\tmt7996_mcu_beacon_cont(dev, vif, rskb, skb, bcn, &offs);\n\t \n\tmt7996_mcu_beacon_cntdwn(vif, rskb, skb, &offs);\nout:\n\tdev_kfree_skb(skb);\n\treturn mt76_mcu_skb_send_msg(&phy->dev->mt76, rskb,\n\t\t\t\t     MCU_WMWA_UNI_CMD(BSS_INFO_UPDATE), true);\n}\n\nint mt7996_mcu_beacon_inband_discov(struct mt7996_dev *dev,\n\t\t\t\t    struct ieee80211_vif *vif, u32 changed)\n{\n#define OFFLOAD_TX_MODE_SU\tBIT(0)\n#define OFFLOAD_TX_MODE_MU\tBIT(1)\n\tstruct ieee80211_hw *hw = mt76_hw(dev);\n\tstruct mt7996_phy *phy = mt7996_hw_phy(hw);\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tstruct cfg80211_chan_def *chandef = &mvif->phy->mt76->chandef;\n\tenum nl80211_band band = chandef->chan->band;\n\tstruct mt76_wcid *wcid = &dev->mt76.global_wcid;\n\tstruct bss_inband_discovery_tlv *discov;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *rskb, *skb = NULL;\n\tstruct tlv *tlv;\n\tu8 *buf, interval;\n\tint len;\n\n\tif (vif->bss_conf.nontransmitted)\n\t\treturn 0;\n\n\trskb = __mt7996_mcu_alloc_bss_req(&dev->mt76, &mvif->mt76,\n\t\t\t\t\t  MT7996_MAX_BSS_OFFLOAD_SIZE);\n\tif (IS_ERR(rskb))\n\t\treturn PTR_ERR(rskb);\n\n\tif (changed & BSS_CHANGED_FILS_DISCOVERY &&\n\t    vif->bss_conf.fils_discovery.max_interval) {\n\t\tinterval = vif->bss_conf.fils_discovery.max_interval;\n\t\tskb = ieee80211_get_fils_discovery_tmpl(hw, vif);\n\t} else if (changed & BSS_CHANGED_UNSOL_BCAST_PROBE_RESP &&\n\t\t   vif->bss_conf.unsol_bcast_probe_resp_interval) {\n\t\tinterval = vif->bss_conf.unsol_bcast_probe_resp_interval;\n\t\tskb = ieee80211_get_unsol_bcast_probe_resp_tmpl(hw, vif);\n\t}\n\n\tif (!skb) {\n\t\tdev_kfree_skb(rskb);\n\t\treturn -EINVAL;\n\t}\n\n\tif (skb->len > MT7996_MAX_BEACON_SIZE) {\n\t\tdev_err(dev->mt76.dev, \"inband discovery size limit exceed\\n\");\n\t\tdev_kfree_skb(rskb);\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tinfo->control.vif = vif;\n\tinfo->band = band;\n\tinfo->hw_queue |= FIELD_PREP(MT_TX_HW_QUEUE_PHY, phy->mt76->band_idx);\n\n\tlen = sizeof(*discov) + MT_TXD_SIZE + skb->len;\n\n\ttlv = mt7996_mcu_add_uni_tlv(rskb, UNI_BSS_INFO_OFFLOAD, len);\n\n\tdiscov = (struct bss_inband_discovery_tlv *)tlv;\n\tdiscov->tx_mode = OFFLOAD_TX_MODE_SU;\n\t \n\tdiscov->tx_type = !!(changed & BSS_CHANGED_FILS_DISCOVERY);\n\tdiscov->tx_interval = interval;\n\tdiscov->prob_rsp_len = cpu_to_le16(MT_TXD_SIZE + skb->len);\n\tdiscov->enable = true;\n\tdiscov->wcid = cpu_to_le16(MT7996_WTBL_RESERVED);\n\n\tbuf = (u8 *)tlv + sizeof(*discov);\n\n\tmt7996_mac_write_txwi(dev, (__le32 *)buf, skb, wcid, NULL, 0, 0, changed);\n\n\tmemcpy(buf + MT_TXD_SIZE, skb->data, skb->len);\n\n\tdev_kfree_skb(skb);\n\n\treturn mt76_mcu_skb_send_msg(&dev->mt76, rskb,\n\t\t\t\t     MCU_WMWA_UNI_CMD(BSS_INFO_UPDATE), true);\n}\n\nstatic int mt7996_driver_own(struct mt7996_dev *dev, u8 band)\n{\n\tmt76_wr(dev, MT_TOP_LPCR_HOST_BAND(band), MT_TOP_LPCR_HOST_DRV_OWN);\n\tif (!mt76_poll_msec(dev, MT_TOP_LPCR_HOST_BAND(band),\n\t\t\t    MT_TOP_LPCR_HOST_FW_OWN_STAT, 0, 500)) {\n\t\tdev_err(dev->mt76.dev, \"Timeout for driver own\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tmt76_wr(dev, MT_TOP_LPCR_HOST_BAND_IRQ_STAT(band),\n\t\tMT_TOP_LPCR_HOST_BAND_STAT);\n\n\treturn 0;\n}\n\nstatic u32 mt7996_patch_sec_mode(u32 key_info)\n{\n\tu32 sec = u32_get_bits(key_info, MT7996_PATCH_SEC), key = 0;\n\n\tif (key_info == GENMASK(31, 0) || sec == MT7996_SEC_MODE_PLAIN)\n\t\treturn 0;\n\n\tif (sec == MT7996_SEC_MODE_AES)\n\t\tkey = u32_get_bits(key_info, MT7996_PATCH_AES_KEY);\n\telse\n\t\tkey = u32_get_bits(key_info, MT7996_PATCH_SCRAMBLE_KEY);\n\n\treturn MT7996_SEC_ENCRYPT | MT7996_SEC_IV |\n\t       u32_encode_bits(key, MT7996_SEC_KEY_IDX);\n}\n\nstatic int mt7996_load_patch(struct mt7996_dev *dev)\n{\n\tconst struct mt7996_patch_hdr *hdr;\n\tconst struct firmware *fw = NULL;\n\tint i, ret, sem;\n\n\tsem = mt76_connac_mcu_patch_sem_ctrl(&dev->mt76, 1);\n\tswitch (sem) {\n\tcase PATCH_IS_DL:\n\t\treturn 0;\n\tcase PATCH_NOT_DL_SEM_SUCCESS:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->mt76.dev, \"Failed to get patch semaphore\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tret = request_firmware(&fw, MT7996_ROM_PATCH, dev->mt76.dev);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!fw || !fw->data || fw->size < sizeof(*hdr)) {\n\t\tdev_err(dev->mt76.dev, \"Invalid firmware\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\thdr = (const struct mt7996_patch_hdr *)(fw->data);\n\n\tdev_info(dev->mt76.dev, \"HW/SW Version: 0x%x, Build Time: %.16s\\n\",\n\t\t be32_to_cpu(hdr->hw_sw_ver), hdr->build_date);\n\n\tfor (i = 0; i < be32_to_cpu(hdr->desc.n_region); i++) {\n\t\tstruct mt7996_patch_sec *sec;\n\t\tconst u8 *dl;\n\t\tu32 len, addr, sec_key_idx, mode = DL_MODE_NEED_RSP;\n\n\t\tsec = (struct mt7996_patch_sec *)(fw->data + sizeof(*hdr) +\n\t\t\t\t\t\t  i * sizeof(*sec));\n\t\tif ((be32_to_cpu(sec->type) & PATCH_SEC_TYPE_MASK) !=\n\t\t    PATCH_SEC_TYPE_INFO) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\taddr = be32_to_cpu(sec->info.addr);\n\t\tlen = be32_to_cpu(sec->info.len);\n\t\tsec_key_idx = be32_to_cpu(sec->info.sec_key_idx);\n\t\tdl = fw->data + be32_to_cpu(sec->offs);\n\n\t\tmode |= mt7996_patch_sec_mode(sec_key_idx);\n\n\t\tret = mt76_connac_mcu_init_download(&dev->mt76, addr, len,\n\t\t\t\t\t\t    mode);\n\t\tif (ret) {\n\t\t\tdev_err(dev->mt76.dev, \"Download request failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = __mt76_mcu_send_firmware(&dev->mt76, MCU_CMD(FW_SCATTER),\n\t\t\t\t\t       dl, len, 4096);\n\t\tif (ret) {\n\t\t\tdev_err(dev->mt76.dev, \"Failed to send patch\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = mt76_connac_mcu_start_patch(&dev->mt76);\n\tif (ret)\n\t\tdev_err(dev->mt76.dev, \"Failed to start patch\\n\");\n\nout:\n\tsem = mt76_connac_mcu_patch_sem_ctrl(&dev->mt76, 0);\n\tswitch (sem) {\n\tcase PATCH_REL_SEM_SUCCESS:\n\t\tbreak;\n\tdefault:\n\t\tret = -EAGAIN;\n\t\tdev_err(dev->mt76.dev, \"Failed to release patch semaphore\\n\");\n\t\tbreak;\n\t}\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\nstatic int\nmt7996_mcu_send_ram_firmware(struct mt7996_dev *dev,\n\t\t\t     const struct mt7996_fw_trailer *hdr,\n\t\t\t     const u8 *data, enum mt7996_ram_type type)\n{\n\tint i, offset = 0;\n\tu32 override = 0, option = 0;\n\n\tfor (i = 0; i < hdr->n_region; i++) {\n\t\tconst struct mt7996_fw_region *region;\n\t\tint err;\n\t\tu32 len, addr, mode;\n\n\t\tregion = (const struct mt7996_fw_region *)((const u8 *)hdr -\n\t\t\t (hdr->n_region - i) * sizeof(*region));\n\t\t \n\t\tmode = mt76_connac_mcu_gen_dl_mode(&dev->mt76,\n\t\t\t\t\t\t   region->feature_set,\n\t\t\t\t\t\t   type != MT7996_RAM_TYPE_WM);\n\t\tlen = le32_to_cpu(region->len);\n\t\taddr = le32_to_cpu(region->addr);\n\n\t\tif (region->feature_set & FW_FEATURE_OVERRIDE_ADDR)\n\t\t\toverride = addr;\n\n\t\terr = mt76_connac_mcu_init_download(&dev->mt76, addr, len,\n\t\t\t\t\t\t    mode);\n\t\tif (err) {\n\t\t\tdev_err(dev->mt76.dev, \"Download request failed\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\terr = __mt76_mcu_send_firmware(&dev->mt76, MCU_CMD(FW_SCATTER),\n\t\t\t\t\t       data + offset, len, 4096);\n\t\tif (err) {\n\t\t\tdev_err(dev->mt76.dev, \"Failed to send firmware.\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\toffset += len;\n\t}\n\n\tif (override)\n\t\toption |= FW_START_OVERRIDE;\n\n\tif (type == MT7996_RAM_TYPE_WA)\n\t\toption |= FW_START_WORKING_PDA_CR4;\n\telse if (type == MT7996_RAM_TYPE_DSP)\n\t\toption |= FW_START_WORKING_PDA_DSP;\n\n\treturn mt76_connac_mcu_start_firmware(&dev->mt76, override, option);\n}\n\nstatic int __mt7996_load_ram(struct mt7996_dev *dev, const char *fw_type,\n\t\t\t     const char *fw_file, enum mt7996_ram_type ram_type)\n{\n\tconst struct mt7996_fw_trailer *hdr;\n\tconst struct firmware *fw;\n\tint ret;\n\n\tret = request_firmware(&fw, fw_file, dev->mt76.dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!fw || !fw->data || fw->size < sizeof(*hdr)) {\n\t\tdev_err(dev->mt76.dev, \"Invalid firmware\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\thdr = (const void *)(fw->data + fw->size - sizeof(*hdr));\n\tdev_info(dev->mt76.dev, \"%s Firmware Version: %.10s, Build Time: %.15s\\n\",\n\t\t fw_type, hdr->fw_ver, hdr->build_date);\n\n\tret = mt7996_mcu_send_ram_firmware(dev, hdr, fw->data, ram_type);\n\tif (ret) {\n\t\tdev_err(dev->mt76.dev, \"Failed to start %s firmware\\n\", fw_type);\n\t\tgoto out;\n\t}\n\n\tsnprintf(dev->mt76.hw->wiphy->fw_version,\n\t\t sizeof(dev->mt76.hw->wiphy->fw_version),\n\t\t \"%.10s-%.15s\", hdr->fw_ver, hdr->build_date);\n\nout:\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\nstatic int mt7996_load_ram(struct mt7996_dev *dev)\n{\n\tint ret;\n\n\tret = __mt7996_load_ram(dev, \"WM\", MT7996_FIRMWARE_WM,\n\t\t\t\tMT7996_RAM_TYPE_WM);\n\tif (ret)\n\t\treturn ret;\n\n\tret = __mt7996_load_ram(dev, \"DSP\", MT7996_FIRMWARE_DSP,\n\t\t\t\tMT7996_RAM_TYPE_DSP);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __mt7996_load_ram(dev, \"WA\", MT7996_FIRMWARE_WA,\n\t\t\t\t MT7996_RAM_TYPE_WA);\n}\n\nstatic int\nmt7996_firmware_state(struct mt7996_dev *dev, bool wa)\n{\n\tu32 state = FIELD_PREP(MT_TOP_MISC_FW_STATE,\n\t\t\t       wa ? FW_STATE_RDY : FW_STATE_FW_DOWNLOAD);\n\n\tif (!mt76_poll_msec(dev, MT_TOP_MISC, MT_TOP_MISC_FW_STATE,\n\t\t\t    state, 1000)) {\n\t\tdev_err(dev->mt76.dev, \"Timeout for initializing firmware\\n\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int\nmt7996_mcu_restart(struct mt76_dev *dev)\n{\n\tstruct {\n\t\tu8 __rsv1[4];\n\n\t\t__le16 tag;\n\t\t__le16 len;\n\t\tu8 power_mode;\n\t\tu8 __rsv2[3];\n\t} __packed req = {\n\t\t.tag = cpu_to_le16(UNI_POWER_OFF),\n\t\t.len = cpu_to_le16(sizeof(req) - 4),\n\t\t.power_mode = 1,\n\t};\n\n\treturn mt76_mcu_send_msg(dev, MCU_WM_UNI_CMD(POWER_CTRL), &req,\n\t\t\t\t sizeof(req), false);\n}\n\nstatic int mt7996_load_firmware(struct mt7996_dev *dev)\n{\n\tint ret;\n\n\t \n\tif (mt7996_firmware_state(dev, false)) {\n\t\t \n\t\tmt7996_mcu_restart(&dev->mt76);\n\t\tret = mt7996_firmware_state(dev, false);\n\t\tif (ret) {\n\t\t\tdev_err(dev->mt76.dev,\n\t\t\t\t\"Firmware is not ready for download\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = mt7996_load_patch(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7996_load_ram(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7996_firmware_state(dev, true);\n\tif (ret)\n\t\treturn ret;\n\n\tmt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[MT_MCUQ_FWDL], false);\n\n\tdev_dbg(dev->mt76.dev, \"Firmware init done\\n\");\n\n\treturn 0;\n}\n\nint mt7996_mcu_fw_log_2_host(struct mt7996_dev *dev, u8 type, u8 ctrl)\n{\n\tstruct {\n\t\tu8 _rsv[4];\n\n\t\t__le16 tag;\n\t\t__le16 len;\n\t\tu8 ctrl;\n\t\tu8 interval;\n\t\tu8 _rsv2[2];\n\t} __packed data = {\n\t\t.tag = cpu_to_le16(UNI_WSYS_CONFIG_FW_LOG_CTRL),\n\t\t.len = cpu_to_le16(sizeof(data) - 4),\n\t\t.ctrl = ctrl,\n\t};\n\n\tif (type == MCU_FW_LOG_WA)\n\t\treturn mt76_mcu_send_msg(&dev->mt76, MCU_WA_UNI_CMD(WSYS_CONFIG),\n\t\t\t\t\t &data, sizeof(data), true);\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(WSYS_CONFIG), &data,\n\t\t\t\t sizeof(data), true);\n}\n\nint mt7996_mcu_fw_dbg_ctrl(struct mt7996_dev *dev, u32 module, u8 level)\n{\n\tstruct {\n\t\tu8 _rsv[4];\n\n\t\t__le16 tag;\n\t\t__le16 len;\n\t\t__le32 module_idx;\n\t\tu8 level;\n\t\tu8 _rsv2[3];\n\t} data = {\n\t\t.tag = cpu_to_le16(UNI_WSYS_CONFIG_FW_DBG_CTRL),\n\t\t.len = cpu_to_le16(sizeof(data) - 4),\n\t\t.module_idx = cpu_to_le32(module),\n\t\t.level = level,\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(WSYS_CONFIG), &data,\n\t\t\t\t sizeof(data), false);\n}\n\nstatic int mt7996_mcu_set_mwds(struct mt7996_dev *dev, bool enabled)\n{\n\tstruct {\n\t\tu8 enable;\n\t\tu8 _rsv[3];\n\t} __packed req = {\n\t\t.enable = enabled\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_WA_EXT_CMD(MWDS_SUPPORT), &req,\n\t\t\t\t sizeof(req), false);\n}\n\nstatic void mt7996_add_rx_airtime_tlv(struct sk_buff *skb, u8 band_idx)\n{\n\tstruct vow_rx_airtime *req;\n\tstruct tlv *tlv;\n\n\ttlv = mt7996_mcu_add_uni_tlv(skb, UNI_VOW_RX_AT_AIRTIME_CLR_EN, sizeof(*req));\n\treq = (struct vow_rx_airtime *)tlv;\n\treq->enable = true;\n\treq->band = band_idx;\n\n\ttlv = mt7996_mcu_add_uni_tlv(skb, UNI_VOW_RX_AT_AIRTIME_EN, sizeof(*req));\n\treq = (struct vow_rx_airtime *)tlv;\n\treq->enable = true;\n\treq->band = band_idx;\n}\n\nstatic int\nmt7996_mcu_init_rx_airtime(struct mt7996_dev *dev)\n{\n\tstruct uni_header hdr = {};\n\tstruct sk_buff *skb;\n\tint len, num;\n\n\tnum = 2 + 2 * (dev->dbdc_support + dev->tbtc_support);\n\tlen = sizeof(hdr) + num * sizeof(struct vow_rx_airtime);\n\tskb = mt76_mcu_msg_alloc(&dev->mt76, NULL, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_data(skb, &hdr, sizeof(hdr));\n\n\tmt7996_add_rx_airtime_tlv(skb, dev->mt76.phy.band_idx);\n\n\tif (dev->dbdc_support)\n\t\tmt7996_add_rx_airtime_tlv(skb, MT_BAND1);\n\n\tif (dev->tbtc_support)\n\t\tmt7996_add_rx_airtime_tlv(skb, MT_BAND2);\n\n\treturn mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t     MCU_WM_UNI_CMD(VOW), true);\n}\n\nint mt7996_mcu_init_firmware(struct mt7996_dev *dev)\n{\n\tint ret;\n\n\t \n\tmt76_wr(dev, MT_SWDEF_MODE, MT_SWDEF_NORMAL_MODE);\n\n\tret = mt7996_driver_own(dev, 0);\n\tif (ret)\n\t\treturn ret;\n\t \n\tif (dev->hif2) {\n\t\tret = mt7996_driver_own(dev, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = mt7996_load_firmware(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tset_bit(MT76_STATE_MCU_RUNNING, &dev->mphy.state);\n\tret = mt7996_mcu_fw_log_2_host(dev, MCU_FW_LOG_WM, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7996_mcu_fw_log_2_host(dev, MCU_FW_LOG_WA, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7996_mcu_set_mwds(dev, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7996_mcu_init_rx_airtime(dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mt7996_mcu_wa_cmd(dev, MCU_WA_PARAM_CMD(SET),\n\t\t\t\t MCU_WA_PARAM_RED, 0, 0);\n}\n\nint mt7996_mcu_init(struct mt7996_dev *dev)\n{\n\tstatic const struct mt76_mcu_ops mt7996_mcu_ops = {\n\t\t.headroom = sizeof(struct mt76_connac2_mcu_txd),  \n\t\t.mcu_skb_send_msg = mt7996_mcu_send_message,\n\t\t.mcu_parse_response = mt7996_mcu_parse_response,\n\t};\n\n\tdev->mt76.mcu_ops = &mt7996_mcu_ops;\n\n\treturn mt7996_mcu_init_firmware(dev);\n}\n\nvoid mt7996_mcu_exit(struct mt7996_dev *dev)\n{\n\tmt7996_mcu_restart(&dev->mt76);\n\tif (mt7996_firmware_state(dev, false)) {\n\t\tdev_err(dev->mt76.dev, \"Failed to exit mcu\\n\");\n\t\tgoto out;\n\t}\n\n\tmt76_wr(dev, MT_TOP_LPCR_HOST_BAND(0), MT_TOP_LPCR_HOST_FW_OWN);\n\tif (dev->hif2)\n\t\tmt76_wr(dev, MT_TOP_LPCR_HOST_BAND(1),\n\t\t\tMT_TOP_LPCR_HOST_FW_OWN);\nout:\n\tskb_queue_purge(&dev->mt76.mcu.res_q);\n}\n\nint mt7996_mcu_set_hdr_trans(struct mt7996_dev *dev, bool hdr_trans)\n{\n\tstruct {\n\t\tu8 __rsv[4];\n\t} __packed hdr;\n\tstruct hdr_trans_blacklist *req_blacklist;\n\tstruct hdr_trans_en *req_en;\n\tstruct sk_buff *skb;\n\tstruct tlv *tlv;\n\tint len = MT7996_HDR_TRANS_MAX_SIZE + sizeof(hdr);\n\n\tskb = mt76_mcu_msg_alloc(&dev->mt76, NULL, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_data(skb, &hdr, sizeof(hdr));\n\n\ttlv = mt7996_mcu_add_uni_tlv(skb, UNI_HDR_TRANS_EN, sizeof(*req_en));\n\treq_en = (struct hdr_trans_en *)tlv;\n\treq_en->enable = hdr_trans;\n\n\ttlv = mt7996_mcu_add_uni_tlv(skb, UNI_HDR_TRANS_VLAN,\n\t\t\t\t     sizeof(struct hdr_trans_vlan));\n\n\tif (hdr_trans) {\n\t\ttlv = mt7996_mcu_add_uni_tlv(skb, UNI_HDR_TRANS_BLACKLIST,\n\t\t\t\t\t     sizeof(*req_blacklist));\n\t\treq_blacklist = (struct hdr_trans_blacklist *)tlv;\n\t\treq_blacklist->enable = 1;\n\t\treq_blacklist->type = cpu_to_le16(ETH_P_PAE);\n\t}\n\n\treturn mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t     MCU_WM_UNI_CMD(RX_HDR_TRANS), true);\n}\n\nint mt7996_mcu_set_tx(struct mt7996_dev *dev, struct ieee80211_vif *vif)\n{\n#define MCU_EDCA_AC_PARAM\t0\n#define WMM_AIFS_SET\t\tBIT(0)\n#define WMM_CW_MIN_SET\t\tBIT(1)\n#define WMM_CW_MAX_SET\t\tBIT(2)\n#define WMM_TXOP_SET\t\tBIT(3)\n#define WMM_PARAM_SET\t\t(WMM_AIFS_SET | WMM_CW_MIN_SET | \\\n\t\t\t\t WMM_CW_MAX_SET | WMM_TXOP_SET)\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tstruct {\n\t\tu8 bss_idx;\n\t\tu8 __rsv[3];\n\t} __packed hdr = {\n\t\t.bss_idx = mvif->mt76.idx,\n\t};\n\tstruct sk_buff *skb;\n\tint len = sizeof(hdr) + IEEE80211_NUM_ACS * sizeof(struct edca);\n\tint ac;\n\n\tskb = mt76_mcu_msg_alloc(&dev->mt76, NULL, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_data(skb, &hdr, sizeof(hdr));\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tstruct ieee80211_tx_queue_params *q = &mvif->queue_params[ac];\n\t\tstruct edca *e;\n\t\tstruct tlv *tlv;\n\n\t\ttlv = mt7996_mcu_add_uni_tlv(skb, MCU_EDCA_AC_PARAM, sizeof(*e));\n\n\t\te = (struct edca *)tlv;\n\t\te->set = WMM_PARAM_SET;\n\t\te->queue = ac;\n\t\te->aifs = q->aifs;\n\t\te->txop = cpu_to_le16(q->txop);\n\n\t\tif (q->cw_min)\n\t\t\te->cw_min = fls(q->cw_min);\n\t\telse\n\t\t\te->cw_min = 5;\n\n\t\tif (q->cw_max)\n\t\t\te->cw_max = fls(q->cw_max);\n\t\telse\n\t\t\te->cw_max = 10;\n\t}\n\n\treturn mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t     MCU_WM_UNI_CMD(EDCA_UPDATE), true);\n}\n\nint mt7996_mcu_set_fcc5_lpn(struct mt7996_dev *dev, int val)\n{\n\tstruct {\n\t\tu8 _rsv[4];\n\n\t\t__le16 tag;\n\t\t__le16 len;\n\n\t\t__le32 ctrl;\n\t\t__le16 min_lpn;\n\t\tu8 rsv[2];\n\t} __packed req = {\n\t\t.tag = cpu_to_le16(UNI_RDD_CTRL_SET_TH),\n\t\t.len = cpu_to_le16(sizeof(req) - 4),\n\n\t\t.ctrl = cpu_to_le32(0x1),\n\t\t.min_lpn = cpu_to_le16(val),\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(RDD_CTRL),\n\t\t\t\t &req, sizeof(req), true);\n}\n\nint mt7996_mcu_set_pulse_th(struct mt7996_dev *dev,\n\t\t\t    const struct mt7996_dfs_pulse *pulse)\n{\n\tstruct {\n\t\tu8 _rsv[4];\n\n\t\t__le16 tag;\n\t\t__le16 len;\n\n\t\t__le32 ctrl;\n\n\t\t__le32 max_width;\t\t \n\t\t__le32 max_pwr;\t\t\t \n\t\t__le32 min_pwr;\t\t\t \n\t\t__le32 min_stgr_pri;\t\t \n\t\t__le32 max_stgr_pri;\t\t \n\t\t__le32 min_cr_pri;\t\t \n\t\t__le32 max_cr_pri;\t\t \n\t} __packed req = {\n\t\t.tag = cpu_to_le16(UNI_RDD_CTRL_SET_TH),\n\t\t.len = cpu_to_le16(sizeof(req) - 4),\n\n\t\t.ctrl = cpu_to_le32(0x3),\n\n#define __req_field(field) .field = cpu_to_le32(pulse->field)\n\t\t__req_field(max_width),\n\t\t__req_field(max_pwr),\n\t\t__req_field(min_pwr),\n\t\t__req_field(min_stgr_pri),\n\t\t__req_field(max_stgr_pri),\n\t\t__req_field(min_cr_pri),\n\t\t__req_field(max_cr_pri),\n#undef __req_field\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(RDD_CTRL),\n\t\t\t\t &req, sizeof(req), true);\n}\n\nint mt7996_mcu_set_radar_th(struct mt7996_dev *dev, int index,\n\t\t\t    const struct mt7996_dfs_pattern *pattern)\n{\n\tstruct {\n\t\tu8 _rsv[4];\n\n\t\t__le16 tag;\n\t\t__le16 len;\n\n\t\t__le32 ctrl;\n\t\t__le16 radar_type;\n\n\t\tu8 enb;\n\t\tu8 stgr;\n\t\tu8 min_crpn;\n\t\tu8 max_crpn;\n\t\tu8 min_crpr;\n\t\tu8 min_pw;\n\t\t__le32 min_pri;\n\t\t__le32 max_pri;\n\t\tu8 max_pw;\n\t\tu8 min_crbn;\n\t\tu8 max_crbn;\n\t\tu8 min_stgpn;\n\t\tu8 max_stgpn;\n\t\tu8 min_stgpr;\n\t\tu8 rsv[2];\n\t\t__le32 min_stgpr_diff;\n\t} __packed req = {\n\t\t.tag = cpu_to_le16(UNI_RDD_CTRL_SET_TH),\n\t\t.len = cpu_to_le16(sizeof(req) - 4),\n\n\t\t.ctrl = cpu_to_le32(0x2),\n\t\t.radar_type = cpu_to_le16(index),\n\n#define __req_field_u8(field) .field = pattern->field\n#define __req_field_u32(field) .field = cpu_to_le32(pattern->field)\n\t\t__req_field_u8(enb),\n\t\t__req_field_u8(stgr),\n\t\t__req_field_u8(min_crpn),\n\t\t__req_field_u8(max_crpn),\n\t\t__req_field_u8(min_crpr),\n\t\t__req_field_u8(min_pw),\n\t\t__req_field_u32(min_pri),\n\t\t__req_field_u32(max_pri),\n\t\t__req_field_u8(max_pw),\n\t\t__req_field_u8(min_crbn),\n\t\t__req_field_u8(max_crbn),\n\t\t__req_field_u8(min_stgpn),\n\t\t__req_field_u8(max_stgpn),\n\t\t__req_field_u8(min_stgpr),\n\t\t__req_field_u32(min_stgpr_diff),\n#undef __req_field_u8\n#undef __req_field_u32\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(RDD_CTRL),\n\t\t\t\t &req, sizeof(req), true);\n}\n\nstatic int\nmt7996_mcu_background_chain_ctrl(struct mt7996_phy *phy,\n\t\t\t\t struct cfg80211_chan_def *chandef,\n\t\t\t\t int cmd)\n{\n\tstruct mt7996_dev *dev = phy->dev;\n\tstruct mt76_phy *mphy = phy->mt76;\n\tstruct ieee80211_channel *chan = mphy->chandef.chan;\n\tint freq = mphy->chandef.center_freq1;\n\tstruct mt7996_mcu_background_chain_ctrl req = {\n\t\t.tag = cpu_to_le16(0),\n\t\t.len = cpu_to_le16(sizeof(req) - 4),\n\t\t.monitor_scan_type = 2,  \n\t};\n\n\tif (!chandef && cmd != CH_SWITCH_BACKGROUND_SCAN_STOP)\n\t\treturn -EINVAL;\n\n\tif (!cfg80211_chandef_valid(&mphy->chandef))\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase CH_SWITCH_BACKGROUND_SCAN_START: {\n\t\treq.chan = chan->hw_value;\n\t\treq.central_chan = ieee80211_frequency_to_channel(freq);\n\t\treq.bw = mt76_connac_chan_bw(&mphy->chandef);\n\t\treq.monitor_chan = chandef->chan->hw_value;\n\t\treq.monitor_central_chan =\n\t\t\tieee80211_frequency_to_channel(chandef->center_freq1);\n\t\treq.monitor_bw = mt76_connac_chan_bw(chandef);\n\t\treq.band_idx = phy->mt76->band_idx;\n\t\treq.scan_mode = 1;\n\t\tbreak;\n\t}\n\tcase CH_SWITCH_BACKGROUND_SCAN_RUNNING:\n\t\treq.monitor_chan = chandef->chan->hw_value;\n\t\treq.monitor_central_chan =\n\t\t\tieee80211_frequency_to_channel(chandef->center_freq1);\n\t\treq.band_idx = phy->mt76->band_idx;\n\t\treq.scan_mode = 2;\n\t\tbreak;\n\tcase CH_SWITCH_BACKGROUND_SCAN_STOP:\n\t\treq.chan = chan->hw_value;\n\t\treq.central_chan = ieee80211_frequency_to_channel(freq);\n\t\treq.bw = mt76_connac_chan_bw(&mphy->chandef);\n\t\treq.tx_stream = hweight8(mphy->antenna_mask);\n\t\treq.rx_stream = mphy->antenna_mask;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treq.band = chandef ? chandef->chan->band == NL80211_BAND_5GHZ : 1;\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(OFFCH_SCAN_CTRL),\n\t\t\t\t &req, sizeof(req), false);\n}\n\nint mt7996_mcu_rdd_background_enable(struct mt7996_phy *phy,\n\t\t\t\t     struct cfg80211_chan_def *chandef)\n{\n\tstruct mt7996_dev *dev = phy->dev;\n\tint err, region;\n\n\tif (!chandef) {  \n\t\terr = mt7996_mcu_rdd_cmd(dev, RDD_STOP, MT_RX_SEL2,\n\t\t\t\t\t 0, 0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn mt7996_mcu_background_chain_ctrl(phy, NULL,\n\t\t\t\tCH_SWITCH_BACKGROUND_SCAN_STOP);\n\t}\n\n\terr = mt7996_mcu_background_chain_ctrl(phy, chandef,\n\t\t\t\t\t       CH_SWITCH_BACKGROUND_SCAN_START);\n\tif (err)\n\t\treturn err;\n\n\tswitch (dev->mt76.region) {\n\tcase NL80211_DFS_ETSI:\n\t\tregion = 0;\n\t\tbreak;\n\tcase NL80211_DFS_JP:\n\t\tregion = 2;\n\t\tbreak;\n\tcase NL80211_DFS_FCC:\n\tdefault:\n\t\tregion = 1;\n\t\tbreak;\n\t}\n\n\treturn mt7996_mcu_rdd_cmd(dev, RDD_START, MT_RX_SEL2,\n\t\t\t\t  0, region);\n}\n\nint mt7996_mcu_set_chan_info(struct mt7996_phy *phy, u16 tag)\n{\n\tstatic const u8 ch_band[] = {\n\t\t[NL80211_BAND_2GHZ] = 0,\n\t\t[NL80211_BAND_5GHZ] = 1,\n\t\t[NL80211_BAND_6GHZ] = 2,\n\t};\n\tstruct mt7996_dev *dev = phy->dev;\n\tstruct cfg80211_chan_def *chandef = &phy->mt76->chandef;\n\tint freq1 = chandef->center_freq1;\n\tu8 band_idx = phy->mt76->band_idx;\n\tstruct {\n\t\t \n\t\tu8 __rsv[4];\n\n\t\t__le16 tag;\n\t\t__le16 len;\n\t\tu8 control_ch;\n\t\tu8 center_ch;\n\t\tu8 bw;\n\t\tu8 tx_path_num;\n\t\tu8 rx_path;\t \n\t\tu8 switch_reason;\n\t\tu8 band_idx;\n\t\tu8 center_ch2;\t \n\t\t__le16 cac_case;\n\t\tu8 channel_band;\n\t\tu8 rsv0;\n\t\t__le32 outband_freq;\n\t\tu8 txpower_drop;\n\t\tu8 ap_bw;\n\t\tu8 ap_center_ch;\n\t\tu8 rsv1[53];\n\t} __packed req = {\n\t\t.tag = cpu_to_le16(tag),\n\t\t.len = cpu_to_le16(sizeof(req) - 4),\n\t\t.control_ch = chandef->chan->hw_value,\n\t\t.center_ch = ieee80211_frequency_to_channel(freq1),\n\t\t.bw = mt76_connac_chan_bw(chandef),\n\t\t.tx_path_num = hweight16(phy->mt76->chainmask),\n\t\t.rx_path = phy->mt76->chainmask >> dev->chainshift[band_idx],\n\t\t.band_idx = band_idx,\n\t\t.channel_band = ch_band[chandef->chan->band],\n\t};\n\n\tif (phy->mt76->hw->conf.flags & IEEE80211_CONF_MONITOR)\n\t\treq.switch_reason = CH_SWITCH_NORMAL;\n\telse if (phy->mt76->hw->conf.flags & IEEE80211_CONF_OFFCHANNEL ||\n\t\t phy->mt76->hw->conf.flags & IEEE80211_CONF_IDLE)\n\t\treq.switch_reason = CH_SWITCH_SCAN_BYPASS_DPD;\n\telse if (!cfg80211_reg_can_beacon(phy->mt76->hw->wiphy, chandef,\n\t\t\t\t\t  NL80211_IFTYPE_AP))\n\t\treq.switch_reason = CH_SWITCH_DFS;\n\telse\n\t\treq.switch_reason = CH_SWITCH_NORMAL;\n\n\tif (tag == UNI_CHANNEL_SWITCH)\n\t\treq.rx_path = hweight8(req.rx_path);\n\n\tif (chandef->width == NL80211_CHAN_WIDTH_80P80) {\n\t\tint freq2 = chandef->center_freq2;\n\n\t\treq.center_ch2 = ieee80211_frequency_to_channel(freq2);\n\t}\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_WMWA_UNI_CMD(CHANNEL_SWITCH),\n\t\t\t\t &req, sizeof(req), true);\n}\n\nstatic int mt7996_mcu_set_eeprom_flash(struct mt7996_dev *dev)\n{\n#define MAX_PAGE_IDX_MASK\tGENMASK(7, 5)\n#define PAGE_IDX_MASK\t\tGENMASK(4, 2)\n#define PER_PAGE_SIZE\t\t0x400\n\tstruct mt7996_mcu_eeprom req = {\n\t\t.tag = cpu_to_le16(UNI_EFUSE_BUFFER_MODE),\n\t\t.buffer_mode = EE_MODE_BUFFER\n\t};\n\tu16 eeprom_size = MT7996_EEPROM_SIZE;\n\tu8 total = DIV_ROUND_UP(eeprom_size, PER_PAGE_SIZE);\n\tu8 *eep = (u8 *)dev->mt76.eeprom.data;\n\tint eep_len, i;\n\n\tfor (i = 0; i < total; i++, eep += eep_len) {\n\t\tstruct sk_buff *skb;\n\t\tint ret, msg_len;\n\n\t\tif (i == total - 1 && !!(eeprom_size % PER_PAGE_SIZE))\n\t\t\teep_len = eeprom_size % PER_PAGE_SIZE;\n\t\telse\n\t\t\teep_len = PER_PAGE_SIZE;\n\n\t\tmsg_len = sizeof(req) + eep_len;\n\t\tskb = mt76_mcu_msg_alloc(&dev->mt76, NULL, msg_len);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\n\t\treq.len = cpu_to_le16(msg_len - 4);\n\t\treq.format = FIELD_PREP(MAX_PAGE_IDX_MASK, total - 1) |\n\t\t\t     FIELD_PREP(PAGE_IDX_MASK, i) | EE_FORMAT_WHOLE;\n\t\treq.buf_len = cpu_to_le16(eep_len);\n\n\t\tskb_put_data(skb, &req, sizeof(req));\n\t\tskb_put_data(skb, eep, eep_len);\n\n\t\tret = mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t\t    MCU_WM_UNI_CMD(EFUSE_CTRL), true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint mt7996_mcu_set_eeprom(struct mt7996_dev *dev)\n{\n\tstruct mt7996_mcu_eeprom req = {\n\t\t.tag = cpu_to_le16(UNI_EFUSE_BUFFER_MODE),\n\t\t.len = cpu_to_le16(sizeof(req) - 4),\n\t\t.buffer_mode = EE_MODE_EFUSE,\n\t\t.format = EE_FORMAT_WHOLE\n\t};\n\n\tif (dev->flash_mode)\n\t\treturn mt7996_mcu_set_eeprom_flash(dev);\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(EFUSE_CTRL),\n\t\t\t\t &req, sizeof(req), true);\n}\n\nint mt7996_mcu_get_eeprom(struct mt7996_dev *dev, u32 offset)\n{\n\tstruct {\n\t\tu8 _rsv[4];\n\n\t\t__le16 tag;\n\t\t__le16 len;\n\t\t__le32 addr;\n\t\t__le32 valid;\n\t\tu8 data[16];\n\t} __packed req = {\n\t\t.tag = cpu_to_le16(UNI_EFUSE_ACCESS),\n\t\t.len = cpu_to_le16(sizeof(req) - 4),\n\t\t.addr = cpu_to_le32(round_down(offset,\n\t\t\t\t    MT7996_EEPROM_BLOCK_SIZE)),\n\t};\n\tstruct sk_buff *skb;\n\tbool valid;\n\tint ret;\n\n\tret = mt76_mcu_send_and_get_msg(&dev->mt76,\n\t\t\t\t\tMCU_WM_UNI_CMD_QUERY(EFUSE_CTRL),\n\t\t\t\t\t&req, sizeof(req), true, &skb);\n\tif (ret)\n\t\treturn ret;\n\n\tvalid = le32_to_cpu(*(__le32 *)(skb->data + 16));\n\tif (valid) {\n\t\tu32 addr = le32_to_cpu(*(__le32 *)(skb->data + 12));\n\t\tu8 *buf = (u8 *)dev->mt76.eeprom.data + addr;\n\n\t\tskb_pull(skb, 64);\n\t\tmemcpy(buf, skb->data, MT7996_EEPROM_BLOCK_SIZE);\n\t}\n\n\tdev_kfree_skb(skb);\n\n\treturn 0;\n}\n\nint mt7996_mcu_get_eeprom_free_block(struct mt7996_dev *dev, u8 *block_num)\n{\n\tstruct {\n\t\tu8 _rsv[4];\n\n\t\t__le16 tag;\n\t\t__le16 len;\n\t\tu8 num;\n\t\tu8 version;\n\t\tu8 die_idx;\n\t\tu8 _rsv2;\n\t} __packed req = {\n\t\t.tag = cpu_to_le16(UNI_EFUSE_FREE_BLOCK),\n\t\t.len = cpu_to_le16(sizeof(req) - 4),\n\t\t.version = 2,\n\t};\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tret = mt76_mcu_send_and_get_msg(&dev->mt76, MCU_WM_UNI_CMD_QUERY(EFUSE_CTRL), &req,\n\t\t\t\t\tsizeof(req), true, &skb);\n\tif (ret)\n\t\treturn ret;\n\n\t*block_num = *(u8 *)(skb->data + 8);\n\tdev_kfree_skb(skb);\n\n\treturn 0;\n}\n\nint mt7996_mcu_get_chip_config(struct mt7996_dev *dev, u32 *cap)\n{\n#define NIC_CAP\t3\n#define UNI_EVENT_CHIP_CONFIG_EFUSE_VERSION\t0x21\n\tstruct {\n\t\tu8 _rsv[4];\n\n\t\t__le16 tag;\n\t\t__le16 len;\n\t} __packed req = {\n\t\t.tag = cpu_to_le16(NIC_CAP),\n\t\t.len = cpu_to_le16(sizeof(req) - 4),\n\t};\n\tstruct sk_buff *skb;\n\tu8 *buf;\n\tint ret;\n\n\tret = mt76_mcu_send_and_get_msg(&dev->mt76,\n\t\t\t\t\tMCU_WM_UNI_CMD_QUERY(CHIP_CONFIG), &req,\n\t\t\t\t\tsizeof(req), true, &skb);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tskb_pull(skb, 4);\n\n\tbuf = skb->data;\n\twhile (buf - skb->data < skb->len) {\n\t\tstruct tlv *tlv = (struct tlv *)buf;\n\n\t\tswitch (le16_to_cpu(tlv->tag)) {\n\t\tcase UNI_EVENT_CHIP_CONFIG_EFUSE_VERSION:\n\t\t\t*cap = le32_to_cpu(*(__le32 *)(buf + sizeof(*tlv)));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf += le16_to_cpu(tlv->len);\n\t}\n\n\tdev_kfree_skb(skb);\n\n\treturn 0;\n}\n\nint mt7996_mcu_get_chan_mib_info(struct mt7996_phy *phy, bool chan_switch)\n{\n\tstruct {\n\t\tstruct {\n\t\t\tu8 band;\n\t\t\tu8 __rsv[3];\n\t\t} hdr;\n\t\tstruct {\n\t\t\t__le16 tag;\n\t\t\t__le16 len;\n\t\t\t__le32 offs;\n\t\t} data[4];\n\t} __packed req = {\n\t\t.hdr.band = phy->mt76->band_idx,\n\t};\n\t \n\tstatic const u32 offs[] = {\n\t\tUNI_MIB_TX_TIME,\n\t\tUNI_MIB_RX_TIME,\n\t\tUNI_MIB_OBSS_AIRTIME,\n\t\tUNI_MIB_NON_WIFI_TIME,\n\t};\n\tstruct mt76_channel_state *state = phy->mt76->chan_state;\n\tstruct mt76_channel_state *state_ts = &phy->state_ts;\n\tstruct mt7996_dev *dev = phy->dev;\n\tstruct mt7996_mcu_mib *res;\n\tstruct sk_buff *skb;\n\tint i, ret;\n\n\tfor (i = 0; i < 4; i++) {\n\t\treq.data[i].tag = cpu_to_le16(UNI_CMD_MIB_DATA);\n\t\treq.data[i].len = cpu_to_le16(sizeof(req.data[i]));\n\t\treq.data[i].offs = cpu_to_le32(offs[i]);\n\t}\n\n\tret = mt76_mcu_send_and_get_msg(&dev->mt76, MCU_WM_UNI_CMD_QUERY(GET_MIB_INFO),\n\t\t\t\t\t&req, sizeof(req), true, &skb);\n\tif (ret)\n\t\treturn ret;\n\n\tskb_pull(skb, sizeof(req.hdr));\n\n\tres = (struct mt7996_mcu_mib *)(skb->data);\n\n\tif (chan_switch)\n\t\tgoto out;\n\n#define __res_u64(s) le64_to_cpu(res[s].data)\n\tstate->cc_tx += __res_u64(1) - state_ts->cc_tx;\n\tstate->cc_bss_rx += __res_u64(2) - state_ts->cc_bss_rx;\n\tstate->cc_rx += __res_u64(2) + __res_u64(3) - state_ts->cc_rx;\n\tstate->cc_busy += __res_u64(0) + __res_u64(1) + __res_u64(2) + __res_u64(3) -\n\t\t\t  state_ts->cc_busy;\n\nout:\n\tstate_ts->cc_tx = __res_u64(1);\n\tstate_ts->cc_bss_rx = __res_u64(2);\n\tstate_ts->cc_rx = __res_u64(2) + __res_u64(3);\n\tstate_ts->cc_busy = __res_u64(0) + __res_u64(1) + __res_u64(2) + __res_u64(3);\n#undef __res_u64\n\n\tdev_kfree_skb(skb);\n\n\treturn 0;\n}\n\nint mt7996_mcu_set_ser(struct mt7996_dev *dev, u8 action, u8 val, u8 band)\n{\n\tstruct {\n\t\tu8 rsv[4];\n\n\t\t__le16 tag;\n\t\t__le16 len;\n\n\t\tunion {\n\t\t\tstruct {\n\t\t\t\t__le32 mask;\n\t\t\t} __packed set;\n\n\t\t\tstruct {\n\t\t\t\tu8 method;\n\t\t\t\tu8 band;\n\t\t\t\tu8 rsv2[2];\n\t\t\t} __packed trigger;\n\t\t};\n\t} __packed req = {\n\t\t.tag = cpu_to_le16(action),\n\t\t.len = cpu_to_le16(sizeof(req) - 4),\n\t};\n\n\tswitch (action) {\n\tcase UNI_CMD_SER_SET:\n\t\treq.set.mask = cpu_to_le32(val);\n\t\tbreak;\n\tcase UNI_CMD_SER_TRIGGER:\n\t\treq.trigger.method = val;\n\t\treq.trigger.band = band;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(SER),\n\t\t\t\t &req, sizeof(req), false);\n}\n\nint mt7996_mcu_set_txbf(struct mt7996_dev *dev, u8 action)\n{\n#define MT7996_BF_MAX_SIZE\tsizeof(union bf_tag_tlv)\n#define BF_PROCESSING\t4\n\tstruct uni_header hdr;\n\tstruct sk_buff *skb;\n\tstruct tlv *tlv;\n\tint len = sizeof(hdr) + MT7996_BF_MAX_SIZE;\n\n\tmemset(&hdr, 0, sizeof(hdr));\n\n\tskb = mt76_mcu_msg_alloc(&dev->mt76, NULL, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_data(skb, &hdr, sizeof(hdr));\n\n\tswitch (action) {\n\tcase BF_SOUNDING_ON: {\n\t\tstruct bf_sounding_on *req_snd_on;\n\n\t\ttlv = mt7996_mcu_add_uni_tlv(skb, action, sizeof(*req_snd_on));\n\t\treq_snd_on = (struct bf_sounding_on *)tlv;\n\t\treq_snd_on->snd_mode = BF_PROCESSING;\n\t\tbreak;\n\t}\n\tcase BF_HW_EN_UPDATE: {\n\t\tstruct bf_hw_en_status_update *req_hw_en;\n\n\t\ttlv = mt7996_mcu_add_uni_tlv(skb, action, sizeof(*req_hw_en));\n\t\treq_hw_en = (struct bf_hw_en_status_update *)tlv;\n\t\treq_hw_en->ebf = true;\n\t\treq_hw_en->ibf = dev->ibf;\n\t\tbreak;\n\t}\n\tcase BF_MOD_EN_CTRL: {\n\t\tstruct bf_mod_en_ctrl *req_mod_en;\n\n\t\ttlv = mt7996_mcu_add_uni_tlv(skb, action, sizeof(*req_mod_en));\n\t\treq_mod_en = (struct bf_mod_en_ctrl *)tlv;\n\t\treq_mod_en->bf_num = 3;\n\t\treq_mod_en->bf_bitmap = GENMASK(2, 0);\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn mt76_mcu_skb_send_msg(&dev->mt76, skb, MCU_WM_UNI_CMD(BF), true);\n}\n\nstatic int\nmt7996_mcu_enable_obss_spr(struct mt7996_phy *phy, u16 action, u8 val)\n{\n\tstruct mt7996_dev *dev = phy->dev;\n\tstruct {\n\t\tu8 band_idx;\n\t\tu8 __rsv[3];\n\n\t\t__le16 tag;\n\t\t__le16 len;\n\n\t\t__le32 val;\n\t} __packed req = {\n\t\t.band_idx = phy->mt76->band_idx,\n\t\t.tag = cpu_to_le16(action),\n\t\t.len = cpu_to_le16(sizeof(req) - 4),\n\t\t.val = cpu_to_le32(val),\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(SR),\n\t\t\t\t &req, sizeof(req), true);\n}\n\nstatic int\nmt7996_mcu_set_obss_spr_pd(struct mt7996_phy *phy,\n\t\t\t   struct ieee80211_he_obss_pd *he_obss_pd)\n{\n\tstruct mt7996_dev *dev = phy->dev;\n\tu8 max_th = 82, non_srg_max_th = 62;\n\tstruct {\n\t\tu8 band_idx;\n\t\tu8 __rsv[3];\n\n\t\t__le16 tag;\n\t\t__le16 len;\n\n\t\tu8 pd_th_non_srg;\n\t\tu8 pd_th_srg;\n\t\tu8 period_offs;\n\t\tu8 rcpi_src;\n\t\t__le16 obss_pd_min;\n\t\t__le16 obss_pd_min_srg;\n\t\tu8 resp_txpwr_mode;\n\t\tu8 txpwr_restrict_mode;\n\t\tu8 txpwr_ref;\n\t\tu8 __rsv2[3];\n\t} __packed req = {\n\t\t.band_idx = phy->mt76->band_idx,\n\t\t.tag = cpu_to_le16(UNI_CMD_SR_SET_PARAM),\n\t\t.len = cpu_to_le16(sizeof(req) - 4),\n\t\t.obss_pd_min = cpu_to_le16(max_th),\n\t\t.obss_pd_min_srg = cpu_to_le16(max_th),\n\t\t.txpwr_restrict_mode = 2,\n\t\t.txpwr_ref = 21\n\t};\n\tint ret;\n\n\t \n\tret = mt7996_mcu_enable_obss_spr(phy, UNI_CMD_SR_ENABLE_DPD, false);\n\tif (ret)\n\t\treturn ret;\n\n\tif (he_obss_pd->sr_ctrl &\n\t    IEEE80211_HE_SPR_NON_SRG_OBSS_PD_SR_DISALLOWED)\n\t\treq.pd_th_non_srg = max_th;\n\telse if (he_obss_pd->sr_ctrl & IEEE80211_HE_SPR_NON_SRG_OFFSET_PRESENT)\n\t\treq.pd_th_non_srg  = max_th - he_obss_pd->non_srg_max_offset;\n\telse\n\t\treq.pd_th_non_srg  = non_srg_max_th;\n\n\tif (he_obss_pd->sr_ctrl & IEEE80211_HE_SPR_SRG_INFORMATION_PRESENT)\n\t\treq.pd_th_srg = max_th - he_obss_pd->max_offset;\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(SR),\n\t\t\t\t &req, sizeof(req), true);\n}\n\nstatic int\nmt7996_mcu_set_obss_spr_siga(struct mt7996_phy *phy, struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_he_obss_pd *he_obss_pd)\n{\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tstruct mt7996_dev *dev = phy->dev;\n\tu8 omac = mvif->mt76.omac_idx;\n\tstruct {\n\t\tu8 band_idx;\n\t\tu8 __rsv[3];\n\n\t\t__le16 tag;\n\t\t__le16 len;\n\n\t\tu8 omac;\n\t\tu8 __rsv2[3];\n\t\tu8 flag[20];\n\t} __packed req = {\n\t\t.band_idx = phy->mt76->band_idx,\n\t\t.tag = cpu_to_le16(UNI_CMD_SR_SET_SIGA),\n\t\t.len = cpu_to_le16(sizeof(req) - 4),\n\t\t.omac = omac > HW_BSSID_MAX ? omac - 12 : omac,\n\t};\n\tint ret;\n\n\tif (he_obss_pd->sr_ctrl & IEEE80211_HE_SPR_HESIGA_SR_VAL15_ALLOWED)\n\t\treq.flag[req.omac] = 0xf;\n\telse\n\t\treturn 0;\n\n\t \n\tret = mt7996_mcu_enable_obss_spr(phy, UNI_CMD_SR_ENABLE_MODE, 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(SR),\n\t\t\t\t &req, sizeof(req), true);\n}\n\nstatic int\nmt7996_mcu_set_obss_spr_bitmap(struct mt7996_phy *phy,\n\t\t\t       struct ieee80211_he_obss_pd *he_obss_pd)\n{\n\tstruct mt7996_dev *dev = phy->dev;\n\tstruct {\n\t\tu8 band_idx;\n\t\tu8 __rsv[3];\n\n\t\t__le16 tag;\n\t\t__le16 len;\n\n\t\t__le32 color_l[2];\n\t\t__le32 color_h[2];\n\t\t__le32 bssid_l[2];\n\t\t__le32 bssid_h[2];\n\t} __packed req = {\n\t\t.band_idx = phy->mt76->band_idx,\n\t\t.tag = cpu_to_le16(UNI_CMD_SR_SET_SRG_BITMAP),\n\t\t.len = cpu_to_le16(sizeof(req) - 4),\n\t};\n\tu32 bitmap;\n\n\tmemcpy(&bitmap, he_obss_pd->bss_color_bitmap, sizeof(bitmap));\n\treq.color_l[req.band_idx] = cpu_to_le32(bitmap);\n\n\tmemcpy(&bitmap, he_obss_pd->bss_color_bitmap + 4, sizeof(bitmap));\n\treq.color_h[req.band_idx] = cpu_to_le32(bitmap);\n\n\tmemcpy(&bitmap, he_obss_pd->partial_bssid_bitmap, sizeof(bitmap));\n\treq.bssid_l[req.band_idx] = cpu_to_le32(bitmap);\n\n\tmemcpy(&bitmap, he_obss_pd->partial_bssid_bitmap + 4, sizeof(bitmap));\n\treq.bssid_h[req.band_idx] = cpu_to_le32(bitmap);\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(SR), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nint mt7996_mcu_add_obss_spr(struct mt7996_phy *phy, struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_he_obss_pd *he_obss_pd)\n{\n\tint ret;\n\n\t \n\tret = mt7996_mcu_enable_obss_spr(phy, UNI_CMD_SR_ENABLE_SD,\n\t\t\t\t\t sr_scene_detect);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (sr_scene_detect && !he_obss_pd->enable)\n\t\treturn 0;\n\n\t \n\tret = mt7996_mcu_enable_obss_spr(phy, UNI_CMD_SR_ENABLE,\n\t\t\t\t\t he_obss_pd->enable);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sr_scene_detect || !he_obss_pd->enable)\n\t\treturn 0;\n\n\tret = mt7996_mcu_enable_obss_spr(phy, UNI_CMD_SR_ENABLE_TX, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mt7996_mcu_set_obss_spr_pd(phy, he_obss_pd);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mt7996_mcu_set_obss_spr_siga(phy, vif, he_obss_pd);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn mt7996_mcu_set_obss_spr_bitmap(phy, he_obss_pd);\n}\n\nint mt7996_mcu_update_bss_color(struct mt7996_dev *dev, struct ieee80211_vif *vif,\n\t\t\t\tstruct cfg80211_he_bss_color *he_bss_color)\n{\n\tint len = sizeof(struct bss_req_hdr) + sizeof(struct bss_color_tlv);\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tstruct bss_color_tlv *bss_color;\n\tstruct sk_buff *skb;\n\tstruct tlv *tlv;\n\n\tskb = __mt7996_mcu_alloc_bss_req(&dev->mt76, &mvif->mt76, len);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, UNI_BSS_INFO_BSS_COLOR,\n\t\t\t\t      sizeof(*bss_color));\n\tbss_color = (struct bss_color_tlv *)tlv;\n\tbss_color->enable = he_bss_color->enabled;\n\tbss_color->color = he_bss_color->color;\n\n\treturn mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t     MCU_WMWA_UNI_CMD(BSS_INFO_UPDATE), true);\n}\n\n#define TWT_AGRT_TRIGGER\tBIT(0)\n#define TWT_AGRT_ANNOUNCE\tBIT(1)\n#define TWT_AGRT_PROTECT\tBIT(2)\n\nint mt7996_mcu_twt_agrt_update(struct mt7996_dev *dev,\n\t\t\t       struct mt7996_vif *mvif,\n\t\t\t       struct mt7996_twt_flow *flow,\n\t\t\t       int cmd)\n{\n\tstruct {\n\t\t \n\t\tu8 bss;\n\t\tu8 _rsv[3];\n\n\t\t__le16 tag;\n\t\t__le16 len;\n\t\tu8 tbl_idx;\n\t\tu8 cmd;\n\t\tu8 own_mac_idx;\n\t\tu8 flowid;  \n\t\t__le16 peer_id;  \n\t\tu8 duration;  \n\t\tu8 bss_idx;\n\t\t__le64 start_tsf;\n\t\t__le16 mantissa;\n\t\tu8 exponent;\n\t\tu8 is_ap;\n\t\tu8 agrt_params;\n\t\tu8 __rsv2[23];\n\t} __packed req = {\n\t\t.tag = cpu_to_le16(UNI_CMD_TWT_ARGT_UPDATE),\n\t\t.len = cpu_to_le16(sizeof(req) - 4),\n\t\t.tbl_idx = flow->table_id,\n\t\t.cmd = cmd,\n\t\t.own_mac_idx = mvif->mt76.omac_idx,\n\t\t.flowid = flow->id,\n\t\t.peer_id = cpu_to_le16(flow->wcid),\n\t\t.duration = flow->duration,\n\t\t.bss = mvif->mt76.idx,\n\t\t.bss_idx = mvif->mt76.idx,\n\t\t.start_tsf = cpu_to_le64(flow->tsf),\n\t\t.mantissa = flow->mantissa,\n\t\t.exponent = flow->exp,\n\t\t.is_ap = true,\n\t};\n\n\tif (flow->protection)\n\t\treq.agrt_params |= TWT_AGRT_PROTECT;\n\tif (!flow->flowtype)\n\t\treq.agrt_params |= TWT_AGRT_ANNOUNCE;\n\tif (flow->trigger)\n\t\treq.agrt_params |= TWT_AGRT_TRIGGER;\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TWT),\n\t\t\t\t &req, sizeof(req), true);\n}\n\nint mt7996_mcu_set_rts_thresh(struct mt7996_phy *phy, u32 val)\n{\n\tstruct {\n\t\tu8 band_idx;\n\t\tu8 _rsv[3];\n\n\t\t__le16 tag;\n\t\t__le16 len;\n\t\t__le32 len_thresh;\n\t\t__le32 pkt_thresh;\n\t} __packed req = {\n\t\t.band_idx = phy->mt76->band_idx,\n\t\t.tag = cpu_to_le16(UNI_BAND_CONFIG_RTS_THRESHOLD),\n\t\t.len = cpu_to_le16(sizeof(req) - 4),\n\t\t.len_thresh = cpu_to_le32(val),\n\t\t.pkt_thresh = cpu_to_le32(0x2),\n\t};\n\n\treturn mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(BAND_CONFIG),\n\t\t\t\t &req, sizeof(req), true);\n}\n\nint mt7996_mcu_set_radio_en(struct mt7996_phy *phy, bool enable)\n{\n\tstruct {\n\t\tu8 band_idx;\n\t\tu8 _rsv[3];\n\n\t\t__le16 tag;\n\t\t__le16 len;\n\t\tu8 enable;\n\t\tu8 _rsv2[3];\n\t} __packed req = {\n\t\t.band_idx = phy->mt76->band_idx,\n\t\t.tag = cpu_to_le16(UNI_BAND_CONFIG_RADIO_ENABLE),\n\t\t.len = cpu_to_le16(sizeof(req) - 4),\n\t\t.enable = enable,\n\t};\n\n\treturn mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(BAND_CONFIG),\n\t\t\t\t &req, sizeof(req), true);\n}\n\nint mt7996_mcu_rdd_cmd(struct mt7996_dev *dev, int cmd, u8 index,\n\t\t       u8 rx_sel, u8 val)\n{\n\tstruct {\n\t\tu8 _rsv[4];\n\n\t\t__le16 tag;\n\t\t__le16 len;\n\n\t\tu8 ctrl;\n\t\tu8 rdd_idx;\n\t\tu8 rdd_rx_sel;\n\t\tu8 val;\n\t\tu8 rsv[4];\n\t} __packed req = {\n\t\t.tag = cpu_to_le16(UNI_RDD_CTRL_PARM),\n\t\t.len = cpu_to_le16(sizeof(req) - 4),\n\t\t.ctrl = cmd,\n\t\t.rdd_idx = index,\n\t\t.rdd_rx_sel = rx_sel,\n\t\t.val = val,\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(RDD_CTRL),\n\t\t\t\t &req, sizeof(req), true);\n}\n\nint mt7996_mcu_wtbl_update_hdr_trans(struct mt7996_dev *dev,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_sta *sta)\n{\n\tstruct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;\n\tstruct mt7996_sta *msta;\n\tstruct sk_buff *skb;\n\n\tmsta = sta ? (struct mt7996_sta *)sta->drv_priv : &mvif->sta;\n\n\tskb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->mt76,\n\t\t\t\t\t      &msta->wcid,\n\t\t\t\t\t      MT7996_STA_UPDATE_MAX_SIZE);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\t \n\tmt7996_mcu_sta_hdr_trans_tlv(dev, skb, vif, sta);\n\treturn mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t     MCU_WMWA_UNI_CMD(STA_REC_UPDATE), true);\n}\n\nint mt7996_mcu_rf_regval(struct mt7996_dev *dev, u32 regidx, u32 *val, bool set)\n{\n\tstruct {\n\t\tu8 __rsv1[4];\n\n\t\t__le16 tag;\n\t\t__le16 len;\n\t\t__le16 idx;\n\t\tu8 __rsv2[2];\n\t\t__le32 ofs;\n\t\t__le32 data;\n\t} __packed *res, req = {\n\t\t.tag = cpu_to_le16(UNI_CMD_ACCESS_RF_REG_BASIC),\n\t\t.len = cpu_to_le16(sizeof(req) - 4),\n\n\t\t.idx = cpu_to_le16(u32_get_bits(regidx, GENMASK(31, 24))),\n\t\t.ofs = cpu_to_le32(u32_get_bits(regidx, GENMASK(23, 0))),\n\t\t.data = set ? cpu_to_le32(*val) : 0,\n\t};\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tif (set)\n\t\treturn mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(REG_ACCESS),\n\t\t\t\t\t &req, sizeof(req), true);\n\n\tret = mt76_mcu_send_and_get_msg(&dev->mt76,\n\t\t\t\t\tMCU_WM_UNI_CMD_QUERY(REG_ACCESS),\n\t\t\t\t\t&req, sizeof(req), true, &skb);\n\tif (ret)\n\t\treturn ret;\n\n\tres = (void *)skb->data;\n\t*val = le32_to_cpu(res->data);\n\tdev_kfree_skb(skb);\n\n\treturn 0;\n}\n\nint mt7996_mcu_trigger_assert(struct mt7996_dev *dev)\n{\n\tstruct {\n\t\t__le16 tag;\n\t\t__le16 len;\n\t\tu8 enable;\n\t\tu8 rsv[3];\n\t} __packed req = {\n\t\t.len = cpu_to_le16(sizeof(req) - 4),\n\t\t.enable = true,\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(ASSERT_DUMP),\n\t\t\t\t &req, sizeof(req), false);\n}\n\nint mt7996_mcu_set_rro(struct mt7996_dev *dev, u16 tag, u8 val)\n{\n\tstruct {\n\t\tu8 __rsv1[4];\n\n\t\t__le16 tag;\n\t\t__le16 len;\n\n\t\tunion {\n\t\t\tstruct {\n\t\t\t\tu8 type;\n\t\t\t\tu8 __rsv2[3];\n\t\t\t} __packed platform_type;\n\t\t\tstruct {\n\t\t\t\tu8 type;\n\t\t\t\tu8 dest;\n\t\t\t\tu8 __rsv2[2];\n\t\t\t} __packed bypass_mode;\n\t\t\tstruct {\n\t\t\t\tu8 path;\n\t\t\t\tu8 __rsv2[3];\n\t\t\t} __packed txfree_path;\n\t\t};\n\t} __packed req = {\n\t\t.tag = cpu_to_le16(tag),\n\t\t.len = cpu_to_le16(sizeof(req) - 4),\n\t};\n\n\tswitch (tag) {\n\tcase UNI_RRO_SET_PLATFORM_TYPE:\n\t\treq.platform_type.type = val;\n\t\tbreak;\n\tcase UNI_RRO_SET_BYPASS_MODE:\n\t\treq.bypass_mode.type = val;\n\t\tbreak;\n\tcase UNI_RRO_SET_TXFREE_PATH:\n\t\treq.txfree_path.path = val;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(RRO), &req,\n\t\t\t\t sizeof(req), true);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}