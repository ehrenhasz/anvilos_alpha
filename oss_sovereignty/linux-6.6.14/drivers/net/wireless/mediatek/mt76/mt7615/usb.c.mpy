{
  "module_name": "usb.c",
  "hash_id": "82cebeca377277d4ac616b8afc7cc8b7279838689d9ae12db3138bc20461e566",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7615/usb.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n\n#include \"mt7615.h\"\n#include \"mac.h\"\n#include \"mcu.h\"\n#include \"regs.h\"\n\nstatic const struct usb_device_id mt7615_device_table[] = {\n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x0e8d, 0x7663, 0xff, 0xff, 0xff) },\n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x043e, 0x310c, 0xff, 0xff, 0xff) },\n\t{ },\n};\n\nstatic u32 mt7663u_rr(struct mt76_dev *dev, u32 addr)\n{\n\tu32 ret;\n\n\tmutex_lock(&dev->usb.usb_ctrl_mtx);\n\tret = ___mt76u_rr(dev, MT_VEND_READ_EXT,\n\t\t\t  USB_DIR_IN | USB_TYPE_VENDOR, addr);\n\tmutex_unlock(&dev->usb.usb_ctrl_mtx);\n\n\treturn ret;\n}\n\nstatic void mt7663u_wr(struct mt76_dev *dev, u32 addr, u32 val)\n{\n\tmutex_lock(&dev->usb.usb_ctrl_mtx);\n\t___mt76u_wr(dev, MT_VEND_WRITE_EXT,\n\t\t    USB_DIR_OUT | USB_TYPE_VENDOR, addr, val);\n\tmutex_unlock(&dev->usb.usb_ctrl_mtx);\n}\n\nstatic u32 mt7663u_rmw(struct mt76_dev *dev, u32 addr,\n\t\t       u32 mask, u32 val)\n{\n\tmutex_lock(&dev->usb.usb_ctrl_mtx);\n\tval |= ___mt76u_rr(dev, MT_VEND_READ_EXT,\n\t\t\t   USB_DIR_IN | USB_TYPE_VENDOR, addr) & ~mask;\n\t___mt76u_wr(dev, MT_VEND_WRITE_EXT,\n\t\t    USB_DIR_OUT | USB_TYPE_VENDOR, addr, val);\n\tmutex_unlock(&dev->usb.usb_ctrl_mtx);\n\n\treturn val;\n}\n\nstatic void mt7663u_copy(struct mt76_dev *dev, u32 offset,\n\t\t\t const void *data, int len)\n{\n\tstruct mt76_usb *usb = &dev->usb;\n\tint ret, i = 0, batch_len;\n\tconst u8 *val = data;\n\n\tlen = round_up(len, 4);\n\n\tmutex_lock(&usb->usb_ctrl_mtx);\n\twhile (i < len) {\n\t\tbatch_len = min_t(int, usb->data_len, len - i);\n\t\tmemcpy(usb->data, val + i, batch_len);\n\t\tret = __mt76u_vendor_request(dev, MT_VEND_WRITE_EXT,\n\t\t\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR,\n\t\t\t\t\t     (offset + i) >> 16, offset + i,\n\t\t\t\t\t     usb->data, batch_len);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\ti += batch_len;\n\t}\n\tmutex_unlock(&usb->usb_ctrl_mtx);\n}\n\nstatic void mt7663u_stop(struct ieee80211_hw *hw)\n{\n\tstruct mt7615_phy *phy = mt7615_hw_phy(hw);\n\tstruct mt7615_dev *dev = hw->priv;\n\n\tclear_bit(MT76_STATE_RUNNING, &dev->mphy.state);\n\tdel_timer_sync(&phy->roc_timer);\n\tcancel_work_sync(&phy->roc_work);\n\tcancel_delayed_work_sync(&phy->scan_work);\n\tcancel_delayed_work_sync(&phy->mt76->mac_work);\n\tmt76u_stop_tx(&dev->mt76);\n}\n\nstatic void mt7663u_cleanup(struct mt7615_dev *dev)\n{\n\tclear_bit(MT76_STATE_INITIALIZED, &dev->mphy.state);\n\tmt76u_queues_deinit(&dev->mt76);\n}\n\nstatic void mt7663u_init_work(struct work_struct *work)\n{\n\tstruct mt7615_dev *dev;\n\n\tdev = container_of(work, struct mt7615_dev, mcu_work);\n\tif (mt7663u_mcu_init(dev))\n\t\treturn;\n\n\tmt7615_init_work(dev);\n}\n\nstatic int mt7663u_probe(struct usb_interface *usb_intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstatic const struct mt76_driver_ops drv_ops = {\n\t\t.txwi_size = MT_USB_TXD_SIZE,\n\t\t.drv_flags = MT_DRV_RX_DMA_HDR | MT_DRV_HW_MGMT_TXQ,\n\t\t.tx_prepare_skb = mt7663_usb_sdio_tx_prepare_skb,\n\t\t.tx_complete_skb = mt7663_usb_sdio_tx_complete_skb,\n\t\t.tx_status_data = mt7663_usb_sdio_tx_status_data,\n\t\t.rx_skb = mt7615_queue_rx_skb,\n\t\t.rx_check = mt7615_rx_check,\n\t\t.sta_add = mt7615_mac_sta_add,\n\t\t.sta_remove = mt7615_mac_sta_remove,\n\t\t.update_survey = mt7615_update_channel,\n\t};\n\tstatic struct mt76_bus_ops bus_ops = {\n\t\t.rr = mt7663u_rr,\n\t\t.wr = mt7663u_wr,\n\t\t.rmw = mt7663u_rmw,\n\t\t.read_copy = mt76u_read_copy,\n\t\t.write_copy = mt7663u_copy,\n\t\t.type = MT76_BUS_USB,\n\t};\n\tstruct usb_device *udev = interface_to_usbdev(usb_intf);\n\tstruct ieee80211_ops *ops;\n\tstruct mt7615_dev *dev;\n\tstruct mt76_dev *mdev;\n\tint ret;\n\n\tops = devm_kmemdup(&usb_intf->dev, &mt7615_ops, sizeof(mt7615_ops),\n\t\t\t   GFP_KERNEL);\n\tif (!ops)\n\t\treturn -ENOMEM;\n\n\tops->stop = mt7663u_stop;\n\n\tmdev = mt76_alloc_device(&usb_intf->dev, sizeof(*dev), ops, &drv_ops);\n\tif (!mdev)\n\t\treturn -ENOMEM;\n\n\tdev = container_of(mdev, struct mt7615_dev, mt76);\n\tudev = usb_get_dev(udev);\n\tusb_reset_device(udev);\n\n\tusb_set_intfdata(usb_intf, dev);\n\n\tINIT_WORK(&dev->mcu_work, mt7663u_init_work);\n\tdev->reg_map = mt7663_usb_sdio_reg_map;\n\tdev->ops = ops;\n\tret = __mt76u_init(mdev, usb_intf, &bus_ops);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tmdev->rev = (mt76_rr(dev, MT_HW_CHIPID) << 16) |\n\t\t    (mt76_rr(dev, MT_HW_REV) & 0xff);\n\tdev_dbg(mdev->dev, \"ASIC revision: %04x\\n\", mdev->rev);\n\n\tif (!mt76_poll_msec(dev, MT_CONN_ON_MISC, MT_TOP_MISC2_FW_PWR_ON,\n\t\t\t    FW_STATE_PWR_ON << 1, 500)) {\n\t\tret = mt7663u_mcu_power_on(dev);\n\t\tif (ret)\n\t\t\tgoto error;\n\t} else {\n\t\tset_bit(MT76_STATE_POWER_OFF, &dev->mphy.state);\n\t}\n\n\tret = mt76u_alloc_mcu_queue(&dev->mt76);\n\tif (ret)\n\t\tgoto error;\n\n\tret = mt76u_alloc_queues(&dev->mt76);\n\tif (ret)\n\t\tgoto error;\n\n\tret = mt7663_usb_sdio_register_device(dev);\n\tif (ret)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tmt76u_queues_deinit(&dev->mt76);\n\tusb_set_intfdata(usb_intf, NULL);\n\tusb_put_dev(interface_to_usbdev(usb_intf));\n\n\tmt76_free_device(&dev->mt76);\n\n\treturn ret;\n}\n\nstatic void mt7663u_disconnect(struct usb_interface *usb_intf)\n{\n\tstruct mt7615_dev *dev = usb_get_intfdata(usb_intf);\n\n\tif (!test_bit(MT76_STATE_INITIALIZED, &dev->mphy.state))\n\t\treturn;\n\n\tieee80211_unregister_hw(dev->mt76.hw);\n\tmt7663u_cleanup(dev);\n\n\tusb_set_intfdata(usb_intf, NULL);\n\tusb_put_dev(interface_to_usbdev(usb_intf));\n\n\tmt76_free_device(&dev->mt76);\n}\n\n#ifdef CONFIG_PM\nstatic int mt7663u_suspend(struct usb_interface *intf, pm_message_t state)\n{\n\tstruct mt7615_dev *dev = usb_get_intfdata(intf);\n\n\tif (!test_bit(MT76_STATE_SUSPEND, &dev->mphy.state) &&\n\t    mt7615_firmware_offload(dev)) {\n\t\tint err;\n\n\t\terr = mt76_connac_mcu_set_hif_suspend(&dev->mt76, true);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tmt76u_stop_rx(&dev->mt76);\n\tmt76u_stop_tx(&dev->mt76);\n\n\treturn 0;\n}\n\nstatic int mt7663u_resume(struct usb_interface *intf)\n{\n\tstruct mt7615_dev *dev = usb_get_intfdata(intf);\n\tint err;\n\n\terr = mt76u_vendor_request(&dev->mt76, MT_VEND_FEATURE_SET,\n\t\t\t\t   USB_DIR_OUT | USB_TYPE_VENDOR,\n\t\t\t\t   0x5, 0x0, NULL, 0);\n\tif (err)\n\t\treturn err;\n\n\terr = mt76u_resume_rx(&dev->mt76);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!test_bit(MT76_STATE_SUSPEND, &dev->mphy.state) &&\n\t    mt7615_firmware_offload(dev))\n\t\terr = mt76_connac_mcu_set_hif_suspend(&dev->mt76, false);\n\n\treturn err;\n}\n#endif  \n\nMODULE_DEVICE_TABLE(usb, mt7615_device_table);\nMODULE_FIRMWARE(MT7663_OFFLOAD_FIRMWARE_N9);\nMODULE_FIRMWARE(MT7663_OFFLOAD_ROM_PATCH);\nMODULE_FIRMWARE(MT7663_FIRMWARE_N9);\nMODULE_FIRMWARE(MT7663_ROM_PATCH);\n\nstatic struct usb_driver mt7663u_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= mt7615_device_table,\n\t.probe\t\t= mt7663u_probe,\n\t.disconnect\t= mt7663u_disconnect,\n#ifdef CONFIG_PM\n\t.suspend\t= mt7663u_suspend,\n\t.resume\t\t= mt7663u_resume,\n\t.reset_resume\t= mt7663u_resume,\n#endif  \n\t.soft_unbind\t= 1,\n\t.disable_hub_initiated_lpm = 1,\n};\nmodule_usb_driver(mt7663u_driver);\n\nMODULE_AUTHOR(\"Sean Wang <sean.wang@mediatek.com>\");\nMODULE_AUTHOR(\"Lorenzo Bianconi <lorenzo@kernel.org>\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}