{
  "module_name": "sdio.c",
  "hash_id": "f15e6e532cb978d970ceab9f89a9bce75d73459a262573d4360eab9e440db87a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7615/sdio.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n\n#include <linux/mmc/host.h>\n#include <linux/mmc/sdio_ids.h>\n#include <linux/mmc/sdio_func.h>\n\n#include \"../sdio.h\"\n#include \"mt7615.h\"\n#include \"mac.h\"\n#include \"mcu.h\"\n\nstatic const struct sdio_device_id mt7663s_table[] = {\n\t{ SDIO_DEVICE(SDIO_VENDOR_ID_MEDIATEK, 0x7603) },\n\t{ }\t \n};\n\nstatic void mt7663s_txrx_worker(struct mt76_worker *w)\n{\n\tstruct mt76_sdio *sdio = container_of(w, struct mt76_sdio,\n\t\t\t\t\t      txrx_worker);\n\tstruct mt76_dev *mdev = container_of(sdio, struct mt76_dev, sdio);\n\tstruct mt7615_dev *dev = container_of(mdev, struct mt7615_dev, mt76);\n\n\tif (!mt76_connac_pm_ref(&dev->mphy, &dev->pm)) {\n\t\tqueue_work(mdev->wq, &dev->pm.wake_work);\n\t\treturn;\n\t}\n\tmt76s_txrx_worker(sdio);\n\tmt76_connac_pm_unref(&dev->mphy, &dev->pm);\n}\n\nstatic void mt7663s_init_work(struct work_struct *work)\n{\n\tstruct mt7615_dev *dev;\n\n\tdev = container_of(work, struct mt7615_dev, mcu_work);\n\tif (mt7663s_mcu_init(dev))\n\t\treturn;\n\n\tmt7615_init_work(dev);\n}\n\nstatic int mt7663s_parse_intr(struct mt76_dev *dev, struct mt76s_intr *intr)\n{\n\tstruct mt76_sdio *sdio = &dev->sdio;\n\tstruct mt7663s_intr *irq_data = sdio->intr_data;\n\tint i, err;\n\n\tsdio_claim_host(sdio->func);\n\terr = sdio_readsb(sdio->func, irq_data, MCR_WHISR, sizeof(*irq_data));\n\tsdio_release_host(sdio->func);\n\n\tif (err)\n\t\treturn err;\n\n\tintr->isr = irq_data->isr;\n\tintr->rec_mb = irq_data->rec_mb;\n\tintr->tx.wtqcr = irq_data->tx.wtqcr;\n\tintr->rx.num = irq_data->rx.num;\n\tfor (i = 0; i < 2 ; i++)\n\t\tintr->rx.len[i] = irq_data->rx.len[i];\n\n\treturn 0;\n}\n\nstatic int mt7663s_probe(struct sdio_func *func,\n\t\t\t const struct sdio_device_id *id)\n{\n\tstatic const struct mt76_driver_ops drv_ops = {\n\t\t.txwi_size = MT_USB_TXD_SIZE,\n\t\t.drv_flags = MT_DRV_RX_DMA_HDR,\n\t\t.tx_prepare_skb = mt7663_usb_sdio_tx_prepare_skb,\n\t\t.tx_complete_skb = mt7663_usb_sdio_tx_complete_skb,\n\t\t.tx_status_data = mt7663_usb_sdio_tx_status_data,\n\t\t.rx_skb = mt7615_queue_rx_skb,\n\t\t.rx_check = mt7615_rx_check,\n\t\t.sta_add = mt7615_mac_sta_add,\n\t\t.sta_remove = mt7615_mac_sta_remove,\n\t\t.update_survey = mt7615_update_channel,\n\t};\n\tstatic const struct mt76_bus_ops mt7663s_ops = {\n\t\t.rr = mt76s_rr,\n\t\t.rmw = mt76s_rmw,\n\t\t.wr = mt76s_wr,\n\t\t.write_copy = mt76s_write_copy,\n\t\t.read_copy = mt76s_read_copy,\n\t\t.wr_rp = mt76s_wr_rp,\n\t\t.rd_rp = mt76s_rd_rp,\n\t\t.type = MT76_BUS_SDIO,\n\t};\n\tstruct ieee80211_ops *ops;\n\tstruct mt7615_dev *dev;\n\tstruct mt76_dev *mdev;\n\tint ret;\n\n\tops = devm_kmemdup(&func->dev, &mt7615_ops, sizeof(mt7615_ops),\n\t\t\t   GFP_KERNEL);\n\tif (!ops)\n\t\treturn -ENOMEM;\n\n\tmdev = mt76_alloc_device(&func->dev, sizeof(*dev), ops, &drv_ops);\n\tif (!mdev)\n\t\treturn -ENOMEM;\n\n\tdev = container_of(mdev, struct mt7615_dev, mt76);\n\n\tINIT_WORK(&dev->mcu_work, mt7663s_init_work);\n\tdev->reg_map = mt7663_usb_sdio_reg_map;\n\tdev->ops = ops;\n\tsdio_set_drvdata(func, dev);\n\n\tret = mt76s_init(mdev, func, &mt7663s_ops);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = mt76s_hw_init(mdev, func, MT76_CONNAC_SDIO);\n\tif (ret)\n\t\tgoto error;\n\n\tmdev->rev = (mt76_rr(dev, MT_HW_CHIPID) << 16) |\n\t\t    (mt76_rr(dev, MT_HW_REV) & 0xff);\n\tdev_dbg(mdev->dev, \"ASIC revision: %04x\\n\", mdev->rev);\n\n\tmdev->sdio.parse_irq = mt7663s_parse_intr;\n\tmdev->sdio.intr_data = devm_kmalloc(mdev->dev,\n\t\t\t\t\t    sizeof(struct mt7663s_intr),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!mdev->sdio.intr_data) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tret = mt76s_alloc_rx_queue(mdev, MT_RXQ_MAIN);\n\tif (ret)\n\t\tgoto error;\n\n\tret = mt76s_alloc_tx(mdev);\n\tif (ret)\n\t\tgoto error;\n\n\tret = mt76_worker_setup(mt76_hw(dev), &mdev->sdio.txrx_worker,\n\t\t\t\tmt7663s_txrx_worker, \"sdio-txrx\");\n\tif (ret)\n\t\tgoto error;\n\n\tsched_set_fifo_low(mdev->sdio.txrx_worker.task);\n\n\tret = mt7663_usb_sdio_register_device(dev);\n\tif (ret)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tmt76s_deinit(&dev->mt76);\n\tmt76_free_device(&dev->mt76);\n\n\treturn ret;\n}\n\nstatic void mt7663s_remove(struct sdio_func *func)\n{\n\tstruct mt7615_dev *dev = sdio_get_drvdata(func);\n\n\tif (!test_and_clear_bit(MT76_STATE_INITIALIZED, &dev->mphy.state))\n\t\treturn;\n\n\tieee80211_unregister_hw(dev->mt76.hw);\n\tmt76s_deinit(&dev->mt76);\n\tmt76_free_device(&dev->mt76);\n}\n\nstatic int mt7663s_suspend(struct device *dev)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(dev);\n\tstruct mt7615_dev *mdev = sdio_get_drvdata(func);\n\tint err;\n\n\tif (!test_bit(MT76_STATE_SUSPEND, &mdev->mphy.state) &&\n\t    mt7615_firmware_offload(mdev)) {\n\t\tint err;\n\n\t\terr = mt76_connac_mcu_set_hif_suspend(&mdev->mt76, true);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tsdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);\n\n\terr = mt7615_mcu_set_fw_ctrl(mdev);\n\tif (err)\n\t\treturn err;\n\n\tmt76_worker_disable(&mdev->mt76.sdio.txrx_worker);\n\tmt76_worker_disable(&mdev->mt76.sdio.status_worker);\n\tmt76_worker_disable(&mdev->mt76.sdio.net_worker);\n\tmt76_worker_disable(&mdev->mt76.sdio.stat_worker);\n\n\tclear_bit(MT76_READING_STATS, &mdev->mphy.state);\n\n\tmt76_tx_status_check(&mdev->mt76, true);\n\n\treturn 0;\n}\n\nstatic int mt7663s_resume(struct device *dev)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(dev);\n\tstruct mt7615_dev *mdev = sdio_get_drvdata(func);\n\tint err;\n\n\tmt76_worker_enable(&mdev->mt76.sdio.txrx_worker);\n\tmt76_worker_enable(&mdev->mt76.sdio.status_worker);\n\tmt76_worker_enable(&mdev->mt76.sdio.net_worker);\n\n\terr = mt7615_mcu_set_drv_ctrl(mdev);\n\tif (err)\n\t\treturn err;\n\n\tif (!test_bit(MT76_STATE_SUSPEND, &mdev->mphy.state) &&\n\t    mt7615_firmware_offload(mdev))\n\t\terr = mt76_connac_mcu_set_hif_suspend(&mdev->mt76, false);\n\n\treturn err;\n}\n\nMODULE_DEVICE_TABLE(sdio, mt7663s_table);\nMODULE_FIRMWARE(MT7663_OFFLOAD_FIRMWARE_N9);\nMODULE_FIRMWARE(MT7663_OFFLOAD_ROM_PATCH);\nMODULE_FIRMWARE(MT7663_FIRMWARE_N9);\nMODULE_FIRMWARE(MT7663_ROM_PATCH);\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(mt7663s_pm_ops, mt7663s_suspend, mt7663s_resume);\n\nstatic struct sdio_driver mt7663s_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.probe\t\t= mt7663s_probe,\n\t.remove\t\t= mt7663s_remove,\n\t.id_table\t= mt7663s_table,\n\t.drv.pm\t\t= pm_sleep_ptr(&mt7663s_pm_ops),\n};\nmodule_sdio_driver(mt7663s_driver);\n\nMODULE_AUTHOR(\"Sean Wang <sean.wang@mediatek.com>\");\nMODULE_AUTHOR(\"Lorenzo Bianconi <lorenzo@kernel.org>\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}