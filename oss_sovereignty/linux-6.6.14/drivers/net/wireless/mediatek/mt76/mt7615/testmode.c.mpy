{
  "module_name": "testmode.c",
  "hash_id": "2203f177cdd99a995dc2d85d679c2563358840e6d28ea08dc034f171f26df7f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7615/testmode.c",
  "human_readable_source": "\n \n\n#include \"mt7615.h\"\n#include \"eeprom.h\"\n#include \"mcu.h\"\n\nenum {\n\tTM_CHANGED_TXPOWER_CTRL,\n\tTM_CHANGED_TXPOWER,\n\tTM_CHANGED_FREQ_OFFSET,\n\n\t \n\tNUM_TM_CHANGED\n};\n\n\nstatic const u8 tm_change_map[] = {\n\t[TM_CHANGED_TXPOWER_CTRL] = MT76_TM_ATTR_TX_POWER_CONTROL,\n\t[TM_CHANGED_TXPOWER] = MT76_TM_ATTR_TX_POWER,\n\t[TM_CHANGED_FREQ_OFFSET] = MT76_TM_ATTR_FREQ_OFFSET,\n};\n\nstatic const u32 reg_backup_list[] = {\n\tMT_WF_PHY_RFINTF3_0(0),\n\tMT_WF_PHY_RFINTF3_0(1),\n\tMT_WF_PHY_RFINTF3_0(2),\n\tMT_WF_PHY_RFINTF3_0(3),\n\tMT_ANT_SWITCH_CON(2),\n\tMT_ANT_SWITCH_CON(3),\n\tMT_ANT_SWITCH_CON(4),\n\tMT_ANT_SWITCH_CON(6),\n\tMT_ANT_SWITCH_CON(7),\n\tMT_ANT_SWITCH_CON(8),\n};\n\nstatic const struct {\n\tu16 wf;\n\tu16 reg;\n} rf_backup_list[] = {\n\t{ 0, 0x48 },\n\t{ 1, 0x48 },\n\t{ 2, 0x48 },\n\t{ 3, 0x48 },\n};\n\nstatic int\nmt7615_tm_set_tx_power(struct mt7615_phy *phy)\n{\n\tstruct mt7615_dev *dev = phy->dev;\n\tstruct mt76_phy *mphy = phy->mt76;\n\tint i, ret, n_chains = hweight8(mphy->antenna_mask);\n\tstruct cfg80211_chan_def *chandef = &mphy->chandef;\n\tint freq = chandef->center_freq1, len, target_chains;\n\tu8 *data, *eep = (u8 *)dev->mt76.eeprom.data;\n\tenum nl80211_band band = chandef->chan->band;\n\tstruct sk_buff *skb;\n\tstruct {\n\t\tu8 center_chan;\n\t\tu8 dbdc_idx;\n\t\tu8 band;\n\t\tu8 rsv;\n\t} __packed req_hdr = {\n\t\t.center_chan = ieee80211_frequency_to_channel(freq),\n\t\t.band = band,\n\t\t.dbdc_idx = phy != &dev->phy,\n\t};\n\tu8 *tx_power = NULL;\n\n\tif (mphy->test.state != MT76_TM_STATE_OFF)\n\t\ttx_power = mphy->test.tx_power;\n\n\tlen = MT7615_EE_MAX - MT_EE_NIC_CONF_0;\n\tskb = mt76_mcu_msg_alloc(&dev->mt76, NULL, sizeof(req_hdr) + len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_data(skb, &req_hdr, sizeof(req_hdr));\n\tdata = skb_put_data(skb, eep + MT_EE_NIC_CONF_0, len);\n\n\ttarget_chains = mt7615_ext_pa_enabled(dev, band) ? 1 : n_chains;\n\tfor (i = 0; i < target_chains; i++) {\n\t\tret = mt7615_eeprom_get_target_power_index(dev, chandef->chan, i);\n\t\tif (ret < 0) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (tx_power && tx_power[i])\n\t\t\tdata[ret - MT_EE_NIC_CONF_0] = tx_power[i];\n\t}\n\n\treturn mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t     MCU_EXT_CMD(SET_TX_POWER_CTRL), false);\n}\n\nstatic void\nmt7615_tm_reg_backup_restore(struct mt7615_phy *phy)\n{\n\tstruct mt7615_dev *dev = phy->dev;\n\tu32 *b = phy->test.reg_backup;\n\tint n_regs = ARRAY_SIZE(reg_backup_list);\n\tint n_rf_regs = ARRAY_SIZE(rf_backup_list);\n\tint i;\n\n\tif (phy->mt76->test.state == MT76_TM_STATE_OFF) {\n\t\tfor (i = 0; i < n_regs; i++)\n\t\t\tmt76_wr(dev, reg_backup_list[i], b[i]);\n\n\t\tfor (i = 0; i < n_rf_regs; i++)\n\t\t\tmt7615_rf_wr(dev, rf_backup_list[i].wf,\n\t\t\t\t     rf_backup_list[i].reg, b[n_regs + i]);\n\t\treturn;\n\t}\n\n\tif (b)\n\t\treturn;\n\n\tb = devm_kzalloc(dev->mt76.dev, 4 * (n_regs + n_rf_regs),\n\t\t\t GFP_KERNEL);\n\tif (!b)\n\t\treturn;\n\n\tphy->test.reg_backup = b;\n\tfor (i = 0; i < n_regs; i++)\n\t\tb[i] = mt76_rr(dev, reg_backup_list[i]);\n\tfor (i = 0; i < n_rf_regs; i++)\n\t\tb[n_regs + i] = mt7615_rf_rr(dev, rf_backup_list[i].wf,\n\t\t\t\t\t     rf_backup_list[i].reg);\n}\n\nstatic void\nmt7615_tm_init(struct mt7615_phy *phy)\n{\n\tstruct mt7615_dev *dev = phy->dev;\n\tunsigned int total_flags = ~0;\n\n\tif (!test_bit(MT76_STATE_RUNNING, &phy->mt76->state))\n\t\treturn;\n\n\tmt7615_mcu_set_sku_en(phy, phy->mt76->test.state == MT76_TM_STATE_OFF);\n\n\tmutex_unlock(&dev->mt76.mutex);\n\tmt7615_set_channel(phy);\n\tmt7615_ops.configure_filter(phy->mt76->hw, 0, &total_flags, 0);\n\tmutex_lock(&dev->mt76.mutex);\n\n\tmt7615_tm_reg_backup_restore(phy);\n}\n\nstatic void\nmt7615_tm_set_rx_enable(struct mt7615_dev *dev, bool en)\n{\n\tu32 rqcr_mask = (MT_ARB_RQCR_RX_START |\n\t\t\t MT_ARB_RQCR_RXV_START |\n\t\t\t MT_ARB_RQCR_RXV_R_EN |\n\t\t\t MT_ARB_RQCR_RXV_T_EN) *\n\t\t\t(BIT(0) | BIT(MT_ARB_RQCR_BAND_SHIFT));\n\n\tif (en) {\n\t\tmt76_clear(dev, MT_ARB_SCR,\n\t\t\t   MT_ARB_SCR_RX0_DISABLE | MT_ARB_SCR_RX1_DISABLE);\n\t\tmt76_set(dev, MT_ARB_RQCR, rqcr_mask);\n\t} else {\n\t\tmt76_set(dev, MT_ARB_SCR,\n\t\t\t MT_ARB_SCR_RX0_DISABLE | MT_ARB_SCR_RX1_DISABLE);\n\t\tmt76_clear(dev, MT_ARB_RQCR, rqcr_mask);\n\t}\n}\n\nstatic void\nmt7615_tm_set_tx_antenna(struct mt7615_phy *phy, bool en)\n{\n\tstruct mt7615_dev *dev = phy->dev;\n\tstruct mt76_testmode_data *td = &phy->mt76->test;\n\tu8 mask = td->tx_antenna_mask;\n\tint i;\n\n\tif (!mask)\n\t\treturn;\n\n\tif (!en)\n\t\tmask = phy->mt76->chainmask;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tmt76_rmw_field(dev, MT_WF_PHY_RFINTF3_0(i),\n\t\t\t       MT_WF_PHY_RFINTF3_0_ANT,\n\t\t\t       (mask & BIT(i)) ? 0 : 0xa);\n\t}\n\n\t \n\tmt76_rmw_field(dev, MT_ANT_SWITCH_CON(3), MT_ANT_SWITCH_CON_MODE(0),\n\t\t       (mask & BIT(0)) ? 0x8 : 0x1b);\n\tmt76_rmw_field(dev, MT_ANT_SWITCH_CON(4), MT_ANT_SWITCH_CON_MODE(2),\n\t\t       (mask & BIT(1)) ? 0xe : 0x1b);\n\tmt76_rmw_field(dev, MT_ANT_SWITCH_CON(6), MT_ANT_SWITCH_CON_MODE1(0),\n\t\t       (mask & BIT(2)) ? 0x0 : 0xf);\n\tmt76_rmw_field(dev, MT_ANT_SWITCH_CON(7), MT_ANT_SWITCH_CON_MODE1(2),\n\t\t       (mask & BIT(3)) ? 0x6 : 0xf);\n\n\t \n\tmt76_rmw_field(dev, MT_ANT_SWITCH_CON(4), MT_ANT_SWITCH_CON_MODE(1),\n\t\t       (mask & BIT(0)) ? 0xd : 0x1b);\n\tmt76_rmw_field(dev, MT_ANT_SWITCH_CON(2), MT_ANT_SWITCH_CON_MODE(3),\n\t\t       (mask & BIT(1)) ? 0x13 : 0x1b);\n\tmt76_rmw_field(dev, MT_ANT_SWITCH_CON(7), MT_ANT_SWITCH_CON_MODE1(1),\n\t\t       (mask & BIT(2)) ? 0x5 : 0xf);\n\tmt76_rmw_field(dev, MT_ANT_SWITCH_CON(8), MT_ANT_SWITCH_CON_MODE1(3),\n\t\t       (mask & BIT(3)) ? 0xb : 0xf);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tu32 val;\n\n\t\tval = mt7615_rf_rr(dev, i, 0x48);\n\t\tval &= ~(0x3ff << 20);\n\t\tif (mask & BIT(i))\n\t\t\tval |= 3 << 20;\n\t\telse\n\t\t\tval |= (2 << 28) | (2 << 26) | (8 << 20);\n\t\tmt7615_rf_wr(dev, i, 0x48, val);\n\t}\n}\n\nstatic void\nmt7615_tm_set_tx_frames(struct mt7615_phy *phy, bool en)\n{\n\tstruct mt7615_dev *dev = phy->dev;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *skb = phy->mt76->test.tx_skb;\n\n\tmt7615_mcu_set_chan_info(phy, MCU_EXT_CMD(SET_RX_PATH));\n\tmt7615_tm_set_tx_antenna(phy, en);\n\tmt7615_tm_set_rx_enable(dev, !en);\n\tif (!en || !skb)\n\t\treturn;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tinfo->control.vif = phy->monitor_vif;\n}\n\nstatic void\nmt7615_tm_update_params(struct mt7615_phy *phy, u32 changed)\n{\n\tstruct mt7615_dev *dev = phy->dev;\n\tstruct mt76_testmode_data *td = &phy->mt76->test;\n\tbool en = phy->mt76->test.state != MT76_TM_STATE_OFF;\n\n\tif (changed & BIT(TM_CHANGED_TXPOWER_CTRL))\n\t\tmt7615_mcu_set_test_param(dev, MCU_ATE_SET_TX_POWER_CONTROL,\n\t\t\t\t\t  en, en && td->tx_power_control);\n\tif (changed & BIT(TM_CHANGED_FREQ_OFFSET))\n\t\tmt7615_mcu_set_test_param(dev, MCU_ATE_SET_FREQ_OFFSET,\n\t\t\t\t\t  en, en ? td->freq_offset : 0);\n\tif (changed & BIT(TM_CHANGED_TXPOWER))\n\t\tmt7615_tm_set_tx_power(phy);\n}\n\nstatic int\nmt7615_tm_set_state(struct mt76_phy *mphy, enum mt76_testmode_state state)\n{\n\tstruct mt7615_phy *phy = mphy->priv;\n\tstruct mt76_testmode_data *td = &mphy->test;\n\tenum mt76_testmode_state prev_state = td->state;\n\n\tmphy->test.state = state;\n\n\tif (prev_state == MT76_TM_STATE_TX_FRAMES)\n\t\tmt7615_tm_set_tx_frames(phy, false);\n\telse if (state == MT76_TM_STATE_TX_FRAMES)\n\t\tmt7615_tm_set_tx_frames(phy, true);\n\n\tif (state <= MT76_TM_STATE_IDLE)\n\t\tmt7615_tm_init(phy);\n\n\tif ((state == MT76_TM_STATE_IDLE &&\n\t     prev_state == MT76_TM_STATE_OFF) ||\n\t    (state == MT76_TM_STATE_OFF &&\n\t     prev_state == MT76_TM_STATE_IDLE)) {\n\t\tu32 changed = 0;\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(tm_change_map); i++) {\n\t\t\tu16 cur = tm_change_map[i];\n\n\t\t\tif (td->param_set[cur / 32] & BIT(cur % 32))\n\t\t\t\tchanged |= BIT(i);\n\t\t}\n\n\t\tmt7615_tm_update_params(phy, changed);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmt7615_tm_set_params(struct mt76_phy *mphy, struct nlattr **tb,\n\t\t     enum mt76_testmode_state new_state)\n{\n\tstruct mt76_testmode_data *td = &mphy->test;\n\tstruct mt7615_phy *phy = mphy->priv;\n\tu32 changed = 0;\n\tint i;\n\n\tBUILD_BUG_ON(NUM_TM_CHANGED >= 32);\n\n\tif (new_state == MT76_TM_STATE_OFF ||\n\t    td->state == MT76_TM_STATE_OFF)\n\t\treturn 0;\n\n\tif (td->tx_antenna_mask & ~mphy->chainmask)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(tm_change_map); i++) {\n\t\tif (tb[tm_change_map[i]])\n\t\t\tchanged |= BIT(i);\n\t}\n\n\tmt7615_tm_update_params(phy, changed);\n\n\treturn 0;\n}\n\nstatic int\nmt7615_tm_dump_stats(struct mt76_phy *mphy, struct sk_buff *msg)\n{\n\tstruct mt7615_phy *phy = mphy->priv;\n\tvoid *rx, *rssi;\n\tint i;\n\n\trx = nla_nest_start(msg, MT76_TM_STATS_ATTR_LAST_RX);\n\tif (!rx)\n\t\treturn -ENOMEM;\n\n\tif (nla_put_s32(msg, MT76_TM_RX_ATTR_FREQ_OFFSET, phy->test.last_freq_offset))\n\t\treturn -ENOMEM;\n\n\trssi = nla_nest_start(msg, MT76_TM_RX_ATTR_RCPI);\n\tif (!rssi)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(phy->test.last_rcpi); i++)\n\t\tif (nla_put_u8(msg, i, phy->test.last_rcpi[i]))\n\t\t\treturn -ENOMEM;\n\n\tnla_nest_end(msg, rssi);\n\n\trssi = nla_nest_start(msg, MT76_TM_RX_ATTR_IB_RSSI);\n\tif (!rssi)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(phy->test.last_ib_rssi); i++)\n\t\tif (nla_put_s8(msg, i, phy->test.last_ib_rssi[i]))\n\t\t\treturn -ENOMEM;\n\n\tnla_nest_end(msg, rssi);\n\n\trssi = nla_nest_start(msg, MT76_TM_RX_ATTR_WB_RSSI);\n\tif (!rssi)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(phy->test.last_wb_rssi); i++)\n\t\tif (nla_put_s8(msg, i, phy->test.last_wb_rssi[i]))\n\t\t\treturn -ENOMEM;\n\n\tnla_nest_end(msg, rssi);\n\n\tnla_nest_end(msg, rx);\n\n\treturn 0;\n}\n\nconst struct mt76_testmode_ops mt7615_testmode_ops = {\n\t.set_state = mt7615_tm_set_state,\n\t.set_params = mt7615_tm_set_params,\n\t.dump_stats = mt7615_tm_dump_stats,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}