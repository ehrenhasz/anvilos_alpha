{
  "module_name": "mcu.c",
  "hash_id": "505e72d53e24b8b1e6510971e530ad3af08d7c844d6ec62df7fecb9a56af7437",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7615/mcu.c",
  "human_readable_source": "\n \n\n#include <linux/firmware.h>\n#include \"mt7615.h\"\n#include \"mcu.h\"\n#include \"mac.h\"\n#include \"eeprom.h\"\n\nstatic bool prefer_offload_fw = true;\nmodule_param(prefer_offload_fw, bool, 0644);\nMODULE_PARM_DESC(prefer_offload_fw,\n\t\t \"Prefer client mode offload firmware (MT7663)\");\n\nstruct mt7615_patch_hdr {\n\tchar build_date[16];\n\tchar platform[4];\n\t__be32 hw_sw_ver;\n\t__be32 patch_ver;\n\t__be16 checksum;\n} __packed;\n\nstruct mt7615_fw_trailer {\n\t__le32 addr;\n\tu8 chip_id;\n\tu8 feature_set;\n\tu8 eco_code;\n\tchar fw_ver[10];\n\tchar build_date[15];\n\t__le32 len;\n} __packed;\n\n#define FW_V3_COMMON_TAILER_SIZE\t36\n#define FW_V3_REGION_TAILER_SIZE\t40\n#define FW_START_OVERRIDE\t\tBIT(0)\n#define FW_START_DLYCAL                 BIT(1)\n#define FW_START_WORKING_PDA_CR4\tBIT(2)\n\nstruct mt7663_fw_buf {\n\t__le32 crc;\n\t__le32 d_img_size;\n\t__le32 block_size;\n\tu8 rsv[4];\n\t__le32 img_dest_addr;\n\t__le32 img_size;\n\tu8 feature_set;\n};\n\n#define MT7615_PATCH_ADDRESS\t\t0x80000\n#define MT7622_PATCH_ADDRESS\t\t0x9c000\n#define MT7663_PATCH_ADDRESS\t\t0xdc000\n\n#define N9_REGION_NUM\t\t\t2\n#define CR4_REGION_NUM\t\t\t1\n\n#define IMG_CRC_LEN\t\t\t4\n\nvoid mt7615_mcu_fill_msg(struct mt7615_dev *dev, struct sk_buff *skb,\n\t\t\t int cmd, int *wait_seq)\n{\n\tint txd_len, mcu_cmd = FIELD_GET(__MCU_CMD_FIELD_ID, cmd);\n\tstruct mt7615_uni_txd *uni_txd;\n\tstruct mt7615_mcu_txd *mcu_txd;\n\tu8 seq, q_idx, pkt_fmt;\n\t__le32 *txd;\n\tu32 val;\n\n\t \n\tdev->mt76.mcu.timeout = 20 * HZ;\n\n\tseq = ++dev->mt76.mcu.msg_seq & 0xf;\n\tif (!seq)\n\t\tseq = ++dev->mt76.mcu.msg_seq & 0xf;\n\tif (wait_seq)\n\t\t*wait_seq = seq;\n\n\ttxd_len = cmd & __MCU_CMD_FIELD_UNI ? sizeof(*uni_txd) : sizeof(*mcu_txd);\n\ttxd = (__le32 *)skb_push(skb, txd_len);\n\n\tif (cmd != MCU_CMD(FW_SCATTER)) {\n\t\tq_idx = MT_TX_MCU_PORT_RX_Q0;\n\t\tpkt_fmt = MT_TX_TYPE_CMD;\n\t} else {\n\t\tq_idx = MT_TX_MCU_PORT_RX_FWDL;\n\t\tpkt_fmt = MT_TX_TYPE_FW;\n\t}\n\n\tval = FIELD_PREP(MT_TXD0_TX_BYTES, skb->len) |\n\t      FIELD_PREP(MT_TXD0_P_IDX, MT_TX_PORT_IDX_MCU) |\n\t      FIELD_PREP(MT_TXD0_Q_IDX, q_idx);\n\ttxd[0] = cpu_to_le32(val);\n\n\tval = MT_TXD1_LONG_FORMAT |\n\t      FIELD_PREP(MT_TXD1_HDR_FORMAT, MT_HDR_FORMAT_CMD) |\n\t      FIELD_PREP(MT_TXD1_PKT_FMT, pkt_fmt);\n\ttxd[1] = cpu_to_le32(val);\n\n\tif (cmd & __MCU_CMD_FIELD_UNI) {\n\t\tuni_txd = (struct mt7615_uni_txd *)txd;\n\t\tuni_txd->len = cpu_to_le16(skb->len - sizeof(uni_txd->txd));\n\t\tuni_txd->option = MCU_CMD_UNI_EXT_ACK;\n\t\tuni_txd->cid = cpu_to_le16(mcu_cmd);\n\t\tuni_txd->s2d_index = MCU_S2D_H2N;\n\t\tuni_txd->pkt_type = MCU_PKT_ID;\n\t\tuni_txd->seq = seq;\n\n\t\treturn;\n\t}\n\n\tmcu_txd = (struct mt7615_mcu_txd *)txd;\n\tmcu_txd->len = cpu_to_le16(skb->len - sizeof(mcu_txd->txd));\n\tmcu_txd->pq_id = cpu_to_le16(MCU_PQ_ID(MT_TX_PORT_IDX_MCU, q_idx));\n\tmcu_txd->s2d_index = MCU_S2D_H2N;\n\tmcu_txd->pkt_type = MCU_PKT_ID;\n\tmcu_txd->seq = seq;\n\tmcu_txd->cid = mcu_cmd;\n\tmcu_txd->ext_cid = FIELD_GET(__MCU_CMD_FIELD_EXT_ID, cmd);\n\n\tif (mcu_txd->ext_cid || (cmd & __MCU_CMD_FIELD_CE)) {\n\t\tif (cmd & __MCU_CMD_FIELD_QUERY)\n\t\t\tmcu_txd->set_query = MCU_Q_QUERY;\n\t\telse\n\t\t\tmcu_txd->set_query = MCU_Q_SET;\n\t\tmcu_txd->ext_cid_ack = !!mcu_txd->ext_cid;\n\t} else {\n\t\tmcu_txd->set_query = MCU_Q_NA;\n\t}\n}\nEXPORT_SYMBOL_GPL(mt7615_mcu_fill_msg);\n\nint mt7615_mcu_parse_response(struct mt76_dev *mdev, int cmd,\n\t\t\t      struct sk_buff *skb, int seq)\n{\n\tstruct mt7615_mcu_rxd *rxd;\n\tint ret = 0;\n\n\tif (!skb) {\n\t\tdev_err(mdev->dev, \"Message %08x (seq %d) timeout\\n\",\n\t\t\tcmd, seq);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\trxd = (struct mt7615_mcu_rxd *)skb->data;\n\tif (seq != rxd->seq)\n\t\treturn -EAGAIN;\n\n\tif (cmd == MCU_CMD(PATCH_SEM_CONTROL)) {\n\t\tskb_pull(skb, sizeof(*rxd) - 4);\n\t\tret = *skb->data;\n\t} else if (cmd == MCU_EXT_CMD(THERMAL_CTRL)) {\n\t\tskb_pull(skb, sizeof(*rxd));\n\t\tret = le32_to_cpu(*(__le32 *)skb->data);\n\t} else if (cmd == MCU_EXT_QUERY(RF_REG_ACCESS)) {\n\t\tskb_pull(skb, sizeof(*rxd));\n\t\tret = le32_to_cpu(*(__le32 *)&skb->data[8]);\n\t} else if (cmd == MCU_UNI_CMD(DEV_INFO_UPDATE) ||\n\t\t   cmd == MCU_UNI_CMD(BSS_INFO_UPDATE) ||\n\t\t   cmd == MCU_UNI_CMD(STA_REC_UPDATE) ||\n\t\t   cmd == MCU_UNI_CMD(HIF_CTRL) ||\n\t\t   cmd == MCU_UNI_CMD(OFFLOAD) ||\n\t\t   cmd == MCU_UNI_CMD(SUSPEND)) {\n\t\tstruct mt76_connac_mcu_uni_event *event;\n\n\t\tskb_pull(skb, sizeof(*rxd));\n\t\tevent = (struct mt76_connac_mcu_uni_event *)skb->data;\n\t\tret = le32_to_cpu(event->status);\n\t} else if (cmd == MCU_CE_QUERY(REG_READ)) {\n\t\tstruct mt76_connac_mcu_reg_event *event;\n\n\t\tskb_pull(skb, sizeof(*rxd));\n\t\tevent = (struct mt76_connac_mcu_reg_event *)skb->data;\n\t\tret = (int)le32_to_cpu(event->val);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mt7615_mcu_parse_response);\n\nstatic int\nmt7615_mcu_send_message(struct mt76_dev *mdev, struct sk_buff *skb,\n\t\t\tint cmd, int *seq)\n{\n\tstruct mt7615_dev *dev = container_of(mdev, struct mt7615_dev, mt76);\n\tenum mt76_mcuq_id qid;\n\n\tmt7615_mcu_fill_msg(dev, skb, cmd, seq);\n\tif (test_bit(MT76_STATE_MCU_RUNNING, &dev->mphy.state))\n\t\tqid = MT_MCUQ_WM;\n\telse\n\t\tqid = MT_MCUQ_FWDL;\n\n\treturn mt76_tx_queue_skb_raw(dev, dev->mt76.q_mcu[qid], skb, 0);\n}\n\nu32 mt7615_rf_rr(struct mt7615_dev *dev, u32 wf, u32 reg)\n{\n\tstruct {\n\t\t__le32 wifi_stream;\n\t\t__le32 address;\n\t\t__le32 data;\n\t} req = {\n\t\t.wifi_stream = cpu_to_le32(wf),\n\t\t.address = cpu_to_le32(reg),\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_QUERY(RF_REG_ACCESS),\n\t\t\t\t &req, sizeof(req), true);\n}\n\nint mt7615_rf_wr(struct mt7615_dev *dev, u32 wf, u32 reg, u32 val)\n{\n\tstruct {\n\t\t__le32 wifi_stream;\n\t\t__le32 address;\n\t\t__le32 data;\n\t} req = {\n\t\t.wifi_stream = cpu_to_le32(wf),\n\t\t.address = cpu_to_le32(reg),\n\t\t.data = cpu_to_le32(val),\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(RF_REG_ACCESS),\n\t\t\t\t &req, sizeof(req), false);\n}\n\nvoid mt7622_trigger_hif_int(struct mt7615_dev *dev, bool en)\n{\n\tif (!is_mt7622(&dev->mt76))\n\t\treturn;\n\n\tregmap_update_bits(dev->infracfg, MT_INFRACFG_MISC,\n\t\t\t   MT_INFRACFG_MISC_AP2CONN_WAKE,\n\t\t\t   !en * MT_INFRACFG_MISC_AP2CONN_WAKE);\n}\nEXPORT_SYMBOL_GPL(mt7622_trigger_hif_int);\n\nstatic int mt7615_mcu_drv_pmctrl(struct mt7615_dev *dev)\n{\n\tstruct mt76_phy *mphy = &dev->mt76.phy;\n\tstruct mt76_connac_pm *pm = &dev->pm;\n\tstruct mt76_dev *mdev = &dev->mt76;\n\tu32 addr;\n\tint err;\n\n\tif (is_mt7663(mdev)) {\n\t\t \n\t\tmt76_wr(dev, MT_PCIE_DOORBELL_PUSH, MT_CFG_LPCR_HOST_DRV_OWN);\n\t\tmt76_poll(dev, MT_CONN_ON_MISC, MT_CFG_LPCR_HOST_FW_OWN, 0, 3000);\n\n\t\taddr = MT_CONN_HIF_ON_LPCTL;\n\t} else {\n\t\taddr = MT_CFG_LPCR_HOST;\n\t}\n\n\tmt76_wr(dev, addr, MT_CFG_LPCR_HOST_DRV_OWN);\n\n\tmt7622_trigger_hif_int(dev, true);\n\n\terr = !mt76_poll_msec(dev, addr, MT_CFG_LPCR_HOST_FW_OWN, 0, 3000);\n\n\tmt7622_trigger_hif_int(dev, false);\n\n\tif (err) {\n\t\tdev_err(mdev->dev, \"driver own failed\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tclear_bit(MT76_STATE_PM, &mphy->state);\n\n\tpm->stats.last_wake_event = jiffies;\n\tpm->stats.doze_time += pm->stats.last_wake_event -\n\t\t\t       pm->stats.last_doze_event;\n\n\treturn 0;\n}\n\nstatic int mt7615_mcu_lp_drv_pmctrl(struct mt7615_dev *dev)\n{\n\tstruct mt76_phy *mphy = &dev->mt76.phy;\n\tstruct mt76_connac_pm *pm = &dev->pm;\n\tint i, err = 0;\n\n\tmutex_lock(&pm->mutex);\n\n\tif (!test_bit(MT76_STATE_PM, &mphy->state))\n\t\tgoto out;\n\n\tfor (i = 0; i < MT7615_DRV_OWN_RETRY_COUNT; i++) {\n\t\tmt76_wr(dev, MT_PCIE_DOORBELL_PUSH, MT_CFG_LPCR_HOST_DRV_OWN);\n\t\tif (mt76_poll_msec(dev, MT_CONN_HIF_ON_LPCTL,\n\t\t\t\t   MT_CFG_LPCR_HOST_FW_OWN, 0, 50))\n\t\t\tbreak;\n\t}\n\n\tif (i == MT7615_DRV_OWN_RETRY_COUNT) {\n\t\tdev_err(dev->mt76.dev, \"driver own failed\\n\");\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\tclear_bit(MT76_STATE_PM, &mphy->state);\n\n\tpm->stats.last_wake_event = jiffies;\n\tpm->stats.doze_time += pm->stats.last_wake_event -\n\t\t\t       pm->stats.last_doze_event;\nout:\n\tmutex_unlock(&pm->mutex);\n\n\treturn err;\n}\n\nstatic int mt7615_mcu_fw_pmctrl(struct mt7615_dev *dev)\n{\n\tstruct mt76_phy *mphy = &dev->mt76.phy;\n\tstruct mt76_connac_pm *pm = &dev->pm;\n\tint err = 0;\n\tu32 addr;\n\n\tmutex_lock(&pm->mutex);\n\n\tif (mt76_connac_skip_fw_pmctrl(mphy, pm))\n\t\tgoto out;\n\n\tmt7622_trigger_hif_int(dev, true);\n\n\taddr = is_mt7663(&dev->mt76) ? MT_CONN_HIF_ON_LPCTL : MT_CFG_LPCR_HOST;\n\tmt76_wr(dev, addr, MT_CFG_LPCR_HOST_FW_OWN);\n\n\tif (is_mt7622(&dev->mt76) &&\n\t    !mt76_poll_msec(dev, addr, MT_CFG_LPCR_HOST_FW_OWN,\n\t\t\t    MT_CFG_LPCR_HOST_FW_OWN, 3000)) {\n\t\tdev_err(dev->mt76.dev, \"Timeout for firmware own\\n\");\n\t\tclear_bit(MT76_STATE_PM, &mphy->state);\n\t\terr = -EIO;\n\t}\n\n\tmt7622_trigger_hif_int(dev, false);\n\tif (!err) {\n\t\tpm->stats.last_doze_event = jiffies;\n\t\tpm->stats.awake_time += pm->stats.last_doze_event -\n\t\t\t\t\tpm->stats.last_wake_event;\n\t}\nout:\n\tmutex_unlock(&pm->mutex);\n\n\treturn err;\n}\n\nstatic void\nmt7615_mcu_csa_finish(void *priv, u8 *mac, struct ieee80211_vif *vif)\n{\n\tif (vif->bss_conf.csa_active)\n\t\tieee80211_csa_finish(vif);\n}\n\nstatic void\nmt7615_mcu_rx_csa_notify(struct mt7615_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt7615_phy *ext_phy = mt7615_ext_phy(dev);\n\tstruct mt76_phy *mphy = &dev->mt76.phy;\n\tstruct mt7615_mcu_csa_notify *c;\n\n\tc = (struct mt7615_mcu_csa_notify *)skb->data;\n\n\tif (c->omac_idx > EXT_BSSID_MAX)\n\t\treturn;\n\n\tif (ext_phy && ext_phy->omac_mask & BIT_ULL(c->omac_idx))\n\t\tmphy = dev->mt76.phys[MT_BAND1];\n\n\tieee80211_iterate_active_interfaces_atomic(mphy->hw,\n\t\t\tIEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\tmt7615_mcu_csa_finish, mphy->hw);\n}\n\nstatic void\nmt7615_mcu_rx_radar_detected(struct mt7615_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt76_phy *mphy = &dev->mt76.phy;\n\tstruct mt7615_mcu_rdd_report *r;\n\n\tr = (struct mt7615_mcu_rdd_report *)skb->data;\n\n\tif (!dev->radar_pattern.n_pulses && !r->long_detected &&\n\t    !r->constant_prf_detected && !r->staggered_prf_detected)\n\t\treturn;\n\n\tif (r->band_idx && dev->mt76.phys[MT_BAND1])\n\t\tmphy = dev->mt76.phys[MT_BAND1];\n\n\tif (mt76_phy_dfs_state(mphy) < MT_DFS_STATE_CAC)\n\t\treturn;\n\n\tieee80211_radar_detected(mphy->hw);\n\tdev->hw_pattern++;\n}\n\nstatic void\nmt7615_mcu_rx_log_message(struct mt7615_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt7615_mcu_rxd *rxd = (struct mt7615_mcu_rxd *)skb->data;\n\tconst char *data = (char *)&rxd[1];\n\tconst char *type;\n\n\tswitch (rxd->s2d_index) {\n\tcase 0:\n\t\ttype = \"N9\";\n\t\tbreak;\n\tcase 2:\n\t\ttype = \"CR4\";\n\t\tbreak;\n\tdefault:\n\t\ttype = \"unknown\";\n\t\tbreak;\n\t}\n\n\twiphy_info(mt76_hw(dev)->wiphy, \"%s: %.*s\", type,\n\t\t   (int)(skb->len - sizeof(*rxd)), data);\n}\n\nstatic void\nmt7615_mcu_rx_ext_event(struct mt7615_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt7615_mcu_rxd *rxd = (struct mt7615_mcu_rxd *)skb->data;\n\n\tswitch (rxd->ext_eid) {\n\tcase MCU_EXT_EVENT_RDD_REPORT:\n\t\tmt7615_mcu_rx_radar_detected(dev, skb);\n\t\tbreak;\n\tcase MCU_EXT_EVENT_CSA_NOTIFY:\n\t\tmt7615_mcu_rx_csa_notify(dev, skb);\n\t\tbreak;\n\tcase MCU_EXT_EVENT_FW_LOG_2_HOST:\n\t\tmt7615_mcu_rx_log_message(dev, skb);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\nmt7615_mcu_scan_event(struct mt7615_dev *dev, struct sk_buff *skb)\n{\n\tu8 *seq_num = skb->data + sizeof(struct mt7615_mcu_rxd);\n\tstruct mt7615_phy *phy;\n\tstruct mt76_phy *mphy;\n\n\tif (*seq_num & BIT(7) && dev->mt76.phys[MT_BAND1])\n\t\tmphy = dev->mt76.phys[MT_BAND1];\n\telse\n\t\tmphy = &dev->mt76.phy;\n\n\tphy = (struct mt7615_phy *)mphy->priv;\n\n\tspin_lock_bh(&dev->mt76.lock);\n\t__skb_queue_tail(&phy->scan_event_list, skb);\n\tspin_unlock_bh(&dev->mt76.lock);\n\n\tieee80211_queue_delayed_work(mphy->hw, &phy->scan_work,\n\t\t\t\t     MT7615_HW_SCAN_TIMEOUT);\n}\n\nstatic void\nmt7615_mcu_roc_event(struct mt7615_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt7615_roc_tlv *event;\n\tstruct mt7615_phy *phy;\n\tstruct mt76_phy *mphy;\n\tint duration;\n\n\tskb_pull(skb, sizeof(struct mt7615_mcu_rxd));\n\tevent = (struct mt7615_roc_tlv *)skb->data;\n\n\tif (event->dbdc_band && dev->mt76.phys[MT_BAND1])\n\t\tmphy = dev->mt76.phys[MT_BAND1];\n\telse\n\t\tmphy = &dev->mt76.phy;\n\n\tieee80211_ready_on_channel(mphy->hw);\n\n\tphy = (struct mt7615_phy *)mphy->priv;\n\tphy->roc_grant = true;\n\twake_up(&phy->roc_wait);\n\n\tduration = le32_to_cpu(event->max_interval);\n\tmod_timer(&phy->roc_timer,\n\t\t  round_jiffies_up(jiffies + msecs_to_jiffies(duration)));\n}\n\nstatic void\nmt7615_mcu_beacon_loss_event(struct mt7615_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt76_connac_beacon_loss_event *event;\n\tstruct mt76_phy *mphy;\n\tu8 band_idx = 0;  \n\n\tskb_pull(skb, sizeof(struct mt7615_mcu_rxd));\n\tevent = (struct mt76_connac_beacon_loss_event *)skb->data;\n\tif (band_idx && dev->mt76.phys[MT_BAND1])\n\t\tmphy = dev->mt76.phys[MT_BAND1];\n\telse\n\t\tmphy = &dev->mt76.phy;\n\n\tieee80211_iterate_active_interfaces_atomic(mphy->hw,\n\t\t\t\t\tIEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\t\t\tmt76_connac_mcu_beacon_loss_iter,\n\t\t\t\t\tevent);\n}\n\nstatic void\nmt7615_mcu_bss_event(struct mt7615_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt76_connac_mcu_bss_event *event;\n\tstruct mt76_phy *mphy;\n\tu8 band_idx = 0;  \n\n\tskb_pull(skb, sizeof(struct mt7615_mcu_rxd));\n\tevent = (struct mt76_connac_mcu_bss_event *)skb->data;\n\n\tif (band_idx && dev->mt76.phys[MT_BAND1])\n\t\tmphy = dev->mt76.phys[MT_BAND1];\n\telse\n\t\tmphy = &dev->mt76.phy;\n\n\tif (event->is_absent)\n\t\tieee80211_stop_queues(mphy->hw);\n\telse\n\t\tieee80211_wake_queues(mphy->hw);\n}\n\nstatic void\nmt7615_mcu_rx_unsolicited_event(struct mt7615_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt7615_mcu_rxd *rxd = (struct mt7615_mcu_rxd *)skb->data;\n\n\tswitch (rxd->eid) {\n\tcase MCU_EVENT_EXT:\n\t\tmt7615_mcu_rx_ext_event(dev, skb);\n\t\tbreak;\n\tcase MCU_EVENT_BSS_BEACON_LOSS:\n\t\tmt7615_mcu_beacon_loss_event(dev, skb);\n\t\tbreak;\n\tcase MCU_EVENT_ROC:\n\t\tmt7615_mcu_roc_event(dev, skb);\n\t\tbreak;\n\tcase MCU_EVENT_SCHED_SCAN_DONE:\n\tcase MCU_EVENT_SCAN_DONE:\n\t\tmt7615_mcu_scan_event(dev, skb);\n\t\treturn;\n\tcase MCU_EVENT_BSS_ABSENCE:\n\t\tmt7615_mcu_bss_event(dev, skb);\n\t\tbreak;\n\tcase MCU_EVENT_COREDUMP:\n\t\tmt76_connac_mcu_coredump_event(&dev->mt76, skb,\n\t\t\t\t\t       &dev->coredump);\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\tdev_kfree_skb(skb);\n}\n\nvoid mt7615_mcu_rx_event(struct mt7615_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt7615_mcu_rxd *rxd = (struct mt7615_mcu_rxd *)skb->data;\n\n\tif (rxd->ext_eid == MCU_EXT_EVENT_THERMAL_PROTECT ||\n\t    rxd->ext_eid == MCU_EXT_EVENT_FW_LOG_2_HOST ||\n\t    rxd->ext_eid == MCU_EXT_EVENT_ASSERT_DUMP ||\n\t    rxd->ext_eid == MCU_EXT_EVENT_PS_SYNC ||\n\t    rxd->eid == MCU_EVENT_BSS_BEACON_LOSS ||\n\t    rxd->eid == MCU_EVENT_SCHED_SCAN_DONE ||\n\t    rxd->eid == MCU_EVENT_BSS_ABSENCE ||\n\t    rxd->eid == MCU_EVENT_SCAN_DONE ||\n\t    rxd->eid == MCU_EVENT_COREDUMP ||\n\t    rxd->eid == MCU_EVENT_ROC ||\n\t    !rxd->seq)\n\t\tmt7615_mcu_rx_unsolicited_event(dev, skb);\n\telse\n\t\tmt76_mcu_rx_event(&dev->mt76, skb);\n}\n\nstatic int\nmt7615_mcu_muar_config(struct mt7615_dev *dev, struct ieee80211_vif *vif,\n\t\t       bool bssid, bool enable)\n{\n\tstruct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;\n\tu32 idx = mvif->mt76.omac_idx - REPEATER_BSSID_START;\n\tu32 mask = dev->omac_mask >> 32 & ~BIT(idx);\n\tconst u8 *addr = vif->addr;\n\tstruct {\n\t\tu8 mode;\n\t\tu8 force_clear;\n\t\tu8 clear_bitmap[8];\n\t\tu8 entry_count;\n\t\tu8 write;\n\n\t\tu8 index;\n\t\tu8 bssid;\n\t\tu8 addr[ETH_ALEN];\n\t} __packed req = {\n\t\t.mode = !!mask || enable,\n\t\t.entry_count = 1,\n\t\t.write = 1,\n\n\t\t.index = idx * 2 + bssid,\n\t};\n\n\tif (bssid)\n\t\taddr = vif->bss_conf.bssid;\n\n\tif (enable)\n\t\tether_addr_copy(req.addr, addr);\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(MUAR_UPDATE),\n\t\t\t\t &req, sizeof(req), true);\n}\n\nstatic int\nmt7615_mcu_add_dev(struct mt7615_phy *phy, struct ieee80211_vif *vif,\n\t\t   bool enable)\n{\n\tstruct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;\n\tstruct mt7615_dev *dev = phy->dev;\n\tstruct {\n\t\tstruct req_hdr {\n\t\t\tu8 omac_idx;\n\t\t\tu8 band_idx;\n\t\t\t__le16 tlv_num;\n\t\t\tu8 is_tlv_append;\n\t\t\tu8 rsv[3];\n\t\t} __packed hdr;\n\t\tstruct req_tlv {\n\t\t\t__le16 tag;\n\t\t\t__le16 len;\n\t\t\tu8 active;\n\t\t\tu8 band_idx;\n\t\t\tu8 omac_addr[ETH_ALEN];\n\t\t} __packed tlv;\n\t} data = {\n\t\t.hdr = {\n\t\t\t.omac_idx = mvif->mt76.omac_idx,\n\t\t\t.band_idx = mvif->mt76.band_idx,\n\t\t\t.tlv_num = cpu_to_le16(1),\n\t\t\t.is_tlv_append = 1,\n\t\t},\n\t\t.tlv = {\n\t\t\t.tag = cpu_to_le16(DEV_INFO_ACTIVE),\n\t\t\t.len = cpu_to_le16(sizeof(struct req_tlv)),\n\t\t\t.active = enable,\n\t\t\t.band_idx = mvif->mt76.band_idx,\n\t\t},\n\t};\n\n\tif (mvif->mt76.omac_idx >= REPEATER_BSSID_START)\n\t\treturn mt7615_mcu_muar_config(dev, vif, false, enable);\n\n\tmemcpy(data.tlv.omac_addr, vif->addr, ETH_ALEN);\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(DEV_INFO_UPDATE),\n\t\t\t\t &data, sizeof(data), true);\n}\n\nstatic int\nmt7615_mcu_add_beacon_offload(struct mt7615_dev *dev,\n\t\t\t      struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif, bool enable)\n{\n\tstruct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;\n\tstruct mt76_wcid *wcid = &dev->mt76.global_wcid;\n\tstruct ieee80211_mutable_offsets offs;\n\tstruct ieee80211_tx_info *info;\n\tstruct req {\n\t\tu8 omac_idx;\n\t\tu8 enable;\n\t\tu8 wlan_idx;\n\t\tu8 band_idx;\n\t\tu8 pkt_type;\n\t\tu8 need_pre_tbtt_int;\n\t\t__le16 csa_ie_pos;\n\t\t__le16 pkt_len;\n\t\t__le16 tim_ie_pos;\n\t\tu8 pkt[512];\n\t\tu8 csa_cnt;\n\t\t \n\t\tu8 bcc_cnt;\n\t\t__le16 bcc_ie_pos;\n\t} __packed req = {\n\t\t.omac_idx = mvif->mt76.omac_idx,\n\t\t.enable = enable,\n\t\t.wlan_idx = wcid->idx,\n\t\t.band_idx = mvif->mt76.band_idx,\n\t};\n\tstruct sk_buff *skb;\n\n\tif (!enable)\n\t\tgoto out;\n\n\tskb = ieee80211_beacon_get_template(hw, vif, &offs, 0);\n\tif (!skb)\n\t\treturn -EINVAL;\n\n\tif (skb->len > 512 - MT_TXD_SIZE) {\n\t\tdev_err(dev->mt76.dev, \"Bcn size limit exceed\\n\");\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tinfo->hw_queue |= FIELD_PREP(MT_TX_HW_QUEUE_PHY, mvif->mt76.band_idx);\n\n\tmt7615_mac_write_txwi(dev, (__le32 *)(req.pkt), skb, wcid, NULL,\n\t\t\t      0, NULL, 0, true);\n\tmemcpy(req.pkt + MT_TXD_SIZE, skb->data, skb->len);\n\treq.pkt_len = cpu_to_le16(MT_TXD_SIZE + skb->len);\n\treq.tim_ie_pos = cpu_to_le16(MT_TXD_SIZE + offs.tim_offset);\n\tif (offs.cntdwn_counter_offs[0]) {\n\t\tu16 csa_offs;\n\n\t\tcsa_offs = MT_TXD_SIZE + offs.cntdwn_counter_offs[0] - 4;\n\t\treq.csa_ie_pos = cpu_to_le16(csa_offs);\n\t\treq.csa_cnt = skb->data[offs.cntdwn_counter_offs[0]];\n\t}\n\tdev_kfree_skb(skb);\n\nout:\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(BCN_OFFLOAD), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nstatic int\nmt7615_mcu_ctrl_pm_state(struct mt7615_dev *dev, int band, int state)\n{\n\treturn mt76_connac_mcu_set_pm(&dev->mt76, band, state);\n}\n\nstatic int\nmt7615_mcu_add_bss(struct mt7615_phy *phy, struct ieee80211_vif *vif,\n\t\t   struct ieee80211_sta *sta, bool enable)\n{\n\tstruct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;\n\tstruct mt7615_dev *dev = phy->dev;\n\tstruct sk_buff *skb;\n\n\tif (mvif->mt76.omac_idx >= REPEATER_BSSID_START)\n\t\tmt7615_mcu_muar_config(dev, vif, true, enable);\n\n\tskb = mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->mt76, NULL);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tif (enable)\n\t\tmt76_connac_mcu_bss_omac_tlv(skb, vif);\n\n\tmt76_connac_mcu_bss_basic_tlv(skb, vif, sta, phy->mt76,\n\t\t\t\t      mvif->sta.wcid.idx, enable);\n\n\tif (enable && mvif->mt76.omac_idx >= EXT_BSSID_START &&\n\t    mvif->mt76.omac_idx < REPEATER_BSSID_START)\n\t\tmt76_connac_mcu_bss_ext_tlv(skb, &mvif->mt76);\n\n\treturn mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t     MCU_EXT_CMD(BSS_INFO_UPDATE), true);\n}\n\nstatic int\nmt7615_mcu_wtbl_tx_ba(struct mt7615_dev *dev,\n\t\t      struct ieee80211_ampdu_params *params,\n\t\t      bool enable)\n{\n\tstruct mt7615_sta *msta = (struct mt7615_sta *)params->sta->drv_priv;\n\tstruct mt7615_vif *mvif = msta->vif;\n\tstruct wtbl_req_hdr *wtbl_hdr;\n\tstruct sk_buff *skb = NULL;\n\tint err;\n\n\twtbl_hdr = mt76_connac_mcu_alloc_wtbl_req(&dev->mt76, &msta->wcid,\n\t\t\t\t\t\t  WTBL_SET, NULL, &skb);\n\tif (IS_ERR(wtbl_hdr))\n\t\treturn PTR_ERR(wtbl_hdr);\n\n\tmt76_connac_mcu_wtbl_ba_tlv(&dev->mt76, skb, params, enable, true,\n\t\t\t\t    NULL, wtbl_hdr);\n\n\terr = mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t    MCU_EXT_CMD(WTBL_UPDATE), true);\n\tif (err < 0)\n\t\treturn err;\n\n\tskb = mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->mt76,\n\t\t\t\t\t    &msta->wcid);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tmt76_connac_mcu_sta_ba_tlv(skb, params, enable, true);\n\n\treturn mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t     MCU_EXT_CMD(STA_REC_UPDATE), true);\n}\n\nstatic int\nmt7615_mcu_wtbl_rx_ba(struct mt7615_dev *dev,\n\t\t      struct ieee80211_ampdu_params *params,\n\t\t      bool enable)\n{\n\tstruct mt7615_sta *msta = (struct mt7615_sta *)params->sta->drv_priv;\n\tstruct mt7615_vif *mvif = msta->vif;\n\tstruct wtbl_req_hdr *wtbl_hdr;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->mt76,\n\t\t\t\t\t    &msta->wcid);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tmt76_connac_mcu_sta_ba_tlv(skb, params, enable, false);\n\n\terr = mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t    MCU_EXT_CMD(STA_REC_UPDATE), true);\n\tif (err < 0 || !enable)\n\t\treturn err;\n\n\tskb = NULL;\n\twtbl_hdr = mt76_connac_mcu_alloc_wtbl_req(&dev->mt76, &msta->wcid,\n\t\t\t\t\t\t  WTBL_SET, NULL, &skb);\n\tif (IS_ERR(wtbl_hdr))\n\t\treturn PTR_ERR(wtbl_hdr);\n\n\tmt76_connac_mcu_wtbl_ba_tlv(&dev->mt76, skb, params, enable, false,\n\t\t\t\t    NULL, wtbl_hdr);\n\n\treturn mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t     MCU_EXT_CMD(WTBL_UPDATE), true);\n}\n\nstatic int\nmt7615_mcu_wtbl_sta_add(struct mt7615_phy *phy, struct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_sta *sta, bool enable)\n{\n\tstruct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;\n\tstruct sk_buff *skb, *sskb, *wskb = NULL;\n\tstruct mt7615_dev *dev = phy->dev;\n\tstruct wtbl_req_hdr *wtbl_hdr;\n\tstruct mt7615_sta *msta;\n\tbool new_entry = true;\n\tint cmd, err;\n\n\tmsta = sta ? (struct mt7615_sta *)sta->drv_priv : &mvif->sta;\n\n\tsskb = mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->mt76,\n\t\t\t\t\t     &msta->wcid);\n\tif (IS_ERR(sskb))\n\t\treturn PTR_ERR(sskb);\n\n\tif (!sta) {\n\t\tif (mvif->sta_added)\n\t\t\tnew_entry = false;\n\t\telse\n\t\t\tmvif->sta_added = true;\n\t}\n\tmt76_connac_mcu_sta_basic_tlv(&dev->mt76, sskb, vif, sta, enable,\n\t\t\t\t      new_entry);\n\tif (enable && sta)\n\t\tmt76_connac_mcu_sta_tlv(phy->mt76, sskb, sta, vif, 0,\n\t\t\t\t\tMT76_STA_INFO_STATE_ASSOC);\n\n\twtbl_hdr = mt76_connac_mcu_alloc_wtbl_req(&dev->mt76, &msta->wcid,\n\t\t\t\t\t\t  WTBL_RESET_AND_SET, NULL,\n\t\t\t\t\t\t  &wskb);\n\tif (IS_ERR(wtbl_hdr))\n\t\treturn PTR_ERR(wtbl_hdr);\n\n\tif (enable) {\n\t\tmt76_connac_mcu_wtbl_generic_tlv(&dev->mt76, wskb, vif, sta,\n\t\t\t\t\t\t NULL, wtbl_hdr);\n\t\tif (sta)\n\t\t\tmt76_connac_mcu_wtbl_ht_tlv(&dev->mt76, wskb, sta,\n\t\t\t\t\t\t    NULL, wtbl_hdr, true, true);\n\t\tmt76_connac_mcu_wtbl_hdr_trans_tlv(wskb, vif, &msta->wcid,\n\t\t\t\t\t\t   NULL, wtbl_hdr);\n\t}\n\n\tcmd = enable ? MCU_EXT_CMD(WTBL_UPDATE) : MCU_EXT_CMD(STA_REC_UPDATE);\n\tskb = enable ? wskb : sskb;\n\n\terr = mt76_mcu_skb_send_msg(&dev->mt76, skb, cmd, true);\n\tif (err < 0) {\n\t\tskb = enable ? sskb : wskb;\n\t\tdev_kfree_skb(skb);\n\n\t\treturn err;\n\t}\n\n\tcmd = enable ? MCU_EXT_CMD(STA_REC_UPDATE) : MCU_EXT_CMD(WTBL_UPDATE);\n\tskb = enable ? sskb : wskb;\n\n\treturn mt76_mcu_skb_send_msg(&dev->mt76, skb, cmd, true);\n}\n\nstatic int\nmt7615_mcu_wtbl_update_hdr_trans(struct mt7615_dev *dev,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_sta *sta)\n{\n\treturn mt76_connac_mcu_wtbl_update_hdr_trans(&dev->mt76, vif, sta);\n}\n\nstatic const struct mt7615_mcu_ops wtbl_update_ops = {\n\t.add_beacon_offload = mt7615_mcu_add_beacon_offload,\n\t.set_pm_state = mt7615_mcu_ctrl_pm_state,\n\t.add_dev_info = mt7615_mcu_add_dev,\n\t.add_bss_info = mt7615_mcu_add_bss,\n\t.add_tx_ba = mt7615_mcu_wtbl_tx_ba,\n\t.add_rx_ba = mt7615_mcu_wtbl_rx_ba,\n\t.sta_add = mt7615_mcu_wtbl_sta_add,\n\t.set_drv_ctrl = mt7615_mcu_drv_pmctrl,\n\t.set_fw_ctrl = mt7615_mcu_fw_pmctrl,\n\t.set_sta_decap_offload = mt7615_mcu_wtbl_update_hdr_trans,\n};\n\nstatic int\nmt7615_mcu_sta_ba(struct mt7615_dev *dev,\n\t\t  struct ieee80211_ampdu_params *params,\n\t\t  bool enable, bool tx)\n{\n\tstruct mt7615_sta *msta = (struct mt7615_sta *)params->sta->drv_priv;\n\tstruct mt7615_vif *mvif = msta->vif;\n\tstruct wtbl_req_hdr *wtbl_hdr;\n\tstruct tlv *sta_wtbl;\n\tstruct sk_buff *skb;\n\n\tskb = mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->mt76,\n\t\t\t\t\t    &msta->wcid);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tmt76_connac_mcu_sta_ba_tlv(skb, params, enable, tx);\n\n\tsta_wtbl = mt76_connac_mcu_add_tlv(skb, STA_REC_WTBL, sizeof(struct tlv));\n\n\twtbl_hdr = mt76_connac_mcu_alloc_wtbl_req(&dev->mt76, &msta->wcid,\n\t\t\t\t\t\t  WTBL_SET, sta_wtbl, &skb);\n\tif (IS_ERR(wtbl_hdr))\n\t\treturn PTR_ERR(wtbl_hdr);\n\n\tmt76_connac_mcu_wtbl_ba_tlv(&dev->mt76, skb, params, enable, tx,\n\t\t\t\t    sta_wtbl, wtbl_hdr);\n\n\treturn mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t     MCU_EXT_CMD(STA_REC_UPDATE), true);\n}\n\nstatic int\nmt7615_mcu_sta_tx_ba(struct mt7615_dev *dev,\n\t\t     struct ieee80211_ampdu_params *params,\n\t\t     bool enable)\n{\n\treturn mt7615_mcu_sta_ba(dev, params, enable, true);\n}\n\nstatic int\nmt7615_mcu_sta_rx_ba(struct mt7615_dev *dev,\n\t\t     struct ieee80211_ampdu_params *params,\n\t\t     bool enable)\n{\n\treturn mt7615_mcu_sta_ba(dev, params, enable, false);\n}\n\nstatic int\n__mt7615_mcu_add_sta(struct mt76_phy *phy, struct ieee80211_vif *vif,\n\t\t     struct ieee80211_sta *sta, bool enable, int cmd,\n\t\t     bool offload_fw)\n{\n\tstruct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;\n\tstruct mt76_sta_cmd_info info = {\n\t\t.sta = sta,\n\t\t.vif = vif,\n\t\t.offload_fw = offload_fw,\n\t\t.enable = enable,\n\t\t.newly = true,\n\t\t.cmd = cmd,\n\t};\n\n\tinfo.wcid = sta ? (struct mt76_wcid *)sta->drv_priv : &mvif->sta.wcid;\n\treturn mt76_connac_mcu_sta_cmd(phy, &info);\n}\n\nstatic int\nmt7615_mcu_add_sta(struct mt7615_phy *phy, struct ieee80211_vif *vif,\n\t\t   struct ieee80211_sta *sta, bool enable)\n{\n\treturn __mt7615_mcu_add_sta(phy->mt76, vif, sta, enable,\n\t\t\t\t    MCU_EXT_CMD(STA_REC_UPDATE), false);\n}\n\nstatic int\nmt7615_mcu_sta_update_hdr_trans(struct mt7615_dev *dev,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta)\n{\n\tstruct mt7615_sta *msta = (struct mt7615_sta *)sta->drv_priv;\n\n\treturn mt76_connac_mcu_sta_update_hdr_trans(&dev->mt76,\n\t\t\t\t\t\t    vif, &msta->wcid,\n\t\t\t\t\t\t    MCU_EXT_CMD(STA_REC_UPDATE));\n}\n\nstatic const struct mt7615_mcu_ops sta_update_ops = {\n\t.add_beacon_offload = mt7615_mcu_add_beacon_offload,\n\t.set_pm_state = mt7615_mcu_ctrl_pm_state,\n\t.add_dev_info = mt7615_mcu_add_dev,\n\t.add_bss_info = mt7615_mcu_add_bss,\n\t.add_tx_ba = mt7615_mcu_sta_tx_ba,\n\t.add_rx_ba = mt7615_mcu_sta_rx_ba,\n\t.sta_add = mt7615_mcu_add_sta,\n\t.set_drv_ctrl = mt7615_mcu_drv_pmctrl,\n\t.set_fw_ctrl = mt7615_mcu_fw_pmctrl,\n\t.set_sta_decap_offload = mt7615_mcu_sta_update_hdr_trans,\n};\n\nstatic int\nmt7615_mcu_uni_ctrl_pm_state(struct mt7615_dev *dev, int band, int state)\n{\n\treturn 0;\n}\n\nstatic int\nmt7615_mcu_uni_add_beacon_offload(struct mt7615_dev *dev,\n\t\t\t\t  struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  bool enable)\n{\n\tstruct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;\n\tstruct mt76_wcid *wcid = &dev->mt76.global_wcid;\n\tstruct ieee80211_mutable_offsets offs;\n\tstruct {\n\t\tstruct req_hdr {\n\t\t\tu8 bss_idx;\n\t\t\tu8 pad[3];\n\t\t} __packed hdr;\n\t\tstruct bcn_content_tlv {\n\t\t\t__le16 tag;\n\t\t\t__le16 len;\n\t\t\t__le16 tim_ie_pos;\n\t\t\t__le16 csa_ie_pos;\n\t\t\t__le16 bcc_ie_pos;\n\t\t\t \n\t\t\tu8 enable;\n\t\t\t \n\t\t\tu8 type;\n\t\t\t__le16 pkt_len;\n\t\t\tu8 pkt[512];\n\t\t} __packed beacon_tlv;\n\t} req = {\n\t\t.hdr = {\n\t\t\t.bss_idx = mvif->mt76.idx,\n\t\t},\n\t\t.beacon_tlv = {\n\t\t\t.tag = cpu_to_le16(UNI_BSS_INFO_BCN_CONTENT),\n\t\t\t.len = cpu_to_le16(sizeof(struct bcn_content_tlv)),\n\t\t\t.enable = enable,\n\t\t},\n\t};\n\tstruct sk_buff *skb;\n\n\tif (!enable)\n\t\tgoto out;\n\n\tskb = ieee80211_beacon_get_template(mt76_hw(dev), vif, &offs, 0);\n\tif (!skb)\n\t\treturn -EINVAL;\n\n\tif (skb->len > 512 - MT_TXD_SIZE) {\n\t\tdev_err(dev->mt76.dev, \"beacon size limit exceed\\n\");\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tmt7615_mac_write_txwi(dev, (__le32 *)(req.beacon_tlv.pkt), skb,\n\t\t\t      wcid, NULL, 0, NULL, 0, true);\n\tmemcpy(req.beacon_tlv.pkt + MT_TXD_SIZE, skb->data, skb->len);\n\treq.beacon_tlv.pkt_len = cpu_to_le16(MT_TXD_SIZE + skb->len);\n\treq.beacon_tlv.tim_ie_pos = cpu_to_le16(MT_TXD_SIZE + offs.tim_offset);\n\n\tif (offs.cntdwn_counter_offs[0]) {\n\t\tu16 csa_offs;\n\n\t\tcsa_offs = MT_TXD_SIZE + offs.cntdwn_counter_offs[0] - 4;\n\t\treq.beacon_tlv.csa_ie_pos = cpu_to_le16(csa_offs);\n\t}\n\tdev_kfree_skb(skb);\n\nout:\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD(BSS_INFO_UPDATE),\n\t\t\t\t &req, sizeof(req), true);\n}\n\nstatic int\nmt7615_mcu_uni_add_dev(struct mt7615_phy *phy, struct ieee80211_vif *vif,\n\t\t       bool enable)\n{\n\tstruct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;\n\n\treturn mt76_connac_mcu_uni_add_dev(phy->mt76, vif, &mvif->sta.wcid,\n\t\t\t\t\t   enable);\n}\n\nstatic int\nmt7615_mcu_uni_add_bss(struct mt7615_phy *phy, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_sta *sta, bool enable)\n{\n\tstruct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;\n\n\treturn mt76_connac_mcu_uni_add_bss(phy->mt76, vif, &mvif->sta.wcid,\n\t\t\t\t\t   enable, NULL);\n}\n\nstatic inline int\nmt7615_mcu_uni_add_sta(struct mt7615_phy *phy, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_sta *sta, bool enable)\n{\n\treturn __mt7615_mcu_add_sta(phy->mt76, vif, sta, enable,\n\t\t\t\t    MCU_UNI_CMD(STA_REC_UPDATE), true);\n}\n\nstatic int\nmt7615_mcu_uni_tx_ba(struct mt7615_dev *dev,\n\t\t     struct ieee80211_ampdu_params *params,\n\t\t     bool enable)\n{\n\tstruct mt7615_sta *sta = (struct mt7615_sta *)params->sta->drv_priv;\n\n\treturn mt76_connac_mcu_sta_ba(&dev->mt76, &sta->vif->mt76, params,\n\t\t\t\t      MCU_UNI_CMD(STA_REC_UPDATE), enable,\n\t\t\t\t      true);\n}\n\nstatic int\nmt7615_mcu_uni_rx_ba(struct mt7615_dev *dev,\n\t\t     struct ieee80211_ampdu_params *params,\n\t\t     bool enable)\n{\n\tstruct mt7615_sta *msta = (struct mt7615_sta *)params->sta->drv_priv;\n\tstruct mt7615_vif *mvif = msta->vif;\n\tstruct wtbl_req_hdr *wtbl_hdr;\n\tstruct tlv *sta_wtbl;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->mt76,\n\t\t\t\t\t    &msta->wcid);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tmt76_connac_mcu_sta_ba_tlv(skb, params, enable, false);\n\n\terr = mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t    MCU_UNI_CMD(STA_REC_UPDATE), true);\n\tif (err < 0 || !enable)\n\t\treturn err;\n\n\tskb = mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->mt76,\n\t\t\t\t\t    &msta->wcid);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tsta_wtbl = mt76_connac_mcu_add_tlv(skb, STA_REC_WTBL,\n\t\t\t\t\t   sizeof(struct tlv));\n\n\twtbl_hdr = mt76_connac_mcu_alloc_wtbl_req(&dev->mt76, &msta->wcid,\n\t\t\t\t\t\t  WTBL_SET, sta_wtbl, &skb);\n\tif (IS_ERR(wtbl_hdr))\n\t\treturn PTR_ERR(wtbl_hdr);\n\n\tmt76_connac_mcu_wtbl_ba_tlv(&dev->mt76, skb, params, enable, false,\n\t\t\t\t    sta_wtbl, wtbl_hdr);\n\n\treturn mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t     MCU_UNI_CMD(STA_REC_UPDATE), true);\n}\n\nstatic int\nmt7615_mcu_sta_uni_update_hdr_trans(struct mt7615_dev *dev,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_sta *sta)\n{\n\tstruct mt7615_sta *msta = (struct mt7615_sta *)sta->drv_priv;\n\n\treturn mt76_connac_mcu_sta_update_hdr_trans(&dev->mt76,\n\t\t\t\t\t\t    vif, &msta->wcid,\n\t\t\t\t\t\t    MCU_UNI_CMD(STA_REC_UPDATE));\n}\n\nstatic const struct mt7615_mcu_ops uni_update_ops = {\n\t.add_beacon_offload = mt7615_mcu_uni_add_beacon_offload,\n\t.set_pm_state = mt7615_mcu_uni_ctrl_pm_state,\n\t.add_dev_info = mt7615_mcu_uni_add_dev,\n\t.add_bss_info = mt7615_mcu_uni_add_bss,\n\t.add_tx_ba = mt7615_mcu_uni_tx_ba,\n\t.add_rx_ba = mt7615_mcu_uni_rx_ba,\n\t.sta_add = mt7615_mcu_uni_add_sta,\n\t.set_drv_ctrl = mt7615_mcu_lp_drv_pmctrl,\n\t.set_fw_ctrl = mt7615_mcu_fw_pmctrl,\n\t.set_sta_decap_offload = mt7615_mcu_sta_uni_update_hdr_trans,\n};\n\nint mt7615_mcu_restart(struct mt76_dev *dev)\n{\n\treturn mt76_mcu_send_msg(dev, MCU_CMD(RESTART_DL_REQ), NULL, 0, true);\n}\nEXPORT_SYMBOL_GPL(mt7615_mcu_restart);\n\nstatic int mt7615_load_patch(struct mt7615_dev *dev, u32 addr, const char *name)\n{\n\tconst struct mt7615_patch_hdr *hdr;\n\tconst struct firmware *fw = NULL;\n\tint len, ret, sem;\n\n\tret = firmware_request_nowarn(&fw, name, dev->mt76.dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!fw || !fw->data || fw->size < sizeof(*hdr)) {\n\t\tdev_err(dev->mt76.dev, \"Invalid firmware\\n\");\n\t\tret = -EINVAL;\n\t\tgoto release_fw;\n\t}\n\n\tsem = mt76_connac_mcu_patch_sem_ctrl(&dev->mt76, true);\n\tswitch (sem) {\n\tcase PATCH_IS_DL:\n\t\tgoto release_fw;\n\tcase PATCH_NOT_DL_SEM_SUCCESS:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->mt76.dev, \"Failed to get patch semaphore\\n\");\n\t\tret = -EAGAIN;\n\t\tgoto release_fw;\n\t}\n\n\thdr = (const struct mt7615_patch_hdr *)(fw->data);\n\n\tdev_info(dev->mt76.dev, \"HW/SW Version: 0x%x, Build Time: %.16s\\n\",\n\t\t be32_to_cpu(hdr->hw_sw_ver), hdr->build_date);\n\n\tlen = fw->size - sizeof(*hdr);\n\n\tret = mt76_connac_mcu_init_download(&dev->mt76, addr, len,\n\t\t\t\t\t    DL_MODE_NEED_RSP);\n\tif (ret) {\n\t\tdev_err(dev->mt76.dev, \"Download request failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = mt76_mcu_send_firmware(&dev->mt76, MCU_CMD(FW_SCATTER),\n\t\t\t\t     fw->data + sizeof(*hdr), len);\n\tif (ret) {\n\t\tdev_err(dev->mt76.dev, \"Failed to send firmware to device\\n\");\n\t\tgoto out;\n\t}\n\n\tret = mt76_connac_mcu_start_patch(&dev->mt76);\n\tif (ret)\n\t\tdev_err(dev->mt76.dev, \"Failed to start patch\\n\");\n\nout:\n\tsem = mt76_connac_mcu_patch_sem_ctrl(&dev->mt76, false);\n\tswitch (sem) {\n\tcase PATCH_REL_SEM_SUCCESS:\n\t\tbreak;\n\tdefault:\n\t\tret = -EAGAIN;\n\t\tdev_err(dev->mt76.dev, \"Failed to release patch semaphore\\n\");\n\t\tbreak;\n\t}\n\nrelease_fw:\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\nstatic int\nmt7615_mcu_send_ram_firmware(struct mt7615_dev *dev,\n\t\t\t     const struct mt7615_fw_trailer *hdr,\n\t\t\t     const u8 *data, bool is_cr4)\n{\n\tint n_region = is_cr4 ? CR4_REGION_NUM : N9_REGION_NUM;\n\tint err, i, offset = 0;\n\tu32 len, addr, mode;\n\n\tfor (i = 0; i < n_region; i++) {\n\t\tmode = mt76_connac_mcu_gen_dl_mode(&dev->mt76,\n\t\t\t\t\t\t   hdr[i].feature_set, is_cr4);\n\t\tlen = le32_to_cpu(hdr[i].len) + IMG_CRC_LEN;\n\t\taddr = le32_to_cpu(hdr[i].addr);\n\n\t\terr = mt76_connac_mcu_init_download(&dev->mt76, addr, len,\n\t\t\t\t\t\t    mode);\n\t\tif (err) {\n\t\t\tdev_err(dev->mt76.dev, \"Download request failed\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\terr = mt76_mcu_send_firmware(&dev->mt76, MCU_CMD(FW_SCATTER),\n\t\t\t\t\t     data + offset, len);\n\t\tif (err) {\n\t\t\tdev_err(dev->mt76.dev, \"Failed to send firmware to device\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\toffset += len;\n\t}\n\n\treturn 0;\n}\n\nstatic int mt7615_load_n9(struct mt7615_dev *dev, const char *name)\n{\n\tconst struct mt7615_fw_trailer *hdr;\n\tconst struct firmware *fw;\n\tint ret;\n\n\tret = request_firmware(&fw, name, dev->mt76.dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!fw || !fw->data || fw->size < N9_REGION_NUM * sizeof(*hdr)) {\n\t\tdev_err(dev->mt76.dev, \"Invalid firmware\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\thdr = (const struct mt7615_fw_trailer *)(fw->data + fw->size -\n\t\t\t\t\tN9_REGION_NUM * sizeof(*hdr));\n\n\tdev_info(dev->mt76.dev, \"N9 Firmware Version: %.10s, Build Time: %.15s\\n\",\n\t\t hdr->fw_ver, hdr->build_date);\n\n\tret = mt7615_mcu_send_ram_firmware(dev, hdr, fw->data, false);\n\tif (ret)\n\t\tgoto out;\n\n\tret = mt76_connac_mcu_start_firmware(&dev->mt76,\n\t\t\t\t\t     le32_to_cpu(hdr->addr),\n\t\t\t\t\t     FW_START_OVERRIDE);\n\tif (ret) {\n\t\tdev_err(dev->mt76.dev, \"Failed to start N9 firmware\\n\");\n\t\tgoto out;\n\t}\n\n\tsnprintf(dev->mt76.hw->wiphy->fw_version,\n\t\t sizeof(dev->mt76.hw->wiphy->fw_version),\n\t\t \"%.10s-%.15s\", hdr->fw_ver, hdr->build_date);\n\n\tif (!is_mt7615(&dev->mt76)) {\n\t\tdev->fw_ver = MT7615_FIRMWARE_V2;\n\t\tdev->mcu_ops = &sta_update_ops;\n\t} else {\n\t\tdev->fw_ver = MT7615_FIRMWARE_V1;\n\t\tdev->mcu_ops = &wtbl_update_ops;\n\t}\n\nout:\n\trelease_firmware(fw);\n\treturn ret;\n}\n\nstatic int mt7615_load_cr4(struct mt7615_dev *dev, const char *name)\n{\n\tconst struct mt7615_fw_trailer *hdr;\n\tconst struct firmware *fw;\n\tint ret;\n\n\tret = request_firmware(&fw, name, dev->mt76.dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!fw || !fw->data || fw->size < CR4_REGION_NUM * sizeof(*hdr)) {\n\t\tdev_err(dev->mt76.dev, \"Invalid firmware\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\thdr = (const struct mt7615_fw_trailer *)(fw->data + fw->size -\n\t\t\t\t\tCR4_REGION_NUM * sizeof(*hdr));\n\n\tdev_info(dev->mt76.dev, \"CR4 Firmware Version: %.10s, Build Time: %.15s\\n\",\n\t\t hdr->fw_ver, hdr->build_date);\n\n\tret = mt7615_mcu_send_ram_firmware(dev, hdr, fw->data, true);\n\tif (ret)\n\t\tgoto out;\n\n\tret = mt76_connac_mcu_start_firmware(&dev->mt76, 0,\n\t\t\t\t\t     FW_START_WORKING_PDA_CR4);\n\tif (ret) {\n\t\tdev_err(dev->mt76.dev, \"Failed to start CR4 firmware\\n\");\n\t\tgoto out;\n\t}\n\nout:\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\nstatic int mt7615_load_ram(struct mt7615_dev *dev)\n{\n\tint ret;\n\n\tret = mt7615_load_n9(dev, MT7615_FIRMWARE_N9);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mt7615_load_cr4(dev, MT7615_FIRMWARE_CR4);\n}\n\nstatic int mt7615_load_firmware(struct mt7615_dev *dev)\n{\n\tint ret;\n\tu32 val;\n\n\tval = mt76_get_field(dev, MT_TOP_MISC2, MT_TOP_MISC2_FW_STATE);\n\n\tif (val != FW_STATE_FW_DOWNLOAD) {\n\t\tdev_err(dev->mt76.dev, \"Firmware is not ready for download\\n\");\n\t\treturn -EIO;\n\t}\n\n\tret = mt7615_load_patch(dev, MT7615_PATCH_ADDRESS, MT7615_ROM_PATCH);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7615_load_ram(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!mt76_poll_msec(dev, MT_TOP_MISC2, MT_TOP_MISC2_FW_STATE,\n\t\t\t    FIELD_PREP(MT_TOP_MISC2_FW_STATE,\n\t\t\t\t       FW_STATE_RDY), 500)) {\n\t\tdev_err(dev->mt76.dev, \"Timeout for initializing firmware\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int mt7622_load_firmware(struct mt7615_dev *dev)\n{\n\tint ret;\n\tu32 val;\n\n\tmt76_set(dev, MT_WPDMA_GLO_CFG, MT_WPDMA_GLO_CFG_BYPASS_TX_SCH);\n\n\tval = mt76_get_field(dev, MT_TOP_OFF_RSV, MT_TOP_OFF_RSV_FW_STATE);\n\tif (val != FW_STATE_FW_DOWNLOAD) {\n\t\tdev_err(dev->mt76.dev, \"Firmware is not ready for download\\n\");\n\t\treturn -EIO;\n\t}\n\n\tret = mt7615_load_patch(dev, MT7622_PATCH_ADDRESS, MT7622_ROM_PATCH);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7615_load_n9(dev, MT7622_FIRMWARE_N9);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!mt76_poll_msec(dev, MT_TOP_OFF_RSV, MT_TOP_OFF_RSV_FW_STATE,\n\t\t\t    FIELD_PREP(MT_TOP_OFF_RSV_FW_STATE,\n\t\t\t\t       FW_STATE_NORMAL_TRX), 1500)) {\n\t\tdev_err(dev->mt76.dev, \"Timeout for initializing firmware\\n\");\n\t\treturn -EIO;\n\t}\n\n\tmt76_clear(dev, MT_WPDMA_GLO_CFG, MT_WPDMA_GLO_CFG_BYPASS_TX_SCH);\n\n\treturn 0;\n}\n\nint mt7615_mcu_fw_log_2_host(struct mt7615_dev *dev, u8 ctrl)\n{\n\tstruct {\n\t\tu8 ctrl_val;\n\t\tu8 pad[3];\n\t} data = {\n\t\t.ctrl_val = ctrl\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(FW_LOG_2_HOST),\n\t\t\t\t &data, sizeof(data), true);\n}\n\nstatic int mt7615_mcu_cal_cache_apply(struct mt7615_dev *dev)\n{\n\tstruct {\n\t\tbool cache_enable;\n\t\tu8 pad[3];\n\t} data = {\n\t\t.cache_enable = true\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(CAL_CACHE), &data,\n\t\t\t\t sizeof(data), false);\n}\n\nstatic int mt7663_load_n9(struct mt7615_dev *dev, const char *name)\n{\n\tu32 offset = 0, override_addr = 0, flag = FW_START_DLYCAL;\n\tconst struct mt76_connac2_fw_trailer *hdr;\n\tconst struct mt7663_fw_buf *buf;\n\tconst struct firmware *fw;\n\tconst u8 *base_addr;\n\tint i, ret;\n\n\tret = request_firmware(&fw, name, dev->mt76.dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!fw || !fw->data || fw->size < FW_V3_COMMON_TAILER_SIZE) {\n\t\tdev_err(dev->mt76.dev, \"Invalid firmware\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\thdr = (const void *)(fw->data + fw->size - FW_V3_COMMON_TAILER_SIZE);\n\tdev_info(dev->mt76.dev, \"N9 Firmware Version: %.10s, Build Time: %.15s\\n\",\n\t\t hdr->fw_ver, hdr->build_date);\n\tdev_info(dev->mt76.dev, \"Region number: 0x%x\\n\", hdr->n_region);\n\n\tbase_addr = fw->data + fw->size - FW_V3_COMMON_TAILER_SIZE;\n\tfor (i = 0; i < hdr->n_region; i++) {\n\t\tu32 shift = (hdr->n_region - i) * FW_V3_REGION_TAILER_SIZE;\n\t\tu32 len, addr, mode;\n\n\t\tdev_info(dev->mt76.dev, \"Parsing tailer Region: %d\\n\", i);\n\n\t\tbuf = (const struct mt7663_fw_buf *)(base_addr - shift);\n\t\tmode = mt76_connac_mcu_gen_dl_mode(&dev->mt76,\n\t\t\t\t\t\t   buf->feature_set, false);\n\t\taddr = le32_to_cpu(buf->img_dest_addr);\n\t\tlen = le32_to_cpu(buf->img_size);\n\n\t\tret = mt76_connac_mcu_init_download(&dev->mt76, addr, len,\n\t\t\t\t\t\t    mode);\n\t\tif (ret) {\n\t\t\tdev_err(dev->mt76.dev, \"Download request failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = mt76_mcu_send_firmware(&dev->mt76, MCU_CMD(FW_SCATTER),\n\t\t\t\t\t     fw->data + offset, len);\n\t\tif (ret) {\n\t\t\tdev_err(dev->mt76.dev, \"Failed to send firmware\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\toffset += le32_to_cpu(buf->img_size);\n\t\tif (buf->feature_set & DL_MODE_VALID_RAM_ENTRY) {\n\t\t\toverride_addr = le32_to_cpu(buf->img_dest_addr);\n\t\t\tdev_info(dev->mt76.dev, \"Region %d, override_addr = 0x%08x\\n\",\n\t\t\t\t i, override_addr);\n\t\t}\n\t}\n\n\tif (override_addr)\n\t\tflag |= FW_START_OVERRIDE;\n\n\tdev_info(dev->mt76.dev, \"override_addr = 0x%08x, option = %d\\n\",\n\t\t override_addr, flag);\n\n\tret = mt76_connac_mcu_start_firmware(&dev->mt76, override_addr, flag);\n\tif (ret) {\n\t\tdev_err(dev->mt76.dev, \"Failed to start N9 firmware\\n\");\n\t\tgoto out;\n\t}\n\n\tsnprintf(dev->mt76.hw->wiphy->fw_version,\n\t\t sizeof(dev->mt76.hw->wiphy->fw_version),\n\t\t \"%.10s-%.15s\", hdr->fw_ver, hdr->build_date);\n\nout:\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\nstatic int\nmt7663_load_rom_patch(struct mt7615_dev *dev, const char **n9_firmware)\n{\n\tconst char *selected_rom, *secondary_rom = MT7663_ROM_PATCH;\n\tconst char *primary_rom = MT7663_OFFLOAD_ROM_PATCH;\n\tint ret;\n\n\tif (!prefer_offload_fw) {\n\t\tsecondary_rom = MT7663_OFFLOAD_ROM_PATCH;\n\t\tprimary_rom = MT7663_ROM_PATCH;\n\t}\n\tselected_rom = primary_rom;\n\n\tret = mt7615_load_patch(dev, MT7663_PATCH_ADDRESS, primary_rom);\n\tif (ret) {\n\t\tdev_info(dev->mt76.dev, \"%s not found, switching to %s\",\n\t\t\t primary_rom, secondary_rom);\n\t\tret = mt7615_load_patch(dev, MT7663_PATCH_ADDRESS,\n\t\t\t\t\tsecondary_rom);\n\t\tif (ret) {\n\t\t\tdev_err(dev->mt76.dev, \"failed to load %s\",\n\t\t\t\tsecondary_rom);\n\t\t\treturn ret;\n\t\t}\n\t\tselected_rom = secondary_rom;\n\t}\n\n\tif (!strcmp(selected_rom, MT7663_OFFLOAD_ROM_PATCH)) {\n\t\t*n9_firmware = MT7663_OFFLOAD_FIRMWARE_N9;\n\t\tdev->fw_ver = MT7615_FIRMWARE_V3;\n\t\tdev->mcu_ops = &uni_update_ops;\n\t} else {\n\t\t*n9_firmware = MT7663_FIRMWARE_N9;\n\t\tdev->fw_ver = MT7615_FIRMWARE_V2;\n\t\tdev->mcu_ops = &sta_update_ops;\n\t}\n\n\treturn 0;\n}\n\nint __mt7663_load_firmware(struct mt7615_dev *dev)\n{\n\tconst char *n9_firmware;\n\tint ret;\n\n\tret = mt76_get_field(dev, MT_CONN_ON_MISC, MT_TOP_MISC2_FW_N9_RDY);\n\tif (ret) {\n\t\tdev_dbg(dev->mt76.dev, \"Firmware is already download\\n\");\n\t\treturn -EIO;\n\t}\n\n\tret = mt7663_load_rom_patch(dev, &n9_firmware);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7663_load_n9(dev, n9_firmware);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!mt76_poll_msec(dev, MT_CONN_ON_MISC, MT_TOP_MISC2_FW_N9_RDY,\n\t\t\t    MT_TOP_MISC2_FW_N9_RDY, 1500)) {\n\t\tret = mt76_get_field(dev, MT_CONN_ON_MISC,\n\t\t\t\t     MT7663_TOP_MISC2_FW_STATE);\n\t\tdev_err(dev->mt76.dev, \"Timeout for initializing firmware\\n\");\n\t\treturn -EIO;\n\t}\n\n#ifdef CONFIG_PM\n\tif (mt7615_firmware_offload(dev))\n\t\tdev->mt76.hw->wiphy->wowlan = &mt76_connac_wowlan_support;\n#endif  \n\n\tdev_dbg(dev->mt76.dev, \"Firmware init done\\n\");\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__mt7663_load_firmware);\n\nstatic int mt7663_load_firmware(struct mt7615_dev *dev)\n{\n\tint ret;\n\n\tmt76_set(dev, MT_WPDMA_GLO_CFG, MT_WPDMA_GLO_CFG_BYPASS_TX_SCH);\n\n\tret = __mt7663_load_firmware(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmt76_clear(dev, MT_WPDMA_GLO_CFG, MT_WPDMA_GLO_CFG_BYPASS_TX_SCH);\n\n\treturn 0;\n}\n\nint mt7615_mcu_init(struct mt7615_dev *dev)\n{\n\tstatic const struct mt76_mcu_ops mt7615_mcu_ops = {\n\t\t.headroom = sizeof(struct mt7615_mcu_txd),\n\t\t.mcu_skb_send_msg = mt7615_mcu_send_message,\n\t\t.mcu_parse_response = mt7615_mcu_parse_response,\n\t};\n\tint ret;\n\n\tdev->mt76.mcu_ops = &mt7615_mcu_ops,\n\n\tret = mt7615_mcu_drv_pmctrl(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (mt76_chip(&dev->mt76)) {\n\tcase 0x7622:\n\t\tret = mt7622_load_firmware(dev);\n\t\tbreak;\n\tcase 0x7663:\n\t\tret = mt7663_load_firmware(dev);\n\t\tbreak;\n\tdefault:\n\t\tret = mt7615_load_firmware(dev);\n\t\tbreak;\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\tmt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[MT_MCUQ_FWDL], false);\n\tdev_dbg(dev->mt76.dev, \"Firmware init done\\n\");\n\tset_bit(MT76_STATE_MCU_RUNNING, &dev->mphy.state);\n\n\tif (dev->dbdc_support) {\n\t\tret = mt7615_mcu_cal_cache_apply(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn mt7615_mcu_fw_log_2_host(dev, 0);\n}\nEXPORT_SYMBOL_GPL(mt7615_mcu_init);\n\nvoid mt7615_mcu_exit(struct mt7615_dev *dev)\n{\n\tmt7615_mcu_restart(&dev->mt76);\n\tmt7615_mcu_set_fw_ctrl(dev);\n\tskb_queue_purge(&dev->mt76.mcu.res_q);\n}\nEXPORT_SYMBOL_GPL(mt7615_mcu_exit);\n\nint mt7615_mcu_set_eeprom(struct mt7615_dev *dev)\n{\n\tstruct {\n\t\tu8 buffer_mode;\n\t\tu8 content_format;\n\t\t__le16 len;\n\t} __packed req_hdr = {\n\t\t.buffer_mode = 1,\n\t};\n\tu8 *eep = (u8 *)dev->mt76.eeprom.data;\n\tstruct sk_buff *skb;\n\tint eep_len, offset;\n\n\tswitch (mt76_chip(&dev->mt76)) {\n\tcase 0x7622:\n\t\teep_len = MT7622_EE_MAX - MT_EE_NIC_CONF_0;\n\t\toffset = MT_EE_NIC_CONF_0;\n\t\tbreak;\n\tcase 0x7663:\n\t\teep_len = MT7663_EE_MAX - MT_EE_CHIP_ID;\n\t\treq_hdr.content_format = 1;\n\t\toffset = MT_EE_CHIP_ID;\n\t\tbreak;\n\tdefault:\n\t\teep_len = MT7615_EE_MAX - MT_EE_NIC_CONF_0;\n\t\toffset = MT_EE_NIC_CONF_0;\n\t\tbreak;\n\t}\n\n\treq_hdr.len = cpu_to_le16(eep_len);\n\n\tskb = mt76_mcu_msg_alloc(&dev->mt76, NULL, sizeof(req_hdr) + eep_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_data(skb, &req_hdr, sizeof(req_hdr));\n\tskb_put_data(skb, eep + offset, eep_len);\n\n\treturn mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t     MCU_EXT_CMD(EFUSE_BUFFER_MODE), true);\n}\n\nint mt7615_mcu_set_wmm(struct mt7615_dev *dev, u8 queue,\n\t\t       const struct ieee80211_tx_queue_params *params)\n{\n#define WMM_AIFS_SET\tBIT(0)\n#define WMM_CW_MIN_SET\tBIT(1)\n#define WMM_CW_MAX_SET\tBIT(2)\n#define WMM_TXOP_SET\tBIT(3)\n#define WMM_PARAM_SET\t(WMM_AIFS_SET | WMM_CW_MIN_SET | \\\n\t\t\t WMM_CW_MAX_SET | WMM_TXOP_SET)\n\tstruct req_data {\n\t\tu8 number;\n\t\tu8 rsv[3];\n\t\tu8 queue;\n\t\tu8 valid;\n\t\tu8 aifs;\n\t\tu8 cw_min;\n\t\t__le16 cw_max;\n\t\t__le16 txop;\n\t} __packed req = {\n\t\t.number = 1,\n\t\t.queue = queue,\n\t\t.valid = WMM_PARAM_SET,\n\t\t.aifs = params->aifs,\n\t\t.cw_min = 5,\n\t\t.cw_max = cpu_to_le16(10),\n\t\t.txop = cpu_to_le16(params->txop),\n\t};\n\n\tif (params->cw_min)\n\t\treq.cw_min = fls(params->cw_min);\n\tif (params->cw_max)\n\t\treq.cw_max = cpu_to_le16(fls(params->cw_max));\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(EDCA_UPDATE),\n\t\t\t\t &req, sizeof(req), true);\n}\n\nint mt7615_mcu_set_dbdc(struct mt7615_dev *dev)\n{\n\tstruct mt7615_phy *ext_phy = mt7615_ext_phy(dev);\n\tstruct dbdc_entry {\n\t\tu8 type;\n\t\tu8 index;\n\t\tu8 band;\n\t\tu8 _rsv;\n\t};\n\tstruct {\n\t\tu8 enable;\n\t\tu8 num;\n\t\tu8 _rsv[2];\n\t\tstruct dbdc_entry entry[64];\n\t} req = {\n\t\t.enable = !!ext_phy,\n\t};\n\tint i;\n\n\tif (!ext_phy)\n\t\tgoto out;\n\n#define ADD_DBDC_ENTRY(_type, _idx, _band)\t\t\\\n\tdo { \\\n\t\treq.entry[req.num].type = _type;\t\t\\\n\t\treq.entry[req.num].index = _idx;\t\t\\\n\t\treq.entry[req.num++].band = _band;\t\t\\\n\t} while (0)\n\n\tfor (i = 0; i < 4; i++) {\n\t\tbool band = !!(ext_phy->omac_mask & BIT_ULL(i));\n\n\t\tADD_DBDC_ENTRY(DBDC_TYPE_BSS, i, band);\n\t}\n\n\tfor (i = 0; i < 14; i++) {\n\t\tbool band = !!(ext_phy->omac_mask & BIT_ULL(0x11 + i));\n\n\t\tADD_DBDC_ENTRY(DBDC_TYPE_MBSS, i, band);\n\t}\n\n\tADD_DBDC_ENTRY(DBDC_TYPE_MU, 0, 1);\n\n\tfor (i = 0; i < 3; i++)\n\t\tADD_DBDC_ENTRY(DBDC_TYPE_BF, i, 1);\n\n\tADD_DBDC_ENTRY(DBDC_TYPE_WMM, 0, 0);\n\tADD_DBDC_ENTRY(DBDC_TYPE_WMM, 1, 0);\n\tADD_DBDC_ENTRY(DBDC_TYPE_WMM, 2, 1);\n\tADD_DBDC_ENTRY(DBDC_TYPE_WMM, 3, 1);\n\n\tADD_DBDC_ENTRY(DBDC_TYPE_MGMT, 0, 0);\n\tADD_DBDC_ENTRY(DBDC_TYPE_MGMT, 1, 1);\n\nout:\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(DBDC_CTRL), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nint mt7615_mcu_del_wtbl_all(struct mt7615_dev *dev)\n{\n\tstruct wtbl_req_hdr req = {\n\t\t.operation = WTBL_RESET_ALL,\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(WTBL_UPDATE),\n\t\t\t\t &req, sizeof(req), true);\n}\n\nint mt7615_mcu_set_fcc5_lpn(struct mt7615_dev *dev, int val)\n{\n\tstruct {\n\t\t__le16 tag;\n\t\t__le16 min_lpn;\n\t} req = {\n\t\t.tag = cpu_to_le16(0x1),\n\t\t.min_lpn = cpu_to_le16(val),\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(SET_RADAR_TH),\n\t\t\t\t &req, sizeof(req), true);\n}\n\nint mt7615_mcu_set_pulse_th(struct mt7615_dev *dev,\n\t\t\t    const struct mt7615_dfs_pulse *pulse)\n{\n\tstruct {\n\t\t__le16 tag;\n\t\t__le32 max_width;\t \n\t\t__le32 max_pwr;\t\t \n\t\t__le32 min_pwr;\t\t \n\t\t__le32 min_stgr_pri;\t \n\t\t__le32 max_stgr_pri;\t \n\t\t__le32 min_cr_pri;\t \n\t\t__le32 max_cr_pri;\t \n\t} req = {\n\t\t.tag = cpu_to_le16(0x3),\n#define __req_field(field) .field = cpu_to_le32(pulse->field)\n\t\t__req_field(max_width),\n\t\t__req_field(max_pwr),\n\t\t__req_field(min_pwr),\n\t\t__req_field(min_stgr_pri),\n\t\t__req_field(max_stgr_pri),\n\t\t__req_field(min_cr_pri),\n\t\t__req_field(max_cr_pri),\n#undef  __req_field\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(SET_RADAR_TH),\n\t\t\t\t &req, sizeof(req), true);\n}\n\nint mt7615_mcu_set_radar_th(struct mt7615_dev *dev, int index,\n\t\t\t    const struct mt7615_dfs_pattern *pattern)\n{\n\tstruct {\n\t\t__le16 tag;\n\t\t__le16 radar_type;\n\t\tu8 enb;\n\t\tu8 stgr;\n\t\tu8 min_crpn;\n\t\tu8 max_crpn;\n\t\tu8 min_crpr;\n\t\tu8 min_pw;\n\t\tu8 max_pw;\n\t\t__le32 min_pri;\n\t\t__le32 max_pri;\n\t\tu8 min_crbn;\n\t\tu8 max_crbn;\n\t\tu8 min_stgpn;\n\t\tu8 max_stgpn;\n\t\tu8 min_stgpr;\n\t} req = {\n\t\t.tag = cpu_to_le16(0x2),\n\t\t.radar_type = cpu_to_le16(index),\n#define __req_field_u8(field) .field = pattern->field\n#define __req_field_u32(field) .field = cpu_to_le32(pattern->field)\n\t\t__req_field_u8(enb),\n\t\t__req_field_u8(stgr),\n\t\t__req_field_u8(min_crpn),\n\t\t__req_field_u8(max_crpn),\n\t\t__req_field_u8(min_crpr),\n\t\t__req_field_u8(min_pw),\n\t\t__req_field_u8(max_pw),\n\t\t__req_field_u32(min_pri),\n\t\t__req_field_u32(max_pri),\n\t\t__req_field_u8(min_crbn),\n\t\t__req_field_u8(max_crbn),\n\t\t__req_field_u8(min_stgpn),\n\t\t__req_field_u8(max_stgpn),\n\t\t__req_field_u8(min_stgpr),\n#undef __req_field_u8\n#undef __req_field_u32\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(SET_RADAR_TH),\n\t\t\t\t &req, sizeof(req), true);\n}\n\nint mt7615_mcu_rdd_send_pattern(struct mt7615_dev *dev)\n{\n\tstruct {\n\t\tu8 pulse_num;\n\t\tu8 rsv[3];\n\t\tstruct {\n\t\t\t__le32 start_time;\n\t\t\t__le16 width;\n\t\t\t__le16 power;\n\t\t} pattern[32];\n\t} req = {\n\t\t.pulse_num = dev->radar_pattern.n_pulses,\n\t};\n\tu32 start_time = ktime_to_ms(ktime_get_boottime());\n\tint i;\n\n\tif (dev->radar_pattern.n_pulses > ARRAY_SIZE(req.pattern))\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < dev->radar_pattern.n_pulses; i++) {\n\t\tu32 ts = start_time + i * dev->radar_pattern.period;\n\n\t\treq.pattern[i].width = cpu_to_le16(dev->radar_pattern.width);\n\t\treq.pattern[i].power = cpu_to_le16(dev->radar_pattern.power);\n\t\treq.pattern[i].start_time = cpu_to_le32(ts);\n\t}\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(SET_RDD_PATTERN),\n\t\t\t\t &req, sizeof(req), false);\n}\n\nstatic void mt7615_mcu_set_txpower_sku(struct mt7615_phy *phy, u8 *sku)\n{\n\tstruct mt76_phy *mphy = phy->mt76;\n\tstruct ieee80211_hw *hw = mphy->hw;\n\tstruct mt76_power_limits limits;\n\ts8 *limits_array = (s8 *)&limits;\n\tint n_chains = hweight8(mphy->antenna_mask);\n\tint tx_power = hw->conf.power_level * 2;\n\tint i;\n\tstatic const u8 sku_mapping[] = {\n#define SKU_FIELD(_type, _field) \\\n\t\t[MT_SKU_##_type] = offsetof(struct mt76_power_limits, _field)\n\t\tSKU_FIELD(CCK_1_2, cck[0]),\n\t\tSKU_FIELD(CCK_55_11, cck[2]),\n\t\tSKU_FIELD(OFDM_6_9, ofdm[0]),\n\t\tSKU_FIELD(OFDM_12_18, ofdm[2]),\n\t\tSKU_FIELD(OFDM_24_36, ofdm[4]),\n\t\tSKU_FIELD(OFDM_48, ofdm[6]),\n\t\tSKU_FIELD(OFDM_54, ofdm[7]),\n\t\tSKU_FIELD(HT20_0_8, mcs[0][0]),\n\t\tSKU_FIELD(HT20_32, ofdm[0]),\n\t\tSKU_FIELD(HT20_1_2_9_10, mcs[0][1]),\n\t\tSKU_FIELD(HT20_3_4_11_12, mcs[0][3]),\n\t\tSKU_FIELD(HT20_5_13, mcs[0][5]),\n\t\tSKU_FIELD(HT20_6_14, mcs[0][6]),\n\t\tSKU_FIELD(HT20_7_15, mcs[0][7]),\n\t\tSKU_FIELD(HT40_0_8, mcs[1][0]),\n\t\tSKU_FIELD(HT40_32, ofdm[0]),\n\t\tSKU_FIELD(HT40_1_2_9_10, mcs[1][1]),\n\t\tSKU_FIELD(HT40_3_4_11_12, mcs[1][3]),\n\t\tSKU_FIELD(HT40_5_13, mcs[1][5]),\n\t\tSKU_FIELD(HT40_6_14, mcs[1][6]),\n\t\tSKU_FIELD(HT40_7_15, mcs[1][7]),\n\t\tSKU_FIELD(VHT20_0, mcs[0][0]),\n\t\tSKU_FIELD(VHT20_1_2, mcs[0][1]),\n\t\tSKU_FIELD(VHT20_3_4, mcs[0][3]),\n\t\tSKU_FIELD(VHT20_5_6, mcs[0][5]),\n\t\tSKU_FIELD(VHT20_7, mcs[0][7]),\n\t\tSKU_FIELD(VHT20_8, mcs[0][8]),\n\t\tSKU_FIELD(VHT20_9, mcs[0][9]),\n\t\tSKU_FIELD(VHT40_0, mcs[1][0]),\n\t\tSKU_FIELD(VHT40_1_2, mcs[1][1]),\n\t\tSKU_FIELD(VHT40_3_4, mcs[1][3]),\n\t\tSKU_FIELD(VHT40_5_6, mcs[1][5]),\n\t\tSKU_FIELD(VHT40_7, mcs[1][7]),\n\t\tSKU_FIELD(VHT40_8, mcs[1][8]),\n\t\tSKU_FIELD(VHT40_9, mcs[1][9]),\n\t\tSKU_FIELD(VHT80_0, mcs[2][0]),\n\t\tSKU_FIELD(VHT80_1_2, mcs[2][1]),\n\t\tSKU_FIELD(VHT80_3_4, mcs[2][3]),\n\t\tSKU_FIELD(VHT80_5_6, mcs[2][5]),\n\t\tSKU_FIELD(VHT80_7, mcs[2][7]),\n\t\tSKU_FIELD(VHT80_8, mcs[2][8]),\n\t\tSKU_FIELD(VHT80_9, mcs[2][9]),\n\t\tSKU_FIELD(VHT160_0, mcs[3][0]),\n\t\tSKU_FIELD(VHT160_1_2, mcs[3][1]),\n\t\tSKU_FIELD(VHT160_3_4, mcs[3][3]),\n\t\tSKU_FIELD(VHT160_5_6, mcs[3][5]),\n\t\tSKU_FIELD(VHT160_7, mcs[3][7]),\n\t\tSKU_FIELD(VHT160_8, mcs[3][8]),\n\t\tSKU_FIELD(VHT160_9, mcs[3][9]),\n#undef SKU_FIELD\n\t};\n\n\ttx_power = mt76_get_sar_power(mphy, mphy->chandef.chan, tx_power);\n\ttx_power -= mt76_tx_power_nss_delta(n_chains);\n\ttx_power = mt76_get_rate_power_limits(mphy, mphy->chandef.chan,\n\t\t\t\t\t      &limits, tx_power);\n\tmphy->txpower_cur = tx_power;\n\n\tif (is_mt7663(mphy->dev)) {\n\t\tmemset(sku, tx_power, MT_SKU_4SS_DELTA + 1);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < MT_SKU_1SS_DELTA; i++)\n\t\tsku[i] = limits_array[sku_mapping[i]];\n\n\tfor (i = 0; i < 4; i++) {\n\t\tint delta = 0;\n\n\t\tif (i < n_chains - 1)\n\t\t\tdelta = mt76_tx_power_nss_delta(n_chains) -\n\t\t\t\tmt76_tx_power_nss_delta(i + 1);\n\t\tsku[MT_SKU_1SS_DELTA + i] = delta;\n\t}\n}\n\nstatic u8 mt7615_mcu_chan_bw(struct cfg80211_chan_def *chandef)\n{\n\tstatic const u8 width_to_bw[] = {\n\t\t[NL80211_CHAN_WIDTH_40] = CMD_CBW_40MHZ,\n\t\t[NL80211_CHAN_WIDTH_80] = CMD_CBW_80MHZ,\n\t\t[NL80211_CHAN_WIDTH_80P80] = CMD_CBW_8080MHZ,\n\t\t[NL80211_CHAN_WIDTH_160] = CMD_CBW_160MHZ,\n\t\t[NL80211_CHAN_WIDTH_5] = CMD_CBW_5MHZ,\n\t\t[NL80211_CHAN_WIDTH_10] = CMD_CBW_10MHZ,\n\t\t[NL80211_CHAN_WIDTH_20] = CMD_CBW_20MHZ,\n\t\t[NL80211_CHAN_WIDTH_20_NOHT] = CMD_CBW_20MHZ,\n\t};\n\n\tif (chandef->width >= ARRAY_SIZE(width_to_bw))\n\t\treturn 0;\n\n\treturn width_to_bw[chandef->width];\n}\n\nint mt7615_mcu_set_chan_info(struct mt7615_phy *phy, int cmd)\n{\n\tstruct mt7615_dev *dev = phy->dev;\n\tstruct cfg80211_chan_def *chandef = &phy->mt76->chandef;\n\tint freq1 = chandef->center_freq1, freq2 = chandef->center_freq2;\n\tstruct {\n\t\tu8 control_chan;\n\t\tu8 center_chan;\n\t\tu8 bw;\n\t\tu8 tx_streams;\n\t\tu8 rx_streams_mask;\n\t\tu8 switch_reason;\n\t\tu8 band_idx;\n\t\t \n\t\tu8 center_chan2;\n\t\t__le16 cac_case;\n\t\tu8 channel_band;\n\t\tu8 rsv0;\n\t\t__le32 outband_freq;\n\t\tu8 txpower_drop;\n\t\tu8 rsv1[3];\n\t\tu8 txpower_sku[53];\n\t\tu8 rsv2[3];\n\t} req = {\n\t\t.control_chan = chandef->chan->hw_value,\n\t\t.center_chan = ieee80211_frequency_to_channel(freq1),\n\t\t.tx_streams = hweight8(phy->mt76->antenna_mask),\n\t\t.rx_streams_mask = phy->mt76->chainmask,\n\t\t.center_chan2 = ieee80211_frequency_to_channel(freq2),\n\t};\n\n\tif (cmd == MCU_EXT_CMD(SET_RX_PATH) ||\n\t    phy->mt76->hw->conf.flags & IEEE80211_CONF_MONITOR)\n\t\treq.switch_reason = CH_SWITCH_NORMAL;\n\telse if (phy->mt76->hw->conf.flags & IEEE80211_CONF_OFFCHANNEL)\n\t\treq.switch_reason = CH_SWITCH_SCAN_BYPASS_DPD;\n\telse if (!cfg80211_reg_can_beacon(phy->mt76->hw->wiphy, chandef,\n\t\t\t\t\t  NL80211_IFTYPE_AP))\n\t\treq.switch_reason = CH_SWITCH_DFS;\n\telse\n\t\treq.switch_reason = CH_SWITCH_NORMAL;\n\n\treq.band_idx = phy != &dev->phy;\n\treq.bw = mt7615_mcu_chan_bw(chandef);\n\n\tif (mt76_testmode_enabled(phy->mt76))\n\t\tmemset(req.txpower_sku, 0x3f, 49);\n\telse\n\t\tmt7615_mcu_set_txpower_sku(phy, req.txpower_sku);\n\n\treturn mt76_mcu_send_msg(&dev->mt76, cmd, &req, sizeof(req), true);\n}\n\nint mt7615_mcu_get_temperature(struct mt7615_dev *dev)\n{\n\tstruct {\n\t\tu8 action;\n\t\tu8 rsv[3];\n\t} req = {};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(THERMAL_CTRL),\n\t\t\t\t &req, sizeof(req), true);\n}\n\nint mt7615_mcu_set_test_param(struct mt7615_dev *dev, u8 param, bool test_mode,\n\t\t\t      u32 val)\n{\n\tstruct {\n\t\tu8 test_mode_en;\n\t\tu8 param_idx;\n\t\tu8 _rsv[2];\n\n\t\t__le32 value;\n\n\t\tu8 pad[8];\n\t} req = {\n\t\t.test_mode_en = test_mode,\n\t\t.param_idx = param,\n\t\t.value = cpu_to_le32(val),\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(ATE_CTRL),\n\t\t\t\t &req, sizeof(req), false);\n}\n\nint mt7615_mcu_set_sku_en(struct mt7615_phy *phy, bool enable)\n{\n\tstruct mt7615_dev *dev = phy->dev;\n\tstruct {\n\t\tu8 format_id;\n\t\tu8 sku_enable;\n\t\tu8 band_idx;\n\t\tu8 rsv;\n\t} req = {\n\t\t.format_id = 0,\n\t\t.band_idx = phy != &dev->phy,\n\t\t.sku_enable = enable,\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76,\n\t\t\t\t MCU_EXT_CMD(TX_POWER_FEATURE_CTRL),\n\t\t\t\t &req, sizeof(req), true);\n}\n\nstatic int mt7615_find_freq_idx(const u16 *freqs, int n_freqs, u16 cur)\n{\n\tint i;\n\n\tfor (i = 0; i < n_freqs; i++)\n\t\tif (cur == freqs[i])\n\t\t\treturn i;\n\n\treturn -1;\n}\n\nstatic int mt7615_dcoc_freq_idx(u16 freq, u8 bw)\n{\n\tstatic const u16 freq_list[] = {\n\t\t4980, 5805, 5905, 5190,\n\t\t5230, 5270, 5310, 5350,\n\t\t5390, 5430, 5470, 5510,\n\t\t5550, 5590, 5630, 5670,\n\t\t5710, 5755, 5795, 5835,\n\t\t5875, 5210, 5290, 5370,\n\t\t5450, 5530, 5610, 5690,\n\t\t5775, 5855\n\t};\n\tstatic const u16 freq_bw40[] = {\n\t\t5190, 5230, 5270, 5310,\n\t\t5350, 5390, 5430, 5470,\n\t\t5510, 5550, 5590, 5630,\n\t\t5670, 5710, 5755, 5795,\n\t\t5835, 5875\n\t};\n\tint offset_2g = ARRAY_SIZE(freq_list);\n\tint idx;\n\n\tif (freq < 4000) {\n\t\tif (freq < 2427)\n\t\t\treturn offset_2g;\n\t\tif (freq < 2442)\n\t\t\treturn offset_2g + 1;\n\t\tif (freq < 2457)\n\t\t\treturn offset_2g + 2;\n\n\t\treturn offset_2g + 3;\n\t}\n\n\tswitch (bw) {\n\tcase NL80211_CHAN_WIDTH_80:\n\tcase NL80211_CHAN_WIDTH_80P80:\n\tcase NL80211_CHAN_WIDTH_160:\n\t\tbreak;\n\tdefault:\n\t\tidx = mt7615_find_freq_idx(freq_bw40, ARRAY_SIZE(freq_bw40),\n\t\t\t\t\t   freq + 10);\n\t\tif (idx >= 0) {\n\t\t\tfreq = freq_bw40[idx];\n\t\t\tbreak;\n\t\t}\n\n\t\tidx = mt7615_find_freq_idx(freq_bw40, ARRAY_SIZE(freq_bw40),\n\t\t\t\t\t   freq - 10);\n\t\tif (idx >= 0) {\n\t\t\tfreq = freq_bw40[idx];\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tidx = mt7615_find_freq_idx(freq_bw40, ARRAY_SIZE(freq_bw40),\n\t\t\t\t\t   freq);\n\t\tif (idx >= 0)\n\t\t\tbreak;\n\n\t\treturn -1;\n\n\t}\n\n\treturn mt7615_find_freq_idx(freq_list, ARRAY_SIZE(freq_list), freq);\n}\n\nint mt7615_mcu_apply_rx_dcoc(struct mt7615_phy *phy)\n{\n\tstruct mt7615_dev *dev = phy->dev;\n\tstruct cfg80211_chan_def *chandef = &phy->mt76->chandef;\n\tint freq2 = chandef->center_freq2;\n\tint ret;\n\tstruct {\n\t\tu8 direction;\n\t\tu8 runtime_calibration;\n\t\tu8 _rsv[2];\n\n\t\t__le16 center_freq;\n\t\tu8 bw;\n\t\tu8 band;\n\t\tu8 is_freq2;\n\t\tu8 success;\n\t\tu8 dbdc_en;\n\n\t\tu8 _rsv2;\n\n\t\tstruct {\n\t\t\t__le32 sx0_i_lna[4];\n\t\t\t__le32 sx0_q_lna[4];\n\n\t\t\t__le32 sx2_i_lna[4];\n\t\t\t__le32 sx2_q_lna[4];\n\t\t} dcoc_data[4];\n\t} req = {\n\t\t.direction = 1,\n\n\t\t.bw = mt7615_mcu_chan_bw(chandef),\n\t\t.band = chandef->center_freq1 > 4000,\n\t\t.dbdc_en = !!dev->mt76.phys[MT_BAND1],\n\t};\n\tu16 center_freq = chandef->center_freq1;\n\tint freq_idx;\n\tu8 *eep = dev->mt76.eeprom.data;\n\n\tif (!(eep[MT_EE_CALDATA_FLASH] & MT_EE_CALDATA_FLASH_RX_CAL))\n\t\treturn 0;\n\n\tif (chandef->width == NL80211_CHAN_WIDTH_160) {\n\t\tfreq2 = center_freq + 40;\n\t\tcenter_freq -= 40;\n\t}\n\nagain:\n\treq.runtime_calibration = 1;\n\tfreq_idx = mt7615_dcoc_freq_idx(center_freq, chandef->width);\n\tif (freq_idx < 0)\n\t\tgoto out;\n\n\tmemcpy(req.dcoc_data, eep + MT7615_EEPROM_DCOC_OFFSET +\n\t\t\t      freq_idx * MT7615_EEPROM_DCOC_SIZE,\n\t       sizeof(req.dcoc_data));\n\treq.runtime_calibration = 0;\n\nout:\n\treq.center_freq = cpu_to_le16(center_freq);\n\tret = mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(RXDCOC_CAL), &req,\n\t\t\t\tsizeof(req), true);\n\n\tif ((chandef->width == NL80211_CHAN_WIDTH_80P80 ||\n\t     chandef->width == NL80211_CHAN_WIDTH_160) && !req.is_freq2) {\n\t\treq.is_freq2 = true;\n\t\tcenter_freq = freq2;\n\t\tgoto again;\n\t}\n\n\treturn ret;\n}\n\nstatic int mt7615_dpd_freq_idx(u16 freq, u8 bw)\n{\n\tstatic const u16 freq_list[] = {\n\t\t4920, 4940, 4960, 4980,\n\t\t5040, 5060, 5080, 5180,\n\t\t5200, 5220, 5240, 5260,\n\t\t5280, 5300, 5320, 5340,\n\t\t5360, 5380, 5400, 5420,\n\t\t5440, 5460, 5480, 5500,\n\t\t5520, 5540, 5560, 5580,\n\t\t5600, 5620, 5640, 5660,\n\t\t5680, 5700, 5720, 5745,\n\t\t5765, 5785, 5805, 5825,\n\t\t5845, 5865, 5885, 5905\n\t};\n\tint offset_2g = ARRAY_SIZE(freq_list);\n\tint idx;\n\n\tif (freq < 4000) {\n\t\tif (freq < 2432)\n\t\t\treturn offset_2g;\n\t\tif (freq < 2457)\n\t\t\treturn offset_2g + 1;\n\n\t\treturn offset_2g + 2;\n\t}\n\n\tif (bw != NL80211_CHAN_WIDTH_20) {\n\t\tidx = mt7615_find_freq_idx(freq_list, ARRAY_SIZE(freq_list),\n\t\t\t\t\t   freq + 10);\n\t\tif (idx >= 0)\n\t\t\treturn idx;\n\n\t\tidx = mt7615_find_freq_idx(freq_list, ARRAY_SIZE(freq_list),\n\t\t\t\t\t   freq - 10);\n\t\tif (idx >= 0)\n\t\t\treturn idx;\n\t}\n\n\treturn mt7615_find_freq_idx(freq_list, ARRAY_SIZE(freq_list), freq);\n}\n\n\nint mt7615_mcu_apply_tx_dpd(struct mt7615_phy *phy)\n{\n\tstruct mt7615_dev *dev = phy->dev;\n\tstruct cfg80211_chan_def *chandef = &phy->mt76->chandef;\n\tint freq2 = chandef->center_freq2;\n\tint ret;\n\tstruct {\n\t\tu8 direction;\n\t\tu8 runtime_calibration;\n\t\tu8 _rsv[2];\n\n\t\t__le16 center_freq;\n\t\tu8 bw;\n\t\tu8 band;\n\t\tu8 is_freq2;\n\t\tu8 success;\n\t\tu8 dbdc_en;\n\n\t\tu8 _rsv2;\n\n\t\tstruct {\n\t\t\tstruct {\n\t\t\t\tu32 dpd_g0;\n\t\t\t\tu8 data[32];\n\t\t\t} wf0, wf1;\n\n\t\t\tstruct {\n\t\t\t\tu32 dpd_g0_prim;\n\t\t\t\tu32 dpd_g0_sec;\n\t\t\t\tu8 data_prim[32];\n\t\t\t\tu8 data_sec[32];\n\t\t\t} wf2, wf3;\n\t\t} dpd_data;\n\t} req = {\n\t\t.direction = 1,\n\n\t\t.bw = mt7615_mcu_chan_bw(chandef),\n\t\t.band = chandef->center_freq1 > 4000,\n\t\t.dbdc_en = !!dev->mt76.phys[MT_BAND1],\n\t};\n\tu16 center_freq = chandef->center_freq1;\n\tint freq_idx;\n\tu8 *eep = dev->mt76.eeprom.data;\n\n\tif (!(eep[MT_EE_CALDATA_FLASH] & MT_EE_CALDATA_FLASH_TX_DPD))\n\t\treturn 0;\n\n\tif (chandef->width == NL80211_CHAN_WIDTH_160) {\n\t\tfreq2 = center_freq + 40;\n\t\tcenter_freq -= 40;\n\t}\n\nagain:\n\treq.runtime_calibration = 1;\n\tfreq_idx = mt7615_dpd_freq_idx(center_freq, chandef->width);\n\tif (freq_idx < 0)\n\t\tgoto out;\n\n\tmemcpy(&req.dpd_data, eep + MT7615_EEPROM_TXDPD_OFFSET +\n\t\t\t      freq_idx * MT7615_EEPROM_TXDPD_SIZE,\n\t       sizeof(req.dpd_data));\n\treq.runtime_calibration = 0;\n\nout:\n\treq.center_freq = cpu_to_le16(center_freq);\n\tret = mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(TXDPD_CAL),\n\t\t\t\t&req, sizeof(req), true);\n\n\tif ((chandef->width == NL80211_CHAN_WIDTH_80P80 ||\n\t     chandef->width == NL80211_CHAN_WIDTH_160) && !req.is_freq2) {\n\t\treq.is_freq2 = true;\n\t\tcenter_freq = freq2;\n\t\tgoto again;\n\t}\n\n\treturn ret;\n}\n\nint mt7615_mcu_set_rx_hdr_trans_blacklist(struct mt7615_dev *dev)\n{\n\tstruct {\n\t\tu8 operation;\n\t\tu8 count;\n\t\tu8 _rsv[2];\n\t\tu8 index;\n\t\tu8 enable;\n\t\t__le16 etype;\n\t} req = {\n\t\t.operation = 1,\n\t\t.count = 1,\n\t\t.enable = 1,\n\t\t.etype = cpu_to_le16(ETH_P_PAE),\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(RX_HDR_TRANS),\n\t\t\t\t &req, sizeof(req), false);\n}\n\nint mt7615_mcu_set_bss_pm(struct mt7615_dev *dev, struct ieee80211_vif *vif,\n\t\t\t  bool enable)\n{\n\tstruct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;\n\tstruct {\n\t\tu8 bss_idx;\n\t\tu8 dtim_period;\n\t\t__le16 aid;\n\t\t__le16 bcn_interval;\n\t\t__le16 atim_window;\n\t\tu8 uapsd;\n\t\tu8 bmc_delivered_ac;\n\t\tu8 bmc_triggered_ac;\n\t\tu8 pad;\n\t} req = {\n\t\t.bss_idx = mvif->mt76.idx,\n\t\t.aid = cpu_to_le16(vif->cfg.aid),\n\t\t.dtim_period = vif->bss_conf.dtim_period,\n\t\t.bcn_interval = cpu_to_le16(vif->bss_conf.beacon_int),\n\t};\n\tstruct {\n\t\tu8 bss_idx;\n\t\tu8 pad[3];\n\t} req_hdr = {\n\t\t.bss_idx = mvif->mt76.idx,\n\t};\n\tint err;\n\n\tif (vif->type != NL80211_IFTYPE_STATION)\n\t\treturn 0;\n\n\terr = mt76_mcu_send_msg(&dev->mt76, MCU_CE_CMD(SET_BSS_ABORT),\n\t\t\t\t&req_hdr, sizeof(req_hdr), false);\n\tif (err < 0 || !enable)\n\t\treturn err;\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_CE_CMD(SET_BSS_CONNECTED),\n\t\t\t\t &req, sizeof(req), false);\n}\n\nint mt7615_mcu_set_roc(struct mt7615_phy *phy, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_channel *chan, int duration)\n{\n\tstruct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;\n\tstruct mt7615_dev *dev = phy->dev;\n\tstruct mt7615_roc_tlv req = {\n\t\t.bss_idx = mvif->mt76.idx,\n\t\t.active = !chan,\n\t\t.max_interval = cpu_to_le32(duration),\n\t\t.primary_chan = chan ? chan->hw_value : 0,\n\t\t.band = chan ? chan->band : 0,\n\t\t.req_type = 2,\n\t};\n\n\tphy->roc_grant = false;\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_CE_CMD(SET_ROC),\n\t\t\t\t &req, sizeof(req), false);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}