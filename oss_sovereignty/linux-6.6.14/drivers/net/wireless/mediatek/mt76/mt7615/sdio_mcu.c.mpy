{
  "module_name": "sdio_mcu.c",
  "hash_id": "9a81524afaa60841dc7a344756fcf392ed73d9b1efe6c51b3e28248164ddb4c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7615/sdio_mcu.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/mmc/sdio_func.h>\n#include <linux/module.h>\n#include <linux/iopoll.h>\n\n#include \"../sdio.h\"\n#include \"mt7615.h\"\n#include \"mac.h\"\n#include \"mcu.h\"\n#include \"regs.h\"\n\nstatic int mt7663s_mcu_init_sched(struct mt7615_dev *dev)\n{\n\tstruct mt76_sdio *sdio = &dev->mt76.sdio;\n\tu32 txdwcnt;\n\n\tsdio->sched.pse_data_quota = mt76_get_field(dev, MT_PSE_PG_HIF0_GROUP,\n\t\t\t\t\t\t    MT_HIF0_MIN_QUOTA);\n\tsdio->sched.pse_mcu_quota = mt76_get_field(dev, MT_PSE_PG_HIF1_GROUP,\n\t\t\t\t\t\t   MT_HIF1_MIN_QUOTA);\n\tsdio->sched.ple_data_quota = mt76_get_field(dev, MT_PLE_PG_HIF0_GROUP,\n\t\t\t\t\t\t    MT_HIF0_MIN_QUOTA);\n\tsdio->sched.pse_page_size = MT_PSE_PAGE_SZ;\n\ttxdwcnt = mt76_get_field(dev, MT_PP_TXDWCNT,\n\t\t\t\t MT_PP_TXDWCNT_TX1_ADD_DW_CNT);\n\tsdio->sched.deficit = txdwcnt << 2;\n\n\treturn 0;\n}\n\nstatic int\nmt7663s_mcu_send_message(struct mt76_dev *mdev, struct sk_buff *skb,\n\t\t\t int cmd, int *seq)\n{\n\tstruct mt7615_dev *dev = container_of(mdev, struct mt7615_dev, mt76);\n\tint ret;\n\n\tmt7615_mcu_fill_msg(dev, skb, cmd, seq);\n\tret = mt76_tx_queue_skb_raw(dev, mdev->q_mcu[MT_MCUQ_WM], skb, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tmt76_queue_kick(dev, mdev->q_mcu[MT_MCUQ_WM]);\n\n\treturn ret;\n}\n\nstatic int __mt7663s_mcu_drv_pmctrl(struct mt7615_dev *dev)\n{\n\tstruct sdio_func *func = dev->mt76.sdio.func;\n\tstruct mt76_phy *mphy = &dev->mt76.phy;\n\tstruct mt76_connac_pm *pm = &dev->pm;\n\tu32 status;\n\tint ret;\n\n\tsdio_claim_host(func);\n\n\tsdio_writel(func, WHLPCR_FW_OWN_REQ_CLR, MCR_WHLPCR, NULL);\n\n\tret = readx_poll_timeout(mt76s_read_pcr, &dev->mt76, status,\n\t\t\t\t status & WHLPCR_IS_DRIVER_OWN, 2000, 1000000);\n\tif (ret < 0) {\n\t\tdev_err(dev->mt76.dev, \"Cannot get ownership from device\");\n\t} else {\n\t\tclear_bit(MT76_STATE_PM, &mphy->state);\n\n\t\tpm->stats.last_wake_event = jiffies;\n\t\tpm->stats.doze_time += pm->stats.last_wake_event -\n\t\t\t\t       pm->stats.last_doze_event;\n\t}\n\tsdio_release_host(func);\n\n\treturn ret;\n}\n\nstatic int mt7663s_mcu_drv_pmctrl(struct mt7615_dev *dev)\n{\n\tstruct mt76_phy *mphy = &dev->mt76.phy;\n\tint ret = 0;\n\n\tmutex_lock(&dev->pm.mutex);\n\n\tif (test_bit(MT76_STATE_PM, &mphy->state))\n\t\tret = __mt7663s_mcu_drv_pmctrl(dev);\n\n\tmutex_unlock(&dev->pm.mutex);\n\n\treturn ret;\n}\n\nstatic int mt7663s_mcu_fw_pmctrl(struct mt7615_dev *dev)\n{\n\tstruct sdio_func *func = dev->mt76.sdio.func;\n\tstruct mt76_phy *mphy = &dev->mt76.phy;\n\tstruct mt76_connac_pm *pm = &dev->pm;\n\tint ret = 0;\n\tu32 status;\n\n\tmutex_lock(&pm->mutex);\n\n\tif (mt76_connac_skip_fw_pmctrl(mphy, pm))\n\t\tgoto out;\n\n\tsdio_claim_host(func);\n\n\tsdio_writel(func, WHLPCR_FW_OWN_REQ_SET, MCR_WHLPCR, NULL);\n\n\tret = readx_poll_timeout(mt76s_read_pcr, &dev->mt76, status,\n\t\t\t\t !(status & WHLPCR_IS_DRIVER_OWN), 2000, 1000000);\n\tif (ret < 0) {\n\t\tdev_err(dev->mt76.dev, \"Cannot set ownership to device\");\n\t\tclear_bit(MT76_STATE_PM, &mphy->state);\n\t} else {\n\t\tpm->stats.last_doze_event = jiffies;\n\t\tpm->stats.awake_time += pm->stats.last_doze_event -\n\t\t\t\t\tpm->stats.last_wake_event;\n\t}\n\n\tsdio_release_host(func);\nout:\n\tmutex_unlock(&pm->mutex);\n\n\treturn ret;\n}\n\nint mt7663s_mcu_init(struct mt7615_dev *dev)\n{\n\tstatic const struct mt76_mcu_ops mt7663s_mcu_ops = {\n\t\t.headroom = sizeof(struct mt7615_mcu_txd),\n\t\t.tailroom = MT_USB_TAIL_SIZE,\n\t\t.mcu_skb_send_msg = mt7663s_mcu_send_message,\n\t\t.mcu_parse_response = mt7615_mcu_parse_response,\n\t\t.mcu_rr = mt76_connac_mcu_reg_rr,\n\t\t.mcu_wr = mt76_connac_mcu_reg_wr,\n\t};\n\tstruct mt7615_mcu_ops *mcu_ops;\n\tint ret;\n\n\tret = __mt7663s_mcu_drv_pmctrl(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->mt76.mcu_ops = &mt7663s_mcu_ops,\n\n\tret = mt76_get_field(dev, MT_CONN_ON_MISC, MT_TOP_MISC2_FW_N9_RDY);\n\tif (ret) {\n\t\tmt7615_mcu_restart(&dev->mt76);\n\t\tif (!mt76_poll_msec(dev, MT_CONN_ON_MISC,\n\t\t\t\t    MT_TOP_MISC2_FW_N9_RDY, 0, 500))\n\t\t\treturn -EIO;\n\t}\n\n\tret = __mt7663_load_firmware(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmcu_ops = devm_kmemdup(dev->mt76.dev, dev->mcu_ops, sizeof(*mcu_ops),\n\t\t\t       GFP_KERNEL);\n\tif (!mcu_ops)\n\t\treturn -ENOMEM;\n\n\tmcu_ops->set_drv_ctrl = mt7663s_mcu_drv_pmctrl;\n\tmcu_ops->set_fw_ctrl = mt7663s_mcu_fw_pmctrl;\n\tdev->mcu_ops = mcu_ops;\n\n\tret = mt7663s_mcu_init_sched(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tset_bit(MT76_STATE_MCU_RUNNING, &dev->mphy.state);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}