{
  "module_name": "usb_sdio.c",
  "hash_id": "6931923f3c9d530ad361d387b3492ce003f105480fd9f933364482d1ac6557fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7615/usb_sdio.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n\n#include \"mt7615.h\"\n#include \"mac.h\"\n#include \"mcu.h\"\n#include \"regs.h\"\n\nconst u32 mt7663_usb_sdio_reg_map[] = {\n\t[MT_TOP_CFG_BASE]\t= 0x80020000,\n\t[MT_HW_BASE]\t\t= 0x80000000,\n\t[MT_DMA_SHDL_BASE]\t= 0x5000a000,\n\t[MT_HIF_BASE]\t\t= 0x50000000,\n\t[MT_CSR_BASE]\t\t= 0x40000000,\n\t[MT_EFUSE_ADDR_BASE]\t= 0x78011000,\n\t[MT_TOP_MISC_BASE]\t= 0x81020000,\n\t[MT_PLE_BASE]\t\t= 0x82060000,\n\t[MT_PSE_BASE]\t\t= 0x82068000,\n\t[MT_PP_BASE]\t\t= 0x8206c000,\n\t[MT_WTBL_BASE_ADDR]\t= 0x820e0000,\n\t[MT_CFG_BASE]\t\t= 0x820f0000,\n\t[MT_AGG_BASE]\t\t= 0x820f2000,\n\t[MT_ARB_BASE]\t\t= 0x820f3000,\n\t[MT_TMAC_BASE]\t\t= 0x820f4000,\n\t[MT_RMAC_BASE]\t\t= 0x820f5000,\n\t[MT_DMA_BASE]\t\t= 0x820f7000,\n\t[MT_PF_BASE]\t\t= 0x820f8000,\n\t[MT_WTBL_BASE_ON]\t= 0x820f9000,\n\t[MT_WTBL_BASE_OFF]\t= 0x820f9800,\n\t[MT_LPON_BASE]\t\t= 0x820fb000,\n\t[MT_MIB_BASE]\t\t= 0x820fd000,\n};\nEXPORT_SYMBOL_GPL(mt7663_usb_sdio_reg_map);\n\nstatic void\nmt7663_usb_sdio_write_txwi(struct mt7615_dev *dev, struct mt76_wcid *wcid,\n\t\t\t   enum mt76_txq_id qid, struct ieee80211_sta *sta,\n\t\t\t   struct ieee80211_key_conf *key, int pid,\n\t\t\t   struct sk_buff *skb)\n{\n\t__le32 *txwi = (__le32 *)(skb->data - MT_USB_TXD_SIZE);\n\n\tmemset(txwi, 0, MT_USB_TXD_SIZE);\n\tmt7615_mac_write_txwi(dev, txwi, skb, wcid, sta, pid, key, qid, false);\n\tskb_push(skb, MT_USB_TXD_SIZE);\n}\n\nstatic int mt7663_usb_sdio_set_rates(struct mt7615_dev *dev,\n\t\t\t\t     struct mt7615_wtbl_rate_desc *wrd)\n{\n\tstruct mt7615_rate_desc *rate = &wrd->rate;\n\tstruct mt7615_sta *sta = wrd->sta;\n\tu32 w5, w27, addr, val;\n\tu16 idx;\n\n\tlockdep_assert_held(&dev->mt76.mutex);\n\n\tif (!sta)\n\t\treturn -EINVAL;\n\n\tif (!mt76_poll(dev, MT_WTBL_UPDATE, MT_WTBL_UPDATE_BUSY, 0, 5000))\n\t\treturn -ETIMEDOUT;\n\n\taddr = mt7615_mac_wtbl_addr(dev, sta->wcid.idx);\n\n\tw27 = mt76_rr(dev, addr + 27 * 4);\n\tw27 &= ~MT_WTBL_W27_CC_BW_SEL;\n\tw27 |= FIELD_PREP(MT_WTBL_W27_CC_BW_SEL, rate->bw);\n\n\tw5 = mt76_rr(dev, addr + 5 * 4);\n\tw5 &= ~(MT_WTBL_W5_BW_CAP | MT_WTBL_W5_CHANGE_BW_RATE |\n\t\tMT_WTBL_W5_MPDU_OK_COUNT |\n\t\tMT_WTBL_W5_MPDU_FAIL_COUNT |\n\t\tMT_WTBL_W5_RATE_IDX);\n\tw5 |= FIELD_PREP(MT_WTBL_W5_BW_CAP, rate->bw) |\n\t      FIELD_PREP(MT_WTBL_W5_CHANGE_BW_RATE,\n\t\t\t rate->bw_idx ? rate->bw_idx - 1 : 7);\n\n\tmt76_wr(dev, MT_WTBL_RIUCR0, w5);\n\n\tmt76_wr(dev, MT_WTBL_RIUCR1,\n\t\tFIELD_PREP(MT_WTBL_RIUCR1_RATE0, rate->probe_val) |\n\t\tFIELD_PREP(MT_WTBL_RIUCR1_RATE1, rate->val[0]) |\n\t\tFIELD_PREP(MT_WTBL_RIUCR1_RATE2_LO, rate->val[1]));\n\n\tmt76_wr(dev, MT_WTBL_RIUCR2,\n\t\tFIELD_PREP(MT_WTBL_RIUCR2_RATE2_HI, rate->val[1] >> 8) |\n\t\tFIELD_PREP(MT_WTBL_RIUCR2_RATE3, rate->val[1]) |\n\t\tFIELD_PREP(MT_WTBL_RIUCR2_RATE4, rate->val[2]) |\n\t\tFIELD_PREP(MT_WTBL_RIUCR2_RATE5_LO, rate->val[2]));\n\n\tmt76_wr(dev, MT_WTBL_RIUCR3,\n\t\tFIELD_PREP(MT_WTBL_RIUCR3_RATE5_HI, rate->val[2] >> 4) |\n\t\tFIELD_PREP(MT_WTBL_RIUCR3_RATE6, rate->val[3]) |\n\t\tFIELD_PREP(MT_WTBL_RIUCR3_RATE7, rate->val[3]));\n\n\tmt76_wr(dev, MT_WTBL_UPDATE,\n\t\tFIELD_PREP(MT_WTBL_UPDATE_WLAN_IDX, sta->wcid.idx) |\n\t\tMT_WTBL_UPDATE_RATE_UPDATE |\n\t\tMT_WTBL_UPDATE_TX_COUNT_CLEAR);\n\n\tmt76_wr(dev, addr + 27 * 4, w27);\n\n\tsta->rate_probe = sta->rateset[rate->rateset].probe_rate.idx != -1;\n\n\tidx = sta->vif->mt76.omac_idx;\n\tidx = idx > HW_BSSID_MAX ? HW_BSSID_0 : idx;\n\taddr = idx > 1 ? MT_LPON_TCR2(idx): MT_LPON_TCR0(idx);\n\n\tmt76_rmw(dev, addr, MT_LPON_TCR_MODE, MT_LPON_TCR_READ);  \n\tval = mt76_rr(dev, MT_LPON_UTTR0);\n\tsta->rate_set_tsf = (val & ~BIT(0)) | rate->rateset;\n\n\tif (!(sta->wcid.tx_info & MT_WCID_TX_INFO_SET))\n\t\tmt76_poll(dev, MT_WTBL_UPDATE, MT_WTBL_UPDATE_BUSY, 0, 5000);\n\n\tsta->rate_count = 2 * MT7615_RATE_RETRY * sta->n_rates;\n\tsta->wcid.tx_info |= MT_WCID_TX_INFO_SET;\n\n\treturn 0;\n}\n\nstatic void mt7663_usb_sdio_rate_work(struct work_struct *work)\n{\n\tstruct mt7615_wtbl_rate_desc *wrd, *wrd_next;\n\tstruct list_head wrd_list;\n\tstruct mt7615_dev *dev;\n\n\tdev = (struct mt7615_dev *)container_of(work, struct mt7615_dev,\n\t\t\t\t\t\trate_work);\n\n\tINIT_LIST_HEAD(&wrd_list);\n\tspin_lock_bh(&dev->mt76.lock);\n\tlist_splice_init(&dev->wrd_head, &wrd_list);\n\tspin_unlock_bh(&dev->mt76.lock);\n\n\tlist_for_each_entry_safe(wrd, wrd_next, &wrd_list, node) {\n\t\tlist_del(&wrd->node);\n\n\t\tmt7615_mutex_acquire(dev);\n\t\tmt7663_usb_sdio_set_rates(dev, wrd);\n\t\tmt7615_mutex_release(dev);\n\n\t\tkfree(wrd);\n\t}\n}\n\nbool mt7663_usb_sdio_tx_status_data(struct mt76_dev *mdev, u8 *update)\n{\n\tstruct mt7615_dev *dev = container_of(mdev, struct mt7615_dev, mt76);\n\n\tmt7615_mutex_acquire(dev);\n\tmt7615_mac_sta_poll(dev);\n\tmt7615_mutex_release(dev);\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(mt7663_usb_sdio_tx_status_data);\n\nvoid mt7663_usb_sdio_tx_complete_skb(struct mt76_dev *mdev,\n\t\t\t\t     struct mt76_queue_entry *e)\n{\n\tunsigned int headroom = MT_USB_TXD_SIZE;\n\n\tif (mt76_is_usb(mdev))\n\t\theadroom += MT_USB_HDR_SIZE;\n\tskb_pull(e->skb, headroom);\n\n\tmt76_tx_complete_skb(mdev, e->wcid, e->skb);\n}\nEXPORT_SYMBOL_GPL(mt7663_usb_sdio_tx_complete_skb);\n\nint mt7663_usb_sdio_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,\n\t\t\t\t   enum mt76_txq_id qid, struct mt76_wcid *wcid,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   struct mt76_tx_info *tx_info)\n{\n\tstruct mt7615_dev *dev = container_of(mdev, struct mt7615_dev, mt76);\n\tstruct sk_buff *skb = tx_info->skb;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_key_conf *key = info->control.hw_key;\n\tstruct mt7615_sta *msta;\n\tint pad, err, pktid;\n\n\tmsta = wcid ? container_of(wcid, struct mt7615_sta, wcid) : NULL;\n\tif (!wcid)\n\t\twcid = &dev->mt76.global_wcid;\n\n\tif ((info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE) &&\n\t    msta && !msta->rate_probe) {\n\t\t \n\t\tspin_lock_bh(&dev->mt76.lock);\n\t\tmt7615_mac_set_rates(&dev->phy, msta, &info->control.rates[0],\n\t\t\t\t     msta->rates);\n\t\tspin_unlock_bh(&dev->mt76.lock);\n\t}\n\n\tpktid = mt76_tx_status_skb_add(&dev->mt76, wcid, skb);\n\tmt7663_usb_sdio_write_txwi(dev, wcid, qid, sta, key, pktid, skb);\n\tif (mt76_is_usb(mdev)) {\n\t\tu32 len = skb->len;\n\n\t\tput_unaligned_le32(len, skb_push(skb, sizeof(len)));\n\t\tpad = round_up(skb->len, 4) + 4 - skb->len;\n\t} else {\n\t\tpad = round_up(skb->len, 4) - skb->len;\n\t}\n\n\terr = mt76_skb_adjust_pad(skb, pad);\n\tif (err)\n\t\t \n\t\tidr_remove(&wcid->pktid, pktid);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mt7663_usb_sdio_tx_prepare_skb);\n\nstatic int mt7663u_dma_sched_init(struct mt7615_dev *dev)\n{\n\tint i;\n\n\tmt76_rmw(dev, MT_DMA_SHDL(MT_DMASHDL_PKT_MAX_SIZE),\n\t\t MT_DMASHDL_PKT_MAX_SIZE_PLE | MT_DMASHDL_PKT_MAX_SIZE_PSE,\n\t\t FIELD_PREP(MT_DMASHDL_PKT_MAX_SIZE_PLE, 1) |\n\t\t FIELD_PREP(MT_DMASHDL_PKT_MAX_SIZE_PSE, 8));\n\n\t \n\tmt76_wr(dev, MT_DMA_SHDL(MT_DMASHDL_REFILL), 0xffe00006);\n\tmt76_clear(dev, MT_DMA_SHDL(MT_DMASHDL_PAGE), BIT(16));\n\n\tfor (i = 0; i < 5; i++)\n\t\tmt76_wr(dev, MT_DMA_SHDL(MT_DMASHDL_GROUP_QUOTA(i)),\n\t\t\tFIELD_PREP(MT_DMASHDL_GROUP_QUOTA_MIN, 0x3) |\n\t\t\tFIELD_PREP(MT_DMASHDL_GROUP_QUOTA_MAX, 0x1ff));\n\n\tmt76_wr(dev, MT_DMA_SHDL(MT_DMASHDL_Q_MAP(0)), 0x42104210);\n\tmt76_wr(dev, MT_DMA_SHDL(MT_DMASHDL_Q_MAP(1)), 0x42104210);\n\n\tmt76_wr(dev, MT_DMA_SHDL(MT_DMASHDL_Q_MAP(2)), 0x4444);\n\n\t \n\tmt76_wr(dev, MT_DMA_SHDL(MT_DMASHDL_SCHED_SET0), 0x6501234f);\n\tmt76_wr(dev, MT_DMA_SHDL(MT_DMASHDL_SCHED_SET1), 0xedcba987);\n\tmt76_wr(dev, MT_DMA_SHDL(MT_DMASHDL_OPTIONAL), 0x7004801c);\n\n\tmt76_wr(dev, MT_UDMA_WLCFG_1,\n\t\tFIELD_PREP(MT_WL_TX_TMOUT_LMT, 80000) |\n\t\tFIELD_PREP(MT_WL_RX_AGG_PKT_LMT, 1));\n\n\t \n\tmt76_clear(dev, MT_UDMA_WLCFG_0, MT_WL_RX_FLUSH);\n\t \n\tmt76_set(dev, MT_HIF_RST, MT_HIF_LOGIC_RST_N);\n\n\tmt76_set(dev, MT_UDMA_WLCFG_0,\n\t\t MT_WL_RX_AGG_EN | MT_WL_RX_EN | MT_WL_TX_EN |\n\t\t MT_WL_RX_MPSZ_PAD0 | MT_TICK_1US_EN |\n\t\t MT_WL_TX_TMOUT_FUNC_EN);\n\tmt76_rmw(dev, MT_UDMA_WLCFG_0, MT_WL_RX_AGG_LMT | MT_WL_RX_AGG_TO,\n\t\t FIELD_PREP(MT_WL_RX_AGG_LMT, 32) |\n\t\t FIELD_PREP(MT_WL_RX_AGG_TO, 100));\n\n\treturn 0;\n}\n\nstatic int mt7663_usb_sdio_init_hardware(struct mt7615_dev *dev)\n{\n\tint ret, idx;\n\n\tret = mt7615_eeprom_init(dev, MT_EFUSE_BASE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (mt76_is_usb(&dev->mt76)) {\n\t\tret = mt7663u_dma_sched_init(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tset_bit(MT76_STATE_INITIALIZED, &dev->mphy.state);\n\n\t \n\tidx = mt76_wcid_alloc(dev->mt76.wcid_mask, MT7615_WTBL_STA - 1);\n\tif (idx)\n\t\treturn -ENOSPC;\n\n\tdev->mt76.global_wcid.idx = idx;\n\tdev->mt76.global_wcid.hw_key_idx = -1;\n\trcu_assign_pointer(dev->mt76.wcid[idx], &dev->mt76.global_wcid);\n\n\treturn 0;\n}\n\nint mt7663_usb_sdio_register_device(struct mt7615_dev *dev)\n{\n\tstruct ieee80211_hw *hw = mt76_hw(dev);\n\tint err;\n\n\tINIT_WORK(&dev->rate_work, mt7663_usb_sdio_rate_work);\n\tINIT_LIST_HEAD(&dev->wrd_head);\n\tmt7615_init_device(dev);\n\n\terr = mt7663_usb_sdio_init_hardware(dev);\n\tif (err)\n\t\treturn err;\n\n\thw->extra_tx_headroom += MT_USB_TXD_SIZE;\n\tif (mt76_is_usb(&dev->mt76)) {\n\t\thw->extra_tx_headroom += MT_USB_HDR_SIZE;\n\t\t \n\t\tif (dev->mt76.usb.sg_en)\n\t\t\thw->max_tx_fragments = MT_HW_TXP_MAX_BUF_NUM;\n\t\telse\n\t\t\thw->max_tx_fragments = 1;\n\t}\n\n\terr = mt76_register_device(&dev->mt76, true, mt76_rates,\n\t\t\t\t   ARRAY_SIZE(mt76_rates));\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!dev->mt76.usb.sg_en) {\n\t\tstruct ieee80211_sta_vht_cap *vht_cap;\n\n\t\t \n\t\tvht_cap = &dev->mphy.sband_5g.sband.vht_cap;\n\t\tvht_cap->cap &= ~IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454;\n\t}\n\n\tieee80211_queue_work(hw, &dev->mcu_work);\n\tmt7615_init_txpower(dev, &dev->mphy.sband_2g.sband);\n\tmt7615_init_txpower(dev, &dev->mphy.sband_5g.sband);\n\n\treturn mt7615_init_debugfs(dev);\n}\nEXPORT_SYMBOL_GPL(mt7663_usb_sdio_register_device);\n\nMODULE_AUTHOR(\"Lorenzo Bianconi <lorenzo@kernel.org>\");\nMODULE_AUTHOR(\"Sean Wang <sean.wang@mediatek.com>\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}