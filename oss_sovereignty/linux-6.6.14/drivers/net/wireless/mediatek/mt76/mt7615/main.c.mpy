{
  "module_name": "main.c",
  "hash_id": "16b8df7c772157177f0b5d7b07beca3e97bb69b22e17cefeca2cf59a33546ba4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7615/main.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/module.h>\n#include \"mt7615.h\"\n#include \"mcu.h\"\n\nstatic bool mt7615_dev_running(struct mt7615_dev *dev)\n{\n\tstruct mt7615_phy *phy;\n\n\tif (test_bit(MT76_STATE_RUNNING, &dev->mphy.state))\n\t\treturn true;\n\n\tphy = mt7615_ext_phy(dev);\n\n\treturn phy && test_bit(MT76_STATE_RUNNING, &phy->mt76->state);\n}\n\nstatic int mt7615_start(struct ieee80211_hw *hw)\n{\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tstruct mt7615_phy *phy = mt7615_hw_phy(hw);\n\tunsigned long timeout;\n\tbool running;\n\tint ret;\n\n\tif (!mt7615_wait_for_mcu_init(dev))\n\t\treturn -EIO;\n\n\tmt7615_mutex_acquire(dev);\n\n\trunning = mt7615_dev_running(dev);\n\n\tif (!running) {\n\t\tret = mt7615_mcu_set_pm(dev, 0, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = mt76_connac_mcu_set_mac_enable(&dev->mt76, 0, true, false);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tmt7615_mac_enable_nf(dev, 0);\n\t}\n\n\tif (phy != &dev->phy) {\n\t\tret = mt7615_mcu_set_pm(dev, 1, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = mt76_connac_mcu_set_mac_enable(&dev->mt76, 1, true, false);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tmt7615_mac_enable_nf(dev, 1);\n\t}\n\n\tif (mt7615_firmware_offload(dev)) {\n\t\tret = mt76_connac_mcu_set_channel_domain(phy->mt76);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = mt76_connac_mcu_set_rate_txpower(phy->mt76);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = mt7615_mcu_set_chan_info(phy, MCU_EXT_CMD(SET_RX_PATH));\n\tif (ret)\n\t\tgoto out;\n\n\tset_bit(MT76_STATE_RUNNING, &phy->mt76->state);\n\n\ttimeout = mt7615_get_macwork_timeout(dev);\n\tieee80211_queue_delayed_work(hw, &phy->mt76->mac_work, timeout);\n\n\tif (!running)\n\t\tmt7615_mac_reset_counters(phy);\n\nout:\n\tmt7615_mutex_release(dev);\n\n\treturn ret;\n}\n\nstatic void mt7615_stop(struct ieee80211_hw *hw)\n{\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tstruct mt7615_phy *phy = mt7615_hw_phy(hw);\n\n\tcancel_delayed_work_sync(&phy->mt76->mac_work);\n\tdel_timer_sync(&phy->roc_timer);\n\tcancel_work_sync(&phy->roc_work);\n\n\tcancel_delayed_work_sync(&dev->pm.ps_work);\n\tcancel_work_sync(&dev->pm.wake_work);\n\n\tmt76_connac_free_pending_tx_skbs(&dev->pm, NULL);\n\n\tmt7615_mutex_acquire(dev);\n\n\tmt76_testmode_reset(phy->mt76, true);\n\n\tclear_bit(MT76_STATE_RUNNING, &phy->mt76->state);\n\tcancel_delayed_work_sync(&phy->scan_work);\n\n\tif (phy != &dev->phy) {\n\t\tmt7615_mcu_set_pm(dev, 1, 1);\n\t\tmt76_connac_mcu_set_mac_enable(&dev->mt76, 1, false, false);\n\t}\n\n\tif (!mt7615_dev_running(dev)) {\n\t\tmt7615_mcu_set_pm(dev, 0, 1);\n\t\tmt76_connac_mcu_set_mac_enable(&dev->mt76, 0, false, false);\n\t}\n\n\tmt7615_mutex_release(dev);\n}\n\nstatic inline int get_free_idx(u32 mask, u8 start, u8 end)\n{\n\treturn ffs(~mask & GENMASK(end, start));\n}\n\nstatic int get_omac_idx(enum nl80211_iftype type, u64 mask)\n{\n\tint i;\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\t \n\t\ti = get_free_idx(mask, HW_BSSID_1, HW_BSSID_3);\n\t\tif (i)\n\t\t\treturn i - 1;\n\n\t\t \n\t\ti = get_free_idx(mask >> REPEATER_BSSID_START, 0,\n\t\t\t\t REPEATER_BSSID_MAX - REPEATER_BSSID_START);\n\t\tif (i)\n\t\t\treturn i + 32 - 1;\n\n\t\ti = get_free_idx(mask, EXT_BSSID_1, EXT_BSSID_MAX);\n\t\tif (i)\n\t\t\treturn i - 1;\n\n\t\tif (~mask & BIT(HW_BSSID_0))\n\t\t\treturn HW_BSSID_0;\n\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_AP:\n\t\t \n\t\tif (~mask & BIT(HW_BSSID_0))\n\t\t\treturn HW_BSSID_0;\n\n\t\ti = get_free_idx(mask, EXT_BSSID_1, EXT_BSSID_MAX);\n\t\tif (i)\n\t\t\treturn i - 1;\n\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\treturn -1;\n}\n\nstatic int mt7615_add_interface(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tstruct mt7615_phy *phy = mt7615_hw_phy(hw);\n\tstruct mt76_txq *mtxq;\n\tbool ext_phy = phy != &dev->phy;\n\tint idx, ret = 0;\n\n\tmt7615_mutex_acquire(dev);\n\n\tmt76_testmode_reset(phy->mt76, true);\n\n\tif (vif->type == NL80211_IFTYPE_MONITOR &&\n\t    is_zero_ether_addr(vif->addr))\n\t\tphy->monitor_vif = vif;\n\n\tmvif->mt76.idx = __ffs64(~dev->mt76.vif_mask);\n\tif (mvif->mt76.idx >= MT7615_MAX_INTERFACES) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tidx = get_omac_idx(vif->type, dev->omac_mask);\n\tif (idx < 0) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\tmvif->mt76.omac_idx = idx;\n\n\tmvif->mt76.band_idx = ext_phy;\n\tmvif->mt76.wmm_idx = vif->type != NL80211_IFTYPE_AP;\n\tif (ext_phy)\n\t\tmvif->mt76.wmm_idx += 2;\n\n\tdev->mt76.vif_mask |= BIT_ULL(mvif->mt76.idx);\n\tdev->omac_mask |= BIT_ULL(mvif->mt76.omac_idx);\n\tphy->omac_mask |= BIT_ULL(mvif->mt76.omac_idx);\n\n\tret = mt7615_mcu_set_dbdc(dev);\n\tif (ret)\n\t\tgoto out;\n\n\tidx = MT7615_WTBL_RESERVED - mvif->mt76.idx;\n\n\tINIT_LIST_HEAD(&mvif->sta.wcid.poll_list);\n\tmvif->sta.wcid.idx = idx;\n\tmvif->sta.wcid.phy_idx = mvif->mt76.band_idx;\n\tmvif->sta.wcid.hw_key_idx = -1;\n\tmt76_packet_id_init(&mvif->sta.wcid);\n\n\tmt7615_mac_wtbl_update(dev, idx,\n\t\t\t       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);\n\n\trcu_assign_pointer(dev->mt76.wcid[idx], &mvif->sta.wcid);\n\tif (vif->txq) {\n\t\tmtxq = (struct mt76_txq *)vif->txq->drv_priv;\n\t\tmtxq->wcid = idx;\n\t}\n\n\tret = mt7615_mcu_add_dev_info(phy, vif, true);\nout:\n\tmt7615_mutex_release(dev);\n\n\treturn ret;\n}\n\nstatic void mt7615_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;\n\tstruct mt7615_sta *msta = &mvif->sta;\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tstruct mt7615_phy *phy = mt7615_hw_phy(hw);\n\tint idx = msta->wcid.idx;\n\n\tmt7615_mutex_acquire(dev);\n\n\tmt7615_mcu_add_bss_info(phy, vif, NULL, false);\n\tmt7615_mcu_sta_add(phy, vif, NULL, false);\n\n\tmt76_testmode_reset(phy->mt76, true);\n\tif (vif == phy->monitor_vif)\n\t    phy->monitor_vif = NULL;\n\n\tmt76_connac_free_pending_tx_skbs(&dev->pm, &msta->wcid);\n\n\tmt7615_mcu_add_dev_info(phy, vif, false);\n\n\trcu_assign_pointer(dev->mt76.wcid[idx], NULL);\n\n\tdev->mt76.vif_mask &= ~BIT_ULL(mvif->mt76.idx);\n\tdev->omac_mask &= ~BIT_ULL(mvif->mt76.omac_idx);\n\tphy->omac_mask &= ~BIT_ULL(mvif->mt76.omac_idx);\n\n\tmt7615_mutex_release(dev);\n\n\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\tif (!list_empty(&msta->wcid.poll_list))\n\t\tlist_del_init(&msta->wcid.poll_list);\n\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\n\tmt76_packet_id_flush(&dev->mt76, &mvif->sta.wcid);\n}\n\nint mt7615_set_channel(struct mt7615_phy *phy)\n{\n\tstruct mt7615_dev *dev = phy->dev;\n\tbool ext_phy = phy != &dev->phy;\n\tint ret;\n\n\tcancel_delayed_work_sync(&phy->mt76->mac_work);\n\n\tmt7615_mutex_acquire(dev);\n\n\tset_bit(MT76_RESET, &phy->mt76->state);\n\n\tmt76_set_channel(phy->mt76);\n\n\tif (is_mt7615(&dev->mt76) && dev->flash_eeprom) {\n\t\tret = mt7615_mcu_apply_rx_dcoc(phy);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = mt7615_mcu_apply_tx_dpd(phy);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = mt7615_mcu_set_chan_info(phy, MCU_EXT_CMD(CHANNEL_SWITCH));\n\tif (ret)\n\t\tgoto out;\n\n\tmt7615_mac_set_timing(phy);\n\tret = mt7615_dfs_init_radar_detector(phy);\n\tif (ret)\n\t\tgoto out;\n\n\tmt7615_mac_cca_stats_reset(phy);\n\tret = mt7615_mcu_set_sku_en(phy, true);\n\tif (ret)\n\t\tgoto out;\n\n\tmt7615_mac_reset_counters(phy);\n\tphy->noise = 0;\n\tphy->chfreq = mt76_rr(dev, MT_CHFREQ(ext_phy));\n\nout:\n\tclear_bit(MT76_RESET, &phy->mt76->state);\n\n\tmt7615_mutex_release(dev);\n\n\tmt76_worker_schedule(&dev->mt76.tx_worker);\n\tif (!mt76_testmode_enabled(phy->mt76)) {\n\t\tunsigned long timeout = mt7615_get_macwork_timeout(dev);\n\n\t\tieee80211_queue_delayed_work(phy->mt76->hw,\n\t\t\t\t\t     &phy->mt76->mac_work, timeout);\n\t}\n\n\treturn ret;\n}\n\nstatic int mt7615_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t\t  struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t\t  struct ieee80211_key_conf *key)\n{\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tstruct mt7615_phy *phy = mt7615_hw_phy(hw);\n\tstruct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;\n\tstruct mt7615_sta *msta = sta ? (struct mt7615_sta *)sta->drv_priv :\n\t\t\t\t  &mvif->sta;\n\tstruct mt76_wcid *wcid = &msta->wcid;\n\tint idx = key->keyidx, err = 0;\n\tu8 *wcid_keyidx = &wcid->hw_key_idx;\n\n\t \n\tif ((vif->type == NL80211_IFTYPE_ADHOC ||\n\t     vif->type == NL80211_IFTYPE_MESH_POINT) &&\n\t    (key->cipher == WLAN_CIPHER_SUITE_TKIP ||\n\t     key->cipher == WLAN_CIPHER_SUITE_CCMP) &&\n\t    !(key->flags & IEEE80211_KEY_FLAG_PAIRWISE))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\twcid_keyidx = &wcid->hw_key_idx2;\n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIE;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\tcase WLAN_CIPHER_SUITE_SMS4:\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmt7615_mutex_acquire(dev);\n\n\tif (cmd == SET_KEY && !sta && !mvif->mt76.cipher) {\n\t\tmvif->mt76.cipher = mt76_connac_mcu_get_cipher(key->cipher);\n\t\tmt7615_mcu_add_bss_info(phy, vif, NULL, true);\n\t}\n\n\tif (cmd == SET_KEY)\n\t\t*wcid_keyidx = idx;\n\telse {\n\t\tif (idx == *wcid_keyidx)\n\t\t\t*wcid_keyidx = -1;\n\t\tgoto out;\n\t}\n\n\tmt76_wcid_key_setup(&dev->mt76, wcid, key);\n\tif (mt76_is_mmio(&dev->mt76))\n\t\terr = mt7615_mac_wtbl_set_key(dev, wcid, key);\n\telse\n\t\terr = __mt7615_mac_wtbl_set_key(dev, wcid, key);\n\nout:\n\tmt7615_mutex_release(dev);\n\n\treturn err;\n}\n\nstatic int mt7615_set_sar_specs(struct ieee80211_hw *hw,\n\t\t\t\tconst struct cfg80211_sar_specs *sar)\n{\n\tstruct mt7615_phy *phy = mt7615_hw_phy(hw);\n\tint err;\n\n\tif (!cfg80211_chandef_valid(&phy->mt76->chandef))\n\t\treturn -EINVAL;\n\n\terr = mt76_init_sar_power(hw, sar);\n\tif (err)\n\t\treturn err;\n\n\tif (mt7615_firmware_offload(phy->dev))\n\t\treturn mt76_connac_mcu_set_rate_txpower(phy->mt76);\n\n\tieee80211_stop_queues(hw);\n\terr = mt7615_set_channel(phy);\n\tieee80211_wake_queues(hw);\n\n\treturn err;\n}\n\nstatic int mt7615_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tstruct mt7615_phy *phy = mt7615_hw_phy(hw);\n\tbool band = phy != &dev->phy;\n\tint ret = 0;\n\n\tif (changed & (IEEE80211_CONF_CHANGE_CHANNEL |\n\t\t       IEEE80211_CONF_CHANGE_POWER)) {\n#ifdef CONFIG_NL80211_TESTMODE\n\t\tif (phy->mt76->test.state != MT76_TM_STATE_OFF) {\n\t\t\tmt7615_mutex_acquire(dev);\n\t\t\tmt76_testmode_reset(phy->mt76, false);\n\t\t\tmt7615_mutex_release(dev);\n\t\t}\n#endif\n\t\tieee80211_stop_queues(hw);\n\t\tret = mt7615_set_channel(phy);\n\t\tieee80211_wake_queues(hw);\n\t}\n\n\tmt7615_mutex_acquire(dev);\n\n\tif (changed & IEEE80211_CONF_CHANGE_MONITOR) {\n\t\tmt76_testmode_reset(phy->mt76, true);\n\n\t\tif (!(hw->conf.flags & IEEE80211_CONF_MONITOR))\n\t\t\tphy->rxfilter |= MT_WF_RFCR_DROP_OTHER_UC;\n\t\telse\n\t\t\tphy->rxfilter &= ~MT_WF_RFCR_DROP_OTHER_UC;\n\n\t\tmt76_wr(dev, MT_WF_RFCR(band), phy->rxfilter);\n\t}\n\n\tmt7615_mutex_release(dev);\n\n\treturn ret;\n}\n\nstatic int\nmt7615_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t       unsigned int link_id, u16 queue,\n\t       const struct ieee80211_tx_queue_params *params)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tint err;\n\n\tmt7615_mutex_acquire(dev);\n\n\tqueue = mt7615_lmac_mapping(dev, queue);\n\tqueue += mvif->wmm_idx * MT7615_MAX_WMM_SETS;\n\terr = mt7615_mcu_set_wmm(dev, queue, params);\n\n\tmt7615_mutex_release(dev);\n\n\treturn err;\n}\n\nstatic void mt7615_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t    unsigned int changed_flags,\n\t\t\t\t    unsigned int *total_flags,\n\t\t\t\t    u64 multicast)\n{\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tstruct mt7615_phy *phy = mt7615_hw_phy(hw);\n\tbool band = phy != &dev->phy;\n\n\tu32 ctl_flags = MT_WF_RFCR1_DROP_ACK |\n\t\t\tMT_WF_RFCR1_DROP_BF_POLL |\n\t\t\tMT_WF_RFCR1_DROP_BA |\n\t\t\tMT_WF_RFCR1_DROP_CFEND |\n\t\t\tMT_WF_RFCR1_DROP_CFACK;\n\tu32 flags = 0;\n\n\tmt7615_mutex_acquire(dev);\n\n#define MT76_FILTER(_flag, _hw) do { \\\n\t\tflags |= *total_flags & FIF_##_flag;\t\t\t\\\n\t\tphy->rxfilter &= ~(_hw);\t\t\t\t\\\n\t\tif (!mt76_testmode_enabled(phy->mt76))\t\t\t\\\n\t\t\tphy->rxfilter |= !(flags & FIF_##_flag) * (_hw);\\\n\t} while (0)\n\n\tphy->rxfilter &= ~(MT_WF_RFCR_DROP_OTHER_BSS |\n\t\t\t   MT_WF_RFCR_DROP_FRAME_REPORT |\n\t\t\t   MT_WF_RFCR_DROP_PROBEREQ |\n\t\t\t   MT_WF_RFCR_DROP_MCAST_FILTERED |\n\t\t\t   MT_WF_RFCR_DROP_MCAST |\n\t\t\t   MT_WF_RFCR_DROP_BCAST |\n\t\t\t   MT_WF_RFCR_DROP_DUPLICATE |\n\t\t\t   MT_WF_RFCR_DROP_A2_BSSID |\n\t\t\t   MT_WF_RFCR_DROP_UNWANTED_CTL |\n\t\t\t   MT_WF_RFCR_DROP_STBC_MULTI);\n\n\tif (phy->n_beacon_vif || !mt7615_firmware_offload(dev))\n\t\tphy->rxfilter &= ~MT_WF_RFCR_DROP_OTHER_BEACON;\n\n\tMT76_FILTER(OTHER_BSS, MT_WF_RFCR_DROP_OTHER_TIM |\n\t\t\t       MT_WF_RFCR_DROP_A3_MAC |\n\t\t\t       MT_WF_RFCR_DROP_A3_BSSID);\n\n\tMT76_FILTER(FCSFAIL, MT_WF_RFCR_DROP_FCSFAIL);\n\n\tMT76_FILTER(CONTROL, MT_WF_RFCR_DROP_CTS |\n\t\t\t     MT_WF_RFCR_DROP_RTS |\n\t\t\t     MT_WF_RFCR_DROP_CTL_RSV |\n\t\t\t     MT_WF_RFCR_DROP_NDPA);\n\n\t*total_flags = flags;\n\tmt76_wr(dev, MT_WF_RFCR(band), phy->rxfilter);\n\n\tif (*total_flags & FIF_CONTROL)\n\t\tmt76_clear(dev, MT_WF_RFCR1(band), ctl_flags);\n\telse\n\t\tmt76_set(dev, MT_WF_RFCR1(band), ctl_flags);\n\n\tmt7615_mutex_release(dev);\n}\n\nstatic void\nmt7615_update_mu_group(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_bss_conf *info)\n{\n\tstruct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tu8 i, band = mvif->mt76.band_idx;\n\tu32 *mu;\n\n\tmu = (u32 *)info->mu_group.membership;\n\tfor (i = 0; i < WLAN_MEMBERSHIP_LEN / sizeof(*mu); i++) {\n\t\tif (is_mt7663(&dev->mt76))\n\t\t\tmt76_wr(dev, MT7663_WF_PHY_GID_TAB_VLD(band, i), mu[i]);\n\t\telse\n\t\t\tmt76_wr(dev, MT_WF_PHY_GID_TAB_VLD(band, i), mu[i]);\n\t}\n\n\tmu = (u32 *)info->mu_group.position;\n\tfor (i = 0; i < WLAN_USER_POSITION_LEN / sizeof(*mu); i++) {\n\t\tif (is_mt7663(&dev->mt76))\n\t\t\tmt76_wr(dev, MT7663_WF_PHY_GID_TAB_POS(band, i), mu[i]);\n\t\telse\n\t\t\tmt76_wr(dev, MT_WF_PHY_GID_TAB_POS(band, i), mu[i]);\n\t}\n}\n\nstatic void mt7615_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_bss_conf *info,\n\t\t\t\t    u64 changed)\n{\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tstruct mt7615_phy *phy = mt7615_hw_phy(hw);\n\n\tmt7615_mutex_acquire(dev);\n\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\tint slottime = info->use_short_slot ? 9 : 20;\n\n\t\tif (slottime != phy->slottime) {\n\t\t\tphy->slottime = slottime;\n\t\t\tmt7615_mac_set_timing(phy);\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_CTS_PROT)\n\t\tmt7615_mac_enable_rtscts(dev, vif, info->use_cts_prot);\n\n\tif (changed & BSS_CHANGED_BEACON_ENABLED && info->enable_beacon) {\n\t\tmt7615_mcu_add_bss_info(phy, vif, NULL, true);\n\t\tmt7615_mcu_sta_add(phy, vif, NULL, true);\n\n\t\tif (mt7615_firmware_offload(dev) && vif->p2p)\n\t\t\tmt76_connac_mcu_set_p2p_oppps(hw, vif);\n\t}\n\n\tif (changed & (BSS_CHANGED_BEACON |\n\t\t       BSS_CHANGED_BEACON_ENABLED))\n\t\tmt7615_mcu_add_beacon(dev, hw, vif, info->enable_beacon);\n\n\tif (changed & BSS_CHANGED_PS)\n\t\tmt76_connac_mcu_set_vif_ps(&dev->mt76, vif);\n\n\tif ((changed & BSS_CHANGED_ARP_FILTER) &&\n\t    mt7615_firmware_offload(dev)) {\n\t\tstruct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;\n\n\t\tmt76_connac_mcu_update_arp_filter(&dev->mt76, &mvif->mt76,\n\t\t\t\t\t\t  info);\n\t}\n\n\tif (changed & BSS_CHANGED_ASSOC)\n\t\tmt7615_mac_set_beacon_filter(phy, vif, vif->cfg.assoc);\n\n\tif (changed & BSS_CHANGED_MU_GROUPS)\n\t\t mt7615_update_mu_group(hw, vif, info);\n\n\tmt7615_mutex_release(dev);\n}\n\nstatic void\nmt7615_channel_switch_beacon(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct cfg80211_chan_def *chandef)\n{\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\n\tmt7615_mutex_acquire(dev);\n\tmt7615_mcu_add_beacon(dev, hw, vif, true);\n\tmt7615_mutex_release(dev);\n}\n\nint mt7615_mac_sta_add(struct mt76_dev *mdev, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_sta *sta)\n{\n\tstruct mt7615_dev *dev = container_of(mdev, struct mt7615_dev, mt76);\n\tstruct mt7615_sta *msta = (struct mt7615_sta *)sta->drv_priv;\n\tstruct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;\n\tstruct mt7615_phy *phy;\n\tint idx, err;\n\n\tidx = mt76_wcid_alloc(dev->mt76.wcid_mask, MT7615_WTBL_STA - 1);\n\tif (idx < 0)\n\t\treturn -ENOSPC;\n\n\tINIT_LIST_HEAD(&msta->wcid.poll_list);\n\tmsta->vif = mvif;\n\tmsta->wcid.sta = 1;\n\tmsta->wcid.idx = idx;\n\tmsta->wcid.phy_idx = mvif->mt76.band_idx;\n\n\tphy = mvif->mt76.band_idx ? mt7615_ext_phy(dev) : &dev->phy;\n\terr = mt76_connac_pm_wake(phy->mt76, &dev->pm);\n\tif (err)\n\t\treturn err;\n\n\tif (vif->type == NL80211_IFTYPE_STATION && !sta->tdls) {\n\t\terr = mt7615_mcu_add_bss_info(phy, vif, sta, true);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmt7615_mac_wtbl_update(dev, idx,\n\t\t\t       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);\n\terr = mt7615_mcu_sta_add(&dev->phy, vif, sta, true);\n\tif (err)\n\t\treturn err;\n\n\tmt76_connac_power_save_sched(phy->mt76, &dev->pm);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mt7615_mac_sta_add);\n\nvoid mt7615_mac_sta_remove(struct mt76_dev *mdev, struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_sta *sta)\n{\n\tstruct mt7615_dev *dev = container_of(mdev, struct mt7615_dev, mt76);\n\tstruct mt7615_sta *msta = (struct mt7615_sta *)sta->drv_priv;\n\tstruct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;\n\tstruct mt7615_phy *phy;\n\n\tmt76_connac_free_pending_tx_skbs(&dev->pm, &msta->wcid);\n\n\tphy = mvif->mt76.band_idx ? mt7615_ext_phy(dev) : &dev->phy;\n\tmt76_connac_pm_wake(phy->mt76, &dev->pm);\n\n\tmt7615_mcu_sta_add(&dev->phy, vif, sta, false);\n\tmt7615_mac_wtbl_update(dev, msta->wcid.idx,\n\t\t\t       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);\n\tif (vif->type == NL80211_IFTYPE_STATION && !sta->tdls)\n\t\tmt7615_mcu_add_bss_info(phy, vif, sta, false);\n\n\tspin_lock_bh(&mdev->sta_poll_lock);\n\tif (!list_empty(&msta->wcid.poll_list))\n\t\tlist_del_init(&msta->wcid.poll_list);\n\tspin_unlock_bh(&mdev->sta_poll_lock);\n\n\tmt76_connac_power_save_sched(phy->mt76, &dev->pm);\n}\nEXPORT_SYMBOL_GPL(mt7615_mac_sta_remove);\n\nstatic void mt7615_sta_rate_tbl_update(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_sta *sta)\n{\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tstruct mt7615_phy *phy = mt7615_hw_phy(hw);\n\tstruct mt7615_sta *msta = (struct mt7615_sta *)sta->drv_priv;\n\tstruct ieee80211_sta_rates *sta_rates = rcu_dereference(sta->rates);\n\tint i;\n\n\tif (!sta_rates)\n\t\treturn;\n\n\tspin_lock_bh(&dev->mt76.lock);\n\tfor (i = 0; i < ARRAY_SIZE(msta->rates); i++) {\n\t\tmsta->rates[i].idx = sta_rates->rate[i].idx;\n\t\tmsta->rates[i].count = sta_rates->rate[i].count;\n\t\tmsta->rates[i].flags = sta_rates->rate[i].flags;\n\n\t\tif (msta->rates[i].idx < 0 || !msta->rates[i].count)\n\t\t\tbreak;\n\t}\n\tmsta->n_rates = i;\n\tif (mt76_connac_pm_ref(phy->mt76, &dev->pm)) {\n\t\tmt7615_mac_set_rates(phy, msta, NULL, msta->rates);\n\t\tmt76_connac_pm_unref(phy->mt76, &dev->pm);\n\t}\n\tspin_unlock_bh(&dev->mt76.lock);\n}\n\nvoid mt7615_tx_worker(struct mt76_worker *w)\n{\n\tstruct mt7615_dev *dev = container_of(w, struct mt7615_dev,\n\t\t\t\t\t      mt76.tx_worker);\n\n\tif (!mt76_connac_pm_ref(&dev->mphy, &dev->pm)) {\n\t\tqueue_work(dev->mt76.wq, &dev->pm.wake_work);\n\t\treturn;\n\t}\n\n\tmt76_tx_worker_run(&dev->mt76);\n\tmt76_connac_pm_unref(&dev->mphy, &dev->pm);\n}\n\nstatic void mt7615_tx(struct ieee80211_hw *hw,\n\t\t      struct ieee80211_tx_control *control,\n\t\t      struct sk_buff *skb)\n{\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tstruct mt76_phy *mphy = hw->priv;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_vif *vif = info->control.vif;\n\tstruct mt76_wcid *wcid = &dev->mt76.global_wcid;\n\tstruct mt7615_sta *msta = NULL;\n\tint qid;\n\n\tif (control->sta) {\n\t\tmsta = (struct mt7615_sta *)control->sta->drv_priv;\n\t\twcid = &msta->wcid;\n\t}\n\n\tif (vif && !control->sta) {\n\t\tstruct mt7615_vif *mvif;\n\n\t\tmvif = (struct mt7615_vif *)vif->drv_priv;\n\t\tmsta = &mvif->sta;\n\t\twcid = &msta->wcid;\n\t}\n\n\tif (mt76_connac_pm_ref(mphy, &dev->pm)) {\n\t\tmt76_tx(mphy, control->sta, wcid, skb);\n\t\tmt76_connac_pm_unref(mphy, &dev->pm);\n\t\treturn;\n\t}\n\n\tqid = skb_get_queue_mapping(skb);\n\tif (qid >= MT_TXQ_PSD) {\n\t\tqid = IEEE80211_AC_BE;\n\t\tskb_set_queue_mapping(skb, qid);\n\t}\n\n\tmt76_connac_pm_queue_skb(hw, &dev->pm, wcid, skb);\n}\n\nstatic int mt7615_set_rts_threshold(struct ieee80211_hw *hw, u32 val)\n{\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tstruct mt7615_phy *phy = mt7615_hw_phy(hw);\n\tint err, band = phy != &dev->phy;\n\n\tmt7615_mutex_acquire(dev);\n\terr = mt76_connac_mcu_set_rts_thresh(&dev->mt76, val, band);\n\tmt7615_mutex_release(dev);\n\n\treturn err;\n}\n\nstatic int\nmt7615_ampdu_action(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t    struct ieee80211_ampdu_params *params)\n{\n\tenum ieee80211_ampdu_mlme_action action = params->action;\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tstruct ieee80211_sta *sta = params->sta;\n\tstruct ieee80211_txq *txq = sta->txq[params->tid];\n\tstruct mt7615_sta *msta = (struct mt7615_sta *)sta->drv_priv;\n\tu16 tid = params->tid;\n\tu16 ssn = params->ssn;\n\tstruct mt76_txq *mtxq;\n\tint ret = 0;\n\n\tif (!txq)\n\t\treturn -EINVAL;\n\n\tmtxq = (struct mt76_txq *)txq->drv_priv;\n\n\tmt7615_mutex_acquire(dev);\n\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_RX_START:\n\t\tmt76_rx_aggr_start(&dev->mt76, &msta->wcid, tid, ssn,\n\t\t\t\t   params->buf_size);\n\t\tret = mt7615_mcu_add_rx_ba(dev, params, true);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\tmt76_rx_aggr_stop(&dev->mt76, &msta->wcid, tid);\n\t\tret = mt7615_mcu_add_rx_ba(dev, params, false);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\tmtxq->aggr = true;\n\t\tmtxq->send_bar = false;\n\t\tret = mt7615_mcu_add_tx_ba(dev, params, true);\n\t\tssn = mt7615_mac_get_sta_tid_sn(dev, msta->wcid.idx, tid);\n\t\tieee80211_send_bar(vif, sta->addr, tid,\n\t\t\t\t   IEEE80211_SN_TO_SEQ(ssn));\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\t\tmtxq->aggr = false;\n\t\tret = mt7615_mcu_add_tx_ba(dev, params, false);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_START:\n\t\tssn = mt7615_mac_get_sta_tid_sn(dev, msta->wcid.idx, tid);\n\t\tparams->ssn = ssn;\n\t\tret = IEEE80211_AMPDU_TX_START_IMMEDIATE;\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\t\tmtxq->aggr = false;\n\t\tret = mt7615_mcu_add_tx_ba(dev, params, false);\n\t\tieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\t\tbreak;\n\t}\n\tmt7615_mutex_release(dev);\n\n\treturn ret;\n}\n\nstatic int\nmt7615_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t       struct ieee80211_sta *sta)\n{\n    return mt76_sta_state(hw, vif, sta, IEEE80211_STA_NOTEXIST,\n\t\t\t  IEEE80211_STA_NONE);\n}\n\nstatic int\nmt7615_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t  struct ieee80211_sta *sta)\n{\n    return mt76_sta_state(hw, vif, sta, IEEE80211_STA_NONE,\n\t\t\t  IEEE80211_STA_NOTEXIST);\n}\n\nstatic int\nmt7615_get_stats(struct ieee80211_hw *hw,\n\t\t struct ieee80211_low_level_stats *stats)\n{\n\tstruct mt7615_phy *phy = mt7615_hw_phy(hw);\n\tstruct mib_stats *mib = &phy->mib;\n\n\tmt7615_mutex_acquire(phy->dev);\n\n\tstats->dot11RTSSuccessCount = mib->rts_cnt;\n\tstats->dot11RTSFailureCount = mib->rts_retries_cnt;\n\tstats->dot11FCSErrorCount = mib->fcs_err_cnt;\n\tstats->dot11ACKFailureCount = mib->ack_fail_cnt;\n\n\tmt7615_mutex_release(phy->dev);\n\n\treturn 0;\n}\n\nstatic u64\nmt7615_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tunion {\n\t\tu64 t64;\n\t\tu32 t32[2];\n\t} tsf;\n\tu16 idx = mvif->mt76.omac_idx;\n\tu32 reg;\n\n\tidx = idx > HW_BSSID_MAX ? HW_BSSID_0 : idx;\n\treg = idx > 1 ? MT_LPON_TCR2(idx): MT_LPON_TCR0(idx);\n\n\tmt7615_mutex_acquire(dev);\n\n\t \n\tmt76_rmw(dev, reg, MT_LPON_TCR_MODE, MT_LPON_TCR_READ);\n\ttsf.t32[0] = mt76_rr(dev, MT_LPON_UTTR0);\n\ttsf.t32[1] = mt76_rr(dev, MT_LPON_UTTR1);\n\n\tmt7615_mutex_release(dev);\n\n\treturn tsf.t64;\n}\n\nstatic void\nmt7615_set_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t       u64 timestamp)\n{\n\tstruct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tunion {\n\t\tu64 t64;\n\t\tu32 t32[2];\n\t} tsf = { .t64 = timestamp, };\n\tu16 idx = mvif->mt76.omac_idx;\n\tu32 reg;\n\n\tidx = idx > HW_BSSID_MAX ? HW_BSSID_0 : idx;\n\treg = idx > 1 ? MT_LPON_TCR2(idx): MT_LPON_TCR0(idx);\n\n\tmt7615_mutex_acquire(dev);\n\n\tmt76_wr(dev, MT_LPON_UTTR0, tsf.t32[0]);\n\tmt76_wr(dev, MT_LPON_UTTR1, tsf.t32[1]);\n\t \n\tmt76_rmw(dev, reg, MT_LPON_TCR_MODE, MT_LPON_TCR_WRITE);\n\n\tmt7615_mutex_release(dev);\n}\n\nstatic void\nmt7615_offset_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t  s64 timestamp)\n{\n\tstruct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tunion {\n\t\tu64 t64;\n\t\tu32 t32[2];\n\t} tsf = { .t64 = timestamp, };\n\tu16 idx = mvif->mt76.omac_idx;\n\tu32 reg;\n\n\tidx = idx > HW_BSSID_MAX ? HW_BSSID_0 : idx;\n\treg = idx > 1 ? MT_LPON_TCR2(idx): MT_LPON_TCR0(idx);\n\n\tmt7615_mutex_acquire(dev);\n\n\tmt76_wr(dev, MT_LPON_UTTR0, tsf.t32[0]);\n\tmt76_wr(dev, MT_LPON_UTTR1, tsf.t32[1]);\n\t \n\tmt76_rmw(dev, reg, MT_LPON_TCR_MODE, MT_LPON_TCR_ADJUST);\n\n\tmt7615_mutex_release(dev);\n}\n\nstatic void\nmt7615_set_coverage_class(struct ieee80211_hw *hw, s16 coverage_class)\n{\n\tstruct mt7615_phy *phy = mt7615_hw_phy(hw);\n\tstruct mt7615_dev *dev = phy->dev;\n\n\tmt7615_mutex_acquire(dev);\n\tphy->coverage_class = max_t(s16, coverage_class, 0);\n\tmt7615_mac_set_timing(phy);\n\tmt7615_mutex_release(dev);\n}\n\nstatic int\nmt7615_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)\n{\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tstruct mt7615_phy *phy = mt7615_hw_phy(hw);\n\tint max_nss = hweight8(hw->wiphy->available_antennas_tx);\n\tbool ext_phy = phy != &dev->phy;\n\n\tif (!tx_ant || tx_ant != rx_ant || ffs(tx_ant) > max_nss)\n\t\treturn -EINVAL;\n\n\tif ((BIT(hweight8(tx_ant)) - 1) != tx_ant)\n\t\ttx_ant = BIT(ffs(tx_ant) - 1) - 1;\n\n\tmt7615_mutex_acquire(dev);\n\n\tphy->mt76->antenna_mask = tx_ant;\n\tif (ext_phy) {\n\t\tif (dev->chainmask == 0xf)\n\t\t\ttx_ant <<= 2;\n\t\telse\n\t\t\ttx_ant <<= 1;\n\t}\n\tphy->mt76->chainmask = tx_ant;\n\n\tmt76_set_stream_caps(phy->mt76, true);\n\n\tmt7615_mutex_release(dev);\n\n\treturn 0;\n}\n\nstatic void mt7615_roc_iter(void *priv, u8 *mac,\n\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct mt7615_phy *phy = priv;\n\n\tmt7615_mcu_set_roc(phy, vif, NULL, 0);\n}\n\nvoid mt7615_roc_work(struct work_struct *work)\n{\n\tstruct mt7615_phy *phy;\n\n\tphy = (struct mt7615_phy *)container_of(work, struct mt7615_phy,\n\t\t\t\t\t\troc_work);\n\n\tif (!test_and_clear_bit(MT76_STATE_ROC, &phy->mt76->state))\n\t\treturn;\n\n\tmt7615_mutex_acquire(phy->dev);\n\tieee80211_iterate_active_interfaces(phy->mt76->hw,\n\t\t\t\t\t    IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\t\t\t    mt7615_roc_iter, phy);\n\tmt7615_mutex_release(phy->dev);\n\tieee80211_remain_on_channel_expired(phy->mt76->hw);\n}\n\nvoid mt7615_roc_timer(struct timer_list *timer)\n{\n\tstruct mt7615_phy *phy = from_timer(phy, timer, roc_timer);\n\n\tieee80211_queue_work(phy->mt76->hw, &phy->roc_work);\n}\n\nvoid mt7615_scan_work(struct work_struct *work)\n{\n\tstruct mt7615_phy *phy;\n\n\tphy = (struct mt7615_phy *)container_of(work, struct mt7615_phy,\n\t\t\t\t\t\tscan_work.work);\n\n\twhile (true) {\n\t\tstruct mt7615_mcu_rxd *rxd;\n\t\tstruct sk_buff *skb;\n\n\t\tspin_lock_bh(&phy->dev->mt76.lock);\n\t\tskb = __skb_dequeue(&phy->scan_event_list);\n\t\tspin_unlock_bh(&phy->dev->mt76.lock);\n\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\trxd = (struct mt7615_mcu_rxd *)skb->data;\n\t\tif (rxd->eid == MCU_EVENT_SCHED_SCAN_DONE) {\n\t\t\tieee80211_sched_scan_results(phy->mt76->hw);\n\t\t} else if (test_and_clear_bit(MT76_HW_SCANNING,\n\t\t\t\t\t      &phy->mt76->state)) {\n\t\t\tstruct cfg80211_scan_info info = {\n\t\t\t\t.aborted = false,\n\t\t\t};\n\n\t\t\tieee80211_scan_completed(phy->mt76->hw, &info);\n\t\t}\n\t\tdev_kfree_skb(skb);\n\t}\n}\n\nstatic int\nmt7615_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t       struct ieee80211_scan_request *req)\n{\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tstruct mt76_phy *mphy = hw->priv;\n\tint err;\n\n\t \n\tif (!mt7615_firmware_offload(dev))\n\t\treturn 1;\n\n\tmt7615_mutex_acquire(dev);\n\terr = mt76_connac_mcu_hw_scan(mphy, vif, req);\n\tmt7615_mutex_release(dev);\n\n\treturn err;\n}\n\nstatic void\nmt7615_cancel_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tstruct mt76_phy *mphy = hw->priv;\n\n\tmt7615_mutex_acquire(dev);\n\tmt76_connac_mcu_cancel_hw_scan(mphy, vif);\n\tmt7615_mutex_release(dev);\n}\n\nstatic int\nmt7615_start_sched_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tstruct cfg80211_sched_scan_request *req,\n\t\t\tstruct ieee80211_scan_ies *ies)\n{\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tstruct mt76_phy *mphy = hw->priv;\n\tint err;\n\n\tif (!mt7615_firmware_offload(dev))\n\t\treturn -EOPNOTSUPP;\n\n\tmt7615_mutex_acquire(dev);\n\n\terr = mt76_connac_mcu_sched_scan_req(mphy, vif, req);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = mt76_connac_mcu_sched_scan_enable(mphy, vif, true);\nout:\n\tmt7615_mutex_release(dev);\n\n\treturn err;\n}\n\nstatic int\nmt7615_stop_sched_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tstruct mt76_phy *mphy = hw->priv;\n\tint err;\n\n\tif (!mt7615_firmware_offload(dev))\n\t\treturn -EOPNOTSUPP;\n\n\tmt7615_mutex_acquire(dev);\n\terr = mt76_connac_mcu_sched_scan_enable(mphy, vif, false);\n\tmt7615_mutex_release(dev);\n\n\treturn err;\n}\n\nstatic int mt7615_remain_on_channel(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_channel *chan,\n\t\t\t\t    int duration,\n\t\t\t\t    enum ieee80211_roc_type type)\n{\n\tstruct mt7615_phy *phy = mt7615_hw_phy(hw);\n\tint err;\n\n\tif (test_and_set_bit(MT76_STATE_ROC, &phy->mt76->state))\n\t\treturn 0;\n\n\tmt7615_mutex_acquire(phy->dev);\n\n\terr = mt7615_mcu_set_roc(phy, vif, chan, duration);\n\tif (err < 0) {\n\t\tclear_bit(MT76_STATE_ROC, &phy->mt76->state);\n\t\tgoto out;\n\t}\n\n\tif (!wait_event_timeout(phy->roc_wait, phy->roc_grant, HZ)) {\n\t\tmt7615_mcu_set_roc(phy, vif, NULL, 0);\n\t\tclear_bit(MT76_STATE_ROC, &phy->mt76->state);\n\t\terr = -ETIMEDOUT;\n\t}\n\nout:\n\tmt7615_mutex_release(phy->dev);\n\n\treturn err;\n}\n\nstatic int mt7615_cancel_remain_on_channel(struct ieee80211_hw *hw,\n\t\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct mt7615_phy *phy = mt7615_hw_phy(hw);\n\tint err;\n\n\tif (!test_and_clear_bit(MT76_STATE_ROC, &phy->mt76->state))\n\t\treturn 0;\n\n\tdel_timer_sync(&phy->roc_timer);\n\tcancel_work_sync(&phy->roc_work);\n\n\tmt7615_mutex_acquire(phy->dev);\n\terr = mt7615_mcu_set_roc(phy, vif, NULL, 0);\n\tmt7615_mutex_release(phy->dev);\n\n\treturn err;\n}\n\nstatic void mt7615_sta_set_decap_offload(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t bool enabled)\n{\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tstruct mt7615_sta *msta = (struct mt7615_sta *)sta->drv_priv;\n\n\tmt7615_mutex_acquire(dev);\n\n\tif (enabled)\n\t\tset_bit(MT_WCID_FLAG_HDR_TRANS, &msta->wcid.flags);\n\telse\n\t\tclear_bit(MT_WCID_FLAG_HDR_TRANS, &msta->wcid.flags);\n\n\tmt7615_mcu_set_sta_decap_offload(dev, vif, sta);\n\n\tmt7615_mutex_release(dev);\n}\n\n#ifdef CONFIG_PM\nstatic int mt7615_suspend(struct ieee80211_hw *hw,\n\t\t\t  struct cfg80211_wowlan *wowlan)\n{\n\tstruct mt7615_phy *phy = mt7615_hw_phy(hw);\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tint err = 0;\n\n\tcancel_delayed_work_sync(&dev->pm.ps_work);\n\tmt76_connac_free_pending_tx_skbs(&dev->pm, NULL);\n\n\tmt7615_mutex_acquire(dev);\n\n\tclear_bit(MT76_STATE_RUNNING, &phy->mt76->state);\n\tcancel_delayed_work_sync(&phy->scan_work);\n\tcancel_delayed_work_sync(&phy->mt76->mac_work);\n\n\tset_bit(MT76_STATE_SUSPEND, &phy->mt76->state);\n\tieee80211_iterate_active_interfaces(hw,\n\t\t\t\t\t    IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\t\t\t    mt76_connac_mcu_set_suspend_iter,\n\t\t\t\t\t    phy->mt76);\n\n\tif (!mt7615_dev_running(dev))\n\t\terr = mt76_connac_mcu_set_hif_suspend(&dev->mt76, true);\n\n\tmt7615_mutex_release(dev);\n\n\treturn err;\n}\n\nstatic int mt7615_resume(struct ieee80211_hw *hw)\n{\n\tstruct mt7615_phy *phy = mt7615_hw_phy(hw);\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tunsigned long timeout;\n\tbool running;\n\n\tmt7615_mutex_acquire(dev);\n\n\trunning = mt7615_dev_running(dev);\n\tset_bit(MT76_STATE_RUNNING, &phy->mt76->state);\n\n\tif (!running) {\n\t\tint err;\n\n\t\terr = mt76_connac_mcu_set_hif_suspend(&dev->mt76, false);\n\t\tif (err < 0) {\n\t\t\tmt7615_mutex_release(dev);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tclear_bit(MT76_STATE_SUSPEND, &phy->mt76->state);\n\tieee80211_iterate_active_interfaces(hw,\n\t\t\t\t\t    IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\t\t\t    mt76_connac_mcu_set_suspend_iter,\n\t\t\t\t\t    phy->mt76);\n\n\ttimeout = mt7615_get_macwork_timeout(dev);\n\tieee80211_queue_delayed_work(hw, &phy->mt76->mac_work, timeout);\n\n\tmt7615_mutex_release(dev);\n\n\treturn 0;\n}\n\nstatic void mt7615_set_wakeup(struct ieee80211_hw *hw, bool enabled)\n{\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tstruct mt76_dev *mdev = &dev->mt76;\n\n\tdevice_set_wakeup_enable(mdev->dev, enabled);\n}\n\nstatic void mt7615_set_rekey_data(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct cfg80211_gtk_rekey_data *data)\n{\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\n\tmt7615_mutex_acquire(dev);\n\tmt76_connac_mcu_update_gtk_rekey(hw, vif, data);\n\tmt7615_mutex_release(dev);\n}\n#endif  \n\nconst struct ieee80211_ops mt7615_ops = {\n\t.tx = mt7615_tx,\n\t.start = mt7615_start,\n\t.stop = mt7615_stop,\n\t.add_interface = mt7615_add_interface,\n\t.remove_interface = mt7615_remove_interface,\n\t.config = mt7615_config,\n\t.conf_tx = mt7615_conf_tx,\n\t.configure_filter = mt7615_configure_filter,\n\t.bss_info_changed = mt7615_bss_info_changed,\n\t.sta_add = mt7615_sta_add,\n\t.sta_remove = mt7615_sta_remove,\n\t.sta_pre_rcu_remove = mt76_sta_pre_rcu_remove,\n\t.set_key = mt7615_set_key,\n\t.sta_set_decap_offload = mt7615_sta_set_decap_offload,\n\t.ampdu_action = mt7615_ampdu_action,\n\t.set_rts_threshold = mt7615_set_rts_threshold,\n\t.wake_tx_queue = mt76_wake_tx_queue,\n\t.sta_rate_tbl_update = mt7615_sta_rate_tbl_update,\n\t.sw_scan_start = mt76_sw_scan,\n\t.sw_scan_complete = mt76_sw_scan_complete,\n\t.release_buffered_frames = mt76_release_buffered_frames,\n\t.get_txpower = mt76_get_txpower,\n\t.channel_switch_beacon = mt7615_channel_switch_beacon,\n\t.get_stats = mt7615_get_stats,\n\t.get_tsf = mt7615_get_tsf,\n\t.set_tsf = mt7615_set_tsf,\n\t.offset_tsf = mt7615_offset_tsf,\n\t.get_survey = mt76_get_survey,\n\t.get_antenna = mt76_get_antenna,\n\t.set_antenna = mt7615_set_antenna,\n\t.set_coverage_class = mt7615_set_coverage_class,\n\t.hw_scan = mt7615_hw_scan,\n\t.cancel_hw_scan = mt7615_cancel_hw_scan,\n\t.sched_scan_start = mt7615_start_sched_scan,\n\t.sched_scan_stop = mt7615_stop_sched_scan,\n\t.remain_on_channel = mt7615_remain_on_channel,\n\t.cancel_remain_on_channel = mt7615_cancel_remain_on_channel,\n\tCFG80211_TESTMODE_CMD(mt76_testmode_cmd)\n\tCFG80211_TESTMODE_DUMP(mt76_testmode_dump)\n#ifdef CONFIG_PM\n\t.suspend = mt7615_suspend,\n\t.resume = mt7615_resume,\n\t.set_wakeup = mt7615_set_wakeup,\n\t.set_rekey_data = mt7615_set_rekey_data,\n#endif  \n\t.set_sar_specs = mt7615_set_sar_specs,\n};\nEXPORT_SYMBOL_GPL(mt7615_ops);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}