{
  "module_name": "mac.c",
  "hash_id": "59917e5fa17b5618d61d9353db79270e89390e8d6cf957a51c6c8310ac78a39a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7615/mac.c",
  "human_readable_source": "\n \n\n#include <linux/devcoredump.h>\n#include <linux/etherdevice.h>\n#include <linux/timekeeping.h>\n#include \"mt7615.h\"\n#include \"../trace.h\"\n#include \"../dma.h\"\n#include \"mt7615_trace.h\"\n#include \"mac.h\"\n#include \"mcu.h\"\n\n#define to_rssi(field, rxv)\t\t((FIELD_GET(field, rxv) - 220) / 2)\n\nstatic const struct mt7615_dfs_radar_spec etsi_radar_specs = {\n\t.pulse_th = { 110, -10, -80, 40, 5200, 128, 5200 },\n\t.radar_pattern = {\n\t\t[5] =  { 1, 0,  6, 32, 28, 0, 17,  990, 5010, 1, 1 },\n\t\t[6] =  { 1, 0,  9, 32, 28, 0, 27,  615, 5010, 1, 1 },\n\t\t[7] =  { 1, 0, 15, 32, 28, 0, 27,  240,  445, 1, 1 },\n\t\t[8] =  { 1, 0, 12, 32, 28, 0, 42,  240,  510, 1, 1 },\n\t\t[9] =  { 1, 1,  0,  0,  0, 0, 14, 2490, 3343, 0, 0, 12, 32, 28 },\n\t\t[10] = { 1, 1,  0,  0,  0, 0, 14, 2490, 3343, 0, 0, 15, 32, 24 },\n\t\t[11] = { 1, 1,  0,  0,  0, 0, 14,  823, 2510, 0, 0, 18, 32, 28 },\n\t\t[12] = { 1, 1,  0,  0,  0, 0, 14,  823, 2510, 0, 0, 27, 32, 24 },\n\t},\n};\n\nstatic const struct mt7615_dfs_radar_spec fcc_radar_specs = {\n\t.pulse_th = { 110, -10, -80, 40, 5200, 128, 5200 },\n\t.radar_pattern = {\n\t\t[0] = { 1, 0,  9,  32, 28, 0, 13, 508, 3076, 1,  1 },\n\t\t[1] = { 1, 0, 12,  32, 28, 0, 17, 140,  240, 1,  1 },\n\t\t[2] = { 1, 0,  8,  32, 28, 0, 22, 190,  510, 1,  1 },\n\t\t[3] = { 1, 0,  6,  32, 28, 0, 32, 190,  510, 1,  1 },\n\t\t[4] = { 1, 0,  9, 255, 28, 0, 13, 323,  343, 1, 32 },\n\t},\n};\n\nstatic const struct mt7615_dfs_radar_spec jp_radar_specs = {\n\t.pulse_th = { 110, -10, -80, 40, 5200, 128, 5200 },\n\t.radar_pattern = {\n\t\t[0] =  { 1, 0,  8, 32, 28, 0, 13,  508, 3076, 1,  1 },\n\t\t[1] =  { 1, 0, 12, 32, 28, 0, 17,  140,  240, 1,  1 },\n\t\t[2] =  { 1, 0,  8, 32, 28, 0, 22,  190,  510, 1,  1 },\n\t\t[3] =  { 1, 0,  6, 32, 28, 0, 32,  190,  510, 1,  1 },\n\t\t[4] =  { 1, 0,  9, 32, 28, 0, 13,  323,  343, 1, 32 },\n\t\t[13] = { 1, 0, 8,  32, 28, 0, 14, 3836, 3856, 1,  1 },\n\t\t[14] = { 1, 0, 8,  32, 28, 0, 14, 3990, 4010, 1,  1 },\n\t},\n};\n\nstatic enum mt76_cipher_type\nmt7615_mac_get_cipher(int cipher)\n{\n\tswitch (cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\treturn MT_CIPHER_WEP40;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\treturn MT_CIPHER_WEP104;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\treturn MT_CIPHER_TKIP;\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\treturn MT_CIPHER_BIP_CMAC_128;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\treturn MT_CIPHER_AES_CCMP;\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\treturn MT_CIPHER_CCMP_256;\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\t\treturn MT_CIPHER_GCMP;\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\treturn MT_CIPHER_GCMP_256;\n\tcase WLAN_CIPHER_SUITE_SMS4:\n\t\treturn MT_CIPHER_WAPI;\n\tdefault:\n\t\treturn MT_CIPHER_NONE;\n\t}\n}\n\nstatic struct mt76_wcid *mt7615_rx_get_wcid(struct mt7615_dev *dev,\n\t\t\t\t\t    u8 idx, bool unicast)\n{\n\tstruct mt7615_sta *sta;\n\tstruct mt76_wcid *wcid;\n\n\tif (idx >= MT7615_WTBL_SIZE)\n\t\treturn NULL;\n\n\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n\tif (unicast || !wcid)\n\t\treturn wcid;\n\n\tif (!wcid->sta)\n\t\treturn NULL;\n\n\tsta = container_of(wcid, struct mt7615_sta, wcid);\n\tif (!sta->vif)\n\t\treturn NULL;\n\n\treturn &sta->vif->sta.wcid;\n}\n\nvoid mt7615_mac_reset_counters(struct mt7615_phy *phy)\n{\n\tstruct mt7615_dev *dev = phy->dev;\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tmt76_rr(dev, MT_TX_AGG_CNT(0, i));\n\t\tmt76_rr(dev, MT_TX_AGG_CNT(1, i));\n\t}\n\n\tmemset(phy->mt76->aggr_stats, 0, sizeof(phy->mt76->aggr_stats));\n\tphy->mt76->survey_time = ktime_get_boottime();\n\n\t \n\tmt76_rr(dev, MT_MIB_SDR9(0));\n\tmt76_rr(dev, MT_MIB_SDR9(1));\n\n\tmt76_rr(dev, MT_MIB_SDR36(0));\n\tmt76_rr(dev, MT_MIB_SDR36(1));\n\n\tmt76_rr(dev, MT_MIB_SDR37(0));\n\tmt76_rr(dev, MT_MIB_SDR37(1));\n\n\tmt76_set(dev, MT_WF_RMAC_MIB_TIME0, MT_WF_RMAC_MIB_RXTIME_CLR);\n\tmt76_set(dev, MT_WF_RMAC_MIB_AIRTIME0, MT_WF_RMAC_MIB_RXTIME_CLR);\n}\n\nvoid mt7615_mac_set_timing(struct mt7615_phy *phy)\n{\n\ts16 coverage_class = phy->coverage_class;\n\tstruct mt7615_dev *dev = phy->dev;\n\tbool ext_phy = phy != &dev->phy;\n\tu32 val, reg_offset;\n\tu32 cck = FIELD_PREP(MT_TIMEOUT_VAL_PLCP, 231) |\n\t\t  FIELD_PREP(MT_TIMEOUT_VAL_CCA, 48);\n\tu32 ofdm = FIELD_PREP(MT_TIMEOUT_VAL_PLCP, 60) |\n\t\t   FIELD_PREP(MT_TIMEOUT_VAL_CCA, 28);\n\tint sifs, offset;\n\tbool is_5ghz = phy->mt76->chandef.chan->band == NL80211_BAND_5GHZ;\n\n\tif (!test_bit(MT76_STATE_RUNNING, &phy->mt76->state))\n\t\treturn;\n\n\tif (is_5ghz)\n\t\tsifs = 16;\n\telse\n\t\tsifs = 10;\n\n\tif (ext_phy) {\n\t\tcoverage_class = max_t(s16, dev->phy.coverage_class,\n\t\t\t\t       coverage_class);\n\t\tmt76_set(dev, MT_ARB_SCR,\n\t\t\t MT_ARB_SCR_TX1_DISABLE | MT_ARB_SCR_RX1_DISABLE);\n\t} else {\n\t\tstruct mt7615_phy *phy_ext = mt7615_ext_phy(dev);\n\n\t\tif (phy_ext)\n\t\t\tcoverage_class = max_t(s16, phy_ext->coverage_class,\n\t\t\t\t\t       coverage_class);\n\t\tmt76_set(dev, MT_ARB_SCR,\n\t\t\t MT_ARB_SCR_TX0_DISABLE | MT_ARB_SCR_RX0_DISABLE);\n\t}\n\tudelay(1);\n\n\toffset = 3 * coverage_class;\n\treg_offset = FIELD_PREP(MT_TIMEOUT_VAL_PLCP, offset) |\n\t\t     FIELD_PREP(MT_TIMEOUT_VAL_CCA, offset);\n\tmt76_wr(dev, MT_TMAC_CDTR, cck + reg_offset);\n\tmt76_wr(dev, MT_TMAC_ODTR, ofdm + reg_offset);\n\n\tmt76_wr(dev, MT_TMAC_ICR(ext_phy),\n\t\tFIELD_PREP(MT_IFS_EIFS, 360) |\n\t\tFIELD_PREP(MT_IFS_RIFS, 2) |\n\t\tFIELD_PREP(MT_IFS_SIFS, sifs) |\n\t\tFIELD_PREP(MT_IFS_SLOT, phy->slottime));\n\n\tif (phy->slottime < 20 || is_5ghz)\n\t\tval = MT7615_CFEND_RATE_DEFAULT;\n\telse\n\t\tval = MT7615_CFEND_RATE_11B;\n\n\tmt76_rmw_field(dev, MT_AGG_ACR(ext_phy), MT_AGG_ACR_CFEND_RATE, val);\n\tif (ext_phy)\n\t\tmt76_clear(dev, MT_ARB_SCR,\n\t\t\t   MT_ARB_SCR_TX1_DISABLE | MT_ARB_SCR_RX1_DISABLE);\n\telse\n\t\tmt76_clear(dev, MT_ARB_SCR,\n\t\t\t   MT_ARB_SCR_TX0_DISABLE | MT_ARB_SCR_RX0_DISABLE);\n\n}\n\nstatic void\nmt7615_get_status_freq_info(struct mt7615_dev *dev, struct mt76_phy *mphy,\n\t\t\t    struct mt76_rx_status *status, u8 chfreq)\n{\n\tif (!test_bit(MT76_HW_SCANNING, &mphy->state) &&\n\t    !test_bit(MT76_HW_SCHED_SCANNING, &mphy->state) &&\n\t    !test_bit(MT76_STATE_ROC, &mphy->state)) {\n\t\tstatus->freq = mphy->chandef.chan->center_freq;\n\t\tstatus->band = mphy->chandef.chan->band;\n\t\treturn;\n\t}\n\n\tstatus->band = chfreq <= 14 ? NL80211_BAND_2GHZ : NL80211_BAND_5GHZ;\n\tstatus->freq = ieee80211_channel_to_frequency(chfreq, status->band);\n}\n\nstatic void mt7615_mac_fill_tm_rx(struct mt7615_phy *phy, __le32 *rxv)\n{\n#ifdef CONFIG_NL80211_TESTMODE\n\tu32 rxv1 = le32_to_cpu(rxv[0]);\n\tu32 rxv3 = le32_to_cpu(rxv[2]);\n\tu32 rxv4 = le32_to_cpu(rxv[3]);\n\tu32 rxv5 = le32_to_cpu(rxv[4]);\n\tu8 cbw = FIELD_GET(MT_RXV1_FRAME_MODE, rxv1);\n\tu8 mode = FIELD_GET(MT_RXV1_TX_MODE, rxv1);\n\ts16 foe = FIELD_GET(MT_RXV5_FOE, rxv5);\n\tu32 foe_const = (BIT(cbw + 1) & 0xf) * 10000;\n\n\tif (!mode) {\n\t\t \n\t\tfoe &= ~BIT(11);\n\t\tfoe *= 1000;\n\t\tfoe >>= 11;\n\t} else {\n\t\tif (foe > 2048)\n\t\t\tfoe -= 4096;\n\n\t\tfoe = (foe * foe_const) >> 15;\n\t}\n\n\tphy->test.last_freq_offset = foe;\n\tphy->test.last_rcpi[0] = FIELD_GET(MT_RXV4_RCPI0, rxv4);\n\tphy->test.last_rcpi[1] = FIELD_GET(MT_RXV4_RCPI1, rxv4);\n\tphy->test.last_rcpi[2] = FIELD_GET(MT_RXV4_RCPI2, rxv4);\n\tphy->test.last_rcpi[3] = FIELD_GET(MT_RXV4_RCPI3, rxv4);\n\tphy->test.last_ib_rssi[0] = FIELD_GET(MT_RXV3_IB_RSSI, rxv3);\n\tphy->test.last_wb_rssi[0] = FIELD_GET(MT_RXV3_WB_RSSI, rxv3);\n#endif\n}\n\n \nstatic int mt7615_reverse_frag0_hdr_trans(struct sk_buff *skb, u16 hdr_gap)\n{\n\tstruct mt76_rx_status *status = (struct mt76_rx_status *)skb->cb;\n\tstruct ethhdr *eth_hdr = (struct ethhdr *)(skb->data + hdr_gap);\n\tstruct mt7615_sta *msta = (struct mt7615_sta *)status->wcid;\n\t__le32 *rxd = (__le32 *)skb->data;\n\tstruct ieee80211_sta *sta;\n\tstruct ieee80211_vif *vif;\n\tstruct ieee80211_hdr hdr;\n\tu16 frame_control;\n\n\tif (le32_get_bits(rxd[1], MT_RXD1_NORMAL_ADDR_TYPE) !=\n\t    MT_RXD1_NORMAL_U2M)\n\t\treturn -EINVAL;\n\n\tif (!(le32_to_cpu(rxd[0]) & MT_RXD0_NORMAL_GROUP_4))\n\t\treturn -EINVAL;\n\n\tif (!msta || !msta->vif)\n\t\treturn -EINVAL;\n\n\tsta = container_of((void *)msta, struct ieee80211_sta, drv_priv);\n\tvif = container_of((void *)msta->vif, struct ieee80211_vif, drv_priv);\n\n\t \n\tframe_control = le32_get_bits(rxd[4], MT_RXD4_FRAME_CONTROL);\n\thdr.frame_control = cpu_to_le16(frame_control);\n\thdr.seq_ctrl = cpu_to_le16(le32_get_bits(rxd[6], MT_RXD6_SEQ_CTRL));\n\thdr.duration_id = 0;\n\n\tether_addr_copy(hdr.addr1, vif->addr);\n\tether_addr_copy(hdr.addr2, sta->addr);\n\tswitch (frame_control & (IEEE80211_FCTL_TODS |\n\t\t\t\t IEEE80211_FCTL_FROMDS)) {\n\tcase 0:\n\t\tether_addr_copy(hdr.addr3, vif->bss_conf.bssid);\n\t\tbreak;\n\tcase IEEE80211_FCTL_FROMDS:\n\t\tether_addr_copy(hdr.addr3, eth_hdr->h_source);\n\t\tbreak;\n\tcase IEEE80211_FCTL_TODS:\n\t\tether_addr_copy(hdr.addr3, eth_hdr->h_dest);\n\t\tbreak;\n\tcase IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS:\n\t\tether_addr_copy(hdr.addr3, eth_hdr->h_dest);\n\t\tether_addr_copy(hdr.addr4, eth_hdr->h_source);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tskb_pull(skb, hdr_gap + sizeof(struct ethhdr) - 2);\n\tif (eth_hdr->h_proto == cpu_to_be16(ETH_P_AARP) ||\n\t    eth_hdr->h_proto == cpu_to_be16(ETH_P_IPX))\n\t\tether_addr_copy(skb_push(skb, ETH_ALEN), bridge_tunnel_header);\n\telse if (be16_to_cpu(eth_hdr->h_proto) >= ETH_P_802_3_MIN)\n\t\tether_addr_copy(skb_push(skb, ETH_ALEN), rfc1042_header);\n\telse\n\t\tskb_pull(skb, 2);\n\n\tif (ieee80211_has_order(hdr.frame_control))\n\t\tmemcpy(skb_push(skb, IEEE80211_HT_CTL_LEN), &rxd[7],\n\t\t       IEEE80211_HT_CTL_LEN);\n\n\tif (ieee80211_is_data_qos(hdr.frame_control)) {\n\t\t__le16 qos_ctrl;\n\n\t\tqos_ctrl = cpu_to_le16(le32_get_bits(rxd[6], MT_RXD6_QOS_CTL));\n\t\tmemcpy(skb_push(skb, IEEE80211_QOS_CTL_LEN), &qos_ctrl,\n\t\t       IEEE80211_QOS_CTL_LEN);\n\t}\n\n\tif (ieee80211_has_a4(hdr.frame_control))\n\t\tmemcpy(skb_push(skb, sizeof(hdr)), &hdr, sizeof(hdr));\n\telse\n\t\tmemcpy(skb_push(skb, sizeof(hdr) - 6), &hdr, sizeof(hdr) - 6);\n\n\tstatus->flag &= ~(RX_FLAG_RADIOTAP_HE | RX_FLAG_RADIOTAP_HE_MU);\n\treturn 0;\n}\n\nstatic int mt7615_mac_fill_rx(struct mt7615_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt76_rx_status *status = (struct mt76_rx_status *)skb->cb;\n\tstruct mt76_phy *mphy = &dev->mt76.phy;\n\tstruct mt7615_phy *phy = &dev->phy;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_hdr *hdr;\n\tstruct mt7615_phy *phy2;\n\t__le32 *rxd = (__le32 *)skb->data;\n\tu32 rxd0 = le32_to_cpu(rxd[0]);\n\tu32 rxd1 = le32_to_cpu(rxd[1]);\n\tu32 rxd2 = le32_to_cpu(rxd[2]);\n\tu32 csum_mask = MT_RXD0_NORMAL_IP_SUM | MT_RXD0_NORMAL_UDP_TCP_SUM;\n\tu32 csum_status = *(u32 *)skb->cb;\n\tbool unicast, hdr_trans, remove_pad, insert_ccmp_hdr = false;\n\tu16 hdr_gap;\n\tint phy_idx;\n\tint i, idx;\n\tu8 chfreq, amsdu_info, qos_ctl = 0;\n\tu16 seq_ctrl = 0;\n\t__le16 fc = 0;\n\n\tmemset(status, 0, sizeof(*status));\n\n\tchfreq = FIELD_GET(MT_RXD1_NORMAL_CH_FREQ, rxd1);\n\n\tphy2 = dev->mt76.phys[MT_BAND1] ? dev->mt76.phys[MT_BAND1]->priv : NULL;\n\tif (!phy2)\n\t\tphy_idx = 0;\n\telse if (phy2->chfreq == phy->chfreq)\n\t\tphy_idx = -1;\n\telse if (phy->chfreq == chfreq)\n\t\tphy_idx = 0;\n\telse if (phy2->chfreq == chfreq)\n\t\tphy_idx = 1;\n\telse\n\t\tphy_idx = -1;\n\n\tif (rxd2 & MT_RXD2_NORMAL_AMSDU_ERR)\n\t\treturn -EINVAL;\n\n\thdr_trans = rxd1 & MT_RXD1_NORMAL_HDR_TRANS;\n\tif (hdr_trans && (rxd2 & MT_RXD2_NORMAL_CM))\n\t\treturn -EINVAL;\n\n\t \n\tif (rxd2 & MT_RXD2_NORMAL_ICV_ERR)\n\t\tstatus->flag |= RX_FLAG_ONLY_MONITOR;\n\n\tunicast = (rxd1 & MT_RXD1_NORMAL_ADDR_TYPE) == MT_RXD1_NORMAL_U2M;\n\tidx = FIELD_GET(MT_RXD2_NORMAL_WLAN_IDX, rxd2);\n\tstatus->wcid = mt7615_rx_get_wcid(dev, idx, unicast);\n\n\tif (status->wcid) {\n\t\tstruct mt7615_sta *msta;\n\n\t\tmsta = container_of(status->wcid, struct mt7615_sta, wcid);\n\t\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\t\tif (list_empty(&msta->wcid.poll_list))\n\t\t\tlist_add_tail(&msta->wcid.poll_list,\n\t\t\t\t      &dev->mt76.sta_poll_list);\n\t\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\t}\n\n\tif (mt76_is_mmio(&dev->mt76) && (rxd0 & csum_mask) == csum_mask &&\n\t    !(csum_status & (BIT(0) | BIT(2) | BIT(3))))\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tif (rxd2 & MT_RXD2_NORMAL_FCS_ERR)\n\t\tstatus->flag |= RX_FLAG_FAILED_FCS_CRC;\n\n\tif (rxd2 & MT_RXD2_NORMAL_TKIP_MIC_ERR)\n\t\tstatus->flag |= RX_FLAG_MMIC_ERROR;\n\n\tif (FIELD_GET(MT_RXD2_NORMAL_SEC_MODE, rxd2) != 0 &&\n\t    !(rxd2 & (MT_RXD2_NORMAL_CLM | MT_RXD2_NORMAL_CM))) {\n\t\tstatus->flag |= RX_FLAG_DECRYPTED;\n\t\tstatus->flag |= RX_FLAG_IV_STRIPPED;\n\t\tstatus->flag |= RX_FLAG_MMIC_STRIPPED | RX_FLAG_MIC_STRIPPED;\n\t}\n\n\tremove_pad = rxd1 & MT_RXD1_NORMAL_HDR_OFFSET;\n\n\tif (rxd2 & MT_RXD2_NORMAL_MAX_LEN_ERROR)\n\t\treturn -EINVAL;\n\n\trxd += 4;\n\tif (rxd0 & MT_RXD0_NORMAL_GROUP_4) {\n\t\tu32 v0 = le32_to_cpu(rxd[0]);\n\t\tu32 v2 = le32_to_cpu(rxd[2]);\n\n\t\tfc = cpu_to_le16(FIELD_GET(MT_RXD4_FRAME_CONTROL, v0));\n\t\tqos_ctl = FIELD_GET(MT_RXD6_QOS_CTL, v2);\n\t\tseq_ctrl = FIELD_GET(MT_RXD6_SEQ_CTRL, v2);\n\n\t\trxd += 4;\n\t\tif ((u8 *)rxd - skb->data >= skb->len)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (rxd0 & MT_RXD0_NORMAL_GROUP_1) {\n\t\tu8 *data = (u8 *)rxd;\n\n\t\tif (status->flag & RX_FLAG_DECRYPTED) {\n\t\t\tswitch (FIELD_GET(MT_RXD2_NORMAL_SEC_MODE, rxd2)) {\n\t\t\tcase MT_CIPHER_AES_CCMP:\n\t\t\tcase MT_CIPHER_CCMP_CCX:\n\t\t\tcase MT_CIPHER_CCMP_256:\n\t\t\t\tinsert_ccmp_hdr =\n\t\t\t\t\tFIELD_GET(MT_RXD2_NORMAL_FRAG, rxd2);\n\t\t\t\tfallthrough;\n\t\t\tcase MT_CIPHER_TKIP:\n\t\t\tcase MT_CIPHER_TKIP_NO_MIC:\n\t\t\tcase MT_CIPHER_GCMP:\n\t\t\tcase MT_CIPHER_GCMP_256:\n\t\t\t\tstatus->iv[0] = data[5];\n\t\t\t\tstatus->iv[1] = data[4];\n\t\t\t\tstatus->iv[2] = data[3];\n\t\t\t\tstatus->iv[3] = data[2];\n\t\t\t\tstatus->iv[4] = data[1];\n\t\t\t\tstatus->iv[5] = data[0];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trxd += 4;\n\t\tif ((u8 *)rxd - skb->data >= skb->len)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (rxd0 & MT_RXD0_NORMAL_GROUP_2) {\n\t\tstatus->timestamp = le32_to_cpu(rxd[0]);\n\t\tstatus->flag |= RX_FLAG_MACTIME_START;\n\n\t\tif (!(rxd2 & (MT_RXD2_NORMAL_NON_AMPDU_SUB |\n\t\t\t      MT_RXD2_NORMAL_NON_AMPDU))) {\n\t\t\tstatus->flag |= RX_FLAG_AMPDU_DETAILS;\n\n\t\t\t \n\t\t\tif (phy->rx_ampdu_ts != status->timestamp) {\n\t\t\t\tif (!++phy->ampdu_ref)\n\t\t\t\t\tphy->ampdu_ref++;\n\t\t\t}\n\t\t\tphy->rx_ampdu_ts = status->timestamp;\n\n\t\t\tstatus->ampdu_ref = phy->ampdu_ref;\n\t\t}\n\n\t\trxd += 2;\n\t\tif ((u8 *)rxd - skb->data >= skb->len)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (rxd0 & MT_RXD0_NORMAL_GROUP_3) {\n\t\tu32 rxdg5 = le32_to_cpu(rxd[5]);\n\n\t\t \n\t\tif (phy_idx < 0) {\n\t\t\tint first_chain = ffs(phy2->mt76->chainmask) - 1;\n\n\t\t\tphy_idx = ((rxdg5 >> (first_chain * 8)) & 0xff) == 0;\n\t\t}\n\t}\n\n\tif (phy_idx == 1 && phy2) {\n\t\tmphy = dev->mt76.phys[MT_BAND1];\n\t\tphy = phy2;\n\t\tstatus->phy_idx = phy_idx;\n\t}\n\n\tif (!mt7615_firmware_offload(dev) && chfreq != phy->chfreq)\n\t\treturn -EINVAL;\n\n\tmt7615_get_status_freq_info(dev, mphy, status, chfreq);\n\tif (status->band == NL80211_BAND_5GHZ)\n\t\tsband = &mphy->sband_5g.sband;\n\telse\n\t\tsband = &mphy->sband_2g.sband;\n\n\tif (!test_bit(MT76_STATE_RUNNING, &mphy->state))\n\t\treturn -EINVAL;\n\n\tif (!sband->channels)\n\t\treturn -EINVAL;\n\n\tif (rxd0 & MT_RXD0_NORMAL_GROUP_3) {\n\t\tu32 rxdg0 = le32_to_cpu(rxd[0]);\n\t\tu32 rxdg1 = le32_to_cpu(rxd[1]);\n\t\tu32 rxdg3 = le32_to_cpu(rxd[3]);\n\t\tu8 stbc = FIELD_GET(MT_RXV1_HT_STBC, rxdg0);\n\t\tbool cck = false;\n\n\t\ti = FIELD_GET(MT_RXV1_TX_RATE, rxdg0);\n\t\tswitch (FIELD_GET(MT_RXV1_TX_MODE, rxdg0)) {\n\t\tcase MT_PHY_TYPE_CCK:\n\t\t\tcck = true;\n\t\t\tfallthrough;\n\t\tcase MT_PHY_TYPE_OFDM:\n\t\t\ti = mt76_get_rate(&dev->mt76, sband, i, cck);\n\t\t\tbreak;\n\t\tcase MT_PHY_TYPE_HT_GF:\n\t\tcase MT_PHY_TYPE_HT:\n\t\t\tstatus->encoding = RX_ENC_HT;\n\t\t\tif (i > 31)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase MT_PHY_TYPE_VHT:\n\t\t\tstatus->nss = FIELD_GET(MT_RXV2_NSTS, rxdg1) + 1;\n\t\t\tstatus->encoding = RX_ENC_VHT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstatus->rate_idx = i;\n\n\t\tswitch (FIELD_GET(MT_RXV1_FRAME_MODE, rxdg0)) {\n\t\tcase MT_PHY_BW_20:\n\t\t\tbreak;\n\t\tcase MT_PHY_BW_40:\n\t\t\tstatus->bw = RATE_INFO_BW_40;\n\t\t\tbreak;\n\t\tcase MT_PHY_BW_80:\n\t\t\tstatus->bw = RATE_INFO_BW_80;\n\t\t\tbreak;\n\t\tcase MT_PHY_BW_160:\n\t\t\tstatus->bw = RATE_INFO_BW_160;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (rxdg0 & MT_RXV1_HT_SHORT_GI)\n\t\t\tstatus->enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\t\tif (rxdg0 & MT_RXV1_HT_AD_CODE)\n\t\t\tstatus->enc_flags |= RX_ENC_FLAG_LDPC;\n\n\t\tstatus->enc_flags |= RX_ENC_FLAG_STBC_MASK * stbc;\n\n\t\tstatus->chains = mphy->antenna_mask;\n\t\tstatus->chain_signal[0] = to_rssi(MT_RXV4_RCPI0, rxdg3);\n\t\tstatus->chain_signal[1] = to_rssi(MT_RXV4_RCPI1, rxdg3);\n\t\tstatus->chain_signal[2] = to_rssi(MT_RXV4_RCPI2, rxdg3);\n\t\tstatus->chain_signal[3] = to_rssi(MT_RXV4_RCPI3, rxdg3);\n\n\t\tmt7615_mac_fill_tm_rx(mphy->priv, rxd);\n\n\t\trxd += 6;\n\t\tif ((u8 *)rxd - skb->data >= skb->len)\n\t\t\treturn -EINVAL;\n\t}\n\n\tamsdu_info = FIELD_GET(MT_RXD1_NORMAL_PAYLOAD_FORMAT, rxd1);\n\tstatus->amsdu = !!amsdu_info;\n\tif (status->amsdu) {\n\t\tstatus->first_amsdu = amsdu_info == MT_RXD1_FIRST_AMSDU_FRAME;\n\t\tstatus->last_amsdu = amsdu_info == MT_RXD1_LAST_AMSDU_FRAME;\n\t}\n\n\thdr_gap = (u8 *)rxd - skb->data + 2 * remove_pad;\n\tif (hdr_trans && ieee80211_has_morefrags(fc)) {\n\t\tif (mt7615_reverse_frag0_hdr_trans(skb, hdr_gap))\n\t\t\treturn -EINVAL;\n\t\thdr_trans = false;\n\t} else {\n\t\tint pad_start = 0;\n\n\t\tskb_pull(skb, hdr_gap);\n\t\tif (!hdr_trans && status->amsdu) {\n\t\t\tpad_start = ieee80211_get_hdrlen_from_skb(skb);\n\t\t} else if (hdr_trans && (rxd2 & MT_RXD2_NORMAL_HDR_TRANS_ERROR)) {\n\t\t\t \n\t\t\tpad_start = 12;\n\t\t\tif (get_unaligned_be16(skb->data + pad_start) == ETH_P_8021Q)\n\t\t\t\tpad_start += 4;\n\t\t\telse\n\t\t\t\tpad_start = 0;\n\t\t}\n\n\t\tif (pad_start) {\n\t\t\tmemmove(skb->data + 2, skb->data, pad_start);\n\t\t\tskb_pull(skb, 2);\n\t\t}\n\t}\n\n\tif (insert_ccmp_hdr && !hdr_trans) {\n\t\tu8 key_id = FIELD_GET(MT_RXD1_NORMAL_KEY_ID, rxd1);\n\n\t\tmt76_insert_ccmp_hdr(skb, key_id);\n\t}\n\n\tif (!hdr_trans) {\n\t\thdr = (struct ieee80211_hdr *)skb->data;\n\t\tfc = hdr->frame_control;\n\t\tif (ieee80211_is_data_qos(fc)) {\n\t\t\tseq_ctrl = le16_to_cpu(hdr->seq_ctrl);\n\t\t\tqos_ctl = *ieee80211_get_qos_ctl(hdr);\n\t\t}\n\t} else {\n\t\tstatus->flag |= RX_FLAG_8023;\n\t}\n\n\tif (!status->wcid || !ieee80211_is_data_qos(fc))\n\t\treturn 0;\n\n\tstatus->aggr = unicast &&\n\t\t       !ieee80211_is_qos_nullfunc(fc);\n\tstatus->qos_ctl = qos_ctl;\n\tstatus->seqno = IEEE80211_SEQ_TO_SN(seq_ctrl);\n\n\treturn 0;\n}\n\nstatic u16\nmt7615_mac_tx_rate_val(struct mt7615_dev *dev,\n\t\t       struct mt76_phy *mphy,\n\t\t       const struct ieee80211_tx_rate *rate,\n\t\t       bool stbc, u8 *bw)\n{\n\tu8 phy, nss, rate_idx;\n\tu16 rateval = 0;\n\n\t*bw = 0;\n\n\tif (rate->flags & IEEE80211_TX_RC_VHT_MCS) {\n\t\trate_idx = ieee80211_rate_get_vht_mcs(rate);\n\t\tnss = ieee80211_rate_get_vht_nss(rate);\n\t\tphy = MT_PHY_TYPE_VHT;\n\t\tif (rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\n\t\t\t*bw = 1;\n\t\telse if (rate->flags & IEEE80211_TX_RC_80_MHZ_WIDTH)\n\t\t\t*bw = 2;\n\t\telse if (rate->flags & IEEE80211_TX_RC_160_MHZ_WIDTH)\n\t\t\t*bw = 3;\n\t} else if (rate->flags & IEEE80211_TX_RC_MCS) {\n\t\trate_idx = rate->idx;\n\t\tnss = 1 + (rate->idx >> 3);\n\t\tphy = MT_PHY_TYPE_HT;\n\t\tif (rate->flags & IEEE80211_TX_RC_GREEN_FIELD)\n\t\t\tphy = MT_PHY_TYPE_HT_GF;\n\t\tif (rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\n\t\t\t*bw = 1;\n\t} else {\n\t\tconst struct ieee80211_rate *r;\n\t\tint band = mphy->chandef.chan->band;\n\t\tu16 val;\n\n\t\tnss = 1;\n\t\tr = &mphy->hw->wiphy->bands[band]->bitrates[rate->idx];\n\t\tif (rate->flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE)\n\t\t\tval = r->hw_value_short;\n\t\telse\n\t\t\tval = r->hw_value;\n\n\t\tphy = val >> 8;\n\t\trate_idx = val & 0xff;\n\t}\n\n\tif (stbc && nss == 1) {\n\t\tnss++;\n\t\trateval |= MT_TX_RATE_STBC;\n\t}\n\n\trateval |= (FIELD_PREP(MT_TX_RATE_IDX, rate_idx) |\n\t\t    FIELD_PREP(MT_TX_RATE_MODE, phy) |\n\t\t    FIELD_PREP(MT_TX_RATE_NSS, nss - 1));\n\n\treturn rateval;\n}\n\nint mt7615_mac_write_txwi(struct mt7615_dev *dev, __le32 *txwi,\n\t\t\t  struct sk_buff *skb, struct mt76_wcid *wcid,\n\t\t\t  struct ieee80211_sta *sta, int pid,\n\t\t\t  struct ieee80211_key_conf *key,\n\t\t\t  enum mt76_txq_id qid, bool beacon)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tu8 fc_type, fc_stype, p_fmt, q_idx, omac_idx = 0, wmm_idx = 0;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_tx_rate *rate = &info->control.rates[0];\n\tu8 phy_idx = (info->hw_queue & MT_TX_HW_QUEUE_PHY) >> 2;\n\tbool multicast = is_multicast_ether_addr(hdr->addr1);\n\tstruct ieee80211_vif *vif = info->control.vif;\n\tbool is_mmio = mt76_is_mmio(&dev->mt76);\n\tu32 val, sz_txd = is_mmio ? MT_TXD_SIZE : MT_USB_TXD_SIZE;\n\tstruct mt76_phy *mphy = &dev->mphy;\n\t__le16 fc = hdr->frame_control;\n\tint tx_count = 8;\n\tu16 seqno = 0;\n\n\tif (vif) {\n\t\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\n\t\tomac_idx = mvif->omac_idx;\n\t\twmm_idx = mvif->wmm_idx;\n\t}\n\n\tif (sta) {\n\t\tstruct mt7615_sta *msta = (struct mt7615_sta *)sta->drv_priv;\n\n\t\ttx_count = msta->rate_count;\n\t}\n\n\tif (phy_idx && dev->mt76.phys[MT_BAND1])\n\t\tmphy = dev->mt76.phys[MT_BAND1];\n\n\tfc_type = (le16_to_cpu(fc) & IEEE80211_FCTL_FTYPE) >> 2;\n\tfc_stype = (le16_to_cpu(fc) & IEEE80211_FCTL_STYPE) >> 4;\n\n\tif (beacon) {\n\t\tp_fmt = MT_TX_TYPE_FW;\n\t\tq_idx = phy_idx ? MT_LMAC_BCN1 : MT_LMAC_BCN0;\n\t} else if (qid >= MT_TXQ_PSD) {\n\t\tp_fmt = is_mmio ? MT_TX_TYPE_CT : MT_TX_TYPE_SF;\n\t\tq_idx = phy_idx ? MT_LMAC_ALTX1 : MT_LMAC_ALTX0;\n\t} else {\n\t\tp_fmt = is_mmio ? MT_TX_TYPE_CT : MT_TX_TYPE_SF;\n\t\tq_idx = wmm_idx * MT7615_MAX_WMM_SETS +\n\t\t\tmt7615_lmac_mapping(dev, skb_get_queue_mapping(skb));\n\t}\n\n\tval = FIELD_PREP(MT_TXD0_TX_BYTES, skb->len + sz_txd) |\n\t      FIELD_PREP(MT_TXD0_P_IDX, MT_TX_PORT_IDX_LMAC) |\n\t      FIELD_PREP(MT_TXD0_Q_IDX, q_idx);\n\ttxwi[0] = cpu_to_le32(val);\n\n\tval = MT_TXD1_LONG_FORMAT |\n\t      FIELD_PREP(MT_TXD1_WLAN_IDX, wcid->idx) |\n\t      FIELD_PREP(MT_TXD1_HDR_FORMAT, MT_HDR_FORMAT_802_11) |\n\t      FIELD_PREP(MT_TXD1_HDR_INFO,\n\t\t\t ieee80211_get_hdrlen_from_skb(skb) / 2) |\n\t      FIELD_PREP(MT_TXD1_TID,\n\t\t\t skb->priority & IEEE80211_QOS_CTL_TID_MASK) |\n\t      FIELD_PREP(MT_TXD1_PKT_FMT, p_fmt) |\n\t      FIELD_PREP(MT_TXD1_OWN_MAC, omac_idx);\n\ttxwi[1] = cpu_to_le32(val);\n\n\tval = FIELD_PREP(MT_TXD2_FRAME_TYPE, fc_type) |\n\t      FIELD_PREP(MT_TXD2_SUB_TYPE, fc_stype) |\n\t      FIELD_PREP(MT_TXD2_MULTICAST, multicast);\n\tif (key) {\n\t\tif (multicast && ieee80211_is_robust_mgmt_frame(skb) &&\n\t\t    key->cipher == WLAN_CIPHER_SUITE_AES_CMAC) {\n\t\t\tval |= MT_TXD2_BIP;\n\t\t\ttxwi[3] = 0;\n\t\t} else {\n\t\t\ttxwi[3] = cpu_to_le32(MT_TXD3_PROTECT_FRAME);\n\t\t}\n\t} else {\n\t\ttxwi[3] = 0;\n\t}\n\ttxwi[2] = cpu_to_le32(val);\n\n\tif (!(info->flags & IEEE80211_TX_CTL_AMPDU))\n\t\ttxwi[2] |= cpu_to_le32(MT_TXD2_BA_DISABLE);\n\n\ttxwi[4] = 0;\n\ttxwi[6] = 0;\n\n\tif (rate->idx >= 0 && rate->count &&\n\t    !(info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE)) {\n\t\tbool stbc = info->flags & IEEE80211_TX_CTL_STBC;\n\t\tu8 bw;\n\t\tu16 rateval = mt7615_mac_tx_rate_val(dev, mphy, rate, stbc,\n\t\t\t\t\t\t     &bw);\n\n\t\ttxwi[2] |= cpu_to_le32(MT_TXD2_FIX_RATE);\n\n\t\tval = MT_TXD6_FIXED_BW |\n\t\t      FIELD_PREP(MT_TXD6_BW, bw) |\n\t\t      FIELD_PREP(MT_TXD6_TX_RATE, rateval);\n\t\ttxwi[6] |= cpu_to_le32(val);\n\n\t\tif (rate->flags & IEEE80211_TX_RC_SHORT_GI)\n\t\t\ttxwi[6] |= cpu_to_le32(MT_TXD6_SGI);\n\n\t\tif (info->flags & IEEE80211_TX_CTL_LDPC)\n\t\t\ttxwi[6] |= cpu_to_le32(MT_TXD6_LDPC);\n\n\t\tif (!(rate->flags & (IEEE80211_TX_RC_MCS |\n\t\t\t\t     IEEE80211_TX_RC_VHT_MCS)))\n\t\t\ttxwi[2] |= cpu_to_le32(MT_TXD2_BA_DISABLE);\n\n\t\ttx_count = rate->count;\n\t}\n\n\tif (!ieee80211_is_beacon(fc)) {\n\t\tstruct ieee80211_hw *hw = mt76_hw(dev);\n\n\t\tval = MT_TXD5_TX_STATUS_HOST | FIELD_PREP(MT_TXD5_PID, pid);\n\t\tif (!ieee80211_hw_check(hw, SUPPORTS_PS))\n\t\t\tval |= MT_TXD5_SW_POWER_MGMT;\n\t\ttxwi[5] = cpu_to_le32(val);\n\t} else {\n\t\ttxwi[5] = 0;\n\t\t \n\t\ttx_count = 0x1f;\n\t}\n\n\tval = FIELD_PREP(MT_TXD3_REM_TX_COUNT, tx_count);\n\tif (info->flags & IEEE80211_TX_CTL_INJECTED) {\n\t\tseqno = le16_to_cpu(hdr->seq_ctrl);\n\n\t\tif (ieee80211_is_back_req(hdr->frame_control)) {\n\t\t\tstruct ieee80211_bar *bar;\n\n\t\t\tbar = (struct ieee80211_bar *)skb->data;\n\t\t\tseqno = le16_to_cpu(bar->start_seq_num);\n\t\t}\n\n\t\tval |= MT_TXD3_SN_VALID |\n\t\t       FIELD_PREP(MT_TXD3_SEQ, IEEE80211_SEQ_TO_SN(seqno));\n\t}\n\n\ttxwi[3] |= cpu_to_le32(val);\n\n\tif (info->flags & IEEE80211_TX_CTL_NO_ACK)\n\t\ttxwi[3] |= cpu_to_le32(MT_TXD3_NO_ACK);\n\n\tval = FIELD_PREP(MT_TXD7_TYPE, fc_type) |\n\t      FIELD_PREP(MT_TXD7_SUB_TYPE, fc_stype) |\n\t      FIELD_PREP(MT_TXD7_SPE_IDX, 0x18);\n\ttxwi[7] = cpu_to_le32(val);\n\tif (!is_mmio) {\n\t\tval = FIELD_PREP(MT_TXD8_L_TYPE, fc_type) |\n\t\t      FIELD_PREP(MT_TXD8_L_SUB_TYPE, fc_stype);\n\t\ttxwi[8] = cpu_to_le32(val);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt7615_mac_write_txwi);\n\nbool mt7615_mac_wtbl_update(struct mt7615_dev *dev, int idx, u32 mask)\n{\n\tmt76_rmw(dev, MT_WTBL_UPDATE, MT_WTBL_UPDATE_WLAN_IDX,\n\t\t FIELD_PREP(MT_WTBL_UPDATE_WLAN_IDX, idx) | mask);\n\n\treturn mt76_poll(dev, MT_WTBL_UPDATE, MT_WTBL_UPDATE_BUSY,\n\t\t\t 0, 5000);\n}\n\nvoid mt7615_mac_sta_poll(struct mt7615_dev *dev)\n{\n\tstatic const u8 ac_to_tid[4] = {\n\t\t[IEEE80211_AC_BE] = 0,\n\t\t[IEEE80211_AC_BK] = 1,\n\t\t[IEEE80211_AC_VI] = 4,\n\t\t[IEEE80211_AC_VO] = 6\n\t};\n\tstatic const u8 hw_queue_map[] = {\n\t\t[IEEE80211_AC_BK] = 0,\n\t\t[IEEE80211_AC_BE] = 1,\n\t\t[IEEE80211_AC_VI] = 2,\n\t\t[IEEE80211_AC_VO] = 3,\n\t};\n\tstruct ieee80211_sta *sta;\n\tstruct mt7615_sta *msta;\n\tu32 addr, tx_time[4], rx_time[4];\n\tstruct list_head sta_poll_list;\n\tint i;\n\n\tINIT_LIST_HEAD(&sta_poll_list);\n\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\tlist_splice_init(&dev->mt76.sta_poll_list, &sta_poll_list);\n\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\n\twhile (!list_empty(&sta_poll_list)) {\n\t\tbool clear = false;\n\n\t\tmsta = list_first_entry(&sta_poll_list, struct mt7615_sta,\n\t\t\t\t\twcid.poll_list);\n\n\t\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\t\tlist_del_init(&msta->wcid.poll_list);\n\t\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\n\t\taddr = mt7615_mac_wtbl_addr(dev, msta->wcid.idx) + 19 * 4;\n\n\t\tfor (i = 0; i < 4; i++, addr += 8) {\n\t\t\tu32 tx_last = msta->airtime_ac[i];\n\t\t\tu32 rx_last = msta->airtime_ac[i + 4];\n\n\t\t\tmsta->airtime_ac[i] = mt76_rr(dev, addr);\n\t\t\tmsta->airtime_ac[i + 4] = mt76_rr(dev, addr + 4);\n\t\t\ttx_time[i] = msta->airtime_ac[i] - tx_last;\n\t\t\trx_time[i] = msta->airtime_ac[i + 4] - rx_last;\n\n\t\t\tif ((tx_last | rx_last) & BIT(30))\n\t\t\t\tclear = true;\n\t\t}\n\n\t\tif (clear) {\n\t\t\tmt7615_mac_wtbl_update(dev, msta->wcid.idx,\n\t\t\t\t\t       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);\n\t\t\tmemset(msta->airtime_ac, 0, sizeof(msta->airtime_ac));\n\t\t}\n\n\t\tif (!msta->wcid.sta)\n\t\t\tcontinue;\n\n\t\tsta = container_of((void *)msta, struct ieee80211_sta,\n\t\t\t\t   drv_priv);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tu32 tx_cur = tx_time[i];\n\t\t\tu32 rx_cur = rx_time[hw_queue_map[i]];\n\t\t\tu8 tid = ac_to_tid[i];\n\n\t\t\tif (!tx_cur && !rx_cur)\n\t\t\t\tcontinue;\n\n\t\t\tieee80211_sta_register_airtime(sta, tid, tx_cur,\n\t\t\t\t\t\t       rx_cur);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(mt7615_mac_sta_poll);\n\nstatic void\nmt7615_mac_update_rate_desc(struct mt7615_phy *phy, struct mt7615_sta *sta,\n\t\t\t    struct ieee80211_tx_rate *probe_rate,\n\t\t\t    struct ieee80211_tx_rate *rates,\n\t\t\t    struct mt7615_rate_desc *rd)\n{\n\tstruct mt7615_dev *dev = phy->dev;\n\tstruct mt76_phy *mphy = phy->mt76;\n\tstruct ieee80211_tx_rate *ref;\n\tbool rateset, stbc = false;\n\tint n_rates = sta->n_rates;\n\tu8 bw, bw_prev;\n\tint i, j;\n\n\tfor (i = n_rates; i < 4; i++)\n\t\trates[i] = rates[n_rates - 1];\n\n\trateset = !(sta->rate_set_tsf & BIT(0));\n\tmemcpy(sta->rateset[rateset].rates, rates,\n\t       sizeof(sta->rateset[rateset].rates));\n\tif (probe_rate) {\n\t\tsta->rateset[rateset].probe_rate = *probe_rate;\n\t\tref = &sta->rateset[rateset].probe_rate;\n\t} else {\n\t\tsta->rateset[rateset].probe_rate.idx = -1;\n\t\tref = &sta->rateset[rateset].rates[0];\n\t}\n\n\trates = sta->rateset[rateset].rates;\n\tfor (i = 0; i < ARRAY_SIZE(sta->rateset[rateset].rates); i++) {\n\t\t \n\t\tif ((ref->flags ^ rates[i].flags) & IEEE80211_TX_RC_SHORT_GI)\n\t\t\trates[i].flags ^= IEEE80211_TX_RC_SHORT_GI;\n\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (rates[i].idx != rates[j].idx)\n\t\t\t\tcontinue;\n\t\t\tif ((rates[i].flags ^ rates[j].flags) &\n\t\t\t    (IEEE80211_TX_RC_40_MHZ_WIDTH |\n\t\t\t     IEEE80211_TX_RC_80_MHZ_WIDTH |\n\t\t\t     IEEE80211_TX_RC_160_MHZ_WIDTH))\n\t\t\t\tcontinue;\n\n\t\t\tif (!rates[i].idx)\n\t\t\t\tcontinue;\n\n\t\t\trates[i].idx--;\n\t\t}\n\t}\n\n\trd->val[0] = mt7615_mac_tx_rate_val(dev, mphy, &rates[0], stbc, &bw);\n\tbw_prev = bw;\n\n\tif (probe_rate) {\n\t\trd->probe_val = mt7615_mac_tx_rate_val(dev, mphy, probe_rate,\n\t\t\t\t\t\t       stbc, &bw);\n\t\tif (bw)\n\t\t\trd->bw_idx = 1;\n\t\telse\n\t\t\tbw_prev = 0;\n\t} else {\n\t\trd->probe_val = rd->val[0];\n\t}\n\n\trd->val[1] = mt7615_mac_tx_rate_val(dev, mphy, &rates[1], stbc, &bw);\n\tif (bw_prev) {\n\t\trd->bw_idx = 3;\n\t\tbw_prev = bw;\n\t}\n\n\trd->val[2] = mt7615_mac_tx_rate_val(dev, mphy, &rates[2], stbc, &bw);\n\tif (bw_prev) {\n\t\trd->bw_idx = 5;\n\t\tbw_prev = bw;\n\t}\n\n\trd->val[3] = mt7615_mac_tx_rate_val(dev, mphy, &rates[3], stbc, &bw);\n\tif (bw_prev)\n\t\trd->bw_idx = 7;\n\n\trd->rateset = rateset;\n\trd->bw = bw;\n}\n\nstatic int\nmt7615_mac_queue_rate_update(struct mt7615_phy *phy, struct mt7615_sta *sta,\n\t\t\t     struct ieee80211_tx_rate *probe_rate,\n\t\t\t     struct ieee80211_tx_rate *rates)\n{\n\tstruct mt7615_dev *dev = phy->dev;\n\tstruct mt7615_wtbl_rate_desc *wrd;\n\n\tif (work_pending(&dev->rate_work))\n\t\treturn -EBUSY;\n\n\twrd = kzalloc(sizeof(*wrd), GFP_ATOMIC);\n\tif (!wrd)\n\t\treturn -ENOMEM;\n\n\twrd->sta = sta;\n\tmt7615_mac_update_rate_desc(phy, sta, probe_rate, rates,\n\t\t\t\t    &wrd->rate);\n\tlist_add_tail(&wrd->node, &dev->wrd_head);\n\tqueue_work(dev->mt76.wq, &dev->rate_work);\n\n\treturn 0;\n}\n\nu32 mt7615_mac_get_sta_tid_sn(struct mt7615_dev *dev, int wcid, u8 tid)\n{\n\tu32 addr, val, val2;\n\tu8 offset;\n\n\taddr = mt7615_mac_wtbl_addr(dev, wcid) + 11 * 4;\n\n\toffset = tid * 12;\n\taddr += 4 * (offset / 32);\n\toffset %= 32;\n\n\tval = mt76_rr(dev, addr);\n\tval >>= offset;\n\n\tif (offset > 20) {\n\t\taddr += 4;\n\t\tval2 = mt76_rr(dev, addr);\n\t\tval |= val2 << (32 - offset);\n\t}\n\n\treturn val & GENMASK(11, 0);\n}\n\nvoid mt7615_mac_set_rates(struct mt7615_phy *phy, struct mt7615_sta *sta,\n\t\t\t  struct ieee80211_tx_rate *probe_rate,\n\t\t\t  struct ieee80211_tx_rate *rates)\n{\n\tint wcid = sta->wcid.idx, n_rates = sta->n_rates;\n\tstruct mt7615_dev *dev = phy->dev;\n\tstruct mt7615_rate_desc rd;\n\tu32 w5, w27, addr;\n\tu16 idx = sta->vif->mt76.omac_idx;\n\n\tif (!mt76_is_mmio(&dev->mt76)) {\n\t\tmt7615_mac_queue_rate_update(phy, sta, probe_rate, rates);\n\t\treturn;\n\t}\n\n\tif (!mt76_poll(dev, MT_WTBL_UPDATE, MT_WTBL_UPDATE_BUSY, 0, 5000))\n\t\treturn;\n\n\tmemset(&rd, 0, sizeof(struct mt7615_rate_desc));\n\tmt7615_mac_update_rate_desc(phy, sta, probe_rate, rates, &rd);\n\n\taddr = mt7615_mac_wtbl_addr(dev, wcid);\n\tw27 = mt76_rr(dev, addr + 27 * 4);\n\tw27 &= ~MT_WTBL_W27_CC_BW_SEL;\n\tw27 |= FIELD_PREP(MT_WTBL_W27_CC_BW_SEL, rd.bw);\n\n\tw5 = mt76_rr(dev, addr + 5 * 4);\n\tw5 &= ~(MT_WTBL_W5_BW_CAP | MT_WTBL_W5_CHANGE_BW_RATE |\n\t\tMT_WTBL_W5_MPDU_OK_COUNT |\n\t\tMT_WTBL_W5_MPDU_FAIL_COUNT |\n\t\tMT_WTBL_W5_RATE_IDX);\n\tw5 |= FIELD_PREP(MT_WTBL_W5_BW_CAP, rd.bw) |\n\t      FIELD_PREP(MT_WTBL_W5_CHANGE_BW_RATE,\n\t\t\t rd.bw_idx ? rd.bw_idx - 1 : 7);\n\n\tmt76_wr(dev, MT_WTBL_RIUCR0, w5);\n\n\tmt76_wr(dev, MT_WTBL_RIUCR1,\n\t\tFIELD_PREP(MT_WTBL_RIUCR1_RATE0, rd.probe_val) |\n\t\tFIELD_PREP(MT_WTBL_RIUCR1_RATE1, rd.val[0]) |\n\t\tFIELD_PREP(MT_WTBL_RIUCR1_RATE2_LO, rd.val[1]));\n\n\tmt76_wr(dev, MT_WTBL_RIUCR2,\n\t\tFIELD_PREP(MT_WTBL_RIUCR2_RATE2_HI, rd.val[1] >> 8) |\n\t\tFIELD_PREP(MT_WTBL_RIUCR2_RATE3, rd.val[1]) |\n\t\tFIELD_PREP(MT_WTBL_RIUCR2_RATE4, rd.val[2]) |\n\t\tFIELD_PREP(MT_WTBL_RIUCR2_RATE5_LO, rd.val[2]));\n\n\tmt76_wr(dev, MT_WTBL_RIUCR3,\n\t\tFIELD_PREP(MT_WTBL_RIUCR3_RATE5_HI, rd.val[2] >> 4) |\n\t\tFIELD_PREP(MT_WTBL_RIUCR3_RATE6, rd.val[3]) |\n\t\tFIELD_PREP(MT_WTBL_RIUCR3_RATE7, rd.val[3]));\n\n\tmt76_wr(dev, MT_WTBL_UPDATE,\n\t\tFIELD_PREP(MT_WTBL_UPDATE_WLAN_IDX, wcid) |\n\t\tMT_WTBL_UPDATE_RATE_UPDATE |\n\t\tMT_WTBL_UPDATE_TX_COUNT_CLEAR);\n\n\tmt76_wr(dev, addr + 27 * 4, w27);\n\n\tidx = idx > HW_BSSID_MAX ? HW_BSSID_0 : idx;\n\taddr = idx > 1 ? MT_LPON_TCR2(idx): MT_LPON_TCR0(idx);\n\n\tmt76_rmw(dev, addr, MT_LPON_TCR_MODE, MT_LPON_TCR_READ);  \n\tsta->rate_set_tsf = mt76_rr(dev, MT_LPON_UTTR0) & ~BIT(0);\n\tsta->rate_set_tsf |= rd.rateset;\n\n\tif (!(sta->wcid.tx_info & MT_WCID_TX_INFO_SET))\n\t\tmt76_poll(dev, MT_WTBL_UPDATE, MT_WTBL_UPDATE_BUSY, 0, 5000);\n\n\tsta->rate_count = 2 * MT7615_RATE_RETRY * n_rates;\n\tsta->wcid.tx_info |= MT_WCID_TX_INFO_SET;\n\tsta->rate_probe = !!probe_rate;\n}\nEXPORT_SYMBOL_GPL(mt7615_mac_set_rates);\n\nvoid mt7615_mac_enable_rtscts(struct mt7615_dev *dev,\n\t\t\t      struct ieee80211_vif *vif, bool enable)\n{\n\tstruct mt7615_vif *mvif = (struct mt7615_vif *)vif->drv_priv;\n\tu32 addr;\n\n\taddr = mt7615_mac_wtbl_addr(dev, mvif->sta.wcid.idx) + 3 * 4;\n\n\tif (enable)\n\t\tmt76_set(dev, addr, MT_WTBL_W3_RTS);\n\telse\n\t\tmt76_clear(dev, addr, MT_WTBL_W3_RTS);\n}\nEXPORT_SYMBOL_GPL(mt7615_mac_enable_rtscts);\n\nstatic int\nmt7615_mac_wtbl_update_key(struct mt7615_dev *dev, struct mt76_wcid *wcid,\n\t\t\t   struct ieee80211_key_conf *key,\n\t\t\t   enum mt76_cipher_type cipher, u16 cipher_mask)\n{\n\tu32 addr = mt7615_mac_wtbl_addr(dev, wcid->idx) + 30 * 4;\n\tu8 data[32] = {};\n\n\tif (key->keylen > sizeof(data))\n\t\treturn -EINVAL;\n\n\tmt76_rr_copy(dev, addr, data, sizeof(data));\n\tif (cipher == MT_CIPHER_TKIP) {\n\t\t \n\t\tmemcpy(data, key->key, 16);\n\t\tmemcpy(data + 16, key->key + 24, 8);\n\t\tmemcpy(data + 24, key->key + 16, 8);\n\t} else {\n\t\tif (cipher_mask == BIT(cipher))\n\t\t\tmemcpy(data, key->key, key->keylen);\n\t\telse if (cipher != MT_CIPHER_BIP_CMAC_128)\n\t\t\tmemcpy(data, key->key, 16);\n\t\tif (cipher == MT_CIPHER_BIP_CMAC_128)\n\t\t\tmemcpy(data + 16, key->key, 16);\n\t}\n\n\tmt76_wr_copy(dev, addr, data, sizeof(data));\n\n\treturn 0;\n}\n\nstatic int\nmt7615_mac_wtbl_update_pk(struct mt7615_dev *dev, struct mt76_wcid *wcid,\n\t\t\t  enum mt76_cipher_type cipher, u16 cipher_mask,\n\t\t\t  int keyidx)\n{\n\tu32 addr = mt7615_mac_wtbl_addr(dev, wcid->idx), w0, w1;\n\n\tif (!mt76_poll(dev, MT_WTBL_UPDATE, MT_WTBL_UPDATE_BUSY, 0, 5000))\n\t\treturn -ETIMEDOUT;\n\n\tw0 = mt76_rr(dev, addr);\n\tw1 = mt76_rr(dev, addr + 4);\n\n\tif (cipher_mask)\n\t\tw0 |= MT_WTBL_W0_RX_KEY_VALID;\n\telse\n\t\tw0 &= ~(MT_WTBL_W0_RX_KEY_VALID | MT_WTBL_W0_KEY_IDX);\n\tif (cipher_mask & BIT(MT_CIPHER_BIP_CMAC_128))\n\t\tw0 |= MT_WTBL_W0_RX_IK_VALID;\n\telse\n\t\tw0 &= ~MT_WTBL_W0_RX_IK_VALID;\n\n\tif (cipher != MT_CIPHER_BIP_CMAC_128 || cipher_mask == BIT(cipher)) {\n\t\tw0 &= ~MT_WTBL_W0_KEY_IDX;\n\t\tw0 |= FIELD_PREP(MT_WTBL_W0_KEY_IDX, keyidx);\n\t}\n\n\tmt76_wr(dev, MT_WTBL_RICR0, w0);\n\tmt76_wr(dev, MT_WTBL_RICR1, w1);\n\n\tif (!mt7615_mac_wtbl_update(dev, wcid->idx,\n\t\t\t\t    MT_WTBL_UPDATE_RXINFO_UPDATE))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic void\nmt7615_mac_wtbl_update_cipher(struct mt7615_dev *dev, struct mt76_wcid *wcid,\n\t\t\t      enum mt76_cipher_type cipher, u16 cipher_mask)\n{\n\tu32 addr = mt7615_mac_wtbl_addr(dev, wcid->idx);\n\n\tif (cipher == MT_CIPHER_BIP_CMAC_128 &&\n\t    cipher_mask & ~BIT(MT_CIPHER_BIP_CMAC_128))\n\t\treturn;\n\n\tmt76_rmw(dev, addr + 2 * 4, MT_WTBL_W2_KEY_TYPE,\n\t\t FIELD_PREP(MT_WTBL_W2_KEY_TYPE, cipher));\n}\n\nint __mt7615_mac_wtbl_set_key(struct mt7615_dev *dev,\n\t\t\t      struct mt76_wcid *wcid,\n\t\t\t      struct ieee80211_key_conf *key)\n{\n\tenum mt76_cipher_type cipher;\n\tu16 cipher_mask = wcid->cipher;\n\tint err;\n\n\tcipher = mt7615_mac_get_cipher(key->cipher);\n\tif (cipher == MT_CIPHER_NONE)\n\t\treturn -EOPNOTSUPP;\n\n\tcipher_mask |= BIT(cipher);\n\tmt7615_mac_wtbl_update_cipher(dev, wcid, cipher, cipher_mask);\n\terr = mt7615_mac_wtbl_update_key(dev, wcid, key, cipher, cipher_mask);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = mt7615_mac_wtbl_update_pk(dev, wcid, cipher, cipher_mask,\n\t\t\t\t\tkey->keyidx);\n\tif (err < 0)\n\t\treturn err;\n\n\twcid->cipher = cipher_mask;\n\n\treturn 0;\n}\n\nint mt7615_mac_wtbl_set_key(struct mt7615_dev *dev,\n\t\t\t    struct mt76_wcid *wcid,\n\t\t\t    struct ieee80211_key_conf *key)\n{\n\tint err;\n\n\tspin_lock_bh(&dev->mt76.lock);\n\terr = __mt7615_mac_wtbl_set_key(dev, wcid, key);\n\tspin_unlock_bh(&dev->mt76.lock);\n\n\treturn err;\n}\n\nstatic bool mt7615_fill_txs(struct mt7615_dev *dev, struct mt7615_sta *sta,\n\t\t\t    struct ieee80211_tx_info *info, __le32 *txs_data)\n{\n\tstruct ieee80211_supported_band *sband;\n\tstruct mt7615_rate_set *rs;\n\tstruct mt76_phy *mphy;\n\tint first_idx = 0, last_idx;\n\tint i, idx, count;\n\tbool fixed_rate, ack_timeout;\n\tbool ampdu, cck = false;\n\tbool rs_idx;\n\tu32 rate_set_tsf;\n\tu32 final_rate, final_rate_flags, final_nss, txs;\n\n\ttxs = le32_to_cpu(txs_data[1]);\n\tampdu = txs & MT_TXS1_AMPDU;\n\n\ttxs = le32_to_cpu(txs_data[3]);\n\tcount = FIELD_GET(MT_TXS3_TX_COUNT, txs);\n\tlast_idx = FIELD_GET(MT_TXS3_LAST_TX_RATE, txs);\n\n\ttxs = le32_to_cpu(txs_data[0]);\n\tfixed_rate = txs & MT_TXS0_FIXED_RATE;\n\tfinal_rate = FIELD_GET(MT_TXS0_TX_RATE, txs);\n\tack_timeout = txs & MT_TXS0_ACK_TIMEOUT;\n\n\tif (!ampdu && (txs & MT_TXS0_RTS_TIMEOUT))\n\t\treturn false;\n\n\tif (txs & MT_TXS0_QUEUE_TIMEOUT)\n\t\treturn false;\n\n\tif (!ack_timeout)\n\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\n\tinfo->status.ampdu_len = 1;\n\tinfo->status.ampdu_ack_len = !!(info->flags &\n\t\t\t\t\tIEEE80211_TX_STAT_ACK);\n\n\tif (ampdu || (info->flags & IEEE80211_TX_CTL_AMPDU))\n\t\tinfo->flags |= IEEE80211_TX_STAT_AMPDU | IEEE80211_TX_CTL_AMPDU;\n\n\tfirst_idx = max_t(int, 0, last_idx - (count - 1) / MT7615_RATE_RETRY);\n\n\tif (fixed_rate) {\n\t\tinfo->status.rates[0].count = count;\n\t\ti = 0;\n\t\tgoto out;\n\t}\n\n\trate_set_tsf = READ_ONCE(sta->rate_set_tsf);\n\trs_idx = !((u32)(le32_get_bits(txs_data[4], MT_TXS4_F0_TIMESTAMP) -\n\t\t\t rate_set_tsf) < 1000000);\n\trs_idx ^= rate_set_tsf & BIT(0);\n\trs = &sta->rateset[rs_idx];\n\n\tif (!first_idx && rs->probe_rate.idx >= 0) {\n\t\tinfo->status.rates[0] = rs->probe_rate;\n\n\t\tspin_lock_bh(&dev->mt76.lock);\n\t\tif (sta->rate_probe) {\n\t\t\tstruct mt7615_phy *phy = &dev->phy;\n\n\t\t\tif (sta->wcid.phy_idx && dev->mt76.phys[MT_BAND1])\n\t\t\t\tphy = dev->mt76.phys[MT_BAND1]->priv;\n\n\t\t\tmt7615_mac_set_rates(phy, sta, NULL, sta->rates);\n\t\t}\n\t\tspin_unlock_bh(&dev->mt76.lock);\n\t} else {\n\t\tinfo->status.rates[0] = rs->rates[first_idx / 2];\n\t}\n\tinfo->status.rates[0].count = 0;\n\n\tfor (i = 0, idx = first_idx; count && idx <= last_idx; idx++) {\n\t\tstruct ieee80211_tx_rate *cur_rate;\n\t\tint cur_count;\n\n\t\tcur_rate = &rs->rates[idx / 2];\n\t\tcur_count = min_t(int, MT7615_RATE_RETRY, count);\n\t\tcount -= cur_count;\n\n\t\tif (idx && (cur_rate->idx != info->status.rates[i].idx ||\n\t\t\t    cur_rate->flags != info->status.rates[i].flags)) {\n\t\t\ti++;\n\t\t\tif (i == ARRAY_SIZE(info->status.rates)) {\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tinfo->status.rates[i] = *cur_rate;\n\t\t\tinfo->status.rates[i].count = 0;\n\t\t}\n\n\t\tinfo->status.rates[i].count += cur_count;\n\t}\n\nout:\n\tfinal_rate_flags = info->status.rates[i].flags;\n\n\tswitch (FIELD_GET(MT_TX_RATE_MODE, final_rate)) {\n\tcase MT_PHY_TYPE_CCK:\n\t\tcck = true;\n\t\tfallthrough;\n\tcase MT_PHY_TYPE_OFDM:\n\t\tmphy = &dev->mphy;\n\t\tif (sta->wcid.phy_idx && dev->mt76.phys[MT_BAND1])\n\t\t\tmphy = dev->mt76.phys[MT_BAND1];\n\n\t\tif (mphy->chandef.chan->band == NL80211_BAND_5GHZ)\n\t\t\tsband = &mphy->sband_5g.sband;\n\t\telse\n\t\t\tsband = &mphy->sband_2g.sband;\n\t\tfinal_rate &= MT_TX_RATE_IDX;\n\t\tfinal_rate = mt76_get_rate(&dev->mt76, sband, final_rate,\n\t\t\t\t\t   cck);\n\t\tfinal_rate_flags = 0;\n\t\tbreak;\n\tcase MT_PHY_TYPE_HT_GF:\n\tcase MT_PHY_TYPE_HT:\n\t\tfinal_rate_flags |= IEEE80211_TX_RC_MCS;\n\t\tfinal_rate &= MT_TX_RATE_IDX;\n\t\tif (final_rate > 31)\n\t\t\treturn false;\n\t\tbreak;\n\tcase MT_PHY_TYPE_VHT:\n\t\tfinal_nss = FIELD_GET(MT_TX_RATE_NSS, final_rate);\n\n\t\tif ((final_rate & MT_TX_RATE_STBC) && final_nss)\n\t\t\tfinal_nss--;\n\n\t\tfinal_rate_flags |= IEEE80211_TX_RC_VHT_MCS;\n\t\tfinal_rate = (final_rate & MT_TX_RATE_IDX) | (final_nss << 4);\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tinfo->status.rates[i].idx = final_rate;\n\tinfo->status.rates[i].flags = final_rate_flags;\n\n\treturn true;\n}\n\nstatic bool mt7615_mac_add_txs_skb(struct mt7615_dev *dev,\n\t\t\t\t   struct mt7615_sta *sta, int pid,\n\t\t\t\t   __le32 *txs_data)\n{\n\tstruct mt76_dev *mdev = &dev->mt76;\n\tstruct sk_buff_head list;\n\tstruct sk_buff *skb;\n\n\tif (pid < MT_PACKET_ID_FIRST)\n\t\treturn false;\n\n\ttrace_mac_txdone(mdev, sta->wcid.idx, pid);\n\n\tmt76_tx_status_lock(mdev, &list);\n\tskb = mt76_tx_status_skb_get(mdev, &sta->wcid, pid, &list);\n\tif (skb) {\n\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\n\t\tif (!mt7615_fill_txs(dev, sta, info, txs_data)) {\n\t\t\tinfo->status.rates[0].count = 0;\n\t\t\tinfo->status.rates[0].idx = -1;\n\t\t}\n\n\t\tmt76_tx_status_skb_done(mdev, skb, &list);\n\t}\n\tmt76_tx_status_unlock(mdev, &list);\n\n\treturn !!skb;\n}\n\nstatic void mt7615_mac_add_txs(struct mt7615_dev *dev, void *data)\n{\n\tstruct ieee80211_tx_info info = {};\n\tstruct ieee80211_sta *sta = NULL;\n\tstruct mt7615_sta *msta = NULL;\n\tstruct mt76_wcid *wcid;\n\tstruct mt76_phy *mphy = &dev->mt76.phy;\n\t__le32 *txs_data = data;\n\tu8 wcidx;\n\tu8 pid;\n\n\tpid = le32_get_bits(txs_data[0], MT_TXS0_PID);\n\twcidx = le32_get_bits(txs_data[2], MT_TXS2_WCID);\n\n\tif (pid == MT_PACKET_ID_NO_ACK)\n\t\treturn;\n\n\tif (wcidx >= MT7615_WTBL_SIZE)\n\t\treturn;\n\n\trcu_read_lock();\n\n\twcid = rcu_dereference(dev->mt76.wcid[wcidx]);\n\tif (!wcid)\n\t\tgoto out;\n\n\tmsta = container_of(wcid, struct mt7615_sta, wcid);\n\tsta = wcid_to_sta(wcid);\n\n\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\tif (list_empty(&msta->wcid.poll_list))\n\t\tlist_add_tail(&msta->wcid.poll_list, &dev->mt76.sta_poll_list);\n\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\n\tif (mt7615_mac_add_txs_skb(dev, msta, pid, txs_data))\n\t\tgoto out;\n\n\tif (wcidx >= MT7615_WTBL_STA || !sta)\n\t\tgoto out;\n\n\tif (wcid->phy_idx && dev->mt76.phys[MT_BAND1])\n\t\tmphy = dev->mt76.phys[MT_BAND1];\n\n\tif (mt7615_fill_txs(dev, msta, &info, txs_data)) {\n\t\tspin_lock_bh(&dev->mt76.rx_lock);\n\t\tieee80211_tx_status_noskb(mphy->hw, sta, &info);\n\t\tspin_unlock_bh(&dev->mt76.rx_lock);\n\t}\n\nout:\n\trcu_read_unlock();\n}\n\nstatic void\nmt7615_txwi_free(struct mt7615_dev *dev, struct mt76_txwi_cache *txwi)\n{\n\tstruct mt76_dev *mdev = &dev->mt76;\n\t__le32 *txwi_data;\n\tu32 val;\n\tu8 wcid;\n\n\tmt76_connac_txp_skb_unmap(mdev, txwi);\n\tif (!txwi->skb)\n\t\tgoto out;\n\n\ttxwi_data = (__le32 *)mt76_get_txwi_ptr(mdev, txwi);\n\tval = le32_to_cpu(txwi_data[1]);\n\twcid = FIELD_GET(MT_TXD1_WLAN_IDX, val);\n\tmt76_tx_complete_skb(mdev, wcid, txwi->skb);\n\nout:\n\ttxwi->skb = NULL;\n\tmt76_put_txwi(mdev, txwi);\n}\n\nstatic void\nmt7615_mac_tx_free_token(struct mt7615_dev *dev, u16 token)\n{\n\tstruct mt76_dev *mdev = &dev->mt76;\n\tstruct mt76_txwi_cache *txwi;\n\n\ttrace_mac_tx_free(dev, token);\n\ttxwi = mt76_token_put(mdev, token);\n\tif (!txwi)\n\t\treturn;\n\n\tmt7615_txwi_free(dev, txwi);\n}\n\nstatic void mt7615_mac_tx_free(struct mt7615_dev *dev, void *data, int len)\n{\n\tstruct mt76_connac_tx_free *free = data;\n\tvoid *tx_token = data + sizeof(*free);\n\tvoid *end = data + len;\n\tu8 i, count;\n\n\tmt76_queue_tx_cleanup(dev, dev->mphy.q_tx[MT_TXQ_PSD], false);\n\tif (is_mt7615(&dev->mt76)) {\n\t\tmt76_queue_tx_cleanup(dev, dev->mphy.q_tx[MT_TXQ_BE], false);\n\t} else {\n\t\tfor (i = 0; i < IEEE80211_NUM_ACS; i++)\n\t\t\tmt76_queue_tx_cleanup(dev, dev->mphy.q_tx[i], false);\n\t}\n\n\tcount = le16_get_bits(free->ctrl, MT_TX_FREE_MSDU_ID_CNT);\n\tif (is_mt7615(&dev->mt76)) {\n\t\t__le16 *token = tx_token;\n\n\t\tif (WARN_ON_ONCE((void *)&token[count] > end))\n\t\t\treturn;\n\n\t\tfor (i = 0; i < count; i++)\n\t\t\tmt7615_mac_tx_free_token(dev, le16_to_cpu(token[i]));\n\t} else {\n\t\t__le32 *token = tx_token;\n\n\t\tif (WARN_ON_ONCE((void *)&token[count] > end))\n\t\t\treturn;\n\n\t\tfor (i = 0; i < count; i++)\n\t\t\tmt7615_mac_tx_free_token(dev, le32_to_cpu(token[i]));\n\t}\n\n\trcu_read_lock();\n\tmt7615_mac_sta_poll(dev);\n\trcu_read_unlock();\n\n\tmt76_worker_schedule(&dev->mt76.tx_worker);\n}\n\nbool mt7615_rx_check(struct mt76_dev *mdev, void *data, int len)\n{\n\tstruct mt7615_dev *dev = container_of(mdev, struct mt7615_dev, mt76);\n\t__le32 *rxd = (__le32 *)data;\n\t__le32 *end = (__le32 *)&rxd[len / 4];\n\tenum rx_pkt_type type;\n\n\ttype = le32_get_bits(rxd[0], MT_RXD0_PKT_TYPE);\n\n\tswitch (type) {\n\tcase PKT_TYPE_TXRX_NOTIFY:\n\t\tmt7615_mac_tx_free(dev, data, len);\n\t\treturn false;\n\tcase PKT_TYPE_TXS:\n\t\tfor (rxd++; rxd + 7 <= end; rxd += 7)\n\t\t\tmt7615_mac_add_txs(dev, rxd);\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\nEXPORT_SYMBOL_GPL(mt7615_rx_check);\n\nvoid mt7615_queue_rx_skb(struct mt76_dev *mdev, enum mt76_rxq_id q,\n\t\t\t struct sk_buff *skb, u32 *info)\n{\n\tstruct mt7615_dev *dev = container_of(mdev, struct mt7615_dev, mt76);\n\t__le32 *rxd = (__le32 *)skb->data;\n\t__le32 *end = (__le32 *)&skb->data[skb->len];\n\tenum rx_pkt_type type;\n\tu16 flag;\n\n\ttype = le32_get_bits(rxd[0], MT_RXD0_PKT_TYPE);\n\tflag = le32_get_bits(rxd[0], MT_RXD0_PKT_FLAG);\n\tif (type == PKT_TYPE_RX_EVENT && flag == 0x1)\n\t\ttype = PKT_TYPE_NORMAL_MCU;\n\n\tswitch (type) {\n\tcase PKT_TYPE_TXS:\n\t\tfor (rxd++; rxd + 7 <= end; rxd += 7)\n\t\t\tmt7615_mac_add_txs(dev, rxd);\n\t\tdev_kfree_skb(skb);\n\t\tbreak;\n\tcase PKT_TYPE_TXRX_NOTIFY:\n\t\tmt7615_mac_tx_free(dev, skb->data, skb->len);\n\t\tdev_kfree_skb(skb);\n\t\tbreak;\n\tcase PKT_TYPE_RX_EVENT:\n\t\tmt7615_mcu_rx_event(dev, skb);\n\t\tbreak;\n\tcase PKT_TYPE_NORMAL_MCU:\n\tcase PKT_TYPE_NORMAL:\n\t\tif (!mt7615_mac_fill_rx(dev, skb)) {\n\t\t\tmt76_rx(&dev->mt76, q, skb);\n\t\t\treturn;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdev_kfree_skb(skb);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(mt7615_queue_rx_skb);\n\nstatic void\nmt7615_mac_set_sensitivity(struct mt7615_phy *phy, int val, bool ofdm)\n{\n\tstruct mt7615_dev *dev = phy->dev;\n\tbool ext_phy = phy != &dev->phy;\n\n\tif (is_mt7663(&dev->mt76)) {\n\t\tif (ofdm)\n\t\t\tmt76_rmw(dev, MT7663_WF_PHY_MIN_PRI_PWR(ext_phy),\n\t\t\t\t MT_WF_PHY_PD_OFDM_MASK(0),\n\t\t\t\t MT_WF_PHY_PD_OFDM(0, val));\n\t\telse\n\t\t\tmt76_rmw(dev, MT7663_WF_PHY_RXTD_CCK_PD(ext_phy),\n\t\t\t\t MT_WF_PHY_PD_CCK_MASK(ext_phy),\n\t\t\t\t MT_WF_PHY_PD_CCK(ext_phy, val));\n\t\treturn;\n\t}\n\n\tif (ofdm)\n\t\tmt76_rmw(dev, MT_WF_PHY_MIN_PRI_PWR(ext_phy),\n\t\t\t MT_WF_PHY_PD_OFDM_MASK(ext_phy),\n\t\t\t MT_WF_PHY_PD_OFDM(ext_phy, val));\n\telse\n\t\tmt76_rmw(dev, MT_WF_PHY_RXTD_CCK_PD(ext_phy),\n\t\t\t MT_WF_PHY_PD_CCK_MASK(ext_phy),\n\t\t\t MT_WF_PHY_PD_CCK(ext_phy, val));\n}\n\nstatic void\nmt7615_mac_set_default_sensitivity(struct mt7615_phy *phy)\n{\n\t \n\tmt7615_mac_set_sensitivity(phy, 0x13c, true);\n\t \n\tmt7615_mac_set_sensitivity(phy, 0x92, false);\n\n\tphy->ofdm_sensitivity = -98;\n\tphy->cck_sensitivity = -110;\n\tphy->last_cca_adj = jiffies;\n}\n\nvoid mt7615_mac_set_scs(struct mt7615_phy *phy, bool enable)\n{\n\tstruct mt7615_dev *dev = phy->dev;\n\tbool ext_phy = phy != &dev->phy;\n\tu32 reg, mask;\n\n\tmt7615_mutex_acquire(dev);\n\n\tif (phy->scs_en == enable)\n\t\tgoto out;\n\n\tif (is_mt7663(&dev->mt76)) {\n\t\treg = MT7663_WF_PHY_MIN_PRI_PWR(ext_phy);\n\t\tmask = MT_WF_PHY_PD_BLK(0);\n\t} else {\n\t\treg = MT_WF_PHY_MIN_PRI_PWR(ext_phy);\n\t\tmask = MT_WF_PHY_PD_BLK(ext_phy);\n\t}\n\n\tif (enable) {\n\t\tmt76_set(dev, reg, mask);\n\t\tif (is_mt7622(&dev->mt76)) {\n\t\t\tmt76_set(dev, MT_MIB_M0_MISC_CR(0), 0x7 << 8);\n\t\t\tmt76_set(dev, MT_MIB_M0_MISC_CR(0), 0x7);\n\t\t}\n\t} else {\n\t\tmt76_clear(dev, reg, mask);\n\t}\n\n\tmt7615_mac_set_default_sensitivity(phy);\n\tphy->scs_en = enable;\n\nout:\n\tmt7615_mutex_release(dev);\n}\n\nvoid mt7615_mac_enable_nf(struct mt7615_dev *dev, bool ext_phy)\n{\n\tu32 rxtd, reg;\n\n\tif (is_mt7663(&dev->mt76))\n\t\treg = MT7663_WF_PHY_R0_PHYMUX_5;\n\telse\n\t\treg = MT_WF_PHY_R0_PHYMUX_5(ext_phy);\n\n\tif (ext_phy)\n\t\trxtd = MT_WF_PHY_RXTD2(10);\n\telse\n\t\trxtd = MT_WF_PHY_RXTD(12);\n\n\tmt76_set(dev, rxtd, BIT(18) | BIT(29));\n\tmt76_set(dev, reg, 0x5 << 12);\n}\n\nvoid mt7615_mac_cca_stats_reset(struct mt7615_phy *phy)\n{\n\tstruct mt7615_dev *dev = phy->dev;\n\tbool ext_phy = phy != &dev->phy;\n\tu32 reg;\n\n\tif (is_mt7663(&dev->mt76))\n\t\treg = MT7663_WF_PHY_R0_PHYMUX_5;\n\telse\n\t\treg = MT_WF_PHY_R0_PHYMUX_5(ext_phy);\n\n\t \n\tmt76_clear(dev, reg, GENMASK(22, 20));\n\tmt76_set(dev, reg, BIT(22) | BIT(20));\n}\n\nstatic void\nmt7615_mac_adjust_sensitivity(struct mt7615_phy *phy,\n\t\t\t      u32 rts_err_rate, bool ofdm)\n{\n\tstruct mt7615_dev *dev = phy->dev;\n\tint false_cca = ofdm ? phy->false_cca_ofdm : phy->false_cca_cck;\n\tbool ext_phy = phy != &dev->phy;\n\ts16 def_th = ofdm ? -98 : -110;\n\tbool update = false;\n\ts8 *sensitivity;\n\tint signal;\n\n\tsensitivity = ofdm ? &phy->ofdm_sensitivity : &phy->cck_sensitivity;\n\tsignal = mt76_get_min_avg_rssi(&dev->mt76, ext_phy);\n\tif (!signal) {\n\t\tmt7615_mac_set_default_sensitivity(phy);\n\t\treturn;\n\t}\n\n\tsignal = min(signal, -72);\n\tif (false_cca > 500) {\n\t\tif (rts_err_rate > MT_FRAC(40, 100))\n\t\t\treturn;\n\n\t\t \n\t\tif (*sensitivity == def_th && signal > -90) {\n\t\t\t*sensitivity = -90;\n\t\t\tupdate = true;\n\t\t} else if (*sensitivity + 2 < signal) {\n\t\t\t*sensitivity += 2;\n\t\t\tupdate = true;\n\t\t}\n\t} else if ((false_cca > 0 && false_cca < 50) ||\n\t\t   rts_err_rate > MT_FRAC(60, 100)) {\n\t\t \n\t\tif (*sensitivity - 2 >= def_th) {\n\t\t\t*sensitivity -= 2;\n\t\t\tupdate = true;\n\t\t}\n\t}\n\n\tif (*sensitivity > signal) {\n\t\t*sensitivity = signal;\n\t\tupdate = true;\n\t}\n\n\tif (update) {\n\t\tu16 val = ofdm ? *sensitivity * 2 + 512 : *sensitivity + 256;\n\n\t\tmt7615_mac_set_sensitivity(phy, val, ofdm);\n\t\tphy->last_cca_adj = jiffies;\n\t}\n}\n\nstatic void\nmt7615_mac_scs_check(struct mt7615_phy *phy)\n{\n\tstruct mt7615_dev *dev = phy->dev;\n\tstruct mib_stats *mib = &phy->mib;\n\tu32 val, rts_err_rate = 0;\n\tu32 mdrdy_cck, mdrdy_ofdm, pd_cck, pd_ofdm;\n\tbool ext_phy = phy != &dev->phy;\n\n\tif (!phy->scs_en)\n\t\treturn;\n\n\tif (is_mt7663(&dev->mt76))\n\t\tval = mt76_rr(dev, MT7663_WF_PHY_R0_PHYCTRL_STS0(ext_phy));\n\telse\n\t\tval = mt76_rr(dev, MT_WF_PHY_R0_PHYCTRL_STS0(ext_phy));\n\tpd_cck = FIELD_GET(MT_WF_PHYCTRL_STAT_PD_CCK, val);\n\tpd_ofdm = FIELD_GET(MT_WF_PHYCTRL_STAT_PD_OFDM, val);\n\n\tif (is_mt7663(&dev->mt76))\n\t\tval = mt76_rr(dev, MT7663_WF_PHY_R0_PHYCTRL_STS5(ext_phy));\n\telse\n\t\tval = mt76_rr(dev, MT_WF_PHY_R0_PHYCTRL_STS5(ext_phy));\n\tmdrdy_cck = FIELD_GET(MT_WF_PHYCTRL_STAT_MDRDY_CCK, val);\n\tmdrdy_ofdm = FIELD_GET(MT_WF_PHYCTRL_STAT_MDRDY_OFDM, val);\n\n\tphy->false_cca_ofdm = pd_ofdm - mdrdy_ofdm;\n\tphy->false_cca_cck = pd_cck - mdrdy_cck;\n\tmt7615_mac_cca_stats_reset(phy);\n\n\tif (mib->rts_cnt + mib->rts_retries_cnt)\n\t\trts_err_rate = MT_FRAC(mib->rts_retries_cnt,\n\t\t\t\t       mib->rts_cnt + mib->rts_retries_cnt);\n\n\t \n\tmt7615_mac_adjust_sensitivity(phy, rts_err_rate, false);\n\t \n\tmt7615_mac_adjust_sensitivity(phy, rts_err_rate, true);\n\n\tif (time_after(jiffies, phy->last_cca_adj + 10 * HZ))\n\t\tmt7615_mac_set_default_sensitivity(phy);\n}\n\nstatic u8\nmt7615_phy_get_nf(struct mt7615_dev *dev, int idx)\n{\n\tstatic const u8 nf_power[] = { 92, 89, 86, 83, 80, 75, 70, 65, 60, 55, 52 };\n\tu32 reg, val, sum = 0, n = 0;\n\tint i;\n\n\tif (is_mt7663(&dev->mt76))\n\t\treg = MT7663_WF_PHY_RXTD(20);\n\telse\n\t\treg = idx ? MT_WF_PHY_RXTD2(17) : MT_WF_PHY_RXTD(20);\n\n\tfor (i = 0; i < ARRAY_SIZE(nf_power); i++, reg += 4) {\n\t\tval = mt76_rr(dev, reg);\n\t\tsum += val * nf_power[i];\n\t\tn += val;\n\t}\n\n\tif (!n)\n\t\treturn 0;\n\n\treturn sum / n;\n}\n\nstatic void\nmt7615_phy_update_channel(struct mt76_phy *mphy, int idx)\n{\n\tstruct mt7615_dev *dev = container_of(mphy->dev, struct mt7615_dev, mt76);\n\tstruct mt7615_phy *phy = mphy->priv;\n\tstruct mt76_channel_state *state;\n\tu64 busy_time, tx_time, rx_time, obss_time;\n\tu32 obss_reg = idx ? MT_WF_RMAC_MIB_TIME6 : MT_WF_RMAC_MIB_TIME5;\n\tint nf;\n\n\tbusy_time = mt76_get_field(dev, MT_MIB_SDR9(idx),\n\t\t\t\t   MT_MIB_SDR9_BUSY_MASK);\n\ttx_time = mt76_get_field(dev, MT_MIB_SDR36(idx),\n\t\t\t\t MT_MIB_SDR36_TXTIME_MASK);\n\trx_time = mt76_get_field(dev, MT_MIB_SDR37(idx),\n\t\t\t\t MT_MIB_SDR37_RXTIME_MASK);\n\tobss_time = mt76_get_field(dev, obss_reg, MT_MIB_OBSSTIME_MASK);\n\n\tnf = mt7615_phy_get_nf(dev, idx);\n\tif (!phy->noise)\n\t\tphy->noise = nf << 4;\n\telse if (nf)\n\t\tphy->noise += nf - (phy->noise >> 4);\n\n\tstate = mphy->chan_state;\n\tstate->cc_busy += busy_time;\n\tstate->cc_tx += tx_time;\n\tstate->cc_rx += rx_time + obss_time;\n\tstate->cc_bss_rx += rx_time;\n\tstate->noise = -(phy->noise >> 4);\n}\n\nstatic void mt7615_update_survey(struct mt7615_dev *dev)\n{\n\tstruct mt76_dev *mdev = &dev->mt76;\n\tstruct mt76_phy *mphy_ext = mdev->phys[MT_BAND1];\n\tktime_t cur_time;\n\n\t \n\n\tmt7615_phy_update_channel(&mdev->phy, 0);\n\tif (mphy_ext)\n\t\tmt7615_phy_update_channel(mphy_ext, 1);\n\n\tcur_time = ktime_get_boottime();\n\n\tmt76_update_survey_active_time(&mdev->phy, cur_time);\n\tif (mphy_ext)\n\t\tmt76_update_survey_active_time(mphy_ext, cur_time);\n\n\t \n\tmt76_set(dev, MT_WF_RMAC_MIB_TIME0, MT_WF_RMAC_MIB_RXTIME_CLR);\n}\n\nvoid mt7615_update_channel(struct mt76_phy *mphy)\n{\n\tstruct mt7615_dev *dev = container_of(mphy->dev, struct mt7615_dev, mt76);\n\n\tif (mt76_connac_pm_wake(&dev->mphy, &dev->pm))\n\t\treturn;\n\n\tmt7615_update_survey(dev);\n\tmt76_connac_power_save_sched(&dev->mphy, &dev->pm);\n}\nEXPORT_SYMBOL_GPL(mt7615_update_channel);\n\nstatic void\nmt7615_mac_update_mib_stats(struct mt7615_phy *phy)\n{\n\tstruct mt7615_dev *dev = phy->dev;\n\tstruct mib_stats *mib = &phy->mib;\n\tbool ext_phy = phy != &dev->phy;\n\tint i, aggr = 0;\n\tu32 val, val2;\n\n\tmib->fcs_err_cnt += mt76_get_field(dev, MT_MIB_SDR3(ext_phy),\n\t\t\t\t\t   MT_MIB_SDR3_FCS_ERR_MASK);\n\n\tval = mt76_get_field(dev, MT_MIB_SDR14(ext_phy),\n\t\t\t     MT_MIB_AMPDU_MPDU_COUNT);\n\tif (val) {\n\t\tval2 = mt76_get_field(dev, MT_MIB_SDR15(ext_phy),\n\t\t\t\t      MT_MIB_AMPDU_ACK_COUNT);\n\t\tmib->aggr_per = 1000 * (val - val2) / val;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tval = mt76_rr(dev, MT_MIB_MB_SDR1(ext_phy, i));\n\t\tmib->ba_miss_cnt += FIELD_GET(MT_MIB_BA_MISS_COUNT_MASK, val);\n\t\tmib->ack_fail_cnt += FIELD_GET(MT_MIB_ACK_FAIL_COUNT_MASK,\n\t\t\t\t\t       val);\n\n\t\tval = mt76_rr(dev, MT_MIB_MB_SDR0(ext_phy, i));\n\t\tmib->rts_cnt += FIELD_GET(MT_MIB_RTS_COUNT_MASK, val);\n\t\tmib->rts_retries_cnt += FIELD_GET(MT_MIB_RTS_RETRIES_COUNT_MASK,\n\t\t\t\t\t\t  val);\n\n\t\tval = mt76_rr(dev, MT_TX_AGG_CNT(ext_phy, i));\n\t\tphy->mt76->aggr_stats[aggr++] += val & 0xffff;\n\t\tphy->mt76->aggr_stats[aggr++] += val >> 16;\n\t}\n}\n\nvoid mt7615_pm_wake_work(struct work_struct *work)\n{\n\tstruct mt7615_dev *dev;\n\tstruct mt76_phy *mphy;\n\n\tdev = (struct mt7615_dev *)container_of(work, struct mt7615_dev,\n\t\t\t\t\t\tpm.wake_work);\n\tmphy = dev->phy.mt76;\n\n\tif (!mt7615_mcu_set_drv_ctrl(dev)) {\n\t\tstruct mt76_dev *mdev = &dev->mt76;\n\t\tint i;\n\n\t\tif (mt76_is_sdio(mdev)) {\n\t\t\tmt76_connac_pm_dequeue_skbs(mphy, &dev->pm);\n\t\t\tmt76_worker_schedule(&mdev->sdio.txrx_worker);\n\t\t} else {\n\t\t\tlocal_bh_disable();\n\t\t\tmt76_for_each_q_rx(mdev, i)\n\t\t\t\tnapi_schedule(&mdev->napi[i]);\n\t\t\tlocal_bh_enable();\n\t\t\tmt76_connac_pm_dequeue_skbs(mphy, &dev->pm);\n\t\t\tmt76_queue_tx_cleanup(dev, mdev->q_mcu[MT_MCUQ_WM],\n\t\t\t\t\t      false);\n\t\t}\n\n\t\tif (test_bit(MT76_STATE_RUNNING, &mphy->state)) {\n\t\t\tunsigned long timeout;\n\n\t\t\ttimeout = mt7615_get_macwork_timeout(dev);\n\t\t\tieee80211_queue_delayed_work(mphy->hw, &mphy->mac_work,\n\t\t\t\t\t\t     timeout);\n\t\t}\n\t}\n\n\tieee80211_wake_queues(mphy->hw);\n\twake_up(&dev->pm.wait);\n}\n\nvoid mt7615_pm_power_save_work(struct work_struct *work)\n{\n\tstruct mt7615_dev *dev;\n\tunsigned long delta;\n\n\tdev = (struct mt7615_dev *)container_of(work, struct mt7615_dev,\n\t\t\t\t\t\tpm.ps_work.work);\n\n\tdelta = dev->pm.idle_timeout;\n\tif (test_bit(MT76_HW_SCANNING, &dev->mphy.state) ||\n\t    test_bit(MT76_HW_SCHED_SCANNING, &dev->mphy.state))\n\t\tgoto out;\n\n\tif (mutex_is_locked(&dev->mt76.mutex))\n\t\t \n\t\tgoto out;\n\n\tif (time_is_after_jiffies(dev->pm.last_activity + delta)) {\n\t\tdelta = dev->pm.last_activity + delta - jiffies;\n\t\tgoto out;\n\t}\n\n\tif (!mt7615_mcu_set_fw_ctrl(dev))\n\t\treturn;\nout:\n\tqueue_delayed_work(dev->mt76.wq, &dev->pm.ps_work, delta);\n}\n\nvoid mt7615_mac_work(struct work_struct *work)\n{\n\tstruct mt7615_phy *phy;\n\tstruct mt76_phy *mphy;\n\tunsigned long timeout;\n\n\tmphy = (struct mt76_phy *)container_of(work, struct mt76_phy,\n\t\t\t\t\t       mac_work.work);\n\tphy = mphy->priv;\n\n\tmt7615_mutex_acquire(phy->dev);\n\n\tmt7615_update_survey(phy->dev);\n\tif (++mphy->mac_work_count == 5) {\n\t\tmphy->mac_work_count = 0;\n\n\t\tmt7615_mac_update_mib_stats(phy);\n\t\tmt7615_mac_scs_check(phy);\n\t}\n\n\tmt7615_mutex_release(phy->dev);\n\n\tmt76_tx_status_check(mphy->dev, false);\n\n\ttimeout = mt7615_get_macwork_timeout(phy->dev);\n\tieee80211_queue_delayed_work(mphy->hw, &mphy->mac_work, timeout);\n}\n\nvoid mt7615_tx_token_put(struct mt7615_dev *dev)\n{\n\tstruct mt76_txwi_cache *txwi;\n\tint id;\n\n\tspin_lock_bh(&dev->mt76.token_lock);\n\tidr_for_each_entry(&dev->mt76.token, txwi, id)\n\t\tmt7615_txwi_free(dev, txwi);\n\tspin_unlock_bh(&dev->mt76.token_lock);\n\tidr_destroy(&dev->mt76.token);\n}\nEXPORT_SYMBOL_GPL(mt7615_tx_token_put);\n\nstatic void mt7615_dfs_stop_radar_detector(struct mt7615_phy *phy)\n{\n\tstruct mt7615_dev *dev = phy->dev;\n\n\tif (phy->rdd_state & BIT(0))\n\t\tmt76_connac_mcu_rdd_cmd(&dev->mt76, RDD_STOP, 0,\n\t\t\t\t\tMT_RX_SEL0, 0);\n\tif (phy->rdd_state & BIT(1))\n\t\tmt76_connac_mcu_rdd_cmd(&dev->mt76, RDD_STOP, 1,\n\t\t\t\t\tMT_RX_SEL0, 0);\n}\n\nstatic int mt7615_dfs_start_rdd(struct mt7615_dev *dev, int chain)\n{\n\tint err;\n\n\terr = mt76_connac_mcu_rdd_cmd(&dev->mt76, RDD_START, chain,\n\t\t\t\t      MT_RX_SEL0, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn mt76_connac_mcu_rdd_cmd(&dev->mt76, RDD_DET_MODE, chain,\n\t\t\t\t       MT_RX_SEL0, 1);\n}\n\nstatic int mt7615_dfs_start_radar_detector(struct mt7615_phy *phy)\n{\n\tstruct cfg80211_chan_def *chandef = &phy->mt76->chandef;\n\tstruct mt7615_dev *dev = phy->dev;\n\tbool ext_phy = phy != &dev->phy;\n\tint err;\n\n\t \n\terr = mt76_connac_mcu_rdd_cmd(&dev->mt76, RDD_CAC_START, ext_phy,\n\t\t\t\t      MT_RX_SEL0, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = mt7615_dfs_start_rdd(dev, ext_phy);\n\tif (err < 0)\n\t\treturn err;\n\n\tphy->rdd_state |= BIT(ext_phy);\n\n\tif (chandef->width == NL80211_CHAN_WIDTH_160 ||\n\t    chandef->width == NL80211_CHAN_WIDTH_80P80) {\n\t\terr = mt7615_dfs_start_rdd(dev, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tphy->rdd_state |= BIT(1);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmt7615_dfs_init_radar_specs(struct mt7615_phy *phy)\n{\n\tconst struct mt7615_dfs_radar_spec *radar_specs;\n\tstruct mt7615_dev *dev = phy->dev;\n\tint err, i, lpn = 500;\n\n\tswitch (dev->mt76.region) {\n\tcase NL80211_DFS_FCC:\n\t\tradar_specs = &fcc_radar_specs;\n\t\tlpn = 8;\n\t\tbreak;\n\tcase NL80211_DFS_ETSI:\n\t\tradar_specs = &etsi_radar_specs;\n\t\tbreak;\n\tcase NL80211_DFS_JP:\n\t\tradar_specs = &jp_radar_specs;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\terr = mt7615_mcu_set_fcc5_lpn(dev, lpn);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < ARRAY_SIZE(radar_specs->radar_pattern); i++) {\n\t\terr = mt7615_mcu_set_radar_th(dev, i,\n\t\t\t\t\t      &radar_specs->radar_pattern[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn mt7615_mcu_set_pulse_th(dev, &radar_specs->pulse_th);\n}\n\nint mt7615_dfs_init_radar_detector(struct mt7615_phy *phy)\n{\n\tstruct cfg80211_chan_def *chandef = &phy->mt76->chandef;\n\tstruct mt7615_dev *dev = phy->dev;\n\tbool ext_phy = phy != &dev->phy;\n\tenum mt76_dfs_state dfs_state, prev_state;\n\tint err;\n\n\tif (is_mt7663(&dev->mt76))\n\t\treturn 0;\n\n\tprev_state = phy->mt76->dfs_state;\n\tdfs_state = mt76_phy_dfs_state(phy->mt76);\n\tif ((chandef->chan->flags & IEEE80211_CHAN_RADAR) &&\n\t    dfs_state < MT_DFS_STATE_CAC)\n\t\tdfs_state = MT_DFS_STATE_ACTIVE;\n\n\tif (prev_state == dfs_state)\n\t\treturn 0;\n\n\tif (dfs_state == MT_DFS_STATE_DISABLED)\n\t\tgoto stop;\n\n\tif (prev_state <= MT_DFS_STATE_DISABLED) {\n\t\terr = mt7615_dfs_init_radar_specs(phy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = mt7615_dfs_start_radar_detector(phy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tphy->mt76->dfs_state = MT_DFS_STATE_CAC;\n\t}\n\n\tif (dfs_state == MT_DFS_STATE_CAC)\n\t\treturn 0;\n\n\terr = mt76_connac_mcu_rdd_cmd(&dev->mt76, RDD_CAC_END,\n\t\t\t\t      ext_phy, MT_RX_SEL0, 0);\n\tif (err < 0) {\n\t\tphy->mt76->dfs_state = MT_DFS_STATE_UNKNOWN;\n\t\treturn err;\n\t}\n\n\tphy->mt76->dfs_state = MT_DFS_STATE_ACTIVE;\n\treturn 0;\n\nstop:\n\terr = mt76_connac_mcu_rdd_cmd(&dev->mt76, RDD_NORMAL_START, ext_phy,\n\t\t\t\t      MT_RX_SEL0, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tmt7615_dfs_stop_radar_detector(phy);\n\tphy->mt76->dfs_state = MT_DFS_STATE_DISABLED;\n\n\treturn 0;\n}\n\nint mt7615_mac_set_beacon_filter(struct mt7615_phy *phy,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t bool enable)\n{\n\tstruct mt7615_dev *dev = phy->dev;\n\tbool ext_phy = phy != &dev->phy;\n\tint err;\n\n\tif (!mt7615_firmware_offload(dev))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_MONITOR:\n\t\treturn 0;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_AP:\n\t\tif (enable)\n\t\t\tphy->n_beacon_vif++;\n\t\telse\n\t\t\tphy->n_beacon_vif--;\n\t\tfallthrough;\n\tdefault:\n\t\tbreak;\n\t}\n\n\terr = mt7615_mcu_set_bss_pm(dev, vif, !phy->n_beacon_vif);\n\tif (err)\n\t\treturn err;\n\n\tif (phy->n_beacon_vif) {\n\t\tvif->driver_flags &= ~IEEE80211_VIF_BEACON_FILTER;\n\t\tmt76_clear(dev, MT_WF_RFCR(ext_phy),\n\t\t\t   MT_WF_RFCR_DROP_OTHER_BEACON);\n\t} else {\n\t\tvif->driver_flags |= IEEE80211_VIF_BEACON_FILTER;\n\t\tmt76_set(dev, MT_WF_RFCR(ext_phy),\n\t\t\t MT_WF_RFCR_DROP_OTHER_BEACON);\n\t}\n\n\treturn 0;\n}\n\nvoid mt7615_coredump_work(struct work_struct *work)\n{\n\tstruct mt7615_dev *dev;\n\tchar *dump, *data;\n\n\tdev = (struct mt7615_dev *)container_of(work, struct mt7615_dev,\n\t\t\t\t\t\tcoredump.work.work);\n\n\tif (time_is_after_jiffies(dev->coredump.last_activity +\n\t\t\t\t  4 * MT76_CONNAC_COREDUMP_TIMEOUT)) {\n\t\tqueue_delayed_work(dev->mt76.wq, &dev->coredump.work,\n\t\t\t\t   MT76_CONNAC_COREDUMP_TIMEOUT);\n\t\treturn;\n\t}\n\n\tdump = vzalloc(MT76_CONNAC_COREDUMP_SZ);\n\tdata = dump;\n\n\twhile (true) {\n\t\tstruct sk_buff *skb;\n\n\t\tspin_lock_bh(&dev->mt76.lock);\n\t\tskb = __skb_dequeue(&dev->coredump.msg_list);\n\t\tspin_unlock_bh(&dev->mt76.lock);\n\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tskb_pull(skb, sizeof(struct mt7615_mcu_rxd));\n\t\tif (!dump || data + skb->len - dump > MT76_CONNAC_COREDUMP_SZ) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmemcpy(data, skb->data, skb->len);\n\t\tdata += skb->len;\n\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tif (dump)\n\t\tdev_coredumpv(dev->mt76.dev, dump, MT76_CONNAC_COREDUMP_SZ,\n\t\t\t      GFP_KERNEL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}