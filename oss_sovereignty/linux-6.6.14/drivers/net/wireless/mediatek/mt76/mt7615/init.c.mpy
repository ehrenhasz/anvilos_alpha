{
  "module_name": "init.c",
  "hash_id": "7b1fe4c93a7b815675342ae434cfcb78e8bb2bc0859fadb13d780712dac7cccd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7615/init.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include \"mt7615.h\"\n#include \"mac.h\"\n#include \"mcu.h\"\n#include \"eeprom.h\"\n\nstatic ssize_t mt7615_thermal_show_temp(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct mt7615_dev *mdev = dev_get_drvdata(dev);\n\tint temperature;\n\n\tif (!mt7615_wait_for_mcu_init(mdev))\n\t\treturn 0;\n\n\tmt7615_mutex_acquire(mdev);\n\ttemperature = mt7615_mcu_get_temperature(mdev);\n\tmt7615_mutex_release(mdev);\n\n\tif (temperature < 0)\n\t\treturn temperature;\n\n\t \n\treturn sprintf(buf, \"%u\\n\", temperature * 1000);\n}\n\nstatic SENSOR_DEVICE_ATTR(temp1_input, 0444, mt7615_thermal_show_temp,\n\t\t\t  NULL, 0);\n\nstatic struct attribute *mt7615_hwmon_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(mt7615_hwmon);\n\nint mt7615_thermal_init(struct mt7615_dev *dev)\n{\n\tstruct wiphy *wiphy = mt76_hw(dev)->wiphy;\n\tstruct device *hwmon;\n\tconst char *name;\n\n\tif (!IS_REACHABLE(CONFIG_HWMON))\n\t\treturn 0;\n\n\tname = devm_kasprintf(&wiphy->dev, GFP_KERNEL, \"mt7615_%s\",\n\t\t\t      wiphy_name(wiphy));\n\thwmon = devm_hwmon_device_register_with_groups(&wiphy->dev, name, dev,\n\t\t\t\t\t\t       mt7615_hwmon_groups);\n\tif (IS_ERR(hwmon))\n\t\treturn PTR_ERR(hwmon);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt7615_thermal_init);\n\nstatic void\nmt7615_phy_init(struct mt7615_dev *dev)\n{\n\t \n\tmt76_set(dev, MT_WF_PHY_WF2_RFCTRL0(0), MT_WF_PHY_WF2_RFCTRL0_LPBCN_EN);\n\tmt76_set(dev, MT_WF_PHY_WF2_RFCTRL0(1), MT_WF_PHY_WF2_RFCTRL0_LPBCN_EN);\n}\n\nstatic void\nmt7615_init_mac_chain(struct mt7615_dev *dev, int chain)\n{\n\tu32 val;\n\n\tif (!chain)\n\t\tval = MT_CFG_CCR_MAC_D0_1X_GC_EN | MT_CFG_CCR_MAC_D0_2X_GC_EN;\n\telse\n\t\tval = MT_CFG_CCR_MAC_D1_1X_GC_EN | MT_CFG_CCR_MAC_D1_2X_GC_EN;\n\n\t \n\tmt76_set(dev, MT_CFG_CCR, val);\n\n\tmt76_rmw(dev, MT_TMAC_TRCR(chain),\n\t\t MT_TMAC_TRCR_CCA_SEL | MT_TMAC_TRCR_SEC_CCA_SEL,\n\t\t FIELD_PREP(MT_TMAC_TRCR_CCA_SEL, 2) |\n\t\t FIELD_PREP(MT_TMAC_TRCR_SEC_CCA_SEL, 0));\n\n\tmt76_wr(dev, MT_AGG_ACR(chain),\n\t\tMT_AGG_ACR_PKT_TIME_EN | MT_AGG_ACR_NO_BA_AR_RULE |\n\t\tFIELD_PREP(MT_AGG_ACR_CFEND_RATE, MT7615_CFEND_RATE_DEFAULT) |\n\t\tFIELD_PREP(MT_AGG_ACR_BAR_RATE, MT7615_BAR_RATE_DEFAULT));\n\n\tmt76_wr(dev, MT_AGG_ARUCR(chain),\n\t\tFIELD_PREP(MT_AGG_ARxCR_LIMIT(0), 7) |\n\t\tFIELD_PREP(MT_AGG_ARxCR_LIMIT(1), 2) |\n\t\tFIELD_PREP(MT_AGG_ARxCR_LIMIT(2), 2) |\n\t\tFIELD_PREP(MT_AGG_ARxCR_LIMIT(3), 2) |\n\t\tFIELD_PREP(MT_AGG_ARxCR_LIMIT(4), 1) |\n\t\tFIELD_PREP(MT_AGG_ARxCR_LIMIT(5), 1) |\n\t\tFIELD_PREP(MT_AGG_ARxCR_LIMIT(6), 1) |\n\t\tFIELD_PREP(MT_AGG_ARxCR_LIMIT(7), 1));\n\n\tmt76_wr(dev, MT_AGG_ARDCR(chain),\n\t\tFIELD_PREP(MT_AGG_ARxCR_LIMIT(0), MT7615_RATE_RETRY - 1) |\n\t\tFIELD_PREP(MT_AGG_ARxCR_LIMIT(1), MT7615_RATE_RETRY - 1) |\n\t\tFIELD_PREP(MT_AGG_ARxCR_LIMIT(2), MT7615_RATE_RETRY - 1) |\n\t\tFIELD_PREP(MT_AGG_ARxCR_LIMIT(3), MT7615_RATE_RETRY - 1) |\n\t\tFIELD_PREP(MT_AGG_ARxCR_LIMIT(4), MT7615_RATE_RETRY - 1) |\n\t\tFIELD_PREP(MT_AGG_ARxCR_LIMIT(5), MT7615_RATE_RETRY - 1) |\n\t\tFIELD_PREP(MT_AGG_ARxCR_LIMIT(6), MT7615_RATE_RETRY - 1) |\n\t\tFIELD_PREP(MT_AGG_ARxCR_LIMIT(7), MT7615_RATE_RETRY - 1));\n\n\tmt76_clear(dev, MT_DMA_RCFR0(chain), MT_DMA_RCFR0_MCU_RX_TDLS);\n\tif (!mt7615_firmware_offload(dev)) {\n\t\tu32 mask, set;\n\n\t\tmask = MT_DMA_RCFR0_MCU_RX_MGMT |\n\t\t       MT_DMA_RCFR0_MCU_RX_CTL_NON_BAR |\n\t\t       MT_DMA_RCFR0_MCU_RX_CTL_BAR |\n\t\t       MT_DMA_RCFR0_MCU_RX_BYPASS |\n\t\t       MT_DMA_RCFR0_RX_DROPPED_UCAST |\n\t\t       MT_DMA_RCFR0_RX_DROPPED_MCAST;\n\t\tset = FIELD_PREP(MT_DMA_RCFR0_RX_DROPPED_UCAST, 2) |\n\t\t      FIELD_PREP(MT_DMA_RCFR0_RX_DROPPED_MCAST, 2);\n\t\tmt76_rmw(dev, MT_DMA_RCFR0(chain), mask, set);\n\t}\n}\n\nstatic void\nmt7615_mac_init(struct mt7615_dev *dev)\n{\n\tint i;\n\n\tmt7615_init_mac_chain(dev, 0);\n\n\tmt76_rmw_field(dev, MT_TMAC_CTCR0,\n\t\t       MT_TMAC_CTCR0_INS_DDLMT_REFTIME, 0x3f);\n\tmt76_rmw_field(dev, MT_TMAC_CTCR0,\n\t\t       MT_TMAC_CTCR0_INS_DDLMT_DENSITY, 0x3);\n\tmt76_rmw(dev, MT_TMAC_CTCR0,\n\t\t MT_TMAC_CTCR0_INS_DDLMT_VHT_SMPDU_EN |\n\t\t MT_TMAC_CTCR0_INS_DDLMT_EN,\n\t\t MT_TMAC_CTCR0_INS_DDLMT_VHT_SMPDU_EN |\n\t\t MT_TMAC_CTCR0_INS_DDLMT_EN);\n\n\tmt76_connac_mcu_set_rts_thresh(&dev->mt76, 0x92b, 0);\n\tmt7615_mac_set_scs(&dev->phy, true);\n\n\tmt76_rmw(dev, MT_AGG_SCR, MT_AGG_SCR_NLNAV_MID_PTEC_DIS,\n\t\t MT_AGG_SCR_NLNAV_MID_PTEC_DIS);\n\n\tmt76_wr(dev, MT_AGG_ARCR,\n\t\tFIELD_PREP(MT_AGG_ARCR_RTS_RATE_THR, 2) |\n\t\tMT_AGG_ARCR_RATE_DOWN_RATIO_EN |\n\t\tFIELD_PREP(MT_AGG_ARCR_RATE_DOWN_RATIO, 1) |\n\t\tFIELD_PREP(MT_AGG_ARCR_RATE_UP_EXTRA_TH, 4));\n\n\tfor (i = 0; i < MT7615_WTBL_SIZE; i++)\n\t\tmt7615_mac_wtbl_update(dev, i,\n\t\t\t\t       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);\n\n\tmt76_set(dev, MT_WF_RMAC_MIB_TIME0, MT_WF_RMAC_MIB_RXTIME_EN);\n\tmt76_set(dev, MT_WF_RMAC_MIB_AIRTIME0, MT_WF_RMAC_MIB_RXTIME_EN);\n\n\tmt76_wr(dev, MT_DMA_DCR0,\n\t\tFIELD_PREP(MT_DMA_DCR0_MAX_RX_LEN, 3072) |\n\t\tMT_DMA_DCR0_RX_VEC_DROP | MT_DMA_DCR0_DAMSDU_EN |\n\t\tMT_DMA_DCR0_RX_HDR_TRANS_EN);\n\t \n\tmt76_clear(dev, MT_WF_PFCR, MT_WF_PFCR_TDLS_EN);\n\tmt76_set(dev, MT_WF_MIB_SCR0, MT_MIB_SCR0_AGG_CNT_RANGE_EN);\n\tif (is_mt7663(&dev->mt76)) {\n\t\tmt76_wr(dev, MT_WF_AGG(0x160), 0x5c341c02);\n\t\tmt76_wr(dev, MT_WF_AGG(0x164), 0x70708040);\n\t} else {\n\t\tmt7615_init_mac_chain(dev, 1);\n\t}\n\tmt7615_mcu_set_rx_hdr_trans_blacklist(dev);\n}\n\nstatic void\nmt7615_check_offload_capability(struct mt7615_dev *dev)\n{\n\tstruct ieee80211_hw *hw = mt76_hw(dev);\n\tstruct wiphy *wiphy = hw->wiphy;\n\n\tif (mt7615_firmware_offload(dev)) {\n\t\tieee80211_hw_set(hw, SUPPORTS_PS);\n\t\tieee80211_hw_set(hw, SUPPORTS_DYNAMIC_PS);\n\n\t\twiphy->flags &= ~WIPHY_FLAG_4ADDR_STATION;\n\t\twiphy->max_remain_on_channel_duration = 5000;\n\t\twiphy->features |= NL80211_FEATURE_SCHED_SCAN_RANDOM_MAC_ADDR |\n\t\t\t\t   NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR |\n\t\t\t\t   WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL |\n\t\t\t\t   NL80211_FEATURE_P2P_GO_CTWIN |\n\t\t\t\t   NL80211_FEATURE_P2P_GO_OPPPS;\n\t} else {\n\t\tdev->ops->hw_scan = NULL;\n\t\tdev->ops->cancel_hw_scan = NULL;\n\t\tdev->ops->sched_scan_start = NULL;\n\t\tdev->ops->sched_scan_stop = NULL;\n\t\tdev->ops->set_rekey_data = NULL;\n\t\tdev->ops->remain_on_channel = NULL;\n\t\tdev->ops->cancel_remain_on_channel = NULL;\n\n\t\twiphy->max_sched_scan_plan_interval = 0;\n\t\twiphy->max_sched_scan_ie_len = 0;\n\t\twiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;\n\t\twiphy->max_sched_scan_ssids = 0;\n\t\twiphy->max_match_sets = 0;\n\t\twiphy->max_sched_scan_reqs = 0;\n\t}\n}\n\nbool mt7615_wait_for_mcu_init(struct mt7615_dev *dev)\n{\n\tflush_work(&dev->mcu_work);\n\n\treturn test_bit(MT76_STATE_MCU_RUNNING, &dev->mphy.state);\n}\nEXPORT_SYMBOL_GPL(mt7615_wait_for_mcu_init);\n\nstatic const struct ieee80211_iface_limit if_limits[] = {\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_ADHOC)\n\t}, {\n\t\t.max = MT7615_MAX_INTERFACES,\n\t\t.types = BIT(NL80211_IFTYPE_AP) |\n#ifdef CONFIG_MAC80211_MESH\n\t\t\t BIT(NL80211_IFTYPE_MESH_POINT) |\n#endif\n\t\t\t BIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\t\t BIT(NL80211_IFTYPE_P2P_GO) |\n\t\t\t BIT(NL80211_IFTYPE_STATION)\n\t}\n};\n\nstatic const struct ieee80211_iface_combination if_comb_radar[] = {\n\t{\n\t\t.limits = if_limits,\n\t\t.n_limits = ARRAY_SIZE(if_limits),\n\t\t.max_interfaces = MT7615_MAX_INTERFACES,\n\t\t.num_different_channels = 1,\n\t\t.beacon_int_infra_match = true,\n\t\t.radar_detect_widths = BIT(NL80211_CHAN_WIDTH_20_NOHT) |\n\t\t\t\t       BIT(NL80211_CHAN_WIDTH_20) |\n\t\t\t\t       BIT(NL80211_CHAN_WIDTH_40) |\n\t\t\t\t       BIT(NL80211_CHAN_WIDTH_80) |\n\t\t\t\t       BIT(NL80211_CHAN_WIDTH_160) |\n\t\t\t\t       BIT(NL80211_CHAN_WIDTH_80P80),\n\t}\n};\n\nstatic const struct ieee80211_iface_combination if_comb[] = {\n\t{\n\t\t.limits = if_limits,\n\t\t.n_limits = ARRAY_SIZE(if_limits),\n\t\t.max_interfaces = MT7615_MAX_INTERFACES,\n\t\t.num_different_channels = 1,\n\t\t.beacon_int_infra_match = true,\n\t}\n};\n\nvoid mt7615_init_txpower(struct mt7615_dev *dev,\n\t\t\t struct ieee80211_supported_band *sband)\n{\n\tint i, n_chains = hweight8(dev->mphy.antenna_mask), target_chains;\n\tint delta_idx, delta = mt76_tx_power_nss_delta(n_chains);\n\tu8 *eep = (u8 *)dev->mt76.eeprom.data;\n\tenum nl80211_band band = sband->band;\n\tstruct mt76_power_limits limits;\n\tu8 rate_val;\n\n\tdelta_idx = mt7615_eeprom_get_power_delta_index(dev, band);\n\trate_val = eep[delta_idx];\n\tif ((rate_val & ~MT_EE_RATE_POWER_MASK) ==\n\t    (MT_EE_RATE_POWER_EN | MT_EE_RATE_POWER_SIGN))\n\t\tdelta += rate_val & MT_EE_RATE_POWER_MASK;\n\n\tif (!is_mt7663(&dev->mt76) && mt7615_ext_pa_enabled(dev, band))\n\t\ttarget_chains = 1;\n\telse\n\t\ttarget_chains = n_chains;\n\n\tfor (i = 0; i < sband->n_channels; i++) {\n\t\tstruct ieee80211_channel *chan = &sband->channels[i];\n\t\tu8 target_power = 0;\n\t\tint j;\n\n\t\tfor (j = 0; j < target_chains; j++) {\n\t\t\tint index;\n\n\t\t\tindex = mt7615_eeprom_get_target_power_index(dev, chan, j);\n\t\t\tif (index < 0)\n\t\t\t\tcontinue;\n\n\t\t\ttarget_power = max(target_power, eep[index]);\n\t\t}\n\n\t\ttarget_power = mt76_get_rate_power_limits(&dev->mphy, chan,\n\t\t\t\t\t\t\t  &limits,\n\t\t\t\t\t\t\t  target_power);\n\t\ttarget_power += delta;\n\t\ttarget_power = DIV_ROUND_UP(target_power, 2);\n\t\tchan->max_power = min_t(int, chan->max_reg_power,\n\t\t\t\t\ttarget_power);\n\t\tchan->orig_mpwr = target_power;\n\t}\n}\nEXPORT_SYMBOL_GPL(mt7615_init_txpower);\n\nvoid mt7615_init_work(struct mt7615_dev *dev)\n{\n\tmt7615_mcu_set_eeprom(dev);\n\tmt7615_mac_init(dev);\n\tmt7615_phy_init(dev);\n\tmt7615_mcu_del_wtbl_all(dev);\n\tmt7615_check_offload_capability(dev);\n}\nEXPORT_SYMBOL_GPL(mt7615_init_work);\n\nstatic void\nmt7615_regd_notifier(struct wiphy *wiphy,\n\t\t     struct regulatory_request *request)\n{\n\tstruct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\tstruct mt76_phy *mphy = hw->priv;\n\tstruct mt7615_phy *phy = mphy->priv;\n\tstruct cfg80211_chan_def *chandef = &mphy->chandef;\n\n\tmemcpy(dev->mt76.alpha2, request->alpha2, sizeof(dev->mt76.alpha2));\n\tdev->mt76.region = request->dfs_region;\n\n\tmt7615_init_txpower(dev, &mphy->sband_2g.sband);\n\tmt7615_init_txpower(dev, &mphy->sband_5g.sband);\n\n\tmt7615_mutex_acquire(dev);\n\n\tif (chandef->chan->flags & IEEE80211_CHAN_RADAR)\n\t\tmt7615_dfs_init_radar_detector(phy);\n\n\tif (mt7615_firmware_offload(phy->dev)) {\n\t\tmt76_connac_mcu_set_channel_domain(mphy);\n\t\tmt76_connac_mcu_set_rate_txpower(mphy);\n\t}\n\n\tmt7615_mutex_release(dev);\n}\n\nstatic void\nmt7615_init_wiphy(struct ieee80211_hw *hw)\n{\n\tstruct mt7615_phy *phy = mt7615_hw_phy(hw);\n\tstruct wiphy *wiphy = hw->wiphy;\n\n\thw->queues = 4;\n\thw->max_rates = 3;\n\thw->max_report_rates = 7;\n\thw->max_rate_tries = 11;\n\thw->netdev_features = NETIF_F_RXCSUM;\n\n\thw->radiotap_timestamp.units_pos =\n\t\tIEEE80211_RADIOTAP_TIMESTAMP_UNIT_US;\n\n\tphy->slottime = 9;\n\n\thw->sta_data_size = sizeof(struct mt7615_sta);\n\thw->vif_data_size = sizeof(struct mt7615_vif);\n\n\tif (is_mt7663(&phy->dev->mt76)) {\n\t\twiphy->iface_combinations = if_comb;\n\t\twiphy->n_iface_combinations = ARRAY_SIZE(if_comb);\n\t} else {\n\t\twiphy->iface_combinations = if_comb_radar;\n\t\twiphy->n_iface_combinations = ARRAY_SIZE(if_comb_radar);\n\t}\n\twiphy->reg_notifier = mt7615_regd_notifier;\n\n\twiphy->max_sched_scan_plan_interval =\n\t\tMT76_CONNAC_MAX_TIME_SCHED_SCAN_INTERVAL;\n\twiphy->max_sched_scan_ie_len = IEEE80211_MAX_DATA_LEN;\n\twiphy->max_scan_ie_len = MT76_CONNAC_SCAN_IE_LEN;\n\twiphy->max_sched_scan_ssids = MT76_CONNAC_MAX_SCHED_SCAN_SSID;\n\twiphy->max_match_sets = MT76_CONNAC_MAX_SCAN_MATCH;\n\twiphy->max_sched_scan_reqs = 1;\n\twiphy->max_scan_ssids = 4;\n\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_SET_SCAN_DWELL);\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_VHT_IBSS);\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_CAN_REPLACE_PTK0);\n\tif (!is_mt7622(&phy->dev->mt76))\n\t\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_MU_MIMO_AIR_SNIFFER);\n\n\tieee80211_hw_set(hw, SINGLE_SCAN_ON_ALL_BANDS);\n\tieee80211_hw_set(hw, TX_STATUS_NO_AMPDU_LEN);\n\tieee80211_hw_set(hw, WANT_MONITOR_VIF);\n\tieee80211_hw_set(hw, SUPPORTS_RX_DECAP_OFFLOAD);\n\tieee80211_hw_set(hw, SUPPORTS_VHT_EXT_NSS_BW);\n\n\tif (is_mt7615(&phy->dev->mt76))\n\t\thw->max_tx_fragments = MT_TXP_MAX_BUF_NUM;\n\telse\n\t\thw->max_tx_fragments = MT_HW_TXP_MAX_BUF_NUM;\n\n\tphy->mt76->sband_2g.sband.ht_cap.cap |= IEEE80211_HT_CAP_LDPC_CODING;\n\tphy->mt76->sband_5g.sband.ht_cap.cap |= IEEE80211_HT_CAP_LDPC_CODING;\n\tphy->mt76->sband_5g.sband.vht_cap.cap |=\n\t\t\tIEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK;\n}\n\nstatic void\nmt7615_cap_dbdc_enable(struct mt7615_dev *dev)\n{\n\tdev->mphy.sband_5g.sband.vht_cap.cap &=\n\t\t\t~(IEEE80211_VHT_CAP_SHORT_GI_160 |\n\t\t\t  IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ);\n\tif (dev->chainmask == 0xf)\n\t\tdev->mphy.antenna_mask = dev->chainmask >> 2;\n\telse\n\t\tdev->mphy.antenna_mask = dev->chainmask >> 1;\n\tdev->mphy.chainmask = dev->mphy.antenna_mask;\n\tdev->mphy.hw->wiphy->available_antennas_rx = dev->mphy.chainmask;\n\tdev->mphy.hw->wiphy->available_antennas_tx = dev->mphy.chainmask;\n\tmt76_set_stream_caps(&dev->mphy, true);\n}\n\nstatic void\nmt7615_cap_dbdc_disable(struct mt7615_dev *dev)\n{\n\tdev->mphy.sband_5g.sband.vht_cap.cap |=\n\t\t\tIEEE80211_VHT_CAP_SHORT_GI_160 |\n\t\t\tIEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ;\n\tdev->mphy.antenna_mask = dev->chainmask;\n\tdev->mphy.chainmask = dev->chainmask;\n\tdev->mphy.hw->wiphy->available_antennas_rx = dev->chainmask;\n\tdev->mphy.hw->wiphy->available_antennas_tx = dev->chainmask;\n\tmt76_set_stream_caps(&dev->mphy, true);\n}\n\nu32 mt7615_reg_map(struct mt7615_dev *dev, u32 addr)\n{\n\tu32 base, offset;\n\n\tif (is_mt7663(&dev->mt76)) {\n\t\tbase = addr & MT7663_MCU_PCIE_REMAP_2_BASE;\n\t\toffset = addr & MT7663_MCU_PCIE_REMAP_2_OFFSET;\n\t} else {\n\t\tbase = addr & MT_MCU_PCIE_REMAP_2_BASE;\n\t\toffset = addr & MT_MCU_PCIE_REMAP_2_OFFSET;\n\t}\n\tmt76_wr(dev, MT_MCU_PCIE_REMAP_2, base);\n\n\treturn MT_PCIE_REMAP_BASE_2 + offset;\n}\nEXPORT_SYMBOL_GPL(mt7615_reg_map);\n\nstatic void\nmt7615_led_set_config(struct led_classdev *led_cdev,\n\t\t      u8 delay_on, u8 delay_off)\n{\n\tstruct mt7615_dev *dev;\n\tstruct mt76_phy *mphy;\n\tu32 val, addr;\n\tu8 index;\n\n\tmphy = container_of(led_cdev, struct mt76_phy, leds.cdev);\n\tdev = container_of(mphy->dev, struct mt7615_dev, mt76);\n\n\tif (!mt76_connac_pm_ref(mphy, &dev->pm))\n\t\treturn;\n\n\tval = FIELD_PREP(MT_LED_STATUS_DURATION, 0xffff) |\n\t      FIELD_PREP(MT_LED_STATUS_OFF, delay_off) |\n\t      FIELD_PREP(MT_LED_STATUS_ON, delay_on);\n\n\tindex = dev->dbdc_support ? mphy->band_idx : mphy->leds.pin;\n\taddr = mt7615_reg_map(dev, MT_LED_STATUS_0(index));\n\tmt76_wr(dev, addr, val);\n\taddr = mt7615_reg_map(dev, MT_LED_STATUS_1(index));\n\tmt76_wr(dev, addr, val);\n\n\tval = MT_LED_CTRL_REPLAY(index) | MT_LED_CTRL_KICK(index);\n\tif (dev->mphy.leds.al)\n\t\tval |= MT_LED_CTRL_POLARITY(index);\n\tif (mphy->band_idx)\n\t\tval |= MT_LED_CTRL_BAND(index);\n\n\taddr = mt7615_reg_map(dev, MT_LED_CTRL);\n\tmt76_wr(dev, addr, val);\n\n\tmt76_connac_pm_unref(mphy, &dev->pm);\n}\n\nint mt7615_led_set_blink(struct led_classdev *led_cdev,\n\t\t\t unsigned long *delay_on,\n\t\t\t unsigned long *delay_off)\n{\n\tu8 delta_on, delta_off;\n\n\tdelta_off = max_t(u8, *delay_off / 10, 1);\n\tdelta_on = max_t(u8, *delay_on / 10, 1);\n\n\tmt7615_led_set_config(led_cdev, delta_on, delta_off);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt7615_led_set_blink);\n\nvoid mt7615_led_set_brightness(struct led_classdev *led_cdev,\n\t\t\t       enum led_brightness brightness)\n{\n\tif (!brightness)\n\t\tmt7615_led_set_config(led_cdev, 0, 0xff);\n\telse\n\t\tmt7615_led_set_config(led_cdev, 0xff, 0);\n}\nEXPORT_SYMBOL_GPL(mt7615_led_set_brightness);\n\nint mt7615_register_ext_phy(struct mt7615_dev *dev)\n{\n\tstruct mt7615_phy *phy = mt7615_ext_phy(dev);\n\tstruct mt76_phy *mphy;\n\tint i, ret;\n\n\tif (!is_mt7615(&dev->mt76))\n\t\treturn -EOPNOTSUPP;\n\n\tif (test_bit(MT76_STATE_RUNNING, &dev->mphy.state))\n\t\treturn -EINVAL;\n\n\tif (phy)\n\t\treturn 0;\n\n\tmt7615_cap_dbdc_enable(dev);\n\tmphy = mt76_alloc_phy(&dev->mt76, sizeof(*phy), &mt7615_ops, MT_BAND1);\n\tif (!mphy)\n\t\treturn -ENOMEM;\n\n\tphy = mphy->priv;\n\tphy->dev = dev;\n\tphy->mt76 = mphy;\n\tmphy->chainmask = dev->chainmask & ~dev->mphy.chainmask;\n\tmphy->antenna_mask = BIT(hweight8(mphy->chainmask)) - 1;\n\tmt7615_init_wiphy(mphy->hw);\n\n\tINIT_DELAYED_WORK(&mphy->mac_work, mt7615_mac_work);\n\tINIT_DELAYED_WORK(&phy->scan_work, mt7615_scan_work);\n\tskb_queue_head_init(&phy->scan_event_list);\n\n\tINIT_WORK(&phy->roc_work, mt7615_roc_work);\n\ttimer_setup(&phy->roc_timer, mt7615_roc_timer, 0);\n\tinit_waitqueue_head(&phy->roc_wait);\n\n\tmt7615_mac_set_scs(phy, true);\n\n\t \n\tmemcpy(mphy->macaddr, dev->mt76.eeprom.data + MT_EE_MAC_ADDR,\n\t       ETH_ALEN);\n\tmphy->macaddr[0] |= 2;\n\tmphy->macaddr[0] ^= BIT(7);\n\tmt76_eeprom_override(mphy);\n\n\t \n\tmphy->cap.has_5ghz = true;\n\n\t \n\tfor (i = 0; i <= MT_TXQ_PSD ; i++)\n\t\tmphy->q_tx[i] = dev->mphy.q_tx[i];\n\n\t \n\tif (IS_ENABLED(CONFIG_MT76_LEDS)) {\n\t\tmphy->leds.cdev.brightness_set = mt7615_led_set_brightness;\n\t\tmphy->leds.cdev.blink_set = mt7615_led_set_blink;\n\t}\n\n\tret = mt76_register_phy(mphy, true, mt76_rates,\n\t\t\t\tARRAY_SIZE(mt76_rates));\n\tif (ret)\n\t\tieee80211_free_hw(mphy->hw);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mt7615_register_ext_phy);\n\nvoid mt7615_unregister_ext_phy(struct mt7615_dev *dev)\n{\n\tstruct mt7615_phy *phy = mt7615_ext_phy(dev);\n\tstruct mt76_phy *mphy = dev->mt76.phys[MT_BAND1];\n\n\tif (!phy)\n\t\treturn;\n\n\tmt7615_cap_dbdc_disable(dev);\n\tmt76_unregister_phy(mphy);\n\tieee80211_free_hw(mphy->hw);\n}\nEXPORT_SYMBOL_GPL(mt7615_unregister_ext_phy);\n\nvoid mt7615_init_device(struct mt7615_dev *dev)\n{\n\tstruct ieee80211_hw *hw = mt76_hw(dev);\n\n\tdev->phy.dev = dev;\n\tdev->phy.mt76 = &dev->mt76.phy;\n\tdev->mt76.phy.priv = &dev->phy;\n\tdev->mt76.tx_worker.fn = mt7615_tx_worker;\n\n\tINIT_DELAYED_WORK(&dev->pm.ps_work, mt7615_pm_power_save_work);\n\tINIT_WORK(&dev->pm.wake_work, mt7615_pm_wake_work);\n\tspin_lock_init(&dev->pm.wake.lock);\n\tmutex_init(&dev->pm.mutex);\n\tinit_waitqueue_head(&dev->pm.wait);\n\tspin_lock_init(&dev->pm.txq_lock);\n\tINIT_DELAYED_WORK(&dev->mphy.mac_work, mt7615_mac_work);\n\tINIT_DELAYED_WORK(&dev->phy.scan_work, mt7615_scan_work);\n\tINIT_DELAYED_WORK(&dev->coredump.work, mt7615_coredump_work);\n\tskb_queue_head_init(&dev->phy.scan_event_list);\n\tskb_queue_head_init(&dev->coredump.msg_list);\n\tinit_waitqueue_head(&dev->reset_wait);\n\tinit_waitqueue_head(&dev->phy.roc_wait);\n\n\tINIT_WORK(&dev->phy.roc_work, mt7615_roc_work);\n\ttimer_setup(&dev->phy.roc_timer, mt7615_roc_timer, 0);\n\n\tmt7615_init_wiphy(hw);\n\tdev->pm.idle_timeout = MT7615_PM_TIMEOUT;\n\tdev->pm.stats.last_wake_event = jiffies;\n\tdev->pm.stats.last_doze_event = jiffies;\n\tmt7615_cap_dbdc_disable(dev);\n\n#ifdef CONFIG_NL80211_TESTMODE\n\tdev->mt76.test_ops = &mt7615_testmode_ops;\n#endif\n}\nEXPORT_SYMBOL_GPL(mt7615_init_device);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}