{
  "module_name": "pci.c",
  "hash_id": "fb4122c8691e28f3fd46cf0ae2c5202b4d87e857fcf15794fa14408c41f82e95",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7615/pci.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#include \"mt7615.h\"\n#include \"mcu.h\"\n\nstatic const struct pci_device_id mt7615_pci_device_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MEDIATEK, 0x7615) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MEDIATEK, 0x7663) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MEDIATEK, 0x7611) },\n\t{ },\n};\n\nstatic int mt7615_pci_probe(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *id)\n{\n\tconst u32 *map;\n\tint ret;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pcim_iomap_regions(pdev, BIT(0), pci_name(pdev));\n\tif (ret)\n\t\treturn ret;\n\n\tpci_set_master(pdev);\n\n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_ALL_TYPES);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\tgoto error;\n\n\tmt76_pci_disable_aspm(pdev);\n\n\tmap = id->device == 0x7663 ? mt7663e_reg_map : mt7615e_reg_map;\n\tret = mt7615_mmio_probe(&pdev->dev, pcim_iomap_table(pdev)[0],\n\t\t\t\tpdev->irq, map);\n\tif (ret)\n\t\tgoto error;\n\n\treturn 0;\nerror:\n\tpci_free_irq_vectors(pdev);\n\n\treturn ret;\n}\n\nstatic void mt7615_pci_remove(struct pci_dev *pdev)\n{\n\tstruct mt76_dev *mdev = pci_get_drvdata(pdev);\n\tstruct mt7615_dev *dev = container_of(mdev, struct mt7615_dev, mt76);\n\n\tmt7615_unregister_device(dev);\n\tdevm_free_irq(&pdev->dev, pdev->irq, dev);\n\tpci_free_irq_vectors(pdev);\n}\n\n#ifdef CONFIG_PM\nstatic int mt7615_pci_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tstruct mt76_dev *mdev = pci_get_drvdata(pdev);\n\tstruct mt7615_dev *dev = container_of(mdev, struct mt7615_dev, mt76);\n\tbool hif_suspend;\n\tint i, err;\n\n\terr = mt76_connac_pm_wake(&dev->mphy, &dev->pm);\n\tif (err < 0)\n\t\treturn err;\n\n\thif_suspend = !test_bit(MT76_STATE_SUSPEND, &dev->mphy.state) &&\n\t\t      mt7615_firmware_offload(dev);\n\tif (hif_suspend) {\n\t\terr = mt76_connac_mcu_set_hif_suspend(mdev, true);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tnapi_disable(&mdev->tx_napi);\n\tmt76_worker_disable(&mdev->tx_worker);\n\n\tmt76_for_each_q_rx(mdev, i) {\n\t\tnapi_disable(&mdev->napi[i]);\n\t}\n\ttasklet_kill(&mdev->irq_tasklet);\n\n\tmt7615_dma_reset(dev);\n\n\terr = mt7615_wait_pdma_busy(dev);\n\tif (err)\n\t\tgoto restore;\n\n\tif (is_mt7663(mdev)) {\n\t\tmt76_set(dev, MT_PDMA_SLP_PROT, MT_PDMA_AXI_SLPPROT_ENABLE);\n\t\tif (!mt76_poll_msec(dev, MT_PDMA_SLP_PROT,\n\t\t\t\t    MT_PDMA_AXI_SLPPROT_RDY,\n\t\t\t\t    MT_PDMA_AXI_SLPPROT_RDY, 1000)) {\n\t\t\tdev_err(mdev->dev, \"PDMA sleep protection failed\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto restore;\n\t\t}\n\t}\n\n\tpci_enable_wake(pdev, pci_choose_state(pdev, state), true);\n\tpci_save_state(pdev);\n\terr = pci_set_power_state(pdev, pci_choose_state(pdev, state));\n\tif (err)\n\t\tgoto restore;\n\n\terr = mt7615_mcu_set_fw_ctrl(dev);\n\tif (err)\n\t\tgoto restore;\n\n\treturn 0;\n\nrestore:\n\tmt76_for_each_q_rx(mdev, i) {\n\t\tnapi_enable(&mdev->napi[i]);\n\t}\n\tnapi_enable(&mdev->tx_napi);\n\tif (hif_suspend)\n\t\tmt76_connac_mcu_set_hif_suspend(mdev, false);\n\n\treturn err;\n}\n\nstatic int mt7615_pci_resume(struct pci_dev *pdev)\n{\n\tstruct mt76_dev *mdev = pci_get_drvdata(pdev);\n\tstruct mt7615_dev *dev = container_of(mdev, struct mt7615_dev, mt76);\n\tbool pdma_reset;\n\tint i, err;\n\n\terr = mt7615_mcu_set_drv_ctrl(dev);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = pci_set_power_state(pdev, PCI_D0);\n\tif (err)\n\t\treturn err;\n\n\tpci_restore_state(pdev);\n\n\tif (is_mt7663(&dev->mt76)) {\n\t\tmt76_clear(dev, MT_PDMA_SLP_PROT, MT_PDMA_AXI_SLPPROT_ENABLE);\n\t\tmt76_wr(dev, MT_PCIE_IRQ_ENABLE, 1);\n\t}\n\n\tpdma_reset = !mt76_rr(dev, MT_WPDMA_TX_RING0_CTRL0) &&\n\t\t     !mt76_rr(dev, MT_WPDMA_TX_RING0_CTRL1);\n\tif (pdma_reset)\n\t\tdev_err(mdev->dev, \"PDMA engine must be reinitialized\\n\");\n\n\tmt76_worker_enable(&mdev->tx_worker);\n\tlocal_bh_disable();\n\tmt76_for_each_q_rx(mdev, i) {\n\t\tnapi_enable(&mdev->napi[i]);\n\t\tnapi_schedule(&mdev->napi[i]);\n\t}\n\tnapi_enable(&mdev->tx_napi);\n\tnapi_schedule(&mdev->tx_napi);\n\tlocal_bh_enable();\n\n\tif (!test_bit(MT76_STATE_SUSPEND, &dev->mphy.state) &&\n\t    mt7615_firmware_offload(dev))\n\t\terr = mt76_connac_mcu_set_hif_suspend(mdev, false);\n\n\treturn err;\n}\n#endif  \n\nstruct pci_driver mt7615_pci_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= mt7615_pci_device_table,\n\t.probe\t\t= mt7615_pci_probe,\n\t.remove\t\t= mt7615_pci_remove,\n#ifdef CONFIG_PM\n\t.suspend\t= mt7615_pci_suspend,\n\t.resume\t\t= mt7615_pci_resume,\n#endif  \n};\n\nMODULE_DEVICE_TABLE(pci, mt7615_pci_device_table);\nMODULE_FIRMWARE(MT7615_FIRMWARE_CR4);\nMODULE_FIRMWARE(MT7615_FIRMWARE_N9);\nMODULE_FIRMWARE(MT7615_ROM_PATCH);\nMODULE_FIRMWARE(MT7663_OFFLOAD_FIRMWARE_N9);\nMODULE_FIRMWARE(MT7663_OFFLOAD_ROM_PATCH);\nMODULE_FIRMWARE(MT7663_FIRMWARE_N9);\nMODULE_FIRMWARE(MT7663_ROM_PATCH);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}