{
  "module_name": "debugfs.c",
  "hash_id": "7ca1cdcd8ba3e1f0c0fd43bd21162be51a3e16e586cdfb876503c440acba6935",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7615/debugfs.c",
  "human_readable_source": "\n\n#include \"mt7615.h\"\n\nstatic int\nmt7615_reg_set(void *data, u64 val)\n{\n\tstruct mt7615_dev *dev = data;\n\n\tmt7615_mutex_acquire(dev);\n\tmt76_wr(dev, dev->mt76.debugfs_reg, val);\n\tmt7615_mutex_release(dev);\n\n\treturn 0;\n}\n\nstatic int\nmt7615_reg_get(void *data, u64 *val)\n{\n\tstruct mt7615_dev *dev = data;\n\n\tmt7615_mutex_acquire(dev);\n\t*val = mt76_rr(dev, dev->mt76.debugfs_reg);\n\tmt7615_mutex_release(dev);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_regval, mt7615_reg_get, mt7615_reg_set,\n\t\t\t \"0x%08llx\\n\");\n\nstatic int\nmt7615_radar_pattern_set(void *data, u64 val)\n{\n\tstruct mt7615_dev *dev = data;\n\tint err;\n\n\tif (!mt7615_wait_for_mcu_init(dev))\n\t\treturn 0;\n\n\tmt7615_mutex_acquire(dev);\n\terr = mt7615_mcu_rdd_send_pattern(dev);\n\tmt7615_mutex_release(dev);\n\n\treturn err;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_radar_pattern, NULL,\n\t\t\t mt7615_radar_pattern_set, \"%lld\\n\");\n\nstatic int mt7615_config(void *data, u64 val)\n{\n\tstruct mt7615_dev *dev = data;\n\tint ret;\n\n\tmt7615_mutex_acquire(dev);\n\tret = mt76_connac_mcu_chip_config(&dev->mt76);\n\tmt7615_mutex_release(dev);\n\n\treturn ret;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_config, NULL, mt7615_config, \"%lld\\n\");\n\nstatic int\nmt7615_scs_set(void *data, u64 val)\n{\n\tstruct mt7615_dev *dev = data;\n\tstruct mt7615_phy *ext_phy;\n\n\tif (!mt7615_wait_for_mcu_init(dev))\n\t\treturn 0;\n\n\tmt7615_mac_set_scs(&dev->phy, val);\n\text_phy = mt7615_ext_phy(dev);\n\tif (ext_phy)\n\t\tmt7615_mac_set_scs(ext_phy, val);\n\n\treturn 0;\n}\n\nstatic int\nmt7615_scs_get(void *data, u64 *val)\n{\n\tstruct mt7615_dev *dev = data;\n\n\t*val = dev->phy.scs_en;\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_scs, mt7615_scs_get,\n\t\t\t mt7615_scs_set, \"%lld\\n\");\n\nstatic int\nmt7615_pm_set(void *data, u64 val)\n{\n\tstruct mt7615_dev *dev = data;\n\tstruct mt76_connac_pm *pm = &dev->pm;\n\tint ret = 0;\n\n\tif (!mt7615_wait_for_mcu_init(dev))\n\t\treturn 0;\n\n\tif (!mt7615_firmware_offload(dev) || mt76_is_usb(&dev->mt76))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tif (val == pm->enable)\n\t\tgoto out;\n\n\tif (dev->phy.n_beacon_vif) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (!pm->enable) {\n\t\tpm->stats.last_wake_event = jiffies;\n\t\tpm->stats.last_doze_event = jiffies;\n\t}\n\t \n\tpm->enable = false;\n\tmt76_connac_pm_wake(&dev->mphy, pm);\n\n\tpm->enable = val;\n\tmt76_connac_power_save_sched(&dev->mphy, pm);\nout:\n\tmutex_unlock(&dev->mt76.mutex);\n\n\treturn ret;\n}\n\nstatic int\nmt7615_pm_get(void *data, u64 *val)\n{\n\tstruct mt7615_dev *dev = data;\n\n\t*val = dev->pm.enable;\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_pm, mt7615_pm_get, mt7615_pm_set, \"%lld\\n\");\n\nstatic int\nmt7615_pm_stats(struct seq_file *s, void *data)\n{\n\tstruct mt7615_dev *dev = dev_get_drvdata(s->private);\n\tstruct mt76_connac_pm *pm = &dev->pm;\n\tunsigned long awake_time = pm->stats.awake_time;\n\tunsigned long doze_time = pm->stats.doze_time;\n\n\tif (!test_bit(MT76_STATE_PM, &dev->mphy.state))\n\t\tawake_time += jiffies - pm->stats.last_wake_event;\n\telse\n\t\tdoze_time += jiffies - pm->stats.last_doze_event;\n\n\tseq_printf(s, \"awake time: %14u\\ndoze time: %15u\\n\",\n\t\t   jiffies_to_msecs(awake_time),\n\t\t   jiffies_to_msecs(doze_time));\n\n\treturn 0;\n}\n\nstatic int\nmt7615_pm_idle_timeout_set(void *data, u64 val)\n{\n\tstruct mt7615_dev *dev = data;\n\n\tdev->pm.idle_timeout = msecs_to_jiffies(val);\n\n\treturn 0;\n}\n\nstatic int\nmt7615_pm_idle_timeout_get(void *data, u64 *val)\n{\n\tstruct mt7615_dev *dev = data;\n\n\t*val = jiffies_to_msecs(dev->pm.idle_timeout);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_pm_idle_timeout, mt7615_pm_idle_timeout_get,\n\t\t\t mt7615_pm_idle_timeout_set, \"%lld\\n\");\n\nstatic int\nmt7615_dbdc_set(void *data, u64 val)\n{\n\tstruct mt7615_dev *dev = data;\n\n\tif (!mt7615_wait_for_mcu_init(dev))\n\t\treturn 0;\n\n\tif (val)\n\t\tmt7615_register_ext_phy(dev);\n\telse\n\t\tmt7615_unregister_ext_phy(dev);\n\n\treturn 0;\n}\n\nstatic int\nmt7615_dbdc_get(void *data, u64 *val)\n{\n\tstruct mt7615_dev *dev = data;\n\n\t*val = !!mt7615_ext_phy(dev);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_dbdc, mt7615_dbdc_get,\n\t\t\t mt7615_dbdc_set, \"%lld\\n\");\n\nstatic int\nmt7615_fw_debug_set(void *data, u64 val)\n{\n\tstruct mt7615_dev *dev = data;\n\n\tif (!mt7615_wait_for_mcu_init(dev))\n\t\treturn 0;\n\n\tdev->fw_debug = val;\n\n\tmt7615_mutex_acquire(dev);\n\tmt7615_mcu_fw_log_2_host(dev, dev->fw_debug ? 2 : 0);\n\tmt7615_mutex_release(dev);\n\n\treturn 0;\n}\n\nstatic int\nmt7615_fw_debug_get(void *data, u64 *val)\n{\n\tstruct mt7615_dev *dev = data;\n\n\t*val = dev->fw_debug;\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_fw_debug, mt7615_fw_debug_get,\n\t\t\t mt7615_fw_debug_set, \"%lld\\n\");\n\nstatic int\nmt7615_reset_test_set(void *data, u64 val)\n{\n\tstruct mt7615_dev *dev = data;\n\tstruct sk_buff *skb;\n\n\tif (!mt7615_wait_for_mcu_init(dev))\n\t\treturn 0;\n\n\tskb = alloc_skb(1, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put(skb, 1);\n\n\tmt7615_mutex_acquire(dev);\n\tmt76_tx_queue_skb_raw(dev, dev->mphy.q_tx[0], skb, 0);\n\tmt7615_mutex_release(dev);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_reset_test, NULL,\n\t\t\t mt7615_reset_test_set, \"%lld\\n\");\n\nstatic void\nmt7615_ampdu_stat_read_phy(struct mt7615_phy *phy,\n\t\t\t   struct seq_file *file)\n{\n\tstruct mt7615_dev *dev = file->private;\n\tu32 reg = is_mt7663(&dev->mt76) ? MT_MIB_ARNG(0) : MT_AGG_ASRCR0;\n\tint bound[7], i, range;\n\n\tif (!phy)\n\t\treturn;\n\n\trange = mt76_rr(dev, reg);\n\tfor (i = 0; i < 4; i++)\n\t\tbound[i] = MT_AGG_ASRCR_RANGE(range, i) + 1;\n\n\trange = mt76_rr(dev, reg + 4);\n\tfor (i = 0; i < 3; i++)\n\t\tbound[i + 4] = MT_AGG_ASRCR_RANGE(range, i) + 1;\n\n\tseq_printf(file, \"\\nPhy %d\\n\", phy != &dev->phy);\n\n\tseq_printf(file, \"Length: %8d | \", bound[0]);\n\tfor (i = 0; i < ARRAY_SIZE(bound) - 1; i++)\n\t\tseq_printf(file, \"%3d -%3d | \",\n\t\t\t   bound[i], bound[i + 1]);\n\tseq_puts(file, \"\\nCount:  \");\n\n\tfor (i = 0; i < ARRAY_SIZE(bound); i++)\n\t\tseq_printf(file, \"%8d | \", phy->mt76->aggr_stats[i]);\n\tseq_puts(file, \"\\n\");\n\n\tseq_printf(file, \"BA miss count: %d\\n\", phy->mib.ba_miss_cnt);\n\tseq_printf(file, \"PER: %ld.%1ld%%\\n\",\n\t\t   phy->mib.aggr_per / 10, phy->mib.aggr_per % 10);\n}\n\nstatic int\nmt7615_ampdu_stat_show(struct seq_file *file, void *data)\n{\n\tstruct mt7615_dev *dev = file->private;\n\n\tmt7615_mutex_acquire(dev);\n\n\tmt7615_ampdu_stat_read_phy(&dev->phy, file);\n\tmt7615_ampdu_stat_read_phy(mt7615_ext_phy(dev), file);\n\n\tmt7615_mutex_release(dev);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(mt7615_ampdu_stat);\n\nstatic void\nmt7615_radio_read_phy(struct mt7615_phy *phy, struct seq_file *s)\n{\n\tstruct mt7615_dev *dev = dev_get_drvdata(s->private);\n\tbool ext_phy = phy != &dev->phy;\n\n\tif (!phy)\n\t\treturn;\n\n\tseq_printf(s, \"Radio %d sensitivity: ofdm=%d cck=%d\\n\", ext_phy,\n\t\t   phy->ofdm_sensitivity, phy->cck_sensitivity);\n\tseq_printf(s, \"Radio %d false CCA: ofdm=%d cck=%d\\n\", ext_phy,\n\t\t   phy->false_cca_ofdm, phy->false_cca_cck);\n}\n\nstatic int\nmt7615_radio_read(struct seq_file *s, void *data)\n{\n\tstruct mt7615_dev *dev = dev_get_drvdata(s->private);\n\n\tmt7615_radio_read_phy(&dev->phy, s);\n\tmt7615_radio_read_phy(mt7615_ext_phy(dev), s);\n\n\treturn 0;\n}\n\nstatic int\nmt7615_queues_acq(struct seq_file *s, void *data)\n{\n\tstruct mt7615_dev *dev = dev_get_drvdata(s->private);\n\tint i;\n\n\tmt7615_mutex_acquire(dev);\n\n\tfor (i = 0; i < 16; i++) {\n\t\tint j, wmm_idx = i % MT7615_MAX_WMM_SETS;\n\t\tint acs = i / MT7615_MAX_WMM_SETS;\n\t\tu32 ctrl, val, qlen = 0;\n\n\t\tif (wmm_idx == 3 && is_mt7663(&dev->mt76))\n\t\t\tcontinue;\n\n\t\tval = mt76_rr(dev, MT_PLE_AC_QEMPTY(acs, wmm_idx));\n\t\tctrl = BIT(31) | BIT(15) | (acs << 8);\n\n\t\tfor (j = 0; j < 32; j++) {\n\t\t\tif (val & BIT(j))\n\t\t\t\tcontinue;\n\n\t\t\tmt76_wr(dev, MT_PLE_FL_Q0_CTRL,\n\t\t\t\tctrl | (j + (wmm_idx << 5)));\n\t\t\tqlen += mt76_get_field(dev, MT_PLE_FL_Q3_CTRL,\n\t\t\t\t\t       GENMASK(11, 0));\n\t\t}\n\t\tseq_printf(s, \"AC%d%d: queued=%d\\n\", wmm_idx, acs, qlen);\n\t}\n\n\tmt7615_mutex_release(dev);\n\n\treturn 0;\n}\n\nstatic int\nmt7615_queues_read(struct seq_file *s, void *data)\n{\n\tstruct mt7615_dev *dev = dev_get_drvdata(s->private);\n\tstruct {\n\t\tstruct mt76_queue *q;\n\t\tchar *queue;\n\t} queue_map[] = {\n\t\t{ dev->mphy.q_tx[MT_TXQ_BE], \"PDMA0\" },\n\t\t{ dev->mt76.q_mcu[MT_MCUQ_WM], \"MCUQ\" },\n\t\t{ dev->mt76.q_mcu[MT_MCUQ_FWDL], \"MCUFWQ\" },\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(queue_map); i++) {\n\t\tstruct mt76_queue *q = queue_map[i].q;\n\n\t\tseq_printf(s,\n\t\t\t   \"%s:\tqueued=%d head=%d tail=%d\\n\",\n\t\t\t   queue_map[i].queue, q->queued, q->head,\n\t\t\t   q->tail);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmt7615_rf_reg_set(void *data, u64 val)\n{\n\tstruct mt7615_dev *dev = data;\n\n\tmt7615_rf_wr(dev, dev->debugfs_rf_wf, dev->debugfs_rf_reg, val);\n\n\treturn 0;\n}\n\nstatic int\nmt7615_rf_reg_get(void *data, u64 *val)\n{\n\tstruct mt7615_dev *dev = data;\n\n\t*val = mt7615_rf_rr(dev, dev->debugfs_rf_wf, dev->debugfs_rf_reg);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_rf_reg, mt7615_rf_reg_get, mt7615_rf_reg_set,\n\t\t\t \"0x%08llx\\n\");\n\nstatic ssize_t\nmt7615_ext_mac_addr_read(struct file *file, char __user *userbuf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct mt7615_dev *dev = file->private_data;\n\tu32 len = 32 * ((ETH_ALEN * 3) + 4) + 1;\n\tu8 addr[ETH_ALEN];\n\tchar *buf;\n\tint ofs = 0;\n\tint i;\n\n\tbuf = kzalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tif (!(dev->muar_mask & BIT(i)))\n\t\t\tcontinue;\n\n\t\tmt76_wr(dev, MT_WF_RMAC_MAR1,\n\t\t\tFIELD_PREP(MT_WF_RMAC_MAR1_IDX, i * 2) |\n\t\t\tMT_WF_RMAC_MAR1_START);\n\t\tput_unaligned_le32(mt76_rr(dev, MT_WF_RMAC_MAR0), addr);\n\t\tput_unaligned_le16((mt76_rr(dev, MT_WF_RMAC_MAR1) &\n\t\t\t\t    MT_WF_RMAC_MAR1_ADDR), addr + 4);\n\t\tofs += snprintf(buf + ofs, len - ofs, \"%d=%pM\\n\", i, addr);\n\t}\n\n\tofs = simple_read_from_buffer(userbuf, count, ppos, buf, ofs);\n\n\tkfree(buf);\n\treturn ofs;\n}\n\nstatic ssize_t\nmt7615_ext_mac_addr_write(struct file *file, const char __user *userbuf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct mt7615_dev *dev = file->private_data;\n\tunsigned long idx = 0;\n\tu8 addr[ETH_ALEN];\n\tchar buf[32];\n\tchar *p;\n\n\tif (count > sizeof(buf))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, userbuf, count))\n\t\treturn -EFAULT;\n\n\tbuf[sizeof(buf) - 1] = '\\0';\n\n\tp = strchr(buf, '=');\n\tif (p) {\n\t\t*p = 0;\n\t\tp++;\n\n\t\tif (kstrtoul(buf, 0, &idx) || idx > 31)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tidx = 0;\n\t\tp = buf;\n\t}\n\n\tif (!mac_pton(p, addr))\n\t\treturn -EINVAL;\n\n\tif (is_valid_ether_addr(addr)) {\n\t\tdev->muar_mask |= BIT(idx);\n\t} else {\n\t\tmemset(addr, 0, sizeof(addr));\n\t\tdev->muar_mask &= ~BIT(idx);\n\t}\n\n\tmt76_rmw_field(dev, MT_WF_RMAC_MORE(0), MT_WF_RMAC_MORE_MUAR_MODE, 1);\n\tmt76_wr(dev, MT_WF_RMAC_MAR0, get_unaligned_le32(addr));\n\tmt76_wr(dev, MT_WF_RMAC_MAR1,\n\t\tget_unaligned_le16(addr + 4) |\n\t\tFIELD_PREP(MT_WF_RMAC_MAR1_IDX, idx * 2) |\n\t\tMT_WF_RMAC_MAR1_START |\n\t\tMT_WF_RMAC_MAR1_WRITE);\n\n\tmt76_rmw_field(dev, MT_WF_RMAC_MORE(0), MT_WF_RMAC_MORE_MUAR_MODE, !!dev->muar_mask);\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_ext_mac_addr = {\n\t.open = simple_open,\n\t.llseek = generic_file_llseek,\n\t.read = mt7615_ext_mac_addr_read,\n\t.write = mt7615_ext_mac_addr_write,\n\t.owner = THIS_MODULE,\n};\n\nstatic int\nmt7663s_sched_quota_read(struct seq_file *s, void *data)\n{\n\tstruct mt7615_dev *dev = dev_get_drvdata(s->private);\n\tstruct mt76_sdio *sdio = &dev->mt76.sdio;\n\n\tseq_printf(s, \"pse_data_quota\\t%d\\n\", sdio->sched.pse_data_quota);\n\tseq_printf(s, \"ple_data_quota\\t%d\\n\", sdio->sched.ple_data_quota);\n\tseq_printf(s, \"pse_mcu_quota\\t%d\\n\", sdio->sched.pse_mcu_quota);\n\tseq_printf(s, \"sched_deficit\\t%d\\n\", sdio->sched.deficit);\n\n\treturn 0;\n}\n\nint mt7615_init_debugfs(struct mt7615_dev *dev)\n{\n\tstruct dentry *dir;\n\n\tdir = mt76_register_debugfs_fops(&dev->mphy, &fops_regval);\n\tif (!dir)\n\t\treturn -ENOMEM;\n\n\tif (is_mt7615(&dev->mt76))\n\t\tdebugfs_create_devm_seqfile(dev->mt76.dev, \"xmit-queues\", dir,\n\t\t\t\t\t    mt7615_queues_read);\n\telse\n\t\tdebugfs_create_devm_seqfile(dev->mt76.dev, \"xmit-queues\", dir,\n\t\t\t\t\t    mt76_queues_read);\n\tdebugfs_create_devm_seqfile(dev->mt76.dev, \"acq\", dir,\n\t\t\t\t    mt7615_queues_acq);\n\tdebugfs_create_file(\"ampdu_stat\", 0400, dir, dev, &mt7615_ampdu_stat_fops);\n\tdebugfs_create_file(\"scs\", 0600, dir, dev, &fops_scs);\n\tdebugfs_create_file(\"dbdc\", 0600, dir, dev, &fops_dbdc);\n\tdebugfs_create_file(\"fw_debug\", 0600, dir, dev, &fops_fw_debug);\n\tdebugfs_create_file(\"runtime-pm\", 0600, dir, dev, &fops_pm);\n\tdebugfs_create_file(\"idle-timeout\", 0600, dir, dev,\n\t\t\t    &fops_pm_idle_timeout);\n\tdebugfs_create_devm_seqfile(dev->mt76.dev, \"runtime_pm_stats\", dir,\n\t\t\t\t    mt7615_pm_stats);\n\tdebugfs_create_devm_seqfile(dev->mt76.dev, \"radio\", dir,\n\t\t\t\t    mt7615_radio_read);\n\n\tif (is_mt7615(&dev->mt76)) {\n\t\tdebugfs_create_u32(\"dfs_hw_pattern\", 0400, dir,\n\t\t\t\t   &dev->hw_pattern);\n\t\t \n\t\tdebugfs_create_u8(\"pattern_len\", 0600, dir,\n\t\t\t\t  &dev->radar_pattern.n_pulses);\n\t\tdebugfs_create_u32(\"pulse_period\", 0600, dir,\n\t\t\t\t   &dev->radar_pattern.period);\n\t\tdebugfs_create_u16(\"pulse_width\", 0600, dir,\n\t\t\t\t   &dev->radar_pattern.width);\n\t\tdebugfs_create_u16(\"pulse_power\", 0600, dir,\n\t\t\t\t   &dev->radar_pattern.power);\n\t\tdebugfs_create_file(\"radar_trigger\", 0200, dir, dev,\n\t\t\t\t    &fops_radar_pattern);\n\t}\n\n\tdebugfs_create_file(\"reset_test\", 0200, dir, dev,\n\t\t\t    &fops_reset_test);\n\tdebugfs_create_file(\"ext_mac_addr\", 0600, dir, dev, &fops_ext_mac_addr);\n\n\tdebugfs_create_u32(\"rf_wfidx\", 0600, dir, &dev->debugfs_rf_wf);\n\tdebugfs_create_u32(\"rf_regidx\", 0600, dir, &dev->debugfs_rf_reg);\n\tdebugfs_create_file_unsafe(\"rf_regval\", 0600, dir, dev,\n\t\t\t\t   &fops_rf_reg);\n\tif (is_mt7663(&dev->mt76))\n\t\tdebugfs_create_file(\"chip_config\", 0600, dir, dev,\n\t\t\t\t    &fops_config);\n\tif (mt76_is_sdio(&dev->mt76))\n\t\tdebugfs_create_devm_seqfile(dev->mt76.dev, \"sched-quota\", dir,\n\t\t\t\t\t    mt7663s_sched_quota_read);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt7615_init_debugfs);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}