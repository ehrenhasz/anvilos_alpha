{
  "module_name": "eeprom.c",
  "hash_id": "24f3b0676fc7b60da1c40e01cbeaf2a922a7d532a967137d052209a523fc2b11",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7615/eeprom.c",
  "human_readable_source": "\n \n\n#include <linux/of.h>\n#include \"mt7615.h\"\n#include \"eeprom.h\"\n\nstatic int mt7615_efuse_read(struct mt7615_dev *dev, u32 base,\n\t\t\t     u16 addr, u8 *data)\n{\n\tu32 val;\n\tint i;\n\n\tval = mt76_rr(dev, base + MT_EFUSE_CTRL);\n\tval &= ~(MT_EFUSE_CTRL_AIN | MT_EFUSE_CTRL_MODE);\n\tval |= FIELD_PREP(MT_EFUSE_CTRL_AIN, addr & ~0xf);\n\tval |= MT_EFUSE_CTRL_KICK;\n\tmt76_wr(dev, base + MT_EFUSE_CTRL, val);\n\n\tif (!mt76_poll(dev, base + MT_EFUSE_CTRL, MT_EFUSE_CTRL_KICK, 0, 1000))\n\t\treturn -ETIMEDOUT;\n\n\tudelay(2);\n\n\tval = mt76_rr(dev, base + MT_EFUSE_CTRL);\n\tif ((val & MT_EFUSE_CTRL_AOUT) == MT_EFUSE_CTRL_AOUT ||\n\t    WARN_ON_ONCE(!(val & MT_EFUSE_CTRL_VALID))) {\n\t\tmemset(data, 0x0, 16);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tval = mt76_rr(dev, base + MT_EFUSE_RDATA(i));\n\t\tput_unaligned_le32(val, data + 4 * i);\n\t}\n\n\treturn 0;\n}\n\nstatic int mt7615_efuse_init(struct mt7615_dev *dev, u32 base)\n{\n\tint i, len = MT7615_EEPROM_SIZE;\n\tvoid *buf;\n\tu32 val;\n\n\tif (is_mt7663(&dev->mt76))\n\t\tlen = MT7663_EEPROM_SIZE;\n\n\tval = mt76_rr(dev, base + MT_EFUSE_BASE_CTRL);\n\tif (val & MT_EFUSE_BASE_CTRL_EMPTY)\n\t\treturn 0;\n\n\tdev->mt76.otp.data = devm_kzalloc(dev->mt76.dev, len, GFP_KERNEL);\n\tdev->mt76.otp.size = len;\n\tif (!dev->mt76.otp.data)\n\t\treturn -ENOMEM;\n\n\tbuf = dev->mt76.otp.data;\n\tfor (i = 0; i + 16 <= len; i += 16) {\n\t\tint ret;\n\n\t\tret = mt7615_efuse_read(dev, base, i, buf + i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mt7615_eeprom_load(struct mt7615_dev *dev, u32 addr)\n{\n\tint ret;\n\n\tBUILD_BUG_ON(MT7615_EEPROM_FULL_SIZE < MT7663_EEPROM_SIZE);\n\n\tret = mt76_eeprom_init(&dev->mt76, MT7615_EEPROM_FULL_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn mt7615_efuse_init(dev, addr);\n}\n\nstatic int mt7615_check_eeprom(struct mt76_dev *dev)\n{\n\tu16 val = get_unaligned_le16(dev->eeprom.data);\n\n\tswitch (val) {\n\tcase 0x7615:\n\tcase 0x7622:\n\tcase 0x7663:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void\nmt7615_eeprom_parse_hw_band_cap(struct mt7615_dev *dev)\n{\n\tu8 val, *eeprom = dev->mt76.eeprom.data;\n\n\tif (is_mt7663(&dev->mt76)) {\n\t\t \n\t\tdev->mphy.cap.has_2ghz = true;\n\t\tdev->mphy.cap.has_5ghz = true;\n\t\treturn;\n\t}\n\n\tif (is_mt7622(&dev->mt76)) {\n\t\t \n\t\tdev->mphy.cap.has_2ghz = true;\n\t\treturn;\n\t}\n\n\tif (is_mt7611(&dev->mt76)) {\n\t\t \n\t\tdev->mphy.cap.has_5ghz = true;\n\t\treturn;\n\t}\n\n\tval = FIELD_GET(MT_EE_NIC_WIFI_CONF_BAND_SEL,\n\t\t\teeprom[MT_EE_WIFI_CONF]);\n\tswitch (val) {\n\tcase MT_EE_5GHZ:\n\t\tdev->mphy.cap.has_5ghz = true;\n\t\tbreak;\n\tcase MT_EE_DBDC:\n\t\tdev->dbdc_support = true;\n\t\tfallthrough;\n\tcase MT_EE_2GHZ:\n\t\tdev->mphy.cap.has_2ghz = true;\n\t\tbreak;\n\tdefault:\n\t\tdev->mphy.cap.has_2ghz = true;\n\t\tdev->mphy.cap.has_5ghz = true;\n\t\tbreak;\n\t}\n}\n\nstatic void mt7615_eeprom_parse_hw_cap(struct mt7615_dev *dev)\n{\n\tu8 *eeprom = dev->mt76.eeprom.data;\n\tu8 tx_mask, max_nss;\n\n\tmt7615_eeprom_parse_hw_band_cap(dev);\n\n\tif (is_mt7663(&dev->mt76)) {\n\t\tmax_nss = 2;\n\t\ttx_mask = FIELD_GET(MT_EE_HW_CONF1_TX_MASK,\n\t\t\t\t    eeprom[MT7663_EE_HW_CONF1]);\n\t} else {\n\t\tu32 val;\n\n\t\t \n\t\tval = mt76_rr(dev, MT_TOP_STRAP_STA);\n\t\tmax_nss = val & MT_TOP_3NSS ? 3 : 4;\n\n\t\ttx_mask =  FIELD_GET(MT_EE_NIC_CONF_TX_MASK,\n\t\t\t\t     eeprom[MT_EE_NIC_CONF_0]);\n\t}\n\tif (!tx_mask || tx_mask > max_nss)\n\t\ttx_mask = max_nss;\n\n\tdev->chainmask = BIT(tx_mask) - 1;\n\tdev->mphy.antenna_mask = dev->chainmask;\n\tdev->mphy.chainmask = dev->chainmask;\n}\n\nstatic int mt7663_eeprom_get_target_power_index(struct mt7615_dev *dev,\n\t\t\t\t\t\tstruct ieee80211_channel *chan,\n\t\t\t\t\t\tu8 chain_idx)\n{\n\tint index, group;\n\n\tif (chain_idx > 1)\n\t\treturn -EINVAL;\n\n\tif (chan->band == NL80211_BAND_2GHZ)\n\t\treturn MT7663_EE_TX0_2G_TARGET_POWER + (chain_idx << 4);\n\n\tgroup = mt7615_get_channel_group(chan->hw_value);\n\tif (chain_idx == 1)\n\t\tindex = MT7663_EE_TX1_5G_G0_TARGET_POWER;\n\telse\n\t\tindex = MT7663_EE_TX0_5G_G0_TARGET_POWER;\n\n\treturn index + group * 3;\n}\n\nint mt7615_eeprom_get_target_power_index(struct mt7615_dev *dev,\n\t\t\t\t\t struct ieee80211_channel *chan,\n\t\t\t\t\t u8 chain_idx)\n{\n\tint index;\n\n\tif (is_mt7663(&dev->mt76))\n\t\treturn mt7663_eeprom_get_target_power_index(dev, chan,\n\t\t\t\t\t\t\t    chain_idx);\n\n\tif (chain_idx > 3)\n\t\treturn -EINVAL;\n\n\t \n\tif (mt7615_ext_pa_enabled(dev, chan->band)) {\n\t\tif (chan->band == NL80211_BAND_2GHZ)\n\t\t\treturn MT_EE_EXT_PA_2G_TARGET_POWER;\n\t\telse\n\t\t\treturn MT_EE_EXT_PA_5G_TARGET_POWER;\n\t}\n\n\t \n\tif (chan->band == NL80211_BAND_2GHZ) {\n\t\tindex = MT_EE_TX0_2G_TARGET_POWER + chain_idx * 6;\n\t} else {\n\t\tint group = mt7615_get_channel_group(chan->hw_value);\n\n\t\tswitch (chain_idx) {\n\t\tcase 1:\n\t\t\tindex = MT_EE_TX1_5G_G0_TARGET_POWER;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tindex = MT_EE_TX2_5G_G0_TARGET_POWER;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tindex = MT_EE_TX3_5G_G0_TARGET_POWER;\n\t\t\tbreak;\n\t\tcase 0:\n\t\tdefault:\n\t\t\tindex = MT_EE_TX0_5G_G0_TARGET_POWER;\n\t\t\tbreak;\n\t\t}\n\t\tindex += 5 * group;\n\t}\n\n\treturn index;\n}\n\nint mt7615_eeprom_get_power_delta_index(struct mt7615_dev *dev,\n\t\t\t\t\tenum nl80211_band band)\n{\n\t \n\tif (is_mt7663(&dev->mt76)) {\n\t\tif (band == NL80211_BAND_2GHZ)\n\t\t\treturn MT_EE_TX0_5G_G0_TARGET_POWER;\n\t\telse\n\t\t\treturn MT7663_EE_5G_RATE_POWER;\n\t}\n\n\tif (band == NL80211_BAND_2GHZ)\n\t\treturn MT_EE_2G_RATE_POWER;\n\telse\n\t\treturn MT_EE_5G_RATE_POWER;\n}\n\nstatic void mt7615_apply_cal_free_data(struct mt7615_dev *dev)\n{\n\tstatic const u16 ical[] = {\n\t\t0x53, 0x54, 0x55, 0x56, 0x57, 0x5c, 0x5d, 0x62, 0x63, 0x68,\n\t\t0x69, 0x6e, 0x6f, 0x73, 0x74, 0x78, 0x79, 0x82, 0x83, 0x87,\n\t\t0x88, 0x8c, 0x8d, 0x91, 0x92, 0x96, 0x97, 0x9b, 0x9c, 0xa0,\n\t\t0xa1, 0xaa, 0xab, 0xaf, 0xb0, 0xb4, 0xb5, 0xb9, 0xba, 0xf4,\n\t\t0xf7, 0xff,\n\t\t0x140, 0x141, 0x145, 0x146, 0x14a, 0x14b, 0x154, 0x155, 0x159,\n\t\t0x15a, 0x15e, 0x15f, 0x163, 0x164, 0x168, 0x169, 0x16d, 0x16e,\n\t\t0x172, 0x173, 0x17c, 0x17d, 0x181, 0x182, 0x186, 0x187, 0x18b,\n\t\t0x18c\n\t};\n\tstatic const u16 ical_nocheck[] = {\n\t\t0x110, 0x111, 0x112, 0x113, 0x114, 0x115, 0x116, 0x117, 0x118,\n\t\t0x1b5, 0x1b6, 0x1b7, 0x3ac, 0x3ad, 0x3ae, 0x3af, 0x3b0, 0x3b1,\n\t\t0x3b2\n\t};\n\tu8 *eeprom = dev->mt76.eeprom.data;\n\tu8 *otp = dev->mt76.otp.data;\n\tint i;\n\n\tif (!otp)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(ical); i++)\n\t\tif (!otp[ical[i]])\n\t\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(ical); i++)\n\t\teeprom[ical[i]] = otp[ical[i]];\n\n\tfor (i = 0; i < ARRAY_SIZE(ical_nocheck); i++)\n\t\teeprom[ical_nocheck[i]] = otp[ical_nocheck[i]];\n}\n\nstatic void mt7622_apply_cal_free_data(struct mt7615_dev *dev)\n{\n\tstatic const u16 ical[] = {\n\t\t0x53, 0x54, 0x55, 0x56, 0xf4, 0xf7, 0x144, 0x156, 0x15b\n\t};\n\tu8 *eeprom = dev->mt76.eeprom.data;\n\tu8 *otp = dev->mt76.otp.data;\n\tint i;\n\n\tif (!otp)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(ical); i++) {\n\t\tif (!otp[ical[i]])\n\t\t\tcontinue;\n\n\t\teeprom[ical[i]] = otp[ical[i]];\n\t}\n}\n\nstatic void mt7615_cal_free_data(struct mt7615_dev *dev)\n{\n\tstruct device_node *np = dev->mt76.dev->of_node;\n\n\tif (!np || !of_property_read_bool(np, \"mediatek,eeprom-merge-otp\"))\n\t\treturn;\n\n\tswitch (mt76_chip(&dev->mt76)) {\n\tcase 0x7622:\n\t\tmt7622_apply_cal_free_data(dev);\n\t\tbreak;\n\tcase 0x7615:\n\tcase 0x7611:\n\t\tmt7615_apply_cal_free_data(dev);\n\t\tbreak;\n\t}\n}\n\nint mt7615_eeprom_init(struct mt7615_dev *dev, u32 addr)\n{\n\tint ret;\n\n\tret = mt7615_eeprom_load(dev, addr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mt7615_check_eeprom(&dev->mt76);\n\tif (ret && dev->mt76.otp.data) {\n\t\tmemcpy(dev->mt76.eeprom.data, dev->mt76.otp.data,\n\t\t       dev->mt76.otp.size);\n\t} else {\n\t\tdev->flash_eeprom = true;\n\t\tmt7615_cal_free_data(dev);\n\t}\n\n\tmt7615_eeprom_parse_hw_cap(dev);\n\tmemcpy(dev->mphy.macaddr, dev->mt76.eeprom.data + MT_EE_MAC_ADDR,\n\t       ETH_ALEN);\n\n\tmt76_eeprom_override(&dev->mphy);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt7615_eeprom_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}