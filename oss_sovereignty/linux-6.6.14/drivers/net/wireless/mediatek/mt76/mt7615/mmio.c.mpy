{
  "module_name": "mmio.c",
  "hash_id": "3e2ce02d72b63b4934907c21447a8518782ce72c9cf451d81c862ea609beb220",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7615/mmio.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pci.h>\n\n#include \"mt7615.h\"\n#include \"regs.h\"\n#include \"mac.h\"\n#include \"../trace.h\"\n\nconst u32 mt7615e_reg_map[] = {\n\t[MT_TOP_CFG_BASE]\t= 0x01000,\n\t[MT_HW_BASE]\t\t= 0x01000,\n\t[MT_PCIE_REMAP_2]\t= 0x02504,\n\t[MT_ARB_BASE]\t\t= 0x20c00,\n\t[MT_HIF_BASE]\t\t= 0x04000,\n\t[MT_CSR_BASE]\t\t= 0x07000,\n\t[MT_PLE_BASE]\t\t= 0x08000,\n\t[MT_PSE_BASE]\t\t= 0x0c000,\n\t[MT_CFG_BASE]\t\t= 0x20200,\n\t[MT_AGG_BASE]\t\t= 0x20a00,\n\t[MT_TMAC_BASE]\t\t= 0x21000,\n\t[MT_RMAC_BASE]\t\t= 0x21200,\n\t[MT_DMA_BASE]\t\t= 0x21800,\n\t[MT_PF_BASE]\t\t= 0x22000,\n\t[MT_WTBL_BASE_ON]\t= 0x23000,\n\t[MT_WTBL_BASE_OFF]\t= 0x23400,\n\t[MT_LPON_BASE]\t\t= 0x24200,\n\t[MT_MIB_BASE]\t\t= 0x24800,\n\t[MT_WTBL_BASE_ADDR]\t= 0x30000,\n\t[MT_PCIE_REMAP_BASE2]\t= 0x80000,\n\t[MT_TOP_MISC_BASE]\t= 0xc0000,\n\t[MT_EFUSE_ADDR_BASE]\t= 0x81070000,\n};\n\nconst u32 mt7663e_reg_map[] = {\n\t[MT_TOP_CFG_BASE]\t= 0x01000,\n\t[MT_HW_BASE]\t\t= 0x02000,\n\t[MT_DMA_SHDL_BASE]\t= 0x06000,\n\t[MT_PCIE_REMAP_2]\t= 0x0700c,\n\t[MT_ARB_BASE]\t\t= 0x20c00,\n\t[MT_HIF_BASE]\t\t= 0x04000,\n\t[MT_CSR_BASE]\t\t= 0x07000,\n\t[MT_PLE_BASE]\t\t= 0x08000,\n\t[MT_PSE_BASE]\t\t= 0x0c000,\n\t[MT_PP_BASE]            = 0x0e000,\n\t[MT_CFG_BASE]\t\t= 0x20000,\n\t[MT_AGG_BASE]\t\t= 0x22000,\n\t[MT_TMAC_BASE]\t\t= 0x24000,\n\t[MT_RMAC_BASE]\t\t= 0x25000,\n\t[MT_DMA_BASE]\t\t= 0x27000,\n\t[MT_PF_BASE]\t\t= 0x28000,\n\t[MT_WTBL_BASE_ON]\t= 0x29000,\n\t[MT_WTBL_BASE_OFF]\t= 0x29800,\n\t[MT_LPON_BASE]\t\t= 0x2b000,\n\t[MT_MIB_BASE]\t\t= 0x2d000,\n\t[MT_WTBL_BASE_ADDR]\t= 0x30000,\n\t[MT_PCIE_REMAP_BASE2]\t= 0x90000,\n\t[MT_TOP_MISC_BASE]\t= 0xc0000,\n\t[MT_EFUSE_ADDR_BASE]\t= 0x78011000,\n};\n\nstatic void\nmt7615_rx_poll_complete(struct mt76_dev *mdev, enum mt76_rxq_id q)\n{\n\tmt76_connac_irq_enable(mdev, MT_INT_RX_DONE(q));\n}\n\nstatic irqreturn_t mt7615_irq_handler(int irq, void *dev_instance)\n{\n\tstruct mt7615_dev *dev = dev_instance;\n\n\tmt76_wr(dev, MT_INT_MASK_CSR, 0);\n\n\tif (!test_bit(MT76_STATE_INITIALIZED, &dev->mphy.state))\n\t\treturn IRQ_NONE;\n\n\ttasklet_schedule(&dev->mt76.irq_tasklet);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void mt7615_irq_tasklet(struct tasklet_struct *t)\n{\n\tstruct mt7615_dev *dev = from_tasklet(dev, t, mt76.irq_tasklet);\n\tu32 intr, mask = 0, tx_mcu_mask = mt7615_tx_mcu_int_mask(dev);\n\tu32 mcu_int;\n\n\tmt76_wr(dev, MT_INT_MASK_CSR, 0);\n\n\tintr = mt76_rr(dev, MT_INT_SOURCE_CSR);\n\tintr &= dev->mt76.mmio.irqmask;\n\tmt76_wr(dev, MT_INT_SOURCE_CSR, intr);\n\n\ttrace_dev_irq(&dev->mt76, intr, dev->mt76.mmio.irqmask);\n\n\tmask |= intr & MT_INT_RX_DONE_ALL;\n\tif (intr & tx_mcu_mask)\n\t\tmask |= tx_mcu_mask;\n\tmt76_set_irq_mask(&dev->mt76, MT_INT_MASK_CSR, mask, 0);\n\n\tif (intr & tx_mcu_mask)\n\t\tnapi_schedule(&dev->mt76.tx_napi);\n\n\tif (intr & MT_INT_RX_DONE(0))\n\t\tnapi_schedule(&dev->mt76.napi[0]);\n\n\tif (intr & MT_INT_RX_DONE(1))\n\t\tnapi_schedule(&dev->mt76.napi[1]);\n\n\tif (!(intr & (MT_INT_MCU_CMD | MT7663_INT_MCU_CMD)))\n\t\treturn;\n\n\tif (is_mt7663(&dev->mt76)) {\n\t\tmcu_int = mt76_rr(dev, MT_MCU2HOST_INT_STATUS);\n\t\tmcu_int &= MT7663_MCU_CMD_ERROR_MASK;\n\t\tmt76_wr(dev, MT_MCU2HOST_INT_STATUS, mcu_int);\n\t} else {\n\t\tmcu_int = mt76_rr(dev, MT_MCU_CMD);\n\t\tmcu_int &= MT_MCU_CMD_ERROR_MASK;\n\t}\n\n\tif (!mcu_int)\n\t\treturn;\n\n\tdev->reset_state = mcu_int;\n\tqueue_work(dev->mt76.wq, &dev->reset_work);\n\twake_up(&dev->reset_wait);\n}\n\nstatic u32 __mt7615_reg_addr(struct mt7615_dev *dev, u32 addr)\n{\n\tif (addr < 0x100000)\n\t\treturn addr;\n\n\treturn mt7615_reg_map(dev, addr);\n}\n\nstatic u32 mt7615_rr(struct mt76_dev *mdev, u32 offset)\n{\n\tstruct mt7615_dev *dev = container_of(mdev, struct mt7615_dev, mt76);\n\tu32 addr = __mt7615_reg_addr(dev, offset);\n\n\treturn dev->bus_ops->rr(mdev, addr);\n}\n\nstatic void mt7615_wr(struct mt76_dev *mdev, u32 offset, u32 val)\n{\n\tstruct mt7615_dev *dev = container_of(mdev, struct mt7615_dev, mt76);\n\tu32 addr = __mt7615_reg_addr(dev, offset);\n\n\tdev->bus_ops->wr(mdev, addr, val);\n}\n\nstatic u32 mt7615_rmw(struct mt76_dev *mdev, u32 offset, u32 mask, u32 val)\n{\n\tstruct mt7615_dev *dev = container_of(mdev, struct mt7615_dev, mt76);\n\tu32 addr = __mt7615_reg_addr(dev, offset);\n\n\treturn dev->bus_ops->rmw(mdev, addr, mask, val);\n}\n\nint mt7615_mmio_probe(struct device *pdev, void __iomem *mem_base,\n\t\t      int irq, const u32 *map)\n{\n\tstatic const struct mt76_driver_ops drv_ops = {\n\t\t \n\t\t.txwi_size = MT_TXD_SIZE + sizeof(struct mt76_connac_txp_common),\n\t\t.drv_flags = MT_DRV_TXWI_NO_FREE | MT_DRV_HW_MGMT_TXQ,\n\t\t.survey_flags = SURVEY_INFO_TIME_TX |\n\t\t\t\tSURVEY_INFO_TIME_RX |\n\t\t\t\tSURVEY_INFO_TIME_BSS_RX,\n\t\t.token_size = MT7615_TOKEN_SIZE,\n\t\t.tx_prepare_skb = mt7615_tx_prepare_skb,\n\t\t.tx_complete_skb = mt76_connac_tx_complete_skb,\n\t\t.rx_check = mt7615_rx_check,\n\t\t.rx_skb = mt7615_queue_rx_skb,\n\t\t.rx_poll_complete = mt7615_rx_poll_complete,\n\t\t.sta_add = mt7615_mac_sta_add,\n\t\t.sta_remove = mt7615_mac_sta_remove,\n\t\t.update_survey = mt7615_update_channel,\n\t};\n\tstruct mt76_bus_ops *bus_ops;\n\tstruct ieee80211_ops *ops;\n\tstruct mt7615_dev *dev;\n\tstruct mt76_dev *mdev;\n\tint ret;\n\n\tops = devm_kmemdup(pdev, &mt7615_ops, sizeof(mt7615_ops), GFP_KERNEL);\n\tif (!ops)\n\t\treturn -ENOMEM;\n\n\tmdev = mt76_alloc_device(pdev, sizeof(*dev), ops, &drv_ops);\n\tif (!mdev)\n\t\treturn -ENOMEM;\n\n\tdev = container_of(mdev, struct mt7615_dev, mt76);\n\tmt76_mmio_init(&dev->mt76, mem_base);\n\ttasklet_setup(&mdev->irq_tasklet, mt7615_irq_tasklet);\n\n\tdev->reg_map = map;\n\tdev->ops = ops;\n\tmdev->rev = (mt76_rr(dev, MT_HW_CHIPID) << 16) |\n\t\t    (mt76_rr(dev, MT_HW_REV) & 0xff);\n\tdev_dbg(mdev->dev, \"ASIC revision: %04x\\n\", mdev->rev);\n\n\tdev->bus_ops = dev->mt76.bus;\n\tbus_ops = devm_kmemdup(dev->mt76.dev, dev->bus_ops, sizeof(*bus_ops),\n\t\t\t       GFP_KERNEL);\n\tif (!bus_ops) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_dev;\n\t}\n\n\tbus_ops->rr = mt7615_rr;\n\tbus_ops->wr = mt7615_wr;\n\tbus_ops->rmw = mt7615_rmw;\n\tdev->mt76.bus = bus_ops;\n\n\tmt76_wr(dev, MT_INT_MASK_CSR, 0);\n\n\tret = devm_request_irq(mdev->dev, irq, mt7615_irq_handler,\n\t\t\t       IRQF_SHARED, KBUILD_MODNAME, dev);\n\tif (ret)\n\t\tgoto err_free_dev;\n\n\tif (is_mt7663(mdev))\n\t\tmt76_wr(dev, MT_PCIE_IRQ_ENABLE, 1);\n\n\tret = mt7615_register_device(dev);\n\tif (ret)\n\t\tgoto err_free_irq;\n\n\treturn 0;\n\nerr_free_irq:\n\tdevm_free_irq(pdev, irq, dev);\nerr_free_dev:\n\tmt76_free_device(&dev->mt76);\n\n\treturn ret;\n}\n\nstatic int __init mt7615_init(void)\n{\n\tint ret;\n\n\tret = pci_register_driver(&mt7615_pci_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tif (IS_ENABLED(CONFIG_MT7622_WMAC)) {\n\t\tret = platform_driver_register(&mt7622_wmac_driver);\n\t\tif (ret)\n\t\t\tpci_unregister_driver(&mt7615_pci_driver);\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit mt7615_exit(void)\n{\n\tif (IS_ENABLED(CONFIG_MT7622_WMAC))\n\t\tplatform_driver_unregister(&mt7622_wmac_driver);\n\tpci_unregister_driver(&mt7615_pci_driver);\n}\n\nmodule_init(mt7615_init);\nmodule_exit(mt7615_exit);\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}