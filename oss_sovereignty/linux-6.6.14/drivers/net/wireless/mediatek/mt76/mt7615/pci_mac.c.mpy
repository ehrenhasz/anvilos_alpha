{
  "module_name": "pci_mac.c",
  "hash_id": "b04c36dcb83def92ef5bda92a493b6584f5a4dd04d7ddb60faffc481048f6de3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7615/pci_mac.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/timekeeping.h>\n\n#include \"mt7615.h\"\n#include \"../dma.h\"\n#include \"mac.h\"\n\nstatic void\nmt7615_write_fw_txp(struct mt7615_dev *dev, struct mt76_tx_info *tx_info,\n\t\t    void *txp_ptr, u32 id)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx_info->skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx_info->skb);\n\tstruct ieee80211_key_conf *key = info->control.hw_key;\n\tstruct ieee80211_vif *vif = info->control.vif;\n\tstruct mt76_connac_fw_txp *txp = txp_ptr;\n\tu8 *rept_wds_wcid = (u8 *)&txp->rept_wds_wcid;\n\tint nbuf = tx_info->nbuf - 1;\n\tint i;\n\n\tfor (i = 0; i < nbuf; i++) {\n\t\ttxp->buf[i] = cpu_to_le32(tx_info->buf[i + 1].addr);\n\t\ttxp->len[i] = cpu_to_le16(tx_info->buf[i + 1].len);\n\t}\n\ttxp->nbuf = nbuf;\n\n\t \n\ttx_info->buf[0].len = MT_TXD_SIZE + sizeof(*txp);\n\ttx_info->buf[1].len = MT_CT_PARSE_LEN;\n\ttx_info->buf[1].skip_unmap = true;\n\ttx_info->nbuf = MT_CT_DMA_BUF_NUM;\n\n\ttxp->flags = cpu_to_le16(MT_CT_INFO_APPLY_TXD);\n\n\tif (!key)\n\t\ttxp->flags |= cpu_to_le16(MT_CT_INFO_NONE_CIPHER_FRAME);\n\n\tif (ieee80211_is_mgmt(hdr->frame_control))\n\t\ttxp->flags |= cpu_to_le16(MT_CT_INFO_MGMT_FRAME);\n\n\tif (vif) {\n\t\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\n\t\ttxp->bss_idx = mvif->idx;\n\t}\n\n\ttxp->token = cpu_to_le16(id);\n\t*rept_wds_wcid = 0xff;\n}\n\nint mt7615_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,\n\t\t\t  enum mt76_txq_id qid, struct mt76_wcid *wcid,\n\t\t\t  struct ieee80211_sta *sta,\n\t\t\t  struct mt76_tx_info *tx_info)\n{\n\tstruct mt7615_dev *dev = container_of(mdev, struct mt7615_dev, mt76);\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx_info->skb);\n\tstruct ieee80211_key_conf *key = info->control.hw_key;\n\tint pid, id;\n\tu8 *txwi = (u8 *)txwi_ptr;\n\tstruct mt76_txwi_cache *t;\n\tstruct mt7615_sta *msta;\n\tvoid *txp;\n\n\tmsta = wcid ? container_of(wcid, struct mt7615_sta, wcid) : NULL;\n\tif (!wcid)\n\t\twcid = &dev->mt76.global_wcid;\n\n\tif ((info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE) && msta) {\n\t\tstruct mt7615_phy *phy = &dev->phy;\n\t\tu8 phy_idx = (info->hw_queue & MT_TX_HW_QUEUE_PHY) >> 2;\n\n\t\tif (phy_idx && mdev->phys[MT_BAND1])\n\t\t\tphy = mdev->phys[MT_BAND1]->priv;\n\n\t\tspin_lock_bh(&dev->mt76.lock);\n\t\tmt7615_mac_set_rates(phy, msta, &info->control.rates[0],\n\t\t\t\t     msta->rates);\n\t\tspin_unlock_bh(&dev->mt76.lock);\n\t}\n\n\tt = (struct mt76_txwi_cache *)(txwi + mdev->drv->txwi_size);\n\tt->skb = tx_info->skb;\n\n\tid = mt76_token_get(mdev, &t);\n\tif (id < 0)\n\t\treturn id;\n\n\tpid = mt76_tx_status_skb_add(mdev, wcid, tx_info->skb);\n\tmt7615_mac_write_txwi(dev, txwi_ptr, tx_info->skb, wcid, sta,\n\t\t\t      pid, key, qid, false);\n\n\ttxp = txwi + MT_TXD_SIZE;\n\tmemset(txp, 0, sizeof(struct mt76_connac_txp_common));\n\tif (is_mt7615(&dev->mt76))\n\t\tmt7615_write_fw_txp(dev, tx_info, txp, id);\n\telse\n\t\tmt76_connac_write_hw_txp(mdev, tx_info, txp, id);\n\n\ttx_info->skb = NULL;\n\n\treturn 0;\n}\n\nvoid mt7615_dma_reset(struct mt7615_dev *dev)\n{\n\tint i;\n\n\tmt76_clear(dev, MT_WPDMA_GLO_CFG,\n\t\t   MT_WPDMA_GLO_CFG_RX_DMA_EN | MT_WPDMA_GLO_CFG_TX_DMA_EN |\n\t\t   MT_WPDMA_GLO_CFG_TX_WRITEBACK_DONE);\n\n\tusleep_range(1000, 2000);\n\n\tfor (i = 0; i < __MT_TXQ_MAX; i++)\n\t\tmt76_queue_tx_cleanup(dev, dev->mphy.q_tx[i], true);\n\n\tfor (i = 0; i < __MT_MCUQ_MAX; i++)\n\t\tmt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[i], true);\n\n\tmt76_for_each_q_rx(&dev->mt76, i)\n\t\tmt76_queue_rx_reset(dev, i);\n\n\tmt76_tx_status_check(&dev->mt76, true);\n\n\tmt7615_dma_start(dev);\n}\nEXPORT_SYMBOL_GPL(mt7615_dma_reset);\n\nstatic void\nmt7615_hif_int_event_trigger(struct mt7615_dev *dev, u8 event)\n{\n\tu32 reg = MT_MCU_INT_EVENT;\n\n\tif (is_mt7663(&dev->mt76))\n\t\treg = MT7663_MCU_INT_EVENT;\n\n\tmt76_wr(dev, reg, event);\n\n\tmt7622_trigger_hif_int(dev, true);\n\tmt7622_trigger_hif_int(dev, false);\n}\n\nstatic bool\nmt7615_wait_reset_state(struct mt7615_dev *dev, u32 state)\n{\n\tbool ret;\n\n\tret = wait_event_timeout(dev->reset_wait,\n\t\t\t\t (READ_ONCE(dev->reset_state) & state),\n\t\t\t\t MT7615_RESET_TIMEOUT);\n\tWARN(!ret, \"Timeout waiting for MCU reset state %x\\n\", state);\n\treturn ret;\n}\n\nstatic void\nmt7615_update_vif_beacon(void *priv, u8 *mac, struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_hw *hw = priv;\n\tstruct mt7615_dev *dev = mt7615_hw_dev(hw);\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_AP:\n\t\tmt7615_mcu_add_beacon(dev, hw, vif,\n\t\t\t\t      vif->bss_conf.enable_beacon);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\nmt7615_update_beacons(struct mt7615_dev *dev)\n{\n\tstruct mt76_phy *mphy_ext = dev->mt76.phys[MT_BAND1];\n\n\tieee80211_iterate_active_interfaces(dev->mt76.hw,\n\t\tIEEE80211_IFACE_ITER_RESUME_ALL,\n\t\tmt7615_update_vif_beacon, dev->mt76.hw);\n\n\tif (!mphy_ext)\n\t\treturn;\n\n\tieee80211_iterate_active_interfaces(mphy_ext->hw,\n\t\tIEEE80211_IFACE_ITER_RESUME_ALL,\n\t\tmt7615_update_vif_beacon, mphy_ext->hw);\n}\n\nvoid mt7615_mac_reset_work(struct work_struct *work)\n{\n\tstruct mt7615_phy *phy2;\n\tstruct mt76_phy *ext_phy;\n\tstruct mt7615_dev *dev;\n\tunsigned long timeout;\n\tint i;\n\n\tdev = container_of(work, struct mt7615_dev, reset_work);\n\text_phy = dev->mt76.phys[MT_BAND1];\n\tphy2 = ext_phy ? ext_phy->priv : NULL;\n\n\tif (!(READ_ONCE(dev->reset_state) & MT_MCU_CMD_STOP_PDMA))\n\t\treturn;\n\n\tieee80211_stop_queues(mt76_hw(dev));\n\tif (ext_phy)\n\t\tieee80211_stop_queues(ext_phy->hw);\n\n\tset_bit(MT76_RESET, &dev->mphy.state);\n\tset_bit(MT76_MCU_RESET, &dev->mphy.state);\n\twake_up(&dev->mt76.mcu.wait);\n\tcancel_delayed_work_sync(&dev->mphy.mac_work);\n\tdel_timer_sync(&dev->phy.roc_timer);\n\tcancel_work_sync(&dev->phy.roc_work);\n\tif (phy2) {\n\t\tset_bit(MT76_RESET, &phy2->mt76->state);\n\t\tcancel_delayed_work_sync(&phy2->mt76->mac_work);\n\t\tdel_timer_sync(&phy2->roc_timer);\n\t\tcancel_work_sync(&phy2->roc_work);\n\t}\n\n\t \n\tmt76_txq_schedule_all(&dev->mphy);\n\tif (ext_phy)\n\t\tmt76_txq_schedule_all(ext_phy);\n\n\tmt76_worker_disable(&dev->mt76.tx_worker);\n\tmt76_for_each_q_rx(&dev->mt76, i)\n\t\tnapi_disable(&dev->mt76.napi[i]);\n\tnapi_disable(&dev->mt76.tx_napi);\n\n\tmt7615_mutex_acquire(dev);\n\n\tmt7615_hif_int_event_trigger(dev, MT_MCU_INT_EVENT_PDMA_STOPPED);\n\n\tif (mt7615_wait_reset_state(dev, MT_MCU_CMD_RESET_DONE)) {\n\t\tmt7615_dma_reset(dev);\n\n\t\tmt7615_tx_token_put(dev);\n\t\tidr_init(&dev->mt76.token);\n\n\t\tmt76_wr(dev, MT_WPDMA_MEM_RNG_ERR, 0);\n\n\t\tmt7615_hif_int_event_trigger(dev, MT_MCU_INT_EVENT_PDMA_INIT);\n\t\tmt7615_wait_reset_state(dev, MT_MCU_CMD_RECOVERY_DONE);\n\t}\n\n\tclear_bit(MT76_MCU_RESET, &dev->mphy.state);\n\tclear_bit(MT76_RESET, &dev->mphy.state);\n\tif (phy2)\n\t\tclear_bit(MT76_RESET, &phy2->mt76->state);\n\n\tmt76_worker_enable(&dev->mt76.tx_worker);\n\n\tlocal_bh_disable();\n\tnapi_enable(&dev->mt76.tx_napi);\n\tnapi_schedule(&dev->mt76.tx_napi);\n\n\tmt76_for_each_q_rx(&dev->mt76, i) {\n\t\tnapi_enable(&dev->mt76.napi[i]);\n\t\tnapi_schedule(&dev->mt76.napi[i]);\n\t}\n\tlocal_bh_enable();\n\n\tieee80211_wake_queues(mt76_hw(dev));\n\tif (ext_phy)\n\t\tieee80211_wake_queues(ext_phy->hw);\n\n\tmt7615_hif_int_event_trigger(dev, MT_MCU_INT_EVENT_RESET_DONE);\n\tmt7615_wait_reset_state(dev, MT_MCU_CMD_NORMAL_STATE);\n\n\tmt7615_update_beacons(dev);\n\n\tmt7615_mutex_release(dev);\n\n\ttimeout = mt7615_get_macwork_timeout(dev);\n\tieee80211_queue_delayed_work(mt76_hw(dev), &dev->mphy.mac_work,\n\t\t\t\t     timeout);\n\tif (phy2)\n\t\tieee80211_queue_delayed_work(ext_phy->hw,\n\t\t\t\t\t     &phy2->mt76->mac_work, timeout);\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}