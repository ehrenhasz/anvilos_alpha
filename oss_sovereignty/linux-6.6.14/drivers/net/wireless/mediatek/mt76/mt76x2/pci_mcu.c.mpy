{
  "module_name": "pci_mcu.c",
  "hash_id": "aa10411e9e0c83015c3e13e2916d78f323e14ee0df1325827987b1bc08995f38",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt76x2/pci_mcu.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/firmware.h>\n#include <linux/delay.h>\n\n#include \"mt76x2.h\"\n#include \"mcu.h\"\n#include \"eeprom.h\"\n\nstatic int\nmt76pci_load_rom_patch(struct mt76x02_dev *dev)\n{\n\tconst struct firmware *fw = NULL;\n\tstruct mt76x02_patch_header *hdr;\n\tbool rom_protect = !is_mt7612(dev);\n\tint len, ret = 0;\n\t__le32 *cur;\n\tu32 patch_mask, patch_reg;\n\n\tif (rom_protect && !mt76_poll(dev, MT_MCU_SEMAPHORE_03, 1, 1, 600)) {\n\t\tdev_err(dev->mt76.dev,\n\t\t\t\"Could not get hardware semaphore for ROM PATCH\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (mt76xx_rev(dev) >= MT76XX_REV_E3) {\n\t\tpatch_mask = BIT(0);\n\t\tpatch_reg = MT_MCU_CLOCK_CTL;\n\t} else {\n\t\tpatch_mask = BIT(1);\n\t\tpatch_reg = MT_MCU_COM_REG0;\n\t}\n\n\tif (rom_protect && (mt76_rr(dev, patch_reg) & patch_mask)) {\n\t\tdev_info(dev->mt76.dev, \"ROM patch already applied\\n\");\n\t\tgoto out;\n\t}\n\n\tret = request_firmware(&fw, MT7662_ROM_PATCH, dev->mt76.dev);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!fw || !fw->data || fw->size <= sizeof(*hdr)) {\n\t\tret = -EIO;\n\t\tdev_err(dev->mt76.dev, \"Failed to load firmware\\n\");\n\t\tgoto out;\n\t}\n\n\thdr = (struct mt76x02_patch_header *)fw->data;\n\tdev_info(dev->mt76.dev, \"ROM patch build: %.15s\\n\", hdr->build_time);\n\n\tmt76_wr(dev, MT_MCU_PCIE_REMAP_BASE4, MT_MCU_ROM_PATCH_OFFSET);\n\n\tcur = (__le32 *)(fw->data + sizeof(*hdr));\n\tlen = fw->size - sizeof(*hdr);\n\tmt76_wr_copy(dev, MT_MCU_ROM_PATCH_ADDR, cur, len);\n\n\tmt76_wr(dev, MT_MCU_PCIE_REMAP_BASE4, 0);\n\n\t \n\tmt76_wr(dev, MT_MCU_INT_LEVEL, 4);\n\n\tif (!mt76_poll_msec(dev, patch_reg, patch_mask, patch_mask, 2000)) {\n\t\tdev_err(dev->mt76.dev, \"Failed to load ROM patch\\n\");\n\t\tret = -ETIMEDOUT;\n\t}\n\nout:\n\t \n\tif (rom_protect)\n\t\tmt76_wr(dev, MT_MCU_SEMAPHORE_03, 1);\n\trelease_firmware(fw);\n\treturn ret;\n}\n\nstatic int\nmt76pci_load_firmware(struct mt76x02_dev *dev)\n{\n\tconst struct firmware *fw;\n\tconst struct mt76x02_fw_header *hdr;\n\tint len, ret;\n\t__le32 *cur;\n\tu32 offset, val;\n\n\tret = request_firmware(&fw, MT7662_FIRMWARE, dev->mt76.dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!fw || !fw->data || fw->size < sizeof(*hdr))\n\t\tgoto error;\n\n\thdr = (const struct mt76x02_fw_header *)fw->data;\n\n\tlen = sizeof(*hdr);\n\tlen += le32_to_cpu(hdr->ilm_len);\n\tlen += le32_to_cpu(hdr->dlm_len);\n\n\tif (fw->size != len)\n\t\tgoto error;\n\n\tval = le16_to_cpu(hdr->fw_ver);\n\tdev_info(dev->mt76.dev, \"Firmware Version: %d.%d.%02d\\n\",\n\t\t (val >> 12) & 0xf, (val >> 8) & 0xf, val & 0xf);\n\n\tval = le16_to_cpu(hdr->build_ver);\n\tdev_info(dev->mt76.dev, \"Build: %x\\n\", val);\n\tdev_info(dev->mt76.dev, \"Build Time: %.16s\\n\", hdr->build_time);\n\n\tcur = (__le32 *)(fw->data + sizeof(*hdr));\n\tlen = le32_to_cpu(hdr->ilm_len);\n\n\tmt76_wr(dev, MT_MCU_PCIE_REMAP_BASE4, MT_MCU_ILM_OFFSET);\n\tmt76_wr_copy(dev, MT_MCU_ILM_ADDR, cur, len);\n\n\tcur += len / sizeof(*cur);\n\tlen = le32_to_cpu(hdr->dlm_len);\n\n\tif (mt76xx_rev(dev) >= MT76XX_REV_E3)\n\t\toffset = MT_MCU_DLM_ADDR_E3;\n\telse\n\t\toffset = MT_MCU_DLM_ADDR;\n\n\tmt76_wr(dev, MT_MCU_PCIE_REMAP_BASE4, MT_MCU_DLM_OFFSET);\n\tmt76_wr_copy(dev, offset, cur, len);\n\n\tmt76_wr(dev, MT_MCU_PCIE_REMAP_BASE4, 0);\n\n\tval = mt76x02_eeprom_get(dev, MT_EE_NIC_CONF_2);\n\tif (FIELD_GET(MT_EE_NIC_CONF_2_XTAL_OPTION, val) == 1)\n\t\tmt76_set(dev, MT_MCU_COM_REG0, BIT(30));\n\n\t \n\tmt76_wr(dev, MT_MCU_INT_LEVEL, 2);\n\tif (!mt76_poll_msec(dev, MT_MCU_COM_REG0, 1, 1, 200)) {\n\t\tdev_err(dev->mt76.dev, \"Firmware failed to start\\n\");\n\t\trelease_firmware(fw);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tmt76x02_set_ethtool_fwver(dev, hdr);\n\tdev_info(dev->mt76.dev, \"Firmware running!\\n\");\n\n\trelease_firmware(fw);\n\n\treturn ret;\n\nerror:\n\tdev_err(dev->mt76.dev, \"Invalid firmware\\n\");\n\trelease_firmware(fw);\n\treturn -ENOENT;\n}\n\nstatic int\nmt76pci_mcu_restart(struct mt76_dev *mdev)\n{\n\tstruct mt76x02_dev *dev;\n\tint ret;\n\n\tdev = container_of(mdev, struct mt76x02_dev, mt76);\n\n\tmt76x02_mcu_cleanup(dev);\n\tmt76x2_mac_reset(dev, true);\n\n\tret = mt76pci_load_firmware(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmt76_wr(dev, MT_WPDMA_RST_IDX, ~0);\n\n\treturn 0;\n}\n\nint mt76x2_mcu_init(struct mt76x02_dev *dev)\n{\n\tstatic const struct mt76_mcu_ops mt76x2_mcu_ops = {\n\t\t.mcu_restart = mt76pci_mcu_restart,\n\t\t.mcu_send_msg = mt76x02_mcu_msg_send,\n\t\t.mcu_parse_response = mt76x02_mcu_parse_response,\n\t};\n\tint ret;\n\n\tdev->mt76.mcu_ops = &mt76x2_mcu_ops;\n\n\tret = mt76pci_load_rom_patch(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt76pci_load_firmware(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmt76x02_mcu_function_select(dev, Q_SELECT, 1);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}