{
  "module_name": "pci_init.c",
  "hash_id": "e2a67070588302a5e30db624c34f12a518b293bc499e5ac3c8cb2f297f318121",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt76x2/pci_init.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include \"mt76x2.h\"\n#include \"eeprom.h\"\n#include \"mcu.h\"\n#include \"../mt76x02_mac.h\"\n\nstatic void\nmt76x2_mac_pbf_init(struct mt76x02_dev *dev)\n{\n\tu32 val;\n\n\tval = MT_PBF_SYS_CTRL_MCU_RESET |\n\t      MT_PBF_SYS_CTRL_DMA_RESET |\n\t      MT_PBF_SYS_CTRL_MAC_RESET |\n\t      MT_PBF_SYS_CTRL_PBF_RESET |\n\t      MT_PBF_SYS_CTRL_ASY_RESET;\n\n\tmt76_set(dev, MT_PBF_SYS_CTRL, val);\n\tmt76_clear(dev, MT_PBF_SYS_CTRL, val);\n\n\tmt76_wr(dev, MT_PBF_TX_MAX_PCNT, 0xefef3f1f);\n\tmt76_wr(dev, MT_PBF_RX_MAX_PCNT, 0xfebf);\n}\n\nstatic void\nmt76x2_fixup_xtal(struct mt76x02_dev *dev)\n{\n\tu16 eep_val;\n\ts8 offset = 0;\n\n\teep_val = mt76x02_eeprom_get(dev, MT_EE_XTAL_TRIM_2);\n\n\toffset = eep_val & 0x7f;\n\tif ((eep_val & 0xff) == 0xff)\n\t\toffset = 0;\n\telse if (eep_val & 0x80)\n\t\toffset = 0 - offset;\n\n\teep_val >>= 8;\n\tif (eep_val == 0x00 || eep_val == 0xff) {\n\t\teep_val = mt76x02_eeprom_get(dev, MT_EE_XTAL_TRIM_1);\n\t\teep_val &= 0xff;\n\n\t\tif (eep_val == 0x00 || eep_val == 0xff)\n\t\t\teep_val = 0x14;\n\t}\n\n\teep_val &= 0x7f;\n\tmt76_rmw_field(dev, MT_XO_CTRL5, MT_XO_CTRL5_C2_VAL, eep_val + offset);\n\tmt76_set(dev, MT_XO_CTRL6, MT_XO_CTRL6_C2_CTRL);\n\n\teep_val = mt76x02_eeprom_get(dev, MT_EE_NIC_CONF_2);\n\tswitch (FIELD_GET(MT_EE_NIC_CONF_2_XTAL_OPTION, eep_val)) {\n\tcase 0:\n\t\tmt76_wr(dev, MT_XO_CTRL7, 0x5c1fee80);\n\t\tbreak;\n\tcase 1:\n\t\tmt76_wr(dev, MT_XO_CTRL7, 0x5c1feed0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nint mt76x2_mac_reset(struct mt76x02_dev *dev, bool hard)\n{\n\tconst u8 *macaddr = dev->mphy.macaddr;\n\tu32 val;\n\tint i, k;\n\n\tif (!mt76x02_wait_for_mac(&dev->mt76))\n\t\treturn -ETIMEDOUT;\n\n\tval = mt76_rr(dev, MT_WPDMA_GLO_CFG);\n\n\tval &= ~(MT_WPDMA_GLO_CFG_TX_DMA_EN |\n\t\t MT_WPDMA_GLO_CFG_TX_DMA_BUSY |\n\t\t MT_WPDMA_GLO_CFG_RX_DMA_EN |\n\t\t MT_WPDMA_GLO_CFG_RX_DMA_BUSY |\n\t\t MT_WPDMA_GLO_CFG_DMA_BURST_SIZE);\n\tval |= FIELD_PREP(MT_WPDMA_GLO_CFG_DMA_BURST_SIZE, 3);\n\n\tmt76_wr(dev, MT_WPDMA_GLO_CFG, val);\n\n\tmt76x2_mac_pbf_init(dev);\n\tmt76_write_mac_initvals(dev);\n\tmt76x2_fixup_xtal(dev);\n\n\tmt76_clear(dev, MT_MAC_SYS_CTRL,\n\t\t   MT_MAC_SYS_CTRL_RESET_CSR |\n\t\t   MT_MAC_SYS_CTRL_RESET_BBP);\n\n\tif (is_mt7612(dev))\n\t\tmt76_clear(dev, MT_COEXCFG0, MT_COEXCFG0_COEX_EN);\n\n\tmt76_set(dev, MT_EXT_CCA_CFG, 0x0000f000);\n\tmt76_clear(dev, MT_TX_ALC_CFG_4, BIT(31));\n\n\tmt76_wr(dev, MT_RF_BYPASS_0, 0x06000000);\n\tmt76_wr(dev, MT_RF_SETTING_0, 0x08800000);\n\tusleep_range(5000, 10000);\n\tmt76_wr(dev, MT_RF_BYPASS_0, 0x00000000);\n\n\tmt76_wr(dev, MT_MCU_CLOCK_CTL, 0x1401);\n\tmt76_clear(dev, MT_FCE_L2_STUFF, MT_FCE_L2_STUFF_WR_MPDU_LEN_EN);\n\n\tmt76x02_mac_setaddr(dev, macaddr);\n\tmt76x02e_init_beacon_config(dev);\n\tif (!hard)\n\t\treturn 0;\n\n\tfor (i = 0; i < 256 / 32; i++)\n\t\tmt76_wr(dev, MT_WCID_DROP_BASE + i * 4, 0);\n\n\tfor (i = 0; i < 256; i++) {\n\t\tmt76x02_mac_wcid_setup(dev, i, 0, NULL);\n\t\tmt76_wr(dev, MT_WCID_TX_RATE(i), 0);\n\t\tmt76_wr(dev, MT_WCID_TX_RATE(i) + 4, 0);\n\t}\n\n\tfor (i = 0; i < MT_MAX_VIFS; i++)\n\t\tmt76x02_mac_wcid_setup(dev, MT_VIF_WCID(i), i, NULL);\n\n\tfor (i = 0; i < 16; i++)\n\t\tfor (k = 0; k < 4; k++)\n\t\t\tmt76x02_mac_shared_key_setup(dev, i, k, NULL);\n\n\tfor (i = 0; i < 16; i++)\n\t\tmt76_rr(dev, MT_TX_STAT_FIFO);\n\n\tmt76x02_set_tx_ackto(dev);\n\n\treturn 0;\n}\n\nstatic void\nmt76x2_power_on_rf_patch(struct mt76x02_dev *dev)\n{\n\tmt76_set(dev, 0x10130, BIT(0) | BIT(16));\n\tudelay(1);\n\n\tmt76_clear(dev, 0x1001c, 0xff);\n\tmt76_set(dev, 0x1001c, 0x30);\n\n\tmt76_wr(dev, 0x10014, 0x484f);\n\tudelay(1);\n\n\tmt76_set(dev, 0x10130, BIT(17));\n\tudelay(125);\n\n\tmt76_clear(dev, 0x10130, BIT(16));\n\tudelay(50);\n\n\tmt76_set(dev, 0x1014c, BIT(19) | BIT(20));\n}\n\nstatic void\nmt76x2_power_on_rf(struct mt76x02_dev *dev, int unit)\n{\n\tint shift = unit ? 8 : 0;\n\n\t \n\tmt76_set(dev, 0x10130, BIT(0) << shift);\n\tudelay(10);\n\n\t \n\tmt76_set(dev, 0x10130, (BIT(1) | BIT(3) | BIT(4) | BIT(5)) << shift);\n\tudelay(10);\n\n\t \n\tmt76_clear(dev, 0x10130, BIT(2) << shift);\n\tudelay(10);\n\n\tmt76x2_power_on_rf_patch(dev);\n\n\tmt76_set(dev, 0x530, 0xf);\n}\n\nstatic void\nmt76x2_power_on(struct mt76x02_dev *dev)\n{\n\tu32 val;\n\n\t \n\tmt76_set(dev, MT_WLAN_MTC_CTRL, MT_WLAN_MTC_CTRL_MTCMOS_PWR_UP);\n\n\tval = MT_WLAN_MTC_CTRL_STATE_UP |\n\t      MT_WLAN_MTC_CTRL_PWR_ACK |\n\t      MT_WLAN_MTC_CTRL_PWR_ACK_S;\n\n\tmt76_poll(dev, MT_WLAN_MTC_CTRL, val, val, 1000);\n\n\tmt76_clear(dev, MT_WLAN_MTC_CTRL, 0x7f << 16);\n\tudelay(10);\n\n\tmt76_clear(dev, MT_WLAN_MTC_CTRL, 0xf << 24);\n\tudelay(10);\n\n\tmt76_set(dev, MT_WLAN_MTC_CTRL, 0xf << 24);\n\tmt76_clear(dev, MT_WLAN_MTC_CTRL, 0xfff);\n\n\t \n\tmt76_clear(dev, 0x11204, BIT(3));\n\n\t \n\tmt76_set(dev, 0x10080, BIT(0));\n\n\t \n\tmt76_clear(dev, 0x10064, BIT(18));\n\n\tmt76x2_power_on_rf(dev, 0);\n\tmt76x2_power_on_rf(dev, 1);\n}\n\nint mt76x2_resume_device(struct mt76x02_dev *dev)\n{\n\tint err;\n\n\tmt76x02_dma_disable(dev);\n\tmt76x2_reset_wlan(dev, true);\n\tmt76x2_power_on(dev);\n\n\terr = mt76x2_mac_reset(dev, true);\n\tif (err)\n\t\treturn err;\n\n\tmt76x02_mac_start(dev);\n\n\treturn mt76x2_mcu_init(dev);\n}\n\nstatic int mt76x2_init_hardware(struct mt76x02_dev *dev)\n{\n\tint ret;\n\n\tmt76x02_dma_disable(dev);\n\tmt76x2_reset_wlan(dev, true);\n\tmt76x2_power_on(dev);\n\n\tret = mt76x2_eeprom_init(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt76x2_mac_reset(dev, true);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->mt76.rxfilter = mt76_rr(dev, MT_RX_FILTR_CFG);\n\n\tret = mt76x02_dma_init(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tset_bit(MT76_STATE_INITIALIZED, &dev->mphy.state);\n\tmt76x02_mac_start(dev);\n\n\tret = mt76x2_mcu_init(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmt76x2_mac_stop(dev, false);\n\n\treturn 0;\n}\n\nvoid mt76x2_stop_hardware(struct mt76x02_dev *dev)\n{\n\tcancel_delayed_work_sync(&dev->cal_work);\n\tcancel_delayed_work_sync(&dev->mphy.mac_work);\n\tcancel_delayed_work_sync(&dev->wdt_work);\n\tclear_bit(MT76_RESTART, &dev->mphy.state);\n\tmt76x02_mcu_set_radio_state(dev, false);\n\tmt76x2_mac_stop(dev, false);\n}\n\nvoid mt76x2_cleanup(struct mt76x02_dev *dev)\n{\n\ttasklet_disable(&dev->dfs_pd.dfs_tasklet);\n\ttasklet_disable(&dev->mt76.pre_tbtt_tasklet);\n\tmt76x2_stop_hardware(dev);\n\tmt76_dma_cleanup(&dev->mt76);\n\tmt76x02_mcu_cleanup(dev);\n}\n\nint mt76x2_register_device(struct mt76x02_dev *dev)\n{\n\tint ret;\n\n\tINIT_DELAYED_WORK(&dev->cal_work, mt76x2_phy_calibrate);\n\tret = mt76x02_init_device(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt76x2_init_hardware(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmt76x02_config_mac_addr_list(dev);\n\n\tret = mt76_register_device(&dev->mt76, true, mt76x02_rates,\n\t\t\t\t   ARRAY_SIZE(mt76x02_rates));\n\tif (ret)\n\t\tgoto fail;\n\n\tmt76x02_init_debugfs(dev);\n\tmt76x2_init_txpower(dev, &dev->mphy.sband_2g.sband);\n\tmt76x2_init_txpower(dev, &dev->mphy.sband_5g.sband);\n\n\treturn 0;\n\nfail:\n\tmt76x2_stop_hardware(dev);\n\treturn ret;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}