{
  "module_name": "usb_init.c",
  "hash_id": "1b85a0e9dbaf3297e0ab81a0c9b9f21e62abe6ba9e8ff54b3fb5c3720a3481e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt76x2/usb_init.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n\n#include \"mt76x2u.h\"\n#include \"eeprom.h\"\n#include \"../mt76x02_phy.h\"\n#include \"../mt76x02_usb.h\"\n\nstatic void mt76x2u_init_dma(struct mt76x02_dev *dev)\n{\n\tu32 val = mt76_rr(dev, MT_VEND_ADDR(CFG, MT_USB_U3DMA_CFG));\n\n\tval |= MT_USB_DMA_CFG_RX_DROP_OR_PAD |\n\t       MT_USB_DMA_CFG_RX_BULK_EN |\n\t       MT_USB_DMA_CFG_TX_BULK_EN;\n\n\t \n\tval &= ~MT_USB_DMA_CFG_RX_BULK_AGG_EN;\n\tmt76_wr(dev, MT_VEND_ADDR(CFG, MT_USB_U3DMA_CFG), val);\n}\n\nstatic void mt76x2u_power_on_rf_patch(struct mt76x02_dev *dev)\n{\n\tmt76_set(dev, MT_VEND_ADDR(CFG, 0x130), BIT(0) | BIT(16));\n\tudelay(1);\n\n\tmt76_clear(dev, MT_VEND_ADDR(CFG, 0x1c), 0xff);\n\tmt76_set(dev, MT_VEND_ADDR(CFG, 0x1c), 0x30);\n\n\tmt76_wr(dev, MT_VEND_ADDR(CFG, 0x14), 0x484f);\n\tudelay(1);\n\n\tmt76_set(dev, MT_VEND_ADDR(CFG, 0x130), BIT(17));\n\tusleep_range(150, 200);\n\n\tmt76_clear(dev, MT_VEND_ADDR(CFG, 0x130), BIT(16));\n\tusleep_range(50, 100);\n\n\tmt76_set(dev, MT_VEND_ADDR(CFG, 0x14c), BIT(19) | BIT(20));\n}\n\nstatic void mt76x2u_power_on_rf(struct mt76x02_dev *dev, int unit)\n{\n\tint shift = unit ? 8 : 0;\n\tu32 val = (BIT(1) | BIT(3) | BIT(4) | BIT(5)) << shift;\n\n\t \n\tmt76_set(dev, MT_VEND_ADDR(CFG, 0x130), BIT(0) << shift);\n\tusleep_range(10, 20);\n\n\t \n\tmt76_set(dev, MT_VEND_ADDR(CFG, 0x130), val);\n\tusleep_range(10, 20);\n\n\t \n\tmt76_clear(dev, MT_VEND_ADDR(CFG, 0x130), BIT(2) << shift);\n\tusleep_range(10, 20);\n\n\tmt76x2u_power_on_rf_patch(dev);\n\n\tmt76_set(dev, 0x530, 0xf);\n}\n\nstatic void mt76x2u_power_on(struct mt76x02_dev *dev)\n{\n\tu32 val;\n\n\t \n\tmt76_set(dev, MT_VEND_ADDR(CFG, 0x148),\n\t\t MT_WLAN_MTC_CTRL_MTCMOS_PWR_UP);\n\n\tval = MT_WLAN_MTC_CTRL_STATE_UP |\n\t      MT_WLAN_MTC_CTRL_PWR_ACK |\n\t      MT_WLAN_MTC_CTRL_PWR_ACK_S;\n\n\tmt76_poll(dev, MT_VEND_ADDR(CFG, 0x148), val, val, 1000);\n\n\tmt76_clear(dev, MT_VEND_ADDR(CFG, 0x148), 0x7f << 16);\n\tusleep_range(10, 20);\n\n\tmt76_clear(dev, MT_VEND_ADDR(CFG, 0x148), 0xf << 24);\n\tusleep_range(10, 20);\n\n\tmt76_set(dev, MT_VEND_ADDR(CFG, 0x148), 0xf << 24);\n\tmt76_clear(dev, MT_VEND_ADDR(CFG, 0x148), 0xfff);\n\n\t \n\tmt76_clear(dev, MT_VEND_ADDR(CFG, 0x1204), BIT(3));\n\n\t \n\tmt76_set(dev, MT_VEND_ADDR(CFG, 0x80), BIT(0));\n\n\t \n\tmt76_clear(dev, MT_VEND_ADDR(CFG, 0x64), BIT(18));\n\n\tmt76x2u_power_on_rf(dev, 0);\n\tmt76x2u_power_on_rf(dev, 1);\n}\n\nstatic int mt76x2u_init_eeprom(struct mt76x02_dev *dev)\n{\n\tu32 val, i;\n\n\tdev->mt76.eeprom.data = devm_kzalloc(dev->mt76.dev,\n\t\t\t\t\t     MT7612U_EEPROM_SIZE,\n\t\t\t\t\t     GFP_KERNEL);\n\tdev->mt76.eeprom.size = MT7612U_EEPROM_SIZE;\n\tif (!dev->mt76.eeprom.data)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i + 4 <= MT7612U_EEPROM_SIZE; i += 4) {\n\t\tval = mt76_rr(dev, MT_VEND_ADDR(EEPROM, i));\n\t\tput_unaligned_le32(val, dev->mt76.eeprom.data + i);\n\t}\n\n\tmt76x02_eeprom_parse_hw_cap(dev);\n\treturn 0;\n}\n\nint mt76x2u_init_hardware(struct mt76x02_dev *dev)\n{\n\tint i, k, err;\n\n\tmt76x2_reset_wlan(dev, true);\n\tmt76x2u_power_on(dev);\n\n\tif (!mt76x02_wait_for_mac(&dev->mt76))\n\t\treturn -ETIMEDOUT;\n\n\terr = mt76x2u_mcu_fw_init(dev);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!mt76_poll_msec(dev, MT_WPDMA_GLO_CFG,\n\t\t\t    MT_WPDMA_GLO_CFG_TX_DMA_BUSY |\n\t\t\t    MT_WPDMA_GLO_CFG_RX_DMA_BUSY, 0, 100))\n\t\treturn -EIO;\n\n\t \n\tif (!mt76x02_wait_for_mac(&dev->mt76))\n\t\treturn -ETIMEDOUT;\n\n\tmt76x2u_init_dma(dev);\n\n\terr = mt76x2u_mcu_init(dev);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = mt76x2u_mac_reset(dev);\n\tif (err < 0)\n\t\treturn err;\n\n\tmt76x02_mac_setaddr(dev, dev->mt76.eeprom.data + MT_EE_MAC_ADDR);\n\tdev->mt76.rxfilter = mt76_rr(dev, MT_RX_FILTR_CFG);\n\n\tif (!mt76x02_wait_for_txrx_idle(&dev->mt76))\n\t\treturn -ETIMEDOUT;\n\n\t \n\tfor (i = 0; i < 256; i++)\n\t\tmt76x02_mac_wcid_setup(dev, i, 0, NULL);\n\n\t \n\tfor (i = 0; i < 16; i++) {\n\t\tfor (k = 0; k < 4; k++)\n\t\t\tmt76x02_mac_shared_key_setup(dev, i, k, NULL);\n\t}\n\n\tmt76x02u_init_beacon_config(dev);\n\n\tmt76_rmw(dev, MT_US_CYC_CFG, MT_US_CYC_CNT, 0x1e);\n\tmt76_wr(dev, MT_TXOP_CTRL_CFG, 0x583f);\n\n\terr = mt76x2_mcu_load_cr(dev, MT_RF_BBP_CR, 0, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tmt76x02_phy_set_rxpath(dev);\n\tmt76x02_phy_set_txdac(dev);\n\n\treturn mt76x2u_mac_stop(dev);\n}\n\nint mt76x2u_register_device(struct mt76x02_dev *dev)\n{\n\tstruct ieee80211_hw *hw = mt76_hw(dev);\n\tstruct mt76_usb *usb = &dev->mt76.usb;\n\tint err;\n\n\tINIT_DELAYED_WORK(&dev->cal_work, mt76x2u_phy_calibrate);\n\terr = mt76x02_init_device(dev);\n\tif (err)\n\t\treturn err;\n\n\terr = mt76x2u_init_eeprom(dev);\n\tif (err < 0)\n\t\treturn err;\n\n\tusb->mcu.data = devm_kmalloc(dev->mt76.dev, MCU_RESP_URB_SIZE,\n\t\t\t\t     GFP_KERNEL);\n\tif (!usb->mcu.data)\n\t\treturn -ENOMEM;\n\n\terr = mt76u_alloc_queues(&dev->mt76);\n\tif (err < 0)\n\t\tgoto fail;\n\n\terr = mt76x2u_init_hardware(dev);\n\tif (err < 0)\n\t\tgoto fail;\n\n\t \n\thw->max_tx_fragments = dev->mt76.usb.sg_en ? MT_TX_SG_MAX_SIZE : 1;\n\terr = mt76_register_device(&dev->mt76, true, mt76x02_rates,\n\t\t\t\t   ARRAY_SIZE(mt76x02_rates));\n\tif (err)\n\t\tgoto fail;\n\n\tset_bit(MT76_STATE_INITIALIZED, &dev->mphy.state);\n\n\tmt76x02_init_debugfs(dev);\n\tmt76x2_init_txpower(dev, &dev->mphy.sband_2g.sband);\n\tmt76x2_init_txpower(dev, &dev->mphy.sband_5g.sband);\n\n\treturn 0;\n\nfail:\n\tmt76x2u_cleanup(dev);\n\treturn err;\n}\n\nvoid mt76x2u_stop_hw(struct mt76x02_dev *dev)\n{\n\tcancel_delayed_work_sync(&dev->cal_work);\n\tcancel_delayed_work_sync(&dev->mphy.mac_work);\n\tmt76x2u_mac_stop(dev);\n}\n\nvoid mt76x2u_cleanup(struct mt76x02_dev *dev)\n{\n\tmt76x02_mcu_set_radio_state(dev, false);\n\tmt76x2u_stop_hw(dev);\n\tmt76u_queues_deinit(&dev->mt76);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}