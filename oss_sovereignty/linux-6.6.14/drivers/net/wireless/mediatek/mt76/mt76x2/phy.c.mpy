{
  "module_name": "phy.c",
  "hash_id": "48efca6b98b3d2799056c71318d7a23684f0d8844872de1066fedfcd997c2ad1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt76x2/phy.c",
  "human_readable_source": "\n \n\n#include \"mt76x2.h\"\n#include \"eeprom.h\"\n#include \"mcu.h\"\n#include \"../mt76x02_phy.h\"\n\nstatic void\nmt76x2_adjust_high_lna_gain(struct mt76x02_dev *dev, int reg, s8 offset)\n{\n\ts8 gain;\n\n\tgain = FIELD_GET(MT_BBP_AGC_LNA_HIGH_GAIN,\n\t\t\t mt76_rr(dev, MT_BBP(AGC, reg)));\n\tgain -= offset / 2;\n\tmt76_rmw_field(dev, MT_BBP(AGC, reg), MT_BBP_AGC_LNA_HIGH_GAIN, gain);\n}\n\nstatic void\nmt76x2_adjust_agc_gain(struct mt76x02_dev *dev, int reg, s8 offset)\n{\n\ts8 gain;\n\n\tgain = FIELD_GET(MT_BBP_AGC_GAIN, mt76_rr(dev, MT_BBP(AGC, reg)));\n\tgain += offset;\n\tmt76_rmw_field(dev, MT_BBP(AGC, reg), MT_BBP_AGC_GAIN, gain);\n}\n\nvoid mt76x2_apply_gain_adj(struct mt76x02_dev *dev)\n{\n\ts8 *gain_adj = dev->cal.rx.high_gain;\n\n\tmt76x2_adjust_high_lna_gain(dev, 4, gain_adj[0]);\n\tmt76x2_adjust_high_lna_gain(dev, 5, gain_adj[1]);\n\n\tmt76x2_adjust_agc_gain(dev, 8, gain_adj[0]);\n\tmt76x2_adjust_agc_gain(dev, 9, gain_adj[1]);\n}\nEXPORT_SYMBOL_GPL(mt76x2_apply_gain_adj);\n\nvoid mt76x2_phy_set_txpower_regs(struct mt76x02_dev *dev,\n\t\t\t\t enum nl80211_band band)\n{\n\tu32 pa_mode[2];\n\tu32 pa_mode_adj;\n\n\tif (band == NL80211_BAND_2GHZ) {\n\t\tpa_mode[0] = 0x010055ff;\n\t\tpa_mode[1] = 0x00550055;\n\n\t\tmt76_wr(dev, MT_TX_ALC_CFG_2, 0x35160a00);\n\t\tmt76_wr(dev, MT_TX_ALC_CFG_3, 0x35160a06);\n\n\t\tif (mt76x02_ext_pa_enabled(dev, band)) {\n\t\t\tmt76_wr(dev, MT_RF_PA_MODE_ADJ0, 0x0000ec00);\n\t\t\tmt76_wr(dev, MT_RF_PA_MODE_ADJ1, 0x0000ec00);\n\t\t} else {\n\t\t\tmt76_wr(dev, MT_RF_PA_MODE_ADJ0, 0xf4000200);\n\t\t\tmt76_wr(dev, MT_RF_PA_MODE_ADJ1, 0xfa000200);\n\t\t}\n\t} else {\n\t\tpa_mode[0] = 0x0000ffff;\n\t\tpa_mode[1] = 0x00ff00ff;\n\n\t\tif (mt76x02_ext_pa_enabled(dev, band)) {\n\t\t\tmt76_wr(dev, MT_TX_ALC_CFG_2, 0x2f0f0400);\n\t\t\tmt76_wr(dev, MT_TX_ALC_CFG_3, 0x2f0f0476);\n\t\t} else {\n\t\t\tmt76_wr(dev, MT_TX_ALC_CFG_2, 0x1b0f0400);\n\t\t\tmt76_wr(dev, MT_TX_ALC_CFG_3, 0x1b0f0476);\n\t\t}\n\n\t\tif (mt76x02_ext_pa_enabled(dev, band))\n\t\t\tpa_mode_adj = 0x04000000;\n\t\telse\n\t\t\tpa_mode_adj = 0;\n\n\t\tmt76_wr(dev, MT_RF_PA_MODE_ADJ0, pa_mode_adj);\n\t\tmt76_wr(dev, MT_RF_PA_MODE_ADJ1, pa_mode_adj);\n\t}\n\n\tmt76_wr(dev, MT_BB_PA_MODE_CFG0, pa_mode[0]);\n\tmt76_wr(dev, MT_BB_PA_MODE_CFG1, pa_mode[1]);\n\tmt76_wr(dev, MT_RF_PA_MODE_CFG0, pa_mode[0]);\n\tmt76_wr(dev, MT_RF_PA_MODE_CFG1, pa_mode[1]);\n\n\tif (mt76x02_ext_pa_enabled(dev, band)) {\n\t\tu32 val;\n\n\t\tif (band == NL80211_BAND_2GHZ)\n\t\t\tval = 0x3c3c023c;\n\t\telse\n\t\t\tval = 0x363c023c;\n\n\t\tmt76_wr(dev, MT_TX0_RF_GAIN_CORR, val);\n\t\tmt76_wr(dev, MT_TX1_RF_GAIN_CORR, val);\n\t\tmt76_wr(dev, MT_TX_ALC_CFG_4, 0x00001818);\n\t} else {\n\t\tif (band == NL80211_BAND_2GHZ) {\n\t\t\tu32 val = 0x0f3c3c3c;\n\n\t\t\tmt76_wr(dev, MT_TX0_RF_GAIN_CORR, val);\n\t\t\tmt76_wr(dev, MT_TX1_RF_GAIN_CORR, val);\n\t\t\tmt76_wr(dev, MT_TX_ALC_CFG_4, 0x00000606);\n\t\t} else {\n\t\t\tmt76_wr(dev, MT_TX0_RF_GAIN_CORR, 0x383c023c);\n\t\t\tmt76_wr(dev, MT_TX1_RF_GAIN_CORR, 0x24282e28);\n\t\t\tmt76_wr(dev, MT_TX_ALC_CFG_4, 0);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(mt76x2_phy_set_txpower_regs);\n\nstatic int\nmt76x2_get_min_rate_power(struct mt76x02_rate_power *r)\n{\n\tint i;\n\ts8 ret = 0;\n\n\tfor (i = 0; i < sizeof(r->all); i++) {\n\t\tif (!r->all[i])\n\t\t\tcontinue;\n\n\t\tif (ret)\n\t\t\tret = min(ret, r->all[i]);\n\t\telse\n\t\t\tret = r->all[i];\n\t}\n\n\treturn ret;\n}\n\nvoid mt76x2_phy_set_txpower(struct mt76x02_dev *dev)\n{\n\tenum nl80211_chan_width width = dev->mphy.chandef.width;\n\tstruct ieee80211_channel *chan = dev->mphy.chandef.chan;\n\tstruct mt76x2_tx_power_info txp;\n\tint txp_0, txp_1, delta = 0;\n\tstruct mt76x02_rate_power t = {};\n\tint base_power, gain;\n\n\tmt76x2_get_power_info(dev, &txp, chan);\n\n\tif (width == NL80211_CHAN_WIDTH_40)\n\t\tdelta = txp.delta_bw40;\n\telse if (width == NL80211_CHAN_WIDTH_80)\n\t\tdelta = txp.delta_bw80;\n\n\tmt76x2_get_rate_power(dev, &t, chan);\n\tmt76x02_add_rate_power_offset(&t, txp.target_power + delta);\n\tmt76x02_limit_rate_power(&t, dev->txpower_conf);\n\tdev->mphy.txpower_cur = mt76x02_get_max_rate_power(&t);\n\n\tbase_power = mt76x2_get_min_rate_power(&t);\n\tdelta = base_power - txp.target_power;\n\ttxp_0 = txp.chain[0].target_power + txp.chain[0].delta + delta;\n\ttxp_1 = txp.chain[1].target_power + txp.chain[1].delta + delta;\n\n\tgain = min(txp_0, txp_1);\n\tif (gain < 0) {\n\t\tbase_power -= gain;\n\t\ttxp_0 -= gain;\n\t\ttxp_1 -= gain;\n\t} else if (gain > 0x2f) {\n\t\tbase_power -= gain - 0x2f;\n\t\ttxp_0 = 0x2f;\n\t\ttxp_1 = 0x2f;\n\t}\n\n\tmt76x02_add_rate_power_offset(&t, -base_power);\n\tdev->target_power = txp.target_power;\n\tdev->target_power_delta[0] = txp_0 - txp.chain[0].target_power;\n\tdev->target_power_delta[1] = txp_1 - txp.chain[0].target_power;\n\tdev->rate_power = t;\n\n\tmt76x02_phy_set_txpower(dev, txp_0, txp_1);\n}\nEXPORT_SYMBOL_GPL(mt76x2_phy_set_txpower);\n\nvoid mt76x2_configure_tx_delay(struct mt76x02_dev *dev,\n\t\t\t       enum nl80211_band band, u8 bw)\n{\n\tu32 cfg0, cfg1;\n\n\tif (mt76x02_ext_pa_enabled(dev, band)) {\n\t\tcfg0 = bw ? 0x000b0c01 : 0x00101101;\n\t\tcfg1 = 0x00011414;\n\t} else {\n\t\tcfg0 = bw ? 0x000b0b01 : 0x00101001;\n\t\tcfg1 = 0x00021414;\n\t}\n\tmt76_wr(dev, MT_TX_SW_CFG0, cfg0);\n\tmt76_wr(dev, MT_TX_SW_CFG1, cfg1);\n\n\tmt76_rmw_field(dev, MT_XIFS_TIME_CFG, MT_XIFS_TIME_CFG_OFDM_SIFS, 15);\n}\nEXPORT_SYMBOL_GPL(mt76x2_configure_tx_delay);\n\nvoid mt76x2_phy_tssi_compensate(struct mt76x02_dev *dev)\n{\n\tstruct ieee80211_channel *chan = dev->mphy.chandef.chan;\n\tstruct mt76x2_tx_power_info txp;\n\tstruct mt76x2_tssi_comp t = {};\n\n\tif (!dev->cal.tssi_cal_done)\n\t\treturn;\n\n\tif (!dev->cal.tssi_comp_pending) {\n\t\t \n\t\tt.cal_mode = BIT(0);\n\t\tmt76x2_mcu_tssi_comp(dev, &t);\n\t\tdev->cal.tssi_comp_pending = true;\n\t} else {\n\t\tif (mt76_rr(dev, MT_BBP(CORE, 34)) & BIT(4))\n\t\t\treturn;\n\n\t\tdev->cal.tssi_comp_pending = false;\n\t\tmt76x2_get_power_info(dev, &txp, chan);\n\n\t\tif (mt76x02_ext_pa_enabled(dev, chan->band))\n\t\t\tt.pa_mode = 1;\n\n\t\tt.cal_mode = BIT(1);\n\t\tt.slope0 = txp.chain[0].tssi_slope;\n\t\tt.offset0 = txp.chain[0].tssi_offset;\n\t\tt.slope1 = txp.chain[1].tssi_slope;\n\t\tt.offset1 = txp.chain[1].tssi_offset;\n\t\tmt76x2_mcu_tssi_comp(dev, &t);\n\n\t\tif (t.pa_mode || dev->cal.dpd_cal_done || dev->ed_tx_blocked)\n\t\t\treturn;\n\n\t\tusleep_range(10000, 20000);\n\t\tmt76x02_mcu_calibrate(dev, MCU_CAL_DPD, chan->hw_value);\n\t\tdev->cal.dpd_cal_done = true;\n\t}\n}\nEXPORT_SYMBOL_GPL(mt76x2_phy_tssi_compensate);\n\nstatic void\nmt76x2_phy_set_gain_val(struct mt76x02_dev *dev)\n{\n\tu32 val;\n\tu8 gain_val[2];\n\n\tgain_val[0] = dev->cal.agc_gain_cur[0] - dev->cal.agc_gain_adjust;\n\tgain_val[1] = dev->cal.agc_gain_cur[1] - dev->cal.agc_gain_adjust;\n\n\tval = 0x1836 << 16;\n\tif (!mt76x2_has_ext_lna(dev) &&\n\t    dev->mphy.chandef.width >= NL80211_CHAN_WIDTH_40)\n\t\tval = 0x1e42 << 16;\n\n\tif (mt76x2_has_ext_lna(dev) &&\n\t    dev->mphy.chandef.chan->band == NL80211_BAND_2GHZ &&\n\t    dev->mphy.chandef.width < NL80211_CHAN_WIDTH_40)\n\t\tval = 0x0f36 << 16;\n\n\tval |= 0xf8;\n\n\tmt76_wr(dev, MT_BBP(AGC, 8),\n\t\tval | FIELD_PREP(MT_BBP_AGC_GAIN, gain_val[0]));\n\tmt76_wr(dev, MT_BBP(AGC, 9),\n\t\tval | FIELD_PREP(MT_BBP_AGC_GAIN, gain_val[1]));\n\n\tif (dev->mphy.chandef.chan->flags & IEEE80211_CHAN_RADAR)\n\t\tmt76x02_phy_dfs_adjust_agc(dev);\n}\n\nvoid mt76x2_phy_update_channel_gain(struct mt76x02_dev *dev)\n{\n\tu8 *gain = dev->cal.agc_gain_init;\n\tu8 low_gain_delta, gain_delta;\n\tu32 agc_35, agc_37;\n\tbool gain_change;\n\tint low_gain;\n\tu32 val;\n\n\tdev->cal.avg_rssi_all = mt76_get_min_avg_rssi(&dev->mt76, false);\n\tif (!dev->cal.avg_rssi_all)\n\t\tdev->cal.avg_rssi_all = -75;\n\n\tlow_gain = (dev->cal.avg_rssi_all > mt76x02_get_rssi_gain_thresh(dev)) +\n\t\t(dev->cal.avg_rssi_all > mt76x02_get_low_rssi_gain_thresh(dev));\n\n\tgain_change = dev->cal.low_gain < 0 ||\n\t\t      (dev->cal.low_gain & 2) ^ (low_gain & 2);\n\tdev->cal.low_gain = low_gain;\n\n\tif (!gain_change) {\n\t\tif (mt76x02_phy_adjust_vga_gain(dev))\n\t\t\tmt76x2_phy_set_gain_val(dev);\n\t\treturn;\n\t}\n\n\tif (dev->mphy.chandef.width == NL80211_CHAN_WIDTH_80) {\n\t\tmt76_wr(dev, MT_BBP(RXO, 14), 0x00560211);\n\t\tval = mt76_rr(dev, MT_BBP(AGC, 26)) & ~0xf;\n\t\tif (low_gain == 2)\n\t\t\tval |= 0x3;\n\t\telse\n\t\t\tval |= 0x5;\n\t\tmt76_wr(dev, MT_BBP(AGC, 26), val);\n\t} else {\n\t\tmt76_wr(dev, MT_BBP(RXO, 14), 0x00560423);\n\t}\n\n\tif (mt76x2_has_ext_lna(dev))\n\t\tlow_gain_delta = 10;\n\telse\n\t\tlow_gain_delta = 14;\n\n\tagc_37 = 0x2121262c;\n\tif (dev->mphy.chandef.chan->band == NL80211_BAND_2GHZ)\n\t\tagc_35 = 0x11111516;\n\telse if (low_gain == 2)\n\t\tagc_35 = agc_37 = 0x08080808;\n\telse if (dev->mphy.chandef.width == NL80211_CHAN_WIDTH_80)\n\t\tagc_35 = 0x10101014;\n\telse\n\t\tagc_35 = 0x11111116;\n\n\tif (low_gain == 2) {\n\t\tmt76_wr(dev, MT_BBP(RXO, 18), 0xf000a990);\n\t\tmt76_wr(dev, MT_BBP(AGC, 35), 0x08080808);\n\t\tmt76_wr(dev, MT_BBP(AGC, 37), 0x08080808);\n\t\tgain_delta = low_gain_delta;\n\t\tdev->cal.agc_gain_adjust = 0;\n\t} else {\n\t\tmt76_wr(dev, MT_BBP(RXO, 18), 0xf000a991);\n\t\tgain_delta = 0;\n\t\tdev->cal.agc_gain_adjust = low_gain_delta;\n\t}\n\n\tmt76_wr(dev, MT_BBP(AGC, 35), agc_35);\n\tmt76_wr(dev, MT_BBP(AGC, 37), agc_37);\n\n\tdev->cal.agc_gain_cur[0] = gain[0] - gain_delta;\n\tdev->cal.agc_gain_cur[1] = gain[1] - gain_delta;\n\tmt76x2_phy_set_gain_val(dev);\n\n\t \n\tmt76_rr(dev, MT_RX_STAT_1);\n}\nEXPORT_SYMBOL_GPL(mt76x2_phy_update_channel_gain);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}