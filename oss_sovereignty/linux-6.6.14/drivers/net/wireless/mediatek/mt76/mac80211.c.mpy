{
  "module_name": "mac80211.c",
  "hash_id": "7250c23c0bf8427d8abeda6e1108f058aba1e4891f7316f4cbabbc6c7b85c98e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mac80211.c",
  "human_readable_source": "\n \n#include <linux/sched.h>\n#include <linux/of.h>\n#include \"mt76.h\"\n\n#define CHAN2G(_idx, _freq) {\t\t\t\\\n\t.band = NL80211_BAND_2GHZ,\t\t\\\n\t.center_freq = (_freq),\t\t\t\\\n\t.hw_value = (_idx),\t\t\t\\\n\t.max_power = 30,\t\t\t\\\n}\n\n#define CHAN5G(_idx, _freq) {\t\t\t\\\n\t.band = NL80211_BAND_5GHZ,\t\t\\\n\t.center_freq = (_freq),\t\t\t\\\n\t.hw_value = (_idx),\t\t\t\\\n\t.max_power = 30,\t\t\t\\\n}\n\n#define CHAN6G(_idx, _freq) {\t\t\t\\\n\t.band = NL80211_BAND_6GHZ,\t\t\\\n\t.center_freq = (_freq),\t\t\t\\\n\t.hw_value = (_idx),\t\t\t\\\n\t.max_power = 30,\t\t\t\\\n}\n\nstatic const struct ieee80211_channel mt76_channels_2ghz[] = {\n\tCHAN2G(1, 2412),\n\tCHAN2G(2, 2417),\n\tCHAN2G(3, 2422),\n\tCHAN2G(4, 2427),\n\tCHAN2G(5, 2432),\n\tCHAN2G(6, 2437),\n\tCHAN2G(7, 2442),\n\tCHAN2G(8, 2447),\n\tCHAN2G(9, 2452),\n\tCHAN2G(10, 2457),\n\tCHAN2G(11, 2462),\n\tCHAN2G(12, 2467),\n\tCHAN2G(13, 2472),\n\tCHAN2G(14, 2484),\n};\n\nstatic const struct ieee80211_channel mt76_channels_5ghz[] = {\n\tCHAN5G(36, 5180),\n\tCHAN5G(40, 5200),\n\tCHAN5G(44, 5220),\n\tCHAN5G(48, 5240),\n\n\tCHAN5G(52, 5260),\n\tCHAN5G(56, 5280),\n\tCHAN5G(60, 5300),\n\tCHAN5G(64, 5320),\n\n\tCHAN5G(100, 5500),\n\tCHAN5G(104, 5520),\n\tCHAN5G(108, 5540),\n\tCHAN5G(112, 5560),\n\tCHAN5G(116, 5580),\n\tCHAN5G(120, 5600),\n\tCHAN5G(124, 5620),\n\tCHAN5G(128, 5640),\n\tCHAN5G(132, 5660),\n\tCHAN5G(136, 5680),\n\tCHAN5G(140, 5700),\n\tCHAN5G(144, 5720),\n\n\tCHAN5G(149, 5745),\n\tCHAN5G(153, 5765),\n\tCHAN5G(157, 5785),\n\tCHAN5G(161, 5805),\n\tCHAN5G(165, 5825),\n\tCHAN5G(169, 5845),\n\tCHAN5G(173, 5865),\n\tCHAN5G(177, 5885),\n};\n\nstatic const struct ieee80211_channel mt76_channels_6ghz[] = {\n\t \n\tCHAN6G(1, 5955),\n\tCHAN6G(5, 5975),\n\tCHAN6G(9, 5995),\n\tCHAN6G(13, 6015),\n\tCHAN6G(17, 6035),\n\tCHAN6G(21, 6055),\n\tCHAN6G(25, 6075),\n\tCHAN6G(29, 6095),\n\tCHAN6G(33, 6115),\n\tCHAN6G(37, 6135),\n\tCHAN6G(41, 6155),\n\tCHAN6G(45, 6175),\n\tCHAN6G(49, 6195),\n\tCHAN6G(53, 6215),\n\tCHAN6G(57, 6235),\n\tCHAN6G(61, 6255),\n\tCHAN6G(65, 6275),\n\tCHAN6G(69, 6295),\n\tCHAN6G(73, 6315),\n\tCHAN6G(77, 6335),\n\tCHAN6G(81, 6355),\n\tCHAN6G(85, 6375),\n\tCHAN6G(89, 6395),\n\tCHAN6G(93, 6415),\n\t \n\tCHAN6G(97, 6435),\n\tCHAN6G(101, 6455),\n\tCHAN6G(105, 6475),\n\tCHAN6G(109, 6495),\n\tCHAN6G(113, 6515),\n\tCHAN6G(117, 6535),\n\t \n\tCHAN6G(121, 6555),\n\tCHAN6G(125, 6575),\n\tCHAN6G(129, 6595),\n\tCHAN6G(133, 6615),\n\tCHAN6G(137, 6635),\n\tCHAN6G(141, 6655),\n\tCHAN6G(145, 6675),\n\tCHAN6G(149, 6695),\n\tCHAN6G(153, 6715),\n\tCHAN6G(157, 6735),\n\tCHAN6G(161, 6755),\n\tCHAN6G(165, 6775),\n\tCHAN6G(169, 6795),\n\tCHAN6G(173, 6815),\n\tCHAN6G(177, 6835),\n\tCHAN6G(181, 6855),\n\tCHAN6G(185, 6875),\n\t \n\tCHAN6G(189, 6895),\n\tCHAN6G(193, 6915),\n\tCHAN6G(197, 6935),\n\tCHAN6G(201, 6955),\n\tCHAN6G(205, 6975),\n\tCHAN6G(209, 6995),\n\tCHAN6G(213, 7015),\n\tCHAN6G(217, 7035),\n\tCHAN6G(221, 7055),\n\tCHAN6G(225, 7075),\n\tCHAN6G(229, 7095),\n\tCHAN6G(233, 7115),\n};\n\nstatic const struct ieee80211_tpt_blink mt76_tpt_blink[] = {\n\t{ .throughput =   0 * 1024, .blink_time = 334 },\n\t{ .throughput =   1 * 1024, .blink_time = 260 },\n\t{ .throughput =   5 * 1024, .blink_time = 220 },\n\t{ .throughput =  10 * 1024, .blink_time = 190 },\n\t{ .throughput =  20 * 1024, .blink_time = 170 },\n\t{ .throughput =  50 * 1024, .blink_time = 150 },\n\t{ .throughput =  70 * 1024, .blink_time = 130 },\n\t{ .throughput = 100 * 1024, .blink_time = 110 },\n\t{ .throughput = 200 * 1024, .blink_time =  80 },\n\t{ .throughput = 300 * 1024, .blink_time =  50 },\n};\n\nstruct ieee80211_rate mt76_rates[] = {\n\tCCK_RATE(0, 10),\n\tCCK_RATE(1, 20),\n\tCCK_RATE(2, 55),\n\tCCK_RATE(3, 110),\n\tOFDM_RATE(11, 60),\n\tOFDM_RATE(15, 90),\n\tOFDM_RATE(10, 120),\n\tOFDM_RATE(14, 180),\n\tOFDM_RATE(9,  240),\n\tOFDM_RATE(13, 360),\n\tOFDM_RATE(8,  480),\n\tOFDM_RATE(12, 540),\n};\nEXPORT_SYMBOL_GPL(mt76_rates);\n\nstatic const struct cfg80211_sar_freq_ranges mt76_sar_freq_ranges[] = {\n\t{ .start_freq = 2402, .end_freq = 2494, },\n\t{ .start_freq = 5150, .end_freq = 5350, },\n\t{ .start_freq = 5350, .end_freq = 5470, },\n\t{ .start_freq = 5470, .end_freq = 5725, },\n\t{ .start_freq = 5725, .end_freq = 5950, },\n\t{ .start_freq = 5945, .end_freq = 6165, },\n\t{ .start_freq = 6165, .end_freq = 6405, },\n\t{ .start_freq = 6405, .end_freq = 6525, },\n\t{ .start_freq = 6525, .end_freq = 6705, },\n\t{ .start_freq = 6705, .end_freq = 6865, },\n\t{ .start_freq = 6865, .end_freq = 7125, },\n};\n\nstatic const struct cfg80211_sar_capa mt76_sar_capa = {\n\t.type = NL80211_SAR_TYPE_POWER,\n\t.num_freq_ranges = ARRAY_SIZE(mt76_sar_freq_ranges),\n\t.freq_ranges = &mt76_sar_freq_ranges[0],\n};\n\nstatic int mt76_led_init(struct mt76_phy *phy)\n{\n\tstruct mt76_dev *dev = phy->dev;\n\tstruct ieee80211_hw *hw = phy->hw;\n\n\tif (!phy->leds.cdev.brightness_set && !phy->leds.cdev.blink_set)\n\t\treturn 0;\n\n\tsnprintf(phy->leds.name, sizeof(phy->leds.name), \"mt76-%s\",\n\t\t wiphy_name(hw->wiphy));\n\n\tphy->leds.cdev.name = phy->leds.name;\n\tphy->leds.cdev.default_trigger =\n\t\tieee80211_create_tpt_led_trigger(hw,\n\t\t\t\t\tIEEE80211_TPT_LEDTRIG_FL_RADIO,\n\t\t\t\t\tmt76_tpt_blink,\n\t\t\t\t\tARRAY_SIZE(mt76_tpt_blink));\n\n\tif (phy == &dev->phy) {\n\t\tstruct device_node *np = dev->dev->of_node;\n\n\t\tnp = of_get_child_by_name(np, \"led\");\n\t\tif (np) {\n\t\t\tint led_pin;\n\n\t\t\tif (!of_property_read_u32(np, \"led-sources\", &led_pin))\n\t\t\t\tphy->leds.pin = led_pin;\n\t\t\tphy->leds.al = of_property_read_bool(np,\n\t\t\t\t\t\t\t     \"led-active-low\");\n\t\t\tof_node_put(np);\n\t\t}\n\t}\n\n\treturn led_classdev_register(dev->dev, &phy->leds.cdev);\n}\n\nstatic void mt76_led_cleanup(struct mt76_phy *phy)\n{\n\tif (!phy->leds.cdev.brightness_set && !phy->leds.cdev.blink_set)\n\t\treturn;\n\n\tled_classdev_unregister(&phy->leds.cdev);\n}\n\nstatic void mt76_init_stream_cap(struct mt76_phy *phy,\n\t\t\t\t struct ieee80211_supported_band *sband,\n\t\t\t\t bool vht)\n{\n\tstruct ieee80211_sta_ht_cap *ht_cap = &sband->ht_cap;\n\tint i, nstream = hweight8(phy->antenna_mask);\n\tstruct ieee80211_sta_vht_cap *vht_cap;\n\tu16 mcs_map = 0;\n\n\tif (nstream > 1)\n\t\tht_cap->cap |= IEEE80211_HT_CAP_TX_STBC;\n\telse\n\t\tht_cap->cap &= ~IEEE80211_HT_CAP_TX_STBC;\n\n\tfor (i = 0; i < IEEE80211_HT_MCS_MASK_LEN; i++)\n\t\tht_cap->mcs.rx_mask[i] = i < nstream ? 0xff : 0;\n\n\tif (!vht)\n\t\treturn;\n\n\tvht_cap = &sband->vht_cap;\n\tif (nstream > 1)\n\t\tvht_cap->cap |= IEEE80211_VHT_CAP_TXSTBC;\n\telse\n\t\tvht_cap->cap &= ~IEEE80211_VHT_CAP_TXSTBC;\n\tvht_cap->cap |= IEEE80211_VHT_CAP_TX_ANTENNA_PATTERN |\n\t\t\tIEEE80211_VHT_CAP_RX_ANTENNA_PATTERN;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (i < nstream)\n\t\t\tmcs_map |= (IEEE80211_VHT_MCS_SUPPORT_0_9 << (i * 2));\n\t\telse\n\t\t\tmcs_map |=\n\t\t\t\t(IEEE80211_VHT_MCS_NOT_SUPPORTED << (i * 2));\n\t}\n\tvht_cap->vht_mcs.rx_mcs_map = cpu_to_le16(mcs_map);\n\tvht_cap->vht_mcs.tx_mcs_map = cpu_to_le16(mcs_map);\n\tif (ieee80211_hw_check(phy->hw, SUPPORTS_VHT_EXT_NSS_BW))\n\t\tvht_cap->vht_mcs.tx_highest |=\n\t\t\t\tcpu_to_le16(IEEE80211_VHT_EXT_NSS_BW_CAPABLE);\n}\n\nvoid mt76_set_stream_caps(struct mt76_phy *phy, bool vht)\n{\n\tif (phy->cap.has_2ghz)\n\t\tmt76_init_stream_cap(phy, &phy->sband_2g.sband, false);\n\tif (phy->cap.has_5ghz)\n\t\tmt76_init_stream_cap(phy, &phy->sband_5g.sband, vht);\n\tif (phy->cap.has_6ghz)\n\t\tmt76_init_stream_cap(phy, &phy->sband_6g.sband, vht);\n}\nEXPORT_SYMBOL_GPL(mt76_set_stream_caps);\n\nstatic int\nmt76_init_sband(struct mt76_phy *phy, struct mt76_sband *msband,\n\t\tconst struct ieee80211_channel *chan, int n_chan,\n\t\tstruct ieee80211_rate *rates, int n_rates,\n\t\tbool ht, bool vht)\n{\n\tstruct ieee80211_supported_band *sband = &msband->sband;\n\tstruct ieee80211_sta_vht_cap *vht_cap;\n\tstruct ieee80211_sta_ht_cap *ht_cap;\n\tstruct mt76_dev *dev = phy->dev;\n\tvoid *chanlist;\n\tint size;\n\n\tsize = n_chan * sizeof(*chan);\n\tchanlist = devm_kmemdup(dev->dev, chan, size, GFP_KERNEL);\n\tif (!chanlist)\n\t\treturn -ENOMEM;\n\n\tmsband->chan = devm_kcalloc(dev->dev, n_chan, sizeof(*msband->chan),\n\t\t\t\t    GFP_KERNEL);\n\tif (!msband->chan)\n\t\treturn -ENOMEM;\n\n\tsband->channels = chanlist;\n\tsband->n_channels = n_chan;\n\tsband->bitrates = rates;\n\tsband->n_bitrates = n_rates;\n\n\tif (!ht)\n\t\treturn 0;\n\n\tht_cap = &sband->ht_cap;\n\tht_cap->ht_supported = true;\n\tht_cap->cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40 |\n\t\t       IEEE80211_HT_CAP_GRN_FLD |\n\t\t       IEEE80211_HT_CAP_SGI_20 |\n\t\t       IEEE80211_HT_CAP_SGI_40 |\n\t\t       (1 << IEEE80211_HT_CAP_RX_STBC_SHIFT);\n\n\tht_cap->mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\n\tht_cap->ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;\n\n\tmt76_init_stream_cap(phy, sband, vht);\n\n\tif (!vht)\n\t\treturn 0;\n\n\tvht_cap = &sband->vht_cap;\n\tvht_cap->vht_supported = true;\n\tvht_cap->cap |= IEEE80211_VHT_CAP_RXLDPC |\n\t\t\tIEEE80211_VHT_CAP_RXSTBC_1 |\n\t\t\tIEEE80211_VHT_CAP_SHORT_GI_80 |\n\t\t\t(3 << IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT);\n\n\treturn 0;\n}\n\nstatic int\nmt76_init_sband_2g(struct mt76_phy *phy, struct ieee80211_rate *rates,\n\t\t   int n_rates)\n{\n\tphy->hw->wiphy->bands[NL80211_BAND_2GHZ] = &phy->sband_2g.sband;\n\n\treturn mt76_init_sband(phy, &phy->sband_2g, mt76_channels_2ghz,\n\t\t\t       ARRAY_SIZE(mt76_channels_2ghz), rates,\n\t\t\t       n_rates, true, false);\n}\n\nstatic int\nmt76_init_sband_5g(struct mt76_phy *phy, struct ieee80211_rate *rates,\n\t\t   int n_rates, bool vht)\n{\n\tphy->hw->wiphy->bands[NL80211_BAND_5GHZ] = &phy->sband_5g.sband;\n\n\treturn mt76_init_sband(phy, &phy->sband_5g, mt76_channels_5ghz,\n\t\t\t       ARRAY_SIZE(mt76_channels_5ghz), rates,\n\t\t\t       n_rates, true, vht);\n}\n\nstatic int\nmt76_init_sband_6g(struct mt76_phy *phy, struct ieee80211_rate *rates,\n\t\t   int n_rates)\n{\n\tphy->hw->wiphy->bands[NL80211_BAND_6GHZ] = &phy->sband_6g.sband;\n\n\treturn mt76_init_sband(phy, &phy->sband_6g, mt76_channels_6ghz,\n\t\t\t       ARRAY_SIZE(mt76_channels_6ghz), rates,\n\t\t\t       n_rates, false, false);\n}\n\nstatic void\nmt76_check_sband(struct mt76_phy *phy, struct mt76_sband *msband,\n\t\t enum nl80211_band band)\n{\n\tstruct ieee80211_supported_band *sband = &msband->sband;\n\tbool found = false;\n\tint i;\n\n\tif (!sband)\n\t\treturn;\n\n\tfor (i = 0; i < sband->n_channels; i++) {\n\t\tif (sband->channels[i].flags & IEEE80211_CHAN_DISABLED)\n\t\t\tcontinue;\n\n\t\tfound = true;\n\t\tbreak;\n\t}\n\n\tif (found) {\n\t\tphy->chandef.chan = &sband->channels[0];\n\t\tphy->chan_state = &msband->chan[0];\n\t\treturn;\n\t}\n\n\tsband->n_channels = 0;\n\tphy->hw->wiphy->bands[band] = NULL;\n}\n\nstatic int\nmt76_phy_init(struct mt76_phy *phy, struct ieee80211_hw *hw)\n{\n\tstruct mt76_dev *dev = phy->dev;\n\tstruct wiphy *wiphy = hw->wiphy;\n\n\tSET_IEEE80211_DEV(hw, dev->dev);\n\tSET_IEEE80211_PERM_ADDR(hw, phy->macaddr);\n\n\twiphy->features |= NL80211_FEATURE_ACTIVE_MONITOR |\n\t\t\t   NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE;\n\twiphy->flags |= WIPHY_FLAG_HAS_CHANNEL_SWITCH |\n\t\t\tWIPHY_FLAG_SUPPORTS_TDLS |\n\t\t\tWIPHY_FLAG_AP_UAPSD;\n\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_AIRTIME_FAIRNESS);\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_AQL);\n\n\twiphy->available_antennas_tx = phy->antenna_mask;\n\twiphy->available_antennas_rx = phy->antenna_mask;\n\n\twiphy->sar_capa = &mt76_sar_capa;\n\tphy->frp = devm_kcalloc(dev->dev, wiphy->sar_capa->num_freq_ranges,\n\t\t\t\tsizeof(struct mt76_freq_range_power),\n\t\t\t\tGFP_KERNEL);\n\tif (!phy->frp)\n\t\treturn -ENOMEM;\n\n\thw->txq_data_size = sizeof(struct mt76_txq);\n\thw->uapsd_max_sp_len = IEEE80211_WMM_IE_STA_QOSINFO_SP_ALL;\n\n\tif (!hw->max_tx_fragments)\n\t\thw->max_tx_fragments = 16;\n\n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\tieee80211_hw_set(hw, AMPDU_AGGREGATION);\n\tieee80211_hw_set(hw, SUPPORTS_RC_TABLE);\n\tieee80211_hw_set(hw, SUPPORT_FAST_XMIT);\n\tieee80211_hw_set(hw, SUPPORTS_CLONED_SKBS);\n\tieee80211_hw_set(hw, SUPPORTS_AMSDU_IN_AMPDU);\n\tieee80211_hw_set(hw, SUPPORTS_REORDERING_BUFFER);\n\n\tif (!(dev->drv->drv_flags & MT_DRV_AMSDU_OFFLOAD)) {\n\t\tieee80211_hw_set(hw, TX_AMSDU);\n\t\tieee80211_hw_set(hw, TX_FRAG_LIST);\n\t}\n\n\tieee80211_hw_set(hw, MFP_CAPABLE);\n\tieee80211_hw_set(hw, AP_LINK_PS);\n\tieee80211_hw_set(hw, REPORTS_TX_ACK_STATUS);\n\n\treturn 0;\n}\n\nstruct mt76_phy *\nmt76_alloc_phy(struct mt76_dev *dev, unsigned int size,\n\t       const struct ieee80211_ops *ops, u8 band_idx)\n{\n\tstruct ieee80211_hw *hw;\n\tunsigned int phy_size;\n\tstruct mt76_phy *phy;\n\n\tphy_size = ALIGN(sizeof(*phy), 8);\n\thw = ieee80211_alloc_hw(size + phy_size, ops);\n\tif (!hw)\n\t\treturn NULL;\n\n\tphy = hw->priv;\n\tphy->dev = dev;\n\tphy->hw = hw;\n\tphy->priv = hw->priv + phy_size;\n\tphy->band_idx = band_idx;\n\n\thw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;\n\thw->wiphy->interface_modes =\n\t\tBIT(NL80211_IFTYPE_STATION) |\n\t\tBIT(NL80211_IFTYPE_AP) |\n#ifdef CONFIG_MAC80211_MESH\n\t\tBIT(NL80211_IFTYPE_MESH_POINT) |\n#endif\n\t\tBIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\tBIT(NL80211_IFTYPE_P2P_GO) |\n\t\tBIT(NL80211_IFTYPE_ADHOC);\n\n\treturn phy;\n}\nEXPORT_SYMBOL_GPL(mt76_alloc_phy);\n\nint mt76_register_phy(struct mt76_phy *phy, bool vht,\n\t\t      struct ieee80211_rate *rates, int n_rates)\n{\n\tint ret;\n\n\tret = mt76_phy_init(phy, phy->hw);\n\tif (ret)\n\t\treturn ret;\n\n\tif (phy->cap.has_2ghz) {\n\t\tret = mt76_init_sband_2g(phy, rates, n_rates);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (phy->cap.has_5ghz) {\n\t\tret = mt76_init_sband_5g(phy, rates + 4, n_rates - 4, vht);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (phy->cap.has_6ghz) {\n\t\tret = mt76_init_sband_6g(phy, rates + 4, n_rates - 4);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (IS_ENABLED(CONFIG_MT76_LEDS)) {\n\t\tret = mt76_led_init(phy);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\twiphy_read_of_freq_limits(phy->hw->wiphy);\n\tmt76_check_sband(phy, &phy->sband_2g, NL80211_BAND_2GHZ);\n\tmt76_check_sband(phy, &phy->sband_5g, NL80211_BAND_5GHZ);\n\tmt76_check_sband(phy, &phy->sband_6g, NL80211_BAND_6GHZ);\n\n\tret = ieee80211_register_hw(phy->hw);\n\tif (ret)\n\t\treturn ret;\n\n\tset_bit(MT76_STATE_REGISTERED, &phy->state);\n\tphy->dev->phys[phy->band_idx] = phy;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76_register_phy);\n\nvoid mt76_unregister_phy(struct mt76_phy *phy)\n{\n\tstruct mt76_dev *dev = phy->dev;\n\n\tif (!test_bit(MT76_STATE_REGISTERED, &phy->state))\n\t\treturn;\n\n\tif (IS_ENABLED(CONFIG_MT76_LEDS))\n\t\tmt76_led_cleanup(phy);\n\tmt76_tx_status_check(dev, true);\n\tieee80211_unregister_hw(phy->hw);\n\tdev->phys[phy->band_idx] = NULL;\n}\nEXPORT_SYMBOL_GPL(mt76_unregister_phy);\n\nint mt76_create_page_pool(struct mt76_dev *dev, struct mt76_queue *q)\n{\n\tstruct page_pool_params pp_params = {\n\t\t.order = 0,\n\t\t.flags = PP_FLAG_PAGE_FRAG,\n\t\t.nid = NUMA_NO_NODE,\n\t\t.dev = dev->dma_dev,\n\t};\n\tint idx = q - dev->q_rx;\n\n\tswitch (idx) {\n\tcase MT_RXQ_MAIN:\n\tcase MT_RXQ_BAND1:\n\tcase MT_RXQ_BAND2:\n\t\tpp_params.pool_size = 256;\n\t\tbreak;\n\tdefault:\n\t\tpp_params.pool_size = 16;\n\t\tbreak;\n\t}\n\n\tif (mt76_is_mmio(dev)) {\n\t\t \n\t\tpp_params.flags |= PP_FLAG_DMA_MAP | PP_FLAG_DMA_SYNC_DEV;\n\t\tpp_params.dma_dir = DMA_FROM_DEVICE;\n\t\tpp_params.max_len = PAGE_SIZE;\n\t\tpp_params.offset = 0;\n\t}\n\n\tq->page_pool = page_pool_create(&pp_params);\n\tif (IS_ERR(q->page_pool)) {\n\t\tint err = PTR_ERR(q->page_pool);\n\n\t\tq->page_pool = NULL;\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76_create_page_pool);\n\nstruct mt76_dev *\nmt76_alloc_device(struct device *pdev, unsigned int size,\n\t\t  const struct ieee80211_ops *ops,\n\t\t  const struct mt76_driver_ops *drv_ops)\n{\n\tstruct ieee80211_hw *hw;\n\tstruct mt76_phy *phy;\n\tstruct mt76_dev *dev;\n\tint i;\n\n\thw = ieee80211_alloc_hw(size, ops);\n\tif (!hw)\n\t\treturn NULL;\n\n\tdev = hw->priv;\n\tdev->hw = hw;\n\tdev->dev = pdev;\n\tdev->drv = drv_ops;\n\tdev->dma_dev = pdev;\n\n\tphy = &dev->phy;\n\tphy->dev = dev;\n\tphy->hw = hw;\n\tphy->band_idx = MT_BAND0;\n\tdev->phys[phy->band_idx] = phy;\n\n\tspin_lock_init(&dev->rx_lock);\n\tspin_lock_init(&dev->lock);\n\tspin_lock_init(&dev->cc_lock);\n\tspin_lock_init(&dev->status_lock);\n\tspin_lock_init(&dev->wed_lock);\n\tmutex_init(&dev->mutex);\n\tinit_waitqueue_head(&dev->tx_wait);\n\n\tskb_queue_head_init(&dev->mcu.res_q);\n\tinit_waitqueue_head(&dev->mcu.wait);\n\tmutex_init(&dev->mcu.mutex);\n\tdev->tx_worker.fn = mt76_tx_worker;\n\n\thw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;\n\thw->wiphy->interface_modes =\n\t\tBIT(NL80211_IFTYPE_STATION) |\n\t\tBIT(NL80211_IFTYPE_AP) |\n#ifdef CONFIG_MAC80211_MESH\n\t\tBIT(NL80211_IFTYPE_MESH_POINT) |\n#endif\n\t\tBIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\tBIT(NL80211_IFTYPE_P2P_GO) |\n\t\tBIT(NL80211_IFTYPE_ADHOC);\n\n\tspin_lock_init(&dev->token_lock);\n\tidr_init(&dev->token);\n\n\tspin_lock_init(&dev->rx_token_lock);\n\tidr_init(&dev->rx_token);\n\n\tINIT_LIST_HEAD(&dev->wcid_list);\n\tINIT_LIST_HEAD(&dev->sta_poll_list);\n\tspin_lock_init(&dev->sta_poll_lock);\n\n\tINIT_LIST_HEAD(&dev->txwi_cache);\n\tINIT_LIST_HEAD(&dev->rxwi_cache);\n\tdev->token_size = dev->drv->token_size;\n\n\tfor (i = 0; i < ARRAY_SIZE(dev->q_rx); i++)\n\t\tskb_queue_head_init(&dev->rx_skb[i]);\n\n\tdev->wq = alloc_ordered_workqueue(\"mt76\", 0);\n\tif (!dev->wq) {\n\t\tieee80211_free_hw(hw);\n\t\treturn NULL;\n\t}\n\n\treturn dev;\n}\nEXPORT_SYMBOL_GPL(mt76_alloc_device);\n\nint mt76_register_device(struct mt76_dev *dev, bool vht,\n\t\t\t struct ieee80211_rate *rates, int n_rates)\n{\n\tstruct ieee80211_hw *hw = dev->hw;\n\tstruct mt76_phy *phy = &dev->phy;\n\tint ret;\n\n\tdev_set_drvdata(dev->dev, dev);\n\tret = mt76_phy_init(phy, hw);\n\tif (ret)\n\t\treturn ret;\n\n\tif (phy->cap.has_2ghz) {\n\t\tret = mt76_init_sband_2g(phy, rates, n_rates);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (phy->cap.has_5ghz) {\n\t\tret = mt76_init_sband_5g(phy, rates + 4, n_rates - 4, vht);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (phy->cap.has_6ghz) {\n\t\tret = mt76_init_sband_6g(phy, rates + 4, n_rates - 4);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\twiphy_read_of_freq_limits(hw->wiphy);\n\tmt76_check_sband(&dev->phy, &phy->sband_2g, NL80211_BAND_2GHZ);\n\tmt76_check_sband(&dev->phy, &phy->sband_5g, NL80211_BAND_5GHZ);\n\tmt76_check_sband(&dev->phy, &phy->sband_6g, NL80211_BAND_6GHZ);\n\n\tif (IS_ENABLED(CONFIG_MT76_LEDS)) {\n\t\tret = mt76_led_init(phy);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = ieee80211_register_hw(hw);\n\tif (ret)\n\t\treturn ret;\n\n\tWARN_ON(mt76_worker_setup(hw, &dev->tx_worker, NULL, \"tx\"));\n\tset_bit(MT76_STATE_REGISTERED, &phy->state);\n\tsched_set_fifo_low(dev->tx_worker.task);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76_register_device);\n\nvoid mt76_unregister_device(struct mt76_dev *dev)\n{\n\tstruct ieee80211_hw *hw = dev->hw;\n\n\tif (!test_bit(MT76_STATE_REGISTERED, &dev->phy.state))\n\t\treturn;\n\n\tif (IS_ENABLED(CONFIG_MT76_LEDS))\n\t\tmt76_led_cleanup(&dev->phy);\n\tmt76_tx_status_check(dev, true);\n\tieee80211_unregister_hw(hw);\n}\nEXPORT_SYMBOL_GPL(mt76_unregister_device);\n\nvoid mt76_free_device(struct mt76_dev *dev)\n{\n\tmt76_worker_teardown(&dev->tx_worker);\n\tif (dev->wq) {\n\t\tdestroy_workqueue(dev->wq);\n\t\tdev->wq = NULL;\n\t}\n\tieee80211_free_hw(dev->hw);\n}\nEXPORT_SYMBOL_GPL(mt76_free_device);\n\nstatic void mt76_rx_release_amsdu(struct mt76_phy *phy, enum mt76_rxq_id q)\n{\n\tstruct sk_buff *skb = phy->rx_amsdu[q].head;\n\tstruct mt76_rx_status *status = (struct mt76_rx_status *)skb->cb;\n\tstruct mt76_dev *dev = phy->dev;\n\n\tphy->rx_amsdu[q].head = NULL;\n\tphy->rx_amsdu[q].tail = NULL;\n\n\t \n\tif (skb_shinfo(skb)->frag_list) {\n\t\tint offset = 0;\n\n\t\tif (!(status->flag & RX_FLAG_8023)) {\n\t\t\toffset = ieee80211_get_hdrlen_from_skb(skb);\n\n\t\t\tif ((status->flag &\n\t\t\t     (RX_FLAG_DECRYPTED | RX_FLAG_IV_STRIPPED)) ==\n\t\t\t    RX_FLAG_DECRYPTED)\n\t\t\t\toffset += 8;\n\t\t}\n\n\t\tif (ether_addr_equal(skb->data + offset, rfc1042_header)) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t}\n\t__skb_queue_tail(&dev->rx_skb[q], skb);\n}\n\nstatic void mt76_rx_release_burst(struct mt76_phy *phy, enum mt76_rxq_id q,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct mt76_rx_status *status = (struct mt76_rx_status *)skb->cb;\n\n\tif (phy->rx_amsdu[q].head &&\n\t    (!status->amsdu || status->first_amsdu ||\n\t     status->seqno != phy->rx_amsdu[q].seqno))\n\t\tmt76_rx_release_amsdu(phy, q);\n\n\tif (!phy->rx_amsdu[q].head) {\n\t\tphy->rx_amsdu[q].tail = &skb_shinfo(skb)->frag_list;\n\t\tphy->rx_amsdu[q].seqno = status->seqno;\n\t\tphy->rx_amsdu[q].head = skb;\n\t} else {\n\t\t*phy->rx_amsdu[q].tail = skb;\n\t\tphy->rx_amsdu[q].tail = &skb->next;\n\t}\n\n\tif (!status->amsdu || status->last_amsdu)\n\t\tmt76_rx_release_amsdu(phy, q);\n}\n\nvoid mt76_rx(struct mt76_dev *dev, enum mt76_rxq_id q, struct sk_buff *skb)\n{\n\tstruct mt76_rx_status *status = (struct mt76_rx_status *)skb->cb;\n\tstruct mt76_phy *phy = mt76_dev_phy(dev, status->phy_idx);\n\n\tif (!test_bit(MT76_STATE_RUNNING, &phy->state)) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_NL80211_TESTMODE\n\tif (phy->test.state == MT76_TM_STATE_RX_FRAMES) {\n\t\tphy->test.rx_stats.packets[q]++;\n\t\tif (status->flag & RX_FLAG_FAILED_FCS_CRC)\n\t\t\tphy->test.rx_stats.fcs_error[q]++;\n\t}\n#endif\n\n\tmt76_rx_release_burst(phy, q, skb);\n}\nEXPORT_SYMBOL_GPL(mt76_rx);\n\nbool mt76_has_tx_pending(struct mt76_phy *phy)\n{\n\tstruct mt76_queue *q;\n\tint i;\n\n\tfor (i = 0; i < __MT_TXQ_MAX; i++) {\n\t\tq = phy->q_tx[i];\n\t\tif (q && q->queued)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(mt76_has_tx_pending);\n\nstatic struct mt76_channel_state *\nmt76_channel_state(struct mt76_phy *phy, struct ieee80211_channel *c)\n{\n\tstruct mt76_sband *msband;\n\tint idx;\n\n\tif (c->band == NL80211_BAND_2GHZ)\n\t\tmsband = &phy->sband_2g;\n\telse if (c->band == NL80211_BAND_6GHZ)\n\t\tmsband = &phy->sband_6g;\n\telse\n\t\tmsband = &phy->sband_5g;\n\n\tidx = c - &msband->sband.channels[0];\n\treturn &msband->chan[idx];\n}\n\nvoid mt76_update_survey_active_time(struct mt76_phy *phy, ktime_t time)\n{\n\tstruct mt76_channel_state *state = phy->chan_state;\n\n\tstate->cc_active += ktime_to_us(ktime_sub(time,\n\t\t\t\t\t\t  phy->survey_time));\n\tphy->survey_time = time;\n}\nEXPORT_SYMBOL_GPL(mt76_update_survey_active_time);\n\nvoid mt76_update_survey(struct mt76_phy *phy)\n{\n\tstruct mt76_dev *dev = phy->dev;\n\tktime_t cur_time;\n\n\tif (dev->drv->update_survey)\n\t\tdev->drv->update_survey(phy);\n\n\tcur_time = ktime_get_boottime();\n\tmt76_update_survey_active_time(phy, cur_time);\n\n\tif (dev->drv->drv_flags & MT_DRV_SW_RX_AIRTIME) {\n\t\tstruct mt76_channel_state *state = phy->chan_state;\n\n\t\tspin_lock_bh(&dev->cc_lock);\n\t\tstate->cc_bss_rx += dev->cur_cc_bss_rx;\n\t\tdev->cur_cc_bss_rx = 0;\n\t\tspin_unlock_bh(&dev->cc_lock);\n\t}\n}\nEXPORT_SYMBOL_GPL(mt76_update_survey);\n\nvoid mt76_set_channel(struct mt76_phy *phy)\n{\n\tstruct mt76_dev *dev = phy->dev;\n\tstruct ieee80211_hw *hw = phy->hw;\n\tstruct cfg80211_chan_def *chandef = &hw->conf.chandef;\n\tbool offchannel = hw->conf.flags & IEEE80211_CONF_OFFCHANNEL;\n\tint timeout = HZ / 5;\n\n\twait_event_timeout(dev->tx_wait, !mt76_has_tx_pending(phy), timeout);\n\tmt76_update_survey(phy);\n\n\tif (phy->chandef.chan->center_freq != chandef->chan->center_freq ||\n\t    phy->chandef.width != chandef->width)\n\t\tphy->dfs_state = MT_DFS_STATE_UNKNOWN;\n\n\tphy->chandef = *chandef;\n\tphy->chan_state = mt76_channel_state(phy, chandef->chan);\n\n\tif (!offchannel)\n\t\tphy->main_chan = chandef->chan;\n\n\tif (chandef->chan != phy->main_chan)\n\t\tmemset(phy->chan_state, 0, sizeof(*phy->chan_state));\n}\nEXPORT_SYMBOL_GPL(mt76_set_channel);\n\nint mt76_get_survey(struct ieee80211_hw *hw, int idx,\n\t\t    struct survey_info *survey)\n{\n\tstruct mt76_phy *phy = hw->priv;\n\tstruct mt76_dev *dev = phy->dev;\n\tstruct mt76_sband *sband;\n\tstruct ieee80211_channel *chan;\n\tstruct mt76_channel_state *state;\n\tint ret = 0;\n\n\tmutex_lock(&dev->mutex);\n\tif (idx == 0 && dev->drv->update_survey)\n\t\tmt76_update_survey(phy);\n\n\tif (idx >= phy->sband_2g.sband.n_channels +\n\t\t   phy->sband_5g.sband.n_channels) {\n\t\tidx -= (phy->sband_2g.sband.n_channels +\n\t\t\tphy->sband_5g.sband.n_channels);\n\t\tsband = &phy->sband_6g;\n\t} else if (idx >= phy->sband_2g.sband.n_channels) {\n\t\tidx -= phy->sband_2g.sband.n_channels;\n\t\tsband = &phy->sband_5g;\n\t} else {\n\t\tsband = &phy->sband_2g;\n\t}\n\n\tif (idx >= sband->sband.n_channels) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tchan = &sband->sband.channels[idx];\n\tstate = mt76_channel_state(phy, chan);\n\n\tmemset(survey, 0, sizeof(*survey));\n\tsurvey->channel = chan;\n\tsurvey->filled = SURVEY_INFO_TIME | SURVEY_INFO_TIME_BUSY;\n\tsurvey->filled |= dev->drv->survey_flags;\n\tif (state->noise)\n\t\tsurvey->filled |= SURVEY_INFO_NOISE_DBM;\n\n\tif (chan == phy->main_chan) {\n\t\tsurvey->filled |= SURVEY_INFO_IN_USE;\n\n\t\tif (dev->drv->drv_flags & MT_DRV_SW_RX_AIRTIME)\n\t\t\tsurvey->filled |= SURVEY_INFO_TIME_BSS_RX;\n\t}\n\n\tsurvey->time_busy = div_u64(state->cc_busy, 1000);\n\tsurvey->time_rx = div_u64(state->cc_rx, 1000);\n\tsurvey->time = div_u64(state->cc_active, 1000);\n\tsurvey->noise = state->noise;\n\n\tspin_lock_bh(&dev->cc_lock);\n\tsurvey->time_bss_rx = div_u64(state->cc_bss_rx, 1000);\n\tsurvey->time_tx = div_u64(state->cc_tx, 1000);\n\tspin_unlock_bh(&dev->cc_lock);\n\nout:\n\tmutex_unlock(&dev->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mt76_get_survey);\n\nvoid mt76_wcid_key_setup(struct mt76_dev *dev, struct mt76_wcid *wcid,\n\t\t\t struct ieee80211_key_conf *key)\n{\n\tstruct ieee80211_key_seq seq;\n\tint i;\n\n\twcid->rx_check_pn = false;\n\n\tif (!key)\n\t\treturn;\n\n\tif (key->cipher != WLAN_CIPHER_SUITE_CCMP)\n\t\treturn;\n\n\twcid->rx_check_pn = true;\n\n\t \n\tfor (i = 0; i < IEEE80211_NUM_TIDS; i++) {\n\t\tieee80211_get_key_rx_seq(key, i, &seq);\n\t\tmemcpy(wcid->rx_key_pn[i], seq.ccmp.pn, sizeof(seq.ccmp.pn));\n\t}\n\n\t \n\tieee80211_get_key_rx_seq(key, -1, &seq);\n\tmemcpy(wcid->rx_key_pn[i], seq.ccmp.pn, sizeof(seq.ccmp.pn));\n\n}\nEXPORT_SYMBOL(mt76_wcid_key_setup);\n\nint mt76_rx_signal(u8 chain_mask, s8 *chain_signal)\n{\n\tint signal = -128;\n\tu8 chains;\n\n\tfor (chains = chain_mask; chains; chains >>= 1, chain_signal++) {\n\t\tint cur, diff;\n\n\t\tcur = *chain_signal;\n\t\tif (!(chains & BIT(0)) ||\n\t\t    cur > 0)\n\t\t\tcontinue;\n\n\t\tif (cur > signal)\n\t\t\tswap(cur, signal);\n\n\t\tdiff = signal - cur;\n\t\tif (diff == 0)\n\t\t\tsignal += 3;\n\t\telse if (diff <= 2)\n\t\t\tsignal += 2;\n\t\telse if (diff <= 6)\n\t\t\tsignal += 1;\n\t}\n\n\treturn signal;\n}\nEXPORT_SYMBOL(mt76_rx_signal);\n\nstatic void\nmt76_rx_convert(struct mt76_dev *dev, struct sk_buff *skb,\n\t\tstruct ieee80211_hw **hw,\n\t\tstruct ieee80211_sta **sta)\n{\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_hdr *hdr = mt76_skb_get_hdr(skb);\n\tstruct mt76_rx_status mstat;\n\n\tmstat = *((struct mt76_rx_status *)skb->cb);\n\tmemset(status, 0, sizeof(*status));\n\n\tstatus->flag = mstat.flag;\n\tstatus->freq = mstat.freq;\n\tstatus->enc_flags = mstat.enc_flags;\n\tstatus->encoding = mstat.encoding;\n\tstatus->bw = mstat.bw;\n\tif (status->encoding == RX_ENC_EHT) {\n\t\tstatus->eht.ru = mstat.eht.ru;\n\t\tstatus->eht.gi = mstat.eht.gi;\n\t} else {\n\t\tstatus->he_ru = mstat.he_ru;\n\t\tstatus->he_gi = mstat.he_gi;\n\t\tstatus->he_dcm = mstat.he_dcm;\n\t}\n\tstatus->rate_idx = mstat.rate_idx;\n\tstatus->nss = mstat.nss;\n\tstatus->band = mstat.band;\n\tstatus->signal = mstat.signal;\n\tstatus->chains = mstat.chains;\n\tstatus->ampdu_reference = mstat.ampdu_ref;\n\tstatus->device_timestamp = mstat.timestamp;\n\tstatus->mactime = mstat.timestamp;\n\tstatus->signal = mt76_rx_signal(mstat.chains, mstat.chain_signal);\n\tif (status->signal <= -128)\n\t\tstatus->flag |= RX_FLAG_NO_SIGNAL_VAL;\n\n\tif (ieee80211_is_beacon(hdr->frame_control) ||\n\t    ieee80211_is_probe_resp(hdr->frame_control))\n\t\tstatus->boottime_ns = ktime_get_boottime_ns();\n\n\tBUILD_BUG_ON(sizeof(mstat) > sizeof(skb->cb));\n\tBUILD_BUG_ON(sizeof(status->chain_signal) !=\n\t\t     sizeof(mstat.chain_signal));\n\tmemcpy(status->chain_signal, mstat.chain_signal,\n\t       sizeof(mstat.chain_signal));\n\n\t*sta = wcid_to_sta(mstat.wcid);\n\t*hw = mt76_phy_hw(dev, mstat.phy_idx);\n}\n\nstatic void\nmt76_check_ccmp_pn(struct sk_buff *skb)\n{\n\tstruct mt76_rx_status *status = (struct mt76_rx_status *)skb->cb;\n\tstruct mt76_wcid *wcid = status->wcid;\n\tstruct ieee80211_hdr *hdr;\n\tint security_idx;\n\tint ret;\n\n\tif (!(status->flag & RX_FLAG_DECRYPTED))\n\t\treturn;\n\n\tif (status->flag & RX_FLAG_ONLY_MONITOR)\n\t\treturn;\n\n\tif (!wcid || !wcid->rx_check_pn)\n\t\treturn;\n\n\tsecurity_idx = status->qos_ctl & IEEE80211_QOS_CTL_TID_MASK;\n\tif (status->flag & RX_FLAG_8023)\n\t\tgoto skip_hdr_check;\n\n\thdr = mt76_skb_get_hdr(skb);\n\tif (!(status->flag & RX_FLAG_IV_STRIPPED)) {\n\t\t \n\t\tif (ieee80211_is_frag(hdr) &&\n\t\t    !ieee80211_is_first_frag(hdr->frame_control))\n\t\t\treturn;\n\t}\n\n\t \n\tif (ieee80211_is_mgmt(hdr->frame_control) &&\n\t    !ieee80211_has_tods(hdr->frame_control))\n\t\tsecurity_idx = IEEE80211_NUM_TIDS;\n\nskip_hdr_check:\n\tBUILD_BUG_ON(sizeof(status->iv) != sizeof(wcid->rx_key_pn[0]));\n\tret = memcmp(status->iv, wcid->rx_key_pn[security_idx],\n\t\t     sizeof(status->iv));\n\tif (ret <= 0) {\n\t\tstatus->flag |= RX_FLAG_ONLY_MONITOR;\n\t\treturn;\n\t}\n\n\tmemcpy(wcid->rx_key_pn[security_idx], status->iv, sizeof(status->iv));\n\n\tif (status->flag & RX_FLAG_IV_STRIPPED)\n\t\tstatus->flag |= RX_FLAG_PN_VALIDATED;\n}\n\nstatic void\nmt76_airtime_report(struct mt76_dev *dev, struct mt76_rx_status *status,\n\t\t    int len)\n{\n\tstruct mt76_wcid *wcid = status->wcid;\n\tstruct ieee80211_rx_status info = {\n\t\t.enc_flags = status->enc_flags,\n\t\t.rate_idx = status->rate_idx,\n\t\t.encoding = status->encoding,\n\t\t.band = status->band,\n\t\t.nss = status->nss,\n\t\t.bw = status->bw,\n\t};\n\tstruct ieee80211_sta *sta;\n\tu32 airtime;\n\tu8 tidno = status->qos_ctl & IEEE80211_QOS_CTL_TID_MASK;\n\n\tairtime = ieee80211_calc_rx_airtime(dev->hw, &info, len);\n\tspin_lock(&dev->cc_lock);\n\tdev->cur_cc_bss_rx += airtime;\n\tspin_unlock(&dev->cc_lock);\n\n\tif (!wcid || !wcid->sta)\n\t\treturn;\n\n\tsta = container_of((void *)wcid, struct ieee80211_sta, drv_priv);\n\tieee80211_sta_register_airtime(sta, tidno, 0, airtime);\n}\n\nstatic void\nmt76_airtime_flush_ampdu(struct mt76_dev *dev)\n{\n\tstruct mt76_wcid *wcid;\n\tint wcid_idx;\n\n\tif (!dev->rx_ampdu_len)\n\t\treturn;\n\n\twcid_idx = dev->rx_ampdu_status.wcid_idx;\n\tif (wcid_idx < ARRAY_SIZE(dev->wcid))\n\t\twcid = rcu_dereference(dev->wcid[wcid_idx]);\n\telse\n\t\twcid = NULL;\n\tdev->rx_ampdu_status.wcid = wcid;\n\n\tmt76_airtime_report(dev, &dev->rx_ampdu_status, dev->rx_ampdu_len);\n\n\tdev->rx_ampdu_len = 0;\n\tdev->rx_ampdu_ref = 0;\n}\n\nstatic void\nmt76_airtime_check(struct mt76_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt76_rx_status *status = (struct mt76_rx_status *)skb->cb;\n\tstruct mt76_wcid *wcid = status->wcid;\n\n\tif (!(dev->drv->drv_flags & MT_DRV_SW_RX_AIRTIME))\n\t\treturn;\n\n\tif (!wcid || !wcid->sta) {\n\t\tstruct ieee80211_hdr *hdr = mt76_skb_get_hdr(skb);\n\n\t\tif (status->flag & RX_FLAG_8023)\n\t\t\treturn;\n\n\t\tif (!ether_addr_equal(hdr->addr1, dev->phy.macaddr))\n\t\t\treturn;\n\n\t\twcid = NULL;\n\t}\n\n\tif (!(status->flag & RX_FLAG_AMPDU_DETAILS) ||\n\t    status->ampdu_ref != dev->rx_ampdu_ref)\n\t\tmt76_airtime_flush_ampdu(dev);\n\n\tif (status->flag & RX_FLAG_AMPDU_DETAILS) {\n\t\tif (!dev->rx_ampdu_len ||\n\t\t    status->ampdu_ref != dev->rx_ampdu_ref) {\n\t\t\tdev->rx_ampdu_status = *status;\n\t\t\tdev->rx_ampdu_status.wcid_idx = wcid ? wcid->idx : 0xff;\n\t\t\tdev->rx_ampdu_ref = status->ampdu_ref;\n\t\t}\n\n\t\tdev->rx_ampdu_len += skb->len;\n\t\treturn;\n\t}\n\n\tmt76_airtime_report(dev, status, skb->len);\n}\n\nstatic void\nmt76_check_sta(struct mt76_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt76_rx_status *status = (struct mt76_rx_status *)skb->cb;\n\tstruct ieee80211_hdr *hdr = mt76_skb_get_hdr(skb);\n\tstruct ieee80211_sta *sta;\n\tstruct ieee80211_hw *hw;\n\tstruct mt76_wcid *wcid = status->wcid;\n\tu8 tidno = status->qos_ctl & IEEE80211_QOS_CTL_TID_MASK;\n\tbool ps;\n\n\thw = mt76_phy_hw(dev, status->phy_idx);\n\tif (ieee80211_is_pspoll(hdr->frame_control) && !wcid &&\n\t    !(status->flag & RX_FLAG_8023)) {\n\t\tsta = ieee80211_find_sta_by_ifaddr(hw, hdr->addr2, NULL);\n\t\tif (sta)\n\t\t\twcid = status->wcid = (struct mt76_wcid *)sta->drv_priv;\n\t}\n\n\tmt76_airtime_check(dev, skb);\n\n\tif (!wcid || !wcid->sta)\n\t\treturn;\n\n\tsta = container_of((void *)wcid, struct ieee80211_sta, drv_priv);\n\n\tif (status->signal <= 0)\n\t\tewma_signal_add(&wcid->rssi, -status->signal);\n\n\twcid->inactive_count = 0;\n\n\tif (status->flag & RX_FLAG_8023)\n\t\treturn;\n\n\tif (!test_bit(MT_WCID_FLAG_CHECK_PS, &wcid->flags))\n\t\treturn;\n\n\tif (ieee80211_is_pspoll(hdr->frame_control)) {\n\t\tieee80211_sta_pspoll(sta);\n\t\treturn;\n\t}\n\n\tif (ieee80211_has_morefrags(hdr->frame_control) ||\n\t    !(ieee80211_is_mgmt(hdr->frame_control) ||\n\t      ieee80211_is_data(hdr->frame_control)))\n\t\treturn;\n\n\tps = ieee80211_has_pm(hdr->frame_control);\n\n\tif (ps && (ieee80211_is_data_qos(hdr->frame_control) ||\n\t\t   ieee80211_is_qos_nullfunc(hdr->frame_control)))\n\t\tieee80211_sta_uapsd_trigger(sta, tidno);\n\n\tif (!!test_bit(MT_WCID_FLAG_PS, &wcid->flags) == ps)\n\t\treturn;\n\n\tif (ps)\n\t\tset_bit(MT_WCID_FLAG_PS, &wcid->flags);\n\n\tif (dev->drv->sta_ps)\n\t\tdev->drv->sta_ps(dev, sta, ps);\n\n\tif (!ps)\n\t\tclear_bit(MT_WCID_FLAG_PS, &wcid->flags);\n\n\tieee80211_sta_ps_transition(sta, ps);\n}\n\nvoid mt76_rx_complete(struct mt76_dev *dev, struct sk_buff_head *frames,\n\t\t      struct napi_struct *napi)\n{\n\tstruct ieee80211_sta *sta;\n\tstruct ieee80211_hw *hw;\n\tstruct sk_buff *skb, *tmp;\n\tLIST_HEAD(list);\n\n\tspin_lock(&dev->rx_lock);\n\twhile ((skb = __skb_dequeue(frames)) != NULL) {\n\t\tstruct sk_buff *nskb = skb_shinfo(skb)->frag_list;\n\n\t\tmt76_check_ccmp_pn(skb);\n\t\tskb_shinfo(skb)->frag_list = NULL;\n\t\tmt76_rx_convert(dev, skb, &hw, &sta);\n\t\tieee80211_rx_list(hw, sta, skb, &list);\n\n\t\t \n\t\twhile (nskb) {\n\t\t\tskb = nskb;\n\t\t\tnskb = nskb->next;\n\t\t\tskb->next = NULL;\n\n\t\t\tmt76_rx_convert(dev, skb, &hw, &sta);\n\t\t\tieee80211_rx_list(hw, sta, skb, &list);\n\t\t}\n\t}\n\tspin_unlock(&dev->rx_lock);\n\n\tif (!napi) {\n\t\tnetif_receive_skb_list(&list);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry_safe(skb, tmp, &list, list) {\n\t\tskb_list_del_init(skb);\n\t\tnapi_gro_receive(napi, skb);\n\t}\n}\n\nvoid mt76_rx_poll_complete(struct mt76_dev *dev, enum mt76_rxq_id q,\n\t\t\t   struct napi_struct *napi)\n{\n\tstruct sk_buff_head frames;\n\tstruct sk_buff *skb;\n\n\t__skb_queue_head_init(&frames);\n\n\twhile ((skb = __skb_dequeue(&dev->rx_skb[q])) != NULL) {\n\t\tmt76_check_sta(dev, skb);\n\t\tif (mtk_wed_device_active(&dev->mmio.wed))\n\t\t\t__skb_queue_tail(&frames, skb);\n\t\telse\n\t\t\tmt76_rx_aggr_reorder(skb, &frames);\n\t}\n\n\tmt76_rx_complete(dev, &frames, napi);\n}\nEXPORT_SYMBOL_GPL(mt76_rx_poll_complete);\n\nstatic int\nmt76_sta_add(struct mt76_phy *phy, struct ieee80211_vif *vif,\n\t     struct ieee80211_sta *sta)\n{\n\tstruct mt76_wcid *wcid = (struct mt76_wcid *)sta->drv_priv;\n\tstruct mt76_dev *dev = phy->dev;\n\tint ret;\n\tint i;\n\n\tmutex_lock(&dev->mutex);\n\n\tret = dev->drv->sta_add(dev, vif, sta);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (i = 0; i < ARRAY_SIZE(sta->txq); i++) {\n\t\tstruct mt76_txq *mtxq;\n\n\t\tif (!sta->txq[i])\n\t\t\tcontinue;\n\n\t\tmtxq = (struct mt76_txq *)sta->txq[i]->drv_priv;\n\t\tmtxq->wcid = wcid->idx;\n\t}\n\n\tewma_signal_init(&wcid->rssi);\n\tif (phy->band_idx == MT_BAND1)\n\t\tmt76_wcid_mask_set(dev->wcid_phy_mask, wcid->idx);\n\twcid->phy_idx = phy->band_idx;\n\trcu_assign_pointer(dev->wcid[wcid->idx], wcid);\n\n\tmt76_packet_id_init(wcid);\nout:\n\tmutex_unlock(&dev->mutex);\n\n\treturn ret;\n}\n\nvoid __mt76_sta_remove(struct mt76_dev *dev, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_sta *sta)\n{\n\tstruct mt76_wcid *wcid = (struct mt76_wcid *)sta->drv_priv;\n\tint i, idx = wcid->idx;\n\n\tfor (i = 0; i < ARRAY_SIZE(wcid->aggr); i++)\n\t\tmt76_rx_aggr_stop(dev, wcid, i);\n\n\tif (dev->drv->sta_remove)\n\t\tdev->drv->sta_remove(dev, vif, sta);\n\n\tmt76_packet_id_flush(dev, wcid);\n\n\tmt76_wcid_mask_clear(dev->wcid_mask, idx);\n\tmt76_wcid_mask_clear(dev->wcid_phy_mask, idx);\n}\nEXPORT_SYMBOL_GPL(__mt76_sta_remove);\n\nstatic void\nmt76_sta_remove(struct mt76_dev *dev, struct ieee80211_vif *vif,\n\t\tstruct ieee80211_sta *sta)\n{\n\tmutex_lock(&dev->mutex);\n\t__mt76_sta_remove(dev, vif, sta);\n\tmutex_unlock(&dev->mutex);\n}\n\nint mt76_sta_state(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t   struct ieee80211_sta *sta,\n\t\t   enum ieee80211_sta_state old_state,\n\t\t   enum ieee80211_sta_state new_state)\n{\n\tstruct mt76_phy *phy = hw->priv;\n\tstruct mt76_dev *dev = phy->dev;\n\n\tif (old_state == IEEE80211_STA_NOTEXIST &&\n\t    new_state == IEEE80211_STA_NONE)\n\t\treturn mt76_sta_add(phy, vif, sta);\n\n\tif (old_state == IEEE80211_STA_AUTH &&\n\t    new_state == IEEE80211_STA_ASSOC &&\n\t    dev->drv->sta_assoc)\n\t\tdev->drv->sta_assoc(dev, vif, sta);\n\n\tif (old_state == IEEE80211_STA_NONE &&\n\t    new_state == IEEE80211_STA_NOTEXIST)\n\t\tmt76_sta_remove(dev, vif, sta);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76_sta_state);\n\nvoid mt76_sta_pre_rcu_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_sta *sta)\n{\n\tstruct mt76_phy *phy = hw->priv;\n\tstruct mt76_dev *dev = phy->dev;\n\tstruct mt76_wcid *wcid = (struct mt76_wcid *)sta->drv_priv;\n\n\tmutex_lock(&dev->mutex);\n\tspin_lock_bh(&dev->status_lock);\n\trcu_assign_pointer(dev->wcid[wcid->idx], NULL);\n\tspin_unlock_bh(&dev->status_lock);\n\tmutex_unlock(&dev->mutex);\n}\nEXPORT_SYMBOL_GPL(mt76_sta_pre_rcu_remove);\n\nint mt76_get_txpower(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t     int *dbm)\n{\n\tstruct mt76_phy *phy = hw->priv;\n\tint n_chains = hweight8(phy->antenna_mask);\n\tint delta = mt76_tx_power_nss_delta(n_chains);\n\n\t*dbm = DIV_ROUND_UP(phy->txpower_cur + delta, 2);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76_get_txpower);\n\nint mt76_init_sar_power(struct ieee80211_hw *hw,\n\t\t\tconst struct cfg80211_sar_specs *sar)\n{\n\tstruct mt76_phy *phy = hw->priv;\n\tconst struct cfg80211_sar_capa *capa = hw->wiphy->sar_capa;\n\tint i;\n\n\tif (sar->type != NL80211_SAR_TYPE_POWER || !sar->num_sub_specs)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < sar->num_sub_specs; i++) {\n\t\tu32 index = sar->sub_specs[i].freq_range_index;\n\t\t \n\t\ts32 power = sar->sub_specs[i].power >> 1;\n\n\t\tif (power > 127 || power < -127)\n\t\t\tpower = 127;\n\n\t\tphy->frp[index].range = &capa->freq_ranges[index];\n\t\tphy->frp[index].power = power;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76_init_sar_power);\n\nint mt76_get_sar_power(struct mt76_phy *phy,\n\t\t       struct ieee80211_channel *chan,\n\t\t       int power)\n{\n\tconst struct cfg80211_sar_capa *capa = phy->hw->wiphy->sar_capa;\n\tint freq, i;\n\n\tif (!capa || !phy->frp)\n\t\treturn power;\n\n\tif (power > 127 || power < -127)\n\t\tpower = 127;\n\n\tfreq = ieee80211_channel_to_frequency(chan->hw_value, chan->band);\n\tfor (i = 0 ; i < capa->num_freq_ranges; i++) {\n\t\tif (phy->frp[i].range &&\n\t\t    freq >= phy->frp[i].range->start_freq &&\n\t\t    freq < phy->frp[i].range->end_freq) {\n\t\t\tpower = min_t(int, phy->frp[i].power, power);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn power;\n}\nEXPORT_SYMBOL_GPL(mt76_get_sar_power);\n\nstatic void\n__mt76_csa_finish(void *priv, u8 *mac, struct ieee80211_vif *vif)\n{\n\tif (vif->bss_conf.csa_active && ieee80211_beacon_cntdwn_is_complete(vif))\n\t\tieee80211_csa_finish(vif);\n}\n\nvoid mt76_csa_finish(struct mt76_dev *dev)\n{\n\tif (!dev->csa_complete)\n\t\treturn;\n\n\tieee80211_iterate_active_interfaces_atomic(dev->hw,\n\t\tIEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t__mt76_csa_finish, dev);\n\n\tdev->csa_complete = 0;\n}\nEXPORT_SYMBOL_GPL(mt76_csa_finish);\n\nstatic void\n__mt76_csa_check(void *priv, u8 *mac, struct ieee80211_vif *vif)\n{\n\tstruct mt76_dev *dev = priv;\n\n\tif (!vif->bss_conf.csa_active)\n\t\treturn;\n\n\tdev->csa_complete |= ieee80211_beacon_cntdwn_is_complete(vif);\n}\n\nvoid mt76_csa_check(struct mt76_dev *dev)\n{\n\tieee80211_iterate_active_interfaces_atomic(dev->hw,\n\t\tIEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t__mt76_csa_check, dev);\n}\nEXPORT_SYMBOL_GPL(mt76_csa_check);\n\nint\nmt76_set_tim(struct ieee80211_hw *hw, struct ieee80211_sta *sta, bool set)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76_set_tim);\n\nvoid mt76_insert_ccmp_hdr(struct sk_buff *skb, u8 key_id)\n{\n\tstruct mt76_rx_status *status = (struct mt76_rx_status *)skb->cb;\n\tint hdr_len = ieee80211_get_hdrlen_from_skb(skb);\n\tu8 *hdr, *pn = status->iv;\n\n\t__skb_push(skb, 8);\n\tmemmove(skb->data, skb->data + 8, hdr_len);\n\thdr = skb->data + hdr_len;\n\n\thdr[0] = pn[5];\n\thdr[1] = pn[4];\n\thdr[2] = 0;\n\thdr[3] = 0x20 | (key_id << 6);\n\thdr[4] = pn[3];\n\thdr[5] = pn[2];\n\thdr[6] = pn[1];\n\thdr[7] = pn[0];\n\n\tstatus->flag &= ~RX_FLAG_IV_STRIPPED;\n}\nEXPORT_SYMBOL_GPL(mt76_insert_ccmp_hdr);\n\nint mt76_get_rate(struct mt76_dev *dev,\n\t\t  struct ieee80211_supported_band *sband,\n\t\t  int idx, bool cck)\n{\n\tint i, offset = 0, len = sband->n_bitrates;\n\n\tif (cck) {\n\t\tif (sband != &dev->phy.sband_2g.sband)\n\t\t\treturn 0;\n\n\t\tidx &= ~BIT(2);  \n\t} else if (sband == &dev->phy.sband_2g.sband) {\n\t\toffset = 4;\n\t}\n\n\tfor (i = offset; i < len; i++) {\n\t\tif ((sband->bitrates[i].hw_value & GENMASK(7, 0)) == idx)\n\t\t\treturn i;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76_get_rate);\n\nvoid mt76_sw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t  const u8 *mac)\n{\n\tstruct mt76_phy *phy = hw->priv;\n\n\tset_bit(MT76_SCANNING, &phy->state);\n}\nEXPORT_SYMBOL_GPL(mt76_sw_scan);\n\nvoid mt76_sw_scan_complete(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct mt76_phy *phy = hw->priv;\n\n\tclear_bit(MT76_SCANNING, &phy->state);\n}\nEXPORT_SYMBOL_GPL(mt76_sw_scan_complete);\n\nint mt76_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant)\n{\n\tstruct mt76_phy *phy = hw->priv;\n\tstruct mt76_dev *dev = phy->dev;\n\n\tmutex_lock(&dev->mutex);\n\t*tx_ant = phy->antenna_mask;\n\t*rx_ant = phy->antenna_mask;\n\tmutex_unlock(&dev->mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76_get_antenna);\n\nstruct mt76_queue *\nmt76_init_queue(struct mt76_dev *dev, int qid, int idx, int n_desc,\n\t\tint ring_base, u32 flags)\n{\n\tstruct mt76_queue *hwq;\n\tint err;\n\n\thwq = devm_kzalloc(dev->dev, sizeof(*hwq), GFP_KERNEL);\n\tif (!hwq)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thwq->flags = flags;\n\n\terr = dev->queue_ops->alloc(dev, hwq, idx, n_desc, 0, ring_base);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\treturn hwq;\n}\nEXPORT_SYMBOL_GPL(mt76_init_queue);\n\nu16 mt76_calculate_default_rate(struct mt76_phy *phy,\n\t\t\t\tstruct ieee80211_vif *vif, int rateidx)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct cfg80211_chan_def *chandef = mvif->ctx ?\n\t\t\t\t\t    &mvif->ctx->def :\n\t\t\t\t\t    &phy->chandef;\n\tint offset = 0;\n\n\tif (chandef->chan->band != NL80211_BAND_2GHZ)\n\t\toffset = 4;\n\n\t \n\tif (rateidx < 0)\n\t\trateidx = 0;\n\n\trateidx += offset;\n\tif (rateidx >= ARRAY_SIZE(mt76_rates))\n\t\trateidx = offset;\n\n\treturn mt76_rates[rateidx].hw_value;\n}\nEXPORT_SYMBOL_GPL(mt76_calculate_default_rate);\n\nvoid mt76_ethtool_worker(struct mt76_ethtool_worker_info *wi,\n\t\t\t struct mt76_sta_stats *stats, bool eht)\n{\n\tint i, ei = wi->initial_stat_idx;\n\tu64 *data = wi->data;\n\n\twi->sta_count++;\n\n\tdata[ei++] += stats->tx_mode[MT_PHY_TYPE_CCK];\n\tdata[ei++] += stats->tx_mode[MT_PHY_TYPE_OFDM];\n\tdata[ei++] += stats->tx_mode[MT_PHY_TYPE_HT];\n\tdata[ei++] += stats->tx_mode[MT_PHY_TYPE_HT_GF];\n\tdata[ei++] += stats->tx_mode[MT_PHY_TYPE_VHT];\n\tdata[ei++] += stats->tx_mode[MT_PHY_TYPE_HE_SU];\n\tdata[ei++] += stats->tx_mode[MT_PHY_TYPE_HE_EXT_SU];\n\tdata[ei++] += stats->tx_mode[MT_PHY_TYPE_HE_TB];\n\tdata[ei++] += stats->tx_mode[MT_PHY_TYPE_HE_MU];\n\tif (eht) {\n\t\tdata[ei++] += stats->tx_mode[MT_PHY_TYPE_EHT_SU];\n\t\tdata[ei++] += stats->tx_mode[MT_PHY_TYPE_EHT_TRIG];\n\t\tdata[ei++] += stats->tx_mode[MT_PHY_TYPE_EHT_MU];\n\t}\n\n\tfor (i = 0; i < (ARRAY_SIZE(stats->tx_bw) - !eht); i++)\n\t\tdata[ei++] += stats->tx_bw[i];\n\n\tfor (i = 0; i < (eht ? 14 : 12); i++)\n\t\tdata[ei++] += stats->tx_mcs[i];\n\n\tfor (i = 0; i < 4; i++)\n\t\tdata[ei++] += stats->tx_nss[i];\n\n\twi->worker_stat_count = ei - wi->initial_stat_idx;\n}\nEXPORT_SYMBOL_GPL(mt76_ethtool_worker);\n\nvoid mt76_ethtool_page_pool_stats(struct mt76_dev *dev, u64 *data, int *index)\n{\n#ifdef CONFIG_PAGE_POOL_STATS\n\tstruct page_pool_stats stats = {};\n\tint i;\n\n\tmt76_for_each_q_rx(dev, i)\n\t\tpage_pool_get_stats(dev->q_rx[i].page_pool, &stats);\n\n\tpage_pool_ethtool_stats_get(data, &stats);\n\t*index += page_pool_ethtool_stats_get_count();\n#endif\n}\nEXPORT_SYMBOL_GPL(mt76_ethtool_page_pool_stats);\n\nenum mt76_dfs_state mt76_phy_dfs_state(struct mt76_phy *phy)\n{\n\tstruct ieee80211_hw *hw = phy->hw;\n\tstruct mt76_dev *dev = phy->dev;\n\n\tif (dev->region == NL80211_DFS_UNSET ||\n\t    test_bit(MT76_SCANNING, &phy->state))\n\t\treturn MT_DFS_STATE_DISABLED;\n\n\tif (!hw->conf.radar_enabled) {\n\t\tif ((hw->conf.flags & IEEE80211_CONF_MONITOR) &&\n\t\t    (phy->chandef.chan->flags & IEEE80211_CHAN_RADAR))\n\t\t\treturn MT_DFS_STATE_ACTIVE;\n\n\t\treturn MT_DFS_STATE_DISABLED;\n\t}\n\n\tif (!cfg80211_reg_can_beacon(hw->wiphy, &phy->chandef, NL80211_IFTYPE_AP))\n\t\treturn MT_DFS_STATE_CAC;\n\n\treturn MT_DFS_STATE_ACTIVE;\n}\nEXPORT_SYMBOL_GPL(mt76_phy_dfs_state);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}