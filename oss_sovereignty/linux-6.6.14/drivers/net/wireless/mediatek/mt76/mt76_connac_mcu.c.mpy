{
  "module_name": "mt76_connac_mcu.c",
  "hash_id": "2bc9450611574d17cd06167b17a4585393c5477a5d3a60e142cf1c625637a9ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt76_connac_mcu.c",
  "human_readable_source": "\n \n\n#include <linux/firmware.h>\n#include \"mt76_connac2_mac.h\"\n#include \"mt76_connac_mcu.h\"\n\nint mt76_connac_mcu_start_firmware(struct mt76_dev *dev, u32 addr, u32 option)\n{\n\tstruct {\n\t\t__le32 option;\n\t\t__le32 addr;\n\t} req = {\n\t\t.option = cpu_to_le32(option),\n\t\t.addr = cpu_to_le32(addr),\n\t};\n\n\treturn mt76_mcu_send_msg(dev, MCU_CMD(FW_START_REQ), &req,\n\t\t\t\t sizeof(req), true);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_start_firmware);\n\nint mt76_connac_mcu_patch_sem_ctrl(struct mt76_dev *dev, bool get)\n{\n\tu32 op = get ? PATCH_SEM_GET : PATCH_SEM_RELEASE;\n\tstruct {\n\t\t__le32 op;\n\t} req = {\n\t\t.op = cpu_to_le32(op),\n\t};\n\n\treturn mt76_mcu_send_msg(dev, MCU_CMD(PATCH_SEM_CONTROL),\n\t\t\t\t &req, sizeof(req), true);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_patch_sem_ctrl);\n\nint mt76_connac_mcu_start_patch(struct mt76_dev *dev)\n{\n\tstruct {\n\t\tu8 check_crc;\n\t\tu8 reserved[3];\n\t} req = {\n\t\t.check_crc = 0,\n\t};\n\n\treturn mt76_mcu_send_msg(dev, MCU_CMD(PATCH_FINISH_REQ),\n\t\t\t\t &req, sizeof(req), true);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_start_patch);\n\n#define MCU_PATCH_ADDRESS\t0x200000\n\nint mt76_connac_mcu_init_download(struct mt76_dev *dev, u32 addr, u32 len,\n\t\t\t\t  u32 mode)\n{\n\tstruct {\n\t\t__le32 addr;\n\t\t__le32 len;\n\t\t__le32 mode;\n\t} req = {\n\t\t.addr = cpu_to_le32(addr),\n\t\t.len = cpu_to_le32(len),\n\t\t.mode = cpu_to_le32(mode),\n\t};\n\tint cmd;\n\n\tif ((!is_connac_v1(dev) && addr == MCU_PATCH_ADDRESS) ||\n\t    (is_mt7921(dev) && addr == 0x900000) ||\n\t    (is_mt7996(dev) && addr == 0x900000))\n\t\tcmd = MCU_CMD(PATCH_START_REQ);\n\telse\n\t\tcmd = MCU_CMD(TARGET_ADDRESS_LEN_REQ);\n\n\treturn mt76_mcu_send_msg(dev, cmd, &req, sizeof(req), true);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_init_download);\n\nint mt76_connac_mcu_set_channel_domain(struct mt76_phy *phy)\n{\n\tint len, i, n_max_channels, n_2ch = 0, n_5ch = 0, n_6ch = 0;\n\tstruct mt76_connac_mcu_channel_domain {\n\t\tu8 alpha2[4];  \n\t\tu8 bw_2g;  \n\t\tu8 bw_5g;\n\t\tu8 bw_6g;\n\t\tu8 pad;\n\t\tu8 n_2ch;\n\t\tu8 n_5ch;\n\t\tu8 n_6ch;\n\t\tu8 pad2;\n\t} __packed hdr = {\n\t\t.bw_2g = 0,\n\t\t.bw_5g = 3,  \n\t\t.bw_6g = 3,\n\t};\n\tstruct mt76_connac_mcu_chan {\n\t\t__le16 hw_value;\n\t\t__le16 pad;\n\t\t__le32 flags;\n\t} __packed channel;\n\tstruct mt76_dev *dev = phy->dev;\n\tstruct ieee80211_channel *chan;\n\tstruct sk_buff *skb;\n\n\tn_max_channels = phy->sband_2g.sband.n_channels +\n\t\t\t phy->sband_5g.sband.n_channels +\n\t\t\t phy->sband_6g.sband.n_channels;\n\tlen = sizeof(hdr) + n_max_channels * sizeof(channel);\n\n\tskb = mt76_mcu_msg_alloc(dev, NULL, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, sizeof(hdr));\n\n\tfor (i = 0; i < phy->sband_2g.sband.n_channels; i++) {\n\t\tchan = &phy->sband_2g.sband.channels[i];\n\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\tcontinue;\n\n\t\tchannel.hw_value = cpu_to_le16(chan->hw_value);\n\t\tchannel.flags = cpu_to_le32(chan->flags);\n\t\tchannel.pad = 0;\n\n\t\tskb_put_data(skb, &channel, sizeof(channel));\n\t\tn_2ch++;\n\t}\n\tfor (i = 0; i < phy->sband_5g.sband.n_channels; i++) {\n\t\tchan = &phy->sband_5g.sband.channels[i];\n\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\tcontinue;\n\n\t\tchannel.hw_value = cpu_to_le16(chan->hw_value);\n\t\tchannel.flags = cpu_to_le32(chan->flags);\n\t\tchannel.pad = 0;\n\n\t\tskb_put_data(skb, &channel, sizeof(channel));\n\t\tn_5ch++;\n\t}\n\tfor (i = 0; i < phy->sband_6g.sband.n_channels; i++) {\n\t\tchan = &phy->sband_6g.sband.channels[i];\n\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\tcontinue;\n\n\t\tchannel.hw_value = cpu_to_le16(chan->hw_value);\n\t\tchannel.flags = cpu_to_le32(chan->flags);\n\t\tchannel.pad = 0;\n\n\t\tskb_put_data(skb, &channel, sizeof(channel));\n\t\tn_6ch++;\n\t}\n\n\tBUILD_BUG_ON(sizeof(dev->alpha2) > sizeof(hdr.alpha2));\n\tmemcpy(hdr.alpha2, dev->alpha2, sizeof(dev->alpha2));\n\thdr.n_2ch = n_2ch;\n\thdr.n_5ch = n_5ch;\n\thdr.n_6ch = n_6ch;\n\n\tmemcpy(__skb_push(skb, sizeof(hdr)), &hdr, sizeof(hdr));\n\n\treturn mt76_mcu_skb_send_msg(dev, skb, MCU_CE_CMD(SET_CHAN_DOMAIN),\n\t\t\t\t     false);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_set_channel_domain);\n\nint mt76_connac_mcu_set_mac_enable(struct mt76_dev *dev, int band, bool enable,\n\t\t\t\t   bool hdr_trans)\n{\n\tstruct {\n\t\tu8 enable;\n\t\tu8 band;\n\t\tu8 rsv[2];\n\t} __packed req_mac = {\n\t\t.enable = enable,\n\t\t.band = band,\n\t};\n\n\treturn mt76_mcu_send_msg(dev, MCU_EXT_CMD(MAC_INIT_CTRL), &req_mac,\n\t\t\t\t sizeof(req_mac), true);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_set_mac_enable);\n\nint mt76_connac_mcu_set_vif_ps(struct mt76_dev *dev, struct ieee80211_vif *vif)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct {\n\t\tu8 bss_idx;\n\t\tu8 ps_state;  \n\t} req = {\n\t\t.bss_idx = mvif->idx,\n\t\t.ps_state = vif->cfg.ps ? 2 : 0,\n\t};\n\n\tif (vif->type != NL80211_IFTYPE_STATION)\n\t\treturn -EOPNOTSUPP;\n\n\treturn mt76_mcu_send_msg(dev, MCU_CE_CMD(SET_PS_PROFILE),\n\t\t\t\t &req, sizeof(req), false);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_set_vif_ps);\n\nint mt76_connac_mcu_set_rts_thresh(struct mt76_dev *dev, u32 val, u8 band)\n{\n\tstruct {\n\t\tu8 prot_idx;\n\t\tu8 band;\n\t\tu8 rsv[2];\n\t\t__le32 len_thresh;\n\t\t__le32 pkt_thresh;\n\t} __packed req = {\n\t\t.prot_idx = 1,\n\t\t.band = band,\n\t\t.len_thresh = cpu_to_le32(val),\n\t\t.pkt_thresh = cpu_to_le32(0x2),\n\t};\n\n\treturn mt76_mcu_send_msg(dev, MCU_EXT_CMD(PROTECT_CTRL), &req,\n\t\t\t\t sizeof(req), true);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_set_rts_thresh);\n\nvoid mt76_connac_mcu_beacon_loss_iter(void *priv, u8 *mac,\n\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct mt76_connac_beacon_loss_event *event = priv;\n\n\tif (mvif->idx != event->bss_idx)\n\t\treturn;\n\n\tif (!(vif->driver_flags & IEEE80211_VIF_BEACON_FILTER))\n\t\treturn;\n\n\tieee80211_beacon_loss(vif);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_beacon_loss_iter);\n\nstruct tlv *\nmt76_connac_mcu_add_nested_tlv(struct sk_buff *skb, int tag, int len,\n\t\t\t       void *sta_ntlv, void *sta_wtbl)\n{\n\tstruct sta_ntlv_hdr *ntlv_hdr = sta_ntlv;\n\tstruct tlv *sta_hdr = sta_wtbl;\n\tstruct tlv *ptlv, tlv = {\n\t\t.tag = cpu_to_le16(tag),\n\t\t.len = cpu_to_le16(len),\n\t};\n\tu16 ntlv;\n\n\tptlv = skb_put(skb, len);\n\tmemcpy(ptlv, &tlv, sizeof(tlv));\n\n\tntlv = le16_to_cpu(ntlv_hdr->tlv_num);\n\tntlv_hdr->tlv_num = cpu_to_le16(ntlv + 1);\n\n\tif (sta_hdr) {\n\t\tlen += le16_to_cpu(sta_hdr->len);\n\t\tsta_hdr->len = cpu_to_le16(len);\n\t}\n\n\treturn ptlv;\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_add_nested_tlv);\n\nstruct sk_buff *\n__mt76_connac_mcu_alloc_sta_req(struct mt76_dev *dev, struct mt76_vif *mvif,\n\t\t\t\tstruct mt76_wcid *wcid, int len)\n{\n\tstruct sta_req_hdr hdr = {\n\t\t.bss_idx = mvif->idx,\n\t\t.muar_idx = wcid ? mvif->omac_idx : 0,\n\t\t.is_tlv_append = 1,\n\t};\n\tstruct sk_buff *skb;\n\n\tmt76_connac_mcu_get_wlan_idx(dev, wcid, &hdr.wlan_idx_lo,\n\t\t\t\t     &hdr.wlan_idx_hi);\n\tskb = mt76_mcu_msg_alloc(dev, NULL, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tskb_put_data(skb, &hdr, sizeof(hdr));\n\n\treturn skb;\n}\nEXPORT_SYMBOL_GPL(__mt76_connac_mcu_alloc_sta_req);\n\nstruct wtbl_req_hdr *\nmt76_connac_mcu_alloc_wtbl_req(struct mt76_dev *dev, struct mt76_wcid *wcid,\n\t\t\t       int cmd, void *sta_wtbl, struct sk_buff **skb)\n{\n\tstruct tlv *sta_hdr = sta_wtbl;\n\tstruct wtbl_req_hdr hdr = {\n\t\t.operation = cmd,\n\t};\n\tstruct sk_buff *nskb = *skb;\n\n\tmt76_connac_mcu_get_wlan_idx(dev, wcid, &hdr.wlan_idx_lo,\n\t\t\t\t     &hdr.wlan_idx_hi);\n\tif (!nskb) {\n\t\tnskb = mt76_mcu_msg_alloc(dev, NULL,\n\t\t\t\t\t  MT76_CONNAC_WTBL_UPDATE_MAX_SIZE);\n\t\tif (!nskb)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\t*skb = nskb;\n\t}\n\n\tif (sta_hdr)\n\t\tle16_add_cpu(&sta_hdr->len, sizeof(hdr));\n\n\treturn skb_put_data(nskb, &hdr, sizeof(hdr));\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_alloc_wtbl_req);\n\nvoid mt76_connac_mcu_bss_omac_tlv(struct sk_buff *skb,\n\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tu8 omac_idx = mvif->omac_idx;\n\tstruct bss_info_omac *omac;\n\tstruct tlv *tlv;\n\tu32 type = 0;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_AP:\n\t\tif (vif->p2p)\n\t\t\ttype = CONNECTION_P2P_GO;\n\t\telse\n\t\t\ttype = CONNECTION_INFRA_AP;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (vif->p2p)\n\t\t\ttype = CONNECTION_P2P_GC;\n\t\telse\n\t\t\ttype = CONNECTION_INFRA_STA;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\ttype = CONNECTION_IBSS_ADHOC;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, BSS_INFO_OMAC, sizeof(*omac));\n\n\tomac = (struct bss_info_omac *)tlv;\n\tomac->conn_type = cpu_to_le32(type);\n\tomac->omac_idx = mvif->omac_idx;\n\tomac->band_idx = mvif->band_idx;\n\tomac->hw_bss_idx = omac_idx > EXT_BSSID_START ? HW_BSSID_0 : omac_idx;\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_bss_omac_tlv);\n\nvoid mt76_connac_mcu_sta_basic_tlv(struct mt76_dev *dev, struct sk_buff *skb,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   bool enable, bool newly)\n{\n\tstruct sta_rec_basic *basic;\n\tstruct tlv *tlv;\n\tint conn_type;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_BASIC, sizeof(*basic));\n\n\tbasic = (struct sta_rec_basic *)tlv;\n\tbasic->extra_info = cpu_to_le16(EXTRA_INFO_VER);\n\n\tif (enable) {\n\t\tif (newly)\n\t\t\tbasic->extra_info |= cpu_to_le16(EXTRA_INFO_NEW);\n\t\tbasic->conn_state = CONN_STATE_PORT_SECURE;\n\t} else {\n\t\tbasic->conn_state = CONN_STATE_DISCONNECT;\n\t}\n\n\tif (!sta) {\n\t\tbasic->conn_type = cpu_to_le32(CONNECTION_INFRA_BC);\n\t\teth_broadcast_addr(basic->peer_addr);\n\t\treturn;\n\t}\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_AP:\n\t\tif (vif->p2p && !is_mt7921(dev))\n\t\t\tconn_type = CONNECTION_P2P_GC;\n\t\telse\n\t\t\tconn_type = CONNECTION_INFRA_STA;\n\t\tbasic->conn_type = cpu_to_le32(conn_type);\n\t\tbasic->aid = cpu_to_le16(sta->aid);\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (vif->p2p && !is_mt7921(dev))\n\t\t\tconn_type = CONNECTION_P2P_GO;\n\t\telse\n\t\t\tconn_type = CONNECTION_INFRA_AP;\n\t\tbasic->conn_type = cpu_to_le32(conn_type);\n\t\tbasic->aid = cpu_to_le16(vif->cfg.aid);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tbasic->conn_type = cpu_to_le32(CONNECTION_IBSS_ADHOC);\n\t\tbasic->aid = cpu_to_le16(sta->aid);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tmemcpy(basic->peer_addr, sta->addr, ETH_ALEN);\n\tbasic->qos = sta->wme;\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_sta_basic_tlv);\n\nvoid mt76_connac_mcu_sta_uapsd(struct sk_buff *skb, struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_sta *sta)\n{\n\tstruct sta_rec_uapsd *uapsd;\n\tstruct tlv *tlv;\n\n\tif (vif->type != NL80211_IFTYPE_AP || !sta->wme)\n\t\treturn;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_APPS, sizeof(*uapsd));\n\tuapsd = (struct sta_rec_uapsd *)tlv;\n\n\tif (sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VO) {\n\t\tuapsd->dac_map |= BIT(3);\n\t\tuapsd->tac_map |= BIT(3);\n\t}\n\tif (sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VI) {\n\t\tuapsd->dac_map |= BIT(2);\n\t\tuapsd->tac_map |= BIT(2);\n\t}\n\tif (sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_BE) {\n\t\tuapsd->dac_map |= BIT(1);\n\t\tuapsd->tac_map |= BIT(1);\n\t}\n\tif (sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_BK) {\n\t\tuapsd->dac_map |= BIT(0);\n\t\tuapsd->tac_map |= BIT(0);\n\t}\n\tuapsd->max_sp = sta->max_sp;\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_sta_uapsd);\n\nvoid mt76_connac_mcu_wtbl_hdr_trans_tlv(struct sk_buff *skb,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tstruct mt76_wcid *wcid,\n\t\t\t\t\tvoid *sta_wtbl, void *wtbl_tlv)\n{\n\tstruct wtbl_hdr_trans *htr;\n\tstruct tlv *tlv;\n\n\ttlv = mt76_connac_mcu_add_nested_tlv(skb, WTBL_HDR_TRANS,\n\t\t\t\t\t     sizeof(*htr),\n\t\t\t\t\t     wtbl_tlv, sta_wtbl);\n\thtr = (struct wtbl_hdr_trans *)tlv;\n\thtr->no_rx_trans = true;\n\n\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\thtr->to_ds = true;\n\telse\n\t\thtr->from_ds = true;\n\n\tif (!wcid)\n\t\treturn;\n\n\thtr->no_rx_trans = !test_bit(MT_WCID_FLAG_HDR_TRANS, &wcid->flags);\n\tif (test_bit(MT_WCID_FLAG_4ADDR, &wcid->flags)) {\n\t\thtr->to_ds = true;\n\t\thtr->from_ds = true;\n\t}\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_wtbl_hdr_trans_tlv);\n\nint mt76_connac_mcu_sta_update_hdr_trans(struct mt76_dev *dev,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t struct mt76_wcid *wcid, int cmd)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct wtbl_req_hdr *wtbl_hdr;\n\tstruct tlv *sta_wtbl;\n\tstruct sk_buff *skb;\n\n\tskb = mt76_connac_mcu_alloc_sta_req(dev, mvif, wcid);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tsta_wtbl = mt76_connac_mcu_add_tlv(skb, STA_REC_WTBL,\n\t\t\t\t\t   sizeof(struct tlv));\n\n\twtbl_hdr = mt76_connac_mcu_alloc_wtbl_req(dev, wcid, WTBL_SET,\n\t\t\t\t\t\t  sta_wtbl, &skb);\n\tif (IS_ERR(wtbl_hdr))\n\t\treturn PTR_ERR(wtbl_hdr);\n\n\tmt76_connac_mcu_wtbl_hdr_trans_tlv(skb, vif, wcid, sta_wtbl, wtbl_hdr);\n\n\treturn mt76_mcu_skb_send_msg(dev, skb, cmd, true);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_sta_update_hdr_trans);\n\nint mt76_connac_mcu_wtbl_update_hdr_trans(struct mt76_dev *dev,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  struct ieee80211_sta *sta)\n{\n\tstruct mt76_wcid *wcid = (struct mt76_wcid *)sta->drv_priv;\n\tstruct wtbl_req_hdr *wtbl_hdr;\n\tstruct sk_buff *skb = NULL;\n\n\twtbl_hdr = mt76_connac_mcu_alloc_wtbl_req(dev, wcid, WTBL_SET, NULL,\n\t\t\t\t\t\t  &skb);\n\tif (IS_ERR(wtbl_hdr))\n\t\treturn PTR_ERR(wtbl_hdr);\n\n\tmt76_connac_mcu_wtbl_hdr_trans_tlv(skb, vif, wcid, NULL, wtbl_hdr);\n\n\treturn mt76_mcu_skb_send_msg(dev, skb, MCU_EXT_CMD(WTBL_UPDATE), true);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_wtbl_update_hdr_trans);\n\nvoid mt76_connac_mcu_wtbl_generic_tlv(struct mt76_dev *dev,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      void *sta_wtbl, void *wtbl_tlv)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct wtbl_generic *generic;\n\tstruct wtbl_rx *rx;\n\tstruct wtbl_spe *spe;\n\tstruct tlv *tlv;\n\n\ttlv = mt76_connac_mcu_add_nested_tlv(skb, WTBL_GENERIC,\n\t\t\t\t\t     sizeof(*generic),\n\t\t\t\t\t     wtbl_tlv, sta_wtbl);\n\n\tgeneric = (struct wtbl_generic *)tlv;\n\n\tif (sta) {\n\t\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\t\tgeneric->partial_aid = cpu_to_le16(vif->cfg.aid);\n\t\telse\n\t\t\tgeneric->partial_aid = cpu_to_le16(sta->aid);\n\t\tmemcpy(generic->peer_addr, sta->addr, ETH_ALEN);\n\t\tgeneric->muar_idx = mvif->omac_idx;\n\t\tgeneric->qos = sta->wme;\n\t} else {\n\t\tif (!is_connac_v1(dev) && vif->type == NL80211_IFTYPE_STATION)\n\t\t\tmemcpy(generic->peer_addr, vif->bss_conf.bssid,\n\t\t\t       ETH_ALEN);\n\t\telse\n\t\t\teth_broadcast_addr(generic->peer_addr);\n\n\t\tgeneric->muar_idx = 0xe;\n\t}\n\n\ttlv = mt76_connac_mcu_add_nested_tlv(skb, WTBL_RX, sizeof(*rx),\n\t\t\t\t\t     wtbl_tlv, sta_wtbl);\n\n\trx = (struct wtbl_rx *)tlv;\n\trx->rca1 = sta ? vif->type != NL80211_IFTYPE_AP : 1;\n\trx->rca2 = 1;\n\trx->rv = 1;\n\n\tif (!is_connac_v1(dev))\n\t\treturn;\n\n\ttlv = mt76_connac_mcu_add_nested_tlv(skb, WTBL_SPE, sizeof(*spe),\n\t\t\t\t\t     wtbl_tlv, sta_wtbl);\n\tspe = (struct wtbl_spe *)tlv;\n\tspe->spe_idx = 24;\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_wtbl_generic_tlv);\n\nstatic void\nmt76_connac_mcu_sta_amsdu_tlv(struct sk_buff *skb, struct ieee80211_sta *sta,\n\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct mt76_wcid *wcid = (struct mt76_wcid *)sta->drv_priv;\n\tstruct sta_rec_amsdu *amsdu;\n\tstruct tlv *tlv;\n\n\tif (vif->type != NL80211_IFTYPE_AP &&\n\t    vif->type != NL80211_IFTYPE_STATION)\n\t\treturn;\n\n\tif (!sta->deflink.agg.max_amsdu_len)\n\t\treturn;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_HW_AMSDU, sizeof(*amsdu));\n\tamsdu = (struct sta_rec_amsdu *)tlv;\n\tamsdu->max_amsdu_num = 8;\n\tamsdu->amsdu_en = true;\n\tamsdu->max_mpdu_size = sta->deflink.agg.max_amsdu_len >=\n\t\t\t       IEEE80211_MAX_MPDU_LEN_VHT_7991;\n\n\twcid->amsdu = true;\n}\n\n#define HE_PHY(p, c)\tu8_get_bits(c, IEEE80211_HE_PHY_##p)\n#define HE_MAC(m, c)\tu8_get_bits(c, IEEE80211_HE_MAC_##m)\nstatic void\nmt76_connac_mcu_sta_he_tlv(struct sk_buff *skb, struct ieee80211_sta *sta)\n{\n\tstruct ieee80211_sta_he_cap *he_cap = &sta->deflink.he_cap;\n\tstruct ieee80211_he_cap_elem *elem = &he_cap->he_cap_elem;\n\tstruct sta_rec_he *he;\n\tstruct tlv *tlv;\n\tu32 cap = 0;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_HE, sizeof(*he));\n\n\the = (struct sta_rec_he *)tlv;\n\n\tif (elem->mac_cap_info[0] & IEEE80211_HE_MAC_CAP0_HTC_HE)\n\t\tcap |= STA_REC_HE_CAP_HTC;\n\n\tif (elem->mac_cap_info[2] & IEEE80211_HE_MAC_CAP2_BSR)\n\t\tcap |= STA_REC_HE_CAP_BSR;\n\n\tif (elem->mac_cap_info[3] & IEEE80211_HE_MAC_CAP3_OMI_CONTROL)\n\t\tcap |= STA_REC_HE_CAP_OM;\n\n\tif (elem->mac_cap_info[4] & IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU)\n\t\tcap |= STA_REC_HE_CAP_AMSDU_IN_AMPDU;\n\n\tif (elem->mac_cap_info[4] & IEEE80211_HE_MAC_CAP4_BQR)\n\t\tcap |= STA_REC_HE_CAP_BQR;\n\n\tif (elem->phy_cap_info[0] &\n\t    (IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_RU_MAPPING_IN_2G |\n\t     IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_RU_MAPPING_IN_5G))\n\t\tcap |= STA_REC_HE_CAP_BW20_RU242_SUPPORT;\n\n\tif (elem->phy_cap_info[1] &\n\t    IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD)\n\t\tcap |= STA_REC_HE_CAP_LDPC;\n\n\tif (elem->phy_cap_info[1] &\n\t    IEEE80211_HE_PHY_CAP1_HE_LTF_AND_GI_FOR_HE_PPDUS_0_8US)\n\t\tcap |= STA_REC_HE_CAP_SU_PPDU_1LTF_8US_GI;\n\n\tif (elem->phy_cap_info[2] &\n\t    IEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US)\n\t\tcap |= STA_REC_HE_CAP_NDP_4LTF_3DOT2MS_GI;\n\n\tif (elem->phy_cap_info[2] &\n\t    IEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ)\n\t\tcap |= STA_REC_HE_CAP_LE_EQ_80M_TX_STBC;\n\n\tif (elem->phy_cap_info[2] &\n\t    IEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ)\n\t\tcap |= STA_REC_HE_CAP_LE_EQ_80M_RX_STBC;\n\n\tif (elem->phy_cap_info[6] &\n\t    IEEE80211_HE_PHY_CAP6_PARTIAL_BW_EXT_RANGE)\n\t\tcap |= STA_REC_HE_CAP_PARTIAL_BW_EXT_RANGE;\n\n\tif (elem->phy_cap_info[7] &\n\t    IEEE80211_HE_PHY_CAP7_HE_SU_MU_PPDU_4XLTF_AND_08_US_GI)\n\t\tcap |= STA_REC_HE_CAP_SU_MU_PPDU_4LTF_8US_GI;\n\n\tif (elem->phy_cap_info[7] &\n\t    IEEE80211_HE_PHY_CAP7_STBC_TX_ABOVE_80MHZ)\n\t\tcap |= STA_REC_HE_CAP_GT_80M_TX_STBC;\n\n\tif (elem->phy_cap_info[7] &\n\t    IEEE80211_HE_PHY_CAP7_STBC_RX_ABOVE_80MHZ)\n\t\tcap |= STA_REC_HE_CAP_GT_80M_RX_STBC;\n\n\tif (elem->phy_cap_info[8] &\n\t    IEEE80211_HE_PHY_CAP8_HE_ER_SU_PPDU_4XLTF_AND_08_US_GI)\n\t\tcap |= STA_REC_HE_CAP_ER_SU_PPDU_4LTF_8US_GI;\n\n\tif (elem->phy_cap_info[8] &\n\t    IEEE80211_HE_PHY_CAP8_HE_ER_SU_1XLTF_AND_08_US_GI)\n\t\tcap |= STA_REC_HE_CAP_ER_SU_PPDU_1LTF_8US_GI;\n\n\tif (elem->phy_cap_info[9] &\n\t    IEEE80211_HE_PHY_CAP9_NON_TRIGGERED_CQI_FEEDBACK)\n\t\tcap |= STA_REC_HE_CAP_TRIG_CQI_FK;\n\n\tif (elem->phy_cap_info[9] &\n\t    IEEE80211_HE_PHY_CAP9_TX_1024_QAM_LESS_THAN_242_TONE_RU)\n\t\tcap |= STA_REC_HE_CAP_TX_1024QAM_UNDER_RU242;\n\n\tif (elem->phy_cap_info[9] &\n\t    IEEE80211_HE_PHY_CAP9_RX_1024_QAM_LESS_THAN_242_TONE_RU)\n\t\tcap |= STA_REC_HE_CAP_RX_1024QAM_UNDER_RU242;\n\n\the->he_cap = cpu_to_le32(cap);\n\n\tswitch (sta->deflink.bandwidth) {\n\tcase IEEE80211_STA_RX_BW_160:\n\t\tif (elem->phy_cap_info[0] &\n\t\t    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G)\n\t\t\the->max_nss_mcs[CMD_HE_MCS_BW8080] =\n\t\t\t\the_cap->he_mcs_nss_supp.rx_mcs_80p80;\n\n\t\the->max_nss_mcs[CMD_HE_MCS_BW160] =\n\t\t\t\the_cap->he_mcs_nss_supp.rx_mcs_160;\n\t\tfallthrough;\n\tdefault:\n\t\the->max_nss_mcs[CMD_HE_MCS_BW80] =\n\t\t\t\the_cap->he_mcs_nss_supp.rx_mcs_80;\n\t\tbreak;\n\t}\n\n\the->t_frame_dur =\n\t\tHE_MAC(CAP1_TF_MAC_PAD_DUR_MASK, elem->mac_cap_info[1]);\n\the->max_ampdu_exp =\n\t\tHE_MAC(CAP3_MAX_AMPDU_LEN_EXP_MASK, elem->mac_cap_info[3]);\n\n\the->bw_set =\n\t\tHE_PHY(CAP0_CHANNEL_WIDTH_SET_MASK, elem->phy_cap_info[0]);\n\the->device_class =\n\t\tHE_PHY(CAP1_DEVICE_CLASS_A, elem->phy_cap_info[1]);\n\the->punc_pream_rx =\n\t\tHE_PHY(CAP1_PREAMBLE_PUNC_RX_MASK, elem->phy_cap_info[1]);\n\n\the->dcm_tx_mode =\n\t\tHE_PHY(CAP3_DCM_MAX_CONST_TX_MASK, elem->phy_cap_info[3]);\n\the->dcm_tx_max_nss =\n\t\tHE_PHY(CAP3_DCM_MAX_TX_NSS_2, elem->phy_cap_info[3]);\n\the->dcm_rx_mode =\n\t\tHE_PHY(CAP3_DCM_MAX_CONST_RX_MASK, elem->phy_cap_info[3]);\n\the->dcm_rx_max_nss =\n\t\tHE_PHY(CAP3_DCM_MAX_RX_NSS_2, elem->phy_cap_info[3]);\n\the->dcm_rx_max_nss =\n\t\tHE_PHY(CAP8_DCM_MAX_RU_MASK, elem->phy_cap_info[8]);\n\n\the->pkt_ext = 2;\n}\n\nstatic void\nmt76_connac_mcu_sta_he_tlv_v2(struct sk_buff *skb, struct ieee80211_sta *sta)\n{\n\tstruct ieee80211_sta_he_cap *he_cap = &sta->deflink.he_cap;\n\tstruct ieee80211_he_cap_elem *elem = &he_cap->he_cap_elem;\n\tstruct sta_rec_he_v2 *he;\n\tstruct tlv *tlv;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_HE_V2, sizeof(*he));\n\n\the = (struct sta_rec_he_v2 *)tlv;\n\tmemcpy(he->he_phy_cap, elem->phy_cap_info, sizeof(he->he_phy_cap));\n\tmemcpy(he->he_mac_cap, elem->mac_cap_info, sizeof(he->he_mac_cap));\n\n\tswitch (sta->deflink.bandwidth) {\n\tcase IEEE80211_STA_RX_BW_160:\n\t\tif (elem->phy_cap_info[0] &\n\t\t    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G)\n\t\t\the->max_nss_mcs[CMD_HE_MCS_BW8080] =\n\t\t\t\the_cap->he_mcs_nss_supp.rx_mcs_80p80;\n\n\t\the->max_nss_mcs[CMD_HE_MCS_BW160] =\n\t\t\t\the_cap->he_mcs_nss_supp.rx_mcs_160;\n\t\tfallthrough;\n\tdefault:\n\t\the->max_nss_mcs[CMD_HE_MCS_BW80] =\n\t\t\t\the_cap->he_mcs_nss_supp.rx_mcs_80;\n\t\tbreak;\n\t}\n\n\the->pkt_ext = IEEE80211_HE_PHY_CAP9_NOMINAL_PKT_PADDING_16US;\n}\n\nstatic u8\nmt76_connac_get_phy_mode_v2(struct mt76_phy *mphy, struct ieee80211_vif *vif,\n\t\t\t    enum nl80211_band band, struct ieee80211_sta *sta)\n{\n\tstruct ieee80211_sta_ht_cap *ht_cap;\n\tstruct ieee80211_sta_vht_cap *vht_cap;\n\tconst struct ieee80211_sta_he_cap *he_cap;\n\tu8 mode = 0;\n\n\tif (sta) {\n\t\tht_cap = &sta->deflink.ht_cap;\n\t\tvht_cap = &sta->deflink.vht_cap;\n\t\the_cap = &sta->deflink.he_cap;\n\t} else {\n\t\tstruct ieee80211_supported_band *sband;\n\n\t\tsband = mphy->hw->wiphy->bands[band];\n\t\tht_cap = &sband->ht_cap;\n\t\tvht_cap = &sband->vht_cap;\n\t\the_cap = ieee80211_get_he_iftype_cap(sband, vif->type);\n\t}\n\n\tif (band == NL80211_BAND_2GHZ) {\n\t\tmode |= PHY_TYPE_BIT_HR_DSSS | PHY_TYPE_BIT_ERP;\n\n\t\tif (ht_cap->ht_supported)\n\t\t\tmode |= PHY_TYPE_BIT_HT;\n\n\t\tif (he_cap && he_cap->has_he)\n\t\t\tmode |= PHY_TYPE_BIT_HE;\n\t} else if (band == NL80211_BAND_5GHZ || band == NL80211_BAND_6GHZ) {\n\t\tmode |= PHY_TYPE_BIT_OFDM;\n\n\t\tif (ht_cap->ht_supported)\n\t\t\tmode |= PHY_TYPE_BIT_HT;\n\n\t\tif (vht_cap->vht_supported)\n\t\t\tmode |= PHY_TYPE_BIT_VHT;\n\n\t\tif (he_cap && he_cap->has_he)\n\t\t\tmode |= PHY_TYPE_BIT_HE;\n\t}\n\n\treturn mode;\n}\n\nvoid mt76_connac_mcu_sta_tlv(struct mt76_phy *mphy, struct sk_buff *skb,\n\t\t\t     struct ieee80211_sta *sta,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     u8 rcpi, u8 sta_state)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct cfg80211_chan_def *chandef = mvif->ctx ?\n\t\t\t\t\t    &mvif->ctx->def : &mphy->chandef;\n\tenum nl80211_band band = chandef->chan->band;\n\tstruct mt76_dev *dev = mphy->dev;\n\tstruct sta_rec_ra_info *ra_info;\n\tstruct sta_rec_state *state;\n\tstruct sta_rec_phy *phy;\n\tstruct tlv *tlv;\n\tu16 supp_rates;\n\n\t \n\tif (sta->deflink.ht_cap.ht_supported) {\n\t\tstruct sta_rec_ht *ht;\n\n\t\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_HT, sizeof(*ht));\n\t\tht = (struct sta_rec_ht *)tlv;\n\t\tht->ht_cap = cpu_to_le16(sta->deflink.ht_cap.cap);\n\t}\n\n\t \n\tif (sta->deflink.vht_cap.vht_supported) {\n\t\tstruct sta_rec_vht *vht;\n\t\tint len;\n\n\t\tlen = is_mt7921(dev) ? sizeof(*vht) : sizeof(*vht) - 4;\n\t\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_VHT, len);\n\t\tvht = (struct sta_rec_vht *)tlv;\n\t\tvht->vht_cap = cpu_to_le32(sta->deflink.vht_cap.cap);\n\t\tvht->vht_rx_mcs_map = sta->deflink.vht_cap.vht_mcs.rx_mcs_map;\n\t\tvht->vht_tx_mcs_map = sta->deflink.vht_cap.vht_mcs.tx_mcs_map;\n\t}\n\n\t \n\tmt76_connac_mcu_sta_uapsd(skb, vif, sta);\n\n\tif (!is_mt7921(dev))\n\t\treturn;\n\n\tif (sta->deflink.ht_cap.ht_supported || sta->deflink.he_cap.has_he)\n\t\tmt76_connac_mcu_sta_amsdu_tlv(skb, sta, vif);\n\n\t \n\tif (sta->deflink.he_cap.has_he) {\n\t\tmt76_connac_mcu_sta_he_tlv(skb, sta);\n\t\tmt76_connac_mcu_sta_he_tlv_v2(skb, sta);\n\t\tif (band == NL80211_BAND_6GHZ &&\n\t\t    sta_state == MT76_STA_INFO_STATE_ASSOC) {\n\t\t\tstruct sta_rec_he_6g_capa *he_6g_capa;\n\n\t\t\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_HE_6G,\n\t\t\t\t\t\t      sizeof(*he_6g_capa));\n\t\t\the_6g_capa = (struct sta_rec_he_6g_capa *)tlv;\n\t\t\the_6g_capa->capa = sta->deflink.he_6ghz_capa.capa;\n\t\t}\n\t}\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_PHY, sizeof(*phy));\n\tphy = (struct sta_rec_phy *)tlv;\n\tphy->phy_type = mt76_connac_get_phy_mode_v2(mphy, vif, band, sta);\n\tphy->basic_rate = cpu_to_le16((u16)vif->bss_conf.basic_rates);\n\tphy->rcpi = rcpi;\n\tphy->ampdu = FIELD_PREP(IEEE80211_HT_AMPDU_PARM_FACTOR,\n\t\t\t\tsta->deflink.ht_cap.ampdu_factor) |\n\t\t     FIELD_PREP(IEEE80211_HT_AMPDU_PARM_DENSITY,\n\t\t\t\tsta->deflink.ht_cap.ampdu_density);\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_RA, sizeof(*ra_info));\n\tra_info = (struct sta_rec_ra_info *)tlv;\n\n\tsupp_rates = sta->deflink.supp_rates[band];\n\tif (band == NL80211_BAND_2GHZ)\n\t\tsupp_rates = FIELD_PREP(RA_LEGACY_OFDM, supp_rates >> 4) |\n\t\t\t     FIELD_PREP(RA_LEGACY_CCK, supp_rates & 0xf);\n\telse\n\t\tsupp_rates = FIELD_PREP(RA_LEGACY_OFDM, supp_rates);\n\n\tra_info->legacy = cpu_to_le16(supp_rates);\n\n\tif (sta->deflink.ht_cap.ht_supported)\n\t\tmemcpy(ra_info->rx_mcs_bitmask,\n\t\t       sta->deflink.ht_cap.mcs.rx_mask,\n\t\t       HT_MCS_MASK_NUM);\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_STATE, sizeof(*state));\n\tstate = (struct sta_rec_state *)tlv;\n\tstate->state = sta_state;\n\n\tif (sta->deflink.vht_cap.vht_supported) {\n\t\tstate->vht_opmode = sta->deflink.bandwidth;\n\t\tstate->vht_opmode |= (sta->deflink.rx_nss - 1) <<\n\t\t\tIEEE80211_OPMODE_NOTIF_RX_NSS_SHIFT;\n\t}\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_sta_tlv);\n\nvoid mt76_connac_mcu_wtbl_smps_tlv(struct sk_buff *skb,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   void *sta_wtbl, void *wtbl_tlv)\n{\n\tstruct wtbl_smps *smps;\n\tstruct tlv *tlv;\n\n\ttlv = mt76_connac_mcu_add_nested_tlv(skb, WTBL_SMPS, sizeof(*smps),\n\t\t\t\t\t     wtbl_tlv, sta_wtbl);\n\tsmps = (struct wtbl_smps *)tlv;\n\tsmps->smps = (sta->deflink.smps_mode == IEEE80211_SMPS_DYNAMIC);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_wtbl_smps_tlv);\n\nvoid mt76_connac_mcu_wtbl_ht_tlv(struct mt76_dev *dev, struct sk_buff *skb,\n\t\t\t\t struct ieee80211_sta *sta, void *sta_wtbl,\n\t\t\t\t void *wtbl_tlv, bool ht_ldpc, bool vht_ldpc)\n{\n\tstruct wtbl_ht *ht = NULL;\n\tstruct tlv *tlv;\n\tu32 flags = 0;\n\n\tif (sta->deflink.ht_cap.ht_supported || sta->deflink.he_6ghz_capa.capa) {\n\t\ttlv = mt76_connac_mcu_add_nested_tlv(skb, WTBL_HT, sizeof(*ht),\n\t\t\t\t\t\t     wtbl_tlv, sta_wtbl);\n\t\tht = (struct wtbl_ht *)tlv;\n\t\tht->ldpc = ht_ldpc &&\n\t\t\t   !!(sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_LDPC_CODING);\n\n\t\tif (sta->deflink.ht_cap.ht_supported) {\n\t\t\tht->af = sta->deflink.ht_cap.ampdu_factor;\n\t\t\tht->mm = sta->deflink.ht_cap.ampdu_density;\n\t\t} else {\n\t\t\tht->af = le16_get_bits(sta->deflink.he_6ghz_capa.capa,\n\t\t\t\t\t       IEEE80211_HE_6GHZ_CAP_MAX_AMPDU_LEN_EXP);\n\t\t\tht->mm = le16_get_bits(sta->deflink.he_6ghz_capa.capa,\n\t\t\t\t\t       IEEE80211_HE_6GHZ_CAP_MIN_MPDU_START);\n\t\t}\n\n\t\tht->ht = true;\n\t}\n\n\tif (sta->deflink.vht_cap.vht_supported || sta->deflink.he_6ghz_capa.capa) {\n\t\tstruct wtbl_vht *vht;\n\t\tu8 af;\n\n\t\ttlv = mt76_connac_mcu_add_nested_tlv(skb, WTBL_VHT,\n\t\t\t\t\t\t     sizeof(*vht), wtbl_tlv,\n\t\t\t\t\t\t     sta_wtbl);\n\t\tvht = (struct wtbl_vht *)tlv;\n\t\tvht->ldpc = vht_ldpc &&\n\t\t\t    !!(sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_RXLDPC);\n\t\tvht->vht = true;\n\n\t\taf = FIELD_GET(IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK,\n\t\t\t       sta->deflink.vht_cap.cap);\n\t\tif (ht)\n\t\t\tht->af = max(ht->af, af);\n\t}\n\n\tmt76_connac_mcu_wtbl_smps_tlv(skb, sta, sta_wtbl, wtbl_tlv);\n\n\tif (is_connac_v1(dev) && sta->deflink.ht_cap.ht_supported) {\n\t\t \n\t\tu32 msk = MT_WTBL_W5_SHORT_GI_20 | MT_WTBL_W5_SHORT_GI_40 |\n\t\t\t  MT_WTBL_W5_SHORT_GI_80 | MT_WTBL_W5_SHORT_GI_160;\n\t\tstruct wtbl_raw *raw;\n\n\t\ttlv = mt76_connac_mcu_add_nested_tlv(skb, WTBL_RAW_DATA,\n\t\t\t\t\t\t     sizeof(*raw), wtbl_tlv,\n\t\t\t\t\t\t     sta_wtbl);\n\n\t\tif (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_20)\n\t\t\tflags |= MT_WTBL_W5_SHORT_GI_20;\n\t\tif (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_40)\n\t\t\tflags |= MT_WTBL_W5_SHORT_GI_40;\n\n\t\tif (sta->deflink.vht_cap.vht_supported) {\n\t\t\tif (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_SHORT_GI_80)\n\t\t\t\tflags |= MT_WTBL_W5_SHORT_GI_80;\n\t\t\tif (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_SHORT_GI_160)\n\t\t\t\tflags |= MT_WTBL_W5_SHORT_GI_160;\n\t\t}\n\t\traw = (struct wtbl_raw *)tlv;\n\t\traw->val = cpu_to_le32(flags);\n\t\traw->msk = cpu_to_le32(~msk);\n\t\traw->wtbl_idx = 1;\n\t\traw->dw = 5;\n\t}\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_wtbl_ht_tlv);\n\nint mt76_connac_mcu_sta_cmd(struct mt76_phy *phy,\n\t\t\t    struct mt76_sta_cmd_info *info)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)info->vif->drv_priv;\n\tstruct mt76_dev *dev = phy->dev;\n\tstruct wtbl_req_hdr *wtbl_hdr;\n\tstruct tlv *sta_wtbl;\n\tstruct sk_buff *skb;\n\n\tskb = mt76_connac_mcu_alloc_sta_req(dev, mvif, info->wcid);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tif (info->sta || !info->offload_fw)\n\t\tmt76_connac_mcu_sta_basic_tlv(dev, skb, info->vif, info->sta,\n\t\t\t\t\t      info->enable, info->newly);\n\tif (info->sta && info->enable)\n\t\tmt76_connac_mcu_sta_tlv(phy, skb, info->sta,\n\t\t\t\t\tinfo->vif, info->rcpi,\n\t\t\t\t\tinfo->state);\n\n\tsta_wtbl = mt76_connac_mcu_add_tlv(skb, STA_REC_WTBL,\n\t\t\t\t\t   sizeof(struct tlv));\n\n\twtbl_hdr = mt76_connac_mcu_alloc_wtbl_req(dev, info->wcid,\n\t\t\t\t\t\t  WTBL_RESET_AND_SET,\n\t\t\t\t\t\t  sta_wtbl, &skb);\n\tif (IS_ERR(wtbl_hdr))\n\t\treturn PTR_ERR(wtbl_hdr);\n\n\tif (info->enable) {\n\t\tmt76_connac_mcu_wtbl_generic_tlv(dev, skb, info->vif,\n\t\t\t\t\t\t info->sta, sta_wtbl,\n\t\t\t\t\t\t wtbl_hdr);\n\t\tmt76_connac_mcu_wtbl_hdr_trans_tlv(skb, info->vif, info->wcid,\n\t\t\t\t\t\t   sta_wtbl, wtbl_hdr);\n\t\tif (info->sta)\n\t\t\tmt76_connac_mcu_wtbl_ht_tlv(dev, skb, info->sta,\n\t\t\t\t\t\t    sta_wtbl, wtbl_hdr,\n\t\t\t\t\t\t    true, true);\n\t}\n\n\treturn mt76_mcu_skb_send_msg(dev, skb, info->cmd, true);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_sta_cmd);\n\nvoid mt76_connac_mcu_wtbl_ba_tlv(struct mt76_dev *dev, struct sk_buff *skb,\n\t\t\t\t struct ieee80211_ampdu_params *params,\n\t\t\t\t bool enable, bool tx, void *sta_wtbl,\n\t\t\t\t void *wtbl_tlv)\n{\n\tstruct wtbl_ba *ba;\n\tstruct tlv *tlv;\n\n\ttlv = mt76_connac_mcu_add_nested_tlv(skb, WTBL_BA, sizeof(*ba),\n\t\t\t\t\t     wtbl_tlv, sta_wtbl);\n\n\tba = (struct wtbl_ba *)tlv;\n\tba->tid = params->tid;\n\n\tif (tx) {\n\t\tba->ba_type = MT_BA_TYPE_ORIGINATOR;\n\t\tba->sn = enable ? cpu_to_le16(params->ssn) : 0;\n\t\tba->ba_winsize = enable ? cpu_to_le16(params->buf_size) : 0;\n\t\tba->ba_en = enable;\n\t} else {\n\t\tmemcpy(ba->peer_addr, params->sta->addr, ETH_ALEN);\n\t\tba->ba_type = MT_BA_TYPE_RECIPIENT;\n\t\tba->rst_ba_tid = params->tid;\n\t\tba->rst_ba_sel = RST_BA_MAC_TID_MATCH;\n\t\tba->rst_ba_sb = 1;\n\t}\n\n\tif (!is_connac_v1(dev)) {\n\t\tba->ba_winsize = enable ? cpu_to_le16(params->buf_size) : 0;\n\t\treturn;\n\t}\n\n\tif (enable && tx) {\n\t\tstatic const u8 ba_range[] = { 4, 8, 12, 24, 36, 48, 54, 64 };\n\t\tint i;\n\n\t\tfor (i = 7; i > 0; i--) {\n\t\t\tif (params->buf_size >= ba_range[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tba->ba_winsize_idx = i;\n\t}\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_wtbl_ba_tlv);\n\nint mt76_connac_mcu_uni_add_dev(struct mt76_phy *phy,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct mt76_wcid *wcid,\n\t\t\t\tbool enable)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct mt76_dev *dev = phy->dev;\n\tstruct {\n\t\tstruct {\n\t\t\tu8 omac_idx;\n\t\t\tu8 band_idx;\n\t\t\t__le16 pad;\n\t\t} __packed hdr;\n\t\tstruct req_tlv {\n\t\t\t__le16 tag;\n\t\t\t__le16 len;\n\t\t\tu8 active;\n\t\t\tu8 pad;\n\t\t\tu8 omac_addr[ETH_ALEN];\n\t\t} __packed tlv;\n\t} dev_req = {\n\t\t.hdr = {\n\t\t\t.omac_idx = mvif->omac_idx,\n\t\t\t.band_idx = mvif->band_idx,\n\t\t},\n\t\t.tlv = {\n\t\t\t.tag = cpu_to_le16(DEV_INFO_ACTIVE),\n\t\t\t.len = cpu_to_le16(sizeof(struct req_tlv)),\n\t\t\t.active = enable,\n\t\t},\n\t};\n\tstruct {\n\t\tstruct {\n\t\t\tu8 bss_idx;\n\t\t\tu8 pad[3];\n\t\t} __packed hdr;\n\t\tstruct mt76_connac_bss_basic_tlv basic;\n\t} basic_req = {\n\t\t.hdr = {\n\t\t\t.bss_idx = mvif->idx,\n\t\t},\n\t\t.basic = {\n\t\t\t.tag = cpu_to_le16(UNI_BSS_INFO_BASIC),\n\t\t\t.len = cpu_to_le16(sizeof(struct mt76_connac_bss_basic_tlv)),\n\t\t\t.omac_idx = mvif->omac_idx,\n\t\t\t.band_idx = mvif->band_idx,\n\t\t\t.wmm_idx = mvif->wmm_idx,\n\t\t\t.active = enable,\n\t\t\t.bmc_tx_wlan_idx = cpu_to_le16(wcid->idx),\n\t\t\t.sta_idx = cpu_to_le16(wcid->idx),\n\t\t\t.conn_state = 1,\n\t\t},\n\t};\n\tint err, idx, cmd, len;\n\tvoid *data;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_AP:\n\t\tbasic_req.basic.conn_type = cpu_to_le32(CONNECTION_INFRA_AP);\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tbasic_req.basic.conn_type = cpu_to_le32(CONNECTION_INFRA_STA);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tbasic_req.basic.conn_type = cpu_to_le32(CONNECTION_IBSS_ADHOC);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tidx = mvif->omac_idx > EXT_BSSID_START ? HW_BSSID_0 : mvif->omac_idx;\n\tbasic_req.basic.hw_bss_idx = idx;\n\n\tmemcpy(dev_req.tlv.omac_addr, vif->addr, ETH_ALEN);\n\n\tcmd = enable ? MCU_UNI_CMD(DEV_INFO_UPDATE) : MCU_UNI_CMD(BSS_INFO_UPDATE);\n\tdata = enable ? (void *)&dev_req : (void *)&basic_req;\n\tlen = enable ? sizeof(dev_req) : sizeof(basic_req);\n\n\terr = mt76_mcu_send_msg(dev, cmd, data, len, true);\n\tif (err < 0)\n\t\treturn err;\n\n\tcmd = enable ? MCU_UNI_CMD(BSS_INFO_UPDATE) : MCU_UNI_CMD(DEV_INFO_UPDATE);\n\tdata = enable ? (void *)&basic_req : (void *)&dev_req;\n\tlen = enable ? sizeof(basic_req) : sizeof(dev_req);\n\n\treturn mt76_mcu_send_msg(dev, cmd, data, len, true);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_uni_add_dev);\n\nvoid mt76_connac_mcu_sta_ba_tlv(struct sk_buff *skb,\n\t\t\t\tstruct ieee80211_ampdu_params *params,\n\t\t\t\tbool enable, bool tx)\n{\n\tstruct sta_rec_ba *ba;\n\tstruct tlv *tlv;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_BA, sizeof(*ba));\n\n\tba = (struct sta_rec_ba *)tlv;\n\tba->ba_type = tx ? MT_BA_TYPE_ORIGINATOR : MT_BA_TYPE_RECIPIENT;\n\tba->winsize = cpu_to_le16(params->buf_size);\n\tba->ssn = cpu_to_le16(params->ssn);\n\tba->ba_en = enable << params->tid;\n\tba->amsdu = params->amsdu;\n\tba->tid = params->tid;\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_sta_ba_tlv);\n\nint mt76_connac_mcu_sta_wed_update(struct mt76_dev *dev, struct sk_buff *skb)\n{\n\tif (!mt76_is_mmio(dev))\n\t\treturn 0;\n\n\tif (!mtk_wed_device_active(&dev->mmio.wed))\n\t\treturn 0;\n\n\treturn mtk_wed_device_update_msg(&dev->mmio.wed, WED_WO_STA_REC,\n\t\t\t\t\t skb->data, skb->len);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_sta_wed_update);\n\nint mt76_connac_mcu_sta_ba(struct mt76_dev *dev, struct mt76_vif *mvif,\n\t\t\t   struct ieee80211_ampdu_params *params,\n\t\t\t   int cmd, bool enable, bool tx)\n{\n\tstruct mt76_wcid *wcid = (struct mt76_wcid *)params->sta->drv_priv;\n\tstruct wtbl_req_hdr *wtbl_hdr;\n\tstruct tlv *sta_wtbl;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = mt76_connac_mcu_alloc_sta_req(dev, mvif, wcid);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tsta_wtbl = mt76_connac_mcu_add_tlv(skb, STA_REC_WTBL,\n\t\t\t\t\t   sizeof(struct tlv));\n\n\twtbl_hdr = mt76_connac_mcu_alloc_wtbl_req(dev, wcid, WTBL_SET,\n\t\t\t\t\t\t  sta_wtbl, &skb);\n\tif (IS_ERR(wtbl_hdr))\n\t\treturn PTR_ERR(wtbl_hdr);\n\n\tmt76_connac_mcu_wtbl_ba_tlv(dev, skb, params, enable, tx, sta_wtbl,\n\t\t\t\t    wtbl_hdr);\n\n\tret = mt76_connac_mcu_sta_wed_update(dev, skb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt76_mcu_skb_send_msg(dev, skb, cmd, true);\n\tif (ret)\n\t\treturn ret;\n\n\tskb = mt76_connac_mcu_alloc_sta_req(dev, mvif, wcid);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tmt76_connac_mcu_sta_ba_tlv(skb, params, enable, tx);\n\n\tret = mt76_connac_mcu_sta_wed_update(dev, skb);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mt76_mcu_skb_send_msg(dev, skb, cmd, true);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_sta_ba);\n\nu8 mt76_connac_get_phy_mode(struct mt76_phy *phy, struct ieee80211_vif *vif,\n\t\t\t    enum nl80211_band band, struct ieee80211_sta *sta)\n{\n\tstruct mt76_dev *dev = phy->dev;\n\tconst struct ieee80211_sta_he_cap *he_cap;\n\tstruct ieee80211_sta_vht_cap *vht_cap;\n\tstruct ieee80211_sta_ht_cap *ht_cap;\n\tu8 mode = 0;\n\n\tif (is_connac_v1(dev))\n\t\treturn 0x38;\n\n\tif (sta) {\n\t\tht_cap = &sta->deflink.ht_cap;\n\t\tvht_cap = &sta->deflink.vht_cap;\n\t\the_cap = &sta->deflink.he_cap;\n\t} else {\n\t\tstruct ieee80211_supported_band *sband;\n\n\t\tsband = phy->hw->wiphy->bands[band];\n\t\tht_cap = &sband->ht_cap;\n\t\tvht_cap = &sband->vht_cap;\n\t\the_cap = ieee80211_get_he_iftype_cap(sband, vif->type);\n\t}\n\n\tif (band == NL80211_BAND_2GHZ) {\n\t\tmode |= PHY_MODE_B | PHY_MODE_G;\n\n\t\tif (ht_cap->ht_supported)\n\t\t\tmode |= PHY_MODE_GN;\n\n\t\tif (he_cap && he_cap->has_he)\n\t\t\tmode |= PHY_MODE_AX_24G;\n\t} else if (band == NL80211_BAND_5GHZ) {\n\t\tmode |= PHY_MODE_A;\n\n\t\tif (ht_cap->ht_supported)\n\t\t\tmode |= PHY_MODE_AN;\n\n\t\tif (vht_cap->vht_supported)\n\t\t\tmode |= PHY_MODE_AC;\n\n\t\tif (he_cap && he_cap->has_he)\n\t\t\tmode |= PHY_MODE_AX_5G;\n\t} else if (band == NL80211_BAND_6GHZ) {\n\t\tmode |= PHY_MODE_A | PHY_MODE_AN |\n\t\t\tPHY_MODE_AC | PHY_MODE_AX_5G;\n\t}\n\n\treturn mode;\n}\nEXPORT_SYMBOL_GPL(mt76_connac_get_phy_mode);\n\nu8 mt76_connac_get_phy_mode_ext(struct mt76_phy *phy, struct ieee80211_vif *vif,\n\t\t\t\tenum nl80211_band band)\n{\n\tconst struct ieee80211_sta_eht_cap *eht_cap;\n\tstruct ieee80211_supported_band *sband;\n\tu8 mode = 0;\n\n\tif (band == NL80211_BAND_6GHZ)\n\t\tmode |= PHY_MODE_AX_6G;\n\n\tsband = phy->hw->wiphy->bands[band];\n\teht_cap = ieee80211_get_eht_iftype_cap(sband, vif->type);\n\n\tif (!eht_cap || !eht_cap->has_eht)\n\t\treturn mode;\n\n\tswitch (band) {\n\tcase NL80211_BAND_6GHZ:\n\t\tmode |= PHY_MODE_BE_6G;\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\tmode |= PHY_MODE_BE_5G;\n\t\tbreak;\n\tcase NL80211_BAND_2GHZ:\n\t\tmode |= PHY_MODE_BE_24G;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn mode;\n}\nEXPORT_SYMBOL_GPL(mt76_connac_get_phy_mode_ext);\n\nconst struct ieee80211_sta_he_cap *\nmt76_connac_get_he_phy_cap(struct mt76_phy *phy, struct ieee80211_vif *vif)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct cfg80211_chan_def *chandef = mvif->ctx ?\n\t\t\t\t\t    &mvif->ctx->def : &phy->chandef;\n\tenum nl80211_band band = chandef->chan->band;\n\tstruct ieee80211_supported_band *sband;\n\n\tsband = phy->hw->wiphy->bands[band];\n\n\treturn ieee80211_get_he_iftype_cap(sband, vif->type);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_get_he_phy_cap);\n\nconst struct ieee80211_sta_eht_cap *\nmt76_connac_get_eht_phy_cap(struct mt76_phy *phy, struct ieee80211_vif *vif)\n{\n\tenum nl80211_band band = phy->chandef.chan->band;\n\tstruct ieee80211_supported_band *sband;\n\n\tsband = phy->hw->wiphy->bands[band];\n\n\treturn ieee80211_get_eht_iftype_cap(sband, vif->type);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_get_eht_phy_cap);\n\n#define DEFAULT_HE_PE_DURATION\t\t4\n#define DEFAULT_HE_DURATION_RTS_THRES\t1023\nstatic void\nmt76_connac_mcu_uni_bss_he_tlv(struct mt76_phy *phy, struct ieee80211_vif *vif,\n\t\t\t       struct tlv *tlv)\n{\n\tconst struct ieee80211_sta_he_cap *cap;\n\tstruct bss_info_uni_he *he;\n\n\tcap = mt76_connac_get_he_phy_cap(phy, vif);\n\n\the = (struct bss_info_uni_he *)tlv;\n\the->he_pe_duration = vif->bss_conf.htc_trig_based_pkt_ext;\n\tif (!he->he_pe_duration)\n\t\the->he_pe_duration = DEFAULT_HE_PE_DURATION;\n\n\the->he_rts_thres = cpu_to_le16(vif->bss_conf.frame_time_rts_th);\n\tif (!he->he_rts_thres)\n\t\the->he_rts_thres = cpu_to_le16(DEFAULT_HE_DURATION_RTS_THRES);\n\n\the->max_nss_mcs[CMD_HE_MCS_BW80] = cap->he_mcs_nss_supp.tx_mcs_80;\n\the->max_nss_mcs[CMD_HE_MCS_BW160] = cap->he_mcs_nss_supp.tx_mcs_160;\n\the->max_nss_mcs[CMD_HE_MCS_BW8080] = cap->he_mcs_nss_supp.tx_mcs_80p80;\n}\n\nint mt76_connac_mcu_uni_set_chctx(struct mt76_phy *phy, struct mt76_vif *mvif,\n\t\t\t\t  struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct cfg80211_chan_def *chandef = ctx ? &ctx->def : &phy->chandef;\n\tint freq1 = chandef->center_freq1, freq2 = chandef->center_freq2;\n\tenum nl80211_band band = chandef->chan->band;\n\tstruct mt76_dev *mdev = phy->dev;\n\tstruct {\n\t\tstruct {\n\t\t\tu8 bss_idx;\n\t\t\tu8 pad[3];\n\t\t} __packed hdr;\n\t\tstruct rlm_tlv {\n\t\t\t__le16 tag;\n\t\t\t__le16 len;\n\t\t\tu8 control_channel;\n\t\t\tu8 center_chan;\n\t\t\tu8 center_chan2;\n\t\t\tu8 bw;\n\t\t\tu8 tx_streams;\n\t\t\tu8 rx_streams;\n\t\t\tu8 short_st;\n\t\t\tu8 ht_op_info;\n\t\t\tu8 sco;\n\t\t\tu8 band;\n\t\t\tu8 pad[2];\n\t\t} __packed rlm;\n\t} __packed rlm_req = {\n\t\t.hdr = {\n\t\t\t.bss_idx = mvif->idx,\n\t\t},\n\t\t.rlm = {\n\t\t\t.tag = cpu_to_le16(UNI_BSS_INFO_RLM),\n\t\t\t.len = cpu_to_le16(sizeof(struct rlm_tlv)),\n\t\t\t.control_channel = chandef->chan->hw_value,\n\t\t\t.center_chan = ieee80211_frequency_to_channel(freq1),\n\t\t\t.center_chan2 = ieee80211_frequency_to_channel(freq2),\n\t\t\t.tx_streams = hweight8(phy->antenna_mask),\n\t\t\t.ht_op_info = 4,  \n\t\t\t.rx_streams = phy->chainmask,\n\t\t\t.short_st = true,\n\t\t\t.band = band,\n\t\t},\n\t};\n\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_40:\n\t\trlm_req.rlm.bw = CMD_CBW_40MHZ;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\trlm_req.rlm.bw = CMD_CBW_80MHZ;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80P80:\n\t\trlm_req.rlm.bw = CMD_CBW_8080MHZ;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_160:\n\t\trlm_req.rlm.bw = CMD_CBW_160MHZ;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_5:\n\t\trlm_req.rlm.bw = CMD_CBW_5MHZ;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_10:\n\t\trlm_req.rlm.bw = CMD_CBW_10MHZ;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\tcase NL80211_CHAN_WIDTH_20:\n\tdefault:\n\t\trlm_req.rlm.bw = CMD_CBW_20MHZ;\n\t\trlm_req.rlm.ht_op_info = 0;\n\t\tbreak;\n\t}\n\n\tif (rlm_req.rlm.control_channel < rlm_req.rlm.center_chan)\n\t\trlm_req.rlm.sco = 1;  \n\telse if (rlm_req.rlm.control_channel > rlm_req.rlm.center_chan)\n\t\trlm_req.rlm.sco = 3;  \n\n\treturn mt76_mcu_send_msg(mdev, MCU_UNI_CMD(BSS_INFO_UPDATE), &rlm_req,\n\t\t\t\t sizeof(rlm_req), true);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_uni_set_chctx);\n\nint mt76_connac_mcu_uni_add_bss(struct mt76_phy *phy,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct mt76_wcid *wcid,\n\t\t\t\tbool enable,\n\t\t\t\tstruct ieee80211_chanctx_conf *ctx)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct cfg80211_chan_def *chandef = ctx ? &ctx->def : &phy->chandef;\n\tenum nl80211_band band = chandef->chan->band;\n\tstruct mt76_dev *mdev = phy->dev;\n\tstruct {\n\t\tstruct {\n\t\t\tu8 bss_idx;\n\t\t\tu8 pad[3];\n\t\t} __packed hdr;\n\t\tstruct mt76_connac_bss_basic_tlv basic;\n\t\tstruct mt76_connac_bss_qos_tlv qos;\n\t} basic_req = {\n\t\t.hdr = {\n\t\t\t.bss_idx = mvif->idx,\n\t\t},\n\t\t.basic = {\n\t\t\t.tag = cpu_to_le16(UNI_BSS_INFO_BASIC),\n\t\t\t.len = cpu_to_le16(sizeof(struct mt76_connac_bss_basic_tlv)),\n\t\t\t.bcn_interval = cpu_to_le16(vif->bss_conf.beacon_int),\n\t\t\t.dtim_period = vif->bss_conf.dtim_period,\n\t\t\t.omac_idx = mvif->omac_idx,\n\t\t\t.band_idx = mvif->band_idx,\n\t\t\t.wmm_idx = mvif->wmm_idx,\n\t\t\t.active = true,  \n\t\t\t.phymode = mt76_connac_get_phy_mode(phy, vif, band, NULL),\n\t\t},\n\t\t.qos = {\n\t\t\t.tag = cpu_to_le16(UNI_BSS_INFO_QBSS),\n\t\t\t.len = cpu_to_le16(sizeof(struct mt76_connac_bss_qos_tlv)),\n\t\t\t.qos = vif->bss_conf.qos,\n\t\t},\n\t};\n\tint err, conn_type;\n\tu8 idx, basic_phy;\n\n\tidx = mvif->omac_idx > EXT_BSSID_START ? HW_BSSID_0 : mvif->omac_idx;\n\tbasic_req.basic.hw_bss_idx = idx;\n\tif (band == NL80211_BAND_6GHZ)\n\t\tbasic_req.basic.phymode_ext = PHY_MODE_AX_6G;\n\n\tbasic_phy = mt76_connac_get_phy_mode_v2(phy, vif, band, NULL);\n\tbasic_req.basic.nonht_basic_phy = cpu_to_le16(basic_phy);\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_AP:\n\t\tif (vif->p2p)\n\t\t\tconn_type = CONNECTION_P2P_GO;\n\t\telse\n\t\t\tconn_type = CONNECTION_INFRA_AP;\n\t\tbasic_req.basic.conn_type = cpu_to_le32(conn_type);\n\t\t \n\t\tbasic_req.basic.active = enable;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (vif->p2p)\n\t\t\tconn_type = CONNECTION_P2P_GC;\n\t\telse\n\t\t\tconn_type = CONNECTION_INFRA_STA;\n\t\tbasic_req.basic.conn_type = cpu_to_le32(conn_type);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tbasic_req.basic.conn_type = cpu_to_le32(CONNECTION_IBSS_ADHOC);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tmemcpy(basic_req.basic.bssid, vif->bss_conf.bssid, ETH_ALEN);\n\tbasic_req.basic.bmc_tx_wlan_idx = cpu_to_le16(wcid->idx);\n\tbasic_req.basic.sta_idx = cpu_to_le16(wcid->idx);\n\tbasic_req.basic.conn_state = !enable;\n\n\terr = mt76_mcu_send_msg(mdev, MCU_UNI_CMD(BSS_INFO_UPDATE), &basic_req,\n\t\t\t\tsizeof(basic_req), true);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (vif->bss_conf.he_support) {\n\t\tstruct {\n\t\t\tstruct {\n\t\t\t\tu8 bss_idx;\n\t\t\t\tu8 pad[3];\n\t\t\t} __packed hdr;\n\t\t\tstruct bss_info_uni_he he;\n\t\t\tstruct bss_info_uni_bss_color bss_color;\n\t\t} he_req = {\n\t\t\t.hdr = {\n\t\t\t\t.bss_idx = mvif->idx,\n\t\t\t},\n\t\t\t.he = {\n\t\t\t\t.tag = cpu_to_le16(UNI_BSS_INFO_HE_BASIC),\n\t\t\t\t.len = cpu_to_le16(sizeof(struct bss_info_uni_he)),\n\t\t\t},\n\t\t\t.bss_color = {\n\t\t\t\t.tag = cpu_to_le16(UNI_BSS_INFO_BSS_COLOR),\n\t\t\t\t.len = cpu_to_le16(sizeof(struct bss_info_uni_bss_color)),\n\t\t\t\t.enable = 0,\n\t\t\t\t.bss_color = 0,\n\t\t\t},\n\t\t};\n\n\t\tif (enable) {\n\t\t\the_req.bss_color.enable =\n\t\t\t\tvif->bss_conf.he_bss_color.enabled;\n\t\t\the_req.bss_color.bss_color =\n\t\t\t\tvif->bss_conf.he_bss_color.color;\n\t\t}\n\n\t\tmt76_connac_mcu_uni_bss_he_tlv(phy, vif,\n\t\t\t\t\t       (struct tlv *)&he_req.he);\n\t\terr = mt76_mcu_send_msg(mdev, MCU_UNI_CMD(BSS_INFO_UPDATE),\n\t\t\t\t\t&he_req, sizeof(he_req), true);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn mt76_connac_mcu_uni_set_chctx(phy, mvif, ctx);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_uni_add_bss);\n\n#define MT76_CONNAC_SCAN_CHANNEL_TIME\t\t60\nint mt76_connac_mcu_hw_scan(struct mt76_phy *phy, struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_scan_request *scan_req)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct cfg80211_scan_request *sreq = &scan_req->req;\n\tint n_ssids = 0, err, i, duration;\n\tint ext_channels_num = max_t(int, sreq->n_channels - 32, 0);\n\tstruct ieee80211_channel **scan_list = sreq->channels;\n\tstruct mt76_dev *mdev = phy->dev;\n\tstruct mt76_connac_mcu_scan_channel *chan;\n\tstruct mt76_connac_hw_scan_req *req;\n\tstruct sk_buff *skb;\n\n\tif (test_bit(MT76_HW_SCANNING, &phy->state))\n\t\treturn -EBUSY;\n\n\tskb = mt76_mcu_msg_alloc(mdev, NULL, sizeof(*req));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tset_bit(MT76_HW_SCANNING, &phy->state);\n\tmvif->scan_seq_num = (mvif->scan_seq_num + 1) & 0x7f;\n\n\treq = (struct mt76_connac_hw_scan_req *)skb_put(skb, sizeof(*req));\n\n\treq->seq_num = mvif->scan_seq_num | mvif->band_idx << 7;\n\treq->bss_idx = mvif->idx;\n\treq->scan_type = sreq->n_ssids ? 1 : 0;\n\treq->probe_req_num = sreq->n_ssids ? 2 : 0;\n\treq->version = 1;\n\n\tfor (i = 0; i < sreq->n_ssids; i++) {\n\t\tif (!sreq->ssids[i].ssid_len)\n\t\t\tcontinue;\n\n\t\treq->ssids[i].ssid_len = cpu_to_le32(sreq->ssids[i].ssid_len);\n\t\tmemcpy(req->ssids[i].ssid, sreq->ssids[i].ssid,\n\t\t       sreq->ssids[i].ssid_len);\n\t\tn_ssids++;\n\t}\n\treq->ssid_type = n_ssids ? BIT(2) : BIT(0);\n\treq->ssid_type_ext = n_ssids ? BIT(0) : 0;\n\treq->ssids_num = n_ssids;\n\n\tduration = is_mt7921(phy->dev) ? 0 : MT76_CONNAC_SCAN_CHANNEL_TIME;\n\t \n\tif (!sreq->n_ssids)\n\t\tduration *= 2;\n\treq->timeout_value = cpu_to_le16(sreq->n_channels * duration);\n\treq->channel_min_dwell_time = cpu_to_le16(duration);\n\treq->channel_dwell_time = cpu_to_le16(duration);\n\n\tif (sreq->n_channels == 0 || sreq->n_channels > 64) {\n\t\treq->channel_type = 0;\n\t\treq->channels_num = 0;\n\t\treq->ext_channels_num = 0;\n\t} else {\n\t\treq->channel_type = 4;\n\t\treq->channels_num = min_t(u8, sreq->n_channels, 32);\n\t\treq->ext_channels_num = min_t(u8, ext_channels_num, 32);\n\t}\n\n\tfor (i = 0; i < req->channels_num + req->ext_channels_num; i++) {\n\t\tif (i >= 32)\n\t\t\tchan = &req->ext_channels[i - 32];\n\t\telse\n\t\t\tchan = &req->channels[i];\n\n\t\tswitch (scan_list[i]->band) {\n\t\tcase NL80211_BAND_2GHZ:\n\t\t\tchan->band = 1;\n\t\t\tbreak;\n\t\tcase NL80211_BAND_6GHZ:\n\t\t\tchan->band = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tchan->band = 2;\n\t\t\tbreak;\n\t\t}\n\t\tchan->channel_num = scan_list[i]->hw_value;\n\t}\n\n\tif (sreq->ie_len > 0) {\n\t\tmemcpy(req->ies, sreq->ie, sreq->ie_len);\n\t\treq->ies_len = cpu_to_le16(sreq->ie_len);\n\t}\n\n\tif (is_mt7921(phy->dev))\n\t\treq->scan_func |= SCAN_FUNC_SPLIT_SCAN;\n\n\tmemcpy(req->bssid, sreq->bssid, ETH_ALEN);\n\tif (sreq->flags & NL80211_SCAN_FLAG_RANDOM_ADDR) {\n\t\tget_random_mask_addr(req->random_mac, sreq->mac_addr,\n\t\t\t\t     sreq->mac_addr_mask);\n\t\treq->scan_func |= SCAN_FUNC_RANDOM_MAC;\n\t}\n\n\terr = mt76_mcu_skb_send_msg(mdev, skb, MCU_CE_CMD(START_HW_SCAN),\n\t\t\t\t    false);\n\tif (err < 0)\n\t\tclear_bit(MT76_HW_SCANNING, &phy->state);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_hw_scan);\n\nint mt76_connac_mcu_cancel_hw_scan(struct mt76_phy *phy,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct {\n\t\tu8 seq_num;\n\t\tu8 is_ext_channel;\n\t\tu8 rsv[2];\n\t} __packed req = {\n\t\t.seq_num = mvif->scan_seq_num,\n\t};\n\n\tif (test_and_clear_bit(MT76_HW_SCANNING, &phy->state)) {\n\t\tstruct cfg80211_scan_info info = {\n\t\t\t.aborted = true,\n\t\t};\n\n\t\tieee80211_scan_completed(phy->hw, &info);\n\t}\n\n\treturn mt76_mcu_send_msg(phy->dev, MCU_CE_CMD(CANCEL_HW_SCAN),\n\t\t\t\t &req, sizeof(req), false);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_cancel_hw_scan);\n\nint mt76_connac_mcu_sched_scan_req(struct mt76_phy *phy,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct cfg80211_sched_scan_request *sreq)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct ieee80211_channel **scan_list = sreq->channels;\n\tstruct mt76_connac_mcu_scan_channel *chan;\n\tstruct mt76_connac_sched_scan_req *req;\n\tstruct mt76_dev *mdev = phy->dev;\n\tstruct cfg80211_match_set *match;\n\tstruct cfg80211_ssid *ssid;\n\tstruct sk_buff *skb;\n\tint i;\n\n\tskb = mt76_mcu_msg_alloc(mdev, NULL, sizeof(*req) + sreq->ie_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmvif->scan_seq_num = (mvif->scan_seq_num + 1) & 0x7f;\n\n\treq = (struct mt76_connac_sched_scan_req *)skb_put(skb, sizeof(*req));\n\treq->version = 1;\n\treq->seq_num = mvif->scan_seq_num | mvif->band_idx << 7;\n\n\tif (sreq->flags & NL80211_SCAN_FLAG_RANDOM_ADDR) {\n\t\tu8 *addr = is_mt7663(phy->dev) ? req->mt7663.random_mac\n\t\t\t\t\t       : req->mt7921.random_mac;\n\n\t\treq->scan_func = 1;\n\t\tget_random_mask_addr(addr, sreq->mac_addr,\n\t\t\t\t     sreq->mac_addr_mask);\n\t}\n\tif (is_mt7921(phy->dev)) {\n\t\treq->mt7921.bss_idx = mvif->idx;\n\t\treq->mt7921.delay = cpu_to_le32(sreq->delay);\n\t}\n\n\treq->ssids_num = sreq->n_ssids;\n\tfor (i = 0; i < req->ssids_num; i++) {\n\t\tssid = &sreq->ssids[i];\n\t\tmemcpy(req->ssids[i].ssid, ssid->ssid, ssid->ssid_len);\n\t\treq->ssids[i].ssid_len = cpu_to_le32(ssid->ssid_len);\n\t}\n\n\treq->match_num = sreq->n_match_sets;\n\tfor (i = 0; i < req->match_num; i++) {\n\t\tmatch = &sreq->match_sets[i];\n\t\tmemcpy(req->match[i].ssid, match->ssid.ssid,\n\t\t       match->ssid.ssid_len);\n\t\treq->match[i].rssi_th = cpu_to_le32(match->rssi_thold);\n\t\treq->match[i].ssid_len = match->ssid.ssid_len;\n\t}\n\n\treq->channel_type = sreq->n_channels ? 4 : 0;\n\treq->channels_num = min_t(u8, sreq->n_channels, 64);\n\tfor (i = 0; i < req->channels_num; i++) {\n\t\tchan = &req->channels[i];\n\n\t\tswitch (scan_list[i]->band) {\n\t\tcase NL80211_BAND_2GHZ:\n\t\t\tchan->band = 1;\n\t\t\tbreak;\n\t\tcase NL80211_BAND_6GHZ:\n\t\t\tchan->band = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tchan->band = 2;\n\t\t\tbreak;\n\t\t}\n\t\tchan->channel_num = scan_list[i]->hw_value;\n\t}\n\n\treq->intervals_num = sreq->n_scan_plans;\n\tfor (i = 0; i < req->intervals_num; i++)\n\t\treq->intervals[i] = cpu_to_le16(sreq->scan_plans[i].interval);\n\n\tif (sreq->ie_len > 0) {\n\t\treq->ie_len = cpu_to_le16(sreq->ie_len);\n\t\tmemcpy(skb_put(skb, sreq->ie_len), sreq->ie, sreq->ie_len);\n\t}\n\n\treturn mt76_mcu_skb_send_msg(mdev, skb, MCU_CE_CMD(SCHED_SCAN_REQ),\n\t\t\t\t     false);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_sched_scan_req);\n\nint mt76_connac_mcu_sched_scan_enable(struct mt76_phy *phy,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      bool enable)\n{\n\tstruct {\n\t\tu8 active;  \n\t\tu8 rsv[3];\n\t} __packed req = {\n\t\t.active = !enable,\n\t};\n\n\tif (enable)\n\t\tset_bit(MT76_HW_SCHED_SCANNING, &phy->state);\n\telse\n\t\tclear_bit(MT76_HW_SCHED_SCANNING, &phy->state);\n\n\treturn mt76_mcu_send_msg(phy->dev, MCU_CE_CMD(SCHED_SCAN_ENABLE),\n\t\t\t\t &req, sizeof(req), false);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_sched_scan_enable);\n\nint mt76_connac_mcu_chip_config(struct mt76_dev *dev)\n{\n\tstruct mt76_connac_config req = {\n\t\t.resp_type = 0,\n\t};\n\n\tmemcpy(req.data, \"assert\", 7);\n\n\treturn mt76_mcu_send_msg(dev, MCU_CE_CMD(CHIP_CONFIG),\n\t\t\t\t &req, sizeof(req), false);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_chip_config);\n\nint mt76_connac_mcu_set_deep_sleep(struct mt76_dev *dev, bool enable)\n{\n\tstruct mt76_connac_config req = {\n\t\t.resp_type = 0,\n\t};\n\n\tsnprintf(req.data, sizeof(req.data), \"KeepFullPwr %d\", !enable);\n\n\treturn mt76_mcu_send_msg(dev, MCU_CE_CMD(CHIP_CONFIG),\n\t\t\t\t &req, sizeof(req), false);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_set_deep_sleep);\n\nint mt76_connac_sta_state_dp(struct mt76_dev *dev,\n\t\t\t     enum ieee80211_sta_state old_state,\n\t\t\t     enum ieee80211_sta_state new_state)\n{\n\tif ((old_state == IEEE80211_STA_ASSOC &&\n\t     new_state == IEEE80211_STA_AUTHORIZED) ||\n\t    (old_state == IEEE80211_STA_NONE &&\n\t     new_state == IEEE80211_STA_NOTEXIST))\n\t\tmt76_connac_mcu_set_deep_sleep(dev, true);\n\n\tif ((old_state == IEEE80211_STA_NOTEXIST &&\n\t     new_state == IEEE80211_STA_NONE) ||\n\t    (old_state == IEEE80211_STA_AUTHORIZED &&\n\t     new_state == IEEE80211_STA_ASSOC))\n\t\tmt76_connac_mcu_set_deep_sleep(dev, false);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76_connac_sta_state_dp);\n\nvoid mt76_connac_mcu_coredump_event(struct mt76_dev *dev, struct sk_buff *skb,\n\t\t\t\t    struct mt76_connac_coredump *coredump)\n{\n\tspin_lock_bh(&dev->lock);\n\t__skb_queue_tail(&coredump->msg_list, skb);\n\tspin_unlock_bh(&dev->lock);\n\n\tcoredump->last_activity = jiffies;\n\n\tqueue_delayed_work(dev->wq, &coredump->work,\n\t\t\t   MT76_CONNAC_COREDUMP_TIMEOUT);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_coredump_event);\n\nstatic void mt76_connac_mcu_parse_tx_resource(struct mt76_dev *dev,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct mt76_sdio *sdio = &dev->sdio;\n\tstruct mt76_connac_tx_resource {\n\t\t__le32 version;\n\t\t__le32 pse_data_quota;\n\t\t__le32 pse_mcu_quota;\n\t\t__le32 ple_data_quota;\n\t\t__le32 ple_mcu_quota;\n\t\t__le16 pse_page_size;\n\t\t__le16 ple_page_size;\n\t\tu8 pp_padding;\n\t\tu8 pad[3];\n\t} __packed * tx_res;\n\n\ttx_res = (struct mt76_connac_tx_resource *)skb->data;\n\tsdio->sched.pse_data_quota = le32_to_cpu(tx_res->pse_data_quota);\n\tsdio->sched.pse_mcu_quota = le32_to_cpu(tx_res->pse_mcu_quota);\n\tsdio->sched.ple_data_quota = le32_to_cpu(tx_res->ple_data_quota);\n\tsdio->sched.pse_page_size = le16_to_cpu(tx_res->pse_page_size);\n\tsdio->sched.deficit = tx_res->pp_padding;\n}\n\nstatic void mt76_connac_mcu_parse_phy_cap(struct mt76_dev *dev,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct mt76_connac_phy_cap {\n\t\tu8 ht;\n\t\tu8 vht;\n\t\tu8 _5g;\n\t\tu8 max_bw;\n\t\tu8 nss;\n\t\tu8 dbdc;\n\t\tu8 tx_ldpc;\n\t\tu8 rx_ldpc;\n\t\tu8 tx_stbc;\n\t\tu8 rx_stbc;\n\t\tu8 hw_path;\n\t\tu8 he;\n\t} __packed * cap;\n\n\tenum {\n\t\tWF0_24G,\n\t\tWF0_5G\n\t};\n\n\tcap = (struct mt76_connac_phy_cap *)skb->data;\n\n\tdev->phy.antenna_mask = BIT(cap->nss) - 1;\n\tdev->phy.chainmask = dev->phy.antenna_mask;\n\tdev->phy.cap.has_2ghz = cap->hw_path & BIT(WF0_24G);\n\tdev->phy.cap.has_5ghz = cap->hw_path & BIT(WF0_5G);\n}\n\nint mt76_connac_mcu_get_nic_capability(struct mt76_phy *phy)\n{\n\tstruct mt76_connac_cap_hdr {\n\t\t__le16 n_element;\n\t\tu8 rsv[2];\n\t} __packed * hdr;\n\tstruct sk_buff *skb;\n\tint ret, i;\n\n\tret = mt76_mcu_send_and_get_msg(phy->dev, MCU_CE_CMD(GET_NIC_CAPAB),\n\t\t\t\t\tNULL, 0, true, &skb);\n\tif (ret)\n\t\treturn ret;\n\n\thdr = (struct mt76_connac_cap_hdr *)skb->data;\n\tif (skb->len < sizeof(*hdr)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tskb_pull(skb, sizeof(*hdr));\n\n\tfor (i = 0; i < le16_to_cpu(hdr->n_element); i++) {\n\t\tstruct tlv_hdr {\n\t\t\t__le32 type;\n\t\t\t__le32 len;\n\t\t} __packed * tlv = (struct tlv_hdr *)skb->data;\n\t\tint len;\n\n\t\tif (skb->len < sizeof(*tlv))\n\t\t\tbreak;\n\n\t\tskb_pull(skb, sizeof(*tlv));\n\n\t\tlen = le32_to_cpu(tlv->len);\n\t\tif (skb->len < len)\n\t\t\tbreak;\n\n\t\tswitch (le32_to_cpu(tlv->type)) {\n\t\tcase MT_NIC_CAP_6G:\n\t\t\tphy->cap.has_6ghz = skb->data[0];\n\t\t\tbreak;\n\t\tcase MT_NIC_CAP_MAC_ADDR:\n\t\t\tmemcpy(phy->macaddr, (void *)skb->data, ETH_ALEN);\n\t\t\tbreak;\n\t\tcase MT_NIC_CAP_PHY:\n\t\t\tmt76_connac_mcu_parse_phy_cap(phy->dev, skb);\n\t\t\tbreak;\n\t\tcase MT_NIC_CAP_TX_RESOURCE:\n\t\t\tif (mt76_is_sdio(phy->dev))\n\t\t\t\tmt76_connac_mcu_parse_tx_resource(phy->dev,\n\t\t\t\t\t\t\t\t  skb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tskb_pull(skb, len);\n\t}\nout:\n\tdev_kfree_skb(skb);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_get_nic_capability);\n\nstatic void\nmt76_connac_mcu_build_sku(struct mt76_dev *dev, s8 *sku,\n\t\t\t  struct mt76_power_limits *limits,\n\t\t\t  enum nl80211_band band)\n{\n\tint max_power = is_mt7921(dev) ? 127 : 63;\n\tint i, offset = sizeof(limits->cck);\n\n\tmemset(sku, max_power, MT_SKU_POWER_LIMIT);\n\n\tif (band == NL80211_BAND_2GHZ) {\n\t\t \n\t\tmemcpy(sku, limits->cck, sizeof(limits->cck));\n\t}\n\n\t \n\tmemcpy(&sku[offset], limits->ofdm, sizeof(limits->ofdm));\n\toffset += sizeof(limits->ofdm);\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tmemcpy(&sku[offset], limits->mcs[i], 8);\n\t\toffset += 8;\n\t}\n\tsku[offset++] = limits->mcs[0][0];\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(limits->mcs); i++) {\n\t\tmemcpy(&sku[offset], limits->mcs[i],\n\t\t       ARRAY_SIZE(limits->mcs[i]));\n\t\toffset += 12;\n\t}\n\n\tif (!is_mt7921(dev))\n\t\treturn;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(limits->ru); i++) {\n\t\tmemcpy(&sku[offset], limits->ru[i], ARRAY_SIZE(limits->ru[i]));\n\t\toffset += ARRAY_SIZE(limits->ru[i]);\n\t}\n}\n\nstatic s8 mt76_connac_get_ch_power(struct mt76_phy *phy,\n\t\t\t\t   struct ieee80211_channel *chan,\n\t\t\t\t   s8 target_power)\n{\n\tstruct mt76_dev *dev = phy->dev;\n\tstruct ieee80211_supported_band *sband;\n\tint i;\n\n\tswitch (chan->band) {\n\tcase NL80211_BAND_2GHZ:\n\t\tsband = &phy->sband_2g.sband;\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\tsband = &phy->sband_5g.sband;\n\t\tbreak;\n\tcase NL80211_BAND_6GHZ:\n\t\tsband = &phy->sband_6g.sband;\n\t\tbreak;\n\tdefault:\n\t\treturn target_power;\n\t}\n\n\tfor (i = 0; i < sband->n_channels; i++) {\n\t\tstruct ieee80211_channel *ch = &sband->channels[i];\n\n\t\tif (ch->hw_value == chan->hw_value) {\n\t\t\tif (!(ch->flags & IEEE80211_CHAN_DISABLED)) {\n\t\t\t\tint power = 2 * ch->max_reg_power;\n\n\t\t\t\tif (is_mt7663(dev) && (power > 63 || power < -64))\n\t\t\t\t\tpower = 63;\n\t\t\t\ttarget_power = min_t(s8, power, target_power);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn target_power;\n}\n\nstatic int\nmt76_connac_mcu_rate_txpower_band(struct mt76_phy *phy,\n\t\t\t\t  enum nl80211_band band)\n{\n\tstruct mt76_dev *dev = phy->dev;\n\tint sku_len, batch_len = is_mt7921(dev) ? 8 : 16;\n\tstatic const u8 chan_list_2ghz[] = {\n\t\t1, 2,  3,  4,  5,  6,  7,\n\t\t8, 9, 10, 11, 12, 13, 14\n\t};\n\tstatic const u8 chan_list_5ghz[] = {\n\t\t 36,  38,  40,  42,  44,  46,  48,\n\t\t 50,  52,  54,  56,  58,  60,  62,\n\t\t 64, 100, 102, 104, 106, 108, 110,\n\t\t112, 114, 116, 118, 120, 122, 124,\n\t\t126, 128, 132, 134, 136, 138, 140,\n\t\t142, 144, 149, 151, 153, 155, 157,\n\t\t159, 161, 165\n\t};\n\tstatic const u8 chan_list_6ghz[] = {\n\t\t  1,   3,   5,   7,   9,  11,  13,\n\t\t 15,  17,  19,  21,  23,  25,  27,\n\t\t 29,  33,  35,  37,  39,  41,  43,\n\t\t 45,  47,  49,  51,  53,  55,  57,\n\t\t 59,  61,  65,  67,  69,  71,  73,\n\t\t 75,  77,  79,  81,  83,  85,  87,\n\t\t 89,  91,  93,  97,  99, 101, 103,\n\t\t105, 107, 109, 111, 113, 115, 117,\n\t\t119, 121, 123, 125, 129, 131, 133,\n\t\t135, 137, 139, 141, 143, 145, 147,\n\t\t149, 151, 153, 155, 157, 161, 163,\n\t\t165, 167, 169, 171, 173, 175, 177,\n\t\t179, 181, 183, 185, 187, 189, 193,\n\t\t195, 197, 199, 201, 203, 205, 207,\n\t\t209, 211, 213, 215, 217, 219, 221,\n\t\t225, 227, 229, 233\n\t};\n\tint i, n_chan, batch_size, idx = 0, tx_power, last_ch;\n\tstruct mt76_connac_sku_tlv sku_tlbv;\n\tstruct mt76_power_limits limits;\n\tconst u8 *ch_list;\n\n\tsku_len = is_mt7921(dev) ? sizeof(sku_tlbv) : sizeof(sku_tlbv) - 92;\n\ttx_power = 2 * phy->hw->conf.power_level;\n\tif (!tx_power)\n\t\ttx_power = 127;\n\n\tif (band == NL80211_BAND_2GHZ) {\n\t\tn_chan = ARRAY_SIZE(chan_list_2ghz);\n\t\tch_list = chan_list_2ghz;\n\t} else if (band == NL80211_BAND_6GHZ) {\n\t\tn_chan = ARRAY_SIZE(chan_list_6ghz);\n\t\tch_list = chan_list_6ghz;\n\t} else {\n\t\tn_chan = ARRAY_SIZE(chan_list_5ghz);\n\t\tch_list = chan_list_5ghz;\n\t}\n\tbatch_size = DIV_ROUND_UP(n_chan, batch_len);\n\n\tif (phy->cap.has_6ghz)\n\t\tlast_ch = chan_list_6ghz[ARRAY_SIZE(chan_list_6ghz) - 1];\n\telse if (phy->cap.has_5ghz)\n\t\tlast_ch = chan_list_5ghz[ARRAY_SIZE(chan_list_5ghz) - 1];\n\telse\n\t\tlast_ch = chan_list_2ghz[ARRAY_SIZE(chan_list_2ghz) - 1];\n\n\tfor (i = 0; i < batch_size; i++) {\n\t\tstruct mt76_connac_tx_power_limit_tlv tx_power_tlv = {};\n\t\tint j, err, msg_len, num_ch;\n\t\tstruct sk_buff *skb;\n\n\t\tnum_ch = i == batch_size - 1 ? n_chan % batch_len : batch_len;\n\t\tmsg_len = sizeof(tx_power_tlv) + num_ch * sizeof(sku_tlbv);\n\t\tskb = mt76_mcu_msg_alloc(dev, NULL, msg_len);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\n\t\tskb_reserve(skb, sizeof(tx_power_tlv));\n\n\t\tBUILD_BUG_ON(sizeof(dev->alpha2) > sizeof(tx_power_tlv.alpha2));\n\t\tmemcpy(tx_power_tlv.alpha2, dev->alpha2, sizeof(dev->alpha2));\n\t\ttx_power_tlv.n_chan = num_ch;\n\n\t\tswitch (band) {\n\t\tcase NL80211_BAND_2GHZ:\n\t\t\ttx_power_tlv.band = 1;\n\t\t\tbreak;\n\t\tcase NL80211_BAND_6GHZ:\n\t\t\ttx_power_tlv.band = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttx_power_tlv.band = 2;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (j = 0; j < num_ch; j++, idx++) {\n\t\t\tstruct ieee80211_channel chan = {\n\t\t\t\t.hw_value = ch_list[idx],\n\t\t\t\t.band = band,\n\t\t\t};\n\t\t\ts8 reg_power, sar_power;\n\n\t\t\treg_power = mt76_connac_get_ch_power(phy, &chan,\n\t\t\t\t\t\t\t     tx_power);\n\t\t\tsar_power = mt76_get_sar_power(phy, &chan, reg_power);\n\n\t\t\tmt76_get_rate_power_limits(phy, &chan, &limits,\n\t\t\t\t\t\t   sar_power);\n\n\t\t\ttx_power_tlv.last_msg = ch_list[idx] == last_ch;\n\t\t\tsku_tlbv.channel = ch_list[idx];\n\n\t\t\tmt76_connac_mcu_build_sku(dev, sku_tlbv.pwr_limit,\n\t\t\t\t\t\t  &limits, band);\n\t\t\tskb_put_data(skb, &sku_tlbv, sku_len);\n\t\t}\n\t\t__skb_push(skb, sizeof(tx_power_tlv));\n\t\tmemcpy(skb->data, &tx_power_tlv, sizeof(tx_power_tlv));\n\n\t\terr = mt76_mcu_skb_send_msg(dev, skb,\n\t\t\t\t\t    MCU_CE_CMD(SET_RATE_TX_POWER),\n\t\t\t\t\t    false);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint mt76_connac_mcu_set_rate_txpower(struct mt76_phy *phy)\n{\n\tint err;\n\n\tif (phy->cap.has_2ghz) {\n\t\terr = mt76_connac_mcu_rate_txpower_band(phy,\n\t\t\t\t\t\t\tNL80211_BAND_2GHZ);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (phy->cap.has_5ghz) {\n\t\terr = mt76_connac_mcu_rate_txpower_band(phy,\n\t\t\t\t\t\t\tNL80211_BAND_5GHZ);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (phy->cap.has_6ghz) {\n\t\terr = mt76_connac_mcu_rate_txpower_band(phy,\n\t\t\t\t\t\t\tNL80211_BAND_6GHZ);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_set_rate_txpower);\n\nint mt76_connac_mcu_update_arp_filter(struct mt76_dev *dev,\n\t\t\t\t      struct mt76_vif *vif,\n\t\t\t\t      struct ieee80211_bss_conf *info)\n{\n\tstruct ieee80211_vif *mvif = container_of(info, struct ieee80211_vif,\n\t\t\t\t\t\t  bss_conf);\n\tstruct sk_buff *skb;\n\tint i, len = min_t(int, mvif->cfg.arp_addr_cnt,\n\t\t\t   IEEE80211_BSS_ARP_ADDR_LIST_LEN);\n\tstruct {\n\t\tstruct {\n\t\t\tu8 bss_idx;\n\t\t\tu8 pad[3];\n\t\t} __packed hdr;\n\t\tstruct mt76_connac_arpns_tlv arp;\n\t} req_hdr = {\n\t\t.hdr = {\n\t\t\t.bss_idx = vif->idx,\n\t\t},\n\t\t.arp = {\n\t\t\t.tag = cpu_to_le16(UNI_OFFLOAD_OFFLOAD_ARP),\n\t\t\t.len = cpu_to_le16(sizeof(struct mt76_connac_arpns_tlv)),\n\t\t\t.ips_num = len,\n\t\t\t.mode = 2,   \n\t\t\t.option = 1,\n\t\t},\n\t};\n\n\tskb = mt76_mcu_msg_alloc(dev, NULL,\n\t\t\t\t sizeof(req_hdr) + len * sizeof(__be32));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_data(skb, &req_hdr, sizeof(req_hdr));\n\tfor (i = 0; i < len; i++)\n\t\tskb_put_data(skb, &mvif->cfg.arp_addr_list[i], sizeof(__be32));\n\n\treturn mt76_mcu_skb_send_msg(dev, skb, MCU_UNI_CMD(OFFLOAD), true);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_update_arp_filter);\n\nint mt76_connac_mcu_set_p2p_oppps(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tint ct_window = vif->bss_conf.p2p_noa_attr.oppps_ctwindow;\n\tstruct mt76_phy *phy = hw->priv;\n\tstruct {\n\t\t__le32 ct_win;\n\t\tu8 bss_idx;\n\t\tu8 rsv[3];\n\t} __packed req = {\n\t\t.ct_win = cpu_to_le32(ct_window),\n\t\t.bss_idx = mvif->idx,\n\t};\n\n\treturn mt76_mcu_send_msg(phy->dev, MCU_CE_CMD(SET_P2P_OPPPS),\n\t\t\t\t &req, sizeof(req), false);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_set_p2p_oppps);\n\n#ifdef CONFIG_PM\n\nconst struct wiphy_wowlan_support mt76_connac_wowlan_support = {\n\t.flags = WIPHY_WOWLAN_MAGIC_PKT | WIPHY_WOWLAN_DISCONNECT |\n\t\t WIPHY_WOWLAN_SUPPORTS_GTK_REKEY | WIPHY_WOWLAN_NET_DETECT,\n\t.n_patterns = 1,\n\t.pattern_min_len = 1,\n\t.pattern_max_len = MT76_CONNAC_WOW_PATTEN_MAX_LEN,\n\t.max_nd_match_sets = 10,\n};\nEXPORT_SYMBOL_GPL(mt76_connac_wowlan_support);\n\nstatic void\nmt76_connac_mcu_key_iter(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t struct ieee80211_sta *sta,\n\t\t\t struct ieee80211_key_conf *key,\n\t\t\t void *data)\n{\n\tstruct mt76_connac_gtk_rekey_tlv *gtk_tlv = data;\n\tu32 cipher;\n\n\tif (key->cipher != WLAN_CIPHER_SUITE_AES_CMAC &&\n\t    key->cipher != WLAN_CIPHER_SUITE_CCMP &&\n\t    key->cipher != WLAN_CIPHER_SUITE_TKIP)\n\t\treturn;\n\n\tif (key->cipher == WLAN_CIPHER_SUITE_TKIP)\n\t\tcipher = BIT(3);\n\telse\n\t\tcipher = BIT(4);\n\n\t \n\tif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE) {\n\t\tif (key->cipher == WLAN_CIPHER_SUITE_TKIP)\n\t\t\tgtk_tlv->proto = cpu_to_le32(NL80211_WPA_VERSION_1);\n\t\telse\n\t\t\tgtk_tlv->proto = cpu_to_le32(NL80211_WPA_VERSION_2);\n\n\t\tgtk_tlv->pairwise_cipher = cpu_to_le32(cipher);\n\t\tgtk_tlv->keyid = key->keyidx;\n\t} else {\n\t\tgtk_tlv->group_cipher = cpu_to_le32(cipher);\n\t}\n}\n\nint mt76_connac_mcu_update_gtk_rekey(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct cfg80211_gtk_rekey_data *key)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct mt76_connac_gtk_rekey_tlv *gtk_tlv;\n\tstruct mt76_phy *phy = hw->priv;\n\tstruct sk_buff *skb;\n\tstruct {\n\t\tu8 bss_idx;\n\t\tu8 pad[3];\n\t} __packed hdr = {\n\t\t.bss_idx = mvif->idx,\n\t};\n\n\tskb = mt76_mcu_msg_alloc(phy->dev, NULL,\n\t\t\t\t sizeof(hdr) + sizeof(*gtk_tlv));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_data(skb, &hdr, sizeof(hdr));\n\tgtk_tlv = (struct mt76_connac_gtk_rekey_tlv *)skb_put(skb,\n\t\t\t\t\t\t\t sizeof(*gtk_tlv));\n\tgtk_tlv->tag = cpu_to_le16(UNI_OFFLOAD_OFFLOAD_GTK_REKEY);\n\tgtk_tlv->len = cpu_to_le16(sizeof(*gtk_tlv));\n\tgtk_tlv->rekey_mode = 2;\n\tgtk_tlv->option = 1;\n\n\trcu_read_lock();\n\tieee80211_iter_keys_rcu(hw, vif, mt76_connac_mcu_key_iter, gtk_tlv);\n\trcu_read_unlock();\n\n\tmemcpy(gtk_tlv->kek, key->kek, NL80211_KEK_LEN);\n\tmemcpy(gtk_tlv->kck, key->kck, NL80211_KCK_LEN);\n\tmemcpy(gtk_tlv->replay_ctr, key->replay_ctr, NL80211_REPLAY_CTR_LEN);\n\n\treturn mt76_mcu_skb_send_msg(phy->dev, skb,\n\t\t\t\t     MCU_UNI_CMD(OFFLOAD), true);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_update_gtk_rekey);\n\nstatic int\nmt76_connac_mcu_set_arp_filter(struct mt76_dev *dev, struct ieee80211_vif *vif,\n\t\t\t       bool suspend)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct {\n\t\tstruct {\n\t\t\tu8 bss_idx;\n\t\t\tu8 pad[3];\n\t\t} __packed hdr;\n\t\tstruct mt76_connac_arpns_tlv arpns;\n\t} req = {\n\t\t.hdr = {\n\t\t\t.bss_idx = mvif->idx,\n\t\t},\n\t\t.arpns = {\n\t\t\t.tag = cpu_to_le16(UNI_OFFLOAD_OFFLOAD_ARP),\n\t\t\t.len = cpu_to_le16(sizeof(struct mt76_connac_arpns_tlv)),\n\t\t\t.mode = suspend,\n\t\t},\n\t};\n\n\treturn mt76_mcu_send_msg(dev, MCU_UNI_CMD(OFFLOAD), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nstatic int\nmt76_connac_mcu_set_gtk_rekey(struct mt76_dev *dev, struct ieee80211_vif *vif,\n\t\t\t      bool suspend)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct {\n\t\tstruct {\n\t\t\tu8 bss_idx;\n\t\t\tu8 pad[3];\n\t\t} __packed hdr;\n\t\tstruct mt76_connac_gtk_rekey_tlv gtk_tlv;\n\t} __packed req = {\n\t\t.hdr = {\n\t\t\t.bss_idx = mvif->idx,\n\t\t},\n\t\t.gtk_tlv = {\n\t\t\t.tag = cpu_to_le16(UNI_OFFLOAD_OFFLOAD_GTK_REKEY),\n\t\t\t.len = cpu_to_le16(sizeof(struct mt76_connac_gtk_rekey_tlv)),\n\t\t\t.rekey_mode = !suspend,\n\t\t},\n\t};\n\n\treturn mt76_mcu_send_msg(dev, MCU_UNI_CMD(OFFLOAD), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nstatic int\nmt76_connac_mcu_set_suspend_mode(struct mt76_dev *dev,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t bool enable, u8 mdtim,\n\t\t\t\t bool wow_suspend)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct {\n\t\tstruct {\n\t\t\tu8 bss_idx;\n\t\t\tu8 pad[3];\n\t\t} __packed hdr;\n\t\tstruct mt76_connac_suspend_tlv suspend_tlv;\n\t} req = {\n\t\t.hdr = {\n\t\t\t.bss_idx = mvif->idx,\n\t\t},\n\t\t.suspend_tlv = {\n\t\t\t.tag = cpu_to_le16(UNI_SUSPEND_MODE_SETTING),\n\t\t\t.len = cpu_to_le16(sizeof(struct mt76_connac_suspend_tlv)),\n\t\t\t.enable = enable,\n\t\t\t.mdtim = mdtim,\n\t\t\t.wow_suspend = wow_suspend,\n\t\t},\n\t};\n\n\treturn mt76_mcu_send_msg(dev, MCU_UNI_CMD(SUSPEND), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nstatic int\nmt76_connac_mcu_set_wow_pattern(struct mt76_dev *dev,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tu8 index, bool enable,\n\t\t\t\tstruct cfg80211_pkt_pattern *pattern)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct mt76_connac_wow_pattern_tlv *ptlv;\n\tstruct sk_buff *skb;\n\tstruct req_hdr {\n\t\tu8 bss_idx;\n\t\tu8 pad[3];\n\t} __packed hdr = {\n\t\t.bss_idx = mvif->idx,\n\t};\n\n\tskb = mt76_mcu_msg_alloc(dev, NULL, sizeof(hdr) + sizeof(*ptlv));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_data(skb, &hdr, sizeof(hdr));\n\tptlv = (struct mt76_connac_wow_pattern_tlv *)skb_put(skb, sizeof(*ptlv));\n\tptlv->tag = cpu_to_le16(UNI_SUSPEND_WOW_PATTERN);\n\tptlv->len = cpu_to_le16(sizeof(*ptlv));\n\tptlv->data_len = pattern->pattern_len;\n\tptlv->enable = enable;\n\tptlv->index = index;\n\n\tmemcpy(ptlv->pattern, pattern->pattern, pattern->pattern_len);\n\tmemcpy(ptlv->mask, pattern->mask, DIV_ROUND_UP(pattern->pattern_len, 8));\n\n\treturn mt76_mcu_skb_send_msg(dev, skb, MCU_UNI_CMD(SUSPEND), true);\n}\n\nstatic int\nmt76_connac_mcu_set_wow_ctrl(struct mt76_phy *phy, struct ieee80211_vif *vif,\n\t\t\t     bool suspend, struct cfg80211_wowlan *wowlan)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct mt76_dev *dev = phy->dev;\n\tstruct {\n\t\tstruct {\n\t\t\tu8 bss_idx;\n\t\t\tu8 pad[3];\n\t\t} __packed hdr;\n\t\tstruct mt76_connac_wow_ctrl_tlv wow_ctrl_tlv;\n\t\tstruct mt76_connac_wow_gpio_param_tlv gpio_tlv;\n\t} req = {\n\t\t.hdr = {\n\t\t\t.bss_idx = mvif->idx,\n\t\t},\n\t\t.wow_ctrl_tlv = {\n\t\t\t.tag = cpu_to_le16(UNI_SUSPEND_WOW_CTRL),\n\t\t\t.len = cpu_to_le16(sizeof(struct mt76_connac_wow_ctrl_tlv)),\n\t\t\t.cmd = suspend ? 1 : 2,\n\t\t},\n\t\t.gpio_tlv = {\n\t\t\t.tag = cpu_to_le16(UNI_SUSPEND_WOW_GPIO_PARAM),\n\t\t\t.len = cpu_to_le16(sizeof(struct mt76_connac_wow_gpio_param_tlv)),\n\t\t\t.gpio_pin = 0xff,  \n\t\t},\n\t};\n\n\tif (wowlan->magic_pkt)\n\t\treq.wow_ctrl_tlv.trigger |= UNI_WOW_DETECT_TYPE_MAGIC;\n\tif (wowlan->disconnect)\n\t\treq.wow_ctrl_tlv.trigger |= (UNI_WOW_DETECT_TYPE_DISCONNECT |\n\t\t\t\t\t     UNI_WOW_DETECT_TYPE_BCN_LOST);\n\tif (wowlan->nd_config) {\n\t\tmt76_connac_mcu_sched_scan_req(phy, vif, wowlan->nd_config);\n\t\treq.wow_ctrl_tlv.trigger |= UNI_WOW_DETECT_TYPE_SCH_SCAN_HIT;\n\t\tmt76_connac_mcu_sched_scan_enable(phy, vif, suspend);\n\t}\n\tif (wowlan->n_patterns)\n\t\treq.wow_ctrl_tlv.trigger |= UNI_WOW_DETECT_TYPE_BITMAP;\n\n\tif (mt76_is_mmio(dev))\n\t\treq.wow_ctrl_tlv.wakeup_hif = WOW_PCIE;\n\telse if (mt76_is_usb(dev))\n\t\treq.wow_ctrl_tlv.wakeup_hif = WOW_USB;\n\telse if (mt76_is_sdio(dev))\n\t\treq.wow_ctrl_tlv.wakeup_hif = WOW_GPIO;\n\n\treturn mt76_mcu_send_msg(dev, MCU_UNI_CMD(SUSPEND), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nint mt76_connac_mcu_set_hif_suspend(struct mt76_dev *dev, bool suspend)\n{\n\tstruct {\n\t\tstruct {\n\t\t\tu8 hif_type;  \n\t\t\tu8 pad[3];\n\t\t} __packed hdr;\n\t\tstruct hif_suspend_tlv {\n\t\t\t__le16 tag;\n\t\t\t__le16 len;\n\t\t\tu8 suspend;\n\t\t} __packed hif_suspend;\n\t} req = {\n\t\t.hif_suspend = {\n\t\t\t.tag = cpu_to_le16(0),  \n\t\t\t.len = cpu_to_le16(sizeof(struct hif_suspend_tlv)),\n\t\t\t.suspend = suspend,\n\t\t},\n\t};\n\n\tif (mt76_is_mmio(dev))\n\t\treq.hdr.hif_type = 2;\n\telse if (mt76_is_usb(dev))\n\t\treq.hdr.hif_type = 1;\n\telse if (mt76_is_sdio(dev))\n\t\treq.hdr.hif_type = 0;\n\n\treturn mt76_mcu_send_msg(dev, MCU_UNI_CMD(HIF_CTRL), &req,\n\t\t\t\t sizeof(req), true);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_set_hif_suspend);\n\nvoid mt76_connac_mcu_set_suspend_iter(void *priv, u8 *mac,\n\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct mt76_phy *phy = priv;\n\tbool suspend = !test_bit(MT76_STATE_RUNNING, &phy->state);\n\tstruct ieee80211_hw *hw = phy->hw;\n\tstruct cfg80211_wowlan *wowlan = hw->wiphy->wowlan_config;\n\tint i;\n\n\tmt76_connac_mcu_set_gtk_rekey(phy->dev, vif, suspend);\n\tmt76_connac_mcu_set_arp_filter(phy->dev, vif, suspend);\n\n\tmt76_connac_mcu_set_suspend_mode(phy->dev, vif, suspend, 1, true);\n\n\tfor (i = 0; i < wowlan->n_patterns; i++)\n\t\tmt76_connac_mcu_set_wow_pattern(phy->dev, vif, i, suspend,\n\t\t\t\t\t\t&wowlan->patterns[i]);\n\tmt76_connac_mcu_set_wow_ctrl(phy, vif, suspend, wowlan);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_set_suspend_iter);\n#endif  \n\nu32 mt76_connac_mcu_reg_rr(struct mt76_dev *dev, u32 offset)\n{\n\tstruct {\n\t\t__le32 addr;\n\t\t__le32 val;\n\t} __packed req = {\n\t\t.addr = cpu_to_le32(offset),\n\t};\n\n\treturn mt76_mcu_send_msg(dev, MCU_CE_QUERY(REG_READ), &req,\n\t\t\t\t sizeof(req), true);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_reg_rr);\n\nvoid mt76_connac_mcu_reg_wr(struct mt76_dev *dev, u32 offset, u32 val)\n{\n\tstruct {\n\t\t__le32 addr;\n\t\t__le32 val;\n\t} __packed req = {\n\t\t.addr = cpu_to_le32(offset),\n\t\t.val = cpu_to_le32(val),\n\t};\n\n\tmt76_mcu_send_msg(dev, MCU_CE_CMD(REG_WRITE), &req,\n\t\t\t  sizeof(req), false);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_reg_wr);\n\nstatic int\nmt76_connac_mcu_sta_key_tlv(struct mt76_connac_sta_key_conf *sta_key_conf,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    struct ieee80211_key_conf *key,\n\t\t\t    enum set_key_cmd cmd)\n{\n\tstruct sta_rec_sec *sec;\n\tu32 len = sizeof(*sec);\n\tstruct tlv *tlv;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, STA_REC_KEY_V2, sizeof(*sec));\n\tsec = (struct sta_rec_sec *)tlv;\n\tsec->add = cmd;\n\n\tif (cmd == SET_KEY) {\n\t\tstruct sec_key *sec_key;\n\t\tu8 cipher;\n\n\t\tcipher = mt76_connac_mcu_get_cipher(key->cipher);\n\t\tif (cipher == MCU_CIPHER_NONE)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tsec_key = &sec->key[0];\n\t\tsec_key->cipher_len = sizeof(*sec_key);\n\n\t\tif (cipher == MCU_CIPHER_BIP_CMAC_128) {\n\t\t\tsec_key->cipher_id = MCU_CIPHER_AES_CCMP;\n\t\t\tsec_key->key_id = sta_key_conf->keyidx;\n\t\t\tsec_key->key_len = 16;\n\t\t\tmemcpy(sec_key->key, sta_key_conf->key, 16);\n\n\t\t\tsec_key = &sec->key[1];\n\t\t\tsec_key->cipher_id = MCU_CIPHER_BIP_CMAC_128;\n\t\t\tsec_key->cipher_len = sizeof(*sec_key);\n\t\t\tsec_key->key_len = 16;\n\t\t\tmemcpy(sec_key->key, key->key, 16);\n\t\t\tsec->n_cipher = 2;\n\t\t} else {\n\t\t\tsec_key->cipher_id = cipher;\n\t\t\tsec_key->key_id = key->keyidx;\n\t\t\tsec_key->key_len = key->keylen;\n\t\t\tmemcpy(sec_key->key, key->key, key->keylen);\n\n\t\t\tif (cipher == MCU_CIPHER_TKIP) {\n\t\t\t\t \n\t\t\t\tmemcpy(sec_key->key + 16, key->key + 24, 8);\n\t\t\t\tmemcpy(sec_key->key + 24, key->key + 16, 8);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (cipher == MCU_CIPHER_AES_CCMP) {\n\t\t\t\tmemcpy(sta_key_conf->key, key->key, key->keylen);\n\t\t\t\tsta_key_conf->keyidx = key->keyidx;\n\t\t\t}\n\n\t\t\tlen -= sizeof(*sec_key);\n\t\t\tsec->n_cipher = 1;\n\t\t}\n\t} else {\n\t\tlen -= sizeof(sec->key);\n\t\tsec->n_cipher = 0;\n\t}\n\tsec->len = cpu_to_le16(len);\n\n\treturn 0;\n}\n\nint mt76_connac_mcu_add_key(struct mt76_dev *dev, struct ieee80211_vif *vif,\n\t\t\t    struct mt76_connac_sta_key_conf *sta_key_conf,\n\t\t\t    struct ieee80211_key_conf *key, int mcu_cmd,\n\t\t\t    struct mt76_wcid *wcid, enum set_key_cmd cmd)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = mt76_connac_mcu_alloc_sta_req(dev, mvif, wcid);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tret = mt76_connac_mcu_sta_key_tlv(sta_key_conf, skb, key, cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt76_connac_mcu_sta_wed_update(dev, skb);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mt76_mcu_skb_send_msg(dev, skb, mcu_cmd, true);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_add_key);\n\n \n#define BCN_TX_ESTIMATE_TIME (4096 + 20)\nvoid mt76_connac_mcu_bss_ext_tlv(struct sk_buff *skb, struct mt76_vif *mvif)\n{\n\tstruct bss_info_ext_bss *ext;\n\tint ext_bss_idx, tsf_offset;\n\tstruct tlv *tlv;\n\n\text_bss_idx = mvif->omac_idx - EXT_BSSID_START;\n\tif (ext_bss_idx < 0)\n\t\treturn;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, BSS_INFO_EXT_BSS, sizeof(*ext));\n\n\text = (struct bss_info_ext_bss *)tlv;\n\ttsf_offset = ext_bss_idx * BCN_TX_ESTIMATE_TIME;\n\text->mbss_tsf_offset = cpu_to_le32(tsf_offset);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_bss_ext_tlv);\n\nint mt76_connac_mcu_bss_basic_tlv(struct sk_buff *skb,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t  struct mt76_phy *phy, u16 wlan_idx,\n\t\t\t\t  bool enable)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tu32 type = vif->p2p ? NETWORK_P2P : NETWORK_INFRA;\n\tstruct bss_info_basic *bss;\n\tstruct tlv *tlv;\n\n\ttlv = mt76_connac_mcu_add_tlv(skb, BSS_INFO_BASIC, sizeof(*bss));\n\tbss = (struct bss_info_basic *)tlv;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tif (ieee80211_hw_check(phy->hw, SUPPORTS_MULTI_BSSID)) {\n\t\t\tu8 bssid_id = vif->bss_conf.bssid_indicator;\n\t\t\tstruct wiphy *wiphy = phy->hw->wiphy;\n\n\t\t\tif (bssid_id > ilog2(wiphy->mbssid_max_interfaces))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tbss->non_tx_bssid = vif->bss_conf.bssid_index;\n\t\t\tbss->max_bssid = bssid_id;\n\t\t}\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (enable) {\n\t\t\trcu_read_lock();\n\t\t\tif (!sta)\n\t\t\t\tsta = ieee80211_find_sta(vif,\n\t\t\t\t\t\t\t vif->bss_conf.bssid);\n\t\t\t \n\t\t\tif (sta) {\n\t\t\t\tstruct mt76_wcid *wcid;\n\n\t\t\t\twcid = (struct mt76_wcid *)sta->drv_priv;\n\t\t\t\twlan_idx = wcid->idx;\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t}\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\ttype = NETWORK_IBSS;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tbss->network_type = cpu_to_le32(type);\n\tbss->bmc_wcid_lo = to_wcid_lo(wlan_idx);\n\tbss->bmc_wcid_hi = to_wcid_hi(wlan_idx);\n\tbss->wmm_idx = mvif->wmm_idx;\n\tbss->active = enable;\n\tbss->cipher = mvif->cipher;\n\n\tif (vif->type != NL80211_IFTYPE_MONITOR) {\n\t\tstruct cfg80211_chan_def *chandef = &phy->chandef;\n\n\t\tmemcpy(bss->bssid, vif->bss_conf.bssid, ETH_ALEN);\n\t\tbss->bcn_interval = cpu_to_le16(vif->bss_conf.beacon_int);\n\t\tbss->dtim_period = vif->bss_conf.dtim_period;\n\t\tbss->phy_mode = mt76_connac_get_phy_mode(phy, vif,\n\t\t\t\t\t\t\t chandef->chan->band, NULL);\n\t} else {\n\t\tmemcpy(bss->bssid, phy->macaddr, ETH_ALEN);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_bss_basic_tlv);\n\n#define ENTER_PM_STATE\t\t1\n#define EXIT_PM_STATE\t\t2\nint mt76_connac_mcu_set_pm(struct mt76_dev *dev, int band, int enter)\n{\n\tstruct {\n\t\tu8 pm_number;\n\t\tu8 pm_state;\n\t\tu8 bssid[ETH_ALEN];\n\t\tu8 dtim_period;\n\t\tu8 wlan_idx_lo;\n\t\t__le16 bcn_interval;\n\t\t__le32 aid;\n\t\t__le32 rx_filter;\n\t\tu8 band_idx;\n\t\tu8 wlan_idx_hi;\n\t\tu8 rsv[2];\n\t\t__le32 feature;\n\t\tu8 omac_idx;\n\t\tu8 wmm_idx;\n\t\tu8 bcn_loss_cnt;\n\t\tu8 bcn_sp_duration;\n\t} __packed req = {\n\t\t.pm_number = 5,\n\t\t.pm_state = enter ? ENTER_PM_STATE : EXIT_PM_STATE,\n\t\t.band_idx = band,\n\t};\n\n\treturn mt76_mcu_send_msg(dev, MCU_EXT_CMD(PM_STATE_CTRL), &req,\n\t\t\t\t sizeof(req), true);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_set_pm);\n\nint mt76_connac_mcu_restart(struct mt76_dev *dev)\n{\n\tstruct {\n\t\tu8 power_mode;\n\t\tu8 rsv[3];\n\t} req = {\n\t\t.power_mode = 1,\n\t};\n\n\treturn mt76_mcu_send_msg(dev, MCU_CMD(NIC_POWER_CTRL), &req,\n\t\t\t\t sizeof(req), false);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_restart);\n\nint mt76_connac_mcu_rdd_cmd(struct mt76_dev *dev, int cmd, u8 index,\n\t\t\t    u8 rx_sel, u8 val)\n{\n\tstruct {\n\t\tu8 ctrl;\n\t\tu8 rdd_idx;\n\t\tu8 rdd_rx_sel;\n\t\tu8 val;\n\t\tu8 rsv[4];\n\t} __packed req = {\n\t\t.ctrl = cmd,\n\t\t.rdd_idx = index,\n\t\t.rdd_rx_sel = rx_sel,\n\t\t.val = val,\n\t};\n\n\treturn mt76_mcu_send_msg(dev, MCU_EXT_CMD(SET_RDD_CTRL), &req,\n\t\t\t\t sizeof(req), true);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_mcu_rdd_cmd);\n\nstatic int\nmt76_connac_mcu_send_ram_firmware(struct mt76_dev *dev,\n\t\t\t\t  const struct mt76_connac2_fw_trailer *hdr,\n\t\t\t\t  const u8 *data, bool is_wa)\n{\n\tint i, offset = 0, max_len = mt76_is_sdio(dev) ? 2048 : 4096;\n\tu32 override = 0, option = 0;\n\n\tfor (i = 0; i < hdr->n_region; i++) {\n\t\tconst struct mt76_connac2_fw_region *region;\n\t\tu32 len, addr, mode;\n\t\tint err;\n\n\t\tregion = (const void *)((const u8 *)hdr -\n\t\t\t\t\t(hdr->n_region - i) * sizeof(*region));\n\t\tmode = mt76_connac_mcu_gen_dl_mode(dev, region->feature_set,\n\t\t\t\t\t\t   is_wa);\n\t\tlen = le32_to_cpu(region->len);\n\t\taddr = le32_to_cpu(region->addr);\n\n\t\tif (region->feature_set & FW_FEATURE_NON_DL)\n\t\t\tgoto next;\n\n\t\tif (region->feature_set & FW_FEATURE_OVERRIDE_ADDR)\n\t\t\toverride = addr;\n\n\t\terr = mt76_connac_mcu_init_download(dev, addr, len, mode);\n\t\tif (err) {\n\t\t\tdev_err(dev->dev, \"Download request failed\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\terr = __mt76_mcu_send_firmware(dev, MCU_CMD(FW_SCATTER),\n\t\t\t\t\t       data + offset, len, max_len);\n\t\tif (err) {\n\t\t\tdev_err(dev->dev, \"Failed to send firmware.\\n\");\n\t\t\treturn err;\n\t\t}\n\nnext:\n\t\toffset += len;\n\t}\n\n\tif (override)\n\t\toption |= FW_START_OVERRIDE;\n\tif (is_wa)\n\t\toption |= FW_START_WORKING_PDA_CR4;\n\n\treturn mt76_connac_mcu_start_firmware(dev, override, option);\n}\n\nint mt76_connac2_load_ram(struct mt76_dev *dev, const char *fw_wm,\n\t\t\t  const char *fw_wa)\n{\n\tconst struct mt76_connac2_fw_trailer *hdr;\n\tconst struct firmware *fw;\n\tint ret;\n\n\tret = request_firmware(&fw, fw_wm, dev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!fw || !fw->data || fw->size < sizeof(*hdr)) {\n\t\tdev_err(dev->dev, \"Invalid firmware\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\thdr = (const void *)(fw->data + fw->size - sizeof(*hdr));\n\tdev_info(dev->dev, \"WM Firmware Version: %.10s, Build Time: %.15s\\n\",\n\t\t hdr->fw_ver, hdr->build_date);\n\n\tret = mt76_connac_mcu_send_ram_firmware(dev, hdr, fw->data, false);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Failed to start WM firmware\\n\");\n\t\tgoto out;\n\t}\n\n\tsnprintf(dev->hw->wiphy->fw_version,\n\t\t sizeof(dev->hw->wiphy->fw_version),\n\t\t \"%.10s-%.15s\", hdr->fw_ver, hdr->build_date);\n\n\trelease_firmware(fw);\n\n\tif (!fw_wa)\n\t\treturn 0;\n\n\tret = request_firmware(&fw, fw_wa, dev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!fw || !fw->data || fw->size < sizeof(*hdr)) {\n\t\tdev_err(dev->dev, \"Invalid firmware\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\thdr = (const void *)(fw->data + fw->size - sizeof(*hdr));\n\tdev_info(dev->dev, \"WA Firmware Version: %.10s, Build Time: %.15s\\n\",\n\t\t hdr->fw_ver, hdr->build_date);\n\n\tret = mt76_connac_mcu_send_ram_firmware(dev, hdr, fw->data, true);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Failed to start WA firmware\\n\");\n\t\tgoto out;\n\t}\n\n\tsnprintf(dev->hw->wiphy->fw_version,\n\t\t sizeof(dev->hw->wiphy->fw_version),\n\t\t \"%.10s-%.15s\", hdr->fw_ver, hdr->build_date);\n\nout:\n\trelease_firmware(fw);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mt76_connac2_load_ram);\n\nstatic u32 mt76_connac2_get_data_mode(struct mt76_dev *dev, u32 info)\n{\n\tu32 mode = DL_MODE_NEED_RSP;\n\n\tif (!is_mt7921(dev) || info == PATCH_SEC_NOT_SUPPORT)\n\t\treturn mode;\n\n\tswitch (FIELD_GET(PATCH_SEC_ENC_TYPE_MASK, info)) {\n\tcase PATCH_SEC_ENC_TYPE_PLAIN:\n\t\tbreak;\n\tcase PATCH_SEC_ENC_TYPE_AES:\n\t\tmode |= DL_MODE_ENCRYPT;\n\t\tmode |= FIELD_PREP(DL_MODE_KEY_IDX,\n\t\t\t\t(info & PATCH_SEC_ENC_AES_KEY_MASK)) & DL_MODE_KEY_IDX;\n\t\tmode |= DL_MODE_RESET_SEC_IV;\n\t\tbreak;\n\tcase PATCH_SEC_ENC_TYPE_SCRAMBLE:\n\t\tmode |= DL_MODE_ENCRYPT;\n\t\tmode |= DL_CONFIG_ENCRY_MODE_SEL;\n\t\tmode |= DL_MODE_RESET_SEC_IV;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->dev, \"Encryption type not support!\\n\");\n\t}\n\n\treturn mode;\n}\n\nint mt76_connac2_load_patch(struct mt76_dev *dev, const char *fw_name)\n{\n\tint i, ret, sem, max_len = mt76_is_sdio(dev) ? 2048 : 4096;\n\tconst struct mt76_connac2_patch_hdr *hdr;\n\tconst struct firmware *fw = NULL;\n\n\tsem = mt76_connac_mcu_patch_sem_ctrl(dev, true);\n\tswitch (sem) {\n\tcase PATCH_IS_DL:\n\t\treturn 0;\n\tcase PATCH_NOT_DL_SEM_SUCCESS:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->dev, \"Failed to get patch semaphore\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tret = request_firmware(&fw, fw_name, dev->dev);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!fw || !fw->data || fw->size < sizeof(*hdr)) {\n\t\tdev_err(dev->dev, \"Invalid firmware\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\thdr = (const void *)fw->data;\n\tdev_info(dev->dev, \"HW/SW Version: 0x%x, Build Time: %.16s\\n\",\n\t\t be32_to_cpu(hdr->hw_sw_ver), hdr->build_date);\n\n\tfor (i = 0; i < be32_to_cpu(hdr->desc.n_region); i++) {\n\t\tstruct mt76_connac2_patch_sec *sec;\n\t\tu32 len, addr, mode;\n\t\tconst u8 *dl;\n\t\tu32 sec_info;\n\n\t\tsec = (void *)(fw->data + sizeof(*hdr) + i * sizeof(*sec));\n\t\tif ((be32_to_cpu(sec->type) & PATCH_SEC_TYPE_MASK) !=\n\t\t    PATCH_SEC_TYPE_INFO) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\taddr = be32_to_cpu(sec->info.addr);\n\t\tlen = be32_to_cpu(sec->info.len);\n\t\tdl = fw->data + be32_to_cpu(sec->offs);\n\t\tsec_info = be32_to_cpu(sec->info.sec_key_idx);\n\t\tmode = mt76_connac2_get_data_mode(dev, sec_info);\n\n\t\tret = mt76_connac_mcu_init_download(dev, addr, len, mode);\n\t\tif (ret) {\n\t\t\tdev_err(dev->dev, \"Download request failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = __mt76_mcu_send_firmware(dev, MCU_CMD(FW_SCATTER),\n\t\t\t\t\t       dl, len, max_len);\n\t\tif (ret) {\n\t\t\tdev_err(dev->dev, \"Failed to send patch\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = mt76_connac_mcu_start_patch(dev);\n\tif (ret)\n\t\tdev_err(dev->dev, \"Failed to start patch\\n\");\n\nout:\n\tsem = mt76_connac_mcu_patch_sem_ctrl(dev, false);\n\tswitch (sem) {\n\tcase PATCH_REL_SEM_SUCCESS:\n\t\tbreak;\n\tdefault:\n\t\tret = -EAGAIN;\n\t\tdev_err(dev->dev, \"Failed to release patch semaphore\\n\");\n\t\tbreak;\n\t}\n\n\trelease_firmware(fw);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mt76_connac2_load_patch);\n\nint mt76_connac2_mcu_fill_message(struct mt76_dev *dev, struct sk_buff *skb,\n\t\t\t\t  int cmd, int *wait_seq)\n{\n\tint txd_len, mcu_cmd = FIELD_GET(__MCU_CMD_FIELD_ID, cmd);\n\tstruct mt76_connac2_mcu_uni_txd *uni_txd;\n\tstruct mt76_connac2_mcu_txd *mcu_txd;\n\t__le32 *txd;\n\tu32 val;\n\tu8 seq;\n\n\t \n\tdev->mcu.timeout = 20 * HZ;\n\n\tseq = ++dev->mcu.msg_seq & 0xf;\n\tif (!seq)\n\t\tseq = ++dev->mcu.msg_seq & 0xf;\n\n\tif (cmd == MCU_CMD(FW_SCATTER))\n\t\tgoto exit;\n\n\ttxd_len = cmd & __MCU_CMD_FIELD_UNI ? sizeof(*uni_txd) : sizeof(*mcu_txd);\n\ttxd = (__le32 *)skb_push(skb, txd_len);\n\n\tval = FIELD_PREP(MT_TXD0_TX_BYTES, skb->len) |\n\t      FIELD_PREP(MT_TXD0_PKT_FMT, MT_TX_TYPE_CMD) |\n\t      FIELD_PREP(MT_TXD0_Q_IDX, MT_TX_MCU_PORT_RX_Q0);\n\ttxd[0] = cpu_to_le32(val);\n\n\tval = MT_TXD1_LONG_FORMAT |\n\t      FIELD_PREP(MT_TXD1_HDR_FORMAT, MT_HDR_FORMAT_CMD);\n\ttxd[1] = cpu_to_le32(val);\n\n\tif (cmd & __MCU_CMD_FIELD_UNI) {\n\t\tuni_txd = (struct mt76_connac2_mcu_uni_txd *)txd;\n\t\tuni_txd->len = cpu_to_le16(skb->len - sizeof(uni_txd->txd));\n\t\tuni_txd->option = MCU_CMD_UNI_EXT_ACK;\n\t\tuni_txd->cid = cpu_to_le16(mcu_cmd);\n\t\tuni_txd->s2d_index = MCU_S2D_H2N;\n\t\tuni_txd->pkt_type = MCU_PKT_ID;\n\t\tuni_txd->seq = seq;\n\n\t\tgoto exit;\n\t}\n\n\tmcu_txd = (struct mt76_connac2_mcu_txd *)txd;\n\tmcu_txd->len = cpu_to_le16(skb->len - sizeof(mcu_txd->txd));\n\tmcu_txd->pq_id = cpu_to_le16(MCU_PQ_ID(MT_TX_PORT_IDX_MCU,\n\t\t\t\t\t       MT_TX_MCU_PORT_RX_Q0));\n\tmcu_txd->pkt_type = MCU_PKT_ID;\n\tmcu_txd->seq = seq;\n\tmcu_txd->cid = mcu_cmd;\n\tmcu_txd->ext_cid = FIELD_GET(__MCU_CMD_FIELD_EXT_ID, cmd);\n\n\tif (mcu_txd->ext_cid || (cmd & __MCU_CMD_FIELD_CE)) {\n\t\tif (cmd & __MCU_CMD_FIELD_QUERY)\n\t\t\tmcu_txd->set_query = MCU_Q_QUERY;\n\t\telse\n\t\t\tmcu_txd->set_query = MCU_Q_SET;\n\t\tmcu_txd->ext_cid_ack = !!mcu_txd->ext_cid;\n\t} else {\n\t\tmcu_txd->set_query = MCU_Q_NA;\n\t}\n\n\tif (cmd & __MCU_CMD_FIELD_WA)\n\t\tmcu_txd->s2d_index = MCU_S2D_H2C;\n\telse\n\t\tmcu_txd->s2d_index = MCU_S2D_H2N;\n\nexit:\n\tif (wait_seq)\n\t\t*wait_seq = seq;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76_connac2_mcu_fill_message);\n\nMODULE_AUTHOR(\"Lorenzo Bianconi <lorenzo@kernel.org>\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}