{
  "module_name": "mt76_connac_mac.c",
  "hash_id": "bff74c2ae0c057b73a08aa25317d2cb0cb016a29875f819db8e0d22483725fef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt76_connac_mac.c",
  "human_readable_source": "\n \n\n#include \"mt76_connac.h\"\n#include \"mt76_connac2_mac.h\"\n#include \"dma.h\"\n\n#define HE_BITS(f)\t\tcpu_to_le16(IEEE80211_RADIOTAP_HE_##f)\n#define HE_PREP(f, m, v)\tle16_encode_bits(le32_get_bits(v, MT_CRXV_HE_##m),\\\n\t\t\t\t\t\t IEEE80211_RADIOTAP_HE_##f)\n\nvoid mt76_connac_gen_ppe_thresh(u8 *he_ppet, int nss)\n{\n\tstatic const u8 ppet16_ppet8_ru3_ru0[] = { 0x1c, 0xc7, 0x71 };\n\tu8 i, ppet_bits, ppet_size, ru_bit_mask = 0x7;  \n\n\the_ppet[0] = FIELD_PREP(IEEE80211_PPE_THRES_NSS_MASK, nss - 1) |\n\t\t     FIELD_PREP(IEEE80211_PPE_THRES_RU_INDEX_BITMASK_MASK,\n\t\t\t\tru_bit_mask);\n\n\tppet_bits = IEEE80211_PPE_THRES_INFO_PPET_SIZE *\n\t\t    nss * hweight8(ru_bit_mask) * 2;\n\tppet_size = DIV_ROUND_UP(ppet_bits, 8);\n\n\tfor (i = 0; i < ppet_size - 1; i++)\n\t\the_ppet[i + 1] = ppet16_ppet8_ru3_ru0[i % 3];\n\n\the_ppet[i + 1] = ppet16_ppet8_ru3_ru0[i % 3] &\n\t\t\t (0xff >> (8 - (ppet_bits - 1) % 8));\n}\nEXPORT_SYMBOL_GPL(mt76_connac_gen_ppe_thresh);\n\nint mt76_connac_pm_wake(struct mt76_phy *phy, struct mt76_connac_pm *pm)\n{\n\tstruct mt76_dev *dev = phy->dev;\n\n\tif (mt76_is_usb(dev))\n\t\treturn 0;\n\n\tcancel_delayed_work_sync(&pm->ps_work);\n\tif (!test_bit(MT76_STATE_PM, &phy->state))\n\t\treturn 0;\n\n\tif (pm->suspended)\n\t\treturn 0;\n\n\tqueue_work(dev->wq, &pm->wake_work);\n\tif (!wait_event_timeout(pm->wait,\n\t\t\t\t!test_bit(MT76_STATE_PM, &phy->state),\n\t\t\t\t3 * HZ)) {\n\t\tieee80211_wake_queues(phy->hw);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76_connac_pm_wake);\n\nvoid mt76_connac_power_save_sched(struct mt76_phy *phy,\n\t\t\t\t  struct mt76_connac_pm *pm)\n{\n\tstruct mt76_dev *dev = phy->dev;\n\n\tif (mt76_is_usb(dev))\n\t\treturn;\n\n\tif (!pm->enable)\n\t\treturn;\n\n\tif (pm->suspended)\n\t\treturn;\n\n\tpm->last_activity = jiffies;\n\n\tif (!test_bit(MT76_STATE_PM, &phy->state)) {\n\t\tcancel_delayed_work(&phy->mac_work);\n\t\tqueue_delayed_work(dev->wq, &pm->ps_work, pm->idle_timeout);\n\t}\n}\nEXPORT_SYMBOL_GPL(mt76_connac_power_save_sched);\n\nvoid mt76_connac_free_pending_tx_skbs(struct mt76_connac_pm *pm,\n\t\t\t\t      struct mt76_wcid *wcid)\n{\n\tint i;\n\n\tspin_lock_bh(&pm->txq_lock);\n\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\tif (wcid && pm->tx_q[i].wcid != wcid)\n\t\t\tcontinue;\n\n\t\tdev_kfree_skb(pm->tx_q[i].skb);\n\t\tpm->tx_q[i].skb = NULL;\n\t}\n\tspin_unlock_bh(&pm->txq_lock);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_free_pending_tx_skbs);\n\nvoid mt76_connac_pm_queue_skb(struct ieee80211_hw *hw,\n\t\t\t      struct mt76_connac_pm *pm,\n\t\t\t      struct mt76_wcid *wcid,\n\t\t\t      struct sk_buff *skb)\n{\n\tint qid = skb_get_queue_mapping(skb);\n\tstruct mt76_phy *phy = hw->priv;\n\n\tspin_lock_bh(&pm->txq_lock);\n\tif (!pm->tx_q[qid].skb) {\n\t\tieee80211_stop_queues(hw);\n\t\tpm->tx_q[qid].wcid = wcid;\n\t\tpm->tx_q[qid].skb = skb;\n\t\tqueue_work(phy->dev->wq, &pm->wake_work);\n\t} else {\n\t\tdev_kfree_skb(skb);\n\t}\n\tspin_unlock_bh(&pm->txq_lock);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_pm_queue_skb);\n\nvoid mt76_connac_pm_dequeue_skbs(struct mt76_phy *phy,\n\t\t\t\t struct mt76_connac_pm *pm)\n{\n\tint i;\n\n\tspin_lock_bh(&pm->txq_lock);\n\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\tstruct mt76_wcid *wcid = pm->tx_q[i].wcid;\n\t\tstruct ieee80211_sta *sta = NULL;\n\n\t\tif (!pm->tx_q[i].skb)\n\t\t\tcontinue;\n\n\t\tif (wcid && wcid->sta)\n\t\t\tsta = container_of((void *)wcid, struct ieee80211_sta,\n\t\t\t\t\t   drv_priv);\n\n\t\tmt76_tx(phy, sta, wcid, pm->tx_q[i].skb);\n\t\tpm->tx_q[i].skb = NULL;\n\t}\n\tspin_unlock_bh(&pm->txq_lock);\n\n\tmt76_worker_schedule(&phy->dev->tx_worker);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_pm_dequeue_skbs);\n\nvoid mt76_connac_tx_complete_skb(struct mt76_dev *mdev,\n\t\t\t\t struct mt76_queue_entry *e)\n{\n\tif (!e->txwi) {\n\t\tdev_kfree_skb_any(e->skb);\n\t\treturn;\n\t}\n\n\tif (e->skb)\n\t\tmt76_tx_complete_skb(mdev, e->wcid, e->skb);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_tx_complete_skb);\n\nvoid mt76_connac_write_hw_txp(struct mt76_dev *dev,\n\t\t\t      struct mt76_tx_info *tx_info,\n\t\t\t      void *txp_ptr, u32 id)\n{\n\tstruct mt76_connac_hw_txp *txp = txp_ptr;\n\tstruct mt76_connac_txp_ptr *ptr = &txp->ptr[0];\n\tint i, nbuf = tx_info->nbuf - 1;\n\tu32 last_mask;\n\n\ttx_info->buf[0].len = MT_TXD_SIZE + sizeof(*txp);\n\ttx_info->nbuf = 1;\n\n\ttxp->msdu_id[0] = cpu_to_le16(id | MT_MSDU_ID_VALID);\n\n\tif (is_mt7663(dev) || is_mt7921(dev))\n\t\tlast_mask = MT_TXD_LEN_LAST;\n\telse\n\t\tlast_mask = MT_TXD_LEN_AMSDU_LAST |\n\t\t\t    MT_TXD_LEN_MSDU_LAST;\n\n\tfor (i = 0; i < nbuf; i++) {\n\t\tu16 len = tx_info->buf[i + 1].len & MT_TXD_LEN_MASK;\n\t\tu32 addr = tx_info->buf[i + 1].addr;\n\n\t\tif (i == nbuf - 1)\n\t\t\tlen |= last_mask;\n\n\t\tif (i & 1) {\n\t\t\tptr->buf1 = cpu_to_le32(addr);\n\t\t\tptr->len1 = cpu_to_le16(len);\n\t\t\tptr++;\n\t\t} else {\n\t\t\tptr->buf0 = cpu_to_le32(addr);\n\t\t\tptr->len0 = cpu_to_le16(len);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(mt76_connac_write_hw_txp);\n\nstatic void\nmt76_connac_txp_skb_unmap_fw(struct mt76_dev *mdev,\n\t\t\t     struct mt76_connac_fw_txp *txp)\n{\n\tstruct device *dev = is_connac_v1(mdev) ? mdev->dev : mdev->dma_dev;\n\tint i;\n\n\tfor (i = 0; i < txp->nbuf; i++)\n\t\tdma_unmap_single(dev, le32_to_cpu(txp->buf[i]),\n\t\t\t\t le16_to_cpu(txp->len[i]), DMA_TO_DEVICE);\n}\n\nstatic void\nmt76_connac_txp_skb_unmap_hw(struct mt76_dev *dev,\n\t\t\t     struct mt76_connac_hw_txp *txp)\n{\n\tu32 last_mask;\n\tint i;\n\n\tif (is_mt7663(dev) || is_mt7921(dev))\n\t\tlast_mask = MT_TXD_LEN_LAST;\n\telse\n\t\tlast_mask = MT_TXD_LEN_MSDU_LAST;\n\n\tfor (i = 0; i < ARRAY_SIZE(txp->ptr); i++) {\n\t\tstruct mt76_connac_txp_ptr *ptr = &txp->ptr[i];\n\t\tbool last;\n\t\tu16 len;\n\n\t\tlen = le16_to_cpu(ptr->len0);\n\t\tlast = len & last_mask;\n\t\tlen &= MT_TXD_LEN_MASK;\n\t\tdma_unmap_single(dev->dev, le32_to_cpu(ptr->buf0), len,\n\t\t\t\t DMA_TO_DEVICE);\n\t\tif (last)\n\t\t\tbreak;\n\n\t\tlen = le16_to_cpu(ptr->len1);\n\t\tlast = len & last_mask;\n\t\tlen &= MT_TXD_LEN_MASK;\n\t\tdma_unmap_single(dev->dev, le32_to_cpu(ptr->buf1), len,\n\t\t\t\t DMA_TO_DEVICE);\n\t\tif (last)\n\t\t\tbreak;\n\t}\n}\n\nvoid mt76_connac_txp_skb_unmap(struct mt76_dev *dev,\n\t\t\t       struct mt76_txwi_cache *t)\n{\n\tstruct mt76_connac_txp_common *txp;\n\n\ttxp = mt76_connac_txwi_to_txp(dev, t);\n\tif (is_mt76_fw_txp(dev))\n\t\tmt76_connac_txp_skb_unmap_fw(dev, &txp->fw);\n\telse\n\t\tmt76_connac_txp_skb_unmap_hw(dev, &txp->hw);\n}\nEXPORT_SYMBOL_GPL(mt76_connac_txp_skb_unmap);\n\nint mt76_connac_init_tx_queues(struct mt76_phy *phy, int idx, int n_desc,\n\t\t\t       int ring_base, u32 flags)\n{\n\tint i, err;\n\n\terr = mt76_init_tx_queue(phy, 0, idx, n_desc, ring_base, flags);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 1; i <= MT_TXQ_PSD; i++)\n\t\tphy->q_tx[i] = phy->q_tx[0];\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76_connac_init_tx_queues);\n\n#define __bitrate_mask_check(_mcs, _mode)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tu8 i = 0;\t\t\t\t\t\t\t\\\n\tfor (nss = 0; i < ARRAY_SIZE(mask->control[band]._mcs); i++) {\t\\\n\t\tif (!mask->control[band]._mcs[i])\t\t\t\\\n\t\t\tcontinue;\t\t\t\t\t\\\n\t\tif (hweight16(mask->control[band]._mcs[i]) == 1) {\t\\\n\t\t\tmode = MT_PHY_TYPE_##_mode;\t\t\t\\\n\t\t\trateidx = ffs(mask->control[band]._mcs[i]) - 1;\t\\\n\t\t\tif (mode == MT_PHY_TYPE_HT)\t\t\t\\\n\t\t\t\trateidx += 8 * i;\t\t\t\\\n\t\t\telse\t\t\t\t\t\t\\\n\t\t\t\tnss = i + 1;\t\t\t\t\\\n\t\t\tgoto out;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n})\n\nu16 mt76_connac2_mac_tx_rate_val(struct mt76_phy *mphy,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t bool beacon, bool mcast)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct cfg80211_chan_def *chandef = mvif->ctx ?\n\t\t\t\t\t    &mvif->ctx->def : &mphy->chandef;\n\tu8 nss = 0, mode = 0, band = chandef->chan->band;\n\tint rateidx = 0, mcast_rate;\n\n\tif (!vif)\n\t\tgoto legacy;\n\n\tif (is_mt7921(mphy->dev)) {\n\t\trateidx = ffs(vif->bss_conf.basic_rates) - 1;\n\t\tgoto legacy;\n\t}\n\n\tif (beacon) {\n\t\tstruct cfg80211_bitrate_mask *mask;\n\n\t\tmask = &vif->bss_conf.beacon_tx_rate;\n\n\t\t__bitrate_mask_check(he_mcs, HE_SU);\n\t\t__bitrate_mask_check(vht_mcs, VHT);\n\t\t__bitrate_mask_check(ht_mcs, HT);\n\n\t\tif (hweight32(mask->control[band].legacy) == 1) {\n\t\t\trateidx = ffs(mask->control[band].legacy) - 1;\n\t\t\tgoto legacy;\n\t\t}\n\t}\n\n\tmcast_rate = vif->bss_conf.mcast_rate[band];\n\tif (mcast && mcast_rate > 0)\n\t\trateidx = mcast_rate - 1;\n\telse\n\t\trateidx = ffs(vif->bss_conf.basic_rates) - 1;\n\nlegacy:\n\trateidx = mt76_calculate_default_rate(mphy, vif, rateidx);\n\tmode = rateidx >> 8;\n\trateidx &= GENMASK(7, 0);\nout:\n\treturn FIELD_PREP(MT_TX_RATE_NSS, nss) |\n\t       FIELD_PREP(MT_TX_RATE_IDX, rateidx) |\n\t       FIELD_PREP(MT_TX_RATE_MODE, mode);\n}\nEXPORT_SYMBOL_GPL(mt76_connac2_mac_tx_rate_val);\n\nstatic void\nmt76_connac2_mac_write_txwi_8023(__le32 *txwi, struct sk_buff *skb,\n\t\t\t\t struct mt76_wcid *wcid)\n{\n\tu8 tid = skb->priority & IEEE80211_QOS_CTL_TID_MASK;\n\tu8 fc_type, fc_stype;\n\tu16 ethertype;\n\tbool wmm = false;\n\tu32 val;\n\n\tif (wcid->sta) {\n\t\tstruct ieee80211_sta *sta;\n\n\t\tsta = container_of((void *)wcid, struct ieee80211_sta, drv_priv);\n\t\twmm = sta->wme;\n\t}\n\n\tval = FIELD_PREP(MT_TXD1_HDR_FORMAT, MT_HDR_FORMAT_802_3) |\n\t      FIELD_PREP(MT_TXD1_TID, tid);\n\n\tethertype = get_unaligned_be16(&skb->data[12]);\n\tif (ethertype >= ETH_P_802_3_MIN)\n\t\tval |= MT_TXD1_ETH_802_3;\n\n\ttxwi[1] |= cpu_to_le32(val);\n\n\tfc_type = IEEE80211_FTYPE_DATA >> 2;\n\tfc_stype = wmm ? IEEE80211_STYPE_QOS_DATA >> 4 : 0;\n\n\tval = FIELD_PREP(MT_TXD2_FRAME_TYPE, fc_type) |\n\t      FIELD_PREP(MT_TXD2_SUB_TYPE, fc_stype);\n\n\ttxwi[2] |= cpu_to_le32(val);\n\n\tval = FIELD_PREP(MT_TXD7_TYPE, fc_type) |\n\t      FIELD_PREP(MT_TXD7_SUB_TYPE, fc_stype);\n\n\ttxwi[7] |= cpu_to_le32(val);\n}\n\nstatic void\nmt76_connac2_mac_write_txwi_80211(struct mt76_dev *dev, __le32 *txwi,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct ieee80211_key_conf *key)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tbool multicast = is_multicast_ether_addr(hdr->addr1);\n\tu8 tid = skb->priority & IEEE80211_QOS_CTL_TID_MASK;\n\t__le16 fc = hdr->frame_control;\n\tu8 fc_type, fc_stype;\n\tu32 val;\n\n\tif (ieee80211_is_action(fc) &&\n\t    mgmt->u.action.category == WLAN_CATEGORY_BACK &&\n\t    mgmt->u.action.u.addba_req.action_code == WLAN_ACTION_ADDBA_REQ) {\n\t\tu16 capab = le16_to_cpu(mgmt->u.action.u.addba_req.capab);\n\n\t\ttxwi[5] |= cpu_to_le32(MT_TXD5_ADD_BA);\n\t\ttid = (capab >> 2) & IEEE80211_QOS_CTL_TID_MASK;\n\t} else if (ieee80211_is_back_req(hdr->frame_control)) {\n\t\tstruct ieee80211_bar *bar = (struct ieee80211_bar *)hdr;\n\t\tu16 control = le16_to_cpu(bar->control);\n\n\t\ttid = FIELD_GET(IEEE80211_BAR_CTRL_TID_INFO_MASK, control);\n\t}\n\n\tval = FIELD_PREP(MT_TXD1_HDR_FORMAT, MT_HDR_FORMAT_802_11) |\n\t      FIELD_PREP(MT_TXD1_HDR_INFO,\n\t\t\t ieee80211_get_hdrlen_from_skb(skb) / 2) |\n\t      FIELD_PREP(MT_TXD1_TID, tid);\n\n\ttxwi[1] |= cpu_to_le32(val);\n\n\tfc_type = (le16_to_cpu(fc) & IEEE80211_FCTL_FTYPE) >> 2;\n\tfc_stype = (le16_to_cpu(fc) & IEEE80211_FCTL_STYPE) >> 4;\n\n\tval = FIELD_PREP(MT_TXD2_FRAME_TYPE, fc_type) |\n\t      FIELD_PREP(MT_TXD2_SUB_TYPE, fc_stype) |\n\t      FIELD_PREP(MT_TXD2_MULTICAST, multicast);\n\n\tif (key && multicast && ieee80211_is_robust_mgmt_frame(skb) &&\n\t    key->cipher == WLAN_CIPHER_SUITE_AES_CMAC) {\n\t\tval |= MT_TXD2_BIP;\n\t\ttxwi[3] &= ~cpu_to_le32(MT_TXD3_PROTECT_FRAME);\n\t}\n\n\tif (!ieee80211_is_data(fc) || multicast ||\n\t    info->flags & IEEE80211_TX_CTL_USE_MINRATE)\n\t\tval |= MT_TXD2_FIX_RATE;\n\n\ttxwi[2] |= cpu_to_le32(val);\n\n\tif (ieee80211_is_beacon(fc)) {\n\t\ttxwi[3] &= ~cpu_to_le32(MT_TXD3_SW_POWER_MGMT);\n\t\ttxwi[3] |= cpu_to_le32(MT_TXD3_REM_TX_COUNT);\n\t}\n\n\tif (info->flags & IEEE80211_TX_CTL_INJECTED) {\n\t\tu16 seqno = le16_to_cpu(hdr->seq_ctrl);\n\n\t\tif (ieee80211_is_back_req(hdr->frame_control)) {\n\t\t\tstruct ieee80211_bar *bar;\n\n\t\t\tbar = (struct ieee80211_bar *)skb->data;\n\t\t\tseqno = le16_to_cpu(bar->start_seq_num);\n\t\t}\n\n\t\tval = MT_TXD3_SN_VALID |\n\t\t      FIELD_PREP(MT_TXD3_SEQ, IEEE80211_SEQ_TO_SN(seqno));\n\t\ttxwi[3] |= cpu_to_le32(val);\n\t\ttxwi[7] &= ~cpu_to_le32(MT_TXD7_HW_AMSDU);\n\t}\n\n\tif (mt76_is_mmio(dev)) {\n\t\tval = FIELD_PREP(MT_TXD7_TYPE, fc_type) |\n\t\t      FIELD_PREP(MT_TXD7_SUB_TYPE, fc_stype);\n\t\ttxwi[7] |= cpu_to_le32(val);\n\t} else {\n\t\tval = FIELD_PREP(MT_TXD8_L_TYPE, fc_type) |\n\t\t      FIELD_PREP(MT_TXD8_L_SUB_TYPE, fc_stype);\n\t\ttxwi[8] |= cpu_to_le32(val);\n\t}\n}\n\nvoid mt76_connac2_mac_write_txwi(struct mt76_dev *dev, __le32 *txwi,\n\t\t\t\t struct sk_buff *skb, struct mt76_wcid *wcid,\n\t\t\t\t struct ieee80211_key_conf *key, int pid,\n\t\t\t\t enum mt76_txq_id qid, u32 changed)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tu8 phy_idx = (info->hw_queue & MT_TX_HW_QUEUE_PHY) >> 2;\n\tstruct ieee80211_vif *vif = info->control.vif;\n\tstruct mt76_phy *mphy = &dev->phy;\n\tu8 p_fmt, q_idx, omac_idx = 0, wmm_idx = 0, band_idx = 0;\n\tu32 val, sz_txd = mt76_is_mmio(dev) ? MT_TXD_SIZE : MT_SDIO_TXD_SIZE;\n\tbool is_8023 = info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP;\n\tbool beacon = !!(changed & (BSS_CHANGED_BEACON |\n\t\t\t\t    BSS_CHANGED_BEACON_ENABLED));\n\tbool inband_disc = !!(changed & (BSS_CHANGED_UNSOL_BCAST_PROBE_RESP |\n\t\t\t\t\t BSS_CHANGED_FILS_DISCOVERY));\n\tbool amsdu_en = wcid->amsdu;\n\n\tif (vif) {\n\t\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\n\t\tomac_idx = mvif->omac_idx;\n\t\twmm_idx = mvif->wmm_idx;\n\t\tband_idx = mvif->band_idx;\n\t}\n\n\tif (phy_idx && dev->phys[MT_BAND1])\n\t\tmphy = dev->phys[MT_BAND1];\n\n\tif (inband_disc) {\n\t\tp_fmt = MT_TX_TYPE_FW;\n\t\tq_idx = MT_LMAC_ALTX0;\n\t} else if (beacon) {\n\t\tp_fmt = MT_TX_TYPE_FW;\n\t\tq_idx = MT_LMAC_BCN0;\n\t} else if (qid >= MT_TXQ_PSD) {\n\t\tp_fmt = mt76_is_mmio(dev) ? MT_TX_TYPE_CT : MT_TX_TYPE_SF;\n\t\tq_idx = MT_LMAC_ALTX0;\n\t} else {\n\t\tp_fmt = mt76_is_mmio(dev) ? MT_TX_TYPE_CT : MT_TX_TYPE_SF;\n\t\tq_idx = wmm_idx * MT76_CONNAC_MAX_WMM_SETS +\n\t\t\tmt76_connac_lmac_mapping(skb_get_queue_mapping(skb));\n\n\t\t \n\t\tif (is_mt7915(dev) && mtk_wed_device_active(&dev->mmio.wed))\n\t\t\twcid->stats.tx_packets++;\n\t}\n\n\tval = FIELD_PREP(MT_TXD0_TX_BYTES, skb->len + sz_txd) |\n\t      FIELD_PREP(MT_TXD0_PKT_FMT, p_fmt) |\n\t      FIELD_PREP(MT_TXD0_Q_IDX, q_idx);\n\ttxwi[0] = cpu_to_le32(val);\n\n\tval = MT_TXD1_LONG_FORMAT |\n\t      FIELD_PREP(MT_TXD1_WLAN_IDX, wcid->idx) |\n\t      FIELD_PREP(MT_TXD1_OWN_MAC, omac_idx);\n\tif (!is_mt7921(dev))\n\t\tval |= MT_TXD1_VTA;\n\tif (phy_idx || band_idx)\n\t\tval |= MT_TXD1_TGID;\n\n\ttxwi[1] = cpu_to_le32(val);\n\ttxwi[2] = 0;\n\n\tval = FIELD_PREP(MT_TXD3_REM_TX_COUNT, 15);\n\tif (!is_mt7921(dev))\n\t\tval |= MT_TXD3_SW_POWER_MGMT;\n\tif (key)\n\t\tval |= MT_TXD3_PROTECT_FRAME;\n\tif (info->flags & IEEE80211_TX_CTL_NO_ACK)\n\t\tval |= MT_TXD3_NO_ACK;\n\n\ttxwi[3] = cpu_to_le32(val);\n\ttxwi[4] = 0;\n\n\tval = FIELD_PREP(MT_TXD5_PID, pid);\n\tif (pid >= MT_PACKET_ID_FIRST) {\n\t\tval |= MT_TXD5_TX_STATUS_HOST;\n\t\tamsdu_en = amsdu_en && !is_mt7921(dev);\n\t}\n\n\ttxwi[5] = cpu_to_le32(val);\n\ttxwi[6] = 0;\n\ttxwi[7] = amsdu_en ? cpu_to_le32(MT_TXD7_HW_AMSDU) : 0;\n\n\tif (is_8023)\n\t\tmt76_connac2_mac_write_txwi_8023(txwi, skb, wcid);\n\telse\n\t\tmt76_connac2_mac_write_txwi_80211(dev, txwi, skb, key);\n\n\tif (txwi[2] & cpu_to_le32(MT_TXD2_FIX_RATE)) {\n\t\t \n\t\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\t\tbool multicast = ieee80211_is_data(hdr->frame_control) &&\n\t\t\t\t is_multicast_ether_addr(hdr->addr1);\n\t\tu16 rate = mt76_connac2_mac_tx_rate_val(mphy, vif, beacon,\n\t\t\t\t\t\t\tmulticast);\n\t\tu32 val = MT_TXD6_FIXED_BW;\n\n\t\t \n\t\ttxwi[2] |= cpu_to_le32(MT_TXD2_HTC_VLD);\n\n\t\tval |= FIELD_PREP(MT_TXD6_TX_RATE, rate);\n\t\ttxwi[6] |= cpu_to_le32(val);\n\t\ttxwi[3] |= cpu_to_le32(MT_TXD3_BA_DISABLE);\n\n\t\tif (!is_mt7921(dev)) {\n\t\t\tu8 spe_idx = mt76_connac_spe_idx(mphy->antenna_mask);\n\n\t\t\tif (!spe_idx)\n\t\t\t\tspe_idx = 24 + phy_idx;\n\t\t\ttxwi[7] |= cpu_to_le32(FIELD_PREP(MT_TXD7_SPE_IDX, spe_idx));\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(mt76_connac2_mac_write_txwi);\n\nbool mt76_connac2_mac_fill_txs(struct mt76_dev *dev, struct mt76_wcid *wcid,\n\t\t\t       __le32 *txs_data)\n{\n\tstruct mt76_sta_stats *stats = &wcid->stats;\n\tstruct ieee80211_supported_band *sband;\n\tstruct mt76_phy *mphy;\n\tstruct rate_info rate = {};\n\tbool cck = false;\n\tu32 txrate, txs, mode, stbc;\n\n\ttxs = le32_to_cpu(txs_data[0]);\n\n\t \n\tif (mtk_wed_device_active(&dev->mmio.wed) &&\n\t    FIELD_GET(MT_TXS0_TXS_FORMAT, txs) > 1) {\n\t\tstats->tx_bytes +=\n\t\t\tle32_get_bits(txs_data[5], MT_TXS5_MPDU_TX_BYTE) -\n\t\t\tle32_get_bits(txs_data[7], MT_TXS7_MPDU_RETRY_BYTE);\n\t\tstats->tx_failed +=\n\t\t\tle32_get_bits(txs_data[6], MT_TXS6_MPDU_FAIL_CNT);\n\t\tstats->tx_retries +=\n\t\t\tle32_get_bits(txs_data[7], MT_TXS7_MPDU_RETRY_CNT);\n\n\t\tif (wcid->sta) {\n\t\t\tstruct ieee80211_sta *sta;\n\t\t\tu8 tid;\n\n\t\t\tsta = container_of((void *)wcid, struct ieee80211_sta,\n\t\t\t\t\t   drv_priv);\n\t\t\ttid = FIELD_GET(MT_TXS0_TID, txs);\n\n\t\t\tieee80211_refresh_tx_agg_session_timer(sta, tid);\n\t\t}\n\t}\n\n\ttxrate = FIELD_GET(MT_TXS0_TX_RATE, txs);\n\n\trate.mcs = FIELD_GET(MT_TX_RATE_IDX, txrate);\n\trate.nss = FIELD_GET(MT_TX_RATE_NSS, txrate) + 1;\n\tstbc = FIELD_GET(MT_TX_RATE_STBC, txrate);\n\n\tif (stbc && rate.nss > 1)\n\t\trate.nss >>= 1;\n\n\tif (rate.nss - 1 < ARRAY_SIZE(stats->tx_nss))\n\t\tstats->tx_nss[rate.nss - 1]++;\n\tif (rate.mcs < ARRAY_SIZE(stats->tx_mcs))\n\t\tstats->tx_mcs[rate.mcs]++;\n\n\tmode = FIELD_GET(MT_TX_RATE_MODE, txrate);\n\tswitch (mode) {\n\tcase MT_PHY_TYPE_CCK:\n\t\tcck = true;\n\t\tfallthrough;\n\tcase MT_PHY_TYPE_OFDM:\n\t\tmphy = &dev->phy;\n\t\tif (wcid->phy_idx == MT_BAND1 && dev->phys[MT_BAND1])\n\t\t\tmphy = dev->phys[MT_BAND1];\n\n\t\tif (mphy->chandef.chan->band == NL80211_BAND_5GHZ)\n\t\t\tsband = &mphy->sband_5g.sband;\n\t\telse if (mphy->chandef.chan->band == NL80211_BAND_6GHZ)\n\t\t\tsband = &mphy->sband_6g.sband;\n\t\telse\n\t\t\tsband = &mphy->sband_2g.sband;\n\n\t\trate.mcs = mt76_get_rate(mphy->dev, sband, rate.mcs, cck);\n\t\trate.legacy = sband->bitrates[rate.mcs].bitrate;\n\t\tbreak;\n\tcase MT_PHY_TYPE_HT:\n\tcase MT_PHY_TYPE_HT_GF:\n\t\tif (rate.mcs > 31)\n\t\t\treturn false;\n\n\t\trate.flags = RATE_INFO_FLAGS_MCS;\n\t\tif (wcid->rate.flags & RATE_INFO_FLAGS_SHORT_GI)\n\t\t\trate.flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t\tbreak;\n\tcase MT_PHY_TYPE_VHT:\n\t\tif (rate.mcs > 9)\n\t\t\treturn false;\n\n\t\trate.flags = RATE_INFO_FLAGS_VHT_MCS;\n\t\tbreak;\n\tcase MT_PHY_TYPE_HE_SU:\n\tcase MT_PHY_TYPE_HE_EXT_SU:\n\tcase MT_PHY_TYPE_HE_TB:\n\tcase MT_PHY_TYPE_HE_MU:\n\t\tif (rate.mcs > 11)\n\t\t\treturn false;\n\n\t\trate.he_gi = wcid->rate.he_gi;\n\t\trate.he_dcm = FIELD_GET(MT_TX_RATE_DCM, txrate);\n\t\trate.flags = RATE_INFO_FLAGS_HE_MCS;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tstats->tx_mode[mode]++;\n\n\tswitch (FIELD_GET(MT_TXS0_BW, txs)) {\n\tcase IEEE80211_STA_RX_BW_160:\n\t\trate.bw = RATE_INFO_BW_160;\n\t\tstats->tx_bw[3]++;\n\t\tbreak;\n\tcase IEEE80211_STA_RX_BW_80:\n\t\trate.bw = RATE_INFO_BW_80;\n\t\tstats->tx_bw[2]++;\n\t\tbreak;\n\tcase IEEE80211_STA_RX_BW_40:\n\t\trate.bw = RATE_INFO_BW_40;\n\t\tstats->tx_bw[1]++;\n\t\tbreak;\n\tdefault:\n\t\trate.bw = RATE_INFO_BW_20;\n\t\tstats->tx_bw[0]++;\n\t\tbreak;\n\t}\n\twcid->rate = rate;\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(mt76_connac2_mac_fill_txs);\n\nbool mt76_connac2_mac_add_txs_skb(struct mt76_dev *dev, struct mt76_wcid *wcid,\n\t\t\t\t  int pid, __le32 *txs_data)\n{\n\tstruct sk_buff_head list;\n\tstruct sk_buff *skb;\n\n\tmt76_tx_status_lock(dev, &list);\n\tskb = mt76_tx_status_skb_get(dev, wcid, pid, &list);\n\tif (skb) {\n\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\n\t\tif (!(le32_to_cpu(txs_data[0]) & MT_TXS0_ACK_ERROR_MASK))\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\n\t\tinfo->status.ampdu_len = 1;\n\t\tinfo->status.ampdu_ack_len =\n\t\t\t!!(info->flags & IEEE80211_TX_STAT_ACK);\n\t\tinfo->status.rates[0].idx = -1;\n\n\t\tmt76_connac2_mac_fill_txs(dev, wcid, txs_data);\n\t\tmt76_tx_status_skb_done(dev, skb, &list);\n\t}\n\tmt76_tx_status_unlock(dev, &list);\n\n\treturn !!skb;\n}\nEXPORT_SYMBOL_GPL(mt76_connac2_mac_add_txs_skb);\n\nstatic void\nmt76_connac2_mac_decode_he_radiotap_ru(struct mt76_rx_status *status,\n\t\t\t\t       struct ieee80211_radiotap_he *he,\n\t\t\t\t       __le32 *rxv)\n{\n\tu32 ru_h, ru_l;\n\tu8 ru, offs = 0;\n\n\tru_l = le32_get_bits(rxv[0], MT_PRXV_HE_RU_ALLOC_L);\n\tru_h = le32_get_bits(rxv[1], MT_PRXV_HE_RU_ALLOC_H);\n\tru = (u8)(ru_l | ru_h << 4);\n\n\tstatus->bw = RATE_INFO_BW_HE_RU;\n\n\tswitch (ru) {\n\tcase 0 ... 36:\n\t\tstatus->he_ru = NL80211_RATE_INFO_HE_RU_ALLOC_26;\n\t\toffs = ru;\n\t\tbreak;\n\tcase 37 ... 52:\n\t\tstatus->he_ru = NL80211_RATE_INFO_HE_RU_ALLOC_52;\n\t\toffs = ru - 37;\n\t\tbreak;\n\tcase 53 ... 60:\n\t\tstatus->he_ru = NL80211_RATE_INFO_HE_RU_ALLOC_106;\n\t\toffs = ru - 53;\n\t\tbreak;\n\tcase 61 ... 64:\n\t\tstatus->he_ru = NL80211_RATE_INFO_HE_RU_ALLOC_242;\n\t\toffs = ru - 61;\n\t\tbreak;\n\tcase 65 ... 66:\n\t\tstatus->he_ru = NL80211_RATE_INFO_HE_RU_ALLOC_484;\n\t\toffs = ru - 65;\n\t\tbreak;\n\tcase 67:\n\t\tstatus->he_ru = NL80211_RATE_INFO_HE_RU_ALLOC_996;\n\t\tbreak;\n\tcase 68:\n\t\tstatus->he_ru = NL80211_RATE_INFO_HE_RU_ALLOC_2x996;\n\t\tbreak;\n\t}\n\n\the->data1 |= HE_BITS(DATA1_BW_RU_ALLOC_KNOWN);\n\the->data2 |= HE_BITS(DATA2_RU_OFFSET_KNOWN) |\n\t\t     le16_encode_bits(offs,\n\t\t\t\t      IEEE80211_RADIOTAP_HE_DATA2_RU_OFFSET);\n}\n\nstatic void\nmt76_connac2_mac_decode_he_mu_radiotap(struct mt76_dev *dev, struct sk_buff *skb,\n\t\t\t\t       __le32 *rxv)\n{\n\tstruct mt76_rx_status *status = (struct mt76_rx_status *)skb->cb;\n\tstatic struct ieee80211_radiotap_he_mu mu_known = {\n\t\t.flags1 = HE_BITS(MU_FLAGS1_SIG_B_MCS_KNOWN) |\n\t\t\t  HE_BITS(MU_FLAGS1_SIG_B_DCM_KNOWN) |\n\t\t\t  HE_BITS(MU_FLAGS1_CH1_RU_KNOWN) |\n\t\t\t  HE_BITS(MU_FLAGS1_SIG_B_SYMS_USERS_KNOWN),\n\t\t.flags2 = HE_BITS(MU_FLAGS2_BW_FROM_SIG_A_BW_KNOWN),\n\t};\n\tstruct ieee80211_radiotap_he_mu *he_mu;\n\n\tif (is_mt7921(dev)) {\n\t\tmu_known.flags1 |= HE_BITS(MU_FLAGS1_SIG_B_COMP_KNOWN);\n\t\tmu_known.flags2 |= HE_BITS(MU_FLAGS2_PUNC_FROM_SIG_A_BW_KNOWN);\n\t}\n\n\tstatus->flag |= RX_FLAG_RADIOTAP_HE_MU;\n\n\the_mu = skb_push(skb, sizeof(mu_known));\n\tmemcpy(he_mu, &mu_known, sizeof(mu_known));\n\n#define MU_PREP(f, v)\tle16_encode_bits(v, IEEE80211_RADIOTAP_HE_MU_##f)\n\n\the_mu->flags1 |= MU_PREP(FLAGS1_SIG_B_MCS, status->rate_idx);\n\tif (status->he_dcm)\n\t\the_mu->flags1 |= MU_PREP(FLAGS1_SIG_B_DCM, status->he_dcm);\n\n\the_mu->flags2 |= MU_PREP(FLAGS2_BW_FROM_SIG_A_BW, status->bw) |\n\t\t\t MU_PREP(FLAGS2_SIG_B_SYMS_USERS,\n\t\t\t\t le32_get_bits(rxv[2], MT_CRXV_HE_NUM_USER));\n\n\the_mu->ru_ch1[0] = le32_get_bits(rxv[3], MT_CRXV_HE_RU0);\n\n\tif (status->bw >= RATE_INFO_BW_40) {\n\t\the_mu->flags1 |= HE_BITS(MU_FLAGS1_CH2_RU_KNOWN);\n\t\the_mu->ru_ch2[0] =\n\t\t\tle32_get_bits(rxv[3], MT_CRXV_HE_RU1);\n\t}\n\n\tif (status->bw >= RATE_INFO_BW_80) {\n\t\the_mu->ru_ch1[1] =\n\t\t\tle32_get_bits(rxv[3], MT_CRXV_HE_RU2);\n\t\the_mu->ru_ch2[1] =\n\t\t\tle32_get_bits(rxv[3], MT_CRXV_HE_RU3);\n\t}\n}\n\nvoid mt76_connac2_mac_decode_he_radiotap(struct mt76_dev *dev,\n\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t __le32 *rxv, u32 mode)\n{\n\tstruct mt76_rx_status *status = (struct mt76_rx_status *)skb->cb;\n\tstatic const struct ieee80211_radiotap_he known = {\n\t\t.data1 = HE_BITS(DATA1_DATA_MCS_KNOWN) |\n\t\t\t HE_BITS(DATA1_DATA_DCM_KNOWN) |\n\t\t\t HE_BITS(DATA1_STBC_KNOWN) |\n\t\t\t HE_BITS(DATA1_CODING_KNOWN) |\n\t\t\t HE_BITS(DATA1_LDPC_XSYMSEG_KNOWN) |\n\t\t\t HE_BITS(DATA1_DOPPLER_KNOWN) |\n\t\t\t HE_BITS(DATA1_SPTL_REUSE_KNOWN) |\n\t\t\t HE_BITS(DATA1_BSS_COLOR_KNOWN),\n\t\t.data2 = HE_BITS(DATA2_GI_KNOWN) |\n\t\t\t HE_BITS(DATA2_TXBF_KNOWN) |\n\t\t\t HE_BITS(DATA2_PE_DISAMBIG_KNOWN) |\n\t\t\t HE_BITS(DATA2_TXOP_KNOWN),\n\t};\n\tu32 ltf_size = le32_get_bits(rxv[2], MT_CRXV_HE_LTF_SIZE) + 1;\n\tstruct ieee80211_radiotap_he *he;\n\n\tstatus->flag |= RX_FLAG_RADIOTAP_HE;\n\n\the = skb_push(skb, sizeof(known));\n\tmemcpy(he, &known, sizeof(known));\n\n\the->data3 = HE_PREP(DATA3_BSS_COLOR, BSS_COLOR, rxv[14]) |\n\t\t    HE_PREP(DATA3_LDPC_XSYMSEG, LDPC_EXT_SYM, rxv[2]);\n\the->data4 = HE_PREP(DATA4_SU_MU_SPTL_REUSE, SR_MASK, rxv[11]);\n\the->data5 = HE_PREP(DATA5_PE_DISAMBIG, PE_DISAMBIG, rxv[2]) |\n\t\t    le16_encode_bits(ltf_size,\n\t\t\t\t     IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE);\n\tif (le32_to_cpu(rxv[0]) & MT_PRXV_TXBF)\n\t\the->data5 |= HE_BITS(DATA5_TXBF);\n\the->data6 = HE_PREP(DATA6_TXOP, TXOP_DUR, rxv[14]) |\n\t\t    HE_PREP(DATA6_DOPPLER, DOPPLER, rxv[14]);\n\n\tswitch (mode) {\n\tcase MT_PHY_TYPE_HE_SU:\n\t\the->data1 |= HE_BITS(DATA1_FORMAT_SU) |\n\t\t\t     HE_BITS(DATA1_UL_DL_KNOWN) |\n\t\t\t     HE_BITS(DATA1_BEAM_CHANGE_KNOWN) |\n\t\t\t     HE_BITS(DATA1_BW_RU_ALLOC_KNOWN);\n\n\t\the->data3 |= HE_PREP(DATA3_BEAM_CHANGE, BEAM_CHNG, rxv[14]) |\n\t\t\t     HE_PREP(DATA3_UL_DL, UPLINK, rxv[2]);\n\t\tbreak;\n\tcase MT_PHY_TYPE_HE_EXT_SU:\n\t\the->data1 |= HE_BITS(DATA1_FORMAT_EXT_SU) |\n\t\t\t     HE_BITS(DATA1_UL_DL_KNOWN) |\n\t\t\t     HE_BITS(DATA1_BW_RU_ALLOC_KNOWN);\n\n\t\the->data3 |= HE_PREP(DATA3_UL_DL, UPLINK, rxv[2]);\n\t\tbreak;\n\tcase MT_PHY_TYPE_HE_MU:\n\t\the->data1 |= HE_BITS(DATA1_FORMAT_MU) |\n\t\t\t     HE_BITS(DATA1_UL_DL_KNOWN);\n\n\t\the->data3 |= HE_PREP(DATA3_UL_DL, UPLINK, rxv[2]);\n\t\the->data4 |= HE_PREP(DATA4_MU_STA_ID, MU_AID, rxv[7]);\n\n\t\tmt76_connac2_mac_decode_he_radiotap_ru(status, he, rxv);\n\t\tmt76_connac2_mac_decode_he_mu_radiotap(dev, skb, rxv);\n\t\tbreak;\n\tcase MT_PHY_TYPE_HE_TB:\n\t\the->data1 |= HE_BITS(DATA1_FORMAT_TRIG) |\n\t\t\t     HE_BITS(DATA1_SPTL_REUSE2_KNOWN) |\n\t\t\t     HE_BITS(DATA1_SPTL_REUSE3_KNOWN) |\n\t\t\t     HE_BITS(DATA1_SPTL_REUSE4_KNOWN);\n\n\t\the->data4 |= HE_PREP(DATA4_TB_SPTL_REUSE1, SR_MASK, rxv[11]) |\n\t\t\t     HE_PREP(DATA4_TB_SPTL_REUSE2, SR1_MASK, rxv[11]) |\n\t\t\t     HE_PREP(DATA4_TB_SPTL_REUSE3, SR2_MASK, rxv[11]) |\n\t\t\t     HE_PREP(DATA4_TB_SPTL_REUSE4, SR3_MASK, rxv[11]);\n\n\t\tmt76_connac2_mac_decode_he_radiotap_ru(status, he, rxv);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(mt76_connac2_mac_decode_he_radiotap);\n\n \nint mt76_connac2_reverse_frag0_hdr_trans(struct ieee80211_vif *vif,\n\t\t\t\t\t struct sk_buff *skb, u16 hdr_offset)\n{\n\tstruct mt76_rx_status *status = (struct mt76_rx_status *)skb->cb;\n\tstruct ethhdr *eth_hdr = (struct ethhdr *)(skb->data + hdr_offset);\n\t__le32 *rxd = (__le32 *)skb->data;\n\tstruct ieee80211_sta *sta;\n\tstruct ieee80211_hdr hdr;\n\tu16 frame_control;\n\n\tif (le32_get_bits(rxd[3], MT_RXD3_NORMAL_ADDR_TYPE) !=\n\t    MT_RXD3_NORMAL_U2M)\n\t\treturn -EINVAL;\n\n\tif (!(le32_to_cpu(rxd[1]) & MT_RXD1_NORMAL_GROUP_4))\n\t\treturn -EINVAL;\n\n\tsta = container_of((void *)status->wcid, struct ieee80211_sta, drv_priv);\n\n\t \n\tframe_control = le32_get_bits(rxd[6], MT_RXD6_FRAME_CONTROL);\n\thdr.frame_control = cpu_to_le16(frame_control);\n\thdr.seq_ctrl = cpu_to_le16(le32_get_bits(rxd[8], MT_RXD8_SEQ_CTRL));\n\thdr.duration_id = 0;\n\n\tether_addr_copy(hdr.addr1, vif->addr);\n\tether_addr_copy(hdr.addr2, sta->addr);\n\tswitch (frame_control & (IEEE80211_FCTL_TODS |\n\t\t\t\t IEEE80211_FCTL_FROMDS)) {\n\tcase 0:\n\t\tether_addr_copy(hdr.addr3, vif->bss_conf.bssid);\n\t\tbreak;\n\tcase IEEE80211_FCTL_FROMDS:\n\t\tether_addr_copy(hdr.addr3, eth_hdr->h_source);\n\t\tbreak;\n\tcase IEEE80211_FCTL_TODS:\n\t\tether_addr_copy(hdr.addr3, eth_hdr->h_dest);\n\t\tbreak;\n\tcase IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS:\n\t\tether_addr_copy(hdr.addr3, eth_hdr->h_dest);\n\t\tether_addr_copy(hdr.addr4, eth_hdr->h_source);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tskb_pull(skb, hdr_offset + sizeof(struct ethhdr) - 2);\n\tif (eth_hdr->h_proto == cpu_to_be16(ETH_P_AARP) ||\n\t    eth_hdr->h_proto == cpu_to_be16(ETH_P_IPX))\n\t\tether_addr_copy(skb_push(skb, ETH_ALEN), bridge_tunnel_header);\n\telse if (be16_to_cpu(eth_hdr->h_proto) >= ETH_P_802_3_MIN)\n\t\tether_addr_copy(skb_push(skb, ETH_ALEN), rfc1042_header);\n\telse\n\t\tskb_pull(skb, 2);\n\n\tif (ieee80211_has_order(hdr.frame_control))\n\t\tmemcpy(skb_push(skb, IEEE80211_HT_CTL_LEN), &rxd[9],\n\t\t       IEEE80211_HT_CTL_LEN);\n\tif (ieee80211_is_data_qos(hdr.frame_control)) {\n\t\t__le16 qos_ctrl;\n\n\t\tqos_ctrl = cpu_to_le16(le32_get_bits(rxd[8], MT_RXD8_QOS_CTL));\n\t\tmemcpy(skb_push(skb, IEEE80211_QOS_CTL_LEN), &qos_ctrl,\n\t\t       IEEE80211_QOS_CTL_LEN);\n\t}\n\n\tif (ieee80211_has_a4(hdr.frame_control))\n\t\tmemcpy(skb_push(skb, sizeof(hdr)), &hdr, sizeof(hdr));\n\telse\n\t\tmemcpy(skb_push(skb, sizeof(hdr) - 6), &hdr, sizeof(hdr) - 6);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76_connac2_reverse_frag0_hdr_trans);\n\nint mt76_connac2_mac_fill_rx_rate(struct mt76_dev *dev,\n\t\t\t\t  struct mt76_rx_status *status,\n\t\t\t\t  struct ieee80211_supported_band *sband,\n\t\t\t\t  __le32 *rxv, u8 *mode)\n{\n\tu32 v0, v2;\n\tu8 stbc, gi, bw, dcm, nss;\n\tint i, idx;\n\tbool cck = false;\n\n\tv0 = le32_to_cpu(rxv[0]);\n\tv2 = le32_to_cpu(rxv[2]);\n\n\tidx = i = FIELD_GET(MT_PRXV_TX_RATE, v0);\n\tnss = FIELD_GET(MT_PRXV_NSTS, v0) + 1;\n\n\tif (!is_mt7915(dev)) {\n\t\tstbc = FIELD_GET(MT_PRXV_HT_STBC, v0);\n\t\tgi = FIELD_GET(MT_PRXV_HT_SGI, v0);\n\t\t*mode = FIELD_GET(MT_PRXV_TX_MODE, v0);\n\t\tif (is_mt7921(dev))\n\t\t\tdcm = !!(idx & MT_PRXV_TX_DCM);\n\t\telse\n\t\t\tdcm = FIELD_GET(MT_PRXV_DCM, v0);\n\t\tbw = FIELD_GET(MT_PRXV_FRAME_MODE, v0);\n\t} else {\n\t\tstbc = FIELD_GET(MT_CRXV_HT_STBC, v2);\n\t\tgi = FIELD_GET(MT_CRXV_HT_SHORT_GI, v2);\n\t\t*mode = FIELD_GET(MT_CRXV_TX_MODE, v2);\n\t\tdcm = !!(idx & GENMASK(3, 0) & MT_PRXV_TX_DCM);\n\t\tbw = FIELD_GET(MT_CRXV_FRAME_MODE, v2);\n\t}\n\n\tswitch (*mode) {\n\tcase MT_PHY_TYPE_CCK:\n\t\tcck = true;\n\t\tfallthrough;\n\tcase MT_PHY_TYPE_OFDM:\n\t\ti = mt76_get_rate(dev, sband, i, cck);\n\t\tbreak;\n\tcase MT_PHY_TYPE_HT_GF:\n\tcase MT_PHY_TYPE_HT:\n\t\tstatus->encoding = RX_ENC_HT;\n\t\tif (gi)\n\t\t\tstatus->enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\t\tif (i > 31)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase MT_PHY_TYPE_VHT:\n\t\tstatus->nss = nss;\n\t\tstatus->encoding = RX_ENC_VHT;\n\t\tif (gi)\n\t\t\tstatus->enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\t\tif (i > 11)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase MT_PHY_TYPE_HE_MU:\n\tcase MT_PHY_TYPE_HE_SU:\n\tcase MT_PHY_TYPE_HE_EXT_SU:\n\tcase MT_PHY_TYPE_HE_TB:\n\t\tstatus->nss = nss;\n\t\tstatus->encoding = RX_ENC_HE;\n\t\ti &= GENMASK(3, 0);\n\n\t\tif (gi <= NL80211_RATE_INFO_HE_GI_3_2)\n\t\t\tstatus->he_gi = gi;\n\n\t\tstatus->he_dcm = dcm;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tstatus->rate_idx = i;\n\n\tswitch (bw) {\n\tcase IEEE80211_STA_RX_BW_20:\n\t\tbreak;\n\tcase IEEE80211_STA_RX_BW_40:\n\t\tif (*mode & MT_PHY_TYPE_HE_EXT_SU &&\n\t\t    (idx & MT_PRXV_TX_ER_SU_106T)) {\n\t\t\tstatus->bw = RATE_INFO_BW_HE_RU;\n\t\t\tstatus->he_ru =\n\t\t\t\tNL80211_RATE_INFO_HE_RU_ALLOC_106;\n\t\t} else {\n\t\t\tstatus->bw = RATE_INFO_BW_40;\n\t\t}\n\t\tbreak;\n\tcase IEEE80211_STA_RX_BW_80:\n\t\tstatus->bw = RATE_INFO_BW_80;\n\t\tbreak;\n\tcase IEEE80211_STA_RX_BW_160:\n\t\tstatus->bw = RATE_INFO_BW_160;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tstatus->enc_flags |= RX_ENC_FLAG_STBC_MASK * stbc;\n\tif (*mode < MT_PHY_TYPE_HE_SU && gi)\n\t\tstatus->enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76_connac2_mac_fill_rx_rate);\n\nvoid mt76_connac2_tx_check_aggr(struct ieee80211_sta *sta, __le32 *txwi)\n{\n\tstruct mt76_wcid *wcid;\n\tu16 fc, tid;\n\tu32 val;\n\n\tif (!sta ||\n\t    !(sta->deflink.ht_cap.ht_supported || sta->deflink.he_cap.has_he))\n\t\treturn;\n\n\ttid = le32_get_bits(txwi[1], MT_TXD1_TID);\n\tif (tid >= 6)  \n\t\treturn;\n\n\tval = le32_to_cpu(txwi[2]);\n\tfc = FIELD_GET(MT_TXD2_FRAME_TYPE, val) << 2 |\n\t     FIELD_GET(MT_TXD2_SUB_TYPE, val) << 4;\n\tif (unlikely(fc != (IEEE80211_FTYPE_DATA | IEEE80211_STYPE_QOS_DATA)))\n\t\treturn;\n\n\twcid = (struct mt76_wcid *)sta->drv_priv;\n\tif (!test_and_set_bit(tid, &wcid->ampdu_state))\n\t\tieee80211_start_tx_ba_session(sta, tid, 0);\n}\nEXPORT_SYMBOL_GPL(mt76_connac2_tx_check_aggr);\n\nvoid mt76_connac2_txwi_free(struct mt76_dev *dev, struct mt76_txwi_cache *t,\n\t\t\t    struct ieee80211_sta *sta,\n\t\t\t    struct list_head *free_list)\n{\n\tstruct mt76_wcid *wcid;\n\t__le32 *txwi;\n\tu16 wcid_idx;\n\n\tmt76_connac_txp_skb_unmap(dev, t);\n\tif (!t->skb)\n\t\tgoto out;\n\n\ttxwi = (__le32 *)mt76_get_txwi_ptr(dev, t);\n\tif (sta) {\n\t\twcid = (struct mt76_wcid *)sta->drv_priv;\n\t\twcid_idx = wcid->idx;\n\t} else {\n\t\twcid_idx = le32_get_bits(txwi[1], MT_TXD1_WLAN_IDX);\n\t\twcid = rcu_dereference(dev->wcid[wcid_idx]);\n\n\t\tif (wcid && wcid->sta) {\n\t\t\tsta = container_of((void *)wcid, struct ieee80211_sta,\n\t\t\t\t\t   drv_priv);\n\t\t\tspin_lock_bh(&dev->sta_poll_lock);\n\t\t\tif (list_empty(&wcid->poll_list))\n\t\t\t\tlist_add_tail(&wcid->poll_list,\n\t\t\t\t\t      &dev->sta_poll_list);\n\t\t\tspin_unlock_bh(&dev->sta_poll_lock);\n\t\t}\n\t}\n\n\tif (sta && likely(t->skb->protocol != cpu_to_be16(ETH_P_PAE)))\n\t\tmt76_connac2_tx_check_aggr(sta, txwi);\n\n\t__mt76_tx_complete_skb(dev, wcid_idx, t->skb, free_list);\nout:\n\tt->skb = NULL;\n\tmt76_put_txwi(dev, t);\n}\nEXPORT_SYMBOL_GPL(mt76_connac2_txwi_free);\n\nvoid mt76_connac2_tx_token_put(struct mt76_dev *dev)\n{\n\tstruct mt76_txwi_cache *txwi;\n\tint id;\n\n\tspin_lock_bh(&dev->token_lock);\n\tidr_for_each_entry(&dev->token, txwi, id) {\n\t\tmt76_connac2_txwi_free(dev, txwi, NULL, NULL);\n\t\tdev->token_count--;\n\t}\n\tspin_unlock_bh(&dev->token_lock);\n\tidr_destroy(&dev->token);\n}\nEXPORT_SYMBOL_GPL(mt76_connac2_tx_token_put);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}