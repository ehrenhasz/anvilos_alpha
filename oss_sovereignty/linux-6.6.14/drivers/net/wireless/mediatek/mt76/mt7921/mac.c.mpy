{
  "module_name": "mac.c",
  "hash_id": "9d6bc270fd3fc9d8282475a0ca6ff4361382e278b99c05ea5f7f417bb4c392b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7921/mac.c",
  "human_readable_source": "\n \n\n#include <linux/devcoredump.h>\n#include <linux/etherdevice.h>\n#include <linux/timekeeping.h>\n#include \"mt7921.h\"\n#include \"../dma.h\"\n#include \"../mt76_connac2_mac.h\"\n#include \"mcu.h\"\n\n#define MT_WTBL_TXRX_CAP_RATE_OFFSET\t7\n#define MT_WTBL_TXRX_RATE_G2_HE\t\t24\n#define MT_WTBL_TXRX_RATE_G2\t\t12\n\n#define MT_WTBL_AC0_CTT_OFFSET\t\t20\n\nbool mt7921_mac_wtbl_update(struct mt792x_dev *dev, int idx, u32 mask)\n{\n\tmt76_rmw(dev, MT_WTBL_UPDATE, MT_WTBL_UPDATE_WLAN_IDX,\n\t\t FIELD_PREP(MT_WTBL_UPDATE_WLAN_IDX, idx) | mask);\n\n\treturn mt76_poll(dev, MT_WTBL_UPDATE, MT_WTBL_UPDATE_BUSY,\n\t\t\t 0, 5000);\n}\n\nstatic u32 mt7921_mac_wtbl_lmac_addr(int idx, u8 offset)\n{\n\treturn MT_WTBL_LMAC_OFFS(idx, 0) + offset * 4;\n}\n\nstatic void mt7921_mac_sta_poll(struct mt792x_dev *dev)\n{\n\tstatic const u8 ac_to_tid[] = {\n\t\t[IEEE80211_AC_BE] = 0,\n\t\t[IEEE80211_AC_BK] = 1,\n\t\t[IEEE80211_AC_VI] = 4,\n\t\t[IEEE80211_AC_VO] = 6\n\t};\n\tstruct ieee80211_sta *sta;\n\tstruct mt792x_sta *msta;\n\tu32 tx_time[IEEE80211_NUM_ACS], rx_time[IEEE80211_NUM_ACS];\n\tLIST_HEAD(sta_poll_list);\n\tstruct rate_info *rate;\n\ts8 rssi[4];\n\tint i;\n\n\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\tlist_splice_init(&dev->mt76.sta_poll_list, &sta_poll_list);\n\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\n\twhile (true) {\n\t\tbool clear = false;\n\t\tu32 addr, val;\n\t\tu16 idx;\n\t\tu8 bw;\n\n\t\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\t\tif (list_empty(&sta_poll_list)) {\n\t\t\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\t\t\tbreak;\n\t\t}\n\t\tmsta = list_first_entry(&sta_poll_list,\n\t\t\t\t\tstruct mt792x_sta, wcid.poll_list);\n\t\tlist_del_init(&msta->wcid.poll_list);\n\t\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\n\t\tidx = msta->wcid.idx;\n\t\taddr = mt7921_mac_wtbl_lmac_addr(idx, MT_WTBL_AC0_CTT_OFFSET);\n\n\t\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\t\tu32 tx_last = msta->airtime_ac[i];\n\t\t\tu32 rx_last = msta->airtime_ac[i + 4];\n\n\t\t\tmsta->airtime_ac[i] = mt76_rr(dev, addr);\n\t\t\tmsta->airtime_ac[i + 4] = mt76_rr(dev, addr + 4);\n\n\t\t\ttx_time[i] = msta->airtime_ac[i] - tx_last;\n\t\t\trx_time[i] = msta->airtime_ac[i + 4] - rx_last;\n\n\t\t\tif ((tx_last | rx_last) & BIT(30))\n\t\t\t\tclear = true;\n\n\t\t\taddr += 8;\n\t\t}\n\n\t\tif (clear) {\n\t\t\tmt7921_mac_wtbl_update(dev, idx,\n\t\t\t\t\t       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);\n\t\t\tmemset(msta->airtime_ac, 0, sizeof(msta->airtime_ac));\n\t\t}\n\n\t\tif (!msta->wcid.sta)\n\t\t\tcontinue;\n\n\t\tsta = container_of((void *)msta, struct ieee80211_sta,\n\t\t\t\t   drv_priv);\n\t\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\t\tu8 q = mt76_connac_lmac_mapping(i);\n\t\t\tu32 tx_cur = tx_time[q];\n\t\t\tu32 rx_cur = rx_time[q];\n\t\t\tu8 tid = ac_to_tid[i];\n\n\t\t\tif (!tx_cur && !rx_cur)\n\t\t\t\tcontinue;\n\n\t\t\tieee80211_sta_register_airtime(sta, tid, tx_cur,\n\t\t\t\t\t\t       rx_cur);\n\t\t}\n\n\t\t \n\t\trate = &msta->wcid.rate;\n\t\taddr = mt7921_mac_wtbl_lmac_addr(idx,\n\t\t\t\t\t\t MT_WTBL_TXRX_CAP_RATE_OFFSET);\n\t\tval = mt76_rr(dev, addr);\n\n\t\tswitch (rate->bw) {\n\t\tcase RATE_INFO_BW_160:\n\t\t\tbw = IEEE80211_STA_RX_BW_160;\n\t\t\tbreak;\n\t\tcase RATE_INFO_BW_80:\n\t\t\tbw = IEEE80211_STA_RX_BW_80;\n\t\t\tbreak;\n\t\tcase RATE_INFO_BW_40:\n\t\t\tbw = IEEE80211_STA_RX_BW_40;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbw = IEEE80211_STA_RX_BW_20;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rate->flags & RATE_INFO_FLAGS_HE_MCS) {\n\t\t\tu8 offs = MT_WTBL_TXRX_RATE_G2_HE + 2 * bw;\n\n\t\t\trate->he_gi = (val & (0x3 << offs)) >> offs;\n\t\t} else if (rate->flags &\n\t\t\t   (RATE_INFO_FLAGS_VHT_MCS | RATE_INFO_FLAGS_MCS)) {\n\t\t\tif (val & BIT(MT_WTBL_TXRX_RATE_G2 + bw))\n\t\t\t\trate->flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t\t\telse\n\t\t\t\trate->flags &= ~RATE_INFO_FLAGS_SHORT_GI;\n\t\t}\n\n\t\t \n\t\taddr = mt7921_mac_wtbl_lmac_addr(idx, 30);\n\t\tval = mt76_rr(dev, addr);\n\n\t\trssi[0] = to_rssi(GENMASK(7, 0), val);\n\t\trssi[1] = to_rssi(GENMASK(15, 8), val);\n\t\trssi[2] = to_rssi(GENMASK(23, 16), val);\n\t\trssi[3] = to_rssi(GENMASK(31, 14), val);\n\n\t\tmsta->ack_signal =\n\t\t\tmt76_rx_signal(msta->vif->phy->mt76->antenna_mask, rssi);\n\n\t\tewma_avg_signal_add(&msta->avg_ack_signal, -msta->ack_signal);\n\t}\n}\n\nstatic int\nmt7921_mac_fill_rx(struct mt792x_dev *dev, struct sk_buff *skb)\n{\n\tu32 csum_mask = MT_RXD0_NORMAL_IP_SUM | MT_RXD0_NORMAL_UDP_TCP_SUM;\n\tstruct mt76_rx_status *status = (struct mt76_rx_status *)skb->cb;\n\tbool hdr_trans, unicast, insert_ccmp_hdr = false;\n\tu8 chfreq, qos_ctl = 0, remove_pad, amsdu_info;\n\tu16 hdr_gap;\n\t__le32 *rxv = NULL, *rxd = (__le32 *)skb->data;\n\tstruct mt76_phy *mphy = &dev->mt76.phy;\n\tstruct mt792x_phy *phy = &dev->phy;\n\tstruct ieee80211_supported_band *sband;\n\tu32 csum_status = *(u32 *)skb->cb;\n\tu32 rxd0 = le32_to_cpu(rxd[0]);\n\tu32 rxd1 = le32_to_cpu(rxd[1]);\n\tu32 rxd2 = le32_to_cpu(rxd[2]);\n\tu32 rxd3 = le32_to_cpu(rxd[3]);\n\tu32 rxd4 = le32_to_cpu(rxd[4]);\n\tstruct mt792x_sta *msta = NULL;\n\tu16 seq_ctrl = 0;\n\t__le16 fc = 0;\n\tu8 mode = 0;\n\tint i, idx;\n\n\tmemset(status, 0, sizeof(*status));\n\n\tif (rxd1 & MT_RXD1_NORMAL_BAND_IDX)\n\t\treturn -EINVAL;\n\n\tif (!test_bit(MT76_STATE_RUNNING, &mphy->state))\n\t\treturn -EINVAL;\n\n\tif (rxd2 & MT_RXD2_NORMAL_AMSDU_ERR)\n\t\treturn -EINVAL;\n\n\thdr_trans = rxd2 & MT_RXD2_NORMAL_HDR_TRANS;\n\tif (hdr_trans && (rxd1 & MT_RXD1_NORMAL_CM))\n\t\treturn -EINVAL;\n\n\t \n\tif (rxd1 & MT_RXD1_NORMAL_ICV_ERR)\n\t\tstatus->flag |= RX_FLAG_ONLY_MONITOR;\n\n\tchfreq = FIELD_GET(MT_RXD3_NORMAL_CH_FREQ, rxd3);\n\tunicast = FIELD_GET(MT_RXD3_NORMAL_ADDR_TYPE, rxd3) == MT_RXD3_NORMAL_U2M;\n\tidx = FIELD_GET(MT_RXD1_NORMAL_WLAN_IDX, rxd1);\n\tstatus->wcid = mt792x_rx_get_wcid(dev, idx, unicast);\n\n\tif (status->wcid) {\n\t\tmsta = container_of(status->wcid, struct mt792x_sta, wcid);\n\t\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\t\tif (list_empty(&msta->wcid.poll_list))\n\t\t\tlist_add_tail(&msta->wcid.poll_list,\n\t\t\t\t      &dev->mt76.sta_poll_list);\n\t\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\t}\n\n\tmt792x_get_status_freq_info(status, chfreq);\n\n\tswitch (status->band) {\n\tcase NL80211_BAND_5GHZ:\n\t\tsband = &mphy->sband_5g.sband;\n\t\tbreak;\n\tcase NL80211_BAND_6GHZ:\n\t\tsband = &mphy->sband_6g.sband;\n\t\tbreak;\n\tdefault:\n\t\tsband = &mphy->sband_2g.sband;\n\t\tbreak;\n\t}\n\n\tif (!sband->channels)\n\t\treturn -EINVAL;\n\n\tif (mt76_is_mmio(&dev->mt76) && (rxd0 & csum_mask) == csum_mask &&\n\t    !(csum_status & (BIT(0) | BIT(2) | BIT(3))))\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tif (rxd1 & MT_RXD1_NORMAL_FCS_ERR)\n\t\tstatus->flag |= RX_FLAG_FAILED_FCS_CRC;\n\n\tif (rxd1 & MT_RXD1_NORMAL_TKIP_MIC_ERR)\n\t\tstatus->flag |= RX_FLAG_MMIC_ERROR;\n\n\tif (FIELD_GET(MT_RXD1_NORMAL_SEC_MODE, rxd1) != 0 &&\n\t    !(rxd1 & (MT_RXD1_NORMAL_CLM | MT_RXD1_NORMAL_CM))) {\n\t\tstatus->flag |= RX_FLAG_DECRYPTED;\n\t\tstatus->flag |= RX_FLAG_IV_STRIPPED;\n\t\tstatus->flag |= RX_FLAG_MMIC_STRIPPED | RX_FLAG_MIC_STRIPPED;\n\t}\n\n\tremove_pad = FIELD_GET(MT_RXD2_NORMAL_HDR_OFFSET, rxd2);\n\n\tif (rxd2 & MT_RXD2_NORMAL_MAX_LEN_ERROR)\n\t\treturn -EINVAL;\n\n\trxd += 6;\n\tif (rxd1 & MT_RXD1_NORMAL_GROUP_4) {\n\t\tu32 v0 = le32_to_cpu(rxd[0]);\n\t\tu32 v2 = le32_to_cpu(rxd[2]);\n\n\t\tfc = cpu_to_le16(FIELD_GET(MT_RXD6_FRAME_CONTROL, v0));\n\t\tseq_ctrl = FIELD_GET(MT_RXD8_SEQ_CTRL, v2);\n\t\tqos_ctl = FIELD_GET(MT_RXD8_QOS_CTL, v2);\n\n\t\trxd += 4;\n\t\tif ((u8 *)rxd - skb->data >= skb->len)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (rxd1 & MT_RXD1_NORMAL_GROUP_1) {\n\t\tu8 *data = (u8 *)rxd;\n\n\t\tif (status->flag & RX_FLAG_DECRYPTED) {\n\t\t\tswitch (FIELD_GET(MT_RXD1_NORMAL_SEC_MODE, rxd1)) {\n\t\t\tcase MT_CIPHER_AES_CCMP:\n\t\t\tcase MT_CIPHER_CCMP_CCX:\n\t\t\tcase MT_CIPHER_CCMP_256:\n\t\t\t\tinsert_ccmp_hdr =\n\t\t\t\t\tFIELD_GET(MT_RXD2_NORMAL_FRAG, rxd2);\n\t\t\t\tfallthrough;\n\t\t\tcase MT_CIPHER_TKIP:\n\t\t\tcase MT_CIPHER_TKIP_NO_MIC:\n\t\t\tcase MT_CIPHER_GCMP:\n\t\t\tcase MT_CIPHER_GCMP_256:\n\t\t\t\tstatus->iv[0] = data[5];\n\t\t\t\tstatus->iv[1] = data[4];\n\t\t\t\tstatus->iv[2] = data[3];\n\t\t\t\tstatus->iv[3] = data[2];\n\t\t\t\tstatus->iv[4] = data[1];\n\t\t\t\tstatus->iv[5] = data[0];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trxd += 4;\n\t\tif ((u8 *)rxd - skb->data >= skb->len)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (rxd1 & MT_RXD1_NORMAL_GROUP_2) {\n\t\tstatus->timestamp = le32_to_cpu(rxd[0]);\n\t\tstatus->flag |= RX_FLAG_MACTIME_START;\n\n\t\tif (!(rxd2 & MT_RXD2_NORMAL_NON_AMPDU)) {\n\t\t\tstatus->flag |= RX_FLAG_AMPDU_DETAILS;\n\n\t\t\t \n\t\t\tif (phy->rx_ampdu_ts != status->timestamp) {\n\t\t\t\tif (!++phy->ampdu_ref)\n\t\t\t\t\tphy->ampdu_ref++;\n\t\t\t}\n\t\t\tphy->rx_ampdu_ts = status->timestamp;\n\n\t\t\tstatus->ampdu_ref = phy->ampdu_ref;\n\t\t}\n\n\t\trxd += 2;\n\t\tif ((u8 *)rxd - skb->data >= skb->len)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (rxd1 & MT_RXD1_NORMAL_GROUP_3) {\n\t\tu32 v0, v1;\n\t\tint ret;\n\n\t\trxv = rxd;\n\t\trxd += 2;\n\t\tif ((u8 *)rxd - skb->data >= skb->len)\n\t\t\treturn -EINVAL;\n\n\t\tv0 = le32_to_cpu(rxv[0]);\n\t\tv1 = le32_to_cpu(rxv[1]);\n\n\t\tif (v0 & MT_PRXV_HT_AD_CODE)\n\t\t\tstatus->enc_flags |= RX_ENC_FLAG_LDPC;\n\n\t\tret = mt76_connac2_mac_fill_rx_rate(&dev->mt76, status, sband,\n\t\t\t\t\t\t    rxv, &mode);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (rxd1 & MT_RXD1_NORMAL_GROUP_5) {\n\t\t\trxd += 6;\n\t\t\tif ((u8 *)rxd - skb->data >= skb->len)\n\t\t\t\treturn -EINVAL;\n\n\t\t\trxv = rxd;\n\t\t\t \n\t\t\tv1 = le32_to_cpu(rxv[0]);\n\n\t\t\trxd += 12;\n\t\t\tif ((u8 *)rxd - skb->data >= skb->len)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tstatus->chains = mphy->antenna_mask;\n\t\tstatus->chain_signal[0] = to_rssi(MT_PRXV_RCPI0, v1);\n\t\tstatus->chain_signal[1] = to_rssi(MT_PRXV_RCPI1, v1);\n\t\tstatus->chain_signal[2] = to_rssi(MT_PRXV_RCPI2, v1);\n\t\tstatus->chain_signal[3] = to_rssi(MT_PRXV_RCPI3, v1);\n\t\tstatus->signal = -128;\n\t\tfor (i = 0; i < hweight8(mphy->antenna_mask); i++) {\n\t\t\tif (!(status->chains & BIT(i)) ||\n\t\t\t    status->chain_signal[i] >= 0)\n\t\t\t\tcontinue;\n\n\t\t\tstatus->signal = max(status->signal,\n\t\t\t\t\t     status->chain_signal[i]);\n\t\t}\n\t}\n\n\tamsdu_info = FIELD_GET(MT_RXD4_NORMAL_PAYLOAD_FORMAT, rxd4);\n\tstatus->amsdu = !!amsdu_info;\n\tif (status->amsdu) {\n\t\tstatus->first_amsdu = amsdu_info == MT_RXD4_FIRST_AMSDU_FRAME;\n\t\tstatus->last_amsdu = amsdu_info == MT_RXD4_LAST_AMSDU_FRAME;\n\t}\n\n\thdr_gap = (u8 *)rxd - skb->data + 2 * remove_pad;\n\tif (hdr_trans && ieee80211_has_morefrags(fc)) {\n\t\tstruct ieee80211_vif *vif;\n\t\tint err;\n\n\t\tif (!msta || !msta->vif)\n\t\t\treturn -EINVAL;\n\n\t\tvif = container_of((void *)msta->vif, struct ieee80211_vif,\n\t\t\t\t   drv_priv);\n\t\terr = mt76_connac2_reverse_frag0_hdr_trans(vif, skb, hdr_gap);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\thdr_trans = false;\n\t} else {\n\t\tskb_pull(skb, hdr_gap);\n\t\tif (!hdr_trans && status->amsdu) {\n\t\t\tmemmove(skb->data + 2, skb->data,\n\t\t\t\tieee80211_get_hdrlen_from_skb(skb));\n\t\t\tskb_pull(skb, 2);\n\t\t}\n\t}\n\n\tif (!hdr_trans) {\n\t\tstruct ieee80211_hdr *hdr;\n\n\t\tif (insert_ccmp_hdr) {\n\t\t\tu8 key_id = FIELD_GET(MT_RXD1_NORMAL_KEY_ID, rxd1);\n\n\t\t\tmt76_insert_ccmp_hdr(skb, key_id);\n\t\t}\n\n\t\thdr = mt76_skb_get_hdr(skb);\n\t\tfc = hdr->frame_control;\n\t\tif (ieee80211_is_data_qos(fc)) {\n\t\t\tseq_ctrl = le16_to_cpu(hdr->seq_ctrl);\n\t\t\tqos_ctl = *ieee80211_get_qos_ctl(hdr);\n\t\t}\n\t} else {\n\t\tstatus->flag |= RX_FLAG_8023;\n\t}\n\n\tmt792x_mac_assoc_rssi(dev, skb);\n\n\tif (rxv && mode >= MT_PHY_TYPE_HE_SU && !(status->flag & RX_FLAG_8023))\n\t\tmt76_connac2_mac_decode_he_radiotap(&dev->mt76, skb, rxv, mode);\n\n\tif (!status->wcid || !ieee80211_is_data_qos(fc))\n\t\treturn 0;\n\n\tstatus->aggr = unicast && !ieee80211_is_qos_nullfunc(fc);\n\tstatus->seqno = IEEE80211_SEQ_TO_SN(seq_ctrl);\n\tstatus->qos_ctl = qos_ctl;\n\n\treturn 0;\n}\n\nvoid mt7921_mac_add_txs(struct mt792x_dev *dev, void *data)\n{\n\tstruct mt792x_sta *msta = NULL;\n\tstruct mt76_wcid *wcid;\n\t__le32 *txs_data = data;\n\tu16 wcidx;\n\tu8 pid;\n\n\tif (le32_get_bits(txs_data[0], MT_TXS0_TXS_FORMAT) > 1)\n\t\treturn;\n\n\twcidx = le32_get_bits(txs_data[2], MT_TXS2_WCID);\n\tpid = le32_get_bits(txs_data[3], MT_TXS3_PID);\n\n\tif (pid < MT_PACKET_ID_FIRST)\n\t\treturn;\n\n\tif (wcidx >= MT792x_WTBL_SIZE)\n\t\treturn;\n\n\trcu_read_lock();\n\n\twcid = rcu_dereference(dev->mt76.wcid[wcidx]);\n\tif (!wcid)\n\t\tgoto out;\n\n\tmsta = container_of(wcid, struct mt792x_sta, wcid);\n\n\tmt76_connac2_mac_add_txs_skb(&dev->mt76, wcid, pid, txs_data);\n\tif (!wcid->sta)\n\t\tgoto out;\n\n\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\tif (list_empty(&msta->wcid.poll_list))\n\t\tlist_add_tail(&msta->wcid.poll_list, &dev->mt76.sta_poll_list);\n\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\nout:\n\trcu_read_unlock();\n}\n\nstatic void mt7921_mac_tx_free(struct mt792x_dev *dev, void *data, int len)\n{\n\tstruct mt76_connac_tx_free *free = data;\n\t__le32 *tx_info = (__le32 *)(data + sizeof(*free));\n\tstruct mt76_dev *mdev = &dev->mt76;\n\tstruct mt76_txwi_cache *txwi;\n\tstruct ieee80211_sta *sta = NULL;\n\tstruct mt76_wcid *wcid = NULL;\n\tstruct sk_buff *skb, *tmp;\n\tvoid *end = data + len;\n\tLIST_HEAD(free_list);\n\tbool wake = false;\n\tu8 i, count;\n\n\t \n\tmt76_queue_tx_cleanup(dev, dev->mphy.q_tx[MT_TXQ_PSD], false);\n\tmt76_queue_tx_cleanup(dev, dev->mphy.q_tx[MT_TXQ_BE], false);\n\n\tcount = le16_get_bits(free->ctrl, MT_TX_FREE_MSDU_CNT);\n\tif (WARN_ON_ONCE((void *)&tx_info[count] > end))\n\t\treturn;\n\n\tfor (i = 0; i < count; i++) {\n\t\tu32 msdu, info = le32_to_cpu(tx_info[i]);\n\t\tu8 stat;\n\n\t\t \n\t\tif (info & MT_TX_FREE_PAIR) {\n\t\t\tstruct mt792x_sta *msta;\n\t\t\tu16 idx;\n\n\t\t\tcount++;\n\t\t\tidx = FIELD_GET(MT_TX_FREE_WLAN_ID, info);\n\t\t\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n\t\t\tsta = wcid_to_sta(wcid);\n\t\t\tif (!sta)\n\t\t\t\tcontinue;\n\n\t\t\tmsta = container_of(wcid, struct mt792x_sta, wcid);\n\t\t\tspin_lock_bh(&mdev->sta_poll_lock);\n\t\t\tif (list_empty(&msta->wcid.poll_list))\n\t\t\t\tlist_add_tail(&msta->wcid.poll_list,\n\t\t\t\t\t      &mdev->sta_poll_list);\n\t\t\tspin_unlock_bh(&mdev->sta_poll_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmsdu = FIELD_GET(MT_TX_FREE_MSDU_ID, info);\n\t\tstat = FIELD_GET(MT_TX_FREE_STATUS, info);\n\n\t\tif (wcid) {\n\t\t\twcid->stats.tx_retries +=\n\t\t\t\tFIELD_GET(MT_TX_FREE_COUNT, info) - 1;\n\t\t\twcid->stats.tx_failed += !!stat;\n\t\t}\n\n\t\ttxwi = mt76_token_release(mdev, msdu, &wake);\n\t\tif (!txwi)\n\t\t\tcontinue;\n\n\t\tmt76_connac2_txwi_free(mdev, txwi, sta, &free_list);\n\t}\n\n\tif (wake)\n\t\tmt76_set_tx_blocked(&dev->mt76, false);\n\n\tlist_for_each_entry_safe(skb, tmp, &free_list, list) {\n\t\tskb_list_del_init(skb);\n\t\tnapi_consume_skb(skb, 1);\n\t}\n\n\trcu_read_lock();\n\tmt7921_mac_sta_poll(dev);\n\trcu_read_unlock();\n\n\tmt76_worker_schedule(&dev->mt76.tx_worker);\n}\n\nbool mt7921_rx_check(struct mt76_dev *mdev, void *data, int len)\n{\n\tstruct mt792x_dev *dev = container_of(mdev, struct mt792x_dev, mt76);\n\t__le32 *rxd = (__le32 *)data;\n\t__le32 *end = (__le32 *)&rxd[len / 4];\n\tenum rx_pkt_type type;\n\n\ttype = le32_get_bits(rxd[0], MT_RXD0_PKT_TYPE);\n\n\tswitch (type) {\n\tcase PKT_TYPE_TXRX_NOTIFY:\n\t\t \n\t\tmt7921_mac_tx_free(dev, data, len);  \n\t\treturn false;\n\tcase PKT_TYPE_TXS:\n\t\tfor (rxd += 2; rxd + 8 <= end; rxd += 8)\n\t\t\tmt7921_mac_add_txs(dev, rxd);\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\nEXPORT_SYMBOL_GPL(mt7921_rx_check);\n\nvoid mt7921_queue_rx_skb(struct mt76_dev *mdev, enum mt76_rxq_id q,\n\t\t\t struct sk_buff *skb, u32 *info)\n{\n\tstruct mt792x_dev *dev = container_of(mdev, struct mt792x_dev, mt76);\n\t__le32 *rxd = (__le32 *)skb->data;\n\t__le32 *end = (__le32 *)&skb->data[skb->len];\n\tenum rx_pkt_type type;\n\tu16 flag;\n\n\ttype = le32_get_bits(rxd[0], MT_RXD0_PKT_TYPE);\n\tflag = le32_get_bits(rxd[0], MT_RXD0_PKT_FLAG);\n\n\tif (type == PKT_TYPE_RX_EVENT && flag == 0x1)\n\t\ttype = PKT_TYPE_NORMAL_MCU;\n\n\tswitch (type) {\n\tcase PKT_TYPE_TXRX_NOTIFY:\n\t\t \n\t\tmt7921_mac_tx_free(dev, skb->data, skb->len);\n\t\tnapi_consume_skb(skb, 1);\n\t\tbreak;\n\tcase PKT_TYPE_RX_EVENT:\n\t\tmt7921_mcu_rx_event(dev, skb);\n\t\tbreak;\n\tcase PKT_TYPE_TXS:\n\t\tfor (rxd += 2; rxd + 8 <= end; rxd += 8)\n\t\t\tmt7921_mac_add_txs(dev, rxd);\n\t\tdev_kfree_skb(skb);\n\t\tbreak;\n\tcase PKT_TYPE_NORMAL_MCU:\n\tcase PKT_TYPE_NORMAL:\n\t\tif (!mt7921_mac_fill_rx(dev, skb)) {\n\t\t\tmt76_rx(&dev->mt76, q, skb);\n\t\t\treturn;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdev_kfree_skb(skb);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(mt7921_queue_rx_skb);\n\nstatic void\nmt7921_vif_connect_iter(void *priv, u8 *mac,\n\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tstruct mt792x_dev *dev = mvif->phy->dev;\n\tstruct ieee80211_hw *hw = mt76_hw(dev);\n\n\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\tieee80211_disconnect(vif, true);\n\n\tmt76_connac_mcu_uni_add_dev(&dev->mphy, vif, &mvif->sta.wcid, true);\n\tmt7921_mcu_set_tx(dev, vif);\n\n\tif (vif->type == NL80211_IFTYPE_AP) {\n\t\tmt76_connac_mcu_uni_add_bss(dev->phy.mt76, vif, &mvif->sta.wcid,\n\t\t\t\t\t    true, NULL);\n\t\tmt7921_mcu_sta_update(dev, NULL, vif, true,\n\t\t\t\t      MT76_STA_INFO_STATE_NONE);\n\t\tmt7921_mcu_uni_add_beacon_offload(dev, hw, vif, true);\n\t}\n}\n\n \nvoid mt7921_mac_reset_work(struct work_struct *work)\n{\n\tstruct mt792x_dev *dev = container_of(work, struct mt792x_dev,\n\t\t\t\t\t      reset_work);\n\tstruct ieee80211_hw *hw = mt76_hw(dev);\n\tstruct mt76_connac_pm *pm = &dev->pm;\n\tint i, ret;\n\n\tdev_dbg(dev->mt76.dev, \"chip reset\\n\");\n\tdev->hw_full_reset = true;\n\tieee80211_stop_queues(hw);\n\n\tcancel_delayed_work_sync(&dev->mphy.mac_work);\n\tcancel_delayed_work_sync(&pm->ps_work);\n\tcancel_work_sync(&pm->wake_work);\n\n\tfor (i = 0; i < 10; i++) {\n\t\tmutex_lock(&dev->mt76.mutex);\n\t\tret = mt792x_dev_reset(dev);\n\t\tmutex_unlock(&dev->mt76.mutex);\n\n\t\tif (!ret)\n\t\t\tbreak;\n\t}\n\n\tif (i == 10)\n\t\tdev_err(dev->mt76.dev, \"chip reset failed\\n\");\n\n\tif (test_and_clear_bit(MT76_HW_SCANNING, &dev->mphy.state)) {\n\t\tstruct cfg80211_scan_info info = {\n\t\t\t.aborted = true,\n\t\t};\n\n\t\tieee80211_scan_completed(dev->mphy.hw, &info);\n\t}\n\n\tdev->hw_full_reset = false;\n\tpm->suspended = false;\n\tieee80211_wake_queues(hw);\n\tieee80211_iterate_active_interfaces(hw,\n\t\t\t\t\t    IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\t\t\t    mt7921_vif_connect_iter, NULL);\n\tmt76_connac_power_save_sched(&dev->mt76.phy, pm);\n}\n\nvoid mt7921_coredump_work(struct work_struct *work)\n{\n\tstruct mt792x_dev *dev;\n\tchar *dump, *data;\n\n\tdev = (struct mt792x_dev *)container_of(work, struct mt792x_dev,\n\t\t\t\t\t\tcoredump.work.work);\n\n\tif (time_is_after_jiffies(dev->coredump.last_activity +\n\t\t\t\t  4 * MT76_CONNAC_COREDUMP_TIMEOUT)) {\n\t\tqueue_delayed_work(dev->mt76.wq, &dev->coredump.work,\n\t\t\t\t   MT76_CONNAC_COREDUMP_TIMEOUT);\n\t\treturn;\n\t}\n\n\tdump = vzalloc(MT76_CONNAC_COREDUMP_SZ);\n\tdata = dump;\n\n\twhile (true) {\n\t\tstruct sk_buff *skb;\n\n\t\tspin_lock_bh(&dev->mt76.lock);\n\t\tskb = __skb_dequeue(&dev->coredump.msg_list);\n\t\tspin_unlock_bh(&dev->mt76.lock);\n\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tskb_pull(skb, sizeof(struct mt76_connac2_mcu_rxd));\n\t\tif (!dump || data + skb->len - dump > MT76_CONNAC_COREDUMP_SZ) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmemcpy(data, skb->data, skb->len);\n\t\tdata += skb->len;\n\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tif (dump)\n\t\tdev_coredumpv(dev->mt76.dev, dump, MT76_CONNAC_COREDUMP_SZ,\n\t\t\t      GFP_KERNEL);\n\n\tmt792x_reset(&dev->mt76);\n}\n\n \nstatic void\nmt7921_usb_sdio_write_txwi(struct mt792x_dev *dev, struct mt76_wcid *wcid,\n\t\t\t   enum mt76_txq_id qid, struct ieee80211_sta *sta,\n\t\t\t   struct ieee80211_key_conf *key, int pid,\n\t\t\t   struct sk_buff *skb)\n{\n\t__le32 *txwi = (__le32 *)(skb->data - MT_SDIO_TXD_SIZE);\n\n\tmemset(txwi, 0, MT_SDIO_TXD_SIZE);\n\tmt76_connac2_mac_write_txwi(&dev->mt76, txwi, skb, wcid, key, pid, qid, 0);\n\tskb_push(skb, MT_SDIO_TXD_SIZE);\n}\n\nint mt7921_usb_sdio_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,\n\t\t\t\t   enum mt76_txq_id qid, struct mt76_wcid *wcid,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   struct mt76_tx_info *tx_info)\n{\n\tstruct mt792x_dev *dev = container_of(mdev, struct mt792x_dev, mt76);\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx_info->skb);\n\tstruct ieee80211_key_conf *key = info->control.hw_key;\n\tstruct sk_buff *skb = tx_info->skb;\n\tint err, pad, pktid, type;\n\n\tif (unlikely(tx_info->skb->len <= ETH_HLEN))\n\t\treturn -EINVAL;\n\n\terr = skb_cow_head(skb, MT_SDIO_TXD_SIZE + MT_SDIO_HDR_SIZE);\n\tif (err)\n\t\treturn err;\n\n\tif (!wcid)\n\t\twcid = &dev->mt76.global_wcid;\n\n\tif (sta) {\n\t\tstruct mt792x_sta *msta = (struct mt792x_sta *)sta->drv_priv;\n\n\t\tif (time_after(jiffies, msta->last_txs + HZ / 4)) {\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;\n\t\t\tmsta->last_txs = jiffies;\n\t\t}\n\t}\n\n\tpktid = mt76_tx_status_skb_add(&dev->mt76, wcid, skb);\n\tmt7921_usb_sdio_write_txwi(dev, wcid, qid, sta, key, pktid, skb);\n\n\ttype = mt76_is_sdio(mdev) ? MT7921_SDIO_DATA : 0;\n\tmt7921_skb_add_usb_sdio_hdr(dev, skb, type);\n\tpad = round_up(skb->len, 4) - skb->len;\n\tif (mt76_is_usb(mdev))\n\t\tpad += 4;\n\n\terr = mt76_skb_adjust_pad(skb, pad);\n\tif (err)\n\t\t \n\t\tidr_remove(&wcid->pktid, pktid);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mt7921_usb_sdio_tx_prepare_skb);\n\nvoid mt7921_usb_sdio_tx_complete_skb(struct mt76_dev *mdev,\n\t\t\t\t     struct mt76_queue_entry *e)\n{\n\t__le32 *txwi = (__le32 *)(e->skb->data + MT_SDIO_HDR_SIZE);\n\tunsigned int headroom = MT_SDIO_TXD_SIZE + MT_SDIO_HDR_SIZE;\n\tstruct ieee80211_sta *sta;\n\tstruct mt76_wcid *wcid;\n\tu16 idx;\n\n\tidx = le32_get_bits(txwi[1], MT_TXD1_WLAN_IDX);\n\twcid = rcu_dereference(mdev->wcid[idx]);\n\tsta = wcid_to_sta(wcid);\n\n\tif (sta && likely(e->skb->protocol != cpu_to_be16(ETH_P_PAE)))\n\t\tmt76_connac2_tx_check_aggr(sta, txwi);\n\n\tskb_pull(e->skb, headroom);\n\tmt76_tx_complete_skb(mdev, e->wcid, e->skb);\n}\nEXPORT_SYMBOL_GPL(mt7921_usb_sdio_tx_complete_skb);\n\nbool mt7921_usb_sdio_tx_status_data(struct mt76_dev *mdev, u8 *update)\n{\n\tstruct mt792x_dev *dev = container_of(mdev, struct mt792x_dev, mt76);\n\n\tmt792x_mutex_acquire(dev);\n\tmt7921_mac_sta_poll(dev);\n\tmt792x_mutex_release(dev);\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(mt7921_usb_sdio_tx_status_data);\n\n#if IS_ENABLED(CONFIG_IPV6)\nvoid mt7921_set_ipv6_ns_work(struct work_struct *work)\n{\n\tstruct mt792x_dev *dev = container_of(work, struct mt792x_dev,\n\t\t\t\t\t      ipv6_ns_work);\n\tstruct sk_buff *skb;\n\tint ret = 0;\n\n\tdo {\n\t\tskb = skb_dequeue(&dev->ipv6_ns_list);\n\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tmt792x_mutex_acquire(dev);\n\t\tret = mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t\t    MCU_UNI_CMD(OFFLOAD), true);\n\t\tmt792x_mutex_release(dev);\n\n\t} while (!ret);\n\n\tif (ret)\n\t\tskb_queue_purge(&dev->ipv6_ns_list);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}