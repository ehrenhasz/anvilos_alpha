{
  "module_name": "usb.c",
  "hash_id": "74cf93d06a49afa26703fd14decf0ec11cefaf0fc845f65253ba89984ad6f003",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7921/usb.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n\n#include \"mt7921.h\"\n#include \"mcu.h\"\n#include \"../mt76_connac2_mac.h\"\n\nstatic const struct usb_device_id mt7921u_device_table[] = {\n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x0e8d, 0x7961, 0xff, 0xff, 0xff),\n\t\t.driver_info = (kernel_ulong_t)MT7921_FIRMWARE_WM },\n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x3574, 0x6211, 0xff, 0xff, 0xff),\n\t\t.driver_info = (kernel_ulong_t)MT7921_FIRMWARE_WM },\n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x0846, 0x9060, 0xff, 0xff, 0xff),\n\t\t.driver_info = (kernel_ulong_t)MT7921_FIRMWARE_WM },\n\t{ },\n};\n\nstatic int\nmt7921u_mcu_send_message(struct mt76_dev *mdev, struct sk_buff *skb,\n\t\t\t int cmd, int *seq)\n{\n\tstruct mt792x_dev *dev = container_of(mdev, struct mt792x_dev, mt76);\n\tu32 pad, ep;\n\tint ret;\n\n\tret = mt76_connac2_mcu_fill_message(mdev, skb, cmd, seq);\n\tif (ret)\n\t\treturn ret;\n\n\tmdev->mcu.timeout = 3 * HZ;\n\n\tif (cmd != MCU_CMD(FW_SCATTER))\n\t\tep = MT_EP_OUT_INBAND_CMD;\n\telse\n\t\tep = MT_EP_OUT_AC_BE;\n\n\tmt7921_skb_add_usb_sdio_hdr(dev, skb, 0);\n\tpad = round_up(skb->len, 4) + 4 - skb->len;\n\t__skb_put_zero(skb, pad);\n\n\tret = mt76u_bulk_msg(&dev->mt76, skb->data, skb->len, NULL,\n\t\t\t     1000, ep);\n\tdev_kfree_skb(skb);\n\n\treturn ret;\n}\n\nstatic int mt7921u_mcu_init(struct mt792x_dev *dev)\n{\n\tstatic const struct mt76_mcu_ops mcu_ops = {\n\t\t.headroom = MT_SDIO_HDR_SIZE +\n\t\t\t    sizeof(struct mt76_connac2_mcu_txd),\n\t\t.tailroom = MT_USB_TAIL_SIZE,\n\t\t.mcu_skb_send_msg = mt7921u_mcu_send_message,\n\t\t.mcu_parse_response = mt7921_mcu_parse_response,\n\t};\n\tint ret;\n\n\tdev->mt76.mcu_ops = &mcu_ops;\n\n\tmt76_set(dev, MT_UDMA_TX_QSEL, MT_FW_DL_EN);\n\tret = mt7921_run_firmware(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tset_bit(MT76_STATE_MCU_RUNNING, &dev->mphy.state);\n\tmt76_clear(dev, MT_UDMA_TX_QSEL, MT_FW_DL_EN);\n\n\treturn 0;\n}\n\nstatic int mt7921u_mac_reset(struct mt792x_dev *dev)\n{\n\tint err;\n\n\tmt76_txq_schedule_all(&dev->mphy);\n\tmt76_worker_disable(&dev->mt76.tx_worker);\n\n\tset_bit(MT76_RESET, &dev->mphy.state);\n\tset_bit(MT76_MCU_RESET, &dev->mphy.state);\n\n\twake_up(&dev->mt76.mcu.wait);\n\tskb_queue_purge(&dev->mt76.mcu.res_q);\n\n\tmt76u_stop_rx(&dev->mt76);\n\tmt76u_stop_tx(&dev->mt76);\n\n\tmt792xu_wfsys_reset(dev);\n\n\tclear_bit(MT76_MCU_RESET, &dev->mphy.state);\n\terr = mt76u_resume_rx(&dev->mt76);\n\tif (err)\n\t\tgoto out;\n\n\terr = mt792xu_mcu_power_on(dev);\n\tif (err)\n\t\tgoto out;\n\n\terr = mt792xu_dma_init(dev, false);\n\tif (err)\n\t\tgoto out;\n\n\tmt76_wr(dev, MT_SWDEF_MODE, MT_SWDEF_NORMAL_MODE);\n\tmt76_set(dev, MT_UDMA_TX_QSEL, MT_FW_DL_EN);\n\n\terr = mt7921_run_firmware(dev);\n\tif (err)\n\t\tgoto out;\n\n\tmt76_clear(dev, MT_UDMA_TX_QSEL, MT_FW_DL_EN);\n\n\terr = mt7921_mcu_set_eeprom(dev);\n\tif (err)\n\t\tgoto out;\n\n\terr = mt7921_mac_init(dev);\n\tif (err)\n\t\tgoto out;\n\n\terr = __mt7921_start(&dev->phy);\nout:\n\tclear_bit(MT76_RESET, &dev->mphy.state);\n\n\tmt76_worker_enable(&dev->mt76.tx_worker);\n\n\treturn err;\n}\n\nstatic void mt7921u_stop(struct ieee80211_hw *hw)\n{\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\n\tmt76u_stop_tx(&dev->mt76);\n\tmt7921_stop(hw);\n}\n\nstatic int mt7921u_probe(struct usb_interface *usb_intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstatic const struct mt76_driver_ops drv_ops = {\n\t\t.txwi_size = MT_SDIO_TXD_SIZE,\n\t\t.drv_flags = MT_DRV_RX_DMA_HDR | MT_DRV_HW_MGMT_TXQ |\n\t\t\t     MT_DRV_AMSDU_OFFLOAD,\n\t\t.survey_flags = SURVEY_INFO_TIME_TX |\n\t\t\t\tSURVEY_INFO_TIME_RX |\n\t\t\t\tSURVEY_INFO_TIME_BSS_RX,\n\t\t.tx_prepare_skb = mt7921_usb_sdio_tx_prepare_skb,\n\t\t.tx_complete_skb = mt7921_usb_sdio_tx_complete_skb,\n\t\t.tx_status_data = mt7921_usb_sdio_tx_status_data,\n\t\t.rx_skb = mt7921_queue_rx_skb,\n\t\t.rx_check = mt7921_rx_check,\n\t\t.sta_add = mt7921_mac_sta_add,\n\t\t.sta_assoc = mt7921_mac_sta_assoc,\n\t\t.sta_remove = mt7921_mac_sta_remove,\n\t\t.update_survey = mt792x_update_channel,\n\t};\n\tstatic const struct mt792x_hif_ops hif_ops = {\n\t\t.mcu_init = mt7921u_mcu_init,\n\t\t.init_reset = mt792xu_init_reset,\n\t\t.reset = mt7921u_mac_reset,\n\t};\n\tstatic struct mt76_bus_ops bus_ops = {\n\t\t.rr = mt792xu_rr,\n\t\t.wr = mt792xu_wr,\n\t\t.rmw = mt792xu_rmw,\n\t\t.read_copy = mt76u_read_copy,\n\t\t.write_copy = mt792xu_copy,\n\t\t.type = MT76_BUS_USB,\n\t};\n\tstruct usb_device *udev = interface_to_usbdev(usb_intf);\n\tstruct ieee80211_ops *ops;\n\tstruct ieee80211_hw *hw;\n\tstruct mt792x_dev *dev;\n\tstruct mt76_dev *mdev;\n\tu8 features;\n\tint ret;\n\n\tops = mt792x_get_mac80211_ops(&usb_intf->dev, &mt7921_ops,\n\t\t\t\t      (void *)id->driver_info, &features);\n\tif (!ops)\n\t\treturn -ENOMEM;\n\n\tops->stop = mt7921u_stop;\n\tmdev = mt76_alloc_device(&usb_intf->dev, sizeof(*dev), ops, &drv_ops);\n\tif (!mdev)\n\t\treturn -ENOMEM;\n\n\tdev = container_of(mdev, struct mt792x_dev, mt76);\n\tdev->fw_features = features;\n\tdev->hif_ops = &hif_ops;\n\n\tudev = usb_get_dev(udev);\n\tusb_reset_device(udev);\n\n\tusb_set_intfdata(usb_intf, dev);\n\n\tret = __mt76u_init(mdev, usb_intf, &bus_ops);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tmdev->rev = (mt76_rr(dev, MT_HW_CHIPID) << 16) |\n\t\t    (mt76_rr(dev, MT_HW_REV) & 0xff);\n\tdev_dbg(mdev->dev, \"ASIC revision: %04x\\n\", mdev->rev);\n\n\tif (mt76_get_field(dev, MT_CONN_ON_MISC, MT_TOP_MISC2_FW_N9_RDY)) {\n\t\tret = mt792xu_wfsys_reset(dev);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tret = mt792xu_mcu_power_on(dev);\n\tif (ret)\n\t\tgoto error;\n\n\tret = mt76u_alloc_mcu_queue(&dev->mt76);\n\tif (ret)\n\t\tgoto error;\n\n\tret = mt76u_alloc_queues(&dev->mt76);\n\tif (ret)\n\t\tgoto error;\n\n\tret = mt792xu_dma_init(dev, false);\n\tif (ret)\n\t\tgoto error;\n\n\thw = mt76_hw(dev);\n\t \n\thw->max_tx_fragments = mdev->usb.sg_en ? MT_HW_TXP_MAX_BUF_NUM : 1;\n\n\tret = mt7921_register_device(dev);\n\tif (ret)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tmt76u_queues_deinit(&dev->mt76);\n\n\tusb_set_intfdata(usb_intf, NULL);\n\tusb_put_dev(interface_to_usbdev(usb_intf));\n\n\tmt76_free_device(&dev->mt76);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_PM\nstatic int mt7921u_suspend(struct usb_interface *intf, pm_message_t state)\n{\n\tstruct mt792x_dev *dev = usb_get_intfdata(intf);\n\tstruct mt76_connac_pm *pm = &dev->pm;\n\tint err;\n\n\tpm->suspended = true;\n\tflush_work(&dev->reset_work);\n\n\terr = mt76_connac_mcu_set_hif_suspend(&dev->mt76, true);\n\tif (err)\n\t\tgoto failed;\n\n\tmt76u_stop_rx(&dev->mt76);\n\tmt76u_stop_tx(&dev->mt76);\n\n\treturn 0;\n\nfailed:\n\tpm->suspended = false;\n\n\tif (err < 0)\n\t\tmt792x_reset(&dev->mt76);\n\n\treturn err;\n}\n\nstatic int mt7921u_resume(struct usb_interface *intf)\n{\n\tstruct mt792x_dev *dev = usb_get_intfdata(intf);\n\tstruct mt76_connac_pm *pm = &dev->pm;\n\tbool reinit = true;\n\tint err, i;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tu32 val = mt76_rr(dev, MT_WF_SW_DEF_CR_USB_MCU_EVENT);\n\n\t\tif (!(val & MT_WF_SW_SER_TRIGGER_SUSPEND)) {\n\t\t\treinit = false;\n\t\t\tbreak;\n\t\t}\n\t\tif (val & MT_WF_SW_SER_DONE_SUSPEND) {\n\t\t\tmt76_wr(dev, MT_WF_SW_DEF_CR_USB_MCU_EVENT, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(20);\n\t}\n\n\tif (reinit || mt792x_dma_need_reinit(dev)) {\n\t\terr = mt792xu_dma_init(dev, true);\n\t\tif (err)\n\t\t\tgoto failed;\n\t}\n\n\terr = mt76u_resume_rx(&dev->mt76);\n\tif (err < 0)\n\t\tgoto failed;\n\n\terr = mt76_connac_mcu_set_hif_suspend(&dev->mt76, false);\nfailed:\n\tpm->suspended = false;\n\n\tif (err < 0)\n\t\tmt792x_reset(&dev->mt76);\n\n\treturn err;\n}\n#endif  \n\nMODULE_DEVICE_TABLE(usb, mt7921u_device_table);\nMODULE_FIRMWARE(MT7921_FIRMWARE_WM);\nMODULE_FIRMWARE(MT7921_ROM_PATCH);\n\nstatic struct usb_driver mt7921u_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= mt7921u_device_table,\n\t.probe\t\t= mt7921u_probe,\n\t.disconnect\t= mt792xu_disconnect,\n#ifdef CONFIG_PM\n\t.suspend\t= mt7921u_suspend,\n\t.resume\t\t= mt7921u_resume,\n\t.reset_resume\t= mt7921u_resume,\n#endif  \n\t.soft_unbind\t= 1,\n\t.disable_hub_initiated_lpm = 1,\n};\nmodule_usb_driver(mt7921u_driver);\n\nMODULE_AUTHOR(\"Lorenzo Bianconi <lorenzo@kernel.org>\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}