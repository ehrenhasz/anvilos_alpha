{
  "module_name": "pci.c",
  "hash_id": "53e6425641fa12e1b6631a95b335e083a6b2798ae0e7bf28457ccdd04c1afe68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7921/pci.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#include \"mt7921.h\"\n#include \"../mt76_connac2_mac.h\"\n#include \"../dma.h\"\n#include \"mcu.h\"\n\nstatic const struct pci_device_id mt7921_pci_device_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MEDIATEK, 0x7961),\n\t\t.driver_data = (kernel_ulong_t)MT7921_FIRMWARE_WM },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MEDIATEK, 0x7922),\n\t\t.driver_data = (kernel_ulong_t)MT7922_FIRMWARE_WM },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ITTIM, 0x7922),\n\t\t.driver_data = (kernel_ulong_t)MT7922_FIRMWARE_WM },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MEDIATEK, 0x0608),\n\t\t.driver_data = (kernel_ulong_t)MT7921_FIRMWARE_WM },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MEDIATEK, 0x0616),\n\t\t.driver_data = (kernel_ulong_t)MT7922_FIRMWARE_WM },\n\t{ },\n};\n\nstatic bool mt7921_disable_aspm;\nmodule_param_named(disable_aspm, mt7921_disable_aspm, bool, 0644);\nMODULE_PARM_DESC(disable_aspm, \"disable PCI ASPM support\");\n\nstatic int mt7921e_init_reset(struct mt792x_dev *dev)\n{\n\treturn mt792x_wpdma_reset(dev, true);\n}\n\nstatic void mt7921e_unregister_device(struct mt792x_dev *dev)\n{\n\tint i;\n\tstruct mt76_connac_pm *pm = &dev->pm;\n\n\tcancel_work_sync(&dev->init_work);\n\tmt76_unregister_device(&dev->mt76);\n\tmt76_for_each_q_rx(&dev->mt76, i)\n\t\tnapi_disable(&dev->mt76.napi[i]);\n\tcancel_delayed_work_sync(&pm->ps_work);\n\tcancel_work_sync(&pm->wake_work);\n\tcancel_work_sync(&dev->reset_work);\n\n\tmt76_connac2_tx_token_put(&dev->mt76);\n\t__mt792x_mcu_drv_pmctrl(dev);\n\tmt792x_dma_cleanup(dev);\n\tmt792x_wfsys_reset(dev);\n\tskb_queue_purge(&dev->mt76.mcu.res_q);\n\n\ttasklet_disable(&dev->mt76.irq_tasklet);\n}\n\nstatic u32 __mt7921_reg_addr(struct mt792x_dev *dev, u32 addr)\n{\n\tstatic const struct mt76_connac_reg_map fixed_map[] = {\n\t\t{ 0x820d0000, 0x30000, 0x10000 },  \n\t\t{ 0x820ed000, 0x24800, 0x00800 },  \n\t\t{ 0x820e4000, 0x21000, 0x00400 },  \n\t\t{ 0x820e7000, 0x21e00, 0x00200 },  \n\t\t{ 0x820eb000, 0x24200, 0x00400 },  \n\t\t{ 0x820e2000, 0x20800, 0x00400 },  \n\t\t{ 0x820e3000, 0x20c00, 0x00400 },  \n\t\t{ 0x820e5000, 0x21400, 0x00800 },  \n\t\t{ 0x00400000, 0x80000, 0x10000 },  \n\t\t{ 0x00410000, 0x90000, 0x10000 },  \n\t\t{ 0x40000000, 0x70000, 0x10000 },  \n\t\t{ 0x54000000, 0x02000, 0x01000 },  \n\t\t{ 0x55000000, 0x03000, 0x01000 },  \n\t\t{ 0x58000000, 0x06000, 0x01000 },  \n\t\t{ 0x59000000, 0x07000, 0x01000 },  \n\t\t{ 0x7c000000, 0xf0000, 0x10000 },  \n\t\t{ 0x7c020000, 0xd0000, 0x10000 },  \n\t\t{ 0x7c060000, 0xe0000, 0x10000 },  \n\t\t{ 0x80020000, 0xb0000, 0x10000 },  \n\t\t{ 0x81020000, 0xc0000, 0x10000 },  \n\t\t{ 0x820c0000, 0x08000, 0x04000 },  \n\t\t{ 0x820c8000, 0x0c000, 0x02000 },  \n\t\t{ 0x820cc000, 0x0e000, 0x01000 },  \n\t\t{ 0x820cd000, 0x0f000, 0x01000 },  \n\t\t{ 0x74030000, 0x10000, 0x10000 },  \n\t\t{ 0x820ce000, 0x21c00, 0x00200 },  \n\t\t{ 0x820cf000, 0x22000, 0x01000 },  \n\t\t{ 0x820e0000, 0x20000, 0x00400 },  \n\t\t{ 0x820e1000, 0x20400, 0x00200 },  \n\t\t{ 0x820e9000, 0x23400, 0x00200 },  \n\t\t{ 0x820ea000, 0x24000, 0x00200 },  \n\t\t{ 0x820ec000, 0x24600, 0x00200 },  \n\t\t{ 0x820f0000, 0xa0000, 0x00400 },  \n\t\t{ 0x820f1000, 0xa0600, 0x00200 },  \n\t\t{ 0x820f2000, 0xa0800, 0x00400 },  \n\t\t{ 0x820f3000, 0xa0c00, 0x00400 },  \n\t\t{ 0x820f4000, 0xa1000, 0x00400 },  \n\t\t{ 0x820f5000, 0xa1400, 0x00800 },  \n\t\t{ 0x820f7000, 0xa1e00, 0x00200 },  \n\t\t{ 0x820f9000, 0xa3400, 0x00200 },  \n\t\t{ 0x820fa000, 0xa4000, 0x00200 },  \n\t\t{ 0x820fb000, 0xa4200, 0x00400 },  \n\t\t{ 0x820fc000, 0xa4600, 0x00200 },  \n\t\t{ 0x820fd000, 0xa4800, 0x00800 },  \n\t};\n\tint i;\n\n\tif (addr < 0x100000)\n\t\treturn addr;\n\n\tfor (i = 0; i < ARRAY_SIZE(fixed_map); i++) {\n\t\tu32 ofs;\n\n\t\tif (addr < fixed_map[i].phys)\n\t\t\tcontinue;\n\n\t\tofs = addr - fixed_map[i].phys;\n\t\tif (ofs > fixed_map[i].size)\n\t\t\tcontinue;\n\n\t\treturn fixed_map[i].maps + ofs;\n\t}\n\n\tif ((addr >= 0x18000000 && addr < 0x18c00000) ||\n\t    (addr >= 0x70000000 && addr < 0x78000000) ||\n\t    (addr >= 0x7c000000 && addr < 0x7c400000))\n\t\treturn mt7921_reg_map_l1(dev, addr);\n\n\tdev_err(dev->mt76.dev, \"Access currently unsupported address %08x\\n\",\n\t\taddr);\n\n\treturn 0;\n}\n\nstatic u32 mt7921_rr(struct mt76_dev *mdev, u32 offset)\n{\n\tstruct mt792x_dev *dev = container_of(mdev, struct mt792x_dev, mt76);\n\tu32 addr = __mt7921_reg_addr(dev, offset);\n\n\treturn dev->bus_ops->rr(mdev, addr);\n}\n\nstatic void mt7921_wr(struct mt76_dev *mdev, u32 offset, u32 val)\n{\n\tstruct mt792x_dev *dev = container_of(mdev, struct mt792x_dev, mt76);\n\tu32 addr = __mt7921_reg_addr(dev, offset);\n\n\tdev->bus_ops->wr(mdev, addr, val);\n}\n\nstatic u32 mt7921_rmw(struct mt76_dev *mdev, u32 offset, u32 mask, u32 val)\n{\n\tstruct mt792x_dev *dev = container_of(mdev, struct mt792x_dev, mt76);\n\tu32 addr = __mt7921_reg_addr(dev, offset);\n\n\treturn dev->bus_ops->rmw(mdev, addr, mask, val);\n}\n\nstatic int mt7921_dma_init(struct mt792x_dev *dev)\n{\n\tint ret;\n\n\tmt76_dma_attach(&dev->mt76);\n\n\tret = mt792x_dma_disable(dev, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mt76_connac_init_tx_queues(dev->phy.mt76, MT7921_TXQ_BAND0,\n\t\t\t\t\t MT7921_TX_RING_SIZE,\n\t\t\t\t\t MT_TX_RING_BASE, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tmt76_wr(dev, MT_WFDMA0_TX_RING0_EXT_CTRL, 0x4);\n\n\t \n\tret = mt76_init_mcu_queue(&dev->mt76, MT_MCUQ_WM, MT7921_TXQ_MCU_WM,\n\t\t\t\t  MT7921_TX_MCU_RING_SIZE, MT_TX_RING_BASE);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mt76_init_mcu_queue(&dev->mt76, MT_MCUQ_FWDL, MT7921_TXQ_FWDL,\n\t\t\t\t  MT7921_TX_FWDL_RING_SIZE, MT_TX_RING_BASE);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_MCU],\n\t\t\t       MT7921_RXQ_MCU_WM,\n\t\t\t       MT7921_RX_MCU_RING_SIZE,\n\t\t\t       MT_RX_BUF_SIZE, MT_RX_EVENT_RING_BASE);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_MCU_WA],\n\t\t\t       MT7921_RXQ_MCU_WM,\n\t\t\t       MT7921_RX_MCU_RING_SIZE,\n\t\t\t       MT_RX_BUF_SIZE, MT_WFDMA0(0x540));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_MAIN],\n\t\t\t       MT7921_RXQ_BAND0, MT7921_RX_RING_SIZE,\n\t\t\t       MT_RX_BUF_SIZE, MT_RX_DATA_RING_BASE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt76_init_queues(dev, mt792x_poll_rx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnetif_napi_add_tx(&dev->mt76.tx_napi_dev, &dev->mt76.tx_napi,\n\t\t\t  mt792x_poll_tx);\n\tnapi_enable(&dev->mt76.tx_napi);\n\n\treturn mt792x_dma_enable(dev);\n}\n\nstatic int mt7921_pci_probe(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *id)\n{\n\tstatic const struct mt76_driver_ops drv_ops = {\n\t\t \n\t\t.txwi_size = MT_TXD_SIZE + sizeof(struct mt76_connac_hw_txp),\n\t\t.drv_flags = MT_DRV_TXWI_NO_FREE | MT_DRV_HW_MGMT_TXQ |\n\t\t\t     MT_DRV_AMSDU_OFFLOAD,\n\t\t.survey_flags = SURVEY_INFO_TIME_TX |\n\t\t\t\tSURVEY_INFO_TIME_RX |\n\t\t\t\tSURVEY_INFO_TIME_BSS_RX,\n\t\t.token_size = MT7921_TOKEN_SIZE,\n\t\t.tx_prepare_skb = mt7921e_tx_prepare_skb,\n\t\t.tx_complete_skb = mt76_connac_tx_complete_skb,\n\t\t.rx_check = mt7921_rx_check,\n\t\t.rx_skb = mt7921_queue_rx_skb,\n\t\t.rx_poll_complete = mt792x_rx_poll_complete,\n\t\t.sta_add = mt7921_mac_sta_add,\n\t\t.sta_assoc = mt7921_mac_sta_assoc,\n\t\t.sta_remove = mt7921_mac_sta_remove,\n\t\t.update_survey = mt792x_update_channel,\n\t};\n\tstatic const struct mt792x_hif_ops mt7921_pcie_ops = {\n\t\t.init_reset = mt7921e_init_reset,\n\t\t.reset = mt7921e_mac_reset,\n\t\t.mcu_init = mt7921e_mcu_init,\n\t\t.drv_own = mt792xe_mcu_drv_pmctrl,\n\t\t.fw_own = mt792xe_mcu_fw_pmctrl,\n\t};\n\tstatic const struct mt792x_irq_map irq_map = {\n\t\t.host_irq_enable = MT_WFDMA0_HOST_INT_ENA,\n\t\t.tx = {\n\t\t\t.all_complete_mask = MT_INT_TX_DONE_ALL,\n\t\t\t.mcu_complete_mask = MT_INT_TX_DONE_MCU,\n\t\t},\n\t\t.rx = {\n\t\t\t.data_complete_mask = MT_INT_RX_DONE_DATA,\n\t\t\t.wm_complete_mask = MT_INT_RX_DONE_WM,\n\t\t\t.wm2_complete_mask = MT_INT_RX_DONE_WM2,\n\t\t},\n\t};\n\tstruct ieee80211_ops *ops;\n\tstruct mt76_bus_ops *bus_ops;\n\tstruct mt792x_dev *dev;\n\tstruct mt76_dev *mdev;\n\tu8 features;\n\tint ret;\n\tu16 cmd;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pcim_iomap_regions(pdev, BIT(0), pci_name(pdev));\n\tif (ret)\n\t\treturn ret;\n\n\tpci_read_config_word(pdev, PCI_COMMAND, &cmd);\n\tif (!(cmd & PCI_COMMAND_MEMORY)) {\n\t\tcmd |= PCI_COMMAND_MEMORY;\n\t\tpci_write_config_word(pdev, PCI_COMMAND, cmd);\n\t}\n\tpci_set_master(pdev);\n\n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_ALL_TYPES);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\tgoto err_free_pci_vec;\n\n\tif (mt7921_disable_aspm)\n\t\tmt76_pci_disable_aspm(pdev);\n\n\tops = mt792x_get_mac80211_ops(&pdev->dev, &mt7921_ops,\n\t\t\t\t      (void *)id->driver_data, &features);\n\tif (!ops) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_pci_vec;\n\t}\n\n\tmdev = mt76_alloc_device(&pdev->dev, sizeof(*dev), ops, &drv_ops);\n\tif (!mdev) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_pci_vec;\n\t}\n\n\tpci_set_drvdata(pdev, mdev);\n\n\tdev = container_of(mdev, struct mt792x_dev, mt76);\n\tdev->fw_features = features;\n\tdev->hif_ops = &mt7921_pcie_ops;\n\tdev->irq_map = &irq_map;\n\tmt76_mmio_init(&dev->mt76, pcim_iomap_table(pdev)[0]);\n\ttasklet_init(&mdev->irq_tasklet, mt792x_irq_tasklet, (unsigned long)dev);\n\n\tdev->phy.dev = dev;\n\tdev->phy.mt76 = &dev->mt76.phy;\n\tdev->mt76.phy.priv = &dev->phy;\n\tdev->bus_ops = dev->mt76.bus;\n\tbus_ops = devm_kmemdup(dev->mt76.dev, dev->bus_ops, sizeof(*bus_ops),\n\t\t\t       GFP_KERNEL);\n\tif (!bus_ops) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_dev;\n\t}\n\n\tbus_ops->rr = mt7921_rr;\n\tbus_ops->wr = mt7921_wr;\n\tbus_ops->rmw = mt7921_rmw;\n\tdev->mt76.bus = bus_ops;\n\n\tret = mt792xe_mcu_fw_pmctrl(dev);\n\tif (ret)\n\t\tgoto err_free_dev;\n\n\tret = __mt792xe_mcu_drv_pmctrl(dev);\n\tif (ret)\n\t\tgoto err_free_dev;\n\n\tmdev->rev = (mt7921_l1_rr(dev, MT_HW_CHIPID) << 16) |\n\t\t    (mt7921_l1_rr(dev, MT_HW_REV) & 0xff);\n\tdev_info(mdev->dev, \"ASIC revision: %04x\\n\", mdev->rev);\n\n\tret = mt792x_wfsys_reset(dev);\n\tif (ret)\n\t\tgoto err_free_dev;\n\n\tmt76_wr(dev, irq_map.host_irq_enable, 0);\n\n\tmt76_wr(dev, MT_PCIE_MAC_INT_ENABLE, 0xff);\n\n\tret = devm_request_irq(mdev->dev, pdev->irq, mt792x_irq_handler,\n\t\t\t       IRQF_SHARED, KBUILD_MODNAME, dev);\n\tif (ret)\n\t\tgoto err_free_dev;\n\n\tret = mt7921_dma_init(dev);\n\tif (ret)\n\t\tgoto err_free_irq;\n\n\tret = mt7921_register_device(dev);\n\tif (ret)\n\t\tgoto err_free_irq;\n\n\treturn 0;\n\nerr_free_irq:\n\tdevm_free_irq(&pdev->dev, pdev->irq, dev);\nerr_free_dev:\n\tmt76_free_device(&dev->mt76);\nerr_free_pci_vec:\n\tpci_free_irq_vectors(pdev);\n\n\treturn ret;\n}\n\nstatic void mt7921_pci_remove(struct pci_dev *pdev)\n{\n\tstruct mt76_dev *mdev = pci_get_drvdata(pdev);\n\tstruct mt792x_dev *dev = container_of(mdev, struct mt792x_dev, mt76);\n\n\tmt7921e_unregister_device(dev);\n\tdevm_free_irq(&pdev->dev, pdev->irq, dev);\n\tmt76_free_device(&dev->mt76);\n\tpci_free_irq_vectors(pdev);\n}\n\nstatic int mt7921_pci_suspend(struct device *device)\n{\n\tstruct pci_dev *pdev = to_pci_dev(device);\n\tstruct mt76_dev *mdev = pci_get_drvdata(pdev);\n\tstruct mt792x_dev *dev = container_of(mdev, struct mt792x_dev, mt76);\n\tstruct mt76_connac_pm *pm = &dev->pm;\n\tint i, err;\n\n\tpm->suspended = true;\n\tflush_work(&dev->reset_work);\n\tcancel_delayed_work_sync(&pm->ps_work);\n\tcancel_work_sync(&pm->wake_work);\n\n\terr = mt792x_mcu_drv_pmctrl(dev);\n\tif (err < 0)\n\t\tgoto restore_suspend;\n\n\terr = mt76_connac_mcu_set_hif_suspend(mdev, true);\n\tif (err)\n\t\tgoto restore_suspend;\n\n\t \n\tmt76_connac_mcu_set_deep_sleep(&dev->mt76, true);\n\n\tnapi_disable(&mdev->tx_napi);\n\tmt76_worker_disable(&mdev->tx_worker);\n\n\tmt76_for_each_q_rx(mdev, i) {\n\t\tnapi_disable(&mdev->napi[i]);\n\t}\n\n\t \n\tmt76_poll(dev, MT_WFDMA0_GLO_CFG,\n\t\t  MT_WFDMA0_GLO_CFG_TX_DMA_BUSY |\n\t\t  MT_WFDMA0_GLO_CFG_RX_DMA_BUSY, 0, 1000);\n\n\t \n\tmt76_clear(dev, MT_WFDMA0_GLO_CFG,\n\t\t   MT_WFDMA0_GLO_CFG_TX_DMA_EN | MT_WFDMA0_GLO_CFG_RX_DMA_EN);\n\n\t \n\tmt76_wr(dev, dev->irq_map->host_irq_enable, 0);\n\tmt76_wr(dev, MT_PCIE_MAC_INT_ENABLE, 0x0);\n\tsynchronize_irq(pdev->irq);\n\ttasklet_kill(&mdev->irq_tasklet);\n\n\terr = mt792x_mcu_fw_pmctrl(dev);\n\tif (err)\n\t\tgoto restore_napi;\n\n\treturn 0;\n\nrestore_napi:\n\tmt76_for_each_q_rx(mdev, i) {\n\t\tnapi_enable(&mdev->napi[i]);\n\t}\n\tnapi_enable(&mdev->tx_napi);\n\n\tif (!pm->ds_enable)\n\t\tmt76_connac_mcu_set_deep_sleep(&dev->mt76, false);\n\n\tmt76_connac_mcu_set_hif_suspend(mdev, false);\n\nrestore_suspend:\n\tpm->suspended = false;\n\n\tif (err < 0)\n\t\tmt792x_reset(&dev->mt76);\n\n\treturn err;\n}\n\nstatic int mt7921_pci_resume(struct device *device)\n{\n\tstruct pci_dev *pdev = to_pci_dev(device);\n\tstruct mt76_dev *mdev = pci_get_drvdata(pdev);\n\tstruct mt792x_dev *dev = container_of(mdev, struct mt792x_dev, mt76);\n\tstruct mt76_connac_pm *pm = &dev->pm;\n\tint i, err;\n\n\terr = mt792x_mcu_drv_pmctrl(dev);\n\tif (err < 0)\n\t\tgoto failed;\n\n\tmt792x_wpdma_reinit_cond(dev);\n\n\t \n\tmt76_wr(dev, MT_PCIE_MAC_INT_ENABLE, 0xff);\n\tmt76_connac_irq_enable(&dev->mt76,\n\t\t\t       dev->irq_map->tx.all_complete_mask |\n\t\t\t       MT_INT_RX_DONE_ALL | MT_INT_MCU_CMD);\n\tmt76_set(dev, MT_MCU2HOST_SW_INT_ENA, MT_MCU_CMD_WAKE_RX_PCIE);\n\n\t \n\tmt76_set(dev, MT_WFDMA0_GLO_CFG,\n\t\t MT_WFDMA0_GLO_CFG_TX_DMA_EN | MT_WFDMA0_GLO_CFG_RX_DMA_EN);\n\n\tmt76_worker_enable(&mdev->tx_worker);\n\n\tlocal_bh_disable();\n\tmt76_for_each_q_rx(mdev, i) {\n\t\tnapi_enable(&mdev->napi[i]);\n\t\tnapi_schedule(&mdev->napi[i]);\n\t}\n\tnapi_enable(&mdev->tx_napi);\n\tnapi_schedule(&mdev->tx_napi);\n\tlocal_bh_enable();\n\n\t \n\tif (!pm->ds_enable)\n\t\tmt76_connac_mcu_set_deep_sleep(&dev->mt76, false);\n\n\terr = mt76_connac_mcu_set_hif_suspend(mdev, false);\nfailed:\n\tpm->suspended = false;\n\n\tif (err < 0)\n\t\tmt792x_reset(&dev->mt76);\n\n\treturn err;\n}\n\nstatic void mt7921_pci_shutdown(struct pci_dev *pdev)\n{\n\tmt7921_pci_remove(pdev);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(mt7921_pm_ops, mt7921_pci_suspend, mt7921_pci_resume);\n\nstatic struct pci_driver mt7921_pci_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= mt7921_pci_device_table,\n\t.probe\t\t= mt7921_pci_probe,\n\t.remove\t\t= mt7921_pci_remove,\n\t.shutdown\t= mt7921_pci_shutdown,\n\t.driver.pm\t= pm_sleep_ptr(&mt7921_pm_ops),\n};\n\nmodule_pci_driver(mt7921_pci_driver);\n\nMODULE_DEVICE_TABLE(pci, mt7921_pci_device_table);\nMODULE_FIRMWARE(MT7921_FIRMWARE_WM);\nMODULE_FIRMWARE(MT7921_ROM_PATCH);\nMODULE_FIRMWARE(MT7922_FIRMWARE_WM);\nMODULE_FIRMWARE(MT7922_ROM_PATCH);\nMODULE_AUTHOR(\"Sean Wang <sean.wang@mediatek.com>\");\nMODULE_AUTHOR(\"Lorenzo Bianconi <lorenzo@kernel.org>\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}