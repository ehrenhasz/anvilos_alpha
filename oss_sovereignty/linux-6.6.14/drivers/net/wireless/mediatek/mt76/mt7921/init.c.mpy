{
  "module_name": "init.c",
  "hash_id": "039c7d44600ae5168ac6c25bca487954c6b7cab54a9b44e18a5d19b93437861d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7921/init.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/thermal.h>\n#include <linux/firmware.h>\n#include \"mt7921.h\"\n#include \"../mt76_connac2_mac.h\"\n#include \"mcu.h\"\n\nstatic ssize_t mt7921_thermal_temp_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tswitch (to_sensor_dev_attr(attr)->index) {\n\tcase 0: {\n\t\tstruct mt792x_phy *phy = dev_get_drvdata(dev);\n\t\tstruct mt792x_dev *mdev = phy->dev;\n\t\tint temperature;\n\n\t\tmt792x_mutex_acquire(mdev);\n\t\ttemperature = mt7921_mcu_get_temperature(phy);\n\t\tmt792x_mutex_release(mdev);\n\n\t\tif (temperature < 0)\n\t\t\treturn temperature;\n\t\t \n\t\treturn sprintf(buf, \"%u\\n\", temperature * 1000);\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\nstatic SENSOR_DEVICE_ATTR_RO(temp1_input, mt7921_thermal_temp, 0);\n\nstatic struct attribute *mt7921_hwmon_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(mt7921_hwmon);\n\nstatic int mt7921_thermal_init(struct mt792x_phy *phy)\n{\n\tstruct wiphy *wiphy = phy->mt76->hw->wiphy;\n\tstruct device *hwmon;\n\tconst char *name;\n\n\tif (!IS_REACHABLE(CONFIG_HWMON))\n\t\treturn 0;\n\n\tname = devm_kasprintf(&wiphy->dev, GFP_KERNEL, \"mt7921_%s\",\n\t\t\t      wiphy_name(wiphy));\n\n\thwmon = devm_hwmon_device_register_with_groups(&wiphy->dev, name, phy,\n\t\t\t\t\t\t       mt7921_hwmon_groups);\n\tif (IS_ERR(hwmon))\n\t\treturn PTR_ERR(hwmon);\n\n\treturn 0;\n}\n\nstatic void\nmt7921_regd_notifier(struct wiphy *wiphy,\n\t\t     struct regulatory_request *request)\n{\n\tstruct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\n\tmemcpy(dev->mt76.alpha2, request->alpha2, sizeof(dev->mt76.alpha2));\n\tdev->mt76.region = request->dfs_region;\n\tdev->country_ie_env = request->country_ie_env;\n\n\tmt792x_mutex_acquire(dev);\n\tmt7921_mcu_set_clc(dev, request->alpha2, request->country_ie_env);\n\tmt76_connac_mcu_set_channel_domain(hw->priv);\n\tmt7921_set_tx_sar_pwr(hw, NULL);\n\tmt792x_mutex_release(dev);\n}\n\nint mt7921_mac_init(struct mt792x_dev *dev)\n{\n\tint i;\n\n\tmt76_rmw_field(dev, MT_MDP_DCR1, MT_MDP_DCR1_MAX_RX_LEN, 1536);\n\t \n\tmt76_set(dev, MT_MDP_DCR0, MT_MDP_DCR0_DAMSDU_EN);\n\t \n\tmt76_set(dev, MT_MDP_DCR0, MT_MDP_DCR0_RX_HDR_TRANS_EN);\n\n\tfor (i = 0; i < MT792x_WTBL_SIZE; i++)\n\t\tmt7921_mac_wtbl_update(dev, i,\n\t\t\t\t       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);\n\tfor (i = 0; i < 2; i++)\n\t\tmt792x_mac_init_band(dev, i);\n\n\treturn mt76_connac_mcu_set_rts_thresh(&dev->mt76, 0x92b, 0);\n}\nEXPORT_SYMBOL_GPL(mt7921_mac_init);\n\nstatic int __mt7921_init_hardware(struct mt792x_dev *dev)\n{\n\tint ret;\n\n\t \n\tmt76_wr(dev, MT_SWDEF_MODE, MT_SWDEF_NORMAL_MODE);\n\tret = mt792x_mcu_init(dev);\n\tif (ret)\n\t\tgoto out;\n\n\tmt76_eeprom_override(&dev->mphy);\n\n\tret = mt7921_mcu_set_eeprom(dev);\n\tif (ret)\n\t\tgoto out;\n\n\tret = mt7921_mac_init(dev);\nout:\n\treturn ret;\n}\n\nstatic int mt7921_init_hardware(struct mt792x_dev *dev)\n{\n\tint ret, i;\n\n\tset_bit(MT76_STATE_INITIALIZED, &dev->mphy.state);\n\n\tfor (i = 0; i < MT792x_MCU_INIT_RETRY_COUNT; i++) {\n\t\tret = __mt7921_init_hardware(dev);\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tmt792x_init_reset(dev);\n\t}\n\n\tif (i == MT792x_MCU_INIT_RETRY_COUNT) {\n\t\tdev_err(dev->mt76.dev, \"hardware init failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void mt7921_init_work(struct work_struct *work)\n{\n\tstruct mt792x_dev *dev = container_of(work, struct mt792x_dev,\n\t\t\t\t\t      init_work);\n\tint ret;\n\n\tret = mt7921_init_hardware(dev);\n\tif (ret)\n\t\treturn;\n\n\tmt76_set_stream_caps(&dev->mphy, true);\n\tmt7921_set_stream_he_caps(&dev->phy);\n\n\tret = mt76_register_device(&dev->mt76, true, mt76_rates,\n\t\t\t\t   ARRAY_SIZE(mt76_rates));\n\tif (ret) {\n\t\tdev_err(dev->mt76.dev, \"register device failed\\n\");\n\t\treturn;\n\t}\n\n\tret = mt7921_init_debugfs(dev);\n\tif (ret) {\n\t\tdev_err(dev->mt76.dev, \"register debugfs failed\\n\");\n\t\treturn;\n\t}\n\n\tret = mt7921_thermal_init(&dev->phy);\n\tif (ret) {\n\t\tdev_err(dev->mt76.dev, \"thermal init failed\\n\");\n\t\treturn;\n\t}\n\n\t \n\tdev->hw_init_done = true;\n\n\tmt76_connac_mcu_set_deep_sleep(&dev->mt76, dev->pm.ds_enable);\n}\n\nint mt7921_register_device(struct mt792x_dev *dev)\n{\n\tstruct ieee80211_hw *hw = mt76_hw(dev);\n\tint ret;\n\n\tdev->phy.dev = dev;\n\tdev->phy.mt76 = &dev->mt76.phy;\n\tdev->mt76.phy.priv = &dev->phy;\n\tdev->mt76.tx_worker.fn = mt792x_tx_worker;\n\n\tINIT_DELAYED_WORK(&dev->pm.ps_work, mt792x_pm_power_save_work);\n\tINIT_WORK(&dev->pm.wake_work, mt792x_pm_wake_work);\n\tspin_lock_init(&dev->pm.wake.lock);\n\tmutex_init(&dev->pm.mutex);\n\tinit_waitqueue_head(&dev->pm.wait);\n\tif (mt76_is_sdio(&dev->mt76))\n\t\tinit_waitqueue_head(&dev->mt76.sdio.wait);\n\tspin_lock_init(&dev->pm.txq_lock);\n\tINIT_DELAYED_WORK(&dev->mphy.mac_work, mt792x_mac_work);\n\tINIT_DELAYED_WORK(&dev->phy.scan_work, mt7921_scan_work);\n\tINIT_DELAYED_WORK(&dev->coredump.work, mt7921_coredump_work);\n#if IS_ENABLED(CONFIG_IPV6)\n\tINIT_WORK(&dev->ipv6_ns_work, mt7921_set_ipv6_ns_work);\n\tskb_queue_head_init(&dev->ipv6_ns_list);\n#endif\n\tskb_queue_head_init(&dev->phy.scan_event_list);\n\tskb_queue_head_init(&dev->coredump.msg_list);\n\n\tINIT_WORK(&dev->reset_work, mt7921_mac_reset_work);\n\tINIT_WORK(&dev->init_work, mt7921_init_work);\n\n\tINIT_WORK(&dev->phy.roc_work, mt7921_roc_work);\n\ttimer_setup(&dev->phy.roc_timer, mt792x_roc_timer, 0);\n\tinit_waitqueue_head(&dev->phy.roc_wait);\n\n\tdev->pm.idle_timeout = MT792x_PM_TIMEOUT;\n\tdev->pm.stats.last_wake_event = jiffies;\n\tdev->pm.stats.last_doze_event = jiffies;\n\tif (!mt76_is_usb(&dev->mt76)) {\n\t\tdev->pm.enable_user = true;\n\t\tdev->pm.enable = true;\n\t\tdev->pm.ds_enable_user = true;\n\t\tdev->pm.ds_enable = true;\n\t}\n\n\tif (!mt76_is_mmio(&dev->mt76))\n\t\thw->extra_tx_headroom += MT_SDIO_TXD_SIZE + MT_SDIO_HDR_SIZE;\n\n\tmt792x_init_acpi_sar(dev);\n\n\tret = mt792x_init_wcid(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt792x_init_wiphy(hw);\n\tif (ret)\n\t\treturn ret;\n\n\thw->wiphy->reg_notifier = mt7921_regd_notifier;\n\tdev->mphy.sband_2g.sband.ht_cap.cap |=\n\t\t\tIEEE80211_HT_CAP_LDPC_CODING |\n\t\t\tIEEE80211_HT_CAP_MAX_AMSDU;\n\tdev->mphy.sband_5g.sband.ht_cap.cap |=\n\t\t\tIEEE80211_HT_CAP_LDPC_CODING |\n\t\t\tIEEE80211_HT_CAP_MAX_AMSDU;\n\tdev->mphy.sband_5g.sband.vht_cap.cap |=\n\t\t\tIEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454 |\n\t\t\tIEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK |\n\t\t\tIEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE |\n\t\t\tIEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE |\n\t\t\t(3 << IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT);\n\tif (is_mt7922(&dev->mt76))\n\t\tdev->mphy.sband_5g.sband.vht_cap.cap |=\n\t\t\tIEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ |\n\t\t\tIEEE80211_VHT_CAP_SHORT_GI_160;\n\n\tdev->mphy.hw->wiphy->available_antennas_rx = dev->mphy.chainmask;\n\tdev->mphy.hw->wiphy->available_antennas_tx = dev->mphy.chainmask;\n\n\tqueue_work(system_wq, &dev->init_work);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt7921_register_device);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}