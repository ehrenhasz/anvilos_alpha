{
  "module_name": "main.c",
  "hash_id": "107b3cee731201dbd2a52055a44e70d24eb7fb3bf80f36329cfce1fb804efd37",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7921/main.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/platform_device.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <net/ipv6.h>\n#include \"mt7921.h\"\n#include \"mcu.h\"\n\nstatic int\nmt7921_init_he_caps(struct mt792x_phy *phy, enum nl80211_band band,\n\t\t    struct ieee80211_sband_iftype_data *data)\n{\n\tint i, idx = 0;\n\tint nss = hweight8(phy->mt76->chainmask);\n\tu16 mcs_map = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (i < nss)\n\t\t\tmcs_map |= (IEEE80211_HE_MCS_SUPPORT_0_11 << (i * 2));\n\t\telse\n\t\t\tmcs_map |= (IEEE80211_HE_MCS_NOT_SUPPORTED << (i * 2));\n\t}\n\n\tfor (i = 0; i < NUM_NL80211_IFTYPES; i++) {\n\t\tstruct ieee80211_sta_he_cap *he_cap = &data[idx].he_cap;\n\t\tstruct ieee80211_he_cap_elem *he_cap_elem =\n\t\t\t\t&he_cap->he_cap_elem;\n\t\tstruct ieee80211_he_mcs_nss_supp *he_mcs =\n\t\t\t\t&he_cap->he_mcs_nss_supp;\n\n\t\tswitch (i) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tdata[idx].types_mask = BIT(i);\n\t\the_cap->has_he = true;\n\n\t\the_cap_elem->mac_cap_info[0] =\n\t\t\tIEEE80211_HE_MAC_CAP0_HTC_HE;\n\t\the_cap_elem->mac_cap_info[3] =\n\t\t\tIEEE80211_HE_MAC_CAP3_OMI_CONTROL |\n\t\t\tIEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_3;\n\t\the_cap_elem->mac_cap_info[4] =\n\t\t\tIEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU;\n\n\t\tif (band == NL80211_BAND_2GHZ)\n\t\t\the_cap_elem->phy_cap_info[0] =\n\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G;\n\t\telse\n\t\t\the_cap_elem->phy_cap_info[0] =\n\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G;\n\n\t\the_cap_elem->phy_cap_info[1] =\n\t\t\tIEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD;\n\t\the_cap_elem->phy_cap_info[2] =\n\t\t\tIEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US |\n\t\t\tIEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ |\n\t\t\tIEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ |\n\t\t\tIEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO |\n\t\t\tIEEE80211_HE_PHY_CAP2_UL_MU_PARTIAL_MU_MIMO;\n\n\t\tswitch (i) {\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\the_cap_elem->mac_cap_info[2] |=\n\t\t\t\tIEEE80211_HE_MAC_CAP2_BSR;\n\t\t\the_cap_elem->mac_cap_info[4] |=\n\t\t\t\tIEEE80211_HE_MAC_CAP4_BQR;\n\t\t\the_cap_elem->mac_cap_info[5] |=\n\t\t\t\tIEEE80211_HE_MAC_CAP5_OM_CTRL_UL_MU_DATA_DIS_RX;\n\t\t\the_cap_elem->phy_cap_info[3] |=\n\t\t\t\tIEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_QPSK |\n\t\t\t\tIEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_QPSK;\n\t\t\the_cap_elem->phy_cap_info[6] |=\n\t\t\t\tIEEE80211_HE_PHY_CAP6_PARTIAL_BW_EXT_RANGE |\n\t\t\t\tIEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT;\n\t\t\the_cap_elem->phy_cap_info[9] |=\n\t\t\t\tIEEE80211_HE_PHY_CAP9_TX_1024_QAM_LESS_THAN_242_TONE_RU |\n\t\t\t\tIEEE80211_HE_PHY_CAP9_RX_1024_QAM_LESS_THAN_242_TONE_RU;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\the_cap_elem->mac_cap_info[1] |=\n\t\t\t\tIEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US;\n\n\t\t\tif (band == NL80211_BAND_2GHZ)\n\t\t\t\the_cap_elem->phy_cap_info[0] |=\n\t\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_RU_MAPPING_IN_2G;\n\t\t\telse\n\t\t\t\the_cap_elem->phy_cap_info[0] |=\n\t\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_RU_MAPPING_IN_5G;\n\n\t\t\the_cap_elem->phy_cap_info[1] |=\n\t\t\t\tIEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |\n\t\t\t\tIEEE80211_HE_PHY_CAP1_HE_LTF_AND_GI_FOR_HE_PPDUS_0_8US;\n\t\t\the_cap_elem->phy_cap_info[3] |=\n\t\t\t\tIEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_QPSK |\n\t\t\t\tIEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_QPSK;\n\t\t\the_cap_elem->phy_cap_info[4] |=\n\t\t\t\tIEEE80211_HE_PHY_CAP4_SU_BEAMFORMEE |\n\t\t\t\tIEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_4;\n\t\t\the_cap_elem->phy_cap_info[5] |=\n\t\t\t\tIEEE80211_HE_PHY_CAP5_NG16_SU_FEEDBACK |\n\t\t\t\tIEEE80211_HE_PHY_CAP5_NG16_MU_FEEDBACK;\n\t\t\the_cap_elem->phy_cap_info[6] |=\n\t\t\t\tIEEE80211_HE_PHY_CAP6_CODEBOOK_SIZE_42_SU |\n\t\t\t\tIEEE80211_HE_PHY_CAP6_CODEBOOK_SIZE_75_MU |\n\t\t\t\tIEEE80211_HE_PHY_CAP6_TRIG_CQI_FB |\n\t\t\t\tIEEE80211_HE_PHY_CAP6_PARTIAL_BW_EXT_RANGE |\n\t\t\t\tIEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT;\n\t\t\the_cap_elem->phy_cap_info[7] |=\n\t\t\t\tIEEE80211_HE_PHY_CAP7_POWER_BOOST_FACTOR_SUPP |\n\t\t\t\tIEEE80211_HE_PHY_CAP7_HE_SU_MU_PPDU_4XLTF_AND_08_US_GI;\n\t\t\the_cap_elem->phy_cap_info[8] |=\n\t\t\t\tIEEE80211_HE_PHY_CAP8_20MHZ_IN_40MHZ_HE_PPDU_IN_2G |\n\t\t\t\tIEEE80211_HE_PHY_CAP8_DCM_MAX_RU_484;\n\t\t\the_cap_elem->phy_cap_info[9] |=\n\t\t\t\tIEEE80211_HE_PHY_CAP9_LONGER_THAN_16_SIGB_OFDM_SYM |\n\t\t\t\tIEEE80211_HE_PHY_CAP9_NON_TRIGGERED_CQI_FEEDBACK |\n\t\t\t\tIEEE80211_HE_PHY_CAP9_TX_1024_QAM_LESS_THAN_242_TONE_RU |\n\t\t\t\tIEEE80211_HE_PHY_CAP9_RX_1024_QAM_LESS_THAN_242_TONE_RU |\n\t\t\t\tIEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_COMP_SIGB |\n\t\t\t\tIEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_NON_COMP_SIGB;\n\n\t\t\tif (is_mt7922(phy->mt76->dev)) {\n\t\t\t\the_cap_elem->phy_cap_info[0] |=\n\t\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G;\n\t\t\t\the_cap_elem->phy_cap_info[8] |=\n\t\t\t\t\tIEEE80211_HE_PHY_CAP8_20MHZ_IN_160MHZ_HE_PPDU |\n\t\t\t\t\tIEEE80211_HE_PHY_CAP8_80MHZ_IN_160MHZ_HE_PPDU;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\the_mcs->rx_mcs_80 = cpu_to_le16(mcs_map);\n\t\the_mcs->tx_mcs_80 = cpu_to_le16(mcs_map);\n\t\tif (is_mt7922(phy->mt76->dev)) {\n\t\t\the_mcs->rx_mcs_160 = cpu_to_le16(mcs_map);\n\t\t\the_mcs->tx_mcs_160 = cpu_to_le16(mcs_map);\n\t\t}\n\n\t\tmemset(he_cap->ppe_thres, 0, sizeof(he_cap->ppe_thres));\n\t\tif (he_cap_elem->phy_cap_info[6] &\n\t\t    IEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT) {\n\t\t\tmt76_connac_gen_ppe_thresh(he_cap->ppe_thres, nss);\n\t\t} else {\n\t\t\the_cap_elem->phy_cap_info[9] |=\n\t\t\t\tu8_encode_bits(IEEE80211_HE_PHY_CAP9_NOMINAL_PKT_PADDING_16US,\n\t\t\t\t\t       IEEE80211_HE_PHY_CAP9_NOMINAL_PKT_PADDING_MASK);\n\t\t}\n\n\t\tif (band == NL80211_BAND_6GHZ) {\n\t\t\tstruct ieee80211_supported_band *sband =\n\t\t\t\t&phy->mt76->sband_5g.sband;\n\t\t\tstruct ieee80211_sta_vht_cap *vht_cap = &sband->vht_cap;\n\t\t\tstruct ieee80211_sta_ht_cap *ht_cap = &sband->ht_cap;\n\t\t\tu32 exp;\n\t\t\tu16 cap;\n\n\t\t\tcap = u16_encode_bits(ht_cap->ampdu_density,\n\t\t\t\t\tIEEE80211_HE_6GHZ_CAP_MIN_MPDU_START);\n\t\t\texp = u32_get_bits(vht_cap->cap,\n\t\t\t\tIEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK);\n\t\t\tcap |= u16_encode_bits(exp,\n\t\t\t\t\tIEEE80211_HE_6GHZ_CAP_MAX_AMPDU_LEN_EXP);\n\t\t\texp = u32_get_bits(vht_cap->cap,\n\t\t\t\t\t   IEEE80211_VHT_CAP_MAX_MPDU_MASK);\n\t\t\tcap |= u16_encode_bits(exp,\n\t\t\t\t\tIEEE80211_HE_6GHZ_CAP_MAX_MPDU_LEN);\n\t\t\tif (vht_cap->cap & IEEE80211_VHT_CAP_TX_ANTENNA_PATTERN)\n\t\t\t\tcap |= IEEE80211_HE_6GHZ_CAP_TX_ANTPAT_CONS;\n\t\t\tif (vht_cap->cap & IEEE80211_VHT_CAP_RX_ANTENNA_PATTERN)\n\t\t\t\tcap |= IEEE80211_HE_6GHZ_CAP_RX_ANTPAT_CONS;\n\n\t\t\tdata[idx].he_6ghz_capa.capa = cpu_to_le16(cap);\n\t\t}\n\t\tidx++;\n\t}\n\n\treturn idx;\n}\n\nvoid mt7921_set_stream_he_caps(struct mt792x_phy *phy)\n{\n\tstruct ieee80211_sband_iftype_data *data;\n\tstruct ieee80211_supported_band *band;\n\tint n;\n\n\tif (phy->mt76->cap.has_2ghz) {\n\t\tdata = phy->iftype[NL80211_BAND_2GHZ];\n\t\tn = mt7921_init_he_caps(phy, NL80211_BAND_2GHZ, data);\n\n\t\tband = &phy->mt76->sband_2g.sband;\n\t\tband->iftype_data = data;\n\t\tband->n_iftype_data = n;\n\t}\n\n\tif (phy->mt76->cap.has_5ghz) {\n\t\tdata = phy->iftype[NL80211_BAND_5GHZ];\n\t\tn = mt7921_init_he_caps(phy, NL80211_BAND_5GHZ, data);\n\n\t\tband = &phy->mt76->sband_5g.sband;\n\t\tband->iftype_data = data;\n\t\tband->n_iftype_data = n;\n\n\t\tif (phy->mt76->cap.has_6ghz) {\n\t\t\tdata = phy->iftype[NL80211_BAND_6GHZ];\n\t\t\tn = mt7921_init_he_caps(phy, NL80211_BAND_6GHZ, data);\n\n\t\t\tband = &phy->mt76->sband_6g.sband;\n\t\t\tband->iftype_data = data;\n\t\t\tband->n_iftype_data = n;\n\t\t}\n\t}\n}\n\nint __mt7921_start(struct mt792x_phy *phy)\n{\n\tstruct mt76_phy *mphy = phy->mt76;\n\tint err;\n\n\terr = mt76_connac_mcu_set_mac_enable(mphy->dev, 0, true, false);\n\tif (err)\n\t\treturn err;\n\n\terr = mt76_connac_mcu_set_channel_domain(mphy);\n\tif (err)\n\t\treturn err;\n\n\terr = mt7921_mcu_set_chan_info(phy, MCU_EXT_CMD(SET_RX_PATH));\n\tif (err)\n\t\treturn err;\n\n\terr = mt7921_set_tx_sar_pwr(mphy->hw, NULL);\n\tif (err)\n\t\treturn err;\n\n\tmt792x_mac_reset_counters(phy);\n\tset_bit(MT76_STATE_RUNNING, &mphy->state);\n\n\tieee80211_queue_delayed_work(mphy->hw, &mphy->mac_work,\n\t\t\t\t     MT792x_WATCHDOG_TIME);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__mt7921_start);\n\nstatic int mt7921_start(struct ieee80211_hw *hw)\n{\n\tstruct mt792x_phy *phy = mt792x_hw_phy(hw);\n\tint err;\n\n\tmt792x_mutex_acquire(phy->dev);\n\terr = __mt7921_start(phy);\n\tmt792x_mutex_release(phy->dev);\n\n\treturn err;\n}\n\nvoid mt7921_stop(struct ieee80211_hw *hw)\n{\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\tstruct mt792x_phy *phy = mt792x_hw_phy(hw);\n\n\tcancel_delayed_work_sync(&phy->mt76->mac_work);\n\n\tcancel_delayed_work_sync(&dev->pm.ps_work);\n\tcancel_work_sync(&dev->pm.wake_work);\n\tcancel_work_sync(&dev->reset_work);\n\tmt76_connac_free_pending_tx_skbs(&dev->pm, NULL);\n\n\tmt792x_mutex_acquire(dev);\n\tclear_bit(MT76_STATE_RUNNING, &phy->mt76->state);\n\tmt76_connac_mcu_set_mac_enable(&dev->mt76, 0, false, false);\n\tmt792x_mutex_release(dev);\n}\nEXPORT_SYMBOL_GPL(mt7921_stop);\n\nstatic int\nmt7921_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\tstruct mt792x_phy *phy = mt792x_hw_phy(hw);\n\tstruct mt76_txq *mtxq;\n\tint idx, ret = 0;\n\n\tmt792x_mutex_acquire(dev);\n\n\tmvif->mt76.idx = __ffs64(~dev->mt76.vif_mask);\n\tif (mvif->mt76.idx >= MT792x_MAX_INTERFACES) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tmvif->mt76.omac_idx = mvif->mt76.idx;\n\tmvif->phy = phy;\n\tmvif->mt76.band_idx = 0;\n\tmvif->mt76.wmm_idx = mvif->mt76.idx % MT76_CONNAC_MAX_WMM_SETS;\n\n\tret = mt76_connac_mcu_uni_add_dev(&dev->mphy, vif, &mvif->sta.wcid,\n\t\t\t\t\t  true);\n\tif (ret)\n\t\tgoto out;\n\n\tdev->mt76.vif_mask |= BIT_ULL(mvif->mt76.idx);\n\tphy->omac_mask |= BIT_ULL(mvif->mt76.omac_idx);\n\n\tidx = MT792x_WTBL_RESERVED - mvif->mt76.idx;\n\n\tINIT_LIST_HEAD(&mvif->sta.wcid.poll_list);\n\tmvif->sta.wcid.idx = idx;\n\tmvif->sta.wcid.phy_idx = mvif->mt76.band_idx;\n\tmvif->sta.wcid.hw_key_idx = -1;\n\tmvif->sta.wcid.tx_info |= MT_WCID_TX_INFO_SET;\n\tmt76_packet_id_init(&mvif->sta.wcid);\n\n\tmt7921_mac_wtbl_update(dev, idx,\n\t\t\t       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);\n\n\tewma_rssi_init(&mvif->rssi);\n\n\trcu_assign_pointer(dev->mt76.wcid[idx], &mvif->sta.wcid);\n\tif (vif->txq) {\n\t\tmtxq = (struct mt76_txq *)vif->txq->drv_priv;\n\t\tmtxq->wcid = idx;\n\t}\n\n\tvif->driver_flags |= IEEE80211_VIF_BEACON_FILTER;\nout:\n\tmt792x_mutex_release(dev);\n\n\treturn ret;\n}\n\nstatic void mt7921_roc_iter(void *priv, u8 *mac,\n\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tstruct mt792x_phy *phy = priv;\n\n\tmt7921_mcu_abort_roc(phy, mvif, phy->roc_token_id);\n}\n\nvoid mt7921_roc_work(struct work_struct *work)\n{\n\tstruct mt792x_phy *phy;\n\n\tphy = (struct mt792x_phy *)container_of(work, struct mt792x_phy,\n\t\t\t\t\t\troc_work);\n\n\tif (!test_and_clear_bit(MT76_STATE_ROC, &phy->mt76->state))\n\t\treturn;\n\n\tmt792x_mutex_acquire(phy->dev);\n\tieee80211_iterate_active_interfaces(phy->mt76->hw,\n\t\t\t\t\t    IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\t\t\t    mt7921_roc_iter, phy);\n\tmt792x_mutex_release(phy->dev);\n\tieee80211_remain_on_channel_expired(phy->mt76->hw);\n}\n\nstatic int mt7921_abort_roc(struct mt792x_phy *phy, struct mt792x_vif *vif)\n{\n\tint err = 0;\n\n\tdel_timer_sync(&phy->roc_timer);\n\tcancel_work_sync(&phy->roc_work);\n\n\tmt792x_mutex_acquire(phy->dev);\n\tif (test_and_clear_bit(MT76_STATE_ROC, &phy->mt76->state))\n\t\terr = mt7921_mcu_abort_roc(phy, vif, phy->roc_token_id);\n\tmt792x_mutex_release(phy->dev);\n\n\treturn err;\n}\n\nstatic int mt7921_set_roc(struct mt792x_phy *phy,\n\t\t\t  struct mt792x_vif *vif,\n\t\t\t  struct ieee80211_channel *chan,\n\t\t\t  int duration,\n\t\t\t  enum mt7921_roc_req type)\n{\n\tint err;\n\n\tif (test_and_set_bit(MT76_STATE_ROC, &phy->mt76->state))\n\t\treturn -EBUSY;\n\n\tphy->roc_grant = false;\n\n\terr = mt7921_mcu_set_roc(phy, vif, chan, duration, type,\n\t\t\t\t ++phy->roc_token_id);\n\tif (err < 0) {\n\t\tclear_bit(MT76_STATE_ROC, &phy->mt76->state);\n\t\tgoto out;\n\t}\n\n\tif (!wait_event_timeout(phy->roc_wait, phy->roc_grant, HZ)) {\n\t\tmt7921_mcu_abort_roc(phy, vif, phy->roc_token_id);\n\t\tclear_bit(MT76_STATE_ROC, &phy->mt76->state);\n\t\terr = -ETIMEDOUT;\n\t}\n\nout:\n\treturn err;\n}\n\nstatic int mt7921_remain_on_channel(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_channel *chan,\n\t\t\t\t    int duration,\n\t\t\t\t    enum ieee80211_roc_type type)\n{\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tstruct mt792x_phy *phy = mt792x_hw_phy(hw);\n\tint err;\n\n\tmt792x_mutex_acquire(phy->dev);\n\terr = mt7921_set_roc(phy, mvif, chan, duration, MT7921_ROC_REQ_ROC);\n\tmt792x_mutex_release(phy->dev);\n\n\treturn err;\n}\n\nstatic int mt7921_cancel_remain_on_channel(struct ieee80211_hw *hw,\n\t\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tstruct mt792x_phy *phy = mt792x_hw_phy(hw);\n\n\treturn mt7921_abort_roc(phy, mvif);\n}\n\nstatic int mt7921_set_channel(struct mt792x_phy *phy)\n{\n\tstruct mt792x_dev *dev = phy->dev;\n\tint ret;\n\n\tcancel_delayed_work_sync(&phy->mt76->mac_work);\n\n\tmt792x_mutex_acquire(dev);\n\tset_bit(MT76_RESET, &phy->mt76->state);\n\n\tmt76_set_channel(phy->mt76);\n\n\tret = mt7921_mcu_set_chan_info(phy, MCU_EXT_CMD(CHANNEL_SWITCH));\n\tif (ret)\n\t\tgoto out;\n\n\tmt792x_mac_set_timeing(phy);\n\n\tmt792x_mac_reset_counters(phy);\n\tphy->noise = 0;\n\nout:\n\tclear_bit(MT76_RESET, &phy->mt76->state);\n\tmt792x_mutex_release(dev);\n\n\tmt76_worker_schedule(&dev->mt76.tx_worker);\n\tieee80211_queue_delayed_work(phy->mt76->hw, &phy->mt76->mac_work,\n\t\t\t\t     MT792x_WATCHDOG_TIME);\n\n\treturn ret;\n}\n\nstatic int mt7921_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t\t  struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t\t  struct ieee80211_key_conf *key)\n{\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tstruct mt792x_sta *msta = sta ? (struct mt792x_sta *)sta->drv_priv :\n\t\t\t\t  &mvif->sta;\n\tstruct mt76_wcid *wcid = &msta->wcid;\n\tu8 *wcid_keyidx = &wcid->hw_key_idx;\n\tint idx = key->keyidx, err = 0;\n\n\t \n\tif ((vif->type == NL80211_IFTYPE_ADHOC ||\n\t     vif->type == NL80211_IFTYPE_MESH_POINT) &&\n\t    (key->cipher == WLAN_CIPHER_SUITE_TKIP ||\n\t     key->cipher == WLAN_CIPHER_SUITE_CCMP) &&\n\t    !(key->flags & IEEE80211_KEY_FLAG_PAIRWISE))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIE;\n\t\twcid_keyidx = &wcid->hw_key_idx2;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tif (!mvif->wep_sta)\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\tcase WLAN_CIPHER_SUITE_SMS4:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmt792x_mutex_acquire(dev);\n\n\tif (cmd == SET_KEY) {\n\t\t*wcid_keyidx = idx;\n\t} else {\n\t\tif (idx == *wcid_keyidx)\n\t\t\t*wcid_keyidx = -1;\n\t\tgoto out;\n\t}\n\n\tmt76_wcid_key_setup(&dev->mt76, wcid, key);\n\terr = mt76_connac_mcu_add_key(&dev->mt76, vif, &msta->bip,\n\t\t\t\t      key, MCU_UNI_CMD(STA_REC_UPDATE),\n\t\t\t\t      &msta->wcid, cmd);\n\tif (err)\n\t\tgoto out;\n\n\tif (key->cipher == WLAN_CIPHER_SUITE_WEP104 ||\n\t    key->cipher == WLAN_CIPHER_SUITE_WEP40)\n\t\terr = mt76_connac_mcu_add_key(&dev->mt76, vif,\n\t\t\t\t\t      &mvif->wep_sta->bip,\n\t\t\t\t\t      key, MCU_UNI_CMD(STA_REC_UPDATE),\n\t\t\t\t\t      &mvif->wep_sta->wcid, cmd);\nout:\n\tmt792x_mutex_release(dev);\n\n\treturn err;\n}\n\nstatic void\nmt7921_pm_interface_iter(void *priv, u8 *mac, struct ieee80211_vif *vif)\n{\n\tstruct mt792x_dev *dev = priv;\n\tstruct ieee80211_hw *hw = mt76_hw(dev);\n\tbool pm_enable = dev->pm.enable;\n\tint err;\n\n\terr = mt7921_mcu_set_beacon_filter(dev, vif, pm_enable);\n\tif (err < 0)\n\t\treturn;\n\n\tif (pm_enable) {\n\t\tvif->driver_flags |= IEEE80211_VIF_BEACON_FILTER;\n\t\tieee80211_hw_set(hw, CONNECTION_MONITOR);\n\t} else {\n\t\tvif->driver_flags &= ~IEEE80211_VIF_BEACON_FILTER;\n\t\t__clear_bit(IEEE80211_HW_CONNECTION_MONITOR, hw->flags);\n\t}\n}\n\nstatic void\nmt7921_sniffer_interface_iter(void *priv, u8 *mac, struct ieee80211_vif *vif)\n{\n\tstruct mt792x_dev *dev = priv;\n\tstruct ieee80211_hw *hw = mt76_hw(dev);\n\tstruct mt76_connac_pm *pm = &dev->pm;\n\tbool monitor = !!(hw->conf.flags & IEEE80211_CONF_MONITOR);\n\n\tmt7921_mcu_set_sniffer(dev, vif, monitor);\n\tpm->enable = pm->enable_user && !monitor;\n\tpm->ds_enable = pm->ds_enable_user && !monitor;\n\n\tmt76_connac_mcu_set_deep_sleep(&dev->mt76, pm->ds_enable);\n\n\tif (monitor)\n\t\tmt7921_mcu_set_beacon_filter(dev, vif, false);\n}\n\nvoid mt7921_set_runtime_pm(struct mt792x_dev *dev)\n{\n\tstruct ieee80211_hw *hw = mt76_hw(dev);\n\tstruct mt76_connac_pm *pm = &dev->pm;\n\tbool monitor = !!(hw->conf.flags & IEEE80211_CONF_MONITOR);\n\n\tpm->enable = pm->enable_user && !monitor;\n\tieee80211_iterate_active_interfaces(hw,\n\t\t\t\t\t    IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\t\t\t    mt7921_pm_interface_iter, dev);\n\tpm->ds_enable = pm->ds_enable_user && !monitor;\n\tmt76_connac_mcu_set_deep_sleep(&dev->mt76, pm->ds_enable);\n}\n\nstatic int mt7921_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\tstruct mt792x_phy *phy = mt792x_hw_phy(hw);\n\tint ret = 0;\n\n\tif (changed & IEEE80211_CONF_CHANGE_CHANNEL) {\n\t\tieee80211_stop_queues(hw);\n\t\tret = mt7921_set_channel(phy);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tieee80211_wake_queues(hw);\n\t}\n\n\tmt792x_mutex_acquire(dev);\n\n\tif (changed & IEEE80211_CONF_CHANGE_POWER) {\n\t\tret = mt7921_set_tx_sar_pwr(hw, NULL);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_MONITOR) {\n\t\tieee80211_iterate_active_interfaces(hw,\n\t\t\t\t\t\t    IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\t\t\t\t    mt7921_sniffer_interface_iter, dev);\n\t}\n\nout:\n\tmt792x_mutex_release(dev);\n\n\treturn ret;\n}\n\nstatic void mt7921_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t    unsigned int changed_flags,\n\t\t\t\t    unsigned int *total_flags,\n\t\t\t\t    u64 multicast)\n{\n#define MT7921_FILTER_FCSFAIL    BIT(2)\n#define MT7921_FILTER_CONTROL    BIT(5)\n#define MT7921_FILTER_OTHER_BSS  BIT(6)\n#define MT7921_FILTER_ENABLE     BIT(31)\n\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\tu32 flags = MT7921_FILTER_ENABLE;\n\n#define MT7921_FILTER(_fif, _type) do {\t\t\t\\\n\t\tif (*total_flags & (_fif))\t\t\\\n\t\t\tflags |= MT7921_FILTER_##_type;\t\\\n\t} while (0)\n\n\tMT7921_FILTER(FIF_FCSFAIL, FCSFAIL);\n\tMT7921_FILTER(FIF_CONTROL, CONTROL);\n\tMT7921_FILTER(FIF_OTHER_BSS, OTHER_BSS);\n\n\tmt792x_mutex_acquire(dev);\n\tmt7921_mcu_set_rxfilter(dev, flags, 0, 0);\n\tmt792x_mutex_release(dev);\n\n\t*total_flags &= (FIF_OTHER_BSS | FIF_FCSFAIL | FIF_CONTROL);\n}\n\nstatic void mt7921_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_bss_conf *info,\n\t\t\t\t    u64 changed)\n{\n\tstruct mt792x_phy *phy = mt792x_hw_phy(hw);\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\n\tmt792x_mutex_acquire(dev);\n\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\tint slottime = info->use_short_slot ? 9 : 20;\n\n\t\tif (slottime != phy->slottime) {\n\t\t\tphy->slottime = slottime;\n\t\t\tmt792x_mac_set_timeing(phy);\n\t\t}\n\t}\n\n\tif (changed & (BSS_CHANGED_BEACON |\n\t\t       BSS_CHANGED_BEACON_ENABLED))\n\t\tmt7921_mcu_uni_add_beacon_offload(dev, hw, vif,\n\t\t\t\t\t\t  info->enable_beacon);\n\n\t \n\tif (changed & (BSS_CHANGED_QOS | BSS_CHANGED_BEACON_ENABLED))\n\t\tmt7921_mcu_set_tx(dev, vif);\n\n\tif (changed & BSS_CHANGED_PS)\n\t\tmt7921_mcu_uni_bss_ps(dev, vif);\n\n\tif (changed & BSS_CHANGED_ASSOC) {\n\t\tmt7921_mcu_sta_update(dev, NULL, vif, true,\n\t\t\t\t      MT76_STA_INFO_STATE_ASSOC);\n\t\tmt7921_mcu_set_beacon_filter(dev, vif, vif->cfg.assoc);\n\t}\n\n\tif (changed & BSS_CHANGED_ARP_FILTER) {\n\t\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\n\t\tmt76_connac_mcu_update_arp_filter(&dev->mt76, &mvif->mt76,\n\t\t\t\t\t\t  info);\n\t}\n\n\tmt792x_mutex_release(dev);\n}\n\nint mt7921_mac_sta_add(struct mt76_dev *mdev, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_sta *sta)\n{\n\tstruct mt792x_dev *dev = container_of(mdev, struct mt792x_dev, mt76);\n\tstruct mt792x_sta *msta = (struct mt792x_sta *)sta->drv_priv;\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tint ret, idx;\n\n\tidx = mt76_wcid_alloc(dev->mt76.wcid_mask, MT792x_WTBL_STA - 1);\n\tif (idx < 0)\n\t\treturn -ENOSPC;\n\n\tINIT_LIST_HEAD(&msta->wcid.poll_list);\n\tmsta->vif = mvif;\n\tmsta->wcid.sta = 1;\n\tmsta->wcid.idx = idx;\n\tmsta->wcid.phy_idx = mvif->mt76.band_idx;\n\tmsta->wcid.tx_info |= MT_WCID_TX_INFO_SET;\n\tmsta->last_txs = jiffies;\n\n\tret = mt76_connac_pm_wake(&dev->mphy, &dev->pm);\n\tif (ret)\n\t\treturn ret;\n\n\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\tmvif->wep_sta = msta;\n\n\tmt7921_mac_wtbl_update(dev, idx,\n\t\t\t       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);\n\n\tret = mt7921_mcu_sta_update(dev, sta, vif, true,\n\t\t\t\t    MT76_STA_INFO_STATE_NONE);\n\tif (ret)\n\t\treturn ret;\n\n\tmt76_connac_power_save_sched(&dev->mphy, &dev->pm);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt7921_mac_sta_add);\n\nvoid mt7921_mac_sta_assoc(struct mt76_dev *mdev, struct ieee80211_vif *vif,\n\t\t\t  struct ieee80211_sta *sta)\n{\n\tstruct mt792x_dev *dev = container_of(mdev, struct mt792x_dev, mt76);\n\tstruct mt792x_sta *msta = (struct mt792x_sta *)sta->drv_priv;\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\n\tmt792x_mutex_acquire(dev);\n\n\tif (vif->type == NL80211_IFTYPE_STATION && !sta->tdls)\n\t\tmt76_connac_mcu_uni_add_bss(&dev->mphy, vif, &mvif->sta.wcid,\n\t\t\t\t\t    true, mvif->mt76.ctx);\n\n\tewma_avg_signal_init(&msta->avg_ack_signal);\n\n\tmt7921_mac_wtbl_update(dev, msta->wcid.idx,\n\t\t\t       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);\n\tmemset(msta->airtime_ac, 0, sizeof(msta->airtime_ac));\n\n\tmt7921_mcu_sta_update(dev, sta, vif, true, MT76_STA_INFO_STATE_ASSOC);\n\n\tmt792x_mutex_release(dev);\n}\nEXPORT_SYMBOL_GPL(mt7921_mac_sta_assoc);\n\nvoid mt7921_mac_sta_remove(struct mt76_dev *mdev, struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_sta *sta)\n{\n\tstruct mt792x_dev *dev = container_of(mdev, struct mt792x_dev, mt76);\n\tstruct mt792x_sta *msta = (struct mt792x_sta *)sta->drv_priv;\n\n\tmt76_connac_free_pending_tx_skbs(&dev->pm, &msta->wcid);\n\tmt76_connac_pm_wake(&dev->mphy, &dev->pm);\n\n\tmt7921_mcu_sta_update(dev, sta, vif, false, MT76_STA_INFO_STATE_NONE);\n\tmt7921_mac_wtbl_update(dev, msta->wcid.idx,\n\t\t\t       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);\n\n\tif (vif->type == NL80211_IFTYPE_STATION) {\n\t\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\n\t\tmvif->wep_sta = NULL;\n\t\tewma_rssi_init(&mvif->rssi);\n\t\tif (!sta->tdls)\n\t\t\tmt76_connac_mcu_uni_add_bss(&dev->mphy, vif,\n\t\t\t\t\t\t    &mvif->sta.wcid, false,\n\t\t\t\t\t\t    mvif->mt76.ctx);\n\t}\n\n\tspin_lock_bh(&dev->mt76.sta_poll_lock);\n\tif (!list_empty(&msta->wcid.poll_list))\n\t\tlist_del_init(&msta->wcid.poll_list);\n\tspin_unlock_bh(&dev->mt76.sta_poll_lock);\n\n\tmt76_connac_power_save_sched(&dev->mphy, &dev->pm);\n}\nEXPORT_SYMBOL_GPL(mt7921_mac_sta_remove);\n\nstatic int mt7921_set_rts_threshold(struct ieee80211_hw *hw, u32 val)\n{\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\n\tmt792x_mutex_acquire(dev);\n\tmt76_connac_mcu_set_rts_thresh(&dev->mt76, val, 0);\n\tmt792x_mutex_release(dev);\n\n\treturn 0;\n}\n\nstatic int\nmt7921_ampdu_action(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t    struct ieee80211_ampdu_params *params)\n{\n\tenum ieee80211_ampdu_mlme_action action = params->action;\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\tstruct ieee80211_sta *sta = params->sta;\n\tstruct ieee80211_txq *txq = sta->txq[params->tid];\n\tstruct mt792x_sta *msta = (struct mt792x_sta *)sta->drv_priv;\n\tu16 tid = params->tid;\n\tu16 ssn = params->ssn;\n\tstruct mt76_txq *mtxq;\n\tint ret = 0;\n\n\tif (!txq)\n\t\treturn -EINVAL;\n\n\tmtxq = (struct mt76_txq *)txq->drv_priv;\n\n\tmt792x_mutex_acquire(dev);\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_RX_START:\n\t\tmt76_rx_aggr_start(&dev->mt76, &msta->wcid, tid, ssn,\n\t\t\t\t   params->buf_size);\n\t\tmt7921_mcu_uni_rx_ba(dev, params, true);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\tmt76_rx_aggr_stop(&dev->mt76, &msta->wcid, tid);\n\t\tmt7921_mcu_uni_rx_ba(dev, params, false);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\tmtxq->aggr = true;\n\t\tmtxq->send_bar = false;\n\t\tmt7921_mcu_uni_tx_ba(dev, params, true);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\t\tmtxq->aggr = false;\n\t\tclear_bit(tid, &msta->wcid.ampdu_state);\n\t\tmt7921_mcu_uni_tx_ba(dev, params, false);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_START:\n\t\tset_bit(tid, &msta->wcid.ampdu_state);\n\t\tret = IEEE80211_AMPDU_TX_START_IMMEDIATE;\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\t\tmtxq->aggr = false;\n\t\tclear_bit(tid, &msta->wcid.ampdu_state);\n\t\tmt7921_mcu_uni_tx_ba(dev, params, false);\n\t\tieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\t\tbreak;\n\t}\n\tmt792x_mutex_release(dev);\n\n\treturn ret;\n}\n\nstatic int mt7921_sta_state(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_sta *sta,\n\t\t\t    enum ieee80211_sta_state old_state,\n\t\t\t    enum ieee80211_sta_state new_state)\n{\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\n\tif (dev->pm.ds_enable) {\n\t\tmt792x_mutex_acquire(dev);\n\t\tmt76_connac_sta_state_dp(&dev->mt76, old_state, new_state);\n\t\tmt792x_mutex_release(dev);\n\t}\n\n\treturn mt76_sta_state(hw, vif, sta, old_state, new_state);\n}\n\nvoid mt7921_scan_work(struct work_struct *work)\n{\n\tstruct mt792x_phy *phy;\n\n\tphy = (struct mt792x_phy *)container_of(work, struct mt792x_phy,\n\t\t\t\t\t\tscan_work.work);\n\n\twhile (true) {\n\t\tstruct mt76_connac2_mcu_rxd *rxd;\n\t\tstruct sk_buff *skb;\n\n\t\tspin_lock_bh(&phy->dev->mt76.lock);\n\t\tskb = __skb_dequeue(&phy->scan_event_list);\n\t\tspin_unlock_bh(&phy->dev->mt76.lock);\n\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\trxd = (struct mt76_connac2_mcu_rxd *)skb->data;\n\t\tif (rxd->eid == MCU_EVENT_SCHED_SCAN_DONE) {\n\t\t\tieee80211_sched_scan_results(phy->mt76->hw);\n\t\t} else if (test_and_clear_bit(MT76_HW_SCANNING,\n\t\t\t\t\t      &phy->mt76->state)) {\n\t\t\tstruct cfg80211_scan_info info = {\n\t\t\t\t.aborted = false,\n\t\t\t};\n\n\t\t\tieee80211_scan_completed(phy->mt76->hw, &info);\n\t\t}\n\t\tdev_kfree_skb(skb);\n\t}\n}\n\nstatic int\nmt7921_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t       struct ieee80211_scan_request *req)\n{\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\tstruct mt76_phy *mphy = hw->priv;\n\tint err;\n\n\tmt792x_mutex_acquire(dev);\n\terr = mt76_connac_mcu_hw_scan(mphy, vif, req);\n\tmt792x_mutex_release(dev);\n\n\treturn err;\n}\n\nstatic void\nmt7921_cancel_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\tstruct mt76_phy *mphy = hw->priv;\n\n\tmt792x_mutex_acquire(dev);\n\tmt76_connac_mcu_cancel_hw_scan(mphy, vif);\n\tmt792x_mutex_release(dev);\n}\n\nstatic int\nmt7921_start_sched_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tstruct cfg80211_sched_scan_request *req,\n\t\t\tstruct ieee80211_scan_ies *ies)\n{\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\tstruct mt76_phy *mphy = hw->priv;\n\tint err;\n\n\tmt792x_mutex_acquire(dev);\n\n\terr = mt76_connac_mcu_sched_scan_req(mphy, vif, req);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = mt76_connac_mcu_sched_scan_enable(mphy, vif, true);\nout:\n\tmt792x_mutex_release(dev);\n\n\treturn err;\n}\n\nstatic int\nmt7921_stop_sched_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\tstruct mt76_phy *mphy = hw->priv;\n\tint err;\n\n\tmt792x_mutex_acquire(dev);\n\terr = mt76_connac_mcu_sched_scan_enable(mphy, vif, false);\n\tmt792x_mutex_release(dev);\n\n\treturn err;\n}\n\nstatic int\nmt7921_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)\n{\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\tstruct mt792x_phy *phy = mt792x_hw_phy(hw);\n\tint max_nss = hweight8(hw->wiphy->available_antennas_tx);\n\n\tif (!tx_ant || tx_ant != rx_ant || ffs(tx_ant) > max_nss)\n\t\treturn -EINVAL;\n\n\tif ((BIT(hweight8(tx_ant)) - 1) != tx_ant)\n\t\treturn -EINVAL;\n\n\tmt792x_mutex_acquire(dev);\n\n\tphy->mt76->antenna_mask = tx_ant;\n\tphy->mt76->chainmask = tx_ant;\n\n\tmt76_set_stream_caps(phy->mt76, true);\n\tmt7921_set_stream_he_caps(phy);\n\n\tmt792x_mutex_release(dev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int mt7921_suspend(struct ieee80211_hw *hw,\n\t\t\t  struct cfg80211_wowlan *wowlan)\n{\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\tstruct mt792x_phy *phy = mt792x_hw_phy(hw);\n\n\tcancel_delayed_work_sync(&phy->scan_work);\n\tcancel_delayed_work_sync(&phy->mt76->mac_work);\n\n\tcancel_delayed_work_sync(&dev->pm.ps_work);\n\tmt76_connac_free_pending_tx_skbs(&dev->pm, NULL);\n\n\tmt792x_mutex_acquire(dev);\n\n\tclear_bit(MT76_STATE_RUNNING, &phy->mt76->state);\n\tieee80211_iterate_active_interfaces(hw,\n\t\t\t\t\t    IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\t\t\t    mt7921_mcu_set_suspend_iter,\n\t\t\t\t\t    &dev->mphy);\n\n\tmt792x_mutex_release(dev);\n\n\treturn 0;\n}\n\nstatic int mt7921_resume(struct ieee80211_hw *hw)\n{\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\tstruct mt792x_phy *phy = mt792x_hw_phy(hw);\n\n\tmt792x_mutex_acquire(dev);\n\n\tset_bit(MT76_STATE_RUNNING, &phy->mt76->state);\n\tieee80211_iterate_active_interfaces(hw,\n\t\t\t\t\t    IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\t\t\t    mt76_connac_mcu_set_suspend_iter,\n\t\t\t\t\t    &dev->mphy);\n\n\tieee80211_queue_delayed_work(hw, &phy->mt76->mac_work,\n\t\t\t\t     MT792x_WATCHDOG_TIME);\n\n\tmt792x_mutex_release(dev);\n\n\treturn 0;\n}\n\nstatic void mt7921_set_rekey_data(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct cfg80211_gtk_rekey_data *data)\n{\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\n\tmt792x_mutex_acquire(dev);\n\tmt76_connac_mcu_update_gtk_rekey(hw, vif, data);\n\tmt792x_mutex_release(dev);\n}\n#endif  \n\nstatic void mt7921_sta_set_decap_offload(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t\t bool enabled)\n{\n\tstruct mt792x_sta *msta = (struct mt792x_sta *)sta->drv_priv;\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\n\tmt792x_mutex_acquire(dev);\n\n\tif (enabled)\n\t\tset_bit(MT_WCID_FLAG_HDR_TRANS, &msta->wcid.flags);\n\telse\n\t\tclear_bit(MT_WCID_FLAG_HDR_TRANS, &msta->wcid.flags);\n\n\tmt76_connac_mcu_sta_update_hdr_trans(&dev->mt76, vif, &msta->wcid,\n\t\t\t\t\t     MCU_UNI_CMD(STA_REC_UPDATE));\n\n\tmt792x_mutex_release(dev);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void mt7921_ipv6_addr_change(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct inet6_dev *idev)\n{\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tstruct mt792x_dev *dev = mvif->phy->dev;\n\tstruct inet6_ifaddr *ifa;\n\tstruct in6_addr ns_addrs[IEEE80211_BSS_ARP_ADDR_LIST_LEN];\n\tstruct sk_buff *skb;\n\tu8 i, idx = 0;\n\n\tstruct {\n\t\tstruct {\n\t\t\tu8 bss_idx;\n\t\t\tu8 pad[3];\n\t\t} __packed hdr;\n\t\tstruct mt76_connac_arpns_tlv arpns;\n\t} req_hdr = {\n\t\t.hdr = {\n\t\t\t.bss_idx = mvif->mt76.idx,\n\t\t},\n\t\t.arpns = {\n\t\t\t.tag = cpu_to_le16(UNI_OFFLOAD_OFFLOAD_ND),\n\t\t\t.mode = 2,   \n\t\t\t.option = 1,  \n\t\t},\n\t};\n\n\tread_lock_bh(&idev->lock);\n\tlist_for_each_entry(ifa, &idev->addr_list, if_list) {\n\t\tif (ifa->flags & IFA_F_TENTATIVE)\n\t\t\tcontinue;\n\t\tns_addrs[idx] = ifa->addr;\n\t\tif (++idx >= IEEE80211_BSS_ARP_ADDR_LIST_LEN)\n\t\t\tbreak;\n\t}\n\tread_unlock_bh(&idev->lock);\n\n\tif (!idx)\n\t\treturn;\n\n\treq_hdr.arpns.ips_num = idx;\n\treq_hdr.arpns.len = cpu_to_le16(sizeof(struct mt76_connac_arpns_tlv)\n\t\t\t\t\t+ idx * sizeof(struct in6_addr));\n\tskb = __mt76_mcu_msg_alloc(&dev->mt76, &req_hdr,\n\t\t\tsizeof(req_hdr) + idx * sizeof(struct in6_addr),\n\t\t\tsizeof(req_hdr), GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tfor (i = 0; i < idx; i++)\n\t\tskb_put_data(skb, &ns_addrs[i].in6_u, sizeof(struct in6_addr));\n\n\tskb_queue_tail(&dev->ipv6_ns_list, skb);\n\n\tieee80211_queue_work(dev->mt76.hw, &dev->ipv6_ns_work);\n}\n#endif\n\nint mt7921_set_tx_sar_pwr(struct ieee80211_hw *hw,\n\t\t\t  const struct cfg80211_sar_specs *sar)\n{\n\tstruct mt76_phy *mphy = hw->priv;\n\n\tif (sar) {\n\t\tint err = mt76_init_sar_power(hw, sar);\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tmt792x_init_acpi_sar_power(mt792x_hw_phy(hw), !sar);\n\n\treturn mt76_connac_mcu_set_rate_txpower(mphy);\n}\n\nstatic int mt7921_set_sar_specs(struct ieee80211_hw *hw,\n\t\t\t\tconst struct cfg80211_sar_specs *sar)\n{\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\tint err;\n\n\tmt792x_mutex_acquire(dev);\n\terr = mt7921_mcu_set_clc(dev, dev->mt76.alpha2,\n\t\t\t\t dev->country_ie_env);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = mt7921_set_tx_sar_pwr(hw, sar);\nout:\n\tmt792x_mutex_release(dev);\n\n\treturn err;\n}\n\nstatic void\nmt7921_channel_switch_beacon(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct cfg80211_chan_def *chandef)\n{\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\n\tmt792x_mutex_acquire(dev);\n\tmt7921_mcu_uni_add_beacon_offload(dev, hw, vif, true);\n\tmt792x_mutex_release(dev);\n}\n\nstatic int\nmt7921_start_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\tstruct ieee80211_bss_conf *link_conf)\n{\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tstruct mt792x_phy *phy = mt792x_hw_phy(hw);\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\tint err;\n\n\tmt792x_mutex_acquire(dev);\n\n\terr = mt76_connac_mcu_uni_add_bss(phy->mt76, vif, &mvif->sta.wcid,\n\t\t\t\t\t  true, mvif->mt76.ctx);\n\tif (err)\n\t\tgoto out;\n\n\terr = mt7921_mcu_set_bss_pm(dev, vif, true);\n\tif (err)\n\t\tgoto out;\n\n\terr = mt7921_mcu_sta_update(dev, NULL, vif, true,\n\t\t\t\t    MT76_STA_INFO_STATE_NONE);\nout:\n\tmt792x_mutex_release(dev);\n\n\treturn err;\n}\n\nstatic void\nmt7921_stop_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t       struct ieee80211_bss_conf *link_conf)\n{\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tstruct mt792x_phy *phy = mt792x_hw_phy(hw);\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\tint err;\n\n\tmt792x_mutex_acquire(dev);\n\n\terr = mt7921_mcu_set_bss_pm(dev, vif, false);\n\tif (err)\n\t\tgoto out;\n\n\tmt76_connac_mcu_uni_add_bss(phy->mt76, vif, &mvif->sta.wcid, false,\n\t\t\t\t    mvif->mt76.ctx);\n\nout:\n\tmt792x_mutex_release(dev);\n}\n\nstatic int\nmt7921_add_chanctx(struct ieee80211_hw *hw,\n\t\t   struct ieee80211_chanctx_conf *ctx)\n{\n\treturn 0;\n}\n\nstatic void\nmt7921_remove_chanctx(struct ieee80211_hw *hw,\n\t\t      struct ieee80211_chanctx_conf *ctx)\n{\n}\n\nstatic void mt7921_ctx_iter(void *priv, u8 *mac,\n\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tstruct ieee80211_chanctx_conf *ctx = priv;\n\n\tif (ctx != mvif->mt76.ctx)\n\t\treturn;\n\n\tif (vif->type == NL80211_IFTYPE_MONITOR)\n\t\tmt7921_mcu_config_sniffer(mvif, ctx);\n\telse\n\t\tmt76_connac_mcu_uni_set_chctx(mvif->phy->mt76, &mvif->mt76, ctx);\n}\n\nstatic void\nmt7921_change_chanctx(struct ieee80211_hw *hw,\n\t\t      struct ieee80211_chanctx_conf *ctx,\n\t\t      u32 changed)\n{\n\tstruct mt792x_phy *phy = mt792x_hw_phy(hw);\n\n\tmt792x_mutex_acquire(phy->dev);\n\tieee80211_iterate_active_interfaces(phy->mt76->hw,\n\t\t\t\t\t    IEEE80211_IFACE_ITER_ACTIVE,\n\t\t\t\t\t    mt7921_ctx_iter, ctx);\n\tmt792x_mutex_release(phy->dev);\n}\n\nstatic void mt7921_mgd_prepare_tx(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_prep_tx_info *info)\n{\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\tu16 duration = info->duration ? info->duration :\n\t\t       jiffies_to_msecs(HZ);\n\n\tmt792x_mutex_acquire(dev);\n\tmt7921_set_roc(mvif->phy, mvif, mvif->mt76.ctx->def.chan, duration,\n\t\t       MT7921_ROC_REQ_JOIN);\n\tmt792x_mutex_release(dev);\n}\n\nstatic void mt7921_mgd_complete_tx(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_prep_tx_info *info)\n{\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\n\tmt7921_abort_roc(mvif->phy, mvif);\n}\n\nconst struct ieee80211_ops mt7921_ops = {\n\t.tx = mt792x_tx,\n\t.start = mt7921_start,\n\t.stop = mt7921_stop,\n\t.add_interface = mt7921_add_interface,\n\t.remove_interface = mt792x_remove_interface,\n\t.config = mt7921_config,\n\t.conf_tx = mt792x_conf_tx,\n\t.configure_filter = mt7921_configure_filter,\n\t.bss_info_changed = mt7921_bss_info_changed,\n\t.start_ap = mt7921_start_ap,\n\t.stop_ap = mt7921_stop_ap,\n\t.sta_state = mt7921_sta_state,\n\t.sta_pre_rcu_remove = mt76_sta_pre_rcu_remove,\n\t.set_key = mt7921_set_key,\n\t.sta_set_decap_offload = mt7921_sta_set_decap_offload,\n#if IS_ENABLED(CONFIG_IPV6)\n\t.ipv6_addr_change = mt7921_ipv6_addr_change,\n#endif  \n\t.ampdu_action = mt7921_ampdu_action,\n\t.set_rts_threshold = mt7921_set_rts_threshold,\n\t.wake_tx_queue = mt76_wake_tx_queue,\n\t.release_buffered_frames = mt76_release_buffered_frames,\n\t.channel_switch_beacon = mt7921_channel_switch_beacon,\n\t.get_txpower = mt76_get_txpower,\n\t.get_stats = mt792x_get_stats,\n\t.get_et_sset_count = mt792x_get_et_sset_count,\n\t.get_et_strings = mt792x_get_et_strings,\n\t.get_et_stats = mt792x_get_et_stats,\n\t.get_tsf = mt792x_get_tsf,\n\t.set_tsf = mt792x_set_tsf,\n\t.get_survey = mt76_get_survey,\n\t.get_antenna = mt76_get_antenna,\n\t.set_antenna = mt7921_set_antenna,\n\t.set_coverage_class = mt792x_set_coverage_class,\n\t.hw_scan = mt7921_hw_scan,\n\t.cancel_hw_scan = mt7921_cancel_hw_scan,\n\t.sta_statistics = mt792x_sta_statistics,\n\t.sched_scan_start = mt7921_start_sched_scan,\n\t.sched_scan_stop = mt7921_stop_sched_scan,\n\tCFG80211_TESTMODE_CMD(mt7921_testmode_cmd)\n\tCFG80211_TESTMODE_DUMP(mt7921_testmode_dump)\n#ifdef CONFIG_PM\n\t.suspend = mt7921_suspend,\n\t.resume = mt7921_resume,\n\t.set_wakeup = mt792x_set_wakeup,\n\t.set_rekey_data = mt7921_set_rekey_data,\n#endif  \n\t.flush = mt792x_flush,\n\t.set_sar_specs = mt7921_set_sar_specs,\n\t.remain_on_channel = mt7921_remain_on_channel,\n\t.cancel_remain_on_channel = mt7921_cancel_remain_on_channel,\n\t.add_chanctx = mt7921_add_chanctx,\n\t.remove_chanctx = mt7921_remove_chanctx,\n\t.change_chanctx = mt7921_change_chanctx,\n\t.assign_vif_chanctx = mt792x_assign_vif_chanctx,\n\t.unassign_vif_chanctx = mt792x_unassign_vif_chanctx,\n\t.mgd_prepare_tx = mt7921_mgd_prepare_tx,\n\t.mgd_complete_tx = mt7921_mgd_complete_tx,\n};\nEXPORT_SYMBOL_GPL(mt7921_ops);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Sean Wang <sean.wang@mediatek.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}