{
  "module_name": "mcu.c",
  "hash_id": "b3f81b52a8bde2aca866f0d5a1faa2b1874d989feedae602b573175f4a616d01",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7921/mcu.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/firmware.h>\n#include \"mt7921.h\"\n#include \"mcu.h\"\n#include \"../mt76_connac2_mac.h\"\n#include \"../mt792x_trace.h\"\n\n#define MT_STA_BFER\t\t\tBIT(0)\n#define MT_STA_BFEE\t\t\tBIT(1)\n\nstatic bool mt7921_disable_clc;\nmodule_param_named(disable_clc, mt7921_disable_clc, bool, 0644);\nMODULE_PARM_DESC(disable_clc, \"disable CLC support\");\n\nint mt7921_mcu_parse_response(struct mt76_dev *mdev, int cmd,\n\t\t\t      struct sk_buff *skb, int seq)\n{\n\tint mcu_cmd = FIELD_GET(__MCU_CMD_FIELD_ID, cmd);\n\tstruct mt76_connac2_mcu_rxd *rxd;\n\tint ret = 0;\n\n\tif (!skb) {\n\t\tdev_err(mdev->dev, \"Message %08x (seq %d) timeout\\n\",\n\t\t\tcmd, seq);\n\t\tmt792x_reset(mdev);\n\n\t\treturn -ETIMEDOUT;\n\t}\n\n\trxd = (struct mt76_connac2_mcu_rxd *)skb->data;\n\tif (seq != rxd->seq)\n\t\treturn -EAGAIN;\n\n\tif (cmd == MCU_CMD(PATCH_SEM_CONTROL) ||\n\t    cmd == MCU_CMD(PATCH_FINISH_REQ)) {\n\t\tskb_pull(skb, sizeof(*rxd) - 4);\n\t\tret = *skb->data;\n\t} else if (cmd == MCU_EXT_CMD(THERMAL_CTRL)) {\n\t\tskb_pull(skb, sizeof(*rxd) + 4);\n\t\tret = le32_to_cpu(*(__le32 *)skb->data);\n\t} else if (cmd == MCU_UNI_CMD(DEV_INFO_UPDATE) ||\n\t\t   cmd == MCU_UNI_CMD(BSS_INFO_UPDATE) ||\n\t\t   cmd == MCU_UNI_CMD(STA_REC_UPDATE) ||\n\t\t   cmd == MCU_UNI_CMD(HIF_CTRL) ||\n\t\t   cmd == MCU_UNI_CMD(OFFLOAD) ||\n\t\t   cmd == MCU_UNI_CMD(SUSPEND)) {\n\t\tstruct mt76_connac_mcu_uni_event *event;\n\n\t\tskb_pull(skb, sizeof(*rxd));\n\t\tevent = (struct mt76_connac_mcu_uni_event *)skb->data;\n\t\tret = le32_to_cpu(event->status);\n\t\t \n\t\tif (mcu_cmd != event->cid)\n\t\t\tret = -EAGAIN;\n\t} else if (cmd == MCU_CE_QUERY(REG_READ)) {\n\t\tstruct mt76_connac_mcu_reg_event *event;\n\n\t\tskb_pull(skb, sizeof(*rxd));\n\t\tevent = (struct mt76_connac_mcu_reg_event *)skb->data;\n\t\tret = (int)le32_to_cpu(event->val);\n\t} else {\n\t\tskb_pull(skb, sizeof(struct mt76_connac2_mcu_rxd));\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mt7921_mcu_parse_response);\n\nstatic int mt7921_mcu_read_eeprom(struct mt792x_dev *dev, u32 offset, u8 *val)\n{\n\tstruct mt7921_mcu_eeprom_info *res, req = {\n\t\t.addr = cpu_to_le32(round_down(offset,\n\t\t\t\t    MT7921_EEPROM_BLOCK_SIZE)),\n\t};\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tret = mt76_mcu_send_and_get_msg(&dev->mt76, MCU_EXT_QUERY(EFUSE_ACCESS),\n\t\t\t\t\t&req, sizeof(req), true, &skb);\n\tif (ret)\n\t\treturn ret;\n\n\tres = (struct mt7921_mcu_eeprom_info *)skb->data;\n\t*val = res->data[offset % MT7921_EEPROM_BLOCK_SIZE];\n\tdev_kfree_skb(skb);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\n\nstatic int\nmt7921_mcu_set_ipv6_ns_filter(struct mt76_dev *dev,\n\t\t\t      struct ieee80211_vif *vif, bool suspend)\n{\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tstruct {\n\t\tstruct {\n\t\t\tu8 bss_idx;\n\t\t\tu8 pad[3];\n\t\t} __packed hdr;\n\t\tstruct mt76_connac_arpns_tlv arpns;\n\t} req = {\n\t\t.hdr = {\n\t\t\t.bss_idx = mvif->mt76.idx,\n\t\t},\n\t\t.arpns = {\n\t\t\t.tag = cpu_to_le16(UNI_OFFLOAD_OFFLOAD_ND),\n\t\t\t.len = cpu_to_le16(sizeof(struct mt76_connac_arpns_tlv)),\n\t\t\t.mode = suspend,\n\t\t},\n\t};\n\n\treturn mt76_mcu_send_msg(dev, MCU_UNI_CMD_OFFLOAD, &req, sizeof(req),\n\t\t\t\t true);\n}\n\nvoid mt7921_mcu_set_suspend_iter(void *priv, u8 *mac, struct ieee80211_vif *vif)\n{\n\tif (IS_ENABLED(CONFIG_IPV6)) {\n\t\tstruct mt76_phy *phy = priv;\n\n\t\tmt7921_mcu_set_ipv6_ns_filter(phy->dev, vif,\n\t\t\t\t\t      !test_bit(MT76_STATE_RUNNING,\n\t\t\t\t\t      &phy->state));\n\t}\n\n\tmt76_connac_mcu_set_suspend_iter(priv, mac, vif);\n}\n\n#endif  \n\nstatic void\nmt7921_mcu_uni_roc_event(struct mt792x_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt7921_roc_grant_tlv *grant;\n\tstruct mt76_connac2_mcu_rxd *rxd;\n\tint duration;\n\n\trxd = (struct mt76_connac2_mcu_rxd *)skb->data;\n\tgrant = (struct mt7921_roc_grant_tlv *)(rxd->tlv + 4);\n\n\t \n\tWARN_ON_ONCE((le16_to_cpu(grant->tag) != UNI_EVENT_ROC_GRANT));\n\n\tif (grant->reqtype == MT7921_ROC_REQ_ROC)\n\t\tieee80211_ready_on_channel(dev->mt76.phy.hw);\n\n\tdev->phy.roc_grant = true;\n\twake_up(&dev->phy.roc_wait);\n\tduration = le32_to_cpu(grant->max_interval);\n\tmod_timer(&dev->phy.roc_timer,\n\t\t  jiffies + msecs_to_jiffies(duration));\n}\n\nstatic void\nmt7921_mcu_scan_event(struct mt792x_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt76_phy *mphy = &dev->mt76.phy;\n\tstruct mt792x_phy *phy = (struct mt792x_phy *)mphy->priv;\n\n\tspin_lock_bh(&dev->mt76.lock);\n\t__skb_queue_tail(&phy->scan_event_list, skb);\n\tspin_unlock_bh(&dev->mt76.lock);\n\n\tieee80211_queue_delayed_work(mphy->hw, &phy->scan_work,\n\t\t\t\t     MT792x_HW_SCAN_TIMEOUT);\n}\n\nstatic void\nmt7921_mcu_connection_loss_iter(void *priv, u8 *mac,\n\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct mt76_connac_beacon_loss_event *event = priv;\n\n\tif (mvif->idx != event->bss_idx)\n\t\treturn;\n\n\tif (!(vif->driver_flags & IEEE80211_VIF_BEACON_FILTER) ||\n\t    vif->type != NL80211_IFTYPE_STATION)\n\t\treturn;\n\n\tieee80211_connection_loss(vif);\n}\n\nstatic void\nmt7921_mcu_connection_loss_event(struct mt792x_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt76_connac_beacon_loss_event *event;\n\tstruct mt76_phy *mphy = &dev->mt76.phy;\n\n\tskb_pull(skb, sizeof(struct mt76_connac2_mcu_rxd));\n\tevent = (struct mt76_connac_beacon_loss_event *)skb->data;\n\n\tieee80211_iterate_active_interfaces_atomic(mphy->hw,\n\t\t\t\t\tIEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\t\t\tmt7921_mcu_connection_loss_iter, event);\n}\n\nstatic void\nmt7921_mcu_debug_msg_event(struct mt792x_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt7921_debug_msg {\n\t\t__le16 id;\n\t\tu8 type;\n\t\tu8 flag;\n\t\t__le32 value;\n\t\t__le16 len;\n\t\tu8 content[512];\n\t} __packed * msg;\n\n\tskb_pull(skb, sizeof(struct mt76_connac2_mcu_rxd));\n\tmsg = (struct mt7921_debug_msg *)skb->data;\n\n\tif (msg->type == 3) {  \n\t\tu16 len = min_t(u16, le16_to_cpu(msg->len), 512);\n\t\tint i;\n\n\t\tfor (i = 0 ; i < len; i++) {\n\t\t\tif (!msg->content[i])\n\t\t\t\tmsg->content[i] = ' ';\n\t\t}\n\t\twiphy_info(mt76_hw(dev)->wiphy, \"%.*s\", len, msg->content);\n\t}\n}\n\nstatic void\nmt7921_mcu_low_power_event(struct mt792x_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt7921_mcu_lp_event {\n\t\tu8 state;\n\t\tu8 reserved[3];\n\t} __packed * event;\n\n\tskb_pull(skb, sizeof(struct mt76_connac2_mcu_rxd));\n\tevent = (struct mt7921_mcu_lp_event *)skb->data;\n\n\ttrace_lp_event(dev, event->state);\n}\n\nstatic void\nmt7921_mcu_tx_done_event(struct mt792x_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt7921_mcu_tx_done_event *event;\n\n\tskb_pull(skb, sizeof(struct mt76_connac2_mcu_rxd));\n\tevent = (struct mt7921_mcu_tx_done_event *)skb->data;\n\n\tmt7921_mac_add_txs(dev, event->txs);\n}\n\nstatic void\nmt7921_mcu_rx_unsolicited_event(struct mt792x_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt76_connac2_mcu_rxd *rxd;\n\n\trxd = (struct mt76_connac2_mcu_rxd *)skb->data;\n\tswitch (rxd->eid) {\n\tcase MCU_EVENT_BSS_BEACON_LOSS:\n\t\tmt7921_mcu_connection_loss_event(dev, skb);\n\t\tbreak;\n\tcase MCU_EVENT_SCHED_SCAN_DONE:\n\tcase MCU_EVENT_SCAN_DONE:\n\t\tmt7921_mcu_scan_event(dev, skb);\n\t\treturn;\n\tcase MCU_EVENT_DBG_MSG:\n\t\tmt7921_mcu_debug_msg_event(dev, skb);\n\t\tbreak;\n\tcase MCU_EVENT_COREDUMP:\n\t\tdev->fw_assert = true;\n\t\tmt76_connac_mcu_coredump_event(&dev->mt76, skb,\n\t\t\t\t\t       &dev->coredump);\n\t\treturn;\n\tcase MCU_EVENT_LP_INFO:\n\t\tmt7921_mcu_low_power_event(dev, skb);\n\t\tbreak;\n\tcase MCU_EVENT_TX_DONE:\n\t\tmt7921_mcu_tx_done_event(dev, skb);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tdev_kfree_skb(skb);\n}\n\nstatic void\nmt7921_mcu_uni_rx_unsolicited_event(struct mt792x_dev *dev,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct mt76_connac2_mcu_rxd *rxd;\n\n\trxd = (struct mt76_connac2_mcu_rxd *)skb->data;\n\n\tswitch (rxd->eid) {\n\tcase MCU_UNI_EVENT_ROC:\n\t\tmt7921_mcu_uni_roc_event(dev, skb);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tdev_kfree_skb(skb);\n}\n\nvoid mt7921_mcu_rx_event(struct mt792x_dev *dev, struct sk_buff *skb)\n{\n\tstruct mt76_connac2_mcu_rxd *rxd;\n\n\tif (skb_linearize(skb))\n\t\treturn;\n\n\trxd = (struct mt76_connac2_mcu_rxd *)skb->data;\n\n\tif (rxd->option & MCU_UNI_CMD_UNSOLICITED_EVENT) {\n\t\tmt7921_mcu_uni_rx_unsolicited_event(dev, skb);\n\t\treturn;\n\t}\n\n\tif (rxd->eid == 0x6) {\n\t\tmt76_mcu_rx_event(&dev->mt76, skb);\n\t\treturn;\n\t}\n\n\tif (rxd->ext_eid == MCU_EXT_EVENT_RATE_REPORT ||\n\t    rxd->eid == MCU_EVENT_BSS_BEACON_LOSS ||\n\t    rxd->eid == MCU_EVENT_SCHED_SCAN_DONE ||\n\t    rxd->eid == MCU_EVENT_SCAN_DONE ||\n\t    rxd->eid == MCU_EVENT_TX_DONE ||\n\t    rxd->eid == MCU_EVENT_DBG_MSG ||\n\t    rxd->eid == MCU_EVENT_COREDUMP ||\n\t    rxd->eid == MCU_EVENT_LP_INFO ||\n\t    !rxd->seq)\n\t\tmt7921_mcu_rx_unsolicited_event(dev, skb);\n\telse\n\t\tmt76_mcu_rx_event(&dev->mt76, skb);\n}\n\n \nint mt7921_mcu_uni_tx_ba(struct mt792x_dev *dev,\n\t\t\t struct ieee80211_ampdu_params *params,\n\t\t\t bool enable)\n{\n\tstruct mt792x_sta *msta = (struct mt792x_sta *)params->sta->drv_priv;\n\n\tif (enable && !params->amsdu)\n\t\tmsta->wcid.amsdu = false;\n\n\treturn mt76_connac_mcu_sta_ba(&dev->mt76, &msta->vif->mt76, params,\n\t\t\t\t      MCU_UNI_CMD(STA_REC_UPDATE),\n\t\t\t\t      enable, true);\n}\n\nint mt7921_mcu_uni_rx_ba(struct mt792x_dev *dev,\n\t\t\t struct ieee80211_ampdu_params *params,\n\t\t\t bool enable)\n{\n\tstruct mt792x_sta *msta = (struct mt792x_sta *)params->sta->drv_priv;\n\n\treturn mt76_connac_mcu_sta_ba(&dev->mt76, &msta->vif->mt76, params,\n\t\t\t\t      MCU_UNI_CMD(STA_REC_UPDATE),\n\t\t\t\t      enable, false);\n}\n\nstatic int mt7921_load_clc(struct mt792x_dev *dev, const char *fw_name)\n{\n\tconst struct mt76_connac2_fw_trailer *hdr;\n\tconst struct mt76_connac2_fw_region *region;\n\tconst struct mt7921_clc *clc;\n\tstruct mt76_dev *mdev = &dev->mt76;\n\tstruct mt792x_phy *phy = &dev->phy;\n\tconst struct firmware *fw;\n\tint ret, i, len, offset = 0;\n\tu8 *clc_base = NULL, hw_encap = 0;\n\n\tif (mt7921_disable_clc ||\n\t    mt76_is_usb(&dev->mt76))\n\t\treturn 0;\n\n\tif (mt76_is_mmio(&dev->mt76)) {\n\t\tret = mt7921_mcu_read_eeprom(dev, MT_EE_HW_TYPE, &hw_encap);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\thw_encap = u8_get_bits(hw_encap, MT_EE_HW_TYPE_ENCAP);\n\t}\n\n\tret = request_firmware(&fw, fw_name, mdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!fw || !fw->data || fw->size < sizeof(*hdr)) {\n\t\tdev_err(mdev->dev, \"Invalid firmware\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\thdr = (const void *)(fw->data + fw->size - sizeof(*hdr));\n\tfor (i = 0; i < hdr->n_region; i++) {\n\t\tregion = (const void *)((const u8 *)hdr -\n\t\t\t\t\t(hdr->n_region - i) * sizeof(*region));\n\t\tlen = le32_to_cpu(region->len);\n\n\t\t \n\t\tif (offset + len > fw->size) {\n\t\t\tdev_err(mdev->dev, \"Invalid firmware region\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif ((region->feature_set & FW_FEATURE_NON_DL) &&\n\t\t    region->type == FW_TYPE_CLC) {\n\t\t\tclc_base = (u8 *)(fw->data + offset);\n\t\t\tbreak;\n\t\t}\n\t\toffset += len;\n\t}\n\n\tif (!clc_base)\n\t\tgoto out;\n\n\tfor (offset = 0; offset < len; offset += le32_to_cpu(clc->len)) {\n\t\tclc = (const struct mt7921_clc *)(clc_base + offset);\n\n\t\t \n\t\tif (phy->clc[clc->idx])\n\t\t\tcontinue;\n\n\t\t \n\t\tif (clc->idx == MT7921_CLC_POWER &&\n\t\t    u8_get_bits(clc->type, MT_EE_HW_TYPE_ENCAP) != hw_encap)\n\t\t\tcontinue;\n\n\t\tphy->clc[clc->idx] = devm_kmemdup(mdev->dev, clc,\n\t\t\t\t\t\t  le32_to_cpu(clc->len),\n\t\t\t\t\t\t  GFP_KERNEL);\n\n\t\tif (!phy->clc[clc->idx]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = mt7921_mcu_set_clc(dev, \"00\", ENVIRON_INDOOR);\nout:\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\nint mt7921_mcu_fw_log_2_host(struct mt792x_dev *dev, u8 ctrl)\n{\n\tstruct {\n\t\tu8 ctrl_val;\n\t\tu8 pad[3];\n\t} data = {\n\t\t.ctrl_val = ctrl\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_CE_CMD(FWLOG_2_HOST),\n\t\t\t\t &data, sizeof(data), false);\n}\n\nint mt7921_run_firmware(struct mt792x_dev *dev)\n{\n\tint err;\n\n\terr = mt792x_load_firmware(dev);\n\tif (err)\n\t\treturn err;\n\n\terr = mt76_connac_mcu_get_nic_capability(&dev->mphy);\n\tif (err)\n\t\treturn err;\n\n\tset_bit(MT76_STATE_MCU_RUNNING, &dev->mphy.state);\n\terr = mt7921_load_clc(dev, mt792x_ram_name(dev));\n\tif (err)\n\t\treturn err;\n\n\treturn mt7921_mcu_fw_log_2_host(dev, 1);\n}\nEXPORT_SYMBOL_GPL(mt7921_run_firmware);\n\nint mt7921_mcu_set_tx(struct mt792x_dev *dev, struct ieee80211_vif *vif)\n{\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tstruct edca {\n\t\t__le16 cw_min;\n\t\t__le16 cw_max;\n\t\t__le16 txop;\n\t\t__le16 aifs;\n\t\tu8 guardtime;\n\t\tu8 acm;\n\t} __packed;\n\tstruct mt7921_mcu_tx {\n\t\tstruct edca edca[IEEE80211_NUM_ACS];\n\t\tu8 bss_idx;\n\t\tu8 qos;\n\t\tu8 wmm_idx;\n\t\tu8 pad;\n\t} __packed req = {\n\t\t.bss_idx = mvif->mt76.idx,\n\t\t.qos = vif->bss_conf.qos,\n\t\t.wmm_idx = mvif->mt76.wmm_idx,\n\t};\n\tstruct mu_edca {\n\t\tu8 cw_min;\n\t\tu8 cw_max;\n\t\tu8 aifsn;\n\t\tu8 acm;\n\t\tu8 timer;\n\t\tu8 padding[3];\n\t};\n\tstruct mt7921_mcu_mu_tx {\n\t\tu8 ver;\n\t\tu8 pad0;\n\t\t__le16 len;\n\t\tu8 bss_idx;\n\t\tu8 qos;\n\t\tu8 wmm_idx;\n\t\tu8 pad1;\n\t\tstruct mu_edca edca[IEEE80211_NUM_ACS];\n\t\tu8 pad3[32];\n\t} __packed req_mu = {\n\t\t.bss_idx = mvif->mt76.idx,\n\t\t.qos = vif->bss_conf.qos,\n\t\t.wmm_idx = mvif->mt76.wmm_idx,\n\t};\n\tstatic const int to_aci[] = { 1, 0, 2, 3 };\n\tint ac, ret;\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tstruct ieee80211_tx_queue_params *q = &mvif->queue_params[ac];\n\t\tstruct edca *e = &req.edca[to_aci[ac]];\n\n\t\te->aifs = cpu_to_le16(q->aifs);\n\t\te->txop = cpu_to_le16(q->txop);\n\n\t\tif (q->cw_min)\n\t\t\te->cw_min = cpu_to_le16(q->cw_min);\n\t\telse\n\t\t\te->cw_min = cpu_to_le16(5);\n\n\t\tif (q->cw_max)\n\t\t\te->cw_max = cpu_to_le16(q->cw_max);\n\t\telse\n\t\t\te->cw_max = cpu_to_le16(10);\n\t}\n\n\tret = mt76_mcu_send_msg(&dev->mt76, MCU_CE_CMD(SET_EDCA_PARMS), &req,\n\t\t\t\tsizeof(req), false);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!vif->bss_conf.he_support)\n\t\treturn 0;\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tstruct ieee80211_he_mu_edca_param_ac_rec *q;\n\t\tstruct mu_edca *e;\n\n\t\tif (!mvif->queue_params[ac].mu_edca)\n\t\t\tbreak;\n\n\t\tq = &mvif->queue_params[ac].mu_edca_param_rec;\n\t\te = &(req_mu.edca[to_aci[ac]]);\n\n\t\te->cw_min = q->ecw_min_max & 0xf;\n\t\te->cw_max = (q->ecw_min_max & 0xf0) >> 4;\n\t\te->aifsn = q->aifsn;\n\t\te->timer = q->mu_edca_timer;\n\t}\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_CE_CMD(SET_MU_EDCA_PARMS),\n\t\t\t\t &req_mu, sizeof(req_mu), false);\n}\n\nint mt7921_mcu_set_roc(struct mt792x_phy *phy, struct mt792x_vif *vif,\n\t\t       struct ieee80211_channel *chan, int duration,\n\t\t       enum mt7921_roc_req type, u8 token_id)\n{\n\tint center_ch = ieee80211_frequency_to_channel(chan->center_freq);\n\tstruct mt792x_dev *dev = phy->dev;\n\tstruct {\n\t\tstruct {\n\t\t\tu8 rsv[4];\n\t\t} __packed hdr;\n\t\tstruct roc_acquire_tlv {\n\t\t\t__le16 tag;\n\t\t\t__le16 len;\n\t\t\tu8 bss_idx;\n\t\t\tu8 tokenid;\n\t\t\tu8 control_channel;\n\t\t\tu8 sco;\n\t\t\tu8 band;\n\t\t\tu8 bw;\n\t\t\tu8 center_chan;\n\t\t\tu8 center_chan2;\n\t\t\tu8 bw_from_ap;\n\t\t\tu8 center_chan_from_ap;\n\t\t\tu8 center_chan2_from_ap;\n\t\t\tu8 reqtype;\n\t\t\t__le32 maxinterval;\n\t\t\tu8 dbdcband;\n\t\t\tu8 rsv[3];\n\t\t} __packed roc;\n\t} __packed req = {\n\t\t.roc = {\n\t\t\t.tag = cpu_to_le16(UNI_ROC_ACQUIRE),\n\t\t\t.len = cpu_to_le16(sizeof(struct roc_acquire_tlv)),\n\t\t\t.tokenid = token_id,\n\t\t\t.reqtype = type,\n\t\t\t.maxinterval = cpu_to_le32(duration),\n\t\t\t.bss_idx = vif->mt76.idx,\n\t\t\t.control_channel = chan->hw_value,\n\t\t\t.bw = CMD_CBW_20MHZ,\n\t\t\t.bw_from_ap = CMD_CBW_20MHZ,\n\t\t\t.center_chan = center_ch,\n\t\t\t.center_chan_from_ap = center_ch,\n\t\t\t.dbdcband = 0xff,  \n\t\t},\n\t};\n\n\tif (chan->hw_value < center_ch)\n\t\treq.roc.sco = 1;  \n\telse if (chan->hw_value > center_ch)\n\t\treq.roc.sco = 3;  \n\n\tswitch (chan->band) {\n\tcase NL80211_BAND_6GHZ:\n\t\treq.roc.band = 3;\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\treq.roc.band = 2;\n\t\tbreak;\n\tdefault:\n\t\treq.roc.band = 1;\n\t\tbreak;\n\t}\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD(ROC),\n\t\t\t\t &req, sizeof(req), false);\n}\n\nint mt7921_mcu_abort_roc(struct mt792x_phy *phy, struct mt792x_vif *vif,\n\t\t\t u8 token_id)\n{\n\tstruct mt792x_dev *dev = phy->dev;\n\tstruct {\n\t\tstruct {\n\t\t\tu8 rsv[4];\n\t\t} __packed hdr;\n\t\tstruct roc_abort_tlv {\n\t\t\t__le16 tag;\n\t\t\t__le16 len;\n\t\t\tu8 bss_idx;\n\t\t\tu8 tokenid;\n\t\t\tu8 dbdcband;\n\t\t\tu8 rsv[5];\n\t\t} __packed abort;\n\t} __packed req = {\n\t\t.abort = {\n\t\t\t.tag = cpu_to_le16(UNI_ROC_ABORT),\n\t\t\t.len = cpu_to_le16(sizeof(struct roc_abort_tlv)),\n\t\t\t.tokenid = token_id,\n\t\t\t.bss_idx = vif->mt76.idx,\n\t\t\t.dbdcband = 0xff,  \n\t\t},\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD(ROC),\n\t\t\t\t &req, sizeof(req), false);\n}\n\nint mt7921_mcu_set_chan_info(struct mt792x_phy *phy, int cmd)\n{\n\tstruct mt792x_dev *dev = phy->dev;\n\tstruct cfg80211_chan_def *chandef = &phy->mt76->chandef;\n\tint freq1 = chandef->center_freq1;\n\tstruct {\n\t\tu8 control_ch;\n\t\tu8 center_ch;\n\t\tu8 bw;\n\t\tu8 tx_streams_num;\n\t\tu8 rx_streams;\t \n\t\tu8 switch_reason;\n\t\tu8 band_idx;\n\t\tu8 center_ch2;\t \n\t\t__le16 cac_case;\n\t\tu8 channel_band;\n\t\tu8 rsv0;\n\t\t__le32 outband_freq;\n\t\tu8 txpower_drop;\n\t\tu8 ap_bw;\n\t\tu8 ap_center_ch;\n\t\tu8 rsv1[57];\n\t} __packed req = {\n\t\t.control_ch = chandef->chan->hw_value,\n\t\t.center_ch = ieee80211_frequency_to_channel(freq1),\n\t\t.bw = mt76_connac_chan_bw(chandef),\n\t\t.tx_streams_num = hweight8(phy->mt76->antenna_mask),\n\t\t.rx_streams = phy->mt76->antenna_mask,\n\t\t.band_idx = phy != &dev->phy,\n\t};\n\n\tif (chandef->chan->band == NL80211_BAND_6GHZ)\n\t\treq.channel_band = 2;\n\telse\n\t\treq.channel_band = chandef->chan->band;\n\n\tif (cmd == MCU_EXT_CMD(SET_RX_PATH) ||\n\t    dev->mt76.hw->conf.flags & IEEE80211_CONF_MONITOR)\n\t\treq.switch_reason = CH_SWITCH_NORMAL;\n\telse if (dev->mt76.hw->conf.flags & IEEE80211_CONF_OFFCHANNEL)\n\t\treq.switch_reason = CH_SWITCH_SCAN_BYPASS_DPD;\n\telse if (!cfg80211_reg_can_beacon(dev->mt76.hw->wiphy, chandef,\n\t\t\t\t\t  NL80211_IFTYPE_AP))\n\t\treq.switch_reason = CH_SWITCH_DFS;\n\telse\n\t\treq.switch_reason = CH_SWITCH_NORMAL;\n\n\tif (cmd == MCU_EXT_CMD(CHANNEL_SWITCH))\n\t\treq.rx_streams = hweight8(req.rx_streams);\n\n\tif (chandef->width == NL80211_CHAN_WIDTH_80P80) {\n\t\tint freq2 = chandef->center_freq2;\n\n\t\treq.center_ch2 = ieee80211_frequency_to_channel(freq2);\n\t}\n\n\treturn mt76_mcu_send_msg(&dev->mt76, cmd, &req, sizeof(req), true);\n}\n\nint mt7921_mcu_set_eeprom(struct mt792x_dev *dev)\n{\n\tstruct req_hdr {\n\t\tu8 buffer_mode;\n\t\tu8 format;\n\t\t__le16 len;\n\t} __packed req = {\n\t\t.buffer_mode = EE_MODE_EFUSE,\n\t\t.format = EE_FORMAT_WHOLE,\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(EFUSE_BUFFER_MODE),\n\t\t\t\t &req, sizeof(req), true);\n}\nEXPORT_SYMBOL_GPL(mt7921_mcu_set_eeprom);\n\nint mt7921_mcu_uni_bss_ps(struct mt792x_dev *dev, struct ieee80211_vif *vif)\n{\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tstruct {\n\t\tstruct {\n\t\t\tu8 bss_idx;\n\t\t\tu8 pad[3];\n\t\t} __packed hdr;\n\t\tstruct ps_tlv {\n\t\t\t__le16 tag;\n\t\t\t__le16 len;\n\t\t\tu8 ps_state;  \n\t\t\tu8 pad[3];\n\t\t} __packed ps;\n\t} __packed ps_req = {\n\t\t.hdr = {\n\t\t\t.bss_idx = mvif->mt76.idx,\n\t\t},\n\t\t.ps = {\n\t\t\t.tag = cpu_to_le16(UNI_BSS_INFO_PS),\n\t\t\t.len = cpu_to_le16(sizeof(struct ps_tlv)),\n\t\t\t.ps_state = vif->cfg.ps ? 2 : 0,\n\t\t},\n\t};\n\n\tif (vif->type != NL80211_IFTYPE_STATION)\n\t\treturn -EOPNOTSUPP;\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD(BSS_INFO_UPDATE),\n\t\t\t\t &ps_req, sizeof(ps_req), true);\n}\n\nstatic int\nmt7921_mcu_uni_bss_bcnft(struct mt792x_dev *dev, struct ieee80211_vif *vif,\n\t\t\t bool enable)\n{\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tstruct {\n\t\tstruct {\n\t\t\tu8 bss_idx;\n\t\t\tu8 pad[3];\n\t\t} __packed hdr;\n\t\tstruct bcnft_tlv {\n\t\t\t__le16 tag;\n\t\t\t__le16 len;\n\t\t\t__le16 bcn_interval;\n\t\t\tu8 dtim_period;\n\t\t\tu8 pad;\n\t\t} __packed bcnft;\n\t} __packed bcnft_req = {\n\t\t.hdr = {\n\t\t\t.bss_idx = mvif->mt76.idx,\n\t\t},\n\t\t.bcnft = {\n\t\t\t.tag = cpu_to_le16(UNI_BSS_INFO_BCNFT),\n\t\t\t.len = cpu_to_le16(sizeof(struct bcnft_tlv)),\n\t\t\t.bcn_interval = cpu_to_le16(vif->bss_conf.beacon_int),\n\t\t\t.dtim_period = vif->bss_conf.dtim_period,\n\t\t},\n\t};\n\n\tif (vif->type != NL80211_IFTYPE_STATION)\n\t\treturn 0;\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD(BSS_INFO_UPDATE),\n\t\t\t\t &bcnft_req, sizeof(bcnft_req), true);\n}\n\nint\nmt7921_mcu_set_bss_pm(struct mt792x_dev *dev, struct ieee80211_vif *vif,\n\t\t      bool enable)\n{\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tstruct {\n\t\tu8 bss_idx;\n\t\tu8 dtim_period;\n\t\t__le16 aid;\n\t\t__le16 bcn_interval;\n\t\t__le16 atim_window;\n\t\tu8 uapsd;\n\t\tu8 bmc_delivered_ac;\n\t\tu8 bmc_triggered_ac;\n\t\tu8 pad;\n\t} req = {\n\t\t.bss_idx = mvif->mt76.idx,\n\t\t.aid = cpu_to_le16(vif->cfg.aid),\n\t\t.dtim_period = vif->bss_conf.dtim_period,\n\t\t.bcn_interval = cpu_to_le16(vif->bss_conf.beacon_int),\n\t};\n\tstruct {\n\t\tu8 bss_idx;\n\t\tu8 pad[3];\n\t} req_hdr = {\n\t\t.bss_idx = mvif->mt76.idx,\n\t};\n\tint err;\n\n\terr = mt76_mcu_send_msg(&dev->mt76, MCU_CE_CMD(SET_BSS_ABORT),\n\t\t\t\t&req_hdr, sizeof(req_hdr), false);\n\tif (err < 0 || !enable)\n\t\treturn err;\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_CE_CMD(SET_BSS_CONNECTED),\n\t\t\t\t &req, sizeof(req), false);\n}\n\nint mt7921_mcu_sta_update(struct mt792x_dev *dev, struct ieee80211_sta *sta,\n\t\t\t  struct ieee80211_vif *vif, bool enable,\n\t\t\t  enum mt76_sta_info_state state)\n{\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tint rssi = -ewma_rssi_read(&mvif->rssi);\n\tstruct mt76_sta_cmd_info info = {\n\t\t.sta = sta,\n\t\t.vif = vif,\n\t\t.enable = enable,\n\t\t.cmd = MCU_UNI_CMD(STA_REC_UPDATE),\n\t\t.state = state,\n\t\t.offload_fw = true,\n\t\t.rcpi = to_rcpi(rssi),\n\t};\n\tstruct mt792x_sta *msta;\n\n\tmsta = sta ? (struct mt792x_sta *)sta->drv_priv : NULL;\n\tinfo.wcid = msta ? &msta->wcid : &mvif->sta.wcid;\n\tinfo.newly = msta ? state != MT76_STA_INFO_STATE_ASSOC : true;\n\n\treturn mt76_connac_mcu_sta_cmd(&dev->mphy, &info);\n}\n\nint mt7921_mcu_set_beacon_filter(struct mt792x_dev *dev,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t bool enable)\n{\n#define MT7921_FIF_BIT_CLR\t\tBIT(1)\n#define MT7921_FIF_BIT_SET\t\tBIT(0)\n\tint err;\n\n\tif (enable) {\n\t\terr = mt7921_mcu_uni_bss_bcnft(dev, vif, true);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mt7921_mcu_set_rxfilter(dev, 0,\n\t\t\t\t\t      MT7921_FIF_BIT_SET,\n\t\t\t\t\t      MT_WF_RFCR_DROP_OTHER_BEACON);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn 0;\n\t}\n\n\terr = mt7921_mcu_set_bss_pm(dev, vif, false);\n\tif (err)\n\t\treturn err;\n\n\terr = mt7921_mcu_set_rxfilter(dev, 0,\n\t\t\t\t      MT7921_FIF_BIT_CLR,\n\t\t\t\t      MT_WF_RFCR_DROP_OTHER_BEACON);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nint mt7921_get_txpwr_info(struct mt792x_dev *dev, struct mt7921_txpwr *txpwr)\n{\n\tstruct mt7921_txpwr_event *event;\n\tstruct mt7921_txpwr_req req = {\n\t\t.dbdc_idx = 0,\n\t};\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tret = mt76_mcu_send_and_get_msg(&dev->mt76, MCU_CE_CMD(GET_TXPWR),\n\t\t\t\t\t&req, sizeof(req), true, &skb);\n\tif (ret)\n\t\treturn ret;\n\n\tevent = (struct mt7921_txpwr_event *)skb->data;\n\tWARN_ON(skb->len != le16_to_cpu(event->len));\n\tmemcpy(txpwr, &event->txpwr, sizeof(event->txpwr));\n\n\tdev_kfree_skb(skb);\n\n\treturn 0;\n}\n\nint mt7921_mcu_set_sniffer(struct mt792x_dev *dev, struct ieee80211_vif *vif,\n\t\t\t   bool enable)\n{\n\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\tstruct {\n\t\tstruct {\n\t\t\tu8 band_idx;\n\t\t\tu8 pad[3];\n\t\t} __packed hdr;\n\t\tstruct sniffer_enable_tlv {\n\t\t\t__le16 tag;\n\t\t\t__le16 len;\n\t\t\tu8 enable;\n\t\t\tu8 pad[3];\n\t\t} __packed enable;\n\t} req = {\n\t\t.hdr = {\n\t\t\t.band_idx = mvif->band_idx,\n\t\t},\n\t\t.enable = {\n\t\t\t.tag = cpu_to_le16(0),\n\t\t\t.len = cpu_to_le16(sizeof(struct sniffer_enable_tlv)),\n\t\t\t.enable = enable,\n\t\t},\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD(SNIFFER), &req, sizeof(req),\n\t\t\t\t true);\n}\n\nint mt7921_mcu_config_sniffer(struct mt792x_vif *vif,\n\t\t\t      struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct cfg80211_chan_def *chandef = &ctx->def;\n\tint freq1 = chandef->center_freq1, freq2 = chandef->center_freq2;\n\tconst u8 ch_band[] = {\n\t\t[NL80211_BAND_2GHZ] = 1,\n\t\t[NL80211_BAND_5GHZ] = 2,\n\t\t[NL80211_BAND_6GHZ] = 3,\n\t};\n\tconst u8 ch_width[] = {\n\t\t[NL80211_CHAN_WIDTH_20_NOHT] = 0,\n\t\t[NL80211_CHAN_WIDTH_20] = 0,\n\t\t[NL80211_CHAN_WIDTH_40] = 0,\n\t\t[NL80211_CHAN_WIDTH_80] = 1,\n\t\t[NL80211_CHAN_WIDTH_160] = 2,\n\t\t[NL80211_CHAN_WIDTH_80P80] = 3,\n\t\t[NL80211_CHAN_WIDTH_5] = 4,\n\t\t[NL80211_CHAN_WIDTH_10] = 5,\n\t\t[NL80211_CHAN_WIDTH_320] = 6,\n\t};\n\tstruct {\n\t\tstruct {\n\t\t\tu8 band_idx;\n\t\t\tu8 pad[3];\n\t\t} __packed hdr;\n\t\tstruct config_tlv {\n\t\t\t__le16 tag;\n\t\t\t__le16 len;\n\t\t\tu16 aid;\n\t\t\tu8 ch_band;\n\t\t\tu8 bw;\n\t\t\tu8 control_ch;\n\t\t\tu8 sco;\n\t\t\tu8 center_ch;\n\t\t\tu8 center_ch2;\n\t\t\tu8 drop_err;\n\t\t\tu8 pad[3];\n\t\t} __packed tlv;\n\t} __packed req = {\n\t\t.hdr = {\n\t\t\t.band_idx = vif->mt76.band_idx,\n\t\t},\n\t\t.tlv = {\n\t\t\t.tag = cpu_to_le16(1),\n\t\t\t.len = cpu_to_le16(sizeof(req.tlv)),\n\t\t\t.control_ch = chandef->chan->hw_value,\n\t\t\t.center_ch = ieee80211_frequency_to_channel(freq1),\n\t\t\t.drop_err = 1,\n\t\t},\n\t};\n\tif (chandef->chan->band < ARRAY_SIZE(ch_band))\n\t\treq.tlv.ch_band = ch_band[chandef->chan->band];\n\tif (chandef->width < ARRAY_SIZE(ch_width))\n\t\treq.tlv.bw = ch_width[chandef->width];\n\n\tif (freq2)\n\t\treq.tlv.center_ch2 = ieee80211_frequency_to_channel(freq2);\n\n\tif (req.tlv.control_ch < req.tlv.center_ch)\n\t\treq.tlv.sco = 1;  \n\telse if (req.tlv.control_ch > req.tlv.center_ch)\n\t\treq.tlv.sco = 3;  \n\n\treturn mt76_mcu_send_msg(vif->phy->mt76->dev, MCU_UNI_CMD(SNIFFER),\n\t\t\t\t &req, sizeof(req), true);\n}\n\nint\nmt7921_mcu_uni_add_beacon_offload(struct mt792x_dev *dev,\n\t\t\t\t  struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  bool enable)\n{\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tstruct mt76_wcid *wcid = &dev->mt76.global_wcid;\n\tstruct ieee80211_mutable_offsets offs;\n\tstruct {\n\t\tstruct req_hdr {\n\t\t\tu8 bss_idx;\n\t\t\tu8 pad[3];\n\t\t} __packed hdr;\n\t\tstruct bcn_content_tlv {\n\t\t\t__le16 tag;\n\t\t\t__le16 len;\n\t\t\t__le16 tim_ie_pos;\n\t\t\t__le16 csa_ie_pos;\n\t\t\t__le16 bcc_ie_pos;\n\t\t\t \n\t\t\tu8 enable;\n\t\t\t \n\t\t\tu8 type;\n\t\t\t__le16 pkt_len;\n\t\t\tu8 pkt[512];\n\t\t} __packed beacon_tlv;\n\t} req = {\n\t\t.hdr = {\n\t\t\t.bss_idx = mvif->mt76.idx,\n\t\t},\n\t\t.beacon_tlv = {\n\t\t\t.tag = cpu_to_le16(UNI_BSS_INFO_BCN_CONTENT),\n\t\t\t.len = cpu_to_le16(sizeof(struct bcn_content_tlv)),\n\t\t\t.enable = enable,\n\t\t},\n\t};\n\tstruct sk_buff *skb;\n\n\t \n\tif (!enable)\n\t\treturn -EOPNOTSUPP;\n\n\tskb = ieee80211_beacon_get_template(mt76_hw(dev), vif, &offs, 0);\n\tif (!skb)\n\t\treturn -EINVAL;\n\n\tif (skb->len > 512 - MT_TXD_SIZE) {\n\t\tdev_err(dev->mt76.dev, \"beacon size limit exceed\\n\");\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tmt76_connac2_mac_write_txwi(&dev->mt76, (__le32 *)(req.beacon_tlv.pkt),\n\t\t\t\t    skb, wcid, NULL, 0, 0, BSS_CHANGED_BEACON);\n\tmemcpy(req.beacon_tlv.pkt + MT_TXD_SIZE, skb->data, skb->len);\n\treq.beacon_tlv.pkt_len = cpu_to_le16(MT_TXD_SIZE + skb->len);\n\treq.beacon_tlv.tim_ie_pos = cpu_to_le16(MT_TXD_SIZE + offs.tim_offset);\n\n\tif (offs.cntdwn_counter_offs[0]) {\n\t\tu16 csa_offs;\n\n\t\tcsa_offs = MT_TXD_SIZE + offs.cntdwn_counter_offs[0] - 4;\n\t\treq.beacon_tlv.csa_ie_pos = cpu_to_le16(csa_offs);\n\t}\n\tdev_kfree_skb(skb);\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_UNI_CMD(BSS_INFO_UPDATE),\n\t\t\t\t &req, sizeof(req), true);\n}\n\nstatic\nint __mt7921_mcu_set_clc(struct mt792x_dev *dev, u8 *alpha2,\n\t\t\t enum environment_cap env_cap,\n\t\t\t struct mt7921_clc *clc,\n\t\t\t u8 idx)\n{\n\tstruct sk_buff *skb;\n\tstruct {\n\t\tu8 ver;\n\t\tu8 pad0;\n\t\t__le16 len;\n\t\tu8 idx;\n\t\tu8 env;\n\t\tu8 acpi_conf;\n\t\tu8 pad1;\n\t\tu8 alpha2[2];\n\t\tu8 type[2];\n\t\tu8 rsvd[64];\n\t} __packed req = {\n\t\t.ver = 1,\n\t\t.idx = idx,\n\t\t.env = env_cap,\n\t\t.acpi_conf = mt792x_acpi_get_flags(&dev->phy),\n\t};\n\tint ret, valid_cnt = 0;\n\tu16 buf_len = 0;\n\tu8 *pos;\n\n\tif (!clc)\n\t\treturn 0;\n\n\tbuf_len = le16_to_cpu(clc->len) - sizeof(*clc);\n\tpos = clc->data;\n\twhile (buf_len > 16) {\n\t\tstruct mt7921_clc_rule *rule = (struct mt7921_clc_rule *)pos;\n\t\tu16 len = le16_to_cpu(rule->len);\n\t\tu16 offset = len + sizeof(*rule);\n\n\t\tpos += offset;\n\t\tbuf_len -= offset;\n\t\tif (rule->alpha2[0] != alpha2[0] ||\n\t\t    rule->alpha2[1] != alpha2[1])\n\t\t\tcontinue;\n\n\t\tmemcpy(req.alpha2, rule->alpha2, 2);\n\t\tmemcpy(req.type, rule->type, 2);\n\n\t\treq.len = cpu_to_le16(sizeof(req) + len);\n\t\tskb = __mt76_mcu_msg_alloc(&dev->mt76, &req,\n\t\t\t\t\t   le16_to_cpu(req.len),\n\t\t\t\t\t   sizeof(req), GFP_KERNEL);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\t\tskb_put_data(skb, rule->data, len);\n\n\t\tret = mt76_mcu_skb_send_msg(&dev->mt76, skb,\n\t\t\t\t\t    MCU_CE_CMD(SET_CLC), false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tvalid_cnt++;\n\t}\n\n\tif (!valid_cnt)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\nint mt7921_mcu_set_clc(struct mt792x_dev *dev, u8 *alpha2,\n\t\t       enum environment_cap env_cap)\n{\n\tstruct mt792x_phy *phy = (struct mt792x_phy *)&dev->phy;\n\tint i, ret;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(phy->clc); i++) {\n\t\tret = __mt7921_mcu_set_clc(dev, alpha2, env_cap,\n\t\t\t\t\t   phy->clc[i], i);\n\n\t\t \n\t\tif (ret == -ENOENT)\n\t\t\tret = __mt7921_mcu_set_clc(dev, \"00\",\n\t\t\t\t\t\t   ENVIRON_INDOOR,\n\t\t\t\t\t\t   phy->clc[i], i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nint mt7921_mcu_get_temperature(struct mt792x_phy *phy)\n{\n\tstruct mt792x_dev *dev = phy->dev;\n\tstruct {\n\t\tu8 ctrl_id;\n\t\tu8 action;\n\t\tu8 band_idx;\n\t\tu8 rsv[5];\n\t} req = {\n\t\t.ctrl_id = THERMAL_SENSOR_TEMP_QUERY,\n\t\t.band_idx = phy->mt76->band_idx,\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_EXT_CMD(THERMAL_CTRL), &req,\n\t\t\t\t sizeof(req), true);\n}\n\nint mt7921_mcu_set_rxfilter(struct mt792x_dev *dev, u32 fif,\n\t\t\t    u8 bit_op, u32 bit_map)\n{\n\tstruct {\n\t\tu8 rsv[4];\n\t\tu8 mode;\n\t\tu8 rsv2[3];\n\t\t__le32 fif;\n\t\t__le32 bit_map;  \n\t\tu8 bit_op;\n\t\tu8 pad[51];\n\t} __packed data = {\n\t\t.mode = fif ? 1 : 2,\n\t\t.fif = cpu_to_le32(fif),\n\t\t.bit_map = cpu_to_le32(bit_map),\n\t\t.bit_op = bit_op,\n\t};\n\n\treturn mt76_mcu_send_msg(&dev->mt76, MCU_CE_CMD(SET_RX_FILTER),\n\t\t\t\t &data, sizeof(data), false);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}