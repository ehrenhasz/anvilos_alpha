{
  "module_name": "sdio.c",
  "hash_id": "ba8ec775220216d4646e6ab32e98f1bb696a88b5b0477bf8c0160cd735e6f295",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7921/sdio.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n\n#include <linux/mmc/host.h>\n#include <linux/mmc/sdio_ids.h>\n#include <linux/mmc/sdio_func.h>\n\n#include \"mt7921.h\"\n#include \"../sdio.h\"\n#include \"../mt76_connac2_mac.h\"\n#include \"mcu.h\"\n\nstatic const struct sdio_device_id mt7921s_table[] = {\n\t{ SDIO_DEVICE(SDIO_VENDOR_ID_MEDIATEK, 0x7901),\n\t\t.driver_data = (kernel_ulong_t)MT7921_FIRMWARE_WM },\n\t{ }\t \n};\n\nstatic void mt7921s_txrx_worker(struct mt76_worker *w)\n{\n\tstruct mt76_sdio *sdio = container_of(w, struct mt76_sdio,\n\t\t\t\t\t      txrx_worker);\n\tstruct mt76_dev *mdev = container_of(sdio, struct mt76_dev, sdio);\n\tstruct mt792x_dev *dev = container_of(mdev, struct mt792x_dev, mt76);\n\n\tif (!mt76_connac_pm_ref(&dev->mphy, &dev->pm)) {\n\t\tqueue_work(mdev->wq, &dev->pm.wake_work);\n\t\treturn;\n\t}\n\n\tmt76s_txrx_worker(sdio);\n\tmt76_connac_pm_unref(&dev->mphy, &dev->pm);\n}\n\nstatic void mt7921s_unregister_device(struct mt792x_dev *dev)\n{\n\tstruct mt76_connac_pm *pm = &dev->pm;\n\n\tcancel_work_sync(&dev->init_work);\n\tmt76_unregister_device(&dev->mt76);\n\tcancel_delayed_work_sync(&pm->ps_work);\n\tcancel_work_sync(&pm->wake_work);\n\n\tmt76s_deinit(&dev->mt76);\n\tmt7921s_wfsys_reset(dev);\n\tskb_queue_purge(&dev->mt76.mcu.res_q);\n\n\tmt76_free_device(&dev->mt76);\n}\n\nstatic int mt7921s_parse_intr(struct mt76_dev *dev, struct mt76s_intr *intr)\n{\n\tstruct mt76_sdio *sdio = &dev->sdio;\n\tstruct mt7921_sdio_intr *irq_data = sdio->intr_data;\n\tint i, err;\n\n\tsdio_claim_host(sdio->func);\n\terr = sdio_readsb(sdio->func, irq_data, MCR_WHISR, sizeof(*irq_data));\n\tsdio_release_host(sdio->func);\n\n\tif (err < 0)\n\t\treturn err;\n\n\tif (irq_data->rx.num[0] > 16 ||\n\t    irq_data->rx.num[1] > 128)\n\t\treturn -EINVAL;\n\n\tintr->isr = irq_data->isr;\n\tintr->rec_mb = irq_data->rec_mb;\n\tintr->tx.wtqcr = irq_data->tx.wtqcr;\n\tintr->rx.num = irq_data->rx.num;\n\tfor (i = 0; i < 2 ; i++) {\n\t\tif (!i)\n\t\t\tintr->rx.len[0] = irq_data->rx.len0;\n\t\telse\n\t\t\tintr->rx.len[1] = irq_data->rx.len1;\n\t}\n\n\treturn 0;\n}\n\nstatic int mt7921s_probe(struct sdio_func *func,\n\t\t\t const struct sdio_device_id *id)\n{\n\tstatic const struct mt76_driver_ops drv_ops = {\n\t\t.txwi_size = MT_SDIO_TXD_SIZE,\n\t\t.drv_flags = MT_DRV_AMSDU_OFFLOAD,\n\t\t.survey_flags = SURVEY_INFO_TIME_TX |\n\t\t\t\tSURVEY_INFO_TIME_RX |\n\t\t\t\tSURVEY_INFO_TIME_BSS_RX,\n\t\t.tx_prepare_skb = mt7921_usb_sdio_tx_prepare_skb,\n\t\t.tx_complete_skb = mt7921_usb_sdio_tx_complete_skb,\n\t\t.tx_status_data = mt7921_usb_sdio_tx_status_data,\n\t\t.rx_skb = mt7921_queue_rx_skb,\n\t\t.rx_check = mt7921_rx_check,\n\t\t.sta_add = mt7921_mac_sta_add,\n\t\t.sta_assoc = mt7921_mac_sta_assoc,\n\t\t.sta_remove = mt7921_mac_sta_remove,\n\t\t.update_survey = mt792x_update_channel,\n\t};\n\tstatic const struct mt76_bus_ops mt7921s_ops = {\n\t\t.rr = mt76s_rr,\n\t\t.rmw = mt76s_rmw,\n\t\t.wr = mt76s_wr,\n\t\t.write_copy = mt76s_write_copy,\n\t\t.read_copy = mt76s_read_copy,\n\t\t.wr_rp = mt76s_wr_rp,\n\t\t.rd_rp = mt76s_rd_rp,\n\t\t.type = MT76_BUS_SDIO,\n\t};\n\tstatic const struct mt792x_hif_ops mt7921_sdio_ops = {\n\t\t.init_reset = mt7921s_init_reset,\n\t\t.reset = mt7921s_mac_reset,\n\t\t.mcu_init = mt7921s_mcu_init,\n\t\t.drv_own = mt7921s_mcu_drv_pmctrl,\n\t\t.fw_own = mt7921s_mcu_fw_pmctrl,\n\t};\n\tstruct ieee80211_ops *ops;\n\tstruct mt792x_dev *dev;\n\tstruct mt76_dev *mdev;\n\tu8 features;\n\tint ret;\n\n\tops = mt792x_get_mac80211_ops(&func->dev, &mt7921_ops,\n\t\t\t\t      (void *)id->driver_data, &features);\n\tif (!ops)\n\t\treturn -ENOMEM;\n\n\tmdev = mt76_alloc_device(&func->dev, sizeof(*dev), ops, &drv_ops);\n\tif (!mdev)\n\t\treturn -ENOMEM;\n\n\tdev = container_of(mdev, struct mt792x_dev, mt76);\n\tdev->fw_features = features;\n\tdev->hif_ops = &mt7921_sdio_ops;\n\tsdio_set_drvdata(func, dev);\n\n\tret = mt76s_init(mdev, func, &mt7921s_ops);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = mt76s_hw_init(mdev, func, MT76_CONNAC2_SDIO);\n\tif (ret)\n\t\tgoto error;\n\n\tmdev->rev = (mt76_rr(dev, MT_HW_CHIPID) << 16) |\n\t\t    (mt76_rr(dev, MT_HW_REV) & 0xff);\n\tdev_dbg(mdev->dev, \"ASIC revision: %04x\\n\", mdev->rev);\n\n\tmdev->sdio.parse_irq = mt7921s_parse_intr;\n\tmdev->sdio.intr_data = devm_kmalloc(mdev->dev,\n\t\t\t\t\t    sizeof(struct mt7921_sdio_intr),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!mdev->sdio.intr_data) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tret = mt76s_alloc_rx_queue(mdev, MT_RXQ_MAIN);\n\tif (ret)\n\t\tgoto error;\n\n\tret = mt76s_alloc_rx_queue(mdev, MT_RXQ_MCU);\n\tif (ret)\n\t\tgoto error;\n\n\tret = mt76s_alloc_tx(mdev);\n\tif (ret)\n\t\tgoto error;\n\n\tret = mt76_worker_setup(mt76_hw(dev), &mdev->sdio.txrx_worker,\n\t\t\t\tmt7921s_txrx_worker, \"sdio-txrx\");\n\tif (ret)\n\t\tgoto error;\n\n\tsched_set_fifo_low(mdev->sdio.txrx_worker.task);\n\n\tret = mt7921_register_device(dev);\n\tif (ret)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tmt76s_deinit(&dev->mt76);\n\tmt76_free_device(&dev->mt76);\n\n\treturn ret;\n}\n\nstatic void mt7921s_remove(struct sdio_func *func)\n{\n\tstruct mt792x_dev *dev = sdio_get_drvdata(func);\n\n\tmt7921s_unregister_device(dev);\n}\n\nstatic int mt7921s_suspend(struct device *__dev)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(__dev);\n\tstruct mt792x_dev *dev = sdio_get_drvdata(func);\n\tstruct mt76_connac_pm *pm = &dev->pm;\n\tstruct mt76_dev *mdev = &dev->mt76;\n\tint err;\n\n\tpm->suspended = true;\n\tset_bit(MT76_STATE_SUSPEND, &mdev->phy.state);\n\n\tflush_work(&dev->reset_work);\n\tcancel_delayed_work_sync(&pm->ps_work);\n\tcancel_work_sync(&pm->wake_work);\n\n\terr = mt792x_mcu_drv_pmctrl(dev);\n\tif (err < 0)\n\t\tgoto restore_suspend;\n\n\t \n\tmt76_connac_mcu_set_deep_sleep(mdev, true);\n\n\tmt76_txq_schedule_all(&dev->mphy);\n\tmt76_worker_disable(&mdev->tx_worker);\n\tmt76_worker_disable(&mdev->sdio.status_worker);\n\tmt76_worker_disable(&mdev->sdio.stat_worker);\n\tclear_bit(MT76_READING_STATS, &dev->mphy.state);\n\tmt76_tx_status_check(mdev, true);\n\n\tmt76_worker_schedule(&mdev->sdio.txrx_worker);\n\twait_event_timeout(dev->mt76.sdio.wait,\n\t\t\t   mt76s_txqs_empty(&dev->mt76), 5 * HZ);\n\n\t \n\terr = mt76_connac_mcu_set_hif_suspend(mdev, true);\n\tif (err)\n\t\tgoto restore_worker;\n\n\tmt76_worker_disable(&mdev->sdio.txrx_worker);\n\tmt76_worker_disable(&mdev->sdio.net_worker);\n\n\terr = mt792x_mcu_fw_pmctrl(dev);\n\tif (err)\n\t\tgoto restore_txrx_worker;\n\n\tsdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);\n\n\treturn 0;\n\nrestore_txrx_worker:\n\tmt76_worker_enable(&mdev->sdio.net_worker);\n\tmt76_worker_enable(&mdev->sdio.txrx_worker);\n\tmt76_connac_mcu_set_hif_suspend(mdev, false);\n\nrestore_worker:\n\tmt76_worker_enable(&mdev->tx_worker);\n\tmt76_worker_enable(&mdev->sdio.status_worker);\n\tmt76_worker_enable(&mdev->sdio.stat_worker);\n\n\tif (!pm->ds_enable)\n\t\tmt76_connac_mcu_set_deep_sleep(mdev, false);\n\nrestore_suspend:\n\tclear_bit(MT76_STATE_SUSPEND, &mdev->phy.state);\n\tpm->suspended = false;\n\n\tif (err < 0)\n\t\tmt792x_reset(&dev->mt76);\n\n\treturn err;\n}\n\nstatic int mt7921s_resume(struct device *__dev)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(__dev);\n\tstruct mt792x_dev *dev = sdio_get_drvdata(func);\n\tstruct mt76_connac_pm *pm = &dev->pm;\n\tstruct mt76_dev *mdev = &dev->mt76;\n\tint err;\n\n\tclear_bit(MT76_STATE_SUSPEND, &mdev->phy.state);\n\n\terr = mt792x_mcu_drv_pmctrl(dev);\n\tif (err < 0)\n\t\tgoto failed;\n\n\tmt76_worker_enable(&mdev->tx_worker);\n\tmt76_worker_enable(&mdev->sdio.txrx_worker);\n\tmt76_worker_enable(&mdev->sdio.status_worker);\n\tmt76_worker_enable(&mdev->sdio.net_worker);\n\tmt76_worker_enable(&mdev->sdio.stat_worker);\n\n\t \n\tif (!pm->ds_enable)\n\t\tmt76_connac_mcu_set_deep_sleep(mdev, false);\n\n\terr = mt76_connac_mcu_set_hif_suspend(mdev, false);\nfailed:\n\tpm->suspended = false;\n\n\tif (err < 0)\n\t\tmt792x_reset(&dev->mt76);\n\n\treturn err;\n}\n\nMODULE_DEVICE_TABLE(sdio, mt7921s_table);\nMODULE_FIRMWARE(MT7921_FIRMWARE_WM);\nMODULE_FIRMWARE(MT7921_ROM_PATCH);\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(mt7921s_pm_ops, mt7921s_suspend, mt7921s_resume);\n\nstatic struct sdio_driver mt7921s_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.probe\t\t= mt7921s_probe,\n\t.remove\t\t= mt7921s_remove,\n\t.id_table\t= mt7921s_table,\n\t.drv.pm\t\t= pm_sleep_ptr(&mt7921s_pm_ops),\n};\nmodule_sdio_driver(mt7921s_driver);\nMODULE_AUTHOR(\"Sean Wang <sean.wang@mediatek.com>\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}