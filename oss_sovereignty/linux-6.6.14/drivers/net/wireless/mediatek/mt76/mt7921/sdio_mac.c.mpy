{
  "module_name": "sdio_mac.c",
  "hash_id": "51ebfe482ca973061ac305473feebdda0bc483cbacc9971c6b9648d27e2b067e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt7921/sdio_mac.c",
  "human_readable_source": "\n \n\n#include <linux/iopoll.h>\n#include <linux/mmc/sdio_func.h>\n#include \"mt7921.h\"\n#include \"../mt76_connac2_mac.h\"\n#include \"../sdio.h\"\n\nstatic void mt7921s_enable_irq(struct mt76_dev *dev)\n{\n\tstruct mt76_sdio *sdio = &dev->sdio;\n\n\tsdio_claim_host(sdio->func);\n\tsdio_writel(sdio->func, WHLPCR_INT_EN_SET, MCR_WHLPCR, NULL);\n\tsdio_release_host(sdio->func);\n}\n\nstatic void mt7921s_disable_irq(struct mt76_dev *dev)\n{\n\tstruct mt76_sdio *sdio = &dev->sdio;\n\n\tsdio_claim_host(sdio->func);\n\tsdio_writel(sdio->func, WHLPCR_INT_EN_CLR, MCR_WHLPCR, NULL);\n\tsdio_release_host(sdio->func);\n}\n\nstatic u32 mt7921s_read_whcr(struct mt76_dev *dev)\n{\n\treturn sdio_readl(dev->sdio.func, MCR_WHCR, NULL);\n}\n\nint mt7921s_wfsys_reset(struct mt792x_dev *dev)\n{\n\tstruct mt76_sdio *sdio = &dev->mt76.sdio;\n\tu32 val, status;\n\n\tmt7921s_mcu_drv_pmctrl(dev);\n\n\tsdio_claim_host(sdio->func);\n\n\tval = sdio_readl(sdio->func, MCR_WHCR, NULL);\n\tval &= ~WF_WHOLE_PATH_RSTB;\n\tsdio_writel(sdio->func, val, MCR_WHCR, NULL);\n\n\tmsleep(50);\n\n\tval = sdio_readl(sdio->func, MCR_WHCR, NULL);\n\tval &= ~WF_SDIO_WF_PATH_RSTB;\n\tsdio_writel(sdio->func, val, MCR_WHCR, NULL);\n\n\tusleep_range(1000, 2000);\n\n\tval = sdio_readl(sdio->func, MCR_WHCR, NULL);\n\tval |= WF_WHOLE_PATH_RSTB;\n\tsdio_writel(sdio->func, val, MCR_WHCR, NULL);\n\n\treadx_poll_timeout(mt7921s_read_whcr, &dev->mt76, status,\n\t\t\t   status & WF_RST_DONE, 50000, 2000000);\n\n\tsdio_release_host(sdio->func);\n\n\tclear_bit(MT76_STATE_MCU_RUNNING, &dev->mphy.state);\n\n\t \n\tmt7921s_mcu_drv_pmctrl(dev);\n\tmt76_clear(dev, MT_CONN_STATUS, MT_WIFI_PATCH_DL_STATE);\n\tmt7921s_mcu_fw_pmctrl(dev);\n\tmt7921s_mcu_drv_pmctrl(dev);\n\n\treturn 0;\n}\n\nint mt7921s_init_reset(struct mt792x_dev *dev)\n{\n\tset_bit(MT76_MCU_RESET, &dev->mphy.state);\n\n\twake_up(&dev->mt76.mcu.wait);\n\tskb_queue_purge(&dev->mt76.mcu.res_q);\n\twait_event_timeout(dev->mt76.sdio.wait,\n\t\t\t   mt76s_txqs_empty(&dev->mt76), 5 * HZ);\n\tmt76_worker_disable(&dev->mt76.sdio.txrx_worker);\n\n\tmt7921s_disable_irq(&dev->mt76);\n\tmt7921s_wfsys_reset(dev);\n\n\tmt76_worker_enable(&dev->mt76.sdio.txrx_worker);\n\tclear_bit(MT76_MCU_RESET, &dev->mphy.state);\n\tmt7921s_enable_irq(&dev->mt76);\n\n\treturn 0;\n}\n\nint mt7921s_mac_reset(struct mt792x_dev *dev)\n{\n\tint err;\n\n\tmt76_connac_free_pending_tx_skbs(&dev->pm, NULL);\n\tmt76_txq_schedule_all(&dev->mphy);\n\tmt76_worker_disable(&dev->mt76.tx_worker);\n\tset_bit(MT76_RESET, &dev->mphy.state);\n\tset_bit(MT76_MCU_RESET, &dev->mphy.state);\n\twake_up(&dev->mt76.mcu.wait);\n\tskb_queue_purge(&dev->mt76.mcu.res_q);\n\twait_event_timeout(dev->mt76.sdio.wait,\n\t\t\t   mt76s_txqs_empty(&dev->mt76), 5 * HZ);\n\tmt76_worker_disable(&dev->mt76.sdio.txrx_worker);\n\tmt76_worker_disable(&dev->mt76.sdio.status_worker);\n\tmt76_worker_disable(&dev->mt76.sdio.net_worker);\n\tmt76_worker_disable(&dev->mt76.sdio.stat_worker);\n\n\tmt7921s_disable_irq(&dev->mt76);\n\tmt7921s_wfsys_reset(dev);\n\n\tmt76_worker_enable(&dev->mt76.sdio.txrx_worker);\n\tmt76_worker_enable(&dev->mt76.sdio.status_worker);\n\tmt76_worker_enable(&dev->mt76.sdio.net_worker);\n\tmt76_worker_enable(&dev->mt76.sdio.stat_worker);\n\n\tdev->fw_assert = false;\n\tclear_bit(MT76_MCU_RESET, &dev->mphy.state);\n\tmt7921s_enable_irq(&dev->mt76);\n\n\terr = mt7921_run_firmware(dev);\n\tif (err)\n\t\tgoto out;\n\n\terr = mt7921_mcu_set_eeprom(dev);\n\tif (err)\n\t\tgoto out;\n\n\terr = mt7921_mac_init(dev);\n\tif (err)\n\t\tgoto out;\n\n\terr = __mt7921_start(&dev->phy);\nout:\n\tclear_bit(MT76_RESET, &dev->mphy.state);\n\n\tmt76_worker_enable(&dev->mt76.tx_worker);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}