{
  "module_name": "mt76x02_mac.c",
  "hash_id": "1b26e72a1ce64de17d924085ddb9cdaac1acd063123d30100563176e40afe873",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt76x02_mac.c",
  "human_readable_source": "\n \n\n#include \"mt76x02.h\"\n#include \"mt76x02_trace.h\"\n#include \"trace.h\"\n\nvoid mt76x02_mac_reset_counters(struct mt76x02_dev *dev)\n{\n\tint i;\n\n\tmt76_rr(dev, MT_RX_STAT_0);\n\tmt76_rr(dev, MT_RX_STAT_1);\n\tmt76_rr(dev, MT_RX_STAT_2);\n\tmt76_rr(dev, MT_TX_STA_0);\n\tmt76_rr(dev, MT_TX_STA_1);\n\tmt76_rr(dev, MT_TX_STA_2);\n\n\tfor (i = 0; i < 16; i++)\n\t\tmt76_rr(dev, MT_TX_AGG_CNT(i));\n\n\tfor (i = 0; i < 16; i++)\n\t\tmt76_rr(dev, MT_TX_STAT_FIFO);\n\n\tmemset(dev->mphy.aggr_stats, 0, sizeof(dev->mphy.aggr_stats));\n}\nEXPORT_SYMBOL_GPL(mt76x02_mac_reset_counters);\n\nstatic enum mt76x02_cipher_type\nmt76x02_mac_get_key_info(struct ieee80211_key_conf *key, u8 *key_data)\n{\n\tmemset(key_data, 0, 32);\n\tif (!key)\n\t\treturn MT76X02_CIPHER_NONE;\n\n\tif (key->keylen > 32)\n\t\treturn MT76X02_CIPHER_NONE;\n\n\tmemcpy(key_data, key->key, key->keylen);\n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\treturn MT76X02_CIPHER_WEP40;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\treturn MT76X02_CIPHER_WEP104;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\treturn MT76X02_CIPHER_TKIP;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\treturn MT76X02_CIPHER_AES_CCMP;\n\tdefault:\n\t\treturn MT76X02_CIPHER_NONE;\n\t}\n}\n\nint mt76x02_mac_shared_key_setup(struct mt76x02_dev *dev, u8 vif_idx,\n\t\t\t\t u8 key_idx, struct ieee80211_key_conf *key)\n{\n\tenum mt76x02_cipher_type cipher;\n\tu8 key_data[32];\n\tu32 val;\n\n\tcipher = mt76x02_mac_get_key_info(key, key_data);\n\tif (cipher == MT76X02_CIPHER_NONE && key)\n\t\treturn -EOPNOTSUPP;\n\n\tval = mt76_rr(dev, MT_SKEY_MODE(vif_idx));\n\tval &= ~(MT_SKEY_MODE_MASK << MT_SKEY_MODE_SHIFT(vif_idx, key_idx));\n\tval |= cipher << MT_SKEY_MODE_SHIFT(vif_idx, key_idx);\n\tmt76_wr(dev, MT_SKEY_MODE(vif_idx), val);\n\n\tmt76_wr_copy(dev, MT_SKEY(vif_idx, key_idx), key_data,\n\t\t     sizeof(key_data));\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76x02_mac_shared_key_setup);\n\nvoid mt76x02_mac_wcid_sync_pn(struct mt76x02_dev *dev, u8 idx,\n\t\t\t      struct ieee80211_key_conf *key)\n{\n\tenum mt76x02_cipher_type cipher;\n\tu8 key_data[32];\n\tu32 iv, eiv;\n\tu64 pn;\n\n\tcipher = mt76x02_mac_get_key_info(key, key_data);\n\tiv = mt76_rr(dev, MT_WCID_IV(idx));\n\teiv = mt76_rr(dev, MT_WCID_IV(idx) + 4);\n\n\tpn = (u64)eiv << 16;\n\tif (cipher == MT76X02_CIPHER_TKIP) {\n\t\tpn |= (iv >> 16) & 0xff;\n\t\tpn |= (iv & 0xff) << 8;\n\t} else if (cipher >= MT76X02_CIPHER_AES_CCMP) {\n\t\tpn |= iv & 0xffff;\n\t} else {\n\t\treturn;\n\t}\n\n\tatomic64_set(&key->tx_pn, pn);\n}\n\nint mt76x02_mac_wcid_set_key(struct mt76x02_dev *dev, u8 idx,\n\t\t\t     struct ieee80211_key_conf *key)\n{\n\tenum mt76x02_cipher_type cipher;\n\tu8 key_data[32];\n\tu8 iv_data[8];\n\tu64 pn;\n\n\tcipher = mt76x02_mac_get_key_info(key, key_data);\n\tif (cipher == MT76X02_CIPHER_NONE && key)\n\t\treturn -EOPNOTSUPP;\n\n\tmt76_wr_copy(dev, MT_WCID_KEY(idx), key_data, sizeof(key_data));\n\tmt76_rmw_field(dev, MT_WCID_ATTR(idx), MT_WCID_ATTR_PKEY_MODE, cipher);\n\n\tmemset(iv_data, 0, sizeof(iv_data));\n\tif (key) {\n\t\tmt76_rmw_field(dev, MT_WCID_ATTR(idx), MT_WCID_ATTR_PAIRWISE,\n\t\t\t       !!(key->flags & IEEE80211_KEY_FLAG_PAIRWISE));\n\n\t\tpn = atomic64_read(&key->tx_pn);\n\n\t\tiv_data[3] = key->keyidx << 6;\n\t\tif (cipher >= MT76X02_CIPHER_TKIP) {\n\t\t\tiv_data[3] |= 0x20;\n\t\t\tput_unaligned_le32(pn >> 16, &iv_data[4]);\n\t\t}\n\n\t\tif (cipher == MT76X02_CIPHER_TKIP) {\n\t\t\tiv_data[0] = (pn >> 8) & 0xff;\n\t\t\tiv_data[1] = (iv_data[0] | 0x20) & 0x7f;\n\t\t\tiv_data[2] = pn & 0xff;\n\t\t} else if (cipher >= MT76X02_CIPHER_AES_CCMP) {\n\t\t\tput_unaligned_le16((pn & 0xffff), &iv_data[0]);\n\t\t}\n\t}\n\n\tmt76_wr_copy(dev, MT_WCID_IV(idx), iv_data, sizeof(iv_data));\n\n\treturn 0;\n}\n\nvoid mt76x02_mac_wcid_setup(struct mt76x02_dev *dev, u8 idx,\n\t\t\t    u8 vif_idx, u8 *mac)\n{\n\tstruct mt76_wcid_addr addr = {};\n\tu32 attr;\n\n\tattr = FIELD_PREP(MT_WCID_ATTR_BSS_IDX, vif_idx & 7) |\n\t       FIELD_PREP(MT_WCID_ATTR_BSS_IDX_EXT, !!(vif_idx & 8));\n\n\tmt76_wr(dev, MT_WCID_ATTR(idx), attr);\n\n\tif (idx >= 128)\n\t\treturn;\n\n\tif (mac)\n\t\tmemcpy(addr.macaddr, mac, ETH_ALEN);\n\n\tmt76_wr_copy(dev, MT_WCID_ADDR(idx), &addr, sizeof(addr));\n}\nEXPORT_SYMBOL_GPL(mt76x02_mac_wcid_setup);\n\nvoid mt76x02_mac_wcid_set_drop(struct mt76x02_dev *dev, u8 idx, bool drop)\n{\n\tu32 val = mt76_rr(dev, MT_WCID_DROP(idx));\n\tu32 bit = MT_WCID_DROP_MASK(idx);\n\n\t \n\tif ((val & bit) != (bit * drop))\n\t\tmt76_wr(dev, MT_WCID_DROP(idx), (val & ~bit) | (bit * drop));\n}\n\nstatic u16\nmt76x02_mac_tx_rate_val(struct mt76x02_dev *dev,\n\t\t\tconst struct ieee80211_tx_rate *rate, u8 *nss_val)\n{\n\tu8 phy, rate_idx, nss, bw = 0;\n\tu16 rateval;\n\n\tif (rate->flags & IEEE80211_TX_RC_VHT_MCS) {\n\t\trate_idx = rate->idx;\n\t\tnss = 1 + (rate->idx >> 4);\n\t\tphy = MT_PHY_TYPE_VHT;\n\t\tif (rate->flags & IEEE80211_TX_RC_80_MHZ_WIDTH)\n\t\t\tbw = 2;\n\t\telse if (rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\n\t\t\tbw = 1;\n\t} else if (rate->flags & IEEE80211_TX_RC_MCS) {\n\t\trate_idx = rate->idx;\n\t\tnss = 1 + (rate->idx >> 3);\n\t\tphy = MT_PHY_TYPE_HT;\n\t\tif (rate->flags & IEEE80211_TX_RC_GREEN_FIELD)\n\t\t\tphy = MT_PHY_TYPE_HT_GF;\n\t\tif (rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\n\t\t\tbw = 1;\n\t} else {\n\t\tconst struct ieee80211_rate *r;\n\t\tint band = dev->mphy.chandef.chan->band;\n\t\tu16 val;\n\n\t\tr = &dev->mt76.hw->wiphy->bands[band]->bitrates[rate->idx];\n\t\tif (rate->flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE)\n\t\t\tval = r->hw_value_short;\n\t\telse\n\t\t\tval = r->hw_value;\n\n\t\tphy = val >> 8;\n\t\trate_idx = val & 0xff;\n\t\tnss = 1;\n\t}\n\n\trateval = FIELD_PREP(MT_RXWI_RATE_INDEX, rate_idx);\n\trateval |= FIELD_PREP(MT_RXWI_RATE_PHY, phy);\n\trateval |= FIELD_PREP(MT_RXWI_RATE_BW, bw);\n\tif (rate->flags & IEEE80211_TX_RC_SHORT_GI)\n\t\trateval |= MT_RXWI_RATE_SGI;\n\n\t*nss_val = nss;\n\treturn rateval;\n}\n\nvoid mt76x02_mac_wcid_set_rate(struct mt76x02_dev *dev, struct mt76_wcid *wcid,\n\t\t\t       const struct ieee80211_tx_rate *rate)\n{\n\ts8 max_txpwr_adj = mt76x02_tx_get_max_txpwr_adj(dev, rate);\n\tu16 rateval;\n\tu32 tx_info;\n\ts8 nss;\n\n\trateval = mt76x02_mac_tx_rate_val(dev, rate, &nss);\n\ttx_info = FIELD_PREP(MT_WCID_TX_INFO_RATE, rateval) |\n\t\t  FIELD_PREP(MT_WCID_TX_INFO_NSS, nss) |\n\t\t  FIELD_PREP(MT_WCID_TX_INFO_TXPWR_ADJ, max_txpwr_adj) |\n\t\t  MT_WCID_TX_INFO_SET;\n\twcid->tx_info = tx_info;\n}\n\nvoid mt76x02_mac_set_short_preamble(struct mt76x02_dev *dev, bool enable)\n{\n\tif (enable)\n\t\tmt76_set(dev, MT_AUTO_RSP_CFG, MT_AUTO_RSP_PREAMB_SHORT);\n\telse\n\t\tmt76_clear(dev, MT_AUTO_RSP_CFG, MT_AUTO_RSP_PREAMB_SHORT);\n}\n\nbool mt76x02_mac_load_tx_status(struct mt76x02_dev *dev,\n\t\t\t\tstruct mt76x02_tx_status *stat)\n{\n\tu32 stat1, stat2;\n\n\tstat2 = mt76_rr(dev, MT_TX_STAT_FIFO_EXT);\n\tstat1 = mt76_rr(dev, MT_TX_STAT_FIFO);\n\n\tstat->valid = !!(stat1 & MT_TX_STAT_FIFO_VALID);\n\tif (!stat->valid)\n\t\treturn false;\n\n\tstat->success = !!(stat1 & MT_TX_STAT_FIFO_SUCCESS);\n\tstat->aggr = !!(stat1 & MT_TX_STAT_FIFO_AGGR);\n\tstat->ack_req = !!(stat1 & MT_TX_STAT_FIFO_ACKREQ);\n\tstat->wcid = FIELD_GET(MT_TX_STAT_FIFO_WCID, stat1);\n\tstat->rate = FIELD_GET(MT_TX_STAT_FIFO_RATE, stat1);\n\n\tstat->retry = FIELD_GET(MT_TX_STAT_FIFO_EXT_RETRY, stat2);\n\tstat->pktid = FIELD_GET(MT_TX_STAT_FIFO_EXT_PKTID, stat2);\n\n\ttrace_mac_txstat_fetch(dev, stat);\n\n\treturn true;\n}\n\nstatic int\nmt76x02_mac_process_tx_rate(struct ieee80211_tx_rate *txrate, u16 rate,\n\t\t\t    enum nl80211_band band)\n{\n\tu8 idx = FIELD_GET(MT_RXWI_RATE_INDEX, rate);\n\n\ttxrate->idx = 0;\n\ttxrate->flags = 0;\n\ttxrate->count = 1;\n\n\tswitch (FIELD_GET(MT_RXWI_RATE_PHY, rate)) {\n\tcase MT_PHY_TYPE_OFDM:\n\t\tif (band == NL80211_BAND_2GHZ)\n\t\t\tidx += 4;\n\n\t\ttxrate->idx = idx;\n\t\treturn 0;\n\tcase MT_PHY_TYPE_CCK:\n\t\tif (idx >= 8)\n\t\t\tidx -= 8;\n\n\t\ttxrate->idx = idx;\n\t\treturn 0;\n\tcase MT_PHY_TYPE_HT_GF:\n\t\ttxrate->flags |= IEEE80211_TX_RC_GREEN_FIELD;\n\t\tfallthrough;\n\tcase MT_PHY_TYPE_HT:\n\t\ttxrate->flags |= IEEE80211_TX_RC_MCS;\n\t\ttxrate->idx = idx;\n\t\tbreak;\n\tcase MT_PHY_TYPE_VHT:\n\t\ttxrate->flags |= IEEE80211_TX_RC_VHT_MCS;\n\t\ttxrate->idx = idx;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (FIELD_GET(MT_RXWI_RATE_BW, rate)) {\n\tcase MT_PHY_BW_20:\n\t\tbreak;\n\tcase MT_PHY_BW_40:\n\t\ttxrate->flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\n\t\tbreak;\n\tcase MT_PHY_BW_80:\n\t\ttxrate->flags |= IEEE80211_TX_RC_80_MHZ_WIDTH;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (rate & MT_RXWI_RATE_SGI)\n\t\ttxrate->flags |= IEEE80211_TX_RC_SHORT_GI;\n\n\treturn 0;\n}\n\nvoid mt76x02_mac_write_txwi(struct mt76x02_dev *dev, struct mt76x02_txwi *txwi,\n\t\t\t    struct sk_buff *skb, struct mt76_wcid *wcid,\n\t\t\t    struct ieee80211_sta *sta, int len)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_tx_rate *rate = &info->control.rates[0];\n\tstruct ieee80211_key_conf *key = info->control.hw_key;\n\tu32 wcid_tx_info;\n\tu16 rate_ht_mask = FIELD_PREP(MT_RXWI_RATE_PHY, BIT(1) | BIT(2));\n\tu16 txwi_flags = 0, rateval;\n\tu8 nss;\n\ts8 txpwr_adj, max_txpwr_adj;\n\tu8 ccmp_pn[8], nstreams = dev->mphy.chainmask & 0xf;\n\n\tmemset(txwi, 0, sizeof(*txwi));\n\n\tmt76_tx_check_agg_ssn(sta, skb);\n\n\tif (!info->control.hw_key && wcid && wcid->hw_key_idx != 0xff &&\n\t    ieee80211_has_protected(hdr->frame_control)) {\n\t\twcid = NULL;\n\t\tieee80211_get_tx_rates(info->control.vif, sta, skb,\n\t\t\t\t       info->control.rates, 1);\n\t}\n\n\tif (wcid)\n\t\ttxwi->wcid = wcid->idx;\n\telse\n\t\ttxwi->wcid = 0xff;\n\n\tif (wcid && wcid->sw_iv && key) {\n\t\tu64 pn = atomic64_inc_return(&key->tx_pn);\n\n\t\tccmp_pn[0] = pn;\n\t\tccmp_pn[1] = pn >> 8;\n\t\tccmp_pn[2] = 0;\n\t\tccmp_pn[3] = 0x20 | (key->keyidx << 6);\n\t\tccmp_pn[4] = pn >> 16;\n\t\tccmp_pn[5] = pn >> 24;\n\t\tccmp_pn[6] = pn >> 32;\n\t\tccmp_pn[7] = pn >> 40;\n\t\ttxwi->iv = *((__le32 *)&ccmp_pn[0]);\n\t\ttxwi->eiv = *((__le32 *)&ccmp_pn[4]);\n\t}\n\n\tif (wcid && (rate->idx < 0 || !rate->count)) {\n\t\twcid_tx_info = wcid->tx_info;\n\t\trateval = FIELD_GET(MT_WCID_TX_INFO_RATE, wcid_tx_info);\n\t\tmax_txpwr_adj = FIELD_GET(MT_WCID_TX_INFO_TXPWR_ADJ,\n\t\t\t\t\t  wcid_tx_info);\n\t\tnss = FIELD_GET(MT_WCID_TX_INFO_NSS, wcid_tx_info);\n\t} else {\n\t\trateval = mt76x02_mac_tx_rate_val(dev, rate, &nss);\n\t\tmax_txpwr_adj = mt76x02_tx_get_max_txpwr_adj(dev, rate);\n\t}\n\ttxwi->rate = cpu_to_le16(rateval);\n\n\ttxpwr_adj = mt76x02_tx_get_txpwr_adj(dev, dev->txpower_conf,\n\t\t\t\t\t     max_txpwr_adj);\n\ttxwi->ctl2 = FIELD_PREP(MT_TX_PWR_ADJ, txpwr_adj);\n\n\tif (nstreams > 1 && mt76_rev(&dev->mt76) >= MT76XX_REV_E4)\n\t\ttxwi->txstream = 0x13;\n\telse if (nstreams > 1 && mt76_rev(&dev->mt76) >= MT76XX_REV_E3 &&\n\t\t !(txwi->rate & cpu_to_le16(rate_ht_mask)))\n\t\ttxwi->txstream = 0x93;\n\n\tif (is_mt76x2(dev) && (info->flags & IEEE80211_TX_CTL_LDPC))\n\t\ttxwi->rate |= cpu_to_le16(MT_RXWI_RATE_LDPC);\n\tif ((info->flags & IEEE80211_TX_CTL_STBC) && nss == 1)\n\t\ttxwi->rate |= cpu_to_le16(MT_RXWI_RATE_STBC);\n\tif (nss > 1 && sta && sta->deflink.smps_mode == IEEE80211_SMPS_DYNAMIC)\n\t\ttxwi_flags |= MT_TXWI_FLAGS_MMPS;\n\tif (!(info->flags & IEEE80211_TX_CTL_NO_ACK))\n\t\ttxwi->ack_ctl |= MT_TXWI_ACK_CTL_REQ;\n\tif (info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ)\n\t\ttxwi->ack_ctl |= MT_TXWI_ACK_CTL_NSEQ;\n\tif ((info->flags & IEEE80211_TX_CTL_AMPDU) && sta) {\n\t\tu8 ba_size = IEEE80211_MIN_AMPDU_BUF;\n\t\tu8 ampdu_density = sta->deflink.ht_cap.ampdu_density;\n\n\t\tba_size <<= sta->deflink.ht_cap.ampdu_factor;\n\t\tba_size = min_t(int, 63, ba_size - 1);\n\t\tif (info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE)\n\t\t\tba_size = 0;\n\t\ttxwi->ack_ctl |= FIELD_PREP(MT_TXWI_ACK_CTL_BA_WINDOW, ba_size);\n\n\t\tif (ampdu_density < IEEE80211_HT_MPDU_DENSITY_4)\n\t\t\tampdu_density = IEEE80211_HT_MPDU_DENSITY_4;\n\n\t\ttxwi_flags |= MT_TXWI_FLAGS_AMPDU |\n\t\t\t FIELD_PREP(MT_TXWI_FLAGS_MPDU_DENSITY, ampdu_density);\n\t}\n\n\tif (ieee80211_is_probe_resp(hdr->frame_control) ||\n\t    ieee80211_is_beacon(hdr->frame_control))\n\t\ttxwi_flags |= MT_TXWI_FLAGS_TS;\n\n\ttxwi->flags |= cpu_to_le16(txwi_flags);\n\ttxwi->len_ctl = cpu_to_le16(len);\n}\nEXPORT_SYMBOL_GPL(mt76x02_mac_write_txwi);\n\nstatic void\nmt76x02_tx_rate_fallback(struct ieee80211_tx_rate *rates, int idx, int phy)\n{\n\tu8 mcs, nss;\n\n\tif (!idx)\n\t\treturn;\n\n\trates += idx - 1;\n\trates[1] = rates[0];\n\tswitch (phy) {\n\tcase MT_PHY_TYPE_VHT:\n\t\tmcs = ieee80211_rate_get_vht_mcs(rates);\n\t\tnss = ieee80211_rate_get_vht_nss(rates);\n\n\t\tif (mcs == 0)\n\t\t\tnss = max_t(int, nss - 1, 1);\n\t\telse\n\t\t\tmcs--;\n\n\t\tieee80211_rate_set_vht(rates + 1, mcs, nss);\n\t\tbreak;\n\tcase MT_PHY_TYPE_HT_GF:\n\tcase MT_PHY_TYPE_HT:\n\t\t \n\t\tif (rates[0].idx == 8) {\n\t\t\trates[1].idx = 0;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\trates[1].idx = max_t(int, rates[0].idx - 1, 0);\n\t\tbreak;\n\t}\n}\n\nstatic void\nmt76x02_mac_fill_tx_status(struct mt76x02_dev *dev, struct mt76x02_sta *msta,\n\t\t\t   struct ieee80211_tx_info *info,\n\t\t\t   struct mt76x02_tx_status *st, int n_frames)\n{\n\tstruct ieee80211_tx_rate *rate = info->status.rates;\n\tstruct ieee80211_tx_rate last_rate;\n\tu16 first_rate;\n\tint retry = st->retry;\n\tint phy;\n\tint i;\n\n\tif (!n_frames)\n\t\treturn;\n\n\tphy = FIELD_GET(MT_RXWI_RATE_PHY, st->rate);\n\n\tif (st->pktid & MT_PACKET_ID_HAS_RATE) {\n\t\tfirst_rate = st->rate & ~MT_PKTID_RATE;\n\t\tfirst_rate |= st->pktid & MT_PKTID_RATE;\n\n\t\tmt76x02_mac_process_tx_rate(&rate[0], first_rate,\n\t\t\t\t\t    dev->mphy.chandef.chan->band);\n\t} else if (rate[0].idx < 0) {\n\t\tif (!msta)\n\t\t\treturn;\n\n\t\tmt76x02_mac_process_tx_rate(&rate[0], msta->wcid.tx_info,\n\t\t\t\t\t    dev->mphy.chandef.chan->band);\n\t}\n\n\tmt76x02_mac_process_tx_rate(&last_rate, st->rate,\n\t\t\t\t    dev->mphy.chandef.chan->band);\n\n\tfor (i = 0; i < ARRAY_SIZE(info->status.rates); i++) {\n\t\tretry--;\n\t\tif (i + 1 == ARRAY_SIZE(info->status.rates)) {\n\t\t\tinfo->status.rates[i] = last_rate;\n\t\t\tinfo->status.rates[i].count = max_t(int, retry, 1);\n\t\t\tbreak;\n\t\t}\n\n\t\tmt76x02_tx_rate_fallback(info->status.rates, i, phy);\n\t\tif (info->status.rates[i].idx == last_rate.idx)\n\t\t\tbreak;\n\t}\n\n\tif (i + 1 < ARRAY_SIZE(info->status.rates)) {\n\t\tinfo->status.rates[i + 1].idx = -1;\n\t\tinfo->status.rates[i + 1].count = 0;\n\t}\n\n\tinfo->status.ampdu_len = n_frames;\n\tinfo->status.ampdu_ack_len = st->success ? n_frames : 0;\n\n\tif (st->aggr)\n\t\tinfo->flags |= IEEE80211_TX_CTL_AMPDU |\n\t\t\t       IEEE80211_TX_STAT_AMPDU;\n\n\tif (!st->ack_req)\n\t\tinfo->flags |= IEEE80211_TX_CTL_NO_ACK;\n\telse if (st->success)\n\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n}\n\nvoid mt76x02_send_tx_status(struct mt76x02_dev *dev,\n\t\t\t    struct mt76x02_tx_status *stat, u8 *update)\n{\n\tstruct ieee80211_tx_info info = {};\n\tstruct ieee80211_tx_status status = {\n\t\t.info = &info\n\t};\n\tstatic const u8 ac_to_tid[4] = {\n\t\t[IEEE80211_AC_BE] = 0,\n\t\t[IEEE80211_AC_BK] = 1,\n\t\t[IEEE80211_AC_VI] = 4,\n\t\t[IEEE80211_AC_VO] = 6\n\t};\n\tstruct mt76_wcid *wcid = NULL;\n\tstruct mt76x02_sta *msta = NULL;\n\tstruct mt76_dev *mdev = &dev->mt76;\n\tstruct sk_buff_head list;\n\tu32 duration = 0;\n\tu8 cur_pktid;\n\tu32 ac = 0;\n\tint len = 0;\n\n\tif (stat->pktid == MT_PACKET_ID_NO_ACK)\n\t\treturn;\n\n\trcu_read_lock();\n\n\tif (stat->wcid < MT76x02_N_WCIDS)\n\t\twcid = rcu_dereference(dev->mt76.wcid[stat->wcid]);\n\n\tif (wcid && wcid->sta) {\n\t\tvoid *priv;\n\n\t\tpriv = msta = container_of(wcid, struct mt76x02_sta, wcid);\n\t\tstatus.sta = container_of(priv, struct ieee80211_sta,\n\t\t\t\t\t  drv_priv);\n\t}\n\n\tmt76_tx_status_lock(mdev, &list);\n\n\tif (wcid) {\n\t\tif (mt76_is_skb_pktid(stat->pktid))\n\t\t\tstatus.skb = mt76_tx_status_skb_get(mdev, wcid,\n\t\t\t\t\t\t\t    stat->pktid, &list);\n\t\tif (status.skb)\n\t\t\tstatus.info = IEEE80211_SKB_CB(status.skb);\n\t}\n\n\tif (!status.skb && !(stat->pktid & MT_PACKET_ID_HAS_RATE)) {\n\t\tmt76_tx_status_unlock(mdev, &list);\n\t\tgoto out;\n\t}\n\n\n\tif (msta && stat->aggr && !status.skb) {\n\t\tu32 stat_val, stat_cache;\n\n\t\tstat_val = stat->rate;\n\t\tstat_val |= ((u32)stat->retry) << 16;\n\t\tstat_cache = msta->status.rate;\n\t\tstat_cache |= ((u32)msta->status.retry) << 16;\n\n\t\tif (*update == 0 && stat_val == stat_cache &&\n\t\t    stat->wcid == msta->status.wcid && msta->n_frames < 32) {\n\t\t\tmsta->n_frames++;\n\t\t\tmt76_tx_status_unlock(mdev, &list);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcur_pktid = msta->status.pktid;\n\t\tmt76x02_mac_fill_tx_status(dev, msta, status.info,\n\t\t\t\t\t   &msta->status, msta->n_frames);\n\n\t\tmsta->status = *stat;\n\t\tmsta->n_frames = 1;\n\t\t*update = 0;\n\t} else {\n\t\tcur_pktid = stat->pktid;\n\t\tmt76x02_mac_fill_tx_status(dev, msta, status.info, stat, 1);\n\t\t*update = 1;\n\t}\n\n\tif (status.skb) {\n\t\tinfo = *status.info;\n\t\tlen = status.skb->len;\n\t\tac = skb_get_queue_mapping(status.skb);\n\t\tmt76_tx_status_skb_done(mdev, status.skb, &list);\n\t} else if (msta) {\n\t\tlen = status.info->status.ampdu_len * ewma_pktlen_read(&msta->pktlen);\n\t\tac = FIELD_GET(MT_PKTID_AC, cur_pktid);\n\t}\n\n\tmt76_tx_status_unlock(mdev, &list);\n\n\tif (!status.skb) {\n\t\tspin_lock_bh(&dev->mt76.rx_lock);\n\t\tieee80211_tx_status_ext(mt76_hw(dev), &status);\n\t\tspin_unlock_bh(&dev->mt76.rx_lock);\n\t}\n\n\tif (!len)\n\t\tgoto out;\n\n\tduration = ieee80211_calc_tx_airtime(mt76_hw(dev), &info, len);\n\n\tspin_lock_bh(&dev->mt76.cc_lock);\n\tdev->tx_airtime += duration;\n\tspin_unlock_bh(&dev->mt76.cc_lock);\n\n\tif (msta)\n\t\tieee80211_sta_register_airtime(status.sta, ac_to_tid[ac], duration, 0);\n\nout:\n\trcu_read_unlock();\n}\n\nstatic int\nmt76x02_mac_process_rate(struct mt76x02_dev *dev,\n\t\t\t struct mt76_rx_status *status,\n\t\t\t u16 rate)\n{\n\tu8 idx = FIELD_GET(MT_RXWI_RATE_INDEX, rate);\n\n\tswitch (FIELD_GET(MT_RXWI_RATE_PHY, rate)) {\n\tcase MT_PHY_TYPE_OFDM:\n\t\tif (idx >= 8)\n\t\t\tidx = 0;\n\n\t\tif (status->band == NL80211_BAND_2GHZ)\n\t\t\tidx += 4;\n\n\t\tstatus->rate_idx = idx;\n\t\treturn 0;\n\tcase MT_PHY_TYPE_CCK:\n\t\tif (idx >= 8) {\n\t\t\tidx -= 8;\n\t\t\tstatus->enc_flags |= RX_ENC_FLAG_SHORTPRE;\n\t\t}\n\n\t\tif (idx >= 4)\n\t\t\tidx = 0;\n\n\t\tstatus->rate_idx = idx;\n\t\treturn 0;\n\tcase MT_PHY_TYPE_HT_GF:\n\t\tstatus->enc_flags |= RX_ENC_FLAG_HT_GF;\n\t\tfallthrough;\n\tcase MT_PHY_TYPE_HT:\n\t\tstatus->encoding = RX_ENC_HT;\n\t\tstatus->rate_idx = idx;\n\t\tbreak;\n\tcase MT_PHY_TYPE_VHT: {\n\t\tu8 n_rxstream = dev->mphy.chainmask & 0xf;\n\n\t\tstatus->encoding = RX_ENC_VHT;\n\t\tstatus->rate_idx = FIELD_GET(MT_RATE_INDEX_VHT_IDX, idx);\n\t\tstatus->nss = min_t(u8, n_rxstream,\n\t\t\t\t    FIELD_GET(MT_RATE_INDEX_VHT_NSS, idx) + 1);\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (rate & MT_RXWI_RATE_LDPC)\n\t\tstatus->enc_flags |= RX_ENC_FLAG_LDPC;\n\n\tif (rate & MT_RXWI_RATE_SGI)\n\t\tstatus->enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\n\tif (rate & MT_RXWI_RATE_STBC)\n\t\tstatus->enc_flags |= 1 << RX_ENC_FLAG_STBC_SHIFT;\n\n\tswitch (FIELD_GET(MT_RXWI_RATE_BW, rate)) {\n\tcase MT_PHY_BW_20:\n\t\tbreak;\n\tcase MT_PHY_BW_40:\n\t\tstatus->bw = RATE_INFO_BW_40;\n\t\tbreak;\n\tcase MT_PHY_BW_80:\n\t\tstatus->bw = RATE_INFO_BW_80;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nvoid mt76x02_mac_setaddr(struct mt76x02_dev *dev, const u8 *addr)\n{\n\tstatic const u8 null_addr[ETH_ALEN] = {};\n\tint i;\n\n\tether_addr_copy(dev->mphy.macaddr, addr);\n\n\tif (!is_valid_ether_addr(dev->mphy.macaddr)) {\n\t\teth_random_addr(dev->mphy.macaddr);\n\t\tdev_info(dev->mt76.dev,\n\t\t\t \"Invalid MAC address, using random address %pM\\n\",\n\t\t\t dev->mphy.macaddr);\n\t}\n\n\tmt76_wr(dev, MT_MAC_ADDR_DW0, get_unaligned_le32(dev->mphy.macaddr));\n\tmt76_wr(dev, MT_MAC_ADDR_DW1,\n\t\tget_unaligned_le16(dev->mphy.macaddr + 4) |\n\t\tFIELD_PREP(MT_MAC_ADDR_DW1_U2ME_MASK, 0xff));\n\n\tmt76_wr(dev, MT_MAC_BSSID_DW0,\n\t\tget_unaligned_le32(dev->mphy.macaddr));\n\tmt76_wr(dev, MT_MAC_BSSID_DW1,\n\t\tget_unaligned_le16(dev->mphy.macaddr + 4) |\n\t\tFIELD_PREP(MT_MAC_BSSID_DW1_MBSS_MODE, 3) |  \n\t\tMT_MAC_BSSID_DW1_MBSS_LOCAL_BIT);\n\t \n\tmt76_rmw_field(dev, MT_MAC_BSSID_DW1, MT_MAC_BSSID_DW1_MBEACON_N, 7);\n\n\tfor (i = 0; i < 16; i++)\n\t\tmt76x02_mac_set_bssid(dev, i, null_addr);\n}\nEXPORT_SYMBOL_GPL(mt76x02_mac_setaddr);\n\nstatic int\nmt76x02_mac_get_rssi(struct mt76x02_dev *dev, s8 rssi, int chain)\n{\n\tstruct mt76x02_rx_freq_cal *cal = &dev->cal.rx;\n\n\trssi += cal->rssi_offset[chain];\n\trssi -= cal->lna_gain;\n\n\treturn rssi;\n}\n\nint mt76x02_mac_process_rx(struct mt76x02_dev *dev, struct sk_buff *skb,\n\t\t\t   void *rxi)\n{\n\tstruct mt76_rx_status *status = (struct mt76_rx_status *)skb->cb;\n\tstruct ieee80211_hdr *hdr;\n\tstruct mt76x02_rxwi *rxwi = rxi;\n\tstruct mt76x02_sta *sta;\n\tu32 rxinfo = le32_to_cpu(rxwi->rxinfo);\n\tu32 ctl = le32_to_cpu(rxwi->ctl);\n\tu16 rate = le16_to_cpu(rxwi->rate);\n\tu16 tid_sn = le16_to_cpu(rxwi->tid_sn);\n\tbool unicast = rxwi->rxinfo & cpu_to_le32(MT_RXINFO_UNICAST);\n\tint pad_len = 0, nstreams = dev->mphy.chainmask & 0xf;\n\ts8 signal;\n\tu8 pn_len;\n\tu8 wcid;\n\tint len;\n\n\tif (!test_bit(MT76_STATE_RUNNING, &dev->mphy.state))\n\t\treturn -EINVAL;\n\n\tif (rxinfo & MT_RXINFO_L2PAD)\n\t\tpad_len += 2;\n\n\tif (rxinfo & MT_RXINFO_DECRYPT) {\n\t\tstatus->flag |= RX_FLAG_DECRYPTED;\n\t\tstatus->flag |= RX_FLAG_MMIC_STRIPPED;\n\t\tstatus->flag |= RX_FLAG_MIC_STRIPPED;\n\t\tstatus->flag |= RX_FLAG_IV_STRIPPED;\n\t}\n\n\twcid = FIELD_GET(MT_RXWI_CTL_WCID, ctl);\n\tsta = mt76x02_rx_get_sta(&dev->mt76, wcid);\n\tstatus->wcid = mt76x02_rx_get_sta_wcid(sta, unicast);\n\n\tlen = FIELD_GET(MT_RXWI_CTL_MPDU_LEN, ctl);\n\tpn_len = FIELD_GET(MT_RXINFO_PN_LEN, rxinfo);\n\tif (pn_len) {\n\t\tint offset = ieee80211_get_hdrlen_from_skb(skb) + pad_len;\n\t\tu8 *data = skb->data + offset;\n\n\t\tstatus->iv[0] = data[7];\n\t\tstatus->iv[1] = data[6];\n\t\tstatus->iv[2] = data[5];\n\t\tstatus->iv[3] = data[4];\n\t\tstatus->iv[4] = data[1];\n\t\tstatus->iv[5] = data[0];\n\n\t\t \n\t\tif (rxinfo & MT_RXINFO_FRAG) {\n\t\t\tstatus->flag &= ~RX_FLAG_IV_STRIPPED;\n\t\t} else {\n\t\t\tpad_len += pn_len << 2;\n\t\t\tlen -= pn_len << 2;\n\t\t}\n\t}\n\n\tmt76x02_remove_hdr_pad(skb, pad_len);\n\n\tif ((rxinfo & MT_RXINFO_BA) && !(rxinfo & MT_RXINFO_NULL))\n\t\tstatus->aggr = true;\n\n\tif (rxinfo & MT_RXINFO_AMPDU) {\n\t\tstatus->flag |= RX_FLAG_AMPDU_DETAILS;\n\t\tstatus->ampdu_ref = dev->ampdu_ref;\n\n\t\t \n\t\tif (rxinfo & MT_RXINFO_RSSI) {\n\t\t\tif (!++dev->ampdu_ref)\n\t\t\t\tdev->ampdu_ref++;\n\t\t}\n\t}\n\n\tif (WARN_ON_ONCE(len > skb->len))\n\t\treturn -EINVAL;\n\n\tif (pskb_trim(skb, len))\n\t\treturn -EINVAL;\n\n\tstatus->chains = BIT(0);\n\tsignal = mt76x02_mac_get_rssi(dev, rxwi->rssi[0], 0);\n\tstatus->chain_signal[0] = signal;\n\tif (nstreams > 1) {\n\t\tstatus->chains |= BIT(1);\n\t\tstatus->chain_signal[1] = mt76x02_mac_get_rssi(dev,\n\t\t\t\t\t\t\t       rxwi->rssi[1],\n\t\t\t\t\t\t\t       1);\n\t}\n\tstatus->freq = dev->mphy.chandef.chan->center_freq;\n\tstatus->band = dev->mphy.chandef.chan->band;\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\tstatus->qos_ctl = *ieee80211_get_qos_ctl(hdr);\n\tstatus->seqno = FIELD_GET(MT_RXWI_SN, tid_sn);\n\n\treturn mt76x02_mac_process_rate(dev, status, rate);\n}\n\nvoid mt76x02_mac_poll_tx_status(struct mt76x02_dev *dev, bool irq)\n{\n\tstruct mt76x02_tx_status stat = {};\n\tu8 update = 1;\n\tbool ret;\n\n\tif (!test_bit(MT76_STATE_RUNNING, &dev->mphy.state))\n\t\treturn;\n\n\ttrace_mac_txstat_poll(dev);\n\n\twhile (!irq || !kfifo_is_full(&dev->txstatus_fifo)) {\n\t\tif (!spin_trylock(&dev->txstatus_fifo_lock))\n\t\t\tbreak;\n\n\t\tret = mt76x02_mac_load_tx_status(dev, &stat);\n\t\tspin_unlock(&dev->txstatus_fifo_lock);\n\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tif (!irq) {\n\t\t\tmt76x02_send_tx_status(dev, &stat, &update);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkfifo_put(&dev->txstatus_fifo, stat);\n\t}\n}\n\nvoid mt76x02_tx_complete_skb(struct mt76_dev *mdev, struct mt76_queue_entry *e)\n{\n\tstruct mt76x02_dev *dev = container_of(mdev, struct mt76x02_dev, mt76);\n\tstruct mt76x02_txwi *txwi;\n\tu8 *txwi_ptr;\n\n\tif (!e->txwi) {\n\t\tdev_kfree_skb_any(e->skb);\n\t\treturn;\n\t}\n\n\tmt76x02_mac_poll_tx_status(dev, false);\n\n\ttxwi_ptr = mt76_get_txwi_ptr(mdev, e->txwi);\n\ttxwi = (struct mt76x02_txwi *)txwi_ptr;\n\ttrace_mac_txdone(mdev, txwi->wcid, txwi->pktid);\n\n\tmt76_tx_complete_skb(mdev, e->wcid, e->skb);\n}\nEXPORT_SYMBOL_GPL(mt76x02_tx_complete_skb);\n\nvoid mt76x02_mac_set_rts_thresh(struct mt76x02_dev *dev, u32 val)\n{\n\tu32 data = 0;\n\n\tif (val != ~0)\n\t\tdata = FIELD_PREP(MT_PROT_CFG_CTRL, 1) |\n\t\t       MT_PROT_CFG_RTS_THRESH;\n\n\tmt76_rmw_field(dev, MT_TX_RTS_CFG, MT_TX_RTS_CFG_THRESH, val);\n\n\tmt76_rmw(dev, MT_CCK_PROT_CFG,\n\t\t MT_PROT_CFG_CTRL | MT_PROT_CFG_RTS_THRESH, data);\n\tmt76_rmw(dev, MT_OFDM_PROT_CFG,\n\t\t MT_PROT_CFG_CTRL | MT_PROT_CFG_RTS_THRESH, data);\n}\n\nvoid mt76x02_mac_set_tx_protection(struct mt76x02_dev *dev, bool legacy_prot,\n\t\t\t\t   int ht_mode)\n{\n\tint mode = ht_mode & IEEE80211_HT_OP_MODE_PROTECTION;\n\tbool non_gf = !!(ht_mode & IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\n\tu32 prot[6];\n\tu32 vht_prot[3];\n\tint i;\n\tu16 rts_thr;\n\n\tfor (i = 0; i < ARRAY_SIZE(prot); i++) {\n\t\tprot[i] = mt76_rr(dev, MT_CCK_PROT_CFG + i * 4);\n\t\tprot[i] &= ~MT_PROT_CFG_CTRL;\n\t\tif (i >= 2)\n\t\t\tprot[i] &= ~MT_PROT_CFG_RATE;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(vht_prot); i++) {\n\t\tvht_prot[i] = mt76_rr(dev, MT_TX_PROT_CFG6 + i * 4);\n\t\tvht_prot[i] &= ~(MT_PROT_CFG_CTRL | MT_PROT_CFG_RATE);\n\t}\n\n\trts_thr = mt76_get_field(dev, MT_TX_RTS_CFG, MT_TX_RTS_CFG_THRESH);\n\n\tif (rts_thr != 0xffff)\n\t\tprot[0] |= MT_PROT_CTRL_RTS_CTS;\n\n\tif (legacy_prot) {\n\t\tprot[1] |= MT_PROT_CTRL_CTS2SELF;\n\n\t\tprot[2] |= MT_PROT_RATE_CCK_11;\n\t\tprot[3] |= MT_PROT_RATE_CCK_11;\n\t\tprot[4] |= MT_PROT_RATE_CCK_11;\n\t\tprot[5] |= MT_PROT_RATE_CCK_11;\n\n\t\tvht_prot[0] |= MT_PROT_RATE_CCK_11;\n\t\tvht_prot[1] |= MT_PROT_RATE_CCK_11;\n\t\tvht_prot[2] |= MT_PROT_RATE_CCK_11;\n\t} else {\n\t\tif (rts_thr != 0xffff)\n\t\t\tprot[1] |= MT_PROT_CTRL_RTS_CTS;\n\n\t\tprot[2] |= MT_PROT_RATE_OFDM_24;\n\t\tprot[3] |= MT_PROT_RATE_DUP_OFDM_24;\n\t\tprot[4] |= MT_PROT_RATE_OFDM_24;\n\t\tprot[5] |= MT_PROT_RATE_DUP_OFDM_24;\n\n\t\tvht_prot[0] |= MT_PROT_RATE_OFDM_24;\n\t\tvht_prot[1] |= MT_PROT_RATE_DUP_OFDM_24;\n\t\tvht_prot[2] |= MT_PROT_RATE_SGI_OFDM_24;\n\t}\n\n\tswitch (mode) {\n\tcase IEEE80211_HT_OP_MODE_PROTECTION_NONMEMBER:\n\tcase IEEE80211_HT_OP_MODE_PROTECTION_NONHT_MIXED:\n\t\tprot[2] |= MT_PROT_CTRL_RTS_CTS;\n\t\tprot[3] |= MT_PROT_CTRL_RTS_CTS;\n\t\tprot[4] |= MT_PROT_CTRL_RTS_CTS;\n\t\tprot[5] |= MT_PROT_CTRL_RTS_CTS;\n\t\tvht_prot[0] |= MT_PROT_CTRL_RTS_CTS;\n\t\tvht_prot[1] |= MT_PROT_CTRL_RTS_CTS;\n\t\tvht_prot[2] |= MT_PROT_CTRL_RTS_CTS;\n\t\tbreak;\n\tcase IEEE80211_HT_OP_MODE_PROTECTION_20MHZ:\n\t\tprot[3] |= MT_PROT_CTRL_RTS_CTS;\n\t\tprot[5] |= MT_PROT_CTRL_RTS_CTS;\n\t\tvht_prot[1] |= MT_PROT_CTRL_RTS_CTS;\n\t\tvht_prot[2] |= MT_PROT_CTRL_RTS_CTS;\n\t\tbreak;\n\t}\n\n\tif (non_gf) {\n\t\tprot[4] |= MT_PROT_CTRL_RTS_CTS;\n\t\tprot[5] |= MT_PROT_CTRL_RTS_CTS;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(prot); i++)\n\t\tmt76_wr(dev, MT_CCK_PROT_CFG + i * 4, prot[i]);\n\n\tfor (i = 0; i < ARRAY_SIZE(vht_prot); i++)\n\t\tmt76_wr(dev, MT_TX_PROT_CFG6 + i * 4, vht_prot[i]);\n}\n\nvoid mt76x02_update_channel(struct mt76_phy *mphy)\n{\n\tstruct mt76x02_dev *dev = container_of(mphy->dev, struct mt76x02_dev, mt76);\n\tstruct mt76_channel_state *state;\n\n\tstate = mphy->chan_state;\n\tstate->cc_busy += mt76_rr(dev, MT_CH_BUSY);\n\n\tspin_lock_bh(&dev->mt76.cc_lock);\n\tstate->cc_tx += dev->tx_airtime;\n\tdev->tx_airtime = 0;\n\tspin_unlock_bh(&dev->mt76.cc_lock);\n}\nEXPORT_SYMBOL_GPL(mt76x02_update_channel);\n\nstatic void mt76x02_check_mac_err(struct mt76x02_dev *dev)\n{\n\tif (dev->mt76.beacon_mask) {\n\t\tif (mt76_rr(dev, MT_TX_STA_0) & MT_TX_STA_0_BEACONS) {\n\t\t\tdev->beacon_hang_check = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tif (dev->beacon_hang_check < 10)\n\t\t\treturn;\n\n\t} else {\n\t\tu32 val = mt76_rr(dev, 0x10f4);\n\t\tif (!(val & BIT(29)) || !(val & (BIT(7) | BIT(5))))\n\t\t\treturn;\n\t}\n\n\tdev_err(dev->mt76.dev, \"MAC error detected\\n\");\n\n\tmt76_wr(dev, MT_MAC_SYS_CTRL, 0);\n\tif (!mt76x02_wait_for_txrx_idle(&dev->mt76)) {\n\t\tdev_err(dev->mt76.dev, \"MAC stop failed\\n\");\n\t\tgoto out;\n\t}\n\n\tdev->beacon_hang_check = 0;\n\tmt76_set(dev, MT_MAC_SYS_CTRL, MT_MAC_SYS_CTRL_RESET_CSR);\n\tudelay(10);\n\nout:\n\tmt76_wr(dev, MT_MAC_SYS_CTRL,\n\t\tMT_MAC_SYS_CTRL_ENABLE_TX | MT_MAC_SYS_CTRL_ENABLE_RX);\n}\n\nstatic void\nmt76x02_edcca_tx_enable(struct mt76x02_dev *dev, bool enable)\n{\n\tif (enable) {\n\t\tu32 data;\n\n\t\tmt76_set(dev, MT_MAC_SYS_CTRL, MT_MAC_SYS_CTRL_ENABLE_TX);\n\t\tmt76_set(dev, MT_AUTO_RSP_CFG, MT_AUTO_RSP_EN);\n\t\t \n\t\tdata = mt76_rr(dev, MT_TX_PIN_CFG);\n\t\tdata |= MT_TX_PIN_CFG_TXANT |\n\t\t\tMT_TX_PIN_CFG_RXANT |\n\t\t\tMT_TX_PIN_RFTR_EN |\n\t\t\tMT_TX_PIN_TRSW_EN;\n\t\tmt76_wr(dev, MT_TX_PIN_CFG, data);\n\t} else {\n\t\tmt76_clear(dev, MT_MAC_SYS_CTRL, MT_MAC_SYS_CTRL_ENABLE_TX);\n\t\tmt76_clear(dev, MT_AUTO_RSP_CFG, MT_AUTO_RSP_EN);\n\t\t \n\t\tmt76_clear(dev, MT_TX_PIN_CFG, MT_TX_PIN_CFG_TXANT);\n\t\tmt76_clear(dev, MT_TX_PIN_CFG, MT_TX_PIN_CFG_RXANT);\n\t}\n\tdev->ed_tx_blocked = !enable;\n}\n\nvoid mt76x02_edcca_init(struct mt76x02_dev *dev)\n{\n\tdev->ed_trigger = 0;\n\tdev->ed_silent = 0;\n\n\tif (dev->ed_monitor) {\n\t\tstruct ieee80211_channel *chan = dev->mphy.chandef.chan;\n\t\tu8 ed_th = chan->band == NL80211_BAND_5GHZ ? 0x0e : 0x20;\n\n\t\tmt76_clear(dev, MT_TX_LINK_CFG, MT_TX_CFACK_EN);\n\t\tmt76_set(dev, MT_TXOP_CTRL_CFG, MT_TXOP_ED_CCA_EN);\n\t\tmt76_rmw(dev, MT_BBP(AGC, 2), GENMASK(15, 0),\n\t\t\t ed_th << 8 | ed_th);\n\t\tmt76_set(dev, MT_TXOP_HLDR_ET, MT_TXOP_HLDR_TX40M_BLK_EN);\n\t} else {\n\t\tmt76_set(dev, MT_TX_LINK_CFG, MT_TX_CFACK_EN);\n\t\tmt76_clear(dev, MT_TXOP_CTRL_CFG, MT_TXOP_ED_CCA_EN);\n\t\tif (is_mt76x2(dev)) {\n\t\t\tmt76_wr(dev, MT_BBP(AGC, 2), 0x00007070);\n\t\t\tmt76_set(dev, MT_TXOP_HLDR_ET,\n\t\t\t\t MT_TXOP_HLDR_TX40M_BLK_EN);\n\t\t} else {\n\t\t\tmt76_wr(dev, MT_BBP(AGC, 2), 0x003a6464);\n\t\t\tmt76_clear(dev, MT_TXOP_HLDR_ET,\n\t\t\t\t   MT_TXOP_HLDR_TX40M_BLK_EN);\n\t\t}\n\t}\n\tmt76x02_edcca_tx_enable(dev, true);\n\tdev->ed_monitor_learning = true;\n\n\t \n\tmt76_rr(dev, MT_ED_CCA_TIMER);\n\tdev->ed_time = ktime_get_boottime();\n}\nEXPORT_SYMBOL_GPL(mt76x02_edcca_init);\n\n#define MT_EDCCA_TH\t\t92\n#define MT_EDCCA_BLOCK_TH\t2\n#define MT_EDCCA_LEARN_TH\t50\n#define MT_EDCCA_LEARN_CCA\t180\n#define MT_EDCCA_LEARN_TIMEOUT\t(20 * HZ)\n\nstatic void mt76x02_edcca_check(struct mt76x02_dev *dev)\n{\n\tktime_t cur_time;\n\tu32 active, val, busy;\n\n\tcur_time = ktime_get_boottime();\n\tval = mt76_rr(dev, MT_ED_CCA_TIMER);\n\n\tactive = ktime_to_us(ktime_sub(cur_time, dev->ed_time));\n\tdev->ed_time = cur_time;\n\n\tbusy = (val * 100) / active;\n\tbusy = min_t(u32, busy, 100);\n\n\tif (busy > MT_EDCCA_TH) {\n\t\tdev->ed_trigger++;\n\t\tdev->ed_silent = 0;\n\t} else {\n\t\tdev->ed_silent++;\n\t\tdev->ed_trigger = 0;\n\t}\n\n\tif (dev->cal.agc_lowest_gain &&\n\t    dev->cal.false_cca > MT_EDCCA_LEARN_CCA &&\n\t    dev->ed_trigger > MT_EDCCA_LEARN_TH) {\n\t\tdev->ed_monitor_learning = false;\n\t\tdev->ed_trigger_timeout = jiffies + 20 * HZ;\n\t} else if (!dev->ed_monitor_learning &&\n\t\t   time_is_after_jiffies(dev->ed_trigger_timeout)) {\n\t\tdev->ed_monitor_learning = true;\n\t\tmt76x02_edcca_tx_enable(dev, true);\n\t}\n\n\tif (dev->ed_monitor_learning)\n\t\treturn;\n\n\tif (dev->ed_trigger > MT_EDCCA_BLOCK_TH && !dev->ed_tx_blocked)\n\t\tmt76x02_edcca_tx_enable(dev, false);\n\telse if (dev->ed_silent > MT_EDCCA_BLOCK_TH && dev->ed_tx_blocked)\n\t\tmt76x02_edcca_tx_enable(dev, true);\n}\n\nvoid mt76x02_mac_work(struct work_struct *work)\n{\n\tstruct mt76x02_dev *dev = container_of(work, struct mt76x02_dev,\n\t\t\t\t\t       mphy.mac_work.work);\n\tint i, idx;\n\n\tmutex_lock(&dev->mt76.mutex);\n\n\tmt76_update_survey(&dev->mphy);\n\tfor (i = 0, idx = 0; i < 16; i++) {\n\t\tu32 val = mt76_rr(dev, MT_TX_AGG_CNT(i));\n\n\t\tdev->mphy.aggr_stats[idx++] += val & 0xffff;\n\t\tdev->mphy.aggr_stats[idx++] += val >> 16;\n\t}\n\n\tmt76x02_check_mac_err(dev);\n\n\tif (dev->ed_monitor)\n\t\tmt76x02_edcca_check(dev);\n\n\tmutex_unlock(&dev->mt76.mutex);\n\n\tmt76_tx_status_check(&dev->mt76, false);\n\n\tieee80211_queue_delayed_work(mt76_hw(dev), &dev->mphy.mac_work,\n\t\t\t\t     MT_MAC_WORK_INTERVAL);\n}\n\nvoid mt76x02_mac_cc_reset(struct mt76x02_dev *dev)\n{\n\tdev->mphy.survey_time = ktime_get_boottime();\n\n\tmt76_wr(dev, MT_CH_TIME_CFG,\n\t\tMT_CH_TIME_CFG_TIMER_EN |\n\t\tMT_CH_TIME_CFG_TX_AS_BUSY |\n\t\tMT_CH_TIME_CFG_RX_AS_BUSY |\n\t\tMT_CH_TIME_CFG_NAV_AS_BUSY |\n\t\tMT_CH_TIME_CFG_EIFS_AS_BUSY |\n\t\tMT_CH_CCA_RC_EN |\n\t\tFIELD_PREP(MT_CH_TIME_CFG_CH_TIMER_CLR, 1));\n\n\t \n\tmt76_rr(dev, MT_CH_BUSY);\n\tmt76_rr(dev, MT_CH_IDLE);\n}\nEXPORT_SYMBOL_GPL(mt76x02_mac_cc_reset);\n\nvoid mt76x02_mac_set_bssid(struct mt76x02_dev *dev, u8 idx, const u8 *addr)\n{\n\tidx &= 7;\n\tmt76_wr(dev, MT_MAC_APC_BSSID_L(idx), get_unaligned_le32(addr));\n\tmt76_rmw_field(dev, MT_MAC_APC_BSSID_H(idx), MT_MAC_APC_BSSID_H_ADDR,\n\t\t       get_unaligned_le16(addr + 4));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}