{
  "module_name": "mt76x02_txrx.c",
  "hash_id": "6aafef2438b14e8d57506471a1d2668673f4094d43e8e9984b912aa22dd5a283",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt76x02_txrx.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n\n#include \"mt76x02.h\"\n\nvoid mt76x02_tx(struct ieee80211_hw *hw, struct ieee80211_tx_control *control,\n\t\tstruct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct mt76x02_dev *dev = hw->priv;\n\tstruct ieee80211_vif *vif = info->control.vif;\n\tstruct mt76_wcid *wcid = &dev->mt76.global_wcid;\n\n\tif (control->sta) {\n\t\tstruct mt76x02_sta *msta;\n\n\t\tmsta = (struct mt76x02_sta *)control->sta->drv_priv;\n\t\twcid = &msta->wcid;\n\t} else if (vif) {\n\t\tstruct mt76x02_vif *mvif;\n\n\t\tmvif = (struct mt76x02_vif *)vif->drv_priv;\n\t\twcid = &mvif->group_wcid;\n\t}\n\n\tmt76_tx(&dev->mphy, control->sta, wcid, skb);\n}\nEXPORT_SYMBOL_GPL(mt76x02_tx);\n\nvoid mt76x02_queue_rx_skb(struct mt76_dev *mdev, enum mt76_rxq_id q,\n\t\t\t  struct sk_buff *skb, u32 *info)\n{\n\tstruct mt76x02_dev *dev = container_of(mdev, struct mt76x02_dev, mt76);\n\tvoid *rxwi = skb->data;\n\n\tif (q == MT_RXQ_MCU) {\n\t\tmt76_mcu_rx_event(&dev->mt76, skb);\n\t\treturn;\n\t}\n\n\tskb_pull(skb, sizeof(struct mt76x02_rxwi));\n\tif (mt76x02_mac_process_rx(dev, skb, rxwi)) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n\tmt76_rx(mdev, q, skb);\n}\nEXPORT_SYMBOL_GPL(mt76x02_queue_rx_skb);\n\ns8 mt76x02_tx_get_max_txpwr_adj(struct mt76x02_dev *dev,\n\t\t\t\tconst struct ieee80211_tx_rate *rate)\n{\n\ts8 max_txpwr;\n\n\tif (rate->flags & IEEE80211_TX_RC_VHT_MCS) {\n\t\tu8 mcs = ieee80211_rate_get_vht_mcs(rate);\n\n\t\tif (mcs == 8 || mcs == 9) {\n\t\t\tmax_txpwr = dev->rate_power.vht[0];\n\t\t} else {\n\t\t\tu8 nss, idx;\n\n\t\t\tnss = ieee80211_rate_get_vht_nss(rate);\n\t\t\tidx = ((nss - 1) << 3) + mcs;\n\t\t\tmax_txpwr = dev->rate_power.ht[idx & 0xf];\n\t\t}\n\t} else if (rate->flags & IEEE80211_TX_RC_MCS) {\n\t\tmax_txpwr = dev->rate_power.ht[rate->idx & 0xf];\n\t} else {\n\t\tenum nl80211_band band = dev->mphy.chandef.chan->band;\n\n\t\tif (band == NL80211_BAND_2GHZ) {\n\t\t\tconst struct ieee80211_rate *r;\n\t\t\tstruct wiphy *wiphy = dev->mt76.hw->wiphy;\n\t\t\tstruct mt76x02_rate_power *rp = &dev->rate_power;\n\n\t\t\tr = &wiphy->bands[band]->bitrates[rate->idx];\n\t\t\tif (r->flags & IEEE80211_RATE_SHORT_PREAMBLE)\n\t\t\t\tmax_txpwr = rp->cck[r->hw_value & 0x3];\n\t\t\telse\n\t\t\t\tmax_txpwr = rp->ofdm[r->hw_value & 0x7];\n\t\t} else {\n\t\t\tmax_txpwr = dev->rate_power.ofdm[rate->idx & 0x7];\n\t\t}\n\t}\n\n\treturn max_txpwr;\n}\n\ns8 mt76x02_tx_get_txpwr_adj(struct mt76x02_dev *dev, s8 txpwr, s8 max_txpwr_adj)\n{\n\ttxpwr = min_t(s8, txpwr, dev->txpower_conf);\n\ttxpwr -= (dev->target_power + dev->target_power_delta[0]);\n\ttxpwr = min_t(s8, txpwr, max_txpwr_adj);\n\n\tif (!dev->enable_tpc)\n\t\treturn 0;\n\telse if (txpwr >= 0)\n\t\treturn min_t(s8, txpwr, 7);\n\telse\n\t\treturn (txpwr < -16) ? 8 : (txpwr + 32) / 2;\n}\n\nvoid mt76x02_tx_set_txpwr_auto(struct mt76x02_dev *dev, s8 txpwr)\n{\n\ts8 txpwr_adj;\n\n\ttxpwr_adj = mt76x02_tx_get_txpwr_adj(dev, txpwr,\n\t\t\t\t\t     dev->rate_power.ofdm[4]);\n\tmt76_rmw_field(dev, MT_PROT_AUTO_TX_CFG,\n\t\t       MT_PROT_AUTO_TX_CFG_PROT_PADJ, txpwr_adj);\n\tmt76_rmw_field(dev, MT_PROT_AUTO_TX_CFG,\n\t\t       MT_PROT_AUTO_TX_CFG_AUTO_PADJ, txpwr_adj);\n}\nEXPORT_SYMBOL_GPL(mt76x02_tx_set_txpwr_auto);\n\nbool mt76x02_tx_status_data(struct mt76_dev *mdev, u8 *update)\n{\n\tstruct mt76x02_dev *dev = container_of(mdev, struct mt76x02_dev, mt76);\n\tstruct mt76x02_tx_status stat;\n\n\tif (!mt76x02_mac_load_tx_status(dev, &stat))\n\t\treturn false;\n\n\tmt76x02_send_tx_status(dev, &stat, update);\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(mt76x02_tx_status_data);\n\nint mt76x02_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,\n\t\t\t   enum mt76_txq_id qid, struct mt76_wcid *wcid,\n\t\t\t   struct ieee80211_sta *sta,\n\t\t\t   struct mt76_tx_info *tx_info)\n{\n\tstruct mt76x02_dev *dev = container_of(mdev, struct mt76x02_dev, mt76);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx_info->skb->data;\n\tstruct mt76x02_txwi *txwi = txwi_ptr;\n\tbool ampdu = IEEE80211_SKB_CB(tx_info->skb)->flags & IEEE80211_TX_CTL_AMPDU;\n\tint hdrlen, len, pid, qsel = MT_QSEL_EDCA;\n\n\tif (qid == MT_TXQ_PSD && wcid && wcid->idx < 128)\n\t\tmt76x02_mac_wcid_set_drop(dev, wcid->idx, false);\n\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\tlen = tx_info->skb->len - (hdrlen & 2);\n\tmt76x02_mac_write_txwi(dev, txwi, tx_info->skb, wcid, sta, len);\n\n\tpid = mt76_tx_status_skb_add(mdev, wcid, tx_info->skb);\n\n\t \n\tif (pid == MT_PACKET_ID_NO_SKB)\n\t\tpid = MT_PACKET_ID_HAS_RATE |\n\t\t      (le16_to_cpu(txwi->rate) & MT_RXWI_RATE_INDEX) |\n\t\t      FIELD_PREP(MT_PKTID_AC,\n\t\t\t\t skb_get_queue_mapping(tx_info->skb));\n\n\ttxwi->pktid = pid;\n\n\tif (mt76_is_skb_pktid(pid) && ampdu)\n\t\tqsel = MT_QSEL_MGMT;\n\n\ttx_info->info = FIELD_PREP(MT_TXD_INFO_QSEL, qsel) |\n\t\t\tMT_TXD_INFO_80211;\n\n\tif (!wcid || wcid->hw_key_idx == 0xff || wcid->sw_iv)\n\t\ttx_info->info |= MT_TXD_INFO_WIV;\n\n\tif (sta) {\n\t\tstruct mt76x02_sta *msta = (struct mt76x02_sta *)sta->drv_priv;\n\n\t\tewma_pktlen_add(&msta->pktlen, tx_info->skb->len);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76x02_tx_prepare_skb);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}