{
  "module_name": "agg-rx.c",
  "hash_id": "40271a456952f36339c2b73bb55d0ad4ef4e3652c033dcdd637cfbbf67929990",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/agg-rx.c",
  "human_readable_source": "\n \n#include \"mt76.h\"\n\nstatic unsigned long mt76_aggr_tid_to_timeo(u8 tidno)\n{\n\t \n\treturn HZ / (tidno >= 4 ? 25 : 10);\n}\n\nstatic void\nmt76_aggr_release(struct mt76_rx_tid *tid, struct sk_buff_head *frames, int idx)\n{\n\tstruct sk_buff *skb;\n\n\ttid->head = ieee80211_sn_inc(tid->head);\n\n\tskb = tid->reorder_buf[idx];\n\tif (!skb)\n\t\treturn;\n\n\ttid->reorder_buf[idx] = NULL;\n\ttid->nframes--;\n\t__skb_queue_tail(frames, skb);\n}\n\nstatic void\nmt76_rx_aggr_release_frames(struct mt76_rx_tid *tid,\n\t\t\t    struct sk_buff_head *frames,\n\t\t\t    u16 head)\n{\n\tint idx;\n\n\twhile (ieee80211_sn_less(tid->head, head)) {\n\t\tidx = tid->head % tid->size;\n\t\tmt76_aggr_release(tid, frames, idx);\n\t}\n}\n\nstatic void\nmt76_rx_aggr_release_head(struct mt76_rx_tid *tid, struct sk_buff_head *frames)\n{\n\tint idx = tid->head % tid->size;\n\n\twhile (tid->reorder_buf[idx]) {\n\t\tmt76_aggr_release(tid, frames, idx);\n\t\tidx = tid->head % tid->size;\n\t}\n}\n\nstatic void\nmt76_rx_aggr_check_release(struct mt76_rx_tid *tid, struct sk_buff_head *frames)\n{\n\tstruct mt76_rx_status *status;\n\tstruct sk_buff *skb;\n\tint start, idx, nframes;\n\n\tif (!tid->nframes)\n\t\treturn;\n\n\tmt76_rx_aggr_release_head(tid, frames);\n\n\tstart = tid->head % tid->size;\n\tnframes = tid->nframes;\n\n\tfor (idx = (tid->head + 1) % tid->size;\n\t     idx != start && nframes;\n\t     idx = (idx + 1) % tid->size) {\n\t\tskb = tid->reorder_buf[idx];\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\tnframes--;\n\t\tstatus = (struct mt76_rx_status *)skb->cb;\n\t\tif (!time_after32(jiffies,\n\t\t\t\t  status->reorder_time +\n\t\t\t\t  mt76_aggr_tid_to_timeo(tid->num)))\n\t\t\tcontinue;\n\n\t\tmt76_rx_aggr_release_frames(tid, frames, status->seqno);\n\t}\n\n\tmt76_rx_aggr_release_head(tid, frames);\n}\n\nstatic void\nmt76_rx_aggr_reorder_work(struct work_struct *work)\n{\n\tstruct mt76_rx_tid *tid = container_of(work, struct mt76_rx_tid,\n\t\t\t\t\t       reorder_work.work);\n\tstruct mt76_dev *dev = tid->dev;\n\tstruct sk_buff_head frames;\n\tint nframes;\n\n\t__skb_queue_head_init(&frames);\n\n\tlocal_bh_disable();\n\trcu_read_lock();\n\n\tspin_lock(&tid->lock);\n\tmt76_rx_aggr_check_release(tid, &frames);\n\tnframes = tid->nframes;\n\tspin_unlock(&tid->lock);\n\n\tif (nframes)\n\t\tieee80211_queue_delayed_work(tid->dev->hw, &tid->reorder_work,\n\t\t\t\t\t     mt76_aggr_tid_to_timeo(tid->num));\n\tmt76_rx_complete(dev, &frames, NULL);\n\n\trcu_read_unlock();\n\tlocal_bh_enable();\n}\n\nstatic void\nmt76_rx_aggr_check_ctl(struct sk_buff *skb, struct sk_buff_head *frames)\n{\n\tstruct mt76_rx_status *status = (struct mt76_rx_status *)skb->cb;\n\tstruct ieee80211_bar *bar = mt76_skb_get_hdr(skb);\n\tstruct mt76_wcid *wcid = status->wcid;\n\tstruct mt76_rx_tid *tid;\n\tu8 tidno = status->qos_ctl & IEEE80211_QOS_CTL_TID_MASK;\n\tu16 seqno;\n\n\tif (!ieee80211_is_ctl(bar->frame_control))\n\t\treturn;\n\n\tif (!ieee80211_is_back_req(bar->frame_control))\n\t\treturn;\n\n\tstatus->qos_ctl = tidno = le16_to_cpu(bar->control) >> 12;\n\tseqno = IEEE80211_SEQ_TO_SN(le16_to_cpu(bar->start_seq_num));\n\ttid = rcu_dereference(wcid->aggr[tidno]);\n\tif (!tid)\n\t\treturn;\n\n\tspin_lock_bh(&tid->lock);\n\tif (!tid->stopped) {\n\t\tmt76_rx_aggr_release_frames(tid, frames, seqno);\n\t\tmt76_rx_aggr_release_head(tid, frames);\n\t}\n\tspin_unlock_bh(&tid->lock);\n}\n\nvoid mt76_rx_aggr_reorder(struct sk_buff *skb, struct sk_buff_head *frames)\n{\n\tstruct mt76_rx_status *status = (struct mt76_rx_status *)skb->cb;\n\tstruct mt76_wcid *wcid = status->wcid;\n\tstruct ieee80211_sta *sta;\n\tstruct mt76_rx_tid *tid;\n\tbool sn_less;\n\tu16 seqno, head, size, idx;\n\tu8 tidno = status->qos_ctl & IEEE80211_QOS_CTL_TID_MASK;\n\tu8 ackp;\n\n\t__skb_queue_tail(frames, skb);\n\n\tsta = wcid_to_sta(wcid);\n\tif (!sta)\n\t\treturn;\n\n\tif (!status->aggr) {\n\t\tif (!(status->flag & RX_FLAG_8023))\n\t\t\tmt76_rx_aggr_check_ctl(skb, frames);\n\t\treturn;\n\t}\n\n\t \n\tackp = status->qos_ctl & IEEE80211_QOS_CTL_ACK_POLICY_MASK;\n\tif (ackp == IEEE80211_QOS_CTL_ACK_POLICY_NOACK)\n\t\treturn;\n\n\ttid = rcu_dereference(wcid->aggr[tidno]);\n\tif (!tid)\n\t\treturn;\n\n\tstatus->flag |= RX_FLAG_DUP_VALIDATED;\n\tspin_lock_bh(&tid->lock);\n\n\tif (tid->stopped)\n\t\tgoto out;\n\n\thead = tid->head;\n\tseqno = status->seqno;\n\tsize = tid->size;\n\tsn_less = ieee80211_sn_less(seqno, head);\n\n\tif (!tid->started) {\n\t\tif (sn_less)\n\t\t\tgoto out;\n\n\t\ttid->started = true;\n\t}\n\n\tif (sn_less) {\n\t\t__skb_unlink(skb, frames);\n\t\tdev_kfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tif (seqno == head) {\n\t\ttid->head = ieee80211_sn_inc(head);\n\t\tif (tid->nframes)\n\t\t\tmt76_rx_aggr_release_head(tid, frames);\n\t\tgoto out;\n\t}\n\n\t__skb_unlink(skb, frames);\n\n\t \n\tif (!ieee80211_sn_less(seqno, head + size)) {\n\t\thead = ieee80211_sn_inc(ieee80211_sn_sub(seqno, size));\n\t\tmt76_rx_aggr_release_frames(tid, frames, head);\n\t}\n\n\tidx = seqno % size;\n\n\t \n\tif (tid->reorder_buf[idx]) {\n\t\tdev_kfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tstatus->reorder_time = jiffies;\n\ttid->reorder_buf[idx] = skb;\n\ttid->nframes++;\n\tmt76_rx_aggr_release_head(tid, frames);\n\n\tieee80211_queue_delayed_work(tid->dev->hw, &tid->reorder_work,\n\t\t\t\t     mt76_aggr_tid_to_timeo(tid->num));\n\nout:\n\tspin_unlock_bh(&tid->lock);\n}\n\nint mt76_rx_aggr_start(struct mt76_dev *dev, struct mt76_wcid *wcid, u8 tidno,\n\t\t       u16 ssn, u16 size)\n{\n\tstruct mt76_rx_tid *tid;\n\n\tmt76_rx_aggr_stop(dev, wcid, tidno);\n\n\ttid = kzalloc(struct_size(tid, reorder_buf, size), GFP_KERNEL);\n\tif (!tid)\n\t\treturn -ENOMEM;\n\n\ttid->dev = dev;\n\ttid->head = ssn;\n\ttid->size = size;\n\ttid->num = tidno;\n\tINIT_DELAYED_WORK(&tid->reorder_work, mt76_rx_aggr_reorder_work);\n\tspin_lock_init(&tid->lock);\n\n\trcu_assign_pointer(wcid->aggr[tidno], tid);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76_rx_aggr_start);\n\nstatic void mt76_rx_aggr_shutdown(struct mt76_dev *dev, struct mt76_rx_tid *tid)\n{\n\tu16 size = tid->size;\n\tint i;\n\n\tspin_lock_bh(&tid->lock);\n\n\ttid->stopped = true;\n\tfor (i = 0; tid->nframes && i < size; i++) {\n\t\tstruct sk_buff *skb = tid->reorder_buf[i];\n\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\ttid->reorder_buf[i] = NULL;\n\t\ttid->nframes--;\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tspin_unlock_bh(&tid->lock);\n\n\tcancel_delayed_work_sync(&tid->reorder_work);\n}\n\nvoid mt76_rx_aggr_stop(struct mt76_dev *dev, struct mt76_wcid *wcid, u8 tidno)\n{\n\tstruct mt76_rx_tid *tid = NULL;\n\n\ttid = rcu_replace_pointer(wcid->aggr[tidno], tid,\n\t\t\t\t  lockdep_is_held(&dev->mutex));\n\tif (tid) {\n\t\tmt76_rx_aggr_shutdown(dev, tid);\n\t\tkfree_rcu(tid, rcu_head);\n\t}\n}\nEXPORT_SYMBOL_GPL(mt76_rx_aggr_stop);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}