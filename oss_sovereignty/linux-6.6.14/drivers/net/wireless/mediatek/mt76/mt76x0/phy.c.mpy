{
  "module_name": "phy.c",
  "hash_id": "f341880805e5a130ca009cc7c05499efa008f666e3cc6184a83a5ee741b0c9a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt76x0/phy.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/etherdevice.h>\n\n#include \"mt76x0.h\"\n#include \"mcu.h\"\n#include \"eeprom.h\"\n#include \"phy.h\"\n#include \"initvals.h\"\n#include \"initvals_phy.h\"\n#include \"../mt76x02_phy.h\"\n\nstatic int\nmt76x0_rf_csr_wr(struct mt76x02_dev *dev, u32 offset, u8 value)\n{\n\tint ret = 0;\n\tu8 bank, reg;\n\n\tif (test_bit(MT76_REMOVED, &dev->mphy.state))\n\t\treturn -ENODEV;\n\n\tbank = MT_RF_BANK(offset);\n\treg = MT_RF_REG(offset);\n\n\tif (WARN_ON_ONCE(reg > 127) || WARN_ON_ONCE(bank > 8))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->phy_mutex);\n\n\tif (!mt76_poll(dev, MT_RF_CSR_CFG, MT_RF_CSR_CFG_KICK, 0, 100)) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\tmt76_wr(dev, MT_RF_CSR_CFG,\n\t\tFIELD_PREP(MT_RF_CSR_CFG_DATA, value) |\n\t\tFIELD_PREP(MT_RF_CSR_CFG_REG_BANK, bank) |\n\t\tFIELD_PREP(MT_RF_CSR_CFG_REG_ID, reg) |\n\t\tMT_RF_CSR_CFG_WR |\n\t\tMT_RF_CSR_CFG_KICK);\n\nout:\n\tmutex_unlock(&dev->phy_mutex);\n\n\tif (ret < 0)\n\t\tdev_err(dev->mt76.dev, \"Error: RF write %d:%d failed:%d!!\\n\",\n\t\t\tbank, reg, ret);\n\n\treturn ret;\n}\n\nstatic int mt76x0_rf_csr_rr(struct mt76x02_dev *dev, u32 offset)\n{\n\tint ret = -ETIMEDOUT;\n\tu32 val;\n\tu8 bank, reg;\n\n\tif (test_bit(MT76_REMOVED, &dev->mphy.state))\n\t\treturn -ENODEV;\n\n\tbank = MT_RF_BANK(offset);\n\treg = MT_RF_REG(offset);\n\n\tif (WARN_ON_ONCE(reg > 127) || WARN_ON_ONCE(bank > 8))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->phy_mutex);\n\n\tif (!mt76_poll(dev, MT_RF_CSR_CFG, MT_RF_CSR_CFG_KICK, 0, 100))\n\t\tgoto out;\n\n\tmt76_wr(dev, MT_RF_CSR_CFG,\n\t\tFIELD_PREP(MT_RF_CSR_CFG_REG_BANK, bank) |\n\t\tFIELD_PREP(MT_RF_CSR_CFG_REG_ID, reg) |\n\t\tMT_RF_CSR_CFG_KICK);\n\n\tif (!mt76_poll(dev, MT_RF_CSR_CFG, MT_RF_CSR_CFG_KICK, 0, 100))\n\t\tgoto out;\n\n\tval = mt76_rr(dev, MT_RF_CSR_CFG);\n\tif (FIELD_GET(MT_RF_CSR_CFG_REG_ID, val) == reg &&\n\t    FIELD_GET(MT_RF_CSR_CFG_REG_BANK, val) == bank)\n\t\tret = FIELD_GET(MT_RF_CSR_CFG_DATA, val);\n\nout:\n\tmutex_unlock(&dev->phy_mutex);\n\n\tif (ret < 0)\n\t\tdev_err(dev->mt76.dev, \"Error: RF read %d:%d failed:%d!!\\n\",\n\t\t\tbank, reg, ret);\n\n\treturn ret;\n}\n\nstatic int\nmt76x0_rf_wr(struct mt76x02_dev *dev, u32 offset, u8 val)\n{\n\tif (mt76_is_usb(&dev->mt76)) {\n\t\tstruct mt76_reg_pair pair = {\n\t\t\t.reg = offset,\n\t\t\t.value = val,\n\t\t};\n\n\t\tWARN_ON_ONCE(!test_bit(MT76_STATE_MCU_RUNNING,\n\t\t\t\t       &dev->mphy.state));\n\t\treturn mt76_wr_rp(dev, MT_MCU_MEMMAP_RF, &pair, 1);\n\t} else {\n\t\treturn mt76x0_rf_csr_wr(dev, offset, val);\n\t}\n}\n\nstatic int mt76x0_rf_rr(struct mt76x02_dev *dev, u32 offset)\n{\n\tint ret;\n\tu32 val;\n\n\tif (mt76_is_usb(&dev->mt76)) {\n\t\tstruct mt76_reg_pair pair = {\n\t\t\t.reg = offset,\n\t\t};\n\n\t\tWARN_ON_ONCE(!test_bit(MT76_STATE_MCU_RUNNING,\n\t\t\t\t       &dev->mphy.state));\n\t\tret = mt76_rd_rp(dev, MT_MCU_MEMMAP_RF, &pair, 1);\n\t\tval = pair.value;\n\t} else {\n\t\tret = val = mt76x0_rf_csr_rr(dev, offset);\n\t}\n\n\treturn (ret < 0) ? ret : val;\n}\n\nstatic int\nmt76x0_rf_rmw(struct mt76x02_dev *dev, u32 offset, u8 mask, u8 val)\n{\n\tint ret;\n\n\tret = mt76x0_rf_rr(dev, offset);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval |= ret & ~mask;\n\n\tret = mt76x0_rf_wr(dev, offset, val);\n\treturn ret ? ret : val;\n}\n\nstatic int\nmt76x0_rf_set(struct mt76x02_dev *dev, u32 offset, u8 val)\n{\n\treturn mt76x0_rf_rmw(dev, offset, 0, val);\n}\n\nstatic int\nmt76x0_rf_clear(struct mt76x02_dev *dev, u32 offset, u8 mask)\n{\n\treturn mt76x0_rf_rmw(dev, offset, mask, 0);\n}\n\nstatic void\nmt76x0_phy_rf_csr_wr_rp(struct mt76x02_dev *dev,\n\t\t\tconst struct mt76_reg_pair *data,\n\t\t\tint n)\n{\n\twhile (n-- > 0) {\n\t\tmt76x0_rf_csr_wr(dev, data->reg, data->value);\n\t\tdata++;\n\t}\n}\n\n#define RF_RANDOM_WRITE(dev, tab) do {\t\t\t\t\t\\\n\tif (mt76_is_mmio(&dev->mt76))\t\t\t\t\t\\\n\t\tmt76x0_phy_rf_csr_wr_rp(dev, tab, ARRAY_SIZE(tab));\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tmt76_wr_rp(dev, MT_MCU_MEMMAP_RF, tab, ARRAY_SIZE(tab));\\\n} while (0)\n\nint mt76x0_phy_wait_bbp_ready(struct mt76x02_dev *dev)\n{\n\tint i = 20;\n\tu32 val;\n\n\tdo {\n\t\tval = mt76_rr(dev, MT_BBP(CORE, 0));\n\t\tif (val && ~val)\n\t\t\tbreak;\n\t} while (--i);\n\n\tif (!i) {\n\t\tdev_err(dev->mt76.dev, \"Error: BBP is not ready\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdev_dbg(dev->mt76.dev, \"BBP version %08x\\n\", val);\n\treturn 0;\n}\n\nstatic void\nmt76x0_phy_set_band(struct mt76x02_dev *dev, enum nl80211_band band)\n{\n\tswitch (band) {\n\tcase NL80211_BAND_2GHZ:\n\t\tRF_RANDOM_WRITE(dev, mt76x0_rf_2g_channel_0_tab);\n\n\t\tmt76x0_rf_wr(dev, MT_RF(5, 0), 0x45);\n\t\tmt76x0_rf_wr(dev, MT_RF(6, 0), 0x44);\n\n\t\tmt76_wr(dev, MT_TX_ALC_VGA3, 0x00050007);\n\t\tmt76_wr(dev, MT_TX0_RF_GAIN_CORR, 0x003E0002);\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\tRF_RANDOM_WRITE(dev, mt76x0_rf_5g_channel_0_tab);\n\n\t\tmt76x0_rf_wr(dev, MT_RF(5, 0), 0x44);\n\t\tmt76x0_rf_wr(dev, MT_RF(6, 0), 0x45);\n\n\t\tmt76_wr(dev, MT_TX_ALC_VGA3, 0x00000005);\n\t\tmt76_wr(dev, MT_TX0_RF_GAIN_CORR, 0x01010102);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\nmt76x0_phy_set_chan_rf_params(struct mt76x02_dev *dev, u8 channel,\n\t\t\t      u16 rf_bw_band)\n{\n\tconst struct mt76x0_freq_item *freq_item;\n\tu16 rf_band = rf_bw_band & 0xff00;\n\tu16 rf_bw = rf_bw_band & 0x00ff;\n\tenum nl80211_band band;\n\tbool b_sdm = false;\n\tu32 mac_reg;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mt76x0_sdm_channel); i++) {\n\t\tif (channel == mt76x0_sdm_channel[i]) {\n\t\t\tb_sdm = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(mt76x0_frequency_plan); i++) {\n\t\tif (channel == mt76x0_frequency_plan[i].channel) {\n\t\t\trf_band = mt76x0_frequency_plan[i].band;\n\n\t\t\tif (b_sdm)\n\t\t\t\tfreq_item = &mt76x0_sdm_frequency_plan[i];\n\t\t\telse\n\t\t\t\tfreq_item = &mt76x0_frequency_plan[i];\n\n\t\t\tmt76x0_rf_wr(dev, MT_RF(0, 37), freq_item->pllR37);\n\t\t\tmt76x0_rf_wr(dev, MT_RF(0, 36), freq_item->pllR36);\n\t\t\tmt76x0_rf_wr(dev, MT_RF(0, 35), freq_item->pllR35);\n\t\t\tmt76x0_rf_wr(dev, MT_RF(0, 34), freq_item->pllR34);\n\t\t\tmt76x0_rf_wr(dev, MT_RF(0, 33), freq_item->pllR33);\n\n\t\t\tmt76x0_rf_rmw(dev, MT_RF(0, 32), 0xe0,\n\t\t\t\t      freq_item->pllR32_b7b5);\n\n\t\t\t \n\t\t\tmt76x0_rf_rmw(dev, MT_RF(0, 32), MT_RF_PLL_DEN_MASK,\n\t\t\t\t      freq_item->pllR32_b4b0);\n\n\t\t\t \n\t\t\tmt76x0_rf_rmw(dev, MT_RF(0, 31), 0xe0,\n\t\t\t\t      freq_item->pllR31_b7b5);\n\n\t\t\t \n\t\t\tmt76x0_rf_rmw(dev, MT_RF(0, 31), MT_RF_PLL_K_MASK,\n\t\t\t\t      freq_item->pllR31_b4b0);\n\n\t\t\t \n\t\t\tif (b_sdm) {\n\t\t\t\tmt76x0_rf_clear(dev, MT_RF(0, 30),\n\t\t\t\t\t\tMT_RF_SDM_RESET_MASK);\n\t\t\t\tmt76x0_rf_set(dev, MT_RF(0, 30),\n\t\t\t\t\t      MT_RF_SDM_RESET_MASK);\n\t\t\t} else {\n\t\t\t\tmt76x0_rf_rmw(dev, MT_RF(0, 30),\n\t\t\t\t\t      MT_RF_SDM_RESET_MASK,\n\t\t\t\t\t      freq_item->pllR30_b7);\n\t\t\t}\n\n\t\t\t \n\t\t\tmt76x0_rf_rmw(dev, MT_RF(0, 30),\n\t\t\t\t      MT_RF_SDM_MASH_PRBS_MASK,\n\t\t\t\t      freq_item->pllR30_b6b2);\n\n\t\t\t \n\t\t\tmt76x0_rf_rmw(dev, MT_RF(0, 30), MT_RF_SDM_BP_MASK,\n\t\t\t\t      freq_item->pllR30_b1 << 1);\n\n\t\t\t \n\t\t\tmt76x0_rf_wr(dev, MT_RF(0, 29),\n\t\t\t\t     freq_item->pll_n & 0xff);\n\n\t\t\tmt76x0_rf_rmw(dev, MT_RF(0, 30), 0x1,\n\t\t\t\t      (freq_item->pll_n >> 8) & 0x1);\n\n\t\t\t \n\t\t\tmt76x0_rf_rmw(dev, MT_RF(0, 28), MT_RF_ISI_ISO_MASK,\n\t\t\t\t      freq_item->pllR28_b7b6);\n\n\t\t\t \n\t\t\tmt76x0_rf_rmw(dev, MT_RF(0, 28), MT_RF_PFD_DLY_MASK,\n\t\t\t\t      freq_item->pllR28_b5b4);\n\n\t\t\t \n\t\t\tmt76x0_rf_rmw(dev, MT_RF(0, 28), MT_RF_CLK_SEL_MASK,\n\t\t\t\t      freq_item->pllR28_b3b2);\n\n\t\t\t \n\t\t\tmt76x0_rf_wr(dev, MT_RF(0, 26),\n\t\t\t\t     freq_item->pll_sdm_k & 0xff);\n\t\t\tmt76x0_rf_wr(dev, MT_RF(0, 27),\n\t\t\t\t     (freq_item->pll_sdm_k >> 8) & 0xff);\n\n\t\t\tmt76x0_rf_rmw(dev, MT_RF(0, 28), 0x3,\n\t\t\t\t      (freq_item->pll_sdm_k >> 16) & 0x3);\n\n\t\t\t \n\t\t\tmt76x0_rf_rmw(dev, MT_RF(0, 24), MT_RF_XO_DIV_MASK,\n\t\t\t\t      freq_item->pllR24_b1b0);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(mt76x0_rf_bw_switch_tab); i++) {\n\t\tif (rf_bw == mt76x0_rf_bw_switch_tab[i].bw_band) {\n\t\t\tmt76x0_rf_wr(dev,\n\t\t\t\t     mt76x0_rf_bw_switch_tab[i].rf_bank_reg,\n\t\t\t\t     mt76x0_rf_bw_switch_tab[i].value);\n\t\t} else if ((rf_bw == (mt76x0_rf_bw_switch_tab[i].bw_band & 0xFF)) &&\n\t\t\t   (rf_band & mt76x0_rf_bw_switch_tab[i].bw_band)) {\n\t\t\tmt76x0_rf_wr(dev,\n\t\t\t\t     mt76x0_rf_bw_switch_tab[i].rf_bank_reg,\n\t\t\t\t     mt76x0_rf_bw_switch_tab[i].value);\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(mt76x0_rf_band_switch_tab); i++) {\n\t\tif (mt76x0_rf_band_switch_tab[i].bw_band & rf_band) {\n\t\t\tmt76x0_rf_wr(dev,\n\t\t\t\t     mt76x0_rf_band_switch_tab[i].rf_bank_reg,\n\t\t\t\t     mt76x0_rf_band_switch_tab[i].value);\n\t\t}\n\t}\n\n\tmt76_clear(dev, MT_RF_MISC, 0xc);\n\n\tband = (rf_band & RF_G_BAND) ? NL80211_BAND_2GHZ : NL80211_BAND_5GHZ;\n\tif (mt76x02_ext_pa_enabled(dev, band)) {\n\t\t \n\t\tif (rf_band & RF_A_BAND)\n\t\t\tmt76_set(dev, MT_RF_MISC, BIT(2));\n\t\telse\n\t\t\tmt76_set(dev, MT_RF_MISC, BIT(3));\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(mt76x0_rf_ext_pa_tab); i++)\n\t\t\tif (mt76x0_rf_ext_pa_tab[i].bw_band & rf_band)\n\t\t\t\tmt76x0_rf_wr(dev,\n\t\t\t\t\tmt76x0_rf_ext_pa_tab[i].rf_bank_reg,\n\t\t\t\t\tmt76x0_rf_ext_pa_tab[i].value);\n\t}\n\n\tif (rf_band & RF_G_BAND) {\n\t\tmt76_wr(dev, MT_TX0_RF_GAIN_ATTEN, 0x63707400);\n\t\t \n\t\tmac_reg = mt76_rr(dev, MT_TX_ALC_CFG_1);\n\t\tmac_reg &= 0x896400FF;\n\t\tmt76_wr(dev, MT_TX_ALC_CFG_1, mac_reg);\n\t} else {\n\t\tmt76_wr(dev, MT_TX0_RF_GAIN_ATTEN, 0x686A7800);\n\t\t \n\t\tmac_reg = mt76_rr(dev, MT_TX_ALC_CFG_1);\n\t\tmac_reg &= 0x890400FF;\n\t\tmt76_wr(dev, MT_TX_ALC_CFG_1, mac_reg);\n\t}\n}\n\nstatic void\nmt76x0_phy_set_chan_bbp_params(struct mt76x02_dev *dev, u16 rf_bw_band)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mt76x0_bbp_switch_tab); i++) {\n\t\tconst struct mt76x0_bbp_switch_item *item = &mt76x0_bbp_switch_tab[i];\n\t\tconst struct mt76_reg_pair *pair = &item->reg_pair;\n\n\t\tif ((rf_bw_band & item->bw_band) != rf_bw_band)\n\t\t\tcontinue;\n\n\t\tif (pair->reg == MT_BBP(AGC, 8)) {\n\t\t\tu32 val = pair->value;\n\t\t\tu8 gain;\n\n\t\t\tgain = FIELD_GET(MT_BBP_AGC_GAIN, val);\n\t\t\tgain -= dev->cal.rx.lna_gain * 2;\n\t\t\tval &= ~MT_BBP_AGC_GAIN;\n\t\t\tval |= FIELD_PREP(MT_BBP_AGC_GAIN, gain);\n\t\t\tmt76_wr(dev, pair->reg, val);\n\t\t} else {\n\t\t\tmt76_wr(dev, pair->reg, pair->value);\n\t\t}\n\t}\n}\n\nstatic void mt76x0_phy_ant_select(struct mt76x02_dev *dev)\n{\n\tu16 ee_ant = mt76x02_eeprom_get(dev, MT_EE_ANTENNA);\n\tu16 ee_cfg1 = mt76x02_eeprom_get(dev, MT_EE_CFG1_INIT);\n\tu16 nic_conf2 = mt76x02_eeprom_get(dev, MT_EE_NIC_CONF_2);\n\tu32 wlan, coex3;\n\tbool ant_div;\n\n\twlan = mt76_rr(dev, MT_WLAN_FUN_CTRL);\n\tcoex3 = mt76_rr(dev, MT_COEXCFG3);\n\n\tee_ant &= ~(BIT(14) | BIT(12));\n\twlan  &= ~(BIT(6) | BIT(5));\n\tcoex3 &= ~GENMASK(5, 2);\n\n\tif (ee_ant & MT_EE_ANTENNA_DUAL) {\n\t\t \n\t\tant_div = !(nic_conf2 & MT_EE_NIC_CONF_2_ANT_OPT) &&\n\t\t\t  (nic_conf2 & MT_EE_NIC_CONF_2_ANT_DIV);\n\t\tif (ant_div)\n\t\t\tee_ant |= BIT(12);\n\t\telse\n\t\t\tcoex3 |= BIT(4);\n\t\tcoex3 |= BIT(3);\n\t\tif (dev->mphy.cap.has_2ghz)\n\t\t\twlan |= BIT(6);\n\t} else {\n\t\t \n\t\tif (dev->mphy.cap.has_5ghz) {\n\t\t\tcoex3 |= BIT(3) | BIT(4);\n\t\t} else {\n\t\t\twlan |= BIT(6);\n\t\t\tcoex3 |= BIT(1);\n\t\t}\n\t}\n\n\tif (is_mt7630(dev))\n\t\tee_ant |= BIT(14) | BIT(11);\n\n\tmt76_wr(dev, MT_WLAN_FUN_CTRL, wlan);\n\tmt76_rmw(dev, MT_CMB_CTRL, GENMASK(15, 0), ee_ant);\n\tmt76_rmw(dev, MT_CSR_EE_CFG1, GENMASK(15, 0), ee_cfg1);\n\tmt76_clear(dev, MT_COEXCFG0, BIT(2));\n\tmt76_wr(dev, MT_COEXCFG3, coex3);\n}\n\nstatic void\nmt76x0_phy_bbp_set_bw(struct mt76x02_dev *dev, enum nl80211_chan_width width)\n{\n\tenum { BW_20 = 0, BW_40 = 1, BW_80 = 2, BW_10 = 4};\n\tint bw;\n\n\tswitch (width) {\n\tdefault:\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\tcase NL80211_CHAN_WIDTH_20:\n\t\tbw = BW_20;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tbw = BW_40;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\tbw = BW_80;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_10:\n\t\tbw = BW_10;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80P80:\n\tcase NL80211_CHAN_WIDTH_160:\n\tcase NL80211_CHAN_WIDTH_5:\n\t\t \n\t\treturn;\n\t}\n\n\tmt76x02_mcu_function_select(dev, BW_SETTING, bw);\n}\n\nstatic void mt76x0_phy_tssi_dc_calibrate(struct mt76x02_dev *dev)\n{\n\tstruct ieee80211_channel *chan = dev->mphy.chandef.chan;\n\tu32 val;\n\n\tif (chan->band == NL80211_BAND_5GHZ)\n\t\tmt76x0_rf_clear(dev, MT_RF(0, 67), 0xf);\n\n\t \n\tmt76_wr(dev, MT_RF_SETTING_0, 0x60002237);\n\tmt76_wr(dev, MT_RF_BYPASS_0, 0xffffffff);\n\n\t \n\tmt76_set(dev, MT_BBP(CORE, 4), BIT(0));\n\tusleep_range(500, 1000);\n\tmt76_clear(dev, MT_BBP(CORE, 4), BIT(0));\n\n\tval = (chan->band == NL80211_BAND_5GHZ) ? 0x80055 : 0x80050;\n\tmt76_wr(dev, MT_BBP(CORE, 34), val);\n\n\t \n\tmt76_wr(dev, MT_BBP(TXBE, 6), BIT(31));\n\n\tmt76_poll_msec(dev, MT_BBP(CORE, 34), BIT(4), 0, 200);\n\tdev->cal.tssi_dc = mt76_rr(dev, MT_BBP(CORE, 35)) & 0xff;\n\n\t \n\tmt76_wr(dev, MT_RF_BYPASS_0, 0);\n\t \n\tmt76_wr(dev, MT_BBP(TXBE, 6), 0);\n\t \n\tmt76_set(dev, MT_BBP(CORE, 4), BIT(0));\n\tusleep_range(500, 1000);\n\tmt76_clear(dev, MT_BBP(CORE, 4), BIT(0));\n\n\tif (chan->band == NL80211_BAND_5GHZ)\n\t\tmt76x0_rf_rmw(dev, MT_RF(0, 67), 0xf, 0x4);\n}\n\nstatic int\nmt76x0_phy_tssi_adc_calibrate(struct mt76x02_dev *dev, s16 *ltssi,\n\t\t\t      u8 *info)\n{\n\tstruct ieee80211_channel *chan = dev->mphy.chandef.chan;\n\tu32 val;\n\n\tval = (chan->band == NL80211_BAND_5GHZ) ? 0x80055 : 0x80050;\n\tmt76_wr(dev, MT_BBP(CORE, 34), val);\n\n\tif (!mt76_poll_msec(dev, MT_BBP(CORE, 34), BIT(4), 0, 200)) {\n\t\tmt76_clear(dev, MT_BBP(CORE, 34), BIT(4));\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t*ltssi = mt76_rr(dev, MT_BBP(CORE, 35)) & 0xff;\n\tif (chan->band == NL80211_BAND_5GHZ)\n\t\t*ltssi += 128;\n\n\t \n\tmt76_wr(dev, MT_BBP(CORE, 34), 0x80041);\n\tinfo[0] = mt76_rr(dev, MT_BBP(CORE, 35)) & 0xff;\n\n\t \n\tmt76_wr(dev, MT_BBP(CORE, 34), 0x80042);\n\tinfo[1] = mt76_rr(dev, MT_BBP(CORE, 35)) & 0xff;\n\n\t \n\tmt76_wr(dev, MT_BBP(CORE, 34), 0x80043);\n\tinfo[2] = mt76_rr(dev, MT_BBP(CORE, 35)) & 0xff;\n\n\treturn 0;\n}\n\nstatic u8 mt76x0_phy_get_rf_pa_mode(struct mt76x02_dev *dev,\n\t\t\t\t    int index, u8 tx_rate)\n{\n\tu32 val, reg;\n\n\treg = (index == 1) ? MT_RF_PA_MODE_CFG1 : MT_RF_PA_MODE_CFG0;\n\tval = mt76_rr(dev, reg);\n\treturn (val & (3 << (tx_rate * 2))) >> (tx_rate * 2);\n}\n\nstatic int\nmt76x0_phy_get_target_power(struct mt76x02_dev *dev, u8 tx_mode,\n\t\t\t    u8 *info, s8 *target_power,\n\t\t\t    s8 *target_pa_power)\n{\n\tu8 tx_rate, cur_power;\n\n\tcur_power = mt76_rr(dev, MT_TX_ALC_CFG_0) & MT_TX_ALC_CFG_0_CH_INIT_0;\n\tswitch (tx_mode) {\n\tcase 0:\n\t\t \n\t\ttx_rate = (info[0] & 0x60) >> 5;\n\t\t*target_power = cur_power + dev->rate_power.cck[tx_rate];\n\t\t*target_pa_power = mt76x0_phy_get_rf_pa_mode(dev, 0, tx_rate);\n\t\tbreak;\n\tcase 1: {\n\t\tu8 index;\n\n\t\t \n\t\ttx_rate = (info[0] & 0xf0) >> 4;\n\t\tswitch (tx_rate) {\n\t\tcase 0xb:\n\t\t\tindex = 0;\n\t\t\tbreak;\n\t\tcase 0xf:\n\t\t\tindex = 1;\n\t\t\tbreak;\n\t\tcase 0xa:\n\t\t\tindex = 2;\n\t\t\tbreak;\n\t\tcase 0xe:\n\t\t\tindex = 3;\n\t\t\tbreak;\n\t\tcase 0x9:\n\t\t\tindex = 4;\n\t\t\tbreak;\n\t\tcase 0xd:\n\t\t\tindex = 5;\n\t\t\tbreak;\n\t\tcase 0x8:\n\t\t\tindex = 6;\n\t\t\tbreak;\n\t\tcase 0xc:\n\t\t\tindex = 7;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*target_power = cur_power + dev->rate_power.ofdm[index];\n\t\t*target_pa_power = mt76x0_phy_get_rf_pa_mode(dev, 0, index + 4);\n\t\tbreak;\n\t}\n\tcase 4:\n\t\t \n\t\ttx_rate = info[1] & 0xf;\n\t\tif (tx_rate > 9)\n\t\t\treturn -EINVAL;\n\n\t\t*target_power = cur_power;\n\t\tif (tx_rate > 7)\n\t\t\t*target_power += dev->rate_power.vht[tx_rate - 8];\n\t\telse\n\t\t\t*target_power += dev->rate_power.ht[tx_rate];\n\n\t\t*target_pa_power = mt76x0_phy_get_rf_pa_mode(dev, 1, tx_rate);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\ttx_rate = info[1] & 0x7f;\n\t\tif (tx_rate > 9)\n\t\t\treturn -EINVAL;\n\n\t\t*target_power = cur_power + dev->rate_power.ht[tx_rate];\n\t\t*target_pa_power = mt76x0_phy_get_rf_pa_mode(dev, 1, tx_rate);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic s16 mt76x0_phy_lin2db(u16 val)\n{\n\tu32 mantissa = val << 4;\n\tint ret, data;\n\ts16 exp = -4;\n\n\twhile (mantissa < BIT(15)) {\n\t\tmantissa <<= 1;\n\t\tif (--exp < -20)\n\t\t\treturn -10000;\n\t}\n\twhile (mantissa > 0xffff) {\n\t\tmantissa >>= 1;\n\t\tif (++exp > 20)\n\t\t\treturn -10000;\n\t}\n\n\t \n\tif (mantissa <= 47104)\n\t\tdata = mantissa + (mantissa >> 3) + (mantissa >> 4) - 38400;\n\telse\n\t\tdata = mantissa - (mantissa >> 3) - (mantissa >> 6) - 23040;\n\tdata = max_t(int, 0, data);\n\n\tret = ((15 + exp) << 15) + data;\n\tret = (ret << 2) + (ret << 1) + (ret >> 6) + (ret >> 7);\n\treturn ret >> 10;\n}\n\nstatic int\nmt76x0_phy_get_delta_power(struct mt76x02_dev *dev, u8 tx_mode,\n\t\t\t   s8 target_power, s8 target_pa_power,\n\t\t\t   s16 ltssi)\n{\n\tstruct ieee80211_channel *chan = dev->mphy.chandef.chan;\n\tint tssi_target = target_power << 12, tssi_slope;\n\tint tssi_offset, tssi_db, ret;\n\tu32 data;\n\tu16 val;\n\n\tif (chan->band == NL80211_BAND_5GHZ) {\n\t\tu8 bound[7];\n\t\tint i, err;\n\n\t\terr = mt76x02_eeprom_copy(dev, MT_EE_TSSI_BOUND1, bound,\n\t\t\t\t\t  sizeof(bound));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(bound); i++) {\n\t\t\tif (chan->hw_value <= bound[i] || !bound[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tval = mt76x02_eeprom_get(dev, MT_EE_TSSI_SLOPE_5G + i * 2);\n\n\t\ttssi_offset = val >> 8;\n\t\tif ((tssi_offset >= 64 && tssi_offset <= 127) ||\n\t\t    (tssi_offset & BIT(7)))\n\t\t\ttssi_offset -= BIT(8);\n\t} else {\n\t\tval = mt76x02_eeprom_get(dev, MT_EE_TSSI_SLOPE_2G);\n\n\t\ttssi_offset = val >> 8;\n\t\tif (tssi_offset & BIT(7))\n\t\t\ttssi_offset -= BIT(8);\n\t}\n\ttssi_slope = val & 0xff;\n\n\tswitch (target_pa_power) {\n\tcase 1:\n\t\tif (chan->band == NL80211_BAND_2GHZ)\n\t\t\ttssi_target += 29491;  \n\t\tfallthrough;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\ttssi_target += 4424;  \n\t\tbreak;\n\t}\n\n\tif (!tx_mode) {\n\t\tdata = mt76_rr(dev, MT_BBP(CORE, 1));\n\t\tif (is_mt7630(dev) && mt76_is_mmio(&dev->mt76)) {\n\t\t\tint offset;\n\n\t\t\t \n\t\t\toffset = (data & BIT(5)) ? 18841 : 12288;\n\t\t\ttssi_target += offset;\n\t\t} else if (data & BIT(5)) {\n\t\t\t \n\t\t\ttssi_target += 6554;\n\t\t}\n\t}\n\n\tdata = mt76_rr(dev, MT_BBP(TXBE, 4));\n\tswitch (data & 0x3) {\n\tcase 1:\n\t\ttssi_target -= 49152;  \n\t\tbreak;\n\tcase 2:\n\t\ttssi_target -= 98304;  \n\t\tbreak;\n\tcase 3:\n\t\ttssi_target += 49152;  \n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\ttssi_db = mt76x0_phy_lin2db(ltssi - dev->cal.tssi_dc) * tssi_slope;\n\tif (chan->band == NL80211_BAND_5GHZ) {\n\t\ttssi_db += ((tssi_offset - 50) << 10);  \n\t\ttssi_target -= tssi_db;\n\t\tif (ltssi > 254 && tssi_target > 0) {\n\t\t\t \n\t\t\ttssi_target = 0;\n\t\t}\n\t} else {\n\t\ttssi_db += (tssi_offset << 9);  \n\t\ttssi_target -= tssi_db;\n\t\t \n\t\tif ((ltssi > 126 && tssi_target > 0) ||\n\t\t    ((ltssi - dev->cal.tssi_dc) < 1 && tssi_target < 0)) {\n\t\t\ttssi_target = 0;\n\t\t}\n\t}\n\n\tif ((dev->cal.tssi_target ^ tssi_target) < 0 &&\n\t    dev->cal.tssi_target > -4096 && dev->cal.tssi_target < 4096 &&\n\t    tssi_target > -4096 && tssi_target < 4096) {\n\t\tif ((tssi_target < 0 &&\n\t\t     tssi_target + dev->cal.tssi_target > 0) ||\n\t\t    (tssi_target > 0 &&\n\t\t     tssi_target + dev->cal.tssi_target <= 0))\n\t\t\ttssi_target = 0;\n\t\telse\n\t\t\tdev->cal.tssi_target = tssi_target;\n\t} else {\n\t\tdev->cal.tssi_target = tssi_target;\n\t}\n\n\t \n\tif (tssi_target > 0)\n\t\ttssi_target += 2048;\n\telse\n\t\ttssi_target -= 2048;\n\ttssi_target >>= 12;\n\n\tret = mt76_get_field(dev, MT_TX_ALC_CFG_1, MT_TX_ALC_CFG_1_TEMP_COMP);\n\tif (ret & BIT(5))\n\t\tret -= BIT(6);\n\tret += tssi_target;\n\n\tret = min_t(int, 31, ret);\n\treturn max_t(int, -32, ret);\n}\n\nstatic void mt76x0_phy_tssi_calibrate(struct mt76x02_dev *dev)\n{\n\ts8 target_power, target_pa_power;\n\tu8 tssi_info[3], tx_mode;\n\ts16 ltssi;\n\ts8 val;\n\n\tif (mt76x0_phy_tssi_adc_calibrate(dev, &ltssi, tssi_info) < 0)\n\t\treturn;\n\n\ttx_mode = tssi_info[0] & 0x7;\n\tif (mt76x0_phy_get_target_power(dev, tx_mode, tssi_info,\n\t\t\t\t\t&target_power, &target_pa_power) < 0)\n\t\treturn;\n\n\tval = mt76x0_phy_get_delta_power(dev, tx_mode, target_power,\n\t\t\t\t\t target_pa_power, ltssi);\n\tmt76_rmw_field(dev, MT_TX_ALC_CFG_1, MT_TX_ALC_CFG_1_TEMP_COMP, val);\n}\n\nvoid mt76x0_phy_set_txpower(struct mt76x02_dev *dev)\n{\n\tstruct mt76x02_rate_power *t = &dev->rate_power;\n\ts8 info;\n\n\tmt76x0_get_tx_power_per_rate(dev, dev->mphy.chandef.chan, t);\n\tmt76x0_get_power_info(dev, dev->mphy.chandef.chan, &info);\n\n\tmt76x02_add_rate_power_offset(t, info);\n\tmt76x02_limit_rate_power(t, dev->txpower_conf);\n\tdev->mphy.txpower_cur = mt76x02_get_max_rate_power(t);\n\tmt76x02_add_rate_power_offset(t, -info);\n\n\tdev->target_power = info;\n\tmt76x02_phy_set_txpower(dev, info, info);\n}\n\nvoid mt76x0_phy_calibrate(struct mt76x02_dev *dev, bool power_on)\n{\n\tstruct ieee80211_channel *chan = dev->mphy.chandef.chan;\n\tint is_5ghz = (chan->band == NL80211_BAND_5GHZ) ? 1 : 0;\n\tu32 val, tx_alc, reg_val;\n\n\tif (is_mt7630(dev))\n\t\treturn;\n\n\tif (power_on) {\n\t\tmt76x02_mcu_calibrate(dev, MCU_CAL_R, 0);\n\t\tmt76x02_mcu_calibrate(dev, MCU_CAL_VCO, chan->hw_value);\n\t\tusleep_range(10, 20);\n\n\t\tif (mt76x0_tssi_enabled(dev)) {\n\t\t\tmt76_wr(dev, MT_MAC_SYS_CTRL,\n\t\t\t\tMT_MAC_SYS_CTRL_ENABLE_RX);\n\t\t\tmt76x0_phy_tssi_dc_calibrate(dev);\n\t\t\tmt76_wr(dev, MT_MAC_SYS_CTRL,\n\t\t\t\tMT_MAC_SYS_CTRL_ENABLE_TX |\n\t\t\t\tMT_MAC_SYS_CTRL_ENABLE_RX);\n\t\t}\n\t}\n\n\ttx_alc = mt76_rr(dev, MT_TX_ALC_CFG_0);\n\tmt76_wr(dev, MT_TX_ALC_CFG_0, 0);\n\tusleep_range(500, 700);\n\n\treg_val = mt76_rr(dev, MT_BBP(IBI, 9));\n\tmt76_wr(dev, MT_BBP(IBI, 9), 0xffffff7e);\n\n\tif (is_5ghz) {\n\t\tif (chan->hw_value < 100)\n\t\t\tval = 0x701;\n\t\telse if (chan->hw_value < 140)\n\t\t\tval = 0x801;\n\t\telse\n\t\t\tval = 0x901;\n\t} else {\n\t\tval = 0x600;\n\t}\n\n\tmt76x02_mcu_calibrate(dev, MCU_CAL_FULL, val);\n\tmt76x02_mcu_calibrate(dev, MCU_CAL_LC, is_5ghz);\n\tusleep_range(15000, 20000);\n\n\tmt76_wr(dev, MT_BBP(IBI, 9), reg_val);\n\tmt76_wr(dev, MT_TX_ALC_CFG_0, tx_alc);\n\tmt76x02_mcu_calibrate(dev, MCU_CAL_RXDCOC, 1);\n}\nEXPORT_SYMBOL_GPL(mt76x0_phy_calibrate);\n\nvoid mt76x0_phy_set_channel(struct mt76x02_dev *dev,\n\t\t\t    struct cfg80211_chan_def *chandef)\n{\n\tu32 ext_cca_chan[4] = {\n\t\t[0] = FIELD_PREP(MT_EXT_CCA_CFG_CCA0, 0) |\n\t\t      FIELD_PREP(MT_EXT_CCA_CFG_CCA1, 1) |\n\t\t      FIELD_PREP(MT_EXT_CCA_CFG_CCA2, 2) |\n\t\t      FIELD_PREP(MT_EXT_CCA_CFG_CCA3, 3) |\n\t\t      FIELD_PREP(MT_EXT_CCA_CFG_CCA_MASK, BIT(0)),\n\t\t[1] = FIELD_PREP(MT_EXT_CCA_CFG_CCA0, 1) |\n\t\t      FIELD_PREP(MT_EXT_CCA_CFG_CCA1, 0) |\n\t\t      FIELD_PREP(MT_EXT_CCA_CFG_CCA2, 2) |\n\t\t      FIELD_PREP(MT_EXT_CCA_CFG_CCA3, 3) |\n\t\t      FIELD_PREP(MT_EXT_CCA_CFG_CCA_MASK, BIT(1)),\n\t\t[2] = FIELD_PREP(MT_EXT_CCA_CFG_CCA0, 2) |\n\t\t      FIELD_PREP(MT_EXT_CCA_CFG_CCA1, 3) |\n\t\t      FIELD_PREP(MT_EXT_CCA_CFG_CCA2, 1) |\n\t\t      FIELD_PREP(MT_EXT_CCA_CFG_CCA3, 0) |\n\t\t      FIELD_PREP(MT_EXT_CCA_CFG_CCA_MASK, BIT(2)),\n\t\t[3] = FIELD_PREP(MT_EXT_CCA_CFG_CCA0, 3) |\n\t\t      FIELD_PREP(MT_EXT_CCA_CFG_CCA1, 2) |\n\t\t      FIELD_PREP(MT_EXT_CCA_CFG_CCA2, 1) |\n\t\t      FIELD_PREP(MT_EXT_CCA_CFG_CCA3, 0) |\n\t\t      FIELD_PREP(MT_EXT_CCA_CFG_CCA_MASK, BIT(3)),\n\t};\n\tbool scan = test_bit(MT76_SCANNING, &dev->mphy.state);\n\tint ch_group_index, freq, freq1;\n\tu8 channel;\n\tu32 val;\n\tu16 rf_bw_band;\n\n\tfreq = chandef->chan->center_freq;\n\tfreq1 = chandef->center_freq1;\n\tchannel = chandef->chan->hw_value;\n\trf_bw_band = (channel <= 14) ? RF_G_BAND : RF_A_BAND;\n\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tif (freq1 > freq)\n\t\t\tch_group_index = 0;\n\t\telse\n\t\t\tch_group_index = 1;\n\t\tchannel += 2 - ch_group_index * 4;\n\t\trf_bw_band |= RF_BW_40;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\tch_group_index = (freq - freq1 + 30) / 20;\n\t\tif (WARN_ON(ch_group_index < 0 || ch_group_index > 3))\n\t\t\tch_group_index = 0;\n\t\tchannel += 6 - ch_group_index * 4;\n\t\trf_bw_band |= RF_BW_80;\n\t\tbreak;\n\tdefault:\n\t\tch_group_index = 0;\n\t\trf_bw_band |= RF_BW_20;\n\t\tbreak;\n\t}\n\n\tif (mt76_is_usb(&dev->mt76)) {\n\t\tmt76x0_phy_bbp_set_bw(dev, chandef->width);\n\t} else {\n\t\tif (chandef->width == NL80211_CHAN_WIDTH_80 ||\n\t\t    chandef->width == NL80211_CHAN_WIDTH_40)\n\t\t\tval = 0x201;\n\t\telse\n\t\t\tval = 0x601;\n\t\tmt76_wr(dev, MT_TX_SW_CFG0, val);\n\t}\n\tmt76x02_phy_set_bw(dev, chandef->width, ch_group_index);\n\tmt76x02_phy_set_band(dev, chandef->chan->band,\n\t\t\t     ch_group_index & 1);\n\n\tmt76_rmw(dev, MT_EXT_CCA_CFG,\n\t\t (MT_EXT_CCA_CFG_CCA0 |\n\t\t  MT_EXT_CCA_CFG_CCA1 |\n\t\t  MT_EXT_CCA_CFG_CCA2 |\n\t\t  MT_EXT_CCA_CFG_CCA3 |\n\t\t  MT_EXT_CCA_CFG_CCA_MASK),\n\t\t ext_cca_chan[ch_group_index]);\n\n\tmt76x0_phy_set_band(dev, chandef->chan->band);\n\tmt76x0_phy_set_chan_rf_params(dev, channel, rf_bw_band);\n\n\t \n\tif (channel == 14)\n\t\tmt76_set(dev, MT_BBP(CORE, 1), 0x20);\n\telse\n\t\tmt76_clear(dev, MT_BBP(CORE, 1), 0x20);\n\n\tmt76x0_read_rx_gain(dev);\n\tmt76x0_phy_set_chan_bbp_params(dev, rf_bw_band);\n\n\t \n\tmt76x0_rf_set(dev, MT_RF(0, 4), BIT(7));\n\tif (scan)\n\t\treturn;\n\n\tmt76x02_init_agc_gain(dev);\n\tmt76x0_phy_calibrate(dev, false);\n\tmt76x0_phy_set_txpower(dev);\n\n\tieee80211_queue_delayed_work(dev->mt76.hw, &dev->cal_work,\n\t\t\t\t     MT_CALIBRATE_INTERVAL);\n}\n\nstatic void mt76x0_phy_temp_sensor(struct mt76x02_dev *dev)\n{\n\tu8 rf_b7_73, rf_b0_66, rf_b0_67;\n\ts8 val;\n\n\trf_b7_73 = mt76x0_rf_rr(dev, MT_RF(7, 73));\n\trf_b0_66 = mt76x0_rf_rr(dev, MT_RF(0, 66));\n\trf_b0_67 = mt76x0_rf_rr(dev, MT_RF(0, 67));\n\n\tmt76x0_rf_wr(dev, MT_RF(7, 73), 0x02);\n\tmt76x0_rf_wr(dev, MT_RF(0, 66), 0x23);\n\tmt76x0_rf_wr(dev, MT_RF(0, 67), 0x01);\n\n\tmt76_wr(dev, MT_BBP(CORE, 34), 0x00080055);\n\tif (!mt76_poll_msec(dev, MT_BBP(CORE, 34), BIT(4), 0, 200)) {\n\t\tmt76_clear(dev, MT_BBP(CORE, 34), BIT(4));\n\t\tgoto done;\n\t}\n\n\tval = mt76_rr(dev, MT_BBP(CORE, 35));\n\tval = (35 * (val - dev->cal.rx.temp_offset)) / 10 + 25;\n\n\tif (abs(val - dev->cal.temp_vco) > 20) {\n\t\tmt76x02_mcu_calibrate(dev, MCU_CAL_VCO,\n\t\t\t\t      dev->mphy.chandef.chan->hw_value);\n\t\tdev->cal.temp_vco = val;\n\t}\n\tif (abs(val - dev->cal.temp) > 30) {\n\t\tmt76x0_phy_calibrate(dev, false);\n\t\tdev->cal.temp = val;\n\t}\n\ndone:\n\tmt76x0_rf_wr(dev, MT_RF(7, 73), rf_b7_73);\n\tmt76x0_rf_wr(dev, MT_RF(0, 66), rf_b0_66);\n\tmt76x0_rf_wr(dev, MT_RF(0, 67), rf_b0_67);\n}\n\nstatic void mt76x0_phy_set_gain_val(struct mt76x02_dev *dev)\n{\n\tu8 gain = dev->cal.agc_gain_cur[0] - dev->cal.agc_gain_adjust;\n\n\tmt76_rmw_field(dev, MT_BBP(AGC, 8), MT_BBP_AGC_GAIN, gain);\n\n\tif ((dev->mphy.chandef.chan->flags & IEEE80211_CHAN_RADAR) &&\n\t    !is_mt7630(dev))\n\t\tmt76x02_phy_dfs_adjust_agc(dev);\n}\n\nstatic void\nmt76x0_phy_update_channel_gain(struct mt76x02_dev *dev)\n{\n\tbool gain_change;\n\tu8 gain_delta;\n\tint low_gain;\n\n\tdev->cal.avg_rssi_all = mt76_get_min_avg_rssi(&dev->mt76, false);\n\tif (!dev->cal.avg_rssi_all)\n\t\tdev->cal.avg_rssi_all = -75;\n\n\tlow_gain = (dev->cal.avg_rssi_all > mt76x02_get_rssi_gain_thresh(dev)) +\n\t\t(dev->cal.avg_rssi_all > mt76x02_get_low_rssi_gain_thresh(dev));\n\n\tgain_change = dev->cal.low_gain < 0 ||\n\t\t      (dev->cal.low_gain & 2) ^ (low_gain & 2);\n\tdev->cal.low_gain = low_gain;\n\n\tif (!gain_change) {\n\t\tif (mt76x02_phy_adjust_vga_gain(dev))\n\t\t\tmt76x0_phy_set_gain_val(dev);\n\t\treturn;\n\t}\n\n\tdev->cal.agc_gain_adjust = (low_gain == 2) ? 0 : 10;\n\tgain_delta = (low_gain == 2) ? 10 : 0;\n\n\tdev->cal.agc_gain_cur[0] = dev->cal.agc_gain_init[0] - gain_delta;\n\tmt76x0_phy_set_gain_val(dev);\n\n\t \n\tmt76_rr(dev, MT_RX_STAT_1);\n}\n\nstatic void mt76x0_phy_calibration_work(struct work_struct *work)\n{\n\tstruct mt76x02_dev *dev = container_of(work, struct mt76x02_dev,\n\t\t\t\t\t       cal_work.work);\n\n\tmt76x0_phy_update_channel_gain(dev);\n\tif (mt76x0_tssi_enabled(dev))\n\t\tmt76x0_phy_tssi_calibrate(dev);\n\telse\n\t\tmt76x0_phy_temp_sensor(dev);\n\n\tieee80211_queue_delayed_work(dev->mt76.hw, &dev->cal_work,\n\t\t\t\t     4 * MT_CALIBRATE_INTERVAL);\n}\n\nstatic void mt76x0_rf_patch_reg_array(struct mt76x02_dev *dev,\n\t\t\t\t      const struct mt76_reg_pair *rp, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tu32 reg = rp[i].reg;\n\t\tu8 val = rp[i].value;\n\n\t\tswitch (reg) {\n\t\tcase MT_RF(0, 3):\n\t\t\tif (mt76_is_mmio(&dev->mt76)) {\n\t\t\t\tif (is_mt7630(dev))\n\t\t\t\t\tval = 0x70;\n\t\t\t\telse\n\t\t\t\t\tval = 0x63;\n\t\t\t} else {\n\t\t\t\tval = 0x73;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MT_RF(0, 21):\n\t\t\tif (is_mt7610e(dev))\n\t\t\t\tval = 0x10;\n\t\t\telse\n\t\t\t\tval = 0x12;\n\t\t\tbreak;\n\t\tcase MT_RF(5, 2):\n\t\t\tif (is_mt7630(dev))\n\t\t\t\tval = 0x1d;\n\t\t\telse if (is_mt7610e(dev))\n\t\t\t\tval = 0x00;\n\t\t\telse\n\t\t\t\tval = 0x0c;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tmt76x0_rf_wr(dev, reg, val);\n\t}\n}\n\nstatic void mt76x0_phy_rf_init(struct mt76x02_dev *dev)\n{\n\tint i;\n\n\tmt76x0_rf_patch_reg_array(dev, mt76x0_rf_central_tab,\n\t\t\t\t  ARRAY_SIZE(mt76x0_rf_central_tab));\n\tmt76x0_rf_patch_reg_array(dev, mt76x0_rf_2g_channel_0_tab,\n\t\t\t\t  ARRAY_SIZE(mt76x0_rf_2g_channel_0_tab));\n\tRF_RANDOM_WRITE(dev, mt76x0_rf_5g_channel_0_tab);\n\tRF_RANDOM_WRITE(dev, mt76x0_rf_vga_channel_0_tab);\n\n\tfor (i = 0; i < ARRAY_SIZE(mt76x0_rf_bw_switch_tab); i++) {\n\t\tconst struct mt76x0_rf_switch_item *item = &mt76x0_rf_bw_switch_tab[i];\n\n\t\tif (item->bw_band == RF_BW_20)\n\t\t\tmt76x0_rf_wr(dev, item->rf_bank_reg, item->value);\n\t\telse if (((RF_G_BAND | RF_BW_20) & item->bw_band) ==\n\t\t\t  (RF_G_BAND | RF_BW_20))\n\t\t\tmt76x0_rf_wr(dev, item->rf_bank_reg, item->value);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(mt76x0_rf_band_switch_tab); i++) {\n\t\tif (mt76x0_rf_band_switch_tab[i].bw_band & RF_G_BAND) {\n\t\t\tmt76x0_rf_wr(dev,\n\t\t\t\t     mt76x0_rf_band_switch_tab[i].rf_bank_reg,\n\t\t\t\t     mt76x0_rf_band_switch_tab[i].value);\n\t\t}\n\t}\n\n\t \n\tmt76x0_rf_wr(dev, MT_RF(0, 22),\n\t\t     min_t(u8, dev->cal.rx.freq_offset, 0xbf));\n\tmt76x0_rf_rr(dev, MT_RF(0, 22));\n\n\t \n\tmt76x0_rf_set(dev, MT_RF(0, 73), BIT(7));\n\tmt76x0_rf_clear(dev, MT_RF(0, 73), BIT(7));\n\tmt76x0_rf_set(dev, MT_RF(0, 73), BIT(7));\n\n\t \n\tmt76x0_rf_set(dev, MT_RF(0, 4), 0x80);\n}\n\nvoid mt76x0_phy_init(struct mt76x02_dev *dev)\n{\n\tINIT_DELAYED_WORK(&dev->cal_work, mt76x0_phy_calibration_work);\n\n\tmt76x0_phy_ant_select(dev);\n\tmt76x0_phy_rf_init(dev);\n\tmt76x02_phy_set_rxpath(dev);\n\tmt76x02_phy_set_txdac(dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}