{
  "module_name": "eeprom.c",
  "hash_id": "7dba1851840ba84fabe19504cb75a3c02b2ea78342642c4f34ec6ce3a758742c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt76x0/eeprom.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n#include <linux/etherdevice.h>\n#include <asm/unaligned.h>\n#include \"mt76x0.h\"\n#include \"eeprom.h\"\n#include \"../mt76x02_phy.h\"\n\n#define MT_MAP_READS\tDIV_ROUND_UP(MT_EFUSE_USAGE_MAP_SIZE, 16)\nstatic int\nmt76x0_efuse_physical_size_check(struct mt76x02_dev *dev)\n{\n\tu8 data[MT_MAP_READS * 16];\n\tint ret, i;\n\tu32 start = 0, end = 0, cnt_free;\n\n\tret = mt76x02_get_efuse_data(dev, MT_EE_USAGE_MAP_START, data,\n\t\t\t\t     sizeof(data), MT_EE_PHYSICAL_READ);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < MT_EFUSE_USAGE_MAP_SIZE; i++)\n\t\tif (!data[i]) {\n\t\t\tif (!start)\n\t\t\t\tstart = MT_EE_USAGE_MAP_START + i;\n\t\t\tend = MT_EE_USAGE_MAP_START + i;\n\t\t}\n\tcnt_free = end - start + 1;\n\n\tif (MT_EFUSE_USAGE_MAP_SIZE - cnt_free < 5) {\n\t\tdev_err(dev->mt76.dev,\n\t\t\t\"driver does not support default EEPROM\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void mt76x0_set_chip_cap(struct mt76x02_dev *dev)\n{\n\tu16 nic_conf0 = mt76x02_eeprom_get(dev, MT_EE_NIC_CONF_0);\n\tu16 nic_conf1 = mt76x02_eeprom_get(dev, MT_EE_NIC_CONF_1);\n\n\tmt76x02_eeprom_parse_hw_cap(dev);\n\tdev_dbg(dev->mt76.dev, \"2GHz %d 5GHz %d\\n\",\n\t\tdev->mphy.cap.has_2ghz, dev->mphy.cap.has_5ghz);\n\n\tif (dev->no_2ghz) {\n\t\tdev->mphy.cap.has_2ghz = false;\n\t\tdev_dbg(dev->mt76.dev, \"mask out 2GHz support\\n\");\n\t}\n\n\tif (is_mt7630(dev)) {\n\t\tdev->mphy.cap.has_5ghz = false;\n\t\tdev_dbg(dev->mt76.dev, \"mask out 5GHz support\\n\");\n\t}\n\n\tif (!mt76x02_field_valid(nic_conf1 & 0xff))\n\t\tnic_conf1 &= 0xff00;\n\n\tif (nic_conf1 & MT_EE_NIC_CONF_1_HW_RF_CTRL)\n\t\tdev_dbg(dev->mt76.dev,\n\t\t\t\"driver does not support HW RF ctrl\\n\");\n\n\tif (!mt76x02_field_valid(nic_conf0 >> 8))\n\t\treturn;\n\n\tif (FIELD_GET(MT_EE_NIC_CONF_0_RX_PATH, nic_conf0) > 1 ||\n\t    FIELD_GET(MT_EE_NIC_CONF_0_TX_PATH, nic_conf0) > 1)\n\t\tdev_err(dev->mt76.dev, \"invalid tx-rx stream\\n\");\n}\n\nstatic void mt76x0_set_temp_offset(struct mt76x02_dev *dev)\n{\n\tu8 val;\n\n\tval = mt76x02_eeprom_get(dev, MT_EE_2G_TARGET_POWER) >> 8;\n\tif (mt76x02_field_valid(val))\n\t\tdev->cal.rx.temp_offset = mt76x02_sign_extend(val, 8);\n\telse\n\t\tdev->cal.rx.temp_offset = -10;\n}\n\nstatic void mt76x0_set_freq_offset(struct mt76x02_dev *dev)\n{\n\tstruct mt76x02_rx_freq_cal *caldata = &dev->cal.rx;\n\tu8 val;\n\n\tval = mt76x02_eeprom_get(dev, MT_EE_FREQ_OFFSET);\n\tif (!mt76x02_field_valid(val))\n\t\tval = 0;\n\tcaldata->freq_offset = val;\n\n\tval = mt76x02_eeprom_get(dev, MT_EE_TSSI_BOUND4) >> 8;\n\tif (!mt76x02_field_valid(val))\n\t\tval = 0;\n\n\tcaldata->freq_offset -= mt76x02_sign_extend(val, 8);\n}\n\nvoid mt76x0_read_rx_gain(struct mt76x02_dev *dev)\n{\n\tstruct ieee80211_channel *chan = dev->mphy.chandef.chan;\n\tstruct mt76x02_rx_freq_cal *caldata = &dev->cal.rx;\n\ts8 val, lna_5g[3], lna_2g;\n\tu16 rssi_offset;\n\tint i;\n\n\tmt76x02_get_rx_gain(dev, chan->band, &rssi_offset, &lna_2g, lna_5g);\n\tcaldata->lna_gain = mt76x02_get_lna_gain(dev, &lna_2g, lna_5g, chan);\n\n\tfor (i = 0; i < ARRAY_SIZE(caldata->rssi_offset); i++) {\n\t\tval = rssi_offset >> (8 * i);\n\t\tif (val < -10 || val > 10)\n\t\t\tval = 0;\n\n\t\tcaldata->rssi_offset[i] = val;\n\t}\n}\n\nstatic s8 mt76x0_get_delta(struct mt76x02_dev *dev)\n{\n\tstruct cfg80211_chan_def *chandef = &dev->mphy.chandef;\n\tu8 val;\n\n\tif (chandef->width == NL80211_CHAN_WIDTH_80) {\n\t\tval = mt76x02_eeprom_get(dev, MT_EE_5G_TARGET_POWER) >> 8;\n\t} else if (chandef->width == NL80211_CHAN_WIDTH_40) {\n\t\tu16 data;\n\n\t\tdata = mt76x02_eeprom_get(dev, MT_EE_TX_POWER_DELTA_BW40);\n\t\tif (chandef->chan->band == NL80211_BAND_5GHZ)\n\t\t\tval = data >> 8;\n\t\telse\n\t\t\tval = data;\n\t} else {\n\t\treturn 0;\n\t}\n\n\treturn mt76x02_rate_power_val(val);\n}\n\nvoid mt76x0_get_tx_power_per_rate(struct mt76x02_dev *dev,\n\t\t\t\t  struct ieee80211_channel *chan,\n\t\t\t\t  struct mt76x02_rate_power *t)\n{\n\tbool is_2ghz = chan->band == NL80211_BAND_2GHZ;\n\tu16 val, addr;\n\ts8 delta;\n\n\tmemset(t, 0, sizeof(*t));\n\n\t \n\tval = mt76x02_eeprom_get(dev, MT_EE_TX_POWER_BYRATE_BASE);\n\tt->cck[0] = t->cck[1] = s6_to_s8(val);\n\tt->cck[2] = t->cck[3] = s6_to_s8(val >> 8);\n\n\t \n\taddr = is_2ghz ? MT_EE_TX_POWER_BYRATE_BASE + 2 : 0x120;\n\tval = mt76x02_eeprom_get(dev, addr);\n\tt->ofdm[0] = t->ofdm[1] = s6_to_s8(val);\n\tt->ofdm[2] = t->ofdm[3] = s6_to_s8(val >> 8);\n\n\t \n\taddr = is_2ghz ? MT_EE_TX_POWER_BYRATE_BASE + 4 : 0x122;\n\tval = mt76x02_eeprom_get(dev, addr);\n\tt->ofdm[4] = t->ofdm[5] = s6_to_s8(val);\n\tt->ofdm[6] = t->ofdm[7] = s6_to_s8(val >> 8);\n\n\t \n\taddr = is_2ghz ? MT_EE_TX_POWER_BYRATE_BASE + 6 : 0x124;\n\tval = mt76x02_eeprom_get(dev, addr);\n\tt->ht[0] = t->ht[1] = s6_to_s8(val);\n\tt->ht[2] = t->ht[3] = s6_to_s8(val >> 8);\n\n\t \n\taddr = is_2ghz ? MT_EE_TX_POWER_BYRATE_BASE + 8 : 0x126;\n\tval = mt76x02_eeprom_get(dev, addr);\n\tt->ht[4] = t->ht[5] = s6_to_s8(val);\n\tt->ht[6] = t->ht[7] = s6_to_s8(val >> 8);\n\n\t \n\tval = mt76x02_eeprom_get(dev, 0x12c);\n\tt->vht[0] = s6_to_s8(val);\n\tt->vht[1] = s6_to_s8(val >> 8);\n\n\tdelta = mt76x0_tssi_enabled(dev) ? 0 : mt76x0_get_delta(dev);\n\tmt76x02_add_rate_power_offset(t, delta);\n}\n\nvoid mt76x0_get_power_info(struct mt76x02_dev *dev,\n\t\t\t   struct ieee80211_channel *chan, s8 *tp)\n{\n\tstatic const struct mt76x0_chan_map {\n\t\tu8 chan;\n\t\tu8 offset;\n\t} chan_map[] = {\n\t\t{   2,  0 }, {   4,  2 }, {   6,  4 }, {   8,  6 },\n\t\t{  10,  8 }, {  12, 10 }, {  14, 12 }, {  38,  0 },\n\t\t{  44,  2 }, {  48,  4 }, {  54,  6 }, {  60,  8 },\n\t\t{  64, 10 }, { 102, 12 }, { 108, 14 }, { 112, 16 },\n\t\t{ 118, 18 }, { 124, 20 }, { 128, 22 }, { 134, 24 },\n\t\t{ 140, 26 }, { 151, 28 }, { 157, 30 }, { 161, 32 },\n\t\t{ 167, 34 }, { 171, 36 }, { 175, 38 },\n\t};\n\tu8 offset, addr;\n\tint i, idx = 0;\n\tu16 data;\n\n\tif (mt76x0_tssi_enabled(dev)) {\n\t\ts8 target_power;\n\n\t\tif (chan->band == NL80211_BAND_5GHZ)\n\t\t\tdata = mt76x02_eeprom_get(dev, MT_EE_5G_TARGET_POWER);\n\t\telse\n\t\t\tdata = mt76x02_eeprom_get(dev, MT_EE_2G_TARGET_POWER);\n\t\ttarget_power = (data & 0xff) - dev->rate_power.ofdm[7];\n\t\t*tp = target_power + mt76x0_get_delta(dev);\n\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(chan_map); i++) {\n\t\tif (chan->hw_value <= chan_map[i].chan) {\n\t\t\tidx = (chan->hw_value == chan_map[i].chan);\n\t\t\toffset = chan_map[i].offset;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == ARRAY_SIZE(chan_map))\n\t\toffset = chan_map[0].offset;\n\n\tif (chan->band == NL80211_BAND_2GHZ) {\n\t\taddr = MT_EE_TX_POWER_DELTA_BW80 + offset;\n\t} else {\n\t\tswitch (chan->hw_value) {\n\t\tcase 42:\n\t\t\toffset = 2;\n\t\t\tbreak;\n\t\tcase 58:\n\t\t\toffset = 8;\n\t\t\tbreak;\n\t\tcase 106:\n\t\t\toffset = 14;\n\t\t\tbreak;\n\t\tcase 122:\n\t\t\toffset = 20;\n\t\t\tbreak;\n\t\tcase 155:\n\t\t\toffset = 30;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\taddr = MT_EE_TX_POWER_0_GRP4_TSSI_SLOPE + 2 + offset;\n\t}\n\n\tdata = mt76x02_eeprom_get(dev, addr);\n\t*tp = data >> (8 * idx);\n\tif (*tp < 0 || *tp > 0x3f)\n\t\t*tp = 5;\n}\n\nstatic int mt76x0_check_eeprom(struct mt76x02_dev *dev)\n{\n\tu16 val;\n\n\tval = get_unaligned_le16(dev->mt76.eeprom.data);\n\tif (!val)\n\t\tval = get_unaligned_le16(dev->mt76.eeprom.data +\n\t\t\t\t\t MT_EE_PCI_ID);\n\n\tswitch (val) {\n\tcase 0x7650:\n\tcase 0x7610:\n\t\treturn 0;\n\tdefault:\n\t\tdev_err(dev->mt76.dev, \"EEPROM data check failed: %04x\\n\",\n\t\t\tval);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int mt76x0_load_eeprom(struct mt76x02_dev *dev)\n{\n\tint found;\n\n\tfound = mt76_eeprom_init(&dev->mt76, MT76X0_EEPROM_SIZE);\n\tif (found < 0)\n\t\treturn found;\n\n\tif (found && !mt76x0_check_eeprom(dev))\n\t\treturn 0;\n\n\tfound = mt76x0_efuse_physical_size_check(dev);\n\tif (found < 0)\n\t\treturn found;\n\n\treturn mt76x02_get_efuse_data(dev, 0, dev->mt76.eeprom.data,\n\t\t\t\t      MT76X0_EEPROM_SIZE, MT_EE_READ);\n}\n\nint mt76x0_eeprom_init(struct mt76x02_dev *dev)\n{\n\tu8 version, fae;\n\tu16 data;\n\tint err;\n\n\terr = mt76x0_load_eeprom(dev);\n\tif (err < 0)\n\t\treturn err;\n\n\tdata = mt76x02_eeprom_get(dev, MT_EE_VERSION);\n\tversion = data >> 8;\n\tfae = data;\n\n\tif (version > MT76X0U_EE_MAX_VER)\n\t\tdev_warn(dev->mt76.dev,\n\t\t\t \"Warning: unsupported EEPROM version %02hhx\\n\",\n\t\t\t version);\n\tdev_info(dev->mt76.dev, \"EEPROM ver:%02hhx fae:%02hhx\\n\",\n\t\t version, fae);\n\n\tmemcpy(dev->mphy.macaddr, (u8 *)dev->mt76.eeprom.data + MT_EE_MAC_ADDR,\n\t       ETH_ALEN);\n\tmt76_eeprom_override(&dev->mphy);\n\tmt76x02_mac_setaddr(dev, dev->mphy.macaddr);\n\n\tmt76x0_set_chip_cap(dev);\n\tmt76x0_set_freq_offset(dev);\n\tmt76x0_set_temp_offset(dev);\n\n\treturn 0;\n}\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}