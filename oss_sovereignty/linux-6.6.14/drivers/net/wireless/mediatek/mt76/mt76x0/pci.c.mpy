{
  "module_name": "pci.c",
  "hash_id": "898c89b70badbeaa73f006b3d1b38609d98499220e7b2060969f7a6ec237298c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt76x0/pci.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#include \"mt76x0.h\"\n#include \"mcu.h\"\n\nstatic int mt76x0e_start(struct ieee80211_hw *hw)\n{\n\tstruct mt76x02_dev *dev = hw->priv;\n\n\tmt76x02_mac_start(dev);\n\tmt76x0_phy_calibrate(dev, true);\n\tieee80211_queue_delayed_work(dev->mt76.hw, &dev->mphy.mac_work,\n\t\t\t\t     MT_MAC_WORK_INTERVAL);\n\tieee80211_queue_delayed_work(dev->mt76.hw, &dev->cal_work,\n\t\t\t\t     MT_CALIBRATE_INTERVAL);\n\tset_bit(MT76_STATE_RUNNING, &dev->mphy.state);\n\n\treturn 0;\n}\n\nstatic void mt76x0e_stop_hw(struct mt76x02_dev *dev)\n{\n\tcancel_delayed_work_sync(&dev->cal_work);\n\tcancel_delayed_work_sync(&dev->mphy.mac_work);\n\tclear_bit(MT76_RESTART, &dev->mphy.state);\n\n\tif (!mt76_poll(dev, MT_WPDMA_GLO_CFG, MT_WPDMA_GLO_CFG_TX_DMA_BUSY,\n\t\t       0, 1000))\n\t\tdev_warn(dev->mt76.dev, \"TX DMA did not stop\\n\");\n\tmt76_clear(dev, MT_WPDMA_GLO_CFG, MT_WPDMA_GLO_CFG_TX_DMA_EN);\n\n\tmt76x0_mac_stop(dev);\n\n\tif (!mt76_poll(dev, MT_WPDMA_GLO_CFG, MT_WPDMA_GLO_CFG_RX_DMA_BUSY,\n\t\t       0, 1000))\n\t\tdev_warn(dev->mt76.dev, \"TX DMA did not stop\\n\");\n\tmt76_clear(dev, MT_WPDMA_GLO_CFG, MT_WPDMA_GLO_CFG_RX_DMA_EN);\n}\n\nstatic void mt76x0e_stop(struct ieee80211_hw *hw)\n{\n\tstruct mt76x02_dev *dev = hw->priv;\n\n\tclear_bit(MT76_STATE_RUNNING, &dev->mphy.state);\n\tmt76x0e_stop_hw(dev);\n}\n\nstatic void\nmt76x0e_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t      u32 queues, bool drop)\n{\n}\n\nstatic const struct ieee80211_ops mt76x0e_ops = {\n\t.tx = mt76x02_tx,\n\t.start = mt76x0e_start,\n\t.stop = mt76x0e_stop,\n\t.add_interface = mt76x02_add_interface,\n\t.remove_interface = mt76x02_remove_interface,\n\t.config = mt76x0_config,\n\t.configure_filter = mt76x02_configure_filter,\n\t.bss_info_changed = mt76x02_bss_info_changed,\n\t.sta_state = mt76_sta_state,\n\t.sta_pre_rcu_remove = mt76_sta_pre_rcu_remove,\n\t.set_key = mt76x02_set_key,\n\t.conf_tx = mt76x02_conf_tx,\n\t.sw_scan_start = mt76_sw_scan,\n\t.sw_scan_complete = mt76x02_sw_scan_complete,\n\t.ampdu_action = mt76x02_ampdu_action,\n\t.sta_rate_tbl_update = mt76x02_sta_rate_tbl_update,\n\t.wake_tx_queue = mt76_wake_tx_queue,\n\t.get_survey = mt76_get_survey,\n\t.get_txpower = mt76_get_txpower,\n\t.flush = mt76x0e_flush,\n\t.set_tim = mt76_set_tim,\n\t.release_buffered_frames = mt76_release_buffered_frames,\n\t.set_coverage_class = mt76x02_set_coverage_class,\n\t.set_rts_threshold = mt76x02_set_rts_threshold,\n\t.get_antenna = mt76_get_antenna,\n\t.reconfig_complete = mt76x02_reconfig_complete,\n\t.set_sar_specs = mt76x0_set_sar_specs,\n};\n\nstatic int mt76x0e_init_hardware(struct mt76x02_dev *dev, bool resume)\n{\n\tint err;\n\n\tmt76x0_chip_onoff(dev, true, false);\n\tif (!mt76x02_wait_for_mac(&dev->mt76))\n\t\treturn -ETIMEDOUT;\n\n\tmt76x02_dma_disable(dev);\n\terr = mt76x0e_mcu_init(dev);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!resume) {\n\t\terr = mt76x02_dma_init(dev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = mt76x0_init_hardware(dev);\n\tif (err < 0)\n\t\treturn err;\n\n\tmt76x02e_init_beacon_config(dev);\n\n\tif (mt76_chip(&dev->mt76) == 0x7610) {\n\t\tu16 val;\n\n\t\tmt76_clear(dev, MT_COEXCFG0, BIT(0));\n\n\t\tval = mt76x02_eeprom_get(dev, MT_EE_NIC_CONF_0);\n\t\tif (!(val & MT_EE_NIC_CONF_0_PA_IO_CURRENT))\n\t\t\tmt76_set(dev, MT_XO_CTRL7, 0xc03);\n\t}\n\n\tmt76_clear(dev, 0x110, BIT(9));\n\tmt76_set(dev, MT_MAX_LEN_CFG, BIT(13));\n\n\treturn 0;\n}\n\nstatic int mt76x0e_register_device(struct mt76x02_dev *dev)\n{\n\tint err;\n\n\terr = mt76x0e_init_hardware(dev, false);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = mt76x0_register_device(dev);\n\tif (err < 0)\n\t\treturn err;\n\n\tset_bit(MT76_STATE_INITIALIZED, &dev->mphy.state);\n\n\treturn 0;\n}\n\nstatic int\nmt76x0e_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstatic const struct mt76_driver_ops drv_ops = {\n\t\t.txwi_size = sizeof(struct mt76x02_txwi),\n\t\t.drv_flags = MT_DRV_TX_ALIGNED4_SKBS |\n\t\t\t     MT_DRV_SW_RX_AIRTIME,\n\t\t.survey_flags = SURVEY_INFO_TIME_TX,\n\t\t.update_survey = mt76x02_update_channel,\n\t\t.tx_prepare_skb = mt76x02_tx_prepare_skb,\n\t\t.tx_complete_skb = mt76x02_tx_complete_skb,\n\t\t.rx_skb = mt76x02_queue_rx_skb,\n\t\t.rx_poll_complete = mt76x02_rx_poll_complete,\n\t\t.sta_ps = mt76x02_sta_ps,\n\t\t.sta_add = mt76x02_sta_add,\n\t\t.sta_remove = mt76x02_sta_remove,\n\t};\n\tstruct mt76x02_dev *dev;\n\tstruct mt76_dev *mdev;\n\tint ret;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pcim_iomap_regions(pdev, BIT(0), pci_name(pdev));\n\tif (ret)\n\t\treturn ret;\n\n\tpci_set_master(pdev);\n\n\tret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\tmt76_pci_disable_aspm(pdev);\n\n\tmdev = mt76_alloc_device(&pdev->dev, sizeof(*dev), &mt76x0e_ops,\n\t\t\t\t &drv_ops);\n\tif (!mdev)\n\t\treturn -ENOMEM;\n\n\tdev = container_of(mdev, struct mt76x02_dev, mt76);\n\tmutex_init(&dev->phy_mutex);\n\n\tmt76_mmio_init(mdev, pcim_iomap_table(pdev)[0]);\n\n\tmdev->rev = mt76_rr(dev, MT_ASIC_VERSION);\n\tdev_info(mdev->dev, \"ASIC revision: %08x\\n\", mdev->rev);\n\n\tmt76_wr(dev, MT_INT_MASK_CSR, 0);\n\n\tret = devm_request_irq(mdev->dev, pdev->irq, mt76x02_irq_handler,\n\t\t\t       IRQF_SHARED, KBUILD_MODNAME, dev);\n\tif (ret)\n\t\tgoto error;\n\n\tret = mt76x0e_register_device(dev);\n\tif (ret < 0)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tmt76_free_device(&dev->mt76);\n\n\treturn ret;\n}\n\nstatic void mt76x0e_cleanup(struct mt76x02_dev *dev)\n{\n\tclear_bit(MT76_STATE_INITIALIZED, &dev->mphy.state);\n\ttasklet_disable(&dev->mt76.pre_tbtt_tasklet);\n\tmt76x0_chip_onoff(dev, false, false);\n\tmt76x0e_stop_hw(dev);\n\tmt76_dma_cleanup(&dev->mt76);\n\tmt76x02_mcu_cleanup(dev);\n}\n\nstatic void\nmt76x0e_remove(struct pci_dev *pdev)\n{\n\tstruct mt76_dev *mdev = pci_get_drvdata(pdev);\n\tstruct mt76x02_dev *dev = container_of(mdev, struct mt76x02_dev, mt76);\n\n\tmt76_unregister_device(mdev);\n\tmt76x0e_cleanup(dev);\n\tmt76_free_device(mdev);\n}\n\n#ifdef CONFIG_PM\nstatic int mt76x0e_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tstruct mt76_dev *mdev = pci_get_drvdata(pdev);\n\tstruct mt76x02_dev *dev = container_of(mdev, struct mt76x02_dev, mt76);\n\tint i;\n\n\tmt76_worker_disable(&mdev->tx_worker);\n\tfor (i = 0; i < ARRAY_SIZE(mdev->phy.q_tx); i++)\n\t\tmt76_queue_tx_cleanup(dev, mdev->phy.q_tx[i], true);\n\tfor (i = 0; i < ARRAY_SIZE(mdev->q_mcu); i++)\n\t\tmt76_queue_tx_cleanup(dev, mdev->q_mcu[i], true);\n\tnapi_disable(&mdev->tx_napi);\n\n\tmt76_for_each_q_rx(mdev, i)\n\t\tnapi_disable(&mdev->napi[i]);\n\n\tmt76x02_dma_disable(dev);\n\tmt76x02_mcu_cleanup(dev);\n\tmt76x0_chip_onoff(dev, false, false);\n\n\tpci_enable_wake(pdev, pci_choose_state(pdev, state), true);\n\tpci_save_state(pdev);\n\n\treturn pci_set_power_state(pdev, pci_choose_state(pdev, state));\n}\n\nstatic int mt76x0e_resume(struct pci_dev *pdev)\n{\n\tstruct mt76_dev *mdev = pci_get_drvdata(pdev);\n\tstruct mt76x02_dev *dev = container_of(mdev, struct mt76x02_dev, mt76);\n\tint err, i;\n\n\terr = pci_set_power_state(pdev, PCI_D0);\n\tif (err)\n\t\treturn err;\n\n\tpci_restore_state(pdev);\n\n\tmt76_worker_enable(&mdev->tx_worker);\n\n\tlocal_bh_disable();\n\tmt76_for_each_q_rx(mdev, i) {\n\t\tmt76_queue_rx_reset(dev, i);\n\t\tnapi_enable(&mdev->napi[i]);\n\t\tnapi_schedule(&mdev->napi[i]);\n\t}\n\n\tnapi_enable(&mdev->tx_napi);\n\tnapi_schedule(&mdev->tx_napi);\n\tlocal_bh_enable();\n\n\treturn mt76x0e_init_hardware(dev, true);\n}\n#endif  \n\nstatic const struct pci_device_id mt76x0e_device_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MEDIATEK, 0x7610) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MEDIATEK, 0x7630) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MEDIATEK, 0x7650) },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(pci, mt76x0e_device_table);\nMODULE_FIRMWARE(MT7610E_FIRMWARE);\nMODULE_FIRMWARE(MT7650E_FIRMWARE);\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\nstatic struct pci_driver mt76x0e_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= mt76x0e_device_table,\n\t.probe\t\t= mt76x0e_probe,\n\t.remove\t\t= mt76x0e_remove,\n#ifdef CONFIG_PM\n\t.suspend\t= mt76x0e_suspend,\n\t.resume\t\t= mt76x0e_resume,\n#endif  \n};\n\nmodule_pci_driver(mt76x0e_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}