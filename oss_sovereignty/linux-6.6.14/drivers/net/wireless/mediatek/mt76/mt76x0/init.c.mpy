{
  "module_name": "init.c",
  "hash_id": "0183088db9bf70777508219c1ee4a87e6dea75208494a18e1dde80d76a0275b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt76x0/init.c",
  "human_readable_source": "\n \n\n#include \"mt76x0.h\"\n#include \"eeprom.h\"\n#include \"mcu.h\"\n#include \"initvals.h\"\n#include \"initvals_init.h\"\n#include \"../mt76x02_phy.h\"\n\nstatic void\nmt76x0_set_wlan_state(struct mt76x02_dev *dev, u32 val, bool enable)\n{\n\tu32 mask = MT_CMB_CTRL_XTAL_RDY | MT_CMB_CTRL_PLL_LD;\n\n\t \n\n\tif (enable)\n\t\tval |= (MT_WLAN_FUN_CTRL_WLAN_EN |\n\t\t\tMT_WLAN_FUN_CTRL_WLAN_CLK_EN);\n\telse\n\t\tval &= ~(MT_WLAN_FUN_CTRL_WLAN_EN);\n\n\tmt76_wr(dev, MT_WLAN_FUN_CTRL, val);\n\tudelay(20);\n\n\t \n\tif (enable && !mt76_poll(dev, MT_CMB_CTRL, mask, mask, 2000))\n\t\tdev_err(dev->mt76.dev, \"PLL and XTAL check failed\\n\");\n}\n\nvoid mt76x0_chip_onoff(struct mt76x02_dev *dev, bool enable, bool reset)\n{\n\tu32 val;\n\n\tval = mt76_rr(dev, MT_WLAN_FUN_CTRL);\n\n\tif (reset) {\n\t\tval |= MT_WLAN_FUN_CTRL_GPIO_OUT_EN;\n\t\tval &= ~MT_WLAN_FUN_CTRL_FRC_WL_ANT_SEL;\n\n\t\tif (val & MT_WLAN_FUN_CTRL_WLAN_EN) {\n\t\t\tval |= (MT_WLAN_FUN_CTRL_WLAN_RESET |\n\t\t\t\tMT_WLAN_FUN_CTRL_WLAN_RESET_RF);\n\t\t\tmt76_wr(dev, MT_WLAN_FUN_CTRL, val);\n\t\t\tudelay(20);\n\n\t\t\tval &= ~(MT_WLAN_FUN_CTRL_WLAN_RESET |\n\t\t\t\t MT_WLAN_FUN_CTRL_WLAN_RESET_RF);\n\t\t}\n\t}\n\n\tmt76_wr(dev, MT_WLAN_FUN_CTRL, val);\n\tudelay(20);\n\n\tmt76x0_set_wlan_state(dev, val, enable);\n}\nEXPORT_SYMBOL_GPL(mt76x0_chip_onoff);\n\nstatic void mt76x0_reset_csr_bbp(struct mt76x02_dev *dev)\n{\n\tmt76_wr(dev, MT_MAC_SYS_CTRL,\n\t\tMT_MAC_SYS_CTRL_RESET_CSR |\n\t\tMT_MAC_SYS_CTRL_RESET_BBP);\n\tmsleep(200);\n\tmt76_clear(dev, MT_MAC_SYS_CTRL,\n\t\t   MT_MAC_SYS_CTRL_RESET_CSR |\n\t\t   MT_MAC_SYS_CTRL_RESET_BBP);\n}\n\n#define RANDOM_WRITE(dev, tab)\t\t\t\\\n\tmt76_wr_rp(dev, MT_MCU_MEMMAP_WLAN,\t\\\n\t\t   tab, ARRAY_SIZE(tab))\n\nstatic int mt76x0_init_bbp(struct mt76x02_dev *dev)\n{\n\tint ret, i;\n\n\tret = mt76x0_phy_wait_bbp_ready(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tRANDOM_WRITE(dev, mt76x0_bbp_init_tab);\n\n\tfor (i = 0; i < ARRAY_SIZE(mt76x0_bbp_switch_tab); i++) {\n\t\tconst struct mt76x0_bbp_switch_item *item = &mt76x0_bbp_switch_tab[i];\n\t\tconst struct mt76_reg_pair *pair = &item->reg_pair;\n\n\t\tif (((RF_G_BAND | RF_BW_20) & item->bw_band) == (RF_G_BAND | RF_BW_20))\n\t\t\tmt76_wr(dev, pair->reg, pair->value);\n\t}\n\n\tRANDOM_WRITE(dev, mt76x0_dcoc_tab);\n\n\treturn 0;\n}\n\nstatic void mt76x0_init_mac_registers(struct mt76x02_dev *dev)\n{\n\tRANDOM_WRITE(dev, common_mac_reg_table);\n\n\t \n\tRANDOM_WRITE(dev, mt76x0_mac_reg_table);\n\n\t \n\tmt76_clear(dev, MT_MAC_SYS_CTRL, 0x3);\n\n\t \n\tmt76_set(dev, MT_EXT_CCA_CFG, 0xf000);\n\n\tmt76_clear(dev, MT_FCE_L2_STUFF, MT_FCE_L2_STUFF_WR_MPDU_LEN_EN);\n\n\t \n\tmt76_rmw(dev, MT_WMM_CTRL, 0x3ff, 0x201);\n}\n\nvoid mt76x0_mac_stop(struct mt76x02_dev *dev)\n{\n\tint i = 200, ok = 0;\n\n\tmt76_clear(dev, MT_TXOP_CTRL_CFG, MT_TXOP_ED_CCA_EN);\n\n\t \n\twhile (i-- && ((mt76_rr(dev, 0x0438) & 0xffffffff) ||\n\t\t       (mt76_rr(dev, 0x0a30) & 0x000000ff) ||\n\t\t       (mt76_rr(dev, 0x0a34) & 0x00ff00ff)))\n\t\tmsleep(10);\n\n\tif (!mt76_poll(dev, MT_MAC_STATUS, MT_MAC_STATUS_TX, 0, 1000))\n\t\tdev_warn(dev->mt76.dev, \"Warning: MAC TX did not stop!\\n\");\n\n\tmt76_clear(dev, MT_MAC_SYS_CTRL, MT_MAC_SYS_CTRL_ENABLE_RX |\n\t\t\t\t\t MT_MAC_SYS_CTRL_ENABLE_TX);\n\n\t \n\tfor (i = 0; i < 200; i++) {\n\t\tif (!(mt76_rr(dev, MT_RXQ_STA) & 0x00ff0000) &&\n\t\t    !mt76_rr(dev, 0x0a30) &&\n\t\t    !mt76_rr(dev, 0x0a34)) {\n\t\t\tif (ok++ > 5)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tmsleep(1);\n\t}\n\n\tif (!mt76_poll(dev, MT_MAC_STATUS, MT_MAC_STATUS_RX, 0, 1000))\n\t\tdev_warn(dev->mt76.dev, \"Warning: MAC RX did not stop!\\n\");\n}\nEXPORT_SYMBOL_GPL(mt76x0_mac_stop);\n\nint mt76x0_init_hardware(struct mt76x02_dev *dev)\n{\n\tint ret, i, k;\n\n\tif (!mt76x02_wait_for_wpdma(&dev->mt76, 1000))\n\t\treturn -EIO;\n\n\t \n\tif (!mt76x02_wait_for_mac(&dev->mt76))\n\t\treturn -ETIMEDOUT;\n\n\tmt76x0_reset_csr_bbp(dev);\n\tret = mt76x02_mcu_function_select(dev, Q_SELECT, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tmt76x0_init_mac_registers(dev);\n\n\tif (!mt76x02_wait_for_txrx_idle(&dev->mt76))\n\t\treturn -EIO;\n\n\tret = mt76x0_init_bbp(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->mt76.rxfilter = mt76_rr(dev, MT_RX_FILTR_CFG);\n\n\tfor (i = 0; i < 16; i++)\n\t\tfor (k = 0; k < 4; k++)\n\t\t\tmt76x02_mac_shared_key_setup(dev, i, k, NULL);\n\n\tfor (i = 0; i < 256; i++)\n\t\tmt76x02_mac_wcid_setup(dev, i, 0, NULL);\n\n\tret = mt76x0_eeprom_init(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmt76x0_phy_init(dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76x0_init_hardware);\n\nstatic void\nmt76x0_init_txpower(struct mt76x02_dev *dev,\n\t\t    struct ieee80211_supported_band *sband)\n{\n\tstruct ieee80211_channel *chan;\n\tstruct mt76x02_rate_power t;\n\ts8 tp;\n\tint i;\n\n\tfor (i = 0; i < sband->n_channels; i++) {\n\t\tchan = &sband->channels[i];\n\n\t\tmt76x0_get_tx_power_per_rate(dev, chan, &t);\n\t\tmt76x0_get_power_info(dev, chan, &tp);\n\n\t\tchan->orig_mpwr = (mt76x02_get_max_rate_power(&t) + tp) / 2;\n\t\tchan->max_power = min_t(int, chan->max_reg_power,\n\t\t\t\t\tchan->orig_mpwr);\n\t}\n}\n\nint mt76x0_register_device(struct mt76x02_dev *dev)\n{\n\tint ret;\n\n\tret = mt76x02_init_device(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmt76x02_config_mac_addr_list(dev);\n\n\tret = mt76_register_device(&dev->mt76, true, mt76x02_rates,\n\t\t\t\t   ARRAY_SIZE(mt76x02_rates));\n\tif (ret)\n\t\treturn ret;\n\n\tif (dev->mphy.cap.has_5ghz) {\n\t\tstruct ieee80211_supported_band *sband;\n\n\t\tsband = &dev->mphy.sband_5g.sband;\n\t\tsband->vht_cap.cap &= ~IEEE80211_VHT_CAP_RXLDPC;\n\t\tmt76x0_init_txpower(dev, sband);\n\t}\n\n\tif (dev->mphy.cap.has_2ghz)\n\t\tmt76x0_init_txpower(dev, &dev->mphy.sband_2g.sband);\n\n\tmt76x02_init_debugfs(dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76x0_register_device);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}