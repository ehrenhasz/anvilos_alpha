{
  "module_name": "usb.c",
  "hash_id": "70f16a3c9f6aa12663bbd7aacac0cf2530782120f7b5180864afc7b6ec41808f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt76x0/usb.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n\n#include \"mt76x0.h\"\n#include \"mcu.h\"\n#include \"../mt76x02_usb.h\"\n\nstatic struct usb_device_id mt76x0_device_table[] = {\n\t{ USB_DEVICE(0x148F, 0x7610) },\t \n\t{ USB_DEVICE(0x13B1, 0x003E) },\t \n\t{ USB_DEVICE(0x0E8D, 0x7610) },\t \n\t{ USB_DEVICE(0x7392, 0xa711) },\t \n\t{ USB_DEVICE(0x7392, 0xb711) },\t \n\t{ USB_DEVICE(0x148f, 0x761a) },\t \n\t{ USB_DEVICE(0x148f, 0x760a) },\t \n\t{ USB_DEVICE(0x0b05, 0x17d1) },\t \n\t{ USB_DEVICE(0x0b05, 0x17db) },\t \n\t{ USB_DEVICE(0x0df6, 0x0075) },\t \n\t{ USB_DEVICE(0x2019, 0xab31) },\t \n\t{ USB_DEVICE(0x2001, 0x3d02) },\t \n\t{ USB_DEVICE(0x0586, 0x3425) },\t \n\t{ USB_DEVICE(0x07b8, 0x7610) },\t \n\t{ USB_DEVICE(0x04bb, 0x0951) },\t \n\t{ USB_DEVICE(0x057c, 0x8502) },\t \n\t{ USB_DEVICE(0x293c, 0x5702) },\t \n\t{ USB_DEVICE(0x20f4, 0x806b) },\t \n\t{ USB_DEVICE(0x7392, 0xc711) },  \n\t{ USB_DEVICE(0x0df6, 0x0079) },  \n\t{ USB_DEVICE(0x2357, 0x0123) },  \n\t{ USB_DEVICE(0x2357, 0x010b) },  \n\t \n\t{ USB_DEVICE(0x2357, 0x0105), .driver_info = 1, },\n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x0E8D, 0x7630, 0xff, 0x2, 0xff)},\n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x0E8D, 0x7650, 0xff, 0x2, 0xff)},\n\t{ 0, }\n};\n\nstatic void mt76x0_init_usb_dma(struct mt76x02_dev *dev)\n{\n\tu32 val;\n\n\tval = mt76_rr(dev, MT_USB_DMA_CFG);\n\n\tval |= MT_USB_DMA_CFG_RX_BULK_EN |\n\t       MT_USB_DMA_CFG_TX_BULK_EN;\n\n\t \n\tval &= ~MT_USB_DMA_CFG_RX_BULK_AGG_EN;\n\tmt76_wr(dev, MT_USB_DMA_CFG, val);\n\n\tval = mt76_rr(dev, MT_COM_REG0);\n\tif (val & 1)\n\t\tdev_dbg(dev->mt76.dev, \"MCU not ready\\n\");\n\n\tval = mt76_rr(dev, MT_USB_DMA_CFG);\n\n\tval |= MT_USB_DMA_CFG_RX_DROP_OR_PAD;\n\tmt76_wr(dev, MT_USB_DMA_CFG, val);\n\tval &= ~MT_USB_DMA_CFG_RX_DROP_OR_PAD;\n\tmt76_wr(dev, MT_USB_DMA_CFG, val);\n}\n\nstatic void mt76x0u_cleanup(struct mt76x02_dev *dev)\n{\n\tclear_bit(MT76_STATE_INITIALIZED, &dev->mphy.state);\n\tmt76x0_chip_onoff(dev, false, false);\n\tmt76u_queues_deinit(&dev->mt76);\n}\n\nstatic void mt76x0u_stop(struct ieee80211_hw *hw)\n{\n\tstruct mt76x02_dev *dev = hw->priv;\n\n\tclear_bit(MT76_STATE_RUNNING, &dev->mphy.state);\n\tcancel_delayed_work_sync(&dev->cal_work);\n\tcancel_delayed_work_sync(&dev->mphy.mac_work);\n\tmt76u_stop_tx(&dev->mt76);\n\tmt76x02u_exit_beacon_config(dev);\n\n\tif (test_bit(MT76_REMOVED, &dev->mphy.state))\n\t\treturn;\n\n\tif (!mt76_poll(dev, MT_USB_DMA_CFG, MT_USB_DMA_CFG_TX_BUSY, 0, 1000))\n\t\tdev_warn(dev->mt76.dev, \"TX DMA did not stop\\n\");\n\n\tmt76x0_mac_stop(dev);\n\n\tif (!mt76_poll(dev, MT_USB_DMA_CFG, MT_USB_DMA_CFG_RX_BUSY, 0, 1000))\n\t\tdev_warn(dev->mt76.dev, \"RX DMA did not stop\\n\");\n}\n\nstatic int mt76x0u_start(struct ieee80211_hw *hw)\n{\n\tstruct mt76x02_dev *dev = hw->priv;\n\tint ret;\n\n\tret = mt76x02u_mac_start(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmt76x0_phy_calibrate(dev, true);\n\tieee80211_queue_delayed_work(dev->mt76.hw, &dev->mphy.mac_work,\n\t\t\t\t     MT_MAC_WORK_INTERVAL);\n\tieee80211_queue_delayed_work(dev->mt76.hw, &dev->cal_work,\n\t\t\t\t     MT_CALIBRATE_INTERVAL);\n\tset_bit(MT76_STATE_RUNNING, &dev->mphy.state);\n\treturn 0;\n}\n\nstatic const struct ieee80211_ops mt76x0u_ops = {\n\t.tx = mt76x02_tx,\n\t.start = mt76x0u_start,\n\t.stop = mt76x0u_stop,\n\t.add_interface = mt76x02_add_interface,\n\t.remove_interface = mt76x02_remove_interface,\n\t.config = mt76x0_config,\n\t.configure_filter = mt76x02_configure_filter,\n\t.bss_info_changed = mt76x02_bss_info_changed,\n\t.sta_state = mt76_sta_state,\n\t.sta_pre_rcu_remove = mt76_sta_pre_rcu_remove,\n\t.set_key = mt76x02_set_key,\n\t.conf_tx = mt76x02_conf_tx,\n\t.sw_scan_start = mt76_sw_scan,\n\t.sw_scan_complete = mt76x02_sw_scan_complete,\n\t.ampdu_action = mt76x02_ampdu_action,\n\t.sta_rate_tbl_update = mt76x02_sta_rate_tbl_update,\n\t.set_rts_threshold = mt76x02_set_rts_threshold,\n\t.wake_tx_queue = mt76_wake_tx_queue,\n\t.get_txpower = mt76_get_txpower,\n\t.get_survey = mt76_get_survey,\n\t.set_tim = mt76_set_tim,\n\t.release_buffered_frames = mt76_release_buffered_frames,\n\t.get_antenna = mt76_get_antenna,\n\t.set_sar_specs = mt76x0_set_sar_specs,\n};\n\nstatic int mt76x0u_init_hardware(struct mt76x02_dev *dev, bool reset)\n{\n\tint err;\n\n\tmt76x0_chip_onoff(dev, true, reset);\n\n\tif (!mt76x02_wait_for_mac(&dev->mt76))\n\t\treturn -ETIMEDOUT;\n\n\terr = mt76x0u_mcu_init(dev);\n\tif (err < 0)\n\t\treturn err;\n\n\tmt76x0_init_usb_dma(dev);\n\terr = mt76x0_init_hardware(dev);\n\tif (err < 0)\n\t\treturn err;\n\n\tmt76x02u_init_beacon_config(dev);\n\n\tmt76_rmw(dev, MT_US_CYC_CFG, MT_US_CYC_CNT, 0x1e);\n\tmt76_wr(dev, MT_TXOP_CTRL_CFG,\n\t\tFIELD_PREP(MT_TXOP_TRUN_EN, 0x3f) |\n\t\tFIELD_PREP(MT_TXOP_EXT_CCA_DLY, 0x58));\n\n\treturn 0;\n}\n\nstatic int mt76x0u_register_device(struct mt76x02_dev *dev)\n{\n\tstruct ieee80211_hw *hw = dev->mt76.hw;\n\tstruct mt76_usb *usb = &dev->mt76.usb;\n\tint err;\n\n\tusb->mcu.data = devm_kmalloc(dev->mt76.dev, MCU_RESP_URB_SIZE,\n\t\t\t\t     GFP_KERNEL);\n\tif (!usb->mcu.data)\n\t\treturn -ENOMEM;\n\n\terr = mt76u_alloc_queues(&dev->mt76);\n\tif (err < 0)\n\t\tgoto out_err;\n\n\terr = mt76x0u_init_hardware(dev, true);\n\tif (err < 0)\n\t\tgoto out_err;\n\n\t \n\thw->max_tx_fragments = dev->mt76.usb.sg_en ? MT_TX_SG_MAX_SIZE : 1;\n\terr = mt76x0_register_device(dev);\n\tif (err < 0)\n\t\tgoto out_err;\n\n\tset_bit(MT76_STATE_INITIALIZED, &dev->mphy.state);\n\n\treturn 0;\n\nout_err:\n\tmt76x0u_cleanup(dev);\n\treturn err;\n}\n\nstatic int mt76x0u_probe(struct usb_interface *usb_intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstatic const struct mt76_driver_ops drv_ops = {\n\t\t.drv_flags = MT_DRV_SW_RX_AIRTIME,\n\t\t.survey_flags = SURVEY_INFO_TIME_TX,\n\t\t.update_survey = mt76x02_update_channel,\n\t\t.tx_prepare_skb = mt76x02u_tx_prepare_skb,\n\t\t.tx_complete_skb = mt76x02u_tx_complete_skb,\n\t\t.tx_status_data = mt76x02_tx_status_data,\n\t\t.rx_skb = mt76x02_queue_rx_skb,\n\t\t.sta_ps = mt76x02_sta_ps,\n\t\t.sta_add = mt76x02_sta_add,\n\t\t.sta_remove = mt76x02_sta_remove,\n\t};\n\tstruct usb_device *usb_dev = interface_to_usbdev(usb_intf);\n\tstruct mt76x02_dev *dev;\n\tstruct mt76_dev *mdev;\n\tu32 mac_rev;\n\tint ret;\n\n\tmdev = mt76_alloc_device(&usb_intf->dev, sizeof(*dev), &mt76x0u_ops,\n\t\t\t\t &drv_ops);\n\tif (!mdev)\n\t\treturn -ENOMEM;\n\n\tdev = container_of(mdev, struct mt76x02_dev, mt76);\n\tmutex_init(&dev->phy_mutex);\n\n\t \n\tif (id->driver_info)\n\t\tdev->no_2ghz = true;\n\n\tusb_dev = usb_get_dev(usb_dev);\n\tusb_reset_device(usb_dev);\n\n\tusb_set_intfdata(usb_intf, dev);\n\n\tmt76x02u_init_mcu(mdev);\n\tret = mt76u_init(mdev, usb_intf);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tmt76x0_chip_onoff(dev, false, false);\n\n\tif (!mt76x02_wait_for_mac(mdev)) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto err;\n\t}\n\n\tmdev->rev = mt76_rr(dev, MT_ASIC_VERSION);\n\tmac_rev = mt76_rr(dev, MT_MAC_CSR0);\n\tdev_info(mdev->dev, \"ASIC revision: %08x MAC revision: %08x\\n\",\n\t\t mdev->rev, mac_rev);\n\tif (!is_mt76x0(dev)) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t \n\tif (!(mt76_rr(dev, MT_EFUSE_CTRL) & MT_EFUSE_CTRL_SEL))\n\t\tdev_warn(mdev->dev, \"Warning: eFUSE not present\\n\");\n\n\tret = mt76x0u_register_device(dev);\n\tif (ret < 0)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tusb_set_intfdata(usb_intf, NULL);\n\tusb_put_dev(interface_to_usbdev(usb_intf));\n\tmt76u_queues_deinit(&dev->mt76);\n\tmt76_free_device(&dev->mt76);\n\n\treturn ret;\n}\n\nstatic void mt76x0_disconnect(struct usb_interface *usb_intf)\n{\n\tstruct mt76x02_dev *dev = usb_get_intfdata(usb_intf);\n\tbool initialized = test_bit(MT76_STATE_INITIALIZED, &dev->mphy.state);\n\n\tif (!initialized)\n\t\treturn;\n\n\tieee80211_unregister_hw(dev->mt76.hw);\n\tmt76x0u_cleanup(dev);\n\n\tusb_set_intfdata(usb_intf, NULL);\n\tusb_put_dev(interface_to_usbdev(usb_intf));\n\n\tmt76_free_device(&dev->mt76);\n}\n\nstatic int __maybe_unused mt76x0_suspend(struct usb_interface *usb_intf,\n\t\t\t\t\t pm_message_t state)\n{\n\tstruct mt76x02_dev *dev = usb_get_intfdata(usb_intf);\n\n\tmt76u_stop_rx(&dev->mt76);\n\tclear_bit(MT76_STATE_MCU_RUNNING, &dev->mphy.state);\n\tmt76x0_chip_onoff(dev, false, false);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused mt76x0_resume(struct usb_interface *usb_intf)\n{\n\tstruct mt76x02_dev *dev = usb_get_intfdata(usb_intf);\n\tint ret;\n\n\tret = mt76u_resume_rx(&dev->mt76);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = mt76x0u_init_hardware(dev, false);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tmt76x0u_cleanup(dev);\n\treturn ret;\n}\n\nMODULE_DEVICE_TABLE(usb, mt76x0_device_table);\nMODULE_FIRMWARE(MT7610E_FIRMWARE);\nMODULE_FIRMWARE(MT7610U_FIRMWARE);\nMODULE_LICENSE(\"GPL\");\n\nstatic struct usb_driver mt76x0_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= mt76x0_device_table,\n\t.probe\t\t= mt76x0u_probe,\n\t.disconnect\t= mt76x0_disconnect,\n\t.suspend\t= mt76x0_suspend,\n\t.resume\t\t= mt76x0_resume,\n\t.reset_resume\t= mt76x0_resume,\n\t.soft_unbind\t= 1,\n\t.disable_hub_initiated_lpm = 1,\n};\nmodule_usb_driver(mt76x0_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}