{
  "module_name": "mt76x02_usb_mcu.c",
  "hash_id": "1e3d267ec1aa7145ebe700dc0288df0ba072b7d418b40a847edc492ad2e2982c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt76x02_usb_mcu.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/firmware.h>\n\n#include \"mt76x02.h\"\n#include \"mt76x02_mcu.h\"\n#include \"mt76x02_usb.h\"\n\n#define MT_CMD_HDR_LEN\t\t\t4\n\n#define MT_FCE_DMA_ADDR\t\t\t0x0230\n#define MT_FCE_DMA_LEN\t\t\t0x0234\n\n#define MT_TX_CPU_FROM_FCE_CPU_DESC_IDX\t0x09a8\n\nstatic void\nmt76x02u_multiple_mcu_reads(struct mt76_dev *dev, u8 *data, int len)\n{\n\tstruct mt76_usb *usb = &dev->usb;\n\tint i;\n\n\tWARN_ON_ONCE(len / 8 != usb->mcu.rp_len);\n\n\tfor (i = 0; i < usb->mcu.rp_len; i++) {\n\t\tu32 reg = get_unaligned_le32(data + 8 * i) - usb->mcu.base;\n\t\tu32 val = get_unaligned_le32(data + 8 * i + 4);\n\n\t\tWARN_ON_ONCE(usb->mcu.rp[i].reg != reg);\n\t\tusb->mcu.rp[i].value = val;\n\t}\n}\n\nstatic int mt76x02u_mcu_wait_resp(struct mt76_dev *dev, u8 seq)\n{\n\tstruct mt76_usb *usb = &dev->usb;\n\tu8 *data = usb->mcu.data;\n\tint i, len, ret;\n\tu32 rxfce;\n\n\tfor (i = 0; i < 5; i++) {\n\t\tret = mt76u_bulk_msg(dev, data, MCU_RESP_URB_SIZE, &len,\n\t\t\t\t     300, MT_EP_IN_CMD_RESP);\n\t\tif (ret == -ETIMEDOUT)\n\t\t\tcontinue;\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (usb->mcu.rp)\n\t\t\tmt76x02u_multiple_mcu_reads(dev, data + 4, len - 8);\n\n\t\trxfce = get_unaligned_le32(data);\n\t\tif (seq == FIELD_GET(MT_RX_FCE_INFO_CMD_SEQ, rxfce) &&\n\t\t    FIELD_GET(MT_RX_FCE_INFO_EVT_TYPE, rxfce) == EVT_CMD_DONE)\n\t\t\treturn 0;\n\n\t\tdev_err(dev->dev, \"error: MCU resp evt:%lx seq:%hhx-%lx\\n\",\n\t\t\tFIELD_GET(MT_RX_FCE_INFO_EVT_TYPE, rxfce),\n\t\t\tseq, FIELD_GET(MT_RX_FCE_INFO_CMD_SEQ, rxfce));\n\t}\nout:\n\tdev_err(dev->dev, \"error: %s failed with %d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int\n__mt76x02u_mcu_send_msg(struct mt76_dev *dev, struct sk_buff *skb,\n\t\t\tint cmd, bool wait_resp)\n{\n\tu8 seq = 0;\n\tu32 info;\n\tint ret;\n\n\tif (test_bit(MT76_REMOVED, &dev->phy.state)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (wait_resp) {\n\t\tseq = ++dev->mcu.msg_seq & 0xf;\n\t\tif (!seq)\n\t\t\tseq = ++dev->mcu.msg_seq & 0xf;\n\t}\n\n\tinfo = FIELD_PREP(MT_MCU_MSG_CMD_SEQ, seq) |\n\t       FIELD_PREP(MT_MCU_MSG_CMD_TYPE, cmd) |\n\t       MT_MCU_MSG_TYPE_CMD;\n\tret = mt76x02u_skb_dma_info(skb, CPU_TX_PORT, info);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt76u_bulk_msg(dev, skb->data, skb->len, NULL, 500,\n\t\t\t     MT_EP_OUT_INBAND_CMD);\n\tif (ret)\n\t\tgoto out;\n\n\tif (wait_resp)\n\t\tret = mt76x02u_mcu_wait_resp(dev, seq);\n\nout:\n\tconsume_skb(skb);\n\n\treturn ret;\n}\n\nstatic int\nmt76x02u_mcu_send_msg(struct mt76_dev *dev, int cmd, const void *data,\n\t\t      int len, bool wait_resp)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = mt76_mcu_msg_alloc(dev, data, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&dev->mcu.mutex);\n\terr = __mt76x02u_mcu_send_msg(dev, skb, cmd, wait_resp);\n\tmutex_unlock(&dev->mcu.mutex);\n\n\treturn err;\n}\n\nstatic inline void skb_put_le32(struct sk_buff *skb, u32 val)\n{\n\tput_unaligned_le32(val, skb_put(skb, 4));\n}\n\nstatic int\nmt76x02u_mcu_wr_rp(struct mt76_dev *dev, u32 base,\n\t\t   const struct mt76_reg_pair *data, int n)\n{\n\tconst int max_vals_per_cmd = MT_INBAND_PACKET_MAX_LEN / 8;\n\tconst int CMD_RANDOM_WRITE = 12;\n\tstruct sk_buff *skb;\n\tint cnt, i, ret;\n\n\tif (!n)\n\t\treturn 0;\n\n\tcnt = min(max_vals_per_cmd, n);\n\n\tskb = alloc_skb(cnt * 8 + MT_DMA_HDR_LEN + 4, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tskb_reserve(skb, MT_DMA_HDR_LEN);\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tskb_put_le32(skb, base + data[i].reg);\n\t\tskb_put_le32(skb, data[i].value);\n\t}\n\n\tmutex_lock(&dev->mcu.mutex);\n\tret = __mt76x02u_mcu_send_msg(dev, skb, CMD_RANDOM_WRITE, cnt == n);\n\tmutex_unlock(&dev->mcu.mutex);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mt76x02u_mcu_wr_rp(dev, base, data + cnt, n - cnt);\n}\n\nstatic int\nmt76x02u_mcu_rd_rp(struct mt76_dev *dev, u32 base,\n\t\t   struct mt76_reg_pair *data, int n)\n{\n\tconst int CMD_RANDOM_READ = 10;\n\tconst int max_vals_per_cmd = MT_INBAND_PACKET_MAX_LEN / 8;\n\tstruct mt76_usb *usb = &dev->usb;\n\tstruct sk_buff *skb;\n\tint cnt, i, ret;\n\n\tif (!n)\n\t\treturn 0;\n\n\tcnt = min(max_vals_per_cmd, n);\n\tif (cnt != n)\n\t\treturn -EINVAL;\n\n\tskb = alloc_skb(cnt * 8 + MT_DMA_HDR_LEN + 4, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tskb_reserve(skb, MT_DMA_HDR_LEN);\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tskb_put_le32(skb, base + data[i].reg);\n\t\tskb_put_le32(skb, data[i].value);\n\t}\n\n\tmutex_lock(&dev->mcu.mutex);\n\n\tusb->mcu.rp = data;\n\tusb->mcu.rp_len = n;\n\tusb->mcu.base = base;\n\n\tret = __mt76x02u_mcu_send_msg(dev, skb, CMD_RANDOM_READ, true);\n\n\tusb->mcu.rp = NULL;\n\n\tmutex_unlock(&dev->mcu.mutex);\n\n\treturn ret;\n}\n\nvoid mt76x02u_mcu_fw_reset(struct mt76x02_dev *dev)\n{\n\tmt76u_vendor_request(&dev->mt76, MT_VEND_DEV_MODE,\n\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR,\n\t\t\t     0x1, 0, NULL, 0);\n}\nEXPORT_SYMBOL_GPL(mt76x02u_mcu_fw_reset);\n\nstatic int\n__mt76x02u_mcu_fw_send_data(struct mt76x02_dev *dev, u8 *data,\n\t\t\t    const void *fw_data, int len, u32 dst_addr)\n{\n\t__le32 info;\n\tu32 val;\n\tint err, data_len;\n\n\tinfo = cpu_to_le32(FIELD_PREP(MT_MCU_MSG_PORT, CPU_TX_PORT) |\n\t\t\t   FIELD_PREP(MT_MCU_MSG_LEN, len) |\n\t\t\t   MT_MCU_MSG_TYPE_CMD);\n\n\tmemcpy(data, &info, sizeof(info));\n\tmemcpy(data + sizeof(info), fw_data, len);\n\tmemset(data + sizeof(info) + len, 0, 4);\n\n\tmt76u_single_wr(&dev->mt76, MT_VEND_WRITE_FCE,\n\t\t\tMT_FCE_DMA_ADDR, dst_addr);\n\tlen = roundup(len, 4);\n\tmt76u_single_wr(&dev->mt76, MT_VEND_WRITE_FCE,\n\t\t\tMT_FCE_DMA_LEN, len << 16);\n\n\tdata_len = MT_CMD_HDR_LEN + len + sizeof(info);\n\n\terr = mt76u_bulk_msg(&dev->mt76, data, data_len, NULL, 1000,\n\t\t\t     MT_EP_OUT_INBAND_CMD);\n\tif (err) {\n\t\tdev_err(dev->mt76.dev, \"firmware upload failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tval = mt76_rr(dev, MT_TX_CPU_FROM_FCE_CPU_DESC_IDX);\n\tval++;\n\tmt76_wr(dev, MT_TX_CPU_FROM_FCE_CPU_DESC_IDX, val);\n\n\treturn 0;\n}\n\nint mt76x02u_mcu_fw_send_data(struct mt76x02_dev *dev, const void *data,\n\t\t\t      int data_len, u32 max_payload, u32 offset)\n{\n\tint len, err = 0, pos = 0, max_len = max_payload - 8;\n\tu8 *buf;\n\n\tbuf = kmalloc(max_payload, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\twhile (data_len > 0) {\n\t\tlen = min_t(int, data_len, max_len);\n\t\terr = __mt76x02u_mcu_fw_send_data(dev, buf, data + pos,\n\t\t\t\t\t\t  len, offset + pos);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tdata_len -= len;\n\t\tpos += len;\n\t\tusleep_range(5000, 10000);\n\t}\n\tkfree(buf);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mt76x02u_mcu_fw_send_data);\n\nvoid mt76x02u_init_mcu(struct mt76_dev *dev)\n{\n\tstatic const struct mt76_mcu_ops mt76x02u_mcu_ops = {\n\t\t.headroom = MT_CMD_HDR_LEN,\n\t\t.tailroom = 8,\n\t\t.mcu_send_msg = mt76x02u_mcu_send_msg,\n\t\t.mcu_parse_response = mt76x02_mcu_parse_response,\n\t\t.mcu_wr_rp = mt76x02u_mcu_wr_rp,\n\t\t.mcu_rd_rp = mt76x02u_mcu_rd_rp,\n\t};\n\n\tdev->mcu_ops = &mt76x02u_mcu_ops;\n}\nEXPORT_SYMBOL_GPL(mt76x02u_init_mcu);\n\nMODULE_AUTHOR(\"Lorenzo Bianconi <lorenzo.bianconi83@gmail.com>\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}