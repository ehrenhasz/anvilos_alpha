{
  "module_name": "mt792x_usb.c",
  "hash_id": "142c84f5a74a2c0421523375768354f7ce2538fb03bfb982b9873b3becaa87b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt792x_usb.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n\n#include \"mt792x.h\"\n#include \"mt76_connac2_mac.h\"\n\nu32 mt792xu_rr(struct mt76_dev *dev, u32 addr)\n{\n\tu32 ret;\n\n\tmutex_lock(&dev->usb.usb_ctrl_mtx);\n\tret = ___mt76u_rr(dev, MT_VEND_READ_EXT,\n\t\t\t  USB_DIR_IN | MT_USB_TYPE_VENDOR, addr);\n\tmutex_unlock(&dev->usb.usb_ctrl_mtx);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mt792xu_rr);\n\nvoid mt792xu_wr(struct mt76_dev *dev, u32 addr, u32 val)\n{\n\tmutex_lock(&dev->usb.usb_ctrl_mtx);\n\t___mt76u_wr(dev, MT_VEND_WRITE_EXT,\n\t\t    USB_DIR_OUT | MT_USB_TYPE_VENDOR, addr, val);\n\tmutex_unlock(&dev->usb.usb_ctrl_mtx);\n}\nEXPORT_SYMBOL_GPL(mt792xu_wr);\n\nu32 mt792xu_rmw(struct mt76_dev *dev, u32 addr, u32 mask, u32 val)\n{\n\tmutex_lock(&dev->usb.usb_ctrl_mtx);\n\tval |= ___mt76u_rr(dev, MT_VEND_READ_EXT,\n\t\t\t   USB_DIR_IN | MT_USB_TYPE_VENDOR, addr) & ~mask;\n\t___mt76u_wr(dev, MT_VEND_WRITE_EXT,\n\t\t    USB_DIR_OUT | MT_USB_TYPE_VENDOR, addr, val);\n\tmutex_unlock(&dev->usb.usb_ctrl_mtx);\n\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(mt792xu_rmw);\n\nvoid mt792xu_copy(struct mt76_dev *dev, u32 offset, const void *data, int len)\n{\n\tstruct mt76_usb *usb = &dev->usb;\n\tint ret, i = 0, batch_len;\n\tconst u8 *val = data;\n\n\tlen = round_up(len, 4);\n\n\tmutex_lock(&usb->usb_ctrl_mtx);\n\twhile (i < len) {\n\t\tbatch_len = min_t(int, usb->data_len, len - i);\n\t\tmemcpy(usb->data, val + i, batch_len);\n\t\tret = __mt76u_vendor_request(dev, MT_VEND_WRITE_EXT,\n\t\t\t\t\t     USB_DIR_OUT | MT_USB_TYPE_VENDOR,\n\t\t\t\t\t     (offset + i) >> 16, offset + i,\n\t\t\t\t\t     usb->data, batch_len);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\ti += batch_len;\n\t}\n\tmutex_unlock(&usb->usb_ctrl_mtx);\n}\nEXPORT_SYMBOL_GPL(mt792xu_copy);\n\nint mt792xu_mcu_power_on(struct mt792x_dev *dev)\n{\n\tint ret;\n\n\tret = mt76u_vendor_request(&dev->mt76, MT_VEND_POWER_ON,\n\t\t\t\t   USB_DIR_OUT | MT_USB_TYPE_VENDOR,\n\t\t\t\t   0x0, 0x1, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!mt76_poll_msec(dev, MT_CONN_ON_MISC, MT_TOP_MISC2_FW_PWR_ON,\n\t\t\t    MT_TOP_MISC2_FW_PWR_ON, 500)) {\n\t\tdev_err(dev->mt76.dev, \"Timeout for power on\\n\");\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mt792xu_mcu_power_on);\n\nstatic void mt792xu_cleanup(struct mt792x_dev *dev)\n{\n\tclear_bit(MT76_STATE_INITIALIZED, &dev->mphy.state);\n\tmt792xu_wfsys_reset(dev);\n\tskb_queue_purge(&dev->mt76.mcu.res_q);\n\tmt76u_queues_deinit(&dev->mt76);\n}\n\nstatic u32 mt792xu_uhw_rr(struct mt76_dev *dev, u32 addr)\n{\n\tu32 ret;\n\n\tmutex_lock(&dev->usb.usb_ctrl_mtx);\n\tret = ___mt76u_rr(dev, MT_VEND_DEV_MODE,\n\t\t\t  USB_DIR_IN | MT_USB_TYPE_UHW_VENDOR, addr);\n\tmutex_unlock(&dev->usb.usb_ctrl_mtx);\n\n\treturn ret;\n}\n\nstatic void mt792xu_uhw_wr(struct mt76_dev *dev, u32 addr, u32 val)\n{\n\tmutex_lock(&dev->usb.usb_ctrl_mtx);\n\t___mt76u_wr(dev, MT_VEND_WRITE,\n\t\t    USB_DIR_OUT | MT_USB_TYPE_UHW_VENDOR, addr, val);\n\tmutex_unlock(&dev->usb.usb_ctrl_mtx);\n}\n\nstatic void mt792xu_dma_prefetch(struct mt792x_dev *dev)\n{\n\tmt76_rmw(dev, MT_UWFDMA0_TX_RING_EXT_CTRL(0),\n\t\t MT_WPDMA0_MAX_CNT_MASK, 4);\n\tmt76_rmw(dev, MT_UWFDMA0_TX_RING_EXT_CTRL(0),\n\t\t MT_WPDMA0_BASE_PTR_MASK, 0x80);\n\n\tmt76_rmw(dev, MT_UWFDMA0_TX_RING_EXT_CTRL(1),\n\t\t MT_WPDMA0_MAX_CNT_MASK, 4);\n\tmt76_rmw(dev, MT_UWFDMA0_TX_RING_EXT_CTRL(1),\n\t\t MT_WPDMA0_BASE_PTR_MASK, 0xc0);\n\n\tmt76_rmw(dev, MT_UWFDMA0_TX_RING_EXT_CTRL(2),\n\t\t MT_WPDMA0_MAX_CNT_MASK, 4);\n\tmt76_rmw(dev, MT_UWFDMA0_TX_RING_EXT_CTRL(2),\n\t\t MT_WPDMA0_BASE_PTR_MASK, 0x100);\n\n\tmt76_rmw(dev, MT_UWFDMA0_TX_RING_EXT_CTRL(3),\n\t\t MT_WPDMA0_MAX_CNT_MASK, 4);\n\tmt76_rmw(dev, MT_UWFDMA0_TX_RING_EXT_CTRL(3),\n\t\t MT_WPDMA0_BASE_PTR_MASK, 0x140);\n\n\tmt76_rmw(dev, MT_UWFDMA0_TX_RING_EXT_CTRL(4),\n\t\t MT_WPDMA0_MAX_CNT_MASK, 4);\n\tmt76_rmw(dev, MT_UWFDMA0_TX_RING_EXT_CTRL(4),\n\t\t MT_WPDMA0_BASE_PTR_MASK, 0x180);\n\n\tmt76_rmw(dev, MT_UWFDMA0_TX_RING_EXT_CTRL(16),\n\t\t MT_WPDMA0_MAX_CNT_MASK, 4);\n\tmt76_rmw(dev, MT_UWFDMA0_TX_RING_EXT_CTRL(16),\n\t\t MT_WPDMA0_BASE_PTR_MASK, 0x280);\n\n\tmt76_rmw(dev, MT_UWFDMA0_TX_RING_EXT_CTRL(17),\n\t\t MT_WPDMA0_MAX_CNT_MASK, 4);\n\tmt76_rmw(dev, MT_UWFDMA0_TX_RING_EXT_CTRL(17),\n\t\t MT_WPDMA0_BASE_PTR_MASK,  0x2c0);\n}\n\nstatic void mt792xu_wfdma_init(struct mt792x_dev *dev)\n{\n\tmt792xu_dma_prefetch(dev);\n\n\tmt76_clear(dev, MT_UWFDMA0_GLO_CFG, MT_WFDMA0_GLO_CFG_OMIT_RX_INFO);\n\tmt76_set(dev, MT_UWFDMA0_GLO_CFG,\n\t\t MT_WFDMA0_GLO_CFG_OMIT_TX_INFO |\n\t\t MT_WFDMA0_GLO_CFG_OMIT_RX_INFO_PFET2 |\n\t\t MT_WFDMA0_GLO_CFG_FW_DWLD_BYPASS_DMASHDL |\n\t\t MT_WFDMA0_GLO_CFG_TX_DMA_EN |\n\t\t MT_WFDMA0_GLO_CFG_RX_DMA_EN);\n\n\t \n\tmt76_clear(dev, MT_UWFDMA0_GLO_CFG_EXT0,\n\t\t   MT_WFDMA0_CSR_TX_DMASHDL_ENABLE);\n\tmt76_set(dev, MT_DMASHDL_SW_CONTROL, MT_DMASHDL_DMASHDL_BYPASS);\n\n\tmt76_set(dev, MT_WFDMA_DUMMY_CR, MT_WFDMA_NEED_REINIT);\n}\n\nstatic int mt792xu_dma_rx_evt_ep4(struct mt792x_dev *dev)\n{\n\tif (!mt76_poll(dev, MT_UWFDMA0_GLO_CFG,\n\t\t       MT_WFDMA0_GLO_CFG_RX_DMA_BUSY, 0, 1000))\n\t\treturn -ETIMEDOUT;\n\n\tmt76_clear(dev, MT_UWFDMA0_GLO_CFG, MT_WFDMA0_GLO_CFG_RX_DMA_EN);\n\tmt76_set(dev, MT_WFDMA_HOST_CONFIG,\n\t\t MT_WFDMA_HOST_CONFIG_USB_RXEVT_EP4_EN);\n\tmt76_set(dev, MT_UWFDMA0_GLO_CFG, MT_WFDMA0_GLO_CFG_RX_DMA_EN);\n\n\treturn 0;\n}\n\nstatic void mt792xu_epctl_rst_opt(struct mt792x_dev *dev, bool reset)\n{\n\tu32 val;\n\n\t \n\tval = mt792xu_uhw_rr(&dev->mt76, MT_SSUSB_EPCTL_CSR_EP_RST_OPT);\n\tif (reset)\n\t\tval |= GENMASK(9, 4) | GENMASK(22, 20);\n\telse\n\t\tval &= ~(GENMASK(9, 4) | GENMASK(22, 20));\n\tmt792xu_uhw_wr(&dev->mt76, MT_SSUSB_EPCTL_CSR_EP_RST_OPT, val);\n}\n\nint mt792xu_dma_init(struct mt792x_dev *dev, bool resume)\n{\n\tint err;\n\n\tmt792xu_wfdma_init(dev);\n\n\tmt76_clear(dev, MT_UDMA_WLCFG_0, MT_WL_RX_FLUSH);\n\n\tmt76_set(dev, MT_UDMA_WLCFG_0,\n\t\t MT_WL_RX_EN | MT_WL_TX_EN |\n\t\t MT_WL_RX_MPSZ_PAD0 | MT_TICK_1US_EN);\n\tmt76_clear(dev, MT_UDMA_WLCFG_0,\n\t\t   MT_WL_RX_AGG_TO | MT_WL_RX_AGG_LMT);\n\tmt76_clear(dev, MT_UDMA_WLCFG_1, MT_WL_RX_AGG_PKT_LMT);\n\n\tif (resume)\n\t\treturn 0;\n\n\terr = mt792xu_dma_rx_evt_ep4(dev);\n\tif (err)\n\t\treturn err;\n\n\tmt792xu_epctl_rst_opt(dev, false);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt792xu_dma_init);\n\nint mt792xu_wfsys_reset(struct mt792x_dev *dev)\n{\n\tu32 val;\n\tint i;\n\n\tmt792xu_epctl_rst_opt(dev, false);\n\n\tval = mt792xu_uhw_rr(&dev->mt76, MT_CBTOP_RGU_WF_SUBSYS_RST);\n\tval |= MT_CBTOP_RGU_WF_SUBSYS_RST_WF_WHOLE_PATH;\n\tmt792xu_uhw_wr(&dev->mt76, MT_CBTOP_RGU_WF_SUBSYS_RST, val);\n\n\tusleep_range(10, 20);\n\n\tval = mt792xu_uhw_rr(&dev->mt76, MT_CBTOP_RGU_WF_SUBSYS_RST);\n\tval &= ~MT_CBTOP_RGU_WF_SUBSYS_RST_WF_WHOLE_PATH;\n\tmt792xu_uhw_wr(&dev->mt76, MT_CBTOP_RGU_WF_SUBSYS_RST, val);\n\n\tmt792xu_uhw_wr(&dev->mt76, MT_UDMA_CONN_INFRA_STATUS_SEL, 0);\n\tfor (i = 0; i < MT792x_WFSYS_INIT_RETRY_COUNT; i++) {\n\t\tval = mt792xu_uhw_rr(&dev->mt76, MT_UDMA_CONN_INFRA_STATUS);\n\t\tif (val & MT_UDMA_CONN_WFSYS_INIT_DONE)\n\t\t\tbreak;\n\n\t\tmsleep(100);\n\t}\n\n\tif (i == MT792x_WFSYS_INIT_RETRY_COUNT)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt792xu_wfsys_reset);\n\nint mt792xu_init_reset(struct mt792x_dev *dev)\n{\n\tset_bit(MT76_RESET, &dev->mphy.state);\n\n\twake_up(&dev->mt76.mcu.wait);\n\tskb_queue_purge(&dev->mt76.mcu.res_q);\n\n\tmt76u_stop_rx(&dev->mt76);\n\tmt76u_stop_tx(&dev->mt76);\n\n\tmt792xu_wfsys_reset(dev);\n\n\tclear_bit(MT76_RESET, &dev->mphy.state);\n\n\treturn mt76u_resume_rx(&dev->mt76);\n}\nEXPORT_SYMBOL_GPL(mt792xu_init_reset);\n\nvoid mt792xu_disconnect(struct usb_interface *usb_intf)\n{\n\tstruct mt792x_dev *dev = usb_get_intfdata(usb_intf);\n\n\tcancel_work_sync(&dev->init_work);\n\tif (!test_bit(MT76_STATE_INITIALIZED, &dev->mphy.state))\n\t\treturn;\n\n\tmt76_unregister_device(&dev->mt76);\n\tmt792xu_cleanup(dev);\n\n\tusb_set_intfdata(usb_intf, NULL);\n\tusb_put_dev(interface_to_usbdev(usb_intf));\n\n\tmt76_free_device(&dev->mt76);\n}\nEXPORT_SYMBOL_GPL(mt792xu_disconnect);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Lorenzo Bianconi <lorenzo@kernel.org>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}