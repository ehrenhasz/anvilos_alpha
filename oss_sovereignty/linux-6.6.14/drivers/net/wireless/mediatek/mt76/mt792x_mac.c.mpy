{
  "module_name": "mt792x_mac.c",
  "hash_id": "54510a9b5241e4c41f36d1be2eae09da32a23658adccb829a9fe8af3fd8b4f8c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt792x_mac.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n\n#include \"mt792x.h\"\n#include \"mt792x_regs.h\"\n\nvoid mt792x_mac_work(struct work_struct *work)\n{\n\tstruct mt792x_phy *phy;\n\tstruct mt76_phy *mphy;\n\n\tmphy = (struct mt76_phy *)container_of(work, struct mt76_phy,\n\t\t\t\t\t       mac_work.work);\n\tphy = mphy->priv;\n\n\tmt792x_mutex_acquire(phy->dev);\n\n\tmt76_update_survey(mphy);\n\tif (++mphy->mac_work_count == 2) {\n\t\tmphy->mac_work_count = 0;\n\n\t\tmt792x_mac_update_mib_stats(phy);\n\t}\n\n\tmt792x_mutex_release(phy->dev);\n\n\tmt76_tx_status_check(mphy->dev, false);\n\tieee80211_queue_delayed_work(phy->mt76->hw, &mphy->mac_work,\n\t\t\t\t     MT792x_WATCHDOG_TIME);\n}\nEXPORT_SYMBOL_GPL(mt792x_mac_work);\n\nvoid mt792x_mac_set_timeing(struct mt792x_phy *phy)\n{\n\ts16 coverage_class = phy->coverage_class;\n\tstruct mt792x_dev *dev = phy->dev;\n\tu32 val, reg_offset;\n\tu32 cck = FIELD_PREP(MT_TIMEOUT_VAL_PLCP, 231) |\n\t\t  FIELD_PREP(MT_TIMEOUT_VAL_CCA, 48);\n\tu32 ofdm = FIELD_PREP(MT_TIMEOUT_VAL_PLCP, 60) |\n\t\t   FIELD_PREP(MT_TIMEOUT_VAL_CCA, 28);\n\tbool is_2ghz = phy->mt76->chandef.chan->band == NL80211_BAND_2GHZ;\n\tint sifs = is_2ghz ? 10 : 16, offset;\n\n\tif (!test_bit(MT76_STATE_RUNNING, &phy->mt76->state))\n\t\treturn;\n\n\tmt76_set(dev, MT_ARB_SCR(0),\n\t\t MT_ARB_SCR_TX_DISABLE | MT_ARB_SCR_RX_DISABLE);\n\tudelay(1);\n\n\toffset = 3 * coverage_class;\n\treg_offset = FIELD_PREP(MT_TIMEOUT_VAL_PLCP, offset) |\n\t\t     FIELD_PREP(MT_TIMEOUT_VAL_CCA, offset);\n\n\tmt76_wr(dev, MT_TMAC_CDTR(0), cck + reg_offset);\n\tmt76_wr(dev, MT_TMAC_ODTR(0), ofdm + reg_offset);\n\tmt76_wr(dev, MT_TMAC_ICR0(0),\n\t\tFIELD_PREP(MT_IFS_EIFS, 360) |\n\t\tFIELD_PREP(MT_IFS_RIFS, 2) |\n\t\tFIELD_PREP(MT_IFS_SIFS, sifs) |\n\t\tFIELD_PREP(MT_IFS_SLOT, phy->slottime));\n\n\tif (phy->slottime < 20 || !is_2ghz)\n\t\tval = MT792x_CFEND_RATE_DEFAULT;\n\telse\n\t\tval = MT792x_CFEND_RATE_11B;\n\n\tmt76_rmw_field(dev, MT_AGG_ACR0(0), MT_AGG_ACR_CFEND_RATE, val);\n\tmt76_clear(dev, MT_ARB_SCR(0),\n\t\t   MT_ARB_SCR_TX_DISABLE | MT_ARB_SCR_RX_DISABLE);\n}\nEXPORT_SYMBOL_GPL(mt792x_mac_set_timeing);\n\nvoid mt792x_mac_update_mib_stats(struct mt792x_phy *phy)\n{\n\tstruct mt76_mib_stats *mib = &phy->mib;\n\tstruct mt792x_dev *dev = phy->dev;\n\tint i, aggr0 = 0, aggr1;\n\tu32 val;\n\n\tmib->fcs_err_cnt += mt76_get_field(dev, MT_MIB_SDR3(0),\n\t\t\t\t\t   MT_MIB_SDR3_FCS_ERR_MASK);\n\tmib->ack_fail_cnt += mt76_get_field(dev, MT_MIB_MB_BSDR3(0),\n\t\t\t\t\t    MT_MIB_ACK_FAIL_COUNT_MASK);\n\tmib->ba_miss_cnt += mt76_get_field(dev, MT_MIB_MB_BSDR2(0),\n\t\t\t\t\t   MT_MIB_BA_FAIL_COUNT_MASK);\n\tmib->rts_cnt += mt76_get_field(dev, MT_MIB_MB_BSDR0(0),\n\t\t\t\t       MT_MIB_RTS_COUNT_MASK);\n\tmib->rts_retries_cnt += mt76_get_field(dev, MT_MIB_MB_BSDR1(0),\n\t\t\t\t\t       MT_MIB_RTS_FAIL_COUNT_MASK);\n\n\tmib->tx_ampdu_cnt += mt76_rr(dev, MT_MIB_SDR12(0));\n\tmib->tx_mpdu_attempts_cnt += mt76_rr(dev, MT_MIB_SDR14(0));\n\tmib->tx_mpdu_success_cnt += mt76_rr(dev, MT_MIB_SDR15(0));\n\n\tval = mt76_rr(dev, MT_MIB_SDR32(0));\n\tmib->tx_pkt_ebf_cnt += FIELD_GET(MT_MIB_SDR9_EBF_CNT_MASK, val);\n\tmib->tx_pkt_ibf_cnt += FIELD_GET(MT_MIB_SDR9_IBF_CNT_MASK, val);\n\n\tval = mt76_rr(dev, MT_ETBF_TX_APP_CNT(0));\n\tmib->tx_bf_ibf_ppdu_cnt += FIELD_GET(MT_ETBF_TX_IBF_CNT, val);\n\tmib->tx_bf_ebf_ppdu_cnt += FIELD_GET(MT_ETBF_TX_EBF_CNT, val);\n\n\tval = mt76_rr(dev, MT_ETBF_RX_FB_CNT(0));\n\tmib->tx_bf_rx_fb_all_cnt += FIELD_GET(MT_ETBF_RX_FB_ALL, val);\n\tmib->tx_bf_rx_fb_he_cnt += FIELD_GET(MT_ETBF_RX_FB_HE, val);\n\tmib->tx_bf_rx_fb_vht_cnt += FIELD_GET(MT_ETBF_RX_FB_VHT, val);\n\tmib->tx_bf_rx_fb_ht_cnt += FIELD_GET(MT_ETBF_RX_FB_HT, val);\n\n\tmib->rx_mpdu_cnt += mt76_rr(dev, MT_MIB_SDR5(0));\n\tmib->rx_ampdu_cnt += mt76_rr(dev, MT_MIB_SDR22(0));\n\tmib->rx_ampdu_bytes_cnt += mt76_rr(dev, MT_MIB_SDR23(0));\n\tmib->rx_ba_cnt += mt76_rr(dev, MT_MIB_SDR31(0));\n\n\tfor (i = 0; i < ARRAY_SIZE(mib->tx_amsdu); i++) {\n\t\tval = mt76_rr(dev, MT_PLE_AMSDU_PACK_MSDU_CNT(i));\n\t\tmib->tx_amsdu[i] += val;\n\t\tmib->tx_amsdu_cnt += val;\n\t}\n\n\tfor (i = 0, aggr1 = aggr0 + 8; i < 4; i++) {\n\t\tu32 val2;\n\n\t\tval = mt76_rr(dev, MT_TX_AGG_CNT(0, i));\n\t\tval2 = mt76_rr(dev, MT_TX_AGG_CNT2(0, i));\n\n\t\tphy->mt76->aggr_stats[aggr0++] += val & 0xffff;\n\t\tphy->mt76->aggr_stats[aggr0++] += val >> 16;\n\t\tphy->mt76->aggr_stats[aggr1++] += val2 & 0xffff;\n\t\tphy->mt76->aggr_stats[aggr1++] += val2 >> 16;\n\t}\n}\nEXPORT_SYMBOL_GPL(mt792x_mac_update_mib_stats);\n\nstruct mt76_wcid *mt792x_rx_get_wcid(struct mt792x_dev *dev, u16 idx,\n\t\t\t\t     bool unicast)\n{\n\tstruct mt792x_sta *sta;\n\tstruct mt76_wcid *wcid;\n\n\tif (idx >= ARRAY_SIZE(dev->mt76.wcid))\n\t\treturn NULL;\n\n\twcid = rcu_dereference(dev->mt76.wcid[idx]);\n\tif (unicast || !wcid)\n\t\treturn wcid;\n\n\tif (!wcid->sta)\n\t\treturn NULL;\n\n\tsta = container_of(wcid, struct mt792x_sta, wcid);\n\tif (!sta->vif)\n\t\treturn NULL;\n\n\treturn &sta->vif->sta.wcid;\n}\nEXPORT_SYMBOL_GPL(mt792x_rx_get_wcid);\n\nstatic void\nmt792x_mac_rssi_iter(void *priv, u8 *mac, struct ieee80211_vif *vif)\n{\n\tstruct sk_buff *skb = priv;\n\tstruct mt76_rx_status *status = (struct mt76_rx_status *)skb->cb;\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tstruct ieee80211_hdr *hdr = mt76_skb_get_hdr(skb);\n\n\tif (status->signal > 0)\n\t\treturn;\n\n\tif (!ether_addr_equal(vif->addr, hdr->addr1))\n\t\treturn;\n\n\tewma_rssi_add(&mvif->rssi, -status->signal);\n}\n\nvoid mt792x_mac_assoc_rssi(struct mt792x_dev *dev, struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = mt76_skb_get_hdr(skb);\n\n\tif (!ieee80211_is_assoc_resp(hdr->frame_control) &&\n\t    !ieee80211_is_auth(hdr->frame_control))\n\t\treturn;\n\n\tieee80211_iterate_active_interfaces_atomic(mt76_hw(dev),\n\t\tIEEE80211_IFACE_ITER_RESUME_ALL,\n\t\tmt792x_mac_rssi_iter, skb);\n}\nEXPORT_SYMBOL_GPL(mt792x_mac_assoc_rssi);\n\nvoid mt792x_mac_reset_counters(struct mt792x_phy *phy)\n{\n\tstruct mt792x_dev *dev = phy->dev;\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tmt76_rr(dev, MT_TX_AGG_CNT(0, i));\n\t\tmt76_rr(dev, MT_TX_AGG_CNT2(0, i));\n\t}\n\n\tdev->mt76.phy.survey_time = ktime_get_boottime();\n\tmemset(phy->mt76->aggr_stats, 0, sizeof(phy->mt76->aggr_stats));\n\n\t \n\tmt76_rr(dev, MT_MIB_SDR9(0));\n\tmt76_rr(dev, MT_MIB_SDR36(0));\n\tmt76_rr(dev, MT_MIB_SDR37(0));\n\n\tmt76_set(dev, MT_WF_RMAC_MIB_TIME0(0), MT_WF_RMAC_MIB_RXTIME_CLR);\n\tmt76_set(dev, MT_WF_RMAC_MIB_AIRTIME0(0), MT_WF_RMAC_MIB_RXTIME_CLR);\n}\nEXPORT_SYMBOL_GPL(mt792x_mac_reset_counters);\n\nstatic u8\nmt792x_phy_get_nf(struct mt792x_phy *phy, int idx)\n{\n\treturn 0;\n}\n\nstatic void\nmt792x_phy_update_channel(struct mt76_phy *mphy, int idx)\n{\n\tstruct mt792x_dev *dev = container_of(mphy->dev, struct mt792x_dev, mt76);\n\tstruct mt792x_phy *phy = (struct mt792x_phy *)mphy->priv;\n\tstruct mt76_channel_state *state;\n\tu64 busy_time, tx_time, rx_time, obss_time;\n\tint nf;\n\n\tbusy_time = mt76_get_field(dev, MT_MIB_SDR9(idx),\n\t\t\t\t   MT_MIB_SDR9_BUSY_MASK);\n\ttx_time = mt76_get_field(dev, MT_MIB_SDR36(idx),\n\t\t\t\t MT_MIB_SDR36_TXTIME_MASK);\n\trx_time = mt76_get_field(dev, MT_MIB_SDR37(idx),\n\t\t\t\t MT_MIB_SDR37_RXTIME_MASK);\n\tobss_time = mt76_get_field(dev, MT_WF_RMAC_MIB_AIRTIME14(idx),\n\t\t\t\t   MT_MIB_OBSSTIME_MASK);\n\n\tnf = mt792x_phy_get_nf(phy, idx);\n\tif (!phy->noise)\n\t\tphy->noise = nf << 4;\n\telse if (nf)\n\t\tphy->noise += nf - (phy->noise >> 4);\n\n\tstate = mphy->chan_state;\n\tstate->cc_busy += busy_time;\n\tstate->cc_tx += tx_time;\n\tstate->cc_rx += rx_time + obss_time;\n\tstate->cc_bss_rx += rx_time;\n\tstate->noise = -(phy->noise >> 4);\n}\n\nvoid mt792x_update_channel(struct mt76_phy *mphy)\n{\n\tstruct mt792x_dev *dev = container_of(mphy->dev, struct mt792x_dev, mt76);\n\n\tif (mt76_connac_pm_wake(mphy, &dev->pm))\n\t\treturn;\n\n\tmt792x_phy_update_channel(mphy, 0);\n\t \n\tmt76_set(dev, MT_WF_RMAC_MIB_TIME0(0), MT_WF_RMAC_MIB_RXTIME_CLR);\n\tmt76_connac_power_save_sched(mphy, &dev->pm);\n}\nEXPORT_SYMBOL_GPL(mt792x_update_channel);\n\nvoid mt792x_reset(struct mt76_dev *mdev)\n{\n\tstruct mt792x_dev *dev = container_of(mdev, struct mt792x_dev, mt76);\n\tstruct mt76_connac_pm *pm = &dev->pm;\n\n\tif (!dev->hw_init_done)\n\t\treturn;\n\n\tif (dev->hw_full_reset)\n\t\treturn;\n\n\tif (pm->suspended)\n\t\treturn;\n\n\tqueue_work(dev->mt76.wq, &dev->reset_work);\n}\nEXPORT_SYMBOL_GPL(mt792x_reset);\n\nvoid mt792x_mac_init_band(struct mt792x_dev *dev, u8 band)\n{\n\tu32 mask, set;\n\n\tmt76_rmw_field(dev, MT_TMAC_CTCR0(band),\n\t\t       MT_TMAC_CTCR0_INS_DDLMT_REFTIME, 0x3f);\n\tmt76_set(dev, MT_TMAC_CTCR0(band),\n\t\t MT_TMAC_CTCR0_INS_DDLMT_VHT_SMPDU_EN |\n\t\t MT_TMAC_CTCR0_INS_DDLMT_EN);\n\n\tmt76_set(dev, MT_WF_RMAC_MIB_TIME0(band), MT_WF_RMAC_MIB_RXTIME_EN);\n\tmt76_set(dev, MT_WF_RMAC_MIB_AIRTIME0(band), MT_WF_RMAC_MIB_RXTIME_EN);\n\n\t \n\tmt76_set(dev, MT_MIB_SCR1(band), MT_MIB_TXDUR_EN);\n\tmt76_set(dev, MT_MIB_SCR1(band), MT_MIB_RXDUR_EN);\n\n\tmt76_rmw_field(dev, MT_DMA_DCR0(band), MT_DMA_DCR0_MAX_RX_LEN, 1536);\n\t \n\tmt76_clear(dev, MT_DMA_DCR0(band), MT_DMA_DCR0_RXD_G5_EN);\n\n\t \n\tmask = MT_WTBLOFF_TOP_RSCR_RCPI_MODE | MT_WTBLOFF_TOP_RSCR_RCPI_PARAM;\n\tset = FIELD_PREP(MT_WTBLOFF_TOP_RSCR_RCPI_MODE, 0) |\n\t      FIELD_PREP(MT_WTBLOFF_TOP_RSCR_RCPI_PARAM, 0x3);\n\tmt76_rmw(dev, MT_WTBLOFF_TOP_RSCR(band), mask, set);\n}\nEXPORT_SYMBOL_GPL(mt792x_mac_init_band);\n\nvoid mt792x_pm_wake_work(struct work_struct *work)\n{\n\tstruct mt792x_dev *dev;\n\tstruct mt76_phy *mphy;\n\n\tdev = (struct mt792x_dev *)container_of(work, struct mt792x_dev,\n\t\t\t\t\t\tpm.wake_work);\n\tmphy = dev->phy.mt76;\n\n\tif (!mt792x_mcu_drv_pmctrl(dev)) {\n\t\tstruct mt76_dev *mdev = &dev->mt76;\n\t\tint i;\n\n\t\tif (mt76_is_sdio(mdev)) {\n\t\t\tmt76_connac_pm_dequeue_skbs(mphy, &dev->pm);\n\t\t\tmt76_worker_schedule(&mdev->sdio.txrx_worker);\n\t\t} else {\n\t\t\tlocal_bh_disable();\n\t\t\tmt76_for_each_q_rx(mdev, i)\n\t\t\t\tnapi_schedule(&mdev->napi[i]);\n\t\t\tlocal_bh_enable();\n\t\t\tmt76_connac_pm_dequeue_skbs(mphy, &dev->pm);\n\t\t\tmt76_connac_tx_cleanup(mdev);\n\t\t}\n\t\tif (test_bit(MT76_STATE_RUNNING, &mphy->state))\n\t\t\tieee80211_queue_delayed_work(mphy->hw, &mphy->mac_work,\n\t\t\t\t\t\t     MT792x_WATCHDOG_TIME);\n\t}\n\n\tieee80211_wake_queues(mphy->hw);\n\twake_up(&dev->pm.wait);\n}\nEXPORT_SYMBOL_GPL(mt792x_pm_wake_work);\n\nvoid mt792x_pm_power_save_work(struct work_struct *work)\n{\n\tstruct mt792x_dev *dev;\n\tunsigned long delta;\n\tstruct mt76_phy *mphy;\n\n\tdev = (struct mt792x_dev *)container_of(work, struct mt792x_dev,\n\t\t\t\t\t\tpm.ps_work.work);\n\tmphy = dev->phy.mt76;\n\n\tdelta = dev->pm.idle_timeout;\n\tif (test_bit(MT76_HW_SCANNING, &mphy->state) ||\n\t    test_bit(MT76_HW_SCHED_SCANNING, &mphy->state) ||\n\t    dev->fw_assert)\n\t\tgoto out;\n\n\tif (mutex_is_locked(&dev->mt76.mutex))\n\t\t \n\t\tgoto out;\n\n\tif (time_is_after_jiffies(dev->pm.last_activity + delta)) {\n\t\tdelta = dev->pm.last_activity + delta - jiffies;\n\t\tgoto out;\n\t}\n\n\tif (!mt792x_mcu_fw_pmctrl(dev)) {\n\t\tcancel_delayed_work_sync(&mphy->mac_work);\n\t\treturn;\n\t}\nout:\n\tqueue_delayed_work(dev->mt76.wq, &dev->pm.ps_work, delta);\n}\nEXPORT_SYMBOL_GPL(mt792x_pm_power_save_work);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}