{
  "module_name": "mt76x02_phy.c",
  "hash_id": "b7accfc2fbca7d0e1dc4a7e6debf05fab00698f25b64a59d4123eae2a68b4163",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt76x02_phy.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n\n#include \"mt76x02.h\"\n#include \"mt76x02_phy.h\"\n\nvoid mt76x02_phy_set_rxpath(struct mt76x02_dev *dev)\n{\n\tu32 val;\n\n\tval = mt76_rr(dev, MT_BBP(AGC, 0));\n\tval &= ~BIT(4);\n\n\tswitch (dev->mphy.chainmask & 0xf) {\n\tcase 2:\n\t\tval |= BIT(3);\n\t\tbreak;\n\tdefault:\n\t\tval &= ~BIT(3);\n\t\tbreak;\n\t}\n\n\tmt76_wr(dev, MT_BBP(AGC, 0), val);\n\tmb();\n\tval = mt76_rr(dev, MT_BBP(AGC, 0));\n}\nEXPORT_SYMBOL_GPL(mt76x02_phy_set_rxpath);\n\nvoid mt76x02_phy_set_txdac(struct mt76x02_dev *dev)\n{\n\tint txpath;\n\n\ttxpath = (dev->mphy.chainmask >> 8) & 0xf;\n\tswitch (txpath) {\n\tcase 2:\n\t\tmt76_set(dev, MT_BBP(TXBE, 5), 0x3);\n\t\tbreak;\n\tdefault:\n\t\tmt76_clear(dev, MT_BBP(TXBE, 5), 0x3);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(mt76x02_phy_set_txdac);\n\nstatic u32\nmt76x02_tx_power_mask(u8 v1, u8 v2, u8 v3, u8 v4)\n{\n\tu32 val = 0;\n\n\tval |= (v1 & (BIT(6) - 1)) << 0;\n\tval |= (v2 & (BIT(6) - 1)) << 8;\n\tval |= (v3 & (BIT(6) - 1)) << 16;\n\tval |= (v4 & (BIT(6) - 1)) << 24;\n\treturn val;\n}\n\nint mt76x02_get_max_rate_power(struct mt76x02_rate_power *r)\n{\n\ts8 ret = 0;\n\tint i;\n\n\tfor (i = 0; i < sizeof(r->all); i++)\n\t\tret = max(ret, r->all[i]);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mt76x02_get_max_rate_power);\n\nvoid mt76x02_limit_rate_power(struct mt76x02_rate_power *r, int limit)\n{\n\tint i;\n\n\tfor (i = 0; i < sizeof(r->all); i++)\n\t\tif (r->all[i] > limit)\n\t\t\tr->all[i] = limit;\n}\nEXPORT_SYMBOL_GPL(mt76x02_limit_rate_power);\n\nvoid mt76x02_add_rate_power_offset(struct mt76x02_rate_power *r, int offset)\n{\n\tint i;\n\n\tfor (i = 0; i < sizeof(r->all); i++)\n\t\tr->all[i] += offset;\n}\nEXPORT_SYMBOL_GPL(mt76x02_add_rate_power_offset);\n\nvoid mt76x02_phy_set_txpower(struct mt76x02_dev *dev, int txp_0, int txp_1)\n{\n\tstruct mt76x02_rate_power *t = &dev->rate_power;\n\n\tmt76_rmw_field(dev, MT_TX_ALC_CFG_0, MT_TX_ALC_CFG_0_CH_INIT_0, txp_0);\n\tmt76_rmw_field(dev, MT_TX_ALC_CFG_0, MT_TX_ALC_CFG_0_CH_INIT_1, txp_1);\n\n\tmt76_wr(dev, MT_TX_PWR_CFG_0,\n\t\tmt76x02_tx_power_mask(t->cck[0], t->cck[2], t->ofdm[0],\n\t\t\t\t      t->ofdm[2]));\n\tmt76_wr(dev, MT_TX_PWR_CFG_1,\n\t\tmt76x02_tx_power_mask(t->ofdm[4], t->ofdm[6], t->ht[0],\n\t\t\t\t      t->ht[2]));\n\tmt76_wr(dev, MT_TX_PWR_CFG_2,\n\t\tmt76x02_tx_power_mask(t->ht[4], t->ht[6], t->ht[8],\n\t\t\t\t      t->ht[10]));\n\tmt76_wr(dev, MT_TX_PWR_CFG_3,\n\t\tmt76x02_tx_power_mask(t->ht[12], t->ht[14], t->ht[0],\n\t\t\t\t      t->ht[2]));\n\tmt76_wr(dev, MT_TX_PWR_CFG_4,\n\t\tmt76x02_tx_power_mask(t->ht[4], t->ht[6], 0, 0));\n\tmt76_wr(dev, MT_TX_PWR_CFG_7,\n\t\tmt76x02_tx_power_mask(t->ofdm[7], t->vht[0], t->ht[7],\n\t\t\t\t      t->vht[1]));\n\tmt76_wr(dev, MT_TX_PWR_CFG_8,\n\t\tmt76x02_tx_power_mask(t->ht[14], 0, t->vht[0], t->vht[1]));\n\tmt76_wr(dev, MT_TX_PWR_CFG_9,\n\t\tmt76x02_tx_power_mask(t->ht[7], 0, t->vht[0], t->vht[1]));\n}\nEXPORT_SYMBOL_GPL(mt76x02_phy_set_txpower);\n\nvoid mt76x02_phy_set_bw(struct mt76x02_dev *dev, int width, u8 ctrl)\n{\n\tint core_val, agc_val;\n\n\tswitch (width) {\n\tcase NL80211_CHAN_WIDTH_80:\n\t\tcore_val = 3;\n\t\tagc_val = 7;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tcore_val = 2;\n\t\tagc_val = 3;\n\t\tbreak;\n\tdefault:\n\t\tcore_val = 0;\n\t\tagc_val = 1;\n\t\tbreak;\n\t}\n\n\tmt76_rmw_field(dev, MT_BBP(CORE, 1), MT_BBP_CORE_R1_BW, core_val);\n\tmt76_rmw_field(dev, MT_BBP(AGC, 0), MT_BBP_AGC_R0_BW, agc_val);\n\tmt76_rmw_field(dev, MT_BBP(AGC, 0), MT_BBP_AGC_R0_CTRL_CHAN, ctrl);\n\tmt76_rmw_field(dev, MT_BBP(TXBE, 0), MT_BBP_TXBE_R0_CTRL_CHAN, ctrl);\n}\nEXPORT_SYMBOL_GPL(mt76x02_phy_set_bw);\n\nvoid mt76x02_phy_set_band(struct mt76x02_dev *dev, int band,\n\t\t\t  bool primary_upper)\n{\n\tswitch (band) {\n\tcase NL80211_BAND_2GHZ:\n\t\tmt76_set(dev, MT_TX_BAND_CFG, MT_TX_BAND_CFG_2G);\n\t\tmt76_clear(dev, MT_TX_BAND_CFG, MT_TX_BAND_CFG_5G);\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\tmt76_clear(dev, MT_TX_BAND_CFG, MT_TX_BAND_CFG_2G);\n\t\tmt76_set(dev, MT_TX_BAND_CFG, MT_TX_BAND_CFG_5G);\n\t\tbreak;\n\t}\n\n\tmt76_rmw_field(dev, MT_TX_BAND_CFG, MT_TX_BAND_CFG_UPPER_40M,\n\t\t       primary_upper);\n}\nEXPORT_SYMBOL_GPL(mt76x02_phy_set_band);\n\nbool mt76x02_phy_adjust_vga_gain(struct mt76x02_dev *dev)\n{\n\tu8 limit = dev->cal.low_gain > 0 ? 16 : 4;\n\tbool ret = false;\n\tu32 false_cca;\n\n\tfalse_cca = FIELD_GET(MT_RX_STAT_1_CCA_ERRORS,\n\t\t\t      mt76_rr(dev, MT_RX_STAT_1));\n\tdev->cal.false_cca = false_cca;\n\tif (false_cca > 800 && dev->cal.agc_gain_adjust < limit) {\n\t\tdev->cal.agc_gain_adjust += 2;\n\t\tret = true;\n\t} else if ((false_cca < 10 && dev->cal.agc_gain_adjust > 0) ||\n\t\t   (dev->cal.agc_gain_adjust >= limit && false_cca < 500)) {\n\t\tdev->cal.agc_gain_adjust -= 2;\n\t\tret = true;\n\t}\n\n\tdev->cal.agc_lowest_gain = dev->cal.agc_gain_adjust >= limit;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mt76x02_phy_adjust_vga_gain);\n\nvoid mt76x02_init_agc_gain(struct mt76x02_dev *dev)\n{\n\tdev->cal.agc_gain_init[0] = mt76_get_field(dev, MT_BBP(AGC, 8),\n\t\t\t\t\t\t   MT_BBP_AGC_GAIN);\n\tdev->cal.agc_gain_init[1] = mt76_get_field(dev, MT_BBP(AGC, 9),\n\t\t\t\t\t\t   MT_BBP_AGC_GAIN);\n\tmemcpy(dev->cal.agc_gain_cur, dev->cal.agc_gain_init,\n\t       sizeof(dev->cal.agc_gain_cur));\n\tdev->cal.low_gain = -1;\n\tdev->cal.gain_init_done = true;\n}\nEXPORT_SYMBOL_GPL(mt76x02_init_agc_gain);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}