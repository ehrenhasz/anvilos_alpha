{
  "module_name": "mt76x02_usb_core.c",
  "hash_id": "ed28f0294b752f8dce8091d381086ae5b6fc6388f8ad72d91eed57df3c74dc65",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt76/mt76x02_usb_core.c",
  "human_readable_source": "\n \n\n#include \"mt76x02_usb.h\"\n\nstatic void mt76x02u_remove_dma_hdr(struct sk_buff *skb)\n{\n\tint hdr_len;\n\n\tskb_pull(skb, sizeof(struct mt76x02_txwi) + MT_DMA_HDR_LEN);\n\thdr_len = ieee80211_get_hdrlen_from_skb(skb);\n\tif (hdr_len % 4)\n\t\tmt76x02_remove_hdr_pad(skb, 2);\n}\n\nvoid mt76x02u_tx_complete_skb(struct mt76_dev *mdev, struct mt76_queue_entry *e)\n{\n\tmt76x02u_remove_dma_hdr(e->skb);\n\tmt76_tx_complete_skb(mdev, e->wcid, e->skb);\n}\nEXPORT_SYMBOL_GPL(mt76x02u_tx_complete_skb);\n\nint mt76x02u_mac_start(struct mt76x02_dev *dev)\n{\n\tmt76x02_mac_reset_counters(dev);\n\n\tmt76_wr(dev, MT_MAC_SYS_CTRL, MT_MAC_SYS_CTRL_ENABLE_TX);\n\tif (!mt76x02_wait_for_wpdma(&dev->mt76, 200000))\n\t\treturn -ETIMEDOUT;\n\n\tmt76_wr(dev, MT_RX_FILTR_CFG, dev->mt76.rxfilter);\n\n\tmt76_wr(dev, MT_MAC_SYS_CTRL,\n\t\tMT_MAC_SYS_CTRL_ENABLE_TX |\n\t\tMT_MAC_SYS_CTRL_ENABLE_RX);\n\n\tif (!mt76x02_wait_for_wpdma(&dev->mt76, 50))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt76x02u_mac_start);\n\nint mt76x02u_skb_dma_info(struct sk_buff *skb, int port, u32 flags)\n{\n\tu32 info, pad;\n\n\t \n\tinfo = FIELD_PREP(MT_TXD_INFO_LEN, round_up(skb->len, 4)) |\n\t       FIELD_PREP(MT_TXD_INFO_DPORT, port) | flags;\n\tput_unaligned_le32(info, skb_push(skb, sizeof(info)));\n\n\tpad = round_up(skb->len, 4) + 4 - skb->len;\n\treturn mt76_skb_adjust_pad(skb, pad);\n}\n\nint mt76x02u_tx_prepare_skb(struct mt76_dev *mdev, void *data,\n\t\t\t    enum mt76_txq_id qid, struct mt76_wcid *wcid,\n\t\t\t    struct ieee80211_sta *sta,\n\t\t\t    struct mt76_tx_info *tx_info)\n{\n\tstruct mt76x02_dev *dev = container_of(mdev, struct mt76x02_dev, mt76);\n\tint pid, len = tx_info->skb->len, ep = q2ep(dev->mphy.q_tx[qid]->hw_idx);\n\tstruct mt76x02_txwi *txwi;\n\tbool ampdu = IEEE80211_SKB_CB(tx_info->skb)->flags & IEEE80211_TX_CTL_AMPDU;\n\tenum mt76_qsel qsel;\n\tu32 flags;\n\tint err;\n\n\tmt76_insert_hdr_pad(tx_info->skb);\n\n\ttxwi = (struct mt76x02_txwi *)(tx_info->skb->data - sizeof(*txwi));\n\tmt76x02_mac_write_txwi(dev, txwi, tx_info->skb, wcid, sta, len);\n\tskb_push(tx_info->skb, sizeof(*txwi));\n\n\tpid = mt76_tx_status_skb_add(mdev, wcid, tx_info->skb);\n\n\t \n\tif (pid == MT_PACKET_ID_NO_SKB)\n\t\tpid = MT_PACKET_ID_HAS_RATE |\n\t\t      (le16_to_cpu(txwi->rate) & MT_PKTID_RATE) |\n\t\t      FIELD_PREP(MT_PKTID_AC,\n\t\t\t\t skb_get_queue_mapping(tx_info->skb));\n\n\ttxwi->pktid = pid;\n\n\tif ((mt76_is_skb_pktid(pid) && ampdu) || ep == MT_EP_OUT_HCCA)\n\t\tqsel = MT_QSEL_MGMT;\n\telse\n\t\tqsel = MT_QSEL_EDCA;\n\n\tflags = FIELD_PREP(MT_TXD_INFO_QSEL, qsel) |\n\t\tMT_TXD_INFO_80211;\n\tif (!wcid || wcid->hw_key_idx == 0xff || wcid->sw_iv)\n\t\tflags |= MT_TXD_INFO_WIV;\n\n\tif (sta) {\n\t\tstruct mt76x02_sta *msta = (struct mt76x02_sta *)sta->drv_priv;\n\n\t\tewma_pktlen_add(&msta->pktlen, tx_info->skb->len);\n\t}\n\n\terr = mt76x02u_skb_dma_info(tx_info->skb, WLAN_PORT, flags);\n\tif (err && wcid)\n\t\t \n\t\tidr_remove(&wcid->pktid, pid);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mt76x02u_tx_prepare_skb);\n\n \n#define PRE_TBTT_USEC 8000\n\n \n#define N_BCN_SLOTS 5\n\nstatic void mt76x02u_start_pre_tbtt_timer(struct mt76x02_dev *dev)\n{\n\tu64 time;\n\tu32 tbtt;\n\n\t \n\ttbtt = mt76_get_field(dev, MT_TBTT_TIMER, MT_TBTT_TIMER_VAL);\n\ttbtt *= 32;\n\n\tif (tbtt <= PRE_TBTT_USEC) {\n\t\tqueue_work(system_highpri_wq, &dev->pre_tbtt_work);\n\t\treturn;\n\t}\n\n\ttime = (tbtt - PRE_TBTT_USEC) * 1000ull;\n\thrtimer_start(&dev->pre_tbtt_timer, time, HRTIMER_MODE_REL);\n}\n\nstatic void mt76x02u_restart_pre_tbtt_timer(struct mt76x02_dev *dev)\n{\n\tu32 tbtt, dw0, dw1;\n\tu64 tsf, time;\n\n\t \n\ttbtt = mt76_get_field(dev, MT_TBTT_TIMER, MT_TBTT_TIMER_VAL);\n\ttbtt *= 32;\n\n\tdw0 = mt76_rr(dev, MT_TSF_TIMER_DW0);\n\tdw1 = mt76_rr(dev, MT_TSF_TIMER_DW1);\n\ttsf = (u64)dw0 << 32 | dw1;\n\tdev_dbg(dev->mt76.dev, \"TSF: %llu us TBTT %u us\\n\", tsf, tbtt);\n\n\t \n\ttime = ((1000000000ull * dev->mt76.beacon_int) >> 10);\n\n\t \n\tif (tbtt < PRE_TBTT_USEC)\n\t\ttime -= (PRE_TBTT_USEC - tbtt) * 1000ull;\n\telse\n\t\ttime += (tbtt - PRE_TBTT_USEC) * 1000ull;\n\n\thrtimer_start(&dev->pre_tbtt_timer, time, HRTIMER_MODE_REL);\n}\n\nstatic void mt76x02u_stop_pre_tbtt_timer(struct mt76x02_dev *dev)\n{\n\tdo {\n\t\thrtimer_cancel(&dev->pre_tbtt_timer);\n\t\tcancel_work_sync(&dev->pre_tbtt_work);\n\t\t \n\t} while (hrtimer_active(&dev->pre_tbtt_timer));\n}\n\nstatic void mt76x02u_pre_tbtt_work(struct work_struct *work)\n{\n\tstruct mt76x02_dev *dev =\n\t\tcontainer_of(work, struct mt76x02_dev, pre_tbtt_work);\n\tstruct beacon_bc_data data = {};\n\tstruct sk_buff *skb;\n\tint nbeacons;\n\n\tif (!dev->mt76.beacon_mask)\n\t\treturn;\n\n\tif (mt76_hw(dev)->conf.flags & IEEE80211_CONF_OFFCHANNEL)\n\t\treturn;\n\n\tmt76x02_resync_beacon_timer(dev);\n\n\t \n\tmt76_set(dev, MT_BCN_BYPASS_MASK, 0xffff);\n\tdev->beacon_data_count = 0;\n\n\tieee80211_iterate_active_interfaces(mt76_hw(dev),\n\t\tIEEE80211_IFACE_ITER_RESUME_ALL,\n\t\tmt76x02_update_beacon_iter, dev);\n\n\tmt76_csa_check(&dev->mt76);\n\n\tif (dev->mt76.csa_complete) {\n\t\tmt76_csa_finish(&dev->mt76);\n\t\tgoto out;\n\t}\n\n\tnbeacons = hweight8(dev->mt76.beacon_mask);\n\tmt76x02_enqueue_buffered_bc(dev, &data, N_BCN_SLOTS - nbeacons);\n\n\twhile ((skb = __skb_dequeue(&data.q)) != NULL)\n\t\tmt76x02_mac_set_beacon(dev, skb);\n\nout:\n\tmt76_wr(dev, MT_BCN_BYPASS_MASK,\n\t\t0xff00 | ~(0xff00 >> dev->beacon_data_count));\n\n\tmt76x02u_restart_pre_tbtt_timer(dev);\n}\n\nstatic enum hrtimer_restart mt76x02u_pre_tbtt_interrupt(struct hrtimer *timer)\n{\n\tstruct mt76x02_dev *dev =\n\t    container_of(timer, struct mt76x02_dev, pre_tbtt_timer);\n\n\tqueue_work(system_highpri_wq, &dev->pre_tbtt_work);\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic void mt76x02u_pre_tbtt_enable(struct mt76x02_dev *dev, bool en)\n{\n\tif (en && dev->mt76.beacon_mask &&\n\t    !hrtimer_active(&dev->pre_tbtt_timer))\n\t\tmt76x02u_start_pre_tbtt_timer(dev);\n\tif (!en)\n\t\tmt76x02u_stop_pre_tbtt_timer(dev);\n}\n\nstatic void mt76x02u_beacon_enable(struct mt76x02_dev *dev, bool en)\n{\n\tif (WARN_ON_ONCE(!dev->mt76.beacon_int))\n\t\treturn;\n\n\tif (en)\n\t\tmt76x02u_start_pre_tbtt_timer(dev);\n}\n\nvoid mt76x02u_init_beacon_config(struct mt76x02_dev *dev)\n{\n\tstatic const struct mt76x02_beacon_ops beacon_ops = {\n\t\t.nslots = N_BCN_SLOTS,\n\t\t.slot_size = (8192 / N_BCN_SLOTS) & ~63,\n\t\t.pre_tbtt_enable = mt76x02u_pre_tbtt_enable,\n\t\t.beacon_enable = mt76x02u_beacon_enable,\n\t};\n\tdev->beacon_ops = &beacon_ops;\n\n\thrtimer_init(&dev->pre_tbtt_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tdev->pre_tbtt_timer.function = mt76x02u_pre_tbtt_interrupt;\n\tINIT_WORK(&dev->pre_tbtt_work, mt76x02u_pre_tbtt_work);\n\n\tmt76x02_init_beacon_config(dev);\n}\nEXPORT_SYMBOL_GPL(mt76x02u_init_beacon_config);\n\nvoid mt76x02u_exit_beacon_config(struct mt76x02_dev *dev)\n{\n\tif (!test_bit(MT76_REMOVED, &dev->mphy.state))\n\t\tmt76_clear(dev, MT_BEACON_TIME_CFG,\n\t\t\t   MT_BEACON_TIME_CFG_TIMER_EN |\n\t\t\t   MT_BEACON_TIME_CFG_SYNC_MODE |\n\t\t\t   MT_BEACON_TIME_CFG_TBTT_EN |\n\t\t\t   MT_BEACON_TIME_CFG_BEACON_TX);\n\n\tmt76x02u_stop_pre_tbtt_timer(dev);\n}\nEXPORT_SYMBOL_GPL(mt76x02u_exit_beacon_config);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}