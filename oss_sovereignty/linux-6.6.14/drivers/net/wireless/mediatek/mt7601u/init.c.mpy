{
  "module_name": "init.c",
  "hash_id": "9d28ceba7d9ea8f1f230d36c31b21bd82fd2f6f7a6d2784103d24ae02dacd69f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt7601u/init.c",
  "human_readable_source": "\n \n\n#include \"mt7601u.h\"\n#include \"eeprom.h\"\n#include \"trace.h\"\n#include \"mcu.h\"\n\n#include \"initvals.h\"\n\nstatic void\nmt7601u_set_wlan_state(struct mt7601u_dev *dev, u32 val, bool enable)\n{\n\tint i;\n\n\t \n\n\tif (enable)\n\t\tval |= (MT_WLAN_FUN_CTRL_WLAN_EN |\n\t\t\tMT_WLAN_FUN_CTRL_WLAN_CLK_EN);\n\telse\n\t\tval &= ~(MT_WLAN_FUN_CTRL_WLAN_EN);\n\n\tmt7601u_wr(dev, MT_WLAN_FUN_CTRL, val);\n\tudelay(20);\n\n\tif (enable) {\n\t\tset_bit(MT7601U_STATE_WLAN_RUNNING, &dev->state);\n\t} else {\n\t\tclear_bit(MT7601U_STATE_WLAN_RUNNING, &dev->state);\n\t\treturn;\n\t}\n\n\tfor (i = 200; i; i--) {\n\t\tval = mt7601u_rr(dev, MT_CMB_CTRL);\n\n\t\tif (val & MT_CMB_CTRL_XTAL_RDY && val & MT_CMB_CTRL_PLL_LD)\n\t\t\tbreak;\n\n\t\tudelay(20);\n\t}\n\n\t \n\tif (!i)\n\t\tdev_err(dev->dev, \"Error: PLL and XTAL check failed!\\n\");\n}\n\nstatic void mt7601u_chip_onoff(struct mt7601u_dev *dev, bool enable, bool reset)\n{\n\tu32 val;\n\n\tmutex_lock(&dev->hw_atomic_mutex);\n\n\tval = mt7601u_rr(dev, MT_WLAN_FUN_CTRL);\n\n\tif (reset) {\n\t\tval |= MT_WLAN_FUN_CTRL_GPIO_OUT_EN;\n\t\tval &= ~MT_WLAN_FUN_CTRL_FRC_WL_ANT_SEL;\n\n\t\tif (val & MT_WLAN_FUN_CTRL_WLAN_EN) {\n\t\t\tval |= (MT_WLAN_FUN_CTRL_WLAN_RESET |\n\t\t\t\tMT_WLAN_FUN_CTRL_WLAN_RESET_RF);\n\t\t\tmt7601u_wr(dev, MT_WLAN_FUN_CTRL, val);\n\t\t\tudelay(20);\n\n\t\t\tval &= ~(MT_WLAN_FUN_CTRL_WLAN_RESET |\n\t\t\t\t MT_WLAN_FUN_CTRL_WLAN_RESET_RF);\n\t\t}\n\t}\n\n\tmt7601u_wr(dev, MT_WLAN_FUN_CTRL, val);\n\tudelay(20);\n\n\tmt7601u_set_wlan_state(dev, val, enable);\n\n\tmutex_unlock(&dev->hw_atomic_mutex);\n}\n\nstatic void mt7601u_reset_csr_bbp(struct mt7601u_dev *dev)\n{\n\tmt7601u_wr(dev, MT_MAC_SYS_CTRL, (MT_MAC_SYS_CTRL_RESET_CSR |\n\t\t\t\t\t  MT_MAC_SYS_CTRL_RESET_BBP));\n\tmt7601u_wr(dev, MT_USB_DMA_CFG, 0);\n\tmsleep(1);\n\tmt7601u_wr(dev, MT_MAC_SYS_CTRL, 0);\n}\n\nstatic void mt7601u_init_usb_dma(struct mt7601u_dev *dev)\n{\n\tu32 val;\n\n\tval = FIELD_PREP(MT_USB_DMA_CFG_RX_BULK_AGG_TOUT, MT_USB_AGGR_TIMEOUT) |\n\t      FIELD_PREP(MT_USB_DMA_CFG_RX_BULK_AGG_LMT,\n\t\t\t MT_USB_AGGR_SIZE_LIMIT) |\n\t      MT_USB_DMA_CFG_RX_BULK_EN |\n\t      MT_USB_DMA_CFG_TX_BULK_EN;\n\tif (dev->in_max_packet == 512)\n\t\tval |= MT_USB_DMA_CFG_RX_BULK_AGG_EN;\n\tmt7601u_wr(dev, MT_USB_DMA_CFG, val);\n\n\tval |= MT_USB_DMA_CFG_UDMA_RX_WL_DROP;\n\tmt7601u_wr(dev, MT_USB_DMA_CFG, val);\n\tval &= ~MT_USB_DMA_CFG_UDMA_RX_WL_DROP;\n\tmt7601u_wr(dev, MT_USB_DMA_CFG, val);\n}\n\nstatic int mt7601u_init_bbp(struct mt7601u_dev *dev)\n{\n\tint ret;\n\n\tret = mt7601u_wait_bbp_ready(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7601u_write_reg_pairs(dev, MT_MCU_MEMMAP_BBP, bbp_common_vals,\n\t\t\t\t      ARRAY_SIZE(bbp_common_vals));\n\tif (ret)\n\t\treturn ret;\n\n\treturn mt7601u_write_reg_pairs(dev, MT_MCU_MEMMAP_BBP, bbp_chip_vals,\n\t\t\t\t       ARRAY_SIZE(bbp_chip_vals));\n}\n\nstatic void\nmt76_init_beacon_offsets(struct mt7601u_dev *dev)\n{\n\tu16 base = MT_BEACON_BASE;\n\tu32 regs[4] = {};\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tu16 addr = dev->beacon_offsets[i];\n\n\t\tregs[i / 4] |= ((addr - base) / 64) << (8 * (i % 4));\n\t}\n\n\tfor (i = 0; i < 4; i++)\n\t\tmt7601u_wr(dev, MT_BCN_OFFSET(i), regs[i]);\n}\n\nstatic int mt7601u_write_mac_initvals(struct mt7601u_dev *dev)\n{\n\tint ret;\n\n\tret = mt7601u_write_reg_pairs(dev, MT_MCU_MEMMAP_WLAN, mac_common_vals,\n\t\t\t\t      ARRAY_SIZE(mac_common_vals));\n\tif (ret)\n\t\treturn ret;\n\tret = mt7601u_write_reg_pairs(dev, MT_MCU_MEMMAP_WLAN,\n\t\t\t\t      mac_chip_vals, ARRAY_SIZE(mac_chip_vals));\n\tif (ret)\n\t\treturn ret;\n\n\tmt76_init_beacon_offsets(dev);\n\n\tmt7601u_wr(dev, MT_AUX_CLK_CFG, 0);\n\n\treturn 0;\n}\n\nstatic int mt7601u_init_wcid_mem(struct mt7601u_dev *dev)\n{\n\tu32 *vals;\n\tint i, ret;\n\n\tvals = kmalloc(sizeof(*vals) * N_WCIDS * 2, GFP_KERNEL);\n\tif (!vals)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < N_WCIDS; i++)  {\n\t\tvals[i * 2] = 0xffffffff;\n\t\tvals[i * 2 + 1] = 0x00ffffff;\n\t}\n\n\tret = mt7601u_burst_write_regs(dev, MT_WCID_ADDR_BASE,\n\t\t\t\t       vals, N_WCIDS * 2);\n\tkfree(vals);\n\n\treturn ret;\n}\n\nstatic int mt7601u_init_key_mem(struct mt7601u_dev *dev)\n{\n\tu32 vals[4] = {};\n\n\treturn mt7601u_burst_write_regs(dev, MT_SKEY_MODE_BASE_0,\n\t\t\t\t\tvals, ARRAY_SIZE(vals));\n}\n\nstatic int mt7601u_init_wcid_attr_mem(struct mt7601u_dev *dev)\n{\n\tu32 *vals;\n\tint i, ret;\n\n\tvals = kmalloc(sizeof(*vals) * N_WCIDS * 2, GFP_KERNEL);\n\tif (!vals)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < N_WCIDS * 2; i++)\n\t\tvals[i] = 1;\n\n\tret = mt7601u_burst_write_regs(dev, MT_WCID_ATTR_BASE,\n\t\t\t\t       vals, N_WCIDS * 2);\n\tkfree(vals);\n\n\treturn ret;\n}\n\nstatic void mt7601u_reset_counters(struct mt7601u_dev *dev)\n{\n\tmt7601u_rr(dev, MT_RX_STA_CNT0);\n\tmt7601u_rr(dev, MT_RX_STA_CNT1);\n\tmt7601u_rr(dev, MT_RX_STA_CNT2);\n\tmt7601u_rr(dev, MT_TX_STA_CNT0);\n\tmt7601u_rr(dev, MT_TX_STA_CNT1);\n\tmt7601u_rr(dev, MT_TX_STA_CNT2);\n}\n\nint mt7601u_mac_start(struct mt7601u_dev *dev)\n{\n\tmt7601u_wr(dev, MT_MAC_SYS_CTRL, MT_MAC_SYS_CTRL_ENABLE_TX);\n\n\tif (!mt76_poll(dev, MT_WPDMA_GLO_CFG, MT_WPDMA_GLO_CFG_TX_DMA_BUSY |\n\t\t       MT_WPDMA_GLO_CFG_RX_DMA_BUSY, 0, 200000))\n\t\treturn -ETIMEDOUT;\n\n\tdev->rxfilter = MT_RX_FILTR_CFG_CRC_ERR |\n\t\tMT_RX_FILTR_CFG_PHY_ERR | MT_RX_FILTR_CFG_PROMISC |\n\t\tMT_RX_FILTR_CFG_VER_ERR | MT_RX_FILTR_CFG_DUP |\n\t\tMT_RX_FILTR_CFG_CFACK | MT_RX_FILTR_CFG_CFEND |\n\t\tMT_RX_FILTR_CFG_ACK | MT_RX_FILTR_CFG_CTS |\n\t\tMT_RX_FILTR_CFG_RTS | MT_RX_FILTR_CFG_PSPOLL |\n\t\tMT_RX_FILTR_CFG_BA | MT_RX_FILTR_CFG_CTRL_RSV;\n\tmt7601u_wr(dev, MT_RX_FILTR_CFG, dev->rxfilter);\n\n\tmt7601u_wr(dev, MT_MAC_SYS_CTRL,\n\t\t   MT_MAC_SYS_CTRL_ENABLE_TX | MT_MAC_SYS_CTRL_ENABLE_RX);\n\n\tif (!mt76_poll(dev, MT_WPDMA_GLO_CFG, MT_WPDMA_GLO_CFG_TX_DMA_BUSY |\n\t\t       MT_WPDMA_GLO_CFG_RX_DMA_BUSY, 0, 50))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic void mt7601u_mac_stop_hw(struct mt7601u_dev *dev)\n{\n\tint i, ok;\n\n\tif (test_bit(MT7601U_STATE_REMOVED, &dev->state))\n\t\treturn;\n\n\tmt76_clear(dev, MT_BEACON_TIME_CFG, MT_BEACON_TIME_CFG_TIMER_EN |\n\t\t   MT_BEACON_TIME_CFG_SYNC_MODE | MT_BEACON_TIME_CFG_TBTT_EN |\n\t\t   MT_BEACON_TIME_CFG_BEACON_TX);\n\n\tif (!mt76_poll(dev, MT_USB_DMA_CFG, MT_USB_DMA_CFG_TX_BUSY, 0, 1000))\n\t\tdev_warn(dev->dev, \"Warning: TX DMA did not stop!\\n\");\n\n\t \n\ti = 200;\n\twhile (i-- && ((mt76_rr(dev, 0x0438) & 0xffffffff) ||\n\t\t       (mt76_rr(dev, 0x0a30) & 0x000000ff) ||\n\t\t       (mt76_rr(dev, 0x0a34) & 0x00ff00ff)))\n\t\tmsleep(10);\n\n\tif (!mt76_poll(dev, MT_MAC_STATUS, MT_MAC_STATUS_TX, 0, 1000))\n\t\tdev_warn(dev->dev, \"Warning: MAC TX did not stop!\\n\");\n\n\tmt76_clear(dev, MT_MAC_SYS_CTRL, MT_MAC_SYS_CTRL_ENABLE_RX |\n\t\t\t\t\t MT_MAC_SYS_CTRL_ENABLE_TX);\n\n\t \n\tok = 0;\n\ti = 200;\n\twhile (i--) {\n\t\tif (!(mt76_rr(dev, MT_RXQ_STA) & 0x00ff0000) &&\n\t\t    !mt76_rr(dev, 0x0a30) &&\n\t\t    !mt76_rr(dev, 0x0a34)) {\n\t\t\tif (ok++ > 5)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tmsleep(1);\n\t}\n\n\tif (!mt76_poll(dev, MT_MAC_STATUS, MT_MAC_STATUS_RX, 0, 1000))\n\t\tdev_warn(dev->dev, \"Warning: MAC RX did not stop!\\n\");\n\n\tif (!mt76_poll(dev, MT_USB_DMA_CFG, MT_USB_DMA_CFG_RX_BUSY, 0, 1000))\n\t\tdev_warn(dev->dev, \"Warning: RX DMA did not stop!\\n\");\n}\n\nvoid mt7601u_mac_stop(struct mt7601u_dev *dev)\n{\n\tmt7601u_mac_stop_hw(dev);\n\tflush_delayed_work(&dev->stat_work);\n\tcancel_delayed_work_sync(&dev->stat_work);\n}\n\nstatic void mt7601u_stop_hardware(struct mt7601u_dev *dev)\n{\n\tmt7601u_chip_onoff(dev, false, false);\n}\n\nint mt7601u_init_hardware(struct mt7601u_dev *dev)\n{\n\tstatic const u16 beacon_offsets[16] = {\n\t\t \n\t\t0xc000,\t0xc200,\t0xc400,\t0xc600,\n\t\t0xc800,\t0xca00,\t0xcc00,\t0xce00,\n\t\t0xd000,\t0xd200,\t0xd400,\t0xd600,\n\t\t0xd800,\t0xda00,\t0xdc00,\t0xde00\n\t};\n\tint ret;\n\n\tdev->beacon_offsets = beacon_offsets;\n\n\tmt7601u_chip_onoff(dev, true, false);\n\n\tret = mt7601u_wait_asic_ready(dev);\n\tif (ret)\n\t\tgoto err;\n\tret = mt7601u_mcu_init(dev);\n\tif (ret)\n\t\tgoto err;\n\n\tif (!mt76_poll_msec(dev, MT_WPDMA_GLO_CFG,\n\t\t\t    MT_WPDMA_GLO_CFG_TX_DMA_BUSY |\n\t\t\t    MT_WPDMA_GLO_CFG_RX_DMA_BUSY, 0, 100)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t \n\tret = mt7601u_wait_asic_ready(dev);\n\tif (ret)\n\t\tgoto err;\n\n\tmt7601u_reset_csr_bbp(dev);\n\tmt7601u_init_usb_dma(dev);\n\n\tret = mt7601u_mcu_cmd_init(dev);\n\tif (ret)\n\t\tgoto err;\n\tret = mt7601u_dma_init(dev);\n\tif (ret)\n\t\tgoto err_mcu;\n\tret = mt7601u_write_mac_initvals(dev);\n\tif (ret)\n\t\tgoto err_rx;\n\n\tif (!mt76_poll_msec(dev, MT_MAC_STATUS,\n\t\t\t    MT_MAC_STATUS_TX | MT_MAC_STATUS_RX, 0, 100)) {\n\t\tret = -EIO;\n\t\tgoto err_rx;\n\t}\n\n\tret = mt7601u_init_bbp(dev);\n\tif (ret)\n\t\tgoto err_rx;\n\tret = mt7601u_init_wcid_mem(dev);\n\tif (ret)\n\t\tgoto err_rx;\n\tret = mt7601u_init_key_mem(dev);\n\tif (ret)\n\t\tgoto err_rx;\n\tret = mt7601u_init_wcid_attr_mem(dev);\n\tif (ret)\n\t\tgoto err_rx;\n\n\tmt76_clear(dev, MT_BEACON_TIME_CFG, (MT_BEACON_TIME_CFG_TIMER_EN |\n\t\t\t\t\t     MT_BEACON_TIME_CFG_SYNC_MODE |\n\t\t\t\t\t     MT_BEACON_TIME_CFG_TBTT_EN |\n\t\t\t\t\t     MT_BEACON_TIME_CFG_BEACON_TX));\n\n\tmt7601u_reset_counters(dev);\n\n\tmt7601u_rmw(dev, MT_US_CYC_CFG, MT_US_CYC_CNT, 0x1e);\n\n\tmt7601u_wr(dev, MT_TXOP_CTRL_CFG,\n\t\t   FIELD_PREP(MT_TXOP_TRUN_EN, 0x3f) |\n\t\t   FIELD_PREP(MT_TXOP_EXT_CCA_DLY, 0x58));\n\n\tret = mt7601u_eeprom_init(dev);\n\tif (ret)\n\t\tgoto err_rx;\n\n\tret = mt7601u_phy_init(dev);\n\tif (ret)\n\t\tgoto err_rx;\n\n\tmt7601u_set_rx_path(dev, 0);\n\tmt7601u_set_tx_dac(dev, 0);\n\n\tmt7601u_mac_set_ctrlch(dev, false);\n\tmt7601u_bbp_set_ctrlch(dev, false);\n\tmt7601u_bbp_set_bw(dev, MT_BW_20);\n\n\treturn 0;\n\nerr_rx:\n\tmt7601u_dma_cleanup(dev);\nerr_mcu:\n\tmt7601u_mcu_cmd_deinit(dev);\nerr:\n\tmt7601u_chip_onoff(dev, false, false);\n\treturn ret;\n}\n\nvoid mt7601u_cleanup(struct mt7601u_dev *dev)\n{\n\tif (!test_and_clear_bit(MT7601U_STATE_INITIALIZED, &dev->state))\n\t\treturn;\n\n\tmt7601u_stop_hardware(dev);\n\tmt7601u_dma_cleanup(dev);\n\tmt7601u_mcu_cmd_deinit(dev);\n}\n\nstruct mt7601u_dev *mt7601u_alloc_device(struct device *pdev)\n{\n\tstruct ieee80211_hw *hw;\n\tstruct mt7601u_dev *dev;\n\n\thw = ieee80211_alloc_hw(sizeof(*dev), &mt7601u_ops);\n\tif (!hw)\n\t\treturn NULL;\n\n\tdev = hw->priv;\n\tdev->dev = pdev;\n\tdev->hw = hw;\n\tmutex_init(&dev->vendor_req_mutex);\n\tmutex_init(&dev->reg_atomic_mutex);\n\tmutex_init(&dev->hw_atomic_mutex);\n\tmutex_init(&dev->mutex);\n\tspin_lock_init(&dev->tx_lock);\n\tspin_lock_init(&dev->rx_lock);\n\tspin_lock_init(&dev->lock);\n\tspin_lock_init(&dev->mac_lock);\n\tspin_lock_init(&dev->con_mon_lock);\n\tatomic_set(&dev->avg_ampdu_len, 1);\n\tskb_queue_head_init(&dev->tx_skb_done);\n\n\tdev->stat_wq = alloc_workqueue(\"mt7601u\", WQ_UNBOUND, 0);\n\tif (!dev->stat_wq) {\n\t\tieee80211_free_hw(hw);\n\t\treturn NULL;\n\t}\n\n\treturn dev;\n}\n\n#define CHAN2G(_idx, _freq) {\t\t\t\\\n\t.band = NL80211_BAND_2GHZ,\t\t\\\n\t.center_freq = (_freq),\t\t\t\\\n\t.hw_value = (_idx),\t\t\t\\\n\t.max_power = 30,\t\t\t\\\n}\n\nstatic const struct ieee80211_channel mt76_channels_2ghz[] = {\n\tCHAN2G(1, 2412),\n\tCHAN2G(2, 2417),\n\tCHAN2G(3, 2422),\n\tCHAN2G(4, 2427),\n\tCHAN2G(5, 2432),\n\tCHAN2G(6, 2437),\n\tCHAN2G(7, 2442),\n\tCHAN2G(8, 2447),\n\tCHAN2G(9, 2452),\n\tCHAN2G(10, 2457),\n\tCHAN2G(11, 2462),\n\tCHAN2G(12, 2467),\n\tCHAN2G(13, 2472),\n\tCHAN2G(14, 2484),\n};\n\n#define CCK_RATE(_idx, _rate) {\t\t\t\t\t\\\n\t.bitrate = _rate,\t\t\t\t\t\\\n\t.flags = IEEE80211_RATE_SHORT_PREAMBLE,\t\t\t\\\n\t.hw_value = (MT_PHY_TYPE_CCK << 8) | _idx,\t\t\\\n\t.hw_value_short = (MT_PHY_TYPE_CCK << 8) | (8 + _idx),\t\\\n}\n\n#define OFDM_RATE(_idx, _rate) {\t\t\t\t\\\n\t.bitrate = _rate,\t\t\t\t\t\\\n\t.hw_value = (MT_PHY_TYPE_OFDM << 8) | _idx,\t\t\\\n\t.hw_value_short = (MT_PHY_TYPE_OFDM << 8) | _idx,\t\\\n}\n\nstatic struct ieee80211_rate mt76_rates[] = {\n\tCCK_RATE(0, 10),\n\tCCK_RATE(1, 20),\n\tCCK_RATE(2, 55),\n\tCCK_RATE(3, 110),\n\tOFDM_RATE(0, 60),\n\tOFDM_RATE(1, 90),\n\tOFDM_RATE(2, 120),\n\tOFDM_RATE(3, 180),\n\tOFDM_RATE(4, 240),\n\tOFDM_RATE(5, 360),\n\tOFDM_RATE(6, 480),\n\tOFDM_RATE(7, 540),\n};\n\nstatic int\nmt76_init_sband(struct mt7601u_dev *dev, struct ieee80211_supported_band *sband,\n\t\tconst struct ieee80211_channel *chan, int n_chan,\n\t\tstruct ieee80211_rate *rates, int n_rates)\n{\n\tstruct ieee80211_sta_ht_cap *ht_cap;\n\tvoid *chanlist;\n\tint size;\n\n\tsize = n_chan * sizeof(*chan);\n\tchanlist = devm_kmemdup(dev->dev, chan, size, GFP_KERNEL);\n\tif (!chanlist)\n\t\treturn -ENOMEM;\n\n\tsband->channels = chanlist;\n\tsband->n_channels = n_chan;\n\tsband->bitrates = rates;\n\tsband->n_bitrates = n_rates;\n\n\tht_cap = &sband->ht_cap;\n\tht_cap->ht_supported = true;\n\tht_cap->cap = IEEE80211_HT_CAP_SUP_WIDTH_20_40 |\n\t\t      IEEE80211_HT_CAP_GRN_FLD |\n\t\t      IEEE80211_HT_CAP_SGI_20 |\n\t\t      IEEE80211_HT_CAP_SGI_40 |\n\t\t      (1 << IEEE80211_HT_CAP_RX_STBC_SHIFT);\n\n\tht_cap->mcs.rx_mask[0] = 0xff;\n\tht_cap->mcs.rx_mask[4] = 0x1;\n\tht_cap->mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\n\tht_cap->ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;\n\tht_cap->ampdu_density = IEEE80211_HT_MPDU_DENSITY_2;\n\n\tdev->chandef.chan = &sband->channels[0];\n\n\treturn 0;\n}\n\nstatic int\nmt76_init_sband_2g(struct mt7601u_dev *dev)\n{\n\tdev->sband_2g = devm_kzalloc(dev->dev, sizeof(*dev->sband_2g),\n\t\t\t\t     GFP_KERNEL);\n\tif (!dev->sband_2g)\n\t\treturn -ENOMEM;\n\n\tdev->hw->wiphy->bands[NL80211_BAND_2GHZ] = dev->sband_2g;\n\n\tWARN_ON(dev->ee->reg.start - 1 + dev->ee->reg.num >\n\t\tARRAY_SIZE(mt76_channels_2ghz));\n\n\treturn mt76_init_sband(dev, dev->sband_2g,\n\t\t\t       &mt76_channels_2ghz[dev->ee->reg.start - 1],\n\t\t\t       dev->ee->reg.num,\n\t\t\t       mt76_rates, ARRAY_SIZE(mt76_rates));\n}\n\nint mt7601u_register_device(struct mt7601u_dev *dev)\n{\n\tstruct ieee80211_hw *hw = dev->hw;\n\tstruct wiphy *wiphy = hw->wiphy;\n\tint ret;\n\n\t \n\tdev->wcid_mask[0] |= 1;\n\n\t \n\tdev->mon_wcid = devm_kmalloc(dev->dev, sizeof(*dev->mon_wcid),\n\t\t\t\t     GFP_KERNEL);\n\tif (!dev->mon_wcid)\n\t\treturn -ENOMEM;\n\tdev->mon_wcid->idx = 0xff;\n\tdev->mon_wcid->hw_key_idx = -1;\n\n\tSET_IEEE80211_DEV(hw, dev->dev);\n\n\thw->queues = 4;\n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\tieee80211_hw_set(hw, PS_NULLFUNC_STACK);\n\tieee80211_hw_set(hw, SUPPORTS_HT_CCK_RATES);\n\tieee80211_hw_set(hw, AMPDU_AGGREGATION);\n\tieee80211_hw_set(hw, SUPPORTS_RC_TABLE);\n\tieee80211_hw_set(hw, MFP_CAPABLE);\n\thw->max_rates = 1;\n\thw->max_report_rates = 7;\n\thw->max_rate_tries = 1;\n\n\thw->sta_data_size = sizeof(struct mt76_sta);\n\thw->vif_data_size = sizeof(struct mt76_vif);\n\n\tSET_IEEE80211_PERM_ADDR(hw, dev->macaddr);\n\n\twiphy->features |= NL80211_FEATURE_ACTIVE_MONITOR;\n\twiphy->interface_modes = BIT(NL80211_IFTYPE_STATION);\n\twiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS;\n\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\tret = mt76_init_sband_2g(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tINIT_DELAYED_WORK(&dev->mac_work, mt7601u_mac_work);\n\tINIT_DELAYED_WORK(&dev->stat_work, mt7601u_tx_stat);\n\n\tret = ieee80211_register_hw(hw);\n\tif (ret)\n\t\treturn ret;\n\n\tmt7601u_init_debugfs(dev);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}