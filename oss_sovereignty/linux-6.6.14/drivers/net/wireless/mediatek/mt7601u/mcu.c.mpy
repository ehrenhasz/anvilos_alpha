{
  "module_name": "mcu.c",
  "hash_id": "4d8bfd2eefd29f991e86239aead7f7d0fdfaaf36b9a6e63139f8e704d693edb6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt7601u/mcu.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/firmware.h>\n#include <linux/delay.h>\n#include <linux/usb.h>\n#include <linux/skbuff.h>\n\n#include \"mt7601u.h\"\n#include \"dma.h\"\n#include \"mcu.h\"\n#include \"usb.h\"\n#include \"trace.h\"\n\n#define MCU_FW_URB_MAX_PAYLOAD\t\t0x3800\n#define MCU_FW_URB_SIZE\t\t\t(MCU_FW_URB_MAX_PAYLOAD + 12)\n#define MCU_RESP_URB_SIZE\t\t1024\n\nstatic inline int firmware_running(struct mt7601u_dev *dev)\n{\n\treturn mt7601u_rr(dev, MT_MCU_COM_REG0) == 1;\n}\n\nstatic inline void skb_put_le32(struct sk_buff *skb, u32 val)\n{\n\tput_unaligned_le32(val, skb_put(skb, 4));\n}\n\nstatic inline void mt7601u_dma_skb_wrap_cmd(struct sk_buff *skb,\n\t\t\t\t\t    u8 seq, enum mcu_cmd cmd)\n{\n\tWARN_ON(mt7601u_dma_skb_wrap(skb, CPU_TX_PORT, DMA_COMMAND,\n\t\t\t\t     FIELD_PREP(MT_TXD_CMD_INFO_SEQ, seq) |\n\t\t\t\t     FIELD_PREP(MT_TXD_CMD_INFO_TYPE, cmd)));\n}\n\nstatic inline void trace_mt_mcu_msg_send_cs(struct mt7601u_dev *dev,\n\t\t\t\t\t    struct sk_buff *skb, bool need_resp)\n{\n\tu32 i, csum = 0;\n\n\tfor (i = 0; i < skb->len / 4; i++)\n\t\tcsum ^= get_unaligned_le32(skb->data + i * 4);\n\n\ttrace_mt_mcu_msg_send(dev, skb, csum, need_resp);\n}\n\nstatic struct sk_buff *mt7601u_mcu_msg_alloc(const void *data, int len)\n{\n\tstruct sk_buff *skb;\n\n\tWARN_ON(len % 4);  \n\n\tskb = alloc_skb(len + MT_DMA_HDR_LEN + 4, GFP_KERNEL);\n\tif (skb) {\n\t\tskb_reserve(skb, MT_DMA_HDR_LEN);\n\t\tskb_put_data(skb, data, len);\n\t}\n\n\treturn skb;\n}\n\nstatic int mt7601u_mcu_wait_resp(struct mt7601u_dev *dev, u8 seq)\n{\n\tstruct urb *urb = dev->mcu.resp.urb;\n\tu32 rxfce;\n\tint urb_status, ret, i = 5;\n\n\twhile (i--) {\n\t\tif (!wait_for_completion_timeout(&dev->mcu.resp_cmpl,\n\t\t\t\t\t\t msecs_to_jiffies(300))) {\n\t\t\tdev_warn(dev->dev, \"Warning: %s retrying\\n\", __func__);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\trxfce = get_unaligned_le32(dev->mcu.resp.buf);\n\t\turb_status = urb->status * mt7601u_urb_has_error(urb);\n\n\t\tret = mt7601u_usb_submit_buf(dev, USB_DIR_IN, MT_EP_IN_CMD_RESP,\n\t\t\t\t\t     &dev->mcu.resp, GFP_KERNEL,\n\t\t\t\t\t     mt7601u_complete_urb,\n\t\t\t\t\t     &dev->mcu.resp_cmpl);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (urb_status)\n\t\t\tdev_err(dev->dev, \"Error: MCU resp urb failed:%d\\n\",\n\t\t\t\turb_status);\n\n\t\tif (FIELD_GET(MT_RXD_CMD_INFO_CMD_SEQ, rxfce) == seq &&\n\t\t    FIELD_GET(MT_RXD_CMD_INFO_EVT_TYPE, rxfce) == CMD_DONE)\n\t\t\treturn 0;\n\n\t\tdev_err(dev->dev, \"Error: MCU resp evt:%lx seq:%hhx-%lx!\\n\",\n\t\t\tFIELD_GET(MT_RXD_CMD_INFO_EVT_TYPE, rxfce),\n\t\t\tseq, FIELD_GET(MT_RXD_CMD_INFO_CMD_SEQ, rxfce));\n\t}\n\n\tdev_err(dev->dev, \"Error: %s timed out\\n\", __func__);\n\treturn -ETIMEDOUT;\n}\n\nstatic int\nmt7601u_mcu_msg_send(struct mt7601u_dev *dev, struct sk_buff *skb,\n\t\t     enum mcu_cmd cmd, bool wait_resp)\n{\n\tstruct usb_device *usb_dev = mt7601u_to_usb_dev(dev);\n\tunsigned cmd_pipe = usb_sndbulkpipe(usb_dev,\n\t\t\t\t\t    dev->out_eps[MT_EP_OUT_INBAND_CMD]);\n\tint sent, ret;\n\tu8 seq = 0;\n\n\tif (test_bit(MT7601U_STATE_REMOVED, &dev->state)) {\n\t\tconsume_skb(skb);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&dev->mcu.mutex);\n\n\tif (wait_resp)\n\t\twhile (!seq)\n\t\t\tseq = ++dev->mcu.msg_seq & 0xf;\n\n\tmt7601u_dma_skb_wrap_cmd(skb, seq, cmd);\n\n\tif (dev->mcu.resp_cmpl.done)\n\t\tdev_err(dev->dev, \"Error: MCU response pre-completed!\\n\");\n\n\ttrace_mt_mcu_msg_send_cs(dev, skb, wait_resp);\n\ttrace_mt_submit_urb_sync(dev, cmd_pipe, skb->len);\n\tret = usb_bulk_msg(usb_dev, cmd_pipe, skb->data, skb->len, &sent, 500);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Error: send MCU cmd failed:%d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (sent != skb->len)\n\t\tdev_err(dev->dev, \"Error: %s sent != skb->len\\n\", __func__);\n\n\tif (wait_resp)\n\t\tret = mt7601u_mcu_wait_resp(dev, seq);\nout:\n\tmutex_unlock(&dev->mcu.mutex);\n\n\tconsume_skb(skb);\n\n\treturn ret;\n}\n\nstatic int mt7601u_mcu_function_select(struct mt7601u_dev *dev,\n\t\t\t\t       enum mcu_function func, u32 val)\n{\n\tstruct sk_buff *skb;\n\tstruct {\n\t\t__le32 id;\n\t\t__le32 value;\n\t} __packed __aligned(4) msg = {\n\t\t.id = cpu_to_le32(func),\n\t\t.value = cpu_to_le32(val),\n\t};\n\n\tskb = mt7601u_mcu_msg_alloc(&msg, sizeof(msg));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\treturn mt7601u_mcu_msg_send(dev, skb, CMD_FUN_SET_OP, func == 5);\n}\n\nint mt7601u_mcu_tssi_read_kick(struct mt7601u_dev *dev, int use_hvga)\n{\n\tint ret;\n\n\tif (!test_bit(MT7601U_STATE_MCU_RUNNING, &dev->state))\n\t\treturn 0;\n\n\tret = mt7601u_mcu_function_select(dev, ATOMIC_TSSI_SETTING,\n\t\t\t\t\t  use_hvga);\n\tif (ret) {\n\t\tdev_warn(dev->dev, \"Warning: MCU TSSI read kick failed\\n\");\n\t\treturn ret;\n\t}\n\n\tdev->tssi_read_trig = true;\n\n\treturn 0;\n}\n\nint\nmt7601u_mcu_calibrate(struct mt7601u_dev *dev, enum mcu_calibrate cal, u32 val)\n{\n\tstruct sk_buff *skb;\n\tstruct {\n\t\t__le32 id;\n\t\t__le32 value;\n\t} __packed __aligned(4) msg = {\n\t\t.id = cpu_to_le32(cal),\n\t\t.value = cpu_to_le32(val),\n\t};\n\n\tskb = mt7601u_mcu_msg_alloc(&msg, sizeof(msg));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\treturn mt7601u_mcu_msg_send(dev, skb, CMD_CALIBRATION_OP, true);\n}\n\nint mt7601u_write_reg_pairs(struct mt7601u_dev *dev, u32 base,\n\t\t\t    const struct mt76_reg_pair *data, int n)\n{\n\tconst int max_vals_per_cmd = INBAND_PACKET_MAX_LEN / 8;\n\tstruct sk_buff *skb;\n\tint cnt, i, ret;\n\n\tif (!n)\n\t\treturn 0;\n\n\tcnt = min(max_vals_per_cmd, n);\n\n\tskb = alloc_skb(cnt * 8 + MT_DMA_HDR_LEN + 4, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tskb_reserve(skb, MT_DMA_HDR_LEN);\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tskb_put_le32(skb, base + data[i].reg);\n\t\tskb_put_le32(skb, data[i].value);\n\t}\n\n\tret = mt7601u_mcu_msg_send(dev, skb, CMD_RANDOM_WRITE, cnt == n);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mt7601u_write_reg_pairs(dev, base, data + cnt, n - cnt);\n}\n\nint mt7601u_burst_write_regs(struct mt7601u_dev *dev, u32 offset,\n\t\t\t     const u32 *data, int n)\n{\n\tconst int max_regs_per_cmd = INBAND_PACKET_MAX_LEN / 4 - 1;\n\tstruct sk_buff *skb;\n\tint cnt, i, ret;\n\n\tif (!n)\n\t\treturn 0;\n\n\tcnt = min(max_regs_per_cmd, n);\n\n\tskb = alloc_skb(cnt * 4 + MT_DMA_HDR_LEN + 4, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tskb_reserve(skb, MT_DMA_HDR_LEN);\n\n\tskb_put_le32(skb, MT_MCU_MEMMAP_WLAN + offset);\n\tfor (i = 0; i < cnt; i++)\n\t\tskb_put_le32(skb, data[i]);\n\n\tret = mt7601u_mcu_msg_send(dev, skb, CMD_BURST_WRITE, cnt == n);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mt7601u_burst_write_regs(dev, offset + cnt * 4,\n\t\t\t\t\tdata + cnt, n - cnt);\n}\n\nstruct mt76_fw_header {\n\t__le32 ilm_len;\n\t__le32 dlm_len;\n\t__le16 build_ver;\n\t__le16 fw_ver;\n\tu8 pad[4];\n\tchar build_time[16];\n};\n\nstruct mt76_fw {\n\tstruct mt76_fw_header hdr;\n\tu8 ivb[MT_MCU_IVB_SIZE];\n\tu8 ilm[];\n};\n\nstatic int __mt7601u_dma_fw(struct mt7601u_dev *dev,\n\t\t\t    const struct mt7601u_dma_buf *dma_buf,\n\t\t\t    const void *data, u32 len, u32 dst_addr)\n{\n\tDECLARE_COMPLETION_ONSTACK(cmpl);\n\tstruct mt7601u_dma_buf buf = *dma_buf;  \n\t__le32 reg;\n\tu32 val;\n\tint ret;\n\n\treg = cpu_to_le32(FIELD_PREP(MT_TXD_INFO_TYPE, DMA_PACKET) |\n\t\t\t  FIELD_PREP(MT_TXD_INFO_D_PORT, CPU_TX_PORT) |\n\t\t\t  FIELD_PREP(MT_TXD_INFO_LEN, len));\n\tmemcpy(buf.buf, &reg, sizeof(reg));\n\tmemcpy(buf.buf + sizeof(reg), data, len);\n\tmemset(buf.buf + sizeof(reg) + len, 0, 8);\n\n\tret = mt7601u_vendor_single_wr(dev, MT_VEND_WRITE_FCE,\n\t\t\t\t       MT_FCE_DMA_ADDR, dst_addr);\n\tif (ret)\n\t\treturn ret;\n\tlen = roundup(len, 4);\n\tret = mt7601u_vendor_single_wr(dev, MT_VEND_WRITE_FCE,\n\t\t\t\t       MT_FCE_DMA_LEN, len << 16);\n\tif (ret)\n\t\treturn ret;\n\n\tbuf.len = MT_DMA_HDR_LEN + len + 4;\n\tret = mt7601u_usb_submit_buf(dev, USB_DIR_OUT, MT_EP_OUT_INBAND_CMD,\n\t\t\t\t     &buf, GFP_KERNEL,\n\t\t\t\t     mt7601u_complete_urb, &cmpl);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!wait_for_completion_timeout(&cmpl, msecs_to_jiffies(1000))) {\n\t\tdev_err(dev->dev, \"Error: firmware upload timed out\\n\");\n\t\tusb_kill_urb(buf.urb);\n\t\treturn -ETIMEDOUT;\n\t}\n\tif (mt7601u_urb_has_error(buf.urb)) {\n\t\tdev_err(dev->dev, \"Error: firmware upload urb failed:%d\\n\",\n\t\t\tbuf.urb->status);\n\t\treturn buf.urb->status;\n\t}\n\n\tval = mt7601u_rr(dev, MT_TX_CPU_FROM_FCE_CPU_DESC_IDX);\n\tval++;\n\tmt7601u_wr(dev, MT_TX_CPU_FROM_FCE_CPU_DESC_IDX, val);\n\n\treturn 0;\n}\n\nstatic int\nmt7601u_dma_fw(struct mt7601u_dev *dev, struct mt7601u_dma_buf *dma_buf,\n\t       const void *data, int len, u32 dst_addr)\n{\n\tint n, ret;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\tn = min(MCU_FW_URB_MAX_PAYLOAD, len);\n\tret = __mt7601u_dma_fw(dev, dma_buf, data, n, dst_addr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!mt76_poll_msec(dev, MT_MCU_COM_REG1, BIT(31), BIT(31), 500))\n\t\treturn -ETIMEDOUT;\n\n\treturn mt7601u_dma_fw(dev, dma_buf, data + n, len - n, dst_addr + n);\n}\n\nstatic int\nmt7601u_upload_firmware(struct mt7601u_dev *dev, const struct mt76_fw *fw)\n{\n\tstruct mt7601u_dma_buf dma_buf;\n\tvoid *ivb;\n\tu32 ilm_len, dlm_len;\n\tint i, ret;\n\n\tivb = kmemdup(fw->ivb, sizeof(fw->ivb), GFP_KERNEL);\n\tif (!ivb)\n\t\treturn -ENOMEM;\n\tif (mt7601u_usb_alloc_buf(dev, MCU_FW_URB_SIZE, &dma_buf)) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tilm_len = le32_to_cpu(fw->hdr.ilm_len) - sizeof(fw->ivb);\n\tdev_dbg(dev->dev, \"loading FW - ILM %u + IVB %zu\\n\",\n\t\tilm_len, sizeof(fw->ivb));\n\tret = mt7601u_dma_fw(dev, &dma_buf, fw->ilm, ilm_len, sizeof(fw->ivb));\n\tif (ret)\n\t\tgoto error;\n\n\tdlm_len = le32_to_cpu(fw->hdr.dlm_len);\n\tdev_dbg(dev->dev, \"loading FW - DLM %u\\n\", dlm_len);\n\tret = mt7601u_dma_fw(dev, &dma_buf, fw->ilm + ilm_len,\n\t\t\t     dlm_len, MT_MCU_DLM_OFFSET);\n\tif (ret)\n\t\tgoto error;\n\n\tret = mt7601u_vendor_request(dev, MT_VEND_DEV_MODE, USB_DIR_OUT,\n\t\t\t\t     0x12, 0, ivb, sizeof(fw->ivb));\n\tif (ret < 0)\n\t\tgoto error;\n\tret = 0;\n\n\tfor (i = 100; i && !firmware_running(dev); i--)\n\t\tmsleep(10);\n\tif (!i) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto error;\n\t}\n\n\tdev_dbg(dev->dev, \"Firmware running!\\n\");\nerror:\n\tkfree(ivb);\n\tmt7601u_usb_free_buf(dev, &dma_buf);\n\n\treturn ret;\n}\n\nstatic int mt7601u_load_firmware(struct mt7601u_dev *dev)\n{\n\tconst struct firmware *fw;\n\tconst struct mt76_fw_header *hdr;\n\tint len, ret;\n\tu32 val;\n\n\tmt7601u_wr(dev, MT_USB_DMA_CFG, (MT_USB_DMA_CFG_RX_BULK_EN |\n\t\t\t\t\t MT_USB_DMA_CFG_TX_BULK_EN));\n\n\tif (firmware_running(dev))\n\t\treturn firmware_request_cache(dev->dev, MT7601U_FIRMWARE);\n\n\tret = request_firmware(&fw, MT7601U_FIRMWARE, dev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!fw || !fw->data || fw->size < sizeof(*hdr))\n\t\tgoto err_inv_fw;\n\n\thdr = (const struct mt76_fw_header *) fw->data;\n\n\tif (le32_to_cpu(hdr->ilm_len) <= MT_MCU_IVB_SIZE)\n\t\tgoto err_inv_fw;\n\n\tlen = sizeof(*hdr);\n\tlen += le32_to_cpu(hdr->ilm_len);\n\tlen += le32_to_cpu(hdr->dlm_len);\n\n\tif (fw->size != len)\n\t\tgoto err_inv_fw;\n\n\tval = le16_to_cpu(hdr->fw_ver);\n\tdev_info(dev->dev,\n\t\t \"Firmware Version: %d.%d.%02d Build: %x Build time: %.16s\\n\",\n\t\t (val >> 12) & 0xf, (val >> 8) & 0xf, val & 0xf,\n\t\t le16_to_cpu(hdr->build_ver), hdr->build_time);\n\n\tlen = le32_to_cpu(hdr->ilm_len);\n\n\tmt7601u_wr(dev, 0x94c, 0);\n\tmt7601u_wr(dev, MT_FCE_PSE_CTRL, 0);\n\n\tmt7601u_vendor_reset(dev);\n\tmsleep(5);\n\n\tmt7601u_wr(dev, 0xa44, 0);\n\tmt7601u_wr(dev, 0x230, 0x84210);\n\tmt7601u_wr(dev, 0x400, 0x80c00);\n\tmt7601u_wr(dev, 0x800, 1);\n\n\tmt7601u_rmw(dev, MT_PBF_CFG, 0, (MT_PBF_CFG_TX0Q_EN |\n\t\t\t\t\t MT_PBF_CFG_TX1Q_EN |\n\t\t\t\t\t MT_PBF_CFG_TX2Q_EN |\n\t\t\t\t\t MT_PBF_CFG_TX3Q_EN));\n\n\tmt7601u_wr(dev, MT_FCE_PSE_CTRL, 1);\n\n\tmt7601u_wr(dev, MT_USB_DMA_CFG, (MT_USB_DMA_CFG_RX_BULK_EN |\n\t\t\t\t\t MT_USB_DMA_CFG_TX_BULK_EN));\n\tval = mt76_set(dev, MT_USB_DMA_CFG, MT_USB_DMA_CFG_TX_CLR);\n\tval &= ~MT_USB_DMA_CFG_TX_CLR;\n\tmt7601u_wr(dev, MT_USB_DMA_CFG, val);\n\n\t \n\tmt7601u_wr(dev, MT_TX_CPU_FROM_FCE_BASE_PTR, 0x400230);\n\t \n\tmt7601u_wr(dev, MT_TX_CPU_FROM_FCE_MAX_COUNT, 1);\n\t \n\tmt7601u_wr(dev, MT_FCE_PDMA_GLOBAL_CONF, 0x44);\n\t \n\tmt7601u_wr(dev, MT_FCE_SKIP_FS, 3);\n\n\tret = mt7601u_upload_firmware(dev, (const struct mt76_fw *)fw->data);\n\n\trelease_firmware(fw);\n\n\treturn ret;\n\nerr_inv_fw:\n\tdev_err(dev->dev, \"Invalid firmware image\\n\");\n\trelease_firmware(fw);\n\treturn -ENOENT;\n}\n\nint mt7601u_mcu_init(struct mt7601u_dev *dev)\n{\n\tint ret;\n\n\tmutex_init(&dev->mcu.mutex);\n\n\tret = mt7601u_load_firmware(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tset_bit(MT7601U_STATE_MCU_RUNNING, &dev->state);\n\n\treturn 0;\n}\n\nint mt7601u_mcu_cmd_init(struct mt7601u_dev *dev)\n{\n\tint ret;\n\n\tret = mt7601u_mcu_function_select(dev, Q_SELECT, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tinit_completion(&dev->mcu.resp_cmpl);\n\tif (mt7601u_usb_alloc_buf(dev, MCU_RESP_URB_SIZE, &dev->mcu.resp)) {\n\t\tmt7601u_usb_free_buf(dev, &dev->mcu.resp);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = mt7601u_usb_submit_buf(dev, USB_DIR_IN, MT_EP_IN_CMD_RESP,\n\t\t\t\t     &dev->mcu.resp, GFP_KERNEL,\n\t\t\t\t     mt7601u_complete_urb, &dev->mcu.resp_cmpl);\n\tif (ret) {\n\t\tmt7601u_usb_free_buf(dev, &dev->mcu.resp);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid mt7601u_mcu_cmd_deinit(struct mt7601u_dev *dev)\n{\n\tusb_kill_urb(dev->mcu.resp.urb);\n\tmt7601u_usb_free_buf(dev, &dev->mcu.resp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}