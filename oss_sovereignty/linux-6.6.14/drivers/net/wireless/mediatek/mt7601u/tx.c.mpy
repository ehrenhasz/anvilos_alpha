{
  "module_name": "tx.c",
  "hash_id": "0f82ae11f96dae6764ceb739981d5db4a486545a41f3d653302a63f3ed44d585",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt7601u/tx.c",
  "human_readable_source": "\n \n\n#include \"mt7601u.h\"\n#include \"trace.h\"\n\nenum mt76_txq_id {\n\tMT_TXQ_VO = IEEE80211_AC_VO,\n\tMT_TXQ_VI = IEEE80211_AC_VI,\n\tMT_TXQ_BE = IEEE80211_AC_BE,\n\tMT_TXQ_BK = IEEE80211_AC_BK,\n\tMT_TXQ_PSD,\n\tMT_TXQ_MCU,\n\t__MT_TXQ_MAX\n};\n\n \nstatic u8 q2hwq(u8 q)\n{\n\treturn q ^ 0x3;\n}\n\n \nstatic u8 skb2q(struct sk_buff *skb)\n{\n\tint qid = skb_get_queue_mapping(skb);\n\n\tif (WARN_ON(qid >= MT_TXQ_PSD)) {\n\t\tqid = MT_TXQ_BE;\n\t\tskb_set_queue_mapping(skb, qid);\n\t}\n\n\treturn q2hwq(qid);\n}\n\n \nstatic u8 mt7601u_tx_pktid_enc(struct mt7601u_dev *dev, u8 rate, bool is_probe)\n{\n\tu8 encoded = (rate + 1) + is_probe *  8;\n\n\t \n\tif (is_probe && rate == 7)\n\t\treturn encoded - 7;\n\n\treturn encoded;\n}\n\nstatic void\nmt7601u_tx_pktid_dec(struct mt7601u_dev *dev, struct mt76_tx_status *stat)\n{\n\tu8 req_rate = stat->pktid;\n\tu8 eff_rate = stat->rate & 0x7;\n\n\treq_rate -= 1;\n\n\tif (req_rate > 7) {\n\t\tstat->is_probe = true;\n\t\treq_rate -= 8;\n\n\t\t \n\t\tif (!req_rate && eff_rate)\n\t\t\treq_rate = 7;\n\t}\n\n\tstat->retry = req_rate - eff_rate;\n}\n\nstatic void mt7601u_tx_skb_remove_dma_overhead(struct sk_buff *skb,\n\t\t\t\t\t       struct ieee80211_tx_info *info)\n{\n\tint pkt_len = (unsigned long)info->status.status_driver_data[0];\n\n\tskb_pull(skb, sizeof(struct mt76_txwi) + 4);\n\tif (ieee80211_get_hdrlen_from_skb(skb) % 4)\n\t\tmt76_remove_hdr_pad(skb);\n\n\tskb_trim(skb, pkt_len);\n}\n\nvoid mt7601u_tx_status(struct mt7601u_dev *dev, struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\n\tmt7601u_tx_skb_remove_dma_overhead(skb, info);\n\n\tieee80211_tx_info_clear_status(info);\n\tinfo->status.rates[0].idx = -1;\n\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\n\tspin_lock_bh(&dev->mac_lock);\n\tieee80211_tx_status(dev->hw, skb);\n\tspin_unlock_bh(&dev->mac_lock);\n}\n\nstatic int mt7601u_skb_rooms(struct mt7601u_dev *dev, struct sk_buff *skb)\n{\n\tint hdr_len = ieee80211_get_hdrlen_from_skb(skb);\n\tu32 need_head;\n\n\tneed_head = sizeof(struct mt76_txwi) + 4;\n\tif (hdr_len % 4)\n\t\tneed_head += 2;\n\n\treturn skb_cow(skb, need_head);\n}\n\nstatic struct mt76_txwi *\nmt7601u_push_txwi(struct mt7601u_dev *dev, struct sk_buff *skb,\n\t\t  struct ieee80211_sta *sta, struct mt76_wcid *wcid,\n\t\t  int pkt_len)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_tx_rate *rate = &info->control.rates[0];\n\tstruct mt76_txwi *txwi;\n\tunsigned long flags;\n\tbool is_probe;\n\tu32 pkt_id;\n\tu16 rate_ctl;\n\tu8 nss;\n\n\ttxwi = skb_push(skb, sizeof(struct mt76_txwi));\n\tmemset(txwi, 0, sizeof(*txwi));\n\n\tif (!wcid->tx_rate_set)\n\t\tieee80211_get_tx_rates(info->control.vif, sta, skb,\n\t\t\t\t       info->control.rates, 1);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (rate->idx < 0 || !rate->count)\n\t\trate_ctl = wcid->tx_rate;\n\telse\n\t\trate_ctl = mt76_mac_tx_rate_val(dev, rate, &nss);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\ttxwi->rate_ctl = cpu_to_le16(rate_ctl);\n\n\tif (!(info->flags & IEEE80211_TX_CTL_NO_ACK))\n\t\ttxwi->ack_ctl |= MT_TXWI_ACK_CTL_REQ;\n\tif (info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ)\n\t\ttxwi->ack_ctl |= MT_TXWI_ACK_CTL_NSEQ;\n\n\tif ((info->flags & IEEE80211_TX_CTL_AMPDU) && sta) {\n\t\tu8 ba_size = IEEE80211_MIN_AMPDU_BUF;\n\n\t\tba_size <<= sta->deflink.ht_cap.ampdu_factor;\n\t\tba_size = min_t(int, 63, ba_size);\n\t\tif (info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE)\n\t\t\tba_size = 0;\n\t\ttxwi->ack_ctl |= FIELD_PREP(MT_TXWI_ACK_CTL_BA_WINDOW, ba_size);\n\n\t\ttxwi->flags =\n\t\t\tcpu_to_le16(MT_TXWI_FLAGS_AMPDU |\n\t\t\t\t    FIELD_PREP(MT_TXWI_FLAGS_MPDU_DENSITY,\n\t\t\t\t\t       sta->deflink.ht_cap.ampdu_density));\n\t\tif (info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE)\n\t\t\ttxwi->flags = 0;\n\t}\n\n\ttxwi->wcid = wcid->idx;\n\n\tis_probe = !!(info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE);\n\tpkt_id = mt7601u_tx_pktid_enc(dev, rate_ctl & 0x7, is_probe);\n\tpkt_len |= FIELD_PREP(MT_TXWI_LEN_PKTID, pkt_id);\n\ttxwi->len_ctl = cpu_to_le16(pkt_len);\n\n\treturn txwi;\n}\n\nvoid mt7601u_tx(struct ieee80211_hw *hw, struct ieee80211_tx_control *control,\n\t\tstruct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct mt7601u_dev *dev = hw->priv;\n\tstruct ieee80211_vif *vif = info->control.vif;\n\tstruct ieee80211_sta *sta = control->sta;\n\tstruct mt76_sta *msta = NULL;\n\tstruct mt76_wcid *wcid = dev->mon_wcid;\n\tstruct mt76_txwi *txwi;\n\tint pkt_len = skb->len;\n\tint hw_q = skb2q(skb);\n\n\tBUILD_BUG_ON(ARRAY_SIZE(info->status.status_driver_data) < 1);\n\tinfo->status.status_driver_data[0] = (void *)(unsigned long)pkt_len;\n\n\tif (mt7601u_skb_rooms(dev, skb) || mt76_insert_hdr_pad(skb)) {\n\t\tieee80211_free_txskb(dev->hw, skb);\n\t\treturn;\n\t}\n\n\tif (sta) {\n\t\tmsta = (struct mt76_sta *) sta->drv_priv;\n\t\twcid = &msta->wcid;\n\t} else if (vif) {\n\t\tstruct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;\n\n\t\twcid = &mvif->group_wcid;\n\t}\n\n\ttxwi = mt7601u_push_txwi(dev, skb, sta, wcid, pkt_len);\n\n\tif (mt7601u_dma_enqueue_tx(dev, skb, wcid, hw_q))\n\t\treturn;\n\n\ttrace_mt_tx(dev, skb, msta, txwi);\n}\n\nvoid mt7601u_tx_stat(struct work_struct *work)\n{\n\tstruct mt7601u_dev *dev = container_of(work, struct mt7601u_dev,\n\t\t\t\t\t       stat_work.work);\n\tstruct mt76_tx_status stat;\n\tunsigned long flags;\n\tint cleaned = 0;\n\n\twhile (!test_bit(MT7601U_STATE_REMOVED, &dev->state)) {\n\t\tstat = mt7601u_mac_fetch_tx_status(dev);\n\t\tif (!stat.valid)\n\t\t\tbreak;\n\n\t\tmt7601u_tx_pktid_dec(dev, &stat);\n\t\tmt76_send_tx_status(dev, &stat);\n\n\t\tcleaned++;\n\t}\n\ttrace_mt_tx_status_cleaned(dev, cleaned);\n\n\tspin_lock_irqsave(&dev->tx_lock, flags);\n\tif (cleaned)\n\t\tqueue_delayed_work(dev->stat_wq, &dev->stat_work,\n\t\t\t\t   msecs_to_jiffies(10));\n\telse if (test_and_clear_bit(MT7601U_STATE_MORE_STATS, &dev->state))\n\t\tqueue_delayed_work(dev->stat_wq, &dev->stat_work,\n\t\t\t\t   msecs_to_jiffies(20));\n\telse\n\t\tclear_bit(MT7601U_STATE_READING_STATS, &dev->state);\n\tspin_unlock_irqrestore(&dev->tx_lock, flags);\n}\n\nint mt7601u_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t    unsigned int link_id, u16 queue,\n\t\t    const struct ieee80211_tx_queue_params *params)\n{\n\tstruct mt7601u_dev *dev = hw->priv;\n\tu8 cw_min = 5, cw_max = 10, hw_q = q2hwq(queue);\n\tu32 val;\n\n\t \n\n\tif (params->cw_min)\n\t\tcw_min = fls(params->cw_min);\n\tif (params->cw_max)\n\t\tcw_max = fls(params->cw_max);\n\n\tWARN_ON(params->txop > 0xff);\n\tWARN_ON(params->aifs > 0xf);\n\tWARN_ON(cw_min > 0xf);\n\tWARN_ON(cw_max > 0xf);\n\n\tval = FIELD_PREP(MT_EDCA_CFG_AIFSN, params->aifs) |\n\t      FIELD_PREP(MT_EDCA_CFG_CWMIN, cw_min) |\n\t      FIELD_PREP(MT_EDCA_CFG_CWMAX, cw_max);\n\t \n\tif (!hw_q)\n\t\tval |= 0x60;\n\telse\n\t\tval |= FIELD_PREP(MT_EDCA_CFG_TXOP, params->txop);\n\tmt76_wr(dev, MT_EDCA_CFG_AC(hw_q), val);\n\n\tval = mt76_rr(dev, MT_WMM_TXOP(hw_q));\n\tval &= ~(MT_WMM_TXOP_MASK << MT_WMM_TXOP_SHIFT(hw_q));\n\tval |= params->txop << MT_WMM_TXOP_SHIFT(hw_q);\n\tmt76_wr(dev, MT_WMM_TXOP(hw_q), val);\n\n\tval = mt76_rr(dev, MT_WMM_AIFSN);\n\tval &= ~(MT_WMM_AIFSN_MASK << MT_WMM_AIFSN_SHIFT(hw_q));\n\tval |= params->aifs << MT_WMM_AIFSN_SHIFT(hw_q);\n\tmt76_wr(dev, MT_WMM_AIFSN, val);\n\n\tval = mt76_rr(dev, MT_WMM_CWMIN);\n\tval &= ~(MT_WMM_CWMIN_MASK << MT_WMM_CWMIN_SHIFT(hw_q));\n\tval |= cw_min << MT_WMM_CWMIN_SHIFT(hw_q);\n\tmt76_wr(dev, MT_WMM_CWMIN, val);\n\n\tval = mt76_rr(dev, MT_WMM_CWMAX);\n\tval &= ~(MT_WMM_CWMAX_MASK << MT_WMM_CWMAX_SHIFT(hw_q));\n\tval |= cw_max << MT_WMM_CWMAX_SHIFT(hw_q);\n\tmt76_wr(dev, MT_WMM_CWMAX, val);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}