{
  "module_name": "phy.c",
  "hash_id": "c5060c56efaf003cc648edb5d385697cfc7fcd0962d727e6dbc6ff862d693294",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt7601u/phy.c",
  "human_readable_source": "\n \n\n#include \"mt7601u.h\"\n#include \"mcu.h\"\n#include \"eeprom.h\"\n#include \"trace.h\"\n#include \"initvals_phy.h\"\n\n#include <linux/etherdevice.h>\n\nstatic void mt7601u_agc_reset(struct mt7601u_dev *dev);\n\nstatic int\nmt7601u_rf_wr(struct mt7601u_dev *dev, u8 bank, u8 offset, u8 value)\n{\n\tint ret = 0;\n\n\tif (WARN_ON(!test_bit(MT7601U_STATE_WLAN_RUNNING, &dev->state)) ||\n\t    WARN_ON(offset > 63))\n\t\treturn -EINVAL;\n\tif (test_bit(MT7601U_STATE_REMOVED, &dev->state))\n\t\treturn 0;\n\n\tmutex_lock(&dev->reg_atomic_mutex);\n\n\tif (!mt76_poll(dev, MT_RF_CSR_CFG, MT_RF_CSR_CFG_KICK, 0, 100)) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\tmt7601u_wr(dev, MT_RF_CSR_CFG,\n\t\t   FIELD_PREP(MT_RF_CSR_CFG_DATA, value) |\n\t\t   FIELD_PREP(MT_RF_CSR_CFG_REG_BANK, bank) |\n\t\t   FIELD_PREP(MT_RF_CSR_CFG_REG_ID, offset) |\n\t\t   MT_RF_CSR_CFG_WR |\n\t\t   MT_RF_CSR_CFG_KICK);\n\ttrace_rf_write(dev, bank, offset, value);\nout:\n\tmutex_unlock(&dev->reg_atomic_mutex);\n\n\tif (ret < 0)\n\t\tdev_err(dev->dev, \"Error: RF write %02hhx:%02hhx failed:%d!!\\n\",\n\t\t\tbank, offset, ret);\n\n\treturn ret;\n}\n\nstatic int\nmt7601u_rf_rr(struct mt7601u_dev *dev, u8 bank, u8 offset)\n{\n\tint ret = -ETIMEDOUT;\n\tu32 val;\n\n\tif (WARN_ON(!test_bit(MT7601U_STATE_WLAN_RUNNING, &dev->state)) ||\n\t    WARN_ON(offset > 63))\n\t\treturn -EINVAL;\n\tif (test_bit(MT7601U_STATE_REMOVED, &dev->state))\n\t\treturn 0xff;\n\n\tmutex_lock(&dev->reg_atomic_mutex);\n\n\tif (!mt76_poll(dev, MT_RF_CSR_CFG, MT_RF_CSR_CFG_KICK, 0, 100))\n\t\tgoto out;\n\n\tmt7601u_wr(dev, MT_RF_CSR_CFG,\n\t\t   FIELD_PREP(MT_RF_CSR_CFG_REG_BANK, bank) |\n\t\t   FIELD_PREP(MT_RF_CSR_CFG_REG_ID, offset) |\n\t\t   MT_RF_CSR_CFG_KICK);\n\n\tif (!mt76_poll(dev, MT_RF_CSR_CFG, MT_RF_CSR_CFG_KICK, 0, 100))\n\t\tgoto out;\n\n\tval = mt7601u_rr(dev, MT_RF_CSR_CFG);\n\tif (FIELD_GET(MT_RF_CSR_CFG_REG_ID, val) == offset &&\n\t    FIELD_GET(MT_RF_CSR_CFG_REG_BANK, val) == bank) {\n\t\tret = FIELD_GET(MT_RF_CSR_CFG_DATA, val);\n\t\ttrace_rf_read(dev, bank, offset, ret);\n\t}\nout:\n\tmutex_unlock(&dev->reg_atomic_mutex);\n\n\tif (ret < 0)\n\t\tdev_err(dev->dev, \"Error: RF read %02hhx:%02hhx failed:%d!!\\n\",\n\t\t\tbank, offset, ret);\n\n\treturn ret;\n}\n\nstatic int\nmt7601u_rf_rmw(struct mt7601u_dev *dev, u8 bank, u8 offset, u8 mask, u8 val)\n{\n\tint ret;\n\n\tret = mt7601u_rf_rr(dev, bank, offset);\n\tif (ret < 0)\n\t\treturn ret;\n\tval |= ret & ~mask;\n\tret = mt7601u_rf_wr(dev, bank, offset, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn val;\n}\n\nstatic int\nmt7601u_rf_set(struct mt7601u_dev *dev, u8 bank, u8 offset, u8 val)\n{\n\treturn mt7601u_rf_rmw(dev, bank, offset, 0, val);\n}\n\nstatic int\nmt7601u_rf_clear(struct mt7601u_dev *dev, u8 bank, u8 offset, u8 mask)\n{\n\treturn mt7601u_rf_rmw(dev, bank, offset, mask, 0);\n}\n\nstatic void mt7601u_bbp_wr(struct mt7601u_dev *dev, u8 offset, u8 val)\n{\n\tif (WARN_ON(!test_bit(MT7601U_STATE_WLAN_RUNNING, &dev->state)) ||\n\t    test_bit(MT7601U_STATE_REMOVED, &dev->state))\n\t\treturn;\n\n\tmutex_lock(&dev->reg_atomic_mutex);\n\n\tif (!mt76_poll(dev, MT_BBP_CSR_CFG, MT_BBP_CSR_CFG_BUSY, 0, 1000)) {\n\t\tdev_err(dev->dev, \"Error: BBP write %02hhx failed!!\\n\", offset);\n\t\tgoto out;\n\t}\n\n\tmt7601u_wr(dev, MT_BBP_CSR_CFG,\n\t\t   FIELD_PREP(MT_BBP_CSR_CFG_VAL, val) |\n\t\t   FIELD_PREP(MT_BBP_CSR_CFG_REG_NUM, offset) |\n\t\t   MT_BBP_CSR_CFG_RW_MODE | MT_BBP_CSR_CFG_BUSY);\n\ttrace_bbp_write(dev, offset, val);\nout:\n\tmutex_unlock(&dev->reg_atomic_mutex);\n}\n\nstatic int mt7601u_bbp_rr(struct mt7601u_dev *dev, u8 offset)\n{\n\tu32 val;\n\tint ret = -ETIMEDOUT;\n\n\tif (WARN_ON(!test_bit(MT7601U_STATE_WLAN_RUNNING, &dev->state)))\n\t\treturn -EINVAL;\n\tif (test_bit(MT7601U_STATE_REMOVED, &dev->state))\n\t\treturn 0xff;\n\n\tmutex_lock(&dev->reg_atomic_mutex);\n\n\tif (!mt76_poll(dev, MT_BBP_CSR_CFG, MT_BBP_CSR_CFG_BUSY, 0, 1000))\n\t\tgoto out;\n\n\tmt7601u_wr(dev, MT_BBP_CSR_CFG,\n\t\t   FIELD_PREP(MT_BBP_CSR_CFG_REG_NUM, offset) |\n\t\t   MT_BBP_CSR_CFG_RW_MODE | MT_BBP_CSR_CFG_BUSY |\n\t\t   MT_BBP_CSR_CFG_READ);\n\n\tif (!mt76_poll(dev, MT_BBP_CSR_CFG, MT_BBP_CSR_CFG_BUSY, 0, 1000))\n\t\tgoto out;\n\n\tval = mt7601u_rr(dev, MT_BBP_CSR_CFG);\n\tif (FIELD_GET(MT_BBP_CSR_CFG_REG_NUM, val) == offset) {\n\t\tret = FIELD_GET(MT_BBP_CSR_CFG_VAL, val);\n\t\ttrace_bbp_read(dev, offset, ret);\n\t}\nout:\n\tmutex_unlock(&dev->reg_atomic_mutex);\n\n\tif (ret < 0)\n\t\tdev_err(dev->dev, \"Error: BBP read %02hhx failed:%d!!\\n\",\n\t\t\toffset, ret);\n\n\treturn ret;\n}\n\nstatic int mt7601u_bbp_rmw(struct mt7601u_dev *dev, u8 offset, u8 mask, u8 val)\n{\n\tint ret;\n\n\tret = mt7601u_bbp_rr(dev, offset);\n\tif (ret < 0)\n\t\treturn ret;\n\tval |= ret & ~mask;\n\tmt7601u_bbp_wr(dev, offset, val);\n\n\treturn val;\n}\n\nstatic u8 mt7601u_bbp_rmc(struct mt7601u_dev *dev, u8 offset, u8 mask, u8 val)\n{\n\tint ret;\n\n\tret = mt7601u_bbp_rr(dev, offset);\n\tif (ret < 0)\n\t\treturn ret;\n\tval |= ret & ~mask;\n\tif (ret != val)\n\t\tmt7601u_bbp_wr(dev, offset, val);\n\n\treturn val;\n}\n\nint mt7601u_wait_bbp_ready(struct mt7601u_dev *dev)\n{\n\tint i = 20;\n\tu8 val;\n\n\tdo {\n\t\tval = mt7601u_bbp_rr(dev, MT_BBP_REG_VERSION);\n\t\tif (val && val != 0xff)\n\t\t\tbreak;\n\t} while (--i);\n\n\tif (!i) {\n\t\tdev_err(dev->dev, \"Error: BBP is not ready\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nu32 mt7601u_bbp_set_ctrlch(struct mt7601u_dev *dev, bool below)\n{\n\treturn mt7601u_bbp_rmc(dev, 3, 0x20, below ? 0x20 : 0);\n}\n\nint mt7601u_phy_get_rssi(struct mt7601u_dev *dev,\n\t\t\t struct mt7601u_rxwi *rxwi, u16 rate)\n{\n\tstatic const s8 lna[2][2][3] = {\n\t\t  {\n\t\t\t  { -2, 15, 33 },\n\t\t\t  {  0, 16, 34 }\n\t\t},\n\t\t  {\n\t\t\t  { -2, 15, 33 },\n\t\t\t  { -2, 16, 34 }\n\t\t}\n\t};\n\tint bw = FIELD_GET(MT_RXWI_RATE_BW, rate);\n\tint aux_lna = FIELD_GET(MT_RXWI_ANT_AUX_LNA, rxwi->ant);\n\tint lna_id = FIELD_GET(MT_RXWI_GAIN_RSSI_LNA_ID, rxwi->gain);\n\tint val;\n\n\tif (lna_id)  \n\t\tlna_id--;\n\n\tval = 8;\n\tval -= lna[aux_lna][bw][lna_id];\n\tval -= FIELD_GET(MT_RXWI_GAIN_RSSI_VAL, rxwi->gain);\n\tval -= dev->ee->lna_gain;\n\tval -= dev->ee->rssi_offset[0];\n\n\treturn val;\n}\n\nstatic void mt7601u_vco_cal(struct mt7601u_dev *dev)\n{\n\tmt7601u_rf_wr(dev, 0, 4, 0x0a);\n\tmt7601u_rf_wr(dev, 0, 5, 0x20);\n\tmt7601u_rf_set(dev, 0, 4, BIT(7));\n\tmsleep(2);\n}\n\nstatic int mt7601u_set_bw_filter(struct mt7601u_dev *dev, bool cal)\n{\n\tu32 filter = 0;\n\tint ret;\n\n\tif (!cal)\n\t\tfilter |= 0x10000;\n\tif (dev->bw != MT_BW_20)\n\t\tfilter |= 0x00100;\n\n\t \n\tret = mt7601u_mcu_calibrate(dev, MCU_CAL_BW, filter | 1);\n\tif (ret)\n\t\treturn ret;\n\t \n\treturn mt7601u_mcu_calibrate(dev, MCU_CAL_BW, filter);\n}\n\nstatic int mt7601u_load_bbp_temp_table_bw(struct mt7601u_dev *dev)\n{\n\tconst struct reg_table *t;\n\n\tif (WARN_ON(dev->temp_mode > MT_TEMP_MODE_LOW))\n\t\treturn -EINVAL;\n\n\tt = &bbp_mode_table[dev->temp_mode][dev->bw];\n\n\treturn mt7601u_write_reg_pairs(dev, MT_MCU_MEMMAP_BBP, t->regs, t->n);\n}\n\nstatic int mt7601u_bbp_temp(struct mt7601u_dev *dev, int mode, const char *name)\n{\n\tconst struct reg_table *t;\n\tint ret;\n\n\tif (dev->temp_mode == mode)\n\t\treturn 0;\n\n\tdev->temp_mode = mode;\n\ttrace_temp_mode(dev, mode);\n\n\tt = bbp_mode_table[dev->temp_mode];\n\tret = mt7601u_write_reg_pairs(dev, MT_MCU_MEMMAP_BBP,\n\t\t\t\t      t[2].regs, t[2].n);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mt7601u_write_reg_pairs(dev, MT_MCU_MEMMAP_BBP,\n\t\t\t\t       t[dev->bw].regs, t[dev->bw].n);\n}\n\nstatic void mt7601u_apply_ch14_fixup(struct mt7601u_dev *dev, int hw_chan)\n{\n\tstruct mt7601u_rate_power *t = &dev->ee->power_rate_table;\n\n\tif (hw_chan != 14 || dev->bw != MT_BW_20) {\n\t\tmt7601u_bbp_rmw(dev, 4, 0x20, 0);\n\t\tmt7601u_bbp_wr(dev, 178, 0xff);\n\n\t\tt->cck[0].bw20 = dev->ee->real_cck_bw20[0];\n\t\tt->cck[1].bw20 = dev->ee->real_cck_bw20[1];\n\t} else {  \n\t\tmt7601u_bbp_wr(dev, 4, 0x60);\n\t\tmt7601u_bbp_wr(dev, 178, 0);\n\n\t\t \n\t\tt->cck[0].bw20 = dev->ee->real_cck_bw20[0] - 2;\n\t\tt->cck[1].bw20 = dev->ee->real_cck_bw20[1] - 2;\n\t}\n}\n\nstatic int __mt7601u_phy_set_channel(struct mt7601u_dev *dev,\n\t\t\t\t     struct cfg80211_chan_def *chandef)\n{\n#define FREQ_PLAN_REGS\t4\n\tstatic const u8 freq_plan[14][FREQ_PLAN_REGS] = {\n\t\t{ 0x99,\t0x99,\t0x09,\t0x50 },\n\t\t{ 0x46,\t0x44,\t0x0a,\t0x50 },\n\t\t{ 0xec,\t0xee,\t0x0a,\t0x50 },\n\t\t{ 0x99,\t0x99,\t0x0b,\t0x50 },\n\t\t{ 0x46,\t0x44,\t0x08,\t0x51 },\n\t\t{ 0xec,\t0xee,\t0x08,\t0x51 },\n\t\t{ 0x99,\t0x99,\t0x09,\t0x51 },\n\t\t{ 0x46,\t0x44,\t0x0a,\t0x51 },\n\t\t{ 0xec,\t0xee,\t0x0a,\t0x51 },\n\t\t{ 0x99,\t0x99,\t0x0b,\t0x51 },\n\t\t{ 0x46,\t0x44,\t0x08,\t0x52 },\n\t\t{ 0xec,\t0xee,\t0x08,\t0x52 },\n\t\t{ 0x99,\t0x99,\t0x09,\t0x52 },\n\t\t{ 0x33,\t0x33,\t0x0b,\t0x52 },\n\t};\n\tstruct mt76_reg_pair channel_freq_plan[FREQ_PLAN_REGS] = {\n\t\t{ 17, 0 }, { 18, 0 }, { 19, 0 }, { 20, 0 },\n\t};\n\tstruct mt76_reg_pair bbp_settings[3] = {\n\t\t{ 62, 0x37 - dev->ee->lna_gain },\n\t\t{ 63, 0x37 - dev->ee->lna_gain },\n\t\t{ 64, 0x37 - dev->ee->lna_gain },\n\t};\n\n\tstruct ieee80211_channel *chan = chandef->chan;\n\tenum nl80211_channel_type chan_type =\n\t\tcfg80211_get_chandef_type(chandef);\n\tstruct mt7601u_rate_power *t = &dev->ee->power_rate_table;\n\tint chan_idx;\n\tbool chan_ext_below;\n\tu8 bw;\n\tint i, ret;\n\n\tbw = MT_BW_20;\n\tchan_ext_below = (chan_type == NL80211_CHAN_HT40MINUS);\n\tchan_idx = chan->hw_value - 1;\n\n\tif (chandef->width == NL80211_CHAN_WIDTH_40) {\n\t\tbw = MT_BW_40;\n\n\t\tif (chan_idx > 1 && chan_type == NL80211_CHAN_HT40MINUS)\n\t\t\tchan_idx -= 2;\n\t\telse if (chan_idx < 12 && chan_type == NL80211_CHAN_HT40PLUS)\n\t\t\tchan_idx += 2;\n\t\telse\n\t\t\tdev_err(dev->dev, \"Error: invalid 40MHz channel!!\\n\");\n\t}\n\n\tif (bw != dev->bw || chan_ext_below != dev->chan_ext_below) {\n\t\tdev_dbg(dev->dev, \"Info: switching HT mode bw:%d below:%d\\n\",\n\t\t\tbw, chan_ext_below);\n\n\t\tmt7601u_bbp_set_bw(dev, bw);\n\n\t\tmt7601u_bbp_set_ctrlch(dev, chan_ext_below);\n\t\tmt7601u_mac_set_ctrlch(dev, chan_ext_below);\n\t\tdev->chan_ext_below = chan_ext_below;\n\t}\n\n\tfor (i = 0; i < FREQ_PLAN_REGS; i++)\n\t\tchannel_freq_plan[i].value = freq_plan[chan_idx][i];\n\n\tret = mt7601u_write_reg_pairs(dev, MT_MCU_MEMMAP_RF,\n\t\t\t\t      channel_freq_plan, FREQ_PLAN_REGS);\n\tif (ret)\n\t\treturn ret;\n\n\tmt7601u_rmw(dev, MT_TX_ALC_CFG_0, 0x3f3f,\n\t\t    dev->ee->chan_pwr[chan_idx] & 0x3f);\n\n\tret = mt7601u_write_reg_pairs(dev, MT_MCU_MEMMAP_BBP,\n\t\t\t\t      bbp_settings, ARRAY_SIZE(bbp_settings));\n\tif (ret)\n\t\treturn ret;\n\n\tmt7601u_vco_cal(dev);\n\tmt7601u_bbp_set_bw(dev, bw);\n\tret = mt7601u_set_bw_filter(dev, false);\n\tif (ret)\n\t\treturn ret;\n\n\tmt7601u_apply_ch14_fixup(dev, chan->hw_value);\n\tmt7601u_wr(dev, MT_TX_PWR_CFG_0, int_to_s6(t->ofdm[1].bw20) << 24 |\n\t\t\t\t\t int_to_s6(t->ofdm[0].bw20) << 16 |\n\t\t\t\t\t int_to_s6(t->cck[1].bw20) << 8 |\n\t\t\t\t\t int_to_s6(t->cck[0].bw20));\n\n\tif (test_bit(MT7601U_STATE_SCANNING, &dev->state))\n\t\tmt7601u_agc_reset(dev);\n\n\tdev->chandef = *chandef;\n\n\treturn 0;\n}\n\nint mt7601u_phy_set_channel(struct mt7601u_dev *dev,\n\t\t\t    struct cfg80211_chan_def *chandef)\n{\n\tint ret;\n\n\tcancel_delayed_work_sync(&dev->cal_work);\n\tcancel_delayed_work_sync(&dev->freq_cal.work);\n\n\tmutex_lock(&dev->hw_atomic_mutex);\n\tret = __mt7601u_phy_set_channel(dev, chandef);\n\tmutex_unlock(&dev->hw_atomic_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tif (test_bit(MT7601U_STATE_SCANNING, &dev->state))\n\t\treturn 0;\n\n\tieee80211_queue_delayed_work(dev->hw, &dev->cal_work,\n\t\t\t\t     MT_CALIBRATE_INTERVAL);\n\tif (dev->freq_cal.enabled)\n\t\tieee80211_queue_delayed_work(dev->hw, &dev->freq_cal.work,\n\t\t\t\t\t     MT_FREQ_CAL_INIT_DELAY);\n\treturn 0;\n}\n\n#define BBP_R47_FLAG\t\tGENMASK(2, 0)\n#define BBP_R47_F_TSSI\t\t0\n#define BBP_R47_F_PKT_T\t\t1\n#define BBP_R47_F_TX_RATE\t2\n#define BBP_R47_F_TEMP\t\t4\n \nstatic u8 mt7601u_bbp_r47_get(struct mt7601u_dev *dev, u8 reg, u8 flag)\n{\n\tflag |= reg & ~BBP_R47_FLAG;\n\tmt7601u_bbp_wr(dev, 47, flag);\n\tusleep_range(500, 700);\n\treturn mt7601u_bbp_rr(dev, 49);\n}\n\nstatic s8 mt7601u_read_bootup_temp(struct mt7601u_dev *dev)\n{\n\tu8 bbp_val, temp;\n\tu32 rf_bp, rf_set;\n\tint i;\n\n\trf_set = mt7601u_rr(dev, MT_RF_SETTING_0);\n\trf_bp = mt7601u_rr(dev, MT_RF_BYPASS_0);\n\n\tmt7601u_wr(dev, MT_RF_BYPASS_0, 0);\n\tmt7601u_wr(dev, MT_RF_SETTING_0, 0x00000010);\n\tmt7601u_wr(dev, MT_RF_BYPASS_0, 0x00000010);\n\n\tbbp_val = mt7601u_bbp_rmw(dev, 47, 0, 0x10);\n\n\tmt7601u_bbp_wr(dev, 22, 0x40);\n\n\tfor (i = 100; i && (bbp_val & 0x10); i--)\n\t\tbbp_val = mt7601u_bbp_rr(dev, 47);\n\n\ttemp = mt7601u_bbp_r47_get(dev, bbp_val, BBP_R47_F_TEMP);\n\n\tmt7601u_bbp_wr(dev, 22, 0);\n\n\tbbp_val = mt7601u_bbp_rr(dev, 21);\n\tbbp_val |= 0x02;\n\tmt7601u_bbp_wr(dev, 21, bbp_val);\n\tbbp_val &= ~0x02;\n\tmt7601u_bbp_wr(dev, 21, bbp_val);\n\n\tmt7601u_wr(dev, MT_RF_BYPASS_0, 0);\n\tmt7601u_wr(dev, MT_RF_SETTING_0, rf_set);\n\tmt7601u_wr(dev, MT_RF_BYPASS_0, rf_bp);\n\n\ttrace_read_temp(dev, temp);\n\treturn temp;\n}\n\nstatic s8 mt7601u_read_temp(struct mt7601u_dev *dev)\n{\n\tint i;\n\tu8 val;\n\ts8 temp;\n\n\tval = mt7601u_bbp_rmw(dev, 47, 0x7f, 0x10);\n\n\t \n\tfor (i = 100; i && (val & 0x10); i--)\n\t\tval = mt7601u_bbp_rr(dev, 47);\n\n\ttemp = mt7601u_bbp_r47_get(dev, val, BBP_R47_F_TEMP);\n\n\ttrace_read_temp(dev, temp);\n\treturn temp;\n}\n\nstatic void mt7601u_rxdc_cal(struct mt7601u_dev *dev)\n{\n\tstatic const struct mt76_reg_pair intro[] = {\n\t\t{ 158, 0x8d }, { 159, 0xfc },\n\t\t{ 158, 0x8c }, { 159, 0x4c },\n\t}, outro[] = {\n\t\t{ 158, 0x8d }, { 159, 0xe0 },\n\t};\n\tu32 mac_ctrl;\n\tint i, ret;\n\n\tmac_ctrl = mt7601u_rr(dev, MT_MAC_SYS_CTRL);\n\tmt7601u_wr(dev, MT_MAC_SYS_CTRL, MT_MAC_SYS_CTRL_ENABLE_RX);\n\n\tret = mt7601u_write_reg_pairs(dev, MT_MCU_MEMMAP_BBP,\n\t\t\t\t      intro, ARRAY_SIZE(intro));\n\tif (ret)\n\t\tdev_err(dev->dev, \"%s intro failed:%d\\n\", __func__, ret);\n\n\tfor (i = 20; i; i--) {\n\t\tusleep_range(300, 500);\n\n\t\tmt7601u_bbp_wr(dev, 158, 0x8c);\n\t\tif (mt7601u_bbp_rr(dev, 159) == 0x0c)\n\t\t\tbreak;\n\t}\n\tif (!i)\n\t\tdev_err(dev->dev, \"%s timed out\\n\", __func__);\n\n\tmt7601u_wr(dev, MT_MAC_SYS_CTRL, 0);\n\n\tret = mt7601u_write_reg_pairs(dev, MT_MCU_MEMMAP_BBP,\n\t\t\t\t      outro, ARRAY_SIZE(outro));\n\tif (ret)\n\t\tdev_err(dev->dev, \"%s outro failed:%d\\n\", __func__, ret);\n\n\tmt7601u_wr(dev, MT_MAC_SYS_CTRL, mac_ctrl);\n}\n\nvoid mt7601u_phy_recalibrate_after_assoc(struct mt7601u_dev *dev)\n{\n\tif (test_bit(MT7601U_STATE_REMOVED, &dev->state))\n\t\treturn;\n\n\tmt7601u_mcu_calibrate(dev, MCU_CAL_DPD, dev->curr_temp);\n\n\tmt7601u_rxdc_cal(dev);\n}\n\n \nstatic s16 lin2dBd(u16 linear)\n{\n\tshort exp = 0;\n\tunsigned int mantisa;\n\tint app, dBd;\n\n\tif (WARN_ON(!linear))\n\t\treturn -10000;\n\n\tmantisa = linear;\n\n\texp = fls(mantisa) - 16;\n\tif (exp > 0)\n\t\tmantisa >>= exp;\n\telse\n\t\tmantisa <<= abs(exp);\n\n\tif (mantisa <= 0xb800)\n\t\tapp = (mantisa + (mantisa >> 3) + (mantisa >> 4) - 0x9600);\n\telse\n\t\tapp = (mantisa - (mantisa >> 3) - (mantisa >> 6) - 0x5a00);\n\tif (app < 0)\n\t\tapp = 0;\n\n\tdBd = ((15 + exp) << 15) + app;\n\tdBd = (dBd << 2) + (dBd << 1) + (dBd >> 6) + (dBd >> 7);\n\tdBd = (dBd >> 10);\n\n\treturn dBd;\n}\n\nstatic void\nmt7601u_set_initial_tssi(struct mt7601u_dev *dev, s16 tssi_db, s16 tssi_hvga_db)\n{\n\tstruct tssi_data *d = &dev->ee->tssi_data;\n\tint init_offset;\n\n\tinit_offset = -((tssi_db * d->slope + d->offset[1]) / 4096) + 10;\n\n\tmt76_rmw(dev, MT_TX_ALC_CFG_1, MT_TX_ALC_CFG_1_TEMP_COMP,\n\t\t int_to_s6(init_offset) & MT_TX_ALC_CFG_1_TEMP_COMP);\n}\n\nstatic void mt7601u_tssi_dc_gain_cal(struct mt7601u_dev *dev)\n{\n\tu8 rf_vga, rf_mixer, bbp_r47;\n\tint i, j;\n\ts8 res[4];\n\ts16 tssi_init_db, tssi_init_hvga_db;\n\n\tmt7601u_wr(dev, MT_RF_SETTING_0, 0x00000030);\n\tmt7601u_wr(dev, MT_RF_BYPASS_0, 0x000c0030);\n\tmt7601u_wr(dev, MT_MAC_SYS_CTRL, 0);\n\n\tmt7601u_bbp_wr(dev, 58, 0);\n\tmt7601u_bbp_wr(dev, 241, 0x2);\n\tmt7601u_bbp_wr(dev, 23, 0x8);\n\tbbp_r47 = mt7601u_bbp_rr(dev, 47);\n\n\t \n\trf_vga = mt7601u_rf_rr(dev, 5, 3);\n\tmt7601u_rf_wr(dev, 5, 3, 8);\n\n\t \n\trf_mixer = mt7601u_rf_rr(dev, 4, 39);\n\tmt7601u_rf_wr(dev, 4, 39, 0);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tmt7601u_rf_wr(dev, 4, 39, (i & 1) ? rf_mixer : 0);\n\n\t\tmt7601u_bbp_wr(dev, 23, (i < 2) ? 0x08 : 0x02);\n\t\tmt7601u_rf_wr(dev, 5, 3, (i < 2) ? 0x08 : 0x11);\n\n\t\t \n\t\tmt7601u_bbp_wr(dev, 22, 0);\n\t\tmt7601u_bbp_wr(dev, 244, 0);\n\n\t\tmt7601u_bbp_wr(dev, 21, 1);\n\t\tudelay(1);\n\t\tmt7601u_bbp_wr(dev, 21, 0);\n\n\t\t \n\t\tmt7601u_bbp_wr(dev, 47, 0x50);\n\t\tmt7601u_bbp_wr(dev, (i & 1) ? 244 : 22, (i & 1) ? 0x31 : 0x40);\n\n\t\tfor (j = 20; j; j--)\n\t\t\tif (!(mt7601u_bbp_rr(dev, 47) & 0x10))\n\t\t\t\tbreak;\n\t\tif (!j)\n\t\t\tdev_err(dev->dev, \"%s timed out\\n\", __func__);\n\n\t\t \n\t\tmt7601u_bbp_wr(dev, 47, 0x40);\n\t\tres[i] = mt7601u_bbp_rr(dev, 49);\n\t}\n\n\ttssi_init_db = lin2dBd((short)res[1] - res[0]);\n\ttssi_init_hvga_db = lin2dBd(((short)res[3] - res[2]) * 4);\n\tdev->tssi_init = res[0];\n\tdev->tssi_init_hvga = res[2];\n\tdev->tssi_init_hvga_offset_db = tssi_init_hvga_db - tssi_init_db;\n\n\tdev_dbg(dev->dev,\n\t\t\"TSSI_init:%hhx db:%hx hvga:%hhx hvga_db:%hx off_db:%hx\\n\",\n\t\tdev->tssi_init, tssi_init_db, dev->tssi_init_hvga,\n\t\ttssi_init_hvga_db, dev->tssi_init_hvga_offset_db);\n\n\tmt7601u_bbp_wr(dev, 22, 0);\n\tmt7601u_bbp_wr(dev, 244, 0);\n\n\tmt7601u_bbp_wr(dev, 21, 1);\n\tudelay(1);\n\tmt7601u_bbp_wr(dev, 21, 0);\n\n\tmt7601u_wr(dev, MT_RF_BYPASS_0, 0);\n\tmt7601u_wr(dev, MT_RF_SETTING_0, 0);\n\n\tmt7601u_rf_wr(dev, 5, 3, rf_vga);\n\tmt7601u_rf_wr(dev, 4, 39, rf_mixer);\n\tmt7601u_bbp_wr(dev, 47, bbp_r47);\n\n\tmt7601u_set_initial_tssi(dev, tssi_init_db, tssi_init_hvga_db);\n}\n\nstatic int mt7601u_temp_comp(struct mt7601u_dev *dev, bool on)\n{\n\tint ret, temp, hi_temp = 400, lo_temp = -200;\n\n\ttemp = (dev->raw_temp - dev->ee->ref_temp) * MT_EE_TEMPERATURE_SLOPE;\n\tdev->curr_temp = temp;\n\n\t \n\tif (temp - dev->dpd_temp > 450 || temp - dev->dpd_temp < -450) {\n\t\tdev->dpd_temp = temp;\n\n\t\tret = mt7601u_mcu_calibrate(dev, MCU_CAL_DPD, dev->dpd_temp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmt7601u_vco_cal(dev);\n\n\t\tdev_dbg(dev->dev, \"Recalibrate DPD\\n\");\n\t}\n\n\t \n\tif (temp < -50 && !dev->pll_lock_protect) {  \n\t\tdev->pll_lock_protect =  true;\n\n\t\tmt7601u_rf_wr(dev, 4, 4, 6);\n\t\tmt7601u_rf_clear(dev, 4, 10, 0x30);\n\n\t\tdev_dbg(dev->dev, \"PLL lock protect on - too cold\\n\");\n\t} else if (temp > 50 && dev->pll_lock_protect) {  \n\t\tdev->pll_lock_protect = false;\n\n\t\tmt7601u_rf_wr(dev, 4, 4, 0);\n\t\tmt7601u_rf_rmw(dev, 4, 10, 0x30, 0x10);\n\n\t\tdev_dbg(dev->dev, \"PLL lock protect off\\n\");\n\t}\n\n\tif (on) {\n\t\thi_temp -= 50;\n\t\tlo_temp -= 50;\n\t}\n\n\t \n\tif (temp > hi_temp)\n\t\treturn mt7601u_bbp_temp(dev, MT_TEMP_MODE_HIGH, \"high\");\n\telse if (temp > lo_temp)\n\t\treturn mt7601u_bbp_temp(dev, MT_TEMP_MODE_NORMAL, \"normal\");\n\telse\n\t\treturn mt7601u_bbp_temp(dev, MT_TEMP_MODE_LOW, \"low\");\n}\n\n \nstatic int mt7601u_current_tx_power(struct mt7601u_dev *dev)\n{\n\treturn dev->ee->chan_pwr[dev->chandef.chan->hw_value - 1];\n}\n\nstatic bool mt7601u_use_hvga(struct mt7601u_dev *dev)\n{\n\treturn !(mt7601u_current_tx_power(dev) > 20);\n}\n\nstatic s16\nmt7601u_phy_rf_pa_mode_val(struct mt7601u_dev *dev, int phy_mode, int tx_rate)\n{\n\tstatic const s16 decode_tb[] = { 0, 8847, -5734, -5734 };\n\tu32 reg;\n\n\tswitch (phy_mode) {\n\tcase MT_PHY_TYPE_OFDM:\n\t\ttx_rate += 4;\n\t\tfallthrough;\n\tcase MT_PHY_TYPE_CCK:\n\t\treg = dev->rf_pa_mode[0];\n\t\tbreak;\n\tdefault:\n\t\treg = dev->rf_pa_mode[1];\n\t\tbreak;\n\t}\n\n\treturn decode_tb[(reg >> (tx_rate * 2)) & 0x3];\n}\n\nstatic struct mt7601u_tssi_params\nmt7601u_tssi_params_get(struct mt7601u_dev *dev)\n{\n\tstatic const u8 ofdm_pkt2rate[8] = { 6, 4, 2, 0, 7, 5, 3, 1 };\n\tstatic const int static_power[4] = { 0, -49152, -98304, 49152 };\n\tstruct mt7601u_tssi_params p;\n\tu8 bbp_r47, pkt_type, tx_rate;\n\tstruct power_per_rate *rate_table;\n\n\tbbp_r47 = mt7601u_bbp_rr(dev, 47);\n\n\tp.tssi0 = mt7601u_bbp_r47_get(dev, bbp_r47, BBP_R47_F_TSSI);\n\tdev->raw_temp = mt7601u_bbp_r47_get(dev, bbp_r47, BBP_R47_F_TEMP);\n\tpkt_type = mt7601u_bbp_r47_get(dev, bbp_r47, BBP_R47_F_PKT_T);\n\n\tp.trgt_power = mt7601u_current_tx_power(dev);\n\n\tswitch (pkt_type & 0x03) {\n\tcase MT_PHY_TYPE_CCK:\n\t\ttx_rate = (pkt_type >> 4) & 0x03;\n\t\trate_table = dev->ee->power_rate_table.cck;\n\t\tbreak;\n\n\tcase MT_PHY_TYPE_OFDM:\n\t\ttx_rate = ofdm_pkt2rate[(pkt_type >> 4) & 0x07];\n\t\trate_table = dev->ee->power_rate_table.ofdm;\n\t\tbreak;\n\n\tdefault:\n\t\ttx_rate = mt7601u_bbp_r47_get(dev, bbp_r47, BBP_R47_F_TX_RATE);\n\t\ttx_rate &= 0x7f;\n\t\trate_table = dev->ee->power_rate_table.ht;\n\t\tbreak;\n\t}\n\n\tif (dev->bw == MT_BW_20)\n\t\tp.trgt_power += rate_table[tx_rate / 2].bw20;\n\telse\n\t\tp.trgt_power += rate_table[tx_rate / 2].bw40;\n\n\tp.trgt_power <<= 12;\n\n\tdev_dbg(dev->dev, \"tx_rate:%02hhx pwr:%08x\\n\", tx_rate, p.trgt_power);\n\n\tp.trgt_power += mt7601u_phy_rf_pa_mode_val(dev, pkt_type & 0x03,\n\t\t\t\t\t\t   tx_rate);\n\n\t \n\tif ((pkt_type & 0x03) == MT_PHY_TYPE_CCK) {\n\t\tif (mt7601u_bbp_rr(dev, 4) & 0x20)\n\t\t\tp.trgt_power += mt7601u_bbp_rr(dev, 178) ? 18022 : 9830;\n\t\telse\n\t\t\tp.trgt_power += mt7601u_bbp_rr(dev, 178) ? 819 : 24576;\n\t}\n\n\tp.trgt_power += static_power[mt7601u_bbp_rr(dev, 1) & 0x03];\n\n\tp.trgt_power += dev->ee->tssi_data.tx0_delta_offset;\n\n\tdev_dbg(dev->dev,\n\t\t\"tssi:%02hhx t_power:%08x temp:%02hhx pkt_type:%02hhx\\n\",\n\t\tp.tssi0, p.trgt_power, dev->raw_temp, pkt_type);\n\n\treturn p;\n}\n\nstatic bool mt7601u_tssi_read_ready(struct mt7601u_dev *dev)\n{\n\treturn !(mt7601u_bbp_rr(dev, 47) & 0x10);\n}\n\nstatic int mt7601u_tssi_cal(struct mt7601u_dev *dev)\n{\n\tstruct mt7601u_tssi_params params;\n\tint curr_pwr, diff_pwr;\n\tchar tssi_offset;\n\ts8 tssi_init;\n\ts16 tssi_m_dc, tssi_db;\n\tbool hvga;\n\tu32 val;\n\n\tif (!dev->ee->tssi_enabled)\n\t\treturn 0;\n\n\thvga = mt7601u_use_hvga(dev);\n\tif (!dev->tssi_read_trig)\n\t\treturn mt7601u_mcu_tssi_read_kick(dev, hvga);\n\n\tif (!mt7601u_tssi_read_ready(dev))\n\t\treturn 0;\n\n\tparams = mt7601u_tssi_params_get(dev);\n\n\ttssi_init = (hvga ? dev->tssi_init_hvga : dev->tssi_init);\n\ttssi_m_dc = params.tssi0 - tssi_init;\n\ttssi_db = lin2dBd(tssi_m_dc);\n\tdev_dbg(dev->dev, \"tssi dc:%04hx db:%04hx hvga:%d\\n\",\n\t\ttssi_m_dc, tssi_db, hvga);\n\n\tif (dev->chandef.chan->hw_value < 5)\n\t\ttssi_offset = dev->ee->tssi_data.offset[0];\n\telse if (dev->chandef.chan->hw_value < 9)\n\t\ttssi_offset = dev->ee->tssi_data.offset[1];\n\telse\n\t\ttssi_offset = dev->ee->tssi_data.offset[2];\n\n\tif (hvga)\n\t\ttssi_db -= dev->tssi_init_hvga_offset_db;\n\n\tcurr_pwr = tssi_db * dev->ee->tssi_data.slope + (tssi_offset << 9);\n\tdiff_pwr = params.trgt_power - curr_pwr;\n\tdev_dbg(dev->dev, \"Power curr:%08x diff:%08x\\n\", curr_pwr, diff_pwr);\n\n\tif (params.tssi0 > 126 && diff_pwr > 0) {\n\t\tdev_err(dev->dev, \"Error: TSSI upper saturation\\n\");\n\t\tdiff_pwr = 0;\n\t}\n\tif (params.tssi0 - tssi_init < 1 && diff_pwr < 0) {\n\t\tdev_err(dev->dev, \"Error: TSSI lower saturation\\n\");\n\t\tdiff_pwr = 0;\n\t}\n\n\tif ((dev->prev_pwr_diff ^ diff_pwr) < 0 && abs(diff_pwr) < 4096 &&\n\t    (abs(diff_pwr) > abs(dev->prev_pwr_diff) ||\n\t     (diff_pwr > 0 && diff_pwr == -dev->prev_pwr_diff)))\n\t\tdiff_pwr = 0;\n\telse\n\t\tdev->prev_pwr_diff = diff_pwr;\n\n\tdiff_pwr += (diff_pwr > 0) ? 2048 : -2048;\n\tdiff_pwr /= 4096;\n\n\tdev_dbg(dev->dev, \"final diff: %08x\\n\", diff_pwr);\n\n\tval = mt7601u_rr(dev, MT_TX_ALC_CFG_1);\n\tcurr_pwr = s6_to_int(FIELD_GET(MT_TX_ALC_CFG_1_TEMP_COMP, val));\n\tdiff_pwr += curr_pwr;\n\tval = (val & ~MT_TX_ALC_CFG_1_TEMP_COMP) | int_to_s6(diff_pwr);\n\tmt7601u_wr(dev, MT_TX_ALC_CFG_1, val);\n\n\treturn mt7601u_mcu_tssi_read_kick(dev, hvga);\n}\n\nstatic u8 mt7601u_agc_default(struct mt7601u_dev *dev)\n{\n\treturn (dev->ee->lna_gain - 8) * 2 + 0x34;\n}\n\nstatic void mt7601u_agc_reset(struct mt7601u_dev *dev)\n{\n\tu8 agc = mt7601u_agc_default(dev);\n\n\tmt7601u_bbp_wr(dev, 66,\tagc);\n}\n\nvoid mt7601u_agc_save(struct mt7601u_dev *dev)\n{\n\tdev->agc_save = mt7601u_bbp_rr(dev, 66);\n}\n\nvoid mt7601u_agc_restore(struct mt7601u_dev *dev)\n{\n\tmt7601u_bbp_wr(dev, 66, dev->agc_save);\n}\n\nstatic void mt7601u_agc_tune(struct mt7601u_dev *dev)\n{\n\tu8 val = mt7601u_agc_default(dev);\n\tlong avg_rssi;\n\n\tif (test_bit(MT7601U_STATE_SCANNING, &dev->state))\n\t\treturn;\n\n\t \n\tspin_lock_bh(&dev->con_mon_lock);\n\tavg_rssi = ewma_rssi_read(&dev->avg_rssi);\n\tspin_unlock_bh(&dev->con_mon_lock);\n\tif (avg_rssi == 0)\n\t\treturn;\n\n\tavg_rssi = -avg_rssi;\n\tif (avg_rssi <= -70)\n\t\tval -= 0x20;\n\telse if (avg_rssi <= -60)\n\t\tval -= 0x10;\n\n\tif (val != mt7601u_bbp_rr(dev, 66))\n\t\tmt7601u_bbp_wr(dev, 66, val);\n\n\t \n}\n\nstatic void mt7601u_phy_calibrate(struct work_struct *work)\n{\n\tstruct mt7601u_dev *dev = container_of(work, struct mt7601u_dev,\n\t\t\t\t\t    cal_work.work);\n\n\tmt7601u_agc_tune(dev);\n\tmt7601u_tssi_cal(dev);\n\t \n\tif (!dev->ee->tssi_enabled)\n\t\tdev->raw_temp = mt7601u_read_temp(dev);\n\tmt7601u_temp_comp(dev, true);  \n\n\tieee80211_queue_delayed_work(dev->hw, &dev->cal_work,\n\t\t\t\t     MT_CALIBRATE_INTERVAL);\n}\n\nstatic unsigned long\n__mt7601u_phy_freq_cal(struct mt7601u_dev *dev, s8 last_offset, u8 phy_mode)\n{\n\tu8 activate_threshold, deactivate_threshold;\n\n\ttrace_freq_cal_offset(dev, phy_mode, last_offset);\n\n\t \n\tif (last_offset == MT_FREQ_OFFSET_INVALID)\n\t\treturn MT_FREQ_CAL_ADJ_INTERVAL;\n\n\tswitch (phy_mode) {\n\tcase MT_PHY_TYPE_CCK:\n\t\tactivate_threshold = 19;\n\t\tdeactivate_threshold = 5;\n\t\tbreak;\n\tcase MT_PHY_TYPE_OFDM:\n\t\tactivate_threshold = 102;\n\t\tdeactivate_threshold = 32;\n\t\tbreak;\n\tcase MT_PHY_TYPE_HT:\n\tcase MT_PHY_TYPE_HT_GF:\n\t\tactivate_threshold = 82;\n\t\tdeactivate_threshold = 20;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn MT_FREQ_CAL_CHECK_INTERVAL;\n\t}\n\n\tif (abs(last_offset) >= activate_threshold)\n\t\tdev->freq_cal.adjusting = true;\n\telse if (abs(last_offset) <= deactivate_threshold)\n\t\tdev->freq_cal.adjusting = false;\n\n\tif (!dev->freq_cal.adjusting)\n\t\treturn MT_FREQ_CAL_CHECK_INTERVAL;\n\n\tif (last_offset > deactivate_threshold) {\n\t\tif (dev->freq_cal.freq > 0)\n\t\t\tdev->freq_cal.freq--;\n\t\telse\n\t\t\tdev->freq_cal.adjusting = false;\n\t} else if (last_offset < -deactivate_threshold) {\n\t\tif (dev->freq_cal.freq < 0xbf)\n\t\t\tdev->freq_cal.freq++;\n\t\telse\n\t\t\tdev->freq_cal.adjusting = false;\n\t}\n\n\ttrace_freq_cal_adjust(dev, dev->freq_cal.freq);\n\tmt7601u_rf_wr(dev, 0, 12, dev->freq_cal.freq);\n\tmt7601u_vco_cal(dev);\n\n\treturn dev->freq_cal.adjusting ? MT_FREQ_CAL_ADJ_INTERVAL :\n\t\t\t\t\t MT_FREQ_CAL_CHECK_INTERVAL;\n}\n\nstatic void mt7601u_phy_freq_cal(struct work_struct *work)\n{\n\tstruct mt7601u_dev *dev = container_of(work, struct mt7601u_dev,\n\t\t\t\t\t       freq_cal.work.work);\n\ts8 last_offset;\n\tu8 phy_mode;\n\tunsigned long delay;\n\n\tspin_lock_bh(&dev->con_mon_lock);\n\tlast_offset = dev->bcn_freq_off;\n\tphy_mode = dev->bcn_phy_mode;\n\tspin_unlock_bh(&dev->con_mon_lock);\n\n\tdelay = __mt7601u_phy_freq_cal(dev, last_offset, phy_mode);\n\tieee80211_queue_delayed_work(dev->hw, &dev->freq_cal.work, delay);\n\n\tspin_lock_bh(&dev->con_mon_lock);\n\tdev->bcn_freq_off = MT_FREQ_OFFSET_INVALID;\n\tspin_unlock_bh(&dev->con_mon_lock);\n}\n\nvoid mt7601u_phy_con_cal_onoff(struct mt7601u_dev *dev,\n\t\t\t       struct ieee80211_bss_conf *info)\n{\n\tstruct ieee80211_vif *vif = container_of(info, struct ieee80211_vif,\n\t\t\t\t\t\t bss_conf);\n\n\tif (!vif->cfg.assoc)\n\t\tcancel_delayed_work_sync(&dev->freq_cal.work);\n\n\t \n\tspin_lock_bh(&dev->con_mon_lock);\n\tether_addr_copy(dev->ap_bssid, info->bssid);\n\tewma_rssi_init(&dev->avg_rssi);\n\tdev->bcn_freq_off = MT_FREQ_OFFSET_INVALID;\n\tspin_unlock_bh(&dev->con_mon_lock);\n\n\tdev->freq_cal.freq = dev->ee->rf_freq_off;\n\tdev->freq_cal.enabled = vif->cfg.assoc;\n\tdev->freq_cal.adjusting = false;\n\n\tif (vif->cfg.assoc)\n\t\tieee80211_queue_delayed_work(dev->hw, &dev->freq_cal.work,\n\t\t\t\t\t     MT_FREQ_CAL_INIT_DELAY);\n}\n\nstatic int mt7601u_init_cal(struct mt7601u_dev *dev)\n{\n\tu32 mac_ctrl;\n\tint ret;\n\n\tdev->raw_temp = mt7601u_read_bootup_temp(dev);\n\tdev->curr_temp = (dev->raw_temp - dev->ee->ref_temp) *\n\t\tMT_EE_TEMPERATURE_SLOPE;\n\tdev->dpd_temp = dev->curr_temp;\n\n\tmac_ctrl = mt7601u_rr(dev, MT_MAC_SYS_CTRL);\n\n\tret = mt7601u_mcu_calibrate(dev, MCU_CAL_R, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7601u_rf_rr(dev, 0, 4);\n\tif (ret < 0)\n\t\treturn ret;\n\tret |= 0x80;\n\tret = mt7601u_rf_wr(dev, 0, 4, ret);\n\tif (ret)\n\t\treturn ret;\n\tmsleep(2);\n\n\tret = mt7601u_mcu_calibrate(dev, MCU_CAL_TXDCOC, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tmt7601u_rxdc_cal(dev);\n\n\tret = mt7601u_set_bw_filter(dev, true);\n\tif (ret)\n\t\treturn ret;\n\tret = mt7601u_mcu_calibrate(dev, MCU_CAL_LOFT, 0);\n\tif (ret)\n\t\treturn ret;\n\tret = mt7601u_mcu_calibrate(dev, MCU_CAL_TXIQ, 0);\n\tif (ret)\n\t\treturn ret;\n\tret = mt7601u_mcu_calibrate(dev, MCU_CAL_RXIQ, 0);\n\tif (ret)\n\t\treturn ret;\n\tret = mt7601u_mcu_calibrate(dev, MCU_CAL_DPD, dev->dpd_temp);\n\tif (ret)\n\t\treturn ret;\n\n\tmt7601u_rxdc_cal(dev);\n\n\tmt7601u_tssi_dc_gain_cal(dev);\n\n\tmt7601u_wr(dev, MT_MAC_SYS_CTRL, mac_ctrl);\n\n\tmt7601u_temp_comp(dev, true);\n\n\treturn 0;\n}\n\nint mt7601u_bbp_set_bw(struct mt7601u_dev *dev, int bw)\n{\n\tu32 val, old;\n\n\tif (bw == dev->bw) {\n\t\t \n\t\tmt7601u_bbp_rmc(dev, 4, 0x18, bw == MT_BW_20 ? 0 : 0x10);\n\n\t\treturn 0;\n\t}\n\tdev->bw = bw;\n\n\t \n\told = mt7601u_rr(dev, MT_MAC_SYS_CTRL);\n\tval = old & ~(MT_MAC_SYS_CTRL_ENABLE_TX | MT_MAC_SYS_CTRL_ENABLE_RX);\n\tmt7601u_wr(dev, MT_MAC_SYS_CTRL, val);\n\tmt76_poll(dev, MT_MAC_STATUS, MT_MAC_STATUS_TX | MT_MAC_STATUS_RX,\n\t\t  0, 500000);\n\n\tmt7601u_bbp_rmc(dev, 4, 0x18, bw == MT_BW_20 ? 0 : 0x10);\n\n\tmt7601u_wr(dev, MT_MAC_SYS_CTRL, old);\n\n\treturn mt7601u_load_bbp_temp_table_bw(dev);\n}\n\n \nvoid mt7601u_set_rx_path(struct mt7601u_dev *dev, u8 path)\n{\n\tmt7601u_bbp_rmw(dev, 3, 0x18, path << 3);\n}\n\n \nvoid mt7601u_set_tx_dac(struct mt7601u_dev *dev, u8 dac)\n{\n\tmt7601u_bbp_rmc(dev, 1, 0x18, dac << 3);\n}\n\nint mt7601u_phy_init(struct mt7601u_dev *dev)\n{\n\tint ret;\n\n\tdev->rf_pa_mode[0] = mt7601u_rr(dev, MT_RF_PA_MODE_CFG0);\n\tdev->rf_pa_mode[1] = mt7601u_rr(dev, MT_RF_PA_MODE_CFG1);\n\n\tret = mt7601u_rf_wr(dev, 0, 12, dev->ee->rf_freq_off);\n\tif (ret)\n\t\treturn ret;\n\tret = mt7601u_write_reg_pairs(dev, 0, rf_central,\n\t\t\t\t      ARRAY_SIZE(rf_central));\n\tif (ret)\n\t\treturn ret;\n\tret = mt7601u_write_reg_pairs(dev, 0, rf_channel,\n\t\t\t\t      ARRAY_SIZE(rf_channel));\n\tif (ret)\n\t\treturn ret;\n\tret = mt7601u_write_reg_pairs(dev, 0, rf_vga, ARRAY_SIZE(rf_vga));\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7601u_init_cal(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->prev_pwr_diff = 100;\n\n\tINIT_DELAYED_WORK(&dev->cal_work, mt7601u_phy_calibrate);\n\tINIT_DELAYED_WORK(&dev->freq_cal.work, mt7601u_phy_freq_cal);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}