{
  "module_name": "main.c",
  "hash_id": "f2ed8f5bb45caf75727a521312c47086254534ceef40d513bfadb8643e7996f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt7601u/main.c",
  "human_readable_source": "\n \n\n#include \"mt7601u.h\"\n#include \"mac.h\"\n#include <linux/etherdevice.h>\n\nstatic int mt7601u_start(struct ieee80211_hw *hw)\n{\n\tstruct mt7601u_dev *dev = hw->priv;\n\tint ret;\n\n\tmutex_lock(&dev->mutex);\n\n\tret = mt7601u_mac_start(dev);\n\tif (ret)\n\t\tgoto out;\n\n\tieee80211_queue_delayed_work(dev->hw, &dev->mac_work,\n\t\t\t\t     MT_CALIBRATE_INTERVAL);\n\tieee80211_queue_delayed_work(dev->hw, &dev->cal_work,\n\t\t\t\t     MT_CALIBRATE_INTERVAL);\nout:\n\tmutex_unlock(&dev->mutex);\n\treturn ret;\n}\n\nstatic void mt7601u_stop(struct ieee80211_hw *hw)\n{\n\tstruct mt7601u_dev *dev = hw->priv;\n\n\tmutex_lock(&dev->mutex);\n\n\tcancel_delayed_work_sync(&dev->cal_work);\n\tcancel_delayed_work_sync(&dev->mac_work);\n\tmt7601u_mac_stop(dev);\n\n\tmutex_unlock(&dev->mutex);\n}\n\nstatic int mt7601u_add_interface(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct mt7601u_dev *dev = hw->priv;\n\tstruct mt76_vif *mvif = (struct mt76_vif *) vif->drv_priv;\n\tunsigned int idx = 0;\n\tunsigned int wcid = GROUP_WCID(idx);\n\n\t \n\tmvif->idx = idx;\n\n\tif (!ether_addr_equal(dev->macaddr, vif->addr))\n\t\tmt7601u_set_macaddr(dev, vif->addr);\n\n\tif (dev->wcid_mask[wcid / BITS_PER_LONG] & BIT(wcid % BITS_PER_LONG))\n\t\treturn -ENOSPC;\n\tdev->wcid_mask[wcid / BITS_PER_LONG] |= BIT(wcid % BITS_PER_LONG);\n\tmvif->group_wcid.idx = wcid;\n\tmvif->group_wcid.hw_key_idx = -1;\n\n\treturn 0;\n}\n\nstatic void mt7601u_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct mt7601u_dev *dev = hw->priv;\n\tstruct mt76_vif *mvif = (struct mt76_vif *) vif->drv_priv;\n\tunsigned int wcid = mvif->group_wcid.idx;\n\n\tdev->wcid_mask[wcid / BITS_PER_LONG] &= ~BIT(wcid % BITS_PER_LONG);\n}\n\nstatic int mt7601u_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct mt7601u_dev *dev = hw->priv;\n\tint ret = 0;\n\n\tmutex_lock(&dev->mutex);\n\n\tif (changed & IEEE80211_CONF_CHANGE_CHANNEL) {\n\t\tieee80211_stop_queues(hw);\n\t\tret = mt7601u_phy_set_channel(dev, &hw->conf.chandef);\n\t\tieee80211_wake_queues(hw);\n\t}\n\n\tmutex_unlock(&dev->mutex);\n\n\treturn ret;\n}\n\nstatic void\nmt76_configure_filter(struct ieee80211_hw *hw, unsigned int changed_flags,\n\t\t      unsigned int *total_flags, u64 multicast)\n{\n\tstruct mt7601u_dev *dev = hw->priv;\n\tu32 flags = 0;\n\n#define MT76_FILTER(_flag, _hw) do { \\\n\t\tflags |= *total_flags & FIF_##_flag;\t\t\t\\\n\t\tdev->rxfilter &= ~(_hw);\t\t\t\t\\\n\t\tdev->rxfilter |= !(flags & FIF_##_flag) * (_hw);\t\\\n\t} while (0)\n\n\tmutex_lock(&dev->mutex);\n\n\tdev->rxfilter &= ~MT_RX_FILTR_CFG_OTHER_BSS;\n\n\tMT76_FILTER(OTHER_BSS, MT_RX_FILTR_CFG_PROMISC);\n\tMT76_FILTER(FCSFAIL, MT_RX_FILTR_CFG_CRC_ERR);\n\tMT76_FILTER(PLCPFAIL, MT_RX_FILTR_CFG_PHY_ERR);\n\tMT76_FILTER(CONTROL, MT_RX_FILTR_CFG_ACK |\n\t\t\t     MT_RX_FILTR_CFG_CTS |\n\t\t\t     MT_RX_FILTR_CFG_CFEND |\n\t\t\t     MT_RX_FILTR_CFG_CFACK |\n\t\t\t     MT_RX_FILTR_CFG_BA |\n\t\t\t     MT_RX_FILTR_CFG_CTRL_RSV);\n\tMT76_FILTER(PSPOLL, MT_RX_FILTR_CFG_PSPOLL);\n\n\t*total_flags = flags;\n\tmt76_wr(dev, MT_RX_FILTR_CFG, dev->rxfilter);\n\n\tmutex_unlock(&dev->mutex);\n}\n\nstatic void\nmt7601u_bss_info_changed(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t struct ieee80211_bss_conf *info, u64 changed)\n{\n\tstruct mt7601u_dev *dev = hw->priv;\n\n\tmutex_lock(&dev->mutex);\n\n\tif (changed & BSS_CHANGED_ASSOC)\n\t\tmt7601u_phy_con_cal_onoff(dev, info);\n\n\tif (changed & BSS_CHANGED_BSSID) {\n\t\tmt7601u_addr_wr(dev, MT_MAC_BSSID_DW0, info->bssid);\n\n\t\t \n\t\tif (is_zero_ether_addr(info->bssid))\n\t\t\tmt7601u_mac_config_tsf(dev, false, 0);\n\t}\n\n\tif (changed & BSS_CHANGED_BASIC_RATES) {\n\t\tmt7601u_wr(dev, MT_LEGACY_BASIC_RATE, info->basic_rates);\n\t\tmt7601u_wr(dev, MT_HT_FBK_CFG0, 0x65432100);\n\t\tmt7601u_wr(dev, MT_HT_FBK_CFG1, 0xedcba980);\n\t\tmt7601u_wr(dev, MT_LG_FBK_CFG0, 0xedcba988);\n\t\tmt7601u_wr(dev, MT_LG_FBK_CFG1, 0x00002100);\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON_INT)\n\t\tmt7601u_mac_config_tsf(dev, true, info->beacon_int);\n\n\tif (changed & BSS_CHANGED_HT || changed & BSS_CHANGED_ERP_CTS_PROT)\n\t\tmt7601u_mac_set_protection(dev, info->use_cts_prot,\n\t\t\t\t\t   info->ht_operation_mode);\n\n\tif (changed & BSS_CHANGED_ERP_PREAMBLE)\n\t\tmt7601u_mac_set_short_preamble(dev, info->use_short_preamble);\n\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\tint slottime = info->use_short_slot ? 9 : 20;\n\n\t\tmt76_rmw_field(dev, MT_BKOFF_SLOT_CFG,\n\t\t\t       MT_BKOFF_SLOT_CFG_SLOTTIME, slottime);\n\t}\n\n\tif (changed & BSS_CHANGED_ASSOC)\n\t\tmt7601u_phy_recalibrate_after_assoc(dev);\n\n\tmutex_unlock(&dev->mutex);\n}\n\nstatic int\nmt76_wcid_alloc(struct mt7601u_dev *dev)\n{\n\tint i, idx = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(dev->wcid_mask); i++) {\n\t\tidx = ffs(~dev->wcid_mask[i]);\n\t\tif (!idx)\n\t\t\tcontinue;\n\n\t\tidx--;\n\t\tdev->wcid_mask[i] |= BIT(idx);\n\t\tbreak;\n\t}\n\n\tidx = i * BITS_PER_LONG + idx;\n\tif (idx > 119)\n\t\treturn -1;\n\n\treturn idx;\n}\n\nstatic int\nmt7601u_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\tstruct ieee80211_sta *sta)\n{\n\tstruct mt7601u_dev *dev = hw->priv;\n\tstruct mt76_sta *msta = (struct mt76_sta *) sta->drv_priv;\n\tstruct mt76_vif *mvif = (struct mt76_vif *) vif->drv_priv;\n\tint ret = 0;\n\tint idx = 0;\n\n\tmutex_lock(&dev->mutex);\n\n\tidx = mt76_wcid_alloc(dev);\n\tif (idx < 0) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tmsta->wcid.idx = idx;\n\tmsta->wcid.hw_key_idx = -1;\n\tmt7601u_mac_wcid_setup(dev, idx, mvif->idx, sta->addr);\n\tmt76_clear(dev, MT_WCID_DROP(idx), MT_WCID_DROP_MASK(idx));\n\trcu_assign_pointer(dev->wcid[idx], &msta->wcid);\n\tmt7601u_mac_set_ampdu_factor(dev);\n\nout:\n\tmutex_unlock(&dev->mutex);\n\n\treturn ret;\n}\n\nstatic int\nmt7601u_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t   struct ieee80211_sta *sta)\n{\n\tstruct mt7601u_dev *dev = hw->priv;\n\tstruct mt76_sta *msta = (struct mt76_sta *) sta->drv_priv;\n\tint idx = msta->wcid.idx;\n\n\tmutex_lock(&dev->mutex);\n\trcu_assign_pointer(dev->wcid[idx], NULL);\n\tmt76_set(dev, MT_WCID_DROP(idx), MT_WCID_DROP_MASK(idx));\n\tdev->wcid_mask[idx / BITS_PER_LONG] &= ~BIT(idx % BITS_PER_LONG);\n\tmt7601u_mac_wcid_setup(dev, idx, 0, NULL);\n\tmt7601u_mac_set_ampdu_factor(dev);\n\tmutex_unlock(&dev->mutex);\n\n\treturn 0;\n}\n\nstatic void\nmt7601u_sta_notify(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t   enum sta_notify_cmd cmd, struct ieee80211_sta *sta)\n{\n}\n\nstatic void\nmt7601u_sw_scan(struct ieee80211_hw *hw,\n\t\tstruct ieee80211_vif *vif,\n\t\tconst u8 *mac_addr)\n{\n\tstruct mt7601u_dev *dev = hw->priv;\n\n\tmt7601u_agc_save(dev);\n\tset_bit(MT7601U_STATE_SCANNING, &dev->state);\n}\n\nstatic void\nmt7601u_sw_scan_complete(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct mt7601u_dev *dev = hw->priv;\n\n\tmt7601u_agc_restore(dev);\n\tclear_bit(MT7601U_STATE_SCANNING, &dev->state);\n\n\tieee80211_queue_delayed_work(dev->hw, &dev->cal_work,\n\t\t\t\t     MT_CALIBRATE_INTERVAL);\n\tif (dev->freq_cal.enabled)\n\t\tieee80211_queue_delayed_work(dev->hw, &dev->freq_cal.work,\n\t\t\t\t\t     MT_FREQ_CAL_INIT_DELAY);\n}\n\nstatic int\nmt7601u_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\tstruct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\tstruct ieee80211_key_conf *key)\n{\n\tstruct mt7601u_dev *dev = hw->priv;\n\tstruct mt76_vif *mvif = (struct mt76_vif *) vif->drv_priv;\n\tstruct mt76_sta *msta = sta ? (struct mt76_sta *) sta->drv_priv : NULL;\n\tstruct mt76_wcid *wcid = msta ? &msta->wcid : &mvif->group_wcid;\n\tint idx = key->keyidx;\n\tint ret;\n\n\t \n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (cmd == SET_KEY) {\n\t\tkey->hw_key_idx = wcid->idx;\n\t\twcid->hw_key_idx = idx;\n\t} else {\n\t\tif (idx == wcid->hw_key_idx)\n\t\t\twcid->hw_key_idx = -1;\n\n\t\tkey = NULL;\n\t}\n\n\tif (!msta) {\n\t\tif (key || wcid->hw_key_idx == idx) {\n\t\t\tret = mt76_mac_wcid_set_key(dev, wcid->idx, key);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\treturn mt76_mac_shared_key_setup(dev, mvif->idx, idx, key);\n\t}\n\n\treturn mt76_mac_wcid_set_key(dev, msta->wcid.idx, key);\n}\n\nstatic int mt7601u_set_rts_threshold(struct ieee80211_hw *hw, u32 value)\n{\n\tstruct mt7601u_dev *dev = hw->priv;\n\n\tmt76_rmw_field(dev, MT_TX_RTS_CFG, MT_TX_RTS_CFG_THRESH, value);\n\n\treturn 0;\n}\n\nstatic int\nmt76_ampdu_action(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t  struct ieee80211_ampdu_params *params)\n{\n\tstruct mt7601u_dev *dev = hw->priv;\n\tstruct ieee80211_sta *sta = params->sta;\n\tenum ieee80211_ampdu_mlme_action action = params->action;\n\tu16 tid = params->tid;\n\tu16 ssn = params->ssn;\n\tstruct mt76_sta *msta = (struct mt76_sta *) sta->drv_priv;\n\n\tWARN_ON(msta->wcid.idx > GROUP_WCID(0));\n\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_RX_START:\n\t\tmt76_set(dev, MT_WCID_ADDR(msta->wcid.idx) + 4, BIT(16 + tid));\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\tmt76_clear(dev, MT_WCID_ADDR(msta->wcid.idx) + 4,\n\t\t\t   BIT(16 + tid));\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\tieee80211_send_bar(vif, sta->addr, tid, msta->agg_ssn[tid]);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_START:\n\t\tmsta->agg_ssn[tid] = ssn << 4;\n\t\treturn IEEE80211_AMPDU_TX_START_IMMEDIATE;\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\t\tieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nmt76_sta_rate_tbl_update(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t struct ieee80211_sta *sta)\n{\n\tstruct mt7601u_dev *dev = hw->priv;\n\tstruct mt76_sta *msta = (struct mt76_sta *) sta->drv_priv;\n\tstruct ieee80211_sta_rates *rates;\n\tstruct ieee80211_tx_rate rate = {};\n\n\trcu_read_lock();\n\trates = rcu_dereference(sta->rates);\n\n\tif (!rates)\n\t\tgoto out;\n\n\trate.idx = rates->rate[0].idx;\n\trate.flags = rates->rate[0].flags;\n\tmt76_mac_wcid_set_rate(dev, &msta->wcid, &rate);\n\nout:\n\trcu_read_unlock();\n}\n\nconst struct ieee80211_ops mt7601u_ops = {\n\t.tx = mt7601u_tx,\n\t.wake_tx_queue = ieee80211_handle_wake_tx_queue,\n\t.start = mt7601u_start,\n\t.stop = mt7601u_stop,\n\t.add_interface = mt7601u_add_interface,\n\t.remove_interface = mt7601u_remove_interface,\n\t.config = mt7601u_config,\n\t.configure_filter = mt76_configure_filter,\n\t.bss_info_changed = mt7601u_bss_info_changed,\n\t.sta_add = mt7601u_sta_add,\n\t.sta_remove = mt7601u_sta_remove,\n\t.sta_notify = mt7601u_sta_notify,\n\t.set_key = mt7601u_set_key,\n\t.conf_tx = mt7601u_conf_tx,\n\t.sw_scan_start = mt7601u_sw_scan,\n\t.sw_scan_complete = mt7601u_sw_scan_complete,\n\t.ampdu_action = mt76_ampdu_action,\n\t.sta_rate_tbl_update = mt76_sta_rate_tbl_update,\n\t.set_rts_threshold = mt7601u_set_rts_threshold,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}