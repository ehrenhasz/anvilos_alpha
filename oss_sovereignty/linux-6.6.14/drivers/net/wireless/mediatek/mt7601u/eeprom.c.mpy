{
  "module_name": "eeprom.c",
  "hash_id": "c1df6b65628cb68e90bd6c3d7fdeeca285057c7ba2f147a59d9cc1d7959ab270",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt7601u/eeprom.c",
  "human_readable_source": "\n \n\n#include <linux/of.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n#include <linux/etherdevice.h>\n#include <asm/unaligned.h>\n#include \"mt7601u.h\"\n#include \"eeprom.h\"\n#include \"mac.h\"\n\nstatic bool\nfield_valid(u8 val)\n{\n\treturn val != 0xff;\n}\n\nstatic s8\nfield_validate(u8 val)\n{\n\tif (!field_valid(val))\n\t\treturn 0;\n\n\treturn val;\n}\n\nstatic int\nmt7601u_efuse_read(struct mt7601u_dev *dev, u16 addr, u8 *data,\n\t\t   enum mt7601u_eeprom_access_modes mode)\n{\n\tu32 val;\n\tint i;\n\n\tval = mt76_rr(dev, MT_EFUSE_CTRL);\n\tval &= ~(MT_EFUSE_CTRL_AIN |\n\t\t MT_EFUSE_CTRL_MODE);\n\tval |= FIELD_PREP(MT_EFUSE_CTRL_AIN, addr & ~0xf) |\n\t       FIELD_PREP(MT_EFUSE_CTRL_MODE, mode) |\n\t       MT_EFUSE_CTRL_KICK;\n\tmt76_wr(dev, MT_EFUSE_CTRL, val);\n\n\tif (!mt76_poll(dev, MT_EFUSE_CTRL, MT_EFUSE_CTRL_KICK, 0, 1000))\n\t\treturn -ETIMEDOUT;\n\n\tval = mt76_rr(dev, MT_EFUSE_CTRL);\n\tif ((val & MT_EFUSE_CTRL_AOUT) == MT_EFUSE_CTRL_AOUT) {\n\t\t \n\t\tmemset(data, 0xff, 16);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tval = mt76_rr(dev, MT_EFUSE_DATA(i));\n\t\tput_unaligned_le32(val, data + 4 * i);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmt7601u_efuse_physical_size_check(struct mt7601u_dev *dev)\n{\n\tconst int map_reads = DIV_ROUND_UP(MT_EFUSE_USAGE_MAP_SIZE, 16);\n\tu8 data[round_up(MT_EFUSE_USAGE_MAP_SIZE, 16)];\n\tint ret, i;\n\tu32 start = 0, end = 0, cnt_free;\n\n\tfor (i = 0; i < map_reads; i++) {\n\t\tret = mt7601u_efuse_read(dev, MT_EE_USAGE_MAP_START + i * 16,\n\t\t\t\t\t data + i * 16, MT_EE_PHYSICAL_READ);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < MT_EFUSE_USAGE_MAP_SIZE; i++)\n\t\tif (!data[i]) {\n\t\t\tif (!start)\n\t\t\t\tstart = MT_EE_USAGE_MAP_START + i;\n\t\t\tend = MT_EE_USAGE_MAP_START + i;\n\t\t}\n\tcnt_free = end - start + 1;\n\n\tif (MT_EFUSE_USAGE_MAP_SIZE - cnt_free < 5) {\n\t\tdev_err(dev->dev, \"Error: your device needs default EEPROM file and this driver doesn't support it!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic bool\nmt7601u_has_tssi(struct mt7601u_dev *dev, u8 *eeprom)\n{\n\tu16 nic_conf1 = get_unaligned_le16(eeprom + MT_EE_NIC_CONF_1);\n\n\treturn (u16)~nic_conf1 && (nic_conf1 & MT_EE_NIC_CONF_1_TX_ALC_EN);\n}\n\nstatic void\nmt7601u_set_chip_cap(struct mt7601u_dev *dev, u8 *eeprom)\n{\n\tu16 nic_conf0 = get_unaligned_le16(eeprom + MT_EE_NIC_CONF_0);\n\tu16 nic_conf1 = get_unaligned_le16(eeprom + MT_EE_NIC_CONF_1);\n\n\tif (!field_valid(nic_conf1 & 0xff))\n\t\tnic_conf1 &= 0xff00;\n\n\tdev->ee->tssi_enabled = mt7601u_has_tssi(dev, eeprom) &&\n\t\t\t\t!(nic_conf1 & MT_EE_NIC_CONF_1_TEMP_TX_ALC);\n\n\tif (nic_conf1 & MT_EE_NIC_CONF_1_HW_RF_CTRL)\n\t\tdev_err(dev->dev,\n\t\t\t\"Error: this driver does not support HW RF ctrl\\n\");\n\n\tif (!field_valid(nic_conf0 >> 8))\n\t\treturn;\n\n\tif (FIELD_GET(MT_EE_NIC_CONF_0_RX_PATH, nic_conf0) > 1 ||\n\t    FIELD_GET(MT_EE_NIC_CONF_0_TX_PATH, nic_conf0) > 1)\n\t\tdev_err(dev->dev,\n\t\t\t\"Error: device has more than 1 RX/TX stream!\\n\");\n}\n\nstatic void mt7601u_set_channel_target_power(struct mt7601u_dev *dev,\n\t\t\t\t\t     u8 *eeprom, u8 max_pwr)\n{\n\tu8 trgt_pwr = eeprom[MT_EE_TX_TSSI_TARGET_POWER];\n\n\tif (trgt_pwr > max_pwr || !trgt_pwr) {\n\t\tdev_warn(dev->dev, \"Error: EEPROM trgt power invalid %hhx!\\n\",\n\t\t\t trgt_pwr);\n\t\ttrgt_pwr = 0x20;\n\t}\n\n\tmemset(dev->ee->chan_pwr, trgt_pwr, sizeof(dev->ee->chan_pwr));\n}\n\nstatic void\nmt7601u_set_channel_power(struct mt7601u_dev *dev, u8 *eeprom)\n{\n\tu32 i, val;\n\tu8 max_pwr;\n\n\tval = mt7601u_rr(dev, MT_TX_ALC_CFG_0);\n\tmax_pwr = FIELD_GET(MT_TX_ALC_CFG_0_LIMIT_0, val);\n\n\tif (mt7601u_has_tssi(dev, eeprom)) {\n\t\tmt7601u_set_channel_target_power(dev, eeprom, max_pwr);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 14; i++) {\n\t\ts8 power = field_validate(eeprom[MT_EE_TX_POWER_OFFSET + i]);\n\n\t\tif (power > max_pwr || power < 0)\n\t\t\tpower = MT7601U_DEFAULT_TX_POWER;\n\n\t\tdev->ee->chan_pwr[i] = power;\n\t}\n}\n\nstatic void\nmt7601u_set_country_reg(struct mt7601u_dev *dev, u8 *eeprom)\n{\n\t \n\tstatic const struct reg_channel_bounds chan_bounds[] = {\n\t\t \n\t\t{  1, 11 },\t{  1, 13 },\t{ 10,  2 },\t{ 10,  4 },\n\t\t{ 14,  1 },\t{  1, 14 },\t{  3,  7 },\t{  5,  9 },\n\t\t \n\t\t{  1, 11 },\t{  1, 14 }\n\t};\n\tu8 val = eeprom[MT_EE_COUNTRY_REGION];\n\tint idx = -1;\n\n\tif (val < 8)\n\t\tidx = val;\n\tif (val > 31 && val < 33)\n\t\tidx = val - 32 + 8;\n\n\tif (idx != -1)\n\t\tdev_info(dev->dev,\n\t\t\t \"EEPROM country region %02x (channels %d-%d)\\n\",\n\t\t\t val, chan_bounds[idx].start,\n\t\t\t chan_bounds[idx].start + chan_bounds[idx].num - 1);\n\telse\n\t\tidx = 5;  \n\n\tdev->ee->reg = chan_bounds[idx];\n\n\t \n}\n\nstatic void\nmt7601u_set_rf_freq_off(struct mt7601u_dev *dev, u8 *eeprom)\n{\n\tu8 comp;\n\n\tdev->ee->rf_freq_off = field_validate(eeprom[MT_EE_FREQ_OFFSET]);\n\tcomp = field_validate(eeprom[MT_EE_FREQ_OFFSET_COMPENSATION]);\n\n\tif (comp & BIT(7))\n\t\tdev->ee->rf_freq_off -= comp & 0x7f;\n\telse\n\t\tdev->ee->rf_freq_off += comp;\n}\n\nstatic void\nmt7601u_set_rssi_offset(struct mt7601u_dev *dev, u8 *eeprom)\n{\n\tint i;\n\ts8 *rssi_offset = dev->ee->rssi_offset;\n\n\tfor (i = 0; i < 2; i++) {\n\t\trssi_offset[i] = eeprom[MT_EE_RSSI_OFFSET + i];\n\n\t\tif (rssi_offset[i] < -10 || rssi_offset[i] > 10) {\n\t\t\tdev_warn(dev->dev,\n\t\t\t\t \"Warning: EEPROM RSSI is invalid %02hhx\\n\",\n\t\t\t\t rssi_offset[i]);\n\t\t\trssi_offset[i] = 0;\n\t\t}\n\t}\n}\n\nstatic void\nmt7601u_extra_power_over_mac(struct mt7601u_dev *dev)\n{\n\tu32 val;\n\n\tval = ((mt7601u_rr(dev, MT_TX_PWR_CFG_1) & 0x0000ff00) >> 8);\n\tval |= ((mt7601u_rr(dev, MT_TX_PWR_CFG_2) & 0x0000ff00) << 8);\n\tmt7601u_wr(dev, MT_TX_PWR_CFG_7, val);\n\n\tval = ((mt7601u_rr(dev, MT_TX_PWR_CFG_4) & 0x0000ff00) >> 8);\n\tmt7601u_wr(dev, MT_TX_PWR_CFG_9, val);\n}\n\nstatic void\nmt7601u_set_power_rate(struct power_per_rate *rate, s8 delta, u8 value)\n{\n\t \n\tif (value == 0xff)\n\t\treturn;\n\n\trate->raw = s6_validate(value);\n\trate->bw20 = s6_to_int(value);\n\t \n\trate->bw40 = rate->bw20 + delta;\n}\n\nstatic void\nmt7601u_save_power_rate(struct mt7601u_dev *dev, s8 delta, u32 val, int i)\n{\n\tstruct mt7601u_rate_power *t = &dev->ee->power_rate_table;\n\n\tswitch (i) {\n\tcase 0:\n\t\tmt7601u_set_power_rate(&t->cck[0], delta, (val >> 0) & 0xff);\n\t\tmt7601u_set_power_rate(&t->cck[1], delta, (val >> 8) & 0xff);\n\t\t \n\t\tdev->ee->real_cck_bw20[0] = t->cck[0].bw20;\n\t\tdev->ee->real_cck_bw20[1] = t->cck[1].bw20;\n\n\t\tmt7601u_set_power_rate(&t->ofdm[0], delta, (val >> 16) & 0xff);\n\t\tmt7601u_set_power_rate(&t->ofdm[1], delta, (val >> 24) & 0xff);\n\t\tbreak;\n\tcase 1:\n\t\tmt7601u_set_power_rate(&t->ofdm[2], delta, (val >> 0) & 0xff);\n\t\tmt7601u_set_power_rate(&t->ofdm[3], delta, (val >> 8) & 0xff);\n\t\tmt7601u_set_power_rate(&t->ht[0], delta, (val >> 16) & 0xff);\n\t\tmt7601u_set_power_rate(&t->ht[1], delta, (val >> 24) & 0xff);\n\t\tbreak;\n\tcase 2:\n\t\tmt7601u_set_power_rate(&t->ht[2], delta, (val >> 0) & 0xff);\n\t\tmt7601u_set_power_rate(&t->ht[3], delta, (val >> 8) & 0xff);\n\t\tbreak;\n\t}\n}\n\nstatic s8\nget_delta(u8 val)\n{\n\ts8 ret;\n\n\tif (!field_valid(val) || !(val & BIT(7)))\n\t\treturn 0;\n\n\tret = val & 0x1f;\n\tif (ret > 8)\n\t\tret = 8;\n\tif (val & BIT(6))\n\t\tret = -ret;\n\n\treturn ret;\n}\n\nstatic void\nmt7601u_config_tx_power_per_rate(struct mt7601u_dev *dev, u8 *eeprom)\n{\n\tu32 val;\n\ts8 bw40_delta;\n\tint i;\n\n\tbw40_delta = get_delta(eeprom[MT_EE_TX_POWER_DELTA_BW40]);\n\n\tfor (i = 0; i < 5; i++) {\n\t\tval = get_unaligned_le32(eeprom + MT_EE_TX_POWER_BYRATE(i));\n\n\t\tmt7601u_save_power_rate(dev, bw40_delta, val, i);\n\n\t\tif (~val)\n\t\t\tmt7601u_wr(dev, MT_TX_PWR_CFG_0 + i * 4, val);\n\t}\n\n\tmt7601u_extra_power_over_mac(dev);\n}\n\nstatic void\nmt7601u_init_tssi_params(struct mt7601u_dev *dev, u8 *eeprom)\n{\n\tstruct tssi_data *d = &dev->ee->tssi_data;\n\n\tif (!dev->ee->tssi_enabled)\n\t\treturn;\n\n\td->slope = eeprom[MT_EE_TX_TSSI_SLOPE];\n\td->tx0_delta_offset = eeprom[MT_EE_TX_TSSI_OFFSET] * 1024;\n\td->offset[0] = eeprom[MT_EE_TX_TSSI_OFFSET_GROUP];\n\td->offset[1] = eeprom[MT_EE_TX_TSSI_OFFSET_GROUP + 1];\n\td->offset[2] = eeprom[MT_EE_TX_TSSI_OFFSET_GROUP + 2];\n}\n\nint\nmt7601u_eeprom_init(struct mt7601u_dev *dev)\n{\n\tu8 *eeprom;\n\tint i, ret;\n\n\tret = mt7601u_efuse_physical_size_check(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->ee = devm_kzalloc(dev->dev, sizeof(*dev->ee), GFP_KERNEL);\n\tif (!dev->ee)\n\t\treturn -ENOMEM;\n\n\teeprom = kmalloc(MT7601U_EEPROM_SIZE, GFP_KERNEL);\n\tif (!eeprom)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i + 16 <= MT7601U_EEPROM_SIZE; i += 16) {\n\t\tret = mt7601u_efuse_read(dev, i, eeprom + i, MT_EE_READ);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (eeprom[MT_EE_VERSION_EE] > MT7601U_EE_MAX_VER)\n\t\tdev_warn(dev->dev,\n\t\t\t \"Warning: unsupported EEPROM version %02hhx\\n\",\n\t\t\t eeprom[MT_EE_VERSION_EE]);\n\tdev_info(dev->dev, \"EEPROM ver:%02hhx fae:%02hhx\\n\",\n\t\t eeprom[MT_EE_VERSION_EE], eeprom[MT_EE_VERSION_FAE]);\n\n\tmt7601u_set_macaddr(dev, eeprom + MT_EE_MAC_ADDR);\n\tmt7601u_set_chip_cap(dev, eeprom);\n\tmt7601u_set_channel_power(dev, eeprom);\n\tmt7601u_set_country_reg(dev, eeprom);\n\tmt7601u_set_rf_freq_off(dev, eeprom);\n\tmt7601u_set_rssi_offset(dev, eeprom);\n\tdev->ee->ref_temp = eeprom[MT_EE_REF_TEMP];\n\tdev->ee->lna_gain = eeprom[MT_EE_LNA_GAIN];\n\n\tmt7601u_config_tx_power_per_rate(dev, eeprom);\n\n\tmt7601u_init_tssi_params(dev, eeprom);\nout:\n\tkfree(eeprom);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}