{
  "module_name": "mac.c",
  "hash_id": "6151974ccbc3fba99a1703d53d84fc052135b036b2912a6f30b086e38a915ca3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt7601u/mac.c",
  "human_readable_source": "\n \n\n#include \"mt7601u.h\"\n#include \"trace.h\"\n#include <linux/etherdevice.h>\n\nvoid mt7601u_set_macaddr(struct mt7601u_dev *dev, const u8 *addr)\n{\n\tether_addr_copy(dev->macaddr, addr);\n\n\tif (!is_valid_ether_addr(dev->macaddr)) {\n\t\teth_random_addr(dev->macaddr);\n\t\tdev_info(dev->dev,\n\t\t\t \"Invalid MAC address, using random address %pM\\n\",\n\t\t\t dev->macaddr);\n\t}\n\n\tmt76_wr(dev, MT_MAC_ADDR_DW0, get_unaligned_le32(dev->macaddr));\n\tmt76_wr(dev, MT_MAC_ADDR_DW1, get_unaligned_le16(dev->macaddr + 4) |\n\t\tFIELD_PREP(MT_MAC_ADDR_DW1_U2ME_MASK, 0xff));\n}\n\nstatic void\nmt76_mac_process_tx_rate(struct ieee80211_tx_rate *txrate, u16 rate)\n{\n\tu8 idx = FIELD_GET(MT_TXWI_RATE_MCS, rate);\n\n\ttxrate->idx = 0;\n\ttxrate->flags = 0;\n\ttxrate->count = 1;\n\n\tswitch (FIELD_GET(MT_TXWI_RATE_PHY_MODE, rate)) {\n\tcase MT_PHY_TYPE_OFDM:\n\t\ttxrate->idx = idx + 4;\n\t\treturn;\n\tcase MT_PHY_TYPE_CCK:\n\t\tif (idx >= 8)\n\t\t\tidx -= 8;\n\n\t\ttxrate->idx = idx;\n\t\treturn;\n\tcase MT_PHY_TYPE_HT_GF:\n\t\ttxrate->flags |= IEEE80211_TX_RC_GREEN_FIELD;\n\t\tfallthrough;\n\tcase MT_PHY_TYPE_HT:\n\t\ttxrate->flags |= IEEE80211_TX_RC_MCS;\n\t\ttxrate->idx = idx;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tif (FIELD_GET(MT_TXWI_RATE_BW, rate) == MT_PHY_BW_40)\n\t\ttxrate->flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\n\n\tif (rate & MT_TXWI_RATE_SGI)\n\t\ttxrate->flags |= IEEE80211_TX_RC_SHORT_GI;\n}\n\nstatic void\nmt76_mac_fill_tx_status(struct mt7601u_dev *dev, struct ieee80211_tx_info *info,\n\t\t\tstruct mt76_tx_status *st)\n{\n\tstruct ieee80211_tx_rate *rate = info->status.rates;\n\tint cur_idx, last_rate;\n\tint i;\n\n\tlast_rate = min_t(int, st->retry, IEEE80211_TX_MAX_RATES - 1);\n\tmt76_mac_process_tx_rate(&rate[last_rate], st->rate);\n\tif (last_rate < IEEE80211_TX_MAX_RATES - 1)\n\t\trate[last_rate + 1].idx = -1;\n\n\tcur_idx = rate[last_rate].idx + st->retry;\n\tfor (i = 0; i <= last_rate; i++) {\n\t\trate[i].flags = rate[last_rate].flags;\n\t\trate[i].idx = max_t(int, 0, cur_idx - i);\n\t\trate[i].count = 1;\n\t}\n\n\tif (last_rate > 0)\n\t\trate[last_rate - 1].count = st->retry + 1 - last_rate;\n\n\tinfo->status.ampdu_len = 1;\n\tinfo->status.ampdu_ack_len = st->success;\n\n\tif (st->is_probe)\n\t\tinfo->flags |= IEEE80211_TX_CTL_RATE_CTRL_PROBE;\n\n\tif (st->aggr)\n\t\tinfo->flags |= IEEE80211_TX_CTL_AMPDU |\n\t\t\t       IEEE80211_TX_STAT_AMPDU;\n\n\tif (!st->ack_req)\n\t\tinfo->flags |= IEEE80211_TX_CTL_NO_ACK;\n\telse if (st->success)\n\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n}\n\nu16 mt76_mac_tx_rate_val(struct mt7601u_dev *dev,\n\t\t\t const struct ieee80211_tx_rate *rate, u8 *nss_val)\n{\n\tu16 rateval;\n\tu8 phy, rate_idx;\n\tu8 nss = 1;\n\tu8 bw = 0;\n\n\tif (rate->flags & IEEE80211_TX_RC_MCS) {\n\t\trate_idx = rate->idx;\n\t\tnss = 1 + (rate->idx >> 3);\n\t\tphy = MT_PHY_TYPE_HT;\n\t\tif (rate->flags & IEEE80211_TX_RC_GREEN_FIELD)\n\t\t\tphy = MT_PHY_TYPE_HT_GF;\n\t\tif (rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\n\t\t\tbw = 1;\n\t} else {\n\t\tconst struct ieee80211_rate *r;\n\t\tint band = dev->chandef.chan->band;\n\t\tu16 val;\n\n\t\tr = &dev->hw->wiphy->bands[band]->bitrates[rate->idx];\n\t\tif (rate->flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE)\n\t\t\tval = r->hw_value_short;\n\t\telse\n\t\t\tval = r->hw_value;\n\n\t\tphy = val >> 8;\n\t\trate_idx = val & 0xff;\n\t\tbw = 0;\n\t}\n\n\trateval = FIELD_PREP(MT_RXWI_RATE_MCS, rate_idx);\n\trateval |= FIELD_PREP(MT_RXWI_RATE_PHY, phy);\n\trateval |= FIELD_PREP(MT_RXWI_RATE_BW, bw);\n\tif (rate->flags & IEEE80211_TX_RC_SHORT_GI)\n\t\trateval |= MT_RXWI_RATE_SGI;\n\n\t*nss_val = nss;\n\treturn rateval;\n}\n\nvoid mt76_mac_wcid_set_rate(struct mt7601u_dev *dev, struct mt76_wcid *wcid,\n\t\t\t    const struct ieee80211_tx_rate *rate)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\twcid->tx_rate = mt76_mac_tx_rate_val(dev, rate, &wcid->tx_rate_nss);\n\twcid->tx_rate_set = true;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n}\n\nstruct mt76_tx_status mt7601u_mac_fetch_tx_status(struct mt7601u_dev *dev)\n{\n\tstruct mt76_tx_status stat = {};\n\tu32 val;\n\n\tval = mt7601u_rr(dev, MT_TX_STAT_FIFO);\n\tstat.valid = !!(val & MT_TX_STAT_FIFO_VALID);\n\tstat.success = !!(val & MT_TX_STAT_FIFO_SUCCESS);\n\tstat.aggr = !!(val & MT_TX_STAT_FIFO_AGGR);\n\tstat.ack_req = !!(val & MT_TX_STAT_FIFO_ACKREQ);\n\tstat.pktid = FIELD_GET(MT_TX_STAT_FIFO_PID_TYPE, val);\n\tstat.wcid = FIELD_GET(MT_TX_STAT_FIFO_WCID, val);\n\tstat.rate = FIELD_GET(MT_TX_STAT_FIFO_RATE, val);\n\n\treturn stat;\n}\n\nvoid mt76_send_tx_status(struct mt7601u_dev *dev, struct mt76_tx_status *stat)\n{\n\tstruct ieee80211_tx_info info = {};\n\tstruct ieee80211_sta *sta = NULL;\n\tstruct mt76_wcid *wcid = NULL;\n\tvoid *msta;\n\n\trcu_read_lock();\n\tif (stat->wcid < ARRAY_SIZE(dev->wcid))\n\t\twcid = rcu_dereference(dev->wcid[stat->wcid]);\n\n\tif (wcid) {\n\t\tmsta = container_of(wcid, struct mt76_sta, wcid);\n\t\tsta = container_of(msta, struct ieee80211_sta,\n\t\t\t\t   drv_priv);\n\t}\n\n\tmt76_mac_fill_tx_status(dev, &info, stat);\n\n\tspin_lock_bh(&dev->mac_lock);\n\tieee80211_tx_status_noskb(dev->hw, sta, &info);\n\tspin_unlock_bh(&dev->mac_lock);\n\n\trcu_read_unlock();\n}\n\nvoid mt7601u_mac_set_protection(struct mt7601u_dev *dev, bool legacy_prot,\n\t\t\t\tint ht_mode)\n{\n\tint mode = ht_mode & IEEE80211_HT_OP_MODE_PROTECTION;\n\tbool non_gf = !!(ht_mode & IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\n\tu32 prot[6];\n\tbool ht_rts[4] = {};\n\tint i;\n\n\tprot[0] = MT_PROT_NAV_SHORT |\n\t\t  MT_PROT_TXOP_ALLOW_ALL |\n\t\t  MT_PROT_RTS_THR_EN;\n\tprot[1] = prot[0];\n\tif (legacy_prot)\n\t\tprot[1] |= MT_PROT_CTRL_CTS2SELF;\n\n\tprot[2] = prot[4] = MT_PROT_NAV_SHORT | MT_PROT_TXOP_ALLOW_BW20;\n\tprot[3] = prot[5] = MT_PROT_NAV_SHORT | MT_PROT_TXOP_ALLOW_ALL;\n\n\tif (legacy_prot) {\n\t\tprot[2] |= MT_PROT_RATE_CCK_11;\n\t\tprot[3] |= MT_PROT_RATE_CCK_11;\n\t\tprot[4] |= MT_PROT_RATE_CCK_11;\n\t\tprot[5] |= MT_PROT_RATE_CCK_11;\n\t} else {\n\t\tprot[2] |= MT_PROT_RATE_OFDM_24;\n\t\tprot[3] |= MT_PROT_RATE_DUP_OFDM_24;\n\t\tprot[4] |= MT_PROT_RATE_OFDM_24;\n\t\tprot[5] |= MT_PROT_RATE_DUP_OFDM_24;\n\t}\n\n\tswitch (mode) {\n\tcase IEEE80211_HT_OP_MODE_PROTECTION_NONE:\n\t\tbreak;\n\n\tcase IEEE80211_HT_OP_MODE_PROTECTION_NONMEMBER:\n\t\tht_rts[0] = ht_rts[1] = ht_rts[2] = ht_rts[3] = true;\n\t\tbreak;\n\n\tcase IEEE80211_HT_OP_MODE_PROTECTION_20MHZ:\n\t\tht_rts[1] = ht_rts[3] = true;\n\t\tbreak;\n\n\tcase IEEE80211_HT_OP_MODE_PROTECTION_NONHT_MIXED:\n\t\tht_rts[0] = ht_rts[1] = ht_rts[2] = ht_rts[3] = true;\n\t\tbreak;\n\t}\n\n\tif (non_gf)\n\t\tht_rts[2] = ht_rts[3] = true;\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (ht_rts[i])\n\t\t\tprot[i + 2] |= MT_PROT_CTRL_RTS_CTS;\n\n\tfor (i = 0; i < 6; i++)\n\t\tmt7601u_wr(dev, MT_CCK_PROT_CFG + i * 4, prot[i]);\n}\n\nvoid mt7601u_mac_set_short_preamble(struct mt7601u_dev *dev, bool short_preamb)\n{\n\tif (short_preamb)\n\t\tmt76_set(dev, MT_AUTO_RSP_CFG, MT_AUTO_RSP_PREAMB_SHORT);\n\telse\n\t\tmt76_clear(dev, MT_AUTO_RSP_CFG, MT_AUTO_RSP_PREAMB_SHORT);\n}\n\nvoid mt7601u_mac_config_tsf(struct mt7601u_dev *dev, bool enable, int interval)\n{\n\tu32 val = mt7601u_rr(dev, MT_BEACON_TIME_CFG);\n\n\tval &= ~(MT_BEACON_TIME_CFG_TIMER_EN |\n\t\t MT_BEACON_TIME_CFG_SYNC_MODE |\n\t\t MT_BEACON_TIME_CFG_TBTT_EN);\n\n\tif (!enable) {\n\t\tmt7601u_wr(dev, MT_BEACON_TIME_CFG, val);\n\t\treturn;\n\t}\n\n\tval &= ~MT_BEACON_TIME_CFG_INTVAL;\n\tval |= FIELD_PREP(MT_BEACON_TIME_CFG_INTVAL, interval << 4) |\n\t\tMT_BEACON_TIME_CFG_TIMER_EN |\n\t\tMT_BEACON_TIME_CFG_SYNC_MODE |\n\t\tMT_BEACON_TIME_CFG_TBTT_EN;\n}\n\nstatic void mt7601u_check_mac_err(struct mt7601u_dev *dev)\n{\n\tu32 val = mt7601u_rr(dev, 0x10f4);\n\n\tif (!(val & BIT(29)) || !(val & (BIT(7) | BIT(5))))\n\t\treturn;\n\n\tdev_err(dev->dev, \"Error: MAC specific condition occurred\\n\");\n\n\tmt76_set(dev, MT_MAC_SYS_CTRL, MT_MAC_SYS_CTRL_RESET_CSR);\n\tudelay(10);\n\tmt76_clear(dev, MT_MAC_SYS_CTRL, MT_MAC_SYS_CTRL_RESET_CSR);\n}\n\nvoid mt7601u_mac_work(struct work_struct *work)\n{\n\tstruct mt7601u_dev *dev = container_of(work, struct mt7601u_dev,\n\t\t\t\t\t       mac_work.work);\n\tstruct {\n\t\tu32 addr_base;\n\t\tu32 span;\n\t\tu64 *stat_base;\n\t} spans[] = {\n\t\t{ MT_RX_STA_CNT0,\t3,\tdev->stats.rx_stat },\n\t\t{ MT_TX_STA_CNT0,\t3,\tdev->stats.tx_stat },\n\t\t{ MT_TX_AGG_STAT,\t1,\tdev->stats.aggr_stat },\n\t\t{ MT_MPDU_DENSITY_CNT,\t1,\tdev->stats.zero_len_del },\n\t\t{ MT_TX_AGG_CNT_BASE0,\t8,\t&dev->stats.aggr_n[0] },\n\t\t{ MT_TX_AGG_CNT_BASE1,\t8,\t&dev->stats.aggr_n[16] },\n\t};\n\tu32 sum, n;\n\tint i, j, k;\n\n\t \n\n\tk = 0;\n\tn = 0;\n\tsum = 0;\n\tfor (i = 0; i < ARRAY_SIZE(spans); i++)\n\t\tfor (j = 0; j < spans[i].span; j++) {\n\t\t\tu32 val = mt7601u_rr(dev, spans[i].addr_base + j * 4);\n\n\t\t\tspans[i].stat_base[j * 2] += val & 0xffff;\n\t\t\tspans[i].stat_base[j * 2 + 1] += val >> 16;\n\n\t\t\t \n\t\t\tif (spans[i].addr_base != MT_TX_AGG_CNT_BASE0 &&\n\t\t\t    spans[i].addr_base != MT_TX_AGG_CNT_BASE1)\n\t\t\t\tcontinue;\n\n\t\t\tn += (val >> 16) + (val & 0xffff);\n\t\t\tsum += (val & 0xffff) * (1 + k * 2) +\n\t\t\t\t(val >> 16) * (2 + k * 2);\n\t\t\tk++;\n\t\t}\n\n\tatomic_set(&dev->avg_ampdu_len, n ? DIV_ROUND_CLOSEST(sum, n) : 1);\n\n\tmt7601u_check_mac_err(dev);\n\n\tieee80211_queue_delayed_work(dev->hw, &dev->mac_work, 10 * HZ);\n}\n\nvoid\nmt7601u_mac_wcid_setup(struct mt7601u_dev *dev, u8 idx, u8 vif_idx, u8 *mac)\n{\n\tu8 zmac[ETH_ALEN] = {};\n\tu32 attr;\n\n\tattr = FIELD_PREP(MT_WCID_ATTR_BSS_IDX, vif_idx & 7) |\n\t       FIELD_PREP(MT_WCID_ATTR_BSS_IDX_EXT, !!(vif_idx & 8));\n\n\tmt76_wr(dev, MT_WCID_ATTR(idx), attr);\n\n\tif (mac)\n\t\tmemcpy(zmac, mac, sizeof(zmac));\n\n\tmt7601u_addr_wr(dev, MT_WCID_ADDR(idx), zmac);\n}\n\nvoid mt7601u_mac_set_ampdu_factor(struct mt7601u_dev *dev)\n{\n\tstruct ieee80211_sta *sta;\n\tstruct mt76_wcid *wcid;\n\tvoid *msta;\n\tu8 min_factor = 3;\n\tint i;\n\n\trcu_read_lock();\n\tfor (i = 0; i < ARRAY_SIZE(dev->wcid); i++) {\n\t\twcid = rcu_dereference(dev->wcid[i]);\n\t\tif (!wcid)\n\t\t\tcontinue;\n\n\t\tmsta = container_of(wcid, struct mt76_sta, wcid);\n\t\tsta = container_of(msta, struct ieee80211_sta, drv_priv);\n\n\t\tmin_factor = min(min_factor, sta->deflink.ht_cap.ampdu_factor);\n\t}\n\trcu_read_unlock();\n\n\tmt7601u_wr(dev, MT_MAX_LEN_CFG, 0xa0fff |\n\t\t   FIELD_PREP(MT_MAX_LEN_CFG_AMPDU, min_factor));\n}\n\nstatic void\nmt76_mac_process_rate(struct ieee80211_rx_status *status, u16 rate)\n{\n\tu8 idx = FIELD_GET(MT_RXWI_RATE_MCS, rate);\n\n\tswitch (FIELD_GET(MT_RXWI_RATE_PHY, rate)) {\n\tcase MT_PHY_TYPE_OFDM:\n\t\tif (WARN_ON(idx >= 8))\n\t\t\tidx = 0;\n\t\tidx += 4;\n\n\t\tstatus->rate_idx = idx;\n\t\treturn;\n\tcase MT_PHY_TYPE_CCK:\n\t\tif (idx >= 8) {\n\t\t\tidx -= 8;\n\t\t\tstatus->enc_flags |= RX_ENC_FLAG_SHORTPRE;\n\t\t}\n\n\t\tif (WARN_ON(idx >= 4))\n\t\t\tidx = 0;\n\n\t\tstatus->rate_idx = idx;\n\t\treturn;\n\tcase MT_PHY_TYPE_HT_GF:\n\t\tstatus->enc_flags |= RX_ENC_FLAG_HT_GF;\n\t\tfallthrough;\n\tcase MT_PHY_TYPE_HT:\n\t\tstatus->encoding = RX_ENC_HT;\n\t\tstatus->rate_idx = idx;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tif (rate & MT_RXWI_RATE_SGI)\n\t\tstatus->enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\n\tif (rate & MT_RXWI_RATE_STBC)\n\t\tstatus->enc_flags |= 1 << RX_ENC_FLAG_STBC_SHIFT;\n\n\tif (rate & MT_RXWI_RATE_BW)\n\t\tstatus->bw = RATE_INFO_BW_40;\n}\n\nstatic void\nmt7601u_rx_monitor_beacon(struct mt7601u_dev *dev, struct mt7601u_rxwi *rxwi,\n\t\t\t  u16 rate, int rssi)\n{\n\tdev->bcn_freq_off = rxwi->freq_off;\n\tdev->bcn_phy_mode = FIELD_GET(MT_RXWI_RATE_PHY, rate);\n\tewma_rssi_add(&dev->avg_rssi, -rssi);\n}\n\nstatic int\nmt7601u_rx_is_our_beacon(struct mt7601u_dev *dev, u8 *data)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)data;\n\n\treturn ieee80211_is_beacon(hdr->frame_control) &&\n\t\tether_addr_equal(hdr->addr2, dev->ap_bssid);\n}\n\nu32 mt76_mac_process_rx(struct mt7601u_dev *dev, struct sk_buff *skb,\n\t\t\tu8 *data, void *rxi)\n{\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct mt7601u_rxwi *rxwi = rxi;\n\tu32 len, ctl = le32_to_cpu(rxwi->ctl);\n\tu16 rate = le16_to_cpu(rxwi->rate);\n\tint rssi;\n\n\tlen = FIELD_GET(MT_RXWI_CTL_MPDU_LEN, ctl);\n\tif (len < 10)\n\t\treturn 0;\n\n\tif (rxwi->rxinfo & cpu_to_le32(MT_RXINFO_DECRYPT)) {\n\t\tstatus->flag |= RX_FLAG_DECRYPTED;\n\t\tstatus->flag |= RX_FLAG_MMIC_STRIPPED;\n\t\tstatus->flag |= RX_FLAG_MIC_STRIPPED;\n\t\tstatus->flag |= RX_FLAG_ICV_STRIPPED;\n\t\tstatus->flag |= RX_FLAG_IV_STRIPPED;\n\t}\n\t \n\tif (rxwi->rxinfo & cpu_to_le32(MT_RXINFO_PN_LEN))\n\t\tstatus->flag &= ~RX_FLAG_IV_STRIPPED;\n\n\tstatus->chains = BIT(0);\n\trssi = mt7601u_phy_get_rssi(dev, rxwi, rate);\n\tstatus->chain_signal[0] = status->signal = rssi;\n\tstatus->freq = dev->chandef.chan->center_freq;\n\tstatus->band = dev->chandef.chan->band;\n\n\tmt76_mac_process_rate(status, rate);\n\n\tspin_lock_bh(&dev->con_mon_lock);\n\tif (mt7601u_rx_is_our_beacon(dev, data))\n\t\tmt7601u_rx_monitor_beacon(dev, rxwi, rate, rssi);\n\telse if (rxwi->rxinfo & cpu_to_le32(MT_RXINFO_U2M))\n\t\tewma_rssi_add(&dev->avg_rssi, -rssi);\n\tspin_unlock_bh(&dev->con_mon_lock);\n\n\treturn len;\n}\n\nstatic enum mt76_cipher_type\nmt76_mac_get_key_info(struct ieee80211_key_conf *key, u8 *key_data)\n{\n\tmemset(key_data, 0, 32);\n\tif (!key)\n\t\treturn MT_CIPHER_NONE;\n\n\tif (key->keylen > 32)\n\t\treturn MT_CIPHER_NONE;\n\n\tmemcpy(key_data, key->key, key->keylen);\n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\treturn MT_CIPHER_WEP40;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\treturn MT_CIPHER_WEP104;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\treturn MT_CIPHER_TKIP;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\treturn MT_CIPHER_AES_CCMP;\n\tdefault:\n\t\treturn MT_CIPHER_NONE;\n\t}\n}\n\nint mt76_mac_wcid_set_key(struct mt7601u_dev *dev, u8 idx,\n\t\t\t  struct ieee80211_key_conf *key)\n{\n\tenum mt76_cipher_type cipher;\n\tu8 key_data[32];\n\tu8 iv_data[8];\n\tu32 val;\n\n\tcipher = mt76_mac_get_key_info(key, key_data);\n\tif (cipher == MT_CIPHER_NONE && key)\n\t\treturn -EINVAL;\n\n\ttrace_set_key(dev, idx);\n\n\tmt7601u_wr_copy(dev, MT_WCID_KEY(idx), key_data, sizeof(key_data));\n\n\tmemset(iv_data, 0, sizeof(iv_data));\n\tif (key) {\n\t\tiv_data[3] = key->keyidx << 6;\n\t\tif (cipher >= MT_CIPHER_TKIP) {\n\t\t\t \n\t\t\tiv_data[0] |= 1;\n\t\t\tiv_data[3] |= 0x20;\n\t\t}\n\t}\n\tmt7601u_wr_copy(dev, MT_WCID_IV(idx), iv_data, sizeof(iv_data));\n\n\tval = mt7601u_rr(dev, MT_WCID_ATTR(idx));\n\tval &= ~MT_WCID_ATTR_PKEY_MODE & ~MT_WCID_ATTR_PKEY_MODE_EXT;\n\tval |= FIELD_PREP(MT_WCID_ATTR_PKEY_MODE, cipher & 7) |\n\t       FIELD_PREP(MT_WCID_ATTR_PKEY_MODE_EXT, cipher >> 3);\n\tval &= ~MT_WCID_ATTR_PAIRWISE;\n\tval |= MT_WCID_ATTR_PAIRWISE *\n\t\t!!(key && key->flags & IEEE80211_KEY_FLAG_PAIRWISE);\n\tmt7601u_wr(dev, MT_WCID_ATTR(idx), val);\n\n\treturn 0;\n}\n\nint mt76_mac_shared_key_setup(struct mt7601u_dev *dev, u8 vif_idx, u8 key_idx,\n\t\t\t      struct ieee80211_key_conf *key)\n{\n\tenum mt76_cipher_type cipher;\n\tu8 key_data[32];\n\tu32 val;\n\n\tcipher = mt76_mac_get_key_info(key, key_data);\n\tif (cipher == MT_CIPHER_NONE && key)\n\t\treturn -EINVAL;\n\n\ttrace_set_shared_key(dev, vif_idx, key_idx);\n\n\tmt7601u_wr_copy(dev, MT_SKEY(vif_idx, key_idx),\n\t\t\tkey_data, sizeof(key_data));\n\n\tval = mt76_rr(dev, MT_SKEY_MODE(vif_idx));\n\tval &= ~(MT_SKEY_MODE_MASK << MT_SKEY_MODE_SHIFT(vif_idx, key_idx));\n\tval |= cipher << MT_SKEY_MODE_SHIFT(vif_idx, key_idx);\n\tmt76_wr(dev, MT_SKEY_MODE(vif_idx), val);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}