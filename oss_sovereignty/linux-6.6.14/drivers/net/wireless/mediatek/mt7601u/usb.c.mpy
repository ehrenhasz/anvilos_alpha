{
  "module_name": "usb.c",
  "hash_id": "b5f67a08f7494b703f507e42c45b1b987f2f3ad5e28348643c5d2819938062a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/mediatek/mt7601u/usb.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n\n#include \"mt7601u.h\"\n#include \"usb.h\"\n#include \"trace.h\"\n\nstatic const struct usb_device_id mt7601u_device_table[] = {\n\t{ USB_DEVICE(0x0b05, 0x17d3) },\n\t{ USB_DEVICE(0x0e8d, 0x760a) },\n\t{ USB_DEVICE(0x0e8d, 0x760b) },\n\t{ USB_DEVICE(0x13d3, 0x3431) },\n\t{ USB_DEVICE(0x13d3, 0x3434) },\n\t{ USB_DEVICE(0x148f, 0x7601) },\n\t{ USB_DEVICE(0x148f, 0x760a) },\n\t{ USB_DEVICE(0x148f, 0x760b) },\n\t{ USB_DEVICE(0x148f, 0x760c) },\n\t{ USB_DEVICE(0x148f, 0x760d) },\n\t{ USB_DEVICE(0x2001, 0x3d04) },\n\t{ USB_DEVICE(0x2717, 0x4106) },\n\t{ USB_DEVICE(0x2955, 0x0001) },\n\t{ USB_DEVICE(0x2955, 0x1001) },\n\t{ USB_DEVICE(0x2955, 0x1003) },\n\t{ USB_DEVICE(0x2a5f, 0x1000) },\n\t{ USB_DEVICE(0x7392, 0x7710) },\n\t{ 0, }\n};\n\nbool mt7601u_usb_alloc_buf(struct mt7601u_dev *dev, size_t len,\n\t\t\t   struct mt7601u_dma_buf *buf)\n{\n\tstruct usb_device *usb_dev = mt7601u_to_usb_dev(dev);\n\n\tbuf->len = len;\n\tbuf->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tbuf->buf = usb_alloc_coherent(usb_dev, buf->len, GFP_KERNEL, &buf->dma);\n\n\treturn !buf->urb || !buf->buf;\n}\n\nvoid mt7601u_usb_free_buf(struct mt7601u_dev *dev, struct mt7601u_dma_buf *buf)\n{\n\tstruct usb_device *usb_dev = mt7601u_to_usb_dev(dev);\n\n\tusb_free_coherent(usb_dev, buf->len, buf->buf, buf->dma);\n\tusb_free_urb(buf->urb);\n}\n\nint mt7601u_usb_submit_buf(struct mt7601u_dev *dev, int dir, int ep_idx,\n\t\t\t   struct mt7601u_dma_buf *buf, gfp_t gfp,\n\t\t\t   usb_complete_t complete_fn, void *context)\n{\n\tstruct usb_device *usb_dev = mt7601u_to_usb_dev(dev);\n\tunsigned pipe;\n\tint ret;\n\n\tif (dir == USB_DIR_IN)\n\t\tpipe = usb_rcvbulkpipe(usb_dev, dev->in_eps[ep_idx]);\n\telse\n\t\tpipe = usb_sndbulkpipe(usb_dev, dev->out_eps[ep_idx]);\n\n\tusb_fill_bulk_urb(buf->urb, usb_dev, pipe, buf->buf, buf->len,\n\t\t\t  complete_fn, context);\n\tbuf->urb->transfer_dma = buf->dma;\n\tbuf->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\ttrace_mt_submit_urb(dev, buf->urb);\n\tret = usb_submit_urb(buf->urb, gfp);\n\tif (ret)\n\t\tdev_err(dev->dev, \"Error: submit URB dir:%d ep:%d failed:%d\\n\",\n\t\t\tdir, ep_idx, ret);\n\treturn ret;\n}\n\nvoid mt7601u_complete_urb(struct urb *urb)\n{\n\tstruct completion *cmpl = urb->context;\n\n\tcomplete(cmpl);\n}\n\nint mt7601u_vendor_request(struct mt7601u_dev *dev, const u8 req,\n\t\t\t   const u8 direction, const u16 val, const u16 offset,\n\t\t\t   void *buf, const size_t buflen)\n{\n\tint i, ret;\n\tstruct usb_device *usb_dev = mt7601u_to_usb_dev(dev);\n\tconst u8 req_type = direction | USB_TYPE_VENDOR | USB_RECIP_DEVICE;\n\tconst unsigned int pipe = (direction == USB_DIR_IN) ?\n\t\tusb_rcvctrlpipe(usb_dev, 0) : usb_sndctrlpipe(usb_dev, 0);\n\n\tfor (i = 0; i < MT_VEND_REQ_MAX_RETRY; i++) {\n\t\tret = usb_control_msg(usb_dev, pipe, req, req_type,\n\t\t\t\t      val, offset, buf, buflen,\n\t\t\t\t      MT_VEND_REQ_TOUT_MS);\n\t\ttrace_mt_vend_req(dev, pipe, req, req_type, val, offset,\n\t\t\t\t  buf, buflen, ret);\n\n\t\tif (ret == -ENODEV)\n\t\t\tset_bit(MT7601U_STATE_REMOVED, &dev->state);\n\t\tif (ret >= 0 || ret == -ENODEV)\n\t\t\treturn ret;\n\n\t\tmsleep(5);\n\t}\n\n\tdev_err(dev->dev, \"Vendor request req:%02x off:%04x failed:%d\\n\",\n\t\treq, offset, ret);\n\n\treturn ret;\n}\n\nvoid mt7601u_vendor_reset(struct mt7601u_dev *dev)\n{\n\tmt7601u_vendor_request(dev, MT_VEND_DEV_MODE, USB_DIR_OUT,\n\t\t\t       MT_VEND_DEV_MODE_RESET, 0, NULL, 0);\n}\n\n \nstatic u32 __mt7601u_rr(struct mt7601u_dev *dev, u32 offset)\n{\n\tint ret;\n\tu32 val = ~0;\n\n\tWARN_ONCE(offset > USHRT_MAX, \"read high off:%08x\", offset);\n\n\tret = mt7601u_vendor_request(dev, MT_VEND_MULTI_READ, USB_DIR_IN,\n\t\t\t\t     0, offset, dev->vend_buf, MT_VEND_BUF);\n\tif (ret == MT_VEND_BUF)\n\t\tval = get_unaligned_le32(dev->vend_buf);\n\telse if (ret > 0)\n\t\tdev_err(dev->dev, \"Error: wrong size read:%d off:%08x\\n\",\n\t\t\tret, offset);\n\n\ttrace_reg_read(dev, offset, val);\n\treturn val;\n}\n\nu32 mt7601u_rr(struct mt7601u_dev *dev, u32 offset)\n{\n\tu32 ret;\n\n\tmutex_lock(&dev->vendor_req_mutex);\n\tret = __mt7601u_rr(dev, offset);\n\tmutex_unlock(&dev->vendor_req_mutex);\n\n\treturn ret;\n}\n\n \nstatic int __mt7601u_vendor_single_wr(struct mt7601u_dev *dev, const u8 req,\n\t\t\t\t      const u16 offset, const u32 val)\n{\n\tint ret = mt7601u_vendor_request(dev, req, USB_DIR_OUT,\n\t\t\t\t\t val & 0xffff, offset, NULL, 0);\n\tif (!ret)\n\t\tret = mt7601u_vendor_request(dev, req, USB_DIR_OUT,\n\t\t\t\t\t     val >> 16, offset + 2, NULL, 0);\n\ttrace_reg_write(dev, offset, val);\n\treturn ret;\n}\n\nint mt7601u_vendor_single_wr(struct mt7601u_dev *dev, const u8 req,\n\t\t\t     const u16 offset, const u32 val)\n{\n\tint ret;\n\n\tmutex_lock(&dev->vendor_req_mutex);\n\tret = __mt7601u_vendor_single_wr(dev, req, offset, val);\n\tmutex_unlock(&dev->vendor_req_mutex);\n\n\treturn ret;\n}\n\nvoid mt7601u_wr(struct mt7601u_dev *dev, u32 offset, u32 val)\n{\n\tWARN_ONCE(offset > USHRT_MAX, \"write high off:%08x\", offset);\n\n\tmt7601u_vendor_single_wr(dev, MT_VEND_WRITE, offset, val);\n}\n\nu32 mt7601u_rmw(struct mt7601u_dev *dev, u32 offset, u32 mask, u32 val)\n{\n\tmutex_lock(&dev->vendor_req_mutex);\n\tval |= __mt7601u_rr(dev, offset) & ~mask;\n\t__mt7601u_vendor_single_wr(dev, MT_VEND_WRITE, offset, val);\n\tmutex_unlock(&dev->vendor_req_mutex);\n\n\treturn val;\n}\n\nu32 mt7601u_rmc(struct mt7601u_dev *dev, u32 offset, u32 mask, u32 val)\n{\n\tu32 reg;\n\n\tmutex_lock(&dev->vendor_req_mutex);\n\treg = __mt7601u_rr(dev, offset);\n\tval |= reg & ~mask;\n\tif (reg != val)\n\t\t__mt7601u_vendor_single_wr(dev, MT_VEND_WRITE,\n\t\t\t\t\t   offset, val);\n\tmutex_unlock(&dev->vendor_req_mutex);\n\n\treturn val;\n}\n\nvoid mt7601u_wr_copy(struct mt7601u_dev *dev, u32 offset,\n\t\t     const void *data, int len)\n{\n\tWARN_ONCE(offset & 3, \"unaligned write copy off:%08x\", offset);\n\tWARN_ONCE(len & 3, \"short write copy off:%08x\", offset);\n\n\tmt7601u_burst_write_regs(dev, offset, data, len / 4);\n}\n\nvoid mt7601u_addr_wr(struct mt7601u_dev *dev, const u32 offset, const u8 *addr)\n{\n\tmt7601u_wr(dev, offset, get_unaligned_le32(addr));\n\tmt7601u_wr(dev, offset + 4, addr[4] | addr[5] << 8);\n}\n\nstatic int mt7601u_assign_pipes(struct usb_interface *usb_intf,\n\t\t\t\tstruct mt7601u_dev *dev)\n{\n\tstruct usb_endpoint_descriptor *ep_desc;\n\tstruct usb_host_interface *intf_desc = usb_intf->cur_altsetting;\n\tunsigned i, ep_i = 0, ep_o = 0;\n\n\tBUILD_BUG_ON(sizeof(dev->in_eps) < __MT_EP_IN_MAX);\n\tBUILD_BUG_ON(sizeof(dev->out_eps) < __MT_EP_OUT_MAX);\n\n\tfor (i = 0; i < intf_desc->desc.bNumEndpoints; i++) {\n\t\tep_desc = &intf_desc->endpoint[i].desc;\n\n\t\tif (usb_endpoint_is_bulk_in(ep_desc) &&\n\t\t    ep_i++ < __MT_EP_IN_MAX) {\n\t\t\tdev->in_eps[ep_i - 1] = usb_endpoint_num(ep_desc);\n\t\t\tdev->in_max_packet = usb_endpoint_maxp(ep_desc);\n\t\t\t \n\t\t\tdev->in_eps[ep_i - 1] |= USB_DIR_IN;\n\t\t} else if (usb_endpoint_is_bulk_out(ep_desc) &&\n\t\t\t   ep_o++ < __MT_EP_OUT_MAX) {\n\t\t\tdev->out_eps[ep_o - 1] = usb_endpoint_num(ep_desc);\n\t\t\tdev->out_max_packet = usb_endpoint_maxp(ep_desc);\n\t\t}\n\t}\n\n\tif (ep_i != __MT_EP_IN_MAX || ep_o != __MT_EP_OUT_MAX) {\n\t\tdev_err(dev->dev, \"Error: wrong pipe number in:%d out:%d\\n\",\n\t\t\tep_i, ep_o);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mt7601u_probe(struct usb_interface *usb_intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct usb_device *usb_dev = interface_to_usbdev(usb_intf);\n\tstruct mt7601u_dev *dev;\n\tu32 asic_rev, mac_rev;\n\tint ret;\n\n\tdev = mt7601u_alloc_device(&usb_intf->dev);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tusb_dev = usb_get_dev(usb_dev);\n\tusb_reset_device(usb_dev);\n\n\tusb_set_intfdata(usb_intf, dev);\n\n\tdev->vend_buf = devm_kmalloc(dev->dev, MT_VEND_BUF, GFP_KERNEL);\n\tif (!dev->vend_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = mt7601u_assign_pipes(usb_intf, dev);\n\tif (ret)\n\t\tgoto err;\n\tret = mt7601u_wait_asic_ready(dev);\n\tif (ret)\n\t\tgoto err;\n\n\tasic_rev = mt7601u_rr(dev, MT_ASIC_VERSION);\n\tmac_rev = mt7601u_rr(dev, MT_MAC_CSR0);\n\tdev_info(dev->dev, \"ASIC revision: %08x MAC revision: %08x\\n\",\n\t\t asic_rev, mac_rev);\n\tif ((asic_rev >> 16) != 0x7601) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t \n\tif (!(mt7601u_rr(dev, MT_EFUSE_CTRL) & MT_EFUSE_CTRL_SEL))\n\t\tdev_warn(dev->dev, \"Warning: eFUSE not present\\n\");\n\n\tret = mt7601u_init_hardware(dev);\n\tif (ret)\n\t\tgoto err;\n\tret = mt7601u_register_device(dev);\n\tif (ret)\n\t\tgoto err_hw;\n\n\tset_bit(MT7601U_STATE_INITIALIZED, &dev->state);\n\n\treturn 0;\nerr_hw:\n\tmt7601u_cleanup(dev);\nerr:\n\tusb_set_intfdata(usb_intf, NULL);\n\tusb_put_dev(interface_to_usbdev(usb_intf));\n\n\tdestroy_workqueue(dev->stat_wq);\n\tieee80211_free_hw(dev->hw);\n\treturn ret;\n}\n\nstatic void mt7601u_disconnect(struct usb_interface *usb_intf)\n{\n\tstruct mt7601u_dev *dev = usb_get_intfdata(usb_intf);\n\n\tieee80211_unregister_hw(dev->hw);\n\tmt7601u_cleanup(dev);\n\n\tusb_set_intfdata(usb_intf, NULL);\n\tusb_put_dev(interface_to_usbdev(usb_intf));\n\n\tdestroy_workqueue(dev->stat_wq);\n\tieee80211_free_hw(dev->hw);\n}\n\nstatic int mt7601u_suspend(struct usb_interface *usb_intf, pm_message_t state)\n{\n\tstruct mt7601u_dev *dev = usb_get_intfdata(usb_intf);\n\n\tmt7601u_cleanup(dev);\n\n\treturn 0;\n}\n\nstatic int mt7601u_resume(struct usb_interface *usb_intf)\n{\n\tstruct mt7601u_dev *dev = usb_get_intfdata(usb_intf);\n\tint ret;\n\n\tret = mt7601u_init_hardware(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tset_bit(MT7601U_STATE_INITIALIZED, &dev->state);\n\n\treturn 0;\n}\n\nMODULE_DEVICE_TABLE(usb, mt7601u_device_table);\nMODULE_FIRMWARE(MT7601U_FIRMWARE);\nMODULE_LICENSE(\"GPL\");\n\nstatic struct usb_driver mt7601u_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= mt7601u_device_table,\n\t.probe\t\t= mt7601u_probe,\n\t.disconnect\t= mt7601u_disconnect,\n\t.suspend\t= mt7601u_suspend,\n\t.resume\t\t= mt7601u_resume,\n\t.reset_resume\t= mt7601u_resume,\n\t.soft_unbind\t= 1,\n\t.disable_hub_initiated_lpm = 1,\n};\nmodule_usb_driver(mt7601u_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}