{
  "module_name": "zd_rf_rf2959.c",
  "hash_id": "61762ba03cef99097c5de23be8ede18271d744dd83d299d72fc1025c050d303d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/zydas/zd1211rw/zd_rf_rf2959.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n\n#include \"zd_rf.h\"\n#include \"zd_usb.h\"\n#include \"zd_chip.h\"\n\nstatic const u32 rf2959_table[][2] = {\n\tRF_CHANNEL( 1) = { 0x181979, 0x1e6666 },\n\tRF_CHANNEL( 2) = { 0x181989, 0x1e6666 },\n\tRF_CHANNEL( 3) = { 0x181999, 0x1e6666 },\n\tRF_CHANNEL( 4) = { 0x1819a9, 0x1e6666 },\n\tRF_CHANNEL( 5) = { 0x1819b9, 0x1e6666 },\n\tRF_CHANNEL( 6) = { 0x1819c9, 0x1e6666 },\n\tRF_CHANNEL( 7) = { 0x1819d9, 0x1e6666 },\n\tRF_CHANNEL( 8) = { 0x1819e9, 0x1e6666 },\n\tRF_CHANNEL( 9) = { 0x1819f9, 0x1e6666 },\n\tRF_CHANNEL(10) = { 0x181a09, 0x1e6666 },\n\tRF_CHANNEL(11) = { 0x181a19, 0x1e6666 },\n\tRF_CHANNEL(12) = { 0x181a29, 0x1e6666 },\n\tRF_CHANNEL(13) = { 0x181a39, 0x1e6666 },\n\tRF_CHANNEL(14) = { 0x181a60, 0x1c0000 },\n};\n\n#if 0\nstatic int bits(u32 rw, int from, int to)\n{\n\trw &= ~(0xffffffffU << (to+1));\n\trw >>= from;\n\treturn rw;\n}\n\nstatic int bit(u32 rw, int bit)\n{\n\treturn bits(rw, bit, bit);\n}\n\nstatic void dump_regwrite(u32 rw)\n{\n\tint reg = bits(rw, 18, 22);\n\tint rw_flag = bits(rw, 23, 23);\n\tPDEBUG(\"rf2959 %#010x reg %d rw %d\", rw, reg, rw_flag);\n\n\tswitch (reg) {\n\tcase 0:\n\t\tPDEBUG(\"reg0 CFG1 ref_sel %d hibernate %d rf_vco_reg_en %d\"\n\t\t       \" if_vco_reg_en %d if_vga_en %d\",\n\t\t       bits(rw, 14, 15), bit(rw, 3), bit(rw, 2), bit(rw, 1),\n\t\t       bit(rw, 0));\n\t\tbreak;\n\tcase 1:\n\t\tPDEBUG(\"reg1 IFPLL1 pll_en1 %d kv_en1 %d vtc_en1 %d lpf1 %d\"\n\t\t       \" cpl1 %d pdp1 %d autocal_en1 %d ld_en1 %d ifloopr %d\"\n\t\t       \" ifloopc %d dac1 %d\",\n\t\t       bit(rw, 17), bit(rw, 16), bit(rw, 15), bit(rw, 14),\n\t\t       bit(rw, 13), bit(rw, 12), bit(rw, 11), bit(rw, 10),\n\t\t       bits(rw, 7, 9), bits(rw, 4, 6), bits(rw, 0, 3));\n\t\tbreak;\n\tcase 2:\n\t\tPDEBUG(\"reg2 IFPLL2 n1 %d num1 %d\",\n\t\t       bits(rw, 6, 17), bits(rw, 0, 5));\n\t\tbreak;\n\tcase 3:\n\t\tPDEBUG(\"reg3 IFPLL3 num %d\", bits(rw, 0, 17));\n\t\tbreak;\n\tcase 4:\n\t\tPDEBUG(\"reg4 IFPLL4 dn1 %#04x ct_def1 %d kv_def1 %d\",\n\t\t       bits(rw, 8, 16), bits(rw, 4, 7), bits(rw, 0, 3));\n\t\tbreak;\n\tcase 5:\n\t\tPDEBUG(\"reg5 RFPLL1 pll_en %d kv_en %d vtc_en %d lpf %d cpl %d\"\n\t\t       \" pdp %d autocal_en %d ld_en %d rfloopr %d rfloopc %d\"\n\t\t       \" dac %d\",\n\t\t       bit(rw, 17), bit(rw, 16), bit(rw, 15), bit(rw, 14),\n\t\t       bit(rw, 13), bit(rw, 12), bit(rw, 11), bit(rw, 10),\n\t\t       bits(rw, 7, 9), bits(rw, 4, 6), bits(rw, 0,3));\n\t\tbreak;\n\tcase 6:\n\t\tPDEBUG(\"reg6 RFPLL2 n %d num %d\",\n\t\t       bits(rw, 6, 17), bits(rw, 0, 5));\n\t\tbreak;\n\tcase 7:\n\t\tPDEBUG(\"reg7 RFPLL3 num2 %d\", bits(rw, 0, 17));\n\t\tbreak;\n\tcase 8:\n\t\tPDEBUG(\"reg8 RFPLL4 dn %#06x ct_def %d kv_def %d\",\n\t\t       bits(rw, 8, 16), bits(rw, 4, 7), bits(rw, 0, 3));\n\t\tbreak;\n\tcase 9:\n\t\tPDEBUG(\"reg9 CAL1 tvco %d tlock %d m_ct_value %d ld_window %d\",\n\t\t       bits(rw, 13, 17), bits(rw, 8, 12), bits(rw, 3, 7),\n\t\t       bits(rw, 0, 2));\n\t\tbreak;\n\tcase 10:\n\t\tPDEBUG(\"reg10 TXRX1 rxdcfbbyps %d pcontrol %d txvgc %d\"\n\t\t       \" rxlpfbw %d txlpfbw %d txdiffmode %d txenmode %d\"\n\t\t       \" intbiasen %d tybypass %d\",\n\t\t       bit(rw, 17), bits(rw, 15, 16), bits(rw, 10, 14),\n\t\t       bits(rw, 7, 9), bits(rw, 4, 6), bit(rw, 3), bit(rw, 2),\n\t\t       bit(rw, 1), bit(rw, 0));\n\t\tbreak;\n\tcase 11:\n\t\tPDEBUG(\"reg11 PCNT1 mid_bias %d p_desired %d pc_offset %d\"\n\t\t\t\" tx_delay %d\",\n\t\t\tbits(rw, 15, 17), bits(rw, 9, 14), bits(rw, 3, 8),\n\t\t\tbits(rw, 0, 2));\n\t\tbreak;\n\tcase 12:\n\t\tPDEBUG(\"reg12 PCNT2 max_power %d mid_power %d min_power %d\",\n\t\t       bits(rw, 12, 17), bits(rw, 6, 11), bits(rw, 0, 5));\n\t\tbreak;\n\tcase 13:\n\t\tPDEBUG(\"reg13 VCOT1 rfpll vco comp %d ifpll vco comp %d\"\n\t\t       \" lobias %d if_biasbuf %d if_biasvco %d rf_biasbuf %d\"\n\t\t       \" rf_biasvco %d\",\n\t\t       bit(rw, 17), bit(rw, 16), bit(rw, 15),\n\t\t       bits(rw, 8, 9), bits(rw, 5, 7), bits(rw, 3, 4),\n\t\t       bits(rw, 0, 2));\n\t\tbreak;\n\tcase 14:\n\t\tPDEBUG(\"reg14 IQCAL rx_acal %d rx_pcal %d\"\n\t\t       \" tx_acal %d tx_pcal %d\",\n\t\t       bits(rw, 13, 17), bits(rw, 9, 12), bits(rw, 4, 8),\n\t\t       bits(rw, 0, 3));\n\t\tbreak;\n\t}\n}\n#endif  \n\nstatic int rf2959_init_hw(struct zd_rf *rf)\n{\n\tint r;\n\tstruct zd_chip *chip = zd_rf_to_chip(rf);\n\n\tstatic const struct zd_ioreq16 ioreqs[] = {\n\t\t{ ZD_CR2,   0x1E }, { ZD_CR9,   0x20 }, { ZD_CR10,  0x89 },\n\t\t{ ZD_CR11,  0x00 }, { ZD_CR15,  0xD0 }, { ZD_CR17,  0x68 },\n\t\t{ ZD_CR19,  0x4a }, { ZD_CR20,  0x0c }, { ZD_CR21,  0x0E },\n\t\t{ ZD_CR23,  0x48 },\n\t\t \n\t\t{ ZD_CR24,  0x14 },\n\t\t \n\t\t{ ZD_CR26,  0x90 }, { ZD_CR27,  0x30 }, { ZD_CR29,  0x20 },\n\t\t{ ZD_CR31,  0xb2 }, { ZD_CR32,  0x43 }, { ZD_CR33,  0x28 },\n\t\t{ ZD_CR38,  0x30 }, { ZD_CR34,  0x0f }, { ZD_CR35,  0xF0 },\n\t\t{ ZD_CR41,  0x2a }, { ZD_CR46,  0x7F }, { ZD_CR47,  0x1E },\n\t\t{ ZD_CR51,  0xc5 }, { ZD_CR52,  0xc5 }, { ZD_CR53,  0xc5 },\n\t\t{ ZD_CR79,  0x58 }, { ZD_CR80,  0x30 }, { ZD_CR81,  0x30 },\n\t\t{ ZD_CR82,  0x00 }, { ZD_CR83,  0x24 }, { ZD_CR84,  0x04 },\n\t\t{ ZD_CR85,  0x00 }, { ZD_CR86,  0x10 }, { ZD_CR87,  0x2A },\n\t\t{ ZD_CR88,  0x10 }, { ZD_CR89,  0x24 }, { ZD_CR90,  0x18 },\n\t\t \n\t\t \n\t\t{ ZD_CR91,  0x00 },\n\t\t{ ZD_CR92,  0x0a }, { ZD_CR93,  0x00 }, { ZD_CR94,  0x01 },\n\t\t{ ZD_CR95,  0x00 }, { ZD_CR96,  0x40 }, { ZD_CR97,  0x37 },\n\t\t{ ZD_CR98,  0x05 }, { ZD_CR99,  0x28 }, { ZD_CR100, 0x00 },\n\t\t{ ZD_CR101, 0x13 }, { ZD_CR102, 0x27 }, { ZD_CR103, 0x27 },\n\t\t{ ZD_CR104, 0x18 }, { ZD_CR105, 0x12 },\n\t\t \n\t\t{ ZD_CR106, 0x1a },\n\t\t \n\t\t{ ZD_CR107, 0x24 }, { ZD_CR108, 0x0a }, { ZD_CR109, 0x13 },\n\t\t{ ZD_CR110, 0x2F }, { ZD_CR111, 0x27 }, { ZD_CR112, 0x27 },\n\t\t{ ZD_CR113, 0x27 }, { ZD_CR114, 0x27 }, { ZD_CR115, 0x40 },\n\t\t{ ZD_CR116, 0x40 }, { ZD_CR117, 0xF0 }, { ZD_CR118, 0xF0 },\n\t\t{ ZD_CR119, 0x16 },\n\t\t \n\t\t{ ZD_CR122, 0x00 },\n\t\t \n\t\t{ ZD_CR127, 0x03 }, { ZD_CR131, 0x08 }, { ZD_CR138, 0x28 },\n\t\t{ ZD_CR148, 0x44 }, { ZD_CR150, 0x10 }, { ZD_CR169, 0xBB },\n\t\t{ ZD_CR170, 0xBB },\n\t};\n\n\tstatic const u32 rv[] = {\n\t\t0x000007,   \n\t\t0x07dd43,   \n\t\t0x080959,   \n\t\t0x0e6666,\n\t\t0x116a57,   \n\t\t0x17dd43,   \n\t\t0x1819f9,   \n\t\t0x1e6666,\n\t\t0x214554,\n\t\t0x25e7fa,\n\t\t0x27fffa,\n\t\t \n\t\t0x294128,  \n\t\t   \n\t\t \n\t\t0x2c0000,\n\t\t0x300000,\n\t\t0x340000,   \n\t\t0x381e0f,   \n\t\t \n\t\t0x6c180f,   \n\t};\n\n\tr = zd_iowrite16a_locked(chip, ioreqs, ARRAY_SIZE(ioreqs));\n\tif (r)\n\t\treturn r;\n\n\treturn zd_rfwritev_locked(chip, rv, ARRAY_SIZE(rv), RF_RV_BITS);\n}\n\nstatic int rf2959_set_channel(struct zd_rf *rf, u8 channel)\n{\n\tint i, r;\n\tconst u32 *rv = rf2959_table[channel-1];\n\tstruct zd_chip *chip = zd_rf_to_chip(rf);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tr = zd_rfwrite_locked(chip, rv[i], RF_RV_BITS);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}\n\nstatic int rf2959_switch_radio_on(struct zd_rf *rf)\n{\n\tstatic const struct zd_ioreq16 ioreqs[] = {\n\t\t{ ZD_CR10, 0x89 },\n\t\t{ ZD_CR11, 0x00 },\n\t};\n\tstruct zd_chip *chip = zd_rf_to_chip(rf);\n\n\treturn zd_iowrite16a_locked(chip, ioreqs, ARRAY_SIZE(ioreqs));\n}\n\nstatic int rf2959_switch_radio_off(struct zd_rf *rf)\n{\n\tstatic const struct zd_ioreq16 ioreqs[] = {\n\t\t{ ZD_CR10, 0x15 },\n\t\t{ ZD_CR11, 0x81 },\n\t};\n\tstruct zd_chip *chip = zd_rf_to_chip(rf);\n\n\treturn zd_iowrite16a_locked(chip, ioreqs, ARRAY_SIZE(ioreqs));\n}\n\nint zd_rf_init_rf2959(struct zd_rf *rf)\n{\n\tstruct zd_chip *chip = zd_rf_to_chip(rf);\n\n\tif (zd_chip_is_zd1211b(chip)) {\n\t\tdev_err(zd_chip_dev(chip),\n\t\t       \"RF2959 is currently not supported for ZD1211B\"\n\t\t       \" devices\\n\");\n\t\treturn -ENODEV;\n\t}\n\trf->init_hw = rf2959_init_hw;\n\trf->set_channel = rf2959_set_channel;\n\trf->switch_radio_on = rf2959_switch_radio_on;\n\trf->switch_radio_off = rf2959_switch_radio_off;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}