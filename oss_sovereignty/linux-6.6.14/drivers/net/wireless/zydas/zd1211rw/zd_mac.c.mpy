{
  "module_name": "zd_mac.c",
  "hash_id": "008a8b983986b5dcd6f47b4fd8c4a13f963b5a932b5b9b069b9ab2983e0518e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/zydas/zd1211rw/zd_mac.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/jiffies.h>\n#include <net/ieee80211_radiotap.h>\n\n#include \"zd_def.h\"\n#include \"zd_chip.h\"\n#include \"zd_mac.h\"\n#include \"zd_rf.h\"\n\nstruct zd_reg_alpha2_map {\n\tu32 reg;\n\tchar alpha2[2];\n};\n\nstatic struct zd_reg_alpha2_map reg_alpha2_map[] = {\n\t{ ZD_REGDOMAIN_FCC, \"US\" },\n\t{ ZD_REGDOMAIN_IC, \"CA\" },\n\t{ ZD_REGDOMAIN_ETSI, \"DE\" },  \n\t{ ZD_REGDOMAIN_JAPAN, \"JP\" },\n\t{ ZD_REGDOMAIN_JAPAN_2, \"JP\" },\n\t{ ZD_REGDOMAIN_JAPAN_3, \"JP\" },\n\t{ ZD_REGDOMAIN_SPAIN, \"ES\" },\n\t{ ZD_REGDOMAIN_FRANCE, \"FR\" },\n};\n\n \nstatic const struct ieee80211_rate zd_rates[] = {\n\t{ .bitrate = 10,\n\t  .hw_value = ZD_CCK_RATE_1M, },\n\t{ .bitrate = 20,\n\t  .hw_value = ZD_CCK_RATE_2M,\n\t  .hw_value_short = ZD_CCK_RATE_2M | ZD_CCK_PREA_SHORT,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 55,\n\t  .hw_value = ZD_CCK_RATE_5_5M,\n\t  .hw_value_short = ZD_CCK_RATE_5_5M | ZD_CCK_PREA_SHORT,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 110,\n\t  .hw_value = ZD_CCK_RATE_11M,\n\t  .hw_value_short = ZD_CCK_RATE_11M | ZD_CCK_PREA_SHORT,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 60,\n\t  .hw_value = ZD_OFDM_RATE_6M,\n\t  .flags = 0 },\n\t{ .bitrate = 90,\n\t  .hw_value = ZD_OFDM_RATE_9M,\n\t  .flags = 0 },\n\t{ .bitrate = 120,\n\t  .hw_value = ZD_OFDM_RATE_12M,\n\t  .flags = 0 },\n\t{ .bitrate = 180,\n\t  .hw_value = ZD_OFDM_RATE_18M,\n\t  .flags = 0 },\n\t{ .bitrate = 240,\n\t  .hw_value = ZD_OFDM_RATE_24M,\n\t  .flags = 0 },\n\t{ .bitrate = 360,\n\t  .hw_value = ZD_OFDM_RATE_36M,\n\t  .flags = 0 },\n\t{ .bitrate = 480,\n\t  .hw_value = ZD_OFDM_RATE_48M,\n\t  .flags = 0 },\n\t{ .bitrate = 540,\n\t  .hw_value = ZD_OFDM_RATE_54M,\n\t  .flags = 0 },\n};\n\n \n\nstatic const struct tx_retry_rate zd_retry_rates[] = {\n\t{  \t1, { 0 }},\n\t{  \t2, { 1,  0 }},\n\t{  \t3, { 2,  1, 0 }},\n\t{  \t4, { 3,  2, 1, 0 }},\n\t{  \t5, { 4,  3, 2, 1, 0 }},\n\t{  \t6, { 5,  4, 3, 2, 1, 0}},\n\t{  \t5, { 6,  3, 2, 1, 0 }},\n\t{  \t6, { 7,  6, 3, 2, 1, 0 }},\n\t{  \t6, { 8,  6, 3, 2, 1, 0 }},\n\t{  \t7, { 9,  8, 6, 3, 2, 1, 0 }},\n\t{  \t8, {10,  9, 8, 6, 3, 2, 1, 0 }},\n\t{  \t9, {11, 10, 9, 8, 6, 3, 2, 1, 0 }}\n};\n\nstatic const struct ieee80211_channel zd_channels[] = {\n\t{ .center_freq = 2412, .hw_value = 1 },\n\t{ .center_freq = 2417, .hw_value = 2 },\n\t{ .center_freq = 2422, .hw_value = 3 },\n\t{ .center_freq = 2427, .hw_value = 4 },\n\t{ .center_freq = 2432, .hw_value = 5 },\n\t{ .center_freq = 2437, .hw_value = 6 },\n\t{ .center_freq = 2442, .hw_value = 7 },\n\t{ .center_freq = 2447, .hw_value = 8 },\n\t{ .center_freq = 2452, .hw_value = 9 },\n\t{ .center_freq = 2457, .hw_value = 10 },\n\t{ .center_freq = 2462, .hw_value = 11 },\n\t{ .center_freq = 2467, .hw_value = 12 },\n\t{ .center_freq = 2472, .hw_value = 13 },\n\t{ .center_freq = 2484, .hw_value = 14 },\n};\n\nstatic void housekeeping_init(struct zd_mac *mac);\nstatic void housekeeping_enable(struct zd_mac *mac);\nstatic void housekeeping_disable(struct zd_mac *mac);\nstatic void beacon_init(struct zd_mac *mac);\nstatic void beacon_enable(struct zd_mac *mac);\nstatic void beacon_disable(struct zd_mac *mac);\nstatic void set_rts_cts(struct zd_mac *mac, unsigned int short_preamble);\nstatic int zd_mac_config_beacon(struct ieee80211_hw *hw,\n\t\t\t\tstruct sk_buff *beacon, bool in_intr);\n\nstatic int zd_reg2alpha2(u8 regdomain, char *alpha2)\n{\n\tunsigned int i;\n\tstruct zd_reg_alpha2_map *reg_map;\n\tfor (i = 0; i < ARRAY_SIZE(reg_alpha2_map); i++) {\n\t\treg_map = &reg_alpha2_map[i];\n\t\tif (regdomain == reg_map->reg) {\n\t\t\talpha2[0] = reg_map->alpha2[0];\n\t\t\talpha2[1] = reg_map->alpha2[1];\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int zd_check_signal(struct ieee80211_hw *hw, int signal)\n{\n\tstruct zd_mac *mac = zd_hw_mac(hw);\n\n\tdev_dbg_f_cond(zd_mac_dev(mac), signal < 0 || signal > 100,\n\t\t\t\"%s: signal value from device not in range 0..100, \"\n\t\t\t\"but %d.\\n\", __func__, signal);\n\n\tif (signal < 0)\n\t\tsignal = 0;\n\telse if (signal > 100)\n\t\tsignal = 100;\n\n\treturn signal;\n}\n\nint zd_mac_preinit_hw(struct ieee80211_hw *hw)\n{\n\tint r;\n\tu8 addr[ETH_ALEN];\n\tstruct zd_mac *mac = zd_hw_mac(hw);\n\n\tr = zd_chip_read_mac_addr_fw(&mac->chip, addr);\n\tif (r)\n\t\treturn r;\n\n\tSET_IEEE80211_PERM_ADDR(hw, addr);\n\n\treturn 0;\n}\n\nint zd_mac_init_hw(struct ieee80211_hw *hw)\n{\n\tint r;\n\tstruct zd_mac *mac = zd_hw_mac(hw);\n\tstruct zd_chip *chip = &mac->chip;\n\tchar alpha2[2];\n\tu8 default_regdomain;\n\n\tr = zd_chip_enable_int(chip);\n\tif (r)\n\t\tgoto out;\n\tr = zd_chip_init_hw(chip);\n\tif (r)\n\t\tgoto disable_int;\n\n\tZD_ASSERT(!irqs_disabled());\n\n\tr = zd_read_regdomain(chip, &default_regdomain);\n\tif (r)\n\t\tgoto disable_int;\n\tspin_lock_irq(&mac->lock);\n\tmac->regdomain = mac->default_regdomain = default_regdomain;\n\tspin_unlock_irq(&mac->lock);\n\n\t \n\tr = zd_set_encryption_type(chip, ENC_SNIFFER);\n\tif (r)\n\t\tgoto disable_int;\n\n\tr = zd_reg2alpha2(mac->regdomain, alpha2);\n\tif (r)\n\t\tgoto disable_int;\n\n\tr = regulatory_hint(hw->wiphy, alpha2);\ndisable_int:\n\tzd_chip_disable_int(chip);\nout:\n\treturn r;\n}\n\nvoid zd_mac_clear(struct zd_mac *mac)\n{\n\tflush_workqueue(zd_workqueue);\n\tzd_chip_clear(&mac->chip);\n\tZD_MEMCLEAR(mac, sizeof(struct zd_mac));\n}\n\nstatic int set_rx_filter(struct zd_mac *mac)\n{\n\tunsigned long flags;\n\tu32 filter = STA_RX_FILTER;\n\n\tspin_lock_irqsave(&mac->lock, flags);\n\tif (mac->pass_ctrl)\n\t\tfilter |= RX_FILTER_CTRL;\n\tspin_unlock_irqrestore(&mac->lock, flags);\n\n\treturn zd_iowrite32(&mac->chip, CR_RX_FILTER, filter);\n}\n\nstatic int set_mac_and_bssid(struct zd_mac *mac)\n{\n\tint r;\n\n\tif (!mac->vif)\n\t\treturn -1;\n\n\tr = zd_write_mac_addr(&mac->chip, mac->vif->addr);\n\tif (r)\n\t\treturn r;\n\n\t \n\tif (mac->type != NL80211_IFTYPE_AP)\n\t\treturn set_rx_filter(mac);\n\telse\n\t\treturn zd_write_bssid(&mac->chip, mac->vif->addr);\n}\n\nstatic int set_mc_hash(struct zd_mac *mac)\n{\n\tstruct zd_mc_hash hash;\n\tzd_mc_clear(&hash);\n\treturn zd_chip_set_multicast_hash(&mac->chip, &hash);\n}\n\nint zd_op_start(struct ieee80211_hw *hw)\n{\n\tstruct zd_mac *mac = zd_hw_mac(hw);\n\tstruct zd_chip *chip = &mac->chip;\n\tstruct zd_usb *usb = &chip->usb;\n\tint r;\n\n\tif (!usb->initialized) {\n\t\tr = zd_usb_init_hw(usb);\n\t\tif (r)\n\t\t\tgoto out;\n\t}\n\n\tr = zd_chip_enable_int(chip);\n\tif (r < 0)\n\t\tgoto out;\n\n\tr = zd_chip_set_basic_rates(chip, CR_RATES_80211B | CR_RATES_80211G);\n\tif (r < 0)\n\t\tgoto disable_int;\n\tr = set_rx_filter(mac);\n\tif (r)\n\t\tgoto disable_int;\n\tr = set_mc_hash(mac);\n\tif (r)\n\t\tgoto disable_int;\n\n\t \n\tmsleep(10);\n\n\tr = zd_chip_switch_radio_on(chip);\n\tif (r < 0) {\n\t\tdev_err(zd_chip_dev(chip),\n\t\t\t\"%s: failed to set radio on\\n\", __func__);\n\t\tgoto disable_int;\n\t}\n\tr = zd_chip_enable_rxtx(chip);\n\tif (r < 0)\n\t\tgoto disable_radio;\n\tr = zd_chip_enable_hwint(chip);\n\tif (r < 0)\n\t\tgoto disable_rxtx;\n\n\thousekeeping_enable(mac);\n\tbeacon_enable(mac);\n\tset_bit(ZD_DEVICE_RUNNING, &mac->flags);\n\treturn 0;\ndisable_rxtx:\n\tzd_chip_disable_rxtx(chip);\ndisable_radio:\n\tzd_chip_switch_radio_off(chip);\ndisable_int:\n\tzd_chip_disable_int(chip);\nout:\n\treturn r;\n}\n\nvoid zd_op_stop(struct ieee80211_hw *hw)\n{\n\tstruct zd_mac *mac = zd_hw_mac(hw);\n\tstruct zd_chip *chip = &mac->chip;\n\tstruct sk_buff *skb;\n\tstruct sk_buff_head *ack_wait_queue = &mac->ack_wait_queue;\n\n\tclear_bit(ZD_DEVICE_RUNNING, &mac->flags);\n\n\t \n\n\tzd_chip_disable_rxtx(chip);\n\tbeacon_disable(mac);\n\thousekeeping_disable(mac);\n\tflush_workqueue(zd_workqueue);\n\n\tzd_chip_disable_hwint(chip);\n\tzd_chip_switch_radio_off(chip);\n\tzd_chip_disable_int(chip);\n\n\n\twhile ((skb = skb_dequeue(ack_wait_queue)))\n\t\tdev_kfree_skb_any(skb);\n}\n\nint zd_restore_settings(struct zd_mac *mac)\n{\n\tstruct sk_buff *beacon;\n\tstruct zd_mc_hash multicast_hash;\n\tunsigned int short_preamble;\n\tint r, beacon_interval, beacon_period;\n\tu8 channel;\n\n\tdev_dbg_f(zd_mac_dev(mac), \"\\n\");\n\n\tspin_lock_irq(&mac->lock);\n\tmulticast_hash = mac->multicast_hash;\n\tshort_preamble = mac->short_preamble;\n\tbeacon_interval = mac->beacon.interval;\n\tbeacon_period = mac->beacon.period;\n\tchannel = mac->channel;\n\tspin_unlock_irq(&mac->lock);\n\n\tr = set_mac_and_bssid(mac);\n\tif (r < 0) {\n\t\tdev_dbg_f(zd_mac_dev(mac), \"set_mac_and_bssid failed, %d\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = zd_chip_set_channel(&mac->chip, channel);\n\tif (r < 0) {\n\t\tdev_dbg_f(zd_mac_dev(mac), \"zd_chip_set_channel failed, %d\\n\",\n\t\t\t  r);\n\t\treturn r;\n\t}\n\n\tset_rts_cts(mac, short_preamble);\n\n\tr = zd_chip_set_multicast_hash(&mac->chip, &multicast_hash);\n\tif (r < 0) {\n\t\tdev_dbg_f(zd_mac_dev(mac),\n\t\t\t  \"zd_chip_set_multicast_hash failed, %d\\n\", r);\n\t\treturn r;\n\t}\n\n\tif (mac->type == NL80211_IFTYPE_MESH_POINT ||\n\t    mac->type == NL80211_IFTYPE_ADHOC ||\n\t    mac->type == NL80211_IFTYPE_AP) {\n\t\tif (mac->vif != NULL) {\n\t\t\tbeacon = ieee80211_beacon_get(mac->hw, mac->vif, 0);\n\t\t\tif (beacon)\n\t\t\t\tzd_mac_config_beacon(mac->hw, beacon, false);\n\t\t}\n\n\t\tzd_set_beacon_interval(&mac->chip, beacon_interval,\n\t\t\t\t\tbeacon_period, mac->type);\n\n\t\tspin_lock_irq(&mac->lock);\n\t\tmac->beacon.last_update = jiffies;\n\t\tspin_unlock_irq(&mac->lock);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void zd_mac_tx_status(struct ieee80211_hw *hw, struct sk_buff *skb,\n\t\t      int ackssi, struct tx_status *tx_status)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tint i;\n\tint success = 1, retry = 1;\n\tint first_idx;\n\tconst struct tx_retry_rate *retries;\n\n\tieee80211_tx_info_clear_status(info);\n\n\tif (tx_status) {\n\t\tsuccess = !tx_status->failure;\n\t\tretry = tx_status->retry + success;\n\t}\n\n\tif (success) {\n\t\t \n\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\t} else {\n\t\t \n\t\tinfo->flags &= ~IEEE80211_TX_STAT_ACK;\n\t}\n\n\tfirst_idx = info->status.rates[0].idx;\n\tZD_ASSERT(0<=first_idx && first_idx<ARRAY_SIZE(zd_retry_rates));\n\tretries = &zd_retry_rates[first_idx];\n\tZD_ASSERT(1 <= retry && retry <= retries->count);\n\n\tinfo->status.rates[0].idx = retries->rate[0];\n\tinfo->status.rates[0].count = 1;  \n\n\tfor (i=1; i<IEEE80211_TX_MAX_RATES-1 && i<retry; i++) {\n\t\tinfo->status.rates[i].idx = retries->rate[i];\n\t\tinfo->status.rates[i].count = 1;  \n\t}\n\tfor (; i<IEEE80211_TX_MAX_RATES && i<retry; i++) {\n\t\tinfo->status.rates[i].idx = retries->rate[retry - 1];\n\t\tinfo->status.rates[i].count = 1;  \n\t}\n\tif (i<IEEE80211_TX_MAX_RATES)\n\t\tinfo->status.rates[i].idx = -1;  \n\n\tinfo->status.ack_signal = zd_check_signal(hw, ackssi);\n\tieee80211_tx_status_irqsafe(hw, skb);\n}\n\n \nvoid zd_mac_tx_failed(struct urb *urb)\n{\n\tstruct ieee80211_hw * hw = zd_usb_to_hw(urb->context);\n\tstruct zd_mac *mac = zd_hw_mac(hw);\n\tstruct sk_buff_head *q = &mac->ack_wait_queue;\n\tstruct sk_buff *skb;\n\tstruct tx_status *tx_status = (struct tx_status *)urb->transfer_buffer;\n\tunsigned long flags;\n\tint success = !tx_status->failure;\n\tint retry = tx_status->retry + success;\n\tint found = 0;\n\tint i, position = 0;\n\n\tspin_lock_irqsave(&q->lock, flags);\n\n\tskb_queue_walk(q, skb) {\n\t\tstruct ieee80211_hdr *tx_hdr;\n\t\tstruct ieee80211_tx_info *info;\n\t\tint first_idx, final_idx;\n\t\tconst struct tx_retry_rate *retries;\n\t\tu8 final_rate;\n\n\t\tposition ++;\n\n\t\t \n\t\tif (tx_status->failure && mac->ack_pending &&\n\t\t    skb_queue_is_first(q, skb)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\ttx_hdr = (struct ieee80211_hdr *)skb->data;\n\n\t\t \n\t\tif (unlikely(!ether_addr_equal(tx_hdr->addr1, tx_status->mac)))\n\t\t\tcontinue;\n\n\t\t \n\n\t\tinfo = IEEE80211_SKB_CB(skb);\n\t\tfirst_idx = info->status.rates[0].idx;\n\t\tZD_ASSERT(0<=first_idx && first_idx<ARRAY_SIZE(zd_retry_rates));\n\t\tretries = &zd_retry_rates[first_idx];\n\t\tif (retry <= 0 || retry > retries->count)\n\t\t\tcontinue;\n\n\t\tfinal_idx = retries->rate[retry - 1];\n\t\tfinal_rate = zd_rates[final_idx].hw_value;\n\n\t\tif (final_rate != tx_status->rate) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tfound = 1;\n\t\tbreak;\n\t}\n\n\tif (found) {\n\t\tfor (i=1; i<=position; i++) {\n\t\t\tskb = __skb_dequeue(q);\n\t\t\tzd_mac_tx_status(hw, skb,\n\t\t\t\t\t mac->ack_pending ? mac->ack_signal : 0,\n\t\t\t\t\t i == position ? tx_status : NULL);\n\t\t\tmac->ack_pending = 0;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&q->lock, flags);\n}\n\n \nvoid zd_mac_tx_to_dev(struct sk_buff *skb, int error)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hw *hw = info->rate_driver_data[0];\n\tstruct zd_mac *mac = zd_hw_mac(hw);\n\n\tieee80211_tx_info_clear_status(info);\n\n\tskb_pull(skb, sizeof(struct zd_ctrlset));\n\tif (unlikely(error ||\n\t    (info->flags & IEEE80211_TX_CTL_NO_ACK))) {\n\t\t \n\t\tieee80211_tx_status_irqsafe(hw, skb);\n\t} else {\n\t\tstruct sk_buff_head *q = &mac->ack_wait_queue;\n\n\t\tskb_queue_tail(q, skb);\n\t\twhile (skb_queue_len(q) > ZD_MAC_MAX_ACK_WAITERS) {\n\t\t\tzd_mac_tx_status(hw, skb_dequeue(q),\n\t\t\t\t\t mac->ack_pending ? mac->ack_signal : 0,\n\t\t\t\t\t NULL);\n\t\t\tmac->ack_pending = 0;\n\t\t}\n\t}\n}\n\nstatic int zd_calc_tx_length_us(u8 *service, u8 zd_rate, u16 tx_length)\n{\n\t \n\tstatic const u8 rate_divisor[] = {\n\t\t[ZD_PURE_RATE(ZD_CCK_RATE_1M)]   =  1,\n\t\t[ZD_PURE_RATE(ZD_CCK_RATE_2M)]\t =  2,\n\t\t \n\t\t[ZD_PURE_RATE(ZD_CCK_RATE_5_5M)] = 11,\n\t\t[ZD_PURE_RATE(ZD_CCK_RATE_11M)]\t = 11,\n\t\t[ZD_PURE_RATE(ZD_OFDM_RATE_6M)]  =  6,\n\t\t[ZD_PURE_RATE(ZD_OFDM_RATE_9M)]  =  9,\n\t\t[ZD_PURE_RATE(ZD_OFDM_RATE_12M)] = 12,\n\t\t[ZD_PURE_RATE(ZD_OFDM_RATE_18M)] = 18,\n\t\t[ZD_PURE_RATE(ZD_OFDM_RATE_24M)] = 24,\n\t\t[ZD_PURE_RATE(ZD_OFDM_RATE_36M)] = 36,\n\t\t[ZD_PURE_RATE(ZD_OFDM_RATE_48M)] = 48,\n\t\t[ZD_PURE_RATE(ZD_OFDM_RATE_54M)] = 54,\n\t};\n\n\tu32 bits = (u32)tx_length * 8;\n\tu32 divisor;\n\n\tdivisor = rate_divisor[ZD_PURE_RATE(zd_rate)];\n\tif (divisor == 0)\n\t\treturn -EINVAL;\n\n\tswitch (zd_rate) {\n\tcase ZD_CCK_RATE_5_5M:\n\t\tbits = (2*bits) + 10;  \n\t\tbreak;\n\tcase ZD_CCK_RATE_11M:\n\t\tif (service) {\n\t\t\tu32 t = bits % 11;\n\t\t\t*service &= ~ZD_PLCP_SERVICE_LENGTH_EXTENSION;\n\t\t\tif (0 < t && t <= 3) {\n\t\t\t\t*service |= ZD_PLCP_SERVICE_LENGTH_EXTENSION;\n\t\t\t}\n\t\t}\n\t\tbits += 10;  \n\t\tbreak;\n\t}\n\n\treturn bits/divisor;\n}\n\nstatic void cs_set_control(struct zd_mac *mac, struct zd_ctrlset *cs,\n\t                   struct ieee80211_hdr *header,\n\t                   struct ieee80211_tx_info *info)\n{\n\t \n\n\tcs->control = 0;\n\n\t \n\tif (info->flags & IEEE80211_TX_CTL_FIRST_FRAGMENT)\n\t\tcs->control |= ZD_CS_NEED_RANDOM_BACKOFF;\n\n\t \n\tif (info->flags & IEEE80211_TX_CTL_NO_ACK)\n\t\tcs->control |= ZD_CS_NO_ACK;\n\n\t \n\tif (ieee80211_is_pspoll(header->frame_control))\n\t\tcs->control |= ZD_CS_PS_POLL_FRAME;\n\n\tif (info->control.rates[0].flags & IEEE80211_TX_RC_USE_RTS_CTS)\n\t\tcs->control |= ZD_CS_RTS;\n\n\tif (info->control.rates[0].flags & IEEE80211_TX_RC_USE_CTS_PROTECT)\n\t\tcs->control |= ZD_CS_SELF_CTS;\n\n\t \n}\n\nstatic bool zd_mac_match_cur_beacon(struct zd_mac *mac, struct sk_buff *beacon)\n{\n\tif (!mac->beacon.cur_beacon)\n\t\treturn false;\n\n\tif (mac->beacon.cur_beacon->len != beacon->len)\n\t\treturn false;\n\n\treturn !memcmp(beacon->data, mac->beacon.cur_beacon->data, beacon->len);\n}\n\nstatic void zd_mac_free_cur_beacon_locked(struct zd_mac *mac)\n{\n\tZD_ASSERT(mutex_is_locked(&mac->chip.mutex));\n\n\tkfree_skb(mac->beacon.cur_beacon);\n\tmac->beacon.cur_beacon = NULL;\n}\n\nstatic void zd_mac_free_cur_beacon(struct zd_mac *mac)\n{\n\tmutex_lock(&mac->chip.mutex);\n\tzd_mac_free_cur_beacon_locked(mac);\n\tmutex_unlock(&mac->chip.mutex);\n}\n\nstatic int zd_mac_config_beacon(struct ieee80211_hw *hw, struct sk_buff *beacon,\n\t\t\t\tbool in_intr)\n{\n\tstruct zd_mac *mac = zd_hw_mac(hw);\n\tint r, ret, num_cmds, req_pos = 0;\n\tu32 tmp, j = 0;\n\t \n\tu32 full_len = beacon->len + 4;\n\tunsigned long end_jiffies, message_jiffies;\n\tstruct zd_ioreq32 *ioreqs;\n\n\tmutex_lock(&mac->chip.mutex);\n\n\t \n\tif (zd_mac_match_cur_beacon(mac, beacon)) {\n\t\tr = 0;\n\t\tgoto out_nofree;\n\t}\n\n\t \n\tnum_cmds = 1 + zd_chip_is_zd1211b(&mac->chip) + full_len;\n\tioreqs = kmalloc_array(num_cmds, sizeof(struct zd_ioreq32),\n\t\t\t       GFP_KERNEL);\n\tif (!ioreqs) {\n\t\tr = -ENOMEM;\n\t\tgoto out_nofree;\n\t}\n\n\tr = zd_iowrite32_locked(&mac->chip, 0, CR_BCN_FIFO_SEMAPHORE);\n\tif (r < 0)\n\t\tgoto out;\n\tr = zd_ioread32_locked(&mac->chip, &tmp, CR_BCN_FIFO_SEMAPHORE);\n\tif (r < 0)\n\t\tgoto release_sema;\n\tif (in_intr && tmp & 0x2) {\n\t\tr = -EBUSY;\n\t\tgoto release_sema;\n\t}\n\n\tend_jiffies = jiffies + HZ / 2;  \n\tmessage_jiffies = jiffies + HZ / 10;  \n\twhile (tmp & 0x2) {\n\t\tr = zd_ioread32_locked(&mac->chip, &tmp, CR_BCN_FIFO_SEMAPHORE);\n\t\tif (r < 0)\n\t\t\tgoto release_sema;\n\t\tif (time_is_before_eq_jiffies(message_jiffies)) {\n\t\t\tmessage_jiffies = jiffies + HZ / 10;\n\t\t\tdev_err(zd_mac_dev(mac),\n\t\t\t\t\t\"CR_BCN_FIFO_SEMAPHORE not ready\\n\");\n\t\t\tif (time_is_before_eq_jiffies(end_jiffies))  {\n\t\t\t\tdev_err(zd_mac_dev(mac),\n\t\t\t\t\t\t\"Giving up beacon config.\\n\");\n\t\t\t\tr = -ETIMEDOUT;\n\t\t\t\tgoto reset_device;\n\t\t\t}\n\t\t}\n\t\tmsleep(20);\n\t}\n\n\tioreqs[req_pos].addr = CR_BCN_FIFO;\n\tioreqs[req_pos].value = full_len - 1;\n\treq_pos++;\n\tif (zd_chip_is_zd1211b(&mac->chip)) {\n\t\tioreqs[req_pos].addr = CR_BCN_LENGTH;\n\t\tioreqs[req_pos].value = full_len - 1;\n\t\treq_pos++;\n\t}\n\n\tfor (j = 0 ; j < beacon->len; j++) {\n\t\tioreqs[req_pos].addr = CR_BCN_FIFO;\n\t\tioreqs[req_pos].value = *((u8 *)(beacon->data + j));\n\t\treq_pos++;\n\t}\n\n\tfor (j = 0; j < 4; j++) {\n\t\tioreqs[req_pos].addr = CR_BCN_FIFO;\n\t\tioreqs[req_pos].value = 0x0;\n\t\treq_pos++;\n\t}\n\n\tBUG_ON(req_pos != num_cmds);\n\n\tr = zd_iowrite32a_locked(&mac->chip, ioreqs, num_cmds);\n\nrelease_sema:\n\t \n\tend_jiffies = jiffies + HZ / 2;  \n\tret = zd_iowrite32_locked(&mac->chip, 1, CR_BCN_FIFO_SEMAPHORE);\n\twhile (ret < 0) {\n\t\tif (in_intr || time_is_before_eq_jiffies(end_jiffies)) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(20);\n\t\tret = zd_iowrite32_locked(&mac->chip, 1, CR_BCN_FIFO_SEMAPHORE);\n\t}\n\n\tif (ret < 0)\n\t\tdev_err(zd_mac_dev(mac), \"Could not release \"\n\t\t\t\t\t \"CR_BCN_FIFO_SEMAPHORE!\\n\");\n\tif (r < 0 || ret < 0) {\n\t\tif (r >= 0)\n\t\t\tr = ret;\n\n\t\t \n\t\tzd_mac_free_cur_beacon_locked(mac);\n\n\t\tgoto out;\n\t}\n\n\t \n\tzd_mac_free_cur_beacon_locked(mac);\n\tmac->beacon.cur_beacon = beacon;\n\tbeacon = NULL;\n\n\t \n\tr = zd_iowrite32_locked(&mac->chip, 0x00000400 | (full_len << 19),\n\t\t\t\tCR_BCN_PLCP_CFG);\nout:\n\tkfree(ioreqs);\nout_nofree:\n\tkfree_skb(beacon);\n\tmutex_unlock(&mac->chip.mutex);\n\n\treturn r;\n\nreset_device:\n\tzd_mac_free_cur_beacon_locked(mac);\n\tkfree_skb(beacon);\n\n\tmutex_unlock(&mac->chip.mutex);\n\tkfree(ioreqs);\n\n\t \n\tdev_warn(zd_mac_dev(mac), \"CR_BCN_FIFO_SEMAPHORE stuck, \"\n\t\t\t\t  \"resetting device...\");\n\tusb_queue_reset_device(mac->chip.usb.intf);\n\n\treturn r;\n}\n\nstatic int fill_ctrlset(struct zd_mac *mac,\n\t\t\tstruct sk_buff *skb)\n{\n\tint r;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tunsigned int frag_len = skb->len + FCS_LEN;\n\tunsigned int packet_length;\n\tstruct ieee80211_rate *txrate;\n\tstruct zd_ctrlset *cs = skb_push(skb, sizeof(struct zd_ctrlset));\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\n\tZD_ASSERT(frag_len <= 0xffff);\n\n\t \n\tif (!ieee80211_is_pspoll(hdr->frame_control))\n\t\thdr->duration_id = 0;\n\n\ttxrate = ieee80211_get_tx_rate(mac->hw, info);\n\n\tcs->modulation = txrate->hw_value;\n\tif (info->control.rates[0].flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE)\n\t\tcs->modulation = txrate->hw_value_short;\n\n\tcs->tx_length = cpu_to_le16(frag_len);\n\n\tcs_set_control(mac, cs, hdr, info);\n\n\tpacket_length = frag_len + sizeof(struct zd_ctrlset) + 10;\n\tZD_ASSERT(packet_length <= 0xffff);\n\t \n\tcs->packet_length = cpu_to_le16(zd_chip_is_zd1211b(&mac->chip) ?\n\t\t\tpacket_length - frag_len : packet_length);\n\n\t \n\tcs->service = 0;\n\tr = zd_calc_tx_length_us(&cs->service, ZD_RATE(cs->modulation),\n\t\t                 le16_to_cpu(cs->tx_length));\n\tif (r < 0)\n\t\treturn r;\n\tcs->current_length = cpu_to_le16(r);\n\tcs->next_frame_length = 0;\n\n\treturn 0;\n}\n\n \nstatic void zd_op_tx(struct ieee80211_hw *hw,\n\t\t     struct ieee80211_tx_control *control,\n\t\t     struct sk_buff *skb)\n{\n\tstruct zd_mac *mac = zd_hw_mac(hw);\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tint r;\n\n\tr = fill_ctrlset(mac, skb);\n\tif (r)\n\t\tgoto fail;\n\n\tinfo->rate_driver_data[0] = hw;\n\n\tr = zd_usb_tx(&mac->chip.usb, skb);\n\tif (r)\n\t\tgoto fail;\n\treturn;\n\nfail:\n\tdev_kfree_skb(skb);\n}\n\n \nstatic int filter_ack(struct ieee80211_hw *hw, struct ieee80211_hdr *rx_hdr,\n\t\t      struct ieee80211_rx_status *stats)\n{\n\tstruct zd_mac *mac = zd_hw_mac(hw);\n\tstruct sk_buff *skb;\n\tstruct sk_buff_head *q;\n\tunsigned long flags;\n\tint found = 0;\n\tint i, position = 0;\n\n\tif (!ieee80211_is_ack(rx_hdr->frame_control))\n\t\treturn 0;\n\n\tq = &mac->ack_wait_queue;\n\tspin_lock_irqsave(&q->lock, flags);\n\tskb_queue_walk(q, skb) {\n\t\tstruct ieee80211_hdr *tx_hdr;\n\n\t\tposition ++;\n\n\t\tif (mac->ack_pending && skb_queue_is_first(q, skb))\n\t\t    continue;\n\n\t\ttx_hdr = (struct ieee80211_hdr *)skb->data;\n\t\tif (likely(ether_addr_equal(tx_hdr->addr2, rx_hdr->addr1)))\n\t\t{\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tfor (i=1; i<position; i++) {\n\t\t\tskb = __skb_dequeue(q);\n\t\t\tzd_mac_tx_status(hw, skb,\n\t\t\t\t\t mac->ack_pending ? mac->ack_signal : 0,\n\t\t\t\t\t NULL);\n\t\t\tmac->ack_pending = 0;\n\t\t}\n\n\t\tmac->ack_pending = 1;\n\t\tmac->ack_signal = stats->signal;\n\n\t\t \n\t\tif (mac->type == NL80211_IFTYPE_AP) {\n\t\t\tskb = __skb_dequeue(q);\n\t\t\tzd_mac_tx_status(hw, skb, mac->ack_signal, NULL);\n\t\t\tmac->ack_pending = 0;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&q->lock, flags);\n\treturn 1;\n}\n\nint zd_mac_rx(struct ieee80211_hw *hw, const u8 *buffer, unsigned int length)\n{\n\tstruct zd_mac *mac = zd_hw_mac(hw);\n\tstruct ieee80211_rx_status stats;\n\tconst struct rx_status *status;\n\tstruct sk_buff *skb;\n\tint bad_frame = 0;\n\t__le16 fc;\n\tint need_padding;\n\tint i;\n\tu8 rate;\n\n\tif (length < ZD_PLCP_HEADER_SIZE + 10   +\n\t             FCS_LEN + sizeof(struct rx_status))\n\t\treturn -EINVAL;\n\n\tmemset(&stats, 0, sizeof(stats));\n\n\t \n\n\t \n\tstatus = (struct rx_status *)\n\t\t(buffer + (length - sizeof(struct rx_status)));\n\tif (status->frame_status & ZD_RX_ERROR) {\n\t\tif (mac->pass_failed_fcs &&\n\t\t\t\t(status->frame_status & ZD_RX_CRC32_ERROR)) {\n\t\t\tstats.flag |= RX_FLAG_FAILED_FCS_CRC;\n\t\t\tbad_frame = 1;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tstats.freq = zd_channels[_zd_chip_get_channel(&mac->chip) - 1].center_freq;\n\tstats.band = NL80211_BAND_2GHZ;\n\tstats.signal = zd_check_signal(hw, status->signal_strength);\n\n\trate = zd_rx_rate(buffer, status);\n\n\t \n\tfor (i = 0; i < mac->band.n_bitrates; i++)\n\t\tif (rate == mac->band.bitrates[i].hw_value)\n\t\t\tstats.rate_idx = i;\n\n\tlength -= ZD_PLCP_HEADER_SIZE + sizeof(struct rx_status);\n\tbuffer += ZD_PLCP_HEADER_SIZE;\n\n\t \n\tif (!bad_frame &&\n\t\t\tfilter_ack(hw, (struct ieee80211_hdr *)buffer, &stats)\n\t\t\t&& !mac->pass_ctrl)\n\t\treturn 0;\n\n\tfc = get_unaligned((__le16*)buffer);\n\tneed_padding = ieee80211_is_data_qos(fc) ^ ieee80211_has_a4(fc);\n\n\tskb = dev_alloc_skb(length + (need_padding ? 2 : 0));\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\tif (need_padding) {\n\t\t \n\t\tskb_reserve(skb, 2);\n\t}\n\n\t \n\tskb_put_data(skb, buffer, length);\n\n\tmemcpy(IEEE80211_SKB_RXCB(skb), &stats, sizeof(stats));\n\tieee80211_rx_irqsafe(hw, skb);\n\treturn 0;\n}\n\nstatic int zd_op_add_interface(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct zd_mac *mac = zd_hw_mac(hw);\n\n\t \n\tif (mac->type != NL80211_IFTYPE_UNSPECIFIED)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_AP:\n\t\tmac->type = vif->type;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmac->vif = vif;\n\n\treturn set_mac_and_bssid(mac);\n}\n\nstatic void zd_op_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct zd_mac *mac = zd_hw_mac(hw);\n\tmac->type = NL80211_IFTYPE_UNSPECIFIED;\n\tmac->vif = NULL;\n\tzd_set_beacon_interval(&mac->chip, 0, 0, NL80211_IFTYPE_UNSPECIFIED);\n\tzd_write_mac_addr(&mac->chip, NULL);\n\n\tzd_mac_free_cur_beacon(mac);\n}\n\nstatic int zd_op_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct zd_mac *mac = zd_hw_mac(hw);\n\tstruct ieee80211_conf *conf = &hw->conf;\n\n\tspin_lock_irq(&mac->lock);\n\tmac->channel = conf->chandef.chan->hw_value;\n\tspin_unlock_irq(&mac->lock);\n\n\treturn zd_chip_set_channel(&mac->chip, conf->chandef.chan->hw_value);\n}\n\nstatic void zd_beacon_done(struct zd_mac *mac)\n{\n\tstruct sk_buff *skb, *beacon;\n\n\tif (!test_bit(ZD_DEVICE_RUNNING, &mac->flags))\n\t\treturn;\n\tif (!mac->vif || mac->vif->type != NL80211_IFTYPE_AP)\n\t\treturn;\n\n\t \n\twhile (!ieee80211_queue_stopped(mac->hw, 0)) {\n\t\tskb = ieee80211_get_buffered_bc(mac->hw, mac->vif);\n\t\tif (!skb)\n\t\t\tbreak;\n\t\tzd_op_tx(mac->hw, NULL, skb);\n\t}\n\n\t \n\tbeacon = ieee80211_beacon_get(mac->hw, mac->vif, 0);\n\tif (beacon)\n\t\tzd_mac_config_beacon(mac->hw, beacon, true);\n\n\tspin_lock_irq(&mac->lock);\n\tmac->beacon.last_update = jiffies;\n\tspin_unlock_irq(&mac->lock);\n}\n\nstatic void zd_process_intr(struct work_struct *work)\n{\n\tu16 int_status;\n\tunsigned long flags;\n\tstruct zd_mac *mac = container_of(work, struct zd_mac, process_intr);\n\n\tspin_lock_irqsave(&mac->lock, flags);\n\tint_status = le16_to_cpu(*(__le16 *)(mac->intr_buffer + 4));\n\tspin_unlock_irqrestore(&mac->lock, flags);\n\n\tif (int_status & INT_CFG_NEXT_BCN) {\n\t\t \n\t\tzd_beacon_done(mac);\n\t} else {\n\t\tdev_dbg_f(zd_mac_dev(mac), \"Unsupported interrupt\\n\");\n\t}\n\n\tzd_chip_enable_hwint(&mac->chip);\n}\n\n\nstatic u64 zd_op_prepare_multicast(struct ieee80211_hw *hw,\n\t\t\t\t   struct netdev_hw_addr_list *mc_list)\n{\n\tstruct zd_mac *mac = zd_hw_mac(hw);\n\tstruct zd_mc_hash hash;\n\tstruct netdev_hw_addr *ha;\n\n\tzd_mc_clear(&hash);\n\n\tnetdev_hw_addr_list_for_each(ha, mc_list) {\n\t\tdev_dbg_f(zd_mac_dev(mac), \"mc addr %pM\\n\", ha->addr);\n\t\tzd_mc_add_addr(&hash, ha->addr);\n\t}\n\n\treturn hash.low | ((u64)hash.high << 32);\n}\n\n#define SUPPORTED_FIF_FLAGS \\\n\t(FIF_ALLMULTI | FIF_FCSFAIL | FIF_CONTROL | \\\n\tFIF_OTHER_BSS | FIF_BCN_PRBRESP_PROMISC)\nstatic void zd_op_configure_filter(struct ieee80211_hw *hw,\n\t\t\tunsigned int changed_flags,\n\t\t\tunsigned int *new_flags,\n\t\t\tu64 multicast)\n{\n\tstruct zd_mc_hash hash = {\n\t\t.low = multicast,\n\t\t.high = multicast >> 32,\n\t};\n\tstruct zd_mac *mac = zd_hw_mac(hw);\n\tunsigned long flags;\n\tint r;\n\n\t \n\tchanged_flags &= SUPPORTED_FIF_FLAGS;\n\t*new_flags &= SUPPORTED_FIF_FLAGS;\n\n\t \n\tif (*new_flags & FIF_ALLMULTI)\n\t\tzd_mc_add_all(&hash);\n\n\tspin_lock_irqsave(&mac->lock, flags);\n\tmac->pass_failed_fcs = !!(*new_flags & FIF_FCSFAIL);\n\tmac->pass_ctrl = !!(*new_flags & FIF_CONTROL);\n\tmac->multicast_hash = hash;\n\tspin_unlock_irqrestore(&mac->lock, flags);\n\n\tzd_chip_set_multicast_hash(&mac->chip, &hash);\n\n\tif (changed_flags & FIF_CONTROL) {\n\t\tr = set_rx_filter(mac);\n\t\tif (r)\n\t\t\tdev_err(zd_mac_dev(mac), \"set_rx_filter error %d\\n\", r);\n\t}\n\n\t \n\t \n}\n\nstatic void set_rts_cts(struct zd_mac *mac, unsigned int short_preamble)\n{\n\tmutex_lock(&mac->chip.mutex);\n\tzd_chip_set_rts_cts_rate_locked(&mac->chip, short_preamble);\n\tmutex_unlock(&mac->chip.mutex);\n}\n\nstatic void zd_op_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_bss_conf *bss_conf,\n\t\t\t\t   u64 changes)\n{\n\tstruct zd_mac *mac = zd_hw_mac(hw);\n\tint associated;\n\n\tdev_dbg_f(zd_mac_dev(mac), \"changes: %llx\\n\", changes);\n\n\tif (mac->type == NL80211_IFTYPE_MESH_POINT ||\n\t    mac->type == NL80211_IFTYPE_ADHOC ||\n\t    mac->type == NL80211_IFTYPE_AP) {\n\t\tassociated = true;\n\t\tif (changes & BSS_CHANGED_BEACON) {\n\t\t\tstruct sk_buff *beacon = ieee80211_beacon_get(hw, vif,\n\t\t\t\t\t\t\t\t      0);\n\n\t\t\tif (beacon) {\n\t\t\t\tzd_chip_disable_hwint(&mac->chip);\n\t\t\t\tzd_mac_config_beacon(hw, beacon, false);\n\t\t\t\tzd_chip_enable_hwint(&mac->chip);\n\t\t\t}\n\t\t}\n\n\t\tif (changes & BSS_CHANGED_BEACON_ENABLED) {\n\t\t\tu16 interval = 0;\n\t\t\tu8 period = 0;\n\n\t\t\tif (bss_conf->enable_beacon) {\n\t\t\t\tperiod = bss_conf->dtim_period;\n\t\t\t\tinterval = bss_conf->beacon_int;\n\t\t\t}\n\n\t\t\tspin_lock_irq(&mac->lock);\n\t\t\tmac->beacon.period = period;\n\t\t\tmac->beacon.interval = interval;\n\t\t\tmac->beacon.last_update = jiffies;\n\t\t\tspin_unlock_irq(&mac->lock);\n\n\t\t\tzd_set_beacon_interval(&mac->chip, interval, period,\n\t\t\t\t\t       mac->type);\n\t\t}\n\t} else\n\t\tassociated = is_valid_ether_addr(bss_conf->bssid);\n\n\tspin_lock_irq(&mac->lock);\n\tmac->associated = associated;\n\tspin_unlock_irq(&mac->lock);\n\n\t \n\n\tif (changes & BSS_CHANGED_ERP_PREAMBLE) {\n\t\tspin_lock_irq(&mac->lock);\n\t\tmac->short_preamble = bss_conf->use_short_preamble;\n\t\tspin_unlock_irq(&mac->lock);\n\n\t\tset_rts_cts(mac, bss_conf->use_short_preamble);\n\t}\n}\n\nstatic u64 zd_op_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct zd_mac *mac = zd_hw_mac(hw);\n\treturn zd_chip_get_tsf(&mac->chip);\n}\n\nstatic const struct ieee80211_ops zd_ops = {\n\t.tx\t\t\t= zd_op_tx,\n\t.wake_tx_queue\t\t= ieee80211_handle_wake_tx_queue,\n\t.start\t\t\t= zd_op_start,\n\t.stop\t\t\t= zd_op_stop,\n\t.add_interface\t\t= zd_op_add_interface,\n\t.remove_interface\t= zd_op_remove_interface,\n\t.config\t\t\t= zd_op_config,\n\t.prepare_multicast\t= zd_op_prepare_multicast,\n\t.configure_filter\t= zd_op_configure_filter,\n\t.bss_info_changed\t= zd_op_bss_info_changed,\n\t.get_tsf\t\t= zd_op_get_tsf,\n};\n\nstruct ieee80211_hw *zd_mac_alloc_hw(struct usb_interface *intf)\n{\n\tstruct zd_mac *mac;\n\tstruct ieee80211_hw *hw;\n\n\thw = ieee80211_alloc_hw(sizeof(struct zd_mac), &zd_ops);\n\tif (!hw) {\n\t\tdev_dbg_f(&intf->dev, \"out of memory\\n\");\n\t\treturn NULL;\n\t}\n\n\tmac = zd_hw_mac(hw);\n\n\tmemset(mac, 0, sizeof(*mac));\n\tspin_lock_init(&mac->lock);\n\tmac->hw = hw;\n\n\tmac->type = NL80211_IFTYPE_UNSPECIFIED;\n\n\tmemcpy(mac->channels, zd_channels, sizeof(zd_channels));\n\tmemcpy(mac->rates, zd_rates, sizeof(zd_rates));\n\tmac->band.n_bitrates = ARRAY_SIZE(zd_rates);\n\tmac->band.bitrates = mac->rates;\n\tmac->band.n_channels = ARRAY_SIZE(zd_channels);\n\tmac->band.channels = mac->channels;\n\n\thw->wiphy->bands[NL80211_BAND_2GHZ] = &mac->band;\n\n\tieee80211_hw_set(hw, MFP_CAPABLE);\n\tieee80211_hw_set(hw, HOST_BROADCAST_PS_BUFFERING);\n\tieee80211_hw_set(hw, RX_INCLUDES_FCS);\n\tieee80211_hw_set(hw, SIGNAL_UNSPEC);\n\n\thw->wiphy->interface_modes =\n\t\tBIT(NL80211_IFTYPE_MESH_POINT) |\n\t\tBIT(NL80211_IFTYPE_STATION) |\n\t\tBIT(NL80211_IFTYPE_ADHOC) |\n\t\tBIT(NL80211_IFTYPE_AP);\n\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\thw->max_signal = 100;\n\thw->queues = 1;\n\thw->extra_tx_headroom = sizeof(struct zd_ctrlset);\n\n\t \n\thw->max_rates = IEEE80211_TX_MAX_RATES;\n\thw->max_rate_tries = 18;\t \n\n\tskb_queue_head_init(&mac->ack_wait_queue);\n\tmac->ack_pending = 0;\n\n\tzd_chip_init(&mac->chip, hw, intf);\n\thousekeeping_init(mac);\n\tbeacon_init(mac);\n\tINIT_WORK(&mac->process_intr, zd_process_intr);\n\n\tSET_IEEE80211_DEV(hw, &intf->dev);\n\treturn hw;\n}\n\n#define BEACON_WATCHDOG_DELAY round_jiffies_relative(HZ)\n\nstatic void beacon_watchdog_handler(struct work_struct *work)\n{\n\tstruct zd_mac *mac =\n\t\tcontainer_of(work, struct zd_mac, beacon.watchdog_work.work);\n\tstruct sk_buff *beacon;\n\tunsigned long timeout;\n\tint interval, period;\n\n\tif (!test_bit(ZD_DEVICE_RUNNING, &mac->flags))\n\t\tgoto rearm;\n\tif (mac->type != NL80211_IFTYPE_AP || !mac->vif)\n\t\tgoto rearm;\n\n\tspin_lock_irq(&mac->lock);\n\tinterval = mac->beacon.interval;\n\tperiod = mac->beacon.period;\n\ttimeout = mac->beacon.last_update +\n\t\t\tmsecs_to_jiffies(interval * 1024 / 1000) * 3;\n\tspin_unlock_irq(&mac->lock);\n\n\tif (interval > 0 && time_is_before_jiffies(timeout)) {\n\t\tdev_dbg_f(zd_mac_dev(mac), \"beacon interrupt stalled, \"\n\t\t\t\t\t   \"restarting. \"\n\t\t\t\t\t   \"(interval: %d, dtim: %d)\\n\",\n\t\t\t\t\t   interval, period);\n\n\t\tzd_chip_disable_hwint(&mac->chip);\n\n\t\tbeacon = ieee80211_beacon_get(mac->hw, mac->vif, 0);\n\t\tif (beacon) {\n\t\t\tzd_mac_free_cur_beacon(mac);\n\n\t\t\tzd_mac_config_beacon(mac->hw, beacon, false);\n\t\t}\n\n\t\tzd_set_beacon_interval(&mac->chip, interval, period, mac->type);\n\n\t\tzd_chip_enable_hwint(&mac->chip);\n\n\t\tspin_lock_irq(&mac->lock);\n\t\tmac->beacon.last_update = jiffies;\n\t\tspin_unlock_irq(&mac->lock);\n\t}\n\nrearm:\n\tqueue_delayed_work(zd_workqueue, &mac->beacon.watchdog_work,\n\t\t\t   BEACON_WATCHDOG_DELAY);\n}\n\nstatic void beacon_init(struct zd_mac *mac)\n{\n\tINIT_DELAYED_WORK(&mac->beacon.watchdog_work, beacon_watchdog_handler);\n}\n\nstatic void beacon_enable(struct zd_mac *mac)\n{\n\tdev_dbg_f(zd_mac_dev(mac), \"\\n\");\n\n\tmac->beacon.last_update = jiffies;\n\tqueue_delayed_work(zd_workqueue, &mac->beacon.watchdog_work,\n\t\t\t   BEACON_WATCHDOG_DELAY);\n}\n\nstatic void beacon_disable(struct zd_mac *mac)\n{\n\tdev_dbg_f(zd_mac_dev(mac), \"\\n\");\n\tcancel_delayed_work_sync(&mac->beacon.watchdog_work);\n\n\tzd_mac_free_cur_beacon(mac);\n}\n\n#define LINK_LED_WORK_DELAY HZ\n\nstatic void link_led_handler(struct work_struct *work)\n{\n\tstruct zd_mac *mac =\n\t\tcontainer_of(work, struct zd_mac, housekeeping.link_led_work.work);\n\tstruct zd_chip *chip = &mac->chip;\n\tint is_associated;\n\tint r;\n\n\tif (!test_bit(ZD_DEVICE_RUNNING, &mac->flags))\n\t\tgoto requeue;\n\n\tspin_lock_irq(&mac->lock);\n\tis_associated = mac->associated;\n\tspin_unlock_irq(&mac->lock);\n\n\tr = zd_chip_control_leds(chip,\n\t\t                 is_associated ? ZD_LED_ASSOCIATED : ZD_LED_SCANNING);\n\tif (r)\n\t\tdev_dbg_f(zd_mac_dev(mac), \"zd_chip_control_leds error %d\\n\", r);\n\nrequeue:\n\tqueue_delayed_work(zd_workqueue, &mac->housekeeping.link_led_work,\n\t\t           LINK_LED_WORK_DELAY);\n}\n\nstatic void housekeeping_init(struct zd_mac *mac)\n{\n\tINIT_DELAYED_WORK(&mac->housekeeping.link_led_work, link_led_handler);\n}\n\nstatic void housekeeping_enable(struct zd_mac *mac)\n{\n\tdev_dbg_f(zd_mac_dev(mac), \"\\n\");\n\tqueue_delayed_work(zd_workqueue, &mac->housekeeping.link_led_work,\n\t\t\t   0);\n}\n\nstatic void housekeeping_disable(struct zd_mac *mac)\n{\n\tdev_dbg_f(zd_mac_dev(mac), \"\\n\");\n\tcancel_delayed_work_sync(&mac->housekeeping.link_led_work);\n\tzd_chip_control_leds(&mac->chip, ZD_LED_OFF);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}