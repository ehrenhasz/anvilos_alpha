{
  "module_name": "zd_usb.h",
  "hash_id": "b48db20f90771b0e60b36ec23c2147440b4eb6cc66f32701f71dcfb97f5e98fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/zydas/zd1211rw/zd_usb.h",
  "human_readable_source": " \n \n\n#ifndef _ZD_USB_H\n#define _ZD_USB_H\n\n#include <linux/completion.h>\n#include <linux/netdevice.h>\n#include <linux/spinlock.h>\n#include <linux/skbuff.h>\n#include <linux/usb.h>\n\n#include \"zd_def.h\"\n\n#define ZD_USB_TX_HIGH  5\n#define ZD_USB_TX_LOW   2\n\n#define ZD_TX_TIMEOUT\t\t(HZ * 5)\n#define ZD_TX_WATCHDOG_INTERVAL\tround_jiffies_relative(HZ)\n#define ZD_RX_IDLE_INTERVAL\tround_jiffies_relative(30 * HZ)\n\nenum devicetype {\n\tDEVICE_ZD1211  = 0,\n\tDEVICE_ZD1211B = 1,\n\tDEVICE_INSTALLER = 2,\n};\n\nenum endpoints {\n\tEP_CTRL\t    = 0,\n\tEP_DATA_OUT = 1,\n\tEP_DATA_IN  = 2,\n\tEP_INT_IN   = 3,\n\tEP_REGS_OUT = 4,\n};\n\nenum {\n\tUSB_MAX_TRANSFER_SIZE\t\t= 4096,  \n\t \n\tUSB_MAX_RX_SIZE\t\t\t= 4800,  \n\tUSB_MAX_IOWRITE16_COUNT\t\t= 15,\n\tUSB_MAX_IOWRITE32_COUNT\t\t= USB_MAX_IOWRITE16_COUNT/2,\n\tUSB_MAX_IOREAD16_COUNT\t\t= 15,\n\tUSB_MAX_IOREAD32_COUNT\t\t= USB_MAX_IOREAD16_COUNT/2,\n\tUSB_MIN_RFWRITE_BIT_COUNT\t= 16,\n\tUSB_MAX_RFWRITE_BIT_COUNT\t= 28,\n\tUSB_MAX_EP_INT_BUFFER\t\t= 64,\n\tUSB_ZD1211B_BCD_DEVICE\t\t= 0x4810,\n};\n\nenum control_requests {\n\tUSB_REQ_WRITE_REGS\t\t= 0x21,\n\tUSB_REQ_READ_REGS\t\t= 0x22,\n\tUSB_REQ_WRITE_RF\t\t= 0x23,\n\tUSB_REQ_PROG_FLASH\t\t= 0x24,\n\tUSB_REQ_EEPROM_START\t\t= 0x0128,  \n\tUSB_REQ_EEPROM_MID\t\t= 0x28,\n\tUSB_REQ_EEPROM_END\t\t= 0x0228,  \n\tUSB_REQ_FIRMWARE_DOWNLOAD\t= 0x30,\n\tUSB_REQ_FIRMWARE_CONFIRM\t= 0x31,\n\tUSB_REQ_FIRMWARE_READ_DATA\t= 0x32,\n};\n\nstruct usb_req_read_regs {\n\t__le16 id;\n\t__le16 addr[];\n} __packed;\n\nstruct reg_data {\n\t__le16 addr;\n\t__le16 value;\n} __packed;\n\nstruct usb_req_write_regs {\n\t__le16 id;\n\tstruct reg_data reg_writes[];\n} __packed;\n\nenum {\n\tRF_IF_LE = 0x02,\n\tRF_CLK   = 0x04,\n\tRF_DATA\t = 0x08,\n};\n\nstruct usb_req_rfwrite {\n\t__le16 id;\n\t__le16 value;\n\t \n\t \n\t__le16 bits;\n\t \n\t__le16 bit_values[];\n\t \n} __packed;\n\n \n\nenum usb_int_id {\n\tUSB_INT_TYPE\t\t\t= 0x01,\n\tUSB_INT_ID_REGS\t\t\t= 0x90,\n\tUSB_INT_ID_RETRY_FAILED\t\t= 0xa0,\n};\n\nenum usb_int_flags {\n\tUSB_INT_READ_REGS_EN\t\t= 0x01,\n};\n\nstruct usb_int_header {\n\tu8 type;\t \n\tu8 id;\n} __packed;\n\nstruct usb_int_regs {\n\tstruct usb_int_header hdr;\n\tstruct reg_data regs[];\n} __packed;\n\nstruct usb_int_retry_fail {\n\tstruct usb_int_header hdr;\n\tu8 new_rate;\n\tu8 _dummy;\n\tu8 addr[ETH_ALEN];\n\tu8 ibss_wakeup_dest;\n} __packed;\n\nstruct read_regs_int {\n\tstruct completion completion;\n\tstruct usb_req_read_regs *req;\n\tunsigned int req_count;\n\t \n\tu8 buffer[USB_MAX_EP_INT_BUFFER];\n\tint length;\n\t__le16 cr_int_addr;\n};\n\nstruct zd_ioreq16 {\n\tzd_addr_t addr;\n\tu16 value;\n};\n\nstruct zd_ioreq32 {\n\tzd_addr_t addr;\n\tu32 value;\n};\n\nstruct zd_usb_interrupt {\n\tstruct read_regs_int read_regs;\n\tspinlock_t lock;\n\tstruct urb *urb;\n\tvoid *buffer;\n\tdma_addr_t buffer_dma;\n\tint interval;\n\tatomic_t read_regs_enabled;\n\tu8 read_regs_int_overridden:1;\n};\n\nstatic inline struct usb_int_regs *get_read_regs(struct zd_usb_interrupt *intr)\n{\n\treturn (struct usb_int_regs *)intr->read_regs.buffer;\n}\n\n#define RX_URBS_COUNT 5\n\nstruct zd_usb_rx {\n\tspinlock_t lock;\n\tstruct mutex setup_mutex;\n\tstruct delayed_work idle_work;\n\tstruct tasklet_struct reset_timer_tasklet;\n\tu8 fragment[2 * USB_MAX_RX_SIZE];\n\tunsigned int fragment_length;\n\tunsigned int usb_packet_size;\n\tstruct urb **urbs;\n\tint urbs_count;\n};\n\n \nstruct zd_usb_tx {\n\tatomic_t enabled;\n\tspinlock_t lock;\n\tstruct delayed_work watchdog_work;\n\tstruct sk_buff_head submitted_skbs;\n\tstruct usb_anchor submitted;\n\tint submitted_urbs;\n\tu8 stopped:1, watchdog_enabled:1;\n};\n\n \nstruct zd_usb {\n\tstruct zd_usb_interrupt intr;\n\tstruct zd_usb_rx rx;\n\tstruct zd_usb_tx tx;\n\tstruct usb_interface *intf;\n\tstruct usb_anchor submitted_cmds;\n\tstruct urb *urb_async_waiting;\n\tint cmd_error;\n\tu8 req_buf[64];  \n\tu8 is_zd1211b:1, initialized:1, was_running:1, in_async:1;\n};\n\n#define zd_usb_dev(usb) (&usb->intf->dev)\n\nstatic inline struct usb_device *zd_usb_to_usbdev(struct zd_usb *usb)\n{\n\treturn interface_to_usbdev(usb->intf);\n}\n\nstatic inline struct ieee80211_hw *zd_intf_to_hw(struct usb_interface *intf)\n{\n\treturn usb_get_intfdata(intf);\n}\n\nstatic inline struct ieee80211_hw *zd_usb_to_hw(struct zd_usb *usb)\n{\n\treturn zd_intf_to_hw(usb->intf);\n}\n\nvoid zd_usb_init(struct zd_usb *usb, struct ieee80211_hw *hw,\n\t         struct usb_interface *intf);\nint zd_usb_init_hw(struct zd_usb *usb);\nvoid zd_usb_clear(struct zd_usb *usb);\n\nint zd_usb_scnprint_id(struct zd_usb *usb, char *buffer, size_t size);\n\nvoid zd_tx_watchdog_enable(struct zd_usb *usb);\nvoid zd_tx_watchdog_disable(struct zd_usb *usb);\n\nint zd_usb_enable_int(struct zd_usb *usb);\nvoid zd_usb_disable_int(struct zd_usb *usb);\n\nint zd_usb_enable_rx(struct zd_usb *usb);\nvoid zd_usb_disable_rx(struct zd_usb *usb);\n\nvoid zd_usb_reset_rx_idle_timer(struct zd_usb *usb);\n\nvoid zd_usb_enable_tx(struct zd_usb *usb);\nvoid zd_usb_disable_tx(struct zd_usb *usb);\n\nint zd_usb_tx(struct zd_usb *usb, struct sk_buff *skb);\n\nint zd_usb_ioread16v(struct zd_usb *usb, u16 *values,\n\t         const zd_addr_t *addresses, unsigned int count);\n\nstatic inline int zd_usb_ioread16(struct zd_usb *usb, u16 *value,\n\t                      const zd_addr_t addr)\n{\n\treturn zd_usb_ioread16v(usb, value, &addr, 1);\n}\n\nvoid zd_usb_iowrite16v_async_start(struct zd_usb *usb);\nint zd_usb_iowrite16v_async_end(struct zd_usb *usb, unsigned int timeout);\nint zd_usb_iowrite16v_async(struct zd_usb *usb, const struct zd_ioreq16 *ioreqs,\n\t\t\t    unsigned int count);\nint zd_usb_iowrite16v(struct zd_usb *usb, const struct zd_ioreq16 *ioreqs,\n\t              unsigned int count);\n\nint zd_usb_rfwrite(struct zd_usb *usb, u32 value, u8 bits);\n\nint zd_usb_read_fw(struct zd_usb *usb, zd_addr_t addr, u8 *data, u16 len);\n\nextern struct workqueue_struct *zd_workqueue;\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}