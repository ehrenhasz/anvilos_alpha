{
  "module_name": "zd_chip.c",
  "hash_id": "2a5078246c6c23928b727a54440c2a643cb5644e161cbf179922f99463f58c96",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/zydas/zd1211rw/zd_chip.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n\n#include \"zd_def.h\"\n#include \"zd_chip.h\"\n#include \"zd_mac.h\"\n#include \"zd_rf.h\"\n\nvoid zd_chip_init(struct zd_chip *chip,\n\t         struct ieee80211_hw *hw,\n\t\t struct usb_interface *intf)\n{\n\tmemset(chip, 0, sizeof(*chip));\n\tmutex_init(&chip->mutex);\n\tzd_usb_init(&chip->usb, hw, intf);\n\tzd_rf_init(&chip->rf);\n}\n\nvoid zd_chip_clear(struct zd_chip *chip)\n{\n\tZD_ASSERT(!mutex_is_locked(&chip->mutex));\n\tzd_usb_clear(&chip->usb);\n\tzd_rf_clear(&chip->rf);\n\tmutex_destroy(&chip->mutex);\n\tZD_MEMCLEAR(chip, sizeof(*chip));\n}\n\nstatic int scnprint_mac_oui(struct zd_chip *chip, char *buffer, size_t size)\n{\n\tu8 *addr = zd_mac_get_perm_addr(zd_chip_to_mac(chip));\n\treturn scnprintf(buffer, size, \"%3phD\", addr);\n}\n\n \nstatic int scnprint_id(struct zd_chip *chip, char *buffer, size_t size)\n{\n\tint i = 0;\n\n\ti = scnprintf(buffer, size, \"zd1211%s chip \",\n\t\t      zd_chip_is_zd1211b(chip) ? \"b\" : \"\");\n\ti += zd_usb_scnprint_id(&chip->usb, buffer+i, size-i);\n\ti += scnprintf(buffer+i, size-i, \" \");\n\ti += scnprint_mac_oui(chip, buffer+i, size-i);\n\ti += scnprintf(buffer+i, size-i, \" \");\n\ti += zd_rf_scnprint_id(&chip->rf, buffer+i, size-i);\n\ti += scnprintf(buffer+i, size-i, \" pa%1x %c%c%c%c%c\", chip->pa_type,\n\t\tchip->patch_cck_gain ? 'g' : '-',\n\t\tchip->patch_cr157 ? '7' : '-',\n\t\tchip->patch_6m_band_edge ? '6' : '-',\n\t\tchip->new_phy_layout ? 'N' : '-',\n\t\tchip->al2230s_bit ? 'S' : '-');\n\treturn i;\n}\n\nstatic void print_id(struct zd_chip *chip)\n{\n\tchar buffer[80];\n\n\tscnprint_id(chip, buffer, sizeof(buffer));\n\tbuffer[sizeof(buffer)-1] = 0;\n\tdev_info(zd_chip_dev(chip), \"%s\\n\", buffer);\n}\n\nstatic zd_addr_t inc_addr(zd_addr_t addr)\n{\n\tu16 a = (u16)addr;\n\t \n\tif ((a & 0xf000) == CR_START)\n\t\ta += 2;\n\telse\n\t\ta += 1;\n\treturn (zd_addr_t)a;\n}\n\n \nint zd_ioread32v_locked(struct zd_chip *chip, u32 *values, const zd_addr_t *addr,\n\t\t unsigned int count)\n{\n\tint r;\n\tint i;\n\tzd_addr_t a16[USB_MAX_IOREAD32_COUNT * 2];\n\tu16 v16[USB_MAX_IOREAD32_COUNT * 2];\n\tunsigned int count16;\n\n\tif (count > USB_MAX_IOREAD32_COUNT)\n\t\treturn -EINVAL;\n\n\t \n\tcount16 = 2 * count;\n\tBUG_ON(count16 * sizeof(zd_addr_t) > sizeof(a16));\n\tBUG_ON(count16 * sizeof(u16) > sizeof(v16));\n\n\tfor (i = 0; i < count; i++) {\n\t\tint j = 2*i;\n\t\t \n\t\ta16[j] = inc_addr(addr[i]);\n\t\ta16[j+1] = addr[i];\n\t}\n\n\tr = zd_ioread16v_locked(chip, v16, a16, count16);\n\tif (r) {\n\t\tdev_dbg_f(zd_chip_dev(chip),\n\t\t\t  \"error: %s. Error number %d\\n\", __func__, r);\n\t\treturn r;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tint j = 2*i;\n\t\tvalues[i] = (v16[j] << 16) | v16[j+1];\n\t}\n\n\treturn 0;\n}\n\nstatic int _zd_iowrite32v_async_locked(struct zd_chip *chip,\n\t\t\t\t       const struct zd_ioreq32 *ioreqs,\n\t\t\t\t       unsigned int count)\n{\n\tint i, j, r;\n\tstruct zd_ioreq16 ioreqs16[USB_MAX_IOWRITE32_COUNT * 2];\n\tunsigned int count16;\n\n\t \n\n\tZD_ASSERT(mutex_is_locked(&chip->mutex));\n\n\tif (count == 0)\n\t\treturn 0;\n\tif (count > USB_MAX_IOWRITE32_COUNT)\n\t\treturn -EINVAL;\n\n\tcount16 = 2 * count;\n\tBUG_ON(count16 * sizeof(struct zd_ioreq16) > sizeof(ioreqs16));\n\n\tfor (i = 0; i < count; i++) {\n\t\tj = 2*i;\n\t\t \n\t\tioreqs16[j].value   = ioreqs[i].value >> 16;\n\t\tioreqs16[j].addr    = inc_addr(ioreqs[i].addr);\n\t\tioreqs16[j+1].value = ioreqs[i].value;\n\t\tioreqs16[j+1].addr  = ioreqs[i].addr;\n\t}\n\n\tr = zd_usb_iowrite16v_async(&chip->usb, ioreqs16, count16);\n#ifdef DEBUG\n\tif (r) {\n\t\tdev_dbg_f(zd_chip_dev(chip),\n\t\t\t  \"error %d in zd_usb_write16v\\n\", r);\n\t}\n#endif  \n\treturn r;\n}\n\nint _zd_iowrite32v_locked(struct zd_chip *chip, const struct zd_ioreq32 *ioreqs,\n\t\t\t  unsigned int count)\n{\n\tint r;\n\n\tzd_usb_iowrite16v_async_start(&chip->usb);\n\tr = _zd_iowrite32v_async_locked(chip, ioreqs, count);\n\tif (r) {\n\t\tzd_usb_iowrite16v_async_end(&chip->usb, 0);\n\t\treturn r;\n\t}\n\treturn zd_usb_iowrite16v_async_end(&chip->usb, 50  );\n}\n\nint zd_iowrite16a_locked(struct zd_chip *chip,\n                  const struct zd_ioreq16 *ioreqs, unsigned int count)\n{\n\tint r;\n\tunsigned int i, j, t, max;\n\n\tZD_ASSERT(mutex_is_locked(&chip->mutex));\n\tzd_usb_iowrite16v_async_start(&chip->usb);\n\n\tfor (i = 0; i < count; i += j + t) {\n\t\tt = 0;\n\t\tmax = count-i;\n\t\tif (max > USB_MAX_IOWRITE16_COUNT)\n\t\t\tmax = USB_MAX_IOWRITE16_COUNT;\n\t\tfor (j = 0; j < max; j++) {\n\t\t\tif (!ioreqs[i+j].addr) {\n\t\t\t\tt = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tr = zd_usb_iowrite16v_async(&chip->usb, &ioreqs[i], j);\n\t\tif (r) {\n\t\t\tzd_usb_iowrite16v_async_end(&chip->usb, 0);\n\t\t\tdev_dbg_f(zd_chip_dev(chip),\n\t\t\t\t  \"error zd_usb_iowrite16v. Error number %d\\n\",\n\t\t\t\t  r);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\treturn zd_usb_iowrite16v_async_end(&chip->usb, 50  );\n}\n\n \nint zd_iowrite32a_locked(struct zd_chip *chip,\n\t          const struct zd_ioreq32 *ioreqs, unsigned int count)\n{\n\tint r;\n\tunsigned int i, j, t, max;\n\n\tzd_usb_iowrite16v_async_start(&chip->usb);\n\n\tfor (i = 0; i < count; i += j + t) {\n\t\tt = 0;\n\t\tmax = count-i;\n\t\tif (max > USB_MAX_IOWRITE32_COUNT)\n\t\t\tmax = USB_MAX_IOWRITE32_COUNT;\n\t\tfor (j = 0; j < max; j++) {\n\t\t\tif (!ioreqs[i+j].addr) {\n\t\t\t\tt = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tr = _zd_iowrite32v_async_locked(chip, &ioreqs[i], j);\n\t\tif (r) {\n\t\t\tzd_usb_iowrite16v_async_end(&chip->usb, 0);\n\t\t\tdev_dbg_f(zd_chip_dev(chip),\n\t\t\t\t\"error _%s. Error number %d\\n\", __func__,\n\t\t\t\tr);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\treturn zd_usb_iowrite16v_async_end(&chip->usb, 50  );\n}\n\nint zd_ioread16(struct zd_chip *chip, zd_addr_t addr, u16 *value)\n{\n\tint r;\n\n\tmutex_lock(&chip->mutex);\n\tr = zd_ioread16_locked(chip, value, addr);\n\tmutex_unlock(&chip->mutex);\n\treturn r;\n}\n\nint zd_ioread32(struct zd_chip *chip, zd_addr_t addr, u32 *value)\n{\n\tint r;\n\n\tmutex_lock(&chip->mutex);\n\tr = zd_ioread32_locked(chip, value, addr);\n\tmutex_unlock(&chip->mutex);\n\treturn r;\n}\n\nint zd_iowrite16(struct zd_chip *chip, zd_addr_t addr, u16 value)\n{\n\tint r;\n\n\tmutex_lock(&chip->mutex);\n\tr = zd_iowrite16_locked(chip, value, addr);\n\tmutex_unlock(&chip->mutex);\n\treturn r;\n}\n\nint zd_iowrite32(struct zd_chip *chip, zd_addr_t addr, u32 value)\n{\n\tint r;\n\n\tmutex_lock(&chip->mutex);\n\tr = zd_iowrite32_locked(chip, value, addr);\n\tmutex_unlock(&chip->mutex);\n\treturn r;\n}\n\nint zd_ioread32v(struct zd_chip *chip, const zd_addr_t *addresses,\n\t          u32 *values, unsigned int count)\n{\n\tint r;\n\n\tmutex_lock(&chip->mutex);\n\tr = zd_ioread32v_locked(chip, values, addresses, count);\n\tmutex_unlock(&chip->mutex);\n\treturn r;\n}\n\nint zd_iowrite32a(struct zd_chip *chip, const struct zd_ioreq32 *ioreqs,\n\t          unsigned int count)\n{\n\tint r;\n\n\tmutex_lock(&chip->mutex);\n\tr = zd_iowrite32a_locked(chip, ioreqs, count);\n\tmutex_unlock(&chip->mutex);\n\treturn r;\n}\n\nstatic int read_pod(struct zd_chip *chip, u8 *rf_type)\n{\n\tint r;\n\tu32 value;\n\n\tZD_ASSERT(mutex_is_locked(&chip->mutex));\n\tr = zd_ioread32_locked(chip, &value, E2P_POD);\n\tif (r)\n\t\tgoto error;\n\tdev_dbg_f(zd_chip_dev(chip), \"E2P_POD %#010x\\n\", value);\n\n\t \n\t*rf_type = value & 0x0f;\n\tchip->pa_type = (value >> 16) & 0x0f;\n\tchip->patch_cck_gain = (value >> 8) & 0x1;\n\tchip->patch_cr157 = (value >> 13) & 0x1;\n\tchip->patch_6m_band_edge = (value >> 21) & 0x1;\n\tchip->new_phy_layout = (value >> 31) & 0x1;\n\tchip->al2230s_bit = (value >> 7) & 0x1;\n\tchip->link_led = ((value >> 4) & 1) ? LED1 : LED2;\n\tchip->supports_tx_led = 1;\n\tif (value & (1 << 24)) {  \n\t\tif (value & (1 << 29))\n\t\t\tchip->supports_tx_led = 0;\n\t}\n\n\tdev_dbg_f(zd_chip_dev(chip),\n\t\t\"RF %s %#01x PA type %#01x patch CCK %d patch CR157 %d \"\n\t\t\"patch 6M %d new PHY %d link LED%d tx led %d\\n\",\n\t\tzd_rf_name(*rf_type), *rf_type,\n\t\tchip->pa_type, chip->patch_cck_gain,\n\t\tchip->patch_cr157, chip->patch_6m_band_edge,\n\t\tchip->new_phy_layout,\n\t\tchip->link_led == LED1 ? 1 : 2,\n\t\tchip->supports_tx_led);\n\treturn 0;\nerror:\n\t*rf_type = 0;\n\tchip->pa_type = 0;\n\tchip->patch_cck_gain = 0;\n\tchip->patch_cr157 = 0;\n\tchip->patch_6m_band_edge = 0;\n\tchip->new_phy_layout = 0;\n\treturn r;\n}\n\nstatic int zd_write_mac_addr_common(struct zd_chip *chip, const u8 *mac_addr,\n\t\t\t\t    const struct zd_ioreq32 *in_reqs,\n\t\t\t\t    const char *type)\n{\n\tint r;\n\tstruct zd_ioreq32 reqs[2] = {in_reqs[0], in_reqs[1]};\n\n\tif (mac_addr) {\n\t\treqs[0].value = (mac_addr[3] << 24)\n\t\t\t      | (mac_addr[2] << 16)\n\t\t\t      | (mac_addr[1] <<  8)\n\t\t\t      |  mac_addr[0];\n\t\treqs[1].value = (mac_addr[5] <<  8)\n\t\t\t      |  mac_addr[4];\n\t\tdev_dbg_f(zd_chip_dev(chip), \"%s addr %pM\\n\", type, mac_addr);\n\t} else {\n\t\tdev_dbg_f(zd_chip_dev(chip), \"set NULL %s\\n\", type);\n\t}\n\n\tmutex_lock(&chip->mutex);\n\tr = zd_iowrite32a_locked(chip, reqs, ARRAY_SIZE(reqs));\n\tmutex_unlock(&chip->mutex);\n\treturn r;\n}\n\n \nint zd_write_mac_addr(struct zd_chip *chip, const u8 *mac_addr)\n{\n\tstatic const struct zd_ioreq32 reqs[2] = {\n\t\t[0] = { .addr = CR_MAC_ADDR_P1 },\n\t\t[1] = { .addr = CR_MAC_ADDR_P2 },\n\t};\n\n\treturn zd_write_mac_addr_common(chip, mac_addr, reqs, \"mac\");\n}\n\nint zd_write_bssid(struct zd_chip *chip, const u8 *bssid)\n{\n\tstatic const struct zd_ioreq32 reqs[2] = {\n\t\t[0] = { .addr = CR_BSSID_P1 },\n\t\t[1] = { .addr = CR_BSSID_P2 },\n\t};\n\n\treturn zd_write_mac_addr_common(chip, bssid, reqs, \"bssid\");\n}\n\nint zd_read_regdomain(struct zd_chip *chip, u8 *regdomain)\n{\n\tint r;\n\tu32 value;\n\n\tmutex_lock(&chip->mutex);\n\tr = zd_ioread32_locked(chip, &value, E2P_SUBID);\n\tmutex_unlock(&chip->mutex);\n\tif (r)\n\t\treturn r;\n\n\t*regdomain = value >> 16;\n\tdev_dbg_f(zd_chip_dev(chip), \"regdomain: %#04x\\n\", *regdomain);\n\n\treturn 0;\n}\n\nstatic int read_values(struct zd_chip *chip, u8 *values, size_t count,\n\t               zd_addr_t e2p_addr, u32 guard)\n{\n\tint r;\n\tint i;\n\tu32 v;\n\n\tZD_ASSERT(mutex_is_locked(&chip->mutex));\n\tfor (i = 0;;) {\n\t\tr = zd_ioread32_locked(chip, &v,\n\t\t\t               (zd_addr_t)((u16)e2p_addr+i/2));\n\t\tif (r)\n\t\t\treturn r;\n\t\tv -= guard;\n\t\tif (i+4 < count) {\n\t\t\tvalues[i++] = v;\n\t\t\tvalues[i++] = v >>  8;\n\t\t\tvalues[i++] = v >> 16;\n\t\t\tvalues[i++] = v >> 24;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (;i < count; i++)\n\t\t\tvalues[i] = v >> (8*(i%3));\n\t\treturn 0;\n\t}\n}\n\nstatic int read_pwr_cal_values(struct zd_chip *chip)\n{\n\treturn read_values(chip, chip->pwr_cal_values,\n\t\t        E2P_CHANNEL_COUNT, E2P_PWR_CAL_VALUE1,\n\t\t\t0);\n}\n\nstatic int read_pwr_int_values(struct zd_chip *chip)\n{\n\treturn read_values(chip, chip->pwr_int_values,\n\t\t        E2P_CHANNEL_COUNT, E2P_PWR_INT_VALUE1,\n\t\t\tE2P_PWR_INT_GUARD);\n}\n\nstatic int read_ofdm_cal_values(struct zd_chip *chip)\n{\n\tint r;\n\tint i;\n\tstatic const zd_addr_t addresses[] = {\n\t\tE2P_36M_CAL_VALUE1,\n\t\tE2P_48M_CAL_VALUE1,\n\t\tE2P_54M_CAL_VALUE1,\n\t};\n\n\tfor (i = 0; i < 3; i++) {\n\t\tr = read_values(chip, chip->ofdm_cal_values[i],\n\t\t\t\tE2P_CHANNEL_COUNT, addresses[i], 0);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}\n\nstatic int read_cal_int_tables(struct zd_chip *chip)\n{\n\tint r;\n\n\tr = read_pwr_cal_values(chip);\n\tif (r)\n\t\treturn r;\n\tr = read_pwr_int_values(chip);\n\tif (r)\n\t\treturn r;\n\tr = read_ofdm_cal_values(chip);\n\tif (r)\n\t\treturn r;\n\treturn 0;\n}\n\n \nint zd_chip_lock_phy_regs(struct zd_chip *chip)\n{\n\tint r;\n\tu32 tmp;\n\n\tZD_ASSERT(mutex_is_locked(&chip->mutex));\n\tr = zd_ioread32_locked(chip, &tmp, CR_REG1);\n\tif (r) {\n\t\tdev_err(zd_chip_dev(chip), \"error ioread32(CR_REG1): %d\\n\", r);\n\t\treturn r;\n\t}\n\n\ttmp &= ~UNLOCK_PHY_REGS;\n\n\tr = zd_iowrite32_locked(chip, tmp, CR_REG1);\n\tif (r)\n\t\tdev_err(zd_chip_dev(chip), \"error iowrite32(CR_REG1): %d\\n\", r);\n\treturn r;\n}\n\nint zd_chip_unlock_phy_regs(struct zd_chip *chip)\n{\n\tint r;\n\tu32 tmp;\n\n\tZD_ASSERT(mutex_is_locked(&chip->mutex));\n\tr = zd_ioread32_locked(chip, &tmp, CR_REG1);\n\tif (r) {\n\t\tdev_err(zd_chip_dev(chip),\n\t\t\t\"error ioread32(CR_REG1): %d\\n\", r);\n\t\treturn r;\n\t}\n\n\ttmp |= UNLOCK_PHY_REGS;\n\n\tr = zd_iowrite32_locked(chip, tmp, CR_REG1);\n\tif (r)\n\t\tdev_err(zd_chip_dev(chip), \"error iowrite32(CR_REG1): %d\\n\", r);\n\treturn r;\n}\n\n \nstatic int patch_cr157(struct zd_chip *chip)\n{\n\tint r;\n\tu16 value;\n\n\tif (!chip->patch_cr157)\n\t\treturn 0;\n\n\tr = zd_ioread16_locked(chip, &value, E2P_PHY_REG);\n\tif (r)\n\t\treturn r;\n\n\tdev_dbg_f(zd_chip_dev(chip), \"patching value %x\\n\", value >> 8);\n\treturn zd_iowrite32_locked(chip, value >> 8, ZD_CR157);\n}\n\n \nstatic int patch_6m_band_edge(struct zd_chip *chip, u8 channel)\n{\n\tZD_ASSERT(mutex_is_locked(&chip->mutex));\n\tif (!chip->patch_6m_band_edge)\n\t\treturn 0;\n\n\treturn zd_rf_patch_6m_band_edge(&chip->rf, channel);\n}\n\n \nint zd_chip_generic_patch_6m_band(struct zd_chip *chip, int channel)\n{\n\tstruct zd_ioreq16 ioreqs[] = {\n\t\t{ ZD_CR128, 0x14 }, { ZD_CR129, 0x12 }, { ZD_CR130, 0x10 },\n\t\t{ ZD_CR47,  0x1e },\n\t};\n\n\t \n\tif (channel == 1 || channel == 11)\n\t\tioreqs[0].value = 0x12;\n\n\tdev_dbg_f(zd_chip_dev(chip), \"patching for channel %d\\n\", channel);\n\treturn zd_iowrite16a_locked(chip, ioreqs, ARRAY_SIZE(ioreqs));\n}\n\nstatic int zd1211_hw_reset_phy(struct zd_chip *chip)\n{\n\tstatic const struct zd_ioreq16 ioreqs[] = {\n\t\t{ ZD_CR0,   0x0a }, { ZD_CR1,   0x06 }, { ZD_CR2,   0x26 },\n\t\t{ ZD_CR3,   0x38 }, { ZD_CR4,   0x80 }, { ZD_CR9,   0xa0 },\n\t\t{ ZD_CR10,  0x81 }, { ZD_CR11,  0x00 }, { ZD_CR12,  0x7f },\n\t\t{ ZD_CR13,  0x8c }, { ZD_CR14,  0x80 }, { ZD_CR15,  0x3d },\n\t\t{ ZD_CR16,  0x20 }, { ZD_CR17,  0x1e }, { ZD_CR18,  0x0a },\n\t\t{ ZD_CR19,  0x48 }, { ZD_CR20,  0x0c }, { ZD_CR21,  0x0c },\n\t\t{ ZD_CR22,  0x23 }, { ZD_CR23,  0x90 }, { ZD_CR24,  0x14 },\n\t\t{ ZD_CR25,  0x40 }, { ZD_CR26,  0x10 }, { ZD_CR27,  0x19 },\n\t\t{ ZD_CR28,  0x7f }, { ZD_CR29,  0x80 }, { ZD_CR30,  0x4b },\n\t\t{ ZD_CR31,  0x60 }, { ZD_CR32,  0x43 }, { ZD_CR33,  0x08 },\n\t\t{ ZD_CR34,  0x06 }, { ZD_CR35,  0x0a }, { ZD_CR36,  0x00 },\n\t\t{ ZD_CR37,  0x00 }, { ZD_CR38,  0x38 }, { ZD_CR39,  0x0c },\n\t\t{ ZD_CR40,  0x84 }, { ZD_CR41,  0x2a }, { ZD_CR42,  0x80 },\n\t\t{ ZD_CR43,  0x10 }, { ZD_CR44,  0x12 }, { ZD_CR46,  0xff },\n\t\t{ ZD_CR47,  0x1E }, { ZD_CR48,  0x26 }, { ZD_CR49,  0x5b },\n\t\t{ ZD_CR64,  0xd0 }, { ZD_CR65,  0x04 }, { ZD_CR66,  0x58 },\n\t\t{ ZD_CR67,  0xc9 }, { ZD_CR68,  0x88 }, { ZD_CR69,  0x41 },\n\t\t{ ZD_CR70,  0x23 }, { ZD_CR71,  0x10 }, { ZD_CR72,  0xff },\n\t\t{ ZD_CR73,  0x32 }, { ZD_CR74,  0x30 }, { ZD_CR75,  0x65 },\n\t\t{ ZD_CR76,  0x41 }, { ZD_CR77,  0x1b }, { ZD_CR78,  0x30 },\n\t\t{ ZD_CR79,  0x68 }, { ZD_CR80,  0x64 }, { ZD_CR81,  0x64 },\n\t\t{ ZD_CR82,  0x00 }, { ZD_CR83,  0x00 }, { ZD_CR84,  0x00 },\n\t\t{ ZD_CR85,  0x02 }, { ZD_CR86,  0x00 }, { ZD_CR87,  0x00 },\n\t\t{ ZD_CR88,  0xff }, { ZD_CR89,  0xfc }, { ZD_CR90,  0x00 },\n\t\t{ ZD_CR91,  0x00 }, { ZD_CR92,  0x00 }, { ZD_CR93,  0x08 },\n\t\t{ ZD_CR94,  0x00 }, { ZD_CR95,  0x00 }, { ZD_CR96,  0xff },\n\t\t{ ZD_CR97,  0xe7 }, { ZD_CR98,  0x00 }, { ZD_CR99,  0x00 },\n\t\t{ ZD_CR100, 0x00 }, { ZD_CR101, 0xae }, { ZD_CR102, 0x02 },\n\t\t{ ZD_CR103, 0x00 }, { ZD_CR104, 0x03 }, { ZD_CR105, 0x65 },\n\t\t{ ZD_CR106, 0x04 }, { ZD_CR107, 0x00 }, { ZD_CR108, 0x0a },\n\t\t{ ZD_CR109, 0xaa }, { ZD_CR110, 0xaa }, { ZD_CR111, 0x25 },\n\t\t{ ZD_CR112, 0x25 }, { ZD_CR113, 0x00 }, { ZD_CR119, 0x1e },\n\t\t{ ZD_CR125, 0x90 }, { ZD_CR126, 0x00 }, { ZD_CR127, 0x00 },\n\t\t{ },\n\t\t{ ZD_CR5,   0x00 }, { ZD_CR6,   0x00 }, { ZD_CR7,   0x00 },\n\t\t{ ZD_CR8,   0x00 }, { ZD_CR9,   0x20 }, { ZD_CR12,  0xf0 },\n\t\t{ ZD_CR20,  0x0e }, { ZD_CR21,  0x0e }, { ZD_CR27,  0x10 },\n\t\t{ ZD_CR44,  0x33 }, { ZD_CR47,  0x1E }, { ZD_CR83,  0x24 },\n\t\t{ ZD_CR84,  0x04 }, { ZD_CR85,  0x00 }, { ZD_CR86,  0x0C },\n\t\t{ ZD_CR87,  0x12 }, { ZD_CR88,  0x0C }, { ZD_CR89,  0x00 },\n\t\t{ ZD_CR90,  0x10 }, { ZD_CR91,  0x08 }, { ZD_CR93,  0x00 },\n\t\t{ ZD_CR94,  0x01 }, { ZD_CR95,  0x00 }, { ZD_CR96,  0x50 },\n\t\t{ ZD_CR97,  0x37 }, { ZD_CR98,  0x35 }, { ZD_CR101, 0x13 },\n\t\t{ ZD_CR102, 0x27 }, { ZD_CR103, 0x27 }, { ZD_CR104, 0x18 },\n\t\t{ ZD_CR105, 0x12 }, { ZD_CR109, 0x27 }, { ZD_CR110, 0x27 },\n\t\t{ ZD_CR111, 0x27 }, { ZD_CR112, 0x27 }, { ZD_CR113, 0x27 },\n\t\t{ ZD_CR114, 0x27 }, { ZD_CR115, 0x26 }, { ZD_CR116, 0x24 },\n\t\t{ ZD_CR117, 0xfc }, { ZD_CR118, 0xfa }, { ZD_CR120, 0x4f },\n\t\t{ ZD_CR125, 0xaa }, { ZD_CR127, 0x03 }, { ZD_CR128, 0x14 },\n\t\t{ ZD_CR129, 0x12 }, { ZD_CR130, 0x10 }, { ZD_CR131, 0x0C },\n\t\t{ ZD_CR136, 0xdf }, { ZD_CR137, 0x40 }, { ZD_CR138, 0xa0 },\n\t\t{ ZD_CR139, 0xb0 }, { ZD_CR140, 0x99 }, { ZD_CR141, 0x82 },\n\t\t{ ZD_CR142, 0x54 }, { ZD_CR143, 0x1c }, { ZD_CR144, 0x6c },\n\t\t{ ZD_CR147, 0x07 }, { ZD_CR148, 0x4c }, { ZD_CR149, 0x50 },\n\t\t{ ZD_CR150, 0x0e }, { ZD_CR151, 0x18 }, { ZD_CR160, 0xfe },\n\t\t{ ZD_CR161, 0xee }, { ZD_CR162, 0xaa }, { ZD_CR163, 0xfa },\n\t\t{ ZD_CR164, 0xfa }, { ZD_CR165, 0xea }, { ZD_CR166, 0xbe },\n\t\t{ ZD_CR167, 0xbe }, { ZD_CR168, 0x6a }, { ZD_CR169, 0xba },\n\t\t{ ZD_CR170, 0xba }, { ZD_CR171, 0xba },\n\t\t \n\t\t{ ZD_CR204, 0x7d },\n\t\t{ },\n\t\t{ ZD_CR203, 0x30 },\n\t};\n\n\tint r, t;\n\n\tdev_dbg_f(zd_chip_dev(chip), \"\\n\");\n\n\tr = zd_chip_lock_phy_regs(chip);\n\tif (r)\n\t\tgoto out;\n\n\tr = zd_iowrite16a_locked(chip, ioreqs, ARRAY_SIZE(ioreqs));\n\tif (r)\n\t\tgoto unlock;\n\n\tr = patch_cr157(chip);\nunlock:\n\tt = zd_chip_unlock_phy_regs(chip);\n\tif (t && !r)\n\t\tr = t;\nout:\n\treturn r;\n}\n\nstatic int zd1211b_hw_reset_phy(struct zd_chip *chip)\n{\n\tstatic const struct zd_ioreq16 ioreqs[] = {\n\t\t{ ZD_CR0,   0x14 }, { ZD_CR1,   0x06 }, { ZD_CR2,   0x26 },\n\t\t{ ZD_CR3,   0x38 }, { ZD_CR4,   0x80 }, { ZD_CR9,   0xe0 },\n\t\t{ ZD_CR10,  0x81 },\n\t\t \n\t\t{ ZD_CR11,  0x00 },\n\t\t{ ZD_CR12,  0xf0 }, { ZD_CR13,  0x8c }, { ZD_CR14,  0x80 },\n\t\t{ ZD_CR15,  0x3d }, { ZD_CR16,  0x20 }, { ZD_CR17,  0x1e },\n\t\t{ ZD_CR18,  0x0a }, { ZD_CR19,  0x48 },\n\t\t{ ZD_CR20,  0x10 },  \n\t\t{ ZD_CR21,  0x0e }, { ZD_CR22,  0x23 }, { ZD_CR23,  0x90 },\n\t\t{ ZD_CR24,  0x14 }, { ZD_CR25,  0x40 }, { ZD_CR26,  0x10 },\n\t\t{ ZD_CR27,  0x10 }, { ZD_CR28,  0x7f }, { ZD_CR29,  0x80 },\n\t\t{ ZD_CR30,  0x4b },  \n\t\t{ ZD_CR31,  0x60 }, { ZD_CR32,  0x43 }, { ZD_CR33,  0x08 },\n\t\t{ ZD_CR34,  0x06 }, { ZD_CR35,  0x0a }, { ZD_CR36,  0x00 },\n\t\t{ ZD_CR37,  0x00 }, { ZD_CR38,  0x38 }, { ZD_CR39,  0x0c },\n\t\t{ ZD_CR40,  0x84 }, { ZD_CR41,  0x2a }, { ZD_CR42,  0x80 },\n\t\t{ ZD_CR43,  0x10 }, { ZD_CR44,  0x33 }, { ZD_CR46,  0xff },\n\t\t{ ZD_CR47,  0x1E }, { ZD_CR48,  0x26 }, { ZD_CR49,  0x5b },\n\t\t{ ZD_CR64,  0xd0 }, { ZD_CR65,  0x04 }, { ZD_CR66,  0x58 },\n\t\t{ ZD_CR67,  0xc9 }, { ZD_CR68,  0x88 }, { ZD_CR69,  0x41 },\n\t\t{ ZD_CR70,  0x23 }, { ZD_CR71,  0x10 }, { ZD_CR72,  0xff },\n\t\t{ ZD_CR73,  0x32 }, { ZD_CR74,  0x30 }, { ZD_CR75,  0x65 },\n\t\t{ ZD_CR76,  0x41 }, { ZD_CR77,  0x1b }, { ZD_CR78,  0x30 },\n\t\t{ ZD_CR79,  0xf0 }, { ZD_CR80,  0x64 }, { ZD_CR81,  0x64 },\n\t\t{ ZD_CR82,  0x00 }, { ZD_CR83,  0x24 }, { ZD_CR84,  0x04 },\n\t\t{ ZD_CR85,  0x00 }, { ZD_CR86,  0x0c }, { ZD_CR87,  0x12 },\n\t\t{ ZD_CR88,  0x0c }, { ZD_CR89,  0x00 }, { ZD_CR90,  0x58 },\n\t\t{ ZD_CR91,  0x04 }, { ZD_CR92,  0x00 }, { ZD_CR93,  0x00 },\n\t\t{ ZD_CR94,  0x01 },\n\t\t{ ZD_CR95,  0x20 },  \n\t\t{ ZD_CR96,  0x50 }, { ZD_CR97,  0x37 }, { ZD_CR98,  0x35 },\n\t\t{ ZD_CR99,  0x00 }, { ZD_CR100, 0x01 }, { ZD_CR101, 0x13 },\n\t\t{ ZD_CR102, 0x27 }, { ZD_CR103, 0x27 }, { ZD_CR104, 0x18 },\n\t\t{ ZD_CR105, 0x12 }, { ZD_CR106, 0x04 }, { ZD_CR107, 0x00 },\n\t\t{ ZD_CR108, 0x0a }, { ZD_CR109, 0x27 }, { ZD_CR110, 0x27 },\n\t\t{ ZD_CR111, 0x27 }, { ZD_CR112, 0x27 }, { ZD_CR113, 0x27 },\n\t\t{ ZD_CR114, 0x27 }, { ZD_CR115, 0x26 }, { ZD_CR116, 0x24 },\n\t\t{ ZD_CR117, 0xfc }, { ZD_CR118, 0xfa }, { ZD_CR119, 0x1e },\n\t\t{ ZD_CR125, 0x90 }, { ZD_CR126, 0x00 }, { ZD_CR127, 0x00 },\n\t\t{ ZD_CR128, 0x14 }, { ZD_CR129, 0x12 }, { ZD_CR130, 0x10 },\n\t\t{ ZD_CR131, 0x0c }, { ZD_CR136, 0xdf }, { ZD_CR137, 0xa0 },\n\t\t{ ZD_CR138, 0xa8 }, { ZD_CR139, 0xb4 }, { ZD_CR140, 0x98 },\n\t\t{ ZD_CR141, 0x82 }, { ZD_CR142, 0x53 }, { ZD_CR143, 0x1c },\n\t\t{ ZD_CR144, 0x6c }, { ZD_CR147, 0x07 }, { ZD_CR148, 0x40 },\n\t\t{ ZD_CR149, 0x40 },  \n\t\t{ ZD_CR150, 0x14 },  \n\t\t{ ZD_CR151, 0x18 }, { ZD_CR159, 0x70 }, { ZD_CR160, 0xfe },\n\t\t{ ZD_CR161, 0xee }, { ZD_CR162, 0xaa }, { ZD_CR163, 0xfa },\n\t\t{ ZD_CR164, 0xfa }, { ZD_CR165, 0xea }, { ZD_CR166, 0xbe },\n\t\t{ ZD_CR167, 0xbe }, { ZD_CR168, 0x6a }, { ZD_CR169, 0xba },\n\t\t{ ZD_CR170, 0xba }, { ZD_CR171, 0xba },\n\t\t \n\t\t{ ZD_CR204, 0x7d },\n\t\t{},\n\t\t{ ZD_CR203, 0x30 },\n\t};\n\n\tint r, t;\n\n\tdev_dbg_f(zd_chip_dev(chip), \"\\n\");\n\n\tr = zd_chip_lock_phy_regs(chip);\n\tif (r)\n\t\tgoto out;\n\n\tr = zd_iowrite16a_locked(chip, ioreqs, ARRAY_SIZE(ioreqs));\n\tt = zd_chip_unlock_phy_regs(chip);\n\tif (t && !r)\n\t\tr = t;\nout:\n\treturn r;\n}\n\nstatic int hw_reset_phy(struct zd_chip *chip)\n{\n\treturn zd_chip_is_zd1211b(chip) ? zd1211b_hw_reset_phy(chip) :\n\t\t                  zd1211_hw_reset_phy(chip);\n}\n\nstatic int zd1211_hw_init_hmac(struct zd_chip *chip)\n{\n\tstatic const struct zd_ioreq32 ioreqs[] = {\n\t\t{ CR_ZD1211_RETRY_MAX,\t\tZD1211_RETRY_COUNT },\n\t\t{ CR_RX_THRESHOLD,\t\t0x000c0640 },\n\t};\n\n\tdev_dbg_f(zd_chip_dev(chip), \"\\n\");\n\tZD_ASSERT(mutex_is_locked(&chip->mutex));\n\treturn zd_iowrite32a_locked(chip, ioreqs, ARRAY_SIZE(ioreqs));\n}\n\nstatic int zd1211b_hw_init_hmac(struct zd_chip *chip)\n{\n\tstatic const struct zd_ioreq32 ioreqs[] = {\n\t\t{ CR_ZD1211B_RETRY_MAX,\t\tZD1211B_RETRY_COUNT },\n\t\t{ CR_ZD1211B_CWIN_MAX_MIN_AC0,\t0x007f003f },\n\t\t{ CR_ZD1211B_CWIN_MAX_MIN_AC1,\t0x007f003f },\n\t\t{ CR_ZD1211B_CWIN_MAX_MIN_AC2,  0x003f001f },\n\t\t{ CR_ZD1211B_CWIN_MAX_MIN_AC3,  0x001f000f },\n\t\t{ CR_ZD1211B_AIFS_CTL1,\t\t0x00280028 },\n\t\t{ CR_ZD1211B_AIFS_CTL2,\t\t0x008C003C },\n\t\t{ CR_ZD1211B_TXOP,\t\t0x01800824 },\n\t\t{ CR_RX_THRESHOLD,\t\t0x000c0eff, },\n\t};\n\n\tdev_dbg_f(zd_chip_dev(chip), \"\\n\");\n\tZD_ASSERT(mutex_is_locked(&chip->mutex));\n\treturn zd_iowrite32a_locked(chip, ioreqs, ARRAY_SIZE(ioreqs));\n}\n\nstatic int hw_init_hmac(struct zd_chip *chip)\n{\n\tint r;\n\tstatic const struct zd_ioreq32 ioreqs[] = {\n\t\t{ CR_ACK_TIMEOUT_EXT,\t\t0x20 },\n\t\t{ CR_ADDA_MBIAS_WARMTIME,\t0x30000808 },\n\t\t{ CR_SNIFFER_ON,\t\t0 },\n\t\t{ CR_RX_FILTER,\t\t\tSTA_RX_FILTER },\n\t\t{ CR_GROUP_HASH_P1,\t\t0x00 },\n\t\t{ CR_GROUP_HASH_P2,\t\t0x80000000 },\n\t\t{ CR_REG1,\t\t\t0xa4 },\n\t\t{ CR_ADDA_PWR_DWN,\t\t0x7f },\n\t\t{ CR_BCN_PLCP_CFG,\t\t0x00f00401 },\n\t\t{ CR_PHY_DELAY,\t\t\t0x00 },\n\t\t{ CR_ACK_TIMEOUT_EXT,\t\t0x80 },\n\t\t{ CR_ADDA_PWR_DWN,\t\t0x00 },\n\t\t{ CR_ACK_TIME_80211,\t\t0x100 },\n\t\t{ CR_RX_PE_DELAY,\t\t0x70 },\n\t\t{ CR_PS_CTRL,\t\t\t0x10000000 },\n\t\t{ CR_RTS_CTS_RATE,\t\t0x02030203 },\n\t\t{ CR_AFTER_PNP,\t\t\t0x1 },\n\t\t{ CR_WEP_PROTECT,\t\t0x114 },\n\t\t{ CR_IFS_VALUE,\t\t\tIFS_VALUE_DEFAULT },\n\t\t{ CR_CAM_MODE,\t\t\tMODE_AP_WDS},\n\t};\n\n\tZD_ASSERT(mutex_is_locked(&chip->mutex));\n\tr = zd_iowrite32a_locked(chip, ioreqs, ARRAY_SIZE(ioreqs));\n\tif (r)\n\t\treturn r;\n\n\treturn zd_chip_is_zd1211b(chip) ?\n\t\tzd1211b_hw_init_hmac(chip) : zd1211_hw_init_hmac(chip);\n}\n\nstruct aw_pt_bi {\n\tu32 atim_wnd_period;\n\tu32 pre_tbtt;\n\tu32 beacon_interval;\n};\n\nstatic int get_aw_pt_bi(struct zd_chip *chip, struct aw_pt_bi *s)\n{\n\tint r;\n\tstatic const zd_addr_t aw_pt_bi_addr[] =\n\t\t{ CR_ATIM_WND_PERIOD, CR_PRE_TBTT, CR_BCN_INTERVAL };\n\tu32 values[3];\n\n\tr = zd_ioread32v_locked(chip, values, (const zd_addr_t *)aw_pt_bi_addr,\n\t\t         ARRAY_SIZE(aw_pt_bi_addr));\n\tif (r) {\n\t\tmemset(s, 0, sizeof(*s));\n\t\treturn r;\n\t}\n\n\ts->atim_wnd_period = values[0];\n\ts->pre_tbtt = values[1];\n\ts->beacon_interval = values[2];\n\treturn 0;\n}\n\nstatic int set_aw_pt_bi(struct zd_chip *chip, struct aw_pt_bi *s)\n{\n\tstruct zd_ioreq32 reqs[3];\n\tu16 b_interval = s->beacon_interval & 0xffff;\n\n\tif (b_interval <= 5)\n\t\tb_interval = 5;\n\tif (s->pre_tbtt < 4 || s->pre_tbtt >= b_interval)\n\t\ts->pre_tbtt = b_interval - 1;\n\tif (s->atim_wnd_period >= s->pre_tbtt)\n\t\ts->atim_wnd_period = s->pre_tbtt - 1;\n\n\treqs[0].addr = CR_ATIM_WND_PERIOD;\n\treqs[0].value = s->atim_wnd_period;\n\treqs[1].addr = CR_PRE_TBTT;\n\treqs[1].value = s->pre_tbtt;\n\treqs[2].addr = CR_BCN_INTERVAL;\n\treqs[2].value = (s->beacon_interval & ~0xffff) | b_interval;\n\n\treturn zd_iowrite32a_locked(chip, reqs, ARRAY_SIZE(reqs));\n}\n\n\nstatic int set_beacon_interval(struct zd_chip *chip, u16 interval,\n\t\t\t       u8 dtim_period, int type)\n{\n\tint r;\n\tstruct aw_pt_bi s;\n\tu32 b_interval, mode_flag;\n\n\tZD_ASSERT(mutex_is_locked(&chip->mutex));\n\n\tif (interval > 0) {\n\t\tswitch (type) {\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t\tmode_flag = BCN_MODE_IBSS;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\tmode_flag = BCN_MODE_AP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmode_flag = 0;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tdtim_period = 0;\n\t\tmode_flag = 0;\n\t}\n\n\tb_interval = mode_flag | (dtim_period << 16) | interval;\n\n\tr = zd_iowrite32_locked(chip, b_interval, CR_BCN_INTERVAL);\n\tif (r)\n\t\treturn r;\n\tr = get_aw_pt_bi(chip, &s);\n\tif (r)\n\t\treturn r;\n\treturn set_aw_pt_bi(chip, &s);\n}\n\nint zd_set_beacon_interval(struct zd_chip *chip, u16 interval, u8 dtim_period,\n\t\t\t   int type)\n{\n\tint r;\n\n\tmutex_lock(&chip->mutex);\n\tr = set_beacon_interval(chip, interval, dtim_period, type);\n\tmutex_unlock(&chip->mutex);\n\treturn r;\n}\n\nstatic int hw_init(struct zd_chip *chip)\n{\n\tint r;\n\n\tdev_dbg_f(zd_chip_dev(chip), \"\\n\");\n\tZD_ASSERT(mutex_is_locked(&chip->mutex));\n\tr = hw_reset_phy(chip);\n\tif (r)\n\t\treturn r;\n\n\tr = hw_init_hmac(chip);\n\tif (r)\n\t\treturn r;\n\n\treturn set_beacon_interval(chip, 100, 0, NL80211_IFTYPE_UNSPECIFIED);\n}\n\nstatic zd_addr_t fw_reg_addr(struct zd_chip *chip, u16 offset)\n{\n\treturn (zd_addr_t)((u16)chip->fw_regs_base + offset);\n}\n\n#ifdef DEBUG\nstatic int dump_cr(struct zd_chip *chip, const zd_addr_t addr,\n\t           const char *addr_string)\n{\n\tint r;\n\tu32 value;\n\n\tr = zd_ioread32_locked(chip, &value, addr);\n\tif (r) {\n\t\tdev_dbg_f(zd_chip_dev(chip),\n\t\t\t\"error reading %s. Error number %d\\n\", addr_string, r);\n\t\treturn r;\n\t}\n\n\tdev_dbg_f(zd_chip_dev(chip), \"%s %#010x\\n\",\n\t\taddr_string, (unsigned int)value);\n\treturn 0;\n}\n\nstatic int test_init(struct zd_chip *chip)\n{\n\tint r;\n\n\tr = dump_cr(chip, CR_AFTER_PNP, \"CR_AFTER_PNP\");\n\tif (r)\n\t\treturn r;\n\tr = dump_cr(chip, CR_GPI_EN, \"CR_GPI_EN\");\n\tif (r)\n\t\treturn r;\n\treturn dump_cr(chip, CR_INTERRUPT, \"CR_INTERRUPT\");\n}\n\nstatic void dump_fw_registers(struct zd_chip *chip)\n{\n\tconst zd_addr_t addr[4] = {\n\t\tfw_reg_addr(chip, FW_REG_FIRMWARE_VER),\n\t\tfw_reg_addr(chip, FW_REG_USB_SPEED),\n\t\tfw_reg_addr(chip, FW_REG_FIX_TX_RATE),\n\t\tfw_reg_addr(chip, FW_REG_LED_LINK_STATUS),\n\t};\n\n\tint r;\n\tu16 values[4];\n\n\tr = zd_ioread16v_locked(chip, values, (const zd_addr_t*)addr,\n\t\t         ARRAY_SIZE(addr));\n\tif (r) {\n\t\tdev_dbg_f(zd_chip_dev(chip), \"error %d zd_ioread16v_locked\\n\",\n\t\t\t r);\n\t\treturn;\n\t}\n\n\tdev_dbg_f(zd_chip_dev(chip), \"FW_FIRMWARE_VER %#06hx\\n\", values[0]);\n\tdev_dbg_f(zd_chip_dev(chip), \"FW_USB_SPEED %#06hx\\n\", values[1]);\n\tdev_dbg_f(zd_chip_dev(chip), \"FW_FIX_TX_RATE %#06hx\\n\", values[2]);\n\tdev_dbg_f(zd_chip_dev(chip), \"FW_LINK_STATUS %#06hx\\n\", values[3]);\n}\n#endif  \n\nstatic int print_fw_version(struct zd_chip *chip)\n{\n\tstruct wiphy *wiphy = zd_chip_to_mac(chip)->hw->wiphy;\n\tint r;\n\tu16 version;\n\n\tr = zd_ioread16_locked(chip, &version,\n\t\tfw_reg_addr(chip, FW_REG_FIRMWARE_VER));\n\tif (r)\n\t\treturn r;\n\n\tdev_info(zd_chip_dev(chip),\"firmware version %04hx\\n\", version);\n\n\tsnprintf(wiphy->fw_version, sizeof(wiphy->fw_version),\n\t\t\t\"%04hx\", version);\n\n\treturn 0;\n}\n\nstatic int set_mandatory_rates(struct zd_chip *chip, int gmode)\n{\n\tu32 rates;\n\tZD_ASSERT(mutex_is_locked(&chip->mutex));\n\t \n\tif (!gmode)\n\t\trates = CR_RATE_1M|CR_RATE_2M|CR_RATE_5_5M|CR_RATE_11M;\n\telse\n\t\trates = CR_RATE_1M|CR_RATE_2M|CR_RATE_5_5M|CR_RATE_11M|\n\t\t\tCR_RATE_6M|CR_RATE_12M|CR_RATE_24M;\n\n\treturn zd_iowrite32_locked(chip, rates, CR_MANDATORY_RATE_TBL);\n}\n\nint zd_chip_set_rts_cts_rate_locked(struct zd_chip *chip,\n\t\t\t\t    int preamble)\n{\n\tu32 value = 0;\n\n\tdev_dbg_f(zd_chip_dev(chip), \"preamble=%x\\n\", preamble);\n\tvalue |= preamble << RTSCTS_SH_RTS_PMB_TYPE;\n\tvalue |= preamble << RTSCTS_SH_CTS_PMB_TYPE;\n\n\t \n\tvalue |= ZD_PURE_RATE(ZD_CCK_RATE_11M) << RTSCTS_SH_RTS_RATE;\n\tvalue |= ZD_RX_CCK << RTSCTS_SH_RTS_MOD_TYPE;\n\tvalue |= ZD_PURE_RATE(ZD_CCK_RATE_11M) << RTSCTS_SH_CTS_RATE;\n\tvalue |= ZD_RX_CCK << RTSCTS_SH_CTS_MOD_TYPE;\n\n\treturn zd_iowrite32_locked(chip, value, CR_RTS_CTS_RATE);\n}\n\nint zd_chip_enable_hwint(struct zd_chip *chip)\n{\n\tint r;\n\n\tmutex_lock(&chip->mutex);\n\tr = zd_iowrite32_locked(chip, HWINT_ENABLED, CR_INTERRUPT);\n\tmutex_unlock(&chip->mutex);\n\treturn r;\n}\n\nstatic int disable_hwint(struct zd_chip *chip)\n{\n\treturn zd_iowrite32_locked(chip, HWINT_DISABLED, CR_INTERRUPT);\n}\n\nint zd_chip_disable_hwint(struct zd_chip *chip)\n{\n\tint r;\n\n\tmutex_lock(&chip->mutex);\n\tr = disable_hwint(chip);\n\tmutex_unlock(&chip->mutex);\n\treturn r;\n}\n\nstatic int read_fw_regs_offset(struct zd_chip *chip)\n{\n\tint r;\n\n\tZD_ASSERT(mutex_is_locked(&chip->mutex));\n\tr = zd_ioread16_locked(chip, (u16*)&chip->fw_regs_base,\n\t\t               FWRAW_REGS_ADDR);\n\tif (r)\n\t\treturn r;\n\tdev_dbg_f(zd_chip_dev(chip), \"fw_regs_base: %#06hx\\n\",\n\t\t  (u16)chip->fw_regs_base);\n\n\treturn 0;\n}\n\n \nint zd_chip_read_mac_addr_fw(struct zd_chip *chip, u8 *addr)\n{\n\tdev_dbg_f(zd_chip_dev(chip), \"\\n\");\n\treturn zd_usb_read_fw(&chip->usb, E2P_MAC_ADDR_P1, addr,\n\t\tETH_ALEN);\n}\n\nint zd_chip_init_hw(struct zd_chip *chip)\n{\n\tint r;\n\tu8 rf_type;\n\n\tdev_dbg_f(zd_chip_dev(chip), \"\\n\");\n\n\tmutex_lock(&chip->mutex);\n\n#ifdef DEBUG\n\tr = test_init(chip);\n\tif (r)\n\t\tgoto out;\n#endif\n\tr = zd_iowrite32_locked(chip, 1, CR_AFTER_PNP);\n\tif (r)\n\t\tgoto out;\n\n\tr = read_fw_regs_offset(chip);\n\tif (r)\n\t\tgoto out;\n\n\t \n\tr = zd_iowrite32_locked(chip, 0, CR_GPI_EN);\n\tif (r)\n\t\tgoto out;\n\tr = zd_iowrite32_locked(chip, CWIN_SIZE, CR_CWMIN_CWMAX);\n\tif (r)\n\t\tgoto out;\n\t \n\tr = set_mandatory_rates(chip, 1);\n\tif (r)\n\t\tgoto out;\n\t \n\tr = disable_hwint(chip);\n\tif (r)\n\t\tgoto out;\n\tr = read_pod(chip, &rf_type);\n\tif (r)\n\t\tgoto out;\n\tr = hw_init(chip);\n\tif (r)\n\t\tgoto out;\n\tr = zd_rf_init_hw(&chip->rf, rf_type);\n\tif (r)\n\t\tgoto out;\n\n\tr = print_fw_version(chip);\n\tif (r)\n\t\tgoto out;\n\n#ifdef DEBUG\n\tdump_fw_registers(chip);\n\tr = test_init(chip);\n\tif (r)\n\t\tgoto out;\n#endif  \n\n\tr = read_cal_int_tables(chip);\n\tif (r)\n\t\tgoto out;\n\n\tprint_id(chip);\nout:\n\tmutex_unlock(&chip->mutex);\n\treturn r;\n}\n\nstatic int update_pwr_int(struct zd_chip *chip, u8 channel)\n{\n\tu8 value = chip->pwr_int_values[channel - 1];\n\treturn zd_iowrite16_locked(chip, value, ZD_CR31);\n}\n\nstatic int update_pwr_cal(struct zd_chip *chip, u8 channel)\n{\n\tu8 value = chip->pwr_cal_values[channel-1];\n\treturn zd_iowrite16_locked(chip, value, ZD_CR68);\n}\n\nstatic int update_ofdm_cal(struct zd_chip *chip, u8 channel)\n{\n\tstruct zd_ioreq16 ioreqs[3];\n\n\tioreqs[0].addr = ZD_CR67;\n\tioreqs[0].value = chip->ofdm_cal_values[OFDM_36M_INDEX][channel-1];\n\tioreqs[1].addr = ZD_CR66;\n\tioreqs[1].value = chip->ofdm_cal_values[OFDM_48M_INDEX][channel-1];\n\tioreqs[2].addr = ZD_CR65;\n\tioreqs[2].value = chip->ofdm_cal_values[OFDM_54M_INDEX][channel-1];\n\n\treturn zd_iowrite16a_locked(chip, ioreqs, ARRAY_SIZE(ioreqs));\n}\n\nstatic int update_channel_integration_and_calibration(struct zd_chip *chip,\n\t                                              u8 channel)\n{\n\tint r;\n\n\tif (!zd_rf_should_update_pwr_int(&chip->rf))\n\t\treturn 0;\n\n\tr = update_pwr_int(chip, channel);\n\tif (r)\n\t\treturn r;\n\tif (zd_chip_is_zd1211b(chip)) {\n\t\tstatic const struct zd_ioreq16 ioreqs[] = {\n\t\t\t{ ZD_CR69, 0x28 },\n\t\t\t{},\n\t\t\t{ ZD_CR69, 0x2a },\n\t\t};\n\n\t\tr = update_ofdm_cal(chip, channel);\n\t\tif (r)\n\t\t\treturn r;\n\t\tr = update_pwr_cal(chip, channel);\n\t\tif (r)\n\t\t\treturn r;\n\t\tr = zd_iowrite16a_locked(chip, ioreqs, ARRAY_SIZE(ioreqs));\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int patch_cck_gain(struct zd_chip *chip)\n{\n\tint r;\n\tu32 value;\n\n\tif (!chip->patch_cck_gain || !zd_rf_should_patch_cck_gain(&chip->rf))\n\t\treturn 0;\n\n\tZD_ASSERT(mutex_is_locked(&chip->mutex));\n\tr = zd_ioread32_locked(chip, &value, E2P_PHY_REG);\n\tif (r)\n\t\treturn r;\n\tdev_dbg_f(zd_chip_dev(chip), \"patching value %x\\n\", value & 0xff);\n\treturn zd_iowrite16_locked(chip, value & 0xff, ZD_CR47);\n}\n\nint zd_chip_set_channel(struct zd_chip *chip, u8 channel)\n{\n\tint r, t;\n\n\tmutex_lock(&chip->mutex);\n\tr = zd_chip_lock_phy_regs(chip);\n\tif (r)\n\t\tgoto out;\n\tr = zd_rf_set_channel(&chip->rf, channel);\n\tif (r)\n\t\tgoto unlock;\n\tr = update_channel_integration_and_calibration(chip, channel);\n\tif (r)\n\t\tgoto unlock;\n\tr = patch_cck_gain(chip);\n\tif (r)\n\t\tgoto unlock;\n\tr = patch_6m_band_edge(chip, channel);\n\tif (r)\n\t\tgoto unlock;\n\tr = zd_iowrite32_locked(chip, 0, CR_CONFIG_PHILIPS);\nunlock:\n\tt = zd_chip_unlock_phy_regs(chip);\n\tif (t && !r)\n\t\tr = t;\nout:\n\tmutex_unlock(&chip->mutex);\n\treturn r;\n}\n\nu8 zd_chip_get_channel(struct zd_chip *chip)\n{\n\tu8 channel;\n\n\tmutex_lock(&chip->mutex);\n\tchannel = chip->rf.channel;\n\tmutex_unlock(&chip->mutex);\n\treturn channel;\n}\n\nint zd_chip_control_leds(struct zd_chip *chip, enum led_status status)\n{\n\tconst zd_addr_t a[] = {\n\t\tfw_reg_addr(chip, FW_REG_LED_LINK_STATUS),\n\t\tCR_LED,\n\t};\n\n\tint r;\n\tu16 v[ARRAY_SIZE(a)];\n\tstruct zd_ioreq16 ioreqs[ARRAY_SIZE(a)] = {\n\t\t[0] = { fw_reg_addr(chip, FW_REG_LED_LINK_STATUS) },\n\t\t[1] = { CR_LED },\n\t};\n\tu16 other_led;\n\n\tmutex_lock(&chip->mutex);\n\tr = zd_ioread16v_locked(chip, v, (const zd_addr_t *)a, ARRAY_SIZE(a));\n\tif (r)\n\t\tgoto out;\n\n\tother_led = chip->link_led == LED1 ? LED2 : LED1;\n\n\tswitch (status) {\n\tcase ZD_LED_OFF:\n\t\tioreqs[0].value = FW_LINK_OFF;\n\t\tioreqs[1].value = v[1] & ~(LED1|LED2);\n\t\tbreak;\n\tcase ZD_LED_SCANNING:\n\t\tioreqs[0].value = FW_LINK_OFF;\n\t\tioreqs[1].value = v[1] & ~other_led;\n\t\tif ((u32)ktime_get_seconds() % 3 == 0) {\n\t\t\tioreqs[1].value &= ~chip->link_led;\n\t\t} else {\n\t\t\tioreqs[1].value |= chip->link_led;\n\t\t}\n\t\tbreak;\n\tcase ZD_LED_ASSOCIATED:\n\t\tioreqs[0].value = FW_LINK_TX;\n\t\tioreqs[1].value = v[1] & ~other_led;\n\t\tioreqs[1].value |= chip->link_led;\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (v[0] != ioreqs[0].value || v[1] != ioreqs[1].value) {\n\t\tr = zd_iowrite16a_locked(chip, ioreqs, ARRAY_SIZE(ioreqs));\n\t\tif (r)\n\t\t\tgoto out;\n\t}\n\tr = 0;\nout:\n\tmutex_unlock(&chip->mutex);\n\treturn r;\n}\n\nint zd_chip_set_basic_rates(struct zd_chip *chip, u16 cr_rates)\n{\n\tint r;\n\n\tif (cr_rates & ~(CR_RATES_80211B|CR_RATES_80211G))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&chip->mutex);\n\tr = zd_iowrite32_locked(chip, cr_rates, CR_BASIC_RATE_TBL);\n\tmutex_unlock(&chip->mutex);\n\treturn r;\n}\n\nstatic inline u8 zd_rate_from_ofdm_plcp_header(const void *rx_frame)\n{\n\treturn ZD_OFDM | zd_ofdm_plcp_header_rate(rx_frame);\n}\n\n \nu8 zd_rx_rate(const void *rx_frame, const struct rx_status *status)\n{\n\tu8 zd_rate;\n\tif (status->frame_status & ZD_RX_OFDM) {\n\t\tzd_rate = zd_rate_from_ofdm_plcp_header(rx_frame);\n\t} else {\n\t\tswitch (zd_cck_plcp_header_signal(rx_frame)) {\n\t\tcase ZD_CCK_PLCP_SIGNAL_1M:\n\t\t\tzd_rate = ZD_CCK_RATE_1M;\n\t\t\tbreak;\n\t\tcase ZD_CCK_PLCP_SIGNAL_2M:\n\t\t\tzd_rate = ZD_CCK_RATE_2M;\n\t\t\tbreak;\n\t\tcase ZD_CCK_PLCP_SIGNAL_5M5:\n\t\t\tzd_rate = ZD_CCK_RATE_5_5M;\n\t\t\tbreak;\n\t\tcase ZD_CCK_PLCP_SIGNAL_11M:\n\t\t\tzd_rate = ZD_CCK_RATE_11M;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tzd_rate = 0;\n\t\t}\n\t}\n\n\treturn zd_rate;\n}\n\nint zd_chip_switch_radio_on(struct zd_chip *chip)\n{\n\tint r;\n\n\tmutex_lock(&chip->mutex);\n\tr = zd_switch_radio_on(&chip->rf);\n\tmutex_unlock(&chip->mutex);\n\treturn r;\n}\n\nint zd_chip_switch_radio_off(struct zd_chip *chip)\n{\n\tint r;\n\n\tmutex_lock(&chip->mutex);\n\tr = zd_switch_radio_off(&chip->rf);\n\tmutex_unlock(&chip->mutex);\n\treturn r;\n}\n\nint zd_chip_enable_int(struct zd_chip *chip)\n{\n\tint r;\n\n\tmutex_lock(&chip->mutex);\n\tr = zd_usb_enable_int(&chip->usb);\n\tmutex_unlock(&chip->mutex);\n\treturn r;\n}\n\nvoid zd_chip_disable_int(struct zd_chip *chip)\n{\n\tmutex_lock(&chip->mutex);\n\tzd_usb_disable_int(&chip->usb);\n\tmutex_unlock(&chip->mutex);\n\n\t \n\tcancel_work_sync(&zd_chip_to_mac(chip)->process_intr);\n}\n\nint zd_chip_enable_rxtx(struct zd_chip *chip)\n{\n\tint r;\n\n\tmutex_lock(&chip->mutex);\n\tzd_usb_enable_tx(&chip->usb);\n\tr = zd_usb_enable_rx(&chip->usb);\n\tzd_tx_watchdog_enable(&chip->usb);\n\tmutex_unlock(&chip->mutex);\n\treturn r;\n}\n\nvoid zd_chip_disable_rxtx(struct zd_chip *chip)\n{\n\tmutex_lock(&chip->mutex);\n\tzd_tx_watchdog_disable(&chip->usb);\n\tzd_usb_disable_rx(&chip->usb);\n\tzd_usb_disable_tx(&chip->usb);\n\tmutex_unlock(&chip->mutex);\n}\n\nint zd_rfwritev_locked(struct zd_chip *chip,\n\t               const u32* values, unsigned int count, u8 bits)\n{\n\tint r;\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tr = zd_rfwrite_locked(chip, values[i], bits);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\n \nint zd_rfwrite_cr_locked(struct zd_chip *chip, u32 value)\n{\n\tconst struct zd_ioreq16 ioreqs[] = {\n\t\t{ ZD_CR244, (value >> 16) & 0xff },\n\t\t{ ZD_CR243, (value >>  8) & 0xff },\n\t\t{ ZD_CR242,  value        & 0xff },\n\t};\n\tZD_ASSERT(mutex_is_locked(&chip->mutex));\n\treturn zd_iowrite16a_locked(chip, ioreqs, ARRAY_SIZE(ioreqs));\n}\n\nint zd_rfwritev_cr_locked(struct zd_chip *chip,\n\t                  const u32 *values, unsigned int count)\n{\n\tint r;\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tr = zd_rfwrite_cr_locked(chip, values[i]);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nint zd_chip_set_multicast_hash(struct zd_chip *chip,\n\t                       struct zd_mc_hash *hash)\n{\n\tconst struct zd_ioreq32 ioreqs[] = {\n\t\t{ CR_GROUP_HASH_P1, hash->low },\n\t\t{ CR_GROUP_HASH_P2, hash->high },\n\t};\n\n\treturn zd_iowrite32a(chip, ioreqs, ARRAY_SIZE(ioreqs));\n}\n\nu64 zd_chip_get_tsf(struct zd_chip *chip)\n{\n\tint r;\n\tstatic const zd_addr_t aw_pt_bi_addr[] =\n\t\t{ CR_TSF_LOW_PART, CR_TSF_HIGH_PART };\n\tu32 values[2];\n\tu64 tsf;\n\n\tmutex_lock(&chip->mutex);\n\tr = zd_ioread32v_locked(chip, values, (const zd_addr_t *)aw_pt_bi_addr,\n\t                        ARRAY_SIZE(aw_pt_bi_addr));\n\tmutex_unlock(&chip->mutex);\n\tif (r)\n\t\treturn 0;\n\n\ttsf = values[1];\n\ttsf = (tsf << 32) | values[0];\n\n\treturn tsf;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}