{
  "module_name": "zd_rf.c",
  "hash_id": "9fccae4c074611bb4bfa6652843744de827478bffadac2fda8e9d1cd184c5322",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/zydas/zd1211rw/zd_rf.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/string.h>\n\n#include \"zd_def.h\"\n#include \"zd_rf.h\"\n#include \"zd_mac.h\"\n#include \"zd_chip.h\"\n\nstatic const char * const rfs[] = {\n\t[0]\t\t= \"unknown RF0\",\n\t[1]\t\t= \"unknown RF1\",\n\t[UW2451_RF]\t= \"UW2451_RF\",\n\t[UCHIP_RF]\t= \"UCHIP_RF\",\n\t[AL2230_RF]\t= \"AL2230_RF\",\n\t[AL7230B_RF]\t= \"AL7230B_RF\",\n\t[THETA_RF]\t= \"THETA_RF\",\n\t[AL2210_RF]\t= \"AL2210_RF\",\n\t[MAXIM_NEW_RF]\t= \"MAXIM_NEW_RF\",\n\t[UW2453_RF]\t= \"UW2453_RF\",\n\t[AL2230S_RF]\t= \"AL2230S_RF\",\n\t[RALINK_RF]\t= \"RALINK_RF\",\n\t[INTERSIL_RF]\t= \"INTERSIL_RF\",\n\t[RF2959_RF]\t= \"RF2959_RF\",\n\t[MAXIM_NEW2_RF]\t= \"MAXIM_NEW2_RF\",\n\t[PHILIPS_RF]\t= \"PHILIPS_RF\",\n};\n\nconst char *zd_rf_name(u8 type)\n{\n\tif (type & 0xf0)\n\t\ttype = 0;\n\treturn rfs[type];\n}\n\nvoid zd_rf_init(struct zd_rf *rf)\n{\n\tmemset(rf, 0, sizeof(*rf));\n\n\t \n\trf->update_channel_int = 1;\n}\n\nvoid zd_rf_clear(struct zd_rf *rf)\n{\n\tif (rf->clear)\n\t\trf->clear(rf);\n\tZD_MEMCLEAR(rf, sizeof(*rf));\n}\n\nint zd_rf_init_hw(struct zd_rf *rf, u8 type)\n{\n\tint r = 0;\n\tint t;\n\tstruct zd_chip *chip = zd_rf_to_chip(rf);\n\n\tZD_ASSERT(mutex_is_locked(&chip->mutex));\n\tswitch (type) {\n\tcase RF2959_RF:\n\t\tr = zd_rf_init_rf2959(rf);\n\t\tbreak;\n\tcase AL2230_RF:\n\tcase AL2230S_RF:\n\t\tr = zd_rf_init_al2230(rf);\n\t\tbreak;\n\tcase AL7230B_RF:\n\t\tr = zd_rf_init_al7230b(rf);\n\t\tbreak;\n\tcase MAXIM_NEW_RF:\n\tcase UW2453_RF:\n\t\tr = zd_rf_init_uw2453(rf);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(zd_chip_dev(chip),\n\t\t\t\"RF %s %#x is not supported\\n\", zd_rf_name(type), type);\n\t\trf->type = 0;\n\t\treturn -ENODEV;\n\t}\n\n\tif (r)\n\t\treturn r;\n\n\trf->type = type;\n\n\tr = zd_chip_lock_phy_regs(chip);\n\tif (r)\n\t\treturn r;\n\tt = rf->init_hw(rf);\n\tr = zd_chip_unlock_phy_regs(chip);\n\tif (t)\n\t\tr = t;\n\treturn r;\n}\n\nint zd_rf_scnprint_id(struct zd_rf *rf, char *buffer, size_t size)\n{\n\treturn scnprintf(buffer, size, \"%s\", zd_rf_name(rf->type));\n}\n\nint zd_rf_set_channel(struct zd_rf *rf, u8 channel)\n{\n\tint r;\n\n\tZD_ASSERT(mutex_is_locked(&zd_rf_to_chip(rf)->mutex));\n\tif (channel < MIN_CHANNEL24)\n\t\treturn -EINVAL;\n\tif (channel > MAX_CHANNEL24)\n\t\treturn -EINVAL;\n\tdev_dbg_f(zd_chip_dev(zd_rf_to_chip(rf)), \"channel: %d\\n\", channel);\n\n\tr = rf->set_channel(rf, channel);\n\tif (r >= 0)\n\t\trf->channel = channel;\n\treturn r;\n}\n\nint zd_switch_radio_on(struct zd_rf *rf)\n{\n\tint r, t;\n\tstruct zd_chip *chip = zd_rf_to_chip(rf);\n\n\tZD_ASSERT(mutex_is_locked(&chip->mutex));\n\tr = zd_chip_lock_phy_regs(chip);\n\tif (r)\n\t\treturn r;\n\tt = rf->switch_radio_on(rf);\n\tr = zd_chip_unlock_phy_regs(chip);\n\tif (t)\n\t\tr = t;\n\treturn r;\n}\n\nint zd_switch_radio_off(struct zd_rf *rf)\n{\n\tint r, t;\n\tstruct zd_chip *chip = zd_rf_to_chip(rf);\n\n\t \n\tZD_ASSERT(mutex_is_locked(&chip->mutex));\n\tr = zd_chip_lock_phy_regs(chip);\n\tif (r)\n\t\treturn r;\n\tt = rf->switch_radio_off(rf);\n\tr = zd_chip_unlock_phy_regs(chip);\n\tif (t)\n\t\tr = t;\n\treturn r;\n}\n\nint zd_rf_patch_6m_band_edge(struct zd_rf *rf, u8 channel)\n{\n\tif (!rf->patch_6m_band_edge)\n\t\treturn 0;\n\n\treturn rf->patch_6m_band_edge(rf, channel);\n}\n\nint zd_rf_generic_patch_6m(struct zd_rf *rf, u8 channel)\n{\n\treturn zd_chip_generic_patch_6m_band(zd_rf_to_chip(rf), channel);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}