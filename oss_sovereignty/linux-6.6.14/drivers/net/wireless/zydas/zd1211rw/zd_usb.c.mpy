{
  "module_name": "zd_usb.c",
  "hash_id": "7fe7b781b57c18b21338def13db8e5276d544e39272c270748075c237a0b9dbd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/zydas/zd1211rw/zd_usb.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/firmware.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <linux/usb.h>\n#include <linux/workqueue.h>\n#include <linux/module.h>\n#include <net/mac80211.h>\n#include <asm/unaligned.h>\n\n#include \"zd_def.h\"\n#include \"zd_mac.h\"\n#include \"zd_usb.h\"\n\nstatic const struct usb_device_id usb_ids[] = {\n\t \n\t{ USB_DEVICE(0x0105, 0x145f), .driver_info = DEVICE_ZD1211 },\n\t{ USB_DEVICE(0x0586, 0x3401), .driver_info = DEVICE_ZD1211 },\n\t{ USB_DEVICE(0x0586, 0x3402), .driver_info = DEVICE_ZD1211 },\n\t{ USB_DEVICE(0x0586, 0x3407), .driver_info = DEVICE_ZD1211 },\n\t{ USB_DEVICE(0x0586, 0x3409), .driver_info = DEVICE_ZD1211 },\n\t{ USB_DEVICE(0x079b, 0x004a), .driver_info = DEVICE_ZD1211 },\n\t{ USB_DEVICE(0x07b8, 0x6001), .driver_info = DEVICE_ZD1211 },\n\t{ USB_DEVICE(0x0ace, 0x1211), .driver_info = DEVICE_ZD1211 },\n\t{ USB_DEVICE(0x0ace, 0xa211), .driver_info = DEVICE_ZD1211 },\n\t{ USB_DEVICE(0x0b05, 0x170c), .driver_info = DEVICE_ZD1211 },\n\t{ USB_DEVICE(0x0b3b, 0x1630), .driver_info = DEVICE_ZD1211 },\n\t{ USB_DEVICE(0x0b3b, 0x5630), .driver_info = DEVICE_ZD1211 },\n\t{ USB_DEVICE(0x0df6, 0x9071), .driver_info = DEVICE_ZD1211 },\n\t{ USB_DEVICE(0x0df6, 0x9075), .driver_info = DEVICE_ZD1211 },\n\t{ USB_DEVICE(0x126f, 0xa006), .driver_info = DEVICE_ZD1211 },\n\t{ USB_DEVICE(0x129b, 0x1666), .driver_info = DEVICE_ZD1211 },\n\t{ USB_DEVICE(0x13b1, 0x001e), .driver_info = DEVICE_ZD1211 },\n\t{ USB_DEVICE(0x1435, 0x0711), .driver_info = DEVICE_ZD1211 },\n\t{ USB_DEVICE(0x14ea, 0xab10), .driver_info = DEVICE_ZD1211 },\n\t{ USB_DEVICE(0x14ea, 0xab13), .driver_info = DEVICE_ZD1211 },\n\t{ USB_DEVICE(0x157e, 0x300a), .driver_info = DEVICE_ZD1211 },\n\t{ USB_DEVICE(0x157e, 0x300b), .driver_info = DEVICE_ZD1211 },\n\t{ USB_DEVICE(0x157e, 0x3204), .driver_info = DEVICE_ZD1211 },\n\t{ USB_DEVICE(0x157e, 0x3207), .driver_info = DEVICE_ZD1211 },\n\t{ USB_DEVICE(0x1740, 0x2000), .driver_info = DEVICE_ZD1211 },\n\t{ USB_DEVICE(0x6891, 0xa727), .driver_info = DEVICE_ZD1211 },\n\t \n\t{ USB_DEVICE(0x0053, 0x5301), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x0409, 0x0248), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x0411, 0x00da), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x0471, 0x1236), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x0471, 0x1237), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x050d, 0x705c), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x054c, 0x0257), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x0586, 0x340a), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x0586, 0x340f), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x0586, 0x3410), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x0586, 0x3412), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x0586, 0x3413), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x079b, 0x0062), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x07fa, 0x1196), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x083a, 0x4505), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x083a, 0xe501), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x083a, 0xe503), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x083a, 0xe506), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x0ace, 0x1215), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x0ace, 0xb215), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x0b05, 0x171b), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x0baf, 0x0121), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x0cde, 0x001a), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x0df6, 0x0036), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x129b, 0x1667), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x13b1, 0x0024), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x157e, 0x300d), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x1582, 0x6003), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x2019, 0x5303), .driver_info = DEVICE_ZD1211B },\n\t{ USB_DEVICE(0x2019, 0xed01), .driver_info = DEVICE_ZD1211B },\n\t \n\t{ USB_DEVICE(0x0ace, 0x2011), .driver_info = DEVICE_INSTALLER },\n\t{ USB_DEVICE(0x0ace, 0x20ff), .driver_info = DEVICE_INSTALLER },\n\t{}\n};\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"USB driver for devices with the ZD1211 chip.\");\nMODULE_AUTHOR(\"Ulrich Kunitz\");\nMODULE_AUTHOR(\"Daniel Drake\");\nMODULE_VERSION(\"1.0\");\nMODULE_DEVICE_TABLE(usb, usb_ids);\n\n#define FW_ZD1211_PREFIX\t\"zd1211/zd1211_\"\n#define FW_ZD1211B_PREFIX\t\"zd1211/zd1211b_\"\n\nstatic bool check_read_regs(struct zd_usb *usb, struct usb_req_read_regs *req,\n\t\t\t    unsigned int count);\n\n \nstatic void int_urb_complete(struct urb *urb);\n\nstatic int request_fw_file(\n\tconst struct firmware **fw, const char *name, struct device *device)\n{\n\tint r;\n\n\tdev_dbg_f(device, \"fw name %s\\n\", name);\n\n\tr = request_firmware(fw, name, device);\n\tif (r)\n\t\tdev_err(device,\n\t\t       \"Could not load firmware file %s. Error number %d\\n\",\n\t\t       name, r);\n\treturn r;\n}\n\nstatic inline u16 get_bcdDevice(const struct usb_device *udev)\n{\n\treturn le16_to_cpu(udev->descriptor.bcdDevice);\n}\n\nenum upload_code_flags {\n\tREBOOT = 1,\n};\n\n \n#define MAX_TRANSFER_SIZE (USB_MAX_TRANSFER_SIZE & ~1)\n\nstatic int upload_code(struct usb_device *udev,\n\tconst u8 *data, size_t size, u16 code_offset, int flags)\n{\n\tu8 *p;\n\tint r;\n\n\t \n\tp = kmalloc(MAX_TRANSFER_SIZE, GFP_KERNEL);\n\tif (!p) {\n\t\tr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tsize &= ~1;\n\twhile (size > 0) {\n\t\tsize_t transfer_size = size <= MAX_TRANSFER_SIZE ?\n\t\t\tsize : MAX_TRANSFER_SIZE;\n\n\t\tdev_dbg_f(&udev->dev, \"transfer size %zu\\n\", transfer_size);\n\n\t\tmemcpy(p, data, transfer_size);\n\t\tr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_FIRMWARE_DOWNLOAD,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR,\n\t\t\tcode_offset, 0, p, transfer_size, 1000  );\n\t\tif (r < 0) {\n\t\t\tdev_err(&udev->dev,\n\t\t\t       \"USB control request for firmware upload\"\n\t\t\t       \" failed. Error number %d\\n\", r);\n\t\t\tgoto error;\n\t\t}\n\t\ttransfer_size = r & ~1;\n\n\t\tsize -= transfer_size;\n\t\tdata += transfer_size;\n\t\tcode_offset += transfer_size/sizeof(u16);\n\t}\n\n\tif (flags & REBOOT) {\n\t\tu8 ret;\n\n\t\t \n\t\tr = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\tUSB_REQ_FIRMWARE_CONFIRM,\n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR,\n\t\t\t0, 0, p, sizeof(ret), 5000  );\n\t\tif (r != sizeof(ret)) {\n\t\t\tdev_err(&udev->dev,\n\t\t\t\t\"control request firmware confirmation failed.\"\n\t\t\t\t\" Return value %d\\n\", r);\n\t\t\tif (r >= 0)\n\t\t\t\tr = -ENODEV;\n\t\t\tgoto error;\n\t\t}\n\t\tret = p[0];\n\t\tif (ret & 0x80) {\n\t\t\tdev_err(&udev->dev,\n\t\t\t\t\"Internal error while downloading.\"\n\t\t\t\t\" Firmware confirm return value %#04x\\n\",\n\t\t\t\t(unsigned int)ret);\n\t\t\tr = -ENODEV;\n\t\t\tgoto error;\n\t\t}\n\t\tdev_dbg_f(&udev->dev, \"firmware confirm return value %#04x\\n\",\n\t\t\t(unsigned int)ret);\n\t}\n\n\tr = 0;\nerror:\n\tkfree(p);\n\treturn r;\n}\n\nstatic u16 get_word(const void *data, u16 offset)\n{\n\tconst __le16 *p = data;\n\treturn le16_to_cpu(p[offset]);\n}\n\nstatic char *get_fw_name(struct zd_usb *usb, char *buffer, size_t size,\n\t               const char* postfix)\n{\n\tscnprintf(buffer, size, \"%s%s\",\n\t\tusb->is_zd1211b ?\n\t\t\tFW_ZD1211B_PREFIX : FW_ZD1211_PREFIX,\n\t\tpostfix);\n\treturn buffer;\n}\n\nstatic int handle_version_mismatch(struct zd_usb *usb,\n\tconst struct firmware *ub_fw)\n{\n\tstruct usb_device *udev = zd_usb_to_usbdev(usb);\n\tconst struct firmware *ur_fw = NULL;\n\tint offset;\n\tint r = 0;\n\tchar fw_name[128];\n\n\tr = request_fw_file(&ur_fw,\n\t\tget_fw_name(usb, fw_name, sizeof(fw_name), \"ur\"),\n\t\t&udev->dev);\n\tif (r)\n\t\tgoto error;\n\n\tr = upload_code(udev, ur_fw->data, ur_fw->size, FW_START, REBOOT);\n\tif (r)\n\t\tgoto error;\n\n\toffset = (E2P_BOOT_CODE_OFFSET * sizeof(u16));\n\tr = upload_code(udev, ub_fw->data + offset, ub_fw->size - offset,\n\t\tE2P_START + E2P_BOOT_CODE_OFFSET, REBOOT);\n\n\t \nerror:\n\trelease_firmware(ur_fw);\n\treturn r;\n}\n\nstatic int upload_firmware(struct zd_usb *usb)\n{\n\tint r;\n\tu16 fw_bcdDevice;\n\tu16 bcdDevice;\n\tstruct usb_device *udev = zd_usb_to_usbdev(usb);\n\tconst struct firmware *ub_fw = NULL;\n\tconst struct firmware *uph_fw = NULL;\n\tchar fw_name[128];\n\n\tbcdDevice = get_bcdDevice(udev);\n\n\tr = request_fw_file(&ub_fw,\n\t\tget_fw_name(usb, fw_name, sizeof(fw_name), \"ub\"),\n\t\t&udev->dev);\n\tif (r)\n\t\tgoto error;\n\n\tfw_bcdDevice = get_word(ub_fw->data, E2P_DATA_OFFSET);\n\n\tif (fw_bcdDevice != bcdDevice) {\n\t\tdev_info(&udev->dev,\n\t\t\t\"firmware version %#06x and device bootcode version \"\n\t\t\t\"%#06x differ\\n\", fw_bcdDevice, bcdDevice);\n\t\tif (bcdDevice <= 0x4313)\n\t\t\tdev_warn(&udev->dev, \"device has old bootcode, please \"\n\t\t\t\t\"report success or failure\\n\");\n\n\t\tr = handle_version_mismatch(usb, ub_fw);\n\t\tif (r)\n\t\t\tgoto error;\n\t} else {\n\t\tdev_dbg_f(&udev->dev,\n\t\t\t\"firmware device id %#06x is equal to the \"\n\t\t\t\"actual device id\\n\", fw_bcdDevice);\n\t}\n\n\n\tr = request_fw_file(&uph_fw,\n\t\tget_fw_name(usb, fw_name, sizeof(fw_name), \"uphr\"),\n\t\t&udev->dev);\n\tif (r)\n\t\tgoto error;\n\n\tr = upload_code(udev, uph_fw->data, uph_fw->size, FW_START, REBOOT);\n\tif (r) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"Could not upload firmware code uph. Error number %d\\n\",\n\t\t\tr);\n\t}\n\n\t \nerror:\n\trelease_firmware(ub_fw);\n\trelease_firmware(uph_fw);\n\treturn r;\n}\n\nMODULE_FIRMWARE(FW_ZD1211B_PREFIX \"ur\");\nMODULE_FIRMWARE(FW_ZD1211_PREFIX \"ur\");\nMODULE_FIRMWARE(FW_ZD1211B_PREFIX \"ub\");\nMODULE_FIRMWARE(FW_ZD1211_PREFIX \"ub\");\nMODULE_FIRMWARE(FW_ZD1211B_PREFIX \"uphr\");\nMODULE_FIRMWARE(FW_ZD1211_PREFIX \"uphr\");\n\n \nint zd_usb_read_fw(struct zd_usb *usb, zd_addr_t addr, u8 *data, u16 len)\n{\n\tint r;\n\tstruct usb_device *udev = zd_usb_to_usbdev(usb);\n\tu8 *buf;\n\n\t \n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tr = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\tUSB_REQ_FIRMWARE_READ_DATA, USB_DIR_IN | 0x40, addr, 0,\n\t\tbuf, len, 5000);\n\tif (r < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"read over firmware interface failed: %d\\n\", r);\n\t\tgoto exit;\n\t} else if (r != len) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"incomplete read over firmware interface: %d/%d\\n\",\n\t\t\tr, len);\n\t\tr = -EIO;\n\t\tgoto exit;\n\t}\n\tr = 0;\n\tmemcpy(data, buf, len);\nexit:\n\tkfree(buf);\n\treturn r;\n}\n\n#define urb_dev(urb) (&(urb)->dev->dev)\n\nstatic inline void handle_regs_int_override(struct urb *urb)\n{\n\tstruct zd_usb *usb = urb->context;\n\tstruct zd_usb_interrupt *intr = &usb->intr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&intr->lock, flags);\n\tif (atomic_read(&intr->read_regs_enabled)) {\n\t\tatomic_set(&intr->read_regs_enabled, 0);\n\t\tintr->read_regs_int_overridden = 1;\n\t\tcomplete(&intr->read_regs.completion);\n\t}\n\tspin_unlock_irqrestore(&intr->lock, flags);\n}\n\nstatic inline void handle_regs_int(struct urb *urb)\n{\n\tstruct zd_usb *usb = urb->context;\n\tstruct zd_usb_interrupt *intr = &usb->intr;\n\tunsigned long flags;\n\tint len;\n\tu16 int_num;\n\n\tspin_lock_irqsave(&intr->lock, flags);\n\n\tint_num = le16_to_cpu(*(__le16 *)(urb->transfer_buffer+2));\n\tif (int_num == CR_INTERRUPT) {\n\t\tstruct zd_mac *mac = zd_hw_mac(zd_usb_to_hw(urb->context));\n\t\tspin_lock(&mac->lock);\n\t\tmemcpy(&mac->intr_buffer, urb->transfer_buffer,\n\t\t\t\tUSB_MAX_EP_INT_BUFFER);\n\t\tspin_unlock(&mac->lock);\n\t\tschedule_work(&mac->process_intr);\n\t} else if (atomic_read(&intr->read_regs_enabled)) {\n\t\tlen = urb->actual_length;\n\t\tintr->read_regs.length = urb->actual_length;\n\t\tif (len > sizeof(intr->read_regs.buffer))\n\t\t\tlen = sizeof(intr->read_regs.buffer);\n\n\t\tmemcpy(intr->read_regs.buffer, urb->transfer_buffer, len);\n\n\t\t \n\t\tif (!check_read_regs(usb, intr->read_regs.req,\n\t\t\t\t\t\tintr->read_regs.req_count))\n\t\t\tgoto out;\n\n\t\tatomic_set(&intr->read_regs_enabled, 0);\n\t\tintr->read_regs_int_overridden = 0;\n\t\tcomplete(&intr->read_regs.completion);\n\n\t\tgoto out;\n\t}\n\nout:\n\tspin_unlock_irqrestore(&intr->lock, flags);\n\n\t \n\tif (int_num == CR_INTERRUPT && atomic_read(&intr->read_regs_enabled))\n\t\thandle_regs_int_override(urb);\n}\n\nstatic void int_urb_complete(struct urb *urb)\n{\n\tint r;\n\tstruct usb_int_header *hdr;\n\tstruct zd_usb *usb;\n\tstruct zd_usb_interrupt *intr;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ESHUTDOWN:\n\tcase -EINVAL:\n\tcase -ENODEV:\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -EPIPE:\n\t\tdev_dbg_f(urb_dev(urb), \"urb %p error %d\\n\", urb, urb->status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg_f(urb_dev(urb), \"urb %p error %d\\n\", urb, urb->status);\n\t\tgoto resubmit;\n\t}\n\n\tif (urb->actual_length < sizeof(hdr)) {\n\t\tdev_dbg_f(urb_dev(urb), \"error: urb %p to small\\n\", urb);\n\t\tgoto resubmit;\n\t}\n\n\thdr = urb->transfer_buffer;\n\tif (hdr->type != USB_INT_TYPE) {\n\t\tdev_dbg_f(urb_dev(urb), \"error: urb %p wrong type\\n\", urb);\n\t\tgoto resubmit;\n\t}\n\n\t \n\tusb = urb->context;\n\tintr = &usb->intr;\n\tif (hdr->id != USB_INT_ID_REGS && atomic_read(&intr->read_regs_enabled))\n\t\thandle_regs_int_override(urb);\n\n\tswitch (hdr->id) {\n\tcase USB_INT_ID_REGS:\n\t\thandle_regs_int(urb);\n\t\tbreak;\n\tcase USB_INT_ID_RETRY_FAILED:\n\t\tzd_mac_tx_failed(urb);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg_f(urb_dev(urb), \"error: urb %p unknown id %x\\n\", urb,\n\t\t\t(unsigned int)hdr->id);\n\t\tgoto resubmit;\n\t}\n\nresubmit:\n\tr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (r) {\n\t\tdev_dbg_f(urb_dev(urb), \"error: resubmit urb %p err code %d\\n\",\n\t\t\t  urb, r);\n\t\t \n\t}\n\treturn;\n}\n\nstatic inline int int_urb_interval(struct usb_device *udev)\n{\n\tswitch (udev->speed) {\n\tcase USB_SPEED_HIGH:\n\t\treturn 4;\n\tcase USB_SPEED_LOW:\n\t\treturn 10;\n\tcase USB_SPEED_FULL:\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic inline int usb_int_enabled(struct zd_usb *usb)\n{\n\tunsigned long flags;\n\tstruct zd_usb_interrupt *intr = &usb->intr;\n\tstruct urb *urb;\n\n\tspin_lock_irqsave(&intr->lock, flags);\n\turb = intr->urb;\n\tspin_unlock_irqrestore(&intr->lock, flags);\n\treturn urb != NULL;\n}\n\nint zd_usb_enable_int(struct zd_usb *usb)\n{\n\tint r;\n\tstruct usb_device *udev = zd_usb_to_usbdev(usb);\n\tstruct zd_usb_interrupt *intr = &usb->intr;\n\tstruct urb *urb;\n\n\tdev_dbg_f(zd_usb_dev(usb), \"\\n\");\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb) {\n\t\tr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tZD_ASSERT(!irqs_disabled());\n\tspin_lock_irq(&intr->lock);\n\tif (intr->urb) {\n\t\tspin_unlock_irq(&intr->lock);\n\t\tr = 0;\n\t\tgoto error_free_urb;\n\t}\n\tintr->urb = urb;\n\tspin_unlock_irq(&intr->lock);\n\n\tr = -ENOMEM;\n\tintr->buffer = usb_alloc_coherent(udev, USB_MAX_EP_INT_BUFFER,\n\t\t\t\t\t  GFP_KERNEL, &intr->buffer_dma);\n\tif (!intr->buffer) {\n\t\tdev_dbg_f(zd_usb_dev(usb),\n\t\t\t\"couldn't allocate transfer_buffer\\n\");\n\t\tgoto error_set_urb_null;\n\t}\n\n\tusb_fill_int_urb(urb, udev, usb_rcvintpipe(udev, EP_INT_IN),\n\t\t\t intr->buffer, USB_MAX_EP_INT_BUFFER,\n\t\t\t int_urb_complete, usb,\n\t\t\t intr->interval);\n\turb->transfer_dma = intr->buffer_dma;\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\tdev_dbg_f(zd_usb_dev(usb), \"submit urb %p\\n\", intr->urb);\n\tr = usb_submit_urb(urb, GFP_KERNEL);\n\tif (r) {\n\t\tdev_dbg_f(zd_usb_dev(usb),\n\t\t\t \"Couldn't submit urb. Error number %d\\n\", r);\n\t\tgoto error;\n\t}\n\n\treturn 0;\nerror:\n\tusb_free_coherent(udev, USB_MAX_EP_INT_BUFFER,\n\t\t\t  intr->buffer, intr->buffer_dma);\nerror_set_urb_null:\n\tspin_lock_irq(&intr->lock);\n\tintr->urb = NULL;\n\tspin_unlock_irq(&intr->lock);\nerror_free_urb:\n\tusb_free_urb(urb);\nout:\n\treturn r;\n}\n\nvoid zd_usb_disable_int(struct zd_usb *usb)\n{\n\tunsigned long flags;\n\tstruct usb_device *udev = zd_usb_to_usbdev(usb);\n\tstruct zd_usb_interrupt *intr = &usb->intr;\n\tstruct urb *urb;\n\tvoid *buffer;\n\tdma_addr_t buffer_dma;\n\n\tspin_lock_irqsave(&intr->lock, flags);\n\turb = intr->urb;\n\tif (!urb) {\n\t\tspin_unlock_irqrestore(&intr->lock, flags);\n\t\treturn;\n\t}\n\tintr->urb = NULL;\n\tbuffer = intr->buffer;\n\tbuffer_dma = intr->buffer_dma;\n\tintr->buffer = NULL;\n\tspin_unlock_irqrestore(&intr->lock, flags);\n\n\tusb_kill_urb(urb);\n\tdev_dbg_f(zd_usb_dev(usb), \"urb %p killed\\n\", urb);\n\tusb_free_urb(urb);\n\n\tusb_free_coherent(udev, USB_MAX_EP_INT_BUFFER, buffer, buffer_dma);\n}\n\nstatic void handle_rx_packet(struct zd_usb *usb, const u8 *buffer,\n\t\t\t     unsigned int length)\n{\n\tint i;\n\tconst struct rx_length_info *length_info;\n\n\tif (length < sizeof(struct rx_length_info)) {\n\t\t \n\t\tdev_dbg_f(zd_usb_dev(usb), \"invalid, small RX packet : %d\\n\",\n\t\t\t\t\t   length);\n\t\treturn;\n\t}\n\tlength_info = (struct rx_length_info *)\n\t\t(buffer + length - sizeof(struct rx_length_info));\n\n\t \n\tif (get_unaligned_le16(&length_info->tag) == RX_LENGTH_INFO_TAG)\n\t{\n\t\tunsigned int l, k, n;\n\t\tfor (i = 0, l = 0;; i++) {\n\t\t\tk = get_unaligned_le16(&length_info->length[i]);\n\t\t\tif (k == 0)\n\t\t\t\treturn;\n\t\t\tn = l+k;\n\t\t\tif (n > length)\n\t\t\t\treturn;\n\t\t\tzd_mac_rx(zd_usb_to_hw(usb), buffer+l, k);\n\t\t\tif (i >= 2)\n\t\t\t\treturn;\n\t\t\tl = (n+3) & ~3;\n\t\t}\n\t} else {\n\t\tzd_mac_rx(zd_usb_to_hw(usb), buffer, length);\n\t}\n}\n\nstatic void rx_urb_complete(struct urb *urb)\n{\n\tint r;\n\tstruct zd_usb *usb;\n\tstruct zd_usb_rx *rx;\n\tconst u8 *buffer;\n\tunsigned int length;\n\tunsigned long flags;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ESHUTDOWN:\n\tcase -EINVAL:\n\tcase -ENODEV:\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -EPIPE:\n\t\tdev_dbg_f(urb_dev(urb), \"urb %p error %d\\n\", urb, urb->status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg_f(urb_dev(urb), \"urb %p error %d\\n\", urb, urb->status);\n\t\tgoto resubmit;\n\t}\n\n\tbuffer = urb->transfer_buffer;\n\tlength = urb->actual_length;\n\tusb = urb->context;\n\trx = &usb->rx;\n\n\ttasklet_schedule(&rx->reset_timer_tasklet);\n\n\tif (length%rx->usb_packet_size > rx->usb_packet_size-4) {\n\t\t \n\t\tdev_dbg_f(urb_dev(urb), \"*** first fragment ***\\n\");\n\t\tZD_ASSERT(length <= ARRAY_SIZE(rx->fragment));\n\t\tspin_lock_irqsave(&rx->lock, flags);\n\t\tmemcpy(rx->fragment, buffer, length);\n\t\trx->fragment_length = length;\n\t\tspin_unlock_irqrestore(&rx->lock, flags);\n\t\tgoto resubmit;\n\t}\n\n\tspin_lock_irqsave(&rx->lock, flags);\n\tif (rx->fragment_length > 0) {\n\t\t \n\t\tZD_ASSERT(length + rx->fragment_length <=\n\t\t\t  ARRAY_SIZE(rx->fragment));\n\t\tdev_dbg_f(urb_dev(urb), \"*** second fragment ***\\n\");\n\t\tmemcpy(rx->fragment+rx->fragment_length, buffer, length);\n\t\thandle_rx_packet(usb, rx->fragment,\n\t\t\t         rx->fragment_length + length);\n\t\trx->fragment_length = 0;\n\t\tspin_unlock_irqrestore(&rx->lock, flags);\n\t} else {\n\t\tspin_unlock_irqrestore(&rx->lock, flags);\n\t\thandle_rx_packet(usb, buffer, length);\n\t}\n\nresubmit:\n\tr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (r)\n\t\tdev_dbg_f(urb_dev(urb), \"urb %p resubmit error %d\\n\", urb, r);\n}\n\nstatic struct urb *alloc_rx_urb(struct zd_usb *usb)\n{\n\tstruct usb_device *udev = zd_usb_to_usbdev(usb);\n\tstruct urb *urb;\n\tvoid *buffer;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn NULL;\n\tbuffer = usb_alloc_coherent(udev, USB_MAX_RX_SIZE, GFP_KERNEL,\n\t\t\t\t    &urb->transfer_dma);\n\tif (!buffer) {\n\t\tusb_free_urb(urb);\n\t\treturn NULL;\n\t}\n\n\tusb_fill_bulk_urb(urb, udev, usb_rcvbulkpipe(udev, EP_DATA_IN),\n\t\t\t  buffer, USB_MAX_RX_SIZE,\n\t\t\t  rx_urb_complete, usb);\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\treturn urb;\n}\n\nstatic void free_rx_urb(struct urb *urb)\n{\n\tif (!urb)\n\t\treturn;\n\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\tusb_free_urb(urb);\n}\n\nstatic int __zd_usb_enable_rx(struct zd_usb *usb)\n{\n\tint i, r;\n\tstruct zd_usb_rx *rx = &usb->rx;\n\tstruct urb **urbs;\n\n\tdev_dbg_f(zd_usb_dev(usb), \"\\n\");\n\n\tr = -ENOMEM;\n\turbs = kcalloc(RX_URBS_COUNT, sizeof(struct urb *), GFP_KERNEL);\n\tif (!urbs)\n\t\tgoto error;\n\tfor (i = 0; i < RX_URBS_COUNT; i++) {\n\t\turbs[i] = alloc_rx_urb(usb);\n\t\tif (!urbs[i])\n\t\t\tgoto error;\n\t}\n\n\tZD_ASSERT(!irqs_disabled());\n\tspin_lock_irq(&rx->lock);\n\tif (rx->urbs) {\n\t\tspin_unlock_irq(&rx->lock);\n\t\tr = 0;\n\t\tgoto error;\n\t}\n\trx->urbs = urbs;\n\trx->urbs_count = RX_URBS_COUNT;\n\tspin_unlock_irq(&rx->lock);\n\n\tfor (i = 0; i < RX_URBS_COUNT; i++) {\n\t\tr = usb_submit_urb(urbs[i], GFP_KERNEL);\n\t\tif (r)\n\t\t\tgoto error_submit;\n\t}\n\n\treturn 0;\nerror_submit:\n\tfor (i = 0; i < RX_URBS_COUNT; i++) {\n\t\tusb_kill_urb(urbs[i]);\n\t}\n\tspin_lock_irq(&rx->lock);\n\trx->urbs = NULL;\n\trx->urbs_count = 0;\n\tspin_unlock_irq(&rx->lock);\nerror:\n\tif (urbs) {\n\t\tfor (i = 0; i < RX_URBS_COUNT; i++)\n\t\t\tfree_rx_urb(urbs[i]);\n\t}\n\treturn r;\n}\n\nint zd_usb_enable_rx(struct zd_usb *usb)\n{\n\tint r;\n\tstruct zd_usb_rx *rx = &usb->rx;\n\n\tmutex_lock(&rx->setup_mutex);\n\tr = __zd_usb_enable_rx(usb);\n\tmutex_unlock(&rx->setup_mutex);\n\n\tzd_usb_reset_rx_idle_timer(usb);\n\n\treturn r;\n}\n\nstatic void __zd_usb_disable_rx(struct zd_usb *usb)\n{\n\tint i;\n\tunsigned long flags;\n\tstruct urb **urbs;\n\tunsigned int count;\n\tstruct zd_usb_rx *rx = &usb->rx;\n\n\tspin_lock_irqsave(&rx->lock, flags);\n\turbs = rx->urbs;\n\tcount = rx->urbs_count;\n\tspin_unlock_irqrestore(&rx->lock, flags);\n\tif (!urbs)\n\t\treturn;\n\n\tfor (i = 0; i < count; i++) {\n\t\tusb_kill_urb(urbs[i]);\n\t\tfree_rx_urb(urbs[i]);\n\t}\n\tkfree(urbs);\n\n\tspin_lock_irqsave(&rx->lock, flags);\n\trx->urbs = NULL;\n\trx->urbs_count = 0;\n\tspin_unlock_irqrestore(&rx->lock, flags);\n}\n\nvoid zd_usb_disable_rx(struct zd_usb *usb)\n{\n\tstruct zd_usb_rx *rx = &usb->rx;\n\n\tmutex_lock(&rx->setup_mutex);\n\t__zd_usb_disable_rx(usb);\n\tmutex_unlock(&rx->setup_mutex);\n\n\ttasklet_kill(&rx->reset_timer_tasklet);\n\tcancel_delayed_work_sync(&rx->idle_work);\n}\n\nstatic void zd_usb_reset_rx(struct zd_usb *usb)\n{\n\tbool do_reset;\n\tstruct zd_usb_rx *rx = &usb->rx;\n\tunsigned long flags;\n\n\tmutex_lock(&rx->setup_mutex);\n\n\tspin_lock_irqsave(&rx->lock, flags);\n\tdo_reset = rx->urbs != NULL;\n\tspin_unlock_irqrestore(&rx->lock, flags);\n\n\tif (do_reset) {\n\t\t__zd_usb_disable_rx(usb);\n\t\t__zd_usb_enable_rx(usb);\n\t}\n\n\tmutex_unlock(&rx->setup_mutex);\n\n\tif (do_reset)\n\t\tzd_usb_reset_rx_idle_timer(usb);\n}\n\n \nvoid zd_usb_disable_tx(struct zd_usb *usb)\n{\n\tstruct zd_usb_tx *tx = &usb->tx;\n\tunsigned long flags;\n\n\tatomic_set(&tx->enabled, 0);\n\n\t \n\tusb_kill_anchored_urbs(&tx->submitted);\n\n\tspin_lock_irqsave(&tx->lock, flags);\n\tWARN_ON(!skb_queue_empty(&tx->submitted_skbs));\n\tWARN_ON(tx->submitted_urbs != 0);\n\ttx->submitted_urbs = 0;\n\tspin_unlock_irqrestore(&tx->lock, flags);\n\n\t \n}\n\n \nvoid zd_usb_enable_tx(struct zd_usb *usb)\n{\n\tunsigned long flags;\n\tstruct zd_usb_tx *tx = &usb->tx;\n\n\tspin_lock_irqsave(&tx->lock, flags);\n\tatomic_set(&tx->enabled, 1);\n\ttx->submitted_urbs = 0;\n\tieee80211_wake_queues(zd_usb_to_hw(usb));\n\ttx->stopped = 0;\n\tspin_unlock_irqrestore(&tx->lock, flags);\n}\n\nstatic void tx_dec_submitted_urbs(struct zd_usb *usb)\n{\n\tstruct zd_usb_tx *tx = &usb->tx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tx->lock, flags);\n\t--tx->submitted_urbs;\n\tif (tx->stopped && tx->submitted_urbs <= ZD_USB_TX_LOW) {\n\t\tieee80211_wake_queues(zd_usb_to_hw(usb));\n\t\ttx->stopped = 0;\n\t}\n\tspin_unlock_irqrestore(&tx->lock, flags);\n}\n\nstatic void tx_inc_submitted_urbs(struct zd_usb *usb)\n{\n\tstruct zd_usb_tx *tx = &usb->tx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tx->lock, flags);\n\t++tx->submitted_urbs;\n\tif (!tx->stopped && tx->submitted_urbs > ZD_USB_TX_HIGH) {\n\t\tieee80211_stop_queues(zd_usb_to_hw(usb));\n\t\ttx->stopped = 1;\n\t}\n\tspin_unlock_irqrestore(&tx->lock, flags);\n}\n\n \nstatic void tx_urb_complete(struct urb *urb)\n{\n\tint r;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_tx_info *info;\n\tstruct zd_usb *usb;\n\tstruct zd_usb_tx *tx;\n\n\tskb = (struct sk_buff *)urb->context;\n\tinfo = IEEE80211_SKB_CB(skb);\n\t \n\tusb = &zd_hw_mac(info->rate_driver_data[0])->chip.usb;\n\ttx = &usb->tx;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ESHUTDOWN:\n\tcase -EINVAL:\n\tcase -ENODEV:\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -EPIPE:\n\t\tdev_dbg_f(urb_dev(urb), \"urb %p error %d\\n\", urb, urb->status);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg_f(urb_dev(urb), \"urb %p error %d\\n\", urb, urb->status);\n\t\tgoto resubmit;\n\t}\nfree_urb:\n\tskb_unlink(skb, &usb->tx.submitted_skbs);\n\tzd_mac_tx_to_dev(skb, urb->status);\n\tusb_free_urb(urb);\n\ttx_dec_submitted_urbs(usb);\n\treturn;\nresubmit:\n\tusb_anchor_urb(urb, &tx->submitted);\n\tr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (r) {\n\t\tusb_unanchor_urb(urb);\n\t\tdev_dbg_f(urb_dev(urb), \"error resubmit urb %p %d\\n\", urb, r);\n\t\tgoto free_urb;\n\t}\n}\n\n \nint zd_usb_tx(struct zd_usb *usb, struct sk_buff *skb)\n{\n\tint r;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct usb_device *udev = zd_usb_to_usbdev(usb);\n\tstruct urb *urb;\n\tstruct zd_usb_tx *tx = &usb->tx;\n\n\tif (!atomic_read(&tx->enabled)) {\n\t\tr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb) {\n\t\tr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tusb_fill_bulk_urb(urb, udev, usb_sndbulkpipe(udev, EP_DATA_OUT),\n\t\t          skb->data, skb->len, tx_urb_complete, skb);\n\n\tinfo->rate_driver_data[1] = (void *)jiffies;\n\tskb_queue_tail(&tx->submitted_skbs, skb);\n\tusb_anchor_urb(urb, &tx->submitted);\n\n\tr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (r) {\n\t\tdev_dbg_f(zd_usb_dev(usb), \"error submit urb %p %d\\n\", urb, r);\n\t\tusb_unanchor_urb(urb);\n\t\tskb_unlink(skb, &tx->submitted_skbs);\n\t\tgoto error;\n\t}\n\ttx_inc_submitted_urbs(usb);\n\treturn 0;\nerror:\n\tusb_free_urb(urb);\nout:\n\treturn r;\n}\n\nstatic bool zd_tx_timeout(struct zd_usb *usb)\n{\n\tstruct zd_usb_tx *tx = &usb->tx;\n\tstruct sk_buff_head *q = &tx->submitted_skbs;\n\tstruct sk_buff *skb, *skbnext;\n\tstruct ieee80211_tx_info *info;\n\tunsigned long flags, trans_start;\n\tbool have_timedout = false;\n\n\tspin_lock_irqsave(&q->lock, flags);\n\tskb_queue_walk_safe(q, skb, skbnext) {\n\t\tinfo = IEEE80211_SKB_CB(skb);\n\t\ttrans_start = (unsigned long)info->rate_driver_data[1];\n\n\t\tif (time_is_before_jiffies(trans_start + ZD_TX_TIMEOUT)) {\n\t\t\thave_timedout = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&q->lock, flags);\n\n\treturn have_timedout;\n}\n\nstatic void zd_tx_watchdog_handler(struct work_struct *work)\n{\n\tstruct zd_usb *usb =\n\t\tcontainer_of(work, struct zd_usb, tx.watchdog_work.work);\n\tstruct zd_usb_tx *tx = &usb->tx;\n\n\tif (!atomic_read(&tx->enabled) || !tx->watchdog_enabled)\n\t\tgoto out;\n\tif (!zd_tx_timeout(usb))\n\t\tgoto out;\n\n\t \n\tdev_warn(zd_usb_dev(usb), \"TX-stall detected, resetting device...\");\n\n\tusb_queue_reset_device(usb->intf);\n\n\t \n\treturn;\nout:\n\tqueue_delayed_work(zd_workqueue, &tx->watchdog_work,\n\t\t\t   ZD_TX_WATCHDOG_INTERVAL);\n}\n\nvoid zd_tx_watchdog_enable(struct zd_usb *usb)\n{\n\tstruct zd_usb_tx *tx = &usb->tx;\n\n\tif (!tx->watchdog_enabled) {\n\t\tdev_dbg_f(zd_usb_dev(usb), \"\\n\");\n\t\tqueue_delayed_work(zd_workqueue, &tx->watchdog_work,\n\t\t\t\t   ZD_TX_WATCHDOG_INTERVAL);\n\t\ttx->watchdog_enabled = 1;\n\t}\n}\n\nvoid zd_tx_watchdog_disable(struct zd_usb *usb)\n{\n\tstruct zd_usb_tx *tx = &usb->tx;\n\n\tif (tx->watchdog_enabled) {\n\t\tdev_dbg_f(zd_usb_dev(usb), \"\\n\");\n\t\ttx->watchdog_enabled = 0;\n\t\tcancel_delayed_work_sync(&tx->watchdog_work);\n\t}\n}\n\nstatic void zd_rx_idle_timer_handler(struct work_struct *work)\n{\n\tstruct zd_usb *usb =\n\t\tcontainer_of(work, struct zd_usb, rx.idle_work.work);\n\tstruct zd_mac *mac = zd_usb_to_mac(usb);\n\n\tif (!test_bit(ZD_DEVICE_RUNNING, &mac->flags))\n\t\treturn;\n\n\tdev_dbg_f(zd_usb_dev(usb), \"\\n\");\n\n\t \n\tzd_usb_reset_rx(usb);\n}\n\nstatic void zd_usb_reset_rx_idle_timer_tasklet(struct tasklet_struct *t)\n{\n\tstruct zd_usb *usb = from_tasklet(usb, t, rx.reset_timer_tasklet);\n\n\tzd_usb_reset_rx_idle_timer(usb);\n}\n\nvoid zd_usb_reset_rx_idle_timer(struct zd_usb *usb)\n{\n\tstruct zd_usb_rx *rx = &usb->rx;\n\n\tmod_delayed_work(zd_workqueue, &rx->idle_work, ZD_RX_IDLE_INTERVAL);\n}\n\nstatic inline void init_usb_interrupt(struct zd_usb *usb)\n{\n\tstruct zd_usb_interrupt *intr = &usb->intr;\n\n\tspin_lock_init(&intr->lock);\n\tintr->interval = int_urb_interval(zd_usb_to_usbdev(usb));\n\tinit_completion(&intr->read_regs.completion);\n\tatomic_set(&intr->read_regs_enabled, 0);\n\tintr->read_regs.cr_int_addr = cpu_to_le16((u16)CR_INTERRUPT);\n}\n\nstatic inline void init_usb_rx(struct zd_usb *usb)\n{\n\tstruct zd_usb_rx *rx = &usb->rx;\n\n\tspin_lock_init(&rx->lock);\n\tmutex_init(&rx->setup_mutex);\n\tif (interface_to_usbdev(usb->intf)->speed == USB_SPEED_HIGH) {\n\t\trx->usb_packet_size = 512;\n\t} else {\n\t\trx->usb_packet_size = 64;\n\t}\n\tZD_ASSERT(rx->fragment_length == 0);\n\tINIT_DELAYED_WORK(&rx->idle_work, zd_rx_idle_timer_handler);\n\trx->reset_timer_tasklet.func = (void (*))\n\t\t\t\t\tzd_usb_reset_rx_idle_timer_tasklet;\n\trx->reset_timer_tasklet.data = (unsigned long)&rx->reset_timer_tasklet;\n}\n\nstatic inline void init_usb_tx(struct zd_usb *usb)\n{\n\tstruct zd_usb_tx *tx = &usb->tx;\n\n\tspin_lock_init(&tx->lock);\n\tatomic_set(&tx->enabled, 0);\n\ttx->stopped = 0;\n\tskb_queue_head_init(&tx->submitted_skbs);\n\tinit_usb_anchor(&tx->submitted);\n\ttx->submitted_urbs = 0;\n\ttx->watchdog_enabled = 0;\n\tINIT_DELAYED_WORK(&tx->watchdog_work, zd_tx_watchdog_handler);\n}\n\nvoid zd_usb_init(struct zd_usb *usb, struct ieee80211_hw *hw,\n\t         struct usb_interface *intf)\n{\n\tmemset(usb, 0, sizeof(*usb));\n\tusb->intf = usb_get_intf(intf);\n\tusb_set_intfdata(usb->intf, hw);\n\tinit_usb_anchor(&usb->submitted_cmds);\n\tinit_usb_interrupt(usb);\n\tinit_usb_tx(usb);\n\tinit_usb_rx(usb);\n}\n\nvoid zd_usb_clear(struct zd_usb *usb)\n{\n\tusb_set_intfdata(usb->intf, NULL);\n\tusb_put_intf(usb->intf);\n\tZD_MEMCLEAR(usb, sizeof(*usb));\n\t \n}\n\nstatic const char *speed(enum usb_device_speed speed)\n{\n\tswitch (speed) {\n\tcase USB_SPEED_LOW:\n\t\treturn \"low\";\n\tcase USB_SPEED_FULL:\n\t\treturn \"full\";\n\tcase USB_SPEED_HIGH:\n\t\treturn \"high\";\n\tdefault:\n\t\treturn \"unknown speed\";\n\t}\n}\n\nstatic int scnprint_id(struct usb_device *udev, char *buffer, size_t size)\n{\n\treturn scnprintf(buffer, size, \"%04hx:%04hx v%04hx %s\",\n\t\tle16_to_cpu(udev->descriptor.idVendor),\n\t\tle16_to_cpu(udev->descriptor.idProduct),\n\t\tget_bcdDevice(udev),\n\t\tspeed(udev->speed));\n}\n\nint zd_usb_scnprint_id(struct zd_usb *usb, char *buffer, size_t size)\n{\n\tstruct usb_device *udev = interface_to_usbdev(usb->intf);\n\treturn scnprint_id(udev, buffer, size);\n}\n\n#ifdef DEBUG\nstatic void print_id(struct usb_device *udev)\n{\n\tchar buffer[40];\n\n\tscnprint_id(udev, buffer, sizeof(buffer));\n\tbuffer[sizeof(buffer)-1] = 0;\n\tdev_dbg_f(&udev->dev, \"%s\\n\", buffer);\n}\n#else\n#define print_id(udev) do { } while (0)\n#endif\n\nstatic int eject_installer(struct usb_interface *intf)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_host_interface *iface_desc = intf->cur_altsetting;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tunsigned char *cmd;\n\tu8 bulk_out_ep;\n\tint r;\n\n\tif (iface_desc->desc.bNumEndpoints < 2)\n\t\treturn -ENODEV;\n\n\t \n\tfor (r = 1; r >= 0; r--) {\n\t\tendpoint = &iface_desc->endpoint[r].desc;\n\t\tif (usb_endpoint_dir_out(endpoint) &&\n\t\t    usb_endpoint_xfer_bulk(endpoint)) {\n\t\t\tbulk_out_ep = endpoint->bEndpointAddress;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (r == -1) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"zd1211rw: Could not find bulk out endpoint\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tcmd = kzalloc(31, GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tcmd[0] = 0x55;\t \n\tcmd[1] = 0x53;\t \n\tcmd[2] = 0x42;\t \n\tcmd[3] = 0x43;\t \n\tcmd[14] = 6;\t \n\n\tcmd[15] = 0x1b;\t \n\tcmd[19] = 0x2;\t \n\n\tdev_info(&udev->dev, \"Ejecting virtual installer media...\\n\");\n\tr = usb_bulk_msg(udev, usb_sndbulkpipe(udev, bulk_out_ep),\n\t\tcmd, 31, NULL, 2000);\n\tkfree(cmd);\n\tif (r)\n\t\treturn r;\n\n\t \n\n\tusb_set_intfdata(intf, NULL);\n\treturn 0;\n}\n\nint zd_usb_init_hw(struct zd_usb *usb)\n{\n\tint r;\n\tstruct zd_mac *mac = zd_usb_to_mac(usb);\n\n\tdev_dbg_f(zd_usb_dev(usb), \"\\n\");\n\n\tr = upload_firmware(usb);\n\tif (r) {\n\t\tdev_err(zd_usb_dev(usb),\n\t\t       \"couldn't load firmware. Error number %d\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = usb_reset_configuration(zd_usb_to_usbdev(usb));\n\tif (r) {\n\t\tdev_dbg_f(zd_usb_dev(usb),\n\t\t\t\"couldn't reset configuration. Error number %d\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = zd_mac_init_hw(mac->hw);\n\tif (r) {\n\t\tdev_dbg_f(zd_usb_dev(usb),\n\t\t         \"couldn't initialize mac. Error number %d\\n\", r);\n\t\treturn r;\n\t}\n\n\tusb->initialized = 1;\n\treturn 0;\n}\n\nstatic int probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tint r;\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct zd_usb *usb;\n\tstruct ieee80211_hw *hw = NULL;\n\n\tprint_id(udev);\n\n\tif (id->driver_info & DEVICE_INSTALLER)\n\t\treturn eject_installer(intf);\n\n\tswitch (udev->speed) {\n\tcase USB_SPEED_LOW:\n\tcase USB_SPEED_FULL:\n\tcase USB_SPEED_HIGH:\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg_f(&intf->dev, \"Unknown USB speed\\n\");\n\t\tr = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tr = usb_reset_device(udev);\n\tif (r) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"couldn't reset usb device. Error number %d\\n\", r);\n\t\tgoto error;\n\t}\n\n\thw = zd_mac_alloc_hw(intf);\n\tif (hw == NULL) {\n\t\tr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tusb = &zd_hw_mac(hw)->chip.usb;\n\tusb->is_zd1211b = (id->driver_info == DEVICE_ZD1211B) != 0;\n\n\tr = zd_mac_preinit_hw(hw);\n\tif (r) {\n\t\tdev_dbg_f(&intf->dev,\n\t\t         \"couldn't initialize mac. Error number %d\\n\", r);\n\t\tgoto error;\n\t}\n\n\tr = ieee80211_register_hw(hw);\n\tif (r) {\n\t\tdev_dbg_f(&intf->dev,\n\t\t\t \"couldn't register device. Error number %d\\n\", r);\n\t\tgoto error;\n\t}\n\n\tdev_dbg_f(&intf->dev, \"successful\\n\");\n\tdev_info(&intf->dev, \"%s\\n\", wiphy_name(hw->wiphy));\n\treturn 0;\nerror:\n\tusb_reset_device(interface_to_usbdev(intf));\n\tif (hw) {\n\t\tzd_mac_clear(zd_hw_mac(hw));\n\t\tieee80211_free_hw(hw);\n\t}\n\treturn r;\n}\n\nstatic void disconnect(struct usb_interface *intf)\n{\n\tstruct ieee80211_hw *hw = zd_intf_to_hw(intf);\n\tstruct zd_mac *mac;\n\tstruct zd_usb *usb;\n\n\t \n\tif (hw == NULL)\n\t\treturn;\n\n\tmac = zd_hw_mac(hw);\n\tusb = &mac->chip.usb;\n\n\tdev_dbg_f(zd_usb_dev(usb), \"\\n\");\n\n\tieee80211_unregister_hw(hw);\n\n\t \n\tzd_usb_disable_tx(usb);\n\tzd_usb_disable_rx(usb);\n\tzd_usb_disable_int(usb);\n\n\t \n\tusb_reset_device(interface_to_usbdev(intf));\n\n\tzd_mac_clear(mac);\n\tieee80211_free_hw(hw);\n\tdev_dbg(&intf->dev, \"disconnected\\n\");\n}\n\nstatic void zd_usb_resume(struct zd_usb *usb)\n{\n\tstruct zd_mac *mac = zd_usb_to_mac(usb);\n\tint r;\n\n\tdev_dbg_f(zd_usb_dev(usb), \"\\n\");\n\n\tr = zd_op_start(zd_usb_to_hw(usb));\n\tif (r < 0) {\n\t\tdev_warn(zd_usb_dev(usb), \"Device resume failed \"\n\t\t\t \"with error code %d. Retrying...\\n\", r);\n\t\tif (usb->was_running)\n\t\t\tset_bit(ZD_DEVICE_RUNNING, &mac->flags);\n\t\tusb_queue_reset_device(usb->intf);\n\t\treturn;\n\t}\n\n\tif (mac->type != NL80211_IFTYPE_UNSPECIFIED) {\n\t\tr = zd_restore_settings(mac);\n\t\tif (r < 0) {\n\t\t\tdev_dbg(zd_usb_dev(usb),\n\t\t\t\t\"failed to restore settings, %d\\n\", r);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void zd_usb_stop(struct zd_usb *usb)\n{\n\tdev_dbg_f(zd_usb_dev(usb), \"\\n\");\n\n\tzd_op_stop(zd_usb_to_hw(usb));\n\n\tzd_usb_disable_tx(usb);\n\tzd_usb_disable_rx(usb);\n\tzd_usb_disable_int(usb);\n\n\tusb->initialized = 0;\n}\n\nstatic int pre_reset(struct usb_interface *intf)\n{\n\tstruct ieee80211_hw *hw = usb_get_intfdata(intf);\n\tstruct zd_mac *mac;\n\tstruct zd_usb *usb;\n\n\tif (!hw || intf->condition != USB_INTERFACE_BOUND)\n\t\treturn 0;\n\n\tmac = zd_hw_mac(hw);\n\tusb = &mac->chip.usb;\n\n\tusb->was_running = test_bit(ZD_DEVICE_RUNNING, &mac->flags);\n\n\tzd_usb_stop(usb);\n\n\tmutex_lock(&mac->chip.mutex);\n\treturn 0;\n}\n\nstatic int post_reset(struct usb_interface *intf)\n{\n\tstruct ieee80211_hw *hw = usb_get_intfdata(intf);\n\tstruct zd_mac *mac;\n\tstruct zd_usb *usb;\n\n\tif (!hw || intf->condition != USB_INTERFACE_BOUND)\n\t\treturn 0;\n\n\tmac = zd_hw_mac(hw);\n\tusb = &mac->chip.usb;\n\n\tmutex_unlock(&mac->chip.mutex);\n\n\tif (usb->was_running)\n\t\tzd_usb_resume(usb);\n\treturn 0;\n}\n\nstatic struct usb_driver driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= usb_ids,\n\t.probe\t\t= probe,\n\t.disconnect\t= disconnect,\n\t.pre_reset\t= pre_reset,\n\t.post_reset\t= post_reset,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nstruct workqueue_struct *zd_workqueue;\n\nstatic int __init usb_init(void)\n{\n\tint r;\n\n\tpr_debug(\"%s usb_init()\\n\", driver.name);\n\n\tzd_workqueue = create_singlethread_workqueue(driver.name);\n\tif (zd_workqueue == NULL) {\n\t\tpr_err(\"%s couldn't create workqueue\\n\", driver.name);\n\t\treturn -ENOMEM;\n\t}\n\n\tr = usb_register(&driver);\n\tif (r) {\n\t\tdestroy_workqueue(zd_workqueue);\n\t\tpr_err(\"%s usb_register() failed. Error number %d\\n\",\n\t\t       driver.name, r);\n\t\treturn r;\n\t}\n\n\tpr_debug(\"%s initialized\\n\", driver.name);\n\treturn 0;\n}\n\nstatic void __exit usb_exit(void)\n{\n\tpr_debug(\"%s usb_exit()\\n\", driver.name);\n\tusb_deregister(&driver);\n\tdestroy_workqueue(zd_workqueue);\n}\n\nmodule_init(usb_init);\nmodule_exit(usb_exit);\n\nstatic int zd_ep_regs_out_msg(struct usb_device *udev, void *data, int len,\n\t\t\t      int *actual_length, int timeout)\n{\n\t \n\tstruct usb_host_endpoint *ep;\n\tunsigned int pipe;\n\n\tpipe = usb_sndintpipe(udev, EP_REGS_OUT);\n\tep = usb_pipe_endpoint(udev, pipe);\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\tif (usb_endpoint_xfer_int(&ep->desc)) {\n\t\treturn usb_interrupt_msg(udev, pipe, data, len,\n\t\t\t\t\t actual_length, timeout);\n\t} else {\n\t\tpipe = usb_sndbulkpipe(udev, EP_REGS_OUT);\n\t\treturn usb_bulk_msg(udev, pipe, data, len, actual_length,\n\t\t\t\t    timeout);\n\t}\n}\n\nstatic void prepare_read_regs_int(struct zd_usb *usb,\n\t\t\t\t  struct usb_req_read_regs *req,\n\t\t\t\t  unsigned int count)\n{\n\tstruct zd_usb_interrupt *intr = &usb->intr;\n\n\tspin_lock_irq(&intr->lock);\n\tatomic_set(&intr->read_regs_enabled, 1);\n\tintr->read_regs.req = req;\n\tintr->read_regs.req_count = count;\n\treinit_completion(&intr->read_regs.completion);\n\tspin_unlock_irq(&intr->lock);\n}\n\nstatic void disable_read_regs_int(struct zd_usb *usb)\n{\n\tstruct zd_usb_interrupt *intr = &usb->intr;\n\n\tspin_lock_irq(&intr->lock);\n\tatomic_set(&intr->read_regs_enabled, 0);\n\tspin_unlock_irq(&intr->lock);\n}\n\nstatic bool check_read_regs(struct zd_usb *usb, struct usb_req_read_regs *req,\n\t\t\t    unsigned int count)\n{\n\tint i;\n\tstruct zd_usb_interrupt *intr = &usb->intr;\n\tstruct read_regs_int *rr = &intr->read_regs;\n\tstruct usb_int_regs *regs = (struct usb_int_regs *)rr->buffer;\n\n\t \n\tif (rr->length < struct_size(regs, regs, count)) {\n\t\tdev_dbg_f(zd_usb_dev(usb),\n\t\t\t \"error: actual length %d less than expected %zu\\n\",\n\t\t\t rr->length, struct_size(regs, regs, count));\n\t\treturn false;\n\t}\n\n\tif (rr->length > sizeof(rr->buffer)) {\n\t\tdev_dbg_f(zd_usb_dev(usb),\n\t\t\t \"error: actual length %d exceeds buffer size %zu\\n\",\n\t\t\t rr->length, sizeof(rr->buffer));\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tstruct reg_data *rd = &regs->regs[i];\n\t\tif (rd->addr != req->addr[i]) {\n\t\t\tdev_dbg_f(zd_usb_dev(usb),\n\t\t\t\t \"rd[%d] addr %#06hx expected %#06hx\\n\", i,\n\t\t\t\t le16_to_cpu(rd->addr),\n\t\t\t\t le16_to_cpu(req->addr[i]));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic int get_results(struct zd_usb *usb, u16 *values,\n\t\t       struct usb_req_read_regs *req, unsigned int count,\n\t\t       bool *retry)\n{\n\tint r;\n\tint i;\n\tstruct zd_usb_interrupt *intr = &usb->intr;\n\tstruct read_regs_int *rr = &intr->read_regs;\n\tstruct usb_int_regs *regs = (struct usb_int_regs *)rr->buffer;\n\n\tspin_lock_irq(&intr->lock);\n\n\tr = -EIO;\n\n\t \n\t*retry = !!intr->read_regs_int_overridden;\n\tif (*retry)\n\t\tgoto error_unlock;\n\n\tif (!check_read_regs(usb, req, count)) {\n\t\tdev_dbg_f(zd_usb_dev(usb), \"error: invalid read regs\\n\");\n\t\tgoto error_unlock;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tstruct reg_data *rd = &regs->regs[i];\n\t\tvalues[i] = le16_to_cpu(rd->value);\n\t}\n\n\tr = 0;\nerror_unlock:\n\tspin_unlock_irq(&intr->lock);\n\treturn r;\n}\n\nint zd_usb_ioread16v(struct zd_usb *usb, u16 *values,\n\t             const zd_addr_t *addresses, unsigned int count)\n{\n\tint r, i, req_len, actual_req_len, try_count = 0;\n\tstruct usb_device *udev;\n\tstruct usb_req_read_regs *req = NULL;\n\tunsigned long timeout;\n\tbool retry = false;\n\n\tif (count < 1) {\n\t\tdev_dbg_f(zd_usb_dev(usb), \"error: count is zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (count > USB_MAX_IOREAD16_COUNT) {\n\t\tdev_dbg_f(zd_usb_dev(usb),\n\t\t\t \"error: count %u exceeds possible max %u\\n\",\n\t\t\t count, USB_MAX_IOREAD16_COUNT);\n\t\treturn -EINVAL;\n\t}\n\tif (!usb_int_enabled(usb)) {\n\t\tdev_dbg_f(zd_usb_dev(usb),\n\t\t\t  \"error: usb interrupt not enabled\\n\");\n\t\treturn -EWOULDBLOCK;\n\t}\n\n\tZD_ASSERT(mutex_is_locked(&zd_usb_to_chip(usb)->mutex));\n\tBUILD_BUG_ON(sizeof(struct usb_req_read_regs) + USB_MAX_IOREAD16_COUNT *\n\t\t     sizeof(__le16) > sizeof(usb->req_buf));\n\tBUG_ON(sizeof(struct usb_req_read_regs) + count * sizeof(__le16) >\n\t       sizeof(usb->req_buf));\n\n\treq_len = sizeof(struct usb_req_read_regs) + count * sizeof(__le16);\n\treq = (void *)usb->req_buf;\n\n\treq->id = cpu_to_le16(USB_REQ_READ_REGS);\n\tfor (i = 0; i < count; i++)\n\t\treq->addr[i] = cpu_to_le16((u16)addresses[i]);\n\nretry_read:\n\ttry_count++;\n\tudev = zd_usb_to_usbdev(usb);\n\tprepare_read_regs_int(usb, req, count);\n\tr = zd_ep_regs_out_msg(udev, req, req_len, &actual_req_len, 50  );\n\tif (r) {\n\t\tdev_dbg_f(zd_usb_dev(usb),\n\t\t\t\"error in zd_ep_regs_out_msg(). Error number %d\\n\", r);\n\t\tgoto error;\n\t}\n\tif (req_len != actual_req_len) {\n\t\tdev_dbg_f(zd_usb_dev(usb), \"error in zd_ep_regs_out_msg()\\n\"\n\t\t\t\" req_len %d != actual_req_len %d\\n\",\n\t\t\treq_len, actual_req_len);\n\t\tr = -EIO;\n\t\tgoto error;\n\t}\n\n\ttimeout = wait_for_completion_timeout(&usb->intr.read_regs.completion,\n\t\t\t\t\t      msecs_to_jiffies(50));\n\tif (!timeout) {\n\t\tdisable_read_regs_int(usb);\n\t\tdev_dbg_f(zd_usb_dev(usb), \"read timed out\\n\");\n\t\tr = -ETIMEDOUT;\n\t\tgoto error;\n\t}\n\n\tr = get_results(usb, values, req, count, &retry);\n\tif (retry && try_count < 20) {\n\t\tdev_dbg_f(zd_usb_dev(usb), \"read retry, tries so far: %d\\n\",\n\t\t\t\ttry_count);\n\t\tgoto retry_read;\n\t}\nerror:\n\treturn r;\n}\n\nstatic void iowrite16v_urb_complete(struct urb *urb)\n{\n\tstruct zd_usb *usb = urb->context;\n\n\tif (urb->status && !usb->cmd_error)\n\t\tusb->cmd_error = urb->status;\n\n\tif (!usb->cmd_error &&\n\t\t\turb->actual_length != urb->transfer_buffer_length)\n\t\tusb->cmd_error = -EIO;\n}\n\nstatic int zd_submit_waiting_urb(struct zd_usb *usb, bool last)\n{\n\tint r = 0;\n\tstruct urb *urb = usb->urb_async_waiting;\n\n\tif (!urb)\n\t\treturn 0;\n\n\tusb->urb_async_waiting = NULL;\n\n\tif (!last)\n\t\turb->transfer_flags |= URB_NO_INTERRUPT;\n\n\tusb_anchor_urb(urb, &usb->submitted_cmds);\n\tr = usb_submit_urb(urb, GFP_KERNEL);\n\tif (r) {\n\t\tusb_unanchor_urb(urb);\n\t\tdev_dbg_f(zd_usb_dev(usb),\n\t\t\t\"error in usb_submit_urb(). Error number %d\\n\", r);\n\t\tgoto error;\n\t}\n\n\t \nerror:\n\tusb_free_urb(urb);\n\treturn r;\n}\n\nvoid zd_usb_iowrite16v_async_start(struct zd_usb *usb)\n{\n\tZD_ASSERT(usb_anchor_empty(&usb->submitted_cmds));\n\tZD_ASSERT(usb->urb_async_waiting == NULL);\n\tZD_ASSERT(!usb->in_async);\n\n\tZD_ASSERT(mutex_is_locked(&zd_usb_to_chip(usb)->mutex));\n\n\tusb->in_async = 1;\n\tusb->cmd_error = 0;\n\tusb->urb_async_waiting = NULL;\n}\n\nint zd_usb_iowrite16v_async_end(struct zd_usb *usb, unsigned int timeout)\n{\n\tint r;\n\n\tZD_ASSERT(mutex_is_locked(&zd_usb_to_chip(usb)->mutex));\n\tZD_ASSERT(usb->in_async);\n\n\t \n\tr = zd_submit_waiting_urb(usb, true);\n\tif (r) {\n\t\tdev_dbg_f(zd_usb_dev(usb),\n\t\t\t\"error in zd_submit_waiting_usb(). \"\n\t\t\t\"Error number %d\\n\", r);\n\n\t\tusb_kill_anchored_urbs(&usb->submitted_cmds);\n\t\tgoto error;\n\t}\n\n\tif (timeout)\n\t\ttimeout = usb_wait_anchor_empty_timeout(&usb->submitted_cmds,\n\t\t\t\t\t\t\ttimeout);\n\tif (!timeout) {\n\t\tusb_kill_anchored_urbs(&usb->submitted_cmds);\n\t\tif (usb->cmd_error == -ENOENT) {\n\t\t\tdev_dbg_f(zd_usb_dev(usb), \"timed out\");\n\t\t\tr = -ETIMEDOUT;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tr = usb->cmd_error;\nerror:\n\tusb->in_async = 0;\n\treturn r;\n}\n\nint zd_usb_iowrite16v_async(struct zd_usb *usb, const struct zd_ioreq16 *ioreqs,\n\t\t\t    unsigned int count)\n{\n\tint r;\n\tstruct usb_device *udev;\n\tstruct usb_req_write_regs *req = NULL;\n\tint i, req_len;\n\tstruct urb *urb;\n\tstruct usb_host_endpoint *ep;\n\n\tZD_ASSERT(mutex_is_locked(&zd_usb_to_chip(usb)->mutex));\n\tZD_ASSERT(usb->in_async);\n\n\tif (count == 0)\n\t\treturn 0;\n\tif (count > USB_MAX_IOWRITE16_COUNT) {\n\t\tdev_dbg_f(zd_usb_dev(usb),\n\t\t\t\"error: count %u exceeds possible max %u\\n\",\n\t\t\tcount, USB_MAX_IOWRITE16_COUNT);\n\t\treturn -EINVAL;\n\t}\n\n\tudev = zd_usb_to_usbdev(usb);\n\n\tep = usb_pipe_endpoint(udev, usb_sndintpipe(udev, EP_REGS_OUT));\n\tif (!ep)\n\t\treturn -ENOENT;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\treq_len = struct_size(req, reg_writes, count);\n\treq = kmalloc(req_len, GFP_KERNEL);\n\tif (!req) {\n\t\tr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\treq->id = cpu_to_le16(USB_REQ_WRITE_REGS);\n\tfor (i = 0; i < count; i++) {\n\t\tstruct reg_data *rw  = &req->reg_writes[i];\n\t\trw->addr = cpu_to_le16((u16)ioreqs[i].addr);\n\t\trw->value = cpu_to_le16(ioreqs[i].value);\n\t}\n\n\t \n\tif (usb_endpoint_xfer_int(&ep->desc))\n\t\tusb_fill_int_urb(urb, udev, usb_sndintpipe(udev, EP_REGS_OUT),\n\t\t\t\t req, req_len, iowrite16v_urb_complete, usb,\n\t\t\t\t ep->desc.bInterval);\n\telse\n\t\tusb_fill_bulk_urb(urb, udev, usb_sndbulkpipe(udev, EP_REGS_OUT),\n\t\t\t\t  req, req_len, iowrite16v_urb_complete, usb);\n\n\turb->transfer_flags |= URB_FREE_BUFFER;\n\n\t \n\tr = zd_submit_waiting_urb(usb, false);\n\tif (r) {\n\t\tdev_dbg_f(zd_usb_dev(usb),\n\t\t\t\"error in zd_submit_waiting_usb(). \"\n\t\t\t\"Error number %d\\n\", r);\n\t\tgoto error;\n\t}\n\n\t \n\tusb->urb_async_waiting = urb;\n\treturn 0;\nerror:\n\tusb_free_urb(urb);\n\treturn r;\n}\n\nint zd_usb_iowrite16v(struct zd_usb *usb, const struct zd_ioreq16 *ioreqs,\n\t\t\tunsigned int count)\n{\n\tint r;\n\n\tzd_usb_iowrite16v_async_start(usb);\n\tr = zd_usb_iowrite16v_async(usb, ioreqs, count);\n\tif (r) {\n\t\tzd_usb_iowrite16v_async_end(usb, 0);\n\t\treturn r;\n\t}\n\treturn zd_usb_iowrite16v_async_end(usb, 50  );\n}\n\nint zd_usb_rfwrite(struct zd_usb *usb, u32 value, u8 bits)\n{\n\tint r;\n\tstruct usb_device *udev;\n\tstruct usb_req_rfwrite *req = NULL;\n\tint i, req_len, actual_req_len;\n\tu16 bit_value_template;\n\n\tif (bits < USB_MIN_RFWRITE_BIT_COUNT) {\n\t\tdev_dbg_f(zd_usb_dev(usb),\n\t\t\t\"error: bits %d are smaller than\"\n\t\t\t\" USB_MIN_RFWRITE_BIT_COUNT %d\\n\",\n\t\t\tbits, USB_MIN_RFWRITE_BIT_COUNT);\n\t\treturn -EINVAL;\n\t}\n\tif (bits > USB_MAX_RFWRITE_BIT_COUNT) {\n\t\tdev_dbg_f(zd_usb_dev(usb),\n\t\t\t\"error: bits %d exceed USB_MAX_RFWRITE_BIT_COUNT %d\\n\",\n\t\t\tbits, USB_MAX_RFWRITE_BIT_COUNT);\n\t\treturn -EINVAL;\n\t}\n#ifdef DEBUG\n\tif (value & (~0UL << bits)) {\n\t\tdev_dbg_f(zd_usb_dev(usb),\n\t\t\t\"error: value %#09x has bits >= %d set\\n\",\n\t\t\tvalue, bits);\n\t\treturn -EINVAL;\n\t}\n#endif  \n\n\tdev_dbg_f(zd_usb_dev(usb), \"value %#09x bits %d\\n\", value, bits);\n\n\tr = zd_usb_ioread16(usb, &bit_value_template, ZD_CR203);\n\tif (r) {\n\t\tdev_dbg_f(zd_usb_dev(usb),\n\t\t\t\"error %d: Couldn't read ZD_CR203\\n\", r);\n\t\treturn r;\n\t}\n\tbit_value_template &= ~(RF_IF_LE|RF_CLK|RF_DATA);\n\n\tZD_ASSERT(mutex_is_locked(&zd_usb_to_chip(usb)->mutex));\n\tBUILD_BUG_ON(sizeof(struct usb_req_rfwrite) +\n\t\t     USB_MAX_RFWRITE_BIT_COUNT * sizeof(__le16) >\n\t\t     sizeof(usb->req_buf));\n\tBUG_ON(sizeof(struct usb_req_rfwrite) + bits * sizeof(__le16) >\n\t       sizeof(usb->req_buf));\n\n\treq_len = sizeof(struct usb_req_rfwrite) + bits * sizeof(__le16);\n\treq = (void *)usb->req_buf;\n\n\treq->id = cpu_to_le16(USB_REQ_WRITE_RF);\n\t \n\treq->value = cpu_to_le16(2);\n\treq->bits = cpu_to_le16(bits);\n\n\tfor (i = 0; i < bits; i++) {\n\t\tu16 bv = bit_value_template;\n\t\tif (value & (1 << (bits-1-i)))\n\t\t\tbv |= RF_DATA;\n\t\treq->bit_values[i] = cpu_to_le16(bv);\n\t}\n\n\tudev = zd_usb_to_usbdev(usb);\n\tr = zd_ep_regs_out_msg(udev, req, req_len, &actual_req_len, 50  );\n\tif (r) {\n\t\tdev_dbg_f(zd_usb_dev(usb),\n\t\t\t\"error in zd_ep_regs_out_msg(). Error number %d\\n\", r);\n\t\tgoto out;\n\t}\n\tif (req_len != actual_req_len) {\n\t\tdev_dbg_f(zd_usb_dev(usb), \"error in zd_ep_regs_out_msg()\"\n\t\t\t\" req_len %d != actual_req_len %d\\n\",\n\t\t\treq_len, actual_req_len);\n\t\tr = -EIO;\n\t\tgoto out;\n\t}\n\n\t \nout:\n\treturn r;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}