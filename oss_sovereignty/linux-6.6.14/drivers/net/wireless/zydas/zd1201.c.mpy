{
  "module_name": "zd1201.c",
  "hash_id": "24955f4d5076a97c0ac4abc54c28a71dd9cfbba4d2692914fd8355a1cd6a736d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/zydas/zd1201.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/slab.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/wireless.h>\n#include <net/cfg80211.h>\n#include <net/iw_handler.h>\n#include <linux/string.h>\n#include <linux/if_arp.h>\n#include <linux/firmware.h>\n#include \"zd1201.h\"\n\nstatic const struct usb_device_id zd1201_table[] = {\n\t{USB_DEVICE(0x0586, 0x3400)},  \n\t{USB_DEVICE(0x0ace, 0x1201)},  \n\t{USB_DEVICE(0x050d, 0x6051)},  \n\t{USB_DEVICE(0x0db0, 0x6823)},  \n\t{USB_DEVICE(0x1044, 0x8004)},  \n\t{USB_DEVICE(0x1044, 0x8005)},  \n\t{}\n};\n\nstatic int ap;\t \n\n#define ZD1201_VERSION\t\"0.15\"\n\nMODULE_AUTHOR(\"Jeroen Vreeken <pe1rxq@amsat.org>\");\nMODULE_DESCRIPTION(\"Driver for ZyDAS ZD1201 based USB Wireless adapters\");\nMODULE_VERSION(ZD1201_VERSION);\nMODULE_LICENSE(\"GPL\");\nmodule_param(ap, int, 0);\nMODULE_PARM_DESC(ap, \"If non-zero Access Point firmware will be loaded\");\nMODULE_DEVICE_TABLE(usb, zd1201_table);\n\n\nstatic int zd1201_fw_upload(struct usb_device *dev, int apfw)\n{\n\tconst struct firmware *fw_entry;\n\tconst char *data;\n\tunsigned long len;\n\tint err;\n\tunsigned char ret;\n\tchar *buf;\n\tchar *fwfile;\n\n\tif (apfw)\n\t\tfwfile = \"zd1201-ap.fw\";\n\telse\n\t\tfwfile = \"zd1201.fw\";\n\n\terr = request_firmware(&fw_entry, fwfile, &dev->dev);\n\tif (err) {\n\t\tdev_err(&dev->dev, \"Failed to load %s firmware file!\\n\", fwfile);\n\t\tdev_err(&dev->dev, \"Make sure the hotplug firmware loader is installed.\\n\");\n\t\tdev_err(&dev->dev, \"Goto http://linux-lc100020.sourceforge.net for more info.\\n\");\n\t\treturn err;\n\t}\n\n\tdata = fw_entry->data;\n        len = fw_entry->size;\n\n\tbuf = kmalloc(1024, GFP_ATOMIC);\n\tif (!buf) {\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\t\n\twhile (len > 0) {\n\t\tint translen = (len > 1024) ? 1024 : len;\n\t\tmemcpy(buf, data, translen);\n\n\t\terr = usb_control_msg(dev, usb_sndctrlpipe(dev, 0), 0,\n\t\t    USB_DIR_OUT | 0x40, 0, 0, buf, translen,\n\t\t    ZD1201_FW_TIMEOUT);\n\t\tif (err < 0)\n\t\t\tgoto exit;\n\n\t\tlen -= translen;\n\t\tdata += translen;\n\t}\n                                        \n\terr = usb_control_msg(dev, usb_sndctrlpipe(dev, 0), 0x2,\n\t    USB_DIR_OUT | 0x40, 0, 0, NULL, 0, ZD1201_FW_TIMEOUT);\n\tif (err < 0)\n\t\tgoto exit;\n\n\terr = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), 0x4,\n\t    USB_DIR_IN | 0x40, 0, 0, buf, sizeof(ret), ZD1201_FW_TIMEOUT);\n\tif (err < 0)\n\t\tgoto exit;\n\n\tmemcpy(&ret, buf, sizeof(ret));\n\n\tif (ret & 0x80) {\n\t\terr = -EIO;\n\t\tgoto exit;\n\t}\n\n\terr = 0;\nexit:\n\tkfree(buf);\n\trelease_firmware(fw_entry);\n\treturn err;\n}\n\nMODULE_FIRMWARE(\"zd1201-ap.fw\");\nMODULE_FIRMWARE(\"zd1201.fw\");\n\nstatic void zd1201_usbfree(struct urb *urb)\n{\n\tstruct zd1201 *zd = urb->context;\n\n\tswitch(urb->status) {\n\t\tcase -EILSEQ:\n\t\tcase -ENODEV:\n\t\tcase -ETIME:\n\t\tcase -ENOENT:\n\t\tcase -EPIPE:\n\t\tcase -EOVERFLOW:\n\t\tcase -ESHUTDOWN:\n\t\t\tdev_warn(&zd->usb->dev, \"%s: urb failed: %d\\n\", \n\t\t\t    zd->dev->name, urb->status);\n\t}\n\n\tkfree(urb->transfer_buffer);\n\tusb_free_urb(urb);\n}\n\n \nstatic int zd1201_docmd(struct zd1201 *zd, int cmd, int parm0,\n\t\t\tint parm1, int parm2)\n{\n\tunsigned char *command;\n\tint ret;\n\tstruct urb *urb;\n\n\tcommand = kmalloc(16, GFP_ATOMIC);\n\tif (!command)\n\t\treturn -ENOMEM;\n\n\t*((__le32*)command) = cpu_to_le32(ZD1201_USB_CMDREQ);\n\t*((__le16*)&command[4]) = cpu_to_le16(cmd);\n\t*((__le16*)&command[6]) = cpu_to_le16(parm0);\n\t*((__le16*)&command[8]) = cpu_to_le16(parm1);\n\t*((__le16*)&command[10])= cpu_to_le16(parm2);\n\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb) {\n\t\tkfree(command);\n\t\treturn -ENOMEM;\n\t}\n\tusb_fill_bulk_urb(urb, zd->usb, usb_sndbulkpipe(zd->usb, zd->endp_out2),\n\t\t\t  command, 16, zd1201_usbfree, zd);\n\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (ret) {\n\t\tkfree(command);\n\t\tusb_free_urb(urb);\n\t}\n\n\treturn ret;\n}\n\n \nstatic void zd1201_usbtx(struct urb *urb)\n{\n\tstruct zd1201 *zd = urb->context;\n\tnetif_wake_queue(zd->dev);\n}\n\n \nstatic void zd1201_usbrx(struct urb *urb)\n{\n\tstruct zd1201 *zd = urb->context;\n\tint free = 0;\n\tunsigned char *data = urb->transfer_buffer;\n\tstruct sk_buff *skb;\n\tunsigned char type;\n\n\tif (!zd)\n\t\treturn;\n\n\tswitch(urb->status) {\n\t\tcase -EILSEQ:\n\t\tcase -ENODEV:\n\t\tcase -ETIME:\n\t\tcase -ENOENT:\n\t\tcase -EPIPE:\n\t\tcase -EOVERFLOW:\n\t\tcase -ESHUTDOWN:\n\t\t\tdev_warn(&zd->usb->dev, \"%s: rx urb failed: %d\\n\",\n\t\t\t    zd->dev->name, urb->status);\n\t\t\tfree = 1;\n\t\t\tgoto exit;\n\t}\n\t\n\tif (urb->status != 0 || urb->actual_length == 0)\n\t\tgoto resubmit;\n\n\ttype = data[0];\n\tif (type == ZD1201_PACKET_EVENTSTAT || type == ZD1201_PACKET_RESOURCE) {\n\t\tmemcpy(zd->rxdata, data, urb->actual_length);\n\t\tzd->rxlen = urb->actual_length;\n\t\tzd->rxdatas = 1;\n\t\twake_up(&zd->rxdataq);\n\t}\n\t \n\tif (type == ZD1201_PACKET_INQUIRE) {\n\t\tint i = 0;\n\t\tunsigned short infotype, copylen;\n\t\tinfotype = le16_to_cpu(*(__le16*)&data[6]);\n\n\t\tif (infotype == ZD1201_INF_LINKSTATUS) {\n\t\t\tshort linkstatus;\n\n\t\t\tlinkstatus = le16_to_cpu(*(__le16*)&data[8]);\n\t\t\tswitch(linkstatus) {\n\t\t\t\tcase 1:\n\t\t\t\t\tnetif_carrier_on(zd->dev);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tnetif_carrier_off(zd->dev);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tnetif_carrier_off(zd->dev);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tnetif_carrier_on(zd->dev);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tnetif_carrier_off(zd->dev);\n\t\t\t}\n\t\t\tgoto resubmit;\n\t\t}\n\t\tif (infotype == ZD1201_INF_ASSOCSTATUS) {\n\t\t\tshort status = le16_to_cpu(*(__le16*)(data+8));\n\t\t\tint event;\n\t\t\tunion iwreq_data wrqu;\n\n\t\t\tswitch (status) {\n\t\t\t\tcase ZD1201_ASSOCSTATUS_STAASSOC:\n\t\t\t\tcase ZD1201_ASSOCSTATUS_REASSOC:\n\t\t\t\t\tevent = IWEVREGISTERED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ZD1201_ASSOCSTATUS_DISASSOC:\n\t\t\t\tcase ZD1201_ASSOCSTATUS_ASSOCFAIL:\n\t\t\t\tcase ZD1201_ASSOCSTATUS_AUTHFAIL:\n\t\t\t\tdefault:\n\t\t\t\t\tevent = IWEVEXPIRED;\n\t\t\t}\n\t\t\tmemcpy(wrqu.addr.sa_data, data+10, ETH_ALEN);\n\t\t\twrqu.addr.sa_family = ARPHRD_ETHER;\n\n\t\t\t \n\t\t\twireless_send_event(zd->dev, event, &wrqu, NULL);\n\n\t\t\tgoto resubmit;\n\t\t}\n\t\tif (infotype == ZD1201_INF_AUTHREQ) {\n\t\t\tunion iwreq_data wrqu;\n\n\t\t\tmemcpy(wrqu.addr.sa_data, data+8, ETH_ALEN);\n\t\t\twrqu.addr.sa_family = ARPHRD_ETHER;\n\t\t\t \n\t\t\twireless_send_event(zd->dev, IWEVEXPIRED, &wrqu, NULL);\n\t\t\tgoto resubmit;\n\t\t}\n\t\t \n\t\tzd->rxlen = 0;\n\t\twhile (i < urb->actual_length) {\n\t\t\tcopylen = le16_to_cpu(*(__le16*)&data[i+2]);\n\t\t\t \n\t\t\tif (copylen+zd->rxlen > sizeof(zd->rxdata))\n\t\t\t\tbreak;\n\t\t\tmemcpy(zd->rxdata+zd->rxlen, data+i+4, copylen);\n\t\t\tzd->rxlen += copylen;\n\t\t\ti += 64;\n\t\t}\n\t\tif (i >= urb->actual_length) {\n\t\t\tzd->rxdatas = 1;\n\t\t\twake_up(&zd->rxdataq);\n\t\t}\n\t\tgoto  resubmit;\n\t}\n\t \n\tif (data[urb->actual_length-1] == ZD1201_PACKET_RXDATA) {\n\t\tint datalen = urb->actual_length-1;\n\t\tunsigned short len, fc, seq;\n\n\t\tlen = ntohs(*(__be16 *)&data[datalen-2]);\n\t\tif (len>datalen)\n\t\t\tlen=datalen;\n\t\tfc = le16_to_cpu(*(__le16 *)&data[datalen-16]);\n\t\tseq = le16_to_cpu(*(__le16 *)&data[datalen-24]);\n\n\t\tif (zd->monitor) {\n\t\t\tif (datalen < 24)\n\t\t\t\tgoto resubmit;\n\t\t\tif (!(skb = dev_alloc_skb(datalen+24)))\n\t\t\t\tgoto resubmit;\n\t\t\t\n\t\t\tskb_put_data(skb, &data[datalen - 16], 2);\n\t\t\tskb_put_data(skb, &data[datalen - 2], 2);\n\t\t\tskb_put_data(skb, &data[datalen - 14], 6);\n\t\t\tskb_put_data(skb, &data[datalen - 22], 6);\n\t\t\tskb_put_data(skb, &data[datalen - 8], 6);\n\t\t\tskb_put_data(skb, &data[datalen - 24], 2);\n\t\t\tskb_put_data(skb, data, len);\n\t\t\tskb->protocol = eth_type_trans(skb, zd->dev);\n\t\t\tzd->dev->stats.rx_packets++;\n\t\t\tzd->dev->stats.rx_bytes += skb->len;\n\t\t\tnetif_rx(skb);\n\t\t\tgoto resubmit;\n\t\t}\n\t\t\t\n\t\tif ((seq & IEEE80211_SCTL_FRAG) ||\n\t\t    (fc & IEEE80211_FCTL_MOREFRAGS)) {\n\t\t\tstruct zd1201_frag *frag = NULL;\n\t\t\tchar *ptr;\n\n\t\t\tif (datalen<14)\n\t\t\t\tgoto resubmit;\n\t\t\tif ((seq & IEEE80211_SCTL_FRAG) == 0) {\n\t\t\t\tfrag = kmalloc(sizeof(*frag), GFP_ATOMIC);\n\t\t\t\tif (!frag)\n\t\t\t\t\tgoto resubmit;\n\t\t\t\tskb = dev_alloc_skb(IEEE80211_MAX_DATA_LEN +14+2);\n\t\t\t\tif (!skb) {\n\t\t\t\t\tkfree(frag);\n\t\t\t\t\tgoto resubmit;\n\t\t\t\t}\n\t\t\t\tfrag->skb = skb;\n\t\t\t\tfrag->seq = seq & IEEE80211_SCTL_SEQ;\n\t\t\t\tskb_reserve(skb, 2);\n\t\t\t\tskb_put_data(skb, &data[datalen - 14], 12);\n\t\t\t\tskb_put_data(skb, &data[6], 2);\n\t\t\t\tskb_put_data(skb, data + 8, len);\n\t\t\t\thlist_add_head(&frag->fnode, &zd->fraglist);\n\t\t\t\tgoto resubmit;\n\t\t\t}\n\t\t\thlist_for_each_entry(frag, &zd->fraglist, fnode)\n\t\t\t\tif (frag->seq == (seq&IEEE80211_SCTL_SEQ))\n\t\t\t\t\tbreak;\n\t\t\tif (!frag)\n\t\t\t\tgoto resubmit;\n\t\t\tskb = frag->skb;\n\t\t\tptr = skb_put(skb, len);\n\t\t\tif (ptr)\n\t\t\t\tmemcpy(ptr, data+8, len);\n\t\t\tif (fc & IEEE80211_FCTL_MOREFRAGS)\n\t\t\t\tgoto resubmit;\n\t\t\thlist_del_init(&frag->fnode);\n\t\t\tkfree(frag);\n\t\t} else {\n\t\t\tif (datalen<14)\n\t\t\t\tgoto resubmit;\n\t\t\tskb = dev_alloc_skb(len + 14 + 2);\n\t\t\tif (!skb)\n\t\t\t\tgoto resubmit;\n\t\t\tskb_reserve(skb, 2);\n\t\t\tskb_put_data(skb, &data[datalen - 14], 12);\n\t\t\tskb_put_data(skb, &data[6], 2);\n\t\t\tskb_put_data(skb, data + 8, len);\n\t\t}\n\t\tskb->protocol = eth_type_trans(skb, zd->dev);\n\t\tzd->dev->stats.rx_packets++;\n\t\tzd->dev->stats.rx_bytes += skb->len;\n\t\tnetif_rx(skb);\n\t}\nresubmit:\n\tmemset(data, 0, ZD1201_RXSIZE);\n\n\turb->status = 0;\n\turb->dev = zd->usb;\n\tif(usb_submit_urb(urb, GFP_ATOMIC))\n\t\tfree = 1;\n\nexit:\n\tif (free) {\n\t\tzd->rxlen = 0;\n\t\tzd->rxdatas = 1;\n\t\twake_up(&zd->rxdataq);\n\t\tkfree(urb->transfer_buffer);\n\t}\n}\n\nstatic int zd1201_getconfig(struct zd1201 *zd, int rid, void *riddata,\n\tunsigned int riddatalen)\n{\n\tint err;\n\tint i = 0;\n\tint code;\n\tint rid_fid;\n\tint length;\n\tunsigned char *pdata;\n\n\tzd->rxdatas = 0;\n\terr = zd1201_docmd(zd, ZD1201_CMDCODE_ACCESS, rid, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\twait_event_interruptible(zd->rxdataq, zd->rxdatas);\n\tif (!zd->rxlen)\n\t\treturn -EIO;\n\n\tcode = le16_to_cpu(*(__le16*)(&zd->rxdata[4]));\n\trid_fid = le16_to_cpu(*(__le16*)(&zd->rxdata[6]));\n\tlength = le16_to_cpu(*(__le16*)(&zd->rxdata[8]));\n\tif (length > zd->rxlen)\n\t\tlength = zd->rxlen-6;\n\n\t \n\tif ((code & ZD1201_ACCESSBIT) != ZD1201_ACCESSBIT || rid_fid != rid )\n\t\treturn -EINVAL;\n\n\t \n\tif (riddatalen != (length - 4)) {\n\t\tdev_dbg(&zd->usb->dev, \"riddatalen mismatches, expected=%u, (packet=%u) length=%u, rid=0x%04X, rid_fid=0x%04X\\n\",\n\t\t    riddatalen, zd->rxlen, length, rid, rid_fid);\n\t\treturn -ENODATA;\n\t}\n\n\tzd->rxdatas = 0;\n\t \t\t\t\n\terr = zd1201_docmd(zd, ZD1201_CMDCODE_SETRXRID, rid, 0, length);\n\tif (err)\n\t\treturn err;\n\n\t \n\twait_event_interruptible(zd->rxdataq, zd->rxdatas);\n\tif (!zd->rxlen)\n\t\treturn -EIO;\n\n\tif (zd->rxdata[zd->rxlen - 1] != ZD1201_PACKET_RESOURCE) {\n\t\tdev_dbg(&zd->usb->dev, \"Packet type mismatch: 0x%x not 0x3\\n\",\n\t\t    zd->rxdata[zd->rxlen-1]);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpdata = zd->rxdata;\n\tlength = zd->rxlen;\n\n\tdo {\n\t\tint actual_length;\n\n\t\tactual_length = (length > 64) ? 64 : length;\n\n\t\tif (pdata[0] != 0x3) {\n\t\t\tdev_dbg(&zd->usb->dev, \"Rx Resource packet type error: %02X\\n\",\n\t\t\t    pdata[0]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (actual_length != 64) {\n\t\t\t \n\t\t\tactual_length--;\n\t\t}\n\n\t\t \n\t\tif (i == 0) {\n\t\t\tpdata += 8;\n\t\t\tactual_length -= 8;\n\t\t} else {\n\t\t\tpdata += 4;\n\t\t\tactual_length -= 4;\n\t\t}\n\t\t\n\t\tmemcpy(riddata, pdata, actual_length);\n\t\triddata += actual_length;\n\t\tpdata += actual_length;\n\t\tlength -= 64;\n\t\ti++;\n\t} while (length > 0);\n\n\treturn 0;\n}\n\n \nstatic int zd1201_setconfig(struct zd1201 *zd, int rid, const void *buf, int len, int wait)\n{\n\tint err;\n\tunsigned char *request;\n\tint reqlen;\n\tchar seq=0;\n\tstruct urb *urb;\n\tgfp_t gfp_mask = wait ? GFP_NOIO : GFP_ATOMIC;\n\n\tlen += 4;\t\t\t \n\n\tzd->rxdatas = 0;\n\tzd->rxlen = 0;\n\tfor (seq=0; len > 0; seq++) {\n\t\trequest = kzalloc(16, gfp_mask);\n\t\tif (!request)\n\t\t\treturn -ENOMEM;\n\t\turb = usb_alloc_urb(0, gfp_mask);\n\t\tif (!urb) {\n\t\t\tkfree(request);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\treqlen = len>12 ? 12 : len;\n\t\trequest[0] = ZD1201_USB_RESREQ;\n\t\trequest[1] = seq;\n\t\trequest[2] = 0;\n\t\trequest[3] = 0;\n\t\tif (request[1] == 0) {\n\t\t\t \n\t\t\t*(__le16*)&request[4] = cpu_to_le16((len-2+1)/2);\n\t\t\t*(__le16*)&request[6] = cpu_to_le16(rid);\n\t\t\tmemcpy(request+8, buf, reqlen-4);\n\t\t\tbuf += reqlen-4;\n\t\t} else {\n\t\t\tmemcpy(request+4, buf, reqlen);\n\t\t\tbuf += reqlen;\n\t\t}\n\n\t\tlen -= reqlen;\n\n\t\tusb_fill_bulk_urb(urb, zd->usb, usb_sndbulkpipe(zd->usb,\n\t\t    zd->endp_out2), request, 16, zd1201_usbfree, zd);\n\t\terr = usb_submit_urb(urb, gfp_mask);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\trequest = kmalloc(16, gfp_mask);\n\tif (!request)\n\t\treturn -ENOMEM;\n\turb = usb_alloc_urb(0, gfp_mask);\n\tif (!urb) {\n\t\tkfree(request);\n\t\treturn -ENOMEM;\n\t}\n\t*((__le32*)request) = cpu_to_le32(ZD1201_USB_CMDREQ);\n\t*((__le16*)&request[4]) = \n\t    cpu_to_le16(ZD1201_CMDCODE_ACCESS|ZD1201_ACCESSBIT);\n\t*((__le16*)&request[6]) = cpu_to_le16(rid);\n\t*((__le16*)&request[8]) = cpu_to_le16(0);\n\t*((__le16*)&request[10]) = cpu_to_le16(0);\n\tusb_fill_bulk_urb(urb, zd->usb, usb_sndbulkpipe(zd->usb, zd->endp_out2),\n\t     request, 16, zd1201_usbfree, zd);\n\terr = usb_submit_urb(urb, gfp_mask);\n\tif (err)\n\t\tgoto err;\n\t\n\tif (wait) {\n\t\twait_event_interruptible(zd->rxdataq, zd->rxdatas);\n\t\tif (!zd->rxlen || le16_to_cpu(*(__le16*)&zd->rxdata[6]) != rid) {\n\t\t\tdev_dbg(&zd->usb->dev, \"wrong or no RID received\\n\");\n\t\t}\n\t}\n\n\treturn 0;\nerr:\n\tkfree(request);\n\tusb_free_urb(urb);\n\treturn err;\n}\n\nstatic inline int zd1201_getconfig16(struct zd1201 *zd, int rid, short *val)\n{\n\tint err;\n\t__le16 zdval;\n\n\terr = zd1201_getconfig(zd, rid, &zdval, sizeof(__le16));\n\tif (err)\n\t\treturn err;\n\t*val = le16_to_cpu(zdval);\n\treturn 0;\n}\n\nstatic inline int zd1201_setconfig16(struct zd1201 *zd, int rid, short val)\n{\n\t__le16 zdval = cpu_to_le16(val);\n\treturn (zd1201_setconfig(zd, rid, &zdval, sizeof(__le16), 1));\n}\n\nstatic int zd1201_drvr_start(struct zd1201 *zd)\n{\n\tint err, i;\n\tshort max;\n\t__le16 zdmax;\n\tunsigned char *buffer;\n\n\tbuffer = kzalloc(ZD1201_RXSIZE, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tusb_fill_bulk_urb(zd->rx_urb, zd->usb, \n\t    usb_rcvbulkpipe(zd->usb, zd->endp_in), buffer, ZD1201_RXSIZE,\n\t    zd1201_usbrx, zd);\n\n\terr = usb_submit_urb(zd->rx_urb, GFP_KERNEL);\n\tif (err)\n\t\tgoto err_buffer;\n\n\terr = zd1201_docmd(zd, ZD1201_CMDCODE_INIT, 0, 0, 0);\n\tif (err)\n\t\tgoto err_urb;\n\n\terr = zd1201_getconfig(zd, ZD1201_RID_CNFMAXTXBUFFERNUMBER, &zdmax,\n\t    sizeof(__le16));\n\tif (err)\n\t\tgoto err_urb;\n\n\tmax = le16_to_cpu(zdmax);\n\tfor (i=0; i<max; i++) {\n\t\terr = zd1201_docmd(zd, ZD1201_CMDCODE_ALLOC, 1514, 0, 0);\n\t\tif (err)\n\t\t\tgoto err_urb;\n\t}\n\n\treturn 0;\n\nerr_urb:\n\tusb_kill_urb(zd->rx_urb);\n\treturn err;\nerr_buffer:\n\tkfree(buffer);\n\treturn err;\n}\n\n \nstatic int zd1201_enable(struct zd1201 *zd)\n{\n\tint err;\n\n\tif (zd->mac_enabled)\n\t\treturn 0;\n\n\terr = zd1201_docmd(zd, ZD1201_CMDCODE_ENABLE, 0, 0, 0);\n\tif (!err)\n\t\tzd->mac_enabled = 1;\n\n\tif (zd->monitor)\n\t\terr = zd1201_setconfig16(zd, ZD1201_RID_PROMISCUOUSMODE, 1);\n\n\treturn err;\n}\n\nstatic int zd1201_disable(struct zd1201 *zd)\n{\n\tint err;\n\n\tif (!zd->mac_enabled)\n\t\treturn 0;\n\tif (zd->monitor) {\n\t\terr = zd1201_setconfig16(zd, ZD1201_RID_PROMISCUOUSMODE, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = zd1201_docmd(zd, ZD1201_CMDCODE_DISABLE, 0, 0, 0);\n\tif (!err)\n\t\tzd->mac_enabled = 0;\n\treturn err;\n}\n\nstatic int zd1201_mac_reset(struct zd1201 *zd)\n{\n\tif (!zd->mac_enabled)\n\t\treturn 0;\n\tzd1201_disable(zd);\n\treturn zd1201_enable(zd);\n}\n\nstatic int zd1201_join(struct zd1201 *zd, char *essid, int essidlen)\n{\n\tint err, val;\n\tchar buf[IW_ESSID_MAX_SIZE+2];\n\n\terr = zd1201_disable(zd);\n\tif (err)\n\t\treturn err;\n\n\tval = ZD1201_CNFAUTHENTICATION_OPENSYSTEM;\n\tval |= ZD1201_CNFAUTHENTICATION_SHAREDKEY;\n\terr = zd1201_setconfig16(zd, ZD1201_RID_CNFAUTHENTICATION, val);\n\tif (err)\n\t\treturn err;\n\n\t*(__le16 *)buf = cpu_to_le16(essidlen);\n\tmemcpy(buf+2, essid, essidlen);\n\tif (!zd->ap) {\t \n\t\terr = zd1201_setconfig(zd, ZD1201_RID_CNFDESIREDSSID, buf,\n\t\t    IW_ESSID_MAX_SIZE+2, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\t \n\t\terr = zd1201_setconfig(zd, ZD1201_RID_CNFOWNSSID, buf,\n\t\t    IW_ESSID_MAX_SIZE+2, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = zd1201_setconfig(zd, ZD1201_RID_CNFOWNMACADDR, \n\t    zd->dev->dev_addr, zd->dev->addr_len, 1);\n\tif (err)\n\t\treturn err;\n\n\terr = zd1201_enable(zd);\n\tif (err)\n\t\treturn err;\n\n\tmsleep(100);\n\treturn 0;\n}\n\nstatic int zd1201_net_open(struct net_device *dev)\n{\n\tstruct zd1201 *zd = netdev_priv(dev);\n\n\t \n\tif (!zd->mac_enabled)\n\t\tzd1201_join(zd, zd->essid, zd->essidlen);\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\nstatic int zd1201_net_stop(struct net_device *dev)\n{\n\tnetif_stop_queue(dev);\n\treturn 0;\n}\n\n \nstatic netdev_tx_t zd1201_hard_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t\tstruct net_device *dev)\n{\n\tstruct zd1201 *zd = netdev_priv(dev);\n\tunsigned char *txbuf = zd->txdata;\n\tint txbuflen, pad = 0, err;\n\tstruct urb *urb = zd->tx_urb;\n\n\tif (!zd->mac_enabled || zd->monitor) {\n\t\tdev->stats.tx_dropped++;\n\t\tkfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\tnetif_stop_queue(dev);\n\n\ttxbuflen = skb->len + 8 + 1;\n\tif (txbuflen%64 == 0) {\n\t\tpad = 1;\n\t\ttxbuflen++;\n\t}\n\ttxbuf[0] = 0xAA;\n\ttxbuf[1] = 0xAA;\n\ttxbuf[2] = 0x03;\n\ttxbuf[3] = 0x00;\t \n\ttxbuf[4] = 0x00;\n\ttxbuf[5] = 0x00;\n\n\tskb_copy_from_linear_data_offset(skb, 12, txbuf + 6, skb->len - 12);\n\tif (pad)\n\t\ttxbuf[skb->len-12+6]=0;\n\tskb_copy_from_linear_data(skb, txbuf + skb->len - 12 + 6 + pad, 12);\n\t*(__be16*)&txbuf[skb->len+6+pad] = htons(skb->len-12+6);\n\ttxbuf[txbuflen-1] = 0;\n\n\tusb_fill_bulk_urb(urb, zd->usb, usb_sndbulkpipe(zd->usb, zd->endp_out),\n\t    txbuf, txbuflen, zd1201_usbtx, zd);\n\n\terr = usb_submit_urb(zd->tx_urb, GFP_ATOMIC);\n\tif (err) {\n\t\tdev->stats.tx_errors++;\n\t\tnetif_start_queue(dev);\n\t} else {\n\t\tdev->stats.tx_packets++;\n\t\tdev->stats.tx_bytes += skb->len;\n\t}\n\tkfree_skb(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void zd1201_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct zd1201 *zd = netdev_priv(dev);\n\n\tif (!zd)\n\t\treturn;\n\tdev_warn(&zd->usb->dev, \"%s: TX timeout, shooting down urb\\n\",\n\t    dev->name);\n\tusb_unlink_urb(zd->tx_urb);\n\tdev->stats.tx_errors++;\n\t \n\tnetif_trans_update(dev);  \n}\n\nstatic int zd1201_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct sockaddr *addr = p;\n\tstruct zd1201 *zd = netdev_priv(dev);\n\tint err;\n\n\tif (!zd)\n\t\treturn -ENODEV;\n\n\terr = zd1201_setconfig(zd, ZD1201_RID_CNFOWNMACADDR, \n\t    addr->sa_data, dev->addr_len, 1);\n\tif (err)\n\t\treturn err;\n\teth_hw_addr_set(dev, addr->sa_data);\n\n\treturn zd1201_mac_reset(zd);\n}\n\nstatic struct iw_statistics *zd1201_get_wireless_stats(struct net_device *dev)\n{\n\tstruct zd1201 *zd = netdev_priv(dev);\n\n\treturn &zd->iwstats;\n}\n\nstatic void zd1201_set_multicast(struct net_device *dev)\n{\n\tstruct zd1201 *zd = netdev_priv(dev);\n\tstruct netdev_hw_addr *ha;\n\tunsigned char reqbuf[ETH_ALEN*ZD1201_MAXMULTI];\n\tint i;\n\n\tif (netdev_mc_count(dev) > ZD1201_MAXMULTI)\n\t\treturn;\n\n\ti = 0;\n\tnetdev_for_each_mc_addr(ha, dev)\n\t\tmemcpy(reqbuf + i++ * ETH_ALEN, ha->addr, ETH_ALEN);\n\tzd1201_setconfig(zd, ZD1201_RID_CNFGROUPADDRESS, reqbuf,\n\t\t\t netdev_mc_count(dev) * ETH_ALEN, 0);\n}\n\nstatic int zd1201_config_commit(struct net_device *dev, \n\tstruct iw_request_info *info, union iwreq_data *wrqu, char *essid)\n{\n\tstruct zd1201 *zd = netdev_priv(dev);\n\n\treturn zd1201_mac_reset(zd);\n}\n\nstatic int zd1201_get_name(struct net_device *dev,\n\tstruct iw_request_info *info, union iwreq_data *wrqu, char *extra)\n{\n\tstrcpy(wrqu->name, \"IEEE 802.11b\");\n\treturn 0;\n}\n\nstatic int zd1201_set_freq(struct net_device *dev,\n\tstruct iw_request_info *info, union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_freq *freq = &wrqu->freq;\n\tstruct zd1201 *zd = netdev_priv(dev);\n\tshort channel = 0;\n\tint err;\n\n\tif (freq->e == 0)\n\t\tchannel = freq->m;\n\telse\n\t\tchannel = ieee80211_frequency_to_channel(freq->m);\n\n\terr = zd1201_setconfig16(zd, ZD1201_RID_CNFOWNCHANNEL, channel);\n\tif (err)\n\t\treturn err;\n\n\tzd1201_mac_reset(zd);\n\n\treturn 0;\n}\n\nstatic int zd1201_get_freq(struct net_device *dev,\n\tstruct iw_request_info *info, union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_freq *freq = &wrqu->freq;\n\tstruct zd1201 *zd = netdev_priv(dev);\n\tshort channel;\n\tint err;\n\n\terr = zd1201_getconfig16(zd, ZD1201_RID_CNFOWNCHANNEL, &channel);\n\tif (err)\n\t\treturn err;\n\tfreq->e = 0;\n\tfreq->m = channel;\n\n\treturn 0;\n}\n\nstatic int zd1201_set_mode(struct net_device *dev,\n\tstruct iw_request_info *info, union iwreq_data *wrqu, char *extra)\n{\n\t__u32 *mode = &wrqu->mode;\n\tstruct zd1201 *zd = netdev_priv(dev);\n\tshort porttype, monitor = 0;\n\tunsigned char buffer[IW_ESSID_MAX_SIZE+2];\n\tint err;\n\n\tif (zd->ap) {\n\t\tif (*mode != IW_MODE_MASTER)\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\terr = zd1201_setconfig16(zd, ZD1201_RID_PROMISCUOUSMODE, 0);\n\tif (err)\n\t\treturn err;\n\tzd->dev->type = ARPHRD_ETHER;\n\tswitch(*mode) {\n\t\tcase IW_MODE_MONITOR:\n\t\t\tmonitor = 1;\n\t\t\tzd->dev->type = ARPHRD_IEEE80211;\n\t\t\t \n\t\t\tzd1201_join(zd, \"\\0-*#\\0\", 5);\n\t\t\t \n\t\t\tfallthrough;\n\t\tcase 8:  \n\t\t\tporttype = ZD1201_PORTTYPE_PSEUDOIBSS;\n\t\t\tbreak;\n\t\tcase IW_MODE_ADHOC:\n\t\t\tporttype = ZD1201_PORTTYPE_IBSS;\n\t\t\tbreak;\n\t\tcase IW_MODE_INFRA:\n\t\t\tporttype = ZD1201_PORTTYPE_BSS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\terr = zd1201_setconfig16(zd, ZD1201_RID_CNFPORTTYPE, porttype);\n\tif (err)\n\t\treturn err;\n\tif (zd->monitor && !monitor) {\n\t\t\tzd1201_disable(zd);\n\t\t\t*(__le16 *)buffer = cpu_to_le16(zd->essidlen);\n\t\t\tmemcpy(buffer+2, zd->essid, zd->essidlen);\n\t\t\terr = zd1201_setconfig(zd, ZD1201_RID_CNFDESIREDSSID,\n\t\t\t    buffer, IW_ESSID_MAX_SIZE+2, 1);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t}\n\tzd->monitor = monitor;\n\t \n\tzd1201_mac_reset(zd);\n\n\treturn 0;\n}\n\nstatic int zd1201_get_mode(struct net_device *dev,\n\tstruct iw_request_info *info, union iwreq_data *wrqu, char *extra)\n{\n\t__u32 *mode = &wrqu->mode;\n\tstruct zd1201 *zd = netdev_priv(dev);\n\tshort porttype;\n\tint err;\n\n\terr = zd1201_getconfig16(zd, ZD1201_RID_CNFPORTTYPE, &porttype);\n\tif (err)\n\t\treturn err;\n\tswitch(porttype) {\n\t\tcase ZD1201_PORTTYPE_IBSS:\n\t\t\t*mode = IW_MODE_ADHOC;\n\t\t\tbreak;\n\t\tcase ZD1201_PORTTYPE_BSS:\n\t\t\t*mode = IW_MODE_INFRA;\n\t\t\tbreak;\n\t\tcase ZD1201_PORTTYPE_WDS:\n\t\t\t*mode = IW_MODE_REPEAT;\n\t\t\tbreak;\n\t\tcase ZD1201_PORTTYPE_PSEUDOIBSS:\n\t\t\t*mode = 8; \n\t\t\tbreak;\n\t\tcase ZD1201_PORTTYPE_AP:\n\t\t\t*mode = IW_MODE_MASTER;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&zd->usb->dev, \"Unknown porttype: %d\\n\",\n\t\t\t    porttype);\n\t\t\t*mode = IW_MODE_AUTO;\n\t}\n\tif (zd->monitor)\n\t\t*mode = IW_MODE_MONITOR;\n\n\treturn 0;\n}\n\nstatic int zd1201_get_range(struct net_device *dev,\n\tstruct iw_request_info *info, union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_point *wrq = &wrqu->data;\n\tstruct iw_range *range = (struct iw_range *)extra;\n\n\twrq->length = sizeof(struct iw_range);\n\tmemset(range, 0, sizeof(struct iw_range));\n\trange->we_version_compiled = WIRELESS_EXT;\n\trange->we_version_source = WIRELESS_EXT;\n\n\trange->max_qual.qual = 128;\n\trange->max_qual.level = 128;\n\trange->max_qual.noise = 128;\n\trange->max_qual.updated = 7;\n\n\trange->encoding_size[0] = 5;\n\trange->encoding_size[1] = 13;\n\trange->num_encoding_sizes = 2;\n\trange->max_encoding_tokens = ZD1201_NUMKEYS;\n\n\trange->num_bitrates = 4;\n\trange->bitrate[0] = 1000000;\n\trange->bitrate[1] = 2000000;\n\trange->bitrate[2] = 5500000;\n\trange->bitrate[3] = 11000000;\n\n\trange->min_rts = 0;\n\trange->min_frag = ZD1201_FRAGMIN;\n\trange->max_rts = ZD1201_RTSMAX;\n\trange->min_frag = ZD1201_FRAGMAX;\n\n\treturn 0;\n}\n\n \nstatic int zd1201_get_wap(struct net_device *dev,\n\tstruct iw_request_info *info, union iwreq_data *wrqu, char *extra)\n{\n\tstruct sockaddr *ap_addr = &wrqu->ap_addr;\n\tstruct zd1201 *zd = netdev_priv(dev);\n\tunsigned char buffer[6];\n\n\tif (!zd1201_getconfig(zd, ZD1201_RID_COMMSQUALITY, buffer, 6)) {\n\t\t \n\t\t \n\t\tzd->iwstats.qual.level = le16_to_cpu(((__le16 *)buffer)[1]);\n\t\t \n\t\tzd->iwstats.qual.updated = 2;\n\t}\n\n\treturn zd1201_getconfig(zd, ZD1201_RID_CURRENTBSSID, ap_addr->sa_data, 6);\n}\n\nstatic int zd1201_set_scan(struct net_device *dev,\n\tstruct iw_request_info *info, union iwreq_data *wrqu, char *extra)\n{\n\t \n\treturn 0;\n}\n\nstatic int zd1201_get_scan(struct net_device *dev,\n\tstruct iw_request_info *info, union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_point *srq = &wrqu->data;\n\tstruct zd1201 *zd = netdev_priv(dev);\n\tint err, i, j, enabled_save;\n\tstruct iw_event iwe;\n\tchar *cev = extra;\n\tchar *end_buf = extra + IW_SCAN_MAX_DATA;\n\n\t \n\tif (zd->ap)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tenabled_save = zd->mac_enabled;\n\tzd1201_enable(zd);\n\n\tzd->rxdatas = 0;\n\terr = zd1201_docmd(zd, ZD1201_CMDCODE_INQUIRE, \n\t     ZD1201_INQ_SCANRESULTS, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\twait_event_interruptible(zd->rxdataq, zd->rxdatas);\n\tif (!zd->rxlen)\n\t\treturn -EIO;\n\n\tif (le16_to_cpu(*(__le16*)&zd->rxdata[2]) != ZD1201_INQ_SCANRESULTS)\n\t\treturn -EIO;\n\n\tfor(i=8; i<zd->rxlen; i+=62) {\n\t\tiwe.cmd = SIOCGIWAP;\n\t\tiwe.u.ap_addr.sa_family = ARPHRD_ETHER;\n\t\tmemcpy(iwe.u.ap_addr.sa_data, zd->rxdata+i+6, 6);\n\t\tcev = iwe_stream_add_event(info, cev, end_buf,\n\t\t\t\t\t   &iwe, IW_EV_ADDR_LEN);\n\n\t\tiwe.cmd = SIOCGIWESSID;\n\t\tiwe.u.data.length = zd->rxdata[i+16];\n\t\tiwe.u.data.flags = 1;\n\t\tcev = iwe_stream_add_point(info, cev, end_buf,\n\t\t\t\t\t   &iwe, zd->rxdata+i+18);\n\n\t\tiwe.cmd = SIOCGIWMODE;\n\t\tif (zd->rxdata[i+14]&0x01)\n\t\t\tiwe.u.mode = IW_MODE_MASTER;\n\t\telse\n\t\t\tiwe.u.mode = IW_MODE_ADHOC;\n\t\tcev = iwe_stream_add_event(info, cev, end_buf,\n\t\t\t\t\t   &iwe, IW_EV_UINT_LEN);\n\t\t\n\t\tiwe.cmd = SIOCGIWFREQ;\n\t\tiwe.u.freq.m = zd->rxdata[i+0];\n\t\tiwe.u.freq.e = 0;\n\t\tcev = iwe_stream_add_event(info, cev, end_buf,\n\t\t\t\t\t   &iwe, IW_EV_FREQ_LEN);\n\t\t\n\t\tiwe.cmd = SIOCGIWRATE;\n\t\tiwe.u.bitrate.fixed = 0;\n\t\tiwe.u.bitrate.disabled = 0;\n\t\tfor (j=0; j<10; j++) if (zd->rxdata[i+50+j]) {\n\t\t\tiwe.u.bitrate.value = (zd->rxdata[i+50+j]&0x7f)*500000;\n\t\t\tcev = iwe_stream_add_event(info, cev, end_buf,\n\t\t\t\t\t\t   &iwe, IW_EV_PARAM_LEN);\n\t\t}\n\t\t\n\t\tiwe.cmd = SIOCGIWENCODE;\n\t\tiwe.u.data.length = 0;\n\t\tif (zd->rxdata[i+14]&0x10)\n\t\t\tiwe.u.data.flags = IW_ENCODE_ENABLED;\n\t\telse\n\t\t\tiwe.u.data.flags = IW_ENCODE_DISABLED;\n\t\tcev = iwe_stream_add_point(info, cev, end_buf, &iwe, NULL);\n\t\t\n\t\tiwe.cmd = IWEVQUAL;\n\t\tiwe.u.qual.qual = zd->rxdata[i+4];\n\t\tiwe.u.qual.noise= zd->rxdata[i+2]/10-100;\n\t\tiwe.u.qual.level = (256+zd->rxdata[i+4]*100)/255-100;\n\t\tiwe.u.qual.updated = 7;\n\t\tcev = iwe_stream_add_event(info, cev, end_buf,\n\t\t\t\t\t   &iwe, IW_EV_QUAL_LEN);\n\t}\n\n\tif (!enabled_save)\n\t\tzd1201_disable(zd);\n\n\tsrq->length = cev - extra;\n\tsrq->flags = 0;\n\n\treturn 0;\n}\n\nstatic int zd1201_set_essid(struct net_device *dev,\n\tstruct iw_request_info *info, union iwreq_data *wrqu, char *essid)\n{\n\tstruct iw_point *data = &wrqu->data;\n\tstruct zd1201 *zd = netdev_priv(dev);\n\n\tif (data->length > IW_ESSID_MAX_SIZE)\n\t\treturn -EINVAL;\n\tif (data->length < 1)\n\t\tdata->length = 1;\n\tzd->essidlen = data->length;\n\tmemset(zd->essid, 0, IW_ESSID_MAX_SIZE+1);\n\tmemcpy(zd->essid, essid, data->length);\n\treturn zd1201_join(zd, zd->essid, zd->essidlen);\n}\n\nstatic int zd1201_get_essid(struct net_device *dev,\n\tstruct iw_request_info *info, union iwreq_data *wrqu, char *essid)\n{\n\tstruct iw_point *data = &wrqu->data;\n\tstruct zd1201 *zd = netdev_priv(dev);\n\n\tmemcpy(essid, zd->essid, zd->essidlen);\n\tdata->flags = 1;\n\tdata->length = zd->essidlen;\n\n\treturn 0;\n}\n\nstatic int zd1201_get_nick(struct net_device *dev, struct iw_request_info *info,\n\tunion iwreq_data *wrqu, char *nick)\n{\n\tstruct iw_point *data = &wrqu->data;\n\tstrcpy(nick, \"zd1201\");\n\tdata->flags = 1;\n\tdata->length = strlen(nick);\n\treturn 0;\n}\n\nstatic int zd1201_set_rate(struct net_device *dev,\n\tstruct iw_request_info *info, union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *rrq = &wrqu->bitrate;\n\tstruct zd1201 *zd = netdev_priv(dev);\n\tshort rate;\n\tint err;\n\n\tswitch (rrq->value) {\n\t\tcase 1000000:\n\t\t\trate = ZD1201_RATEB1;\n\t\t\tbreak;\n\t\tcase 2000000:\n\t\t\trate = ZD1201_RATEB2;\n\t\t\tbreak;\n\t\tcase 5500000:\n\t\t\trate = ZD1201_RATEB5;\n\t\t\tbreak;\n\t\tcase 11000000:\n\t\tdefault:\n\t\t\trate = ZD1201_RATEB11;\n\t\t\tbreak;\n\t}\n\tif (!rrq->fixed) {  \n\t\trate |= rate-1;\n\t}\n\n\terr = zd1201_setconfig16(zd, ZD1201_RID_TXRATECNTL, rate);\n\tif (err)\n\t\treturn err;\n\n\treturn zd1201_mac_reset(zd);\n}\n\nstatic int zd1201_get_rate(struct net_device *dev,\n\tstruct iw_request_info *info, union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *rrq = &wrqu->bitrate;\n\tstruct zd1201 *zd = netdev_priv(dev);\n\tshort rate;\n\tint err;\n\n\terr = zd1201_getconfig16(zd, ZD1201_RID_CURRENTTXRATE, &rate);\n\tif (err)\n\t\treturn err;\n\n\tswitch(rate) {\n\t\tcase 1:\n\t\t\trrq->value = 1000000;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\trrq->value = 2000000;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\trrq->value = 5500000;\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\trrq->value = 11000000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trrq->value = 0;\n\t}\n\trrq->fixed = 0;\n\trrq->disabled = 0;\n\n\treturn 0;\n}\n\nstatic int zd1201_set_rts(struct net_device *dev, struct iw_request_info *info,\n\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *rts = &wrqu->rts;\n\tstruct zd1201 *zd = netdev_priv(dev);\n\tint err;\n\tshort val = rts->value;\n\n\tif (rts->disabled || !rts->fixed)\n\t\tval = ZD1201_RTSMAX;\n\tif (val > ZD1201_RTSMAX)\n\t\treturn -EINVAL;\n\tif (val < 0)\n\t\treturn -EINVAL;\n\n\terr = zd1201_setconfig16(zd, ZD1201_RID_CNFRTSTHRESHOLD, val);\n\tif (err)\n\t\treturn err;\n\treturn zd1201_mac_reset(zd);\n}\n\nstatic int zd1201_get_rts(struct net_device *dev, struct iw_request_info *info,\n\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *rts = &wrqu->rts;\n\tstruct zd1201 *zd = netdev_priv(dev);\n\tshort rtst;\n\tint err;\n\n\terr = zd1201_getconfig16(zd, ZD1201_RID_CNFRTSTHRESHOLD, &rtst);\n\tif (err)\n\t\treturn err;\n\trts->value = rtst;\n\trts->disabled = (rts->value == ZD1201_RTSMAX);\n\trts->fixed = 1;\n\n\treturn 0;\n}\n\nstatic int zd1201_set_frag(struct net_device *dev, struct iw_request_info *info,\n\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *frag = &wrqu->frag;\n\tstruct zd1201 *zd = netdev_priv(dev);\n\tint err;\n\tshort val = frag->value;\n\n\tif (frag->disabled || !frag->fixed)\n\t\tval = ZD1201_FRAGMAX;\n\tif (val > ZD1201_FRAGMAX)\n\t\treturn -EINVAL;\n\tif (val < ZD1201_FRAGMIN)\n\t\treturn -EINVAL;\n\tif (val & 1)\n\t\treturn -EINVAL;\n\terr = zd1201_setconfig16(zd, ZD1201_RID_CNFFRAGTHRESHOLD, val);\n\tif (err)\n\t\treturn err;\n\treturn zd1201_mac_reset(zd);\n}\n\nstatic int zd1201_get_frag(struct net_device *dev, struct iw_request_info *info,\n\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *frag = &wrqu->frag;\n\tstruct zd1201 *zd = netdev_priv(dev);\n\tshort fragt;\n\tint err;\n\n\terr = zd1201_getconfig16(zd, ZD1201_RID_CNFFRAGTHRESHOLD, &fragt);\n\tif (err)\n\t\treturn err;\n\tfrag->value = fragt;\n\tfrag->disabled = (frag->value == ZD1201_FRAGMAX);\n\tfrag->fixed = 1;\n\n\treturn 0;\n}\n\nstatic int zd1201_set_retry(struct net_device *dev,\n\tstruct iw_request_info *info, union iwreq_data *wrqu, char *extra)\n{\n\treturn 0;\n}\n\nstatic int zd1201_get_retry(struct net_device *dev,\n\tstruct iw_request_info *info, union iwreq_data *wrqu, char *extra)\n{\n\treturn 0;\n}\n\nstatic int zd1201_set_encode(struct net_device *dev,\n\tstruct iw_request_info *info, union iwreq_data *wrqu, char *key)\n{\n\tstruct iw_point *erq = &wrqu->encoding;\n\tstruct zd1201 *zd = netdev_priv(dev);\n\tshort i;\n\tint err, rid;\n\n\tif (erq->length > ZD1201_MAXKEYLEN)\n\t\treturn -EINVAL;\n\n\ti = (erq->flags & IW_ENCODE_INDEX)-1;\n\tif (i == -1) {\n\t\terr = zd1201_getconfig16(zd,ZD1201_RID_CNFDEFAULTKEYID,&i);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\terr = zd1201_setconfig16(zd, ZD1201_RID_CNFDEFAULTKEYID, i);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (i < 0 || i >= ZD1201_NUMKEYS)\n\t\treturn -EINVAL;\n\n\trid = ZD1201_RID_CNFDEFAULTKEY0 + i;\n\terr = zd1201_setconfig(zd, rid, key, erq->length, 1);\n\tif (err)\n\t\treturn err;\n\tzd->encode_keylen[i] = erq->length;\n\tmemcpy(zd->encode_keys[i], key, erq->length);\n\n\ti=0;\n\tif (!(erq->flags & IW_ENCODE_DISABLED & IW_ENCODE_MODE)) {\n\t\ti |= 0x01;\n\t\tzd->encode_enabled = 1;\n\t} else\n\t\tzd->encode_enabled = 0;\n\tif (erq->flags & IW_ENCODE_RESTRICTED & IW_ENCODE_MODE) {\n\t\ti |= 0x02;\n\t\tzd->encode_restricted = 1;\n\t} else\n\t\tzd->encode_restricted = 0;\n\terr = zd1201_setconfig16(zd, ZD1201_RID_CNFWEBFLAGS, i);\n\tif (err)\n\t\treturn err;\n\n\tif (zd->encode_enabled)\n\t\ti = ZD1201_CNFAUTHENTICATION_SHAREDKEY;\n\telse\n\t\ti = ZD1201_CNFAUTHENTICATION_OPENSYSTEM;\n\terr = zd1201_setconfig16(zd, ZD1201_RID_CNFAUTHENTICATION, i);\n\tif (err)\n\t\treturn err;\n\n\treturn zd1201_mac_reset(zd);\n}\n\nstatic int zd1201_get_encode(struct net_device *dev,\n\tstruct iw_request_info *info, union iwreq_data *wrqu, char *key)\n{\n\tstruct iw_point *erq = &wrqu->encoding;\n\tstruct zd1201 *zd = netdev_priv(dev);\n\tshort i;\n\tint err;\n\n\tif (zd->encode_enabled)\n\t\terq->flags = IW_ENCODE_ENABLED;\n\telse\n\t\terq->flags = IW_ENCODE_DISABLED;\n\tif (zd->encode_restricted)\n\t\terq->flags |= IW_ENCODE_RESTRICTED;\n\telse\n\t\terq->flags |= IW_ENCODE_OPEN;\n\n\ti = (erq->flags & IW_ENCODE_INDEX) -1;\n\tif (i == -1) {\n\t\terr = zd1201_getconfig16(zd, ZD1201_RID_CNFDEFAULTKEYID, &i);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (i<0 || i>= ZD1201_NUMKEYS)\n\t\treturn -EINVAL;\n\n\terq->flags |= i+1;\n\n\terq->length = zd->encode_keylen[i];\n\tmemcpy(key, zd->encode_keys[i], erq->length);\n\n\treturn 0;\n}\n\nstatic int zd1201_set_power(struct net_device *dev, \n\tstruct iw_request_info *info, union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *vwrq = &wrqu->power;\n\tstruct zd1201 *zd = netdev_priv(dev);\n\tshort enabled, duration, level;\n\tint err;\n\n\tenabled = vwrq->disabled ? 0 : 1;\n\tif (enabled) {\n\t\tif (vwrq->flags & IW_POWER_PERIOD) {\n\t\t\tduration = vwrq->value;\n\t\t\terr = zd1201_setconfig16(zd, \n\t\t\t    ZD1201_RID_CNFMAXSLEEPDURATION, duration);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tgoto out;\n\t\t}\n\t\tif (vwrq->flags & IW_POWER_TIMEOUT) {\n\t\t\terr = zd1201_getconfig16(zd, \n\t\t\t    ZD1201_RID_CNFMAXSLEEPDURATION, &duration);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tlevel = vwrq->value * 4 / duration;\n\t\t\tif (level > 4)\n\t\t\t\tlevel = 4;\n\t\t\tif (level < 0)\n\t\t\t\tlevel = 0;\n\t\t\terr = zd1201_setconfig16(zd, ZD1201_RID_CNFPMEPS,\n\t\t\t    level);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tgoto out;\n\t\t}\n\t\treturn -EINVAL;\n\t}\nout:\n\treturn zd1201_setconfig16(zd, ZD1201_RID_CNFPMENABLED, enabled);\n}\n\nstatic int zd1201_get_power(struct net_device *dev,\n\tstruct iw_request_info *info, union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *vwrq = &wrqu->power;\n\tstruct zd1201 *zd = netdev_priv(dev);\n\tshort enabled, level, duration;\n\tint err;\n\n\terr = zd1201_getconfig16(zd, ZD1201_RID_CNFPMENABLED, &enabled);\n\tif (err)\n\t\treturn err;\n\terr = zd1201_getconfig16(zd, ZD1201_RID_CNFPMEPS, &level);\n\tif (err)\n\t\treturn err;\n\terr = zd1201_getconfig16(zd, ZD1201_RID_CNFMAXSLEEPDURATION, &duration);\n\tif (err)\n\t\treturn err;\n\tvwrq->disabled = enabled ? 0 : 1;\n\tif (vwrq->flags & IW_POWER_TYPE) {\n\t\tif (vwrq->flags & IW_POWER_PERIOD) {\n\t\t\tvwrq->value = duration;\n\t\t\tvwrq->flags = IW_POWER_PERIOD;\n\t\t} else {\n\t\t\tvwrq->value = duration * level / 4;\n\t\t\tvwrq->flags = IW_POWER_TIMEOUT;\n\t\t}\n\t}\n\tif (vwrq->flags & IW_POWER_MODE) {\n\t\tif (enabled && level)\n\t\t\tvwrq->flags = IW_POWER_UNICAST_R;\n\t\telse\n\t\t\tvwrq->flags = IW_POWER_ALL_R;\n\t}\n\n\treturn 0;\n}\n\n\nstatic const iw_handler zd1201_iw_handler[] =\n{\n\tIW_HANDLER(SIOCSIWCOMMIT,\tzd1201_config_commit),\n\tIW_HANDLER(SIOCGIWNAME,\t\tzd1201_get_name),\n\tIW_HANDLER(SIOCSIWFREQ,\t\tzd1201_set_freq),\n\tIW_HANDLER(SIOCGIWFREQ,\t\tzd1201_get_freq),\n\tIW_HANDLER(SIOCSIWMODE,\t\tzd1201_set_mode),\n\tIW_HANDLER(SIOCGIWMODE,\t\tzd1201_get_mode),\n\tIW_HANDLER(SIOCGIWRANGE,\tzd1201_get_range),\n\tIW_HANDLER(SIOCGIWAP,\t\tzd1201_get_wap),\n\tIW_HANDLER(SIOCSIWSCAN,\t\tzd1201_set_scan),\n\tIW_HANDLER(SIOCGIWSCAN,\t\tzd1201_get_scan),\n\tIW_HANDLER(SIOCSIWESSID,\tzd1201_set_essid),\n\tIW_HANDLER(SIOCGIWESSID,\tzd1201_get_essid),\n\tIW_HANDLER(SIOCGIWNICKN,\tzd1201_get_nick),\n\tIW_HANDLER(SIOCSIWRATE,\t\tzd1201_set_rate),\n\tIW_HANDLER(SIOCGIWRATE,\t\tzd1201_get_rate),\n\tIW_HANDLER(SIOCSIWRTS,\t\tzd1201_set_rts),\n\tIW_HANDLER(SIOCGIWRTS,\t\tzd1201_get_rts),\n\tIW_HANDLER(SIOCSIWFRAG,\t\tzd1201_set_frag),\n\tIW_HANDLER(SIOCGIWFRAG,\t\tzd1201_get_frag),\n\tIW_HANDLER(SIOCSIWRETRY,\tzd1201_set_retry),\n\tIW_HANDLER(SIOCGIWRETRY,\tzd1201_get_retry),\n\tIW_HANDLER(SIOCSIWENCODE,\tzd1201_set_encode),\n\tIW_HANDLER(SIOCGIWENCODE,\tzd1201_get_encode),\n\tIW_HANDLER(SIOCSIWPOWER,\tzd1201_set_power),\n\tIW_HANDLER(SIOCGIWPOWER,\tzd1201_get_power),\n};\n\nstatic int zd1201_set_hostauth(struct net_device *dev,\n\tstruct iw_request_info *info, union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *rrq = &wrqu->param;\n\tstruct zd1201 *zd = netdev_priv(dev);\n\n\tif (!zd->ap)\n\t\treturn -EOPNOTSUPP;\n\n\treturn zd1201_setconfig16(zd, ZD1201_RID_CNFHOSTAUTH, rrq->value);\n}\n\nstatic int zd1201_get_hostauth(struct net_device *dev,\n\tstruct iw_request_info *info, union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *rrq = &wrqu->param;\n\tstruct zd1201 *zd = netdev_priv(dev);\n\tshort hostauth;\n\tint err;\n\n\tif (!zd->ap)\n\t\treturn -EOPNOTSUPP;\n\n\terr = zd1201_getconfig16(zd, ZD1201_RID_CNFHOSTAUTH, &hostauth);\n\tif (err)\n\t\treturn err;\n\trrq->value = hostauth;\n\trrq->fixed = 1;\n\n\treturn 0;\n}\n\nstatic int zd1201_auth_sta(struct net_device *dev,\n\tstruct iw_request_info *info, union iwreq_data *wrqu, char *extra)\n{\n\tstruct sockaddr *sta = &wrqu->ap_addr;\n\tstruct zd1201 *zd = netdev_priv(dev);\n\tunsigned char buffer[10];\n\n\tif (!zd->ap)\n\t\treturn -EOPNOTSUPP;\n\n\tmemcpy(buffer, sta->sa_data, ETH_ALEN);\n\t*(short*)(buffer+6) = 0;\t \n\t*(short*)(buffer+8) = 0;\n\n\treturn zd1201_setconfig(zd, ZD1201_RID_AUTHENTICATESTA, buffer, 10, 1);\n}\n\nstatic int zd1201_set_maxassoc(struct net_device *dev,\n\tstruct iw_request_info *info, union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *rrq = &wrqu->param;\n\tstruct zd1201 *zd = netdev_priv(dev);\n\n\tif (!zd->ap)\n\t\treturn -EOPNOTSUPP;\n\n\treturn zd1201_setconfig16(zd, ZD1201_RID_CNFMAXASSOCSTATIONS, rrq->value);\n}\n\nstatic int zd1201_get_maxassoc(struct net_device *dev,\n\tstruct iw_request_info *info, union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *rrq = &wrqu->param;\n\tstruct zd1201 *zd = netdev_priv(dev);\n\tshort maxassoc;\n\tint err;\n\n\tif (!zd->ap)\n\t\treturn -EOPNOTSUPP;\n\n\terr = zd1201_getconfig16(zd, ZD1201_RID_CNFMAXASSOCSTATIONS, &maxassoc);\n\tif (err)\n\t\treturn err;\n\trrq->value = maxassoc;\n\trrq->fixed = 1;\n\n\treturn 0;\n}\n\nstatic const iw_handler zd1201_private_handler[] = {\n\tzd1201_set_hostauth,\t \n\tzd1201_get_hostauth,\t \n\tzd1201_auth_sta,\t \n\tNULL,\t\t\t \n\tzd1201_set_maxassoc,\t \n\tzd1201_get_maxassoc,\t \n};\n\nstatic const struct iw_priv_args zd1201_private_args[] = {\n\t{ ZD1201SIWHOSTAUTH, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t    IW_PRIV_TYPE_NONE, \"sethostauth\" },\n\t{ ZD1201GIWHOSTAUTH, IW_PRIV_TYPE_NONE,\n\t    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"gethostauth\" },\n\t{ ZD1201SIWAUTHSTA, IW_PRIV_TYPE_ADDR | IW_PRIV_SIZE_FIXED | 1,\n\t    IW_PRIV_TYPE_NONE, \"authstation\" },\n\t{ ZD1201SIWMAXASSOC, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t    IW_PRIV_TYPE_NONE, \"setmaxassoc\" },\n\t{ ZD1201GIWMAXASSOC, IW_PRIV_TYPE_NONE,\n\t    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"getmaxassoc\" },\n};\n\nstatic const struct iw_handler_def zd1201_iw_handlers = {\n\t.num_standard \t\t= ARRAY_SIZE(zd1201_iw_handler),\n\t.num_private \t\t= ARRAY_SIZE(zd1201_private_handler),\n\t.num_private_args \t= ARRAY_SIZE(zd1201_private_args),\n\t.standard\t\t= zd1201_iw_handler,\n\t.private\t\t= zd1201_private_handler,\n\t.private_args \t\t= (struct iw_priv_args *) zd1201_private_args,\n\t.get_wireless_stats\t= zd1201_get_wireless_stats,\n};\n\nstatic const struct net_device_ops zd1201_netdev_ops = {\n\t.ndo_open\t\t= zd1201_net_open,\n\t.ndo_stop\t\t= zd1201_net_stop,\n\t.ndo_start_xmit\t\t= zd1201_hard_start_xmit,\n\t.ndo_tx_timeout\t\t= zd1201_tx_timeout,\n\t.ndo_set_rx_mode\t= zd1201_set_multicast,\n\t.ndo_set_mac_address\t= zd1201_set_mac_address,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int zd1201_probe(struct usb_interface *interface,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct zd1201 *zd;\n\tstruct net_device *dev;\n\tstruct usb_device *usb;\n\tint err;\n\tshort porttype;\n\tchar buf[IW_ESSID_MAX_SIZE+2];\n\tu8 addr[ETH_ALEN];\n\n\tusb = interface_to_usbdev(interface);\n\n\tdev = alloc_etherdev(sizeof(*zd));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tzd = netdev_priv(dev);\n\tzd->dev = dev;\n\n\tzd->ap = ap;\n\tzd->usb = usb;\n\tzd->removed = 0;\n\tinit_waitqueue_head(&zd->rxdataq);\n\tINIT_HLIST_HEAD(&zd->fraglist);\n\t\n\terr = zd1201_fw_upload(usb, zd->ap);\n\tif (err) {\n\t\tdev_err(&usb->dev, \"zd1201 firmware upload failed: %d\\n\", err);\n\t\tgoto err_zd;\n\t}\n\t\n\tzd->endp_in = 1;\n\tzd->endp_out = 1;\n\tzd->endp_out2 = 2;\n\tzd->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tzd->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!zd->rx_urb || !zd->tx_urb) {\n\t\terr = -ENOMEM;\n\t\tgoto err_zd;\n\t}\n\n\tmdelay(100);\n\terr = zd1201_drvr_start(zd);\n\tif (err)\n\t\tgoto err_zd;\n\n\terr = zd1201_setconfig16(zd, ZD1201_RID_CNFMAXDATALEN, 2312);\n\tif (err)\n\t\tgoto err_start;\n\n\terr = zd1201_setconfig16(zd, ZD1201_RID_TXRATECNTL,\n\t    ZD1201_RATEB1 | ZD1201_RATEB2 | ZD1201_RATEB5 | ZD1201_RATEB11);\n\tif (err)\n\t\tgoto err_start;\n\n\tdev->netdev_ops = &zd1201_netdev_ops;\n\tdev->wireless_handlers = &zd1201_iw_handlers;\n\tdev->watchdog_timeo = ZD1201_TX_TIMEOUT;\n\tstrcpy(dev->name, \"wlan%d\");\n\n\terr = zd1201_getconfig(zd, ZD1201_RID_CNFOWNMACADDR, addr, ETH_ALEN);\n\tif (err)\n\t\tgoto err_start;\n\teth_hw_addr_set(dev, addr);\n\n\t \n\t*(__le16 *)buf = cpu_to_le16(0);\n\terr = zd1201_setconfig(zd, ZD1201_RID_CNFDESIREDSSID, buf,\n\t    IW_ESSID_MAX_SIZE+2, 1);\n\tif (err)\n\t\tgoto err_start;\n\n\tif (zd->ap)\n\t\tporttype = ZD1201_PORTTYPE_AP;\n\telse\n\t\tporttype = ZD1201_PORTTYPE_BSS;\n\terr = zd1201_setconfig16(zd, ZD1201_RID_CNFPORTTYPE, porttype);\n\tif (err)\n\t\tgoto err_start;\n\n\tSET_NETDEV_DEV(dev, &usb->dev);\n\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto err_start;\n\tdev_info(&usb->dev, \"%s: ZD1201 USB Wireless interface\\n\",\n\t    dev->name);\n\n\tusb_set_intfdata(interface, zd);\n\tzd1201_enable(zd);\t \n\tzd1201_disable(zd);\t \n\treturn 0;\n\nerr_start:\n\t \n\tzd1201_docmd(zd, ZD1201_CMDCODE_INIT, 0, 0, 0);\nerr_zd:\n\tusb_free_urb(zd->tx_urb);\n\tusb_free_urb(zd->rx_urb);\n\tfree_netdev(dev);\n\treturn err;\n}\n\nstatic void zd1201_disconnect(struct usb_interface *interface)\n{\n\tstruct zd1201 *zd = usb_get_intfdata(interface);\n\tstruct hlist_node *node2;\n\tstruct zd1201_frag *frag;\n\n\tif (!zd)\n\t\treturn;\n\tusb_set_intfdata(interface, NULL);\n\n\thlist_for_each_entry_safe(frag, node2, &zd->fraglist, fnode) {\n\t\thlist_del_init(&frag->fnode);\n\t\tkfree_skb(frag->skb);\n\t\tkfree(frag);\n\t}\n\n\tif (zd->tx_urb) {\n\t\tusb_kill_urb(zd->tx_urb);\n\t\tusb_free_urb(zd->tx_urb);\n\t}\n\tif (zd->rx_urb) {\n\t\tusb_kill_urb(zd->rx_urb);\n\t\tusb_free_urb(zd->rx_urb);\n\t}\n\n\tif (zd->dev) {\n\t\tunregister_netdev(zd->dev);\n\t\tfree_netdev(zd->dev);\n\t}\n}\n\n#ifdef CONFIG_PM\n\nstatic int zd1201_suspend(struct usb_interface *interface,\n\t\t\t   pm_message_t message)\n{\n\tstruct zd1201 *zd = usb_get_intfdata(interface);\n\n\tnetif_device_detach(zd->dev);\n\n\tzd->was_enabled = zd->mac_enabled;\n\n\tif (zd->was_enabled)\n\t\treturn zd1201_disable(zd);\n\telse\n\t\treturn 0;\n}\n\nstatic int zd1201_resume(struct usb_interface *interface)\n{\n\tstruct zd1201 *zd = usb_get_intfdata(interface);\n\n\tif (!zd || !zd->dev)\n\t\treturn -ENODEV;\n\n\tnetif_device_attach(zd->dev);\n\n\tif (zd->was_enabled)\n\t\treturn zd1201_enable(zd);\n\telse\n\t\treturn 0;\n}\n\n#else\n\n#define zd1201_suspend NULL\n#define zd1201_resume  NULL\n\n#endif\n\nstatic struct usb_driver zd1201_usb = {\n\t.name = \"zd1201\",\n\t.probe = zd1201_probe,\n\t.disconnect = zd1201_disconnect,\n\t.id_table = zd1201_table,\n\t.suspend = zd1201_suspend,\n\t.resume = zd1201_resume,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(zd1201_usb);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}