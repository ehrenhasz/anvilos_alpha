{
  "module_name": "adm8211.c",
  "hash_id": "e121b297c7e17b81a02d827dc400748b0a5f8311aa835180f596559a73eabcfd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/admtek/adm8211.c",
  "human_readable_source": "\n\n \n\n#include <linux/interrupt.h>\n#include <linux/if.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/etherdevice.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/eeprom_93cx6.h>\n#include <linux/module.h>\n#include <net/mac80211.h>\n\n#include \"adm8211.h\"\n\nMODULE_AUTHOR(\"Michael Wu <flamingice@sourmilk.net>\");\nMODULE_AUTHOR(\"Jouni Malinen <j@w1.fi>\");\nMODULE_DESCRIPTION(\"Driver for IEEE 802.11b wireless cards based on ADMtek ADM8211\");\nMODULE_LICENSE(\"GPL\");\n\nstatic unsigned int tx_ring_size __read_mostly = 16;\nstatic unsigned int rx_ring_size __read_mostly = 16;\n\nmodule_param(tx_ring_size, uint, 0);\nmodule_param(rx_ring_size, uint, 0);\n\nstatic const struct pci_device_id adm8211_pci_id_table[] = {\n\t \n\t{ PCI_DEVICE(0x10B7, 0x6000) },  \n\t{ PCI_DEVICE(0x1200, 0x8201) },  \n\t{ PCI_DEVICE(0x1317, 0x8201) },  \n\t{ PCI_DEVICE(0x1317, 0x8211) },  \n\t{ 0 }\n};\n\nstatic struct ieee80211_rate adm8211_rates[] = {\n\t{ .bitrate = 10, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 20, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 55, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 110, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 220, .flags = IEEE80211_RATE_SHORT_PREAMBLE },  \n};\n\nstatic const struct ieee80211_channel adm8211_channels[] = {\n\t{ .center_freq = 2412},\n\t{ .center_freq = 2417},\n\t{ .center_freq = 2422},\n\t{ .center_freq = 2427},\n\t{ .center_freq = 2432},\n\t{ .center_freq = 2437},\n\t{ .center_freq = 2442},\n\t{ .center_freq = 2447},\n\t{ .center_freq = 2452},\n\t{ .center_freq = 2457},\n\t{ .center_freq = 2462},\n\t{ .center_freq = 2467},\n\t{ .center_freq = 2472},\n\t{ .center_freq = 2484},\n};\n\n\nstatic void adm8211_eeprom_register_read(struct eeprom_93cx6 *eeprom)\n{\n\tstruct adm8211_priv *priv = eeprom->data;\n\tu32 reg = ADM8211_CSR_READ(SPR);\n\n\teeprom->reg_data_in = reg & ADM8211_SPR_SDI;\n\teeprom->reg_data_out = reg & ADM8211_SPR_SDO;\n\teeprom->reg_data_clock = reg & ADM8211_SPR_SCLK;\n\teeprom->reg_chip_select = reg & ADM8211_SPR_SCS;\n}\n\nstatic void adm8211_eeprom_register_write(struct eeprom_93cx6 *eeprom)\n{\n\tstruct adm8211_priv *priv = eeprom->data;\n\tu32 reg = 0x4000 | ADM8211_SPR_SRS;\n\n\tif (eeprom->reg_data_in)\n\t\treg |= ADM8211_SPR_SDI;\n\tif (eeprom->reg_data_out)\n\t\treg |= ADM8211_SPR_SDO;\n\tif (eeprom->reg_data_clock)\n\t\treg |= ADM8211_SPR_SCLK;\n\tif (eeprom->reg_chip_select)\n\t\treg |= ADM8211_SPR_SCS;\n\n\tADM8211_CSR_WRITE(SPR, reg);\n\tADM8211_CSR_READ(SPR);\t\t \n}\n\nstatic int adm8211_read_eeprom(struct ieee80211_hw *dev)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\tunsigned int words, i;\n\tstruct ieee80211_chan_range chan_range;\n\tu16 cr49;\n\tstruct eeprom_93cx6 eeprom = {\n\t\t.data\t\t= priv,\n\t\t.register_read\t= adm8211_eeprom_register_read,\n\t\t.register_write\t= adm8211_eeprom_register_write\n\t};\n\n\tif (ADM8211_CSR_READ(CSR_TEST0) & ADM8211_CSR_TEST0_EPTYP) {\n\t\t \n\t\teeprom.width = PCI_EEPROM_WIDTH_93C66;\n\t\twords = 256;\n\t} else {\n\t\t \n\t\teeprom.width = PCI_EEPROM_WIDTH_93C46;\n\t\twords = 64;\n\t}\n\n\tpriv->eeprom_len = words * 2;\n\tpriv->eeprom = kmalloc(priv->eeprom_len, GFP_KERNEL);\n\tif (!priv->eeprom)\n\t\treturn -ENOMEM;\n\n\teeprom_93cx6_multiread(&eeprom, 0, (__le16 *)priv->eeprom, words);\n\n\tcr49 = le16_to_cpu(priv->eeprom->cr49);\n\tpriv->rf_type = (cr49 >> 3) & 0x7;\n\tswitch (priv->rf_type) {\n\tcase ADM8211_TYPE_INTERSIL:\n\tcase ADM8211_TYPE_RFMD:\n\tcase ADM8211_TYPE_MARVEL:\n\tcase ADM8211_TYPE_AIROHA:\n\tcase ADM8211_TYPE_ADMTEK:\n\t\tbreak;\n\n\tdefault:\n\t\tif (priv->pdev->revision < ADM8211_REV_CA)\n\t\t\tpriv->rf_type = ADM8211_TYPE_RFMD;\n\t\telse\n\t\t\tpriv->rf_type = ADM8211_TYPE_AIROHA;\n\n\t\tprintk(KERN_WARNING \"%s (adm8211): Unknown RFtype %d\\n\",\n\t\t       pci_name(priv->pdev), (cr49 >> 3) & 0x7);\n\t}\n\n\tpriv->bbp_type = cr49 & 0x7;\n\tswitch (priv->bbp_type) {\n\tcase ADM8211_TYPE_INTERSIL:\n\tcase ADM8211_TYPE_RFMD:\n\tcase ADM8211_TYPE_MARVEL:\n\tcase ADM8211_TYPE_AIROHA:\n\tcase ADM8211_TYPE_ADMTEK:\n\t\tbreak;\n\tdefault:\n\t\tif (priv->pdev->revision < ADM8211_REV_CA)\n\t\t\tpriv->bbp_type = ADM8211_TYPE_RFMD;\n\t\telse\n\t\t\tpriv->bbp_type = ADM8211_TYPE_ADMTEK;\n\n\t\tprintk(KERN_WARNING \"%s (adm8211): Unknown BBPtype: %d\\n\",\n\t\t       pci_name(priv->pdev), cr49 >> 3);\n\t}\n\n\tif (priv->eeprom->country_code >= ARRAY_SIZE(cranges)) {\n\t\tprintk(KERN_WARNING \"%s (adm8211): Invalid country code (%d)\\n\",\n\t\t       pci_name(priv->pdev), priv->eeprom->country_code);\n\n\t\tchan_range = cranges[2];\n\t} else\n\t\tchan_range = cranges[priv->eeprom->country_code];\n\n\tprintk(KERN_DEBUG \"%s (adm8211): Channel range: %d - %d\\n\",\n\t       pci_name(priv->pdev), (int)chan_range.min, (int)chan_range.max);\n\n\tBUILD_BUG_ON(sizeof(priv->channels) != sizeof(adm8211_channels));\n\n\tmemcpy(priv->channels, adm8211_channels, sizeof(priv->channels));\n\tpriv->band.channels = priv->channels;\n\tpriv->band.n_channels = ARRAY_SIZE(adm8211_channels);\n\tpriv->band.bitrates = adm8211_rates;\n\tpriv->band.n_bitrates = ARRAY_SIZE(adm8211_rates);\n\n\tfor (i = 1; i <= ARRAY_SIZE(adm8211_channels); i++)\n\t\tif (i < chan_range.min || i > chan_range.max)\n\t\t\tpriv->channels[i - 1].flags |= IEEE80211_CHAN_DISABLED;\n\n\tswitch (priv->eeprom->specific_bbptype) {\n\tcase ADM8211_BBP_RFMD3000:\n\tcase ADM8211_BBP_RFMD3002:\n\tcase ADM8211_BBP_ADM8011:\n\t\tpriv->specific_bbptype = priv->eeprom->specific_bbptype;\n\t\tbreak;\n\n\tdefault:\n\t\tif (priv->pdev->revision < ADM8211_REV_CA)\n\t\t\tpriv->specific_bbptype = ADM8211_BBP_RFMD3000;\n\t\telse\n\t\t\tpriv->specific_bbptype = ADM8211_BBP_ADM8011;\n\n\t\tprintk(KERN_WARNING \"%s (adm8211): Unknown specific BBP: %d\\n\",\n\t\t       pci_name(priv->pdev), priv->eeprom->specific_bbptype);\n\t}\n\n\tswitch (priv->eeprom->specific_rftype) {\n\tcase ADM8211_RFMD2948:\n\tcase ADM8211_RFMD2958:\n\tcase ADM8211_RFMD2958_RF3000_CONTROL_POWER:\n\tcase ADM8211_MAX2820:\n\tcase ADM8211_AL2210L:\n\t\tpriv->transceiver_type = priv->eeprom->specific_rftype;\n\t\tbreak;\n\n\tdefault:\n\t\tif (priv->pdev->revision == ADM8211_REV_BA)\n\t\t\tpriv->transceiver_type = ADM8211_RFMD2958_RF3000_CONTROL_POWER;\n\t\telse if (priv->pdev->revision == ADM8211_REV_CA)\n\t\t\tpriv->transceiver_type = ADM8211_AL2210L;\n\t\telse if (priv->pdev->revision == ADM8211_REV_AB)\n\t\t\tpriv->transceiver_type = ADM8211_RFMD2948;\n\n\t\tprintk(KERN_WARNING \"%s (adm8211): Unknown transceiver: %d\\n\",\n\t\t       pci_name(priv->pdev), priv->eeprom->specific_rftype);\n\n\t\tbreak;\n\t}\n\n\tprintk(KERN_DEBUG \"%s (adm8211): RFtype=%d BBPtype=%d Specific BBP=%d \"\n               \"Transceiver=%d\\n\", pci_name(priv->pdev), priv->rf_type,\n\t       priv->bbp_type, priv->specific_bbptype, priv->transceiver_type);\n\n\treturn 0;\n}\n\nstatic inline void adm8211_write_sram(struct ieee80211_hw *dev,\n\t\t\t\t      u32 addr, u32 data)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\n\tADM8211_CSR_WRITE(WEPCTL, addr | ADM8211_WEPCTL_TABLE_WR |\n\t\t\t  (priv->pdev->revision < ADM8211_REV_BA ?\n\t\t\t   0 : ADM8211_WEPCTL_SEL_WEPTABLE ));\n\tADM8211_CSR_READ(WEPCTL);\n\tmsleep(1);\n\n\tADM8211_CSR_WRITE(WESK, data);\n\tADM8211_CSR_READ(WESK);\n\tmsleep(1);\n}\n\nstatic void adm8211_write_sram_bytes(struct ieee80211_hw *dev,\n\t\t\t\t     unsigned int addr, u8 *buf,\n\t\t\t\t     unsigned int len)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\tu32 reg = ADM8211_CSR_READ(WEPCTL);\n\tunsigned int i;\n\n\tif (priv->pdev->revision < ADM8211_REV_BA) {\n\t\tfor (i = 0; i < len; i += 2) {\n\t\t\tu16 val = buf[i] | (buf[i + 1] << 8);\n\t\t\tadm8211_write_sram(dev, addr + i / 2, val);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < len; i += 4) {\n\t\t\tu32 val = (buf[i + 0] << 0 ) | (buf[i + 1] << 8 ) |\n\t\t\t\t  (buf[i + 2] << 16) | (buf[i + 3] << 24);\n\t\t\tadm8211_write_sram(dev, addr + i / 4, val);\n\t\t}\n\t}\n\n\tADM8211_CSR_WRITE(WEPCTL, reg);\n}\n\nstatic void adm8211_clear_sram(struct ieee80211_hw *dev)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\tu32 reg = ADM8211_CSR_READ(WEPCTL);\n\tunsigned int addr;\n\n\tfor (addr = 0; addr < ADM8211_SRAM_SIZE; addr++)\n\t\tadm8211_write_sram(dev, addr, 0);\n\n\tADM8211_CSR_WRITE(WEPCTL, reg);\n}\n\nstatic int adm8211_get_stats(struct ieee80211_hw *dev,\n\t\t\t     struct ieee80211_low_level_stats *stats)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\n\tmemcpy(stats, &priv->stats, sizeof(*stats));\n\n\treturn 0;\n}\n\nstatic void adm8211_interrupt_tci(struct ieee80211_hw *dev)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\tunsigned int dirty_tx;\n\n\tspin_lock(&priv->lock);\n\n\tfor (dirty_tx = priv->dirty_tx; priv->cur_tx - dirty_tx; dirty_tx++) {\n\t\tunsigned int entry = dirty_tx % priv->tx_ring_size;\n\t\tu32 status = le32_to_cpu(priv->tx_ring[entry].status);\n\t\tstruct ieee80211_tx_info *txi;\n\t\tstruct adm8211_tx_ring_info *info;\n\t\tstruct sk_buff *skb;\n\n\t\tif (status & TDES0_CONTROL_OWN ||\n\t\t    !(status & TDES0_CONTROL_DONE))\n\t\t\tbreak;\n\n\t\tinfo = &priv->tx_buffers[entry];\n\t\tskb = info->skb;\n\t\ttxi = IEEE80211_SKB_CB(skb);\n\n\t\t \n\n\t\tdma_unmap_single(&priv->pdev->dev, info->mapping,\n\t\t\t\t info->skb->len, DMA_TO_DEVICE);\n\n\t\tieee80211_tx_info_clear_status(txi);\n\n\t\tskb_pull(skb, sizeof(struct adm8211_tx_hdr));\n\t\tmemcpy(skb_push(skb, info->hdrlen), skb->cb, info->hdrlen);\n\t\tif (!(txi->flags & IEEE80211_TX_CTL_NO_ACK) &&\n\t\t    !(status & TDES0_STATUS_ES))\n\t\t\ttxi->flags |= IEEE80211_TX_STAT_ACK;\n\n\t\tieee80211_tx_status_irqsafe(dev, skb);\n\n\t\tinfo->skb = NULL;\n\t}\n\n\tif (priv->cur_tx - dirty_tx < priv->tx_ring_size - 2)\n\t\tieee80211_wake_queue(dev, 0);\n\n\tpriv->dirty_tx = dirty_tx;\n\tspin_unlock(&priv->lock);\n}\n\n\nstatic void adm8211_interrupt_rci(struct ieee80211_hw *dev)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\tunsigned int entry = priv->cur_rx % priv->rx_ring_size;\n\tu32 status;\n\tunsigned int pktlen;\n\tstruct sk_buff *skb, *newskb;\n\tunsigned int limit = priv->rx_ring_size;\n\tu8 rssi, rate;\n\n\twhile (!(priv->rx_ring[entry].status & cpu_to_le32(RDES0_STATUS_OWN))) {\n\t\tif (!limit--)\n\t\t\tbreak;\n\n\t\tstatus = le32_to_cpu(priv->rx_ring[entry].status);\n\t\trate = (status & RDES0_STATUS_RXDR) >> 12;\n\t\trssi = le32_to_cpu(priv->rx_ring[entry].length) &\n\t\t\tRDES1_STATUS_RSSI;\n\n\t\tpktlen = status & RDES0_STATUS_FL;\n\t\tif (pktlen > RX_PKT_SIZE) {\n\t\t\tif (net_ratelimit())\n\t\t\t\twiphy_debug(dev->wiphy, \"frame too long (%d)\\n\",\n\t\t\t\t\t    pktlen);\n\t\t\tpktlen = RX_PKT_SIZE;\n\t\t}\n\n\t\tif (!priv->soft_rx_crc && status & RDES0_STATUS_ES) {\n\t\t\tskb = NULL;  \n\t\t\t \n\t\t\t \n\t\t} else if (pktlen < RX_COPY_BREAK) {\n\t\t\tskb = dev_alloc_skb(pktlen);\n\t\t\tif (skb) {\n\t\t\t\tdma_sync_single_for_cpu(&priv->pdev->dev,\n\t\t\t\t\t\t\tpriv->rx_buffers[entry].mapping,\n\t\t\t\t\t\t\tpktlen,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\t\tskb_put_data(skb,\n\t\t\t\t\t     skb_tail_pointer(priv->rx_buffers[entry].skb),\n\t\t\t\t\t     pktlen);\n\t\t\t\tdma_sync_single_for_device(&priv->pdev->dev,\n\t\t\t\t\t\t\t   priv->rx_buffers[entry].mapping,\n\t\t\t\t\t\t\t   RX_PKT_SIZE,\n\t\t\t\t\t\t\t   DMA_FROM_DEVICE);\n\t\t\t}\n\t\t} else {\n\t\t\tnewskb = dev_alloc_skb(RX_PKT_SIZE);\n\t\t\tif (newskb) {\n\t\t\t\tskb = priv->rx_buffers[entry].skb;\n\t\t\t\tskb_put(skb, pktlen);\n\t\t\t\tdma_unmap_single(&priv->pdev->dev,\n\t\t\t\t\t\t priv->rx_buffers[entry].mapping,\n\t\t\t\t\t\t RX_PKT_SIZE, DMA_FROM_DEVICE);\n\t\t\t\tpriv->rx_buffers[entry].skb = newskb;\n\t\t\t\tpriv->rx_buffers[entry].mapping =\n\t\t\t\t\tdma_map_single(&priv->pdev->dev,\n\t\t\t\t\t\t       skb_tail_pointer(newskb),\n\t\t\t\t\t\t       RX_PKT_SIZE,\n\t\t\t\t\t\t       DMA_FROM_DEVICE);\n\t\t\t\tif (dma_mapping_error(&priv->pdev->dev,\n\t\t\t\t\t\t      priv->rx_buffers[entry].mapping)) {\n\t\t\t\t\tpriv->rx_buffers[entry].skb = NULL;\n\t\t\t\t\tdev_kfree_skb(newskb);\n\t\t\t\t\tskb = NULL;\n\t\t\t\t\t \n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tskb = NULL;\n\t\t\t\t \n\t\t\t}\n\n\t\t\tpriv->rx_ring[entry].buffer1 =\n\t\t\t\tcpu_to_le32(priv->rx_buffers[entry].mapping);\n\t\t}\n\n\t\tpriv->rx_ring[entry].status = cpu_to_le32(RDES0_STATUS_OWN |\n\t\t\t\t\t\t\t  RDES0_STATUS_SQL);\n\t\tpriv->rx_ring[entry].length =\n\t\t\tcpu_to_le32(RX_PKT_SIZE |\n\t\t\t\t    (entry == priv->rx_ring_size - 1 ?\n\t\t\t\t     RDES1_CONTROL_RER : 0));\n\n\t\tif (skb) {\n\t\t\tstruct ieee80211_rx_status rx_status = {0};\n\n\t\t\tif (priv->pdev->revision < ADM8211_REV_CA)\n\t\t\t\trx_status.signal = rssi;\n\t\t\telse\n\t\t\t\trx_status.signal = 100 - rssi;\n\n\t\t\trx_status.rate_idx = rate;\n\n\t\t\trx_status.freq = adm8211_channels[priv->channel - 1].center_freq;\n\t\t\trx_status.band = NL80211_BAND_2GHZ;\n\n\t\t\tmemcpy(IEEE80211_SKB_RXCB(skb), &rx_status, sizeof(rx_status));\n\t\t\tieee80211_rx_irqsafe(dev, skb);\n\t\t}\n\n\t\tentry = (++priv->cur_rx) % priv->rx_ring_size;\n\t}\n\n\t \n}\n\n\nstatic irqreturn_t adm8211_interrupt(int irq, void *dev_id)\n{\n#define ADM8211_INT(x)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (unlikely(stsr & ADM8211_STSR_ ## x))\t\t\\\n\t\twiphy_debug(dev->wiphy, \"%s\\n\", #x);\t\t\\\n} while (0)\n\n\tstruct ieee80211_hw *dev = dev_id;\n\tstruct adm8211_priv *priv = dev->priv;\n\tu32 stsr = ADM8211_CSR_READ(STSR);\n\tADM8211_CSR_WRITE(STSR, stsr);\n\tif (stsr == 0xffffffff)\n\t\treturn IRQ_HANDLED;\n\n\tif (!(stsr & (ADM8211_STSR_NISS | ADM8211_STSR_AISS)))\n\t\treturn IRQ_HANDLED;\n\n\tif (stsr & ADM8211_STSR_RCI)\n\t\tadm8211_interrupt_rci(dev);\n\tif (stsr & ADM8211_STSR_TCI)\n\t\tadm8211_interrupt_tci(dev);\n\n\tADM8211_INT(PCF);\n\tADM8211_INT(BCNTC);\n\tADM8211_INT(GPINT);\n\tADM8211_INT(ATIMTC);\n\tADM8211_INT(TSFTF);\n\tADM8211_INT(TSCZ);\n\tADM8211_INT(SQL);\n\tADM8211_INT(WEPTD);\n\tADM8211_INT(ATIME);\n\tADM8211_INT(TEIS);\n\tADM8211_INT(FBE);\n\tADM8211_INT(REIS);\n\tADM8211_INT(GPTT);\n\tADM8211_INT(RPS);\n\tADM8211_INT(RDU);\n\tADM8211_INT(TUF);\n\tADM8211_INT(TPS);\n\n\treturn IRQ_HANDLED;\n\n#undef ADM8211_INT\n}\n\n#define WRITE_SYN(name,v_mask,v_shift,a_mask,a_shift,bits,prewrite,postwrite)\\\nstatic void adm8211_rf_write_syn_ ## name (struct ieee80211_hw *dev,\t     \\\n\t\t\t\t\t   u16 addr, u32 value) {\t     \\\n\tstruct adm8211_priv *priv = dev->priv;\t\t\t\t     \\\n\tunsigned int i;\t\t\t\t\t\t\t     \\\n\tu32 reg, bitbuf;\t\t\t\t\t\t     \\\n\t\t\t\t\t\t\t\t\t     \\\n\tvalue &= v_mask;\t\t\t\t\t\t     \\\n\taddr &= a_mask;\t\t\t\t\t\t\t     \\\n\tbitbuf = (value << v_shift) | (addr << a_shift);\t\t     \\\n\t\t\t\t\t\t\t\t\t     \\\n\tADM8211_CSR_WRITE(SYNRF, ADM8211_SYNRF_IF_SELECT_1);\t\t     \\\n\tADM8211_CSR_READ(SYNRF);\t\t\t\t\t     \\\n\tADM8211_CSR_WRITE(SYNRF, ADM8211_SYNRF_IF_SELECT_0);\t\t     \\\n\tADM8211_CSR_READ(SYNRF);\t\t\t\t\t     \\\n\t\t\t\t\t\t\t\t\t     \\\n\tif (prewrite) {\t\t\t\t\t\t\t     \\\n\t\tADM8211_CSR_WRITE(SYNRF, ADM8211_SYNRF_WRITE_SYNDATA_0);     \\\n\t\tADM8211_CSR_READ(SYNRF);\t\t\t\t     \\\n\t}\t\t\t\t\t\t\t\t     \\\n\t\t\t\t\t\t\t\t\t     \\\n\tfor (i = 0; i <= bits; i++) {\t\t\t\t\t     \\\n\t\tif (bitbuf & (1 << (bits - i)))\t\t\t\t     \\\n\t\t\treg = ADM8211_SYNRF_WRITE_SYNDATA_1;\t\t     \\\n\t\telse\t\t\t\t\t\t\t     \\\n\t\t\treg = ADM8211_SYNRF_WRITE_SYNDATA_0;\t\t     \\\n\t\t\t\t\t\t\t\t\t     \\\n\t\tADM8211_CSR_WRITE(SYNRF, reg);\t\t\t\t     \\\n\t\tADM8211_CSR_READ(SYNRF);\t\t\t\t     \\\n\t\t\t\t\t\t\t\t\t     \\\n\t\tADM8211_CSR_WRITE(SYNRF, reg | ADM8211_SYNRF_WRITE_CLOCK_1); \\\n\t\tADM8211_CSR_READ(SYNRF);\t\t\t\t     \\\n\t\tADM8211_CSR_WRITE(SYNRF, reg | ADM8211_SYNRF_WRITE_CLOCK_0); \\\n\t\tADM8211_CSR_READ(SYNRF);\t\t\t\t     \\\n\t}\t\t\t\t\t\t\t\t     \\\n\t\t\t\t\t\t\t\t\t     \\\n\tif (postwrite == 1) {\t\t\t\t\t\t     \\\n\t\tADM8211_CSR_WRITE(SYNRF, reg | ADM8211_SYNRF_IF_SELECT_0);   \\\n\t\tADM8211_CSR_READ(SYNRF);\t\t\t\t     \\\n\t}\t\t\t\t\t\t\t\t     \\\n\tif (postwrite == 2) {\t\t\t\t\t\t     \\\n\t\tADM8211_CSR_WRITE(SYNRF, reg | ADM8211_SYNRF_IF_SELECT_1);   \\\n\t\tADM8211_CSR_READ(SYNRF);\t\t\t\t     \\\n\t}\t\t\t\t\t\t\t\t     \\\n\t\t\t\t\t\t\t\t\t     \\\n\tADM8211_CSR_WRITE(SYNRF, 0);\t\t\t\t\t     \\\n\tADM8211_CSR_READ(SYNRF);\t\t\t\t\t     \\\n}\n\nWRITE_SYN(max2820,  0x00FFF, 0, 0x0F, 12, 15, 1, 1)\nWRITE_SYN(al2210l,  0xFFFFF, 4, 0x0F,  0, 23, 1, 1)\nWRITE_SYN(rfmd2958, 0x3FFFF, 0, 0x1F, 18, 23, 0, 1)\nWRITE_SYN(rfmd2948, 0x0FFFF, 4, 0x0F,  0, 21, 0, 2)\n\n#undef WRITE_SYN\n\nstatic int adm8211_write_bbp(struct ieee80211_hw *dev, u8 addr, u8 data)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\tunsigned int timeout;\n\tu32 reg;\n\n\ttimeout = 10;\n\twhile (timeout > 0) {\n\t\treg = ADM8211_CSR_READ(BBPCTL);\n\t\tif (!(reg & (ADM8211_BBPCTL_WR | ADM8211_BBPCTL_RD)))\n\t\t\tbreak;\n\t\ttimeout--;\n\t\tmsleep(2);\n\t}\n\n\tif (timeout == 0) {\n\t\twiphy_debug(dev->wiphy,\n\t\t\t    \"adm8211_write_bbp(%d,%d) failed prewrite (reg=0x%08x)\\n\",\n\t\t\t    addr, data, reg);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tswitch (priv->bbp_type) {\n\tcase ADM8211_TYPE_INTERSIL:\n\t\treg = ADM8211_BBPCTL_MMISEL;\t \n\t\tbreak;\n\tcase ADM8211_TYPE_RFMD:\n\t\treg = (0x20 << 24) | ADM8211_BBPCTL_TXCE | ADM8211_BBPCTL_CCAP |\n\t\t      (0x01 << 18);\n\t\tbreak;\n\tcase ADM8211_TYPE_ADMTEK:\n\t\treg = (0x20 << 24) | ADM8211_BBPCTL_TXCE | ADM8211_BBPCTL_CCAP |\n\t\t      (0x05 << 18);\n\t\tbreak;\n\t}\n\treg |= ADM8211_BBPCTL_WR | (addr << 8) | data;\n\n\tADM8211_CSR_WRITE(BBPCTL, reg);\n\n\ttimeout = 10;\n\twhile (timeout > 0) {\n\t\treg = ADM8211_CSR_READ(BBPCTL);\n\t\tif (!(reg & ADM8211_BBPCTL_WR))\n\t\t\tbreak;\n\t\ttimeout--;\n\t\tmsleep(2);\n\t}\n\n\tif (timeout == 0) {\n\t\tADM8211_CSR_WRITE(BBPCTL, ADM8211_CSR_READ(BBPCTL) &\n\t\t\t\t  ~ADM8211_BBPCTL_WR);\n\t\twiphy_debug(dev->wiphy,\n\t\t\t    \"adm8211_write_bbp(%d,%d) failed postwrite (reg=0x%08x)\\n\",\n\t\t\t    addr, data, reg);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int adm8211_rf_set_channel(struct ieee80211_hw *dev, unsigned int chan)\n{\n\tstatic const u32 adm8211_rfmd2958_reg5[] =\n\t\t{0x22BD, 0x22D2, 0x22E8, 0x22FE, 0x2314, 0x232A, 0x2340,\n\t\t 0x2355, 0x236B, 0x2381, 0x2397, 0x23AD, 0x23C2, 0x23F7};\n\tstatic const u32 adm8211_rfmd2958_reg6[] =\n\t\t{0x05D17, 0x3A2E8, 0x2E8BA, 0x22E8B, 0x1745D, 0x0BA2E, 0x00000,\n\t\t 0x345D1, 0x28BA2, 0x1D174, 0x11745, 0x05D17, 0x3A2E8, 0x11745};\n\n\tstruct adm8211_priv *priv = dev->priv;\n\tu8 ant_power = priv->ant_power > 0x3F ?\n\t\tpriv->eeprom->antenna_power[chan - 1] : priv->ant_power;\n\tu8 tx_power = priv->tx_power > 0x3F ?\n\t\tpriv->eeprom->tx_power[chan - 1] : priv->tx_power;\n\tu8 lpf_cutoff = priv->lpf_cutoff == 0xFF ?\n\t\tpriv->eeprom->lpf_cutoff[chan - 1] : priv->lpf_cutoff;\n\tu8 lnags_thresh = priv->lnags_threshold == 0xFF ?\n\t\tpriv->eeprom->lnags_threshold[chan - 1] : priv->lnags_threshold;\n\tu32 reg;\n\n\tADM8211_IDLE();\n\n\t \n\tswitch (priv->transceiver_type) {\n\tcase ADM8211_RFMD2958:\n\tcase ADM8211_RFMD2958_RF3000_CONTROL_POWER:\n\t\tadm8211_rf_write_syn_rfmd2958(dev, 0x00, 0x04007);\n\t\tadm8211_rf_write_syn_rfmd2958(dev, 0x02, 0x00033);\n\n\t\tadm8211_rf_write_syn_rfmd2958(dev, 0x05,\n\t\t\tadm8211_rfmd2958_reg5[chan - 1]);\n\t\tadm8211_rf_write_syn_rfmd2958(dev, 0x06,\n\t\t\tadm8211_rfmd2958_reg6[chan - 1]);\n\t\tbreak;\n\n\tcase ADM8211_RFMD2948:\n\t\tadm8211_rf_write_syn_rfmd2948(dev, SI4126_MAIN_CONF,\n\t\t\t\t\t      SI4126_MAIN_XINDIV2);\n\t\tadm8211_rf_write_syn_rfmd2948(dev, SI4126_POWERDOWN,\n\t\t\t\t\t      SI4126_POWERDOWN_PDIB |\n\t\t\t\t\t      SI4126_POWERDOWN_PDRB);\n\t\tadm8211_rf_write_syn_rfmd2948(dev, SI4126_PHASE_DET_GAIN, 0);\n\t\tadm8211_rf_write_syn_rfmd2948(dev, SI4126_RF2_N_DIV,\n\t\t\t\t\t      (chan == 14 ?\n\t\t\t\t\t       2110 : (2033 + (chan * 5))));\n\t\tadm8211_rf_write_syn_rfmd2948(dev, SI4126_IF_N_DIV, 1496);\n\t\tadm8211_rf_write_syn_rfmd2948(dev, SI4126_RF2_R_DIV, 44);\n\t\tadm8211_rf_write_syn_rfmd2948(dev, SI4126_IF_R_DIV, 44);\n\t\tbreak;\n\n\tcase ADM8211_MAX2820:\n\t\tadm8211_rf_write_syn_max2820(dev, 0x3,\n\t\t\t(chan == 14 ? 0x054 : (0x7 + (chan * 5))));\n\t\tbreak;\n\n\tcase ADM8211_AL2210L:\n\t\tadm8211_rf_write_syn_al2210l(dev, 0x0,\n\t\t\t(chan == 14 ? 0x229B4 : (0x22967 + (chan * 5))));\n\t\tbreak;\n\n\tdefault:\n\t\twiphy_debug(dev->wiphy, \"unsupported transceiver type %d\\n\",\n\t\t\t    priv->transceiver_type);\n\t\tbreak;\n\t}\n\n\t \n\tif (priv->bbp_type == ADM8211_TYPE_RFMD) {\n\n\t \n\t \n\tif (priv->transceiver_type == ADM8211_RFMD2948) {\n\t\treg = ADM8211_CSR_READ(GPIO);\n\t\treg &= 0xfffc0000;\n\t\treg |= ADM8211_CSR_GPIO_EN0;\n\t\tif (chan != 14)\n\t\t\treg |= ADM8211_CSR_GPIO_O0;\n\t\tADM8211_CSR_WRITE(GPIO, reg);\n\t}\n\n\tif (priv->transceiver_type == ADM8211_RFMD2958) {\n\t\t \n\t\tadm8211_rf_write_syn_rfmd2958(dev, 0x0B, 0x07100);\n\t\t \n\t\treg = le16_to_cpu(priv->eeprom->cr49);\n\t\treg >>= 13;\n\t\treg <<= 15;\n\t\treg |= ant_power << 9;\n\t\tadm8211_rf_write_syn_rfmd2958(dev, 0x0A, reg);\n\t\t \n\t\tadm8211_rf_write_syn_rfmd2958(dev, 0x09, 0x00050 |\n\t\t\t(priv->pdev->revision < ADM8211_REV_CA ? tx_power : 0));\n\t} else {\n\t\treg = ADM8211_CSR_READ(PLCPHD);\n\t\treg &= 0xff00ffff;\n\t\treg |= tx_power << 18;\n\t\tADM8211_CSR_WRITE(PLCPHD, reg);\n\t}\n\n\tADM8211_CSR_WRITE(SYNRF, ADM8211_SYNRF_SELRF |\n\t\t\t  ADM8211_SYNRF_PE1 | ADM8211_SYNRF_PHYRST);\n\tADM8211_CSR_READ(SYNRF);\n\tmsleep(30);\n\n\t \n\tif (priv->transceiver_type != ADM8211_RFMD2958)\n\t\tadm8211_write_bbp(dev, RF3000_TX_VAR_GAIN__TX_LEN_EXT,\n\t\t\t\t  tx_power<<2);\n\tadm8211_write_bbp(dev, RF3000_LOW_GAIN_CALIB, lpf_cutoff);\n\tadm8211_write_bbp(dev, RF3000_HIGH_GAIN_CALIB, lnags_thresh);\n\tadm8211_write_bbp(dev, 0x1c, priv->pdev->revision == ADM8211_REV_BA ?\n\t\t\t\t     priv->eeprom->cr28 : 0);\n\tadm8211_write_bbp(dev, 0x1d, priv->eeprom->cr29);\n\n\tADM8211_CSR_WRITE(SYNRF, 0);\n\n\t \n\t} else if (priv->bbp_type != ADM8211_TYPE_ADMTEK)\n\t\twiphy_debug(dev->wiphy, \"unsupported BBP type %d\\n\",\n\t\t\t    priv->bbp_type);\n\n\tADM8211_RESTORE();\n\n\t \n\treg = ADM8211_CSR_READ(CAP0);\n\treg &= ~0xF;\n\treg |= chan;\n\tADM8211_CSR_WRITE(CAP0, reg);\n\n\treturn 0;\n}\n\nstatic void adm8211_update_mode(struct ieee80211_hw *dev)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\n\tADM8211_IDLE();\n\n\tpriv->soft_rx_crc = 0;\n\tswitch (priv->mode) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tpriv->nar &= ~(ADM8211_NAR_PR | ADM8211_NAR_EA);\n\t\tpriv->nar |= ADM8211_NAR_ST | ADM8211_NAR_SR;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tpriv->nar &= ~ADM8211_NAR_PR;\n\t\tpriv->nar |= ADM8211_NAR_EA | ADM8211_NAR_ST | ADM8211_NAR_SR;\n\n\t\t \n\t\tif (priv->pdev->revision >= ADM8211_REV_BA)\n\t\t\tpriv->soft_rx_crc = 1;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tpriv->nar &= ~(ADM8211_NAR_EA | ADM8211_NAR_ST);\n\t\tpriv->nar |= ADM8211_NAR_PR | ADM8211_NAR_SR;\n\t\tbreak;\n\t}\n\n\tADM8211_RESTORE();\n}\n\nstatic void adm8211_hw_init_syn(struct ieee80211_hw *dev)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\n\tswitch (priv->transceiver_type) {\n\tcase ADM8211_RFMD2958:\n\tcase ADM8211_RFMD2958_RF3000_CONTROL_POWER:\n\t\t \n\n\t\t \n\t\tadm8211_rf_write_syn_rfmd2958(dev, 0x1F, 0x00000);\n\t\t \n\t\tadm8211_rf_write_syn_rfmd2958(dev, 0x0C, 0x3001F);\n\t\t \n\t\tadm8211_rf_write_syn_rfmd2958(dev, 0x01, 0x29C03);\n\t\t \n\t\tadm8211_rf_write_syn_rfmd2958(dev, 0x03, 0x1FF6F);\n\t\t \n\t\tadm8211_rf_write_syn_rfmd2958(dev, 0x04, 0x29403);\n\t\t \n\t\tadm8211_rf_write_syn_rfmd2958(dev, 0x07, 0x1456F);\n\t\t \n\t\tadm8211_rf_write_syn_rfmd2958(dev, 0x09,\n\t\t\t(priv->transceiver_type == ADM8211_RFMD2958 ?\n\t\t\t 0x10050 : 0x00050));\n\t\t \n\t\tadm8211_rf_write_syn_rfmd2958(dev, 0x08, 0x3FFF8);\n\t\tbreak;\n\n\tcase ADM8211_MAX2820:\n\t\tadm8211_rf_write_syn_max2820(dev, 0x1, 0x01E);\n\t\tadm8211_rf_write_syn_max2820(dev, 0x2, 0x001);\n\t\tadm8211_rf_write_syn_max2820(dev, 0x3, 0x054);\n\t\tadm8211_rf_write_syn_max2820(dev, 0x4, 0x310);\n\t\tadm8211_rf_write_syn_max2820(dev, 0x5, 0x000);\n\t\tbreak;\n\n\tcase ADM8211_AL2210L:\n\t\tadm8211_rf_write_syn_al2210l(dev, 0x0, 0x0196C);\n\t\tadm8211_rf_write_syn_al2210l(dev, 0x1, 0x007CB);\n\t\tadm8211_rf_write_syn_al2210l(dev, 0x2, 0x3582F);\n\t\tadm8211_rf_write_syn_al2210l(dev, 0x3, 0x010A9);\n\t\tadm8211_rf_write_syn_al2210l(dev, 0x4, 0x77280);\n\t\tadm8211_rf_write_syn_al2210l(dev, 0x5, 0x45641);\n\t\tadm8211_rf_write_syn_al2210l(dev, 0x6, 0xEA130);\n\t\tadm8211_rf_write_syn_al2210l(dev, 0x7, 0x80000);\n\t\tadm8211_rf_write_syn_al2210l(dev, 0x8, 0x7850F);\n\t\tadm8211_rf_write_syn_al2210l(dev, 0x9, 0xF900C);\n\t\tadm8211_rf_write_syn_al2210l(dev, 0xA, 0x00000);\n\t\tadm8211_rf_write_syn_al2210l(dev, 0xB, 0x00000);\n\t\tbreak;\n\n\tcase ADM8211_RFMD2948:\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int adm8211_hw_init_bbp(struct ieee80211_hw *dev)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\tu32 reg;\n\n\t \n\tif (priv->bbp_type == ADM8211_TYPE_INTERSIL) {\n\t\tADM8211_CSR_WRITE(MMIWA,  0x100E0C0A);\n\t\tADM8211_CSR_WRITE(MMIRD0, 0x00007C7E);\n\t\tADM8211_CSR_WRITE(MMIRD1, 0x00100000);\n\t} else if (priv->bbp_type == ADM8211_TYPE_RFMD ||\n\t\t   priv->bbp_type == ADM8211_TYPE_ADMTEK) {\n\t\t \n\t\tswitch (priv->specific_bbptype) {\n\t\tcase ADM8211_BBP_RFMD3000:\n\t\tcase ADM8211_BBP_RFMD3002:\n\t\t\tADM8211_CSR_WRITE(MMIWA,  0x00009101);\n\t\t\tADM8211_CSR_WRITE(MMIRD0, 0x00000301);\n\t\t\tbreak;\n\n\t\tcase ADM8211_BBP_ADM8011:\n\t\t\tADM8211_CSR_WRITE(MMIWA,  0x00008903);\n\t\t\tADM8211_CSR_WRITE(MMIRD0, 0x00001716);\n\n\t\t\treg = ADM8211_CSR_READ(BBPCTL);\n\t\t\treg &= ~ADM8211_BBPCTL_TYPE;\n\t\t\treg |= 0x5 << 18;\n\t\t\tADM8211_CSR_WRITE(BBPCTL, reg);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (priv->pdev->revision) {\n\t\tcase ADM8211_REV_CA:\n\t\t\tif (priv->transceiver_type == ADM8211_RFMD2958 ||\n\t\t\t    priv->transceiver_type == ADM8211_RFMD2958_RF3000_CONTROL_POWER ||\n\t\t\t    priv->transceiver_type == ADM8211_RFMD2948)\n\t\t\t\tADM8211_CSR_WRITE(SYNCTL, 0x1 << 22);\n\t\t\telse if (priv->transceiver_type == ADM8211_MAX2820 ||\n\t\t\t\t priv->transceiver_type == ADM8211_AL2210L)\n\t\t\t\tADM8211_CSR_WRITE(SYNCTL, 0x3 << 22);\n\t\t\tbreak;\n\n\t\tcase ADM8211_REV_BA:\n\t\t\treg  = ADM8211_CSR_READ(MMIRD1);\n\t\t\treg &= 0x0000FFFF;\n\t\t\treg |= 0x7e100000;\n\t\t\tADM8211_CSR_WRITE(MMIRD1, reg);\n\t\t\tbreak;\n\n\t\tcase ADM8211_REV_AB:\n\t\tcase ADM8211_REV_AF:\n\t\tdefault:\n\t\t\tADM8211_CSR_WRITE(MMIRD1, 0x7e100000);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tADM8211_CSR_WRITE(MACTEST, 0x800);\n\t}\n\n\tadm8211_hw_init_syn(dev);\n\n\t \n\tADM8211_CSR_WRITE(SYNRF, ADM8211_SYNRF_SELRF |\n\t\t\t  ADM8211_SYNRF_PE1 | ADM8211_SYNRF_PHYRST);\n\tADM8211_CSR_READ(SYNRF);\n\tmsleep(20);\n\n\t \n\tif (priv->bbp_type == ADM8211_TYPE_RFMD) {\n\t\t \n\t\t \n\t\tadm8211_write_bbp(dev, RF3000_CCA_CTRL, 0x80);\n\t\t \n\t\tadm8211_write_bbp(dev, RF3000_DIVERSITY__RSSI, 0x80);\n\t\tadm8211_write_bbp(dev, RF3000_TX_VAR_GAIN__TX_LEN_EXT, 0x74);\n\t\tadm8211_write_bbp(dev, RF3000_LOW_GAIN_CALIB, 0x38);\n\t\tadm8211_write_bbp(dev, RF3000_HIGH_GAIN_CALIB, 0x40);\n\n\t\tif (priv->eeprom->major_version < 2) {\n\t\t\tadm8211_write_bbp(dev, 0x1c, 0x00);\n\t\t\tadm8211_write_bbp(dev, 0x1d, 0x80);\n\t\t} else {\n\t\t\tif (priv->pdev->revision == ADM8211_REV_BA)\n\t\t\t\tadm8211_write_bbp(dev, 0x1c, priv->eeprom->cr28);\n\t\t\telse\n\t\t\t\tadm8211_write_bbp(dev, 0x1c, 0x00);\n\n\t\t\tadm8211_write_bbp(dev, 0x1d, priv->eeprom->cr29);\n\t\t}\n\t} else if (priv->bbp_type == ADM8211_TYPE_ADMTEK) {\n\t\t \n\t\tadm8211_write_bbp(dev, 0x00, 0xFF);\n\t\t \n\t\tadm8211_write_bbp(dev, 0x07, 0x0A);\n\n\t\t \n\t\tswitch (priv->transceiver_type) {\n\t\tcase ADM8211_RFMD2958:\n\t\tcase ADM8211_RFMD2958_RF3000_CONTROL_POWER:\n\t\t\tadm8211_write_bbp(dev, 0x00, 0x00);\n\t\t\tadm8211_write_bbp(dev, 0x01, 0x00);\n\t\t\tadm8211_write_bbp(dev, 0x02, 0x00);\n\t\t\tadm8211_write_bbp(dev, 0x03, 0x00);\n\t\t\tadm8211_write_bbp(dev, 0x06, 0x0f);\n\t\t\tadm8211_write_bbp(dev, 0x09, 0x00);\n\t\t\tadm8211_write_bbp(dev, 0x0a, 0x00);\n\t\t\tadm8211_write_bbp(dev, 0x0b, 0x00);\n\t\t\tadm8211_write_bbp(dev, 0x0c, 0x00);\n\t\t\tadm8211_write_bbp(dev, 0x0f, 0xAA);\n\t\t\tadm8211_write_bbp(dev, 0x10, 0x8c);\n\t\t\tadm8211_write_bbp(dev, 0x11, 0x43);\n\t\t\tadm8211_write_bbp(dev, 0x18, 0x40);\n\t\t\tadm8211_write_bbp(dev, 0x20, 0x23);\n\t\t\tadm8211_write_bbp(dev, 0x21, 0x02);\n\t\t\tadm8211_write_bbp(dev, 0x22, 0x28);\n\t\t\tadm8211_write_bbp(dev, 0x23, 0x30);\n\t\t\tadm8211_write_bbp(dev, 0x24, 0x2d);\n\t\t\tadm8211_write_bbp(dev, 0x28, 0x35);\n\t\t\tadm8211_write_bbp(dev, 0x2a, 0x8c);\n\t\t\tadm8211_write_bbp(dev, 0x2b, 0x81);\n\t\t\tadm8211_write_bbp(dev, 0x2c, 0x44);\n\t\t\tadm8211_write_bbp(dev, 0x2d, 0x0A);\n\t\t\tadm8211_write_bbp(dev, 0x29, 0x40);\n\t\t\tadm8211_write_bbp(dev, 0x60, 0x08);\n\t\t\tadm8211_write_bbp(dev, 0x64, 0x01);\n\t\t\tbreak;\n\n\t\tcase ADM8211_MAX2820:\n\t\t\tadm8211_write_bbp(dev, 0x00, 0x00);\n\t\t\tadm8211_write_bbp(dev, 0x01, 0x00);\n\t\t\tadm8211_write_bbp(dev, 0x02, 0x00);\n\t\t\tadm8211_write_bbp(dev, 0x03, 0x00);\n\t\t\tadm8211_write_bbp(dev, 0x06, 0x0f);\n\t\t\tadm8211_write_bbp(dev, 0x09, 0x05);\n\t\t\tadm8211_write_bbp(dev, 0x0a, 0x02);\n\t\t\tadm8211_write_bbp(dev, 0x0b, 0x00);\n\t\t\tadm8211_write_bbp(dev, 0x0c, 0x0f);\n\t\t\tadm8211_write_bbp(dev, 0x0f, 0x55);\n\t\t\tadm8211_write_bbp(dev, 0x10, 0x8d);\n\t\t\tadm8211_write_bbp(dev, 0x11, 0x43);\n\t\t\tadm8211_write_bbp(dev, 0x18, 0x4a);\n\t\t\tadm8211_write_bbp(dev, 0x20, 0x20);\n\t\t\tadm8211_write_bbp(dev, 0x21, 0x02);\n\t\t\tadm8211_write_bbp(dev, 0x22, 0x23);\n\t\t\tadm8211_write_bbp(dev, 0x23, 0x30);\n\t\t\tadm8211_write_bbp(dev, 0x24, 0x2d);\n\t\t\tadm8211_write_bbp(dev, 0x2a, 0x8c);\n\t\t\tadm8211_write_bbp(dev, 0x2b, 0x81);\n\t\t\tadm8211_write_bbp(dev, 0x2c, 0x44);\n\t\t\tadm8211_write_bbp(dev, 0x29, 0x4a);\n\t\t\tadm8211_write_bbp(dev, 0x60, 0x2b);\n\t\t\tadm8211_write_bbp(dev, 0x64, 0x01);\n\t\t\tbreak;\n\n\t\tcase ADM8211_AL2210L:\n\t\t\tadm8211_write_bbp(dev, 0x00, 0x00);\n\t\t\tadm8211_write_bbp(dev, 0x01, 0x00);\n\t\t\tadm8211_write_bbp(dev, 0x02, 0x00);\n\t\t\tadm8211_write_bbp(dev, 0x03, 0x00);\n\t\t\tadm8211_write_bbp(dev, 0x06, 0x0f);\n\t\t\tadm8211_write_bbp(dev, 0x07, 0x05);\n\t\t\tadm8211_write_bbp(dev, 0x08, 0x03);\n\t\t\tadm8211_write_bbp(dev, 0x09, 0x00);\n\t\t\tadm8211_write_bbp(dev, 0x0a, 0x00);\n\t\t\tadm8211_write_bbp(dev, 0x0b, 0x00);\n\t\t\tadm8211_write_bbp(dev, 0x0c, 0x10);\n\t\t\tadm8211_write_bbp(dev, 0x0f, 0x55);\n\t\t\tadm8211_write_bbp(dev, 0x10, 0x8d);\n\t\t\tadm8211_write_bbp(dev, 0x11, 0x43);\n\t\t\tadm8211_write_bbp(dev, 0x18, 0x4a);\n\t\t\tadm8211_write_bbp(dev, 0x20, 0x20);\n\t\t\tadm8211_write_bbp(dev, 0x21, 0x02);\n\t\t\tadm8211_write_bbp(dev, 0x22, 0x23);\n\t\t\tadm8211_write_bbp(dev, 0x23, 0x30);\n\t\t\tadm8211_write_bbp(dev, 0x24, 0x2d);\n\t\t\tadm8211_write_bbp(dev, 0x2a, 0xaa);\n\t\t\tadm8211_write_bbp(dev, 0x2b, 0x81);\n\t\t\tadm8211_write_bbp(dev, 0x2c, 0x44);\n\t\t\tadm8211_write_bbp(dev, 0x29, 0xfa);\n\t\t\tadm8211_write_bbp(dev, 0x60, 0x2d);\n\t\t\tadm8211_write_bbp(dev, 0x64, 0x01);\n\t\t\tbreak;\n\n\t\tcase ADM8211_RFMD2948:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\twiphy_debug(dev->wiphy, \"unsupported transceiver %d\\n\",\n\t\t\t\t    priv->transceiver_type);\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\twiphy_debug(dev->wiphy, \"unsupported BBP %d\\n\", priv->bbp_type);\n\n\tADM8211_CSR_WRITE(SYNRF, 0);\n\n\t \n\treg = ADM8211_CSR_READ(SYNCTL);\n\treg |= ADM8211_SYNCTL_SELCAL;\n\tADM8211_CSR_WRITE(SYNCTL, reg);\n\n\treturn 0;\n}\n\n \nstatic int adm8211_set_rate(struct ieee80211_hw *dev)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\tu32 reg;\n\tint i = 0;\n\tu8 rate_buf[12] = {0};\n\n\t \n\tif (priv->pdev->revision != ADM8211_REV_BA) {\n\t\trate_buf[0] = ARRAY_SIZE(adm8211_rates);\n\t\tfor (i = 0; i < ARRAY_SIZE(adm8211_rates); i++)\n\t\t\trate_buf[i + 1] = (adm8211_rates[i].bitrate / 5) | 0x80;\n\t} else {\n\t\t \n\t\trate_buf[0] = 0x04;\n\t\trate_buf[1] = 0x82;\n\t\trate_buf[2] = 0x04;\n\t\trate_buf[3] = 0x0b;\n\t\trate_buf[4] = 0x16;\n\t}\n\n\tadm8211_write_sram_bytes(dev, ADM8211_SRAM_SUPP_RATE, rate_buf,\n\t\t\t\t ARRAY_SIZE(adm8211_rates) + 1);\n\n\treg = ADM8211_CSR_READ(PLCPHD) & 0x00FFFFFF;  \n\treg |= 1 << 15;\t \n\treg |= 110 << 24;\n\tADM8211_CSR_WRITE(PLCPHD, reg);\n\n\t \n\tADM8211_CSR_WRITE(TXLMT, (512 << 16) | (110 << 8) | (224 << 0));\n\n\treturn 0;\n}\n\nstatic void adm8211_hw_init(struct ieee80211_hw *dev)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\tu32 reg;\n\tu8 cline;\n\n\treg = ADM8211_CSR_READ(PAR);\n\treg |= ADM8211_PAR_MRLE | ADM8211_PAR_MRME;\n\treg &= ~(ADM8211_PAR_BAR | ADM8211_PAR_CAL);\n\n\tif (!pci_set_mwi(priv->pdev)) {\n\t\treg |= 0x1 << 24;\n\t\tpci_read_config_byte(priv->pdev, PCI_CACHE_LINE_SIZE, &cline);\n\n\t\tswitch (cline) {\n\t\tcase  0x8:\n\t\t\treg |= (0x1 << 14);\n\t\t\tbreak;\n\t\tcase 0x10:\n\t\t\treg |= (0x2 << 14);\n\t\t\tbreak;\n\t\tcase 0x20:\n\t\t\treg |= (0x3 << 14);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treg |= (0x0 << 14);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tADM8211_CSR_WRITE(PAR, reg);\n\n\treg = ADM8211_CSR_READ(CSR_TEST1);\n\treg &= ~(0xF << 28);\n\treg |= (1 << 28) | (1 << 31);\n\tADM8211_CSR_WRITE(CSR_TEST1, reg);\n\n\t \n\treg = (0x04 << 21) | ADM8211_WCSR_TSFTWE | ADM8211_WCSR_LSOE;\n\tADM8211_CSR_WRITE(WCSR, reg);\n\n\t \n\treg = ADM8211_CSR_READ(CMDR);\n\treg &= ~(ADM8211_CMDR_APM | ADM8211_CMDR_DRT);\n\treg |= ADM8211_CMDR_RTE | ADM8211_CMDR_DRT_SF;\n\tADM8211_CSR_WRITE(CMDR, reg);\n\n\tadm8211_set_rate(dev);\n\n\t \n\tif (priv->pdev->revision < ADM8211_REV_CA)\n\t\tADM8211_CSR_WRITE(TOFS2, 0x8815cd18);\n\telse\n\t\tADM8211_CSR_WRITE(TOFS2, 0x8535cd16);\n\n\t \n\tpriv->nar = ADM8211_NAR_SF | ADM8211_NAR_PB;\n\tADM8211_CSR_WRITE(NAR, priv->nar);\n\n\t \n\tADM8211_CSR_WRITE(SYNRF, ADM8211_SYNRF_RADIO);\n\tADM8211_CSR_READ(SYNRF);\n\tmsleep(10);\n\tADM8211_CSR_WRITE(SYNRF, 0);\n\tADM8211_CSR_READ(SYNRF);\n\tmsleep(5);\n\n\t \n\treg = ADM8211_CSR_READ(CFPP);\n\treg &= ~(0xffff << 8);\n\treg |= 0x0010 << 8;\n\tADM8211_CSR_WRITE(CFPP, reg);\n\n\t \n\tADM8211_CSR_WRITE(TOFS0, (0x16 << 24) | 0x3ff);\n\n\t \n\tif (priv->pdev->revision < ADM8211_REV_CA)\n\t\tADM8211_CSR_WRITE(IFST, (20 << 23) | (110 << 15) |\n\t\t\t\t\t(50 << 9)  | 100);\n\telse\n\t\tADM8211_CSR_WRITE(IFST, (20 << 23) | (24 << 15) |\n\t\t\t\t\t(50 << 9)  | 100);\n\n\t \n\tADM8211_CSR_WRITE(RMD, (1 << 16) | 18769);\n\n\t \n\tADM8211_CSR_WRITE(RSPT, 0xffffff00);\n\n\t \n\tadm8211_hw_init_bbp(dev);\n\n\t \n\tADM8211_CSR_WRITE(IER, 0);\n\n\t \n\tADM8211_CSR_WRITE(STSR, ADM8211_CSR_READ(STSR));\n\n\t \n\treg = ADM8211_CSR_READ(MACTEST);\n\treg &= ~(7 << 20);\n\tADM8211_CSR_WRITE(MACTEST, reg);\n\n\treg = ADM8211_CSR_READ(WEPCTL);\n\treg &= ~ADM8211_WEPCTL_WEPENABLE;\n\treg |= ADM8211_WEPCTL_WEPRXBYP;\n\tADM8211_CSR_WRITE(WEPCTL, reg);\n\n\t \n\tADM8211_CSR_READ(LPC);\n}\n\nstatic int adm8211_hw_reset(struct ieee80211_hw *dev)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\tu32 reg, tmp;\n\tint timeout = 100;\n\n\t \n\t \n\tADM8211_CSR_WRITE(FRCTL, 0);\n\n\t \n\ttmp = ADM8211_CSR_READ(PAR);\n\tADM8211_CSR_WRITE(PAR, ADM8211_PAR_SWR);\n\n\twhile ((ADM8211_CSR_READ(PAR) & ADM8211_PAR_SWR) && timeout--)\n\t\tmsleep(50);\n\n\tif (timeout <= 0)\n\t\treturn -ETIMEDOUT;\n\n\tADM8211_CSR_WRITE(PAR, tmp);\n\n\tif (priv->pdev->revision == ADM8211_REV_BA &&\n\t    (priv->transceiver_type == ADM8211_RFMD2958_RF3000_CONTROL_POWER ||\n\t     priv->transceiver_type == ADM8211_RFMD2958)) {\n\t\treg = ADM8211_CSR_READ(CSR_TEST1);\n\t\treg |= (1 << 4) | (1 << 5);\n\t\tADM8211_CSR_WRITE(CSR_TEST1, reg);\n\t} else if (priv->pdev->revision == ADM8211_REV_CA) {\n\t\treg = ADM8211_CSR_READ(CSR_TEST1);\n\t\treg &= ~((1 << 4) | (1 << 5));\n\t\tADM8211_CSR_WRITE(CSR_TEST1, reg);\n\t}\n\n\tADM8211_CSR_WRITE(FRCTL, 0);\n\n\treg = ADM8211_CSR_READ(CSR_TEST0);\n\treg |= ADM8211_CSR_TEST0_EPRLD;\t \n\tADM8211_CSR_WRITE(CSR_TEST0, reg);\n\n\tadm8211_clear_sram(dev);\n\n\treturn 0;\n}\n\nstatic u64 adm8211_get_tsft(struct ieee80211_hw *dev,\n\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\tu32 tsftl;\n\tu64 tsft;\n\n\ttsftl = ADM8211_CSR_READ(TSFTL);\n\ttsft = ADM8211_CSR_READ(TSFTH);\n\ttsft <<= 32;\n\ttsft |= tsftl;\n\n\treturn tsft;\n}\n\nstatic void adm8211_set_interval(struct ieee80211_hw *dev,\n\t\t\t\t unsigned short bi, unsigned short li)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\tu32 reg;\n\n\t \n\treg = (bi << 16) | li;\n\tADM8211_CSR_WRITE(BPLI, reg);\n}\n\nstatic void adm8211_set_bssid(struct ieee80211_hw *dev, const u8 *bssid)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\tu32 reg;\n\n\tADM8211_CSR_WRITE(BSSID0, le32_to_cpu(*(__le32 *)bssid));\n\treg = ADM8211_CSR_READ(ABDA1);\n\treg &= 0x0000ffff;\n\treg |= (bssid[4] << 16) | (bssid[5] << 24);\n\tADM8211_CSR_WRITE(ABDA1, reg);\n}\n\nstatic int adm8211_config(struct ieee80211_hw *dev, u32 changed)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\tstruct ieee80211_conf *conf = &dev->conf;\n\tint channel =\n\t\tieee80211_frequency_to_channel(conf->chandef.chan->center_freq);\n\n\tif (channel != priv->channel) {\n\t\tpriv->channel = channel;\n\t\tadm8211_rf_set_channel(dev, priv->channel);\n\t}\n\n\treturn 0;\n}\n\nstatic void adm8211_bss_info_changed(struct ieee80211_hw *dev,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_bss_conf *conf,\n\t\t\t\t     u64 changes)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\n\tif (!(changes & BSS_CHANGED_BSSID))\n\t\treturn;\n\n\tif (!ether_addr_equal(conf->bssid, priv->bssid)) {\n\t\tadm8211_set_bssid(dev, conf->bssid);\n\t\tmemcpy(priv->bssid, conf->bssid, ETH_ALEN);\n\t}\n}\n\nstatic u64 adm8211_prepare_multicast(struct ieee80211_hw *hw,\n\t\t\t\t     struct netdev_hw_addr_list *mc_list)\n{\n\tunsigned int bit_nr;\n\tu32 mc_filter[2];\n\tstruct netdev_hw_addr *ha;\n\n\tmc_filter[1] = mc_filter[0] = 0;\n\n\tnetdev_hw_addr_list_for_each(ha, mc_list) {\n\t\tbit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;\n\n\t\tbit_nr &= 0x3F;\n\t\tmc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);\n\t}\n\n\treturn mc_filter[0] | ((u64)(mc_filter[1]) << 32);\n}\n\nstatic void adm8211_configure_filter(struct ieee80211_hw *dev,\n\t\t\t\t     unsigned int changed_flags,\n\t\t\t\t     unsigned int *total_flags,\n\t\t\t\t     u64 multicast)\n{\n\tstatic const u8 bcast[ETH_ALEN] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };\n\tstruct adm8211_priv *priv = dev->priv;\n\tunsigned int new_flags;\n\tu32 mc_filter[2];\n\n\tmc_filter[0] = multicast;\n\tmc_filter[1] = multicast >> 32;\n\n\tnew_flags = 0;\n\n\tif (*total_flags & FIF_ALLMULTI || multicast == ~(0ULL)) {\n\t\tnew_flags |= FIF_ALLMULTI;\n\t\tpriv->nar &= ~ADM8211_NAR_PR;\n\t\tpriv->nar |= ADM8211_NAR_MM;\n\t\tmc_filter[1] = mc_filter[0] = ~0;\n\t} else {\n\t\tpriv->nar &= ~(ADM8211_NAR_MM | ADM8211_NAR_PR);\n\t}\n\n\tADM8211_IDLE_RX();\n\n\tADM8211_CSR_WRITE(MAR0, mc_filter[0]);\n\tADM8211_CSR_WRITE(MAR1, mc_filter[1]);\n\tADM8211_CSR_READ(NAR);\n\n\tif (priv->nar & ADM8211_NAR_PR)\n\t\tieee80211_hw_set(dev, RX_INCLUDES_FCS);\n\telse\n\t\t__clear_bit(IEEE80211_HW_RX_INCLUDES_FCS, dev->flags);\n\n\tif (*total_flags & FIF_BCN_PRBRESP_PROMISC)\n\t\tadm8211_set_bssid(dev, bcast);\n\telse\n\t\tadm8211_set_bssid(dev, priv->bssid);\n\n\tADM8211_RESTORE();\n\n\t*total_flags = new_flags;\n}\n\nstatic int adm8211_add_interface(struct ieee80211_hw *dev,\n\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\tif (priv->mode != NL80211_IFTYPE_MONITOR)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tpriv->mode = vif->type;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tADM8211_IDLE();\n\n\tADM8211_CSR_WRITE(PAR0, le32_to_cpu(*(__le32 *)vif->addr));\n\tADM8211_CSR_WRITE(PAR1, le16_to_cpu(*(__le16 *)(vif->addr + 4)));\n\n\tadm8211_update_mode(dev);\n\n\tADM8211_RESTORE();\n\n\treturn 0;\n}\n\nstatic void adm8211_remove_interface(struct ieee80211_hw *dev,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\tpriv->mode = NL80211_IFTYPE_MONITOR;\n}\n\nstatic int adm8211_init_rings(struct ieee80211_hw *dev)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\tstruct adm8211_desc *desc = NULL;\n\tstruct adm8211_rx_ring_info *rx_info;\n\tstruct adm8211_tx_ring_info *tx_info;\n\tunsigned int i;\n\n\tfor (i = 0; i < priv->rx_ring_size; i++) {\n\t\tdesc = &priv->rx_ring[i];\n\t\tdesc->status = 0;\n\t\tdesc->length = cpu_to_le32(RX_PKT_SIZE);\n\t\tpriv->rx_buffers[i].skb = NULL;\n\t}\n\t \n\tdesc->length |= cpu_to_le32(RDES1_CONTROL_RER);\n\n\tfor (i = 0; i < priv->rx_ring_size; i++) {\n\t\tdesc = &priv->rx_ring[i];\n\t\trx_info = &priv->rx_buffers[i];\n\n\t\trx_info->skb = dev_alloc_skb(RX_PKT_SIZE);\n\t\tif (rx_info->skb == NULL)\n\t\t\tbreak;\n\t\trx_info->mapping = dma_map_single(&priv->pdev->dev,\n\t\t\t\t\t\t  skb_tail_pointer(rx_info->skb),\n\t\t\t\t\t\t  RX_PKT_SIZE,\n\t\t\t\t\t\t  DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(&priv->pdev->dev, rx_info->mapping)) {\n\t\t\tdev_kfree_skb(rx_info->skb);\n\t\t\trx_info->skb = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tdesc->buffer1 = cpu_to_le32(rx_info->mapping);\n\t\tdesc->status = cpu_to_le32(RDES0_STATUS_OWN | RDES0_STATUS_SQL);\n\t}\n\n\t \n\tfor (i = 0; i < priv->tx_ring_size; i++) {\n\t\tdesc = &priv->tx_ring[i];\n\t\ttx_info = &priv->tx_buffers[i];\n\n\t\ttx_info->skb = NULL;\n\t\ttx_info->mapping = 0;\n\t\tdesc->status = 0;\n\t}\n\tdesc->length = cpu_to_le32(TDES1_CONTROL_TER);\n\n\tpriv->cur_rx = priv->cur_tx = priv->dirty_tx = 0;\n\tADM8211_CSR_WRITE(RDB, priv->rx_ring_dma);\n\tADM8211_CSR_WRITE(TDBD, priv->tx_ring_dma);\n\n\treturn 0;\n}\n\nstatic void adm8211_free_rings(struct ieee80211_hw *dev)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\tunsigned int i;\n\n\tfor (i = 0; i < priv->rx_ring_size; i++) {\n\t\tif (!priv->rx_buffers[i].skb)\n\t\t\tcontinue;\n\n\t\tdma_unmap_single(&priv->pdev->dev,\n\t\t\t\t priv->rx_buffers[i].mapping, RX_PKT_SIZE,\n\t\t\t\t DMA_FROM_DEVICE);\n\n\t\tdev_kfree_skb(priv->rx_buffers[i].skb);\n\t}\n\n\tfor (i = 0; i < priv->tx_ring_size; i++) {\n\t\tif (!priv->tx_buffers[i].skb)\n\t\t\tcontinue;\n\n\t\tdma_unmap_single(&priv->pdev->dev,\n\t\t\t\t priv->tx_buffers[i].mapping,\n\t\t\t\t priv->tx_buffers[i].skb->len, DMA_TO_DEVICE);\n\n\t\tdev_kfree_skb(priv->tx_buffers[i].skb);\n\t}\n}\n\nstatic int adm8211_start(struct ieee80211_hw *dev)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\tint retval;\n\n\t \n\tretval = adm8211_hw_reset(dev);\n\tif (retval) {\n\t\twiphy_err(dev->wiphy, \"hardware reset failed\\n\");\n\t\tgoto fail;\n\t}\n\n\tretval = adm8211_init_rings(dev);\n\tif (retval) {\n\t\twiphy_err(dev->wiphy, \"failed to initialize rings\\n\");\n\t\tgoto fail;\n\t}\n\n\t \n\tadm8211_hw_init(dev);\n\tadm8211_rf_set_channel(dev, priv->channel);\n\n\tretval = request_irq(priv->pdev->irq, adm8211_interrupt,\n\t\t\t     IRQF_SHARED, \"adm8211\", dev);\n\tif (retval) {\n\t\twiphy_err(dev->wiphy, \"failed to register IRQ handler\\n\");\n\t\tgoto fail;\n\t}\n\n\tADM8211_CSR_WRITE(IER, ADM8211_IER_NIE | ADM8211_IER_AIE |\n\t\t\t       ADM8211_IER_RCIE | ADM8211_IER_TCIE |\n\t\t\t       ADM8211_IER_TDUIE | ADM8211_IER_GPTIE);\n\tpriv->mode = NL80211_IFTYPE_MONITOR;\n\tadm8211_update_mode(dev);\n\tADM8211_CSR_WRITE(RDR, 0);\n\n\tadm8211_set_interval(dev, 100, 10);\n\treturn 0;\n\nfail:\n\treturn retval;\n}\n\nstatic void adm8211_stop(struct ieee80211_hw *dev)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\n\tpriv->mode = NL80211_IFTYPE_UNSPECIFIED;\n\tpriv->nar = 0;\n\tADM8211_CSR_WRITE(NAR, 0);\n\tADM8211_CSR_WRITE(IER, 0);\n\tADM8211_CSR_READ(NAR);\n\n\tfree_irq(priv->pdev->irq, dev);\n\n\tadm8211_free_rings(dev);\n}\n\nstatic void adm8211_calc_durations(int *dur, int *plcp, size_t payload_len, int len,\n\t\t\t\t   int plcp_signal, int short_preamble)\n{\n\t \n\n \n#define IEEE80211_DUR_DS_LONG_PREAMBLE\t144\n#define IEEE80211_DUR_DS_SHORT_PREAMBLE\t72\n#define IEEE80211_DUR_DS_FAST_PLCPHDR\t24\n#define IEEE80211_DUR_DS_SLOW_PLCPHDR\t48\n#define IEEE80211_DUR_DS_SLOW_ACK\t112\n#define IEEE80211_DUR_DS_FAST_ACK\t56\n#define IEEE80211_DUR_DS_SLOW_CTS\t112\n#define IEEE80211_DUR_DS_FAST_CTS\t56\n#define IEEE80211_DUR_DS_SLOT\t\t20\n#define IEEE80211_DUR_DS_SIFS\t\t10\n\n\tint remainder;\n\n\t*dur = (80 * (24 + payload_len) + plcp_signal - 1)\n\t\t/ plcp_signal;\n\n\tif (plcp_signal <= PLCP_SIGNAL_2M)\n\t\t \n\t\t*dur += 3 * (IEEE80211_DUR_DS_SIFS +\n\t\t\t     IEEE80211_DUR_DS_SHORT_PREAMBLE +\n\t\t\t     IEEE80211_DUR_DS_FAST_PLCPHDR) +\n\t\t\t     IEEE80211_DUR_DS_SLOW_CTS + IEEE80211_DUR_DS_SLOW_ACK;\n\telse\n\t\t \n\t\t*dur += 3 * (IEEE80211_DUR_DS_SIFS +\n\t\t\t     IEEE80211_DUR_DS_SHORT_PREAMBLE +\n\t\t\t     IEEE80211_DUR_DS_FAST_PLCPHDR) +\n\t\t\t     IEEE80211_DUR_DS_FAST_CTS + IEEE80211_DUR_DS_FAST_ACK;\n\n\t \n\tif (!short_preamble)\n\t\t*dur +=\t3 * (IEEE80211_DUR_DS_LONG_PREAMBLE -\n\t\t\t     IEEE80211_DUR_DS_SHORT_PREAMBLE) +\n\t\t\t3 * (IEEE80211_DUR_DS_SLOW_PLCPHDR -\n\t\t\t     IEEE80211_DUR_DS_FAST_PLCPHDR);\n\n\n\t*plcp = (80 * len) / plcp_signal;\n\tremainder = (80 * len) % plcp_signal;\n\tif (plcp_signal == PLCP_SIGNAL_11M &&\n\t    remainder <= 30 && remainder > 0)\n\t\t*plcp = (*plcp | 0x8000) + 1;\n\telse if (remainder)\n\t\t(*plcp)++;\n}\n\n \nstatic int adm8211_tx_raw(struct ieee80211_hw *dev, struct sk_buff *skb,\n\t\t\t   u16 plcp_signal,\n\t\t\t   size_t hdrlen)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\tunsigned long flags;\n\tdma_addr_t mapping;\n\tunsigned int entry;\n\tu32 flag;\n\n\tmapping = dma_map_single(&priv->pdev->dev, skb->data, skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\tif (dma_mapping_error(&priv->pdev->dev, mapping))\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tif (priv->cur_tx - priv->dirty_tx == priv->tx_ring_size / 2)\n\t\tflag = TDES1_CONTROL_IC | TDES1_CONTROL_LS | TDES1_CONTROL_FS;\n\telse\n\t\tflag = TDES1_CONTROL_LS | TDES1_CONTROL_FS;\n\n\tif (priv->cur_tx - priv->dirty_tx == priv->tx_ring_size - 2)\n\t\tieee80211_stop_queue(dev, 0);\n\n\tentry = priv->cur_tx % priv->tx_ring_size;\n\n\tpriv->tx_buffers[entry].skb = skb;\n\tpriv->tx_buffers[entry].mapping = mapping;\n\tpriv->tx_buffers[entry].hdrlen = hdrlen;\n\tpriv->tx_ring[entry].buffer1 = cpu_to_le32(mapping);\n\n\tif (entry == priv->tx_ring_size - 1)\n\t\tflag |= TDES1_CONTROL_TER;\n\tpriv->tx_ring[entry].length = cpu_to_le32(flag | skb->len);\n\n\t \n\tflag = TDES0_CONTROL_OWN | (plcp_signal << 20) | 8  ;\n\tpriv->tx_ring[entry].status = cpu_to_le32(flag);\n\n\tpriv->cur_tx++;\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\t \n\tADM8211_CSR_WRITE(TDR, 0);\n\n\treturn 0;\n}\n\n \nstatic void adm8211_tx(struct ieee80211_hw *dev,\n\t\t       struct ieee80211_tx_control *control,\n\t\t       struct sk_buff *skb)\n{\n\tstruct adm8211_tx_hdr *txhdr;\n\tsize_t payload_len, hdrlen;\n\tint plcp, dur, len, plcp_signal, short_preamble;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_rate *txrate = ieee80211_get_tx_rate(dev, info);\n\tu8 rc_flags;\n\n\trc_flags = info->control.rates[0].flags;\n\tshort_preamble = !!(rc_flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE);\n\tplcp_signal = txrate->bitrate;\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\tmemcpy(skb->cb, skb->data, hdrlen);\n\thdr = (struct ieee80211_hdr *)skb->cb;\n\tskb_pull(skb, hdrlen);\n\tpayload_len = skb->len;\n\n\ttxhdr = skb_push(skb, sizeof(*txhdr));\n\tmemset(txhdr, 0, sizeof(*txhdr));\n\tmemcpy(txhdr->da, ieee80211_get_DA(hdr), ETH_ALEN);\n\ttxhdr->signal = plcp_signal;\n\ttxhdr->frame_body_size = cpu_to_le16(payload_len);\n\ttxhdr->frame_control = hdr->frame_control;\n\n\tlen = hdrlen + payload_len + FCS_LEN;\n\n\ttxhdr->frag = cpu_to_le16(0x0FFF);\n\tadm8211_calc_durations(&dur, &plcp, payload_len,\n\t\t\t       len, plcp_signal, short_preamble);\n\ttxhdr->plcp_frag_head_len = cpu_to_le16(plcp);\n\ttxhdr->plcp_frag_tail_len = cpu_to_le16(plcp);\n\ttxhdr->dur_frag_head = cpu_to_le16(dur);\n\ttxhdr->dur_frag_tail = cpu_to_le16(dur);\n\n\ttxhdr->header_control = cpu_to_le16(ADM8211_TXHDRCTL_ENABLE_EXTEND_HEADER);\n\n\tif (short_preamble)\n\t\ttxhdr->header_control |= cpu_to_le16(ADM8211_TXHDRCTL_SHORT_PREAMBLE);\n\n\tif (rc_flags & IEEE80211_TX_RC_USE_RTS_CTS)\n\t\ttxhdr->header_control |= cpu_to_le16(ADM8211_TXHDRCTL_ENABLE_RTS);\n\n\ttxhdr->retry_limit = info->control.rates[0].count;\n\n\tif (adm8211_tx_raw(dev, skb, plcp_signal, hdrlen)) {\n\t\t \n\t\tieee80211_free_txskb(dev, skb);\n\t}\n}\n\nstatic int adm8211_alloc_rings(struct ieee80211_hw *dev)\n{\n\tstruct adm8211_priv *priv = dev->priv;\n\tunsigned int ring_size;\n\n\tpriv->rx_buffers = kmalloc(sizeof(*priv->rx_buffers) * priv->rx_ring_size +\n\t\t\t\t   sizeof(*priv->tx_buffers) * priv->tx_ring_size, GFP_KERNEL);\n\tif (!priv->rx_buffers)\n\t\treturn -ENOMEM;\n\n\tpriv->tx_buffers = (void *)priv->rx_buffers +\n\t\t\t   sizeof(*priv->rx_buffers) * priv->rx_ring_size;\n\n\t \n\tring_size = sizeof(struct adm8211_desc) * priv->rx_ring_size +\n\t\t    sizeof(struct adm8211_desc) * priv->tx_ring_size;\n\tpriv->rx_ring = dma_alloc_coherent(&priv->pdev->dev, ring_size,\n\t\t\t\t\t   &priv->rx_ring_dma, GFP_KERNEL);\n\n\tif (!priv->rx_ring) {\n\t\tkfree(priv->rx_buffers);\n\t\tpriv->rx_buffers = NULL;\n\t\tpriv->tx_buffers = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->tx_ring = priv->rx_ring + priv->rx_ring_size;\n\tpriv->tx_ring_dma = priv->rx_ring_dma +\n\t\t\t    sizeof(struct adm8211_desc) * priv->rx_ring_size;\n\n\treturn 0;\n}\n\nstatic const struct ieee80211_ops adm8211_ops = {\n\t.tx\t\t\t= adm8211_tx,\n\t.wake_tx_queue\t\t= ieee80211_handle_wake_tx_queue,\n\t.start\t\t\t= adm8211_start,\n\t.stop\t\t\t= adm8211_stop,\n\t.add_interface\t\t= adm8211_add_interface,\n\t.remove_interface\t= adm8211_remove_interface,\n\t.config\t\t\t= adm8211_config,\n\t.bss_info_changed\t= adm8211_bss_info_changed,\n\t.prepare_multicast\t= adm8211_prepare_multicast,\n\t.configure_filter\t= adm8211_configure_filter,\n\t.get_stats\t\t= adm8211_get_stats,\n\t.get_tsf\t\t= adm8211_get_tsft\n};\n\nstatic int adm8211_probe(struct pci_dev *pdev,\n\t\t\t\t   const struct pci_device_id *id)\n{\n\tstruct ieee80211_hw *dev;\n\tstruct adm8211_priv *priv;\n\tunsigned long mem_len;\n\tunsigned int io_len;\n\tint err;\n\tu32 reg;\n\tu8 perm_addr[ETH_ALEN];\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s (adm8211): Cannot enable new PCI device\\n\",\n\t\t       pci_name(pdev));\n\t\treturn err;\n\t}\n\n\tio_len = pci_resource_len(pdev, 0);\n\tmem_len = pci_resource_len(pdev, 1);\n\tif (io_len < 256 || mem_len < 1024) {\n\t\tprintk(KERN_ERR \"%s (adm8211): Too short PCI resources\\n\",\n\t\t       pci_name(pdev));\n\t\terr = -ENOMEM;\n\t\tgoto err_disable_pdev;\n\t}\n\n\n\t \n\tpci_read_config_dword(pdev, 0x80  , &reg);\n\tif (reg != ADM8211_SIG1 && reg != ADM8211_SIG2) {\n\t\tprintk(KERN_ERR \"%s (adm8211): Invalid signature (0x%x)\\n\",\n\t\t       pci_name(pdev), reg);\n\t\terr = -EINVAL;\n\t\tgoto err_disable_pdev;\n\t}\n\n\terr = pci_request_regions(pdev, \"adm8211\");\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s (adm8211): Cannot obtain PCI resources\\n\",\n\t\t       pci_name(pdev));\n\t\treturn err;  \n\t}\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s (adm8211): No suitable DMA available\\n\",\n\t\t       pci_name(pdev));\n\t\tgoto err_free_reg;\n\t}\n\n\tpci_set_master(pdev);\n\n\tdev = ieee80211_alloc_hw(sizeof(*priv), &adm8211_ops);\n\tif (!dev) {\n\t\tprintk(KERN_ERR \"%s (adm8211): ieee80211 alloc failed\\n\",\n\t\t       pci_name(pdev));\n\t\terr = -ENOMEM;\n\t\tgoto err_free_reg;\n\t}\n\tpriv = dev->priv;\n\tpriv->pdev = pdev;\n\n\tspin_lock_init(&priv->lock);\n\n\tSET_IEEE80211_DEV(dev, &pdev->dev);\n\n\tpci_set_drvdata(pdev, dev);\n\n\tpriv->map = pci_iomap(pdev, 1, mem_len);\n\tif (!priv->map)\n\t\tpriv->map = pci_iomap(pdev, 0, io_len);\n\n\tif (!priv->map) {\n\t\tprintk(KERN_ERR \"%s (adm8211): Cannot map device memory\\n\",\n\t\t       pci_name(pdev));\n\t\terr = -ENOMEM;\n\t\tgoto err_free_dev;\n\t}\n\n\tpriv->rx_ring_size = rx_ring_size;\n\tpriv->tx_ring_size = tx_ring_size;\n\n\terr = adm8211_alloc_rings(dev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s (adm8211): Cannot allocate TX/RX ring\\n\",\n\t\t       pci_name(pdev));\n\t\tgoto err_iounmap;\n\t}\n\n\t*(__le32 *)perm_addr = cpu_to_le32(ADM8211_CSR_READ(PAR0));\n\t*(__le16 *)&perm_addr[4] =\n\t\tcpu_to_le16(ADM8211_CSR_READ(PAR1) & 0xFFFF);\n\n\tif (!is_valid_ether_addr(perm_addr)) {\n\t\tprintk(KERN_WARNING \"%s (adm8211): Invalid hwaddr in EEPROM!\\n\",\n\t\t       pci_name(pdev));\n\t\teth_random_addr(perm_addr);\n\t}\n\tSET_IEEE80211_PERM_ADDR(dev, perm_addr);\n\n\tdev->extra_tx_headroom = sizeof(struct adm8211_tx_hdr);\n\t \n\tieee80211_hw_set(dev, SIGNAL_UNSPEC);\n\tdev->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION);\n\n\tdev->max_signal = 100;     \n\n\tdev->queues = 1;  \n\n\tpriv->retry_limit = 3;\n\tpriv->ant_power = 0x40;\n\tpriv->tx_power = 0x40;\n\tpriv->lpf_cutoff = 0xFF;\n\tpriv->lnags_threshold = 0xFF;\n\tpriv->mode = NL80211_IFTYPE_UNSPECIFIED;\n\n\t \n\tif (pdev->revision >= ADM8211_REV_BA) {\n\t\tADM8211_CSR_WRITE(FRCTL, 0);\n\t\tADM8211_CSR_READ(FRCTL);\n\t\tADM8211_CSR_WRITE(FRCTL, 1);\n\t\tADM8211_CSR_READ(FRCTL);\n\t\tmsleep(100);\n\t}\n\n\terr = adm8211_read_eeprom(dev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s (adm8211): Can't alloc eeprom buffer\\n\",\n\t\t       pci_name(pdev));\n\t\tgoto err_free_desc;\n\t}\n\n\tpriv->channel = 1;\n\n\tdev->wiphy->bands[NL80211_BAND_2GHZ] = &priv->band;\n\n\twiphy_ext_feature_set(dev->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\terr = ieee80211_register_hw(dev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s (adm8211): Cannot register device\\n\",\n\t\t       pci_name(pdev));\n\t\tgoto err_free_eeprom;\n\t}\n\n\twiphy_info(dev->wiphy, \"hwaddr %pM, Rev 0x%02x\\n\",\n\t\t   dev->wiphy->perm_addr, pdev->revision);\n\n\treturn 0;\n\n err_free_eeprom:\n\tkfree(priv->eeprom);\n\n err_free_desc:\n\tdma_free_coherent(&pdev->dev,\n\t\t\t  sizeof(struct adm8211_desc) * priv->rx_ring_size +\n\t\t\t  sizeof(struct adm8211_desc) * priv->tx_ring_size,\n\t\t\t  priv->rx_ring, priv->rx_ring_dma);\n\tkfree(priv->rx_buffers);\n\n err_iounmap:\n\tpci_iounmap(pdev, priv->map);\n\n err_free_dev:\n\tieee80211_free_hw(dev);\n\n err_free_reg:\n\tpci_release_regions(pdev);\n\n err_disable_pdev:\n\tpci_disable_device(pdev);\n\treturn err;\n}\n\n\nstatic void adm8211_remove(struct pci_dev *pdev)\n{\n\tstruct ieee80211_hw *dev = pci_get_drvdata(pdev);\n\tstruct adm8211_priv *priv;\n\n\tif (!dev)\n\t\treturn;\n\n\tieee80211_unregister_hw(dev);\n\n\tpriv = dev->priv;\n\n\tdma_free_coherent(&pdev->dev,\n\t\t\t  sizeof(struct adm8211_desc) * priv->rx_ring_size +\n\t\t\t  sizeof(struct adm8211_desc) * priv->tx_ring_size,\n\t\t\t  priv->rx_ring, priv->rx_ring_dma);\n\n\tkfree(priv->rx_buffers);\n\tkfree(priv->eeprom);\n\tpci_iounmap(pdev, priv->map);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tieee80211_free_hw(dev);\n}\n\n\n#define adm8211_suspend NULL\n#define adm8211_resume NULL\n\nMODULE_DEVICE_TABLE(pci, adm8211_pci_id_table);\n\nstatic SIMPLE_DEV_PM_OPS(adm8211_pm_ops, adm8211_suspend, adm8211_resume);\n\n \nstatic struct pci_driver adm8211_driver = {\n\t.name\t\t= \"adm8211\",\n\t.id_table\t= adm8211_pci_id_table,\n\t.probe\t\t= adm8211_probe,\n\t.remove\t\t= adm8211_remove,\n\t.driver.pm\t= &adm8211_pm_ops,\n};\n\nmodule_pci_driver(adm8211_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}