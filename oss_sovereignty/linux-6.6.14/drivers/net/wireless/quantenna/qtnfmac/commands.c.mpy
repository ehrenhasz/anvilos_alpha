{
  "module_name": "commands.c",
  "hash_id": "4e2856ac28858e5992e3dbcca01505af2f7b677e23ece7c89004443661f5cca3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/quantenna/qtnfmac/commands.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/skbuff.h>\n\n#include \"cfg80211.h\"\n#include \"core.h\"\n#include \"qlink.h\"\n#include \"qlink_util.h\"\n#include \"bus.h\"\n#include \"commands.h\"\n\n \n#define QTNF_SCAN_TIME_AUTO\t0\n\n#define QTNF_SCAN_DWELL_ACTIVE_DEFAULT\t\t90\n#define QTNF_SCAN_DWELL_PASSIVE_DEFAULT\t\t100\n#define QTNF_SCAN_SAMPLE_DURATION_DEFAULT\tQTNF_SCAN_TIME_AUTO\n\nstatic int qtnf_cmd_check_reply_header(const struct qlink_resp *resp,\n\t\t\t\t       u16 cmd_id, u8 mac_id, u8 vif_id,\n\t\t\t\t       size_t resp_size)\n{\n\tif (unlikely(le16_to_cpu(resp->cmd_id) != cmd_id)) {\n\t\tpr_warn(\"VIF%u.%u CMD%x: bad cmd_id in response: 0x%.4X\\n\",\n\t\t\tmac_id, vif_id, cmd_id, le16_to_cpu(resp->cmd_id));\n\t\treturn -EINVAL;\n\t}\n\n\tif (unlikely(resp->macid != mac_id)) {\n\t\tpr_warn(\"VIF%u.%u CMD%x: bad MAC in response: %u\\n\",\n\t\t\tmac_id, vif_id, cmd_id, resp->macid);\n\t\treturn -EINVAL;\n\t}\n\n\tif (unlikely(resp->vifid != vif_id)) {\n\t\tpr_warn(\"VIF%u.%u CMD%x: bad VIF in response: %u\\n\",\n\t\t\tmac_id, vif_id, cmd_id, resp->vifid);\n\t\treturn -EINVAL;\n\t}\n\n\tif (unlikely(le16_to_cpu(resp->mhdr.len) < resp_size)) {\n\t\tpr_warn(\"VIF%u.%u CMD%x: bad response size %u < %zu\\n\",\n\t\t\tmac_id, vif_id, cmd_id,\n\t\t\tle16_to_cpu(resp->mhdr.len), resp_size);\n\t\treturn -ENOSPC;\n\t}\n\n\treturn 0;\n}\n\nstatic int qtnf_cmd_resp_result_decode(enum qlink_cmd_result qcode)\n{\n\tswitch (qcode) {\n\tcase QLINK_CMD_RESULT_OK:\n\t\treturn 0;\n\tcase QLINK_CMD_RESULT_INVALID:\n\t\treturn -EINVAL;\n\tcase QLINK_CMD_RESULT_ENOTSUPP:\n\t\treturn -ENOTSUPP;\n\tcase QLINK_CMD_RESULT_ENOTFOUND:\n\t\treturn -ENOENT;\n\tcase QLINK_CMD_RESULT_EALREADY:\n\t\treturn -EALREADY;\n\tcase QLINK_CMD_RESULT_EADDRINUSE:\n\t\treturn -EADDRINUSE;\n\tcase QLINK_CMD_RESULT_EADDRNOTAVAIL:\n\t\treturn -EADDRNOTAVAIL;\n\tcase QLINK_CMD_RESULT_EBUSY:\n\t\treturn -EBUSY;\n\tdefault:\n\t\treturn -EFAULT;\n\t}\n}\n\nstatic int qtnf_cmd_send_with_reply(struct qtnf_bus *bus,\n\t\t\t\t    struct sk_buff *cmd_skb,\n\t\t\t\t    struct sk_buff **response_skb,\n\t\t\t\t    size_t const_resp_size,\n\t\t\t\t    size_t *var_resp_size)\n{\n\tstruct qlink_cmd *cmd;\n\tstruct qlink_resp *resp = NULL;\n\tstruct sk_buff *resp_skb = NULL;\n\tint resp_res = 0;\n\tu16 cmd_id;\n\tu8 mac_id;\n\tu8 vif_id;\n\tint ret;\n\n\tcmd = (struct qlink_cmd *)cmd_skb->data;\n\tcmd_id = le16_to_cpu(cmd->cmd_id);\n\tmac_id = cmd->macid;\n\tvif_id = cmd->vifid;\n\tcmd->mhdr.len = cpu_to_le16(cmd_skb->len);\n\n\tpr_debug(\"VIF%u.%u cmd=0x%.4X\\n\", mac_id, vif_id, cmd_id);\n\n\tif (!qtnf_fw_is_up(bus) && cmd_id != QLINK_CMD_FW_INIT) {\n\t\tpr_warn(\"VIF%u.%u: drop cmd 0x%.4X in fw state %d\\n\",\n\t\t\tmac_id, vif_id, cmd_id, bus->fw_state);\n\t\tdev_kfree_skb(cmd_skb);\n\t\treturn -ENODEV;\n\t}\n\n\tret = qtnf_trans_send_cmd_with_resp(bus, cmd_skb, &resp_skb);\n\tif (ret)\n\t\tgoto out;\n\n\tif (WARN_ON(!resp_skb || !resp_skb->data)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tresp = (struct qlink_resp *)resp_skb->data;\n\tresp_res = le16_to_cpu(resp->result);\n\tret = qtnf_cmd_check_reply_header(resp, cmd_id, mac_id, vif_id,\n\t\t\t\t\t  const_resp_size);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (response_skb && var_resp_size)\n\t\t*var_resp_size = le16_to_cpu(resp->mhdr.len) - const_resp_size;\n\nout:\n\tif (response_skb)\n\t\t*response_skb = resp_skb;\n\telse\n\t\tconsume_skb(resp_skb);\n\n\tif (!ret)\n\t\treturn qtnf_cmd_resp_result_decode(resp_res);\n\n\tpr_warn(\"VIF%u.%u: cmd 0x%.4X failed: %d\\n\",\n\t\tmac_id, vif_id, cmd_id, ret);\n\n\treturn ret;\n}\n\nstatic inline int qtnf_cmd_send(struct qtnf_bus *bus, struct sk_buff *cmd_skb)\n{\n\treturn qtnf_cmd_send_with_reply(bus, cmd_skb, NULL,\n\t\t\t\t\tsizeof(struct qlink_resp), NULL);\n}\n\nstatic struct sk_buff *qtnf_cmd_alloc_new_cmdskb(u8 macid, u8 vifid, u16 cmd_no,\n\t\t\t\t\t\t size_t cmd_size)\n{\n\tstruct qlink_cmd *cmd;\n\tstruct sk_buff *cmd_skb;\n\n\tcmd_skb = __dev_alloc_skb(sizeof(*cmd) +\n\t\t\t\t  QTNF_MAX_CMD_BUF_SIZE, GFP_KERNEL);\n\tif (unlikely(!cmd_skb)) {\n\t\tpr_err(\"VIF%u.%u CMD %u: alloc failed\\n\", macid, vifid, cmd_no);\n\t\treturn NULL;\n\t}\n\n\tskb_put_zero(cmd_skb, cmd_size);\n\n\tcmd = (struct qlink_cmd *)cmd_skb->data;\n\tcmd->mhdr.len = cpu_to_le16(cmd_skb->len);\n\tcmd->mhdr.type = cpu_to_le16(QLINK_MSG_TYPE_CMD);\n\tcmd->cmd_id = cpu_to_le16(cmd_no);\n\tcmd->macid = macid;\n\tcmd->vifid = vifid;\n\n\treturn cmd_skb;\n}\n\nstatic void qtnf_cmd_tlv_ie_set_add(struct sk_buff *cmd_skb, u8 frame_type,\n\t\t\t\t    const u8 *buf, size_t len)\n{\n\tstruct qlink_tlv_ie_set *tlv;\n\n\ttlv = (struct qlink_tlv_ie_set *)skb_put(cmd_skb, sizeof(*tlv) +\n\t\t\t\t\t\t round_up(len, QLINK_ALIGN));\n\ttlv->hdr.type = cpu_to_le16(QTN_TLV_ID_IE_SET);\n\ttlv->hdr.len = cpu_to_le16(len + sizeof(*tlv) - sizeof(tlv->hdr));\n\ttlv->type = frame_type;\n\ttlv->flags = 0;\n\n\tif (len && buf)\n\t\tmemcpy(tlv->ie_data, buf, len);\n}\n\nstatic bool qtnf_cmd_start_ap_can_fit(const struct qtnf_vif *vif,\n\t\t\t\t      const struct cfg80211_ap_settings *s)\n{\n\tunsigned int len = sizeof(struct qlink_cmd_start_ap);\n\n\tlen += round_up(s->ssid_len, QLINK_ALIGN);\n\tlen += round_up(s->beacon.head_len, QLINK_ALIGN);\n\tlen += round_up(s->beacon.tail_len, QLINK_ALIGN);\n\tlen += round_up(s->beacon.beacon_ies_len, QLINK_ALIGN);\n\tlen += round_up(s->beacon.proberesp_ies_len, QLINK_ALIGN);\n\tlen += round_up(s->beacon.assocresp_ies_len, QLINK_ALIGN);\n\tlen += round_up(s->beacon.probe_resp_len, QLINK_ALIGN);\n\n\tif (cfg80211_chandef_valid(&s->chandef))\n\t\tlen += sizeof(struct qlink_tlv_chandef);\n\n\tif (s->acl) {\n\t\tunsigned int acl_len = struct_size(s->acl, mac_addrs,\n\t\t\t\t\t\t   s->acl->n_acl_entries);\n\n\t\tlen += sizeof(struct qlink_tlv_hdr) +\n\t\t\tround_up(acl_len, QLINK_ALIGN);\n\t}\n\n\tif (len > (sizeof(struct qlink_cmd) + QTNF_MAX_CMD_BUF_SIZE)) {\n\t\tpr_err(\"VIF%u.%u: can not fit AP settings: %u\\n\",\n\t\t       vif->mac->macid, vif->vifid, len);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void qtnf_cmd_tlv_ie_ext_add(struct sk_buff *cmd_skb, u8 eid_ext,\n\t\t\t\t    const void *buf, size_t len)\n{\n\tstruct qlink_tlv_ext_ie *tlv;\n\n\ttlv = (struct qlink_tlv_ext_ie *)skb_put(cmd_skb, sizeof(*tlv) + len);\n\ttlv->hdr.type = cpu_to_le16(WLAN_EID_EXTENSION);\n\ttlv->hdr.len = cpu_to_le16(sizeof(*tlv) + len - sizeof(tlv->hdr));\n\ttlv->eid_ext = eid_ext;\n\n\tif (len && buf)\n\t\tmemcpy(tlv->ie_data, buf, len);\n}\n\nint qtnf_cmd_send_start_ap(struct qtnf_vif *vif,\n\t\t\t   const struct cfg80211_ap_settings *s)\n{\n\tstruct sk_buff *cmd_skb;\n\tstruct qlink_cmd_start_ap *cmd;\n\tstruct qlink_auth_encr *aen;\n\tint ret;\n\tint i;\n\tint n;\n\n\tif (!qtnf_cmd_start_ap_can_fit(vif, s))\n\t\treturn -E2BIG;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_START_AP,\n\t\t\t\t\t    sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct qlink_cmd_start_ap *)cmd_skb->data;\n\tcmd->dtim_period = s->dtim_period;\n\tcmd->beacon_interval = cpu_to_le16(s->beacon_interval);\n\tcmd->hidden_ssid = qlink_hidden_ssid_nl2q(s->hidden_ssid);\n\tcmd->inactivity_timeout = cpu_to_le16(s->inactivity_timeout);\n\tcmd->smps_mode = s->smps_mode;\n\tcmd->p2p_ctwindow = s->p2p_ctwindow;\n\tcmd->p2p_opp_ps = s->p2p_opp_ps;\n\tcmd->pbss = s->pbss;\n\tcmd->ht_required = s->ht_required;\n\tcmd->vht_required = s->vht_required;\n\tcmd->twt_responder = s->twt_responder;\n\tif (s->he_obss_pd.enable) {\n\t\tcmd->sr_params.sr_control |= QLINK_SR_SRG_INFORMATION_PRESENT;\n\t\tcmd->sr_params.srg_obss_pd_min_offset =\n\t\t\ts->he_obss_pd.min_offset;\n\t\tcmd->sr_params.srg_obss_pd_max_offset =\n\t\t\ts->he_obss_pd.max_offset;\n\t}\n\n\taen = &cmd->aen;\n\taen->auth_type = s->auth_type;\n\taen->privacy = !!s->privacy;\n\taen->wpa_versions = cpu_to_le32(s->crypto.wpa_versions);\n\taen->cipher_group = cpu_to_le32(s->crypto.cipher_group);\n\taen->n_ciphers_pairwise = cpu_to_le32(s->crypto.n_ciphers_pairwise);\n\tfor (i = 0; i < QLINK_MAX_NR_CIPHER_SUITES; i++)\n\t\taen->ciphers_pairwise[i] =\n\t\t\t\tcpu_to_le32(s->crypto.ciphers_pairwise[i]);\n\tn = min(QLINK_MAX_NR_AKM_SUITES, s->crypto.n_akm_suites);\n\taen->n_akm_suites = cpu_to_le32(n);\n\tfor (i = 0; i < n; i++)\n\t\taen->akm_suites[i] = cpu_to_le32(s->crypto.akm_suites[i]);\n\taen->control_port = s->crypto.control_port;\n\taen->control_port_no_encrypt = s->crypto.control_port_no_encrypt;\n\taen->control_port_ethertype =\n\t\tcpu_to_le16(be16_to_cpu(s->crypto.control_port_ethertype));\n\n\tif (s->ssid && s->ssid_len > 0 && s->ssid_len <= IEEE80211_MAX_SSID_LEN)\n\t\tqtnf_cmd_skb_put_tlv_arr(cmd_skb, WLAN_EID_SSID, s->ssid,\n\t\t\t\t\t s->ssid_len);\n\n\tif (cfg80211_chandef_valid(&s->chandef)) {\n\t\tstruct qlink_tlv_chandef *chtlv =\n\t\t\t(struct qlink_tlv_chandef *)skb_put(cmd_skb,\n\t\t\t\t\t\t\t    sizeof(*chtlv));\n\n\t\tchtlv->hdr.type = cpu_to_le16(QTN_TLV_ID_CHANDEF);\n\t\tchtlv->hdr.len = cpu_to_le16(sizeof(*chtlv) -\n\t\t\t\t\t     sizeof(chtlv->hdr));\n\t\tqlink_chandef_cfg2q(&s->chandef, &chtlv->chdef);\n\t}\n\n\tqtnf_cmd_tlv_ie_set_add(cmd_skb, QLINK_IE_SET_BEACON_HEAD,\n\t\t\t\ts->beacon.head, s->beacon.head_len);\n\tqtnf_cmd_tlv_ie_set_add(cmd_skb, QLINK_IE_SET_BEACON_TAIL,\n\t\t\t\ts->beacon.tail, s->beacon.tail_len);\n\tqtnf_cmd_tlv_ie_set_add(cmd_skb, QLINK_IE_SET_BEACON_IES,\n\t\t\t\ts->beacon.beacon_ies, s->beacon.beacon_ies_len);\n\tqtnf_cmd_tlv_ie_set_add(cmd_skb, QLINK_IE_SET_PROBE_RESP,\n\t\t\t\ts->beacon.probe_resp, s->beacon.probe_resp_len);\n\tqtnf_cmd_tlv_ie_set_add(cmd_skb, QLINK_IE_SET_PROBE_RESP_IES,\n\t\t\t\ts->beacon.proberesp_ies,\n\t\t\t\ts->beacon.proberesp_ies_len);\n\tqtnf_cmd_tlv_ie_set_add(cmd_skb, QLINK_IE_SET_ASSOC_RESP,\n\t\t\t\ts->beacon.assocresp_ies,\n\t\t\t\ts->beacon.assocresp_ies_len);\n\n\tif (s->ht_cap) {\n\t\tstruct qlink_tlv_hdr *tlv = (struct qlink_tlv_hdr *)\n\t\t\tskb_put(cmd_skb, sizeof(*tlv) +\n\t\t\t\tround_up(sizeof(*s->ht_cap), QLINK_ALIGN));\n\n\t\ttlv->type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\n\t\ttlv->len = cpu_to_le16(sizeof(*s->ht_cap));\n\t\tmemcpy(tlv->val, s->ht_cap, sizeof(*s->ht_cap));\n\t}\n\n\tif (s->vht_cap) {\n\t\tstruct qlink_tlv_hdr *tlv = (struct qlink_tlv_hdr *)\n\t\t\tskb_put(cmd_skb, sizeof(*tlv) + sizeof(*s->vht_cap));\n\n\t\ttlv->type = cpu_to_le16(WLAN_EID_VHT_CAPABILITY);\n\t\ttlv->len = cpu_to_le16(sizeof(*s->vht_cap));\n\t\tmemcpy(tlv->val, s->vht_cap, sizeof(*s->vht_cap));\n\t}\n\n\tif (s->he_cap)\n\t\tqtnf_cmd_tlv_ie_ext_add(cmd_skb, WLAN_EID_EXT_HE_CAPABILITY,\n\t\t\t\t\ts->he_cap, sizeof(*s->he_cap));\n\n\tif (s->acl) {\n\t\tsize_t acl_size = struct_size(s->acl, mac_addrs,\n\t\t\t\t\t      s->acl->n_acl_entries);\n\t\tstruct qlink_tlv_hdr *tlv =\n\t\t\tskb_put(cmd_skb,\n\t\t\t\tsizeof(*tlv) + round_up(acl_size, QLINK_ALIGN));\n\n\t\ttlv->type = cpu_to_le16(QTN_TLV_ID_ACL_DATA);\n\t\ttlv->len = cpu_to_le16(acl_size);\n\t\tqlink_acl_data_cfg2q(s->acl, (struct qlink_acl_data *)tlv->val);\n\t}\n\n\tqtnf_bus_lock(vif->mac->bus);\n\tret = qtnf_cmd_send(vif->mac->bus, cmd_skb);\n\tif (ret)\n\t\tgoto out;\n\n\tnetif_carrier_on(vif->netdev);\n\nout:\n\tqtnf_bus_unlock(vif->mac->bus);\n\n\treturn ret;\n}\n\nint qtnf_cmd_send_stop_ap(struct qtnf_vif *vif)\n{\n\tstruct sk_buff *cmd_skb;\n\tint ret;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_STOP_AP,\n\t\t\t\t\t    sizeof(struct qlink_cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tqtnf_bus_lock(vif->mac->bus);\n\tret = qtnf_cmd_send(vif->mac->bus, cmd_skb);\n\tqtnf_bus_unlock(vif->mac->bus);\n\n\treturn ret;\n}\n\nint qtnf_cmd_send_register_mgmt(struct qtnf_vif *vif, u16 frame_type, bool reg)\n{\n\tstruct sk_buff *cmd_skb;\n\tstruct qlink_cmd_mgmt_frame_register *cmd;\n\tint ret;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_REGISTER_MGMT,\n\t\t\t\t\t    sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tqtnf_bus_lock(vif->mac->bus);\n\n\tcmd = (struct qlink_cmd_mgmt_frame_register *)cmd_skb->data;\n\tcmd->frame_type = cpu_to_le16(frame_type);\n\tcmd->do_register = reg;\n\n\tret = qtnf_cmd_send(vif->mac->bus, cmd_skb);\n\n\tqtnf_bus_unlock(vif->mac->bus);\n\n\treturn ret;\n}\n\nint qtnf_cmd_send_frame(struct qtnf_vif *vif, u32 cookie, u16 flags,\n\t\t\tu16 freq, const u8 *buf, size_t len)\n{\n\tstruct sk_buff *cmd_skb;\n\tstruct qlink_cmd_frame_tx *cmd;\n\tint ret;\n\n\tif (sizeof(*cmd) + len > QTNF_MAX_CMD_BUF_SIZE) {\n\t\tpr_warn(\"VIF%u.%u: frame is too big: %zu\\n\", vif->mac->macid,\n\t\t\tvif->vifid, len);\n\t\treturn -E2BIG;\n\t}\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_SEND_FRAME,\n\t\t\t\t\t    sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tqtnf_bus_lock(vif->mac->bus);\n\n\tcmd = (struct qlink_cmd_frame_tx *)cmd_skb->data;\n\tcmd->cookie = cpu_to_le32(cookie);\n\tcmd->freq = cpu_to_le16(freq);\n\tcmd->flags = cpu_to_le16(flags);\n\n\tif (len && buf)\n\t\tqtnf_cmd_skb_put_buffer(cmd_skb, buf, len);\n\n\tret = qtnf_cmd_send(vif->mac->bus, cmd_skb);\n\n\tqtnf_bus_unlock(vif->mac->bus);\n\n\treturn ret;\n}\n\nint qtnf_cmd_send_mgmt_set_appie(struct qtnf_vif *vif, u8 frame_type,\n\t\t\t\t const u8 *buf, size_t len)\n{\n\tstruct sk_buff *cmd_skb;\n\tint ret;\n\n\tif (len > QTNF_MAX_CMD_BUF_SIZE) {\n\t\tpr_warn(\"VIF%u.%u: %u frame is too big: %zu\\n\", vif->mac->macid,\n\t\t\tvif->vifid, frame_type, len);\n\t\treturn -E2BIG;\n\t}\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_MGMT_SET_APPIE,\n\t\t\t\t\t    sizeof(struct qlink_cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tqtnf_cmd_tlv_ie_set_add(cmd_skb, frame_type, buf, len);\n\n\tqtnf_bus_lock(vif->mac->bus);\n\tret = qtnf_cmd_send(vif->mac->bus, cmd_skb);\n\tqtnf_bus_unlock(vif->mac->bus);\n\n\treturn ret;\n}\n\nstatic void\nqtnf_sta_info_parse_rate(struct rate_info *rate_dst,\n\t\t\t const struct qlink_sta_info_rate *rate_src)\n{\n\trate_dst->legacy = get_unaligned_le16(&rate_src->rate) * 10;\n\n\trate_dst->mcs = rate_src->mcs;\n\trate_dst->nss = rate_src->nss;\n\trate_dst->flags = 0;\n\n\tswitch (rate_src->bw) {\n\tcase QLINK_CHAN_WIDTH_5:\n\t\trate_dst->bw = RATE_INFO_BW_5;\n\t\tbreak;\n\tcase QLINK_CHAN_WIDTH_10:\n\t\trate_dst->bw = RATE_INFO_BW_10;\n\t\tbreak;\n\tcase QLINK_CHAN_WIDTH_20:\n\tcase QLINK_CHAN_WIDTH_20_NOHT:\n\t\trate_dst->bw = RATE_INFO_BW_20;\n\t\tbreak;\n\tcase QLINK_CHAN_WIDTH_40:\n\t\trate_dst->bw = RATE_INFO_BW_40;\n\t\tbreak;\n\tcase QLINK_CHAN_WIDTH_80:\n\t\trate_dst->bw = RATE_INFO_BW_80;\n\t\tbreak;\n\tcase QLINK_CHAN_WIDTH_160:\n\t\trate_dst->bw = RATE_INFO_BW_160;\n\t\tbreak;\n\tdefault:\n\t\trate_dst->bw = 0;\n\t\tbreak;\n\t}\n\n\tif (rate_src->flags & QLINK_STA_INFO_RATE_FLAG_HT_MCS)\n\t\trate_dst->flags |= RATE_INFO_FLAGS_MCS;\n\telse if (rate_src->flags & QLINK_STA_INFO_RATE_FLAG_VHT_MCS)\n\t\trate_dst->flags |= RATE_INFO_FLAGS_VHT_MCS;\n\telse if (rate_src->flags & QLINK_STA_INFO_RATE_FLAG_HE_MCS)\n\t\trate_dst->flags |= RATE_INFO_FLAGS_HE_MCS;\n\n\tif (rate_src->flags & QLINK_STA_INFO_RATE_FLAG_SHORT_GI)\n\t\trate_dst->flags |= RATE_INFO_FLAGS_SHORT_GI;\n}\n\nstatic void\nqtnf_sta_info_parse_flags(struct nl80211_sta_flag_update *dst,\n\t\t\t  const struct qlink_sta_info_state *src)\n{\n\tu32 mask, value;\n\n\tdst->mask = 0;\n\tdst->set = 0;\n\n\tmask = le32_to_cpu(src->mask);\n\tvalue = le32_to_cpu(src->value);\n\n\tif (mask & QLINK_STA_FLAG_AUTHORIZED) {\n\t\tdst->mask |= BIT(NL80211_STA_FLAG_AUTHORIZED);\n\t\tif (value & QLINK_STA_FLAG_AUTHORIZED)\n\t\t\tdst->set |= BIT(NL80211_STA_FLAG_AUTHORIZED);\n\t}\n\n\tif (mask & QLINK_STA_FLAG_SHORT_PREAMBLE) {\n\t\tdst->mask |= BIT(NL80211_STA_FLAG_SHORT_PREAMBLE);\n\t\tif (value & QLINK_STA_FLAG_SHORT_PREAMBLE)\n\t\t\tdst->set |= BIT(NL80211_STA_FLAG_SHORT_PREAMBLE);\n\t}\n\n\tif (mask & QLINK_STA_FLAG_WME) {\n\t\tdst->mask |= BIT(NL80211_STA_FLAG_WME);\n\t\tif (value & QLINK_STA_FLAG_WME)\n\t\t\tdst->set |= BIT(NL80211_STA_FLAG_WME);\n\t}\n\n\tif (mask & QLINK_STA_FLAG_MFP) {\n\t\tdst->mask |= BIT(NL80211_STA_FLAG_MFP);\n\t\tif (value & QLINK_STA_FLAG_MFP)\n\t\t\tdst->set |= BIT(NL80211_STA_FLAG_MFP);\n\t}\n\n\tif (mask & QLINK_STA_FLAG_AUTHENTICATED) {\n\t\tdst->mask |= BIT(NL80211_STA_FLAG_AUTHENTICATED);\n\t\tif (value & QLINK_STA_FLAG_AUTHENTICATED)\n\t\t\tdst->set |= BIT(NL80211_STA_FLAG_AUTHENTICATED);\n\t}\n\n\tif (mask & QLINK_STA_FLAG_TDLS_PEER) {\n\t\tdst->mask |= BIT(NL80211_STA_FLAG_TDLS_PEER);\n\t\tif (value & QLINK_STA_FLAG_TDLS_PEER)\n\t\t\tdst->set |= BIT(NL80211_STA_FLAG_TDLS_PEER);\n\t}\n\n\tif (mask & QLINK_STA_FLAG_ASSOCIATED) {\n\t\tdst->mask |= BIT(NL80211_STA_FLAG_ASSOCIATED);\n\t\tif (value & QLINK_STA_FLAG_ASSOCIATED)\n\t\t\tdst->set |= BIT(NL80211_STA_FLAG_ASSOCIATED);\n\t}\n}\n\nstatic void\nqtnf_cmd_sta_info_parse(struct station_info *sinfo, const u8 *data,\n\t\t\tsize_t resp_size)\n{\n\tconst struct qlink_tlv_hdr *tlv;\n\tconst struct qlink_sta_stats *stats = NULL;\n\tconst u8 *map = NULL;\n\tunsigned int map_len = 0;\n\tunsigned int stats_len = 0;\n\tu16 tlv_len;\n\n#define qtnf_sta_stat_avail(stat_name, bitn)\t\\\n\t(qtnf_utils_is_bit_set(map, bitn, map_len) && \\\n\t (offsetofend(struct qlink_sta_stats, stat_name) <= stats_len))\n\n\tqlink_for_each_tlv(tlv, data, resp_size) {\n\t\ttlv_len = le16_to_cpu(tlv->len);\n\n\t\tswitch (le16_to_cpu(tlv->type)) {\n\t\tcase QTN_TLV_ID_BITMAP:\n\t\t\tmap_len = tlv_len;\n\t\t\tmap = tlv->val;\n\t\t\tbreak;\n\t\tcase QTN_TLV_ID_STA_STATS:\n\t\t\tstats_len = tlv_len;\n\t\t\tstats = (const struct qlink_sta_stats *)tlv->val;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!qlink_tlv_parsing_ok(tlv, data, resp_size)) {\n\t\tpr_err(\"Malformed TLV buffer\\n\");\n\t\treturn;\n\t}\n\n\tif (!map || !stats)\n\t\treturn;\n\n\tif (qtnf_sta_stat_avail(inactive_time, QLINK_STA_INFO_INACTIVE_TIME)) {\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_INACTIVE_TIME);\n\t\tsinfo->inactive_time = le32_to_cpu(stats->inactive_time);\n\t}\n\n\tif (qtnf_sta_stat_avail(connected_time,\n\t\t\t\tQLINK_STA_INFO_CONNECTED_TIME)) {\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_CONNECTED_TIME);\n\t\tsinfo->connected_time = le32_to_cpu(stats->connected_time);\n\t}\n\n\tif (qtnf_sta_stat_avail(signal, QLINK_STA_INFO_SIGNAL)) {\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL);\n\t\tsinfo->signal = stats->signal - QLINK_RSSI_OFFSET;\n\t}\n\n\tif (qtnf_sta_stat_avail(signal_avg, QLINK_STA_INFO_SIGNAL_AVG)) {\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL_AVG);\n\t\tsinfo->signal_avg = stats->signal_avg - QLINK_RSSI_OFFSET;\n\t}\n\n\tif (qtnf_sta_stat_avail(rxrate, QLINK_STA_INFO_RX_BITRATE)) {\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_BITRATE);\n\t\tqtnf_sta_info_parse_rate(&sinfo->rxrate, &stats->rxrate);\n\t}\n\n\tif (qtnf_sta_stat_avail(txrate, QLINK_STA_INFO_TX_BITRATE)) {\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);\n\t\tqtnf_sta_info_parse_rate(&sinfo->txrate, &stats->txrate);\n\t}\n\n\tif (qtnf_sta_stat_avail(sta_flags, QLINK_STA_INFO_STA_FLAGS)) {\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_STA_FLAGS);\n\t\tqtnf_sta_info_parse_flags(&sinfo->sta_flags, &stats->sta_flags);\n\t}\n\n\tif (qtnf_sta_stat_avail(rx_bytes, QLINK_STA_INFO_RX_BYTES)) {\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_BYTES);\n\t\tsinfo->rx_bytes = le64_to_cpu(stats->rx_bytes);\n\t}\n\n\tif (qtnf_sta_stat_avail(tx_bytes, QLINK_STA_INFO_TX_BYTES)) {\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BYTES);\n\t\tsinfo->tx_bytes = le64_to_cpu(stats->tx_bytes);\n\t}\n\n\tif (qtnf_sta_stat_avail(rx_bytes, QLINK_STA_INFO_RX_BYTES64)) {\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_BYTES64);\n\t\tsinfo->rx_bytes = le64_to_cpu(stats->rx_bytes);\n\t}\n\n\tif (qtnf_sta_stat_avail(tx_bytes, QLINK_STA_INFO_TX_BYTES64)) {\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BYTES64);\n\t\tsinfo->tx_bytes = le64_to_cpu(stats->tx_bytes);\n\t}\n\n\tif (qtnf_sta_stat_avail(rx_packets, QLINK_STA_INFO_RX_PACKETS)) {\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_PACKETS);\n\t\tsinfo->rx_packets = le32_to_cpu(stats->rx_packets);\n\t}\n\n\tif (qtnf_sta_stat_avail(tx_packets, QLINK_STA_INFO_TX_PACKETS)) {\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_PACKETS);\n\t\tsinfo->tx_packets = le32_to_cpu(stats->tx_packets);\n\t}\n\n\tif (qtnf_sta_stat_avail(rx_beacon, QLINK_STA_INFO_BEACON_RX)) {\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_BEACON_RX);\n\t\tsinfo->rx_beacon = le64_to_cpu(stats->rx_beacon);\n\t}\n\n\tif (qtnf_sta_stat_avail(rx_dropped_misc, QLINK_STA_INFO_RX_DROP_MISC)) {\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_DROP_MISC);\n\t\tsinfo->rx_dropped_misc = le32_to_cpu(stats->rx_dropped_misc);\n\t}\n\n\tif (qtnf_sta_stat_avail(tx_failed, QLINK_STA_INFO_TX_FAILED)) {\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_FAILED);\n\t\tsinfo->tx_failed = le32_to_cpu(stats->tx_failed);\n\t}\n\n#undef qtnf_sta_stat_avail\n}\n\nint qtnf_cmd_get_sta_info(struct qtnf_vif *vif, const u8 *sta_mac,\n\t\t\t  struct station_info *sinfo)\n{\n\tstruct sk_buff *cmd_skb, *resp_skb = NULL;\n\tstruct qlink_cmd_get_sta_info *cmd;\n\tconst struct qlink_resp_get_sta_info *resp;\n\tsize_t var_resp_len = 0;\n\tint ret = 0;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_GET_STA_INFO,\n\t\t\t\t\t    sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tqtnf_bus_lock(vif->mac->bus);\n\n\tcmd = (struct qlink_cmd_get_sta_info *)cmd_skb->data;\n\tether_addr_copy(cmd->sta_addr, sta_mac);\n\n\tret = qtnf_cmd_send_with_reply(vif->mac->bus, cmd_skb, &resp_skb,\n\t\t\t\t       sizeof(*resp), &var_resp_len);\n\tif (ret)\n\t\tgoto out;\n\n\tresp = (const struct qlink_resp_get_sta_info *)resp_skb->data;\n\n\tif (!ether_addr_equal(sta_mac, resp->sta_addr)) {\n\t\tpr_err(\"VIF%u.%u: wrong mac in reply: %pM != %pM\\n\",\n\t\t       vif->mac->macid, vif->vifid, resp->sta_addr, sta_mac);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tqtnf_cmd_sta_info_parse(sinfo, resp->info, var_resp_len);\n\nout:\n\tqtnf_bus_unlock(vif->mac->bus);\n\tconsume_skb(resp_skb);\n\n\treturn ret;\n}\n\nstatic int qtnf_cmd_send_add_change_intf(struct qtnf_vif *vif,\n\t\t\t\t\t enum nl80211_iftype iftype,\n\t\t\t\t\t int use4addr,\n\t\t\t\t\t u8 *mac_addr,\n\t\t\t\t\t enum qlink_cmd_type cmd_type)\n{\n\tstruct sk_buff *cmd_skb, *resp_skb = NULL;\n\tstruct qlink_cmd_manage_intf *cmd;\n\tconst struct qlink_resp_manage_intf *resp;\n\tint ret = 0;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    cmd_type,\n\t\t\t\t\t    sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tqtnf_bus_lock(vif->mac->bus);\n\n\tcmd = (struct qlink_cmd_manage_intf *)cmd_skb->data;\n\tcmd->intf_info.use4addr = use4addr;\n\n\tswitch (iftype) {\n\tcase NL80211_IFTYPE_AP:\n\t\tcmd->intf_info.if_type = cpu_to_le16(QLINK_IFTYPE_AP);\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tcmd->intf_info.if_type = cpu_to_le16(QLINK_IFTYPE_STATION);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"VIF%u.%u: unsupported type %d\\n\", vif->mac->macid,\n\t\t       vif->vifid, iftype);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (mac_addr)\n\t\tether_addr_copy(cmd->intf_info.mac_addr, mac_addr);\n\telse\n\t\teth_zero_addr(cmd->intf_info.mac_addr);\n\n\tret = qtnf_cmd_send_with_reply(vif->mac->bus, cmd_skb, &resp_skb,\n\t\t\t\t       sizeof(*resp), NULL);\n\tif (ret)\n\t\tgoto out;\n\n\tresp = (const struct qlink_resp_manage_intf *)resp_skb->data;\n\tether_addr_copy(vif->mac_addr, resp->intf_info.mac_addr);\n\nout:\n\tqtnf_bus_unlock(vif->mac->bus);\n\tconsume_skb(resp_skb);\n\n\treturn ret;\n}\n\nint qtnf_cmd_send_add_intf(struct qtnf_vif *vif, enum nl80211_iftype iftype,\n\t\t\t   int use4addr, u8 *mac_addr)\n{\n\treturn qtnf_cmd_send_add_change_intf(vif, iftype, use4addr, mac_addr,\n\t\t\tQLINK_CMD_ADD_INTF);\n}\n\nint qtnf_cmd_send_change_intf_type(struct qtnf_vif *vif,\n\t\t\t\t   enum nl80211_iftype iftype,\n\t\t\t\t   int use4addr,\n\t\t\t\t   u8 *mac_addr)\n{\n\tint ret;\n\n\tret = qtnf_cmd_send_add_change_intf(vif, iftype, use4addr, mac_addr,\n\t\t\t\t\t    QLINK_CMD_CHANGE_INTF);\n\n\t \n\tif (ret == 0 && vif->wdev.iftype != iftype) {\n\t\tenum nl80211_band band;\n\t\tstruct wiphy *wiphy = priv_to_wiphy(vif->mac);\n\n\t\tfor (band = 0; band < NUM_NL80211_BANDS; ++band) {\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\n\t\t\tqtnf_cmd_band_info_get(vif->mac, wiphy->bands[band]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint qtnf_cmd_send_del_intf(struct qtnf_vif *vif)\n{\n\tstruct sk_buff *cmd_skb;\n\tstruct qlink_cmd_manage_intf *cmd;\n\tint ret = 0;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_DEL_INTF,\n\t\t\t\t\t    sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tqtnf_bus_lock(vif->mac->bus);\n\n\tcmd = (struct qlink_cmd_manage_intf *)cmd_skb->data;\n\n\tswitch (vif->wdev.iftype) {\n\tcase NL80211_IFTYPE_AP:\n\t\tcmd->intf_info.if_type = cpu_to_le16(QLINK_IFTYPE_AP);\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tcmd->intf_info.if_type = cpu_to_le16(QLINK_IFTYPE_STATION);\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"VIF%u.%u: unsupported iftype %d\\n\", vif->mac->macid,\n\t\t\tvif->vifid, vif->wdev.iftype);\n\t\tdev_kfree_skb(cmd_skb);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\teth_zero_addr(cmd->intf_info.mac_addr);\n\n\tret = qtnf_cmd_send(vif->mac->bus, cmd_skb);\n\tif (ret)\n\t\tgoto out;\n\nout:\n\tqtnf_bus_unlock(vif->mac->bus);\n\treturn ret;\n}\n\nstatic int\nqtnf_cmd_resp_proc_hw_info(struct qtnf_bus *bus,\n\t\t\t   const struct qlink_resp_get_hw_info *resp,\n\t\t\t   size_t info_len)\n{\n\tstruct qtnf_hw_info *hwinfo = &bus->hw_info;\n\tconst struct qlink_tlv_hdr *tlv;\n\tconst char *bld_name = NULL;\n\tconst char *bld_rev = NULL;\n\tconst char *bld_type = NULL;\n\tconst char *bld_label = NULL;\n\tu32 bld_tmstamp = 0;\n\tu32 plat_id = 0;\n\tconst char *hw_id = NULL;\n\tconst char *calibration_ver = NULL;\n\tconst char *uboot_ver = NULL;\n\tu32 hw_ver = 0;\n\tu16 tlv_type;\n\tu16 tlv_len;\n\n\thwinfo->num_mac = resp->num_mac;\n\thwinfo->mac_bitmap = resp->mac_bitmap;\n\thwinfo->fw_ver = le32_to_cpu(resp->fw_ver);\n\thwinfo->total_tx_chain = resp->total_tx_chain;\n\thwinfo->total_rx_chain = resp->total_rx_chain;\n\n\tbld_tmstamp = le32_to_cpu(resp->bld_tmstamp);\n\tplat_id = le32_to_cpu(resp->plat_id);\n\thw_ver = le32_to_cpu(resp->hw_ver);\n\n\tqlink_for_each_tlv(tlv, resp->info, info_len) {\n\t\ttlv_type = le16_to_cpu(tlv->type);\n\t\ttlv_len = le16_to_cpu(tlv->len);\n\n\t\tswitch (tlv_type) {\n\t\tcase QTN_TLV_ID_BUILD_NAME:\n\t\t\tbld_name = (const void *)tlv->val;\n\t\t\tbreak;\n\t\tcase QTN_TLV_ID_BUILD_REV:\n\t\t\tbld_rev = (const void *)tlv->val;\n\t\t\tbreak;\n\t\tcase QTN_TLV_ID_BUILD_TYPE:\n\t\t\tbld_type = (const void *)tlv->val;\n\t\t\tbreak;\n\t\tcase QTN_TLV_ID_BUILD_LABEL:\n\t\t\tbld_label = (const void *)tlv->val;\n\t\t\tbreak;\n\t\tcase QTN_TLV_ID_HW_ID:\n\t\t\thw_id = (const void *)tlv->val;\n\t\t\tbreak;\n\t\tcase QTN_TLV_ID_CALIBRATION_VER:\n\t\t\tcalibration_ver = (const void *)tlv->val;\n\t\t\tbreak;\n\t\tcase QTN_TLV_ID_UBOOT_VER:\n\t\t\tuboot_ver = (const void *)tlv->val;\n\t\t\tbreak;\n\t\tcase QTN_TLV_ID_BITMAP:\n\t\t\tmemcpy(hwinfo->hw_capab, tlv->val,\n\t\t\t       min(sizeof(hwinfo->hw_capab), (size_t)tlv_len));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!qlink_tlv_parsing_ok(tlv, resp->info, info_len)) {\n\t\tpr_err(\"Malformed TLV buffer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpr_info(\"\\nBuild name:            %s\\n\"\n\t\t\"Build revision:        %s\\n\"\n\t\t\"Build type:            %s\\n\"\n\t\t\"Build label:           %s\\n\"\n\t\t\"Build timestamp:       %lu\\n\"\n\t\t\"Platform ID:           %lu\\n\"\n\t\t\"Hardware ID:           %s\\n\"\n\t\t\"Calibration version:   %s\\n\"\n\t\t\"U-Boot version:        %s\\n\"\n\t\t\"Hardware version:      0x%08x\\n\"\n\t\t\"Qlink ver:             %u.%u\\n\"\n\t\t\"MACs map:              %#x\\n\"\n\t\t\"Chains Rx-Tx:          %ux%u\\n\"\n\t\t\"FW version:            0x%x\\n\",\n\t\tbld_name, bld_rev, bld_type, bld_label,\n\t\t(unsigned long)bld_tmstamp,\n\t\t(unsigned long)plat_id,\n\t\thw_id, calibration_ver, uboot_ver, hw_ver,\n\t\tQLINK_VER_MAJOR(bus->hw_info.ql_proto_ver),\n\t\tQLINK_VER_MINOR(bus->hw_info.ql_proto_ver),\n\t\thwinfo->mac_bitmap,\n\t\thwinfo->total_rx_chain, hwinfo->total_tx_chain,\n\t\thwinfo->fw_ver);\n\n\tstrscpy(hwinfo->fw_version, bld_label, sizeof(hwinfo->fw_version));\n\thwinfo->hw_version = hw_ver;\n\n\treturn 0;\n}\n\nstatic void\nqtnf_parse_wowlan_info(struct qtnf_wmac *mac,\n\t\t       const struct qlink_wowlan_capab_data *wowlan)\n{\n\tstruct qtnf_mac_info *mac_info = &mac->macinfo;\n\tconst struct qlink_wowlan_support *data1;\n\tstruct wiphy_wowlan_support *supp;\n\n\tsupp = kzalloc(sizeof(*supp), GFP_KERNEL);\n\tif (!supp)\n\t\treturn;\n\n\tswitch (le16_to_cpu(wowlan->version)) {\n\tcase 0x1:\n\t\tdata1 = (struct qlink_wowlan_support *)wowlan->data;\n\n\t\tsupp->flags = WIPHY_WOWLAN_MAGIC_PKT | WIPHY_WOWLAN_DISCONNECT;\n\t\tsupp->n_patterns = le32_to_cpu(data1->n_patterns);\n\t\tsupp->pattern_max_len = le32_to_cpu(data1->pattern_max_len);\n\t\tsupp->pattern_min_len = le32_to_cpu(data1->pattern_min_len);\n\n\t\tmac_info->wowlan = supp;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"MAC%u: unsupported WoWLAN version 0x%x\\n\",\n\t\t\tmac->macid, le16_to_cpu(wowlan->version));\n\t\tkfree(supp);\n\t\tbreak;\n\t}\n}\n\nstatic int\nqtnf_parse_variable_mac_info(struct qtnf_wmac *mac,\n\t\t\t     const struct qlink_resp_get_mac_info *resp,\n\t\t\t     size_t tlv_buf_size)\n{\n\tstruct ieee80211_iface_combination *comb = mac->macinfo.if_comb;\n\tsize_t n_comb = 0;\n\tstruct ieee80211_iface_limit *limits;\n\tconst struct qlink_iface_limit_record *rec;\n\tconst struct qlink_iface_limit *lim;\n\tconst struct qlink_wowlan_capab_data *wowlan;\n\tu16 rec_len;\n\tu16 tlv_type;\n\tu16 tlv_value_len;\n\tconst struct qlink_tlv_hdr *tlv;\n\tu8 *ext_capa = NULL;\n\tu8 *ext_capa_mask = NULL;\n\tu8 ext_capa_len = 0;\n\tu8 ext_capa_mask_len = 0;\n\tint i = 0;\n\tstruct ieee80211_reg_rule *rule;\n\tunsigned int rule_idx = 0;\n\tconst struct qlink_tlv_reg_rule *tlv_rule;\n\n\tif (WARN_ON(resp->n_reg_rules > NL80211_MAX_SUPP_REG_RULES))\n\t\treturn -E2BIG;\n\n\tmac->rd = kzalloc(struct_size(mac->rd, reg_rules, resp->n_reg_rules),\n\t\t\t  GFP_KERNEL);\n\tif (!mac->rd)\n\t\treturn -ENOMEM;\n\n\tmac->rd->n_reg_rules = resp->n_reg_rules;\n\tmac->rd->alpha2[0] = resp->alpha2[0];\n\tmac->rd->alpha2[1] = resp->alpha2[1];\n\n\tswitch (resp->dfs_region) {\n\tcase QLINK_DFS_FCC:\n\t\tmac->rd->dfs_region = NL80211_DFS_FCC;\n\t\tbreak;\n\tcase QLINK_DFS_ETSI:\n\t\tmac->rd->dfs_region = NL80211_DFS_ETSI;\n\t\tbreak;\n\tcase QLINK_DFS_JP:\n\t\tmac->rd->dfs_region = NL80211_DFS_JP;\n\t\tbreak;\n\tcase QLINK_DFS_UNSET:\n\tdefault:\n\t\tmac->rd->dfs_region = NL80211_DFS_UNSET;\n\t\tbreak;\n\t}\n\n\tqlink_for_each_tlv(tlv, resp->var_info, tlv_buf_size) {\n\t\ttlv_type = le16_to_cpu(tlv->type);\n\t\ttlv_value_len = le16_to_cpu(tlv->len);\n\n\t\tswitch (tlv_type) {\n\t\tcase QTN_TLV_ID_IFACE_LIMIT:\n\t\t\tif (unlikely(!comb)) {\n\t\t\t\tpr_warn(\"MAC%u: no combinations advertised\\n\",\n\t\t\t\t\tmac->macid);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (n_comb >= mac->macinfo.n_if_comb) {\n\t\t\t\tpr_warn(\"MAC%u: combinations count exceeded\\n\",\n\t\t\t\t\tmac->macid);\n\t\t\t\tn_comb++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trec = (void *)tlv->val;\n\t\t\trec_len = sizeof(*rec) + rec->n_limits * sizeof(*lim);\n\n\t\t\tif (unlikely(tlv_value_len != rec_len)) {\n\t\t\t\tpr_warn(\"MAC%u: record %zu size mismatch\\n\",\n\t\t\t\t\tmac->macid, n_comb);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tlimits = kcalloc(rec->n_limits, sizeof(*limits),\n\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!limits)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tcomb[n_comb].num_different_channels =\n\t\t\t\trec->num_different_channels;\n\t\t\tcomb[n_comb].max_interfaces =\n\t\t\t\tle16_to_cpu(rec->max_interfaces);\n\t\t\tcomb[n_comb].n_limits = rec->n_limits;\n\t\t\tcomb[n_comb].limits = limits;\n\n\t\t\tfor (i = 0; i < rec->n_limits; i++) {\n\t\t\t\tlim = &rec->limits[i];\n\t\t\t\tlimits[i].max = le16_to_cpu(lim->max_num);\n\t\t\t\tlimits[i].types =\n\t\t\t\t\tqlink_iface_type_to_nl_mask(le16_to_cpu(lim->type));\n\t\t\t\tpr_debug(\"MAC%u: comb[%zu]: MAX:%u TYPES:%.4X\\n\",\n\t\t\t\t\t mac->macid, n_comb,\n\t\t\t\t\t limits[i].max, limits[i].types);\n\t\t\t}\n\n\t\t\tn_comb++;\n\t\t\tbreak;\n\t\tcase WLAN_EID_EXT_CAPABILITY:\n\t\t\tif (unlikely(tlv_value_len > U8_MAX))\n\t\t\t\treturn -EINVAL;\n\t\t\text_capa = (u8 *)tlv->val;\n\t\t\text_capa_len = tlv_value_len;\n\t\t\tbreak;\n\t\tcase QTN_TLV_ID_EXT_CAPABILITY_MASK:\n\t\t\tif (unlikely(tlv_value_len > U8_MAX))\n\t\t\t\treturn -EINVAL;\n\t\t\text_capa_mask = (u8 *)tlv->val;\n\t\t\text_capa_mask_len = tlv_value_len;\n\t\t\tbreak;\n\t\tcase QTN_TLV_ID_WOWLAN_CAPAB:\n\t\t\tif (tlv_value_len < sizeof(*wowlan))\n\t\t\t\treturn -EINVAL;\n\n\t\t\twowlan = (void *)tlv->val;\n\t\t\tif (!le16_to_cpu(wowlan->len)) {\n\t\t\t\tpr_warn(\"MAC%u: skip empty WoWLAN data\\n\",\n\t\t\t\t\tmac->macid);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trec_len = sizeof(*wowlan) + le16_to_cpu(wowlan->len);\n\t\t\tif (unlikely(tlv_value_len != rec_len)) {\n\t\t\t\tpr_warn(\"MAC%u: WoWLAN data size mismatch\\n\",\n\t\t\t\t\tmac->macid);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tkfree(mac->macinfo.wowlan);\n\t\t\tmac->macinfo.wowlan = NULL;\n\t\t\tqtnf_parse_wowlan_info(mac, wowlan);\n\t\t\tbreak;\n\t\tcase QTN_TLV_ID_REG_RULE:\n\t\t\tif (rule_idx >= resp->n_reg_rules) {\n\t\t\t\tpr_warn(\"unexpected number of rules: %u\\n\",\n\t\t\t\t\tresp->n_reg_rules);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (tlv_value_len != sizeof(*tlv_rule) - sizeof(*tlv)) {\n\t\t\t\tpr_warn(\"malformed TLV 0x%.2X; LEN: %u\\n\",\n\t\t\t\t\ttlv_type, tlv_value_len);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\ttlv_rule = (const struct qlink_tlv_reg_rule *)tlv;\n\t\t\trule = &mac->rd->reg_rules[rule_idx++];\n\t\t\tqlink_utils_regrule_q2nl(rule, tlv_rule);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"MAC%u: unknown TLV type %u\\n\",\n\t\t\t\tmac->macid, tlv_type);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!qlink_tlv_parsing_ok(tlv, resp->var_info, tlv_buf_size)) {\n\t\tpr_err(\"Malformed TLV buffer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (mac->macinfo.n_if_comb != n_comb) {\n\t\tpr_err(\"MAC%u: combination mismatch: reported=%zu parsed=%zu\\n\",\n\t\t       mac->macid, mac->macinfo.n_if_comb, n_comb);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ext_capa_len != ext_capa_mask_len) {\n\t\tpr_err(\"MAC%u: ext_capa/_mask lengths mismatch: %u != %u\\n\",\n\t\t       mac->macid, ext_capa_len, ext_capa_mask_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (rule_idx != resp->n_reg_rules) {\n\t\tpr_warn(\"unexpected number of rules: expected %u got %u\\n\",\n\t\t\tresp->n_reg_rules, rule_idx);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ext_capa_len > 0) {\n\t\text_capa = kmemdup(ext_capa, ext_capa_len, GFP_KERNEL);\n\t\tif (!ext_capa)\n\t\t\treturn -ENOMEM;\n\n\t\text_capa_mask =\n\t\t\tkmemdup(ext_capa_mask, ext_capa_mask_len, GFP_KERNEL);\n\t\tif (!ext_capa_mask) {\n\t\t\tkfree(ext_capa);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\text_capa = NULL;\n\t\text_capa_mask = NULL;\n\t}\n\n\tqtnf_mac_ext_caps_free(mac);\n\tmac->macinfo.extended_capabilities = ext_capa;\n\tmac->macinfo.extended_capabilities_mask = ext_capa_mask;\n\tmac->macinfo.extended_capabilities_len = ext_capa_len;\n\n\treturn 0;\n}\n\nstatic int\nqtnf_cmd_resp_proc_mac_info(struct qtnf_wmac *mac,\n\t\t\t    const struct qlink_resp_get_mac_info *resp_info)\n{\n\tstruct qtnf_mac_info *mac_info;\n\tstruct qtnf_vif *vif;\n\n\tqtnf_mac_iface_comb_free(mac);\n\n\tmac_info = &mac->macinfo;\n\n\tmac_info->bands_cap = resp_info->bands_cap;\n\tether_addr_copy(mac->macaddr, resp_info->dev_mac);\n\n\tvif = qtnf_mac_get_base_vif(mac);\n\tif (vif)\n\t\tether_addr_copy(vif->mac_addr, mac->macaddr);\n\telse\n\t\tpr_err(\"could not get valid base vif\\n\");\n\n\tmac_info->num_tx_chain = resp_info->num_tx_chain;\n\tmac_info->num_rx_chain = resp_info->num_rx_chain;\n\n\tmac_info->max_ap_assoc_sta = le16_to_cpu(resp_info->max_ap_assoc_sta);\n\tmac_info->radar_detect_widths =\n\t\t\tqlink_chan_width_mask_to_nl(le16_to_cpu(\n\t\t\t\t\tresp_info->radar_detect_widths));\n\tmac_info->max_acl_mac_addrs = le16_to_cpu(resp_info->max_acl_mac_addrs);\n\tmac_info->frag_thr = le32_to_cpu(resp_info->frag_threshold);\n\tmac_info->rts_thr = le32_to_cpu(resp_info->rts_threshold);\n\tmac_info->sretry_limit = resp_info->retry_short;\n\tmac_info->lretry_limit = resp_info->retry_long;\n\tmac_info->coverage_class = resp_info->coverage_class;\n\tmac_info->max_scan_ssids = resp_info->max_scan_ssids;\n\n\tmemcpy(&mac_info->ht_cap_mod_mask, &resp_info->ht_cap_mod_mask,\n\t       sizeof(mac_info->ht_cap_mod_mask));\n\tmemcpy(&mac_info->vht_cap_mod_mask, &resp_info->vht_cap_mod_mask,\n\t       sizeof(mac_info->vht_cap_mod_mask));\n\n\tmac_info->n_if_comb = resp_info->n_iface_combinations;\n\tmac_info->if_comb = kcalloc(mac->macinfo.n_if_comb,\n\t\t\t\t    sizeof(*mac->macinfo.if_comb),\n\t\t\t\t    GFP_KERNEL);\n\n\tif (!mac->macinfo.if_comb)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void qtnf_cmd_resp_band_fill_htcap(const u8 *info,\n\t\t\t\t\t  struct ieee80211_sta_ht_cap *bcap)\n{\n\tconst struct ieee80211_ht_cap *ht_cap =\n\t\t(const struct ieee80211_ht_cap *)info;\n\n\tbcap->ht_supported = true;\n\tbcap->cap = le16_to_cpu(ht_cap->cap_info);\n\tbcap->ampdu_factor =\n\t\tht_cap->ampdu_params_info & IEEE80211_HT_AMPDU_PARM_FACTOR;\n\tbcap->ampdu_density =\n\t\t(ht_cap->ampdu_params_info & IEEE80211_HT_AMPDU_PARM_DENSITY) >>\n\t\tIEEE80211_HT_AMPDU_PARM_DENSITY_SHIFT;\n\tmemcpy(&bcap->mcs, &ht_cap->mcs, sizeof(bcap->mcs));\n}\n\nstatic void qtnf_cmd_resp_band_fill_vhtcap(const u8 *info,\n\t\t\t\t\t   struct ieee80211_sta_vht_cap *bcap)\n{\n\tconst struct ieee80211_vht_cap *vht_cap =\n\t\t(const struct ieee80211_vht_cap *)info;\n\n\tbcap->vht_supported = true;\n\tbcap->cap = le32_to_cpu(vht_cap->vht_cap_info);\n\tmemcpy(&bcap->vht_mcs, &vht_cap->supp_mcs, sizeof(bcap->vht_mcs));\n}\n\nstatic void qtnf_cmd_conv_iftype(struct ieee80211_sband_iftype_data\n\t\t\t\t  *iftype_data,\n\t\t\t\t  const struct qlink_sband_iftype_data\n\t\t\t\t  *qlink_data)\n{\n\tiftype_data->types_mask = le16_to_cpu(qlink_data->types_mask);\n\n\tiftype_data->he_cap.has_he = true;\n\tmemcpy(&iftype_data->he_cap.he_cap_elem, &qlink_data->he_cap_elem,\n\t       sizeof(qlink_data->he_cap_elem));\n\tmemcpy(iftype_data->he_cap.ppe_thres, qlink_data->ppe_thres,\n\t       ARRAY_SIZE(qlink_data->ppe_thres));\n\n\tiftype_data->he_cap.he_mcs_nss_supp.rx_mcs_80 =\n\t\tqlink_data->he_mcs_nss_supp.rx_mcs_80;\n\tiftype_data->he_cap.he_mcs_nss_supp.tx_mcs_80 =\n\t\tqlink_data->he_mcs_nss_supp.tx_mcs_80;\n\tiftype_data->he_cap.he_mcs_nss_supp.rx_mcs_160 =\n\t\tqlink_data->he_mcs_nss_supp.rx_mcs_160;\n\tiftype_data->he_cap.he_mcs_nss_supp.tx_mcs_160 =\n\t\tqlink_data->he_mcs_nss_supp.tx_mcs_160;\n\tiftype_data->he_cap.he_mcs_nss_supp.rx_mcs_80p80 =\n\t\tqlink_data->he_mcs_nss_supp.rx_mcs_80p80;\n\tiftype_data->he_cap.he_mcs_nss_supp.tx_mcs_80p80 =\n\t\tqlink_data->he_mcs_nss_supp.tx_mcs_80p80;\n}\n\nstatic int qtnf_cmd_band_fill_iftype(const u8 *data,\n\t\t\t\t     struct ieee80211_supported_band *band)\n{\n\tunsigned int i;\n\tstruct ieee80211_sband_iftype_data *iftype_data;\n\tconst struct qlink_tlv_iftype_data *tlv =\n\t\t(const struct qlink_tlv_iftype_data *)data;\n\tsize_t payload_len;\n\n\tpayload_len = struct_size(tlv, iftype_data, tlv->n_iftype_data);\n\tpayload_len = size_sub(payload_len, sizeof(struct qlink_tlv_hdr));\n\n\tif (tlv->hdr.len != cpu_to_le16(payload_len)) {\n\t\tpr_err(\"bad IFTYPE_DATA TLV len %u\\n\", tlv->hdr.len);\n\t\treturn -EINVAL;\n\t}\n\n\tkfree(band->iftype_data);\n\tband->iftype_data = NULL;\n\tband->n_iftype_data = tlv->n_iftype_data;\n\tif (band->n_iftype_data == 0)\n\t\treturn 0;\n\n\tiftype_data = kcalloc(band->n_iftype_data, sizeof(*iftype_data),\n\t\t\t      GFP_KERNEL);\n\tif (!iftype_data) {\n\t\tband->n_iftype_data = 0;\n\t\treturn -ENOMEM;\n\t}\n\tband->iftype_data = iftype_data;\n\n\tfor (i = 0; i < band->n_iftype_data; i++)\n\t\tqtnf_cmd_conv_iftype(iftype_data++, &tlv->iftype_data[i]);\n\n\treturn 0;\n}\n\nstatic int\nqtnf_cmd_resp_fill_band_info(struct ieee80211_supported_band *band,\n\t\t\t     struct qlink_resp_band_info_get *resp,\n\t\t\t     size_t payload_len)\n{\n\tu16 tlv_type;\n\tsize_t tlv_dlen;\n\tconst struct qlink_tlv_hdr *tlv;\n\tconst struct qlink_channel *qchan;\n\tstruct ieee80211_channel *chan;\n\tunsigned int chidx = 0;\n\tu32 qflags;\n\tint ret = -EINVAL;\n\n\tmemset(&band->ht_cap, 0, sizeof(band->ht_cap));\n\tmemset(&band->vht_cap, 0, sizeof(band->vht_cap));\n\n\tif (band->channels) {\n\t\tif (band->n_channels == resp->num_chans) {\n\t\t\tmemset(band->channels, 0,\n\t\t\t       sizeof(*band->channels) * band->n_channels);\n\t\t} else {\n\t\t\tkfree(band->channels);\n\t\t\tband->n_channels = 0;\n\t\t\tband->channels = NULL;\n\t\t}\n\t}\n\n\tband->n_channels = resp->num_chans;\n\tif (band->n_channels == 0)\n\t\treturn 0;\n\n\tif (!band->channels)\n\t\tband->channels = kcalloc(band->n_channels, sizeof(*chan),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!band->channels) {\n\t\tband->n_channels = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tqlink_for_each_tlv(tlv, resp->info, payload_len) {\n\t\ttlv_type = le16_to_cpu(tlv->type);\n\t\ttlv_dlen = le16_to_cpu(tlv->len);\n\n\t\tswitch (tlv_type) {\n\t\tcase QTN_TLV_ID_CHANNEL:\n\t\t\tif (unlikely(tlv_dlen != sizeof(*qchan))) {\n\t\t\t\tpr_err(\"invalid channel TLV len %zu\\n\",\n\t\t\t\t       tlv_dlen);\n\t\t\t\tgoto error_ret;\n\t\t\t}\n\n\t\t\tif (chidx == band->n_channels) {\n\t\t\t\tpr_err(\"too many channel TLVs\\n\");\n\t\t\t\tgoto error_ret;\n\t\t\t}\n\n\t\t\tqchan = (const struct qlink_channel *)tlv->val;\n\t\t\tchan = &band->channels[chidx++];\n\t\t\tqflags = le32_to_cpu(qchan->flags);\n\n\t\t\tchan->hw_value = le16_to_cpu(qchan->hw_value);\n\t\t\tchan->band = band->band;\n\t\t\tchan->center_freq = le16_to_cpu(qchan->center_freq);\n\t\t\tchan->max_antenna_gain = (int)qchan->max_antenna_gain;\n\t\t\tchan->max_power = (int)qchan->max_power;\n\t\t\tchan->max_reg_power = (int)qchan->max_reg_power;\n\t\t\tchan->beacon_found = qchan->beacon_found;\n\t\t\tchan->dfs_cac_ms = le32_to_cpu(qchan->dfs_cac_ms);\n\t\t\tchan->flags = 0;\n\n\t\t\tif (qflags & QLINK_CHAN_DISABLED)\n\t\t\t\tchan->flags |= IEEE80211_CHAN_DISABLED;\n\n\t\t\tif (qflags & QLINK_CHAN_NO_IR)\n\t\t\t\tchan->flags |= IEEE80211_CHAN_NO_IR;\n\n\t\t\tif (qflags & QLINK_CHAN_NO_HT40PLUS)\n\t\t\t\tchan->flags |= IEEE80211_CHAN_NO_HT40PLUS;\n\n\t\t\tif (qflags & QLINK_CHAN_NO_HT40MINUS)\n\t\t\t\tchan->flags |= IEEE80211_CHAN_NO_HT40MINUS;\n\n\t\t\tif (qflags & QLINK_CHAN_NO_OFDM)\n\t\t\t\tchan->flags |= IEEE80211_CHAN_NO_OFDM;\n\n\t\t\tif (qflags & QLINK_CHAN_NO_80MHZ)\n\t\t\t\tchan->flags |= IEEE80211_CHAN_NO_80MHZ;\n\n\t\t\tif (qflags & QLINK_CHAN_NO_160MHZ)\n\t\t\t\tchan->flags |= IEEE80211_CHAN_NO_160MHZ;\n\n\t\t\tif (qflags & QLINK_CHAN_INDOOR_ONLY)\n\t\t\t\tchan->flags |= IEEE80211_CHAN_INDOOR_ONLY;\n\n\t\t\tif (qflags & QLINK_CHAN_IR_CONCURRENT)\n\t\t\t\tchan->flags |= IEEE80211_CHAN_IR_CONCURRENT;\n\n\t\t\tif (qflags & QLINK_CHAN_NO_20MHZ)\n\t\t\t\tchan->flags |= IEEE80211_CHAN_NO_20MHZ;\n\n\t\t\tif (qflags & QLINK_CHAN_NO_10MHZ)\n\t\t\t\tchan->flags |= IEEE80211_CHAN_NO_10MHZ;\n\n\t\t\tif (qflags & QLINK_CHAN_RADAR) {\n\t\t\t\tchan->flags |= IEEE80211_CHAN_RADAR;\n\t\t\t\tchan->dfs_state_entered = jiffies;\n\n\t\t\t\tif (qchan->dfs_state == QLINK_DFS_USABLE)\n\t\t\t\t\tchan->dfs_state = NL80211_DFS_USABLE;\n\t\t\t\telse if (qchan->dfs_state ==\n\t\t\t\t\tQLINK_DFS_AVAILABLE)\n\t\t\t\t\tchan->dfs_state = NL80211_DFS_AVAILABLE;\n\t\t\t\telse\n\t\t\t\t\tchan->dfs_state =\n\t\t\t\t\t\tNL80211_DFS_UNAVAILABLE;\n\t\t\t}\n\n\t\t\tpr_debug(\"chan=%d flags=%#x max_pow=%d max_reg_pow=%d\\n\",\n\t\t\t\t chan->hw_value, chan->flags, chan->max_power,\n\t\t\t\t chan->max_reg_power);\n\t\t\tbreak;\n\t\tcase WLAN_EID_HT_CAPABILITY:\n\t\t\tif (unlikely(tlv_dlen !=\n\t\t\t\t     sizeof(struct ieee80211_ht_cap))) {\n\t\t\t\tpr_err(\"bad HTCAP TLV len %zu\\n\", tlv_dlen);\n\t\t\t\tgoto error_ret;\n\t\t\t}\n\n\t\t\tqtnf_cmd_resp_band_fill_htcap(tlv->val, &band->ht_cap);\n\t\t\tbreak;\n\t\tcase WLAN_EID_VHT_CAPABILITY:\n\t\t\tif (unlikely(tlv_dlen !=\n\t\t\t\t     sizeof(struct ieee80211_vht_cap))) {\n\t\t\t\tpr_err(\"bad VHTCAP TLV len %zu\\n\", tlv_dlen);\n\t\t\t\tgoto error_ret;\n\t\t\t}\n\n\t\t\tqtnf_cmd_resp_band_fill_vhtcap(tlv->val,\n\t\t\t\t\t\t       &band->vht_cap);\n\t\t\tbreak;\n\t\tcase QTN_TLV_ID_IFTYPE_DATA:\n\t\t\tret = qtnf_cmd_band_fill_iftype((const uint8_t *)tlv,\n\t\t\t\t\t\t\tband);\n\t\t\tif (ret)\n\t\t\t\tgoto error_ret;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"unknown TLV type: %#x\\n\", tlv_type);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!qlink_tlv_parsing_ok(tlv, resp->info, payload_len)) {\n\t\tpr_err(\"Malformed TLV buffer\\n\");\n\t\tgoto error_ret;\n\t}\n\n\tif (band->n_channels != chidx) {\n\t\tpr_err(\"channel count mismatch: reported=%d, parsed=%d\\n\",\n\t\t       band->n_channels, chidx);\n\t\tgoto error_ret;\n\t}\n\n\treturn 0;\n\nerror_ret:\n\tkfree(band->channels);\n\tband->channels = NULL;\n\tband->n_channels = 0;\n\n\treturn ret;\n}\n\nint qtnf_cmd_get_mac_info(struct qtnf_wmac *mac)\n{\n\tstruct sk_buff *cmd_skb, *resp_skb = NULL;\n\tconst struct qlink_resp_get_mac_info *resp;\n\tsize_t var_data_len = 0;\n\tint ret = 0;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(mac->macid, QLINK_VIFID_RSVD,\n\t\t\t\t\t    QLINK_CMD_MAC_INFO,\n\t\t\t\t\t    sizeof(struct qlink_cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tqtnf_bus_lock(mac->bus);\n\tret = qtnf_cmd_send_with_reply(mac->bus, cmd_skb, &resp_skb,\n\t\t\t\t       sizeof(*resp), &var_data_len);\n\tif (ret)\n\t\tgoto out;\n\n\tresp = (const struct qlink_resp_get_mac_info *)resp_skb->data;\n\tret = qtnf_cmd_resp_proc_mac_info(mac, resp);\n\tif (ret)\n\t\tgoto out;\n\n\tret = qtnf_parse_variable_mac_info(mac, resp, var_data_len);\n\nout:\n\tqtnf_bus_unlock(mac->bus);\n\tconsume_skb(resp_skb);\n\n\treturn ret;\n}\n\nint qtnf_cmd_get_hw_info(struct qtnf_bus *bus)\n{\n\tstruct sk_buff *cmd_skb, *resp_skb = NULL;\n\tconst struct qlink_resp_get_hw_info *resp;\n\tsize_t info_len = 0;\n\tint ret = 0;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(QLINK_MACID_RSVD, QLINK_VIFID_RSVD,\n\t\t\t\t\t    QLINK_CMD_GET_HW_INFO,\n\t\t\t\t\t    sizeof(struct qlink_cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tqtnf_bus_lock(bus);\n\tret = qtnf_cmd_send_with_reply(bus, cmd_skb, &resp_skb,\n\t\t\t\t       sizeof(*resp), &info_len);\n\tif (ret)\n\t\tgoto out;\n\n\tresp = (const struct qlink_resp_get_hw_info *)resp_skb->data;\n\tret = qtnf_cmd_resp_proc_hw_info(bus, resp, info_len);\n\nout:\n\tqtnf_bus_unlock(bus);\n\tconsume_skb(resp_skb);\n\n\treturn ret;\n}\n\nint qtnf_cmd_band_info_get(struct qtnf_wmac *mac,\n\t\t\t   struct ieee80211_supported_band *band)\n{\n\tstruct sk_buff *cmd_skb, *resp_skb = NULL;\n\tstruct qlink_cmd_band_info_get *cmd;\n\tstruct qlink_resp_band_info_get *resp;\n\tsize_t info_len = 0;\n\tint ret = 0;\n\tu8 qband = qlink_utils_band_cfg2q(band->band);\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(mac->macid, 0,\n\t\t\t\t\t    QLINK_CMD_BAND_INFO_GET,\n\t\t\t\t\t    sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct qlink_cmd_band_info_get *)cmd_skb->data;\n\tcmd->band = qband;\n\n\tqtnf_bus_lock(mac->bus);\n\tret = qtnf_cmd_send_with_reply(mac->bus, cmd_skb, &resp_skb,\n\t\t\t\t       sizeof(*resp), &info_len);\n\tif (ret)\n\t\tgoto out;\n\n\tresp = (struct qlink_resp_band_info_get *)resp_skb->data;\n\tif (resp->band != qband) {\n\t\tpr_err(\"MAC%u: reply band %u != cmd band %u\\n\", mac->macid,\n\t\t       resp->band, qband);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = qtnf_cmd_resp_fill_band_info(band, resp, info_len);\n\nout:\n\tqtnf_bus_unlock(mac->bus);\n\tconsume_skb(resp_skb);\n\n\treturn ret;\n}\n\nint qtnf_cmd_send_update_phy_params(struct qtnf_wmac *mac, u32 changed)\n{\n\tstruct wiphy *wiphy = priv_to_wiphy(mac);\n\tstruct sk_buff *cmd_skb;\n\tint ret = 0;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(mac->macid, 0,\n\t\t\t\t\t    QLINK_CMD_PHY_PARAMS_SET,\n\t\t\t\t\t    sizeof(struct qlink_cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tqtnf_bus_lock(mac->bus);\n\n\tif (changed & WIPHY_PARAM_FRAG_THRESHOLD)\n\t\tqtnf_cmd_skb_put_tlv_u32(cmd_skb, QTN_TLV_ID_FRAG_THRESH,\n\t\t\t\t\t wiphy->frag_threshold);\n\tif (changed & WIPHY_PARAM_RTS_THRESHOLD)\n\t\tqtnf_cmd_skb_put_tlv_u32(cmd_skb, QTN_TLV_ID_RTS_THRESH,\n\t\t\t\t\t wiphy->rts_threshold);\n\tif (changed & WIPHY_PARAM_COVERAGE_CLASS)\n\t\tqtnf_cmd_skb_put_tlv_u32(cmd_skb, QTN_TLV_ID_COVERAGE_CLASS,\n\t\t\t\t\t wiphy->coverage_class);\n\n\tif (changed & WIPHY_PARAM_RETRY_LONG)\n\t\tqtnf_cmd_skb_put_tlv_u32(cmd_skb, QTN_TLV_ID_LRETRY_LIMIT,\n\t\t\t\t\t wiphy->retry_long);\n\n\tif (changed & WIPHY_PARAM_RETRY_SHORT)\n\t\tqtnf_cmd_skb_put_tlv_u32(cmd_skb, QTN_TLV_ID_SRETRY_LIMIT,\n\t\t\t\t\t wiphy->retry_short);\n\n\tret = qtnf_cmd_send(mac->bus, cmd_skb);\n\n\tqtnf_bus_unlock(mac->bus);\n\n\treturn ret;\n}\n\nint qtnf_cmd_send_init_fw(struct qtnf_bus *bus)\n{\n\tstruct sk_buff *resp_skb = NULL;\n\tstruct qlink_resp_init_fw *resp;\n\tstruct qlink_cmd_init_fw *cmd;\n\tstruct sk_buff *cmd_skb;\n\tsize_t info_len = 0;\n\tint ret;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(QLINK_MACID_RSVD, QLINK_VIFID_RSVD,\n\t\t\t\t\t    QLINK_CMD_FW_INIT,\n\t\t\t\t\t    sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct qlink_cmd_init_fw *)cmd_skb->data;\n\tcmd->qlink_proto_ver = cpu_to_le32(QLINK_PROTO_VER);\n\n\tqtnf_bus_lock(bus);\n\tret = qtnf_cmd_send_with_reply(bus, cmd_skb, &resp_skb,\n\t\t\t\t       sizeof(*resp), &info_len);\n\tqtnf_bus_unlock(bus);\n\n\tif (ret)\n\t\tgoto out;\n\n\tresp = (struct qlink_resp_init_fw *)resp_skb->data;\n\tbus->hw_info.ql_proto_ver = le32_to_cpu(resp->qlink_proto_ver);\n\nout:\n\tconsume_skb(resp_skb);\n\treturn ret;\n}\n\nvoid qtnf_cmd_send_deinit_fw(struct qtnf_bus *bus)\n{\n\tstruct sk_buff *cmd_skb;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(QLINK_MACID_RSVD, QLINK_VIFID_RSVD,\n\t\t\t\t\t    QLINK_CMD_FW_DEINIT,\n\t\t\t\t\t    sizeof(struct qlink_cmd));\n\tif (!cmd_skb)\n\t\treturn;\n\n\tqtnf_bus_lock(bus);\n\tqtnf_cmd_send(bus, cmd_skb);\n\tqtnf_bus_unlock(bus);\n}\n\nint qtnf_cmd_send_add_key(struct qtnf_vif *vif, u8 key_index, bool pairwise,\n\t\t\t  const u8 *mac_addr, struct key_params *params)\n{\n\tstruct sk_buff *cmd_skb;\n\tstruct qlink_cmd_add_key *cmd;\n\tint ret = 0;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_ADD_KEY,\n\t\t\t\t\t    sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tqtnf_bus_lock(vif->mac->bus);\n\n\tcmd = (struct qlink_cmd_add_key *)cmd_skb->data;\n\n\tif (mac_addr)\n\t\tether_addr_copy(cmd->addr, mac_addr);\n\telse\n\t\teth_broadcast_addr(cmd->addr);\n\n\tcmd->cipher = cpu_to_le32(params->cipher);\n\tcmd->key_index = key_index;\n\tcmd->pairwise = pairwise;\n\n\tif (params->key && params->key_len > 0)\n\t\tqtnf_cmd_skb_put_tlv_arr(cmd_skb, QTN_TLV_ID_KEY,\n\t\t\t\t\t params->key,\n\t\t\t\t\t params->key_len);\n\n\tif (params->seq && params->seq_len > 0)\n\t\tqtnf_cmd_skb_put_tlv_arr(cmd_skb, QTN_TLV_ID_SEQ,\n\t\t\t\t\t params->seq,\n\t\t\t\t\t params->seq_len);\n\n\tret = qtnf_cmd_send(vif->mac->bus, cmd_skb);\n\n\tqtnf_bus_unlock(vif->mac->bus);\n\n\treturn ret;\n}\n\nint qtnf_cmd_send_del_key(struct qtnf_vif *vif, u8 key_index, bool pairwise,\n\t\t\t  const u8 *mac_addr)\n{\n\tstruct sk_buff *cmd_skb;\n\tstruct qlink_cmd_del_key *cmd;\n\tint ret = 0;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_DEL_KEY,\n\t\t\t\t\t    sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tqtnf_bus_lock(vif->mac->bus);\n\n\tcmd = (struct qlink_cmd_del_key *)cmd_skb->data;\n\n\tif (mac_addr)\n\t\tether_addr_copy(cmd->addr, mac_addr);\n\telse\n\t\teth_broadcast_addr(cmd->addr);\n\n\tcmd->key_index = key_index;\n\tcmd->pairwise = pairwise;\n\n\tret = qtnf_cmd_send(vif->mac->bus, cmd_skb);\n\n\tqtnf_bus_unlock(vif->mac->bus);\n\n\treturn ret;\n}\n\nint qtnf_cmd_send_set_default_key(struct qtnf_vif *vif, u8 key_index,\n\t\t\t\t  bool unicast, bool multicast)\n{\n\tstruct sk_buff *cmd_skb;\n\tstruct qlink_cmd_set_def_key *cmd;\n\tint ret = 0;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_SET_DEFAULT_KEY,\n\t\t\t\t\t    sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tqtnf_bus_lock(vif->mac->bus);\n\n\tcmd = (struct qlink_cmd_set_def_key *)cmd_skb->data;\n\tcmd->key_index = key_index;\n\tcmd->unicast = unicast;\n\tcmd->multicast = multicast;\n\n\tret = qtnf_cmd_send(vif->mac->bus, cmd_skb);\n\n\tqtnf_bus_unlock(vif->mac->bus);\n\n\treturn ret;\n}\n\nint qtnf_cmd_send_set_default_mgmt_key(struct qtnf_vif *vif, u8 key_index)\n{\n\tstruct sk_buff *cmd_skb;\n\tstruct qlink_cmd_set_def_mgmt_key *cmd;\n\tint ret = 0;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_SET_DEFAULT_MGMT_KEY,\n\t\t\t\t\t    sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tqtnf_bus_lock(vif->mac->bus);\n\n\tcmd = (struct qlink_cmd_set_def_mgmt_key *)cmd_skb->data;\n\tcmd->key_index = key_index;\n\n\tret = qtnf_cmd_send(vif->mac->bus, cmd_skb);\n\n\tqtnf_bus_unlock(vif->mac->bus);\n\n\treturn ret;\n}\n\nstatic u32 qtnf_encode_sta_flags(u32 flags)\n{\n\tu32 code = 0;\n\n\tif (flags & BIT(NL80211_STA_FLAG_AUTHORIZED))\n\t\tcode |= QLINK_STA_FLAG_AUTHORIZED;\n\tif (flags & BIT(NL80211_STA_FLAG_SHORT_PREAMBLE))\n\t\tcode |= QLINK_STA_FLAG_SHORT_PREAMBLE;\n\tif (flags & BIT(NL80211_STA_FLAG_WME))\n\t\tcode |= QLINK_STA_FLAG_WME;\n\tif (flags & BIT(NL80211_STA_FLAG_MFP))\n\t\tcode |= QLINK_STA_FLAG_MFP;\n\tif (flags & BIT(NL80211_STA_FLAG_AUTHENTICATED))\n\t\tcode |= QLINK_STA_FLAG_AUTHENTICATED;\n\tif (flags & BIT(NL80211_STA_FLAG_TDLS_PEER))\n\t\tcode |= QLINK_STA_FLAG_TDLS_PEER;\n\tif (flags & BIT(NL80211_STA_FLAG_ASSOCIATED))\n\t\tcode |= QLINK_STA_FLAG_ASSOCIATED;\n\treturn code;\n}\n\nint qtnf_cmd_send_change_sta(struct qtnf_vif *vif, const u8 *mac,\n\t\t\t     struct station_parameters *params)\n{\n\tstruct sk_buff *cmd_skb;\n\tstruct qlink_cmd_change_sta *cmd;\n\tint ret = 0;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_CHANGE_STA,\n\t\t\t\t\t    sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tqtnf_bus_lock(vif->mac->bus);\n\n\tcmd = (struct qlink_cmd_change_sta *)cmd_skb->data;\n\tether_addr_copy(cmd->sta_addr, mac);\n\tcmd->flag_update.mask =\n\t\tcpu_to_le32(qtnf_encode_sta_flags(params->sta_flags_mask));\n\tcmd->flag_update.value =\n\t\tcpu_to_le32(qtnf_encode_sta_flags(params->sta_flags_set));\n\n\tswitch (vif->wdev.iftype) {\n\tcase NL80211_IFTYPE_AP:\n\t\tcmd->if_type = cpu_to_le16(QLINK_IFTYPE_AP);\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tcmd->if_type = cpu_to_le16(QLINK_IFTYPE_STATION);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unsupported iftype %d\\n\", vif->wdev.iftype);\n\t\tdev_kfree_skb(cmd_skb);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = qtnf_cmd_send(vif->mac->bus, cmd_skb);\n\nout:\n\tqtnf_bus_unlock(vif->mac->bus);\n\n\treturn ret;\n}\n\nint qtnf_cmd_send_del_sta(struct qtnf_vif *vif,\n\t\t\t  struct station_del_parameters *params)\n{\n\tstruct sk_buff *cmd_skb;\n\tstruct qlink_cmd_del_sta *cmd;\n\tint ret = 0;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_DEL_STA,\n\t\t\t\t\t    sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tqtnf_bus_lock(vif->mac->bus);\n\n\tcmd = (struct qlink_cmd_del_sta *)cmd_skb->data;\n\n\tif (params->mac)\n\t\tether_addr_copy(cmd->sta_addr, params->mac);\n\telse\n\t\teth_broadcast_addr(cmd->sta_addr);\t \n\n\tcmd->subtype = params->subtype;\n\tcmd->reason_code = cpu_to_le16(params->reason_code);\n\n\tret = qtnf_cmd_send(vif->mac->bus, cmd_skb);\n\n\tqtnf_bus_unlock(vif->mac->bus);\n\n\treturn ret;\n}\n\nstatic void qtnf_cmd_channel_tlv_add(struct sk_buff *cmd_skb,\n\t\t\t\t     const struct ieee80211_channel *sc)\n{\n\tstruct qlink_tlv_channel *tlv;\n\tstruct qlink_channel *qch;\n\n\ttlv = skb_put_zero(cmd_skb, sizeof(*tlv));\n\tqch = &tlv->chan;\n\ttlv->hdr.type = cpu_to_le16(QTN_TLV_ID_CHANNEL);\n\ttlv->hdr.len = cpu_to_le16(sizeof(*qch));\n\n\tqch->center_freq = cpu_to_le16(sc->center_freq);\n\tqch->hw_value = cpu_to_le16(sc->hw_value);\n\tqch->band = qlink_utils_band_cfg2q(sc->band);\n\tqch->max_power = sc->max_power;\n\tqch->max_reg_power = sc->max_reg_power;\n\tqch->max_antenna_gain = sc->max_antenna_gain;\n\tqch->beacon_found = sc->beacon_found;\n\tqch->dfs_state = qlink_utils_dfs_state_cfg2q(sc->dfs_state);\n\tqch->flags = cpu_to_le32(qlink_utils_chflags_cfg2q(sc->flags));\n}\n\nstatic void qtnf_cmd_randmac_tlv_add(struct sk_buff *cmd_skb,\n\t\t\t\t     const u8 *mac_addr,\n\t\t\t\t     const u8 *mac_addr_mask)\n{\n\tstruct qlink_random_mac_addr *randmac;\n\tstruct qlink_tlv_hdr *hdr =\n\t\tskb_put(cmd_skb, sizeof(*hdr) + sizeof(*randmac));\n\n\thdr->type = cpu_to_le16(QTN_TLV_ID_RANDOM_MAC_ADDR);\n\thdr->len = cpu_to_le16(sizeof(*randmac));\n\trandmac = (struct qlink_random_mac_addr *)hdr->val;\n\n\tmemcpy(randmac->mac_addr, mac_addr, ETH_ALEN);\n\tmemcpy(randmac->mac_addr_mask, mac_addr_mask, ETH_ALEN);\n}\n\nint qtnf_cmd_send_scan(struct qtnf_wmac *mac)\n{\n\tstruct cfg80211_scan_request *scan_req = mac->scan_req;\n\tu16 dwell_passive = QTNF_SCAN_DWELL_PASSIVE_DEFAULT;\n\tu16 dwell_active = QTNF_SCAN_DWELL_ACTIVE_DEFAULT;\n\tstruct wireless_dev *wdev = scan_req->wdev;\n\tstruct ieee80211_channel *sc;\n\tstruct qlink_cmd_scan *cmd;\n\tstruct sk_buff *cmd_skb;\n\tint n_channels = 0;\n\tu64 flags = 0;\n\tint count;\n\tint ret;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(mac->macid, QLINK_VIFID_RSVD,\n\t\t\t\t\t    QLINK_CMD_SCAN,\n\t\t\t\t\t    sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct qlink_cmd_scan *)cmd_skb->data;\n\n\tif (scan_req->duration) {\n\t\tdwell_active = scan_req->duration;\n\t\tdwell_passive = scan_req->duration;\n\t} else if (wdev->iftype == NL80211_IFTYPE_STATION &&\n\t\t   wdev->connected) {\n\t\t \n\t\tdwell_active = QTNF_SCAN_TIME_AUTO;\n\t\tdwell_passive = QTNF_SCAN_TIME_AUTO;\n\t}\n\n\tcmd->n_ssids = cpu_to_le16(scan_req->n_ssids);\n\tfor (count = 0; count < scan_req->n_ssids; ++count) {\n\t\tqtnf_cmd_skb_put_tlv_arr(cmd_skb, WLAN_EID_SSID,\n\t\t\t\t\t scan_req->ssids[count].ssid,\n\t\t\t\t\t scan_req->ssids[count].ssid_len);\n\t}\n\n\tif (scan_req->ie_len != 0)\n\t\tqtnf_cmd_tlv_ie_set_add(cmd_skb, QLINK_IE_SET_PROBE_REQ,\n\t\t\t\t\tscan_req->ie, scan_req->ie_len);\n\n\tfor (count = 0; count < scan_req->n_channels; ++count) {\n\t\tsc = scan_req->channels[count];\n\t\tif (sc->flags & IEEE80211_CHAN_DISABLED)\n\t\t\tcontinue;\n\n\t\tpr_debug(\"[MAC%u] scan chan=%d, freq=%d, flags=%#x\\n\",\n\t\t\t mac->macid, sc->hw_value, sc->center_freq,\n\t\t\t sc->flags);\n\n\t\tqtnf_cmd_channel_tlv_add(cmd_skb, sc);\n\t\t++n_channels;\n\t}\n\n\tif (scan_req->flags & NL80211_SCAN_FLAG_FLUSH)\n\t\tflags |= QLINK_SCAN_FLAG_FLUSH;\n\n\tif (scan_req->duration_mandatory)\n\t\tflags |= QLINK_SCAN_FLAG_DURATION_MANDATORY;\n\n\tcmd->n_channels = cpu_to_le16(n_channels);\n\tcmd->active_dwell = cpu_to_le16(dwell_active);\n\tcmd->passive_dwell = cpu_to_le16(dwell_passive);\n\tcmd->sample_duration = cpu_to_le16(QTNF_SCAN_SAMPLE_DURATION_DEFAULT);\n\tcmd->flags = cpu_to_le64(flags);\n\n\tpr_debug(\"[MAC%u] %s scan dwell active=%u passive=%u duration=%u\\n\",\n\t\t mac->macid,\n\t\t scan_req->duration_mandatory ? \"mandatory\" : \"max\",\n\t\t dwell_active, dwell_passive,\n\t\t QTNF_SCAN_SAMPLE_DURATION_DEFAULT);\n\n\tif (scan_req->flags & NL80211_SCAN_FLAG_RANDOM_ADDR) {\n\t\tpr_debug(\"[MAC%u] scan with random addr=%pM, mask=%pM\\n\",\n\t\t\t mac->macid,\n\t\t\t scan_req->mac_addr, scan_req->mac_addr_mask);\n\t\tqtnf_cmd_randmac_tlv_add(cmd_skb, scan_req->mac_addr,\n\t\t\t\t\t scan_req->mac_addr_mask);\n\t}\n\n\tqtnf_bus_lock(mac->bus);\n\tret = qtnf_cmd_send(mac->bus, cmd_skb);\n\tqtnf_bus_unlock(mac->bus);\n\n\treturn ret;\n}\n\nint qtnf_cmd_send_connect(struct qtnf_vif *vif,\n\t\t\t  struct cfg80211_connect_params *sme)\n{\n\tstruct sk_buff *cmd_skb;\n\tstruct qlink_cmd_connect *cmd;\n\tstruct qlink_auth_encr *aen;\n\tint ret;\n\tint i;\n\tint n;\n\tu32 connect_flags = 0;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_CONNECT,\n\t\t\t\t\t    sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct qlink_cmd_connect *)cmd_skb->data;\n\n\tether_addr_copy(cmd->bssid, vif->bssid);\n\n\tif (sme->bssid_hint)\n\t\tether_addr_copy(cmd->bssid_hint, sme->bssid_hint);\n\telse\n\t\teth_zero_addr(cmd->bssid_hint);\n\n\tif (sme->prev_bssid)\n\t\tether_addr_copy(cmd->prev_bssid, sme->prev_bssid);\n\telse\n\t\teth_zero_addr(cmd->prev_bssid);\n\n\tif ((sme->bg_scan_period >= 0) &&\n\t    (sme->bg_scan_period <= SHRT_MAX))\n\t\tcmd->bg_scan_period = cpu_to_le16(sme->bg_scan_period);\n\telse\n\t\tcmd->bg_scan_period = cpu_to_le16(-1);  \n\n\tif (sme->flags & ASSOC_REQ_DISABLE_HT)\n\t\tconnect_flags |= QLINK_STA_CONNECT_DISABLE_HT;\n\tif (sme->flags & ASSOC_REQ_DISABLE_VHT)\n\t\tconnect_flags |= QLINK_STA_CONNECT_DISABLE_VHT;\n\tif (sme->flags & ASSOC_REQ_USE_RRM)\n\t\tconnect_flags |= QLINK_STA_CONNECT_USE_RRM;\n\n\tcmd->flags = cpu_to_le32(connect_flags);\n\tmemcpy(&cmd->ht_capa, &sme->ht_capa, sizeof(cmd->ht_capa));\n\tmemcpy(&cmd->ht_capa_mask, &sme->ht_capa_mask,\n\t       sizeof(cmd->ht_capa_mask));\n\tmemcpy(&cmd->vht_capa, &sme->vht_capa, sizeof(cmd->vht_capa));\n\tmemcpy(&cmd->vht_capa_mask, &sme->vht_capa_mask,\n\t       sizeof(cmd->vht_capa_mask));\n\tcmd->pbss = sme->pbss;\n\n\taen = &cmd->aen;\n\taen->auth_type = sme->auth_type;\n\taen->privacy = !!sme->privacy;\n\tcmd->mfp = sme->mfp;\n\taen->wpa_versions = cpu_to_le32(sme->crypto.wpa_versions);\n\taen->cipher_group = cpu_to_le32(sme->crypto.cipher_group);\n\taen->n_ciphers_pairwise = cpu_to_le32(sme->crypto.n_ciphers_pairwise);\n\n\tfor (i = 0; i < QLINK_MAX_NR_CIPHER_SUITES; i++)\n\t\taen->ciphers_pairwise[i] =\n\t\t\tcpu_to_le32(sme->crypto.ciphers_pairwise[i]);\n\n\tn = min(QLINK_MAX_NR_AKM_SUITES, sme->crypto.n_akm_suites);\n\taen->n_akm_suites = cpu_to_le32(n);\n\n\tfor (i = 0; i < n; i++)\n\t\taen->akm_suites[i] = cpu_to_le32(sme->crypto.akm_suites[i]);\n\n\taen->control_port = sme->crypto.control_port;\n\taen->control_port_no_encrypt =\n\t\tsme->crypto.control_port_no_encrypt;\n\taen->control_port_ethertype =\n\t\tcpu_to_le16(be16_to_cpu(sme->crypto.control_port_ethertype));\n\n\tqtnf_cmd_skb_put_tlv_arr(cmd_skb, WLAN_EID_SSID, sme->ssid,\n\t\t\t\t sme->ssid_len);\n\n\tif (sme->ie_len != 0)\n\t\tqtnf_cmd_tlv_ie_set_add(cmd_skb, QLINK_IE_SET_ASSOC_REQ,\n\t\t\t\t\tsme->ie, sme->ie_len);\n\n\tif (sme->channel)\n\t\tqtnf_cmd_channel_tlv_add(cmd_skb, sme->channel);\n\n\tqtnf_bus_lock(vif->mac->bus);\n\tret = qtnf_cmd_send(vif->mac->bus, cmd_skb);\n\tqtnf_bus_unlock(vif->mac->bus);\n\n\treturn ret;\n}\n\nint qtnf_cmd_send_external_auth(struct qtnf_vif *vif,\n\t\t\t\tstruct cfg80211_external_auth_params *auth)\n{\n\tstruct sk_buff *cmd_skb;\n\tstruct qlink_cmd_external_auth *cmd;\n\tint ret;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_EXTERNAL_AUTH,\n\t\t\t\t\t    sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct qlink_cmd_external_auth *)cmd_skb->data;\n\n\tether_addr_copy(cmd->peer, auth->bssid);\n\tcmd->status = cpu_to_le16(auth->status);\n\n\tqtnf_bus_lock(vif->mac->bus);\n\tret = qtnf_cmd_send(vif->mac->bus, cmd_skb);\n\tqtnf_bus_unlock(vif->mac->bus);\n\n\treturn ret;\n}\n\nint qtnf_cmd_send_disconnect(struct qtnf_vif *vif, u16 reason_code)\n{\n\tstruct sk_buff *cmd_skb;\n\tstruct qlink_cmd_disconnect *cmd;\n\tint ret;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_DISCONNECT,\n\t\t\t\t\t    sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tqtnf_bus_lock(vif->mac->bus);\n\n\tcmd = (struct qlink_cmd_disconnect *)cmd_skb->data;\n\tcmd->reason = cpu_to_le16(reason_code);\n\n\tret = qtnf_cmd_send(vif->mac->bus, cmd_skb);\n\n\tqtnf_bus_unlock(vif->mac->bus);\n\n\treturn ret;\n}\n\nint qtnf_cmd_send_updown_intf(struct qtnf_vif *vif, bool up)\n{\n\tstruct sk_buff *cmd_skb;\n\tstruct qlink_cmd_updown *cmd;\n\tint ret;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_UPDOWN_INTF,\n\t\t\t\t\t    sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct qlink_cmd_updown *)cmd_skb->data;\n\tcmd->if_up = !!up;\n\n\tqtnf_bus_lock(vif->mac->bus);\n\tret = qtnf_cmd_send(vif->mac->bus, cmd_skb);\n\tqtnf_bus_unlock(vif->mac->bus);\n\n\treturn ret;\n}\n\nint qtnf_cmd_reg_notify(struct qtnf_wmac *mac, struct regulatory_request *req,\n\t\t\tbool slave_radar, bool dfs_offload)\n{\n\tstruct wiphy *wiphy = priv_to_wiphy(mac);\n\tstruct qtnf_bus *bus = mac->bus;\n\tstruct sk_buff *cmd_skb;\n\tint ret;\n\tstruct qlink_cmd_reg_notify *cmd;\n\tenum nl80211_band band;\n\tconst struct ieee80211_supported_band *cfg_band;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(mac->macid, QLINK_VIFID_RSVD,\n\t\t\t\t\t    QLINK_CMD_REG_NOTIFY,\n\t\t\t\t\t    sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct qlink_cmd_reg_notify *)cmd_skb->data;\n\tcmd->alpha2[0] = req->alpha2[0];\n\tcmd->alpha2[1] = req->alpha2[1];\n\n\tswitch (req->initiator) {\n\tcase NL80211_REGDOM_SET_BY_CORE:\n\t\tcmd->initiator = QLINK_REGDOM_SET_BY_CORE;\n\t\tbreak;\n\tcase NL80211_REGDOM_SET_BY_USER:\n\t\tcmd->initiator = QLINK_REGDOM_SET_BY_USER;\n\t\tbreak;\n\tcase NL80211_REGDOM_SET_BY_DRIVER:\n\t\tcmd->initiator = QLINK_REGDOM_SET_BY_DRIVER;\n\t\tbreak;\n\tcase NL80211_REGDOM_SET_BY_COUNTRY_IE:\n\t\tcmd->initiator = QLINK_REGDOM_SET_BY_COUNTRY_IE;\n\t\tbreak;\n\t}\n\n\tswitch (req->user_reg_hint_type) {\n\tcase NL80211_USER_REG_HINT_USER:\n\t\tcmd->user_reg_hint_type = QLINK_USER_REG_HINT_USER;\n\t\tbreak;\n\tcase NL80211_USER_REG_HINT_CELL_BASE:\n\t\tcmd->user_reg_hint_type = QLINK_USER_REG_HINT_CELL_BASE;\n\t\tbreak;\n\tcase NL80211_USER_REG_HINT_INDOOR:\n\t\tcmd->user_reg_hint_type = QLINK_USER_REG_HINT_INDOOR;\n\t\tbreak;\n\t}\n\n\tswitch (req->dfs_region) {\n\tcase NL80211_DFS_FCC:\n\t\tcmd->dfs_region = QLINK_DFS_FCC;\n\t\tbreak;\n\tcase NL80211_DFS_ETSI:\n\t\tcmd->dfs_region = QLINK_DFS_ETSI;\n\t\tbreak;\n\tcase NL80211_DFS_JP:\n\t\tcmd->dfs_region = QLINK_DFS_JP;\n\t\tbreak;\n\tdefault:\n\t\tcmd->dfs_region = QLINK_DFS_UNSET;\n\t\tbreak;\n\t}\n\n\tcmd->slave_radar = slave_radar;\n\tcmd->dfs_offload = dfs_offload;\n\tcmd->num_channels = 0;\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tunsigned int i;\n\n\t\tcfg_band = wiphy->bands[band];\n\t\tif (!cfg_band)\n\t\t\tcontinue;\n\n\t\tcmd->num_channels += cfg_band->n_channels;\n\n\t\tfor (i = 0; i < cfg_band->n_channels; ++i) {\n\t\t\tqtnf_cmd_channel_tlv_add(cmd_skb,\n\t\t\t\t\t\t &cfg_band->channels[i]);\n\t\t}\n\t}\n\n\tqtnf_bus_lock(bus);\n\tret = qtnf_cmd_send(bus, cmd_skb);\n\tqtnf_bus_unlock(bus);\n\n\treturn ret;\n}\n\nstatic int\nqtnf_cmd_resp_proc_chan_stat_info(struct survey_info *survey,\n\t\t\t\t  const u8 *payload, size_t payload_len)\n{\n\tconst struct qlink_chan_stats *stats = NULL;\n\tconst struct qlink_tlv_hdr *tlv;\n\tu16 tlv_value_len;\n\tu16 tlv_type;\n\tconst u8 *map = NULL;\n\tunsigned int map_len = 0;\n\tunsigned int stats_len = 0;\n\n\tqlink_for_each_tlv(tlv, payload, payload_len) {\n\t\ttlv_type = le16_to_cpu(tlv->type);\n\t\ttlv_value_len = le16_to_cpu(tlv->len);\n\n\t\tswitch (tlv_type) {\n\t\tcase QTN_TLV_ID_BITMAP:\n\t\t\tmap = tlv->val;\n\t\t\tmap_len = tlv_value_len;\n\t\t\tbreak;\n\t\tcase QTN_TLV_ID_CHANNEL_STATS:\n\t\t\tstats = (struct qlink_chan_stats *)tlv->val;\n\t\t\tstats_len = tlv_value_len;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_info(\"Unknown TLV type: %#x\\n\", tlv_type);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!qlink_tlv_parsing_ok(tlv, payload, payload_len)) {\n\t\tpr_err(\"Malformed TLV buffer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!map || !stats)\n\t\treturn 0;\n\n#define qtnf_chan_stat_avail(stat_name, bitn)\t\\\n\t(qtnf_utils_is_bit_set(map, bitn, map_len) && \\\n\t (offsetofend(struct qlink_chan_stats, stat_name) <= stats_len))\n\n\tif (qtnf_chan_stat_avail(time_on, QLINK_CHAN_STAT_TIME_ON)) {\n\t\tsurvey->filled |= SURVEY_INFO_TIME;\n\t\tsurvey->time = le64_to_cpu(stats->time_on);\n\t}\n\n\tif (qtnf_chan_stat_avail(time_tx, QLINK_CHAN_STAT_TIME_TX)) {\n\t\tsurvey->filled |= SURVEY_INFO_TIME_TX;\n\t\tsurvey->time_tx = le64_to_cpu(stats->time_tx);\n\t}\n\n\tif (qtnf_chan_stat_avail(time_rx, QLINK_CHAN_STAT_TIME_RX)) {\n\t\tsurvey->filled |= SURVEY_INFO_TIME_RX;\n\t\tsurvey->time_rx = le64_to_cpu(stats->time_rx);\n\t}\n\n\tif (qtnf_chan_stat_avail(cca_busy, QLINK_CHAN_STAT_CCA_BUSY)) {\n\t\tsurvey->filled |= SURVEY_INFO_TIME_BUSY;\n\t\tsurvey->time_busy = le64_to_cpu(stats->cca_busy);\n\t}\n\n\tif (qtnf_chan_stat_avail(cca_busy_ext, QLINK_CHAN_STAT_CCA_BUSY_EXT)) {\n\t\tsurvey->filled |= SURVEY_INFO_TIME_EXT_BUSY;\n\t\tsurvey->time_ext_busy = le64_to_cpu(stats->cca_busy_ext);\n\t}\n\n\tif (qtnf_chan_stat_avail(time_scan, QLINK_CHAN_STAT_TIME_SCAN)) {\n\t\tsurvey->filled |= SURVEY_INFO_TIME_SCAN;\n\t\tsurvey->time_scan = le64_to_cpu(stats->time_scan);\n\t}\n\n\tif (qtnf_chan_stat_avail(chan_noise, QLINK_CHAN_STAT_CHAN_NOISE)) {\n\t\tsurvey->filled |= SURVEY_INFO_NOISE_DBM;\n\t\tsurvey->noise = stats->chan_noise;\n\t}\n\n#undef qtnf_chan_stat_avail\n\n\treturn 0;\n}\n\nint qtnf_cmd_get_chan_stats(struct qtnf_wmac *mac, u32 chan_freq,\n\t\t\t    struct survey_info *survey)\n{\n\tstruct sk_buff *cmd_skb, *resp_skb = NULL;\n\tstruct qlink_cmd_get_chan_stats *cmd;\n\tstruct qlink_resp_get_chan_stats *resp;\n\tsize_t var_data_len = 0;\n\tint ret = 0;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(mac->macid, QLINK_VIFID_RSVD,\n\t\t\t\t\t    QLINK_CMD_CHAN_STATS,\n\t\t\t\t\t    sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct qlink_cmd_get_chan_stats *)cmd_skb->data;\n\tcmd->channel_freq = cpu_to_le32(chan_freq);\n\n\tqtnf_bus_lock(mac->bus);\n\tret = qtnf_cmd_send_with_reply(mac->bus, cmd_skb, &resp_skb,\n\t\t\t\t       sizeof(*resp), &var_data_len);\n\tqtnf_bus_unlock(mac->bus);\n\n\tif (ret)\n\t\tgoto out;\n\n\tresp = (struct qlink_resp_get_chan_stats *)resp_skb->data;\n\n\tif (le32_to_cpu(resp->chan_freq) != chan_freq) {\n\t\tpr_err(\"[MAC%u] channel stats freq %u != requested %u\\n\",\n\t\t       mac->macid, le32_to_cpu(resp->chan_freq), chan_freq);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = qtnf_cmd_resp_proc_chan_stat_info(survey, resp->info,\n\t\t\t\t\t\tvar_data_len);\n\nout:\n\tconsume_skb(resp_skb);\n\n\treturn ret;\n}\n\nint qtnf_cmd_send_chan_switch(struct qtnf_vif *vif,\n\t\t\t      struct cfg80211_csa_settings *params)\n{\n\tstruct qtnf_wmac *mac = vif->mac;\n\tstruct qlink_cmd_chan_switch *cmd;\n\tstruct sk_buff *cmd_skb;\n\tint ret;\n\tu64 flags = 0;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_CHAN_SWITCH,\n\t\t\t\t\t    sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tif (params->radar_required)\n\t\tflags |= QLINK_CHAN_SW_RADAR_REQUIRED;\n\n\tif (params->block_tx)\n\t\tflags |= QLINK_CHAN_SW_BLOCK_TX;\n\n\tcmd = (struct qlink_cmd_chan_switch *)cmd_skb->data;\n\tqlink_chandef_cfg2q(&params->chandef, &cmd->channel);\n\tcmd->flags = cpu_to_le64(flags);\n\tcmd->beacon_count = params->count;\n\n\tqtnf_bus_lock(mac->bus);\n\tret = qtnf_cmd_send(mac->bus, cmd_skb);\n\tqtnf_bus_unlock(mac->bus);\n\n\treturn ret;\n}\n\nint qtnf_cmd_get_channel(struct qtnf_vif *vif, struct cfg80211_chan_def *chdef)\n{\n\tstruct qtnf_bus *bus = vif->mac->bus;\n\tconst struct qlink_resp_channel_get *resp;\n\tstruct sk_buff *cmd_skb;\n\tstruct sk_buff *resp_skb = NULL;\n\tint ret;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_CHAN_GET,\n\t\t\t\t\t    sizeof(struct qlink_cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tqtnf_bus_lock(bus);\n\tret = qtnf_cmd_send_with_reply(bus, cmd_skb, &resp_skb,\n\t\t\t\t       sizeof(*resp), NULL);\n\tif (ret)\n\t\tgoto out;\n\n\tresp = (const struct qlink_resp_channel_get *)resp_skb->data;\n\tqlink_chandef_q2cfg(priv_to_wiphy(vif->mac), &resp->chan, chdef);\n\nout:\n\tqtnf_bus_unlock(bus);\n\tconsume_skb(resp_skb);\n\n\treturn ret;\n}\n\nint qtnf_cmd_start_cac(const struct qtnf_vif *vif,\n\t\t       const struct cfg80211_chan_def *chdef,\n\t\t       u32 cac_time_ms)\n{\n\tstruct qtnf_bus *bus = vif->mac->bus;\n\tstruct sk_buff *cmd_skb;\n\tstruct qlink_cmd_start_cac *cmd;\n\tint ret;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_START_CAC,\n\t\t\t\t\t    sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct qlink_cmd_start_cac *)cmd_skb->data;\n\tcmd->cac_time_ms = cpu_to_le32(cac_time_ms);\n\tqlink_chandef_cfg2q(chdef, &cmd->chan);\n\n\tqtnf_bus_lock(bus);\n\tret = qtnf_cmd_send(bus, cmd_skb);\n\tqtnf_bus_unlock(bus);\n\n\treturn ret;\n}\n\nint qtnf_cmd_set_mac_acl(const struct qtnf_vif *vif,\n\t\t\t const struct cfg80211_acl_data *params)\n{\n\tstruct qtnf_bus *bus = vif->mac->bus;\n\tstruct sk_buff *cmd_skb;\n\tstruct qlink_tlv_hdr *tlv;\n\tsize_t acl_size = struct_size(params, mac_addrs, params->n_acl_entries);\n\tint ret;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_SET_MAC_ACL,\n\t\t\t\t\t    sizeof(struct qlink_cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\ttlv = skb_put(cmd_skb, sizeof(*tlv) + round_up(acl_size, QLINK_ALIGN));\n\ttlv->type = cpu_to_le16(QTN_TLV_ID_ACL_DATA);\n\ttlv->len = cpu_to_le16(acl_size);\n\tqlink_acl_data_cfg2q(params, (struct qlink_acl_data *)tlv->val);\n\n\tqtnf_bus_lock(bus);\n\tret = qtnf_cmd_send(bus, cmd_skb);\n\tqtnf_bus_unlock(bus);\n\n\treturn ret;\n}\n\nint qtnf_cmd_send_pm_set(const struct qtnf_vif *vif, u8 pm_mode, int timeout)\n{\n\tstruct qtnf_bus *bus = vif->mac->bus;\n\tstruct sk_buff *cmd_skb;\n\tstruct qlink_cmd_pm_set *cmd;\n\tint ret = 0;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_PM_SET, sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct qlink_cmd_pm_set *)cmd_skb->data;\n\tcmd->pm_mode = pm_mode;\n\tcmd->pm_standby_timer = cpu_to_le32(timeout);\n\n\tqtnf_bus_lock(bus);\n\n\tret = qtnf_cmd_send(bus, cmd_skb);\n\n\tqtnf_bus_unlock(bus);\n\n\treturn ret;\n}\n\nint qtnf_cmd_get_tx_power(const struct qtnf_vif *vif, int *dbm)\n{\n\tstruct qtnf_bus *bus = vif->mac->bus;\n\tconst struct qlink_resp_txpwr *resp;\n\tstruct sk_buff *resp_skb = NULL;\n\tstruct qlink_cmd_txpwr *cmd;\n\tstruct sk_buff *cmd_skb;\n\tint ret = 0;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_TXPWR, sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct qlink_cmd_txpwr *)cmd_skb->data;\n\tcmd->op_type = QLINK_TXPWR_GET;\n\n\tqtnf_bus_lock(bus);\n\n\tret = qtnf_cmd_send_with_reply(bus, cmd_skb, &resp_skb,\n\t\t\t\t       sizeof(*resp), NULL);\n\tif (ret)\n\t\tgoto out;\n\n\tresp = (const struct qlink_resp_txpwr *)resp_skb->data;\n\t*dbm = MBM_TO_DBM(le32_to_cpu(resp->txpwr));\n\nout:\n\tqtnf_bus_unlock(bus);\n\tconsume_skb(resp_skb);\n\n\treturn ret;\n}\n\nint qtnf_cmd_set_tx_power(const struct qtnf_vif *vif,\n\t\t\t  enum nl80211_tx_power_setting type, int mbm)\n{\n\tstruct qtnf_bus *bus = vif->mac->bus;\n\tconst struct qlink_resp_txpwr *resp;\n\tstruct sk_buff *resp_skb = NULL;\n\tstruct qlink_cmd_txpwr *cmd;\n\tstruct sk_buff *cmd_skb;\n\tint ret = 0;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_TXPWR, sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct qlink_cmd_txpwr *)cmd_skb->data;\n\tcmd->op_type = QLINK_TXPWR_SET;\n\tcmd->txpwr_setting = type;\n\tcmd->txpwr = cpu_to_le32(mbm);\n\n\tqtnf_bus_lock(bus);\n\n\tret = qtnf_cmd_send_with_reply(bus, cmd_skb, &resp_skb,\n\t\t\t\t       sizeof(*resp), NULL);\n\n\tqtnf_bus_unlock(bus);\n\tconsume_skb(resp_skb);\n\n\treturn ret;\n}\n\nint qtnf_cmd_send_wowlan_set(const struct qtnf_vif *vif,\n\t\t\t     const struct cfg80211_wowlan *wowl)\n{\n\tstruct qtnf_bus *bus = vif->mac->bus;\n\tstruct sk_buff *cmd_skb;\n\tstruct qlink_cmd_wowlan_set *cmd;\n\tu32 triggers = 0;\n\tint count = 0;\n\tint ret = 0;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_WOWLAN_SET, sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tqtnf_bus_lock(bus);\n\n\tcmd = (struct qlink_cmd_wowlan_set *)cmd_skb->data;\n\n\tif (wowl) {\n\t\tif (wowl->disconnect)\n\t\t\ttriggers |=  QLINK_WOWLAN_TRIG_DISCONNECT;\n\n\t\tif (wowl->magic_pkt)\n\t\t\ttriggers |= QLINK_WOWLAN_TRIG_MAGIC_PKT;\n\n\t\tif (wowl->n_patterns && wowl->patterns) {\n\t\t\ttriggers |= QLINK_WOWLAN_TRIG_PATTERN_PKT;\n\t\t\twhile (count < wowl->n_patterns) {\n\t\t\t\tqtnf_cmd_skb_put_tlv_arr(cmd_skb,\n\t\t\t\t\tQTN_TLV_ID_WOWLAN_PATTERN,\n\t\t\t\t\twowl->patterns[count].pattern,\n\t\t\t\t\twowl->patterns[count].pattern_len);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcmd->triggers = cpu_to_le32(triggers);\n\n\tret = qtnf_cmd_send(bus, cmd_skb);\n\n\tqtnf_bus_unlock(bus);\n\treturn ret;\n}\n\nint qtnf_cmd_netdev_changeupper(const struct qtnf_vif *vif, int br_domain)\n{\n\tstruct qtnf_bus *bus = vif->mac->bus;\n\tstruct sk_buff *cmd_skb;\n\tstruct qlink_cmd_ndev_changeupper *cmd;\n\tint ret;\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_NDEV_EVENT,\n\t\t\t\t\t    sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tpr_debug(\"[VIF%u.%u] set broadcast domain to %d\\n\",\n\t\t vif->mac->macid, vif->vifid, br_domain);\n\n\tcmd = (struct qlink_cmd_ndev_changeupper *)cmd_skb->data;\n\tcmd->nehdr.event = cpu_to_le16(QLINK_NDEV_EVENT_CHANGEUPPER);\n\tcmd->upper_type = QLINK_NDEV_UPPER_TYPE_BRIDGE;\n\tcmd->br_domain = cpu_to_le32(br_domain);\n\n\tqtnf_bus_lock(bus);\n\tret = qtnf_cmd_send(bus, cmd_skb);\n\tqtnf_bus_unlock(bus);\n\n\tif (ret)\n\t\tpr_err(\"[VIF%u.%u] failed to set broadcast domain\\n\",\n\t\t       vif->mac->macid, vif->vifid);\n\n\treturn ret;\n}\n\nint qtnf_cmd_send_update_owe(struct qtnf_vif *vif,\n\t\t\t     struct cfg80211_update_owe_info *owe)\n{\n\tstruct qlink_cmd_update_owe *cmd;\n\tstruct sk_buff *cmd_skb;\n\tint ret;\n\n\tif (sizeof(*cmd) + owe->ie_len > QTNF_MAX_CMD_BUF_SIZE) {\n\t\tpr_warn(\"VIF%u.%u: OWE update IEs too big: %zu\\n\",\n\t\t\tvif->mac->macid, vif->vifid, owe->ie_len);\n\t\treturn -E2BIG;\n\t}\n\n\tcmd_skb = qtnf_cmd_alloc_new_cmdskb(vif->mac->macid, vif->vifid,\n\t\t\t\t\t    QLINK_CMD_UPDATE_OWE,\n\t\t\t\t\t    sizeof(*cmd));\n\tif (!cmd_skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct qlink_cmd_update_owe *)cmd_skb->data;\n\tether_addr_copy(cmd->peer, owe->peer);\n\tcmd->status = cpu_to_le16(owe->status);\n\tif (owe->ie_len && owe->ie)\n\t\tqtnf_cmd_skb_put_buffer(cmd_skb, owe->ie, owe->ie_len);\n\n\tqtnf_bus_lock(vif->mac->bus);\n\tret = qtnf_cmd_send(vif->mac->bus, cmd_skb);\n\tqtnf_bus_unlock(vif->mac->bus);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}