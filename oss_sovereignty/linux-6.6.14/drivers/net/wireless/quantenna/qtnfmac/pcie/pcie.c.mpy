{
  "module_name": "pcie.c",
  "hash_id": "d614b78716cd4935b9069e8e3d7c2976aa6ba075f935eba1e9d90e9e67ec0bf1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/quantenna/qtnfmac/pcie/pcie.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/printk.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/netdevice.h>\n#include <linux/seq_file.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n\n#include \"pcie_priv.h\"\n#include \"bus.h\"\n#include \"shm_ipc.h\"\n#include \"core.h\"\n#include \"debug.h\"\n#include \"util.h\"\n#include \"qtn_hw_ids.h\"\n\n#define QTN_SYSCTL_BAR\t0\n#define QTN_SHMEM_BAR\t2\n#define QTN_DMA_BAR\t3\n\n#define QTN_PCIE_MAX_FW_BUFSZ\t\t(1 * 1024 * 1024)\n\nstatic bool use_msi = true;\nmodule_param(use_msi, bool, 0644);\nMODULE_PARM_DESC(use_msi, \"set 0 to use legacy interrupt\");\n\nstatic unsigned int tx_bd_size_param;\nmodule_param(tx_bd_size_param, uint, 0644);\nMODULE_PARM_DESC(tx_bd_size_param, \"Tx descriptors queue size\");\n\nstatic unsigned int rx_bd_size_param;\nmodule_param(rx_bd_size_param, uint, 0644);\nMODULE_PARM_DESC(rx_bd_size_param, \"Rx descriptors queue size\");\n\nstatic u8 flashboot = 1;\nmodule_param(flashboot, byte, 0644);\nMODULE_PARM_DESC(flashboot, \"set to 0 to use FW binary file on FS\");\n\nstatic unsigned int fw_blksize_param = QTN_PCIE_MAX_FW_BUFSZ;\nmodule_param(fw_blksize_param, uint, 0644);\nMODULE_PARM_DESC(fw_blksize_param, \"firmware loading block size in bytes\");\n\n#define DRV_NAME\t\"qtnfmac_pcie\"\n\nint qtnf_pcie_control_tx(struct qtnf_bus *bus, struct sk_buff *skb)\n{\n\tstruct qtnf_pcie_bus_priv *priv = get_bus_priv(bus);\n\tint ret;\n\n\tret = qtnf_shm_ipc_send(&priv->shm_ipc_ep_in, skb->data, skb->len);\n\n\tif (ret == -ETIMEDOUT) {\n\t\tpr_err(\"EP firmware is dead\\n\");\n\t\tbus->fw_state = QTNF_FW_STATE_DEAD;\n\t}\n\n\treturn ret;\n}\n\nint qtnf_pcie_alloc_skb_array(struct qtnf_pcie_bus_priv *priv)\n{\n\tstruct sk_buff **vaddr;\n\tint len;\n\n\tlen = priv->tx_bd_num * sizeof(*priv->tx_skb) +\n\t\tpriv->rx_bd_num * sizeof(*priv->rx_skb);\n\tvaddr = devm_kzalloc(&priv->pdev->dev, len, GFP_KERNEL);\n\n\tif (!vaddr)\n\t\treturn -ENOMEM;\n\n\tpriv->tx_skb = vaddr;\n\n\tvaddr += priv->tx_bd_num;\n\tpriv->rx_skb = vaddr;\n\n\treturn 0;\n}\n\nstatic void qtnf_pcie_bringup_fw_async(struct qtnf_bus *bus)\n{\n\tstruct qtnf_pcie_bus_priv *priv = get_bus_priv(bus);\n\tstruct pci_dev *pdev = priv->pdev;\n\n\tget_device(&pdev->dev);\n\tschedule_work(&bus->fw_work);\n}\n\nstatic int qtnf_dbg_mps_show(struct seq_file *s, void *data)\n{\n\tstruct qtnf_bus *bus = dev_get_drvdata(s->private);\n\tstruct qtnf_pcie_bus_priv *priv = get_bus_priv(bus);\n\n\tseq_printf(s, \"%d\\n\", pcie_get_mps(priv->pdev));\n\n\treturn 0;\n}\n\nstatic int qtnf_dbg_msi_show(struct seq_file *s, void *data)\n{\n\tstruct qtnf_bus *bus = dev_get_drvdata(s->private);\n\tstruct qtnf_pcie_bus_priv *priv = get_bus_priv(bus);\n\n\tseq_printf(s, \"%u\\n\", priv->msi_enabled);\n\n\treturn 0;\n}\n\nstatic int qtnf_dbg_shm_stats(struct seq_file *s, void *data)\n{\n\tstruct qtnf_bus *bus = dev_get_drvdata(s->private);\n\tstruct qtnf_pcie_bus_priv *priv = get_bus_priv(bus);\n\n\tseq_printf(s, \"shm_ipc_ep_in.tx_packet_count(%zu)\\n\",\n\t\t   priv->shm_ipc_ep_in.tx_packet_count);\n\tseq_printf(s, \"shm_ipc_ep_in.rx_packet_count(%zu)\\n\",\n\t\t   priv->shm_ipc_ep_in.rx_packet_count);\n\tseq_printf(s, \"shm_ipc_ep_out.tx_packet_count(%zu)\\n\",\n\t\t   priv->shm_ipc_ep_out.tx_timeout_count);\n\tseq_printf(s, \"shm_ipc_ep_out.rx_packet_count(%zu)\\n\",\n\t\t   priv->shm_ipc_ep_out.rx_packet_count);\n\n\treturn 0;\n}\n\nint qtnf_pcie_fw_boot_done(struct qtnf_bus *bus)\n{\n\tstruct qtnf_pcie_bus_priv *priv = get_bus_priv(bus);\n\tchar card_id[64];\n\tint ret;\n\n\tbus->fw_state = QTNF_FW_STATE_BOOT_DONE;\n\tret = qtnf_core_attach(bus);\n\tif (ret) {\n\t\tpr_err(\"failed to attach core\\n\");\n\t} else {\n\t\tsnprintf(card_id, sizeof(card_id), \"%s:%s\",\n\t\t\t DRV_NAME, pci_name(priv->pdev));\n\t\tqtnf_debugfs_init(bus, card_id);\n\t\tqtnf_debugfs_add_entry(bus, \"mps\", qtnf_dbg_mps_show);\n\t\tqtnf_debugfs_add_entry(bus, \"msi_enabled\", qtnf_dbg_msi_show);\n\t\tqtnf_debugfs_add_entry(bus, \"shm_stats\", qtnf_dbg_shm_stats);\n\t}\n\n\treturn ret;\n}\n\nstatic void qtnf_tune_pcie_mps(struct pci_dev *pdev)\n{\n\tstruct pci_dev *parent;\n\tint mps_p, mps_o, mps_m, mps;\n\tint ret;\n\n\t \n\tmps_o = pcie_get_mps(pdev);\n\n\t \n\tmps_m = 128 << pdev->pcie_mpss;\n\n\t \n\tmps = mps_m;\n\n\tif (pdev->bus && pdev->bus->self) {\n\t\t \n\t\tparent = pdev->bus->self;\n\n\t\tif (pci_is_pcie(parent)) {\n\t\t\tmps_p = pcie_get_mps(parent);\n\t\t\tmps = min(mps_m, mps_p);\n\t\t}\n\t}\n\n\tret = pcie_set_mps(pdev, mps);\n\tif (ret) {\n\t\tpr_err(\"failed to set mps to %d, keep using current %d\\n\",\n\t\t       mps, mps_o);\n\t\treturn;\n\t}\n\n\tpr_debug(\"set mps to %d (was %d, max %d)\\n\", mps, mps_o, mps_m);\n}\n\nstatic void qtnf_pcie_init_irq(struct qtnf_pcie_bus_priv *priv, bool use_msi)\n{\n\tstruct pci_dev *pdev = priv->pdev;\n\n\t \n\tpriv->msi_enabled = 0;\n\n\t \n\tif (use_msi) {\n\t\tif (!pci_enable_msi(pdev)) {\n\t\t\tpr_debug(\"enabled MSI interrupt\\n\");\n\t\t\tpriv->msi_enabled = 1;\n\t\t} else {\n\t\t\tpr_warn(\"failed to enable MSI interrupts\");\n\t\t}\n\t}\n\n\tif (!priv->msi_enabled) {\n\t\tpr_warn(\"legacy PCIE interrupts enabled\\n\");\n\t\tpci_intx(pdev, 1);\n\t}\n}\n\nstatic void __iomem *qtnf_map_bar(struct pci_dev *pdev, u8 index)\n{\n\tvoid __iomem *vaddr;\n\tdma_addr_t busaddr;\n\tsize_t len;\n\tint ret;\n\n\tret = pcim_iomap_regions(pdev, 1 << index, \"qtnfmac_pcie\");\n\tif (ret)\n\t\treturn IOMEM_ERR_PTR(ret);\n\n\tbusaddr = pci_resource_start(pdev, index);\n\tlen = pci_resource_len(pdev, index);\n\tvaddr = pcim_iomap_table(pdev)[index];\n\tif (!vaddr)\n\t\treturn IOMEM_ERR_PTR(-ENOMEM);\n\n\tpr_debug(\"BAR%u vaddr=0x%p busaddr=%pad len=%u\\n\",\n\t\t index, vaddr, &busaddr, (int)len);\n\n\treturn vaddr;\n}\n\nstatic void qtnf_pcie_control_rx_callback(void *arg, const u8 __iomem *buf,\n\t\t\t\t\t  size_t len)\n{\n\tstruct qtnf_pcie_bus_priv *priv = arg;\n\tstruct qtnf_bus *bus = pci_get_drvdata(priv->pdev);\n\tstruct sk_buff *skb;\n\n\tif (unlikely(len == 0)) {\n\t\tpr_warn(\"zero length packet received\\n\");\n\t\treturn;\n\t}\n\n\tskb = __dev_alloc_skb(len, GFP_KERNEL);\n\n\tif (unlikely(!skb)) {\n\t\tpr_err(\"failed to allocate skb\\n\");\n\t\treturn;\n\t}\n\n\tmemcpy_fromio(skb_put(skb, len), buf, len);\n\n\tqtnf_trans_handle_rx_ctl_packet(bus, skb);\n}\n\nvoid qtnf_pcie_init_shm_ipc(struct qtnf_pcie_bus_priv *priv,\n\t\t\t    struct qtnf_shm_ipc_region __iomem *ipc_tx_reg,\n\t\t\t    struct qtnf_shm_ipc_region __iomem *ipc_rx_reg,\n\t\t\t    const struct qtnf_shm_ipc_int *ipc_int)\n{\n\tconst struct qtnf_shm_ipc_rx_callback rx_callback = {\n\t\t\t\t\tqtnf_pcie_control_rx_callback, priv };\n\n\tqtnf_shm_ipc_init(&priv->shm_ipc_ep_in, QTNF_SHM_IPC_OUTBOUND,\n\t\t\t  ipc_tx_reg, priv->workqueue,\n\t\t\t  ipc_int, &rx_callback);\n\tqtnf_shm_ipc_init(&priv->shm_ipc_ep_out, QTNF_SHM_IPC_INBOUND,\n\t\t\t  ipc_rx_reg, priv->workqueue,\n\t\t\t  ipc_int, &rx_callback);\n}\n\nstatic int qtnf_pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct qtnf_pcie_bus_priv *pcie_priv;\n\tstruct qtnf_bus *bus;\n\tvoid __iomem *sysctl_bar;\n\tvoid __iomem *epmem_bar;\n\tvoid __iomem *dmareg_bar;\n\tunsigned int chipid;\n\tint ret;\n\n\tif (!pci_is_pcie(pdev)) {\n\t\tpr_err(\"device %s is not PCI Express\\n\", pci_name(pdev));\n\t\treturn -EIO;\n\t}\n\n\tqtnf_tune_pcie_mps(pdev);\n\n\tret = pcim_enable_device(pdev);\n\tif (ret) {\n\t\tpr_err(\"failed to init PCI device %x\\n\", pdev->device);\n\t\treturn ret;\n\t}\n\n\tpci_set_master(pdev);\n\n\tsysctl_bar = qtnf_map_bar(pdev, QTN_SYSCTL_BAR);\n\tif (IS_ERR(sysctl_bar)) {\n\t\tpr_err(\"failed to map BAR%u\\n\", QTN_SYSCTL_BAR);\n\t\treturn PTR_ERR(sysctl_bar);\n\t}\n\n\tdmareg_bar = qtnf_map_bar(pdev, QTN_DMA_BAR);\n\tif (IS_ERR(dmareg_bar)) {\n\t\tpr_err(\"failed to map BAR%u\\n\", QTN_DMA_BAR);\n\t\treturn PTR_ERR(dmareg_bar);\n\t}\n\n\tepmem_bar = qtnf_map_bar(pdev, QTN_SHMEM_BAR);\n\tif (IS_ERR(epmem_bar)) {\n\t\tpr_err(\"failed to map BAR%u\\n\", QTN_SHMEM_BAR);\n\t\treturn PTR_ERR(epmem_bar);\n\t}\n\n\tchipid = qtnf_chip_id_get(sysctl_bar);\n\n\tpr_info(\"identified device: %s\\n\", qtnf_chipid_to_string(chipid));\n\n\tswitch (chipid) {\n\tcase QTN_CHIP_ID_PEARL:\n\tcase QTN_CHIP_ID_PEARL_B:\n\tcase QTN_CHIP_ID_PEARL_C:\n\t\tbus = qtnf_pcie_pearl_alloc(pdev);\n\t\tbreak;\n\tcase QTN_CHIP_ID_TOPAZ:\n\t\tbus = qtnf_pcie_topaz_alloc(pdev);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unsupported chip ID 0x%x\\n\", chipid);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\tpcie_priv = get_bus_priv(bus);\n\tpci_set_drvdata(pdev, bus);\n\tbus->dev = &pdev->dev;\n\tbus->fw_state = QTNF_FW_STATE_DETACHED;\n\tpcie_priv->pdev = pdev;\n\tpcie_priv->tx_stopped = 0;\n\tpcie_priv->flashboot = flashboot;\n\n\tif (fw_blksize_param > QTN_PCIE_MAX_FW_BUFSZ)\n\t\tpcie_priv->fw_blksize =  QTN_PCIE_MAX_FW_BUFSZ;\n\telse\n\t\tpcie_priv->fw_blksize = fw_blksize_param;\n\n\tmutex_init(&bus->bus_lock);\n\tspin_lock_init(&pcie_priv->tx_lock);\n\tspin_lock_init(&pcie_priv->tx_reclaim_lock);\n\n\tpcie_priv->tx_full_count = 0;\n\tpcie_priv->tx_done_count = 0;\n\tpcie_priv->pcie_irq_count = 0;\n\tpcie_priv->tx_reclaim_done = 0;\n\tpcie_priv->tx_reclaim_req = 0;\n\n\tpcie_priv->workqueue = create_singlethread_workqueue(\"QTNF_PCIE\");\n\tif (!pcie_priv->workqueue) {\n\t\tpr_err(\"failed to alloc bus workqueue\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = dma_set_mask_and_coherent(&pdev->dev,\n\t\t\t\t\tpcie_priv->dma_mask_get_cb());\n\tif (ret) {\n\t\tpr_err(\"PCIE DMA coherent mask init failed 0x%llx\\n\",\n\t\t       pcie_priv->dma_mask_get_cb());\n\t\tgoto error;\n\t}\n\n\tinit_dummy_netdev(&bus->mux_dev);\n\tqtnf_pcie_init_irq(pcie_priv, use_msi);\n\tpcie_priv->sysctl_bar = sysctl_bar;\n\tpcie_priv->dmareg_bar = dmareg_bar;\n\tpcie_priv->epmem_bar = epmem_bar;\n\tpci_save_state(pdev);\n\n\tret = pcie_priv->probe_cb(bus, tx_bd_size_param, rx_bd_size_param);\n\tif (ret)\n\t\tgoto error;\n\n\tqtnf_pcie_bringup_fw_async(bus);\n\treturn 0;\n\nerror:\n\tdestroy_workqueue(pcie_priv->workqueue);\n\tpci_set_drvdata(pdev, NULL);\n\treturn ret;\n}\n\nstatic void qtnf_pcie_free_shm_ipc(struct qtnf_pcie_bus_priv *priv)\n{\n\tqtnf_shm_ipc_free(&priv->shm_ipc_ep_in);\n\tqtnf_shm_ipc_free(&priv->shm_ipc_ep_out);\n}\n\nstatic void qtnf_pcie_remove(struct pci_dev *dev)\n{\n\tstruct qtnf_pcie_bus_priv *priv;\n\tstruct qtnf_bus *bus;\n\n\tbus = pci_get_drvdata(dev);\n\tif (!bus)\n\t\treturn;\n\n\tpriv = get_bus_priv(bus);\n\n\tcancel_work_sync(&bus->fw_work);\n\n\tif (qtnf_fw_is_attached(bus))\n\t\tqtnf_core_detach(bus);\n\n\tnetif_napi_del(&bus->mux_napi);\n\tdestroy_workqueue(priv->workqueue);\n\ttasklet_kill(&priv->reclaim_tq);\n\n\tqtnf_pcie_free_shm_ipc(priv);\n\tqtnf_debugfs_remove(bus);\n\tpriv->remove_cb(bus);\n\tpci_set_drvdata(priv->pdev, NULL);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int qtnf_pcie_suspend(struct device *dev)\n{\n\tstruct qtnf_pcie_bus_priv *priv;\n\tstruct qtnf_bus *bus;\n\n\tbus = dev_get_drvdata(dev);\n\tif (!bus)\n\t\treturn -EFAULT;\n\n\tpriv = get_bus_priv(bus);\n\treturn priv->suspend_cb(bus);\n}\n\nstatic int qtnf_pcie_resume(struct device *dev)\n{\n\tstruct qtnf_pcie_bus_priv *priv;\n\tstruct qtnf_bus *bus;\n\n\tbus = dev_get_drvdata(dev);\n\tif (!bus)\n\t\treturn -EFAULT;\n\n\tpriv = get_bus_priv(bus);\n\treturn priv->resume_cb(bus);\n}\n\n \nstatic SIMPLE_DEV_PM_OPS(qtnf_pcie_pm_ops, qtnf_pcie_suspend,\n\t\t\t qtnf_pcie_resume);\n#endif\n\nstatic const struct pci_device_id qtnf_pcie_devid_table[] = {\n\t{\n\t\tPCIE_VENDOR_ID_QUANTENNA, PCIE_DEVICE_ID_QSR,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t},\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(pci, qtnf_pcie_devid_table);\n\nstatic struct pci_driver qtnf_pcie_drv_data = {\n\t.name = DRV_NAME,\n\t.id_table = qtnf_pcie_devid_table,\n\t.probe = qtnf_pcie_probe,\n\t.remove = qtnf_pcie_remove,\n#ifdef CONFIG_PM_SLEEP\n\t.driver = {\n\t\t.pm = &qtnf_pcie_pm_ops,\n\t},\n#endif\n};\n\nmodule_pci_driver(qtnf_pcie_drv_data)\n\nMODULE_AUTHOR(\"Quantenna Communications\");\nMODULE_DESCRIPTION(\"Quantenna PCIe bus driver for 802.11 wireless LAN.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}