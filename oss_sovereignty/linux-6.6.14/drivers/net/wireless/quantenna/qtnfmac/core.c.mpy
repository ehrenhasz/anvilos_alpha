{
  "module_name": "core.c",
  "hash_id": "a9fab365c808e71b331d28d2a721d306a6b296bc5e63d7e8a933f8d742795c69",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/quantenna/qtnfmac/core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/if_ether.h>\n#include <linux/nospec.h>\n\n#include \"core.h\"\n#include \"bus.h\"\n#include \"trans.h\"\n#include \"commands.h\"\n#include \"cfg80211.h\"\n#include \"event.h\"\n#include \"util.h\"\n#include \"switchdev.h\"\n\n#define QTNF_PRIMARY_VIF_IDX\t0\n\nstatic bool slave_radar = true;\nmodule_param(slave_radar, bool, 0644);\nMODULE_PARM_DESC(slave_radar, \"set 0 to disable radar detection in slave mode\");\n\nstatic bool dfs_offload;\nmodule_param(dfs_offload, bool, 0644);\nMODULE_PARM_DESC(dfs_offload, \"set 1 to enable DFS offload to firmware\");\n\nstatic struct dentry *qtnf_debugfs_dir;\n\nbool qtnf_slave_radar_get(void)\n{\n\treturn slave_radar;\n}\n\nbool qtnf_dfs_offload_get(void)\n{\n\treturn dfs_offload;\n}\n\nstruct qtnf_wmac *qtnf_core_get_mac(const struct qtnf_bus *bus, u8 macid)\n{\n\tstruct qtnf_wmac *mac = NULL;\n\n\tif (macid >= QTNF_MAX_MAC) {\n\t\tpr_err(\"invalid MAC index %u\\n\", macid);\n\t\treturn NULL;\n\t}\n\n\tmacid = array_index_nospec(macid, QTNF_MAX_MAC);\n\tmac = bus->mac[macid];\n\n\tif (unlikely(!mac)) {\n\t\tpr_err(\"MAC%u: not initialized\\n\", macid);\n\t\treturn NULL;\n\t}\n\n\treturn mac;\n}\n\n \nstatic int qtnf_netdev_open(struct net_device *ndev)\n{\n\tnetif_carrier_off(ndev);\n\tqtnf_netdev_updown(ndev, 1);\n\treturn 0;\n}\n\n \nstatic int qtnf_netdev_close(struct net_device *ndev)\n{\n\tnetif_carrier_off(ndev);\n\tqtnf_virtual_intf_cleanup(ndev);\n\tqtnf_netdev_updown(ndev, 0);\n\treturn 0;\n}\n\nstatic void qtnf_packet_send_hi_pri(struct sk_buff *skb)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(skb->dev);\n\n\tskb_queue_tail(&vif->high_pri_tx_queue, skb);\n\tqueue_work(vif->mac->bus->hprio_workqueue, &vif->high_pri_tx_work);\n}\n\n \nstatic netdev_tx_t\nqtnf_netdev_hard_start_xmit(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct qtnf_vif *vif;\n\tstruct qtnf_wmac *mac;\n\n\tvif = qtnf_netdev_get_priv(ndev);\n\n\tif (unlikely(skb->dev != ndev)) {\n\t\tpr_err_ratelimited(\"invalid skb->dev\");\n\t\tdev_kfree_skb_any(skb);\n\t\treturn 0;\n\t}\n\n\tif (unlikely(vif->wdev.iftype == NL80211_IFTYPE_UNSPECIFIED)) {\n\t\tpr_err_ratelimited(\"%s: VIF not initialized\\n\", ndev->name);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn 0;\n\t}\n\n\tmac = vif->mac;\n\tif (unlikely(!mac)) {\n\t\tpr_err_ratelimited(\"%s: NULL mac pointer\", ndev->name);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn 0;\n\t}\n\n\tif (!skb->len || (skb->len > ETH_FRAME_LEN)) {\n\t\tpr_err_ratelimited(\"%s: invalid skb len %d\\n\", ndev->name,\n\t\t\t\t   skb->len);\n\t\tdev_kfree_skb_any(skb);\n\t\tndev->stats.tx_dropped++;\n\t\treturn 0;\n\t}\n\n\t \n\tvif->cons_tx_timeout_cnt = 0;\n\n\tif (unlikely(skb->protocol == htons(ETH_P_PAE))) {\n\t\tqtnf_packet_send_hi_pri(skb);\n\t\tdev_sw_netstats_tx_add(ndev, 1, skb->len);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\treturn qtnf_bus_data_tx(mac->bus, skb, mac->macid, vif->vifid);\n}\n\n \nstatic void qtnf_netdev_tx_timeout(struct net_device *ndev, unsigned int txqueue)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(ndev);\n\tstruct qtnf_wmac *mac;\n\tstruct qtnf_bus *bus;\n\n\tif (unlikely(!vif || !vif->mac || !vif->mac->bus))\n\t\treturn;\n\n\tmac = vif->mac;\n\tbus = mac->bus;\n\n\tpr_warn(\"VIF%u.%u: Tx timeout- %lu\\n\", mac->macid, vif->vifid, jiffies);\n\n\tqtnf_bus_data_tx_timeout(bus, ndev);\n\tndev->stats.tx_errors++;\n\n\tif (++vif->cons_tx_timeout_cnt > QTNF_TX_TIMEOUT_TRSHLD) {\n\t\tpr_err(\"Tx timeout threshold exceeded !\\n\");\n\t\tpr_err(\"schedule interface %s reset !\\n\", netdev_name(ndev));\n\t\tqueue_work(bus->workqueue, &vif->reset_work);\n\t}\n}\n\nstatic int qtnf_netdev_set_mac_address(struct net_device *ndev, void *addr)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(ndev);\n\tstruct sockaddr *sa = addr;\n\tint ret;\n\tunsigned char old_addr[ETH_ALEN];\n\n\tmemcpy(old_addr, sa->sa_data, sizeof(old_addr));\n\n\tret = eth_mac_addr(ndev, sa);\n\tif (ret)\n\t\treturn ret;\n\n\tqtnf_scan_done(vif->mac, true);\n\n\tret = qtnf_cmd_send_change_intf_type(vif, vif->wdev.iftype,\n\t\t\t\t\t     vif->wdev.use_4addr,\n\t\t\t\t\t     sa->sa_data);\n\n\tif (ret)\n\t\teth_hw_addr_set(ndev, old_addr);\n\n\treturn ret;\n}\n\nstatic int qtnf_netdev_port_parent_id(struct net_device *ndev,\n\t\t\t\t      struct netdev_phys_item_id *ppid)\n{\n\tconst struct qtnf_vif *vif = qtnf_netdev_get_priv(ndev);\n\tconst struct qtnf_bus *bus = vif->mac->bus;\n\n\tppid->id_len = sizeof(bus->hw_id);\n\tmemcpy(&ppid->id, bus->hw_id, ppid->id_len);\n\n\treturn 0;\n}\n\nstatic int qtnf_netdev_alloc_pcpu_stats(struct net_device *dev)\n{\n\tdev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\n\n\treturn dev->tstats ? 0 : -ENOMEM;\n}\n\nstatic void qtnf_netdev_free_pcpu_stats(struct net_device *dev)\n{\n\tfree_percpu(dev->tstats);\n}\n\n \nconst struct net_device_ops qtnf_netdev_ops = {\n\t.ndo_init = qtnf_netdev_alloc_pcpu_stats,\n\t.ndo_uninit = qtnf_netdev_free_pcpu_stats,\n\t.ndo_open = qtnf_netdev_open,\n\t.ndo_stop = qtnf_netdev_close,\n\t.ndo_start_xmit = qtnf_netdev_hard_start_xmit,\n\t.ndo_tx_timeout = qtnf_netdev_tx_timeout,\n\t.ndo_get_stats64 = dev_get_tstats64,\n\t.ndo_set_mac_address = qtnf_netdev_set_mac_address,\n\t.ndo_get_port_parent_id = qtnf_netdev_port_parent_id,\n};\n\nstatic int qtnf_mac_init_single_band(struct wiphy *wiphy,\n\t\t\t\t     struct qtnf_wmac *mac,\n\t\t\t\t     enum nl80211_band band)\n{\n\tint ret;\n\n\twiphy->bands[band] = kzalloc(sizeof(*wiphy->bands[band]), GFP_KERNEL);\n\tif (!wiphy->bands[band])\n\t\treturn -ENOMEM;\n\n\twiphy->bands[band]->band = band;\n\n\tret = qtnf_cmd_band_info_get(mac, wiphy->bands[band]);\n\tif (ret) {\n\t\tpr_err(\"MAC%u: band %u: failed to get chans info: %d\\n\",\n\t\t       mac->macid, band, ret);\n\t\treturn ret;\n\t}\n\n\tqtnf_band_init_rates(wiphy->bands[band]);\n\n\treturn 0;\n}\n\nstatic int qtnf_mac_init_bands(struct qtnf_wmac *mac)\n{\n\tstruct wiphy *wiphy = priv_to_wiphy(mac);\n\tint ret = 0;\n\n\tif (mac->macinfo.bands_cap & QLINK_BAND_2GHZ) {\n\t\tret = qtnf_mac_init_single_band(wiphy, mac, NL80211_BAND_2GHZ);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (mac->macinfo.bands_cap & QLINK_BAND_5GHZ) {\n\t\tret = qtnf_mac_init_single_band(wiphy, mac, NL80211_BAND_5GHZ);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (mac->macinfo.bands_cap & QLINK_BAND_60GHZ)\n\t\tret = qtnf_mac_init_single_band(wiphy, mac, NL80211_BAND_60GHZ);\n\nout:\n\treturn ret;\n}\n\nstruct qtnf_vif *qtnf_mac_get_free_vif(struct qtnf_wmac *mac)\n{\n\tstruct qtnf_vif *vif;\n\tint i;\n\n\tfor (i = 0; i < QTNF_MAX_INTF; i++) {\n\t\tvif = &mac->iflist[i];\n\t\tif (vif->wdev.iftype == NL80211_IFTYPE_UNSPECIFIED)\n\t\t\treturn vif;\n\t}\n\n\treturn NULL;\n}\n\nstruct qtnf_vif *qtnf_mac_get_base_vif(struct qtnf_wmac *mac)\n{\n\tstruct qtnf_vif *vif;\n\n\tvif = &mac->iflist[QTNF_PRIMARY_VIF_IDX];\n\n\tif (vif->wdev.iftype == NL80211_IFTYPE_UNSPECIFIED)\n\t\treturn NULL;\n\n\treturn vif;\n}\n\nvoid qtnf_mac_iface_comb_free(struct qtnf_wmac *mac)\n{\n\tstruct ieee80211_iface_combination *comb;\n\tint i;\n\n\tif (mac->macinfo.if_comb) {\n\t\tfor (i = 0; i < mac->macinfo.n_if_comb; i++) {\n\t\t\tcomb = &mac->macinfo.if_comb[i];\n\t\t\tkfree(comb->limits);\n\t\t\tcomb->limits = NULL;\n\t\t}\n\n\t\tkfree(mac->macinfo.if_comb);\n\t\tmac->macinfo.if_comb = NULL;\n\t}\n}\n\nvoid qtnf_mac_ext_caps_free(struct qtnf_wmac *mac)\n{\n\tif (mac->macinfo.extended_capabilities_len) {\n\t\tkfree(mac->macinfo.extended_capabilities);\n\t\tmac->macinfo.extended_capabilities = NULL;\n\n\t\tkfree(mac->macinfo.extended_capabilities_mask);\n\t\tmac->macinfo.extended_capabilities_mask = NULL;\n\n\t\tmac->macinfo.extended_capabilities_len = 0;\n\t}\n}\n\nstatic void qtnf_vif_reset_handler(struct work_struct *work)\n{\n\tstruct qtnf_vif *vif = container_of(work, struct qtnf_vif, reset_work);\n\n\trtnl_lock();\n\n\tif (vif->wdev.iftype == NL80211_IFTYPE_UNSPECIFIED) {\n\t\trtnl_unlock();\n\t\treturn;\n\t}\n\n\t \n\tnetif_tx_stop_all_queues(vif->netdev);\n\tif (netif_carrier_ok(vif->netdev))\n\t\tnetif_carrier_off(vif->netdev);\n\n\tqtnf_cfg80211_vif_reset(vif);\n\n\trtnl_unlock();\n}\n\nstatic void qtnf_mac_init_primary_intf(struct qtnf_wmac *mac)\n{\n\tstruct qtnf_vif *vif = &mac->iflist[QTNF_PRIMARY_VIF_IDX];\n\n\tvif->wdev.iftype = NL80211_IFTYPE_STATION;\n\tvif->bss_priority = QTNF_DEF_BSS_PRIORITY;\n\tvif->wdev.wiphy = priv_to_wiphy(mac);\n\tINIT_WORK(&vif->reset_work, qtnf_vif_reset_handler);\n\tvif->cons_tx_timeout_cnt = 0;\n}\n\nstatic void qtnf_mac_scan_finish(struct qtnf_wmac *mac, bool aborted)\n{\n\tstruct cfg80211_scan_info info = {\n\t\t.aborted = aborted,\n\t};\n\n\tmutex_lock(&mac->mac_lock);\n\n\tif (mac->scan_req) {\n\t\tcfg80211_scan_done(mac->scan_req, &info);\n\t\tmac->scan_req = NULL;\n\t}\n\n\tmutex_unlock(&mac->mac_lock);\n}\n\nvoid qtnf_scan_done(struct qtnf_wmac *mac, bool aborted)\n{\n\tcancel_delayed_work_sync(&mac->scan_timeout);\n\tqtnf_mac_scan_finish(mac, aborted);\n}\n\nstatic void qtnf_mac_scan_timeout(struct work_struct *work)\n{\n\tstruct qtnf_wmac *mac =\n\t\tcontainer_of(work, struct qtnf_wmac, scan_timeout.work);\n\n\tpr_warn(\"MAC%d: scan timed out\\n\", mac->macid);\n\tqtnf_mac_scan_finish(mac, true);\n}\n\nstatic void qtnf_vif_send_data_high_pri(struct work_struct *work)\n{\n\tstruct qtnf_vif *vif =\n\t\tcontainer_of(work, struct qtnf_vif, high_pri_tx_work);\n\tstruct sk_buff *skb;\n\n\tif (!vif->netdev ||\n\t    vif->wdev.iftype == NL80211_IFTYPE_UNSPECIFIED)\n\t\treturn;\n\n\twhile ((skb = skb_dequeue(&vif->high_pri_tx_queue))) {\n\t\tqtnf_cmd_send_frame(vif, 0, QLINK_FRAME_TX_FLAG_8023,\n\t\t\t\t    0, skb->data, skb->len);\n\t\tdev_kfree_skb_any(skb);\n\t}\n}\n\nstatic struct qtnf_wmac *qtnf_core_mac_alloc(struct qtnf_bus *bus,\n\t\t\t\t\t     unsigned int macid)\n{\n\tstruct platform_device *pdev = NULL;\n\tstruct qtnf_wmac *mac;\n\tstruct qtnf_vif *vif;\n\tstruct wiphy *wiphy;\n\tunsigned int i;\n\n\tif (bus->hw_info.num_mac > 1) {\n\t\tpdev = platform_device_register_data(bus->dev,\n\t\t\t\t\t\t     dev_name(bus->dev),\n\t\t\t\t\t\t     macid, NULL, 0);\n\t\tif (IS_ERR(pdev))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\twiphy = qtnf_wiphy_allocate(bus, pdev);\n\tif (!wiphy) {\n\t\tif (pdev)\n\t\t\tplatform_device_unregister(pdev);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tmac = wiphy_priv(wiphy);\n\n\tmac->macid = macid;\n\tmac->pdev = pdev;\n\tmac->bus = bus;\n\tmutex_init(&mac->mac_lock);\n\tINIT_DELAYED_WORK(&mac->scan_timeout, qtnf_mac_scan_timeout);\n\n\tfor (i = 0; i < QTNF_MAX_INTF; i++) {\n\t\tvif = &mac->iflist[i];\n\n\t\tmemset(vif, 0, sizeof(*vif));\n\t\tvif->wdev.iftype = NL80211_IFTYPE_UNSPECIFIED;\n\t\tvif->mac = mac;\n\t\tvif->vifid = i;\n\t\tqtnf_sta_list_init(&vif->sta_list);\n\t\tINIT_WORK(&vif->high_pri_tx_work, qtnf_vif_send_data_high_pri);\n\t\tskb_queue_head_init(&vif->high_pri_tx_queue);\n\t}\n\n\tqtnf_mac_init_primary_intf(mac);\n\tbus->mac[macid] = mac;\n\n\treturn mac;\n}\n\nstatic const struct ethtool_ops qtnf_ethtool_ops = {\n\t.get_drvinfo = cfg80211_get_drvinfo,\n};\n\nint qtnf_core_net_attach(struct qtnf_wmac *mac, struct qtnf_vif *vif,\n\t\t\t const char *name, unsigned char name_assign_type)\n{\n\tstruct wiphy *wiphy = priv_to_wiphy(mac);\n\tstruct net_device *dev;\n\tvoid *qdev_vif;\n\tint ret;\n\n\tdev = alloc_netdev_mqs(sizeof(struct qtnf_vif *), name,\n\t\t\t       name_assign_type, ether_setup, 1, 1);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tvif->netdev = dev;\n\n\tdev->netdev_ops = &qtnf_netdev_ops;\n\tdev->needs_free_netdev = true;\n\tdev_net_set(dev, wiphy_net(wiphy));\n\tdev->ieee80211_ptr = &vif->wdev;\n\teth_hw_addr_set(dev, vif->mac_addr);\n\tdev->flags |= IFF_BROADCAST | IFF_MULTICAST;\n\tdev->watchdog_timeo = QTNF_DEF_WDOG_TIMEOUT;\n\tdev->tx_queue_len = 100;\n\tdev->ethtool_ops = &qtnf_ethtool_ops;\n\n\tif (qtnf_hwcap_is_set(&mac->bus->hw_info, QLINK_HW_CAPAB_HW_BRIDGE))\n\t\tdev->needed_tailroom = sizeof(struct qtnf_frame_meta_info);\n\n\tqdev_vif = netdev_priv(dev);\n\t*((void **)qdev_vif) = vif;\n\n\tSET_NETDEV_DEV(dev, wiphy_dev(wiphy));\n\n\tret = cfg80211_register_netdevice(dev);\n\tif (ret) {\n\t\tfree_netdev(dev);\n\t\tvif->netdev = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic void qtnf_core_mac_detach(struct qtnf_bus *bus, unsigned int macid)\n{\n\tstruct qtnf_wmac *mac;\n\tstruct wiphy *wiphy;\n\tstruct qtnf_vif *vif;\n\tunsigned int i;\n\tenum nl80211_band band;\n\n\tmac = bus->mac[macid];\n\n\tif (!mac)\n\t\treturn;\n\n\twiphy = priv_to_wiphy(mac);\n\n\tfor (i = 0; i < QTNF_MAX_INTF; i++) {\n\t\tvif = &mac->iflist[i];\n\t\trtnl_lock();\n\t\tif (vif->netdev &&\n\t\t    vif->wdev.iftype != NL80211_IFTYPE_UNSPECIFIED) {\n\t\t\tqtnf_virtual_intf_cleanup(vif->netdev);\n\t\t\tqtnf_del_virtual_intf(wiphy, &vif->wdev);\n\t\t}\n\t\trtnl_unlock();\n\t\tqtnf_sta_list_free(&vif->sta_list);\n\t}\n\n\tif (mac->wiphy_registered)\n\t\twiphy_unregister(wiphy);\n\n\tfor (band = NL80211_BAND_2GHZ; band < NUM_NL80211_BANDS; ++band) {\n\t\tif (!wiphy->bands[band])\n\t\t\tcontinue;\n\n\t\tkfree(wiphy->bands[band]->iftype_data);\n\t\twiphy->bands[band]->n_iftype_data = 0;\n\n\t\tkfree(wiphy->bands[band]->channels);\n\t\twiphy->bands[band]->n_channels = 0;\n\n\t\tkfree(wiphy->bands[band]);\n\t\twiphy->bands[band] = NULL;\n\t}\n\n\tplatform_device_unregister(mac->pdev);\n\tqtnf_mac_iface_comb_free(mac);\n\tqtnf_mac_ext_caps_free(mac);\n\tkfree(mac->macinfo.wowlan);\n\tkfree(mac->rd);\n\tmac->rd = NULL;\n\twiphy_free(wiphy);\n\tbus->mac[macid] = NULL;\n}\n\nstatic int qtnf_core_mac_attach(struct qtnf_bus *bus, unsigned int macid)\n{\n\tstruct qtnf_wmac *mac;\n\tstruct qtnf_vif *vif;\n\tint ret;\n\n\tif (!(bus->hw_info.mac_bitmap & BIT(macid))) {\n\t\tpr_info(\"MAC%u is not active in FW\\n\", macid);\n\t\treturn 0;\n\t}\n\n\tmac = qtnf_core_mac_alloc(bus, macid);\n\tif (IS_ERR(mac)) {\n\t\tpr_err(\"MAC%u allocation failed\\n\", macid);\n\t\treturn PTR_ERR(mac);\n\t}\n\n\tvif = qtnf_mac_get_base_vif(mac);\n\tif (!vif) {\n\t\tpr_err(\"MAC%u: primary VIF is not ready\\n\", macid);\n\t\tret = -EFAULT;\n\t\tgoto error;\n\t}\n\n\tret = qtnf_cmd_send_add_intf(vif, vif->wdev.iftype,\n\t\t\t\t     vif->wdev.use_4addr, vif->mac_addr);\n\tif (ret) {\n\t\tpr_err(\"MAC%u: failed to add VIF\\n\", macid);\n\t\tgoto error;\n\t}\n\n\tret = qtnf_cmd_get_mac_info(mac);\n\tif (ret) {\n\t\tpr_err(\"MAC%u: failed to get MAC info\\n\", macid);\n\t\tgoto error_del_vif;\n\t}\n\n\t \n\tif (is_zero_ether_addr(mac->bus->hw_id))\n\t\tether_addr_copy(mac->bus->hw_id, mac->macaddr);\n\n\tret = qtnf_mac_init_bands(mac);\n\tif (ret) {\n\t\tpr_err(\"MAC%u: failed to init bands\\n\", macid);\n\t\tgoto error_del_vif;\n\t}\n\n\tret = qtnf_wiphy_register(&bus->hw_info, mac);\n\tif (ret) {\n\t\tpr_err(\"MAC%u: wiphy registration failed\\n\", macid);\n\t\tgoto error_del_vif;\n\t}\n\n\tmac->wiphy_registered = 1;\n\n\trtnl_lock();\n\twiphy_lock(priv_to_wiphy(mac));\n\tret = qtnf_core_net_attach(mac, vif, \"wlan%d\", NET_NAME_ENUM);\n\twiphy_unlock(priv_to_wiphy(mac));\n\trtnl_unlock();\n\n\tif (ret) {\n\t\tpr_err(\"MAC%u: failed to attach netdev\\n\", macid);\n\t\tgoto error_del_vif;\n\t}\n\n\tif (qtnf_hwcap_is_set(&bus->hw_info, QLINK_HW_CAPAB_HW_BRIDGE)) {\n\t\tret = qtnf_cmd_netdev_changeupper(vif, vif->netdev->ifindex);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tpr_debug(\"MAC%u initialized\\n\", macid);\n\n\treturn 0;\n\nerror_del_vif:\n\tqtnf_cmd_send_del_intf(vif);\n\tvif->wdev.iftype = NL80211_IFTYPE_UNSPECIFIED;\nerror:\n\tqtnf_core_mac_detach(bus, macid);\n\treturn ret;\n}\n\nbool qtnf_netdev_is_qtn(const struct net_device *ndev)\n{\n\treturn ndev->netdev_ops == &qtnf_netdev_ops;\n}\n\nstatic int qtnf_check_br_ports(struct net_device *dev,\n\t\t\t       struct netdev_nested_priv *priv)\n{\n\tstruct net_device *ndev = (struct net_device *)priv->data;\n\n\tif (dev != ndev && netdev_port_same_parent_id(dev, ndev))\n\t\treturn -ENOTSUPP;\n\n\treturn 0;\n}\n\nstatic int qtnf_core_netdevice_event(struct notifier_block *nb,\n\t\t\t\t     unsigned long event, void *ptr)\n{\n\tstruct net_device *ndev = netdev_notifier_info_to_dev(ptr);\n\tconst struct netdev_notifier_changeupper_info *info;\n\tstruct netdev_nested_priv priv = {\n\t\t.data = (void *)ndev,\n\t};\n\tstruct net_device *brdev;\n\tstruct qtnf_vif *vif;\n\tstruct qtnf_bus *bus;\n\tint br_domain;\n\tint ret = 0;\n\n\tif (!qtnf_netdev_is_qtn(ndev))\n\t\treturn NOTIFY_DONE;\n\n\tif (!net_eq(dev_net(ndev), &init_net))\n\t\treturn NOTIFY_OK;\n\n\tvif = qtnf_netdev_get_priv(ndev);\n\tbus = vif->mac->bus;\n\n\tswitch (event) {\n\tcase NETDEV_CHANGEUPPER:\n\t\tinfo = ptr;\n\t\tbrdev = info->upper_dev;\n\n\t\tif (!netif_is_bridge_master(brdev))\n\t\t\tbreak;\n\n\t\tpr_debug(\"[VIF%u.%u] change bridge: %s %s\\n\",\n\t\t\t vif->mac->macid, vif->vifid, netdev_name(brdev),\n\t\t\t info->linking ? \"add\" : \"del\");\n\n\t\tif (IS_ENABLED(CONFIG_NET_SWITCHDEV) &&\n\t\t    qtnf_hwcap_is_set(&bus->hw_info,\n\t\t\t\t      QLINK_HW_CAPAB_HW_BRIDGE)) {\n\t\t\tif (info->linking)\n\t\t\t\tbr_domain = brdev->ifindex;\n\t\t\telse\n\t\t\t\tbr_domain = ndev->ifindex;\n\n\t\t\tret = qtnf_cmd_netdev_changeupper(vif, br_domain);\n\t\t} else {\n\t\t\tret = netdev_walk_all_lower_dev(brdev,\n\t\t\t\t\t\t\tqtnf_check_br_ports,\n\t\t\t\t\t\t\t&priv);\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn notifier_from_errno(ret);\n}\n\nint qtnf_core_attach(struct qtnf_bus *bus)\n{\n\tunsigned int i;\n\tint ret;\n\n\tqtnf_trans_init(bus);\n\tqtnf_bus_data_rx_start(bus);\n\n\tbus->workqueue = alloc_ordered_workqueue(\"QTNF_BUS\", 0);\n\tif (!bus->workqueue) {\n\t\tpr_err(\"failed to alloc main workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tbus->hprio_workqueue = alloc_workqueue(\"QTNF_HPRI\", WQ_HIGHPRI, 0);\n\tif (!bus->hprio_workqueue) {\n\t\tpr_err(\"failed to alloc high prio workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tINIT_WORK(&bus->event_work, qtnf_event_work_handler);\n\n\tret = qtnf_cmd_send_init_fw(bus);\n\tif (ret) {\n\t\tpr_err(\"failed to init FW: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tif (QLINK_VER_MAJOR(bus->hw_info.ql_proto_ver) !=\n\t    QLINK_PROTO_VER_MAJOR) {\n\t\tpr_err(\"qlink driver vs FW version mismatch: %u vs %u\\n\",\n\t\t       QLINK_PROTO_VER_MAJOR,\n\t\t       QLINK_VER_MAJOR(bus->hw_info.ql_proto_ver));\n\t\tret = -EPROTONOSUPPORT;\n\t\tgoto error;\n\t}\n\n\tbus->fw_state = QTNF_FW_STATE_ACTIVE;\n\tret = qtnf_cmd_get_hw_info(bus);\n\tif (ret) {\n\t\tpr_err(\"failed to get HW info: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tif (qtnf_hwcap_is_set(&bus->hw_info, QLINK_HW_CAPAB_HW_BRIDGE) &&\n\t    bus->bus_ops->data_tx_use_meta_set)\n\t\tbus->bus_ops->data_tx_use_meta_set(bus, true);\n\n\tif (bus->hw_info.num_mac > QTNF_MAX_MAC) {\n\t\tpr_err(\"no support for number of MACs=%u\\n\",\n\t\t       bus->hw_info.num_mac);\n\t\tret = -ERANGE;\n\t\tgoto error;\n\t}\n\n\tfor (i = 0; i < bus->hw_info.num_mac; i++) {\n\t\tret = qtnf_core_mac_attach(bus, i);\n\n\t\tif (ret) {\n\t\t\tpr_err(\"MAC%u: attach failed: %d\\n\", i, ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tbus->netdev_nb.notifier_call = qtnf_core_netdevice_event;\n\tret = register_netdevice_notifier(&bus->netdev_nb);\n\tif (ret) {\n\t\tpr_err(\"failed to register netdev notifier: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tbus->fw_state = QTNF_FW_STATE_RUNNING;\n\treturn 0;\n\nerror:\n\tqtnf_core_detach(bus);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(qtnf_core_attach);\n\nvoid qtnf_core_detach(struct qtnf_bus *bus)\n{\n\tunsigned int macid;\n\n\tunregister_netdevice_notifier(&bus->netdev_nb);\n\tqtnf_bus_data_rx_stop(bus);\n\n\tfor (macid = 0; macid < QTNF_MAX_MAC; macid++)\n\t\tqtnf_core_mac_detach(bus, macid);\n\n\tif (qtnf_fw_is_up(bus))\n\t\tqtnf_cmd_send_deinit_fw(bus);\n\n\tbus->fw_state = QTNF_FW_STATE_DETACHED;\n\n\tif (bus->workqueue) {\n\t\tdestroy_workqueue(bus->workqueue);\n\t\tbus->workqueue = NULL;\n\t}\n\n\tif (bus->hprio_workqueue) {\n\t\tdestroy_workqueue(bus->hprio_workqueue);\n\t\tbus->hprio_workqueue = NULL;\n\t}\n\n\tqtnf_trans_free(bus);\n}\nEXPORT_SYMBOL_GPL(qtnf_core_detach);\n\nstatic inline int qtnf_is_frame_meta_magic_valid(struct qtnf_frame_meta_info *m)\n{\n\treturn m->magic_s == HBM_FRAME_META_MAGIC_PATTERN_S &&\n\t\tm->magic_e == HBM_FRAME_META_MAGIC_PATTERN_E;\n}\n\nstruct net_device *qtnf_classify_skb(struct qtnf_bus *bus, struct sk_buff *skb)\n{\n\tstruct qtnf_frame_meta_info *meta;\n\tstruct net_device *ndev = NULL;\n\tstruct qtnf_wmac *mac;\n\tstruct qtnf_vif *vif;\n\n\tif (unlikely(bus->fw_state != QTNF_FW_STATE_RUNNING))\n\t\treturn NULL;\n\n\tmeta = (struct qtnf_frame_meta_info *)\n\t\t(skb_tail_pointer(skb) - sizeof(*meta));\n\n\tif (unlikely(!qtnf_is_frame_meta_magic_valid(meta))) {\n\t\tpr_err_ratelimited(\"invalid magic 0x%x:0x%x\\n\",\n\t\t\t\t   meta->magic_s, meta->magic_e);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(meta->macid >= QTNF_MAX_MAC)) {\n\t\tpr_err_ratelimited(\"invalid mac(%u)\\n\", meta->macid);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(meta->ifidx >= QTNF_MAX_INTF)) {\n\t\tpr_err_ratelimited(\"invalid vif(%u)\\n\", meta->ifidx);\n\t\tgoto out;\n\t}\n\n\tmac = bus->mac[meta->macid];\n\n\tif (unlikely(!mac)) {\n\t\tpr_err_ratelimited(\"mac(%d) does not exist\\n\", meta->macid);\n\t\tgoto out;\n\t}\n\n\tvif = &mac->iflist[meta->ifidx];\n\n\tif (unlikely(vif->wdev.iftype == NL80211_IFTYPE_UNSPECIFIED)) {\n\t\tpr_err_ratelimited(\"vif(%u) does not exists\\n\", meta->ifidx);\n\t\tgoto out;\n\t}\n\n\tndev = vif->netdev;\n\n\tif (unlikely(!ndev)) {\n\t\tpr_err_ratelimited(\"netdev for wlan%u.%u does not exists\\n\",\n\t\t\t\t   meta->macid, meta->ifidx);\n\t\tgoto out;\n\t}\n\n\t__skb_trim(skb, skb->len - sizeof(*meta));\n\t \n\tqtnfmac_switch_mark_skb_flooded(skb);\n\nout:\n\treturn ndev;\n}\nEXPORT_SYMBOL_GPL(qtnf_classify_skb);\n\nvoid qtnf_wake_all_queues(struct net_device *ndev)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(ndev);\n\tstruct qtnf_wmac *mac;\n\tstruct qtnf_bus *bus;\n\tint macid;\n\tint i;\n\n\tif (unlikely(!vif || !vif->mac || !vif->mac->bus))\n\t\treturn;\n\n\tbus = vif->mac->bus;\n\n\tfor (macid = 0; macid < QTNF_MAX_MAC; macid++) {\n\t\tif (!(bus->hw_info.mac_bitmap & BIT(macid)))\n\t\t\tcontinue;\n\n\t\tmac = bus->mac[macid];\n\t\tfor (i = 0; i < QTNF_MAX_INTF; i++) {\n\t\t\tvif = &mac->iflist[i];\n\t\t\tif (vif->netdev && netif_queue_stopped(vif->netdev))\n\t\t\t\tnetif_tx_wake_all_queues(vif->netdev);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(qtnf_wake_all_queues);\n\nstruct dentry *qtnf_get_debugfs_dir(void)\n{\n\treturn qtnf_debugfs_dir;\n}\nEXPORT_SYMBOL_GPL(qtnf_get_debugfs_dir);\n\nstatic int __init qtnf_core_register(void)\n{\n\tqtnf_debugfs_dir = debugfs_create_dir(KBUILD_MODNAME, NULL);\n\n\tif (IS_ERR(qtnf_debugfs_dir))\n\t\tqtnf_debugfs_dir = NULL;\n\n\treturn 0;\n}\n\nstatic void __exit qtnf_core_exit(void)\n{\n\tdebugfs_remove(qtnf_debugfs_dir);\n}\n\nmodule_init(qtnf_core_register);\nmodule_exit(qtnf_core_exit);\n\nMODULE_AUTHOR(\"Quantenna Communications\");\nMODULE_DESCRIPTION(\"Quantenna 802.11 wireless LAN FullMAC driver.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}