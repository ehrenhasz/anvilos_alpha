{
  "module_name": "qlink_util.h",
  "hash_id": "942fe4540e5d36431fbc9b51fbde1fff90c9d4a81aef50b1110800149f843304",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/quantenna/qtnfmac/qlink_util.h",
  "human_readable_source": " \n \n\n#ifndef _QTN_FMAC_QLINK_UTIL_H_\n#define _QTN_FMAC_QLINK_UTIL_H_\n\n#include <linux/types.h>\n#include <linux/skbuff.h>\n#include <net/cfg80211.h>\n\n#include \"qlink.h\"\n\nstatic inline void\nqtnf_cmd_skb_put_buffer(struct sk_buff *skb, const u8 *buf_src, size_t len)\n{\n\tskb_put_data(skb, buf_src, len);\n}\n\nstatic inline void qtnf_cmd_skb_put_tlv_arr(struct sk_buff *skb,\n\t\t\t\t\t    u16 tlv_id, const u8 arr[],\n\t\t\t\t\t    size_t arr_len)\n{\n\tstruct qlink_tlv_hdr *hdr;\n\n\thdr = skb_put(skb, sizeof(*hdr) + round_up(arr_len, QLINK_ALIGN));\n\thdr->type = cpu_to_le16(tlv_id);\n\thdr->len = cpu_to_le16(arr_len);\n\tmemcpy(hdr->val, arr, arr_len);\n}\n\nstatic inline void qtnf_cmd_skb_put_tlv_u32(struct sk_buff *skb,\n\t\t\t\t\t    u16 tlv_id, u32 value)\n{\n\tstruct qlink_tlv_hdr *hdr = skb_put(skb, sizeof(*hdr) + sizeof(value));\n\t__le32 tmp = cpu_to_le32(value);\n\n\thdr->type = cpu_to_le16(tlv_id);\n\thdr->len = cpu_to_le16(sizeof(value));\n\tmemcpy(hdr->val, &tmp, sizeof(tmp));\n}\n\nu16 qlink_iface_type_to_nl_mask(u16 qlink_type);\nu8 qlink_chan_width_mask_to_nl(u16 qlink_mask);\nvoid qlink_chandef_q2cfg(struct wiphy *wiphy,\n\t\t\t const struct qlink_chandef *qch,\n\t\t\t struct cfg80211_chan_def *chdef);\nvoid qlink_chandef_cfg2q(const struct cfg80211_chan_def *chdef,\n\t\t\t struct qlink_chandef *qch);\nenum qlink_hidden_ssid qlink_hidden_ssid_nl2q(enum nl80211_hidden_ssid nl_val);\nbool qtnf_utils_is_bit_set(const u8 *arr, unsigned int bit,\n\t\t\t   unsigned int arr_max_len);\nvoid qlink_acl_data_cfg2q(const struct cfg80211_acl_data *acl,\n\t\t\t  struct qlink_acl_data *qacl);\nenum qlink_band qlink_utils_band_cfg2q(enum nl80211_band band);\nenum qlink_dfs_state qlink_utils_dfs_state_cfg2q(enum nl80211_dfs_state state);\nu32 qlink_utils_chflags_cfg2q(u32 cfgflags);\nvoid qlink_utils_regrule_q2nl(struct ieee80211_reg_rule *rule,\n\t\t\t      const struct qlink_tlv_reg_rule *tlv_rule);\n\n#define qlink_for_each_tlv(_tlv, _start, _datalen)\t\t\t\\\n\tfor (_tlv = (const struct qlink_tlv_hdr *)(_start);\t\t\\\n\t     (const u8 *)(_start) + (_datalen) - (const u8 *)_tlv >=\t\\\n\t\t(int)sizeof(*_tlv) &&\t\t\t\t\t\\\n\t     (const u8 *)(_start) + (_datalen) - (const u8 *)_tlv >=\t\\\n\t\t(int)sizeof(*_tlv) + le16_to_cpu(_tlv->len);\t\t\\\n\t     _tlv = (const struct qlink_tlv_hdr *)(_tlv->val +\t\t\\\n\t\tround_up(le16_to_cpu(_tlv->len), QLINK_ALIGN)))\n\n#define qlink_tlv_parsing_ok(_tlv_last, _start, _datalen)\t\\\n\t((const u8 *)(_tlv_last) == \\\n\t\t(const u8 *)(_start) + round_up(_datalen, QLINK_ALIGN))\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}