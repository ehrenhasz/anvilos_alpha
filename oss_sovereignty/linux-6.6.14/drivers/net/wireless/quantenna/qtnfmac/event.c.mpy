{
  "module_name": "event.c",
  "hash_id": "9ee36488f6cefddf33863b66cc30b5ae51d61c157f04fc122f9f58a8f9501a81",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/quantenna/qtnfmac/event.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/nospec.h>\n\n#include \"cfg80211.h\"\n#include \"core.h\"\n#include \"qlink.h\"\n#include \"bus.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"event.h\"\n#include \"qlink_util.h\"\n\nstatic int\nqtnf_event_handle_sta_assoc(struct qtnf_wmac *mac, struct qtnf_vif *vif,\n\t\t\t    const struct qlink_event_sta_assoc *sta_assoc,\n\t\t\t    u16 len)\n{\n\tconst u8 *sta_addr;\n\tu16 frame_control;\n\tstruct station_info *sinfo;\n\tsize_t payload_len;\n\tu16 tlv_type;\n\tu16 tlv_value_len;\n\tconst struct qlink_tlv_hdr *tlv;\n\tint ret = 0;\n\n\tif (unlikely(len < sizeof(*sta_assoc))) {\n\t\tpr_err(\"VIF%u.%u: payload is too short (%u < %zu)\\n\",\n\t\t       mac->macid, vif->vifid, len, sizeof(*sta_assoc));\n\t\treturn -EINVAL;\n\t}\n\n\tif (vif->wdev.iftype != NL80211_IFTYPE_AP) {\n\t\tpr_err(\"VIF%u.%u: STA_ASSOC event when not in AP mode\\n\",\n\t\t       mac->macid, vif->vifid);\n\t\treturn -EPROTO;\n\t}\n\n\tsinfo = kzalloc(sizeof(*sinfo), GFP_KERNEL);\n\tif (!sinfo)\n\t\treturn -ENOMEM;\n\n\tsta_addr = sta_assoc->sta_addr;\n\tframe_control = le16_to_cpu(sta_assoc->frame_control);\n\n\tpr_debug(\"VIF%u.%u: MAC:%pM FC:%x\\n\", mac->macid, vif->vifid, sta_addr,\n\t\t frame_control);\n\n\tqtnf_sta_list_add(vif, sta_addr);\n\n\tsinfo->assoc_req_ies = NULL;\n\tsinfo->assoc_req_ies_len = 0;\n\tsinfo->generation = vif->generation;\n\n\tpayload_len = len - sizeof(*sta_assoc);\n\n\tqlink_for_each_tlv(tlv, sta_assoc->ies, payload_len) {\n\t\ttlv_type = le16_to_cpu(tlv->type);\n\t\ttlv_value_len = le16_to_cpu(tlv->len);\n\n\t\tif (tlv_type == QTN_TLV_ID_IE_SET) {\n\t\t\tconst struct qlink_tlv_ie_set *ie_set;\n\t\t\tunsigned int ie_len;\n\n\t\t\tif (tlv_value_len <\n\t\t\t    (sizeof(*ie_set) - sizeof(ie_set->hdr))) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tie_set = (const struct qlink_tlv_ie_set *)tlv;\n\t\t\tie_len = tlv_value_len -\n\t\t\t\t(sizeof(*ie_set) - sizeof(ie_set->hdr));\n\n\t\t\tif (ie_set->type == QLINK_IE_SET_ASSOC_REQ && ie_len) {\n\t\t\t\tsinfo->assoc_req_ies = ie_set->ie_data;\n\t\t\t\tsinfo->assoc_req_ies_len = ie_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!qlink_tlv_parsing_ok(tlv, sta_assoc->ies, payload_len)) {\n\t\tpr_err(\"Malformed TLV buffer\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcfg80211_new_sta(vif->netdev, sta_assoc->sta_addr, sinfo,\n\t\t\t GFP_KERNEL);\n\nout:\n\tkfree(sinfo);\n\treturn ret;\n}\n\nstatic int\nqtnf_event_handle_sta_deauth(struct qtnf_wmac *mac, struct qtnf_vif *vif,\n\t\t\t     const struct qlink_event_sta_deauth *sta_deauth,\n\t\t\t     u16 len)\n{\n\tconst u8 *sta_addr;\n\tu16 reason;\n\n\tif (unlikely(len < sizeof(*sta_deauth))) {\n\t\tpr_err(\"VIF%u.%u: payload is too short (%u < %zu)\\n\",\n\t\t       mac->macid, vif->vifid, len,\n\t\t       sizeof(struct qlink_event_sta_deauth));\n\t\treturn -EINVAL;\n\t}\n\n\tif (vif->wdev.iftype != NL80211_IFTYPE_AP) {\n\t\tpr_err(\"VIF%u.%u: STA_DEAUTH event when not in AP mode\\n\",\n\t\t       mac->macid, vif->vifid);\n\t\treturn -EPROTO;\n\t}\n\n\tsta_addr = sta_deauth->sta_addr;\n\treason = le16_to_cpu(sta_deauth->reason);\n\n\tpr_debug(\"VIF%u.%u: MAC:%pM reason:%x\\n\", mac->macid, vif->vifid,\n\t\t sta_addr, reason);\n\n\tif (qtnf_sta_list_del(vif, sta_addr))\n\t\tcfg80211_del_sta(vif->netdev, sta_deauth->sta_addr,\n\t\t\t\t GFP_KERNEL);\n\n\treturn 0;\n}\n\nstatic int\nqtnf_event_handle_bss_join(struct qtnf_vif *vif,\n\t\t\t   const struct qlink_event_bss_join *join_info,\n\t\t\t   u16 len)\n{\n\tstruct wiphy *wiphy = priv_to_wiphy(vif->mac);\n\tenum ieee80211_statuscode status = le16_to_cpu(join_info->status);\n\tstruct cfg80211_chan_def chandef;\n\tstruct cfg80211_bss *bss = NULL;\n\tu8 *ie = NULL;\n\tsize_t payload_len;\n\tu16 tlv_type;\n\tu16 tlv_value_len;\n\tconst struct qlink_tlv_hdr *tlv;\n\tconst u8 *rsp_ies = NULL;\n\tsize_t rsp_ies_len = 0;\n\n\tif (unlikely(len < sizeof(*join_info))) {\n\t\tpr_err(\"VIF%u.%u: payload is too short (%u < %zu)\\n\",\n\t\t       vif->mac->macid, vif->vifid, len,\n\t\t       sizeof(struct qlink_event_bss_join));\n\t\treturn -EINVAL;\n\t}\n\n\tif (vif->wdev.iftype != NL80211_IFTYPE_STATION) {\n\t\tpr_err(\"VIF%u.%u: BSS_JOIN event when not in STA mode\\n\",\n\t\t       vif->mac->macid, vif->vifid);\n\t\treturn -EPROTO;\n\t}\n\n\tpr_debug(\"VIF%u.%u: BSSID:%pM chan:%u status:%u\\n\",\n\t\t vif->mac->macid, vif->vifid, join_info->bssid,\n\t\t le16_to_cpu(join_info->chan.chan.center_freq), status);\n\n\tif (status != WLAN_STATUS_SUCCESS)\n\t\tgoto done;\n\n\tqlink_chandef_q2cfg(wiphy, &join_info->chan, &chandef);\n\tif (!cfg80211_chandef_valid(&chandef)) {\n\t\tpr_warn(\"MAC%u.%u: bad channel freq=%u cf1=%u cf2=%u bw=%u\\n\",\n\t\t\tvif->mac->macid, vif->vifid,\n\t\t\tchandef.chan ? chandef.chan->center_freq : 0,\n\t\t\tchandef.center_freq1,\n\t\t\tchandef.center_freq2,\n\t\t\tchandef.width);\n\t\tstatus = WLAN_STATUS_UNSPECIFIED_FAILURE;\n\t\tgoto done;\n\t}\n\n\tbss = cfg80211_get_bss(wiphy, chandef.chan, join_info->bssid,\n\t\t\t       NULL, 0, IEEE80211_BSS_TYPE_ESS,\n\t\t\t       IEEE80211_PRIVACY_ANY);\n\tif (!bss) {\n\t\tpr_warn(\"VIF%u.%u: add missing BSS:%pM chan:%u\\n\",\n\t\t\tvif->mac->macid, vif->vifid,\n\t\t\tjoin_info->bssid, chandef.chan->hw_value);\n\n\t\tif (!vif->wdev.u.client.ssid_len) {\n\t\t\tpr_warn(\"VIF%u.%u: SSID unknown for BSS:%pM\\n\",\n\t\t\t\tvif->mac->macid, vif->vifid,\n\t\t\t\tjoin_info->bssid);\n\t\t\tstatus = WLAN_STATUS_UNSPECIFIED_FAILURE;\n\t\t\tgoto done;\n\t\t}\n\n\t\tie = kzalloc(2 + vif->wdev.u.client.ssid_len, GFP_KERNEL);\n\t\tif (!ie) {\n\t\t\tpr_warn(\"VIF%u.%u: IE alloc failed for BSS:%pM\\n\",\n\t\t\t\tvif->mac->macid, vif->vifid,\n\t\t\t\tjoin_info->bssid);\n\t\t\tstatus = WLAN_STATUS_UNSPECIFIED_FAILURE;\n\t\t\tgoto done;\n\t\t}\n\n\t\tie[0] = WLAN_EID_SSID;\n\t\tie[1] = vif->wdev.u.client.ssid_len;\n\t\tmemcpy(ie + 2, vif->wdev.u.client.ssid,\n\t\t       vif->wdev.u.client.ssid_len);\n\n\t\tbss = cfg80211_inform_bss(wiphy, chandef.chan,\n\t\t\t\t\t  CFG80211_BSS_FTYPE_UNKNOWN,\n\t\t\t\t\t  join_info->bssid, 0,\n\t\t\t\t\t  WLAN_CAPABILITY_ESS, 100,\n\t\t\t\t\t  ie, 2 + vif->wdev.u.client.ssid_len,\n\t\t\t\t\t  0, GFP_KERNEL);\n\t\tif (!bss) {\n\t\t\tpr_warn(\"VIF%u.%u: can't connect to unknown BSS: %pM\\n\",\n\t\t\t\tvif->mac->macid, vif->vifid,\n\t\t\t\tjoin_info->bssid);\n\t\t\tstatus = WLAN_STATUS_UNSPECIFIED_FAILURE;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tpayload_len = len - sizeof(*join_info);\n\n\tqlink_for_each_tlv(tlv, join_info->ies, payload_len) {\n\t\ttlv_type = le16_to_cpu(tlv->type);\n\t\ttlv_value_len = le16_to_cpu(tlv->len);\n\n\t\tif (tlv_type == QTN_TLV_ID_IE_SET) {\n\t\t\tconst struct qlink_tlv_ie_set *ie_set;\n\t\t\tunsigned int ie_len;\n\n\t\t\tif (tlv_value_len <\n\t\t\t    (sizeof(*ie_set) - sizeof(ie_set->hdr))) {\n\t\t\t\tpr_warn(\"invalid IE_SET TLV\\n\");\n\t\t\t\tstatus = WLAN_STATUS_UNSPECIFIED_FAILURE;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tie_set = (const struct qlink_tlv_ie_set *)tlv;\n\t\t\tie_len = tlv_value_len -\n\t\t\t\t(sizeof(*ie_set) - sizeof(ie_set->hdr));\n\n\t\t\tswitch (ie_set->type) {\n\t\t\tcase QLINK_IE_SET_ASSOC_RESP:\n\t\t\t\tif (ie_len) {\n\t\t\t\t\trsp_ies = ie_set->ie_data;\n\t\t\t\t\trsp_ies_len = ie_len;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_warn(\"unexpected IE type: %u\\n\",\n\t\t\t\t\tie_set->type);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!qlink_tlv_parsing_ok(tlv, join_info->ies, payload_len))\n\t\tpr_warn(\"Malformed TLV buffer\\n\");\ndone:\n\tcfg80211_connect_result(vif->netdev, join_info->bssid, NULL, 0, rsp_ies,\n\t\t\t\trsp_ies_len, status, GFP_KERNEL);\n\tif (bss) {\n\t\tif (!ether_addr_equal(vif->bssid, join_info->bssid))\n\t\t\tether_addr_copy(vif->bssid, join_info->bssid);\n\t\tcfg80211_put_bss(wiphy, bss);\n\t}\n\n\tif (status == WLAN_STATUS_SUCCESS)\n\t\tnetif_carrier_on(vif->netdev);\n\n\tkfree(ie);\n\treturn 0;\n}\n\nstatic int\nqtnf_event_handle_bss_leave(struct qtnf_vif *vif,\n\t\t\t    const struct qlink_event_bss_leave *leave_info,\n\t\t\t    u16 len)\n{\n\tif (unlikely(len < sizeof(*leave_info))) {\n\t\tpr_err(\"VIF%u.%u: payload is too short (%u < %zu)\\n\",\n\t\t       vif->mac->macid, vif->vifid, len,\n\t\t       sizeof(struct qlink_event_bss_leave));\n\t\treturn -EINVAL;\n\t}\n\n\tif (vif->wdev.iftype != NL80211_IFTYPE_STATION) {\n\t\tpr_err(\"VIF%u.%u: BSS_LEAVE event when not in STA mode\\n\",\n\t\t       vif->mac->macid, vif->vifid);\n\t\treturn -EPROTO;\n\t}\n\n\tpr_debug(\"VIF%u.%u: disconnected\\n\", vif->mac->macid, vif->vifid);\n\n\tcfg80211_disconnected(vif->netdev, le16_to_cpu(leave_info->reason),\n\t\t\t      NULL, 0, 0, GFP_KERNEL);\n\tnetif_carrier_off(vif->netdev);\n\n\treturn 0;\n}\n\nstatic int\nqtnf_event_handle_mgmt_received(struct qtnf_vif *vif,\n\t\t\t\tconst struct qlink_event_rxmgmt *rxmgmt,\n\t\t\t\tu16 len)\n{\n\tconst size_t min_len = sizeof(*rxmgmt) +\n\t\t\t       sizeof(struct ieee80211_hdr_3addr);\n\tconst struct ieee80211_hdr_3addr *frame = (void *)rxmgmt->frame_data;\n\tconst u16 frame_len = len - sizeof(*rxmgmt);\n\tenum nl80211_rxmgmt_flags flags = 0;\n\n\tif (unlikely(len < min_len)) {\n\t\tpr_err(\"VIF%u.%u: payload is too short (%u < %zu)\\n\",\n\t\t       vif->mac->macid, vif->vifid, len, min_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(rxmgmt->flags) & QLINK_RXMGMT_FLAG_ANSWERED)\n\t\tflags |= NL80211_RXMGMT_FLAG_ANSWERED;\n\n\tpr_debug(\"%s LEN:%u FC:%.4X SA:%pM\\n\", vif->netdev->name, frame_len,\n\t\t le16_to_cpu(frame->frame_control), frame->addr2);\n\n\tcfg80211_rx_mgmt(&vif->wdev, le32_to_cpu(rxmgmt->freq), rxmgmt->sig_dbm,\n\t\t\t rxmgmt->frame_data, frame_len, flags);\n\n\treturn 0;\n}\n\nstatic int\nqtnf_event_handle_scan_results(struct qtnf_vif *vif,\n\t\t\t       const struct qlink_event_scan_result *sr,\n\t\t\t       u16 len)\n{\n\tstruct cfg80211_bss *bss;\n\tstruct ieee80211_channel *channel;\n\tstruct wiphy *wiphy = priv_to_wiphy(vif->mac);\n\tenum cfg80211_bss_frame_type frame_type = CFG80211_BSS_FTYPE_UNKNOWN;\n\tsize_t payload_len;\n\tu16 tlv_type;\n\tu16 tlv_value_len;\n\tconst struct qlink_tlv_hdr *tlv;\n\tconst u8 *ies = NULL;\n\tsize_t ies_len = 0;\n\n\tif (len < sizeof(*sr)) {\n\t\tpr_err(\"VIF%u.%u: payload is too short\\n\", vif->mac->macid,\n\t\t       vif->vifid);\n\t\treturn -EINVAL;\n\t}\n\n\tchannel = ieee80211_get_channel(wiphy, le16_to_cpu(sr->freq));\n\tif (!channel) {\n\t\tpr_err(\"VIF%u.%u: channel at %u MHz not found\\n\",\n\t\t       vif->mac->macid, vif->vifid, le16_to_cpu(sr->freq));\n\t\treturn -EINVAL;\n\t}\n\n\tpayload_len = len - sizeof(*sr);\n\n\tqlink_for_each_tlv(tlv, sr->payload, payload_len) {\n\t\ttlv_type = le16_to_cpu(tlv->type);\n\t\ttlv_value_len = le16_to_cpu(tlv->len);\n\n\t\tif (tlv_type == QTN_TLV_ID_IE_SET) {\n\t\t\tconst struct qlink_tlv_ie_set *ie_set;\n\t\t\tunsigned int ie_len;\n\n\t\t\tif (tlv_value_len <\n\t\t\t    (sizeof(*ie_set) - sizeof(ie_set->hdr)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tie_set = (const struct qlink_tlv_ie_set *)tlv;\n\t\t\tie_len = tlv_value_len -\n\t\t\t\t(sizeof(*ie_set) - sizeof(ie_set->hdr));\n\n\t\t\tswitch (ie_set->type) {\n\t\t\tcase QLINK_IE_SET_BEACON_IES:\n\t\t\t\tframe_type = CFG80211_BSS_FTYPE_BEACON;\n\t\t\t\tbreak;\n\t\t\tcase QLINK_IE_SET_PROBE_RESP_IES:\n\t\t\t\tframe_type = CFG80211_BSS_FTYPE_PRESP;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tframe_type = CFG80211_BSS_FTYPE_UNKNOWN;\n\t\t\t}\n\n\t\t\tif (ie_len) {\n\t\t\t\ties = ie_set->ie_data;\n\t\t\t\ties_len = ie_len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!qlink_tlv_parsing_ok(tlv, sr->payload, payload_len))\n\t\treturn -EINVAL;\n\n\tbss = cfg80211_inform_bss(wiphy, channel, frame_type,\n\t\t\t\t  sr->bssid, get_unaligned_le64(&sr->tsf),\n\t\t\t\t  le16_to_cpu(sr->capab),\n\t\t\t\t  le16_to_cpu(sr->bintval), ies, ies_len,\n\t\t\t\t  DBM_TO_MBM(sr->sig_dbm), GFP_KERNEL);\n\tif (!bss)\n\t\treturn -ENOMEM;\n\n\tcfg80211_put_bss(wiphy, bss);\n\n\treturn 0;\n}\n\nstatic int\nqtnf_event_handle_scan_complete(struct qtnf_wmac *mac,\n\t\t\t\tconst struct qlink_event_scan_complete *status,\n\t\t\t\tu16 len)\n{\n\tif (len < sizeof(*status)) {\n\t\tpr_err(\"MAC%u: payload is too short\\n\", mac->macid);\n\t\treturn -EINVAL;\n\t}\n\n\tqtnf_scan_done(mac, le32_to_cpu(status->flags) & QLINK_SCAN_ABORTED);\n\n\treturn 0;\n}\n\nstatic int\nqtnf_event_handle_freq_change(struct qtnf_wmac *mac,\n\t\t\t      const struct qlink_event_freq_change *data,\n\t\t\t      u16 len)\n{\n\tstruct wiphy *wiphy = priv_to_wiphy(mac);\n\tstruct cfg80211_chan_def chandef;\n\tstruct qtnf_vif *vif;\n\tint i;\n\n\tif (len < sizeof(*data)) {\n\t\tpr_err(\"MAC%u: payload is too short\\n\", mac->macid);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!wiphy->registered)\n\t\treturn 0;\n\n\tqlink_chandef_q2cfg(wiphy, &data->chan, &chandef);\n\n\tif (!cfg80211_chandef_valid(&chandef)) {\n\t\tpr_err(\"MAC%u: bad channel freq=%u cf1=%u cf2=%u bw=%u\\n\",\n\t\t       mac->macid, chandef.chan->center_freq,\n\t\t       chandef.center_freq1, chandef.center_freq2,\n\t\t       chandef.width);\n\t\treturn -EINVAL;\n\t}\n\n\tpr_debug(\"MAC%d: new channel ieee=%u freq1=%u freq2=%u bw=%u\\n\",\n\t\t mac->macid, chandef.chan->hw_value, chandef.center_freq1,\n\t\t chandef.center_freq2, chandef.width);\n\n\tfor (i = 0; i < QTNF_MAX_INTF; i++) {\n\t\tvif = &mac->iflist[i];\n\n\t\tif (vif->wdev.iftype == NL80211_IFTYPE_UNSPECIFIED)\n\t\t\tcontinue;\n\n\t\tif (vif->wdev.iftype == NL80211_IFTYPE_STATION &&\n\t\t    !vif->wdev.connected)\n\t\t\tcontinue;\n\n\t\tif (!vif->netdev)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&vif->wdev.mtx);\n\t\tcfg80211_ch_switch_notify(vif->netdev, &chandef, 0, 0);\n\t\tmutex_unlock(&vif->wdev.mtx);\n\t}\n\n\treturn 0;\n}\n\nstatic int qtnf_event_handle_radar(struct qtnf_vif *vif,\n\t\t\t\t   const struct qlink_event_radar *ev,\n\t\t\t\t   u16 len)\n{\n\tstruct wiphy *wiphy = priv_to_wiphy(vif->mac);\n\tstruct cfg80211_chan_def chandef;\n\n\tif (len < sizeof(*ev)) {\n\t\tpr_err(\"MAC%u: payload is too short\\n\", vif->mac->macid);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!wiphy->registered || !vif->netdev)\n\t\treturn 0;\n\n\tqlink_chandef_q2cfg(wiphy, &ev->chan, &chandef);\n\n\tif (!cfg80211_chandef_valid(&chandef)) {\n\t\tpr_err(\"MAC%u: bad channel f1=%u f2=%u bw=%u\\n\",\n\t\t       vif->mac->macid,\n\t\t       chandef.center_freq1, chandef.center_freq2,\n\t\t       chandef.width);\n\t\treturn -EINVAL;\n\t}\n\n\tpr_info(\"%s: radar event=%u f1=%u f2=%u bw=%u\\n\",\n\t\tvif->netdev->name, ev->event,\n\t\tchandef.center_freq1, chandef.center_freq2,\n\t\tchandef.width);\n\n\tswitch (ev->event) {\n\tcase QLINK_RADAR_DETECTED:\n\t\tcfg80211_radar_event(wiphy, &chandef, GFP_KERNEL);\n\t\tbreak;\n\tcase QLINK_RADAR_CAC_FINISHED:\n\t\tif (!vif->wdev.cac_started)\n\t\t\tbreak;\n\n\t\tcfg80211_cac_event(vif->netdev, &chandef,\n\t\t\t\t   NL80211_RADAR_CAC_FINISHED, GFP_KERNEL);\n\t\tbreak;\n\tcase QLINK_RADAR_CAC_ABORTED:\n\t\tif (!vif->wdev.cac_started)\n\t\t\tbreak;\n\n\t\tcfg80211_cac_event(vif->netdev, &chandef,\n\t\t\t\t   NL80211_RADAR_CAC_ABORTED, GFP_KERNEL);\n\t\tbreak;\n\tcase QLINK_RADAR_CAC_STARTED:\n\t\tif (vif->wdev.cac_started)\n\t\t\tbreak;\n\n\t\tif (!wiphy_ext_feature_isset(wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_DFS_OFFLOAD))\n\t\t\tbreak;\n\n\t\tcfg80211_cac_event(vif->netdev, &chandef,\n\t\t\t\t   NL80211_RADAR_CAC_STARTED, GFP_KERNEL);\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: unhandled radar event %u\\n\",\n\t\t\tvif->netdev->name, ev->event);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nqtnf_event_handle_external_auth(struct qtnf_vif *vif,\n\t\t\t\tconst struct qlink_event_external_auth *ev,\n\t\t\t\tu16 len)\n{\n\tstruct cfg80211_external_auth_params auth = {0};\n\tstruct wiphy *wiphy = priv_to_wiphy(vif->mac);\n\tint ret;\n\n\tif (len < sizeof(*ev)) {\n\t\tpr_err(\"MAC%u: payload is too short\\n\", vif->mac->macid);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!wiphy->registered || !vif->netdev)\n\t\treturn 0;\n\n\tif (ev->ssid_len) {\n\t\tint len = clamp_val(ev->ssid_len, 0, IEEE80211_MAX_SSID_LEN);\n\n\t\tmemcpy(auth.ssid.ssid, ev->ssid, len);\n\t\tauth.ssid.ssid_len = len;\n\t}\n\n\tauth.key_mgmt_suite = le32_to_cpu(ev->akm_suite);\n\tether_addr_copy(auth.bssid, ev->bssid);\n\tauth.action = ev->action;\n\n\tpr_debug(\"%s: external SAE processing: bss=%pM action=%u akm=%u\\n\",\n\t\t vif->netdev->name, auth.bssid, auth.action,\n\t\t auth.key_mgmt_suite);\n\n\tret = cfg80211_external_auth_request(vif->netdev, &auth, GFP_KERNEL);\n\tif (ret)\n\t\tpr_warn(\"failed to offload external auth request\\n\");\n\n\treturn ret;\n}\n\nstatic int\nqtnf_event_handle_mic_failure(struct qtnf_vif *vif,\n\t\t\t      const struct qlink_event_mic_failure *mic_ev,\n\t\t\t      u16 len)\n{\n\tstruct wiphy *wiphy = priv_to_wiphy(vif->mac);\n\tu8 pairwise;\n\n\tif (len < sizeof(*mic_ev)) {\n\t\tpr_err(\"VIF%u.%u: payload is too short (%u < %zu)\\n\",\n\t\t       vif->mac->macid, vif->vifid, len,\n\t\t       sizeof(struct qlink_event_mic_failure));\n\t\treturn -EINVAL;\n\t}\n\n\tif (!wiphy->registered || !vif->netdev)\n\t\treturn 0;\n\n\tif (vif->wdev.iftype != NL80211_IFTYPE_STATION) {\n\t\tpr_err(\"VIF%u.%u: MIC_FAILURE event when not in STA mode\\n\",\n\t\t       vif->mac->macid, vif->vifid);\n\t\treturn -EPROTO;\n\t}\n\n\tpairwise = mic_ev->pairwise ?\n\t\tNL80211_KEYTYPE_PAIRWISE : NL80211_KEYTYPE_GROUP;\n\n\tpr_info(\"%s: MIC error: src=%pM key_index=%u pairwise=%u\\n\",\n\t\tvif->netdev->name, mic_ev->src, mic_ev->key_index, pairwise);\n\n\tcfg80211_michael_mic_failure(vif->netdev, mic_ev->src, pairwise,\n\t\t\t\t     mic_ev->key_index, NULL, GFP_KERNEL);\n\n\treturn 0;\n}\n\nstatic int\nqtnf_event_handle_update_owe(struct qtnf_vif *vif,\n\t\t\t     const struct qlink_event_update_owe *owe_ev,\n\t\t\t     u16 len)\n{\n\tstruct wiphy *wiphy = priv_to_wiphy(vif->mac);\n\tstruct cfg80211_update_owe_info owe_info = {};\n\tconst u16 ie_len = len - sizeof(*owe_ev);\n\tu8 *ie;\n\n\tif (len < sizeof(*owe_ev)) {\n\t\tpr_err(\"VIF%u.%u: payload is too short (%u < %zu)\\n\",\n\t\t       vif->mac->macid, vif->vifid, len,\n\t\t       sizeof(struct qlink_event_update_owe));\n\t\treturn -EINVAL;\n\t}\n\n\tif (!wiphy->registered || !vif->netdev)\n\t\treturn 0;\n\n\tif (vif->wdev.iftype != NL80211_IFTYPE_AP) {\n\t\tpr_err(\"VIF%u.%u: UPDATE_OWE event when not in AP mode\\n\",\n\t\t       vif->mac->macid, vif->vifid);\n\t\treturn -EPROTO;\n\t}\n\n\tie = kzalloc(ie_len, GFP_KERNEL);\n\tif (!ie)\n\t\treturn -ENOMEM;\n\n\tmemcpy(owe_info.peer, owe_ev->peer, ETH_ALEN);\n\tmemcpy(ie, owe_ev->ies, ie_len);\n\towe_info.ie_len = ie_len;\n\towe_info.ie = ie;\n\towe_info.assoc_link_id = -1;\n\n\tpr_info(\"%s: external OWE processing: peer=%pM\\n\",\n\t\tvif->netdev->name, owe_ev->peer);\n\n\tcfg80211_update_owe_info_event(vif->netdev, &owe_info, GFP_KERNEL);\n\tkfree(ie);\n\n\treturn 0;\n}\n\nstatic int qtnf_event_parse(struct qtnf_wmac *mac,\n\t\t\t    const struct sk_buff *event_skb)\n{\n\tconst struct qlink_event *event;\n\tstruct qtnf_vif *vif = NULL;\n\tint ret = -1;\n\tu16 event_id;\n\tu16 event_len;\n\tu8 vifid;\n\n\tevent = (const struct qlink_event *)event_skb->data;\n\tevent_id = le16_to_cpu(event->event_id);\n\tevent_len = le16_to_cpu(event->mhdr.len);\n\n\tif (event->vifid >= QTNF_MAX_INTF) {\n\t\tpr_err(\"invalid vif(%u)\\n\", event->vifid);\n\t\treturn -EINVAL;\n\t}\n\n\tvifid = array_index_nospec(event->vifid, QTNF_MAX_INTF);\n\tvif = &mac->iflist[vifid];\n\n\tswitch (event_id) {\n\tcase QLINK_EVENT_STA_ASSOCIATED:\n\t\tret = qtnf_event_handle_sta_assoc(mac, vif, (const void *)event,\n\t\t\t\t\t\t  event_len);\n\t\tbreak;\n\tcase QLINK_EVENT_STA_DEAUTH:\n\t\tret = qtnf_event_handle_sta_deauth(mac, vif,\n\t\t\t\t\t\t   (const void *)event,\n\t\t\t\t\t\t   event_len);\n\t\tbreak;\n\tcase QLINK_EVENT_MGMT_RECEIVED:\n\t\tret = qtnf_event_handle_mgmt_received(vif, (const void *)event,\n\t\t\t\t\t\t      event_len);\n\t\tbreak;\n\tcase QLINK_EVENT_SCAN_RESULTS:\n\t\tret = qtnf_event_handle_scan_results(vif, (const void *)event,\n\t\t\t\t\t\t     event_len);\n\t\tbreak;\n\tcase QLINK_EVENT_SCAN_COMPLETE:\n\t\tret = qtnf_event_handle_scan_complete(mac, (const void *)event,\n\t\t\t\t\t\t      event_len);\n\t\tbreak;\n\tcase QLINK_EVENT_BSS_JOIN:\n\t\tret = qtnf_event_handle_bss_join(vif, (const void *)event,\n\t\t\t\t\t\t event_len);\n\t\tbreak;\n\tcase QLINK_EVENT_BSS_LEAVE:\n\t\tret = qtnf_event_handle_bss_leave(vif, (const void *)event,\n\t\t\t\t\t\t  event_len);\n\t\tbreak;\n\tcase QLINK_EVENT_FREQ_CHANGE:\n\t\tret = qtnf_event_handle_freq_change(mac, (const void *)event,\n\t\t\t\t\t\t    event_len);\n\t\tbreak;\n\tcase QLINK_EVENT_RADAR:\n\t\tret = qtnf_event_handle_radar(vif, (const void *)event,\n\t\t\t\t\t      event_len);\n\t\tbreak;\n\tcase QLINK_EVENT_EXTERNAL_AUTH:\n\t\tret = qtnf_event_handle_external_auth(vif, (const void *)event,\n\t\t\t\t\t\t      event_len);\n\t\tbreak;\n\tcase QLINK_EVENT_MIC_FAILURE:\n\t\tret = qtnf_event_handle_mic_failure(vif, (const void *)event,\n\t\t\t\t\t\t    event_len);\n\t\tbreak;\n\tcase QLINK_EVENT_UPDATE_OWE:\n\t\tret = qtnf_event_handle_update_owe(vif, (const void *)event,\n\t\t\t\t\t\t   event_len);\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"unknown event type: %x\\n\", event_id);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int qtnf_event_process_skb(struct qtnf_bus *bus,\n\t\t\t\t  const struct sk_buff *skb)\n{\n\tconst struct qlink_event *event;\n\tstruct qtnf_wmac *mac;\n\tint res;\n\n\tif (unlikely(!skb || skb->len < sizeof(*event))) {\n\t\tpr_err(\"invalid event buffer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tevent = (struct qlink_event *)skb->data;\n\n\tmac = qtnf_core_get_mac(bus, event->macid);\n\n\tpr_debug(\"new event id:%x len:%u mac:%u vif:%u\\n\",\n\t\t le16_to_cpu(event->event_id), le16_to_cpu(event->mhdr.len),\n\t\t event->macid, event->vifid);\n\n\tif (unlikely(!mac))\n\t\treturn -ENXIO;\n\n\trtnl_lock();\n\tres = qtnf_event_parse(mac, skb);\n\trtnl_unlock();\n\n\treturn res;\n}\n\nvoid qtnf_event_work_handler(struct work_struct *work)\n{\n\tstruct qtnf_bus *bus = container_of(work, struct qtnf_bus, event_work);\n\tstruct sk_buff_head *event_queue = &bus->trans.event_queue;\n\tstruct sk_buff *current_event_skb = skb_dequeue(event_queue);\n\n\twhile (current_event_skb) {\n\t\tqtnf_event_process_skb(bus, current_event_skb);\n\t\tdev_kfree_skb_any(current_event_skb);\n\t\tcurrent_event_skb = skb_dequeue(event_queue);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}