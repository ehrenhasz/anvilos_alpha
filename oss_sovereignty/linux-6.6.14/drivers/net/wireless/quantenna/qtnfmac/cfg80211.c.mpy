{
  "module_name": "cfg80211.c",
  "hash_id": "ae6b7754f2b7f9a9595098c0abcd304fe4b12485420cdd91c1f6ad8f7797e263",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/quantenna/qtnfmac/cfg80211.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/etherdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/ieee80211.h>\n#include <net/cfg80211.h>\n#include <net/netlink.h>\n\n#include \"cfg80211.h\"\n#include \"commands.h\"\n#include \"core.h\"\n#include \"util.h\"\n#include \"bus.h\"\n\n \nstatic struct ieee80211_rate qtnf_rates_2g[] = {\n\t{.bitrate = 10, .hw_value = 2, },\n\t{.bitrate = 20, .hw_value = 4, },\n\t{.bitrate = 55, .hw_value = 11, },\n\t{.bitrate = 110, .hw_value = 22, },\n\t{.bitrate = 60, .hw_value = 12, },\n\t{.bitrate = 90, .hw_value = 18, },\n\t{.bitrate = 120, .hw_value = 24, },\n\t{.bitrate = 180, .hw_value = 36, },\n\t{.bitrate = 240, .hw_value = 48, },\n\t{.bitrate = 360, .hw_value = 72, },\n\t{.bitrate = 480, .hw_value = 96, },\n\t{.bitrate = 540, .hw_value = 108, },\n};\n\n \nstatic struct ieee80211_rate qtnf_rates_5g[] = {\n\t{.bitrate = 60, .hw_value = 12, },\n\t{.bitrate = 90, .hw_value = 18, },\n\t{.bitrate = 120, .hw_value = 24, },\n\t{.bitrate = 180, .hw_value = 36, },\n\t{.bitrate = 240, .hw_value = 48, },\n\t{.bitrate = 360, .hw_value = 72, },\n\t{.bitrate = 480, .hw_value = 96, },\n\t{.bitrate = 540, .hw_value = 108, },\n};\n\n \nstatic const u32 qtnf_cipher_suites[] = {\n\tWLAN_CIPHER_SUITE_TKIP,\n\tWLAN_CIPHER_SUITE_CCMP,\n\tWLAN_CIPHER_SUITE_AES_CMAC,\n};\n\n \nstatic const struct ieee80211_txrx_stypes\nqtnf_mgmt_stypes[NUM_NL80211_IFTYPES] = {\n\t[NL80211_IFTYPE_STATION] = {\n\t\t.tx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t      BIT(IEEE80211_STYPE_AUTH >> 4),\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t      BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |\n\t\t      BIT(IEEE80211_STYPE_AUTH >> 4),\n\t},\n\t[NL80211_IFTYPE_AP] = {\n\t\t.tx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t      BIT(IEEE80211_STYPE_AUTH >> 4),\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t      BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |\n\t\t      BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |\n\t\t      BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |\n\t\t      BIT(IEEE80211_STYPE_AUTH >> 4),\n\t},\n};\n\nstatic int\nqtnf_validate_iface_combinations(struct wiphy *wiphy,\n\t\t\t\t struct qtnf_vif *change_vif,\n\t\t\t\t enum nl80211_iftype new_type)\n{\n\tstruct qtnf_wmac *mac;\n\tstruct qtnf_vif *vif;\n\tint i;\n\tint ret = 0;\n\tstruct iface_combination_params params = {\n\t\t.num_different_channels = 1,\n\t};\n\n\tmac = wiphy_priv(wiphy);\n\tif (!mac)\n\t\treturn -EFAULT;\n\n\tfor (i = 0; i < QTNF_MAX_INTF; i++) {\n\t\tvif = &mac->iflist[i];\n\t\tif (vif->wdev.iftype != NL80211_IFTYPE_UNSPECIFIED)\n\t\t\tparams.iftype_num[vif->wdev.iftype]++;\n\t}\n\n\tif (change_vif) {\n\t\tparams.iftype_num[new_type]++;\n\t\tparams.iftype_num[change_vif->wdev.iftype]--;\n\t} else {\n\t\tparams.iftype_num[new_type]++;\n\t}\n\n\tret = cfg80211_check_combinations(wiphy, &params);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tvif = qtnf_mac_get_base_vif(mac);\n\tif (vif && vif->wdev.iftype == NL80211_IFTYPE_AP &&\n\t    vif != change_vif && new_type == NL80211_IFTYPE_STATION) {\n\t\tret = -EINVAL;\n\t\tpr_err(\"MAC%u invalid combination: AP as primary repeater interface is not supported\\n\",\n\t\t       mac->macid);\n\t}\n\n\treturn ret;\n}\n\nstatic int\nqtnf_change_virtual_intf(struct wiphy *wiphy,\n\t\t\t struct net_device *dev,\n\t\t\t enum nl80211_iftype type,\n\t\t\t struct vif_params *params)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(dev);\n\tu8 *mac_addr = NULL;\n\tint use4addr = 0;\n\tint ret;\n\n\tret = qtnf_validate_iface_combinations(wiphy, vif, type);\n\tif (ret) {\n\t\tpr_err(\"VIF%u.%u combination check: failed to set type %d\\n\",\n\t\t       vif->mac->macid, vif->vifid, type);\n\t\treturn ret;\n\t}\n\n\tif (params) {\n\t\tmac_addr = params->macaddr;\n\t\tuse4addr = params->use_4addr;\n\t}\n\n\tqtnf_scan_done(vif->mac, true);\n\n\tret = qtnf_cmd_send_change_intf_type(vif, type, use4addr, mac_addr);\n\tif (ret) {\n\t\tpr_err(\"VIF%u.%u: failed to change type to %d\\n\",\n\t\t       vif->mac->macid, vif->vifid, type);\n\t\treturn ret;\n\t}\n\n\tvif->wdev.iftype = type;\n\treturn 0;\n}\n\nint qtnf_del_virtual_intf(struct wiphy *wiphy, struct wireless_dev *wdev)\n{\n\tstruct net_device *netdev =  wdev->netdev;\n\tstruct qtnf_vif *vif;\n\tstruct sk_buff *skb;\n\n\tif (WARN_ON(!netdev))\n\t\treturn -EFAULT;\n\n\tvif = qtnf_netdev_get_priv(wdev->netdev);\n\n\tqtnf_scan_done(vif->mac, true);\n\n\t \n\tnetif_tx_stop_all_queues(netdev);\n\tif (netif_carrier_ok(netdev))\n\t\tnetif_carrier_off(netdev);\n\n\twhile ((skb = skb_dequeue(&vif->high_pri_tx_queue)))\n\t\tdev_kfree_skb_any(skb);\n\n\tcancel_work_sync(&vif->high_pri_tx_work);\n\n\tif (netdev->reg_state == NETREG_REGISTERED)\n\t\tcfg80211_unregister_netdevice(netdev);\n\n\tif (qtnf_cmd_send_del_intf(vif))\n\t\tpr_err(\"VIF%u.%u: failed to delete VIF\\n\", vif->mac->macid,\n\t\t       vif->vifid);\n\n\tvif->netdev->ieee80211_ptr = NULL;\n\tvif->netdev = NULL;\n\tvif->wdev.iftype = NL80211_IFTYPE_UNSPECIFIED;\n\n\treturn 0;\n}\n\nstatic struct wireless_dev *qtnf_add_virtual_intf(struct wiphy *wiphy,\n\t\t\t\t\t\t  const char *name,\n\t\t\t\t\t\t  unsigned char name_assign_t,\n\t\t\t\t\t\t  enum nl80211_iftype type,\n\t\t\t\t\t\t  struct vif_params *params)\n{\n\tstruct qtnf_wmac *mac;\n\tstruct qtnf_vif *vif;\n\tu8 *mac_addr = NULL;\n\tint use4addr = 0;\n\tint ret;\n\n\tmac = wiphy_priv(wiphy);\n\n\tif (!mac)\n\t\treturn ERR_PTR(-EFAULT);\n\n\tret = qtnf_validate_iface_combinations(wiphy, NULL, type);\n\tif (ret) {\n\t\tpr_err(\"MAC%u invalid combination: failed to add type %d\\n\",\n\t\t       mac->macid, type);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_AP:\n\t\tvif = qtnf_mac_get_free_vif(mac);\n\t\tif (!vif) {\n\t\t\tpr_err(\"MAC%u: no free VIF available\\n\", mac->macid);\n\t\t\treturn ERR_PTR(-EFAULT);\n\t\t}\n\n\t\teth_zero_addr(vif->mac_addr);\n\t\teth_zero_addr(vif->bssid);\n\t\tvif->bss_priority = QTNF_DEF_BSS_PRIORITY;\n\t\tmemset(&vif->wdev, 0, sizeof(vif->wdev));\n\t\tvif->wdev.wiphy = wiphy;\n\t\tvif->wdev.iftype = type;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"MAC%u: unsupported IF type %d\\n\", mac->macid, type);\n\t\treturn ERR_PTR(-ENOTSUPP);\n\t}\n\n\tif (params) {\n\t\tmac_addr = params->macaddr;\n\t\tuse4addr = params->use_4addr;\n\t}\n\n\tret = qtnf_cmd_send_add_intf(vif, type, use4addr, mac_addr);\n\tif (ret) {\n\t\tpr_err(\"VIF%u.%u: failed to add VIF %pM\\n\",\n\t\t       mac->macid, vif->vifid, mac_addr);\n\t\tgoto err_cmd;\n\t}\n\n\tif (!is_valid_ether_addr(vif->mac_addr)) {\n\t\tpr_err(\"VIF%u.%u: FW reported bad MAC: %pM\\n\",\n\t\t       mac->macid, vif->vifid, vif->mac_addr);\n\t\tret = -EINVAL;\n\t\tgoto error_del_vif;\n\t}\n\n\tret = qtnf_core_net_attach(mac, vif, name, name_assign_t);\n\tif (ret) {\n\t\tpr_err(\"VIF%u.%u: failed to attach netdev\\n\", mac->macid,\n\t\t       vif->vifid);\n\t\tgoto error_del_vif;\n\t}\n\n\tif (qtnf_hwcap_is_set(&mac->bus->hw_info, QLINK_HW_CAPAB_HW_BRIDGE)) {\n\t\tret = qtnf_cmd_netdev_changeupper(vif, vif->netdev->ifindex);\n\t\tif (ret) {\n\t\t\tcfg80211_unregister_netdevice(vif->netdev);\n\t\t\tvif->netdev = NULL;\n\t\t\tgoto error_del_vif;\n\t\t}\n\t}\n\n\tvif->wdev.netdev = vif->netdev;\n\treturn &vif->wdev;\n\nerror_del_vif:\n\tqtnf_cmd_send_del_intf(vif);\nerr_cmd:\n\tvif->wdev.iftype = NL80211_IFTYPE_UNSPECIFIED;\n\n\treturn ERR_PTR(ret);\n}\n\nstatic int qtnf_mgmt_set_appie(struct qtnf_vif *vif,\n\t\t\t       const struct cfg80211_beacon_data *info)\n{\n\tint ret = 0;\n\n\tif (!info->beacon_ies || !info->beacon_ies_len) {\n\t\tret = qtnf_cmd_send_mgmt_set_appie(vif, QLINK_IE_SET_BEACON_IES,\n\t\t\t\t\t\t   NULL, 0);\n\t} else {\n\t\tret = qtnf_cmd_send_mgmt_set_appie(vif, QLINK_IE_SET_BEACON_IES,\n\t\t\t\t\t\t   info->beacon_ies,\n\t\t\t\t\t\t   info->beacon_ies_len);\n\t}\n\n\tif (ret)\n\t\tgoto out;\n\n\tif (!info->proberesp_ies || !info->proberesp_ies_len) {\n\t\tret = qtnf_cmd_send_mgmt_set_appie(vif,\n\t\t\t\t\t\t   QLINK_IE_SET_PROBE_RESP_IES,\n\t\t\t\t\t\t   NULL, 0);\n\t} else {\n\t\tret = qtnf_cmd_send_mgmt_set_appie(vif,\n\t\t\t\t\t\t   QLINK_IE_SET_PROBE_RESP_IES,\n\t\t\t\t\t\t   info->proberesp_ies,\n\t\t\t\t\t\t   info->proberesp_ies_len);\n\t}\n\n\tif (ret)\n\t\tgoto out;\n\n\tif (!info->assocresp_ies || !info->assocresp_ies_len) {\n\t\tret = qtnf_cmd_send_mgmt_set_appie(vif,\n\t\t\t\t\t\t   QLINK_IE_SET_ASSOC_RESP,\n\t\t\t\t\t\t   NULL, 0);\n\t} else {\n\t\tret = qtnf_cmd_send_mgmt_set_appie(vif,\n\t\t\t\t\t\t   QLINK_IE_SET_ASSOC_RESP,\n\t\t\t\t\t\t   info->assocresp_ies,\n\t\t\t\t\t\t   info->assocresp_ies_len);\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int qtnf_change_beacon(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      struct cfg80211_beacon_data *info)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(dev);\n\n\treturn qtnf_mgmt_set_appie(vif, info);\n}\n\nstatic int qtnf_start_ap(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t struct cfg80211_ap_settings *settings)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(dev);\n\tint ret;\n\n\tret = qtnf_cmd_send_start_ap(vif, settings);\n\tif (ret)\n\t\tpr_err(\"VIF%u.%u: failed to start AP\\n\", vif->mac->macid,\n\t\t       vif->vifid);\n\n\treturn ret;\n}\n\nstatic int qtnf_stop_ap(struct wiphy *wiphy, struct net_device *dev,\n\t\t\tunsigned int link_id)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(dev);\n\tint ret;\n\n\tqtnf_scan_done(vif->mac, true);\n\n\tret = qtnf_cmd_send_stop_ap(vif);\n\tif (ret)\n\t\tpr_err(\"VIF%u.%u: failed to stop AP operation in FW\\n\",\n\t\t       vif->mac->macid, vif->vifid);\n\n\tnetif_carrier_off(vif->netdev);\n\n\treturn ret;\n}\n\nstatic int qtnf_set_wiphy_params(struct wiphy *wiphy, u32 changed)\n{\n\tstruct qtnf_wmac *mac = wiphy_priv(wiphy);\n\tstruct qtnf_vif *vif;\n\tint ret;\n\n\tvif = qtnf_mac_get_base_vif(mac);\n\tif (!vif) {\n\t\tpr_err(\"MAC%u: primary VIF is not configured\\n\", mac->macid);\n\t\treturn -EFAULT;\n\t}\n\n\tret = qtnf_cmd_send_update_phy_params(mac, changed);\n\tif (ret)\n\t\tpr_err(\"MAC%u: failed to update PHY params\\n\", mac->macid);\n\n\treturn ret;\n}\n\nstatic void\nqtnf_update_mgmt_frame_registrations(struct wiphy *wiphy,\n\t\t\t\t     struct wireless_dev *wdev,\n\t\t\t\t     struct mgmt_frame_regs *upd)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(wdev->netdev);\n\tu16 new_mask = upd->interface_stypes;\n\tu16 old_mask = vif->mgmt_frames_bitmask;\n\tstatic const struct {\n\t\tu16 mask, qlink_type;\n\t} updates[] = {\n\t\t{\n\t\t\t.mask = BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |\n\t\t\t\tBIT(IEEE80211_STYPE_ASSOC_REQ >> 4),\n\t\t\t.qlink_type = QLINK_MGMT_FRAME_ASSOC_REQ,\n\t\t},\n\t\t{\n\t\t\t.mask = BIT(IEEE80211_STYPE_AUTH >> 4),\n\t\t\t.qlink_type = QLINK_MGMT_FRAME_AUTH,\n\t\t},\n\t\t{\n\t\t\t.mask = BIT(IEEE80211_STYPE_PROBE_REQ >> 4),\n\t\t\t.qlink_type = QLINK_MGMT_FRAME_PROBE_REQ,\n\t\t},\n\t\t{\n\t\t\t.mask = BIT(IEEE80211_STYPE_ACTION >> 4),\n\t\t\t.qlink_type = QLINK_MGMT_FRAME_ACTION,\n\t\t},\n\t};\n\tunsigned int i;\n\n\tif (new_mask == old_mask)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(updates); i++) {\n\t\tu16 mask = updates[i].mask;\n\t\tu16 qlink_frame_type = updates[i].qlink_type;\n\t\tbool reg;\n\n\t\t \n\t\tif (!(new_mask & mask) == !(old_mask & mask))\n\t\t\tcontinue;\n\n\t\treg = new_mask & mask;\n\n\t\tif (qtnf_cmd_send_register_mgmt(vif, qlink_frame_type, reg))\n\t\t\tpr_warn(\"VIF%u.%u: failed to %sregister qlink frame type 0x%x\\n\",\n\t\t\t\tvif->mac->macid, vif->vifid, reg ? \"\" : \"un\",\n\t\t\t\tqlink_frame_type);\n\t}\n\n\tvif->mgmt_frames_bitmask = new_mask;\n}\n\nstatic int\nqtnf_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t     struct cfg80211_mgmt_tx_params *params, u64 *cookie)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(wdev->netdev);\n\tconst struct ieee80211_mgmt *mgmt_frame = (void *)params->buf;\n\tu32 short_cookie = get_random_u32();\n\tu16 flags = 0;\n\tu16 freq;\n\n\t*cookie = short_cookie;\n\n\tif (params->offchan)\n\t\tflags |= QLINK_FRAME_TX_FLAG_OFFCHAN;\n\n\tif (params->no_cck)\n\t\tflags |= QLINK_FRAME_TX_FLAG_NO_CCK;\n\n\tif (params->dont_wait_for_ack)\n\t\tflags |= QLINK_FRAME_TX_FLAG_ACK_NOWAIT;\n\n\t \n\tif (params->chan)\n\t\tfreq = params->chan->center_freq;\n\telse\n\t\tfreq = 0;\n\n\tpr_debug(\"%s freq:%u; FC:%.4X; DA:%pM; len:%zu; C:%.8X; FL:%.4X\\n\",\n\t\t wdev->netdev->name, freq,\n\t\t le16_to_cpu(mgmt_frame->frame_control), mgmt_frame->da,\n\t\t params->len, short_cookie, flags);\n\n\treturn qtnf_cmd_send_frame(vif, short_cookie, flags,\n\t\t\t\t   freq, params->buf, params->len);\n}\n\nstatic int\nqtnf_get_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t const u8 *mac, struct station_info *sinfo)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(dev);\n\n\tsinfo->generation = vif->generation;\n\treturn qtnf_cmd_get_sta_info(vif, mac, sinfo);\n}\n\nstatic int\nqtnf_dump_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t  int idx, u8 *mac, struct station_info *sinfo)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(dev);\n\tconst struct qtnf_sta_node *sta_node;\n\tint ret;\n\n\tswitch (vif->wdev.iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (idx != 0 || !vif->wdev.connected)\n\t\t\treturn -ENOENT;\n\n\t\tether_addr_copy(mac, vif->bssid);\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tsta_node = qtnf_sta_list_lookup_index(&vif->sta_list, idx);\n\t\tif (unlikely(!sta_node))\n\t\t\treturn -ENOENT;\n\n\t\tether_addr_copy(mac, sta_node->mac_addr);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\tret = qtnf_cmd_get_sta_info(vif, mac, sinfo);\n\n\tif (vif->wdev.iftype == NL80211_IFTYPE_AP) {\n\t\tif (ret == -ENOENT) {\n\t\t\tcfg80211_del_sta(vif->netdev, mac, GFP_KERNEL);\n\t\t\tsinfo->filled = 0;\n\t\t}\n\t}\n\n\tsinfo->generation = vif->generation;\n\n\treturn ret;\n}\n\nstatic int qtnf_add_key(struct wiphy *wiphy, struct net_device *dev,\n\t\t\tint link_id, u8 key_index, bool pairwise,\n\t\t\tconst u8 *mac_addr, struct key_params *params)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(dev);\n\tint ret;\n\n\tret = qtnf_cmd_send_add_key(vif, key_index, pairwise, mac_addr, params);\n\tif (ret)\n\t\tpr_err(\"VIF%u.%u: failed to add key: cipher=%x idx=%u pw=%u\\n\",\n\t\t       vif->mac->macid, vif->vifid, params->cipher, key_index,\n\t\t       pairwise);\n\n\treturn ret;\n}\n\nstatic int qtnf_del_key(struct wiphy *wiphy, struct net_device *dev,\n\t\t\tint link_id, u8 key_index, bool pairwise,\n\t\t\tconst u8 *mac_addr)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(dev);\n\tint ret;\n\n\tret = qtnf_cmd_send_del_key(vif, key_index, pairwise, mac_addr);\n\tif (ret) {\n\t\tif (ret == -ENOENT) {\n\t\t\tpr_debug(\"VIF%u.%u: key index %d out of bounds\\n\",\n\t\t\t\t vif->mac->macid, vif->vifid, key_index);\n\t\t} else {\n\t\t\tpr_err(\"VIF%u.%u: failed to delete key: idx=%u pw=%u\\n\",\n\t\t\t       vif->mac->macid, vif->vifid,\n\t\t\t       key_index, pairwise);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int qtnf_set_default_key(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\tint link_id, u8 key_index, bool unicast,\n\t\t\t\tbool multicast)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(dev);\n\tint ret;\n\n\tret = qtnf_cmd_send_set_default_key(vif, key_index, unicast, multicast);\n\tif (ret)\n\t\tpr_err(\"VIF%u.%u: failed to set dflt key: idx=%u uc=%u mc=%u\\n\",\n\t\t       vif->mac->macid, vif->vifid, key_index, unicast,\n\t\t       multicast);\n\n\treturn ret;\n}\n\nstatic int\nqtnf_set_default_mgmt_key(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t  int link_id, u8 key_index)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(dev);\n\tint ret;\n\n\tret = qtnf_cmd_send_set_default_mgmt_key(vif, key_index);\n\tif (ret)\n\t\tpr_err(\"VIF%u.%u: failed to set default MGMT key: idx=%u\\n\",\n\t\t       vif->mac->macid, vif->vifid, key_index);\n\n\treturn ret;\n}\n\nstatic int\nqtnf_change_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t    const u8 *mac, struct station_parameters *params)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(dev);\n\tint ret;\n\n\tret = qtnf_cmd_send_change_sta(vif, mac, params);\n\tif (ret)\n\t\tpr_err(\"VIF%u.%u: failed to change STA %pM\\n\",\n\t\t       vif->mac->macid, vif->vifid, mac);\n\n\treturn ret;\n}\n\nstatic int\nqtnf_del_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t struct station_del_parameters *params)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(dev);\n\tint ret;\n\n\tif (params->mac &&\n\t    (vif->wdev.iftype == NL80211_IFTYPE_AP) &&\n\t    !is_broadcast_ether_addr(params->mac) &&\n\t    !qtnf_sta_list_lookup(&vif->sta_list, params->mac))\n\t\treturn 0;\n\n\tret = qtnf_cmd_send_del_sta(vif, params);\n\tif (ret)\n\t\tpr_err(\"VIF%u.%u: failed to delete STA %pM\\n\",\n\t\t       vif->mac->macid, vif->vifid, params->mac);\n\n\treturn ret;\n}\n\nstatic int\nqtnf_scan(struct wiphy *wiphy, struct cfg80211_scan_request *request)\n{\n\tstruct qtnf_wmac *mac = wiphy_priv(wiphy);\n\tint ret;\n\n\tcancel_delayed_work_sync(&mac->scan_timeout);\n\n\tmac->scan_req = request;\n\n\tret = qtnf_cmd_send_scan(mac);\n\tif (ret) {\n\t\tpr_err(\"MAC%u: failed to start scan\\n\", mac->macid);\n\t\tmac->scan_req = NULL;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"MAC%u: scan started\\n\", mac->macid);\n\tqueue_delayed_work(mac->bus->workqueue, &mac->scan_timeout,\n\t\t\t   QTNF_SCAN_TIMEOUT_SEC * HZ);\n\nout:\n\treturn ret;\n}\n\nstatic int\nqtnf_connect(struct wiphy *wiphy, struct net_device *dev,\n\t     struct cfg80211_connect_params *sme)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(dev);\n\tint ret;\n\n\tif (vif->wdev.iftype != NL80211_IFTYPE_STATION)\n\t\treturn -EOPNOTSUPP;\n\n\tif (sme->auth_type == NL80211_AUTHTYPE_SAE &&\n\t    !(sme->flags & CONNECT_REQ_EXTERNAL_AUTH_SUPPORT)) {\n\t\tpr_err(\"can not offload authentication to userspace\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (sme->bssid)\n\t\tether_addr_copy(vif->bssid, sme->bssid);\n\telse\n\t\teth_zero_addr(vif->bssid);\n\n\tret = qtnf_cmd_send_connect(vif, sme);\n\tif (ret)\n\t\tpr_err(\"VIF%u.%u: failed to connect\\n\",\n\t\t       vif->mac->macid, vif->vifid);\n\n\treturn ret;\n}\n\nstatic int\nqtnf_external_auth(struct wiphy *wiphy, struct net_device *dev,\n\t\t   struct cfg80211_external_auth_params *auth)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(dev);\n\tint ret;\n\n\tif (vif->wdev.iftype == NL80211_IFTYPE_STATION &&\n\t    !ether_addr_equal(vif->bssid, auth->bssid))\n\t\tpr_warn(\"unexpected bssid: %pM\", auth->bssid);\n\n\tret = qtnf_cmd_send_external_auth(vif, auth);\n\tif (ret)\n\t\tpr_err(\"VIF%u.%u: failed to report external auth\\n\",\n\t\t       vif->mac->macid, vif->vifid);\n\n\treturn ret;\n}\n\nstatic int\nqtnf_disconnect(struct wiphy *wiphy, struct net_device *dev,\n\t\tu16 reason_code)\n{\n\tstruct qtnf_wmac *mac = wiphy_priv(wiphy);\n\tstruct qtnf_vif *vif;\n\tint ret = 0;\n\n\tvif = qtnf_mac_get_base_vif(mac);\n\tif (!vif) {\n\t\tpr_err(\"MAC%u: primary VIF is not configured\\n\", mac->macid);\n\t\treturn -EFAULT;\n\t}\n\n\tif (vif->wdev.iftype != NL80211_IFTYPE_STATION)\n\t\treturn -EOPNOTSUPP;\n\n\tret = qtnf_cmd_send_disconnect(vif, reason_code);\n\tif (ret)\n\t\tpr_err(\"VIF%u.%u: failed to disconnect\\n\",\n\t\t       mac->macid, vif->vifid);\n\n\tif (vif->wdev.connected) {\n\t\tnetif_carrier_off(vif->netdev);\n\t\tcfg80211_disconnected(vif->netdev, reason_code,\n\t\t\t\t      NULL, 0, true, GFP_KERNEL);\n\t}\n\n\treturn ret;\n}\n\nstatic int\nqtnf_dump_survey(struct wiphy *wiphy, struct net_device *dev,\n\t\t int idx, struct survey_info *survey)\n{\n\tstruct qtnf_wmac *mac = wiphy_priv(wiphy);\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct ieee80211_supported_band *sband;\n\tconst struct cfg80211_chan_def *chandef = wdev_chandef(wdev, 0);\n\tstruct ieee80211_channel *chan;\n\tint ret;\n\n\tsband = wiphy->bands[NL80211_BAND_2GHZ];\n\tif (sband && idx >= sband->n_channels) {\n\t\tidx -= sband->n_channels;\n\t\tsband = NULL;\n\t}\n\n\tif (!sband)\n\t\tsband = wiphy->bands[NL80211_BAND_5GHZ];\n\n\tif (!sband || idx >= sband->n_channels)\n\t\treturn -ENOENT;\n\n\tchan = &sband->channels[idx];\n\tsurvey->channel = chan;\n\tsurvey->filled = 0x0;\n\n\tif (chandef && chan == chandef->chan)\n\t\tsurvey->filled = SURVEY_INFO_IN_USE;\n\n\tret = qtnf_cmd_get_chan_stats(mac, chan->center_freq, survey);\n\tif (ret)\n\t\tpr_debug(\"failed to get chan(%d) stats from card\\n\",\n\t\t\t chan->hw_value);\n\n\treturn ret;\n}\n\nstatic int\nqtnf_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t unsigned int link_id, struct cfg80211_chan_def *chandef)\n{\n\tstruct net_device *ndev = wdev->netdev;\n\tstruct qtnf_vif *vif;\n\tint ret;\n\n\tif (!ndev)\n\t\treturn -ENODEV;\n\n\tvif = qtnf_netdev_get_priv(wdev->netdev);\n\n\tret = qtnf_cmd_get_channel(vif, chandef);\n\tif (ret) {\n\t\tpr_err(\"%s: failed to get channel: %d\\n\", ndev->name, ret);\n\t\tret = -ENODATA;\n\t\tgoto out;\n\t}\n\n\tif (!cfg80211_chandef_valid(chandef)) {\n\t\tpr_err(\"%s: bad channel freq=%u cf1=%u cf2=%u bw=%u\\n\",\n\t\t       ndev->name, chandef->chan->center_freq,\n\t\t       chandef->center_freq1, chandef->center_freq2,\n\t\t       chandef->width);\n\t\tret = -ENODATA;\n\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int qtnf_channel_switch(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       struct cfg80211_csa_settings *params)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(dev);\n\tint ret;\n\n\tpr_debug(\"%s: chan(%u) count(%u) radar(%u) block_tx(%u)\\n\", dev->name,\n\t\t params->chandef.chan->hw_value, params->count,\n\t\t params->radar_required, params->block_tx);\n\n\tif (!cfg80211_chandef_valid(&params->chandef)) {\n\t\tpr_err(\"%s: invalid channel\\n\", dev->name);\n\t\treturn -EINVAL;\n\t}\n\n\tret = qtnf_cmd_send_chan_switch(vif, params);\n\tif (ret)\n\t\tpr_warn(\"%s: failed to switch to channel (%u)\\n\",\n\t\t\tdev->name, params->chandef.chan->hw_value);\n\n\treturn ret;\n}\n\nstatic int qtnf_start_radar_detection(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *ndev,\n\t\t\t\t      struct cfg80211_chan_def *chandef,\n\t\t\t\t      u32 cac_time_ms)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(ndev);\n\tint ret;\n\n\tif (wiphy_ext_feature_isset(wiphy, NL80211_EXT_FEATURE_DFS_OFFLOAD))\n\t\treturn -ENOTSUPP;\n\n\tret = qtnf_cmd_start_cac(vif, chandef, cac_time_ms);\n\tif (ret)\n\t\tpr_err(\"%s: failed to start CAC ret=%d\\n\", ndev->name, ret);\n\n\treturn ret;\n}\n\nstatic int qtnf_set_mac_acl(struct wiphy *wiphy,\n\t\t\t    struct net_device *dev,\n\t\t\t    const struct cfg80211_acl_data *params)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(dev);\n\tint ret;\n\n\tret = qtnf_cmd_set_mac_acl(vif, params);\n\tif (ret)\n\t\tpr_err(\"%s: failed to set mac ACL ret=%d\\n\", dev->name, ret);\n\n\treturn ret;\n}\n\nstatic int qtnf_set_power_mgmt(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       bool enabled, int timeout)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(dev);\n\tint ret;\n\n\tret = qtnf_cmd_send_pm_set(vif, enabled ? QLINK_PM_AUTO_STANDBY :\n\t\t\t\t   QLINK_PM_OFF, timeout);\n\tif (ret)\n\t\tpr_err(\"%s: failed to set PM mode ret=%d\\n\", dev->name, ret);\n\n\treturn ret;\n}\n\nstatic int qtnf_get_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t     int *dbm)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(wdev->netdev);\n\tint ret;\n\n\tret = qtnf_cmd_get_tx_power(vif, dbm);\n\tif (ret)\n\t\tpr_err(\"MAC%u: failed to get Tx power\\n\", vif->mac->macid);\n\n\treturn ret;\n}\n\nstatic int qtnf_set_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t     enum nl80211_tx_power_setting type, int mbm)\n{\n\tstruct qtnf_vif *vif;\n\tint ret;\n\n\tif (wdev) {\n\t\tvif = qtnf_netdev_get_priv(wdev->netdev);\n\t} else {\n\t\tstruct qtnf_wmac *mac = wiphy_priv(wiphy);\n\n\t\tvif = qtnf_mac_get_base_vif(mac);\n\t\tif (!vif) {\n\t\t\tpr_err(\"MAC%u: primary VIF is not configured\\n\",\n\t\t\t       mac->macid);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tret = qtnf_cmd_set_tx_power(vif, type, mbm);\n\tif (ret)\n\t\tpr_err(\"MAC%u: failed to set Tx power\\n\", vif->mac->macid);\n\n\treturn ret;\n}\n\nstatic int qtnf_update_owe_info(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\tstruct cfg80211_update_owe_info *owe_info)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(dev);\n\tint ret;\n\n\tif (vif->wdev.iftype != NL80211_IFTYPE_AP)\n\t\treturn -EOPNOTSUPP;\n\n\tret = qtnf_cmd_send_update_owe(vif, owe_info);\n\tif (ret)\n\t\tpr_err(\"VIF%u.%u: failed to update owe info\\n\",\n\t\t       vif->mac->macid, vif->vifid);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_PM\nstatic int qtnf_suspend(struct wiphy *wiphy, struct cfg80211_wowlan *wowlan)\n{\n\tstruct qtnf_wmac *mac = wiphy_priv(wiphy);\n\tstruct qtnf_vif *vif;\n\tint ret = 0;\n\n\tvif = qtnf_mac_get_base_vif(mac);\n\tif (!vif) {\n\t\tpr_err(\"MAC%u: primary VIF is not configured\\n\", mac->macid);\n\t\tret = -EFAULT;\n\t\tgoto exit;\n\t}\n\n\tif (!wowlan) {\n\t\tpr_debug(\"WoWLAN triggers are not enabled\\n\");\n\t\tqtnf_virtual_intf_cleanup(vif->netdev);\n\t\tgoto exit;\n\t}\n\n\tqtnf_scan_done(vif->mac, true);\n\n\tret = qtnf_cmd_send_wowlan_set(vif, wowlan);\n\tif (ret) {\n\t\tpr_err(\"MAC%u: failed to set WoWLAN triggers\\n\",\n\t\t       mac->macid);\n\t\tgoto exit;\n\t}\n\nexit:\n\treturn ret;\n}\n\nstatic int qtnf_resume(struct wiphy *wiphy)\n{\n\tstruct qtnf_wmac *mac = wiphy_priv(wiphy);\n\tstruct qtnf_vif *vif;\n\tint ret = 0;\n\n\tvif = qtnf_mac_get_base_vif(mac);\n\tif (!vif) {\n\t\tpr_err(\"MAC%u: primary VIF is not configured\\n\", mac->macid);\n\t\treturn -EFAULT;\n\t}\n\n\tret = qtnf_cmd_send_wowlan_set(vif, NULL);\n\tif (ret)\n\t\tpr_err(\"MAC%u: failed to reset WoWLAN triggers\\n\",\n\t\t       mac->macid);\n\n\treturn ret;\n}\n\nstatic void qtnf_set_wakeup(struct wiphy *wiphy, bool enabled)\n{\n\tstruct qtnf_wmac *mac = wiphy_priv(wiphy);\n\tstruct qtnf_bus *bus = mac->bus;\n\n\tdevice_set_wakeup_enable(bus->dev, enabled);\n}\n#endif\n\nstatic struct cfg80211_ops qtn_cfg80211_ops = {\n\t.add_virtual_intf\t= qtnf_add_virtual_intf,\n\t.change_virtual_intf\t= qtnf_change_virtual_intf,\n\t.del_virtual_intf\t= qtnf_del_virtual_intf,\n\t.start_ap\t\t= qtnf_start_ap,\n\t.change_beacon\t\t= qtnf_change_beacon,\n\t.stop_ap\t\t= qtnf_stop_ap,\n\t.set_wiphy_params\t= qtnf_set_wiphy_params,\n\t.update_mgmt_frame_registrations =\n\t\tqtnf_update_mgmt_frame_registrations,\n\t.mgmt_tx\t\t= qtnf_mgmt_tx,\n\t.change_station\t\t= qtnf_change_station,\n\t.del_station\t\t= qtnf_del_station,\n\t.get_station\t\t= qtnf_get_station,\n\t.dump_station\t\t= qtnf_dump_station,\n\t.add_key\t\t= qtnf_add_key,\n\t.del_key\t\t= qtnf_del_key,\n\t.set_default_key\t= qtnf_set_default_key,\n\t.set_default_mgmt_key\t= qtnf_set_default_mgmt_key,\n\t.scan\t\t\t= qtnf_scan,\n\t.connect\t\t= qtnf_connect,\n\t.external_auth\t\t= qtnf_external_auth,\n\t.disconnect\t\t= qtnf_disconnect,\n\t.dump_survey\t\t= qtnf_dump_survey,\n\t.get_channel\t\t= qtnf_get_channel,\n\t.channel_switch\t\t= qtnf_channel_switch,\n\t.start_radar_detection\t= qtnf_start_radar_detection,\n\t.set_mac_acl\t\t= qtnf_set_mac_acl,\n\t.set_power_mgmt\t\t= qtnf_set_power_mgmt,\n\t.get_tx_power\t\t= qtnf_get_tx_power,\n\t.set_tx_power\t\t= qtnf_set_tx_power,\n\t.update_owe_info\t= qtnf_update_owe_info,\n#ifdef CONFIG_PM\n\t.suspend\t\t= qtnf_suspend,\n\t.resume\t\t\t= qtnf_resume,\n\t.set_wakeup\t\t= qtnf_set_wakeup,\n#endif\n};\n\nstatic void qtnf_cfg80211_reg_notifier(struct wiphy *wiphy,\n\t\t\t\t       struct regulatory_request *req)\n{\n\tstruct qtnf_wmac *mac = wiphy_priv(wiphy);\n\tenum nl80211_band band;\n\tint ret;\n\n\tpr_debug(\"MAC%u: initiator=%d alpha=%c%c\\n\", mac->macid, req->initiator,\n\t\t req->alpha2[0], req->alpha2[1]);\n\n\tret = qtnf_cmd_reg_notify(mac, req, qtnf_slave_radar_get(),\n\t\t\t\t  qtnf_dfs_offload_get());\n\tif (ret) {\n\t\tpr_err(\"MAC%u: failed to update region to %c%c: %d\\n\",\n\t\t       mac->macid, req->alpha2[0], req->alpha2[1], ret);\n\t\treturn;\n\t}\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; ++band) {\n\t\tif (!wiphy->bands[band])\n\t\t\tcontinue;\n\n\t\tret = qtnf_cmd_band_info_get(mac, wiphy->bands[band]);\n\t\tif (ret)\n\t\t\tpr_err(\"MAC%u: failed to update band %u\\n\",\n\t\t\t       mac->macid, band);\n\t}\n}\n\nstruct wiphy *qtnf_wiphy_allocate(struct qtnf_bus *bus,\n\t\t\t\t  struct platform_device *pdev)\n{\n\tstruct wiphy *wiphy;\n\n\tif (qtnf_dfs_offload_get() &&\n\t    qtnf_hwcap_is_set(&bus->hw_info, QLINK_HW_CAPAB_DFS_OFFLOAD))\n\t\tqtn_cfg80211_ops.start_radar_detection = NULL;\n\n\tif (!qtnf_hwcap_is_set(&bus->hw_info, QLINK_HW_CAPAB_PWR_MGMT))\n\t\tqtn_cfg80211_ops.set_power_mgmt\t= NULL;\n\n\twiphy = wiphy_new(&qtn_cfg80211_ops, sizeof(struct qtnf_wmac));\n\tif (!wiphy)\n\t\treturn NULL;\n\n\tif (pdev)\n\t\tset_wiphy_dev(wiphy, &pdev->dev);\n\telse\n\t\tset_wiphy_dev(wiphy, bus->dev);\n\n\treturn wiphy;\n}\n\nstatic int\nqtnf_wiphy_setup_if_comb(struct wiphy *wiphy, struct qtnf_mac_info *mac_info)\n{\n\tstruct ieee80211_iface_combination *if_comb;\n\tsize_t n_if_comb;\n\tu16 interface_modes = 0;\n\tsize_t i, j;\n\n\tif_comb = mac_info->if_comb;\n\tn_if_comb = mac_info->n_if_comb;\n\n\tif (!if_comb || !n_if_comb)\n\t\treturn -ENOENT;\n\n\tfor (i = 0; i < n_if_comb; i++) {\n\t\tif_comb[i].radar_detect_widths = mac_info->radar_detect_widths;\n\n\t\tfor (j = 0; j < if_comb[i].n_limits; j++)\n\t\t\tinterface_modes |= if_comb[i].limits[j].types;\n\t}\n\n\twiphy->iface_combinations = if_comb;\n\twiphy->n_iface_combinations = n_if_comb;\n\twiphy->interface_modes = interface_modes;\n\n\treturn 0;\n}\n\nint qtnf_wiphy_register(struct qtnf_hw_info *hw_info, struct qtnf_wmac *mac)\n{\n\tstruct wiphy *wiphy = priv_to_wiphy(mac);\n\tstruct qtnf_mac_info *macinfo = &mac->macinfo;\n\tint ret;\n\tbool regdomain_is_known;\n\n\tif (!wiphy) {\n\t\tpr_err(\"invalid wiphy pointer\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\twiphy->frag_threshold = macinfo->frag_thr;\n\twiphy->rts_threshold = macinfo->rts_thr;\n\twiphy->retry_short = macinfo->sretry_limit;\n\twiphy->retry_long = macinfo->lretry_limit;\n\twiphy->coverage_class = macinfo->coverage_class;\n\n\twiphy->max_scan_ssids =\n\t\t(macinfo->max_scan_ssids) ? macinfo->max_scan_ssids : 1;\n\twiphy->max_scan_ie_len = QTNF_MAX_VSIE_LEN;\n\twiphy->mgmt_stypes = qtnf_mgmt_stypes;\n\twiphy->max_remain_on_channel_duration = 5000;\n\twiphy->max_acl_mac_addrs = macinfo->max_acl_mac_addrs;\n\twiphy->max_num_csa_counters = 2;\n\n\tret = qtnf_wiphy_setup_if_comb(wiphy, macinfo);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\twiphy->cipher_suites = qtnf_cipher_suites;\n\twiphy->n_cipher_suites = ARRAY_SIZE(qtnf_cipher_suites);\n\twiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;\n\twiphy->flags |= WIPHY_FLAG_HAVE_AP_SME |\n\t\t\tWIPHY_FLAG_AP_PROBE_RESP_OFFLOAD |\n\t\t\tWIPHY_FLAG_AP_UAPSD |\n\t\t\tWIPHY_FLAG_HAS_CHANNEL_SWITCH |\n\t\t\tWIPHY_FLAG_4ADDR_STATION |\n\t\t\tWIPHY_FLAG_NETNS_OK;\n\twiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;\n\n\tif (qtnf_dfs_offload_get() &&\n\t    qtnf_hwcap_is_set(hw_info, QLINK_HW_CAPAB_DFS_OFFLOAD))\n\t\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_DFS_OFFLOAD);\n\n\tif (qtnf_hwcap_is_set(hw_info, QLINK_HW_CAPAB_SCAN_DWELL))\n\t\twiphy_ext_feature_set(wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_SET_SCAN_DWELL);\n\n\twiphy->probe_resp_offload = NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS |\n\t\t\t\t    NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS2;\n\n\twiphy->available_antennas_tx = macinfo->num_tx_chain;\n\twiphy->available_antennas_rx = macinfo->num_rx_chain;\n\n\twiphy->max_ap_assoc_sta = macinfo->max_ap_assoc_sta;\n\twiphy->ht_capa_mod_mask = &macinfo->ht_cap_mod_mask;\n\twiphy->vht_capa_mod_mask = &macinfo->vht_cap_mod_mask;\n\n\tether_addr_copy(wiphy->perm_addr, mac->macaddr);\n\n\tif (qtnf_hwcap_is_set(hw_info, QLINK_HW_CAPAB_STA_INACT_TIMEOUT))\n\t\twiphy->features |= NL80211_FEATURE_INACTIVITY_TIMER;\n\n\tif (qtnf_hwcap_is_set(hw_info, QLINK_HW_CAPAB_SCAN_RANDOM_MAC_ADDR))\n\t\twiphy->features |= NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR;\n\n\tif (!qtnf_hwcap_is_set(hw_info, QLINK_HW_CAPAB_OBSS_SCAN))\n\t\twiphy->features |= NL80211_FEATURE_NEED_OBSS_SCAN;\n\n\tif (qtnf_hwcap_is_set(hw_info, QLINK_HW_CAPAB_SAE))\n\t\twiphy->features |= NL80211_FEATURE_SAE;\n\n#ifdef CONFIG_PM\n\tif (macinfo->wowlan)\n\t\twiphy->wowlan = macinfo->wowlan;\n#endif\n\n\tregdomain_is_known = isalpha(mac->rd->alpha2[0]) &&\n\t\t\t\tisalpha(mac->rd->alpha2[1]);\n\n\tif (qtnf_hwcap_is_set(hw_info, QLINK_HW_CAPAB_REG_UPDATE)) {\n\t\twiphy->reg_notifier = qtnf_cfg80211_reg_notifier;\n\n\t\tif (mac->rd->alpha2[0] == '9' && mac->rd->alpha2[1] == '9') {\n\t\t\twiphy->regulatory_flags |= REGULATORY_CUSTOM_REG |\n\t\t\t\tREGULATORY_STRICT_REG;\n\t\t\twiphy_apply_custom_regulatory(wiphy, mac->rd);\n\t\t} else if (regdomain_is_known) {\n\t\t\twiphy->regulatory_flags |= REGULATORY_STRICT_REG;\n\t\t}\n\t} else {\n\t\twiphy->regulatory_flags |= REGULATORY_WIPHY_SELF_MANAGED;\n\t}\n\n\tif (mac->macinfo.extended_capabilities_len) {\n\t\twiphy->extended_capabilities =\n\t\t\tmac->macinfo.extended_capabilities;\n\t\twiphy->extended_capabilities_mask =\n\t\t\tmac->macinfo.extended_capabilities_mask;\n\t\twiphy->extended_capabilities_len =\n\t\t\tmac->macinfo.extended_capabilities_len;\n\t}\n\n\tstrscpy(wiphy->fw_version, hw_info->fw_version,\n\t\tsizeof(wiphy->fw_version));\n\twiphy->hw_version = hw_info->hw_version;\n\n\tret = wiphy_register(wiphy);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED)\n\t\tret = regulatory_set_wiphy_regd(wiphy, mac->rd);\n\telse if (regdomain_is_known)\n\t\tret = regulatory_hint(wiphy, mac->rd->alpha2);\n\nout:\n\treturn ret;\n}\n\nvoid qtnf_netdev_updown(struct net_device *ndev, bool up)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(ndev);\n\n\tif (qtnf_cmd_send_updown_intf(vif, up))\n\t\tpr_err(\"failed to send %s command to VIF%u.%u\\n\",\n\t\t       up ? \"UP\" : \"DOWN\", vif->mac->macid, vif->vifid);\n}\n\nvoid qtnf_virtual_intf_cleanup(struct net_device *ndev)\n{\n\tstruct qtnf_vif *vif = qtnf_netdev_get_priv(ndev);\n\tstruct qtnf_wmac *mac = wiphy_priv(vif->wdev.wiphy);\n\n\tif (vif->wdev.iftype == NL80211_IFTYPE_STATION)\n\t\tqtnf_disconnect(vif->wdev.wiphy, ndev,\n\t\t\t\tWLAN_REASON_DEAUTH_LEAVING);\n\n\tqtnf_scan_done(mac, true);\n}\n\nvoid qtnf_cfg80211_vif_reset(struct qtnf_vif *vif)\n{\n\tif (vif->wdev.iftype == NL80211_IFTYPE_STATION)\n\t\tcfg80211_disconnected(vif->netdev, WLAN_REASON_DEAUTH_LEAVING,\n\t\t\t\t      NULL, 0, 1, GFP_KERNEL);\n\n\tcfg80211_shutdown_all_interfaces(vif->wdev.wiphy);\n}\n\nvoid qtnf_band_init_rates(struct ieee80211_supported_band *band)\n{\n\tswitch (band->band) {\n\tcase NL80211_BAND_2GHZ:\n\t\tband->bitrates = qtnf_rates_2g;\n\t\tband->n_bitrates = ARRAY_SIZE(qtnf_rates_2g);\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\tband->bitrates = qtnf_rates_5g;\n\t\tband->n_bitrates = ARRAY_SIZE(qtnf_rates_5g);\n\t\tbreak;\n\tdefault:\n\t\tband->bitrates = NULL;\n\t\tband->n_bitrates = 0;\n\t\tbreak;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}