{
  "module_name": "qlink_util.c",
  "hash_id": "a36fe45996e5ef982d783d7cf01995af8c0554133c314c2722aac62254f317e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/quantenna/qtnfmac/qlink_util.c",
  "human_readable_source": "\n \n\n#include <linux/nl80211.h>\n\n#include \"qlink_util.h\"\n\nu16 qlink_iface_type_to_nl_mask(u16 qlink_type)\n{\n\tu16 result = 0;\n\n\tswitch (qlink_type) {\n\tcase QLINK_IFTYPE_AP:\n\t\tresult |= BIT(NL80211_IFTYPE_AP);\n\t\tbreak;\n\tcase QLINK_IFTYPE_STATION:\n\t\tresult |= BIT(NL80211_IFTYPE_STATION);\n\t\tbreak;\n\tcase QLINK_IFTYPE_ADHOC:\n\t\tresult |= BIT(NL80211_IFTYPE_ADHOC);\n\t\tbreak;\n\tcase QLINK_IFTYPE_MONITOR:\n\t\tresult |= BIT(NL80211_IFTYPE_MONITOR);\n\t\tbreak;\n\tcase QLINK_IFTYPE_WDS:\n\t\tresult |= BIT(NL80211_IFTYPE_WDS);\n\t\tbreak;\n\tcase QLINK_IFTYPE_AP_VLAN:\n\t\tresult |= BIT(NL80211_IFTYPE_AP_VLAN);\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nu8 qlink_chan_width_mask_to_nl(u16 qlink_mask)\n{\n\tu8 result = 0;\n\n\tif (qlink_mask & BIT(QLINK_CHAN_WIDTH_5))\n\t\tresult |= BIT(NL80211_CHAN_WIDTH_5);\n\n\tif (qlink_mask & BIT(QLINK_CHAN_WIDTH_10))\n\t\tresult |= BIT(NL80211_CHAN_WIDTH_10);\n\n\tif (qlink_mask & BIT(QLINK_CHAN_WIDTH_20_NOHT))\n\t\tresult |= BIT(NL80211_CHAN_WIDTH_20_NOHT);\n\n\tif (qlink_mask & BIT(QLINK_CHAN_WIDTH_20))\n\t\tresult |= BIT(NL80211_CHAN_WIDTH_20);\n\n\tif (qlink_mask & BIT(QLINK_CHAN_WIDTH_40))\n\t\tresult |= BIT(NL80211_CHAN_WIDTH_40);\n\n\tif (qlink_mask & BIT(QLINK_CHAN_WIDTH_80))\n\t\tresult |= BIT(NL80211_CHAN_WIDTH_80);\n\n\tif (qlink_mask & BIT(QLINK_CHAN_WIDTH_80P80))\n\t\tresult |= BIT(NL80211_CHAN_WIDTH_80P80);\n\n\tif (qlink_mask & BIT(QLINK_CHAN_WIDTH_160))\n\t\tresult |= BIT(NL80211_CHAN_WIDTH_160);\n\n\treturn result;\n}\n\nstatic enum nl80211_chan_width qlink_chanwidth_to_nl(u8 qlw)\n{\n\tswitch (qlw) {\n\tcase QLINK_CHAN_WIDTH_20_NOHT:\n\t\treturn NL80211_CHAN_WIDTH_20_NOHT;\n\tcase QLINK_CHAN_WIDTH_20:\n\t\treturn NL80211_CHAN_WIDTH_20;\n\tcase QLINK_CHAN_WIDTH_40:\n\t\treturn NL80211_CHAN_WIDTH_40;\n\tcase QLINK_CHAN_WIDTH_80:\n\t\treturn NL80211_CHAN_WIDTH_80;\n\tcase QLINK_CHAN_WIDTH_80P80:\n\t\treturn NL80211_CHAN_WIDTH_80P80;\n\tcase QLINK_CHAN_WIDTH_160:\n\t\treturn NL80211_CHAN_WIDTH_160;\n\tcase QLINK_CHAN_WIDTH_5:\n\t\treturn NL80211_CHAN_WIDTH_5;\n\tcase QLINK_CHAN_WIDTH_10:\n\t\treturn NL80211_CHAN_WIDTH_10;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nstatic u8 qlink_chanwidth_nl_to_qlink(enum nl80211_chan_width nlwidth)\n{\n\tswitch (nlwidth) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\treturn QLINK_CHAN_WIDTH_20_NOHT;\n\tcase NL80211_CHAN_WIDTH_20:\n\t\treturn QLINK_CHAN_WIDTH_20;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\treturn QLINK_CHAN_WIDTH_40;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\treturn QLINK_CHAN_WIDTH_80;\n\tcase NL80211_CHAN_WIDTH_80P80:\n\t\treturn QLINK_CHAN_WIDTH_80P80;\n\tcase NL80211_CHAN_WIDTH_160:\n\t\treturn QLINK_CHAN_WIDTH_160;\n\tcase NL80211_CHAN_WIDTH_5:\n\t\treturn QLINK_CHAN_WIDTH_5;\n\tcase NL80211_CHAN_WIDTH_10:\n\t\treturn QLINK_CHAN_WIDTH_10;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nvoid qlink_chandef_q2cfg(struct wiphy *wiphy,\n\t\t\t const struct qlink_chandef *qch,\n\t\t\t struct cfg80211_chan_def *chdef)\n{\n\tstruct ieee80211_channel *chan;\n\n\tchan = ieee80211_get_channel(wiphy, le16_to_cpu(qch->chan.center_freq));\n\n\tchdef->chan = chan;\n\tchdef->center_freq1 = le16_to_cpu(qch->center_freq1);\n\tchdef->center_freq2 = le16_to_cpu(qch->center_freq2);\n\tchdef->width = qlink_chanwidth_to_nl(qch->width);\n\tchdef->edmg.bw_config = 0;\n\tchdef->edmg.channels = 0;\n}\n\nvoid qlink_chandef_cfg2q(const struct cfg80211_chan_def *chdef,\n\t\t\t struct qlink_chandef *qch)\n{\n\tstruct ieee80211_channel *chan = chdef->chan;\n\n\tqch->chan.hw_value = cpu_to_le16(chan->hw_value);\n\tqch->chan.center_freq = cpu_to_le16(chan->center_freq);\n\tqch->chan.flags = cpu_to_le32(chan->flags);\n\n\tqch->center_freq1 = cpu_to_le16(chdef->center_freq1);\n\tqch->center_freq2 = cpu_to_le16(chdef->center_freq2);\n\tqch->width = qlink_chanwidth_nl_to_qlink(chdef->width);\n}\n\nenum qlink_hidden_ssid qlink_hidden_ssid_nl2q(enum nl80211_hidden_ssid nl_val)\n{\n\tswitch (nl_val) {\n\tcase NL80211_HIDDEN_SSID_ZERO_LEN:\n\t\treturn QLINK_HIDDEN_SSID_ZERO_LEN;\n\tcase NL80211_HIDDEN_SSID_ZERO_CONTENTS:\n\t\treturn QLINK_HIDDEN_SSID_ZERO_CONTENTS;\n\tcase NL80211_HIDDEN_SSID_NOT_IN_USE:\n\tdefault:\n\t\treturn QLINK_HIDDEN_SSID_NOT_IN_USE;\n\t}\n}\n\nbool qtnf_utils_is_bit_set(const u8 *arr, unsigned int bit,\n\t\t\t   unsigned int arr_max_len)\n{\n\tunsigned int idx = bit / BITS_PER_BYTE;\n\tu8 mask = 1 << (bit - (idx * BITS_PER_BYTE));\n\n\tif (idx >= arr_max_len)\n\t\treturn false;\n\n\treturn arr[idx] & mask;\n}\n\nvoid qlink_acl_data_cfg2q(const struct cfg80211_acl_data *acl,\n\t\t\t  struct qlink_acl_data *qacl)\n{\n\tswitch (acl->acl_policy) {\n\tcase NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED:\n\t\tqacl->policy =\n\t\t\tcpu_to_le32(QLINK_ACL_POLICY_ACCEPT_UNLESS_LISTED);\n\t\tbreak;\n\tcase NL80211_ACL_POLICY_DENY_UNLESS_LISTED:\n\t\tqacl->policy = cpu_to_le32(QLINK_ACL_POLICY_DENY_UNLESS_LISTED);\n\t\tbreak;\n\t}\n\n\tqacl->num_entries = cpu_to_le32(acl->n_acl_entries);\n\tmemcpy(qacl->mac_addrs, acl->mac_addrs,\n\t       acl->n_acl_entries * sizeof(*qacl->mac_addrs));\n}\n\nenum qlink_band qlink_utils_band_cfg2q(enum nl80211_band band)\n{\n\tswitch (band) {\n\tcase NL80211_BAND_2GHZ:\n\t\treturn QLINK_BAND_2GHZ;\n\tcase NL80211_BAND_5GHZ:\n\t\treturn QLINK_BAND_5GHZ;\n\tcase NL80211_BAND_60GHZ:\n\t\treturn QLINK_BAND_60GHZ;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nenum qlink_dfs_state qlink_utils_dfs_state_cfg2q(enum nl80211_dfs_state state)\n{\n\tswitch (state) {\n\tcase NL80211_DFS_USABLE:\n\t\treturn QLINK_DFS_USABLE;\n\tcase NL80211_DFS_AVAILABLE:\n\t\treturn QLINK_DFS_AVAILABLE;\n\tcase NL80211_DFS_UNAVAILABLE:\n\tdefault:\n\t\treturn QLINK_DFS_UNAVAILABLE;\n\t}\n}\n\nu32 qlink_utils_chflags_cfg2q(u32 cfgflags)\n{\n\tu32 flags = 0;\n\n\tif (cfgflags & IEEE80211_CHAN_DISABLED)\n\t\tflags |= QLINK_CHAN_DISABLED;\n\n\tif (cfgflags & IEEE80211_CHAN_NO_IR)\n\t\tflags |= QLINK_CHAN_NO_IR;\n\n\tif (cfgflags & IEEE80211_CHAN_RADAR)\n\t\tflags |= QLINK_CHAN_RADAR;\n\n\tif (cfgflags & IEEE80211_CHAN_NO_HT40PLUS)\n\t\tflags |= QLINK_CHAN_NO_HT40PLUS;\n\n\tif (cfgflags & IEEE80211_CHAN_NO_HT40MINUS)\n\t\tflags |= QLINK_CHAN_NO_HT40MINUS;\n\n\tif (cfgflags & IEEE80211_CHAN_NO_80MHZ)\n\t\tflags |= QLINK_CHAN_NO_80MHZ;\n\n\tif (cfgflags & IEEE80211_CHAN_NO_160MHZ)\n\t\tflags |= QLINK_CHAN_NO_160MHZ;\n\n\treturn flags;\n}\n\nstatic u32 qtnf_reg_rule_flags_parse(u32 qflags)\n{\n\tu32 flags = 0;\n\n\tif (qflags & QLINK_RRF_NO_OFDM)\n\t\tflags |= NL80211_RRF_NO_OFDM;\n\n\tif (qflags & QLINK_RRF_NO_CCK)\n\t\tflags |= NL80211_RRF_NO_CCK;\n\n\tif (qflags & QLINK_RRF_NO_INDOOR)\n\t\tflags |= NL80211_RRF_NO_INDOOR;\n\n\tif (qflags & QLINK_RRF_NO_OUTDOOR)\n\t\tflags |= NL80211_RRF_NO_OUTDOOR;\n\n\tif (qflags & QLINK_RRF_DFS)\n\t\tflags |= NL80211_RRF_DFS;\n\n\tif (qflags & QLINK_RRF_PTP_ONLY)\n\t\tflags |= NL80211_RRF_PTP_ONLY;\n\n\tif (qflags & QLINK_RRF_PTMP_ONLY)\n\t\tflags |= NL80211_RRF_PTMP_ONLY;\n\n\tif (qflags & QLINK_RRF_NO_IR)\n\t\tflags |= NL80211_RRF_NO_IR;\n\n\tif (qflags & QLINK_RRF_AUTO_BW)\n\t\tflags |= NL80211_RRF_AUTO_BW;\n\n\tif (qflags & QLINK_RRF_IR_CONCURRENT)\n\t\tflags |= NL80211_RRF_IR_CONCURRENT;\n\n\tif (qflags & QLINK_RRF_NO_HT40MINUS)\n\t\tflags |= NL80211_RRF_NO_HT40MINUS;\n\n\tif (qflags & QLINK_RRF_NO_HT40PLUS)\n\t\tflags |= NL80211_RRF_NO_HT40PLUS;\n\n\tif (qflags & QLINK_RRF_NO_80MHZ)\n\t\tflags |= NL80211_RRF_NO_80MHZ;\n\n\tif (qflags & QLINK_RRF_NO_160MHZ)\n\t\tflags |= NL80211_RRF_NO_160MHZ;\n\n\treturn flags;\n}\n\nvoid qlink_utils_regrule_q2nl(struct ieee80211_reg_rule *rule,\n\t\t\t      const struct qlink_tlv_reg_rule *tlv)\n{\n\trule->freq_range.start_freq_khz = le32_to_cpu(tlv->start_freq_khz);\n\trule->freq_range.end_freq_khz = le32_to_cpu(tlv->end_freq_khz);\n\trule->freq_range.max_bandwidth_khz =\n\t\tle32_to_cpu(tlv->max_bandwidth_khz);\n\trule->power_rule.max_antenna_gain = le32_to_cpu(tlv->max_antenna_gain);\n\trule->power_rule.max_eirp = le32_to_cpu(tlv->max_eirp);\n\trule->dfs_cac_ms = le32_to_cpu(tlv->dfs_cac_ms);\n\trule->flags = qtnf_reg_rule_flags_parse(le32_to_cpu(tlv->flags));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}