{
  "module_name": "trans.c",
  "hash_id": "10735e262b97c65d6a737b10ae2f3cfc76382f143cb9962658a378bf0e0fd483",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/quantenna/qtnfmac/trans.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\n#include \"core.h\"\n#include \"commands.h\"\n#include \"event.h\"\n#include \"bus.h\"\n\n#define QTNF_DEF_SYNC_CMD_TIMEOUT\t(5 * HZ)\n\nint qtnf_trans_send_cmd_with_resp(struct qtnf_bus *bus, struct sk_buff *cmd_skb,\n\t\t\t\t  struct sk_buff **response_skb)\n{\n\tstruct qtnf_cmd_ctl_node *ctl_node = &bus->trans.curr_cmd;\n\tstruct qlink_cmd *cmd = (void *)cmd_skb->data;\n\tint ret = 0;\n\tlong status;\n\tbool resp_not_handled = true;\n\tstruct sk_buff *resp_skb = NULL;\n\n\tif (unlikely(!response_skb)) {\n\t\tdev_kfree_skb(cmd_skb);\n\t\treturn -EFAULT;\n\t}\n\n\tspin_lock(&ctl_node->resp_lock);\n\tctl_node->seq_num++;\n\tcmd->seq_num = cpu_to_le16(ctl_node->seq_num);\n\tWARN(ctl_node->resp_skb, \"qtnfmac: response skb not empty\\n\");\n\tctl_node->waiting_for_resp = true;\n\tspin_unlock(&ctl_node->resp_lock);\n\n\tret = qtnf_bus_control_tx(bus, cmd_skb);\n\tdev_kfree_skb(cmd_skb);\n\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tstatus = wait_for_completion_interruptible_timeout(\n\t\t\t\t\t\t&ctl_node->cmd_resp_completion,\n\t\t\t\t\t\tQTNF_DEF_SYNC_CMD_TIMEOUT);\n\n\tspin_lock(&ctl_node->resp_lock);\n\tresp_not_handled = ctl_node->waiting_for_resp;\n\tresp_skb = ctl_node->resp_skb;\n\tctl_node->resp_skb = NULL;\n\tctl_node->waiting_for_resp = false;\n\tspin_unlock(&ctl_node->resp_lock);\n\n\tif (unlikely(status <= 0)) {\n\t\tif (status == 0) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tpr_err(\"response timeout\\n\");\n\t\t} else {\n\t\t\tret = -EINTR;\n\t\t\tpr_debug(\"interrupted\\n\");\n\t\t}\n\t}\n\n\tif (unlikely(!resp_skb || resp_not_handled)) {\n\t\tif (!ret)\n\t\t\tret = -EFAULT;\n\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\t*response_skb = resp_skb;\n\nout:\n\tif (unlikely(resp_skb && resp_not_handled))\n\t\tdev_kfree_skb(resp_skb);\n\n\treturn ret;\n}\n\nstatic void qtnf_trans_signal_cmdresp(struct qtnf_bus *bus, struct sk_buff *skb)\n{\n\tstruct qtnf_cmd_ctl_node *ctl_node = &bus->trans.curr_cmd;\n\tconst struct qlink_resp *resp = (const struct qlink_resp *)skb->data;\n\tconst u16 recvd_seq_num = le16_to_cpu(resp->seq_num);\n\n\tspin_lock(&ctl_node->resp_lock);\n\n\tif (unlikely(!ctl_node->waiting_for_resp)) {\n\t\tpr_err(\"unexpected response\\n\");\n\t\tgoto out_err;\n\t}\n\n\tif (unlikely(recvd_seq_num != ctl_node->seq_num)) {\n\t\tpr_err(\"seq num mismatch\\n\");\n\t\tgoto out_err;\n\t}\n\n\tctl_node->resp_skb = skb;\n\tctl_node->waiting_for_resp = false;\n\n\tspin_unlock(&ctl_node->resp_lock);\n\n\tcomplete(&ctl_node->cmd_resp_completion);\n\treturn;\n\nout_err:\n\tspin_unlock(&ctl_node->resp_lock);\n\tdev_kfree_skb(skb);\n}\n\nstatic int qtnf_trans_event_enqueue(struct qtnf_bus *bus, struct sk_buff *skb)\n{\n\tstruct qtnf_qlink_transport *trans = &bus->trans;\n\n\tif (likely(skb_queue_len(&trans->event_queue) <\n\t\t   trans->event_queue_max_len)) {\n\t\tskb_queue_tail(&trans->event_queue, skb);\n\t\tqueue_work(bus->workqueue, &bus->event_work);\n\t} else {\n\t\tpr_warn(\"event dropped due to queue overflow\\n\");\n\t\tdev_kfree_skb(skb);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nvoid qtnf_trans_init(struct qtnf_bus *bus)\n{\n\tstruct qtnf_qlink_transport *trans = &bus->trans;\n\n\tinit_completion(&trans->curr_cmd.cmd_resp_completion);\n\tspin_lock_init(&trans->curr_cmd.resp_lock);\n\n\tspin_lock(&trans->curr_cmd.resp_lock);\n\ttrans->curr_cmd.seq_num = 0;\n\ttrans->curr_cmd.waiting_for_resp = false;\n\ttrans->curr_cmd.resp_skb = NULL;\n\tspin_unlock(&trans->curr_cmd.resp_lock);\n\n\t \n\tskb_queue_head_init(&trans->event_queue);\n\ttrans->event_queue_max_len = QTNF_MAX_EVENT_QUEUE_LEN;\n}\n\nstatic void qtnf_trans_free_events(struct qtnf_bus *bus)\n{\n\tstruct sk_buff_head *event_queue = &bus->trans.event_queue;\n\tstruct sk_buff *current_event_skb = skb_dequeue(event_queue);\n\n\twhile (current_event_skb) {\n\t\tdev_kfree_skb_any(current_event_skb);\n\t\tcurrent_event_skb = skb_dequeue(event_queue);\n\t}\n}\n\nvoid qtnf_trans_free(struct qtnf_bus *bus)\n{\n\tif (!bus) {\n\t\tpr_err(\"invalid bus pointer\\n\");\n\t\treturn;\n\t}\n\n\tqtnf_trans_free_events(bus);\n}\n\nint qtnf_trans_handle_rx_ctl_packet(struct qtnf_bus *bus, struct sk_buff *skb)\n{\n\tconst struct qlink_msg_header *header = (void *)skb->data;\n\tint ret = -1;\n\n\tif (unlikely(skb->len < sizeof(*header))) {\n\t\tpr_warn(\"packet is too small: %u\\n\", skb->len);\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tif (unlikely(skb->len != le16_to_cpu(header->len))) {\n\t\tpr_warn(\"cmd reply length mismatch: %u != %u\\n\",\n\t\t\tskb->len, le16_to_cpu(header->len));\n\t\tdev_kfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\n\tswitch (le16_to_cpu(header->type)) {\n\tcase QLINK_MSG_TYPE_CMDRSP:\n\t\tif (unlikely(skb->len < sizeof(struct qlink_cmd))) {\n\t\t\tpr_warn(\"cmd reply too short: %u\\n\", skb->len);\n\t\t\tdev_kfree_skb(skb);\n\t\t\tbreak;\n\t\t}\n\n\t\tqtnf_trans_signal_cmdresp(bus, skb);\n\t\tbreak;\n\tcase QLINK_MSG_TYPE_EVENT:\n\t\tif (unlikely(skb->len < sizeof(struct qlink_event))) {\n\t\t\tpr_warn(\"event too short: %u\\n\", skb->len);\n\t\t\tdev_kfree_skb(skb);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = qtnf_trans_event_enqueue(bus, skb);\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"unknown packet type: %x\\n\", le16_to_cpu(header->type));\n\t\tdev_kfree_skb(skb);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(qtnf_trans_handle_rx_ctl_packet);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}