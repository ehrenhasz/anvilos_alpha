{
  "module_name": "shm_ipc.c",
  "hash_id": "dbee48abe3ebbac272dd95e7e426562b3a19075cf61a5f2c0cda67cdae51273c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/quantenna/qtnfmac/shm_ipc.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/io.h>\n\n#include \"shm_ipc.h\"\n\n#undef pr_fmt\n#define pr_fmt(fmt)\t\"qtnfmac shm_ipc: %s: \" fmt, __func__\n\nstatic bool qtnf_shm_ipc_has_new_data(struct qtnf_shm_ipc *ipc)\n{\n\tconst u32 flags = readl(&ipc->shm_region->headroom.hdr.flags);\n\n\treturn (flags & QTNF_SHM_IPC_NEW_DATA);\n}\n\nstatic void qtnf_shm_handle_new_data(struct qtnf_shm_ipc *ipc)\n{\n\tsize_t size;\n\tbool rx_buff_ok = true;\n\tstruct qtnf_shm_ipc_region_header __iomem *shm_reg_hdr;\n\n\tshm_reg_hdr = &ipc->shm_region->headroom.hdr;\n\n\tsize = readw(&shm_reg_hdr->data_len);\n\n\tif (unlikely(size == 0 || size > QTN_IPC_MAX_DATA_SZ)) {\n\t\tpr_err(\"wrong rx packet size: %zu\\n\", size);\n\t\trx_buff_ok = false;\n\t}\n\n\tif (likely(rx_buff_ok)) {\n\t\tipc->rx_packet_count++;\n\t\tipc->rx_callback.fn(ipc->rx_callback.arg,\n\t\t\t\t    ipc->shm_region->data, size);\n\t}\n\n\twritel(QTNF_SHM_IPC_ACK, &shm_reg_hdr->flags);\n\treadl(&shm_reg_hdr->flags);  \n\n\tipc->interrupt.fn(ipc->interrupt.arg);\n}\n\nstatic void qtnf_shm_ipc_irq_work(struct work_struct *work)\n{\n\tstruct qtnf_shm_ipc *ipc = container_of(work, struct qtnf_shm_ipc,\n\t\t\t\t\t\tirq_work);\n\n\twhile (qtnf_shm_ipc_has_new_data(ipc))\n\t\tqtnf_shm_handle_new_data(ipc);\n}\n\nstatic void qtnf_shm_ipc_irq_inbound_handler(struct qtnf_shm_ipc *ipc)\n{\n\tu32 flags;\n\n\tflags = readl(&ipc->shm_region->headroom.hdr.flags);\n\n\tif (flags & QTNF_SHM_IPC_NEW_DATA)\n\t\tqueue_work(ipc->workqueue, &ipc->irq_work);\n}\n\nstatic void qtnf_shm_ipc_irq_outbound_handler(struct qtnf_shm_ipc *ipc)\n{\n\tu32 flags;\n\n\tif (!READ_ONCE(ipc->waiting_for_ack))\n\t\treturn;\n\n\tflags = readl(&ipc->shm_region->headroom.hdr.flags);\n\n\tif (flags & QTNF_SHM_IPC_ACK) {\n\t\tWRITE_ONCE(ipc->waiting_for_ack, 0);\n\t\tcomplete(&ipc->tx_completion);\n\t}\n}\n\nint qtnf_shm_ipc_init(struct qtnf_shm_ipc *ipc,\n\t\t      enum qtnf_shm_ipc_direction direction,\n\t\t      struct qtnf_shm_ipc_region __iomem *shm_region,\n\t\t      struct workqueue_struct *workqueue,\n\t\t      const struct qtnf_shm_ipc_int *interrupt,\n\t\t      const struct qtnf_shm_ipc_rx_callback *rx_callback)\n{\n\tBUILD_BUG_ON(offsetof(struct qtnf_shm_ipc_region, data) !=\n\t\t     QTN_IPC_REG_HDR_SZ);\n\tBUILD_BUG_ON(sizeof(struct qtnf_shm_ipc_region) > QTN_IPC_REG_SZ);\n\n\tipc->shm_region = shm_region;\n\tipc->direction = direction;\n\tipc->interrupt = *interrupt;\n\tipc->rx_callback = *rx_callback;\n\tipc->tx_packet_count = 0;\n\tipc->rx_packet_count = 0;\n\tipc->workqueue = workqueue;\n\tipc->waiting_for_ack = 0;\n\tipc->tx_timeout_count = 0;\n\n\tswitch (direction) {\n\tcase QTNF_SHM_IPC_OUTBOUND:\n\t\tipc->irq_handler = qtnf_shm_ipc_irq_outbound_handler;\n\t\tbreak;\n\tcase QTNF_SHM_IPC_INBOUND:\n\t\tipc->irq_handler = qtnf_shm_ipc_irq_inbound_handler;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tINIT_WORK(&ipc->irq_work, qtnf_shm_ipc_irq_work);\n\tinit_completion(&ipc->tx_completion);\n\n\treturn 0;\n}\n\nvoid qtnf_shm_ipc_free(struct qtnf_shm_ipc *ipc)\n{\n\tcomplete_all(&ipc->tx_completion);\n}\n\nint qtnf_shm_ipc_send(struct qtnf_shm_ipc *ipc, const u8 *buf, size_t size)\n{\n\tint ret = 0;\n\tstruct qtnf_shm_ipc_region_header __iomem *shm_reg_hdr;\n\n\tshm_reg_hdr = &ipc->shm_region->headroom.hdr;\n\n\tif (unlikely(size > QTN_IPC_MAX_DATA_SZ))\n\t\treturn -E2BIG;\n\n\tipc->tx_packet_count++;\n\n\twritew(size, &shm_reg_hdr->data_len);\n\tmemcpy_toio(ipc->shm_region->data, buf, size);\n\n\t \n\tdma_wmb();\n\n\tWRITE_ONCE(ipc->waiting_for_ack, 1);\n\n\t \n\twmb();\n\n\twritel(QTNF_SHM_IPC_NEW_DATA, &shm_reg_hdr->flags);\n\treadl(&shm_reg_hdr->flags);  \n\n\tipc->interrupt.fn(ipc->interrupt.arg);\n\n\tif (!wait_for_completion_timeout(&ipc->tx_completion,\n\t\t\t\t\t QTN_SHM_IPC_ACK_TIMEOUT)) {\n\t\tret = -ETIMEDOUT;\n\t\tipc->tx_timeout_count++;\n\t\tpr_err(\"TX ACK timeout\\n\");\n\t}\n\n\t \n\tWRITE_ONCE(ipc->waiting_for_ack, 0);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}