{
  "module_name": "cmd.c",
  "hash_id": "6e5e0b128c6db8f8c669c7b0e4d5a94c423672cd7217720085b0422ab5761e1e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wl12xx/cmd.c",
  "human_readable_source": "\n \n\n#include \"../wlcore/cmd.h\"\n#include \"../wlcore/debug.h\"\n\n#include \"wl12xx.h\"\n#include \"cmd.h\"\n\nint wl1271_cmd_ext_radio_parms(struct wl1271 *wl)\n{\n\tstruct wl1271_ext_radio_parms_cmd *ext_radio_parms;\n\tstruct wl12xx_priv *priv = wl->priv;\n\tstruct wl12xx_conf_rf *rf = &priv->conf.rf;\n\tint ret;\n\n\tif (!wl->nvs)\n\t\treturn -ENODEV;\n\n\text_radio_parms = kzalloc(sizeof(*ext_radio_parms), GFP_KERNEL);\n\tif (!ext_radio_parms)\n\t\treturn -ENOMEM;\n\n\text_radio_parms->test.id = TEST_CMD_INI_FILE_RF_EXTENDED_PARAM;\n\n\tmemcpy(ext_radio_parms->tx_per_channel_power_compensation_2,\n\t       rf->tx_per_channel_power_compensation_2,\n\t       CONF_TX_PWR_COMPENSATION_LEN_2);\n\tmemcpy(ext_radio_parms->tx_per_channel_power_compensation_5,\n\t       rf->tx_per_channel_power_compensation_5,\n\t       CONF_TX_PWR_COMPENSATION_LEN_5);\n\n\twl1271_dump(DEBUG_CMD, \"TEST_CMD_INI_FILE_EXT_RADIO_PARAM: \",\n\t\t    ext_radio_parms, sizeof(*ext_radio_parms));\n\n\tret = wl1271_cmd_test(wl, ext_radio_parms, sizeof(*ext_radio_parms), 0);\n\tif (ret < 0)\n\t\twl1271_warning(\"TEST_CMD_INI_FILE_RF_EXTENDED_PARAM failed\");\n\n\tkfree(ext_radio_parms);\n\treturn ret;\n}\n\nint wl1271_cmd_general_parms(struct wl1271 *wl)\n{\n\tstruct wl1271_general_parms_cmd *gen_parms;\n\tstruct wl1271_ini_general_params *gp =\n\t\t&((struct wl1271_nvs_file *)wl->nvs)->general_params;\n\tstruct wl12xx_priv *priv = wl->priv;\n\tbool answer = false;\n\tint ret;\n\n\tif (!wl->nvs)\n\t\treturn -ENODEV;\n\n\tif (gp->tx_bip_fem_manufacturer >= WL1271_INI_FEM_MODULE_COUNT) {\n\t\twl1271_warning(\"FEM index from INI out of bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tgen_parms = kzalloc(sizeof(*gen_parms), GFP_KERNEL);\n\tif (!gen_parms)\n\t\treturn -ENOMEM;\n\n\tgen_parms->test.id = TEST_CMD_INI_FILE_GENERAL_PARAM;\n\n\tmemcpy(&gen_parms->general_params, gp, sizeof(*gp));\n\n\t \n\tif (wl->plt_mode == PLT_FEM_DETECT)\n\t\tgen_parms->general_params.tx_bip_fem_auto_detect = true;\n\n\tif (gen_parms->general_params.tx_bip_fem_auto_detect)\n\t\tanswer = true;\n\n\t \n\tgen_parms->general_params.ref_clock = priv->ref_clock;\n\n\tret = wl1271_cmd_test(wl, gen_parms, sizeof(*gen_parms), answer);\n\tif (ret < 0) {\n\t\twl1271_warning(\"CMD_INI_FILE_GENERAL_PARAM failed\");\n\t\tgoto out;\n\t}\n\n\tgp->tx_bip_fem_manufacturer =\n\t\tgen_parms->general_params.tx_bip_fem_manufacturer;\n\n\tif (gp->tx_bip_fem_manufacturer >= WL1271_INI_FEM_MODULE_COUNT) {\n\t\twl1271_warning(\"FEM index from FW out of bounds\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (wl->plt_mode == PLT_FEM_DETECT)\n\t\twl->fem_manuf = gp->tx_bip_fem_manufacturer;\n\n\twl1271_debug(DEBUG_CMD, \"FEM autodetect: %s, manufacturer: %d\\n\",\n\t\tanswer == false ?\n\t\t\t\"manual\" :\n\t\twl->plt_mode == PLT_FEM_DETECT ?\n\t\t\t\"calibrator_fem_detect\" :\n\t\t\t\"auto\",\n\t\tgp->tx_bip_fem_manufacturer);\n\nout:\n\tkfree(gen_parms);\n\treturn ret;\n}\n\nint wl128x_cmd_general_parms(struct wl1271 *wl)\n{\n\tstruct wl128x_general_parms_cmd *gen_parms;\n\tstruct wl128x_ini_general_params *gp =\n\t\t&((struct wl128x_nvs_file *)wl->nvs)->general_params;\n\tstruct wl12xx_priv *priv = wl->priv;\n\tbool answer = false;\n\tint ret;\n\n\tif (!wl->nvs)\n\t\treturn -ENODEV;\n\n\tif (gp->tx_bip_fem_manufacturer >= WL1271_INI_FEM_MODULE_COUNT) {\n\t\twl1271_warning(\"FEM index from ini out of bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tgen_parms = kzalloc(sizeof(*gen_parms), GFP_KERNEL);\n\tif (!gen_parms)\n\t\treturn -ENOMEM;\n\n\tgen_parms->test.id = TEST_CMD_INI_FILE_GENERAL_PARAM;\n\n\tmemcpy(&gen_parms->general_params, gp, sizeof(*gp));\n\n\t \n\tif (wl->plt_mode == PLT_FEM_DETECT)\n\t\tgen_parms->general_params.tx_bip_fem_auto_detect = true;\n\n\tif (gen_parms->general_params.tx_bip_fem_auto_detect)\n\t\tanswer = true;\n\n\t \n\tgen_parms->general_params.ref_clock = priv->ref_clock;\n\tgen_parms->general_params.tcxo_ref_clock = priv->tcxo_clock;\n\n\tret = wl1271_cmd_test(wl, gen_parms, sizeof(*gen_parms), answer);\n\tif (ret < 0) {\n\t\twl1271_warning(\"CMD_INI_FILE_GENERAL_PARAM failed\");\n\t\tgoto out;\n\t}\n\n\tgp->tx_bip_fem_manufacturer =\n\t\tgen_parms->general_params.tx_bip_fem_manufacturer;\n\n\tif (gp->tx_bip_fem_manufacturer >= WL1271_INI_FEM_MODULE_COUNT) {\n\t\twl1271_warning(\"FEM index from FW out of bounds\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (wl->plt_mode == PLT_FEM_DETECT)\n\t\twl->fem_manuf = gp->tx_bip_fem_manufacturer;\n\n\twl1271_debug(DEBUG_CMD, \"FEM autodetect: %s, manufacturer: %d\\n\",\n\t\tanswer == false ?\n\t\t\t\"manual\" :\n\t\twl->plt_mode == PLT_FEM_DETECT ?\n\t\t\t\"calibrator_fem_detect\" :\n\t\t\t\"auto\",\n\t\tgp->tx_bip_fem_manufacturer);\n\nout:\n\tkfree(gen_parms);\n\treturn ret;\n}\n\nint wl1271_cmd_radio_parms(struct wl1271 *wl)\n{\n\tstruct wl1271_nvs_file *nvs = (struct wl1271_nvs_file *)wl->nvs;\n\tstruct wl1271_radio_parms_cmd *radio_parms;\n\tstruct wl1271_ini_general_params *gp = &nvs->general_params;\n\tint ret, fem_idx;\n\n\tif (!wl->nvs)\n\t\treturn -ENODEV;\n\n\tradio_parms = kzalloc(sizeof(*radio_parms), GFP_KERNEL);\n\tif (!radio_parms)\n\t\treturn -ENOMEM;\n\n\tradio_parms->test.id = TEST_CMD_INI_FILE_RADIO_PARAM;\n\n\tfem_idx = WL12XX_FEM_TO_NVS_ENTRY(gp->tx_bip_fem_manufacturer);\n\n\t \n\tmemcpy(&radio_parms->static_params_2, &nvs->stat_radio_params_2,\n\t       sizeof(struct wl1271_ini_band_params_2));\n\tmemcpy(&radio_parms->dyn_params_2,\n\t       &nvs->dyn_radio_params_2[fem_idx].params,\n\t       sizeof(struct wl1271_ini_fem_params_2));\n\n\t \n\tmemcpy(&radio_parms->static_params_5,\n\t       &nvs->stat_radio_params_5,\n\t       sizeof(struct wl1271_ini_band_params_5));\n\tmemcpy(&radio_parms->dyn_params_5,\n\t       &nvs->dyn_radio_params_5[fem_idx].params,\n\t       sizeof(struct wl1271_ini_fem_params_5));\n\n\twl1271_dump(DEBUG_CMD, \"TEST_CMD_INI_FILE_RADIO_PARAM: \",\n\t\t    radio_parms, sizeof(*radio_parms));\n\n\tret = wl1271_cmd_test(wl, radio_parms, sizeof(*radio_parms), 0);\n\tif (ret < 0)\n\t\twl1271_warning(\"CMD_INI_FILE_RADIO_PARAM failed\");\n\n\tkfree(radio_parms);\n\treturn ret;\n}\n\nint wl128x_cmd_radio_parms(struct wl1271 *wl)\n{\n\tstruct wl128x_nvs_file *nvs = (struct wl128x_nvs_file *)wl->nvs;\n\tstruct wl128x_radio_parms_cmd *radio_parms;\n\tstruct wl128x_ini_general_params *gp = &nvs->general_params;\n\tint ret, fem_idx;\n\n\tif (!wl->nvs)\n\t\treturn -ENODEV;\n\n\tradio_parms = kzalloc(sizeof(*radio_parms), GFP_KERNEL);\n\tif (!radio_parms)\n\t\treturn -ENOMEM;\n\n\tradio_parms->test.id = TEST_CMD_INI_FILE_RADIO_PARAM;\n\n\tfem_idx = WL12XX_FEM_TO_NVS_ENTRY(gp->tx_bip_fem_manufacturer);\n\n\t \n\tmemcpy(&radio_parms->static_params_2, &nvs->stat_radio_params_2,\n\t       sizeof(struct wl128x_ini_band_params_2));\n\tmemcpy(&radio_parms->dyn_params_2,\n\t       &nvs->dyn_radio_params_2[fem_idx].params,\n\t       sizeof(struct wl128x_ini_fem_params_2));\n\n\t \n\tmemcpy(&radio_parms->static_params_5,\n\t       &nvs->stat_radio_params_5,\n\t       sizeof(struct wl128x_ini_band_params_5));\n\tmemcpy(&radio_parms->dyn_params_5,\n\t       &nvs->dyn_radio_params_5[fem_idx].params,\n\t       sizeof(struct wl128x_ini_fem_params_5));\n\n\tradio_parms->fem_vendor_and_options = nvs->fem_vendor_and_options;\n\n\twl1271_dump(DEBUG_CMD, \"TEST_CMD_INI_FILE_RADIO_PARAM: \",\n\t\t    radio_parms, sizeof(*radio_parms));\n\n\tret = wl1271_cmd_test(wl, radio_parms, sizeof(*radio_parms), 0);\n\tif (ret < 0)\n\t\twl1271_warning(\"CMD_INI_FILE_RADIO_PARAM failed\");\n\n\tkfree(radio_parms);\n\treturn ret;\n}\n\nint wl12xx_cmd_channel_switch(struct wl1271 *wl,\n\t\t\t      struct wl12xx_vif *wlvif,\n\t\t\t      struct ieee80211_channel_switch *ch_switch)\n{\n\tstruct wl12xx_cmd_channel_switch *cmd;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"cmd channel switch\");\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcmd->role_id = wlvif->role_id;\n\tcmd->channel = ch_switch->chandef.chan->hw_value;\n\tcmd->switch_time = ch_switch->count;\n\tcmd->stop_tx = ch_switch->block_tx;\n\n\t \n\t \n\tcmd->post_switch_tx_disable = 0;\n\n\tret = wl1271_cmd_send(wl, CMD_CHANNEL_SWITCH, cmd, sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_error(\"failed to send channel switch command\");\n\t\tgoto out_free;\n\t}\n\nout_free:\n\tkfree(cmd);\n\nout:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}