{
  "module_name": "main.c",
  "hash_id": "d64e87bf810efe16db4646fcfd3af0674a9f8b9d4c14424b7d343994de56aa35",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wl18xx/main.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/ip.h>\n#include <linux/firmware.h>\n#include <linux/etherdevice.h>\n#include <linux/irq.h>\n\n#include \"../wlcore/wlcore.h\"\n#include \"../wlcore/debug.h\"\n#include \"../wlcore/io.h\"\n#include \"../wlcore/acx.h\"\n#include \"../wlcore/tx.h\"\n#include \"../wlcore/rx.h\"\n#include \"../wlcore/boot.h\"\n\n#include \"reg.h\"\n#include \"conf.h\"\n#include \"cmd.h\"\n#include \"acx.h\"\n#include \"tx.h\"\n#include \"wl18xx.h\"\n#include \"io.h\"\n#include \"scan.h\"\n#include \"event.h\"\n#include \"debugfs.h\"\n\n#define WL18XX_RX_CHECKSUM_MASK      0x40\n\nstatic char *ht_mode_param = NULL;\nstatic char *board_type_param = NULL;\nstatic bool checksum_param = false;\nstatic int num_rx_desc_param = -1;\n\n \nstatic int dc2dc_param = -1;\nstatic int n_antennas_2_param = -1;\nstatic int n_antennas_5_param = -1;\nstatic int low_band_component_param = -1;\nstatic int low_band_component_type_param = -1;\nstatic int high_band_component_param = -1;\nstatic int high_band_component_type_param = -1;\nstatic int pwr_limit_reference_11_abg_param = -1;\n\nstatic const u8 wl18xx_rate_to_idx_2ghz[] = {\n\t \n\t15,                             \n\t14,                             \n\t13,                             \n\t12,                             \n\t11,                             \n\t10,                             \n\t9,                              \n\t8,                              \n\t7,                              \n\t6,                              \n\t5,                              \n\t4,                              \n\t3,                              \n\t2,                              \n\t1,                              \n\t0,                              \n\n\t11,                             \n\t10,                             \n\t9,                              \n\t8,                              \n\n\t \n\tCONF_HW_RXTX_RATE_UNSUPPORTED,  \n\n\t7,                              \n\t6,                              \n\t3,                              \n\t5,                              \n\t4,                              \n\t2,                              \n\t1,                              \n\t0                               \n};\n\nstatic const u8 wl18xx_rate_to_idx_5ghz[] = {\n\t \n\t15,                            \n\t14,                            \n\t13,                            \n\t12,                            \n\t11,                            \n\t10,                            \n\t9,                             \n\t8,                             \n\t7,                             \n\t6,                             \n\t5,                             \n\t4,                             \n\t3,                             \n\t2,                             \n\t1,                             \n\t0,                             \n\n\t7,                              \n\t6,                              \n\t5,                              \n\t4,                              \n\n\t \n\tCONF_HW_RXTX_RATE_UNSUPPORTED,  \n\n\t3,                              \n\t2,                              \n\tCONF_HW_RXTX_RATE_UNSUPPORTED,  \n\t1,                              \n\t0,                              \n\tCONF_HW_RXTX_RATE_UNSUPPORTED,  \n\tCONF_HW_RXTX_RATE_UNSUPPORTED,  \n\tCONF_HW_RXTX_RATE_UNSUPPORTED,  \n};\n\nstatic const u8 *wl18xx_band_rate_to_idx[] = {\n\t[NL80211_BAND_2GHZ] = wl18xx_rate_to_idx_2ghz,\n\t[NL80211_BAND_5GHZ] = wl18xx_rate_to_idx_5ghz\n};\n\nenum wl18xx_hw_rates {\n\tWL18XX_CONF_HW_RXTX_RATE_MCS15 = 0,\n\tWL18XX_CONF_HW_RXTX_RATE_MCS14,\n\tWL18XX_CONF_HW_RXTX_RATE_MCS13,\n\tWL18XX_CONF_HW_RXTX_RATE_MCS12,\n\tWL18XX_CONF_HW_RXTX_RATE_MCS11,\n\tWL18XX_CONF_HW_RXTX_RATE_MCS10,\n\tWL18XX_CONF_HW_RXTX_RATE_MCS9,\n\tWL18XX_CONF_HW_RXTX_RATE_MCS8,\n\tWL18XX_CONF_HW_RXTX_RATE_MCS7,\n\tWL18XX_CONF_HW_RXTX_RATE_MCS6,\n\tWL18XX_CONF_HW_RXTX_RATE_MCS5,\n\tWL18XX_CONF_HW_RXTX_RATE_MCS4,\n\tWL18XX_CONF_HW_RXTX_RATE_MCS3,\n\tWL18XX_CONF_HW_RXTX_RATE_MCS2,\n\tWL18XX_CONF_HW_RXTX_RATE_MCS1,\n\tWL18XX_CONF_HW_RXTX_RATE_MCS0,\n\tWL18XX_CONF_HW_RXTX_RATE_54,\n\tWL18XX_CONF_HW_RXTX_RATE_48,\n\tWL18XX_CONF_HW_RXTX_RATE_36,\n\tWL18XX_CONF_HW_RXTX_RATE_24,\n\tWL18XX_CONF_HW_RXTX_RATE_22,\n\tWL18XX_CONF_HW_RXTX_RATE_18,\n\tWL18XX_CONF_HW_RXTX_RATE_12,\n\tWL18XX_CONF_HW_RXTX_RATE_11,\n\tWL18XX_CONF_HW_RXTX_RATE_9,\n\tWL18XX_CONF_HW_RXTX_RATE_6,\n\tWL18XX_CONF_HW_RXTX_RATE_5_5,\n\tWL18XX_CONF_HW_RXTX_RATE_2,\n\tWL18XX_CONF_HW_RXTX_RATE_1,\n\tWL18XX_CONF_HW_RXTX_RATE_MAX,\n};\n\nstatic struct wlcore_conf wl18xx_conf = {\n\t.sg = {\n\t\t.params = {\n\t\t\t[WL18XX_CONF_SG_PARAM_0] = 0,\n\t\t\t \n\t\t\t[WL18XX_CONF_SG_ANTENNA_CONFIGURATION] = 0,\n\t\t\t[WL18XX_CONF_SG_ZIGBEE_COEX] = 0,\n\t\t\t[WL18XX_CONF_SG_TIME_SYNC] = 0,\n\t\t\t[WL18XX_CONF_SG_PARAM_4] = 0,\n\t\t\t[WL18XX_CONF_SG_PARAM_5] = 0,\n\t\t\t[WL18XX_CONF_SG_PARAM_6] = 0,\n\t\t\t[WL18XX_CONF_SG_PARAM_7] = 0,\n\t\t\t[WL18XX_CONF_SG_PARAM_8] = 0,\n\t\t\t[WL18XX_CONF_SG_PARAM_9] = 0,\n\t\t\t[WL18XX_CONF_SG_PARAM_10] = 0,\n\t\t\t[WL18XX_CONF_SG_PARAM_11] = 0,\n\t\t\t[WL18XX_CONF_SG_PARAM_12] = 0,\n\t\t\t[WL18XX_CONF_SG_PARAM_13] = 0,\n\t\t\t[WL18XX_CONF_SG_PARAM_14] = 0,\n\t\t\t[WL18XX_CONF_SG_PARAM_15] = 0,\n\t\t\t[WL18XX_CONF_SG_PARAM_16] = 0,\n\t\t\t[WL18XX_CONF_SG_PARAM_17] = 0,\n\t\t\t[WL18XX_CONF_SG_PARAM_18] = 0,\n\t\t\t[WL18XX_CONF_SG_PARAM_19] = 0,\n\t\t\t[WL18XX_CONF_SG_PARAM_20] = 0,\n\t\t\t[WL18XX_CONF_SG_PARAM_21] = 0,\n\t\t\t[WL18XX_CONF_SG_PARAM_22] = 0,\n\t\t\t[WL18XX_CONF_SG_PARAM_23] = 0,\n\t\t\t[WL18XX_CONF_SG_PARAM_24] = 0,\n\t\t\t[WL18XX_CONF_SG_PARAM_25] = 0,\n\t\t\t \n\t\t\t[WL18XX_CONF_SG_AUTO_SCAN_PROBE_REQ] = 170,\n\t\t\t[WL18XX_CONF_SG_ACTIVE_SCAN_DURATION_FACTOR_HV3] = 50,\n\t\t\t[WL18XX_CONF_SG_PARAM_28] = 0,\n\t\t\t \n\t\t\t[WL18XX_CONF_SG_PARAM_29] = 0,\n\t\t\t[WL18XX_CONF_SG_PARAM_30] = 0,\n\t\t\t[WL18XX_CONF_SG_PASSIVE_SCAN_DURATION_FACTOR_HV3] = 200,\n\t\t\t \n\t\t\t[WL18XX_CONF_SG_CONSECUTIVE_HV3_IN_PASSIVE_SCAN] = 0,\n\t\t\t[WL18XX_CONF_SG_BEACON_HV3_COLL_TH_IN_PASSIVE_SCAN] = 0,\n\t\t\t[WL18XX_CONF_SG_TX_RX_PROTECT_BW_IN_PASSIVE_SCAN] = 0,\n\t\t\t \n\t\t\t[WL18XX_CONF_SG_STA_FORCE_PS_IN_BT_SCO] = 1,\n\t\t\t[WL18XX_CONF_SG_PARAM_36] = 0,\n\t\t\t[WL18XX_CONF_SG_BEACON_MISS_PERCENT] = 60,\n\t\t\t[WL18XX_CONF_SG_PARAM_38] = 0,\n\t\t\t[WL18XX_CONF_SG_RXT] = 1200,\n\t\t\t[WL18XX_CONF_SG_UNUSED] = 0,\n\t\t\t[WL18XX_CONF_SG_ADAPTIVE_RXT_TXT] = 1,\n\t\t\t[WL18XX_CONF_SG_GENERAL_USAGE_BIT_MAP] = 3,\n\t\t\t[WL18XX_CONF_SG_HV3_MAX_SERVED] = 6,\n\t\t\t[WL18XX_CONF_SG_PARAM_44] = 0,\n\t\t\t[WL18XX_CONF_SG_PARAM_45] = 0,\n\t\t\t[WL18XX_CONF_SG_CONSECUTIVE_CTS_THRESHOLD] = 2,\n\t\t\t[WL18XX_CONF_SG_GEMINI_PARAM_47] = 0,\n\t\t\t[WL18XX_CONF_SG_STA_CONNECTION_PROTECTION_TIME] = 0,\n\t\t\t \n\t\t\t[WL18XX_CONF_SG_AP_BEACON_MISS_TX] = 3,\n\t\t\t[WL18XX_CONF_SG_PARAM_50] = 0,\n\t\t\t[WL18XX_CONF_SG_AP_BEACON_WINDOW_INTERVAL] = 2,\n\t\t\t[WL18XX_CONF_SG_AP_CONNECTION_PROTECTION_TIME] = 30,\n\t\t\t[WL18XX_CONF_SG_PARAM_53] = 0,\n\t\t\t[WL18XX_CONF_SG_PARAM_54] = 0,\n\t\t\t \n\t\t\t[WL18XX_CONF_SG_CTS_DILUTED_BAD_RX_PACKETS_TH] = 0,\n\t\t\t[WL18XX_CONF_SG_CTS_CHOP_IN_DUAL_ANT_SCO_MASTER] = 0,\n\t\t\t[WL18XX_CONF_SG_TEMP_PARAM_1] = 0,\n\t\t\t[WL18XX_CONF_SG_TEMP_PARAM_2] = 0,\n\t\t\t[WL18XX_CONF_SG_TEMP_PARAM_3] = 0,\n\t\t\t[WL18XX_CONF_SG_TEMP_PARAM_4] = 0,\n\t\t\t[WL18XX_CONF_SG_TEMP_PARAM_5] = 0,\n\t\t\t[WL18XX_CONF_SG_TEMP_PARAM_6] = 0,\n\t\t\t[WL18XX_CONF_SG_TEMP_PARAM_7] = 0,\n\t\t\t[WL18XX_CONF_SG_TEMP_PARAM_8] = 0,\n\t\t\t[WL18XX_CONF_SG_TEMP_PARAM_9] = 0,\n\t\t\t[WL18XX_CONF_SG_TEMP_PARAM_10] = 0,\n\t\t},\n\t\t.state = CONF_SG_PROTECTIVE,\n\t},\n\t.rx = {\n\t\t.rx_msdu_life_time           = 512000,\n\t\t.packet_detection_threshold  = 0,\n\t\t.ps_poll_timeout             = 15,\n\t\t.upsd_timeout                = 15,\n\t\t.rts_threshold               = IEEE80211_MAX_RTS_THRESHOLD,\n\t\t.rx_cca_threshold            = 0,\n\t\t.irq_blk_threshold           = 0xFFFF,\n\t\t.irq_pkt_threshold           = 0,\n\t\t.irq_timeout                 = 600,\n\t\t.queue_type                  = CONF_RX_QUEUE_TYPE_LOW_PRIORITY,\n\t},\n\t.tx = {\n\t\t.tx_energy_detection         = 0,\n\t\t.sta_rc_conf                 = {\n\t\t\t.enabled_rates       = 0,\n\t\t\t.short_retry_limit   = 10,\n\t\t\t.long_retry_limit    = 10,\n\t\t\t.aflags              = 0,\n\t\t},\n\t\t.ac_conf_count               = 4,\n\t\t.ac_conf                     = {\n\t\t\t[CONF_TX_AC_BE] = {\n\t\t\t\t.ac          = CONF_TX_AC_BE,\n\t\t\t\t.cw_min      = 15,\n\t\t\t\t.cw_max      = 63,\n\t\t\t\t.aifsn       = 3,\n\t\t\t\t.tx_op_limit = 0,\n\t\t\t},\n\t\t\t[CONF_TX_AC_BK] = {\n\t\t\t\t.ac          = CONF_TX_AC_BK,\n\t\t\t\t.cw_min      = 15,\n\t\t\t\t.cw_max      = 63,\n\t\t\t\t.aifsn       = 7,\n\t\t\t\t.tx_op_limit = 0,\n\t\t\t},\n\t\t\t[CONF_TX_AC_VI] = {\n\t\t\t\t.ac          = CONF_TX_AC_VI,\n\t\t\t\t.cw_min      = 15,\n\t\t\t\t.cw_max      = 63,\n\t\t\t\t.aifsn       = CONF_TX_AIFS_PIFS,\n\t\t\t\t.tx_op_limit = 3008,\n\t\t\t},\n\t\t\t[CONF_TX_AC_VO] = {\n\t\t\t\t.ac          = CONF_TX_AC_VO,\n\t\t\t\t.cw_min      = 15,\n\t\t\t\t.cw_max      = 63,\n\t\t\t\t.aifsn       = CONF_TX_AIFS_PIFS,\n\t\t\t\t.tx_op_limit = 1504,\n\t\t\t},\n\t\t},\n\t\t.max_tx_retries = 100,\n\t\t.ap_aging_period = 300,\n\t\t.tid_conf_count = 4,\n\t\t.tid_conf = {\n\t\t\t[CONF_TX_AC_BE] = {\n\t\t\t\t.queue_id    = CONF_TX_AC_BE,\n\t\t\t\t.channel_type = CONF_CHANNEL_TYPE_EDCF,\n\t\t\t\t.tsid        = CONF_TX_AC_BE,\n\t\t\t\t.ps_scheme   = CONF_PS_SCHEME_LEGACY,\n\t\t\t\t.ack_policy  = CONF_ACK_POLICY_LEGACY,\n\t\t\t\t.apsd_conf   = {0, 0},\n\t\t\t},\n\t\t\t[CONF_TX_AC_BK] = {\n\t\t\t\t.queue_id    = CONF_TX_AC_BK,\n\t\t\t\t.channel_type = CONF_CHANNEL_TYPE_EDCF,\n\t\t\t\t.tsid        = CONF_TX_AC_BK,\n\t\t\t\t.ps_scheme   = CONF_PS_SCHEME_LEGACY,\n\t\t\t\t.ack_policy  = CONF_ACK_POLICY_LEGACY,\n\t\t\t\t.apsd_conf   = {0, 0},\n\t\t\t},\n\t\t\t[CONF_TX_AC_VI] = {\n\t\t\t\t.queue_id    = CONF_TX_AC_VI,\n\t\t\t\t.channel_type = CONF_CHANNEL_TYPE_EDCF,\n\t\t\t\t.tsid        = CONF_TX_AC_VI,\n\t\t\t\t.ps_scheme   = CONF_PS_SCHEME_LEGACY,\n\t\t\t\t.ack_policy  = CONF_ACK_POLICY_LEGACY,\n\t\t\t\t.apsd_conf   = {0, 0},\n\t\t\t},\n\t\t\t[CONF_TX_AC_VO] = {\n\t\t\t\t.queue_id    = CONF_TX_AC_VO,\n\t\t\t\t.channel_type = CONF_CHANNEL_TYPE_EDCF,\n\t\t\t\t.tsid        = CONF_TX_AC_VO,\n\t\t\t\t.ps_scheme   = CONF_PS_SCHEME_LEGACY,\n\t\t\t\t.ack_policy  = CONF_ACK_POLICY_LEGACY,\n\t\t\t\t.apsd_conf   = {0, 0},\n\t\t\t},\n\t\t},\n\t\t.frag_threshold              = IEEE80211_MAX_FRAG_THRESHOLD,\n\t\t.tx_compl_timeout            = 350,\n\t\t.tx_compl_threshold          = 10,\n\t\t.basic_rate                  = CONF_HW_BIT_RATE_1MBPS,\n\t\t.basic_rate_5                = CONF_HW_BIT_RATE_6MBPS,\n\t\t.tmpl_short_retry_limit      = 10,\n\t\t.tmpl_long_retry_limit       = 10,\n\t\t.tx_watchdog_timeout         = 5000,\n\t\t.slow_link_thold             = 3,\n\t\t.fast_link_thold             = 30,\n\t},\n\t.conn = {\n\t\t.wake_up_event               = CONF_WAKE_UP_EVENT_DTIM,\n\t\t.listen_interval             = 1,\n\t\t.suspend_wake_up_event       = CONF_WAKE_UP_EVENT_N_DTIM,\n\t\t.suspend_listen_interval     = 3,\n\t\t.bcn_filt_mode               = CONF_BCN_FILT_MODE_ENABLED,\n\t\t.bcn_filt_ie_count           = 3,\n\t\t.bcn_filt_ie = {\n\t\t\t[0] = {\n\t\t\t\t.ie          = WLAN_EID_CHANNEL_SWITCH,\n\t\t\t\t.rule        = CONF_BCN_RULE_PASS_ON_APPEARANCE,\n\t\t\t},\n\t\t\t[1] = {\n\t\t\t\t.ie          = WLAN_EID_HT_OPERATION,\n\t\t\t\t.rule        = CONF_BCN_RULE_PASS_ON_CHANGE,\n\t\t\t},\n\t\t\t[2] = {\n\t\t\t\t.ie\t     = WLAN_EID_ERP_INFO,\n\t\t\t\t.rule\t     = CONF_BCN_RULE_PASS_ON_CHANGE,\n\t\t\t},\n\t\t},\n\t\t.synch_fail_thold            = 12,\n\t\t.bss_lose_timeout            = 400,\n\t\t.beacon_rx_timeout           = 10000,\n\t\t.broadcast_timeout           = 20000,\n\t\t.rx_broadcast_in_ps          = 1,\n\t\t.ps_poll_threshold           = 10,\n\t\t.bet_enable                  = CONF_BET_MODE_ENABLE,\n\t\t.bet_max_consecutive         = 50,\n\t\t.psm_entry_retries           = 8,\n\t\t.psm_exit_retries            = 16,\n\t\t.psm_entry_nullfunc_retries  = 3,\n\t\t.dynamic_ps_timeout          = 1500,\n\t\t.forced_ps                   = false,\n\t\t.keep_alive_interval         = 55000,\n\t\t.max_listen_interval         = 20,\n\t\t.sta_sleep_auth              = WL1271_PSM_ILLEGAL,\n\t\t.suspend_rx_ba_activity      = 0,\n\t},\n\t.itrim = {\n\t\t.enable = false,\n\t\t.timeout = 50000,\n\t},\n\t.pm_config = {\n\t\t.host_clk_settling_time = 5000,\n\t\t.host_fast_wakeup_support = CONF_FAST_WAKEUP_DISABLE,\n\t},\n\t.roam_trigger = {\n\t\t.trigger_pacing               = 1,\n\t\t.avg_weight_rssi_beacon       = 20,\n\t\t.avg_weight_rssi_data         = 10,\n\t\t.avg_weight_snr_beacon        = 20,\n\t\t.avg_weight_snr_data          = 10,\n\t},\n\t.scan = {\n\t\t.min_dwell_time_active        = 7500,\n\t\t.max_dwell_time_active        = 30000,\n\t\t.min_dwell_time_active_long   = 25000,\n\t\t.max_dwell_time_active_long   = 50000,\n\t\t.dwell_time_passive           = 100000,\n\t\t.dwell_time_dfs               = 150000,\n\t\t.num_probe_reqs               = 2,\n\t\t.split_scan_timeout           = 50000,\n\t},\n\t.sched_scan = {\n\t\t \n\t\t.base_dwell_time\t\t= 7500,\n\t\t.max_dwell_time_delta\t\t= 22500,\n\t\t \n\t\t.dwell_time_delta_per_probe\t= 2000,\n\t\t \n\t\t.dwell_time_delta_per_probe_5\t= 350,\n\t\t.dwell_time_passive\t\t= 100000,\n\t\t.dwell_time_dfs\t\t\t= 150000,\n\t\t.num_probe_reqs\t\t\t= 2,\n\t\t.rssi_threshold\t\t\t= -90,\n\t\t.snr_threshold\t\t\t= 0,\n\t\t.num_short_intervals\t\t= SCAN_MAX_SHORT_INTERVALS,\n\t\t.long_interval\t\t\t= 30000,\n\t},\n\t.ht = {\n\t\t.rx_ba_win_size = 32,\n\t\t.tx_ba_win_size = 64,\n\t\t.inactivity_timeout = 10000,\n\t\t.tx_ba_tid_bitmap = CONF_TX_BA_ENABLED_TID_BITMAP,\n\t},\n\t.mem = {\n\t\t.num_stations                 = 1,\n\t\t.ssid_profiles                = 1,\n\t\t.rx_block_num                 = 40,\n\t\t.tx_min_block_num             = 40,\n\t\t.dynamic_memory               = 1,\n\t\t.min_req_tx_blocks            = 45,\n\t\t.min_req_rx_blocks            = 22,\n\t\t.tx_min                       = 27,\n\t},\n\t.fm_coex = {\n\t\t.enable                       = true,\n\t\t.swallow_period               = 5,\n\t\t.n_divider_fref_set_1         = 0xff,        \n\t\t.n_divider_fref_set_2         = 12,\n\t\t.m_divider_fref_set_1         = 0xffff,\n\t\t.m_divider_fref_set_2         = 148,         \n\t\t.coex_pll_stabilization_time  = 0xffffffff,  \n\t\t.ldo_stabilization_time       = 0xffff,      \n\t\t.fm_disturbed_band_margin     = 0xff,        \n\t\t.swallow_clk_diff             = 0xff,        \n\t},\n\t.rx_streaming = {\n\t\t.duration                      = 150,\n\t\t.queues                        = 0x1,\n\t\t.interval                      = 20,\n\t\t.always                        = 0,\n\t},\n\t.fwlog = {\n\t\t.mode                         = WL12XX_FWLOG_CONTINUOUS,\n\t\t.mem_blocks                   = 0,\n\t\t.severity                     = 0,\n\t\t.timestamp                    = WL12XX_FWLOG_TIMESTAMP_DISABLED,\n\t\t.output                       = WL12XX_FWLOG_OUTPUT_DBG_PINS,\n\t\t.threshold                    = 0,\n\t},\n\t.rate = {\n\t\t.rate_retry_score = 32000,\n\t\t.per_add = 8192,\n\t\t.per_th1 = 2048,\n\t\t.per_th2 = 4096,\n\t\t.max_per = 8100,\n\t\t.inverse_curiosity_factor = 5,\n\t\t.tx_fail_low_th = 4,\n\t\t.tx_fail_high_th = 10,\n\t\t.per_alpha_shift = 4,\n\t\t.per_add_shift = 13,\n\t\t.per_beta1_shift = 10,\n\t\t.per_beta2_shift = 8,\n\t\t.rate_check_up = 2,\n\t\t.rate_check_down = 12,\n\t\t.rate_retry_policy = {\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t0x00, 0x00, 0x00,\n\t\t},\n\t},\n\t.hangover = {\n\t\t.recover_time               = 0,\n\t\t.hangover_period            = 20,\n\t\t.dynamic_mode               = 1,\n\t\t.early_termination_mode     = 1,\n\t\t.max_period                 = 20,\n\t\t.min_period                 = 1,\n\t\t.increase_delta             = 1,\n\t\t.decrease_delta             = 2,\n\t\t.quiet_time                 = 4,\n\t\t.increase_time              = 1,\n\t\t.window_size                = 16,\n\t},\n\t.recovery = {\n\t\t.bug_on_recovery\t    = 0,\n\t\t.no_recovery\t\t    = 0,\n\t},\n};\n\nstatic struct wl18xx_priv_conf wl18xx_default_priv_conf = {\n\t.ht = {\n\t\t.mode\t\t\t\t= HT_MODE_WIDE,\n\t},\n\t.phy = {\n\t\t.phy_standalone\t\t\t= 0x00,\n\t\t.primary_clock_setting_time\t= 0x05,\n\t\t.clock_valid_on_wake_up\t\t= 0x00,\n\t\t.secondary_clock_setting_time\t= 0x05,\n\t\t.board_type \t\t\t= BOARD_TYPE_HDK_18XX,\n\t\t.auto_detect\t\t\t= 0x00,\n\t\t.dedicated_fem\t\t\t= FEM_NONE,\n\t\t.low_band_component\t\t= COMPONENT_3_WAY_SWITCH,\n\t\t.low_band_component_type\t= 0x05,\n\t\t.high_band_component\t\t= COMPONENT_2_WAY_SWITCH,\n\t\t.high_band_component_type\t= 0x09,\n\t\t.tcxo_ldo_voltage\t\t= 0x00,\n\t\t.xtal_itrim_val\t\t\t= 0x04,\n\t\t.srf_state\t\t\t= 0x00,\n\t\t.io_configuration\t\t= 0x01,\n\t\t.sdio_configuration\t\t= 0x00,\n\t\t.settings\t\t\t= 0x00,\n\t\t.enable_clpc\t\t\t= 0x00,\n\t\t.enable_tx_low_pwr_on_siso_rdl\t= 0x00,\n\t\t.rx_profile\t\t\t= 0x00,\n\t\t.pwr_limit_reference_11_abg\t= 0x64,\n\t\t.per_chan_pwr_limit_arr_11abg\t= {\n\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff },\n\t\t.pwr_limit_reference_11p\t= 0x64,\n\t\t.per_chan_bo_mode_11_abg\t= { 0x00, 0x00, 0x00, 0x00,\n\t\t\t\t\t\t    0x00, 0x00, 0x00, 0x00,\n\t\t\t\t\t\t    0x00, 0x00, 0x00, 0x00,\n\t\t\t\t\t\t    0x00 },\n\t\t.per_chan_bo_mode_11_p\t\t= { 0x00, 0x00, 0x00, 0x00 },\n\t\t.per_chan_pwr_limit_arr_11p\t= { 0xff, 0xff, 0xff, 0xff,\n\t\t\t\t\t\t    0xff, 0xff, 0xff },\n\t\t.psat\t\t\t\t= 0,\n\t\t.external_pa_dc2dc\t\t= 0,\n\t\t.number_of_assembled_ant2_4\t= 2,\n\t\t.number_of_assembled_ant5\t= 1,\n\t\t.low_power_val\t\t\t= 0xff,\n\t\t.med_power_val\t\t\t= 0xff,\n\t\t.high_power_val\t\t\t= 0xff,\n\t\t.low_power_val_2nd\t\t= 0xff,\n\t\t.med_power_val_2nd\t\t= 0xff,\n\t\t.high_power_val_2nd\t\t= 0xff,\n\t\t.tx_rf_margin\t\t\t= 1,\n\t},\n\t.ap_sleep = {                \n\t\t.idle_duty_cycle        = 0,\n\t\t.connected_duty_cycle   = 0,\n\t\t.max_stations_thresh    = 0,\n\t\t.idle_conn_thresh       = 0,\n\t},\n};\n\nstatic const struct wlcore_partition_set wl18xx_ptable[PART_TABLE_LEN] = {\n\t[PART_TOP_PRCM_ELP_SOC] = {\n\t\t.mem  = { .start = 0x00A00000, .size  = 0x00012000 },\n\t\t.reg  = { .start = 0x00807000, .size  = 0x00005000 },\n\t\t.mem2 = { .start = 0x00800000, .size  = 0x0000B000 },\n\t\t.mem3 = { .start = 0x00401594, .size  = 0x00001020 },\n\t},\n\t[PART_DOWN] = {\n\t\t.mem  = { .start = 0x00000000, .size  = 0x00014000 },\n\t\t.reg  = { .start = 0x00810000, .size  = 0x0000BFFF },\n\t\t.mem2 = { .start = 0x00000000, .size  = 0x00000000 },\n\t\t.mem3 = { .start = 0x00000000, .size  = 0x00000000 },\n\t},\n\t[PART_BOOT] = {\n\t\t.mem  = { .start = 0x00700000, .size = 0x0000030c },\n\t\t.reg  = { .start = 0x00802000, .size = 0x00014578 },\n\t\t.mem2 = { .start = 0x00B00404, .size = 0x00001000 },\n\t\t.mem3 = { .start = 0x00C00000, .size = 0x00000400 },\n\t},\n\t[PART_WORK] = {\n\t\t.mem  = { .start = 0x00800000, .size  = 0x000050FC },\n\t\t.reg  = { .start = 0x00B00404, .size  = 0x00001000 },\n\t\t.mem2 = { .start = 0x00C00000, .size  = 0x00000400 },\n\t\t.mem3 = { .start = 0x00401594, .size  = 0x00001020 },\n\t},\n\t[PART_PHY_INIT] = {\n\t\t.mem  = { .start = WL18XX_PHY_INIT_MEM_ADDR,\n\t\t\t  .size  = WL18XX_PHY_INIT_MEM_SIZE },\n\t\t.reg  = { .start = 0x00000000, .size = 0x00000000 },\n\t\t.mem2 = { .start = 0x00000000, .size = 0x00000000 },\n\t\t.mem3 = { .start = 0x00000000, .size = 0x00000000 },\n\t},\n};\n\nstatic const int wl18xx_rtable[REG_TABLE_LEN] = {\n\t[REG_ECPU_CONTROL]\t\t= WL18XX_REG_ECPU_CONTROL,\n\t[REG_INTERRUPT_NO_CLEAR]\t= WL18XX_REG_INTERRUPT_NO_CLEAR,\n\t[REG_INTERRUPT_ACK]\t\t= WL18XX_REG_INTERRUPT_ACK,\n\t[REG_COMMAND_MAILBOX_PTR]\t= WL18XX_REG_COMMAND_MAILBOX_PTR,\n\t[REG_EVENT_MAILBOX_PTR]\t\t= WL18XX_REG_EVENT_MAILBOX_PTR,\n\t[REG_INTERRUPT_TRIG]\t\t= WL18XX_REG_INTERRUPT_TRIG_H,\n\t[REG_INTERRUPT_MASK]\t\t= WL18XX_REG_INTERRUPT_MASK,\n\t[REG_PC_ON_RECOVERY]\t\t= WL18XX_SCR_PAD4,\n\t[REG_CHIP_ID_B]\t\t\t= WL18XX_REG_CHIP_ID_B,\n\t[REG_CMD_MBOX_ADDRESS]\t\t= WL18XX_CMD_MBOX_ADDRESS,\n\n\t \n\t[REG_SLV_MEM_DATA]\t\t= WL18XX_SLV_MEM_DATA,\n\t[REG_SLV_REG_DATA]\t\t= WL18XX_SLV_REG_DATA,\n\n\t \n\t[REG_RAW_FW_STATUS_ADDR]\t= WL18XX_FW_STATUS_ADDR,\n};\n\nstatic const struct wl18xx_clk_cfg wl18xx_clk_table_coex[NUM_CLOCK_CONFIGS] = {\n\t[CLOCK_CONFIG_16_2_M]\t= { 8,  121, 0, 0, false },\n\t[CLOCK_CONFIG_16_368_M]\t= { 8,  120, 0, 0, false },\n\t[CLOCK_CONFIG_16_8_M]\t= { 8,  117, 0, 0, false },\n\t[CLOCK_CONFIG_19_2_M]\t= { 10, 128, 0, 0, false },\n\t[CLOCK_CONFIG_26_M]\t= { 11, 104, 0, 0, false },\n\t[CLOCK_CONFIG_32_736_M]\t= { 8,  120, 0, 0, false },\n\t[CLOCK_CONFIG_33_6_M]\t= { 8,  117, 0, 0, false },\n\t[CLOCK_CONFIG_38_468_M]\t= { 10, 128, 0, 0, false },\n\t[CLOCK_CONFIG_52_M]\t= { 11, 104, 0, 0, false },\n};\n\nstatic const struct wl18xx_clk_cfg wl18xx_clk_table[NUM_CLOCK_CONFIGS] = {\n\t[CLOCK_CONFIG_16_2_M]\t= { 7,  104,  801, 4,  true },\n\t[CLOCK_CONFIG_16_368_M]\t= { 9,  132, 3751, 4,  true },\n\t[CLOCK_CONFIG_16_8_M]\t= { 7,  100,    0, 0, false },\n\t[CLOCK_CONFIG_19_2_M]\t= { 8,  100,    0, 0, false },\n\t[CLOCK_CONFIG_26_M]\t= { 13, 120,    0, 0, false },\n\t[CLOCK_CONFIG_32_736_M]\t= { 9,  132, 3751, 4,  true },\n\t[CLOCK_CONFIG_33_6_M]\t= { 7,  100,    0, 0, false },\n\t[CLOCK_CONFIG_38_468_M]\t= { 8,  100,    0, 0, false },\n\t[CLOCK_CONFIG_52_M]\t= { 13, 120,    0, 0, false },\n};\n\n \n#define WL18XX_FW_NAME \"ti-connectivity/wl18xx-fw-4.bin\"\n\nstatic int wl18xx_identify_chip(struct wl1271 *wl)\n{\n\tint ret = 0;\n\n\tswitch (wl->chip.id) {\n\tcase CHIP_ID_185x_PG20:\n\t\twl1271_debug(DEBUG_BOOT, \"chip id 0x%x (185x PG20)\",\n\t\t\t\t wl->chip.id);\n\t\twl->sr_fw_name = WL18XX_FW_NAME;\n\t\t \n\t\twl->plt_fw_name = WL18XX_FW_NAME;\n\t\twl->quirks |= WLCORE_QUIRK_RX_BLOCKSIZE_ALIGN |\n\t\t\t      WLCORE_QUIRK_TX_BLOCKSIZE_ALIGN |\n\t\t\t      WLCORE_QUIRK_NO_SCHED_SCAN_WHILE_CONN |\n\t\t\t      WLCORE_QUIRK_TX_PAD_LAST_FRAME |\n\t\t\t      WLCORE_QUIRK_REGDOMAIN_CONF |\n\t\t\t      WLCORE_QUIRK_DUAL_PROBE_TMPL;\n\n\t\twlcore_set_min_fw_ver(wl, WL18XX_CHIP_VER,\n\t\t\t\t      WL18XX_IFTYPE_VER,  WL18XX_MAJOR_VER,\n\t\t\t\t      WL18XX_SUBTYPE_VER, WL18XX_MINOR_VER,\n\t\t\t\t       \n\t\t\t\t      0, 0, 0, 0);\n\t\tbreak;\n\tcase CHIP_ID_185x_PG10:\n\t\twl1271_warning(\"chip id 0x%x (185x PG10) is deprecated\",\n\t\t\t       wl->chip.id);\n\t\tret = -ENODEV;\n\t\tgoto out;\n\n\tdefault:\n\t\twl1271_warning(\"unsupported chip id: 0x%x\", wl->chip.id);\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\twl->fw_mem_block_size = 272;\n\twl->fwlog_end = 0x40000000;\n\n\twl->scan_templ_id_2_4 = CMD_TEMPL_CFG_PROBE_REQ_2_4;\n\twl->scan_templ_id_5 = CMD_TEMPL_CFG_PROBE_REQ_5;\n\twl->sched_scan_templ_id_2_4 = CMD_TEMPL_PROBE_REQ_2_4_PERIODIC;\n\twl->sched_scan_templ_id_5 = CMD_TEMPL_PROBE_REQ_5_PERIODIC;\n\twl->max_channels_5 = WL18XX_MAX_CHANNELS_5GHZ;\n\twl->ba_rx_session_count_max = WL18XX_RX_BA_MAX_SESSIONS;\nout:\n\treturn ret;\n}\n\nstatic int wl18xx_set_clk(struct wl1271 *wl)\n{\n\tu16 clk_freq;\n\tint ret;\n\n\tret = wlcore_set_partition(wl, &wl->ptable[PART_TOP_PRCM_ELP_SOC]);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\n\tret = wl18xx_top_reg_read(wl, PRIMARY_CLK_DETECT, &clk_freq);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twl1271_debug(DEBUG_BOOT, \"clock freq %d (%d, %d, %d, %d, %s)\", clk_freq,\n\t\t     wl18xx_clk_table[clk_freq].n, wl18xx_clk_table[clk_freq].m,\n\t\t     wl18xx_clk_table[clk_freq].p, wl18xx_clk_table[clk_freq].q,\n\t\t     wl18xx_clk_table[clk_freq].swallow ? \"swallow\" : \"spit\");\n\n\t \n\tret = wl18xx_top_reg_write(wl, PLLSH_COEX_PLL_N,\n\t\t\t\t   wl18xx_clk_table_coex[clk_freq].n);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl18xx_top_reg_write(wl, PLLSH_COEX_PLL_M,\n\t\t\t\t   wl18xx_clk_table_coex[clk_freq].m);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = wl18xx_top_reg_write(wl, PLLSH_COEX_PLL_SWALLOW_EN,\n\t\t\t\t   PLLSH_COEX_PLL_SWALLOW_EN_VAL1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl18xx_top_reg_write(wl, PLLSH_WCS_PLL_N,\n\t\t\t\t   wl18xx_clk_table[clk_freq].n);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl18xx_top_reg_write(wl, PLLSH_WCS_PLL_M,\n\t\t\t\t   wl18xx_clk_table[clk_freq].m);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (wl18xx_clk_table[clk_freq].swallow) {\n\t\t \n\t\tret = wl18xx_top_reg_write(wl, PLLSH_WCS_PLL_Q_FACTOR_CFG_1,\n\t\t\t\t\t   wl18xx_clk_table[clk_freq].q &\n\t\t\t\t\t   PLLSH_WCS_PLL_Q_FACTOR_CFG_1_MASK);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t \n\t\tret = wl18xx_top_reg_write(wl, PLLSH_WCS_PLL_Q_FACTOR_CFG_2,\n\t\t\t\t\t(wl18xx_clk_table[clk_freq].q >> 16) &\n\t\t\t\t\tPLLSH_WCS_PLL_Q_FACTOR_CFG_2_MASK);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t \n\t\tret = wl18xx_top_reg_write(wl, PLLSH_WCS_PLL_P_FACTOR_CFG_1,\n\t\t\t\t\t   wl18xx_clk_table[clk_freq].p &\n\t\t\t\t\t   PLLSH_WCS_PLL_P_FACTOR_CFG_1_MASK);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t \n\t\tret = wl18xx_top_reg_write(wl, PLLSH_WCS_PLL_P_FACTOR_CFG_2,\n\t\t\t\t\t(wl18xx_clk_table[clk_freq].p >> 16) &\n\t\t\t\t\tPLLSH_WCS_PLL_P_FACTOR_CFG_2_MASK);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tret = wl18xx_top_reg_write(wl, PLLSH_WCS_PLL_SWALLOW_EN,\n\t\t\t\t\t   PLLSH_WCS_PLL_SWALLOW_EN_VAL2);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t \n\tret = wl18xx_top_reg_write(wl, PLLSH_WL_PLL_SEL,\n\t\t\t\t   PLLSH_WL_PLL_SEL_WCS_PLL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = wl18xx_top_reg_write(wl, PLLSH_WL_PLL_EN, PLLSH_WL_PLL_EN_VAL1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tudelay(1000);\n\n\t \n\tret = wl18xx_top_reg_write(wl, PLLSH_WL_PLL_EN, PLLSH_WL_PLL_EN_VAL2);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = wl18xx_top_reg_write(wl, PLLSH_COEX_PLL_SWALLOW_EN,\n\t\t\t\t   PLLSH_COEX_PLL_SWALLOW_EN_VAL2);\n\nout:\n\treturn ret;\n}\n\nstatic int wl18xx_boot_soft_reset(struct wl1271 *wl)\n{\n\tint ret;\n\n\t \n\tret = wlcore_write32(wl, WL18XX_ENABLE, 0x0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = wlcore_write32(wl, WL18XX_SPARE_A2, 0xffff);\n\nout:\n\treturn ret;\n}\n\nstatic int wl18xx_pre_boot(struct wl1271 *wl)\n{\n\tint ret;\n\n\tret = wl18xx_set_clk(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = wlcore_write32(wl, WL18XX_WELP_ARM_COMMAND, WELP_ARM_COMMAND_VAL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tudelay(500);\n\n\tret = wlcore_set_partition(wl, &wl->ptable[PART_BOOT]);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = wlcore_write_reg(wl, REG_INTERRUPT_MASK, WL1271_ACX_INTR_ALL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl18xx_boot_soft_reset(wl);\n\nout:\n\treturn ret;\n}\n\nstatic int wl18xx_pre_upload(struct wl1271 *wl)\n{\n\tu32 tmp;\n\tint ret;\n\tu16 irq_invert;\n\n\tBUILD_BUG_ON(sizeof(struct wl18xx_mac_and_phy_params) >\n\t\tWL18XX_PHY_INIT_MEM_SIZE);\n\n\tret = wlcore_set_partition(wl, &wl->ptable[PART_BOOT]);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = wlcore_write32(wl, WL18XX_EEPROMLESS_IND, WL18XX_EEPROMLESS_IND);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wlcore_read_reg(wl, REG_CHIP_ID_B, &tmp);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twl1271_debug(DEBUG_BOOT, \"chip id 0x%x\", tmp);\n\n\tret = wlcore_read32(wl, WL18XX_SCR_PAD2, &tmp);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\n\tret = wlcore_set_partition(wl, &wl->ptable[PART_PHY_INIT]);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = wlcore_write32(wl, WL18XX_PHY_FPGA_SPARE_1,\n\t\t\t     MEM_FDSP_CLK_120_DISABLE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = wlcore_write32(wl, WL18XX_PHY_FPGA_SPARE_1,\n\t\t\t     MEM_FDSP_CODERAM_FUNC_CLK_SEL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = wlcore_write32(wl, WL18XX_PHY_FPGA_SPARE_1,\n\t\t\t     MEM_FDSP_CLK_120_ENABLE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = irq_get_trigger_type(wl->irq);\n\tif ((ret == IRQ_TYPE_LEVEL_LOW) || (ret == IRQ_TYPE_EDGE_FALLING)) {\n\t\twl1271_info(\"using inverted interrupt logic: %d\", ret);\n\t\tret = wlcore_set_partition(wl,\n\t\t\t\t\t   &wl->ptable[PART_TOP_PRCM_ELP_SOC]);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = wl18xx_top_reg_read(wl, TOP_FN0_CCCR_REG_32, &irq_invert);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tirq_invert |= BIT(1);\n\t\tret = wl18xx_top_reg_write(wl, TOP_FN0_CCCR_REG_32, irq_invert);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = wlcore_set_partition(wl, &wl->ptable[PART_PHY_INIT]);\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int wl18xx_set_mac_and_phy(struct wl1271 *wl)\n{\n\tstruct wl18xx_priv *priv = wl->priv;\n\tstruct wl18xx_mac_and_phy_params *params;\n\tint ret;\n\n\tparams = kmemdup(&priv->conf.phy, sizeof(*params), GFP_KERNEL);\n\tif (!params) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = wlcore_set_partition(wl, &wl->ptable[PART_PHY_INIT]);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wlcore_write(wl, WL18XX_PHY_INIT_MEM_ADDR, params,\n\t\t\t   sizeof(*params), false);\n\nout:\n\tkfree(params);\n\treturn ret;\n}\n\nstatic int wl18xx_enable_interrupts(struct wl1271 *wl)\n{\n\tu32 event_mask, intr_mask;\n\tint ret;\n\n\tevent_mask = WL18XX_ACX_EVENTS_VECTOR;\n\tintr_mask = WL18XX_INTR_MASK;\n\n\tret = wlcore_write_reg(wl, REG_INTERRUPT_MASK, event_mask);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twlcore_enable_interrupts(wl);\n\n\tret = wlcore_write_reg(wl, REG_INTERRUPT_MASK,\n\t\t\t       WL1271_ACX_INTR_ALL & ~intr_mask);\n\tif (ret < 0)\n\t\tgoto disable_interrupts;\n\n\treturn ret;\n\ndisable_interrupts:\n\twlcore_disable_interrupts(wl);\n\nout:\n\treturn ret;\n}\n\nstatic int wl18xx_boot(struct wl1271 *wl)\n{\n\tint ret;\n\n\tret = wl18xx_pre_boot(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl18xx_pre_upload(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wlcore_boot_upload_firmware(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl18xx_set_mac_and_phy(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twl->event_mask = BSS_LOSS_EVENT_ID |\n\t\tSCAN_COMPLETE_EVENT_ID |\n\t\tRADAR_DETECTED_EVENT_ID |\n\t\tRSSI_SNR_TRIGGER_0_EVENT_ID |\n\t\tPERIODIC_SCAN_COMPLETE_EVENT_ID |\n\t\tPERIODIC_SCAN_REPORT_EVENT_ID |\n\t\tDUMMY_PACKET_EVENT_ID |\n\t\tPEER_REMOVE_COMPLETE_EVENT_ID |\n\t\tBA_SESSION_RX_CONSTRAINT_EVENT_ID |\n\t\tREMAIN_ON_CHANNEL_COMPLETE_EVENT_ID |\n\t\tINACTIVE_STA_EVENT_ID |\n\t\tCHANNEL_SWITCH_COMPLETE_EVENT_ID |\n\t\tDFS_CHANNELS_CONFIG_COMPLETE_EVENT |\n\t\tSMART_CONFIG_SYNC_EVENT_ID |\n\t\tSMART_CONFIG_DECODE_EVENT_ID |\n\t\tTIME_SYNC_EVENT_ID |\n\t\tFW_LOGGER_INDICATION |\n\t\tRX_BA_WIN_SIZE_CHANGE_EVENT_ID;\n\n\twl->ap_event_mask = MAX_TX_FAILURE_EVENT_ID;\n\n\tret = wlcore_boot_run_firmware(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl18xx_enable_interrupts(wl);\n\nout:\n\treturn ret;\n}\n\nstatic int wl18xx_trigger_cmd(struct wl1271 *wl, int cmd_box_addr,\n\t\t\t       void *buf, size_t len)\n{\n\tstruct wl18xx_priv *priv = wl->priv;\n\n\tmemcpy(priv->cmd_buf, buf, len);\n\tmemset(priv->cmd_buf + len, 0, WL18XX_CMD_MAX_SIZE - len);\n\n\treturn wlcore_write(wl, cmd_box_addr, priv->cmd_buf,\n\t\t\t    WL18XX_CMD_MAX_SIZE, false);\n}\n\nstatic int wl18xx_ack_event(struct wl1271 *wl)\n{\n\treturn wlcore_write_reg(wl, REG_INTERRUPT_TRIG,\n\t\t\t\tWL18XX_INTR_TRIG_EVENT_ACK);\n}\n\nstatic u32 wl18xx_calc_tx_blocks(struct wl1271 *wl, u32 len, u32 spare_blks)\n{\n\tu32 blk_size = WL18XX_TX_HW_BLOCK_SIZE;\n\treturn (len + blk_size - 1) / blk_size + spare_blks;\n}\n\nstatic void\nwl18xx_set_tx_desc_blocks(struct wl1271 *wl, struct wl1271_tx_hw_descr *desc,\n\t\t\t  u32 blks, u32 spare_blks)\n{\n\tdesc->wl18xx_mem.total_mem_blocks = blks;\n}\n\nstatic void\nwl18xx_set_tx_desc_data_len(struct wl1271 *wl, struct wl1271_tx_hw_descr *desc,\n\t\t\t    struct sk_buff *skb)\n{\n\tdesc->length = cpu_to_le16(skb->len);\n\n\t \n\tif (wl->quirks & WLCORE_QUIRK_TX_PAD_LAST_FRAME)\n\t\tdesc->wl18xx_mem.ctrl = WL18XX_TX_CTRL_NOT_PADDED;\n\telse\n\t\tdesc->wl18xx_mem.ctrl = 0;\n\n\twl1271_debug(DEBUG_TX, \"tx_fill_hdr: hlid: %d \"\n\t\t     \"len: %d life: %d mem: %d\", desc->hlid,\n\t\t     le16_to_cpu(desc->length),\n\t\t     le16_to_cpu(desc->life_time),\n\t\t     desc->wl18xx_mem.total_mem_blocks);\n}\n\nstatic enum wl_rx_buf_align\nwl18xx_get_rx_buf_align(struct wl1271 *wl, u32 rx_desc)\n{\n\tif (rx_desc & RX_BUF_PADDED_PAYLOAD)\n\t\treturn WLCORE_RX_BUF_PADDED;\n\n\treturn WLCORE_RX_BUF_ALIGNED;\n}\n\nstatic u32 wl18xx_get_rx_packet_len(struct wl1271 *wl, void *rx_data,\n\t\t\t\t    u32 data_len)\n{\n\tstruct wl1271_rx_descriptor *desc = rx_data;\n\n\t \n\tif (data_len < sizeof(*desc))\n\t\treturn 0;\n\n\treturn data_len - sizeof(*desc);\n}\n\nstatic void wl18xx_tx_immediate_completion(struct wl1271 *wl)\n{\n\twl18xx_tx_immediate_complete(wl);\n}\n\nstatic int wl18xx_set_host_cfg_bitmap(struct wl1271 *wl, u32 extra_mem_blk)\n{\n\tint ret;\n\tu32 sdio_align_size = 0;\n\tu32 host_cfg_bitmap = HOST_IF_CFG_RX_FIFO_ENABLE |\n\t\t\t      HOST_IF_CFG_ADD_RX_ALIGNMENT;\n\n\t \n\tif (wl->quirks & WLCORE_QUIRK_TX_BLOCKSIZE_ALIGN) {\n\t\thost_cfg_bitmap |= HOST_IF_CFG_TX_PAD_TO_SDIO_BLK;\n\t\tsdio_align_size = WL12XX_BUS_BLOCK_SIZE;\n\t}\n\n\t \n\tif (wl->quirks & WLCORE_QUIRK_RX_BLOCKSIZE_ALIGN) {\n\t\thost_cfg_bitmap |= HOST_IF_CFG_RX_PAD_TO_SDIO_BLK;\n\t\tsdio_align_size = WL12XX_BUS_BLOCK_SIZE;\n\t}\n\n\tret = wl18xx_acx_host_if_cfg_bitmap(wl, host_cfg_bitmap,\n\t\t\t\t\t    sdio_align_size, extra_mem_blk,\n\t\t\t\t\t    WL18XX_HOST_IF_LEN_SIZE_FIELD);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int wl18xx_hw_init(struct wl1271 *wl)\n{\n\tint ret;\n\tstruct wl18xx_priv *priv = wl->priv;\n\n\t \n\tpriv->last_fw_rls_idx = 0;\n\tpriv->extra_spare_key_count = 0;\n\n\t \n\tret = wl18xx_set_host_cfg_bitmap(wl, WL18XX_TX_HW_BLOCK_SPARE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wl18xx_acx_dynamic_fw_traces(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (checksum_param) {\n\t\tret = wl18xx_acx_set_checksum_state(wl);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void wl18xx_convert_fw_status(struct wl1271 *wl, void *raw_fw_status,\n\t\t\t\t     struct wl_fw_status *fw_status)\n{\n\tstruct wl18xx_fw_status *int_fw_status = raw_fw_status;\n\n\tfw_status->intr = le32_to_cpu(int_fw_status->intr);\n\tfw_status->fw_rx_counter = int_fw_status->fw_rx_counter;\n\tfw_status->drv_rx_counter = int_fw_status->drv_rx_counter;\n\tfw_status->tx_results_counter = int_fw_status->tx_results_counter;\n\tfw_status->rx_pkt_descs = int_fw_status->rx_pkt_descs;\n\n\tfw_status->fw_localtime = le32_to_cpu(int_fw_status->fw_localtime);\n\tfw_status->link_ps_bitmap = le32_to_cpu(int_fw_status->link_ps_bitmap);\n\tfw_status->link_fast_bitmap =\n\t\t\tle32_to_cpu(int_fw_status->link_fast_bitmap);\n\tfw_status->total_released_blks =\n\t\t\tle32_to_cpu(int_fw_status->total_released_blks);\n\tfw_status->tx_total = le32_to_cpu(int_fw_status->tx_total);\n\n\tfw_status->counters.tx_released_pkts =\n\t\t\tint_fw_status->counters.tx_released_pkts;\n\tfw_status->counters.tx_lnk_free_pkts =\n\t\t\tint_fw_status->counters.tx_lnk_free_pkts;\n\tfw_status->counters.tx_voice_released_blks =\n\t\t\tint_fw_status->counters.tx_voice_released_blks;\n\tfw_status->counters.tx_last_rate =\n\t\t\tint_fw_status->counters.tx_last_rate;\n\tfw_status->counters.tx_last_rate_mbps =\n\t\t\tint_fw_status->counters.tx_last_rate_mbps;\n\tfw_status->counters.hlid =\n\t\t\tint_fw_status->counters.hlid;\n\n\tfw_status->log_start_addr = le32_to_cpu(int_fw_status->log_start_addr);\n\n\tfw_status->priv = &int_fw_status->priv;\n}\n\nstatic void wl18xx_set_tx_desc_csum(struct wl1271 *wl,\n\t\t\t\t    struct wl1271_tx_hw_descr *desc,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tu32 ip_hdr_offset;\n\tstruct iphdr *ip_hdr;\n\n\tif (!checksum_param) {\n\t\tdesc->wl18xx_checksum_data = 0;\n\t\treturn;\n\t}\n\n\tif (skb->ip_summed != CHECKSUM_PARTIAL) {\n\t\tdesc->wl18xx_checksum_data = 0;\n\t\treturn;\n\t}\n\n\tip_hdr_offset = skb_network_header(skb) - skb_mac_header(skb);\n\tif (WARN_ON(ip_hdr_offset >= (1<<7))) {\n\t\tdesc->wl18xx_checksum_data = 0;\n\t\treturn;\n\t}\n\n\tdesc->wl18xx_checksum_data = ip_hdr_offset << 1;\n\n\t \n\tip_hdr = (void *)skb_network_header(skb);\n\tdesc->wl18xx_checksum_data |= (ip_hdr->protocol & 0x01);\n}\n\nstatic void wl18xx_set_rx_csum(struct wl1271 *wl,\n\t\t\t       struct wl1271_rx_descriptor *desc,\n\t\t\t       struct sk_buff *skb)\n{\n\tif (desc->status & WL18XX_RX_CHECKSUM_MASK)\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n}\n\nstatic bool wl18xx_is_mimo_supported(struct wl1271 *wl)\n{\n\tstruct wl18xx_priv *priv = wl->priv;\n\n\t \n\treturn (priv->conf.phy.number_of_assembled_ant2_4 >= 2) &&\n\t       (priv->conf.ht.mode != HT_MODE_WIDE) &&\n\t       (priv->conf.ht.mode != HT_MODE_SISO20);\n}\n\n \nstatic u32 wl18xx_sta_get_ap_rate_mask(struct wl1271 *wl,\n\t\t\t\t       struct wl12xx_vif *wlvif)\n{\n\tu32 hw_rate_set = wlvif->rate_set;\n\n\tif (wlvif->channel_type == NL80211_CHAN_HT40MINUS ||\n\t    wlvif->channel_type == NL80211_CHAN_HT40PLUS) {\n\t\twl1271_debug(DEBUG_ACX, \"using wide channel rate mask\");\n\t\thw_rate_set |= CONF_TX_RATE_USE_WIDE_CHAN;\n\n\t\t \n\t\thw_rate_set &= ~CONF_TX_MIMO_RATES;\n\t} else if (wl18xx_is_mimo_supported(wl)) {\n\t\twl1271_debug(DEBUG_ACX, \"using MIMO channel rate mask\");\n\t\thw_rate_set |= CONF_TX_MIMO_RATES;\n\t}\n\n\treturn hw_rate_set;\n}\n\nstatic u32 wl18xx_ap_get_mimo_wide_rate_mask(struct wl1271 *wl,\n\t\t\t\t\t     struct wl12xx_vif *wlvif)\n{\n\tif (wlvif->channel_type == NL80211_CHAN_HT40MINUS ||\n\t    wlvif->channel_type == NL80211_CHAN_HT40PLUS) {\n\t\twl1271_debug(DEBUG_ACX, \"using wide channel rate mask\");\n\n\t\t \n\t\tif (WARN_ON(wlvif->band != NL80211_BAND_5GHZ))\n\t\t\treturn 0;\n\n\t\treturn CONF_TX_RATE_USE_WIDE_CHAN;\n\t} else if (wl18xx_is_mimo_supported(wl) &&\n\t\t   wlvif->band == NL80211_BAND_2GHZ) {\n\t\twl1271_debug(DEBUG_ACX, \"using MIMO rate mask\");\n\t\t \n\t\treturn CONF_TX_MIMO_RATES;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nstatic const char *wl18xx_rdl_name(enum wl18xx_rdl_num rdl_num)\n{\n\tswitch (rdl_num) {\n\tcase RDL_1_HP:\n\t\treturn \"183xH\";\n\tcase RDL_2_SP:\n\t\treturn \"183x or 180x\";\n\tcase RDL_3_HP:\n\t\treturn \"187xH\";\n\tcase RDL_4_SP:\n\t\treturn \"187x\";\n\tcase RDL_5_SP:\n\t\treturn \"RDL11 - Not Supported\";\n\tcase RDL_6_SP:\n\t\treturn \"180xD\";\n\tcase RDL_7_SP:\n\t\treturn \"RDL13 - Not Supported (1893Q)\";\n\tcase RDL_8_SP:\n\t\treturn \"18xxQ\";\n\tcase RDL_NONE:\n\t\treturn \"UNTRIMMED\";\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n}\n\nstatic int wl18xx_get_pg_ver(struct wl1271 *wl, s8 *ver)\n{\n\tu32 fuse;\n\ts8 rom = 0, metal = 0, pg_ver = 0, rdl_ver = 0, package_type = 0;\n\tint ret;\n\n\tret = wlcore_set_partition(wl, &wl->ptable[PART_TOP_PRCM_ELP_SOC]);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wlcore_read32(wl, WL18XX_REG_FUSE_DATA_2_3, &fuse);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tpackage_type = (fuse >> WL18XX_PACKAGE_TYPE_OFFSET) & 1;\n\n\tret = wlcore_read32(wl, WL18XX_REG_FUSE_DATA_1_3, &fuse);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tpg_ver = (fuse & WL18XX_PG_VER_MASK) >> WL18XX_PG_VER_OFFSET;\n\trom = (fuse & WL18XX_ROM_VER_MASK) >> WL18XX_ROM_VER_OFFSET;\n\n\tif ((rom <= 0xE) && (package_type == WL18XX_PACKAGE_TYPE_WSP))\n\t\tmetal = (fuse & WL18XX_METAL_VER_MASK) >>\n\t\t\tWL18XX_METAL_VER_OFFSET;\n\telse\n\t\tmetal = (fuse & WL18XX_NEW_METAL_VER_MASK) >>\n\t\t\tWL18XX_NEW_METAL_VER_OFFSET;\n\n\tret = wlcore_read32(wl, WL18XX_REG_FUSE_DATA_2_3, &fuse);\n\tif (ret < 0)\n\t\tgoto out;\n\n\trdl_ver = (fuse & WL18XX_RDL_VER_MASK) >> WL18XX_RDL_VER_OFFSET;\n\n\twl1271_info(\"wl18xx HW: %s, PG %d.%d (ROM 0x%x)\",\n\t\t    wl18xx_rdl_name(rdl_ver), pg_ver, metal, rom);\n\n\tif (ver)\n\t\t*ver = pg_ver;\n\n\tret = wlcore_set_partition(wl, &wl->ptable[PART_BOOT]);\n\nout:\n\treturn ret;\n}\n\nstatic int wl18xx_load_conf_file(struct device *dev, struct wlcore_conf *conf,\n\t\t\t\t struct wl18xx_priv_conf *priv_conf,\n\t\t\t\t const char *file)\n{\n\tstruct wlcore_conf_file *conf_file;\n\tconst struct firmware *fw;\n\tint ret;\n\n\tret = request_firmware(&fw, file, dev);\n\tif (ret < 0) {\n\t\twl1271_error(\"could not get configuration binary %s: %d\",\n\t\t\t     file, ret);\n\t\treturn ret;\n\t}\n\n\tif (fw->size != WL18XX_CONF_SIZE) {\n\t\twl1271_error(\"%s configuration binary size is wrong, expected %zu got %zu\",\n\t\t\t     file, WL18XX_CONF_SIZE, fw->size);\n\t\tret = -EINVAL;\n\t\tgoto out_release;\n\t}\n\n\tconf_file = (struct wlcore_conf_file *) fw->data;\n\n\tif (conf_file->header.magic != cpu_to_le32(WL18XX_CONF_MAGIC)) {\n\t\twl1271_error(\"configuration binary file magic number mismatch, \"\n\t\t\t     \"expected 0x%0x got 0x%0x\", WL18XX_CONF_MAGIC,\n\t\t\t     conf_file->header.magic);\n\t\tret = -EINVAL;\n\t\tgoto out_release;\n\t}\n\n\tif (conf_file->header.version != cpu_to_le32(WL18XX_CONF_VERSION)) {\n\t\twl1271_error(\"configuration binary file version not supported, \"\n\t\t\t     \"expected 0x%08x got 0x%08x\",\n\t\t\t     WL18XX_CONF_VERSION, conf_file->header.version);\n\t\tret = -EINVAL;\n\t\tgoto out_release;\n\t}\n\n\tmemcpy(conf, &conf_file->core, sizeof(*conf));\n\tmemcpy(priv_conf, &conf_file->priv, sizeof(*priv_conf));\n\nout_release:\n\trelease_firmware(fw);\n\treturn ret;\n}\n\nstatic int wl18xx_conf_init(struct wl1271 *wl, struct device *dev)\n{\n\tstruct platform_device *pdev = wl->pdev;\n\tstruct wlcore_platdev_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct wl18xx_priv *priv = wl->priv;\n\n\tif (wl18xx_load_conf_file(dev, &wl->conf, &priv->conf,\n\t\t\t\t  pdata->family->cfg_name) < 0) {\n\t\twl1271_warning(\"falling back to default config\");\n\n\t\t \n\t\tmemcpy(&wl->conf, &wl18xx_conf, sizeof(wl->conf));\n\t\t \n\t\tmemcpy(&priv->conf, &wl18xx_default_priv_conf,\n\t\t       sizeof(priv->conf));\n\t}\n\n\treturn 0;\n}\n\nstatic int wl18xx_plt_init(struct wl1271 *wl)\n{\n\tint ret;\n\n\t \n\tif (wl->plt_mode == PLT_FEM_DETECT) {\n\t\twl1271_error(\"wl18xx_plt_init: PLT FEM_DETECT not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = wlcore_write32(wl, WL18XX_SCR_PAD8, WL18XX_SCR_PAD8_PLT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn wl->ops->boot(wl);\n}\n\nstatic int wl18xx_get_mac(struct wl1271 *wl)\n{\n\tu32 mac1, mac2;\n\tint ret;\n\n\tret = wlcore_set_partition(wl, &wl->ptable[PART_TOP_PRCM_ELP_SOC]);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wlcore_read32(wl, WL18XX_REG_FUSE_BD_ADDR_1, &mac1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wlcore_read32(wl, WL18XX_REG_FUSE_BD_ADDR_2, &mac2);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\twl->fuse_oui_addr = ((mac2 & 0xffff) << 8) +\n\t\t((mac1 & 0xff000000) >> 24);\n\twl->fuse_nic_addr = (mac1 & 0xffffff);\n\n\tif (!wl->fuse_oui_addr && !wl->fuse_nic_addr) {\n\t\tu8 mac[ETH_ALEN];\n\n\t\teth_random_addr(mac);\n\n\t\twl->fuse_oui_addr = (mac[0] << 16) + (mac[1] << 8) + mac[2];\n\t\twl->fuse_nic_addr = (mac[3] << 16) + (mac[4] << 8) + mac[5];\n\t\twl1271_warning(\"MAC address from fuse not available, using random locally administered addresses.\");\n\t}\n\n\tret = wlcore_set_partition(wl, &wl->ptable[PART_DOWN]);\n\nout:\n\treturn ret;\n}\n\nstatic int wl18xx_handle_static_data(struct wl1271 *wl,\n\t\t\t\t     struct wl1271_static_data *static_data)\n{\n\tstruct wl18xx_static_data_priv *static_data_priv =\n\t\t(struct wl18xx_static_data_priv *) static_data->priv;\n\n\tstrncpy(wl->chip.phy_fw_ver_str, static_data_priv->phy_version,\n\t\tsizeof(wl->chip.phy_fw_ver_str));\n\n\t \n\twl->chip.phy_fw_ver_str[sizeof(wl->chip.phy_fw_ver_str) - 1] = '\\0';\n\n\twl1271_info(\"PHY firmware version: %s\", static_data_priv->phy_version);\n\n\treturn 0;\n}\n\nstatic int wl18xx_get_spare_blocks(struct wl1271 *wl, bool is_gem)\n{\n\tstruct wl18xx_priv *priv = wl->priv;\n\n\t \n\tif (priv->extra_spare_key_count)\n\t\treturn WL18XX_TX_HW_EXTRA_BLOCK_SPARE;\n\n\treturn WL18XX_TX_HW_BLOCK_SPARE;\n}\n\nstatic int wl18xx_set_key(struct wl1271 *wl, enum set_key_cmd cmd,\n\t\t\t  struct ieee80211_vif *vif,\n\t\t\t  struct ieee80211_sta *sta,\n\t\t\t  struct ieee80211_key_conf *key_conf)\n{\n\tstruct wl18xx_priv *priv = wl->priv;\n\tbool change_spare = false, special_enc;\n\tint ret;\n\n\twl1271_debug(DEBUG_CRYPT, \"extra spare keys before: %d\",\n\t\t     priv->extra_spare_key_count);\n\n\tspecial_enc = key_conf->cipher == WL1271_CIPHER_SUITE_GEM ||\n\t\t      key_conf->cipher == WLAN_CIPHER_SUITE_TKIP;\n\n\tret = wlcore_set_key(wl, cmd, vif, sta, key_conf);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tif (special_enc) {\n\t\tif (cmd == SET_KEY) {\n\t\t\t \n\t\t\tchange_spare = (priv->extra_spare_key_count == 0);\n\t\t\tpriv->extra_spare_key_count++;\n\t\t} else if (cmd == DISABLE_KEY) {\n\t\t\t \n\t\t\tchange_spare = (priv->extra_spare_key_count == 1);\n\t\t\tpriv->extra_spare_key_count--;\n\t\t}\n\t}\n\n\twl1271_debug(DEBUG_CRYPT, \"extra spare keys after: %d\",\n\t\t     priv->extra_spare_key_count);\n\n\tif (!change_spare)\n\t\tgoto out;\n\n\t \n\tif (priv->extra_spare_key_count)\n\t\tret = wl18xx_set_host_cfg_bitmap(wl,\n\t\t\t\t\tWL18XX_TX_HW_EXTRA_BLOCK_SPARE);\n\telse\n\t\tret = wl18xx_set_host_cfg_bitmap(wl,\n\t\t\t\t\tWL18XX_TX_HW_BLOCK_SPARE);\n\nout:\n\treturn ret;\n}\n\nstatic u32 wl18xx_pre_pkt_send(struct wl1271 *wl,\n\t\t\t       u32 buf_offset, u32 last_len)\n{\n\tif (wl->quirks & WLCORE_QUIRK_TX_PAD_LAST_FRAME) {\n\t\tstruct wl1271_tx_hw_descr *last_desc;\n\n\t\t \n\t\tlast_desc = (struct wl1271_tx_hw_descr *)(wl->aggr_buf +\n\t\t\t\t\t\t\tbuf_offset - last_len);\n\n\t\t \n\t\tlast_desc->wl18xx_mem.ctrl &= ~WL18XX_TX_CTRL_NOT_PADDED;\n\t\treturn ALIGN(buf_offset, WL12XX_BUS_BLOCK_SIZE);\n\t}\n\n\t \n\treturn buf_offset;\n}\n\nstatic void wl18xx_sta_rc_update(struct wl1271 *wl,\n\t\t\t\t struct wl12xx_vif *wlvif)\n{\n\tbool wide = wlvif->rc_update_bw >= IEEE80211_STA_RX_BW_40;\n\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 sta_rc_update wide %d\", wide);\n\n\t \n\tif (WARN_ON(wlvif->bss_type != BSS_TYPE_STA_BSS))\n\t\treturn;\n\n\t \n\tif (!test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags))\n\t\treturn;\n\n\t \n\tif (wlvif->sta.role_chan_type == NL80211_CHAN_HT40MINUS ||\n\t    wlvif->sta.role_chan_type == NL80211_CHAN_HT40PLUS)\n\t\twl18xx_acx_peer_ht_operation_mode(wl, wlvif->sta.hlid, wide);\n\telse\n\t\tieee80211_connection_loss(wl12xx_wlvif_to_vif(wlvif));\n}\n\nstatic int wl18xx_set_peer_cap(struct wl1271 *wl,\n\t\t\t       struct ieee80211_sta_ht_cap *ht_cap,\n\t\t\t       bool allow_ht_operation,\n\t\t\t       u32 rate_set, u8 hlid)\n{\n\treturn wl18xx_acx_set_peer_cap(wl, ht_cap, allow_ht_operation,\n\t\t\t\t       rate_set, hlid);\n}\n\nstatic bool wl18xx_lnk_high_prio(struct wl1271 *wl, u8 hlid,\n\t\t\t\t struct wl1271_link *lnk)\n{\n\tu8 thold;\n\tstruct wl18xx_fw_status_priv *status_priv =\n\t\t(struct wl18xx_fw_status_priv *)wl->fw_status->priv;\n\tunsigned long suspend_bitmap;\n\n\t \n\tif (!status_priv)\n\t\treturn false;\n\n\t \n\tsuspend_bitmap = le32_to_cpu(status_priv->link_suspend_bitmap);\n\tif (test_bit(hlid, &suspend_bitmap))\n\t\treturn false;\n\n\t \n\tif (test_bit(hlid, &wl->fw_fast_lnk_map) &&\n\t    !test_bit(hlid, &wl->ap_fw_ps_map))\n\t\tthold = status_priv->tx_fast_link_prio_threshold;\n\telse\n\t\tthold = status_priv->tx_slow_link_prio_threshold;\n\n\treturn lnk->allocated_pkts < thold;\n}\n\nstatic bool wl18xx_lnk_low_prio(struct wl1271 *wl, u8 hlid,\n\t\t\t\tstruct wl1271_link *lnk)\n{\n\tu8 thold;\n\tstruct wl18xx_fw_status_priv *status_priv =\n\t\t(struct wl18xx_fw_status_priv *)wl->fw_status->priv;\n\tunsigned long suspend_bitmap;\n\n\t \n\tif (!status_priv)\n\t\treturn true;\n\n\tsuspend_bitmap = le32_to_cpu(status_priv->link_suspend_bitmap);\n\tif (test_bit(hlid, &suspend_bitmap))\n\t\tthold = status_priv->tx_suspend_threshold;\n\telse if (test_bit(hlid, &wl->fw_fast_lnk_map) &&\n\t\t !test_bit(hlid, &wl->ap_fw_ps_map))\n\t\tthold = status_priv->tx_fast_stop_threshold;\n\telse\n\t\tthold = status_priv->tx_slow_stop_threshold;\n\n\treturn lnk->allocated_pkts < thold;\n}\n\nstatic u32 wl18xx_convert_hwaddr(struct wl1271 *wl, u32 hwaddr)\n{\n\treturn hwaddr & ~0x80000000;\n}\n\nstatic int wl18xx_setup(struct wl1271 *wl);\n\nstatic struct wlcore_ops wl18xx_ops = {\n\t.setup\t\t= wl18xx_setup,\n\t.identify_chip\t= wl18xx_identify_chip,\n\t.boot\t\t= wl18xx_boot,\n\t.plt_init\t= wl18xx_plt_init,\n\t.trigger_cmd\t= wl18xx_trigger_cmd,\n\t.ack_event\t= wl18xx_ack_event,\n\t.wait_for_event\t= wl18xx_wait_for_event,\n\t.process_mailbox_events = wl18xx_process_mailbox_events,\n\t.calc_tx_blocks = wl18xx_calc_tx_blocks,\n\t.set_tx_desc_blocks = wl18xx_set_tx_desc_blocks,\n\t.set_tx_desc_data_len = wl18xx_set_tx_desc_data_len,\n\t.get_rx_buf_align = wl18xx_get_rx_buf_align,\n\t.get_rx_packet_len = wl18xx_get_rx_packet_len,\n\t.tx_immediate_compl = wl18xx_tx_immediate_completion,\n\t.tx_delayed_compl = NULL,\n\t.hw_init\t= wl18xx_hw_init,\n\t.convert_fw_status = wl18xx_convert_fw_status,\n\t.set_tx_desc_csum = wl18xx_set_tx_desc_csum,\n\t.get_pg_ver\t= wl18xx_get_pg_ver,\n\t.set_rx_csum = wl18xx_set_rx_csum,\n\t.sta_get_ap_rate_mask = wl18xx_sta_get_ap_rate_mask,\n\t.ap_get_mimo_wide_rate_mask = wl18xx_ap_get_mimo_wide_rate_mask,\n\t.get_mac\t= wl18xx_get_mac,\n\t.debugfs_init\t= wl18xx_debugfs_add_files,\n\t.scan_start\t= wl18xx_scan_start,\n\t.scan_stop\t= wl18xx_scan_stop,\n\t.sched_scan_start\t= wl18xx_sched_scan_start,\n\t.sched_scan_stop\t= wl18xx_scan_sched_scan_stop,\n\t.handle_static_data\t= wl18xx_handle_static_data,\n\t.get_spare_blocks = wl18xx_get_spare_blocks,\n\t.set_key\t= wl18xx_set_key,\n\t.channel_switch\t= wl18xx_cmd_channel_switch,\n\t.pre_pkt_send\t= wl18xx_pre_pkt_send,\n\t.sta_rc_update\t= wl18xx_sta_rc_update,\n\t.set_peer_cap\t= wl18xx_set_peer_cap,\n\t.convert_hwaddr = wl18xx_convert_hwaddr,\n\t.lnk_high_prio\t= wl18xx_lnk_high_prio,\n\t.lnk_low_prio\t= wl18xx_lnk_low_prio,\n\t.smart_config_start = wl18xx_cmd_smart_config_start,\n\t.smart_config_stop  = wl18xx_cmd_smart_config_stop,\n\t.smart_config_set_group_key = wl18xx_cmd_smart_config_set_group_key,\n\t.interrupt_notify = wl18xx_acx_interrupt_notify_config,\n\t.rx_ba_filter\t= wl18xx_acx_rx_ba_filter,\n\t.ap_sleep\t= wl18xx_acx_ap_sleep,\n\t.set_cac\t= wl18xx_cmd_set_cac,\n\t.dfs_master_restart\t= wl18xx_cmd_dfs_master_restart,\n};\n\n \nstatic struct ieee80211_sta_ht_cap wl18xx_siso40_ht_cap_2ghz = {\n\t.cap = IEEE80211_HT_CAP_SGI_20 | IEEE80211_HT_CAP_SGI_40 |\n\t       IEEE80211_HT_CAP_SUP_WIDTH_20_40 | IEEE80211_HT_CAP_DSSSCCK40 |\n\t       IEEE80211_HT_CAP_GRN_FLD,\n\t.ht_supported = true,\n\t.ampdu_factor = IEEE80211_HT_MAX_AMPDU_16K,\n\t.ampdu_density = IEEE80211_HT_MPDU_DENSITY_16,\n\t.mcs = {\n\t\t.rx_mask = { 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t\t.rx_highest = cpu_to_le16(150),\n\t\t.tx_params = IEEE80211_HT_MCS_TX_DEFINED,\n\t\t},\n};\n\n \nstatic struct ieee80211_sta_ht_cap wl18xx_siso40_ht_cap_5ghz = {\n\t.cap = IEEE80211_HT_CAP_SGI_20 | IEEE80211_HT_CAP_SGI_40 |\n\t       IEEE80211_HT_CAP_SUP_WIDTH_20_40 |\n\t       IEEE80211_HT_CAP_GRN_FLD,\n\t.ht_supported = true,\n\t.ampdu_factor = IEEE80211_HT_MAX_AMPDU_16K,\n\t.ampdu_density = IEEE80211_HT_MPDU_DENSITY_16,\n\t.mcs = {\n\t\t.rx_mask = { 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t\t.rx_highest = cpu_to_le16(150),\n\t\t.tx_params = IEEE80211_HT_MCS_TX_DEFINED,\n\t\t},\n};\n\n \nstatic struct ieee80211_sta_ht_cap wl18xx_siso20_ht_cap = {\n\t.cap = IEEE80211_HT_CAP_SGI_20 |\n\t       IEEE80211_HT_CAP_GRN_FLD,\n\t.ht_supported = true,\n\t.ampdu_factor = IEEE80211_HT_MAX_AMPDU_16K,\n\t.ampdu_density = IEEE80211_HT_MPDU_DENSITY_16,\n\t.mcs = {\n\t\t.rx_mask = { 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t\t.rx_highest = cpu_to_le16(72),\n\t\t.tx_params = IEEE80211_HT_MCS_TX_DEFINED,\n\t\t},\n};\n\n \nstatic struct ieee80211_sta_ht_cap wl18xx_mimo_ht_cap_2ghz = {\n\t.cap = IEEE80211_HT_CAP_SGI_20 |\n\t       IEEE80211_HT_CAP_GRN_FLD,\n\t.ht_supported = true,\n\t.ampdu_factor = IEEE80211_HT_MAX_AMPDU_16K,\n\t.ampdu_density = IEEE80211_HT_MPDU_DENSITY_16,\n\t.mcs = {\n\t\t.rx_mask = { 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t\t.rx_highest = cpu_to_le16(144),\n\t\t.tx_params = IEEE80211_HT_MCS_TX_DEFINED,\n\t\t},\n};\n\nstatic const struct ieee80211_iface_limit wl18xx_iface_limits[] = {\n\t{\n\t\t.max = 2,\n\t\t.types = BIT(NL80211_IFTYPE_STATION),\n\t},\n\t{\n\t\t.max = 1,\n\t\t.types =   BIT(NL80211_IFTYPE_AP)\n\t\t\t | BIT(NL80211_IFTYPE_P2P_GO)\n\t\t\t | BIT(NL80211_IFTYPE_P2P_CLIENT)\n#ifdef CONFIG_MAC80211_MESH\n\t\t\t | BIT(NL80211_IFTYPE_MESH_POINT)\n#endif\n\t},\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_P2P_DEVICE),\n\t},\n};\n\nstatic const struct ieee80211_iface_limit wl18xx_iface_ap_limits[] = {\n\t{\n\t\t.max = 2,\n\t\t.types = BIT(NL80211_IFTYPE_AP),\n\t},\n#ifdef CONFIG_MAC80211_MESH\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_MESH_POINT),\n\t},\n#endif\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_P2P_DEVICE),\n\t},\n};\n\nstatic const struct ieee80211_iface_combination\nwl18xx_iface_combinations[] = {\n\t{\n\t\t.max_interfaces = 3,\n\t\t.limits = wl18xx_iface_limits,\n\t\t.n_limits = ARRAY_SIZE(wl18xx_iface_limits),\n\t\t.num_different_channels = 2,\n\t},\n\t{\n\t\t.max_interfaces = 2,\n\t\t.limits = wl18xx_iface_ap_limits,\n\t\t.n_limits = ARRAY_SIZE(wl18xx_iface_ap_limits),\n\t\t.num_different_channels = 1,\n\t\t.radar_detect_widths =\tBIT(NL80211_CHAN_NO_HT) |\n\t\t\t\t\tBIT(NL80211_CHAN_HT20) |\n\t\t\t\t\tBIT(NL80211_CHAN_HT40MINUS) |\n\t\t\t\t\tBIT(NL80211_CHAN_HT40PLUS),\n\t}\n};\n\nstatic int wl18xx_setup(struct wl1271 *wl)\n{\n\tstruct wl18xx_priv *priv = wl->priv;\n\tint ret;\n\n\tBUILD_BUG_ON(WL18XX_MAX_LINKS > WLCORE_MAX_LINKS);\n\tBUILD_BUG_ON(WL18XX_MAX_AP_STATIONS > WL18XX_MAX_LINKS);\n\tBUILD_BUG_ON(WL18XX_CONF_SG_PARAMS_MAX > WLCORE_CONF_SG_PARAMS_MAX);\n\n\twl->rtable = wl18xx_rtable;\n\twl->num_tx_desc = WL18XX_NUM_TX_DESCRIPTORS;\n\twl->num_rx_desc = WL18XX_NUM_RX_DESCRIPTORS;\n\twl->num_links = WL18XX_MAX_LINKS;\n\twl->max_ap_stations = WL18XX_MAX_AP_STATIONS;\n\twl->iface_combinations = wl18xx_iface_combinations;\n\twl->n_iface_combinations = ARRAY_SIZE(wl18xx_iface_combinations);\n\twl->num_mac_addr = WL18XX_NUM_MAC_ADDRESSES;\n\twl->band_rate_to_idx = wl18xx_band_rate_to_idx;\n\twl->hw_tx_rate_tbl_size = WL18XX_CONF_HW_RXTX_RATE_MAX;\n\twl->hw_min_ht_rate = WL18XX_CONF_HW_RXTX_RATE_MCS0;\n\twl->fw_status_len = sizeof(struct wl18xx_fw_status);\n\twl->fw_status_priv_len = sizeof(struct wl18xx_fw_status_priv);\n\twl->stats.fw_stats_len = sizeof(struct wl18xx_acx_statistics);\n\twl->static_data_priv_len = sizeof(struct wl18xx_static_data_priv);\n\n\tif (num_rx_desc_param != -1)\n\t\twl->num_rx_desc = num_rx_desc_param;\n\n\tret = wl18xx_conf_init(wl, wl->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (board_type_param) {\n\t\tif (!strcmp(board_type_param, \"fpga\")) {\n\t\t\tpriv->conf.phy.board_type = BOARD_TYPE_FPGA_18XX;\n\t\t} else if (!strcmp(board_type_param, \"hdk\")) {\n\t\t\tpriv->conf.phy.board_type = BOARD_TYPE_HDK_18XX;\n\t\t} else if (!strcmp(board_type_param, \"dvp\")) {\n\t\t\tpriv->conf.phy.board_type = BOARD_TYPE_DVP_18XX;\n\t\t} else if (!strcmp(board_type_param, \"evb\")) {\n\t\t\tpriv->conf.phy.board_type = BOARD_TYPE_EVB_18XX;\n\t\t} else if (!strcmp(board_type_param, \"com8\")) {\n\t\t\tpriv->conf.phy.board_type = BOARD_TYPE_COM8_18XX;\n\t\t} else {\n\t\t\twl1271_error(\"invalid board type '%s'\",\n\t\t\t\tboard_type_param);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (priv->conf.phy.board_type >= NUM_BOARD_TYPES) {\n\t\twl1271_error(\"invalid board type '%d'\",\n\t\t\tpriv->conf.phy.board_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (low_band_component_param != -1)\n\t\tpriv->conf.phy.low_band_component = low_band_component_param;\n\tif (low_band_component_type_param != -1)\n\t\tpriv->conf.phy.low_band_component_type =\n\t\t\tlow_band_component_type_param;\n\tif (high_band_component_param != -1)\n\t\tpriv->conf.phy.high_band_component = high_band_component_param;\n\tif (high_band_component_type_param != -1)\n\t\tpriv->conf.phy.high_band_component_type =\n\t\t\thigh_band_component_type_param;\n\tif (pwr_limit_reference_11_abg_param != -1)\n\t\tpriv->conf.phy.pwr_limit_reference_11_abg =\n\t\t\tpwr_limit_reference_11_abg_param;\n\tif (n_antennas_2_param != -1)\n\t\tpriv->conf.phy.number_of_assembled_ant2_4 = n_antennas_2_param;\n\tif (n_antennas_5_param != -1)\n\t\tpriv->conf.phy.number_of_assembled_ant5 = n_antennas_5_param;\n\tif (dc2dc_param != -1)\n\t\tpriv->conf.phy.external_pa_dc2dc = dc2dc_param;\n\n\tif (ht_mode_param) {\n\t\tif (!strcmp(ht_mode_param, \"default\"))\n\t\t\tpriv->conf.ht.mode = HT_MODE_DEFAULT;\n\t\telse if (!strcmp(ht_mode_param, \"wide\"))\n\t\t\tpriv->conf.ht.mode = HT_MODE_WIDE;\n\t\telse if (!strcmp(ht_mode_param, \"siso20\"))\n\t\t\tpriv->conf.ht.mode = HT_MODE_SISO20;\n\t\telse {\n\t\t\twl1271_error(\"invalid ht_mode '%s'\", ht_mode_param);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (priv->conf.ht.mode == HT_MODE_DEFAULT) {\n\t\t \n\t\tif (wl18xx_is_mimo_supported(wl))\n\t\t\twlcore_set_ht_cap(wl, NL80211_BAND_2GHZ,\n\t\t\t\t\t  &wl18xx_mimo_ht_cap_2ghz);\n\t\telse\n\t\t\twlcore_set_ht_cap(wl, NL80211_BAND_2GHZ,\n\t\t\t\t\t  &wl18xx_siso40_ht_cap_2ghz);\n\n\t\t \n\t\twlcore_set_ht_cap(wl, NL80211_BAND_5GHZ,\n\t\t\t\t  &wl18xx_siso40_ht_cap_5ghz);\n\t} else if (priv->conf.ht.mode == HT_MODE_WIDE) {\n\t\twlcore_set_ht_cap(wl, NL80211_BAND_2GHZ,\n\t\t\t\t  &wl18xx_siso40_ht_cap_2ghz);\n\t\twlcore_set_ht_cap(wl, NL80211_BAND_5GHZ,\n\t\t\t\t  &wl18xx_siso40_ht_cap_5ghz);\n\t} else if (priv->conf.ht.mode == HT_MODE_SISO20) {\n\t\twlcore_set_ht_cap(wl, NL80211_BAND_2GHZ,\n\t\t\t\t  &wl18xx_siso20_ht_cap);\n\t\twlcore_set_ht_cap(wl, NL80211_BAND_5GHZ,\n\t\t\t\t  &wl18xx_siso20_ht_cap);\n\t}\n\n\tif (!checksum_param) {\n\t\twl18xx_ops.set_rx_csum = NULL;\n\t\twl18xx_ops.init_vif = NULL;\n\t}\n\n\t \n\twl->enable_11a = (priv->conf.phy.number_of_assembled_ant5 != 0);\n\n\treturn 0;\n}\n\nstatic int wl18xx_probe(struct platform_device *pdev)\n{\n\tstruct wl1271 *wl;\n\tstruct ieee80211_hw *hw;\n\tint ret;\n\n\thw = wlcore_alloc_hw(sizeof(struct wl18xx_priv),\n\t\t\t     WL18XX_AGGR_BUFFER_SIZE,\n\t\t\t     sizeof(struct wl18xx_event_mailbox));\n\tif (IS_ERR(hw)) {\n\t\twl1271_error(\"can't allocate hw\");\n\t\tret = PTR_ERR(hw);\n\t\tgoto out;\n\t}\n\n\twl = hw->priv;\n\twl->ops = &wl18xx_ops;\n\twl->ptable = wl18xx_ptable;\n\tret = wlcore_probe(wl, pdev);\n\tif (ret)\n\t\tgoto out_free;\n\n\treturn ret;\n\nout_free:\n\twlcore_free_hw(wl);\nout:\n\treturn ret;\n}\n\nstatic const struct platform_device_id wl18xx_id_table[] = {\n\t{ \"wl18xx\", 0 },\n\t{  }  \n};\nMODULE_DEVICE_TABLE(platform, wl18xx_id_table);\n\nstatic struct platform_driver wl18xx_driver = {\n\t.probe\t\t= wl18xx_probe,\n\t.remove\t\t= wlcore_remove,\n\t.id_table\t= wl18xx_id_table,\n\t.driver = {\n\t\t.name\t= \"wl18xx_driver\",\n\t}\n};\n\nmodule_platform_driver(wl18xx_driver);\nmodule_param_named(ht_mode, ht_mode_param, charp, 0400);\nMODULE_PARM_DESC(ht_mode, \"Force HT mode: wide or siso20\");\n\nmodule_param_named(board_type, board_type_param, charp, 0400);\nMODULE_PARM_DESC(board_type, \"Board type: fpga, hdk (default), evb, com8 or \"\n\t\t \"dvp\");\n\nmodule_param_named(checksum, checksum_param, bool, 0400);\nMODULE_PARM_DESC(checksum, \"Enable TCP checksum: boolean (defaults to false)\");\n\nmodule_param_named(dc2dc, dc2dc_param, int, 0400);\nMODULE_PARM_DESC(dc2dc, \"External DC2DC: u8 (defaults to 0)\");\n\nmodule_param_named(n_antennas_2, n_antennas_2_param, int, 0400);\nMODULE_PARM_DESC(n_antennas_2,\n\t\t \"Number of installed 2.4GHz antennas: 1 (default) or 2\");\n\nmodule_param_named(n_antennas_5, n_antennas_5_param, int, 0400);\nMODULE_PARM_DESC(n_antennas_5,\n\t\t \"Number of installed 5GHz antennas: 1 (default) or 2\");\n\nmodule_param_named(low_band_component, low_band_component_param, int, 0400);\nMODULE_PARM_DESC(low_band_component, \"Low band component: u8 \"\n\t\t \"(default is 0x01)\");\n\nmodule_param_named(low_band_component_type, low_band_component_type_param,\n\t\t   int, 0400);\nMODULE_PARM_DESC(low_band_component_type, \"Low band component type: u8 \"\n\t\t \"(default is 0x05 or 0x06 depending on the board_type)\");\n\nmodule_param_named(high_band_component, high_band_component_param, int, 0400);\nMODULE_PARM_DESC(high_band_component, \"High band component: u8, \"\n\t\t \"(default is 0x01)\");\n\nmodule_param_named(high_band_component_type, high_band_component_type_param,\n\t\t   int, 0400);\nMODULE_PARM_DESC(high_band_component_type, \"High band component type: u8 \"\n\t\t \"(default is 0x09)\");\n\nmodule_param_named(pwr_limit_reference_11_abg,\n\t\t   pwr_limit_reference_11_abg_param, int, 0400);\nMODULE_PARM_DESC(pwr_limit_reference_11_abg, \"Power limit reference: u8 \"\n\t\t \"(default is 0xc8)\");\n\nmodule_param_named(num_rx_desc, num_rx_desc_param, int, 0400);\nMODULE_PARM_DESC(num_rx_desc_param,\n\t\t \"Number of Rx descriptors: u8 (default is 32)\");\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Luciano Coelho <coelho@ti.com>\");\nMODULE_FIRMWARE(WL18XX_FW_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}