{
  "module_name": "acx.c",
  "hash_id": "2cd6fc74e95c16e11e1c2e3bc3cac2104b17c201c989cee3fc4bd087c4e8b549",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wl18xx/acx.c",
  "human_readable_source": "\n \n\n#include \"../wlcore/cmd.h\"\n#include \"../wlcore/debug.h\"\n#include \"../wlcore/acx.h\"\n\n#include \"acx.h\"\n#include \"wl18xx.h\"\n\nint wl18xx_acx_host_if_cfg_bitmap(struct wl1271 *wl, u32 host_cfg_bitmap,\n\t\t\t\t  u32 sdio_blk_size, u32 extra_mem_blks,\n\t\t\t\t  u32 len_field_size)\n{\n\tstruct wl18xx_acx_host_config_bitmap *bitmap_conf;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx cfg bitmap %d blk %d spare %d field %d\",\n\t\t     host_cfg_bitmap, sdio_blk_size, extra_mem_blks,\n\t\t     len_field_size);\n\n\tbitmap_conf = kzalloc(sizeof(*bitmap_conf), GFP_KERNEL);\n\tif (!bitmap_conf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tbitmap_conf->host_cfg_bitmap = cpu_to_le32(host_cfg_bitmap);\n\tbitmap_conf->host_sdio_block_size = cpu_to_le32(sdio_blk_size);\n\tbitmap_conf->extra_mem_blocks = cpu_to_le32(extra_mem_blks);\n\tbitmap_conf->length_field_size = cpu_to_le32(len_field_size);\n\n\tret = wl1271_cmd_configure(wl, ACX_HOST_IF_CFG_BITMAP,\n\t\t\t\t   bitmap_conf, sizeof(*bitmap_conf));\n\tif (ret < 0) {\n\t\twl1271_warning(\"wl1271 bitmap config opt failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(bitmap_conf);\n\n\treturn ret;\n}\n\nint wl18xx_acx_set_checksum_state(struct wl1271 *wl)\n{\n\tstruct wl18xx_acx_checksum_state *acx;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx checksum state\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->checksum_state = CHECKSUM_OFFLOAD_ENABLED;\n\n\tret = wl1271_cmd_configure(wl, ACX_CSUM_CONFIG, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"failed to set Tx checksum state: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl18xx_acx_clear_statistics(struct wl1271 *wl)\n{\n\tstruct wl18xx_acx_clear_statistics *acx;\n\tint ret = 0;\n\n\twl1271_debug(DEBUG_ACX, \"acx clear statistics\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = wl1271_cmd_configure(wl, ACX_CLEAR_STATISTICS, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"failed to clear firmware statistics: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl18xx_acx_peer_ht_operation_mode(struct wl1271 *wl, u8 hlid, bool wide)\n{\n\tstruct wlcore_peer_ht_operation_mode *acx;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx peer ht operation mode hlid %d bw %d\",\n\t\t     hlid, wide);\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->hlid = hlid;\n\tacx->bandwidth = wide ? WLCORE_BANDWIDTH_40MHZ : WLCORE_BANDWIDTH_20MHZ;\n\n\tret = wl1271_cmd_configure(wl, ACX_PEER_HT_OPERATION_MODE_CFG, acx,\n\t\t\t\t   sizeof(*acx));\n\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx peer ht operation mode failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n\n}\n\n \nint wl18xx_acx_set_peer_cap(struct wl1271 *wl,\n\t\t\t    struct ieee80211_sta_ht_cap *ht_cap,\n\t\t\t    bool allow_ht_operation,\n\t\t\t    u32 rate_set, u8 hlid)\n{\n\tstruct wlcore_acx_peer_cap *acx;\n\tint ret = 0;\n\tu32 ht_capabilites = 0;\n\n\twl1271_debug(DEBUG_ACX,\n\t\t     \"acx set cap ht_supp: %d ht_cap: %d rates: 0x%x\",\n\t\t     ht_cap->ht_supported, ht_cap->cap, rate_set);\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (allow_ht_operation && ht_cap->ht_supported) {\n\t\t \n\t\tht_capabilites = ht_cap->cap;\n\n\t\t \n\t\tht_capabilites |= WL12XX_HT_CAP_HT_OPERATION;\n\n\t\t \n\t\tacx->ampdu_max_length = ht_cap->ampdu_factor;\n\t\tacx->ampdu_min_spacing = ht_cap->ampdu_density;\n\t}\n\n\tacx->hlid = hlid;\n\tacx->ht_capabilites = cpu_to_le32(ht_capabilites);\n\tacx->supported_rates = cpu_to_le32(rate_set);\n\n\tret = wl1271_cmd_configure(wl, ACX_PEER_CAP, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx ht capabilities setting failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\n \nint wl18xx_acx_interrupt_notify_config(struct wl1271 *wl,\n\t\t\t\t       bool action)\n{\n\tstruct wl18xx_acx_interrupt_notify *acx;\n\tint ret = 0;\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->enable = action;\n\tret = wl1271_cmd_configure(wl, ACX_INTERRUPT_NOTIFY, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx interrupt notify setting failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\n \nint wl18xx_acx_rx_ba_filter(struct wl1271 *wl, bool action)\n{\n\tstruct wl18xx_acx_rx_ba_filter *acx;\n\tint ret = 0;\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->enable = (u32)action;\n\tret = wl1271_cmd_configure(wl, ACX_RX_BA_FILTER, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx rx ba activity filter setting failed: %d\",\n\t\t\t       ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl18xx_acx_ap_sleep(struct wl1271 *wl)\n{\n\tstruct wl18xx_priv *priv = wl->priv;\n\tstruct acx_ap_sleep_cfg *acx;\n\tstruct conf_ap_sleep_settings *conf = &priv->conf.ap_sleep;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx config ap sleep\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->idle_duty_cycle = conf->idle_duty_cycle;\n\tacx->connected_duty_cycle = conf->connected_duty_cycle;\n\tacx->max_stations_thresh = conf->max_stations_thresh;\n\tacx->idle_conn_thresh = conf->idle_conn_thresh;\n\n\tret = wl1271_cmd_configure(wl, ACX_AP_SLEEP_CFG, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx config ap-sleep failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl18xx_acx_dynamic_fw_traces(struct wl1271 *wl)\n{\n\tstruct acx_dynamic_fw_traces_cfg *acx;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx dynamic fw traces config %d\",\n\t\t     wl->dynamic_fw_traces);\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->dynamic_fw_traces = cpu_to_le32(wl->dynamic_fw_traces);\n\n\tret = wl1271_cmd_configure(wl, ACX_DYNAMIC_TRACES_CFG,\n\t\t\t\t   acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx config dynamic fw traces failed: %d\", ret);\n\t\tgoto out;\n\t}\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl18xx_acx_time_sync_cfg(struct wl1271 *wl)\n{\n\tstruct acx_time_sync_cfg *acx;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx time sync cfg: mode %d, addr: %pM\",\n\t\t     wl->conf.sg.params[WL18XX_CONF_SG_TIME_SYNC],\n\t\t     wl->zone_master_mac_addr);\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->sync_mode = wl->conf.sg.params[WL18XX_CONF_SG_TIME_SYNC];\n\tmemcpy(acx->zone_mac_addr, wl->zone_master_mac_addr, ETH_ALEN);\n\n\tret = wl1271_cmd_configure(wl, ACX_TIME_SYNC_CFG,\n\t\t\t\t   acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx time sync cfg failed: %d\", ret);\n\t\tgoto out;\n\t}\nout:\n\tkfree(acx);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}