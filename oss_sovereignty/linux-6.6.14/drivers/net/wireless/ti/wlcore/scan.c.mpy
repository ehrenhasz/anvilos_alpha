{
  "module_name": "scan.c",
  "hash_id": "28f6d601721b7a4d1b0855c276c38b2daa0b74a460337617b3be19e2824b57e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wlcore/scan.c",
  "human_readable_source": "\n \n\n#include <linux/ieee80211.h>\n#include <linux/pm_runtime.h>\n\n#include \"wlcore.h\"\n#include \"debug.h\"\n#include \"cmd.h\"\n#include \"scan.h\"\n#include \"acx.h\"\n#include \"tx.h\"\n\nvoid wl1271_scan_complete_work(struct work_struct *work)\n{\n\tstruct delayed_work *dwork;\n\tstruct wl1271 *wl;\n\tstruct wl12xx_vif *wlvif;\n\tstruct cfg80211_scan_info info = {\n\t\t.aborted = false,\n\t};\n\tint ret;\n\n\tdwork = to_delayed_work(work);\n\twl = container_of(dwork, struct wl1271, scan_complete_work);\n\n\twl1271_debug(DEBUG_SCAN, \"Scanning complete\");\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON))\n\t\tgoto out;\n\n\tif (wl->scan.state == WL1271_SCAN_STATE_IDLE)\n\t\tgoto out;\n\n\twlvif = wl->scan_wlvif;\n\n\t \n\twl12xx_rearm_tx_watchdog_locked(wl);\n\n\twl->scan.state = WL1271_SCAN_STATE_IDLE;\n\tmemset(wl->scan.scanned_ch, 0, sizeof(wl->scan.scanned_ch));\n\twl->scan.req = NULL;\n\twl->scan_wlvif = NULL;\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags)) {\n\t\t \n\t\twl1271_cmd_build_ap_probe_req(wl, wlvif, wlvif->probereq);\n\t}\n\n\tif (wl->scan.failed) {\n\t\twl1271_info(\"Scan completed due to error.\");\n\t\twl12xx_queue_recovery_work(wl);\n\t}\n\n\twlcore_cmd_regdomain_config_locked(wl);\n\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\n\n\tieee80211_scan_completed(wl->hw, &info);\n\nout:\n\tmutex_unlock(&wl->mutex);\n\n}\n\nstatic void wlcore_started_vifs_iter(void *data, u8 *mac,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tbool active = false;\n\tint *count = (int *)data;\n\n\t \n\tswitch (wlvif->bss_type) {\n\tcase BSS_TYPE_STA_BSS:\n\t\tif (test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags))\n\t\t\tactive = true;\n\t\tbreak;\n\n\tcase BSS_TYPE_AP_BSS:\n\t\tif (wlvif->wl->active_sta_count > 0)\n\t\t\tactive = true;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (active)\n\t\t(*count)++;\n}\n\nstatic int wlcore_count_started_vifs(struct wl1271 *wl)\n{\n\tint count = 0;\n\n\tieee80211_iterate_active_interfaces_atomic(wl->hw,\n\t\t\t\t\tIEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\t\t\twlcore_started_vifs_iter, &count);\n\treturn count;\n}\n\nstatic int\nwlcore_scan_get_channels(struct wl1271 *wl,\n\t\t\t struct ieee80211_channel *req_channels[],\n\t\t\t u32 n_channels,\n\t\t\t u32 n_ssids,\n\t\t\t struct conn_scan_ch_params *channels,\n\t\t\t u32 band, bool radar, bool passive,\n\t\t\t int start, int max_channels,\n\t\t\t u8 *n_pactive_ch,\n\t\t\t int scan_type)\n{\n\tint i, j;\n\tu32 flags;\n\tbool force_passive = !n_ssids;\n\tu32 min_dwell_time_active, max_dwell_time_active;\n\tu32 dwell_time_passive, dwell_time_dfs;\n\n\t \n\tif (scan_type == SCAN_TYPE_SEARCH) {\n\t\tstruct conf_scan_settings *c = &wl->conf.scan;\n\t\tbool active_vif_exists = !!wlcore_count_started_vifs(wl);\n\n\t\tmin_dwell_time_active = active_vif_exists ?\n\t\t\tc->min_dwell_time_active :\n\t\t\tc->min_dwell_time_active_long;\n\t\tmax_dwell_time_active = active_vif_exists ?\n\t\t\tc->max_dwell_time_active :\n\t\t\tc->max_dwell_time_active_long;\n\t\tdwell_time_passive = c->dwell_time_passive;\n\t\tdwell_time_dfs = c->dwell_time_dfs;\n\t} else {\n\t\tstruct conf_sched_scan_settings *c = &wl->conf.sched_scan;\n\t\tu32 delta_per_probe;\n\n\t\tif (band == NL80211_BAND_5GHZ)\n\t\t\tdelta_per_probe = c->dwell_time_delta_per_probe_5;\n\t\telse\n\t\t\tdelta_per_probe = c->dwell_time_delta_per_probe;\n\n\t\tmin_dwell_time_active = c->base_dwell_time +\n\t\t\t n_ssids * c->num_probe_reqs * delta_per_probe;\n\n\t\tmax_dwell_time_active = min_dwell_time_active +\n\t\t\t\t\tc->max_dwell_time_delta;\n\t\tdwell_time_passive = c->dwell_time_passive;\n\t\tdwell_time_dfs = c->dwell_time_dfs;\n\t}\n\tmin_dwell_time_active = DIV_ROUND_UP(min_dwell_time_active, 1000);\n\tmax_dwell_time_active = DIV_ROUND_UP(max_dwell_time_active, 1000);\n\tdwell_time_passive = DIV_ROUND_UP(dwell_time_passive, 1000);\n\tdwell_time_dfs = DIV_ROUND_UP(dwell_time_dfs, 1000);\n\n\tfor (i = 0, j = start;\n\t     i < n_channels && j < max_channels;\n\t     i++) {\n\t\tflags = req_channels[i]->flags;\n\n\t\tif (force_passive)\n\t\t\tflags |= IEEE80211_CHAN_NO_IR;\n\n\t\tif ((req_channels[i]->band == band) &&\n\t\t    !(flags & IEEE80211_CHAN_DISABLED) &&\n\t\t    (!!(flags & IEEE80211_CHAN_RADAR) == radar) &&\n\t\t     \n\t\t    (radar ||\n\t\t     !!(flags & IEEE80211_CHAN_NO_IR) == passive)) {\n\t\t\tif (flags & IEEE80211_CHAN_RADAR) {\n\t\t\t\tchannels[j].flags |= SCAN_CHANNEL_FLAGS_DFS;\n\n\t\t\t\tchannels[j].passive_duration =\n\t\t\t\t\tcpu_to_le16(dwell_time_dfs);\n\t\t\t} else {\n\t\t\t\tchannels[j].passive_duration =\n\t\t\t\t\tcpu_to_le16(dwell_time_passive);\n\t\t\t}\n\n\t\t\tchannels[j].min_duration =\n\t\t\t\tcpu_to_le16(min_dwell_time_active);\n\t\t\tchannels[j].max_duration =\n\t\t\t\tcpu_to_le16(max_dwell_time_active);\n\n\t\t\tchannels[j].tx_power_att = req_channels[i]->max_power;\n\t\t\tchannels[j].channel = req_channels[i]->hw_value;\n\n\t\t\tif (n_pactive_ch &&\n\t\t\t    (band == NL80211_BAND_2GHZ) &&\n\t\t\t    (channels[j].channel >= 12) &&\n\t\t\t    (channels[j].channel <= 14) &&\n\t\t\t    (flags & IEEE80211_CHAN_NO_IR) &&\n\t\t\t    !force_passive) {\n\t\t\t\t \n\t\t\t\tchannels[j].flags = SCAN_CHANNEL_FLAGS_DFS;\n\n\t\t\t\t \n\t\t\t\t(*n_pactive_ch)++;\n\t\t\t\twl1271_debug(DEBUG_SCAN, \"n_pactive_ch = %d\",\n\t\t\t\t\t     *n_pactive_ch);\n\t\t\t}\n\n\t\t\twl1271_debug(DEBUG_SCAN, \"freq %d, ch. %d, flags 0x%x, power %d, min/max_dwell %d/%d%s%s\",\n\t\t\t\t     req_channels[i]->center_freq,\n\t\t\t\t     req_channels[i]->hw_value,\n\t\t\t\t     req_channels[i]->flags,\n\t\t\t\t     req_channels[i]->max_power,\n\t\t\t\t     min_dwell_time_active,\n\t\t\t\t     max_dwell_time_active,\n\t\t\t\t     flags & IEEE80211_CHAN_RADAR ?\n\t\t\t\t\t\", DFS\" : \"\",\n\t\t\t\t     flags & IEEE80211_CHAN_NO_IR ?\n\t\t\t\t\t\", NO-IR\" : \"\");\n\t\t\tj++;\n\t\t}\n\t}\n\n\treturn j - start;\n}\n\nbool\nwlcore_set_scan_chan_params(struct wl1271 *wl,\n\t\t\t    struct wlcore_scan_channels *cfg,\n\t\t\t    struct ieee80211_channel *channels[],\n\t\t\t    u32 n_channels,\n\t\t\t    u32 n_ssids,\n\t\t\t    int scan_type)\n{\n\tu8 n_pactive_ch = 0;\n\n\tcfg->passive[0] =\n\t\twlcore_scan_get_channels(wl,\n\t\t\t\t\t channels,\n\t\t\t\t\t n_channels,\n\t\t\t\t\t n_ssids,\n\t\t\t\t\t cfg->channels_2,\n\t\t\t\t\t NL80211_BAND_2GHZ,\n\t\t\t\t\t false, true, 0,\n\t\t\t\t\t MAX_CHANNELS_2GHZ,\n\t\t\t\t\t &n_pactive_ch,\n\t\t\t\t\t scan_type);\n\tcfg->active[0] =\n\t\twlcore_scan_get_channels(wl,\n\t\t\t\t\t channels,\n\t\t\t\t\t n_channels,\n\t\t\t\t\t n_ssids,\n\t\t\t\t\t cfg->channels_2,\n\t\t\t\t\t NL80211_BAND_2GHZ,\n\t\t\t\t\t false, false,\n\t\t\t\t\t cfg->passive[0],\n\t\t\t\t\t MAX_CHANNELS_2GHZ,\n\t\t\t\t\t &n_pactive_ch,\n\t\t\t\t\t scan_type);\n\tcfg->passive[1] =\n\t\twlcore_scan_get_channels(wl,\n\t\t\t\t\t channels,\n\t\t\t\t\t n_channels,\n\t\t\t\t\t n_ssids,\n\t\t\t\t\t cfg->channels_5,\n\t\t\t\t\t NL80211_BAND_5GHZ,\n\t\t\t\t\t false, true, 0,\n\t\t\t\t\t wl->max_channels_5,\n\t\t\t\t\t &n_pactive_ch,\n\t\t\t\t\t scan_type);\n\tcfg->dfs =\n\t\twlcore_scan_get_channels(wl,\n\t\t\t\t\t channels,\n\t\t\t\t\t n_channels,\n\t\t\t\t\t n_ssids,\n\t\t\t\t\t cfg->channels_5,\n\t\t\t\t\t NL80211_BAND_5GHZ,\n\t\t\t\t\t true, true,\n\t\t\t\t\t cfg->passive[1],\n\t\t\t\t\t wl->max_channels_5,\n\t\t\t\t\t &n_pactive_ch,\n\t\t\t\t\t scan_type);\n\tcfg->active[1] =\n\t\twlcore_scan_get_channels(wl,\n\t\t\t\t\t channels,\n\t\t\t\t\t n_channels,\n\t\t\t\t\t n_ssids,\n\t\t\t\t\t cfg->channels_5,\n\t\t\t\t\t NL80211_BAND_5GHZ,\n\t\t\t\t\t false, false,\n\t\t\t\t\t cfg->passive[1] + cfg->dfs,\n\t\t\t\t\t wl->max_channels_5,\n\t\t\t\t\t &n_pactive_ch,\n\t\t\t\t\t scan_type);\n\n\t \n\tcfg->passive[2] = 0;\n\tcfg->active[2] = 0;\n\n\tcfg->passive_active = n_pactive_ch;\n\n\twl1271_debug(DEBUG_SCAN, \"    2.4GHz: active %d passive %d\",\n\t\t     cfg->active[0], cfg->passive[0]);\n\twl1271_debug(DEBUG_SCAN, \"    5GHz: active %d passive %d\",\n\t\t     cfg->active[1], cfg->passive[1]);\n\twl1271_debug(DEBUG_SCAN, \"    DFS: %d\", cfg->dfs);\n\n\treturn  cfg->passive[0] || cfg->active[0] ||\n\t\tcfg->passive[1] || cfg->active[1] || cfg->dfs ||\n\t\tcfg->passive[2] || cfg->active[2];\n}\nEXPORT_SYMBOL_GPL(wlcore_set_scan_chan_params);\n\nint wlcore_scan(struct wl1271 *wl, struct ieee80211_vif *vif,\n\t\tconst u8 *ssid, size_t ssid_len,\n\t\tstruct cfg80211_scan_request *req)\n{\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\n\t \n\tBUG_ON(req->n_channels > WL1271_MAX_CHANNELS);\n\n\tif (wl->scan.state != WL1271_SCAN_STATE_IDLE)\n\t\treturn -EBUSY;\n\n\twl->scan.state = WL1271_SCAN_STATE_2GHZ_ACTIVE;\n\n\tif (ssid_len && ssid) {\n\t\twl->scan.ssid_len = ssid_len;\n\t\tmemcpy(wl->scan.ssid, ssid, ssid_len);\n\t} else {\n\t\twl->scan.ssid_len = 0;\n\t}\n\n\twl->scan_wlvif = wlvif;\n\twl->scan.req = req;\n\tmemset(wl->scan.scanned_ch, 0, sizeof(wl->scan.scanned_ch));\n\n\t \n\twl->scan.failed = true;\n\tieee80211_queue_delayed_work(wl->hw, &wl->scan_complete_work,\n\t\t\t\t     msecs_to_jiffies(WL1271_SCAN_TIMEOUT));\n\n\twl->ops->scan_start(wl, wlvif, req);\n\n\treturn 0;\n}\n \nint\nwlcore_scan_sched_scan_ssid_list(struct wl1271 *wl,\n\t\t\t\t struct wl12xx_vif *wlvif,\n\t\t\t\t struct cfg80211_sched_scan_request *req)\n{\n\tstruct wl1271_cmd_sched_scan_ssid_list *cmd = NULL;\n\tstruct cfg80211_match_set *sets = req->match_sets;\n\tstruct cfg80211_ssid *ssids = req->ssids;\n\tint ret = 0, type, i, j, n_match_ssids = 0;\n\n\twl1271_debug((DEBUG_CMD | DEBUG_SCAN), \"cmd sched scan ssid list\");\n\n\t \n\tfor (i = 0; i < req->n_match_sets; i++)\n\t\tif (sets[i].ssid.ssid_len > 0)\n\t\t\tn_match_ssids++;\n\n\t \n\tif (!n_match_ssids &&\n\t    (!req->n_ssids ||\n\t     (req->n_ssids == 1 && req->ssids[0].ssid_len == 0))) {\n\t\ttype = SCAN_SSID_FILTER_ANY;\n\t\tgoto out;\n\t}\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcmd->role_id = wlvif->role_id;\n\tif (!n_match_ssids) {\n\t\t \n\t\ttype = SCAN_SSID_FILTER_DISABLED;\n\n\t\tfor (i = 0; i < req->n_ssids; i++) {\n\t\t\tcmd->ssids[cmd->n_ssids].type = (ssids[i].ssid_len) ?\n\t\t\t\tSCAN_SSID_TYPE_HIDDEN : SCAN_SSID_TYPE_PUBLIC;\n\t\t\tcmd->ssids[cmd->n_ssids].len = ssids[i].ssid_len;\n\t\t\tmemcpy(cmd->ssids[cmd->n_ssids].ssid, ssids[i].ssid,\n\t\t\t       ssids[i].ssid_len);\n\t\t\tcmd->n_ssids++;\n\t\t}\n\t} else {\n\t\ttype = SCAN_SSID_FILTER_LIST;\n\n\t\t \n\t\tfor (i = 0; i < req->n_match_sets; i++) {\n\t\t\t \n\t\t\tif (!sets[i].ssid.ssid_len)\n\t\t\t\tcontinue;\n\n\t\t\tcmd->ssids[cmd->n_ssids].type = SCAN_SSID_TYPE_PUBLIC;\n\t\t\tcmd->ssids[cmd->n_ssids].len = sets[i].ssid.ssid_len;\n\t\t\tmemcpy(cmd->ssids[cmd->n_ssids].ssid,\n\t\t\t       sets[i].ssid.ssid, sets[i].ssid.ssid_len);\n\t\t\tcmd->n_ssids++;\n\t\t}\n\t\tif ((req->n_ssids > 1) ||\n\t\t    (req->n_ssids == 1 && req->ssids[0].ssid_len > 0)) {\n\t\t\t \n\t\t\tfor (i = 0; i < req->n_ssids; i++) {\n\t\t\t\tif (!req->ssids[i].ssid_len)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (j = 0; j < cmd->n_ssids; j++)\n\t\t\t\t\tif ((req->ssids[i].ssid_len ==\n\t\t\t\t\t     cmd->ssids[j].len) &&\n\t\t\t\t\t    !memcmp(req->ssids[i].ssid,\n\t\t\t\t\t\t   cmd->ssids[j].ssid,\n\t\t\t\t\t\t   req->ssids[i].ssid_len)) {\n\t\t\t\t\t\tcmd->ssids[j].type =\n\t\t\t\t\t\t\tSCAN_SSID_TYPE_HIDDEN;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (j == cmd->n_ssids) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out_free;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tret = wl1271_cmd_send(wl, CMD_CONNECTION_SCAN_SSID_CFG, cmd,\n\t\t\t      sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_error(\"cmd sched scan ssid list failed\");\n\t\tgoto out_free;\n\t}\n\nout_free:\n\tkfree(cmd);\nout:\n\tif (ret < 0)\n\t\treturn ret;\n\treturn type;\n}\nEXPORT_SYMBOL_GPL(wlcore_scan_sched_scan_ssid_list);\n\nvoid wlcore_scan_sched_scan_results(struct wl1271 *wl)\n{\n\twl1271_debug(DEBUG_SCAN, \"got periodic scan results\");\n\n\tieee80211_sched_scan_results(wl->hw);\n}\nEXPORT_SYMBOL_GPL(wlcore_scan_sched_scan_results);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}