{
  "module_name": "tx.h",
  "hash_id": "0b292455790dd4910c76ab92a8bab0d9aaa3d0fa24f261eecb97c00b1b5dafff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wlcore/tx.h",
  "human_readable_source": " \n \n\n#ifndef __TX_H__\n#define __TX_H__\n\n#define TX_HW_MGMT_PKT_LIFETIME_TU       2000\n#define TX_HW_AP_MODE_PKT_LIFETIME_TU    8000\n\n#define TX_HW_ATTR_SAVE_RETRIES          BIT(0)\n#define TX_HW_ATTR_HEADER_PAD            BIT(1)\n#define TX_HW_ATTR_SESSION_COUNTER       (BIT(2) | BIT(3) | BIT(4))\n#define TX_HW_ATTR_RATE_POLICY           (BIT(5) | BIT(6) | BIT(7) | \\\n\t\t\t\t\t  BIT(8) | BIT(9))\n#define TX_HW_ATTR_LAST_WORD_PAD         (BIT(10) | BIT(11))\n#define TX_HW_ATTR_TX_CMPLT_REQ          BIT(12)\n#define TX_HW_ATTR_TX_DUMMY_REQ          BIT(13)\n#define TX_HW_ATTR_HOST_ENCRYPT          BIT(14)\n#define TX_HW_ATTR_EAPOL_FRAME           BIT(15)\n\n#define TX_HW_ATTR_OFST_SAVE_RETRIES     0\n#define TX_HW_ATTR_OFST_HEADER_PAD       1\n#define TX_HW_ATTR_OFST_SESSION_COUNTER  2\n#define TX_HW_ATTR_OFST_RATE_POLICY      5\n#define TX_HW_ATTR_OFST_LAST_WORD_PAD    10\n#define TX_HW_ATTR_OFST_TX_CMPLT_REQ     12\n\n#define TX_HW_RESULT_QUEUE_LEN           16\n#define TX_HW_RESULT_QUEUE_LEN_MASK      0xf\n\n#define WL1271_TX_ALIGN_TO 4\n#define WL1271_EXTRA_SPACE_TKIP 4\n#define WL1271_EXTRA_SPACE_AES  8\n#define WL1271_EXTRA_SPACE_MAX  8\n\n \n#define WL1271_TID_MGMT 7\n\n \n#define WLCORE_PEND_AUTH_ROC_TIMEOUT     1000\n\nstruct wl127x_tx_mem {\n\t \n\tu8 extra_blocks;\n\t \n\tu8 total_mem_blocks;\n} __packed;\n\nstruct wl128x_tx_mem {\n\t \n\tu8 total_mem_blocks;\n\t \n\tu8 extra_bytes;\n} __packed;\n\nstruct wl18xx_tx_mem {\n\t \n\tu8 total_mem_blocks;\n\n\t \n\tu8 ctrl;\n} __packed;\n\n \n#define WL12XX_BUS_BLOCK_SIZE min(512u,\t\\\n\t    (1u << (8 * sizeof(((struct wl128x_tx_mem *) 0)->extra_bytes))))\n\nstruct wl1271_tx_hw_descr {\n\t \n\t__le16 length;\n\tunion {\n\t\tstruct wl127x_tx_mem wl127x_mem;\n\t\tstruct wl128x_tx_mem wl128x_mem;\n\t\tstruct wl18xx_tx_mem wl18xx_mem;\n\t} __packed;\n\t \n\t__le32 start_time;\n\t \n\t__le16 life_time;\n\t \n\t__le16 tx_attr;\n\t \n\tu8 id;\n\t \n\tu8 tid;\n\t \n\tu8 hlid;\n\n\tunion {\n\t\tu8 wl12xx_reserved;\n\n\t\t \n\t\tu8 wl18xx_checksum_data;\n\t} __packed;\n} __packed;\n\nenum wl1271_tx_hw_res_status {\n\tTX_SUCCESS          = 0,\n\tTX_HW_ERROR         = 1,\n\tTX_DISABLED         = 2,\n\tTX_RETRY_EXCEEDED   = 3,\n\tTX_TIMEOUT          = 4,\n\tTX_KEY_NOT_FOUND    = 5,\n\tTX_PEER_NOT_FOUND   = 6,\n\tTX_SESSION_MISMATCH = 7,\n\tTX_LINK_NOT_VALID   = 8,\n};\n\nstruct wl1271_tx_hw_res_descr {\n\t \n\tu8 id;\n\t \n\tu8 status;\n\t \n\t__le16 medium_usage;\n\t \n\t__le32 fw_handling_time;\n\t \n\t__le32 medium_delay;\n\t \n\tu8 tx_security_sequence_number_lsb;\n\t \n\tu8 ack_failures;\n\t \n\tu8 rate_class_index;\n\t \n\tu8 spare;\n} __packed;\n\nstruct wl1271_tx_hw_res_if {\n\t__le32 tx_result_fw_counter;\n\t__le32 tx_result_host_counter;\n\tstruct wl1271_tx_hw_res_descr tx_results_queue[TX_HW_RESULT_QUEUE_LEN];\n} __packed;\n\nenum wlcore_queue_stop_reason {\n\tWLCORE_QUEUE_STOP_REASON_WATERMARK,\n\tWLCORE_QUEUE_STOP_REASON_FW_RESTART,\n\tWLCORE_QUEUE_STOP_REASON_FLUSH,\n\tWLCORE_QUEUE_STOP_REASON_SPARE_BLK,  \n};\n\nstatic inline int wl1271_tx_get_queue(int queue)\n{\n\tswitch (queue) {\n\tcase 0:\n\t\treturn CONF_TX_AC_VO;\n\tcase 1:\n\t\treturn CONF_TX_AC_VI;\n\tcase 2:\n\t\treturn CONF_TX_AC_BE;\n\tcase 3:\n\t\treturn CONF_TX_AC_BK;\n\tdefault:\n\t\treturn CONF_TX_AC_BE;\n\t}\n}\n\nstatic inline\nint wlcore_tx_get_mac80211_queue(struct wl12xx_vif *wlvif, int queue)\n{\n\tint mac_queue = wlvif->hw_queue_base;\n\n\tswitch (queue) {\n\tcase CONF_TX_AC_VO:\n\t\treturn mac_queue + 0;\n\tcase CONF_TX_AC_VI:\n\t\treturn mac_queue + 1;\n\tcase CONF_TX_AC_BE:\n\t\treturn mac_queue + 2;\n\tcase CONF_TX_AC_BK:\n\t\treturn mac_queue + 3;\n\tdefault:\n\t\treturn mac_queue + 2;\n\t}\n}\n\nstatic inline int wl1271_tx_total_queue_count(struct wl1271 *wl)\n{\n\tint i, count = 0;\n\n\tfor (i = 0; i < NUM_TX_QUEUES; i++)\n\t\tcount += wl->tx_queue_count[i];\n\n\treturn count;\n}\n\nvoid wl1271_tx_work(struct work_struct *work);\nint wlcore_tx_work_locked(struct wl1271 *wl);\nint wlcore_tx_complete(struct wl1271 *wl);\nvoid wl12xx_tx_reset_wlvif(struct wl1271 *wl, struct wl12xx_vif *wlvif);\nvoid wl12xx_tx_reset(struct wl1271 *wl);\nvoid wl1271_tx_flush(struct wl1271 *wl);\nu8 wlcore_rate_to_idx(struct wl1271 *wl, u8 rate, enum nl80211_band band);\nu32 wl1271_tx_enabled_rates_get(struct wl1271 *wl, u32 rate_set,\n\t\t\t\tenum nl80211_band rate_band);\nu32 wl1271_tx_min_rate_get(struct wl1271 *wl, u32 rate_set);\nu8 wl12xx_tx_get_hlid(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t      struct sk_buff *skb, struct ieee80211_sta *sta);\nvoid wl1271_tx_reset_link_queues(struct wl1271 *wl, u8 hlid);\nvoid wl1271_handle_tx_low_watermark(struct wl1271 *wl);\nbool wl12xx_is_dummy_packet(struct wl1271 *wl, struct sk_buff *skb);\nvoid wl12xx_rearm_rx_streaming(struct wl1271 *wl, unsigned long *active_hlids);\nunsigned int wlcore_calc_packet_alignment(struct wl1271 *wl,\n\t\t\t\t\t  unsigned int packet_length);\nvoid wl1271_free_tx_id(struct wl1271 *wl, int id);\nvoid wlcore_stop_queue_locked(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t      u8 queue, enum wlcore_queue_stop_reason reason);\nvoid wlcore_stop_queue(struct wl1271 *wl, struct wl12xx_vif *wlvif, u8 queue,\n\t\t       enum wlcore_queue_stop_reason reason);\nvoid wlcore_wake_queue(struct wl1271 *wl, struct wl12xx_vif *wlvif, u8 queue,\n\t\t       enum wlcore_queue_stop_reason reason);\nvoid wlcore_stop_queues(struct wl1271 *wl,\n\t\t\tenum wlcore_queue_stop_reason reason);\nvoid wlcore_wake_queues(struct wl1271 *wl,\n\t\t\tenum wlcore_queue_stop_reason reason);\nbool wlcore_is_queue_stopped_by_reason(struct wl1271 *wl,\n\t\t\t\t       struct wl12xx_vif *wlvif, u8 queue,\n\t\t\t\t       enum wlcore_queue_stop_reason reason);\nbool\nwlcore_is_queue_stopped_by_reason_locked(struct wl1271 *wl,\n\t\t\t\t\t struct wl12xx_vif *wlvif,\n\t\t\t\t\t u8 queue,\n\t\t\t\t\t enum wlcore_queue_stop_reason reason);\nbool wlcore_is_queue_stopped_locked(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t\t    u8 queue);\n\n \nvoid wl1271_free_sta(struct wl1271 *wl, struct wl12xx_vif *wlvif, u8 hlid);\nvoid wl12xx_rearm_tx_watchdog_locked(struct wl1271 *wl);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}