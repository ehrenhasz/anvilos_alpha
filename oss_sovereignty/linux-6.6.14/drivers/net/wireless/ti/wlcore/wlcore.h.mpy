{
  "module_name": "wlcore.h",
  "hash_id": "157da501f9b0a8fa0c2c3855a5a437ac3bbc40b78623b124c5c03e7f63d3c1df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wlcore/wlcore.h",
  "human_readable_source": " \n \n\n#ifndef __WLCORE_H__\n#define __WLCORE_H__\n\n#include <linux/platform_device.h>\n\n#include \"wlcore_i.h\"\n#include \"event.h\"\n#include \"boot.h\"\n\n \n#define WLCORE_MAX_TX_DESCRIPTORS 32\n\n \n#define WLCORE_NUM_MAC_ADDRESSES 3\n\n \n#define WLCORE_MAX_TXPWR        25\n\n \n#define WLCORE_TI_OUI_ADDRESS 0x080028\n\n \nstruct wl1271_tx_hw_descr;\nenum wl_rx_buf_align;\nstruct wl1271_rx_descriptor;\n\nstruct wlcore_ops {\n\tint (*setup)(struct wl1271 *wl);\n\tint (*identify_chip)(struct wl1271 *wl);\n\tint (*identify_fw)(struct wl1271 *wl);\n\tint (*boot)(struct wl1271 *wl);\n\tint (*plt_init)(struct wl1271 *wl);\n\tint (*trigger_cmd)(struct wl1271 *wl, int cmd_box_addr,\n\t\t\t   void *buf, size_t len);\n\tint (*ack_event)(struct wl1271 *wl);\n\tint (*wait_for_event)(struct wl1271 *wl, enum wlcore_wait_event event,\n\t\t\t      bool *timeout);\n\tint (*process_mailbox_events)(struct wl1271 *wl);\n\tu32 (*calc_tx_blocks)(struct wl1271 *wl, u32 len, u32 spare_blks);\n\tvoid (*set_tx_desc_blocks)(struct wl1271 *wl,\n\t\t\t\t   struct wl1271_tx_hw_descr *desc,\n\t\t\t\t   u32 blks, u32 spare_blks);\n\tvoid (*set_tx_desc_data_len)(struct wl1271 *wl,\n\t\t\t\t     struct wl1271_tx_hw_descr *desc,\n\t\t\t\t     struct sk_buff *skb);\n\tenum wl_rx_buf_align (*get_rx_buf_align)(struct wl1271 *wl,\n\t\t\t\t\t\t u32 rx_desc);\n\tint (*prepare_read)(struct wl1271 *wl, u32 rx_desc, u32 len);\n\tu32 (*get_rx_packet_len)(struct wl1271 *wl, void *rx_data,\n\t\t\t\t u32 data_len);\n\tint (*tx_delayed_compl)(struct wl1271 *wl);\n\tvoid (*tx_immediate_compl)(struct wl1271 *wl);\n\tint (*hw_init)(struct wl1271 *wl);\n\tint (*init_vif)(struct wl1271 *wl, struct wl12xx_vif *wlvif);\n\tvoid (*convert_fw_status)(struct wl1271 *wl, void *raw_fw_status,\n\t\t\t\t  struct wl_fw_status *fw_status);\n\tu32 (*sta_get_ap_rate_mask)(struct wl1271 *wl,\n\t\t\t\t    struct wl12xx_vif *wlvif);\n\tint (*get_pg_ver)(struct wl1271 *wl, s8 *ver);\n\tint (*get_mac)(struct wl1271 *wl);\n\tvoid (*set_tx_desc_csum)(struct wl1271 *wl,\n\t\t\t\t struct wl1271_tx_hw_descr *desc,\n\t\t\t\t struct sk_buff *skb);\n\tvoid (*set_rx_csum)(struct wl1271 *wl,\n\t\t\t    struct wl1271_rx_descriptor *desc,\n\t\t\t    struct sk_buff *skb);\n\tu32 (*ap_get_mimo_wide_rate_mask)(struct wl1271 *wl,\n\t\t\t\t\t  struct wl12xx_vif *wlvif);\n\tint (*debugfs_init)(struct wl1271 *wl, struct dentry *rootdir);\n\tint (*handle_static_data)(struct wl1271 *wl,\n\t\t\t\t  struct wl1271_static_data *static_data);\n\tint (*scan_start)(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t  struct cfg80211_scan_request *req);\n\tint (*scan_stop)(struct wl1271 *wl, struct wl12xx_vif *wlvif);\n\tint (*sched_scan_start)(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t\tstruct cfg80211_sched_scan_request *req,\n\t\t\t\tstruct ieee80211_scan_ies *ies);\n\tvoid (*sched_scan_stop)(struct wl1271 *wl, struct wl12xx_vif *wlvif);\n\tint (*get_spare_blocks)(struct wl1271 *wl, bool is_gem);\n\tint (*set_key)(struct wl1271 *wl, enum set_key_cmd cmd,\n\t\t       struct ieee80211_vif *vif,\n\t\t       struct ieee80211_sta *sta,\n\t\t       struct ieee80211_key_conf *key_conf);\n\tint (*channel_switch)(struct wl1271 *wl,\n\t\t\t      struct wl12xx_vif *wlvif,\n\t\t\t      struct ieee80211_channel_switch *ch_switch);\n\tu32 (*pre_pkt_send)(struct wl1271 *wl, u32 buf_offset, u32 last_len);\n\tvoid (*sta_rc_update)(struct wl1271 *wl, struct wl12xx_vif *wlvif);\n\tint (*set_peer_cap)(struct wl1271 *wl,\n\t\t\t    struct ieee80211_sta_ht_cap *ht_cap,\n\t\t\t    bool allow_ht_operation,\n\t\t\t    u32 rate_set, u8 hlid);\n\tu32 (*convert_hwaddr)(struct wl1271 *wl, u32 hwaddr);\n\tbool (*lnk_high_prio)(struct wl1271 *wl, u8 hlid,\n\t\t\t      struct wl1271_link *lnk);\n\tbool (*lnk_low_prio)(struct wl1271 *wl, u8 hlid,\n\t\t\t     struct wl1271_link *lnk);\n\tint (*interrupt_notify)(struct wl1271 *wl, bool action);\n\tint (*rx_ba_filter)(struct wl1271 *wl, bool action);\n\tint (*ap_sleep)(struct wl1271 *wl);\n\tint (*smart_config_start)(struct wl1271 *wl, u32 group_bitmap);\n\tint (*smart_config_stop)(struct wl1271 *wl);\n\tint (*smart_config_set_group_key)(struct wl1271 *wl, u16 group_id,\n\t\t\t\t\t  u8 key_len, u8 *key);\n\tint (*set_cac)(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t       bool start);\n\tint (*dfs_master_restart)(struct wl1271 *wl, struct wl12xx_vif *wlvif);\n};\n\nenum wlcore_partitions {\n\tPART_DOWN,\n\tPART_WORK,\n\tPART_BOOT,\n\tPART_DRPW,\n\tPART_TOP_PRCM_ELP_SOC,\n\tPART_PHY_INIT,\n\n\tPART_TABLE_LEN,\n};\n\nstruct wlcore_partition {\n\tu32 size;\n\tu32 start;\n};\n\nstruct wlcore_partition_set {\n\tstruct wlcore_partition mem;\n\tstruct wlcore_partition reg;\n\tstruct wlcore_partition mem2;\n\tstruct wlcore_partition mem3;\n};\n\nenum wlcore_registers {\n\t \n\tREG_ECPU_CONTROL,\n\tREG_INTERRUPT_NO_CLEAR,\n\tREG_INTERRUPT_ACK,\n\tREG_COMMAND_MAILBOX_PTR,\n\tREG_EVENT_MAILBOX_PTR,\n\tREG_INTERRUPT_TRIG,\n\tREG_INTERRUPT_MASK,\n\tREG_PC_ON_RECOVERY,\n\tREG_CHIP_ID_B,\n\tREG_CMD_MBOX_ADDRESS,\n\n\t \n\tREG_SLV_MEM_DATA,\n\tREG_SLV_REG_DATA,\n\n\t \n\tREG_RAW_FW_STATUS_ADDR,\n\n\tREG_TABLE_LEN,\n};\n\nstruct wl1271_stats {\n\tvoid *fw_stats;\n\tunsigned long fw_stats_update;\n\tsize_t fw_stats_len;\n\n\tunsigned int retry_count;\n\tunsigned int excessive_retries;\n};\n\nstruct wl1271 {\n\tbool initialized;\n\tstruct ieee80211_hw *hw;\n\tbool mac80211_registered;\n\n\tstruct device *dev;\n\tstruct platform_device *pdev;\n\n\tvoid *if_priv;\n\n\tstruct wl1271_if_operations *if_ops;\n\n\tint irq;\n\tint wakeirq;\n\n\tint irq_flags;\n\tint wakeirq_flags;\n\n\tspinlock_t wl_lock;\n\n\tenum wlcore_state state;\n\tenum wl12xx_fw_type fw_type;\n\tbool plt;\n\tenum plt_mode plt_mode;\n\tu8 fem_manuf;\n\tu8 last_vif_count;\n\tstruct mutex mutex;\n\n\tunsigned long flags;\n\n\tstruct wlcore_partition_set curr_part;\n\n\tstruct wl1271_chip chip;\n\n\tint cmd_box_addr;\n\n\tu8 *fw;\n\tsize_t fw_len;\n\tvoid *nvs;\n\tsize_t nvs_len;\n\n\ts8 hw_pg_ver;\n\n\t \n\tu32 fuse_oui_addr;\n\tu32 fuse_nic_addr;\n\n\t \n\tstruct mac_address addresses[WLCORE_NUM_MAC_ADDRESSES];\n\tint channel;\n\tu8 system_hlid;\n\n\tunsigned long links_map[BITS_TO_LONGS(WLCORE_MAX_LINKS)];\n\tunsigned long roles_map[BITS_TO_LONGS(WL12XX_MAX_ROLES)];\n\tunsigned long roc_map[BITS_TO_LONGS(WL12XX_MAX_ROLES)];\n\tunsigned long rate_policies_map[\n\t\t\tBITS_TO_LONGS(WL12XX_MAX_RATE_POLICIES)];\n\tunsigned long klv_templates_map[\n\t\t\tBITS_TO_LONGS(WLCORE_MAX_KLV_TEMPLATES)];\n\n\tu8 session_ids[WLCORE_MAX_LINKS];\n\n\tstruct list_head wlvif_list;\n\n\tu8 sta_count;\n\tu8 ap_count;\n\n\tstruct wl1271_acx_mem_map *target_mem_map;\n\n\t \n\tu32 tx_blocks_freed;\n\tu32 tx_blocks_available;\n\tu32 tx_allocated_blocks;\n\tu32 tx_results_count;\n\n\t \n\tu32 tx_pkts_freed[NUM_TX_QUEUES];\n\tu32 tx_allocated_pkts[NUM_TX_QUEUES];\n\n\t \n\tu32 tx_packets_count;\n\n\t \n\ts64 time_offset;\n\n\t \n\tint tx_queue_count[NUM_TX_QUEUES];\n\tunsigned long queue_stop_reasons[\n\t\t\t\tNUM_TX_QUEUES * WLCORE_NUM_MAC_ADDRESSES];\n\n\t \n\tstruct sk_buff_head deferred_rx_queue;\n\n\t \n\tstruct sk_buff_head deferred_tx_queue;\n\n\tstruct work_struct tx_work;\n\tstruct workqueue_struct *freezable_wq;\n\n\t \n\tunsigned long tx_frames_map[BITS_TO_LONGS(WLCORE_MAX_TX_DESCRIPTORS)];\n\tstruct sk_buff *tx_frames[WLCORE_MAX_TX_DESCRIPTORS];\n\tint tx_frames_cnt;\n\n\t \n\tu32 rx_counter;\n\n\t \n\tu8 *aggr_buf;\n\tu32 aggr_buf_size;\n\n\t \n\tstruct sk_buff *dummy_packet;\n\n\t \n\tstruct work_struct netstack_work;\n\n\t \n\tu8 *fwlog;\n\n\t \n\tssize_t fwlog_size;\n\n\t \n\tu32 fwlog_end;\n\n\t \n\tu32 fw_mem_block_size;\n\n\t \n\tstruct work_struct recovery_work;\n\tbool watchdog_recovery;\n\n\t \n\tDECLARE_BITMAP(reg_ch_conf_last, 64);\n\t \n\tDECLARE_BITMAP(reg_ch_conf_pending, 64);\n\n\t \n\tvoid *mbox;\n\n\t \n\tu32 event_mask;\n\t \n\tu32 ap_event_mask;\n\n\t \n\tu32 mbox_size;\n\tu32 mbox_ptr[2];\n\n\t \n\tstruct wl12xx_vif *scan_wlvif;\n\tstruct wl1271_scan scan;\n\tstruct delayed_work scan_complete_work;\n\n\tstruct ieee80211_vif *roc_vif;\n\tstruct delayed_work roc_complete_work;\n\n\tstruct wl12xx_vif *sched_vif;\n\n\t \n\tenum nl80211_band band;\n\n\tstruct completion *elp_compl;\n\n\t \n\tint power_level;\n\n\tstruct wl1271_stats stats;\n\n\t__le32 *buffer_32;\n\tu32 buffer_cmd;\n\tu32 buffer_busyword[WL1271_BUSY_WORD_CNT];\n\n\tvoid *raw_fw_status;\n\tstruct wl_fw_status *fw_status;\n\tstruct wl1271_tx_hw_res_if *tx_res_if;\n\n\t \n\tstruct wlcore_conf conf;\n\n\tbool sg_enabled;\n\n\tbool enable_11a;\n\n\tint recovery_count;\n\n\t \n\ts8 noise;\n\n\t \n\tstruct ieee80211_supported_band bands[WLCORE_NUM_BANDS];\n\n\t \n\tbool wow_enabled;\n\tbool irq_wake_enabled;\n\n\t \n\tstruct wl1271_link links[WLCORE_MAX_LINKS];\n\n\t \n\tint active_link_count;\n\n\t \n\tunsigned long fw_fast_lnk_map;\n\n\t \n\tunsigned long ap_fw_ps_map;\n\n\t \n\tunsigned long ap_ps_map;\n\n\t \n\tunsigned int quirks;\n\n\t \n\tint ba_rx_session_count;\n\n\t \n\tint ba_rx_session_count_max;\n\n\t \n\tint active_sta_count;\n\n\t \n\tbool ofdm_only_ap;\n\n\t \n\tstruct wl12xx_vif *last_wlvif;\n\n\t \n\tstruct delayed_work tx_watchdog_work;\n\n\tstruct wlcore_ops *ops;\n\t \n\tconst struct wlcore_partition_set *ptable;\n\t \n\tconst int *rtable;\n\t \n\tconst char *plt_fw_name;\n\tconst char *sr_fw_name;\n\tconst char *mr_fw_name;\n\n\tu8 scan_templ_id_2_4;\n\tu8 scan_templ_id_5;\n\tu8 sched_scan_templ_id_2_4;\n\tu8 sched_scan_templ_id_5;\n\tu8 max_channels_5;\n\n\t \n\tvoid *priv;\n\n\t \n\tu32 num_tx_desc;\n\t \n\tu32 num_rx_desc;\n\t \n\tu8 num_links;\n\t \n\tu8 max_ap_stations;\n\n\t \n\tconst u8 **band_rate_to_idx;\n\n\t \n\tu8 hw_tx_rate_tbl_size;\n\n\t \n\tu8 hw_min_ht_rate;\n\n\t \n\tstruct ieee80211_sta_ht_cap ht_cap[WLCORE_NUM_BANDS];\n\n\t \n\tenum nl80211_dfs_regions dfs_region;\n\tbool radar_debug_mode;\n\n\t \n\tsize_t fw_status_len;\n\tsize_t fw_status_priv_len;\n\n\t \n\tunsigned long rx_filter_enabled[BITS_TO_LONGS(WL1271_MAX_RX_FILTERS)];\n\n\t \n\tsize_t static_data_priv_len;\n\n\t \n\tenum nl80211_channel_type channel_type;\n\n\t \n\tstruct mutex flush_mutex;\n\n\t \n\tint sleep_auth;\n\n\t \n\tint num_mac_addr;\n\n\t \n\tunsigned int min_sr_fw_ver[NUM_FW_VER];\n\n\t \n\tunsigned int min_mr_fw_ver[NUM_FW_VER];\n\n\tstruct completion nvs_loading_complete;\n\n\t \n\tconst struct ieee80211_iface_combination *iface_combinations;\n\tu8 n_iface_combinations;\n\n\t \n\tu32 dynamic_fw_traces;\n\n\t \n\tu8 zone_master_mac_addr[ETH_ALEN];\n};\n\nint wlcore_probe(struct wl1271 *wl, struct platform_device *pdev);\nint wlcore_remove(struct platform_device *pdev);\nstruct ieee80211_hw *wlcore_alloc_hw(size_t priv_size, u32 aggr_buf_size,\n\t\t\t\t     u32 mbox_size);\nint wlcore_free_hw(struct wl1271 *wl);\nint wlcore_set_key(struct wl1271 *wl, enum set_key_cmd cmd,\n\t\t   struct ieee80211_vif *vif,\n\t\t   struct ieee80211_sta *sta,\n\t\t   struct ieee80211_key_conf *key_conf);\nvoid wlcore_regdomain_config(struct wl1271 *wl);\nvoid wlcore_update_inconn_sta(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t      struct wl1271_station *wl_sta, bool in_conn);\n\nstatic inline void\nwlcore_set_ht_cap(struct wl1271 *wl, enum nl80211_band band,\n\t\t  struct ieee80211_sta_ht_cap *ht_cap)\n{\n\tmemcpy(&wl->ht_cap[band], ht_cap, sizeof(*ht_cap));\n}\n\n \n#define WLCORE_FW_VER_IGNORE\t-1\n\nstatic inline void\nwlcore_set_min_fw_ver(struct wl1271 *wl, unsigned int chip,\n\t\t      unsigned int iftype_sr, unsigned int major_sr,\n\t\t      unsigned int subtype_sr, unsigned int minor_sr,\n\t\t      unsigned int iftype_mr, unsigned int major_mr,\n\t\t      unsigned int subtype_mr, unsigned int minor_mr)\n{\n\twl->min_sr_fw_ver[FW_VER_CHIP] = chip;\n\twl->min_sr_fw_ver[FW_VER_IF_TYPE] = iftype_sr;\n\twl->min_sr_fw_ver[FW_VER_MAJOR] = major_sr;\n\twl->min_sr_fw_ver[FW_VER_SUBTYPE] = subtype_sr;\n\twl->min_sr_fw_ver[FW_VER_MINOR] = minor_sr;\n\n\twl->min_mr_fw_ver[FW_VER_CHIP] = chip;\n\twl->min_mr_fw_ver[FW_VER_IF_TYPE] = iftype_mr;\n\twl->min_mr_fw_ver[FW_VER_MAJOR] = major_mr;\n\twl->min_mr_fw_ver[FW_VER_SUBTYPE] = subtype_mr;\n\twl->min_mr_fw_ver[FW_VER_MINOR] = minor_mr;\n}\n\n \n#define CHUNK_SIZE\t16384\n\n \n\n \n#define WLCORE_QUIRK_END_OF_TRANSACTION\t\tBIT(0)\n\n \n#define WLCORE_QUIRK_TX_BLOCKSIZE_ALIGN\t\tBIT(2)\n\n \n#define WLCORE_QUIRK_RX_BLOCKSIZE_ALIGN\t\tBIT(3)\n\n \n#define WLCORE_QUIRK_FWLOG_NOT_IMPLEMENTED\tBIT(4)\n\n \n#define WLCORE_QUIRK_LEGACY_NVS\t\t\tBIT(5)\n\n \n#define WLCORE_QUIRK_TX_PAD_LAST_FRAME\t\tBIT(7)\n\n \n#define WLCORE_QUIRK_TKIP_HEADER_SPACE\t\tBIT(8)\n\n \n#define WLCORE_QUIRK_NO_SCHED_SCAN_WHILE_CONN\tBIT(9)\n\n \n#define WLCORE_QUIRK_DUAL_PROBE_TMPL\t\tBIT(10)\n\n \n#define WLCORE_QUIRK_REGDOMAIN_CONF\t\tBIT(11)\n\n \n#define WLCORE_QUIRK_AP_ZERO_SESSION_ID\t\tBIT(12)\n\n \n#define HW_ACCESS_ELP_CTRL_REG\t\t0x1FFFC\n\n \n#define ELPCTRL_WAKE_UP             0x1\n#define ELPCTRL_WAKE_UP_WLAN_READY  0x5\n#define ELPCTRL_SLEEP               0x0\n \n#define ELPCTRL_WLAN_READY          0x2\n\n \n\n \n\n \n#define INTR_TRIG_TX_PROC0 BIT(2)\n\n \n#define INTR_TRIG_RX_PROC0 BIT(3)\n\n#define INTR_TRIG_DEBUG_ACK BIT(4)\n\n#define INTR_TRIG_STATE_CHANGED BIT(5)\n\n \n\n \n#define INTR_TRIG_RX_PROC1 BIT(17)\n\n \n#define INTR_TRIG_TX_PROC1 BIT(18)\n\n#define ACX_SLV_SOFT_RESET_BIT\tBIT(1)\n#define SOFT_RESET_MAX_TIME\t1000000\n#define SOFT_RESET_STALL_TIME\t1000\n\n#define ECPU_CONTROL_HALT\t0x00000101\n\n#define WELP_ARM_COMMAND_VAL\t0x4\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}