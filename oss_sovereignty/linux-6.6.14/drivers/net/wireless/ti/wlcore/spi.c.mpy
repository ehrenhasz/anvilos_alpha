{
  "module_name": "spi.c",
  "hash_id": "d638957dc0f1fa21fdf778eb925b0cdf83fe2c228060103767ee0685af2f4ecb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wlcore/spi.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/swab.h>\n#include <linux/crc7.h>\n#include <linux/spi/spi.h>\n#include <linux/platform_device.h>\n#include <linux/of_irq.h>\n#include <linux/regulator/consumer.h>\n\n#include \"wlcore.h\"\n#include \"wl12xx_80211.h\"\n#include \"io.h\"\n\n#define WSPI_CMD_READ                 0x40000000\n#define WSPI_CMD_WRITE                0x00000000\n#define WSPI_CMD_FIXED                0x20000000\n#define WSPI_CMD_BYTE_LENGTH          0x1FFE0000\n#define WSPI_CMD_BYTE_LENGTH_OFFSET   17\n#define WSPI_CMD_BYTE_ADDR            0x0001FFFF\n\n#define WSPI_INIT_CMD_CRC_LEN       5\n\n#define WSPI_INIT_CMD_START         0x00\n#define WSPI_INIT_CMD_TX            0x40\n \n#define WSPI_INIT_CMD_BYPASS_BIT    0x80\n#define WSPI_INIT_CMD_FIXEDBUSY_LEN 0x07\n#define WSPI_INIT_CMD_EN_FIXEDBUSY  0x80\n#define WSPI_INIT_CMD_DIS_FIXEDBUSY 0x00\n#define WSPI_INIT_CMD_IOD           0x40\n#define WSPI_INIT_CMD_IP            0x20\n#define WSPI_INIT_CMD_CS            0x10\n#define WSPI_INIT_CMD_WS            0x08\n#define WSPI_INIT_CMD_WSPI          0x01\n#define WSPI_INIT_CMD_END           0x01\n\n#define WSPI_INIT_CMD_LEN           8\n\n#define HW_ACCESS_WSPI_FIXED_BUSY_LEN \\\n\t\t((WL1271_BUSY_WORD_LEN - 4) / sizeof(u32))\n#define HW_ACCESS_WSPI_INIT_CMD_MASK  0\n\n \n#define WSPI_MAX_CHUNK_SIZE    4092\n\n \n#define SPI_AGGR_BUFFER_SIZE (13 * SZ_4K)\n\n \n#define WSPI_MAX_NUM_OF_CHUNKS \\\n\t((SPI_AGGR_BUFFER_SIZE / WSPI_MAX_CHUNK_SIZE) + 1)\n\nstatic const struct wilink_family_data wl127x_data = {\n\t.name = \"wl127x\",\n\t.nvs_name = \"ti-connectivity/wl127x-nvs.bin\",\n};\n\nstatic const struct wilink_family_data wl128x_data = {\n\t.name = \"wl128x\",\n\t.nvs_name = \"ti-connectivity/wl128x-nvs.bin\",\n};\n\nstatic const struct wilink_family_data wl18xx_data = {\n\t.name = \"wl18xx\",\n\t.cfg_name = \"ti-connectivity/wl18xx-conf.bin\",\n\t.nvs_name = \"ti-connectivity/wl1271-nvs.bin\",\n};\n\nstruct wl12xx_spi_glue {\n\tstruct device *dev;\n\tstruct platform_device *core;\n\tstruct regulator *reg;  \n};\n\nstatic void wl12xx_spi_reset(struct device *child)\n{\n\tstruct wl12xx_spi_glue *glue = dev_get_drvdata(child->parent);\n\tu8 *cmd;\n\tstruct spi_transfer t;\n\tstruct spi_message m;\n\n\tcmd = kzalloc(WSPI_INIT_CMD_LEN, GFP_KERNEL);\n\tif (!cmd) {\n\t\tdev_err(child->parent,\n\t\t\t\"could not allocate cmd for spi reset\\n\");\n\t\treturn;\n\t}\n\n\tmemset(&t, 0, sizeof(t));\n\tspi_message_init(&m);\n\n\tmemset(cmd, 0xff, WSPI_INIT_CMD_LEN);\n\n\tt.tx_buf = cmd;\n\tt.len = WSPI_INIT_CMD_LEN;\n\tspi_message_add_tail(&t, &m);\n\n\tspi_sync(to_spi_device(glue->dev), &m);\n\n\tkfree(cmd);\n}\n\nstatic void wl12xx_spi_init(struct device *child)\n{\n\tstruct wl12xx_spi_glue *glue = dev_get_drvdata(child->parent);\n\tstruct spi_transfer t;\n\tstruct spi_message m;\n\tstruct spi_device *spi = to_spi_device(glue->dev);\n\tu8 *cmd = kzalloc(WSPI_INIT_CMD_LEN, GFP_KERNEL);\n\n\tif (!cmd) {\n\t\tdev_err(child->parent,\n\t\t\t\"could not allocate cmd for spi init\\n\");\n\t\treturn;\n\t}\n\n\tmemset(&t, 0, sizeof(t));\n\tspi_message_init(&m);\n\n\t \n\tcmd[0] = 0xff;\n\tcmd[1] = 0xff;\n\tcmd[2] = WSPI_INIT_CMD_START | WSPI_INIT_CMD_TX;\n\tcmd[3] = 0;\n\tcmd[4] = 0;\n\tcmd[5] = HW_ACCESS_WSPI_INIT_CMD_MASK << 3;\n\tcmd[5] |= HW_ACCESS_WSPI_FIXED_BUSY_LEN & WSPI_INIT_CMD_FIXEDBUSY_LEN;\n\n\tcmd[6] = WSPI_INIT_CMD_IOD | WSPI_INIT_CMD_IP | WSPI_INIT_CMD_CS\n\t\t| WSPI_INIT_CMD_WSPI | WSPI_INIT_CMD_WS;\n\n\tif (HW_ACCESS_WSPI_FIXED_BUSY_LEN == 0)\n\t\tcmd[6] |= WSPI_INIT_CMD_DIS_FIXEDBUSY;\n\telse\n\t\tcmd[6] |= WSPI_INIT_CMD_EN_FIXEDBUSY;\n\n\tcmd[7] = crc7_be(0, cmd+2, WSPI_INIT_CMD_CRC_LEN) | WSPI_INIT_CMD_END;\n\n\t \n\t__swab32s((u32 *)cmd);\n\t__swab32s((u32 *)cmd+1);\n\n\tt.tx_buf = cmd;\n\tt.len = WSPI_INIT_CMD_LEN;\n\tspi_message_add_tail(&t, &m);\n\n\tspi_sync(to_spi_device(glue->dev), &m);\n\n\t \n\tspi->mode ^= SPI_CS_HIGH;\n\tmemset(&m, 0, sizeof(m));\n\tspi_message_init(&m);\n\n\tcmd[0] = 0xff;\n\tcmd[1] = 0xff;\n\tcmd[2] = 0xff;\n\tcmd[3] = 0xff;\n\t__swab32s((u32 *)cmd);\n\n\tt.tx_buf = cmd;\n\tt.len = 4;\n\tspi_message_add_tail(&t, &m);\n\n\tspi_sync(to_spi_device(glue->dev), &m);\n\n\t \n\tspi->mode ^= SPI_CS_HIGH;\n\tkfree(cmd);\n}\n\n#define WL1271_BUSY_WORD_TIMEOUT 1000\n\nstatic int wl12xx_spi_read_busy(struct device *child)\n{\n\tstruct wl12xx_spi_glue *glue = dev_get_drvdata(child->parent);\n\tstruct wl1271 *wl = dev_get_drvdata(child);\n\tstruct spi_transfer t[1];\n\tstruct spi_message m;\n\tu32 *busy_buf;\n\tint num_busy_bytes = 0;\n\n\t \n\n\tnum_busy_bytes = WL1271_BUSY_WORD_TIMEOUT;\n\tbusy_buf = wl->buffer_busyword;\n\twhile (num_busy_bytes) {\n\t\tnum_busy_bytes--;\n\t\tspi_message_init(&m);\n\t\tmemset(t, 0, sizeof(t));\n\t\tt[0].rx_buf = busy_buf;\n\t\tt[0].len = sizeof(u32);\n\t\tt[0].cs_change = true;\n\t\tspi_message_add_tail(&t[0], &m);\n\t\tspi_sync(to_spi_device(glue->dev), &m);\n\n\t\tif (*busy_buf & 0x1)\n\t\t\treturn 0;\n\t}\n\n\t \n\tdev_err(child->parent, \"SPI read busy-word timeout!\\n\");\n\treturn -ETIMEDOUT;\n}\n\nstatic int __must_check wl12xx_spi_raw_read(struct device *child, int addr,\n\t\t\t\t\t    void *buf, size_t len, bool fixed)\n{\n\tstruct wl12xx_spi_glue *glue = dev_get_drvdata(child->parent);\n\tstruct wl1271 *wl = dev_get_drvdata(child);\n\tstruct spi_transfer t[2];\n\tstruct spi_message m;\n\tu32 *busy_buf;\n\tu32 *cmd;\n\tu32 chunk_len;\n\n\twhile (len > 0) {\n\t\tchunk_len = min_t(size_t, WSPI_MAX_CHUNK_SIZE, len);\n\n\t\tcmd = &wl->buffer_cmd;\n\t\tbusy_buf = wl->buffer_busyword;\n\n\t\t*cmd = 0;\n\t\t*cmd |= WSPI_CMD_READ;\n\t\t*cmd |= (chunk_len << WSPI_CMD_BYTE_LENGTH_OFFSET) &\n\t\t\tWSPI_CMD_BYTE_LENGTH;\n\t\t*cmd |= addr & WSPI_CMD_BYTE_ADDR;\n\n\t\tif (fixed)\n\t\t\t*cmd |= WSPI_CMD_FIXED;\n\n\t\tspi_message_init(&m);\n\t\tmemset(t, 0, sizeof(t));\n\n\t\tt[0].tx_buf = cmd;\n\t\tt[0].len = 4;\n\t\tt[0].cs_change = true;\n\t\tspi_message_add_tail(&t[0], &m);\n\n\t\t \n\t\tt[1].rx_buf = busy_buf;\n\t\tt[1].len = WL1271_BUSY_WORD_LEN;\n\t\tt[1].cs_change = true;\n\t\tspi_message_add_tail(&t[1], &m);\n\n\t\tspi_sync(to_spi_device(glue->dev), &m);\n\n\t\tif (!(busy_buf[WL1271_BUSY_WORD_CNT - 1] & 0x1) &&\n\t\t    wl12xx_spi_read_busy(child)) {\n\t\t\tmemset(buf, 0, chunk_len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tspi_message_init(&m);\n\t\tmemset(t, 0, sizeof(t));\n\n\t\tt[0].rx_buf = buf;\n\t\tt[0].len = chunk_len;\n\t\tt[0].cs_change = true;\n\t\tspi_message_add_tail(&t[0], &m);\n\n\t\tspi_sync(to_spi_device(glue->dev), &m);\n\n\t\tif (!fixed)\n\t\t\taddr += chunk_len;\n\t\tbuf += chunk_len;\n\t\tlen -= chunk_len;\n\t}\n\n\treturn 0;\n}\n\nstatic int __wl12xx_spi_raw_write(struct device *child, int addr,\n\t\t\t\t  void *buf, size_t len, bool fixed)\n{\n\tstruct wl12xx_spi_glue *glue = dev_get_drvdata(child->parent);\n\tstruct spi_transfer *t;\n\tstruct spi_message m;\n\tu32 commands[WSPI_MAX_NUM_OF_CHUNKS];  \n\tu32 *cmd;\n\tu32 chunk_len;\n\tint i;\n\n\t \n\tt = kzalloc(sizeof(*t) * 2 * WSPI_MAX_NUM_OF_CHUNKS, GFP_KERNEL);\n\tif (!t)\n\t\treturn -ENOMEM;\n\n\tWARN_ON(len > SPI_AGGR_BUFFER_SIZE);\n\n\tspi_message_init(&m);\n\n\tcmd = &commands[0];\n\ti = 0;\n\twhile (len > 0) {\n\t\tchunk_len = min_t(size_t, WSPI_MAX_CHUNK_SIZE, len);\n\n\t\t*cmd = 0;\n\t\t*cmd |= WSPI_CMD_WRITE;\n\t\t*cmd |= (chunk_len << WSPI_CMD_BYTE_LENGTH_OFFSET) &\n\t\t\tWSPI_CMD_BYTE_LENGTH;\n\t\t*cmd |= addr & WSPI_CMD_BYTE_ADDR;\n\n\t\tif (fixed)\n\t\t\t*cmd |= WSPI_CMD_FIXED;\n\n\t\tt[i].tx_buf = cmd;\n\t\tt[i].len = sizeof(*cmd);\n\t\tspi_message_add_tail(&t[i++], &m);\n\n\t\tt[i].tx_buf = buf;\n\t\tt[i].len = chunk_len;\n\t\tspi_message_add_tail(&t[i++], &m);\n\n\t\tif (!fixed)\n\t\t\taddr += chunk_len;\n\t\tbuf += chunk_len;\n\t\tlen -= chunk_len;\n\t\tcmd++;\n\t}\n\n\tspi_sync(to_spi_device(glue->dev), &m);\n\n\tkfree(t);\n\treturn 0;\n}\n\nstatic int __must_check wl12xx_spi_raw_write(struct device *child, int addr,\n\t\t\t\t\t     void *buf, size_t len, bool fixed)\n{\n\t \n\tif (addr == HW_ACCESS_ELP_CTRL_REG)\n\t\t__wl12xx_spi_raw_write(child, addr, buf, len, fixed);\n\n\treturn __wl12xx_spi_raw_write(child, addr, buf, len, fixed);\n}\n\n \nstatic int wl12xx_spi_set_power(struct device *child, bool enable)\n{\n\tint ret = 0;\n\tstruct wl12xx_spi_glue *glue = dev_get_drvdata(child->parent);\n\n\tWARN_ON(!glue->reg);\n\n\t \n\tif (enable) {\n\t\tret = regulator_enable(glue->reg);\n\t\tif (ret)\n\t\t\tdev_err(child, \"Power enable failure\\n\");\n\t} else {\n\t\tret =  regulator_disable(glue->reg);\n\t\tif (ret)\n\t\t\tdev_err(child, \"Power disable failure\\n\");\n\t}\n\n\treturn ret;\n}\n\n \nstatic void wl12xx_spi_set_block_size(struct device *child,\n\t\t\t\t      unsigned int blksz)\n{\n}\n\nstatic struct wl1271_if_operations spi_ops = {\n\t.read\t\t= wl12xx_spi_raw_read,\n\t.write\t\t= wl12xx_spi_raw_write,\n\t.reset\t\t= wl12xx_spi_reset,\n\t.init\t\t= wl12xx_spi_init,\n\t.power\t\t= wl12xx_spi_set_power,\n\t.set_block_size = wl12xx_spi_set_block_size,\n};\n\nstatic const struct of_device_id wlcore_spi_of_match_table[] = {\n\t{ .compatible = \"ti,wl1271\", .data = &wl127x_data},\n\t{ .compatible = \"ti,wl1273\", .data = &wl127x_data},\n\t{ .compatible = \"ti,wl1281\", .data = &wl128x_data},\n\t{ .compatible = \"ti,wl1283\", .data = &wl128x_data},\n\t{ .compatible = \"ti,wl1285\", .data = &wl128x_data},\n\t{ .compatible = \"ti,wl1801\", .data = &wl18xx_data},\n\t{ .compatible = \"ti,wl1805\", .data = &wl18xx_data},\n\t{ .compatible = \"ti,wl1807\", .data = &wl18xx_data},\n\t{ .compatible = \"ti,wl1831\", .data = &wl18xx_data},\n\t{ .compatible = \"ti,wl1835\", .data = &wl18xx_data},\n\t{ .compatible = \"ti,wl1837\", .data = &wl18xx_data},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, wlcore_spi_of_match_table);\n\n \nstatic int wlcore_probe_of(struct spi_device *spi, struct wl12xx_spi_glue *glue,\n\t\t\t   struct wlcore_platdev_data *pdev_data)\n{\n\tstruct device_node *dt_node = spi->dev.of_node;\n\tconst struct of_device_id *of_id;\n\n\tof_id = of_match_node(wlcore_spi_of_match_table, dt_node);\n\tif (!of_id)\n\t\treturn -ENODEV;\n\n\tpdev_data->family = of_id->data;\n\tdev_info(&spi->dev, \"selected chip family is %s\\n\",\n\t\t pdev_data->family->name);\n\n\tpdev_data->ref_clock_xtal = of_property_read_bool(dt_node, \"clock-xtal\");\n\n\t \n\tof_property_read_u32(dt_node, \"ref-clock-frequency\",\n\t\t\t     &pdev_data->ref_clock_freq);\n\tof_property_read_u32(dt_node, \"tcxo-clock-frequency\",\n\t\t\t     &pdev_data->tcxo_clock_freq);\n\n\treturn 0;\n}\n\nstatic int wl1271_probe(struct spi_device *spi)\n{\n\tstruct wl12xx_spi_glue *glue;\n\tstruct wlcore_platdev_data *pdev_data;\n\tstruct resource res[1];\n\tint ret;\n\n\tpdev_data = devm_kzalloc(&spi->dev, sizeof(*pdev_data), GFP_KERNEL);\n\tif (!pdev_data)\n\t\treturn -ENOMEM;\n\n\tpdev_data->if_ops = &spi_ops;\n\n\tglue = devm_kzalloc(&spi->dev, sizeof(*glue), GFP_KERNEL);\n\tif (!glue) {\n\t\tdev_err(&spi->dev, \"can't allocate glue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tglue->dev = &spi->dev;\n\n\tspi_set_drvdata(spi, glue);\n\n\t \n\tspi->bits_per_word = 32;\n\n\tglue->reg = devm_regulator_get(&spi->dev, \"vwlan\");\n\tif (IS_ERR(glue->reg))\n\t\treturn dev_err_probe(glue->dev, PTR_ERR(glue->reg),\n\t\t\t\t     \"can't get regulator\\n\");\n\n\tret = wlcore_probe_of(spi, glue, pdev_data);\n\tif (ret) {\n\t\tdev_err(glue->dev,\n\t\t\t\"can't get device tree parameters (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = spi_setup(spi);\n\tif (ret < 0) {\n\t\tdev_err(glue->dev, \"spi_setup failed\\n\");\n\t\treturn ret;\n\t}\n\n\tglue->core = platform_device_alloc(pdev_data->family->name,\n\t\t\t\t\t   PLATFORM_DEVID_AUTO);\n\tif (!glue->core) {\n\t\tdev_err(glue->dev, \"can't allocate platform_device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tglue->core->dev.parent = &spi->dev;\n\n\tmemset(res, 0x00, sizeof(res));\n\n\tres[0].start = spi->irq;\n\tres[0].flags = IORESOURCE_IRQ | irq_get_trigger_type(spi->irq);\n\tres[0].name = \"irq\";\n\n\tret = platform_device_add_resources(glue->core, res, ARRAY_SIZE(res));\n\tif (ret) {\n\t\tdev_err(glue->dev, \"can't add resources\\n\");\n\t\tgoto out_dev_put;\n\t}\n\n\tret = platform_device_add_data(glue->core, pdev_data,\n\t\t\t\t       sizeof(*pdev_data));\n\tif (ret) {\n\t\tdev_err(glue->dev, \"can't add platform data\\n\");\n\t\tgoto out_dev_put;\n\t}\n\n\tret = platform_device_add(glue->core);\n\tif (ret) {\n\t\tdev_err(glue->dev, \"can't register platform device\\n\");\n\t\tgoto out_dev_put;\n\t}\n\n\treturn 0;\n\nout_dev_put:\n\tplatform_device_put(glue->core);\n\treturn ret;\n}\n\nstatic void wl1271_remove(struct spi_device *spi)\n{\n\tstruct wl12xx_spi_glue *glue = spi_get_drvdata(spi);\n\n\tplatform_device_unregister(glue->core);\n}\n\nstatic struct spi_driver wl1271_spi_driver = {\n\t.driver = {\n\t\t.name\t\t= \"wl1271_spi\",\n\t\t.of_match_table = wlcore_spi_of_match_table,\n\t},\n\n\t.probe\t\t= wl1271_probe,\n\t.remove\t\t= wl1271_remove,\n};\n\nmodule_spi_driver(wl1271_spi_driver);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Luciano Coelho <coelho@ti.com>\");\nMODULE_AUTHOR(\"Juuso Oikarinen <juuso.oikarinen@nokia.com>\");\nMODULE_ALIAS(\"spi:wl1271\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}