{
  "module_name": "init.c",
  "hash_id": "2d52e8a69cb1da857cf94345f31ee4bb724acdc43676aa6dbc76f87e0cbfab7f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wlcore/init.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include \"debug.h\"\n#include \"init.h\"\n#include \"wl12xx_80211.h\"\n#include \"acx.h\"\n#include \"cmd.h\"\n#include \"tx.h\"\n#include \"io.h\"\n#include \"hw_ops.h\"\n\nint wl1271_init_templates_config(struct wl1271 *wl)\n{\n\tint ret, i;\n\tsize_t max_size;\n\n\t \n\tret = wl1271_cmd_template_set(wl, WL12XX_INVALID_ROLE_ID,\n\t\t\t\t      wl->scan_templ_id_2_4, NULL,\n\t\t\t\t      WL1271_CMD_TEMPL_MAX_SIZE,\n\t\t\t\t      0, WL1271_RATE_AUTOMATIC);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1271_cmd_template_set(wl, WL12XX_INVALID_ROLE_ID,\n\t\t\t\t      wl->scan_templ_id_5,\n\t\t\t\t      NULL, WL1271_CMD_TEMPL_MAX_SIZE, 0,\n\t\t\t\t      WL1271_RATE_AUTOMATIC);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (wl->quirks & WLCORE_QUIRK_DUAL_PROBE_TMPL) {\n\t\tret = wl1271_cmd_template_set(wl, WL12XX_INVALID_ROLE_ID,\n\t\t\t\t\t      wl->sched_scan_templ_id_2_4,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      WL1271_CMD_TEMPL_MAX_SIZE,\n\t\t\t\t\t      0, WL1271_RATE_AUTOMATIC);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = wl1271_cmd_template_set(wl, WL12XX_INVALID_ROLE_ID,\n\t\t\t\t\t      wl->sched_scan_templ_id_5,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      WL1271_CMD_TEMPL_MAX_SIZE,\n\t\t\t\t\t      0, WL1271_RATE_AUTOMATIC);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = wl1271_cmd_template_set(wl, WL12XX_INVALID_ROLE_ID,\n\t\t\t\t      CMD_TEMPL_NULL_DATA, NULL,\n\t\t\t\t      sizeof(struct wl12xx_null_data_template),\n\t\t\t\t      0, WL1271_RATE_AUTOMATIC);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1271_cmd_template_set(wl, WL12XX_INVALID_ROLE_ID,\n\t\t\t\t      CMD_TEMPL_PS_POLL, NULL,\n\t\t\t\t      sizeof(struct wl12xx_ps_poll_template),\n\t\t\t\t      0, WL1271_RATE_AUTOMATIC);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1271_cmd_template_set(wl, WL12XX_INVALID_ROLE_ID,\n\t\t\t\t      CMD_TEMPL_QOS_NULL_DATA, NULL,\n\t\t\t\t      sizeof\n\t\t\t\t      (struct ieee80211_qos_hdr),\n\t\t\t\t      0, WL1271_RATE_AUTOMATIC);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1271_cmd_template_set(wl, WL12XX_INVALID_ROLE_ID,\n\t\t\t\t      CMD_TEMPL_PROBE_RESPONSE, NULL,\n\t\t\t\t      WL1271_CMD_TEMPL_DFLT_SIZE,\n\t\t\t\t      0, WL1271_RATE_AUTOMATIC);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1271_cmd_template_set(wl, WL12XX_INVALID_ROLE_ID,\n\t\t\t\t      CMD_TEMPL_BEACON, NULL,\n\t\t\t\t      WL1271_CMD_TEMPL_DFLT_SIZE,\n\t\t\t\t      0, WL1271_RATE_AUTOMATIC);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmax_size = sizeof(struct wl12xx_arp_rsp_template) +\n\t\t   WL1271_EXTRA_SPACE_MAX;\n\tret = wl1271_cmd_template_set(wl, WL12XX_INVALID_ROLE_ID,\n\t\t\t\t      CMD_TEMPL_ARP_RSP, NULL,\n\t\t\t\t      max_size,\n\t\t\t\t      0, WL1271_RATE_AUTOMATIC);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wl1271_cmd_template_set(wl, WL12XX_INVALID_ROLE_ID,\n\t\t\t\t      CMD_TEMPL_AP_PROBE_RESPONSE, NULL,\n\t\t\t\t      WL1271_CMD_TEMPL_MAX_SIZE,\n\t\t\t\t      0, WL1271_RATE_AUTOMATIC);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1271_cmd_template_set(wl, WL12XX_INVALID_ROLE_ID,\n\t\t\t\t      CMD_TEMPL_AP_BEACON, NULL,\n\t\t\t\t      WL1271_CMD_TEMPL_MAX_SIZE,\n\t\t\t\t      0, WL1271_RATE_AUTOMATIC);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1271_cmd_template_set(wl, WL12XX_INVALID_ROLE_ID,\n\t\t\t\t      CMD_TEMPL_DEAUTH_AP, NULL,\n\t\t\t\t      sizeof\n\t\t\t\t      (struct wl12xx_disconn_template),\n\t\t\t\t      0, WL1271_RATE_AUTOMATIC);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < WLCORE_MAX_KLV_TEMPLATES; i++) {\n\t\tret = wl1271_cmd_template_set(wl, WL12XX_INVALID_ROLE_ID,\n\t\t\t\t\t      CMD_TEMPL_KLV, NULL,\n\t\t\t\t\t      sizeof(struct ieee80211_qos_hdr),\n\t\t\t\t\t      i, WL1271_RATE_AUTOMATIC);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int wl1271_ap_init_deauth_template(struct wl1271 *wl,\n\t\t\t\t\t  struct wl12xx_vif *wlvif)\n{\n\tstruct wl12xx_disconn_template *tmpl;\n\tint ret;\n\tu32 rate;\n\n\ttmpl = kzalloc(sizeof(*tmpl), GFP_KERNEL);\n\tif (!tmpl) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttmpl->header.frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t     IEEE80211_STYPE_DEAUTH);\n\n\trate = wl1271_tx_min_rate_get(wl, wlvif->basic_rate_set);\n\tret = wl1271_cmd_template_set(wl, wlvif->role_id,\n\t\t\t\t      CMD_TEMPL_DEAUTH_AP,\n\t\t\t\t      tmpl, sizeof(*tmpl), 0, rate);\n\nout:\n\tkfree(tmpl);\n\treturn ret;\n}\n\nstatic int wl1271_ap_init_null_template(struct wl1271 *wl,\n\t\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tstruct ieee80211_hdr_3addr *nullfunc;\n\tint ret;\n\tu32 rate;\n\n\tnullfunc = kzalloc(sizeof(*nullfunc), GFP_KERNEL);\n\tif (!nullfunc) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnullfunc->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |\n\t\t\t\t\t      IEEE80211_STYPE_NULLFUNC |\n\t\t\t\t\t      IEEE80211_FCTL_FROMDS);\n\n\t \n\n\tmemcpy(nullfunc->addr2, vif->addr, ETH_ALEN);\n\tmemcpy(nullfunc->addr3, vif->addr, ETH_ALEN);\n\n\trate = wl1271_tx_min_rate_get(wl, wlvif->basic_rate_set);\n\tret = wl1271_cmd_template_set(wl, wlvif->role_id,\n\t\t\t\t      CMD_TEMPL_NULL_DATA, nullfunc,\n\t\t\t\t      sizeof(*nullfunc), 0, rate);\n\nout:\n\tkfree(nullfunc);\n\treturn ret;\n}\n\nstatic int wl1271_ap_init_qos_null_template(struct wl1271 *wl,\n\t\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tstruct ieee80211_qos_hdr *qosnull;\n\tint ret;\n\tu32 rate;\n\n\tqosnull = kzalloc(sizeof(*qosnull), GFP_KERNEL);\n\tif (!qosnull) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tqosnull->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |\n\t\t\t\t\t     IEEE80211_STYPE_QOS_NULLFUNC |\n\t\t\t\t\t     IEEE80211_FCTL_FROMDS);\n\n\t \n\n\tmemcpy(qosnull->addr2, vif->addr, ETH_ALEN);\n\tmemcpy(qosnull->addr3, vif->addr, ETH_ALEN);\n\n\trate = wl1271_tx_min_rate_get(wl, wlvif->basic_rate_set);\n\tret = wl1271_cmd_template_set(wl, wlvif->role_id,\n\t\t\t\t      CMD_TEMPL_QOS_NULL_DATA, qosnull,\n\t\t\t\t      sizeof(*qosnull), 0, rate);\n\nout:\n\tkfree(qosnull);\n\treturn ret;\n}\n\nstatic int wl12xx_init_rx_config(struct wl1271 *wl)\n{\n\tint ret;\n\n\tret = wl1271_acx_rx_msdu_life_time(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int wl12xx_init_phy_vif_config(struct wl1271 *wl,\n\t\t\t\t\t    struct wl12xx_vif *wlvif)\n{\n\tint ret;\n\n\tret = wl1271_acx_slot(wl, wlvif, DEFAULT_SLOT_TIME);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1271_acx_service_period_timeout(wl, wlvif);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1271_acx_rts_threshold(wl, wlvif, wl->hw->wiphy->rts_threshold);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int wl1271_init_sta_beacon_filter(struct wl1271 *wl,\n\t\t\t\t\t struct wl12xx_vif *wlvif)\n{\n\tint ret;\n\n\tret = wl1271_acx_beacon_filter_table(wl, wlvif);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wl1271_acx_beacon_filter_opt(wl, wlvif, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint wl1271_init_pta(struct wl1271 *wl)\n{\n\tint ret;\n\n\tret = wl12xx_acx_sg_cfg(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1271_acx_sg_enable(wl, wl->sg_enabled);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint wl1271_init_energy_detection(struct wl1271 *wl)\n{\n\tint ret;\n\n\tret = wl1271_acx_cca_threshold(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int wl1271_init_beacon_broadcast(struct wl1271 *wl,\n\t\t\t\t\tstruct wl12xx_vif *wlvif)\n{\n\tint ret;\n\n\tret = wl1271_acx_bcn_dtim_options(wl, wlvif);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int wl12xx_init_fwlog(struct wl1271 *wl)\n{\n\tint ret;\n\n\tif (wl->quirks & WLCORE_QUIRK_FWLOG_NOT_IMPLEMENTED)\n\t\treturn 0;\n\n\tret = wl12xx_cmd_config_fwlog(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nint wl1271_sta_hw_init(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tint ret;\n\n\t \n\tret = wl12xx_acx_config_ps(wl, wlvif);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wl1271_acx_fm_coex(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1271_acx_sta_rate_policies(wl, wlvif);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int wl1271_sta_hw_init_post_mem(struct wl1271 *wl,\n\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tint ret;\n\n\t \n\tret = wl1271_acx_keep_alive_mode(wl, wlvif, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic int wl1271_ap_hw_init(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tint ret;\n\n\tret = wl1271_init_ap_rates(wl, wlvif);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wlcore_hw_ap_sleep(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint wl1271_ap_init_templates(struct wl1271 *wl, struct ieee80211_vif *vif)\n{\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tint ret;\n\n\tret = wl1271_ap_init_deauth_template(wl, wlvif);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1271_ap_init_null_template(wl, vif);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1271_ap_init_qos_null_template(wl, vif);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wl1271_acx_beacon_filter_opt(wl, wlvif, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int wl1271_ap_hw_init_post_mem(struct wl1271 *wl,\n\t\t\t\t      struct ieee80211_vif *vif)\n{\n\treturn wl1271_ap_init_templates(wl, vif);\n}\n\nint wl1271_init_ap_rates(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tint i, ret;\n\tstruct conf_tx_rate_class rc;\n\tu32 supported_rates;\n\n\twl1271_debug(DEBUG_AP, \"AP basic rate set: 0x%x\",\n\t\t     wlvif->basic_rate_set);\n\n\tif (wlvif->basic_rate_set == 0)\n\t\treturn -EINVAL;\n\n\trc.enabled_rates = wlvif->basic_rate_set;\n\trc.long_retry_limit = 10;\n\trc.short_retry_limit = 10;\n\trc.aflags = 0;\n\tret = wl1271_acx_ap_rate_policy(wl, &rc, wlvif->ap.mgmt_rate_idx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\trc.enabled_rates = wl1271_tx_min_rate_get(wl, wlvif->basic_rate_set);\n\trc.short_retry_limit = 10;\n\trc.long_retry_limit = 10;\n\trc.aflags = 0;\n\tret = wl1271_acx_ap_rate_policy(wl, &rc, wlvif->ap.bcast_rate_idx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (wl->ofdm_only_ap && (wlvif->basic_rate_set & CONF_TX_OFDM_RATES))\n\t\tsupported_rates = CONF_TX_OFDM_RATES;\n\telse\n\t\tsupported_rates = CONF_TX_ENABLED_RATES;\n\n\t \n\tsupported_rates |= CONF_TX_MCS_RATES;\n\n\t \n\tsupported_rates |= wlcore_hw_ap_get_mimo_wide_rate_mask(wl, wlvif);\n\n\t \n\tfor (i = 0; i < wl->conf.tx.ac_conf_count; i++) {\n\t\trc.enabled_rates = supported_rates;\n\t\trc.short_retry_limit = 10;\n\t\trc.long_retry_limit = 10;\n\t\trc.aflags = 0;\n\t\tret = wl1271_acx_ap_rate_policy(wl, &rc,\n\t\t\t\t\t\twlvif->ap.ucast_rate_idx[i]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int wl1271_set_ba_policies(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\t \n\twlvif->ba_allowed = true;\n\twl->ba_rx_session_count = 0;\n\n\t \n\tif (wlvif->bss_type != BSS_TYPE_AP_BSS &&\n\t    wlvif->bss_type != BSS_TYPE_STA_BSS) {\n\t\twlvif->ba_support = false;\n\t\treturn 0;\n\t}\n\n\twlvif->ba_support = true;\n\n\t \n\treturn wl12xx_acx_set_ba_initiator_policy(wl, wlvif);\n}\n\n \nstatic int wl12xx_init_sta_role(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tint ret;\n\n\tret = wl1271_acx_group_address_tbl(wl, wlvif, true, NULL, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wl1271_acx_conn_monit_params(wl, wlvif, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wl1271_init_sta_beacon_filter(wl, wlvif);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wl1271_init_beacon_broadcast(wl, wlvif);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wl1271_acx_rssi_snr_avg_weights(wl, wlvif);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic int wl12xx_init_ap_role(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tint ret;\n\n\tret = wl1271_acx_ap_max_tx_retry(wl, wlvif);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wl1271_acx_tx_power(wl, wlvif, wlvif->power_level);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (wl->radar_debug_mode)\n\t\twlcore_cmd_generic_cfg(wl, wlvif,\n\t\t\t\t       WLCORE_CFG_FEATURE_RADAR_DEBUG,\n\t\t\t\t       wl->radar_debug_mode, 0);\n\n\treturn 0;\n}\n\nint wl1271_init_vif_specific(struct wl1271 *wl, struct ieee80211_vif *vif)\n{\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tstruct conf_tx_ac_category *conf_ac;\n\tstruct conf_tx_tid *conf_tid;\n\tbool is_ap = (wlvif->bss_type == BSS_TYPE_AP_BSS);\n\tint ret, i;\n\n\t \n\n\tif (wl->ap_count == 0 && is_ap) {  \n\t\tret = wl1271_acx_sleep_auth(wl, WL1271_PSM_ELP);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\twl->event_mask |= wl->ap_event_mask;\n\t\tret = wl1271_event_unmask(wl);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t \n\t} else if (wl->sta_count == 0 && wl->ap_count == 0 && !is_ap) {\n\t\tu8 sta_auth = wl->conf.conn.sta_sleep_auth;\n\t\t \n\t\tif (sta_auth != WL1271_PSM_ILLEGAL)\n\t\t\tret = wl1271_acx_sleep_auth(wl, sta_auth);\n\t\t \n\t\telse\n\t\t\tret = wl1271_acx_sleep_auth(wl, WL1271_PSM_ELP);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (is_ap) {\n\t\tret = wl1271_ap_hw_init(wl, wlvif);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = wl12xx_init_ap_role(wl, wlvif);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tret = wl1271_sta_hw_init(wl, wlvif);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = wl12xx_init_sta_role(wl, wlvif);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\twl12xx_init_phy_vif_config(wl, wlvif);\n\n\t \n\tBUG_ON(wl->conf.tx.tid_conf_count != wl->conf.tx.ac_conf_count);\n\tfor (i = 0; i < wl->conf.tx.tid_conf_count; i++) {\n\t\tconf_ac = &wl->conf.tx.ac_conf[i];\n\t\tret = wl1271_acx_ac_cfg(wl, wlvif, conf_ac->ac,\n\t\t\t\t\tconf_ac->cw_min, conf_ac->cw_max,\n\t\t\t\t\tconf_ac->aifsn, conf_ac->tx_op_limit);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tconf_tid = &wl->conf.tx.tid_conf[i];\n\t\tret = wl1271_acx_tid_cfg(wl, wlvif,\n\t\t\t\t\t conf_tid->queue_id,\n\t\t\t\t\t conf_tid->channel_type,\n\t\t\t\t\t conf_tid->tsid,\n\t\t\t\t\t conf_tid->ps_scheme,\n\t\t\t\t\t conf_tid->ack_policy,\n\t\t\t\t\t conf_tid->apsd_conf[0],\n\t\t\t\t\t conf_tid->apsd_conf[1]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = wl1271_acx_feature_cfg(wl, wlvif);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (is_ap)\n\t\tret = wl1271_ap_hw_init_post_mem(wl, vif);\n\telse\n\t\tret = wl1271_sta_hw_init_post_mem(wl, vif);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wl1271_set_ba_policies(wl, wlvif);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wlcore_hw_init_vif(wl, wlvif);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint wl1271_hw_init(struct wl1271 *wl)\n{\n\tint ret;\n\n\t \n\tret = wl->ops->hw_init(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wl1271_init_templates_config(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl12xx_acx_mem_cfg(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wl12xx_init_fwlog(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wlcore_cmd_regdomain_config_locked(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wl1271_init_pta(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wl1271_acx_init_mem_config(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wl12xx_init_rx_config(wl);\n\tif (ret < 0)\n\t\tgoto out_free_memmap;\n\n\tret = wl1271_acx_dco_itrim_params(wl);\n\tif (ret < 0)\n\t\tgoto out_free_memmap;\n\n\t \n\tret = wl1271_acx_tx_config_options(wl);\n\tif (ret < 0)\n\t\tgoto out_free_memmap;\n\n\t \n\tret = wl1271_acx_init_rx_interrupt(wl);\n\tif (ret < 0)\n\t\tgoto out_free_memmap;\n\n\t \n\tret = wl1271_init_energy_detection(wl);\n\tif (ret < 0)\n\t\tgoto out_free_memmap;\n\n\t \n\tret = wl1271_acx_frag_threshold(wl, wl->hw->wiphy->frag_threshold);\n\tif (ret < 0)\n\t\tgoto out_free_memmap;\n\n\t \n\tret = wl1271_cmd_data_path(wl, 1);\n\tif (ret < 0)\n\t\tgoto out_free_memmap;\n\n\t \n\tret = wl1271_acx_pm_config(wl);\n\tif (ret < 0)\n\t\tgoto out_free_memmap;\n\n\tret = wl12xx_acx_set_rate_mgmt_params(wl);\n\tif (ret < 0)\n\t\tgoto out_free_memmap;\n\n\t \n\tret = wl12xx_acx_config_hangover(wl);\n\tif (ret < 0)\n\t\tgoto out_free_memmap;\n\n\treturn 0;\n\n out_free_memmap:\n\tkfree(wl->target_mem_map);\n\twl->target_mem_map = NULL;\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}