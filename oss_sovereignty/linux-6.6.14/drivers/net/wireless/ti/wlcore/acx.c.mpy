{
  "module_name": "acx.c",
  "hash_id": "0116fcbbde50ae4a149156cf97dfd1f022d843b153cdff7acae9e4dc9421e1cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wlcore/acx.c",
  "human_readable_source": "\n \n\n#include \"acx.h\"\n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n\n#include \"wlcore.h\"\n#include \"debug.h\"\n#include \"wl12xx_80211.h\"\n#include \"hw_ops.h\"\n\nint wl1271_acx_wake_up_conditions(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t\t  u8 wake_up_event, u8 listen_interval)\n{\n\tstruct acx_wake_up_condition *wake_up;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx wake up conditions (wake_up_event %d listen_interval %d)\",\n\t\t     wake_up_event, listen_interval);\n\n\twake_up = kzalloc(sizeof(*wake_up), GFP_KERNEL);\n\tif (!wake_up) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\twake_up->role_id = wlvif->role_id;\n\twake_up->wake_up_event = wake_up_event;\n\twake_up->listen_interval = listen_interval;\n\n\tret = wl1271_cmd_configure(wl, ACX_WAKE_UP_CONDITIONS,\n\t\t\t\t   wake_up, sizeof(*wake_up));\n\tif (ret < 0) {\n\t\twl1271_warning(\"could not set wake up conditions: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(wake_up);\n\treturn ret;\n}\n\nint wl1271_acx_sleep_auth(struct wl1271 *wl, u8 sleep_auth)\n{\n\tstruct acx_sleep_auth *auth;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx sleep auth %d\", sleep_auth);\n\n\tauth = kzalloc(sizeof(*auth), GFP_KERNEL);\n\tif (!auth) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tauth->sleep_auth = sleep_auth;\n\n\tret = wl1271_cmd_configure(wl, ACX_SLEEP_AUTH, auth, sizeof(*auth));\n\tif (ret < 0) {\n\t\twl1271_error(\"could not configure sleep_auth to %d: %d\",\n\t\t\t     sleep_auth, ret);\n\t\tgoto out;\n\t}\n\n\twl->sleep_auth = sleep_auth;\nout:\n\tkfree(auth);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wl1271_acx_sleep_auth);\n\nint wl1271_acx_tx_power(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\tint power)\n{\n\tstruct acx_current_tx_power *acx;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx dot11_cur_tx_pwr %d\", power);\n\n\tif (power < 0 || power > 25)\n\t\treturn -EINVAL;\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->role_id = wlvif->role_id;\n\tacx->current_tx_power = power * 10;\n\n\tret = wl1271_cmd_configure(wl, DOT11_CUR_TX_PWR, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"configure of tx power failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1271_acx_feature_cfg(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tstruct acx_feature_config *feature;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx feature cfg\");\n\n\tfeature = kzalloc(sizeof(*feature), GFP_KERNEL);\n\tif (!feature) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tfeature->role_id = wlvif->role_id;\n\tfeature->data_flow_options = 0;\n\tfeature->options = 0;\n\n\tret = wl1271_cmd_configure(wl, ACX_FEATURE_CFG,\n\t\t\t\t   feature, sizeof(*feature));\n\tif (ret < 0) {\n\t\twl1271_error(\"Couldn't set HW encryption\");\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(feature);\n\treturn ret;\n}\n\nint wl1271_acx_mem_map(struct wl1271 *wl, struct acx_header *mem_map,\n\t\t       size_t len)\n{\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx mem map\");\n\n\tret = wl1271_cmd_interrogate(wl, ACX_MEM_MAP, mem_map,\n\t\t\t\t     sizeof(struct acx_header), len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint wl1271_acx_rx_msdu_life_time(struct wl1271 *wl)\n{\n\tstruct acx_rx_msdu_lifetime *acx;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx rx msdu life time\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->lifetime = cpu_to_le32(wl->conf.rx.rx_msdu_life_time);\n\tret = wl1271_cmd_configure(wl, DOT11_RX_MSDU_LIFE_TIME,\n\t\t\t\t   acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"failed to set rx msdu life time: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1271_acx_slot(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t    enum acx_slot_type slot_time)\n{\n\tstruct acx_slot *slot;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx slot\");\n\n\tslot = kzalloc(sizeof(*slot), GFP_KERNEL);\n\tif (!slot) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tslot->role_id = wlvif->role_id;\n\tslot->wone_index = STATION_WONE_INDEX;\n\tslot->slot_time = slot_time;\n\n\tret = wl1271_cmd_configure(wl, ACX_SLOT, slot, sizeof(*slot));\n\tif (ret < 0) {\n\t\twl1271_warning(\"failed to set slot time: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(slot);\n\treturn ret;\n}\n\nint wl1271_acx_group_address_tbl(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t\t bool enable, void *mc_list, u32 mc_list_len)\n{\n\tstruct acx_dot11_grp_addr_tbl *acx;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx group address tbl\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tacx->role_id = wlvif->role_id;\n\tacx->enabled = enable;\n\tacx->num_groups = mc_list_len;\n\tmemcpy(acx->mac_table, mc_list, mc_list_len * ETH_ALEN);\n\n\tret = wl1271_cmd_configure(wl, DOT11_GROUP_ADDRESS_TBL,\n\t\t\t\t   acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"failed to set group addr table: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1271_acx_service_period_timeout(struct wl1271 *wl,\n\t\t\t\t      struct wl12xx_vif *wlvif)\n{\n\tstruct acx_rx_timeout *rx_timeout;\n\tint ret;\n\n\trx_timeout = kzalloc(sizeof(*rx_timeout), GFP_KERNEL);\n\tif (!rx_timeout) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\twl1271_debug(DEBUG_ACX, \"acx service period timeout\");\n\n\trx_timeout->role_id = wlvif->role_id;\n\trx_timeout->ps_poll_timeout = cpu_to_le16(wl->conf.rx.ps_poll_timeout);\n\trx_timeout->upsd_timeout = cpu_to_le16(wl->conf.rx.upsd_timeout);\n\n\tret = wl1271_cmd_configure(wl, ACX_SERVICE_PERIOD_TIMEOUT,\n\t\t\t\t   rx_timeout, sizeof(*rx_timeout));\n\tif (ret < 0) {\n\t\twl1271_warning(\"failed to set service period timeout: %d\",\n\t\t\t       ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(rx_timeout);\n\treturn ret;\n}\n\nint wl1271_acx_rts_threshold(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t     u32 rts_threshold)\n{\n\tstruct acx_rts_threshold *rts;\n\tint ret;\n\n\t \n\tif (rts_threshold > IEEE80211_MAX_RTS_THRESHOLD)\n\t\trts_threshold = wl->conf.rx.rts_threshold;\n\n\twl1271_debug(DEBUG_ACX, \"acx rts threshold: %d\", rts_threshold);\n\n\trts = kzalloc(sizeof(*rts), GFP_KERNEL);\n\tif (!rts) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trts->role_id = wlvif->role_id;\n\trts->threshold = cpu_to_le16((u16)rts_threshold);\n\n\tret = wl1271_cmd_configure(wl, DOT11_RTS_THRESHOLD, rts, sizeof(*rts));\n\tif (ret < 0) {\n\t\twl1271_warning(\"failed to set rts threshold: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(rts);\n\treturn ret;\n}\n\nint wl1271_acx_dco_itrim_params(struct wl1271 *wl)\n{\n\tstruct acx_dco_itrim_params *dco;\n\tstruct conf_itrim_settings *c = &wl->conf.itrim;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx dco itrim parameters\");\n\n\tdco = kzalloc(sizeof(*dco), GFP_KERNEL);\n\tif (!dco) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdco->enable = c->enable;\n\tdco->timeout = cpu_to_le32(c->timeout);\n\n\tret = wl1271_cmd_configure(wl, ACX_SET_DCO_ITRIM_PARAMS,\n\t\t\t\t   dco, sizeof(*dco));\n\tif (ret < 0) {\n\t\twl1271_warning(\"failed to set dco itrim parameters: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(dco);\n\treturn ret;\n}\n\nint wl1271_acx_beacon_filter_opt(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t\t bool enable_filter)\n{\n\tstruct acx_beacon_filter_option *beacon_filter = NULL;\n\tint ret = 0;\n\n\twl1271_debug(DEBUG_ACX, \"acx beacon filter opt enable=%d\",\n\t\t     enable_filter);\n\n\tif (enable_filter &&\n\t    wl->conf.conn.bcn_filt_mode == CONF_BCN_FILT_MODE_DISABLED)\n\t\tgoto out;\n\n\tbeacon_filter = kzalloc(sizeof(*beacon_filter), GFP_KERNEL);\n\tif (!beacon_filter) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tbeacon_filter->role_id = wlvif->role_id;\n\tbeacon_filter->enable = enable_filter;\n\n\t \n\tbeacon_filter->max_num_beacons = 0;\n\n\tret = wl1271_cmd_configure(wl, ACX_BEACON_FILTER_OPT,\n\t\t\t\t   beacon_filter, sizeof(*beacon_filter));\n\tif (ret < 0) {\n\t\twl1271_warning(\"failed to set beacon filter opt: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(beacon_filter);\n\treturn ret;\n}\n\nint wl1271_acx_beacon_filter_table(struct wl1271 *wl,\n\t\t\t\t   struct wl12xx_vif *wlvif)\n{\n\tstruct acx_beacon_filter_ie_table *ie_table;\n\tint i, idx = 0;\n\tint ret;\n\tbool vendor_spec = false;\n\n\twl1271_debug(DEBUG_ACX, \"acx beacon filter table\");\n\n\tie_table = kzalloc(sizeof(*ie_table), GFP_KERNEL);\n\tif (!ie_table) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tie_table->role_id = wlvif->role_id;\n\tie_table->num_ie = 0;\n\tfor (i = 0; i < wl->conf.conn.bcn_filt_ie_count; i++) {\n\t\tstruct conf_bcn_filt_rule *r = &(wl->conf.conn.bcn_filt_ie[i]);\n\t\tie_table->table[idx++] = r->ie;\n\t\tie_table->table[idx++] = r->rule;\n\n\t\tif (r->ie == WLAN_EID_VENDOR_SPECIFIC) {\n\t\t\t \n\t\t\tif (vendor_spec)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tmemcpy(&(ie_table->table[idx]), r->oui,\n\t\t\t       CONF_BCN_IE_OUI_LEN);\n\t\t\tidx += CONF_BCN_IE_OUI_LEN;\n\t\t\tie_table->table[idx++] = r->type;\n\t\t\tmemcpy(&(ie_table->table[idx]), r->version,\n\t\t\t       CONF_BCN_IE_VER_LEN);\n\t\t\tidx += CONF_BCN_IE_VER_LEN;\n\t\t\tvendor_spec = true;\n\t\t}\n\n\t\tie_table->num_ie++;\n\t}\n\n\tret = wl1271_cmd_configure(wl, ACX_BEACON_FILTER_TABLE,\n\t\t\t\t   ie_table, sizeof(*ie_table));\n\tif (ret < 0) {\n\t\twl1271_warning(\"failed to set beacon filter table: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(ie_table);\n\treturn ret;\n}\n\n#define ACX_CONN_MONIT_DISABLE_VALUE  0xffffffff\n\nint wl1271_acx_conn_monit_params(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t\t bool enable)\n{\n\tstruct acx_conn_monit_params *acx;\n\tu32 threshold = ACX_CONN_MONIT_DISABLE_VALUE;\n\tu32 timeout = ACX_CONN_MONIT_DISABLE_VALUE;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx connection monitor parameters: %s\",\n\t\t     enable ? \"enabled\" : \"disabled\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (enable) {\n\t\tthreshold = wl->conf.conn.synch_fail_thold;\n\t\ttimeout = wl->conf.conn.bss_lose_timeout;\n\t}\n\n\tacx->role_id = wlvif->role_id;\n\tacx->synch_fail_thold = cpu_to_le32(threshold);\n\tacx->bss_lose_timeout = cpu_to_le32(timeout);\n\n\tret = wl1271_cmd_configure(wl, ACX_CONN_MONIT_PARAMS,\n\t\t\t\t   acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"failed to set connection monitor \"\n\t\t\t       \"parameters: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\n\nint wl1271_acx_sg_enable(struct wl1271 *wl, bool enable)\n{\n\tstruct acx_bt_wlan_coex *pta;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx sg enable\");\n\n\tpta = kzalloc(sizeof(*pta), GFP_KERNEL);\n\tif (!pta) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (enable)\n\t\tpta->enable = wl->conf.sg.state;\n\telse\n\t\tpta->enable = CONF_SG_DISABLE;\n\n\tret = wl1271_cmd_configure(wl, ACX_SG_ENABLE, pta, sizeof(*pta));\n\tif (ret < 0) {\n\t\twl1271_warning(\"failed to set softgemini enable: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(pta);\n\treturn ret;\n}\n\nint wl12xx_acx_sg_cfg(struct wl1271 *wl)\n{\n\tstruct acx_bt_wlan_coex_param *param;\n\tstruct conf_sg_settings *c = &wl->conf.sg;\n\tint i, ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx sg cfg\");\n\n\tparam = kzalloc(sizeof(*param), GFP_KERNEL);\n\tif (!param) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < WLCORE_CONF_SG_PARAMS_MAX; i++)\n\t\tparam->params[i] = cpu_to_le32(c->params[i]);\n\tparam->param_idx = WLCORE_CONF_SG_PARAMS_ALL;\n\n\tret = wl1271_cmd_configure(wl, ACX_SG_CFG, param, sizeof(*param));\n\tif (ret < 0) {\n\t\twl1271_warning(\"failed to set sg config: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(param);\n\treturn ret;\n}\n\nint wl1271_acx_cca_threshold(struct wl1271 *wl)\n{\n\tstruct acx_energy_detection *detection;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx cca threshold\");\n\n\tdetection = kzalloc(sizeof(*detection), GFP_KERNEL);\n\tif (!detection) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdetection->rx_cca_threshold = cpu_to_le16(wl->conf.rx.rx_cca_threshold);\n\tdetection->tx_energy_detection = wl->conf.tx.tx_energy_detection;\n\n\tret = wl1271_cmd_configure(wl, ACX_CCA_THRESHOLD,\n\t\t\t\t   detection, sizeof(*detection));\n\tif (ret < 0)\n\t\twl1271_warning(\"failed to set cca threshold: %d\", ret);\n\nout:\n\tkfree(detection);\n\treturn ret;\n}\n\nint wl1271_acx_bcn_dtim_options(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tstruct acx_beacon_broadcast *bb;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx bcn dtim options\");\n\n\tbb = kzalloc(sizeof(*bb), GFP_KERNEL);\n\tif (!bb) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tbb->role_id = wlvif->role_id;\n\tbb->beacon_rx_timeout = cpu_to_le16(wl->conf.conn.beacon_rx_timeout);\n\tbb->broadcast_timeout = cpu_to_le16(wl->conf.conn.broadcast_timeout);\n\tbb->rx_broadcast_in_ps = wl->conf.conn.rx_broadcast_in_ps;\n\tbb->ps_poll_threshold = wl->conf.conn.ps_poll_threshold;\n\n\tret = wl1271_cmd_configure(wl, ACX_BCN_DTIM_OPTIONS, bb, sizeof(*bb));\n\tif (ret < 0) {\n\t\twl1271_warning(\"failed to set rx config: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(bb);\n\treturn ret;\n}\n\nint wl1271_acx_aid(struct wl1271 *wl, struct wl12xx_vif *wlvif, u16 aid)\n{\n\tstruct acx_aid *acx_aid;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx aid\");\n\n\tacx_aid = kzalloc(sizeof(*acx_aid), GFP_KERNEL);\n\tif (!acx_aid) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx_aid->role_id = wlvif->role_id;\n\tacx_aid->aid = cpu_to_le16(aid);\n\n\tret = wl1271_cmd_configure(wl, ACX_AID, acx_aid, sizeof(*acx_aid));\n\tif (ret < 0) {\n\t\twl1271_warning(\"failed to set aid: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx_aid);\n\treturn ret;\n}\n\nint wl1271_acx_event_mbox_mask(struct wl1271 *wl, u32 event_mask)\n{\n\tstruct acx_event_mask *mask;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx event mbox mask\");\n\n\tmask = kzalloc(sizeof(*mask), GFP_KERNEL);\n\tif (!mask) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tmask->high_event_mask = cpu_to_le32(0xffffffff);\n\tmask->event_mask = cpu_to_le32(event_mask);\n\n\tret = wl1271_cmd_configure(wl, ACX_EVENT_MBOX_MASK,\n\t\t\t\t   mask, sizeof(*mask));\n\tif (ret < 0) {\n\t\twl1271_warning(\"failed to set acx_event_mbox_mask: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(mask);\n\treturn ret;\n}\n\nint wl1271_acx_set_preamble(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t    enum acx_preamble_type preamble)\n{\n\tstruct acx_preamble *acx;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx_set_preamble\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->role_id = wlvif->role_id;\n\tacx->preamble = preamble;\n\n\tret = wl1271_cmd_configure(wl, ACX_PREAMBLE_TYPE, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"Setting of preamble failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1271_acx_cts_protect(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t   enum acx_ctsprotect_type ctsprotect)\n{\n\tstruct acx_ctsprotect *acx;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx_set_ctsprotect\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->role_id = wlvif->role_id;\n\tacx->ctsprotect = ctsprotect;\n\n\tret = wl1271_cmd_configure(wl, ACX_CTS_PROTECTION, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"Setting of ctsprotect failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1271_acx_statistics(struct wl1271 *wl, void *stats)\n{\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx statistics\");\n\n\tret = wl1271_cmd_interrogate(wl, ACX_STATISTICS, stats,\n\t\t\t\t     sizeof(struct acx_header),\n\t\t\t\t     wl->stats.fw_stats_len);\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx statistics failed: %d\", ret);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nint wl1271_acx_sta_rate_policies(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tstruct acx_rate_policy *acx;\n\tstruct conf_tx_rate_class *c = &wl->conf.tx.sta_rc_conf;\n\tint ret = 0;\n\n\twl1271_debug(DEBUG_ACX, \"acx rate policies\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\twl1271_debug(DEBUG_ACX, \"basic_rate: 0x%x, full_rate: 0x%x\",\n\t\twlvif->basic_rate, wlvif->rate_set);\n\n\t \n\tacx->rate_policy_idx = cpu_to_le32(wlvif->sta.basic_rate_idx);\n\tacx->rate_policy.enabled_rates = cpu_to_le32(wlvif->basic_rate);\n\tacx->rate_policy.short_retry_limit = c->short_retry_limit;\n\tacx->rate_policy.long_retry_limit = c->long_retry_limit;\n\tacx->rate_policy.aflags = c->aflags;\n\n\tret = wl1271_cmd_configure(wl, ACX_RATE_POLICY, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"Setting of rate policies failed: %d\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\tacx->rate_policy_idx = cpu_to_le32(wlvif->sta.ap_rate_idx);\n\n\t \n\tacx->rate_policy.enabled_rates =\n\t\tcpu_to_le32(wlcore_hw_sta_get_ap_rate_mask(wl, wlvif));\n\tacx->rate_policy.short_retry_limit = c->short_retry_limit;\n\tacx->rate_policy.long_retry_limit = c->long_retry_limit;\n\tacx->rate_policy.aflags = c->aflags;\n\n\tret = wl1271_cmd_configure(wl, ACX_RATE_POLICY, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"Setting of rate policies failed: %d\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\tacx->rate_policy_idx = cpu_to_le32(wlvif->sta.p2p_rate_idx);\n\tacx->rate_policy.enabled_rates =\n\t\t\t\tcpu_to_le32(CONF_TX_RATE_MASK_BASIC_P2P);\n\tacx->rate_policy.short_retry_limit = c->short_retry_limit;\n\tacx->rate_policy.long_retry_limit = c->long_retry_limit;\n\tacx->rate_policy.aflags = c->aflags;\n\n\tret = wl1271_cmd_configure(wl, ACX_RATE_POLICY, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"Setting of rate policies failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1271_acx_ap_rate_policy(struct wl1271 *wl, struct conf_tx_rate_class *c,\n\t\t      u8 idx)\n{\n\tstruct acx_rate_policy *acx;\n\tint ret = 0;\n\n\twl1271_debug(DEBUG_ACX, \"acx ap rate policy %d rates 0x%x\",\n\t\t     idx, c->enabled_rates);\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->rate_policy.enabled_rates = cpu_to_le32(c->enabled_rates);\n\tacx->rate_policy.short_retry_limit = c->short_retry_limit;\n\tacx->rate_policy.long_retry_limit = c->long_retry_limit;\n\tacx->rate_policy.aflags = c->aflags;\n\n\tacx->rate_policy_idx = cpu_to_le32(idx);\n\n\tret = wl1271_cmd_configure(wl, ACX_RATE_POLICY, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"Setting of ap rate policy failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1271_acx_ac_cfg(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t      u8 ac, u8 cw_min, u16 cw_max, u8 aifsn, u16 txop)\n{\n\tstruct acx_ac_cfg *acx;\n\tint ret = 0;\n\n\twl1271_debug(DEBUG_ACX, \"acx ac cfg %d cw_ming %d cw_max %d \"\n\t\t     \"aifs %d txop %d\", ac, cw_min, cw_max, aifsn, txop);\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->role_id = wlvif->role_id;\n\tacx->ac = ac;\n\tacx->cw_min = cw_min;\n\tacx->cw_max = cpu_to_le16(cw_max);\n\tacx->aifsn = aifsn;\n\tacx->tx_op_limit = cpu_to_le16(txop);\n\n\tret = wl1271_cmd_configure(wl, ACX_AC_CFG, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx ac cfg failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1271_acx_tid_cfg(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t       u8 queue_id, u8 channel_type,\n\t\t       u8 tsid, u8 ps_scheme, u8 ack_policy,\n\t\t       u32 apsd_conf0, u32 apsd_conf1)\n{\n\tstruct acx_tid_config *acx;\n\tint ret = 0;\n\n\twl1271_debug(DEBUG_ACX, \"acx tid config\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->role_id = wlvif->role_id;\n\tacx->queue_id = queue_id;\n\tacx->channel_type = channel_type;\n\tacx->tsid = tsid;\n\tacx->ps_scheme = ps_scheme;\n\tacx->ack_policy = ack_policy;\n\tacx->apsd_conf[0] = cpu_to_le32(apsd_conf0);\n\tacx->apsd_conf[1] = cpu_to_le32(apsd_conf1);\n\n\tret = wl1271_cmd_configure(wl, ACX_TID_CFG, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"Setting of tid config failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1271_acx_frag_threshold(struct wl1271 *wl, u32 frag_threshold)\n{\n\tstruct acx_frag_threshold *acx;\n\tint ret = 0;\n\n\t \n\tif (frag_threshold > IEEE80211_MAX_FRAG_THRESHOLD)\n\t\tfrag_threshold = wl->conf.tx.frag_threshold;\n\n\twl1271_debug(DEBUG_ACX, \"acx frag threshold: %d\", frag_threshold);\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->frag_threshold = cpu_to_le16((u16)frag_threshold);\n\tret = wl1271_cmd_configure(wl, ACX_FRAG_CFG, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"Setting of frag threshold failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1271_acx_tx_config_options(struct wl1271 *wl)\n{\n\tstruct acx_tx_config_options *acx;\n\tint ret = 0;\n\n\twl1271_debug(DEBUG_ACX, \"acx tx config options\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->tx_compl_timeout = cpu_to_le16(wl->conf.tx.tx_compl_timeout);\n\tacx->tx_compl_threshold = cpu_to_le16(wl->conf.tx.tx_compl_threshold);\n\tret = wl1271_cmd_configure(wl, ACX_TX_CONFIG_OPT, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"Setting of tx options failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl12xx_acx_mem_cfg(struct wl1271 *wl)\n{\n\tstruct wl12xx_acx_config_memory *mem_conf;\n\tstruct conf_memory_settings *mem;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"wl1271 mem cfg\");\n\n\tmem_conf = kzalloc(sizeof(*mem_conf), GFP_KERNEL);\n\tif (!mem_conf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmem = &wl->conf.mem;\n\n\t \n\tmem_conf->num_stations = mem->num_stations;\n\tmem_conf->rx_mem_block_num = mem->rx_block_num;\n\tmem_conf->tx_min_mem_block_num = mem->tx_min_block_num;\n\tmem_conf->num_ssid_profiles = mem->ssid_profiles;\n\tmem_conf->total_tx_descriptors = cpu_to_le32(wl->num_tx_desc);\n\tmem_conf->dyn_mem_enable = mem->dynamic_memory;\n\tmem_conf->tx_free_req = mem->min_req_tx_blocks;\n\tmem_conf->rx_free_req = mem->min_req_rx_blocks;\n\tmem_conf->tx_min = mem->tx_min;\n\tmem_conf->fwlog_blocks = wl->conf.fwlog.mem_blocks;\n\n\tret = wl1271_cmd_configure(wl, ACX_MEM_CFG, mem_conf,\n\t\t\t\t   sizeof(*mem_conf));\n\tif (ret < 0) {\n\t\twl1271_warning(\"wl1271 mem config failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(mem_conf);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wl12xx_acx_mem_cfg);\n\nint wl1271_acx_init_mem_config(struct wl1271 *wl)\n{\n\tint ret;\n\n\twl->target_mem_map = kzalloc(sizeof(struct wl1271_acx_mem_map),\n\t\t\t\t     GFP_KERNEL);\n\tif (!wl->target_mem_map) {\n\t\twl1271_error(\"couldn't allocate target memory map\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tret = wl1271_acx_mem_map(wl, (void *)wl->target_mem_map,\n\t\t\t\t sizeof(struct wl1271_acx_mem_map));\n\tif (ret < 0) {\n\t\twl1271_error(\"couldn't retrieve firmware memory map\");\n\t\tkfree(wl->target_mem_map);\n\t\twl->target_mem_map = NULL;\n\t\treturn ret;\n\t}\n\n\t \n\twl->tx_blocks_available =\n\t\tle32_to_cpu(wl->target_mem_map->num_tx_mem_blocks);\n\twl1271_debug(DEBUG_TX, \"available tx blocks: %d\",\n\t\t     wl->tx_blocks_available);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wl1271_acx_init_mem_config);\n\nint wl1271_acx_init_rx_interrupt(struct wl1271 *wl)\n{\n\tstruct wl1271_acx_rx_config_opt *rx_conf;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"wl1271 rx interrupt config\");\n\n\trx_conf = kzalloc(sizeof(*rx_conf), GFP_KERNEL);\n\tif (!rx_conf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trx_conf->threshold = cpu_to_le16(wl->conf.rx.irq_pkt_threshold);\n\trx_conf->timeout = cpu_to_le16(wl->conf.rx.irq_timeout);\n\trx_conf->mblk_threshold = cpu_to_le16(wl->conf.rx.irq_blk_threshold);\n\trx_conf->queue_type = wl->conf.rx.queue_type;\n\n\tret = wl1271_cmd_configure(wl, ACX_RX_CONFIG_OPT, rx_conf,\n\t\t\t\t   sizeof(*rx_conf));\n\tif (ret < 0) {\n\t\twl1271_warning(\"wl1271 rx config opt failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(rx_conf);\n\treturn ret;\n}\n\nint wl1271_acx_bet_enable(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t  bool enable)\n{\n\tstruct wl1271_acx_bet_enable *acx = NULL;\n\tint ret = 0;\n\n\twl1271_debug(DEBUG_ACX, \"acx bet enable\");\n\n\tif (enable && wl->conf.conn.bet_enable == CONF_BET_MODE_DISABLE)\n\t\tgoto out;\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->role_id = wlvif->role_id;\n\tacx->enable = enable ? CONF_BET_MODE_ENABLE : CONF_BET_MODE_DISABLE;\n\tacx->max_consecutive = wl->conf.conn.bet_max_consecutive;\n\n\tret = wl1271_cmd_configure(wl, ACX_BET_ENABLE, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx bet enable failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1271_acx_arp_ip_filter(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t     u8 enable, __be32 address)\n{\n\tstruct wl1271_acx_arp_filter *acx;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx arp ip filter, enable: %d\", enable);\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->role_id = wlvif->role_id;\n\tacx->version = ACX_IPV4_VERSION;\n\tacx->enable = enable;\n\n\tif (enable)\n\t\tmemcpy(acx->address, &address, ACX_IPV4_ADDR_SIZE);\n\n\tret = wl1271_cmd_configure(wl, ACX_ARP_IP_FILTER,\n\t\t\t\t   acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"failed to set arp ip filter: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1271_acx_pm_config(struct wl1271 *wl)\n{\n\tstruct wl1271_acx_pm_config *acx = NULL;\n\tstruct  conf_pm_config_settings *c = &wl->conf.pm_config;\n\tint ret = 0;\n\n\twl1271_debug(DEBUG_ACX, \"acx pm config\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->host_clk_settling_time = cpu_to_le32(c->host_clk_settling_time);\n\tacx->host_fast_wakeup_support = c->host_fast_wakeup_support;\n\n\tret = wl1271_cmd_configure(wl, ACX_PM_CONFIG, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx pm config failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wl1271_acx_pm_config);\n\nint wl1271_acx_keep_alive_mode(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t       bool enable)\n{\n\tstruct wl1271_acx_keep_alive_mode *acx = NULL;\n\tint ret = 0;\n\n\twl1271_debug(DEBUG_ACX, \"acx keep alive mode: %d\", enable);\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->role_id = wlvif->role_id;\n\tacx->enabled = enable;\n\n\tret = wl1271_cmd_configure(wl, ACX_KEEP_ALIVE_MODE, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx keep alive mode failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1271_acx_keep_alive_config(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t\t u8 index, u8 tpl_valid)\n{\n\tstruct wl1271_acx_keep_alive_config *acx = NULL;\n\tint ret = 0;\n\n\twl1271_debug(DEBUG_ACX, \"acx keep alive config\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->role_id = wlvif->role_id;\n\tacx->period = cpu_to_le32(wl->conf.conn.keep_alive_interval);\n\tacx->index = index;\n\tacx->tpl_validation = tpl_valid;\n\tacx->trigger = ACX_KEEP_ALIVE_NO_TX;\n\n\tret = wl1271_cmd_configure(wl, ACX_SET_KEEP_ALIVE_CONFIG,\n\t\t\t\t   acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx keep alive config failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1271_acx_rssi_snr_trigger(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t\tbool enable, s16 thold, u8 hyst)\n{\n\tstruct wl1271_acx_rssi_snr_trigger *acx = NULL;\n\tint ret = 0;\n\n\twl1271_debug(DEBUG_ACX, \"acx rssi snr trigger\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\twlvif->last_rssi_event = -1;\n\n\tacx->role_id = wlvif->role_id;\n\tacx->pacing = cpu_to_le16(wl->conf.roam_trigger.trigger_pacing);\n\tacx->metric = WL1271_ACX_TRIG_METRIC_RSSI_BEACON;\n\tacx->type = WL1271_ACX_TRIG_TYPE_EDGE;\n\tif (enable)\n\t\tacx->enable = WL1271_ACX_TRIG_ENABLE;\n\telse\n\t\tacx->enable = WL1271_ACX_TRIG_DISABLE;\n\n\tacx->index = WL1271_ACX_TRIG_IDX_RSSI;\n\tacx->dir = WL1271_ACX_TRIG_DIR_BIDIR;\n\tacx->threshold = cpu_to_le16(thold);\n\tacx->hysteresis = hyst;\n\n\tret = wl1271_cmd_configure(wl, ACX_RSSI_SNR_TRIGGER, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx rssi snr trigger setting failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1271_acx_rssi_snr_avg_weights(struct wl1271 *wl,\n\t\t\t\t    struct wl12xx_vif *wlvif)\n{\n\tstruct wl1271_acx_rssi_snr_avg_weights *acx = NULL;\n\tstruct conf_roam_trigger_settings *c = &wl->conf.roam_trigger;\n\tint ret = 0;\n\n\twl1271_debug(DEBUG_ACX, \"acx rssi snr avg weights\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->role_id = wlvif->role_id;\n\tacx->rssi_beacon = c->avg_weight_rssi_beacon;\n\tacx->rssi_data = c->avg_weight_rssi_data;\n\tacx->snr_beacon = c->avg_weight_snr_beacon;\n\tacx->snr_data = c->avg_weight_snr_data;\n\n\tret = wl1271_cmd_configure(wl, ACX_RSSI_SNR_WEIGHTS, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx rssi snr trigger weights failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1271_acx_set_ht_capabilities(struct wl1271 *wl,\n\t\t\t\t    struct ieee80211_sta_ht_cap *ht_cap,\n\t\t\t\t    bool allow_ht_operation, u8 hlid)\n{\n\tstruct wl1271_acx_ht_capabilities *acx;\n\tint ret = 0;\n\tu32 ht_capabilites = 0;\n\n\twl1271_debug(DEBUG_ACX, \"acx ht capabilities setting \"\n\t\t     \"sta supp: %d sta cap: %d\", ht_cap->ht_supported,\n\t\t     ht_cap->cap);\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (allow_ht_operation && ht_cap->ht_supported) {\n\t\t \n\t\tht_capabilites = ht_cap->cap;\n\n\t\t \n\t\tht_capabilites |= WL12XX_HT_CAP_HT_OPERATION;\n\n\t\t \n\t\tacx->ampdu_max_length = ht_cap->ampdu_factor;\n\t\tacx->ampdu_min_spacing = ht_cap->ampdu_density;\n\t}\n\n\tacx->hlid = hlid;\n\tacx->ht_capabilites = cpu_to_le32(ht_capabilites);\n\n\tret = wl1271_cmd_configure(wl, ACX_PEER_HT_CAP, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx ht capabilities setting failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wl1271_acx_set_ht_capabilities);\n\n\nint wl1271_acx_set_ht_information(struct wl1271 *wl,\n\t\t\t\t   struct wl12xx_vif *wlvif,\n\t\t\t\t   u16 ht_operation_mode)\n{\n\tstruct wl1271_acx_ht_information *acx;\n\tint ret = 0;\n\n\twl1271_debug(DEBUG_ACX, \"acx ht information setting\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->role_id = wlvif->role_id;\n\tacx->ht_protection =\n\t\t(u8)(ht_operation_mode & IEEE80211_HT_OP_MODE_PROTECTION);\n\tacx->rifs_mode = 0;\n\tacx->gf_protection =\n\t\t!!(ht_operation_mode & IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\n\tacx->ht_tx_burst_limit = 0;\n\tacx->dual_cts_protection = 0;\n\n\tret = wl1271_cmd_configure(wl, ACX_HT_BSS_OPERATION, acx, sizeof(*acx));\n\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx ht information setting failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\n \nint wl12xx_acx_set_ba_initiator_policy(struct wl1271 *wl,\n\t\t\t\t       struct wl12xx_vif *wlvif)\n{\n\tstruct wl1271_acx_ba_initiator_policy *acx;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx ba initiator policy\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tacx->role_id = wlvif->role_id;\n\tacx->tid_bitmap = wl->conf.ht.tx_ba_tid_bitmap;\n\tacx->win_size = wl->conf.ht.tx_ba_win_size;\n\tacx->inactivity_timeout = wl->conf.ht.inactivity_timeout;\n\n\tret = wl1271_cmd_configure(wl,\n\t\t\t\t   ACX_BA_SESSION_INIT_POLICY,\n\t\t\t\t   acx,\n\t\t\t\t   sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx ba initiator policy failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\n \nint wl12xx_acx_set_ba_receiver_session(struct wl1271 *wl, u8 tid_index,\n\t\t\t\t       u16 ssn, bool enable, u8 peer_hlid,\n\t\t\t\t       u8 win_size)\n{\n\tstruct wl1271_acx_ba_receiver_setup *acx;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx ba receiver session setting\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->hlid = peer_hlid;\n\tacx->tid = tid_index;\n\tacx->enable = enable;\n\tacx->win_size =\twin_size;\n\tacx->ssn = ssn;\n\n\tret = wlcore_cmd_configure_failsafe(wl, ACX_BA_SESSION_RX_SETUP, acx,\n\t\t\t\t\t    sizeof(*acx),\n\t\t\t\t\t    BIT(CMD_STATUS_NO_RX_BA_SESSION));\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx ba receiver session failed: %d\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\tif (ret == CMD_STATUS_NO_RX_BA_SESSION) {\n\t\twl1271_warning(\"no fw rx ba on tid %d\", tid_index);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl12xx_acx_tsf_info(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\tu64 *mactime)\n{\n\tstruct wl12xx_acx_fw_tsf_information *tsf_info;\n\tint ret;\n\n\ttsf_info = kzalloc(sizeof(*tsf_info), GFP_KERNEL);\n\tif (!tsf_info) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttsf_info->role_id = wlvif->role_id;\n\n\tret = wl1271_cmd_interrogate(wl, ACX_TSF_INFO, tsf_info,\n\t\t\t\tsizeof(struct acx_header), sizeof(*tsf_info));\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx tsf info interrogate failed\");\n\t\tgoto out;\n\t}\n\n\t*mactime = le32_to_cpu(tsf_info->current_tsf_low) |\n\t\t((u64) le32_to_cpu(tsf_info->current_tsf_high) << 32);\n\nout:\n\tkfree(tsf_info);\n\treturn ret;\n}\n\nint wl1271_acx_ps_rx_streaming(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t       bool enable)\n{\n\tstruct wl1271_acx_ps_rx_streaming *rx_streaming;\n\tu32 conf_queues, enable_queues;\n\tint i, ret = 0;\n\n\twl1271_debug(DEBUG_ACX, \"acx ps rx streaming\");\n\n\trx_streaming = kzalloc(sizeof(*rx_streaming), GFP_KERNEL);\n\tif (!rx_streaming) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tconf_queues = wl->conf.rx_streaming.queues;\n\tif (enable)\n\t\tenable_queues = conf_queues;\n\telse\n\t\tenable_queues = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\t \n\t\tif (!(conf_queues & BIT(i)))\n\t\t\tcontinue;\n\n\t\trx_streaming->role_id = wlvif->role_id;\n\t\trx_streaming->tid = i;\n\t\trx_streaming->enable = enable_queues & BIT(i);\n\t\trx_streaming->period = wl->conf.rx_streaming.interval;\n\t\trx_streaming->timeout = wl->conf.rx_streaming.interval;\n\n\t\tret = wl1271_cmd_configure(wl, ACX_PS_RX_STREAMING,\n\t\t\t\t\t   rx_streaming,\n\t\t\t\t\t   sizeof(*rx_streaming));\n\t\tif (ret < 0) {\n\t\t\twl1271_warning(\"acx ps rx streaming failed: %d\", ret);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tkfree(rx_streaming);\n\treturn ret;\n}\n\nint wl1271_acx_ap_max_tx_retry(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tstruct wl1271_acx_ap_max_tx_retry *acx = NULL;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx ap max tx retry\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx)\n\t\treturn -ENOMEM;\n\n\tacx->role_id = wlvif->role_id;\n\tacx->max_tx_retry = cpu_to_le16(wl->conf.tx.max_tx_retries);\n\n\tret = wl1271_cmd_configure(wl, ACX_MAX_TX_FAILURE, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx ap max tx retry failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl12xx_acx_config_ps(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tstruct wl1271_acx_config_ps *config_ps;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx config ps\");\n\n\tconfig_ps = kzalloc(sizeof(*config_ps), GFP_KERNEL);\n\tif (!config_ps) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tconfig_ps->exit_retries = wl->conf.conn.psm_exit_retries;\n\tconfig_ps->enter_retries = wl->conf.conn.psm_entry_retries;\n\tconfig_ps->null_data_rate = cpu_to_le32(wlvif->basic_rate);\n\n\tret = wl1271_cmd_configure(wl, ACX_CONFIG_PS, config_ps,\n\t\t\t\t   sizeof(*config_ps));\n\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx config ps failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(config_ps);\n\treturn ret;\n}\n\nint wl1271_acx_set_inconnection_sta(struct wl1271 *wl,\n\t\t\t\t    struct wl12xx_vif *wlvif, u8 *addr)\n{\n\tstruct wl1271_acx_inconnection_sta *acx = NULL;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx set inconnaction sta %pM\", addr);\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx)\n\t\treturn -ENOMEM;\n\n\tmemcpy(acx->addr, addr, ETH_ALEN);\n\tacx->role_id = wlvif->role_id;\n\n\tret = wl1271_cmd_configure(wl, ACX_UPDATE_INCONNECTION_STA_LIST,\n\t\t\t\t   acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx set inconnaction sta failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1271_acx_fm_coex(struct wl1271 *wl)\n{\n\tstruct wl1271_acx_fm_coex *acx;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx fm coex setting\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->enable = wl->conf.fm_coex.enable;\n\tacx->swallow_period = wl->conf.fm_coex.swallow_period;\n\tacx->n_divider_fref_set_1 = wl->conf.fm_coex.n_divider_fref_set_1;\n\tacx->n_divider_fref_set_2 = wl->conf.fm_coex.n_divider_fref_set_2;\n\tacx->m_divider_fref_set_1 =\n\t\tcpu_to_le16(wl->conf.fm_coex.m_divider_fref_set_1);\n\tacx->m_divider_fref_set_2 =\n\t\tcpu_to_le16(wl->conf.fm_coex.m_divider_fref_set_2);\n\tacx->coex_pll_stabilization_time =\n\t\tcpu_to_le32(wl->conf.fm_coex.coex_pll_stabilization_time);\n\tacx->ldo_stabilization_time =\n\t\tcpu_to_le16(wl->conf.fm_coex.ldo_stabilization_time);\n\tacx->fm_disturbed_band_margin =\n\t\twl->conf.fm_coex.fm_disturbed_band_margin;\n\tacx->swallow_clk_diff = wl->conf.fm_coex.swallow_clk_diff;\n\n\tret = wl1271_cmd_configure(wl, ACX_FM_COEX_CFG, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx fm coex setting failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl12xx_acx_set_rate_mgmt_params(struct wl1271 *wl)\n{\n\tstruct wl12xx_acx_set_rate_mgmt_params *acx = NULL;\n\tstruct conf_rate_policy_settings *conf = &wl->conf.rate;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx set rate mgmt params\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx)\n\t\treturn -ENOMEM;\n\n\tacx->index = ACX_RATE_MGMT_ALL_PARAMS;\n\tacx->rate_retry_score = cpu_to_le16(conf->rate_retry_score);\n\tacx->per_add = cpu_to_le16(conf->per_add);\n\tacx->per_th1 = cpu_to_le16(conf->per_th1);\n\tacx->per_th2 = cpu_to_le16(conf->per_th2);\n\tacx->max_per = cpu_to_le16(conf->max_per);\n\tacx->inverse_curiosity_factor = conf->inverse_curiosity_factor;\n\tacx->tx_fail_low_th = conf->tx_fail_low_th;\n\tacx->tx_fail_high_th = conf->tx_fail_high_th;\n\tacx->per_alpha_shift = conf->per_alpha_shift;\n\tacx->per_add_shift = conf->per_add_shift;\n\tacx->per_beta1_shift = conf->per_beta1_shift;\n\tacx->per_beta2_shift = conf->per_beta2_shift;\n\tacx->rate_check_up = conf->rate_check_up;\n\tacx->rate_check_down = conf->rate_check_down;\n\tmemcpy(acx->rate_retry_policy, conf->rate_retry_policy,\n\t       sizeof(acx->rate_retry_policy));\n\n\tret = wl1271_cmd_configure(wl, ACX_SET_RATE_MGMT_PARAMS,\n\t\t\t\t   acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx set rate mgmt params failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl12xx_acx_config_hangover(struct wl1271 *wl)\n{\n\tstruct wl12xx_acx_config_hangover *acx;\n\tstruct conf_hangover_settings *conf = &wl->conf.hangover;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx config hangover\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->recover_time = cpu_to_le32(conf->recover_time);\n\tacx->hangover_period = conf->hangover_period;\n\tacx->dynamic_mode = conf->dynamic_mode;\n\tacx->early_termination_mode = conf->early_termination_mode;\n\tacx->max_period = conf->max_period;\n\tacx->min_period = conf->min_period;\n\tacx->increase_delta = conf->increase_delta;\n\tacx->decrease_delta = conf->decrease_delta;\n\tacx->quiet_time = conf->quiet_time;\n\tacx->increase_time = conf->increase_time;\n\tacx->window_size = conf->window_size;\n\n\tret = wl1271_cmd_configure(wl, ACX_CONFIG_HANGOVER, acx,\n\t\t\t\t   sizeof(*acx));\n\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx config hangover failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n\n}\n\nint wlcore_acx_average_rssi(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t    s8 *avg_rssi)\n{\n\tstruct acx_roaming_stats *acx;\n\tint ret = 0;\n\n\twl1271_debug(DEBUG_ACX, \"acx roaming statistics\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tacx->role_id = wlvif->role_id;\n\tret = wl1271_cmd_interrogate(wl, ACX_ROAMING_STATISTICS_TBL,\n\t\t\t\t     acx, sizeof(*acx), sizeof(*acx));\n\tif (ret\t< 0) {\n\t\twl1271_warning(\"acx roaming statistics failed: %d\", ret);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t*avg_rssi = acx->rssi_beacon;\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\n#ifdef CONFIG_PM\n \nint wl1271_acx_default_rx_filter_enable(struct wl1271 *wl, bool enable,\n\t\t\t\t\tenum rx_filter_action action)\n{\n\tstruct acx_default_rx_filter *acx;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"acx default rx filter en: %d act: %d\",\n\t\t     enable, action);\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx)\n\t\treturn -ENOMEM;\n\n\tacx->enable = enable;\n\tacx->default_action = action;\n\n\tret = wl1271_cmd_configure(wl, ACX_ENABLE_RX_DATA_FILTER, acx,\n\t\t\t\t   sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1271_warning(\"acx default rx filter enable failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\n \nint wl1271_acx_set_rx_filter(struct wl1271 *wl, u8 index, bool enable,\n\t\t\t     struct wl12xx_rx_filter *filter)\n{\n\tstruct acx_rx_filter_cfg *acx;\n\tint fields_size = 0;\n\tint acx_size;\n\tint ret;\n\n\tWARN_ON(enable && !filter);\n\tWARN_ON(index >= WL1271_MAX_RX_FILTERS);\n\n\twl1271_debug(DEBUG_ACX,\n\t\t     \"acx set rx filter idx: %d enable: %d filter: %p\",\n\t\t     index, enable, filter);\n\n\tif (enable) {\n\t\tfields_size = wl1271_rx_filter_get_fields_size(filter);\n\n\t\twl1271_debug(DEBUG_ACX, \"act: %d num_fields: %d field_size: %d\",\n\t\t      filter->action, filter->num_fields, fields_size);\n\t}\n\n\tacx_size = ALIGN(sizeof(*acx) + fields_size, 4);\n\tacx = kzalloc(acx_size, GFP_KERNEL);\n\n\tif (!acx)\n\t\treturn -ENOMEM;\n\n\tacx->enable = enable;\n\tacx->index = index;\n\n\tif (enable) {\n\t\tacx->num_fields = filter->num_fields;\n\t\tacx->action = filter->action;\n\t\twl1271_rx_filter_flatten_fields(filter, acx->fields);\n\t}\n\n\twl1271_dump(DEBUG_ACX, \"RX_FILTER: \", acx, acx_size);\n\n\tret = wl1271_cmd_configure(wl, ACX_SET_RX_DATA_FILTER, acx, acx_size);\n\tif (ret < 0) {\n\t\twl1271_warning(\"setting rx filter failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}