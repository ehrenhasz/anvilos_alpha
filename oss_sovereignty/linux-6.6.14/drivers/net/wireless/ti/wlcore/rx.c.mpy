{
  "module_name": "rx.c",
  "hash_id": "5ca5390bd113cd74547d2ed4d29ce5becd6d5602530b172cbc0b181aa6362b79",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wlcore/rx.c",
  "human_readable_source": "\n \n\n#include <linux/gfp.h>\n#include <linux/sched.h>\n\n#include \"wlcore.h\"\n#include \"debug.h\"\n#include \"acx.h\"\n#include \"rx.h\"\n#include \"tx.h\"\n#include \"io.h\"\n#include \"hw_ops.h\"\n\n \n#include \"../wl12xx/reg.h\"\n\nstatic u32 wlcore_rx_get_buf_size(struct wl1271 *wl,\n\t\t\t\t  u32 rx_pkt_desc)\n{\n\tif (wl->quirks & WLCORE_QUIRK_RX_BLOCKSIZE_ALIGN)\n\t\treturn (rx_pkt_desc & ALIGNED_RX_BUF_SIZE_MASK) >>\n\t\t       ALIGNED_RX_BUF_SIZE_SHIFT;\n\n\treturn (rx_pkt_desc & RX_BUF_SIZE_MASK) >> RX_BUF_SIZE_SHIFT_DIV;\n}\n\nstatic u32 wlcore_rx_get_align_buf_size(struct wl1271 *wl, u32 pkt_len)\n{\n\tif (wl->quirks & WLCORE_QUIRK_RX_BLOCKSIZE_ALIGN)\n\t\treturn ALIGN(pkt_len, WL12XX_BUS_BLOCK_SIZE);\n\n\treturn pkt_len;\n}\n\nstatic void wl1271_rx_status(struct wl1271 *wl,\n\t\t\t     struct wl1271_rx_descriptor *desc,\n\t\t\t     struct ieee80211_rx_status *status,\n\t\t\t     u8 beacon, u8 probe_rsp)\n{\n\tmemset(status, 0, sizeof(struct ieee80211_rx_status));\n\n\tif ((desc->flags & WL1271_RX_DESC_BAND_MASK) == WL1271_RX_DESC_BAND_BG)\n\t\tstatus->band = NL80211_BAND_2GHZ;\n\telse\n\t\tstatus->band = NL80211_BAND_5GHZ;\n\n\tstatus->rate_idx = wlcore_rate_to_idx(wl, desc->rate, status->band);\n\n\t \n\tif (desc->rate <= wl->hw_min_ht_rate)\n\t\tstatus->encoding = RX_ENC_HT;\n\n\t \n\tstatus->signal = ((desc->rssi & RSSI_LEVEL_BITMASK) | BIT(7));\n\tstatus->antenna = ((desc->rssi & ANT_DIVERSITY_BITMASK) >> 7);\n\n\t \n\twl->noise = desc->rssi - (desc->snr >> 1);\n\n\tstatus->freq = ieee80211_channel_to_frequency(desc->channel,\n\t\t\t\t\t\t      status->band);\n\n\tif (desc->flags & WL1271_RX_DESC_ENCRYPT_MASK) {\n\t\tu8 desc_err_code = desc->status & WL1271_RX_DESC_STATUS_MASK;\n\n\t\tstatus->flag |= RX_FLAG_IV_STRIPPED | RX_FLAG_MMIC_STRIPPED |\n\t\t\t\tRX_FLAG_DECRYPTED;\n\n\t\tif (unlikely(desc_err_code & WL1271_RX_DESC_MIC_FAIL)) {\n\t\t\tstatus->flag |= RX_FLAG_MMIC_ERROR;\n\t\t\twl1271_warning(\"Michael MIC error. Desc: 0x%x\",\n\t\t\t\t       desc_err_code);\n\t\t}\n\t}\n\n\tif (beacon || probe_rsp)\n\t\tstatus->boottime_ns = ktime_get_boottime_ns();\n\n\tif (beacon)\n\t\twlcore_set_pending_regdomain_ch(wl, (u16)desc->channel,\n\t\t\t\t\t\tstatus->band);\n}\n\nstatic int wl1271_rx_handle_data(struct wl1271 *wl, u8 *data, u32 length,\n\t\t\t\t enum wl_rx_buf_align rx_align, u8 *hlid)\n{\n\tstruct wl1271_rx_descriptor *desc;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr *hdr;\n\tu8 beacon = 0;\n\tu8 is_data = 0;\n\tu8 reserved = 0, offset_to_data = 0;\n\tu16 seq_num;\n\tu32 pkt_data_len;\n\n\t \n\tif (unlikely(wl->plt))\n\t\treturn -EINVAL;\n\n\tpkt_data_len = wlcore_hw_get_rx_packet_len(wl, data, length);\n\tif (!pkt_data_len) {\n\t\twl1271_error(\"Invalid packet arrived from HW. length %d\",\n\t\t\t     length);\n\t\treturn -EINVAL;\n\t}\n\n\tif (rx_align == WLCORE_RX_BUF_UNALIGNED)\n\t\treserved = RX_BUF_ALIGN;\n\telse if (rx_align == WLCORE_RX_BUF_PADDED)\n\t\toffset_to_data = RX_BUF_ALIGN;\n\n\t \n\tdesc = (struct wl1271_rx_descriptor *) data;\n\n\tif (desc->packet_class == WL12XX_RX_CLASS_LOGGER) {\n\t\tsize_t len = length - sizeof(*desc);\n\t\twl12xx_copy_fwlog(wl, data + sizeof(*desc), len);\n\t\treturn 0;\n\t}\n\n\t \n\tif (desc->status & WL1271_RX_DESC_DECRYPT_FAIL) {\n\t\thdr = (void *)(data + sizeof(*desc) + offset_to_data);\n\t\twl1271_warning(\"corrupted packet in RX: status: 0x%x len: %d\",\n\t\t\t       desc->status & WL1271_RX_DESC_STATUS_MASK,\n\t\t\t       pkt_data_len);\n\t\twl1271_dump((DEBUG_RX|DEBUG_CMD), \"PKT: \", data + sizeof(*desc),\n\t\t\t    min(pkt_data_len,\n\t\t\t\tieee80211_hdrlen(hdr->frame_control)));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tskb = __dev_alloc_skb(pkt_data_len + reserved, GFP_KERNEL);\n\tif (!skb) {\n\t\twl1271_error(\"Couldn't allocate RX frame\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tskb_reserve(skb, reserved);\n\n\t \n\tskb_put_data(skb, data + sizeof(*desc), pkt_data_len);\n\tif (rx_align == WLCORE_RX_BUF_PADDED)\n\t\tskb_pull(skb, RX_BUF_ALIGN);\n\n\t*hlid = desc->hlid;\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\tif (ieee80211_is_beacon(hdr->frame_control))\n\t\tbeacon = 1;\n\tif (ieee80211_is_data_present(hdr->frame_control))\n\t\tis_data = 1;\n\n\twl1271_rx_status(wl, desc, IEEE80211_SKB_RXCB(skb), beacon,\n\t\t\t ieee80211_is_probe_resp(hdr->frame_control));\n\twlcore_hw_set_rx_csum(wl, desc, skb);\n\n\tseq_num = (le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_SEQ) >> 4;\n\twl1271_debug(DEBUG_RX, \"rx skb 0x%p: %d B %s seq %d hlid %d\", skb,\n\t\t     skb->len - desc->pad_len,\n\t\t     beacon ? \"beacon\" : \"\",\n\t\t     seq_num, *hlid);\n\n\tskb_queue_tail(&wl->deferred_rx_queue, skb);\n\tqueue_work(wl->freezable_wq, &wl->netstack_work);\n\n\treturn is_data;\n}\n\nint wlcore_rx(struct wl1271 *wl, struct wl_fw_status *status)\n{\n\tunsigned long active_hlids[BITS_TO_LONGS(WLCORE_MAX_LINKS)] = {0};\n\tu32 buf_size;\n\tu32 fw_rx_counter = status->fw_rx_counter % wl->num_rx_desc;\n\tu32 drv_rx_counter = wl->rx_counter % wl->num_rx_desc;\n\tu32 rx_counter;\n\tu32 pkt_len, align_pkt_len;\n\tu32 pkt_offset, des;\n\tu8 hlid;\n\tenum wl_rx_buf_align rx_align;\n\tint ret = 0;\n\n\t \n\thlid = status->counters.hlid;\n\n\tif (hlid < WLCORE_MAX_LINKS)\n\t\twl->links[hlid].fw_rate_mbps =\n\t\t\t\tstatus->counters.tx_last_rate_mbps;\n\n\twhile (drv_rx_counter != fw_rx_counter) {\n\t\tbuf_size = 0;\n\t\trx_counter = drv_rx_counter;\n\t\twhile (rx_counter != fw_rx_counter) {\n\t\t\tdes = le32_to_cpu(status->rx_pkt_descs[rx_counter]);\n\t\t\tpkt_len = wlcore_rx_get_buf_size(wl, des);\n\t\t\talign_pkt_len = wlcore_rx_get_align_buf_size(wl,\n\t\t\t\t\t\t\t\t     pkt_len);\n\t\t\tif (buf_size + align_pkt_len > wl->aggr_buf_size)\n\t\t\t\tbreak;\n\t\t\tbuf_size += align_pkt_len;\n\t\t\trx_counter++;\n\t\t\trx_counter %= wl->num_rx_desc;\n\t\t}\n\n\t\tif (buf_size == 0) {\n\t\t\twl1271_warning(\"received empty data\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tdes = le32_to_cpu(status->rx_pkt_descs[drv_rx_counter]);\n\t\tret = wlcore_hw_prepare_read(wl, des, buf_size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = wlcore_read_data(wl, REG_SLV_MEM_DATA, wl->aggr_buf,\n\t\t\t\t       buf_size, true);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t \n\t\tpkt_offset = 0;\n\t\twhile (pkt_offset < buf_size) {\n\t\t\tdes = le32_to_cpu(status->rx_pkt_descs[drv_rx_counter]);\n\t\t\tpkt_len = wlcore_rx_get_buf_size(wl, des);\n\t\t\trx_align = wlcore_hw_get_rx_buf_align(wl, des);\n\n\t\t\t \n\t\t\tif (wl1271_rx_handle_data(wl,\n\t\t\t\t\t\t  wl->aggr_buf + pkt_offset,\n\t\t\t\t\t\t  pkt_len, rx_align,\n\t\t\t\t\t\t  &hlid) == 1) {\n\t\t\t\tif (hlid < wl->num_links)\n\t\t\t\t\t__set_bit(hlid, active_hlids);\n\t\t\t\telse\n\t\t\t\t\tWARN(1,\n\t\t\t\t\t     \"hlid (%d) exceeded MAX_LINKS\\n\",\n\t\t\t\t\t     hlid);\n\t\t\t}\n\n\t\t\twl->rx_counter++;\n\t\t\tdrv_rx_counter++;\n\t\t\tdrv_rx_counter %= wl->num_rx_desc;\n\t\t\tpkt_offset += wlcore_rx_get_align_buf_size(wl, pkt_len);\n\t\t}\n\t}\n\n\t \n\tif (wl->quirks & WLCORE_QUIRK_END_OF_TRANSACTION) {\n\t\tret = wlcore_write32(wl, WL12XX_REG_RX_DRIVER_COUNTER,\n\t\t\t\t     wl->rx_counter);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\twl12xx_rearm_rx_streaming(wl, active_hlids);\n\nout:\n\treturn ret;\n}\n\n#ifdef CONFIG_PM\nint wl1271_rx_filter_enable(struct wl1271 *wl,\n\t\t\t    int index, bool enable,\n\t\t\t    struct wl12xx_rx_filter *filter)\n{\n\tint ret;\n\n\tif (!!test_bit(index, wl->rx_filter_enabled) == enable) {\n\t\twl1271_warning(\"Request to enable an already \"\n\t\t\t     \"enabled rx filter %d\", index);\n\t\treturn 0;\n\t}\n\n\tret = wl1271_acx_set_rx_filter(wl, index, enable, filter);\n\n\tif (ret) {\n\t\twl1271_error(\"Failed to %s rx data filter %d (err=%d)\",\n\t\t\t     enable ? \"enable\" : \"disable\", index, ret);\n\t\treturn ret;\n\t}\n\n\tif (enable)\n\t\t__set_bit(index, wl->rx_filter_enabled);\n\telse\n\t\t__clear_bit(index, wl->rx_filter_enabled);\n\n\treturn 0;\n}\n\nint wl1271_rx_filter_clear_all(struct wl1271 *wl)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; i < WL1271_MAX_RX_FILTERS; i++) {\n\t\tif (!test_bit(i, wl->rx_filter_enabled))\n\t\t\tcontinue;\n\t\tret = wl1271_rx_filter_enable(wl, i, 0, NULL);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}