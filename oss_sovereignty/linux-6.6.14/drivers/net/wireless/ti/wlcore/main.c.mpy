{
  "module_name": "main.c",
  "hash_id": "c5dac444602738bed9211925f164b0d4af788b8a011bb800451016e9030e109e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wlcore/main.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/firmware.h>\n#include <linux/etherdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_wakeirq.h>\n\n#include \"wlcore.h\"\n#include \"debug.h\"\n#include \"wl12xx_80211.h\"\n#include \"io.h\"\n#include \"tx.h\"\n#include \"ps.h\"\n#include \"init.h\"\n#include \"debugfs.h\"\n#include \"testmode.h\"\n#include \"vendor_cmd.h\"\n#include \"scan.h\"\n#include \"hw_ops.h\"\n#include \"sysfs.h\"\n\n#define WL1271_BOOT_RETRIES 3\n#define WL1271_WAKEUP_TIMEOUT 500\n\nstatic char *fwlog_param;\nstatic int fwlog_mem_blocks = -1;\nstatic int bug_on_recovery = -1;\nstatic int no_recovery     = -1;\n\nstatic void __wl1271_op_remove_interface(struct wl1271 *wl,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t bool reset_tx_queues);\nstatic void wlcore_op_stop_locked(struct wl1271 *wl);\nstatic void wl1271_free_ap_keys(struct wl1271 *wl, struct wl12xx_vif *wlvif);\n\nstatic int wl12xx_set_authorized(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tint ret;\n\n\tif (WARN_ON(wlvif->bss_type != BSS_TYPE_STA_BSS))\n\t\treturn -EINVAL;\n\n\tif (!test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags))\n\t\treturn 0;\n\n\tif (test_and_set_bit(WLVIF_FLAG_STA_STATE_SENT, &wlvif->flags))\n\t\treturn 0;\n\n\tret = wl12xx_cmd_set_peer_state(wl, wlvif, wlvif->sta.hlid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twl1271_info(\"Association completed.\");\n\treturn 0;\n}\n\nstatic void wl1271_reg_notify(struct wiphy *wiphy,\n\t\t\t      struct regulatory_request *request)\n{\n\tstruct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);\n\tstruct wl1271 *wl = hw->priv;\n\n\t \n\tif (request)\n\t\twl->dfs_region = request->dfs_region;\n\n\twlcore_regdomain_config(wl);\n}\n\nstatic int wl1271_set_rx_streaming(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t\t   bool enable)\n{\n\tint ret = 0;\n\n\t \n\tret = wl1271_acx_ps_rx_streaming(wl, wlvif, enable);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (enable)\n\t\tset_bit(WLVIF_FLAG_RX_STREAMING_STARTED, &wlvif->flags);\n\telse\n\t\tclear_bit(WLVIF_FLAG_RX_STREAMING_STARTED, &wlvif->flags);\nout:\n\treturn ret;\n}\n\n \nint wl1271_recalc_rx_streaming(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tint ret = 0;\n\tint period = wl->conf.rx_streaming.interval;\n\n\t \n\tif (!test_bit(WLVIF_FLAG_RX_STREAMING_STARTED, &wlvif->flags))\n\t\tgoto out;\n\n\t \n\tif (period &&\n\t    test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags) &&\n\t    (wl->conf.rx_streaming.always ||\n\t     test_bit(WL1271_FLAG_SOFT_GEMINI, &wl->flags)))\n\t\tret = wl1271_set_rx_streaming(wl, wlvif, true);\n\telse {\n\t\tret = wl1271_set_rx_streaming(wl, wlvif, false);\n\t\t \n\t\tdel_timer_sync(&wlvif->rx_streaming_timer);\n\t}\nout:\n\treturn ret;\n}\n\nstatic void wl1271_rx_streaming_enable_work(struct work_struct *work)\n{\n\tint ret;\n\tstruct wl12xx_vif *wlvif = container_of(work, struct wl12xx_vif,\n\t\t\t\t\t\trx_streaming_enable_work);\n\tstruct wl1271 *wl = wlvif->wl;\n\n\tmutex_lock(&wl->mutex);\n\n\tif (test_bit(WLVIF_FLAG_RX_STREAMING_STARTED, &wlvif->flags) ||\n\t    !test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags) ||\n\t    (!wl->conf.rx_streaming.always &&\n\t     !test_bit(WL1271_FLAG_SOFT_GEMINI, &wl->flags)))\n\t\tgoto out;\n\n\tif (!wl->conf.rx_streaming.interval)\n\t\tgoto out;\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl1271_set_rx_streaming(wl, wlvif, true);\n\tif (ret < 0)\n\t\tgoto out_sleep;\n\n\t \n\tmod_timer(&wlvif->rx_streaming_timer,\n\t\t  jiffies + msecs_to_jiffies(wl->conf.rx_streaming.duration));\n\nout_sleep:\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\nout:\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic void wl1271_rx_streaming_disable_work(struct work_struct *work)\n{\n\tint ret;\n\tstruct wl12xx_vif *wlvif = container_of(work, struct wl12xx_vif,\n\t\t\t\t\t\trx_streaming_disable_work);\n\tstruct wl1271 *wl = wlvif->wl;\n\n\tmutex_lock(&wl->mutex);\n\n\tif (!test_bit(WLVIF_FLAG_RX_STREAMING_STARTED, &wlvif->flags))\n\t\tgoto out;\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl1271_set_rx_streaming(wl, wlvif, false);\n\tif (ret)\n\t\tgoto out_sleep;\n\nout_sleep:\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\nout:\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic void wl1271_rx_streaming_timer(struct timer_list *t)\n{\n\tstruct wl12xx_vif *wlvif = from_timer(wlvif, t, rx_streaming_timer);\n\tstruct wl1271 *wl = wlvif->wl;\n\tieee80211_queue_work(wl->hw, &wlvif->rx_streaming_disable_work);\n}\n\n \nvoid wl12xx_rearm_tx_watchdog_locked(struct wl1271 *wl)\n{\n\t \n\tif (wl->tx_allocated_blocks == 0)\n\t\treturn;\n\n\tcancel_delayed_work(&wl->tx_watchdog_work);\n\tieee80211_queue_delayed_work(wl->hw, &wl->tx_watchdog_work,\n\t\tmsecs_to_jiffies(wl->conf.tx.tx_watchdog_timeout));\n}\n\nstatic void wlcore_rc_update_work(struct work_struct *work)\n{\n\tint ret;\n\tstruct wl12xx_vif *wlvif = container_of(work, struct wl12xx_vif,\n\t\t\t\t\t\trc_update_work);\n\tstruct wl1271 *wl = wlvif->wl;\n\tstruct ieee80211_vif *vif = wl12xx_wlvif_to_vif(wlvif);\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON))\n\t\tgoto out;\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ieee80211_vif_is_mesh(vif)) {\n\t\tret = wl1271_acx_set_ht_capabilities(wl, &wlvif->rc_ht_cap,\n\t\t\t\t\t\t     true, wlvif->sta.hlid);\n\t\tif (ret < 0)\n\t\t\tgoto out_sleep;\n\t} else {\n\t\twlcore_hw_sta_rc_update(wl, wlvif);\n\t}\n\nout_sleep:\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\nout:\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic void wl12xx_tx_watchdog_work(struct work_struct *work)\n{\n\tstruct delayed_work *dwork;\n\tstruct wl1271 *wl;\n\n\tdwork = to_delayed_work(work);\n\twl = container_of(dwork, struct wl1271, tx_watchdog_work);\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON))\n\t\tgoto out;\n\n\t \n\tif (unlikely(wl->tx_allocated_blocks == 0))\n\t\tgoto out;\n\n\t \n\tif (find_first_bit(wl->roc_map, WL12XX_MAX_ROLES) < WL12XX_MAX_ROLES) {\n\t\twl1271_debug(DEBUG_TX, \"No Tx (in FW) for %d ms due to ROC\",\n\t\t\t     wl->conf.tx.tx_watchdog_timeout);\n\t\twl12xx_rearm_tx_watchdog_locked(wl);\n\t\tgoto out;\n\t}\n\n\t \n\tif (wl->scan.state != WL1271_SCAN_STATE_IDLE) {\n\t\twl1271_debug(DEBUG_TX, \"No Tx (in FW) for %d ms due to scan\",\n\t\t\t     wl->conf.tx.tx_watchdog_timeout);\n\t\twl12xx_rearm_tx_watchdog_locked(wl);\n\t\tgoto out;\n\t}\n\n\t \n\tif (wl->active_sta_count) {\n\t\twl1271_debug(DEBUG_TX, \"No Tx (in FW) for %d ms. AP has \"\n\t\t\t     \" %d stations\",\n\t\t\t      wl->conf.tx.tx_watchdog_timeout,\n\t\t\t      wl->active_sta_count);\n\t\twl12xx_rearm_tx_watchdog_locked(wl);\n\t\tgoto out;\n\t}\n\n\twl1271_error(\"Tx stuck (in FW) for %d ms. Starting recovery\",\n\t\t     wl->conf.tx.tx_watchdog_timeout);\n\twl12xx_queue_recovery_work(wl);\n\nout:\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic void wlcore_adjust_conf(struct wl1271 *wl)\n{\n\n\tif (fwlog_param) {\n\t\tif (!strcmp(fwlog_param, \"continuous\")) {\n\t\t\twl->conf.fwlog.mode = WL12XX_FWLOG_CONTINUOUS;\n\t\t\twl->conf.fwlog.output = WL12XX_FWLOG_OUTPUT_HOST;\n\t\t} else if (!strcmp(fwlog_param, \"dbgpins\")) {\n\t\t\twl->conf.fwlog.mode = WL12XX_FWLOG_CONTINUOUS;\n\t\t\twl->conf.fwlog.output = WL12XX_FWLOG_OUTPUT_DBG_PINS;\n\t\t} else if (!strcmp(fwlog_param, \"disable\")) {\n\t\t\twl->conf.fwlog.mem_blocks = 0;\n\t\t\twl->conf.fwlog.output = WL12XX_FWLOG_OUTPUT_NONE;\n\t\t} else {\n\t\t\twl1271_error(\"Unknown fwlog parameter %s\", fwlog_param);\n\t\t}\n\t}\n\n\tif (bug_on_recovery != -1)\n\t\twl->conf.recovery.bug_on_recovery = (u8) bug_on_recovery;\n\n\tif (no_recovery != -1)\n\t\twl->conf.recovery.no_recovery = (u8) no_recovery;\n}\n\nstatic void wl12xx_irq_ps_regulate_link(struct wl1271 *wl,\n\t\t\t\t\tstruct wl12xx_vif *wlvif,\n\t\t\t\t\tu8 hlid, u8 tx_pkts)\n{\n\tbool fw_ps;\n\n\tfw_ps = test_bit(hlid, &wl->ap_fw_ps_map);\n\n\t \n\tif (!fw_ps || tx_pkts < WL1271_PS_STA_MAX_PACKETS)\n\t\twl12xx_ps_link_end(wl, wlvif, hlid);\n\n\t \n\telse if (wl->active_link_count > (wl->ap_count*2 + 1) && fw_ps &&\n\t\t tx_pkts >= WL1271_PS_STA_MAX_PACKETS)\n\t\twl12xx_ps_link_start(wl, wlvif, hlid, true);\n}\n\nstatic void wl12xx_irq_update_links_status(struct wl1271 *wl,\n\t\t\t\t\t   struct wl12xx_vif *wlvif,\n\t\t\t\t\t   struct wl_fw_status *status)\n{\n\tunsigned long cur_fw_ps_map;\n\tu8 hlid;\n\n\tcur_fw_ps_map = status->link_ps_bitmap;\n\tif (wl->ap_fw_ps_map != cur_fw_ps_map) {\n\t\twl1271_debug(DEBUG_PSM,\n\t\t\t     \"link ps prev 0x%lx cur 0x%lx changed 0x%lx\",\n\t\t\t     wl->ap_fw_ps_map, cur_fw_ps_map,\n\t\t\t     wl->ap_fw_ps_map ^ cur_fw_ps_map);\n\n\t\twl->ap_fw_ps_map = cur_fw_ps_map;\n\t}\n\n\tfor_each_set_bit(hlid, wlvif->ap.sta_hlid_map, wl->num_links)\n\t\twl12xx_irq_ps_regulate_link(wl, wlvif, hlid,\n\t\t\t\t\t    wl->links[hlid].allocated_pkts);\n}\n\nstatic int wlcore_fw_status(struct wl1271 *wl, struct wl_fw_status *status)\n{\n\tstruct wl12xx_vif *wlvif;\n\tu32 old_tx_blk_count = wl->tx_blocks_available;\n\tint avail, freed_blocks;\n\tint i;\n\tint ret;\n\tstruct wl1271_link *lnk;\n\n\tret = wlcore_raw_read_data(wl, REG_RAW_FW_STATUS_ADDR,\n\t\t\t\t   wl->raw_fw_status,\n\t\t\t\t   wl->fw_status_len, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twlcore_hw_convert_fw_status(wl, wl->raw_fw_status, wl->fw_status);\n\n\twl1271_debug(DEBUG_IRQ, \"intr: 0x%x (fw_rx_counter = %d, \"\n\t\t     \"drv_rx_counter = %d, tx_results_counter = %d)\",\n\t\t     status->intr,\n\t\t     status->fw_rx_counter,\n\t\t     status->drv_rx_counter,\n\t\t     status->tx_results_counter);\n\n\tfor (i = 0; i < NUM_TX_QUEUES; i++) {\n\t\t \n\t\twl->tx_allocated_pkts[i] -=\n\t\t\t\t(status->counters.tx_released_pkts[i] -\n\t\t\t\twl->tx_pkts_freed[i]) & 0xff;\n\n\t\twl->tx_pkts_freed[i] = status->counters.tx_released_pkts[i];\n\t}\n\n\n\tfor_each_set_bit(i, wl->links_map, wl->num_links) {\n\t\tu8 diff;\n\t\tlnk = &wl->links[i];\n\n\t\t \n\t\tdiff = (status->counters.tx_lnk_free_pkts[i] -\n\t\t       lnk->prev_freed_pkts) & 0xff;\n\n\t\tif (diff == 0)\n\t\t\tcontinue;\n\n\t\tlnk->allocated_pkts -= diff;\n\t\tlnk->prev_freed_pkts = status->counters.tx_lnk_free_pkts[i];\n\n\t\t \n\t\tlnk->total_freed_pkts += diff;\n\t}\n\n\t \n\tif (likely(wl->tx_blocks_freed <= status->total_released_blks))\n\t\tfreed_blocks = status->total_released_blks -\n\t\t\t       wl->tx_blocks_freed;\n\telse\n\t\tfreed_blocks = 0x100000000LL - wl->tx_blocks_freed +\n\t\t\t       status->total_released_blks;\n\n\twl->tx_blocks_freed = status->total_released_blks;\n\n\twl->tx_allocated_blocks -= freed_blocks;\n\n\t \n\tif (freed_blocks) {\n\t\tif (wl->tx_allocated_blocks)\n\t\t\twl12xx_rearm_tx_watchdog_locked(wl);\n\t\telse\n\t\t\tcancel_delayed_work(&wl->tx_watchdog_work);\n\t}\n\n\tavail = status->tx_total - wl->tx_allocated_blocks;\n\n\t \n\twl->tx_blocks_available = max((int)wl->tx_blocks_available,\n\t\t\t\t      avail);\n\n\t \n\tif (wl->tx_blocks_available > old_tx_blk_count)\n\t\tclear_bit(WL1271_FLAG_FW_TX_BUSY, &wl->flags);\n\n\t \n\twl12xx_for_each_wlvif_ap(wl, wlvif) {\n\t\twl12xx_irq_update_links_status(wl, wlvif, status);\n\t}\n\n\t \n\twl->time_offset = (ktime_get_boottime_ns() >> 10) -\n\t\t(s64)(status->fw_localtime);\n\n\twl->fw_fast_lnk_map = status->link_fast_bitmap;\n\n\treturn 0;\n}\n\nstatic void wl1271_flush_deferred_work(struct wl1271 *wl)\n{\n\tstruct sk_buff *skb;\n\n\t \n\twhile ((skb = skb_dequeue(&wl->deferred_rx_queue)))\n\t\tieee80211_rx_ni(wl->hw, skb);\n\n\t \n\twhile ((skb = skb_dequeue(&wl->deferred_tx_queue)))\n\t\tieee80211_tx_status_ni(wl->hw, skb);\n}\n\nstatic void wl1271_netstack_work(struct work_struct *work)\n{\n\tstruct wl1271 *wl =\n\t\tcontainer_of(work, struct wl1271, netstack_work);\n\n\tdo {\n\t\twl1271_flush_deferred_work(wl);\n\t} while (skb_queue_len(&wl->deferred_rx_queue));\n}\n\n#define WL1271_IRQ_MAX_LOOPS 256\n\nstatic int wlcore_irq_locked(struct wl1271 *wl)\n{\n\tint ret = 0;\n\tu32 intr;\n\tint loopcount = WL1271_IRQ_MAX_LOOPS;\n\tbool run_tx_queue = true;\n\tbool done = false;\n\tunsigned int defer_count;\n\tunsigned long flags;\n\n\t \n\tif (wl->irq_flags & (IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING))\n\t\tloopcount = 1;\n\n\twl1271_debug(DEBUG_IRQ, \"IRQ work\");\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON))\n\t\tgoto out;\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (!done && loopcount--) {\n\t\tsmp_mb__after_atomic();\n\n\t\tret = wlcore_fw_status(wl, wl->fw_status);\n\t\tif (ret < 0)\n\t\t\tgoto err_ret;\n\n\t\twlcore_hw_tx_immediate_compl(wl);\n\n\t\tintr = wl->fw_status->intr;\n\t\tintr &= WLCORE_ALL_INTR_MASK;\n\t\tif (!intr) {\n\t\t\tdone = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (unlikely(intr & WL1271_ACX_INTR_WATCHDOG)) {\n\t\t\twl1271_error(\"HW watchdog interrupt received! starting recovery.\");\n\t\t\twl->watchdog_recovery = true;\n\t\t\tret = -EIO;\n\n\t\t\t \n\t\t\tgoto err_ret;\n\t\t}\n\n\t\tif (unlikely(intr & WL1271_ACX_SW_INTR_WATCHDOG)) {\n\t\t\twl1271_error(\"SW watchdog interrupt received! \"\n\t\t\t\t     \"starting recovery.\");\n\t\t\twl->watchdog_recovery = true;\n\t\t\tret = -EIO;\n\n\t\t\t \n\t\t\tgoto err_ret;\n\t\t}\n\n\t\tif (likely(intr & WL1271_ACX_INTR_DATA)) {\n\t\t\twl1271_debug(DEBUG_IRQ, \"WL1271_ACX_INTR_DATA\");\n\n\t\t\tret = wlcore_rx(wl, wl->fw_status);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err_ret;\n\n\t\t\t \n\t\t\tif (!test_bit(WL1271_FLAG_FW_TX_BUSY, &wl->flags)) {\n\t\t\t\tif (spin_trylock_irqsave(&wl->wl_lock, flags)) {\n\t\t\t\t\tif (!wl1271_tx_total_queue_count(wl))\n\t\t\t\t\t\trun_tx_queue = false;\n\t\t\t\t\tspin_unlock_irqrestore(&wl->wl_lock, flags);\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (run_tx_queue) {\n\t\t\t\t\tret = wlcore_tx_work_locked(wl);\n\t\t\t\t\tif (ret < 0)\n\t\t\t\t\t\tgoto err_ret;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tret = wlcore_hw_tx_delayed_compl(wl);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err_ret;\n\n\t\t\t \n\t\t\tdefer_count = skb_queue_len(&wl->deferred_tx_queue) +\n\t\t\t\t      skb_queue_len(&wl->deferred_rx_queue);\n\t\t\tif (defer_count > WL1271_DEFERRED_QUEUE_LIMIT)\n\t\t\t\twl1271_flush_deferred_work(wl);\n\t\t}\n\n\t\tif (intr & WL1271_ACX_INTR_EVENT_A) {\n\t\t\twl1271_debug(DEBUG_IRQ, \"WL1271_ACX_INTR_EVENT_A\");\n\t\t\tret = wl1271_event_handle(wl, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err_ret;\n\t\t}\n\n\t\tif (intr & WL1271_ACX_INTR_EVENT_B) {\n\t\t\twl1271_debug(DEBUG_IRQ, \"WL1271_ACX_INTR_EVENT_B\");\n\t\t\tret = wl1271_event_handle(wl, 1);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err_ret;\n\t\t}\n\n\t\tif (intr & WL1271_ACX_INTR_INIT_COMPLETE)\n\t\t\twl1271_debug(DEBUG_IRQ,\n\t\t\t\t     \"WL1271_ACX_INTR_INIT_COMPLETE\");\n\n\t\tif (intr & WL1271_ACX_INTR_HW_AVAILABLE)\n\t\t\twl1271_debug(DEBUG_IRQ, \"WL1271_ACX_INTR_HW_AVAILABLE\");\n\t}\n\nerr_ret:\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\n\nout:\n\treturn ret;\n}\n\nstatic irqreturn_t wlcore_irq(int irq, void *cookie)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct wl1271 *wl = cookie;\n\tbool queue_tx_work = true;\n\n\tset_bit(WL1271_FLAG_IRQ_RUNNING, &wl->flags);\n\n\t \n\tif (test_bit(WL1271_FLAG_IN_ELP, &wl->flags)) {\n\t\tspin_lock_irqsave(&wl->wl_lock, flags);\n\t\tif (wl->elp_compl)\n\t\t\tcomplete(wl->elp_compl);\n\t\tspin_unlock_irqrestore(&wl->wl_lock, flags);\n\t}\n\n\tif (test_bit(WL1271_FLAG_SUSPENDED, &wl->flags)) {\n\t\t \n\t\tset_bit(WL1271_FLAG_PENDING_WORK, &wl->flags);\n\t\twl1271_debug(DEBUG_IRQ, \"should not enqueue work\");\n\t\tspin_lock_irqsave(&wl->wl_lock, flags);\n\t\tdisable_irq_nosync(wl->irq);\n\t\tpm_wakeup_event(wl->dev, 0);\n\t\tspin_unlock_irqrestore(&wl->wl_lock, flags);\n\t\tgoto out_handled;\n\t}\n\n\t \n\tset_bit(WL1271_FLAG_TX_PENDING, &wl->flags);\n\tcancel_work_sync(&wl->tx_work);\n\n\tmutex_lock(&wl->mutex);\n\n\tret = wlcore_irq_locked(wl);\n\tif (ret)\n\t\twl12xx_queue_recovery_work(wl);\n\n\t \n\tclear_bit(WL1271_FLAG_TX_PENDING, &wl->flags);\n\tif (!test_bit(WL1271_FLAG_FW_TX_BUSY, &wl->flags)) {\n\t\tif (spin_trylock_irqsave(&wl->wl_lock, flags)) {\n\t\t\tif (!wl1271_tx_total_queue_count(wl))\n\t\t\t\tqueue_tx_work = false;\n\t\t\tspin_unlock_irqrestore(&wl->wl_lock, flags);\n\t\t}\n\t\tif (queue_tx_work)\n\t\t\tieee80211_queue_work(wl->hw, &wl->tx_work);\n\t}\n\n\tmutex_unlock(&wl->mutex);\n\nout_handled:\n\tclear_bit(WL1271_FLAG_IRQ_RUNNING, &wl->flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstruct vif_counter_data {\n\tu8 counter;\n\n\tstruct ieee80211_vif *cur_vif;\n\tbool cur_vif_running;\n};\n\nstatic void wl12xx_vif_count_iter(void *data, u8 *mac,\n\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct vif_counter_data *counter = data;\n\n\tcounter->counter++;\n\tif (counter->cur_vif == vif)\n\t\tcounter->cur_vif_running = true;\n}\n\n \nstatic void wl12xx_get_vif_count(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *cur_vif,\n\t\t\t       struct vif_counter_data *data)\n{\n\tmemset(data, 0, sizeof(*data));\n\tdata->cur_vif = cur_vif;\n\n\tieee80211_iterate_active_interfaces(hw, IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\t\t\t    wl12xx_vif_count_iter, data);\n}\n\nstatic int wl12xx_fetch_firmware(struct wl1271 *wl, bool plt)\n{\n\tconst struct firmware *fw;\n\tconst char *fw_name;\n\tenum wl12xx_fw_type fw_type;\n\tint ret;\n\n\tif (plt) {\n\t\tfw_type = WL12XX_FW_TYPE_PLT;\n\t\tfw_name = wl->plt_fw_name;\n\t} else {\n\t\t \n\t\tif (wl->last_vif_count > 1 && wl->mr_fw_name) {\n\t\t\tfw_type = WL12XX_FW_TYPE_MULTI;\n\t\t\tfw_name = wl->mr_fw_name;\n\t\t} else {\n\t\t\tfw_type = WL12XX_FW_TYPE_NORMAL;\n\t\t\tfw_name = wl->sr_fw_name;\n\t\t}\n\t}\n\n\tif (wl->fw_type == fw_type)\n\t\treturn 0;\n\n\twl1271_debug(DEBUG_BOOT, \"booting firmware %s\", fw_name);\n\n\tret = request_firmware(&fw, fw_name, wl->dev);\n\n\tif (ret < 0) {\n\t\twl1271_error(\"could not get firmware %s: %d\", fw_name, ret);\n\t\treturn ret;\n\t}\n\n\tif (fw->size % 4) {\n\t\twl1271_error(\"firmware size is not multiple of 32 bits: %zu\",\n\t\t\t     fw->size);\n\t\tret = -EILSEQ;\n\t\tgoto out;\n\t}\n\n\tvfree(wl->fw);\n\twl->fw_type = WL12XX_FW_TYPE_NONE;\n\twl->fw_len = fw->size;\n\twl->fw = vmalloc(wl->fw_len);\n\n\tif (!wl->fw) {\n\t\twl1271_error(\"could not allocate memory for the firmware\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemcpy(wl->fw, fw->data, wl->fw_len);\n\tret = 0;\n\twl->fw_type = fw_type;\nout:\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\nvoid wl12xx_queue_recovery_work(struct wl1271 *wl)\n{\n\t \n\tif (wl->state == WLCORE_STATE_ON) {\n\t\tWARN_ON(!test_bit(WL1271_FLAG_INTENDED_FW_RECOVERY,\n\t\t\t\t  &wl->flags));\n\n\t\twl->state = WLCORE_STATE_RESTARTING;\n\t\tset_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS, &wl->flags);\n\t\tieee80211_queue_work(wl->hw, &wl->recovery_work);\n\t}\n}\n\nsize_t wl12xx_copy_fwlog(struct wl1271 *wl, u8 *memblock, size_t maxlen)\n{\n\tsize_t len;\n\n\t \n\tlen = min_t(size_t, maxlen, PAGE_SIZE - wl->fwlog_size);\n\n\t \n\tmemcpy(wl->fwlog + wl->fwlog_size, memblock, len);\n\twl->fwlog_size += len;\n\n\treturn len;\n}\n\nstatic void wl12xx_read_fwlog_panic(struct wl1271 *wl)\n{\n\tu32 end_of_log = 0;\n\tint error;\n\n\tif (wl->quirks & WLCORE_QUIRK_FWLOG_NOT_IMPLEMENTED)\n\t\treturn;\n\n\twl1271_info(\"Reading FW panic log\");\n\n\t \n\terror = pm_runtime_resume_and_get(wl->dev);\n\tif (error < 0)\n\t\treturn;\n\tif (!wl->watchdog_recovery &&\n\t    wl->conf.fwlog.output != WL12XX_FWLOG_OUTPUT_DBG_PINS)\n\t\twl12xx_cmd_stop_fwlog(wl);\n\n\t \n\tdo {\n\t\tend_of_log = wlcore_event_fw_logger(wl);\n\t\tif (end_of_log == 0) {\n\t\t\tmsleep(100);\n\t\t\tend_of_log = wlcore_event_fw_logger(wl);\n\t\t}\n\t} while (end_of_log != 0);\n}\n\nstatic void wlcore_save_freed_pkts(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t\t   u8 hlid, struct ieee80211_sta *sta)\n{\n\tstruct wl1271_station *wl_sta;\n\tu32 sqn_recovery_padding = WL1271_TX_SQN_POST_RECOVERY_PADDING;\n\n\twl_sta = (void *)sta->drv_priv;\n\twl_sta->total_freed_pkts = wl->links[hlid].total_freed_pkts;\n\n\t \n\tif (wlvif->encryption_type == KEY_GEM)\n\t\tsqn_recovery_padding = WL1271_TX_SQN_POST_RECOVERY_PADDING_GEM;\n\n\tif (test_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS, &wl->flags))\n\t\twl_sta->total_freed_pkts += sqn_recovery_padding;\n}\n\nstatic void wlcore_save_freed_pkts_addr(struct wl1271 *wl,\n\t\t\t\t\tstruct wl12xx_vif *wlvif,\n\t\t\t\t\tu8 hlid, const u8 *addr)\n{\n\tstruct ieee80211_sta *sta;\n\tstruct ieee80211_vif *vif = wl12xx_wlvif_to_vif(wlvif);\n\n\tif (WARN_ON(hlid == WL12XX_INVALID_LINK_ID ||\n\t\t    is_zero_ether_addr(addr)))\n\t\treturn;\n\n\trcu_read_lock();\n\tsta = ieee80211_find_sta(vif, addr);\n\tif (sta)\n\t\twlcore_save_freed_pkts(wl, wlvif, hlid, sta);\n\trcu_read_unlock();\n}\n\nstatic void wlcore_print_recovery(struct wl1271 *wl)\n{\n\tu32 pc = 0;\n\tu32 hint_sts = 0;\n\tint ret;\n\n\twl1271_info(\"Hardware recovery in progress. FW ver: %s\",\n\t\t    wl->chip.fw_ver_str);\n\n\t \n\tret = wlcore_set_partition(wl, &wl->ptable[PART_BOOT]);\n\tif (ret < 0)\n\t\treturn;\n\n\tret = wlcore_read_reg(wl, REG_PC_ON_RECOVERY, &pc);\n\tif (ret < 0)\n\t\treturn;\n\n\tret = wlcore_read_reg(wl, REG_INTERRUPT_NO_CLEAR, &hint_sts);\n\tif (ret < 0)\n\t\treturn;\n\n\twl1271_info(\"pc: 0x%x, hint_sts: 0x%08x count: %d\",\n\t\t\t\tpc, hint_sts, ++wl->recovery_count);\n\n\twlcore_set_partition(wl, &wl->ptable[PART_WORK]);\n}\n\n\nstatic void wl1271_recovery_work(struct work_struct *work)\n{\n\tstruct wl1271 *wl =\n\t\tcontainer_of(work, struct wl1271, recovery_work);\n\tstruct wl12xx_vif *wlvif;\n\tstruct ieee80211_vif *vif;\n\tint error;\n\n\tmutex_lock(&wl->mutex);\n\n\tif (wl->state == WLCORE_STATE_OFF || wl->plt)\n\t\tgoto out_unlock;\n\n\terror = pm_runtime_resume_and_get(wl->dev);\n\tif (error < 0)\n\t\twl1271_warning(\"Enable for recovery failed\");\n\twlcore_disable_interrupts_nosync(wl);\n\n\tif (!test_bit(WL1271_FLAG_INTENDED_FW_RECOVERY, &wl->flags)) {\n\t\tif (wl->conf.fwlog.output == WL12XX_FWLOG_OUTPUT_HOST)\n\t\t\twl12xx_read_fwlog_panic(wl);\n\t\twlcore_print_recovery(wl);\n\t}\n\n\tBUG_ON(wl->conf.recovery.bug_on_recovery &&\n\t       !test_bit(WL1271_FLAG_INTENDED_FW_RECOVERY, &wl->flags));\n\n\tclear_bit(WL1271_FLAG_INTENDED_FW_RECOVERY, &wl->flags);\n\n\tif (wl->conf.recovery.no_recovery) {\n\t\twl1271_info(\"No recovery (chosen on module load). Fw will remain stuck.\");\n\t\tgoto out_unlock;\n\t}\n\n\t \n\twlcore_stop_queues(wl, WLCORE_QUEUE_STOP_REASON_FW_RESTART);\n\n\t \n\twhile (!list_empty(&wl->wlvif_list)) {\n\t\twlvif = list_first_entry(&wl->wlvif_list,\n\t\t\t\t       struct wl12xx_vif, list);\n\t\tvif = wl12xx_wlvif_to_vif(wlvif);\n\n\t\tif (wlvif->bss_type == BSS_TYPE_STA_BSS &&\n\t\t    test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags)) {\n\t\t\twlcore_save_freed_pkts_addr(wl, wlvif, wlvif->sta.hlid,\n\t\t\t\t\t\t    vif->bss_conf.bssid);\n\t\t}\n\n\t\t__wl1271_op_remove_interface(wl, vif, false);\n\t}\n\n\twlcore_op_stop_locked(wl);\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\n\n\tieee80211_restart_hw(wl->hw);\n\n\t \n\twlcore_wake_queues(wl, WLCORE_QUEUE_STOP_REASON_FW_RESTART);\n\nout_unlock:\n\twl->watchdog_recovery = false;\n\tclear_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS, &wl->flags);\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic int wlcore_fw_wakeup(struct wl1271 *wl)\n{\n\treturn wlcore_raw_write32(wl, HW_ACCESS_ELP_CTRL_REG, ELPCTRL_WAKE_UP);\n}\n\nstatic int wl1271_setup(struct wl1271 *wl)\n{\n\twl->raw_fw_status = kzalloc(wl->fw_status_len, GFP_KERNEL);\n\tif (!wl->raw_fw_status)\n\t\tgoto err;\n\n\twl->fw_status = kzalloc(sizeof(*wl->fw_status), GFP_KERNEL);\n\tif (!wl->fw_status)\n\t\tgoto err;\n\n\twl->tx_res_if = kzalloc(sizeof(*wl->tx_res_if), GFP_KERNEL);\n\tif (!wl->tx_res_if)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tkfree(wl->fw_status);\n\tkfree(wl->raw_fw_status);\n\treturn -ENOMEM;\n}\n\nstatic int wl12xx_set_power_on(struct wl1271 *wl)\n{\n\tint ret;\n\n\tmsleep(WL1271_PRE_POWER_ON_SLEEP);\n\tret = wl1271_power_on(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\tmsleep(WL1271_POWER_ON_SLEEP);\n\twl1271_io_reset(wl);\n\twl1271_io_init(wl);\n\n\tret = wlcore_set_partition(wl, &wl->ptable[PART_BOOT]);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\t \n\tret = wlcore_fw_wakeup(wl);\n\tif (ret < 0)\n\t\tgoto fail;\n\nout:\n\treturn ret;\n\nfail:\n\twl1271_power_off(wl);\n\treturn ret;\n}\n\nstatic int wl12xx_chip_wakeup(struct wl1271 *wl, bool plt)\n{\n\tint ret = 0;\n\n\tret = wl12xx_set_power_on(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tif (!wl1271_set_block_size(wl))\n\t\twl->quirks &= ~WLCORE_QUIRK_TX_BLOCKSIZE_ALIGN;\n\n\t \n\n\tret = wl1271_setup(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl12xx_fetch_firmware(wl, plt);\n\tif (ret < 0) {\n\t\tkfree(wl->fw_status);\n\t\tkfree(wl->raw_fw_status);\n\t\tkfree(wl->tx_res_if);\n\t}\n\nout:\n\treturn ret;\n}\n\nint wl1271_plt_start(struct wl1271 *wl, const enum plt_mode plt_mode)\n{\n\tint retries = WL1271_BOOT_RETRIES;\n\tstruct wiphy *wiphy = wl->hw->wiphy;\n\n\tstatic const char* const PLT_MODE[] = {\n\t\t\"PLT_OFF\",\n\t\t\"PLT_ON\",\n\t\t\"PLT_FEM_DETECT\",\n\t\t\"PLT_CHIP_AWAKE\"\n\t};\n\n\tint ret;\n\n\tmutex_lock(&wl->mutex);\n\n\twl1271_notice(\"power up\");\n\n\tif (wl->state != WLCORE_STATE_OFF) {\n\t\twl1271_error(\"cannot go into PLT state because not \"\n\t\t\t     \"in off state: %d\", wl->state);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\twl->plt = true;\n\twl->plt_mode = plt_mode;\n\n\twhile (retries) {\n\t\tretries--;\n\t\tret = wl12xx_chip_wakeup(wl, true);\n\t\tif (ret < 0)\n\t\t\tgoto power_off;\n\n\t\tif (plt_mode != PLT_CHIP_AWAKE) {\n\t\t\tret = wl->ops->plt_init(wl);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto power_off;\n\t\t}\n\n\t\twl->state = WLCORE_STATE_ON;\n\t\twl1271_notice(\"firmware booted in PLT mode %s (%s)\",\n\t\t\t      PLT_MODE[plt_mode],\n\t\t\t      wl->chip.fw_ver_str);\n\n\t\t \n\t\twiphy->hw_version = wl->chip.id;\n\t\tstrncpy(wiphy->fw_version, wl->chip.fw_ver_str,\n\t\t\tsizeof(wiphy->fw_version));\n\n\t\tgoto out;\n\npower_off:\n\t\twl1271_power_off(wl);\n\t}\n\n\twl->plt = false;\n\twl->plt_mode = PLT_OFF;\n\n\twl1271_error(\"firmware boot in PLT mode failed despite %d retries\",\n\t\t     WL1271_BOOT_RETRIES);\nout:\n\tmutex_unlock(&wl->mutex);\n\n\treturn ret;\n}\n\nint wl1271_plt_stop(struct wl1271 *wl)\n{\n\tint ret = 0;\n\n\twl1271_notice(\"power down\");\n\n\t \n\twlcore_disable_interrupts(wl);\n\tmutex_lock(&wl->mutex);\n\tif (!wl->plt) {\n\t\tmutex_unlock(&wl->mutex);\n\n\t\t \n\t\twlcore_enable_interrupts(wl);\n\n\t\twl1271_error(\"cannot power down because not in PLT \"\n\t\t\t     \"state: %d\", wl->state);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tmutex_unlock(&wl->mutex);\n\n\twl1271_flush_deferred_work(wl);\n\tcancel_work_sync(&wl->netstack_work);\n\tcancel_work_sync(&wl->recovery_work);\n\tcancel_delayed_work_sync(&wl->tx_watchdog_work);\n\n\tmutex_lock(&wl->mutex);\n\twl1271_power_off(wl);\n\twl->flags = 0;\n\twl->sleep_auth = WL1271_PSM_ILLEGAL;\n\twl->state = WLCORE_STATE_OFF;\n\twl->plt = false;\n\twl->plt_mode = PLT_OFF;\n\twl->rx_counter = 0;\n\tmutex_unlock(&wl->mutex);\n\nout:\n\treturn ret;\n}\n\nstatic void wl1271_op_tx(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_tx_control *control,\n\t\t\t struct sk_buff *skb)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_vif *vif = info->control.vif;\n\tstruct wl12xx_vif *wlvif = NULL;\n\tunsigned long flags;\n\tint q, mapping;\n\tu8 hlid;\n\n\tif (!vif) {\n\t\twl1271_debug(DEBUG_TX, \"DROP skb with no vif\");\n\t\tieee80211_free_txskb(hw, skb);\n\t\treturn;\n\t}\n\n\twlvif = wl12xx_vif_to_data(vif);\n\tmapping = skb_get_queue_mapping(skb);\n\tq = wl1271_tx_get_queue(mapping);\n\n\thlid = wl12xx_tx_get_hlid(wl, wlvif, skb, control->sta);\n\n\tspin_lock_irqsave(&wl->wl_lock, flags);\n\n\t \n\tif (hlid == WL12XX_INVALID_LINK_ID ||\n\t    (!test_bit(hlid, wlvif->links_map)) ||\n\t     (wlcore_is_queue_stopped_locked(wl, wlvif, q) &&\n\t      !wlcore_is_queue_stopped_by_reason_locked(wl, wlvif, q,\n\t\t\tWLCORE_QUEUE_STOP_REASON_WATERMARK))) {\n\t\twl1271_debug(DEBUG_TX, \"DROP skb hlid %d q %d\", hlid, q);\n\t\tieee80211_free_txskb(hw, skb);\n\t\tgoto out;\n\t}\n\n\twl1271_debug(DEBUG_TX, \"queue skb hlid %d q %d len %d\",\n\t\t     hlid, q, skb->len);\n\tskb_queue_tail(&wl->links[hlid].tx_queue[q], skb);\n\n\twl->tx_queue_count[q]++;\n\twlvif->tx_queue_count[q]++;\n\n\t \n\tif (wlvif->tx_queue_count[q] >= WL1271_TX_QUEUE_HIGH_WATERMARK &&\n\t    !wlcore_is_queue_stopped_by_reason_locked(wl, wlvif, q,\n\t\t\t\t\tWLCORE_QUEUE_STOP_REASON_WATERMARK)) {\n\t\twl1271_debug(DEBUG_TX, \"op_tx: stopping queues for q %d\", q);\n\t\twlcore_stop_queue_locked(wl, wlvif, q,\n\t\t\t\t\t WLCORE_QUEUE_STOP_REASON_WATERMARK);\n\t}\n\n\t \n\n\tif (!test_bit(WL1271_FLAG_FW_TX_BUSY, &wl->flags) &&\n\t    !test_bit(WL1271_FLAG_TX_PENDING, &wl->flags))\n\t\tieee80211_queue_work(wl->hw, &wl->tx_work);\n\nout:\n\tspin_unlock_irqrestore(&wl->wl_lock, flags);\n}\n\nint wl1271_tx_dummy_packet(struct wl1271 *wl)\n{\n\tunsigned long flags;\n\tint q;\n\n\t \n\tif (test_bit(WL1271_FLAG_DUMMY_PACKET_PENDING, &wl->flags))\n\t\treturn 0;\n\n\tq = wl1271_tx_get_queue(skb_get_queue_mapping(wl->dummy_packet));\n\n\tspin_lock_irqsave(&wl->wl_lock, flags);\n\tset_bit(WL1271_FLAG_DUMMY_PACKET_PENDING, &wl->flags);\n\twl->tx_queue_count[q]++;\n\tspin_unlock_irqrestore(&wl->wl_lock, flags);\n\n\t \n\tif (!test_bit(WL1271_FLAG_FW_TX_BUSY, &wl->flags))\n\t\treturn wlcore_tx_work_locked(wl);\n\n\t \n\treturn 0;\n}\n\n \n#define TOTAL_TX_DUMMY_PACKET_SIZE (ALIGN(1400, 512))\n\nstatic struct sk_buff *wl12xx_alloc_dummy_packet(struct wl1271 *wl)\n{\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr_3addr *hdr;\n\tunsigned int dummy_packet_size;\n\n\tdummy_packet_size = TOTAL_TX_DUMMY_PACKET_SIZE -\n\t\t\t    sizeof(struct wl1271_tx_hw_descr) - sizeof(*hdr);\n\n\tskb = dev_alloc_skb(TOTAL_TX_DUMMY_PACKET_SIZE);\n\tif (!skb) {\n\t\twl1271_warning(\"Failed to allocate a dummy packet skb\");\n\t\treturn NULL;\n\t}\n\n\tskb_reserve(skb, sizeof(struct wl1271_tx_hw_descr));\n\n\thdr = skb_put_zero(skb, sizeof(*hdr));\n\thdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |\n\t\t\t\t\t IEEE80211_STYPE_NULLFUNC |\n\t\t\t\t\t IEEE80211_FCTL_TODS);\n\n\tskb_put_zero(skb, dummy_packet_size);\n\n\t \n\tskb->priority = WL1271_TID_MGMT;\n\n\t \n\tskb_set_queue_mapping(skb, 0);\n\tmemset(IEEE80211_SKB_CB(skb), 0, sizeof(struct ieee80211_tx_info));\n\n\treturn skb;\n}\n\n\nstatic int\nwl1271_validate_wowlan_pattern(struct cfg80211_pkt_pattern *p)\n{\n\tint num_fields = 0, in_field = 0, fields_size = 0;\n\tint i, pattern_len = 0;\n\n\tif (!p->mask) {\n\t\twl1271_warning(\"No mask in WoWLAN pattern\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < p->pattern_len; i++) {\n\t\tif (test_bit(i, (unsigned long *)p->mask)) {\n\t\t\tif (!in_field) {\n\t\t\t\tin_field = 1;\n\t\t\t\tpattern_len = 1;\n\t\t\t} else {\n\t\t\t\tif (i == WL1271_RX_FILTER_ETH_HEADER_SIZE) {\n\t\t\t\t\tnum_fields++;\n\t\t\t\t\tfields_size += pattern_len +\n\t\t\t\t\t\tRX_FILTER_FIELD_OVERHEAD;\n\t\t\t\t\tpattern_len = 1;\n\t\t\t\t} else\n\t\t\t\t\tpattern_len++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (in_field) {\n\t\t\t\tin_field = 0;\n\t\t\t\tfields_size += pattern_len +\n\t\t\t\t\tRX_FILTER_FIELD_OVERHEAD;\n\t\t\t\tnum_fields++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (in_field) {\n\t\tfields_size += pattern_len + RX_FILTER_FIELD_OVERHEAD;\n\t\tnum_fields++;\n\t}\n\n\tif (num_fields > WL1271_RX_FILTER_MAX_FIELDS) {\n\t\twl1271_warning(\"RX Filter too complex. Too many segments\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (fields_size > WL1271_RX_FILTER_MAX_FIELDS_SIZE) {\n\t\twl1271_warning(\"RX filter pattern is too big\");\n\t\treturn -E2BIG;\n\t}\n\n\treturn 0;\n}\n\nstruct wl12xx_rx_filter *wl1271_rx_filter_alloc(void)\n{\n\treturn kzalloc(sizeof(struct wl12xx_rx_filter), GFP_KERNEL);\n}\n\nvoid wl1271_rx_filter_free(struct wl12xx_rx_filter *filter)\n{\n\tint i;\n\n\tif (filter == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < filter->num_fields; i++)\n\t\tkfree(filter->fields[i].pattern);\n\n\tkfree(filter);\n}\n\nint wl1271_rx_filter_alloc_field(struct wl12xx_rx_filter *filter,\n\t\t\t\t u16 offset, u8 flags,\n\t\t\t\t const u8 *pattern, u8 len)\n{\n\tstruct wl12xx_rx_filter_field *field;\n\n\tif (filter->num_fields == WL1271_RX_FILTER_MAX_FIELDS) {\n\t\twl1271_warning(\"Max fields per RX filter. can't alloc another\");\n\t\treturn -EINVAL;\n\t}\n\n\tfield = &filter->fields[filter->num_fields];\n\n\tfield->pattern = kmemdup(pattern, len, GFP_KERNEL);\n\tif (!field->pattern) {\n\t\twl1271_warning(\"Failed to allocate RX filter pattern\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfilter->num_fields++;\n\n\tfield->offset = cpu_to_le16(offset);\n\tfield->flags = flags;\n\tfield->len = len;\n\n\treturn 0;\n}\n\nint wl1271_rx_filter_get_fields_size(struct wl12xx_rx_filter *filter)\n{\n\tint i, fields_size = 0;\n\n\tfor (i = 0; i < filter->num_fields; i++)\n\t\tfields_size += filter->fields[i].len +\n\t\t\tsizeof(struct wl12xx_rx_filter_field) -\n\t\t\tsizeof(u8 *);\n\n\treturn fields_size;\n}\n\nvoid wl1271_rx_filter_flatten_fields(struct wl12xx_rx_filter *filter,\n\t\t\t\t    u8 *buf)\n{\n\tint i;\n\tstruct wl12xx_rx_filter_field *field;\n\n\tfor (i = 0; i < filter->num_fields; i++) {\n\t\tfield = (struct wl12xx_rx_filter_field *)buf;\n\n\t\tfield->offset = filter->fields[i].offset;\n\t\tfield->flags = filter->fields[i].flags;\n\t\tfield->len = filter->fields[i].len;\n\n\t\tmemcpy(&field->pattern, filter->fields[i].pattern, field->len);\n\t\tbuf += sizeof(struct wl12xx_rx_filter_field) -\n\t\t\tsizeof(u8 *) + field->len;\n\t}\n}\n\n \nstatic int\nwl1271_convert_wowlan_pattern_to_rx_filter(struct cfg80211_pkt_pattern *p,\n\t\t\t\t\t   struct wl12xx_rx_filter **f)\n{\n\tint i, j, ret = 0;\n\tstruct wl12xx_rx_filter *filter;\n\tu16 offset;\n\tu8 flags, len;\n\n\tfilter = wl1271_rx_filter_alloc();\n\tif (!filter) {\n\t\twl1271_warning(\"Failed to alloc rx filter\");\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\ti = 0;\n\twhile (i < p->pattern_len) {\n\t\tif (!test_bit(i, (unsigned long *)p->mask)) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = i; j < p->pattern_len; j++) {\n\t\t\tif (!test_bit(j, (unsigned long *)p->mask))\n\t\t\t\tbreak;\n\n\t\t\tif (i < WL1271_RX_FILTER_ETH_HEADER_SIZE &&\n\t\t\t    j >= WL1271_RX_FILTER_ETH_HEADER_SIZE)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i < WL1271_RX_FILTER_ETH_HEADER_SIZE) {\n\t\t\toffset = i;\n\t\t\tflags = WL1271_RX_FILTER_FLAG_ETHERNET_HEADER;\n\t\t} else {\n\t\t\toffset = i - WL1271_RX_FILTER_ETH_HEADER_SIZE;\n\t\t\tflags = WL1271_RX_FILTER_FLAG_IP_HEADER;\n\t\t}\n\n\t\tlen = j - i;\n\n\t\tret = wl1271_rx_filter_alloc_field(filter,\n\t\t\t\t\t\t   offset,\n\t\t\t\t\t\t   flags,\n\t\t\t\t\t\t   &p->pattern[i], len);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\ti = j;\n\t}\n\n\tfilter->action = FILTER_SIGNAL;\n\n\t*f = filter;\n\treturn 0;\n\nerr:\n\twl1271_rx_filter_free(filter);\n\t*f = NULL;\n\n\treturn ret;\n}\n\nstatic int wl1271_configure_wowlan(struct wl1271 *wl,\n\t\t\t\t   struct cfg80211_wowlan *wow)\n{\n\tint i, ret;\n\n\tif (!wow || wow->any || !wow->n_patterns) {\n\t\tret = wl1271_acx_default_rx_filter_enable(wl, 0,\n\t\t\t\t\t\t\t  FILTER_SIGNAL);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = wl1271_rx_filter_clear_all(wl);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\treturn 0;\n\t}\n\n\tif (WARN_ON(wow->n_patterns > WL1271_MAX_RX_FILTERS))\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < wow->n_patterns; i++) {\n\t\tret = wl1271_validate_wowlan_pattern(&wow->patterns[i]);\n\t\tif (ret) {\n\t\t\twl1271_warning(\"Bad wowlan pattern %d\", i);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = wl1271_acx_default_rx_filter_enable(wl, 0, FILTER_SIGNAL);\n\tif (ret)\n\t\tgoto out;\n\n\tret = wl1271_rx_filter_clear_all(wl);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < wow->n_patterns; i++) {\n\t\tstruct cfg80211_pkt_pattern *p;\n\t\tstruct wl12xx_rx_filter *filter = NULL;\n\n\t\tp = &wow->patterns[i];\n\n\t\tret = wl1271_convert_wowlan_pattern_to_rx_filter(p, &filter);\n\t\tif (ret) {\n\t\t\twl1271_warning(\"Failed to create an RX filter from \"\n\t\t\t\t       \"wowlan pattern %d\", i);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = wl1271_rx_filter_enable(wl, i, 1, filter);\n\n\t\twl1271_rx_filter_free(filter);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = wl1271_acx_default_rx_filter_enable(wl, 1, FILTER_DROP);\n\nout:\n\treturn ret;\n}\n\nstatic int wl1271_configure_suspend_sta(struct wl1271 *wl,\n\t\t\t\t\tstruct wl12xx_vif *wlvif,\n\t\t\t\t\tstruct cfg80211_wowlan *wow)\n{\n\tint ret = 0;\n\n\tif (!test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags))\n\t\tgoto out;\n\n\tret = wl1271_configure_wowlan(wl, wow);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif ((wl->conf.conn.suspend_wake_up_event ==\n\t     wl->conf.conn.wake_up_event) &&\n\t    (wl->conf.conn.suspend_listen_interval ==\n\t     wl->conf.conn.listen_interval))\n\t\tgoto out;\n\n\tret = wl1271_acx_wake_up_conditions(wl, wlvif,\n\t\t\t\t    wl->conf.conn.suspend_wake_up_event,\n\t\t\t\t    wl->conf.conn.suspend_listen_interval);\n\n\tif (ret < 0)\n\t\twl1271_error(\"suspend: set wake up conditions failed: %d\", ret);\nout:\n\treturn ret;\n\n}\n\nstatic int wl1271_configure_suspend_ap(struct wl1271 *wl,\n\t\t\t\t\tstruct wl12xx_vif *wlvif,\n\t\t\t\t\tstruct cfg80211_wowlan *wow)\n{\n\tint ret = 0;\n\n\tif (!test_bit(WLVIF_FLAG_AP_STARTED, &wlvif->flags))\n\t\tgoto out;\n\n\tret = wl1271_acx_beacon_filter_opt(wl, wlvif, true);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl1271_configure_wowlan(wl, wow);\n\tif (ret < 0)\n\t\tgoto out;\n\nout:\n\treturn ret;\n\n}\n\nstatic int wl1271_configure_suspend(struct wl1271 *wl,\n\t\t\t\t    struct wl12xx_vif *wlvif,\n\t\t\t\t    struct cfg80211_wowlan *wow)\n{\n\tif (wlvif->bss_type == BSS_TYPE_STA_BSS)\n\t\treturn wl1271_configure_suspend_sta(wl, wlvif, wow);\n\tif (wlvif->bss_type == BSS_TYPE_AP_BSS)\n\t\treturn wl1271_configure_suspend_ap(wl, wlvif, wow);\n\treturn 0;\n}\n\nstatic void wl1271_configure_resume(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tint ret = 0;\n\tbool is_ap = wlvif->bss_type == BSS_TYPE_AP_BSS;\n\tbool is_sta = wlvif->bss_type == BSS_TYPE_STA_BSS;\n\n\tif ((!is_ap) && (!is_sta))\n\t\treturn;\n\n\tif ((is_sta && !test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags)) ||\n\t    (is_ap && !test_bit(WLVIF_FLAG_AP_STARTED, &wlvif->flags)))\n\t\treturn;\n\n\twl1271_configure_wowlan(wl, NULL);\n\n\tif (is_sta) {\n\t\tif ((wl->conf.conn.suspend_wake_up_event ==\n\t\t     wl->conf.conn.wake_up_event) &&\n\t\t    (wl->conf.conn.suspend_listen_interval ==\n\t\t     wl->conf.conn.listen_interval))\n\t\t\treturn;\n\n\t\tret = wl1271_acx_wake_up_conditions(wl, wlvif,\n\t\t\t\t    wl->conf.conn.wake_up_event,\n\t\t\t\t    wl->conf.conn.listen_interval);\n\n\t\tif (ret < 0)\n\t\t\twl1271_error(\"resume: wake up conditions failed: %d\",\n\t\t\t\t     ret);\n\n\t} else if (is_ap) {\n\t\tret = wl1271_acx_beacon_filter_opt(wl, wlvif, false);\n\t}\n}\n\nstatic int __maybe_unused wl1271_op_suspend(struct ieee80211_hw *hw,\n\t\t\t\t\t    struct cfg80211_wowlan *wow)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tstruct wl12xx_vif *wlvif;\n\tunsigned long flags;\n\tint ret;\n\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 suspend wow=%d\", !!wow);\n\tWARN_ON(!wow);\n\n\t \n\tif (test_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS, &wl->flags)) {\n\t\twl1271_warning(\"postponing suspend to perform recovery\");\n\t\treturn -EBUSY;\n\t}\n\n\twl1271_tx_flush(wl);\n\n\tmutex_lock(&wl->mutex);\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0) {\n\t\tmutex_unlock(&wl->mutex);\n\t\treturn ret;\n\t}\n\n\twl->wow_enabled = true;\n\twl12xx_for_each_wlvif(wl, wlvif) {\n\t\tif (wlcore_is_p2p_mgmt(wlvif))\n\t\t\tcontinue;\n\n\t\tret = wl1271_configure_suspend(wl, wlvif, wow);\n\t\tif (ret < 0) {\n\t\t\tgoto out_sleep;\n\t\t}\n\t}\n\n\t \n\tret = wlcore_hw_interrupt_notify(wl, false);\n\tif (ret < 0)\n\t\tgoto out_sleep;\n\n\t \n\tret = wlcore_hw_rx_ba_filter(wl,\n\t\t\t\t     !!wl->conf.conn.suspend_rx_ba_activity);\n\tif (ret < 0)\n\t\tgoto out_sleep;\n\nout_sleep:\n\tpm_runtime_put_noidle(wl->dev);\n\tmutex_unlock(&wl->mutex);\n\n\tif (ret < 0) {\n\t\twl1271_warning(\"couldn't prepare device to suspend\");\n\t\treturn ret;\n\t}\n\n\t \n\twl1271_debug(DEBUG_MAC80211, \"flushing remaining works\");\n\n\tflush_work(&wl->tx_work);\n\n\t \n\tcancel_delayed_work(&wl->tx_watchdog_work);\n\n\t \n\tspin_lock_irqsave(&wl->wl_lock, flags);\n\tset_bit(WL1271_FLAG_SUSPENDED, &wl->flags);\n\tspin_unlock_irqrestore(&wl->wl_lock, flags);\n\n\treturn pm_runtime_force_suspend(wl->dev);\n}\n\nstatic int __maybe_unused wl1271_op_resume(struct ieee80211_hw *hw)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tstruct wl12xx_vif *wlvif;\n\tunsigned long flags;\n\tbool run_irq_work = false, pending_recovery;\n\tint ret;\n\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 resume wow=%d\",\n\t\t     wl->wow_enabled);\n\tWARN_ON(!wl->wow_enabled);\n\n\tret = pm_runtime_force_resume(wl->dev);\n\tif (ret < 0) {\n\t\twl1271_error(\"ELP wakeup failure!\");\n\t\tgoto out_sleep;\n\t}\n\n\t \n\tspin_lock_irqsave(&wl->wl_lock, flags);\n\tclear_bit(WL1271_FLAG_SUSPENDED, &wl->flags);\n\tif (test_and_clear_bit(WL1271_FLAG_PENDING_WORK, &wl->flags))\n\t\trun_irq_work = true;\n\tspin_unlock_irqrestore(&wl->wl_lock, flags);\n\n\tmutex_lock(&wl->mutex);\n\n\t \n\tpending_recovery = test_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS,\n\t\t\t\t    &wl->flags);\n\n\tif (run_irq_work) {\n\t\twl1271_debug(DEBUG_MAC80211,\n\t\t\t     \"run postponed irq_work directly\");\n\n\t\t \n\t\tif (!pending_recovery) {\n\t\t\tret = wlcore_irq_locked(wl);\n\t\t\tif (ret)\n\t\t\t\twl12xx_queue_recovery_work(wl);\n\t\t}\n\n\t\twlcore_enable_interrupts(wl);\n\t}\n\n\tif (pending_recovery) {\n\t\twl1271_warning(\"queuing forgotten recovery on resume\");\n\t\tieee80211_queue_work(wl->hw, &wl->recovery_work);\n\t\tgoto out_sleep;\n\t}\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twl12xx_for_each_wlvif(wl, wlvif) {\n\t\tif (wlcore_is_p2p_mgmt(wlvif))\n\t\t\tcontinue;\n\n\t\twl1271_configure_resume(wl, wlvif);\n\t}\n\n\tret = wlcore_hw_interrupt_notify(wl, true);\n\tif (ret < 0)\n\t\tgoto out_sleep;\n\n\t \n\tret = wlcore_hw_rx_ba_filter(wl, false);\n\tif (ret < 0)\n\t\tgoto out_sleep;\n\nout_sleep:\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\n\nout:\n\twl->wow_enabled = false;\n\n\t \n\tset_bit(WL1271_FLAG_REINIT_TX_WDOG, &wl->flags);\n\tmutex_unlock(&wl->mutex);\n\n\treturn 0;\n}\n\nstatic int wl1271_op_start(struct ieee80211_hw *hw)\n{\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 start\");\n\n\t \n\n\treturn 0;\n}\n\nstatic void wlcore_op_stop_locked(struct wl1271 *wl)\n{\n\tint i;\n\n\tif (wl->state == WLCORE_STATE_OFF) {\n\t\tif (test_and_clear_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS,\n\t\t\t\t\t&wl->flags))\n\t\t\twlcore_enable_interrupts(wl);\n\n\t\treturn;\n\t}\n\n\t \n\twl->state = WLCORE_STATE_OFF;\n\n\t \n\twlcore_disable_interrupts_nosync(wl);\n\n\tmutex_unlock(&wl->mutex);\n\n\twlcore_synchronize_interrupts(wl);\n\tif (!test_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS, &wl->flags))\n\t\tcancel_work_sync(&wl->recovery_work);\n\twl1271_flush_deferred_work(wl);\n\tcancel_delayed_work_sync(&wl->scan_complete_work);\n\tcancel_work_sync(&wl->netstack_work);\n\tcancel_work_sync(&wl->tx_work);\n\tcancel_delayed_work_sync(&wl->tx_watchdog_work);\n\n\t \n\tmutex_lock(&wl->mutex);\n\twl12xx_tx_reset(wl);\n\n\twl1271_power_off(wl);\n\t \n\tif (test_and_clear_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS, &wl->flags))\n\t\twlcore_enable_interrupts(wl);\n\n\twl->band = NL80211_BAND_2GHZ;\n\n\twl->rx_counter = 0;\n\twl->power_level = WL1271_DEFAULT_POWER_LEVEL;\n\twl->channel_type = NL80211_CHAN_NO_HT;\n\twl->tx_blocks_available = 0;\n\twl->tx_allocated_blocks = 0;\n\twl->tx_results_count = 0;\n\twl->tx_packets_count = 0;\n\twl->time_offset = 0;\n\twl->ap_fw_ps_map = 0;\n\twl->ap_ps_map = 0;\n\twl->sleep_auth = WL1271_PSM_ILLEGAL;\n\tmemset(wl->roles_map, 0, sizeof(wl->roles_map));\n\tmemset(wl->links_map, 0, sizeof(wl->links_map));\n\tmemset(wl->roc_map, 0, sizeof(wl->roc_map));\n\tmemset(wl->session_ids, 0, sizeof(wl->session_ids));\n\tmemset(wl->rx_filter_enabled, 0, sizeof(wl->rx_filter_enabled));\n\twl->active_sta_count = 0;\n\twl->active_link_count = 0;\n\n\t \n\twl->links[WL12XX_SYSTEM_HLID].allocated_pkts = 0;\n\twl->links[WL12XX_SYSTEM_HLID].prev_freed_pkts = 0;\n\t__set_bit(WL12XX_SYSTEM_HLID, wl->links_map);\n\n\t \n\twl->flags = 0;\n\n\twl->tx_blocks_freed = 0;\n\n\tfor (i = 0; i < NUM_TX_QUEUES; i++) {\n\t\twl->tx_pkts_freed[i] = 0;\n\t\twl->tx_allocated_pkts[i] = 0;\n\t}\n\n\twl1271_debugfs_reset(wl);\n\n\tkfree(wl->raw_fw_status);\n\twl->raw_fw_status = NULL;\n\tkfree(wl->fw_status);\n\twl->fw_status = NULL;\n\tkfree(wl->tx_res_if);\n\twl->tx_res_if = NULL;\n\tkfree(wl->target_mem_map);\n\twl->target_mem_map = NULL;\n\n\t \n\tmemcpy(wl->reg_ch_conf_pending, wl->reg_ch_conf_last,\n\t       sizeof(wl->reg_ch_conf_pending));\n\tmemset(wl->reg_ch_conf_last, 0, sizeof(wl->reg_ch_conf_last));\n}\n\nstatic void wlcore_op_stop(struct ieee80211_hw *hw)\n{\n\tstruct wl1271 *wl = hw->priv;\n\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 stop\");\n\n\tmutex_lock(&wl->mutex);\n\n\twlcore_op_stop_locked(wl);\n\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic void wlcore_channel_switch_work(struct work_struct *work)\n{\n\tstruct delayed_work *dwork;\n\tstruct wl1271 *wl;\n\tstruct ieee80211_vif *vif;\n\tstruct wl12xx_vif *wlvif;\n\tint ret;\n\n\tdwork = to_delayed_work(work);\n\twlvif = container_of(dwork, struct wl12xx_vif, channel_switch_work);\n\twl = wlvif->wl;\n\n\twl1271_info(\"channel switch failed (role_id: %d).\", wlvif->role_id);\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON))\n\t\tgoto out;\n\n\t \n\tif (!test_and_clear_bit(WLVIF_FLAG_CS_PROGRESS, &wlvif->flags))\n\t\tgoto out;\n\n\tvif = wl12xx_wlvif_to_vif(wlvif);\n\tieee80211_chswitch_done(vif, false);\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twl12xx_cmd_stop_channel_switch(wl, wlvif);\n\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\nout:\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic void wlcore_connection_loss_work(struct work_struct *work)\n{\n\tstruct delayed_work *dwork;\n\tstruct wl1271 *wl;\n\tstruct ieee80211_vif *vif;\n\tstruct wl12xx_vif *wlvif;\n\n\tdwork = to_delayed_work(work);\n\twlvif = container_of(dwork, struct wl12xx_vif, connection_loss_work);\n\twl = wlvif->wl;\n\n\twl1271_info(\"Connection loss work (role_id: %d).\", wlvif->role_id);\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON))\n\t\tgoto out;\n\n\t \n\tif (!test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags))\n\t\tgoto out;\n\n\tvif = wl12xx_wlvif_to_vif(wlvif);\n\tieee80211_connection_loss(vif);\nout:\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic void wlcore_pending_auth_complete_work(struct work_struct *work)\n{\n\tstruct delayed_work *dwork;\n\tstruct wl1271 *wl;\n\tstruct wl12xx_vif *wlvif;\n\tunsigned long time_spare;\n\tint ret;\n\n\tdwork = to_delayed_work(work);\n\twlvif = container_of(dwork, struct wl12xx_vif,\n\t\t\t     pending_auth_complete_work);\n\twl = wlvif->wl;\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON))\n\t\tgoto out;\n\n\t \n\ttime_spare = jiffies +\n\t\t\tmsecs_to_jiffies(WLCORE_PEND_AUTH_ROC_TIMEOUT - 50);\n\tif (!time_after(time_spare, wlvif->pending_auth_reply_time))\n\t\tgoto out;\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\twlcore_update_inconn_sta(wl, wlvif, NULL, false);\n\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\nout:\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic int wl12xx_allocate_rate_policy(struct wl1271 *wl, u8 *idx)\n{\n\tu8 policy = find_first_zero_bit(wl->rate_policies_map,\n\t\t\t\t\tWL12XX_MAX_RATE_POLICIES);\n\tif (policy >= WL12XX_MAX_RATE_POLICIES)\n\t\treturn -EBUSY;\n\n\t__set_bit(policy, wl->rate_policies_map);\n\t*idx = policy;\n\treturn 0;\n}\n\nstatic void wl12xx_free_rate_policy(struct wl1271 *wl, u8 *idx)\n{\n\tif (WARN_ON(*idx >= WL12XX_MAX_RATE_POLICIES))\n\t\treturn;\n\n\t__clear_bit(*idx, wl->rate_policies_map);\n\t*idx = WL12XX_MAX_RATE_POLICIES;\n}\n\nstatic int wlcore_allocate_klv_template(struct wl1271 *wl, u8 *idx)\n{\n\tu8 policy = find_first_zero_bit(wl->klv_templates_map,\n\t\t\t\t\tWLCORE_MAX_KLV_TEMPLATES);\n\tif (policy >= WLCORE_MAX_KLV_TEMPLATES)\n\t\treturn -EBUSY;\n\n\t__set_bit(policy, wl->klv_templates_map);\n\t*idx = policy;\n\treturn 0;\n}\n\nstatic void wlcore_free_klv_template(struct wl1271 *wl, u8 *idx)\n{\n\tif (WARN_ON(*idx >= WLCORE_MAX_KLV_TEMPLATES))\n\t\treturn;\n\n\t__clear_bit(*idx, wl->klv_templates_map);\n\t*idx = WLCORE_MAX_KLV_TEMPLATES;\n}\n\nstatic u8 wl12xx_get_role_type(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tstruct ieee80211_vif *vif = wl12xx_wlvif_to_vif(wlvif);\n\n\tswitch (wlvif->bss_type) {\n\tcase BSS_TYPE_AP_BSS:\n\t\tif (wlvif->p2p)\n\t\t\treturn WL1271_ROLE_P2P_GO;\n\t\telse if (ieee80211_vif_is_mesh(vif))\n\t\t\treturn WL1271_ROLE_MESH_POINT;\n\t\telse\n\t\t\treturn WL1271_ROLE_AP;\n\n\tcase BSS_TYPE_STA_BSS:\n\t\tif (wlvif->p2p)\n\t\t\treturn WL1271_ROLE_P2P_CL;\n\t\telse\n\t\t\treturn WL1271_ROLE_STA;\n\n\tcase BSS_TYPE_IBSS:\n\t\treturn WL1271_ROLE_IBSS;\n\n\tdefault:\n\t\twl1271_error(\"invalid bss_type: %d\", wlvif->bss_type);\n\t}\n\treturn WL12XX_INVALID_ROLE_TYPE;\n}\n\nstatic int wl12xx_init_vif_data(struct wl1271 *wl, struct ieee80211_vif *vif)\n{\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tint i;\n\n\t \n\tmemset(wlvif, 0, offsetof(struct wl12xx_vif, persistent));\n\n\tswitch (ieee80211_vif_type_p2p(vif)) {\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\twlvif->p2p = 1;\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\twlvif->bss_type = BSS_TYPE_STA_BSS;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\twlvif->bss_type = BSS_TYPE_IBSS;\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\twlvif->p2p = 1;\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\twlvif->bss_type = BSS_TYPE_AP_BSS;\n\t\tbreak;\n\tdefault:\n\t\twlvif->bss_type = MAX_BSS_TYPE;\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\twlvif->role_id = WL12XX_INVALID_ROLE_ID;\n\twlvif->dev_role_id = WL12XX_INVALID_ROLE_ID;\n\twlvif->dev_hlid = WL12XX_INVALID_LINK_ID;\n\n\tif (wlvif->bss_type == BSS_TYPE_STA_BSS ||\n\t    wlvif->bss_type == BSS_TYPE_IBSS) {\n\t\t \n\t\twlvif->sta.hlid = WL12XX_INVALID_LINK_ID;\n\t\twl12xx_allocate_rate_policy(wl, &wlvif->sta.basic_rate_idx);\n\t\twl12xx_allocate_rate_policy(wl, &wlvif->sta.ap_rate_idx);\n\t\twl12xx_allocate_rate_policy(wl, &wlvif->sta.p2p_rate_idx);\n\t\twlcore_allocate_klv_template(wl, &wlvif->sta.klv_template_id);\n\t\twlvif->basic_rate_set = CONF_TX_RATE_MASK_BASIC;\n\t\twlvif->basic_rate = CONF_TX_RATE_MASK_BASIC;\n\t\twlvif->rate_set = CONF_TX_RATE_MASK_BASIC;\n\t} else {\n\t\t \n\t\twlvif->ap.bcast_hlid = WL12XX_INVALID_LINK_ID;\n\t\twlvif->ap.global_hlid = WL12XX_INVALID_LINK_ID;\n\t\twl12xx_allocate_rate_policy(wl, &wlvif->ap.mgmt_rate_idx);\n\t\twl12xx_allocate_rate_policy(wl, &wlvif->ap.bcast_rate_idx);\n\t\tfor (i = 0; i < CONF_TX_MAX_AC_COUNT; i++)\n\t\t\twl12xx_allocate_rate_policy(wl,\n\t\t\t\t\t\t&wlvif->ap.ucast_rate_idx[i]);\n\t\twlvif->basic_rate_set = CONF_TX_ENABLED_RATES;\n\t\t \n\t\twlvif->basic_rate = CONF_TX_ENABLED_RATES;\n\t\t \n\t\twlvif->rate_set = CONF_TX_ENABLED_RATES;\n\t}\n\n\twlvif->bitrate_masks[NL80211_BAND_2GHZ] = wl->conf.tx.basic_rate;\n\twlvif->bitrate_masks[NL80211_BAND_5GHZ] = wl->conf.tx.basic_rate_5;\n\twlvif->beacon_int = WL1271_DEFAULT_BEACON_INT;\n\n\t \n\twlvif->band = wl->band;\n\twlvif->channel = wl->channel;\n\twlvif->power_level = wl->power_level;\n\twlvif->channel_type = wl->channel_type;\n\n\tINIT_WORK(&wlvif->rx_streaming_enable_work,\n\t\t  wl1271_rx_streaming_enable_work);\n\tINIT_WORK(&wlvif->rx_streaming_disable_work,\n\t\t  wl1271_rx_streaming_disable_work);\n\tINIT_WORK(&wlvif->rc_update_work, wlcore_rc_update_work);\n\tINIT_DELAYED_WORK(&wlvif->channel_switch_work,\n\t\t\t  wlcore_channel_switch_work);\n\tINIT_DELAYED_WORK(&wlvif->connection_loss_work,\n\t\t\t  wlcore_connection_loss_work);\n\tINIT_DELAYED_WORK(&wlvif->pending_auth_complete_work,\n\t\t\t  wlcore_pending_auth_complete_work);\n\tINIT_LIST_HEAD(&wlvif->list);\n\n\ttimer_setup(&wlvif->rx_streaming_timer, wl1271_rx_streaming_timer, 0);\n\treturn 0;\n}\n\nstatic int wl12xx_init_fw(struct wl1271 *wl)\n{\n\tint retries = WL1271_BOOT_RETRIES;\n\tbool booted = false;\n\tstruct wiphy *wiphy = wl->hw->wiphy;\n\tint ret;\n\n\twhile (retries) {\n\t\tretries--;\n\t\tret = wl12xx_chip_wakeup(wl, false);\n\t\tif (ret < 0)\n\t\t\tgoto power_off;\n\n\t\tret = wl->ops->boot(wl);\n\t\tif (ret < 0)\n\t\t\tgoto power_off;\n\n\t\tret = wl1271_hw_init(wl);\n\t\tif (ret < 0)\n\t\t\tgoto irq_disable;\n\n\t\tbooted = true;\n\t\tbreak;\n\nirq_disable:\n\t\tmutex_unlock(&wl->mutex);\n\t\t \n\t\twlcore_disable_interrupts(wl);\n\t\twl1271_flush_deferred_work(wl);\n\t\tcancel_work_sync(&wl->netstack_work);\n\t\tmutex_lock(&wl->mutex);\npower_off:\n\t\twl1271_power_off(wl);\n\t}\n\n\tif (!booted) {\n\t\twl1271_error(\"firmware boot failed despite %d retries\",\n\t\t\t     WL1271_BOOT_RETRIES);\n\t\tgoto out;\n\t}\n\n\twl1271_info(\"firmware booted (%s)\", wl->chip.fw_ver_str);\n\n\t \n\twiphy->hw_version = wl->chip.id;\n\tstrncpy(wiphy->fw_version, wl->chip.fw_ver_str,\n\t\tsizeof(wiphy->fw_version));\n\n\t \n\tif (!wl->enable_11a)\n\t\twiphy->bands[NL80211_BAND_5GHZ]->n_channels = 0;\n\n\twl1271_debug(DEBUG_MAC80211, \"11a is %ssupported\",\n\t\t     wl->enable_11a ? \"\" : \"not \");\n\n\twl->state = WLCORE_STATE_ON;\nout:\n\treturn ret;\n}\n\nstatic bool wl12xx_dev_role_started(struct wl12xx_vif *wlvif)\n{\n\treturn wlvif->dev_hlid != WL12XX_INVALID_LINK_ID;\n}\n\n \nstatic bool wl12xx_need_fw_change(struct wl1271 *wl,\n\t\t\t\t  struct vif_counter_data vif_counter_data,\n\t\t\t\t  bool add)\n{\n\tenum wl12xx_fw_type current_fw = wl->fw_type;\n\tu8 vif_count = vif_counter_data.counter;\n\n\tif (test_bit(WL1271_FLAG_VIF_CHANGE_IN_PROGRESS, &wl->flags))\n\t\treturn false;\n\n\t \n\tif (add && !vif_counter_data.cur_vif_running)\n\t\tvif_count++;\n\n\twl->last_vif_count = vif_count;\n\n\t \n\tif (wl->state == WLCORE_STATE_OFF)\n\t\treturn false;\n\n\t \n\tif (!wl->mr_fw_name)\n\t\treturn false;\n\n\tif (vif_count > 1 && current_fw == WL12XX_FW_TYPE_NORMAL)\n\t\treturn true;\n\tif (vif_count <= 1 && current_fw == WL12XX_FW_TYPE_MULTI)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic void wl12xx_force_active_psm(struct wl1271 *wl)\n{\n\tstruct wl12xx_vif *wlvif;\n\n\twl12xx_for_each_wlvif_sta(wl, wlvif) {\n\t\twl1271_ps_set_mode(wl, wlvif, STATION_POWER_SAVE_MODE);\n\t}\n}\n\nstruct wlcore_hw_queue_iter_data {\n\tunsigned long hw_queue_map[BITS_TO_LONGS(WLCORE_NUM_MAC_ADDRESSES)];\n\t \n\tstruct ieee80211_vif *vif;\n\t \n\tbool cur_running;\n};\n\nstatic void wlcore_hw_queue_iter(void *data, u8 *mac,\n\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct wlcore_hw_queue_iter_data *iter_data = data;\n\n\tif (vif->type == NL80211_IFTYPE_P2P_DEVICE ||\n\t    WARN_ON_ONCE(vif->hw_queue[0] == IEEE80211_INVAL_HW_QUEUE))\n\t\treturn;\n\n\tif (iter_data->cur_running || vif == iter_data->vif) {\n\t\titer_data->cur_running = true;\n\t\treturn;\n\t}\n\n\t__set_bit(vif->hw_queue[0] / NUM_TX_QUEUES, iter_data->hw_queue_map);\n}\n\nstatic int wlcore_allocate_hw_queue_base(struct wl1271 *wl,\n\t\t\t\t\t struct wl12xx_vif *wlvif)\n{\n\tstruct ieee80211_vif *vif = wl12xx_wlvif_to_vif(wlvif);\n\tstruct wlcore_hw_queue_iter_data iter_data = {};\n\tint i, q_base;\n\n\tif (vif->type == NL80211_IFTYPE_P2P_DEVICE) {\n\t\tvif->cab_queue = IEEE80211_INVAL_HW_QUEUE;\n\t\treturn 0;\n\t}\n\n\titer_data.vif = vif;\n\n\t \n\tieee80211_iterate_active_interfaces_atomic(wl->hw,\n\t\t\t\t\tIEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\t\t\twlcore_hw_queue_iter, &iter_data);\n\n\t \n\tif (iter_data.cur_running) {\n\t\twlvif->hw_queue_base = vif->hw_queue[0];\n\t\twl1271_debug(DEBUG_MAC80211,\n\t\t\t     \"using pre-allocated hw queue base %d\",\n\t\t\t     wlvif->hw_queue_base);\n\n\t\t \n\t\tgoto adjust_cab_queue;\n\t}\n\n\tq_base = find_first_zero_bit(iter_data.hw_queue_map,\n\t\t\t\t     WLCORE_NUM_MAC_ADDRESSES);\n\tif (q_base >= WLCORE_NUM_MAC_ADDRESSES)\n\t\treturn -EBUSY;\n\n\twlvif->hw_queue_base = q_base * NUM_TX_QUEUES;\n\twl1271_debug(DEBUG_MAC80211, \"allocating hw queue base: %d\",\n\t\t     wlvif->hw_queue_base);\n\n\tfor (i = 0; i < NUM_TX_QUEUES; i++) {\n\t\twl->queue_stop_reasons[wlvif->hw_queue_base + i] = 0;\n\t\t \n\t\tvif->hw_queue[i] = wlvif->hw_queue_base + i;\n\t}\n\nadjust_cab_queue:\n\t \n\tif (wlvif->bss_type == BSS_TYPE_AP_BSS)\n\t\tvif->cab_queue = NUM_TX_QUEUES * WLCORE_NUM_MAC_ADDRESSES +\n\t\t\t\t wlvif->hw_queue_base / NUM_TX_QUEUES;\n\telse\n\t\tvif->cab_queue = IEEE80211_INVAL_HW_QUEUE;\n\n\treturn 0;\n}\n\nstatic int wl1271_op_add_interface(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tstruct vif_counter_data vif_count;\n\tint ret = 0;\n\tu8 role_type;\n\n\tif (wl->plt) {\n\t\twl1271_error(\"Adding Interface not allowed while in PLT mode\");\n\t\treturn -EBUSY;\n\t}\n\n\tvif->driver_flags |= IEEE80211_VIF_BEACON_FILTER |\n\t\t\t     IEEE80211_VIF_SUPPORTS_UAPSD |\n\t\t\t     IEEE80211_VIF_SUPPORTS_CQM_RSSI;\n\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 add interface type %d mac %pM\",\n\t\t     ieee80211_vif_type_p2p(vif), vif->addr);\n\n\twl12xx_get_vif_count(hw, vif, &vif_count);\n\n\tmutex_lock(&wl->mutex);\n\n\t \n\tif (test_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS, &wl->flags) ||\n\t    test_bit(WLVIF_FLAG_INITIALIZED, &wlvif->flags)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\n\tret = wl12xx_init_vif_data(wl, vif);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twlvif->wl = wl;\n\trole_type = wl12xx_get_role_type(wl, wlvif);\n\tif (role_type == WL12XX_INVALID_ROLE_TYPE) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = wlcore_allocate_hw_queue_base(wl, wlvif);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tif (wl->state == WLCORE_STATE_OFF) {\n\t\t \n\t\tmemcpy(wl->addresses[0].addr, vif->addr, ETH_ALEN);\n\n\t\tret = wl12xx_init_fw(wl);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t \n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tif (wl12xx_need_fw_change(wl, vif_count, true)) {\n\t\twl12xx_force_active_psm(wl);\n\t\tset_bit(WL1271_FLAG_INTENDED_FW_RECOVERY, &wl->flags);\n\t\tmutex_unlock(&wl->mutex);\n\t\twl1271_recovery_work(&wl->recovery_work);\n\t\treturn 0;\n\t}\n\n\tif (!wlcore_is_p2p_mgmt(wlvif)) {\n\t\tret = wl12xx_cmd_role_enable(wl, vif->addr,\n\t\t\t\t\t     role_type, &wlvif->role_id);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = wl1271_init_vif_specific(wl, vif);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t} else {\n\t\tret = wl12xx_cmd_role_enable(wl, vif->addr, WL1271_ROLE_DEVICE,\n\t\t\t\t\t     &wlvif->dev_role_id);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t \n\t\tret = wl1271_sta_hw_init(wl, wlvif);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_add(&wlvif->list, &wl->wlvif_list);\n\tset_bit(WLVIF_FLAG_INITIALIZED, &wlvif->flags);\n\n\tif (wlvif->bss_type == BSS_TYPE_AP_BSS)\n\t\twl->ap_count++;\n\telse\n\t\twl->sta_count++;\nout:\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\nout_unlock:\n\tmutex_unlock(&wl->mutex);\n\n\treturn ret;\n}\n\nstatic void __wl1271_op_remove_interface(struct wl1271 *wl,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t bool reset_tx_queues)\n{\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tint i, ret;\n\tbool is_ap = (wlvif->bss_type == BSS_TYPE_AP_BSS);\n\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 remove interface\");\n\n\tif (!test_and_clear_bit(WLVIF_FLAG_INITIALIZED, &wlvif->flags))\n\t\treturn;\n\n\t \n\tif (wl->state == WLCORE_STATE_OFF)\n\t\treturn;\n\n\twl1271_info(\"down\");\n\n\tif (wl->scan.state != WL1271_SCAN_STATE_IDLE &&\n\t    wl->scan_wlvif == wlvif) {\n\t\tstruct cfg80211_scan_info info = {\n\t\t\t.aborted = true,\n\t\t};\n\n\t\t \n\t\twl12xx_rearm_tx_watchdog_locked(wl);\n\n\t\twl->scan.state = WL1271_SCAN_STATE_IDLE;\n\t\tmemset(wl->scan.scanned_ch, 0, sizeof(wl->scan.scanned_ch));\n\t\twl->scan_wlvif = NULL;\n\t\twl->scan.req = NULL;\n\t\tieee80211_scan_completed(wl->hw, &info);\n\t}\n\n\tif (wl->sched_vif == wlvif)\n\t\twl->sched_vif = NULL;\n\n\tif (wl->roc_vif == vif) {\n\t\twl->roc_vif = NULL;\n\t\tieee80211_remain_on_channel_expired(wl->hw);\n\t}\n\n\tif (!test_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS, &wl->flags)) {\n\t\t \n\t\tret = pm_runtime_resume_and_get(wl->dev);\n\t\tif (ret < 0)\n\t\t\tgoto deinit;\n\n\t\tif (wlvif->bss_type == BSS_TYPE_STA_BSS ||\n\t\t    wlvif->bss_type == BSS_TYPE_IBSS) {\n\t\t\tif (wl12xx_dev_role_started(wlvif))\n\t\t\t\twl12xx_stop_dev(wl, wlvif);\n\t\t}\n\n\t\tif (!wlcore_is_p2p_mgmt(wlvif)) {\n\t\t\tret = wl12xx_cmd_role_disable(wl, &wlvif->role_id);\n\t\t\tif (ret < 0) {\n\t\t\t\tpm_runtime_put_noidle(wl->dev);\n\t\t\t\tgoto deinit;\n\t\t\t}\n\t\t} else {\n\t\t\tret = wl12xx_cmd_role_disable(wl, &wlvif->dev_role_id);\n\t\t\tif (ret < 0) {\n\t\t\t\tpm_runtime_put_noidle(wl->dev);\n\t\t\t\tgoto deinit;\n\t\t\t}\n\t\t}\n\n\t\tpm_runtime_mark_last_busy(wl->dev);\n\t\tpm_runtime_put_autosuspend(wl->dev);\n\t}\ndeinit:\n\twl12xx_tx_reset_wlvif(wl, wlvif);\n\n\t \n\twlvif->dev_hlid = WL12XX_INVALID_LINK_ID;\n\n\tif (wlvif->bss_type == BSS_TYPE_STA_BSS ||\n\t    wlvif->bss_type == BSS_TYPE_IBSS) {\n\t\twlvif->sta.hlid = WL12XX_INVALID_LINK_ID;\n\t\twl12xx_free_rate_policy(wl, &wlvif->sta.basic_rate_idx);\n\t\twl12xx_free_rate_policy(wl, &wlvif->sta.ap_rate_idx);\n\t\twl12xx_free_rate_policy(wl, &wlvif->sta.p2p_rate_idx);\n\t\twlcore_free_klv_template(wl, &wlvif->sta.klv_template_id);\n\t} else {\n\t\twlvif->ap.bcast_hlid = WL12XX_INVALID_LINK_ID;\n\t\twlvif->ap.global_hlid = WL12XX_INVALID_LINK_ID;\n\t\twl12xx_free_rate_policy(wl, &wlvif->ap.mgmt_rate_idx);\n\t\twl12xx_free_rate_policy(wl, &wlvif->ap.bcast_rate_idx);\n\t\tfor (i = 0; i < CONF_TX_MAX_AC_COUNT; i++)\n\t\t\twl12xx_free_rate_policy(wl,\n\t\t\t\t\t\t&wlvif->ap.ucast_rate_idx[i]);\n\t\twl1271_free_ap_keys(wl, wlvif);\n\t}\n\n\tdev_kfree_skb(wlvif->probereq);\n\twlvif->probereq = NULL;\n\tif (wl->last_wlvif == wlvif)\n\t\twl->last_wlvif = NULL;\n\tlist_del(&wlvif->list);\n\tmemset(wlvif->ap.sta_hlid_map, 0, sizeof(wlvif->ap.sta_hlid_map));\n\twlvif->role_id = WL12XX_INVALID_ROLE_ID;\n\twlvif->dev_role_id = WL12XX_INVALID_ROLE_ID;\n\n\tif (is_ap)\n\t\twl->ap_count--;\n\telse\n\t\twl->sta_count--;\n\n\t \n\tif (test_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS, &wl->flags) &&\n\t    !test_bit(WL1271_FLAG_INTENDED_FW_RECOVERY, &wl->flags))\n\t\tgoto unlock;\n\n\tif (wl->ap_count == 0 && is_ap) {\n\t\t \n\t\twl->event_mask &= ~wl->ap_event_mask;\n\t\twl1271_event_unmask(wl);\n\t}\n\n\tif (wl->ap_count == 0 && is_ap && wl->sta_count) {\n\t\tu8 sta_auth = wl->conf.conn.sta_sleep_auth;\n\t\t \n\t\tif (sta_auth != WL1271_PSM_ILLEGAL)\n\t\t\twl1271_acx_sleep_auth(wl, sta_auth);\n\t\t \n\t\telse\n\t\t\twl1271_acx_sleep_auth(wl, WL1271_PSM_ELP);\n\t}\n\nunlock:\n\tmutex_unlock(&wl->mutex);\n\n\tdel_timer_sync(&wlvif->rx_streaming_timer);\n\tcancel_work_sync(&wlvif->rx_streaming_enable_work);\n\tcancel_work_sync(&wlvif->rx_streaming_disable_work);\n\tcancel_work_sync(&wlvif->rc_update_work);\n\tcancel_delayed_work_sync(&wlvif->connection_loss_work);\n\tcancel_delayed_work_sync(&wlvif->channel_switch_work);\n\tcancel_delayed_work_sync(&wlvif->pending_auth_complete_work);\n\n\tmutex_lock(&wl->mutex);\n}\n\nstatic void wl1271_op_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tstruct wl12xx_vif *iter;\n\tstruct vif_counter_data vif_count;\n\n\twl12xx_get_vif_count(hw, vif, &vif_count);\n\tmutex_lock(&wl->mutex);\n\n\tif (wl->state == WLCORE_STATE_OFF ||\n\t    !test_bit(WLVIF_FLAG_INITIALIZED, &wlvif->flags))\n\t\tgoto out;\n\n\t \n\twl12xx_for_each_wlvif(wl, iter) {\n\t\tif (iter != wlvif)\n\t\t\tcontinue;\n\n\t\t__wl1271_op_remove_interface(wl, vif, true);\n\t\tbreak;\n\t}\n\tWARN_ON(iter != wlvif);\n\tif (wl12xx_need_fw_change(wl, vif_count, false)) {\n\t\twl12xx_force_active_psm(wl);\n\t\tset_bit(WL1271_FLAG_INTENDED_FW_RECOVERY, &wl->flags);\n\t\twl12xx_queue_recovery_work(wl);\n\t}\nout:\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic int wl12xx_op_change_interface(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      enum nl80211_iftype new_type, bool p2p)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tint ret;\n\n\tset_bit(WL1271_FLAG_VIF_CHANGE_IN_PROGRESS, &wl->flags);\n\twl1271_op_remove_interface(hw, vif);\n\n\tvif->type = new_type;\n\tvif->p2p = p2p;\n\tret = wl1271_op_add_interface(hw, vif);\n\n\tclear_bit(WL1271_FLAG_VIF_CHANGE_IN_PROGRESS, &wl->flags);\n\treturn ret;\n}\n\nstatic int wlcore_join(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tint ret;\n\tbool is_ibss = (wlvif->bss_type == BSS_TYPE_IBSS);\n\n\t \n\tif (test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags))\n\t\twl1271_info(\"JOIN while associated.\");\n\n\t \n\twlvif->encryption_type = KEY_NONE;\n\n\tif (is_ibss)\n\t\tret = wl12xx_cmd_role_start_ibss(wl, wlvif);\n\telse\n\t\tret = wl12xx_cmd_role_start_sta(wl, wlvif);\n\n\treturn ret;\n}\n\nstatic int wl1271_ssid_set(struct wl12xx_vif *wlvif, struct sk_buff *skb,\n\t\t\t    int offset)\n{\n\tu8 ssid_len;\n\tconst u8 *ptr = cfg80211_find_ie(WLAN_EID_SSID, skb->data + offset,\n\t\t\t\t\t skb->len - offset);\n\n\tif (!ptr) {\n\t\twl1271_error(\"No SSID in IEs!\");\n\t\treturn -ENOENT;\n\t}\n\n\tssid_len = ptr[1];\n\tif (ssid_len > IEEE80211_MAX_SSID_LEN) {\n\t\twl1271_error(\"SSID is too long!\");\n\t\treturn -EINVAL;\n\t}\n\n\twlvif->ssid_len = ssid_len;\n\tmemcpy(wlvif->ssid, ptr+2, ssid_len);\n\treturn 0;\n}\n\nstatic int wlcore_set_ssid(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tstruct ieee80211_vif *vif = wl12xx_wlvif_to_vif(wlvif);\n\tstruct sk_buff *skb;\n\tint ieoffset;\n\n\t \n\tif (wlvif->bss_type != BSS_TYPE_STA_BSS)\n\t\treturn -EINVAL;\n\n\tskb = ieee80211_ap_probereq_get(wl->hw, vif);\n\tif (!skb)\n\t\treturn -EINVAL;\n\n\tieoffset = offsetof(struct ieee80211_mgmt,\n\t\t\t    u.probe_req.variable);\n\twl1271_ssid_set(wlvif, skb, ieoffset);\n\tdev_kfree_skb(skb);\n\n\treturn 0;\n}\n\nstatic int wlcore_set_assoc(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t    struct ieee80211_bss_conf *bss_conf,\n\t\t\t    u32 sta_rate_set)\n{\n\tstruct ieee80211_vif *vif = container_of(bss_conf, struct ieee80211_vif,\n\t\t\t\t\t\t bss_conf);\n\tint ieoffset;\n\tint ret;\n\n\twlvif->aid = vif->cfg.aid;\n\twlvif->channel_type = cfg80211_get_chandef_type(&bss_conf->chandef);\n\twlvif->beacon_int = bss_conf->beacon_int;\n\twlvif->wmm_enabled = bss_conf->qos;\n\n\tset_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags);\n\n\t \n\tret = wl1271_cmd_build_ps_poll(wl, wlvif, wlvif->aid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tdev_kfree_skb(wlvif->probereq);\n\twlvif->probereq = wl1271_cmd_build_ap_probe_req(wl,\n\t\t\t\t\t\t\twlvif,\n\t\t\t\t\t\t\tNULL);\n\tieoffset = offsetof(struct ieee80211_mgmt,\n\t\t\t    u.probe_req.variable);\n\twl1271_ssid_set(wlvif, wlvif->probereq, ieoffset);\n\n\t \n\tret = wl1271_acx_conn_monit_params(wl, wlvif, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wl1271_acx_keep_alive_mode(wl, wlvif, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1271_acx_aid(wl, wlvif, wlvif->aid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl12xx_cmd_build_klv_null_data(wl, wlvif);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1271_acx_keep_alive_config(wl, wlvif,\n\t\t\t\t\t   wlvif->sta.klv_template_id,\n\t\t\t\t\t   ACX_KEEP_ALIVE_TPL_VALID);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wl1271_ps_set_mode(wl, wlvif, STATION_ACTIVE_MODE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (sta_rate_set) {\n\t\twlvif->rate_set =\n\t\t\twl1271_tx_enabled_rates_get(wl,\n\t\t\t\t\t\t    sta_rate_set,\n\t\t\t\t\t\t    wlvif->band);\n\t\tret = wl1271_acx_sta_rate_policies(wl, wlvif);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int wlcore_unset_assoc(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tint ret;\n\tbool sta = wlvif->bss_type == BSS_TYPE_STA_BSS;\n\n\t \n\tif (sta &&\n\t    !test_and_clear_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags))\n\t\treturn false;\n\n\t \n\tif (!sta &&\n\t    test_and_clear_bit(WLVIF_FLAG_IBSS_JOINED, &wlvif->flags))\n\t\treturn false;\n\n\tif (sta) {\n\t\t \n\t\twlvif->aid = 0;\n\n\t\t \n\t\tdev_kfree_skb(wlvif->probereq);\n\t\twlvif->probereq = NULL;\n\n\t\t \n\t\tret = wl1271_acx_conn_monit_params(wl, wlvif, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = wl1271_acx_keep_alive_mode(wl, wlvif, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = wl1271_acx_beacon_filter_opt(wl, wlvif, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (test_and_clear_bit(WLVIF_FLAG_CS_PROGRESS, &wlvif->flags)) {\n\t\tstruct ieee80211_vif *vif = wl12xx_wlvif_to_vif(wlvif);\n\n\t\twl12xx_cmd_stop_channel_switch(wl, wlvif);\n\t\tieee80211_chswitch_done(vif, false);\n\t\tcancel_delayed_work(&wlvif->channel_switch_work);\n\t}\n\n\t \n\twl1271_acx_keep_alive_config(wl, wlvif,\n\t\t\t\t     wlvif->sta.klv_template_id,\n\t\t\t\t     ACX_KEEP_ALIVE_TPL_INVALID);\n\n\treturn 0;\n}\n\nstatic void wl1271_set_band_rate(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\twlvif->basic_rate_set = wlvif->bitrate_masks[wlvif->band];\n\twlvif->rate_set = wlvif->basic_rate_set;\n}\n\nstatic void wl1271_sta_handle_idle(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t\t   bool idle)\n{\n\tbool cur_idle = !test_bit(WLVIF_FLAG_ACTIVE, &wlvif->flags);\n\n\tif (idle == cur_idle)\n\t\treturn;\n\n\tif (idle) {\n\t\tclear_bit(WLVIF_FLAG_ACTIVE, &wlvif->flags);\n\t} else {\n\t\t \n\t\tif (wl->sched_vif == wlvif)\n\t\t\twl->ops->sched_scan_stop(wl, wlvif);\n\n\t\tset_bit(WLVIF_FLAG_ACTIVE, &wlvif->flags);\n\t}\n}\n\nstatic int wl12xx_config_vif(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t     struct ieee80211_conf *conf, u32 changed)\n{\n\tint ret;\n\n\tif (wlcore_is_p2p_mgmt(wlvif))\n\t\treturn 0;\n\n\tif (conf->power_level != wlvif->power_level) {\n\t\tret = wl1271_acx_tx_power(wl, wlvif, conf->power_level);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\twlvif->power_level = conf->power_level;\n\t}\n\n\treturn 0;\n}\n\nstatic int wl1271_op_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tstruct wl12xx_vif *wlvif;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tint ret = 0;\n\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 config psm %s power %d %s\"\n\t\t     \" changed 0x%x\",\n\t\t     conf->flags & IEEE80211_CONF_PS ? \"on\" : \"off\",\n\t\t     conf->power_level,\n\t\t     conf->flags & IEEE80211_CONF_IDLE ? \"idle\" : \"in use\",\n\t\t\t changed);\n\n\tmutex_lock(&wl->mutex);\n\n\tif (changed & IEEE80211_CONF_CHANGE_POWER)\n\t\twl->power_level = conf->power_level;\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON))\n\t\tgoto out;\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\twl12xx_for_each_wlvif(wl, wlvif) {\n\t\tret = wl12xx_config_vif(wl, wlvif, conf, changed);\n\t\tif (ret < 0)\n\t\t\tgoto out_sleep;\n\t}\n\nout_sleep:\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\n\nout:\n\tmutex_unlock(&wl->mutex);\n\n\treturn ret;\n}\n\nstruct wl1271_filter_params {\n\tbool enabled;\n\tint mc_list_length;\n\tu8 mc_list[ACX_MC_ADDRESS_GROUP_MAX][ETH_ALEN];\n};\n\nstatic u64 wl1271_op_prepare_multicast(struct ieee80211_hw *hw,\n\t\t\t\t       struct netdev_hw_addr_list *mc_list)\n{\n\tstruct wl1271_filter_params *fp;\n\tstruct netdev_hw_addr *ha;\n\n\tfp = kzalloc(sizeof(*fp), GFP_ATOMIC);\n\tif (!fp) {\n\t\twl1271_error(\"Out of memory setting filters.\");\n\t\treturn 0;\n\t}\n\n\t \n\tfp->mc_list_length = 0;\n\tif (netdev_hw_addr_list_count(mc_list) > ACX_MC_ADDRESS_GROUP_MAX) {\n\t\tfp->enabled = false;\n\t} else {\n\t\tfp->enabled = true;\n\t\tnetdev_hw_addr_list_for_each(ha, mc_list) {\n\t\t\tmemcpy(fp->mc_list[fp->mc_list_length],\n\t\t\t\t\tha->addr, ETH_ALEN);\n\t\t\tfp->mc_list_length++;\n\t\t}\n\t}\n\n\treturn (u64)(unsigned long)fp;\n}\n\n#define WL1271_SUPPORTED_FILTERS (FIF_ALLMULTI | \\\n\t\t\t\t  FIF_FCSFAIL | \\\n\t\t\t\t  FIF_BCN_PRBRESP_PROMISC | \\\n\t\t\t\t  FIF_CONTROL | \\\n\t\t\t\t  FIF_OTHER_BSS)\n\nstatic void wl1271_op_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t       unsigned int changed,\n\t\t\t\t       unsigned int *total, u64 multicast)\n{\n\tstruct wl1271_filter_params *fp = (void *)(unsigned long)multicast;\n\tstruct wl1271 *wl = hw->priv;\n\tstruct wl12xx_vif *wlvif;\n\n\tint ret;\n\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 configure filter changed %x\"\n\t\t     \" total %x\", changed, *total);\n\n\tmutex_lock(&wl->mutex);\n\n\t*total &= WL1271_SUPPORTED_FILTERS;\n\tchanged &= WL1271_SUPPORTED_FILTERS;\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON))\n\t\tgoto out;\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twl12xx_for_each_wlvif(wl, wlvif) {\n\t\tif (wlcore_is_p2p_mgmt(wlvif))\n\t\t\tcontinue;\n\n\t\tif (wlvif->bss_type != BSS_TYPE_AP_BSS) {\n\t\t\tif (*total & FIF_ALLMULTI)\n\t\t\t\tret = wl1271_acx_group_address_tbl(wl, wlvif,\n\t\t\t\t\t\t\t\t   false,\n\t\t\t\t\t\t\t\t   NULL, 0);\n\t\t\telse if (fp)\n\t\t\t\tret = wl1271_acx_group_address_tbl(wl, wlvif,\n\t\t\t\t\t\t\tfp->enabled,\n\t\t\t\t\t\t\tfp->mc_list,\n\t\t\t\t\t\t\tfp->mc_list_length);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_sleep;\n\t\t}\n\n\t\t \n\t\tif (wlvif->bss_type == BSS_TYPE_AP_BSS) {\n\t\t\tif (*total & FIF_ALLMULTI) {\n\t\t\t\tret = wl1271_acx_group_address_tbl(wl, wlvif,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tNULL, 0);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out_sleep;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\nout_sleep:\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\n\nout:\n\tmutex_unlock(&wl->mutex);\n\tkfree(fp);\n}\n\nstatic int wl1271_record_ap_key(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t\tu8 id, u8 key_type, u8 key_size,\n\t\t\t\tconst u8 *key, u8 hlid, u32 tx_seq_32,\n\t\t\t\tu16 tx_seq_16, bool is_pairwise)\n{\n\tstruct wl1271_ap_key *ap_key;\n\tint i;\n\n\twl1271_debug(DEBUG_CRYPT, \"record ap key id %d\", (int)id);\n\n\tif (key_size > MAX_KEY_SIZE)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < MAX_NUM_KEYS; i++) {\n\t\tif (wlvif->ap.recorded_keys[i] == NULL)\n\t\t\tbreak;\n\n\t\tif (wlvif->ap.recorded_keys[i]->id == id) {\n\t\t\twl1271_warning(\"trying to record key replacement\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (i == MAX_NUM_KEYS)\n\t\treturn -EBUSY;\n\n\tap_key = kzalloc(sizeof(*ap_key), GFP_KERNEL);\n\tif (!ap_key)\n\t\treturn -ENOMEM;\n\n\tap_key->id = id;\n\tap_key->key_type = key_type;\n\tap_key->key_size = key_size;\n\tmemcpy(ap_key->key, key, key_size);\n\tap_key->hlid = hlid;\n\tap_key->tx_seq_32 = tx_seq_32;\n\tap_key->tx_seq_16 = tx_seq_16;\n\tap_key->is_pairwise = is_pairwise;\n\n\twlvif->ap.recorded_keys[i] = ap_key;\n\treturn 0;\n}\n\nstatic void wl1271_free_ap_keys(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_NUM_KEYS; i++) {\n\t\tkfree(wlvif->ap.recorded_keys[i]);\n\t\twlvif->ap.recorded_keys[i] = NULL;\n\t}\n}\n\nstatic int wl1271_ap_init_hwenc(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tint i, ret = 0;\n\tstruct wl1271_ap_key *key;\n\tbool wep_key_added = false;\n\n\tfor (i = 0; i < MAX_NUM_KEYS; i++) {\n\t\tu8 hlid;\n\t\tif (wlvif->ap.recorded_keys[i] == NULL)\n\t\t\tbreak;\n\n\t\tkey = wlvif->ap.recorded_keys[i];\n\t\thlid = key->hlid;\n\t\tif (hlid == WL12XX_INVALID_LINK_ID)\n\t\t\thlid = wlvif->ap.bcast_hlid;\n\n\t\tret = wl1271_cmd_set_ap_key(wl, wlvif, KEY_ADD_OR_REPLACE,\n\t\t\t\t\t    key->id, key->key_type,\n\t\t\t\t\t    key->key_size, key->key,\n\t\t\t\t\t    hlid, key->tx_seq_32,\n\t\t\t\t\t    key->tx_seq_16, key->is_pairwise);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (key->key_type == KEY_WEP)\n\t\t\twep_key_added = true;\n\t}\n\n\tif (wep_key_added) {\n\t\tret = wl12xx_cmd_set_default_wep_key(wl, wlvif->default_key,\n\t\t\t\t\t\t     wlvif->ap.bcast_hlid);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\twl1271_free_ap_keys(wl, wlvif);\n\treturn ret;\n}\n\nstatic int wl1271_set_key(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t       u16 action, u8 id, u8 key_type,\n\t\t       u8 key_size, const u8 *key, u32 tx_seq_32,\n\t\t       u16 tx_seq_16, struct ieee80211_sta *sta,\n\t\t       bool is_pairwise)\n{\n\tint ret;\n\tbool is_ap = (wlvif->bss_type == BSS_TYPE_AP_BSS);\n\n\tif (is_ap) {\n\t\tstruct wl1271_station *wl_sta;\n\t\tu8 hlid;\n\n\t\tif (sta) {\n\t\t\twl_sta = (struct wl1271_station *)sta->drv_priv;\n\t\t\thlid = wl_sta->hlid;\n\t\t} else {\n\t\t\thlid = wlvif->ap.bcast_hlid;\n\t\t}\n\n\t\tif (!test_bit(WLVIF_FLAG_AP_STARTED, &wlvif->flags)) {\n\t\t\t \n\t\t\tif (action != KEY_ADD_OR_REPLACE)\n\t\t\t\treturn 0;\n\n\t\t\tret = wl1271_record_ap_key(wl, wlvif, id,\n\t\t\t\t\t     key_type, key_size,\n\t\t\t\t\t     key, hlid, tx_seq_32,\n\t\t\t\t\t     tx_seq_16, is_pairwise);\n\t\t} else {\n\t\t\tret = wl1271_cmd_set_ap_key(wl, wlvif, action,\n\t\t\t\t\t     id, key_type, key_size,\n\t\t\t\t\t     key, hlid, tx_seq_32,\n\t\t\t\t\t     tx_seq_16, is_pairwise);\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tconst u8 *addr;\n\t\tstatic const u8 bcast_addr[ETH_ALEN] = {\n\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n\t\t};\n\n\t\taddr = sta ? sta->addr : bcast_addr;\n\n\t\tif (is_zero_ether_addr(addr)) {\n\t\t\t \n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\t \n\t\tif (action == KEY_REMOVE && !is_broadcast_ether_addr(addr))\n\t\t\treturn 0;\n\n\t\t \n\t\tif (action == KEY_REMOVE &&\n\t\t    wlvif->sta.hlid == WL12XX_INVALID_LINK_ID)\n\t\t\treturn 0;\n\n\t\tret = wl1271_cmd_set_sta_key(wl, wlvif, action,\n\t\t\t\t\t     id, key_type, key_size,\n\t\t\t\t\t     key, addr, tx_seq_32,\n\t\t\t\t\t     tx_seq_16);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t}\n\n\treturn 0;\n}\n\nstatic int wlcore_op_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_sta *sta,\n\t\t\t     struct ieee80211_key_conf *key_conf)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tint ret;\n\tbool might_change_spare =\n\t\tkey_conf->cipher == WL1271_CIPHER_SUITE_GEM ||\n\t\tkey_conf->cipher == WLAN_CIPHER_SUITE_TKIP;\n\n\tif (might_change_spare) {\n\t\t \n\t\twlcore_stop_queues(wl, WLCORE_QUEUE_STOP_REASON_SPARE_BLK);\n\t\twl1271_tx_flush(wl);\n\t}\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON)) {\n\t\tret = -EAGAIN;\n\t\tgoto out_wake_queues;\n\t}\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out_wake_queues;\n\n\tret = wlcore_hw_set_key(wl, cmd, vif, sta, key_conf);\n\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\n\nout_wake_queues:\n\tif (might_change_spare)\n\t\twlcore_wake_queues(wl, WLCORE_QUEUE_STOP_REASON_SPARE_BLK);\n\n\tmutex_unlock(&wl->mutex);\n\n\treturn ret;\n}\n\nint wlcore_set_key(struct wl1271 *wl, enum set_key_cmd cmd,\n\t\t   struct ieee80211_vif *vif,\n\t\t   struct ieee80211_sta *sta,\n\t\t   struct ieee80211_key_conf *key_conf)\n{\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tint ret;\n\tu32 tx_seq_32 = 0;\n\tu16 tx_seq_16 = 0;\n\tu8 key_type;\n\tu8 hlid;\n\tbool is_pairwise;\n\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 set key\");\n\n\twl1271_debug(DEBUG_CRYPT, \"CMD: 0x%x sta: %p\", cmd, sta);\n\twl1271_debug(DEBUG_CRYPT, \"Key: algo:0x%x, id:%d, len:%d flags 0x%x\",\n\t\t     key_conf->cipher, key_conf->keyidx,\n\t\t     key_conf->keylen, key_conf->flags);\n\twl1271_dump(DEBUG_CRYPT, \"KEY: \", key_conf->key, key_conf->keylen);\n\n\tif (wlvif->bss_type == BSS_TYPE_AP_BSS)\n\t\tif (sta) {\n\t\t\tstruct wl1271_station *wl_sta = (void *)sta->drv_priv;\n\t\t\thlid = wl_sta->hlid;\n\t\t} else {\n\t\t\thlid = wlvif->ap.bcast_hlid;\n\t\t}\n\telse\n\t\thlid = wlvif->sta.hlid;\n\n\tif (hlid != WL12XX_INVALID_LINK_ID) {\n\t\tu64 tx_seq = wl->links[hlid].total_freed_pkts;\n\t\ttx_seq_32 = WL1271_TX_SECURITY_HI32(tx_seq);\n\t\ttx_seq_16 = WL1271_TX_SECURITY_LO16(tx_seq);\n\t}\n\n\tswitch (key_conf->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tkey_type = KEY_WEP;\n\n\t\tkey_conf->hw_key_idx = key_conf->keyidx;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tkey_type = KEY_TKIP;\n\t\tkey_conf->hw_key_idx = key_conf->keyidx;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tkey_type = KEY_AES;\n\t\tkey_conf->flags |= IEEE80211_KEY_FLAG_PUT_IV_SPACE;\n\t\tbreak;\n\tcase WL1271_CIPHER_SUITE_GEM:\n\t\tkey_type = KEY_GEM;\n\t\tbreak;\n\tdefault:\n\t\twl1271_error(\"Unknown key algo 0x%x\", key_conf->cipher);\n\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tis_pairwise = key_conf->flags & IEEE80211_KEY_FLAG_PAIRWISE;\n\n\tswitch (cmd) {\n\tcase SET_KEY:\n\t\tret = wl1271_set_key(wl, wlvif, KEY_ADD_OR_REPLACE,\n\t\t\t\t key_conf->keyidx, key_type,\n\t\t\t\t key_conf->keylen, key_conf->key,\n\t\t\t\t tx_seq_32, tx_seq_16, sta, is_pairwise);\n\t\tif (ret < 0) {\n\t\t\twl1271_error(\"Could not add or replace key\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (wlvif->bss_type == BSS_TYPE_STA_BSS &&\n\t\t    (sta || key_type == KEY_WEP) &&\n\t\t    wlvif->encryption_type != key_type) {\n\t\t\twlvif->encryption_type = key_type;\n\t\t\tret = wl1271_cmd_build_arp_rsp(wl, wlvif);\n\t\t\tif (ret < 0) {\n\t\t\t\twl1271_warning(\"build arp rsp failed: %d\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase DISABLE_KEY:\n\t\tret = wl1271_set_key(wl, wlvif, KEY_REMOVE,\n\t\t\t\t     key_conf->keyidx, key_type,\n\t\t\t\t     key_conf->keylen, key_conf->key,\n\t\t\t\t     0, 0, sta, is_pairwise);\n\t\tif (ret < 0) {\n\t\t\twl1271_error(\"Could not remove key\");\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\twl1271_error(\"Unsupported key cmd 0x%x\", cmd);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wlcore_set_key);\n\nstatic void wl1271_op_set_default_key_idx(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  int key_idx)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tint ret;\n\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 set default key idx %d\",\n\t\t     key_idx);\n\n\t \n\tif (key_idx == -1)\n\t\treturn;\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON)) {\n\t\tret = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\twlvif->default_key = key_idx;\n\n\t \n\tif (wlvif->encryption_type == KEY_WEP) {\n\t\tret = wl12xx_cmd_set_default_wep_key(wl,\n\t\t\t\tkey_idx,\n\t\t\t\twlvif->sta.hlid);\n\t\tif (ret < 0)\n\t\t\tgoto out_sleep;\n\t}\n\nout_sleep:\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\n\nout_unlock:\n\tmutex_unlock(&wl->mutex);\n}\n\nvoid wlcore_regdomain_config(struct wl1271 *wl)\n{\n\tint ret;\n\n\tif (!(wl->quirks & WLCORE_QUIRK_REGDOMAIN_CONF))\n\t\treturn;\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON))\n\t\tgoto out;\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wlcore_cmd_regdomain_config_locked(wl);\n\tif (ret < 0) {\n\t\twl12xx_queue_recovery_work(wl);\n\t\tgoto out;\n\t}\n\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\nout:\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic int wl1271_op_hw_scan(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_scan_request *hw_req)\n{\n\tstruct cfg80211_scan_request *req = &hw_req->req;\n\tstruct wl1271 *wl = hw->priv;\n\tint ret;\n\tu8 *ssid = NULL;\n\tsize_t len = 0;\n\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 hw scan\");\n\n\tif (req->n_ssids) {\n\t\tssid = req->ssids[0].ssid;\n\t\tlen = req->ssids[0].ssid_len;\n\t}\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON)) {\n\t\t \n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tif (find_first_bit(wl->roc_map, WL12XX_MAX_ROLES) < WL12XX_MAX_ROLES) {\n\t\t \n\t\tret = -EBUSY;\n\t\tgoto out_sleep;\n\t}\n\n\tret = wlcore_scan(hw->priv, vif, ssid, len, req);\nout_sleep:\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\nout:\n\tmutex_unlock(&wl->mutex);\n\n\treturn ret;\n}\n\nstatic void wl1271_op_cancel_hw_scan(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tstruct cfg80211_scan_info info = {\n\t\t.aborted = true,\n\t};\n\tint ret;\n\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 cancel hw scan\");\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON))\n\t\tgoto out;\n\n\tif (wl->scan.state == WL1271_SCAN_STATE_IDLE)\n\t\tgoto out;\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (wl->scan.state != WL1271_SCAN_STATE_DONE) {\n\t\tret = wl->ops->scan_stop(wl, wlvif);\n\t\tif (ret < 0)\n\t\t\tgoto out_sleep;\n\t}\n\n\t \n\twl12xx_rearm_tx_watchdog_locked(wl);\n\n\twl->scan.state = WL1271_SCAN_STATE_IDLE;\n\tmemset(wl->scan.scanned_ch, 0, sizeof(wl->scan.scanned_ch));\n\twl->scan_wlvif = NULL;\n\twl->scan.req = NULL;\n\tieee80211_scan_completed(wl->hw, &info);\n\nout_sleep:\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\nout:\n\tmutex_unlock(&wl->mutex);\n\n\tcancel_delayed_work_sync(&wl->scan_complete_work);\n}\n\nstatic int wl1271_op_sched_scan_start(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct cfg80211_sched_scan_request *req,\n\t\t\t\t      struct ieee80211_scan_ies *ies)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tint ret;\n\n\twl1271_debug(DEBUG_MAC80211, \"wl1271_op_sched_scan_start\");\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON)) {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl->ops->sched_scan_start(wl, wlvif, req, ies);\n\tif (ret < 0)\n\t\tgoto out_sleep;\n\n\twl->sched_vif = wlvif;\n\nout_sleep:\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\nout:\n\tmutex_unlock(&wl->mutex);\n\treturn ret;\n}\n\nstatic int wl1271_op_sched_scan_stop(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tint ret;\n\n\twl1271_debug(DEBUG_MAC80211, \"wl1271_op_sched_scan_stop\");\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON))\n\t\tgoto out;\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twl->ops->sched_scan_stop(wl, wlvif);\n\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\nout:\n\tmutex_unlock(&wl->mutex);\n\n\treturn 0;\n}\n\nstatic int wl1271_op_set_frag_threshold(struct ieee80211_hw *hw, u32 value)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tint ret = 0;\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON)) {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl1271_acx_frag_threshold(wl, value);\n\tif (ret < 0)\n\t\twl1271_warning(\"wl1271_op_set_frag_threshold failed: %d\", ret);\n\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\n\nout:\n\tmutex_unlock(&wl->mutex);\n\n\treturn ret;\n}\n\nstatic int wl1271_op_set_rts_threshold(struct ieee80211_hw *hw, u32 value)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tstruct wl12xx_vif *wlvif;\n\tint ret = 0;\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON)) {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twl12xx_for_each_wlvif(wl, wlvif) {\n\t\tret = wl1271_acx_rts_threshold(wl, wlvif, value);\n\t\tif (ret < 0)\n\t\t\twl1271_warning(\"set rts threshold failed: %d\", ret);\n\t}\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\n\nout:\n\tmutex_unlock(&wl->mutex);\n\n\treturn ret;\n}\n\nstatic void wl12xx_remove_ie(struct sk_buff *skb, u8 eid, int ieoffset)\n{\n\tint len;\n\tconst u8 *next, *end = skb->data + skb->len;\n\tu8 *ie = (u8 *)cfg80211_find_ie(eid, skb->data + ieoffset,\n\t\t\t\t\tskb->len - ieoffset);\n\tif (!ie)\n\t\treturn;\n\tlen = ie[1] + 2;\n\tnext = ie + len;\n\tmemmove(ie, next, end - next);\n\tskb_trim(skb, skb->len - len);\n}\n\nstatic void wl12xx_remove_vendor_ie(struct sk_buff *skb,\n\t\t\t\t\t    unsigned int oui, u8 oui_type,\n\t\t\t\t\t    int ieoffset)\n{\n\tint len;\n\tconst u8 *next, *end = skb->data + skb->len;\n\tu8 *ie = (u8 *)cfg80211_find_vendor_ie(oui, oui_type,\n\t\t\t\t\t       skb->data + ieoffset,\n\t\t\t\t\t       skb->len - ieoffset);\n\tif (!ie)\n\t\treturn;\n\tlen = ie[1] + 2;\n\tnext = ie + len;\n\tmemmove(ie, next, end - next);\n\tskb_trim(skb, skb->len - len);\n}\n\nstatic int wl1271_ap_set_probe_resp_tmpl(struct wl1271 *wl, u32 rates,\n\t\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ieee80211_proberesp_get(wl->hw, vif);\n\tif (!skb)\n\t\treturn -EOPNOTSUPP;\n\n\tret = wl1271_cmd_template_set(wl, wlvif->role_id,\n\t\t\t\t      CMD_TEMPL_AP_PROBE_RESPONSE,\n\t\t\t\t      skb->data,\n\t\t\t\t      skb->len, 0,\n\t\t\t\t      rates);\n\tdev_kfree_skb(skb);\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\twl1271_debug(DEBUG_AP, \"probe response updated\");\n\tset_bit(WLVIF_FLAG_AP_PROBE_RESP_SET, &wlvif->flags);\n\nout:\n\treturn ret;\n}\n\nstatic int wl1271_ap_set_probe_resp_tmpl_legacy(struct wl1271 *wl,\n\t\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t\t     u8 *probe_rsp_data,\n\t\t\t\t\t     size_t probe_rsp_len,\n\t\t\t\t\t     u32 rates)\n{\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tu8 probe_rsp_templ[WL1271_CMD_TEMPL_MAX_SIZE];\n\tint ssid_ie_offset, ie_offset, templ_len;\n\tconst u8 *ptr;\n\n\t \n\tif (wlvif->ssid_len > 0)\n\t\treturn wl1271_cmd_template_set(wl, wlvif->role_id,\n\t\t\t\t\t       CMD_TEMPL_AP_PROBE_RESPONSE,\n\t\t\t\t\t       probe_rsp_data,\n\t\t\t\t\t       probe_rsp_len, 0,\n\t\t\t\t\t       rates);\n\n\tif (probe_rsp_len + vif->cfg.ssid_len > WL1271_CMD_TEMPL_MAX_SIZE) {\n\t\twl1271_error(\"probe_rsp template too big\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tie_offset = offsetof(struct ieee80211_mgmt, u.probe_resp.variable);\n\n\tptr = cfg80211_find_ie(WLAN_EID_SSID, probe_rsp_data + ie_offset,\n\t\t\t       probe_rsp_len - ie_offset);\n\tif (!ptr) {\n\t\twl1271_error(\"No SSID in beacon!\");\n\t\treturn -EINVAL;\n\t}\n\n\tssid_ie_offset = ptr - probe_rsp_data;\n\tptr += (ptr[1] + 2);\n\n\tmemcpy(probe_rsp_templ, probe_rsp_data, ssid_ie_offset);\n\n\t \n\tprobe_rsp_templ[ssid_ie_offset] = WLAN_EID_SSID;\n\tprobe_rsp_templ[ssid_ie_offset + 1] = vif->cfg.ssid_len;\n\tmemcpy(probe_rsp_templ + ssid_ie_offset + 2,\n\t       vif->cfg.ssid, vif->cfg.ssid_len);\n\ttempl_len = ssid_ie_offset + 2 + vif->cfg.ssid_len;\n\n\tmemcpy(probe_rsp_templ + ssid_ie_offset + 2 + vif->cfg.ssid_len,\n\t       ptr, probe_rsp_len - (ptr - probe_rsp_data));\n\ttempl_len += probe_rsp_len - (ptr - probe_rsp_data);\n\n\treturn wl1271_cmd_template_set(wl, wlvif->role_id,\n\t\t\t\t       CMD_TEMPL_AP_PROBE_RESPONSE,\n\t\t\t\t       probe_rsp_templ,\n\t\t\t\t       templ_len, 0,\n\t\t\t\t       rates);\n}\n\nstatic int wl1271_bss_erp_info_changed(struct wl1271 *wl,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_bss_conf *bss_conf,\n\t\t\t\t       u32 changed)\n{\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tint ret = 0;\n\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\tif (bss_conf->use_short_slot)\n\t\t\tret = wl1271_acx_slot(wl, wlvif, SLOT_TIME_SHORT);\n\t\telse\n\t\t\tret = wl1271_acx_slot(wl, wlvif, SLOT_TIME_LONG);\n\t\tif (ret < 0) {\n\t\t\twl1271_warning(\"Set slot time failed %d\", ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_PREAMBLE) {\n\t\tif (bss_conf->use_short_preamble)\n\t\t\twl1271_acx_set_preamble(wl, wlvif, ACX_PREAMBLE_SHORT);\n\t\telse\n\t\t\twl1271_acx_set_preamble(wl, wlvif, ACX_PREAMBLE_LONG);\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_CTS_PROT) {\n\t\tif (bss_conf->use_cts_prot)\n\t\t\tret = wl1271_acx_cts_protect(wl, wlvif,\n\t\t\t\t\t\t     CTSPROTECT_ENABLE);\n\t\telse\n\t\t\tret = wl1271_acx_cts_protect(wl, wlvif,\n\t\t\t\t\t\t     CTSPROTECT_DISABLE);\n\t\tif (ret < 0) {\n\t\t\twl1271_warning(\"Set ctsprotect failed %d\", ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int wlcore_set_beacon_template(struct wl1271 *wl,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      bool is_ap)\n{\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tstruct ieee80211_hdr *hdr;\n\tu32 min_rate;\n\tint ret;\n\tint ieoffset = offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\tstruct sk_buff *beacon = ieee80211_beacon_get(wl->hw, vif, 0);\n\tu16 tmpl_id;\n\n\tif (!beacon) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\twl1271_debug(DEBUG_MASTER, \"beacon updated\");\n\n\tret = wl1271_ssid_set(wlvif, beacon, ieoffset);\n\tif (ret < 0) {\n\t\tdev_kfree_skb(beacon);\n\t\tgoto out;\n\t}\n\tmin_rate = wl1271_tx_min_rate_get(wl, wlvif->basic_rate_set);\n\ttmpl_id = is_ap ? CMD_TEMPL_AP_BEACON :\n\t\tCMD_TEMPL_BEACON;\n\tret = wl1271_cmd_template_set(wl, wlvif->role_id, tmpl_id,\n\t\t\t\t      beacon->data,\n\t\t\t\t      beacon->len, 0,\n\t\t\t\t      min_rate);\n\tif (ret < 0) {\n\t\tdev_kfree_skb(beacon);\n\t\tgoto out;\n\t}\n\n\twlvif->wmm_enabled =\n\t\tcfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\tWLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\tbeacon->data + ieoffset,\n\t\t\t\t\tbeacon->len - ieoffset);\n\n\t \n\tif (test_bit(WLVIF_FLAG_AP_PROBE_RESP_SET, &wlvif->flags))\n\t\tgoto end_bcn;\n\n\t \n\twl12xx_remove_ie(beacon, WLAN_EID_TIM, ieoffset);\n\n\t \n\twl12xx_remove_vendor_ie(beacon, WLAN_OUI_WFA,\n\t\t\t\tWLAN_OUI_TYPE_WFA_P2P, ieoffset);\n\n\thdr = (struct ieee80211_hdr *) beacon->data;\n\thdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t IEEE80211_STYPE_PROBE_RESP);\n\tif (is_ap)\n\t\tret = wl1271_ap_set_probe_resp_tmpl_legacy(wl, vif,\n\t\t\t\t\t\t\t   beacon->data,\n\t\t\t\t\t\t\t   beacon->len,\n\t\t\t\t\t\t\t   min_rate);\n\telse\n\t\tret = wl1271_cmd_template_set(wl, wlvif->role_id,\n\t\t\t\t\t      CMD_TEMPL_PROBE_RESPONSE,\n\t\t\t\t\t      beacon->data,\n\t\t\t\t\t      beacon->len, 0,\n\t\t\t\t\t      min_rate);\nend_bcn:\n\tdev_kfree_skb(beacon);\n\tif (ret < 0)\n\t\tgoto out;\n\nout:\n\treturn ret;\n}\n\nstatic int wl1271_bss_beacon_info_changed(struct wl1271 *wl,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  struct ieee80211_bss_conf *bss_conf,\n\t\t\t\t\t  u32 changed)\n{\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tbool is_ap = (wlvif->bss_type == BSS_TYPE_AP_BSS);\n\tint ret = 0;\n\n\tif (changed & BSS_CHANGED_BEACON_INT) {\n\t\twl1271_debug(DEBUG_MASTER, \"beacon interval updated: %d\",\n\t\t\tbss_conf->beacon_int);\n\n\t\twlvif->beacon_int = bss_conf->beacon_int;\n\t}\n\n\tif ((changed & BSS_CHANGED_AP_PROBE_RESP) && is_ap) {\n\t\tu32 rate = wl1271_tx_min_rate_get(wl, wlvif->basic_rate_set);\n\n\t\twl1271_ap_set_probe_resp_tmpl(wl, rate, vif);\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON) {\n\t\tret = wlcore_set_beacon_template(wl, vif, is_ap);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (test_and_clear_bit(WLVIF_FLAG_BEACON_DISABLED,\n\t\t\t\t       &wlvif->flags)) {\n\t\t\tret = wlcore_hw_dfs_master_restart(wl, wlvif);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tif (ret != 0)\n\t\twl1271_error(\"beacon info change failed: %d\", ret);\n\treturn ret;\n}\n\n \nstatic void wl1271_bss_info_changed_ap(struct wl1271 *wl,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_bss_conf *bss_conf,\n\t\t\t\t       u32 changed)\n{\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tint ret = 0;\n\n\tif (changed & BSS_CHANGED_BASIC_RATES) {\n\t\tu32 rates = bss_conf->basic_rates;\n\n\t\twlvif->basic_rate_set = wl1271_tx_enabled_rates_get(wl, rates,\n\t\t\t\t\t\t\t\t wlvif->band);\n\t\twlvif->basic_rate = wl1271_tx_min_rate_get(wl,\n\t\t\t\t\t\t\twlvif->basic_rate_set);\n\n\t\tret = wl1271_init_ap_rates(wl, wlvif);\n\t\tif (ret < 0) {\n\t\t\twl1271_error(\"AP rate policy change failed %d\", ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = wl1271_ap_init_templates(wl, vif);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (!ieee80211_vif_is_mesh(vif)) {\n\t\t\tret = wl1271_ap_set_probe_resp_tmpl(wl,\n\t\t\t\t\t\t\t    wlvif->basic_rate,\n\t\t\t\t\t\t\t    vif);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tret = wlcore_set_beacon_template(wl, vif, true);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = wl1271_bss_beacon_info_changed(wl, vif, bss_conf, changed);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (changed & BSS_CHANGED_BEACON_ENABLED) {\n\t\tif (bss_conf->enable_beacon) {\n\t\t\tif (!test_bit(WLVIF_FLAG_AP_STARTED, &wlvif->flags)) {\n\t\t\t\tret = wl12xx_cmd_role_start_ap(wl, wlvif);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tret = wl1271_ap_init_hwenc(wl, wlvif);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tset_bit(WLVIF_FLAG_AP_STARTED, &wlvif->flags);\n\t\t\t\twl1271_debug(DEBUG_AP, \"started AP\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (test_bit(WLVIF_FLAG_AP_STARTED, &wlvif->flags)) {\n\t\t\t\t \n\t\t\t\tif (test_bit(wlvif->role_id, wl->roc_map))\n\t\t\t\t\twl12xx_croc(wl, wlvif->role_id);\n\n\t\t\t\tret = wl12xx_cmd_role_stop_ap(wl, wlvif);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tclear_bit(WLVIF_FLAG_AP_STARTED, &wlvif->flags);\n\t\t\t\tclear_bit(WLVIF_FLAG_AP_PROBE_RESP_SET,\n\t\t\t\t\t  &wlvif->flags);\n\t\t\t\twl1271_debug(DEBUG_AP, \"stopped AP\");\n\t\t\t}\n\t\t}\n\t}\n\n\tret = wl1271_bss_erp_info_changed(wl, vif, bss_conf, changed);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tif ((changed & BSS_CHANGED_HT) &&\n\t    (bss_conf->chandef.width != NL80211_CHAN_WIDTH_20_NOHT)) {\n\t\tret = wl1271_acx_set_ht_information(wl, wlvif,\n\t\t\t\t\tbss_conf->ht_operation_mode);\n\t\tif (ret < 0) {\n\t\t\twl1271_warning(\"Set ht information failed %d\", ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn;\n}\n\nstatic int wlcore_set_bssid(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t    struct ieee80211_vif *vif, u32 sta_rate_set)\n{\n\tstruct ieee80211_bss_conf *bss_conf = &vif->bss_conf;\n\tu32 rates;\n\tint ret;\n\n\twl1271_debug(DEBUG_MAC80211,\n\t     \"changed_bssid: %pM, aid: %d, bcn_int: %d, brates: 0x%x sta_rate_set: 0x%x\",\n\t     bss_conf->bssid, vif->cfg.aid,\n\t     bss_conf->beacon_int,\n\t     bss_conf->basic_rates, sta_rate_set);\n\n\twlvif->beacon_int = bss_conf->beacon_int;\n\trates = bss_conf->basic_rates;\n\twlvif->basic_rate_set =\n\t\twl1271_tx_enabled_rates_get(wl, rates,\n\t\t\t\t\t    wlvif->band);\n\twlvif->basic_rate =\n\t\twl1271_tx_min_rate_get(wl,\n\t\t\t\t       wlvif->basic_rate_set);\n\n\tif (sta_rate_set)\n\t\twlvif->rate_set =\n\t\t\twl1271_tx_enabled_rates_get(wl,\n\t\t\t\t\t\tsta_rate_set,\n\t\t\t\t\t\twlvif->band);\n\n\t \n\tif (wl->sched_vif == wlvif)\n\t\twl->ops->sched_scan_stop(wl, wlvif);\n\n\tret = wl1271_acx_sta_rate_policies(wl, wlvif);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl12xx_cmd_build_null_data(wl, wlvif);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1271_build_qos_null_data(wl, wl12xx_wlvif_to_vif(wlvif));\n\tif (ret < 0)\n\t\treturn ret;\n\n\twlcore_set_ssid(wl, wlvif);\n\n\tset_bit(WLVIF_FLAG_IN_USE, &wlvif->flags);\n\n\treturn 0;\n}\n\nstatic int wlcore_clear_bssid(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tint ret;\n\n\t \n\twl1271_set_band_rate(wl, wlvif);\n\twlvif->basic_rate = wl1271_tx_min_rate_get(wl, wlvif->basic_rate_set);\n\n\tret = wl1271_acx_sta_rate_policies(wl, wlvif);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (wlvif->bss_type == BSS_TYPE_STA_BSS &&\n\t    test_bit(WLVIF_FLAG_IN_USE, &wlvif->flags)) {\n\t\tret = wl12xx_cmd_role_stop_sta(wl, wlvif);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tclear_bit(WLVIF_FLAG_IN_USE, &wlvif->flags);\n\treturn 0;\n}\n \nstatic void wl1271_bss_info_changed_sta(struct wl1271 *wl,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tstruct ieee80211_bss_conf *bss_conf,\n\t\t\t\t\tu32 changed)\n{\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tbool do_join = false;\n\tbool is_ibss = (wlvif->bss_type == BSS_TYPE_IBSS);\n\tbool ibss_joined = false;\n\tu32 sta_rate_set = 0;\n\tint ret;\n\tstruct ieee80211_sta *sta;\n\tbool sta_exists = false;\n\tstruct ieee80211_sta_ht_cap sta_ht_cap;\n\n\tif (is_ibss) {\n\t\tret = wl1271_bss_beacon_info_changed(wl, vif, bss_conf,\n\t\t\t\t\t\t     changed);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (changed & BSS_CHANGED_IBSS) {\n\t\tif (vif->cfg.ibss_joined) {\n\t\t\tset_bit(WLVIF_FLAG_IBSS_JOINED, &wlvif->flags);\n\t\t\tibss_joined = true;\n\t\t} else {\n\t\t\twlcore_unset_assoc(wl, wlvif);\n\t\t\twl12xx_cmd_role_stop_sta(wl, wlvif);\n\t\t}\n\t}\n\n\tif ((changed & BSS_CHANGED_BEACON_INT) && ibss_joined)\n\t\tdo_join = true;\n\n\t \n\tif ((changed & BSS_CHANGED_BEACON) && ibss_joined)\n\t\tdo_join = true;\n\n\tif ((changed & BSS_CHANGED_BEACON_ENABLED) && ibss_joined) {\n\t\twl1271_debug(DEBUG_ADHOC, \"ad-hoc beaconing: %s\",\n\t\t\t     bss_conf->enable_beacon ? \"enabled\" : \"disabled\");\n\n\t\tdo_join = true;\n\t}\n\n\tif (changed & BSS_CHANGED_IDLE && !is_ibss)\n\t\twl1271_sta_handle_idle(wl, wlvif, vif->cfg.idle);\n\n\tif (changed & BSS_CHANGED_CQM) {\n\t\tbool enable = false;\n\t\tif (bss_conf->cqm_rssi_thold)\n\t\t\tenable = true;\n\t\tret = wl1271_acx_rssi_snr_trigger(wl, wlvif, enable,\n\t\t\t\t\t\t  bss_conf->cqm_rssi_thold,\n\t\t\t\t\t\t  bss_conf->cqm_rssi_hyst);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\twlvif->rssi_thold = bss_conf->cqm_rssi_thold;\n\t}\n\n\tif (changed & (BSS_CHANGED_BSSID | BSS_CHANGED_HT |\n\t\t       BSS_CHANGED_ASSOC)) {\n\t\trcu_read_lock();\n\t\tsta = ieee80211_find_sta(vif, bss_conf->bssid);\n\t\tif (sta) {\n\t\t\tu8 *rx_mask = sta->deflink.ht_cap.mcs.rx_mask;\n\n\t\t\t \n\t\t\tsta_rate_set = sta->deflink.supp_rates[wlvif->band];\n\t\t\tif (sta->deflink.ht_cap.ht_supported)\n\t\t\t\tsta_rate_set |=\n\t\t\t\t\t(rx_mask[0] << HW_HT_RATES_OFFSET) |\n\t\t\t\t\t(rx_mask[1] << HW_MIMO_RATES_OFFSET);\n\t\t\tsta_ht_cap = sta->deflink.ht_cap;\n\t\t\tsta_exists = true;\n\t\t}\n\n\t\trcu_read_unlock();\n\t}\n\n\tif (changed & BSS_CHANGED_BSSID) {\n\t\tif (!is_zero_ether_addr(bss_conf->bssid)) {\n\t\t\tret = wlcore_set_bssid(wl, wlvif, vif,\n\t\t\t\t\t       sta_rate_set);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\t \n\t\t\tdo_join = true;\n\t\t} else {\n\t\t\tret = wlcore_clear_bssid(wl, wlvif);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_IBSS) {\n\t\twl1271_debug(DEBUG_ADHOC, \"ibss_joined: %d\",\n\t\t\t     vif->cfg.ibss_joined);\n\n\t\tif (vif->cfg.ibss_joined) {\n\t\t\tu32 rates = bss_conf->basic_rates;\n\t\t\twlvif->basic_rate_set =\n\t\t\t\twl1271_tx_enabled_rates_get(wl, rates,\n\t\t\t\t\t\t\t    wlvif->band);\n\t\t\twlvif->basic_rate =\n\t\t\t\twl1271_tx_min_rate_get(wl,\n\t\t\t\t\t\t       wlvif->basic_rate_set);\n\n\t\t\t \n\t\t\twlvif->rate_set = CONF_TX_IBSS_DEFAULT_RATES;\n\t\t\tret = wl1271_acx_sta_rate_policies(wl, wlvif);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif ((changed & BSS_CHANGED_BEACON_INFO) && bss_conf->dtim_period) {\n\t\t \n\t\tret = wl1271_acx_beacon_filter_opt(wl, wlvif, true);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = wl1271_bss_erp_info_changed(wl, vif, bss_conf, changed);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (do_join) {\n\t\tret = wlcore_join(wl, wlvif);\n\t\tif (ret < 0) {\n\t\t\twl1271_warning(\"cmd join failed %d\", ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_ASSOC) {\n\t\tif (vif->cfg.assoc) {\n\t\t\tret = wlcore_set_assoc(wl, wlvif, bss_conf,\n\t\t\t\t\t       sta_rate_set);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tif (test_bit(WLVIF_FLAG_STA_AUTHORIZED, &wlvif->flags))\n\t\t\t\twl12xx_set_authorized(wl, wlvif);\n\t\t} else {\n\t\t\twlcore_unset_assoc(wl, wlvif);\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_PS) {\n\t\tif (vif->cfg.ps &&\n\t\t    test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags) &&\n\t\t    !test_bit(WLVIF_FLAG_IN_PS, &wlvif->flags)) {\n\t\t\tint ps_mode;\n\t\t\tchar *ps_mode_str;\n\n\t\t\tif (wl->conf.conn.forced_ps) {\n\t\t\t\tps_mode = STATION_POWER_SAVE_MODE;\n\t\t\t\tps_mode_str = \"forced\";\n\t\t\t} else {\n\t\t\t\tps_mode = STATION_AUTO_PS_MODE;\n\t\t\t\tps_mode_str = \"auto\";\n\t\t\t}\n\n\t\t\twl1271_debug(DEBUG_PSM, \"%s ps enabled\", ps_mode_str);\n\n\t\t\tret = wl1271_ps_set_mode(wl, wlvif, ps_mode);\n\t\t\tif (ret < 0)\n\t\t\t\twl1271_warning(\"enter %s ps failed %d\",\n\t\t\t\t\t       ps_mode_str, ret);\n\t\t} else if (!vif->cfg.ps &&\n\t\t\t   test_bit(WLVIF_FLAG_IN_PS, &wlvif->flags)) {\n\t\t\twl1271_debug(DEBUG_PSM, \"auto ps disabled\");\n\n\t\t\tret = wl1271_ps_set_mode(wl, wlvif,\n\t\t\t\t\t\t STATION_ACTIVE_MODE);\n\t\t\tif (ret < 0)\n\t\t\t\twl1271_warning(\"exit auto ps failed %d\", ret);\n\t\t}\n\t}\n\n\t \n\tif (sta_exists) {\n\t\tbool enabled =\n\t\t\tbss_conf->chandef.width != NL80211_CHAN_WIDTH_20_NOHT;\n\n\t\tret = wlcore_hw_set_peer_cap(wl,\n\t\t\t\t\t     &sta_ht_cap,\n\t\t\t\t\t     enabled,\n\t\t\t\t\t     wlvif->rate_set,\n\t\t\t\t\t     wlvif->sta.hlid);\n\t\tif (ret < 0) {\n\t\t\twl1271_warning(\"Set ht cap failed %d\", ret);\n\t\t\tgoto out;\n\n\t\t}\n\n\t\tif (enabled) {\n\t\t\tret = wl1271_acx_set_ht_information(wl, wlvif,\n\t\t\t\t\t\tbss_conf->ht_operation_mode);\n\t\t\tif (ret < 0) {\n\t\t\t\twl1271_warning(\"Set ht information failed %d\",\n\t\t\t\t\t       ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif ((changed & BSS_CHANGED_ARP_FILTER) ||\n\t    (!is_ibss && (changed & BSS_CHANGED_QOS))) {\n\t\t__be32 addr = vif->cfg.arp_addr_list[0];\n\t\twlvif->sta.qos = bss_conf->qos;\n\t\tWARN_ON(wlvif->bss_type != BSS_TYPE_STA_BSS);\n\n\t\tif (vif->cfg.arp_addr_cnt == 1 && vif->cfg.assoc) {\n\t\t\twlvif->ip_addr = addr;\n\t\t\t \n\t\t\tret = wl1271_cmd_build_arp_rsp(wl, wlvif);\n\t\t\tif (ret < 0) {\n\t\t\t\twl1271_warning(\"build arp rsp failed: %d\", ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = wl1271_acx_arp_ip_filter(wl, wlvif,\n\t\t\t\t(ACX_ARP_FILTER_ARP_FILTERING |\n\t\t\t\t ACX_ARP_FILTER_AUTO_ARP),\n\t\t\t\taddr);\n\t\t} else {\n\t\t\twlvif->ip_addr = 0;\n\t\t\tret = wl1271_acx_arp_ip_filter(wl, wlvif, 0, addr);\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn;\n}\n\nstatic void wl1271_op_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_bss_conf *bss_conf,\n\t\t\t\t       u64 changed)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tbool is_ap = (wlvif->bss_type == BSS_TYPE_AP_BSS);\n\tint ret;\n\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 bss info role %d changed 0x%x\",\n\t\t     wlvif->role_id, (int)changed);\n\n\t \n\tif (!is_ap && (changed & BSS_CHANGED_ASSOC))\n\t\tcancel_delayed_work_sync(&wlvif->connection_loss_work);\n\n\tif (is_ap && (changed & BSS_CHANGED_BEACON_ENABLED) &&\n\t    !bss_conf->enable_beacon)\n\t\twl1271_tx_flush(wl);\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON))\n\t\tgoto out;\n\n\tif (unlikely(!test_bit(WLVIF_FLAG_INITIALIZED, &wlvif->flags)))\n\t\tgoto out;\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif ((changed & BSS_CHANGED_TXPOWER) &&\n\t    bss_conf->txpower != wlvif->power_level) {\n\n\t\tret = wl1271_acx_tx_power(wl, wlvif, bss_conf->txpower);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\twlvif->power_level = bss_conf->txpower;\n\t}\n\n\tif (is_ap)\n\t\twl1271_bss_info_changed_ap(wl, vif, bss_conf, changed);\n\telse\n\t\twl1271_bss_info_changed_sta(wl, vif, bss_conf, changed);\n\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\n\nout:\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic int wlcore_op_add_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_chanctx_conf *ctx)\n{\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 add chanctx %d (type %d)\",\n\t\t     ieee80211_frequency_to_channel(ctx->def.chan->center_freq),\n\t\t     cfg80211_get_chandef_type(&ctx->def));\n\treturn 0;\n}\n\nstatic void wlcore_op_remove_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_chanctx_conf *ctx)\n{\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 remove chanctx %d (type %d)\",\n\t\t     ieee80211_frequency_to_channel(ctx->def.chan->center_freq),\n\t\t     cfg80211_get_chandef_type(&ctx->def));\n}\n\nstatic void wlcore_op_change_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_chanctx_conf *ctx,\n\t\t\t\t     u32 changed)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tstruct wl12xx_vif *wlvif;\n\tint ret;\n\tint channel = ieee80211_frequency_to_channel(\n\t\tctx->def.chan->center_freq);\n\n\twl1271_debug(DEBUG_MAC80211,\n\t\t     \"mac80211 change chanctx %d (type %d) changed 0x%x\",\n\t\t     channel, cfg80211_get_chandef_type(&ctx->def), changed);\n\n\tmutex_lock(&wl->mutex);\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twl12xx_for_each_wlvif(wl, wlvif) {\n\t\tstruct ieee80211_vif *vif = wl12xx_wlvif_to_vif(wlvif);\n\n\t\trcu_read_lock();\n\t\tif (rcu_access_pointer(vif->bss_conf.chanctx_conf) != ctx) {\n\t\t\trcu_read_unlock();\n\t\t\tcontinue;\n\t\t}\n\t\trcu_read_unlock();\n\n\t\t \n\t\tif (changed & IEEE80211_CHANCTX_CHANGE_RADAR &&\n\t\t    wlvif->bss_type == BSS_TYPE_AP_BSS &&\n\t\t    ctx->radar_enabled && !wlvif->radar_enabled &&\n\t\t    ctx->def.chan->dfs_state == NL80211_DFS_USABLE) {\n\t\t\twl1271_debug(DEBUG_MAC80211, \"Start radar detection\");\n\t\t\twlcore_hw_set_cac(wl, wlvif, true);\n\t\t\twlvif->radar_enabled = true;\n\t\t}\n\t}\n\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\nout:\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic int wlcore_op_assign_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tstruct ieee80211_bss_conf *link_conf,\n\t\t\t\t\tstruct ieee80211_chanctx_conf *ctx)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tint channel = ieee80211_frequency_to_channel(\n\t\tctx->def.chan->center_freq);\n\tint ret = -EINVAL;\n\n\twl1271_debug(DEBUG_MAC80211,\n\t\t     \"mac80211 assign chanctx (role %d) %d (type %d) (radar %d dfs_state %d)\",\n\t\t     wlvif->role_id, channel,\n\t\t     cfg80211_get_chandef_type(&ctx->def),\n\t\t     ctx->radar_enabled, ctx->def.chan->dfs_state);\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON))\n\t\tgoto out;\n\n\tif (unlikely(!test_bit(WLVIF_FLAG_INITIALIZED, &wlvif->flags)))\n\t\tgoto out;\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twlvif->band = ctx->def.chan->band;\n\twlvif->channel = channel;\n\twlvif->channel_type = cfg80211_get_chandef_type(&ctx->def);\n\n\t \n\twl1271_set_band_rate(wl, wlvif);\n\n\tif (ctx->radar_enabled &&\n\t    ctx->def.chan->dfs_state == NL80211_DFS_USABLE) {\n\t\twl1271_debug(DEBUG_MAC80211, \"Start radar detection\");\n\t\twlcore_hw_set_cac(wl, wlvif, true);\n\t\twlvif->radar_enabled = true;\n\t}\n\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\nout:\n\tmutex_unlock(&wl->mutex);\n\n\treturn 0;\n}\n\nstatic void wlcore_op_unassign_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t   struct ieee80211_bss_conf *link_conf,\n\t\t\t\t\t   struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tint ret;\n\n\twl1271_debug(DEBUG_MAC80211,\n\t\t     \"mac80211 unassign chanctx (role %d) %d (type %d)\",\n\t\t     wlvif->role_id,\n\t\t     ieee80211_frequency_to_channel(ctx->def.chan->center_freq),\n\t\t     cfg80211_get_chandef_type(&ctx->def));\n\n\twl1271_tx_flush(wl);\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON))\n\t\tgoto out;\n\n\tif (unlikely(!test_bit(WLVIF_FLAG_INITIALIZED, &wlvif->flags)))\n\t\tgoto out;\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (wlvif->radar_enabled) {\n\t\twl1271_debug(DEBUG_MAC80211, \"Stop radar detection\");\n\t\twlcore_hw_set_cac(wl, wlvif, false);\n\t\twlvif->radar_enabled = false;\n\t}\n\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\nout:\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic int __wlcore_switch_vif_chan(struct wl1271 *wl,\n\t\t\t\t    struct wl12xx_vif *wlvif,\n\t\t\t\t    struct ieee80211_chanctx_conf *new_ctx)\n{\n\tint channel = ieee80211_frequency_to_channel(\n\t\tnew_ctx->def.chan->center_freq);\n\n\twl1271_debug(DEBUG_MAC80211,\n\t\t     \"switch vif (role %d) %d -> %d chan_type: %d\",\n\t\t     wlvif->role_id, wlvif->channel, channel,\n\t\t     cfg80211_get_chandef_type(&new_ctx->def));\n\n\tif (WARN_ON_ONCE(wlvif->bss_type != BSS_TYPE_AP_BSS))\n\t\treturn 0;\n\n\tWARN_ON(!test_bit(WLVIF_FLAG_BEACON_DISABLED, &wlvif->flags));\n\n\tif (wlvif->radar_enabled) {\n\t\twl1271_debug(DEBUG_MAC80211, \"Stop radar detection\");\n\t\twlcore_hw_set_cac(wl, wlvif, false);\n\t\twlvif->radar_enabled = false;\n\t}\n\n\twlvif->band = new_ctx->def.chan->band;\n\twlvif->channel = channel;\n\twlvif->channel_type = cfg80211_get_chandef_type(&new_ctx->def);\n\n\t \n\tif (new_ctx->radar_enabled) {\n\t\twl1271_debug(DEBUG_MAC80211, \"Start radar detection\");\n\t\twlcore_hw_set_cac(wl, wlvif, true);\n\t\twlvif->radar_enabled = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nwlcore_op_switch_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif_chanctx_switch *vifs,\n\t\t\t     int n_vifs,\n\t\t\t     enum ieee80211_chanctx_switch_mode mode)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tint i, ret;\n\n\twl1271_debug(DEBUG_MAC80211,\n\t\t     \"mac80211 switch chanctx n_vifs %d mode %d\",\n\t\t     n_vifs, mode);\n\n\tmutex_lock(&wl->mutex);\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfor (i = 0; i < n_vifs; i++) {\n\t\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vifs[i].vif);\n\n\t\tret = __wlcore_switch_vif_chan(wl, wlvif, vifs[i].new_ctx);\n\t\tif (ret)\n\t\t\tgoto out_sleep;\n\t}\nout_sleep:\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\nout:\n\tmutex_unlock(&wl->mutex);\n\n\treturn 0;\n}\n\nstatic int wl1271_op_conf_tx(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     unsigned int link_id, u16 queue,\n\t\t\t     const struct ieee80211_tx_queue_params *params)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tu8 ps_scheme;\n\tint ret = 0;\n\n\tif (wlcore_is_p2p_mgmt(wlvif))\n\t\treturn 0;\n\n\tmutex_lock(&wl->mutex);\n\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 conf tx %d\", queue);\n\n\tif (params->uapsd)\n\t\tps_scheme = CONF_PS_SCHEME_UPSD_TRIGGER;\n\telse\n\t\tps_scheme = CONF_PS_SCHEME_LEGACY;\n\n\tif (!test_bit(WLVIF_FLAG_INITIALIZED, &wlvif->flags))\n\t\tgoto out;\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = wl1271_acx_ac_cfg(wl, wlvif, wl1271_tx_get_queue(queue),\n\t\t\t\tparams->cw_min, params->cw_max,\n\t\t\t\tparams->aifs, params->txop << 5);\n\tif (ret < 0)\n\t\tgoto out_sleep;\n\n\tret = wl1271_acx_tid_cfg(wl, wlvif, wl1271_tx_get_queue(queue),\n\t\t\t\t CONF_CHANNEL_TYPE_EDCF,\n\t\t\t\t wl1271_tx_get_queue(queue),\n\t\t\t\t ps_scheme, CONF_ACK_POLICY_LEGACY,\n\t\t\t\t 0, 0);\n\nout_sleep:\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\n\nout:\n\tmutex_unlock(&wl->mutex);\n\n\treturn ret;\n}\n\nstatic u64 wl1271_op_get_tsf(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif)\n{\n\n\tstruct wl1271 *wl = hw->priv;\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tu64 mactime = ULLONG_MAX;\n\tint ret;\n\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 get tsf\");\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON))\n\t\tgoto out;\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl12xx_acx_tsf_info(wl, wlvif, &mactime);\n\tif (ret < 0)\n\t\tgoto out_sleep;\n\nout_sleep:\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\n\nout:\n\tmutex_unlock(&wl->mutex);\n\treturn mactime;\n}\n\nstatic int wl1271_op_get_survey(struct ieee80211_hw *hw, int idx,\n\t\t\t\tstruct survey_info *survey)\n{\n\tstruct ieee80211_conf *conf = &hw->conf;\n\n\tif (idx != 0)\n\t\treturn -ENOENT;\n\n\tsurvey->channel = conf->chandef.chan;\n\tsurvey->filled = 0;\n\treturn 0;\n}\n\nstatic int wl1271_allocate_sta(struct wl1271 *wl,\n\t\t\t     struct wl12xx_vif *wlvif,\n\t\t\t     struct ieee80211_sta *sta)\n{\n\tstruct wl1271_station *wl_sta;\n\tint ret;\n\n\n\tif (wl->active_sta_count >= wl->max_ap_stations) {\n\t\twl1271_warning(\"could not allocate HLID - too much stations\");\n\t\treturn -EBUSY;\n\t}\n\n\twl_sta = (struct wl1271_station *)sta->drv_priv;\n\tret = wl12xx_allocate_link(wl, wlvif, &wl_sta->hlid);\n\tif (ret < 0) {\n\t\twl1271_warning(\"could not allocate HLID - too many links\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\twl->links[wl_sta->hlid].total_freed_pkts = wl_sta->total_freed_pkts;\n\n\tset_bit(wl_sta->hlid, wlvif->ap.sta_hlid_map);\n\tmemcpy(wl->links[wl_sta->hlid].addr, sta->addr, ETH_ALEN);\n\twl->active_sta_count++;\n\treturn 0;\n}\n\nvoid wl1271_free_sta(struct wl1271 *wl, struct wl12xx_vif *wlvif, u8 hlid)\n{\n\tif (!test_bit(hlid, wlvif->ap.sta_hlid_map))\n\t\treturn;\n\n\tclear_bit(hlid, wlvif->ap.sta_hlid_map);\n\t__clear_bit(hlid, &wl->ap_ps_map);\n\t__clear_bit(hlid, &wl->ap_fw_ps_map);\n\n\t \n\twlcore_save_freed_pkts_addr(wl, wlvif, hlid, wl->links[hlid].addr);\n\n\twl12xx_free_link(wl, wlvif, &hlid);\n\twl->active_sta_count--;\n\n\t \n\tif (wl->active_sta_count == 0)\n\t\twl12xx_rearm_tx_watchdog_locked(wl);\n}\n\nstatic int wl12xx_sta_add(struct wl1271 *wl,\n\t\t\t  struct wl12xx_vif *wlvif,\n\t\t\t  struct ieee80211_sta *sta)\n{\n\tstruct wl1271_station *wl_sta;\n\tint ret = 0;\n\tu8 hlid;\n\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 add sta %d\", (int)sta->aid);\n\n\tret = wl1271_allocate_sta(wl, wlvif, sta);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twl_sta = (struct wl1271_station *)sta->drv_priv;\n\thlid = wl_sta->hlid;\n\n\tret = wl12xx_cmd_add_peer(wl, wlvif, sta, hlid);\n\tif (ret < 0)\n\t\twl1271_free_sta(wl, wlvif, hlid);\n\n\treturn ret;\n}\n\nstatic int wl12xx_sta_remove(struct wl1271 *wl,\n\t\t\t     struct wl12xx_vif *wlvif,\n\t\t\t     struct ieee80211_sta *sta)\n{\n\tstruct wl1271_station *wl_sta;\n\tint ret = 0, id;\n\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 remove sta %d\", (int)sta->aid);\n\n\twl_sta = (struct wl1271_station *)sta->drv_priv;\n\tid = wl_sta->hlid;\n\tif (WARN_ON(!test_bit(id, wlvif->ap.sta_hlid_map)))\n\t\treturn -EINVAL;\n\n\tret = wl12xx_cmd_remove_peer(wl, wlvif, wl_sta->hlid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twl1271_free_sta(wl, wlvif, wl_sta->hlid);\n\treturn ret;\n}\n\nstatic void wlcore_roc_if_possible(struct wl1271 *wl,\n\t\t\t\t   struct wl12xx_vif *wlvif)\n{\n\tif (find_first_bit(wl->roc_map,\n\t\t\t   WL12XX_MAX_ROLES) < WL12XX_MAX_ROLES)\n\t\treturn;\n\n\tif (WARN_ON(wlvif->role_id == WL12XX_INVALID_ROLE_ID))\n\t\treturn;\n\n\twl12xx_roc(wl, wlvif, wlvif->role_id, wlvif->band, wlvif->channel);\n}\n\n \nvoid wlcore_update_inconn_sta(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t      struct wl1271_station *wl_sta, bool in_conn)\n{\n\tif (in_conn) {\n\t\tif (WARN_ON(wl_sta && wl_sta->in_connection))\n\t\t\treturn;\n\n\t\tif (!wlvif->ap_pending_auth_reply &&\n\t\t    !wlvif->inconn_count)\n\t\t\twlcore_roc_if_possible(wl, wlvif);\n\n\t\tif (wl_sta) {\n\t\t\twl_sta->in_connection = true;\n\t\t\twlvif->inconn_count++;\n\t\t} else {\n\t\t\twlvif->ap_pending_auth_reply = true;\n\t\t}\n\t} else {\n\t\tif (wl_sta && !wl_sta->in_connection)\n\t\t\treturn;\n\n\t\tif (WARN_ON(!wl_sta && !wlvif->ap_pending_auth_reply))\n\t\t\treturn;\n\n\t\tif (WARN_ON(wl_sta && !wlvif->inconn_count))\n\t\t\treturn;\n\n\t\tif (wl_sta) {\n\t\t\twl_sta->in_connection = false;\n\t\t\twlvif->inconn_count--;\n\t\t} else {\n\t\t\twlvif->ap_pending_auth_reply = false;\n\t\t}\n\n\t\tif (!wlvif->inconn_count && !wlvif->ap_pending_auth_reply &&\n\t\t    test_bit(wlvif->role_id, wl->roc_map))\n\t\t\twl12xx_croc(wl, wlvif->role_id);\n\t}\n}\n\nstatic int wl12xx_update_sta_state(struct wl1271 *wl,\n\t\t\t\t   struct wl12xx_vif *wlvif,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   enum ieee80211_sta_state old_state,\n\t\t\t\t   enum ieee80211_sta_state new_state)\n{\n\tstruct wl1271_station *wl_sta;\n\tbool is_ap = wlvif->bss_type == BSS_TYPE_AP_BSS;\n\tbool is_sta = wlvif->bss_type == BSS_TYPE_STA_BSS;\n\tint ret;\n\n\twl_sta = (struct wl1271_station *)sta->drv_priv;\n\n\t \n\tif (is_ap &&\n\t    old_state == IEEE80211_STA_NOTEXIST &&\n\t    new_state == IEEE80211_STA_NONE) {\n\t\tret = wl12xx_sta_add(wl, wlvif, sta);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\twlcore_update_inconn_sta(wl, wlvif, wl_sta, true);\n\t}\n\n\t \n\tif (is_ap &&\n\t    old_state == IEEE80211_STA_NONE &&\n\t    new_state == IEEE80211_STA_NOTEXIST) {\n\t\t \n\t\twl12xx_sta_remove(wl, wlvif, sta);\n\n\t\twlcore_update_inconn_sta(wl, wlvif, wl_sta, false);\n\t}\n\n\t \n\tif (is_ap &&\n\t    new_state == IEEE80211_STA_AUTHORIZED) {\n\t\tret = wl12xx_cmd_set_peer_state(wl, wlvif, wl_sta->hlid);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = wl12xx_cmd_add_peer(wl, wlvif, sta, wl_sta->hlid);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = wl1271_acx_set_ht_capabilities(wl, &sta->deflink.ht_cap,\n\t\t\t\t\t\t     true,\n\t\t\t\t\t\t     wl_sta->hlid);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\twlcore_update_inconn_sta(wl, wlvif, wl_sta, false);\n\t}\n\n\t \n\tif (is_sta &&\n\t    new_state == IEEE80211_STA_AUTHORIZED) {\n\t\tset_bit(WLVIF_FLAG_STA_AUTHORIZED, &wlvif->flags);\n\t\tret = wl12xx_set_authorized(wl, wlvif);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (is_sta &&\n\t    old_state == IEEE80211_STA_AUTHORIZED &&\n\t    new_state == IEEE80211_STA_ASSOC) {\n\t\tclear_bit(WLVIF_FLAG_STA_AUTHORIZED, &wlvif->flags);\n\t\tclear_bit(WLVIF_FLAG_STA_STATE_SENT, &wlvif->flags);\n\t}\n\n\t \n\tif (is_sta &&\n\t    old_state == IEEE80211_STA_ASSOC &&\n\t    new_state == IEEE80211_STA_AUTH) {\n\t\twlcore_save_freed_pkts(wl, wlvif, wlvif->sta.hlid, sta);\n\t\twlvif->total_freed_pkts = 0;\n\t}\n\n\t \n\tif (is_sta &&\n\t    old_state == IEEE80211_STA_AUTH &&\n\t    new_state == IEEE80211_STA_ASSOC) {\n\t\twlvif->total_freed_pkts = wl_sta->total_freed_pkts;\n\t}\n\n\t \n\tif (is_sta &&\n\t    (new_state == IEEE80211_STA_AUTHORIZED ||\n\t     new_state == IEEE80211_STA_NOTEXIST)) {\n\t\tif (test_bit(wlvif->role_id, wl->roc_map))\n\t\t\twl12xx_croc(wl, wlvif->role_id);\n\t}\n\n\tif (is_sta &&\n\t    old_state == IEEE80211_STA_NOTEXIST &&\n\t    new_state == IEEE80211_STA_NONE) {\n\t\tif (find_first_bit(wl->roc_map,\n\t\t\t\t   WL12XX_MAX_ROLES) >= WL12XX_MAX_ROLES) {\n\t\t\tWARN_ON(wlvif->role_id == WL12XX_INVALID_ROLE_ID);\n\t\t\twl12xx_roc(wl, wlvif, wlvif->role_id,\n\t\t\t\t   wlvif->band, wlvif->channel);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int wl12xx_op_sta_state(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_sta *sta,\n\t\t\t       enum ieee80211_sta_state old_state,\n\t\t\t       enum ieee80211_sta_state new_state)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tint ret;\n\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 sta %d state=%d->%d\",\n\t\t     sta->aid, old_state, new_state);\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl12xx_update_sta_state(wl, wlvif, sta, old_state, new_state);\n\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\nout:\n\tmutex_unlock(&wl->mutex);\n\tif (new_state < old_state)\n\t\treturn 0;\n\treturn ret;\n}\n\nstatic int wl1271_op_ampdu_action(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_ampdu_params *params)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tint ret;\n\tu8 hlid, *ba_bitmap;\n\tstruct ieee80211_sta *sta = params->sta;\n\tenum ieee80211_ampdu_mlme_action action = params->action;\n\tu16 tid = params->tid;\n\tu16 *ssn = &params->ssn;\n\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 ampdu action %d tid %d\", action,\n\t\t     tid);\n\n\t \n\tif (WARN_ON(tid > 0xFF))\n\t\treturn -ENOTSUPP;\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON)) {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (wlvif->bss_type == BSS_TYPE_STA_BSS) {\n\t\thlid = wlvif->sta.hlid;\n\t} else if (wlvif->bss_type == BSS_TYPE_AP_BSS) {\n\t\tstruct wl1271_station *wl_sta;\n\n\t\twl_sta = (struct wl1271_station *)sta->drv_priv;\n\t\thlid = wl_sta->hlid;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tba_bitmap = &wl->links[hlid].ba_bitmap;\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 ampdu: Rx tid %d action %d\",\n\t\t     tid, action);\n\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_RX_START:\n\t\tif (!wlvif->ba_support || !wlvif->ba_allowed) {\n\t\t\tret = -ENOTSUPP;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wl->ba_rx_session_count >= wl->ba_rx_session_count_max) {\n\t\t\tret = -EBUSY;\n\t\t\twl1271_debug(DEBUG_RX, \"exceeded max RX BA sessions\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*ba_bitmap & BIT(tid)) {\n\t\t\tret = -EINVAL;\n\t\t\twl1271_error(\"cannot enable RX BA session on active \"\n\t\t\t\t     \"tid: %d\", tid);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = wl12xx_acx_set_ba_receiver_session(wl, tid, *ssn, true,\n\t\t\t\thlid,\n\t\t\t\tparams->buf_size);\n\n\t\tif (!ret) {\n\t\t\t*ba_bitmap |= BIT(tid);\n\t\t\twl->ba_rx_session_count++;\n\t\t}\n\t\tbreak;\n\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\tif (!(*ba_bitmap & BIT(tid))) {\n\t\t\t \n\t\t\twl1271_debug(DEBUG_MAC80211,\n\t\t\t\t     \"no active RX BA session on tid: %d\",\n\t\t\t\t     tid);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = wl12xx_acx_set_ba_receiver_session(wl, tid, 0, false,\n\t\t\t\t\t\t\t hlid, 0);\n\t\tif (!ret) {\n\t\t\t*ba_bitmap &= ~BIT(tid);\n\t\t\twl->ba_rx_session_count--;\n\t\t}\n\t\tbreak;\n\n\t \n\tcase IEEE80211_AMPDU_TX_START:\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\tret = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\twl1271_error(\"Incorrect ampdu action id=%x\\n\", action);\n\t\tret = -EINVAL;\n\t}\n\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\n\nout:\n\tmutex_unlock(&wl->mutex);\n\n\treturn ret;\n}\n\nstatic int wl12xx_set_bitrate_mask(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   const struct cfg80211_bitrate_mask *mask)\n{\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tstruct wl1271 *wl = hw->priv;\n\tint i, ret = 0;\n\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 set_bitrate_mask 0x%x 0x%x\",\n\t\tmask->control[NL80211_BAND_2GHZ].legacy,\n\t\tmask->control[NL80211_BAND_5GHZ].legacy);\n\n\tmutex_lock(&wl->mutex);\n\n\tfor (i = 0; i < WLCORE_NUM_BANDS; i++)\n\t\twlvif->bitrate_masks[i] =\n\t\t\twl1271_tx_enabled_rates_get(wl,\n\t\t\t\t\t\t    mask->control[i].legacy,\n\t\t\t\t\t\t    i);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON))\n\t\tgoto out;\n\n\tif (wlvif->bss_type == BSS_TYPE_STA_BSS &&\n\t    !test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags)) {\n\n\t\tret = pm_runtime_resume_and_get(wl->dev);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\twl1271_set_band_rate(wl, wlvif);\n\t\twlvif->basic_rate =\n\t\t\twl1271_tx_min_rate_get(wl, wlvif->basic_rate_set);\n\t\tret = wl1271_acx_sta_rate_policies(wl, wlvif);\n\n\t\tpm_runtime_mark_last_busy(wl->dev);\n\t\tpm_runtime_put_autosuspend(wl->dev);\n\t}\nout:\n\tmutex_unlock(&wl->mutex);\n\n\treturn ret;\n}\n\nstatic void wl12xx_op_channel_switch(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_channel_switch *ch_switch)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tint ret;\n\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 channel switch\");\n\n\twl1271_tx_flush(wl);\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state == WLCORE_STATE_OFF)) {\n\t\tif (test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags))\n\t\t\tieee80211_chswitch_done(vif, false);\n\t\tgoto out;\n\t} else if (unlikely(wl->state != WLCORE_STATE_ON)) {\n\t\tgoto out;\n\t}\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\n\tif (test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags)) {\n\t\tunsigned long delay_usec;\n\n\t\tret = wl->ops->channel_switch(wl, wlvif, ch_switch);\n\t\tif (ret)\n\t\t\tgoto out_sleep;\n\n\t\tset_bit(WLVIF_FLAG_CS_PROGRESS, &wlvif->flags);\n\n\t\t \n\t\tdelay_usec = ieee80211_tu_to_usec(wlvif->beacon_int) *\n\t\t\tch_switch->count;\n\t\tieee80211_queue_delayed_work(hw, &wlvif->channel_switch_work,\n\t\t\t\t\t     usecs_to_jiffies(delay_usec) +\n\t\t\t\t\t     msecs_to_jiffies(5000));\n\t}\n\nout_sleep:\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\n\nout:\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic const void *wlcore_get_beacon_ie(struct wl1271 *wl,\n\t\t\t\t\tstruct wl12xx_vif *wlvif,\n\t\t\t\t\tu8 eid)\n{\n\tint ieoffset = offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\tstruct sk_buff *beacon =\n\t\tieee80211_beacon_get(wl->hw, wl12xx_wlvif_to_vif(wlvif), 0);\n\n\tif (!beacon)\n\t\treturn NULL;\n\n\treturn cfg80211_find_ie(eid,\n\t\t\t\tbeacon->data + ieoffset,\n\t\t\t\tbeacon->len - ieoffset);\n}\n\nstatic int wlcore_get_csa_count(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t\tu8 *csa_count)\n{\n\tconst u8 *ie;\n\tconst struct ieee80211_channel_sw_ie *ie_csa;\n\n\tie = wlcore_get_beacon_ie(wl, wlvif, WLAN_EID_CHANNEL_SWITCH);\n\tif (!ie)\n\t\treturn -EINVAL;\n\n\tie_csa = (struct ieee80211_channel_sw_ie *)&ie[2];\n\t*csa_count = ie_csa->count;\n\n\treturn 0;\n}\n\nstatic void wlcore_op_channel_switch_beacon(struct ieee80211_hw *hw,\n\t\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t\t    struct cfg80211_chan_def *chandef)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tstruct ieee80211_channel_switch ch_switch = {\n\t\t.block_tx = true,\n\t\t.chandef = *chandef,\n\t};\n\tint ret;\n\n\twl1271_debug(DEBUG_MAC80211,\n\t\t     \"mac80211 channel switch beacon (role %d)\",\n\t\t     wlvif->role_id);\n\n\tret = wlcore_get_csa_count(wl, wlvif, &ch_switch.count);\n\tif (ret < 0) {\n\t\twl1271_error(\"error getting beacon (for CSA counter)\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl->ops->channel_switch(wl, wlvif, &ch_switch);\n\tif (ret)\n\t\tgoto out_sleep;\n\n\tset_bit(WLVIF_FLAG_CS_PROGRESS, &wlvif->flags);\n\nout_sleep:\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\nout:\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic void wlcore_op_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t    u32 queues, bool drop)\n{\n\tstruct wl1271 *wl = hw->priv;\n\n\twl1271_tx_flush(wl);\n}\n\nstatic int wlcore_op_remain_on_channel(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_channel *chan,\n\t\t\t\t       int duration,\n\t\t\t\t       enum ieee80211_roc_type type)\n{\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tstruct wl1271 *wl = hw->priv;\n\tint channel, active_roc, ret = 0;\n\n\tchannel = ieee80211_frequency_to_channel(chan->center_freq);\n\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 roc %d (%d)\",\n\t\t     channel, wlvif->role_id);\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON))\n\t\tgoto out;\n\n\t \n\tactive_roc = find_first_bit(wl->roc_map, WL12XX_MAX_ROLES);\n\tif (wl->roc_vif || active_roc < WL12XX_MAX_ROLES) {\n\t\twl1271_warning(\"active roc on role %d\", active_roc);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl12xx_start_dev(wl, wlvif, chan->band, channel);\n\tif (ret < 0)\n\t\tgoto out_sleep;\n\n\twl->roc_vif = vif;\n\tieee80211_queue_delayed_work(hw, &wl->roc_complete_work,\n\t\t\t\t     msecs_to_jiffies(duration));\nout_sleep:\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\nout:\n\tmutex_unlock(&wl->mutex);\n\treturn ret;\n}\n\nstatic int __wlcore_roc_completed(struct wl1271 *wl)\n{\n\tstruct wl12xx_vif *wlvif;\n\tint ret;\n\n\t \n\tif (unlikely(!wl->roc_vif))\n\t\treturn 0;\n\n\twlvif = wl12xx_vif_to_data(wl->roc_vif);\n\n\tif (!test_bit(WLVIF_FLAG_INITIALIZED, &wlvif->flags))\n\t\treturn -EBUSY;\n\n\tret = wl12xx_stop_dev(wl, wlvif);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twl->roc_vif = NULL;\n\n\treturn 0;\n}\n\nstatic int wlcore_roc_completed(struct wl1271 *wl)\n{\n\tint ret;\n\n\twl1271_debug(DEBUG_MAC80211, \"roc complete\");\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = __wlcore_roc_completed(wl);\n\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\nout:\n\tmutex_unlock(&wl->mutex);\n\n\treturn ret;\n}\n\nstatic void wlcore_roc_complete_work(struct work_struct *work)\n{\n\tstruct delayed_work *dwork;\n\tstruct wl1271 *wl;\n\tint ret;\n\n\tdwork = to_delayed_work(work);\n\twl = container_of(dwork, struct wl1271, roc_complete_work);\n\n\tret = wlcore_roc_completed(wl);\n\tif (!ret)\n\t\tieee80211_remain_on_channel_expired(wl->hw);\n}\n\nstatic int wlcore_op_cancel_remain_on_channel(struct ieee80211_hw *hw,\n\t\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct wl1271 *wl = hw->priv;\n\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 croc\");\n\n\t \n\twl1271_tx_flush(wl);\n\n\t \n\tcancel_delayed_work_sync(&wl->roc_complete_work);\n\twlcore_roc_completed(wl);\n\n\treturn 0;\n}\n\nstatic void wlcore_op_sta_rc_update(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_sta *sta,\n\t\t\t\t    u32 changed)\n{\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 sta_rc_update\");\n\n\tif (!(changed & IEEE80211_RC_BW_CHANGED))\n\t\treturn;\n\n\t \n\twlvif->rc_update_bw = sta->deflink.bandwidth;\n\tmemcpy(&wlvif->rc_ht_cap, &sta->deflink.ht_cap,\n\t       sizeof(sta->deflink.ht_cap));\n\tieee80211_queue_work(hw, &wlvif->rc_update_work);\n}\n\nstatic void wlcore_op_sta_statistics(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_sta *sta,\n\t\t\t\t     struct station_info *sinfo)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\ts8 rssi_dbm;\n\tint ret;\n\n\twl1271_debug(DEBUG_MAC80211, \"mac80211 get_rssi\");\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON))\n\t\tgoto out;\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out_sleep;\n\n\tret = wlcore_acx_average_rssi(wl, wlvif, &rssi_dbm);\n\tif (ret < 0)\n\t\tgoto out_sleep;\n\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL);\n\tsinfo->signal = rssi_dbm;\n\nout_sleep:\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\n\nout:\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic u32 wlcore_op_get_expected_throughput(struct ieee80211_hw *hw,\n\t\t\t\t\t     struct ieee80211_sta *sta)\n{\n\tstruct wl1271_station *wl_sta = (struct wl1271_station *)sta->drv_priv;\n\tstruct wl1271 *wl = hw->priv;\n\tu8 hlid = wl_sta->hlid;\n\n\t \n\treturn (wl->links[hlid].fw_rate_mbps * 1000);\n}\n\nstatic bool wl1271_tx_frames_pending(struct ieee80211_hw *hw)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tbool ret = false;\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON))\n\t\tgoto out;\n\n\t \n\tret = (wl1271_tx_total_queue_count(wl) > 0) || (wl->tx_frames_cnt > 0);\nout:\n\tmutex_unlock(&wl->mutex);\n\n\treturn ret;\n}\n\n \nstatic struct ieee80211_rate wl1271_rates[] = {\n\t{ .bitrate = 10,\n\t  .hw_value = CONF_HW_BIT_RATE_1MBPS,\n\t  .hw_value_short = CONF_HW_BIT_RATE_1MBPS, },\n\t{ .bitrate = 20,\n\t  .hw_value = CONF_HW_BIT_RATE_2MBPS,\n\t  .hw_value_short = CONF_HW_BIT_RATE_2MBPS,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 55,\n\t  .hw_value = CONF_HW_BIT_RATE_5_5MBPS,\n\t  .hw_value_short = CONF_HW_BIT_RATE_5_5MBPS,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 110,\n\t  .hw_value = CONF_HW_BIT_RATE_11MBPS,\n\t  .hw_value_short = CONF_HW_BIT_RATE_11MBPS,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 60,\n\t  .hw_value = CONF_HW_BIT_RATE_6MBPS,\n\t  .hw_value_short = CONF_HW_BIT_RATE_6MBPS, },\n\t{ .bitrate = 90,\n\t  .hw_value = CONF_HW_BIT_RATE_9MBPS,\n\t  .hw_value_short = CONF_HW_BIT_RATE_9MBPS, },\n\t{ .bitrate = 120,\n\t  .hw_value = CONF_HW_BIT_RATE_12MBPS,\n\t  .hw_value_short = CONF_HW_BIT_RATE_12MBPS, },\n\t{ .bitrate = 180,\n\t  .hw_value = CONF_HW_BIT_RATE_18MBPS,\n\t  .hw_value_short = CONF_HW_BIT_RATE_18MBPS, },\n\t{ .bitrate = 240,\n\t  .hw_value = CONF_HW_BIT_RATE_24MBPS,\n\t  .hw_value_short = CONF_HW_BIT_RATE_24MBPS, },\n\t{ .bitrate = 360,\n\t .hw_value = CONF_HW_BIT_RATE_36MBPS,\n\t .hw_value_short = CONF_HW_BIT_RATE_36MBPS, },\n\t{ .bitrate = 480,\n\t  .hw_value = CONF_HW_BIT_RATE_48MBPS,\n\t  .hw_value_short = CONF_HW_BIT_RATE_48MBPS, },\n\t{ .bitrate = 540,\n\t  .hw_value = CONF_HW_BIT_RATE_54MBPS,\n\t  .hw_value_short = CONF_HW_BIT_RATE_54MBPS, },\n};\n\n \nstatic struct ieee80211_channel wl1271_channels[] = {\n\t{ .hw_value = 1, .center_freq = 2412, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 2, .center_freq = 2417, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 3, .center_freq = 2422, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 4, .center_freq = 2427, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 5, .center_freq = 2432, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 6, .center_freq = 2437, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 7, .center_freq = 2442, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 8, .center_freq = 2447, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 9, .center_freq = 2452, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 10, .center_freq = 2457, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 11, .center_freq = 2462, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 12, .center_freq = 2467, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 13, .center_freq = 2472, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 14, .center_freq = 2484, .max_power = WLCORE_MAX_TXPWR },\n};\n\n \nstatic struct ieee80211_supported_band wl1271_band_2ghz = {\n\t.channels = wl1271_channels,\n\t.n_channels = ARRAY_SIZE(wl1271_channels),\n\t.bitrates = wl1271_rates,\n\t.n_bitrates = ARRAY_SIZE(wl1271_rates),\n};\n\n \nstatic struct ieee80211_rate wl1271_rates_5ghz[] = {\n\t{ .bitrate = 60,\n\t  .hw_value = CONF_HW_BIT_RATE_6MBPS,\n\t  .hw_value_short = CONF_HW_BIT_RATE_6MBPS, },\n\t{ .bitrate = 90,\n\t  .hw_value = CONF_HW_BIT_RATE_9MBPS,\n\t  .hw_value_short = CONF_HW_BIT_RATE_9MBPS, },\n\t{ .bitrate = 120,\n\t  .hw_value = CONF_HW_BIT_RATE_12MBPS,\n\t  .hw_value_short = CONF_HW_BIT_RATE_12MBPS, },\n\t{ .bitrate = 180,\n\t  .hw_value = CONF_HW_BIT_RATE_18MBPS,\n\t  .hw_value_short = CONF_HW_BIT_RATE_18MBPS, },\n\t{ .bitrate = 240,\n\t  .hw_value = CONF_HW_BIT_RATE_24MBPS,\n\t  .hw_value_short = CONF_HW_BIT_RATE_24MBPS, },\n\t{ .bitrate = 360,\n\t .hw_value = CONF_HW_BIT_RATE_36MBPS,\n\t .hw_value_short = CONF_HW_BIT_RATE_36MBPS, },\n\t{ .bitrate = 480,\n\t  .hw_value = CONF_HW_BIT_RATE_48MBPS,\n\t  .hw_value_short = CONF_HW_BIT_RATE_48MBPS, },\n\t{ .bitrate = 540,\n\t  .hw_value = CONF_HW_BIT_RATE_54MBPS,\n\t  .hw_value_short = CONF_HW_BIT_RATE_54MBPS, },\n};\n\n \nstatic struct ieee80211_channel wl1271_channels_5ghz[] = {\n\t{ .hw_value = 8, .center_freq = 5040, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 12, .center_freq = 5060, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 16, .center_freq = 5080, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 34, .center_freq = 5170, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 36, .center_freq = 5180, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 38, .center_freq = 5190, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 40, .center_freq = 5200, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 42, .center_freq = 5210, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 44, .center_freq = 5220, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 46, .center_freq = 5230, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 48, .center_freq = 5240, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 52, .center_freq = 5260, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 56, .center_freq = 5280, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 60, .center_freq = 5300, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 64, .center_freq = 5320, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 100, .center_freq = 5500, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 104, .center_freq = 5520, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 108, .center_freq = 5540, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 112, .center_freq = 5560, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 116, .center_freq = 5580, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 120, .center_freq = 5600, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 124, .center_freq = 5620, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 128, .center_freq = 5640, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 132, .center_freq = 5660, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 136, .center_freq = 5680, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 140, .center_freq = 5700, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 149, .center_freq = 5745, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 153, .center_freq = 5765, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 157, .center_freq = 5785, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 161, .center_freq = 5805, .max_power = WLCORE_MAX_TXPWR },\n\t{ .hw_value = 165, .center_freq = 5825, .max_power = WLCORE_MAX_TXPWR },\n};\n\nstatic struct ieee80211_supported_band wl1271_band_5ghz = {\n\t.channels = wl1271_channels_5ghz,\n\t.n_channels = ARRAY_SIZE(wl1271_channels_5ghz),\n\t.bitrates = wl1271_rates_5ghz,\n\t.n_bitrates = ARRAY_SIZE(wl1271_rates_5ghz),\n};\n\nstatic const struct ieee80211_ops wl1271_ops = {\n\t.start = wl1271_op_start,\n\t.stop = wlcore_op_stop,\n\t.add_interface = wl1271_op_add_interface,\n\t.remove_interface = wl1271_op_remove_interface,\n\t.change_interface = wl12xx_op_change_interface,\n#ifdef CONFIG_PM\n\t.suspend = wl1271_op_suspend,\n\t.resume = wl1271_op_resume,\n#endif\n\t.config = wl1271_op_config,\n\t.prepare_multicast = wl1271_op_prepare_multicast,\n\t.configure_filter = wl1271_op_configure_filter,\n\t.tx = wl1271_op_tx,\n\t.wake_tx_queue = ieee80211_handle_wake_tx_queue,\n\t.set_key = wlcore_op_set_key,\n\t.hw_scan = wl1271_op_hw_scan,\n\t.cancel_hw_scan = wl1271_op_cancel_hw_scan,\n\t.sched_scan_start = wl1271_op_sched_scan_start,\n\t.sched_scan_stop = wl1271_op_sched_scan_stop,\n\t.bss_info_changed = wl1271_op_bss_info_changed,\n\t.set_frag_threshold = wl1271_op_set_frag_threshold,\n\t.set_rts_threshold = wl1271_op_set_rts_threshold,\n\t.conf_tx = wl1271_op_conf_tx,\n\t.get_tsf = wl1271_op_get_tsf,\n\t.get_survey = wl1271_op_get_survey,\n\t.sta_state = wl12xx_op_sta_state,\n\t.ampdu_action = wl1271_op_ampdu_action,\n\t.tx_frames_pending = wl1271_tx_frames_pending,\n\t.set_bitrate_mask = wl12xx_set_bitrate_mask,\n\t.set_default_unicast_key = wl1271_op_set_default_key_idx,\n\t.channel_switch = wl12xx_op_channel_switch,\n\t.channel_switch_beacon = wlcore_op_channel_switch_beacon,\n\t.flush = wlcore_op_flush,\n\t.remain_on_channel = wlcore_op_remain_on_channel,\n\t.cancel_remain_on_channel = wlcore_op_cancel_remain_on_channel,\n\t.add_chanctx = wlcore_op_add_chanctx,\n\t.remove_chanctx = wlcore_op_remove_chanctx,\n\t.change_chanctx = wlcore_op_change_chanctx,\n\t.assign_vif_chanctx = wlcore_op_assign_vif_chanctx,\n\t.unassign_vif_chanctx = wlcore_op_unassign_vif_chanctx,\n\t.switch_vif_chanctx = wlcore_op_switch_vif_chanctx,\n\t.sta_rc_update = wlcore_op_sta_rc_update,\n\t.sta_statistics = wlcore_op_sta_statistics,\n\t.get_expected_throughput = wlcore_op_get_expected_throughput,\n\tCFG80211_TESTMODE_CMD(wl1271_tm_cmd)\n};\n\n\nu8 wlcore_rate_to_idx(struct wl1271 *wl, u8 rate, enum nl80211_band band)\n{\n\tu8 idx;\n\n\tBUG_ON(band >= 2);\n\n\tif (unlikely(rate >= wl->hw_tx_rate_tbl_size)) {\n\t\twl1271_error(\"Illegal RX rate from HW: %d\", rate);\n\t\treturn 0;\n\t}\n\n\tidx = wl->band_rate_to_idx[band][rate];\n\tif (unlikely(idx == CONF_HW_RXTX_RATE_UNSUPPORTED)) {\n\t\twl1271_error(\"Unsupported RX rate from HW: %d\", rate);\n\t\treturn 0;\n\t}\n\n\treturn idx;\n}\n\nstatic void wl12xx_derive_mac_addresses(struct wl1271 *wl, u32 oui, u32 nic)\n{\n\tint i;\n\n\twl1271_debug(DEBUG_PROBE, \"base address: oui %06x nic %06x\",\n\t\t     oui, nic);\n\n\tif (nic + WLCORE_NUM_MAC_ADDRESSES - wl->num_mac_addr > 0xffffff)\n\t\twl1271_warning(\"NIC part of the MAC address wraps around!\");\n\n\tfor (i = 0; i < wl->num_mac_addr; i++) {\n\t\twl->addresses[i].addr[0] = (u8)(oui >> 16);\n\t\twl->addresses[i].addr[1] = (u8)(oui >> 8);\n\t\twl->addresses[i].addr[2] = (u8) oui;\n\t\twl->addresses[i].addr[3] = (u8)(nic >> 16);\n\t\twl->addresses[i].addr[4] = (u8)(nic >> 8);\n\t\twl->addresses[i].addr[5] = (u8) nic;\n\t\tnic++;\n\t}\n\n\t \n\tWARN_ON(wl->num_mac_addr + 1 < WLCORE_NUM_MAC_ADDRESSES);\n\n\t \n\tif (wl->num_mac_addr < WLCORE_NUM_MAC_ADDRESSES) {\n\t\tint idx = WLCORE_NUM_MAC_ADDRESSES - 1;\n\t\tmemcpy(&wl->addresses[idx], &wl->addresses[0],\n\t\t       sizeof(wl->addresses[0]));\n\t\t \n\t\twl->addresses[idx].addr[0] |= BIT(1);\n\t}\n\n\twl->hw->wiphy->n_addresses = WLCORE_NUM_MAC_ADDRESSES;\n\twl->hw->wiphy->addresses = wl->addresses;\n}\n\nstatic int wl12xx_get_hw_info(struct wl1271 *wl)\n{\n\tint ret;\n\n\tret = wlcore_read_reg(wl, REG_CHIP_ID_B, &wl->chip.id);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twl->fuse_oui_addr = 0;\n\twl->fuse_nic_addr = 0;\n\n\tret = wl->ops->get_pg_ver(wl, &wl->hw_pg_ver);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (wl->ops->get_mac)\n\t\tret = wl->ops->get_mac(wl);\n\nout:\n\treturn ret;\n}\n\nstatic int wl1271_register_hw(struct wl1271 *wl)\n{\n\tint ret;\n\tu32 oui_addr = 0, nic_addr = 0;\n\tstruct platform_device *pdev = wl->pdev;\n\tstruct wlcore_platdev_data *pdev_data = dev_get_platdata(&pdev->dev);\n\n\tif (wl->mac80211_registered)\n\t\treturn 0;\n\n\tif (wl->nvs_len >= 12) {\n\t\t \n\t\tu8 *nvs_ptr = (u8 *)wl->nvs;\n\n\t\toui_addr =\n\t\t\t(nvs_ptr[11] << 16) + (nvs_ptr[10] << 8) + nvs_ptr[6];\n\t\tnic_addr =\n\t\t\t(nvs_ptr[5] << 16) + (nvs_ptr[4] << 8) + nvs_ptr[3];\n\t}\n\n\t \n\tif (oui_addr == 0 && nic_addr == 0) {\n\t\toui_addr = wl->fuse_oui_addr;\n\t\t \n\t\tnic_addr = wl->fuse_nic_addr + 1;\n\t}\n\n\tif (oui_addr == 0xdeadbe && nic_addr == 0xef0000) {\n\t\twl1271_warning(\"Detected unconfigured mac address in nvs, derive from fuse instead.\");\n\t\tif (!strcmp(pdev_data->family->name, \"wl18xx\")) {\n\t\t\twl1271_warning(\"This default nvs file can be removed from the file system\");\n\t\t} else {\n\t\t\twl1271_warning(\"Your device performance is not optimized.\");\n\t\t\twl1271_warning(\"Please use the calibrator tool to configure your device.\");\n\t\t}\n\n\t\tif (wl->fuse_oui_addr == 0 && wl->fuse_nic_addr == 0) {\n\t\t\twl1271_warning(\"Fuse mac address is zero. using random mac\");\n\t\t\t \n\t\t\toui_addr = WLCORE_TI_OUI_ADDRESS;\n\t\t\tnic_addr = get_random_u32();\n\t\t} else {\n\t\t\toui_addr = wl->fuse_oui_addr;\n\t\t\t \n\t\t\tnic_addr = wl->fuse_nic_addr + 1;\n\t\t}\n\t}\n\n\twl12xx_derive_mac_addresses(wl, oui_addr, nic_addr);\n\n\tret = ieee80211_register_hw(wl->hw);\n\tif (ret < 0) {\n\t\twl1271_error(\"unable to register mac80211 hw: %d\", ret);\n\t\tgoto out;\n\t}\n\n\twl->mac80211_registered = true;\n\n\twl1271_debugfs_init(wl);\n\n\twl1271_notice(\"loaded\");\n\nout:\n\treturn ret;\n}\n\nstatic void wl1271_unregister_hw(struct wl1271 *wl)\n{\n\tif (wl->plt)\n\t\twl1271_plt_stop(wl);\n\n\tieee80211_unregister_hw(wl->hw);\n\twl->mac80211_registered = false;\n\n}\n\nstatic int wl1271_init_ieee80211(struct wl1271 *wl)\n{\n\tint i;\n\tstatic const u32 cipher_suites[] = {\n\t\tWLAN_CIPHER_SUITE_WEP40,\n\t\tWLAN_CIPHER_SUITE_WEP104,\n\t\tWLAN_CIPHER_SUITE_TKIP,\n\t\tWLAN_CIPHER_SUITE_CCMP,\n\t\tWL1271_CIPHER_SUITE_GEM,\n\t};\n\n\t \n\twl->hw->extra_tx_headroom = sizeof(struct wl1271_tx_hw_descr);\n\n\tif (wl->quirks & WLCORE_QUIRK_TKIP_HEADER_SPACE)\n\t\twl->hw->extra_tx_headroom += WL1271_EXTRA_SPACE_TKIP;\n\n\t \n\t \n\twl->hw->max_listen_interval = wl->conf.conn.max_listen_interval;\n\n\tieee80211_hw_set(wl->hw, SUPPORT_FAST_XMIT);\n\tieee80211_hw_set(wl->hw, CHANCTX_STA_CSA);\n\tieee80211_hw_set(wl->hw, SUPPORTS_PER_STA_GTK);\n\tieee80211_hw_set(wl->hw, QUEUE_CONTROL);\n\tieee80211_hw_set(wl->hw, TX_AMPDU_SETUP_IN_HW);\n\tieee80211_hw_set(wl->hw, AMPDU_AGGREGATION);\n\tieee80211_hw_set(wl->hw, AP_LINK_PS);\n\tieee80211_hw_set(wl->hw, SPECTRUM_MGMT);\n\tieee80211_hw_set(wl->hw, REPORTS_TX_ACK_STATUS);\n\tieee80211_hw_set(wl->hw, CONNECTION_MONITOR);\n\tieee80211_hw_set(wl->hw, HAS_RATE_CONTROL);\n\tieee80211_hw_set(wl->hw, SUPPORTS_DYNAMIC_PS);\n\tieee80211_hw_set(wl->hw, SIGNAL_DBM);\n\tieee80211_hw_set(wl->hw, SUPPORTS_PS);\n\tieee80211_hw_set(wl->hw, SUPPORTS_TX_FRAG);\n\n\twl->hw->wiphy->cipher_suites = cipher_suites;\n\twl->hw->wiphy->n_cipher_suites = ARRAY_SIZE(cipher_suites);\n\n\twl->hw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t\t BIT(NL80211_IFTYPE_AP) |\n\t\t\t\t\t BIT(NL80211_IFTYPE_P2P_DEVICE) |\n\t\t\t\t\t BIT(NL80211_IFTYPE_P2P_CLIENT) |\n#ifdef CONFIG_MAC80211_MESH\n\t\t\t\t\t BIT(NL80211_IFTYPE_MESH_POINT) |\n#endif\n\t\t\t\t\t BIT(NL80211_IFTYPE_P2P_GO);\n\n\twl->hw->wiphy->max_scan_ssids = 1;\n\twl->hw->wiphy->max_sched_scan_ssids = 16;\n\twl->hw->wiphy->max_match_sets = 16;\n\t \n\twl->hw->wiphy->max_scan_ie_len = WL1271_CMD_TEMPL_MAX_SIZE -\n\t\t\tsizeof(struct ieee80211_header);\n\n\twl->hw->wiphy->max_sched_scan_reqs = 1;\n\twl->hw->wiphy->max_sched_scan_ie_len = WL1271_CMD_TEMPL_MAX_SIZE -\n\t\tsizeof(struct ieee80211_header);\n\n\twl->hw->wiphy->max_remain_on_channel_duration = 30000;\n\n\twl->hw->wiphy->flags |= WIPHY_FLAG_AP_UAPSD |\n\t\t\t\tWIPHY_FLAG_HAS_REMAIN_ON_CHANNEL |\n\t\t\t\tWIPHY_FLAG_HAS_CHANNEL_SWITCH |\n\t\t\t\tWIPHY_FLAG_IBSS_RSN;\n\n\twl->hw->wiphy->features |= NL80211_FEATURE_AP_SCAN;\n\n\t \n\tBUILD_BUG_ON(ARRAY_SIZE(wl1271_channels) +\n\t\t     ARRAY_SIZE(wl1271_channels_5ghz) >\n\t\t     WL1271_MAX_CHANNELS);\n\t \n\tfor (i = 0; i < ARRAY_SIZE(wl1271_channels); i++) {\n\t\twl1271_band_2ghz.channels[i].flags = 0;\n\t\twl1271_band_2ghz.channels[i].max_power = WLCORE_MAX_TXPWR;\n\t\twl1271_band_2ghz.channels[i].max_antenna_gain = 0;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(wl1271_channels_5ghz); i++) {\n\t\twl1271_band_5ghz.channels[i].flags = 0;\n\t\twl1271_band_5ghz.channels[i].max_power = WLCORE_MAX_TXPWR;\n\t\twl1271_band_5ghz.channels[i].max_antenna_gain = 0;\n\t}\n\n\t \n\tmemcpy(&wl->bands[NL80211_BAND_2GHZ], &wl1271_band_2ghz,\n\t       sizeof(wl1271_band_2ghz));\n\tmemcpy(&wl->bands[NL80211_BAND_2GHZ].ht_cap,\n\t       &wl->ht_cap[NL80211_BAND_2GHZ],\n\t       sizeof(*wl->ht_cap));\n\tmemcpy(&wl->bands[NL80211_BAND_5GHZ], &wl1271_band_5ghz,\n\t       sizeof(wl1271_band_5ghz));\n\tmemcpy(&wl->bands[NL80211_BAND_5GHZ].ht_cap,\n\t       &wl->ht_cap[NL80211_BAND_5GHZ],\n\t       sizeof(*wl->ht_cap));\n\n\twl->hw->wiphy->bands[NL80211_BAND_2GHZ] =\n\t\t&wl->bands[NL80211_BAND_2GHZ];\n\twl->hw->wiphy->bands[NL80211_BAND_5GHZ] =\n\t\t&wl->bands[NL80211_BAND_5GHZ];\n\n\t \n\twl->hw->queues = (NUM_TX_QUEUES + 1) * WLCORE_NUM_MAC_ADDRESSES + 1;\n\n\t \n\twl->hw->offchannel_tx_hw_queue = wl->hw->queues - 1;\n\twl->hw->max_rates = 1;\n\n\twl->hw->wiphy->reg_notifier = wl1271_reg_notify;\n\n\t \n\twl->hw->wiphy->flags |= WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD;\n\twl->hw->wiphy->probe_resp_offload =\n\t\tNL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS |\n\t\tNL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS2 |\n\t\tNL80211_PROBE_RESP_OFFLOAD_SUPPORT_P2P;\n\n\t \n\twl->hw->wiphy->iface_combinations = wl->iface_combinations;\n\twl->hw->wiphy->n_iface_combinations = wl->n_iface_combinations;\n\n\t \n\twlcore_set_vendor_commands(wl->hw->wiphy);\n\n\tSET_IEEE80211_DEV(wl->hw, wl->dev);\n\n\twl->hw->sta_data_size = sizeof(struct wl1271_station);\n\twl->hw->vif_data_size = sizeof(struct wl12xx_vif);\n\n\twl->hw->max_rx_aggregation_subframes = wl->conf.ht.rx_ba_win_size;\n\n\treturn 0;\n}\n\nstruct ieee80211_hw *wlcore_alloc_hw(size_t priv_size, u32 aggr_buf_size,\n\t\t\t\t     u32 mbox_size)\n{\n\tstruct ieee80211_hw *hw;\n\tstruct wl1271 *wl;\n\tint i, j, ret;\n\tunsigned int order;\n\n\thw = ieee80211_alloc_hw(sizeof(*wl), &wl1271_ops);\n\tif (!hw) {\n\t\twl1271_error(\"could not alloc ieee80211_hw\");\n\t\tret = -ENOMEM;\n\t\tgoto err_hw_alloc;\n\t}\n\n\twl = hw->priv;\n\tmemset(wl, 0, sizeof(*wl));\n\n\twl->priv = kzalloc(priv_size, GFP_KERNEL);\n\tif (!wl->priv) {\n\t\twl1271_error(\"could not alloc wl priv\");\n\t\tret = -ENOMEM;\n\t\tgoto err_priv_alloc;\n\t}\n\n\tINIT_LIST_HEAD(&wl->wlvif_list);\n\n\twl->hw = hw;\n\n\t \n\tfor (i = 0; i < NUM_TX_QUEUES; i++)\n\t\tfor (j = 0; j < WLCORE_MAX_LINKS; j++)\n\t\t\tskb_queue_head_init(&wl->links[j].tx_queue[i]);\n\n\tskb_queue_head_init(&wl->deferred_rx_queue);\n\tskb_queue_head_init(&wl->deferred_tx_queue);\n\n\tINIT_WORK(&wl->netstack_work, wl1271_netstack_work);\n\tINIT_WORK(&wl->tx_work, wl1271_tx_work);\n\tINIT_WORK(&wl->recovery_work, wl1271_recovery_work);\n\tINIT_DELAYED_WORK(&wl->scan_complete_work, wl1271_scan_complete_work);\n\tINIT_DELAYED_WORK(&wl->roc_complete_work, wlcore_roc_complete_work);\n\tINIT_DELAYED_WORK(&wl->tx_watchdog_work, wl12xx_tx_watchdog_work);\n\n\twl->freezable_wq = create_freezable_workqueue(\"wl12xx_wq\");\n\tif (!wl->freezable_wq) {\n\t\tret = -ENOMEM;\n\t\tgoto err_hw;\n\t}\n\n\twl->channel = 0;\n\twl->rx_counter = 0;\n\twl->power_level = WL1271_DEFAULT_POWER_LEVEL;\n\twl->band = NL80211_BAND_2GHZ;\n\twl->channel_type = NL80211_CHAN_NO_HT;\n\twl->flags = 0;\n\twl->sg_enabled = true;\n\twl->sleep_auth = WL1271_PSM_ILLEGAL;\n\twl->recovery_count = 0;\n\twl->hw_pg_ver = -1;\n\twl->ap_ps_map = 0;\n\twl->ap_fw_ps_map = 0;\n\twl->quirks = 0;\n\twl->system_hlid = WL12XX_SYSTEM_HLID;\n\twl->active_sta_count = 0;\n\twl->active_link_count = 0;\n\twl->fwlog_size = 0;\n\n\t \n\t__set_bit(WL12XX_SYSTEM_HLID, wl->links_map);\n\n\tmemset(wl->tx_frames_map, 0, sizeof(wl->tx_frames_map));\n\tfor (i = 0; i < wl->num_tx_desc; i++)\n\t\twl->tx_frames[i] = NULL;\n\n\tspin_lock_init(&wl->wl_lock);\n\n\twl->state = WLCORE_STATE_OFF;\n\twl->fw_type = WL12XX_FW_TYPE_NONE;\n\tmutex_init(&wl->mutex);\n\tmutex_init(&wl->flush_mutex);\n\tinit_completion(&wl->nvs_loading_complete);\n\n\torder = get_order(aggr_buf_size);\n\twl->aggr_buf = (u8 *)__get_free_pages(GFP_KERNEL, order);\n\tif (!wl->aggr_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err_wq;\n\t}\n\twl->aggr_buf_size = aggr_buf_size;\n\n\twl->dummy_packet = wl12xx_alloc_dummy_packet(wl);\n\tif (!wl->dummy_packet) {\n\t\tret = -ENOMEM;\n\t\tgoto err_aggr;\n\t}\n\n\t \n\twl->fwlog = (u8 *)get_zeroed_page(GFP_KERNEL);\n\tif (!wl->fwlog) {\n\t\tret = -ENOMEM;\n\t\tgoto err_dummy_packet;\n\t}\n\n\twl->mbox_size = mbox_size;\n\twl->mbox = kmalloc(wl->mbox_size, GFP_KERNEL | GFP_DMA);\n\tif (!wl->mbox) {\n\t\tret = -ENOMEM;\n\t\tgoto err_fwlog;\n\t}\n\n\twl->buffer_32 = kmalloc(sizeof(*wl->buffer_32), GFP_KERNEL);\n\tif (!wl->buffer_32) {\n\t\tret = -ENOMEM;\n\t\tgoto err_mbox;\n\t}\n\n\treturn hw;\n\nerr_mbox:\n\tkfree(wl->mbox);\n\nerr_fwlog:\n\tfree_page((unsigned long)wl->fwlog);\n\nerr_dummy_packet:\n\tdev_kfree_skb(wl->dummy_packet);\n\nerr_aggr:\n\tfree_pages((unsigned long)wl->aggr_buf, order);\n\nerr_wq:\n\tdestroy_workqueue(wl->freezable_wq);\n\nerr_hw:\n\twl1271_debugfs_exit(wl);\n\tkfree(wl->priv);\n\nerr_priv_alloc:\n\tieee80211_free_hw(hw);\n\nerr_hw_alloc:\n\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(wlcore_alloc_hw);\n\nint wlcore_free_hw(struct wl1271 *wl)\n{\n\t \n\tmutex_lock(&wl->mutex);\n\twl->fwlog_size = -1;\n\tmutex_unlock(&wl->mutex);\n\n\twlcore_sysfs_free(wl);\n\n\tkfree(wl->buffer_32);\n\tkfree(wl->mbox);\n\tfree_page((unsigned long)wl->fwlog);\n\tdev_kfree_skb(wl->dummy_packet);\n\tfree_pages((unsigned long)wl->aggr_buf, get_order(wl->aggr_buf_size));\n\n\twl1271_debugfs_exit(wl);\n\n\tvfree(wl->fw);\n\twl->fw = NULL;\n\twl->fw_type = WL12XX_FW_TYPE_NONE;\n\tkfree(wl->nvs);\n\twl->nvs = NULL;\n\n\tkfree(wl->raw_fw_status);\n\tkfree(wl->fw_status);\n\tkfree(wl->tx_res_if);\n\tdestroy_workqueue(wl->freezable_wq);\n\n\tkfree(wl->priv);\n\tieee80211_free_hw(wl->hw);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wlcore_free_hw);\n\n#ifdef CONFIG_PM\nstatic const struct wiphy_wowlan_support wlcore_wowlan_support = {\n\t.flags = WIPHY_WOWLAN_ANY,\n\t.n_patterns = WL1271_MAX_RX_FILTERS,\n\t.pattern_min_len = 1,\n\t.pattern_max_len = WL1271_RX_FILTER_MAX_PATTERN_SIZE,\n};\n#endif\n\nstatic irqreturn_t wlcore_hardirq(int irq, void *cookie)\n{\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic void wlcore_nvs_cb(const struct firmware *fw, void *context)\n{\n\tstruct wl1271 *wl = context;\n\tstruct platform_device *pdev = wl->pdev;\n\tstruct wlcore_platdev_data *pdev_data = dev_get_platdata(&pdev->dev);\n\tstruct resource *res;\n\n\tint ret;\n\tirq_handler_t hardirq_fn = NULL;\n\n\tif (fw) {\n\t\twl->nvs = kmemdup(fw->data, fw->size, GFP_KERNEL);\n\t\tif (!wl->nvs) {\n\t\t\twl1271_error(\"Could not allocate nvs data\");\n\t\t\tgoto out;\n\t\t}\n\t\twl->nvs_len = fw->size;\n\t} else if (pdev_data->family->nvs_name) {\n\t\twl1271_debug(DEBUG_BOOT, \"Could not get nvs file %s\",\n\t\t\t     pdev_data->family->nvs_name);\n\t\twl->nvs = NULL;\n\t\twl->nvs_len = 0;\n\t} else {\n\t\twl->nvs = NULL;\n\t\twl->nvs_len = 0;\n\t}\n\n\tret = wl->ops->setup(wl);\n\tif (ret < 0)\n\t\tgoto out_free_nvs;\n\n\tBUG_ON(wl->num_tx_desc > WLCORE_MAX_TX_DESCRIPTORS);\n\n\t \n\twlcore_adjust_conf(wl);\n\n\tres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\tif (!res) {\n\t\twl1271_error(\"Could not get IRQ resource\");\n\t\tgoto out_free_nvs;\n\t}\n\n\twl->irq = res->start;\n\twl->irq_flags = res->flags & IRQF_TRIGGER_MASK;\n\twl->if_ops = pdev_data->if_ops;\n\n\tif (wl->irq_flags & (IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING))\n\t\thardirq_fn = wlcore_hardirq;\n\telse\n\t\twl->irq_flags |= IRQF_ONESHOT;\n\n\tret = wl12xx_set_power_on(wl);\n\tif (ret < 0)\n\t\tgoto out_free_nvs;\n\n\tret = wl12xx_get_hw_info(wl);\n\tif (ret < 0) {\n\t\twl1271_error(\"couldn't get hw info\");\n\t\twl1271_power_off(wl);\n\t\tgoto out_free_nvs;\n\t}\n\n\tret = request_threaded_irq(wl->irq, hardirq_fn, wlcore_irq,\n\t\t\t\t   wl->irq_flags, pdev->name, wl);\n\tif (ret < 0) {\n\t\twl1271_error(\"interrupt configuration failed\");\n\t\twl1271_power_off(wl);\n\t\tgoto out_free_nvs;\n\t}\n\n#ifdef CONFIG_PM\n\tdevice_init_wakeup(wl->dev, true);\n\n\tret = enable_irq_wake(wl->irq);\n\tif (!ret) {\n\t\twl->irq_wake_enabled = true;\n\t\tif (pdev_data->pwr_in_suspend)\n\t\t\twl->hw->wiphy->wowlan = &wlcore_wowlan_support;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_IRQ, 1);\n\tif (res) {\n\t\twl->wakeirq = res->start;\n\t\twl->wakeirq_flags = res->flags & IRQF_TRIGGER_MASK;\n\t\tret = dev_pm_set_dedicated_wake_irq(wl->dev, wl->wakeirq);\n\t\tif (ret)\n\t\t\twl->wakeirq = -ENODEV;\n\t} else {\n\t\twl->wakeirq = -ENODEV;\n\t}\n#endif\n\tdisable_irq(wl->irq);\n\twl1271_power_off(wl);\n\n\tret = wl->ops->identify_chip(wl);\n\tif (ret < 0)\n\t\tgoto out_irq;\n\n\tret = wl1271_init_ieee80211(wl);\n\tif (ret)\n\t\tgoto out_irq;\n\n\tret = wl1271_register_hw(wl);\n\tif (ret)\n\t\tgoto out_irq;\n\n\tret = wlcore_sysfs_init(wl);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\twl->initialized = true;\n\tgoto out;\n\nout_unreg:\n\twl1271_unregister_hw(wl);\n\nout_irq:\n\tif (wl->wakeirq >= 0)\n\t\tdev_pm_clear_wake_irq(wl->dev);\n\tdevice_init_wakeup(wl->dev, false);\n\tfree_irq(wl->irq, wl);\n\nout_free_nvs:\n\tkfree(wl->nvs);\n\nout:\n\trelease_firmware(fw);\n\tcomplete_all(&wl->nvs_loading_complete);\n}\n\nstatic int __maybe_unused wlcore_runtime_suspend(struct device *dev)\n{\n\tstruct wl1271 *wl = dev_get_drvdata(dev);\n\tstruct wl12xx_vif *wlvif;\n\tint error;\n\n\t \n\tif (wl->plt)\n\t\treturn 0;\n\n\t \n\tif (wl->sleep_auth != WL1271_PSM_ELP)\n\t\treturn 0;\n\n\twl12xx_for_each_wlvif(wl, wlvif) {\n\t\tif (!test_bit(WLVIF_FLAG_IN_PS, &wlvif->flags) &&\n\t\t    test_bit(WLVIF_FLAG_IN_USE, &wlvif->flags))\n\t\t\treturn -EBUSY;\n\t}\n\n\twl1271_debug(DEBUG_PSM, \"chip to elp\");\n\terror = wlcore_raw_write32(wl, HW_ACCESS_ELP_CTRL_REG, ELPCTRL_SLEEP);\n\tif (error < 0) {\n\t\twl12xx_queue_recovery_work(wl);\n\n\t\treturn error;\n\t}\n\n\tset_bit(WL1271_FLAG_IN_ELP, &wl->flags);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused wlcore_runtime_resume(struct device *dev)\n{\n\tstruct wl1271 *wl = dev_get_drvdata(dev);\n\tDECLARE_COMPLETION_ONSTACK(compl);\n\tunsigned long flags;\n\tint ret;\n\tunsigned long start_time = jiffies;\n\tbool recovery = false;\n\n\t \n\tif (!test_bit(WL1271_FLAG_IN_ELP, &wl->flags))\n\t\treturn 0;\n\n\twl1271_debug(DEBUG_PSM, \"waking up chip from elp\");\n\n\tspin_lock_irqsave(&wl->wl_lock, flags);\n\twl->elp_compl = &compl;\n\tspin_unlock_irqrestore(&wl->wl_lock, flags);\n\n\tret = wlcore_raw_write32(wl, HW_ACCESS_ELP_CTRL_REG, ELPCTRL_WAKE_UP);\n\tif (ret < 0) {\n\t\trecovery = true;\n\t} else if (!test_bit(WL1271_FLAG_IRQ_RUNNING, &wl->flags)) {\n\t\tret = wait_for_completion_timeout(&compl,\n\t\t\tmsecs_to_jiffies(WL1271_WAKEUP_TIMEOUT));\n\t\tif (ret == 0) {\n\t\t\twl1271_warning(\"ELP wakeup timeout!\");\n\t\t\trecovery = true;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&wl->wl_lock, flags);\n\twl->elp_compl = NULL;\n\tspin_unlock_irqrestore(&wl->wl_lock, flags);\n\tclear_bit(WL1271_FLAG_IN_ELP, &wl->flags);\n\n\tif (recovery) {\n\t\tset_bit(WL1271_FLAG_INTENDED_FW_RECOVERY, &wl->flags);\n\t\twl12xx_queue_recovery_work(wl);\n\t} else {\n\t\twl1271_debug(DEBUG_PSM, \"wakeup time: %u ms\",\n\t\t\t     jiffies_to_msecs(jiffies - start_time));\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops wlcore_pm_ops = {\n\tSET_RUNTIME_PM_OPS(wlcore_runtime_suspend,\n\t\t\t   wlcore_runtime_resume,\n\t\t\t   NULL)\n};\n\nint wlcore_probe(struct wl1271 *wl, struct platform_device *pdev)\n{\n\tstruct wlcore_platdev_data *pdev_data = dev_get_platdata(&pdev->dev);\n\tconst char *nvs_name;\n\tint ret = 0;\n\n\tif (!wl->ops || !wl->ptable || !pdev_data)\n\t\treturn -EINVAL;\n\n\twl->dev = &pdev->dev;\n\twl->pdev = pdev;\n\tplatform_set_drvdata(pdev, wl);\n\n\tif (pdev_data->family && pdev_data->family->nvs_name) {\n\t\tnvs_name = pdev_data->family->nvs_name;\n\t\tret = request_firmware_nowait(THIS_MODULE, FW_ACTION_UEVENT,\n\t\t\t\t\t      nvs_name, &pdev->dev, GFP_KERNEL,\n\t\t\t\t\t      wl, wlcore_nvs_cb);\n\t\tif (ret < 0) {\n\t\t\twl1271_error(\"request_firmware_nowait failed for %s: %d\",\n\t\t\t\t     nvs_name, ret);\n\t\t\tcomplete_all(&wl->nvs_loading_complete);\n\t\t}\n\t} else {\n\t\twlcore_nvs_cb(NULL, wl);\n\t}\n\n\twl->dev->driver->pm = &wlcore_pm_ops;\n\tpm_runtime_set_autosuspend_delay(wl->dev, 50);\n\tpm_runtime_use_autosuspend(wl->dev);\n\tpm_runtime_enable(wl->dev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wlcore_probe);\n\nint wlcore_remove(struct platform_device *pdev)\n{\n\tstruct wlcore_platdev_data *pdev_data = dev_get_platdata(&pdev->dev);\n\tstruct wl1271 *wl = platform_get_drvdata(pdev);\n\tint error;\n\n\terror = pm_runtime_get_sync(wl->dev);\n\tif (error < 0)\n\t\tdev_warn(wl->dev, \"PM runtime failed: %i\\n\", error);\n\n\twl->dev->driver->pm = NULL;\n\n\tif (pdev_data->family && pdev_data->family->nvs_name)\n\t\twait_for_completion(&wl->nvs_loading_complete);\n\tif (!wl->initialized)\n\t\treturn 0;\n\n\tif (wl->wakeirq >= 0) {\n\t\tdev_pm_clear_wake_irq(wl->dev);\n\t\twl->wakeirq = -ENODEV;\n\t}\n\n\tdevice_init_wakeup(wl->dev, false);\n\n\tif (wl->irq_wake_enabled)\n\t\tdisable_irq_wake(wl->irq);\n\n\twl1271_unregister_hw(wl);\n\n\tpm_runtime_put_sync(wl->dev);\n\tpm_runtime_dont_use_autosuspend(wl->dev);\n\tpm_runtime_disable(wl->dev);\n\n\tfree_irq(wl->irq, wl);\n\twlcore_free_hw(wl);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wlcore_remove);\n\nu32 wl12xx_debug_level = DEBUG_NONE;\nEXPORT_SYMBOL_GPL(wl12xx_debug_level);\nmodule_param_named(debug_level, wl12xx_debug_level, uint, 0600);\nMODULE_PARM_DESC(debug_level, \"wl12xx debugging level\");\n\nmodule_param_named(fwlog, fwlog_param, charp, 0);\nMODULE_PARM_DESC(fwlog,\n\t\t \"FW logger options: continuous, dbgpins or disable\");\n\nmodule_param(fwlog_mem_blocks, int, 0600);\nMODULE_PARM_DESC(fwlog_mem_blocks, \"fwlog mem_blocks\");\n\nmodule_param(bug_on_recovery, int, 0600);\nMODULE_PARM_DESC(bug_on_recovery, \"BUG() on fw recovery\");\n\nmodule_param(no_recovery, int, 0600);\nMODULE_PARM_DESC(no_recovery, \"Prevent HW recovery. FW will remain stuck.\");\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Luciano Coelho <coelho@ti.com>\");\nMODULE_AUTHOR(\"Juuso Oikarinen <juuso.oikarinen@nokia.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}