{
  "module_name": "testmode.c",
  "hash_id": "90318089f278f120692eec355c125d5d4782c36b8de44c593800a1f56f4673e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wlcore/testmode.c",
  "human_readable_source": "\n \n#include \"testmode.h\"\n\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <net/genetlink.h>\n\n#include \"wlcore.h\"\n#include \"debug.h\"\n#include \"acx.h\"\n#include \"io.h\"\n\n#define WL1271_TM_MAX_DATA_LENGTH 1024\n\nenum wl1271_tm_commands {\n\tWL1271_TM_CMD_UNSPEC,\n\tWL1271_TM_CMD_TEST,\n\tWL1271_TM_CMD_INTERROGATE,\n\tWL1271_TM_CMD_CONFIGURE,\n\tWL1271_TM_CMD_NVS_PUSH,\t\t \n\tWL1271_TM_CMD_SET_PLT_MODE,\n\tWL1271_TM_CMD_RECOVER,\t\t \n\tWL1271_TM_CMD_GET_MAC,\n\n\t__WL1271_TM_CMD_AFTER_LAST\n};\n#define WL1271_TM_CMD_MAX (__WL1271_TM_CMD_AFTER_LAST - 1)\n\nenum wl1271_tm_attrs {\n\tWL1271_TM_ATTR_UNSPEC,\n\tWL1271_TM_ATTR_CMD_ID,\n\tWL1271_TM_ATTR_ANSWER,\n\tWL1271_TM_ATTR_DATA,\n\tWL1271_TM_ATTR_IE_ID,\n\tWL1271_TM_ATTR_PLT_MODE,\n\n\t__WL1271_TM_ATTR_AFTER_LAST\n};\n#define WL1271_TM_ATTR_MAX (__WL1271_TM_ATTR_AFTER_LAST - 1)\n\nstatic struct nla_policy wl1271_tm_policy[WL1271_TM_ATTR_MAX + 1] = {\n\t[WL1271_TM_ATTR_CMD_ID] =\t{ .type = NLA_U32 },\n\t[WL1271_TM_ATTR_ANSWER] =\t{ .type = NLA_U8 },\n\t[WL1271_TM_ATTR_DATA] =\t\t{ .type = NLA_BINARY,\n\t\t\t\t\t  .len = WL1271_TM_MAX_DATA_LENGTH },\n\t[WL1271_TM_ATTR_IE_ID] =\t{ .type = NLA_U32 },\n\t[WL1271_TM_ATTR_PLT_MODE] =\t{ .type = NLA_U32 },\n};\n\n\nstatic int wl1271_tm_cmd_test(struct wl1271 *wl, struct nlattr *tb[])\n{\n\tint buf_len, ret, len;\n\tstruct sk_buff *skb;\n\tvoid *buf;\n\tu8 answer = 0;\n\n\twl1271_debug(DEBUG_TESTMODE, \"testmode cmd test\");\n\n\tif (!tb[WL1271_TM_ATTR_DATA])\n\t\treturn -EINVAL;\n\n\tbuf = nla_data(tb[WL1271_TM_ATTR_DATA]);\n\tbuf_len = nla_len(tb[WL1271_TM_ATTR_DATA]);\n\n\tif (tb[WL1271_TM_ATTR_ANSWER])\n\t\tanswer = nla_get_u8(tb[WL1271_TM_ATTR_ANSWER]);\n\n\tif (buf_len > sizeof(struct wl1271_command))\n\t\treturn -EMSGSIZE;\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl1271_cmd_test(wl, buf, buf_len, answer);\n\tif (ret < 0) {\n\t\twl1271_warning(\"testmode cmd test failed: %d\", ret);\n\t\tgoto out_sleep;\n\t}\n\n\tif (answer) {\n\t\t \n\t\tstruct wl1271_cmd_cal_p2g *params =\n\t\t\t(struct wl1271_cmd_cal_p2g *) buf;\n\n\t\ts16 radio_status = (s16) le16_to_cpu(params->radio_status);\n\n\t\tif (params->test.id == TEST_CMD_P2G_CAL &&\n\t\t    radio_status < 0)\n\t\t\twl1271_warning(\"testmode cmd: radio status=%d\",\n\t\t\t\t\tradio_status);\n\t\telse\n\t\t\twl1271_info(\"testmode cmd: radio status=%d\",\n\t\t\t\t\tradio_status);\n\n\t\tlen = nla_total_size(buf_len);\n\t\tskb = cfg80211_testmode_alloc_reply_skb(wl->hw->wiphy, len);\n\t\tif (!skb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_sleep;\n\t\t}\n\n\t\tif (nla_put(skb, WL1271_TM_ATTR_DATA, buf_len, buf)) {\n\t\t\tkfree_skb(skb);\n\t\t\tret = -EMSGSIZE;\n\t\t\tgoto out_sleep;\n\t\t}\n\n\t\tret = cfg80211_testmode_reply(skb);\n\t\tif (ret < 0)\n\t\t\tgoto out_sleep;\n\t}\n\nout_sleep:\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\nout:\n\tmutex_unlock(&wl->mutex);\n\n\treturn ret;\n}\n\nstatic int wl1271_tm_cmd_interrogate(struct wl1271 *wl, struct nlattr *tb[])\n{\n\tint ret;\n\tstruct wl1271_command *cmd;\n\tstruct sk_buff *skb;\n\tu8 ie_id;\n\n\twl1271_debug(DEBUG_TESTMODE, \"testmode cmd interrogate\");\n\n\tif (!tb[WL1271_TM_ATTR_IE_ID])\n\t\treturn -EINVAL;\n\n\tie_id = nla_get_u8(tb[WL1271_TM_ATTR_IE_ID]);\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out_sleep;\n\t}\n\n\tret = wl1271_cmd_interrogate(wl, ie_id, cmd,\n\t\t\t\t     sizeof(struct acx_header), sizeof(*cmd));\n\tif (ret < 0) {\n\t\twl1271_warning(\"testmode cmd interrogate failed: %d\", ret);\n\t\tgoto out_free;\n\t}\n\n\tskb = cfg80211_testmode_alloc_reply_skb(wl->hw->wiphy, sizeof(*cmd));\n\tif (!skb) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tif (nla_put(skb, WL1271_TM_ATTR_DATA, sizeof(*cmd), cmd)) {\n\t\tkfree_skb(skb);\n\t\tret = -EMSGSIZE;\n\t\tgoto out_free;\n\t}\n\n\tret = cfg80211_testmode_reply(skb);\n\tif (ret < 0)\n\t\tgoto out_free;\n\nout_free:\n\tkfree(cmd);\nout_sleep:\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\nout:\n\tmutex_unlock(&wl->mutex);\n\n\treturn ret;\n}\n\nstatic int wl1271_tm_cmd_configure(struct wl1271 *wl, struct nlattr *tb[])\n{\n\tint buf_len, ret;\n\tvoid *buf;\n\tu8 ie_id;\n\n\twl1271_debug(DEBUG_TESTMODE, \"testmode cmd configure\");\n\n\tif (!tb[WL1271_TM_ATTR_DATA])\n\t\treturn -EINVAL;\n\tif (!tb[WL1271_TM_ATTR_IE_ID])\n\t\treturn -EINVAL;\n\n\tie_id = nla_get_u8(tb[WL1271_TM_ATTR_IE_ID]);\n\tbuf = nla_data(tb[WL1271_TM_ATTR_DATA]);\n\tbuf_len = nla_len(tb[WL1271_TM_ATTR_DATA]);\n\n\tif (buf_len > sizeof(struct wl1271_command))\n\t\treturn -EMSGSIZE;\n\n\tmutex_lock(&wl->mutex);\n\tret = wl1271_cmd_configure(wl, ie_id, buf, buf_len);\n\tmutex_unlock(&wl->mutex);\n\n\tif (ret < 0) {\n\t\twl1271_warning(\"testmode cmd configure failed: %d\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int wl1271_tm_detect_fem(struct wl1271 *wl, struct nlattr *tb[])\n{\n\t \n\tint ret, len;\n\tstruct sk_buff *skb;\n\n\tret = wl1271_plt_start(wl, PLT_FEM_DETECT);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tmutex_lock(&wl->mutex);\n\n\tlen = nla_total_size(sizeof(wl->fem_manuf));\n\tskb = cfg80211_testmode_alloc_reply_skb(wl->hw->wiphy, len);\n\tif (!skb) {\n\t\tret = -ENOMEM;\n\t\tgoto out_mutex;\n\t}\n\n\tif (nla_put(skb, WL1271_TM_ATTR_DATA, sizeof(wl->fem_manuf),\n\t\t\t\t\t      &wl->fem_manuf)) {\n\t\tkfree_skb(skb);\n\t\tret = -EMSGSIZE;\n\t\tgoto out_mutex;\n\t}\n\n\tret = cfg80211_testmode_reply(skb);\n\nout_mutex:\n\tmutex_unlock(&wl->mutex);\n\n\t \n\twl1271_plt_stop(wl);\nout:\n\treturn ret;\n}\n\nstatic int wl1271_tm_cmd_set_plt_mode(struct wl1271 *wl, struct nlattr *tb[])\n{\n\tu32 val;\n\tint ret;\n\n\twl1271_debug(DEBUG_TESTMODE, \"testmode cmd set plt mode\");\n\n\tif (!tb[WL1271_TM_ATTR_PLT_MODE])\n\t\treturn -EINVAL;\n\n\tval = nla_get_u32(tb[WL1271_TM_ATTR_PLT_MODE]);\n\n\tswitch (val) {\n\tcase PLT_OFF:\n\t\tret = wl1271_plt_stop(wl);\n\t\tbreak;\n\tcase PLT_ON:\n\tcase PLT_CHIP_AWAKE:\n\t\tret = wl1271_plt_start(wl, val);\n\t\tbreak;\n\tcase PLT_FEM_DETECT:\n\t\tret = wl1271_tm_detect_fem(wl, tb);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int wl12xx_tm_cmd_get_mac(struct wl1271 *wl, struct nlattr *tb[])\n{\n\tstruct sk_buff *skb;\n\tu8 mac_addr[ETH_ALEN];\n\tint ret = 0;\n\n\tmutex_lock(&wl->mutex);\n\n\tif (!wl->plt) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (wl->fuse_oui_addr == 0 && wl->fuse_nic_addr == 0) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tmac_addr[0] = (u8)(wl->fuse_oui_addr >> 16);\n\tmac_addr[1] = (u8)(wl->fuse_oui_addr >> 8);\n\tmac_addr[2] = (u8) wl->fuse_oui_addr;\n\tmac_addr[3] = (u8)(wl->fuse_nic_addr >> 16);\n\tmac_addr[4] = (u8)(wl->fuse_nic_addr >> 8);\n\tmac_addr[5] = (u8) wl->fuse_nic_addr;\n\n\tskb = cfg80211_testmode_alloc_reply_skb(wl->hw->wiphy, ETH_ALEN);\n\tif (!skb) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (nla_put(skb, WL1271_TM_ATTR_DATA, ETH_ALEN, mac_addr)) {\n\t\tkfree_skb(skb);\n\t\tret = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\tret = cfg80211_testmode_reply(skb);\n\tif (ret < 0)\n\t\tgoto out;\n\nout:\n\tmutex_unlock(&wl->mutex);\n\treturn ret;\n}\n\nint wl1271_tm_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t  void *data, int len)\n{\n\tstruct wl1271 *wl = hw->priv;\n\tstruct nlattr *tb[WL1271_TM_ATTR_MAX + 1];\n\tu32 nla_cmd;\n\tint err;\n\n\terr = nla_parse_deprecated(tb, WL1271_TM_ATTR_MAX, data, len,\n\t\t\t\t   wl1271_tm_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[WL1271_TM_ATTR_CMD_ID])\n\t\treturn -EINVAL;\n\n\tnla_cmd = nla_get_u32(tb[WL1271_TM_ATTR_CMD_ID]);\n\n\t \n\tif (wl->plt_mode == PLT_CHIP_AWAKE &&\n\t    nla_cmd != WL1271_TM_CMD_SET_PLT_MODE)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (nla_cmd) {\n\tcase WL1271_TM_CMD_TEST:\n\t\treturn wl1271_tm_cmd_test(wl, tb);\n\tcase WL1271_TM_CMD_INTERROGATE:\n\t\treturn wl1271_tm_cmd_interrogate(wl, tb);\n\tcase WL1271_TM_CMD_CONFIGURE:\n\t\treturn wl1271_tm_cmd_configure(wl, tb);\n\tcase WL1271_TM_CMD_SET_PLT_MODE:\n\t\treturn wl1271_tm_cmd_set_plt_mode(wl, tb);\n\tcase WL1271_TM_CMD_GET_MAC:\n\t\treturn wl12xx_tm_cmd_get_mac(wl, tb);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}