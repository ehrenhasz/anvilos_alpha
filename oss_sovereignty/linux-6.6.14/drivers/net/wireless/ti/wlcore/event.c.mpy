{
  "module_name": "event.c",
  "hash_id": "7d40a5b52e8959a561fe3234fa798736ada523213d0539fcffef5ef02e0a833a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wlcore/event.c",
  "human_readable_source": "\n \n\n#include \"wlcore.h\"\n#include \"debug.h\"\n#include \"io.h\"\n#include \"event.h\"\n#include \"ps.h\"\n#include \"scan.h\"\n#include \"wl12xx_80211.h\"\n#include \"hw_ops.h\"\n\n#define WL18XX_LOGGER_SDIO_BUFF_MAX\t(0x1020)\n#define WL18XX_DATA_RAM_BASE_ADDRESS\t(0x20000000)\n#define WL18XX_LOGGER_SDIO_BUFF_ADDR\t(0x40159c)\n#define WL18XX_LOGGER_BUFF_OFFSET\t(sizeof(struct fw_logger_information))\n#define WL18XX_LOGGER_READ_POINT_OFFSET\t\t(12)\n\nint wlcore_event_fw_logger(struct wl1271 *wl)\n{\n\tint ret;\n\tstruct fw_logger_information fw_log;\n\tu8  *buffer;\n\tu32 internal_fw_addrbase = WL18XX_DATA_RAM_BASE_ADDRESS;\n\tu32 addr = WL18XX_LOGGER_SDIO_BUFF_ADDR;\n\tu32 addr_ptr;\n\tu32 buff_start_ptr;\n\tu32 buff_read_ptr;\n\tu32 buff_end_ptr;\n\tu32 available_len;\n\tu32 actual_len;\n\tu32 clear_ptr;\n\tsize_t len;\n\tu32 start_loc;\n\n\tbuffer = kzalloc(WL18XX_LOGGER_SDIO_BUFF_MAX, GFP_KERNEL);\n\tif (!buffer) {\n\t\twl1271_error(\"Fail to allocate fw logger memory\");\n\t\tactual_len = 0;\n\t\tgoto out;\n\t}\n\n\tret = wlcore_read(wl, addr, buffer, WL18XX_LOGGER_SDIO_BUFF_MAX,\n\t\t\t  false);\n\tif (ret < 0) {\n\t\twl1271_error(\"Fail to read logger buffer, error_id = %d\",\n\t\t\t     ret);\n\t\tactual_len = 0;\n\t\tgoto free_out;\n\t}\n\n\tmemcpy(&fw_log, buffer, sizeof(fw_log));\n\n\tactual_len = le32_to_cpu(fw_log.actual_buff_size);\n\tif (actual_len == 0)\n\t\tgoto free_out;\n\n\t \n\taddr_ptr = internal_fw_addrbase + addr;\n\n\t \n\tbuff_start_ptr = addr_ptr + WL18XX_LOGGER_BUFF_OFFSET;\n\tbuff_end_ptr = buff_start_ptr + le32_to_cpu(fw_log.max_buff_size);\n\n\t \n\tbuff_read_ptr = le32_to_cpu(fw_log.buff_read_ptr);\n\tif (buff_read_ptr < buff_start_ptr ||\n\t    buff_read_ptr >= buff_end_ptr) {\n\t\twl1271_error(\"buffer read pointer out of bounds: %x not in (%x-%x)\\n\",\n\t\t\t     buff_read_ptr, buff_start_ptr, buff_end_ptr);\n\t\tgoto free_out;\n\t}\n\n\tstart_loc = buff_read_ptr - addr_ptr;\n\tavailable_len = buff_end_ptr - buff_read_ptr;\n\n\t \n\tlen = min(actual_len, available_len);\n\twl12xx_copy_fwlog(wl, &buffer[start_loc], len);\n\tclear_ptr = addr_ptr + start_loc + actual_len;\n\tif (clear_ptr == buff_end_ptr)\n\t\tclear_ptr = buff_start_ptr;\n\n\t \n\tlen = actual_len - len;\n\tif (len) {\n\t\twl12xx_copy_fwlog(wl,\n\t\t\t\t  &buffer[WL18XX_LOGGER_BUFF_OFFSET],\n\t\t\t\t  len);\n\t\tclear_ptr = addr_ptr + WL18XX_LOGGER_BUFF_OFFSET + len;\n\t}\n\n\t \n\tret = wlcore_write32(wl, addr + WL18XX_LOGGER_READ_POINT_OFFSET,\n\t\t\t     clear_ptr);\nfree_out:\n\tkfree(buffer);\nout:\n\treturn actual_len;\n}\nEXPORT_SYMBOL_GPL(wlcore_event_fw_logger);\n\nvoid wlcore_event_rssi_trigger(struct wl1271 *wl, s8 *metric_arr)\n{\n\tstruct wl12xx_vif *wlvif;\n\tstruct ieee80211_vif *vif;\n\tenum nl80211_cqm_rssi_threshold_event event;\n\ts8 metric = metric_arr[0];\n\n\twl1271_debug(DEBUG_EVENT, \"RSSI trigger metric: %d\", metric);\n\n\t \n\twl12xx_for_each_wlvif_sta(wl, wlvif) {\n\t\tif (metric <= wlvif->rssi_thold)\n\t\t\tevent = NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW;\n\t\telse\n\t\t\tevent = NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH;\n\n\t\tvif = wl12xx_wlvif_to_vif(wlvif);\n\t\tif (event != wlvif->last_rssi_event)\n\t\t\tieee80211_cqm_rssi_notify(vif, event, metric,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\twlvif->last_rssi_event = event;\n\t}\n}\nEXPORT_SYMBOL_GPL(wlcore_event_rssi_trigger);\n\nstatic void wl1271_stop_ba_event(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tstruct ieee80211_vif *vif = wl12xx_wlvif_to_vif(wlvif);\n\n\tif (wlvif->bss_type != BSS_TYPE_AP_BSS) {\n\t\tu8 hlid = wlvif->sta.hlid;\n\t\tif (!wl->links[hlid].ba_bitmap)\n\t\t\treturn;\n\t\tieee80211_stop_rx_ba_session(vif, wl->links[hlid].ba_bitmap,\n\t\t\t\t\t     vif->bss_conf.bssid);\n\t} else {\n\t\tu8 hlid;\n\t\tstruct wl1271_link *lnk;\n\t\tfor_each_set_bit(hlid, wlvif->ap.sta_hlid_map,\n\t\t\t\t wl->num_links) {\n\t\t\tlnk = &wl->links[hlid];\n\t\t\tif (!lnk->ba_bitmap)\n\t\t\t\tcontinue;\n\n\t\t\tieee80211_stop_rx_ba_session(vif,\n\t\t\t\t\t\t     lnk->ba_bitmap,\n\t\t\t\t\t\t     lnk->addr);\n\t\t}\n\t}\n}\n\nvoid wlcore_event_soft_gemini_sense(struct wl1271 *wl, u8 enable)\n{\n\tstruct wl12xx_vif *wlvif;\n\n\tif (enable) {\n\t\tset_bit(WL1271_FLAG_SOFT_GEMINI, &wl->flags);\n\t} else {\n\t\tclear_bit(WL1271_FLAG_SOFT_GEMINI, &wl->flags);\n\t\twl12xx_for_each_wlvif_sta(wl, wlvif) {\n\t\t\twl1271_recalc_rx_streaming(wl, wlvif);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(wlcore_event_soft_gemini_sense);\n\nvoid wlcore_event_sched_scan_completed(struct wl1271 *wl,\n\t\t\t\t       u8 status)\n{\n\twl1271_debug(DEBUG_EVENT, \"PERIODIC_SCAN_COMPLETE_EVENT (status 0x%0x)\",\n\t\t     status);\n\n\tif (wl->sched_vif) {\n\t\tieee80211_sched_scan_stopped(wl->hw);\n\t\twl->sched_vif = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(wlcore_event_sched_scan_completed);\n\nvoid wlcore_event_ba_rx_constraint(struct wl1271 *wl,\n\t\t\t\t   unsigned long roles_bitmap,\n\t\t\t\t   unsigned long allowed_bitmap)\n{\n\tstruct wl12xx_vif *wlvif;\n\n\twl1271_debug(DEBUG_EVENT, \"%s: roles=0x%lx allowed=0x%lx\",\n\t\t     __func__, roles_bitmap, allowed_bitmap);\n\n\twl12xx_for_each_wlvif(wl, wlvif) {\n\t\tif (wlvif->role_id == WL12XX_INVALID_ROLE_ID ||\n\t\t    !test_bit(wlvif->role_id , &roles_bitmap))\n\t\t\tcontinue;\n\n\t\twlvif->ba_allowed = !!test_bit(wlvif->role_id,\n\t\t\t\t\t       &allowed_bitmap);\n\t\tif (!wlvif->ba_allowed)\n\t\t\twl1271_stop_ba_event(wl, wlvif);\n\t}\n}\nEXPORT_SYMBOL_GPL(wlcore_event_ba_rx_constraint);\n\nvoid wlcore_event_channel_switch(struct wl1271 *wl,\n\t\t\t\t unsigned long roles_bitmap,\n\t\t\t\t bool success)\n{\n\tstruct wl12xx_vif *wlvif;\n\tstruct ieee80211_vif *vif;\n\n\twl1271_debug(DEBUG_EVENT, \"%s: roles=0x%lx success=%d\",\n\t\t     __func__, roles_bitmap, success);\n\n\twl12xx_for_each_wlvif(wl, wlvif) {\n\t\tif (wlvif->role_id == WL12XX_INVALID_ROLE_ID ||\n\t\t    !test_bit(wlvif->role_id , &roles_bitmap))\n\t\t\tcontinue;\n\n\t\tif (!test_and_clear_bit(WLVIF_FLAG_CS_PROGRESS,\n\t\t\t\t\t&wlvif->flags))\n\t\t\tcontinue;\n\n\t\tvif = wl12xx_wlvif_to_vif(wlvif);\n\n\t\tif (wlvif->bss_type == BSS_TYPE_STA_BSS) {\n\t\t\tieee80211_chswitch_done(vif, success);\n\t\t\tcancel_delayed_work(&wlvif->channel_switch_work);\n\t\t} else {\n\t\t\tset_bit(WLVIF_FLAG_BEACON_DISABLED, &wlvif->flags);\n\t\t\tieee80211_csa_finish(vif);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(wlcore_event_channel_switch);\n\nvoid wlcore_event_dummy_packet(struct wl1271 *wl)\n{\n\tif (wl->plt) {\n\t\twl1271_info(\"Got DUMMY_PACKET event in PLT mode.  FW bug, ignoring.\");\n\t\treturn;\n\t}\n\n\twl1271_debug(DEBUG_EVENT, \"DUMMY_PACKET_ID_EVENT_ID\");\n\twl1271_tx_dummy_packet(wl);\n}\nEXPORT_SYMBOL_GPL(wlcore_event_dummy_packet);\n\nstatic void wlcore_disconnect_sta(struct wl1271 *wl, unsigned long sta_bitmap)\n{\n\tu32 num_packets = wl->conf.tx.max_tx_retries;\n\tstruct wl12xx_vif *wlvif;\n\tstruct ieee80211_vif *vif;\n\tstruct ieee80211_sta *sta;\n\tconst u8 *addr;\n\tint h;\n\n\tfor_each_set_bit(h, &sta_bitmap, wl->num_links) {\n\t\tbool found = false;\n\t\t \n\t\twl12xx_for_each_wlvif_ap(wl, wlvif) {\n\t\t\tif (!test_bit(h, wlvif->ap.sta_hlid_map))\n\t\t\t\tcontinue;\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tvif = wl12xx_wlvif_to_vif(wlvif);\n\t\taddr = wl->links[h].addr;\n\n\t\trcu_read_lock();\n\t\tsta = ieee80211_find_sta(vif, addr);\n\t\tif (sta) {\n\t\t\twl1271_debug(DEBUG_EVENT, \"remove sta %d\", h);\n\t\t\tieee80211_report_low_ack(sta, num_packets);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n}\n\nvoid wlcore_event_max_tx_failure(struct wl1271 *wl, unsigned long sta_bitmap)\n{\n\twl1271_debug(DEBUG_EVENT, \"MAX_TX_FAILURE_EVENT_ID\");\n\twlcore_disconnect_sta(wl, sta_bitmap);\n}\nEXPORT_SYMBOL_GPL(wlcore_event_max_tx_failure);\n\nvoid wlcore_event_inactive_sta(struct wl1271 *wl, unsigned long sta_bitmap)\n{\n\twl1271_debug(DEBUG_EVENT, \"INACTIVE_STA_EVENT_ID\");\n\twlcore_disconnect_sta(wl, sta_bitmap);\n}\nEXPORT_SYMBOL_GPL(wlcore_event_inactive_sta);\n\nvoid wlcore_event_roc_complete(struct wl1271 *wl)\n{\n\twl1271_debug(DEBUG_EVENT, \"REMAIN_ON_CHANNEL_COMPLETE_EVENT_ID\");\n\tif (wl->roc_vif)\n\t\tieee80211_ready_on_channel(wl->hw);\n}\nEXPORT_SYMBOL_GPL(wlcore_event_roc_complete);\n\nvoid wlcore_event_beacon_loss(struct wl1271 *wl, unsigned long roles_bitmap)\n{\n\t \n\tstruct wl12xx_vif *wlvif;\n\tstruct ieee80211_vif *vif;\n\tint delay = wl->conf.conn.synch_fail_thold *\n\t\t\t\twl->conf.conn.bss_lose_timeout;\n\n\twl1271_info(\"Beacon loss detected. roles:0x%lx\", roles_bitmap);\n\n\twl12xx_for_each_wlvif_sta(wl, wlvif) {\n\t\tif (wlvif->role_id == WL12XX_INVALID_ROLE_ID ||\n\t\t    !test_bit(wlvif->role_id , &roles_bitmap))\n\t\t\tcontinue;\n\n\t\tvif = wl12xx_wlvif_to_vif(wlvif);\n\n\t\t \n\t\tif (wlvif->p2p) {\n\t\t\tieee80211_connection_loss(vif);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tieee80211_queue_delayed_work(wl->hw,\n\t\t\t\t\t     &wlvif->connection_loss_work,\n\t\t\t\t\t     msecs_to_jiffies(delay));\n\n\t\tieee80211_cqm_beacon_loss_notify(vif, GFP_KERNEL);\n\t}\n}\nEXPORT_SYMBOL_GPL(wlcore_event_beacon_loss);\n\nint wl1271_event_unmask(struct wl1271 *wl)\n{\n\tint ret;\n\n\twl1271_debug(DEBUG_EVENT, \"unmasking event_mask 0x%x\", wl->event_mask);\n\tret = wl1271_acx_event_mbox_mask(wl, ~(wl->event_mask));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint wl1271_event_handle(struct wl1271 *wl, u8 mbox_num)\n{\n\tint ret;\n\n\twl1271_debug(DEBUG_EVENT, \"EVENT on mbox %d\", mbox_num);\n\n\tif (mbox_num > 1)\n\t\treturn -EINVAL;\n\n\t \n\tret = wlcore_read(wl, wl->mbox_ptr[mbox_num], wl->mbox,\n\t\t\t  wl->mbox_size, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wl->ops->process_mailbox_events(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wl->ops->ack_event(wl);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}