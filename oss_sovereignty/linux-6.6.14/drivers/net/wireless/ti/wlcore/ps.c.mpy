{
  "module_name": "ps.c",
  "hash_id": "a101d2de65f1317c014b4fa38276210577b0513dafa6ffce2c30cea687e24d76",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wlcore/ps.c",
  "human_readable_source": "\n \n\n#include \"ps.h\"\n#include \"io.h\"\n#include \"tx.h\"\n#include \"debug.h\"\n\nint wl1271_ps_set_mode(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t       enum wl1271_cmd_ps_mode mode)\n{\n\tint ret;\n\tu16 timeout = wl->conf.conn.dynamic_ps_timeout;\n\n\tswitch (mode) {\n\tcase STATION_AUTO_PS_MODE:\n\tcase STATION_POWER_SAVE_MODE:\n\t\twl1271_debug(DEBUG_PSM, \"entering psm (mode=%d,timeout=%u)\",\n\t\t\t     mode, timeout);\n\n\t\tret = wl1271_acx_wake_up_conditions(wl, wlvif,\n\t\t\t\t\t    wl->conf.conn.wake_up_event,\n\t\t\t\t\t    wl->conf.conn.listen_interval);\n\t\tif (ret < 0) {\n\t\t\twl1271_error(\"couldn't set wake up conditions\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = wl1271_cmd_ps_mode(wl, wlvif, mode, timeout);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tset_bit(WLVIF_FLAG_IN_PS, &wlvif->flags);\n\n\t\t \n\t\tif ((wlvif->band == NL80211_BAND_2GHZ) &&\n\t\t    (wlvif->basic_rate < CONF_HW_BIT_RATE_9MBPS)) {\n\t\t\tret = wl1271_acx_bet_enable(wl, wlvif, true);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase STATION_ACTIVE_MODE:\n\t\twl1271_debug(DEBUG_PSM, \"leaving psm\");\n\n\t\t \n\t\tif ((wlvif->band == NL80211_BAND_2GHZ) &&\n\t\t    (wlvif->basic_rate < CONF_HW_BIT_RATE_9MBPS)) {\n\t\t\tret = wl1271_acx_bet_enable(wl, wlvif, false);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tret = wl1271_cmd_ps_mode(wl, wlvif, mode, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tclear_bit(WLVIF_FLAG_IN_PS, &wlvif->flags);\n\t\tbreak;\n\tdefault:\n\t\twl1271_warning(\"trying to set ps to unsupported mode %d\", mode);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic void wl1271_ps_filter_frames(struct wl1271 *wl, u8 hlid)\n{\n\tint i;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_tx_info *info;\n\tunsigned long flags;\n\tint filtered[NUM_TX_QUEUES];\n\tstruct wl1271_link *lnk = &wl->links[hlid];\n\n\t \n\tfor (i = 0; i < NUM_TX_QUEUES; i++) {\n\t\tfiltered[i] = 0;\n\t\twhile ((skb = skb_dequeue(&lnk->tx_queue[i]))) {\n\t\t\tfiltered[i]++;\n\n\t\t\tif (WARN_ON(wl12xx_is_dummy_packet(wl, skb)))\n\t\t\t\tcontinue;\n\n\t\t\tinfo = IEEE80211_SKB_CB(skb);\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_TX_FILTERED;\n\t\t\tinfo->status.rates[0].idx = -1;\n\t\t\tieee80211_tx_status_ni(wl->hw, skb);\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&wl->wl_lock, flags);\n\tfor (i = 0; i < NUM_TX_QUEUES; i++) {\n\t\twl->tx_queue_count[i] -= filtered[i];\n\t\tif (lnk->wlvif)\n\t\t\tlnk->wlvif->tx_queue_count[i] -= filtered[i];\n\t}\n\tspin_unlock_irqrestore(&wl->wl_lock, flags);\n\n\twl1271_handle_tx_low_watermark(wl);\n}\n\nvoid wl12xx_ps_link_start(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t  u8 hlid, bool clean_queues)\n{\n\tstruct ieee80211_sta *sta;\n\tstruct ieee80211_vif *vif = wl12xx_wlvif_to_vif(wlvif);\n\n\tif (WARN_ON_ONCE(wlvif->bss_type != BSS_TYPE_AP_BSS))\n\t\treturn;\n\n\tif (!test_bit(hlid, wlvif->ap.sta_hlid_map) ||\n\t    test_bit(hlid, &wl->ap_ps_map))\n\t\treturn;\n\n\twl1271_debug(DEBUG_PSM, \"start mac80211 PSM on hlid %d pkts %d \"\n\t\t     \"clean_queues %d\", hlid, wl->links[hlid].allocated_pkts,\n\t\t     clean_queues);\n\n\trcu_read_lock();\n\tsta = ieee80211_find_sta(vif, wl->links[hlid].addr);\n\tif (!sta) {\n\t\twl1271_error(\"could not find sta %pM for starting ps\",\n\t\t\t     wl->links[hlid].addr);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tieee80211_sta_ps_transition_ni(sta, true);\n\trcu_read_unlock();\n\n\t \n\tif (clean_queues)\n\t\twl1271_ps_filter_frames(wl, hlid);\n\n\t__set_bit(hlid, &wl->ap_ps_map);\n}\n\nvoid wl12xx_ps_link_end(struct wl1271 *wl, struct wl12xx_vif *wlvif, u8 hlid)\n{\n\tstruct ieee80211_sta *sta;\n\tstruct ieee80211_vif *vif = wl12xx_wlvif_to_vif(wlvif);\n\n\tif (!test_bit(hlid, &wl->ap_ps_map))\n\t\treturn;\n\n\twl1271_debug(DEBUG_PSM, \"end mac80211 PSM on hlid %d\", hlid);\n\n\t__clear_bit(hlid, &wl->ap_ps_map);\n\n\trcu_read_lock();\n\tsta = ieee80211_find_sta(vif, wl->links[hlid].addr);\n\tif (!sta) {\n\t\twl1271_error(\"could not find sta %pM for ending ps\",\n\t\t\t     wl->links[hlid].addr);\n\t\tgoto end;\n\t}\n\n\tieee80211_sta_ps_transition_ni(sta, false);\nend:\n\trcu_read_unlock();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}