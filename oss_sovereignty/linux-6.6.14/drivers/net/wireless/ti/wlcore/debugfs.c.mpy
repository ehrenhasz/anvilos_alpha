{
  "module_name": "debugfs.c",
  "hash_id": "78f360fef16b1efd1603f6b58c2e0c89f0ae349f5feb1a946d79d0c861bf4f9f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wlcore/debugfs.c",
  "human_readable_source": "\n \n\n#include \"debugfs.h\"\n\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n\n#include \"wlcore.h\"\n#include \"debug.h\"\n#include \"acx.h\"\n#include \"ps.h\"\n#include \"io.h\"\n#include \"tx.h\"\n#include \"hw_ops.h\"\n\n \n#define WL1271_DEBUGFS_STATS_LIFETIME 1000\n\n#define WLCORE_MAX_BLOCK_SIZE ((size_t)(4*PAGE_SIZE))\n\n \nint wl1271_format_buffer(char __user *userbuf, size_t count,\n\t\t\t loff_t *ppos, char *fmt, ...)\n{\n\tva_list args;\n\tchar buf[DEBUGFS_FORMAT_BUFFER_SIZE];\n\tint res;\n\n\tva_start(args, fmt);\n\tres = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\treturn simple_read_from_buffer(userbuf, count, ppos, buf, res);\n}\nEXPORT_SYMBOL_GPL(wl1271_format_buffer);\n\nvoid wl1271_debugfs_update_stats(struct wl1271 *wl)\n{\n\tint ret;\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON))\n\t\tgoto out;\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!wl->plt &&\n\t    time_after(jiffies, wl->stats.fw_stats_update +\n\t\t       msecs_to_jiffies(WL1271_DEBUGFS_STATS_LIFETIME))) {\n\t\twl1271_acx_statistics(wl, wl->stats.fw_stats);\n\t\twl->stats.fw_stats_update = jiffies;\n\t}\n\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\n\nout:\n\tmutex_unlock(&wl->mutex);\n}\nEXPORT_SYMBOL_GPL(wl1271_debugfs_update_stats);\n\nDEBUGFS_READONLY_FILE(retry_count, \"%u\", wl->stats.retry_count);\nDEBUGFS_READONLY_FILE(excessive_retries, \"%u\",\n\t\t      wl->stats.excessive_retries);\n\nstatic ssize_t tx_queue_len_read(struct file *file, char __user *userbuf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\tu32 queue_len;\n\tchar buf[20];\n\tint res;\n\n\tqueue_len = wl1271_tx_total_queue_count(wl);\n\n\tres = scnprintf(buf, sizeof(buf), \"%u\\n\", queue_len);\n\treturn simple_read_from_buffer(userbuf, count, ppos, buf, res);\n}\n\nstatic const struct file_operations tx_queue_len_ops = {\n\t.read = tx_queue_len_read,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic void chip_op_handler(struct wl1271 *wl, unsigned long value,\n\t\t\t    void *arg)\n{\n\tint ret;\n\tint (*chip_op) (struct wl1271 *wl);\n\n\tif (!arg) {\n\t\twl1271_warning(\"debugfs chip_op_handler with no callback\");\n\t\treturn;\n\t}\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\treturn;\n\n\tchip_op = arg;\n\tchip_op(wl);\n\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\n}\n\n#define WL12XX_CONF_DEBUGFS(param, conf_sub_struct,\t\t\t\\\n\t\t\t    min_val, max_val, write_handler_locked,\t\\\n\t\t\t    write_handler_arg)\t\t\t\t\\\n\tstatic ssize_t param##_read(struct file *file,\t\t\t\\\n\t\t\t\t      char __user *user_buf,\t\t\\\n\t\t\t\t      size_t count, loff_t *ppos)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\tstruct wl1271 *wl = file->private_data;\t\t\t\t\\\n\treturn wl1271_format_buffer(user_buf, count,\t\t\t\\\n\t\t\t\t    ppos, \"%d\\n\",\t\t\t\\\n\t\t\t\t    wl->conf.conf_sub_struct.param);\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tstatic ssize_t param##_write(struct file *file,\t\t\t\\\n\t\t\t\t     const char __user *user_buf,\t\\\n\t\t\t\t     size_t count, loff_t *ppos)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\tstruct wl1271 *wl = file->private_data;\t\t\t\t\\\n\tunsigned long value;\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = kstrtoul_from_user(user_buf, count, 10, &value);\t\t\\\n\tif (ret < 0) {\t\t\t\t\t\t\t\\\n\t\twl1271_warning(\"illegal value for \" #param);\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (value < min_val || value > max_val) {\t\t\t\\\n\t\twl1271_warning(#param \" is not in valid range\");\t\\\n\t\treturn -ERANGE;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&wl->mutex);\t\t\t\t\t\t\\\n\twl->conf.conf_sub_struct.param = value;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\twrite_handler_locked(wl, value, write_handler_arg);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(&wl->mutex);\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tstatic const struct file_operations param##_ops = {\t\t\\\n\t\t.read = param##_read,\t\t\t\t\t\\\n\t\t.write = param##_write,\t\t\t\t\t\\\n\t\t.open = simple_open,\t\t\t\t\t\\\n\t\t.llseek = default_llseek,\t\t\t\t\\\n\t};\n\nWL12XX_CONF_DEBUGFS(irq_pkt_threshold, rx, 0, 65535,\n\t\t    chip_op_handler, wl1271_acx_init_rx_interrupt)\nWL12XX_CONF_DEBUGFS(irq_blk_threshold, rx, 0, 65535,\n\t\t    chip_op_handler, wl1271_acx_init_rx_interrupt)\nWL12XX_CONF_DEBUGFS(irq_timeout, rx, 0, 100,\n\t\t    chip_op_handler, wl1271_acx_init_rx_interrupt)\n\nstatic ssize_t gpio_power_read(struct file *file, char __user *user_buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\tbool state = test_bit(WL1271_FLAG_GPIO_POWER, &wl->flags);\n\n\tint res;\n\tchar buf[10];\n\n\tres = scnprintf(buf, sizeof(buf), \"%d\\n\", state);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, res);\n}\n\nstatic ssize_t gpio_power_write(struct file *file,\n\t\t\t   const char __user *user_buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul_from_user(user_buf, count, 10, &value);\n\tif (ret < 0) {\n\t\twl1271_warning(\"illegal value in gpio_power\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&wl->mutex);\n\n\tif (value)\n\t\twl1271_power_on(wl);\n\telse\n\t\twl1271_power_off(wl);\n\n\tmutex_unlock(&wl->mutex);\n\treturn count;\n}\n\nstatic const struct file_operations gpio_power_ops = {\n\t.read = gpio_power_read,\n\t.write = gpio_power_write,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t start_recovery_write(struct file *file,\n\t\t\t\t    const char __user *user_buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\n\tmutex_lock(&wl->mutex);\n\twl12xx_queue_recovery_work(wl);\n\tmutex_unlock(&wl->mutex);\n\n\treturn count;\n}\n\nstatic const struct file_operations start_recovery_ops = {\n\t.write = start_recovery_write,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t dynamic_ps_timeout_read(struct file *file, char __user *user_buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\n\treturn wl1271_format_buffer(user_buf, count,\n\t\t\t\t    ppos, \"%d\\n\",\n\t\t\t\t    wl->conf.conn.dynamic_ps_timeout);\n}\n\nstatic ssize_t dynamic_ps_timeout_write(struct file *file,\n\t\t\t\t    const char __user *user_buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\tstruct wl12xx_vif *wlvif;\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul_from_user(user_buf, count, 10, &value);\n\tif (ret < 0) {\n\t\twl1271_warning(\"illegal value in dynamic_ps\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (value < 1 || value > 65535) {\n\t\twl1271_warning(\"dynamic_ps_timeout is not in valid range\");\n\t\treturn -ERANGE;\n\t}\n\n\tmutex_lock(&wl->mutex);\n\n\twl->conf.conn.dynamic_ps_timeout = value;\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON))\n\t\tgoto out;\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\n\twl12xx_for_each_wlvif_sta(wl, wlvif) {\n\t\tif (test_bit(WLVIF_FLAG_IN_PS, &wlvif->flags))\n\t\t\twl1271_ps_set_mode(wl, wlvif, STATION_AUTO_PS_MODE);\n\t}\n\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\n\nout:\n\tmutex_unlock(&wl->mutex);\n\treturn count;\n}\n\nstatic const struct file_operations dynamic_ps_timeout_ops = {\n\t.read = dynamic_ps_timeout_read,\n\t.write = dynamic_ps_timeout_write,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t forced_ps_read(struct file *file, char __user *user_buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\n\treturn wl1271_format_buffer(user_buf, count,\n\t\t\t\t    ppos, \"%d\\n\",\n\t\t\t\t    wl->conf.conn.forced_ps);\n}\n\nstatic ssize_t forced_ps_write(struct file *file,\n\t\t\t\t    const char __user *user_buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\tstruct wl12xx_vif *wlvif;\n\tunsigned long value;\n\tint ret, ps_mode;\n\n\tret = kstrtoul_from_user(user_buf, count, 10, &value);\n\tif (ret < 0) {\n\t\twl1271_warning(\"illegal value in forced_ps\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (value != 1 && value != 0) {\n\t\twl1271_warning(\"forced_ps should be either 0 or 1\");\n\t\treturn -ERANGE;\n\t}\n\n\tmutex_lock(&wl->mutex);\n\n\tif (wl->conf.conn.forced_ps == value)\n\t\tgoto out;\n\n\twl->conf.conn.forced_ps = value;\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON))\n\t\tgoto out;\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\n\tps_mode = value ? STATION_POWER_SAVE_MODE : STATION_AUTO_PS_MODE;\n\n\twl12xx_for_each_wlvif_sta(wl, wlvif) {\n\t\tif (test_bit(WLVIF_FLAG_IN_PS, &wlvif->flags))\n\t\t\twl1271_ps_set_mode(wl, wlvif, ps_mode);\n\t}\n\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\n\nout:\n\tmutex_unlock(&wl->mutex);\n\treturn count;\n}\n\nstatic const struct file_operations forced_ps_ops = {\n\t.read = forced_ps_read,\n\t.write = forced_ps_write,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t split_scan_timeout_read(struct file *file, char __user *user_buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\n\treturn wl1271_format_buffer(user_buf, count,\n\t\t\t\t    ppos, \"%d\\n\",\n\t\t\t\t    wl->conf.scan.split_scan_timeout / 1000);\n}\n\nstatic ssize_t split_scan_timeout_write(struct file *file,\n\t\t\t\t    const char __user *user_buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul_from_user(user_buf, count, 10, &value);\n\tif (ret < 0) {\n\t\twl1271_warning(\"illegal value in split_scan_timeout\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (value == 0)\n\t\twl1271_info(\"split scan will be disabled\");\n\n\tmutex_lock(&wl->mutex);\n\n\twl->conf.scan.split_scan_timeout = value * 1000;\n\n\tmutex_unlock(&wl->mutex);\n\treturn count;\n}\n\nstatic const struct file_operations split_scan_timeout_ops = {\n\t.read = split_scan_timeout_read,\n\t.write = split_scan_timeout_write,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t driver_state_read(struct file *file, char __user *user_buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\tint res = 0;\n\tssize_t ret;\n\tchar *buf;\n\tstruct wl12xx_vif *wlvif;\n\n#define DRIVER_STATE_BUF_LEN 1024\n\n\tbuf = kmalloc(DRIVER_STATE_BUF_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&wl->mutex);\n\n#define DRIVER_STATE_PRINT(x, fmt)   \\\n\t(res += scnprintf(buf + res, DRIVER_STATE_BUF_LEN - res,\\\n\t\t\t  #x \" = \" fmt \"\\n\", wl->x))\n\n#define DRIVER_STATE_PRINT_GENERIC(x, fmt, args...)   \\\n\t(res += scnprintf(buf + res, DRIVER_STATE_BUF_LEN - res,\\\n\t\t\t  #x \" = \" fmt \"\\n\", args))\n\n#define DRIVER_STATE_PRINT_LONG(x) DRIVER_STATE_PRINT(x, \"%ld\")\n#define DRIVER_STATE_PRINT_INT(x)  DRIVER_STATE_PRINT(x, \"%d\")\n#define DRIVER_STATE_PRINT_STR(x)  DRIVER_STATE_PRINT(x, \"%s\")\n#define DRIVER_STATE_PRINT_LHEX(x) DRIVER_STATE_PRINT(x, \"0x%lx\")\n#define DRIVER_STATE_PRINT_HEX(x)  DRIVER_STATE_PRINT(x, \"0x%x\")\n\n\twl12xx_for_each_wlvif_sta(wl, wlvif) {\n\t\tif (!test_bit(WLVIF_FLAG_STA_ASSOCIATED, &wlvif->flags))\n\t\t\tcontinue;\n\n\t\tDRIVER_STATE_PRINT_GENERIC(channel, \"%d (%s)\", wlvif->channel,\n\t\t\t\t\t   wlvif->p2p ? \"P2P-CL\" : \"STA\");\n\t}\n\n\twl12xx_for_each_wlvif_ap(wl, wlvif)\n\t\tDRIVER_STATE_PRINT_GENERIC(channel, \"%d (%s)\", wlvif->channel,\n\t\t\t\t\t   wlvif->p2p ? \"P2P-GO\" : \"AP\");\n\n\tDRIVER_STATE_PRINT_INT(tx_blocks_available);\n\tDRIVER_STATE_PRINT_INT(tx_allocated_blocks);\n\tDRIVER_STATE_PRINT_INT(tx_allocated_pkts[0]);\n\tDRIVER_STATE_PRINT_INT(tx_allocated_pkts[1]);\n\tDRIVER_STATE_PRINT_INT(tx_allocated_pkts[2]);\n\tDRIVER_STATE_PRINT_INT(tx_allocated_pkts[3]);\n\tDRIVER_STATE_PRINT_INT(tx_frames_cnt);\n\tDRIVER_STATE_PRINT_LHEX(tx_frames_map[0]);\n\tDRIVER_STATE_PRINT_INT(tx_queue_count[0]);\n\tDRIVER_STATE_PRINT_INT(tx_queue_count[1]);\n\tDRIVER_STATE_PRINT_INT(tx_queue_count[2]);\n\tDRIVER_STATE_PRINT_INT(tx_queue_count[3]);\n\tDRIVER_STATE_PRINT_INT(tx_packets_count);\n\tDRIVER_STATE_PRINT_INT(tx_results_count);\n\tDRIVER_STATE_PRINT_LHEX(flags);\n\tDRIVER_STATE_PRINT_INT(tx_blocks_freed);\n\tDRIVER_STATE_PRINT_INT(rx_counter);\n\tDRIVER_STATE_PRINT_INT(state);\n\tDRIVER_STATE_PRINT_INT(band);\n\tDRIVER_STATE_PRINT_INT(power_level);\n\tDRIVER_STATE_PRINT_INT(sg_enabled);\n\tDRIVER_STATE_PRINT_INT(enable_11a);\n\tDRIVER_STATE_PRINT_INT(noise);\n\tDRIVER_STATE_PRINT_LHEX(ap_fw_ps_map);\n\tDRIVER_STATE_PRINT_LHEX(ap_ps_map);\n\tDRIVER_STATE_PRINT_HEX(quirks);\n\tDRIVER_STATE_PRINT_HEX(irq);\n\t \n\tDRIVER_STATE_PRINT_HEX(hw_pg_ver);\n\tDRIVER_STATE_PRINT_HEX(irq_flags);\n\tDRIVER_STATE_PRINT_HEX(chip.id);\n\tDRIVER_STATE_PRINT_STR(chip.fw_ver_str);\n\tDRIVER_STATE_PRINT_STR(chip.phy_fw_ver_str);\n\tDRIVER_STATE_PRINT_INT(recovery_count);\n\n#undef DRIVER_STATE_PRINT_INT\n#undef DRIVER_STATE_PRINT_LONG\n#undef DRIVER_STATE_PRINT_HEX\n#undef DRIVER_STATE_PRINT_LHEX\n#undef DRIVER_STATE_PRINT_STR\n#undef DRIVER_STATE_PRINT\n#undef DRIVER_STATE_BUF_LEN\n\n\tmutex_unlock(&wl->mutex);\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, res);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic const struct file_operations driver_state_ops = {\n\t.read = driver_state_read,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t vifs_state_read(struct file *file, char __user *user_buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\tstruct wl12xx_vif *wlvif;\n\tint ret, res = 0;\n\tconst int buf_size = 4096;\n\tchar *buf;\n\tchar tmp_buf[64];\n\n\tbuf = kzalloc(buf_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&wl->mutex);\n\n#define VIF_STATE_PRINT(x, fmt)\t\t\t\t\\\n\t(res += scnprintf(buf + res, buf_size - res,\t\\\n\t\t\t  #x \" = \" fmt \"\\n\", wlvif->x))\n\n#define VIF_STATE_PRINT_LONG(x)  VIF_STATE_PRINT(x, \"%ld\")\n#define VIF_STATE_PRINT_INT(x)   VIF_STATE_PRINT(x, \"%d\")\n#define VIF_STATE_PRINT_STR(x)   VIF_STATE_PRINT(x, \"%s\")\n#define VIF_STATE_PRINT_LHEX(x)  VIF_STATE_PRINT(x, \"0x%lx\")\n#define VIF_STATE_PRINT_LLHEX(x) VIF_STATE_PRINT(x, \"0x%llx\")\n#define VIF_STATE_PRINT_HEX(x)   VIF_STATE_PRINT(x, \"0x%x\")\n\n#define VIF_STATE_PRINT_NSTR(x, len)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tmemset(tmp_buf, 0, sizeof(tmp_buf));\t\t\\\n\t\tmemcpy(tmp_buf, wlvif->x,\t\t\t\\\n\t\t       min_t(u8, len, sizeof(tmp_buf) - 1));\t\\\n\t\tres += scnprintf(buf + res, buf_size - res,\t\\\n\t\t\t\t #x \" = %s\\n\", tmp_buf);\t\\\n\t} while (0)\n\n\twl12xx_for_each_wlvif(wl, wlvif) {\n\t\tVIF_STATE_PRINT_INT(role_id);\n\t\tVIF_STATE_PRINT_INT(bss_type);\n\t\tVIF_STATE_PRINT_LHEX(flags);\n\t\tVIF_STATE_PRINT_INT(p2p);\n\t\tVIF_STATE_PRINT_INT(dev_role_id);\n\t\tVIF_STATE_PRINT_INT(dev_hlid);\n\n\t\tif (wlvif->bss_type == BSS_TYPE_STA_BSS ||\n\t\t    wlvif->bss_type == BSS_TYPE_IBSS) {\n\t\t\tVIF_STATE_PRINT_INT(sta.hlid);\n\t\t\tVIF_STATE_PRINT_INT(sta.basic_rate_idx);\n\t\t\tVIF_STATE_PRINT_INT(sta.ap_rate_idx);\n\t\t\tVIF_STATE_PRINT_INT(sta.p2p_rate_idx);\n\t\t\tVIF_STATE_PRINT_INT(sta.qos);\n\t\t} else {\n\t\t\tVIF_STATE_PRINT_INT(ap.global_hlid);\n\t\t\tVIF_STATE_PRINT_INT(ap.bcast_hlid);\n\t\t\tVIF_STATE_PRINT_LHEX(ap.sta_hlid_map[0]);\n\t\t\tVIF_STATE_PRINT_INT(ap.mgmt_rate_idx);\n\t\t\tVIF_STATE_PRINT_INT(ap.bcast_rate_idx);\n\t\t\tVIF_STATE_PRINT_INT(ap.ucast_rate_idx[0]);\n\t\t\tVIF_STATE_PRINT_INT(ap.ucast_rate_idx[1]);\n\t\t\tVIF_STATE_PRINT_INT(ap.ucast_rate_idx[2]);\n\t\t\tVIF_STATE_PRINT_INT(ap.ucast_rate_idx[3]);\n\t\t}\n\t\tVIF_STATE_PRINT_INT(last_tx_hlid);\n\t\tVIF_STATE_PRINT_INT(tx_queue_count[0]);\n\t\tVIF_STATE_PRINT_INT(tx_queue_count[1]);\n\t\tVIF_STATE_PRINT_INT(tx_queue_count[2]);\n\t\tVIF_STATE_PRINT_INT(tx_queue_count[3]);\n\t\tVIF_STATE_PRINT_LHEX(links_map[0]);\n\t\tVIF_STATE_PRINT_NSTR(ssid, wlvif->ssid_len);\n\t\tVIF_STATE_PRINT_INT(band);\n\t\tVIF_STATE_PRINT_INT(channel);\n\t\tVIF_STATE_PRINT_HEX(bitrate_masks[0]);\n\t\tVIF_STATE_PRINT_HEX(bitrate_masks[1]);\n\t\tVIF_STATE_PRINT_HEX(basic_rate_set);\n\t\tVIF_STATE_PRINT_HEX(basic_rate);\n\t\tVIF_STATE_PRINT_HEX(rate_set);\n\t\tVIF_STATE_PRINT_INT(beacon_int);\n\t\tVIF_STATE_PRINT_INT(default_key);\n\t\tVIF_STATE_PRINT_INT(aid);\n\t\tVIF_STATE_PRINT_INT(psm_entry_retry);\n\t\tVIF_STATE_PRINT_INT(power_level);\n\t\tVIF_STATE_PRINT_INT(rssi_thold);\n\t\tVIF_STATE_PRINT_INT(last_rssi_event);\n\t\tVIF_STATE_PRINT_INT(ba_support);\n\t\tVIF_STATE_PRINT_INT(ba_allowed);\n\t\tVIF_STATE_PRINT_LLHEX(total_freed_pkts);\n\t}\n\n#undef VIF_STATE_PRINT_INT\n#undef VIF_STATE_PRINT_LONG\n#undef VIF_STATE_PRINT_HEX\n#undef VIF_STATE_PRINT_LHEX\n#undef VIF_STATE_PRINT_LLHEX\n#undef VIF_STATE_PRINT_STR\n#undef VIF_STATE_PRINT_NSTR\n#undef VIF_STATE_PRINT\n\n\tmutex_unlock(&wl->mutex);\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, res);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic const struct file_operations vifs_state_ops = {\n\t.read = vifs_state_read,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t dtim_interval_read(struct file *file, char __user *user_buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\tu8 value;\n\n\tif (wl->conf.conn.wake_up_event == CONF_WAKE_UP_EVENT_DTIM ||\n\t    wl->conf.conn.wake_up_event == CONF_WAKE_UP_EVENT_N_DTIM)\n\t\tvalue = wl->conf.conn.listen_interval;\n\telse\n\t\tvalue = 0;\n\n\treturn wl1271_format_buffer(user_buf, count, ppos, \"%d\\n\", value);\n}\n\nstatic ssize_t dtim_interval_write(struct file *file,\n\t\t\t\t   const char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul_from_user(user_buf, count, 10, &value);\n\tif (ret < 0) {\n\t\twl1271_warning(\"illegal value for dtim_interval\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (value < 1 || value > 10) {\n\t\twl1271_warning(\"dtim value is not in valid range\");\n\t\treturn -ERANGE;\n\t}\n\n\tmutex_lock(&wl->mutex);\n\n\twl->conf.conn.listen_interval = value;\n\t \n\tif (value == 1)\n\t\twl->conf.conn.wake_up_event = CONF_WAKE_UP_EVENT_DTIM;\n\telse\n\t\twl->conf.conn.wake_up_event = CONF_WAKE_UP_EVENT_N_DTIM;\n\n\t \n\tmutex_unlock(&wl->mutex);\n\treturn count;\n}\n\nstatic const struct file_operations dtim_interval_ops = {\n\t.read = dtim_interval_read,\n\t.write = dtim_interval_write,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\n\n\nstatic ssize_t suspend_dtim_interval_read(struct file *file,\n\t\t\t\t\t  char __user *user_buf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\tu8 value;\n\n\tif (wl->conf.conn.suspend_wake_up_event == CONF_WAKE_UP_EVENT_DTIM ||\n\t    wl->conf.conn.suspend_wake_up_event == CONF_WAKE_UP_EVENT_N_DTIM)\n\t\tvalue = wl->conf.conn.suspend_listen_interval;\n\telse\n\t\tvalue = 0;\n\n\treturn wl1271_format_buffer(user_buf, count, ppos, \"%d\\n\", value);\n}\n\nstatic ssize_t suspend_dtim_interval_write(struct file *file,\n\t\t\t\t\t   const char __user *user_buf,\n\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul_from_user(user_buf, count, 10, &value);\n\tif (ret < 0) {\n\t\twl1271_warning(\"illegal value for suspend_dtim_interval\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (value < 1 || value > 10) {\n\t\twl1271_warning(\"suspend_dtim value is not in valid range\");\n\t\treturn -ERANGE;\n\t}\n\n\tmutex_lock(&wl->mutex);\n\n\twl->conf.conn.suspend_listen_interval = value;\n\t \n\tif (value == 1)\n\t\twl->conf.conn.suspend_wake_up_event = CONF_WAKE_UP_EVENT_DTIM;\n\telse\n\t\twl->conf.conn.suspend_wake_up_event = CONF_WAKE_UP_EVENT_N_DTIM;\n\n\tmutex_unlock(&wl->mutex);\n\treturn count;\n}\n\n\nstatic const struct file_operations suspend_dtim_interval_ops = {\n\t.read = suspend_dtim_interval_read,\n\t.write = suspend_dtim_interval_write,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t beacon_interval_read(struct file *file, char __user *user_buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\tu8 value;\n\n\tif (wl->conf.conn.wake_up_event == CONF_WAKE_UP_EVENT_BEACON ||\n\t    wl->conf.conn.wake_up_event == CONF_WAKE_UP_EVENT_N_BEACONS)\n\t\tvalue = wl->conf.conn.listen_interval;\n\telse\n\t\tvalue = 0;\n\n\treturn wl1271_format_buffer(user_buf, count, ppos, \"%d\\n\", value);\n}\n\nstatic ssize_t beacon_interval_write(struct file *file,\n\t\t\t\t     const char __user *user_buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul_from_user(user_buf, count, 10, &value);\n\tif (ret < 0) {\n\t\twl1271_warning(\"illegal value for beacon_interval\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (value < 1 || value > 255) {\n\t\twl1271_warning(\"beacon interval value is not in valid range\");\n\t\treturn -ERANGE;\n\t}\n\n\tmutex_lock(&wl->mutex);\n\n\twl->conf.conn.listen_interval = value;\n\t \n\tif (value == 1)\n\t\twl->conf.conn.wake_up_event = CONF_WAKE_UP_EVENT_BEACON;\n\telse\n\t\twl->conf.conn.wake_up_event = CONF_WAKE_UP_EVENT_N_BEACONS;\n\n\t \n\tmutex_unlock(&wl->mutex);\n\treturn count;\n}\n\nstatic const struct file_operations beacon_interval_ops = {\n\t.read = beacon_interval_read,\n\t.write = beacon_interval_write,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t rx_streaming_interval_write(struct file *file,\n\t\t\t   const char __user *user_buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\tstruct wl12xx_vif *wlvif;\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul_from_user(user_buf, count, 10, &value);\n\tif (ret < 0) {\n\t\twl1271_warning(\"illegal value in rx_streaming_interval!\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (value && (value < 10 || value > 100)) {\n\t\twl1271_warning(\"value is not in range!\");\n\t\treturn -ERANGE;\n\t}\n\n\tmutex_lock(&wl->mutex);\n\n\twl->conf.rx_streaming.interval = value;\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twl12xx_for_each_wlvif_sta(wl, wlvif) {\n\t\twl1271_recalc_rx_streaming(wl, wlvif);\n\t}\n\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\nout:\n\tmutex_unlock(&wl->mutex);\n\treturn count;\n}\n\nstatic ssize_t rx_streaming_interval_read(struct file *file,\n\t\t\t    char __user *userbuf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\treturn wl1271_format_buffer(userbuf, count, ppos,\n\t\t\t\t    \"%d\\n\", wl->conf.rx_streaming.interval);\n}\n\nstatic const struct file_operations rx_streaming_interval_ops = {\n\t.read = rx_streaming_interval_read,\n\t.write = rx_streaming_interval_write,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t rx_streaming_always_write(struct file *file,\n\t\t\t   const char __user *user_buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\tstruct wl12xx_vif *wlvif;\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul_from_user(user_buf, count, 10, &value);\n\tif (ret < 0) {\n\t\twl1271_warning(\"illegal value in rx_streaming_write!\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!(value == 0 || value == 1)) {\n\t\twl1271_warning(\"value is not in valid!\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&wl->mutex);\n\n\twl->conf.rx_streaming.always = value;\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twl12xx_for_each_wlvif_sta(wl, wlvif) {\n\t\twl1271_recalc_rx_streaming(wl, wlvif);\n\t}\n\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\nout:\n\tmutex_unlock(&wl->mutex);\n\treturn count;\n}\n\nstatic ssize_t rx_streaming_always_read(struct file *file,\n\t\t\t    char __user *userbuf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\treturn wl1271_format_buffer(userbuf, count, ppos,\n\t\t\t\t    \"%d\\n\", wl->conf.rx_streaming.always);\n}\n\nstatic const struct file_operations rx_streaming_always_ops = {\n\t.read = rx_streaming_always_read,\n\t.write = rx_streaming_always_write,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t beacon_filtering_write(struct file *file,\n\t\t\t\t      const char __user *user_buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\tstruct wl12xx_vif *wlvif;\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul_from_user(user_buf, count, 0, &value);\n\tif (ret < 0) {\n\t\twl1271_warning(\"illegal value for beacon_filtering!\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&wl->mutex);\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twl12xx_for_each_wlvif(wl, wlvif) {\n\t\tret = wl1271_acx_beacon_filter_opt(wl, wlvif, !!value);\n\t}\n\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\nout:\n\tmutex_unlock(&wl->mutex);\n\treturn count;\n}\n\nstatic const struct file_operations beacon_filtering_ops = {\n\t.write = beacon_filtering_write,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t fw_stats_raw_read(struct file *file,\n\t\t\t\t char __user *userbuf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\n\twl1271_debugfs_update_stats(wl);\n\n\treturn simple_read_from_buffer(userbuf, count, ppos,\n\t\t\t\t       wl->stats.fw_stats,\n\t\t\t\t       wl->stats.fw_stats_len);\n}\n\nstatic const struct file_operations fw_stats_raw_ops = {\n\t.read = fw_stats_raw_read,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t sleep_auth_read(struct file *file, char __user *user_buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\n\treturn wl1271_format_buffer(user_buf, count,\n\t\t\t\t    ppos, \"%d\\n\",\n\t\t\t\t    wl->sleep_auth);\n}\n\nstatic ssize_t sleep_auth_write(struct file *file,\n\t\t\t\tconst char __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul_from_user(user_buf, count, 0, &value);\n\tif (ret < 0) {\n\t\twl1271_warning(\"illegal value in sleep_auth\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (value > WL1271_PSM_MAX) {\n\t\twl1271_warning(\"sleep_auth must be between 0 and %d\",\n\t\t\t       WL1271_PSM_MAX);\n\t\treturn -ERANGE;\n\t}\n\n\tmutex_lock(&wl->mutex);\n\n\twl->conf.conn.sta_sleep_auth = value;\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON)) {\n\t\t \n\t\twl->sleep_auth = value;\n\t\tgoto out;\n\t}\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl1271_acx_sleep_auth(wl, value);\n\tif (ret < 0)\n\t\tgoto out_sleep;\n\nout_sleep:\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\nout:\n\tmutex_unlock(&wl->mutex);\n\treturn count;\n}\n\nstatic const struct file_operations sleep_auth_ops = {\n\t.read = sleep_auth_read,\n\t.write = sleep_auth_write,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t dev_mem_read(struct file *file,\n\t     char __user *user_buf, size_t count,\n\t     loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\tstruct wlcore_partition_set part, old_part;\n\tsize_t bytes = count;\n\tint ret;\n\tchar *buf;\n\n\t \n\tif (bytes % 4)\n\t\treturn -EINVAL;\n\n\tif (*ppos % 4)\n\t\treturn -EINVAL;\n\n\t \n\tbytes = min(bytes, WLCORE_MAX_BLOCK_SIZE);\n\n\tif (bytes == 0)\n\t\treturn -EINVAL;\n\n\tmemset(&part, 0, sizeof(part));\n\tpart.mem.start = *ppos;\n\tpart.mem.size = bytes;\n\n\tbuf = kmalloc(bytes, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state == WLCORE_STATE_OFF)) {\n\t\tret = -EFAULT;\n\t\tgoto skip_read;\n\t}\n\n\t \n\tpm_runtime_get_sync(wl->dev);\n\n\t \n\tmemcpy(&old_part, &wl->curr_part, sizeof(old_part));\n\tret = wlcore_set_partition(wl, &part);\n\tif (ret < 0)\n\t\tgoto part_err;\n\n\tret = wlcore_raw_read(wl, 0, buf, bytes, false);\n\tif (ret < 0)\n\t\tgoto read_err;\n\nread_err:\n\t \n\tret = wlcore_set_partition(wl, &old_part);\n\tif (ret < 0)\n\t\tgoto part_err;\n\npart_err:\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\n\nskip_read:\n\tmutex_unlock(&wl->mutex);\n\n\tif (ret == 0) {\n\t\tret = copy_to_user(user_buf, buf, bytes);\n\t\tif (ret < bytes) {\n\t\t\tbytes -= ret;\n\t\t\t*ppos += bytes;\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tret = -EFAULT;\n\t\t}\n\t}\n\n\tkfree(buf);\n\n\treturn ((ret == 0) ? bytes : ret);\n}\n\nstatic ssize_t dev_mem_write(struct file *file, const char __user *user_buf,\n\t\tsize_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\tstruct wlcore_partition_set part, old_part;\n\tsize_t bytes = count;\n\tint ret;\n\tchar *buf;\n\n\t \n\tif (bytes % 4)\n\t\treturn -EINVAL;\n\n\tif (*ppos % 4)\n\t\treturn -EINVAL;\n\n\t \n\tbytes = min(bytes, WLCORE_MAX_BLOCK_SIZE);\n\n\tif (bytes == 0)\n\t\treturn -EINVAL;\n\n\tmemset(&part, 0, sizeof(part));\n\tpart.mem.start = *ppos;\n\tpart.mem.size = bytes;\n\n\tbuf = memdup_user(user_buf, bytes);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state == WLCORE_STATE_OFF)) {\n\t\tret = -EFAULT;\n\t\tgoto skip_write;\n\t}\n\n\t \n\tpm_runtime_get_sync(wl->dev);\n\n\t \n\tmemcpy(&old_part, &wl->curr_part, sizeof(old_part));\n\tret = wlcore_set_partition(wl, &part);\n\tif (ret < 0)\n\t\tgoto part_err;\n\n\tret = wlcore_raw_write(wl, 0, buf, bytes, false);\n\tif (ret < 0)\n\t\tgoto write_err;\n\nwrite_err:\n\t \n\tret = wlcore_set_partition(wl, &old_part);\n\tif (ret < 0)\n\t\tgoto part_err;\n\npart_err:\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\n\nskip_write:\n\tmutex_unlock(&wl->mutex);\n\n\tif (ret == 0)\n\t\t*ppos += bytes;\n\n\tkfree(buf);\n\n\treturn ((ret == 0) ? bytes : ret);\n}\n\nstatic loff_t dev_mem_seek(struct file *file, loff_t offset, int orig)\n{\n\t \n\tif (offset % 4)\n\t\treturn -EINVAL;\n\n\treturn no_seek_end_llseek(file, offset, orig);\n}\n\nstatic const struct file_operations dev_mem_ops = {\n\t.open = simple_open,\n\t.read = dev_mem_read,\n\t.write = dev_mem_write,\n\t.llseek = dev_mem_seek,\n};\n\nstatic ssize_t fw_logger_read(struct file *file, char __user *user_buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\n\treturn wl1271_format_buffer(user_buf, count,\n\t\t\t\t\tppos, \"%d\\n\",\n\t\t\t\t\twl->conf.fwlog.output);\n}\n\nstatic ssize_t fw_logger_write(struct file *file,\n\t\t\t       const char __user *user_buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct wl1271 *wl = file->private_data;\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul_from_user(user_buf, count, 0, &value);\n\tif (ret < 0) {\n\t\twl1271_warning(\"illegal value in fw_logger\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((value > 2) || (value == 0)) {\n\t\twl1271_warning(\"fw_logger value must be 1-UART 2-SDIO\");\n\t\treturn -ERANGE;\n\t}\n\n\tif (wl->conf.fwlog.output == 0) {\n\t\twl1271_warning(\"invalid operation - fw logger disabled by default, please change mode via wlconf\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&wl->mutex);\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0) {\n\t\tcount = ret;\n\t\tgoto out;\n\t}\n\n\twl->conf.fwlog.output = value;\n\n\tret = wl12xx_cmd_config_fwlog(wl);\n\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\n\nout:\n\tmutex_unlock(&wl->mutex);\n\treturn count;\n}\n\nstatic const struct file_operations fw_logger_ops = {\n\t.open = simple_open,\n\t.read = fw_logger_read,\n\t.write = fw_logger_write,\n\t.llseek = default_llseek,\n};\n\nstatic void wl1271_debugfs_add_files(struct wl1271 *wl,\n\t\t\t\t     struct dentry *rootdir)\n{\n\tstruct dentry *streaming;\n\n\tDEBUGFS_ADD(tx_queue_len, rootdir);\n\tDEBUGFS_ADD(retry_count, rootdir);\n\tDEBUGFS_ADD(excessive_retries, rootdir);\n\n\tDEBUGFS_ADD(gpio_power, rootdir);\n\tDEBUGFS_ADD(start_recovery, rootdir);\n\tDEBUGFS_ADD(driver_state, rootdir);\n\tDEBUGFS_ADD(vifs_state, rootdir);\n\tDEBUGFS_ADD(dtim_interval, rootdir);\n\tDEBUGFS_ADD(suspend_dtim_interval, rootdir);\n\tDEBUGFS_ADD(beacon_interval, rootdir);\n\tDEBUGFS_ADD(beacon_filtering, rootdir);\n\tDEBUGFS_ADD(dynamic_ps_timeout, rootdir);\n\tDEBUGFS_ADD(forced_ps, rootdir);\n\tDEBUGFS_ADD(split_scan_timeout, rootdir);\n\tDEBUGFS_ADD(irq_pkt_threshold, rootdir);\n\tDEBUGFS_ADD(irq_blk_threshold, rootdir);\n\tDEBUGFS_ADD(irq_timeout, rootdir);\n\tDEBUGFS_ADD(fw_stats_raw, rootdir);\n\tDEBUGFS_ADD(sleep_auth, rootdir);\n\tDEBUGFS_ADD(fw_logger, rootdir);\n\n\tstreaming = debugfs_create_dir(\"rx_streaming\", rootdir);\n\n\tDEBUGFS_ADD_PREFIX(rx_streaming, interval, streaming);\n\tDEBUGFS_ADD_PREFIX(rx_streaming, always, streaming);\n\n\tDEBUGFS_ADD_PREFIX(dev, mem, rootdir);\n}\n\nvoid wl1271_debugfs_reset(struct wl1271 *wl)\n{\n\tif (!wl->stats.fw_stats)\n\t\treturn;\n\n\tmemset(wl->stats.fw_stats, 0, wl->stats.fw_stats_len);\n\twl->stats.retry_count = 0;\n\twl->stats.excessive_retries = 0;\n}\n\nint wl1271_debugfs_init(struct wl1271 *wl)\n{\n\tint ret;\n\tstruct dentry *rootdir;\n\n\trootdir = debugfs_create_dir(KBUILD_MODNAME,\n\t\t\t\t     wl->hw->wiphy->debugfsdir);\n\n\twl->stats.fw_stats = kzalloc(wl->stats.fw_stats_len, GFP_KERNEL);\n\tif (!wl->stats.fw_stats) {\n\t\tret = -ENOMEM;\n\t\tgoto out_remove;\n\t}\n\n\twl->stats.fw_stats_update = jiffies;\n\n\twl1271_debugfs_add_files(wl, rootdir);\n\n\tret = wlcore_debugfs_init(wl, rootdir);\n\tif (ret < 0)\n\t\tgoto out_exit;\n\n\tgoto out;\n\nout_exit:\n\twl1271_debugfs_exit(wl);\n\nout_remove:\n\tdebugfs_remove_recursive(rootdir);\n\nout:\n\treturn ret;\n}\n\nvoid wl1271_debugfs_exit(struct wl1271 *wl)\n{\n\tkfree(wl->stats.fw_stats);\n\twl->stats.fw_stats = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}