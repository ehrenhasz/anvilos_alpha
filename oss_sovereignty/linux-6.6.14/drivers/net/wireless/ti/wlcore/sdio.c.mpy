{
  "module_name": "sdio.c",
  "hash_id": "0e7890e7826298f1a5859bd23d97149afed5a59313acda4ece20463840d03755",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wlcore/sdio.c",
  "human_readable_source": "\n \n\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/platform_device.h>\n#include <linux/mmc/sdio.h>\n#include <linux/mmc/sdio_func.h>\n#include <linux/mmc/sdio_ids.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/host.h>\n#include <linux/gpio.h>\n#include <linux/pm_runtime.h>\n#include <linux/printk.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n\n#include \"wlcore.h\"\n#include \"wl12xx_80211.h\"\n#include \"io.h\"\n\nstatic bool dump;\n\nstruct wl12xx_sdio_glue {\n\tstruct device *dev;\n\tstruct platform_device *core;\n};\n\nstatic const struct sdio_device_id wl1271_devices[] = {\n\t{ SDIO_DEVICE(SDIO_VENDOR_ID_TI, SDIO_DEVICE_ID_TI_WL1271) },\n\t{}\n};\nMODULE_DEVICE_TABLE(sdio, wl1271_devices);\n\nstatic void wl1271_sdio_set_block_size(struct device *child,\n\t\t\t\t       unsigned int blksz)\n{\n\tstruct wl12xx_sdio_glue *glue = dev_get_drvdata(child->parent);\n\tstruct sdio_func *func = dev_to_sdio_func(glue->dev);\n\n\tsdio_claim_host(func);\n\tsdio_set_block_size(func, blksz);\n\tsdio_release_host(func);\n}\n\nstatic int __must_check wl12xx_sdio_raw_read(struct device *child, int addr,\n\t\t\t\t\t     void *buf, size_t len, bool fixed)\n{\n\tint ret;\n\tstruct wl12xx_sdio_glue *glue = dev_get_drvdata(child->parent);\n\tstruct sdio_func *func = dev_to_sdio_func(glue->dev);\n\n\tsdio_claim_host(func);\n\n\tif (unlikely(addr == HW_ACCESS_ELP_CTRL_REG)) {\n\t\t((u8 *)buf)[0] = sdio_f0_readb(func, addr, &ret);\n\t\tdev_dbg(child->parent, \"sdio read 52 addr 0x%x, byte 0x%02x\\n\",\n\t\t\taddr, ((u8 *)buf)[0]);\n\t} else {\n\t\tif (fixed)\n\t\t\tret = sdio_readsb(func, buf, addr, len);\n\t\telse\n\t\t\tret = sdio_memcpy_fromio(func, buf, addr, len);\n\n\t\tdev_dbg(child->parent, \"sdio read 53 addr 0x%x, %zu bytes\\n\",\n\t\t\taddr, len);\n\t}\n\n\tsdio_release_host(func);\n\n\tif (WARN_ON(ret))\n\t\tdev_err(child->parent, \"sdio read failed (%d)\\n\", ret);\n\n\tif (unlikely(dump)) {\n\t\tprintk(KERN_DEBUG \"wlcore_sdio: READ from 0x%04x\\n\", addr);\n\t\tprint_hex_dump(KERN_DEBUG, \"wlcore_sdio: READ \",\n\t\t\t       DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t       buf, len, false);\n\t}\n\n\treturn ret;\n}\n\nstatic int __must_check wl12xx_sdio_raw_write(struct device *child, int addr,\n\t\t\t\t\t      void *buf, size_t len, bool fixed)\n{\n\tint ret;\n\tstruct wl12xx_sdio_glue *glue = dev_get_drvdata(child->parent);\n\tstruct sdio_func *func = dev_to_sdio_func(glue->dev);\n\n\tsdio_claim_host(func);\n\n\tif (unlikely(dump)) {\n\t\tprintk(KERN_DEBUG \"wlcore_sdio: WRITE to 0x%04x\\n\", addr);\n\t\tprint_hex_dump(KERN_DEBUG, \"wlcore_sdio: WRITE \",\n\t\t\t\tDUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t\tbuf, len, false);\n\t}\n\n\tif (unlikely(addr == HW_ACCESS_ELP_CTRL_REG)) {\n\t\tsdio_f0_writeb(func, ((u8 *)buf)[0], addr, &ret);\n\t\tdev_dbg(child->parent, \"sdio write 52 addr 0x%x, byte 0x%02x\\n\",\n\t\t\taddr, ((u8 *)buf)[0]);\n\t} else {\n\t\tdev_dbg(child->parent, \"sdio write 53 addr 0x%x, %zu bytes\\n\",\n\t\t\taddr, len);\n\n\t\tif (fixed)\n\t\t\tret = sdio_writesb(func, addr, buf, len);\n\t\telse\n\t\t\tret = sdio_memcpy_toio(func, addr, buf, len);\n\t}\n\n\tsdio_release_host(func);\n\n\tif (WARN_ON(ret))\n\t\tdev_err(child->parent, \"sdio write failed (%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int wl12xx_sdio_power_on(struct wl12xx_sdio_glue *glue)\n{\n\tint ret;\n\tstruct sdio_func *func = dev_to_sdio_func(glue->dev);\n\tstruct mmc_card *card = func->card;\n\n\tret = pm_runtime_resume_and_get(&card->dev);\n\tif (ret < 0) {\n\t\tdev_err(glue->dev, \"%s: failed to get_sync(%d)\\n\",\n\t\t\t__func__, ret);\n\n\t\treturn ret;\n\t}\n\n\tsdio_claim_host(func);\n\t \n\tmmc_hw_reset(card);\n\n\tsdio_enable_func(func);\n\tsdio_release_host(func);\n\n\treturn 0;\n}\n\nstatic int wl12xx_sdio_power_off(struct wl12xx_sdio_glue *glue)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(glue->dev);\n\tstruct mmc_card *card = func->card;\n\n\tsdio_claim_host(func);\n\tsdio_disable_func(func);\n\tsdio_release_host(func);\n\n\t \n\tpm_runtime_put(&card->dev);\n\treturn 0;\n}\n\nstatic int wl12xx_sdio_set_power(struct device *child, bool enable)\n{\n\tstruct wl12xx_sdio_glue *glue = dev_get_drvdata(child->parent);\n\n\tif (enable)\n\t\treturn wl12xx_sdio_power_on(glue);\n\telse\n\t\treturn wl12xx_sdio_power_off(glue);\n}\n\nstatic struct wl1271_if_operations sdio_ops = {\n\t.read\t\t= wl12xx_sdio_raw_read,\n\t.write\t\t= wl12xx_sdio_raw_write,\n\t.power\t\t= wl12xx_sdio_set_power,\n\t.set_block_size = wl1271_sdio_set_block_size,\n};\n\n#ifdef CONFIG_OF\n\nstatic const struct wilink_family_data wl127x_data = {\n\t.name = \"wl127x\",\n\t.nvs_name = \"ti-connectivity/wl127x-nvs.bin\",\n};\n\nstatic const struct wilink_family_data wl128x_data = {\n\t.name = \"wl128x\",\n\t.nvs_name = \"ti-connectivity/wl128x-nvs.bin\",\n};\n\nstatic const struct wilink_family_data wl18xx_data = {\n\t.name = \"wl18xx\",\n\t.cfg_name = \"ti-connectivity/wl18xx-conf.bin\",\n\t.nvs_name = \"ti-connectivity/wl1271-nvs.bin\",\n};\n\nstatic const struct of_device_id wlcore_sdio_of_match_table[] = {\n\t{ .compatible = \"ti,wl1271\", .data = &wl127x_data },\n\t{ .compatible = \"ti,wl1273\", .data = &wl127x_data },\n\t{ .compatible = \"ti,wl1281\", .data = &wl128x_data },\n\t{ .compatible = \"ti,wl1283\", .data = &wl128x_data },\n\t{ .compatible = \"ti,wl1285\", .data = &wl128x_data },\n\t{ .compatible = \"ti,wl1801\", .data = &wl18xx_data },\n\t{ .compatible = \"ti,wl1805\", .data = &wl18xx_data },\n\t{ .compatible = \"ti,wl1807\", .data = &wl18xx_data },\n\t{ .compatible = \"ti,wl1831\", .data = &wl18xx_data },\n\t{ .compatible = \"ti,wl1835\", .data = &wl18xx_data },\n\t{ .compatible = \"ti,wl1837\", .data = &wl18xx_data },\n\t{ }\n};\n\nstatic int wlcore_probe_of(struct device *dev, int *irq, int *wakeirq,\n\t\t\t   struct wlcore_platdev_data *pdev_data)\n{\n\tstruct device_node *np = dev->of_node;\n\tconst struct of_device_id *of_id;\n\n\tof_id = of_match_node(wlcore_sdio_of_match_table, np);\n\tif (!of_id)\n\t\treturn -ENODEV;\n\n\tpdev_data->family = of_id->data;\n\n\t*irq = irq_of_parse_and_map(np, 0);\n\tif (!*irq) {\n\t\tdev_err(dev, \"No irq in platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*wakeirq = irq_of_parse_and_map(np, 1);\n\n\t \n\tof_property_read_u32(np, \"ref-clock-frequency\",\n\t\t\t     &pdev_data->ref_clock_freq);\n\tof_property_read_u32(np, \"tcxo-clock-frequency\",\n\t\t\t     &pdev_data->tcxo_clock_freq);\n\n\treturn 0;\n}\n#else\nstatic int wlcore_probe_of(struct device *dev, int *irq, int *wakeirq,\n\t\t\t   struct wlcore_platdev_data *pdev_data)\n{\n\treturn -ENODATA;\n}\n#endif\n\nstatic int wl1271_probe(struct sdio_func *func,\n\t\t\t\t  const struct sdio_device_id *id)\n{\n\tstruct wlcore_platdev_data *pdev_data;\n\tstruct wl12xx_sdio_glue *glue;\n\tstruct resource res[2];\n\tmmc_pm_flag_t mmcflags;\n\tint ret = -ENOMEM;\n\tint irq, wakeirq, num_irqs;\n\tconst char *chip_family;\n\n\t \n\tif (func->num != 0x02)\n\t\treturn -ENODEV;\n\n\tpdev_data = devm_kzalloc(&func->dev, sizeof(*pdev_data), GFP_KERNEL);\n\tif (!pdev_data)\n\t\treturn -ENOMEM;\n\n\tpdev_data->if_ops = &sdio_ops;\n\n\tglue = devm_kzalloc(&func->dev, sizeof(*glue), GFP_KERNEL);\n\tif (!glue)\n\t\treturn -ENOMEM;\n\n\tglue->dev = &func->dev;\n\n\t \n\tfunc->card->quirks |= MMC_QUIRK_LENIENT_FN0;\n\n\t \n\tfunc->card->quirks |= MMC_QUIRK_BLKSZ_FOR_BYTE_MODE;\n\n\tret = wlcore_probe_of(&func->dev, &irq, &wakeirq, pdev_data);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tmmcflags = sdio_get_host_pm_caps(func);\n\tdev_dbg(glue->dev, \"sdio PM caps = 0x%x\\n\", mmcflags);\n\n\tif (mmcflags & MMC_PM_KEEP_POWER)\n\t\tpdev_data->pwr_in_suspend = true;\n\n\tsdio_set_drvdata(func, glue);\n\n\t \n\tpm_runtime_put_noidle(&func->dev);\n\n\t \n\tif (func->card->cccr.sdio_vsn == SDIO_SDIO_REV_3_00)\n\t\tchip_family = \"wl18xx\";\n\telse\n\t\tchip_family = \"wl12xx\";\n\n\tglue->core = platform_device_alloc(chip_family, PLATFORM_DEVID_AUTO);\n\tif (!glue->core) {\n\t\tdev_err(glue->dev, \"can't allocate platform_device\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tglue->core->dev.parent = &func->dev;\n\n\tmemset(res, 0x00, sizeof(res));\n\n\tres[0].start = irq;\n\tres[0].flags = IORESOURCE_IRQ |\n\t\t       irqd_get_trigger_type(irq_get_irq_data(irq));\n\tres[0].name = \"irq\";\n\n\n\tif (wakeirq > 0) {\n\t\tres[1].start = wakeirq;\n\t\tres[1].flags = IORESOURCE_IRQ |\n\t\t\t       irqd_get_trigger_type(irq_get_irq_data(wakeirq));\n\t\tres[1].name = \"wakeirq\";\n\t\tnum_irqs = 2;\n\t} else {\n\t\tnum_irqs = 1;\n\t}\n\tret = platform_device_add_resources(glue->core, res, num_irqs);\n\tif (ret) {\n\t\tdev_err(glue->dev, \"can't add resources\\n\");\n\t\tgoto out_dev_put;\n\t}\n\n\tret = platform_device_add_data(glue->core, pdev_data,\n\t\t\t\t       sizeof(*pdev_data));\n\tif (ret) {\n\t\tdev_err(glue->dev, \"can't add platform data\\n\");\n\t\tgoto out_dev_put;\n\t}\n\n\tret = platform_device_add(glue->core);\n\tif (ret) {\n\t\tdev_err(glue->dev, \"can't add platform device\\n\");\n\t\tgoto out_dev_put;\n\t}\n\treturn 0;\n\nout_dev_put:\n\tplatform_device_put(glue->core);\n\nout:\n\treturn ret;\n}\n\nstatic void wl1271_remove(struct sdio_func *func)\n{\n\tstruct wl12xx_sdio_glue *glue = sdio_get_drvdata(func);\n\n\t \n\tpm_runtime_get_noresume(&func->dev);\n\n\tplatform_device_unregister(glue->core);\n}\n\n#ifdef CONFIG_PM\nstatic int wl1271_suspend(struct device *dev)\n{\n\t \n\tstruct sdio_func *func = dev_to_sdio_func(dev);\n\tstruct wl12xx_sdio_glue *glue = sdio_get_drvdata(func);\n\tstruct wl1271 *wl = platform_get_drvdata(glue->core);\n\tmmc_pm_flag_t sdio_flags;\n\tint ret = 0;\n\n\tif (!wl) {\n\t\tdev_err(dev, \"no wilink module was probed\\n\");\n\t\tgoto out;\n\t}\n\n\tdev_dbg(dev, \"wl1271 suspend. wow_enabled: %d\\n\",\n\t\twl->wow_enabled);\n\n\t \n\tif (wl->wow_enabled) {\n\t\tsdio_flags = sdio_get_host_pm_caps(func);\n\n\t\tif (!(sdio_flags & MMC_PM_KEEP_POWER)) {\n\t\t\tdev_err(dev, \"can't keep power while host \"\n\t\t\t\t     \"is suspended\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tret = sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"error while trying to keep power\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn ret;\n}\n\nstatic int wl1271_resume(struct device *dev)\n{\n\tdev_dbg(dev, \"wl1271 resume\\n\");\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops wl1271_sdio_pm_ops = {\n\t.suspend\t= wl1271_suspend,\n\t.resume\t\t= wl1271_resume,\n};\n#endif\n\nstatic struct sdio_driver wl1271_sdio_driver = {\n\t.name\t\t= \"wl1271_sdio\",\n\t.id_table\t= wl1271_devices,\n\t.probe\t\t= wl1271_probe,\n\t.remove\t\t= wl1271_remove,\n#ifdef CONFIG_PM\n\t.drv = {\n\t\t.pm = &wl1271_sdio_pm_ops,\n\t},\n#endif\n};\n\nmodule_sdio_driver(wl1271_sdio_driver);\n\nmodule_param(dump, bool, 0600);\nMODULE_PARM_DESC(dump, \"Enable sdio read/write dumps.\");\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Luciano Coelho <coelho@ti.com>\");\nMODULE_AUTHOR(\"Juuso Oikarinen <juuso.oikarinen@nokia.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}