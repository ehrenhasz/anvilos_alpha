{
  "module_name": "io.c",
  "hash_id": "1aee4ff5c8cf744f1d972b425c61701513853605edf2a83a2fc9959f78594f5b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wlcore/io.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n#include <linux/interrupt.h>\n\n#include \"wlcore.h\"\n#include \"debug.h\"\n#include \"wl12xx_80211.h\"\n#include \"io.h\"\n#include \"tx.h\"\n\nbool wl1271_set_block_size(struct wl1271 *wl)\n{\n\tif (wl->if_ops->set_block_size) {\n\t\twl->if_ops->set_block_size(wl->dev, WL12XX_BUS_BLOCK_SIZE);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid wlcore_disable_interrupts(struct wl1271 *wl)\n{\n\tdisable_irq(wl->irq);\n}\nEXPORT_SYMBOL_GPL(wlcore_disable_interrupts);\n\nvoid wlcore_disable_interrupts_nosync(struct wl1271 *wl)\n{\n\tdisable_irq_nosync(wl->irq);\n}\nEXPORT_SYMBOL_GPL(wlcore_disable_interrupts_nosync);\n\nvoid wlcore_enable_interrupts(struct wl1271 *wl)\n{\n\tenable_irq(wl->irq);\n}\nEXPORT_SYMBOL_GPL(wlcore_enable_interrupts);\n\nvoid wlcore_synchronize_interrupts(struct wl1271 *wl)\n{\n\tsynchronize_irq(wl->irq);\n}\nEXPORT_SYMBOL_GPL(wlcore_synchronize_interrupts);\n\nint wlcore_translate_addr(struct wl1271 *wl, int addr)\n{\n\tstruct wlcore_partition_set *part = &wl->curr_part;\n\n\t \n\tif ((addr >= part->mem.start) &&\n\t    (addr < part->mem.start + part->mem.size))\n\t\treturn addr - part->mem.start;\n\telse if ((addr >= part->reg.start) &&\n\t\t (addr < part->reg.start + part->reg.size))\n\t\treturn addr - part->reg.start + part->mem.size;\n\telse if ((addr >= part->mem2.start) &&\n\t\t (addr < part->mem2.start + part->mem2.size))\n\t\treturn addr - part->mem2.start + part->mem.size +\n\t\t\tpart->reg.size;\n\telse if ((addr >= part->mem3.start) &&\n\t\t (addr < part->mem3.start + part->mem3.size))\n\t\treturn addr - part->mem3.start + part->mem.size +\n\t\t\tpart->reg.size + part->mem2.size;\n\n\tWARN(1, \"HW address 0x%x out of range\", addr);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wlcore_translate_addr);\n\n \nint wlcore_set_partition(struct wl1271 *wl,\n\t\t\t const struct wlcore_partition_set *p)\n{\n\tint ret;\n\n\t \n\tmemcpy(&wl->curr_part, p, sizeof(*p));\n\n\twl1271_debug(DEBUG_IO, \"mem_start %08X mem_size %08X\",\n\t\t     p->mem.start, p->mem.size);\n\twl1271_debug(DEBUG_IO, \"reg_start %08X reg_size %08X\",\n\t\t     p->reg.start, p->reg.size);\n\twl1271_debug(DEBUG_IO, \"mem2_start %08X mem2_size %08X\",\n\t\t     p->mem2.start, p->mem2.size);\n\twl1271_debug(DEBUG_IO, \"mem3_start %08X mem3_size %08X\",\n\t\t     p->mem3.start, p->mem3.size);\n\n\tret = wlcore_raw_write32(wl, HW_PART0_START_ADDR, p->mem.start);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wlcore_raw_write32(wl, HW_PART0_SIZE_ADDR, p->mem.size);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wlcore_raw_write32(wl, HW_PART1_START_ADDR, p->reg.start);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wlcore_raw_write32(wl, HW_PART1_SIZE_ADDR, p->reg.size);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wlcore_raw_write32(wl, HW_PART2_START_ADDR, p->mem2.start);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wlcore_raw_write32(wl, HW_PART2_SIZE_ADDR, p->mem2.size);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = wlcore_raw_write32(wl, HW_PART3_START_ADDR, p->mem3.start);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wlcore_raw_write32(wl, HW_PART3_SIZE_ADDR, p->mem3.size);\n\tif (ret < 0)\n\t\tgoto out;\n\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wlcore_set_partition);\n\nvoid wl1271_io_reset(struct wl1271 *wl)\n{\n\tif (wl->if_ops->reset)\n\t\twl->if_ops->reset(wl->dev);\n}\n\nvoid wl1271_io_init(struct wl1271 *wl)\n{\n\tif (wl->if_ops->init)\n\t\twl->if_ops->init(wl->dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}