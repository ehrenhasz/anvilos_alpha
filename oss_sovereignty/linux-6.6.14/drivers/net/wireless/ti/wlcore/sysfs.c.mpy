{
  "module_name": "sysfs.c",
  "hash_id": "8fbcdf8f183bf05946dde5c0b534551e197603140032729782e96bf3e7460117",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wlcore/sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/pm_runtime.h>\n\n#include \"acx.h\"\n#include \"wlcore.h\"\n#include \"debug.h\"\n#include \"sysfs.h\"\n\nstatic ssize_t bt_coex_state_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tstruct wl1271 *wl = dev_get_drvdata(dev);\n\tssize_t len;\n\n\tlen = PAGE_SIZE;\n\n\tmutex_lock(&wl->mutex);\n\tlen = snprintf(buf, len, \"%d\\n\\n0 - off\\n1 - on\\n\",\n\t\t       wl->sg_enabled);\n\tmutex_unlock(&wl->mutex);\n\n\treturn len;\n\n}\n\nstatic ssize_t bt_coex_state_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct wl1271 *wl = dev_get_drvdata(dev);\n\tunsigned long res;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &res);\n\tif (ret < 0) {\n\t\twl1271_warning(\"incorrect value written to bt_coex_mode\");\n\t\treturn count;\n\t}\n\n\tmutex_lock(&wl->mutex);\n\n\tres = !!res;\n\n\tif (res == wl->sg_enabled)\n\t\tgoto out;\n\n\twl->sg_enabled = res;\n\n\tif (unlikely(wl->state != WLCORE_STATE_ON))\n\t\tgoto out;\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twl1271_acx_sg_enable(wl, wl->sg_enabled);\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\n\n out:\n\tmutex_unlock(&wl->mutex);\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(bt_coex_state);\n\nstatic ssize_t hw_pg_ver_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct wl1271 *wl = dev_get_drvdata(dev);\n\tssize_t len;\n\n\tlen = PAGE_SIZE;\n\n\tmutex_lock(&wl->mutex);\n\tif (wl->hw_pg_ver >= 0)\n\t\tlen = snprintf(buf, len, \"%d\\n\", wl->hw_pg_ver);\n\telse\n\t\tlen = snprintf(buf, len, \"n/a\\n\");\n\tmutex_unlock(&wl->mutex);\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR_RO(hw_pg_ver);\n\nstatic ssize_t wl1271_sysfs_read_fwlog(struct file *filp, struct kobject *kobj,\n\t\t\t\t       struct bin_attribute *bin_attr,\n\t\t\t\t       char *buffer, loff_t pos, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct wl1271 *wl = dev_get_drvdata(dev);\n\tssize_t len;\n\tint ret;\n\n\tret = mutex_lock_interruptible(&wl->mutex);\n\tif (ret < 0)\n\t\treturn -ERESTARTSYS;\n\n\t \n\tif (wl->fwlog_size < 0) {\n\t\tmutex_unlock(&wl->mutex);\n\t\treturn 0;\n\t}\n\n\t \n\tlen = min_t(size_t, count, wl->fwlog_size);\n\twl->fwlog_size -= len;\n\tmemcpy(buffer, wl->fwlog, len);\n\n\t \n\tmemmove(wl->fwlog, wl->fwlog + len, wl->fwlog_size);\n\n\tmutex_unlock(&wl->mutex);\n\n\treturn len;\n}\n\nstatic const struct bin_attribute fwlog_attr = {\n\t.attr = { .name = \"fwlog\", .mode = 0400 },\n\t.read = wl1271_sysfs_read_fwlog,\n};\n\nint wlcore_sysfs_init(struct wl1271 *wl)\n{\n\tint ret;\n\n\t \n\tret = device_create_file(wl->dev, &dev_attr_bt_coex_state);\n\tif (ret < 0) {\n\t\twl1271_error(\"failed to create sysfs file bt_coex_state\");\n\t\tgoto out;\n\t}\n\n\t \n\tret = device_create_file(wl->dev, &dev_attr_hw_pg_ver);\n\tif (ret < 0) {\n\t\twl1271_error(\"failed to create sysfs file hw_pg_ver\");\n\t\tgoto out_bt_coex_state;\n\t}\n\n\t \n\tret = device_create_bin_file(wl->dev, &fwlog_attr);\n\tif (ret < 0) {\n\t\twl1271_error(\"failed to create sysfs file fwlog\");\n\t\tgoto out_hw_pg_ver;\n\t}\n\n\tgoto out;\n\nout_hw_pg_ver:\n\tdevice_remove_file(wl->dev, &dev_attr_hw_pg_ver);\n\nout_bt_coex_state:\n\tdevice_remove_file(wl->dev, &dev_attr_bt_coex_state);\n\nout:\n\treturn ret;\n}\n\nvoid wlcore_sysfs_free(struct wl1271 *wl)\n{\n\tdevice_remove_bin_file(wl->dev, &fwlog_attr);\n\n\tdevice_remove_file(wl->dev, &dev_attr_hw_pg_ver);\n\n\tdevice_remove_file(wl->dev, &dev_attr_bt_coex_state);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}