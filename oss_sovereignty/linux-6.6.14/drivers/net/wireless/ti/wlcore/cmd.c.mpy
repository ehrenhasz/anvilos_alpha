{
  "module_name": "cmd.c",
  "hash_id": "17bae198242dadfca323f7f6717c2abca48b4b402b349ab602112818c7ec5511",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wlcore/cmd.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/spi/spi.h>\n#include <linux/etherdevice.h>\n#include <linux/ieee80211.h>\n#include <linux/slab.h>\n\n#include \"wlcore.h\"\n#include \"debug.h\"\n#include \"io.h\"\n#include \"acx.h\"\n#include \"wl12xx_80211.h\"\n#include \"cmd.h\"\n#include \"event.h\"\n#include \"tx.h\"\n#include \"hw_ops.h\"\n\n#define WL1271_CMD_FAST_POLL_COUNT       50\n#define WL1271_WAIT_EVENT_FAST_POLL_COUNT 20\n\n \nstatic int __wlcore_cmd_send(struct wl1271 *wl, u16 id, void *buf,\n\t\t\t     size_t len, size_t res_len)\n{\n\tstruct wl1271_cmd_header *cmd;\n\tunsigned long timeout;\n\tu32 intr;\n\tint ret;\n\tu16 status;\n\tu16 poll_count = 0;\n\n\tif (unlikely(wl->state == WLCORE_STATE_RESTARTING &&\n\t\t     id != CMD_STOP_FWLOGGER))\n\t\treturn -EIO;\n\n\tif (WARN_ON_ONCE(len < sizeof(*cmd)))\n\t\treturn -EIO;\n\n\tcmd = buf;\n\tcmd->id = cpu_to_le16(id);\n\tcmd->status = 0;\n\n\tWARN_ON(len % 4 != 0);\n\tWARN_ON(test_bit(WL1271_FLAG_IN_ELP, &wl->flags));\n\n\tret = wlcore_write(wl, wl->cmd_box_addr, buf, len, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wl->ops->trigger_cmd(wl, wl->cmd_box_addr, buf, len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttimeout = jiffies + msecs_to_jiffies(WL1271_COMMAND_TIMEOUT);\n\n\tret = wlcore_read_reg(wl, REG_INTERRUPT_NO_CLEAR, &intr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twhile (!(intr & WL1271_ACX_INTR_CMD_COMPLETE)) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\twl1271_error(\"command complete timeout\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\tpoll_count++;\n\t\tif (poll_count < WL1271_CMD_FAST_POLL_COUNT)\n\t\t\tudelay(10);\n\t\telse\n\t\t\tmsleep(1);\n\n\t\tret = wlcore_read_reg(wl, REG_INTERRUPT_NO_CLEAR, &intr);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (res_len == 0)\n\t\tres_len = sizeof(struct wl1271_cmd_header);\n\n\tret = wlcore_read(wl, wl->cmd_box_addr, cmd, res_len, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstatus = le16_to_cpu(cmd->status);\n\n\tret = wlcore_write_reg(wl, REG_INTERRUPT_ACK,\n\t\t\t       WL1271_ACX_INTR_CMD_COMPLETE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn status;\n}\n\n \nstatic int wlcore_cmd_send_failsafe(struct wl1271 *wl, u16 id, void *buf,\n\t\t\t\t    size_t len, size_t res_len,\n\t\t\t\t    unsigned long valid_rets)\n{\n\tint ret = __wlcore_cmd_send(wl, id, buf, len, res_len);\n\n\tif (ret < 0)\n\t\tgoto fail;\n\n\t \n\tvalid_rets |= BIT(CMD_STATUS_SUCCESS);\n\n\tif (ret >= MAX_COMMAND_STATUS ||\n\t    !test_bit(ret, &valid_rets)) {\n\t\twl1271_error(\"command execute failure %d\", ret);\n\t\tret = -EIO;\n\t\tgoto fail;\n\t}\n\treturn ret;\nfail:\n\twl12xx_queue_recovery_work(wl);\n\treturn ret;\n}\n\n \nint wl1271_cmd_send(struct wl1271 *wl, u16 id, void *buf, size_t len,\n\t\t    size_t res_len)\n{\n\tint ret = wlcore_cmd_send_failsafe(wl, id, buf, len, res_len, 0);\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wl1271_cmd_send);\n\n \nint wlcore_cmd_wait_for_event_or_timeout(struct wl1271 *wl,\n\t\t\t\t\t u32 mask, bool *timeout)\n{\n\tu32 *events_vector;\n\tu32 event;\n\tunsigned long timeout_time;\n\tu16 poll_count = 0;\n\tint ret = 0;\n\n\t*timeout = false;\n\n\tevents_vector = kmalloc(sizeof(*events_vector), GFP_KERNEL | GFP_DMA);\n\tif (!events_vector)\n\t\treturn -ENOMEM;\n\n\ttimeout_time = jiffies + msecs_to_jiffies(WL1271_EVENT_TIMEOUT);\n\n\tret = pm_runtime_resume_and_get(wl->dev);\n\tif (ret < 0)\n\t\tgoto free_vector;\n\n\tdo {\n\t\tif (time_after(jiffies, timeout_time)) {\n\t\t\twl1271_debug(DEBUG_CMD, \"timeout waiting for event %d\",\n\t\t\t\t     (int)mask);\n\t\t\t*timeout = true;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpoll_count++;\n\t\tif (poll_count < WL1271_WAIT_EVENT_FAST_POLL_COUNT)\n\t\t\tusleep_range(50, 51);\n\t\telse\n\t\t\tusleep_range(1000, 5000);\n\n\t\t \n\t\tret = wlcore_read(wl, wl->mbox_ptr[0], events_vector,\n\t\t\t\t  sizeof(*events_vector), false);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tevent = *events_vector & mask;\n\n\t\tret = wlcore_read(wl, wl->mbox_ptr[1], events_vector,\n\t\t\t\t  sizeof(*events_vector), false);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tevent |= *events_vector & mask;\n\t} while (!event);\n\nout:\n\tpm_runtime_mark_last_busy(wl->dev);\n\tpm_runtime_put_autosuspend(wl->dev);\nfree_vector:\n\tkfree(events_vector);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wlcore_cmd_wait_for_event_or_timeout);\n\nint wl12xx_cmd_role_enable(struct wl1271 *wl, u8 *addr, u8 role_type,\n\t\t\t   u8 *role_id)\n{\n\tstruct wl12xx_cmd_role_enable *cmd;\n\tint ret;\n\n\twl1271_debug(DEBUG_CMD, \"cmd role enable\");\n\n\tif (WARN_ON(*role_id != WL12XX_INVALID_ROLE_ID))\n\t\treturn -EBUSY;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tcmd->role_id = find_first_zero_bit(wl->roles_map, WL12XX_MAX_ROLES);\n\tif (cmd->role_id >= WL12XX_MAX_ROLES) {\n\t\tret = -EBUSY;\n\t\tgoto out_free;\n\t}\n\n\tmemcpy(cmd->mac_address, addr, ETH_ALEN);\n\tcmd->role_type = role_type;\n\n\tret = wl1271_cmd_send(wl, CMD_ROLE_ENABLE, cmd, sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_error(\"failed to initiate cmd role enable\");\n\t\tgoto out_free;\n\t}\n\n\t__set_bit(cmd->role_id, wl->roles_map);\n\t*role_id = cmd->role_id;\n\nout_free:\n\tkfree(cmd);\n\nout:\n\treturn ret;\n}\n\nint wl12xx_cmd_role_disable(struct wl1271 *wl, u8 *role_id)\n{\n\tstruct wl12xx_cmd_role_disable *cmd;\n\tint ret;\n\n\twl1271_debug(DEBUG_CMD, \"cmd role disable\");\n\n\tif (WARN_ON(*role_id == WL12XX_INVALID_ROLE_ID))\n\t\treturn -ENOENT;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tcmd->role_id = *role_id;\n\n\tret = wl1271_cmd_send(wl, CMD_ROLE_DISABLE, cmd, sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_error(\"failed to initiate cmd role disable\");\n\t\tgoto out_free;\n\t}\n\n\t__clear_bit(*role_id, wl->roles_map);\n\t*role_id = WL12XX_INVALID_ROLE_ID;\n\nout_free:\n\tkfree(cmd);\n\nout:\n\treturn ret;\n}\n\nstatic int wlcore_get_new_session_id(struct wl1271 *wl, u8 hlid)\n{\n\tif (wl->session_ids[hlid] >= SESSION_COUNTER_MAX)\n\t\twl->session_ids[hlid] = 0;\n\n\twl->session_ids[hlid]++;\n\n\treturn wl->session_ids[hlid];\n}\n\nint wl12xx_allocate_link(struct wl1271 *wl, struct wl12xx_vif *wlvif, u8 *hlid)\n{\n\tunsigned long flags;\n\tu8 link = find_first_zero_bit(wl->links_map, wl->num_links);\n\tif (link >= wl->num_links)\n\t\treturn -EBUSY;\n\n\twl->session_ids[link] = wlcore_get_new_session_id(wl, link);\n\n\t \n\tspin_lock_irqsave(&wl->wl_lock, flags);\n\t__set_bit(link, wl->links_map);\n\t__set_bit(link, wlvif->links_map);\n\tspin_unlock_irqrestore(&wl->wl_lock, flags);\n\n\t \n\tif (wl->fw_status->counters.tx_lnk_free_pkts)\n\t\twl->links[link].prev_freed_pkts =\n\t\t\twl->fw_status->counters.tx_lnk_free_pkts[link];\n\twl->links[link].wlvif = wlvif;\n\n\t \n\tif (wlvif->bss_type != BSS_TYPE_AP_BSS)\n\t\twl->links[link].total_freed_pkts = wlvif->total_freed_pkts;\n\n\t*hlid = link;\n\n\twl->active_link_count++;\n\treturn 0;\n}\n\nvoid wl12xx_free_link(struct wl1271 *wl, struct wl12xx_vif *wlvif, u8 *hlid)\n{\n\tunsigned long flags;\n\n\tif (*hlid == WL12XX_INVALID_LINK_ID)\n\t\treturn;\n\n\t \n\tspin_lock_irqsave(&wl->wl_lock, flags);\n\t__clear_bit(*hlid, wl->links_map);\n\t__clear_bit(*hlid, wlvif->links_map);\n\tspin_unlock_irqrestore(&wl->wl_lock, flags);\n\n\twl->links[*hlid].allocated_pkts = 0;\n\twl->links[*hlid].prev_freed_pkts = 0;\n\twl->links[*hlid].ba_bitmap = 0;\n\teth_zero_addr(wl->links[*hlid].addr);\n\n\t \n\twl1271_tx_reset_link_queues(wl, *hlid);\n\twl->links[*hlid].wlvif = NULL;\n\n\tif (wlvif->bss_type == BSS_TYPE_AP_BSS &&\n\t    *hlid == wlvif->ap.bcast_hlid) {\n\t\tu32 sqn_padding = WL1271_TX_SQN_POST_RECOVERY_PADDING;\n\t\t \n\t\twlvif->total_freed_pkts = wl->links[*hlid].total_freed_pkts;\n\n\t\t \n\t\tif (wlvif->encryption_type == KEY_GEM)\n\t\t\tsqn_padding = WL1271_TX_SQN_POST_RECOVERY_PADDING_GEM;\n\n\t\tif (test_bit(WL1271_FLAG_RECOVERY_IN_PROGRESS, &wl->flags))\n\t\t\twlvif->total_freed_pkts += sqn_padding;\n\t}\n\n\twl->links[*hlid].total_freed_pkts = 0;\n\n\t*hlid = WL12XX_INVALID_LINK_ID;\n\twl->active_link_count--;\n\tWARN_ON_ONCE(wl->active_link_count < 0);\n}\n\nu8 wlcore_get_native_channel_type(u8 nl_channel_type)\n{\n\tswitch (nl_channel_type) {\n\tcase NL80211_CHAN_NO_HT:\n\t\treturn WLCORE_CHAN_NO_HT;\n\tcase NL80211_CHAN_HT20:\n\t\treturn WLCORE_CHAN_HT20;\n\tcase NL80211_CHAN_HT40MINUS:\n\t\treturn WLCORE_CHAN_HT40MINUS;\n\tcase NL80211_CHAN_HT40PLUS:\n\t\treturn WLCORE_CHAN_HT40PLUS;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn WLCORE_CHAN_NO_HT;\n\t}\n}\nEXPORT_SYMBOL_GPL(wlcore_get_native_channel_type);\n\nstatic int wl12xx_cmd_role_start_dev(struct wl1271 *wl,\n\t\t\t\t     struct wl12xx_vif *wlvif,\n\t\t\t\t     enum nl80211_band band,\n\t\t\t\t     int channel)\n{\n\tstruct wl12xx_cmd_role_start *cmd;\n\tint ret;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\twl1271_debug(DEBUG_CMD, \"cmd role start dev %d\", wlvif->dev_role_id);\n\n\tcmd->role_id = wlvif->dev_role_id;\n\tif (band == NL80211_BAND_5GHZ)\n\t\tcmd->band = WLCORE_BAND_5GHZ;\n\tcmd->channel = channel;\n\n\tif (wlvif->dev_hlid == WL12XX_INVALID_LINK_ID) {\n\t\tret = wl12xx_allocate_link(wl, wlvif, &wlvif->dev_hlid);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\tcmd->device.hlid = wlvif->dev_hlid;\n\tcmd->device.session = wl->session_ids[wlvif->dev_hlid];\n\n\twl1271_debug(DEBUG_CMD, \"role start: roleid=%d, hlid=%d, session=%d\",\n\t\t     cmd->role_id, cmd->device.hlid, cmd->device.session);\n\n\tret = wl1271_cmd_send(wl, CMD_ROLE_START, cmd, sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_error(\"failed to initiate cmd role enable\");\n\t\tgoto err_hlid;\n\t}\n\n\tgoto out_free;\n\nerr_hlid:\n\t \n\twl12xx_free_link(wl, wlvif, &wlvif->dev_hlid);\n\nout_free:\n\tkfree(cmd);\n\nout:\n\treturn ret;\n}\n\nstatic int wl12xx_cmd_role_stop_dev(struct wl1271 *wl,\n\t\t\t\t    struct wl12xx_vif *wlvif)\n{\n\tstruct wl12xx_cmd_role_stop *cmd;\n\tint ret;\n\n\tif (WARN_ON(wlvif->dev_hlid == WL12XX_INVALID_LINK_ID))\n\t\treturn -EINVAL;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\twl1271_debug(DEBUG_CMD, \"cmd role stop dev\");\n\n\tcmd->role_id = wlvif->dev_role_id;\n\tcmd->disc_type = DISCONNECT_IMMEDIATE;\n\tcmd->reason = cpu_to_le16(WLAN_REASON_UNSPECIFIED);\n\n\tret = wl1271_cmd_send(wl, CMD_ROLE_STOP, cmd, sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_error(\"failed to initiate cmd role stop\");\n\t\tgoto out_free;\n\t}\n\n\twl12xx_free_link(wl, wlvif, &wlvif->dev_hlid);\n\nout_free:\n\tkfree(cmd);\n\nout:\n\treturn ret;\n}\n\nint wl12xx_cmd_role_start_sta(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tstruct ieee80211_vif *vif = wl12xx_wlvif_to_vif(wlvif);\n\tstruct wl12xx_cmd_role_start *cmd;\n\tu32 supported_rates;\n\tint ret;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\twl1271_debug(DEBUG_CMD, \"cmd role start sta %d\", wlvif->role_id);\n\n\tcmd->role_id = wlvif->role_id;\n\tif (wlvif->band == NL80211_BAND_5GHZ)\n\t\tcmd->band = WLCORE_BAND_5GHZ;\n\tcmd->channel = wlvif->channel;\n\tcmd->sta.basic_rate_set = cpu_to_le32(wlvif->basic_rate_set);\n\tcmd->sta.beacon_interval = cpu_to_le16(wlvif->beacon_int);\n\tcmd->sta.ssid_type = WL12XX_SSID_TYPE_ANY;\n\tcmd->sta.ssid_len = wlvif->ssid_len;\n\tmemcpy(cmd->sta.ssid, wlvif->ssid, wlvif->ssid_len);\n\tmemcpy(cmd->sta.bssid, vif->bss_conf.bssid, ETH_ALEN);\n\n\tsupported_rates = CONF_TX_ENABLED_RATES | CONF_TX_MCS_RATES |\n\t\t\t  wlcore_hw_sta_get_ap_rate_mask(wl, wlvif);\n\tif (wlvif->p2p)\n\t\tsupported_rates &= ~CONF_TX_CCK_RATES;\n\n\tcmd->sta.local_rates = cpu_to_le32(supported_rates);\n\n\tcmd->channel_type = wlcore_get_native_channel_type(wlvif->channel_type);\n\n\tif (wlvif->sta.hlid == WL12XX_INVALID_LINK_ID) {\n\t\tret = wl12xx_allocate_link(wl, wlvif, &wlvif->sta.hlid);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\tcmd->sta.hlid = wlvif->sta.hlid;\n\tcmd->sta.session = wl->session_ids[wlvif->sta.hlid];\n\t \n\tcmd->sta.remote_rates = cpu_to_le32(supported_rates);\n\n\twl1271_debug(DEBUG_CMD, \"role start: roleid=%d, hlid=%d, session=%d \"\n\t\t     \"basic_rate_set: 0x%x, remote_rates: 0x%x\",\n\t\t     wlvif->role_id, cmd->sta.hlid, cmd->sta.session,\n\t\t     wlvif->basic_rate_set, wlvif->rate_set);\n\n\tret = wl1271_cmd_send(wl, CMD_ROLE_START, cmd, sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_error(\"failed to initiate cmd role start sta\");\n\t\tgoto err_hlid;\n\t}\n\n\twlvif->sta.role_chan_type = wlvif->channel_type;\n\tgoto out_free;\n\nerr_hlid:\n\t \n\twl12xx_free_link(wl, wlvif, &wlvif->sta.hlid);\n\nout_free:\n\tkfree(cmd);\n\nout:\n\treturn ret;\n}\n\n \nint wl12xx_cmd_role_stop_sta(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tstruct wl12xx_cmd_role_stop *cmd;\n\tint ret;\n\n\tif (WARN_ON(wlvif->sta.hlid == WL12XX_INVALID_LINK_ID))\n\t\treturn -EINVAL;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\twl1271_debug(DEBUG_CMD, \"cmd role stop sta %d\", wlvif->role_id);\n\n\tcmd->role_id = wlvif->role_id;\n\tcmd->disc_type = DISCONNECT_IMMEDIATE;\n\tcmd->reason = cpu_to_le16(WLAN_REASON_UNSPECIFIED);\n\n\tret = wl1271_cmd_send(wl, CMD_ROLE_STOP, cmd, sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_error(\"failed to initiate cmd role stop sta\");\n\t\tgoto out_free;\n\t}\n\n\twl12xx_free_link(wl, wlvif, &wlvif->sta.hlid);\n\nout_free:\n\tkfree(cmd);\n\nout:\n\treturn ret;\n}\n\nint wl12xx_cmd_role_start_ap(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tstruct wl12xx_cmd_role_start *cmd;\n\tstruct ieee80211_vif *vif = wl12xx_wlvif_to_vif(wlvif);\n\tstruct ieee80211_bss_conf *bss_conf = &vif->bss_conf;\n\tu32 supported_rates;\n\tint ret;\n\n\twl1271_debug(DEBUG_CMD, \"cmd role start ap %d\", wlvif->role_id);\n\n\t \n\tif (!ieee80211_vif_is_mesh(vif)) {\n\t\t \n\t\tif (wlvif->ssid_len == 0 && !bss_conf->hidden_ssid) {\n\t\t\twl1271_error(\"got a null SSID from beacon/bss\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = wl12xx_allocate_link(wl, wlvif, &wlvif->ap.global_hlid);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n\tret = wl12xx_allocate_link(wl, wlvif, &wlvif->ap.bcast_hlid);\n\tif (ret < 0)\n\t\tgoto out_free_global;\n\n\t \n\twl->links[wlvif->ap.bcast_hlid].total_freed_pkts =\n\t\t\t\t\t\twlvif->total_freed_pkts;\n\n\tcmd->role_id = wlvif->role_id;\n\tcmd->ap.aging_period = cpu_to_le16(wl->conf.tx.ap_aging_period);\n\tcmd->ap.bss_index = WL1271_AP_BSS_INDEX;\n\tcmd->ap.global_hlid = wlvif->ap.global_hlid;\n\tcmd->ap.broadcast_hlid = wlvif->ap.bcast_hlid;\n\tcmd->ap.global_session_id = wl->session_ids[wlvif->ap.global_hlid];\n\tcmd->ap.bcast_session_id = wl->session_ids[wlvif->ap.bcast_hlid];\n\tcmd->ap.basic_rate_set = cpu_to_le32(wlvif->basic_rate_set);\n\tcmd->ap.beacon_interval = cpu_to_le16(wlvif->beacon_int);\n\tcmd->ap.dtim_interval = bss_conf->dtim_period;\n\tcmd->ap.beacon_expiry = WL1271_AP_DEF_BEACON_EXP;\n\t \n\tcmd->ap.reset_tsf = 1;   \n\tcmd->ap.wmm = wlvif->wmm_enabled;\n\tcmd->channel = wlvif->channel;\n\tcmd->channel_type = wlcore_get_native_channel_type(wlvif->channel_type);\n\n\tif (!bss_conf->hidden_ssid) {\n\t\t \n\t\tcmd->ap.ssid_type = WL12XX_SSID_TYPE_PUBLIC;\n\t\tcmd->ap.ssid_len = wlvif->ssid_len;\n\t\tmemcpy(cmd->ap.ssid, wlvif->ssid, wlvif->ssid_len);\n\t} else {\n\t\tcmd->ap.ssid_type = WL12XX_SSID_TYPE_HIDDEN;\n\t\tcmd->ap.ssid_len = vif->cfg.ssid_len;\n\t\tmemcpy(cmd->ap.ssid, vif->cfg.ssid, vif->cfg.ssid_len);\n\t}\n\n\tsupported_rates = CONF_TX_ENABLED_RATES | CONF_TX_MCS_RATES |\n\t\twlcore_hw_ap_get_mimo_wide_rate_mask(wl, wlvif);\n\tif (wlvif->p2p)\n\t\tsupported_rates &= ~CONF_TX_CCK_RATES;\n\n\twl1271_debug(DEBUG_CMD, \"cmd role start ap with supported_rates 0x%08x\",\n\t\t     supported_rates);\n\n\tcmd->ap.local_rates = cpu_to_le32(supported_rates);\n\n\tswitch (wlvif->band) {\n\tcase NL80211_BAND_2GHZ:\n\t\tcmd->band = WLCORE_BAND_2_4GHZ;\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\tcmd->band = WLCORE_BAND_5GHZ;\n\t\tbreak;\n\tdefault:\n\t\twl1271_warning(\"ap start - unknown band: %d\", (int)wlvif->band);\n\t\tcmd->band = WLCORE_BAND_2_4GHZ;\n\t\tbreak;\n\t}\n\n\tret = wl1271_cmd_send(wl, CMD_ROLE_START, cmd, sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_error(\"failed to initiate cmd role start ap\");\n\t\tgoto out_free_bcast;\n\t}\n\n\tgoto out_free;\n\nout_free_bcast:\n\twl12xx_free_link(wl, wlvif, &wlvif->ap.bcast_hlid);\n\nout_free_global:\n\twl12xx_free_link(wl, wlvif, &wlvif->ap.global_hlid);\n\nout_free:\n\tkfree(cmd);\n\nout:\n\treturn ret;\n}\n\nint wl12xx_cmd_role_stop_ap(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tstruct wl12xx_cmd_role_stop *cmd;\n\tint ret;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\twl1271_debug(DEBUG_CMD, \"cmd role stop ap %d\", wlvif->role_id);\n\n\tcmd->role_id = wlvif->role_id;\n\n\tret = wl1271_cmd_send(wl, CMD_ROLE_STOP, cmd, sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_error(\"failed to initiate cmd role stop ap\");\n\t\tgoto out_free;\n\t}\n\n\twl12xx_free_link(wl, wlvif, &wlvif->ap.bcast_hlid);\n\twl12xx_free_link(wl, wlvif, &wlvif->ap.global_hlid);\n\nout_free:\n\tkfree(cmd);\n\nout:\n\treturn ret;\n}\n\nint wl12xx_cmd_role_start_ibss(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tstruct ieee80211_vif *vif = wl12xx_wlvif_to_vif(wlvif);\n\tstruct wl12xx_cmd_role_start *cmd;\n\tstruct ieee80211_bss_conf *bss_conf = &vif->bss_conf;\n\tint ret;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\twl1271_debug(DEBUG_CMD, \"cmd role start ibss %d\", wlvif->role_id);\n\n\tcmd->role_id = wlvif->role_id;\n\tif (wlvif->band == NL80211_BAND_5GHZ)\n\t\tcmd->band = WLCORE_BAND_5GHZ;\n\tcmd->channel = wlvif->channel;\n\tcmd->ibss.basic_rate_set = cpu_to_le32(wlvif->basic_rate_set);\n\tcmd->ibss.beacon_interval = cpu_to_le16(wlvif->beacon_int);\n\tcmd->ibss.dtim_interval = bss_conf->dtim_period;\n\tcmd->ibss.ssid_type = WL12XX_SSID_TYPE_ANY;\n\tcmd->ibss.ssid_len = wlvif->ssid_len;\n\tmemcpy(cmd->ibss.ssid, wlvif->ssid, wlvif->ssid_len);\n\tmemcpy(cmd->ibss.bssid, vif->bss_conf.bssid, ETH_ALEN);\n\tcmd->sta.local_rates = cpu_to_le32(wlvif->rate_set);\n\n\tif (wlvif->sta.hlid == WL12XX_INVALID_LINK_ID) {\n\t\tret = wl12xx_allocate_link(wl, wlvif, &wlvif->sta.hlid);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\tcmd->ibss.hlid = wlvif->sta.hlid;\n\tcmd->ibss.remote_rates = cpu_to_le32(wlvif->rate_set);\n\n\twl1271_debug(DEBUG_CMD, \"role start: roleid=%d, hlid=%d, session=%d \"\n\t\t     \"basic_rate_set: 0x%x, remote_rates: 0x%x\",\n\t\t     wlvif->role_id, cmd->sta.hlid, cmd->sta.session,\n\t\t     wlvif->basic_rate_set, wlvif->rate_set);\n\n\twl1271_debug(DEBUG_CMD, \"vif->bss_conf.bssid = %pM\",\n\t\t     vif->bss_conf.bssid);\n\n\tret = wl1271_cmd_send(wl, CMD_ROLE_START, cmd, sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_error(\"failed to initiate cmd role enable\");\n\t\tgoto err_hlid;\n\t}\n\n\tgoto out_free;\n\nerr_hlid:\n\t \n\twl12xx_free_link(wl, wlvif, &wlvif->sta.hlid);\n\nout_free:\n\tkfree(cmd);\n\nout:\n\treturn ret;\n}\n\n\n \nint wl1271_cmd_test(struct wl1271 *wl, void *buf, size_t buf_len, u8 answer)\n{\n\tint ret;\n\tsize_t res_len = 0;\n\n\twl1271_debug(DEBUG_CMD, \"cmd test\");\n\n\tif (answer)\n\t\tres_len = buf_len;\n\n\tret = wl1271_cmd_send(wl, CMD_TEST, buf, buf_len, res_len);\n\n\tif (ret < 0) {\n\t\twl1271_warning(\"TEST command failed\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wl1271_cmd_test);\n\n \nint wl1271_cmd_interrogate(struct wl1271 *wl, u16 id, void *buf,\n\t\t\t   size_t cmd_len, size_t res_len)\n{\n\tstruct acx_header *acx = buf;\n\tint ret;\n\n\twl1271_debug(DEBUG_CMD, \"cmd interrogate\");\n\n\tacx->id = cpu_to_le16(id);\n\n\t \n\tacx->len = cpu_to_le16(res_len - sizeof(*acx));\n\n\tret = wl1271_cmd_send(wl, CMD_INTERROGATE, acx, cmd_len, res_len);\n\tif (ret < 0)\n\t\twl1271_error(\"INTERROGATE command failed\");\n\n\treturn ret;\n}\n\n \nint wlcore_cmd_configure_failsafe(struct wl1271 *wl, u16 id, void *buf,\n\t\t\t\t  size_t len, unsigned long valid_rets)\n{\n\tstruct acx_header *acx = buf;\n\tint ret;\n\n\twl1271_debug(DEBUG_CMD, \"cmd configure (%d)\", id);\n\n\tif (WARN_ON_ONCE(len < sizeof(*acx)))\n\t\treturn -EIO;\n\n\tacx->id = cpu_to_le16(id);\n\n\t \n\tacx->len = cpu_to_le16(len - sizeof(*acx));\n\n\tret = wlcore_cmd_send_failsafe(wl, CMD_CONFIGURE, acx, len, 0,\n\t\t\t\t       valid_rets);\n\tif (ret < 0) {\n\t\twl1271_warning(\"CONFIGURE command NOK\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\n \nint wl1271_cmd_configure(struct wl1271 *wl, u16 id, void *buf, size_t len)\n{\n\tint ret = wlcore_cmd_configure_failsafe(wl, id, buf, len, 0);\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wl1271_cmd_configure);\n\nint wl1271_cmd_data_path(struct wl1271 *wl, bool enable)\n{\n\tstruct cmd_enabledisable_path *cmd;\n\tint ret;\n\tu16 cmd_rx, cmd_tx;\n\n\twl1271_debug(DEBUG_CMD, \"cmd data path\");\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tcmd->channel = 1;\n\n\tif (enable) {\n\t\tcmd_rx = CMD_ENABLE_RX;\n\t\tcmd_tx = CMD_ENABLE_TX;\n\t} else {\n\t\tcmd_rx = CMD_DISABLE_RX;\n\t\tcmd_tx = CMD_DISABLE_TX;\n\t}\n\n\tret = wl1271_cmd_send(wl, cmd_rx, cmd, sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_error(\"rx %s cmd for channel %d failed\",\n\t\t\t     enable ? \"start\" : \"stop\", cmd->channel);\n\t\tgoto out;\n\t}\n\n\twl1271_debug(DEBUG_BOOT, \"rx %s cmd channel %d\",\n\t\t     enable ? \"start\" : \"stop\", cmd->channel);\n\n\tret = wl1271_cmd_send(wl, cmd_tx, cmd, sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_error(\"tx %s cmd for channel %d failed\",\n\t\t\t     enable ? \"start\" : \"stop\", cmd->channel);\n\t\tgoto out;\n\t}\n\n\twl1271_debug(DEBUG_BOOT, \"tx %s cmd channel %d\",\n\t\t     enable ? \"start\" : \"stop\", cmd->channel);\n\nout:\n\tkfree(cmd);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wl1271_cmd_data_path);\n\nint wl1271_cmd_ps_mode(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t       u8 ps_mode, u16 auto_ps_timeout)\n{\n\tstruct wl1271_cmd_ps_params *ps_params = NULL;\n\tint ret = 0;\n\n\twl1271_debug(DEBUG_CMD, \"cmd set ps mode\");\n\n\tps_params = kzalloc(sizeof(*ps_params), GFP_KERNEL);\n\tif (!ps_params) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tps_params->role_id = wlvif->role_id;\n\tps_params->ps_mode = ps_mode;\n\tps_params->auto_ps_timeout = auto_ps_timeout;\n\n\tret = wl1271_cmd_send(wl, CMD_SET_PS_MODE, ps_params,\n\t\t\t      sizeof(*ps_params), 0);\n\tif (ret < 0) {\n\t\twl1271_error(\"cmd set_ps_mode failed\");\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(ps_params);\n\treturn ret;\n}\n\nint wl1271_cmd_template_set(struct wl1271 *wl, u8 role_id,\n\t\t\t    u16 template_id, void *buf, size_t buf_len,\n\t\t\t    int index, u32 rates)\n{\n\tstruct wl1271_cmd_template_set *cmd;\n\tint ret = 0;\n\n\twl1271_debug(DEBUG_CMD, \"cmd template_set %d (role %d)\",\n\t\t     template_id, role_id);\n\n\tWARN_ON(buf_len > WL1271_CMD_TEMPL_MAX_SIZE);\n\tbuf_len = min_t(size_t, buf_len, WL1271_CMD_TEMPL_MAX_SIZE);\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tcmd->role_id = role_id;\n\tcmd->len = cpu_to_le16(buf_len);\n\tcmd->template_type = template_id;\n\tcmd->enabled_rates = cpu_to_le32(rates);\n\tcmd->short_retry_limit = wl->conf.tx.tmpl_short_retry_limit;\n\tcmd->long_retry_limit = wl->conf.tx.tmpl_long_retry_limit;\n\tcmd->index = index;\n\n\tif (buf)\n\t\tmemcpy(cmd->template_data, buf, buf_len);\n\n\tret = wl1271_cmd_send(wl, CMD_SET_TEMPLATE, cmd, sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_warning(\"cmd set_template failed: %d\", ret);\n\t\tgoto out_free;\n\t}\n\nout_free:\n\tkfree(cmd);\n\nout:\n\treturn ret;\n}\n\nint wl12xx_cmd_build_null_data(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tstruct sk_buff *skb = NULL;\n\tint size;\n\tvoid *ptr;\n\tint ret = -ENOMEM;\n\n\n\tif (wlvif->bss_type == BSS_TYPE_IBSS) {\n\t\tsize = sizeof(struct wl12xx_null_data_template);\n\t\tptr = NULL;\n\t} else {\n\t\tskb = ieee80211_nullfunc_get(wl->hw,\n\t\t\t\t\t     wl12xx_wlvif_to_vif(wlvif),\n\t\t\t\t\t     -1, false);\n\t\tif (!skb)\n\t\t\tgoto out;\n\t\tsize = skb->len;\n\t\tptr = skb->data;\n\t}\n\n\tret = wl1271_cmd_template_set(wl, wlvif->role_id,\n\t\t\t\t      CMD_TEMPL_NULL_DATA, ptr, size, 0,\n\t\t\t\t      wlvif->basic_rate);\n\nout:\n\tdev_kfree_skb(skb);\n\tif (ret)\n\t\twl1271_warning(\"cmd build null data failed %d\", ret);\n\n\treturn ret;\n\n}\n\nint wl12xx_cmd_build_klv_null_data(struct wl1271 *wl,\n\t\t\t\t   struct wl12xx_vif *wlvif)\n{\n\tstruct ieee80211_vif *vif = wl12xx_wlvif_to_vif(wlvif);\n\tstruct sk_buff *skb = NULL;\n\tint ret = -ENOMEM;\n\n\tskb = ieee80211_nullfunc_get(wl->hw, vif,-1, false);\n\tif (!skb)\n\t\tgoto out;\n\n\tret = wl1271_cmd_template_set(wl, wlvif->role_id, CMD_TEMPL_KLV,\n\t\t\t\t      skb->data, skb->len,\n\t\t\t\t      wlvif->sta.klv_template_id,\n\t\t\t\t      wlvif->basic_rate);\n\nout:\n\tdev_kfree_skb(skb);\n\tif (ret)\n\t\twl1271_warning(\"cmd build klv null data failed %d\", ret);\n\n\treturn ret;\n\n}\n\nint wl1271_cmd_build_ps_poll(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t     u16 aid)\n{\n\tstruct ieee80211_vif *vif = wl12xx_wlvif_to_vif(wlvif);\n\tstruct sk_buff *skb;\n\tint ret = 0;\n\n\tskb = ieee80211_pspoll_get(wl->hw, vif);\n\tif (!skb)\n\t\tgoto out;\n\n\tret = wl1271_cmd_template_set(wl, wlvif->role_id,\n\t\t\t\t      CMD_TEMPL_PS_POLL, skb->data,\n\t\t\t\t      skb->len, 0, wlvif->basic_rate_set);\n\nout:\n\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nint wl12xx_cmd_build_probe_req(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t       u8 role_id, u8 band,\n\t\t\t       const u8 *ssid, size_t ssid_len,\n\t\t\t       const u8 *ie0, size_t ie0_len, const u8 *ie1,\n\t\t\t       size_t ie1_len, bool sched_scan)\n{\n\tstruct ieee80211_vif *vif = wl12xx_wlvif_to_vif(wlvif);\n\tstruct sk_buff *skb;\n\tint ret;\n\tu32 rate;\n\tu16 template_id_2_4 = wl->scan_templ_id_2_4;\n\tu16 template_id_5 = wl->scan_templ_id_5;\n\n\twl1271_debug(DEBUG_SCAN, \"build probe request band %d\", band);\n\n\tskb = ieee80211_probereq_get(wl->hw, vif->addr, ssid, ssid_len,\n\t\t\t\t     ie0_len + ie1_len);\n\tif (!skb) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (ie0_len)\n\t\tskb_put_data(skb, ie0, ie0_len);\n\tif (ie1_len)\n\t\tskb_put_data(skb, ie1, ie1_len);\n\n\tif (sched_scan &&\n\t    (wl->quirks & WLCORE_QUIRK_DUAL_PROBE_TMPL)) {\n\t\ttemplate_id_2_4 = wl->sched_scan_templ_id_2_4;\n\t\ttemplate_id_5 = wl->sched_scan_templ_id_5;\n\t}\n\n\trate = wl1271_tx_min_rate_get(wl, wlvif->bitrate_masks[band]);\n\tif (band == NL80211_BAND_2GHZ)\n\t\tret = wl1271_cmd_template_set(wl, role_id,\n\t\t\t\t\t      template_id_2_4,\n\t\t\t\t\t      skb->data, skb->len, 0, rate);\n\telse\n\t\tret = wl1271_cmd_template_set(wl, role_id,\n\t\t\t\t\t      template_id_5,\n\t\t\t\t\t      skb->data, skb->len, 0, rate);\n\nout:\n\tdev_kfree_skb(skb);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wl12xx_cmd_build_probe_req);\n\nstruct sk_buff *wl1271_cmd_build_ap_probe_req(struct wl1271 *wl,\n\t\t\t\t\t      struct wl12xx_vif *wlvif,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ieee80211_vif *vif = wl12xx_wlvif_to_vif(wlvif);\n\tint ret;\n\tu32 rate;\n\n\tif (!skb)\n\t\tskb = ieee80211_ap_probereq_get(wl->hw, vif);\n\tif (!skb)\n\t\tgoto out;\n\n\twl1271_debug(DEBUG_SCAN, \"set ap probe request template\");\n\n\trate = wl1271_tx_min_rate_get(wl, wlvif->bitrate_masks[wlvif->band]);\n\tif (wlvif->band == NL80211_BAND_2GHZ)\n\t\tret = wl1271_cmd_template_set(wl, wlvif->role_id,\n\t\t\t\t\t      CMD_TEMPL_CFG_PROBE_REQ_2_4,\n\t\t\t\t\t      skb->data, skb->len, 0, rate);\n\telse\n\t\tret = wl1271_cmd_template_set(wl, wlvif->role_id,\n\t\t\t\t\t      CMD_TEMPL_CFG_PROBE_REQ_5,\n\t\t\t\t\t      skb->data, skb->len, 0, rate);\n\n\tif (ret < 0)\n\t\twl1271_error(\"Unable to set ap probe request template.\");\n\nout:\n\treturn skb;\n}\n\nint wl1271_cmd_build_arp_rsp(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tint ret, extra = 0;\n\tu16 fc;\n\tstruct ieee80211_vif *vif = wl12xx_wlvif_to_vif(wlvif);\n\tstruct sk_buff *skb;\n\tstruct wl12xx_arp_rsp_template *tmpl;\n\tstruct ieee80211_hdr_3addr *hdr;\n\tstruct arphdr *arp_hdr;\n\n\tskb = dev_alloc_skb(sizeof(*hdr) + sizeof(__le16) + sizeof(*tmpl) +\n\t\t\t    WL1271_EXTRA_SPACE_MAX);\n\tif (!skb) {\n\t\twl1271_error(\"failed to allocate buffer for arp rsp template\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_reserve(skb, sizeof(*hdr) + WL1271_EXTRA_SPACE_MAX);\n\n\ttmpl = skb_put_zero(skb, sizeof(*tmpl));\n\n\t \n\tmemcpy(tmpl->llc_hdr, rfc1042_header, sizeof(rfc1042_header));\n\ttmpl->llc_type = cpu_to_be16(ETH_P_ARP);\n\n\t \n\tarp_hdr = &tmpl->arp_hdr;\n\tarp_hdr->ar_hrd = cpu_to_be16(ARPHRD_ETHER);\n\tarp_hdr->ar_pro = cpu_to_be16(ETH_P_IP);\n\tarp_hdr->ar_hln = ETH_ALEN;\n\tarp_hdr->ar_pln = 4;\n\tarp_hdr->ar_op = cpu_to_be16(ARPOP_REPLY);\n\n\t \n\tmemcpy(tmpl->sender_hw, vif->addr, ETH_ALEN);\n\ttmpl->sender_ip = wlvif->ip_addr;\n\n\t \n\tswitch (wlvif->encryption_type) {\n\tcase KEY_TKIP:\n\t\tif (wl->quirks & WLCORE_QUIRK_TKIP_HEADER_SPACE)\n\t\t\textra = WL1271_EXTRA_SPACE_TKIP;\n\t\tbreak;\n\tcase KEY_AES:\n\t\textra = WL1271_EXTRA_SPACE_AES;\n\t\tbreak;\n\tcase KEY_NONE:\n\tcase KEY_WEP:\n\tcase KEY_GEM:\n\t\textra = 0;\n\t\tbreak;\n\tdefault:\n\t\twl1271_warning(\"Unknown encryption type: %d\",\n\t\t\t       wlvif->encryption_type);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (extra) {\n\t\tu8 *space = skb_push(skb, extra);\n\t\tmemset(space, 0, extra);\n\t}\n\n\t \n\tif (wlvif->sta.qos)\n\t\tmemset(skb_push(skb, sizeof(__le16)), 0, sizeof(__le16));\n\n\t \n\thdr = skb_push(skb, sizeof(*hdr));\n\tmemset(hdr, 0, sizeof(*hdr));\n\tfc = IEEE80211_FTYPE_DATA | IEEE80211_FCTL_TODS;\n\tif (wlvif->sta.qos)\n\t\tfc |= IEEE80211_STYPE_QOS_DATA;\n\telse\n\t\tfc |= IEEE80211_STYPE_DATA;\n\tif (wlvif->encryption_type != KEY_NONE)\n\t\tfc |= IEEE80211_FCTL_PROTECTED;\n\n\thdr->frame_control = cpu_to_le16(fc);\n\tmemcpy(hdr->addr1, vif->bss_conf.bssid, ETH_ALEN);\n\tmemcpy(hdr->addr2, vif->addr, ETH_ALEN);\n\teth_broadcast_addr(hdr->addr3);\n\n\tret = wl1271_cmd_template_set(wl, wlvif->role_id, CMD_TEMPL_ARP_RSP,\n\t\t\t\t      skb->data, skb->len, 0,\n\t\t\t\t      wlvif->basic_rate);\nout:\n\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nint wl1271_build_qos_null_data(struct wl1271 *wl, struct ieee80211_vif *vif)\n{\n\tstruct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);\n\tstruct ieee80211_qos_hdr template;\n\n\tmemset(&template, 0, sizeof(template));\n\n\tmemcpy(template.addr1, vif->bss_conf.bssid, ETH_ALEN);\n\tmemcpy(template.addr2, vif->addr, ETH_ALEN);\n\tmemcpy(template.addr3, vif->bss_conf.bssid, ETH_ALEN);\n\n\ttemplate.frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |\n\t\t\t\t\t     IEEE80211_STYPE_QOS_NULLFUNC |\n\t\t\t\t\t     IEEE80211_FCTL_TODS);\n\n\t \n\ttemplate.qos_ctrl = cpu_to_le16(0);\n\n\treturn wl1271_cmd_template_set(wl, wlvif->role_id,\n\t\t\t\t       CMD_TEMPL_QOS_NULL_DATA, &template,\n\t\t\t\t       sizeof(template), 0,\n\t\t\t\t       wlvif->basic_rate);\n}\n\nint wl12xx_cmd_set_default_wep_key(struct wl1271 *wl, u8 id, u8 hlid)\n{\n\tstruct wl1271_cmd_set_keys *cmd;\n\tint ret = 0;\n\n\twl1271_debug(DEBUG_CMD, \"cmd set_default_wep_key %d\", id);\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcmd->hlid = hlid;\n\tcmd->key_id = id;\n\tcmd->lid_key_type = WEP_DEFAULT_LID_TYPE;\n\tcmd->key_action = cpu_to_le16(KEY_SET_ID);\n\tcmd->key_type = KEY_WEP;\n\n\tret = wl1271_cmd_send(wl, CMD_SET_KEYS, cmd, sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_warning(\"cmd set_default_wep_key failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(cmd);\n\n\treturn ret;\n}\n\nint wl1271_cmd_set_sta_key(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t       u16 action, u8 id, u8 key_type,\n\t\t       u8 key_size, const u8 *key, const u8 *addr,\n\t\t       u32 tx_seq_32, u16 tx_seq_16)\n{\n\tstruct wl1271_cmd_set_keys *cmd;\n\tint ret = 0;\n\n\t \n\tif (wlvif->sta.hlid == WL12XX_INVALID_LINK_ID)\n\t\treturn 0;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcmd->hlid = wlvif->sta.hlid;\n\n\tif (key_type == KEY_WEP)\n\t\tcmd->lid_key_type = WEP_DEFAULT_LID_TYPE;\n\telse if (is_broadcast_ether_addr(addr))\n\t\tcmd->lid_key_type = BROADCAST_LID_TYPE;\n\telse\n\t\tcmd->lid_key_type = UNICAST_LID_TYPE;\n\n\tcmd->key_action = cpu_to_le16(action);\n\tcmd->key_size = key_size;\n\tcmd->key_type = key_type;\n\n\tcmd->ac_seq_num16[0] = cpu_to_le16(tx_seq_16);\n\tcmd->ac_seq_num32[0] = cpu_to_le32(tx_seq_32);\n\n\tcmd->key_id = id;\n\n\tif (key_type == KEY_TKIP) {\n\t\t \n\t\tmemcpy(cmd->key, key, 16);\n\t\tmemcpy(cmd->key + 16, key + 24, 8);\n\t\tmemcpy(cmd->key + 24, key + 16, 8);\n\n\t} else {\n\t\tmemcpy(cmd->key, key, key_size);\n\t}\n\n\twl1271_dump(DEBUG_CRYPT, \"TARGET KEY: \", cmd, sizeof(*cmd));\n\n\tret = wl1271_cmd_send(wl, CMD_SET_KEYS, cmd, sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_warning(\"could not set keys\");\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(cmd);\n\n\treturn ret;\n}\n\n \nint wl1271_cmd_set_ap_key(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t  u16 action, u8 id, u8 key_type,\n\t\t\t  u8 key_size, const u8 *key, u8 hlid, u32 tx_seq_32,\n\t\t\t  u16 tx_seq_16, bool is_pairwise)\n{\n\tstruct wl1271_cmd_set_keys *cmd;\n\tint ret = 0;\n\tu8 lid_type;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tif (hlid == wlvif->ap.bcast_hlid) {\n\t\tif (key_type == KEY_WEP)\n\t\t\tlid_type = WEP_DEFAULT_LID_TYPE;\n\t\telse\n\t\t\tlid_type = BROADCAST_LID_TYPE;\n\t} else if (is_pairwise) {\n\t\tlid_type = UNICAST_LID_TYPE;\n\t} else {\n\t\tlid_type = BROADCAST_LID_TYPE;\n\t}\n\n\twl1271_debug(DEBUG_CRYPT, \"ap key action: %d id: %d lid: %d type: %d\"\n\t\t     \" hlid: %d\", (int)action, (int)id, (int)lid_type,\n\t\t     (int)key_type, (int)hlid);\n\n\tcmd->lid_key_type = lid_type;\n\tcmd->hlid = hlid;\n\tcmd->key_action = cpu_to_le16(action);\n\tcmd->key_size = key_size;\n\tcmd->key_type = key_type;\n\tcmd->key_id = id;\n\tcmd->ac_seq_num16[0] = cpu_to_le16(tx_seq_16);\n\tcmd->ac_seq_num32[0] = cpu_to_le32(tx_seq_32);\n\n\tif (key_type == KEY_TKIP) {\n\t\t \n\t\tmemcpy(cmd->key, key, 16);\n\t\tmemcpy(cmd->key + 16, key + 24, 8);\n\t\tmemcpy(cmd->key + 24, key + 16, 8);\n\t} else {\n\t\tmemcpy(cmd->key, key, key_size);\n\t}\n\n\twl1271_dump(DEBUG_CRYPT, \"TARGET AP KEY: \", cmd, sizeof(*cmd));\n\n\tret = wl1271_cmd_send(wl, CMD_SET_KEYS, cmd, sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_warning(\"could not set ap keys\");\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(cmd);\n\treturn ret;\n}\n\nint wl12xx_cmd_set_peer_state(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t      u8 hlid)\n{\n\tstruct wl12xx_cmd_set_peer_state *cmd;\n\tint ret = 0;\n\n\twl1271_debug(DEBUG_CMD, \"cmd set peer state (hlid=%d)\", hlid);\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcmd->hlid = hlid;\n\tcmd->state = WL1271_CMD_STA_STATE_CONNECTED;\n\n\t \n\tif (wlvif->bss_type == BSS_TYPE_STA_BSS)\n\t\tcmd->wmm = wlvif->wmm_enabled;\n\n\tret = wl1271_cmd_send(wl, CMD_SET_PEER_STATE, cmd, sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_error(\"failed to send set peer state command\");\n\t\tgoto out_free;\n\t}\n\nout_free:\n\tkfree(cmd);\n\nout:\n\treturn ret;\n}\n\nint wl12xx_cmd_add_peer(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\tstruct ieee80211_sta *sta, u8 hlid)\n{\n\tstruct wl12xx_cmd_add_peer *cmd;\n\tint i, ret;\n\tu32 sta_rates;\n\n\twl1271_debug(DEBUG_CMD, \"cmd add peer %d\", (int)hlid);\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemcpy(cmd->addr, sta->addr, ETH_ALEN);\n\tcmd->bss_index = WL1271_AP_BSS_INDEX;\n\tcmd->aid = sta->aid;\n\tcmd->hlid = hlid;\n\tcmd->sp_len = sta->max_sp;\n\tcmd->wmm = sta->wme ? 1 : 0;\n\tcmd->session_id = wl->session_ids[hlid];\n\tcmd->role_id = wlvif->role_id;\n\n\tfor (i = 0; i < NUM_ACCESS_CATEGORIES_COPY; i++)\n\t\tif (sta->wme && (sta->uapsd_queues & BIT(i)))\n\t\t\tcmd->psd_type[NUM_ACCESS_CATEGORIES_COPY-1-i] =\n\t\t\t\t\tWL1271_PSD_UPSD_TRIGGER;\n\t\telse\n\t\t\tcmd->psd_type[NUM_ACCESS_CATEGORIES_COPY-1-i] =\n\t\t\t\t\tWL1271_PSD_LEGACY;\n\n\n\tsta_rates = sta->deflink.supp_rates[wlvif->band];\n\tif (sta->deflink.ht_cap.ht_supported)\n\t\tsta_rates |=\n\t\t\t(sta->deflink.ht_cap.mcs.rx_mask[0] << HW_HT_RATES_OFFSET) |\n\t\t\t(sta->deflink.ht_cap.mcs.rx_mask[1] << HW_MIMO_RATES_OFFSET);\n\n\tcmd->supported_rates =\n\t\tcpu_to_le32(wl1271_tx_enabled_rates_get(wl, sta_rates,\n\t\t\t\t\t\t\twlvif->band));\n\n\tif (!cmd->supported_rates) {\n\t\twl1271_debug(DEBUG_CMD,\n\t\t\t     \"peer has no supported rates yet, configuring basic rates: 0x%x\",\n\t\t\t     wlvif->basic_rate_set);\n\t\tcmd->supported_rates = cpu_to_le32(wlvif->basic_rate_set);\n\t}\n\n\twl1271_debug(DEBUG_CMD, \"new peer rates=0x%x queues=0x%x\",\n\t\t     cmd->supported_rates, sta->uapsd_queues);\n\n\tret = wl1271_cmd_send(wl, CMD_ADD_PEER, cmd, sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_error(\"failed to initiate cmd add peer\");\n\t\tgoto out_free;\n\t}\n\nout_free:\n\tkfree(cmd);\n\nout:\n\treturn ret;\n}\n\nint wl12xx_cmd_remove_peer(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t   u8 hlid)\n{\n\tstruct wl12xx_cmd_remove_peer *cmd;\n\tint ret;\n\tbool timeout = false;\n\n\twl1271_debug(DEBUG_CMD, \"cmd remove peer %d\", (int)hlid);\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcmd->hlid = hlid;\n\t \n\tcmd->reason_opcode = 0;\n\tcmd->send_deauth_flag = 0;\n\tcmd->role_id = wlvif->role_id;\n\n\tret = wl1271_cmd_send(wl, CMD_REMOVE_PEER, cmd, sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_error(\"failed to initiate cmd remove peer\");\n\t\tgoto out_free;\n\t}\n\n\tret = wl->ops->wait_for_event(wl,\n\t\t\t\t      WLCORE_EVENT_PEER_REMOVE_COMPLETE,\n\t\t\t\t      &timeout);\n\n\t \n\tif (ret)\n\t\twl12xx_queue_recovery_work(wl);\n\nout_free:\n\tkfree(cmd);\n\nout:\n\treturn ret;\n}\n\nstatic int wlcore_get_reg_conf_ch_idx(enum nl80211_band band, u16 ch)\n{\n\t \n\tswitch (band) {\n\tcase NL80211_BAND_2GHZ:\n\t\t \n\t\tif (ch >= 1 && ch <= 14)\n\t\t\treturn ch - 1;\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\tswitch (ch) {\n\t\tcase 8 ... 16:\n\t\t\t \n\t\t\treturn 18 + (ch-8)/4;\n\t\tcase 34 ... 48:\n\t\t\t \n\t\t\treturn 21 + (ch-34)/2;\n\t\tcase 52 ... 64:\n\t\t\t \n\t\t\treturn 29 + (ch-52)/4;\n\t\tcase 100 ... 140:\n\t\t\t \n\t\t\treturn 33 + (ch-100)/4;\n\t\tcase 149 ... 165:\n\t\t\t \n\t\t\treturn 44 + (ch-149)/4;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\twl1271_error(\"%s: unknown band/channel: %d/%d\", __func__, band, ch);\n\treturn -1;\n}\n\nvoid wlcore_set_pending_regdomain_ch(struct wl1271 *wl, u16 channel,\n\t\t\t\t     enum nl80211_band band)\n{\n\tint ch_bit_idx = 0;\n\n\tif (!(wl->quirks & WLCORE_QUIRK_REGDOMAIN_CONF))\n\t\treturn;\n\n\tch_bit_idx = wlcore_get_reg_conf_ch_idx(band, channel);\n\n\tif (ch_bit_idx >= 0 && ch_bit_idx <= WL1271_MAX_CHANNELS)\n\t\t__set_bit_le(ch_bit_idx, (long *)wl->reg_ch_conf_pending);\n}\n\nint wlcore_cmd_regdomain_config_locked(struct wl1271 *wl)\n{\n\tstruct wl12xx_cmd_regdomain_dfs_config *cmd = NULL;\n\tint ret = 0, i, b, ch_bit_idx;\n\t__le32 tmp_ch_bitmap[2] __aligned(sizeof(unsigned long));\n\tstruct wiphy *wiphy = wl->hw->wiphy;\n\tstruct ieee80211_supported_band *band;\n\tbool timeout = false;\n\n\tif (!(wl->quirks & WLCORE_QUIRK_REGDOMAIN_CONF))\n\t\treturn 0;\n\n\twl1271_debug(DEBUG_CMD, \"cmd reg domain config\");\n\n\tmemcpy(tmp_ch_bitmap, wl->reg_ch_conf_pending, sizeof(tmp_ch_bitmap));\n\n\tfor (b = NL80211_BAND_2GHZ; b <= NL80211_BAND_5GHZ; b++) {\n\t\tband = wiphy->bands[b];\n\t\tfor (i = 0; i < band->n_channels; i++) {\n\t\t\tstruct ieee80211_channel *channel = &band->channels[i];\n\t\t\tu16 ch = channel->hw_value;\n\t\t\tu32 flags = channel->flags;\n\n\t\t\tif (flags & (IEEE80211_CHAN_DISABLED |\n\t\t\t\t     IEEE80211_CHAN_NO_IR))\n\t\t\t\tcontinue;\n\n\t\t\tif ((flags & IEEE80211_CHAN_RADAR) &&\n\t\t\t    channel->dfs_state != NL80211_DFS_AVAILABLE)\n\t\t\t\tcontinue;\n\n\t\t\tch_bit_idx = wlcore_get_reg_conf_ch_idx(b, ch);\n\t\t\tif (ch_bit_idx < 0)\n\t\t\t\tcontinue;\n\n\t\t\t__set_bit_le(ch_bit_idx, (long *)tmp_ch_bitmap);\n\t\t}\n\t}\n\n\tif (!memcmp(tmp_ch_bitmap, wl->reg_ch_conf_last, sizeof(tmp_ch_bitmap)))\n\t\tgoto out;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcmd->ch_bit_map1 = tmp_ch_bitmap[0];\n\tcmd->ch_bit_map2 = tmp_ch_bitmap[1];\n\tcmd->dfs_region = wl->dfs_region;\n\n\twl1271_debug(DEBUG_CMD,\n\t\t     \"cmd reg domain bitmap1: 0x%08x, bitmap2: 0x%08x\",\n\t\t     cmd->ch_bit_map1, cmd->ch_bit_map2);\n\n\tret = wl1271_cmd_send(wl, CMD_DFS_CHANNEL_CONFIG, cmd, sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_error(\"failed to send reg domain dfs config\");\n\t\tgoto out;\n\t}\n\n\tret = wl->ops->wait_for_event(wl,\n\t\t\t\t      WLCORE_EVENT_DFS_CONFIG_COMPLETE,\n\t\t\t\t      &timeout);\n\tif (ret < 0 || timeout) {\n\t\twl1271_error(\"reg domain conf %serror\",\n\t\t\t     timeout ? \"completion \" : \"\");\n\t\tret = timeout ? -ETIMEDOUT : ret;\n\t\tgoto out;\n\t}\n\n\tmemcpy(wl->reg_ch_conf_last, tmp_ch_bitmap, sizeof(tmp_ch_bitmap));\n\tmemset(wl->reg_ch_conf_pending, 0, sizeof(wl->reg_ch_conf_pending));\n\nout:\n\tkfree(cmd);\n\treturn ret;\n}\n\nint wl12xx_cmd_config_fwlog(struct wl1271 *wl)\n{\n\tstruct wl12xx_cmd_config_fwlog *cmd;\n\tint ret = 0;\n\n\twl1271_debug(DEBUG_CMD, \"cmd config firmware logger\");\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcmd->logger_mode = wl->conf.fwlog.mode;\n\tcmd->log_severity = wl->conf.fwlog.severity;\n\tcmd->timestamp = wl->conf.fwlog.timestamp;\n\tcmd->output = wl->conf.fwlog.output;\n\tcmd->threshold = wl->conf.fwlog.threshold;\n\n\tret = wl1271_cmd_send(wl, CMD_CONFIG_FWLOGGER, cmd, sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_error(\"failed to send config firmware logger command\");\n\t\tgoto out_free;\n\t}\n\nout_free:\n\tkfree(cmd);\n\nout:\n\treturn ret;\n}\n\nint wl12xx_cmd_start_fwlog(struct wl1271 *wl)\n{\n\tstruct wl12xx_cmd_start_fwlog *cmd;\n\tint ret = 0;\n\n\twl1271_debug(DEBUG_CMD, \"cmd start firmware logger\");\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = wl1271_cmd_send(wl, CMD_START_FWLOGGER, cmd, sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_error(\"failed to send start firmware logger command\");\n\t\tgoto out_free;\n\t}\n\nout_free:\n\tkfree(cmd);\n\nout:\n\treturn ret;\n}\n\nint wl12xx_cmd_stop_fwlog(struct wl1271 *wl)\n{\n\tstruct wl12xx_cmd_stop_fwlog *cmd;\n\tint ret = 0;\n\n\twl1271_debug(DEBUG_CMD, \"cmd stop firmware logger\");\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = wl1271_cmd_send(wl, CMD_STOP_FWLOGGER, cmd, sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_error(\"failed to send stop firmware logger command\");\n\t\tgoto out_free;\n\t}\n\nout_free:\n\tkfree(cmd);\n\nout:\n\treturn ret;\n}\n\nstatic int wl12xx_cmd_roc(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t  u8 role_id, enum nl80211_band band, u8 channel)\n{\n\tstruct wl12xx_cmd_roc *cmd;\n\tint ret = 0;\n\n\twl1271_debug(DEBUG_CMD, \"cmd roc %d (%d)\", channel, role_id);\n\n\tif (WARN_ON(role_id == WL12XX_INVALID_ROLE_ID))\n\t\treturn -EINVAL;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcmd->role_id = role_id;\n\tcmd->channel = channel;\n\tswitch (band) {\n\tcase NL80211_BAND_2GHZ:\n\t\tcmd->band = WLCORE_BAND_2_4GHZ;\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\tcmd->band = WLCORE_BAND_5GHZ;\n\t\tbreak;\n\tdefault:\n\t\twl1271_error(\"roc - unknown band: %d\", (int)wlvif->band);\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\n\tret = wl1271_cmd_send(wl, CMD_REMAIN_ON_CHANNEL, cmd, sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_error(\"failed to send ROC command\");\n\t\tgoto out_free;\n\t}\n\nout_free:\n\tkfree(cmd);\n\nout:\n\treturn ret;\n}\n\nstatic int wl12xx_cmd_croc(struct wl1271 *wl, u8 role_id)\n{\n\tstruct wl12xx_cmd_croc *cmd;\n\tint ret = 0;\n\n\twl1271_debug(DEBUG_CMD, \"cmd croc (%d)\", role_id);\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tcmd->role_id = role_id;\n\n\tret = wl1271_cmd_send(wl, CMD_CANCEL_REMAIN_ON_CHANNEL, cmd,\n\t\t\t      sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_error(\"failed to send ROC command\");\n\t\tgoto out_free;\n\t}\n\nout_free:\n\tkfree(cmd);\n\nout:\n\treturn ret;\n}\n\nint wl12xx_roc(struct wl1271 *wl, struct wl12xx_vif *wlvif, u8 role_id,\n\t       enum nl80211_band band, u8 channel)\n{\n\tint ret = 0;\n\n\tif (WARN_ON(test_bit(role_id, wl->roc_map)))\n\t\treturn 0;\n\n\tret = wl12xx_cmd_roc(wl, wlvif, role_id, band, channel);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t__set_bit(role_id, wl->roc_map);\nout:\n\treturn ret;\n}\n\nint wl12xx_croc(struct wl1271 *wl, u8 role_id)\n{\n\tint ret = 0;\n\n\tif (WARN_ON(!test_bit(role_id, wl->roc_map)))\n\t\treturn 0;\n\n\tret = wl12xx_cmd_croc(wl, role_id);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t__clear_bit(role_id, wl->roc_map);\n\n\t \n\tif (find_first_bit(wl->roc_map, WL12XX_MAX_ROLES) >= WL12XX_MAX_ROLES)\n\t\twl12xx_rearm_tx_watchdog_locked(wl);\nout:\n\treturn ret;\n}\n\nint wl12xx_cmd_stop_channel_switch(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tstruct wl12xx_cmd_stop_channel_switch *cmd;\n\tint ret;\n\n\twl1271_debug(DEBUG_ACX, \"cmd stop channel switch\");\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcmd->role_id = wlvif->role_id;\n\n\tret = wl1271_cmd_send(wl, CMD_STOP_CHANNEL_SWICTH, cmd, sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_error(\"failed to stop channel switch command\");\n\t\tgoto out_free;\n\t}\n\nout_free:\n\tkfree(cmd);\n\nout:\n\treturn ret;\n}\n\n \nint wl12xx_start_dev(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t     enum nl80211_band band, int channel)\n{\n\tint ret;\n\n\tif (WARN_ON(!(wlvif->bss_type == BSS_TYPE_STA_BSS ||\n\t\t      wlvif->bss_type == BSS_TYPE_IBSS)))\n\t\treturn -EINVAL;\n\n\t \n\tif (!wlcore_is_p2p_mgmt(wlvif)) {\n\t\tret = wl12xx_cmd_role_enable(wl,\n\t\t\t\t\t     wl12xx_wlvif_to_vif(wlvif)->addr,\n\t\t\t\t\t     WL1271_ROLE_DEVICE,\n\t\t\t\t\t     &wlvif->dev_role_id);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = wl12xx_cmd_role_start_dev(wl, wlvif, band, channel);\n\tif (ret < 0)\n\t\tgoto out_disable;\n\n\tret = wl12xx_roc(wl, wlvif, wlvif->dev_role_id, band, channel);\n\tif (ret < 0)\n\t\tgoto out_stop;\n\n\treturn 0;\n\nout_stop:\n\twl12xx_cmd_role_stop_dev(wl, wlvif);\nout_disable:\n\tif (!wlcore_is_p2p_mgmt(wlvif))\n\t\twl12xx_cmd_role_disable(wl, &wlvif->dev_role_id);\nout:\n\treturn ret;\n}\n\n \nint wl12xx_stop_dev(struct wl1271 *wl, struct wl12xx_vif *wlvif)\n{\n\tint ret;\n\n\tif (WARN_ON(!(wlvif->bss_type == BSS_TYPE_STA_BSS ||\n\t\t      wlvif->bss_type == BSS_TYPE_IBSS)))\n\t\treturn -EINVAL;\n\n\t \n\tret = wlcore_tx_work_locked(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (test_bit(wlvif->dev_role_id, wl->roc_map)) {\n\t\tret = wl12xx_croc(wl, wlvif->dev_role_id);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = wl12xx_cmd_role_stop_dev(wl, wlvif);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!wlcore_is_p2p_mgmt(wlvif)) {\n\t\tret = wl12xx_cmd_role_disable(wl, &wlvif->dev_role_id);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n}\n\nint wlcore_cmd_generic_cfg(struct wl1271 *wl, struct wl12xx_vif *wlvif,\n\t\t\t   u8 feature, u8 enable, u8 value)\n{\n\tstruct wlcore_cmd_generic_cfg *cmd;\n\tint ret;\n\n\twl1271_debug(DEBUG_CMD,\n\t\t     \"cmd generic cfg (role %d feature %d enable %d value %d)\",\n\t\t     wlvif->role_id, feature, enable, value);\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->role_id = wlvif->role_id;\n\tcmd->feature = feature;\n\tcmd->enable = enable;\n\tcmd->value = value;\n\n\tret = wl1271_cmd_send(wl, CMD_GENERIC_CFG, cmd, sizeof(*cmd), 0);\n\tif (ret < 0) {\n\t\twl1271_error(\"failed to send generic cfg command\");\n\t\tgoto out_free;\n\t}\nout_free:\n\tkfree(cmd);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wlcore_cmd_generic_cfg);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}