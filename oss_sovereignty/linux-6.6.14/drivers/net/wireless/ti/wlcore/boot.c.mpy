{
  "module_name": "boot.c",
  "hash_id": "dc139558e3b7262215c9aae088d711c1e00dea1c582d6333f32003f54bfa1aed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wlcore/boot.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/export.h>\n\n#include \"debug.h\"\n#include \"acx.h\"\n#include \"boot.h\"\n#include \"io.h\"\n#include \"event.h\"\n#include \"rx.h\"\n#include \"hw_ops.h\"\n\nstatic int wl1271_boot_set_ecpu_ctrl(struct wl1271 *wl, u32 flag)\n{\n\tu32 cpu_ctrl;\n\tint ret;\n\n\t \n\tret = wlcore_read_reg(wl, REG_ECPU_CONTROL, &cpu_ctrl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tcpu_ctrl |= flag;\n\tret = wlcore_write_reg(wl, REG_ECPU_CONTROL, cpu_ctrl);\n\nout:\n\treturn ret;\n}\n\nstatic int wlcore_boot_parse_fw_ver(struct wl1271 *wl,\n\t\t\t\t    struct wl1271_static_data *static_data)\n{\n\tint ret;\n\n\tstrncpy(wl->chip.fw_ver_str, static_data->fw_version,\n\t\tsizeof(wl->chip.fw_ver_str));\n\n\t \n\twl->chip.fw_ver_str[sizeof(wl->chip.fw_ver_str) - 1] = '\\0';\n\n\tret = sscanf(wl->chip.fw_ver_str + 4, \"%u.%u.%u.%u.%u\",\n\t\t     &wl->chip.fw_ver[0], &wl->chip.fw_ver[1],\n\t\t     &wl->chip.fw_ver[2], &wl->chip.fw_ver[3],\n\t\t     &wl->chip.fw_ver[4]);\n\n\tif (ret != 5) {\n\t\twl1271_warning(\"fw version incorrect value\");\n\t\tmemset(wl->chip.fw_ver, 0, sizeof(wl->chip.fw_ver));\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = wlcore_identify_fw(wl);\n\tif (ret < 0)\n\t\tgoto out;\nout:\n\treturn ret;\n}\n\nstatic int wlcore_validate_fw_ver(struct wl1271 *wl)\n{\n\tunsigned int *fw_ver = wl->chip.fw_ver;\n\tunsigned int *min_ver = (wl->fw_type == WL12XX_FW_TYPE_MULTI) ?\n\t\twl->min_mr_fw_ver : wl->min_sr_fw_ver;\n\tchar min_fw_str[32] = \"\";\n\tint off = 0;\n\tint i;\n\n\t \n\tif ((min_ver[FW_VER_CHIP] != WLCORE_FW_VER_IGNORE) &&\n\t    (min_ver[FW_VER_CHIP] != fw_ver[FW_VER_CHIP]))\n\t\tgoto fail;\n\n\t \n\tif ((min_ver[FW_VER_IF_TYPE] != WLCORE_FW_VER_IGNORE) &&\n\t    (min_ver[FW_VER_IF_TYPE] != fw_ver[FW_VER_IF_TYPE]))\n\t\tgoto fail;\n\n\t \n\tif ((min_ver[FW_VER_SUBTYPE] != WLCORE_FW_VER_IGNORE) &&\n\t    (min_ver[FW_VER_SUBTYPE] != fw_ver[FW_VER_SUBTYPE]))\n\t\tgoto fail;\n\n\t \n\tif ((min_ver[FW_VER_MAJOR] != WLCORE_FW_VER_IGNORE) &&\n\t\t (min_ver[FW_VER_MAJOR] > fw_ver[FW_VER_MAJOR]))\n\t\tgoto fail;\n\n\t \n\tif (((min_ver[FW_VER_MAJOR] == WLCORE_FW_VER_IGNORE) ||\n\t     (min_ver[FW_VER_MAJOR] == fw_ver[FW_VER_MAJOR])) &&\n\t     \n\t    ((min_ver[FW_VER_MINOR] != WLCORE_FW_VER_IGNORE) &&\n\t     (min_ver[FW_VER_MINOR] > fw_ver[FW_VER_MINOR])))\n\t\tgoto fail;\n\n\treturn 0;\n\nfail:\n\tfor (i = 0; i < NUM_FW_VER && off < sizeof(min_fw_str); i++)\n\t\tif (min_ver[i] == WLCORE_FW_VER_IGNORE)\n\t\t\toff += snprintf(min_fw_str + off,\n\t\t\t\t\tsizeof(min_fw_str) - off,\n\t\t\t\t\t\"*.\");\n\t\telse\n\t\t\toff += snprintf(min_fw_str + off,\n\t\t\t\t\tsizeof(min_fw_str) - off,\n\t\t\t\t\t\"%u.\", min_ver[i]);\n\n\twl1271_error(\"Your WiFi FW version (%u.%u.%u.%u.%u) is invalid.\\n\"\n\t\t     \"Please use at least FW %s\\n\"\n\t\t     \"You can get the latest firmwares at:\\n\"\n\t\t     \"git://git.ti.com/wilink8-wlan/wl18xx_fw.git\",\n\t\t     fw_ver[FW_VER_CHIP], fw_ver[FW_VER_IF_TYPE],\n\t\t     fw_ver[FW_VER_MAJOR], fw_ver[FW_VER_SUBTYPE],\n\t\t     fw_ver[FW_VER_MINOR], min_fw_str);\n\treturn -EINVAL;\n}\n\nstatic int wlcore_boot_static_data(struct wl1271 *wl)\n{\n\tstruct wl1271_static_data *static_data;\n\tsize_t len = sizeof(*static_data) + wl->static_data_priv_len;\n\tint ret;\n\n\tstatic_data = kmalloc(len, GFP_KERNEL);\n\tif (!static_data) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = wlcore_read(wl, wl->cmd_box_addr, static_data, len, false);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n\tret = wlcore_boot_parse_fw_ver(wl, static_data);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n\tret = wlcore_validate_fw_ver(wl);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n\tret = wlcore_handle_static_data(wl, static_data);\n\tif (ret < 0)\n\t\tgoto out_free;\n\nout_free:\n\tkfree(static_data);\nout:\n\treturn ret;\n}\n\nstatic int wl1271_boot_upload_firmware_chunk(struct wl1271 *wl, void *buf,\n\t\t\t\t\t     size_t fw_data_len, u32 dest)\n{\n\tstruct wlcore_partition_set partition;\n\tint addr, chunk_num, partition_limit;\n\tu8 *p, *chunk;\n\tint ret;\n\n\t \n\n\twl1271_debug(DEBUG_BOOT, \"starting firmware upload\");\n\n\twl1271_debug(DEBUG_BOOT, \"fw_data_len %zd chunk_size %d\",\n\t\t     fw_data_len, CHUNK_SIZE);\n\n\tif ((fw_data_len % 4) != 0) {\n\t\twl1271_error(\"firmware length not multiple of four\");\n\t\treturn -EIO;\n\t}\n\n\tchunk = kmalloc(CHUNK_SIZE, GFP_KERNEL);\n\tif (!chunk) {\n\t\twl1271_error(\"allocation for firmware upload chunk failed\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(&partition, &wl->ptable[PART_DOWN], sizeof(partition));\n\tpartition.mem.start = dest;\n\tret = wlcore_set_partition(wl, &partition);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tchunk_num = 0;\n\tpartition_limit = wl->ptable[PART_DOWN].mem.size;\n\n\twhile (chunk_num < fw_data_len / CHUNK_SIZE) {\n\t\t \n\t\taddr = dest + (chunk_num + 2) * CHUNK_SIZE;\n\t\tif (addr > partition_limit) {\n\t\t\taddr = dest + chunk_num * CHUNK_SIZE;\n\t\t\tpartition_limit = chunk_num * CHUNK_SIZE +\n\t\t\t\twl->ptable[PART_DOWN].mem.size;\n\t\t\tpartition.mem.start = addr;\n\t\t\tret = wlcore_set_partition(wl, &partition);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\taddr = dest + chunk_num * CHUNK_SIZE;\n\t\tp = buf + chunk_num * CHUNK_SIZE;\n\t\tmemcpy(chunk, p, CHUNK_SIZE);\n\t\twl1271_debug(DEBUG_BOOT, \"uploading fw chunk 0x%p to 0x%x\",\n\t\t\t     p, addr);\n\t\tret = wlcore_write(wl, addr, chunk, CHUNK_SIZE, false);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tchunk_num++;\n\t}\n\n\t \n\taddr = dest + chunk_num * CHUNK_SIZE;\n\tp = buf + chunk_num * CHUNK_SIZE;\n\tmemcpy(chunk, p, fw_data_len % CHUNK_SIZE);\n\twl1271_debug(DEBUG_BOOT, \"uploading fw last chunk (%zd B) 0x%p to 0x%x\",\n\t\t     fw_data_len % CHUNK_SIZE, p, addr);\n\tret = wlcore_write(wl, addr, chunk, fw_data_len % CHUNK_SIZE, false);\n\nout:\n\tkfree(chunk);\n\treturn ret;\n}\n\nint wlcore_boot_upload_firmware(struct wl1271 *wl)\n{\n\tu32 chunks, addr, len;\n\tint ret = 0;\n\tu8 *fw;\n\n\tfw = wl->fw;\n\tchunks = be32_to_cpup((__be32 *) fw);\n\tfw += sizeof(u32);\n\n\twl1271_debug(DEBUG_BOOT, \"firmware chunks to be uploaded: %u\", chunks);\n\n\twhile (chunks--) {\n\t\taddr = be32_to_cpup((__be32 *) fw);\n\t\tfw += sizeof(u32);\n\t\tlen = be32_to_cpup((__be32 *) fw);\n\t\tfw += sizeof(u32);\n\n\t\tif (len > 300000) {\n\t\t\twl1271_info(\"firmware chunk too long: %u\", len);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\twl1271_debug(DEBUG_BOOT, \"chunk %d addr 0x%x len %u\",\n\t\t\t     chunks, addr, len);\n\t\tret = wl1271_boot_upload_firmware_chunk(wl, fw, len, addr);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\tfw += len;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wlcore_boot_upload_firmware);\n\nint wlcore_boot_upload_nvs(struct wl1271 *wl)\n{\n\tstruct platform_device *pdev = wl->pdev;\n\tstruct wlcore_platdev_data *pdev_data = dev_get_platdata(&pdev->dev);\n\tconst char *nvs_name = \"unknown\";\n\tsize_t nvs_len, burst_len;\n\tint i;\n\tu32 dest_addr, val;\n\tu8 *nvs_ptr, *nvs_aligned;\n\tint ret;\n\n\tif (wl->nvs == NULL) {\n\t\twl1271_error(\"NVS file is needed during boot\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (pdev_data && pdev_data->family)\n\t\tnvs_name = pdev_data->family->nvs_name;\n\n\tif (wl->quirks & WLCORE_QUIRK_LEGACY_NVS) {\n\t\tstruct wl1271_nvs_file *nvs =\n\t\t\t(struct wl1271_nvs_file *)wl->nvs;\n\t\t \n\t\tif (wl->nvs_len == sizeof(struct wl1271_nvs_file) ||\n\t\t    wl->nvs_len == WL1271_INI_LEGACY_NVS_FILE_SIZE) {\n\t\t\tif (nvs->general_params.dual_mode_select)\n\t\t\t\twl->enable_11a = true;\n\t\t}\n\n\t\tif (wl->nvs_len != sizeof(struct wl1271_nvs_file) &&\n\t\t    (wl->nvs_len != WL1271_INI_LEGACY_NVS_FILE_SIZE ||\n\t\t     wl->enable_11a)) {\n\t\t\twl1271_error(\"%s size is not as expected: %zu != %zu\",\n\t\t\t\t     nvs_name, wl->nvs_len,\n\t\t\t\t     sizeof(struct wl1271_nvs_file));\n\t\t\tkfree(wl->nvs);\n\t\t\twl->nvs = NULL;\n\t\t\twl->nvs_len = 0;\n\t\t\treturn -EILSEQ;\n\t\t}\n\n\t\t \n\t\tnvs_len = sizeof(nvs->nvs);\n\t\tnvs_ptr = (u8 *) nvs->nvs;\n\t} else {\n\t\tstruct wl128x_nvs_file *nvs = (struct wl128x_nvs_file *)wl->nvs;\n\n\t\tif (wl->nvs_len == sizeof(struct wl128x_nvs_file)) {\n\t\t\tif (nvs->general_params.dual_mode_select)\n\t\t\t\twl->enable_11a = true;\n\t\t} else {\n\t\t\twl1271_error(\"%s size is not as expected: %zu != %zu\",\n\t\t\t\t     nvs_name, wl->nvs_len,\n\t\t\t\t     sizeof(struct wl128x_nvs_file));\n\t\t\tkfree(wl->nvs);\n\t\t\twl->nvs = NULL;\n\t\t\twl->nvs_len = 0;\n\t\t\treturn -EILSEQ;\n\t\t}\n\n\t\t \n\t\tnvs_len = sizeof(nvs->nvs);\n\t\tnvs_ptr = (u8 *)nvs->nvs;\n\t}\n\n\t \n\tnvs_ptr[11] = wl->addresses[0].addr[0];\n\tnvs_ptr[10] = wl->addresses[0].addr[1];\n\tnvs_ptr[6] = wl->addresses[0].addr[2];\n\tnvs_ptr[5] = wl->addresses[0].addr[3];\n\tnvs_ptr[4] = wl->addresses[0].addr[4];\n\tnvs_ptr[3] = wl->addresses[0].addr[5];\n\n\t \n\n\t \n\twhile (nvs_ptr[0]) {\n\t\tburst_len = nvs_ptr[0];\n\t\tdest_addr = (nvs_ptr[1] & 0xfe) | ((u32)(nvs_ptr[2] << 8));\n\n\t\t \n\t\tdest_addr += wl->curr_part.reg.start;\n\n\t\t \n\t\tnvs_ptr += 3;\n\n\t\tfor (i = 0; i < burst_len; i++) {\n\t\t\tif (nvs_ptr + 3 >= (u8 *) wl->nvs + nvs_len)\n\t\t\t\tgoto out_badnvs;\n\n\t\t\tval = (nvs_ptr[0] | (nvs_ptr[1] << 8)\n\t\t\t       | (nvs_ptr[2] << 16) | (nvs_ptr[3] << 24));\n\n\t\t\twl1271_debug(DEBUG_BOOT,\n\t\t\t\t     \"nvs burst write 0x%x: 0x%x\",\n\t\t\t\t     dest_addr, val);\n\t\t\tret = wlcore_write32(wl, dest_addr, val);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tnvs_ptr += 4;\n\t\t\tdest_addr += 4;\n\t\t}\n\n\t\tif (nvs_ptr >= (u8 *) wl->nvs + nvs_len)\n\t\t\tgoto out_badnvs;\n\t}\n\n\t \n\tnvs_ptr = (u8 *)wl->nvs +\n\t\t\tALIGN(nvs_ptr - (u8 *)wl->nvs + 7, 4);\n\n\tif (nvs_ptr >= (u8 *) wl->nvs + nvs_len)\n\t\tgoto out_badnvs;\n\n\tnvs_len -= nvs_ptr - (u8 *)wl->nvs;\n\n\t \n\tret = wlcore_set_partition(wl, &wl->ptable[PART_WORK]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tnvs_aligned = kmemdup(nvs_ptr, nvs_len, GFP_KERNEL);\n\tif (!nvs_aligned)\n\t\treturn -ENOMEM;\n\n\t \n\tret = wlcore_write_data(wl, REG_CMD_MBOX_ADDRESS, nvs_aligned, nvs_len,\n\t\t\t\tfalse);\n\n\tkfree(nvs_aligned);\n\treturn ret;\n\nout_badnvs:\n\twl1271_error(\"nvs data is malformed\");\n\treturn -EILSEQ;\n}\nEXPORT_SYMBOL_GPL(wlcore_boot_upload_nvs);\n\nint wlcore_boot_run_firmware(struct wl1271 *wl)\n{\n\tint loop, ret;\n\tu32 chip_id, intr;\n\n\t \n\tret = wlcore_set_partition(wl, &wl->ptable[PART_BOOT]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1271_boot_set_ecpu_ctrl(wl, ECPU_CONTROL_HALT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wlcore_read_reg(wl, REG_CHIP_ID_B, &chip_id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twl1271_debug(DEBUG_BOOT, \"chip id after firmware boot: 0x%x\", chip_id);\n\n\tif (chip_id != wl->chip.id) {\n\t\twl1271_error(\"chip id doesn't match after firmware boot\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tloop = 0;\n\twhile (loop++ < INIT_LOOP) {\n\t\tudelay(INIT_LOOP_DELAY);\n\t\tret = wlcore_read_reg(wl, REG_INTERRUPT_NO_CLEAR, &intr);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (intr == 0xffffffff) {\n\t\t\twl1271_error(\"error reading hardware complete \"\n\t\t\t\t     \"init indication\");\n\t\t\treturn -EIO;\n\t\t}\n\t\t \n\t\telse if (intr & WL1271_ACX_INTR_INIT_COMPLETE) {\n\t\t\tret = wlcore_write_reg(wl, REG_INTERRUPT_ACK,\n\t\t\t\t\t       WL1271_ACX_INTR_INIT_COMPLETE);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (loop > INIT_LOOP) {\n\t\twl1271_error(\"timeout waiting for the hardware to \"\n\t\t\t     \"complete initialization\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tret = wlcore_read_reg(wl, REG_COMMAND_MAILBOX_PTR, &wl->cmd_box_addr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twl1271_debug(DEBUG_MAILBOX, \"cmd_box_addr 0x%x\", wl->cmd_box_addr);\n\n\t \n\tret = wlcore_read_reg(wl, REG_EVENT_MAILBOX_PTR, &wl->mbox_ptr[0]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twl->mbox_ptr[1] = wl->mbox_ptr[0] + wl->mbox_size;\n\n\twl1271_debug(DEBUG_MAILBOX, \"MBOX ptrs: 0x%x 0x%x\",\n\t\t     wl->mbox_ptr[0], wl->mbox_ptr[1]);\n\n\tret = wlcore_boot_static_data(wl);\n\tif (ret < 0) {\n\t\twl1271_error(\"error getting static data\");\n\t\treturn ret;\n\t}\n\n\t \n\n\t \n\tret = wl1271_event_unmask(wl);\n\tif (ret < 0) {\n\t\twl1271_error(\"EVENT mask setting failed\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = wlcore_set_partition(wl, &wl->ptable[PART_WORK]);\n\n\t \n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wlcore_boot_run_firmware);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}