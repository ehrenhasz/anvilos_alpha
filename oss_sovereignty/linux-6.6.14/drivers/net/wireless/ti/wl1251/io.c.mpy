{
  "module_name": "io.c",
  "hash_id": "3cdf349a3078d4b70989fbb345fc066cd82f95e28cfeb2ea5e4a458895e6feda",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wl1251/io.c",
  "human_readable_source": "\n \n\n#include \"wl1251.h\"\n#include \"reg.h\"\n#include \"io.h\"\n\n \nstatic enum wl12xx_acx_int_reg wl1251_io_reg_table[ACX_REG_TABLE_LEN] = {\n\t[ACX_REG_INTERRUPT_TRIG]     = (REGISTERS_BASE + 0x0474),\n\t[ACX_REG_INTERRUPT_TRIG_H]   = (REGISTERS_BASE + 0x0478),\n\t[ACX_REG_INTERRUPT_MASK]     = (REGISTERS_BASE + 0x0494),\n\t[ACX_REG_HINT_MASK_SET]      = (REGISTERS_BASE + 0x0498),\n\t[ACX_REG_HINT_MASK_CLR]      = (REGISTERS_BASE + 0x049C),\n\t[ACX_REG_INTERRUPT_NO_CLEAR] = (REGISTERS_BASE + 0x04B0),\n\t[ACX_REG_INTERRUPT_CLEAR]    = (REGISTERS_BASE + 0x04A4),\n\t[ACX_REG_INTERRUPT_ACK]      = (REGISTERS_BASE + 0x04A8),\n\t[ACX_REG_SLV_SOFT_RESET]     = (REGISTERS_BASE + 0x0000),\n\t[ACX_REG_EE_START]           = (REGISTERS_BASE + 0x080C),\n\t[ACX_REG_ECPU_CONTROL]       = (REGISTERS_BASE + 0x0804)\n};\n\nstatic int wl1251_translate_reg_addr(struct wl1251 *wl, int addr)\n{\n\t \n\tif (addr < REGISTERS_BASE) {\n\t\t \n\t\tif (addr >= ACX_REG_TABLE_LEN) {\n\t\t\twl1251_error(\"address out of range (%d)\", addr);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\taddr = wl1251_io_reg_table[addr];\n\t}\n\n\treturn addr - wl->physical_reg_addr + wl->virtual_reg_addr;\n}\n\nstatic int wl1251_translate_mem_addr(struct wl1251 *wl, int addr)\n{\n\treturn addr - wl->physical_mem_addr + wl->virtual_mem_addr;\n}\n\nvoid wl1251_mem_read(struct wl1251 *wl, int addr, void *buf, size_t len)\n{\n\tint physical;\n\n\tphysical = wl1251_translate_mem_addr(wl, addr);\n\n\twl->if_ops->read(wl, physical, buf, len);\n}\n\nvoid wl1251_mem_write(struct wl1251 *wl, int addr, void *buf, size_t len)\n{\n\tint physical;\n\n\tphysical = wl1251_translate_mem_addr(wl, addr);\n\n\twl->if_ops->write(wl, physical, buf, len);\n}\n\nu32 wl1251_mem_read32(struct wl1251 *wl, int addr)\n{\n\treturn wl1251_read32(wl, wl1251_translate_mem_addr(wl, addr));\n}\n\nvoid wl1251_mem_write32(struct wl1251 *wl, int addr, u32 val)\n{\n\twl1251_write32(wl, wl1251_translate_mem_addr(wl, addr), val);\n}\n\nu32 wl1251_reg_read32(struct wl1251 *wl, int addr)\n{\n\treturn wl1251_read32(wl, wl1251_translate_reg_addr(wl, addr));\n}\n\nvoid wl1251_reg_write32(struct wl1251 *wl, int addr, u32 val)\n{\n\twl1251_write32(wl, wl1251_translate_reg_addr(wl, addr), val);\n}\n\n \nvoid wl1251_set_partition(struct wl1251 *wl,\n\t\t\t  u32 mem_start, u32 mem_size,\n\t\t\t  u32 reg_start, u32 reg_size)\n{\n\tstruct wl1251_partition_set *partition;\n\n\tpartition = kmalloc(sizeof(*partition), GFP_KERNEL);\n\tif (!partition) {\n\t\twl1251_error(\"can not allocate partition buffer\");\n\t\treturn;\n\t}\n\n\twl1251_debug(DEBUG_SPI, \"mem_start %08X mem_size %08X\",\n\t\t     mem_start, mem_size);\n\twl1251_debug(DEBUG_SPI, \"reg_start %08X reg_size %08X\",\n\t\t     reg_start, reg_size);\n\n\t \n\tif ((mem_size + reg_size) > HW_ACCESS_MEMORY_MAX_RANGE) {\n\t\twl1251_debug(DEBUG_SPI, \"Total size exceeds maximum virtual\"\n\t\t\t     \" address range.  Truncating partition[0].\");\n\t\tmem_size = HW_ACCESS_MEMORY_MAX_RANGE - reg_size;\n\t\twl1251_debug(DEBUG_SPI, \"mem_start %08X mem_size %08X\",\n\t\t\t     mem_start, mem_size);\n\t\twl1251_debug(DEBUG_SPI, \"reg_start %08X reg_size %08X\",\n\t\t\t     reg_start, reg_size);\n\t}\n\n\tif ((mem_start < reg_start) &&\n\t    ((mem_start + mem_size) > reg_start)) {\n\t\t \n\t\twl1251_debug(DEBUG_SPI, \"End of partition[0] is \"\n\t\t\t     \"overlapping partition[1].  Adjusted.\");\n\t\tmem_size = reg_start - mem_start;\n\t\twl1251_debug(DEBUG_SPI, \"mem_start %08X mem_size %08X\",\n\t\t\t     mem_start, mem_size);\n\t\twl1251_debug(DEBUG_SPI, \"reg_start %08X reg_size %08X\",\n\t\t\t     reg_start, reg_size);\n\t} else if ((reg_start < mem_start) &&\n\t\t   ((reg_start + reg_size) > mem_start)) {\n\t\t \n\t\twl1251_debug(DEBUG_SPI, \"End of partition[1] is\"\n\t\t\t     \" overlapping partition[0].  Adjusted.\");\n\t\treg_size = mem_start - reg_start;\n\t\twl1251_debug(DEBUG_SPI, \"mem_start %08X mem_size %08X\",\n\t\t\t     mem_start, mem_size);\n\t\twl1251_debug(DEBUG_SPI, \"reg_start %08X reg_size %08X\",\n\t\t\t     reg_start, reg_size);\n\t}\n\n\tpartition->mem.start = mem_start;\n\tpartition->mem.size  = mem_size;\n\tpartition->reg.start = reg_start;\n\tpartition->reg.size  = reg_size;\n\n\twl->physical_mem_addr = mem_start;\n\twl->physical_reg_addr = reg_start;\n\n\twl->virtual_mem_addr = 0;\n\twl->virtual_reg_addr = mem_size;\n\n\twl->if_ops->write(wl, HW_ACCESS_PART0_SIZE_ADDR, partition,\n\t\tsizeof(*partition));\n\n\tkfree(partition);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}