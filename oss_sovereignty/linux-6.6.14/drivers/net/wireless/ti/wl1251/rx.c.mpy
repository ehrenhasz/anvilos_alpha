{
  "module_name": "rx.c",
  "hash_id": "df86257d81a9b983de5bd7b9e2716c0ecd48e27c97f1c1b71b28442a7051399a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wl1251/rx.c",
  "human_readable_source": "\n \n\n#include <linux/skbuff.h>\n#include <linux/gfp.h>\n#include <net/mac80211.h>\n\n#include \"wl1251.h\"\n#include \"reg.h\"\n#include \"io.h\"\n#include \"rx.h\"\n#include \"cmd.h\"\n#include \"acx.h\"\n\nstatic void wl1251_rx_header(struct wl1251 *wl,\n\t\t\t     struct wl1251_rx_descriptor *desc)\n{\n\tu32 rx_packet_ring_addr;\n\n\trx_packet_ring_addr = wl->data_path->rx_packet_ring_addr;\n\tif (wl->rx_current_buffer)\n\t\trx_packet_ring_addr += wl->data_path->rx_packet_ring_chunk_size;\n\n\twl1251_mem_read(wl, rx_packet_ring_addr, desc, sizeof(*desc));\n}\n\nstatic void wl1251_rx_status(struct wl1251 *wl,\n\t\t\t     struct wl1251_rx_descriptor *desc,\n\t\t\t     struct ieee80211_rx_status *status,\n\t\t\t     u8 beacon)\n{\n\tu64 mactime;\n\tint ret;\n\n\tmemset(status, 0, sizeof(struct ieee80211_rx_status));\n\n\tstatus->band = NL80211_BAND_2GHZ;\n\tstatus->mactime = desc->timestamp;\n\n\t \n\tif ((wl->bss_type == BSS_TYPE_IBSS) && beacon) {\n\t\tret = wl1251_acx_tsf_info(wl, &mactime);\n\t\tif (ret == 0)\n\t\t\tstatus->mactime = mactime;\n\t}\n\n\tstatus->signal = desc->rssi;\n\n\t \n\twl->noise = desc->rssi - desc->snr / 2;\n\n\tstatus->freq = ieee80211_channel_to_frequency(desc->channel,\n\t\t\t\t\t\t      status->band);\n\n\tstatus->flag |= RX_FLAG_MACTIME_START;\n\n\tif (!wl->monitor_present && (desc->flags & RX_DESC_ENCRYPTION_MASK)) {\n\t\tstatus->flag |= RX_FLAG_IV_STRIPPED | RX_FLAG_MMIC_STRIPPED;\n\n\t\tif (likely(!(desc->flags & RX_DESC_DECRYPT_FAIL)))\n\t\t\tstatus->flag |= RX_FLAG_DECRYPTED;\n\n\t\tif (unlikely(desc->flags & RX_DESC_MIC_FAIL))\n\t\t\tstatus->flag |= RX_FLAG_MMIC_ERROR;\n\t}\n\n\tif (unlikely(!(desc->flags & RX_DESC_VALID_FCS)))\n\t\tstatus->flag |= RX_FLAG_FAILED_FCS_CRC;\n\n\tswitch (desc->rate) {\n\t\t \n\tcase RATE_2MBPS:\n\t\tstatus->rate_idx = 1;\n\t\tbreak;\n\tcase RATE_5_5MBPS:\n\t\tstatus->rate_idx = 2;\n\t\tbreak;\n\tcase RATE_11MBPS:\n\t\tstatus->rate_idx = 3;\n\t\tbreak;\n\tcase RATE_6MBPS:\n\t\tstatus->rate_idx = 4;\n\t\tbreak;\n\tcase RATE_9MBPS:\n\t\tstatus->rate_idx = 5;\n\t\tbreak;\n\tcase RATE_18MBPS:\n\t\tstatus->rate_idx = 7;\n\t\tbreak;\n\tcase RATE_24MBPS:\n\t\tstatus->rate_idx = 8;\n\t\tbreak;\n\tcase RATE_36MBPS:\n\t\tstatus->rate_idx = 9;\n\t\tbreak;\n\tcase RATE_48MBPS:\n\t\tstatus->rate_idx = 10;\n\t\tbreak;\n\tcase RATE_54MBPS:\n\t\tstatus->rate_idx = 11;\n\t\tbreak;\n\t}\n\n\t \n\tif (desc->rate == RATE_1MBPS) {\n\t\tif (!(desc->mod_pre & OFDM_RATE_BIT))\n\t\t\t \n\t\t\tstatus->rate_idx = 0;\n\t\telse\n\t\t\t \n\t\t\tstatus->rate_idx = 6;\n\t}\n\n\tif (desc->mod_pre & SHORT_PREAMBLE_BIT)\n\t\tstatus->enc_flags |= RX_ENC_FLAG_SHORTPRE;\n}\n\nstatic void wl1251_rx_body(struct wl1251 *wl,\n\t\t\t   struct wl1251_rx_descriptor *desc)\n{\n\tstruct sk_buff *skb;\n\tstruct ieee80211_rx_status status;\n\tu8 *rx_buffer, beacon = 0;\n\tu16 length, *fc;\n\tu32 curr_id, last_id_inc, rx_packet_ring_addr;\n\n\tlength = WL1251_RX_ALIGN(desc->length  - PLCP_HEADER_LENGTH);\n\tcurr_id = (desc->flags & RX_DESC_SEQNUM_MASK) >> RX_DESC_PACKETID_SHIFT;\n\tlast_id_inc = (wl->rx_last_id + 1) % (RX_MAX_PACKET_ID + 1);\n\n\tif (last_id_inc != curr_id) {\n\t\twl1251_warning(\"curr ID:%d, last ID inc:%d\",\n\t\t\t       curr_id, last_id_inc);\n\t\twl->rx_last_id = curr_id;\n\t} else {\n\t\twl->rx_last_id = last_id_inc;\n\t}\n\n\trx_packet_ring_addr = wl->data_path->rx_packet_ring_addr +\n\t\tsizeof(struct wl1251_rx_descriptor) + 20;\n\tif (wl->rx_current_buffer)\n\t\trx_packet_ring_addr += wl->data_path->rx_packet_ring_chunk_size;\n\n\tskb = __dev_alloc_skb(length, GFP_KERNEL);\n\tif (!skb) {\n\t\twl1251_error(\"Couldn't allocate RX frame\");\n\t\treturn;\n\t}\n\n\trx_buffer = skb_put(skb, length);\n\twl1251_mem_read(wl, rx_packet_ring_addr, rx_buffer, length);\n\n\t \n\tskb_trim(skb, desc->length - PLCP_HEADER_LENGTH);\n\n\tfc = (u16 *)skb->data;\n\n\tif ((*fc & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_BEACON)\n\t\tbeacon = 1;\n\n\twl1251_rx_status(wl, desc, &status, beacon);\n\n\twl1251_debug(DEBUG_RX, \"rx skb 0x%p: %d B %s\", skb, skb->len,\n\t\t     beacon ? \"beacon\" : \"\");\n\n\tmemcpy(IEEE80211_SKB_RXCB(skb), &status, sizeof(status));\n\tieee80211_rx_ni(wl->hw, skb);\n}\n\nstatic void wl1251_rx_ack(struct wl1251 *wl)\n{\n\tu32 data, addr;\n\n\tif (wl->rx_current_buffer) {\n\t\taddr = ACX_REG_INTERRUPT_TRIG_H;\n\t\tdata = INTR_TRIG_RX_PROC1;\n\t} else {\n\t\taddr = ACX_REG_INTERRUPT_TRIG;\n\t\tdata = INTR_TRIG_RX_PROC0;\n\t}\n\n\twl1251_reg_write32(wl, addr, data);\n\n\t \n\twl->rx_current_buffer = !wl->rx_current_buffer;\n}\n\n\nvoid wl1251_rx(struct wl1251 *wl)\n{\n\tstruct wl1251_rx_descriptor *rx_desc;\n\n\tif (wl->state != WL1251_STATE_ON)\n\t\treturn;\n\n\trx_desc = wl->rx_descriptor;\n\n\t \n\twl1251_rx_header(wl, rx_desc);\n\n\t \n\twl1251_rx_body(wl, rx_desc);\n\n\t \n\twl1251_rx_ack(wl);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}