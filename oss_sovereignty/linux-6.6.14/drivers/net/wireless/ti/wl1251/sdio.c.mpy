{
  "module_name": "sdio.c",
  "hash_id": "134e567a28ea85eb4fbfe3efa8e52eabd64d5bdc6295a5475eb7ea22740d1382",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wl1251/sdio.c",
  "human_readable_source": "\n \n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mmc/sdio_func.h>\n#include <linux/mmc/sdio_ids.h>\n#include <linux/platform_device.h>\n#include <linux/irq.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n\n#include \"wl1251.h\"\n\nstruct wl1251_sdio {\n\tstruct sdio_func *func;\n\tu32 elp_val;\n};\n\nstatic struct sdio_func *wl_to_func(struct wl1251 *wl)\n{\n\tstruct wl1251_sdio *wl_sdio = wl->if_priv;\n\treturn wl_sdio->func;\n}\n\nstatic void wl1251_sdio_interrupt(struct sdio_func *func)\n{\n\tstruct wl1251 *wl = sdio_get_drvdata(func);\n\n\twl1251_debug(DEBUG_IRQ, \"IRQ\");\n\n\t \n\tieee80211_queue_work(wl->hw, &wl->irq_work);\n}\n\nstatic const struct sdio_device_id wl1251_devices[] = {\n\t{ SDIO_DEVICE(SDIO_VENDOR_ID_TI_WL1251, SDIO_DEVICE_ID_TI_WL1251) },\n\t{}\n};\nMODULE_DEVICE_TABLE(sdio, wl1251_devices);\n\n\nstatic void wl1251_sdio_read(struct wl1251 *wl, int addr,\n\t\t\t     void *buf, size_t len)\n{\n\tint ret;\n\tstruct sdio_func *func = wl_to_func(wl);\n\n\tsdio_claim_host(func);\n\tret = sdio_memcpy_fromio(func, buf, addr, len);\n\tif (ret)\n\t\twl1251_error(\"sdio read failed (%d)\", ret);\n\tsdio_release_host(func);\n}\n\nstatic void wl1251_sdio_write(struct wl1251 *wl, int addr,\n\t\t\t      void *buf, size_t len)\n{\n\tint ret;\n\tstruct sdio_func *func = wl_to_func(wl);\n\n\tsdio_claim_host(func);\n\tret = sdio_memcpy_toio(func, addr, buf, len);\n\tif (ret)\n\t\twl1251_error(\"sdio write failed (%d)\", ret);\n\tsdio_release_host(func);\n}\n\nstatic void wl1251_sdio_read_elp(struct wl1251 *wl, int addr, u32 *val)\n{\n\tint ret = 0;\n\tstruct wl1251_sdio *wl_sdio = wl->if_priv;\n\tstruct sdio_func *func = wl_sdio->func;\n\n\t \n\tsdio_claim_host(func);\n\t*val = sdio_writeb_readb(func, wl_sdio->elp_val, addr, &ret);\n\tsdio_release_host(func);\n\n\tif (ret)\n\t\twl1251_error(\"sdio_readb failed (%d)\", ret);\n}\n\nstatic void wl1251_sdio_write_elp(struct wl1251 *wl, int addr, u32 val)\n{\n\tint ret = 0;\n\tstruct wl1251_sdio *wl_sdio = wl->if_priv;\n\tstruct sdio_func *func = wl_sdio->func;\n\n\tsdio_claim_host(func);\n\tsdio_writeb(func, val, addr, &ret);\n\tsdio_release_host(func);\n\n\tif (ret)\n\t\twl1251_error(\"sdio_writeb failed (%d)\", ret);\n\telse\n\t\twl_sdio->elp_val = val;\n}\n\nstatic void wl1251_sdio_reset(struct wl1251 *wl)\n{\n}\n\nstatic void wl1251_sdio_enable_irq(struct wl1251 *wl)\n{\n\tstruct sdio_func *func = wl_to_func(wl);\n\n\tsdio_claim_host(func);\n\tsdio_claim_irq(func, wl1251_sdio_interrupt);\n\tsdio_release_host(func);\n}\n\nstatic void wl1251_sdio_disable_irq(struct wl1251 *wl)\n{\n\tstruct sdio_func *func = wl_to_func(wl);\n\n\tsdio_claim_host(func);\n\tsdio_release_irq(func);\n\tsdio_release_host(func);\n}\n\n \nstatic irqreturn_t wl1251_line_irq(int irq, void *cookie)\n{\n\tstruct wl1251 *wl = cookie;\n\n\tieee80211_queue_work(wl->hw, &wl->irq_work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void wl1251_enable_line_irq(struct wl1251 *wl)\n{\n\treturn enable_irq(wl->irq);\n}\n\nstatic void wl1251_disable_line_irq(struct wl1251 *wl)\n{\n\treturn disable_irq(wl->irq);\n}\n\nstatic int wl1251_sdio_set_power(struct wl1251 *wl, bool enable)\n{\n\tstruct sdio_func *func = wl_to_func(wl);\n\tint ret;\n\n\tif (enable) {\n\t\tret = pm_runtime_get_sync(&func->dev);\n\t\tif (ret < 0) {\n\t\t\tpm_runtime_put_sync(&func->dev);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsdio_claim_host(func);\n\t\tsdio_enable_func(func);\n\t\tsdio_release_host(func);\n\t} else {\n\t\tsdio_claim_host(func);\n\t\tsdio_disable_func(func);\n\t\tsdio_release_host(func);\n\n\t\tret = pm_runtime_put_sync(&func->dev);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic struct wl1251_if_operations wl1251_sdio_ops = {\n\t.read = wl1251_sdio_read,\n\t.write = wl1251_sdio_write,\n\t.write_elp = wl1251_sdio_write_elp,\n\t.read_elp = wl1251_sdio_read_elp,\n\t.reset = wl1251_sdio_reset,\n\t.power = wl1251_sdio_set_power,\n};\n\nstatic int wl1251_sdio_probe(struct sdio_func *func,\n\t\t\t     const struct sdio_device_id *id)\n{\n\tint ret;\n\tstruct wl1251 *wl;\n\tstruct ieee80211_hw *hw;\n\tstruct wl1251_sdio *wl_sdio;\n\tstruct device_node *np = func->dev.of_node;\n\n\thw = wl1251_alloc_hw();\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\n\twl = hw->priv;\n\n\twl_sdio = kzalloc(sizeof(*wl_sdio), GFP_KERNEL);\n\tif (wl_sdio == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_hw;\n\t}\n\n\tsdio_claim_host(func);\n\tret = sdio_enable_func(func);\n\tif (ret)\n\t\tgoto release;\n\n\tsdio_set_block_size(func, 512);\n\tsdio_release_host(func);\n\n\tSET_IEEE80211_DEV(hw, &func->dev);\n\twl_sdio->func = func;\n\twl->if_priv = wl_sdio;\n\twl->if_ops = &wl1251_sdio_ops;\n\n\tif (np) {\n\t\twl->use_eeprom = of_property_read_bool(np, \"ti,wl1251-has-eeprom\");\n\t\twl->irq = of_irq_get(np, 0);\n\t\tif (wl->irq == -EPROBE_DEFER) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto disable;\n\t\t}\n\t}\n\n\tif (wl->irq) {\n\t\tirq_set_status_flags(wl->irq, IRQ_NOAUTOEN);\n\t\tret = request_irq(wl->irq, wl1251_line_irq, 0, \"wl1251\", wl);\n\t\tif (ret < 0) {\n\t\t\twl1251_error(\"request_irq() failed: %d\", ret);\n\t\t\tgoto disable;\n\t\t}\n\n\t\tirq_set_irq_type(wl->irq, IRQ_TYPE_EDGE_RISING);\n\n\t\twl1251_sdio_ops.enable_irq = wl1251_enable_line_irq;\n\t\twl1251_sdio_ops.disable_irq = wl1251_disable_line_irq;\n\n\t\twl1251_info(\"using dedicated interrupt line\");\n\t} else {\n\t\twl1251_sdio_ops.enable_irq = wl1251_sdio_enable_irq;\n\t\twl1251_sdio_ops.disable_irq = wl1251_sdio_disable_irq;\n\n\t\twl1251_info(\"using SDIO interrupt\");\n\t}\n\n\tret = wl1251_init_ieee80211(wl);\n\tif (ret)\n\t\tgoto out_free_irq;\n\n\tsdio_set_drvdata(func, wl);\n\n\t \n\tpm_runtime_put_noidle(&func->dev);\n\n\treturn ret;\n\nout_free_irq:\n\tif (wl->irq)\n\t\tfree_irq(wl->irq, wl);\ndisable:\n\tsdio_claim_host(func);\n\tsdio_disable_func(func);\nrelease:\n\tsdio_release_host(func);\n\tkfree(wl_sdio);\nout_free_hw:\n\twl1251_free_hw(wl);\n\treturn ret;\n}\n\nstatic void wl1251_sdio_remove(struct sdio_func *func)\n{\n\tstruct wl1251 *wl = sdio_get_drvdata(func);\n\tstruct wl1251_sdio *wl_sdio = wl->if_priv;\n\n\t \n\tpm_runtime_get_noresume(&func->dev);\n\n\tif (wl->irq)\n\t\tfree_irq(wl->irq, wl);\n\twl1251_free_hw(wl);\n\tkfree(wl_sdio);\n\n\tsdio_claim_host(func);\n\tsdio_release_irq(func);\n\tsdio_disable_func(func);\n\tsdio_release_host(func);\n}\n\nstatic int wl1251_suspend(struct device *dev)\n{\n\t \n\treturn 0;\n}\n\nstatic int wl1251_resume(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops wl1251_sdio_pm_ops = {\n\t.suspend        = wl1251_suspend,\n\t.resume         = wl1251_resume,\n};\n\nstatic struct sdio_driver wl1251_sdio_driver = {\n\t.name\t\t= \"wl1251_sdio\",\n\t.id_table\t= wl1251_devices,\n\t.probe\t\t= wl1251_sdio_probe,\n\t.remove\t\t= wl1251_sdio_remove,\n\t.drv.pm\t\t= &wl1251_sdio_pm_ops,\n};\n\nstatic int __init wl1251_sdio_init(void)\n{\n\tint err;\n\n\terr = sdio_register_driver(&wl1251_sdio_driver);\n\tif (err)\n\t\twl1251_error(\"failed to register sdio driver: %d\", err);\n\treturn err;\n}\n\nstatic void __exit wl1251_sdio_exit(void)\n{\n\tsdio_unregister_driver(&wl1251_sdio_driver);\n\twl1251_notice(\"unloaded\");\n}\n\nmodule_init(wl1251_sdio_init);\nmodule_exit(wl1251_sdio_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kalle Valo <kvalo@adurom.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}