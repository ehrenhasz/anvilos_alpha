{
  "module_name": "init.c",
  "hash_id": "dda9d5a3b87a6d8284b278a9654484d34d32e2f62e907732b8e63afd0f947c47",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wl1251/init.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include \"init.h\"\n#include \"wl12xx_80211.h\"\n#include \"acx.h\"\n#include \"cmd.h\"\n#include \"reg.h\"\n\nint wl1251_hw_init_hwenc_config(struct wl1251 *wl)\n{\n\tint ret;\n\n\tret = wl1251_acx_feature_cfg(wl, 0);\n\tif (ret < 0) {\n\t\twl1251_warning(\"couldn't set feature config\");\n\t\treturn ret;\n\t}\n\n\tret = wl1251_acx_default_key(wl, wl->default_key);\n\tif (ret < 0) {\n\t\twl1251_warning(\"couldn't set default key\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint wl1251_hw_init_templates_config(struct wl1251 *wl)\n{\n\tint ret;\n\tu8 partial_vbm[PARTIAL_VBM_MAX];\n\n\t \n\tret = wl1251_cmd_template_set(wl, CMD_PROBE_REQ, NULL,\n\t\t\t\t      sizeof(struct wl12xx_probe_req_template));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1251_cmd_template_set(wl, CMD_NULL_DATA, NULL,\n\t\t\t\t      sizeof(struct wl12xx_null_data_template));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1251_cmd_template_set(wl, CMD_PS_POLL, NULL,\n\t\t\t\t      sizeof(struct wl12xx_ps_poll_template));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1251_cmd_template_set(wl, CMD_QOS_NULL_DATA, NULL,\n\t\t\t\t      sizeof\n\t\t\t\t      (struct wl12xx_qos_null_data_template));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1251_cmd_template_set(wl, CMD_PROBE_RESP, NULL,\n\t\t\t\t      sizeof\n\t\t\t\t      (struct wl12xx_probe_resp_template));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1251_cmd_template_set(wl, CMD_BEACON, NULL,\n\t\t\t\t      sizeof\n\t\t\t\t      (struct wl12xx_beacon_template));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmemset(partial_vbm, 0, PARTIAL_VBM_MAX);\n\tret = wl1251_cmd_vbm(wl, TIM_ELE_ID, partial_vbm, PARTIAL_VBM_MAX, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1251_cmd_vbm(wl, TIM_ELE_ID, partial_vbm, 1, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint wl1251_hw_init_rx_config(struct wl1251 *wl, u32 config, u32 filter)\n{\n\tint ret;\n\n\tret = wl1251_acx_rx_msdu_life_time(wl, RX_MSDU_LIFETIME_DEF);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1251_acx_rx_config(wl, config, filter);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint wl1251_hw_init_phy_config(struct wl1251 *wl)\n{\n\tint ret;\n\n\tret = wl1251_acx_pd_threshold(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1251_acx_slot(wl, DEFAULT_SLOT_TIME);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1251_acx_group_address_tbl(wl, true, NULL, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1251_acx_service_period_timeout(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1251_acx_rts_threshold(wl, RTS_THRESHOLD_DEF);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint wl1251_hw_init_beacon_filter(struct wl1251 *wl)\n{\n\tint ret;\n\n\t \n\tret = wl1251_acx_beacon_filter_opt(wl, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1251_acx_beacon_filter_table(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint wl1251_hw_init_pta(struct wl1251 *wl)\n{\n\tint ret;\n\n\tret = wl1251_acx_sg_enable(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1251_acx_sg_cfg(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint wl1251_hw_init_energy_detection(struct wl1251 *wl)\n{\n\tint ret;\n\n\tret = wl1251_acx_cca_threshold(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint wl1251_hw_init_beacon_broadcast(struct wl1251 *wl)\n{\n\tint ret;\n\n\tret = wl1251_acx_bcn_dtim_options(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint wl1251_hw_init_power_auth(struct wl1251 *wl)\n{\n\treturn wl1251_acx_sleep_auth(wl, WL1251_PSM_CAM);\n}\n\nint wl1251_hw_init_mem_config(struct wl1251 *wl)\n{\n\tint ret;\n\n\tret = wl1251_acx_mem_cfg(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twl->target_mem_map = kzalloc(sizeof(struct wl1251_acx_mem_map),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!wl->target_mem_map) {\n\t\twl1251_error(\"couldn't allocate target memory map\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tret = wl1251_acx_mem_map(wl, wl->target_mem_map,\n\t\t\t\t sizeof(struct wl1251_acx_mem_map));\n\tif (ret < 0) {\n\t\twl1251_error(\"couldn't retrieve firmware memory map\");\n\t\tkfree(wl->target_mem_map);\n\t\twl->target_mem_map = NULL;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int wl1251_hw_init_txq_fill(u8 qid,\n\t\t\t\t   struct acx_tx_queue_qos_config *config,\n\t\t\t\t   u32 num_blocks)\n{\n\tconfig->qid = qid;\n\n\tswitch (qid) {\n\tcase QOS_AC_BE:\n\t\tconfig->high_threshold =\n\t\t\t(QOS_TX_HIGH_BE_DEF * num_blocks) / 100;\n\t\tconfig->low_threshold =\n\t\t\t(QOS_TX_LOW_BE_DEF * num_blocks) / 100;\n\t\tbreak;\n\tcase QOS_AC_BK:\n\t\tconfig->high_threshold =\n\t\t\t(QOS_TX_HIGH_BK_DEF * num_blocks) / 100;\n\t\tconfig->low_threshold =\n\t\t\t(QOS_TX_LOW_BK_DEF * num_blocks) / 100;\n\t\tbreak;\n\tcase QOS_AC_VI:\n\t\tconfig->high_threshold =\n\t\t\t(QOS_TX_HIGH_VI_DEF * num_blocks) / 100;\n\t\tconfig->low_threshold =\n\t\t\t(QOS_TX_LOW_VI_DEF * num_blocks) / 100;\n\t\tbreak;\n\tcase QOS_AC_VO:\n\t\tconfig->high_threshold =\n\t\t\t(QOS_TX_HIGH_VO_DEF * num_blocks) / 100;\n\t\tconfig->low_threshold =\n\t\t\t(QOS_TX_LOW_VO_DEF * num_blocks) / 100;\n\t\tbreak;\n\tdefault:\n\t\twl1251_error(\"Invalid TX queue id: %d\", qid);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int wl1251_hw_init_tx_queue_config(struct wl1251 *wl)\n{\n\tstruct acx_tx_queue_qos_config *config;\n\tstruct wl1251_acx_mem_map *wl_mem_map = wl->target_mem_map;\n\tint ret, i;\n\n\twl1251_debug(DEBUG_ACX, \"acx tx queue config\");\n\n\tconfig = kzalloc(sizeof(*config), GFP_KERNEL);\n\tif (!config) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < MAX_NUM_OF_AC; i++) {\n\t\tret = wl1251_hw_init_txq_fill(i, config,\n\t\t\t\t\t      wl_mem_map->num_tx_mem_blocks);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = wl1251_cmd_configure(wl, ACX_TX_QUEUE_CFG,\n\t\t\t\t\t   config, sizeof(*config));\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\twl1251_acx_ac_cfg(wl, AC_BE, CWMIN_BE, CWMAX_BE, AIFS_DIFS, TXOP_BE);\n\twl1251_acx_ac_cfg(wl, AC_BK, CWMIN_BK, CWMAX_BK, AIFS_DIFS, TXOP_BK);\n\twl1251_acx_ac_cfg(wl, AC_VI, CWMIN_VI, CWMAX_VI, AIFS_DIFS, TXOP_VI);\n\twl1251_acx_ac_cfg(wl, AC_VO, CWMIN_VO, CWMAX_VO, AIFS_DIFS, TXOP_VO);\n\nout:\n\tkfree(config);\n\treturn ret;\n}\n\nstatic int wl1251_hw_init_data_path_config(struct wl1251 *wl)\n{\n\tint ret;\n\n\t \n\twl->data_path = kzalloc(sizeof(struct acx_data_path_params_resp),\n\t\t\t\tGFP_KERNEL);\n\tif (!wl->data_path)\n\t\treturn -ENOMEM;\n\n\tret = wl1251_acx_data_path_params(wl, wl->data_path);\n\tif (ret < 0) {\n\t\tkfree(wl->data_path);\n\t\twl->data_path = NULL;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n\nint wl1251_hw_init(struct wl1251 *wl)\n{\n\tstruct wl1251_acx_mem_map *wl_mem_map;\n\tint ret;\n\n\tret = wl1251_hw_init_hwenc_config(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wl1251_hw_init_templates_config(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wl1251_hw_init_mem_config(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = wl1251_hw_init_data_path_config(wl);\n\tif (ret < 0)\n\t\tgoto out_free_memmap;\n\n\t \n\tret = wl1251_hw_init_rx_config(wl,\n\t\t\t\t       RX_CFG_PROMISCUOUS | RX_CFG_TSF,\n\t\t\t\t       RX_FILTER_OPTION_DEF);\n\t \n\tif (ret < 0)\n\t\tgoto out_free_data_path;\n\n\t \n\tret = wl1251_hw_init_tx_queue_config(wl);\n\tif (ret < 0)\n\t\tgoto out_free_data_path;\n\n\t \n\tret = wl1251_hw_init_phy_config(wl);\n\tif (ret < 0)\n\t\tgoto out_free_data_path;\n\n\t \n\tret = wl1251_acx_conn_monit_params(wl);\n\tif (ret < 0)\n\t\tgoto out_free_data_path;\n\n\t \n\tret = wl1251_hw_init_beacon_filter(wl);\n\tif (ret < 0)\n\t\tgoto out_free_data_path;\n\n\t \n\tret = wl1251_hw_init_pta(wl);\n\tif (ret < 0)\n\t\tgoto out_free_data_path;\n\n\t \n\tret = wl1251_hw_init_energy_detection(wl);\n\tif (ret < 0)\n\t\tgoto out_free_data_path;\n\n\t \n\tret = wl1251_hw_init_beacon_broadcast(wl);\n\tif (ret < 0)\n\t\tgoto out_free_data_path;\n\n\t \n\tret = wl1251_cmd_data_path_rx(wl, wl->channel, 1);\n\tif (ret < 0)\n\t\tgoto out_free_data_path;\n\n\t \n\tret = wl1251_cmd_data_path_tx(wl, wl->channel, 1);\n\tif (ret < 0)\n\t\tgoto out_free_data_path;\n\n\t \n\tret = wl1251_hw_init_power_auth(wl);\n\tif (ret < 0)\n\t\tgoto out_free_data_path;\n\n\twl_mem_map = wl->target_mem_map;\n\twl1251_info(\"%d tx blocks at 0x%x, %d rx blocks at 0x%x\",\n\t\t    wl_mem_map->num_tx_mem_blocks,\n\t\t    wl->data_path->tx_control_addr,\n\t\t    wl_mem_map->num_rx_mem_blocks,\n\t\t    wl->data_path->rx_control_addr);\n\n\treturn 0;\n\n out_free_data_path:\n\tkfree(wl->data_path);\n\n out_free_memmap:\n\tkfree(wl->target_mem_map);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}