{
  "module_name": "ps.c",
  "hash_id": "86f0c16cff4f5a56ad3d906fc46e0d5f3910a7d18428297c504edb4693744252",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wl1251/ps.c",
  "human_readable_source": "\n \n\n#include \"reg.h\"\n#include \"ps.h\"\n#include \"cmd.h\"\n#include \"io.h\"\n\n \n#define WL1251_WAKEUP_TIMEOUT 100\n\nvoid wl1251_elp_work(struct work_struct *work)\n{\n\tstruct delayed_work *dwork;\n\tstruct wl1251 *wl;\n\n\tdwork = to_delayed_work(work);\n\twl = container_of(dwork, struct wl1251, elp_work);\n\n\twl1251_debug(DEBUG_PSM, \"elp work\");\n\n\tmutex_lock(&wl->mutex);\n\n\tif (wl->elp || wl->station_mode == STATION_ACTIVE_MODE)\n\t\tgoto out;\n\n\twl1251_debug(DEBUG_PSM, \"chip to elp\");\n\twl1251_write_elp(wl, HW_ACCESS_ELP_CTRL_REG_ADDR, ELPCTRL_SLEEP);\n\twl->elp = true;\n\nout:\n\tmutex_unlock(&wl->mutex);\n}\n\n#define ELP_ENTRY_DELAY  5\n\n \nvoid wl1251_ps_elp_sleep(struct wl1251 *wl)\n{\n\tunsigned long delay;\n\n\tif (wl->station_mode != STATION_ACTIVE_MODE) {\n\t\tdelay = msecs_to_jiffies(ELP_ENTRY_DELAY);\n\t\tieee80211_queue_delayed_work(wl->hw, &wl->elp_work, delay);\n\t}\n}\n\nint wl1251_ps_elp_wakeup(struct wl1251 *wl)\n{\n\tunsigned long timeout, start;\n\tu32 elp_reg;\n\n\tcancel_delayed_work(&wl->elp_work);\n\n\tif (!wl->elp)\n\t\treturn 0;\n\n\twl1251_debug(DEBUG_PSM, \"waking up chip from elp\");\n\n\tstart = jiffies;\n\ttimeout = jiffies + msecs_to_jiffies(WL1251_WAKEUP_TIMEOUT);\n\n\twl1251_write_elp(wl, HW_ACCESS_ELP_CTRL_REG_ADDR, ELPCTRL_WAKE_UP);\n\n\telp_reg = wl1251_read_elp(wl, HW_ACCESS_ELP_CTRL_REG_ADDR);\n\n\t \n\twhile (!(elp_reg & ELPCTRL_WLAN_READY)) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\twl1251_error(\"elp wakeup timeout\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tmsleep(1);\n\t\telp_reg = wl1251_read_elp(wl, HW_ACCESS_ELP_CTRL_REG_ADDR);\n\t}\n\n\twl1251_debug(DEBUG_PSM, \"wakeup time: %u ms\",\n\t\t     jiffies_to_msecs(jiffies - start));\n\n\twl->elp = false;\n\n\treturn 0;\n}\n\nint wl1251_ps_set_mode(struct wl1251 *wl, enum wl1251_station_mode mode)\n{\n\tint ret;\n\n\tswitch (mode) {\n\tcase STATION_POWER_SAVE_MODE:\n\t\twl1251_debug(DEBUG_PSM, \"entering psm\");\n\n\t\t \n\t\tret = wl1251_acx_beacon_filter_opt(wl, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = wl1251_acx_wake_up_conditions(wl,\n\t\t\t\t\t\t    WAKE_UP_EVENT_DTIM_BITMAP,\n\t\t\t\t\t\t    wl->listen_int);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = wl1251_acx_bet_enable(wl, WL1251_ACX_BET_ENABLE,\n\t\t\t\t\t    WL1251_DEFAULT_BET_CONSECUTIVE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = wl1251_cmd_ps_mode(wl, CHIP_POWER_SAVE_MODE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = wl1251_acx_sleep_auth(wl, WL1251_PSM_ELP);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase STATION_IDLE:\n\t\twl1251_debug(DEBUG_PSM, \"entering idle\");\n\n\t\tret = wl1251_acx_sleep_auth(wl, WL1251_PSM_ELP);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = wl1251_cmd_template_set(wl, CMD_DISCONNECT, NULL, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase STATION_ACTIVE_MODE:\n\tdefault:\n\t\twl1251_debug(DEBUG_PSM, \"leaving psm\");\n\n\t\tret = wl1251_acx_sleep_auth(wl, WL1251_PSM_CAM);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = wl1251_acx_bet_enable(wl, WL1251_ACX_BET_DISABLE,\n\t\t\t\t\t    WL1251_DEFAULT_BET_CONSECUTIVE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = wl1251_acx_beacon_filter_opt(wl, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = wl1251_acx_wake_up_conditions(wl,\n\t\t\t\t\t\t    WAKE_UP_EVENT_DTIM_BITMAP,\n\t\t\t\t\t\t    wl->listen_int);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = wl1251_cmd_ps_mode(wl, CHIP_ACTIVE_MODE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbreak;\n\t}\n\twl->station_mode = mode;\n\n\treturn ret;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}