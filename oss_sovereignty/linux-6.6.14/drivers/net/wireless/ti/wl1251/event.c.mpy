{
  "module_name": "event.c",
  "hash_id": "4606ad43ea71e3c214d7caae58a71f4909be96abba22c6e8949f329f84c13732",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wl1251/event.c",
  "human_readable_source": "\n \n\n#include \"wl1251.h\"\n#include \"reg.h\"\n#include \"io.h\"\n#include \"event.h\"\n#include \"ps.h\"\n\nstatic int wl1251_event_scan_complete(struct wl1251 *wl,\n\t\t\t\t      struct event_mailbox *mbox)\n{\n\tint ret = 0;\n\n\twl1251_debug(DEBUG_EVENT, \"status: 0x%x, channels: %d\",\n\t\t     mbox->scheduled_scan_status,\n\t\t     mbox->scheduled_scan_channels);\n\n\tif (wl->scanning) {\n\t\tstruct cfg80211_scan_info info = {\n\t\t\t.aborted = false,\n\t\t};\n\n\t\tieee80211_scan_completed(wl->hw, &info);\n\t\twl1251_debug(DEBUG_MAC80211, \"mac80211 hw scan completed\");\n\t\twl->scanning = false;\n\t\tif (wl->hw->conf.flags & IEEE80211_CONF_IDLE)\n\t\t\tret = wl1251_ps_set_mode(wl, STATION_IDLE);\n\t}\n\n\treturn ret;\n}\n\n#define WL1251_PSM_ENTRY_RETRIES  3\nstatic int wl1251_event_ps_report(struct wl1251 *wl,\n\t\t\t\t  struct event_mailbox *mbox)\n{\n\tint ret = 0;\n\n\twl1251_debug(DEBUG_EVENT, \"ps status: %x\", mbox->ps_status);\n\n\tswitch (mbox->ps_status) {\n\tcase EVENT_ENTER_POWER_SAVE_FAIL:\n\t\twl1251_debug(DEBUG_PSM, \"PSM entry failed\");\n\n\t\tif (wl->station_mode != STATION_POWER_SAVE_MODE) {\n\t\t\t \n\t\t\twl->psm_entry_retry = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wl->psm_entry_retry < WL1251_PSM_ENTRY_RETRIES) {\n\t\t\twl->psm_entry_retry++;\n\t\t\tret = wl1251_ps_set_mode(wl, STATION_POWER_SAVE_MODE);\n\t\t} else {\n\t\t\twl1251_error(\"Power save entry failed, giving up\");\n\t\t\twl->psm_entry_retry = 0;\n\t\t}\n\t\tbreak;\n\tcase EVENT_ENTER_POWER_SAVE_SUCCESS:\n\tcase EVENT_EXIT_POWER_SAVE_FAIL:\n\tcase EVENT_EXIT_POWER_SAVE_SUCCESS:\n\tdefault:\n\t\twl->psm_entry_retry = 0;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void wl1251_event_mbox_dump(struct event_mailbox *mbox)\n{\n\twl1251_debug(DEBUG_EVENT, \"MBOX DUMP:\");\n\twl1251_debug(DEBUG_EVENT, \"\\tvector: 0x%x\", mbox->events_vector);\n\twl1251_debug(DEBUG_EVENT, \"\\tmask: 0x%x\", mbox->events_mask);\n}\n\nstatic int wl1251_event_process(struct wl1251 *wl, struct event_mailbox *mbox)\n{\n\tint ret;\n\tu32 vector;\n\n\twl1251_event_mbox_dump(mbox);\n\n\tvector = mbox->events_vector & ~(mbox->events_mask);\n\twl1251_debug(DEBUG_EVENT, \"vector: 0x%x\", vector);\n\n\tif (vector & SCAN_COMPLETE_EVENT_ID) {\n\t\tret = wl1251_event_scan_complete(wl, mbox);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (vector & BSS_LOSE_EVENT_ID) {\n\t\twl1251_debug(DEBUG_EVENT, \"BSS_LOSE_EVENT\");\n\n\t\tif (wl->psm_requested &&\n\t\t    wl->station_mode != STATION_ACTIVE_MODE) {\n\t\t\tret = wl1251_ps_set_mode(wl, STATION_ACTIVE_MODE);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (vector & PS_REPORT_EVENT_ID) {\n\t\twl1251_debug(DEBUG_EVENT, \"PS_REPORT_EVENT\");\n\t\tret = wl1251_event_ps_report(wl, mbox);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (vector & SYNCHRONIZATION_TIMEOUT_EVENT_ID) {\n\t\twl1251_debug(DEBUG_EVENT, \"SYNCHRONIZATION_TIMEOUT_EVENT\");\n\n\t\t \n\t\tif (wl->vif && wl->vif->type == NL80211_IFTYPE_STATION)\n\t\t\tieee80211_beacon_loss(wl->vif);\n\t}\n\n\tif (vector & REGAINED_BSS_EVENT_ID) {\n\t\tif (wl->psm_requested) {\n\t\t\tret = wl1251_ps_set_mode(wl, STATION_POWER_SAVE_MODE);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (wl->vif && wl->rssi_thold) {\n\t\tif (vector & ROAMING_TRIGGER_LOW_RSSI_EVENT_ID) {\n\t\t\twl1251_debug(DEBUG_EVENT,\n\t\t\t\t     \"ROAMING_TRIGGER_LOW_RSSI_EVENT\");\n\t\t\tieee80211_cqm_rssi_notify(wl->vif,\n\t\t\t\tNL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,\n\t\t\t\t0, GFP_KERNEL);\n\t\t}\n\n\t\tif (vector & ROAMING_TRIGGER_REGAINED_RSSI_EVENT_ID) {\n\t\t\twl1251_debug(DEBUG_EVENT,\n\t\t\t\t     \"ROAMING_TRIGGER_REGAINED_RSSI_EVENT\");\n\t\t\tieee80211_cqm_rssi_notify(wl->vif,\n\t\t\t\tNL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,\n\t\t\t\t0, GFP_KERNEL);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint wl1251_event_wait(struct wl1251 *wl, u32 mask, int timeout_ms)\n{\n\tu32 events_vector, event;\n\tunsigned long timeout;\n\n\ttimeout = jiffies + msecs_to_jiffies(timeout_ms);\n\n\tdo {\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -ETIMEDOUT;\n\n\t\tmsleep(1);\n\n\t\t \n\t\tevents_vector = wl1251_mem_read32(wl, wl->mbox_ptr[0]);\n\t\tevent = events_vector & mask;\n\t\tevents_vector = wl1251_mem_read32(wl, wl->mbox_ptr[1]);\n\t\tevent |= events_vector & mask;\n\t} while (!event);\n\n\treturn 0;\n}\n\nint wl1251_event_unmask(struct wl1251 *wl)\n{\n\tint ret;\n\n\tret = wl1251_acx_event_mbox_mask(wl, ~(wl->event_mask));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nvoid wl1251_event_mbox_config(struct wl1251 *wl)\n{\n\twl->mbox_ptr[0] = wl1251_reg_read32(wl, REG_EVENT_MAILBOX_PTR);\n\twl->mbox_ptr[1] = wl->mbox_ptr[0] + sizeof(struct event_mailbox);\n\n\twl1251_debug(DEBUG_EVENT, \"MBOX ptrs: 0x%x 0x%x\",\n\t\t     wl->mbox_ptr[0], wl->mbox_ptr[1]);\n}\n\nint wl1251_event_handle(struct wl1251 *wl, u8 mbox_num)\n{\n\tstruct event_mailbox *mbox;\n\tint ret;\n\n\twl1251_debug(DEBUG_EVENT, \"EVENT on mbox %d\", mbox_num);\n\n\tif (mbox_num > 1)\n\t\treturn -EINVAL;\n\n\tmbox = kmalloc(sizeof(*mbox), GFP_KERNEL);\n\tif (!mbox) {\n\t\twl1251_error(\"can not allocate mbox buffer\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\twl1251_mem_read(wl, wl->mbox_ptr[mbox_num], mbox,\n\t\t\tsizeof(*mbox));\n\n\t \n\tret = wl1251_event_process(wl, mbox);\n\tkfree(mbox);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\twl1251_reg_write32(wl, ACX_REG_INTERRUPT_TRIG, INTR_TRIG_EVENT_ACK);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}