{
  "module_name": "boot.c",
  "hash_id": "340a1d77f2c46058963d6986b958d9e6064aae30af9e16a5704e6d623b5a2018",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wl1251/boot.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n\n#include \"reg.h\"\n#include \"boot.h\"\n#include \"io.h\"\n#include \"spi.h\"\n#include \"event.h\"\n#include \"acx.h\"\n\nvoid wl1251_boot_target_enable_interrupts(struct wl1251 *wl)\n{\n\twl1251_reg_write32(wl, ACX_REG_INTERRUPT_MASK, ~(wl->intr_mask));\n\twl1251_reg_write32(wl, HI_CFG, HI_CFG_DEF_VAL);\n}\n\nint wl1251_boot_soft_reset(struct wl1251 *wl)\n{\n\tunsigned long timeout;\n\tu32 boot_data;\n\n\t \n\twl1251_reg_write32(wl, ACX_REG_SLV_SOFT_RESET, ACX_SLV_SOFT_RESET_BIT);\n\n\t \n\ttimeout = jiffies + usecs_to_jiffies(SOFT_RESET_MAX_TIME);\n\twhile (1) {\n\t\tboot_data = wl1251_reg_read32(wl, ACX_REG_SLV_SOFT_RESET);\n\t\twl1251_debug(DEBUG_BOOT, \"soft reset bootdata 0x%x\", boot_data);\n\t\tif ((boot_data & ACX_SLV_SOFT_RESET_BIT) == 0)\n\t\t\tbreak;\n\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\t \n\t\t\twl1251_error(\"soft reset timeout\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tudelay(SOFT_RESET_STALL_TIME);\n\t}\n\n\t \n\twl1251_reg_write32(wl, ENABLE, 0x0);\n\n\t \n\twl1251_reg_write32(wl, SPARE_A2, 0xffff);\n\n\treturn 0;\n}\n\nint wl1251_boot_init_seq(struct wl1251 *wl)\n{\n\tu32 scr_pad6, init_data, tmp, elp_cmd, ref_freq;\n\n\t \n\tstatic const u32 LUT[REF_FREQ_NUM][LUT_PARAM_NUM] = {\n\n\t\t{   83, 87381,  0xB, 5, 0xF00,  3},  \n\t\t{   61, 141154, 0xB, 5, 0x1450, 2},  \n\t\t{   41, 174763, 0xC, 6, 0x2D00, 1},  \n\t\t{   40, 0,      0xC, 6, 0x2EE0, 1},  \n\t\t{   47, 162280, 0xC, 6, 0x2760, 1}   \n\t};\n\n\t \n\tscr_pad6 = wl1251_reg_read32(wl, SCR_PAD6);\n\twl1251_debug(DEBUG_BOOT, \"scr_pad6 0x%x\", scr_pad6);\n\n\t \n\telp_cmd = wl1251_reg_read32(wl, ELP_CMD);\n\twl1251_debug(DEBUG_BOOT, \"elp_cmd 0x%x\", elp_cmd);\n\n\t \n\tref_freq = scr_pad6 & 0x000000FF;\n\twl1251_debug(DEBUG_BOOT, \"ref_freq 0x%x\", ref_freq);\n\n\twl1251_reg_write32(wl, PLL_CAL_TIME, 0x9);\n\n\t \n\twl1251_reg_write32(wl, CLK_BUF_TIME, 0x6);\n\n\t \n\ttmp = ((scr_pad6 & 0x0000FF00) << 4) | 0x00004000;\n\twl1251_reg_write32(wl, ELP_CFG_MODE, tmp);\n\n\t \n\telp_cmd |= 0x00000040;\n\twl1251_reg_write32(wl, ELP_CMD, elp_cmd);\n\n\t \n\twl1251_reg_write32(wl, CFG_PLL_SYNC_CNT, 0x20);\n\n\t \n\tinit_data = wl1251_reg_read32(wl, CLK_REQ_TIME);\n\n\t \n\tif (init_data > 0x21)\n\t\ttmp = init_data - 0x21;\n\telse\n\t\ttmp = 0;\n\twl1251_reg_write32(wl, CLK_REQ_TIME, tmp);\n\n\t \n\twl1251_reg_write32(wl, 0x003058cc, 0x4B5);\n\n\t \n\twl1251_reg_write32(wl, 0x003058d4, 0x50);\n\n\t \n\twl1251_reg_write32(wl, 0x00305948, 0x11c001);\n\n\t \n\twl1251_reg_write32(wl, 0x003058f4, 0x1e);\n\n\t \n\ttmp = LUT[ref_freq][LUT_PARAM_INTEGER_DIVIDER] | 0x00017000;\n\twl1251_reg_write32(wl, 0x00305840, tmp);\n\n\t \n\ttmp = LUT[ref_freq][LUT_PARAM_FRACTIONAL_DIVIDER];\n\twl1251_reg_write32(wl, 0x00305844, tmp);\n\n\t \n\twl1251_reg_write32(wl, 0x00305848, 0x3039);\n\n\t \n\ttmp = (LUT[ref_freq][LUT_PARAM_ATTN_BB] << 16) |\n\t\t(LUT[ref_freq][LUT_PARAM_ALPHA_BB] << 12) | 0x1;\n\twl1251_reg_write32(wl, 0x00305854, tmp);\n\n\t \n\ttmp = LUT[ref_freq][LUT_PARAM_STOP_TIME_BB] | 0x000A0000;\n\twl1251_reg_write32(wl, 0x00305858, tmp);\n\n\t \n\ttmp = LUT[ref_freq][LUT_PARAM_BB_PLL_LOOP_FILTER] | 0x00000030;\n\twl1251_reg_write32(wl, 0x003058f8, tmp);\n\n\t \n\twl1251_reg_write32(wl, 0x003058f0, 0x29);\n\n\t \n\twl1251_reg_write32(wl, ELP_CMD, elp_cmd | 0x1);\n\n\t \n\tudelay(2000);\n\n\treturn 0;\n}\n\nstatic void wl1251_boot_set_ecpu_ctrl(struct wl1251 *wl, u32 flag)\n{\n\tu32 cpu_ctrl;\n\n\t \n\tcpu_ctrl = wl1251_reg_read32(wl, ACX_REG_ECPU_CONTROL);\n\n\t \n\tcpu_ctrl &= ~flag;\n\twl1251_reg_write32(wl, ACX_REG_ECPU_CONTROL, cpu_ctrl);\n}\n\nint wl1251_boot_run_firmware(struct wl1251 *wl)\n{\n\tint loop, ret;\n\tu32 chip_id, acx_intr;\n\n\twl1251_boot_set_ecpu_ctrl(wl, ECPU_CONTROL_HALT);\n\n\tchip_id = wl1251_reg_read32(wl, CHIP_ID_B);\n\n\twl1251_debug(DEBUG_BOOT, \"chip id after firmware boot: 0x%x\", chip_id);\n\n\tif (chip_id != wl->chip_id) {\n\t\twl1251_error(\"chip id doesn't match after firmware boot\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tloop = 0;\n\twhile (loop++ < INIT_LOOP) {\n\t\tudelay(INIT_LOOP_DELAY);\n\t\tacx_intr = wl1251_reg_read32(wl, ACX_REG_INTERRUPT_NO_CLEAR);\n\n\t\tif (acx_intr == 0xffffffff) {\n\t\t\twl1251_error(\"error reading hardware complete \"\n\t\t\t\t     \"init indication\");\n\t\t\treturn -EIO;\n\t\t}\n\t\t \n\t\telse if (acx_intr & WL1251_ACX_INTR_INIT_COMPLETE) {\n\t\t\twl1251_reg_write32(wl, ACX_REG_INTERRUPT_ACK,\n\t\t\t\t\t   WL1251_ACX_INTR_INIT_COMPLETE);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (loop > INIT_LOOP) {\n\t\twl1251_error(\"timeout waiting for the hardware to \"\n\t\t\t     \"complete initialization\");\n\t\treturn -EIO;\n\t}\n\n\t \n\twl->cmd_box_addr = wl1251_reg_read32(wl, REG_COMMAND_MAILBOX_PTR);\n\n\t \n\twl->event_box_addr = wl1251_reg_read32(wl, REG_EVENT_MAILBOX_PTR);\n\n\t \n\twl1251_set_partition(wl, WL1251_PART_WORK_MEM_START,\n\t\t\t     WL1251_PART_WORK_MEM_SIZE,\n\t\t\t     WL1251_PART_WORK_REG_START,\n\t\t\t     WL1251_PART_WORK_REG_SIZE);\n\n\twl1251_debug(DEBUG_MAILBOX, \"cmd_box_addr 0x%x event_box_addr 0x%x\",\n\t\t     wl->cmd_box_addr, wl->event_box_addr);\n\n\twl1251_acx_fw_version(wl, wl->fw_ver, sizeof(wl->fw_ver));\n\n\t \n\n\t \n\twl1251_enable_interrupts(wl);\n\n\t \n\twl->intr_mask = WL1251_ACX_INTR_RX0_DATA |\n\t\tWL1251_ACX_INTR_RX1_DATA |\n\t\tWL1251_ACX_INTR_TX_RESULT |\n\t\tWL1251_ACX_INTR_EVENT_A |\n\t\tWL1251_ACX_INTR_EVENT_B |\n\t\tWL1251_ACX_INTR_INIT_COMPLETE;\n\twl1251_boot_target_enable_interrupts(wl);\n\n\twl->event_mask = SCAN_COMPLETE_EVENT_ID | BSS_LOSE_EVENT_ID |\n\t\tSYNCHRONIZATION_TIMEOUT_EVENT_ID |\n\t\tROAMING_TRIGGER_LOW_RSSI_EVENT_ID |\n\t\tROAMING_TRIGGER_REGAINED_RSSI_EVENT_ID |\n\t\tREGAINED_BSS_EVENT_ID | BT_PTA_SENSE_EVENT_ID |\n\t\tBT_PTA_PREDICTION_EVENT_ID | JOIN_EVENT_COMPLETE_ID |\n\t\tPS_REPORT_EVENT_ID;\n\n\tret = wl1251_event_unmask(wl);\n\tif (ret < 0) {\n\t\twl1251_error(\"EVENT mask setting failed\");\n\t\treturn ret;\n\t}\n\n\twl1251_event_mbox_config(wl);\n\n\t \n\treturn 0;\n}\n\nstatic int wl1251_boot_upload_firmware(struct wl1251 *wl)\n{\n\tint addr, chunk_num, partition_limit;\n\tsize_t fw_data_len, len;\n\tu8 *p, *buf;\n\n\t \n\n\twl1251_debug(DEBUG_BOOT, \"chip id before fw upload: 0x%x\",\n\t\t     wl1251_reg_read32(wl, CHIP_ID_B));\n\n\t \n\tfw_data_len =  (wl->fw[4] << 24) | (wl->fw[5] << 16) |\n\t\t(wl->fw[6] << 8) | (wl->fw[7]);\n\n\twl1251_debug(DEBUG_BOOT, \"fw_data_len %zu chunk_size %d\", fw_data_len,\n\t\tCHUNK_SIZE);\n\n\tif ((fw_data_len % 4) != 0) {\n\t\twl1251_error(\"firmware length not multiple of four\");\n\t\treturn -EIO;\n\t}\n\n\tbuf = kmalloc(CHUNK_SIZE, GFP_KERNEL);\n\tif (!buf) {\n\t\twl1251_error(\"allocation for firmware upload chunk failed\");\n\t\treturn -ENOMEM;\n\t}\n\n\twl1251_set_partition(wl, WL1251_PART_DOWN_MEM_START,\n\t\t\t     WL1251_PART_DOWN_MEM_SIZE,\n\t\t\t     WL1251_PART_DOWN_REG_START,\n\t\t\t     WL1251_PART_DOWN_REG_SIZE);\n\n\t \n\tchunk_num = 0;\n\tpartition_limit = WL1251_PART_DOWN_MEM_SIZE;\n\n\twhile (chunk_num < fw_data_len / CHUNK_SIZE) {\n\t\t \n\t\taddr = WL1251_PART_DOWN_MEM_START +\n\t\t\t(chunk_num + 2) * CHUNK_SIZE;\n\t\tif (addr > partition_limit) {\n\t\t\taddr = WL1251_PART_DOWN_MEM_START +\n\t\t\t\tchunk_num * CHUNK_SIZE;\n\t\t\tpartition_limit = chunk_num * CHUNK_SIZE +\n\t\t\t\tWL1251_PART_DOWN_MEM_SIZE;\n\t\t\twl1251_set_partition(wl,\n\t\t\t\t\t     addr,\n\t\t\t\t\t     WL1251_PART_DOWN_MEM_SIZE,\n\t\t\t\t\t     WL1251_PART_DOWN_REG_START,\n\t\t\t\t\t     WL1251_PART_DOWN_REG_SIZE);\n\t\t}\n\n\t\t \n\t\taddr = WL1251_PART_DOWN_MEM_START + chunk_num * CHUNK_SIZE;\n\t\tp = wl->fw + FW_HDR_SIZE + chunk_num * CHUNK_SIZE;\n\t\twl1251_debug(DEBUG_BOOT, \"uploading fw chunk 0x%p to 0x%x\",\n\t\t\t     p, addr);\n\n\t\t \n\t\tlen = CHUNK_SIZE;\n\t\tmemcpy(buf, p, len);\n\t\twl1251_mem_write(wl, addr, buf, len);\n\n\t\tchunk_num++;\n\t}\n\n\t \n\taddr = WL1251_PART_DOWN_MEM_START + chunk_num * CHUNK_SIZE;\n\tp = wl->fw + FW_HDR_SIZE + chunk_num * CHUNK_SIZE;\n\n\t \n\tlen = fw_data_len % CHUNK_SIZE;\n\tmemcpy(buf, p, len);\n\n\twl1251_debug(DEBUG_BOOT, \"uploading fw last chunk (%zu B) 0x%p to 0x%x\",\n\t\t     len, p, addr);\n\twl1251_mem_write(wl, addr, buf, len);\n\n\tkfree(buf);\n\n\treturn 0;\n}\n\nstatic int wl1251_boot_upload_nvs(struct wl1251 *wl)\n{\n\tsize_t nvs_len, nvs_bytes_written, burst_len;\n\tint nvs_start, i;\n\tu32 dest_addr, val;\n\tu8 *nvs_ptr, *nvs;\n\n\tnvs = wl->nvs;\n\tif (nvs == NULL)\n\t\treturn -ENODEV;\n\n\tnvs_ptr = nvs;\n\n\tnvs_len = wl->nvs_len;\n\tnvs_start = wl->fw_len;\n\n\t \n\n\twhile (nvs_ptr[0]) {\n\t\tburst_len = nvs_ptr[0];\n\t\tdest_addr = (nvs_ptr[1] & 0xfe) | ((u32)(nvs_ptr[2] << 8));\n\n\t\t \n\t\tnvs_ptr += 3;\n\n\t\tfor (i = 0; i < burst_len; i++) {\n\t\t\tval = (nvs_ptr[0] | (nvs_ptr[1] << 8)\n\t\t\t       | (nvs_ptr[2] << 16) | (nvs_ptr[3] << 24));\n\n\t\t\twl1251_debug(DEBUG_BOOT,\n\t\t\t\t     \"nvs burst write 0x%x: 0x%x\",\n\t\t\t\t     dest_addr, val);\n\t\t\twl1251_mem_write32(wl, dest_addr, val);\n\n\t\t\tnvs_ptr += 4;\n\t\t\tdest_addr += 4;\n\t\t}\n\t}\n\n\t \n\tnvs_ptr += 7;\n\tnvs_len -= nvs_ptr - nvs;\n\tnvs_len = ALIGN(nvs_len, 4);\n\n\t \n\twl1251_set_partition(wl, nvs_start,\n\t\t\t     WL1251_PART_DOWN_MEM_SIZE,\n\t\t\t     WL1251_PART_DOWN_REG_START,\n\t\t\t     WL1251_PART_DOWN_REG_SIZE);\n\n\t \n\tnvs_bytes_written = 0;\n\twhile (nvs_bytes_written < nvs_len) {\n\t\tval = (nvs_ptr[0] | (nvs_ptr[1] << 8)\n\t\t       | (nvs_ptr[2] << 16) | (nvs_ptr[3] << 24));\n\n\t\twl1251_debug(DEBUG_BOOT,\n\t\t\t     \"nvs write table 0x%x: 0x%x\",\n\t\t\t     nvs_start, val);\n\t\twl1251_mem_write32(wl, nvs_start, val);\n\n\t\tnvs_ptr += 4;\n\t\tnvs_bytes_written += 4;\n\t\tnvs_start += 4;\n\t}\n\n\treturn 0;\n}\n\nint wl1251_boot(struct wl1251 *wl)\n{\n\tint ret = 0, minor_minor_e2_ver;\n\tu32 tmp, boot_data;\n\n\t \n\twl1251_reg_write32(wl, ACX_REG_ECPU_CONTROL, ECPU_CONTROL_HALT);\n\n\tret = wl1251_boot_soft_reset(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tif (wl->use_eeprom) {\n\t\twl1251_reg_write32(wl, ACX_REG_EE_START, START_EEPROM_MGR);\n\t\t \n\t\tmsleep(40);\n\t\twl1251_reg_write32(wl, ACX_EEPROMLESS_IND_REG, USE_EEPROM);\n\t} else {\n\t\tret = wl1251_boot_upload_nvs(wl);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t \n\t\twl1251_reg_write32(wl, ACX_EEPROMLESS_IND_REG, wl->fw_len);\n\t}\n\n\t \n\ttmp = wl1251_reg_read32(wl, SCR_PAD2);\n\n\t \n\twl->boot_attr.radio_type = (tmp & 0x0000FF00) >> 8;\n\twl->boot_attr.major = (tmp & 0x00FF0000) >> 16;\n\ttmp = wl1251_reg_read32(wl, SCR_PAD3);\n\n\t \n\twl->boot_attr.minor = (tmp & 0x00FF0000) >> 16;\n\tminor_minor_e2_ver = (tmp & 0xFF000000) >> 24;\n\n\twl1251_debug(DEBUG_BOOT, \"radioType 0x%x majorE2Ver 0x%x \"\n\t\t     \"minorE2Ver 0x%x minor_minor_e2_ver 0x%x\",\n\t\t     wl->boot_attr.radio_type, wl->boot_attr.major,\n\t\t     wl->boot_attr.minor, minor_minor_e2_ver);\n\n\tret = wl1251_boot_init_seq(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tboot_data = wl1251_reg_read32(wl, ACX_REG_ECPU_CONTROL);\n\n\twl1251_debug(DEBUG_BOOT, \"halt boot_data 0x%x\", boot_data);\n\n\t \n\tif ((boot_data & ECPU_CONTROL_HALT) == 0) {\n\t\twl1251_error(\"boot failed, ECPU_CONTROL_HALT not set\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = wl1251_boot_upload_firmware(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = wl1251_boot_run_firmware(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\nout:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}