{
  "module_name": "cmd.c",
  "hash_id": "a117105a534be8cafccc2ed6930c89f5bcbbb980de006ff42086525de240121a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wl1251/cmd.c",
  "human_readable_source": "\n#include \"cmd.h\"\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/etherdevice.h>\n\n#include \"wl1251.h\"\n#include \"reg.h\"\n#include \"io.h\"\n#include \"ps.h\"\n#include \"acx.h\"\n\n \nint wl1251_cmd_send(struct wl1251 *wl, u16 id, void *buf, size_t len)\n{\n\tstruct wl1251_cmd_header *cmd;\n\tunsigned long timeout;\n\tu32 intr;\n\tint ret = 0;\n\n\tcmd = buf;\n\tcmd->id = id;\n\tcmd->status = 0;\n\n\tWARN_ON(len % 4 != 0);\n\n\twl1251_mem_write(wl, wl->cmd_box_addr, buf, len);\n\n\twl1251_reg_write32(wl, ACX_REG_INTERRUPT_TRIG, INTR_TRIG_CMD);\n\n\ttimeout = jiffies + msecs_to_jiffies(WL1251_COMMAND_TIMEOUT);\n\n\tintr = wl1251_reg_read32(wl, ACX_REG_INTERRUPT_NO_CLEAR);\n\twhile (!(intr & WL1251_ACX_INTR_CMD_COMPLETE)) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\twl1251_error(\"command complete timeout\");\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmsleep(1);\n\n\t\tintr = wl1251_reg_read32(wl, ACX_REG_INTERRUPT_NO_CLEAR);\n\t}\n\n\twl1251_reg_write32(wl, ACX_REG_INTERRUPT_ACK,\n\t\t\t   WL1251_ACX_INTR_CMD_COMPLETE);\n\nout:\n\treturn ret;\n}\n\n \nint wl1251_cmd_test(struct wl1251 *wl, void *buf, size_t buf_len, u8 answer)\n{\n\tint ret;\n\n\twl1251_debug(DEBUG_CMD, \"cmd test\");\n\n\tret = wl1251_cmd_send(wl, CMD_TEST, buf, buf_len);\n\n\tif (ret < 0) {\n\t\twl1251_warning(\"TEST command failed\");\n\t\treturn ret;\n\t}\n\n\tif (answer) {\n\t\tstruct wl1251_command *cmd_answer;\n\n\t\t \n\t\twl1251_mem_read(wl, wl->cmd_box_addr, buf, buf_len);\n\n\t\tcmd_answer = buf;\n\n\t\tif (cmd_answer->header.status != CMD_STATUS_SUCCESS)\n\t\t\twl1251_error(\"TEST command answer error: %d\",\n\t\t\t\t     cmd_answer->header.status);\n\t}\n\n\treturn 0;\n}\n\n \nint wl1251_cmd_interrogate(struct wl1251 *wl, u16 id, void *buf, size_t len)\n{\n\tstruct acx_header *acx = buf;\n\tint ret;\n\n\twl1251_debug(DEBUG_CMD, \"cmd interrogate\");\n\n\tacx->id = id;\n\n\t \n\tacx->len = len - sizeof(*acx);\n\n\tret = wl1251_cmd_send(wl, CMD_INTERROGATE, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1251_error(\"INTERROGATE command failed\");\n\t\tgoto out;\n\t}\n\n\t \n\twl1251_mem_read(wl, wl->cmd_box_addr, buf, len);\n\n\tacx = buf;\n\tif (acx->cmd.status != CMD_STATUS_SUCCESS)\n\t\twl1251_error(\"INTERROGATE command error: %d\",\n\t\t\t     acx->cmd.status);\n\nout:\n\treturn ret;\n}\n\n \nint wl1251_cmd_configure(struct wl1251 *wl, u16 id, void *buf, size_t len)\n{\n\tstruct acx_header *acx = buf;\n\tint ret;\n\n\twl1251_debug(DEBUG_CMD, \"cmd configure\");\n\n\tacx->id = id;\n\n\t \n\tacx->len = len - sizeof(*acx);\n\n\tret = wl1251_cmd_send(wl, CMD_CONFIGURE, acx, len);\n\tif (ret < 0) {\n\t\twl1251_warning(\"CONFIGURE command NOK\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint wl1251_cmd_vbm(struct wl1251 *wl, u8 identity,\n\t\t   void *bitmap, u16 bitmap_len, u8 bitmap_control)\n{\n\tstruct wl1251_cmd_vbm_update *vbm;\n\tint ret;\n\n\twl1251_debug(DEBUG_CMD, \"cmd vbm\");\n\n\tvbm = kzalloc(sizeof(*vbm), GFP_KERNEL);\n\tif (!vbm)\n\t\treturn -ENOMEM;\n\n\t \n\tvbm->tim.bitmap_ctrl = bitmap_control;\n\tif (bitmap_len > PARTIAL_VBM_MAX) {\n\t\twl1251_warning(\"cmd vbm len is %d B, truncating to %d\",\n\t\t\t       bitmap_len, PARTIAL_VBM_MAX);\n\t\tbitmap_len = PARTIAL_VBM_MAX;\n\t}\n\tmemcpy(vbm->tim.pvb_field, bitmap, bitmap_len);\n\tvbm->tim.identity = identity;\n\tvbm->tim.length = bitmap_len + 3;\n\n\tvbm->len = cpu_to_le16(bitmap_len + 5);\n\n\tret = wl1251_cmd_send(wl, CMD_VBM, vbm, sizeof(*vbm));\n\tif (ret < 0) {\n\t\twl1251_error(\"VBM command failed\");\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(vbm);\n\treturn ret;\n}\n\nint wl1251_cmd_data_path_rx(struct wl1251 *wl, u8 channel, bool enable)\n{\n\tstruct cmd_enabledisable_path *cmd;\n\tint ret;\n\tu16 cmd_rx;\n\n\twl1251_debug(DEBUG_CMD, \"cmd data path\");\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->channel = channel;\n\n\tif (enable)\n\t\tcmd_rx = CMD_ENABLE_RX;\n\telse\n\t\tcmd_rx = CMD_DISABLE_RX;\n\n\tret = wl1251_cmd_send(wl, cmd_rx, cmd, sizeof(*cmd));\n\tif (ret < 0) {\n\t\twl1251_error(\"rx %s cmd for channel %d failed\",\n\t\t\t     enable ? \"start\" : \"stop\", channel);\n\t\tgoto out;\n\t}\n\n\twl1251_debug(DEBUG_BOOT, \"rx %s cmd channel %d\",\n\t\t     enable ? \"start\" : \"stop\", channel);\n\nout:\n\tkfree(cmd);\n\treturn ret;\n}\n\nint wl1251_cmd_data_path_tx(struct wl1251 *wl, u8 channel, bool enable)\n{\n\tstruct cmd_enabledisable_path *cmd;\n\tint ret;\n\tu16 cmd_tx;\n\n\twl1251_debug(DEBUG_CMD, \"cmd data path\");\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->channel = channel;\n\n\tif (enable)\n\t\tcmd_tx = CMD_ENABLE_TX;\n\telse\n\t\tcmd_tx = CMD_DISABLE_TX;\n\n\tret = wl1251_cmd_send(wl, cmd_tx, cmd, sizeof(*cmd));\n\tif (ret < 0)\n\t\twl1251_error(\"tx %s cmd for channel %d failed\",\n\t\t\t     enable ? \"start\" : \"stop\", channel);\n\telse\n\t\twl1251_debug(DEBUG_BOOT, \"tx %s cmd channel %d\",\n\t\t\t     enable ? \"start\" : \"stop\", channel);\n\n\tkfree(cmd);\n\treturn ret;\n}\n\nint wl1251_cmd_join(struct wl1251 *wl, u8 bss_type, u8 channel,\n\t\t    u16 beacon_interval, u8 dtim_interval)\n{\n\tstruct cmd_join *join;\n\tint ret, i;\n\tu8 *bssid;\n\n\tjoin = kzalloc(sizeof(*join), GFP_KERNEL);\n\tif (!join)\n\t\treturn -ENOMEM;\n\n\twl1251_debug(DEBUG_CMD, \"cmd join%s ch %d %d/%d\",\n\t\t     bss_type == BSS_TYPE_IBSS ? \" ibss\" : \"\",\n\t\t     channel, beacon_interval, dtim_interval);\n\n\t \n\tbssid = (u8 *) &join->bssid_lsb;\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tbssid[i] = wl->bssid[ETH_ALEN - i - 1];\n\n\tjoin->rx_config_options = wl->rx_config;\n\tjoin->rx_filter_options = wl->rx_filter;\n\n\tjoin->basic_rate_set = RATE_MASK_1MBPS | RATE_MASK_2MBPS |\n\t\tRATE_MASK_5_5MBPS | RATE_MASK_11MBPS;\n\n\tjoin->beacon_interval = beacon_interval;\n\tjoin->dtim_interval = dtim_interval;\n\tjoin->bss_type = bss_type;\n\tjoin->channel = channel;\n\tjoin->ctrl = JOIN_CMD_CTRL_TX_FLUSH;\n\n\tret = wl1251_cmd_send(wl, CMD_START_JOIN, join, sizeof(*join));\n\tif (ret < 0) {\n\t\twl1251_error(\"failed to initiate cmd join\");\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(join);\n\treturn ret;\n}\n\nint wl1251_cmd_ps_mode(struct wl1251 *wl, u8 ps_mode)\n{\n\tstruct wl1251_cmd_ps_params *ps_params = NULL;\n\tint ret = 0;\n\n\twl1251_debug(DEBUG_CMD, \"cmd set ps mode\");\n\n\tps_params = kzalloc(sizeof(*ps_params), GFP_KERNEL);\n\tif (!ps_params)\n\t\treturn -ENOMEM;\n\n\tps_params->ps_mode = ps_mode;\n\tps_params->send_null_data = 1;\n\tps_params->retries = 5;\n\tps_params->hang_over_period = 128;\n\tps_params->null_data_rate = 1;  \n\n\tret = wl1251_cmd_send(wl, CMD_SET_PS_MODE, ps_params,\n\t\t\t      sizeof(*ps_params));\n\tif (ret < 0) {\n\t\twl1251_error(\"cmd set_ps_mode failed\");\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(ps_params);\n\treturn ret;\n}\n\nint wl1251_cmd_read_memory(struct wl1251 *wl, u32 addr, void *answer,\n\t\t\t   size_t len)\n{\n\tstruct cmd_read_write_memory *cmd;\n\tint ret = 0;\n\n\twl1251_debug(DEBUG_CMD, \"cmd read memory\");\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tWARN_ON(len > MAX_READ_SIZE);\n\tlen = min_t(size_t, len, MAX_READ_SIZE);\n\n\tcmd->addr = addr;\n\tcmd->size = len;\n\n\tret = wl1251_cmd_send(wl, CMD_READ_MEMORY, cmd, sizeof(*cmd));\n\tif (ret < 0) {\n\t\twl1251_error(\"read memory command failed: %d\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\twl1251_mem_read(wl, wl->cmd_box_addr, cmd, sizeof(*cmd));\n\n\tif (cmd->header.status != CMD_STATUS_SUCCESS)\n\t\twl1251_error(\"error in read command result: %d\",\n\t\t\t     cmd->header.status);\n\n\tmemcpy(answer, cmd->value, len);\n\nout:\n\tkfree(cmd);\n\treturn ret;\n}\n\nint wl1251_cmd_template_set(struct wl1251 *wl, u16 cmd_id,\n\t\t\t    void *buf, size_t buf_len)\n{\n\tstruct wl1251_cmd_packet_template *cmd;\n\tsize_t cmd_len;\n\tint ret = 0;\n\n\twl1251_debug(DEBUG_CMD, \"cmd template %d\", cmd_id);\n\n\tWARN_ON(buf_len > WL1251_MAX_TEMPLATE_SIZE);\n\tbuf_len = min_t(size_t, buf_len, WL1251_MAX_TEMPLATE_SIZE);\n\tcmd_len = ALIGN(sizeof(*cmd) + buf_len, 4);\n\n\tcmd = kzalloc(cmd_len, GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->size = cpu_to_le16(buf_len);\n\n\tif (buf)\n\t\tmemcpy(cmd->data, buf, buf_len);\n\n\tret = wl1251_cmd_send(wl, cmd_id, cmd, cmd_len);\n\tif (ret < 0) {\n\t\twl1251_warning(\"cmd set_template failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(cmd);\n\treturn ret;\n}\n\nint wl1251_cmd_scan(struct wl1251 *wl, u8 *ssid, size_t ssid_len,\n\t\t    struct ieee80211_channel *channels[],\n\t\t    unsigned int n_channels, unsigned int n_probes)\n{\n\tstruct wl1251_cmd_scan *cmd;\n\tint i, ret = 0;\n\n\twl1251_debug(DEBUG_CMD, \"cmd scan channels %d\", n_channels);\n\n\tWARN_ON(n_channels > SCAN_MAX_NUM_OF_CHANNELS);\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->params.rx_config_options = cpu_to_le32(CFG_RX_ALL_GOOD);\n\tcmd->params.rx_filter_options = cpu_to_le32(CFG_RX_PRSP_EN |\n\t\t\t\t\t\t    CFG_RX_MGMT_EN |\n\t\t\t\t\t\t    CFG_RX_BCN_EN);\n\tcmd->params.scan_options = 0;\n\t \n\tif (is_zero_ether_addr(wl->bssid))\n\t\tcmd->params.scan_options |= cpu_to_le16(WL1251_SCAN_OPT_PRIORITY_HIGH);\n\tcmd->params.num_channels = n_channels;\n\tcmd->params.num_probe_requests = n_probes;\n\tcmd->params.tx_rate = cpu_to_le16(1 << 1);  \n\tcmd->params.tid_trigger = 0;\n\n\tfor (i = 0; i < n_channels; i++) {\n\t\tcmd->channels[i].min_duration =\n\t\t\tcpu_to_le32(WL1251_SCAN_MIN_DURATION);\n\t\tcmd->channels[i].max_duration =\n\t\t\tcpu_to_le32(WL1251_SCAN_MAX_DURATION);\n\t\tmemset(&cmd->channels[i].bssid_lsb, 0xff, 4);\n\t\tmemset(&cmd->channels[i].bssid_msb, 0xff, 2);\n\t\tcmd->channels[i].early_termination = 0;\n\t\tcmd->channels[i].tx_power_att = 0;\n\t\tcmd->channels[i].channel = channels[i]->hw_value;\n\t}\n\n\tif (ssid) {\n\t\tint len = clamp_val(ssid_len, 0, IEEE80211_MAX_SSID_LEN);\n\n\t\tcmd->params.ssid_len = len;\n\t\tmemcpy(cmd->params.ssid, ssid, len);\n\t}\n\n\tret = wl1251_cmd_send(wl, CMD_SCAN, cmd, sizeof(*cmd));\n\tif (ret < 0) {\n\t\twl1251_error(\"cmd scan failed: %d\", ret);\n\t\tgoto out;\n\t}\n\n\twl1251_mem_read(wl, wl->cmd_box_addr, cmd, sizeof(*cmd));\n\n\tif (cmd->header.status != CMD_STATUS_SUCCESS) {\n\t\twl1251_error(\"cmd scan status wasn't success: %d\",\n\t\t\t     cmd->header.status);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(cmd);\n\treturn ret;\n}\n\nint wl1251_cmd_trigger_scan_to(struct wl1251 *wl, u32 timeout)\n{\n\tstruct wl1251_cmd_trigger_scan_to *cmd;\n\tint ret;\n\n\twl1251_debug(DEBUG_CMD, \"cmd trigger scan to\");\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->timeout = timeout;\n\n\tret = wl1251_cmd_send(wl, CMD_TRIGGER_SCAN_TO, cmd, sizeof(*cmd));\n\tif (ret < 0) {\n\t\twl1251_error(\"cmd trigger scan to failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(cmd);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}