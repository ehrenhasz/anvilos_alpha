{
  "module_name": "spi.c",
  "hash_id": "7fe2ac5a32913bb75c6c9b5c96f39d8365b11c6065645474740685a6a2316ebf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wl1251/spi.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/swab.h>\n#include <linux/crc7.h>\n#include <linux/spi/spi.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n\n#include \"wl1251.h\"\n#include \"reg.h\"\n#include \"spi.h\"\n\nstruct wl1251_spi {\n\tstruct spi_device *spi;\n\tstruct gpio_desc *power_gpio;\n};\n\nstatic irqreturn_t wl1251_irq(int irq, void *cookie)\n{\n\tstruct wl1251 *wl;\n\n\twl1251_debug(DEBUG_IRQ, \"IRQ\");\n\n\twl = cookie;\n\n\tieee80211_queue_work(wl->hw, &wl->irq_work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void wl1251_spi_reset(struct wl1251 *wl)\n{\n\tstruct wl1251_spi *wl_spi = wl->if_priv;\n\tu8 *cmd;\n\tstruct spi_transfer t;\n\tstruct spi_message m;\n\n\tcmd = kzalloc(WSPI_INIT_CMD_LEN, GFP_KERNEL);\n\tif (!cmd) {\n\t\twl1251_error(\"could not allocate cmd for spi reset\");\n\t\treturn;\n\t}\n\n\tmemset(&t, 0, sizeof(t));\n\tspi_message_init(&m);\n\n\tmemset(cmd, 0xff, WSPI_INIT_CMD_LEN);\n\n\tt.tx_buf = cmd;\n\tt.len = WSPI_INIT_CMD_LEN;\n\tspi_message_add_tail(&t, &m);\n\n\tspi_sync(wl_spi->spi, &m);\n\n\twl1251_dump(DEBUG_SPI, \"spi reset -> \", cmd, WSPI_INIT_CMD_LEN);\n\n\tkfree(cmd);\n}\n\nstatic void wl1251_spi_wake(struct wl1251 *wl)\n{\n\tstruct wl1251_spi *wl_spi = wl->if_priv;\n\tstruct spi_transfer t;\n\tstruct spi_message m;\n\tu8 *cmd = kzalloc(WSPI_INIT_CMD_LEN, GFP_KERNEL);\n\n\tif (!cmd) {\n\t\twl1251_error(\"could not allocate cmd for spi init\");\n\t\treturn;\n\t}\n\n\tmemset(&t, 0, sizeof(t));\n\tspi_message_init(&m);\n\n\t \n\tcmd[0] = 0xff;\n\tcmd[1] = 0xff;\n\tcmd[2] = WSPI_INIT_CMD_START | WSPI_INIT_CMD_TX;\n\tcmd[3] = 0;\n\tcmd[4] = 0;\n\tcmd[5] = HW_ACCESS_WSPI_INIT_CMD_MASK << 3;\n\tcmd[5] |= HW_ACCESS_WSPI_FIXED_BUSY_LEN & WSPI_INIT_CMD_FIXEDBUSY_LEN;\n\n\tcmd[6] = WSPI_INIT_CMD_IOD | WSPI_INIT_CMD_IP | WSPI_INIT_CMD_CS\n\t\t| WSPI_INIT_CMD_WSPI | WSPI_INIT_CMD_WS;\n\n\tif (HW_ACCESS_WSPI_FIXED_BUSY_LEN == 0)\n\t\tcmd[6] |= WSPI_INIT_CMD_DIS_FIXEDBUSY;\n\telse\n\t\tcmd[6] |= WSPI_INIT_CMD_EN_FIXEDBUSY;\n\n\tcmd[7] = crc7_be(0, cmd+2, WSPI_INIT_CMD_CRC_LEN) | WSPI_INIT_CMD_END;\n\t \n\t__swab32s((u32 *)cmd);\n\t__swab32s((u32 *)cmd+1);\n\n\tt.tx_buf = cmd;\n\tt.len = WSPI_INIT_CMD_LEN;\n\tspi_message_add_tail(&t, &m);\n\n\tspi_sync(wl_spi->spi, &m);\n\n\twl1251_dump(DEBUG_SPI, \"spi init -> \", cmd, WSPI_INIT_CMD_LEN);\n\n\tkfree(cmd);\n}\n\nstatic void wl1251_spi_reset_wake(struct wl1251 *wl)\n{\n\twl1251_spi_reset(wl);\n\twl1251_spi_wake(wl);\n}\n\nstatic void wl1251_spi_read(struct wl1251 *wl, int addr, void *buf,\n\t\t\t    size_t len)\n{\n\tstruct wl1251_spi *wl_spi = wl->if_priv;\n\tstruct spi_transfer t[3];\n\tstruct spi_message m;\n\tu8 *busy_buf;\n\tu32 *cmd;\n\n\tcmd = &wl->buffer_cmd;\n\tbusy_buf = wl->buffer_busyword;\n\n\t*cmd = 0;\n\t*cmd |= WSPI_CMD_READ;\n\t*cmd |= (len << WSPI_CMD_BYTE_LENGTH_OFFSET) & WSPI_CMD_BYTE_LENGTH;\n\t*cmd |= addr & WSPI_CMD_BYTE_ADDR;\n\n\tspi_message_init(&m);\n\tmemset(t, 0, sizeof(t));\n\n\tt[0].tx_buf = cmd;\n\tt[0].len = 4;\n\tspi_message_add_tail(&t[0], &m);\n\n\t \n\tt[1].rx_buf = busy_buf;\n\tt[1].len = WL1251_BUSY_WORD_LEN;\n\tspi_message_add_tail(&t[1], &m);\n\n\tt[2].rx_buf = buf;\n\tt[2].len = len;\n\tspi_message_add_tail(&t[2], &m);\n\n\tspi_sync(wl_spi->spi, &m);\n\n\t \n\n\twl1251_dump(DEBUG_SPI, \"spi_read cmd -> \", cmd, sizeof(*cmd));\n\twl1251_dump(DEBUG_SPI, \"spi_read buf <- \", buf, len);\n}\n\nstatic void wl1251_spi_write(struct wl1251 *wl, int addr, void *buf,\n\t\t\t     size_t len)\n{\n\tstruct wl1251_spi *wl_spi = wl->if_priv;\n\tstruct spi_transfer t[2];\n\tstruct spi_message m;\n\tu32 *cmd;\n\n\tcmd = &wl->buffer_cmd;\n\n\t*cmd = 0;\n\t*cmd |= WSPI_CMD_WRITE;\n\t*cmd |= (len << WSPI_CMD_BYTE_LENGTH_OFFSET) & WSPI_CMD_BYTE_LENGTH;\n\t*cmd |= addr & WSPI_CMD_BYTE_ADDR;\n\n\tspi_message_init(&m);\n\tmemset(t, 0, sizeof(t));\n\n\tt[0].tx_buf = cmd;\n\tt[0].len = sizeof(*cmd);\n\tspi_message_add_tail(&t[0], &m);\n\n\tt[1].tx_buf = buf;\n\tt[1].len = len;\n\tspi_message_add_tail(&t[1], &m);\n\n\tspi_sync(wl_spi->spi, &m);\n\n\twl1251_dump(DEBUG_SPI, \"spi_write cmd -> \", cmd, sizeof(*cmd));\n\twl1251_dump(DEBUG_SPI, \"spi_write buf -> \", buf, len);\n}\n\nstatic void wl1251_spi_enable_irq(struct wl1251 *wl)\n{\n\treturn enable_irq(wl->irq);\n}\n\nstatic void wl1251_spi_disable_irq(struct wl1251 *wl)\n{\n\treturn disable_irq(wl->irq);\n}\n\nstatic int wl1251_spi_set_power(struct wl1251 *wl, bool enable)\n{\n\tstruct wl1251_spi *wl_spi = wl->if_priv;\n\n\tif (wl_spi->power_gpio)\n\t\tgpiod_set_value_cansleep(wl_spi->power_gpio, enable);\n\n\treturn 0;\n}\n\nstatic const struct wl1251_if_operations wl1251_spi_ops = {\n\t.read = wl1251_spi_read,\n\t.write = wl1251_spi_write,\n\t.reset = wl1251_spi_reset_wake,\n\t.enable_irq = wl1251_spi_enable_irq,\n\t.disable_irq = wl1251_spi_disable_irq,\n\t.power = wl1251_spi_set_power,\n};\n\nstatic int wl1251_spi_probe(struct spi_device *spi)\n{\n\tstruct device_node *np = spi->dev.of_node;\n\tstruct ieee80211_hw *hw;\n\tstruct wl1251_spi *wl_spi;\n\tstruct wl1251 *wl;\n\tint ret;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\twl_spi = devm_kzalloc(&spi->dev, sizeof(*wl_spi), GFP_KERNEL);\n\tif (!wl_spi)\n\t\treturn -ENOMEM;\n\n\twl_spi->spi = spi;\n\n\thw = wl1251_alloc_hw();\n\tif (IS_ERR(hw))\n\t\treturn PTR_ERR(hw);\n\n\twl = hw->priv;\n\n\tSET_IEEE80211_DEV(hw, &spi->dev);\n\tspi_set_drvdata(spi, wl);\n\twl->if_priv = wl_spi;\n\twl->if_ops = &wl1251_spi_ops;\n\n\t \n\tspi->bits_per_word = 32;\n\n\tret = spi_setup(spi);\n\tif (ret < 0) {\n\t\twl1251_error(\"spi_setup failed\");\n\t\tgoto out_free;\n\t}\n\n\twl->use_eeprom = of_property_read_bool(np, \"ti,wl1251-has-eeprom\");\n\n\twl_spi->power_gpio = devm_gpiod_get_optional(&spi->dev, \"ti,power\",\n\t\t\t\t\t\t     GPIOD_OUT_LOW);\n\tret = PTR_ERR_OR_ZERO(wl_spi->power_gpio);\n\tif (ret) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\twl1251_error(\"Failed to request gpio: %d\\n\", ret);\n\t\tgoto out_free;\n\t}\n\n\tgpiod_set_consumer_name(wl_spi->power_gpio, \"wl1251 power\");\n\n\twl->irq = spi->irq;\n\tif (wl->irq < 0) {\n\t\twl1251_error(\"irq missing in platform data\");\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\tirq_set_status_flags(wl->irq, IRQ_NOAUTOEN);\n\tret = devm_request_irq(&spi->dev, wl->irq, wl1251_irq, 0,\n\t\t\t\t\t\t\tDRIVER_NAME, wl);\n\tif (ret < 0) {\n\t\twl1251_error(\"request_irq() failed: %d\", ret);\n\t\tgoto out_free;\n\t}\n\n\tirq_set_irq_type(wl->irq, IRQ_TYPE_EDGE_RISING);\n\n\twl->vio = devm_regulator_get(&spi->dev, \"vio\");\n\tif (IS_ERR(wl->vio)) {\n\t\tret = PTR_ERR(wl->vio);\n\t\twl1251_error(\"vio regulator missing: %d\", ret);\n\t\tgoto out_free;\n\t}\n\n\tret = regulator_enable(wl->vio);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = wl1251_init_ieee80211(wl);\n\tif (ret)\n\t\tgoto disable_regulator;\n\n\treturn 0;\n\ndisable_regulator:\n\tregulator_disable(wl->vio);\nout_free:\n\tieee80211_free_hw(hw);\n\n\treturn ret;\n}\n\nstatic void wl1251_spi_remove(struct spi_device *spi)\n{\n\tstruct wl1251 *wl = spi_get_drvdata(spi);\n\n\twl1251_free_hw(wl);\n\tregulator_disable(wl->vio);\n}\n\nstatic struct spi_driver wl1251_spi_driver = {\n\t.driver = {\n\t\t.name\t\t= DRIVER_NAME,\n\t},\n\n\t.probe\t\t= wl1251_spi_probe,\n\t.remove\t\t= wl1251_spi_remove,\n};\n\nmodule_spi_driver(wl1251_spi_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kalle Valo <kvalo@adurom.com>\");\nMODULE_ALIAS(\"spi:wl1251\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}