{
  "module_name": "main.c",
  "hash_id": "c86ecdabc934ae1b85e24891ca7bb33abb218cdc8533b1939b94905245877c13",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wl1251/main.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/firmware.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/crc32.h>\n#include <linux/etherdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/netdevice.h>\n\n#include \"wl1251.h\"\n#include \"wl12xx_80211.h\"\n#include \"reg.h\"\n#include \"io.h\"\n#include \"cmd.h\"\n#include \"event.h\"\n#include \"tx.h\"\n#include \"rx.h\"\n#include \"ps.h\"\n#include \"init.h\"\n#include \"debugfs.h\"\n#include \"boot.h\"\n\nvoid wl1251_enable_interrupts(struct wl1251 *wl)\n{\n\twl->if_ops->enable_irq(wl);\n}\n\nvoid wl1251_disable_interrupts(struct wl1251 *wl)\n{\n\twl->if_ops->disable_irq(wl);\n}\n\nstatic int wl1251_power_off(struct wl1251 *wl)\n{\n\treturn wl->if_ops->power(wl, false);\n}\n\nstatic int wl1251_power_on(struct wl1251 *wl)\n{\n\treturn wl->if_ops->power(wl, true);\n}\n\nstatic int wl1251_fetch_firmware(struct wl1251 *wl)\n{\n\tconst struct firmware *fw;\n\tstruct device *dev = wiphy_dev(wl->hw->wiphy);\n\tint ret;\n\n\tret = request_firmware(&fw, WL1251_FW_NAME, dev);\n\n\tif (ret < 0) {\n\t\twl1251_error(\"could not get firmware: %d\", ret);\n\t\treturn ret;\n\t}\n\n\tif (fw->size % 4) {\n\t\twl1251_error(\"firmware size is not multiple of 32 bits: %zu\",\n\t\t\t     fw->size);\n\t\tret = -EILSEQ;\n\t\tgoto out;\n\t}\n\n\twl->fw_len = fw->size;\n\twl->fw = vmalloc(wl->fw_len);\n\n\tif (!wl->fw) {\n\t\twl1251_error(\"could not allocate memory for the firmware\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemcpy(wl->fw, fw->data, wl->fw_len);\n\n\tret = 0;\n\nout:\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\nstatic int wl1251_fetch_nvs(struct wl1251 *wl)\n{\n\tconst struct firmware *fw;\n\tstruct device *dev = wiphy_dev(wl->hw->wiphy);\n\tint ret;\n\n\tret = request_firmware(&fw, WL1251_NVS_NAME, dev);\n\n\tif (ret < 0) {\n\t\twl1251_error(\"could not get nvs file: %d\", ret);\n\t\treturn ret;\n\t}\n\n\tif (fw->size % 4) {\n\t\twl1251_error(\"nvs size is not multiple of 32 bits: %zu\",\n\t\t\t     fw->size);\n\t\tret = -EILSEQ;\n\t\tgoto out;\n\t}\n\n\twl->nvs = kmemdup(fw->data, fw->size, GFP_KERNEL);\n\n\tif (!wl->nvs) {\n\t\twl1251_error(\"could not allocate memory for the nvs file\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\twl->nvs_len = fw->size;\n\n\tret = 0;\n\nout:\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\nstatic void wl1251_fw_wakeup(struct wl1251 *wl)\n{\n\tu32 elp_reg;\n\n\telp_reg = ELPCTRL_WAKE_UP;\n\twl1251_write_elp(wl, HW_ACCESS_ELP_CTRL_REG_ADDR, elp_reg);\n\telp_reg = wl1251_read_elp(wl, HW_ACCESS_ELP_CTRL_REG_ADDR);\n\n\tif (!(elp_reg & ELPCTRL_WLAN_READY))\n\t\twl1251_warning(\"WLAN not ready\");\n}\n\nstatic int wl1251_chip_wakeup(struct wl1251 *wl)\n{\n\tint ret;\n\n\tret = wl1251_power_on(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmsleep(WL1251_POWER_ON_SLEEP);\n\twl->if_ops->reset(wl);\n\n\t \n\twl1251_set_partition(wl,\n\t\t\t     0x00000000,\n\t\t\t     0x00000000,\n\t\t\t     REGISTERS_BASE,\n\t\t\t     REGISTERS_DOWN_SIZE);\n\n\t \n\twl1251_fw_wakeup(wl);\n\n\t \n\n\t \n\twl->chip_id = wl1251_reg_read32(wl, CHIP_ID_B);\n\n\t \n\n\tswitch (wl->chip_id) {\n\tcase CHIP_ID_1251_PG12:\n\t\twl1251_debug(DEBUG_BOOT, \"chip id 0x%x (1251 PG12)\",\n\t\t\t     wl->chip_id);\n\t\tbreak;\n\tcase CHIP_ID_1251_PG11:\n\t\twl1251_debug(DEBUG_BOOT, \"chip id 0x%x (1251 PG11)\",\n\t\t\t     wl->chip_id);\n\t\tbreak;\n\tcase CHIP_ID_1251_PG10:\n\tdefault:\n\t\twl1251_error(\"unsupported chip id: 0x%x\", wl->chip_id);\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (wl->fw == NULL) {\n\t\tret = wl1251_fetch_firmware(wl);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n}\n\n#define WL1251_IRQ_LOOP_COUNT 10\nstatic void wl1251_irq_work(struct work_struct *work)\n{\n\tu32 intr, ctr = WL1251_IRQ_LOOP_COUNT;\n\tstruct wl1251 *wl =\n\t\tcontainer_of(work, struct wl1251, irq_work);\n\tint ret;\n\n\tmutex_lock(&wl->mutex);\n\n\twl1251_debug(DEBUG_IRQ, \"IRQ work\");\n\n\tif (wl->state == WL1251_STATE_OFF)\n\t\tgoto out;\n\n\tret = wl1251_ps_elp_wakeup(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twl1251_reg_write32(wl, ACX_REG_INTERRUPT_MASK, WL1251_ACX_INTR_ALL);\n\n\tintr = wl1251_reg_read32(wl, ACX_REG_INTERRUPT_CLEAR);\n\twl1251_debug(DEBUG_IRQ, \"intr: 0x%x\", intr);\n\n\tdo {\n\t\tif (wl->data_path) {\n\t\t\twl->rx_counter = wl1251_mem_read32(\n\t\t\t\twl, wl->data_path->rx_control_addr);\n\n\t\t\t \n\t\t\tswitch ((wl->rx_counter - wl->rx_handled) & 0xf) {\n\t\t\tcase 0:\n\t\t\t\twl1251_debug(DEBUG_IRQ,\n\t\t\t\t\t     \"RX: FW and host in sync\");\n\t\t\t\tintr &= ~WL1251_ACX_INTR_RX0_DATA;\n\t\t\t\tintr &= ~WL1251_ACX_INTR_RX1_DATA;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\twl1251_debug(DEBUG_IRQ, \"RX: FW +1\");\n\t\t\t\tintr |= WL1251_ACX_INTR_RX0_DATA;\n\t\t\t\tintr &= ~WL1251_ACX_INTR_RX1_DATA;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\twl1251_debug(DEBUG_IRQ, \"RX: FW +2\");\n\t\t\t\tintr |= WL1251_ACX_INTR_RX0_DATA;\n\t\t\t\tintr |= WL1251_ACX_INTR_RX1_DATA;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\twl1251_warning(\n\t\t\t\t\t\"RX: FW and host out of sync: %d\",\n\t\t\t\t\twl->rx_counter - wl->rx_handled);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twl->rx_handled = wl->rx_counter;\n\n\t\t\twl1251_debug(DEBUG_IRQ, \"RX counter: %d\",\n\t\t\t\t     wl->rx_counter);\n\t\t}\n\n\t\tintr &= wl->intr_mask;\n\n\t\tif (intr == 0) {\n\t\t\twl1251_debug(DEBUG_IRQ, \"INTR is 0\");\n\t\t\tgoto out_sleep;\n\t\t}\n\n\t\tif (intr & WL1251_ACX_INTR_RX0_DATA) {\n\t\t\twl1251_debug(DEBUG_IRQ, \"WL1251_ACX_INTR_RX0_DATA\");\n\t\t\twl1251_rx(wl);\n\t\t}\n\n\t\tif (intr & WL1251_ACX_INTR_RX1_DATA) {\n\t\t\twl1251_debug(DEBUG_IRQ, \"WL1251_ACX_INTR_RX1_DATA\");\n\t\t\twl1251_rx(wl);\n\t\t}\n\n\t\tif (intr & WL1251_ACX_INTR_TX_RESULT) {\n\t\t\twl1251_debug(DEBUG_IRQ, \"WL1251_ACX_INTR_TX_RESULT\");\n\t\t\twl1251_tx_complete(wl);\n\t\t}\n\n\t\tif (intr & WL1251_ACX_INTR_EVENT_A) {\n\t\t\twl1251_debug(DEBUG_IRQ, \"WL1251_ACX_INTR_EVENT_A\");\n\t\t\twl1251_event_handle(wl, 0);\n\t\t}\n\n\t\tif (intr & WL1251_ACX_INTR_EVENT_B) {\n\t\t\twl1251_debug(DEBUG_IRQ, \"WL1251_ACX_INTR_EVENT_B\");\n\t\t\twl1251_event_handle(wl, 1);\n\t\t}\n\n\t\tif (intr & WL1251_ACX_INTR_INIT_COMPLETE)\n\t\t\twl1251_debug(DEBUG_IRQ,\n\t\t\t\t     \"WL1251_ACX_INTR_INIT_COMPLETE\");\n\n\t\tif (--ctr == 0)\n\t\t\tbreak;\n\n\t\tintr = wl1251_reg_read32(wl, ACX_REG_INTERRUPT_CLEAR);\n\t} while (intr);\n\nout_sleep:\n\twl1251_reg_write32(wl, ACX_REG_INTERRUPT_MASK, ~(wl->intr_mask));\n\twl1251_ps_elp_sleep(wl);\n\nout:\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic int wl1251_join(struct wl1251 *wl, u8 bss_type, u8 channel,\n\t\t       u16 beacon_interval, u8 dtim_period)\n{\n\tint ret;\n\n\tret = wl1251_acx_frame_rates(wl, DEFAULT_HW_GEN_TX_RATE,\n\t\t\t\t     DEFAULT_HW_GEN_MODULATION_TYPE,\n\t\t\t\t     wl->tx_mgmt_frm_rate,\n\t\t\t\t     wl->tx_mgmt_frm_mod);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tif (is_zero_ether_addr(wl->bssid))\n\t\twl->rx_config &= ~CFG_BSSID_FILTER_EN;\n\n\tret = wl1251_cmd_join(wl, bss_type, channel, beacon_interval,\n\t\t\t      dtim_period);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl1251_event_wait(wl, JOIN_EVENT_COMPLETE_ID, 100);\n\tif (ret < 0)\n\t\twl1251_warning(\"join timeout\");\n\nout:\n\treturn ret;\n}\n\nstatic void wl1251_op_tx(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_tx_control *control,\n\t\t\t struct sk_buff *skb)\n{\n\tstruct wl1251 *wl = hw->priv;\n\tunsigned long flags;\n\n\tskb_queue_tail(&wl->tx_queue, skb);\n\n\t \n\n\tieee80211_queue_work(wl->hw, &wl->tx_work);\n\n\t \n\tif (skb_queue_len(&wl->tx_queue) >= WL1251_TX_QUEUE_HIGH_WATERMARK) {\n\t\twl1251_debug(DEBUG_TX, \"op_tx: tx_queue full, stop queues\");\n\n\t\tspin_lock_irqsave(&wl->wl_lock, flags);\n\t\tieee80211_stop_queues(wl->hw);\n\t\twl->tx_queue_stopped = true;\n\t\tspin_unlock_irqrestore(&wl->wl_lock, flags);\n\t}\n}\n\nstatic int wl1251_op_start(struct ieee80211_hw *hw)\n{\n\tstruct wl1251 *wl = hw->priv;\n\tstruct wiphy *wiphy = hw->wiphy;\n\tint ret = 0;\n\n\twl1251_debug(DEBUG_MAC80211, \"mac80211 start\");\n\n\tmutex_lock(&wl->mutex);\n\n\tif (wl->state != WL1251_STATE_OFF) {\n\t\twl1251_error(\"cannot start because not in off state: %d\",\n\t\t\t     wl->state);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = wl1251_chip_wakeup(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl1251_boot(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl1251_hw_init(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl1251_acx_station_id(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twl->state = WL1251_STATE_ON;\n\n\twl1251_info(\"firmware booted (%s)\", wl->fw_ver);\n\n\t \n\twiphy->hw_version = wl->chip_id;\n\tstrncpy(wiphy->fw_version, wl->fw_ver, sizeof(wiphy->fw_version));\n\nout:\n\tif (ret < 0)\n\t\twl1251_power_off(wl);\n\n\tmutex_unlock(&wl->mutex);\n\n\treturn ret;\n}\n\nstatic void wl1251_op_stop(struct ieee80211_hw *hw)\n{\n\tstruct wl1251 *wl = hw->priv;\n\n\twl1251_info(\"down\");\n\n\twl1251_debug(DEBUG_MAC80211, \"mac80211 stop\");\n\n\tmutex_lock(&wl->mutex);\n\n\tWARN_ON(wl->state != WL1251_STATE_ON);\n\n\tif (wl->scanning) {\n\t\tstruct cfg80211_scan_info info = {\n\t\t\t.aborted = true,\n\t\t};\n\n\t\tieee80211_scan_completed(wl->hw, &info);\n\t\twl->scanning = false;\n\t}\n\n\twl->state = WL1251_STATE_OFF;\n\n\twl1251_disable_interrupts(wl);\n\n\tmutex_unlock(&wl->mutex);\n\n\tcancel_work_sync(&wl->irq_work);\n\tcancel_work_sync(&wl->tx_work);\n\tcancel_delayed_work_sync(&wl->elp_work);\n\n\tmutex_lock(&wl->mutex);\n\n\t \n\twl1251_tx_flush(wl);\n\twl1251_power_off(wl);\n\n\teth_zero_addr(wl->bssid);\n\twl->listen_int = 1;\n\twl->bss_type = MAX_BSS_TYPE;\n\n\twl->data_in_count = 0;\n\twl->rx_counter = 0;\n\twl->rx_handled = 0;\n\twl->rx_current_buffer = 0;\n\twl->rx_last_id = 0;\n\twl->next_tx_complete = 0;\n\twl->elp = false;\n\twl->station_mode = STATION_ACTIVE_MODE;\n\twl->psm_entry_retry = 0;\n\twl->tx_queue_stopped = false;\n\twl->power_level = WL1251_DEFAULT_POWER_LEVEL;\n\twl->rssi_thold = 0;\n\twl->channel = WL1251_DEFAULT_CHANNEL;\n\twl->monitor_present = false;\n\twl->joined = false;\n\n\twl1251_debugfs_reset(wl);\n\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic int wl1251_op_add_interface(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct wl1251 *wl = hw->priv;\n\tint ret = 0;\n\n\tvif->driver_flags |= IEEE80211_VIF_BEACON_FILTER |\n\t\t\t     IEEE80211_VIF_SUPPORTS_UAPSD |\n\t\t\t     IEEE80211_VIF_SUPPORTS_CQM_RSSI;\n\n\twl1251_debug(DEBUG_MAC80211, \"mac80211 add interface type %d mac %pM\",\n\t\t     vif->type, vif->addr);\n\n\tmutex_lock(&wl->mutex);\n\tif (wl->vif) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\twl->vif = vif;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\twl->bss_type = BSS_TYPE_STA_BSS;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\twl->bss_type = BSS_TYPE_IBSS;\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (!ether_addr_equal_unaligned(wl->mac_addr, vif->addr)) {\n\t\tmemcpy(wl->mac_addr, vif->addr, ETH_ALEN);\n\t\tSET_IEEE80211_PERM_ADDR(wl->hw, wl->mac_addr);\n\t\tret = wl1251_acx_station_id(wl);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tmutex_unlock(&wl->mutex);\n\treturn ret;\n}\n\nstatic void wl1251_op_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct wl1251 *wl = hw->priv;\n\n\tmutex_lock(&wl->mutex);\n\twl1251_debug(DEBUG_MAC80211, \"mac80211 remove interface\");\n\twl->vif = NULL;\n\teth_zero_addr(wl->bssid);\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic int wl1251_build_null_data(struct wl1251 *wl)\n{\n\tstruct sk_buff *skb = NULL;\n\tint size;\n\tvoid *ptr;\n\tint ret = -ENOMEM;\n\n\tif (wl->bss_type == BSS_TYPE_IBSS) {\n\t\tsize = sizeof(struct wl12xx_null_data_template);\n\t\tptr = NULL;\n\t} else {\n\t\tskb = ieee80211_nullfunc_get(wl->hw, wl->vif, -1, false);\n\t\tif (!skb)\n\t\t\tgoto out;\n\t\tsize = skb->len;\n\t\tptr = skb->data;\n\t}\n\n\tret = wl1251_cmd_template_set(wl, CMD_NULL_DATA, ptr, size);\n\nout:\n\tdev_kfree_skb(skb);\n\tif (ret)\n\t\twl1251_warning(\"cmd build null data failed: %d\", ret);\n\n\treturn ret;\n}\n\nstatic int wl1251_build_qos_null_data(struct wl1251 *wl)\n{\n\tstruct ieee80211_qos_hdr template;\n\n\tmemset(&template, 0, sizeof(template));\n\n\tmemcpy(template.addr1, wl->bssid, ETH_ALEN);\n\tmemcpy(template.addr2, wl->mac_addr, ETH_ALEN);\n\tmemcpy(template.addr3, wl->bssid, ETH_ALEN);\n\n\ttemplate.frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |\n\t\t\t\t\t     IEEE80211_STYPE_QOS_NULLFUNC |\n\t\t\t\t\t     IEEE80211_FCTL_TODS);\n\n\t \n\ttemplate.qos_ctrl = cpu_to_le16(0);\n\n\treturn wl1251_cmd_template_set(wl, CMD_QOS_NULL_DATA, &template,\n\t\t\t\t       sizeof(template));\n}\n\nstatic bool wl1251_can_do_pm(struct ieee80211_conf *conf, struct wl1251 *wl)\n{\n\treturn (conf->flags & IEEE80211_CONF_PS) && !wl->monitor_present;\n}\n\nstatic int wl1251_op_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct wl1251 *wl = hw->priv;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tint channel, ret = 0;\n\n\tchannel = ieee80211_frequency_to_channel(\n\t\t\tconf->chandef.chan->center_freq);\n\n\twl1251_debug(DEBUG_MAC80211,\n\t\t     \"mac80211 config ch %d monitor %s psm %s power %d\",\n\t\t     channel,\n\t\t     conf->flags & IEEE80211_CONF_MONITOR ? \"on\" : \"off\",\n\t\t     conf->flags & IEEE80211_CONF_PS ? \"on\" : \"off\",\n\t\t     conf->power_level);\n\n\tmutex_lock(&wl->mutex);\n\n\tret = wl1251_ps_elp_wakeup(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (changed & IEEE80211_CONF_CHANGE_MONITOR) {\n\t\tu32 mode;\n\n\t\tif (conf->flags & IEEE80211_CONF_MONITOR) {\n\t\t\twl->monitor_present = true;\n\t\t\tmode = DF_SNIFF_MODE_ENABLE | DF_ENCRYPTION_DISABLE;\n\t\t} else {\n\t\t\twl->monitor_present = false;\n\t\t\tmode = 0;\n\t\t}\n\n\t\tret = wl1251_acx_feature_cfg(wl, mode);\n\t\tif (ret < 0)\n\t\t\tgoto out_sleep;\n\t}\n\n\tif (channel != wl->channel) {\n\t\twl->channel = channel;\n\n\t\t \n\t\tif (wl->vif == NULL) {\n\t\t\twl->joined = false;\n\t\t\tret = wl1251_cmd_data_path_rx(wl, wl->channel, 1);\n\t\t} else {\n\t\t\tret = wl1251_join(wl, wl->bss_type, wl->channel,\n\t\t\t\t\t  wl->beacon_int, wl->dtim_period);\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out_sleep;\n\t}\n\n\tif (wl1251_can_do_pm(conf, wl) && !wl->psm_requested) {\n\t\twl1251_debug(DEBUG_PSM, \"psm enabled\");\n\n\t\twl->psm_requested = true;\n\n\t\twl->dtim_period = conf->ps_dtim_period;\n\n\t\tret = wl1251_acx_wr_tbtt_and_dtim(wl, wl->beacon_int,\n\t\t\t\t\t\t  wl->dtim_period);\n\n\t\t \n\t\tret = wl1251_ps_set_mode(wl, STATION_POWER_SAVE_MODE);\n\t\tif (ret < 0)\n\t\t\tgoto out_sleep;\n\t} else if (!wl1251_can_do_pm(conf, wl) && wl->psm_requested) {\n\t\twl1251_debug(DEBUG_PSM, \"psm disabled\");\n\n\t\twl->psm_requested = false;\n\n\t\tif (wl->station_mode != STATION_ACTIVE_MODE) {\n\t\t\tret = wl1251_ps_set_mode(wl, STATION_ACTIVE_MODE);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_sleep;\n\t\t}\n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_IDLE && !wl->scanning) {\n\t\tif (conf->flags & IEEE80211_CONF_IDLE) {\n\t\t\tret = wl1251_ps_set_mode(wl, STATION_IDLE);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_sleep;\n\t\t} else {\n\t\t\tret = wl1251_ps_set_mode(wl, STATION_ACTIVE_MODE);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_sleep;\n\t\t\tret = wl1251_join(wl, wl->bss_type, wl->channel,\n\t\t\t\t\t  wl->beacon_int, wl->dtim_period);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_sleep;\n\t\t}\n\t}\n\n\tif (conf->power_level != wl->power_level) {\n\t\tret = wl1251_acx_tx_power(wl, conf->power_level);\n\t\tif (ret < 0)\n\t\t\tgoto out_sleep;\n\n\t\twl->power_level = conf->power_level;\n\t}\n\nout_sleep:\n\twl1251_ps_elp_sleep(wl);\n\nout:\n\tmutex_unlock(&wl->mutex);\n\n\treturn ret;\n}\n\nstruct wl1251_filter_params {\n\tbool enabled;\n\tint mc_list_length;\n\tu8 mc_list[ACX_MC_ADDRESS_GROUP_MAX][ETH_ALEN];\n};\n\nstatic u64 wl1251_op_prepare_multicast(struct ieee80211_hw *hw,\n\t\t\t\t       struct netdev_hw_addr_list *mc_list)\n{\n\tstruct wl1251_filter_params *fp;\n\tstruct netdev_hw_addr *ha;\n\tstruct wl1251 *wl = hw->priv;\n\n\tif (unlikely(wl->state == WL1251_STATE_OFF))\n\t\treturn 0;\n\n\tfp = kzalloc(sizeof(*fp), GFP_ATOMIC);\n\tif (!fp) {\n\t\twl1251_error(\"Out of memory setting filters.\");\n\t\treturn 0;\n\t}\n\n\t \n\tfp->mc_list_length = 0;\n\tif (netdev_hw_addr_list_count(mc_list) > ACX_MC_ADDRESS_GROUP_MAX) {\n\t\tfp->enabled = false;\n\t} else {\n\t\tfp->enabled = true;\n\t\tnetdev_hw_addr_list_for_each(ha, mc_list) {\n\t\t\tmemcpy(fp->mc_list[fp->mc_list_length],\n\t\t\t\t\tha->addr, ETH_ALEN);\n\t\t\tfp->mc_list_length++;\n\t\t}\n\t}\n\n\treturn (u64)(unsigned long)fp;\n}\n\n#define WL1251_SUPPORTED_FILTERS (FIF_ALLMULTI | \\\n\t\t\t\t  FIF_FCSFAIL | \\\n\t\t\t\t  FIF_BCN_PRBRESP_PROMISC | \\\n\t\t\t\t  FIF_CONTROL | \\\n\t\t\t\t  FIF_OTHER_BSS | \\\n\t\t\t\t  FIF_PROBE_REQ)\n\nstatic void wl1251_op_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t       unsigned int changed,\n\t\t\t\t       unsigned int *total, u64 multicast)\n{\n\tstruct wl1251_filter_params *fp = (void *)(unsigned long)multicast;\n\tstruct wl1251 *wl = hw->priv;\n\tint ret;\n\n\twl1251_debug(DEBUG_MAC80211, \"mac80211 configure filter\");\n\n\t*total &= WL1251_SUPPORTED_FILTERS;\n\tchanged &= WL1251_SUPPORTED_FILTERS;\n\n\tif (changed == 0) {\n\t\t \n\t\tkfree(fp);\n\t\treturn;\n\t}\n\n\tmutex_lock(&wl->mutex);\n\n\twl->rx_config = WL1251_DEFAULT_RX_CONFIG;\n\twl->rx_filter = WL1251_DEFAULT_RX_FILTER;\n\n\tif (*total & FIF_ALLMULTI)\n\t\t \n\t\twl->rx_config &= ~CFG_MC_FILTER_EN;\n\tif (*total & FIF_FCSFAIL)\n\t\twl->rx_filter |= CFG_RX_FCS_ERROR;\n\tif (*total & FIF_BCN_PRBRESP_PROMISC) {\n\t\twl->rx_config &= ~CFG_BSSID_FILTER_EN;\n\t\twl->rx_config &= ~CFG_SSID_FILTER_EN;\n\t}\n\tif (*total & FIF_CONTROL)\n\t\twl->rx_filter |= CFG_RX_CTL_EN;\n\tif (*total & FIF_OTHER_BSS || is_zero_ether_addr(wl->bssid))\n\t\twl->rx_config &= ~CFG_BSSID_FILTER_EN;\n\tif (*total & FIF_PROBE_REQ)\n\t\twl->rx_filter |= CFG_RX_PREQ_EN;\n\n\tif (wl->state == WL1251_STATE_OFF)\n\t\tgoto out;\n\n\tret = wl1251_ps_elp_wakeup(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (*total & FIF_ALLMULTI)\n\t\tret = wl1251_acx_group_address_tbl(wl, false, NULL, 0);\n\telse if (fp)\n\t\tret = wl1251_acx_group_address_tbl(wl, fp->enabled,\n\t\t\t\t\t\t   fp->mc_list,\n\t\t\t\t\t\t   fp->mc_list_length);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\twl1251_acx_rx_config(wl, wl->rx_config, wl->rx_filter);\n\n\twl1251_ps_elp_sleep(wl);\n\nout:\n\tmutex_unlock(&wl->mutex);\n\tkfree(fp);\n}\n\n \nstatic int wl1251_set_key_type(struct wl1251 *wl,\n\t\t\t       struct wl1251_cmd_set_keys *key,\n\t\t\t       enum set_key_cmd cmd,\n\t\t\t       struct ieee80211_key_conf *mac80211_key,\n\t\t\t       const u8 *addr)\n{\n\tswitch (mac80211_key->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tif (is_broadcast_ether_addr(addr))\n\t\t\tkey->key_type = KEY_WEP_DEFAULT;\n\t\telse\n\t\t\tkey->key_type = KEY_WEP_ADDR;\n\n\t\tmac80211_key->hw_key_idx = mac80211_key->keyidx;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tif (is_broadcast_ether_addr(addr))\n\t\t\tkey->key_type = KEY_TKIP_MIC_GROUP;\n\t\telse\n\t\t\tkey->key_type = KEY_TKIP_MIC_PAIRWISE;\n\n\t\tmac80211_key->hw_key_idx = mac80211_key->keyidx;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tif (is_broadcast_ether_addr(addr))\n\t\t\tkey->key_type = KEY_AES_GROUP;\n\t\telse\n\t\t\tkey->key_type = KEY_AES_PAIRWISE;\n\t\tmac80211_key->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\n\t\tbreak;\n\tdefault:\n\t\twl1251_error(\"Unknown key cipher 0x%x\", mac80211_key->cipher);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int wl1251_op_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_sta *sta,\n\t\t\t     struct ieee80211_key_conf *key)\n{\n\tstruct wl1251 *wl = hw->priv;\n\tstruct wl1251_cmd_set_keys *wl_cmd;\n\tconst u8 *addr;\n\tint ret;\n\n\tstatic const u8 bcast_addr[ETH_ALEN] =\n\t\t{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\n\twl1251_debug(DEBUG_MAC80211, \"mac80211 set key\");\n\n\twl_cmd = kzalloc(sizeof(*wl_cmd), GFP_KERNEL);\n\tif (!wl_cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\taddr = sta ? sta->addr : bcast_addr;\n\n\twl1251_debug(DEBUG_CRYPT, \"CMD: 0x%x\", cmd);\n\twl1251_dump(DEBUG_CRYPT, \"ADDR: \", addr, ETH_ALEN);\n\twl1251_debug(DEBUG_CRYPT, \"Key: algo:0x%x, id:%d, len:%d flags 0x%x\",\n\t\t     key->cipher, key->keyidx, key->keylen, key->flags);\n\twl1251_dump(DEBUG_CRYPT, \"KEY: \", key->key, key->keylen);\n\n\tif (is_zero_ether_addr(addr)) {\n\t\t \n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&wl->mutex);\n\n\tswitch (cmd) {\n\tcase SET_KEY:\n\t\tif (wl->monitor_present) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\twl_cmd->key_action = KEY_ADD_OR_REPLACE;\n\t\tbreak;\n\tcase DISABLE_KEY:\n\t\twl_cmd->key_action = KEY_REMOVE;\n\t\tbreak;\n\tdefault:\n\t\twl1251_error(\"Unsupported key cmd 0x%x\", cmd);\n\t\tbreak;\n\t}\n\n\tret = wl1251_ps_elp_wakeup(wl);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tret = wl1251_set_key_type(wl, wl_cmd, cmd, key, addr);\n\tif (ret < 0) {\n\t\twl1251_error(\"Set KEY type failed\");\n\t\tgoto out_sleep;\n\t}\n\n\tif (wl_cmd->key_type != KEY_WEP_DEFAULT)\n\t\tmemcpy(wl_cmd->addr, addr, ETH_ALEN);\n\n\tif ((wl_cmd->key_type == KEY_TKIP_MIC_GROUP) ||\n\t    (wl_cmd->key_type == KEY_TKIP_MIC_PAIRWISE)) {\n\t\t \n\t\tmemcpy(wl_cmd->key, key->key, 16);\n\t\tmemcpy(wl_cmd->key + 16, key->key + 24, 8);\n\t\tmemcpy(wl_cmd->key + 24, key->key + 16, 8);\n\n\t} else {\n\t\tmemcpy(wl_cmd->key, key->key, key->keylen);\n\t}\n\twl_cmd->key_size = key->keylen;\n\n\twl_cmd->id = key->keyidx;\n\twl_cmd->ssid_profile = 0;\n\n\twl1251_dump(DEBUG_CRYPT, \"TARGET KEY: \", wl_cmd, sizeof(*wl_cmd));\n\n\tret = wl1251_cmd_send(wl, CMD_SET_KEYS, wl_cmd, sizeof(*wl_cmd));\n\tif (ret < 0) {\n\t\twl1251_warning(\"could not set keys\");\n\t\tgoto out_sleep;\n\t}\n\nout_sleep:\n\twl1251_ps_elp_sleep(wl);\n\nout_unlock:\n\tmutex_unlock(&wl->mutex);\n\nout:\n\tkfree(wl_cmd);\n\n\treturn ret;\n}\n\nstatic int wl1251_op_hw_scan(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_scan_request *hw_req)\n{\n\tstruct cfg80211_scan_request *req = &hw_req->req;\n\tstruct wl1251 *wl = hw->priv;\n\tstruct sk_buff *skb;\n\tsize_t ssid_len = 0;\n\tu8 *ssid = NULL;\n\tint ret;\n\n\twl1251_debug(DEBUG_MAC80211, \"mac80211 hw scan\");\n\n\tif (req->n_ssids) {\n\t\tssid = req->ssids[0].ssid;\n\t\tssid_len = req->ssids[0].ssid_len;\n\t}\n\n\tmutex_lock(&wl->mutex);\n\n\tif (wl->scanning) {\n\t\twl1251_debug(DEBUG_SCAN, \"scan already in progress\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = wl1251_ps_elp_wakeup(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (hw->conf.flags & IEEE80211_CONF_IDLE) {\n\t\tret = wl1251_ps_set_mode(wl, STATION_ACTIVE_MODE);\n\t\tif (ret < 0)\n\t\t\tgoto out_sleep;\n\t\tret = wl1251_join(wl, wl->bss_type, wl->channel,\n\t\t\t\t  wl->beacon_int, wl->dtim_period);\n\t\tif (ret < 0)\n\t\t\tgoto out_sleep;\n\t}\n\n\tskb = ieee80211_probereq_get(wl->hw, wl->vif->addr, ssid, ssid_len,\n\t\t\t\t     req->ie_len);\n\tif (!skb) {\n\t\tret = -ENOMEM;\n\t\tgoto out_idle;\n\t}\n\tif (req->ie_len)\n\t\tskb_put_data(skb, req->ie, req->ie_len);\n\n\tret = wl1251_cmd_template_set(wl, CMD_PROBE_REQ, skb->data,\n\t\t\t\t      skb->len);\n\tdev_kfree_skb(skb);\n\tif (ret < 0)\n\t\tgoto out_idle;\n\n\tret = wl1251_cmd_trigger_scan_to(wl, 0);\n\tif (ret < 0)\n\t\tgoto out_idle;\n\n\twl->scanning = true;\n\n\tret = wl1251_cmd_scan(wl, ssid, ssid_len, req->channels,\n\t\t\t      req->n_channels, WL1251_SCAN_NUM_PROBES);\n\tif (ret < 0) {\n\t\twl1251_debug(DEBUG_SCAN, \"scan failed %d\", ret);\n\t\twl->scanning = false;\n\t\tgoto out_idle;\n\t}\n\tgoto out_sleep;\n\nout_idle:\n\tif (hw->conf.flags & IEEE80211_CONF_IDLE)\n\t\tret = wl1251_ps_set_mode(wl, STATION_IDLE);\nout_sleep:\n\twl1251_ps_elp_sleep(wl);\n\nout:\n\tmutex_unlock(&wl->mutex);\n\n\treturn ret;\n}\n\nstatic int wl1251_op_set_rts_threshold(struct ieee80211_hw *hw, u32 value)\n{\n\tstruct wl1251 *wl = hw->priv;\n\tint ret;\n\n\tmutex_lock(&wl->mutex);\n\n\tret = wl1251_ps_elp_wakeup(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl1251_acx_rts_threshold(wl, (u16) value);\n\tif (ret < 0)\n\t\twl1251_warning(\"wl1251_op_set_rts_threshold failed: %d\", ret);\n\n\twl1251_ps_elp_sleep(wl);\n\nout:\n\tmutex_unlock(&wl->mutex);\n\n\treturn ret;\n}\n\nstatic void wl1251_op_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_bss_conf *bss_conf,\n\t\t\t\t       u64 changed)\n{\n\tstruct wl1251 *wl = hw->priv;\n\tstruct sk_buff *beacon, *skb;\n\tbool enable;\n\tint ret;\n\n\twl1251_debug(DEBUG_MAC80211, \"mac80211 bss info changed\");\n\n\tmutex_lock(&wl->mutex);\n\n\tret = wl1251_ps_elp_wakeup(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (changed & BSS_CHANGED_CQM) {\n\t\tret = wl1251_acx_low_rssi(wl, bss_conf->cqm_rssi_thold,\n\t\t\t\t\t  WL1251_DEFAULT_LOW_RSSI_WEIGHT,\n\t\t\t\t\t  WL1251_DEFAULT_LOW_RSSI_DEPTH,\n\t\t\t\t\t  WL1251_ACX_LOW_RSSI_TYPE_EDGE);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\twl->rssi_thold = bss_conf->cqm_rssi_thold;\n\t}\n\n\tif ((changed & BSS_CHANGED_BSSID) &&\n\t    memcmp(wl->bssid, bss_conf->bssid, ETH_ALEN)) {\n\t\tmemcpy(wl->bssid, bss_conf->bssid, ETH_ALEN);\n\n\t\tif (!is_zero_ether_addr(wl->bssid)) {\n\t\t\tret = wl1251_build_null_data(wl);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_sleep;\n\n\t\t\tret = wl1251_build_qos_null_data(wl);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_sleep;\n\n\t\t\tret = wl1251_join(wl, wl->bss_type, wl->channel,\n\t\t\t\t\t  wl->beacon_int, wl->dtim_period);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_sleep;\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_ASSOC) {\n\t\tif (vif->cfg.assoc) {\n\t\t\twl->beacon_int = bss_conf->beacon_int;\n\n\t\t\tskb = ieee80211_pspoll_get(wl->hw, wl->vif);\n\t\t\tif (!skb)\n\t\t\t\tgoto out_sleep;\n\n\t\t\tret = wl1251_cmd_template_set(wl, CMD_PS_POLL,\n\t\t\t\t\t\t      skb->data,\n\t\t\t\t\t\t      skb->len);\n\t\t\tdev_kfree_skb(skb);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_sleep;\n\n\t\t\tret = wl1251_acx_aid(wl, vif->cfg.aid);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_sleep;\n\t\t} else {\n\t\t\t \n\t\t\twl->beacon_int = WL1251_DEFAULT_BEACON_INT;\n\t\t\twl->dtim_period = WL1251_DEFAULT_DTIM_PERIOD;\n\t\t}\n\t}\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\tif (bss_conf->use_short_slot)\n\t\t\tret = wl1251_acx_slot(wl, SLOT_TIME_SHORT);\n\t\telse\n\t\t\tret = wl1251_acx_slot(wl, SLOT_TIME_LONG);\n\t\tif (ret < 0) {\n\t\t\twl1251_warning(\"Set slot time failed %d\", ret);\n\t\t\tgoto out_sleep;\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_PREAMBLE) {\n\t\tif (bss_conf->use_short_preamble)\n\t\t\twl1251_acx_set_preamble(wl, ACX_PREAMBLE_SHORT);\n\t\telse\n\t\t\twl1251_acx_set_preamble(wl, ACX_PREAMBLE_LONG);\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_CTS_PROT) {\n\t\tif (bss_conf->use_cts_prot)\n\t\t\tret = wl1251_acx_cts_protect(wl, CTSPROTECT_ENABLE);\n\t\telse\n\t\t\tret = wl1251_acx_cts_protect(wl, CTSPROTECT_DISABLE);\n\t\tif (ret < 0) {\n\t\t\twl1251_warning(\"Set ctsprotect failed %d\", ret);\n\t\t\tgoto out_sleep;\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_ARP_FILTER) {\n\t\t__be32 addr = vif->cfg.arp_addr_list[0];\n\t\tWARN_ON(wl->bss_type != BSS_TYPE_STA_BSS);\n\n\t\tenable = vif->cfg.arp_addr_cnt == 1 && vif->cfg.assoc;\n\t\tret = wl1251_acx_arp_ip_filter(wl, enable, addr);\n\t\tif (ret < 0)\n\t\t\tgoto out_sleep;\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON) {\n\t\tbeacon = ieee80211_beacon_get(hw, vif, 0);\n\t\tif (!beacon)\n\t\t\tgoto out_sleep;\n\n\t\tret = wl1251_cmd_template_set(wl, CMD_BEACON, beacon->data,\n\t\t\t\t\t      beacon->len);\n\n\t\tif (ret < 0) {\n\t\t\tdev_kfree_skb(beacon);\n\t\t\tgoto out_sleep;\n\t\t}\n\n\t\tret = wl1251_cmd_template_set(wl, CMD_PROBE_RESP, beacon->data,\n\t\t\t\t\t      beacon->len);\n\n\t\tdev_kfree_skb(beacon);\n\n\t\tif (ret < 0)\n\t\t\tgoto out_sleep;\n\n\t\tret = wl1251_join(wl, wl->bss_type, wl->channel,\n\t\t\t\t  wl->beacon_int, wl->dtim_period);\n\n\t\tif (ret < 0)\n\t\t\tgoto out_sleep;\n\t}\n\nout_sleep:\n\twl1251_ps_elp_sleep(wl);\n\nout:\n\tmutex_unlock(&wl->mutex);\n}\n\n\n \nstatic struct ieee80211_rate wl1251_rates[] = {\n\t{ .bitrate = 10,\n\t  .hw_value = 0x1,\n\t  .hw_value_short = 0x1, },\n\t{ .bitrate = 20,\n\t  .hw_value = 0x2,\n\t  .hw_value_short = 0x2,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 55,\n\t  .hw_value = 0x4,\n\t  .hw_value_short = 0x4,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 110,\n\t  .hw_value = 0x20,\n\t  .hw_value_short = 0x20,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 60,\n\t  .hw_value = 0x8,\n\t  .hw_value_short = 0x8, },\n\t{ .bitrate = 90,\n\t  .hw_value = 0x10,\n\t  .hw_value_short = 0x10, },\n\t{ .bitrate = 120,\n\t  .hw_value = 0x40,\n\t  .hw_value_short = 0x40, },\n\t{ .bitrate = 180,\n\t  .hw_value = 0x80,\n\t  .hw_value_short = 0x80, },\n\t{ .bitrate = 240,\n\t  .hw_value = 0x200,\n\t  .hw_value_short = 0x200, },\n\t{ .bitrate = 360,\n\t .hw_value = 0x400,\n\t .hw_value_short = 0x400, },\n\t{ .bitrate = 480,\n\t  .hw_value = 0x800,\n\t  .hw_value_short = 0x800, },\n\t{ .bitrate = 540,\n\t  .hw_value = 0x1000,\n\t  .hw_value_short = 0x1000, },\n};\n\n \nstatic struct ieee80211_channel wl1251_channels[] = {\n\t{ .hw_value = 1, .center_freq = 2412},\n\t{ .hw_value = 2, .center_freq = 2417},\n\t{ .hw_value = 3, .center_freq = 2422},\n\t{ .hw_value = 4, .center_freq = 2427},\n\t{ .hw_value = 5, .center_freq = 2432},\n\t{ .hw_value = 6, .center_freq = 2437},\n\t{ .hw_value = 7, .center_freq = 2442},\n\t{ .hw_value = 8, .center_freq = 2447},\n\t{ .hw_value = 9, .center_freq = 2452},\n\t{ .hw_value = 10, .center_freq = 2457},\n\t{ .hw_value = 11, .center_freq = 2462},\n\t{ .hw_value = 12, .center_freq = 2467},\n\t{ .hw_value = 13, .center_freq = 2472},\n};\n\nstatic int wl1251_op_conf_tx(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     unsigned int link_id, u16 queue,\n\t\t\t     const struct ieee80211_tx_queue_params *params)\n{\n\tenum wl1251_acx_ps_scheme ps_scheme;\n\tstruct wl1251 *wl = hw->priv;\n\tint ret;\n\n\tmutex_lock(&wl->mutex);\n\n\twl1251_debug(DEBUG_MAC80211, \"mac80211 conf tx %d\", queue);\n\n\tret = wl1251_ps_elp_wakeup(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = wl1251_acx_ac_cfg(wl, wl1251_tx_get_queue(queue),\n\t\t\t\tparams->cw_min, params->cw_max,\n\t\t\t\tparams->aifs, params->txop * 32);\n\tif (ret < 0)\n\t\tgoto out_sleep;\n\n\tif (params->uapsd)\n\t\tps_scheme = WL1251_ACX_PS_SCHEME_UPSD_TRIGGER;\n\telse\n\t\tps_scheme = WL1251_ACX_PS_SCHEME_LEGACY;\n\n\tret = wl1251_acx_tid_cfg(wl, wl1251_tx_get_queue(queue),\n\t\t\t\t CHANNEL_TYPE_EDCF,\n\t\t\t\t wl1251_tx_get_queue(queue), ps_scheme,\n\t\t\t\t WL1251_ACX_ACK_POLICY_LEGACY);\n\tif (ret < 0)\n\t\tgoto out_sleep;\n\nout_sleep:\n\twl1251_ps_elp_sleep(wl);\n\nout:\n\tmutex_unlock(&wl->mutex);\n\n\treturn ret;\n}\n\nstatic int wl1251_op_get_survey(struct ieee80211_hw *hw, int idx,\n\t\t\t\tstruct survey_info *survey)\n{\n\tstruct wl1251 *wl = hw->priv;\n\tstruct ieee80211_conf *conf = &hw->conf;\n \n\tif (idx != 0)\n\t\treturn -ENOENT;\n \n\tsurvey->channel = conf->chandef.chan;\n\tsurvey->filled = SURVEY_INFO_NOISE_DBM;\n\tsurvey->noise = wl->noise;\n \n\treturn 0;\n}\n\n \nstatic struct ieee80211_supported_band wl1251_band_2ghz = {\n\t.channels = wl1251_channels,\n\t.n_channels = ARRAY_SIZE(wl1251_channels),\n\t.bitrates = wl1251_rates,\n\t.n_bitrates = ARRAY_SIZE(wl1251_rates),\n};\n\nstatic const struct ieee80211_ops wl1251_ops = {\n\t.start = wl1251_op_start,\n\t.stop = wl1251_op_stop,\n\t.add_interface = wl1251_op_add_interface,\n\t.remove_interface = wl1251_op_remove_interface,\n\t.config = wl1251_op_config,\n\t.prepare_multicast = wl1251_op_prepare_multicast,\n\t.configure_filter = wl1251_op_configure_filter,\n\t.tx = wl1251_op_tx,\n\t.wake_tx_queue = ieee80211_handle_wake_tx_queue,\n\t.set_key = wl1251_op_set_key,\n\t.hw_scan = wl1251_op_hw_scan,\n\t.bss_info_changed = wl1251_op_bss_info_changed,\n\t.set_rts_threshold = wl1251_op_set_rts_threshold,\n\t.conf_tx = wl1251_op_conf_tx,\n\t.get_survey = wl1251_op_get_survey,\n};\n\nstatic int wl1251_read_eeprom_byte(struct wl1251 *wl, off_t offset, u8 *data)\n{\n\tunsigned long timeout;\n\n\twl1251_reg_write32(wl, EE_ADDR, offset);\n\twl1251_reg_write32(wl, EE_CTL, EE_CTL_READ);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(100);\n\twhile (1) {\n\t\tif (!(wl1251_reg_read32(wl, EE_CTL) & EE_CTL_READ))\n\t\t\tbreak;\n\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -ETIMEDOUT;\n\n\t\tmsleep(1);\n\t}\n\n\t*data = wl1251_reg_read32(wl, EE_DATA);\n\treturn 0;\n}\n\nstatic int wl1251_read_eeprom(struct wl1251 *wl, off_t offset,\n\t\t\t      u8 *data, size_t len)\n{\n\tsize_t i;\n\tint ret;\n\n\twl1251_reg_write32(wl, EE_START, 0);\n\n\tfor (i = 0; i < len; i++) {\n\t\tret = wl1251_read_eeprom_byte(wl, offset + i, &data[i]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int wl1251_read_eeprom_mac(struct wl1251 *wl)\n{\n\tu8 mac[ETH_ALEN];\n\tint i, ret;\n\n\twl1251_set_partition(wl, 0, 0, REGISTERS_BASE, REGISTERS_DOWN_SIZE);\n\n\tret = wl1251_read_eeprom(wl, 0x1c, mac, sizeof(mac));\n\tif (ret < 0) {\n\t\twl1251_warning(\"failed to read MAC address from EEPROM\");\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\twl->mac_addr[i] = mac[ETH_ALEN - i - 1];\n\n\treturn 0;\n}\n\n#define NVS_OFF_MAC_LEN 0x19\n#define NVS_OFF_MAC_ADDR_LO 0x1a\n#define NVS_OFF_MAC_ADDR_HI 0x1b\n#define NVS_OFF_MAC_DATA 0x1c\n\nstatic int wl1251_check_nvs_mac(struct wl1251 *wl)\n{\n\tif (wl->nvs_len < 0x24)\n\t\treturn -ENODATA;\n\n\t \n\tif (wl->nvs[NVS_OFF_MAC_LEN] != 2 ||\n\t    wl->nvs[NVS_OFF_MAC_ADDR_LO] != 0x6d ||\n\t    wl->nvs[NVS_OFF_MAC_ADDR_HI] != 0x54)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int wl1251_read_nvs_mac(struct wl1251 *wl)\n{\n\tu8 mac[ETH_ALEN];\n\tint i, ret;\n\n\tret = wl1251_check_nvs_mac(wl);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tmac[i] = wl->nvs[NVS_OFF_MAC_DATA + ETH_ALEN - i - 1];\n\n\t \n\tif (ether_addr_equal_unaligned(mac, \"\\x00\\x00\\x20\\x07\\x03\\x09\"))\n\t\treturn -EINVAL;\n\n\tmemcpy(wl->mac_addr, mac, ETH_ALEN);\n\treturn 0;\n}\n\nstatic int wl1251_write_nvs_mac(struct wl1251 *wl)\n{\n\tint i, ret;\n\n\tret = wl1251_check_nvs_mac(wl);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\twl->nvs[NVS_OFF_MAC_DATA + i] = wl->mac_addr[ETH_ALEN - i - 1];\n\n\treturn 0;\n}\n\nstatic int wl1251_register_hw(struct wl1251 *wl)\n{\n\tint ret;\n\n\tif (wl->mac80211_registered)\n\t\treturn 0;\n\n\tSET_IEEE80211_PERM_ADDR(wl->hw, wl->mac_addr);\n\n\tret = ieee80211_register_hw(wl->hw);\n\tif (ret < 0) {\n\t\twl1251_error(\"unable to register mac80211 hw: %d\", ret);\n\t\treturn ret;\n\t}\n\n\twl->mac80211_registered = true;\n\n\twl1251_notice(\"loaded\");\n\n\treturn 0;\n}\n\nint wl1251_init_ieee80211(struct wl1251 *wl)\n{\n\tint ret;\n\n\t \n\twl->hw->extra_tx_headroom = sizeof(struct tx_double_buffer_desc)\n\t\t+ WL1251_TKIP_IV_SPACE;\n\n\t \n\t \n\n\tieee80211_hw_set(wl->hw, SIGNAL_DBM);\n\tieee80211_hw_set(wl->hw, SUPPORTS_PS);\n\n\twl->hw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t\t BIT(NL80211_IFTYPE_ADHOC);\n\twl->hw->wiphy->max_scan_ssids = 1;\n\n\t \n\twl->hw->wiphy->max_scan_ie_len = 512;\n\n\twl->hw->wiphy->bands[NL80211_BAND_2GHZ] = &wl1251_band_2ghz;\n\n\twl->hw->queues = 4;\n\n\tif (wl->nvs == NULL && !wl->use_eeprom) {\n\t\tret = wl1251_fetch_nvs(wl);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (wl->use_eeprom)\n\t\tret = wl1251_read_eeprom_mac(wl);\n\telse\n\t\tret = wl1251_read_nvs_mac(wl);\n\n\tif (ret == 0 && !is_valid_ether_addr(wl->mac_addr))\n\t\tret = -EINVAL;\n\n\tif (ret < 0) {\n\t\t \n\t\tstatic const u8 nokia_oui[3] = {0x00, 0x1f, 0xdf};\n\t\tmemcpy(wl->mac_addr, nokia_oui, 3);\n\t\tget_random_bytes(wl->mac_addr + 3, 3);\n\t\tif (!wl->use_eeprom)\n\t\t\twl1251_write_nvs_mac(wl);\n\t\twl1251_warning(\"MAC address in eeprom or nvs data is not valid\");\n\t\twl1251_warning(\"Setting random MAC address: %pM\", wl->mac_addr);\n\t}\n\n\tret = wl1251_register_hw(wl);\n\tif (ret)\n\t\tgoto out;\n\n\twl1251_debugfs_init(wl);\n\twl1251_notice(\"initialized\");\n\n\tret = 0;\n\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wl1251_init_ieee80211);\n\nstruct ieee80211_hw *wl1251_alloc_hw(void)\n{\n\tstruct ieee80211_hw *hw;\n\tstruct wl1251 *wl;\n\tint i;\n\n\thw = ieee80211_alloc_hw(sizeof(*wl), &wl1251_ops);\n\tif (!hw) {\n\t\twl1251_error(\"could not alloc ieee80211_hw\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\twl = hw->priv;\n\tmemset(wl, 0, sizeof(*wl));\n\n\twl->hw = hw;\n\n\twl->data_in_count = 0;\n\n\tskb_queue_head_init(&wl->tx_queue);\n\n\tINIT_DELAYED_WORK(&wl->elp_work, wl1251_elp_work);\n\twl->channel = WL1251_DEFAULT_CHANNEL;\n\twl->monitor_present = false;\n\twl->joined = false;\n\twl->scanning = false;\n\twl->bss_type = MAX_BSS_TYPE;\n\twl->default_key = 0;\n\twl->listen_int = 1;\n\twl->rx_counter = 0;\n\twl->rx_handled = 0;\n\twl->rx_current_buffer = 0;\n\twl->rx_last_id = 0;\n\twl->rx_config = WL1251_DEFAULT_RX_CONFIG;\n\twl->rx_filter = WL1251_DEFAULT_RX_FILTER;\n\twl->elp = false;\n\twl->station_mode = STATION_ACTIVE_MODE;\n\twl->psm_requested = false;\n\twl->psm_entry_retry = 0;\n\twl->tx_queue_stopped = false;\n\twl->power_level = WL1251_DEFAULT_POWER_LEVEL;\n\twl->rssi_thold = 0;\n\twl->beacon_int = WL1251_DEFAULT_BEACON_INT;\n\twl->dtim_period = WL1251_DEFAULT_DTIM_PERIOD;\n\twl->vif = NULL;\n\n\tfor (i = 0; i < FW_TX_CMPLT_BLOCK_SIZE; i++)\n\t\twl->tx_frames[i] = NULL;\n\n\twl->next_tx_complete = 0;\n\n\tINIT_WORK(&wl->irq_work, wl1251_irq_work);\n\tINIT_WORK(&wl->tx_work, wl1251_tx_work);\n\n\twl->state = WL1251_STATE_OFF;\n\tmutex_init(&wl->mutex);\n\tspin_lock_init(&wl->wl_lock);\n\n\twl->tx_mgmt_frm_rate = DEFAULT_HW_GEN_TX_RATE;\n\twl->tx_mgmt_frm_mod = DEFAULT_HW_GEN_MODULATION_TYPE;\n\n\twl->rx_descriptor = kmalloc(sizeof(*wl->rx_descriptor), GFP_KERNEL);\n\tif (!wl->rx_descriptor) {\n\t\twl1251_error(\"could not allocate memory for rx descriptor\");\n\t\tieee80211_free_hw(hw);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn hw;\n}\nEXPORT_SYMBOL_GPL(wl1251_alloc_hw);\n\nint wl1251_free_hw(struct wl1251 *wl)\n{\n\tieee80211_unregister_hw(wl->hw);\n\n\twl1251_debugfs_exit(wl);\n\n\tkfree(wl->target_mem_map);\n\tkfree(wl->data_path);\n\tvfree(wl->fw);\n\twl->fw = NULL;\n\tkfree(wl->nvs);\n\twl->nvs = NULL;\n\n\tkfree(wl->rx_descriptor);\n\twl->rx_descriptor = NULL;\n\n\tieee80211_free_hw(wl->hw);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wl1251_free_hw);\n\nMODULE_DESCRIPTION(\"TI wl1251 Wireless LAN Driver Core\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kalle Valo <kvalo@adurom.com>\");\nMODULE_FIRMWARE(WL1251_FW_NAME);\nMODULE_FIRMWARE(WL1251_NVS_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}