{
  "module_name": "acx.c",
  "hash_id": "febb7b8b47aea91b9005989bec6b67bd9aa05a3bf355f2a9ecc46c5d7747347f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wl1251/acx.c",
  "human_readable_source": "\n#include \"acx.h\"\n\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include \"wl1251.h\"\n#include \"reg.h\"\n#include \"cmd.h\"\n#include \"ps.h\"\n\nint wl1251_acx_frame_rates(struct wl1251 *wl, u8 ctrl_rate, u8 ctrl_mod,\n\t\t\t   u8 mgt_rate, u8 mgt_mod)\n{\n\tstruct acx_fw_gen_frame_rates *rates;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx frame rates\");\n\n\trates = kzalloc(sizeof(*rates), GFP_KERNEL);\n\tif (!rates)\n\t\treturn -ENOMEM;\n\n\trates->tx_ctrl_frame_rate = ctrl_rate;\n\trates->tx_ctrl_frame_mod = ctrl_mod;\n\trates->tx_mgt_frame_rate = mgt_rate;\n\trates->tx_mgt_frame_mod = mgt_mod;\n\n\tret = wl1251_cmd_configure(wl, ACX_FW_GEN_FRAME_RATES,\n\t\t\t\t   rates, sizeof(*rates));\n\tif (ret < 0) {\n\t\twl1251_error(\"Failed to set FW rates and modulation\");\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(rates);\n\treturn ret;\n}\n\n\nint wl1251_acx_station_id(struct wl1251 *wl)\n{\n\tstruct acx_dot11_station_id *mac;\n\tint ret, i;\n\n\twl1251_debug(DEBUG_ACX, \"acx dot11_station_id\");\n\n\tmac = kzalloc(sizeof(*mac), GFP_KERNEL);\n\tif (!mac)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tmac->mac[i] = wl->mac_addr[ETH_ALEN - 1 - i];\n\n\tret = wl1251_cmd_configure(wl, DOT11_STATION_ID, mac, sizeof(*mac));\n\n\tkfree(mac);\n\treturn ret;\n}\n\nint wl1251_acx_default_key(struct wl1251 *wl, u8 key_id)\n{\n\tstruct acx_dot11_default_key *default_key;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx dot11_default_key (%d)\", key_id);\n\n\tdefault_key = kzalloc(sizeof(*default_key), GFP_KERNEL);\n\tif (!default_key)\n\t\treturn -ENOMEM;\n\n\tdefault_key->id = key_id;\n\n\tret = wl1251_cmd_configure(wl, DOT11_DEFAULT_KEY,\n\t\t\t\t   default_key, sizeof(*default_key));\n\tif (ret < 0) {\n\t\twl1251_error(\"Couldn't set default key\");\n\t\tgoto out;\n\t}\n\n\twl->default_key = key_id;\n\nout:\n\tkfree(default_key);\n\treturn ret;\n}\n\nint wl1251_acx_wake_up_conditions(struct wl1251 *wl, u8 wake_up_event,\n\t\t\t\t  u8 listen_interval)\n{\n\tstruct acx_wake_up_condition *wake_up;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx wake up conditions\");\n\n\twake_up = kzalloc(sizeof(*wake_up), GFP_KERNEL);\n\tif (!wake_up)\n\t\treturn -ENOMEM;\n\n\twake_up->wake_up_event = wake_up_event;\n\twake_up->listen_interval = listen_interval;\n\n\tret = wl1251_cmd_configure(wl, ACX_WAKE_UP_CONDITIONS,\n\t\t\t\t   wake_up, sizeof(*wake_up));\n\tif (ret < 0) {\n\t\twl1251_warning(\"could not set wake up conditions: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(wake_up);\n\treturn ret;\n}\n\nint wl1251_acx_sleep_auth(struct wl1251 *wl, u8 sleep_auth)\n{\n\tstruct acx_sleep_auth *auth;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx sleep auth\");\n\n\tauth = kzalloc(sizeof(*auth), GFP_KERNEL);\n\tif (!auth)\n\t\treturn -ENOMEM;\n\n\tauth->sleep_auth = sleep_auth;\n\n\tret = wl1251_cmd_configure(wl, ACX_SLEEP_AUTH, auth, sizeof(*auth));\n\n\tkfree(auth);\n\treturn ret;\n}\n\nint wl1251_acx_fw_version(struct wl1251 *wl, char *buf, size_t len)\n{\n\tstruct acx_revision *rev;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx fw rev\");\n\n\trev = kzalloc(sizeof(*rev), GFP_KERNEL);\n\tif (!rev)\n\t\treturn -ENOMEM;\n\n\tret = wl1251_cmd_interrogate(wl, ACX_FW_REV, rev, sizeof(*rev));\n\tif (ret < 0) {\n\t\twl1251_warning(\"ACX_FW_REV interrogate failed\");\n\t\tgoto out;\n\t}\n\n\t \n\tstrncpy(buf, rev->fw_version, min(len, sizeof(rev->fw_version)));\n\n\t \n\tbuf[min(len, sizeof(rev->fw_version)) - 1] = '\\0';\n\nout:\n\tkfree(rev);\n\treturn ret;\n}\n\nint wl1251_acx_tx_power(struct wl1251 *wl, int power)\n{\n\tstruct acx_current_tx_power *acx;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx dot11_cur_tx_pwr\");\n\n\tif (power < 0 || power > 25)\n\t\treturn -EINVAL;\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx)\n\t\treturn -ENOMEM;\n\n\tacx->current_tx_power = power * 10;\n\n\tret = wl1251_cmd_configure(wl, DOT11_CUR_TX_PWR, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1251_warning(\"configure of tx power failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1251_acx_feature_cfg(struct wl1251 *wl, u32 data_flow_options)\n{\n\tstruct acx_feature_config *feature;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx feature cfg\");\n\n\tfeature = kzalloc(sizeof(*feature), GFP_KERNEL);\n\tif (!feature)\n\t\treturn -ENOMEM;\n\n\t \n\tfeature->data_flow_options = data_flow_options;\n\tfeature->options = 0;\n\n\tret = wl1251_cmd_configure(wl, ACX_FEATURE_CFG,\n\t\t\t\t   feature, sizeof(*feature));\n\tif (ret < 0) {\n\t\twl1251_error(\"Couldn't set HW encryption\");\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(feature);\n\treturn ret;\n}\n\nint wl1251_acx_mem_map(struct wl1251 *wl, struct acx_header *mem_map,\n\t\t       size_t len)\n{\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx mem map\");\n\n\tret = wl1251_cmd_interrogate(wl, ACX_MEM_MAP, mem_map, len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint wl1251_acx_data_path_params(struct wl1251 *wl,\n\t\t\t\tstruct acx_data_path_params_resp *resp)\n{\n\tstruct acx_data_path_params *params;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx data path params\");\n\n\tparams = kzalloc(sizeof(*params), GFP_KERNEL);\n\tif (!params)\n\t\treturn -ENOMEM;\n\n\tparams->rx_packet_ring_chunk_size = DP_RX_PACKET_RING_CHUNK_SIZE;\n\tparams->tx_packet_ring_chunk_size = DP_TX_PACKET_RING_CHUNK_SIZE;\n\n\tparams->rx_packet_ring_chunk_num = DP_RX_PACKET_RING_CHUNK_NUM;\n\tparams->tx_packet_ring_chunk_num = DP_TX_PACKET_RING_CHUNK_NUM;\n\n\tparams->tx_complete_threshold = 1;\n\n\tparams->tx_complete_ring_depth = FW_TX_CMPLT_BLOCK_SIZE;\n\n\tparams->tx_complete_timeout = DP_TX_COMPLETE_TIME_OUT;\n\n\tret = wl1251_cmd_configure(wl, ACX_DATA_PATH_PARAMS,\n\t\t\t\t   params, sizeof(*params));\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = wl1251_cmd_interrogate(wl, ACX_DATA_PATH_PARAMS,\n\t\t\t\t     resp, sizeof(*resp));\n\n\tif (ret < 0) {\n\t\twl1251_warning(\"failed to read data path parameters: %d\", ret);\n\t\tgoto out;\n\t} else if (resp->header.cmd.status != CMD_STATUS_SUCCESS) {\n\t\twl1251_warning(\"data path parameter acx status failed\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(params);\n\treturn ret;\n}\n\nint wl1251_acx_rx_msdu_life_time(struct wl1251 *wl, u32 life_time)\n{\n\tstruct acx_rx_msdu_lifetime *acx;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx rx msdu life time\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx)\n\t\treturn -ENOMEM;\n\n\tacx->lifetime = life_time;\n\tret = wl1251_cmd_configure(wl, DOT11_RX_MSDU_LIFE_TIME,\n\t\t\t\t   acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1251_warning(\"failed to set rx msdu life time: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1251_acx_rx_config(struct wl1251 *wl, u32 config, u32 filter)\n{\n\tstruct acx_rx_config *rx_config;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx rx config\");\n\n\trx_config = kzalloc(sizeof(*rx_config), GFP_KERNEL);\n\tif (!rx_config)\n\t\treturn -ENOMEM;\n\n\trx_config->config_options = config;\n\trx_config->filter_options = filter;\n\n\tret = wl1251_cmd_configure(wl, ACX_RX_CFG,\n\t\t\t\t   rx_config, sizeof(*rx_config));\n\tif (ret < 0) {\n\t\twl1251_warning(\"failed to set rx config: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(rx_config);\n\treturn ret;\n}\n\nint wl1251_acx_pd_threshold(struct wl1251 *wl)\n{\n\tstruct acx_packet_detection *pd;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx data pd threshold\");\n\n\tpd = kzalloc(sizeof(*pd), GFP_KERNEL);\n\tif (!pd)\n\t\treturn -ENOMEM;\n\n\t \n\n\tret = wl1251_cmd_configure(wl, ACX_PD_THRESHOLD, pd, sizeof(*pd));\n\tif (ret < 0) {\n\t\twl1251_warning(\"failed to set pd threshold: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(pd);\n\treturn ret;\n}\n\nint wl1251_acx_slot(struct wl1251 *wl, enum acx_slot_type slot_time)\n{\n\tstruct acx_slot *slot;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx slot\");\n\n\tslot = kzalloc(sizeof(*slot), GFP_KERNEL);\n\tif (!slot)\n\t\treturn -ENOMEM;\n\n\tslot->wone_index = STATION_WONE_INDEX;\n\tslot->slot_time = slot_time;\n\n\tret = wl1251_cmd_configure(wl, ACX_SLOT, slot, sizeof(*slot));\n\tif (ret < 0) {\n\t\twl1251_warning(\"failed to set slot time: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(slot);\n\treturn ret;\n}\n\nint wl1251_acx_group_address_tbl(struct wl1251 *wl, bool enable,\n\t\t\t\t void *mc_list, u32 mc_list_len)\n{\n\tstruct acx_dot11_grp_addr_tbl *acx;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx group address tbl\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx)\n\t\treturn -ENOMEM;\n\n\t \n\tacx->enabled = enable;\n\tacx->num_groups = mc_list_len;\n\tmemcpy(acx->mac_table, mc_list, mc_list_len * ETH_ALEN);\n\n\tret = wl1251_cmd_configure(wl, DOT11_GROUP_ADDRESS_TBL,\n\t\t\t\t   acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1251_warning(\"failed to set group addr table: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1251_acx_service_period_timeout(struct wl1251 *wl)\n{\n\tstruct acx_rx_timeout *rx_timeout;\n\tint ret;\n\n\trx_timeout = kzalloc(sizeof(*rx_timeout), GFP_KERNEL);\n\tif (!rx_timeout)\n\t\treturn -ENOMEM;\n\n\twl1251_debug(DEBUG_ACX, \"acx service period timeout\");\n\n\trx_timeout->ps_poll_timeout = RX_TIMEOUT_PS_POLL_DEF;\n\trx_timeout->upsd_timeout = RX_TIMEOUT_UPSD_DEF;\n\n\tret = wl1251_cmd_configure(wl, ACX_SERVICE_PERIOD_TIMEOUT,\n\t\t\t\t   rx_timeout, sizeof(*rx_timeout));\n\tif (ret < 0) {\n\t\twl1251_warning(\"failed to set service period timeout: %d\",\n\t\t\t       ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(rx_timeout);\n\treturn ret;\n}\n\nint wl1251_acx_rts_threshold(struct wl1251 *wl, u16 rts_threshold)\n{\n\tstruct acx_rts_threshold *rts;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx rts threshold\");\n\n\trts = kzalloc(sizeof(*rts), GFP_KERNEL);\n\tif (!rts)\n\t\treturn -ENOMEM;\n\n\trts->threshold = rts_threshold;\n\n\tret = wl1251_cmd_configure(wl, DOT11_RTS_THRESHOLD, rts, sizeof(*rts));\n\tif (ret < 0) {\n\t\twl1251_warning(\"failed to set rts threshold: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(rts);\n\treturn ret;\n}\n\nint wl1251_acx_beacon_filter_opt(struct wl1251 *wl, bool enable_filter)\n{\n\tstruct acx_beacon_filter_option *beacon_filter;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx beacon filter opt\");\n\n\tbeacon_filter = kzalloc(sizeof(*beacon_filter), GFP_KERNEL);\n\tif (!beacon_filter)\n\t\treturn -ENOMEM;\n\n\tbeacon_filter->enable = enable_filter;\n\tbeacon_filter->max_num_beacons = 0;\n\n\tret = wl1251_cmd_configure(wl, ACX_BEACON_FILTER_OPT,\n\t\t\t\t   beacon_filter, sizeof(*beacon_filter));\n\tif (ret < 0) {\n\t\twl1251_warning(\"failed to set beacon filter opt: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(beacon_filter);\n\treturn ret;\n}\n\nint wl1251_acx_beacon_filter_table(struct wl1251 *wl)\n{\n\tstruct acx_beacon_filter_ie_table *ie_table;\n\tint idx = 0;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx beacon filter table\");\n\n\tie_table = kzalloc(sizeof(*ie_table), GFP_KERNEL);\n\tif (!ie_table)\n\t\treturn -ENOMEM;\n\n\t \n\tie_table->num_ie = 1;\n\tie_table->table[idx++] = BEACON_FILTER_IE_ID_CHANNEL_SWITCH_ANN;\n\tie_table->table[idx++] = BEACON_RULE_PASS_ON_APPEARANCE;\n\n\tret = wl1251_cmd_configure(wl, ACX_BEACON_FILTER_TABLE,\n\t\t\t\t   ie_table, sizeof(*ie_table));\n\tif (ret < 0) {\n\t\twl1251_warning(\"failed to set beacon filter table: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(ie_table);\n\treturn ret;\n}\n\nint wl1251_acx_conn_monit_params(struct wl1251 *wl)\n{\n\tstruct acx_conn_monit_params *acx;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx connection monitor parameters\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx)\n\t\treturn -ENOMEM;\n\n\tacx->synch_fail_thold = SYNCH_FAIL_DEFAULT_THRESHOLD;\n\tacx->bss_lose_timeout = NO_BEACON_DEFAULT_TIMEOUT;\n\n\tret = wl1251_cmd_configure(wl, ACX_CONN_MONIT_PARAMS,\n\t\t\t\t   acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1251_warning(\"failed to set connection monitor \"\n\t\t\t       \"parameters: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1251_acx_sg_enable(struct wl1251 *wl)\n{\n\tstruct acx_bt_wlan_coex *pta;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx sg enable\");\n\n\tpta = kzalloc(sizeof(*pta), GFP_KERNEL);\n\tif (!pta)\n\t\treturn -ENOMEM;\n\n\tpta->enable = SG_ENABLE;\n\n\tret = wl1251_cmd_configure(wl, ACX_SG_ENABLE, pta, sizeof(*pta));\n\tif (ret < 0) {\n\t\twl1251_warning(\"failed to set softgemini enable: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(pta);\n\treturn ret;\n}\n\nint wl1251_acx_sg_cfg(struct wl1251 *wl)\n{\n\tstruct acx_bt_wlan_coex_param *param;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx sg cfg\");\n\n\tparam = kzalloc(sizeof(*param), GFP_KERNEL);\n\tif (!param)\n\t\treturn -ENOMEM;\n\n\t \n\tparam->min_rate = RATE_INDEX_24MBPS;\n\tparam->bt_hp_max_time = PTA_BT_HP_MAXTIME_DEF;\n\tparam->wlan_hp_max_time = PTA_WLAN_HP_MAX_TIME_DEF;\n\tparam->sense_disable_timer = PTA_SENSE_DISABLE_TIMER_DEF;\n\tparam->rx_time_bt_hp = PTA_PROTECTIVE_RX_TIME_DEF;\n\tparam->tx_time_bt_hp = PTA_PROTECTIVE_TX_TIME_DEF;\n\tparam->rx_time_bt_hp_fast = PTA_PROTECTIVE_RX_TIME_FAST_DEF;\n\tparam->tx_time_bt_hp_fast = PTA_PROTECTIVE_TX_TIME_FAST_DEF;\n\tparam->wlan_cycle_fast = PTA_CYCLE_TIME_FAST_DEF;\n\tparam->bt_anti_starvation_period = PTA_ANTI_STARVE_PERIOD_DEF;\n\tparam->next_bt_lp_packet = PTA_TIMEOUT_NEXT_BT_LP_PACKET_DEF;\n\tparam->wake_up_beacon = PTA_TIME_BEFORE_BEACON_DEF;\n\tparam->hp_dm_max_guard_time = PTA_HPDM_MAX_TIME_DEF;\n\tparam->next_wlan_packet = PTA_TIME_OUT_NEXT_WLAN_DEF;\n\tparam->antenna_type = PTA_ANTENNA_TYPE_DEF;\n\tparam->signal_type = PTA_SIGNALING_TYPE_DEF;\n\tparam->afh_leverage_on = PTA_AFH_LEVERAGE_ON_DEF;\n\tparam->quiet_cycle_num = PTA_NUMBER_QUIET_CYCLE_DEF;\n\tparam->max_cts = PTA_MAX_NUM_CTS_DEF;\n\tparam->wlan_packets_num = PTA_NUMBER_OF_WLAN_PACKETS_DEF;\n\tparam->bt_packets_num = PTA_NUMBER_OF_BT_PACKETS_DEF;\n\tparam->missed_rx_avalanche = PTA_RX_FOR_AVALANCHE_DEF;\n\tparam->wlan_elp_hp = PTA_ELP_HP_DEF;\n\tparam->bt_anti_starvation_cycles = PTA_ANTI_STARVE_NUM_CYCLE_DEF;\n\tparam->ack_mode_dual_ant = PTA_ACK_MODE_DEF;\n\tparam->pa_sd_enable = PTA_ALLOW_PA_SD_DEF;\n\tparam->pta_auto_mode_enable = PTA_AUTO_MODE_NO_CTS_DEF;\n\tparam->bt_hp_respected_num = PTA_BT_HP_RESPECTED_DEF;\n\n\tret = wl1251_cmd_configure(wl, ACX_SG_CFG, param, sizeof(*param));\n\tif (ret < 0) {\n\t\twl1251_warning(\"failed to set sg config: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(param);\n\treturn ret;\n}\n\nint wl1251_acx_cca_threshold(struct wl1251 *wl)\n{\n\tstruct acx_energy_detection *detection;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx cca threshold\");\n\n\tdetection = kzalloc(sizeof(*detection), GFP_KERNEL);\n\tif (!detection)\n\t\treturn -ENOMEM;\n\n\tdetection->rx_cca_threshold = CCA_THRSH_DISABLE_ENERGY_D;\n\tdetection->tx_energy_detection = 0;\n\n\tret = wl1251_cmd_configure(wl, ACX_CCA_THRESHOLD,\n\t\t\t\t   detection, sizeof(*detection));\n\tif (ret < 0)\n\t\twl1251_warning(\"failed to set cca threshold: %d\", ret);\n\n\tkfree(detection);\n\treturn ret;\n}\n\nint wl1251_acx_bcn_dtim_options(struct wl1251 *wl)\n{\n\tstruct acx_beacon_broadcast *bb;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx bcn dtim options\");\n\n\tbb = kzalloc(sizeof(*bb), GFP_KERNEL);\n\tif (!bb)\n\t\treturn -ENOMEM;\n\n\tbb->beacon_rx_timeout = BCN_RX_TIMEOUT_DEF_VALUE;\n\tbb->broadcast_timeout = BROADCAST_RX_TIMEOUT_DEF_VALUE;\n\tbb->rx_broadcast_in_ps = RX_BROADCAST_IN_PS_DEF_VALUE;\n\tbb->ps_poll_threshold = CONSECUTIVE_PS_POLL_FAILURE_DEF;\n\n\tret = wl1251_cmd_configure(wl, ACX_BCN_DTIM_OPTIONS, bb, sizeof(*bb));\n\tif (ret < 0) {\n\t\twl1251_warning(\"failed to set rx config: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(bb);\n\treturn ret;\n}\n\nint wl1251_acx_aid(struct wl1251 *wl, u16 aid)\n{\n\tstruct acx_aid *acx_aid;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx aid\");\n\n\tacx_aid = kzalloc(sizeof(*acx_aid), GFP_KERNEL);\n\tif (!acx_aid)\n\t\treturn -ENOMEM;\n\n\tacx_aid->aid = aid;\n\n\tret = wl1251_cmd_configure(wl, ACX_AID, acx_aid, sizeof(*acx_aid));\n\tif (ret < 0) {\n\t\twl1251_warning(\"failed to set aid: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx_aid);\n\treturn ret;\n}\n\nint wl1251_acx_event_mbox_mask(struct wl1251 *wl, u32 event_mask)\n{\n\tstruct acx_event_mask *mask;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx event mbox mask\");\n\n\tmask = kzalloc(sizeof(*mask), GFP_KERNEL);\n\tif (!mask)\n\t\treturn -ENOMEM;\n\n\t \n\tmask->high_event_mask = 0xffffffff;\n\n\tmask->event_mask = event_mask;\n\n\tret = wl1251_cmd_configure(wl, ACX_EVENT_MBOX_MASK,\n\t\t\t\t   mask, sizeof(*mask));\n\tif (ret < 0) {\n\t\twl1251_warning(\"failed to set acx_event_mbox_mask: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(mask);\n\treturn ret;\n}\n\nint wl1251_acx_low_rssi(struct wl1251 *wl, s8 threshold, u8 weight,\n\t\t\tu8 depth, enum wl1251_acx_low_rssi_type type)\n{\n\tstruct acx_low_rssi *rssi;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx low rssi\");\n\n\trssi = kzalloc(sizeof(*rssi), GFP_KERNEL);\n\tif (!rssi)\n\t\treturn -ENOMEM;\n\n\trssi->threshold = threshold;\n\trssi->weight = weight;\n\trssi->depth = depth;\n\trssi->type = type;\n\n\tret = wl1251_cmd_configure(wl, ACX_LOW_RSSI, rssi, sizeof(*rssi));\n\tif (ret < 0)\n\t\twl1251_warning(\"failed to set low rssi threshold: %d\", ret);\n\n\tkfree(rssi);\n\treturn ret;\n}\n\nint wl1251_acx_set_preamble(struct wl1251 *wl, enum acx_preamble_type preamble)\n{\n\tstruct acx_preamble *acx;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx_set_preamble\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx)\n\t\treturn -ENOMEM;\n\n\tacx->preamble = preamble;\n\n\tret = wl1251_cmd_configure(wl, ACX_PREAMBLE_TYPE, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1251_warning(\"Setting of preamble failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1251_acx_cts_protect(struct wl1251 *wl,\n\t\t\t   enum acx_ctsprotect_type ctsprotect)\n{\n\tstruct acx_ctsprotect *acx;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx_set_ctsprotect\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx)\n\t\treturn -ENOMEM;\n\n\tacx->ctsprotect = ctsprotect;\n\n\tret = wl1251_cmd_configure(wl, ACX_CTS_PROTECTION, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1251_warning(\"Setting of ctsprotect failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1251_acx_tsf_info(struct wl1251 *wl, u64 *mactime)\n{\n\tstruct acx_tsf_info *tsf_info;\n\tint ret;\n\n\ttsf_info = kzalloc(sizeof(*tsf_info), GFP_KERNEL);\n\tif (!tsf_info)\n\t\treturn -ENOMEM;\n\n\tret = wl1251_cmd_interrogate(wl, ACX_TSF_INFO,\n\t\t\t\t     tsf_info, sizeof(*tsf_info));\n\tif (ret < 0) {\n\t\twl1251_warning(\"ACX_FW_REV interrogate failed\");\n\t\tgoto out;\n\t}\n\n\t*mactime = tsf_info->current_tsf_lsb |\n\t\t((u64)tsf_info->current_tsf_msb << 32);\n\nout:\n\tkfree(tsf_info);\n\treturn ret;\n}\n\nint wl1251_acx_statistics(struct wl1251 *wl, struct acx_statistics *stats)\n{\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx statistics\");\n\n\tret = wl1251_cmd_interrogate(wl, ACX_STATISTICS, stats,\n\t\t\t\t     sizeof(*stats));\n\tif (ret < 0) {\n\t\twl1251_warning(\"acx statistics failed: %d\", ret);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nint wl1251_acx_rate_policies(struct wl1251 *wl)\n{\n\tstruct acx_rate_policy *acx;\n\tint ret = 0;\n\n\twl1251_debug(DEBUG_ACX, \"acx rate policies\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx)\n\t\treturn -ENOMEM;\n\n\t \n\tacx->rate_class_cnt = 2;\n\tacx->rate_class[0].enabled_rates = ACX_RATE_MASK_UNSPECIFIED;\n\tacx->rate_class[0].short_retry_limit = ACX_RATE_RETRY_LIMIT;\n\tacx->rate_class[0].long_retry_limit = ACX_RATE_RETRY_LIMIT;\n\tacx->rate_class[0].aflags = 0;\n\n\t \n\tacx->rate_class[1].enabled_rates = ACX_RATE_MASK_UNSPECIFIED;\n\tacx->rate_class[1].short_retry_limit = 0;\n\tacx->rate_class[1].long_retry_limit = 0;\n\tacx->rate_class[1].aflags = 0;\n\n\tret = wl1251_cmd_configure(wl, ACX_RATE_POLICY, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1251_warning(\"Setting of rate policies failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1251_acx_mem_cfg(struct wl1251 *wl)\n{\n\tstruct wl1251_acx_config_memory *mem_conf;\n\tint ret, i;\n\n\twl1251_debug(DEBUG_ACX, \"acx mem cfg\");\n\n\tmem_conf = kzalloc(sizeof(*mem_conf), GFP_KERNEL);\n\tif (!mem_conf)\n\t\treturn -ENOMEM;\n\n\t \n\tmem_conf->mem_config.num_stations = cpu_to_le16(DEFAULT_NUM_STATIONS);\n\tmem_conf->mem_config.rx_mem_block_num = 35;\n\tmem_conf->mem_config.tx_min_mem_block_num = 64;\n\tmem_conf->mem_config.num_tx_queues = MAX_TX_QUEUES;\n\tmem_conf->mem_config.host_if_options = HOSTIF_PKT_RING;\n\tmem_conf->mem_config.num_ssid_profiles = 1;\n\tmem_conf->mem_config.debug_buffer_size =\n\t\tcpu_to_le16(TRACE_BUFFER_MAX_SIZE);\n\n\t \n\tmem_conf->rx_queue_config.dma_address = 0;\n\tmem_conf->rx_queue_config.num_descs = ACX_RX_DESC_DEF;\n\tmem_conf->rx_queue_config.priority = DEFAULT_RXQ_PRIORITY;\n\tmem_conf->rx_queue_config.type = DEFAULT_RXQ_TYPE;\n\n\t \n\tfor (i = 0; i < MAX_TX_QUEUES; i++) {\n\t\tmem_conf->tx_queue_config[i].num_descs = ACX_TX_DESC_DEF;\n\t\tmem_conf->tx_queue_config[i].attributes = i;\n\t}\n\n\tret = wl1251_cmd_configure(wl, ACX_MEM_CFG, mem_conf,\n\t\t\t\t   sizeof(*mem_conf));\n\tif (ret < 0) {\n\t\twl1251_warning(\"wl1251 mem config failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(mem_conf);\n\treturn ret;\n}\n\nint wl1251_acx_wr_tbtt_and_dtim(struct wl1251 *wl, u16 tbtt, u8 dtim)\n{\n\tstruct wl1251_acx_wr_tbtt_and_dtim *acx;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx tbtt and dtim\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx)\n\t\treturn -ENOMEM;\n\n\tacx->tbtt = tbtt;\n\tacx->dtim = dtim;\n\n\tret = wl1251_cmd_configure(wl, ACX_WR_TBTT_AND_DTIM,\n\t\t\t\t   acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1251_warning(\"failed to set tbtt and dtim: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1251_acx_bet_enable(struct wl1251 *wl, enum wl1251_acx_bet_mode mode,\n\t\t\t  u8 max_consecutive)\n{\n\tstruct wl1251_acx_bet_enable *acx;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx bet enable\");\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx)\n\t\treturn -ENOMEM;\n\n\tacx->enable = mode;\n\tacx->max_consecutive = max_consecutive;\n\n\tret = wl1251_cmd_configure(wl, ACX_BET_ENABLE, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1251_warning(\"wl1251 acx bet enable failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1251_acx_arp_ip_filter(struct wl1251 *wl, bool enable, __be32 address)\n{\n\tstruct wl1251_acx_arp_filter *acx;\n\tint ret;\n\n\twl1251_debug(DEBUG_ACX, \"acx arp ip filter, enable: %d\", enable);\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx)\n\t\treturn -ENOMEM;\n\n\tacx->version = ACX_IPV4_VERSION;\n\tacx->enable = enable;\n\n\tif (enable)\n\t\tmemcpy(acx->address, &address, ACX_IPV4_ADDR_SIZE);\n\n\tret = wl1251_cmd_configure(wl, ACX_ARP_IP_FILTER,\n\t\t\t\t   acx, sizeof(*acx));\n\tif (ret < 0)\n\t\twl1251_warning(\"failed to set arp ip filter: %d\", ret);\n\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1251_acx_ac_cfg(struct wl1251 *wl, u8 ac, u8 cw_min, u16 cw_max,\n\t\t      u8 aifs, u16 txop)\n{\n\tstruct wl1251_acx_ac_cfg *acx;\n\tint ret = 0;\n\n\twl1251_debug(DEBUG_ACX, \"acx ac cfg %d cw_ming %d cw_max %d \"\n\t\t     \"aifs %d txop %d\", ac, cw_min, cw_max, aifs, txop);\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx)\n\t\treturn -ENOMEM;\n\n\tacx->ac = ac;\n\tacx->cw_min = cw_min;\n\tacx->cw_max = cw_max;\n\tacx->aifsn = aifs;\n\tacx->txop_limit = txop;\n\n\tret = wl1251_cmd_configure(wl, ACX_AC_CFG, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1251_warning(\"acx ac cfg failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n\nint wl1251_acx_tid_cfg(struct wl1251 *wl, u8 queue,\n\t\t       enum wl1251_acx_channel_type type,\n\t\t       u8 tsid, enum wl1251_acx_ps_scheme ps_scheme,\n\t\t       enum wl1251_acx_ack_policy ack_policy)\n{\n\tstruct wl1251_acx_tid_cfg *acx;\n\tint ret = 0;\n\n\twl1251_debug(DEBUG_ACX, \"acx tid cfg %d type %d tsid %d \"\n\t\t     \"ps_scheme %d ack_policy %d\", queue, type, tsid,\n\t\t     ps_scheme, ack_policy);\n\n\tacx = kzalloc(sizeof(*acx), GFP_KERNEL);\n\tif (!acx)\n\t\treturn -ENOMEM;\n\n\tacx->queue = queue;\n\tacx->type = type;\n\tacx->tsid = tsid;\n\tacx->ps_scheme = ps_scheme;\n\tacx->ack_policy = ack_policy;\n\n\tret = wl1251_cmd_configure(wl, ACX_TID_CFG, acx, sizeof(*acx));\n\tif (ret < 0) {\n\t\twl1251_warning(\"acx tid cfg failed: %d\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(acx);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}