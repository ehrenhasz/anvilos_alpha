{
  "module_name": "tx.c",
  "hash_id": "88713c3119469bbac25eafaa13e4d3dadc399cfbb2659b69c520a7107c563154",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ti/wl1251/tx.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#include \"wl1251.h\"\n#include \"reg.h\"\n#include \"tx.h\"\n#include \"ps.h\"\n#include \"io.h\"\n#include \"event.h\"\n\nstatic bool wl1251_tx_double_buffer_busy(struct wl1251 *wl, u32 data_out_count)\n{\n\tint used, data_in_count;\n\n\tdata_in_count = wl->data_in_count;\n\n\tif (data_in_count < data_out_count)\n\t\t \n\t\tdata_in_count += TX_STATUS_DATA_OUT_COUNT_MASK + 1;\n\n\tused = data_in_count - data_out_count;\n\n\tWARN_ON(used < 0);\n\tWARN_ON(used > DP_TX_PACKET_RING_CHUNK_NUM);\n\n\tif (used >= DP_TX_PACKET_RING_CHUNK_NUM)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic int wl1251_tx_path_status(struct wl1251 *wl)\n{\n\tu32 status, addr, data_out_count;\n\tbool busy;\n\n\taddr = wl->data_path->tx_control_addr;\n\tstatus = wl1251_mem_read32(wl, addr);\n\tdata_out_count = status & TX_STATUS_DATA_OUT_COUNT_MASK;\n\tbusy = wl1251_tx_double_buffer_busy(wl, data_out_count);\n\n\tif (busy)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic int wl1251_tx_id(struct wl1251 *wl, struct sk_buff *skb)\n{\n\tint i;\n\n\tfor (i = 0; i < FW_TX_CMPLT_BLOCK_SIZE; i++)\n\t\tif (wl->tx_frames[i] == NULL) {\n\t\t\twl->tx_frames[i] = skb;\n\t\t\treturn i;\n\t\t}\n\n\treturn -EBUSY;\n}\n\nstatic void wl1251_tx_control(struct tx_double_buffer_desc *tx_hdr,\n\t\t\t      struct ieee80211_tx_info *control, u16 fc)\n{\n\t*(u16 *)&tx_hdr->control = 0;\n\n\ttx_hdr->control.rate_policy = 0;\n\n\t \n\ttx_hdr->control.packet_type = 0;\n\n\t \n\tif ((control->flags & IEEE80211_TX_CTL_NO_ACK) ||\n\t    (control->flags & IEEE80211_TX_CTL_INJECTED)) {\n\t\ttx_hdr->control.rate_policy = 1;\n\t\ttx_hdr->control.ack_policy = 1;\n\t}\n\n\ttx_hdr->control.tx_complete = 1;\n\n\tif ((fc & IEEE80211_FTYPE_DATA) &&\n\t    ((fc & IEEE80211_STYPE_QOS_DATA) ||\n\t     (fc & IEEE80211_STYPE_QOS_NULLFUNC)))\n\t\ttx_hdr->control.qos = 1;\n}\n\n \n#define MAX_MSDU_SECURITY_LENGTH      16\n#define MAX_MPDU_SECURITY_LENGTH      16\n#define WLAN_QOS_HDR_LEN              26\n#define MAX_MPDU_HEADER_AND_SECURITY  (MAX_MPDU_SECURITY_LENGTH + \\\n\t\t\t\t       WLAN_QOS_HDR_LEN)\n#define HW_BLOCK_SIZE                 252\nstatic void wl1251_tx_frag_block_num(struct tx_double_buffer_desc *tx_hdr)\n{\n\tu16 payload_len, frag_threshold, mem_blocks;\n\tu16 num_mpdus, mem_blocks_per_frag;\n\n\tfrag_threshold = IEEE80211_MAX_FRAG_THRESHOLD;\n\ttx_hdr->frag_threshold = cpu_to_le16(frag_threshold);\n\n\tpayload_len = le16_to_cpu(tx_hdr->length) + MAX_MSDU_SECURITY_LENGTH;\n\n\tif (payload_len > frag_threshold) {\n\t\tmem_blocks_per_frag =\n\t\t\t((frag_threshold + MAX_MPDU_HEADER_AND_SECURITY) /\n\t\t\t HW_BLOCK_SIZE) + 1;\n\t\tnum_mpdus = payload_len / frag_threshold;\n\t\tmem_blocks = num_mpdus * mem_blocks_per_frag;\n\t\tpayload_len -= num_mpdus * frag_threshold;\n\t\tnum_mpdus++;\n\n\t} else {\n\t\tmem_blocks_per_frag = 0;\n\t\tmem_blocks = 0;\n\t\tnum_mpdus = 1;\n\t}\n\n\tmem_blocks += (payload_len / HW_BLOCK_SIZE) + 1;\n\n\tif (num_mpdus > 1)\n\t\tmem_blocks += min(num_mpdus, mem_blocks_per_frag);\n\n\ttx_hdr->num_mem_blocks = mem_blocks;\n}\n\nstatic int wl1251_tx_fill_hdr(struct wl1251 *wl, struct sk_buff *skb,\n\t\t\t      struct ieee80211_tx_info *control)\n{\n\tstruct tx_double_buffer_desc *tx_hdr;\n\tstruct ieee80211_rate *rate;\n\tint id;\n\tu16 fc;\n\n\tif (!skb)\n\t\treturn -EINVAL;\n\n\tid = wl1251_tx_id(wl, skb);\n\tif (id < 0)\n\t\treturn id;\n\n\tfc = *(u16 *)skb->data;\n\ttx_hdr = skb_push(skb, sizeof(*tx_hdr));\n\n\ttx_hdr->length = cpu_to_le16(skb->len - sizeof(*tx_hdr));\n\trate = ieee80211_get_tx_rate(wl->hw, control);\n\ttx_hdr->rate = cpu_to_le16(rate->hw_value);\n\ttx_hdr->expiry_time = cpu_to_le32(1 << 16);\n\ttx_hdr->id = id;\n\n\ttx_hdr->xmit_queue = wl1251_tx_get_queue(skb_get_queue_mapping(skb));\n\n\twl1251_tx_control(tx_hdr, control, fc);\n\twl1251_tx_frag_block_num(tx_hdr);\n\n\treturn 0;\n}\n\n \nstatic int wl1251_tx_send_packet(struct wl1251 *wl, struct sk_buff *skb,\n\t\t\t\t struct ieee80211_tx_info *control)\n{\n\tstruct tx_double_buffer_desc *tx_hdr;\n\tint len;\n\tu32 addr;\n\n\tif (!skb)\n\t\treturn -EINVAL;\n\n\ttx_hdr = (struct tx_double_buffer_desc *) skb->data;\n\n\tif (control->control.hw_key &&\n\t    control->control.hw_key->cipher == WLAN_CIPHER_SUITE_TKIP) {\n\t\tint hdrlen;\n\t\t__le16 fc;\n\t\tu16 length;\n\t\tu8 *pos;\n\n\t\tfc = *(__le16 *)(skb->data + sizeof(*tx_hdr));\n\t\tlength = le16_to_cpu(tx_hdr->length) + WL1251_TKIP_IV_SPACE;\n\t\ttx_hdr->length = cpu_to_le16(length);\n\n\t\thdrlen = ieee80211_hdrlen(fc);\n\n\t\tpos = skb_push(skb, WL1251_TKIP_IV_SPACE);\n\t\tmemmove(pos, pos + WL1251_TKIP_IV_SPACE,\n\t\t\tsizeof(*tx_hdr) + hdrlen);\n\t}\n\n\t \n\tif (unlikely((long)skb->data & 0x03)) {\n\t\tint offset = (4 - (long)skb->data) & 0x03;\n\t\twl1251_debug(DEBUG_TX, \"skb offset %d\", offset);\n\n\t\t \n\t\tif (skb_cloned(skb) || (skb_tailroom(skb) < offset)) {\n\t\t\tstruct sk_buff *newskb = skb_copy_expand(skb, 0, 3,\n\t\t\t\t\t\t\t\t GFP_KERNEL);\n\n\t\t\tif (unlikely(newskb == NULL))\n\t\t\t\treturn -EINVAL;\n\n\t\t\ttx_hdr = (struct tx_double_buffer_desc *) newskb->data;\n\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\twl->tx_frames[tx_hdr->id] = skb = newskb;\n\n\t\t\toffset = (4 - (long)skb->data) & 0x03;\n\t\t\twl1251_debug(DEBUG_TX, \"new skb offset %d\", offset);\n\t\t}\n\n\t\t \n\t\tif (offset) {\n\t\t\tunsigned char *src = skb->data;\n\t\t\tskb_reserve(skb, offset);\n\t\t\tmemmove(skb->data, src, skb->len);\n\t\t\ttx_hdr = (struct tx_double_buffer_desc *) skb->data;\n\t\t}\n\t}\n\n\t \n\tlen = WL1251_TX_ALIGN(skb->len);\n\n\tif (wl->data_in_count & 0x1)\n\t\taddr = wl->data_path->tx_packet_ring_addr +\n\t\t\twl->data_path->tx_packet_ring_chunk_size;\n\telse\n\t\taddr = wl->data_path->tx_packet_ring_addr;\n\n\twl1251_mem_write(wl, addr, skb->data, len);\n\n\twl1251_debug(DEBUG_TX, \"tx id %u skb 0x%p payload %u rate 0x%x \"\n\t\t     \"queue %d\", tx_hdr->id, skb, tx_hdr->length,\n\t\t     tx_hdr->rate, tx_hdr->xmit_queue);\n\n\treturn 0;\n}\n\nstatic void wl1251_tx_trigger(struct wl1251 *wl)\n{\n\tu32 data, addr;\n\n\tif (wl->data_in_count & 0x1) {\n\t\taddr = ACX_REG_INTERRUPT_TRIG_H;\n\t\tdata = INTR_TRIG_TX_PROC1;\n\t} else {\n\t\taddr = ACX_REG_INTERRUPT_TRIG;\n\t\tdata = INTR_TRIG_TX_PROC0;\n\t}\n\n\twl1251_reg_write32(wl, addr, data);\n\n\t \n\twl->data_in_count = (wl->data_in_count + 1) &\n\t\tTX_STATUS_DATA_OUT_COUNT_MASK;\n}\n\nstatic void enable_tx_for_packet_injection(struct wl1251 *wl)\n{\n\tint ret;\n\n\tret = wl1251_cmd_join(wl, BSS_TYPE_STA_BSS, wl->channel,\n\t\t\t      wl->beacon_int, wl->dtim_period);\n\tif (ret < 0) {\n\t\twl1251_warning(\"join failed\");\n\t\treturn;\n\t}\n\n\tret = wl1251_event_wait(wl, JOIN_EVENT_COMPLETE_ID, 100);\n\tif (ret < 0) {\n\t\twl1251_warning(\"join timeout\");\n\t\treturn;\n\t}\n\n\twl->joined = true;\n}\n\n \nstatic int wl1251_tx_frame(struct wl1251 *wl, struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info;\n\tint ret = 0;\n\tu8 idx;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\tif (info->control.hw_key) {\n\t\tif (unlikely(wl->monitor_present))\n\t\t\treturn -EINVAL;\n\n\t\tidx = info->control.hw_key->hw_key_idx;\n\t\tif (unlikely(wl->default_key != idx)) {\n\t\t\tret = wl1251_acx_default_key(wl, idx);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif ((wl->vif == NULL) && !wl->joined)\n\t\tenable_tx_for_packet_injection(wl);\n\n\tret = wl1251_tx_path_status(wl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1251_tx_fill_hdr(wl, skb, info);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wl1251_tx_send_packet(wl, skb, info);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twl1251_tx_trigger(wl);\n\n\treturn ret;\n}\n\nvoid wl1251_tx_work(struct work_struct *work)\n{\n\tstruct wl1251 *wl = container_of(work, struct wl1251, tx_work);\n\tstruct sk_buff *skb;\n\tbool woken_up = false;\n\tint ret;\n\n\tmutex_lock(&wl->mutex);\n\n\tif (unlikely(wl->state == WL1251_STATE_OFF))\n\t\tgoto out;\n\n\twhile ((skb = skb_dequeue(&wl->tx_queue))) {\n\t\tif (!woken_up) {\n\t\t\tret = wl1251_ps_elp_wakeup(wl);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\twoken_up = true;\n\t\t}\n\n\t\tret = wl1251_tx_frame(wl, skb);\n\t\tif (ret == -EBUSY) {\n\t\t\tskb_queue_head(&wl->tx_queue, skb);\n\t\t\tgoto out;\n\t\t} else if (ret < 0) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tif (woken_up)\n\t\twl1251_ps_elp_sleep(wl);\n\n\tmutex_unlock(&wl->mutex);\n}\n\nstatic const char *wl1251_tx_parse_status(u8 status)\n{\n\t \n\tstatic char buf[9];\n\tint i = 0;\n\n\tmemset(buf, 0, sizeof(buf));\n\n\tif (status & TX_DMA_ERROR)\n\t\tbuf[i++] = 'm';\n\tif (status & TX_DISABLED)\n\t\tbuf[i++] = 'd';\n\tif (status & TX_RETRY_EXCEEDED)\n\t\tbuf[i++] = 'r';\n\tif (status & TX_TIMEOUT)\n\t\tbuf[i++] = 't';\n\tif (status & TX_KEY_NOT_FOUND)\n\t\tbuf[i++] = 'k';\n\tif (status & TX_ENCRYPT_FAIL)\n\t\tbuf[i++] = 'e';\n\tif (status & TX_UNAVAILABLE_PRIORITY)\n\t\tbuf[i++] = 'p';\n\n\t \n\n\treturn buf;\n}\n\nstatic void wl1251_tx_packet_cb(struct wl1251 *wl,\n\t\t\t\tstruct tx_result *result)\n{\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *skb;\n\tint hdrlen;\n\tu8 *frame;\n\n\tskb = wl->tx_frames[result->id];\n\tif (skb == NULL) {\n\t\twl1251_error(\"SKB for packet %d is NULL\", result->id);\n\t\treturn;\n\t}\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\tif (!(info->flags & IEEE80211_TX_CTL_NO_ACK) &&\n\t    !(info->flags & IEEE80211_TX_CTL_INJECTED) &&\n\t    (result->status == TX_SUCCESS))\n\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\n\tinfo->status.rates[0].count = result->ack_failures + 1;\n\twl->stats.retry_count += result->ack_failures;\n\n\t \n\tframe = skb_pull(skb, sizeof(struct tx_double_buffer_desc));\n\tif (info->control.hw_key &&\n\t    info->control.hw_key->cipher == WLAN_CIPHER_SUITE_TKIP) {\n\t\thdrlen = ieee80211_get_hdrlen_from_skb(skb);\n\t\tmemmove(frame + WL1251_TKIP_IV_SPACE, frame, hdrlen);\n\t\tskb_pull(skb, WL1251_TKIP_IV_SPACE);\n\t}\n\n\twl1251_debug(DEBUG_TX, \"tx status id %u skb 0x%p failures %u rate 0x%x\"\n\t\t     \" status 0x%x (%s)\",\n\t\t     result->id, skb, result->ack_failures, result->rate,\n\t\t     result->status, wl1251_tx_parse_status(result->status));\n\n\n\tieee80211_tx_status(wl->hw, skb);\n\n\twl->tx_frames[result->id] = NULL;\n}\n\n \nvoid wl1251_tx_complete(struct wl1251 *wl)\n{\n\tint i, result_index, num_complete = 0, queue_len;\n\tstruct tx_result *result, *result_ptr;\n\tunsigned long flags;\n\n\tif (unlikely(wl->state != WL1251_STATE_ON))\n\t\treturn;\n\n\tresult = kmalloc_array(FW_TX_CMPLT_BLOCK_SIZE, sizeof(*result), GFP_KERNEL);\n\tif (!result) {\n\t\twl1251_error(\"can not allocate result buffer\");\n\t\treturn;\n\t}\n\n\t \n\twl1251_mem_read(wl, wl->data_path->tx_complete_addr, result,\n\t\t\tFW_TX_CMPLT_BLOCK_SIZE * sizeof(*result));\n\n\tresult_index = wl->next_tx_complete;\n\n\tfor (i = 0; i < FW_TX_CMPLT_BLOCK_SIZE; i++) {\n\t\tresult_ptr = &result[result_index];\n\n\t\tif (result_ptr->done_1 == 1 &&\n\t\t    result_ptr->done_2 == 1) {\n\t\t\twl1251_tx_packet_cb(wl, result_ptr);\n\n\t\t\tresult_ptr->done_1 = 0;\n\t\t\tresult_ptr->done_2 = 0;\n\n\t\t\tresult_index = (result_index + 1) &\n\t\t\t\t(FW_TX_CMPLT_BLOCK_SIZE - 1);\n\t\t\tnum_complete++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tqueue_len = skb_queue_len(&wl->tx_queue);\n\n\tif ((num_complete > 0) && (queue_len > 0)) {\n\t\t \n\t\twl1251_debug(DEBUG_TX, \"tx_complete: reschedule tx_work\");\n\t\tieee80211_queue_work(wl->hw, &wl->tx_work);\n\t}\n\n\tif (wl->tx_queue_stopped &&\n\t    queue_len <= WL1251_TX_QUEUE_LOW_WATERMARK) {\n\t\t \n\t\twl1251_debug(DEBUG_TX, \"tx_complete: waking queues\");\n\t\tspin_lock_irqsave(&wl->wl_lock, flags);\n\t\tieee80211_wake_queues(wl->hw);\n\t\twl->tx_queue_stopped = false;\n\t\tspin_unlock_irqrestore(&wl->wl_lock, flags);\n\t}\n\n\t \n\tif (num_complete) {\n\t\t \n\t\tif (result_index > wl->next_tx_complete) {\n\t\t\t \n\t\t\twl1251_mem_write(wl,\n\t\t\t\t\t wl->data_path->tx_complete_addr +\n\t\t\t\t\t (wl->next_tx_complete *\n\t\t\t\t\t  sizeof(struct tx_result)),\n\t\t\t\t\t &result[wl->next_tx_complete],\n\t\t\t\t\t num_complete *\n\t\t\t\t\t sizeof(struct tx_result));\n\n\n\t\t} else if (result_index < wl->next_tx_complete) {\n\t\t\t \n\t\t\twl1251_mem_write(wl,\n\t\t\t\t\t wl->data_path->tx_complete_addr +\n\t\t\t\t\t (wl->next_tx_complete *\n\t\t\t\t\t  sizeof(struct tx_result)),\n\t\t\t\t\t &result[wl->next_tx_complete],\n\t\t\t\t\t (FW_TX_CMPLT_BLOCK_SIZE -\n\t\t\t\t\t  wl->next_tx_complete) *\n\t\t\t\t\t sizeof(struct tx_result));\n\n\t\t\twl1251_mem_write(wl,\n\t\t\t\t\t wl->data_path->tx_complete_addr,\n\t\t\t\t\t result,\n\t\t\t\t\t (num_complete -\n\t\t\t\t\t  FW_TX_CMPLT_BLOCK_SIZE +\n\t\t\t\t\t  wl->next_tx_complete) *\n\t\t\t\t\t sizeof(struct tx_result));\n\n\t\t} else {\n\t\t\t \n\t\t\twl1251_mem_write(wl,\n\t\t\t\t\t wl->data_path->tx_complete_addr,\n\t\t\t\t\t result,\n\t\t\t\t\t FW_TX_CMPLT_BLOCK_SIZE *\n\t\t\t\t\t sizeof(struct tx_result));\n\t\t}\n\n\t}\n\n\tkfree(result);\n\twl->next_tx_complete = result_index;\n}\n\n \nvoid wl1251_tx_flush(struct wl1251 *wl)\n{\n\tint i;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_tx_info *info;\n\n\t \n \n\n\twhile ((skb = skb_dequeue(&wl->tx_queue))) {\n\t\tinfo = IEEE80211_SKB_CB(skb);\n\n\t\twl1251_debug(DEBUG_TX, \"flushing skb 0x%p\", skb);\n\n\t\tif (!(info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS))\n\t\t\t\tcontinue;\n\n\t\tieee80211_tx_status(wl->hw, skb);\n\t}\n\n\tfor (i = 0; i < FW_TX_CMPLT_BLOCK_SIZE; i++)\n\t\tif (wl->tx_frames[i] != NULL) {\n\t\t\tskb = wl->tx_frames[i];\n\t\t\tinfo = IEEE80211_SKB_CB(skb);\n\n\t\t\tif (!(info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS))\n\t\t\t\tcontinue;\n\n\t\t\tieee80211_tx_status(wl->hw, skb);\n\t\t\twl->tx_frames[i] = NULL;\n\t\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}