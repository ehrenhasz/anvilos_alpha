{
  "module_name": "htc_drv_txrx.c",
  "hash_id": "b47ea2fee5a0ac9b2cf7572919e780cc5a66f1f84486c6e46a65914d033f6904",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/htc_drv_txrx.c",
  "human_readable_source": " \n\n#include \"htc.h\"\n\n \n \n \n\nstatic const int subtype_txq_to_hwq[] = {\n\t[IEEE80211_AC_BE] = ATH_TXQ_AC_BE,\n\t[IEEE80211_AC_BK] = ATH_TXQ_AC_BK,\n\t[IEEE80211_AC_VI] = ATH_TXQ_AC_VI,\n\t[IEEE80211_AC_VO] = ATH_TXQ_AC_VO,\n};\n\n#define ATH9K_HTC_INIT_TXQ(subtype) do {\t\t\t\\\n\t\tqi.tqi_subtype = subtype_txq_to_hwq[subtype];\t\\\n\t\tqi.tqi_aifs = ATH9K_TXQ_USEDEFAULT;\t\t\\\n\t\tqi.tqi_cwmin = ATH9K_TXQ_USEDEFAULT;\t\t\\\n\t\tqi.tqi_cwmax = ATH9K_TXQ_USEDEFAULT;\t\t\\\n\t\tqi.tqi_physCompBuf = 0;\t\t\t\t\\\n\t\tqi.tqi_qflags = TXQ_FLAG_TXEOLINT_ENABLE |\t\\\n\t\t\tTXQ_FLAG_TXDESCINT_ENABLE;\t\t\\\n\t} while (0)\n\nint get_hw_qnum(u16 queue, int *hwq_map)\n{\n\tswitch (queue) {\n\tcase 0:\n\t\treturn hwq_map[IEEE80211_AC_VO];\n\tcase 1:\n\t\treturn hwq_map[IEEE80211_AC_VI];\n\tcase 2:\n\t\treturn hwq_map[IEEE80211_AC_BE];\n\tcase 3:\n\t\treturn hwq_map[IEEE80211_AC_BK];\n\tdefault:\n\t\treturn hwq_map[IEEE80211_AC_BE];\n\t}\n}\n\nvoid ath9k_htc_check_stop_queues(struct ath9k_htc_priv *priv)\n{\n\tspin_lock_bh(&priv->tx.tx_lock);\n\tpriv->tx.queued_cnt++;\n\tif ((priv->tx.queued_cnt >= ATH9K_HTC_TX_THRESHOLD) &&\n\t    !(priv->tx.flags & ATH9K_HTC_OP_TX_QUEUES_STOP)) {\n\t\tpriv->tx.flags |= ATH9K_HTC_OP_TX_QUEUES_STOP;\n\t\tieee80211_stop_queues(priv->hw);\n\t}\n\tspin_unlock_bh(&priv->tx.tx_lock);\n}\n\nvoid ath9k_htc_check_wake_queues(struct ath9k_htc_priv *priv)\n{\n\tspin_lock_bh(&priv->tx.tx_lock);\n\tif ((priv->tx.queued_cnt < ATH9K_HTC_TX_THRESHOLD) &&\n\t    (priv->tx.flags & ATH9K_HTC_OP_TX_QUEUES_STOP)) {\n\t\tpriv->tx.flags &= ~ATH9K_HTC_OP_TX_QUEUES_STOP;\n\t\tieee80211_wake_queues(priv->hw);\n\t}\n\tspin_unlock_bh(&priv->tx.tx_lock);\n}\n\nint ath9k_htc_tx_get_slot(struct ath9k_htc_priv *priv)\n{\n\tint slot;\n\n\tspin_lock_bh(&priv->tx.tx_lock);\n\tslot = find_first_zero_bit(priv->tx.tx_slot, MAX_TX_BUF_NUM);\n\tif (slot >= MAX_TX_BUF_NUM) {\n\t\tspin_unlock_bh(&priv->tx.tx_lock);\n\t\treturn -ENOBUFS;\n\t}\n\t__set_bit(slot, priv->tx.tx_slot);\n\tspin_unlock_bh(&priv->tx.tx_lock);\n\n\treturn slot;\n}\n\nvoid ath9k_htc_tx_clear_slot(struct ath9k_htc_priv *priv, int slot)\n{\n\tspin_lock_bh(&priv->tx.tx_lock);\n\t__clear_bit(slot, priv->tx.tx_slot);\n\tspin_unlock_bh(&priv->tx.tx_lock);\n}\n\nstatic inline enum htc_endpoint_id get_htc_epid(struct ath9k_htc_priv *priv,\n\t\t\t\t\t\tu16 qnum)\n{\n\tenum htc_endpoint_id epid;\n\n\tswitch (qnum) {\n\tcase 0:\n\t\tTX_QSTAT_INC(priv, IEEE80211_AC_VO);\n\t\tepid = priv->data_vo_ep;\n\t\tbreak;\n\tcase 1:\n\t\tTX_QSTAT_INC(priv, IEEE80211_AC_VI);\n\t\tepid = priv->data_vi_ep;\n\t\tbreak;\n\tcase 2:\n\t\tTX_QSTAT_INC(priv, IEEE80211_AC_BE);\n\t\tepid = priv->data_be_ep;\n\t\tbreak;\n\tcase 3:\n\tdefault:\n\t\tTX_QSTAT_INC(priv, IEEE80211_AC_BK);\n\t\tepid = priv->data_bk_ep;\n\t\tbreak;\n\t}\n\n\treturn epid;\n}\n\nstatic inline struct sk_buff_head*\nget_htc_epid_queue(struct ath9k_htc_priv *priv, u8 epid)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct sk_buff_head *epid_queue = NULL;\n\n\tif (epid == priv->mgmt_ep)\n\t\tepid_queue = &priv->tx.mgmt_ep_queue;\n\telse if (epid == priv->cab_ep)\n\t\tepid_queue = &priv->tx.cab_ep_queue;\n\telse if (epid == priv->data_be_ep)\n\t\tepid_queue = &priv->tx.data_be_queue;\n\telse if (epid == priv->data_bk_ep)\n\t\tepid_queue = &priv->tx.data_bk_queue;\n\telse if (epid == priv->data_vi_ep)\n\t\tepid_queue = &priv->tx.data_vi_queue;\n\telse if (epid == priv->data_vo_ep)\n\t\tepid_queue = &priv->tx.data_vo_queue;\n\telse\n\t\tath_err(common, \"Invalid EPID: %d\\n\", epid);\n\n\treturn epid_queue;\n}\n\n \nstatic inline int strip_drv_header(struct ath9k_htc_priv *priv,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ath9k_htc_tx_ctl *tx_ctl;\n\tint slot;\n\n\ttx_ctl = HTC_SKB_CB(skb);\n\n\tif (tx_ctl->epid == priv->mgmt_ep) {\n\t\tstruct tx_mgmt_hdr *tx_mhdr =\n\t\t\t(struct tx_mgmt_hdr *)skb->data;\n\t\tslot = tx_mhdr->cookie;\n\t\tskb_pull(skb, sizeof(struct tx_mgmt_hdr));\n\t} else if ((tx_ctl->epid == priv->data_bk_ep) ||\n\t\t   (tx_ctl->epid == priv->data_be_ep) ||\n\t\t   (tx_ctl->epid == priv->data_vi_ep) ||\n\t\t   (tx_ctl->epid == priv->data_vo_ep) ||\n\t\t   (tx_ctl->epid == priv->cab_ep)) {\n\t\tstruct tx_frame_hdr *tx_fhdr =\n\t\t\t(struct tx_frame_hdr *)skb->data;\n\t\tslot = tx_fhdr->cookie;\n\t\tskb_pull(skb, sizeof(struct tx_frame_hdr));\n\t} else {\n\t\tath_err(common, \"Unsupported EPID: %d\\n\", tx_ctl->epid);\n\t\tslot = -EINVAL;\n\t}\n\n\treturn slot;\n}\n\nint ath_htc_txq_update(struct ath9k_htc_priv *priv, int qnum,\n\t\t       struct ath9k_tx_queue_info *qinfo)\n{\n\tstruct ath_hw *ah = priv->ah;\n\tint error = 0;\n\tstruct ath9k_tx_queue_info qi;\n\n\tath9k_hw_get_txq_props(ah, qnum, &qi);\n\n\tqi.tqi_aifs = qinfo->tqi_aifs;\n\tqi.tqi_cwmin = qinfo->tqi_cwmin / 2;  \n\tqi.tqi_cwmax = qinfo->tqi_cwmax;\n\tqi.tqi_burstTime = qinfo->tqi_burstTime;\n\tqi.tqi_readyTime = qinfo->tqi_readyTime;\n\n\tif (!ath9k_hw_set_txq_props(ah, qnum, &qi)) {\n\t\tath_err(ath9k_hw_common(ah),\n\t\t\t\"Unable to update hardware queue %u!\\n\", qnum);\n\t\terror = -EIO;\n\t} else {\n\t\tath9k_hw_resettxqueue(ah, qnum);\n\t}\n\n\treturn error;\n}\n\nstatic void ath9k_htc_tx_mgmt(struct ath9k_htc_priv *priv,\n\t\t\t      struct ath9k_htc_vif *avp,\n\t\t\t      struct sk_buff *skb,\n\t\t\t      u8 sta_idx, u8 vif_idx, u8 slot)\n{\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_mgmt *mgmt;\n\tstruct ieee80211_hdr *hdr;\n\tstruct tx_mgmt_hdr mgmt_hdr;\n\tstruct ath9k_htc_tx_ctl *tx_ctl;\n\tu8 *tx_fhdr;\n\n\ttx_ctl = HTC_SKB_CB(skb);\n\thdr = (struct ieee80211_hdr *) skb->data;\n\n\tmemset(tx_ctl, 0, sizeof(*tx_ctl));\n\tmemset(&mgmt_hdr, 0, sizeof(struct tx_mgmt_hdr));\n\n\t \n\tif (avp && unlikely(ieee80211_is_probe_resp(hdr->frame_control))) {\n\t\tmgmt = (struct ieee80211_mgmt *)skb->data;\n\t\tmgmt->u.probe_resp.timestamp = avp->tsfadjust;\n\t}\n\n\ttx_ctl->type = ATH9K_HTC_MGMT;\n\n\tmgmt_hdr.node_idx = sta_idx;\n\tmgmt_hdr.vif_idx = vif_idx;\n\tmgmt_hdr.tidno = 0;\n\tmgmt_hdr.flags = 0;\n\tmgmt_hdr.cookie = slot;\n\n\tmgmt_hdr.key_type = ath9k_cmn_get_hw_crypto_keytype(skb);\n\tif (mgmt_hdr.key_type == ATH9K_KEY_TYPE_CLEAR)\n\t\tmgmt_hdr.keyix = (u8) ATH9K_TXKEYIX_INVALID;\n\telse\n\t\tmgmt_hdr.keyix = tx_info->control.hw_key->hw_key_idx;\n\n\ttx_fhdr = skb_push(skb, sizeof(mgmt_hdr));\n\tmemcpy(tx_fhdr, (u8 *) &mgmt_hdr, sizeof(mgmt_hdr));\n\ttx_ctl->epid = priv->mgmt_ep;\n}\n\nstatic void ath9k_htc_tx_data(struct ath9k_htc_priv *priv,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct sk_buff *skb,\n\t\t\t      u8 sta_idx, u8 vif_idx, u8 slot,\n\t\t\t      bool is_cab)\n{\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr;\n\tstruct ath9k_htc_tx_ctl *tx_ctl;\n\tstruct tx_frame_hdr tx_hdr;\n\tu32 flags = 0;\n\tu8 *qc, *tx_fhdr;\n\tu16 qnum;\n\n\ttx_ctl = HTC_SKB_CB(skb);\n\thdr = (struct ieee80211_hdr *) skb->data;\n\n\tmemset(tx_ctl, 0, sizeof(*tx_ctl));\n\tmemset(&tx_hdr, 0, sizeof(struct tx_frame_hdr));\n\n\ttx_hdr.node_idx = sta_idx;\n\ttx_hdr.vif_idx = vif_idx;\n\ttx_hdr.cookie = slot;\n\n\t \n\ttx_ctl->sta_idx = sta_idx;\n\n\tif (tx_info->flags & IEEE80211_TX_CTL_AMPDU) {\n\t\ttx_ctl->type = ATH9K_HTC_AMPDU;\n\t\ttx_hdr.data_type = ATH9K_HTC_AMPDU;\n\t} else {\n\t\ttx_ctl->type = ATH9K_HTC_NORMAL;\n\t\ttx_hdr.data_type = ATH9K_HTC_NORMAL;\n\t}\n\n\t \n\tif (!(tx_info->control.flags & IEEE80211_TX_CTRL_DONT_REORDER) &&\n\t    ieee80211_is_data_qos(hdr->frame_control)) {\n\t\tqc = ieee80211_get_qos_ctl(hdr);\n\t\ttx_hdr.tidno = qc[0] & IEEE80211_QOS_CTL_TID_MASK;\n\t}\n\n\t \n\tif (priv->hw->wiphy->rts_threshold != (u32) -1)\n\t\tif (skb->len > priv->hw->wiphy->rts_threshold)\n\t\t\tflags |= ATH9K_HTC_TX_RTSCTS;\n\n\t \n\tif (!(flags & ATH9K_HTC_TX_RTSCTS) &&\n\t    (vif && vif->bss_conf.use_cts_prot))\n\t\tflags |= ATH9K_HTC_TX_CTSONLY;\n\n\ttx_hdr.flags = cpu_to_be32(flags);\n\ttx_hdr.key_type = ath9k_cmn_get_hw_crypto_keytype(skb);\n\tif (tx_hdr.key_type == ATH9K_KEY_TYPE_CLEAR)\n\t\ttx_hdr.keyix = (u8) ATH9K_TXKEYIX_INVALID;\n\telse\n\t\ttx_hdr.keyix = tx_info->control.hw_key->hw_key_idx;\n\n\ttx_fhdr = skb_push(skb, sizeof(tx_hdr));\n\tmemcpy(tx_fhdr, (u8 *) &tx_hdr, sizeof(tx_hdr));\n\n\tif (is_cab) {\n\t\tCAB_STAT_INC(priv);\n\t\ttx_ctl->epid = priv->cab_ep;\n\t\treturn;\n\t}\n\n\tqnum = skb_get_queue_mapping(skb);\n\ttx_ctl->epid = get_htc_epid(priv, qnum);\n}\n\nint ath9k_htc_tx_start(struct ath9k_htc_priv *priv,\n\t\t       struct ieee80211_sta *sta,\n\t\t       struct sk_buff *skb,\n\t\t       u8 slot, bool is_cab)\n{\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_vif *vif = tx_info->control.vif;\n\tstruct ath9k_htc_sta *ista;\n\tstruct ath9k_htc_vif *avp = NULL;\n\tu8 sta_idx, vif_idx;\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\n\t \n\tif (vif) {\n\t\tavp = (struct ath9k_htc_vif *) vif->drv_priv;\n\t\tvif_idx = avp->index;\n\t} else {\n\t\tif (!priv->ah->is_monitoring) {\n\t\t\tath_dbg(ath9k_hw_common(priv->ah), XMIT,\n\t\t\t\t\"VIF is null, but no monitor interface !\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tvif_idx = priv->mon_vif_idx;\n\t}\n\n\t \n\tif (sta) {\n\t\tista = (struct ath9k_htc_sta *) sta->drv_priv;\n\t\tsta_idx = ista->index;\n\t} else {\n\t\tsta_idx = priv->vif_sta_pos[vif_idx];\n\t}\n\n\tif (ieee80211_is_data(hdr->frame_control))\n\t\tath9k_htc_tx_data(priv, vif, skb,\n\t\t\t\t  sta_idx, vif_idx, slot, is_cab);\n\telse\n\t\tath9k_htc_tx_mgmt(priv, avp, skb,\n\t\t\t\t  sta_idx, vif_idx, slot);\n\n\n\treturn htc_send(priv->htc, skb);\n}\n\nstatic inline bool __ath9k_htc_check_tx_aggr(struct ath9k_htc_priv *priv,\n\t\t\t\t\t     struct ath9k_htc_sta *ista, u8 tid)\n{\n\tbool ret = false;\n\n\tspin_lock_bh(&priv->tx.tx_lock);\n\tif ((tid < ATH9K_HTC_MAX_TID) && (ista->tid_state[tid] == AGGR_STOP))\n\t\tret = true;\n\tspin_unlock_bh(&priv->tx.tx_lock);\n\n\treturn ret;\n}\n\nstatic void ath9k_htc_check_tx_aggr(struct ath9k_htc_priv *priv,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct ieee80211_sta *sta;\n\tstruct ieee80211_hdr *hdr;\n\t__le16 fc;\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\tfc = hdr->frame_control;\n\n\trcu_read_lock();\n\n\tsta = ieee80211_find_sta(vif, hdr->addr1);\n\tif (!sta) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (sta && conf_is_ht(&priv->hw->conf) &&\n\t    !(skb->protocol == cpu_to_be16(ETH_P_PAE))) {\n\t\tif (ieee80211_is_data_qos(fc)) {\n\t\t\tu8 *qc, tid;\n\t\t\tstruct ath9k_htc_sta *ista;\n\n\t\t\tqc = ieee80211_get_qos_ctl(hdr);\n\t\t\ttid = qc[0] & 0xf;\n\t\t\tista = (struct ath9k_htc_sta *)sta->drv_priv;\n\t\t\tif (__ath9k_htc_check_tx_aggr(priv, ista, tid)) {\n\t\t\t\tieee80211_start_tx_ba_session(sta, tid, 0);\n\t\t\t\tspin_lock_bh(&priv->tx.tx_lock);\n\t\t\t\tista->tid_state[tid] = AGGR_PROGRESS;\n\t\t\t\tspin_unlock_bh(&priv->tx.tx_lock);\n\t\t\t}\n\t\t}\n\t}\n\n\trcu_read_unlock();\n}\n\nstatic void ath9k_htc_tx_process(struct ath9k_htc_priv *priv,\n\t\t\t\t struct sk_buff *skb,\n\t\t\t\t struct __wmi_event_txstatus *txs)\n{\n\tstruct ieee80211_vif *vif;\n\tstruct ath9k_htc_tx_ctl *tx_ctl;\n\tstruct ieee80211_tx_info *tx_info;\n\tstruct ieee80211_tx_rate *rate;\n\tstruct ieee80211_conf *cur_conf = &priv->hw->conf;\n\tbool txok;\n\tint slot;\n\tint hdrlen, padsize;\n\n\tslot = strip_drv_header(priv, skb);\n\tif (slot < 0) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\n\ttx_ctl = HTC_SKB_CB(skb);\n\ttxok = tx_ctl->txok;\n\ttx_info = IEEE80211_SKB_CB(skb);\n\tvif = tx_info->control.vif;\n\trate = &tx_info->status.rates[0];\n\n\tmemset(&tx_info->status, 0, sizeof(tx_info->status));\n\n\t \n\tif (!txok || !vif || !txs)\n\t\tgoto send_mac80211;\n\n\tif (txs->ts_flags & ATH9K_HTC_TXSTAT_ACK) {\n\t\ttx_info->flags |= IEEE80211_TX_STAT_ACK;\n\t\tif (tx_info->flags & IEEE80211_TX_CTL_AMPDU)\n\t\t\ttx_info->flags |= IEEE80211_TX_STAT_AMPDU;\n\t}\n\n\tif (txs->ts_flags & ATH9K_HTC_TXSTAT_FILT)\n\t\ttx_info->flags |= IEEE80211_TX_STAT_TX_FILTERED;\n\n\tif (txs->ts_flags & ATH9K_HTC_TXSTAT_RTC_CTS)\n\t\trate->flags |= IEEE80211_TX_RC_USE_RTS_CTS;\n\n\trate->count = 1;\n\trate->idx = MS(txs->ts_rate, ATH9K_HTC_TXSTAT_RATE);\n\n\tif (txs->ts_flags & ATH9K_HTC_TXSTAT_MCS) {\n\t\trate->flags |= IEEE80211_TX_RC_MCS;\n\n\t\tif (txs->ts_flags & ATH9K_HTC_TXSTAT_CW40)\n\t\t\trate->flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\n\t\tif (txs->ts_flags & ATH9K_HTC_TXSTAT_SGI)\n\t\t\trate->flags |= IEEE80211_TX_RC_SHORT_GI;\n\t} else {\n\t\tif (cur_conf->chandef.chan->band == NL80211_BAND_5GHZ)\n\t\t\trate->idx += 4;  \n\t}\n\n\tath9k_htc_check_tx_aggr(priv, vif, skb);\n\nsend_mac80211:\n\tspin_lock_bh(&priv->tx.tx_lock);\n\tif (WARN_ON(--priv->tx.queued_cnt < 0))\n\t\tpriv->tx.queued_cnt = 0;\n\tspin_unlock_bh(&priv->tx.tx_lock);\n\n\tath9k_htc_tx_clear_slot(priv, slot);\n\n\t \n\thdrlen = ieee80211_get_hdrlen_from_skb(skb);\n\n\tpadsize = hdrlen & 3;\n\tif (padsize && skb->len > hdrlen + padsize) {\n\t\tmemmove(skb->data + padsize, skb->data, hdrlen);\n\t\tskb_pull(skb, padsize);\n\t}\n\n\t \n\tieee80211_tx_status(priv->hw, skb);\n}\n\nstatic inline void ath9k_htc_tx_drainq(struct ath9k_htc_priv *priv,\n\t\t\t\t       struct sk_buff_head *queue)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(queue)) != NULL) {\n\t\tath9k_htc_tx_process(priv, skb, NULL);\n\t}\n}\n\nvoid ath9k_htc_tx_drain(struct ath9k_htc_priv *priv)\n{\n\tstruct ath9k_htc_tx_event *event, *tmp;\n\n\tspin_lock_bh(&priv->tx.tx_lock);\n\tpriv->tx.flags |= ATH9K_HTC_OP_TX_DRAIN;\n\tspin_unlock_bh(&priv->tx.tx_lock);\n\n\t \n\thtc_stop(priv->htc);\n\ttasklet_kill(&priv->wmi->wmi_event_tasklet);\n\ttasklet_kill(&priv->tx_failed_tasklet);\n\n\tath9k_htc_tx_drainq(priv, &priv->tx.mgmt_ep_queue);\n\tath9k_htc_tx_drainq(priv, &priv->tx.cab_ep_queue);\n\tath9k_htc_tx_drainq(priv, &priv->tx.data_be_queue);\n\tath9k_htc_tx_drainq(priv, &priv->tx.data_bk_queue);\n\tath9k_htc_tx_drainq(priv, &priv->tx.data_vi_queue);\n\tath9k_htc_tx_drainq(priv, &priv->tx.data_vo_queue);\n\tath9k_htc_tx_drainq(priv, &priv->tx.tx_failed);\n\n\t \n\tspin_lock_bh(&priv->wmi->event_lock);\n\tlist_for_each_entry_safe(event, tmp, &priv->wmi->pending_tx_events, list) {\n\t\tlist_del(&event->list);\n\t\tkfree(event);\n\t}\n\tspin_unlock_bh(&priv->wmi->event_lock);\n\n\tspin_lock_bh(&priv->tx.tx_lock);\n\tpriv->tx.flags &= ~ATH9K_HTC_OP_TX_DRAIN;\n\tspin_unlock_bh(&priv->tx.tx_lock);\n}\n\nvoid ath9k_tx_failed_tasklet(struct tasklet_struct *t)\n{\n\tstruct ath9k_htc_priv *priv = from_tasklet(priv, t, tx_failed_tasklet);\n\n\tspin_lock(&priv->tx.tx_lock);\n\tif (priv->tx.flags & ATH9K_HTC_OP_TX_DRAIN) {\n\t\tspin_unlock(&priv->tx.tx_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&priv->tx.tx_lock);\n\n\tath9k_htc_tx_drainq(priv, &priv->tx.tx_failed);\n}\n\nstatic inline bool check_cookie(struct ath9k_htc_priv *priv,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tu8 cookie, u8 epid)\n{\n\tu8 fcookie = 0;\n\n\tif (epid == priv->mgmt_ep) {\n\t\tstruct tx_mgmt_hdr *hdr;\n\t\thdr = (struct tx_mgmt_hdr *) skb->data;\n\t\tfcookie = hdr->cookie;\n\t} else if ((epid == priv->data_bk_ep) ||\n\t\t   (epid == priv->data_be_ep) ||\n\t\t   (epid == priv->data_vi_ep) ||\n\t\t   (epid == priv->data_vo_ep) ||\n\t\t   (epid == priv->cab_ep)) {\n\t\tstruct tx_frame_hdr *hdr;\n\t\thdr = (struct tx_frame_hdr *) skb->data;\n\t\tfcookie = hdr->cookie;\n\t}\n\n\tif (fcookie == cookie)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct sk_buff* ath9k_htc_tx_get_packet(struct ath9k_htc_priv *priv,\n\t\t\t\t\t       struct __wmi_event_txstatus *txs)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct sk_buff_head *epid_queue;\n\tstruct sk_buff *skb, *tmp;\n\tunsigned long flags;\n\tu8 epid = MS(txs->ts_rate, ATH9K_HTC_TXSTAT_EPID);\n\n\tepid_queue = get_htc_epid_queue(priv, epid);\n\tif (!epid_queue)\n\t\treturn NULL;\n\n\tspin_lock_irqsave(&epid_queue->lock, flags);\n\tskb_queue_walk_safe(epid_queue, skb, tmp) {\n\t\tif (check_cookie(priv, skb, txs->cookie, epid)) {\n\t\t\t__skb_unlink(skb, epid_queue);\n\t\t\tspin_unlock_irqrestore(&epid_queue->lock, flags);\n\t\t\treturn skb;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&epid_queue->lock, flags);\n\n\tath_dbg(common, XMIT, \"No matching packet for cookie: %d, epid: %d\\n\",\n\t\ttxs->cookie, epid);\n\n\treturn NULL;\n}\n\nvoid ath9k_htc_txstatus(struct ath9k_htc_priv *priv, void *wmi_event)\n{\n\tstruct wmi_event_txstatus *txs = wmi_event;\n\tstruct __wmi_event_txstatus *__txs;\n\tstruct sk_buff *skb;\n\tstruct ath9k_htc_tx_event *tx_pend;\n\tint i;\n\n\tfor (i = 0; i < txs->cnt; i++) {\n\t\tWARN_ON(txs->cnt > HTC_MAX_TX_STATUS);\n\n\t\t__txs = &txs->txstatus[i];\n\n\t\tskb = ath9k_htc_tx_get_packet(priv, __txs);\n\t\tif (!skb) {\n\t\t\t \n\t\t\ttx_pend = kzalloc(sizeof(struct ath9k_htc_tx_event),\n\t\t\t\t\t  GFP_ATOMIC);\n\t\t\tif (!tx_pend)\n\t\t\t\tcontinue;\n\n\t\t\tmemcpy(&tx_pend->txs, __txs,\n\t\t\t       sizeof(struct __wmi_event_txstatus));\n\n\t\t\tspin_lock(&priv->wmi->event_lock);\n\t\t\tlist_add_tail(&tx_pend->list,\n\t\t\t\t      &priv->wmi->pending_tx_events);\n\t\t\tspin_unlock(&priv->wmi->event_lock);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tath9k_htc_tx_process(priv, skb, __txs);\n\t}\n\n\t \n\tath9k_htc_check_wake_queues(priv);\n}\n\nvoid ath9k_htc_txep(void *drv_priv, struct sk_buff *skb,\n\t\t    enum htc_endpoint_id ep_id, bool txok)\n{\n\tstruct ath9k_htc_priv *priv = drv_priv;\n\tstruct ath9k_htc_tx_ctl *tx_ctl;\n\tstruct sk_buff_head *epid_queue;\n\n\ttx_ctl = HTC_SKB_CB(skb);\n\ttx_ctl->txok = txok;\n\ttx_ctl->timestamp = jiffies;\n\n\tif (!txok) {\n\t\tskb_queue_tail(&priv->tx.tx_failed, skb);\n\t\ttasklet_schedule(&priv->tx_failed_tasklet);\n\t\treturn;\n\t}\n\n\tepid_queue = get_htc_epid_queue(priv, ep_id);\n\tif (!epid_queue) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\n\tskb_queue_tail(epid_queue, skb);\n}\n\nstatic inline bool check_packet(struct ath9k_htc_priv *priv, struct sk_buff *skb)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ath9k_htc_tx_ctl *tx_ctl;\n\n\ttx_ctl = HTC_SKB_CB(skb);\n\n\tif (time_after(jiffies,\n\t\t       tx_ctl->timestamp +\n\t\t       msecs_to_jiffies(ATH9K_HTC_TX_TIMEOUT_INTERVAL))) {\n\t\tath_dbg(common, XMIT, \"Dropping a packet due to TX timeout\\n\");\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void ath9k_htc_tx_cleanup_queue(struct ath9k_htc_priv *priv,\n\t\t\t\t       struct sk_buff_head *epid_queue)\n{\n\tbool process = false;\n\tunsigned long flags;\n\tstruct sk_buff *skb, *tmp;\n\tstruct sk_buff_head queue;\n\n\tskb_queue_head_init(&queue);\n\n\tspin_lock_irqsave(&epid_queue->lock, flags);\n\tskb_queue_walk_safe(epid_queue, skb, tmp) {\n\t\tif (check_packet(priv, skb)) {\n\t\t\t__skb_unlink(skb, epid_queue);\n\t\t\t__skb_queue_tail(&queue, skb);\n\t\t\tprocess = true;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&epid_queue->lock, flags);\n\n\tif (process) {\n\t\tskb_queue_walk_safe(&queue, skb, tmp) {\n\t\t\t__skb_unlink(skb, &queue);\n\t\t\tath9k_htc_tx_process(priv, skb, NULL);\n\t\t}\n\t}\n}\n\nvoid ath9k_htc_tx_cleanup_timer(struct timer_list *t)\n{\n\tstruct ath9k_htc_priv *priv = from_timer(priv, t, tx.cleanup_timer);\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ath9k_htc_tx_event *event, *tmp;\n\tstruct sk_buff *skb;\n\n\tspin_lock(&priv->wmi->event_lock);\n\tlist_for_each_entry_safe(event, tmp, &priv->wmi->pending_tx_events, list) {\n\n\t\tskb = ath9k_htc_tx_get_packet(priv, &event->txs);\n\t\tif (skb) {\n\t\t\tath_dbg(common, XMIT,\n\t\t\t\t\"Found packet for cookie: %d, epid: %d\\n\",\n\t\t\t\tevent->txs.cookie,\n\t\t\t\tMS(event->txs.ts_rate, ATH9K_HTC_TXSTAT_EPID));\n\n\t\t\tath9k_htc_tx_process(priv, skb, &event->txs);\n\t\t\tlist_del(&event->list);\n\t\t\tkfree(event);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (++event->count >= ATH9K_HTC_TX_TIMEOUT_COUNT) {\n\t\t\tlist_del(&event->list);\n\t\t\tkfree(event);\n\t\t}\n\t}\n\tspin_unlock(&priv->wmi->event_lock);\n\n\t \n\tath9k_htc_tx_cleanup_queue(priv, &priv->tx.mgmt_ep_queue);\n\tath9k_htc_tx_cleanup_queue(priv, &priv->tx.cab_ep_queue);\n\tath9k_htc_tx_cleanup_queue(priv, &priv->tx.data_be_queue);\n\tath9k_htc_tx_cleanup_queue(priv, &priv->tx.data_bk_queue);\n\tath9k_htc_tx_cleanup_queue(priv, &priv->tx.data_vi_queue);\n\tath9k_htc_tx_cleanup_queue(priv, &priv->tx.data_vo_queue);\n\n\t \n\tath9k_htc_check_wake_queues(priv);\n\n\tmod_timer(&priv->tx.cleanup_timer,\n\t\t  jiffies + msecs_to_jiffies(ATH9K_HTC_TX_CLEANUP_INTERVAL));\n}\n\nint ath9k_tx_init(struct ath9k_htc_priv *priv)\n{\n\tskb_queue_head_init(&priv->tx.mgmt_ep_queue);\n\tskb_queue_head_init(&priv->tx.cab_ep_queue);\n\tskb_queue_head_init(&priv->tx.data_be_queue);\n\tskb_queue_head_init(&priv->tx.data_bk_queue);\n\tskb_queue_head_init(&priv->tx.data_vi_queue);\n\tskb_queue_head_init(&priv->tx.data_vo_queue);\n\tskb_queue_head_init(&priv->tx.tx_failed);\n\n\t \n\tsmp_wmb();\n\tpriv->tx.initialized = true;\n\n\treturn 0;\n}\n\nvoid ath9k_tx_cleanup(struct ath9k_htc_priv *priv)\n{\n\n}\n\nbool ath9k_htc_txq_setup(struct ath9k_htc_priv *priv, int subtype)\n{\n\tstruct ath_hw *ah = priv->ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_tx_queue_info qi;\n\tint qnum;\n\n\tmemset(&qi, 0, sizeof(qi));\n\tATH9K_HTC_INIT_TXQ(subtype);\n\n\tqnum = ath9k_hw_setuptxqueue(priv->ah, ATH9K_TX_QUEUE_DATA, &qi);\n\tif (qnum == -1)\n\t\treturn false;\n\n\tif (qnum >= ARRAY_SIZE(priv->hwq_map)) {\n\t\tath_err(common, \"qnum %u out of range, max %zu!\\n\",\n\t\t\tqnum, ARRAY_SIZE(priv->hwq_map));\n\t\tath9k_hw_releasetxqueue(ah, qnum);\n\t\treturn false;\n\t}\n\n\tpriv->hwq_map[subtype] = qnum;\n\treturn true;\n}\n\nint ath9k_htc_cabq_setup(struct ath9k_htc_priv *priv)\n{\n\tstruct ath9k_tx_queue_info qi;\n\n\tmemset(&qi, 0, sizeof(qi));\n\tATH9K_HTC_INIT_TXQ(0);\n\n\treturn ath9k_hw_setuptxqueue(priv->ah, ATH9K_TX_QUEUE_CAB, &qi);\n}\n\n \n \n \n\n \nu32 ath9k_htc_calcrxfilter(struct ath9k_htc_priv *priv)\n{\n#define\tRX_FILTER_PRESERVE (ATH9K_RX_FILTER_PHYERR | ATH9K_RX_FILTER_PHYRADAR)\n\n\tstruct ath_hw *ah = priv->ah;\n\tu32 rfilt;\n\n\trfilt = (ath9k_hw_getrxfilter(ah) & RX_FILTER_PRESERVE)\n\t\t| ATH9K_RX_FILTER_UCAST | ATH9K_RX_FILTER_BCAST\n\t\t| ATH9K_RX_FILTER_MCAST;\n\n\tif (priv->rxfilter & FIF_PROBE_REQ)\n\t\trfilt |= ATH9K_RX_FILTER_PROBEREQ;\n\n\tif (ah->is_monitoring)\n\t\trfilt |= ATH9K_RX_FILTER_PROM;\n\n\tif (priv->rxfilter & FIF_CONTROL)\n\t\trfilt |= ATH9K_RX_FILTER_CONTROL;\n\n\tif ((ah->opmode == NL80211_IFTYPE_STATION) &&\n\t    (priv->nvifs <= 1) &&\n\t    !(priv->rxfilter & FIF_BCN_PRBRESP_PROMISC))\n\t\trfilt |= ATH9K_RX_FILTER_MYBEACON;\n\telse\n\t\trfilt |= ATH9K_RX_FILTER_BEACON;\n\n\tif (conf_is_ht(&priv->hw->conf)) {\n\t\trfilt |= ATH9K_RX_FILTER_COMP_BAR;\n\t\trfilt |= ATH9K_RX_FILTER_UNCOMP_BA_BAR;\n\t}\n\n\tif (priv->rxfilter & FIF_PSPOLL)\n\t\trfilt |= ATH9K_RX_FILTER_PSPOLL;\n\n\tif (priv->nvifs > 1 ||\n\t    priv->rxfilter & (FIF_OTHER_BSS | FIF_MCAST_ACTION))\n\t\trfilt |= ATH9K_RX_FILTER_MCAST_BCAST_ALL;\n\n\treturn rfilt;\n\n#undef RX_FILTER_PRESERVE\n}\n\n \nstatic void ath9k_htc_opmode_init(struct ath9k_htc_priv *priv)\n{\n\tstruct ath_hw *ah = priv->ah;\n\tu32 rfilt, mfilt[2];\n\n\t \n\trfilt = ath9k_htc_calcrxfilter(priv);\n\tath9k_hw_setrxfilter(ah, rfilt);\n\n\t \n\tmfilt[0] = mfilt[1] = ~0;\n\tath9k_hw_setmcastfilter(ah, mfilt[0], mfilt[1]);\n}\n\nvoid ath9k_host_rx_init(struct ath9k_htc_priv *priv)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tath9k_hw_rxena(priv->ah);\n\tath9k_htc_opmode_init(priv);\n\tath9k_hw_startpcureceive(priv->ah, test_bit(ATH_OP_SCANNING, &common->op_flags));\n}\n\nstatic inline void convert_htc_flag(struct ath_rx_status *rx_stats,\n\t\t\t\t   struct ath_htc_rx_status *rxstatus)\n{\n\trx_stats->enc_flags = 0;\n\trx_stats->bw = RATE_INFO_BW_20;\n\tif (rxstatus->rs_flags & ATH9K_RX_2040)\n\t\trx_stats->bw = RATE_INFO_BW_40;\n\tif (rxstatus->rs_flags & ATH9K_RX_GI)\n\t\trx_stats->enc_flags |= RX_ENC_FLAG_SHORT_GI;\n}\n\nstatic void rx_status_htc_to_ath(struct ath_rx_status *rx_stats,\n\t\t\t\t struct ath_htc_rx_status *rxstatus)\n{\n\trx_stats->rs_datalen\t= be16_to_cpu(rxstatus->rs_datalen);\n\trx_stats->rs_status\t= rxstatus->rs_status;\n\trx_stats->rs_phyerr\t= rxstatus->rs_phyerr;\n\trx_stats->rs_rssi\t= rxstatus->rs_rssi;\n\trx_stats->rs_keyix\t= rxstatus->rs_keyix;\n\trx_stats->rs_rate\t= rxstatus->rs_rate;\n\trx_stats->rs_antenna\t= rxstatus->rs_antenna;\n\trx_stats->rs_more\t= rxstatus->rs_more;\n\n\tmemcpy(rx_stats->rs_rssi_ctl, rxstatus->rs_rssi_ctl,\n\t\tsizeof(rx_stats->rs_rssi_ctl));\n\tmemcpy(rx_stats->rs_rssi_ext, rxstatus->rs_rssi_ext,\n\t\tsizeof(rx_stats->rs_rssi_ext));\n\n\trx_stats->rs_isaggr\t= rxstatus->rs_isaggr;\n\trx_stats->rs_moreaggr\t= rxstatus->rs_moreaggr;\n\trx_stats->rs_num_delims\t= rxstatus->rs_num_delims;\n\tconvert_htc_flag(rx_stats, rxstatus);\n}\n\nstatic bool ath9k_rx_prepare(struct ath9k_htc_priv *priv,\n\t\t\t     struct ath9k_htc_rxbuf *rxbuf,\n\t\t\t     struct ieee80211_rx_status *rx_status)\n\n{\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_hw *hw = priv->hw;\n\tstruct sk_buff *skb = rxbuf->skb;\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ath_hw *ah = common->ah;\n\tstruct ath_htc_rx_status *rxstatus;\n\tstruct ath_rx_status rx_stats;\n\tbool decrypt_error = false;\n\tu16 rs_datalen;\n\tbool is_phyerr;\n\n\tif (skb->len < HTC_RX_FRAME_HEADER_SIZE) {\n\t\tath_err(common, \"Corrupted RX frame, dropping (len: %d)\\n\",\n\t\t\tskb->len);\n\t\tgoto rx_next;\n\t}\n\n\trxstatus = (struct ath_htc_rx_status *)skb->data;\n\n\trs_datalen = be16_to_cpu(rxstatus->rs_datalen);\n\tif (unlikely(rs_datalen -\n\t    (skb->len - HTC_RX_FRAME_HEADER_SIZE) != 0)) {\n\t\tath_err(common,\n\t\t\t\"Corrupted RX data len, dropping (dlen: %d, skblen: %d)\\n\",\n\t\t\trs_datalen, skb->len);\n\t\tgoto rx_next;\n\t}\n\n\tis_phyerr = rxstatus->rs_status & ATH9K_RXERR_PHY;\n\t \n\tif (unlikely(!rs_datalen || (rs_datalen < 10 && !is_phyerr))) {\n\t\tath_dbg(common, ANY,\n\t\t\t\"Short RX data len, dropping (dlen: %d)\\n\",\n\t\t\trs_datalen);\n\t\tgoto rx_next;\n\t}\n\n\tif (rxstatus->rs_keyix >= ATH_KEYMAX &&\n\t    rxstatus->rs_keyix != ATH9K_RXKEYIX_INVALID) {\n\t\tath_dbg(common, ANY,\n\t\t\t\"Invalid keyix, dropping (keyix: %d)\\n\",\n\t\t\trxstatus->rs_keyix);\n\t\tgoto rx_next;\n\t}\n\n\t \n\n\tmemset(rx_status, 0, sizeof(struct ieee80211_rx_status));\n\n\t \n\trx_status_htc_to_ath(&rx_stats, rxstatus);\n\tath9k_htc_err_stat_rx(priv, &rx_stats);\n\trx_status->mactime = be64_to_cpu(rxstatus->rs_tstamp);\n\tskb_pull(skb, HTC_RX_FRAME_HEADER_SIZE);\n\n\t \n\thdr = (struct ieee80211_hdr *)skb->data;\n\n\t \n\tif (unlikely(is_phyerr)) {\n\t\t \n\t\tif (ath_cmn_process_fft(&priv->spec_priv, hdr,\n\t\t\t\t    &rx_stats, rx_status->mactime)) {\n\t\t\t \n\t\t}\n\t\tgoto rx_next;\n\t}\n\n\tif (!ath9k_cmn_rx_accept(common, hdr, rx_status, &rx_stats,\n\t\t\t&decrypt_error, priv->rxfilter))\n\t\tgoto rx_next;\n\n\tath9k_cmn_rx_skb_postprocess(common, skb, &rx_stats,\n\t\t\t\t     rx_status, decrypt_error);\n\n\tif (ath9k_cmn_process_rate(common, hw, &rx_stats, rx_status))\n\t\tgoto rx_next;\n\n\trx_stats.is_mybeacon = ath_is_mybeacon(common, hdr);\n\tath9k_cmn_process_rssi(common, hw, &rx_stats, rx_status);\n\n\trx_status->band = ah->curchan->chan->band;\n\trx_status->freq = ah->curchan->chan->center_freq;\n\trx_status->antenna = rx_stats.rs_antenna;\n\trx_status->flag |= RX_FLAG_MACTIME_END;\n\n\treturn true;\nrx_next:\n\treturn false;\n}\n\n \nvoid ath9k_rx_tasklet(struct tasklet_struct *t)\n{\n\tstruct ath9k_htc_priv *priv = from_tasklet(priv, t, rx_tasklet);\n\tstruct ath9k_htc_rxbuf *rxbuf = NULL, *tmp_buf = NULL;\n\tstruct ieee80211_rx_status rx_status;\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\tstruct ieee80211_hdr *hdr;\n\n\tdo {\n\t\tspin_lock_irqsave(&priv->rx.rxbuflock, flags);\n\t\tlist_for_each_entry(tmp_buf, &priv->rx.rxbuf, list) {\n\t\t\tif (tmp_buf->in_process) {\n\t\t\t\trxbuf = tmp_buf;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (rxbuf == NULL) {\n\t\t\tspin_unlock_irqrestore(&priv->rx.rxbuflock, flags);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!rxbuf->skb)\n\t\t\tgoto requeue;\n\n\t\tif (!ath9k_rx_prepare(priv, rxbuf, &rx_status)) {\n\t\t\tdev_kfree_skb_any(rxbuf->skb);\n\t\t\tgoto requeue;\n\t\t}\n\n\t\tmemcpy(IEEE80211_SKB_RXCB(rxbuf->skb), &rx_status,\n\t\t       sizeof(struct ieee80211_rx_status));\n\t\tskb = rxbuf->skb;\n\t\thdr = (struct ieee80211_hdr *) skb->data;\n\n\t\tif (ieee80211_is_beacon(hdr->frame_control) && priv->ps_enabled)\n\t\t\t\tieee80211_queue_work(priv->hw, &priv->ps_work);\n\n\t\tspin_unlock_irqrestore(&priv->rx.rxbuflock, flags);\n\n\t\tieee80211_rx(priv->hw, skb);\n\n\t\tspin_lock_irqsave(&priv->rx.rxbuflock, flags);\nrequeue:\n\t\trxbuf->in_process = false;\n\t\trxbuf->skb = NULL;\n\t\tlist_move_tail(&rxbuf->list, &priv->rx.rxbuf);\n\t\trxbuf = NULL;\n\t\tspin_unlock_irqrestore(&priv->rx.rxbuflock, flags);\n\t} while (1);\n\n}\n\nvoid ath9k_htc_rxep(void *drv_priv, struct sk_buff *skb,\n\t\t    enum htc_endpoint_id ep_id)\n{\n\tstruct ath9k_htc_priv *priv = drv_priv;\n\tstruct ath_hw *ah = priv->ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_htc_rxbuf *rxbuf = NULL, *tmp_buf = NULL;\n\tunsigned long flags;\n\n\t \n\tif (!data_race(priv->rx.initialized))\n\t\tgoto err;\n\n\tspin_lock_irqsave(&priv->rx.rxbuflock, flags);\n\tlist_for_each_entry(tmp_buf, &priv->rx.rxbuf, list) {\n\t\tif (!tmp_buf->in_process) {\n\t\t\trxbuf = tmp_buf;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&priv->rx.rxbuflock, flags);\n\n\tif (rxbuf == NULL) {\n\t\tath_dbg(common, ANY, \"No free RX buffer\\n\");\n\t\tgoto err;\n\t}\n\n\tspin_lock_irqsave(&priv->rx.rxbuflock, flags);\n\trxbuf->skb = skb;\n\trxbuf->in_process = true;\n\tspin_unlock_irqrestore(&priv->rx.rxbuflock, flags);\n\n\ttasklet_schedule(&priv->rx_tasklet);\n\treturn;\nerr:\n\tdev_kfree_skb_any(skb);\n}\n\n \n\nvoid ath9k_rx_cleanup(struct ath9k_htc_priv *priv)\n{\n\tstruct ath9k_htc_rxbuf *rxbuf, *tbuf;\n\n\tlist_for_each_entry_safe(rxbuf, tbuf, &priv->rx.rxbuf, list) {\n\t\tlist_del(&rxbuf->list);\n\t\tif (rxbuf->skb)\n\t\t\tdev_kfree_skb_any(rxbuf->skb);\n\t\tkfree(rxbuf);\n\t}\n}\n\nint ath9k_rx_init(struct ath9k_htc_priv *priv)\n{\n\tint i = 0;\n\n\tINIT_LIST_HEAD(&priv->rx.rxbuf);\n\tspin_lock_init(&priv->rx.rxbuflock);\n\n\tfor (i = 0; i < ATH9K_HTC_RXBUF; i++) {\n\t\tstruct ath9k_htc_rxbuf *rxbuf =\n\t\t\tkzalloc(sizeof(struct ath9k_htc_rxbuf), GFP_KERNEL);\n\t\tif (rxbuf == NULL)\n\t\t\tgoto err;\n\n\t\tlist_add_tail(&rxbuf->list, &priv->rx.rxbuf);\n\t}\n\n\t \n\tsmp_wmb();\n\tpriv->rx.initialized = true;\n\n\treturn 0;\n\nerr:\n\tath9k_rx_cleanup(priv);\n\treturn -ENOMEM;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}