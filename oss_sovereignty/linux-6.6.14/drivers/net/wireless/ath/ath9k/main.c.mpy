{
  "module_name": "main.c",
  "hash_id": "499eccdc040aa84664e2eba28b375304d100331b5c04709458a335b2b6142917",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/main.c",
  "human_readable_source": " \n\n#include <linux/nl80211.h>\n#include <linux/delay.h>\n#include \"ath9k.h\"\n#include \"btcoex.h\"\n\nstatic void ath9k_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tu32 queues, bool drop);\n\nu8 ath9k_parse_mpdudensity(u8 mpdudensity)\n{\n\t \n\tswitch (mpdudensity) {\n\tcase 0:\n\t\treturn 0;\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\t\t \n\t\treturn 1;\n\tcase 4:\n\t\treturn 2;\n\tcase 5:\n\t\treturn 4;\n\tcase 6:\n\t\treturn 8;\n\tcase 7:\n\t\treturn 16;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic bool ath9k_has_pending_frames(struct ath_softc *sc, struct ath_txq *txq,\n\t\t\t\t     bool sw_pending)\n{\n\tbool pending = false;\n\n\tspin_lock_bh(&txq->axq_lock);\n\n\tif (txq->axq_depth) {\n\t\tpending = true;\n\t\tgoto out;\n\t}\n\n\tif (!sw_pending)\n\t\tgoto out;\n\n\tif (txq->mac80211_qnum >= 0) {\n\t\tstruct ath_acq *acq;\n\n\t\tacq = &sc->cur_chan->acq[txq->mac80211_qnum];\n\t\tif (!list_empty(&acq->acq_new) || !list_empty(&acq->acq_old))\n\t\t\tpending = true;\n\t}\nout:\n\tspin_unlock_bh(&txq->axq_lock);\n\treturn pending;\n}\n\nstatic bool ath9k_setpower(struct ath_softc *sc, enum ath9k_power_mode mode)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\tspin_lock_irqsave(&sc->sc_pm_lock, flags);\n\tret = ath9k_hw_setpower(sc->sc_ah, mode);\n\tspin_unlock_irqrestore(&sc->sc_pm_lock, flags);\n\n\treturn ret;\n}\n\nvoid ath_ps_full_sleep(struct timer_list *t)\n{\n\tstruct ath_softc *sc = from_timer(sc, t, sleep_timer);\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tunsigned long flags;\n\tbool reset;\n\n\tspin_lock_irqsave(&common->cc_lock, flags);\n\tath_hw_cycle_counters_update(common);\n\tspin_unlock_irqrestore(&common->cc_lock, flags);\n\n\tath9k_hw_setrxabort(sc->sc_ah, 1);\n\tath9k_hw_stopdmarecv(sc->sc_ah, &reset);\n\n\tath9k_hw_setpower(sc->sc_ah, ATH9K_PM_FULL_SLEEP);\n}\n\nvoid ath9k_ps_wakeup(struct ath_softc *sc)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tunsigned long flags;\n\tenum ath9k_power_mode power_mode;\n\n\tspin_lock_irqsave(&sc->sc_pm_lock, flags);\n\tif (++sc->ps_usecount != 1)\n\t\tgoto unlock;\n\n\tdel_timer_sync(&sc->sleep_timer);\n\tpower_mode = sc->sc_ah->power_mode;\n\tath9k_hw_setpower(sc->sc_ah, ATH9K_PM_AWAKE);\n\n\t \n\tif (power_mode != ATH9K_PM_AWAKE) {\n\t\tspin_lock(&common->cc_lock);\n\t\tath_hw_cycle_counters_update(common);\n\t\tmemset(&common->cc_survey, 0, sizeof(common->cc_survey));\n\t\tmemset(&common->cc_ani, 0, sizeof(common->cc_ani));\n\t\tspin_unlock(&common->cc_lock);\n\t}\n\n unlock:\n\tspin_unlock_irqrestore(&sc->sc_pm_lock, flags);\n}\n\nvoid ath9k_ps_restore(struct ath_softc *sc)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tenum ath9k_power_mode mode;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sc->sc_pm_lock, flags);\n\tif (--sc->ps_usecount != 0)\n\t\tgoto unlock;\n\n\tif (sc->ps_idle) {\n\t\tmod_timer(&sc->sleep_timer, jiffies + HZ / 10);\n\t\tgoto unlock;\n\t}\n\n\tif (sc->ps_enabled &&\n\t\t   !(sc->ps_flags & (PS_WAIT_FOR_BEACON |\n\t\t\t\t     PS_WAIT_FOR_CAB |\n\t\t\t\t     PS_WAIT_FOR_PSPOLL_DATA |\n\t\t\t\t     PS_WAIT_FOR_TX_ACK |\n\t\t\t\t     PS_WAIT_FOR_ANI))) {\n\t\tmode = ATH9K_PM_NETWORK_SLEEP;\n\t\tif (ath9k_hw_btcoex_is_enabled(sc->sc_ah))\n\t\t\tath9k_btcoex_stop_gen_timer(sc);\n\t} else {\n\t\tgoto unlock;\n\t}\n\n\tspin_lock(&common->cc_lock);\n\tath_hw_cycle_counters_update(common);\n\tspin_unlock(&common->cc_lock);\n\n\tath9k_hw_setpower(sc->sc_ah, mode);\n\n unlock:\n\tspin_unlock_irqrestore(&sc->sc_pm_lock, flags);\n}\n\nstatic void __ath_cancel_work(struct ath_softc *sc)\n{\n\tcancel_work_sync(&sc->paprd_work);\n\tcancel_delayed_work_sync(&sc->hw_check_work);\n\tcancel_delayed_work_sync(&sc->hw_pll_work);\n\n#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT\n\tif (ath9k_hw_mci_is_enabled(sc->sc_ah))\n\t\tcancel_work_sync(&sc->mci_work);\n#endif\n}\n\nvoid ath_cancel_work(struct ath_softc *sc)\n{\n\t__ath_cancel_work(sc);\n\tcancel_work_sync(&sc->hw_reset_work);\n}\n\nvoid ath_restart_work(struct ath_softc *sc)\n{\n\tieee80211_queue_delayed_work(sc->hw, &sc->hw_check_work,\n\t\t\t\t     msecs_to_jiffies(ATH_HW_CHECK_POLL_INT));\n\n\tif (AR_SREV_9340(sc->sc_ah) || AR_SREV_9330(sc->sc_ah))\n\t\tieee80211_queue_delayed_work(sc->hw, &sc->hw_pll_work,\n\t\t\t\t     msecs_to_jiffies(ATH_PLL_WORK_INTERVAL));\n\n\tath_start_ani(sc);\n}\n\nstatic bool ath_prepare_reset(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tbool ret = true;\n\n\tieee80211_stop_queues(sc->hw);\n\tath_stop_ani(sc);\n\tath9k_hw_disable_interrupts(ah);\n\n\tif (AR_SREV_9300_20_OR_LATER(ah)) {\n\t\tret &= ath_stoprecv(sc);\n\t\tret &= ath_drain_all_txq(sc);\n\t} else {\n\t\tret &= ath_drain_all_txq(sc);\n\t\tret &= ath_stoprecv(sc);\n\t}\n\n\treturn ret;\n}\n\nstatic bool ath_complete_reset(struct ath_softc *sc, bool start)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tunsigned long flags;\n\n\tath9k_calculate_summary_state(sc, sc->cur_chan);\n\tath_startrecv(sc);\n\tath9k_cmn_update_txpow(ah, sc->cur_chan->cur_txpower,\n\t\t\t       sc->cur_chan->txpower,\n\t\t\t       &sc->cur_chan->cur_txpower);\n\tclear_bit(ATH_OP_HW_RESET, &common->op_flags);\n\n\tif (!sc->cur_chan->offchannel && start) {\n\t\t \n\t\tif (sc->cur_chan->tsf_val) {\n\t\t\tu32 offset;\n\n\t\t\toffset = ath9k_hw_get_tsf_offset(&sc->cur_chan->tsf_ts,\n\t\t\t\t\t\t\t NULL);\n\t\t\tath9k_hw_settsf64(ah, sc->cur_chan->tsf_val + offset);\n\t\t}\n\n\n\t\tif (!test_bit(ATH_OP_BEACONS, &common->op_flags))\n\t\t\tgoto work;\n\n\t\tif (ah->opmode == NL80211_IFTYPE_STATION &&\n\t\t    test_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags)) {\n\t\t\tspin_lock_irqsave(&sc->sc_pm_lock, flags);\n\t\t\tsc->ps_flags |= PS_BEACON_SYNC | PS_WAIT_FOR_BEACON;\n\t\t\tspin_unlock_irqrestore(&sc->sc_pm_lock, flags);\n\t\t} else {\n\t\t\tath9k_set_beacon(sc);\n\t\t}\n\twork:\n\t\tath_restart_work(sc);\n\t\tath_txq_schedule_all(sc);\n\t}\n\n\tsc->gtt_cnt = 0;\n\n\tath9k_hw_set_interrupts(ah);\n\tath9k_hw_enable_interrupts(ah);\n\tieee80211_wake_queues(sc->hw);\n\tath9k_p2p_ps_timer(sc);\n\n\treturn true;\n}\n\nstatic int ath_reset_internal(struct ath_softc *sc, struct ath9k_channel *hchan)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_hw_cal_data *caldata = NULL;\n\tbool fastcc = true;\n\tint r;\n\n\t__ath_cancel_work(sc);\n\n\tdisable_irq(sc->irq);\n\ttasklet_disable(&sc->intr_tq);\n\ttasklet_disable(&sc->bcon_tasklet);\n\tspin_lock_bh(&sc->sc_pcu_lock);\n\n\tif (!sc->cur_chan->offchannel) {\n\t\tfastcc = false;\n\t\tcaldata = &sc->cur_chan->caldata;\n\t}\n\n\tif (!hchan) {\n\t\tfastcc = false;\n\t\thchan = ah->curchan;\n\t}\n\n\tif (!hchan) {\n\t\tfastcc = false;\n\t\thchan = ath9k_cmn_get_channel(sc->hw, ah, &sc->cur_chan->chandef);\n\t}\n\n\tif (!ath_prepare_reset(sc))\n\t\tfastcc = false;\n\n\tif (ath9k_is_chanctx_enabled())\n\t\tfastcc = false;\n\n\tspin_lock_bh(&sc->chan_lock);\n\tsc->cur_chandef = sc->cur_chan->chandef;\n\tspin_unlock_bh(&sc->chan_lock);\n\n\tath_dbg(common, CONFIG, \"Reset to %u MHz, HT40: %d fastcc: %d\\n\",\n\t\thchan->channel, IS_CHAN_HT40(hchan), fastcc);\n\n\tr = ath9k_hw_reset(ah, hchan, caldata, fastcc);\n\tif (r) {\n\t\tath_err(common,\n\t\t\t\"Unable to reset channel, reset status %d\\n\", r);\n\n\t\tath9k_hw_enable_interrupts(ah);\n\t\tath9k_queue_reset(sc, RESET_TYPE_BB_HANG);\n\n\t\tgoto out;\n\t}\n\n\tif (ath9k_hw_mci_is_enabled(sc->sc_ah) &&\n\t    sc->cur_chan->offchannel)\n\t\tath9k_mci_set_txpower(sc, true, false);\n\n\tif (!ath_complete_reset(sc, true))\n\t\tr = -EIO;\n\nout:\n\tenable_irq(sc->irq);\n\tspin_unlock_bh(&sc->sc_pcu_lock);\n\ttasklet_enable(&sc->bcon_tasklet);\n\ttasklet_enable(&sc->intr_tq);\n\n\treturn r;\n}\n\nstatic void ath_node_attach(struct ath_softc *sc, struct ieee80211_sta *sta,\n\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct ath_node *an;\n\tan = (struct ath_node *)sta->drv_priv;\n\n\tan->sc = sc;\n\tan->sta = sta;\n\tan->vif = vif;\n\tmemset(&an->key_idx, 0, sizeof(an->key_idx));\n\n\tath_tx_node_init(sc, an);\n\n\tath_dynack_node_init(sc->sc_ah, an);\n}\n\nstatic void ath_node_detach(struct ath_softc *sc, struct ieee80211_sta *sta)\n{\n\tstruct ath_node *an = (struct ath_node *)sta->drv_priv;\n\tath_tx_node_cleanup(sc, an);\n\n\tath_dynack_node_deinit(sc->sc_ah, an);\n}\n\nvoid ath9k_tasklet(struct tasklet_struct *t)\n{\n\tstruct ath_softc *sc = from_tasklet(sc, t, intr_tq);\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tenum ath_reset_type type;\n\tunsigned long flags;\n\tu32 status;\n\tu32 rxmask;\n\n\tspin_lock_irqsave(&sc->intr_lock, flags);\n\tstatus = sc->intrstatus;\n\tsc->intrstatus = 0;\n\tspin_unlock_irqrestore(&sc->intr_lock, flags);\n\n\tath9k_ps_wakeup(sc);\n\tspin_lock(&sc->sc_pcu_lock);\n\n\tif (status & ATH9K_INT_FATAL) {\n\t\ttype = RESET_TYPE_FATAL_INT;\n\t\tath9k_queue_reset(sc, type);\n\t\tath_dbg(common, RESET, \"FATAL: Skipping interrupts\\n\");\n\t\tgoto out;\n\t}\n\n\tif ((ah->config.hw_hang_checks & HW_BB_WATCHDOG) &&\n\t    (status & ATH9K_INT_BB_WATCHDOG)) {\n\t\tspin_lock_irqsave(&common->cc_lock, flags);\n\t\tath_hw_cycle_counters_update(common);\n\t\tar9003_hw_bb_watchdog_dbg_info(ah);\n\t\tspin_unlock_irqrestore(&common->cc_lock, flags);\n\n\t\tif (ar9003_hw_bb_watchdog_check(ah)) {\n\t\t\ttype = RESET_TYPE_BB_WATCHDOG;\n\t\t\tath9k_queue_reset(sc, type);\n\n\t\t\tath_dbg(common, RESET,\n\t\t\t\t\"BB_WATCHDOG: Skipping interrupts\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (status & ATH9K_INT_GTT) {\n\t\tsc->gtt_cnt++;\n\n\t\tif ((sc->gtt_cnt >= MAX_GTT_CNT) && !ath9k_hw_check_alive(ah)) {\n\t\t\ttype = RESET_TYPE_TX_GTT;\n\t\t\tath9k_queue_reset(sc, type);\n\t\t\tath_dbg(common, RESET,\n\t\t\t\t\"GTT: Skipping interrupts\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&sc->sc_pm_lock, flags);\n\tif ((status & ATH9K_INT_TSFOOR) && sc->ps_enabled) {\n\t\t \n\t\tath_dbg(common, PS, \"TSFOOR - Sync with next Beacon\\n\");\n\t\tsc->ps_flags |= PS_WAIT_FOR_BEACON | PS_BEACON_SYNC;\n\t}\n\tspin_unlock_irqrestore(&sc->sc_pm_lock, flags);\n\n\tif (ah->caps.hw_caps & ATH9K_HW_CAP_EDMA)\n\t\trxmask = (ATH9K_INT_RXHP | ATH9K_INT_RXLP | ATH9K_INT_RXEOL |\n\t\t\t  ATH9K_INT_RXORN);\n\telse\n\t\trxmask = (ATH9K_INT_RX | ATH9K_INT_RXEOL | ATH9K_INT_RXORN);\n\n\tif (status & rxmask) {\n\t\t \n\t\tif ((ah->caps.hw_caps & ATH9K_HW_CAP_EDMA) &&\n\t\t    (status & ATH9K_INT_RXHP))\n\t\t\tath_rx_tasklet(sc, 0, true);\n\n\t\tath_rx_tasklet(sc, 0, false);\n\t}\n\n\tif (status & ATH9K_INT_TX) {\n\t\tif (ah->caps.hw_caps & ATH9K_HW_CAP_EDMA) {\n\t\t\t \n\t\t\tsc->gtt_cnt = 0;\n\n\t\t\tath_tx_edma_tasklet(sc);\n\t\t} else {\n\t\t\tath_tx_tasklet(sc);\n\t\t}\n\n\t\twake_up(&sc->tx_wait);\n\t}\n\n\tif (status & ATH9K_INT_GENTIMER)\n\t\tath_gen_timer_isr(sc->sc_ah);\n\n\tath9k_btcoex_handle_interrupt(sc, status);\n\n\t \n\tath9k_hw_resume_interrupts(ah);\nout:\n\tspin_unlock(&sc->sc_pcu_lock);\n\tath9k_ps_restore(sc);\n}\n\nirqreturn_t ath_isr(int irq, void *dev)\n{\n#define SCHED_INTR (\t\t\t\t\\\n\t\tATH9K_INT_FATAL |\t\t\\\n\t\tATH9K_INT_BB_WATCHDOG |\t\t\\\n\t\tATH9K_INT_RXORN |\t\t\\\n\t\tATH9K_INT_RXEOL |\t\t\\\n\t\tATH9K_INT_RX |\t\t\t\\\n\t\tATH9K_INT_RXLP |\t\t\\\n\t\tATH9K_INT_RXHP |\t\t\\\n\t\tATH9K_INT_TX |\t\t\t\\\n\t\tATH9K_INT_BMISS |\t\t\\\n\t\tATH9K_INT_CST |\t\t\t\\\n\t\tATH9K_INT_GTT |\t\t\t\\\n\t\tATH9K_INT_TSFOOR |\t\t\\\n\t\tATH9K_INT_GENTIMER |\t\t\\\n\t\tATH9K_INT_MCI)\n\n\tstruct ath_softc *sc = dev;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tenum ath9k_int status;\n\tu32 sync_cause = 0;\n\tbool sched = false;\n\n\t \n\tif (!ah || test_bit(ATH_OP_INVALID, &common->op_flags))\n\t\treturn IRQ_NONE;\n\n\t \n\tif (!ath9k_hw_intrpend(ah))\n\t\treturn IRQ_NONE;\n\n\t \n\tath9k_hw_getisr(ah, &status, &sync_cause);  \n\tath9k_debug_sync_cause(sc, sync_cause);\n\tstatus &= ah->imask;\t \n\n\tif (test_bit(ATH_OP_HW_RESET, &common->op_flags)) {\n\t\tath9k_hw_kill_interrupts(sc->sc_ah);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\t \n\tspin_lock(&sc->intr_lock);\n\tsc->intrstatus |= status;\n\tspin_unlock(&sc->intr_lock);\n\n\tif (status & SCHED_INTR)\n\t\tsched = true;\n\n\t \n\tif (status & ATH9K_INT_FATAL)\n\t\tgoto chip_reset;\n\n\tif ((ah->config.hw_hang_checks & HW_BB_WATCHDOG) &&\n\t    (status & ATH9K_INT_BB_WATCHDOG))\n\t\tgoto chip_reset;\n\n\tif (status & ATH9K_INT_SWBA)\n\t\ttasklet_schedule(&sc->bcon_tasklet);\n\n\tif (status & ATH9K_INT_TXURN)\n\t\tath9k_hw_updatetxtriglevel(ah, true);\n\n\tif (status & ATH9K_INT_RXEOL) {\n\t\tah->imask &= ~(ATH9K_INT_RXEOL | ATH9K_INT_RXORN);\n\t\tath9k_hw_set_interrupts(ah);\n\t}\n\n\tif (!(ah->caps.hw_caps & ATH9K_HW_CAP_AUTOSLEEP))\n\t\tif (status & ATH9K_INT_TIM_TIMER) {\n\t\t\tif (ATH_DBG_WARN_ON_ONCE(sc->ps_idle))\n\t\t\t\tgoto chip_reset;\n\t\t\t \n\t\t\tath9k_setpower(sc, ATH9K_PM_AWAKE);\n\t\t\tspin_lock(&sc->sc_pm_lock);\n\t\t\tath9k_hw_setrxabort(sc->sc_ah, 0);\n\t\t\tsc->ps_flags |= PS_WAIT_FOR_BEACON;\n\t\t\tspin_unlock(&sc->sc_pm_lock);\n\t\t}\n\nchip_reset:\n\n\tath_debug_stat_interrupt(sc, status);\n\n\tif (sched) {\n\t\t \n\t\tath9k_hw_kill_interrupts(ah);\n\t\ttasklet_schedule(&sc->intr_tq);\n\t}\n\n\treturn IRQ_HANDLED;\n\n#undef SCHED_INTR\n}\n\n \nint ath_reset(struct ath_softc *sc, struct ath9k_channel *hchan)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tint r;\n\n\tath9k_hw_kill_interrupts(sc->sc_ah);\n\tset_bit(ATH_OP_HW_RESET, &common->op_flags);\n\n\tath9k_ps_wakeup(sc);\n\tr = ath_reset_internal(sc, hchan);\n\tath9k_ps_restore(sc);\n\n\treturn r;\n}\n\n \nvoid ath9k_queue_reset(struct ath_softc *sc, enum ath_reset_type type)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n#ifdef CONFIG_ATH9K_DEBUGFS\n\tRESET_STAT_INC(sc, type);\n#endif\n\tath9k_hw_kill_interrupts(sc->sc_ah);\n\tset_bit(ATH_OP_HW_RESET, &common->op_flags);\n\tieee80211_queue_work(sc->hw, &sc->hw_reset_work);\n}\n\nvoid ath_reset_work(struct work_struct *work)\n{\n\tstruct ath_softc *sc = container_of(work, struct ath_softc, hw_reset_work);\n\n\tath9k_ps_wakeup(sc);\n\tath_reset_internal(sc, NULL);\n\tath9k_ps_restore(sc);\n}\n\n \n \n \n\nstatic int ath9k_start(struct ieee80211_hw *hw)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ieee80211_channel *curchan = sc->cur_chan->chandef.chan;\n\tstruct ath_chanctx *ctx = sc->cur_chan;\n\tstruct ath9k_channel *init_channel;\n\tint r;\n\n\tath_dbg(common, CONFIG,\n\t\t\"Starting driver with initial channel: %d MHz\\n\",\n\t\tcurchan->center_freq);\n\n\tath9k_ps_wakeup(sc);\n\tmutex_lock(&sc->mutex);\n\n\tinit_channel = ath9k_cmn_get_channel(hw, ah, &ctx->chandef);\n\tsc->cur_chandef = hw->conf.chandef;\n\n\t \n\tath9k_hw_configpcipowersave(ah, false);\n\n\t \n\tspin_lock_bh(&sc->sc_pcu_lock);\n\n\tatomic_set(&ah->intr_ref_cnt, -1);\n\n\tr = ath9k_hw_reset(ah, init_channel, ah->caldata, false);\n\tif (r) {\n\t\tath_err(common,\n\t\t\t\"Unable to reset hardware; reset status %d (freq %u MHz)\\n\",\n\t\t\tr, curchan->center_freq);\n\t\tah->reset_power_on = false;\n\t}\n\n\t \n\tah->imask = ATH9K_INT_TX | ATH9K_INT_RXEOL |\n\t\t    ATH9K_INT_RXORN | ATH9K_INT_FATAL |\n\t\t    ATH9K_INT_GLOBAL;\n\n\tif (ah->caps.hw_caps & ATH9K_HW_CAP_EDMA)\n\t\tah->imask |= ATH9K_INT_RXHP |\n\t\t\t     ATH9K_INT_RXLP;\n\telse\n\t\tah->imask |= ATH9K_INT_RX;\n\n\tif (ah->config.hw_hang_checks & HW_BB_WATCHDOG)\n\t\tah->imask |= ATH9K_INT_BB_WATCHDOG;\n\n\t \n\tif (AR_SREV_9300_20_OR_LATER(ah))\n\t\tah->imask |= ATH9K_INT_GTT;\n\n\tif (ah->caps.hw_caps & ATH9K_HW_CAP_HT)\n\t\tah->imask |= ATH9K_INT_CST;\n\n\tath_mci_enable(sc);\n\n\tclear_bit(ATH_OP_INVALID, &common->op_flags);\n\tsc->sc_ah->is_monitoring = false;\n\n\tif (!ath_complete_reset(sc, false))\n\t\tah->reset_power_on = false;\n\n\tif (ah->led_pin >= 0) {\n\t\tath9k_hw_set_gpio(ah, ah->led_pin,\n\t\t\t\t  (ah->config.led_active_high) ? 1 : 0);\n\t\tath9k_hw_gpio_request_out(ah, ah->led_pin, NULL,\n\t\t\t\t\t  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);\n\t}\n\n\t \n\tath9k_cmn_init_crypto(sc->sc_ah);\n\n\tath9k_hw_reset_tsf(ah);\n\n\tspin_unlock_bh(&sc->sc_pcu_lock);\n\n\tath9k_rng_start(sc);\n\n\tmutex_unlock(&sc->mutex);\n\n\tath9k_ps_restore(sc);\n\n\treturn 0;\n}\n\nstatic void ath9k_tx(struct ieee80211_hw *hw,\n\t\t     struct ieee80211_tx_control *control,\n\t\t     struct sk_buff *skb)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_tx_control txctl;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tunsigned long flags;\n\n\tif (sc->ps_enabled) {\n\t\t \n\t\tif (ieee80211_is_data(hdr->frame_control) &&\n\t\t    !ieee80211_is_nullfunc(hdr->frame_control) &&\n\t\t    !ieee80211_has_pm(hdr->frame_control)) {\n\t\t\tath_dbg(common, PS,\n\t\t\t\t\"Add PM=1 for a TX frame while in PS mode\\n\");\n\t\t\thdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);\n\t\t}\n\t}\n\n\tif (unlikely(sc->sc_ah->power_mode == ATH9K_PM_NETWORK_SLEEP)) {\n\t\t \n\t\tath9k_ps_wakeup(sc);\n\t\tspin_lock_irqsave(&sc->sc_pm_lock, flags);\n\t\tif (!(sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_AUTOSLEEP))\n\t\t\tath9k_hw_setrxabort(sc->sc_ah, 0);\n\t\tif (ieee80211_is_pspoll(hdr->frame_control)) {\n\t\t\tath_dbg(common, PS,\n\t\t\t\t\"Sending PS-Poll to pick a buffered frame\\n\");\n\t\t\tsc->ps_flags |= PS_WAIT_FOR_PSPOLL_DATA;\n\t\t} else {\n\t\t\tath_dbg(common, PS, \"Wake up to complete TX\\n\");\n\t\t\tsc->ps_flags |= PS_WAIT_FOR_TX_ACK;\n\t\t}\n\t\t \n\t\tspin_unlock_irqrestore(&sc->sc_pm_lock, flags);\n\t\tath9k_ps_restore(sc);\n\t}\n\n\t \n\tif (unlikely(sc->sc_ah->power_mode == ATH9K_PM_FULL_SLEEP)) {\n\t\tath_err(common, \"TX while HW is in FULL_SLEEP mode\\n\");\n\t\tgoto exit;\n\t}\n\n\tmemset(&txctl, 0, sizeof(struct ath_tx_control));\n\ttxctl.txq = sc->tx.txq_map[skb_get_queue_mapping(skb)];\n\ttxctl.sta = control->sta;\n\n\tath_dbg(common, XMIT, \"transmitting packet, skb: %p\\n\", skb);\n\n\tif (ath_tx_start(hw, skb, &txctl) != 0) {\n\t\tath_dbg(common, XMIT, \"TX failed\\n\");\n\t\tTX_STAT_INC(sc, txctl.txq->axq_qnum, txfailed);\n\t\tgoto exit;\n\t}\n\n\treturn;\nexit:\n\tieee80211_free_txskb(hw, skb);\n}\n\nstatic bool ath9k_txq_list_has_key(struct list_head *txq_list, u32 keyix)\n{\n\tstruct ath_buf *bf;\n\tstruct ieee80211_tx_info *txinfo;\n\tstruct ath_frame_info *fi;\n\n\tlist_for_each_entry(bf, txq_list, list) {\n\t\tif (bf->bf_state.stale || !bf->bf_mpdu)\n\t\t\tcontinue;\n\n\t\ttxinfo = IEEE80211_SKB_CB(bf->bf_mpdu);\n\t\tfi = (struct ath_frame_info *)&txinfo->status.status_driver_data[0];\n\t\tif (fi->keyix == keyix)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool ath9k_txq_has_key(struct ath_softc *sc, u32 keyix)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tint i, j;\n\tstruct ath_txq *txq;\n\tbool key_in_use = false;\n\n\tfor (i = 0; !key_in_use && i < ATH9K_NUM_TX_QUEUES; i++) {\n\t\tif (!ATH_TXQ_SETUP(sc, i))\n\t\t\tcontinue;\n\t\ttxq = &sc->tx.txq[i];\n\t\tif (!txq->axq_depth)\n\t\t\tcontinue;\n\t\tif (!ath9k_hw_numtxpending(ah, txq->axq_qnum))\n\t\t\tcontinue;\n\n\t\tath_txq_lock(sc, txq);\n\t\tkey_in_use = ath9k_txq_list_has_key(&txq->axq_q, keyix);\n\t\tif (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_EDMA) {\n\t\t\tint idx = txq->txq_tailidx;\n\n\t\t\tfor (j = 0; !key_in_use &&\n\t\t\t     !list_empty(&txq->txq_fifo[idx]) &&\n\t\t\t     j < ATH_TXFIFO_DEPTH; j++) {\n\t\t\t\tkey_in_use = ath9k_txq_list_has_key(\n\t\t\t\t\t&txq->txq_fifo[idx], keyix);\n\t\t\t\tINCR(idx, ATH_TXFIFO_DEPTH);\n\t\t\t}\n\t\t}\n\t\tath_txq_unlock(sc, txq);\n\t}\n\n\treturn key_in_use;\n}\n\nstatic void ath9k_pending_key_del(struct ath_softc *sc, u8 keyix)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tif (!test_bit(keyix, ah->pending_del_keymap) ||\n\t    ath9k_txq_has_key(sc, keyix))\n\t\treturn;\n\n\t \n\tclear_bit(keyix, ah->pending_del_keymap);\n\tath_key_delete(common, keyix);\n}\n\nstatic void ath9k_stop(struct ieee80211_hw *hw)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tbool prev_idle;\n\tint i;\n\n\tath9k_deinit_channel_context(sc);\n\n\tmutex_lock(&sc->mutex);\n\n\tath9k_rng_stop(sc);\n\n\tath_cancel_work(sc);\n\n\tif (test_bit(ATH_OP_INVALID, &common->op_flags)) {\n\t\tath_dbg(common, ANY, \"Device not present\\n\");\n\t\tmutex_unlock(&sc->mutex);\n\t\treturn;\n\t}\n\n\t \n\tath9k_ps_wakeup(sc);\n\n\tspin_lock_bh(&sc->sc_pcu_lock);\n\n\t \n\tah->imask &= ~ATH9K_INT_GLOBAL;\n\n\t \n\tath9k_hw_disable_interrupts(ah);\n\n\tspin_unlock_bh(&sc->sc_pcu_lock);\n\n\t \n\tsynchronize_irq(sc->irq);\n\ttasklet_kill(&sc->intr_tq);\n\ttasklet_kill(&sc->bcon_tasklet);\n\n\tprev_idle = sc->ps_idle;\n\tsc->ps_idle = true;\n\n\tspin_lock_bh(&sc->sc_pcu_lock);\n\n\tif (ah->led_pin >= 0) {\n\t\tath9k_hw_set_gpio(ah, ah->led_pin,\n\t\t\t\t  (ah->config.led_active_high) ? 0 : 1);\n\t\tath9k_hw_gpio_request_in(ah, ah->led_pin, NULL);\n\t}\n\n\tath_prepare_reset(sc);\n\n\tif (sc->rx.frag) {\n\t\tdev_kfree_skb_any(sc->rx.frag);\n\t\tsc->rx.frag = NULL;\n\t}\n\n\tif (!ah->curchan)\n\t\tah->curchan = ath9k_cmn_get_channel(hw, ah,\n\t\t\t\t\t\t    &sc->cur_chan->chandef);\n\n\tath9k_hw_reset(ah, ah->curchan, ah->caldata, false);\n\n\tset_bit(ATH_OP_INVALID, &common->op_flags);\n\n\tath9k_hw_phy_disable(ah);\n\n\tath9k_hw_configpcipowersave(ah, true);\n\n\tspin_unlock_bh(&sc->sc_pcu_lock);\n\n\tfor (i = 0; i < ATH_KEYMAX; i++)\n\t\tath9k_pending_key_del(sc, i);\n\n\t \n\tath9k_cmn_init_crypto(sc->sc_ah);\n\n\tath9k_ps_restore(sc);\n\n\tsc->ps_idle = prev_idle;\n\n\tmutex_unlock(&sc->mutex);\n\n\tath_dbg(common, CONFIG, \"Driver halt\\n\");\n}\n\nstatic bool ath9k_uses_beacons(int type)\n{\n\tswitch (type) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic void ath9k_vif_iter_set_beacon(struct ath9k_vif_iter_data *iter_data,\n\t\t\t\t      struct ieee80211_vif *vif)\n{\n\t \n\tif (!iter_data->primary_beacon_vif) {\n\t\titer_data->primary_beacon_vif = vif;\n\t} else {\n\t\tif (iter_data->primary_beacon_vif->type != NL80211_IFTYPE_AP &&\n\t\t    vif->type == NL80211_IFTYPE_AP)\n\t\t\titer_data->primary_beacon_vif = vif;\n\t}\n\n\titer_data->beacons = true;\n\titer_data->nbcnvifs += 1;\n}\n\nstatic void ath9k_vif_iter(struct ath9k_vif_iter_data *iter_data,\n\t\t\t   u8 *mac, struct ieee80211_vif *vif)\n{\n\tstruct ath_vif *avp = (struct ath_vif *)vif->drv_priv;\n\tint i;\n\n\tif (iter_data->has_hw_macaddr) {\n\t\tfor (i = 0; i < ETH_ALEN; i++)\n\t\t\titer_data->mask[i] &=\n\t\t\t\t~(iter_data->hw_macaddr[i] ^ mac[i]);\n\t} else {\n\t\tmemcpy(iter_data->hw_macaddr, mac, ETH_ALEN);\n\t\titer_data->has_hw_macaddr = true;\n\t}\n\n\tif (!vif->bss_conf.use_short_slot)\n\t\titer_data->slottime = 20;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_AP:\n\t\titer_data->naps++;\n\t\tif (vif->bss_conf.enable_beacon)\n\t\t\tath9k_vif_iter_set_beacon(iter_data, vif);\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\titer_data->nstations++;\n\t\tif (avp->assoc && !iter_data->primary_sta)\n\t\t\titer_data->primary_sta = vif;\n\t\tbreak;\n\tcase NL80211_IFTYPE_OCB:\n\t\titer_data->nocbs++;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\titer_data->nadhocs++;\n\t\tif (vif->bss_conf.enable_beacon)\n\t\t\tath9k_vif_iter_set_beacon(iter_data, vif);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\titer_data->nmeshes++;\n\t\tif (vif->bss_conf.enable_beacon)\n\t\t\tath9k_vif_iter_set_beacon(iter_data, vif);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ath9k_update_bssid_mask(struct ath_softc *sc,\n\t\t\t\t    struct ath_chanctx *ctx,\n\t\t\t\t    struct ath9k_vif_iter_data *iter_data)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_vif *avp;\n\tint i;\n\n\tif (!ath9k_is_chanctx_enabled())\n\t\treturn;\n\n\tlist_for_each_entry(avp, &ctx->vifs, list) {\n\t\tif (ctx->nvifs_assigned != 1)\n\t\t\tcontinue;\n\n\t\tif (!iter_data->has_hw_macaddr)\n\t\t\tcontinue;\n\n\t\tether_addr_copy(common->curbssid, avp->bssid);\n\n\t\t \n\t\tfor (i = 0; i < ETH_ALEN; i++)\n\t\t\titer_data->mask[i] &=\n\t\t\t\t~(iter_data->hw_macaddr[i] ^\n\t\t\t\t  sc->hw->wiphy->perm_addr[i]);\n\t}\n}\n\n \nvoid ath9k_calculate_iter_data(struct ath_softc *sc,\n\t\t\t       struct ath_chanctx *ctx,\n\t\t\t       struct ath9k_vif_iter_data *iter_data)\n{\n\tstruct ath_vif *avp;\n\n\t \n\tmemset(iter_data, 0, sizeof(*iter_data));\n\teth_broadcast_addr(iter_data->mask);\n\titer_data->slottime = 9;\n\n\tlist_for_each_entry(avp, &ctx->vifs, list)\n\t\tath9k_vif_iter(iter_data, avp->vif->addr, avp->vif);\n\n\tath9k_update_bssid_mask(sc, ctx, iter_data);\n}\n\nstatic void ath9k_set_assoc_state(struct ath_softc *sc,\n\t\t\t\t  struct ieee80211_vif *vif, bool changed)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_vif *avp = (struct ath_vif *)vif->drv_priv;\n\tunsigned long flags;\n\n\tset_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags);\n\n\tether_addr_copy(common->curbssid, avp->bssid);\n\tcommon->curaid = avp->aid;\n\tath9k_hw_write_associd(sc->sc_ah);\n\n\tif (changed) {\n\t\tcommon->last_rssi = ATH_RSSI_DUMMY_MARKER;\n\t\tsc->sc_ah->stats.avgbrssi = ATH_RSSI_DUMMY_MARKER;\n\n\t\tspin_lock_irqsave(&sc->sc_pm_lock, flags);\n\t\tsc->ps_flags |= PS_BEACON_SYNC | PS_WAIT_FOR_BEACON;\n\t\tspin_unlock_irqrestore(&sc->sc_pm_lock, flags);\n\t}\n\n\tif (ath9k_hw_mci_is_enabled(sc->sc_ah))\n\t\tath9k_mci_update_wlan_channels(sc, false);\n\n\tath_dbg(common, CONFIG,\n\t\t\"Primary Station interface: %pM, BSSID: %pM\\n\",\n\t\tvif->addr, common->curbssid);\n}\n\n#ifdef CONFIG_ATH9K_CHANNEL_CONTEXT\nstatic void ath9k_set_offchannel_state(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ieee80211_vif *vif = NULL;\n\n\tath9k_ps_wakeup(sc);\n\n\tif (sc->offchannel.state < ATH_OFFCHANNEL_ROC_START)\n\t\tvif = sc->offchannel.scan_vif;\n\telse\n\t\tvif = sc->offchannel.roc_vif;\n\n\tif (WARN_ON(!vif))\n\t\tgoto exit;\n\n\teth_zero_addr(common->curbssid);\n\teth_broadcast_addr(common->bssidmask);\n\tmemcpy(common->macaddr, vif->addr, ETH_ALEN);\n\tcommon->curaid = 0;\n\tah->opmode = vif->type;\n\tah->imask &= ~ATH9K_INT_SWBA;\n\tah->imask &= ~ATH9K_INT_TSFOOR;\n\tah->slottime = 9;\n\n\tath_hw_setbssidmask(common);\n\tath9k_hw_setopmode(ah);\n\tath9k_hw_write_associd(sc->sc_ah);\n\tath9k_hw_set_interrupts(ah);\n\tath9k_hw_init_global_settings(ah);\n\nexit:\n\tath9k_ps_restore(sc);\n}\n#endif\n\n \nvoid ath9k_calculate_summary_state(struct ath_softc *sc,\n\t\t\t\t   struct ath_chanctx *ctx)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_vif_iter_data iter_data;\n\n\tath_chanctx_check_active(sc, ctx);\n\n\tif (ctx != sc->cur_chan)\n\t\treturn;\n\n#ifdef CONFIG_ATH9K_CHANNEL_CONTEXT\n\tif (ctx == &sc->offchannel.chan)\n\t\treturn ath9k_set_offchannel_state(sc);\n#endif\n\n\tath9k_ps_wakeup(sc);\n\tath9k_calculate_iter_data(sc, ctx, &iter_data);\n\n\tif (iter_data.has_hw_macaddr)\n\t\tmemcpy(common->macaddr, iter_data.hw_macaddr, ETH_ALEN);\n\n\tmemcpy(common->bssidmask, iter_data.mask, ETH_ALEN);\n\tath_hw_setbssidmask(common);\n\n\tif (iter_data.naps > 0) {\n\t\tath9k_hw_set_tsfadjust(ah, true);\n\t\tah->opmode = NL80211_IFTYPE_AP;\n\t} else {\n\t\tath9k_hw_set_tsfadjust(ah, false);\n\t\tif (iter_data.beacons)\n\t\t\tath9k_beacon_ensure_primary_slot(sc);\n\n\t\tif (iter_data.nmeshes)\n\t\t\tah->opmode = NL80211_IFTYPE_MESH_POINT;\n\t\telse if (iter_data.nocbs)\n\t\t\tah->opmode = NL80211_IFTYPE_OCB;\n\t\telse if (iter_data.nadhocs)\n\t\t\tah->opmode = NL80211_IFTYPE_ADHOC;\n\t\telse\n\t\t\tah->opmode = NL80211_IFTYPE_STATION;\n\t}\n\n\tath9k_hw_setopmode(ah);\n\n\tctx->switch_after_beacon = false;\n\tif ((iter_data.nstations + iter_data.nadhocs + iter_data.nmeshes) > 0)\n\t\tah->imask |= ATH9K_INT_TSFOOR;\n\telse {\n\t\tah->imask &= ~ATH9K_INT_TSFOOR;\n\t\tif (iter_data.naps == 1 && iter_data.beacons)\n\t\t\tctx->switch_after_beacon = true;\n\t}\n\n\tif (ah->opmode == NL80211_IFTYPE_STATION) {\n\t\tbool changed = (iter_data.primary_sta != ctx->primary_sta);\n\n\t\tif (iter_data.primary_sta) {\n\t\t\titer_data.primary_beacon_vif = iter_data.primary_sta;\n\t\t\titer_data.beacons = true;\n\t\t\tath9k_set_assoc_state(sc, iter_data.primary_sta,\n\t\t\t\t\t      changed);\n\t\t\tctx->primary_sta = iter_data.primary_sta;\n\t\t} else {\n\t\t\tctx->primary_sta = NULL;\n\t\t\teth_zero_addr(common->curbssid);\n\t\t\tcommon->curaid = 0;\n\t\t\tath9k_hw_write_associd(sc->sc_ah);\n\t\t\tif (ath9k_hw_mci_is_enabled(sc->sc_ah))\n\t\t\t\tath9k_mci_update_wlan_channels(sc, true);\n\t\t}\n\t}\n\tsc->nbcnvifs = iter_data.nbcnvifs;\n\tath9k_beacon_config(sc, iter_data.primary_beacon_vif,\n\t\t\t    iter_data.beacons);\n\tath9k_hw_set_interrupts(ah);\n\n\tif (ah->slottime != iter_data.slottime) {\n\t\tah->slottime = iter_data.slottime;\n\t\tath9k_hw_init_global_settings(ah);\n\t}\n\n\tif (iter_data.primary_sta)\n\t\tset_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags);\n\telse\n\t\tclear_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags);\n\n\tath_dbg(common, CONFIG,\n\t\t\"macaddr: %pM, bssid: %pM, bssidmask: %pM\\n\",\n\t\tcommon->macaddr, common->curbssid, common->bssidmask);\n\n\tath9k_ps_restore(sc);\n}\n\nstatic void ath9k_tpc_vif_iter(void *data, u8 *mac, struct ieee80211_vif *vif)\n{\n\tint *power = data;\n\n\tif (vif->bss_conf.txpower == INT_MIN)\n\t\treturn;\n\n\tif (*power < vif->bss_conf.txpower)\n\t\t*power = vif->bss_conf.txpower;\n}\n\n \nvoid ath9k_set_txpower(struct ath_softc *sc, struct ieee80211_vif *vif)\n{\n\tint power;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_regulatory *reg = ath9k_hw_regulatory(ah);\n\n\tath9k_ps_wakeup(sc);\n\tif (ah->tpc_enabled) {\n\t\tpower = (vif) ? vif->bss_conf.txpower : -1;\n\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\t\tsc->hw, IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\t\tath9k_tpc_vif_iter, &power);\n\t\tif (power == -1)\n\t\t\tpower = sc->hw->conf.power_level;\n\t} else {\n\t\tpower = sc->hw->conf.power_level;\n\t}\n\tsc->cur_chan->txpower = 2 * power;\n\tath9k_hw_set_txpowerlimit(ah, sc->cur_chan->txpower, false);\n\tsc->cur_chan->cur_txpower = reg->max_power_level;\n\tath9k_ps_restore(sc);\n}\n\nstatic void ath9k_assign_hw_queues(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tint i;\n\n\tif (!ath9k_is_chanctx_enabled())\n\t\treturn;\n\n\tfor (i = 0; i < IEEE80211_NUM_ACS; i++)\n\t\tvif->hw_queue[i] = i;\n\n\tif (vif->type == NL80211_IFTYPE_AP ||\n\t    vif->type == NL80211_IFTYPE_MESH_POINT)\n\t\tvif->cab_queue = hw->queues - 2;\n\telse\n\t\tvif->cab_queue = IEEE80211_INVAL_HW_QUEUE;\n}\n\nstatic int ath9k_add_interface(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath_vif *avp = (void *)vif->drv_priv;\n\tstruct ath_node *an = &avp->mcast_node;\n\n\tmutex_lock(&sc->mutex);\n\tif (IS_ENABLED(CONFIG_ATH9K_TX99)) {\n\t\tif (sc->cur_chan->nvifs >= 1) {\n\t\t\tmutex_unlock(&sc->mutex);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tsc->tx99_vif = vif;\n\t}\n\n\tath_dbg(common, CONFIG, \"Attach a VIF of type: %d\\n\", vif->type);\n\tsc->cur_chan->nvifs++;\n\n\tif (vif->type == NL80211_IFTYPE_STATION && ath9k_is_chanctx_enabled())\n\t\tvif->driver_flags |= IEEE80211_VIF_GET_NOA_UPDATE;\n\n\tif (ath9k_uses_beacons(vif->type))\n\t\tath9k_beacon_assign_slot(sc, vif);\n\n\tavp->vif = vif;\n\tif (!ath9k_is_chanctx_enabled()) {\n\t\tavp->chanctx = sc->cur_chan;\n\t\tlist_add_tail(&avp->list, &avp->chanctx->vifs);\n\t}\n\n\tath9k_calculate_summary_state(sc, avp->chanctx);\n\n\tath9k_assign_hw_queues(hw, vif);\n\n\tath9k_set_txpower(sc, vif);\n\n\tan->sc = sc;\n\tan->sta = NULL;\n\tan->vif = vif;\n\tan->no_ps_filter = true;\n\tath_tx_node_init(sc, an);\n\n\tmutex_unlock(&sc->mutex);\n\treturn 0;\n}\n\nstatic int ath9k_change_interface(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  enum nl80211_iftype new_type,\n\t\t\t\t  bool p2p)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_vif *avp = (void *)vif->drv_priv;\n\n\tmutex_lock(&sc->mutex);\n\n\tif (IS_ENABLED(CONFIG_ATH9K_TX99)) {\n\t\tmutex_unlock(&sc->mutex);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tath_dbg(common, CONFIG, \"Change Interface\\n\");\n\n\tif (ath9k_uses_beacons(vif->type))\n\t\tath9k_beacon_remove_slot(sc, vif);\n\n\tvif->type = new_type;\n\tvif->p2p = p2p;\n\n\tif (ath9k_uses_beacons(vif->type))\n\t\tath9k_beacon_assign_slot(sc, vif);\n\n\tath9k_assign_hw_queues(hw, vif);\n\tath9k_calculate_summary_state(sc, avp->chanctx);\n\n\tath9k_set_txpower(sc, vif);\n\n\tmutex_unlock(&sc->mutex);\n\treturn 0;\n}\n\nstatic void ath9k_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_vif *avp = (void *)vif->drv_priv;\n\n\tath_dbg(common, CONFIG, \"Detach Interface\\n\");\n\n\tmutex_lock(&sc->mutex);\n\n\tath9k_p2p_remove_vif(sc, vif);\n\n\tsc->cur_chan->nvifs--;\n\tsc->tx99_vif = NULL;\n\tif (!ath9k_is_chanctx_enabled())\n\t\tlist_del(&avp->list);\n\n\tif (ath9k_uses_beacons(vif->type))\n\t\tath9k_beacon_remove_slot(sc, vif);\n\n\tath_tx_node_cleanup(sc, &avp->mcast_node);\n\n\tath9k_calculate_summary_state(sc, avp->chanctx);\n\n\tath9k_set_txpower(sc, NULL);\n\n\tmutex_unlock(&sc->mutex);\n}\n\nstatic void ath9k_enable_ps(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tif (IS_ENABLED(CONFIG_ATH9K_TX99))\n\t\treturn;\n\n\tsc->ps_enabled = true;\n\tif (!(ah->caps.hw_caps & ATH9K_HW_CAP_AUTOSLEEP)) {\n\t\tif ((ah->imask & ATH9K_INT_TIM_TIMER) == 0) {\n\t\t\tah->imask |= ATH9K_INT_TIM_TIMER;\n\t\t\tath9k_hw_set_interrupts(ah);\n\t\t}\n\t\tath9k_hw_setrxabort(ah, 1);\n\t}\n\tath_dbg(common, PS, \"PowerSave enabled\\n\");\n}\n\nstatic void ath9k_disable_ps(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tif (IS_ENABLED(CONFIG_ATH9K_TX99))\n\t\treturn;\n\n\tsc->ps_enabled = false;\n\tath9k_hw_setpower(ah, ATH9K_PM_AWAKE);\n\tif (!(ah->caps.hw_caps & ATH9K_HW_CAP_AUTOSLEEP)) {\n\t\tath9k_hw_setrxabort(ah, 0);\n\t\tsc->ps_flags &= ~(PS_WAIT_FOR_BEACON |\n\t\t\t\t  PS_WAIT_FOR_CAB |\n\t\t\t\t  PS_WAIT_FOR_PSPOLL_DATA |\n\t\t\t\t  PS_WAIT_FOR_TX_ACK);\n\t\tif (ah->imask & ATH9K_INT_TIM_TIMER) {\n\t\t\tah->imask &= ~ATH9K_INT_TIM_TIMER;\n\t\t\tath9k_hw_set_interrupts(ah);\n\t\t}\n\t}\n\tath_dbg(common, PS, \"PowerSave disabled\\n\");\n}\n\nstatic int ath9k_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tstruct ath_chanctx *ctx = sc->cur_chan;\n\n\tath9k_ps_wakeup(sc);\n\tmutex_lock(&sc->mutex);\n\n\tif (changed & IEEE80211_CONF_CHANGE_IDLE) {\n\t\tsc->ps_idle = !!(conf->flags & IEEE80211_CONF_IDLE);\n\t\tif (sc->ps_idle) {\n\t\t\tath_cancel_work(sc);\n\t\t\tath9k_stop_btcoex(sc);\n\t\t} else {\n\t\t\tath9k_start_btcoex(sc);\n\t\t\t \n\t\t\tath_chanctx_set_channel(sc, ctx, &ctx->chandef);\n\t\t}\n\t}\n\n\t \n\tif (changed & IEEE80211_CONF_CHANGE_PS) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&sc->sc_pm_lock, flags);\n\t\tif (conf->flags & IEEE80211_CONF_PS)\n\t\t\tath9k_enable_ps(sc);\n\t\telse\n\t\t\tath9k_disable_ps(sc);\n\t\tspin_unlock_irqrestore(&sc->sc_pm_lock, flags);\n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_MONITOR) {\n\t\tif (conf->flags & IEEE80211_CONF_MONITOR) {\n\t\t\tath_dbg(common, CONFIG, \"Monitor mode is enabled\\n\");\n\t\t\tsc->sc_ah->is_monitoring = true;\n\t\t} else {\n\t\t\tath_dbg(common, CONFIG, \"Monitor mode is disabled\\n\");\n\t\t\tsc->sc_ah->is_monitoring = false;\n\t\t}\n\t}\n\n\tif (!ath9k_is_chanctx_enabled() && (changed & IEEE80211_CONF_CHANGE_CHANNEL)) {\n\t\tctx->offchannel = !!(conf->flags & IEEE80211_CONF_OFFCHANNEL);\n\t\tath_chanctx_set_channel(sc, ctx, &hw->conf.chandef);\n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_POWER)\n\t\tath9k_set_txpower(sc, NULL);\n\n\tmutex_unlock(&sc->mutex);\n\tath9k_ps_restore(sc);\n\n\treturn 0;\n}\n\n#define SUPPORTED_FILTERS\t\t\t\\\n\t(FIF_ALLMULTI |\t\t\t\t\\\n\tFIF_CONTROL |\t\t\t\t\\\n\tFIF_PSPOLL |\t\t\t\t\\\n\tFIF_OTHER_BSS |\t\t\t\t\\\n\tFIF_BCN_PRBRESP_PROMISC |\t\t\\\n\tFIF_PROBE_REQ |\t\t\t\t\\\n\tFIF_MCAST_ACTION |\t\t\t\\\n\tFIF_FCSFAIL)\n\n \nstatic void ath9k_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t   unsigned int changed_flags,\n\t\t\t\t   unsigned int *total_flags,\n\t\t\t\t   u64 multicast)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_chanctx *ctx;\n\tu32 rfilt;\n\n\t*total_flags &= SUPPORTED_FILTERS;\n\n\tspin_lock_bh(&sc->chan_lock);\n\tath_for_each_chanctx(sc, ctx)\n\t\tctx->rxfilter = *total_flags;\n#ifdef CONFIG_ATH9K_CHANNEL_CONTEXT\n\tsc->offchannel.chan.rxfilter = *total_flags;\n#endif\n\tspin_unlock_bh(&sc->chan_lock);\n\n\tath9k_ps_wakeup(sc);\n\trfilt = ath_calcrxfilter(sc);\n\tath9k_hw_setrxfilter(sc->sc_ah, rfilt);\n\tath9k_ps_restore(sc);\n\n\tath_dbg(ath9k_hw_common(sc->sc_ah), CONFIG, \"Set HW RX filter: 0x%x\\n\",\n\t\trfilt);\n}\n\nstatic int ath9k_sta_add(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t struct ieee80211_sta *sta)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_node *an = (struct ath_node *) sta->drv_priv;\n\tstruct ieee80211_key_conf ps_key = { };\n\tint key;\n\n\tath_node_attach(sc, sta, vif);\n\n\tif (vif->type != NL80211_IFTYPE_AP &&\n\t    vif->type != NL80211_IFTYPE_AP_VLAN)\n\t\treturn 0;\n\n\tkey = ath_key_config(common, vif, sta, &ps_key);\n\tif (key > 0) {\n\t\tan->ps_key = key;\n\t\tan->key_idx[0] = key;\n\t}\n\n\treturn 0;\n}\n\nstatic void ath9k_del_ps_key(struct ath_softc *sc,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_sta *sta)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_node *an = (struct ath_node *) sta->drv_priv;\n\n\tif (!an->ps_key)\n\t    return;\n\n\tath_key_delete(common, an->ps_key);\n\tan->ps_key = 0;\n\tan->key_idx[0] = 0;\n}\n\nstatic int ath9k_sta_remove(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_sta *sta)\n{\n\tstruct ath_softc *sc = hw->priv;\n\n\tath9k_del_ps_key(sc, vif, sta);\n\tath_node_detach(sc, sta);\n\n\treturn 0;\n}\n\nstatic int ath9k_sta_state(struct ieee80211_hw *hw,\n\t\t\t   struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_sta *sta,\n\t\t\t   enum ieee80211_sta_state old_state,\n\t\t\t   enum ieee80211_sta_state new_state)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tint ret = 0;\n\n\tif (old_state == IEEE80211_STA_NOTEXIST &&\n\t    new_state == IEEE80211_STA_NONE) {\n\t\tret = ath9k_sta_add(hw, vif, sta);\n\t\tath_dbg(common, CONFIG,\n\t\t\t\"Add station: %pM\\n\", sta->addr);\n\t} else if (old_state == IEEE80211_STA_NONE &&\n\t\t   new_state == IEEE80211_STA_NOTEXIST) {\n\t\tret = ath9k_sta_remove(hw, vif, sta);\n\t\tath_dbg(common, CONFIG,\n\t\t\t\"Remove station: %pM\\n\", sta->addr);\n\t}\n\n\tif (ath9k_is_chanctx_enabled()) {\n\t\tif (vif->type == NL80211_IFTYPE_STATION) {\n\t\t\tif (old_state == IEEE80211_STA_ASSOC &&\n\t\t\t    new_state == IEEE80211_STA_AUTHORIZED)\n\t\t\t\tath_chanctx_event(sc, vif,\n\t\t\t\t\t\t  ATH_CHANCTX_EVENT_AUTHORIZED);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void ath9k_sta_set_tx_filter(struct ath_hw *ah,\n\t\t\t\t    struct ath_node *an,\n\t\t\t\t    bool set)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(an->key_idx); i++) {\n\t\tif (!an->key_idx[i])\n\t\t\tcontinue;\n\t\tath9k_hw_set_tx_filter(ah, an->key_idx[i], set);\n\t}\n}\n\nstatic void ath9k_sta_notify(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t enum sta_notify_cmd cmd,\n\t\t\t struct ieee80211_sta *sta)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_node *an = (struct ath_node *) sta->drv_priv;\n\n\tswitch (cmd) {\n\tcase STA_NOTIFY_SLEEP:\n\t\tan->sleeping = true;\n\t\tath_tx_aggr_sleep(sta, sc, an);\n\t\tath9k_sta_set_tx_filter(sc->sc_ah, an, true);\n\t\tbreak;\n\tcase STA_NOTIFY_AWAKE:\n\t\tath9k_sta_set_tx_filter(sc->sc_ah, an, false);\n\t\tan->sleeping = false;\n\t\tath_tx_aggr_wakeup(sc, an);\n\t\tbreak;\n\t}\n}\n\nstatic int ath9k_conf_tx(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t unsigned int link_id, u16 queue,\n\t\t\t const struct ieee80211_tx_queue_params *params)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_txq *txq;\n\tstruct ath9k_tx_queue_info qi;\n\tint ret = 0;\n\n\tif (queue >= IEEE80211_NUM_ACS)\n\t\treturn 0;\n\n\ttxq = sc->tx.txq_map[queue];\n\n\tath9k_ps_wakeup(sc);\n\tmutex_lock(&sc->mutex);\n\n\tmemset(&qi, 0, sizeof(struct ath9k_tx_queue_info));\n\n\tqi.tqi_aifs = params->aifs;\n\tqi.tqi_cwmin = params->cw_min;\n\tqi.tqi_cwmax = params->cw_max;\n\tqi.tqi_burstTime = params->txop * 32;\n\n\tath_dbg(common, CONFIG,\n\t\t\"Configure tx [queue/halq] [%d/%d], aifs: %d, cw_min: %d, cw_max: %d, txop: %d\\n\",\n\t\tqueue, txq->axq_qnum, params->aifs, params->cw_min,\n\t\tparams->cw_max, params->txop);\n\n\tath_update_max_aggr_framelen(sc, queue, qi.tqi_burstTime);\n\tret = ath_txq_update(sc, txq->axq_qnum, &qi);\n\tif (ret)\n\t\tath_err(common, \"TXQ Update failed\\n\");\n\n\tmutex_unlock(&sc->mutex);\n\tath9k_ps_restore(sc);\n\n\treturn ret;\n}\n\nstatic int ath9k_set_key(struct ieee80211_hw *hw,\n\t\t\t enum set_key_cmd cmd,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t struct ieee80211_sta *sta,\n\t\t\t struct ieee80211_key_conf *key)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_node *an = NULL;\n\tint ret = 0, i;\n\n\tif (ath9k_modparam_nohwcrypt)\n\t\treturn -ENOSPC;\n\n\tif ((vif->type == NL80211_IFTYPE_ADHOC ||\n\t     vif->type == NL80211_IFTYPE_MESH_POINT) &&\n\t    (key->cipher == WLAN_CIPHER_SUITE_TKIP ||\n\t     key->cipher == WLAN_CIPHER_SUITE_CCMP) &&\n\t    !(key->flags & IEEE80211_KEY_FLAG_PAIRWISE)) {\n\t\t \n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (cmd == DISABLE_KEY && key->flags & IEEE80211_KEY_FLAG_PAIRWISE) {\n\t\tieee80211_stop_queues(hw);\n\t\tath9k_flush(hw, vif, 0, true);\n\t\tieee80211_wake_queues(hw);\n\t}\n\n\tmutex_lock(&sc->mutex);\n\tath9k_ps_wakeup(sc);\n\tath_dbg(common, CONFIG, \"Set HW Key %d\\n\", cmd);\n\tif (sta)\n\t\tan = (struct ath_node *)sta->drv_priv;\n\n\t \n\tfor (i = 0; i < ATH_KEYMAX; i++)\n\t\tath9k_pending_key_del(sc, i);\n\n\tswitch (cmd) {\n\tcase SET_KEY:\n\t\tif (sta)\n\t\t\tath9k_del_ps_key(sc, vif, sta);\n\n\t\tkey->hw_key_idx = 0;\n\t\tret = ath_key_config(common, vif, sta, key);\n\t\tif (ret >= 0) {\n\t\t\tkey->hw_key_idx = ret;\n\t\t\t \n\t\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\n\t\t\tif (key->cipher == WLAN_CIPHER_SUITE_TKIP)\n\t\t\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;\n\t\t\tif (sc->sc_ah->sw_mgmt_crypto_tx &&\n\t\t\t    key->cipher == WLAN_CIPHER_SUITE_CCMP)\n\t\t\t\tkey->flags |= IEEE80211_KEY_FLAG_SW_MGMT_TX;\n\t\t\tret = 0;\n\t\t}\n\t\tif (an && key->hw_key_idx) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(an->key_idx); i++) {\n\t\t\t\tif (an->key_idx[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tan->key_idx[i] = key->hw_key_idx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tWARN_ON(i == ARRAY_SIZE(an->key_idx));\n\t\t}\n\t\tbreak;\n\tcase DISABLE_KEY:\n\t\tif (ath9k_txq_has_key(sc, key->hw_key_idx)) {\n\t\t\t \n\t\t\tset_bit(key->hw_key_idx, sc->sc_ah->pending_del_keymap);\n\t\t\tath_hw_keysetmac(common, key->hw_key_idx, NULL);\n\t\t} else {\n\t\t\tath_key_delete(common, key->hw_key_idx);\n\t\t}\n\t\tif (an) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(an->key_idx); i++) {\n\t\t\t\tif (an->key_idx[i] != key->hw_key_idx)\n\t\t\t\t\tcontinue;\n\t\t\t\tan->key_idx[i] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tkey->hw_key_idx = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tath9k_ps_restore(sc);\n\tmutex_unlock(&sc->mutex);\n\n\treturn ret;\n}\n\nstatic void ath9k_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_bss_conf *bss_conf,\n\t\t\t\t   u64 changed)\n{\n#define CHECK_ANI\t\t\t\t\\\n\t(BSS_CHANGED_ASSOC |\t\t\t\\\n\t BSS_CHANGED_IBSS |\t\t\t\\\n\t BSS_CHANGED_BEACON_ENABLED)\n\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath_vif *avp = (void *)vif->drv_priv;\n\tint slottime;\n\n\tath9k_ps_wakeup(sc);\n\tmutex_lock(&sc->mutex);\n\n\tif (changed & BSS_CHANGED_ASSOC) {\n\t\tath_dbg(common, CONFIG, \"BSSID %pM Changed ASSOC %d\\n\",\n\t\t\tbss_conf->bssid, vif->cfg.assoc);\n\n\t\tmemcpy(avp->bssid, bss_conf->bssid, ETH_ALEN);\n\t\tavp->aid = vif->cfg.aid;\n\t\tavp->assoc = vif->cfg.assoc;\n\n\t\tath9k_calculate_summary_state(sc, avp->chanctx);\n\t}\n\n\tif ((changed & BSS_CHANGED_IBSS) ||\n\t      (changed & BSS_CHANGED_OCB)) {\n\t\tmemcpy(common->curbssid, bss_conf->bssid, ETH_ALEN);\n\t\tcommon->curaid = vif->cfg.aid;\n\t\tath9k_hw_write_associd(sc->sc_ah);\n\t}\n\n\tif ((changed & BSS_CHANGED_BEACON_ENABLED) ||\n\t    (changed & BSS_CHANGED_BEACON_INT) ||\n\t    (changed & BSS_CHANGED_BEACON_INFO)) {\n\t\tath9k_calculate_summary_state(sc, avp->chanctx);\n\t}\n\n\tif ((avp->chanctx == sc->cur_chan) &&\n\t    (changed & BSS_CHANGED_ERP_SLOT)) {\n\t\tif (bss_conf->use_short_slot)\n\t\t\tslottime = 9;\n\t\telse\n\t\t\tslottime = 20;\n\n\t\tif (vif->type == NL80211_IFTYPE_AP) {\n\t\t\t \n\t\t\tsc->beacon.slottime = slottime;\n\t\t\tsc->beacon.updateslot = UPDATE;\n\t\t} else {\n\t\t\tah->slottime = slottime;\n\t\t\tath9k_hw_init_global_settings(ah);\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_P2P_PS)\n\t\tath9k_p2p_bss_info_changed(sc, vif);\n\n\tif (changed & CHECK_ANI)\n\t\tath_check_ani(sc);\n\n\tif (changed & BSS_CHANGED_TXPOWER) {\n\t\tath_dbg(common, CONFIG, \"vif %pM power %d dbm power_type %d\\n\",\n\t\t\tvif->addr, bss_conf->txpower, bss_conf->txpower_type);\n\t\tath9k_set_txpower(sc, vif);\n\t}\n\n\tmutex_unlock(&sc->mutex);\n\tath9k_ps_restore(sc);\n\n#undef CHECK_ANI\n}\n\nstatic u64 ath9k_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_vif *avp = (void *)vif->drv_priv;\n\tu64 tsf;\n\n\tmutex_lock(&sc->mutex);\n\tath9k_ps_wakeup(sc);\n\t \n\tif (sc->cur_chan == avp->chanctx) {\n\t\ttsf = ath9k_hw_gettsf64(sc->sc_ah);\n\t} else {\n\t\ttsf = sc->cur_chan->tsf_val +\n\t\t      ath9k_hw_get_tsf_offset(&sc->cur_chan->tsf_ts, NULL);\n\t}\n\ttsf += le64_to_cpu(avp->tsf_adjust);\n\tath9k_ps_restore(sc);\n\tmutex_unlock(&sc->mutex);\n\n\treturn tsf;\n}\n\nstatic void ath9k_set_tsf(struct ieee80211_hw *hw,\n\t\t\t  struct ieee80211_vif *vif,\n\t\t\t  u64 tsf)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_vif *avp = (void *)vif->drv_priv;\n\n\tmutex_lock(&sc->mutex);\n\tath9k_ps_wakeup(sc);\n\ttsf -= le64_to_cpu(avp->tsf_adjust);\n\tktime_get_raw_ts64(&avp->chanctx->tsf_ts);\n\tif (sc->cur_chan == avp->chanctx)\n\t\tath9k_hw_settsf64(sc->sc_ah, tsf);\n\tavp->chanctx->tsf_val = tsf;\n\tath9k_ps_restore(sc);\n\tmutex_unlock(&sc->mutex);\n}\n\nstatic void ath9k_reset_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_vif *avp = (void *)vif->drv_priv;\n\n\tmutex_lock(&sc->mutex);\n\n\tath9k_ps_wakeup(sc);\n\tktime_get_raw_ts64(&avp->chanctx->tsf_ts);\n\tif (sc->cur_chan == avp->chanctx)\n\t\tath9k_hw_reset_tsf(sc->sc_ah);\n\tavp->chanctx->tsf_val = 0;\n\tath9k_ps_restore(sc);\n\n\tmutex_unlock(&sc->mutex);\n}\n\nstatic int ath9k_ampdu_action(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_ampdu_params *params)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tbool flush = false;\n\tint ret = 0;\n\tstruct ieee80211_sta *sta = params->sta;\n\tstruct ath_node *an = (struct ath_node *)sta->drv_priv;\n\tenum ieee80211_ampdu_mlme_action action = params->action;\n\tu16 tid = params->tid;\n\tu16 *ssn = &params->ssn;\n\tstruct ath_atx_tid *atid;\n\n\tmutex_lock(&sc->mutex);\n\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_RX_START:\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_START:\n\t\tif (ath9k_is_chanctx_enabled()) {\n\t\t\tif (test_bit(ATH_OP_SCANNING, &common->op_flags)) {\n\t\t\t\tret = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tath9k_ps_wakeup(sc);\n\t\tret = ath_tx_aggr_start(sc, sta, tid, ssn);\n\t\tif (!ret)\n\t\t\tret = IEEE80211_AMPDU_TX_START_IMMEDIATE;\n\t\tath9k_ps_restore(sc);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\t\tflush = true;\n\t\tfallthrough;\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\t\tath9k_ps_wakeup(sc);\n\t\tath_tx_aggr_stop(sc, sta, tid);\n\t\tif (!flush)\n\t\t\tieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\t\tath9k_ps_restore(sc);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\tatid = ath_node_to_tid(an, tid);\n\t\tatid->baw_size = IEEE80211_MIN_AMPDU_BUF <<\n\t\t\t\t\tsta->deflink.ht_cap.ampdu_factor;\n\t\tbreak;\n\tdefault:\n\t\tath_err(ath9k_hw_common(sc->sc_ah), \"Unknown AMPDU action\\n\");\n\t}\n\n\tmutex_unlock(&sc->mutex);\n\n\treturn ret;\n}\n\nstatic int ath9k_get_survey(struct ieee80211_hw *hw, int idx,\n\t\t\t     struct survey_info *survey)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *chan;\n\tunsigned long flags;\n\tint pos;\n\n\tif (IS_ENABLED(CONFIG_ATH9K_TX99))\n\t\treturn -EOPNOTSUPP;\n\n\tspin_lock_irqsave(&common->cc_lock, flags);\n\tif (idx == 0)\n\t\tath_update_survey_stats(sc);\n\n\tsband = hw->wiphy->bands[NL80211_BAND_2GHZ];\n\tif (sband && idx >= sband->n_channels) {\n\t\tidx -= sband->n_channels;\n\t\tsband = NULL;\n\t}\n\n\tif (!sband)\n\t\tsband = hw->wiphy->bands[NL80211_BAND_5GHZ];\n\n\tif (!sband || idx >= sband->n_channels) {\n\t\tspin_unlock_irqrestore(&common->cc_lock, flags);\n\t\treturn -ENOENT;\n\t}\n\n\tchan = &sband->channels[idx];\n\tpos = chan->hw_value;\n\tmemcpy(survey, &sc->survey[pos], sizeof(*survey));\n\tsurvey->channel = chan;\n\tspin_unlock_irqrestore(&common->cc_lock, flags);\n\n\treturn 0;\n}\n\nstatic void ath9k_enable_dynack(struct ath_softc *sc)\n{\n#ifdef CONFIG_ATH9K_DYNACK\n\tu32 rfilt;\n\tstruct ath_hw *ah = sc->sc_ah;\n\n\tath_dynack_reset(ah);\n\n\tah->dynack.enabled = true;\n\trfilt = ath_calcrxfilter(sc);\n\tath9k_hw_setrxfilter(ah, rfilt);\n#endif\n}\n\nstatic void ath9k_set_coverage_class(struct ieee80211_hw *hw,\n\t\t\t\t     s16 coverage_class)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_hw *ah = sc->sc_ah;\n\n\tif (IS_ENABLED(CONFIG_ATH9K_TX99))\n\t\treturn;\n\n\tmutex_lock(&sc->mutex);\n\n\tif (coverage_class >= 0) {\n\t\tah->coverage_class = coverage_class;\n\t\tif (ah->dynack.enabled) {\n\t\t\tu32 rfilt;\n\n\t\t\tah->dynack.enabled = false;\n\t\t\trfilt = ath_calcrxfilter(sc);\n\t\t\tath9k_hw_setrxfilter(ah, rfilt);\n\t\t}\n\t\tath9k_ps_wakeup(sc);\n\t\tath9k_hw_init_global_settings(ah);\n\t\tath9k_ps_restore(sc);\n\t} else if (!ah->dynack.enabled) {\n\t\tath9k_enable_dynack(sc);\n\t}\n\n\tmutex_unlock(&sc->mutex);\n}\n\nstatic bool ath9k_has_tx_pending(struct ath_softc *sc,\n\t\t\t\t bool sw_pending)\n{\n\tint i, npend = 0;\n\n\tfor (i = 0; i < ATH9K_NUM_TX_QUEUES; i++) {\n\t\tif (!ATH_TXQ_SETUP(sc, i))\n\t\t\tcontinue;\n\n\t\tnpend = ath9k_has_pending_frames(sc, &sc->tx.txq[i],\n\t\t\t\t\t\t sw_pending);\n\t\tif (npend)\n\t\t\tbreak;\n\t}\n\n\treturn !!npend;\n}\n\nstatic void ath9k_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tu32 queues, bool drop)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\n\tif (ath9k_is_chanctx_enabled()) {\n\t\tif (!test_bit(ATH_OP_MULTI_CHANNEL, &common->op_flags))\n\t\t\tgoto flush;\n\n\t\t \n\t\t__ath9k_flush(hw, queues, drop, true, true);\n\t\treturn;\n\t}\nflush:\n\tmutex_lock(&sc->mutex);\n\t__ath9k_flush(hw, queues, drop, true, false);\n\tmutex_unlock(&sc->mutex);\n}\n\nvoid __ath9k_flush(struct ieee80211_hw *hw, u32 queues, bool drop,\n\t\t   bool sw_pending, bool timeout_override)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tint timeout;\n\tbool drain_txq;\n\n\tcancel_delayed_work_sync(&sc->hw_check_work);\n\n\tif (ah->ah_flags & AH_UNPLUGGED) {\n\t\tath_dbg(common, ANY, \"Device has been unplugged!\\n\");\n\t\treturn;\n\t}\n\n\tif (test_bit(ATH_OP_INVALID, &common->op_flags)) {\n\t\tath_dbg(common, ANY, \"Device not present\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&sc->chan_lock);\n\tif (timeout_override)\n\t\ttimeout = HZ / 5;\n\telse\n\t\ttimeout = sc->cur_chan->flush_timeout;\n\tspin_unlock_bh(&sc->chan_lock);\n\n\tath_dbg(common, CHAN_CTX,\n\t\t\"Flush timeout: %d\\n\", jiffies_to_msecs(timeout));\n\n\tif (wait_event_timeout(sc->tx_wait, !ath9k_has_tx_pending(sc, sw_pending),\n\t\t\t       timeout) > 0)\n\t\tdrop = false;\n\n\tif (drop) {\n\t\tath9k_ps_wakeup(sc);\n\t\tspin_lock_bh(&sc->sc_pcu_lock);\n\t\tdrain_txq = ath_drain_all_txq(sc);\n\t\tspin_unlock_bh(&sc->sc_pcu_lock);\n\n\t\tif (!drain_txq)\n\t\t\tath_reset(sc, NULL);\n\n\t\tath9k_ps_restore(sc);\n\t}\n\n\tieee80211_queue_delayed_work(hw, &sc->hw_check_work,\n\t\t\t\t     msecs_to_jiffies(ATH_HW_CHECK_POLL_INT));\n}\n\nstatic bool ath9k_tx_frames_pending(struct ieee80211_hw *hw)\n{\n\tstruct ath_softc *sc = hw->priv;\n\n\treturn ath9k_has_tx_pending(sc, true);\n}\n\nstatic int ath9k_tx_last_beacon(struct ieee80211_hw *hw)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ieee80211_vif *vif;\n\tstruct ath_vif *avp;\n\tstruct ath_buf *bf;\n\tstruct ath_tx_status ts;\n\tbool edma = !!(ah->caps.hw_caps & ATH9K_HW_CAP_EDMA);\n\tint status;\n\n\tvif = sc->beacon.bslot[0];\n\tif (!vif)\n\t\treturn 0;\n\n\tif (!vif->bss_conf.enable_beacon)\n\t\treturn 0;\n\n\tavp = (void *)vif->drv_priv;\n\n\tif (!sc->beacon.tx_processed && !edma) {\n\t\ttasklet_disable(&sc->bcon_tasklet);\n\n\t\tbf = avp->av_bcbuf;\n\t\tif (!bf || !bf->bf_mpdu)\n\t\t\tgoto skip;\n\n\t\tstatus = ath9k_hw_txprocdesc(ah, bf->bf_desc, &ts);\n\t\tif (status == -EINPROGRESS)\n\t\t\tgoto skip;\n\n\t\tsc->beacon.tx_processed = true;\n\t\tsc->beacon.tx_last = !(ts.ts_status & ATH9K_TXERR_MASK);\n\nskip:\n\t\ttasklet_enable(&sc->bcon_tasklet);\n\t}\n\n\treturn sc->beacon.tx_last;\n}\n\nstatic int ath9k_get_stats(struct ieee80211_hw *hw,\n\t\t\t   struct ieee80211_low_level_stats *stats)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath9k_mib_stats *mib_stats = &ah->ah_mibStats;\n\n\tstats->dot11ACKFailureCount = mib_stats->ackrcv_bad;\n\tstats->dot11RTSFailureCount = mib_stats->rts_bad;\n\tstats->dot11FCSErrorCount = mib_stats->fcs_bad;\n\tstats->dot11RTSSuccessCount = mib_stats->rts_good;\n\treturn 0;\n}\n\nstatic u32 fill_chainmask(u32 cap, u32 new)\n{\n\tu32 filled = 0;\n\tint i;\n\n\tfor (i = 0; cap && new; i++, cap >>= 1) {\n\t\tif (!(cap & BIT(0)))\n\t\t\tcontinue;\n\n\t\tif (new & BIT(0))\n\t\t\tfilled |= BIT(i);\n\n\t\tnew >>= 1;\n\t}\n\n\treturn filled;\n}\n\nstatic bool validate_antenna_mask(struct ath_hw *ah, u32 val)\n{\n\tif (AR_SREV_9300_20_OR_LATER(ah))\n\t\treturn true;\n\n\tswitch (val & 0x7) {\n\tcase 0x1:\n\tcase 0x3:\n\tcase 0x7:\n\t\treturn true;\n\tcase 0x2:\n\t\treturn (ah->caps.rx_chainmask == 1);\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int ath9k_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_hw *ah = sc->sc_ah;\n\n\tif (ah->caps.rx_chainmask != 1)\n\t\trx_ant |= tx_ant;\n\n\tif (!validate_antenna_mask(ah, rx_ant) || !tx_ant)\n\t\treturn -EINVAL;\n\n\tsc->ant_rx = rx_ant;\n\tsc->ant_tx = tx_ant;\n\n\tif (ah->caps.rx_chainmask == 1)\n\t\treturn 0;\n\n\t \n\tif (AR_SREV_9100(ah))\n\t\tah->rxchainmask = 0x7;\n\telse\n\t\tah->rxchainmask = fill_chainmask(ah->caps.rx_chainmask, rx_ant);\n\n\tah->txchainmask = fill_chainmask(ah->caps.tx_chainmask, tx_ant);\n\tath9k_cmn_reload_chainmask(ah);\n\n\treturn 0;\n}\n\nstatic int ath9k_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant)\n{\n\tstruct ath_softc *sc = hw->priv;\n\n\t*tx_ant = sc->ant_tx;\n\t*rx_ant = sc->ant_rx;\n\treturn 0;\n}\n\nstatic void ath9k_sw_scan_start(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tconst u8 *mac_addr)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tset_bit(ATH_OP_SCANNING, &common->op_flags);\n}\n\nstatic void ath9k_sw_scan_complete(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tclear_bit(ATH_OP_SCANNING, &common->op_flags);\n}\n\n#ifdef CONFIG_ATH9K_CHANNEL_CONTEXT\n\nstatic void ath9k_cancel_pending_offchannel(struct ath_softc *sc)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\n\tif (sc->offchannel.roc_vif) {\n\t\tath_dbg(common, CHAN_CTX,\n\t\t\t\"%s: Aborting RoC\\n\", __func__);\n\n\t\tdel_timer_sync(&sc->offchannel.timer);\n\t\tif (sc->offchannel.state >= ATH_OFFCHANNEL_ROC_START)\n\t\t\tath_roc_complete(sc, ATH_ROC_COMPLETE_ABORT);\n\t}\n\n\tif (test_bit(ATH_OP_SCANNING, &common->op_flags)) {\n\t\tath_dbg(common, CHAN_CTX,\n\t\t\t\"%s: Aborting HW scan\\n\", __func__);\n\n\t\tdel_timer_sync(&sc->offchannel.timer);\n\t\tath_scan_complete(sc, true);\n\t}\n}\n\nstatic int ath9k_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t struct ieee80211_scan_request *hw_req)\n{\n\tstruct cfg80211_scan_request *req = &hw_req->req;\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tint ret = 0;\n\n\tmutex_lock(&sc->mutex);\n\n\tif (WARN_ON(sc->offchannel.scan_req)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tath9k_ps_wakeup(sc);\n\tset_bit(ATH_OP_SCANNING, &common->op_flags);\n\tsc->offchannel.scan_vif = vif;\n\tsc->offchannel.scan_req = req;\n\tsc->offchannel.scan_idx = 0;\n\n\tath_dbg(common, CHAN_CTX, \"HW scan request received on vif: %pM\\n\",\n\t\tvif->addr);\n\n\tif (sc->offchannel.state == ATH_OFFCHANNEL_IDLE) {\n\t\tath_dbg(common, CHAN_CTX, \"Starting HW scan\\n\");\n\t\tath_offchannel_next(sc);\n\t}\n\nout:\n\tmutex_unlock(&sc->mutex);\n\n\treturn ret;\n}\n\nstatic void ath9k_cancel_hw_scan(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\n\tath_dbg(common, CHAN_CTX, \"Cancel HW scan on vif: %pM\\n\", vif->addr);\n\n\tmutex_lock(&sc->mutex);\n\tdel_timer_sync(&sc->offchannel.timer);\n\tath_scan_complete(sc, true);\n\tmutex_unlock(&sc->mutex);\n}\n\nstatic int ath9k_remain_on_channel(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_channel *chan, int duration,\n\t\t\t\t   enum ieee80211_roc_type type)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tint ret = 0;\n\n\tmutex_lock(&sc->mutex);\n\n\tif (WARN_ON(sc->offchannel.roc_vif)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tath9k_ps_wakeup(sc);\n\tsc->offchannel.roc_vif = vif;\n\tsc->offchannel.roc_chan = chan;\n\tsc->offchannel.roc_duration = duration;\n\n\tath_dbg(common, CHAN_CTX,\n\t\t\"RoC request on vif: %pM, type: %d duration: %d\\n\",\n\t\tvif->addr, type, duration);\n\n\tif (sc->offchannel.state == ATH_OFFCHANNEL_IDLE) {\n\t\tath_dbg(common, CHAN_CTX, \"Starting RoC period\\n\");\n\t\tath_offchannel_next(sc);\n\t}\n\nout:\n\tmutex_unlock(&sc->mutex);\n\n\treturn ret;\n}\n\nstatic int ath9k_cancel_remain_on_channel(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\n\tmutex_lock(&sc->mutex);\n\n\tath_dbg(common, CHAN_CTX, \"Cancel RoC\\n\");\n\tdel_timer_sync(&sc->offchannel.timer);\n\n\tif (sc->offchannel.roc_vif) {\n\t\tif (sc->offchannel.state >= ATH_OFFCHANNEL_ROC_START)\n\t\t\tath_roc_complete(sc, ATH_ROC_COMPLETE_CANCEL);\n\t}\n\n\tmutex_unlock(&sc->mutex);\n\n\treturn 0;\n}\n\nstatic int ath9k_add_chanctx(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_chanctx_conf *conf)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_chanctx *ctx, **ptr;\n\tint pos;\n\n\tmutex_lock(&sc->mutex);\n\n\tath_for_each_chanctx(sc, ctx) {\n\t\tif (ctx->assigned)\n\t\t\tcontinue;\n\n\t\tptr = (void *) conf->drv_priv;\n\t\t*ptr = ctx;\n\t\tctx->assigned = true;\n\t\tpos = ctx - &sc->chanctx[0];\n\t\tctx->hw_queue_base = pos * IEEE80211_NUM_ACS;\n\n\t\tath_dbg(common, CHAN_CTX,\n\t\t\t\"Add channel context: %d MHz\\n\",\n\t\t\tconf->def.chan->center_freq);\n\n\t\tath_chanctx_set_channel(sc, ctx, &conf->def);\n\n\t\tmutex_unlock(&sc->mutex);\n\t\treturn 0;\n\t}\n\n\tmutex_unlock(&sc->mutex);\n\treturn -ENOSPC;\n}\n\n\nstatic void ath9k_remove_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_chanctx_conf *conf)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_chanctx *ctx = ath_chanctx_get(conf);\n\n\tmutex_lock(&sc->mutex);\n\n\tath_dbg(common, CHAN_CTX,\n\t\t\"Remove channel context: %d MHz\\n\",\n\t\tconf->def.chan->center_freq);\n\n\tctx->assigned = false;\n\tctx->hw_queue_base = 0;\n\tath_chanctx_event(sc, NULL, ATH_CHANCTX_EVENT_UNASSIGN);\n\n\tmutex_unlock(&sc->mutex);\n}\n\nstatic void ath9k_change_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_chanctx_conf *conf,\n\t\t\t\t u32 changed)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_chanctx *ctx = ath_chanctx_get(conf);\n\n\tmutex_lock(&sc->mutex);\n\tath_dbg(common, CHAN_CTX,\n\t\t\"Change channel context: %d MHz\\n\",\n\t\tconf->def.chan->center_freq);\n\tath_chanctx_set_channel(sc, ctx, &conf->def);\n\tmutex_unlock(&sc->mutex);\n}\n\nstatic int ath9k_assign_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_bss_conf *link_conf,\n\t\t\t\t    struct ieee80211_chanctx_conf *conf)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_vif *avp = (void *)vif->drv_priv;\n\tstruct ath_chanctx *ctx = ath_chanctx_get(conf);\n\tint i;\n\n\tath9k_cancel_pending_offchannel(sc);\n\n\tmutex_lock(&sc->mutex);\n\n\tath_dbg(common, CHAN_CTX,\n\t\t\"Assign VIF (addr: %pM, type: %d, p2p: %d) to channel context: %d MHz\\n\",\n\t\tvif->addr, vif->type, vif->p2p,\n\t\tconf->def.chan->center_freq);\n\n\tavp->chanctx = ctx;\n\tctx->nvifs_assigned++;\n\tlist_add_tail(&avp->list, &ctx->vifs);\n\tath9k_calculate_summary_state(sc, ctx);\n\tfor (i = 0; i < IEEE80211_NUM_ACS; i++)\n\t\tvif->hw_queue[i] = ctx->hw_queue_base + i;\n\n\tmutex_unlock(&sc->mutex);\n\n\treturn 0;\n}\n\nstatic void ath9k_unassign_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_bss_conf *link_conf,\n\t\t\t\t       struct ieee80211_chanctx_conf *conf)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_vif *avp = (void *)vif->drv_priv;\n\tstruct ath_chanctx *ctx = ath_chanctx_get(conf);\n\tint ac;\n\n\tath9k_cancel_pending_offchannel(sc);\n\n\tmutex_lock(&sc->mutex);\n\n\tath_dbg(common, CHAN_CTX,\n\t\t\"Remove VIF (addr: %pM, type: %d, p2p: %d) from channel context: %d MHz\\n\",\n\t\tvif->addr, vif->type, vif->p2p,\n\t\tconf->def.chan->center_freq);\n\n\tavp->chanctx = NULL;\n\tctx->nvifs_assigned--;\n\tlist_del(&avp->list);\n\tath9k_calculate_summary_state(sc, ctx);\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\n\t\tvif->hw_queue[ac] = IEEE80211_INVAL_HW_QUEUE;\n\n\tmutex_unlock(&sc->mutex);\n}\n\nstatic void ath9k_mgd_prepare_tx(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_prep_tx_info *info)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_vif *avp = (struct ath_vif *) vif->drv_priv;\n\tstruct ath_beacon_config *cur_conf;\n\tstruct ath_chanctx *go_ctx;\n\tunsigned long timeout;\n\tbool changed = false;\n\tu32 beacon_int;\n\n\tif (!test_bit(ATH_OP_MULTI_CHANNEL, &common->op_flags))\n\t\treturn;\n\n\tif (!avp->chanctx)\n\t\treturn;\n\n\tmutex_lock(&sc->mutex);\n\n\tspin_lock_bh(&sc->chan_lock);\n\tif (sc->next_chan || (sc->cur_chan != avp->chanctx))\n\t\tchanged = true;\n\tspin_unlock_bh(&sc->chan_lock);\n\n\tif (!changed)\n\t\tgoto out;\n\n\tath9k_cancel_pending_offchannel(sc);\n\n\tgo_ctx = ath_is_go_chanctx_present(sc);\n\n\tif (go_ctx) {\n\t\t \n\t\tspin_lock_bh(&sc->chan_lock);\n\t\tsc->sched.mgd_prepare_tx = true;\n\t\tcur_conf = &go_ctx->beacon;\n\t\tbeacon_int = TU_TO_USEC(cur_conf->beacon_interval);\n\t\tspin_unlock_bh(&sc->chan_lock);\n\n\t\ttimeout = usecs_to_jiffies(beacon_int * 2);\n\t\tinit_completion(&sc->go_beacon);\n\n\t\tmutex_unlock(&sc->mutex);\n\n\t\tif (wait_for_completion_timeout(&sc->go_beacon,\n\t\t\t\t\t\ttimeout) == 0) {\n\t\t\tath_dbg(common, CHAN_CTX,\n\t\t\t\t\"Failed to send new NoA\\n\");\n\n\t\t\tspin_lock_bh(&sc->chan_lock);\n\t\t\tsc->sched.mgd_prepare_tx = false;\n\t\t\tspin_unlock_bh(&sc->chan_lock);\n\t\t}\n\n\t\tmutex_lock(&sc->mutex);\n\t}\n\n\tath_dbg(common, CHAN_CTX,\n\t\t\"%s: Set chanctx state to FORCE_ACTIVE for vif: %pM\\n\",\n\t\t__func__, vif->addr);\n\n\tspin_lock_bh(&sc->chan_lock);\n\tsc->next_chan = avp->chanctx;\n\tsc->sched.state = ATH_CHANCTX_STATE_FORCE_ACTIVE;\n\tspin_unlock_bh(&sc->chan_lock);\n\n\tath_chanctx_set_next(sc, true);\nout:\n\tmutex_unlock(&sc->mutex);\n}\n\nvoid ath9k_fill_chanctx_ops(void)\n{\n\tif (!ath9k_is_chanctx_enabled())\n\t\treturn;\n\n\tath9k_ops.hw_scan                  = ath9k_hw_scan;\n\tath9k_ops.cancel_hw_scan           = ath9k_cancel_hw_scan;\n\tath9k_ops.remain_on_channel        = ath9k_remain_on_channel;\n\tath9k_ops.cancel_remain_on_channel = ath9k_cancel_remain_on_channel;\n\tath9k_ops.add_chanctx              = ath9k_add_chanctx;\n\tath9k_ops.remove_chanctx           = ath9k_remove_chanctx;\n\tath9k_ops.change_chanctx           = ath9k_change_chanctx;\n\tath9k_ops.assign_vif_chanctx       = ath9k_assign_vif_chanctx;\n\tath9k_ops.unassign_vif_chanctx     = ath9k_unassign_vif_chanctx;\n\tath9k_ops.mgd_prepare_tx           = ath9k_mgd_prepare_tx;\n}\n\n#endif\n\nstatic int ath9k_get_txpower(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t     int *dbm)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_vif *avp = (void *)vif->drv_priv;\n\n\tmutex_lock(&sc->mutex);\n\tif (avp->chanctx)\n\t\t*dbm = avp->chanctx->cur_txpower;\n\telse\n\t\t*dbm = sc->cur_chan->cur_txpower;\n\tmutex_unlock(&sc->mutex);\n\n\t*dbm /= 2;\n\n\treturn 0;\n}\n\nstruct ieee80211_ops ath9k_ops = {\n\t.tx \t\t    = ath9k_tx,\n\t.start \t\t    = ath9k_start,\n\t.stop \t\t    = ath9k_stop,\n\t.add_interface \t    = ath9k_add_interface,\n\t.change_interface   = ath9k_change_interface,\n\t.remove_interface   = ath9k_remove_interface,\n\t.config \t    = ath9k_config,\n\t.configure_filter   = ath9k_configure_filter,\n\t.sta_state          = ath9k_sta_state,\n\t.sta_notify         = ath9k_sta_notify,\n\t.conf_tx \t    = ath9k_conf_tx,\n\t.bss_info_changed   = ath9k_bss_info_changed,\n\t.set_key            = ath9k_set_key,\n\t.get_tsf \t    = ath9k_get_tsf,\n\t.set_tsf \t    = ath9k_set_tsf,\n\t.reset_tsf \t    = ath9k_reset_tsf,\n\t.ampdu_action       = ath9k_ampdu_action,\n\t.get_survey\t    = ath9k_get_survey,\n\t.rfkill_poll        = ath9k_rfkill_poll_state,\n\t.set_coverage_class = ath9k_set_coverage_class,\n\t.flush\t\t    = ath9k_flush,\n\t.tx_frames_pending  = ath9k_tx_frames_pending,\n\t.tx_last_beacon     = ath9k_tx_last_beacon,\n\t.release_buffered_frames = ath9k_release_buffered_frames,\n\t.get_stats\t    = ath9k_get_stats,\n\t.set_antenna\t    = ath9k_set_antenna,\n\t.get_antenna\t    = ath9k_get_antenna,\n\n#ifdef CONFIG_ATH9K_WOW\n\t.suspend\t    = ath9k_suspend,\n\t.resume\t\t    = ath9k_resume,\n\t.set_wakeup\t    = ath9k_set_wakeup,\n#endif\n\n#ifdef CONFIG_ATH9K_DEBUGFS\n\t.get_et_sset_count  = ath9k_get_et_sset_count,\n\t.get_et_stats       = ath9k_get_et_stats,\n\t.get_et_strings     = ath9k_get_et_strings,\n#endif\n\n#if defined(CONFIG_MAC80211_DEBUGFS) && defined(CONFIG_ATH9K_STATION_STATISTICS)\n\t.sta_add_debugfs    = ath9k_sta_add_debugfs,\n#endif\n\t.sw_scan_start\t    = ath9k_sw_scan_start,\n\t.sw_scan_complete   = ath9k_sw_scan_complete,\n\t.get_txpower        = ath9k_get_txpower,\n\t.wake_tx_queue      = ath9k_wake_tx_queue,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}