{
  "module_name": "eeprom_def.c",
  "hash_id": "9cac100c80d44dd03254e309b5f58d856dd0e0ed6fe7357bfbc55878438dc27a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/eeprom_def.c",
  "human_readable_source": " \n\n#include <asm/unaligned.h>\n#include \"hw.h\"\n#include \"ar9002_phy.h\"\n\nstatic void ath9k_get_txgain_index(struct ath_hw *ah,\n\t\tstruct ath9k_channel *chan,\n\t\tstruct calDataPerFreqOpLoop *rawDatasetOpLoop,\n\t\tu8 *calChans,  u16 availPiers, u8 *pwr, u8 *pcdacIdx)\n{\n\tu8 pcdac, i = 0;\n\tu16 idxL = 0, idxR = 0, numPiers;\n\tbool match;\n\tstruct chan_centers centers;\n\n\tath9k_hw_get_channel_centers(ah, chan, &centers);\n\n\tfor (numPiers = 0; numPiers < availPiers; numPiers++)\n\t\tif (calChans[numPiers] == AR5416_BCHAN_UNUSED)\n\t\t\tbreak;\n\n\tmatch = ath9k_hw_get_lower_upper_index(\n\t\t\t(u8)FREQ2FBIN(centers.synth_center, IS_CHAN_2GHZ(chan)),\n\t\t\tcalChans, numPiers, &idxL, &idxR);\n\tif (match) {\n\t\tpcdac = rawDatasetOpLoop[idxL].pcdac[0][0];\n\t\t*pwr = rawDatasetOpLoop[idxL].pwrPdg[0][0];\n\t} else {\n\t\tpcdac = rawDatasetOpLoop[idxR].pcdac[0][0];\n\t\t*pwr = (rawDatasetOpLoop[idxL].pwrPdg[0][0] +\n\t\t\t\trawDatasetOpLoop[idxR].pwrPdg[0][0])/2;\n\t}\n\n\twhile (pcdac > ah->originalGain[i] &&\n\t\t\ti < (AR9280_TX_GAIN_TABLE_SIZE - 1))\n\t\ti++;\n\n\t*pcdacIdx = i;\n}\n\nstatic void ath9k_olc_get_pdadcs(struct ath_hw *ah,\n\t\t\t\tu32 initTxGain,\n\t\t\t\tint txPower,\n\t\t\t\tu8 *pPDADCValues)\n{\n\tu32 i;\n\tu32 offset;\n\n\tREG_RMW_FIELD(ah, AR_PHY_TX_PWRCTRL6_0,\n\t\t\tAR_PHY_TX_PWRCTRL_ERR_EST_MODE, 3);\n\tREG_RMW_FIELD(ah, AR_PHY_TX_PWRCTRL6_1,\n\t\t\tAR_PHY_TX_PWRCTRL_ERR_EST_MODE, 3);\n\n\tREG_RMW_FIELD(ah, AR_PHY_TX_PWRCTRL7,\n\t\t\tAR_PHY_TX_PWRCTRL_INIT_TX_GAIN, initTxGain);\n\n\toffset = txPower;\n\tfor (i = 0; i < AR5416_NUM_PDADC_VALUES; i++)\n\t\tif (i < offset)\n\t\t\tpPDADCValues[i] = 0x0;\n\t\telse\n\t\t\tpPDADCValues[i] = 0xFF;\n}\n\nstatic int ath9k_hw_def_get_eeprom_ver(struct ath_hw *ah)\n{\n\tu16 version = le16_to_cpu(ah->eeprom.def.baseEepHeader.version);\n\n\treturn (version & AR5416_EEP_VER_MAJOR_MASK) >>\n\t\tAR5416_EEP_VER_MAJOR_SHIFT;\n}\n\nstatic int ath9k_hw_def_get_eeprom_rev(struct ath_hw *ah)\n{\n\tu16 version = le16_to_cpu(ah->eeprom.def.baseEepHeader.version);\n\n\treturn version & AR5416_EEP_VER_MINOR_MASK;\n}\n\n#define SIZE_EEPROM_DEF (sizeof(struct ar5416_eeprom_def) / sizeof(u16))\n\nstatic bool __ath9k_hw_def_fill_eeprom(struct ath_hw *ah)\n{\n\tu16 *eep_data = (u16 *)&ah->eeprom.def;\n\tint addr, ar5416_eep_start_loc = 0x100;\n\n\tfor (addr = 0; addr < SIZE_EEPROM_DEF; addr++) {\n\t\tif (!ath9k_hw_nvram_read(ah, addr + ar5416_eep_start_loc,\n\t\t\t\t\t eep_data))\n\t\t\treturn false;\n\t\teep_data++;\n\t}\n\treturn true;\n}\n\nstatic bool __ath9k_hw_usb_def_fill_eeprom(struct ath_hw *ah)\n{\n\tu16 *eep_data = (u16 *)&ah->eeprom.def;\n\n\tath9k_hw_usb_gen_fill_eeprom(ah, eep_data,\n\t\t\t\t     0x100, SIZE_EEPROM_DEF);\n\treturn true;\n}\n\nstatic bool ath9k_hw_def_fill_eeprom(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tif (!ath9k_hw_use_flash(ah)) {\n\t\tath_dbg(common, EEPROM, \"Reading from EEPROM, not flash\\n\");\n\t}\n\n\tif (common->bus_ops->ath_bus_type == ATH_USB)\n\t\treturn __ath9k_hw_usb_def_fill_eeprom(ah);\n\telse\n\t\treturn __ath9k_hw_def_fill_eeprom(ah);\n}\n\n#ifdef CONFIG_ATH9K_COMMON_DEBUG\nstatic u32 ath9k_def_dump_modal_eeprom(char *buf, u32 len, u32 size,\n\t\t\t\t       struct modal_eep_header *modal_hdr)\n{\n\tPR_EEP(\"Chain0 Ant. Control\", le16_to_cpu(modal_hdr->antCtrlChain[0]));\n\tPR_EEP(\"Chain1 Ant. Control\", le16_to_cpu(modal_hdr->antCtrlChain[1]));\n\tPR_EEP(\"Chain2 Ant. Control\", le16_to_cpu(modal_hdr->antCtrlChain[2]));\n\tPR_EEP(\"Ant. Common Control\", le32_to_cpu(modal_hdr->antCtrlCommon));\n\tPR_EEP(\"Chain0 Ant. Gain\", modal_hdr->antennaGainCh[0]);\n\tPR_EEP(\"Chain1 Ant. Gain\", modal_hdr->antennaGainCh[1]);\n\tPR_EEP(\"Chain2 Ant. Gain\", modal_hdr->antennaGainCh[2]);\n\tPR_EEP(\"Switch Settle\", modal_hdr->switchSettling);\n\tPR_EEP(\"Chain0 TxRxAtten\", modal_hdr->txRxAttenCh[0]);\n\tPR_EEP(\"Chain1 TxRxAtten\", modal_hdr->txRxAttenCh[1]);\n\tPR_EEP(\"Chain2 TxRxAtten\", modal_hdr->txRxAttenCh[2]);\n\tPR_EEP(\"Chain0 RxTxMargin\", modal_hdr->rxTxMarginCh[0]);\n\tPR_EEP(\"Chain1 RxTxMargin\", modal_hdr->rxTxMarginCh[1]);\n\tPR_EEP(\"Chain2 RxTxMargin\", modal_hdr->rxTxMarginCh[2]);\n\tPR_EEP(\"ADC Desired size\", modal_hdr->adcDesiredSize);\n\tPR_EEP(\"PGA Desired size\", modal_hdr->pgaDesiredSize);\n\tPR_EEP(\"Chain0 xlna Gain\", modal_hdr->xlnaGainCh[0]);\n\tPR_EEP(\"Chain1 xlna Gain\", modal_hdr->xlnaGainCh[1]);\n\tPR_EEP(\"Chain2 xlna Gain\", modal_hdr->xlnaGainCh[2]);\n\tPR_EEP(\"txEndToXpaOff\", modal_hdr->txEndToXpaOff);\n\tPR_EEP(\"txEndToRxOn\", modal_hdr->txEndToRxOn);\n\tPR_EEP(\"txFrameToXpaOn\", modal_hdr->txFrameToXpaOn);\n\tPR_EEP(\"CCA Threshold)\", modal_hdr->thresh62);\n\tPR_EEP(\"Chain0 NF Threshold\", modal_hdr->noiseFloorThreshCh[0]);\n\tPR_EEP(\"Chain1 NF Threshold\", modal_hdr->noiseFloorThreshCh[1]);\n\tPR_EEP(\"Chain2 NF Threshold\", modal_hdr->noiseFloorThreshCh[2]);\n\tPR_EEP(\"xpdGain\", modal_hdr->xpdGain);\n\tPR_EEP(\"External PD\", modal_hdr->xpd);\n\tPR_EEP(\"Chain0 I Coefficient\", modal_hdr->iqCalICh[0]);\n\tPR_EEP(\"Chain1 I Coefficient\", modal_hdr->iqCalICh[1]);\n\tPR_EEP(\"Chain2 I Coefficient\", modal_hdr->iqCalICh[2]);\n\tPR_EEP(\"Chain0 Q Coefficient\", modal_hdr->iqCalQCh[0]);\n\tPR_EEP(\"Chain1 Q Coefficient\", modal_hdr->iqCalQCh[1]);\n\tPR_EEP(\"Chain2 Q Coefficient\", modal_hdr->iqCalQCh[2]);\n\tPR_EEP(\"pdGainOverlap\", modal_hdr->pdGainOverlap);\n\tPR_EEP(\"Chain0 OutputBias\", modal_hdr->ob);\n\tPR_EEP(\"Chain0 DriverBias\", modal_hdr->db);\n\tPR_EEP(\"xPA Bias Level\", modal_hdr->xpaBiasLvl);\n\tPR_EEP(\"2chain pwr decrease\", modal_hdr->pwrDecreaseFor2Chain);\n\tPR_EEP(\"3chain pwr decrease\", modal_hdr->pwrDecreaseFor3Chain);\n\tPR_EEP(\"txFrameToDataStart\", modal_hdr->txFrameToDataStart);\n\tPR_EEP(\"txFrameToPaOn\", modal_hdr->txFrameToPaOn);\n\tPR_EEP(\"HT40 Power Inc.\", modal_hdr->ht40PowerIncForPdadc);\n\tPR_EEP(\"Chain0 bswAtten\", modal_hdr->bswAtten[0]);\n\tPR_EEP(\"Chain1 bswAtten\", modal_hdr->bswAtten[1]);\n\tPR_EEP(\"Chain2 bswAtten\", modal_hdr->bswAtten[2]);\n\tPR_EEP(\"Chain0 bswMargin\", modal_hdr->bswMargin[0]);\n\tPR_EEP(\"Chain1 bswMargin\", modal_hdr->bswMargin[1]);\n\tPR_EEP(\"Chain2 bswMargin\", modal_hdr->bswMargin[2]);\n\tPR_EEP(\"HT40 Switch Settle\", modal_hdr->swSettleHt40);\n\tPR_EEP(\"Chain0 xatten2Db\", modal_hdr->xatten2Db[0]);\n\tPR_EEP(\"Chain1 xatten2Db\", modal_hdr->xatten2Db[1]);\n\tPR_EEP(\"Chain2 xatten2Db\", modal_hdr->xatten2Db[2]);\n\tPR_EEP(\"Chain0 xatten2Margin\", modal_hdr->xatten2Margin[0]);\n\tPR_EEP(\"Chain1 xatten2Margin\", modal_hdr->xatten2Margin[1]);\n\tPR_EEP(\"Chain2 xatten2Margin\", modal_hdr->xatten2Margin[2]);\n\tPR_EEP(\"Chain1 OutputBias\", modal_hdr->ob_ch1);\n\tPR_EEP(\"Chain1 DriverBias\", modal_hdr->db_ch1);\n\tPR_EEP(\"LNA Control\", modal_hdr->lna_ctl);\n\tPR_EEP(\"XPA Bias Freq0\", le16_to_cpu(modal_hdr->xpaBiasLvlFreq[0]));\n\tPR_EEP(\"XPA Bias Freq1\", le16_to_cpu(modal_hdr->xpaBiasLvlFreq[1]));\n\tPR_EEP(\"XPA Bias Freq2\", le16_to_cpu(modal_hdr->xpaBiasLvlFreq[2]));\n\n\treturn len;\n}\n\nstatic u32 ath9k_hw_def_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,\n\t\t\t\t    u8 *buf, u32 len, u32 size)\n{\n\tstruct ar5416_eeprom_def *eep = &ah->eeprom.def;\n\tstruct base_eep_header *pBase = &eep->baseEepHeader;\n\tu32 binBuildNumber = le32_to_cpu(pBase->binBuildNumber);\n\n\tif (!dump_base_hdr) {\n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t \"%20s :\\n\", \"2GHz modal Header\");\n\t\tlen = ath9k_def_dump_modal_eeprom(buf, len, size,\n\t\t\t\t\t\t   &eep->modalHeader[0]);\n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t \"%20s :\\n\", \"5GHz modal Header\");\n\t\tlen = ath9k_def_dump_modal_eeprom(buf, len, size,\n\t\t\t\t\t\t   &eep->modalHeader[1]);\n\t\tgoto out;\n\t}\n\n\tPR_EEP(\"Major Version\", ath9k_hw_def_get_eeprom_ver(ah));\n\tPR_EEP(\"Minor Version\", ath9k_hw_def_get_eeprom_rev(ah));\n\tPR_EEP(\"Checksum\", le16_to_cpu(pBase->checksum));\n\tPR_EEP(\"Length\", le16_to_cpu(pBase->length));\n\tPR_EEP(\"RegDomain1\", le16_to_cpu(pBase->regDmn[0]));\n\tPR_EEP(\"RegDomain2\", le16_to_cpu(pBase->regDmn[1]));\n\tPR_EEP(\"TX Mask\", pBase->txMask);\n\tPR_EEP(\"RX Mask\", pBase->rxMask);\n\tPR_EEP(\"Allow 5GHz\", !!(pBase->opCapFlags & AR5416_OPFLAGS_11A));\n\tPR_EEP(\"Allow 2GHz\", !!(pBase->opCapFlags & AR5416_OPFLAGS_11G));\n\tPR_EEP(\"Disable 2GHz HT20\", !!(pBase->opCapFlags &\n\t\t\t\t\tAR5416_OPFLAGS_N_2G_HT20));\n\tPR_EEP(\"Disable 2GHz HT40\", !!(pBase->opCapFlags &\n\t\t\t\t\tAR5416_OPFLAGS_N_2G_HT40));\n\tPR_EEP(\"Disable 5Ghz HT20\", !!(pBase->opCapFlags &\n\t\t\t\t\tAR5416_OPFLAGS_N_5G_HT20));\n\tPR_EEP(\"Disable 5Ghz HT40\", !!(pBase->opCapFlags &\n\t\t\t\t\tAR5416_OPFLAGS_N_5G_HT40));\n\tPR_EEP(\"Big Endian\", !!(pBase->eepMisc & AR5416_EEPMISC_BIG_ENDIAN));\n\tPR_EEP(\"Cal Bin Major Ver\", (binBuildNumber >> 24) & 0xFF);\n\tPR_EEP(\"Cal Bin Minor Ver\", (binBuildNumber >> 16) & 0xFF);\n\tPR_EEP(\"Cal Bin Build\", (binBuildNumber >> 8) & 0xFF);\n\tPR_EEP(\"OpenLoop Power Ctrl\", pBase->openLoopPwrCntl);\n\n\tlen += scnprintf(buf + len, size - len, \"%20s : %pM\\n\", \"MacAddress\",\n\t\t\t pBase->macAddr);\n\nout:\n\tif (len > size)\n\t\tlen = size;\n\n\treturn len;\n}\n#else\nstatic u32 ath9k_hw_def_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,\n\t\t\t\t    u8 *buf, u32 len, u32 size)\n{\n\treturn 0;\n}\n#endif\n\nstatic int ath9k_hw_def_check_eeprom(struct ath_hw *ah)\n{\n\tstruct ar5416_eeprom_def *eep = &ah->eeprom.def;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tu32 el;\n\tbool need_swap;\n\tint i, err;\n\n\terr = ath9k_hw_nvram_swap_data(ah, &need_swap, SIZE_EEPROM_DEF);\n\tif (err)\n\t\treturn err;\n\n\tif (need_swap)\n\t\tel = swab16((__force u16)eep->baseEepHeader.length);\n\telse\n\t\tel = le16_to_cpu(eep->baseEepHeader.length);\n\n\tel = min(el / sizeof(u16), SIZE_EEPROM_DEF);\n\tif (!ath9k_hw_nvram_validate_checksum(ah, el))\n\t\treturn -EINVAL;\n\n\tif (need_swap) {\n\t\tu32 j;\n\n\t\tEEPROM_FIELD_SWAB16(eep->baseEepHeader.length);\n\t\tEEPROM_FIELD_SWAB16(eep->baseEepHeader.checksum);\n\t\tEEPROM_FIELD_SWAB16(eep->baseEepHeader.version);\n\t\tEEPROM_FIELD_SWAB16(eep->baseEepHeader.regDmn[0]);\n\t\tEEPROM_FIELD_SWAB16(eep->baseEepHeader.regDmn[1]);\n\t\tEEPROM_FIELD_SWAB16(eep->baseEepHeader.rfSilent);\n\t\tEEPROM_FIELD_SWAB16(eep->baseEepHeader.blueToothOptions);\n\t\tEEPROM_FIELD_SWAB16(eep->baseEepHeader.deviceCap);\n\n\t\tfor (j = 0; j < ARRAY_SIZE(eep->modalHeader); j++) {\n\t\t\tstruct modal_eep_header *pModal =\n\t\t\t\t&eep->modalHeader[j];\n\t\t\tEEPROM_FIELD_SWAB32(pModal->antCtrlCommon);\n\n\t\t\tfor (i = 0; i < AR5416_MAX_CHAINS; i++)\n\t\t\t\tEEPROM_FIELD_SWAB32(pModal->antCtrlChain[i]);\n\n\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t\tEEPROM_FIELD_SWAB16(pModal->xpaBiasLvlFreq[i]);\n\n\t\t\tfor (i = 0; i < AR_EEPROM_MODAL_SPURS; i++)\n\t\t\t\tEEPROM_FIELD_SWAB16(\n\t\t\t\t\tpModal->spurChans[i].spurChan);\n\t\t}\n\t}\n\n\tif (!ath9k_hw_nvram_check_version(ah, AR5416_EEP_VER,\n\t    AR5416_EEP_NO_BACK_VER))\n\t\treturn -EINVAL;\n\n\t \n\tif ((ah->hw_version.devid == AR9280_DEVID_PCI) &&\n\t    ((le16_to_cpu(eep->baseEepHeader.version) & 0xff) > 0x0a) &&\n\t    (eep->baseEepHeader.pwdclkind == 0))\n\t\tah->need_an_top2_fixup = true;\n\n\tif ((common->bus_ops->ath_bus_type == ATH_USB) &&\n\t    (AR_SREV_9280(ah)))\n\t\teep->modalHeader[0].xpaBiasLvl = 0;\n\n\treturn 0;\n}\n\n#undef SIZE_EEPROM_DEF\n\nstatic u32 ath9k_hw_def_get_eeprom(struct ath_hw *ah,\n\t\t\t\t   enum eeprom_param param)\n{\n\tstruct ar5416_eeprom_def *eep = &ah->eeprom.def;\n\tstruct modal_eep_header *pModal = eep->modalHeader;\n\tstruct base_eep_header *pBase = &eep->baseEepHeader;\n\tint band = 0;\n\n\tswitch (param) {\n\tcase EEP_NFTHRESH_5:\n\t\treturn pModal[0].noiseFloorThreshCh[0];\n\tcase EEP_NFTHRESH_2:\n\t\treturn pModal[1].noiseFloorThreshCh[0];\n\tcase EEP_MAC_LSW:\n\t\treturn get_unaligned_be16(pBase->macAddr);\n\tcase EEP_MAC_MID:\n\t\treturn get_unaligned_be16(pBase->macAddr + 2);\n\tcase EEP_MAC_MSW:\n\t\treturn get_unaligned_be16(pBase->macAddr + 4);\n\tcase EEP_REG_0:\n\t\treturn le16_to_cpu(pBase->regDmn[0]);\n\tcase EEP_OP_CAP:\n\t\treturn le16_to_cpu(pBase->deviceCap);\n\tcase EEP_OP_MODE:\n\t\treturn pBase->opCapFlags;\n\tcase EEP_RF_SILENT:\n\t\treturn le16_to_cpu(pBase->rfSilent);\n\tcase EEP_OB_5:\n\t\treturn pModal[0].ob;\n\tcase EEP_DB_5:\n\t\treturn pModal[0].db;\n\tcase EEP_OB_2:\n\t\treturn pModal[1].ob;\n\tcase EEP_DB_2:\n\t\treturn pModal[1].db;\n\tcase EEP_TX_MASK:\n\t\treturn pBase->txMask;\n\tcase EEP_RX_MASK:\n\t\treturn pBase->rxMask;\n\tcase EEP_FSTCLK_5G:\n\t\treturn pBase->fastClk5g;\n\tcase EEP_RXGAIN_TYPE:\n\t\treturn pBase->rxGainType;\n\tcase EEP_TXGAIN_TYPE:\n\t\treturn pBase->txGainType;\n\tcase EEP_OL_PWRCTRL:\n\t\tif (ath9k_hw_def_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_19)\n\t\t\treturn pBase->openLoopPwrCntl ? true : false;\n\t\telse\n\t\t\treturn false;\n\tcase EEP_RC_CHAIN_MASK:\n\t\tif (ath9k_hw_def_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_19)\n\t\t\treturn pBase->rcChainMask;\n\t\telse\n\t\t\treturn 0;\n\tcase EEP_DAC_HPWR_5G:\n\t\tif (ath9k_hw_def_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_20)\n\t\t\treturn pBase->dacHiPwrMode_5G;\n\t\telse\n\t\t\treturn 0;\n\tcase EEP_FRAC_N_5G:\n\t\tif (ath9k_hw_def_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_22)\n\t\t\treturn pBase->frac_n_5g;\n\t\telse\n\t\t\treturn 0;\n\tcase EEP_PWR_TABLE_OFFSET:\n\t\tif (ath9k_hw_def_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_21)\n\t\t\treturn pBase->pwr_table_offset;\n\t\telse\n\t\t\treturn AR5416_PWR_TABLE_OFFSET_DB;\n\tcase EEP_ANTENNA_GAIN_2G:\n\t\tband = 1;\n\t\tfallthrough;\n\tcase EEP_ANTENNA_GAIN_5G:\n\t\treturn max_t(u8, max_t(u8,\n\t\t\tpModal[band].antennaGainCh[0],\n\t\t\tpModal[band].antennaGainCh[1]),\n\t\t\tpModal[band].antennaGainCh[2]);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void ath9k_hw_def_set_gain(struct ath_hw *ah,\n\t\t\t\t  struct modal_eep_header *pModal,\n\t\t\t\t  struct ar5416_eeprom_def *eep,\n\t\t\t\t  u8 txRxAttenLocal, int regChainOffset, int i)\n{\n\tENABLE_REG_RMW_BUFFER(ah);\n\tif (ath9k_hw_def_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_3) {\n\t\ttxRxAttenLocal = pModal->txRxAttenCh[i];\n\n\t\tif (AR_SREV_9280_20_OR_LATER(ah)) {\n\t\t\tREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ + regChainOffset,\n\t\t\t      AR_PHY_GAIN_2GHZ_XATTEN1_MARGIN,\n\t\t\t      pModal->bswMargin[i]);\n\t\t\tREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ + regChainOffset,\n\t\t\t      AR_PHY_GAIN_2GHZ_XATTEN1_DB,\n\t\t\t      pModal->bswAtten[i]);\n\t\t\tREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ + regChainOffset,\n\t\t\t      AR_PHY_GAIN_2GHZ_XATTEN2_MARGIN,\n\t\t\t      pModal->xatten2Margin[i]);\n\t\t\tREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ + regChainOffset,\n\t\t\t      AR_PHY_GAIN_2GHZ_XATTEN2_DB,\n\t\t\t      pModal->xatten2Db[i]);\n\t\t} else {\n\t\t\tREG_RMW(ah, AR_PHY_GAIN_2GHZ + regChainOffset,\n\t\t\t\tSM(pModal-> bswMargin[i], AR_PHY_GAIN_2GHZ_BSW_MARGIN),\n\t\t\t\tAR_PHY_GAIN_2GHZ_BSW_MARGIN);\n\t\t\tREG_RMW(ah, AR_PHY_GAIN_2GHZ + regChainOffset,\n\t\t\t\tSM(pModal->bswAtten[i], AR_PHY_GAIN_2GHZ_BSW_ATTEN),\n\t\t\t\tAR_PHY_GAIN_2GHZ_BSW_ATTEN);\n\t\t}\n\t}\n\n\tif (AR_SREV_9280_20_OR_LATER(ah)) {\n\t\tREG_RMW_FIELD(ah,\n\t\t      AR_PHY_RXGAIN + regChainOffset,\n\t\t      AR9280_PHY_RXGAIN_TXRX_ATTEN, txRxAttenLocal);\n\t\tREG_RMW_FIELD(ah,\n\t\t      AR_PHY_RXGAIN + regChainOffset,\n\t\t      AR9280_PHY_RXGAIN_TXRX_MARGIN, pModal->rxTxMarginCh[i]);\n\t} else {\n\t\tREG_RMW(ah, AR_PHY_RXGAIN + regChainOffset,\n\t\t\tSM(txRxAttenLocal, AR_PHY_RXGAIN_TXRX_ATTEN),\n\t\t\tAR_PHY_RXGAIN_TXRX_ATTEN);\n\t\tREG_RMW(ah, AR_PHY_GAIN_2GHZ + regChainOffset,\n\t\t\tSM(pModal->rxTxMarginCh[i], AR_PHY_GAIN_2GHZ_RXTX_MARGIN),\n\t\t\tAR_PHY_GAIN_2GHZ_RXTX_MARGIN);\n\t}\n\tREG_RMW_BUFFER_FLUSH(ah);\n}\n\nstatic void ath9k_hw_def_set_board_values(struct ath_hw *ah,\n\t\t\t\t\t  struct ath9k_channel *chan)\n{\n\tstruct modal_eep_header *pModal;\n\tstruct ar5416_eeprom_def *eep = &ah->eeprom.def;\n\tint i, regChainOffset;\n\tu8 txRxAttenLocal;\n\tu32 antCtrlCommon;\n\n\tpModal = &(eep->modalHeader[IS_CHAN_2GHZ(chan)]);\n\ttxRxAttenLocal = IS_CHAN_2GHZ(chan) ? 23 : 44;\n\tantCtrlCommon = le32_to_cpu(pModal->antCtrlCommon);\n\n\tREG_WRITE(ah, AR_PHY_SWITCH_COM, antCtrlCommon & 0xffff);\n\n\tfor (i = 0; i < AR5416_MAX_CHAINS; i++) {\n\t\tif (AR_SREV_9280(ah)) {\n\t\t\tif (i >= 2)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif ((ah->rxchainmask == 5 || ah->txchainmask == 5) && (i != 0))\n\t\t\tregChainOffset = (i == 1) ? 0x2000 : 0x1000;\n\t\telse\n\t\t\tregChainOffset = i * 0x1000;\n\n\t\tREG_WRITE(ah, AR_PHY_SWITCH_CHAIN_0 + regChainOffset,\n\t\t\t  le32_to_cpu(pModal->antCtrlChain[i]));\n\n\t\tREG_WRITE(ah, AR_PHY_TIMING_CTRL4(0) + regChainOffset,\n\t\t\t  (REG_READ(ah, AR_PHY_TIMING_CTRL4(0) + regChainOffset) &\n\t\t\t   ~(AR_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF |\n\t\t\t     AR_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF)) |\n\t\t\t  SM(pModal->iqCalICh[i],\n\t\t\t     AR_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF) |\n\t\t\t  SM(pModal->iqCalQCh[i],\n\t\t\t     AR_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF));\n\n\t\tath9k_hw_def_set_gain(ah, pModal, eep, txRxAttenLocal,\n\t\t\t\t      regChainOffset, i);\n\t}\n\n\tif (AR_SREV_9280_20_OR_LATER(ah)) {\n\t\tif (IS_CHAN_2GHZ(chan)) {\n\t\t\tath9k_hw_analog_shift_rmw(ah, AR_AN_RF2G1_CH0,\n\t\t\t\t\t\t  AR_AN_RF2G1_CH0_OB,\n\t\t\t\t\t\t  AR_AN_RF2G1_CH0_OB_S,\n\t\t\t\t\t\t  pModal->ob);\n\t\t\tath9k_hw_analog_shift_rmw(ah, AR_AN_RF2G1_CH0,\n\t\t\t\t\t\t  AR_AN_RF2G1_CH0_DB,\n\t\t\t\t\t\t  AR_AN_RF2G1_CH0_DB_S,\n\t\t\t\t\t\t  pModal->db);\n\t\t\tath9k_hw_analog_shift_rmw(ah, AR_AN_RF2G1_CH1,\n\t\t\t\t\t\t  AR_AN_RF2G1_CH1_OB,\n\t\t\t\t\t\t  AR_AN_RF2G1_CH1_OB_S,\n\t\t\t\t\t\t  pModal->ob_ch1);\n\t\t\tath9k_hw_analog_shift_rmw(ah, AR_AN_RF2G1_CH1,\n\t\t\t\t\t\t  AR_AN_RF2G1_CH1_DB,\n\t\t\t\t\t\t  AR_AN_RF2G1_CH1_DB_S,\n\t\t\t\t\t\t  pModal->db_ch1);\n\t\t} else {\n\t\t\tath9k_hw_analog_shift_rmw(ah, AR_AN_RF5G1_CH0,\n\t\t\t\t\t\t  AR_AN_RF5G1_CH0_OB5,\n\t\t\t\t\t\t  AR_AN_RF5G1_CH0_OB5_S,\n\t\t\t\t\t\t  pModal->ob);\n\t\t\tath9k_hw_analog_shift_rmw(ah, AR_AN_RF5G1_CH0,\n\t\t\t\t\t\t  AR_AN_RF5G1_CH0_DB5,\n\t\t\t\t\t\t  AR_AN_RF5G1_CH0_DB5_S,\n\t\t\t\t\t\t  pModal->db);\n\t\t\tath9k_hw_analog_shift_rmw(ah, AR_AN_RF5G1_CH1,\n\t\t\t\t\t\t  AR_AN_RF5G1_CH1_OB5,\n\t\t\t\t\t\t  AR_AN_RF5G1_CH1_OB5_S,\n\t\t\t\t\t\t  pModal->ob_ch1);\n\t\t\tath9k_hw_analog_shift_rmw(ah, AR_AN_RF5G1_CH1,\n\t\t\t\t\t\t  AR_AN_RF5G1_CH1_DB5,\n\t\t\t\t\t\t  AR_AN_RF5G1_CH1_DB5_S,\n\t\t\t\t\t\t  pModal->db_ch1);\n\t\t}\n\t\tath9k_hw_analog_shift_rmw(ah, AR_AN_TOP2,\n\t\t\t\t\t  AR_AN_TOP2_XPABIAS_LVL,\n\t\t\t\t\t  AR_AN_TOP2_XPABIAS_LVL_S,\n\t\t\t\t\t  pModal->xpaBiasLvl);\n\t\tath9k_hw_analog_shift_rmw(ah, AR_AN_TOP2,\n\t\t\t\t\t  AR_AN_TOP2_LOCALBIAS,\n\t\t\t\t\t  AR_AN_TOP2_LOCALBIAS_S,\n\t\t\t\t\t  !!(pModal->lna_ctl &\n\t\t\t\t\t     LNA_CTL_LOCAL_BIAS));\n\t\tREG_RMW_FIELD(ah, AR_PHY_XPA_CFG, AR_PHY_FORCE_XPA_CFG,\n\t\t\t      !!(pModal->lna_ctl & LNA_CTL_FORCE_XPA));\n\t}\n\n\tREG_RMW_FIELD(ah, AR_PHY_SETTLING, AR_PHY_SETTLING_SWITCH,\n\t\t      pModal->switchSettling);\n\tREG_RMW_FIELD(ah, AR_PHY_DESIRED_SZ, AR_PHY_DESIRED_SZ_ADC,\n\t\t      pModal->adcDesiredSize);\n\n\tif (!AR_SREV_9280_20_OR_LATER(ah))\n\t\tREG_RMW_FIELD(ah, AR_PHY_DESIRED_SZ,\n\t\t\t      AR_PHY_DESIRED_SZ_PGA,\n\t\t\t      pModal->pgaDesiredSize);\n\n\tREG_WRITE(ah, AR_PHY_RF_CTL4,\n\t\t  SM(pModal->txEndToXpaOff, AR_PHY_RF_CTL4_TX_END_XPAA_OFF)\n\t\t  | SM(pModal->txEndToXpaOff,\n\t\t       AR_PHY_RF_CTL4_TX_END_XPAB_OFF)\n\t\t  | SM(pModal->txFrameToXpaOn,\n\t\t       AR_PHY_RF_CTL4_FRAME_XPAA_ON)\n\t\t  | SM(pModal->txFrameToXpaOn,\n\t\t       AR_PHY_RF_CTL4_FRAME_XPAB_ON));\n\n\tREG_RMW_FIELD(ah, AR_PHY_RF_CTL3, AR_PHY_TX_END_TO_A2_RX_ON,\n\t\t      pModal->txEndToRxOn);\n\n\tif (AR_SREV_9280_20_OR_LATER(ah)) {\n\t\tREG_RMW_FIELD(ah, AR_PHY_CCA, AR9280_PHY_CCA_THRESH62,\n\t\t\t      pModal->thresh62);\n\t\tREG_RMW_FIELD(ah, AR_PHY_EXT_CCA0,\n\t\t\t      AR_PHY_EXT_CCA0_THRESH62,\n\t\t\t      pModal->thresh62);\n\t} else {\n\t\tREG_RMW_FIELD(ah, AR_PHY_CCA, AR_PHY_CCA_THRESH62,\n\t\t\t      pModal->thresh62);\n\t\tREG_RMW_FIELD(ah, AR_PHY_EXT_CCA,\n\t\t\t      AR_PHY_EXT_CCA_THRESH62,\n\t\t\t      pModal->thresh62);\n\t}\n\n\tif (ath9k_hw_def_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_2) {\n\t\tREG_RMW_FIELD(ah, AR_PHY_RF_CTL2,\n\t\t\t      AR_PHY_TX_END_DATA_START,\n\t\t\t      pModal->txFrameToDataStart);\n\t\tREG_RMW_FIELD(ah, AR_PHY_RF_CTL2, AR_PHY_TX_END_PA_ON,\n\t\t\t      pModal->txFrameToPaOn);\n\t}\n\n\tif (ath9k_hw_def_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_3) {\n\t\tif (IS_CHAN_HT40(chan))\n\t\t\tREG_RMW_FIELD(ah, AR_PHY_SETTLING,\n\t\t\t\t      AR_PHY_SETTLING_SWITCH,\n\t\t\t\t      pModal->swSettleHt40);\n\t}\n\n\tif (AR_SREV_9280_20_OR_LATER(ah) &&\n\t    ath9k_hw_def_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_19)\n\t\tREG_RMW_FIELD(ah, AR_PHY_CCK_TX_CTRL,\n\t\t\t      AR_PHY_CCK_TX_CTRL_TX_DAC_SCALE_CCK,\n\t\t\t      pModal->miscBits);\n\n\n\tif (AR_SREV_9280_20(ah) &&\n\t    ath9k_hw_def_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_20) {\n\t\tif (IS_CHAN_2GHZ(chan))\n\t\t\tREG_RMW_FIELD(ah, AR_AN_TOP1, AR_AN_TOP1_DACIPMODE,\n\t\t\t\t\teep->baseEepHeader.dacLpMode);\n\t\telse if (eep->baseEepHeader.dacHiPwrMode_5G)\n\t\t\tREG_RMW_FIELD(ah, AR_AN_TOP1, AR_AN_TOP1_DACIPMODE, 0);\n\t\telse\n\t\t\tREG_RMW_FIELD(ah, AR_AN_TOP1, AR_AN_TOP1_DACIPMODE,\n\t\t\t\t      eep->baseEepHeader.dacLpMode);\n\n\t\tudelay(100);\n\n\t\tREG_RMW_FIELD(ah, AR_PHY_FRAME_CTL, AR_PHY_FRAME_CTL_TX_CLIP,\n\t\t\t      pModal->miscBits >> 2);\n\n\t\tREG_RMW_FIELD(ah, AR_PHY_TX_PWRCTRL9,\n\t\t\t      AR_PHY_TX_DESIRED_SCALE_CCK,\n\t\t\t      eep->baseEepHeader.desiredScaleCCK);\n\t}\n}\n\nstatic void ath9k_hw_def_set_addac(struct ath_hw *ah,\n\t\t\t\t   struct ath9k_channel *chan)\n{\n#define XPA_LVL_FREQ(cnt) (le16_to_cpu(pModal->xpaBiasLvlFreq[cnt]))\n\tstruct modal_eep_header *pModal;\n\tstruct ar5416_eeprom_def *eep = &ah->eeprom.def;\n\tu8 biaslevel;\n\n\tif (ah->hw_version.macVersion != AR_SREV_VERSION_9160)\n\t\treturn;\n\n\tif (ah->eep_ops->get_eeprom_rev(ah) < AR5416_EEP_MINOR_VER_7)\n\t\treturn;\n\n\tpModal = &(eep->modalHeader[IS_CHAN_2GHZ(chan)]);\n\n\tif (pModal->xpaBiasLvl != 0xff) {\n\t\tbiaslevel = pModal->xpaBiasLvl;\n\t} else {\n\t\tu16 resetFreqBin, freqBin, freqCount = 0;\n\t\tstruct chan_centers centers;\n\n\t\tath9k_hw_get_channel_centers(ah, chan, &centers);\n\n\t\tresetFreqBin = FREQ2FBIN(centers.synth_center,\n\t\t\t\t\t IS_CHAN_2GHZ(chan));\n\t\tfreqBin = XPA_LVL_FREQ(0) & 0xff;\n\t\tbiaslevel = (u8) (XPA_LVL_FREQ(0) >> 14);\n\n\t\tfreqCount++;\n\n\t\twhile (freqCount < 3) {\n\t\t\tif (XPA_LVL_FREQ(freqCount) == 0x0)\n\t\t\t\tbreak;\n\n\t\t\tfreqBin = XPA_LVL_FREQ(freqCount) & 0xff;\n\t\t\tif (resetFreqBin >= freqBin)\n\t\t\t\tbiaslevel = (u8)(XPA_LVL_FREQ(freqCount) >> 14);\n\t\t\telse\n\t\t\t\tbreak;\n\t\t\tfreqCount++;\n\t\t}\n\t}\n\n\tif (IS_CHAN_2GHZ(chan)) {\n\t\tINI_RA(&ah->iniAddac, 7, 1) = (INI_RA(&ah->iniAddac,\n\t\t\t\t\t7, 1) & (~0x18)) | biaslevel << 3;\n\t} else {\n\t\tINI_RA(&ah->iniAddac, 6, 1) = (INI_RA(&ah->iniAddac,\n\t\t\t\t\t6, 1) & (~0xc0)) | biaslevel << 6;\n\t}\n#undef XPA_LVL_FREQ\n}\n\nstatic int16_t ath9k_change_gain_boundary_setting(struct ath_hw *ah,\n\t\t\t\tu16 *gb,\n\t\t\t\tu16 numXpdGain,\n\t\t\t\tu16 pdGainOverlap_t2,\n\t\t\t\tint8_t pwr_table_offset,\n\t\t\t\tint16_t *diff)\n\n{\n\tu16 k;\n\n\t \n\tif (AR_SREV_9280_20_OR_LATER(ah)) {\n\t\tu16 gb_limit;\n\n\t\tif (AR5416_PWR_TABLE_OFFSET_DB != pwr_table_offset) {\n\t\t\t \n\t\t\t*diff = (u16)(pwr_table_offset - AR5416_PWR_TABLE_OFFSET_DB);\n\t\t\t \n\t\t\t*diff *= 2;\n\t\t\t \n\t\t\tfor (k = 0; k < numXpdGain; k++)\n\t\t\t\tgb[k] = (u16)(gb[k] - *diff);\n\t\t}\n\t\t \n\t\tgb_limit = (u16)(MAX_RATE_POWER - pdGainOverlap_t2);\n\n\t\tfor (k = 0; k < numXpdGain; k++)\n\t\t\tgb[k] = (u16)min(gb_limit, gb[k]);\n\t}\n\n\treturn *diff;\n}\n\nstatic void ath9k_adjust_pdadc_values(struct ath_hw *ah,\n\t\t\t\t      int8_t pwr_table_offset,\n\t\t\t\t      int16_t diff,\n\t\t\t\t      u8 *pdadcValues)\n{\n#define NUM_PDADC(diff) (AR5416_NUM_PDADC_VALUES - diff)\n\tu16 k;\n\n\t \n\tif (AR_SREV_9280_20_OR_LATER(ah)) {\n\t\tif (AR5416_PWR_TABLE_OFFSET_DB != pwr_table_offset) {\n\t\t\t \n\t\t\tfor (k = 0; k < (u16)NUM_PDADC(diff); k++ ) {\n\t\t\t\tpdadcValues[k] = pdadcValues[k + diff];\n\t\t\t}\n\n\t\t\t \n\t\t\tfor (k = (u16)NUM_PDADC(diff); k < NUM_PDADC(0); k++) {\n\t\t\t\tpdadcValues[k] = pdadcValues[NUM_PDADC(diff)];\n\t\t\t}\n\t\t}\n\t}\n#undef NUM_PDADC\n}\n\nstatic void ath9k_hw_set_def_power_cal_table(struct ath_hw *ah,\n\t\t\t\t  struct ath9k_channel *chan)\n{\n#define SM_PD_GAIN(x) SM(0x38, AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_##x)\n#define SM_PDGAIN_B(x, y) \\\n\t\tSM((gainBoundaries[x]), AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_##y)\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ar5416_eeprom_def *pEepData = &ah->eeprom.def;\n\tstruct cal_data_per_freq *pRawDataset;\n\tu8 *pCalBChans = NULL;\n\tu16 pdGainOverlap_t2;\n\tstatic u8 pdadcValues[AR5416_NUM_PDADC_VALUES];\n\tu16 gainBoundaries[AR5416_PD_GAINS_IN_MASK];\n\tu16 numPiers, i, j;\n\tint16_t diff = 0;\n\tu16 numXpdGain, xpdMask;\n\tu16 xpdGainValues[AR5416_NUM_PD_GAINS] = { 0, 0, 0, 0 };\n\tu32 reg32, regOffset, regChainOffset;\n\tint16_t modalIdx;\n\tint8_t pwr_table_offset;\n\n\tmodalIdx = IS_CHAN_2GHZ(chan) ? 1 : 0;\n\txpdMask = pEepData->modalHeader[modalIdx].xpdGain;\n\n\tpwr_table_offset = ah->eep_ops->get_eeprom(ah, EEP_PWR_TABLE_OFFSET);\n\n\tif (ath9k_hw_def_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_2) {\n\t\tpdGainOverlap_t2 =\n\t\t\tpEepData->modalHeader[modalIdx].pdGainOverlap;\n\t} else {\n\t\tpdGainOverlap_t2 = (u16)(MS(REG_READ(ah, AR_PHY_TPCRG5),\n\t\t\t\t\t    AR_PHY_TPCRG5_PD_GAIN_OVERLAP));\n\t}\n\n\tif (IS_CHAN_2GHZ(chan)) {\n\t\tpCalBChans = pEepData->calFreqPier2G;\n\t\tnumPiers = AR5416_NUM_2G_CAL_PIERS;\n\t} else {\n\t\tpCalBChans = pEepData->calFreqPier5G;\n\t\tnumPiers = AR5416_NUM_5G_CAL_PIERS;\n\t}\n\n\tif (OLC_FOR_AR9280_20_LATER(ah) && IS_CHAN_2GHZ(chan)) {\n\t\tpRawDataset = pEepData->calPierData2G[0];\n\t\tah->initPDADC = ((struct calDataPerFreqOpLoop *)\n\t\t\t\t pRawDataset)->vpdPdg[0][0];\n\t}\n\n\tnumXpdGain = 0;\n\n\tfor (i = 1; i <= AR5416_PD_GAINS_IN_MASK; i++) {\n\t\tif ((xpdMask >> (AR5416_PD_GAINS_IN_MASK - i)) & 1) {\n\t\t\tif (numXpdGain >= AR5416_NUM_PD_GAINS)\n\t\t\t\tbreak;\n\t\t\txpdGainValues[numXpdGain] =\n\t\t\t\t(u16)(AR5416_PD_GAINS_IN_MASK - i);\n\t\t\tnumXpdGain++;\n\t\t}\n\t}\n\n\tREG_RMW_FIELD(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_NUM_PD_GAIN,\n\t\t      (numXpdGain - 1) & 0x3);\n\tREG_RMW_FIELD(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_PD_GAIN_1,\n\t\t      xpdGainValues[0]);\n\tREG_RMW_FIELD(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_PD_GAIN_2,\n\t\t      xpdGainValues[1]);\n\tREG_RMW_FIELD(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_PD_GAIN_3,\n\t\t      xpdGainValues[2]);\n\n\tfor (i = 0; i < AR5416_MAX_CHAINS; i++) {\n\t\tif ((ah->rxchainmask == 5 || ah->txchainmask == 5) &&\n\t\t    (i != 0)) {\n\t\t\tregChainOffset = (i == 1) ? 0x2000 : 0x1000;\n\t\t} else\n\t\t\tregChainOffset = i * 0x1000;\n\n\t\tif (pEepData->baseEepHeader.txMask & (1 << i)) {\n\t\t\tif (IS_CHAN_2GHZ(chan))\n\t\t\t\tpRawDataset = pEepData->calPierData2G[i];\n\t\t\telse\n\t\t\t\tpRawDataset = pEepData->calPierData5G[i];\n\n\n\t\t\tif (OLC_FOR_AR9280_20_LATER(ah)) {\n\t\t\t\tu8 pcdacIdx;\n\t\t\t\tu8 txPower;\n\n\t\t\t\tath9k_get_txgain_index(ah, chan,\n\t\t\t\t(struct calDataPerFreqOpLoop *)pRawDataset,\n\t\t\t\tpCalBChans, numPiers, &txPower, &pcdacIdx);\n\t\t\t\tath9k_olc_get_pdadcs(ah, pcdacIdx,\n\t\t\t\t\t\t     txPower/2, pdadcValues);\n\t\t\t} else {\n\t\t\t\tath9k_hw_get_gain_boundaries_pdadcs(ah,\n\t\t\t\t\t\t\tchan, pRawDataset,\n\t\t\t\t\t\t\tpCalBChans, numPiers,\n\t\t\t\t\t\t\tpdGainOverlap_t2,\n\t\t\t\t\t\t\tgainBoundaries,\n\t\t\t\t\t\t\tpdadcValues,\n\t\t\t\t\t\t\tnumXpdGain);\n\t\t\t}\n\n\t\t\tdiff = ath9k_change_gain_boundary_setting(ah,\n\t\t\t\t\t\t\t   gainBoundaries,\n\t\t\t\t\t\t\t   numXpdGain,\n\t\t\t\t\t\t\t   pdGainOverlap_t2,\n\t\t\t\t\t\t\t   pwr_table_offset,\n\t\t\t\t\t\t\t   &diff);\n\n\t\t\tENABLE_REGWRITE_BUFFER(ah);\n\n\t\t\tif (OLC_FOR_AR9280_20_LATER(ah)) {\n\t\t\t\tREG_WRITE(ah,\n\t\t\t\t\tAR_PHY_TPCRG5 + regChainOffset,\n\t\t\t\t\tSM(0x6,\n\t\t\t\t\tAR_PHY_TPCRG5_PD_GAIN_OVERLAP) |\n\t\t\t\t\tSM_PD_GAIN(1) | SM_PD_GAIN(2) |\n\t\t\t\t\tSM_PD_GAIN(3) | SM_PD_GAIN(4));\n\t\t\t} else {\n\t\t\t\tREG_WRITE(ah,\n\t\t\t\t\tAR_PHY_TPCRG5 + regChainOffset,\n\t\t\t\t\tSM(pdGainOverlap_t2,\n\t\t\t\t\tAR_PHY_TPCRG5_PD_GAIN_OVERLAP)|\n\t\t\t\t\tSM_PDGAIN_B(0, 1) |\n\t\t\t\t\tSM_PDGAIN_B(1, 2) |\n\t\t\t\t\tSM_PDGAIN_B(2, 3) |\n\t\t\t\t\tSM_PDGAIN_B(3, 4));\n\t\t\t}\n\n\t\t\tath9k_adjust_pdadc_values(ah, pwr_table_offset,\n\t\t\t\t\t\t  diff, pdadcValues);\n\n\t\t\tregOffset = AR_PHY_BASE + (672 << 2) + regChainOffset;\n\t\t\tfor (j = 0; j < 32; j++) {\n\t\t\t\treg32 = get_unaligned_le32(&pdadcValues[4 * j]);\n\t\t\t\tREG_WRITE(ah, regOffset, reg32);\n\n\t\t\t\tath_dbg(common, EEPROM,\n\t\t\t\t\t\"PDADC (%d,%4x): %4.4x %8.8x\\n\",\n\t\t\t\t\ti, regChainOffset, regOffset,\n\t\t\t\t\treg32);\n\t\t\t\tath_dbg(common, EEPROM,\n\t\t\t\t\t\"PDADC: Chain %d | PDADC %3d Value %3d | PDADC %3d Value %3d | PDADC %3d Value %3d | PDADC %3d Value %3d |\\n\",\n\t\t\t\t\ti, 4 * j, pdadcValues[4 * j],\n\t\t\t\t\t4 * j + 1, pdadcValues[4 * j + 1],\n\t\t\t\t\t4 * j + 2, pdadcValues[4 * j + 2],\n\t\t\t\t\t4 * j + 3, pdadcValues[4 * j + 3]);\n\n\t\t\t\tregOffset += 4;\n\t\t\t}\n\t\t\tREGWRITE_BUFFER_FLUSH(ah);\n\t\t}\n\t}\n\n#undef SM_PD_GAIN\n#undef SM_PDGAIN_B\n}\n\nstatic void ath9k_hw_set_def_power_per_rate_table(struct ath_hw *ah,\n\t\t\t\t\t\t  struct ath9k_channel *chan,\n\t\t\t\t\t\t  int16_t *ratesArray,\n\t\t\t\t\t\t  u16 cfgCtl,\n\t\t\t\t\t\t  u16 antenna_reduction,\n\t\t\t\t\t\t  u16 powerLimit)\n{\n\tstruct ar5416_eeprom_def *pEepData = &ah->eeprom.def;\n\tu16 twiceMaxEdgePower;\n\tint i;\n\tstruct cal_ctl_data *rep;\n\tstruct cal_target_power_leg targetPowerOfdm, targetPowerCck = {\n\t\t0, { 0, 0, 0, 0}\n\t};\n\tstruct cal_target_power_leg targetPowerOfdmExt = {\n\t\t0, { 0, 0, 0, 0} }, targetPowerCckExt = {\n\t\t0, { 0, 0, 0, 0 }\n\t};\n\tstruct cal_target_power_ht targetPowerHt20, targetPowerHt40 = {\n\t\t0, {0, 0, 0, 0}\n\t};\n\tu16 scaledPower = 0, minCtlPower;\n\tstatic const u16 ctlModesFor11a[] = {\n\t\tCTL_11A, CTL_5GHT20, CTL_11A_EXT, CTL_5GHT40\n\t};\n\tstatic const u16 ctlModesFor11g[] = {\n\t\tCTL_11B, CTL_11G, CTL_2GHT20,\n\t\tCTL_11B_EXT, CTL_11G_EXT, CTL_2GHT40\n\t};\n\tu16 numCtlModes;\n\tconst u16 *pCtlMode;\n\tu16 ctlMode, freq;\n\tstruct chan_centers centers;\n\tint tx_chainmask;\n\tu16 twiceMinEdgePower;\n\n\ttx_chainmask = ah->txchainmask;\n\n\tath9k_hw_get_channel_centers(ah, chan, &centers);\n\n\tscaledPower = ath9k_hw_get_scaled_power(ah, powerLimit,\n\t\t\t\t\t\tantenna_reduction);\n\n\tif (IS_CHAN_2GHZ(chan)) {\n\t\tnumCtlModes = ARRAY_SIZE(ctlModesFor11g) -\n\t\t\tSUB_NUM_CTL_MODES_AT_2G_40;\n\t\tpCtlMode = ctlModesFor11g;\n\n\t\tath9k_hw_get_legacy_target_powers(ah, chan,\n\t\t\tpEepData->calTargetPowerCck,\n\t\t\tAR5416_NUM_2G_CCK_TARGET_POWERS,\n\t\t\t&targetPowerCck, 4, false);\n\t\tath9k_hw_get_legacy_target_powers(ah, chan,\n\t\t\tpEepData->calTargetPower2G,\n\t\t\tAR5416_NUM_2G_20_TARGET_POWERS,\n\t\t\t&targetPowerOfdm, 4, false);\n\t\tath9k_hw_get_target_powers(ah, chan,\n\t\t\tpEepData->calTargetPower2GHT20,\n\t\t\tAR5416_NUM_2G_20_TARGET_POWERS,\n\t\t\t&targetPowerHt20, 8, false);\n\n\t\tif (IS_CHAN_HT40(chan)) {\n\t\t\tnumCtlModes = ARRAY_SIZE(ctlModesFor11g);\n\t\t\tath9k_hw_get_target_powers(ah, chan,\n\t\t\t\tpEepData->calTargetPower2GHT40,\n\t\t\t\tAR5416_NUM_2G_40_TARGET_POWERS,\n\t\t\t\t&targetPowerHt40, 8, true);\n\t\t\tath9k_hw_get_legacy_target_powers(ah, chan,\n\t\t\t\tpEepData->calTargetPowerCck,\n\t\t\t\tAR5416_NUM_2G_CCK_TARGET_POWERS,\n\t\t\t\t&targetPowerCckExt, 4, true);\n\t\t\tath9k_hw_get_legacy_target_powers(ah, chan,\n\t\t\t\tpEepData->calTargetPower2G,\n\t\t\t\tAR5416_NUM_2G_20_TARGET_POWERS,\n\t\t\t\t&targetPowerOfdmExt, 4, true);\n\t\t}\n\t} else {\n\t\tnumCtlModes = ARRAY_SIZE(ctlModesFor11a) -\n\t\t\tSUB_NUM_CTL_MODES_AT_5G_40;\n\t\tpCtlMode = ctlModesFor11a;\n\n\t\tath9k_hw_get_legacy_target_powers(ah, chan,\n\t\t\tpEepData->calTargetPower5G,\n\t\t\tAR5416_NUM_5G_20_TARGET_POWERS,\n\t\t\t&targetPowerOfdm, 4, false);\n\t\tath9k_hw_get_target_powers(ah, chan,\n\t\t\tpEepData->calTargetPower5GHT20,\n\t\t\tAR5416_NUM_5G_20_TARGET_POWERS,\n\t\t\t&targetPowerHt20, 8, false);\n\n\t\tif (IS_CHAN_HT40(chan)) {\n\t\t\tnumCtlModes = ARRAY_SIZE(ctlModesFor11a);\n\t\t\tath9k_hw_get_target_powers(ah, chan,\n\t\t\t\tpEepData->calTargetPower5GHT40,\n\t\t\t\tAR5416_NUM_5G_40_TARGET_POWERS,\n\t\t\t\t&targetPowerHt40, 8, true);\n\t\t\tath9k_hw_get_legacy_target_powers(ah, chan,\n\t\t\t\tpEepData->calTargetPower5G,\n\t\t\t\tAR5416_NUM_5G_20_TARGET_POWERS,\n\t\t\t\t&targetPowerOfdmExt, 4, true);\n\t\t}\n\t}\n\n\tfor (ctlMode = 0; ctlMode < numCtlModes; ctlMode++) {\n\t\tbool isHt40CtlMode = (pCtlMode[ctlMode] == CTL_5GHT40) ||\n\t\t\t(pCtlMode[ctlMode] == CTL_2GHT40);\n\t\tif (isHt40CtlMode)\n\t\t\tfreq = centers.synth_center;\n\t\telse if (pCtlMode[ctlMode] & EXT_ADDITIVE)\n\t\t\tfreq = centers.ext_center;\n\t\telse\n\t\t\tfreq = centers.ctl_center;\n\n\t\ttwiceMaxEdgePower = MAX_RATE_POWER;\n\n\t\tfor (i = 0; (i < AR5416_NUM_CTLS) && pEepData->ctlIndex[i]; i++) {\n\t\t\tif ((((cfgCtl & ~CTL_MODE_M) |\n\t\t\t      (pCtlMode[ctlMode] & CTL_MODE_M)) ==\n\t\t\t     pEepData->ctlIndex[i]) ||\n\t\t\t    (((cfgCtl & ~CTL_MODE_M) |\n\t\t\t      (pCtlMode[ctlMode] & CTL_MODE_M)) ==\n\t\t\t     ((pEepData->ctlIndex[i] & CTL_MODE_M) | SD_NO_CTL))) {\n\t\t\t\trep = &(pEepData->ctlData[i]);\n\n\t\t\t\ttwiceMinEdgePower = ath9k_hw_get_max_edge_power(freq,\n\t\t\t\trep->ctlEdges[ar5416_get_ntxchains(tx_chainmask) - 1],\n\t\t\t\tIS_CHAN_2GHZ(chan), AR5416_NUM_BAND_EDGES);\n\n\t\t\t\tif ((cfgCtl & ~CTL_MODE_M) == SD_NO_CTL) {\n\t\t\t\t\ttwiceMaxEdgePower = min(twiceMaxEdgePower,\n\t\t\t\t\t\t\t\ttwiceMinEdgePower);\n\t\t\t\t} else {\n\t\t\t\t\ttwiceMaxEdgePower = twiceMinEdgePower;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tminCtlPower = min(twiceMaxEdgePower, scaledPower);\n\n\t\tswitch (pCtlMode[ctlMode]) {\n\t\tcase CTL_11B:\n\t\t\tfor (i = 0; i < ARRAY_SIZE(targetPowerCck.tPow2x); i++) {\n\t\t\t\ttargetPowerCck.tPow2x[i] =\n\t\t\t\t\tmin((u16)targetPowerCck.tPow2x[i],\n\t\t\t\t\t    minCtlPower);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CTL_11A:\n\t\tcase CTL_11G:\n\t\t\tfor (i = 0; i < ARRAY_SIZE(targetPowerOfdm.tPow2x); i++) {\n\t\t\t\ttargetPowerOfdm.tPow2x[i] =\n\t\t\t\t\tmin((u16)targetPowerOfdm.tPow2x[i],\n\t\t\t\t\t    minCtlPower);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CTL_5GHT20:\n\t\tcase CTL_2GHT20:\n\t\t\tfor (i = 0; i < ARRAY_SIZE(targetPowerHt20.tPow2x); i++) {\n\t\t\t\ttargetPowerHt20.tPow2x[i] =\n\t\t\t\t\tmin((u16)targetPowerHt20.tPow2x[i],\n\t\t\t\t\t    minCtlPower);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CTL_11B_EXT:\n\t\t\ttargetPowerCckExt.tPow2x[0] = min((u16)\n\t\t\t\t\ttargetPowerCckExt.tPow2x[0],\n\t\t\t\t\tminCtlPower);\n\t\t\tbreak;\n\t\tcase CTL_11A_EXT:\n\t\tcase CTL_11G_EXT:\n\t\t\ttargetPowerOfdmExt.tPow2x[0] = min((u16)\n\t\t\t\t\ttargetPowerOfdmExt.tPow2x[0],\n\t\t\t\t\tminCtlPower);\n\t\t\tbreak;\n\t\tcase CTL_5GHT40:\n\t\tcase CTL_2GHT40:\n\t\t\tfor (i = 0; i < ARRAY_SIZE(targetPowerHt40.tPow2x); i++) {\n\t\t\t\ttargetPowerHt40.tPow2x[i] =\n\t\t\t\t\tmin((u16)targetPowerHt40.tPow2x[i],\n\t\t\t\t\t    minCtlPower);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tratesArray[rate6mb] = ratesArray[rate9mb] = ratesArray[rate12mb] =\n\t\tratesArray[rate18mb] = ratesArray[rate24mb] =\n\t\ttargetPowerOfdm.tPow2x[0];\n\tratesArray[rate36mb] = targetPowerOfdm.tPow2x[1];\n\tratesArray[rate48mb] = targetPowerOfdm.tPow2x[2];\n\tratesArray[rate54mb] = targetPowerOfdm.tPow2x[3];\n\tratesArray[rateXr] = targetPowerOfdm.tPow2x[0];\n\n\tfor (i = 0; i < ARRAY_SIZE(targetPowerHt20.tPow2x); i++)\n\t\tratesArray[rateHt20_0 + i] = targetPowerHt20.tPow2x[i];\n\n\tif (IS_CHAN_2GHZ(chan)) {\n\t\tratesArray[rate1l] = targetPowerCck.tPow2x[0];\n\t\tratesArray[rate2s] = ratesArray[rate2l] =\n\t\t\ttargetPowerCck.tPow2x[1];\n\t\tratesArray[rate5_5s] = ratesArray[rate5_5l] =\n\t\t\ttargetPowerCck.tPow2x[2];\n\t\tratesArray[rate11s] = ratesArray[rate11l] =\n\t\t\ttargetPowerCck.tPow2x[3];\n\t}\n\tif (IS_CHAN_HT40(chan)) {\n\t\tfor (i = 0; i < ARRAY_SIZE(targetPowerHt40.tPow2x); i++) {\n\t\t\tratesArray[rateHt40_0 + i] =\n\t\t\t\ttargetPowerHt40.tPow2x[i];\n\t\t}\n\t\tratesArray[rateDupOfdm] = targetPowerHt40.tPow2x[0];\n\t\tratesArray[rateDupCck] = targetPowerHt40.tPow2x[0];\n\t\tratesArray[rateExtOfdm] = targetPowerOfdmExt.tPow2x[0];\n\t\tif (IS_CHAN_2GHZ(chan)) {\n\t\t\tratesArray[rateExtCck] =\n\t\t\t\ttargetPowerCckExt.tPow2x[0];\n\t\t}\n\t}\n}\n\nstatic void ath9k_hw_def_set_txpower(struct ath_hw *ah,\n\t\t\t\t    struct ath9k_channel *chan,\n\t\t\t\t    u16 cfgCtl,\n\t\t\t\t    u8 twiceAntennaReduction,\n\t\t\t\t    u8 powerLimit, bool test)\n{\n#define RT_AR_DELTA(x) (ratesArray[x] - cck_ofdm_delta)\n\tstruct ath_regulatory *regulatory = ath9k_hw_regulatory(ah);\n\tstruct ar5416_eeprom_def *pEepData = &ah->eeprom.def;\n\tstruct modal_eep_header *pModal =\n\t\t&(pEepData->modalHeader[IS_CHAN_2GHZ(chan)]);\n\tint16_t ratesArray[Ar5416RateSize];\n\tu8 ht40PowerIncForPdadc = 2;\n\tint i, cck_ofdm_delta = 0;\n\n\tmemset(ratesArray, 0, sizeof(ratesArray));\n\n\tif (ath9k_hw_def_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_2)\n\t\tht40PowerIncForPdadc = pModal->ht40PowerIncForPdadc;\n\n\tath9k_hw_set_def_power_per_rate_table(ah, chan,\n\t\t\t\t\t       &ratesArray[0], cfgCtl,\n\t\t\t\t\t       twiceAntennaReduction,\n\t\t\t\t\t       powerLimit);\n\n\tath9k_hw_set_def_power_cal_table(ah, chan);\n\n\tregulatory->max_power_level = 0;\n\tfor (i = 0; i < ARRAY_SIZE(ratesArray); i++) {\n\t\tif (ratesArray[i] > MAX_RATE_POWER)\n\t\t\tratesArray[i] = MAX_RATE_POWER;\n\t\tif (ratesArray[i] > regulatory->max_power_level)\n\t\t\tregulatory->max_power_level = ratesArray[i];\n\t}\n\n\tath9k_hw_update_regulatory_maxpower(ah);\n\n\tif (test)\n\t\treturn;\n\n\tif (AR_SREV_9280_20_OR_LATER(ah)) {\n\t\tfor (i = 0; i < Ar5416RateSize; i++) {\n\t\t\tint8_t pwr_table_offset;\n\n\t\t\tpwr_table_offset = ah->eep_ops->get_eeprom(ah,\n\t\t\t\t\t\t\tEEP_PWR_TABLE_OFFSET);\n\t\t\tratesArray[i] -= pwr_table_offset * 2;\n\t\t}\n\t}\n\n\tENABLE_REGWRITE_BUFFER(ah);\n\n\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE1,\n\t\t  ATH9K_POW_SM(ratesArray[rate18mb], 24)\n\t\t  | ATH9K_POW_SM(ratesArray[rate12mb], 16)\n\t\t  | ATH9K_POW_SM(ratesArray[rate9mb], 8)\n\t\t  | ATH9K_POW_SM(ratesArray[rate6mb], 0));\n\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE2,\n\t\t  ATH9K_POW_SM(ratesArray[rate54mb], 24)\n\t\t  | ATH9K_POW_SM(ratesArray[rate48mb], 16)\n\t\t  | ATH9K_POW_SM(ratesArray[rate36mb], 8)\n\t\t  | ATH9K_POW_SM(ratesArray[rate24mb], 0));\n\n\tif (IS_CHAN_2GHZ(chan)) {\n\t\tif (OLC_FOR_AR9280_20_LATER(ah)) {\n\t\t\tcck_ofdm_delta = 2;\n\t\t\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE3,\n\t\t\t\tATH9K_POW_SM(RT_AR_DELTA(rate2s), 24)\n\t\t\t\t| ATH9K_POW_SM(RT_AR_DELTA(rate2l), 16)\n\t\t\t\t| ATH9K_POW_SM(ratesArray[rateXr], 8)\n\t\t\t\t| ATH9K_POW_SM(RT_AR_DELTA(rate1l), 0));\n\t\t\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE4,\n\t\t\t\tATH9K_POW_SM(RT_AR_DELTA(rate11s), 24)\n\t\t\t\t| ATH9K_POW_SM(RT_AR_DELTA(rate11l), 16)\n\t\t\t\t| ATH9K_POW_SM(RT_AR_DELTA(rate5_5s), 8)\n\t\t\t\t| ATH9K_POW_SM(RT_AR_DELTA(rate5_5l), 0));\n\t\t} else {\n\t\t\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE3,\n\t\t\t\tATH9K_POW_SM(ratesArray[rate2s], 24)\n\t\t\t\t| ATH9K_POW_SM(ratesArray[rate2l], 16)\n\t\t\t\t| ATH9K_POW_SM(ratesArray[rateXr], 8)\n\t\t\t\t| ATH9K_POW_SM(ratesArray[rate1l], 0));\n\t\t\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE4,\n\t\t\t\tATH9K_POW_SM(ratesArray[rate11s], 24)\n\t\t\t\t| ATH9K_POW_SM(ratesArray[rate11l], 16)\n\t\t\t\t| ATH9K_POW_SM(ratesArray[rate5_5s], 8)\n\t\t\t\t| ATH9K_POW_SM(ratesArray[rate5_5l], 0));\n\t\t}\n\t}\n\n\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE5,\n\t\t  ATH9K_POW_SM(ratesArray[rateHt20_3], 24)\n\t\t  | ATH9K_POW_SM(ratesArray[rateHt20_2], 16)\n\t\t  | ATH9K_POW_SM(ratesArray[rateHt20_1], 8)\n\t\t  | ATH9K_POW_SM(ratesArray[rateHt20_0], 0));\n\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE6,\n\t\t  ATH9K_POW_SM(ratesArray[rateHt20_7], 24)\n\t\t  | ATH9K_POW_SM(ratesArray[rateHt20_6], 16)\n\t\t  | ATH9K_POW_SM(ratesArray[rateHt20_5], 8)\n\t\t  | ATH9K_POW_SM(ratesArray[rateHt20_4], 0));\n\n\tif (IS_CHAN_HT40(chan)) {\n\t\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE7,\n\t\t\t  ATH9K_POW_SM(ratesArray[rateHt40_3] +\n\t\t\t\t       ht40PowerIncForPdadc, 24)\n\t\t\t  | ATH9K_POW_SM(ratesArray[rateHt40_2] +\n\t\t\t\t\t ht40PowerIncForPdadc, 16)\n\t\t\t  | ATH9K_POW_SM(ratesArray[rateHt40_1] +\n\t\t\t\t\t ht40PowerIncForPdadc, 8)\n\t\t\t  | ATH9K_POW_SM(ratesArray[rateHt40_0] +\n\t\t\t\t\t ht40PowerIncForPdadc, 0));\n\t\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE8,\n\t\t\t  ATH9K_POW_SM(ratesArray[rateHt40_7] +\n\t\t\t\t       ht40PowerIncForPdadc, 24)\n\t\t\t  | ATH9K_POW_SM(ratesArray[rateHt40_6] +\n\t\t\t\t\t ht40PowerIncForPdadc, 16)\n\t\t\t  | ATH9K_POW_SM(ratesArray[rateHt40_5] +\n\t\t\t\t\t ht40PowerIncForPdadc, 8)\n\t\t\t  | ATH9K_POW_SM(ratesArray[rateHt40_4] +\n\t\t\t\t\t ht40PowerIncForPdadc, 0));\n\t\tif (OLC_FOR_AR9280_20_LATER(ah)) {\n\t\t\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE9,\n\t\t\t\tATH9K_POW_SM(ratesArray[rateExtOfdm], 24)\n\t\t\t\t| ATH9K_POW_SM(RT_AR_DELTA(rateExtCck), 16)\n\t\t\t\t| ATH9K_POW_SM(ratesArray[rateDupOfdm], 8)\n\t\t\t\t| ATH9K_POW_SM(RT_AR_DELTA(rateDupCck), 0));\n\t\t} else {\n\t\t\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE9,\n\t\t\t\tATH9K_POW_SM(ratesArray[rateExtOfdm], 24)\n\t\t\t\t| ATH9K_POW_SM(ratesArray[rateExtCck], 16)\n\t\t\t\t| ATH9K_POW_SM(ratesArray[rateDupOfdm], 8)\n\t\t\t\t| ATH9K_POW_SM(ratesArray[rateDupCck], 0));\n\t\t}\n\t}\n\n\tREG_WRITE(ah, AR_PHY_POWER_TX_SUB,\n\t\t  ATH9K_POW_SM(pModal->pwrDecreaseFor3Chain, 6)\n\t\t  | ATH9K_POW_SM(pModal->pwrDecreaseFor2Chain, 0));\n\n\t \n\tif (ah->tpc_enabled) {\n\t\tint ht40_delta;\n\n\t\tht40_delta = (IS_CHAN_HT40(chan)) ? ht40PowerIncForPdadc : 0;\n\t\tar5008_hw_init_rate_txpower(ah, ratesArray, chan, ht40_delta);\n\t\t \n\t\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE_MAX,\n\t\t\tMAX_RATE_POWER | AR_PHY_POWER_TX_RATE_MAX_TPC_ENABLE);\n\t} else {\n\t\t \n\t\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE_MAX, MAX_RATE_POWER);\n\t}\n\n\tREGWRITE_BUFFER_FLUSH(ah);\n}\n\nstatic u16 ath9k_hw_def_get_spur_channel(struct ath_hw *ah, u16 i, bool is2GHz)\n{\n\t__le16 spch = ah->eeprom.def.modalHeader[is2GHz].spurChans[i].spurChan;\n\n\treturn le16_to_cpu(spch);\n}\n\nstatic u8 ath9k_hw_def_get_eepmisc(struct ath_hw *ah)\n{\n\treturn ah->eeprom.def.baseEepHeader.eepMisc;\n}\n\nconst struct eeprom_ops eep_def_ops = {\n\t.check_eeprom\t\t= ath9k_hw_def_check_eeprom,\n\t.get_eeprom\t\t= ath9k_hw_def_get_eeprom,\n\t.fill_eeprom\t\t= ath9k_hw_def_fill_eeprom,\n\t.dump_eeprom\t\t= ath9k_hw_def_dump_eeprom,\n\t.get_eeprom_ver\t\t= ath9k_hw_def_get_eeprom_ver,\n\t.get_eeprom_rev\t\t= ath9k_hw_def_get_eeprom_rev,\n\t.set_board_values\t= ath9k_hw_def_set_board_values,\n\t.set_addac\t\t= ath9k_hw_def_set_addac,\n\t.set_txpower\t\t= ath9k_hw_def_set_txpower,\n\t.get_spur_channel\t= ath9k_hw_def_get_spur_channel,\n\t.get_eepmisc\t\t= ath9k_hw_def_get_eepmisc\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}