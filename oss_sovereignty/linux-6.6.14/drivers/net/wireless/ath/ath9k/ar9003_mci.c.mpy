{
  "module_name": "ar9003_mci.c",
  "hash_id": "dc6f481bfb599517306f48bde372195f8379c81256b751504bf6688df3385cf0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/ar9003_mci.c",
  "human_readable_source": " \n\n#include <linux/export.h>\n#include \"hw.h\"\n#include \"hw-ops.h\"\n#include \"ar9003_phy.h\"\n#include \"ar9003_mci.h\"\n#include \"ar9003_aic.h\"\n\nstatic void ar9003_mci_reset_req_wakeup(struct ath_hw *ah)\n{\n\tREG_RMW_FIELD(ah, AR_MCI_COMMAND2,\n\t\t      AR_MCI_COMMAND2_RESET_REQ_WAKEUP, 1);\n\tudelay(1);\n\tREG_RMW_FIELD(ah, AR_MCI_COMMAND2,\n\t\t      AR_MCI_COMMAND2_RESET_REQ_WAKEUP, 0);\n}\n\nstatic int ar9003_mci_wait_for_interrupt(struct ath_hw *ah, u32 address,\n\t\t\t\t\tu32 bit_position, int time_out)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\twhile (time_out) {\n\t\tif (!(REG_READ(ah, address) & bit_position)) {\n\t\t\tudelay(10);\n\t\t\ttime_out -= 10;\n\n\t\t\tif (time_out < 0)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\tREG_WRITE(ah, address, bit_position);\n\n\t\tif (address != AR_MCI_INTERRUPT_RX_MSG_RAW)\n\t\t\tbreak;\n\n\t\tif (bit_position & AR_MCI_INTERRUPT_RX_MSG_REQ_WAKE)\n\t\t\tar9003_mci_reset_req_wakeup(ah);\n\n\t\tif (bit_position & (AR_MCI_INTERRUPT_RX_MSG_SYS_SLEEPING |\n\t\t\t\t    AR_MCI_INTERRUPT_RX_MSG_SYS_WAKING))\n\t\t\tREG_WRITE(ah, AR_MCI_INTERRUPT_RAW,\n\t\t\t\t  AR_MCI_INTERRUPT_REMOTE_SLEEP_UPDATE);\n\n\t\tREG_WRITE(ah, AR_MCI_INTERRUPT_RAW, AR_MCI_INTERRUPT_RX_MSG);\n\t\tbreak;\n\t}\n\n\tif (time_out <= 0) {\n\t\tath_dbg(common, MCI,\n\t\t\t\"MCI Wait for Reg 0x%08x = 0x%08x timeout\\n\",\n\t\t\taddress, bit_position);\n\t\tath_dbg(common, MCI,\n\t\t\t\"MCI INT_RAW = 0x%08x, RX_MSG_RAW = 0x%08x\\n\",\n\t\t\tREG_READ(ah, AR_MCI_INTERRUPT_RAW),\n\t\t\tREG_READ(ah, AR_MCI_INTERRUPT_RX_MSG_RAW));\n\t\ttime_out = 0;\n\t}\n\n\treturn time_out;\n}\n\nstatic void ar9003_mci_remote_reset(struct ath_hw *ah, bool wait_done)\n{\n\tu32 payload[4] = { 0xffffffff, 0xffffffff, 0xffffffff, 0xffffff00};\n\n\tar9003_mci_send_message(ah, MCI_REMOTE_RESET, 0, payload, 16,\n\t\t\t\twait_done, false);\n\tudelay(5);\n}\n\nstatic void ar9003_mci_send_lna_transfer(struct ath_hw *ah, bool wait_done)\n{\n\tu32 payload = 0x00000000;\n\n\tar9003_mci_send_message(ah, MCI_LNA_TRANS, 0, &payload, 1,\n\t\t\t\twait_done, false);\n}\n\nstatic void ar9003_mci_send_req_wake(struct ath_hw *ah, bool wait_done)\n{\n\tar9003_mci_send_message(ah, MCI_REQ_WAKE, MCI_FLAG_DISABLE_TIMESTAMP,\n\t\t\t\tNULL, 0, wait_done, false);\n\tudelay(5);\n}\n\nstatic void ar9003_mci_send_sys_waking(struct ath_hw *ah, bool wait_done)\n{\n\tar9003_mci_send_message(ah, MCI_SYS_WAKING, MCI_FLAG_DISABLE_TIMESTAMP,\n\t\t\t\tNULL, 0, wait_done, false);\n}\n\nstatic void ar9003_mci_send_lna_take(struct ath_hw *ah, bool wait_done)\n{\n\tu32 payload = 0x70000000;\n\n\tar9003_mci_send_message(ah, MCI_LNA_TAKE, 0, &payload, 1,\n\t\t\t\twait_done, false);\n}\n\nstatic void ar9003_mci_send_sys_sleeping(struct ath_hw *ah, bool wait_done)\n{\n\tar9003_mci_send_message(ah, MCI_SYS_SLEEPING,\n\t\t\t\tMCI_FLAG_DISABLE_TIMESTAMP,\n\t\t\t\tNULL, 0, wait_done, false);\n}\n\nstatic void ar9003_mci_send_coex_version_query(struct ath_hw *ah,\n\t\t\t\t\t       bool wait_done)\n{\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\tu32 payload[4] = {0, 0, 0, 0};\n\n\tif (mci->bt_version_known ||\n\t    (mci->bt_state == MCI_BT_SLEEP))\n\t\treturn;\n\n\tMCI_GPM_SET_TYPE_OPCODE(payload, MCI_GPM_COEX_AGENT,\n\t\t\t\tMCI_GPM_COEX_VERSION_QUERY);\n\tar9003_mci_send_message(ah, MCI_GPM, 0, payload, 16, wait_done, true);\n}\n\nstatic void ar9003_mci_send_coex_version_response(struct ath_hw *ah,\n\t\t\t\t\t\t  bool wait_done)\n{\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\tu32 payload[4] = {0, 0, 0, 0};\n\n\tMCI_GPM_SET_TYPE_OPCODE(payload, MCI_GPM_COEX_AGENT,\n\t\t\t\tMCI_GPM_COEX_VERSION_RESPONSE);\n\t*(((u8 *)payload) + MCI_GPM_COEX_B_MAJOR_VERSION) =\n\t\tmci->wlan_ver_major;\n\t*(((u8 *)payload) + MCI_GPM_COEX_B_MINOR_VERSION) =\n\t\tmci->wlan_ver_minor;\n\tar9003_mci_send_message(ah, MCI_GPM, 0, payload, 16, wait_done, true);\n}\n\nstatic void ar9003_mci_send_coex_wlan_channels(struct ath_hw *ah,\n\t\t\t\t\t       bool wait_done)\n{\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\tu32 *payload = &mci->wlan_channels[0];\n\n\tif (!mci->wlan_channels_update ||\n\t    (mci->bt_state == MCI_BT_SLEEP))\n\t\treturn;\n\n\tMCI_GPM_SET_TYPE_OPCODE(payload, MCI_GPM_COEX_AGENT,\n\t\t\t\tMCI_GPM_COEX_WLAN_CHANNELS);\n\tar9003_mci_send_message(ah, MCI_GPM, 0, payload, 16, wait_done, true);\n\tMCI_GPM_SET_TYPE_OPCODE(payload, 0xff, 0xff);\n}\n\nstatic void ar9003_mci_send_coex_bt_status_query(struct ath_hw *ah,\n\t\t\t\t\t\tbool wait_done, u8 query_type)\n{\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\tu32 payload[4] = {0, 0, 0, 0};\n\tbool query_btinfo;\n\n\tif (mci->bt_state == MCI_BT_SLEEP)\n\t\treturn;\n\n\tquery_btinfo = !!(query_type & (MCI_GPM_COEX_QUERY_BT_ALL_INFO |\n\t\t\t\t\tMCI_GPM_COEX_QUERY_BT_TOPOLOGY));\n\tMCI_GPM_SET_TYPE_OPCODE(payload, MCI_GPM_COEX_AGENT,\n\t\t\t\tMCI_GPM_COEX_STATUS_QUERY);\n\n\t*(((u8 *)payload) + MCI_GPM_COEX_B_BT_BITMAP) = query_type;\n\n\t \n\tif (!ar9003_mci_send_message(ah, MCI_GPM, 0, payload, 16,\n\t\t\t\twait_done, true)) {\n\t\tif (query_btinfo)\n\t\t\tmci->need_flush_btinfo = true;\n\t}\n\n\tif (query_btinfo)\n\t\tmci->query_bt = false;\n}\n\nstatic void ar9003_mci_send_coex_halt_bt_gpm(struct ath_hw *ah, bool halt,\n\t\t\t\t\t     bool wait_done)\n{\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\tu32 payload[4] = {0, 0, 0, 0};\n\n\tMCI_GPM_SET_TYPE_OPCODE(payload, MCI_GPM_COEX_AGENT,\n\t\t\t\tMCI_GPM_COEX_HALT_BT_GPM);\n\n\tif (halt) {\n\t\tmci->query_bt = true;\n\t\t \n\t\tmci->unhalt_bt_gpm = true;\n\t\tmci->need_flush_btinfo = true;\n\t\t*(((u8 *)payload) + MCI_GPM_COEX_B_HALT_STATE) =\n\t\t\tMCI_GPM_COEX_BT_GPM_HALT;\n\t} else\n\t\t*(((u8 *)payload) + MCI_GPM_COEX_B_HALT_STATE) =\n\t\t\tMCI_GPM_COEX_BT_GPM_UNHALT;\n\n\tar9003_mci_send_message(ah, MCI_GPM, 0, payload, 16, wait_done, true);\n}\n\nstatic void ar9003_mci_prep_interface(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\tu32 saved_mci_int_en;\n\tu32 mci_timeout = 150;\n\n\tmci->bt_state = MCI_BT_SLEEP;\n\tsaved_mci_int_en = REG_READ(ah, AR_MCI_INTERRUPT_EN);\n\n\tREG_WRITE(ah, AR_MCI_INTERRUPT_EN, 0);\n\tREG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_RAW,\n\t\t  REG_READ(ah, AR_MCI_INTERRUPT_RX_MSG_RAW));\n\tREG_WRITE(ah, AR_MCI_INTERRUPT_RAW,\n\t\t  REG_READ(ah, AR_MCI_INTERRUPT_RAW));\n\n\tar9003_mci_remote_reset(ah, true);\n\tar9003_mci_send_req_wake(ah, true);\n\n\tif (!ar9003_mci_wait_for_interrupt(ah, AR_MCI_INTERRUPT_RX_MSG_RAW,\n\t\t\t\t  AR_MCI_INTERRUPT_RX_MSG_SYS_WAKING, 500))\n\t\tgoto clear_redunt;\n\n\tmci->bt_state = MCI_BT_AWAKE;\n\n\t \n\tar9003_mci_send_sys_waking(ah, true);\n\tudelay(10);\n\n\t \n\tREG_WRITE(ah, AR_MCI_BT_PRI0, 0xFFFFFFFF);\n\tREG_WRITE(ah, AR_MCI_BT_PRI1, 0xFFFFFFFF);\n\tREG_WRITE(ah, AR_MCI_BT_PRI2, 0xFFFFFFFF);\n\tREG_WRITE(ah, AR_MCI_BT_PRI3, 0xFFFFFFFF);\n\tREG_WRITE(ah, AR_MCI_BT_PRI, 0X000000FF);\n\n\t \n\n\tREG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_RAW,\n\t\t  AR_MCI_INTERRUPT_RX_MSG_CONT_RST);\n\tREG_WRITE(ah, AR_MCI_INTERRUPT_RAW, AR_MCI_INTERRUPT_BT_PRI);\n\n\tif (mci->is_2g && MCI_ANT_ARCH_PA_LNA_SHARED(mci)) {\n\t\tar9003_mci_send_lna_transfer(ah, true);\n\t\tudelay(5);\n\t}\n\n\tif (mci->is_2g && !mci->update_2g5g && MCI_ANT_ARCH_PA_LNA_SHARED(mci)) {\n\t\tif (ar9003_mci_wait_for_interrupt(ah,\n\t\t\t\t\tAR_MCI_INTERRUPT_RX_MSG_RAW,\n\t\t\t\t\tAR_MCI_INTERRUPT_RX_MSG_LNA_INFO,\n\t\t\t\t\tmci_timeout))\n\t\t\tath_dbg(common, MCI,\n\t\t\t\t\"MCI WLAN has control over the LNA & BT obeys it\\n\");\n\t\telse\n\t\t\tath_dbg(common, MCI,\n\t\t\t\t\"MCI BT didn't respond to LNA_TRANS\\n\");\n\t}\n\nclear_redunt:\n\t \n\tif ((mci->bt_state == MCI_BT_AWAKE) &&\n\t    (REG_READ_FIELD(ah, AR_MCI_INTERRUPT_RX_MSG_RAW,\n\t\t\t    AR_MCI_INTERRUPT_RX_MSG_SYS_WAKING)) &&\n\t    (REG_READ_FIELD(ah, AR_MCI_INTERRUPT_RX_MSG_RAW,\n\t\t\t    AR_MCI_INTERRUPT_RX_MSG_SYS_SLEEPING) == 0)) {\n\t\tREG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_RAW,\n\t\t\t  AR_MCI_INTERRUPT_RX_MSG_SYS_WAKING);\n\t\tREG_WRITE(ah, AR_MCI_INTERRUPT_RAW,\n\t\t\t  AR_MCI_INTERRUPT_REMOTE_SLEEP_UPDATE);\n\t}\n\n\tREG_WRITE(ah, AR_MCI_INTERRUPT_EN, saved_mci_int_en);\n}\n\nvoid ar9003_mci_set_full_sleep(struct ath_hw *ah)\n{\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\n\tif (ar9003_mci_state(ah, MCI_STATE_ENABLE) &&\n\t    (mci->bt_state != MCI_BT_SLEEP) &&\n\t    !mci->halted_bt_gpm) {\n\t\tar9003_mci_send_coex_halt_bt_gpm(ah, true, true);\n\t}\n\n\tmci->ready = false;\n}\n\nstatic void ar9003_mci_disable_interrupt(struct ath_hw *ah)\n{\n\tREG_WRITE(ah, AR_MCI_INTERRUPT_EN, 0);\n\tREG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_EN, 0);\n}\n\nstatic void ar9003_mci_enable_interrupt(struct ath_hw *ah)\n{\n\tREG_WRITE(ah, AR_MCI_INTERRUPT_EN, AR_MCI_INTERRUPT_DEFAULT);\n\tREG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_EN,\n\t\t  AR_MCI_INTERRUPT_RX_MSG_DEFAULT);\n}\n\nstatic bool ar9003_mci_check_int(struct ath_hw *ah, u32 ints)\n{\n\tu32 intr;\n\n\tintr = REG_READ(ah, AR_MCI_INTERRUPT_RX_MSG_RAW);\n\treturn ((intr & ints) == ints);\n}\n\nvoid ar9003_mci_get_interrupt(struct ath_hw *ah, u32 *raw_intr,\n\t\t\t      u32 *rx_msg_intr)\n{\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\n\t*raw_intr = mci->raw_intr;\n\t*rx_msg_intr = mci->rx_msg_intr;\n\n\t \n\tmci->raw_intr = 0;\n\tmci->rx_msg_intr = 0;\n}\nEXPORT_SYMBOL(ar9003_mci_get_interrupt);\n\nvoid ar9003_mci_get_isr(struct ath_hw *ah, enum ath9k_int *masked)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\tu32 raw_intr, rx_msg_intr;\n\n\trx_msg_intr = REG_READ(ah, AR_MCI_INTERRUPT_RX_MSG_RAW);\n\traw_intr = REG_READ(ah, AR_MCI_INTERRUPT_RAW);\n\n\tif ((raw_intr == 0xdeadbeef) || (rx_msg_intr == 0xdeadbeef)) {\n\t\tath_dbg(common, MCI,\n\t\t\t\"MCI gets 0xdeadbeef during int processing\\n\");\n\t} else {\n\t\tmci->rx_msg_intr |= rx_msg_intr;\n\t\tmci->raw_intr |= raw_intr;\n\t\t*masked |= ATH9K_INT_MCI;\n\n\t\tif (rx_msg_intr & AR_MCI_INTERRUPT_RX_MSG_CONT_INFO)\n\t\t\tmci->cont_status = REG_READ(ah, AR_MCI_CONT_STATUS);\n\n\t\tREG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_RAW, rx_msg_intr);\n\t\tREG_WRITE(ah, AR_MCI_INTERRUPT_RAW, raw_intr);\n\t}\n}\n\nstatic void ar9003_mci_2g5g_changed(struct ath_hw *ah, bool is_2g)\n{\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\n\tif (!mci->update_2g5g &&\n\t    (mci->is_2g != is_2g))\n\t\tmci->update_2g5g = true;\n\n\tmci->is_2g = is_2g;\n}\n\nstatic bool ar9003_mci_is_gpm_valid(struct ath_hw *ah, u32 msg_index)\n{\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\tu32 *payload;\n\tu32 recv_type, offset;\n\n\tif (msg_index == MCI_GPM_INVALID)\n\t\treturn false;\n\n\toffset = msg_index << 4;\n\n\tpayload = (u32 *)(mci->gpm_buf + offset);\n\trecv_type = MCI_GPM_TYPE(payload);\n\n\tif (recv_type == MCI_GPM_RSVD_PATTERN)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void ar9003_mci_observation_set_up(struct ath_hw *ah)\n{\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\n\tif (mci->config & ATH_MCI_CONFIG_MCI_OBS_MCI) {\n\t\tath9k_hw_gpio_request_out(ah, 3, NULL,\n\t\t\t\t\t  AR_GPIO_OUTPUT_MUX_AS_MCI_WLAN_DATA);\n\t\tath9k_hw_gpio_request_out(ah, 2, NULL,\n\t\t\t\t\t  AR_GPIO_OUTPUT_MUX_AS_MCI_WLAN_CLK);\n\t\tath9k_hw_gpio_request_out(ah, 1, NULL,\n\t\t\t\t\t  AR_GPIO_OUTPUT_MUX_AS_MCI_BT_DATA);\n\t\tath9k_hw_gpio_request_out(ah, 0, NULL,\n\t\t\t\t\t  AR_GPIO_OUTPUT_MUX_AS_MCI_BT_CLK);\n\t} else if (mci->config & ATH_MCI_CONFIG_MCI_OBS_TXRX) {\n\t\tath9k_hw_gpio_request_out(ah, 3, NULL,\n\t\t\t\t\t  AR_GPIO_OUTPUT_MUX_AS_WL_IN_TX);\n\t\tath9k_hw_gpio_request_out(ah, 2, NULL,\n\t\t\t\t\t  AR_GPIO_OUTPUT_MUX_AS_WL_IN_RX);\n\t\tath9k_hw_gpio_request_out(ah, 1, NULL,\n\t\t\t\t\t  AR_GPIO_OUTPUT_MUX_AS_BT_IN_TX);\n\t\tath9k_hw_gpio_request_out(ah, 0, NULL,\n\t\t\t\t\t  AR_GPIO_OUTPUT_MUX_AS_BT_IN_RX);\n\t\tath9k_hw_gpio_request_out(ah, 5, NULL,\n\t\t\t\t\t  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);\n\t} else if (mci->config & ATH_MCI_CONFIG_MCI_OBS_BT) {\n\t\tath9k_hw_gpio_request_out(ah, 3, NULL,\n\t\t\t\t\t  AR_GPIO_OUTPUT_MUX_AS_BT_IN_TX);\n\t\tath9k_hw_gpio_request_out(ah, 2, NULL,\n\t\t\t\t\t  AR_GPIO_OUTPUT_MUX_AS_BT_IN_RX);\n\t\tath9k_hw_gpio_request_out(ah, 1, NULL,\n\t\t\t\t\t  AR_GPIO_OUTPUT_MUX_AS_MCI_BT_DATA);\n\t\tath9k_hw_gpio_request_out(ah, 0, NULL,\n\t\t\t\t\t  AR_GPIO_OUTPUT_MUX_AS_MCI_BT_CLK);\n\t} else\n\t\treturn;\n\n\tREG_SET_BIT(ah, AR_GPIO_INPUT_EN_VAL(ah), AR_GPIO_JTAG_DISABLE);\n\n\tREG_RMW_FIELD(ah, AR_PHY_GLB_CONTROL, AR_GLB_DS_JTAG_DISABLE, 1);\n\tREG_RMW_FIELD(ah, AR_PHY_GLB_CONTROL, AR_GLB_WLAN_UART_INTF_EN, 0);\n\tREG_SET_BIT(ah, AR_GLB_GPIO_CONTROL, ATH_MCI_CONFIG_MCI_OBS_GPIO);\n\n\tREG_RMW_FIELD(ah, AR_BTCOEX_CTRL2, AR_BTCOEX_CTRL2_GPIO_OBS_SEL, 0);\n\tREG_RMW_FIELD(ah, AR_BTCOEX_CTRL2, AR_BTCOEX_CTRL2_MAC_BB_OBS_SEL, 1);\n\tREG_WRITE(ah, AR_OBS(ah), 0x4b);\n\tREG_RMW_FIELD(ah, AR_DIAG_SW, AR_DIAG_OBS_PT_SEL1, 0x03);\n\tREG_RMW_FIELD(ah, AR_DIAG_SW, AR_DIAG_OBS_PT_SEL2, 0x01);\n\tREG_RMW_FIELD(ah, AR_MACMISC, AR_MACMISC_MISC_OBS_BUS_LSB, 0x02);\n\tREG_RMW_FIELD(ah, AR_MACMISC, AR_MACMISC_MISC_OBS_BUS_MSB, 0x03);\n\tREG_RMW_FIELD(ah, AR_PHY_TEST_CTL_STATUS(ah),\n\t\t      AR_PHY_TEST_CTL_DEBUGPORT_SEL, 0x07);\n}\n\nstatic bool ar9003_mci_send_coex_bt_flags(struct ath_hw *ah, bool wait_done,\n\t\t\t\t\t  u8 opcode, u32 bt_flags)\n{\n\tu32 pld[4] = {0, 0, 0, 0};\n\n\tMCI_GPM_SET_TYPE_OPCODE(pld, MCI_GPM_COEX_AGENT,\n\t\t\t\tMCI_GPM_COEX_BT_UPDATE_FLAGS);\n\n\t*(((u8 *)pld) + MCI_GPM_COEX_B_BT_FLAGS_OP)  = opcode;\n\t*(((u8 *)pld) + MCI_GPM_COEX_W_BT_FLAGS + 0) = bt_flags & 0xFF;\n\t*(((u8 *)pld) + MCI_GPM_COEX_W_BT_FLAGS + 1) = (bt_flags >> 8) & 0xFF;\n\t*(((u8 *)pld) + MCI_GPM_COEX_W_BT_FLAGS + 2) = (bt_flags >> 16) & 0xFF;\n\t*(((u8 *)pld) + MCI_GPM_COEX_W_BT_FLAGS + 3) = (bt_flags >> 24) & 0xFF;\n\n\treturn ar9003_mci_send_message(ah, MCI_GPM, 0, pld, 16,\n\t\t\t\t       wait_done, true);\n}\n\nstatic void ar9003_mci_sync_bt_state(struct ath_hw *ah)\n{\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\tu32 cur_bt_state;\n\n\tcur_bt_state = ar9003_mci_state(ah, MCI_STATE_REMOTE_SLEEP);\n\n\tif (mci->bt_state != cur_bt_state)\n\t\tmci->bt_state = cur_bt_state;\n\n\tif (mci->bt_state != MCI_BT_SLEEP) {\n\n\t\tar9003_mci_send_coex_version_query(ah, true);\n\t\tar9003_mci_send_coex_wlan_channels(ah, true);\n\n\t\tif (mci->unhalt_bt_gpm == true)\n\t\t\tar9003_mci_send_coex_halt_bt_gpm(ah, false, true);\n\t}\n}\n\nvoid ar9003_mci_check_bt(struct ath_hw *ah)\n{\n\tstruct ath9k_hw_mci *mci_hw = &ah->btcoex_hw.mci;\n\n\tif (!mci_hw->ready)\n\t\treturn;\n\n\t \n\tar9003_mci_sync_bt_state(ah);\n\tar9003_mci_2g5g_switch(ah, true);\n\n\tif ((mci_hw->bt_state == MCI_BT_AWAKE) &&\n\t    (mci_hw->query_bt == true)) {\n\t\tmci_hw->need_flush_btinfo = true;\n\t}\n}\n\nstatic void ar9003_mci_process_gpm_extra(struct ath_hw *ah, u8 gpm_type,\n\t\t\t\t\t u8 gpm_opcode, u32 *p_gpm)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\tu8 *p_data = (u8 *) p_gpm;\n\n\tif (gpm_type != MCI_GPM_COEX_AGENT)\n\t\treturn;\n\n\tswitch (gpm_opcode) {\n\tcase MCI_GPM_COEX_VERSION_QUERY:\n\t\tath_dbg(common, MCI, \"MCI Recv GPM COEX Version Query\\n\");\n\t\tar9003_mci_send_coex_version_response(ah, true);\n\t\tbreak;\n\tcase MCI_GPM_COEX_VERSION_RESPONSE:\n\t\tath_dbg(common, MCI, \"MCI Recv GPM COEX Version Response\\n\");\n\t\tmci->bt_ver_major =\n\t\t\t*(p_data + MCI_GPM_COEX_B_MAJOR_VERSION);\n\t\tmci->bt_ver_minor =\n\t\t\t*(p_data + MCI_GPM_COEX_B_MINOR_VERSION);\n\t\tmci->bt_version_known = true;\n\t\tath_dbg(common, MCI, \"MCI BT Coex version: %d.%d\\n\",\n\t\t\tmci->bt_ver_major, mci->bt_ver_minor);\n\t\tbreak;\n\tcase MCI_GPM_COEX_STATUS_QUERY:\n\t\tath_dbg(common, MCI,\n\t\t\t\"MCI Recv GPM COEX Status Query = 0x%02X\\n\",\n\t\t\t*(p_data + MCI_GPM_COEX_B_WLAN_BITMAP));\n\t\tmci->wlan_channels_update = true;\n\t\tar9003_mci_send_coex_wlan_channels(ah, true);\n\t\tbreak;\n\tcase MCI_GPM_COEX_BT_PROFILE_INFO:\n\t\tmci->query_bt = true;\n\t\tath_dbg(common, MCI, \"MCI Recv GPM COEX BT_Profile_Info\\n\");\n\t\tbreak;\n\tcase MCI_GPM_COEX_BT_STATUS_UPDATE:\n\t\tmci->query_bt = true;\n\t\tath_dbg(common, MCI,\n\t\t\t\"MCI Recv GPM COEX BT_Status_Update SEQ=%d (drop&query)\\n\",\n\t\t\t*(p_gpm + 3));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic u32 ar9003_mci_wait_for_gpm(struct ath_hw *ah, u8 gpm_type,\n\t\t\t\t   u8 gpm_opcode, int time_out)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\tu32 *p_gpm = NULL, more_data;\n\tu32 offset;\n\tu8 recv_type = 0, recv_opcode = 0;\n\tbool b_is_bt_cal_done = (gpm_type == MCI_GPM_BT_CAL_DONE);\n\n\tmore_data = time_out ? MCI_GPM_NOMORE : MCI_GPM_MORE;\n\n\twhile (time_out > 0) {\n\t\tif (p_gpm) {\n\t\t\tMCI_GPM_RECYCLE(p_gpm);\n\t\t\tp_gpm = NULL;\n\t\t}\n\n\t\tif (more_data != MCI_GPM_MORE)\n\t\t\ttime_out = ar9003_mci_wait_for_interrupt(ah,\n\t\t\t\t\tAR_MCI_INTERRUPT_RX_MSG_RAW,\n\t\t\t\t\tAR_MCI_INTERRUPT_RX_MSG_GPM,\n\t\t\t\t\ttime_out);\n\n\t\tif (!time_out)\n\t\t\tbreak;\n\n\t\toffset = ar9003_mci_get_next_gpm_offset(ah, &more_data);\n\n\t\tif (offset == MCI_GPM_INVALID)\n\t\t\tcontinue;\n\n\t\tp_gpm = (u32 *) (mci->gpm_buf + offset);\n\t\trecv_type = MCI_GPM_TYPE(p_gpm);\n\t\trecv_opcode = MCI_GPM_OPCODE(p_gpm);\n\n\t\tif (MCI_GPM_IS_CAL_TYPE(recv_type)) {\n\t\t\tif (recv_type == gpm_type) {\n\t\t\t\tif ((gpm_type == MCI_GPM_BT_CAL_DONE) &&\n\t\t\t\t    !b_is_bt_cal_done) {\n\t\t\t\t\tgpm_type = MCI_GPM_BT_CAL_GRANT;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((recv_type == gpm_type) &&\n\t\t\t   (recv_opcode == gpm_opcode))\n\t\t\tbreak;\n\n\t\t \n\n\t\tif ((gpm_type == MCI_GPM_BT_CAL_GRANT) &&\n\t\t    (recv_type == MCI_GPM_BT_CAL_REQ)) {\n\n\t\t\tu32 payload[4] = {0, 0, 0, 0};\n\n\t\t\tgpm_type = MCI_GPM_BT_CAL_DONE;\n\t\t\tMCI_GPM_SET_CAL_TYPE(payload,\n\t\t\t\t\t     MCI_GPM_WLAN_CAL_GRANT);\n\t\t\tar9003_mci_send_message(ah, MCI_GPM, 0, payload, 16,\n\t\t\t\t\t\tfalse, false);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tath_dbg(common, MCI, \"MCI GPM subtype not match 0x%x\\n\",\n\t\t\t\t*(p_gpm + 1));\n\t\t\tar9003_mci_process_gpm_extra(ah, recv_type,\n\t\t\t\t\t\t     recv_opcode, p_gpm);\n\t\t}\n\t}\n\n\tif (p_gpm) {\n\t\tMCI_GPM_RECYCLE(p_gpm);\n\t\tp_gpm = NULL;\n\t}\n\n\tif (time_out <= 0)\n\t\ttime_out = 0;\n\n\twhile (more_data == MCI_GPM_MORE) {\n\t\toffset = ar9003_mci_get_next_gpm_offset(ah, &more_data);\n\t\tif (offset == MCI_GPM_INVALID)\n\t\t\tbreak;\n\n\t\tp_gpm = (u32 *) (mci->gpm_buf + offset);\n\t\trecv_type = MCI_GPM_TYPE(p_gpm);\n\t\trecv_opcode = MCI_GPM_OPCODE(p_gpm);\n\n\t\tif (!MCI_GPM_IS_CAL_TYPE(recv_type))\n\t\t\tar9003_mci_process_gpm_extra(ah, recv_type,\n\t\t\t\t\t\t     recv_opcode, p_gpm);\n\n\t\tMCI_GPM_RECYCLE(p_gpm);\n\t}\n\n\treturn time_out;\n}\n\nbool ar9003_mci_start_reset(struct ath_hw *ah, struct ath9k_channel *chan)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_hw_mci *mci_hw = &ah->btcoex_hw.mci;\n\tu32 payload[4] = {0, 0, 0, 0};\n\n\tar9003_mci_2g5g_changed(ah, IS_CHAN_2GHZ(chan));\n\n\tif (mci_hw->bt_state != MCI_BT_CAL_START)\n\t\treturn false;\n\n\tmci_hw->bt_state = MCI_BT_CAL;\n\n\t \n\tar9003_mci_disable_interrupt(ah);\n\n\tMCI_GPM_SET_CAL_TYPE(payload, MCI_GPM_WLAN_CAL_GRANT);\n\tar9003_mci_send_message(ah, MCI_GPM, 0, payload,\n\t\t\t\t16, true, false);\n\n\t \n\n\tif (ar9003_mci_wait_for_gpm(ah, MCI_GPM_BT_CAL_DONE,\n\t\t\t\t    0, 25000))\n\t\tath_dbg(common, MCI, \"MCI BT_CAL_DONE received\\n\");\n\telse\n\t\tath_dbg(common, MCI,\n\t\t\t\"MCI BT_CAL_DONE not received\\n\");\n\n\tmci_hw->bt_state = MCI_BT_AWAKE;\n\t \n\tar9003_mci_enable_interrupt(ah);\n\n\treturn true;\n}\n\nint ar9003_mci_end_reset(struct ath_hw *ah, struct ath9k_channel *chan,\n\t\t\t struct ath9k_hw_cal_data *caldata)\n{\n\tstruct ath9k_hw_mci *mci_hw = &ah->btcoex_hw.mci;\n\n\tif (!mci_hw->ready)\n\t\treturn 0;\n\n\tif (!IS_CHAN_2GHZ(chan) || (mci_hw->bt_state != MCI_BT_SLEEP))\n\t\tgoto exit;\n\n\tif (!ar9003_mci_check_int(ah, AR_MCI_INTERRUPT_RX_MSG_REMOTE_RESET) &&\n\t    !ar9003_mci_check_int(ah, AR_MCI_INTERRUPT_RX_MSG_REQ_WAKE))\n\t\tgoto exit;\n\n\t \n\tREG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_RAW,\n\t\t  (AR_MCI_INTERRUPT_RX_MSG_REMOTE_RESET |\n\t\t   AR_MCI_INTERRUPT_RX_MSG_REQ_WAKE));\n\n\tar9003_mci_remote_reset(ah, true);\n\tar9003_mci_send_sys_waking(ah, true);\n\tudelay(1);\n\n\tif (IS_CHAN_2GHZ(chan))\n\t\tar9003_mci_send_lna_transfer(ah, true);\n\n\tmci_hw->bt_state = MCI_BT_AWAKE;\n\n\tREG_CLR_BIT(ah, AR_PHY_TIMING4,\n\t\t    1 << AR_PHY_TIMING_CONTROL4_DO_GAIN_DC_IQ_CAL_SHIFT);\n\n\tif (caldata) {\n\t\tclear_bit(TXIQCAL_DONE, &caldata->cal_flags);\n\t\tclear_bit(TXCLCAL_DONE, &caldata->cal_flags);\n\t\tclear_bit(RTT_DONE, &caldata->cal_flags);\n\t}\n\n\tif (!ath9k_hw_init_cal(ah, chan))\n\t\treturn -EIO;\n\n\tREG_SET_BIT(ah, AR_PHY_TIMING4,\n\t\t    1 << AR_PHY_TIMING_CONTROL4_DO_GAIN_DC_IQ_CAL_SHIFT);\n\nexit:\n\tar9003_mci_enable_interrupt(ah);\n\treturn 0;\n}\n\nstatic void ar9003_mci_mute_bt(struct ath_hw *ah)\n{\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\n\t \n\tREG_WRITE(ah, AR_MCI_MSG_ATTRIBUTES_TABLE, 0xffff0000);\n\tREG_WRITE(ah, AR_BTCOEX_WL_WEIGHTS0, 0xffffffff);\n\tREG_WRITE(ah, AR_BTCOEX_WL_WEIGHTS1, 0xffffffff);\n\tREG_WRITE(ah, AR_BTCOEX_WL_WEIGHTS2, 0xffffffff);\n\tREG_WRITE(ah, AR_BTCOEX_WL_WEIGHTS3, 0xffffffff);\n\tREG_SET_BIT(ah, AR_MCI_TX_CTRL, AR_MCI_TX_CTRL_DISABLE_LNA_UPDATE);\n\n\t \n\tudelay(10);\n\n\t \n\tif (MCI_ANT_ARCH_PA_LNA_SHARED(mci)) {\n\t\tar9003_mci_send_lna_take(ah, true);\n\t\tudelay(5);\n\t}\n\n\tar9003_mci_send_sys_sleeping(ah, true);\n}\n\nstatic void ar9003_mci_osla_setup(struct ath_hw *ah, bool enable)\n{\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\tu32 thresh;\n\n\tif (!enable) {\n\t\tREG_CLR_BIT(ah, AR_BTCOEX_CTRL,\n\t\t\t    AR_BTCOEX_CTRL_ONE_STEP_LOOK_AHEAD_EN);\n\t\treturn;\n\t}\n\tREG_RMW_FIELD(ah, AR_MCI_SCHD_TABLE_2, AR_MCI_SCHD_TABLE_2_HW_BASED, 1);\n\tREG_RMW_FIELD(ah, AR_MCI_SCHD_TABLE_2,\n\t\t      AR_MCI_SCHD_TABLE_2_MEM_BASED, 1);\n\n\tif (AR_SREV_9565(ah))\n\t\tREG_RMW_FIELD(ah, AR_MCI_MISC, AR_MCI_MISC_HW_FIX_EN, 1);\n\n\tif (!(mci->config & ATH_MCI_CONFIG_DISABLE_AGGR_THRESH)) {\n\t\tthresh = MS(mci->config, ATH_MCI_CONFIG_AGGR_THRESH);\n\t\tREG_RMW_FIELD(ah, AR_BTCOEX_CTRL,\n\t\t\t      AR_BTCOEX_CTRL_AGGR_THRESH, thresh);\n\t\tREG_RMW_FIELD(ah, AR_BTCOEX_CTRL,\n\t\t\t      AR_BTCOEX_CTRL_TIME_TO_NEXT_BT_THRESH_EN, 1);\n\t} else\n\t\tREG_RMW_FIELD(ah, AR_BTCOEX_CTRL,\n\t\t\t      AR_BTCOEX_CTRL_TIME_TO_NEXT_BT_THRESH_EN, 0);\n\n\tREG_RMW_FIELD(ah, AR_BTCOEX_CTRL,\n\t\t      AR_BTCOEX_CTRL_ONE_STEP_LOOK_AHEAD_EN, 1);\n}\n\nstatic void ar9003_mci_stat_setup(struct ath_hw *ah)\n{\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\n\tif (!AR_SREV_9565(ah))\n\t\treturn;\n\n\tif (mci->config & ATH_MCI_CONFIG_MCI_STAT_DBG) {\n\t\tREG_RMW_FIELD(ah, AR_MCI_DBG_CNT_CTRL,\n\t\t\t      AR_MCI_DBG_CNT_CTRL_ENABLE, 1);\n\t\tREG_RMW_FIELD(ah, AR_MCI_DBG_CNT_CTRL,\n\t\t\t      AR_MCI_DBG_CNT_CTRL_BT_LINKID,\n\t\t\t      MCI_STAT_ALL_BT_LINKID);\n\t} else {\n\t\tREG_RMW_FIELD(ah, AR_MCI_DBG_CNT_CTRL,\n\t\t\t      AR_MCI_DBG_CNT_CTRL_ENABLE, 0);\n\t}\n}\n\nstatic void ar9003_mci_set_btcoex_ctrl_9565_1ANT(struct ath_hw *ah)\n{\n\tu32 regval;\n\n\tregval = SM(1, AR_BTCOEX_CTRL_AR9462_MODE) |\n\t\t SM(1, AR_BTCOEX_CTRL_WBTIMER_EN) |\n\t\t SM(1, AR_BTCOEX_CTRL_PA_SHARED) |\n\t\t SM(1, AR_BTCOEX_CTRL_LNA_SHARED) |\n\t\t SM(1, AR_BTCOEX_CTRL_NUM_ANTENNAS) |\n\t\t SM(1, AR_BTCOEX_CTRL_RX_CHAIN_MASK) |\n\t\t SM(0, AR_BTCOEX_CTRL_1_CHAIN_ACK) |\n\t\t SM(0, AR_BTCOEX_CTRL_1_CHAIN_BCN) |\n\t\t SM(0, AR_BTCOEX_CTRL_ONE_STEP_LOOK_AHEAD_EN);\n\n\tREG_RMW_FIELD(ah, AR_BTCOEX_CTRL2,\n\t\t      AR_BTCOEX_CTRL2_TX_CHAIN_MASK, 0x1);\n\tREG_WRITE(ah, AR_BTCOEX_CTRL, regval);\n}\n\nstatic void ar9003_mci_set_btcoex_ctrl_9565_2ANT(struct ath_hw *ah)\n{\n\tu32 regval;\n\n\tregval = SM(1, AR_BTCOEX_CTRL_AR9462_MODE) |\n\t\t SM(1, AR_BTCOEX_CTRL_WBTIMER_EN) |\n\t\t SM(0, AR_BTCOEX_CTRL_PA_SHARED) |\n\t\t SM(0, AR_BTCOEX_CTRL_LNA_SHARED) |\n\t\t SM(2, AR_BTCOEX_CTRL_NUM_ANTENNAS) |\n\t\t SM(1, AR_BTCOEX_CTRL_RX_CHAIN_MASK) |\n\t\t SM(0, AR_BTCOEX_CTRL_1_CHAIN_ACK) |\n\t\t SM(0, AR_BTCOEX_CTRL_1_CHAIN_BCN) |\n\t\t SM(0, AR_BTCOEX_CTRL_ONE_STEP_LOOK_AHEAD_EN);\n\n\tREG_RMW_FIELD(ah, AR_BTCOEX_CTRL2,\n\t\t      AR_BTCOEX_CTRL2_TX_CHAIN_MASK, 0x0);\n\tREG_WRITE(ah, AR_BTCOEX_CTRL, regval);\n}\n\nstatic void ar9003_mci_set_btcoex_ctrl_9462(struct ath_hw *ah)\n{\n\tu32 regval;\n\n        regval = SM(1, AR_BTCOEX_CTRL_AR9462_MODE) |\n\t\t SM(1, AR_BTCOEX_CTRL_WBTIMER_EN) |\n\t\t SM(1, AR_BTCOEX_CTRL_PA_SHARED) |\n\t\t SM(1, AR_BTCOEX_CTRL_LNA_SHARED) |\n\t\t SM(2, AR_BTCOEX_CTRL_NUM_ANTENNAS) |\n\t\t SM(3, AR_BTCOEX_CTRL_RX_CHAIN_MASK) |\n\t\t SM(0, AR_BTCOEX_CTRL_1_CHAIN_ACK) |\n\t\t SM(0, AR_BTCOEX_CTRL_1_CHAIN_BCN) |\n\t\t SM(0, AR_BTCOEX_CTRL_ONE_STEP_LOOK_AHEAD_EN);\n\n\tREG_WRITE(ah, AR_BTCOEX_CTRL, regval);\n}\n\nint ar9003_mci_reset(struct ath_hw *ah, bool en_int, bool is_2g,\n\t\t     bool is_full_sleep)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\tu32 regval, i;\n\n\tath_dbg(common, MCI, \"MCI Reset (full_sleep = %d, is_2g = %d)\\n\",\n\t\tis_full_sleep, is_2g);\n\n\tif (REG_READ(ah, AR_BTCOEX_CTRL) == 0xdeadbeef) {\n\t\tath_err(common, \"BTCOEX control register is dead\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tREG_WRITE(ah, AR_MCI_GPM_0, mci->gpm_addr);\n\tREG_WRITE(ah, AR_MCI_GPM_1, mci->gpm_len);\n\tREG_WRITE(ah, AR_MCI_SCHD_TABLE_0, mci->sched_addr);\n\n\t \n\tif (AR_SREV_9565(ah)) {\n\t\tu8 ant = MS(mci->config, ATH_MCI_CONFIG_ANT_ARCH);\n\n\t\tif (ant == ATH_MCI_ANT_ARCH_1_ANT_PA_LNA_SHARED)\n\t\t\tar9003_mci_set_btcoex_ctrl_9565_1ANT(ah);\n\t\telse\n\t\t\tar9003_mci_set_btcoex_ctrl_9565_2ANT(ah);\n\t} else {\n\t\tar9003_mci_set_btcoex_ctrl_9462(ah);\n\t}\n\n\tif (is_2g && !(mci->config & ATH_MCI_CONFIG_DISABLE_OSLA))\n\t\tar9003_mci_osla_setup(ah, true);\n\telse\n\t\tar9003_mci_osla_setup(ah, false);\n\n\tREG_SET_BIT(ah, AR_PHY_GLB_CONTROL,\n\t\t    AR_BTCOEX_CTRL_SPDT_ENABLE);\n\tREG_RMW_FIELD(ah, AR_BTCOEX_CTRL3,\n\t\t      AR_BTCOEX_CTRL3_CONT_INFO_TIMEOUT, 20);\n\n\tREG_RMW_FIELD(ah, AR_BTCOEX_CTRL2, AR_BTCOEX_CTRL2_RX_DEWEIGHT, 0);\n\tREG_RMW_FIELD(ah, AR_PCU_MISC, AR_PCU_BT_ANT_PREVENT_RX, 0);\n\n\t \n\tREG_RMW_FIELD(ah, AR_BTCOEX_WL_LNA, AR_BTCOEX_WL_LNA_TIMEOUT, 0x3D090);\n\n\t \n\tif (mci->config & ATH_MCI_CONFIG_CONCUR_TX) {\n\t\tREG_RMW_FIELD(ah, AR_BTCOEX_CTRL2,\n\t\t\t      AR_BTCOEX_CTRL2_DESC_BASED_TXPWR_ENABLE, 0);\n\t\tREG_RMW_FIELD(ah, AR_BTCOEX_CTRL2,\n\t\t\t      AR_BTCOEX_CTRL2_TXPWR_THRESH, 0x7f);\n\t\tREG_RMW_FIELD(ah, AR_BTCOEX_CTRL,\n\t\t\t      AR_BTCOEX_CTRL_REDUCE_TXPWR, 0);\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tREG_WRITE(ah, AR_BTCOEX_MAX_TXPWR(i), 0x7f7f7f7f);\n\t}\n\n\tregval = MS(mci->config, ATH_MCI_CONFIG_CLK_DIV);\n\tREG_RMW_FIELD(ah, AR_MCI_TX_CTRL, AR_MCI_TX_CTRL_CLK_DIV, regval);\n\tREG_SET_BIT(ah, AR_BTCOEX_CTRL, AR_BTCOEX_CTRL_MCI_MODE_EN);\n\n\t \n\tregval = REG_READ(ah, AR_MCI_COMMAND2);\n\tregval |= SM(1, AR_MCI_COMMAND2_RESET_TX);\n\tREG_WRITE(ah, AR_MCI_COMMAND2, regval);\n\n\tudelay(1);\n\n\tregval &= ~SM(1, AR_MCI_COMMAND2_RESET_TX);\n\tREG_WRITE(ah, AR_MCI_COMMAND2, regval);\n\n\tif (is_full_sleep) {\n\t\tar9003_mci_mute_bt(ah);\n\t\tudelay(100);\n\t}\n\n\t \n\tar9003_mci_check_gpm_offset(ah);\n\n\tregval |= SM(1, AR_MCI_COMMAND2_RESET_RX);\n\tREG_WRITE(ah, AR_MCI_COMMAND2, regval);\n\tudelay(1);\n\tregval &= ~SM(1, AR_MCI_COMMAND2_RESET_RX);\n\tREG_WRITE(ah, AR_MCI_COMMAND2, regval);\n\n\t \n\tar9003_mci_state(ah, MCI_STATE_INIT_GPM_OFFSET);\n\n\tREG_WRITE(ah, AR_MCI_MSG_ATTRIBUTES_TABLE,\n\t\t  (SM(0xe801, AR_MCI_MSG_ATTRIBUTES_TABLE_INVALID_HDR) |\n\t\t   SM(0x0000, AR_MCI_MSG_ATTRIBUTES_TABLE_CHECKSUM)));\n\n\tif (MCI_ANT_ARCH_PA_LNA_SHARED(mci))\n\t\tREG_CLR_BIT(ah, AR_MCI_TX_CTRL,\n\t\t\t    AR_MCI_TX_CTRL_DISABLE_LNA_UPDATE);\n\telse\n\t\tREG_SET_BIT(ah, AR_MCI_TX_CTRL,\n\t\t\t    AR_MCI_TX_CTRL_DISABLE_LNA_UPDATE);\n\n\tar9003_mci_observation_set_up(ah);\n\n\tmci->ready = true;\n\tar9003_mci_prep_interface(ah);\n\tar9003_mci_stat_setup(ah);\n\n\tif (en_int)\n\t\tar9003_mci_enable_interrupt(ah);\n\n\tif (ath9k_hw_is_aic_enabled(ah))\n\t\tar9003_aic_start_normal(ah);\n\n\treturn 0;\n}\n\nvoid ar9003_mci_stop_bt(struct ath_hw *ah, bool save_fullsleep)\n{\n\tstruct ath9k_hw_mci *mci_hw = &ah->btcoex_hw.mci;\n\n\tar9003_mci_disable_interrupt(ah);\n\n\tif (mci_hw->ready && !save_fullsleep) {\n\t\tar9003_mci_mute_bt(ah);\n\t\tudelay(20);\n\t\tREG_WRITE(ah, AR_BTCOEX_CTRL, 0);\n\t}\n\n\tmci_hw->bt_state = MCI_BT_SLEEP;\n\tmci_hw->ready = false;\n}\n\nstatic void ar9003_mci_send_2g5g_status(struct ath_hw *ah, bool wait_done)\n{\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\tu32 to_set, to_clear;\n\n\tif (!mci->update_2g5g || (mci->bt_state == MCI_BT_SLEEP))\n\t\treturn;\n\n\tif (mci->is_2g) {\n\t\tto_clear = MCI_2G_FLAGS_CLEAR_MASK;\n\t\tto_set = MCI_2G_FLAGS_SET_MASK;\n\t} else {\n\t\tto_clear = MCI_5G_FLAGS_CLEAR_MASK;\n\t\tto_set = MCI_5G_FLAGS_SET_MASK;\n\t}\n\n\tif (to_clear)\n\t\tar9003_mci_send_coex_bt_flags(ah, wait_done,\n\t\t\t\t\t      MCI_GPM_COEX_BT_FLAGS_CLEAR,\n\t\t\t\t\t      to_clear);\n\tif (to_set)\n\t\tar9003_mci_send_coex_bt_flags(ah, wait_done,\n\t\t\t\t\t      MCI_GPM_COEX_BT_FLAGS_SET,\n\t\t\t\t\t      to_set);\n}\n\nstatic void ar9003_mci_queue_unsent_gpm(struct ath_hw *ah, u8 header,\n\t\t\t\t\tu32 *payload, bool queue)\n{\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\tu8 type, opcode;\n\n\t \n\tif (header != MCI_GPM)\n\t\treturn;\n\n\ttype = MCI_GPM_TYPE(payload);\n\topcode = MCI_GPM_OPCODE(payload);\n\n\tif (type != MCI_GPM_COEX_AGENT)\n\t\treturn;\n\n\tswitch (opcode) {\n\tcase MCI_GPM_COEX_BT_UPDATE_FLAGS:\n\t\tif (*(((u8 *)payload) + MCI_GPM_COEX_B_BT_FLAGS_OP) ==\n\t\t    MCI_GPM_COEX_BT_FLAGS_READ)\n\t\t\tbreak;\n\n\t\tmci->update_2g5g = queue;\n\n\t\tbreak;\n\tcase MCI_GPM_COEX_WLAN_CHANNELS:\n\t\tmci->wlan_channels_update = queue;\n\t\tbreak;\n\tcase MCI_GPM_COEX_HALT_BT_GPM:\n\t\tif (*(((u8 *)payload) + MCI_GPM_COEX_B_HALT_STATE) ==\n\t\t    MCI_GPM_COEX_BT_GPM_UNHALT) {\n\t\t\tmci->unhalt_bt_gpm = queue;\n\n\t\t\tif (!queue)\n\t\t\t\tmci->halted_bt_gpm = false;\n\t\t}\n\n\t\tif (*(((u8 *)payload) + MCI_GPM_COEX_B_HALT_STATE) ==\n\t\t\t\tMCI_GPM_COEX_BT_GPM_HALT) {\n\n\t\t\tmci->halted_bt_gpm = !queue;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid ar9003_mci_2g5g_switch(struct ath_hw *ah, bool force)\n{\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\n\tif (!mci->update_2g5g && !force)\n\t\treturn;\n\n\tif (mci->is_2g) {\n\t\tar9003_mci_send_2g5g_status(ah, true);\n\t\tar9003_mci_send_lna_transfer(ah, true);\n\t\tudelay(5);\n\n\t\tREG_CLR_BIT(ah, AR_MCI_TX_CTRL,\n\t\t\t    AR_MCI_TX_CTRL_DISABLE_LNA_UPDATE);\n\t\tREG_CLR_BIT(ah, AR_PHY_GLB_CONTROL,\n\t\t\t    AR_BTCOEX_CTRL_BT_OWN_SPDT_CTRL);\n\n\t\tif (!(mci->config & ATH_MCI_CONFIG_DISABLE_OSLA))\n\t\t\tar9003_mci_osla_setup(ah, true);\n\n\t\tif (AR_SREV_9462(ah))\n\t\t\tREG_WRITE(ah, AR_SELFGEN_MASK, 0x02);\n\t} else {\n\t\tar9003_mci_send_lna_take(ah, true);\n\t\tudelay(5);\n\n\t\tREG_SET_BIT(ah, AR_MCI_TX_CTRL,\n\t\t\t    AR_MCI_TX_CTRL_DISABLE_LNA_UPDATE);\n\t\tREG_SET_BIT(ah, AR_PHY_GLB_CONTROL,\n\t\t\t    AR_BTCOEX_CTRL_BT_OWN_SPDT_CTRL);\n\n\t\tar9003_mci_osla_setup(ah, false);\n\t\tar9003_mci_send_2g5g_status(ah, true);\n\t}\n}\n\nbool ar9003_mci_send_message(struct ath_hw *ah, u8 header, u32 flag,\n\t\t\t     u32 *payload, u8 len, bool wait_done,\n\t\t\t     bool check_bt)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\tbool msg_sent = false;\n\tu32 regval;\n\tu32 saved_mci_int_en;\n\tint i;\n\n\tsaved_mci_int_en = REG_READ(ah, AR_MCI_INTERRUPT_EN);\n\tregval = REG_READ(ah, AR_BTCOEX_CTRL);\n\n\tif ((regval == 0xdeadbeef) || !(regval & AR_BTCOEX_CTRL_MCI_MODE_EN)) {\n\t\tath_dbg(common, MCI,\n\t\t\t\"MCI Not sending 0x%x. MCI is not enabled. full_sleep = %d\\n\",\n\t\t\theader, (ah->power_mode == ATH9K_PM_FULL_SLEEP) ? 1 : 0);\n\t\tar9003_mci_queue_unsent_gpm(ah, header, payload, true);\n\t\treturn false;\n\t} else if (check_bt && (mci->bt_state == MCI_BT_SLEEP)) {\n\t\tath_dbg(common, MCI,\n\t\t\t\"MCI Don't send message 0x%x. BT is in sleep state\\n\",\n\t\t\theader);\n\t\tar9003_mci_queue_unsent_gpm(ah, header, payload, true);\n\t\treturn false;\n\t}\n\n\tif (wait_done)\n\t\tREG_WRITE(ah, AR_MCI_INTERRUPT_EN, 0);\n\n\t \n\n\tREG_WRITE(ah, AR_MCI_INTERRUPT_RAW,\n\t\t  (AR_MCI_INTERRUPT_SW_MSG_DONE |\n\t\t   AR_MCI_INTERRUPT_MSG_FAIL_MASK));\n\n\tif (payload) {\n\t\tfor (i = 0; (i * 4) < len; i++)\n\t\t\tREG_WRITE(ah, (AR_MCI_TX_PAYLOAD0 + i * 4),\n\t\t\t\t  *(payload + i));\n\t}\n\n\tREG_WRITE(ah, AR_MCI_COMMAND0,\n\t\t  (SM((flag & MCI_FLAG_DISABLE_TIMESTAMP),\n\t\t      AR_MCI_COMMAND0_DISABLE_TIMESTAMP) |\n\t\t   SM(len, AR_MCI_COMMAND0_LEN) |\n\t\t   SM(header, AR_MCI_COMMAND0_HEADER)));\n\n\tif (wait_done &&\n\t    !(ar9003_mci_wait_for_interrupt(ah, AR_MCI_INTERRUPT_RAW,\n\t\t\t\t\t    AR_MCI_INTERRUPT_SW_MSG_DONE, 500)))\n\t\tar9003_mci_queue_unsent_gpm(ah, header, payload, true);\n\telse {\n\t\tar9003_mci_queue_unsent_gpm(ah, header, payload, false);\n\t\tmsg_sent = true;\n\t}\n\n\tif (wait_done)\n\t\tREG_WRITE(ah, AR_MCI_INTERRUPT_EN, saved_mci_int_en);\n\n\treturn msg_sent;\n}\nEXPORT_SYMBOL(ar9003_mci_send_message);\n\nvoid ar9003_mci_init_cal_req(struct ath_hw *ah, bool *is_reusable)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_hw_mci *mci_hw = &ah->btcoex_hw.mci;\n\tu32 pld[4] = {0, 0, 0, 0};\n\n\tif ((mci_hw->bt_state != MCI_BT_AWAKE) ||\n\t    (mci_hw->config & ATH_MCI_CONFIG_DISABLE_MCI_CAL))\n\t\treturn;\n\n\tMCI_GPM_SET_CAL_TYPE(pld, MCI_GPM_WLAN_CAL_REQ);\n\tpld[MCI_GPM_WLAN_CAL_W_SEQUENCE] = mci_hw->wlan_cal_seq++;\n\n\tar9003_mci_send_message(ah, MCI_GPM, 0, pld, 16, true, false);\n\n\tif (ar9003_mci_wait_for_gpm(ah, MCI_GPM_BT_CAL_GRANT, 0, 50000)) {\n\t\tath_dbg(common, MCI, \"MCI BT_CAL_GRANT received\\n\");\n\t} else {\n\t\t*is_reusable = false;\n\t\tath_dbg(common, MCI, \"MCI BT_CAL_GRANT not received\\n\");\n\t}\n}\n\nvoid ar9003_mci_init_cal_done(struct ath_hw *ah)\n{\n\tstruct ath9k_hw_mci *mci_hw = &ah->btcoex_hw.mci;\n\tu32 pld[4] = {0, 0, 0, 0};\n\n\tif ((mci_hw->bt_state != MCI_BT_AWAKE) ||\n\t    (mci_hw->config & ATH_MCI_CONFIG_DISABLE_MCI_CAL))\n\t\treturn;\n\n\tMCI_GPM_SET_CAL_TYPE(pld, MCI_GPM_WLAN_CAL_DONE);\n\tpld[MCI_GPM_WLAN_CAL_W_SEQUENCE] = mci_hw->wlan_cal_done++;\n\tar9003_mci_send_message(ah, MCI_GPM, 0, pld, 16, true, false);\n}\n\nint ar9003_mci_setup(struct ath_hw *ah, u32 gpm_addr, void *gpm_buf,\n\t\t     u16 len, u32 sched_addr)\n{\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\n\tmci->gpm_addr = gpm_addr;\n\tmci->gpm_buf = gpm_buf;\n\tmci->gpm_len = len;\n\tmci->sched_addr = sched_addr;\n\n\treturn ar9003_mci_reset(ah, true, true, true);\n}\nEXPORT_SYMBOL(ar9003_mci_setup);\n\nvoid ar9003_mci_cleanup(struct ath_hw *ah)\n{\n\t \n\tREG_WRITE(ah, AR_BTCOEX_CTRL, 0x00);\n\tar9003_mci_disable_interrupt(ah);\n}\nEXPORT_SYMBOL(ar9003_mci_cleanup);\n\nu32 ar9003_mci_state(struct ath_hw *ah, u32 state_type)\n{\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\tu32 value = 0, tsf;\n\tu8 query_type;\n\n\tswitch (state_type) {\n\tcase MCI_STATE_ENABLE:\n\t\tif (mci->ready) {\n\t\t\tvalue = REG_READ(ah, AR_BTCOEX_CTRL);\n\n\t\t\tif ((value == 0xdeadbeef) || (value == 0xffffffff))\n\t\t\t\tvalue = 0;\n\t\t}\n\t\tvalue &= AR_BTCOEX_CTRL_MCI_MODE_EN;\n\t\tbreak;\n\tcase MCI_STATE_INIT_GPM_OFFSET:\n\t\tvalue = MS(REG_READ(ah, AR_MCI_GPM_1), AR_MCI_GPM_WRITE_PTR);\n\n\t\tif (value < mci->gpm_len)\n\t\t\tmci->gpm_idx = value;\n\t\telse\n\t\t\tmci->gpm_idx = 0;\n\t\tbreak;\n\tcase MCI_STATE_LAST_SCHD_MSG_OFFSET:\n\t\tvalue = MS(REG_READ(ah, AR_MCI_RX_STATUS),\n\t\t\t\t    AR_MCI_RX_LAST_SCHD_MSG_INDEX);\n\t\t \n\t\tvalue <<= 4;\n\t\tbreak;\n\tcase MCI_STATE_REMOTE_SLEEP:\n\t\tvalue = MS(REG_READ(ah, AR_MCI_RX_STATUS),\n\t\t\t   AR_MCI_RX_REMOTE_SLEEP) ?\n\t\t\tMCI_BT_SLEEP : MCI_BT_AWAKE;\n\t\tbreak;\n\tcase MCI_STATE_SET_BT_AWAKE:\n\t\tmci->bt_state = MCI_BT_AWAKE;\n\t\tar9003_mci_send_coex_version_query(ah, true);\n\t\tar9003_mci_send_coex_wlan_channels(ah, true);\n\n\t\tif (mci->unhalt_bt_gpm)\n\t\t\tar9003_mci_send_coex_halt_bt_gpm(ah, false, true);\n\n\t\tar9003_mci_2g5g_switch(ah, false);\n\t\tbreak;\n\tcase MCI_STATE_RESET_REQ_WAKE:\n\t\tar9003_mci_reset_req_wakeup(ah);\n\t\tmci->update_2g5g = true;\n\n\t\tif (mci->config & ATH_MCI_CONFIG_MCI_OBS_MASK) {\n\t\t\t \n\t\t\tif ((REG_READ(ah, AR_GLB_GPIO_CONTROL) &\n\t\t\t     ATH_MCI_CONFIG_MCI_OBS_GPIO) !=\n\t\t\t    ATH_MCI_CONFIG_MCI_OBS_GPIO) {\n\t\t\t\tar9003_mci_observation_set_up(ah);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase MCI_STATE_SEND_WLAN_COEX_VERSION:\n\t\tar9003_mci_send_coex_version_response(ah, true);\n\t\tbreak;\n\tcase MCI_STATE_SEND_VERSION_QUERY:\n\t\tar9003_mci_send_coex_version_query(ah, true);\n\t\tbreak;\n\tcase MCI_STATE_SEND_STATUS_QUERY:\n\t\tquery_type = MCI_GPM_COEX_QUERY_BT_TOPOLOGY;\n\t\tar9003_mci_send_coex_bt_status_query(ah, true, query_type);\n\t\tbreak;\n\tcase MCI_STATE_RECOVER_RX:\n\t\ttsf = ath9k_hw_gettsf32(ah);\n\t\tif ((tsf - mci->last_recovery) <= MCI_RECOVERY_DUR_TSF) {\n\t\t\tath_dbg(ath9k_hw_common(ah), MCI,\n\t\t\t\t\"(MCI) ignore Rx recovery\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tath_dbg(ath9k_hw_common(ah), MCI, \"(MCI) RECOVER RX\\n\");\n\t\tmci->last_recovery = tsf;\n\t\tar9003_mci_prep_interface(ah);\n\t\tmci->query_bt = true;\n\t\tmci->need_flush_btinfo = true;\n\t\tar9003_mci_send_coex_wlan_channels(ah, true);\n\t\tar9003_mci_2g5g_switch(ah, false);\n\t\tbreak;\n\tcase MCI_STATE_NEED_FTP_STOMP:\n\t\tvalue = !(mci->config & ATH_MCI_CONFIG_DISABLE_FTP_STOMP);\n\t\tbreak;\n\tcase MCI_STATE_NEED_FLUSH_BT_INFO:\n\t\tvalue = (!mci->unhalt_bt_gpm && mci->need_flush_btinfo) ? 1 : 0;\n\t\tmci->need_flush_btinfo = false;\n\t\tbreak;\n\tcase MCI_STATE_AIC_CAL:\n\t\tif (ath9k_hw_is_aic_enabled(ah))\n\t\t\tvalue = ar9003_aic_calibration(ah);\n\t\tbreak;\n\tcase MCI_STATE_AIC_START:\n\t\tif (ath9k_hw_is_aic_enabled(ah))\n\t\t\tar9003_aic_start_normal(ah);\n\t\tbreak;\n\tcase MCI_STATE_AIC_CAL_RESET:\n\t\tif (ath9k_hw_is_aic_enabled(ah))\n\t\t\tvalue = ar9003_aic_cal_reset(ah);\n\t\tbreak;\n\tcase MCI_STATE_AIC_CAL_SINGLE:\n\t\tif (ath9k_hw_is_aic_enabled(ah))\n\t\t\tvalue = ar9003_aic_calibration_single(ah);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn value;\n}\nEXPORT_SYMBOL(ar9003_mci_state);\n\nvoid ar9003_mci_bt_gain_ctrl(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\n\tath_dbg(common, MCI, \"Give LNA and SPDT control to BT\\n\");\n\n\tar9003_mci_send_lna_take(ah, true);\n\tudelay(50);\n\n\tREG_SET_BIT(ah, AR_PHY_GLB_CONTROL, AR_BTCOEX_CTRL_BT_OWN_SPDT_CTRL);\n\tmci->is_2g = false;\n\tmci->update_2g5g = true;\n\tar9003_mci_send_2g5g_status(ah, true);\n\n\t \n\tmci->update_2g5g = true;\n}\n\nvoid ar9003_mci_set_power_awake(struct ath_hw *ah)\n{\n\tu32 btcoex_ctrl2, diag_sw;\n\tint i;\n\tu8 lna_ctrl, bt_sleep;\n\n\tfor (i = 0; i < AH_WAIT_TIMEOUT; i++) {\n\t\tbtcoex_ctrl2 = REG_READ(ah, AR_BTCOEX_CTRL2);\n\t\tif (btcoex_ctrl2 != 0xdeadbeef)\n\t\t\tbreak;\n\t\tudelay(AH_TIME_QUANTUM);\n\t}\n\tREG_WRITE(ah, AR_BTCOEX_CTRL2, (btcoex_ctrl2 | BIT(23)));\n\n\tfor (i = 0; i < AH_WAIT_TIMEOUT; i++) {\n\t\tdiag_sw = REG_READ(ah, AR_DIAG_SW);\n\t\tif (diag_sw != 0xdeadbeef)\n\t\t\tbreak;\n\t\tudelay(AH_TIME_QUANTUM);\n\t}\n\tREG_WRITE(ah, AR_DIAG_SW, (diag_sw | BIT(27) | BIT(19) | BIT(18)));\n\tlna_ctrl = REG_READ(ah, AR_OBS_BUS_CTRL) & 0x3;\n\tbt_sleep = MS(REG_READ(ah, AR_MCI_RX_STATUS), AR_MCI_RX_REMOTE_SLEEP);\n\n\tREG_WRITE(ah, AR_BTCOEX_CTRL2, btcoex_ctrl2);\n\tREG_WRITE(ah, AR_DIAG_SW, diag_sw);\n\n\tif (bt_sleep && (lna_ctrl == 2)) {\n\t\tREG_SET_BIT(ah, AR_BTCOEX_RC, 0x1);\n\t\tREG_CLR_BIT(ah, AR_BTCOEX_RC, 0x1);\n\t\tudelay(50);\n\t}\n}\n\nvoid ar9003_mci_check_gpm_offset(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\tu32 offset;\n\n\t \n\toffset = MS(REG_READ(ah, AR_MCI_GPM_1), AR_MCI_GPM_WRITE_PTR);\n\tif (mci->gpm_idx == offset)\n\t\treturn;\n\tath_dbg(common, MCI, \"GPM cached write pointer mismatch %d %d\\n\",\n\t\tmci->gpm_idx, offset);\n\tmci->query_bt = true;\n\tmci->need_flush_btinfo = true;\n\tmci->gpm_idx = 0;\n}\n\nu32 ar9003_mci_get_next_gpm_offset(struct ath_hw *ah, u32 *more)\n{\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\tu32 offset, more_gpm = 0, gpm_ptr;\n\n\t \n\tREG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_RAW,\n\t\t\tAR_MCI_INTERRUPT_RX_MSG_GPM);\n\n\tgpm_ptr = MS(REG_READ(ah, AR_MCI_GPM_1), AR_MCI_GPM_WRITE_PTR);\n\toffset = gpm_ptr;\n\n\tif (!offset)\n\t\toffset = mci->gpm_len - 1;\n\telse if (offset >= mci->gpm_len) {\n\t\tif (offset != 0xFFFF)\n\t\t\toffset = 0;\n\t} else {\n\t\toffset--;\n\t}\n\n\tif ((offset == 0xFFFF) || (gpm_ptr == mci->gpm_idx)) {\n\t\toffset = MCI_GPM_INVALID;\n\t\tmore_gpm = MCI_GPM_NOMORE;\n\t\tgoto out;\n\t}\n\tfor (;;) {\n\t\tu32 temp_index;\n\n\t\t \n\n\t\tif (offset != mci->gpm_idx)\n\t\t\tmore_gpm = MCI_GPM_MORE;\n\t\telse\n\t\t\tmore_gpm = MCI_GPM_NOMORE;\n\n\t\ttemp_index = mci->gpm_idx;\n\n\t\tif (temp_index >= mci->gpm_len)\n\t\t\ttemp_index = 0;\n\n\t\tmci->gpm_idx++;\n\n\t\tif (mci->gpm_idx >= mci->gpm_len)\n\t\t\tmci->gpm_idx = 0;\n\n\t\tif (ar9003_mci_is_gpm_valid(ah, temp_index)) {\n\t\t\toffset = temp_index;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (more_gpm == MCI_GPM_NOMORE) {\n\t\t\toffset = MCI_GPM_INVALID;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (offset != MCI_GPM_INVALID)\n\t\toffset <<= 4;\nout:\n\tif (more)\n\t\t*more = more_gpm;\n\n\treturn offset;\n}\nEXPORT_SYMBOL(ar9003_mci_get_next_gpm_offset);\n\nvoid ar9003_mci_set_bt_version(struct ath_hw *ah, u8 major, u8 minor)\n{\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\n\tmci->bt_ver_major = major;\n\tmci->bt_ver_minor = minor;\n\tmci->bt_version_known = true;\n\tath_dbg(ath9k_hw_common(ah), MCI, \"MCI BT version set: %d.%d\\n\",\n\t\tmci->bt_ver_major, mci->bt_ver_minor);\n}\nEXPORT_SYMBOL(ar9003_mci_set_bt_version);\n\nvoid ar9003_mci_send_wlan_channels(struct ath_hw *ah)\n{\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\n\tmci->wlan_channels_update = true;\n\tar9003_mci_send_coex_wlan_channels(ah, true);\n}\nEXPORT_SYMBOL(ar9003_mci_send_wlan_channels);\n\nu16 ar9003_mci_get_max_txpower(struct ath_hw *ah, u8 ctlmode)\n{\n\tif (!ah->btcoex_hw.mci.concur_tx)\n\t\tgoto out;\n\n\tif (ctlmode == CTL_2GHT20)\n\t\treturn ATH_BTCOEX_HT20_MAX_TXPOWER;\n\telse if (ctlmode == CTL_2GHT40)\n\t\treturn ATH_BTCOEX_HT40_MAX_TXPOWER;\n\nout:\n\treturn -1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}