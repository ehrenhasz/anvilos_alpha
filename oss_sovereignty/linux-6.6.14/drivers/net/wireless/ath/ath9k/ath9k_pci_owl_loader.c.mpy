{
  "module_name": "ath9k_pci_owl_loader.c",
  "hash_id": "53550b9a5bf80e83fc1946717da20a4529825ff20ebe1d3ce7efce62917e838f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/ath9k_pci_owl_loader.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/completion.h>\n#include <linux/etherdevice.h>\n#include <linux/firmware.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/ath9k_platform.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/workqueue.h>\n\nstruct owl_ctx {\n\tstruct pci_dev *pdev;\n\tstruct completion eeprom_load;\n\tstruct work_struct work;\n\tstruct nvmem_cell *cell;\n};\n\n#define EEPROM_FILENAME_LEN 100\n\n#define AR5416_EEPROM_MAGIC 0xa55a\n\nstatic int ath9k_pci_fixup(struct pci_dev *pdev, const u16 *cal_data,\n\t\t\t   size_t cal_len)\n{\n\tvoid __iomem *mem;\n\tconst void *cal_end = (void *)cal_data + cal_len;\n\tconst struct {\n\t\tu16 reg;\n\t\tu16 low_val;\n\t\tu16 high_val;\n\t} __packed * data;\n\tu16 cmd;\n\tu32 bar0;\n\tbool swap_needed = false;\n\n\t \n\tif (cal_len > 4096 || cal_len < 0x200 || (cal_len & 1) == 1) {\n\t\tdev_err(&pdev->dev, \"eeprom has an invalid size.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (*cal_data != AR5416_EEPROM_MAGIC) {\n\t\tif (*cal_data != swab16(AR5416_EEPROM_MAGIC)) {\n\t\t\tdev_err(&pdev->dev, \"invalid calibration data\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdev_dbg(&pdev->dev, \"calibration data needs swapping\\n\");\n\t\tswap_needed = true;\n\t}\n\n\tdev_info(&pdev->dev, \"fixup device configuration\\n\");\n\n\tmem = pcim_iomap(pdev, 0, 0);\n\tif (!mem) {\n\t\tdev_err(&pdev->dev, \"ioremap error\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpci_read_config_dword(pdev, PCI_BASE_ADDRESS_0, &bar0);\n\tpci_write_config_dword(pdev, PCI_BASE_ADDRESS_0,\n\t\t\t       pci_resource_start(pdev, 0));\n\tpci_read_config_word(pdev, PCI_COMMAND, &cmd);\n\tcmd |= PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;\n\tpci_write_config_word(pdev, PCI_COMMAND, cmd);\n\n\t \n\tfor (data = (const void *)(cal_data + 3);\n\t     (const void *)data <= cal_end && data->reg != (u16)~0;\n\t     data++) {\n\t\tu32 val;\n\t\tu16 reg;\n\n\t\treg = data->reg;\n\t\tval = data->low_val;\n\t\tval |= ((u32)data->high_val) << 16;\n\n\t\tif (swap_needed) {\n\t\t\treg = swab16(reg);\n\t\t\tval = swahb32(val);\n\t\t}\n\n\t\tiowrite32(val, mem + reg);\n\t\tusleep_range(100, 120);\n\t}\n\n\tpci_read_config_word(pdev, PCI_COMMAND, &cmd);\n\tcmd &= ~(PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY);\n\tpci_write_config_word(pdev, PCI_COMMAND, cmd);\n\n\tpci_write_config_dword(pdev, PCI_BASE_ADDRESS_0, bar0);\n\tpcim_iounmap(pdev, mem);\n\n\tpci_disable_device(pdev);\n\n\treturn 0;\n}\n\nstatic void owl_rescan(struct pci_dev *pdev)\n{\n\tstruct pci_bus *bus = pdev->bus;\n\n\tpci_lock_rescan_remove();\n\tpci_stop_and_remove_bus_device(pdev);\n\t \n\tpci_rescan_bus(bus);\n\tpci_unlock_rescan_remove();\n}\n\nstatic void owl_fw_cb(const struct firmware *fw, void *context)\n{\n\tstruct owl_ctx *ctx = (struct owl_ctx *)context;\n\n\tcomplete(&ctx->eeprom_load);\n\n\tif (fw) {\n\t\tath9k_pci_fixup(ctx->pdev, (const u16 *)fw->data, fw->size);\n\t\towl_rescan(ctx->pdev);\n\t} else {\n\t\tdev_err(&ctx->pdev->dev, \"no eeprom data received.\\n\");\n\t}\n\trelease_firmware(fw);\n}\n\nstatic const char *owl_get_eeprom_name(struct pci_dev *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tchar *eeprom_name;\n\n\tdev_dbg(dev, \"using auto-generated eeprom filename\\n\");\n\n\teeprom_name = devm_kzalloc(dev, EEPROM_FILENAME_LEN, GFP_KERNEL);\n\tif (!eeprom_name)\n\t\treturn NULL;\n\n\t \n\tscnprintf(eeprom_name, EEPROM_FILENAME_LEN, \"ath9k-eeprom-pci-%s.bin\",\n\t\t  dev_name(dev));\n\n\treturn eeprom_name;\n}\n\nstatic void owl_nvmem_work(struct work_struct *work)\n{\n\tstruct owl_ctx *ctx = container_of(work, struct owl_ctx, work);\n\tvoid *buf;\n\tsize_t len;\n\n\tcomplete(&ctx->eeprom_load);\n\n\tbuf = nvmem_cell_read(ctx->cell, &len);\n\tif (!IS_ERR(buf)) {\n\t\tath9k_pci_fixup(ctx->pdev, buf, len);\n\t\tkfree(buf);\n\t\towl_rescan(ctx->pdev);\n\t} else {\n\t\tdev_err(&ctx->pdev->dev, \"no nvmem data received.\\n\");\n\t}\n}\n\nstatic int owl_nvmem_probe(struct owl_ctx *ctx)\n{\n\tint err;\n\n\tctx->cell = devm_nvmem_cell_get(&ctx->pdev->dev, \"calibration\");\n\tif (IS_ERR(ctx->cell)) {\n\t\terr = PTR_ERR(ctx->cell);\n\t\tif (err == -ENOENT || err == -EOPNOTSUPP)\n\t\t\treturn 1;  \n\n\t\treturn err;\n\t}\n\n\tINIT_WORK(&ctx->work, owl_nvmem_work);\n\tschedule_work(&ctx->work);\n\n\treturn 0;\n}\n\nstatic int owl_probe(struct pci_dev *pdev,\n\t\t     const struct pci_device_id *id)\n{\n\tstruct owl_ctx *ctx;\n\tconst char *eeprom_name;\n\tint err = 0;\n\n\tif (pcim_enable_device(pdev))\n\t\treturn -EIO;\n\n\tpcim_pin_device(pdev);\n\n\tctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&ctx->eeprom_load);\n\tctx->pdev = pdev;\n\n\tpci_set_drvdata(pdev, ctx);\n\n\terr = owl_nvmem_probe(ctx);\n\tif (err <= 0)\n\t\treturn err;\n\n\teeprom_name = owl_get_eeprom_name(pdev);\n\tif (!eeprom_name) {\n\t\tdev_err(&pdev->dev, \"no eeprom filename found.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = request_firmware_nowait(THIS_MODULE, true, eeprom_name,\n\t\t\t\t      &pdev->dev, GFP_KERNEL, ctx, owl_fw_cb);\n\tif (err)\n\t\tdev_err(&pdev->dev, \"failed to request caldata (%d).\\n\", err);\n\n\treturn err;\n}\n\nstatic void owl_remove(struct pci_dev *pdev)\n{\n\tstruct owl_ctx *ctx = pci_get_drvdata(pdev);\n\n\tif (ctx) {\n\t\twait_for_completion(&ctx->eeprom_load);\n\t\tpci_set_drvdata(pdev, NULL);\n\t}\n}\n\nstatic const struct pci_device_id owl_pci_table[] = {\n\t{ PCI_VDEVICE(ATHEROS, 0xff1c) },  \n\t{ PCI_VDEVICE(ATHEROS, 0xff1d) },  \n\t{ },\n};\nMODULE_DEVICE_TABLE(pci, owl_pci_table);\n\nstatic struct pci_driver owl_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= owl_pci_table,\n\t.probe\t\t= owl_probe,\n\t.remove\t\t= owl_remove,\n};\nmodule_pci_driver(owl_driver);\nMODULE_AUTHOR(\"Christian Lamparter <chunkeey@gmail.com>\");\nMODULE_DESCRIPTION(\"External EEPROM data loader for Atheros AR500X to AR92XX\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}