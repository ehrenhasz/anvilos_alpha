{
  "module_name": "ani.c",
  "hash_id": "5ecdb63515e05ca584e0e4a77ecfef2d22c9ebd80ddfca08b1fded558a587bd7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/ani.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include \"hw.h\"\n#include \"hw-ops.h\"\n\nstruct ani_ofdm_level_entry {\n\tint spur_immunity_level;\n\tint fir_step_level;\n\tint ofdm_weak_signal_on;\n};\n\n \n\n \n\nstatic const struct ani_ofdm_level_entry ofdm_level_table[] = {\n\t \n\t{  0,  0,  1  },  \n\t{  1,  1,  1  },  \n\t{  2,  2,  1  },  \n\t{  3,  2,  1  },  \n\t{  4,  3,  1  },  \n\t{  5,  4,  1  },  \n\t{  6,  5,  1  },  \n\t{  7,  6,  1  },  \n\t{  7,  7,  1  },  \n\t{  7,  8,  0  }   \n};\n#define ATH9K_ANI_OFDM_NUM_LEVEL \\\n\tARRAY_SIZE(ofdm_level_table)\n#define ATH9K_ANI_OFDM_MAX_LEVEL \\\n\t(ATH9K_ANI_OFDM_NUM_LEVEL-1)\n#define ATH9K_ANI_OFDM_DEF_LEVEL \\\n\t3  \n\n \n\nstruct ani_cck_level_entry {\n\tint fir_step_level;\n\tint mrc_cck_on;\n};\n\nstatic const struct ani_cck_level_entry cck_level_table[] = {\n\t \n\t{  0,  1  },  \n\t{  1,  1  },  \n\t{  2,  1  },  \n\t{  3,  1  },  \n\t{  4,  0  },  \n\t{  5,  0  },  \n\t{  6,  0  },  \n\t{  7,  0  },  \n\t{  8,  0  }   \n};\n\n#define ATH9K_ANI_CCK_NUM_LEVEL \\\n\tARRAY_SIZE(cck_level_table)\n#define ATH9K_ANI_CCK_MAX_LEVEL \\\n\t(ATH9K_ANI_CCK_NUM_LEVEL-1)\n#define ATH9K_ANI_CCK_MAX_LEVEL_LOW_RSSI \\\n\t(ATH9K_ANI_CCK_NUM_LEVEL-3)\n#define ATH9K_ANI_CCK_DEF_LEVEL \\\n\t2  \n\nstatic void ath9k_hw_update_mibstats(struct ath_hw *ah,\n\t\t\t\t     struct ath9k_mib_stats *stats)\n{\n\tu32 addr[5] = {AR_RTS_OK, AR_RTS_FAIL, AR_ACK_FAIL,\n\t\t       AR_FCS_FAIL, AR_BEACON_CNT};\n\tu32 data[5];\n\n\tREG_READ_MULTI(ah, &addr[0], &data[0], 5);\n\t \n\tstats->rts_good += data[0];\n\t \n\tstats->rts_bad += data[1];\n\t \n\tstats->ackrcv_bad += data[2];\n\t \n\tstats->fcs_bad += data[3];\n\t \n\tstats->beacons += data[4];\n}\n\nstatic void ath9k_ani_restart(struct ath_hw *ah)\n{\n\tstruct ar5416AniState *aniState = &ah->ani;\n\n\taniState->listenTime = 0;\n\n\tENABLE_REGWRITE_BUFFER(ah);\n\n\tREG_WRITE(ah, AR_PHY_ERR_1, 0);\n\tREG_WRITE(ah, AR_PHY_ERR_2, 0);\n\tREG_WRITE(ah, AR_PHY_ERR_MASK_1, AR_PHY_ERR_OFDM_TIMING);\n\tREG_WRITE(ah, AR_PHY_ERR_MASK_2, AR_PHY_ERR_CCK_TIMING);\n\n\tREGWRITE_BUFFER_FLUSH(ah);\n\n\tath9k_hw_update_mibstats(ah, &ah->ah_mibStats);\n\n\taniState->ofdmPhyErrCount = 0;\n\taniState->cckPhyErrCount = 0;\n}\n\n \nstatic void ath9k_hw_set_ofdm_nil(struct ath_hw *ah, u8 immunityLevel,\n\t\t\t\t  bool scan)\n{\n\tstruct ar5416AniState *aniState = &ah->ani;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tconst struct ani_ofdm_level_entry *entry_ofdm;\n\tconst struct ani_cck_level_entry *entry_cck;\n\tbool weak_sig;\n\n\tath_dbg(common, ANI, \"**** ofdmlevel %d=>%d, rssi=%d[lo=%d hi=%d]\\n\",\n\t\taniState->ofdmNoiseImmunityLevel,\n\t\timmunityLevel, BEACON_RSSI(ah),\n\t\tATH9K_ANI_RSSI_THR_LOW,\n\t\tATH9K_ANI_RSSI_THR_HIGH);\n\n\tif (AR_SREV_9100(ah) && immunityLevel < ATH9K_ANI_OFDM_DEF_LEVEL)\n\t\timmunityLevel = ATH9K_ANI_OFDM_DEF_LEVEL;\n\n\tif (!scan)\n\t\taniState->ofdmNoiseImmunityLevel = immunityLevel;\n\n\tentry_ofdm = &ofdm_level_table[aniState->ofdmNoiseImmunityLevel];\n\tentry_cck = &cck_level_table[aniState->cckNoiseImmunityLevel];\n\n\tif (aniState->spurImmunityLevel != entry_ofdm->spur_immunity_level)\n\t\tath9k_hw_ani_control(ah,\n\t\t\t\t     ATH9K_ANI_SPUR_IMMUNITY_LEVEL,\n\t\t\t\t     entry_ofdm->spur_immunity_level);\n\n\tif (aniState->firstepLevel != entry_ofdm->fir_step_level &&\n\t    entry_ofdm->fir_step_level >= entry_cck->fir_step_level)\n\t\tath9k_hw_ani_control(ah,\n\t\t\t\t     ATH9K_ANI_FIRSTEP_LEVEL,\n\t\t\t\t     entry_ofdm->fir_step_level);\n\n\tweak_sig = entry_ofdm->ofdm_weak_signal_on;\n\tif (ah->opmode == NL80211_IFTYPE_STATION &&\n\t    BEACON_RSSI(ah) <= ATH9K_ANI_RSSI_THR_HIGH)\n\t\tweak_sig = true;\n\t \n\telse if (AR_SREV_9300_20_OR_LATER(ah) &&\n\t\t ah->opmode != NL80211_IFTYPE_STATION)\n\t\tweak_sig = true;\n\n\t \n\telse if (!AR_SREV_9300_20_OR_LATER(ah) &&\n\t\t aniState->ofdmNoiseImmunityLevel >= 8)\n\t\tweak_sig = false;\n\n\tif (aniState->ofdmWeakSigDetect != weak_sig)\n\t\tath9k_hw_ani_control(ah, ATH9K_ANI_OFDM_WEAK_SIGNAL_DETECTION,\n\t\t\t\t     weak_sig);\n\n\tif (!AR_SREV_9300_20_OR_LATER(ah))\n\t\treturn;\n\n\tif (aniState->ofdmNoiseImmunityLevel >= ATH9K_ANI_OFDM_DEF_LEVEL) {\n\t\tah->config.ofdm_trig_high = ATH9K_ANI_OFDM_TRIG_HIGH;\n\t\tah->config.ofdm_trig_low = ATH9K_ANI_OFDM_TRIG_LOW_ABOVE_INI;\n\t} else {\n\t\tah->config.ofdm_trig_high = ATH9K_ANI_OFDM_TRIG_HIGH_BELOW_INI;\n\t\tah->config.ofdm_trig_low = ATH9K_ANI_OFDM_TRIG_LOW;\n\t}\n}\n\nstatic void ath9k_hw_ani_ofdm_err_trigger(struct ath_hw *ah)\n{\n\tstruct ar5416AniState *aniState = &ah->ani;\n\n\tif (aniState->ofdmNoiseImmunityLevel < ATH9K_ANI_OFDM_MAX_LEVEL)\n\t\tath9k_hw_set_ofdm_nil(ah, aniState->ofdmNoiseImmunityLevel + 1, false);\n}\n\n \nstatic void ath9k_hw_set_cck_nil(struct ath_hw *ah, u_int8_t immunityLevel,\n\t\t\t\t bool scan)\n{\n\tstruct ar5416AniState *aniState = &ah->ani;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tconst struct ani_ofdm_level_entry *entry_ofdm;\n\tconst struct ani_cck_level_entry *entry_cck;\n\n\tath_dbg(common, ANI, \"**** ccklevel %d=>%d, rssi=%d[lo=%d hi=%d]\\n\",\n\t\taniState->cckNoiseImmunityLevel, immunityLevel,\n\t\tBEACON_RSSI(ah), ATH9K_ANI_RSSI_THR_LOW,\n\t\tATH9K_ANI_RSSI_THR_HIGH);\n\n\tif (AR_SREV_9100(ah) && immunityLevel < ATH9K_ANI_CCK_DEF_LEVEL)\n\t\timmunityLevel = ATH9K_ANI_CCK_DEF_LEVEL;\n\n\tif (ah->opmode == NL80211_IFTYPE_STATION &&\n\t    BEACON_RSSI(ah) <= ATH9K_ANI_RSSI_THR_LOW &&\n\t    immunityLevel > ATH9K_ANI_CCK_MAX_LEVEL_LOW_RSSI)\n\t\timmunityLevel = ATH9K_ANI_CCK_MAX_LEVEL_LOW_RSSI;\n\n\tif (!scan)\n\t\taniState->cckNoiseImmunityLevel = immunityLevel;\n\n\tentry_ofdm = &ofdm_level_table[aniState->ofdmNoiseImmunityLevel];\n\tentry_cck = &cck_level_table[aniState->cckNoiseImmunityLevel];\n\n\tif (aniState->firstepLevel != entry_cck->fir_step_level &&\n\t    entry_cck->fir_step_level >= entry_ofdm->fir_step_level)\n\t\tath9k_hw_ani_control(ah,\n\t\t\t\t     ATH9K_ANI_FIRSTEP_LEVEL,\n\t\t\t\t     entry_cck->fir_step_level);\n\n\t \n\tif (!AR_SREV_9300_20_OR_LATER(ah) || AR_SREV_9485(ah) ||\n\t    AR_SREV_9565(ah) || AR_SREV_9561(ah))\n\t\treturn;\n\n\tif (aniState->mrcCCK != entry_cck->mrc_cck_on)\n\t\tath9k_hw_ani_control(ah,\n\t\t\t\t     ATH9K_ANI_MRC_CCK,\n\t\t\t\t     entry_cck->mrc_cck_on);\n}\n\nstatic void ath9k_hw_ani_cck_err_trigger(struct ath_hw *ah)\n{\n\tstruct ar5416AniState *aniState = &ah->ani;\n\n\tif (aniState->cckNoiseImmunityLevel < ATH9K_ANI_CCK_MAX_LEVEL)\n\t\tath9k_hw_set_cck_nil(ah, aniState->cckNoiseImmunityLevel + 1,\n\t\t\t\t     false);\n}\n\n \nstatic void ath9k_hw_ani_lower_immunity(struct ath_hw *ah)\n{\n\tstruct ar5416AniState *aniState = &ah->ani;\n\n\t \n\tif (aniState->ofdmNoiseImmunityLevel > 0 &&\n\t    (aniState->ofdmsTurn || aniState->cckNoiseImmunityLevel == 0)) {\n\t\tath9k_hw_set_ofdm_nil(ah, aniState->ofdmNoiseImmunityLevel - 1,\n\t\t\t\t      false);\n\t\treturn;\n\t}\n\n\t \n\tif (aniState->cckNoiseImmunityLevel > 0)\n\t\tath9k_hw_set_cck_nil(ah, aniState->cckNoiseImmunityLevel - 1,\n\t\t\t\t     false);\n}\n\n \nvoid ath9k_ani_reset(struct ath_hw *ah, bool is_scanning)\n{\n\tstruct ar5416AniState *aniState = &ah->ani;\n\tstruct ath9k_channel *chan = ah->curchan;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tint ofdm_nil, cck_nil;\n\n\tif (!chan)\n\t\treturn;\n\n\tBUG_ON(aniState == NULL);\n\tah->stats.ast_ani_reset++;\n\n\tofdm_nil = max_t(int, ATH9K_ANI_OFDM_DEF_LEVEL,\n\t\t\t aniState->ofdmNoiseImmunityLevel);\n\tcck_nil = max_t(int, ATH9K_ANI_CCK_DEF_LEVEL,\n\t\t\t aniState->cckNoiseImmunityLevel);\n\n\tif (is_scanning ||\n\t    (ah->opmode != NL80211_IFTYPE_STATION &&\n\t     ah->opmode != NL80211_IFTYPE_ADHOC)) {\n\t\t \n\t\tif (aniState->ofdmNoiseImmunityLevel !=\n\t\t    ATH9K_ANI_OFDM_DEF_LEVEL ||\n\t\t    aniState->cckNoiseImmunityLevel !=\n\t\t    ATH9K_ANI_CCK_DEF_LEVEL) {\n\t\t\tath_dbg(common, ANI,\n\t\t\t\t\"Restore defaults: opmode %u chan %d Mhz is_scanning=%d ofdm:%d cck:%d\\n\",\n\t\t\t\tah->opmode,\n\t\t\t\tchan->channel,\n\t\t\t\tis_scanning,\n\t\t\t\taniState->ofdmNoiseImmunityLevel,\n\t\t\t\taniState->cckNoiseImmunityLevel);\n\n\t\t\tofdm_nil = ATH9K_ANI_OFDM_DEF_LEVEL;\n\t\t\tcck_nil = ATH9K_ANI_CCK_DEF_LEVEL;\n\t\t}\n\t} else {\n\t\t \n\t\tath_dbg(common, ANI,\n\t\t\t\"Restore history: opmode %u chan %d Mhz is_scanning=%d ofdm:%d cck:%d\\n\",\n\t\t\tah->opmode,\n\t\t\tchan->channel,\n\t\t\tis_scanning,\n\t\t\taniState->ofdmNoiseImmunityLevel,\n\t\t\taniState->cckNoiseImmunityLevel);\n\t}\n\tath9k_hw_set_ofdm_nil(ah, ofdm_nil, is_scanning);\n\tath9k_hw_set_cck_nil(ah, cck_nil, is_scanning);\n\n\tath9k_ani_restart(ah);\n}\n\nstatic bool ath9k_hw_ani_read_counters(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ar5416AniState *aniState = &ah->ani;\n\tu32 phyCnt1, phyCnt2;\n\tint32_t listenTime;\n\n\tath_hw_cycle_counters_update(common);\n\tlistenTime = ath_hw_get_listen_time(common);\n\n\tif (listenTime <= 0) {\n\t\tah->stats.ast_ani_lneg_or_lzero++;\n\t\tath9k_ani_restart(ah);\n\t\treturn false;\n\t}\n\n\taniState->listenTime += listenTime;\n\n\tath9k_hw_update_mibstats(ah, &ah->ah_mibStats);\n\n\tphyCnt1 = REG_READ(ah, AR_PHY_ERR_1);\n\tphyCnt2 = REG_READ(ah, AR_PHY_ERR_2);\n\n\tah->stats.ast_ani_ofdmerrs += phyCnt1 - aniState->ofdmPhyErrCount;\n\taniState->ofdmPhyErrCount = phyCnt1;\n\n\tah->stats.ast_ani_cckerrs += phyCnt2 - aniState->cckPhyErrCount;\n\taniState->cckPhyErrCount = phyCnt2;\n\n\treturn true;\n}\n\nvoid ath9k_hw_ani_monitor(struct ath_hw *ah, struct ath9k_channel *chan)\n{\n\tstruct ar5416AniState *aniState = &ah->ani;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tu32 ofdmPhyErrRate, cckPhyErrRate;\n\n\tif (!ath9k_hw_ani_read_counters(ah))\n\t\treturn;\n\n\tofdmPhyErrRate = aniState->ofdmPhyErrCount * 1000 /\n\t\t\t aniState->listenTime;\n\tcckPhyErrRate =  aniState->cckPhyErrCount * 1000 /\n\t\t\t aniState->listenTime;\n\n\tath_dbg(common, ANI,\n\t\t\"listenTime=%d OFDM:%d errs=%d/s CCK:%d errs=%d/s ofdm_turn=%d\\n\",\n\t\taniState->listenTime,\n\t\taniState->ofdmNoiseImmunityLevel,\n\t\tofdmPhyErrRate, aniState->cckNoiseImmunityLevel,\n\t\tcckPhyErrRate, aniState->ofdmsTurn);\n\n\tif (aniState->listenTime > ah->aniperiod) {\n\t\tif (cckPhyErrRate < ah->config.cck_trig_low &&\n\t\t    ofdmPhyErrRate < ah->config.ofdm_trig_low) {\n\t\t\tath9k_hw_ani_lower_immunity(ah);\n\t\t\taniState->ofdmsTurn = !aniState->ofdmsTurn;\n\t\t} else if (ofdmPhyErrRate > ah->config.ofdm_trig_high) {\n\t\t\tath9k_hw_ani_ofdm_err_trigger(ah);\n\t\t\taniState->ofdmsTurn = false;\n\t\t} else if (cckPhyErrRate > ah->config.cck_trig_high) {\n\t\t\tath9k_hw_ani_cck_err_trigger(ah);\n\t\t\taniState->ofdmsTurn = true;\n\t\t} else\n\t\t\treturn;\n\t\t\t\n\t\tath9k_ani_restart(ah);\n\t}\n}\nEXPORT_SYMBOL(ath9k_hw_ani_monitor);\n\nvoid ath9k_enable_mib_counters(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tath_dbg(common, ANI, \"Enable MIB counters\\n\");\n\n\tath9k_hw_update_mibstats(ah, &ah->ah_mibStats);\n\n\tENABLE_REGWRITE_BUFFER(ah);\n\n\tREG_WRITE(ah, AR_FILT_OFDM, 0);\n\tREG_WRITE(ah, AR_FILT_CCK, 0);\n\tREG_WRITE(ah, AR_MIBC,\n\t\t  ~(AR_MIBC_COW | AR_MIBC_FMC | AR_MIBC_CMC | AR_MIBC_MCS)\n\t\t  & 0x0f);\n\tREG_WRITE(ah, AR_PHY_ERR_MASK_1, AR_PHY_ERR_OFDM_TIMING);\n\tREG_WRITE(ah, AR_PHY_ERR_MASK_2, AR_PHY_ERR_CCK_TIMING);\n\n\tREGWRITE_BUFFER_FLUSH(ah);\n}\n\n \nvoid ath9k_hw_disable_mib_counters(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tath_dbg(common, ANI, \"Disable MIB counters\\n\");\n\n\tREG_WRITE(ah, AR_MIBC, AR_MIBC_FMC);\n\tath9k_hw_update_mibstats(ah, &ah->ah_mibStats);\n\tREG_WRITE(ah, AR_MIBC, AR_MIBC_CMC);\n\tREG_WRITE(ah, AR_FILT_OFDM, 0);\n\tREG_WRITE(ah, AR_FILT_CCK, 0);\n}\nEXPORT_SYMBOL(ath9k_hw_disable_mib_counters);\n\nvoid ath9k_hw_ani_init(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ar5416AniState *ani = &ah->ani;\n\n\tath_dbg(common, ANI, \"Initialize ANI\\n\");\n\n\tif (AR_SREV_9300_20_OR_LATER(ah)) {\n\t\tah->config.ofdm_trig_high = ATH9K_ANI_OFDM_TRIG_HIGH;\n\t\tah->config.ofdm_trig_low = ATH9K_ANI_OFDM_TRIG_LOW;\n\t\tah->config.cck_trig_high = ATH9K_ANI_CCK_TRIG_HIGH;\n\t\tah->config.cck_trig_low = ATH9K_ANI_CCK_TRIG_LOW;\n\t} else {\n\t\tah->config.ofdm_trig_high = ATH9K_ANI_OFDM_TRIG_HIGH_OLD;\n\t\tah->config.ofdm_trig_low = ATH9K_ANI_OFDM_TRIG_LOW_OLD;\n\t\tah->config.cck_trig_high = ATH9K_ANI_CCK_TRIG_HIGH_OLD;\n\t\tah->config.cck_trig_low = ATH9K_ANI_CCK_TRIG_LOW_OLD;\n\t}\n\n\tani->spurImmunityLevel = ATH9K_ANI_SPUR_IMMUNE_LVL;\n\tani->firstepLevel = ATH9K_ANI_FIRSTEP_LVL;\n\tani->mrcCCK = AR_SREV_9300_20_OR_LATER(ah) ? true : false;\n\tani->ofdmsTurn = true;\n\tani->ofdmWeakSigDetect = true;\n\tani->cckNoiseImmunityLevel = ATH9K_ANI_CCK_DEF_LEVEL;\n\tani->ofdmNoiseImmunityLevel = ATH9K_ANI_OFDM_DEF_LEVEL;\n\n\t \n\tah->aniperiod = ATH9K_ANI_PERIOD;\n\tah->config.ani_poll_interval = ATH9K_ANI_POLLINTERVAL;\n\n\tath9k_ani_restart(ah);\n\tath9k_enable_mib_counters(ah);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}