{
  "module_name": "recv.c",
  "hash_id": "e9d09ecabcb28e86b4ac9aa57e5eaa417a5070bd64e59728e2cc0835a86ff459",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/recv.c",
  "human_readable_source": " \n\n#include <linux/dma-mapping.h>\n#include \"ath9k.h\"\n#include \"ar9003_mac.h\"\n\n#define SKB_CB_ATHBUF(__skb)\t(*((struct ath_rxbuf **)__skb->cb))\n\nstatic inline bool ath9k_check_auto_sleep(struct ath_softc *sc)\n{\n\treturn sc->ps_enabled &&\n\t       (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_AUTOSLEEP);\n}\n\n \nstatic void ath_rx_buf_link(struct ath_softc *sc, struct ath_rxbuf *bf,\n\t\t\t    bool flush)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath_desc *ds;\n\tstruct sk_buff *skb;\n\n\tds = bf->bf_desc;\n\tds->ds_link = 0;  \n\tds->ds_data = bf->bf_buf_addr;\n\n\t \n\tskb = bf->bf_mpdu;\n\tBUG_ON(skb == NULL);\n\tds->ds_vdata = skb->data;\n\n\t \n\tath9k_hw_setuprxdesc(ah, ds,\n\t\t\t     common->rx_bufsize,\n\t\t\t     0);\n\n\tif (sc->rx.rxlink)\n\t\t*sc->rx.rxlink = bf->bf_daddr;\n\telse if (!flush)\n\t\tath9k_hw_putrxbuf(ah, bf->bf_daddr);\n\n\tsc->rx.rxlink = &ds->ds_link;\n}\n\nstatic void ath_rx_buf_relink(struct ath_softc *sc, struct ath_rxbuf *bf,\n\t\t\t      bool flush)\n{\n\tif (sc->rx.buf_hold)\n\t\tath_rx_buf_link(sc, sc->rx.buf_hold, flush);\n\n\tsc->rx.buf_hold = bf;\n}\n\nstatic void ath_setdefantenna(struct ath_softc *sc, u32 antenna)\n{\n\t \n\tath9k_hw_setantenna(sc->sc_ah, antenna);\n\tsc->rx.defant = antenna;\n\tsc->rx.rxotherant = 0;\n}\n\nstatic void ath_opmode_init(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tu32 rfilt, mfilt[2];\n\n\t \n\trfilt = ath_calcrxfilter(sc);\n\tath9k_hw_setrxfilter(ah, rfilt);\n\n\t \n\tath_hw_setbssidmask(common);\n\n\t \n\tath9k_hw_setopmode(ah);\n\n\t \n\tmfilt[0] = mfilt[1] = ~0;\n\tath9k_hw_setmcastfilter(ah, mfilt[0], mfilt[1]);\n}\n\nstatic bool ath_rx_edma_buf_link(struct ath_softc *sc,\n\t\t\t\t enum ath9k_rx_qtype qtype)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_rx_edma *rx_edma;\n\tstruct sk_buff *skb;\n\tstruct ath_rxbuf *bf;\n\n\trx_edma = &sc->rx.rx_edma[qtype];\n\tif (skb_queue_len(&rx_edma->rx_fifo) >= rx_edma->rx_fifo_hwsize)\n\t\treturn false;\n\n\tbf = list_first_entry(&sc->rx.rxbuf, struct ath_rxbuf, list);\n\tlist_del_init(&bf->list);\n\n\tskb = bf->bf_mpdu;\n\n\tmemset(skb->data, 0, ah->caps.rx_status_len);\n\tdma_sync_single_for_device(sc->dev, bf->bf_buf_addr,\n\t\t\t\tah->caps.rx_status_len, DMA_TO_DEVICE);\n\n\tSKB_CB_ATHBUF(skb) = bf;\n\tath9k_hw_addrxbuf_edma(ah, bf->bf_buf_addr, qtype);\n\t__skb_queue_tail(&rx_edma->rx_fifo, skb);\n\n\treturn true;\n}\n\nstatic void ath_rx_addbuffer_edma(struct ath_softc *sc,\n\t\t\t\t  enum ath9k_rx_qtype qtype)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_rxbuf *bf, *tbf;\n\n\tif (list_empty(&sc->rx.rxbuf)) {\n\t\tath_dbg(common, QUEUE, \"No free rx buf available\\n\");\n\t\treturn;\n\t}\n\n\tlist_for_each_entry_safe(bf, tbf, &sc->rx.rxbuf, list)\n\t\tif (!ath_rx_edma_buf_link(sc, qtype))\n\t\t\tbreak;\n\n}\n\nstatic void ath_rx_remove_buffer(struct ath_softc *sc,\n\t\t\t\t enum ath9k_rx_qtype qtype)\n{\n\tstruct ath_rxbuf *bf;\n\tstruct ath_rx_edma *rx_edma;\n\tstruct sk_buff *skb;\n\n\trx_edma = &sc->rx.rx_edma[qtype];\n\n\twhile ((skb = __skb_dequeue(&rx_edma->rx_fifo)) != NULL) {\n\t\tbf = SKB_CB_ATHBUF(skb);\n\t\tBUG_ON(!bf);\n\t\tlist_add_tail(&bf->list, &sc->rx.rxbuf);\n\t}\n}\n\nstatic void ath_rx_edma_cleanup(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath_rxbuf *bf;\n\n\tath_rx_remove_buffer(sc, ATH9K_RX_QUEUE_LP);\n\tath_rx_remove_buffer(sc, ATH9K_RX_QUEUE_HP);\n\n\tlist_for_each_entry(bf, &sc->rx.rxbuf, list) {\n\t\tif (bf->bf_mpdu) {\n\t\t\tdma_unmap_single(sc->dev, bf->bf_buf_addr,\n\t\t\t\t\tcommon->rx_bufsize,\n\t\t\t\t\tDMA_BIDIRECTIONAL);\n\t\t\tdev_kfree_skb_any(bf->bf_mpdu);\n\t\t\tbf->bf_buf_addr = 0;\n\t\t\tbf->bf_mpdu = NULL;\n\t\t}\n\t}\n}\n\nstatic void ath_rx_edma_init_queue(struct ath_rx_edma *rx_edma, int size)\n{\n\t__skb_queue_head_init(&rx_edma->rx_fifo);\n\trx_edma->rx_fifo_hwsize = size;\n}\n\nstatic int ath_rx_edma_init(struct ath_softc *sc, int nbufs)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct sk_buff *skb;\n\tstruct ath_rxbuf *bf;\n\tint error = 0, i;\n\tu32 size;\n\n\tath9k_hw_set_rx_bufsize(ah, common->rx_bufsize -\n\t\t\t\t    ah->caps.rx_status_len);\n\n\tath_rx_edma_init_queue(&sc->rx.rx_edma[ATH9K_RX_QUEUE_LP],\n\t\t\t       ah->caps.rx_lp_qdepth);\n\tath_rx_edma_init_queue(&sc->rx.rx_edma[ATH9K_RX_QUEUE_HP],\n\t\t\t       ah->caps.rx_hp_qdepth);\n\n\tsize = sizeof(struct ath_rxbuf) * nbufs;\n\tbf = devm_kzalloc(sc->dev, size, GFP_KERNEL);\n\tif (!bf)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&sc->rx.rxbuf);\n\n\tfor (i = 0; i < nbufs; i++, bf++) {\n\t\tskb = ath_rxbuf_alloc(common, common->rx_bufsize, GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto rx_init_fail;\n\t\t}\n\n\t\tmemset(skb->data, 0, common->rx_bufsize);\n\t\tbf->bf_mpdu = skb;\n\n\t\tbf->bf_buf_addr = dma_map_single(sc->dev, skb->data,\n\t\t\t\t\t\t common->rx_bufsize,\n\t\t\t\t\t\t DMA_BIDIRECTIONAL);\n\t\tif (unlikely(dma_mapping_error(sc->dev,\n\t\t\t\t\t\tbf->bf_buf_addr))) {\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\tbf->bf_mpdu = NULL;\n\t\t\t\tbf->bf_buf_addr = 0;\n\t\t\t\tath_err(common,\n\t\t\t\t\t\"dma_mapping_error() on RX init\\n\");\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto rx_init_fail;\n\t\t}\n\n\t\tlist_add_tail(&bf->list, &sc->rx.rxbuf);\n\t}\n\n\treturn 0;\n\nrx_init_fail:\n\tath_rx_edma_cleanup(sc);\n\treturn error;\n}\n\nstatic void ath_edma_start_recv(struct ath_softc *sc)\n{\n\tath9k_hw_rxena(sc->sc_ah);\n\tath_rx_addbuffer_edma(sc, ATH9K_RX_QUEUE_HP);\n\tath_rx_addbuffer_edma(sc, ATH9K_RX_QUEUE_LP);\n\tath_opmode_init(sc);\n\tath9k_hw_startpcureceive(sc->sc_ah, sc->cur_chan->offchannel);\n}\n\nstatic void ath_edma_stop_recv(struct ath_softc *sc)\n{\n\tath_rx_remove_buffer(sc, ATH9K_RX_QUEUE_HP);\n\tath_rx_remove_buffer(sc, ATH9K_RX_QUEUE_LP);\n}\n\nint ath_rx_init(struct ath_softc *sc, int nbufs)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct sk_buff *skb;\n\tstruct ath_rxbuf *bf;\n\tint error = 0;\n\n\tspin_lock_init(&sc->sc_pcu_lock);\n\n\tcommon->rx_bufsize = IEEE80211_MAX_MPDU_LEN / 2 +\n\t\t\t     sc->sc_ah->caps.rx_status_len;\n\n\tif (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_EDMA)\n\t\treturn ath_rx_edma_init(sc, nbufs);\n\n\tath_dbg(common, CONFIG, \"cachelsz %u rxbufsize %u\\n\",\n\t\tcommon->cachelsz, common->rx_bufsize);\n\n\t \n\n\terror = ath_descdma_setup(sc, &sc->rx.rxdma, &sc->rx.rxbuf,\n\t\t\t\t  \"rx\", nbufs, 1, 0);\n\tif (error != 0) {\n\t\tath_err(common,\n\t\t\t\"failed to allocate rx descriptors: %d\\n\",\n\t\t\terror);\n\t\tgoto err;\n\t}\n\n\tlist_for_each_entry(bf, &sc->rx.rxbuf, list) {\n\t\tskb = ath_rxbuf_alloc(common, common->rx_bufsize,\n\t\t\t\t      GFP_KERNEL);\n\t\tif (skb == NULL) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tbf->bf_mpdu = skb;\n\t\tbf->bf_buf_addr = dma_map_single(sc->dev, skb->data,\n\t\t\t\t\t\t common->rx_bufsize,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\tif (unlikely(dma_mapping_error(sc->dev,\n\t\t\t\t\t       bf->bf_buf_addr))) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tbf->bf_mpdu = NULL;\n\t\t\tbf->bf_buf_addr = 0;\n\t\t\tath_err(common,\n\t\t\t\t\"dma_mapping_error() on RX init\\n\");\n\t\t\terror = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t}\n\tsc->rx.rxlink = NULL;\nerr:\n\tif (error)\n\t\tath_rx_cleanup(sc);\n\n\treturn error;\n}\n\nvoid ath_rx_cleanup(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct sk_buff *skb;\n\tstruct ath_rxbuf *bf;\n\n\tif (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_EDMA) {\n\t\tath_rx_edma_cleanup(sc);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(bf, &sc->rx.rxbuf, list) {\n\t\tskb = bf->bf_mpdu;\n\t\tif (skb) {\n\t\t\tdma_unmap_single(sc->dev, bf->bf_buf_addr,\n\t\t\t\t\t common->rx_bufsize,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(skb);\n\t\t\tbf->bf_buf_addr = 0;\n\t\t\tbf->bf_mpdu = NULL;\n\t\t}\n\t}\n}\n\n \n\nu32 ath_calcrxfilter(struct ath_softc *sc)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tu32 rfilt;\n\n\tif (IS_ENABLED(CONFIG_ATH9K_TX99))\n\t\treturn 0;\n\n\trfilt = ATH9K_RX_FILTER_UCAST | ATH9K_RX_FILTER_BCAST\n\t\t| ATH9K_RX_FILTER_MCAST;\n\n\t \n\tif (sc->hw->conf.radar_enabled)\n\t\trfilt |= ATH9K_RX_FILTER_PHYRADAR | ATH9K_RX_FILTER_PHYERR;\n\n\tspin_lock_bh(&sc->chan_lock);\n\n\tif (sc->cur_chan->rxfilter & FIF_PROBE_REQ)\n\t\trfilt |= ATH9K_RX_FILTER_PROBEREQ;\n\n\tif (sc->sc_ah->is_monitoring)\n\t\trfilt |= ATH9K_RX_FILTER_PROM;\n\n\tif ((sc->cur_chan->rxfilter & FIF_CONTROL) ||\n\t    sc->sc_ah->dynack.enabled)\n\t\trfilt |= ATH9K_RX_FILTER_CONTROL;\n\n\tif ((sc->sc_ah->opmode == NL80211_IFTYPE_STATION) &&\n\t    (sc->cur_chan->nvifs <= 1) &&\n\t    !(sc->cur_chan->rxfilter & FIF_BCN_PRBRESP_PROMISC))\n\t\trfilt |= ATH9K_RX_FILTER_MYBEACON;\n\telse if (sc->sc_ah->opmode != NL80211_IFTYPE_OCB)\n\t\trfilt |= ATH9K_RX_FILTER_BEACON;\n\n\tif ((sc->sc_ah->opmode == NL80211_IFTYPE_AP) ||\n\t    (sc->cur_chan->rxfilter & FIF_PSPOLL))\n\t\trfilt |= ATH9K_RX_FILTER_PSPOLL;\n\n\tif (sc->cur_chandef.width != NL80211_CHAN_WIDTH_20_NOHT)\n\t\trfilt |= ATH9K_RX_FILTER_COMP_BAR;\n\n\tif (sc->cur_chan->nvifs > 1 ||\n\t    (sc->cur_chan->rxfilter & (FIF_OTHER_BSS | FIF_MCAST_ACTION))) {\n\t\t \n\t\tif (sc->sc_ah->hw_version.macVersion <= AR_SREV_VERSION_9160)\n\t\t\trfilt |= ATH9K_RX_FILTER_PROM;\n\t\trfilt |= ATH9K_RX_FILTER_MCAST_BCAST_ALL;\n\t}\n\n\tif (AR_SREV_9550(sc->sc_ah) || AR_SREV_9531(sc->sc_ah) ||\n\t    AR_SREV_9561(sc->sc_ah))\n\t\trfilt |= ATH9K_RX_FILTER_4ADDRESS;\n\n\tif (AR_SREV_9462(sc->sc_ah) || AR_SREV_9565(sc->sc_ah))\n\t\trfilt |= ATH9K_RX_FILTER_CONTROL_WRAPPER;\n\n\tif (ath9k_is_chanctx_enabled() &&\n\t    test_bit(ATH_OP_SCANNING, &common->op_flags))\n\t\trfilt |= ATH9K_RX_FILTER_BEACON;\n\n\tspin_unlock_bh(&sc->chan_lock);\n\n\treturn rfilt;\n\n}\n\nvoid ath_startrecv(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_rxbuf *bf, *tbf;\n\n\tif (ah->caps.hw_caps & ATH9K_HW_CAP_EDMA) {\n\t\tath_edma_start_recv(sc);\n\t\treturn;\n\t}\n\n\tif (list_empty(&sc->rx.rxbuf))\n\t\tgoto start_recv;\n\n\tsc->rx.buf_hold = NULL;\n\tsc->rx.rxlink = NULL;\n\tlist_for_each_entry_safe(bf, tbf, &sc->rx.rxbuf, list) {\n\t\tath_rx_buf_link(sc, bf, false);\n\t}\n\n\t \n\tif (list_empty(&sc->rx.rxbuf))\n\t\tgoto start_recv;\n\n\tbf = list_first_entry(&sc->rx.rxbuf, struct ath_rxbuf, list);\n\tath9k_hw_putrxbuf(ah, bf->bf_daddr);\n\tath9k_hw_rxena(ah);\n\nstart_recv:\n\tath_opmode_init(sc);\n\tath9k_hw_startpcureceive(ah, sc->cur_chan->offchannel);\n}\n\nstatic void ath_flushrecv(struct ath_softc *sc)\n{\n\tif (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_EDMA)\n\t\tath_rx_tasklet(sc, 1, true);\n\tath_rx_tasklet(sc, 1, false);\n}\n\nbool ath_stoprecv(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tbool stopped, reset = false;\n\n\tath9k_hw_abortpcurecv(ah);\n\tath9k_hw_setrxfilter(ah, 0);\n\tstopped = ath9k_hw_stopdmarecv(ah, &reset);\n\n\tath_flushrecv(sc);\n\n\tif (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_EDMA)\n\t\tath_edma_stop_recv(sc);\n\telse\n\t\tsc->rx.rxlink = NULL;\n\n\tif (!(ah->ah_flags & AH_UNPLUGGED) &&\n\t    unlikely(!stopped)) {\n\t\tath_dbg(ath9k_hw_common(sc->sc_ah), RESET,\n\t\t\t\"Failed to stop Rx DMA\\n\");\n\t\tRESET_STAT_INC(sc, RESET_RX_DMA_ERROR);\n\t}\n\treturn stopped && !reset;\n}\n\nstatic bool ath_beacon_dtim_pending_cab(struct sk_buff *skb)\n{\n\t \n\tstruct ieee80211_mgmt *mgmt;\n\tu8 *pos, *end, id, elen;\n\tstruct ieee80211_tim_ie *tim;\n\n\tmgmt = (struct ieee80211_mgmt *)skb->data;\n\tpos = mgmt->u.beacon.variable;\n\tend = skb->data + skb->len;\n\n\twhile (pos + 2 < end) {\n\t\tid = *pos++;\n\t\telen = *pos++;\n\t\tif (pos + elen > end)\n\t\t\tbreak;\n\n\t\tif (id == WLAN_EID_TIM) {\n\t\t\tif (elen < sizeof(*tim))\n\t\t\t\tbreak;\n\t\t\ttim = (struct ieee80211_tim_ie *) pos;\n\t\t\tif (tim->dtim_count != 0)\n\t\t\t\tbreak;\n\t\t\treturn tim->bitmap_ctrl & 0x01;\n\t\t}\n\n\t\tpos += elen;\n\t}\n\n\treturn false;\n}\n\nstatic void ath_rx_ps_beacon(struct ath_softc *sc, struct sk_buff *skb)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tbool skip_beacon = false;\n\n\tif (skb->len < 24 + 8 + 2 + 2)\n\t\treturn;\n\n\tsc->ps_flags &= ~PS_WAIT_FOR_BEACON;\n\n\tif (sc->ps_flags & PS_BEACON_SYNC) {\n\t\tsc->ps_flags &= ~PS_BEACON_SYNC;\n\t\tath_dbg(common, PS,\n\t\t\t\"Reconfigure beacon timers based on synchronized timestamp\\n\");\n\n#ifdef CONFIG_ATH9K_CHANNEL_CONTEXT\n\t\tif (ath9k_is_chanctx_enabled()) {\n\t\t\tif (sc->cur_chan == &sc->offchannel.chan)\n\t\t\t\tskip_beacon = true;\n\t\t}\n#endif\n\n\t\tif (!skip_beacon &&\n\t\t    !(WARN_ON_ONCE(sc->cur_chan->beacon.beacon_interval == 0)))\n\t\t\tath9k_set_beacon(sc);\n\n\t\tath9k_p2p_beacon_sync(sc);\n\t}\n\n\tif (ath_beacon_dtim_pending_cab(skb)) {\n\t\t \n\t\tath_dbg(common, PS,\n\t\t\t\"Received DTIM beacon indicating buffered broadcast/multicast frame(s)\\n\");\n\t\tsc->ps_flags |= PS_WAIT_FOR_CAB | PS_WAIT_FOR_BEACON;\n\t\treturn;\n\t}\n\n\tif (sc->ps_flags & PS_WAIT_FOR_CAB) {\n\t\t \n\t\tsc->ps_flags &= ~PS_WAIT_FOR_CAB;\n\t\tath_dbg(common, PS, \"PS wait for CAB frames timed out\\n\");\n\t}\n}\n\nstatic void ath_rx_ps(struct ath_softc *sc, struct sk_buff *skb, bool mybeacon)\n{\n\tstruct ieee80211_hdr *hdr;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\n\t \n\tif (((sc->ps_flags & PS_WAIT_FOR_BEACON) || ath9k_check_auto_sleep(sc))\n\t    && mybeacon) {\n\t\tath_rx_ps_beacon(sc, skb);\n\t} else if ((sc->ps_flags & PS_WAIT_FOR_CAB) &&\n\t\t   (ieee80211_is_data(hdr->frame_control) ||\n\t\t    ieee80211_is_action(hdr->frame_control)) &&\n\t\t   is_multicast_ether_addr(hdr->addr1) &&\n\t\t   !ieee80211_has_moredata(hdr->frame_control)) {\n\t\t \n\t\tsc->ps_flags &= ~(PS_WAIT_FOR_CAB | PS_WAIT_FOR_BEACON);\n\t\tath_dbg(common, PS,\n\t\t\t\"All PS CAB frames received, back to sleep\\n\");\n\t} else if ((sc->ps_flags & PS_WAIT_FOR_PSPOLL_DATA) &&\n\t\t   !is_multicast_ether_addr(hdr->addr1) &&\n\t\t   !ieee80211_has_morefrags(hdr->frame_control)) {\n\t\tsc->ps_flags &= ~PS_WAIT_FOR_PSPOLL_DATA;\n\t\tath_dbg(common, PS,\n\t\t\t\"Going back to sleep after having received PS-Poll data (0x%lx)\\n\",\n\t\t\tsc->ps_flags & (PS_WAIT_FOR_BEACON |\n\t\t\t\t\tPS_WAIT_FOR_CAB |\n\t\t\t\t\tPS_WAIT_FOR_PSPOLL_DATA |\n\t\t\t\t\tPS_WAIT_FOR_TX_ACK));\n\t}\n}\n\nstatic bool ath_edma_get_buffers(struct ath_softc *sc,\n\t\t\t\t enum ath9k_rx_qtype qtype,\n\t\t\t\t struct ath_rx_status *rs,\n\t\t\t\t struct ath_rxbuf **dest)\n{\n\tstruct ath_rx_edma *rx_edma = &sc->rx.rx_edma[qtype];\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct sk_buff *skb;\n\tstruct ath_rxbuf *bf;\n\tint ret;\n\n\tskb = skb_peek(&rx_edma->rx_fifo);\n\tif (!skb)\n\t\treturn false;\n\n\tbf = SKB_CB_ATHBUF(skb);\n\tBUG_ON(!bf);\n\n\tdma_sync_single_for_cpu(sc->dev, bf->bf_buf_addr,\n\t\t\t\tcommon->rx_bufsize, DMA_FROM_DEVICE);\n\n\tret = ath9k_hw_process_rxdesc_edma(ah, rs, skb->data);\n\tif (ret == -EINPROGRESS) {\n\t\t \n\t\tdma_sync_single_for_device(sc->dev, bf->bf_buf_addr,\n\t\t\t\tcommon->rx_bufsize, DMA_FROM_DEVICE);\n\t\treturn false;\n\t}\n\n\t__skb_unlink(skb, &rx_edma->rx_fifo);\n\tif (ret == -EINVAL) {\n\t\t \n\t\tlist_add_tail(&bf->list, &sc->rx.rxbuf);\n\t\tath_rx_edma_buf_link(sc, qtype);\n\n\t\tskb = skb_peek(&rx_edma->rx_fifo);\n\t\tif (skb) {\n\t\t\tbf = SKB_CB_ATHBUF(skb);\n\t\t\tBUG_ON(!bf);\n\n\t\t\t__skb_unlink(skb, &rx_edma->rx_fifo);\n\t\t\tlist_add_tail(&bf->list, &sc->rx.rxbuf);\n\t\t\tath_rx_edma_buf_link(sc, qtype);\n\t\t}\n\n\t\tbf = NULL;\n\t}\n\n\t*dest = bf;\n\treturn true;\n}\n\nstatic struct ath_rxbuf *ath_edma_get_next_rx_buf(struct ath_softc *sc,\n\t\t\t\t\t\tstruct ath_rx_status *rs,\n\t\t\t\t\t\tenum ath9k_rx_qtype qtype)\n{\n\tstruct ath_rxbuf *bf = NULL;\n\n\twhile (ath_edma_get_buffers(sc, qtype, rs, &bf)) {\n\t\tif (!bf)\n\t\t\tcontinue;\n\n\t\treturn bf;\n\t}\n\treturn NULL;\n}\n\nstatic struct ath_rxbuf *ath_get_next_rx_buf(struct ath_softc *sc,\n\t\t\t\t\t   struct ath_rx_status *rs)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath_desc *ds;\n\tstruct ath_rxbuf *bf;\n\tint ret;\n\n\tif (list_empty(&sc->rx.rxbuf)) {\n\t\tsc->rx.rxlink = NULL;\n\t\treturn NULL;\n\t}\n\n\tbf = list_first_entry(&sc->rx.rxbuf, struct ath_rxbuf, list);\n\tif (bf == sc->rx.buf_hold)\n\t\treturn NULL;\n\n\tds = bf->bf_desc;\n\n\t \n\tret = ath9k_hw_rxprocdesc(ah, ds, rs);\n\tif (ret == -EINPROGRESS) {\n\t\tstruct ath_rx_status trs;\n\t\tstruct ath_rxbuf *tbf;\n\t\tstruct ath_desc *tds;\n\n\t\tmemset(&trs, 0, sizeof(trs));\n\t\tif (list_is_last(&bf->list, &sc->rx.rxbuf)) {\n\t\t\tsc->rx.rxlink = NULL;\n\t\t\treturn NULL;\n\t\t}\n\n\t\ttbf = list_entry(bf->list.next, struct ath_rxbuf, list);\n\n\t\t \n\n\t\ttds = tbf->bf_desc;\n\t\tret = ath9k_hw_rxprocdesc(ah, tds, &trs);\n\t\tif (ret == -EINPROGRESS)\n\t\t\treturn NULL;\n\n\t\t \n\t\tret = ath9k_hw_rxprocdesc(ah, ds, rs);\n\t\tif (ret == -EINPROGRESS) {\n\t\t\t \n\t\t\trs->rs_datalen = 0;\n\t\t\trs->rs_more = true;\n\t\t}\n\t}\n\n\tlist_del(&bf->list);\n\tif (!bf->bf_mpdu)\n\t\treturn bf;\n\n\t \n\tdma_sync_single_for_cpu(sc->dev, bf->bf_buf_addr,\n\t\t\tcommon->rx_bufsize,\n\t\t\tDMA_FROM_DEVICE);\n\n\treturn bf;\n}\n\nstatic void ath9k_process_tsf(struct ath_rx_status *rs,\n\t\t\t      struct ieee80211_rx_status *rxs,\n\t\t\t      u64 tsf)\n{\n\tu32 tsf_lower = tsf & 0xffffffff;\n\n\trxs->mactime = (tsf & ~0xffffffffULL) | rs->rs_tstamp;\n\tif (rs->rs_tstamp > tsf_lower &&\n\t    unlikely(rs->rs_tstamp - tsf_lower > 0x10000000))\n\t\trxs->mactime -= 0x100000000ULL;\n\n\tif (rs->rs_tstamp < tsf_lower &&\n\t    unlikely(tsf_lower - rs->rs_tstamp > 0x10000000))\n\t\trxs->mactime += 0x100000000ULL;\n}\n\n \nstatic int ath9k_rx_skb_preprocess(struct ath_softc *sc,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   struct ath_rx_status *rx_stats,\n\t\t\t\t   struct ieee80211_rx_status *rx_status,\n\t\t\t\t   bool *decrypt_error, u64 tsf)\n{\n\tstruct ieee80211_hw *hw = sc->hw;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ieee80211_hdr *hdr;\n\tbool discard_current = sc->rx.discard_next;\n\tbool is_phyerr;\n\n\t \n\tif (discard_current)\n\t\tgoto corrupt;\n\n\tsc->rx.discard_next = false;\n\n\t \n\tis_phyerr = rx_stats->rs_status & ATH9K_RXERR_PHY;\n\tif (!rx_stats->rs_datalen ||\n\t    (rx_stats->rs_datalen < 10 && !is_phyerr)) {\n\t\tRX_STAT_INC(sc, rx_len_err);\n\t\tgoto corrupt;\n\t}\n\n\t \n\tif (rx_stats->rs_datalen > (common->rx_bufsize - ah->caps.rx_status_len)) {\n\t\tRX_STAT_INC(sc, rx_len_err);\n\t\tgoto corrupt;\n\t}\n\n\t \n\tif (rx_stats->rs_more)\n\t\treturn 0;\n\n\t \n\tif (rx_stats->rs_status & ATH9K_RXERR_CORRUPT_DESC)\n\t\tgoto corrupt;\n\n\thdr = (struct ieee80211_hdr *) (skb->data + ah->caps.rx_status_len);\n\n\tath9k_process_tsf(rx_stats, rx_status, tsf);\n\tath_debug_stat_rx(sc, rx_stats);\n\n\t \n\tif (rx_stats->rs_status & ATH9K_RXERR_PHY) {\n\t\t \n\t\tif (hw->conf.radar_enabled) {\n\t\t\tath9k_dfs_process_phyerr(sc, hdr, rx_stats,\n\t\t\t\t\t\t rx_status->mactime);\n\t\t} else if (sc->spec_priv.spectral_mode != SPECTRAL_DISABLED &&\n\t\t\t   ath_cmn_process_fft(&sc->spec_priv, hdr, rx_stats,\n\t\t\t\t\t       rx_status->mactime)) {\n\t\t\tRX_STAT_INC(sc, rx_spectral);\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tspin_lock_bh(&sc->chan_lock);\n\tif (!ath9k_cmn_rx_accept(common, hdr, rx_status, rx_stats, decrypt_error,\n\t\t\t\t sc->cur_chan->rxfilter)) {\n\t\tspin_unlock_bh(&sc->chan_lock);\n\t\treturn -EINVAL;\n\t}\n\tspin_unlock_bh(&sc->chan_lock);\n\n\tif (ath_is_mybeacon(common, hdr)) {\n\t\tRX_STAT_INC(sc, rx_beacons);\n\t\trx_stats->is_mybeacon = true;\n\t}\n\n\t \n\tif (WARN_ON(!ah->curchan))\n\t\treturn -EINVAL;\n\n\tif (ath9k_cmn_process_rate(common, hw, rx_stats, rx_status)) {\n\t\t \n\t\tath_dbg(common, ANY, \"unsupported hw bitrate detected 0x%02x using 1 Mbit\\n\",\n\t\t\trx_stats->rs_rate);\n\t\tRX_STAT_INC(sc, rx_rate_err);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ath9k_is_chanctx_enabled()) {\n\t\tif (rx_stats->is_mybeacon)\n\t\t\tath_chanctx_beacon_recv_ev(sc,\n\t\t\t\t\t   ATH_CHANCTX_EVENT_BEACON_RECEIVED);\n\t}\n\n\tath9k_cmn_process_rssi(common, hw, rx_stats, rx_status);\n\n\trx_status->band = ah->curchan->chan->band;\n\trx_status->freq = ah->curchan->chan->center_freq;\n\trx_status->antenna = rx_stats->rs_antenna;\n\trx_status->flag |= RX_FLAG_MACTIME_END;\n\n#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT\n\tif (ieee80211_is_data_present(hdr->frame_control) &&\n\t    !ieee80211_is_qos_nullfunc(hdr->frame_control))\n\t\tsc->rx.num_pkts++;\n#endif\n\n\treturn 0;\n\ncorrupt:\n\tsc->rx.discard_next = rx_stats->rs_more;\n\treturn -EINVAL;\n}\n\n \nstatic void ath9k_antenna_check(struct ath_softc *sc,\n\t\t\t\tstruct ath_rx_status *rs)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath9k_hw_capabilities *pCap = &ah->caps;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tif (!(ah->caps.hw_caps & ATH9K_HW_CAP_ANT_DIV_COMB))\n\t\treturn;\n\n\t \n\tif (sc->rx.defant != rs->rs_antenna) {\n\t\tif (++sc->rx.rxotherant >= 3)\n\t\t\tath_setdefantenna(sc, rs->rs_antenna);\n\t} else {\n\t\tsc->rx.rxotherant = 0;\n\t}\n\n\tif (pCap->hw_caps & ATH9K_HW_CAP_BT_ANT_DIV) {\n\t\tif (common->bt_ant_diversity)\n\t\t\tath_ant_comb_scan(sc, rs);\n\t} else {\n\t\tath_ant_comb_scan(sc, rs);\n\t}\n}\n\nstatic void ath9k_apply_ampdu_details(struct ath_softc *sc,\n\tstruct ath_rx_status *rs, struct ieee80211_rx_status *rxs)\n{\n\tif (rs->rs_isaggr) {\n\t\trxs->flag |= RX_FLAG_AMPDU_DETAILS | RX_FLAG_AMPDU_LAST_KNOWN;\n\n\t\trxs->ampdu_reference = sc->rx.ampdu_ref;\n\n\t\tif (!rs->rs_moreaggr) {\n\t\t\trxs->flag |= RX_FLAG_AMPDU_IS_LAST;\n\t\t\tsc->rx.ampdu_ref++;\n\t\t}\n\n\t\tif (rs->rs_flags & ATH9K_RX_DELIM_CRC_PRE)\n\t\t\trxs->flag |= RX_FLAG_AMPDU_DELIM_CRC_ERROR;\n\t}\n}\n\nstatic void ath_rx_count_airtime(struct ath_softc *sc,\n\t\t\t\t struct ath_rx_status *rs,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ieee80211_sta *sta;\n\tstruct ieee80211_rx_status *rxs;\n\tconst struct ieee80211_rate *rate;\n\tbool is_sgi, is_40, is_sp;\n\tint phy;\n\tu16 len = rs->rs_datalen;\n\tu32 airtime = 0;\n\tu8 tidno;\n\n\tif (!ieee80211_is_data(hdr->frame_control))\n\t\treturn;\n\n\trcu_read_lock();\n\n\tsta = ieee80211_find_sta_by_ifaddr(sc->hw, hdr->addr2, NULL);\n\tif (!sta)\n\t\tgoto exit;\n\ttidno = skb->priority & IEEE80211_QOS_CTL_TID_MASK;\n\n\trxs = IEEE80211_SKB_RXCB(skb);\n\n\tis_sgi = !!(rxs->enc_flags & RX_ENC_FLAG_SHORT_GI);\n\tis_40 = !!(rxs->bw == RATE_INFO_BW_40);\n\tis_sp = !!(rxs->enc_flags & RX_ENC_FLAG_SHORTPRE);\n\n\tif (!!(rxs->encoding == RX_ENC_HT)) {\n\t\t \n\n\t\tairtime += ath_pkt_duration(sc, rxs->rate_idx, len,\n\t\t\t\t\tis_40, is_sgi, is_sp);\n\t} else {\n\n\t\tphy = IS_CCK_RATE(rs->rs_rate) ? WLAN_RC_PHY_CCK : WLAN_RC_PHY_OFDM;\n\t\trate = &common->sbands[rxs->band].bitrates[rxs->rate_idx];\n\t\tairtime += ath9k_hw_computetxtime(ah, phy, rate->bitrate * 100,\n\t\t\t\t\t\tlen, rxs->rate_idx, is_sp);\n\t}\n\n\tieee80211_sta_register_airtime(sta, tidno, 0, airtime);\nexit:\n\trcu_read_unlock();\n}\n\nint ath_rx_tasklet(struct ath_softc *sc, int flush, bool hp)\n{\n\tstruct ath_rxbuf *bf;\n\tstruct sk_buff *skb = NULL, *requeue_skb, *hdr_skb;\n\tstruct ieee80211_rx_status *rxs;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ieee80211_hw *hw = sc->hw;\n\tint retval;\n\tstruct ath_rx_status rs;\n\tenum ath9k_rx_qtype qtype;\n\tbool edma = !!(ah->caps.hw_caps & ATH9K_HW_CAP_EDMA);\n\tint dma_type;\n\tu64 tsf = 0;\n\tunsigned long flags;\n\tdma_addr_t new_buf_addr;\n\tunsigned int budget = 512;\n\tstruct ieee80211_hdr *hdr;\n\n\tif (edma)\n\t\tdma_type = DMA_BIDIRECTIONAL;\n\telse\n\t\tdma_type = DMA_FROM_DEVICE;\n\n\tqtype = hp ? ATH9K_RX_QUEUE_HP : ATH9K_RX_QUEUE_LP;\n\n\ttsf = ath9k_hw_gettsf64(ah);\n\n\tdo {\n\t\tbool decrypt_error = false;\n\n\t\tmemset(&rs, 0, sizeof(rs));\n\t\tif (edma)\n\t\t\tbf = ath_edma_get_next_rx_buf(sc, &rs, qtype);\n\t\telse\n\t\t\tbf = ath_get_next_rx_buf(sc, &rs);\n\n\t\tif (!bf)\n\t\t\tbreak;\n\n\t\tskb = bf->bf_mpdu;\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (sc->rx.frag)\n\t\t\thdr_skb = sc->rx.frag;\n\t\telse\n\t\t\thdr_skb = skb;\n\n\t\trxs = IEEE80211_SKB_RXCB(hdr_skb);\n\t\tmemset(rxs, 0, sizeof(struct ieee80211_rx_status));\n\n\t\tretval = ath9k_rx_skb_preprocess(sc, hdr_skb, &rs, rxs,\n\t\t\t\t\t\t &decrypt_error, tsf);\n\t\tif (retval)\n\t\t\tgoto requeue_drop_frag;\n\n\t\t \n\t\trequeue_skb = ath_rxbuf_alloc(common, common->rx_bufsize, GFP_ATOMIC);\n\n\t\t \n\t\tif (!requeue_skb) {\n\t\t\tRX_STAT_INC(sc, rx_oom_err);\n\t\t\tgoto requeue_drop_frag;\n\t\t}\n\n\t\t \n\t\tnew_buf_addr = dma_map_single(sc->dev, requeue_skb->data,\n\t\t\t\t\t      common->rx_bufsize, dma_type);\n\t\tif (unlikely(dma_mapping_error(sc->dev, new_buf_addr))) {\n\t\t\tdev_kfree_skb_any(requeue_skb);\n\t\t\tgoto requeue_drop_frag;\n\t\t}\n\n\t\t \n\t\tdma_unmap_single(sc->dev, bf->bf_buf_addr,\n\t\t\t\t common->rx_bufsize, dma_type);\n\n\t\tbf->bf_mpdu = requeue_skb;\n\t\tbf->bf_buf_addr = new_buf_addr;\n\n\t\tskb_put(skb, rs.rs_datalen + ah->caps.rx_status_len);\n\t\tif (ah->caps.rx_status_len)\n\t\t\tskb_pull(skb, ah->caps.rx_status_len);\n\n\t\tif (!rs.rs_more)\n\t\t\tath9k_cmn_rx_skb_postprocess(common, hdr_skb, &rs,\n\t\t\t\t\t\t     rxs, decrypt_error);\n\n\t\tif (rs.rs_more) {\n\t\t\tRX_STAT_INC(sc, rx_frags);\n\t\t\t \n\t\t\tif (sc->rx.frag) {\n\t\t\t\t \n\t\t\t\tdev_kfree_skb_any(sc->rx.frag);\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\tRX_STAT_INC(sc, rx_too_many_frags_err);\n\t\t\t\tskb = NULL;\n\t\t\t}\n\t\t\tsc->rx.frag = skb;\n\t\t\tgoto requeue;\n\t\t}\n\n\t\tif (sc->rx.frag) {\n\t\t\tint space = skb->len - skb_tailroom(hdr_skb);\n\n\t\t\tif (pskb_expand_head(hdr_skb, 0, space, GFP_ATOMIC) < 0) {\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\tRX_STAT_INC(sc, rx_oom_err);\n\t\t\t\tgoto requeue_drop_frag;\n\t\t\t}\n\n\t\t\tsc->rx.frag = NULL;\n\n\t\t\tskb_copy_from_linear_data(skb, skb_put(hdr_skb, skb->len),\n\t\t\t\t\t\t  skb->len);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tskb = hdr_skb;\n\t\t}\n\n\t\tif (rxs->flag & RX_FLAG_MMIC_STRIPPED)\n\t\t\tskb_trim(skb, skb->len - 8);\n\n\t\tspin_lock_irqsave(&sc->sc_pm_lock, flags);\n\t\tif ((sc->ps_flags & (PS_WAIT_FOR_BEACON |\n\t\t\t\t     PS_WAIT_FOR_CAB |\n\t\t\t\t     PS_WAIT_FOR_PSPOLL_DATA)) ||\n\t\t    ath9k_check_auto_sleep(sc))\n\t\t\tath_rx_ps(sc, skb, rs.is_mybeacon);\n\t\tspin_unlock_irqrestore(&sc->sc_pm_lock, flags);\n\n\t\tath9k_antenna_check(sc, &rs);\n\t\tath9k_apply_ampdu_details(sc, &rs, rxs);\n\t\tath_debug_rate_stats(sc, &rs, skb);\n\t\tath_rx_count_airtime(sc, &rs, skb);\n\n\t\thdr = (struct ieee80211_hdr *)skb->data;\n\t\tif (ieee80211_is_ack(hdr->frame_control))\n\t\t\tath_dynack_sample_ack_ts(sc->sc_ah, skb, rs.rs_tstamp);\n\n\t\tieee80211_rx(hw, skb);\n\nrequeue_drop_frag:\n\t\tif (sc->rx.frag) {\n\t\t\tdev_kfree_skb_any(sc->rx.frag);\n\t\t\tsc->rx.frag = NULL;\n\t\t}\nrequeue:\n\t\tlist_add_tail(&bf->list, &sc->rx.rxbuf);\n\n\t\tif (!edma) {\n\t\t\tath_rx_buf_relink(sc, bf, flush);\n\t\t\tif (!flush)\n\t\t\t\tath9k_hw_rxena(ah);\n\t\t} else if (!flush) {\n\t\t\tath_rx_edma_buf_link(sc, qtype);\n\t\t}\n\n\t\tif (!budget--)\n\t\t\tbreak;\n\t} while (1);\n\n\tif (!(ah->imask & ATH9K_INT_RXEOL)) {\n\t\tah->imask |= (ATH9K_INT_RXEOL | ATH9K_INT_RXORN);\n\t\tath9k_hw_set_interrupts(ah);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}