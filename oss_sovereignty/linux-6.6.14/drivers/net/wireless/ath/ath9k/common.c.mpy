{
  "module_name": "common.c",
  "hash_id": "34e96ac8e577a3ca0a443983732ba693ec2d62befdc5f82bc2a8dc7a5b042941",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/common.c",
  "human_readable_source": " \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#include \"common.h\"\n\nMODULE_AUTHOR(\"Atheros Communications\");\nMODULE_DESCRIPTION(\"Shared library for Atheros wireless 802.11n LAN cards.\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\n \nbool ath9k_cmn_rx_accept(struct ath_common *common,\n\t\t\t struct ieee80211_hdr *hdr,\n\t\t\t struct ieee80211_rx_status *rxs,\n\t\t\t struct ath_rx_status *rx_stats,\n\t\t\t bool *decrypt_error,\n\t\t\t unsigned int rxfilter)\n{\n\tstruct ath_hw *ah = common->ah;\n\tbool is_mc, is_valid_tkip, strip_mic, mic_error;\n\t__le16 fc;\n\n\tfc = hdr->frame_control;\n\n\tis_mc = !!is_multicast_ether_addr(hdr->addr1);\n\tis_valid_tkip = rx_stats->rs_keyix != ATH9K_RXKEYIX_INVALID &&\n\t\ttest_bit(rx_stats->rs_keyix, common->tkip_keymap);\n\tstrip_mic = is_valid_tkip && ieee80211_is_data(fc) &&\n\t\tieee80211_has_protected(fc) &&\n\t\t!(rx_stats->rs_status &\n\t\t(ATH9K_RXERR_DECRYPT | ATH9K_RXERR_CRC | ATH9K_RXERR_MIC |\n\t\t ATH9K_RXERR_KEYMISS));\n\n\t \n\tif (rx_stats->rs_keyix == ATH9K_RXKEYIX_INVALID ||\n\t    !test_bit(rx_stats->rs_keyix, common->ccmp_keymap))\n\t\trx_stats->rs_status &= ~ATH9K_RXERR_KEYMISS;\n\n\tmic_error = is_valid_tkip && !ieee80211_is_ctl(fc) &&\n\t\t!ieee80211_has_morefrags(fc) &&\n\t\t!(le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_FRAG) &&\n\t\t(rx_stats->rs_status & ATH9K_RXERR_MIC);\n\n\t \n\tif (rx_stats->rs_status != 0) {\n\t\tu8 status_mask;\n\n\t\tif (rx_stats->rs_status & ATH9K_RXERR_CRC) {\n\t\t\trxs->flag |= RX_FLAG_FAILED_FCS_CRC;\n\t\t\tmic_error = false;\n\t\t}\n\n\t\tif ((rx_stats->rs_status & ATH9K_RXERR_DECRYPT) ||\n\t\t    (!is_mc && (rx_stats->rs_status & ATH9K_RXERR_KEYMISS))) {\n\t\t\t*decrypt_error = true;\n\t\t\tmic_error = false;\n\t\t}\n\n\n\t\t \n\t\tstatus_mask = ATH9K_RXERR_DECRYPT | ATH9K_RXERR_MIC |\n\t\t\t      ATH9K_RXERR_KEYMISS;\n\n\t\tif (ah->is_monitoring && (rxfilter & FIF_FCSFAIL))\n\t\t\tstatus_mask |= ATH9K_RXERR_CRC;\n\n\t\tif (rx_stats->rs_status & ~status_mask)\n\t\t\treturn false;\n\t}\n\n\t \n\tif (strip_mic)\n\t\trxs->flag |= RX_FLAG_MMIC_STRIPPED;\n\telse if (is_mc && mic_error)\n\t\trxs->flag |= RX_FLAG_MMIC_ERROR;\n\n\treturn true;\n}\nEXPORT_SYMBOL(ath9k_cmn_rx_accept);\n\nvoid ath9k_cmn_rx_skb_postprocess(struct ath_common *common,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct ath_rx_status *rx_stats,\n\t\t\t\t  struct ieee80211_rx_status *rxs,\n\t\t\t\t  bool decrypt_error)\n{\n\tstruct ath_hw *ah = common->ah;\n\tstruct ieee80211_hdr *hdr;\n\tint hdrlen, padpos, padsize;\n\tu8 keyix;\n\t__le16 fc;\n\n\t \n\thdr = (struct ieee80211_hdr *) skb->data;\n\thdrlen = ieee80211_get_hdrlen_from_skb(skb);\n\tfc = hdr->frame_control;\n\tpadpos = ieee80211_hdrlen(fc);\n\n\t \n\tpadsize = padpos & 3;\n\tif (padsize && skb->len>=padpos+padsize+FCS_LEN) {\n\t\tmemmove(skb->data + padsize, skb->data, padpos);\n\t\tskb_pull(skb, padsize);\n\t}\n\n\tkeyix = rx_stats->rs_keyix;\n\n\tif (!(keyix == ATH9K_RXKEYIX_INVALID) && !decrypt_error &&\n\t    ieee80211_has_protected(fc)) {\n\t\trxs->flag |= RX_FLAG_DECRYPTED;\n\t} else if (ieee80211_has_protected(fc)\n\t\t   && !decrypt_error && skb->len >= hdrlen + 4) {\n\t\tkeyix = skb->data[hdrlen + 3] >> 6;\n\n\t\tif (test_bit(keyix, common->keymap))\n\t\t\trxs->flag |= RX_FLAG_DECRYPTED;\n\t}\n\tif (ah->sw_mgmt_crypto_rx &&\n\t    (rxs->flag & RX_FLAG_DECRYPTED) &&\n\t    ieee80211_is_mgmt(fc))\n\t\t \n\t\trxs->flag &= ~RX_FLAG_DECRYPTED;\n}\nEXPORT_SYMBOL(ath9k_cmn_rx_skb_postprocess);\n\nint ath9k_cmn_process_rate(struct ath_common *common,\n\t\t\t   struct ieee80211_hw *hw,\n\t\t\t   struct ath_rx_status *rx_stats,\n\t\t\t   struct ieee80211_rx_status *rxs)\n{\n\tstruct ieee80211_supported_band *sband;\n\tenum nl80211_band band;\n\tunsigned int i = 0;\n\tstruct ath_hw *ah = common->ah;\n\n\tband = ah->curchan->chan->band;\n\tsband = hw->wiphy->bands[band];\n\n\tif (IS_CHAN_QUARTER_RATE(ah->curchan))\n\t\trxs->bw = RATE_INFO_BW_5;\n\telse if (IS_CHAN_HALF_RATE(ah->curchan))\n\t\trxs->bw = RATE_INFO_BW_10;\n\n\tif (rx_stats->rs_rate & 0x80) {\n\t\t \n\t\trxs->encoding = RX_ENC_HT;\n\t\trxs->enc_flags |= rx_stats->enc_flags;\n\t\trxs->bw = rx_stats->bw;\n\t\trxs->rate_idx = rx_stats->rs_rate & 0x7f;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\tif (sband->bitrates[i].hw_value == rx_stats->rs_rate) {\n\t\t\trxs->rate_idx = i;\n\t\t\treturn 0;\n\t\t}\n\t\tif (sband->bitrates[i].hw_value_short == rx_stats->rs_rate) {\n\t\t\trxs->enc_flags |= RX_ENC_FLAG_SHORTPRE;\n\t\t\trxs->rate_idx = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(ath9k_cmn_process_rate);\n\nvoid ath9k_cmn_process_rssi(struct ath_common *common,\n\t\t\t    struct ieee80211_hw *hw,\n\t\t\t    struct ath_rx_status *rx_stats,\n\t\t\t    struct ieee80211_rx_status *rxs)\n{\n\tstruct ath_hw *ah = common->ah;\n\tint last_rssi;\n\tint rssi = rx_stats->rs_rssi;\n\tint i, j;\n\n\t \n\tif (rx_stats->rs_moreaggr) {\n\t\trxs->flag |= RX_FLAG_NO_SIGNAL_VAL;\n\t\treturn;\n\t}\n\n\t \n\tif (rx_stats->rs_rssi == ATH9K_RSSI_BAD) {\n\t\trxs->flag |= RX_FLAG_NO_SIGNAL_VAL;\n\t\treturn;\n\t}\n\n\tfor (i = 0, j = 0; i < ARRAY_SIZE(rx_stats->rs_rssi_ctl); i++) {\n\t\ts8 rssi;\n\n\t\tif (!(ah->rxchainmask & BIT(i)))\n\t\t\tcontinue;\n\n\t\trssi = rx_stats->rs_rssi_ctl[i];\n\t\tif (rssi != ATH9K_RSSI_BAD) {\n\t\t    rxs->chains |= BIT(j);\n\t\t    rxs->chain_signal[j] = ah->noise + rssi;\n\t\t}\n\t\tj++;\n\t}\n\n\t \n\tif (rx_stats->is_mybeacon &&\n\t    ((ah->opmode == NL80211_IFTYPE_STATION) ||\n\t     (ah->opmode == NL80211_IFTYPE_ADHOC))) {\n\t\tATH_RSSI_LPF(common->last_rssi, rx_stats->rs_rssi);\n\t\tlast_rssi = common->last_rssi;\n\n\t\tif (likely(last_rssi != ATH_RSSI_DUMMY_MARKER))\n\t\t\trssi = ATH_EP_RND(last_rssi, ATH_RSSI_EP_MULTIPLIER);\n\t\tif (rssi < 0)\n\t\t\trssi = 0;\n\n\t\tah->stats.avgbrssi = rssi;\n\t}\n\n\trxs->signal = ah->noise + rx_stats->rs_rssi;\n}\nEXPORT_SYMBOL(ath9k_cmn_process_rssi);\n\nint ath9k_cmn_get_hw_crypto_keytype(struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\n\tif (tx_info->control.hw_key) {\n\t\tswitch (tx_info->control.hw_key->cipher) {\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\t\treturn ATH9K_KEY_TYPE_WEP;\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\treturn ATH9K_KEY_TYPE_TKIP;\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\t\treturn ATH9K_KEY_TYPE_AES;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ATH9K_KEY_TYPE_CLEAR;\n}\nEXPORT_SYMBOL(ath9k_cmn_get_hw_crypto_keytype);\n\n \nstatic void ath9k_cmn_update_ichannel(struct ath9k_channel *ichan,\n\t\t\t\t      struct cfg80211_chan_def *chandef)\n{\n\tstruct ieee80211_channel *chan = chandef->chan;\n\tu16 flags = 0;\n\n\tichan->channel = chan->center_freq;\n\tichan->chan = chan;\n\n\tif (chan->band == NL80211_BAND_5GHZ)\n\t\tflags |= CHANNEL_5GHZ;\n\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_5:\n\t\tflags |= CHANNEL_QUARTER;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_10:\n\t\tflags |= CHANNEL_HALF;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_20:\n\t\tflags |= CHANNEL_HT;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tif (chandef->center_freq1 > chandef->chan->center_freq)\n\t\t\tflags |= CHANNEL_HT40PLUS | CHANNEL_HT;\n\t\telse\n\t\t\tflags |= CHANNEL_HT40MINUS | CHANNEL_HT;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\tichan->channelFlags = flags;\n}\n\n \nstruct ath9k_channel *ath9k_cmn_get_channel(struct ieee80211_hw *hw,\n\t\t\t\t\t    struct ath_hw *ah,\n\t\t\t\t\t    struct cfg80211_chan_def *chandef)\n{\n\tstruct ieee80211_channel *curchan = chandef->chan;\n\tstruct ath9k_channel *channel;\n\n\tchannel = &ah->channels[curchan->hw_value];\n\tath9k_cmn_update_ichannel(channel, chandef);\n\n\treturn channel;\n}\nEXPORT_SYMBOL(ath9k_cmn_get_channel);\n\nint ath9k_cmn_count_streams(unsigned int chainmask, int max)\n{\n\tint streams = 0;\n\n\tdo {\n\t\tif (++streams == max)\n\t\t\tbreak;\n\t} while ((chainmask = chainmask & (chainmask - 1)));\n\n\treturn streams;\n}\nEXPORT_SYMBOL(ath9k_cmn_count_streams);\n\nvoid ath9k_cmn_update_txpow(struct ath_hw *ah, u16 cur_txpow,\n\t\t\t    u16 new_txpow, u16 *txpower)\n{\n\tstruct ath_regulatory *reg = ath9k_hw_regulatory(ah);\n\n\tif (ah->curchan && reg->power_limit != new_txpow)\n\t\tath9k_hw_set_txpowerlimit(ah, new_txpow, false);\n\n\t \n\t*txpower = reg->max_power_level;\n}\nEXPORT_SYMBOL(ath9k_cmn_update_txpow);\n\nvoid ath9k_cmn_init_crypto(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tint i = 0;\n\n\t \n\tcommon->keymax = AR_KEYTABLE_SIZE;\n\n\t \n\tif (ah->misc_mode & AR_PCU_MIC_NEW_LOC_ENA)\n\t\tcommon->crypt_caps |= ATH_CRYPT_CAP_MIC_COMBINED;\n\n\t \n\tfor (i = 0; i < common->keymax; i++)\n\t\tath_hw_keyreset(common, (u16) i);\n}\nEXPORT_SYMBOL(ath9k_cmn_init_crypto);\n\nstatic int __init ath9k_cmn_init(void)\n{\n\treturn 0;\n}\nmodule_init(ath9k_cmn_init);\n\nstatic void __exit ath9k_cmn_exit(void)\n{\n\treturn;\n}\nmodule_exit(ath9k_cmn_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}