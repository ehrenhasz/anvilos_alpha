{
  "module_name": "htc_hst.c",
  "hash_id": "97d3eefd9480cc2f9540926429ec02c6d02c3dbc50c80547d2f6342030b09386",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/htc_hst.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"htc.h\"\n\nstatic int htc_issue_send(struct htc_target *target, struct sk_buff* skb,\n\t\t\t  u16 len, u8 flags, u8 epid)\n\n{\n\tstruct htc_frame_hdr *hdr;\n\tstruct htc_endpoint *endpoint = &target->endpoint[epid];\n\tint status;\n\n\thdr = skb_push(skb, sizeof(struct htc_frame_hdr));\n\thdr->endpoint_id = epid;\n\thdr->flags = flags;\n\thdr->payload_len = cpu_to_be16(len);\n\tmemset(hdr->control, 0, sizeof(hdr->control));\n\n\tstatus = target->hif->send(target->hif_dev, endpoint->ul_pipeid, skb);\n\n\treturn status;\n}\n\nstatic struct htc_endpoint *get_next_avail_ep(struct htc_endpoint *endpoint)\n{\n\tenum htc_endpoint_id avail_epid;\n\n\tfor (avail_epid = (ENDPOINT_MAX - 1); avail_epid > ENDPOINT0; avail_epid--)\n\t\tif (endpoint[avail_epid].service_id == 0)\n\t\t\treturn &endpoint[avail_epid];\n\treturn NULL;\n}\n\nstatic u8 service_to_ulpipe(u16 service_id)\n{\n\tswitch (service_id) {\n\tcase WMI_CONTROL_SVC:\n\t\treturn 4;\n\tcase WMI_BEACON_SVC:\n\tcase WMI_CAB_SVC:\n\tcase WMI_UAPSD_SVC:\n\tcase WMI_MGMT_SVC:\n\tcase WMI_DATA_VO_SVC:\n\tcase WMI_DATA_VI_SVC:\n\tcase WMI_DATA_BE_SVC:\n\tcase WMI_DATA_BK_SVC:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic u8 service_to_dlpipe(u16 service_id)\n{\n\tswitch (service_id) {\n\tcase WMI_CONTROL_SVC:\n\t\treturn 3;\n\tcase WMI_BEACON_SVC:\n\tcase WMI_CAB_SVC:\n\tcase WMI_UAPSD_SVC:\n\tcase WMI_MGMT_SVC:\n\tcase WMI_DATA_VO_SVC:\n\tcase WMI_DATA_VI_SVC:\n\tcase WMI_DATA_BE_SVC:\n\tcase WMI_DATA_BK_SVC:\n\t\treturn 2;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void htc_process_target_rdy(struct htc_target *target,\n\t\t\t\t   void *buf)\n{\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_ready_msg *htc_ready_msg = (struct htc_ready_msg *) buf;\n\n\ttarget->credit_size = be16_to_cpu(htc_ready_msg->credit_size);\n\n\tendpoint = &target->endpoint[ENDPOINT0];\n\tendpoint->service_id = HTC_CTRL_RSVD_SVC;\n\tendpoint->max_msglen = HTC_MAX_CONTROL_MESSAGE_LENGTH;\n\tatomic_inc(&target->tgt_ready);\n\tcomplete(&target->target_wait);\n}\n\nstatic void htc_process_conn_rsp(struct htc_target *target,\n\t\t\t\t struct htc_frame_hdr *htc_hdr)\n{\n\tstruct htc_conn_svc_rspmsg *svc_rspmsg;\n\tstruct htc_endpoint *endpoint, *tmp_endpoint = NULL;\n\tu16 service_id;\n\tu16 max_msglen;\n\tenum htc_endpoint_id epid, tepid;\n\n\tsvc_rspmsg = (struct htc_conn_svc_rspmsg *)\n\t\t((void *) htc_hdr + sizeof(struct htc_frame_hdr));\n\n\tif (svc_rspmsg->status == HTC_SERVICE_SUCCESS) {\n\t\tepid = svc_rspmsg->endpoint_id;\n\n\t\t \n\t\tif (epid <= ENDPOINT0 || epid >= ENDPOINT_MAX)\n\t\t\treturn;\n\n\t\tservice_id = be16_to_cpu(svc_rspmsg->service_id);\n\t\tmax_msglen = be16_to_cpu(svc_rspmsg->max_msg_len);\n\t\tendpoint = &target->endpoint[epid];\n\n\t\tfor (tepid = (ENDPOINT_MAX - 1); tepid > ENDPOINT0; tepid--) {\n\t\t\ttmp_endpoint = &target->endpoint[tepid];\n\t\t\tif (tmp_endpoint->service_id == service_id) {\n\t\t\t\ttmp_endpoint->service_id = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (tepid == ENDPOINT0)\n\t\t\treturn;\n\n\t\tendpoint->service_id = service_id;\n\t\tendpoint->max_txqdepth = tmp_endpoint->max_txqdepth;\n\t\tendpoint->ep_callbacks = tmp_endpoint->ep_callbacks;\n\t\tendpoint->ul_pipeid = tmp_endpoint->ul_pipeid;\n\t\tendpoint->dl_pipeid = tmp_endpoint->dl_pipeid;\n\t\tendpoint->max_msglen = max_msglen;\n\t\ttarget->conn_rsp_epid = epid;\n\t\tcomplete(&target->cmd_wait);\n\t} else {\n\t\ttarget->conn_rsp_epid = ENDPOINT_UNUSED;\n\t}\n}\n\nstatic int htc_config_pipe_credits(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_config_pipe_msg *cp_msg;\n\tint ret;\n\tunsigned long time_left;\n\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"failed to allocate send buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\n\tcp_msg = skb_put(skb, sizeof(struct htc_config_pipe_msg));\n\n\tcp_msg->message_id = cpu_to_be16(HTC_MSG_CONFIG_PIPE_ID);\n\tcp_msg->pipe_id = USB_WLAN_TX_PIPE;\n\tcp_msg->credits = target->credits;\n\n\ttarget->htc_flags |= HTC_OP_CONFIG_PIPE_CREDITS;\n\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"HTC credit config timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\nstatic int htc_setup_complete(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_comp_msg *comp_msg;\n\tint ret = 0;\n\tunsigned long time_left;\n\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"failed to allocate send buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\n\tcomp_msg = skb_put(skb, sizeof(struct htc_comp_msg));\n\tcomp_msg->msg_id = cpu_to_be16(HTC_MSG_SETUP_COMPLETE_ID);\n\n\ttarget->htc_flags |= HTC_OP_START_WAIT;\n\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"HTC start timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\n \n\nint htc_init(struct htc_target *target)\n{\n\tint ret;\n\n\tret = htc_config_pipe_credits(target);\n\tif (ret)\n\t\treturn ret;\n\n\treturn htc_setup_complete(target);\n}\n\nint htc_connect_service(struct htc_target *target,\n\t\t     struct htc_service_connreq *service_connreq,\n\t\t     enum htc_endpoint_id *conn_rsp_epid)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_conn_svc_msg *conn_msg;\n\tint ret;\n\tunsigned long time_left;\n\n\t \n\tendpoint = get_next_avail_ep(target->endpoint);\n\tif (!endpoint) {\n\t\tdev_err(target->dev, \"Endpoint is not available for service %d\\n\",\n\t\t\tservice_connreq->service_id);\n\t\treturn -EINVAL;\n\t}\n\n\tendpoint->service_id = service_connreq->service_id;\n\tendpoint->max_txqdepth = service_connreq->max_send_qdepth;\n\tendpoint->ul_pipeid = service_to_ulpipe(service_connreq->service_id);\n\tendpoint->dl_pipeid = service_to_dlpipe(service_connreq->service_id);\n\tendpoint->ep_callbacks = service_connreq->ep_callbacks;\n\n\tskb = alloc_skb(sizeof(struct htc_conn_svc_msg) +\n\t\t\t    sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"Failed to allocate buf to send\"\n\t\t\t\"service connect req\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\n\tconn_msg = skb_put(skb, sizeof(struct htc_conn_svc_msg));\n\tconn_msg->service_id = cpu_to_be16(service_connreq->service_id);\n\tconn_msg->msg_id = cpu_to_be16(HTC_MSG_CONNECT_SERVICE_ID);\n\tconn_msg->con_flags = cpu_to_be16(service_connreq->con_flags);\n\tconn_msg->dl_pipeid = endpoint->dl_pipeid;\n\tconn_msg->ul_pipeid = endpoint->ul_pipeid;\n\n\t \n\tconn_msg->svc_meta_len = 0;\n\tconn_msg->pad = 0;\n\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"Service connection timeout for: %d\\n\",\n\t\t\tservice_connreq->service_id);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t*conn_rsp_epid = target->conn_rsp_epid;\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn ret;\n}\n\nint htc_send(struct htc_target *target, struct sk_buff *skb)\n{\n\tstruct ath9k_htc_tx_ctl *tx_ctl;\n\n\ttx_ctl = HTC_SKB_CB(skb);\n\treturn htc_issue_send(target, skb, skb->len, 0, tx_ctl->epid);\n}\n\nint htc_send_epid(struct htc_target *target, struct sk_buff *skb,\n\t\t  enum htc_endpoint_id epid)\n{\n\treturn htc_issue_send(target, skb, skb->len, 0, epid);\n}\n\nvoid htc_stop(struct htc_target *target)\n{\n\ttarget->hif->stop(target->hif_dev);\n}\n\nvoid htc_start(struct htc_target *target)\n{\n\ttarget->hif->start(target->hif_dev);\n}\n\nvoid htc_sta_drain(struct htc_target *target, u8 idx)\n{\n\ttarget->hif->sta_drain(target->hif_dev, idx);\n}\n\nvoid ath9k_htc_txcompletion_cb(struct htc_target *htc_handle,\n\t\t\t       struct sk_buff *skb, bool txok)\n{\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_frame_hdr *htc_hdr = NULL;\n\n\tif (htc_handle->htc_flags & HTC_OP_CONFIG_PIPE_CREDITS) {\n\t\tcomplete(&htc_handle->cmd_wait);\n\t\thtc_handle->htc_flags &= ~HTC_OP_CONFIG_PIPE_CREDITS;\n\t\tgoto ret;\n\t}\n\n\tif (htc_handle->htc_flags & HTC_OP_START_WAIT) {\n\t\tcomplete(&htc_handle->cmd_wait);\n\t\thtc_handle->htc_flags &= ~HTC_OP_START_WAIT;\n\t\tgoto ret;\n\t}\n\n\tif (skb) {\n\t\thtc_hdr = (struct htc_frame_hdr *) skb->data;\n\t\tif (htc_hdr->endpoint_id >= ARRAY_SIZE(htc_handle->endpoint))\n\t\t\tgoto ret;\n\t\tendpoint = &htc_handle->endpoint[htc_hdr->endpoint_id];\n\t\tskb_pull(skb, sizeof(struct htc_frame_hdr));\n\n\t\tif (endpoint->ep_callbacks.tx) {\n\t\t\tendpoint->ep_callbacks.tx(endpoint->ep_callbacks.priv,\n\t\t\t\t\t\t  skb, htc_hdr->endpoint_id,\n\t\t\t\t\t\t  txok);\n\t\t} else {\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n\n\treturn;\nret:\n\tkfree_skb(skb);\n}\n\nstatic void ath9k_htc_fw_panic_report(struct htc_target *htc_handle,\n\t\t\t\t      struct sk_buff *skb, u32 len)\n{\n\tuint32_t *pattern = (uint32_t *)skb->data;\n\n\tif (*pattern == 0x33221199 && len >= sizeof(struct htc_panic_bad_vaddr)) {\n\t\tstruct htc_panic_bad_vaddr *htc_panic;\n\t\thtc_panic = (struct htc_panic_bad_vaddr *) skb->data;\n\t\tdev_err(htc_handle->dev, \"ath: firmware panic! \"\n\t\t\t\"exccause: 0x%08x; pc: 0x%08x; badvaddr: 0x%08x.\\n\",\n\t\t\thtc_panic->exccause, htc_panic->pc,\n\t\t\thtc_panic->badvaddr);\n\t\treturn;\n\t}\n\tif (*pattern == 0x33221299) {\n\t\tstruct htc_panic_bad_epid *htc_panic;\n\t\thtc_panic = (struct htc_panic_bad_epid *) skb->data;\n\t\tdev_err(htc_handle->dev, \"ath: firmware panic! \"\n\t\t\t\"bad epid: 0x%08x\\n\", htc_panic->epid);\n\t\treturn;\n\t}\n\tdev_err(htc_handle->dev, \"ath: unknown panic pattern!\\n\");\n}\n\n \nvoid ath9k_htc_rx_msg(struct htc_target *htc_handle,\n\t\t      struct sk_buff *skb, u32 len, u8 pipe_id)\n{\n\tstruct htc_frame_hdr *htc_hdr;\n\tenum htc_endpoint_id epid;\n\tstruct htc_endpoint *endpoint;\n\t__be16 *msg_id;\n\n\tif (!htc_handle || !skb)\n\t\treturn;\n\n\t \n\tif (unlikely(len < sizeof(struct htc_frame_hdr)))\n\t\tgoto invalid;\n\thtc_hdr = (struct htc_frame_hdr *) skb->data;\n\tepid = htc_hdr->endpoint_id;\n\n\tif (epid == 0x99) {\n\t\tath9k_htc_fw_panic_report(htc_handle, skb, len);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tif (epid < 0 || epid >= ENDPOINT_MAX) {\ninvalid:\n\t\tif (pipe_id != USB_REG_IN_PIPE)\n\t\t\tdev_kfree_skb_any(skb);\n\t\telse\n\t\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tif (epid == ENDPOINT0) {\n\n\t\t \n\t\tif (htc_hdr->flags & HTC_FLAGS_RECV_TRAILER) {\n\t\t\tif (be32_to_cpu(*(__be32 *) skb->data) == 0x00C60000) {\n\t\t\t\t \n\t\t\t\thtc_hdr = (struct htc_frame_hdr *)(skb->data + 4);\n\t\t\t\tlen -= 4;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (unlikely(len < sizeof(struct htc_frame_hdr) + sizeof(__be16)))\n\t\t\tgoto invalid;\n\t\tmsg_id = (__be16 *) ((void *) htc_hdr +\n\t\t\t\t     sizeof(struct htc_frame_hdr));\n\n\t\t \n\t\tswitch (be16_to_cpu(*msg_id)) {\n\t\tcase HTC_MSG_READY_ID:\n\t\t\tif (unlikely(len < sizeof(struct htc_ready_msg)))\n\t\t\t\tgoto invalid;\n\t\t\thtc_process_target_rdy(htc_handle, htc_hdr);\n\t\t\tbreak;\n\t\tcase HTC_MSG_CONNECT_SERVICE_RESPONSE_ID:\n\t\t\tif (unlikely(len < sizeof(struct htc_frame_hdr) +\n\t\t\t\t     sizeof(struct htc_conn_svc_rspmsg)))\n\t\t\t\tgoto invalid;\n\t\t\thtc_process_conn_rsp(htc_handle, htc_hdr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tkfree_skb(skb);\n\n\t} else {\n\t\tif (htc_hdr->flags & HTC_FLAGS_RECV_TRAILER)\n\t\t\tskb_trim(skb, len - htc_hdr->control[0]);\n\n\t\tskb_pull(skb, sizeof(struct htc_frame_hdr));\n\n\t\tendpoint = &htc_handle->endpoint[epid];\n\t\tif (endpoint->ep_callbacks.rx)\n\t\t\tendpoint->ep_callbacks.rx(endpoint->ep_callbacks.priv,\n\t\t\t\t\t\t  skb, epid);\n\t\telse\n\t\t\tgoto invalid;\n\t}\n}\n\nstruct htc_target *ath9k_htc_hw_alloc(void *hif_handle,\n\t\t\t\t      struct ath9k_htc_hif *hif,\n\t\t\t\t      struct device *dev)\n{\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_target *target;\n\n\ttarget = kzalloc(sizeof(struct htc_target), GFP_KERNEL);\n\tif (!target)\n\t\treturn NULL;\n\n\tinit_completion(&target->target_wait);\n\tinit_completion(&target->cmd_wait);\n\n\ttarget->hif = hif;\n\ttarget->hif_dev = hif_handle;\n\ttarget->dev = dev;\n\n\t \n\tendpoint = &target->endpoint[ENDPOINT0];\n\tendpoint->ul_pipeid = hif->control_ul_pipe;\n\tendpoint->dl_pipeid = hif->control_dl_pipe;\n\n\tatomic_set(&target->tgt_ready, 0);\n\n\treturn target;\n}\n\nvoid ath9k_htc_hw_free(struct htc_target *htc)\n{\n\tkfree(htc);\n}\n\nint ath9k_htc_hw_init(struct htc_target *target,\n\t\t      struct device *dev, u16 devid,\n\t\t      char *product, u32 drv_info)\n{\n\tif (ath9k_htc_probe_device(target, dev, devid, product, drv_info)) {\n\t\tpr_err(\"Failed to initialize the device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nvoid ath9k_htc_hw_deinit(struct htc_target *target, bool hot_unplug)\n{\n\tif (target)\n\t\tath9k_htc_disconnect_device(target, hot_unplug);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}