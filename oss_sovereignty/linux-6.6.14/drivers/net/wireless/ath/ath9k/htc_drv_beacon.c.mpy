{
  "module_name": "htc_drv_beacon.c",
  "hash_id": "9134bfbe799f240327188ce8f10189d39f1f353dd1fe342eed7acdf90e772a55",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/htc_drv_beacon.c",
  "human_readable_source": " \n\n#include \"htc.h\"\n\n#define FUDGE 2\n\nvoid ath9k_htc_beaconq_config(struct ath9k_htc_priv *priv)\n{\n\tstruct ath_hw *ah = priv->ah;\n\tstruct ath9k_tx_queue_info qi, qi_be;\n\n\tmemset(&qi, 0, sizeof(struct ath9k_tx_queue_info));\n\tmemset(&qi_be, 0, sizeof(struct ath9k_tx_queue_info));\n\n\tath9k_hw_get_txq_props(ah, priv->beacon.beaconq, &qi);\n\n\tif (priv->ah->opmode == NL80211_IFTYPE_AP ||\n\t    priv->ah->opmode == NL80211_IFTYPE_MESH_POINT) {\n\t\tqi.tqi_aifs = 1;\n\t\tqi.tqi_cwmin = 0;\n\t\tqi.tqi_cwmax = 0;\n\t} else if (priv->ah->opmode == NL80211_IFTYPE_ADHOC) {\n\t\tint qnum = priv->hwq_map[IEEE80211_AC_BE];\n\n\t\tath9k_hw_get_txq_props(ah, qnum, &qi_be);\n\n\t\tqi.tqi_aifs = qi_be.tqi_aifs;\n\n\t\t \n\t\tif (ah->slottime == 20)\n\t\t\tqi.tqi_cwmin = 2*qi_be.tqi_cwmin;\n\t\telse\n\t\t\tqi.tqi_cwmin = 4*qi_be.tqi_cwmin;\n\n\t\tqi.tqi_cwmax = qi_be.tqi_cwmax;\n\n\t}\n\n\tif (!ath9k_hw_set_txq_props(ah, priv->beacon.beaconq, &qi)) {\n\t\tath_err(ath9k_hw_common(ah),\n\t\t\t\"Unable to update beacon queue %u!\\n\", priv->beacon.beaconq);\n\t} else {\n\t\tath9k_hw_resettxqueue(ah, priv->beacon.beaconq);\n\t}\n}\n\n \nstatic void ath9k_htc_beacon_init(struct ath9k_htc_priv *priv,\n\t\t\t\t  struct ath_beacon_config *conf,\n\t\t\t\t  bool reset_tsf)\n{\n\tstruct ath_hw *ah = priv->ah;\n\tint ret __attribute__ ((unused));\n\t__be32 htc_imask = 0;\n\tu8 cmd_rsp;\n\n\tif (conf->intval >= TU_TO_USEC(DEFAULT_SWBA_RESPONSE))\n\t\tah->config.sw_beacon_response_time = DEFAULT_SWBA_RESPONSE;\n\telse\n\t\tah->config.sw_beacon_response_time = MIN_SWBA_RESPONSE;\n\n\tWMI_CMD(WMI_DISABLE_INTR_CMDID);\n\tif (reset_tsf)\n\t\tath9k_hw_reset_tsf(ah);\n\tath9k_htc_beaconq_config(priv);\n\tath9k_hw_beaconinit(ah, conf->nexttbtt, conf->intval);\n\tpriv->beacon.bmisscnt = 0;\n\thtc_imask = cpu_to_be32(ah->imask);\n\tWMI_CMD_BUF(WMI_ENABLE_INTR_CMDID, &htc_imask);\n}\n\nstatic void ath9k_htc_beacon_config_sta(struct ath9k_htc_priv *priv,\n\t\t\t\t\tstruct ath_beacon_config *bss_conf)\n{\n\tstruct ath9k_beacon_state bs;\n\tenum ath9k_int imask = 0;\n\t__be32 htc_imask = 0;\n\tint ret __attribute__ ((unused));\n\tu8 cmd_rsp;\n\n\tif (ath9k_cmn_beacon_config_sta(priv->ah, bss_conf, &bs) == -EPERM)\n\t\treturn;\n\n\tWMI_CMD(WMI_DISABLE_INTR_CMDID);\n\tath9k_hw_set_sta_beacon_timers(priv->ah, &bs);\n\timask |= ATH9K_INT_BMISS;\n\thtc_imask = cpu_to_be32(imask);\n\tWMI_CMD_BUF(WMI_ENABLE_INTR_CMDID, &htc_imask);\n}\n\nstatic void ath9k_htc_beacon_config_ap(struct ath9k_htc_priv *priv,\n\t\t\t\t       struct ath_beacon_config *conf)\n{\n\tstruct ath_hw *ah = priv->ah;\n\tah->imask = 0;\n\n\tath9k_cmn_beacon_config_ap(ah, conf, ATH9K_HTC_MAX_BCN_VIF);\n\tath9k_htc_beacon_init(priv, conf, false);\n}\n\nstatic void ath9k_htc_beacon_config_adhoc(struct ath9k_htc_priv *priv,\n\t\t\t\t\t  struct ath_beacon_config *conf)\n{\n\tstruct ath_hw *ah = priv->ah;\n\tah->imask = 0;\n\n\tath9k_cmn_beacon_config_adhoc(ah, conf);\n\tath9k_htc_beacon_init(priv, conf, conf->ibss_creator);\n}\n\nvoid ath9k_htc_beaconep(void *drv_priv, struct sk_buff *skb,\n\t\t\tenum htc_endpoint_id ep_id, bool txok)\n{\n\tdev_kfree_skb_any(skb);\n}\n\nstatic void ath9k_htc_send_buffered(struct ath9k_htc_priv *priv,\n\t\t\t\t    int slot)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ieee80211_vif *vif;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr *hdr;\n\tint padpos, padsize, ret, tx_slot;\n\n\tspin_lock_bh(&priv->beacon_lock);\n\n\tvif = priv->beacon.bslot[slot];\n\n\tskb = ieee80211_get_buffered_bc(priv->hw, vif);\n\n\twhile(skb) {\n\t\thdr = (struct ieee80211_hdr *) skb->data;\n\n\t\tpadpos = ieee80211_hdrlen(hdr->frame_control);\n\t\tpadsize = padpos & 3;\n\t\tif (padsize && skb->len > padpos) {\n\t\t\tif (skb_headroom(skb) < padsize) {\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tskb_push(skb, padsize);\n\t\t\tmemmove(skb->data, skb->data + padsize, padpos);\n\t\t}\n\n\t\ttx_slot = ath9k_htc_tx_get_slot(priv);\n\t\tif (tx_slot < 0) {\n\t\t\tath_dbg(common, XMIT, \"No free CAB slot\\n\");\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tgoto next;\n\t\t}\n\n\t\tret = ath9k_htc_tx_start(priv, NULL, skb, tx_slot, true);\n\t\tif (ret != 0) {\n\t\t\tath9k_htc_tx_clear_slot(priv, tx_slot);\n\t\t\tdev_kfree_skb_any(skb);\n\n\t\t\tath_dbg(common, XMIT, \"Failed to send CAB frame\\n\");\n\t\t} else {\n\t\t\tspin_lock_bh(&priv->tx.tx_lock);\n\t\t\tpriv->tx.queued_cnt++;\n\t\t\tspin_unlock_bh(&priv->tx.tx_lock);\n\t\t}\n\tnext:\n\t\tskb = ieee80211_get_buffered_bc(priv->hw, vif);\n\t}\n\n\tspin_unlock_bh(&priv->beacon_lock);\n}\n\nstatic void ath9k_htc_send_beacon(struct ath9k_htc_priv *priv,\n\t\t\t\t  int slot)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ieee80211_vif *vif;\n\tstruct ath9k_htc_vif *avp;\n\tstruct tx_beacon_header beacon_hdr;\n\tstruct ath9k_htc_tx_ctl *tx_ctl;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_mgmt *mgmt;\n\tstruct sk_buff *beacon;\n\tu8 *tx_fhdr;\n\tint ret;\n\n\tmemset(&beacon_hdr, 0, sizeof(struct tx_beacon_header));\n\n\tspin_lock_bh(&priv->beacon_lock);\n\n\tvif = priv->beacon.bslot[slot];\n\tavp = (struct ath9k_htc_vif *)vif->drv_priv;\n\n\tif (unlikely(test_bit(ATH_OP_SCANNING, &common->op_flags))) {\n\t\tspin_unlock_bh(&priv->beacon_lock);\n\t\treturn;\n\t}\n\n\t \n\tbeacon = ieee80211_beacon_get(priv->hw, vif, 0);\n\tif (!beacon) {\n\t\tspin_unlock_bh(&priv->beacon_lock);\n\t\treturn;\n\t}\n\n\t \n\tmgmt = (struct ieee80211_mgmt *)beacon->data;\n\tmgmt->u.beacon.timestamp = avp->tsfadjust;\n\n\tinfo = IEEE80211_SKB_CB(beacon);\n\tif (info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ) {\n\t\tstruct ieee80211_hdr *hdr =\n\t\t\t(struct ieee80211_hdr *) beacon->data;\n\t\tavp->seq_no += 0x10;\n\t\thdr->seq_ctrl &= cpu_to_le16(IEEE80211_SCTL_FRAG);\n\t\thdr->seq_ctrl |= cpu_to_le16(avp->seq_no);\n\t}\n\n\ttx_ctl = HTC_SKB_CB(beacon);\n\tmemset(tx_ctl, 0, sizeof(*tx_ctl));\n\n\ttx_ctl->type = ATH9K_HTC_BEACON;\n\ttx_ctl->epid = priv->beacon_ep;\n\n\tbeacon_hdr.vif_index = avp->index;\n\ttx_fhdr = skb_push(beacon, sizeof(beacon_hdr));\n\tmemcpy(tx_fhdr, (u8 *) &beacon_hdr, sizeof(beacon_hdr));\n\n\tret = htc_send(priv->htc, beacon);\n\tif (ret != 0) {\n\t\tif (ret == -ENOMEM) {\n\t\t\tath_dbg(common, BSTUCK,\n\t\t\t\t\"Failed to send beacon, no free TX buffer\\n\");\n\t\t}\n\t\tdev_kfree_skb_any(beacon);\n\t}\n\n\tspin_unlock_bh(&priv->beacon_lock);\n\n\tath9k_htc_csa_is_finished(priv);\n}\n\nstatic int ath9k_htc_choose_bslot(struct ath9k_htc_priv *priv,\n\t\t\t\t  struct wmi_event_swba *swba)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tu64 tsf;\n\tu32 tsftu;\n\tu16 intval;\n\tint slot;\n\n\tintval = priv->cur_beacon_conf.beacon_interval;\n\n\ttsf = be64_to_cpu(swba->tsf);\n\ttsftu = TSF_TO_TU(tsf >> 32, tsf);\n\tslot = ((tsftu % intval) * ATH9K_HTC_MAX_BCN_VIF) / intval;\n\tslot = ATH9K_HTC_MAX_BCN_VIF - slot - 1;\n\n\tath_dbg(common, BEACON,\n\t\t\"Choose slot: %d, tsf: %llu, tsftu: %u, intval: %u\\n\",\n\t\tslot, tsf, tsftu, intval);\n\n\treturn slot;\n}\n\nvoid ath9k_htc_swba(struct ath9k_htc_priv *priv,\n\t\t    struct wmi_event_swba *swba)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tint slot;\n\n\tif (swba->beacon_pending != 0) {\n\t\tpriv->beacon.bmisscnt++;\n\t\tif (priv->beacon.bmisscnt > BSTUCK_THRESHOLD) {\n\t\t\tath_dbg(common, BSTUCK, \"Beacon stuck, HW reset\\n\");\n\t\t\tieee80211_queue_work(priv->hw,\n\t\t\t\t\t     &priv->fatal_work);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (priv->beacon.bmisscnt) {\n\t\tath_dbg(common, BSTUCK,\n\t\t\t\"Resuming beacon xmit after %u misses\\n\",\n\t\t\tpriv->beacon.bmisscnt);\n\t\tpriv->beacon.bmisscnt = 0;\n\t}\n\n\tslot = ath9k_htc_choose_bslot(priv, swba);\n\tspin_lock_bh(&priv->beacon_lock);\n\tif (priv->beacon.bslot[slot] == NULL) {\n\t\tspin_unlock_bh(&priv->beacon_lock);\n\t\treturn;\n\t}\n\tspin_unlock_bh(&priv->beacon_lock);\n\n\tath9k_htc_send_buffered(priv, slot);\n\tath9k_htc_send_beacon(priv, slot);\n}\n\nvoid ath9k_htc_assign_bslot(struct ath9k_htc_priv *priv,\n\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ath9k_htc_vif *avp = (struct ath9k_htc_vif *)vif->drv_priv;\n\tint i = 0;\n\n\tspin_lock_bh(&priv->beacon_lock);\n\tfor (i = 0; i < ATH9K_HTC_MAX_BCN_VIF; i++) {\n\t\tif (priv->beacon.bslot[i] == NULL) {\n\t\t\tavp->bslot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpriv->beacon.bslot[avp->bslot] = vif;\n\tspin_unlock_bh(&priv->beacon_lock);\n\n\tath_dbg(common, CONFIG, \"Added interface at beacon slot: %d\\n\",\n\t\tavp->bslot);\n}\n\nvoid ath9k_htc_remove_bslot(struct ath9k_htc_priv *priv,\n\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ath9k_htc_vif *avp = (struct ath9k_htc_vif *)vif->drv_priv;\n\n\tspin_lock_bh(&priv->beacon_lock);\n\tpriv->beacon.bslot[avp->bslot] = NULL;\n\tspin_unlock_bh(&priv->beacon_lock);\n\n\tath_dbg(common, CONFIG, \"Removed interface at beacon slot: %d\\n\",\n\t\tavp->bslot);\n}\n\n \nvoid ath9k_htc_set_tsfadjust(struct ath9k_htc_priv *priv,\n\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ath9k_htc_vif *avp = (struct ath9k_htc_vif *)vif->drv_priv;\n\tstruct ath_beacon_config *cur_conf = &priv->cur_beacon_conf;\n\tu64 tsfadjust;\n\n\tif (avp->bslot == 0)\n\t\treturn;\n\n\t \n\ttsfadjust = cur_conf->beacon_interval * avp->bslot / ATH9K_HTC_MAX_BCN_VIF;\n\tavp->tsfadjust = cpu_to_le64(TU_TO_USEC(tsfadjust));\n\n\tath_dbg(common, CONFIG, \"tsfadjust is: %llu for bslot: %d\\n\",\n\t\t(unsigned long long)tsfadjust, avp->bslot);\n}\n\nstatic void ath9k_htc_beacon_iter(void *data, u8 *mac, struct ieee80211_vif *vif)\n{\n\tbool *beacon_configured = data;\n\tstruct ath9k_htc_vif *avp = (struct ath9k_htc_vif *) vif->drv_priv;\n\n\tif (vif->type == NL80211_IFTYPE_STATION &&\n\t    avp->beacon_configured)\n\t\t*beacon_configured = true;\n}\n\nstatic bool ath9k_htc_check_beacon_config(struct ath9k_htc_priv *priv,\n\t\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ath_beacon_config *cur_conf = &priv->cur_beacon_conf;\n\tstruct ieee80211_bss_conf *bss_conf = &vif->bss_conf;\n\tbool beacon_configured;\n\n\t \n\tif ((priv->ah->opmode == NL80211_IFTYPE_AP) &&\n\t    (priv->num_ap_vif > 1) &&\n\t    (vif->type == NL80211_IFTYPE_AP) &&\n\t    (cur_conf->beacon_interval != bss_conf->beacon_int)) {\n\t\tath_dbg(common, CONFIG,\n\t\t\t\"Changing beacon interval of multiple AP interfaces !\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tif (priv->num_ap_vif &&\n\t    (vif->type != NL80211_IFTYPE_AP)) {\n\t\tath_dbg(common, CONFIG,\n\t\t\t\"HW in AP mode, cannot set STA beacon parameters\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tif ((priv->ah->opmode == NL80211_IFTYPE_STATION) &&\n\t    (priv->num_sta_vif > 1) &&\n\t    (vif->type == NL80211_IFTYPE_STATION)) {\n\t\tbeacon_configured = false;\n\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\tpriv->hw, IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\tath9k_htc_beacon_iter, &beacon_configured);\n\n\t\tif (beacon_configured) {\n\t\t\tath_dbg(common, CONFIG,\n\t\t\t\t\"Beacon already configured for a station interface\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nvoid ath9k_htc_beacon_config(struct ath9k_htc_priv *priv,\n\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ath_beacon_config *cur_conf = &priv->cur_beacon_conf;\n\tstruct ieee80211_bss_conf *bss_conf = &vif->bss_conf;\n\tstruct ath9k_htc_vif *avp = (struct ath9k_htc_vif *) vif->drv_priv;\n\n\tif (!ath9k_htc_check_beacon_config(priv, vif))\n\t\treturn;\n\n\tcur_conf->beacon_interval = bss_conf->beacon_int;\n\tif (cur_conf->beacon_interval == 0)\n\t\tcur_conf->beacon_interval = 100;\n\n\tcur_conf->dtim_period = bss_conf->dtim_period;\n\tcur_conf->bmiss_timeout =\n\t\tATH_DEFAULT_BMISS_LIMIT * cur_conf->beacon_interval;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tath9k_htc_beacon_config_sta(priv, cur_conf);\n\t\tavp->beacon_configured = true;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tath9k_htc_beacon_config_adhoc(priv, cur_conf);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_AP:\n\t\tath9k_htc_beacon_config_ap(priv, cur_conf);\n\t\tbreak;\n\tdefault:\n\t\tath_dbg(common, CONFIG, \"Unsupported beaconing mode\\n\");\n\t\treturn;\n\t}\n}\n\nvoid ath9k_htc_beacon_reconfig(struct ath9k_htc_priv *priv)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ath_beacon_config *cur_conf = &priv->cur_beacon_conf;\n\n\tswitch (priv->ah->opmode) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tath9k_htc_beacon_config_sta(priv, cur_conf);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tath9k_htc_beacon_config_adhoc(priv, cur_conf);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_AP:\n\t\tath9k_htc_beacon_config_ap(priv, cur_conf);\n\t\tbreak;\n\tdefault:\n\t\tath_dbg(common, CONFIG, \"Unsupported beaconing mode\\n\");\n\t\treturn;\n\t}\n}\n\nbool ath9k_htc_csa_is_finished(struct ath9k_htc_priv *priv)\n{\n\tstruct ieee80211_vif *vif;\n\n\tvif = priv->csa_vif;\n\tif (!vif || !vif->bss_conf.csa_active)\n\t\treturn false;\n\n\tif (!ieee80211_beacon_cntdwn_is_complete(vif))\n\t\treturn false;\n\n\tieee80211_csa_finish(vif);\n\n\tpriv->csa_vif = NULL;\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}