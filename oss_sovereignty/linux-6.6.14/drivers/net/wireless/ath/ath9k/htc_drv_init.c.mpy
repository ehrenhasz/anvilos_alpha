{
  "module_name": "htc_drv_init.c",
  "hash_id": "1e1b769f2bc8466a0abe24cb1a1fc4ba95723ae4335592c9f51d11a438220214",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/htc_drv_init.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"htc.h\"\n\nMODULE_AUTHOR(\"Atheros Communications\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DESCRIPTION(\"Atheros driver 802.11n HTC based wireless devices\");\n\nstatic unsigned int ath9k_debug = ATH_DBG_DEFAULT;\nmodule_param_named(debug, ath9k_debug, uint, 0);\nMODULE_PARM_DESC(debug, \"Debugging mask\");\n\nint htc_modparam_nohwcrypt;\nmodule_param_named(nohwcrypt, htc_modparam_nohwcrypt, int, 0444);\nMODULE_PARM_DESC(nohwcrypt, \"Disable hardware encryption\");\n\nstatic int ath9k_htc_btcoex_enable;\nmodule_param_named(btcoex_enable, ath9k_htc_btcoex_enable, int, 0444);\nMODULE_PARM_DESC(btcoex_enable, \"Enable wifi-BT coexistence\");\n\nstatic int ath9k_ps_enable;\nmodule_param_named(ps_enable, ath9k_ps_enable, int, 0444);\nMODULE_PARM_DESC(ps_enable, \"Enable WLAN PowerSave\");\n\nint htc_use_dev_fw = 0;\nmodule_param_named(use_dev_fw, htc_use_dev_fw, int, 0444);\nMODULE_PARM_DESC(use_dev_fw, \"Use development FW version\");\n\n#ifdef CONFIG_MAC80211_LEDS\nint ath9k_htc_led_blink = 1;\nmodule_param_named(blink, ath9k_htc_led_blink, int, 0444);\nMODULE_PARM_DESC(blink, \"Enable LED blink on activity\");\n\nstatic const struct ieee80211_tpt_blink ath9k_htc_tpt_blink[] = {\n\t{ .throughput = 0 * 1024, .blink_time = 334 },\n\t{ .throughput = 1 * 1024, .blink_time = 260 },\n\t{ .throughput = 5 * 1024, .blink_time = 220 },\n\t{ .throughput = 10 * 1024, .blink_time = 190 },\n\t{ .throughput = 20 * 1024, .blink_time = 170 },\n\t{ .throughput = 50 * 1024, .blink_time = 150 },\n\t{ .throughput = 70 * 1024, .blink_time = 130 },\n\t{ .throughput = 100 * 1024, .blink_time = 110 },\n\t{ .throughput = 200 * 1024, .blink_time = 80 },\n\t{ .throughput = 300 * 1024, .blink_time = 50 },\n};\n#endif\n\nstatic void ath9k_htc_op_ps_wakeup(struct ath_common *common)\n{\n\tath9k_htc_ps_wakeup((struct ath9k_htc_priv *) common->priv);\n}\n\nstatic void ath9k_htc_op_ps_restore(struct ath_common *common)\n{\n\tath9k_htc_ps_restore((struct ath9k_htc_priv *) common->priv);\n}\n\nstatic const struct ath_ps_ops ath9k_htc_ps_ops = {\n\t.wakeup = ath9k_htc_op_ps_wakeup,\n\t.restore = ath9k_htc_op_ps_restore,\n};\n\nstatic int ath9k_htc_wait_for_target(struct ath9k_htc_priv *priv)\n{\n\tunsigned long time_left;\n\n\tif (atomic_read(&priv->htc->tgt_ready) > 0) {\n\t\tatomic_dec(&priv->htc->tgt_ready);\n\t\treturn 0;\n\t}\n\n\t \n\ttime_left = wait_for_completion_timeout(&priv->htc->target_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(priv->dev, \"ath9k_htc: Target is unresponsive\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tatomic_dec(&priv->htc->tgt_ready);\n\n\treturn 0;\n}\n\nstatic void ath9k_deinit_priv(struct ath9k_htc_priv *priv)\n{\n\tath9k_hw_deinit(priv->ah);\n\tkfree(priv->ah);\n\tpriv->ah = NULL;\n}\n\nstatic void ath9k_deinit_device(struct ath9k_htc_priv *priv)\n{\n\tstruct ieee80211_hw *hw = priv->hw;\n\n\twiphy_rfkill_stop_polling(hw->wiphy);\n\tath9k_deinit_leds(priv);\n\tath9k_htc_deinit_debug(priv);\n\tieee80211_unregister_hw(hw);\n\tath9k_rx_cleanup(priv);\n\tath9k_tx_cleanup(priv);\n\tath9k_deinit_priv(priv);\n}\n\nstatic inline int ath9k_htc_connect_svc(struct ath9k_htc_priv *priv,\n\t\t\t\t\tu16 service_id,\n\t\t\t\t\tvoid (*tx) (void *,\n\t\t\t\t\t\t    struct sk_buff *,\n\t\t\t\t\t\t    enum htc_endpoint_id,\n\t\t\t\t\t\t    bool txok),\n\t\t\t\t\tenum htc_endpoint_id *ep_id)\n{\n\tstruct htc_service_connreq req;\n\n\tmemset(&req, 0, sizeof(struct htc_service_connreq));\n\n\treq.service_id = service_id;\n\treq.ep_callbacks.priv = priv;\n\treq.ep_callbacks.rx = ath9k_htc_rxep;\n\treq.ep_callbacks.tx = tx;\n\n\treturn htc_connect_service(priv->htc, &req, ep_id);\n}\n\nstatic int ath9k_init_htc_services(struct ath9k_htc_priv *priv, u16 devid,\n\t\t\t\t   u32 drv_info)\n{\n\tint ret;\n\n\t \n\tret = ath9k_wmi_connect(priv->htc, priv->wmi, &priv->wmi_cmd_ep);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = ath9k_htc_connect_svc(priv, WMI_BEACON_SVC, ath9k_htc_beaconep,\n\t\t\t\t    &priv->beacon_ep);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = ath9k_htc_connect_svc(priv, WMI_CAB_SVC, ath9k_htc_txep,\n\t\t\t\t    &priv->cab_ep);\n\tif (ret)\n\t\tgoto err;\n\n\n\t \n\tret = ath9k_htc_connect_svc(priv, WMI_UAPSD_SVC, ath9k_htc_txep,\n\t\t\t\t    &priv->uapsd_ep);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = ath9k_htc_connect_svc(priv, WMI_MGMT_SVC, ath9k_htc_txep,\n\t\t\t\t    &priv->mgmt_ep);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = ath9k_htc_connect_svc(priv, WMI_DATA_BE_SVC, ath9k_htc_txep,\n\t\t\t\t    &priv->data_be_ep);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = ath9k_htc_connect_svc(priv, WMI_DATA_BK_SVC, ath9k_htc_txep,\n\t\t\t\t    &priv->data_bk_ep);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = ath9k_htc_connect_svc(priv, WMI_DATA_VI_SVC, ath9k_htc_txep,\n\t\t\t\t    &priv->data_vi_ep);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = ath9k_htc_connect_svc(priv, WMI_DATA_VO_SVC, ath9k_htc_txep,\n\t\t\t\t    &priv->data_vo_ep);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\n\tif (IS_AR7010_DEVICE(drv_info))\n\t\tpriv->htc->credits = 45;\n\telse\n\t\tpriv->htc->credits = 33;\n\n\tret = htc_init(priv->htc);\n\tif (ret)\n\t\tgoto err;\n\n\tdev_info(priv->dev, \"ath9k_htc: HTC initialized with %d credits\\n\",\n\t\t priv->htc->credits);\n\n\treturn 0;\n\nerr:\n\tdev_err(priv->dev, \"ath9k_htc: Unable to initialize HTC services\\n\");\n\treturn ret;\n}\n\nstatic void ath9k_reg_notifier(struct wiphy *wiphy,\n\t\t\t       struct regulatory_request *request)\n{\n\tstruct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);\n\tstruct ath9k_htc_priv *priv = hw->priv;\n\n\tath_reg_notifier_apply(wiphy, request,\n\t\t\t       ath9k_hw_regulatory(priv->ah));\n}\n\nstatic unsigned int ath9k_regread(void *hw_priv, u32 reg_offset)\n{\n\tstruct ath_hw *ah = hw_priv;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;\n\t__be32 val, reg = cpu_to_be32(reg_offset);\n\tint r;\n\n\tr = ath9k_wmi_cmd(priv->wmi, WMI_REG_READ_CMDID,\n\t\t\t  (u8 *) &reg, sizeof(reg),\n\t\t\t  (u8 *) &val, sizeof(val),\n\t\t\t  100);\n\tif (unlikely(r)) {\n\t\tath_dbg(common, WMI, \"REGISTER READ FAILED: (0x%04x, %d)\\n\",\n\t\t\treg_offset, r);\n\t\treturn -1;\n\t}\n\n\treturn be32_to_cpu(val);\n}\n\nstatic void ath9k_multi_regread(void *hw_priv, u32 *addr,\n\t\t\t\tu32 *val, u16 count)\n{\n\tstruct ath_hw *ah = hw_priv;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;\n\t__be32 tmpaddr[8];\n\t__be32 tmpval[8];\n\tint i, ret;\n\n\tfor (i = 0; i < count; i++) {\n\t\ttmpaddr[i] = cpu_to_be32(addr[i]);\n\t}\n\n\tret = ath9k_wmi_cmd(priv->wmi, WMI_REG_READ_CMDID,\n\t\t\t   (u8 *)tmpaddr , sizeof(u32) * count,\n\t\t\t   (u8 *)tmpval, sizeof(u32) * count,\n\t\t\t   100);\n\tif (unlikely(ret)) {\n\t\tath_dbg(common, WMI,\n\t\t\t\"Multiple REGISTER READ FAILED (count: %d)\\n\", count);\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tval[i] = be32_to_cpu(tmpval[i]);\n\t}\n}\n\nstatic void ath9k_regwrite_multi(struct ath_common *common)\n{\n\tstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;\n\tu32 rsp_status;\n\tint r;\n\n\tr = ath9k_wmi_cmd(priv->wmi, WMI_REG_WRITE_CMDID,\n\t\t\t  (u8 *) &priv->wmi->multi_write,\n\t\t\t  sizeof(struct register_write) * priv->wmi->multi_write_idx,\n\t\t\t  (u8 *) &rsp_status, sizeof(rsp_status),\n\t\t\t  100);\n\tif (unlikely(r)) {\n\t\tath_dbg(common, WMI,\n\t\t\t\"REGISTER WRITE FAILED, multi len: %d\\n\",\n\t\t\tpriv->wmi->multi_write_idx);\n\t}\n\tpriv->wmi->multi_write_idx = 0;\n}\n\nstatic void ath9k_regwrite_single(void *hw_priv, u32 val, u32 reg_offset)\n{\n\tstruct ath_hw *ah = hw_priv;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;\n\tconst __be32 buf[2] = {\n\t\tcpu_to_be32(reg_offset),\n\t\tcpu_to_be32(val),\n\t};\n\tint r;\n\n\tr = ath9k_wmi_cmd(priv->wmi, WMI_REG_WRITE_CMDID,\n\t\t\t  (u8 *) &buf, sizeof(buf),\n\t\t\t  (u8 *) &val, sizeof(val),\n\t\t\t  100);\n\tif (unlikely(r)) {\n\t\tath_dbg(common, WMI, \"REGISTER WRITE FAILED:(0x%04x, %d)\\n\",\n\t\t\treg_offset, r);\n\t}\n}\n\nstatic void ath9k_regwrite_buffer(void *hw_priv, u32 val, u32 reg_offset)\n{\n\tstruct ath_hw *ah = hw_priv;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;\n\n\tmutex_lock(&priv->wmi->multi_write_mutex);\n\n\t \n\tpriv->wmi->multi_write[priv->wmi->multi_write_idx].reg =\n\t\tcpu_to_be32(reg_offset);\n\tpriv->wmi->multi_write[priv->wmi->multi_write_idx].val =\n\t\tcpu_to_be32(val);\n\n\tpriv->wmi->multi_write_idx++;\n\n\t \n\tif (priv->wmi->multi_write_idx == MAX_CMD_NUMBER)\n\t\tath9k_regwrite_multi(common);\n\n\tmutex_unlock(&priv->wmi->multi_write_mutex);\n}\n\nstatic void ath9k_regwrite(void *hw_priv, u32 val, u32 reg_offset)\n{\n\tstruct ath_hw *ah = hw_priv;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;\n\n\tif (atomic_read(&priv->wmi->mwrite_cnt))\n\t\tath9k_regwrite_buffer(hw_priv, val, reg_offset);\n\telse\n\t\tath9k_regwrite_single(hw_priv, val, reg_offset);\n}\n\nstatic void ath9k_enable_regwrite_buffer(void *hw_priv)\n{\n\tstruct ath_hw *ah = hw_priv;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;\n\n\tatomic_inc(&priv->wmi->mwrite_cnt);\n}\n\nstatic void ath9k_regwrite_flush(void *hw_priv)\n{\n\tstruct ath_hw *ah = hw_priv;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;\n\n\tatomic_dec(&priv->wmi->mwrite_cnt);\n\n\tmutex_lock(&priv->wmi->multi_write_mutex);\n\n\tif (priv->wmi->multi_write_idx)\n\t\tath9k_regwrite_multi(common);\n\n\tmutex_unlock(&priv->wmi->multi_write_mutex);\n}\n\nstatic void ath9k_reg_rmw_buffer(void *hw_priv,\n\t\t\t\t u32 reg_offset, u32 set, u32 clr)\n{\n\tstruct ath_hw *ah = hw_priv;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;\n\tu32 rsp_status;\n\tint r;\n\n\tmutex_lock(&priv->wmi->multi_rmw_mutex);\n\n\t \n\tpriv->wmi->multi_rmw[priv->wmi->multi_rmw_idx].reg =\n\t\tcpu_to_be32(reg_offset);\n\tpriv->wmi->multi_rmw[priv->wmi->multi_rmw_idx].set =\n\t\tcpu_to_be32(set);\n\tpriv->wmi->multi_rmw[priv->wmi->multi_rmw_idx].clr =\n\t\tcpu_to_be32(clr);\n\n\tpriv->wmi->multi_rmw_idx++;\n\n\t \n\tif (priv->wmi->multi_rmw_idx == MAX_RMW_CMD_NUMBER) {\n\t\tr = ath9k_wmi_cmd(priv->wmi, WMI_REG_RMW_CMDID,\n\t\t\t  (u8 *) &priv->wmi->multi_rmw,\n\t\t\t  sizeof(struct register_write) * priv->wmi->multi_rmw_idx,\n\t\t\t  (u8 *) &rsp_status, sizeof(rsp_status),\n\t\t\t  100);\n\t\tif (unlikely(r)) {\n\t\t\tath_dbg(common, WMI,\n\t\t\t\t\"REGISTER RMW FAILED, multi len: %d\\n\",\n\t\t\t\tpriv->wmi->multi_rmw_idx);\n\t\t}\n\t\tpriv->wmi->multi_rmw_idx = 0;\n\t}\n\n\tmutex_unlock(&priv->wmi->multi_rmw_mutex);\n}\n\nstatic void ath9k_reg_rmw_flush(void *hw_priv)\n{\n\tstruct ath_hw *ah = hw_priv;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;\n\tu32 rsp_status;\n\tint r;\n\n\tif (test_bit(HTC_FWFLAG_NO_RMW, &priv->fw_flags))\n\t\treturn;\n\n\tatomic_dec(&priv->wmi->m_rmw_cnt);\n\n\tmutex_lock(&priv->wmi->multi_rmw_mutex);\n\n\tif (priv->wmi->multi_rmw_idx) {\n\t\tr = ath9k_wmi_cmd(priv->wmi, WMI_REG_RMW_CMDID,\n\t\t\t  (u8 *) &priv->wmi->multi_rmw,\n\t\t\t  sizeof(struct register_rmw) * priv->wmi->multi_rmw_idx,\n\t\t\t  (u8 *) &rsp_status, sizeof(rsp_status),\n\t\t\t  100);\n\t\tif (unlikely(r)) {\n\t\t\tath_dbg(common, WMI,\n\t\t\t\t\"REGISTER RMW FAILED, multi len: %d\\n\",\n\t\t\t\tpriv->wmi->multi_rmw_idx);\n\t\t}\n\t\tpriv->wmi->multi_rmw_idx = 0;\n\t}\n\n\tmutex_unlock(&priv->wmi->multi_rmw_mutex);\n}\n\nstatic void ath9k_enable_rmw_buffer(void *hw_priv)\n{\n\tstruct ath_hw *ah = hw_priv;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;\n\n\tif (test_bit(HTC_FWFLAG_NO_RMW, &priv->fw_flags))\n\t\treturn;\n\n\tatomic_inc(&priv->wmi->m_rmw_cnt);\n}\n\nstatic void ath9k_reg_rmw_single(void *hw_priv,\n\t\t\t\t u32 reg_offset, u32 set, u32 clr)\n{\n\tstruct ath_hw *ah = hw_priv;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;\n\tstruct register_rmw buf, buf_ret;\n\tint ret;\n\n\tbuf.reg = cpu_to_be32(reg_offset);\n\tbuf.set = cpu_to_be32(set);\n\tbuf.clr = cpu_to_be32(clr);\n\n\tret = ath9k_wmi_cmd(priv->wmi, WMI_REG_RMW_CMDID,\n\t\t\t  (u8 *) &buf, sizeof(buf),\n\t\t\t  (u8 *) &buf_ret, sizeof(buf_ret),\n\t\t\t  100);\n\tif (unlikely(ret)) {\n\t\tath_dbg(common, WMI, \"REGISTER RMW FAILED:(0x%04x, %d)\\n\",\n\t\t\treg_offset, ret);\n\t}\n}\n\nstatic u32 ath9k_reg_rmw(void *hw_priv, u32 reg_offset, u32 set, u32 clr)\n{\n\tstruct ath_hw *ah = hw_priv;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;\n\n\tif (test_bit(HTC_FWFLAG_NO_RMW, &priv->fw_flags)) {\n\t\tu32 val;\n\n\t\tval = REG_READ(ah, reg_offset);\n\t\tval &= ~clr;\n\t\tval |= set;\n\t\tREG_WRITE(ah, reg_offset, val);\n\n\t\treturn 0;\n\t}\n\n\tif (atomic_read(&priv->wmi->m_rmw_cnt))\n\t\tath9k_reg_rmw_buffer(hw_priv, reg_offset, set, clr);\n\telse\n\t\tath9k_reg_rmw_single(hw_priv, reg_offset, set, clr);\n\n\treturn 0;\n}\n\nstatic void ath_usb_read_cachesize(struct ath_common *common, int *csz)\n{\n\t*csz = L1_CACHE_BYTES >> 2;\n}\n\nstatic bool ath_usb_eeprom_read(struct ath_common *common, u32 off, u16 *data)\n{\n\tstruct ath_hw *ah = (struct ath_hw *) common->ah;\n\n\t(void)REG_READ(ah, AR5416_EEPROM_OFFSET + (off << AR5416_EEPROM_S));\n\n\tif (!ath9k_hw_wait(ah,\n\t\t\t   AR_EEPROM_STATUS_DATA(ah),\n\t\t\t   AR_EEPROM_STATUS_DATA_BUSY |\n\t\t\t   AR_EEPROM_STATUS_DATA_PROT_ACCESS, 0,\n\t\t\t   AH_WAIT_TIMEOUT))\n\t\treturn false;\n\n\t*data = MS(REG_READ(ah, AR_EEPROM_STATUS_DATA(ah)),\n\t\t   AR_EEPROM_STATUS_DATA_VAL);\n\n\treturn true;\n}\n\nstatic const struct ath_bus_ops ath9k_usb_bus_ops = {\n\t.ath_bus_type = ATH_USB,\n\t.read_cachesize = ath_usb_read_cachesize,\n\t.eeprom_read = ath_usb_eeprom_read,\n};\n\nstatic int ath9k_init_queues(struct ath9k_htc_priv *priv)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->hwq_map); i++)\n\t\tpriv->hwq_map[i] = -1;\n\n\tpriv->beacon.beaconq = ath9k_hw_beaconq_setup(priv->ah);\n\tif (priv->beacon.beaconq == -1) {\n\t\tath_err(common, \"Unable to setup BEACON xmit queue\\n\");\n\t\tgoto err;\n\t}\n\n\tpriv->cabq = ath9k_htc_cabq_setup(priv);\n\tif (priv->cabq == -1) {\n\t\tath_err(common, \"Unable to setup CAB xmit queue\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!ath9k_htc_txq_setup(priv, IEEE80211_AC_BE)) {\n\t\tath_err(common, \"Unable to setup xmit queue for BE traffic\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!ath9k_htc_txq_setup(priv, IEEE80211_AC_BK)) {\n\t\tath_err(common, \"Unable to setup xmit queue for BK traffic\\n\");\n\t\tgoto err;\n\t}\n\tif (!ath9k_htc_txq_setup(priv, IEEE80211_AC_VI)) {\n\t\tath_err(common, \"Unable to setup xmit queue for VI traffic\\n\");\n\t\tgoto err;\n\t}\n\tif (!ath9k_htc_txq_setup(priv, IEEE80211_AC_VO)) {\n\t\tath_err(common, \"Unable to setup xmit queue for VO traffic\\n\");\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\treturn -EINVAL;\n}\n\nstatic void ath9k_init_misc(struct ath9k_htc_priv *priv)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\n\teth_broadcast_addr(common->bssidmask);\n\n\tcommon->last_rssi = ATH_RSSI_DUMMY_MARKER;\n\tpriv->ah->opmode = NL80211_IFTYPE_STATION;\n\n\tpriv->spec_priv.ah = priv->ah;\n\tpriv->spec_priv.spec_config.enabled = 0;\n\tpriv->spec_priv.spec_config.short_repeat = true;\n\tpriv->spec_priv.spec_config.count = 8;\n\tpriv->spec_priv.spec_config.endless = false;\n\tpriv->spec_priv.spec_config.period = 0x12;\n\tpriv->spec_priv.spec_config.fft_period = 0x02;\n}\n\nstatic int ath9k_init_priv(struct ath9k_htc_priv *priv,\n\t\t\t   u16 devid, char *product,\n\t\t\t   u32 drv_info)\n{\n\tstruct ath_hw *ah = NULL;\n\tstruct ath_common *common;\n\tint i, ret = 0, csz = 0;\n\n\tah = kzalloc(sizeof(struct ath_hw), GFP_KERNEL);\n\tif (!ah)\n\t\treturn -ENOMEM;\n\n\tah->dev = priv->dev;\n\tah->hw = priv->hw;\n\tah->hw_version.devid = devid;\n\tah->hw_version.usbdev = drv_info;\n\tah->ah_flags |= AH_USE_EEPROM;\n\tah->reg_ops.read = ath9k_regread;\n\tah->reg_ops.multi_read = ath9k_multi_regread;\n\tah->reg_ops.write = ath9k_regwrite;\n\tah->reg_ops.enable_write_buffer = ath9k_enable_regwrite_buffer;\n\tah->reg_ops.write_flush = ath9k_regwrite_flush;\n\tah->reg_ops.enable_rmw_buffer = ath9k_enable_rmw_buffer;\n\tah->reg_ops.rmw_flush = ath9k_reg_rmw_flush;\n\tah->reg_ops.rmw = ath9k_reg_rmw;\n\tpriv->ah = ah;\n\n\tcommon = ath9k_hw_common(ah);\n\tcommon->ops = &ah->reg_ops;\n\tcommon->ps_ops = &ath9k_htc_ps_ops;\n\tcommon->bus_ops = &ath9k_usb_bus_ops;\n\tcommon->ah = ah;\n\tcommon->hw = priv->hw;\n\tcommon->priv = priv;\n\tcommon->debug_mask = ath9k_debug;\n\tcommon->btcoex_enabled = ath9k_htc_btcoex_enable == 1;\n\tset_bit(ATH_OP_INVALID, &common->op_flags);\n\n\tspin_lock_init(&priv->beacon_lock);\n\tspin_lock_init(&priv->tx.tx_lock);\n\tmutex_init(&priv->mutex);\n\tmutex_init(&priv->htc_pm_lock);\n\ttasklet_setup(&priv->rx_tasklet, ath9k_rx_tasklet);\n\ttasklet_setup(&priv->tx_failed_tasklet, ath9k_tx_failed_tasklet);\n\tINIT_DELAYED_WORK(&priv->ani_work, ath9k_htc_ani_work);\n\tINIT_WORK(&priv->ps_work, ath9k_ps_work);\n\tINIT_WORK(&priv->fatal_work, ath9k_fatal_work);\n\ttimer_setup(&priv->tx.cleanup_timer, ath9k_htc_tx_cleanup_timer, 0);\n\n\t \n\tath_read_cachesize(common, &csz);\n\tcommon->cachelsz = csz << 2;  \n\n\tret = ath9k_hw_init(ah);\n\tif (ret) {\n\t\tath_err(common,\n\t\t\t\"Unable to initialize hardware; initialization status: %d\\n\",\n\t\t\tret);\n\t\tgoto err_hw;\n\t}\n\n\tret = ath9k_init_queues(priv);\n\tif (ret)\n\t\tgoto err_queues;\n\n\tfor (i = 0; i < ATH9K_HTC_MAX_BCN_VIF; i++)\n\t\tpriv->beacon.bslot[i] = NULL;\n\tpriv->beacon.slottime = 9;\n\n\tath9k_cmn_init_channels_rates(common);\n\tath9k_cmn_init_crypto(ah);\n\tath9k_init_misc(priv);\n\tath9k_htc_init_btcoex(priv, product);\n\n\treturn 0;\n\nerr_queues:\n\tath9k_hw_deinit(ah);\nerr_hw:\n\n\tkfree(ah);\n\tpriv->ah = NULL;\n\n\treturn ret;\n}\n\nstatic const struct ieee80211_iface_limit if_limits[] = {\n\t{ .max = 2,\t.types = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t BIT(NL80211_IFTYPE_P2P_CLIENT) },\n\t{ .max = 2,\t.types = BIT(NL80211_IFTYPE_AP) |\n#ifdef CONFIG_MAC80211_MESH\n\t\t\t\t BIT(NL80211_IFTYPE_MESH_POINT) |\n#endif\n\t\t\t\t BIT(NL80211_IFTYPE_P2P_GO) },\n};\n\nstatic const struct ieee80211_iface_combination if_comb = {\n\t.limits = if_limits,\n\t.n_limits = ARRAY_SIZE(if_limits),\n\t.max_interfaces = 2,\n\t.num_different_channels = 1,\n};\n\nstatic void ath9k_set_hw_capab(struct ath9k_htc_priv *priv,\n\t\t\t       struct ieee80211_hw *hw)\n{\n\tstruct ath_hw *ah = priv->ah;\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct base_eep_header *pBase;\n\n\tieee80211_hw_set(hw, HOST_BROADCAST_PS_BUFFERING);\n\tieee80211_hw_set(hw, MFP_CAPABLE);\n\tieee80211_hw_set(hw, REPORTS_TX_ACK_STATUS);\n\tieee80211_hw_set(hw, PS_NULLFUNC_STACK);\n\tieee80211_hw_set(hw, RX_INCLUDES_FCS);\n\tieee80211_hw_set(hw, HAS_RATE_CONTROL);\n\tieee80211_hw_set(hw, SPECTRUM_MGMT);\n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\tieee80211_hw_set(hw, AMPDU_AGGREGATION);\n\tieee80211_hw_set(hw, DOESNT_SUPPORT_QOS_NDP);\n\n\tif (ath9k_ps_enable)\n\t\tieee80211_hw_set(hw, SUPPORTS_PS);\n\n\thw->wiphy->interface_modes =\n\t\tBIT(NL80211_IFTYPE_STATION) |\n\t\tBIT(NL80211_IFTYPE_ADHOC) |\n\t\tBIT(NL80211_IFTYPE_AP) |\n\t\tBIT(NL80211_IFTYPE_P2P_GO) |\n\t\tBIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\tBIT(NL80211_IFTYPE_MESH_POINT) |\n\t\tBIT(NL80211_IFTYPE_OCB);\n\n\thw->wiphy->iface_combinations = &if_comb;\n\thw->wiphy->n_iface_combinations = 1;\n\n\thw->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;\n\n\thw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN |\n\t\t\t    WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL |\n\t\t\t    WIPHY_FLAG_HAS_CHANNEL_SWITCH;\n\n\thw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS;\n\n\thw->queues = 4;\n\thw->max_listen_interval = 1;\n\n\thw->vif_data_size = sizeof(struct ath9k_htc_vif);\n\thw->sta_data_size = sizeof(struct ath9k_htc_sta);\n\n\t \n\thw->extra_tx_headroom = sizeof(struct tx_frame_hdr) +\n\t\tsizeof(struct htc_frame_hdr) + 4;\n\n\tif (priv->ah->caps.hw_caps & ATH9K_HW_CAP_2GHZ)\n\t\thw->wiphy->bands[NL80211_BAND_2GHZ] =\n\t\t\t&common->sbands[NL80211_BAND_2GHZ];\n\tif (priv->ah->caps.hw_caps & ATH9K_HW_CAP_5GHZ)\n\t\thw->wiphy->bands[NL80211_BAND_5GHZ] =\n\t\t\t&common->sbands[NL80211_BAND_5GHZ];\n\n\tath9k_cmn_reload_chainmask(ah);\n\n\tpBase = ath9k_htc_get_eeprom_base(priv);\n\tif (pBase) {\n\t\thw->wiphy->available_antennas_rx = pBase->rxMask;\n\t\thw->wiphy->available_antennas_tx = pBase->txMask;\n\t}\n\n\tSET_IEEE80211_PERM_ADDR(hw, common->macaddr);\n\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\twiphy_ext_feature_set(hw->wiphy,\n\t\t\t      NL80211_EXT_FEATURE_MULTICAST_REGISTRATIONS);\n}\n\nstatic int ath9k_init_firmware_version(struct ath9k_htc_priv *priv)\n{\n\tstruct ieee80211_hw *hw = priv->hw;\n\tstruct wmi_fw_version cmd_rsp;\n\tint ret;\n\n\tmemset(&cmd_rsp, 0, sizeof(cmd_rsp));\n\n\tWMI_CMD(WMI_GET_FW_VERSION);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tpriv->fw_version_major = be16_to_cpu(cmd_rsp.major);\n\tpriv->fw_version_minor = be16_to_cpu(cmd_rsp.minor);\n\n\tsnprintf(hw->wiphy->fw_version, sizeof(hw->wiphy->fw_version), \"%d.%d\",\n\t\t priv->fw_version_major,\n\t\t priv->fw_version_minor);\n\n\tdev_info(priv->dev, \"ath9k_htc: FW Version: %d.%d\\n\",\n\t\t priv->fw_version_major,\n\t\t priv->fw_version_minor);\n\n\t \n\tif (priv->fw_version_major != MAJOR_VERSION_REQ ||\n\t    priv->fw_version_minor < MINOR_VERSION_REQ) {\n\t\tdev_err(priv->dev, \"ath9k_htc: Please upgrade to FW version %d.%d\\n\",\n\t\t\tMAJOR_VERSION_REQ, MINOR_VERSION_REQ);\n\t\treturn -EINVAL;\n\t}\n\n\tif (priv->fw_version_major == 1 && priv->fw_version_minor < 4)\n\t\tset_bit(HTC_FWFLAG_NO_RMW, &priv->fw_flags);\n\n\tdev_info(priv->dev, \"FW RMW support: %s\\n\",\n\t\ttest_bit(HTC_FWFLAG_NO_RMW, &priv->fw_flags) ? \"Off\" : \"On\");\n\n\treturn 0;\n}\n\nstatic int ath9k_init_device(struct ath9k_htc_priv *priv,\n\t\t\t     u16 devid, char *product, u32 drv_info)\n{\n\tstruct ieee80211_hw *hw = priv->hw;\n\tstruct ath_common *common;\n\tstruct ath_hw *ah;\n\tint error = 0;\n\tstruct ath_regulatory *reg;\n\tchar hw_name[64];\n\n\t \n\terror = ath9k_init_priv(priv, devid, product, drv_info);\n\tif (error != 0)\n\t\tgoto err_init;\n\n\tah = priv->ah;\n\tcommon = ath9k_hw_common(ah);\n\tath9k_set_hw_capab(priv, hw);\n\n\terror = ath9k_init_firmware_version(priv);\n\tif (error != 0)\n\t\tgoto err_fw;\n\n\t \n\terror = ath_regd_init(&common->regulatory, priv->hw->wiphy,\n\t\t\t      ath9k_reg_notifier);\n\tif (error)\n\t\tgoto err_regd;\n\n\treg = &common->regulatory;\n\n\t \n\terror = ath9k_tx_init(priv);\n\tif (error != 0)\n\t\tgoto err_tx;\n\n\t \n\terror = ath9k_rx_init(priv);\n\tif (error != 0)\n\t\tgoto err_rx;\n\n\tath9k_hw_disable(priv->ah);\n#ifdef CONFIG_MAC80211_LEDS\n\t \n\tpriv->led_cdev.default_trigger = ieee80211_create_tpt_led_trigger(priv->hw,\n\t\tIEEE80211_TPT_LEDTRIG_FL_RADIO, ath9k_htc_tpt_blink,\n\t\tARRAY_SIZE(ath9k_htc_tpt_blink));\n#endif\n\n\t \n\terror = ieee80211_register_hw(hw);\n\tif (error)\n\t\tgoto err_register;\n\n\t \n\tif (!ath_is_world_regd(reg)) {\n\t\terror = regulatory_hint(hw->wiphy, reg->alpha2);\n\t\tif (error)\n\t\t\tgoto err_world;\n\t}\n\n\terror = ath9k_htc_init_debug(priv->ah);\n\tif (error) {\n\t\tath_err(common, \"Unable to create debugfs files\\n\");\n\t\tgoto err_world;\n\t}\n\n\tath_dbg(common, CONFIG,\n\t\t\"WMI:%d, BCN:%d, CAB:%d, UAPSD:%d, MGMT:%d, BE:%d, BK:%d, VI:%d, VO:%d\\n\",\n\t\tpriv->wmi_cmd_ep,\n\t\tpriv->beacon_ep,\n\t\tpriv->cab_ep,\n\t\tpriv->uapsd_ep,\n\t\tpriv->mgmt_ep,\n\t\tpriv->data_be_ep,\n\t\tpriv->data_bk_ep,\n\t\tpriv->data_vi_ep,\n\t\tpriv->data_vo_ep);\n\n\tath9k_hw_name(priv->ah, hw_name, sizeof(hw_name));\n\twiphy_info(hw->wiphy, \"%s\\n\", hw_name);\n\n\tath9k_init_leds(priv);\n\tath9k_start_rfkill_poll(priv);\n\n\treturn 0;\n\nerr_world:\n\tieee80211_unregister_hw(hw);\nerr_register:\n\tath9k_rx_cleanup(priv);\nerr_rx:\n\tath9k_tx_cleanup(priv);\nerr_tx:\n\t \nerr_regd:\n\t \nerr_fw:\n\tath9k_deinit_priv(priv);\nerr_init:\n\treturn error;\n}\n\nint ath9k_htc_probe_device(struct htc_target *htc_handle, struct device *dev,\n\t\t\t   u16 devid, char *product, u32 drv_info)\n{\n\tstruct hif_device_usb *hif_dev;\n\tstruct ath9k_htc_priv *priv;\n\tstruct ieee80211_hw *hw;\n\tint ret;\n\n\thw = ieee80211_alloc_hw(sizeof(struct ath9k_htc_priv), &ath9k_htc_ops);\n\tif (!hw)\n\t\treturn -ENOMEM;\n\n\tpriv = hw->priv;\n\tpriv->hw = hw;\n\tpriv->htc = htc_handle;\n\tpriv->dev = dev;\n\tSET_IEEE80211_DEV(hw, priv->dev);\n\n\tret = ath9k_htc_wait_for_target(priv);\n\tif (ret)\n\t\tgoto err_free;\n\n\tpriv->wmi = ath9k_init_wmi(priv);\n\tif (!priv->wmi) {\n\t\tret = -EINVAL;\n\t\tgoto err_free;\n\t}\n\n\tret = ath9k_init_htc_services(priv, devid, drv_info);\n\tif (ret)\n\t\tgoto err_init;\n\n\tret = ath9k_init_device(priv, devid, product, drv_info);\n\tif (ret)\n\t\tgoto err_init;\n\n\thtc_handle->drv_priv = priv;\n\n\treturn 0;\n\nerr_init:\n\tath9k_stop_wmi(priv);\n\thif_dev = (struct hif_device_usb *)htc_handle->hif_dev;\n\tath9k_hif_usb_dealloc_urbs(hif_dev);\n\tath9k_destroy_wmi(priv);\nerr_free:\n\tieee80211_free_hw(hw);\n\treturn ret;\n}\n\nvoid ath9k_htc_disconnect_device(struct htc_target *htc_handle, bool hotunplug)\n{\n\tif (htc_handle->drv_priv) {\n\n\t\t \n\t\tif (hotunplug)\n\t\t\thtc_handle->drv_priv->ah->ah_flags |= AH_UNPLUGGED;\n\n\t\tath9k_deinit_device(htc_handle->drv_priv);\n\t\tath9k_stop_wmi(htc_handle->drv_priv);\n\t\tath9k_hif_usb_dealloc_urbs((struct hif_device_usb *)htc_handle->hif_dev);\n\t\tath9k_destroy_wmi(htc_handle->drv_priv);\n\t\tieee80211_free_hw(htc_handle->drv_priv->hw);\n\t}\n}\n\n#ifdef CONFIG_PM\n\nvoid ath9k_htc_suspend(struct htc_target *htc_handle)\n{\n\tath9k_htc_setpower(htc_handle->drv_priv, ATH9K_PM_FULL_SLEEP);\n}\n\nint ath9k_htc_resume(struct htc_target *htc_handle)\n{\n\tstruct ath9k_htc_priv *priv = htc_handle->drv_priv;\n\tint ret;\n\n\tret = ath9k_htc_wait_for_target(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ath9k_init_htc_services(priv, priv->ah->hw_version.devid,\n\t\t\t\t      priv->ah->hw_version.usbdev);\n\tath9k_configure_leds(priv);\n\n\treturn ret;\n}\n#endif\n\nstatic int __init ath9k_htc_init(void)\n{\n\tif (ath9k_hif_usb_init() < 0) {\n\t\tpr_err(\"No USB devices found, driver not installed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\nmodule_init(ath9k_htc_init);\n\nstatic void __exit ath9k_htc_exit(void)\n{\n\tath9k_hif_usb_exit();\n\tpr_info(\"Driver unloaded\\n\");\n}\nmodule_exit(ath9k_htc_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}