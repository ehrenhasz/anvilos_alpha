{
  "module_name": "tx99.c",
  "hash_id": "2669842486727e8f1ea592853ab826a92ce97431f2a818091df74adfd8e929c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/tx99.c",
  "human_readable_source": " \n\n#include \"ath9k.h\"\n\nstatic void ath9k_tx99_stop(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tath_drain_all_txq(sc);\n\tath_startrecv(sc);\n\n\tath9k_hw_set_interrupts(ah);\n\tath9k_hw_enable_interrupts(ah);\n\n\tieee80211_wake_queues(sc->hw);\n\n\tkfree_skb(sc->tx99_skb);\n\tsc->tx99_skb = NULL;\n\tsc->tx99_state = false;\n\n\tath9k_hw_tx99_stop(sc->sc_ah);\n\tath_dbg(common, XMIT, \"TX99 stopped\\n\");\n}\n\nstatic struct sk_buff *ath9k_build_tx99_skb(struct ath_softc *sc)\n{\n\tstatic u8 PN9Data[] = {0xff, 0x87, 0xb8, 0x59, 0xb7, 0xa1, 0xcc, 0x24,\n\t\t\t       0x57, 0x5e, 0x4b, 0x9c, 0x0e, 0xe9, 0xea, 0x50,\n\t\t\t       0x2a, 0xbe, 0xb4, 0x1b, 0xb6, 0xb0, 0x5d, 0xf1,\n\t\t\t       0xe6, 0x9a, 0xe3, 0x45, 0xfd, 0x2c, 0x53, 0x18,\n\t\t\t       0x0c, 0xca, 0xc9, 0xfb, 0x49, 0x37, 0xe5, 0xa8,\n\t\t\t       0x51, 0x3b, 0x2f, 0x61, 0xaa, 0x72, 0x18, 0x84,\n\t\t\t       0x02, 0x23, 0x23, 0xab, 0x63, 0x89, 0x51, 0xb3,\n\t\t\t       0xe7, 0x8b, 0x72, 0x90, 0x4c, 0xe8, 0xfb, 0xc0};\n\tu32 len = 1200;\n\tstruct ieee80211_tx_rate *rate;\n\tstruct ieee80211_hw *hw = sc->hw;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_tx_info *tx_info;\n\tstruct sk_buff *skb;\n\tstruct ath_vif *avp;\n\n\tskb = alloc_skb(len, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_put(skb, len);\n\n\tmemset(skb->data, 0, len);\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\thdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA);\n\thdr->duration_id = 0;\n\n\tmemcpy(hdr->addr1, hw->wiphy->perm_addr, ETH_ALEN);\n\tmemcpy(hdr->addr2, hw->wiphy->perm_addr, ETH_ALEN);\n\tmemcpy(hdr->addr3, hw->wiphy->perm_addr, ETH_ALEN);\n\n\tif (sc->tx99_vif) {\n\t\tavp = (struct ath_vif *) sc->tx99_vif->drv_priv;\n\t\thdr->seq_ctrl |= cpu_to_le16(avp->seq_no);\n\t}\n\n\ttx_info = IEEE80211_SKB_CB(skb);\n\tmemset(tx_info, 0, sizeof(*tx_info));\n\trate = &tx_info->control.rates[0];\n\ttx_info->band = sc->cur_chan->chandef.chan->band;\n\ttx_info->flags = IEEE80211_TX_CTL_NO_ACK;\n\ttx_info->control.vif = sc->tx99_vif;\n\trate->count = 1;\n\tif (ah->curchan && IS_CHAN_HT(ah->curchan)) {\n\t\trate->flags |= IEEE80211_TX_RC_MCS;\n\t\tif (IS_CHAN_HT40(ah->curchan))\n\t\t\trate->flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\n\t}\n\n\tmemcpy(skb->data + sizeof(*hdr), PN9Data, sizeof(PN9Data));\n\n\treturn skb;\n}\n\nstatic void ath9k_tx99_deinit(struct ath_softc *sc)\n{\n\tath_reset(sc, NULL);\n\n\tath9k_ps_wakeup(sc);\n\tath9k_tx99_stop(sc);\n\tath9k_ps_restore(sc);\n}\n\nstatic int ath9k_tx99_init(struct ath_softc *sc)\n{\n\tstruct ieee80211_hw *hw = sc->hw;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath_tx_control txctl;\n\tint r;\n\n\tif (test_bit(ATH_OP_INVALID, &common->op_flags)) {\n\t\tath_err(common,\n\t\t\t\"driver is in invalid state unable to use TX99\");\n\t\treturn -EINVAL;\n\t}\n\n\tsc->tx99_skb = ath9k_build_tx99_skb(sc);\n\tif (!sc->tx99_skb)\n\t\treturn -ENOMEM;\n\n\tmemset(&txctl, 0, sizeof(txctl));\n\ttxctl.txq = sc->tx.txq_map[IEEE80211_AC_VO];\n\n\tath_reset(sc, NULL);\n\n\tath9k_ps_wakeup(sc);\n\n\tath9k_hw_disable_interrupts(ah);\n\tath_drain_all_txq(sc);\n\tath_stoprecv(sc);\n\n\tsc->tx99_state = true;\n\n\tieee80211_stop_queues(hw);\n\n\tif (sc->tx99_power == MAX_RATE_POWER + 1)\n\t\tsc->tx99_power = MAX_RATE_POWER;\n\n\tath9k_hw_tx99_set_txpower(ah, sc->tx99_power);\n\tr = ath9k_tx99_send(sc, sc->tx99_skb, &txctl);\n\tif (r) {\n\t\tath_dbg(common, XMIT, \"Failed to xmit TX99 skb\\n\");\n\t\treturn r;\n\t}\n\n\tath_dbg(common, XMIT, \"TX99 xmit started using %d ( %ddBm)\\n\",\n\t\tsc->tx99_power,\n\t\tsc->tx99_power / 2);\n\n\t \n\n\treturn 0;\n}\n\nstatic ssize_t read_file_tx99(struct file *file, char __user *user_buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ath_softc *sc = file->private_data;\n\tchar buf[3];\n\tunsigned int len;\n\n\tlen = sprintf(buf, \"%d\\n\", sc->tx99_state);\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t write_file_tx99(struct file *file, const char __user *user_buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct ath_softc *sc = file->private_data;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tbool start;\n\tssize_t ret;\n\tint r;\n\n\tif (count < 1)\n\t\treturn -EINVAL;\n\n\tif (sc->cur_chan->nvifs > 1)\n\t\treturn -EOPNOTSUPP;\n\n\tret = kstrtobool_from_user(user_buf, count, &start);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&sc->mutex);\n\n\tif (start == sc->tx99_state) {\n\t\tif (!start)\n\t\t\tgoto out;\n\t\tath_dbg(common, XMIT, \"Resetting TX99\\n\");\n\t\tath9k_tx99_deinit(sc);\n\t}\n\n\tif (!start) {\n\t\tath9k_tx99_deinit(sc);\n\t\tgoto out;\n\t}\n\n\tr = ath9k_tx99_init(sc);\n\tif (r) {\n\t\tmutex_unlock(&sc->mutex);\n\t\treturn r;\n\t}\nout:\n\tmutex_unlock(&sc->mutex);\n\treturn count;\n}\n\nstatic const struct file_operations fops_tx99 = {\n\t.read = read_file_tx99,\n\t.write = write_file_tx99,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t read_file_tx99_power(struct file *file,\n\t\t\t\t    char __user *user_buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct ath_softc *sc = file->private_data;\n\tchar buf[32];\n\tunsigned int len;\n\n\tlen = sprintf(buf, \"%d (%d dBm)\\n\",\n\t\t      sc->tx99_power,\n\t\t      sc->tx99_power / 2);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t write_file_tx99_power(struct file *file,\n\t\t\t\t     const char __user *user_buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct ath_softc *sc = file->private_data;\n\tint r;\n\tu8 tx_power;\n\n\tr = kstrtou8_from_user(user_buf, count, 0, &tx_power);\n\tif (r)\n\t\treturn r;\n\n\tif (tx_power > MAX_RATE_POWER)\n\t\treturn -EINVAL;\n\n\tsc->tx99_power = tx_power;\n\n\tath9k_ps_wakeup(sc);\n\tath9k_hw_tx99_set_txpower(sc->sc_ah, sc->tx99_power);\n\tath9k_ps_restore(sc);\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_tx99_power = {\n\t.read = read_file_tx99_power,\n\t.write = write_file_tx99_power,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nvoid ath9k_tx99_init_debug(struct ath_softc *sc)\n{\n\tif (!AR_SREV_9280_20_OR_LATER(sc->sc_ah))\n\t\treturn;\n\n\tdebugfs_create_file(\"tx99\", 0600,\n\t\t\t    sc->debug.debugfs_phy, sc,\n\t\t\t    &fops_tx99);\n\tdebugfs_create_file(\"tx99_power\", 0600,\n\t\t\t    sc->debug.debugfs_phy, sc,\n\t\t\t    &fops_tx99_power);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}