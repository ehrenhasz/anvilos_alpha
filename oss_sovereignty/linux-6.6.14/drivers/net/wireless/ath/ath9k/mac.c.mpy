{
  "module_name": "mac.c",
  "hash_id": "4e83d27bf3c6661dce7b887a03e9d8fe292612587a9793de5edca09c13e805e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/mac.c",
  "human_readable_source": " \n\n#include \"hw.h\"\n#include \"hw-ops.h\"\n#include <linux/export.h>\n\nstatic void ath9k_hw_set_txq_interrupts(struct ath_hw *ah,\n\t\t\t\t\tstruct ath9k_tx_queue_info *qi)\n{\n\tath_dbg(ath9k_hw_common(ah), INTERRUPT,\n\t\t\"tx ok 0x%x err 0x%x desc 0x%x eol 0x%x urn 0x%x\\n\",\n\t\tah->txok_interrupt_mask, ah->txerr_interrupt_mask,\n\t\tah->txdesc_interrupt_mask, ah->txeol_interrupt_mask,\n\t\tah->txurn_interrupt_mask);\n\n\tENABLE_REGWRITE_BUFFER(ah);\n\n\tREG_WRITE(ah, AR_IMR_S0,\n\t\t  SM(ah->txok_interrupt_mask, AR_IMR_S0_QCU_TXOK)\n\t\t  | SM(ah->txdesc_interrupt_mask, AR_IMR_S0_QCU_TXDESC));\n\tREG_WRITE(ah, AR_IMR_S1,\n\t\t  SM(ah->txerr_interrupt_mask, AR_IMR_S1_QCU_TXERR)\n\t\t  | SM(ah->txeol_interrupt_mask, AR_IMR_S1_QCU_TXEOL));\n\n\tah->imrs2_reg &= ~AR_IMR_S2_QCU_TXURN;\n\tah->imrs2_reg |= (ah->txurn_interrupt_mask & AR_IMR_S2_QCU_TXURN);\n\tREG_WRITE(ah, AR_IMR_S2, ah->imrs2_reg);\n\n\tREGWRITE_BUFFER_FLUSH(ah);\n}\n\nu32 ath9k_hw_gettxbuf(struct ath_hw *ah, u32 q)\n{\n\treturn REG_READ(ah, AR_QTXDP(q));\n}\nEXPORT_SYMBOL(ath9k_hw_gettxbuf);\n\nvoid ath9k_hw_puttxbuf(struct ath_hw *ah, u32 q, u32 txdp)\n{\n\tREG_WRITE(ah, AR_QTXDP(q), txdp);\n}\nEXPORT_SYMBOL(ath9k_hw_puttxbuf);\n\nvoid ath9k_hw_txstart(struct ath_hw *ah, u32 q)\n{\n\tath_dbg(ath9k_hw_common(ah), QUEUE, \"Enable TXE on queue: %u\\n\", q);\n\tREG_WRITE(ah, AR_Q_TXE, 1 << q);\n}\nEXPORT_SYMBOL(ath9k_hw_txstart);\n\nu32 ath9k_hw_numtxpending(struct ath_hw *ah, u32 q)\n{\n\tu32 npend;\n\n\tnpend = REG_READ(ah, AR_QSTS(q)) & AR_Q_STS_PEND_FR_CNT;\n\tif (npend == 0) {\n\n\t\tif (REG_READ(ah, AR_Q_TXE) & (1 << q))\n\t\t\tnpend = 1;\n\t}\n\n\treturn npend;\n}\nEXPORT_SYMBOL(ath9k_hw_numtxpending);\n\n \nbool ath9k_hw_updatetxtriglevel(struct ath_hw *ah, bool bIncTrigLevel)\n{\n\tu32 txcfg, curLevel, newLevel;\n\n\tif (ah->tx_trig_level >= ah->config.max_txtrig_level)\n\t\treturn false;\n\n\tath9k_hw_disable_interrupts(ah);\n\n\ttxcfg = REG_READ(ah, AR_TXCFG);\n\tcurLevel = MS(txcfg, AR_FTRIG);\n\tnewLevel = curLevel;\n\tif (bIncTrigLevel) {\n\t\tif (curLevel < ah->config.max_txtrig_level)\n\t\t\tnewLevel++;\n\t} else if (curLevel > MIN_TX_FIFO_THRESHOLD)\n\t\tnewLevel--;\n\tif (newLevel != curLevel)\n\t\tREG_WRITE(ah, AR_TXCFG,\n\t\t\t  (txcfg & ~AR_FTRIG) | SM(newLevel, AR_FTRIG));\n\n\tath9k_hw_enable_interrupts(ah);\n\n\tah->tx_trig_level = newLevel;\n\n\treturn newLevel != curLevel;\n}\nEXPORT_SYMBOL(ath9k_hw_updatetxtriglevel);\n\nvoid ath9k_hw_abort_tx_dma(struct ath_hw *ah)\n{\n\tint maxdelay = 1000;\n\tint i, q;\n\n\tif (ah->curchan) {\n\t\tif (IS_CHAN_HALF_RATE(ah->curchan))\n\t\t\tmaxdelay *= 2;\n\t\telse if (IS_CHAN_QUARTER_RATE(ah->curchan))\n\t\t\tmaxdelay *= 4;\n\t}\n\n\tREG_WRITE(ah, AR_Q_TXD, AR_Q_TXD_M);\n\n\tREG_SET_BIT(ah, AR_PCU_MISC, AR_PCU_FORCE_QUIET_COLL | AR_PCU_CLEAR_VMF);\n\tREG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH);\n\tREG_SET_BIT(ah, AR_D_GBL_IFS_MISC, AR_D_GBL_IFS_MISC_IGNORE_BACKOFF);\n\n\tfor (q = 0; q < AR_NUM_QCU; q++) {\n\t\tfor (i = 0; i < maxdelay; i++) {\n\t\t\tif (i)\n\t\t\t\tudelay(5);\n\n\t\t\tif (!ath9k_hw_numtxpending(ah, q))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tREG_CLR_BIT(ah, AR_PCU_MISC, AR_PCU_FORCE_QUIET_COLL | AR_PCU_CLEAR_VMF);\n\tREG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH);\n\tREG_CLR_BIT(ah, AR_D_GBL_IFS_MISC, AR_D_GBL_IFS_MISC_IGNORE_BACKOFF);\n\n\tREG_WRITE(ah, AR_Q_TXD, 0);\n}\nEXPORT_SYMBOL(ath9k_hw_abort_tx_dma);\n\nbool ath9k_hw_stop_dma_queue(struct ath_hw *ah, u32 q)\n{\n#define ATH9K_TX_STOP_DMA_TIMEOUT\t1000     \n#define ATH9K_TIME_QUANTUM\t\t100      \n\tint wait_time = ATH9K_TX_STOP_DMA_TIMEOUT / ATH9K_TIME_QUANTUM;\n\tint wait;\n\n\tREG_WRITE(ah, AR_Q_TXD, 1 << q);\n\n\tfor (wait = wait_time; wait != 0; wait--) {\n\t\tif (wait != wait_time)\n\t\t\tudelay(ATH9K_TIME_QUANTUM);\n\n\t\tif (ath9k_hw_numtxpending(ah, q) == 0)\n\t\t\tbreak;\n\t}\n\n\tREG_WRITE(ah, AR_Q_TXD, 0);\n\n\treturn wait != 0;\n\n#undef ATH9K_TX_STOP_DMA_TIMEOUT\n#undef ATH9K_TIME_QUANTUM\n}\nEXPORT_SYMBOL(ath9k_hw_stop_dma_queue);\n\nbool ath9k_hw_set_txq_props(struct ath_hw *ah, int q,\n\t\t\t    const struct ath9k_tx_queue_info *qinfo)\n{\n\tu32 cw;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_tx_queue_info *qi;\n\n\tqi = &ah->txq[q];\n\tif (qi->tqi_type == ATH9K_TX_QUEUE_INACTIVE) {\n\t\tath_dbg(common, QUEUE,\n\t\t\t\"Set TXQ properties, inactive queue: %u\\n\", q);\n\t\treturn false;\n\t}\n\n\tath_dbg(common, QUEUE, \"Set queue properties for: %u\\n\", q);\n\n\tqi->tqi_ver = qinfo->tqi_ver;\n\tqi->tqi_subtype = qinfo->tqi_subtype;\n\tqi->tqi_qflags = qinfo->tqi_qflags;\n\tqi->tqi_priority = qinfo->tqi_priority;\n\tif (qinfo->tqi_aifs != ATH9K_TXQ_USEDEFAULT)\n\t\tqi->tqi_aifs = min(qinfo->tqi_aifs, 255U);\n\telse\n\t\tqi->tqi_aifs = INIT_AIFS;\n\tif (qinfo->tqi_cwmin != ATH9K_TXQ_USEDEFAULT) {\n\t\tcw = min(qinfo->tqi_cwmin, 1024U);\n\t\tqi->tqi_cwmin = 1;\n\t\twhile (qi->tqi_cwmin < cw)\n\t\t\tqi->tqi_cwmin = (qi->tqi_cwmin << 1) | 1;\n\t} else\n\t\tqi->tqi_cwmin = qinfo->tqi_cwmin;\n\tif (qinfo->tqi_cwmax != ATH9K_TXQ_USEDEFAULT) {\n\t\tcw = min(qinfo->tqi_cwmax, 1024U);\n\t\tqi->tqi_cwmax = 1;\n\t\twhile (qi->tqi_cwmax < cw)\n\t\t\tqi->tqi_cwmax = (qi->tqi_cwmax << 1) | 1;\n\t} else\n\t\tqi->tqi_cwmax = INIT_CWMAX;\n\n\tif (qinfo->tqi_shretry != 0)\n\t\tqi->tqi_shretry = min((u32) qinfo->tqi_shretry, 15U);\n\telse\n\t\tqi->tqi_shretry = INIT_SH_RETRY;\n\tif (qinfo->tqi_lgretry != 0)\n\t\tqi->tqi_lgretry = min((u32) qinfo->tqi_lgretry, 15U);\n\telse\n\t\tqi->tqi_lgretry = INIT_LG_RETRY;\n\tqi->tqi_cbrPeriod = qinfo->tqi_cbrPeriod;\n\tqi->tqi_cbrOverflowLimit = qinfo->tqi_cbrOverflowLimit;\n\tqi->tqi_burstTime = qinfo->tqi_burstTime;\n\tqi->tqi_readyTime = qinfo->tqi_readyTime;\n\n\tswitch (qinfo->tqi_subtype) {\n\tcase ATH9K_WME_UPSD:\n\t\tif (qi->tqi_type == ATH9K_TX_QUEUE_DATA)\n\t\t\tqi->tqi_intFlags = ATH9K_TXQ_USE_LOCKOUT_BKOFF_DIS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(ath9k_hw_set_txq_props);\n\nbool ath9k_hw_get_txq_props(struct ath_hw *ah, int q,\n\t\t\t    struct ath9k_tx_queue_info *qinfo)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_tx_queue_info *qi;\n\n\tqi = &ah->txq[q];\n\tif (qi->tqi_type == ATH9K_TX_QUEUE_INACTIVE) {\n\t\tath_dbg(common, QUEUE,\n\t\t\t\"Get TXQ properties, inactive queue: %u\\n\", q);\n\t\treturn false;\n\t}\n\n\tqinfo->tqi_qflags = qi->tqi_qflags;\n\tqinfo->tqi_ver = qi->tqi_ver;\n\tqinfo->tqi_subtype = qi->tqi_subtype;\n\tqinfo->tqi_qflags = qi->tqi_qflags;\n\tqinfo->tqi_priority = qi->tqi_priority;\n\tqinfo->tqi_aifs = qi->tqi_aifs;\n\tqinfo->tqi_cwmin = qi->tqi_cwmin;\n\tqinfo->tqi_cwmax = qi->tqi_cwmax;\n\tqinfo->tqi_shretry = qi->tqi_shretry;\n\tqinfo->tqi_lgretry = qi->tqi_lgretry;\n\tqinfo->tqi_cbrPeriod = qi->tqi_cbrPeriod;\n\tqinfo->tqi_cbrOverflowLimit = qi->tqi_cbrOverflowLimit;\n\tqinfo->tqi_burstTime = qi->tqi_burstTime;\n\tqinfo->tqi_readyTime = qi->tqi_readyTime;\n\n\treturn true;\n}\nEXPORT_SYMBOL(ath9k_hw_get_txq_props);\n\nint ath9k_hw_setuptxqueue(struct ath_hw *ah, enum ath9k_tx_queue type,\n\t\t\t  const struct ath9k_tx_queue_info *qinfo)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_tx_queue_info *qi;\n\tint q;\n\n\tswitch (type) {\n\tcase ATH9K_TX_QUEUE_BEACON:\n\t\tq = ATH9K_NUM_TX_QUEUES - 1;\n\t\tbreak;\n\tcase ATH9K_TX_QUEUE_CAB:\n\t\tq = ATH9K_NUM_TX_QUEUES - 2;\n\t\tbreak;\n\tcase ATH9K_TX_QUEUE_PSPOLL:\n\t\tq = 1;\n\t\tbreak;\n\tcase ATH9K_TX_QUEUE_UAPSD:\n\t\tq = ATH9K_NUM_TX_QUEUES - 3;\n\t\tbreak;\n\tcase ATH9K_TX_QUEUE_DATA:\n\t\tq = qinfo->tqi_subtype;\n\t\tbreak;\n\tdefault:\n\t\tath_err(common, \"Invalid TX queue type: %u\\n\", type);\n\t\treturn -1;\n\t}\n\n\tath_dbg(common, QUEUE, \"Setup TX queue: %u\\n\", q);\n\n\tqi = &ah->txq[q];\n\tif (qi->tqi_type != ATH9K_TX_QUEUE_INACTIVE) {\n\t\tath_err(common, \"TX queue: %u already active\\n\", q);\n\t\treturn -1;\n\t}\n\tmemset(qi, 0, sizeof(struct ath9k_tx_queue_info));\n\tqi->tqi_type = type;\n\tqi->tqi_physCompBuf = qinfo->tqi_physCompBuf;\n\t(void) ath9k_hw_set_txq_props(ah, q, qinfo);\n\n\treturn q;\n}\nEXPORT_SYMBOL(ath9k_hw_setuptxqueue);\n\nstatic void ath9k_hw_clear_queue_interrupts(struct ath_hw *ah, u32 q)\n{\n\tah->txok_interrupt_mask &= ~(1 << q);\n\tah->txerr_interrupt_mask &= ~(1 << q);\n\tah->txdesc_interrupt_mask &= ~(1 << q);\n\tah->txeol_interrupt_mask &= ~(1 << q);\n\tah->txurn_interrupt_mask &= ~(1 << q);\n}\n\nbool ath9k_hw_releasetxqueue(struct ath_hw *ah, u32 q)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_tx_queue_info *qi;\n\n\tqi = &ah->txq[q];\n\tif (qi->tqi_type == ATH9K_TX_QUEUE_INACTIVE) {\n\t\tath_dbg(common, QUEUE, \"Release TXQ, inactive queue: %u\\n\", q);\n\t\treturn false;\n\t}\n\n\tath_dbg(common, QUEUE, \"Release TX queue: %u\\n\", q);\n\n\tqi->tqi_type = ATH9K_TX_QUEUE_INACTIVE;\n\tath9k_hw_clear_queue_interrupts(ah, q);\n\tath9k_hw_set_txq_interrupts(ah, qi);\n\n\treturn true;\n}\nEXPORT_SYMBOL(ath9k_hw_releasetxqueue);\n\nbool ath9k_hw_resettxqueue(struct ath_hw *ah, u32 q)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_tx_queue_info *qi;\n\tu32 cwMin, chanCwMin, value;\n\n\tqi = &ah->txq[q];\n\tif (qi->tqi_type == ATH9K_TX_QUEUE_INACTIVE) {\n\t\tath_dbg(common, QUEUE, \"Reset TXQ, inactive queue: %u\\n\", q);\n\t\treturn true;\n\t}\n\n\tath_dbg(common, QUEUE, \"Reset TX queue: %u\\n\", q);\n\n\tif (qi->tqi_cwmin == ATH9K_TXQ_USEDEFAULT) {\n\t\tchanCwMin = INIT_CWMIN;\n\n\t\tfor (cwMin = 1; cwMin < chanCwMin; cwMin = (cwMin << 1) | 1);\n\t} else\n\t\tcwMin = qi->tqi_cwmin;\n\n\tENABLE_REGWRITE_BUFFER(ah);\n\n\tREG_WRITE(ah, AR_DLCL_IFS(q),\n\t\t  SM(cwMin, AR_D_LCL_IFS_CWMIN) |\n\t\t  SM(qi->tqi_cwmax, AR_D_LCL_IFS_CWMAX) |\n\t\t  SM(qi->tqi_aifs, AR_D_LCL_IFS_AIFS));\n\n\tREG_WRITE(ah, AR_DRETRY_LIMIT(q),\n\t\t  SM(INIT_SSH_RETRY, AR_D_RETRY_LIMIT_STA_SH) |\n\t\t  SM(INIT_SLG_RETRY, AR_D_RETRY_LIMIT_STA_LG) |\n\t\t  SM(qi->tqi_shretry, AR_D_RETRY_LIMIT_FR_SH));\n\n\tREG_WRITE(ah, AR_QMISC(q), AR_Q_MISC_DCU_EARLY_TERM_REQ);\n\n\tif (AR_SREV_9340(ah) && !AR_SREV_9340_13_OR_LATER(ah))\n\t\tREG_WRITE(ah, AR_DMISC(q),\n\t\t\t  AR_D_MISC_CW_BKOFF_EN | AR_D_MISC_FRAG_WAIT_EN | 0x1);\n\telse\n\t\tREG_WRITE(ah, AR_DMISC(q),\n\t\t\t  AR_D_MISC_CW_BKOFF_EN | AR_D_MISC_FRAG_WAIT_EN | 0x2);\n\n\tif (qi->tqi_cbrPeriod) {\n\t\tREG_WRITE(ah, AR_QCBRCFG(q),\n\t\t\t  SM(qi->tqi_cbrPeriod, AR_Q_CBRCFG_INTERVAL) |\n\t\t\t  SM(qi->tqi_cbrOverflowLimit, AR_Q_CBRCFG_OVF_THRESH));\n\t\tREG_SET_BIT(ah, AR_QMISC(q), AR_Q_MISC_FSP_CBR |\n\t\t\t    (qi->tqi_cbrOverflowLimit ?\n\t\t\t     AR_Q_MISC_CBR_EXP_CNTR_LIMIT_EN : 0));\n\t}\n\tif (qi->tqi_readyTime && (qi->tqi_type != ATH9K_TX_QUEUE_CAB)) {\n\t\tREG_WRITE(ah, AR_QRDYTIMECFG(q),\n\t\t\t  SM(qi->tqi_readyTime, AR_Q_RDYTIMECFG_DURATION) |\n\t\t\t  AR_Q_RDYTIMECFG_EN);\n\t}\n\n\tREG_WRITE(ah, AR_DCHNTIME(q),\n\t\t  SM(qi->tqi_burstTime, AR_D_CHNTIME_DUR) |\n\t\t  (qi->tqi_burstTime ? AR_D_CHNTIME_EN : 0));\n\n\tif (qi->tqi_burstTime\n\t    && (qi->tqi_qflags & TXQ_FLAG_RDYTIME_EXP_POLICY_ENABLE))\n\t\tREG_SET_BIT(ah, AR_QMISC(q), AR_Q_MISC_RDYTIME_EXP_POLICY);\n\n\tif (qi->tqi_qflags & TXQ_FLAG_BACKOFF_DISABLE)\n\t\tREG_SET_BIT(ah, AR_DMISC(q), AR_D_MISC_POST_FR_BKOFF_DIS);\n\n\tREGWRITE_BUFFER_FLUSH(ah);\n\n\tif (qi->tqi_qflags & TXQ_FLAG_FRAG_BURST_BACKOFF_ENABLE)\n\t\tREG_SET_BIT(ah, AR_DMISC(q), AR_D_MISC_FRAG_BKOFF_EN);\n\n\tswitch (qi->tqi_type) {\n\tcase ATH9K_TX_QUEUE_BEACON:\n\t\tENABLE_REGWRITE_BUFFER(ah);\n\n\t\tREG_SET_BIT(ah, AR_QMISC(q),\n\t\t\t    AR_Q_MISC_FSP_DBA_GATED\n\t\t\t    | AR_Q_MISC_BEACON_USE\n\t\t\t    | AR_Q_MISC_CBR_INCR_DIS1);\n\n\t\tREG_SET_BIT(ah, AR_DMISC(q),\n\t\t\t    (AR_D_MISC_ARB_LOCKOUT_CNTRL_GLOBAL <<\n\t\t\t     AR_D_MISC_ARB_LOCKOUT_CNTRL_S)\n\t\t\t    | AR_D_MISC_BEACON_USE\n\t\t\t    | AR_D_MISC_POST_FR_BKOFF_DIS);\n\n\t\tREGWRITE_BUFFER_FLUSH(ah);\n\n\t\t \n\t\tif (AR_SREV_9300_20_OR_LATER(ah) &&\n\t\t    ah->opmode != NL80211_IFTYPE_ADHOC) {\n\t\t\tREG_WRITE(ah, AR_DLCL_IFS(q), SM(0, AR_D_LCL_IFS_CWMIN)\n\t\t\t\t  | SM(0, AR_D_LCL_IFS_CWMAX)\n\t\t\t\t  | SM(qi->tqi_aifs, AR_D_LCL_IFS_AIFS));\n\t\t}\n\t\tbreak;\n\tcase ATH9K_TX_QUEUE_CAB:\n\t\tENABLE_REGWRITE_BUFFER(ah);\n\n\t\tREG_SET_BIT(ah, AR_QMISC(q),\n\t\t\t    AR_Q_MISC_FSP_DBA_GATED\n\t\t\t    | AR_Q_MISC_CBR_INCR_DIS1\n\t\t\t    | AR_Q_MISC_CBR_INCR_DIS0);\n\t\tvalue = (qi->tqi_readyTime -\n\t\t\t (ah->config.sw_beacon_response_time -\n\t\t\t  ah->config.dma_beacon_response_time)) * 1024;\n\t\tREG_WRITE(ah, AR_QRDYTIMECFG(q),\n\t\t\t  value | AR_Q_RDYTIMECFG_EN);\n\t\tREG_SET_BIT(ah, AR_DMISC(q),\n\t\t\t    (AR_D_MISC_ARB_LOCKOUT_CNTRL_GLOBAL <<\n\t\t\t     AR_D_MISC_ARB_LOCKOUT_CNTRL_S));\n\n\t\tREGWRITE_BUFFER_FLUSH(ah);\n\n\t\tbreak;\n\tcase ATH9K_TX_QUEUE_PSPOLL:\n\t\tREG_SET_BIT(ah, AR_QMISC(q), AR_Q_MISC_CBR_INCR_DIS1);\n\t\tbreak;\n\tcase ATH9K_TX_QUEUE_UAPSD:\n\t\tREG_SET_BIT(ah, AR_DMISC(q), AR_D_MISC_POST_FR_BKOFF_DIS);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (qi->tqi_intFlags & ATH9K_TXQ_USE_LOCKOUT_BKOFF_DIS) {\n\t\tREG_SET_BIT(ah, AR_DMISC(q),\n\t\t\t    SM(AR_D_MISC_ARB_LOCKOUT_CNTRL_GLOBAL,\n\t\t\t       AR_D_MISC_ARB_LOCKOUT_CNTRL) |\n\t\t\t    AR_D_MISC_POST_FR_BKOFF_DIS);\n\t}\n\n\tif (AR_SREV_9300_20_OR_LATER(ah))\n\t\tREG_WRITE(ah, AR_Q_DESC_CRCCHK, AR_Q_DESC_CRCCHK_EN);\n\n\tath9k_hw_clear_queue_interrupts(ah, q);\n\tif (qi->tqi_qflags & TXQ_FLAG_TXINT_ENABLE) {\n\t\tah->txok_interrupt_mask |= 1 << q;\n\t\tah->txerr_interrupt_mask |= 1 << q;\n\t}\n\tif (qi->tqi_qflags & TXQ_FLAG_TXDESCINT_ENABLE)\n\t\tah->txdesc_interrupt_mask |= 1 << q;\n\tif (qi->tqi_qflags & TXQ_FLAG_TXEOLINT_ENABLE)\n\t\tah->txeol_interrupt_mask |= 1 << q;\n\tif (qi->tqi_qflags & TXQ_FLAG_TXURNINT_ENABLE)\n\t\tah->txurn_interrupt_mask |= 1 << q;\n\tath9k_hw_set_txq_interrupts(ah, qi);\n\n\treturn true;\n}\nEXPORT_SYMBOL(ath9k_hw_resettxqueue);\n\nint ath9k_hw_rxprocdesc(struct ath_hw *ah, struct ath_desc *ds,\n\t\t\tstruct ath_rx_status *rs)\n{\n\tstruct ar5416_desc ads;\n\tstruct ar5416_desc *adsp = AR5416DESC(ds);\n\tu32 phyerr;\n\n\tif ((adsp->ds_rxstatus8 & AR_RxDone) == 0)\n\t\treturn -EINPROGRESS;\n\n\tads.u.rx = adsp->u.rx;\n\n\trs->rs_status = 0;\n\trs->rs_flags = 0;\n\trs->enc_flags = 0;\n\trs->bw = RATE_INFO_BW_20;\n\n\trs->rs_datalen = ads.ds_rxstatus1 & AR_DataLen;\n\trs->rs_tstamp = ads.AR_RcvTimestamp;\n\n\tif (ads.ds_rxstatus8 & AR_PostDelimCRCErr) {\n\t\trs->rs_rssi = ATH9K_RSSI_BAD;\n\t\trs->rs_rssi_ctl[0] = ATH9K_RSSI_BAD;\n\t\trs->rs_rssi_ctl[1] = ATH9K_RSSI_BAD;\n\t\trs->rs_rssi_ctl[2] = ATH9K_RSSI_BAD;\n\t\trs->rs_rssi_ext[0] = ATH9K_RSSI_BAD;\n\t\trs->rs_rssi_ext[1] = ATH9K_RSSI_BAD;\n\t\trs->rs_rssi_ext[2] = ATH9K_RSSI_BAD;\n\t} else {\n\t\trs->rs_rssi = MS(ads.ds_rxstatus4, AR_RxRSSICombined);\n\t\trs->rs_rssi_ctl[0] = MS(ads.ds_rxstatus0,\n\t\t\t\t\t\tAR_RxRSSIAnt00);\n\t\trs->rs_rssi_ctl[1] = MS(ads.ds_rxstatus0,\n\t\t\t\t\t\tAR_RxRSSIAnt01);\n\t\trs->rs_rssi_ctl[2] = MS(ads.ds_rxstatus0,\n\t\t\t\t\t\tAR_RxRSSIAnt02);\n\t\trs->rs_rssi_ext[0] = MS(ads.ds_rxstatus4,\n\t\t\t\t\t\tAR_RxRSSIAnt10);\n\t\trs->rs_rssi_ext[1] = MS(ads.ds_rxstatus4,\n\t\t\t\t\t\tAR_RxRSSIAnt11);\n\t\trs->rs_rssi_ext[2] = MS(ads.ds_rxstatus4,\n\t\t\t\t\t\tAR_RxRSSIAnt12);\n\t}\n\tif (ads.ds_rxstatus8 & AR_RxKeyIdxValid)\n\t\trs->rs_keyix = MS(ads.ds_rxstatus8, AR_KeyIdx);\n\telse\n\t\trs->rs_keyix = ATH9K_RXKEYIX_INVALID;\n\n\trs->rs_rate = MS(ads.ds_rxstatus0, AR_RxRate);\n\trs->rs_more = (ads.ds_rxstatus1 & AR_RxMore) ? 1 : 0;\n\n\trs->rs_firstaggr = (ads.ds_rxstatus8 & AR_RxFirstAggr) ? 1 : 0;\n\trs->rs_isaggr = (ads.ds_rxstatus8 & AR_RxAggr) ? 1 : 0;\n\trs->rs_moreaggr = (ads.ds_rxstatus8 & AR_RxMoreAggr) ? 1 : 0;\n\trs->rs_antenna = MS(ads.ds_rxstatus3, AR_RxAntenna);\n\n\t \n\trs->enc_flags |=\n\t\t(ads.ds_rxstatus3 & AR_GI) ? RX_ENC_FLAG_SHORT_GI : 0;\n\trs->bw = (ads.ds_rxstatus3 & AR_2040) ? RATE_INFO_BW_40 :\n\t\t\t\t\t\tRATE_INFO_BW_20;\n\tif (AR_SREV_9280_20_OR_LATER(ah))\n\t\trs->enc_flags |=\n\t\t\t(ads.ds_rxstatus3 & AR_STBC) ?\n\t\t\t\t \n\t\t\t\t(1 << RX_ENC_FLAG_STBC_SHIFT) : 0;\n\n\tif (ads.ds_rxstatus8 & AR_PreDelimCRCErr)\n\t\trs->rs_flags |= ATH9K_RX_DELIM_CRC_PRE;\n\tif (ads.ds_rxstatus8 & AR_PostDelimCRCErr)\n\t\trs->rs_flags |= ATH9K_RX_DELIM_CRC_POST;\n\tif (ads.ds_rxstatus8 & AR_DecryptBusyErr)\n\t\trs->rs_flags |= ATH9K_RX_DECRYPT_BUSY;\n\n\tif ((ads.ds_rxstatus8 & AR_RxFrameOK) == 0) {\n\t\t \n\t\tif (ads.ds_rxstatus8 & AR_PHYErr) {\n\t\t\trs->rs_status |= ATH9K_RXERR_PHY;\n\t\t\tphyerr = MS(ads.ds_rxstatus8, AR_PHYErrCode);\n\t\t\trs->rs_phyerr = phyerr;\n\t\t} else if (ads.ds_rxstatus8 & AR_CRCErr)\n\t\t\trs->rs_status |= ATH9K_RXERR_CRC;\n\t\telse if (ads.ds_rxstatus8 & AR_DecryptCRCErr)\n\t\t\trs->rs_status |= ATH9K_RXERR_DECRYPT;\n\t\telse if (ads.ds_rxstatus8 & AR_MichaelErr)\n\t\t\trs->rs_status |= ATH9K_RXERR_MIC;\n\t} else {\n\t\tif (ads.ds_rxstatus8 &\n\t\t    (AR_CRCErr | AR_PHYErr | AR_DecryptCRCErr | AR_MichaelErr))\n\t\t\trs->rs_status |= ATH9K_RXERR_CORRUPT_DESC;\n\n\t\t \n\t\tif (rs->rs_rate >= 0x90)\n\t\t\trs->rs_status |= ATH9K_RXERR_CORRUPT_DESC;\n\t}\n\n\tif (ads.ds_rxstatus8 & AR_KeyMiss)\n\t\trs->rs_status |= ATH9K_RXERR_KEYMISS;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ath9k_hw_rxprocdesc);\n\n \nbool ath9k_hw_setrxabort(struct ath_hw *ah, bool set)\n{\n\tu32 reg;\n\n\tif (set) {\n\t\tREG_SET_BIT(ah, AR_DIAG_SW,\n\t\t\t    (AR_DIAG_RX_DIS | AR_DIAG_RX_ABORT));\n\n\t\tif (!ath9k_hw_wait(ah, AR_OBS_BUS_1, AR_OBS_BUS_1_RX_STATE,\n\t\t\t\t   0, AH_WAIT_TIMEOUT)) {\n\t\t\tREG_CLR_BIT(ah, AR_DIAG_SW,\n\t\t\t\t    (AR_DIAG_RX_DIS |\n\t\t\t\t     AR_DIAG_RX_ABORT));\n\n\t\t\treg = REG_READ(ah, AR_OBS_BUS_1);\n\t\t\tath_err(ath9k_hw_common(ah),\n\t\t\t\t\"RX failed to go idle in 10 ms RXSM=0x%x\\n\",\n\t\t\t\treg);\n\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tREG_CLR_BIT(ah, AR_DIAG_SW,\n\t\t\t    (AR_DIAG_RX_DIS | AR_DIAG_RX_ABORT));\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(ath9k_hw_setrxabort);\n\nvoid ath9k_hw_putrxbuf(struct ath_hw *ah, u32 rxdp)\n{\n\tREG_WRITE(ah, AR_RXDP, rxdp);\n}\nEXPORT_SYMBOL(ath9k_hw_putrxbuf);\n\nvoid ath9k_hw_startpcureceive(struct ath_hw *ah, bool is_scanning)\n{\n\tath9k_enable_mib_counters(ah);\n\n\tath9k_ani_reset(ah, is_scanning);\n\n\tREG_CLR_BIT(ah, AR_DIAG_SW, (AR_DIAG_RX_DIS | AR_DIAG_RX_ABORT));\n}\nEXPORT_SYMBOL(ath9k_hw_startpcureceive);\n\nvoid ath9k_hw_abortpcurecv(struct ath_hw *ah)\n{\n\tREG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_ABORT | AR_DIAG_RX_DIS);\n\n\tath9k_hw_disable_mib_counters(ah);\n}\nEXPORT_SYMBOL(ath9k_hw_abortpcurecv);\n\nbool ath9k_hw_stopdmarecv(struct ath_hw *ah, bool *reset)\n{\n#define AH_RX_STOP_DMA_TIMEOUT 10000    \n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tu32 mac_status, last_mac_status = 0;\n\tint i;\n\n\t \n\tREG_WRITE(ah, AR_MACMISC,\n\t\t  ((AR_MACMISC_DMA_OBS_LINE_8 << AR_MACMISC_DMA_OBS_S) |\n\t\t   (AR_MACMISC_MISC_OBS_BUS_1 <<\n\t\t    AR_MACMISC_MISC_OBS_BUS_MSB_S)));\n\n\tREG_WRITE(ah, AR_CR, AR_CR_RXD);\n\n\t \n\tfor (i = AH_RX_STOP_DMA_TIMEOUT / AH_TIME_QUANTUM; i != 0; i--) {\n\t\tif ((REG_READ(ah, AR_CR) & AR_CR_RXE(ah)) == 0)\n\t\t\tbreak;\n\n\t\tif (!AR_SREV_9300_20_OR_LATER(ah)) {\n\t\t\tmac_status = REG_READ(ah, AR_DMADBG_7) & 0x7f0;\n\t\t\tif (mac_status == 0x1c0 && mac_status == last_mac_status) {\n\t\t\t\t*reset = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlast_mac_status = mac_status;\n\t\t}\n\n\t\tudelay(AH_TIME_QUANTUM);\n\t}\n\n\tif (i == 0) {\n\t\tath_err(common,\n\t\t\t\"DMA failed to stop in %d ms AR_CR=0x%08x AR_DIAG_SW=0x%08x DMADBG_7=0x%08x\\n\",\n\t\t\tAH_RX_STOP_DMA_TIMEOUT / 1000,\n\t\t\tREG_READ(ah, AR_CR),\n\t\t\tREG_READ(ah, AR_DIAG_SW),\n\t\t\tREG_READ(ah, AR_DMADBG_7));\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n\n#undef AH_RX_STOP_DMA_TIMEOUT\n}\nEXPORT_SYMBOL(ath9k_hw_stopdmarecv);\n\nint ath9k_hw_beaconq_setup(struct ath_hw *ah)\n{\n\tstruct ath9k_tx_queue_info qi;\n\n\tmemset(&qi, 0, sizeof(qi));\n\tqi.tqi_aifs = 1;\n\tqi.tqi_cwmin = 0;\n\tqi.tqi_cwmax = 0;\n\n\tif (ah->caps.hw_caps & ATH9K_HW_CAP_EDMA)\n\t\tqi.tqi_qflags = TXQ_FLAG_TXINT_ENABLE;\n\n\treturn ath9k_hw_setuptxqueue(ah, ATH9K_TX_QUEUE_BEACON, &qi);\n}\nEXPORT_SYMBOL(ath9k_hw_beaconq_setup);\n\nbool ath9k_hw_intrpend(struct ath_hw *ah)\n{\n\tu32 host_isr;\n\n\tif (AR_SREV_9100(ah))\n\t\treturn true;\n\n\thost_isr = REG_READ(ah, AR_INTR_ASYNC_CAUSE(ah));\n\n\tif (((host_isr & AR_INTR_MAC_IRQ) ||\n\t     (host_isr & AR_INTR_ASYNC_MASK_MCI)) &&\n\t    (host_isr != AR_INTR_SPURIOUS))\n\t\treturn true;\n\n\thost_isr = REG_READ(ah, AR_INTR_SYNC_CAUSE(ah));\n\tif ((host_isr & AR_INTR_SYNC_DEFAULT)\n\t    && (host_isr != AR_INTR_SPURIOUS))\n\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL(ath9k_hw_intrpend);\n\nvoid ath9k_hw_kill_interrupts(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tath_dbg(common, INTERRUPT, \"disable IER\\n\");\n\tREG_WRITE(ah, AR_IER, AR_IER_DISABLE);\n\t(void) REG_READ(ah, AR_IER);\n\tif (!AR_SREV_9100(ah)) {\n\t\tREG_WRITE(ah, AR_INTR_ASYNC_ENABLE(ah), 0);\n\t\t(void) REG_READ(ah, AR_INTR_ASYNC_ENABLE(ah));\n\n\t\tREG_WRITE(ah, AR_INTR_SYNC_ENABLE(ah), 0);\n\t\t(void) REG_READ(ah, AR_INTR_SYNC_ENABLE(ah));\n\t}\n}\nEXPORT_SYMBOL(ath9k_hw_kill_interrupts);\n\nvoid ath9k_hw_disable_interrupts(struct ath_hw *ah)\n{\n\tif (!(ah->imask & ATH9K_INT_GLOBAL))\n\t\tatomic_set(&ah->intr_ref_cnt, -1);\n\telse\n\t\tatomic_dec(&ah->intr_ref_cnt);\n\n\tath9k_hw_kill_interrupts(ah);\n}\nEXPORT_SYMBOL(ath9k_hw_disable_interrupts);\n\nstatic void __ath9k_hw_enable_interrupts(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tu32 sync_default = AR_INTR_SYNC_DEFAULT;\n\tu32 async_mask;\n\n\tif (AR_SREV_9340(ah) || AR_SREV_9550(ah) || AR_SREV_9531(ah) ||\n\t    AR_SREV_9561(ah))\n\t\tsync_default &= ~AR_INTR_SYNC_HOST1_FATAL;\n\n\tasync_mask = AR_INTR_MAC_IRQ;\n\n\tif (ah->imask & ATH9K_INT_MCI)\n\t\tasync_mask |= AR_INTR_ASYNC_MASK_MCI;\n\n\tath_dbg(common, INTERRUPT, \"enable IER\\n\");\n\tREG_WRITE(ah, AR_IER, AR_IER_ENABLE);\n\tif (!AR_SREV_9100(ah)) {\n\t\tREG_WRITE(ah, AR_INTR_ASYNC_ENABLE(ah), async_mask);\n\t\tREG_WRITE(ah, AR_INTR_ASYNC_MASK(ah), async_mask);\n\n\t\tREG_WRITE(ah, AR_INTR_SYNC_ENABLE(ah), sync_default);\n\t\tREG_WRITE(ah, AR_INTR_SYNC_MASK(ah), sync_default);\n\t}\n\tath_dbg(common, INTERRUPT, \"AR_IMR 0x%x IER 0x%x\\n\",\n\t\tREG_READ(ah, AR_IMR), REG_READ(ah, AR_IER));\n\n\tif (ah->msi_enabled) {\n\t\tu32 _msi_reg = 0;\n\t\tu32 i = 0;\n\t\tu32 msi_pend_addr_mask = AR_PCIE_MSI_HW_INT_PENDING_ADDR_MSI_64;\n\n\t\tath_dbg(ath9k_hw_common(ah), INTERRUPT,\n\t\t\t\"Enabling MSI, msi_mask=0x%X\\n\", ah->msi_mask);\n\n\t\tREG_WRITE(ah, AR_INTR_PRIO_ASYNC_ENABLE(ah), ah->msi_mask);\n\t\tREG_WRITE(ah, AR_INTR_PRIO_ASYNC_MASK(ah), ah->msi_mask);\n\t\tath_dbg(ath9k_hw_common(ah), INTERRUPT,\n\t\t\t\"AR_INTR_PRIO_ASYNC_ENABLE=0x%X, AR_INTR_PRIO_ASYNC_MASK=0x%X\\n\",\n\t\t\tREG_READ(ah, AR_INTR_PRIO_ASYNC_ENABLE(ah)),\n\t\t\tREG_READ(ah, AR_INTR_PRIO_ASYNC_MASK(ah)));\n\n\t\tif (ah->msi_reg == 0)\n\t\t\tah->msi_reg = REG_READ(ah, AR_PCIE_MSI(ah));\n\n\t\tath_dbg(ath9k_hw_common(ah), INTERRUPT,\n\t\t\t\"AR_PCIE_MSI=0x%X, ah->msi_reg = 0x%X\\n\",\n\t\t\tAR_PCIE_MSI(ah), ah->msi_reg);\n\n\t\ti = 0;\n\t\tdo {\n\t\t\tREG_WRITE(ah, AR_PCIE_MSI(ah),\n\t\t\t\t  (ah->msi_reg | AR_PCIE_MSI_ENABLE)\n\t\t\t\t  & msi_pend_addr_mask);\n\t\t\t_msi_reg = REG_READ(ah, AR_PCIE_MSI(ah));\n\t\t\ti++;\n\t\t} while ((_msi_reg & AR_PCIE_MSI_ENABLE) == 0 && i < 200);\n\n\t\tif (i >= 200)\n\t\t\tath_err(ath9k_hw_common(ah),\n\t\t\t\t\"%s: _msi_reg = 0x%X\\n\",\n\t\t\t\t__func__, _msi_reg);\n\t}\n}\n\nvoid ath9k_hw_resume_interrupts(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tif (!(ah->imask & ATH9K_INT_GLOBAL))\n\t\treturn;\n\n\tif (atomic_read(&ah->intr_ref_cnt) != 0) {\n\t\tath_dbg(common, INTERRUPT, \"Do not enable IER ref count %d\\n\",\n\t\t\tatomic_read(&ah->intr_ref_cnt));\n\t\treturn;\n\t}\n\n\t__ath9k_hw_enable_interrupts(ah);\n}\nEXPORT_SYMBOL(ath9k_hw_resume_interrupts);\n\nvoid ath9k_hw_enable_interrupts(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tif (!(ah->imask & ATH9K_INT_GLOBAL))\n\t\treturn;\n\n\tif (!atomic_inc_and_test(&ah->intr_ref_cnt)) {\n\t\tath_dbg(common, INTERRUPT, \"Do not enable IER ref count %d\\n\",\n\t\t\tatomic_read(&ah->intr_ref_cnt));\n\t\treturn;\n\t}\n\n\t__ath9k_hw_enable_interrupts(ah);\n}\nEXPORT_SYMBOL(ath9k_hw_enable_interrupts);\n\nvoid ath9k_hw_set_interrupts(struct ath_hw *ah)\n{\n\tenum ath9k_int ints = ah->imask;\n\tu32 mask, mask2;\n\tstruct ath9k_hw_capabilities *pCap = &ah->caps;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tif (!(ints & ATH9K_INT_GLOBAL))\n\t\tath9k_hw_disable_interrupts(ah);\n\n\tif (ah->msi_enabled) {\n\t\tath_dbg(common, INTERRUPT, \"Clearing AR_INTR_PRIO_ASYNC_ENABLE\\n\");\n\n\t\tREG_WRITE(ah, AR_INTR_PRIO_ASYNC_ENABLE(ah), 0);\n\t\tREG_READ(ah, AR_INTR_PRIO_ASYNC_ENABLE(ah));\n\t}\n\n\tath_dbg(common, INTERRUPT, \"New interrupt mask 0x%x\\n\", ints);\n\n\tmask = ints & ATH9K_INT_COMMON;\n\tmask2 = 0;\n\n\tah->msi_mask = 0;\n\tif (ints & ATH9K_INT_TX) {\n\t\tah->msi_mask |= AR_INTR_PRIO_TX;\n\t\tif (ah->config.tx_intr_mitigation)\n\t\t\tmask |= AR_IMR_TXMINTR | AR_IMR_TXINTM;\n\t\telse {\n\t\t\tif (ah->txok_interrupt_mask)\n\t\t\t\tmask |= AR_IMR_TXOK;\n\t\t\tif (ah->txdesc_interrupt_mask)\n\t\t\t\tmask |= AR_IMR_TXDESC;\n\t\t}\n\t\tif (ah->txerr_interrupt_mask)\n\t\t\tmask |= AR_IMR_TXERR;\n\t\tif (ah->txeol_interrupt_mask)\n\t\t\tmask |= AR_IMR_TXEOL;\n\t}\n\tif (ints & ATH9K_INT_RX) {\n\t\tah->msi_mask |= AR_INTR_PRIO_RXLP | AR_INTR_PRIO_RXHP;\n\t\tif (AR_SREV_9300_20_OR_LATER(ah)) {\n\t\t\tmask |= AR_IMR_RXERR | AR_IMR_RXOK_HP;\n\t\t\tif (ah->config.rx_intr_mitigation) {\n\t\t\t\tmask &= ~AR_IMR_RXOK_LP;\n\t\t\t\tmask |=  AR_IMR_RXMINTR | AR_IMR_RXINTM;\n\t\t\t} else {\n\t\t\t\tmask |= AR_IMR_RXOK_LP;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ah->config.rx_intr_mitigation)\n\t\t\t\tmask |= AR_IMR_RXMINTR | AR_IMR_RXINTM;\n\t\t\telse\n\t\t\t\tmask |= AR_IMR_RXOK | AR_IMR_RXDESC;\n\t\t}\n\t\tif (!(pCap->hw_caps & ATH9K_HW_CAP_AUTOSLEEP))\n\t\t\tmask |= AR_IMR_GENTMR;\n\t}\n\n\tif (ints & ATH9K_INT_GENTIMER)\n\t\tmask |= AR_IMR_GENTMR;\n\n\tif (ints & (ATH9K_INT_BMISC)) {\n\t\tmask |= AR_IMR_BCNMISC;\n\t\tif (ints & ATH9K_INT_TIM)\n\t\t\tmask2 |= AR_IMR_S2_TIM;\n\t\tif (ints & ATH9K_INT_DTIM)\n\t\t\tmask2 |= AR_IMR_S2_DTIM;\n\t\tif (ints & ATH9K_INT_DTIMSYNC)\n\t\t\tmask2 |= AR_IMR_S2_DTIMSYNC;\n\t\tif (ints & ATH9K_INT_CABEND)\n\t\t\tmask2 |= AR_IMR_S2_CABEND;\n\t\tif (ints & ATH9K_INT_TSFOOR)\n\t\t\tmask2 |= AR_IMR_S2_TSFOOR;\n\t}\n\n\tif (ints & (ATH9K_INT_GTT | ATH9K_INT_CST)) {\n\t\tmask |= AR_IMR_BCNMISC;\n\t\tif (ints & ATH9K_INT_GTT)\n\t\t\tmask2 |= AR_IMR_S2_GTT;\n\t\tif (ints & ATH9K_INT_CST)\n\t\t\tmask2 |= AR_IMR_S2_CST;\n\t}\n\n\tif (ah->config.hw_hang_checks & HW_BB_WATCHDOG) {\n\t\tif (ints & ATH9K_INT_BB_WATCHDOG) {\n\t\t\tmask |= AR_IMR_BCNMISC;\n\t\t\tmask2 |= AR_IMR_S2_BB_WATCHDOG;\n\t\t}\n\t}\n\n\tath_dbg(common, INTERRUPT, \"new IMR 0x%x\\n\", mask);\n\tREG_WRITE(ah, AR_IMR, mask);\n\tah->imrs2_reg &= ~(AR_IMR_S2_TIM |\n\t\t\t   AR_IMR_S2_DTIM |\n\t\t\t   AR_IMR_S2_DTIMSYNC |\n\t\t\t   AR_IMR_S2_CABEND |\n\t\t\t   AR_IMR_S2_CABTO |\n\t\t\t   AR_IMR_S2_TSFOOR |\n\t\t\t   AR_IMR_S2_GTT |\n\t\t\t   AR_IMR_S2_CST);\n\n\tif (ah->config.hw_hang_checks & HW_BB_WATCHDOG) {\n\t\tif (ints & ATH9K_INT_BB_WATCHDOG)\n\t\t\tah->imrs2_reg &= ~AR_IMR_S2_BB_WATCHDOG;\n\t}\n\n\tah->imrs2_reg |= mask2;\n\tREG_WRITE(ah, AR_IMR_S2, ah->imrs2_reg);\n\n\tif (!(pCap->hw_caps & ATH9K_HW_CAP_AUTOSLEEP)) {\n\t\tif (ints & ATH9K_INT_TIM_TIMER)\n\t\t\tREG_SET_BIT(ah, AR_IMR_S5, AR_IMR_S5_TIM_TIMER);\n\t\telse\n\t\t\tREG_CLR_BIT(ah, AR_IMR_S5, AR_IMR_S5_TIM_TIMER);\n\t}\n\n\treturn;\n}\nEXPORT_SYMBOL(ath9k_hw_set_interrupts);\n\n#define ATH9K_HW_MAX_DCU       10\n#define ATH9K_HW_SLICE_PER_DCU 16\n#define ATH9K_HW_BIT_IN_SLICE  16\nvoid ath9k_hw_set_tx_filter(struct ath_hw *ah, u8 destidx, bool set)\n{\n\tint dcu_idx;\n\tu32 filter;\n\n\tfor (dcu_idx = 0; dcu_idx < 10; dcu_idx++) {\n\t\tfilter = SM(set, AR_D_TXBLK_WRITE_COMMAND);\n\t\tfilter |= SM(dcu_idx, AR_D_TXBLK_WRITE_DCU);\n\t\tfilter |= SM((destidx / ATH9K_HW_SLICE_PER_DCU),\n\t\t\t     AR_D_TXBLK_WRITE_SLICE);\n\t\tfilter |= BIT(destidx % ATH9K_HW_BIT_IN_SLICE);\n\t\tath_dbg(ath9k_hw_common(ah), PS,\n\t\t\t\"DCU%d staid %d set %d txfilter %08x\\n\",\n\t\t\tdcu_idx, destidx, set, filter);\n\t\tREG_WRITE(ah, AR_D_TXBLK_BASE, filter);\n\t}\n}\nEXPORT_SYMBOL(ath9k_hw_set_tx_filter);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}