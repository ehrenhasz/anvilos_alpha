{
  "module_name": "xmit.c",
  "hash_id": "2048aca00b5720c9dcb2f6cf34df23cd26e51bbe05f9c475dfcf45fccd5be054",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/xmit.c",
  "human_readable_source": " \n\n#include <linux/dma-mapping.h>\n#include \"ath9k.h\"\n#include \"ar9003_mac.h\"\n\n#define BITS_PER_BYTE           8\n#define OFDM_PLCP_BITS          22\n#define HT_RC_2_STREAMS(_rc)    ((((_rc) & 0x78) >> 3) + 1)\n#define L_STF                   8\n#define L_LTF                   8\n#define L_SIG                   4\n#define HT_SIG                  8\n#define HT_STF                  4\n#define HT_LTF(_ns)             (4 * (_ns))\n#define SYMBOL_TIME(_ns)        ((_ns) << 2)  \n#define SYMBOL_TIME_HALFGI(_ns) (((_ns) * 18 + 4) / 5)   \n#define TIME_SYMBOLS(t)         ((t) >> 2)\n#define TIME_SYMBOLS_HALFGI(t)  (((t) * 5 - 4) / 18)\n#define NUM_SYMBOLS_PER_USEC(_usec) (_usec >> 2)\n#define NUM_SYMBOLS_PER_USEC_HALFGI(_usec) (((_usec*5)-4)/18)\n\n \n#define ATH9K_PWRTBL_11NA_OFDM_SHIFT    0\n#define ATH9K_PWRTBL_11NG_OFDM_SHIFT    4\n#define ATH9K_PWRTBL_11NA_HT_SHIFT      8\n#define ATH9K_PWRTBL_11NG_HT_SHIFT      12\n\n\nstatic u16 bits_per_symbol[][2] = {\n\t \n\t{    26,   54 },      \n\t{    52,  108 },      \n\t{    78,  162 },      \n\t{   104,  216 },      \n\t{   156,  324 },      \n\t{   208,  432 },      \n\t{   234,  486 },      \n\t{   260,  540 },      \n};\n\nstatic void ath_tx_send_normal(struct ath_softc *sc, struct ath_txq *txq,\n\t\t\t       struct ath_atx_tid *tid, struct sk_buff *skb);\nstatic void ath_tx_complete(struct ath_softc *sc, struct sk_buff *skb,\n\t\t\t    int tx_flags, struct ath_txq *txq,\n\t\t\t    struct ieee80211_sta *sta);\nstatic void ath_tx_complete_buf(struct ath_softc *sc, struct ath_buf *bf,\n\t\t\t\tstruct ath_txq *txq, struct list_head *bf_q,\n\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\tstruct ath_tx_status *ts, int txok);\nstatic void ath_tx_txqaddbuf(struct ath_softc *sc, struct ath_txq *txq,\n\t\t\t     struct list_head *head, bool internal);\nstatic void ath_tx_rc_status(struct ath_softc *sc, struct ath_buf *bf,\n\t\t\t     struct ath_tx_status *ts, int nframes, int nbad,\n\t\t\t     int txok);\nstatic void ath_tx_update_baw(struct ath_softc *sc, struct ath_atx_tid *tid,\n\t\t\t      struct ath_buf *bf);\nstatic struct ath_buf *ath_tx_setup_buffer(struct ath_softc *sc,\n\t\t\t\t\t   struct ath_txq *txq,\n\t\t\t\t\t   struct ath_atx_tid *tid,\n\t\t\t\t\t   struct sk_buff *skb);\nstatic int ath_tx_prepare(struct ieee80211_hw *hw, struct sk_buff *skb,\n\t\t\t  struct ath_tx_control *txctl);\n\nenum {\n\tMCS_HT20,\n\tMCS_HT20_SGI,\n\tMCS_HT40,\n\tMCS_HT40_SGI,\n};\n\n \n \n \n\nstatic void ath_tx_status(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_sta *sta = info->status.status_driver_data[0];\n\n\tif (info->flags & (IEEE80211_TX_CTL_REQ_TX_STATUS |\n\t\t\t   IEEE80211_TX_STATUS_EOSP)) {\n\t\tieee80211_tx_status(hw, skb);\n\t\treturn;\n\t}\n\n\tif (sta)\n\t\tieee80211_tx_status_noskb(hw, sta, info);\n\n\tdev_kfree_skb(skb);\n}\n\nvoid ath_txq_unlock_complete(struct ath_softc *sc, struct ath_txq *txq)\n\t__releases(&txq->axq_lock)\n{\n\tstruct ieee80211_hw *hw = sc->hw;\n\tstruct sk_buff_head q;\n\tstruct sk_buff *skb;\n\n\t__skb_queue_head_init(&q);\n\tskb_queue_splice_init(&txq->complete_q, &q);\n\tspin_unlock_bh(&txq->axq_lock);\n\n\twhile ((skb = __skb_dequeue(&q)))\n\t\tath_tx_status(hw, skb);\n}\n\nvoid ath_tx_queue_tid(struct ath_softc *sc, struct ath_atx_tid *tid)\n{\n\tstruct ieee80211_txq *queue =\n\t\tcontainer_of((void *)tid, struct ieee80211_txq, drv_priv);\n\n\tieee80211_schedule_txq(sc->hw, queue);\n}\n\nvoid ath9k_wake_tx_queue(struct ieee80211_hw *hw, struct ieee80211_txq *queue)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_atx_tid *tid = (struct ath_atx_tid *) queue->drv_priv;\n\tstruct ath_txq *txq = tid->txq;\n\n\tath_dbg(common, QUEUE, \"Waking TX queue: %pM (%d)\\n\",\n\t\tqueue->sta ? queue->sta->addr : queue->vif->addr,\n\t\ttid->tidno);\n\n\tath_txq_lock(sc, txq);\n\tath_txq_schedule(sc, txq);\n\tath_txq_unlock(sc, txq);\n}\n\nstatic struct ath_frame_info *get_frame_info(struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tBUILD_BUG_ON(sizeof(struct ath_frame_info) >\n\t\t     sizeof(tx_info->status.status_driver_data));\n\treturn (struct ath_frame_info *) &tx_info->status.status_driver_data[0];\n}\n\nstatic void ath_send_bar(struct ath_atx_tid *tid, u16 seqno)\n{\n\tif (!tid->an->sta)\n\t\treturn;\n\n\tieee80211_send_bar(tid->an->vif, tid->an->sta->addr, tid->tidno,\n\t\t\t   seqno << IEEE80211_SEQ_SEQ_SHIFT);\n}\n\nstatic bool ath_merge_ratetbl(struct ieee80211_sta *sta, struct ath_buf *bf,\n\t\t\t      struct ieee80211_tx_info *tx_info)\n{\n\tstruct ieee80211_sta_rates *ratetbl;\n\tu8 i;\n\n\tif (!sta)\n\t\treturn false;\n\n\tratetbl = rcu_dereference(sta->rates);\n\tif (!ratetbl)\n\t\treturn false;\n\n\tif (tx_info->control.rates[0].idx < 0 ||\n\t    tx_info->control.rates[0].count == 0)\n\t{\n\t\ti = 0;\n\t} else {\n\t\tbf->rates[0] = tx_info->control.rates[0];\n\t\ti = 1;\n\t}\n\n\tfor ( ; i < IEEE80211_TX_MAX_RATES; i++) {\n\t\tbf->rates[i].idx = ratetbl->rate[i].idx;\n\t\tbf->rates[i].flags = ratetbl->rate[i].flags;\n\t\tif (tx_info->control.use_rts)\n\t\t\tbf->rates[i].count = ratetbl->rate[i].count_rts;\n\t\telse if (tx_info->control.use_cts_prot)\n\t\t\tbf->rates[i].count = ratetbl->rate[i].count_cts;\n\t\telse\n\t\t\tbf->rates[i].count = ratetbl->rate[i].count;\n\t}\n\n\treturn true;\n}\n\nstatic void ath_set_rates(struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t\t  struct ath_buf *bf)\n{\n\tstruct ieee80211_tx_info *tx_info;\n\n\ttx_info = IEEE80211_SKB_CB(bf->bf_mpdu);\n\n\tif (!ath_merge_ratetbl(sta, bf, tx_info))\n\t\tieee80211_get_tx_rates(vif, sta, bf->bf_mpdu, bf->rates,\n\t\t\t\t       ARRAY_SIZE(bf->rates));\n}\n\nstatic void ath_txq_skb_done(struct ath_softc *sc, struct ath_txq *txq,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct ath_frame_info *fi = get_frame_info(skb);\n\tint q = fi->txq;\n\n\tif (q < 0)\n\t\treturn;\n\n\ttxq = sc->tx.txq_map[q];\n\tif (WARN_ON(--txq->pending_frames < 0))\n\t\ttxq->pending_frames = 0;\n\n}\n\nstatic struct ath_atx_tid *\nath_get_skb_tid(struct ath_softc *sc, struct ath_node *an, struct sk_buff *skb)\n{\n\tu8 tidno = skb->priority & IEEE80211_QOS_CTL_TID_MASK;\n\treturn ATH_AN_2_TID(an, tidno);\n}\n\nstatic int\nath_tid_pull(struct ath_atx_tid *tid, struct sk_buff **skbuf)\n{\n\tstruct ieee80211_txq *txq = container_of((void*)tid, struct ieee80211_txq, drv_priv);\n\tstruct ath_softc *sc = tid->an->sc;\n\tstruct ieee80211_hw *hw = sc->hw;\n\tstruct ath_tx_control txctl = {\n\t\t.txq = tid->txq,\n\t\t.sta = tid->an->sta,\n\t};\n\tstruct sk_buff *skb;\n\tstruct ath_frame_info *fi;\n\tint q, ret;\n\n\tskb = ieee80211_tx_dequeue(hw, txq);\n\tif (!skb)\n\t\treturn -ENOENT;\n\n\tret = ath_tx_prepare(hw, skb, &txctl);\n\tif (ret) {\n\t\tieee80211_free_txskb(hw, skb);\n\t\treturn ret;\n\t}\n\n\tq = skb_get_queue_mapping(skb);\n\tif (tid->txq == sc->tx.txq_map[q]) {\n\t\tfi = get_frame_info(skb);\n\t\tfi->txq = q;\n\t\t++tid->txq->pending_frames;\n\t}\n\n\t*skbuf = skb;\n\treturn 0;\n}\n\nstatic int ath_tid_dequeue(struct ath_atx_tid *tid,\n\t\t\t   struct sk_buff **skb)\n{\n\tint ret = 0;\n\t*skb = __skb_dequeue(&tid->retry_q);\n\tif (!*skb)\n\t\tret = ath_tid_pull(tid, skb);\n\n\treturn ret;\n}\n\nstatic void ath_tx_flush_tid(struct ath_softc *sc, struct ath_atx_tid *tid)\n{\n\tstruct ath_txq *txq = tid->txq;\n\tstruct sk_buff *skb;\n\tstruct ath_buf *bf;\n\tstruct list_head bf_head;\n\tstruct ath_tx_status ts;\n\tstruct ath_frame_info *fi;\n\tbool sendbar = false;\n\n\tINIT_LIST_HEAD(&bf_head);\n\n\tmemset(&ts, 0, sizeof(ts));\n\n\twhile ((skb = __skb_dequeue(&tid->retry_q))) {\n\t\tfi = get_frame_info(skb);\n\t\tbf = fi->bf;\n\t\tif (!bf) {\n\t\t\tath_txq_skb_done(sc, txq, skb);\n\t\t\tieee80211_free_txskb(sc->hw, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fi->baw_tracked) {\n\t\t\tath_tx_update_baw(sc, tid, bf);\n\t\t\tsendbar = true;\n\t\t}\n\n\t\tlist_add_tail(&bf->list, &bf_head);\n\t\tath_tx_complete_buf(sc, bf, txq, &bf_head, NULL, &ts, 0);\n\t}\n\n\tif (sendbar) {\n\t\tath_txq_unlock(sc, txq);\n\t\tath_send_bar(tid, tid->seq_start);\n\t\tath_txq_lock(sc, txq);\n\t}\n}\n\nstatic void ath_tx_update_baw(struct ath_softc *sc, struct ath_atx_tid *tid,\n\t\t\t      struct ath_buf *bf)\n{\n\tstruct ath_frame_info *fi = get_frame_info(bf->bf_mpdu);\n\tu16 seqno = bf->bf_state.seqno;\n\tint index, cindex;\n\n\tif (!fi->baw_tracked)\n\t\treturn;\n\n\tindex  = ATH_BA_INDEX(tid->seq_start, seqno);\n\tcindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);\n\n\t__clear_bit(cindex, tid->tx_buf);\n\n\twhile (tid->baw_head != tid->baw_tail && !test_bit(tid->baw_head, tid->tx_buf)) {\n\t\tINCR(tid->seq_start, IEEE80211_SEQ_MAX);\n\t\tINCR(tid->baw_head, ATH_TID_MAX_BUFS);\n\t\tif (tid->bar_index >= 0)\n\t\t\ttid->bar_index--;\n\t}\n}\n\nstatic void ath_tx_addto_baw(struct ath_softc *sc, struct ath_atx_tid *tid,\n\t\t\t     struct ath_buf *bf)\n{\n\tstruct ath_frame_info *fi = get_frame_info(bf->bf_mpdu);\n\tu16 seqno = bf->bf_state.seqno;\n\tint index, cindex;\n\n\tif (fi->baw_tracked)\n\t\treturn;\n\n\tindex  = ATH_BA_INDEX(tid->seq_start, seqno);\n\tcindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);\n\t__set_bit(cindex, tid->tx_buf);\n\tfi->baw_tracked = 1;\n\n\tif (index >= ((tid->baw_tail - tid->baw_head) &\n\t\t(ATH_TID_MAX_BUFS - 1))) {\n\t\ttid->baw_tail = cindex;\n\t\tINCR(tid->baw_tail, ATH_TID_MAX_BUFS);\n\t}\n}\n\nstatic void ath_tid_drain(struct ath_softc *sc, struct ath_txq *txq,\n\t\t\t  struct ath_atx_tid *tid)\n\n{\n\tstruct sk_buff *skb;\n\tstruct ath_buf *bf;\n\tstruct list_head bf_head;\n\tstruct ath_tx_status ts;\n\tstruct ath_frame_info *fi;\n\tint ret;\n\n\tmemset(&ts, 0, sizeof(ts));\n\tINIT_LIST_HEAD(&bf_head);\n\n\twhile ((ret = ath_tid_dequeue(tid, &skb)) == 0) {\n\t\tfi = get_frame_info(skb);\n\t\tbf = fi->bf;\n\n\t\tif (!bf) {\n\t\t\tath_tx_complete(sc, skb, ATH_TX_ERROR, txq, NULL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_add_tail(&bf->list, &bf_head);\n\t\tath_tx_complete_buf(sc, bf, txq, &bf_head, NULL, &ts, 0);\n\t}\n}\n\nstatic void ath_tx_set_retry(struct ath_softc *sc, struct ath_txq *txq,\n\t\t\t     struct sk_buff *skb, int count)\n{\n\tstruct ath_frame_info *fi = get_frame_info(skb);\n\tstruct ath_buf *bf = fi->bf;\n\tstruct ieee80211_hdr *hdr;\n\tint prev = fi->retries;\n\n\tTX_STAT_INC(sc, txq->axq_qnum, a_retries);\n\tfi->retries += count;\n\n\tif (prev > 0)\n\t\treturn;\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\thdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_RETRY);\n\tdma_sync_single_for_device(sc->dev, bf->bf_buf_addr,\n\t\tsizeof(*hdr), DMA_TO_DEVICE);\n}\n\nstatic struct ath_buf *ath_tx_get_buffer(struct ath_softc *sc)\n{\n\tstruct ath_buf *bf = NULL;\n\n\tspin_lock_bh(&sc->tx.txbuflock);\n\n\tif (unlikely(list_empty(&sc->tx.txbuf))) {\n\t\tspin_unlock_bh(&sc->tx.txbuflock);\n\t\treturn NULL;\n\t}\n\n\tbf = list_first_entry(&sc->tx.txbuf, struct ath_buf, list);\n\tlist_del(&bf->list);\n\n\tspin_unlock_bh(&sc->tx.txbuflock);\n\n\treturn bf;\n}\n\nstatic void ath_tx_return_buffer(struct ath_softc *sc, struct ath_buf *bf)\n{\n\tspin_lock_bh(&sc->tx.txbuflock);\n\tlist_add_tail(&bf->list, &sc->tx.txbuf);\n\tspin_unlock_bh(&sc->tx.txbuflock);\n}\n\nstatic struct ath_buf* ath_clone_txbuf(struct ath_softc *sc, struct ath_buf *bf)\n{\n\tstruct ath_buf *tbf;\n\n\ttbf = ath_tx_get_buffer(sc);\n\tif (WARN_ON(!tbf))\n\t\treturn NULL;\n\n\tATH_TXBUF_RESET(tbf);\n\n\ttbf->bf_mpdu = bf->bf_mpdu;\n\ttbf->bf_buf_addr = bf->bf_buf_addr;\n\tmemcpy(tbf->bf_desc, bf->bf_desc, sc->sc_ah->caps.tx_desc_len);\n\ttbf->bf_state = bf->bf_state;\n\ttbf->bf_state.stale = false;\n\n\treturn tbf;\n}\n\nstatic void ath_tx_count_frames(struct ath_softc *sc, struct ath_buf *bf,\n\t\t\t        struct ath_tx_status *ts, int txok,\n\t\t\t        int *nframes, int *nbad)\n{\n\tu16 seq_st = 0;\n\tu32 ba[WME_BA_BMP_SIZE >> 5];\n\tint ba_index;\n\tint isaggr = 0;\n\n\t*nbad = 0;\n\t*nframes = 0;\n\n\tisaggr = bf_isaggr(bf);\n\tmemset(ba, 0, WME_BA_BMP_SIZE >> 3);\n\n\tif (isaggr) {\n\t\tseq_st = ts->ts_seqnum;\n\t\tmemcpy(ba, &ts->ba, WME_BA_BMP_SIZE >> 3);\n\t}\n\n\twhile (bf) {\n\t\tba_index = ATH_BA_INDEX(seq_st, bf->bf_state.seqno);\n\n\t\t(*nframes)++;\n\t\tif (!txok || (isaggr && !ATH_BA_ISSET(ba, ba_index)))\n\t\t\t(*nbad)++;\n\n\t\tbf = bf->bf_next;\n\t}\n}\n\n\nstatic void ath_tx_complete_aggr(struct ath_softc *sc, struct ath_txq *txq,\n\t\t\t\t struct ath_buf *bf, struct list_head *bf_q,\n\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t struct ath_atx_tid *tid,\n\t\t\t\t struct ath_tx_status *ts, int txok)\n{\n\tstruct ath_node *an = NULL;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_tx_info *tx_info;\n\tstruct ath_buf *bf_next, *bf_last = bf->bf_lastbf;\n\tstruct list_head bf_head;\n\tstruct sk_buff_head bf_pending;\n\tu16 seq_st = 0, acked_cnt = 0, txfail_cnt = 0, seq_first;\n\tu32 ba[WME_BA_BMP_SIZE >> 5];\n\tint isaggr, txfail, txpending, sendbar = 0, needreset = 0, nbad = 0;\n\tbool rc_update = true, isba;\n\tstruct ieee80211_tx_rate rates[4];\n\tstruct ath_frame_info *fi;\n\tint nframes;\n\tbool flush = !!(ts->ts_status & ATH9K_TX_FLUSH);\n\tint i, retries;\n\tint bar_index = -1;\n\n\tskb = bf->bf_mpdu;\n\ttx_info = IEEE80211_SKB_CB(skb);\n\n\tmemcpy(rates, bf->rates, sizeof(rates));\n\n\tretries = ts->ts_longretry + 1;\n\tfor (i = 0; i < ts->ts_rateindex; i++)\n\t\tretries += rates[i].count;\n\n\tif (!sta) {\n\t\tINIT_LIST_HEAD(&bf_head);\n\t\twhile (bf) {\n\t\t\tbf_next = bf->bf_next;\n\n\t\t\tif (!bf->bf_state.stale || bf_next != NULL)\n\t\t\t\tlist_move_tail(&bf->list, &bf_head);\n\n\t\t\tath_tx_complete_buf(sc, bf, txq, &bf_head, NULL, ts, 0);\n\n\t\t\tbf = bf_next;\n\t\t}\n\t\treturn;\n\t}\n\n\tan = (struct ath_node *)sta->drv_priv;\n\tseq_first = tid->seq_start;\n\tisba = ts->ts_flags & ATH9K_TX_BA;\n\n\t \n\tif (isba && tid->tidno != ts->tid)\n\t\ttxok = false;\n\n\tisaggr = bf_isaggr(bf);\n\tmemset(ba, 0, WME_BA_BMP_SIZE >> 3);\n\n\tif (isaggr && txok) {\n\t\tif (ts->ts_flags & ATH9K_TX_BA) {\n\t\t\tseq_st = ts->ts_seqnum;\n\t\t\tmemcpy(ba, &ts->ba, WME_BA_BMP_SIZE >> 3);\n\t\t} else {\n\t\t\t \n\t\t\tif (sc->sc_ah->opmode == NL80211_IFTYPE_STATION)\n\t\t\t\tneedreset = 1;\n\t\t}\n\t}\n\n\t__skb_queue_head_init(&bf_pending);\n\n\tath_tx_count_frames(sc, bf, ts, txok, &nframes, &nbad);\n\twhile (bf) {\n\t\tu16 seqno = bf->bf_state.seqno;\n\n\t\ttxfail = txpending = sendbar = 0;\n\t\tbf_next = bf->bf_next;\n\n\t\tskb = bf->bf_mpdu;\n\t\ttx_info = IEEE80211_SKB_CB(skb);\n\t\tfi = get_frame_info(skb);\n\n\t\tif (!BAW_WITHIN(tid->seq_start, tid->baw_size, seqno) ||\n\t\t    !tid->active) {\n\t\t\t \n\t\t\ttxfail = 1;\n\t\t} else if (ATH_BA_ISSET(ba, ATH_BA_INDEX(seq_st, seqno))) {\n\t\t\t \n\t\t\tacked_cnt++;\n\t\t} else if (!isaggr && txok) {\n\t\t\t \n\t\t\tacked_cnt++;\n\t\t} else if (flush) {\n\t\t\ttxpending = 1;\n\t\t} else if (fi->retries < ATH_MAX_SW_RETRIES) {\n\t\t\tif (txok || !an->sleeping)\n\t\t\t\tath_tx_set_retry(sc, txq, bf->bf_mpdu,\n\t\t\t\t\t\t retries);\n\n\t\t\ttxpending = 1;\n\t\t} else {\n\t\t\ttxfail = 1;\n\t\t\ttxfail_cnt++;\n\t\t\tbar_index = max_t(int, bar_index,\n\t\t\t\tATH_BA_INDEX(seq_first, seqno));\n\t\t}\n\n\t\t \n\t\tINIT_LIST_HEAD(&bf_head);\n\t\tif (bf_next != NULL || !bf_last->bf_state.stale)\n\t\t\tlist_move_tail(&bf->list, &bf_head);\n\n\t\tif (!txpending) {\n\t\t\t \n\t\t\tath_tx_update_baw(sc, tid, bf);\n\n\t\t\tif (rc_update && (acked_cnt == 1 || txfail_cnt == 1)) {\n\t\t\t\tmemcpy(tx_info->control.rates, rates, sizeof(rates));\n\t\t\t\tath_tx_rc_status(sc, bf, ts, nframes, nbad, txok);\n\t\t\t\trc_update = false;\n\t\t\t\tif (bf == bf->bf_lastbf)\n\t\t\t\t\tath_dynack_sample_tx_ts(sc->sc_ah,\n\t\t\t\t\t\t\t\tbf->bf_mpdu,\n\t\t\t\t\t\t\t\tts, sta);\n\t\t\t}\n\n\t\t\tath_tx_complete_buf(sc, bf, txq, &bf_head, sta, ts,\n\t\t\t\t!txfail);\n\t\t} else {\n\t\t\tif (tx_info->flags & IEEE80211_TX_STATUS_EOSP) {\n\t\t\t\ttx_info->flags &= ~IEEE80211_TX_STATUS_EOSP;\n\t\t\t\tieee80211_sta_eosp(sta);\n\t\t\t}\n\t\t\t \n\t\t\tif (bf->bf_next == NULL && bf_last->bf_state.stale) {\n\t\t\t\tstruct ath_buf *tbf;\n\n\t\t\t\ttbf = ath_clone_txbuf(sc, bf_last);\n\t\t\t\t \n\t\t\t\tif (!tbf) {\n\t\t\t\t\tath_tx_update_baw(sc, tid, bf);\n\n\t\t\t\t\tath_tx_complete_buf(sc, bf, txq,\n\t\t\t\t\t\t\t    &bf_head, NULL, ts,\n\t\t\t\t\t\t\t    0);\n\t\t\t\t\tbar_index = max_t(int, bar_index,\n\t\t\t\t\t\tATH_BA_INDEX(seq_first, seqno));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfi->bf = tbf;\n\t\t\t}\n\n\t\t\t \n\t\t\t__skb_queue_tail(&bf_pending, skb);\n\t\t}\n\n\t\tbf = bf_next;\n\t}\n\n\t \n\tif (!skb_queue_empty(&bf_pending)) {\n\t\tif (an->sleeping)\n\t\t\tieee80211_sta_set_buffered(sta, tid->tidno, true);\n\n\t\tskb_queue_splice_tail(&bf_pending, &tid->retry_q);\n\t\tif (!an->sleeping) {\n\t\t\tath_tx_queue_tid(sc, tid);\n\t\t\tif (ts->ts_status & (ATH9K_TXERR_FILT | ATH9K_TXERR_XRETRY))\n\t\t\t\ttid->clear_ps_filter = true;\n\t\t}\n\t}\n\n\tif (bar_index >= 0) {\n\t\tu16 bar_seq = ATH_BA_INDEX2SEQ(seq_first, bar_index);\n\n\t\tif (BAW_WITHIN(tid->seq_start, tid->baw_size, bar_seq))\n\t\t\ttid->bar_index = ATH_BA_INDEX(tid->seq_start, bar_seq);\n\n\t\tath_txq_unlock(sc, txq);\n\t\tath_send_bar(tid, ATH_BA_INDEX2SEQ(seq_first, bar_index + 1));\n\t\tath_txq_lock(sc, txq);\n\t}\n\n\tif (needreset)\n\t\tath9k_queue_reset(sc, RESET_TYPE_TX_ERROR);\n}\n\nstatic bool bf_is_ampdu_not_probing(struct ath_buf *bf)\n{\n    struct ieee80211_tx_info *info = IEEE80211_SKB_CB(bf->bf_mpdu);\n    return bf_isampdu(bf) && !(info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE);\n}\n\nstatic void ath_tx_count_airtime(struct ath_softc *sc,\n\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t struct ath_buf *bf,\n\t\t\t\t struct ath_tx_status *ts,\n\t\t\t\t u8 tid)\n{\n\tu32 airtime = 0;\n\tint i;\n\n\tairtime += ts->duration * (ts->ts_longretry + 1);\n\tfor(i = 0; i < ts->ts_rateindex; i++) {\n\t\tint rate_dur = ath9k_hw_get_duration(sc->sc_ah, bf->bf_desc, i);\n\t\tairtime += rate_dur * bf->rates[i].count;\n\t}\n\n\tieee80211_sta_register_airtime(sta, tid, airtime, 0);\n}\n\nstatic void ath_tx_process_buffer(struct ath_softc *sc, struct ath_txq *txq,\n\t\t\t\t  struct ath_tx_status *ts, struct ath_buf *bf,\n\t\t\t\t  struct list_head *bf_head)\n{\n\tstruct ieee80211_hw *hw = sc->hw;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_sta *sta;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ath_atx_tid *tid = NULL;\n\tbool txok, flush;\n\n\ttxok = !(ts->ts_status & ATH9K_TXERR_MASK);\n\tflush = !!(ts->ts_status & ATH9K_TX_FLUSH);\n\ttxq->axq_tx_inprogress = false;\n\n\ttxq->axq_depth--;\n\tif (bf_is_ampdu_not_probing(bf))\n\t\ttxq->axq_ampdu_depth--;\n\n\tts->duration = ath9k_hw_get_duration(sc->sc_ah, bf->bf_desc,\n\t\t\t\t\t     ts->ts_rateindex);\n\n\thdr = (struct ieee80211_hdr *) bf->bf_mpdu->data;\n\tsta = ieee80211_find_sta_by_ifaddr(hw, hdr->addr1, hdr->addr2);\n\tif (sta) {\n\t\tstruct ath_node *an = (struct ath_node *)sta->drv_priv;\n\t\ttid = ath_get_skb_tid(sc, an, bf->bf_mpdu);\n\t\tath_tx_count_airtime(sc, sta, bf, ts, tid->tidno);\n\t\tif (ts->ts_status & (ATH9K_TXERR_FILT | ATH9K_TXERR_XRETRY))\n\t\t\ttid->clear_ps_filter = true;\n\t}\n\n\tif (!bf_isampdu(bf)) {\n\t\tif (!flush) {\n\t\t\tinfo = IEEE80211_SKB_CB(bf->bf_mpdu);\n\t\t\tmemcpy(info->control.rates, bf->rates,\n\t\t\t       sizeof(info->control.rates));\n\t\t\tath_tx_rc_status(sc, bf, ts, 1, txok ? 0 : 1, txok);\n\t\t\tath_dynack_sample_tx_ts(sc->sc_ah, bf->bf_mpdu, ts,\n\t\t\t\t\t\tsta);\n\t\t}\n\t\tath_tx_complete_buf(sc, bf, txq, bf_head, sta, ts, txok);\n\t} else\n\t\tath_tx_complete_aggr(sc, txq, bf, bf_head, sta, tid, ts, txok);\n\n\tif (!flush)\n\t\tath_txq_schedule(sc, txq);\n}\n\nstatic bool ath_lookup_legacy(struct ath_buf *bf)\n{\n\tstruct sk_buff *skb;\n\tstruct ieee80211_tx_info *tx_info;\n\tstruct ieee80211_tx_rate *rates;\n\tint i;\n\n\tskb = bf->bf_mpdu;\n\ttx_info = IEEE80211_SKB_CB(skb);\n\trates = tx_info->control.rates;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (!rates[i].count || rates[i].idx < 0)\n\t\t\tbreak;\n\n\t\tif (!(rates[i].flags & IEEE80211_TX_RC_MCS))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic u32 ath_lookup_rate(struct ath_softc *sc, struct ath_buf *bf,\n\t\t\t   struct ath_atx_tid *tid)\n{\n\tstruct sk_buff *skb;\n\tstruct ieee80211_tx_info *tx_info;\n\tstruct ieee80211_tx_rate *rates;\n\tu32 max_4ms_framelen, frmlen;\n\tu16 aggr_limit, bt_aggr_limit, legacy = 0;\n\tint q = tid->txq->mac80211_qnum;\n\tint i;\n\n\tskb = bf->bf_mpdu;\n\ttx_info = IEEE80211_SKB_CB(skb);\n\trates = bf->rates;\n\n\t \n\tmax_4ms_framelen = ATH_AMPDU_LIMIT_MAX;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tint modeidx;\n\n\t\tif (!rates[i].count)\n\t\t\tcontinue;\n\n\t\tif (!(rates[i].flags & IEEE80211_TX_RC_MCS)) {\n\t\t\tlegacy = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rates[i].flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\n\t\t\tmodeidx = MCS_HT40;\n\t\telse\n\t\t\tmodeidx = MCS_HT20;\n\n\t\tif (rates[i].flags & IEEE80211_TX_RC_SHORT_GI)\n\t\t\tmodeidx++;\n\n\t\tfrmlen = sc->tx.max_aggr_framelen[q][modeidx][rates[i].idx];\n\t\tmax_4ms_framelen = min(max_4ms_framelen, frmlen);\n\t}\n\n\t \n\tif (tx_info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE || legacy)\n\t\treturn 0;\n\n\taggr_limit = min(max_4ms_framelen, (u32)ATH_AMPDU_LIMIT_MAX);\n\n\t \n\tbt_aggr_limit = ath9k_btcoex_aggr_limit(sc, max_4ms_framelen);\n\tif (bt_aggr_limit)\n\t\taggr_limit = bt_aggr_limit;\n\n\tif (tid->an->maxampdu)\n\t\taggr_limit = min(aggr_limit, tid->an->maxampdu);\n\n\treturn aggr_limit;\n}\n\n \nstatic int ath_compute_num_delims(struct ath_softc *sc, struct ath_atx_tid *tid,\n\t\t\t\t  struct ath_buf *bf, u16 frmlen,\n\t\t\t\t  bool first_subfrm)\n{\n#define FIRST_DESC_NDELIMS 60\n\tu32 nsymbits, nsymbols;\n\tu16 minlen;\n\tu8 flags, rix;\n\tint width, streams, half_gi, ndelim, mindelim;\n\tstruct ath_frame_info *fi = get_frame_info(bf->bf_mpdu);\n\n\t \n\tndelim = ATH_AGGR_GET_NDELIM(frmlen);\n\n\t \n\tif ((fi->keyix != ATH9K_TXKEYIX_INVALID) &&\n\t    !(sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_EDMA))\n\t\tndelim += ATH_AGGR_ENCRYPTDELIM;\n\n\t \n\tif (first_subfrm && !AR_SREV_9580_10_OR_LATER(sc->sc_ah) &&\n\t    (sc->sc_ah->ent_mode & AR_ENT_OTP_MIN_PKT_SIZE_DISABLE))\n\t\tndelim = max(ndelim, FIRST_DESC_NDELIMS);\n\n\t \n\n\tif (tid->an->mpdudensity == 0)\n\t\treturn ndelim;\n\n\trix = bf->rates[0].idx;\n\tflags = bf->rates[0].flags;\n\twidth = (flags & IEEE80211_TX_RC_40_MHZ_WIDTH) ? 1 : 0;\n\thalf_gi = (flags & IEEE80211_TX_RC_SHORT_GI) ? 1 : 0;\n\n\tif (half_gi)\n\t\tnsymbols = NUM_SYMBOLS_PER_USEC_HALFGI(tid->an->mpdudensity);\n\telse\n\t\tnsymbols = NUM_SYMBOLS_PER_USEC(tid->an->mpdudensity);\n\n\tif (nsymbols == 0)\n\t\tnsymbols = 1;\n\n\tstreams = HT_RC_2_STREAMS(rix);\n\tnsymbits = bits_per_symbol[rix % 8][width] * streams;\n\tminlen = (nsymbols * nsymbits) / BITS_PER_BYTE;\n\n\tif (frmlen < minlen) {\n\t\tmindelim = (minlen - frmlen) / ATH_AGGR_DELIM_SZ;\n\t\tndelim = max(mindelim, ndelim);\n\t}\n\n\treturn ndelim;\n}\n\nstatic int\nath_tx_get_tid_subframe(struct ath_softc *sc, struct ath_txq *txq,\n\t\t\tstruct ath_atx_tid *tid, struct ath_buf **buf)\n{\n\tstruct ieee80211_tx_info *tx_info;\n\tstruct ath_frame_info *fi;\n\tstruct ath_buf *bf;\n\tstruct sk_buff *skb, *first_skb = NULL;\n\tu16 seqno;\n\tint ret;\n\n\twhile (1) {\n\t\tret = ath_tid_dequeue(tid, &skb);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tfi = get_frame_info(skb);\n\t\tbf = fi->bf;\n\t\tif (!fi->bf)\n\t\t\tbf = ath_tx_setup_buffer(sc, txq, tid, skb);\n\t\telse\n\t\t\tbf->bf_state.stale = false;\n\n\t\tif (!bf) {\n\t\t\tath_txq_skb_done(sc, txq, skb);\n\t\t\tieee80211_free_txskb(sc->hw, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbf->bf_next = NULL;\n\t\tbf->bf_lastbf = bf;\n\n\t\ttx_info = IEEE80211_SKB_CB(skb);\n\t\ttx_info->flags &= ~(IEEE80211_TX_CTL_CLEAR_PS_FILT |\n\t\t\t\t    IEEE80211_TX_STATUS_EOSP);\n\n\t\t \n\t\tif (!tid->active)\n\t\t\ttx_info->flags &= ~IEEE80211_TX_CTL_AMPDU;\n\n\t\tif (!(tx_info->flags & IEEE80211_TX_CTL_AMPDU)) {\n\t\t\tbf->bf_state.bf_type = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tbf->bf_state.bf_type = BUF_AMPDU | BUF_AGGR;\n\t\tseqno = bf->bf_state.seqno;\n\n\t\t \n\t\tif (!BAW_WITHIN(tid->seq_start, tid->baw_size, seqno)) {\n\t\t\t__skb_queue_tail(&tid->retry_q, skb);\n\n\t\t\t \n\t\t\tif (!skb_queue_is_first(&tid->retry_q, skb) &&\n\t\t\t    !WARN_ON(skb == first_skb)) {\n\t\t\t\tif(!first_skb)  \n\t\t\t\t\tfirst_skb = skb;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn -EINPROGRESS;\n\t\t}\n\n\t\tif (tid->bar_index > ATH_BA_INDEX(tid->seq_start, seqno)) {\n\t\t\tstruct ath_tx_status ts = {};\n\t\t\tstruct list_head bf_head;\n\n\t\t\tINIT_LIST_HEAD(&bf_head);\n\t\t\tlist_add(&bf->list, &bf_head);\n\t\t\tath_tx_update_baw(sc, tid, bf);\n\t\t\tath_tx_complete_buf(sc, bf, txq, &bf_head, NULL, &ts, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (bf_isampdu(bf))\n\t\t\tath_tx_addto_baw(sc, tid, bf);\n\n\t\tbreak;\n\t}\n\n\t*buf = bf;\n\treturn 0;\n}\n\nstatic int\nath_tx_form_aggr(struct ath_softc *sc, struct ath_txq *txq,\n\t\t struct ath_atx_tid *tid, struct list_head *bf_q,\n\t\t struct ath_buf *bf_first)\n{\n#define PADBYTES(_len) ((4 - ((_len) % 4)) % 4)\n\tstruct ath_buf *bf = bf_first, *bf_prev = NULL;\n\tint nframes = 0, ndelim, ret;\n\tu16 aggr_limit = 0, al = 0, bpad = 0,\n\t    al_delta, h_baw = tid->baw_size / 2;\n\tstruct ieee80211_tx_info *tx_info;\n\tstruct ath_frame_info *fi;\n\tstruct sk_buff *skb;\n\n\n\tbf = bf_first;\n\taggr_limit = ath_lookup_rate(sc, bf, tid);\n\n\twhile (bf)\n\t{\n\t\tskb = bf->bf_mpdu;\n\t\tfi = get_frame_info(skb);\n\n\t\t \n\t\tal_delta = ATH_AGGR_DELIM_SZ + fi->framelen;\n\t\tif (nframes) {\n\t\t\tif (aggr_limit < al + bpad + al_delta ||\n\t\t\t    ath_lookup_legacy(bf) || nframes >= h_baw)\n\t\t\t\tgoto stop;\n\n\t\t\ttx_info = IEEE80211_SKB_CB(bf->bf_mpdu);\n\t\t\tif ((tx_info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE) ||\n\t\t\t    !(tx_info->flags & IEEE80211_TX_CTL_AMPDU))\n\t\t\t\tgoto stop;\n\t\t}\n\n\t\t \n\t\tal += bpad + al_delta;\n\n\t\t \n\t\tndelim = ath_compute_num_delims(sc, tid, bf_first, fi->framelen,\n\t\t\t\t\t\t!nframes);\n\t\tbpad = PADBYTES(al_delta) + (ndelim << 2);\n\n\t\tnframes++;\n\t\tbf->bf_next = NULL;\n\n\t\t \n\t\tbf->bf_state.ndelim = ndelim;\n\n\t\tlist_add_tail(&bf->list, bf_q);\n\t\tif (bf_prev)\n\t\t\tbf_prev->bf_next = bf;\n\n\t\tbf_prev = bf;\n\n\t\tret = ath_tx_get_tid_subframe(sc, txq, tid, &bf);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tgoto finish;\nstop:\n\t__skb_queue_tail(&tid->retry_q, bf->bf_mpdu);\nfinish:\n\tbf = bf_first;\n\tbf->bf_lastbf = bf_prev;\n\n\tif (bf == bf_prev) {\n\t\tal = get_frame_info(bf->bf_mpdu)->framelen;\n\t\tbf->bf_state.bf_type = BUF_AMPDU;\n\t} else {\n\t\tTX_STAT_INC(sc, txq->axq_qnum, a_aggr);\n\t}\n\n\treturn al;\n#undef PADBYTES\n}\n\n \nu32 ath_pkt_duration(struct ath_softc *sc, u8 rix, int pktlen,\n\t\t     int width, int half_gi, bool shortPreamble)\n{\n\tu32 nbits, nsymbits, duration, nsymbols;\n\tint streams;\n\n\t \n\tstreams = HT_RC_2_STREAMS(rix);\n\tnbits = (pktlen << 3) + OFDM_PLCP_BITS;\n\tnsymbits = bits_per_symbol[rix % 8][width] * streams;\n\tnsymbols = (nbits + nsymbits - 1) / nsymbits;\n\n\tif (!half_gi)\n\t\tduration = SYMBOL_TIME(nsymbols);\n\telse\n\t\tduration = SYMBOL_TIME_HALFGI(nsymbols);\n\n\t \n\tduration += L_STF + L_LTF + L_SIG + HT_SIG + HT_STF + HT_LTF(streams);\n\n\treturn duration;\n}\n\nstatic int ath_max_framelen(int usec, int mcs, bool ht40, bool sgi)\n{\n\tint streams = HT_RC_2_STREAMS(mcs);\n\tint symbols, bits;\n\tint bytes = 0;\n\n\tusec -= L_STF + L_LTF + L_SIG + HT_SIG + HT_STF + HT_LTF(streams);\n\tsymbols = sgi ? TIME_SYMBOLS_HALFGI(usec) : TIME_SYMBOLS(usec);\n\tbits = symbols * bits_per_symbol[mcs % 8][ht40] * streams;\n\tbits -= OFDM_PLCP_BITS;\n\tbytes = bits / 8;\n\tif (bytes > 65532)\n\t\tbytes = 65532;\n\n\treturn bytes;\n}\n\nvoid ath_update_max_aggr_framelen(struct ath_softc *sc, int queue, int txop)\n{\n\tu16 *cur_ht20, *cur_ht20_sgi, *cur_ht40, *cur_ht40_sgi;\n\tint mcs;\n\n\t \n\tif (!txop || txop > 4096)\n\t\ttxop = 4096;\n\n\tcur_ht20 = sc->tx.max_aggr_framelen[queue][MCS_HT20];\n\tcur_ht20_sgi = sc->tx.max_aggr_framelen[queue][MCS_HT20_SGI];\n\tcur_ht40 = sc->tx.max_aggr_framelen[queue][MCS_HT40];\n\tcur_ht40_sgi = sc->tx.max_aggr_framelen[queue][MCS_HT40_SGI];\n\tfor (mcs = 0; mcs < 32; mcs++) {\n\t\tcur_ht20[mcs] = ath_max_framelen(txop, mcs, false, false);\n\t\tcur_ht20_sgi[mcs] = ath_max_framelen(txop, mcs, false, true);\n\t\tcur_ht40[mcs] = ath_max_framelen(txop, mcs, true, false);\n\t\tcur_ht40_sgi[mcs] = ath_max_framelen(txop, mcs, true, true);\n\t}\n}\n\nstatic u8 ath_get_rate_txpower(struct ath_softc *sc, struct ath_buf *bf,\n\t\t\t       u8 rateidx, bool is_40, bool is_cck, bool is_mcs)\n{\n\tu8 max_power;\n\tstruct sk_buff *skb;\n\tstruct ath_frame_info *fi;\n\tstruct ieee80211_tx_info *info;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tbool is_2ghz, is_5ghz, use_stbc;\n\n\tif (sc->tx99_state || !ah->tpc_enabled)\n\t\treturn MAX_RATE_POWER;\n\n\tskb = bf->bf_mpdu;\n\tfi = get_frame_info(skb);\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\tis_2ghz = info->band == NL80211_BAND_2GHZ;\n\tis_5ghz = info->band == NL80211_BAND_5GHZ;\n\tuse_stbc = is_mcs && rateidx < 8 && (info->flags &\n\t\t\t\t\t     IEEE80211_TX_CTL_STBC);\n\n\tif (is_mcs)\n\t\trateidx += is_5ghz ? ATH9K_PWRTBL_11NA_HT_SHIFT\n\t\t\t\t   : ATH9K_PWRTBL_11NG_HT_SHIFT;\n\telse if (is_2ghz && !is_cck)\n\t\trateidx += ATH9K_PWRTBL_11NG_OFDM_SHIFT;\n\telse\n\t\trateidx += ATH9K_PWRTBL_11NA_OFDM_SHIFT;\n\n\tif (!AR_SREV_9300_20_OR_LATER(ah)) {\n\t\tint txpower = fi->tx_power;\n\n\t\tif (is_40) {\n\t\t\tu8 power_ht40delta;\n\t\t\tstruct ar5416_eeprom_def *eep = &ah->eeprom.def;\n\t\t\tu16 eeprom_rev = ah->eep_ops->get_eeprom_rev(ah);\n\n\t\t\tif (eeprom_rev >= AR5416_EEP_MINOR_VER_2) {\n\t\t\t\tstruct modal_eep_header *pmodal;\n\n\t\t\t\tpmodal = &eep->modalHeader[is_2ghz];\n\t\t\t\tpower_ht40delta = pmodal->ht40PowerIncForPdadc;\n\t\t\t} else {\n\t\t\t\tpower_ht40delta = 2;\n\t\t\t}\n\t\t\ttxpower += power_ht40delta;\n\t\t}\n\n\t\tif (AR_SREV_9287(ah) || AR_SREV_9285(ah) ||\n\t\t    AR_SREV_9271(ah)) {\n\t\t\ttxpower -= 2 * AR9287_PWR_TABLE_OFFSET_DB;\n\t\t} else if (AR_SREV_9280_20_OR_LATER(ah)) {\n\t\t\ts8 power_offset;\n\n\t\t\tpower_offset = ah->eep_ops->get_eeprom(ah,\n\t\t\t\t\t\t\tEEP_PWR_TABLE_OFFSET);\n\t\t\ttxpower -= 2 * power_offset;\n\t\t}\n\n\t\tif (OLC_FOR_AR9280_20_LATER(ah) && is_cck)\n\t\t\ttxpower -= 2;\n\n\t\ttxpower = max(txpower, 0);\n\t\tmax_power = min_t(u8, ah->tx_power[rateidx], txpower);\n\n\t\t \n\t\tif (!max_power && !AR_SREV_9280_20_OR_LATER(ah))\n\t\t\tmax_power = 1;\n\t} else if (!bf->bf_state.bfs_paprd) {\n\t\tif (use_stbc)\n\t\t\tmax_power = min_t(u8, ah->tx_power_stbc[rateidx],\n\t\t\t\t\t  fi->tx_power);\n\t\telse\n\t\t\tmax_power = min_t(u8, ah->tx_power[rateidx],\n\t\t\t\t\t  fi->tx_power);\n\t} else {\n\t\tmax_power = ah->paprd_training_power;\n\t}\n\n\treturn max_power;\n}\n\nstatic void ath_buf_set_rate(struct ath_softc *sc, struct ath_buf *bf,\n\t\t\t     struct ath_tx_info *info, int len, bool rts)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct sk_buff *skb;\n\tstruct ieee80211_tx_info *tx_info;\n\tstruct ieee80211_tx_rate *rates;\n\tconst struct ieee80211_rate *rate;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ath_frame_info *fi = get_frame_info(bf->bf_mpdu);\n\tu32 rts_thresh = sc->hw->wiphy->rts_threshold;\n\tint i;\n\tu8 rix = 0;\n\n\tskb = bf->bf_mpdu;\n\ttx_info = IEEE80211_SKB_CB(skb);\n\trates = bf->rates;\n\thdr = (struct ieee80211_hdr *)skb->data;\n\n\t \n\tinfo->dur_update = !ieee80211_is_pspoll(hdr->frame_control);\n\tinfo->rtscts_rate = fi->rtscts_rate;\n\n\tfor (i = 0; i < ARRAY_SIZE(bf->rates); i++) {\n\t\tbool is_40, is_sgi, is_sp, is_cck;\n\t\tint phy;\n\n\t\tif (!rates[i].count || (rates[i].idx < 0))\n\t\t\tbreak;\n\n\t\trix = rates[i].idx;\n\t\tinfo->rates[i].Tries = rates[i].count;\n\n\t\t \n\t\tif (bf_isampdu(bf) && !bf_isaggr(bf) &&\n\t\t    (rates[i].flags & IEEE80211_TX_RC_MCS) &&\n\t\t    unlikely(rts_thresh != (u32) -1)) {\n\t\t\tif (!rts_thresh || (len > rts_thresh))\n\t\t\t\trts = true;\n\t\t}\n\n\t\tif (rts || rates[i].flags & IEEE80211_TX_RC_USE_RTS_CTS) {\n\t\t\tinfo->rates[i].RateFlags |= ATH9K_RATESERIES_RTS_CTS;\n\t\t\tinfo->flags |= ATH9K_TXDESC_RTSENA;\n\t\t} else if (rates[i].flags & IEEE80211_TX_RC_USE_CTS_PROTECT) {\n\t\t\tinfo->rates[i].RateFlags |= ATH9K_RATESERIES_RTS_CTS;\n\t\t\tinfo->flags |= ATH9K_TXDESC_CTSENA;\n\t\t}\n\n\t\tif (rates[i].flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\n\t\t\tinfo->rates[i].RateFlags |= ATH9K_RATESERIES_2040;\n\t\tif (rates[i].flags & IEEE80211_TX_RC_SHORT_GI)\n\t\t\tinfo->rates[i].RateFlags |= ATH9K_RATESERIES_HALFGI;\n\n\t\tis_sgi = !!(rates[i].flags & IEEE80211_TX_RC_SHORT_GI);\n\t\tis_40 = !!(rates[i].flags & IEEE80211_TX_RC_40_MHZ_WIDTH);\n\t\tis_sp = !!(rates[i].flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE);\n\n\t\tif (rates[i].flags & IEEE80211_TX_RC_MCS) {\n\t\t\t \n\t\t\tinfo->rates[i].Rate = rix | 0x80;\n\t\t\tinfo->rates[i].ChSel = ath_txchainmask_reduction(sc,\n\t\t\t\t\tah->txchainmask, info->rates[i].Rate);\n\t\t\tinfo->rates[i].PktDuration = ath_pkt_duration(sc, rix, len,\n\t\t\t\t is_40, is_sgi, is_sp);\n\t\t\tif (rix < 8 && (tx_info->flags & IEEE80211_TX_CTL_STBC))\n\t\t\t\tinfo->rates[i].RateFlags |= ATH9K_RATESERIES_STBC;\n\t\t\tif (rix >= 8 && fi->dyn_smps) {\n\t\t\t\tinfo->rates[i].RateFlags |=\n\t\t\t\t\tATH9K_RATESERIES_RTS_CTS;\n\t\t\t\tinfo->flags |= ATH9K_TXDESC_CTSENA;\n\t\t\t}\n\n\t\t\tinfo->txpower[i] = ath_get_rate_txpower(sc, bf, rix,\n\t\t\t\t\t\t\t\tis_40, false, true);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\trate = &common->sbands[tx_info->band].bitrates[rates[i].idx];\n\t\tif ((tx_info->band == NL80211_BAND_2GHZ) &&\n\t\t    !(rate->flags & IEEE80211_RATE_ERP_G))\n\t\t\tphy = WLAN_RC_PHY_CCK;\n\t\telse\n\t\t\tphy = WLAN_RC_PHY_OFDM;\n\n\t\tinfo->rates[i].Rate = rate->hw_value;\n\t\tif (rate->hw_value_short) {\n\t\t\tif (rates[i].flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE)\n\t\t\t\tinfo->rates[i].Rate |= rate->hw_value_short;\n\t\t} else {\n\t\t\tis_sp = false;\n\t\t}\n\n\t\tif (bf->bf_state.bfs_paprd)\n\t\t\tinfo->rates[i].ChSel = ah->txchainmask;\n\t\telse\n\t\t\tinfo->rates[i].ChSel = ath_txchainmask_reduction(sc,\n\t\t\t\t\tah->txchainmask, info->rates[i].Rate);\n\n\t\tinfo->rates[i].PktDuration = ath9k_hw_computetxtime(sc->sc_ah,\n\t\t\tphy, rate->bitrate * 100, len, rix, is_sp);\n\n\t\tis_cck = IS_CCK_RATE(info->rates[i].Rate);\n\t\tinfo->txpower[i] = ath_get_rate_txpower(sc, bf, rix, false,\n\t\t\t\t\t\t\tis_cck, false);\n\t}\n\n\t \n\tif (bf_isaggr(bf) && (len > sc->sc_ah->caps.rts_aggr_limit))\n\t\tinfo->flags &= ~ATH9K_TXDESC_RTSENA;\n\n\t \n\tif (info->flags & ATH9K_TXDESC_RTSENA)\n\t\tinfo->flags &= ~ATH9K_TXDESC_CTSENA;\n}\n\nstatic enum ath9k_pkt_type get_hw_packet_type(struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr;\n\tenum ath9k_pkt_type htype;\n\t__le16 fc;\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\tfc = hdr->frame_control;\n\n\tif (ieee80211_is_beacon(fc))\n\t\thtype = ATH9K_PKT_TYPE_BEACON;\n\telse if (ieee80211_is_probe_resp(fc))\n\t\thtype = ATH9K_PKT_TYPE_PROBE_RESP;\n\telse if (ieee80211_is_atim(fc))\n\t\thtype = ATH9K_PKT_TYPE_ATIM;\n\telse if (ieee80211_is_pspoll(fc))\n\t\thtype = ATH9K_PKT_TYPE_PSPOLL;\n\telse\n\t\thtype = ATH9K_PKT_TYPE_NORMAL;\n\n\treturn htype;\n}\n\nstatic void ath_tx_fill_desc(struct ath_softc *sc, struct ath_buf *bf,\n\t\t\t     struct ath_txq *txq, int len)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_buf *bf_first = NULL;\n\tstruct ath_tx_info info;\n\tu32 rts_thresh = sc->hw->wiphy->rts_threshold;\n\tbool rts = false;\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.is_first = true;\n\tinfo.is_last = true;\n\tinfo.qcu = txq->axq_qnum;\n\n\twhile (bf) {\n\t\tstruct sk_buff *skb = bf->bf_mpdu;\n\t\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\t\tstruct ath_frame_info *fi = get_frame_info(skb);\n\t\tbool aggr = !!(bf->bf_state.bf_type & BUF_AGGR);\n\n\t\tinfo.type = get_hw_packet_type(skb);\n\t\tif (bf->bf_next)\n\t\t\tinfo.link = bf->bf_next->bf_daddr;\n\t\telse\n\t\t\tinfo.link = (sc->tx99_state) ? bf->bf_daddr : 0;\n\n\t\tif (!bf_first) {\n\t\t\tbf_first = bf;\n\n\t\t\tif (!sc->tx99_state)\n\t\t\t\tinfo.flags = ATH9K_TXDESC_INTREQ;\n\t\t\tif ((tx_info->flags & IEEE80211_TX_CTL_CLEAR_PS_FILT) ||\n\t\t\t    txq == sc->tx.uapsdq)\n\t\t\t\tinfo.flags |= ATH9K_TXDESC_CLRDMASK;\n\n\t\t\tif (tx_info->flags & IEEE80211_TX_CTL_NO_ACK)\n\t\t\t\tinfo.flags |= ATH9K_TXDESC_NOACK;\n\t\t\tif (tx_info->flags & IEEE80211_TX_CTL_LDPC)\n\t\t\t\tinfo.flags |= ATH9K_TXDESC_LDPC;\n\n\t\t\tif (bf->bf_state.bfs_paprd)\n\t\t\t\tinfo.flags |= (u32) bf->bf_state.bfs_paprd <<\n\t\t\t\t\t      ATH9K_TXDESC_PAPRD_S;\n\n\t\t\t \n\t\t\tif (aggr && (bf == bf_first) &&\n\t\t\t    unlikely(rts_thresh != (u32) -1)) {\n\t\t\t\t \n\t\t\t\tif (!rts_thresh || (len > rts_thresh))\n\t\t\t\t\trts = true;\n\t\t\t}\n\n\t\t\tif (!aggr)\n\t\t\t\tlen = fi->framelen;\n\n\t\t\tath_buf_set_rate(sc, bf, &info, len, rts);\n\t\t}\n\n\t\tinfo.buf_addr[0] = bf->bf_buf_addr;\n\t\tinfo.buf_len[0] = skb->len;\n\t\tinfo.pkt_len = fi->framelen;\n\t\tinfo.keyix = fi->keyix;\n\t\tinfo.keytype = fi->keytype;\n\n\t\tif (aggr) {\n\t\t\tif (bf == bf_first)\n\t\t\t\tinfo.aggr = AGGR_BUF_FIRST;\n\t\t\telse if (bf == bf_first->bf_lastbf)\n\t\t\t\tinfo.aggr = AGGR_BUF_LAST;\n\t\t\telse\n\t\t\t\tinfo.aggr = AGGR_BUF_MIDDLE;\n\n\t\t\tinfo.ndelim = bf->bf_state.ndelim;\n\t\t\tinfo.aggr_len = len;\n\t\t}\n\n\t\tif (bf == bf_first->bf_lastbf)\n\t\t\tbf_first = NULL;\n\n\t\tath9k_hw_set_txdesc(ah, bf->bf_desc, &info);\n\t\tbf = bf->bf_next;\n\t}\n}\n\nstatic void\nath_tx_form_burst(struct ath_softc *sc, struct ath_txq *txq,\n\t\t  struct ath_atx_tid *tid, struct list_head *bf_q,\n\t\t  struct ath_buf *bf_first)\n{\n\tstruct ath_buf *bf = bf_first, *bf_prev = NULL;\n\tint nframes = 0, ret;\n\n\tdo {\n\t\tstruct ieee80211_tx_info *tx_info;\n\n\t\tnframes++;\n\t\tlist_add_tail(&bf->list, bf_q);\n\t\tif (bf_prev)\n\t\t\tbf_prev->bf_next = bf;\n\t\tbf_prev = bf;\n\n\t\tif (nframes >= 2)\n\t\t\tbreak;\n\n\t\tret = ath_tx_get_tid_subframe(sc, txq, tid, &bf);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\ttx_info = IEEE80211_SKB_CB(bf->bf_mpdu);\n\t\tif (tx_info->flags & IEEE80211_TX_CTL_AMPDU) {\n\t\t\t__skb_queue_tail(&tid->retry_q, bf->bf_mpdu);\n\t\t\tbreak;\n\t\t}\n\n\t\tath_set_rates(tid->an->vif, tid->an->sta, bf);\n\t} while (1);\n}\n\nstatic int ath_tx_sched_aggr(struct ath_softc *sc, struct ath_txq *txq,\n\t\t\t     struct ath_atx_tid *tid)\n{\n\tstruct ath_buf *bf = NULL;\n\tstruct ieee80211_tx_info *tx_info;\n\tstruct list_head bf_q;\n\tint aggr_len = 0, ret;\n\tbool aggr;\n\n\tINIT_LIST_HEAD(&bf_q);\n\n\tret = ath_tx_get_tid_subframe(sc, txq, tid, &bf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttx_info = IEEE80211_SKB_CB(bf->bf_mpdu);\n\taggr = !!(tx_info->flags & IEEE80211_TX_CTL_AMPDU);\n\tif ((aggr && txq->axq_ampdu_depth >= ATH_AGGR_MIN_QDEPTH) ||\n\t    (!aggr && txq->axq_depth >= ATH_NON_AGGR_MIN_QDEPTH)) {\n\t\t__skb_queue_tail(&tid->retry_q, bf->bf_mpdu);\n\t\treturn -EBUSY;\n\t}\n\n\tath_set_rates(tid->an->vif, tid->an->sta, bf);\n\tif (aggr)\n\t\taggr_len = ath_tx_form_aggr(sc, txq, tid, &bf_q, bf);\n\telse\n\t\tath_tx_form_burst(sc, txq, tid, &bf_q, bf);\n\n\tif (list_empty(&bf_q))\n\t\treturn -EAGAIN;\n\n\tif (tid->clear_ps_filter || tid->an->no_ps_filter) {\n\t\ttid->clear_ps_filter = false;\n\t\ttx_info->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT;\n\t}\n\n\tath_tx_fill_desc(sc, bf, txq, aggr_len);\n\tath_tx_txqaddbuf(sc, txq, &bf_q, false);\n\treturn 0;\n}\n\nint ath_tx_aggr_start(struct ath_softc *sc, struct ieee80211_sta *sta,\n\t\t      u16 tid, u16 *ssn)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_atx_tid *txtid;\n\tstruct ath_txq *txq;\n\tstruct ath_node *an;\n\tu8 density;\n\n\tath_dbg(common, XMIT, \"%s called\\n\", __func__);\n\n\tan = (struct ath_node *)sta->drv_priv;\n\ttxtid = ATH_AN_2_TID(an, tid);\n\ttxq = txtid->txq;\n\n\tath_txq_lock(sc, txq);\n\n\t \n\tif (sta->deflink.ht_cap.ht_supported) {\n\t\tan->maxampdu = (1 << (IEEE80211_HT_MAX_AMPDU_FACTOR +\n\t\t\t\t      sta->deflink.ht_cap.ampdu_factor)) - 1;\n\t\tdensity = ath9k_parse_mpdudensity(sta->deflink.ht_cap.ampdu_density);\n\t\tan->mpdudensity = density;\n\t}\n\n\ttxtid->active = true;\n\t*ssn = txtid->seq_start = txtid->seq_next;\n\ttxtid->bar_index = -1;\n\n\tmemset(txtid->tx_buf, 0, sizeof(txtid->tx_buf));\n\ttxtid->baw_head = txtid->baw_tail = 0;\n\n\tath_txq_unlock_complete(sc, txq);\n\n\treturn 0;\n}\n\nvoid ath_tx_aggr_stop(struct ath_softc *sc, struct ieee80211_sta *sta, u16 tid)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_node *an = (struct ath_node *)sta->drv_priv;\n\tstruct ath_atx_tid *txtid = ATH_AN_2_TID(an, tid);\n\tstruct ath_txq *txq = txtid->txq;\n\n\tath_dbg(common, XMIT, \"%s called\\n\", __func__);\n\n\tath_txq_lock(sc, txq);\n\ttxtid->active = false;\n\tath_tx_flush_tid(sc, txtid);\n\tath_txq_unlock_complete(sc, txq);\n}\n\nvoid ath_tx_aggr_sleep(struct ieee80211_sta *sta, struct ath_softc *sc,\n\t\t       struct ath_node *an)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_atx_tid *tid;\n\tint tidno;\n\n\tath_dbg(common, XMIT, \"%s called\\n\", __func__);\n\n\tfor (tidno = 0; tidno < IEEE80211_NUM_TIDS; tidno++) {\n\t\ttid = ath_node_to_tid(an, tidno);\n\n\t\tif (!skb_queue_empty(&tid->retry_q))\n\t\t\tieee80211_sta_set_buffered(sta, tid->tidno, true);\n\n\t}\n}\n\nvoid ath_tx_aggr_wakeup(struct ath_softc *sc, struct ath_node *an)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_atx_tid *tid;\n\tstruct ath_txq *txq;\n\tint tidno;\n\n\tath_dbg(common, XMIT, \"%s called\\n\", __func__);\n\n\tfor (tidno = 0; tidno < IEEE80211_NUM_TIDS; tidno++) {\n\t\ttid = ath_node_to_tid(an, tidno);\n\t\ttxq = tid->txq;\n\n\t\tath_txq_lock(sc, txq);\n\t\ttid->clear_ps_filter = true;\n\t\tif (!skb_queue_empty(&tid->retry_q)) {\n\t\t\tath_tx_queue_tid(sc, tid);\n\t\t\tath_txq_schedule(sc, txq);\n\t\t}\n\t\tath_txq_unlock_complete(sc, txq);\n\n\t}\n}\n\n\nstatic void\nath9k_set_moredata(struct ath_softc *sc, struct ath_buf *bf, bool val)\n{\n\tstruct ieee80211_hdr *hdr;\n\tu16 mask = cpu_to_le16(IEEE80211_FCTL_MOREDATA);\n\tu16 mask_val = mask * val;\n\n\thdr = (struct ieee80211_hdr *) bf->bf_mpdu->data;\n\tif ((hdr->frame_control & mask) != mask_val) {\n\t\thdr->frame_control = (hdr->frame_control & ~mask) | mask_val;\n\t\tdma_sync_single_for_device(sc->dev, bf->bf_buf_addr,\n\t\t\tsizeof(*hdr), DMA_TO_DEVICE);\n\t}\n}\n\nvoid ath9k_release_buffered_frames(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   u16 tids, int nframes,\n\t\t\t\t   enum ieee80211_frame_release_type reason,\n\t\t\t\t   bool more_data)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_node *an = (struct ath_node *)sta->drv_priv;\n\tstruct ath_txq *txq = sc->tx.uapsdq;\n\tstruct ieee80211_tx_info *info;\n\tstruct list_head bf_q;\n\tstruct ath_buf *bf_tail = NULL, *bf = NULL;\n\tint i, ret;\n\n\tINIT_LIST_HEAD(&bf_q);\n\tfor (i = 0; tids && nframes; i++, tids >>= 1) {\n\t\tstruct ath_atx_tid *tid;\n\n\t\tif (!(tids & 1))\n\t\t\tcontinue;\n\n\t\ttid = ATH_AN_2_TID(an, i);\n\n\t\tath_txq_lock(sc, tid->txq);\n\t\twhile (nframes > 0) {\n\t\t\tret = ath_tx_get_tid_subframe(sc, sc->tx.uapsdq,\n\t\t\t\t\t\t      tid, &bf);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\tath9k_set_moredata(sc, bf, true);\n\t\t\tlist_add_tail(&bf->list, &bf_q);\n\t\t\tath_set_rates(tid->an->vif, tid->an->sta, bf);\n\t\t\tif (bf_isampdu(bf))\n\t\t\t\tbf->bf_state.bf_type &= ~BUF_AGGR;\n\t\t\tif (bf_tail)\n\t\t\t\tbf_tail->bf_next = bf;\n\n\t\t\tbf_tail = bf;\n\t\t\tnframes--;\n\t\t\tTX_STAT_INC(sc, txq->axq_qnum, a_queued_hw);\n\n\t\t\tif (an->sta && skb_queue_empty(&tid->retry_q))\n\t\t\t\tieee80211_sta_set_buffered(an->sta, i, false);\n\t\t}\n\t\tath_txq_unlock_complete(sc, tid->txq);\n\t}\n\n\tif (list_empty(&bf_q))\n\t\treturn;\n\n\tif (!more_data)\n\t\tath9k_set_moredata(sc, bf_tail, false);\n\n\tinfo = IEEE80211_SKB_CB(bf_tail->bf_mpdu);\n\tinfo->flags |= IEEE80211_TX_STATUS_EOSP;\n\n\tbf = list_first_entry(&bf_q, struct ath_buf, list);\n\tath_txq_lock(sc, txq);\n\tath_tx_fill_desc(sc, bf, txq, 0);\n\tath_tx_txqaddbuf(sc, txq, &bf_q, false);\n\tath_txq_unlock(sc, txq);\n}\n\n \n \n \n\nstruct ath_txq *ath_txq_setup(struct ath_softc *sc, int qtype, int subtype)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath9k_tx_queue_info qi;\n\tstatic const int subtype_txq_to_hwq[] = {\n\t\t[IEEE80211_AC_BE] = ATH_TXQ_AC_BE,\n\t\t[IEEE80211_AC_BK] = ATH_TXQ_AC_BK,\n\t\t[IEEE80211_AC_VI] = ATH_TXQ_AC_VI,\n\t\t[IEEE80211_AC_VO] = ATH_TXQ_AC_VO,\n\t};\n\tint axq_qnum, i;\n\n\tmemset(&qi, 0, sizeof(qi));\n\tqi.tqi_subtype = subtype_txq_to_hwq[subtype];\n\tqi.tqi_aifs = ATH9K_TXQ_USEDEFAULT;\n\tqi.tqi_cwmin = ATH9K_TXQ_USEDEFAULT;\n\tqi.tqi_cwmax = ATH9K_TXQ_USEDEFAULT;\n\tqi.tqi_physCompBuf = 0;\n\n\t \n\tif (ah->caps.hw_caps & ATH9K_HW_CAP_EDMA) {\n\t\tqi.tqi_qflags = TXQ_FLAG_TXINT_ENABLE;\n\t} else {\n\t\tif (qtype == ATH9K_TX_QUEUE_UAPSD)\n\t\t\tqi.tqi_qflags = TXQ_FLAG_TXDESCINT_ENABLE;\n\t\telse\n\t\t\tqi.tqi_qflags = TXQ_FLAG_TXEOLINT_ENABLE |\n\t\t\t\t\tTXQ_FLAG_TXDESCINT_ENABLE;\n\t}\n\taxq_qnum = ath9k_hw_setuptxqueue(ah, qtype, &qi);\n\tif (axq_qnum == -1) {\n\t\t \n\t\treturn NULL;\n\t}\n\tif (!ATH_TXQ_SETUP(sc, axq_qnum)) {\n\t\tstruct ath_txq *txq = &sc->tx.txq[axq_qnum];\n\n\t\ttxq->axq_qnum = axq_qnum;\n\t\ttxq->mac80211_qnum = -1;\n\t\ttxq->axq_link = NULL;\n\t\t__skb_queue_head_init(&txq->complete_q);\n\t\tINIT_LIST_HEAD(&txq->axq_q);\n\t\tspin_lock_init(&txq->axq_lock);\n\t\ttxq->axq_depth = 0;\n\t\ttxq->axq_ampdu_depth = 0;\n\t\ttxq->axq_tx_inprogress = false;\n\t\tsc->tx.txqsetup |= 1<<axq_qnum;\n\n\t\ttxq->txq_headidx = txq->txq_tailidx = 0;\n\t\tfor (i = 0; i < ATH_TXFIFO_DEPTH; i++)\n\t\t\tINIT_LIST_HEAD(&txq->txq_fifo[i]);\n\t}\n\treturn &sc->tx.txq[axq_qnum];\n}\n\nint ath_txq_update(struct ath_softc *sc, int qnum,\n\t\t   struct ath9k_tx_queue_info *qinfo)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tint error = 0;\n\tstruct ath9k_tx_queue_info qi;\n\n\tBUG_ON(sc->tx.txq[qnum].axq_qnum != qnum);\n\n\tath9k_hw_get_txq_props(ah, qnum, &qi);\n\tqi.tqi_aifs = qinfo->tqi_aifs;\n\tqi.tqi_cwmin = qinfo->tqi_cwmin;\n\tqi.tqi_cwmax = qinfo->tqi_cwmax;\n\tqi.tqi_burstTime = qinfo->tqi_burstTime;\n\tqi.tqi_readyTime = qinfo->tqi_readyTime;\n\n\tif (!ath9k_hw_set_txq_props(ah, qnum, &qi)) {\n\t\tath_err(ath9k_hw_common(sc->sc_ah),\n\t\t\t\"Unable to update hardware queue %u!\\n\", qnum);\n\t\terror = -EIO;\n\t} else {\n\t\tath9k_hw_resettxqueue(ah, qnum);\n\t}\n\n\treturn error;\n}\n\nint ath_cabq_update(struct ath_softc *sc)\n{\n\tstruct ath9k_tx_queue_info qi;\n\tstruct ath_beacon_config *cur_conf = &sc->cur_chan->beacon;\n\tint qnum = sc->beacon.cabq->axq_qnum;\n\n\tath9k_hw_get_txq_props(sc->sc_ah, qnum, &qi);\n\n\tqi.tqi_readyTime = (TU_TO_USEC(cur_conf->beacon_interval) *\n\t\t\t    ATH_CABQ_READY_TIME) / 100;\n\tath_txq_update(sc, qnum, &qi);\n\n\treturn 0;\n}\n\nstatic void ath_drain_txq_list(struct ath_softc *sc, struct ath_txq *txq,\n\t\t\t       struct list_head *list)\n{\n\tstruct ath_buf *bf, *lastbf;\n\tstruct list_head bf_head;\n\tstruct ath_tx_status ts;\n\n\tmemset(&ts, 0, sizeof(ts));\n\tts.ts_status = ATH9K_TX_FLUSH;\n\tINIT_LIST_HEAD(&bf_head);\n\n\twhile (!list_empty(list)) {\n\t\tbf = list_first_entry(list, struct ath_buf, list);\n\n\t\tif (bf->bf_state.stale) {\n\t\t\tlist_del(&bf->list);\n\n\t\t\tath_tx_return_buffer(sc, bf);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlastbf = bf->bf_lastbf;\n\t\tlist_cut_position(&bf_head, list, &lastbf->list);\n\t\tath_tx_process_buffer(sc, txq, &ts, bf, &bf_head);\n\t}\n}\n\n \nvoid ath_draintxq(struct ath_softc *sc, struct ath_txq *txq)\n{\n\trcu_read_lock();\n\tath_txq_lock(sc, txq);\n\n\tif (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_EDMA) {\n\t\tint idx = txq->txq_tailidx;\n\n\t\twhile (!list_empty(&txq->txq_fifo[idx])) {\n\t\t\tath_drain_txq_list(sc, txq, &txq->txq_fifo[idx]);\n\n\t\t\tINCR(idx, ATH_TXFIFO_DEPTH);\n\t\t}\n\t\ttxq->txq_tailidx = idx;\n\t}\n\n\ttxq->axq_link = NULL;\n\ttxq->axq_tx_inprogress = false;\n\tath_drain_txq_list(sc, txq, &txq->axq_q);\n\n\tath_txq_unlock_complete(sc, txq);\n\trcu_read_unlock();\n}\n\nbool ath_drain_all_txq(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_txq *txq;\n\tint i;\n\tu32 npend = 0;\n\n\tif (test_bit(ATH_OP_INVALID, &common->op_flags))\n\t\treturn true;\n\n\tath9k_hw_abort_tx_dma(ah);\n\n\t \n\tfor (i = 0; i < ATH9K_NUM_TX_QUEUES; i++) {\n\t\tif (!ATH_TXQ_SETUP(sc, i))\n\t\t\tcontinue;\n\n\t\tif (!sc->tx.txq[i].axq_depth)\n\t\t\tcontinue;\n\n\t\tif (ath9k_hw_numtxpending(ah, sc->tx.txq[i].axq_qnum))\n\t\t\tnpend |= BIT(i);\n\t}\n\n\tif (npend) {\n\t\tRESET_STAT_INC(sc, RESET_TX_DMA_ERROR);\n\t\tath_dbg(common, RESET,\n\t\t\t\"Failed to stop TX DMA, queues=0x%03x!\\n\", npend);\n\t}\n\n\tfor (i = 0; i < ATH9K_NUM_TX_QUEUES; i++) {\n\t\tif (!ATH_TXQ_SETUP(sc, i))\n\t\t\tcontinue;\n\n\t\ttxq = &sc->tx.txq[i];\n\t\tath_draintxq(sc, txq);\n\t}\n\n\treturn !npend;\n}\n\nvoid ath_tx_cleanupq(struct ath_softc *sc, struct ath_txq *txq)\n{\n\tath9k_hw_releasetxqueue(sc->sc_ah, txq->axq_qnum);\n\tsc->tx.txqsetup &= ~(1<<txq->axq_qnum);\n}\n\n \nvoid ath_txq_schedule(struct ath_softc *sc, struct ath_txq *txq)\n{\n\tstruct ieee80211_hw *hw = sc->hw;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ieee80211_txq *queue;\n\tstruct ath_atx_tid *tid;\n\tint ret;\n\n\tif (txq->mac80211_qnum < 0)\n\t\treturn;\n\n\tif (test_bit(ATH_OP_HW_RESET, &common->op_flags))\n\t\treturn;\n\n\tieee80211_txq_schedule_start(hw, txq->mac80211_qnum);\n\tspin_lock_bh(&sc->chan_lock);\n\trcu_read_lock();\n\n\tif (sc->cur_chan->stopped)\n\t\tgoto out;\n\n\twhile ((queue = ieee80211_next_txq(hw, txq->mac80211_qnum))) {\n\t\tbool force;\n\n\t\ttid = (struct ath_atx_tid *)queue->drv_priv;\n\n\t\tret = ath_tx_sched_aggr(sc, txq, tid);\n\t\tath_dbg(common, QUEUE, \"ath_tx_sched_aggr returned %d\\n\", ret);\n\n\t\tforce = !skb_queue_empty(&tid->retry_q);\n\t\tieee80211_return_txq(hw, queue, force);\n\t}\n\nout:\n\trcu_read_unlock();\n\tspin_unlock_bh(&sc->chan_lock);\n\tieee80211_txq_schedule_end(hw, txq->mac80211_qnum);\n}\n\nvoid ath_txq_schedule_all(struct ath_softc *sc)\n{\n\tstruct ath_txq *txq;\n\tint i;\n\n\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\ttxq = sc->tx.txq_map[i];\n\n\t\tspin_lock_bh(&txq->axq_lock);\n\t\tath_txq_schedule(sc, txq);\n\t\tspin_unlock_bh(&txq->axq_lock);\n\t}\n}\n\n \n \n \n\n \nstatic void ath_tx_txqaddbuf(struct ath_softc *sc, struct ath_txq *txq,\n\t\t\t     struct list_head *head, bool internal)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath_buf *bf, *bf_last;\n\tbool puttxbuf = false;\n\tbool edma;\n\n\t \n\n\tif (list_empty(head))\n\t\treturn;\n\n\tedma = !!(ah->caps.hw_caps & ATH9K_HW_CAP_EDMA);\n\tbf = list_first_entry(head, struct ath_buf, list);\n\tbf_last = list_entry(head->prev, struct ath_buf, list);\n\n\tath_dbg(common, QUEUE, \"qnum: %d, txq depth: %d\\n\",\n\t\ttxq->axq_qnum, txq->axq_depth);\n\n\tif (edma && list_empty(&txq->txq_fifo[txq->txq_headidx])) {\n\t\tlist_splice_tail_init(head, &txq->txq_fifo[txq->txq_headidx]);\n\t\tINCR(txq->txq_headidx, ATH_TXFIFO_DEPTH);\n\t\tputtxbuf = true;\n\t} else {\n\t\tlist_splice_tail_init(head, &txq->axq_q);\n\n\t\tif (txq->axq_link) {\n\t\t\tath9k_hw_set_desc_link(ah, txq->axq_link, bf->bf_daddr);\n\t\t\tath_dbg(common, XMIT, \"link[%u] (%p)=%llx (%p)\\n\",\n\t\t\t\ttxq->axq_qnum, txq->axq_link,\n\t\t\t\tito64(bf->bf_daddr), bf->bf_desc);\n\t\t} else if (!edma)\n\t\t\tputtxbuf = true;\n\n\t\ttxq->axq_link = bf_last->bf_desc;\n\t}\n\n\tif (puttxbuf) {\n\t\tTX_STAT_INC(sc, txq->axq_qnum, puttxbuf);\n\t\tath9k_hw_puttxbuf(ah, txq->axq_qnum, bf->bf_daddr);\n\t\tath_dbg(common, XMIT, \"TXDP[%u] = %llx (%p)\\n\",\n\t\t\ttxq->axq_qnum, ito64(bf->bf_daddr), bf->bf_desc);\n\t}\n\n\tif (!edma || sc->tx99_state) {\n\t\tTX_STAT_INC(sc, txq->axq_qnum, txstart);\n\t\tath9k_hw_txstart(ah, txq->axq_qnum);\n\t}\n\n\tif (!internal) {\n\t\twhile (bf) {\n\t\t\ttxq->axq_depth++;\n\t\t\tif (bf_is_ampdu_not_probing(bf))\n\t\t\t\ttxq->axq_ampdu_depth++;\n\n\t\t\tbf_last = bf->bf_lastbf;\n\t\t\tbf = bf_last->bf_next;\n\t\t\tbf_last->bf_next = NULL;\n\t\t}\n\t}\n}\n\nstatic void ath_tx_send_normal(struct ath_softc *sc, struct ath_txq *txq,\n\t\t\t       struct ath_atx_tid *tid, struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tstruct ath_frame_info *fi = get_frame_info(skb);\n\tstruct list_head bf_head;\n\tstruct ath_buf *bf = fi->bf;\n\n\tINIT_LIST_HEAD(&bf_head);\n\tlist_add_tail(&bf->list, &bf_head);\n\tbf->bf_state.bf_type = 0;\n\tif (tid && (tx_info->flags & IEEE80211_TX_CTL_AMPDU)) {\n\t\tbf->bf_state.bf_type = BUF_AMPDU;\n\t\tath_tx_addto_baw(sc, tid, bf);\n\t}\n\n\tbf->bf_next = NULL;\n\tbf->bf_lastbf = bf;\n\tath_tx_fill_desc(sc, bf, txq, fi->framelen);\n\tath_tx_txqaddbuf(sc, txq, &bf_head, false);\n\tTX_STAT_INC(sc, txq->axq_qnum, queued);\n}\n\nstatic void setup_frame_info(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_sta *sta,\n\t\t\t     struct sk_buff *skb,\n\t\t\t     int framelen)\n{\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_key_conf *hw_key = tx_info->control.hw_key;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tconst struct ieee80211_rate *rate;\n\tstruct ath_frame_info *fi = get_frame_info(skb);\n\tstruct ath_node *an = NULL;\n\tenum ath9k_key_type keytype;\n\tbool short_preamble = false;\n\tu8 txpower;\n\n\t \n\tif (tx_info->control.vif &&\n\t    tx_info->control.vif->bss_conf.use_short_preamble)\n\t\tshort_preamble = true;\n\n\trate = ieee80211_get_rts_cts_rate(hw, tx_info);\n\tkeytype = ath9k_cmn_get_hw_crypto_keytype(skb);\n\n\tif (sta)\n\t\tan = (struct ath_node *) sta->drv_priv;\n\n\tif (tx_info->control.vif) {\n\t\tstruct ieee80211_vif *vif = tx_info->control.vif;\n\t\tif (vif->bss_conf.txpower == INT_MIN)\n\t\t\tgoto nonvifpower;\n\t\ttxpower = 2 * vif->bss_conf.txpower;\n\t} else {\n\t\tstruct ath_softc *sc;\n\tnonvifpower:\n\t\tsc = hw->priv;\n\n\t\ttxpower = sc->cur_chan->cur_txpower;\n\t}\n\n\tmemset(fi, 0, sizeof(*fi));\n\tfi->txq = -1;\n\tif (hw_key)\n\t\tfi->keyix = hw_key->hw_key_idx;\n\telse if (an && ieee80211_is_data(hdr->frame_control) && an->ps_key > 0)\n\t\tfi->keyix = an->ps_key;\n\telse\n\t\tfi->keyix = ATH9K_TXKEYIX_INVALID;\n\tfi->dyn_smps = sta && sta->deflink.smps_mode == IEEE80211_SMPS_DYNAMIC;\n\tfi->keytype = keytype;\n\tfi->framelen = framelen;\n\tfi->tx_power = txpower;\n\n\tif (!rate)\n\t\treturn;\n\tfi->rtscts_rate = rate->hw_value;\n\tif (short_preamble)\n\t\tfi->rtscts_rate |= rate->hw_value_short;\n}\n\nu8 ath_txchainmask_reduction(struct ath_softc *sc, u8 chainmask, u32 rate)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath9k_channel *curchan = ah->curchan;\n\n\tif ((ah->caps.hw_caps & ATH9K_HW_CAP_APM) && IS_CHAN_5GHZ(curchan) &&\n\t    (chainmask == 0x7) && (rate < 0x90))\n\t\treturn 0x3;\n\telse if (AR_SREV_9462(ah) && ath9k_hw_btcoex_is_enabled(ah) &&\n\t\t IS_CCK_RATE(rate))\n\t\treturn 0x2;\n\telse\n\t\treturn chainmask;\n}\n\n \nstatic struct ath_buf *ath_tx_setup_buffer(struct ath_softc *sc,\n\t\t\t\t\t   struct ath_txq *txq,\n\t\t\t\t\t   struct ath_atx_tid *tid,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_frame_info *fi = get_frame_info(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct ath_buf *bf;\n\tint fragno;\n\tu16 seqno;\n\n\tbf = ath_tx_get_buffer(sc);\n\tif (!bf) {\n\t\tath_dbg(common, XMIT, \"TX buffers are full\\n\");\n\t\treturn NULL;\n\t}\n\n\tATH_TXBUF_RESET(bf);\n\n\tif (tid && ieee80211_is_data_present(hdr->frame_control)) {\n\t\tfragno = le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_FRAG;\n\t\tseqno = tid->seq_next;\n\t\thdr->seq_ctrl = cpu_to_le16(tid->seq_next << IEEE80211_SEQ_SEQ_SHIFT);\n\n\t\tif (fragno)\n\t\t\thdr->seq_ctrl |= cpu_to_le16(fragno);\n\n\t\tif (!ieee80211_has_morefrags(hdr->frame_control))\n\t\t\tINCR(tid->seq_next, IEEE80211_SEQ_MAX);\n\n\t\tbf->bf_state.seqno = seqno;\n\t}\n\n\tbf->bf_mpdu = skb;\n\n\tbf->bf_buf_addr = dma_map_single(sc->dev, skb->data,\n\t\t\t\t\t skb->len, DMA_TO_DEVICE);\n\tif (unlikely(dma_mapping_error(sc->dev, bf->bf_buf_addr))) {\n\t\tbf->bf_mpdu = NULL;\n\t\tbf->bf_buf_addr = 0;\n\t\tath_err(ath9k_hw_common(sc->sc_ah),\n\t\t\t\"dma_mapping_error() on TX\\n\");\n\t\tath_tx_return_buffer(sc, bf);\n\t\treturn NULL;\n\t}\n\n\tfi->bf = bf;\n\n\treturn bf;\n}\n\nvoid ath_assign_seq(struct ath_common *common, struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_vif *vif = info->control.vif;\n\tstruct ath_vif *avp;\n\n\tif (!(info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ))\n\t\treturn;\n\n\tif (!vif)\n\t\treturn;\n\n\tavp = (struct ath_vif *)vif->drv_priv;\n\n\tif (info->flags & IEEE80211_TX_CTL_FIRST_FRAGMENT)\n\t\tavp->seq_no += 0x10;\n\n\thdr->seq_ctrl &= cpu_to_le16(IEEE80211_SCTL_FRAG);\n\thdr->seq_ctrl |= cpu_to_le16(avp->seq_no);\n}\n\nstatic int ath_tx_prepare(struct ieee80211_hw *hw, struct sk_buff *skb,\n\t\t\t  struct ath_tx_control *txctl)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_sta *sta = txctl->sta;\n\tstruct ieee80211_vif *vif = info->control.vif;\n\tstruct ath_vif *avp;\n\tstruct ath_softc *sc = hw->priv;\n\tint frmlen = skb->len + FCS_LEN;\n\tint padpos, padsize;\n\n\t \n\tif (sta)\n\t\ttxctl->an = (struct ath_node *)sta->drv_priv;\n\telse if (vif && ieee80211_is_data(hdr->frame_control)) {\n\t\tavp = (void *)vif->drv_priv;\n\t\ttxctl->an = &avp->mcast_node;\n\t}\n\n\tif (info->control.hw_key)\n\t\tfrmlen += info->control.hw_key->icv_len;\n\n\tath_assign_seq(ath9k_hw_common(sc->sc_ah), skb);\n\n\tif ((vif && vif->type != NL80211_IFTYPE_AP &&\n\t            vif->type != NL80211_IFTYPE_AP_VLAN) ||\n\t    !ieee80211_is_data(hdr->frame_control))\n\t\tinfo->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT;\n\n\t \n\tpadpos = ieee80211_hdrlen(hdr->frame_control);\n\tpadsize = padpos & 3;\n\tif (padsize && skb->len > padpos) {\n\t\tif (skb_headroom(skb) < padsize)\n\t\t\treturn -ENOMEM;\n\n\t\tskb_push(skb, padsize);\n\t\tmemmove(skb->data, skb->data + padsize, padpos);\n\t}\n\n\tsetup_frame_info(hw, sta, skb, frmlen);\n\treturn 0;\n}\n\n\n \nint ath_tx_start(struct ieee80211_hw *hw, struct sk_buff *skb,\n\t\t struct ath_tx_control *txctl)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_sta *sta = txctl->sta;\n\tstruct ieee80211_vif *vif = info->control.vif;\n\tstruct ath_frame_info *fi = get_frame_info(skb);\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_txq *txq = txctl->txq;\n\tstruct ath_atx_tid *tid = NULL;\n\tstruct ath_node *an = NULL;\n\tstruct ath_buf *bf;\n\tbool ps_resp;\n\tint q, ret;\n\n\tps_resp = !!(info->control.flags & IEEE80211_TX_CTRL_PS_RESPONSE);\n\n\tret = ath_tx_prepare(hw, skb, txctl);\n\tif (ret)\n\t    return ret;\n\n\t \n\n\tq = skb_get_queue_mapping(skb);\n\n\tif (ps_resp)\n\t\ttxq = sc->tx.uapsdq;\n\n\tif (txctl->sta) {\n\t\tan = (struct ath_node *) sta->drv_priv;\n\t\ttid = ath_get_skb_tid(sc, an, skb);\n\t}\n\n\tath_txq_lock(sc, txq);\n\tif (txq == sc->tx.txq_map[q]) {\n\t\tfi->txq = q;\n\t\t++txq->pending_frames;\n\t}\n\n\tbf = ath_tx_setup_buffer(sc, txq, tid, skb);\n\tif (!bf) {\n\t\tath_txq_skb_done(sc, txq, skb);\n\t\tif (txctl->paprd)\n\t\t\tdev_kfree_skb_any(skb);\n\t\telse\n\t\t\tieee80211_free_txskb(sc->hw, skb);\n\t\tgoto out;\n\t}\n\n\tbf->bf_state.bfs_paprd = txctl->paprd;\n\n\tif (txctl->paprd)\n\t\tbf->bf_state.bfs_paprd_timestamp = jiffies;\n\n\tath_set_rates(vif, sta, bf);\n\tath_tx_send_normal(sc, txq, tid, skb);\n\nout:\n\tath_txq_unlock(sc, txq);\n\n\treturn 0;\n}\n\nvoid ath_tx_cabq(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t struct sk_buff *skb)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_tx_control txctl = {\n\t\t.txq = sc->beacon.cabq\n\t};\n\tstruct ath_tx_info info = {};\n\tstruct ath_buf *bf_tail = NULL;\n\tstruct ath_buf *bf;\n\tLIST_HEAD(bf_q);\n\tint duration = 0;\n\tint max_duration;\n\n\tmax_duration =\n\t\tsc->cur_chan->beacon.beacon_interval * 1000 *\n\t\tsc->cur_chan->beacon.dtim_period / ATH_BCBUF;\n\n\tdo {\n\t\tstruct ath_frame_info *fi = get_frame_info(skb);\n\n\t\tif (ath_tx_prepare(hw, skb, &txctl))\n\t\t\tbreak;\n\n\t\tbf = ath_tx_setup_buffer(sc, txctl.txq, NULL, skb);\n\t\tif (!bf)\n\t\t\tbreak;\n\n\t\tbf->bf_lastbf = bf;\n\t\tath_set_rates(vif, NULL, bf);\n\t\tath_buf_set_rate(sc, bf, &info, fi->framelen, false);\n\t\tduration += info.rates[0].PktDuration;\n\t\tif (bf_tail)\n\t\t\tbf_tail->bf_next = bf;\n\n\t\tlist_add_tail(&bf->list, &bf_q);\n\t\tbf_tail = bf;\n\t\tskb = NULL;\n\n\t\tif (duration > max_duration)\n\t\t\tbreak;\n\n\t\tskb = ieee80211_get_buffered_bc(hw, vif);\n\t} while(skb);\n\n\tif (skb)\n\t\tieee80211_free_txskb(hw, skb);\n\n\tif (list_empty(&bf_q))\n\t\treturn;\n\n\tbf = list_last_entry(&bf_q, struct ath_buf, list);\n\tath9k_set_moredata(sc, bf, false);\n\n\tbf = list_first_entry(&bf_q, struct ath_buf, list);\n\tath_txq_lock(sc, txctl.txq);\n\tath_tx_fill_desc(sc, bf, txctl.txq, 0);\n\tath_tx_txqaddbuf(sc, txctl.txq, &bf_q, false);\n\tTX_STAT_INC(sc, txctl.txq->axq_qnum, queued);\n\tath_txq_unlock(sc, txctl.txq);\n}\n\n \n \n \n\nstatic void ath_tx_complete(struct ath_softc *sc, struct sk_buff *skb,\n\t\t\t    int tx_flags, struct ath_txq *txq,\n\t\t\t    struct ieee80211_sta *sta)\n{\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ieee80211_hdr * hdr = (struct ieee80211_hdr *)skb->data;\n\tint padpos, padsize;\n\tunsigned long flags;\n\n\tath_dbg(common, XMIT, \"TX complete: skb: %p\\n\", skb);\n\n\tif (sc->sc_ah->caldata)\n\t\tset_bit(PAPRD_PACKET_SENT, &sc->sc_ah->caldata->cal_flags);\n\n\tif (!(tx_flags & ATH_TX_ERROR)) {\n\t\tif (tx_info->flags & IEEE80211_TX_CTL_NO_ACK)\n\t\t\ttx_info->flags |= IEEE80211_TX_STAT_NOACK_TRANSMITTED;\n\t\telse\n\t\t\ttx_info->flags |= IEEE80211_TX_STAT_ACK;\n\t}\n\n\tif (tx_info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS) {\n\t\tpadpos = ieee80211_hdrlen(hdr->frame_control);\n\t\tpadsize = padpos & 3;\n\t\tif (padsize && skb->len>padpos+padsize) {\n\t\t\t \n\t\t\tmemmove(skb->data + padsize, skb->data, padpos);\n\t\t\tskb_pull(skb, padsize);\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&sc->sc_pm_lock, flags);\n\tif ((sc->ps_flags & PS_WAIT_FOR_TX_ACK) && !txq->axq_depth) {\n\t\tsc->ps_flags &= ~PS_WAIT_FOR_TX_ACK;\n\t\tath_dbg(common, PS,\n\t\t\t\"Going back to sleep after having received TX status (0x%lx)\\n\",\n\t\t\tsc->ps_flags & (PS_WAIT_FOR_BEACON |\n\t\t\t\t\tPS_WAIT_FOR_CAB |\n\t\t\t\t\tPS_WAIT_FOR_PSPOLL_DATA |\n\t\t\t\t\tPS_WAIT_FOR_TX_ACK));\n\t}\n\tspin_unlock_irqrestore(&sc->sc_pm_lock, flags);\n\n\tath_txq_skb_done(sc, txq, skb);\n\ttx_info->status.status_driver_data[0] = sta;\n\t__skb_queue_tail(&txq->complete_q, skb);\n}\n\nstatic void ath_tx_complete_buf(struct ath_softc *sc, struct ath_buf *bf,\n\t\t\t\tstruct ath_txq *txq, struct list_head *bf_q,\n\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\tstruct ath_tx_status *ts, int txok)\n{\n\tstruct sk_buff *skb = bf->bf_mpdu;\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tunsigned long flags;\n\tint tx_flags = 0;\n\n\tif (!txok)\n\t\ttx_flags |= ATH_TX_ERROR;\n\n\tif (ts->ts_status & ATH9K_TXERR_FILT)\n\t\ttx_info->flags |= IEEE80211_TX_STAT_TX_FILTERED;\n\n\tdma_unmap_single(sc->dev, bf->bf_buf_addr, skb->len, DMA_TO_DEVICE);\n\tbf->bf_buf_addr = 0;\n\tif (sc->tx99_state)\n\t\tgoto skip_tx_complete;\n\n\tif (bf->bf_state.bfs_paprd) {\n\t\tif (time_after(jiffies,\n\t\t\t\tbf->bf_state.bfs_paprd_timestamp +\n\t\t\t\tmsecs_to_jiffies(ATH_PAPRD_TIMEOUT)))\n\t\t\tdev_kfree_skb_any(skb);\n\t\telse\n\t\t\tcomplete(&sc->paprd_complete);\n\t} else {\n\t\tath_debug_stat_tx(sc, bf, ts, txq, tx_flags);\n\t\tath_tx_complete(sc, skb, tx_flags, txq, sta);\n\t}\nskip_tx_complete:\n\t \n\tbf->bf_mpdu = NULL;\n\n\t \n\tspin_lock_irqsave(&sc->tx.txbuflock, flags);\n\tlist_splice_tail_init(bf_q, &sc->tx.txbuf);\n\tspin_unlock_irqrestore(&sc->tx.txbuflock, flags);\n}\n\nstatic void ath_clear_tx_status(struct ieee80211_tx_info *tx_info)\n{\n\tvoid *ptr = &tx_info->status;\n\n\tmemset(ptr + sizeof(tx_info->status.rates), 0,\n\t       sizeof(tx_info->status) -\n\t       sizeof(tx_info->status.rates) -\n\t       sizeof(tx_info->status.status_driver_data));\n}\n\nstatic void ath_tx_rc_status(struct ath_softc *sc, struct ath_buf *bf,\n\t\t\t     struct ath_tx_status *ts, int nframes, int nbad,\n\t\t\t     int txok)\n{\n\tstruct sk_buff *skb = bf->bf_mpdu;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hw *hw = sc->hw;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tu8 i, tx_rateindex;\n\n\tath_clear_tx_status(tx_info);\n\n\tif (txok)\n\t\ttx_info->status.ack_signal = ts->ts_rssi;\n\n\ttx_rateindex = ts->ts_rateindex;\n\tWARN_ON(tx_rateindex >= hw->max_rates);\n\n\tif (tx_info->flags & IEEE80211_TX_CTL_AMPDU) {\n\t\ttx_info->flags |= IEEE80211_TX_STAT_AMPDU;\n\n\t\tBUG_ON(nbad > nframes);\n\t}\n\ttx_info->status.ampdu_len = nframes;\n\ttx_info->status.ampdu_ack_len = nframes - nbad;\n\n\ttx_info->status.rates[tx_rateindex].count = ts->ts_longretry + 1;\n\n\tfor (i = tx_rateindex + 1; i < hw->max_rates; i++) {\n\t\ttx_info->status.rates[i].count = 0;\n\t\ttx_info->status.rates[i].idx = -1;\n\t}\n\n\tif ((ts->ts_status & ATH9K_TXERR_FILT) == 0 &&\n\t    (tx_info->flags & IEEE80211_TX_CTL_NO_ACK) == 0) {\n\t\t \n\t\tif (unlikely(ts->ts_flags & (ATH9K_TX_DATA_UNDERRUN |\n\t\t                             ATH9K_TX_DELIM_UNDERRUN)) &&\n\t\t    ieee80211_is_data(hdr->frame_control) &&\n\t\t    ah->tx_trig_level >= sc->sc_ah->config.max_txtrig_level)\n\t\t\ttx_info->status.rates[tx_rateindex].count =\n\t\t\t\thw->max_rate_tries;\n\t}\n}\n\nstatic void ath_tx_processq(struct ath_softc *sc, struct ath_txq *txq)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath_buf *bf, *lastbf, *bf_held = NULL;\n\tstruct list_head bf_head;\n\tstruct ath_desc *ds;\n\tstruct ath_tx_status ts;\n\tint status;\n\n\tath_dbg(common, QUEUE, \"tx queue %d (%x), link %p\\n\",\n\t\ttxq->axq_qnum, ath9k_hw_gettxbuf(sc->sc_ah, txq->axq_qnum),\n\t\ttxq->axq_link);\n\n\tath_txq_lock(sc, txq);\n\tfor (;;) {\n\t\tif (test_bit(ATH_OP_HW_RESET, &common->op_flags))\n\t\t\tbreak;\n\n\t\tif (list_empty(&txq->axq_q)) {\n\t\t\ttxq->axq_link = NULL;\n\t\t\tath_txq_schedule(sc, txq);\n\t\t\tbreak;\n\t\t}\n\t\tbf = list_first_entry(&txq->axq_q, struct ath_buf, list);\n\n\t\t \n\t\tbf_held = NULL;\n\t\tif (bf->bf_state.stale) {\n\t\t\tbf_held = bf;\n\t\t\tif (list_is_last(&bf_held->list, &txq->axq_q))\n\t\t\t\tbreak;\n\n\t\t\tbf = list_entry(bf_held->list.next, struct ath_buf,\n\t\t\t\t\tlist);\n\t\t}\n\n\t\tlastbf = bf->bf_lastbf;\n\t\tds = lastbf->bf_desc;\n\n\t\tmemset(&ts, 0, sizeof(ts));\n\t\tstatus = ath9k_hw_txprocdesc(ah, ds, &ts);\n\t\tif (status == -EINPROGRESS)\n\t\t\tbreak;\n\n\t\tTX_STAT_INC(sc, txq->axq_qnum, txprocdesc);\n\n\t\t \n\t\tlastbf->bf_state.stale = true;\n\t\tINIT_LIST_HEAD(&bf_head);\n\t\tif (!list_is_singular(&lastbf->list))\n\t\t\tlist_cut_position(&bf_head,\n\t\t\t\t&txq->axq_q, lastbf->list.prev);\n\n\t\tif (bf_held) {\n\t\t\tlist_del(&bf_held->list);\n\t\t\tath_tx_return_buffer(sc, bf_held);\n\t\t}\n\n\t\tath_tx_process_buffer(sc, txq, &ts, bf, &bf_head);\n\t}\n\tath_txq_unlock_complete(sc, txq);\n}\n\nvoid ath_tx_tasklet(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tu32 qcumask = ((1 << ATH9K_NUM_TX_QUEUES) - 1) & ah->intr_txqs;\n\tint i;\n\n\trcu_read_lock();\n\tfor (i = 0; i < ATH9K_NUM_TX_QUEUES; i++) {\n\t\tif (ATH_TXQ_SETUP(sc, i) && (qcumask & (1 << i)))\n\t\t\tath_tx_processq(sc, &sc->tx.txq[i]);\n\t}\n\trcu_read_unlock();\n}\n\nvoid ath_tx_edma_tasklet(struct ath_softc *sc)\n{\n\tstruct ath_tx_status ts;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_txq *txq;\n\tstruct ath_buf *bf, *lastbf;\n\tstruct list_head bf_head;\n\tstruct list_head *fifo_list;\n\tint status;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tif (test_bit(ATH_OP_HW_RESET, &common->op_flags))\n\t\t\tbreak;\n\n\t\tstatus = ath9k_hw_txprocdesc(ah, NULL, (void *)&ts);\n\t\tif (status == -EINPROGRESS)\n\t\t\tbreak;\n\t\tif (status == -EIO) {\n\t\t\tath_dbg(common, XMIT, \"Error processing tx status\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (ts.qid == sc->beacon.beaconq) {\n\t\t\tsc->beacon.tx_processed = true;\n\t\t\tsc->beacon.tx_last = !(ts.ts_status & ATH9K_TXERR_MASK);\n\n\t\t\tif (ath9k_is_chanctx_enabled()) {\n\t\t\t\tath_chanctx_event(sc, NULL,\n\t\t\t\t\t\t  ATH_CHANCTX_EVENT_BEACON_SENT);\n\t\t\t}\n\n\t\t\tath9k_csa_update(sc);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttxq = &sc->tx.txq[ts.qid];\n\n\t\tath_txq_lock(sc, txq);\n\n\t\tTX_STAT_INC(sc, txq->axq_qnum, txprocdesc);\n\n\t\tfifo_list = &txq->txq_fifo[txq->txq_tailidx];\n\t\tif (list_empty(fifo_list)) {\n\t\t\tath_txq_unlock(sc, txq);\n\t\t\tbreak;\n\t\t}\n\n\t\tbf = list_first_entry(fifo_list, struct ath_buf, list);\n\t\tif (bf->bf_state.stale) {\n\t\t\tlist_del(&bf->list);\n\t\t\tath_tx_return_buffer(sc, bf);\n\t\t\tbf = list_first_entry(fifo_list, struct ath_buf, list);\n\t\t}\n\n\t\tlastbf = bf->bf_lastbf;\n\n\t\tINIT_LIST_HEAD(&bf_head);\n\t\tif (list_is_last(&lastbf->list, fifo_list)) {\n\t\t\tlist_splice_tail_init(fifo_list, &bf_head);\n\t\t\tINCR(txq->txq_tailidx, ATH_TXFIFO_DEPTH);\n\n\t\t\tif (!list_empty(&txq->axq_q)) {\n\t\t\t\tstruct list_head bf_q;\n\n\t\t\t\tINIT_LIST_HEAD(&bf_q);\n\t\t\t\ttxq->axq_link = NULL;\n\t\t\t\tlist_splice_tail_init(&txq->axq_q, &bf_q);\n\t\t\t\tath_tx_txqaddbuf(sc, txq, &bf_q, true);\n\t\t\t}\n\t\t} else {\n\t\t\tlastbf->bf_state.stale = true;\n\t\t\tif (bf != lastbf)\n\t\t\t\tlist_cut_position(&bf_head, fifo_list,\n\t\t\t\t\t\t  lastbf->list.prev);\n\t\t}\n\n\t\tath_tx_process_buffer(sc, txq, &ts, bf, &bf_head);\n\t\tath_txq_unlock_complete(sc, txq);\n\t}\n\trcu_read_unlock();\n}\n\n \n \n \n\nstatic int ath_txstatus_setup(struct ath_softc *sc, int size)\n{\n\tstruct ath_descdma *dd = &sc->txsdma;\n\tu8 txs_len = sc->sc_ah->caps.txs_len;\n\n\tdd->dd_desc_len = size * txs_len;\n\tdd->dd_desc = dmam_alloc_coherent(sc->dev, dd->dd_desc_len,\n\t\t\t\t\t  &dd->dd_desc_paddr, GFP_KERNEL);\n\tif (!dd->dd_desc)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int ath_tx_edma_init(struct ath_softc *sc)\n{\n\tint err;\n\n\terr = ath_txstatus_setup(sc, ATH_TXSTATUS_RING_SIZE);\n\tif (!err)\n\t\tath9k_hw_setup_statusring(sc->sc_ah, sc->txsdma.dd_desc,\n\t\t\t\t\t  sc->txsdma.dd_desc_paddr,\n\t\t\t\t\t  ATH_TXSTATUS_RING_SIZE);\n\n\treturn err;\n}\n\nint ath_tx_init(struct ath_softc *sc, int nbufs)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tint error = 0;\n\n\tspin_lock_init(&sc->tx.txbuflock);\n\n\terror = ath_descdma_setup(sc, &sc->tx.txdma, &sc->tx.txbuf,\n\t\t\t\t  \"tx\", nbufs, 1, 1);\n\tif (error != 0) {\n\t\tath_err(common,\n\t\t\t\"Failed to allocate tx descriptors: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = ath_descdma_setup(sc, &sc->beacon.bdma, &sc->beacon.bbuf,\n\t\t\t\t  \"beacon\", ATH_BCBUF, 1, 1);\n\tif (error != 0) {\n\t\tath_err(common,\n\t\t\t\"Failed to allocate beacon descriptors: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tif (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_EDMA)\n\t\terror = ath_tx_edma_init(sc);\n\n\treturn error;\n}\n\nvoid ath_tx_node_init(struct ath_softc *sc, struct ath_node *an)\n{\n\tstruct ath_atx_tid *tid;\n\tint tidno, acno;\n\n\tfor (tidno = 0; tidno < IEEE80211_NUM_TIDS; tidno++) {\n\t\ttid = ath_node_to_tid(an, tidno);\n\t\ttid->an        = an;\n\t\ttid->tidno     = tidno;\n\t\ttid->seq_start = tid->seq_next = 0;\n\t\ttid->baw_size  = WME_MAX_BA;\n\t\ttid->baw_head  = tid->baw_tail = 0;\n\t\ttid->active\t   = false;\n\t\ttid->clear_ps_filter = true;\n\t\t__skb_queue_head_init(&tid->retry_q);\n\t\tINIT_LIST_HEAD(&tid->list);\n\t\tacno = TID_TO_WME_AC(tidno);\n\t\ttid->txq = sc->tx.txq_map[acno];\n\n\t\tif (!an->sta)\n\t\t\tbreak;  \n\t}\n}\n\nvoid ath_tx_node_cleanup(struct ath_softc *sc, struct ath_node *an)\n{\n\tstruct ath_atx_tid *tid;\n\tstruct ath_txq *txq;\n\tint tidno;\n\n\trcu_read_lock();\n\n\tfor (tidno = 0; tidno < IEEE80211_NUM_TIDS; tidno++) {\n\t\ttid = ath_node_to_tid(an, tidno);\n\t\ttxq = tid->txq;\n\n\t\tath_txq_lock(sc, txq);\n\n\t\tif (!list_empty(&tid->list))\n\t\t\tlist_del_init(&tid->list);\n\n\t\tath_tid_drain(sc, txq, tid);\n\t\ttid->active = false;\n\n\t\tath_txq_unlock(sc, txq);\n\n\t\tif (!an->sta)\n\t\t\tbreak;  \n\t}\n\n\trcu_read_unlock();\n}\n\n#ifdef CONFIG_ATH9K_TX99\n\nint ath9k_tx99_send(struct ath_softc *sc, struct sk_buff *skb,\n\t\t    struct ath_tx_control *txctl)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tstruct ath_frame_info *fi = get_frame_info(skb);\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_buf *bf;\n\tint padpos, padsize;\n\n\tpadpos = ieee80211_hdrlen(hdr->frame_control);\n\tpadsize = padpos & 3;\n\n\tif (padsize && skb->len > padpos) {\n\t\tif (skb_headroom(skb) < padsize) {\n\t\t\tath_dbg(common, XMIT,\n\t\t\t\t\"tx99 padding failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tskb_push(skb, padsize);\n\t\tmemmove(skb->data, skb->data + padsize, padpos);\n\t}\n\n\tfi->keyix = ATH9K_TXKEYIX_INVALID;\n\tfi->framelen = skb->len + FCS_LEN;\n\tfi->keytype = ATH9K_KEY_TYPE_CLEAR;\n\n\tbf = ath_tx_setup_buffer(sc, txctl->txq, NULL, skb);\n\tif (!bf) {\n\t\tath_dbg(common, XMIT, \"tx99 buffer setup failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tath_set_rates(sc->tx99_vif, NULL, bf);\n\n\tath9k_hw_set_desc_link(sc->sc_ah, bf->bf_desc, bf->bf_daddr);\n\tath9k_hw_tx99_start(sc->sc_ah, txctl->txq->axq_qnum);\n\n\tath_tx_send_normal(sc, txctl->txq, NULL, skb);\n\n\treturn 0;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}