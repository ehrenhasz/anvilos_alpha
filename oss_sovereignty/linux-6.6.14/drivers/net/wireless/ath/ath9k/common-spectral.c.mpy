{
  "module_name": "common-spectral.c",
  "hash_id": "224b5de3c68a9945ca72670646e37569a911464b0af751ffb483055f470a4a37",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/common-spectral.c",
  "human_readable_source": " \n\n#include <linux/relay.h>\n#include <linux/random.h>\n#include \"ath9k.h\"\n\nstatic s8 fix_rssi_inv_only(u8 rssi_val)\n{\n\tif (rssi_val == 128)\n\t\trssi_val = 0;\n\treturn (s8) rssi_val;\n}\n\nstatic void ath_debug_send_fft_sample(struct ath_spec_scan_priv *spec_priv,\n\t\t\t\t      struct fft_sample_tlv *fft_sample_tlv)\n{\n\tint length;\n\tif (!spec_priv->rfs_chan_spec_scan)\n\t\treturn;\n\n\tlength = __be16_to_cpu(fft_sample_tlv->length) +\n\t\t sizeof(*fft_sample_tlv);\n\trelay_write(spec_priv->rfs_chan_spec_scan, fft_sample_tlv, length);\n}\n\ntypedef int (ath_cmn_fft_idx_validator) (u8 *sample_end, int bytes_read);\n\nstatic int\nath_cmn_max_idx_verify_ht20_fft(u8 *sample_end, int bytes_read)\n{\n\tstruct ath_ht20_mag_info *mag_info;\n\tu8 *sample;\n\tu16 max_magnitude;\n\tu8 max_index;\n\tu8 max_exp;\n\n\t \n\tif (bytes_read < SPECTRAL_HT20_SAMPLE_LEN - 1)\n\t\treturn -1;\n\n\tmag_info = (struct ath_ht20_mag_info *) (sample_end -\n\t\t\t\tsizeof(struct ath_ht20_mag_info) + 1);\n\n\tsample = sample_end - SPECTRAL_HT20_SAMPLE_LEN + 1;\n\n\tmax_index = spectral_max_index_ht20(mag_info->all_bins);\n\tmax_magnitude = spectral_max_magnitude(mag_info->all_bins);\n\n\tmax_exp = mag_info->max_exp & 0xf;\n\n\t \n\tif (bytes_read < SPECTRAL_HT20_SAMPLE_LEN && max_index < 1)\n\t\treturn -1;\n\n\tif ((sample[max_index] & 0xf8) != ((max_magnitude >> max_exp) & 0xf8))\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}\n\nstatic int\nath_cmn_max_idx_verify_ht20_40_fft(u8 *sample_end, int bytes_read)\n{\n\tstruct ath_ht20_40_mag_info *mag_info;\n\tu8 *sample;\n\tu16 lower_mag, upper_mag;\n\tu8 lower_max_index, upper_max_index;\n\tu8 max_exp;\n\tint dc_pos = SPECTRAL_HT20_40_NUM_BINS / 2;\n\n\t \n\tif (bytes_read < SPECTRAL_HT20_40_SAMPLE_LEN - 1)\n\t\treturn -1;\n\n\tmag_info = (struct ath_ht20_40_mag_info *) (sample_end -\n\t\t\t\tsizeof(struct ath_ht20_40_mag_info) + 1);\n\n\tsample = sample_end - SPECTRAL_HT20_40_SAMPLE_LEN + 1;\n\n\tlower_mag = spectral_max_magnitude(mag_info->lower_bins);\n\tlower_max_index = spectral_max_index_ht40(mag_info->lower_bins);\n\n\tupper_mag = spectral_max_magnitude(mag_info->upper_bins);\n\tupper_max_index = spectral_max_index_ht40(mag_info->upper_bins);\n\n\tmax_exp = mag_info->max_exp & 0xf;\n\n\t \n\tif (bytes_read < SPECTRAL_HT20_40_SAMPLE_LEN &&\n\t   ((upper_max_index < 1) || (lower_max_index < 1)))\n\t\treturn -1;\n\n\tif (((sample[upper_max_index + dc_pos] & 0xf8) !=\n\t     ((upper_mag >> max_exp) & 0xf8)) ||\n\t    ((sample[lower_max_index] & 0xf8) !=\n\t     ((lower_mag >> max_exp) & 0xf8)))\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}\n\ntypedef int (ath_cmn_fft_sample_handler) (struct ath_rx_status *rs,\n\t\t\tstruct ath_spec_scan_priv *spec_priv,\n\t\t\tu8 *sample_buf, u64 tsf, u16 freq, int chan_type);\n\nstatic int\nath_cmn_process_ht20_fft(struct ath_rx_status *rs,\n\t\t\tstruct ath_spec_scan_priv *spec_priv,\n\t\t\tu8 *sample_buf,\n\t\t\tu64 tsf, u16 freq, int chan_type)\n{\n\tstruct fft_sample_ht20 fft_sample_20;\n\tstruct ath_common *common = ath9k_hw_common(spec_priv->ah);\n\tstruct ath_hw *ah = spec_priv->ah;\n\tstruct ath_ht20_mag_info *mag_info;\n\tstruct fft_sample_tlv *tlv;\n\tint i = 0;\n\tint ret = 0;\n\tint dc_pos = SPECTRAL_HT20_NUM_BINS / 2;\n\tu16 magnitude, tmp_mag, length;\n\tu8 max_index, bitmap_w, max_exp;\n\n\tlength = sizeof(fft_sample_20) - sizeof(struct fft_sample_tlv);\n\tfft_sample_20.tlv.type = ATH_FFT_SAMPLE_HT20;\n\tfft_sample_20.tlv.length = __cpu_to_be16(length);\n\tfft_sample_20.freq = __cpu_to_be16(freq);\n\tfft_sample_20.rssi = fix_rssi_inv_only(rs->rs_rssi_ctl[0]);\n\tfft_sample_20.noise = ah->noise;\n\n\tmag_info = (struct ath_ht20_mag_info *) (sample_buf +\n\t\t\t\t\tSPECTRAL_HT20_NUM_BINS);\n\n\tmagnitude = spectral_max_magnitude(mag_info->all_bins);\n\tfft_sample_20.max_magnitude = __cpu_to_be16(magnitude);\n\n\tmax_index = spectral_max_index_ht20(mag_info->all_bins);\n\tfft_sample_20.max_index = max_index;\n\n\tbitmap_w = spectral_bitmap_weight(mag_info->all_bins);\n\tfft_sample_20.bitmap_weight = bitmap_w;\n\n\tmax_exp = mag_info->max_exp & 0xf;\n\tfft_sample_20.max_exp = max_exp;\n\n\tfft_sample_20.tsf = __cpu_to_be64(tsf);\n\n\tmemcpy(fft_sample_20.data, sample_buf, SPECTRAL_HT20_NUM_BINS);\n\n\tath_dbg(common, SPECTRAL_SCAN, \"FFT HT20 frame: max mag 0x%X,\"\n\t\t\t\t\t\"max_mag_idx %i\\n\",\n\t\t\t\t\tmagnitude >> max_exp,\n\t\t\t\t\tmax_index);\n\n\tif ((fft_sample_20.data[max_index] & 0xf8) !=\n\t    ((magnitude >> max_exp) & 0xf8)) {\n\t\tath_dbg(common, SPECTRAL_SCAN, \"Magnitude mismatch !\\n\");\n\t\tret = -1;\n\t}\n\n\t \n\tfft_sample_20.data[dc_pos] = (fft_sample_20.data[dc_pos + 1] +\n\t\t\t\t\tfft_sample_20.data[dc_pos - 1]) / 2;\n\n\t \n\tif (max_index == dc_pos) {\n\t\ttmp_mag = 0;\n\t\tfor (i = 0; i < dc_pos; i++) {\n\t\t\tif (fft_sample_20.data[i] > tmp_mag) {\n\t\t\t\ttmp_mag = fft_sample_20.data[i];\n\t\t\t\tfft_sample_20.max_index = i;\n\t\t\t}\n\t\t}\n\n\t\tmagnitude = tmp_mag << max_exp;\n\t\tfft_sample_20.max_magnitude = __cpu_to_be16(magnitude);\n\n\t\tath_dbg(common, SPECTRAL_SCAN,\n\t\t\t\"Calculated new lower max 0x%X at %i\\n\",\n\t\t\ttmp_mag, fft_sample_20.max_index);\n\t} else\n\tfor (i = 0; i < SPECTRAL_HT20_NUM_BINS; i++) {\n\t\tif (fft_sample_20.data[i] == (magnitude >> max_exp))\n\t\t\tath_dbg(common, SPECTRAL_SCAN,\n\t\t\t\t\"Got max: 0x%X at index %i\\n\",\n\t\t\t\tfft_sample_20.data[i], i);\n\n\t\tif (fft_sample_20.data[i] > (magnitude >> max_exp)) {\n\t\t\tath_dbg(common, SPECTRAL_SCAN,\n\t\t\t\t\"Got bin %i greater than max: 0x%X\\n\",\n\t\t\t\ti, fft_sample_20.data[i]);\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttlv = (struct fft_sample_tlv *)&fft_sample_20;\n\n\tath_debug_send_fft_sample(spec_priv, tlv);\n\n\treturn 0;\n}\n\nstatic int\nath_cmn_process_ht20_40_fft(struct ath_rx_status *rs,\n\t\t\tstruct ath_spec_scan_priv *spec_priv,\n\t\t\tu8 *sample_buf,\n\t\t\tu64 tsf, u16 freq, int chan_type)\n{\n\tstruct fft_sample_ht20_40 fft_sample_40;\n\tstruct ath_common *common = ath9k_hw_common(spec_priv->ah);\n\tstruct ath_hw *ah = spec_priv->ah;\n\tstruct ath9k_hw_cal_data *caldata = ah->caldata;\n\tstruct ath_ht20_40_mag_info *mag_info;\n\tstruct fft_sample_tlv *tlv;\n\tint dc_pos = SPECTRAL_HT20_40_NUM_BINS / 2;\n\tint i = 0;\n\tint ret = 0;\n\ts16 ext_nf;\n\tu16 lower_mag, upper_mag, tmp_mag, length;\n\ts8 lower_rssi, upper_rssi;\n\tu8 lower_max_index, upper_max_index;\n\tu8 lower_bitmap_w, upper_bitmap_w, max_exp;\n\n\tif (caldata)\n\t\text_nf = ath9k_hw_getchan_noise(ah, ah->curchan,\n\t\t\t\tcaldata->nfCalHist[3].privNF);\n\telse\n\t\text_nf = ATH_DEFAULT_NOISE_FLOOR;\n\n\tlength = sizeof(fft_sample_40) - sizeof(struct fft_sample_tlv);\n\tfft_sample_40.tlv.type = ATH_FFT_SAMPLE_HT20_40;\n\tfft_sample_40.tlv.length = __cpu_to_be16(length);\n\tfft_sample_40.freq = __cpu_to_be16(freq);\n\tfft_sample_40.channel_type = chan_type;\n\n\tif (chan_type == NL80211_CHAN_HT40PLUS) {\n\t\tlower_rssi = fix_rssi_inv_only(rs->rs_rssi_ctl[0]);\n\t\tupper_rssi = fix_rssi_inv_only(rs->rs_rssi_ext[0]);\n\n\t\tfft_sample_40.lower_noise = ah->noise;\n\t\tfft_sample_40.upper_noise = ext_nf;\n\t} else {\n\t\tlower_rssi = fix_rssi_inv_only(rs->rs_rssi_ext[0]);\n\t\tupper_rssi = fix_rssi_inv_only(rs->rs_rssi_ctl[0]);\n\n\t\tfft_sample_40.lower_noise = ext_nf;\n\t\tfft_sample_40.upper_noise = ah->noise;\n\t}\n\n\tfft_sample_40.lower_rssi = lower_rssi;\n\tfft_sample_40.upper_rssi = upper_rssi;\n\n\tmag_info = (struct ath_ht20_40_mag_info *) (sample_buf +\n\t\t\t\t\tSPECTRAL_HT20_40_NUM_BINS);\n\n\tlower_mag = spectral_max_magnitude(mag_info->lower_bins);\n\tfft_sample_40.lower_max_magnitude = __cpu_to_be16(lower_mag);\n\n\tupper_mag = spectral_max_magnitude(mag_info->upper_bins);\n\tfft_sample_40.upper_max_magnitude = __cpu_to_be16(upper_mag);\n\n\tlower_max_index = spectral_max_index_ht40(mag_info->lower_bins);\n\tfft_sample_40.lower_max_index = lower_max_index;\n\n\tupper_max_index = spectral_max_index_ht40(mag_info->upper_bins);\n\tfft_sample_40.upper_max_index = upper_max_index;\n\n\tlower_bitmap_w = spectral_bitmap_weight(mag_info->lower_bins);\n\tfft_sample_40.lower_bitmap_weight = lower_bitmap_w;\n\n\tupper_bitmap_w = spectral_bitmap_weight(mag_info->upper_bins);\n\tfft_sample_40.upper_bitmap_weight = upper_bitmap_w;\n\n\tmax_exp = mag_info->max_exp & 0xf;\n\tfft_sample_40.max_exp = max_exp;\n\n\tfft_sample_40.tsf = __cpu_to_be64(tsf);\n\n\tmemcpy(fft_sample_40.data, sample_buf, SPECTRAL_HT20_40_NUM_BINS);\n\n\tath_dbg(common, SPECTRAL_SCAN, \"FFT HT20/40 frame: lower mag 0x%X,\"\n\t\t\t\t\t\"lower_mag_idx %i, upper mag 0x%X,\"\n\t\t\t\t\t\"upper_mag_idx %i\\n\",\n\t\t\t\t\tlower_mag >> max_exp,\n\t\t\t\t\tlower_max_index,\n\t\t\t\t\tupper_mag >> max_exp,\n\t\t\t\t\tupper_max_index);\n\n\t \n\tif (((fft_sample_40.data[upper_max_index + dc_pos] & 0xf8)\n\t    != ((upper_mag >> max_exp) & 0xf8)) ||\n\t   ((fft_sample_40.data[lower_max_index] & 0xf8)\n\t    != ((lower_mag >> max_exp) & 0xf8))) {\n\t\tath_dbg(common, SPECTRAL_SCAN, \"Magnitude mismatch !\\n\");\n\t\tret = -1;\n\t}\n\n\t \n\tfft_sample_40.data[dc_pos] = (fft_sample_40.data[dc_pos + 1] +\n\t\t\t\t\tfft_sample_40.data[dc_pos - 1]) / 2;\n\n\t \n\tif (lower_max_index == dc_pos) {\n\t\ttmp_mag = 0;\n\t\tfor (i = 0; i < dc_pos; i++) {\n\t\t\tif (fft_sample_40.data[i] > tmp_mag) {\n\t\t\t\ttmp_mag = fft_sample_40.data[i];\n\t\t\t\tfft_sample_40.lower_max_index = i;\n\t\t\t}\n\t\t}\n\n\t\tlower_mag = tmp_mag << max_exp;\n\t\tfft_sample_40.lower_max_magnitude = __cpu_to_be16(lower_mag);\n\n\t\tath_dbg(common, SPECTRAL_SCAN,\n\t\t\t\"Calculated new lower max 0x%X at %i\\n\",\n\t\t\ttmp_mag, fft_sample_40.lower_max_index);\n\t} else\n\tfor (i = 0; i < dc_pos; i++) {\n\t\tif (fft_sample_40.data[i] == (lower_mag >> max_exp))\n\t\t\tath_dbg(common, SPECTRAL_SCAN,\n\t\t\t\t\"Got lower mag: 0x%X at index %i\\n\",\n\t\t\t\tfft_sample_40.data[i], i);\n\n\t\tif (fft_sample_40.data[i] > (lower_mag >> max_exp)) {\n\t\t\tath_dbg(common, SPECTRAL_SCAN,\n\t\t\t\t\"Got lower bin %i higher than max: 0x%X\\n\",\n\t\t\t\ti, fft_sample_40.data[i]);\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\tif (upper_max_index == dc_pos) {\n\t\ttmp_mag = 0;\n\t\tfor (i = dc_pos; i < SPECTRAL_HT20_40_NUM_BINS; i++) {\n\t\t\tif (fft_sample_40.data[i] > tmp_mag) {\n\t\t\t\ttmp_mag = fft_sample_40.data[i];\n\t\t\t\tfft_sample_40.upper_max_index = i;\n\t\t\t}\n\t\t}\n\t\tupper_mag = tmp_mag << max_exp;\n\t\tfft_sample_40.upper_max_magnitude = __cpu_to_be16(upper_mag);\n\n\t\tath_dbg(common, SPECTRAL_SCAN,\n\t\t\t\"Calculated new upper max 0x%X at %i\\n\",\n\t\t\ttmp_mag, fft_sample_40.upper_max_index);\n\t} else\n\tfor (i = dc_pos; i < SPECTRAL_HT20_40_NUM_BINS; i++) {\n\t\tif (fft_sample_40.data[i] == (upper_mag >> max_exp))\n\t\t\tath_dbg(common, SPECTRAL_SCAN,\n\t\t\t\t\"Got upper mag: 0x%X at index %i\\n\",\n\t\t\t\tfft_sample_40.data[i], i);\n\n\t\tif (fft_sample_40.data[i] > (upper_mag >> max_exp)) {\n\t\t\tath_dbg(common, SPECTRAL_SCAN,\n\t\t\t\t\"Got upper bin %i higher than max: 0x%X\\n\",\n\t\t\t\ti, fft_sample_40.data[i]);\n\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttlv = (struct fft_sample_tlv *)&fft_sample_40;\n\n\tath_debug_send_fft_sample(spec_priv, tlv);\n\n\treturn 0;\n}\n\nstatic inline void\nath_cmn_copy_fft_frame(u8 *in, u8 *out, int sample_len, int sample_bytes)\n{\n\tswitch (sample_bytes - sample_len) {\n\tcase -1:\n\t\t \n\t\tmemcpy(&out[1], in,\n\t\t       sample_len - 1);\n\t\tbreak;\n\tcase 0:\n\t\t \n\t\tmemcpy(out, in, sample_len);\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tmemcpy(&out[1], in, 30);\n\t\tout[31] = in[31];\n\t\tmemcpy(&out[32], &in[33],\n\t\t       sample_len - 32);\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tmemcpy(out, in, 30);\n\t\tout[30] = in[31];\n\t\tmemcpy(&out[31], &in[33],\n\t\t       sample_len - 31);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int\nath_cmn_is_fft_buf_full(struct ath_spec_scan_priv *spec_priv)\n{\n\tint i = 0;\n\tint ret = 0;\n\tstruct rchan_buf *buf;\n\tstruct rchan *rc = spec_priv->rfs_chan_spec_scan;\n\n\tfor_each_possible_cpu(i) {\n\t\tif ((buf = *per_cpu_ptr(rc->buf, i))) {\n\t\t\tret += relay_buf_full(buf);\n\t\t}\n\t}\n\n\tif (ret)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n \nint ath_cmn_process_fft(struct ath_spec_scan_priv *spec_priv, struct ieee80211_hdr *hdr,\n\t\t    struct ath_rx_status *rs, u64 tsf)\n{\n\tu8 sample_buf[SPECTRAL_SAMPLE_MAX_LEN] = {0};\n\tstruct ath_hw *ah = spec_priv->ah;\n\tstruct ath_common *common = ath9k_hw_common(spec_priv->ah);\n\tstruct ath_softc *sc = (struct ath_softc *)common->priv;\n\tu8 num_bins, *vdata = (u8 *)hdr;\n\tstruct ath_radar_info *radar_info;\n\tint len = rs->rs_datalen;\n\tint i;\n\tint got_slen = 0;\n\tu8  *sample_start;\n\tint sample_bytes = 0;\n\tint ret = 0;\n\tu16 fft_len, sample_len, freq = ah->curchan->chan->center_freq;\n\tenum nl80211_channel_type chan_type;\n\tath_cmn_fft_idx_validator *fft_idx_validator;\n\tath_cmn_fft_sample_handler *fft_handler;\n\n\t \n\tif (rs->rs_phyerr != ATH9K_PHYERR_RADAR &&\n\t    rs->rs_phyerr != ATH9K_PHYERR_FALSE_RADAR_EXT &&\n\t    rs->rs_phyerr != ATH9K_PHYERR_SPECTRAL)\n\t\treturn 0;\n\n\t \n\tradar_info = ((struct ath_radar_info *)&vdata[len]) - 1;\n\tif (!(radar_info->pulse_bw_info & SPECTRAL_SCAN_BITMASK))\n\t\treturn 0;\n\n\tif (!spec_priv->rfs_chan_spec_scan)\n\t\treturn 1;\n\n\t \n\tret = ath_cmn_is_fft_buf_full(spec_priv);\n\tif (ret == 1) {\n\t\tath_dbg(common, SPECTRAL_SCAN, \"FFT report ignored, no space \"\n\t\t\t\t\t\t\"left on output buffers\\n\");\n\t\treturn 1;\n\t}\n\n\tchan_type = cfg80211_get_chandef_type(&common->hw->conf.chandef);\n\tif ((chan_type == NL80211_CHAN_HT40MINUS) ||\n\t    (chan_type == NL80211_CHAN_HT40PLUS)) {\n\t\tfft_len = SPECTRAL_HT20_40_TOTAL_DATA_LEN;\n\t\tsample_len = SPECTRAL_HT20_40_SAMPLE_LEN;\n\t\tnum_bins = SPECTRAL_HT20_40_NUM_BINS;\n\t\tfft_idx_validator = &ath_cmn_max_idx_verify_ht20_40_fft;\n\t\tfft_handler = &ath_cmn_process_ht20_40_fft;\n\t} else {\n\t\tfft_len = SPECTRAL_HT20_TOTAL_DATA_LEN;\n\t\tsample_len = SPECTRAL_HT20_SAMPLE_LEN;\n\t\tnum_bins = SPECTRAL_HT20_NUM_BINS;\n\t\tfft_idx_validator = ath_cmn_max_idx_verify_ht20_fft;\n\t\tfft_handler = &ath_cmn_process_ht20_fft;\n\t}\n\n\tath_dbg(common, SPECTRAL_SCAN, \"Got radar dump bw_info: 0x%X,\"\n\t\t\t\t\t\"len: %i fft_len: %i\\n\",\n\t\t\t\t\tradar_info->pulse_bw_info,\n\t\t\t\t\tlen,\n\t\t\t\t\tfft_len);\n\tsample_start = vdata;\n\tfor (i = 0; i < len - 2; i++) {\n\t\tsample_bytes++;\n\n\t\t \n\t\tif (len <= fft_len + 2) {\n\t\t\tsample_bytes = len - sizeof(struct ath_radar_info);\n\t\t\tgot_slen = 1;\n\t\t}\n\n\t\t \n\t\tif (vdata[i] <= 0x7 && sample_bytes >= sample_len - 1) {\n\n\t\t\t \n\n\t\t\t \n\t\t\tif ((sample_bytes > sample_len + 2) ||\n\t\t\t   ((sample_bytes > sample_len) &&\n\t\t\t   (sample_start[31] != sample_start[32])))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (!fft_idx_validator(&vdata[i], i)) {\n\t\t\t\tath_dbg(common, SPECTRAL_SCAN,\n\t\t\t\t\t\"Found valid fft frame at %i\\n\", i);\n\t\t\t\tgot_slen = 1;\n\t\t\t}\n\n\t\t\t \n\t\t\telse if ((sample_start[31] == sample_start[32]) &&\n\t\t\t\t(sample_bytes >= sample_len) &&\n\t\t\t\t(sample_bytes < sample_len + 2) &&\n\t\t\t\t(vdata[i + 1] <= 0x7))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\telse if ((sample_bytes == sample_len - 1) &&\n\t\t\t\t(vdata[i + 1] <= 0x7))\n\t\t\t\tcontinue;\n\n\t\t\tgot_slen = 1;\n\t\t}\n\n\t\tif (got_slen) {\n\t\t\tath_dbg(common, SPECTRAL_SCAN, \"FFT frame len: %i\\n\",\n\t\t\t\tsample_bytes);\n\n\t\t\t \n\t\t\tif (sample_bytes != sample_len && len <= fft_len + 2) {\n\t\t\t\tath_cmn_copy_fft_frame(sample_start,\n\t\t\t\t\t\t       sample_buf, sample_len,\n\t\t\t\t\t\t       sample_bytes);\n\n\t\t\t\tret = fft_handler(rs, spec_priv, sample_buf,\n\t\t\t\t\t\t  tsf, freq, chan_type);\n\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tRX_STAT_INC(sc, rx_spectral_sample_good);\n\t\t\t\telse\n\t\t\t\t\tRX_STAT_INC(sc, rx_spectral_sample_err);\n\n\t\t\t\tmemset(sample_buf, 0, SPECTRAL_SAMPLE_MAX_LEN);\n\n\t\t\t\t \n\t\t\t\tadd_device_randomness(sample_buf, num_bins);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (sample_bytes == sample_len) {\n\t\t\t\tret = fft_handler(rs, spec_priv, sample_start,\n\t\t\t\t\t\t  tsf, freq, chan_type);\n\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tRX_STAT_INC(sc, rx_spectral_sample_good);\n\t\t\t\telse\n\t\t\t\t\tRX_STAT_INC(sc, rx_spectral_sample_err);\n\n\t\t\t\t \n\t\t\t\tadd_device_randomness(sample_start, num_bins);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (len <= fft_len + 2)\n\t\t\t\treturn 1;\n\n\t\t\tsample_start = &vdata[i + 1];\n\n\t\t\t \n\t\t\tif (ret == 0) {\n\t\t\t\ti += num_bins - 2;\n\t\t\t\tsample_bytes = num_bins - 2;\n\t\t\t}\n\t\t\tgot_slen = 0;\n\t\t}\n\t}\n\n\ti -= num_bins - 2;\n\tif (len - i != sizeof(struct ath_radar_info))\n\t\tath_dbg(common, SPECTRAL_SCAN, \"FFT report truncated\"\n\t\t\t\t\t\t\"(bytes left: %i)\\n\",\n\t\t\t\t\t\tlen - i);\n\treturn 1;\n}\nEXPORT_SYMBOL(ath_cmn_process_fft);\n\n \n \n \n\nstatic ssize_t read_file_spec_scan_ctl(struct file *file, char __user *user_buf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct ath_spec_scan_priv *spec_priv = file->private_data;\n\tchar *mode = \"\";\n\tunsigned int len;\n\n\tswitch (spec_priv->spectral_mode) {\n\tcase SPECTRAL_DISABLED:\n\t\tmode = \"disable\";\n\t\tbreak;\n\tcase SPECTRAL_BACKGROUND:\n\t\tmode = \"background\";\n\t\tbreak;\n\tcase SPECTRAL_CHANSCAN:\n\t\tmode = \"chanscan\";\n\t\tbreak;\n\tcase SPECTRAL_MANUAL:\n\t\tmode = \"manual\";\n\t\tbreak;\n\t}\n\tlen = strlen(mode);\n\treturn simple_read_from_buffer(user_buf, count, ppos, mode, len);\n}\n\nvoid ath9k_cmn_spectral_scan_trigger(struct ath_common *common,\n\t\t\t\t struct ath_spec_scan_priv *spec_priv)\n{\n\tstruct ath_hw *ah = spec_priv->ah;\n\tu32 rxfilter;\n\n\tif (IS_ENABLED(CONFIG_ATH9K_TX99))\n\t\treturn;\n\n\tif (!ath9k_hw_ops(ah)->spectral_scan_trigger) {\n\t\tath_err(common, \"spectrum analyzer not implemented on this hardware\\n\");\n\t\treturn;\n\t}\n\n\tif (!spec_priv->spec_config.enabled)\n\t\treturn;\n\n\tath_ps_ops(common)->wakeup(common);\n\trxfilter = ath9k_hw_getrxfilter(ah);\n\tath9k_hw_setrxfilter(ah, rxfilter |\n\t\t\t\t ATH9K_RX_FILTER_PHYRADAR |\n\t\t\t\t ATH9K_RX_FILTER_PHYERR);\n\n\t \n\tath9k_cmn_spectral_scan_config(common, spec_priv, spec_priv->spectral_mode);\n\tath9k_hw_ops(ah)->spectral_scan_trigger(ah);\n\tath_ps_ops(common)->restore(common);\n}\nEXPORT_SYMBOL(ath9k_cmn_spectral_scan_trigger);\n\nint ath9k_cmn_spectral_scan_config(struct ath_common *common,\n\t\t\t       struct ath_spec_scan_priv *spec_priv,\n\t\t\t       enum spectral_mode spectral_mode)\n{\n\tstruct ath_hw *ah = spec_priv->ah;\n\n\tif (!ath9k_hw_ops(ah)->spectral_scan_trigger) {\n\t\tath_err(common, \"spectrum analyzer not implemented on this hardware\\n\");\n\t\treturn -1;\n\t}\n\n\tswitch (spectral_mode) {\n\tcase SPECTRAL_DISABLED:\n\t\tspec_priv->spec_config.enabled = 0;\n\t\tbreak;\n\tcase SPECTRAL_BACKGROUND:\n\t\t \n\t\tspec_priv->spec_config.endless = 1;\n\t\tspec_priv->spec_config.enabled = 1;\n\t\tbreak;\n\tcase SPECTRAL_CHANSCAN:\n\tcase SPECTRAL_MANUAL:\n\t\tspec_priv->spec_config.endless = 0;\n\t\tspec_priv->spec_config.enabled = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\tath_ps_ops(common)->wakeup(common);\n\tath9k_hw_ops(ah)->spectral_scan_config(ah, &spec_priv->spec_config);\n\tath_ps_ops(common)->restore(common);\n\n\tspec_priv->spectral_mode = spectral_mode;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ath9k_cmn_spectral_scan_config);\n\nstatic ssize_t write_file_spec_scan_ctl(struct file *file,\n\t\t\t\t\tconst char __user *user_buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ath_spec_scan_priv *spec_priv = file->private_data;\n\tstruct ath_common *common = ath9k_hw_common(spec_priv->ah);\n\tchar buf[32];\n\tssize_t len;\n\n\tif (IS_ENABLED(CONFIG_ATH9K_TX99))\n\t\treturn -EOPNOTSUPP;\n\n\tlen = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, len))\n\t\treturn -EFAULT;\n\n\tbuf[len] = '\\0';\n\n\tif (strncmp(\"trigger\", buf, 7) == 0) {\n\t\tath9k_cmn_spectral_scan_trigger(common, spec_priv);\n\t} else if (strncmp(\"background\", buf, 10) == 0) {\n\t\tath9k_cmn_spectral_scan_config(common, spec_priv, SPECTRAL_BACKGROUND);\n\t\tath_dbg(common, CONFIG, \"spectral scan: background mode enabled\\n\");\n\t} else if (strncmp(\"chanscan\", buf, 8) == 0) {\n\t\tath9k_cmn_spectral_scan_config(common, spec_priv, SPECTRAL_CHANSCAN);\n\t\tath_dbg(common, CONFIG, \"spectral scan: channel scan mode enabled\\n\");\n\t} else if (strncmp(\"manual\", buf, 6) == 0) {\n\t\tath9k_cmn_spectral_scan_config(common, spec_priv, SPECTRAL_MANUAL);\n\t\tath_dbg(common, CONFIG, \"spectral scan: manual mode enabled\\n\");\n\t} else if (strncmp(\"disable\", buf, 7) == 0) {\n\t\tath9k_cmn_spectral_scan_config(common, spec_priv, SPECTRAL_DISABLED);\n\t\tath_dbg(common, CONFIG, \"spectral scan: disabled\\n\");\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_spec_scan_ctl = {\n\t.read = read_file_spec_scan_ctl,\n\t.write = write_file_spec_scan_ctl,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\n \n \n \n\nstatic ssize_t read_file_spectral_short_repeat(struct file *file,\n\t\t\t\t\t       char __user *user_buf,\n\t\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct ath_spec_scan_priv *spec_priv = file->private_data;\n\tchar buf[32];\n\tunsigned int len;\n\n\tlen = sprintf(buf, \"%d\\n\", spec_priv->spec_config.short_repeat);\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t write_file_spectral_short_repeat(struct file *file,\n\t\t\t\t\t\tconst char __user *user_buf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ath_spec_scan_priv *spec_priv = file->private_data;\n\tunsigned long val;\n\tssize_t ret;\n\n\tret = kstrtoul_from_user(user_buf, count, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tspec_priv->spec_config.short_repeat = val;\n\treturn count;\n}\n\nstatic const struct file_operations fops_spectral_short_repeat = {\n\t.read = read_file_spectral_short_repeat,\n\t.write = write_file_spectral_short_repeat,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\n \n \n \n\nstatic ssize_t read_file_spectral_count(struct file *file,\n\t\t\t\t\tchar __user *user_buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ath_spec_scan_priv *spec_priv = file->private_data;\n\tchar buf[32];\n\tunsigned int len;\n\n\tlen = sprintf(buf, \"%d\\n\", spec_priv->spec_config.count);\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t write_file_spectral_count(struct file *file,\n\t\t\t\t\t const char __user *user_buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ath_spec_scan_priv *spec_priv = file->private_data;\n\tunsigned long val;\n\tssize_t ret;\n\n\tret = kstrtoul_from_user(user_buf, count, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\tif (val > 255)\n\t\treturn -EINVAL;\n\n\tspec_priv->spec_config.count = val;\n\treturn count;\n}\n\nstatic const struct file_operations fops_spectral_count = {\n\t.read = read_file_spectral_count,\n\t.write = write_file_spectral_count,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\n \n \n \n\nstatic ssize_t read_file_spectral_period(struct file *file,\n\t\t\t\t\t char __user *user_buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ath_spec_scan_priv *spec_priv = file->private_data;\n\tchar buf[32];\n\tunsigned int len;\n\n\tlen = sprintf(buf, \"%d\\n\", spec_priv->spec_config.period);\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t write_file_spectral_period(struct file *file,\n\t\t\t\t\t  const char __user *user_buf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct ath_spec_scan_priv *spec_priv = file->private_data;\n\tunsigned long val;\n\tssize_t ret;\n\n\tret = kstrtoul_from_user(user_buf, count, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val > 255)\n\t\treturn -EINVAL;\n\n\tspec_priv->spec_config.period = val;\n\treturn count;\n}\n\nstatic const struct file_operations fops_spectral_period = {\n\t.read = read_file_spectral_period,\n\t.write = write_file_spectral_period,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\n \n \n \n\nstatic ssize_t read_file_spectral_fft_period(struct file *file,\n\t\t\t\t\t     char __user *user_buf,\n\t\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct ath_spec_scan_priv *spec_priv = file->private_data;\n\tchar buf[32];\n\tunsigned int len;\n\n\tlen = sprintf(buf, \"%d\\n\", spec_priv->spec_config.fft_period);\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t write_file_spectral_fft_period(struct file *file,\n\t\t\t\t\t      const char __user *user_buf,\n\t\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ath_spec_scan_priv *spec_priv = file->private_data;\n\tunsigned long val;\n\tssize_t ret;\n\n\tret = kstrtoul_from_user(user_buf, count, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val > 15)\n\t\treturn -EINVAL;\n\n\tspec_priv->spec_config.fft_period = val;\n\treturn count;\n}\n\nstatic const struct file_operations fops_spectral_fft_period = {\n\t.read = read_file_spectral_fft_period,\n\t.write = write_file_spectral_fft_period,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\n \n \n \n\nstatic struct dentry *create_buf_file_handler(const char *filename,\n\t\t\t\t\t      struct dentry *parent,\n\t\t\t\t\t      umode_t mode,\n\t\t\t\t\t      struct rchan_buf *buf,\n\t\t\t\t\t      int *is_global)\n{\n\tstruct dentry *buf_file;\n\n\tbuf_file = debugfs_create_file(filename, mode, parent, buf,\n\t\t\t\t       &relay_file_operations);\n\tif (IS_ERR(buf_file))\n\t\treturn NULL;\n\n\t*is_global = 1;\n\treturn buf_file;\n}\n\nstatic int remove_buf_file_handler(struct dentry *dentry)\n{\n\tdebugfs_remove(dentry);\n\n\treturn 0;\n}\n\nstatic const struct rchan_callbacks rfs_spec_scan_cb = {\n\t.create_buf_file = create_buf_file_handler,\n\t.remove_buf_file = remove_buf_file_handler,\n};\n\n \n \n \n\nvoid ath9k_cmn_spectral_deinit_debug(struct ath_spec_scan_priv *spec_priv)\n{\n\tif (spec_priv->rfs_chan_spec_scan) {\n\t\trelay_close(spec_priv->rfs_chan_spec_scan);\n\t\tspec_priv->rfs_chan_spec_scan = NULL;\n\t}\n}\nEXPORT_SYMBOL(ath9k_cmn_spectral_deinit_debug);\n\nvoid ath9k_cmn_spectral_init_debug(struct ath_spec_scan_priv *spec_priv,\n\t\t\t\t   struct dentry *debugfs_phy)\n{\n\tspec_priv->rfs_chan_spec_scan = relay_open(\"spectral_scan\",\n\t\t\t\t\t    debugfs_phy,\n\t\t\t\t\t    1024, 256, &rfs_spec_scan_cb,\n\t\t\t\t\t    NULL);\n\tif (!spec_priv->rfs_chan_spec_scan)\n\t\treturn;\n\n\tdebugfs_create_file(\"spectral_scan_ctl\",\n\t\t\t    0600,\n\t\t\t    debugfs_phy, spec_priv,\n\t\t\t    &fops_spec_scan_ctl);\n\tdebugfs_create_file(\"spectral_short_repeat\",\n\t\t\t    0600,\n\t\t\t    debugfs_phy, spec_priv,\n\t\t\t    &fops_spectral_short_repeat);\n\tdebugfs_create_file(\"spectral_count\",\n\t\t\t    0600,\n\t\t\t    debugfs_phy, spec_priv,\n\t\t\t    &fops_spectral_count);\n\tdebugfs_create_file(\"spectral_period\",\n\t\t\t    0600,\n\t\t\t    debugfs_phy, spec_priv,\n\t\t\t    &fops_spectral_period);\n\tdebugfs_create_file(\"spectral_fft_period\",\n\t\t\t    0600,\n\t\t\t    debugfs_phy, spec_priv,\n\t\t\t    &fops_spectral_fft_period);\n}\nEXPORT_SYMBOL(ath9k_cmn_spectral_init_debug);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}