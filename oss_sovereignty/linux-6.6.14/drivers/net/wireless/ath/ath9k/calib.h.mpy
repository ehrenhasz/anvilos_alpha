{
  "module_name": "calib.h",
  "hash_id": "bc94e3c5265c76d6e97e39030dc0d5611771bd3ca016642c9c12c7dd3819c9cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/calib.h",
  "human_readable_source": " \n\n#ifndef CALIB_H\n#define CALIB_H\n\n#include \"hw.h\"\n\n#define AR_PHY_CCA_FILTERWINDOW_LENGTH          5\n\n \n#define ATH9K_NF_CAL_NOISE_THRESH\t\t6\n\n#define NUM_NF_READINGS       6\n#define ATH9K_NF_CAL_HIST_MAX 5\n\nstruct ar5416IniArray {\n\tu32 *ia_array;\n\tu32 ia_rows;\n\tu32 ia_columns;\n};\n\n#define STATIC_INI_ARRAY(array) {\t\t\t\\\n\t\t.ia_array = (u32 *)(array),\t\t\\\n\t\t.ia_rows = ARRAY_SIZE(array),\t\t\\\n\t\t.ia_columns = ARRAY_SIZE(array[0]),\t\\\n\t}\n\n#define INIT_INI_ARRAY(iniarray, array) do {\t\\\n\t\t(iniarray)->ia_array = (u32 *)(array);\t\t\\\n\t\t(iniarray)->ia_rows = ARRAY_SIZE(array);\t\\\n\t\t(iniarray)->ia_columns = ARRAY_SIZE(array[0]);\t\\\n\t} while (0)\n\n#define INI_RA(iniarray, row, column) \\\n\t(((iniarray)->ia_array)[(row) *\t((iniarray)->ia_columns) + (column)])\n\n#define INIT_CAL(_perCal) do {\t\t\t\t\\\n\t\t(_perCal)->calState = CAL_WAITING;\t\\\n\t\t(_perCal)->calNext = NULL;\t\t\\\n\t} while (0)\n\n#define INSERT_CAL(_ahp, _perCal)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif ((_ahp)->cal_list_last == NULL) {\t\t\t\\\n\t\t\t(_ahp)->cal_list =\t\t\t\t\\\n\t\t\t\t(_ahp)->cal_list_last = (_perCal);\t\\\n\t\t\t((_ahp)->cal_list_last)->calNext = (_perCal); \\\n\t\t} else {\t\t\t\t\t\t\\\n\t\t\t((_ahp)->cal_list_last)->calNext = (_perCal); \\\n\t\t\t(_ahp)->cal_list_last = (_perCal);\t\t\\\n\t\t\t(_perCal)->calNext = (_ahp)->cal_list;\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\nenum ath9k_cal_state {\n\tCAL_INACTIVE,\n\tCAL_WAITING,\n\tCAL_RUNNING,\n\tCAL_DONE\n};\n\n#define MIN_CAL_SAMPLES     1\n#define MAX_CAL_SAMPLES    64\n#define INIT_LOG_COUNT      5\n#define PER_MIN_LOG_COUNT   2\n#define PER_MAX_LOG_COUNT  10\n\nstruct ath9k_percal_data {\n\tu32 calType;\n\tu32 calNumSamples;\n\tu32 calCountMax;\n\tvoid (*calCollect) (struct ath_hw *);\n\tvoid (*calPostProc) (struct ath_hw *, u8);\n};\n\nstruct ath9k_cal_list {\n\tconst struct ath9k_percal_data *calData;\n\tenum ath9k_cal_state calState;\n\tstruct ath9k_cal_list *calNext;\n};\n\nstruct ath9k_nfcal_hist {\n\tint16_t nfCalBuffer[ATH9K_NF_CAL_HIST_MAX];\n\tu8 currIndex;\n\tint16_t privNF;\n\tu8 invalidNFcount;\n};\n\n#define MAX_PACAL_SKIPCOUNT 8\nstruct ath9k_pacal_info{\n\tint32_t prev_offset;\t \n\tint8_t max_skipcount;\t \n\tint8_t skipcount;\t \n};\n\nbool ath9k_hw_reset_calvalid(struct ath_hw *ah);\nvoid ath9k_hw_start_nfcal(struct ath_hw *ah, bool update);\nint ath9k_hw_loadnf(struct ath_hw *ah, struct ath9k_channel *chan);\nbool ath9k_hw_getnf(struct ath_hw *ah, struct ath9k_channel *chan);\nvoid ath9k_init_nfcal_hist_buffer(struct ath_hw *ah,\n\t\t\t\t  struct ath9k_channel *chan);\nvoid ath9k_hw_bstuck_nfcal(struct ath_hw *ah);\nvoid ath9k_hw_reset_calibration(struct ath_hw *ah,\n\t\t\t\tstruct ath9k_cal_list *currCal);\ns16 ath9k_hw_getchan_noise(struct ath_hw *ah, struct ath9k_channel *chan,\n\t\t\t   s16 nf);\n\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}