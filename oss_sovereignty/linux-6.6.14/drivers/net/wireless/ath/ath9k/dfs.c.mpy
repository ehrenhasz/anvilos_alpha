{
  "module_name": "dfs.c",
  "hash_id": "24b44d907f1ddeaf02280558c7c563a0e3e84882696d8c278076be898e098940",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/dfs.c",
  "human_readable_source": " \n\n#include \"hw.h\"\n#include \"hw-ops.h\"\n#include \"ath9k.h\"\n#include \"dfs.h\"\n#include \"dfs_debug.h\"\n\n \nstruct ath_radar_data {\n\tu8 pulse_bw_info;\n\tu8 rssi;\n\tu8 ext_rssi;\n\tu8 pulse_length_ext;\n\tu8 pulse_length_pri;\n};\n\n \n\n \nstatic const int BIN_DELTA_MIN\t\t= 1;\nstatic const int BIN_DELTA_MAX\t\t= 10;\n\n \n#define NUM_DIFFS 3\n#define FFT_NUM_SAMPLES\t\t(NUM_DIFFS + 1)\n\n \nstatic const int MAX_DIFF\t\t= 2;\n\n \nstatic const int MIN_CHIRP_PULSE_WIDTH\t= 20;\nstatic const int MAX_CHIRP_PULSE_WIDTH\t= 110;\n\nstruct ath9k_dfs_fft_20 {\n\tu8 bin[28];\n\tu8 lower_bins[3];\n} __packed;\nstruct ath9k_dfs_fft_40 {\n\tu8 bin[64];\n\tu8 lower_bins[3];\n\tu8 upper_bins[3];\n} __packed;\n\nstatic inline int fft_max_index(u8 *bins)\n{\n\treturn (bins[2] & 0xfc) >> 2;\n}\nstatic inline int fft_max_magnitude(u8 *bins)\n{\n\treturn (bins[0] & 0xc0) >> 6 | bins[1] << 2 | (bins[2] & 0x03) << 10;\n}\nstatic inline u8 fft_bitmap_weight(u8 *bins)\n{\n\treturn bins[0] & 0x3f;\n}\n\nstatic int ath9k_get_max_index_ht40(struct ath9k_dfs_fft_40 *fft,\n\t\t\t\t    bool is_ctl, bool is_ext)\n{\n\tconst int DFS_UPPER_BIN_OFFSET = 64;\n\t \n\tif (is_ctl && is_ext) {\n\t\t \n\t\tis_ctl = fft_bitmap_weight(fft->lower_bins) != 0;\n\t\tis_ext = fft_bitmap_weight(fft->upper_bins) != 0;\n\n\t\t \n\t\tif (is_ctl && is_ext) {\n\t\t\tint mag_lower = fft_max_magnitude(fft->lower_bins);\n\t\t\tint mag_upper = fft_max_magnitude(fft->upper_bins);\n\t\t\tif (mag_upper > mag_lower)\n\t\t\t\tis_ctl = false;\n\t\t\telse\n\t\t\t\tis_ext = false;\n\t\t}\n\t}\n\tif (is_ctl)\n\t\treturn fft_max_index(fft->lower_bins);\n\treturn fft_max_index(fft->upper_bins) + DFS_UPPER_BIN_OFFSET;\n}\nstatic bool ath9k_check_chirping(struct ath_softc *sc, u8 *data,\n\t\t\t\t int datalen, bool is_ctl, bool is_ext)\n{\n\tint i;\n\tint max_bin[FFT_NUM_SAMPLES];\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tint prev_delta;\n\n\tif (IS_CHAN_HT40(ah->curchan)) {\n\t\tstruct ath9k_dfs_fft_40 *fft = (struct ath9k_dfs_fft_40 *) data;\n\t\tint num_fft_packets = datalen / sizeof(*fft);\n\t\tif (num_fft_packets == 0)\n\t\t\treturn false;\n\n\t\tath_dbg(common, DFS, \"HT40: datalen=%d, num_fft_packets=%d\\n\",\n\t\t\tdatalen, num_fft_packets);\n\t\tif (num_fft_packets < FFT_NUM_SAMPLES) {\n\t\t\tath_dbg(common, DFS, \"not enough packets for chirp\\n\");\n\t\t\treturn false;\n\t\t}\n\t\t \n\t\tif ((datalen % sizeof(*fft)) == 2) {\n\t\t\tfft = (struct ath9k_dfs_fft_40 *) (data + 2);\n\t\t\tath_dbg(common, DFS, \"fixing datalen by 2\\n\");\n\t\t}\n\t\tif (IS_CHAN_HT40MINUS(ah->curchan))\n\t\t\tswap(is_ctl, is_ext);\n\n\t\tfor (i = 0; i < FFT_NUM_SAMPLES; i++)\n\t\t\tmax_bin[i] = ath9k_get_max_index_ht40(fft + i, is_ctl,\n\t\t\t\t\t\t\t      is_ext);\n\t} else {\n\t\tstruct ath9k_dfs_fft_20 *fft = (struct ath9k_dfs_fft_20 *) data;\n\t\tint num_fft_packets = datalen / sizeof(*fft);\n\t\tif (num_fft_packets == 0)\n\t\t\treturn false;\n\t\tath_dbg(common, DFS, \"HT20: datalen=%d, num_fft_packets=%d\\n\",\n\t\t\tdatalen, num_fft_packets);\n\t\tif (num_fft_packets < FFT_NUM_SAMPLES) {\n\t\t\tath_dbg(common, DFS, \"not enough packets for chirp\\n\");\n\t\t\treturn false;\n\t\t}\n\t\t \n\t\tfor (i = 0; i < FFT_NUM_SAMPLES; i++)\n\t\t\tmax_bin[i] = fft_max_index(fft[i].lower_bins) ^ 0x20;\n\t}\n\tath_dbg(common, DFS, \"bin_max = [%d, %d, %d, %d]\\n\",\n\t\tmax_bin[0], max_bin[1], max_bin[2], max_bin[3]);\n\n\t \n\tprev_delta = 0;\n\tfor (i = 0; i < NUM_DIFFS; i++) {\n\t\tint ddelta = -1;\n\t\tint delta = max_bin[i + 1] - max_bin[i];\n\n\t\t \n\t\tif (abs(delta) < BIN_DELTA_MIN || abs(delta) > BIN_DELTA_MAX) {\n\t\t\tath_dbg(common, DFS, \"CHIRP: invalid delta %d \"\n\t\t\t\t\"in sample %d\\n\", delta, i);\n\t\t\treturn false;\n\t\t}\n\t\tif (i == 0)\n\t\t\tgoto done;\n\t\tddelta = delta - prev_delta;\n\t\tif (abs(ddelta) > MAX_DIFF) {\n\t\t\tath_dbg(common, DFS, \"CHIRP: ddelta %d too high\\n\",\n\t\t\t\tddelta);\n\t\t\treturn false;\n\t\t}\ndone:\n\t\tath_dbg(common, DFS, \"CHIRP - %d: delta=%d, ddelta=%d\\n\",\n\t\t\ti, delta, ddelta);\n\t\tprev_delta = delta;\n\t}\n\treturn true;\n}\n \n\n \nstatic u32 dur_to_usecs(struct ath_hw *ah, u32 dur)\n{\n\tconst u32 AR93X_NSECS_PER_DUR = 800;\n\tconst u32 AR93X_NSECS_PER_DUR_FAST = (8000 / 11);\n\tu32 nsecs;\n\n\tif (IS_CHAN_A_FAST_CLOCK(ah, ah->curchan))\n\t\tnsecs = dur * AR93X_NSECS_PER_DUR_FAST;\n\telse\n\t\tnsecs = dur * AR93X_NSECS_PER_DUR;\n\n\treturn (nsecs + 500) / 1000;\n}\n\n#define PRI_CH_RADAR_FOUND 0x01\n#define EXT_CH_RADAR_FOUND 0x02\nstatic bool\nath9k_postprocess_radar_event(struct ath_softc *sc,\n\t\t\t      struct ath_radar_data *ard,\n\t\t\t      struct pulse_event *pe)\n{\n\tu8 rssi;\n\tu16 dur;\n\n\t \n\tard->pulse_bw_info &= 0x03;\n\n\tswitch (ard->pulse_bw_info) {\n\tcase PRI_CH_RADAR_FOUND:\n\t\t \n\t\tdur = ard->pulse_length_pri;\n\t\tDFS_STAT_INC(sc, pri_phy_errors);\n\t\t \n\t\trssi = (ard->ext_rssi >= (ard->rssi + 3)) ? 0 : ard->rssi;\n\t\tbreak;\n\tcase EXT_CH_RADAR_FOUND:\n\t\t \n\t\tdur = ard->pulse_length_ext;\n\t\tDFS_STAT_INC(sc, ext_phy_errors);\n\t\t \n\t\trssi = (ard->rssi >= (ard->ext_rssi + 12)) ? 0 : ard->ext_rssi;\n\t\tbreak;\n\tcase (PRI_CH_RADAR_FOUND | EXT_CH_RADAR_FOUND):\n\t\t \n\t\tif (ard->pulse_length_ext >= ard->pulse_length_pri)\n\t\t\tdur = ard->pulse_length_ext;\n\t\telse\n\t\t\tdur = ard->pulse_length_pri;\n\t\tDFS_STAT_INC(sc, dc_phy_errors);\n\n\t\t \n\t\trssi = max(ard->rssi, ard->ext_rssi);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tDFS_STAT_INC(sc, bwinfo_discards);\n\t\treturn false;\n\t}\n\n\tif (rssi == 0) {\n\t\tDFS_STAT_INC(sc, rssi_discards);\n\t\treturn false;\n\t}\n\n\t \n\tpe->width = dur_to_usecs(sc->sc_ah, dur);\n\tpe->rssi = rssi;\n\n\tDFS_STAT_INC(sc, pulses_detected);\n\treturn true;\n}\n\nstatic void\nath9k_dfs_process_radar_pulse(struct ath_softc *sc, struct pulse_event *pe)\n{\n\tstruct dfs_pattern_detector *pd = sc->dfs_detector;\n\tDFS_STAT_INC(sc, pulses_processed);\n\tif (pd == NULL)\n\t\treturn;\n\tif (!pd->add_pulse(pd, pe, NULL))\n\t\treturn;\n\tDFS_STAT_INC(sc, radar_detected);\n\tieee80211_radar_detected(sc->hw);\n}\n\n \nvoid ath9k_dfs_process_phyerr(struct ath_softc *sc, void *data,\n\t\t\t      struct ath_rx_status *rs, u64 mactime)\n{\n\tstruct ath_radar_data ard;\n\tu16 datalen;\n\tchar *vdata_end;\n\tstruct pulse_event pe;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tDFS_STAT_INC(sc, pulses_total);\n\tif ((rs->rs_phyerr != ATH9K_PHYERR_RADAR) &&\n\t    (rs->rs_phyerr != ATH9K_PHYERR_FALSE_RADAR_EXT)) {\n\t\tath_dbg(common, DFS,\n\t\t\t\"Error: rs_phyer=0x%x not a radar error\\n\",\n\t\t\trs->rs_phyerr);\n\t\tDFS_STAT_INC(sc, pulses_no_dfs);\n\t\treturn;\n\t}\n\n\tdatalen = rs->rs_datalen;\n\tif (datalen == 0) {\n\t\tDFS_STAT_INC(sc, datalen_discards);\n\t\treturn;\n\t}\n\n\tard.rssi = rs->rs_rssi_ctl[0];\n\tard.ext_rssi = rs->rs_rssi_ext[0];\n\n\t \n\tif (ard.rssi & 0x80)\n\t\tard.rssi = 0;\n\tif (ard.ext_rssi & 0x80)\n\t\tard.ext_rssi = 0;\n\n\tvdata_end = data + datalen;\n\tard.pulse_bw_info = vdata_end[-1];\n\tard.pulse_length_ext = vdata_end[-2];\n\tard.pulse_length_pri = vdata_end[-3];\n\tpe.freq = ah->curchan->channel;\n\tpe.ts = mactime;\n\tif (!ath9k_postprocess_radar_event(sc, &ard, &pe))\n\t\treturn;\n\n\tif (pe.width > MIN_CHIRP_PULSE_WIDTH &&\n\t    pe.width < MAX_CHIRP_PULSE_WIDTH) {\n\t\tbool is_ctl = !!(ard.pulse_bw_info & PRI_CH_RADAR_FOUND);\n\t\tbool is_ext = !!(ard.pulse_bw_info & EXT_CH_RADAR_FOUND);\n\t\tint clen = datalen - 3;\n\t\tpe.chirp = ath9k_check_chirping(sc, data, clen, is_ctl, is_ext);\n\t} else {\n\t\tpe.chirp = false;\n\t}\n\n\tath_dbg(common, DFS,\n\t\t\"ath9k_dfs_process_phyerr: type=%d, freq=%d, ts=%llu, \"\n\t\t\"width=%d, rssi=%d, delta_ts=%llu\\n\",\n\t\tard.pulse_bw_info, pe.freq, pe.ts, pe.width, pe.rssi,\n\t\tpe.ts - sc->dfs_prev_pulse_ts);\n\tsc->dfs_prev_pulse_ts = pe.ts;\n\tif (ard.pulse_bw_info & PRI_CH_RADAR_FOUND)\n\t\tath9k_dfs_process_radar_pulse(sc, &pe);\n\tif (IS_CHAN_HT40(ah->curchan) &&\n\t    ard.pulse_bw_info & EXT_CH_RADAR_FOUND) {\n\t\tpe.freq += IS_CHAN_HT40PLUS(ah->curchan) ? 20 : -20;\n\t\tath9k_dfs_process_radar_pulse(sc, &pe);\n\t}\n}\n#undef PRI_CH_RADAR_FOUND\n#undef EXT_CH_RADAR_FOUND\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}