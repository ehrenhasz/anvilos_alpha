{
  "module_name": "htc.h",
  "hash_id": "fa915cecf56a626bdb3c3474b8e4a51ac483fed998eb837e132b2aee09e0fde5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/htc.h",
  "human_readable_source": " \n\n#ifndef HTC_H\n#define HTC_H\n\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/firmware.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/leds.h>\n#include <linux/slab.h>\n#include <net/mac80211.h>\n\n#include \"common.h\"\n#include \"htc_hst.h\"\n#include \"hif_usb.h\"\n#include \"wmi.h\"\n\n#define ATH_STA_SHORT_CALINTERVAL 1000     \n#define ATH_AP_SHORT_CALINTERVAL  100      \n#define ATH_ANI_POLLINTERVAL      100      \n#define ATH_LONG_CALINTERVAL      30000    \n#define ATH_RESTART_CALINTERVAL   1200000  \n\n#define ATH_DEFAULT_BMISS_LIMIT 10\n#define TSF_TO_TU(_h, _l) \\\n\t((((u32)(_h)) << 22) | (((u32)(_l)) >> 10))\n\nextern struct ieee80211_ops ath9k_htc_ops;\nextern int htc_modparam_nohwcrypt;\n#ifdef CONFIG_MAC80211_LEDS\nextern int ath9k_htc_led_blink;\n#endif\n\nenum htc_phymode {\n\tHTC_MODE_11NA\t\t= 0,\n\tHTC_MODE_11NG\t\t= 1\n};\n\nenum htc_opmode {\n\tHTC_M_STA\t= 1,\n\tHTC_M_IBSS\t= 0,\n\tHTC_M_AHDEMO\t= 3,\n\tHTC_M_HOSTAP\t= 6,\n\tHTC_M_MONITOR\t= 8,\n\tHTC_M_WDS\t= 2\n};\n\n#define ATH9K_HTC_AMPDU  1\n#define ATH9K_HTC_NORMAL 2\n#define ATH9K_HTC_BEACON 3\n#define ATH9K_HTC_MGMT   4\n\n#define ATH9K_HTC_TX_CTSONLY      0x1\n#define ATH9K_HTC_TX_RTSCTS       0x2\n\nstruct tx_frame_hdr {\n\tu8 data_type;\n\tu8 node_idx;\n\tu8 vif_idx;\n\tu8 tidno;\n\t__be32 flags;  \n\tu8 key_type;\n\tu8 keyix;\n\tu8 cookie;\n\tu8 pad;\n} __packed;\n\nstruct tx_mgmt_hdr {\n\tu8 node_idx;\n\tu8 vif_idx;\n\tu8 tidno;\n\tu8 flags;\n\tu8 key_type;\n\tu8 keyix;\n\tu8 cookie;\n\tu8 pad;\n} __packed;\n\nstruct tx_beacon_header {\n\tu8 vif_index;\n\tu8 len_changed;\n\tu16 rev;\n} __packed;\n\n#define MAX_TX_AMPDU_SUBFRAMES_9271 17\n#define MAX_TX_AMPDU_SUBFRAMES_7010 22\n\nstruct ath9k_htc_cap_target {\n\t__be32 ampdu_limit;\n\tu8 ampdu_subframes;\n\tu8 enable_coex;\n\tu8 tx_chainmask;\n\tu8 pad;\n} __packed;\n\nstruct ath9k_htc_target_vif {\n\tu8 index;\n\tu8 opmode;\n\tu8 myaddr[ETH_ALEN];\n\tu8 ath_cap;\n\t__be16 rtsthreshold;\n\tu8 pad;\n} __packed;\n\nstruct ath9k_htc_target_sta {\n\tu8 macaddr[ETH_ALEN];\n\tu8 bssid[ETH_ALEN];\n\tu8 sta_index;\n\tu8 vif_index;\n\tu8 is_vif_sta;\n\t__be16 flags;\n\t__be16 htcap;\n\t__be16 maxampdu;\n\tu8 pad;\n} __packed;\n\nstruct ath9k_htc_target_aggr {\n\tu8 sta_index;\n\tu8 tidno;\n\tu8 aggr_enable;\n\tu8 padding;\n} __packed;\n\n#define ATH_HTC_RATE_MAX 30\n\n#define WLAN_RC_DS_FLAG  0x01\n#define WLAN_RC_40_FLAG  0x02\n#define WLAN_RC_SGI_FLAG 0x04\n#define WLAN_RC_HT_FLAG  0x08\n#define ATH_RC_TX_STBC_FLAG 0x20\n\nstruct ath9k_htc_rateset {\n\tu8 rs_nrates;\n\tu8 rs_rates[ATH_HTC_RATE_MAX];\n};\n\nstruct ath9k_htc_rate {\n\tstruct ath9k_htc_rateset legacy_rates;\n\tstruct ath9k_htc_rateset ht_rates;\n} __packed;\n\nstruct ath9k_htc_target_rate {\n\tu8 sta_index;\n\tu8 isnew;\n\t__be32 capflags;\n\tstruct ath9k_htc_rate rates;\n};\n\nstruct ath9k_htc_target_rate_mask {\n\tu8 vif_index;\n\tu8 band;\n\t__be32 mask;\n\tu16 pad;\n} __packed;\n\nstruct ath9k_htc_target_int_stats {\n\t__be32 rx;\n\t__be32 rxorn;\n\t__be32 rxeol;\n\t__be32 txurn;\n\t__be32 txto;\n\t__be32 cst;\n} __packed;\n\nstruct ath9k_htc_target_tx_stats {\n\t__be32 xretries;\n\t__be32 fifoerr;\n\t__be32 filtered;\n\t__be32 timer_exp;\n\t__be32 shortretries;\n\t__be32 longretries;\n\t__be32 qnull;\n\t__be32 encap_fail;\n\t__be32 nobuf;\n} __packed;\n\nstruct ath9k_htc_target_rx_stats {\n\t__be32 nobuf;\n\t__be32 host_send;\n\t__be32 host_done;\n} __packed;\n\n#define ATH9K_HTC_MAX_VIF 2\n#define ATH9K_HTC_MAX_BCN_VIF 2\n\n#define INC_VIF(_priv, _type) do {\t\t\\\n\t\tswitch (_type) {\t\t\\\n\t\tcase NL80211_IFTYPE_STATION:\t\\\n\t\t\t_priv->num_sta_vif++;\t\\\n\t\t\tbreak;\t\t\t\\\n\t\tcase NL80211_IFTYPE_ADHOC:\t\\\n\t\t\t_priv->num_ibss_vif++;\t\\\n\t\t\tbreak;\t\t\t\\\n\t\tcase NL80211_IFTYPE_AP:\t\t\\\n\t\t\t_priv->num_ap_vif++;\t\\\n\t\t\tbreak;\t\t\t\\\n\t\tcase NL80211_IFTYPE_MESH_POINT:\t\\\n\t\t\t_priv->num_mbss_vif++;\t\\\n\t\t\tbreak;\t\t\t\\\n\t\tdefault:\t\t\t\\\n\t\t\tbreak;\t\t\t\\\n\t\t}\t\t\t\t\\\n\t} while (0)\n\n#define DEC_VIF(_priv, _type) do {\t\t\\\n\t\tswitch (_type) {\t\t\\\n\t\tcase NL80211_IFTYPE_STATION:\t\\\n\t\t\t_priv->num_sta_vif--;\t\\\n\t\t\tbreak;\t\t\t\\\n\t\tcase NL80211_IFTYPE_ADHOC:\t\\\n\t\t\t_priv->num_ibss_vif--;\t\\\n\t\t\tbreak;\t\t\t\\\n\t\tcase NL80211_IFTYPE_AP:\t\t\\\n\t\t\t_priv->num_ap_vif--;\t\\\n\t\t\tbreak;\t\t\t\\\n\t\tcase NL80211_IFTYPE_MESH_POINT:\t\\\n\t\t\t_priv->num_mbss_vif--;\t\\\n\t\t\tbreak;\t\t\t\\\n\t\tdefault:\t\t\t\\\n\t\t\tbreak;\t\t\t\\\n\t\t}\t\t\t\t\\\n\t} while (0)\n\nstruct ath9k_htc_vif {\n\tu8 index;\n\tu16 seq_no;\n\tbool beacon_configured;\n\tint bslot;\n\t__le64 tsfadjust;\n};\n\nstruct ath9k_vif_iter_data {\n\tconst u8 *hw_macaddr;\n\tu8 mask[ETH_ALEN];\n};\n\n#define ATH9K_HTC_MAX_STA 8\n#define ATH9K_HTC_MAX_TID 8\n\nenum tid_aggr_state {\n\tAGGR_STOP = 0,\n\tAGGR_PROGRESS,\n\tAGGR_START,\n\tAGGR_OPERATIONAL\n};\n\nstruct ath9k_htc_sta {\n\tu8 index;\n\tenum tid_aggr_state tid_state[ATH9K_HTC_MAX_TID];\n\tstruct work_struct rc_update_work;\n\tstruct ath9k_htc_priv *htc_priv;\n};\n\n#define ATH9K_HTC_RXBUF 256\n#define HTC_RX_FRAME_HEADER_SIZE 40\n\nstruct ath9k_htc_rxbuf {\n\tbool in_process;\n\tstruct sk_buff *skb;\n\tstruct ath_htc_rx_status rxstatus;\n\tstruct list_head list;\n};\n\nstruct ath9k_htc_rx {\n\tstruct list_head rxbuf;\n\tspinlock_t rxbuflock;\n\tbool initialized;\n};\n\n#define ATH9K_HTC_TX_CLEANUP_INTERVAL 50  \n#define ATH9K_HTC_TX_TIMEOUT_INTERVAL 3000  \n#define ATH9K_HTC_TX_RESERVE 10\n#define ATH9K_HTC_TX_TIMEOUT_COUNT 40\n#define ATH9K_HTC_TX_THRESHOLD (MAX_TX_BUF_NUM - ATH9K_HTC_TX_RESERVE)\n\n#define ATH9K_HTC_OP_TX_QUEUES_STOP BIT(0)\n#define ATH9K_HTC_OP_TX_DRAIN       BIT(1)\n\nstruct ath9k_htc_tx {\n\tu8 flags;\n\tint queued_cnt;\n\tstruct sk_buff_head mgmt_ep_queue;\n\tstruct sk_buff_head cab_ep_queue;\n\tstruct sk_buff_head data_be_queue;\n\tstruct sk_buff_head data_bk_queue;\n\tstruct sk_buff_head data_vi_queue;\n\tstruct sk_buff_head data_vo_queue;\n\tstruct sk_buff_head tx_failed;\n\tDECLARE_BITMAP(tx_slot, MAX_TX_BUF_NUM);\n\tstruct timer_list cleanup_timer;\n\tspinlock_t tx_lock;\n\tbool initialized;\n};\n\nstruct ath9k_htc_tx_ctl {\n\tu8 type;  \n\tu8 epid;\n\tu8 txok;\n\tu8 sta_idx;\n\tunsigned long timestamp;\n};\n\nstatic inline struct ath9k_htc_tx_ctl *HTC_SKB_CB(struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\n\tBUILD_BUG_ON(sizeof(struct ath9k_htc_tx_ctl) >\n\t\t     IEEE80211_TX_INFO_DRIVER_DATA_SIZE);\n\treturn (struct ath9k_htc_tx_ctl *) &tx_info->driver_data;\n}\n\n#ifdef CONFIG_ATH9K_HTC_DEBUGFS\n#define __STAT_SAFE(hif_dev, expr)\tdo { ((hif_dev)->htc_handle->drv_priv ? (expr) : 0); } while (0)\n#define CAB_STAT_INC(priv)\t\tdo { ((priv)->debug.tx_stats.cab_queued++); } while (0)\n#define TX_QSTAT_INC(priv, q)\t\tdo { ((priv)->debug.tx_stats.queue_stats[q]++); } while (0)\n\n#define TX_STAT_INC(hif_dev, c) \\\n\t\t__STAT_SAFE((hif_dev), (hif_dev)->htc_handle->drv_priv->debug.tx_stats.c++)\n#define TX_STAT_ADD(hif_dev, c, a) \\\n\t\t__STAT_SAFE((hif_dev), (hif_dev)->htc_handle->drv_priv->debug.tx_stats.c += a)\n#define RX_STAT_INC(hif_dev, c) \\\n\t\t__STAT_SAFE((hif_dev), (hif_dev)->htc_handle->drv_priv->debug.skbrx_stats.c++)\n#define RX_STAT_ADD(hif_dev, c, a) \\\n\t\t__STAT_SAFE((hif_dev), (hif_dev)->htc_handle->drv_priv->debug.skbrx_stats.c += a)\n\nvoid ath9k_htc_err_stat_rx(struct ath9k_htc_priv *priv,\n\t\t\t   struct ath_rx_status *rs);\n\nstruct ath_tx_stats {\n\tu32 buf_queued;\n\tu32 buf_completed;\n\tu32 skb_queued;\n\tu32 skb_success;\n\tu32 skb_success_bytes;\n\tu32 skb_failed;\n\tu32 cab_queued;\n\tu32 queue_stats[IEEE80211_NUM_ACS];\n};\n\nstruct ath_skbrx_stats {\n\tu32 skb_allocated;\n\tu32 skb_completed;\n\tu32 skb_completed_bytes;\n\tu32 skb_dropped;\n};\n\nstruct ath9k_debug {\n\tstruct dentry *debugfs_phy;\n\tstruct ath_tx_stats tx_stats;\n\tstruct ath_rx_stats rx_stats;\n\tstruct ath_skbrx_stats skbrx_stats;\n};\n\nvoid ath9k_htc_get_et_strings(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      u32 sset, u8 *data);\nint ath9k_htc_get_et_sset_count(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif, int sset);\nvoid ath9k_htc_get_et_stats(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct ethtool_stats *stats, u64 *data);\n#else\n\n#define TX_STAT_INC(hif_dev, c)\t\tdo { } while (0)\n#define TX_STAT_ADD(hif_dev, c, a)\tdo { } while (0)\n#define RX_STAT_INC(hif_dev, c)\t\tdo { } while (0)\n#define RX_STAT_ADD(hif_dev, c, a)\tdo { } while (0)\n\n#define CAB_STAT_INC(priv)\n#define TX_QSTAT_INC(priv, c)\n\nstatic inline void ath9k_htc_err_stat_rx(struct ath9k_htc_priv *priv,\n\t\t\t\t\t struct ath_rx_status *rs)\n{\n}\n\n#endif  \n\n#define ATH_LED_PIN_DEF             1\n#define ATH_LED_PIN_9287            10\n#define ATH_LED_PIN_9271            15\n#define ATH_LED_PIN_7010            12\n\n#define BSTUCK_THRESHOLD 10\n\n \n#define DEFAULT_SWBA_RESPONSE 40  \n#define MIN_SWBA_RESPONSE     10  \n\nstruct htc_beacon {\n\tenum {\n\t\tOK,\t\t \n\t\tUPDATE,\t\t \n\t\tCOMMIT\t\t \n\t} updateslot;\t\t \n\n\tstruct ieee80211_vif *bslot[ATH9K_HTC_MAX_BCN_VIF];\n\tu32 bmisscnt;\n\tu32 beaconq;\n\tint slottime;\n\tint slotupdate;\n};\n\nstruct ath_btcoex {\n\tu32 bt_priority_cnt;\n\tunsigned long bt_priority_time;\n\tint bt_stomp_type;  \n\tu32 btcoex_no_stomp;\n\tu32 btcoex_period;\n\tu32 btscan_no_stomp;\n};\n\n#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT\nvoid ath9k_htc_init_btcoex(struct ath9k_htc_priv *priv, char *product);\nvoid ath9k_htc_start_btcoex(struct ath9k_htc_priv *priv);\nvoid ath9k_htc_stop_btcoex(struct ath9k_htc_priv *priv);\n#else\nstatic inline void ath9k_htc_init_btcoex(struct ath9k_htc_priv *priv, char *product)\n{\n}\nstatic inline void ath9k_htc_start_btcoex(struct ath9k_htc_priv *priv)\n{\n}\nstatic inline void ath9k_htc_stop_btcoex(struct ath9k_htc_priv *priv)\n{\n}\n#endif  \n\n#define OP_BT_PRIORITY_DETECTED    3\n#define OP_BT_SCAN                 4\n#define OP_TSF_RESET               6\n\nenum htc_op_flags {\n\tHTC_FWFLAG_NO_RMW,\n};\n\nstruct ath9k_htc_priv {\n\tstruct device *dev;\n\tstruct ieee80211_hw *hw;\n\tstruct ath_hw *ah;\n\tstruct htc_target *htc;\n\tstruct wmi *wmi;\n\n\tu16 fw_version_major;\n\tu16 fw_version_minor;\n\n\tenum htc_endpoint_id wmi_cmd_ep;\n\tenum htc_endpoint_id beacon_ep;\n\tenum htc_endpoint_id cab_ep;\n\tenum htc_endpoint_id uapsd_ep;\n\tenum htc_endpoint_id mgmt_ep;\n\tenum htc_endpoint_id data_be_ep;\n\tenum htc_endpoint_id data_bk_ep;\n\tenum htc_endpoint_id data_vi_ep;\n\tenum htc_endpoint_id data_vo_ep;\n\n\tu8 vif_slot;\n\tu8 mon_vif_idx;\n\tu8 sta_slot;\n\tu8 vif_sta_pos[ATH9K_HTC_MAX_VIF];\n\tu8 num_ibss_vif;\n\tu8 num_mbss_vif;\n\tu8 num_sta_vif;\n\tu8 num_sta_assoc_vif;\n\tu8 num_ap_vif;\n\n\tu16 curtxpow;\n\tu16 txpowlimit;\n\tu16 nvifs;\n\tu16 nstations;\n\tbool rearm_ani;\n\tbool reconfig_beacon;\n\tunsigned int rxfilter;\n\tunsigned long op_flags;\n\tunsigned long fw_flags;\n\n\tstruct ath9k_hw_cal_data caldata;\n\tstruct ath_spec_scan_priv spec_priv;\n\n\tspinlock_t beacon_lock;\n\tstruct ath_beacon_config cur_beacon_conf;\n\tstruct htc_beacon beacon;\n\n\tstruct ath9k_htc_rx rx;\n\tstruct ath9k_htc_tx tx;\n\n\tstruct tasklet_struct swba_tasklet;\n\tstruct tasklet_struct rx_tasklet;\n\tstruct delayed_work ani_work;\n\tstruct tasklet_struct tx_failed_tasklet;\n\tstruct work_struct ps_work;\n\tstruct work_struct fatal_work;\n\n\tstruct mutex htc_pm_lock;\n\tunsigned long ps_usecount;\n\tbool ps_enabled;\n\tbool ps_idle;\n\n#ifdef CONFIG_MAC80211_LEDS\n\tenum led_brightness brightness;\n\tbool led_registered;\n\tchar led_name[32];\n\tstruct led_classdev led_cdev;\n\tstruct work_struct led_work;\n#endif\n\n\tint cabq;\n\tint hwq_map[IEEE80211_NUM_ACS];\n\n#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT\n\tstruct ath_btcoex btcoex;\n#endif\n\n\tstruct delayed_work coex_period_work;\n\tstruct delayed_work duty_cycle_work;\n#ifdef CONFIG_ATH9K_HTC_DEBUGFS\n\tstruct ath9k_debug debug;\n#endif\n\tstruct mutex mutex;\n\tstruct ieee80211_vif *csa_vif;\n};\n\nstatic inline void ath_read_cachesize(struct ath_common *common, int *csz)\n{\n\tcommon->bus_ops->read_cachesize(common, csz);\n}\n\nvoid ath9k_htc_reset(struct ath9k_htc_priv *priv);\n\nvoid ath9k_htc_assign_bslot(struct ath9k_htc_priv *priv,\n\t\t\t    struct ieee80211_vif *vif);\nvoid ath9k_htc_remove_bslot(struct ath9k_htc_priv *priv,\n\t\t\t    struct ieee80211_vif *vif);\nvoid ath9k_htc_set_tsfadjust(struct ath9k_htc_priv *priv,\n\t\t\t     struct ieee80211_vif *vif);\nvoid ath9k_htc_beaconq_config(struct ath9k_htc_priv *priv);\nvoid ath9k_htc_beacon_config(struct ath9k_htc_priv *priv,\n\t\t\t     struct ieee80211_vif *vif);\nvoid ath9k_htc_beacon_reconfig(struct ath9k_htc_priv *priv);\nvoid ath9k_htc_swba(struct ath9k_htc_priv *priv,\n\t\t    struct wmi_event_swba *swba);\n\nvoid ath9k_htc_rxep(void *priv, struct sk_buff *skb,\n\t\t    enum htc_endpoint_id ep_id);\nvoid ath9k_htc_txep(void *priv, struct sk_buff *skb, enum htc_endpoint_id ep_id,\n\t\t    bool txok);\nvoid ath9k_htc_beaconep(void *drv_priv, struct sk_buff *skb,\n\t\t\tenum htc_endpoint_id ep_id, bool txok);\n\nint ath9k_htc_update_cap_target(struct ath9k_htc_priv *priv,\n\t\t\t\tu8 enable_coex);\nvoid ath9k_htc_ani_work(struct work_struct *work);\nvoid ath9k_htc_start_ani(struct ath9k_htc_priv *priv);\nvoid ath9k_htc_stop_ani(struct ath9k_htc_priv *priv);\n\nint ath9k_tx_init(struct ath9k_htc_priv *priv);\nint ath9k_htc_tx_start(struct ath9k_htc_priv *priv,\n\t\t       struct ieee80211_sta *sta,\n\t\t       struct sk_buff *skb, u8 slot, bool is_cab);\nvoid ath9k_tx_cleanup(struct ath9k_htc_priv *priv);\nbool ath9k_htc_txq_setup(struct ath9k_htc_priv *priv, int subtype);\nint ath9k_htc_cabq_setup(struct ath9k_htc_priv *priv);\nint get_hw_qnum(u16 queue, int *hwq_map);\nint ath_htc_txq_update(struct ath9k_htc_priv *priv, int qnum,\n\t\t       struct ath9k_tx_queue_info *qinfo);\nvoid ath9k_htc_check_stop_queues(struct ath9k_htc_priv *priv);\nvoid ath9k_htc_check_wake_queues(struct ath9k_htc_priv *priv);\nint ath9k_htc_tx_get_slot(struct ath9k_htc_priv *priv);\nvoid ath9k_htc_tx_clear_slot(struct ath9k_htc_priv *priv, int slot);\nvoid ath9k_htc_tx_drain(struct ath9k_htc_priv *priv);\nvoid ath9k_htc_txstatus(struct ath9k_htc_priv *priv, void *wmi_event);\nvoid ath9k_tx_failed_tasklet(struct tasklet_struct *t);\nvoid ath9k_htc_tx_cleanup_timer(struct timer_list *t);\nbool ath9k_htc_csa_is_finished(struct ath9k_htc_priv *priv);\n\nint ath9k_rx_init(struct ath9k_htc_priv *priv);\nvoid ath9k_rx_cleanup(struct ath9k_htc_priv *priv);\nvoid ath9k_host_rx_init(struct ath9k_htc_priv *priv);\nvoid ath9k_rx_tasklet(struct tasklet_struct *t);\nu32 ath9k_htc_calcrxfilter(struct ath9k_htc_priv *priv);\n\nvoid ath9k_htc_ps_wakeup(struct ath9k_htc_priv *priv);\nvoid ath9k_htc_ps_restore(struct ath9k_htc_priv *priv);\nvoid ath9k_ps_work(struct work_struct *work);\nbool ath9k_htc_setpower(struct ath9k_htc_priv *priv,\n\t\t\tenum ath9k_power_mode mode);\n\nvoid ath9k_start_rfkill_poll(struct ath9k_htc_priv *priv);\nvoid ath9k_htc_rfkill_poll_state(struct ieee80211_hw *hw);\n\nstruct base_eep_header *ath9k_htc_get_eeprom_base(struct ath9k_htc_priv *priv);\n\n#ifdef CONFIG_MAC80211_LEDS\nvoid ath9k_configure_leds(struct ath9k_htc_priv *priv);\nvoid ath9k_init_leds(struct ath9k_htc_priv *priv);\nvoid ath9k_deinit_leds(struct ath9k_htc_priv *priv);\nvoid ath9k_led_work(struct work_struct *work);\n#else\nstatic inline void ath9k_configure_leds(struct ath9k_htc_priv *priv)\n{\n}\n\nstatic inline void ath9k_init_leds(struct ath9k_htc_priv *priv)\n{\n}\n\nstatic inline void ath9k_deinit_leds(struct ath9k_htc_priv *priv)\n{\n}\n\nstatic inline void ath9k_led_work(struct work_struct *work)\n{\n}\n#endif\n\nint ath9k_htc_probe_device(struct htc_target *htc_handle, struct device *dev,\n\t\t\t   u16 devid, char *product, u32 drv_info);\nvoid ath9k_htc_disconnect_device(struct htc_target *htc_handle, bool hotunplug);\n#ifdef CONFIG_PM\nvoid ath9k_htc_suspend(struct htc_target *htc_handle);\nint ath9k_htc_resume(struct htc_target *htc_handle);\n#endif\n#ifdef CONFIG_ATH9K_HTC_DEBUGFS\nint ath9k_htc_init_debug(struct ath_hw *ah);\nvoid ath9k_htc_deinit_debug(struct ath9k_htc_priv *priv);\n#else\nstatic inline int ath9k_htc_init_debug(struct ath_hw *ah) { return 0; };\nstatic inline void ath9k_htc_deinit_debug(struct ath9k_htc_priv *priv)\n{\n}\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}