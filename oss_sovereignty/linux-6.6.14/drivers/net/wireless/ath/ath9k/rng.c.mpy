{
  "module_name": "rng.c",
  "hash_id": "30bd362eb136540bc36620ebd754b521d5eea519429892b3c1b092b2b0db4bad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/rng.c",
  "human_readable_source": " \n\n#include <linux/hw_random.h>\n#include <linux/kthread.h>\n\n#include \"ath9k.h\"\n#include \"hw.h\"\n#include \"ar9003_phy.h\"\n\nstatic int ath9k_rng_data_read(struct ath_softc *sc, u32 *buf, u32 buf_size)\n{\n\tint i, j;\n\tu32  v1, v2, rng_last = sc->rng_last;\n\tstruct ath_hw *ah = sc->sc_ah;\n\n\tath9k_ps_wakeup(sc);\n\n\tREG_RMW_FIELD(ah, AR_PHY_TEST(ah), AR_PHY_TEST_BBB_OBS_SEL, 1);\n\tREG_CLR_BIT(ah, AR_PHY_TEST(ah), AR_PHY_TEST_RX_OBS_SEL_BIT5);\n\tREG_RMW_FIELD(ah, AR_PHY_TEST_CTL_STATUS(ah), AR_PHY_TEST_CTL_RX_OBS_SEL, 0);\n\n\tfor (i = 0, j = 0; i < buf_size; i++) {\n\t\tv1 = REG_READ(ah, AR_PHY_TST_ADC) & 0xffff;\n\t\tv2 = REG_READ(ah, AR_PHY_TST_ADC) & 0xffff;\n\n\t\t \n\t\tif (v1 && v2 && rng_last != v1 && v1 != v2 && v1 != 0xffff &&\n\t\t    v2 != 0xffff)\n\t\t\tbuf[j++] = (v1 << 16) | v2;\n\n\t\trng_last = v2;\n\t}\n\n\tath9k_ps_restore(sc);\n\n\tsc->rng_last = rng_last;\n\n\treturn j << 2;\n}\n\nstatic u32 ath9k_rng_delay_get(u32 fail_stats)\n{\n\tu32 delay;\n\n\tif (fail_stats < 100)\n\t\tdelay = 10;\n\telse if (fail_stats < 105)\n\t\tdelay = 1000;\n\telse\n\t\tdelay = 10000;\n\n\treturn delay;\n}\n\nstatic int ath9k_rng_read(struct hwrng *rng, void *buf, size_t max, bool wait)\n{\n\tstruct ath_softc *sc = container_of(rng, struct ath_softc, rng_ops);\n\tu32 fail_stats = 0, word;\n\tint bytes_read = 0;\n\n\tfor (;;) {\n\t\tif (max & ~3UL)\n\t\t\tbytes_read = ath9k_rng_data_read(sc, buf, max >> 2);\n\t\tif ((max & 3UL) && ath9k_rng_data_read(sc, &word, 1)) {\n\t\t\tmemcpy(buf + bytes_read, &word, max & 3UL);\n\t\t\tbytes_read += max & 3UL;\n\t\t\tmemzero_explicit(&word, sizeof(word));\n\t\t}\n\t\tif (!wait || !max || likely(bytes_read) || fail_stats > 110)\n\t\t\tbreak;\n\n\t\tif (hwrng_msleep(rng, ath9k_rng_delay_get(++fail_stats)))\n\t\t\tbreak;\n\t}\n\n\tif (wait && !bytes_read && max)\n\t\tbytes_read = -EIO;\n\treturn bytes_read;\n}\n\nvoid ath9k_rng_start(struct ath_softc *sc)\n{\n\tstatic atomic_t serial = ATOMIC_INIT(0);\n\tstruct ath_hw *ah = sc->sc_ah;\n\n\tif (sc->rng_ops.read)\n\t\treturn;\n\n\tif (!AR_SREV_9300_20_OR_LATER(ah))\n\t\treturn;\n\n\tsnprintf(sc->rng_name, sizeof(sc->rng_name), \"ath9k_%u\",\n\t\t (atomic_inc_return(&serial) - 1) & U16_MAX);\n\tsc->rng_ops.name = sc->rng_name;\n\tsc->rng_ops.read = ath9k_rng_read;\n\tsc->rng_ops.quality = 320;\n\n\tif (devm_hwrng_register(sc->dev, &sc->rng_ops))\n\t\tsc->rng_ops.read = NULL;\n}\n\nvoid ath9k_rng_stop(struct ath_softc *sc)\n{\n\tif (sc->rng_ops.read) {\n\t\tdevm_hwrng_unregister(sc->dev, &sc->rng_ops);\n\t\tsc->rng_ops.read = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}