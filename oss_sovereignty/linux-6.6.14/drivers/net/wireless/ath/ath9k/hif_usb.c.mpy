{
  "module_name": "hif_usb.c",
  "hash_id": "f1afa5c2733afb9dce74a86a32e5aedc18527952816163c635cf8d3d3e801113",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/hif_usb.c",
  "human_readable_source": " \n\n#include <asm/unaligned.h>\n#include \"htc.h\"\n\nMODULE_FIRMWARE(HTC_7010_MODULE_FW);\nMODULE_FIRMWARE(HTC_9271_MODULE_FW);\n\nstatic const struct usb_device_id ath9k_hif_usb_ids[] = {\n\t{ USB_DEVICE(0x0cf3, 0x9271) },  \n\t{ USB_DEVICE(0x0cf3, 0x1006) },  \n\t{ USB_DEVICE(0x0846, 0x9030) },  \n\t{ USB_DEVICE(0x07b8, 0x9271) },  \n\t{ USB_DEVICE(0x07D1, 0x3A10) },  \n\t{ USB_DEVICE(0x13D3, 0x3327) },  \n\t{ USB_DEVICE(0x13D3, 0x3328) },  \n\t{ USB_DEVICE(0x13D3, 0x3346) },  \n\t{ USB_DEVICE(0x13D3, 0x3348) },  \n\t{ USB_DEVICE(0x13D3, 0x3349) },  \n\t{ USB_DEVICE(0x13D3, 0x3350) },  \n\t{ USB_DEVICE(0x04CA, 0x4605) },  \n\t{ USB_DEVICE(0x040D, 0x3801) },  \n\t{ USB_DEVICE(0x0cf3, 0xb003) },  \n\t{ USB_DEVICE(0x0cf3, 0xb002) },  \n\t{ USB_DEVICE(0x057c, 0x8403) },  \n\t{ USB_DEVICE(0x0471, 0x209e) },  \n\t{ USB_DEVICE(0x1eda, 0x2315) },  \n\n\t{ USB_DEVICE(0x0cf3, 0x7015),\n\t  .driver_info = AR9287_USB },   \n\n\t{ USB_DEVICE(0x0cf3, 0x7010),\n\t  .driver_info = AR9280_USB },   \n\t{ USB_DEVICE(0x0846, 0x9018),\n\t  .driver_info = AR9280_USB },   \n\t{ USB_DEVICE(0x083A, 0xA704),\n\t  .driver_info = AR9280_USB },   \n\t{ USB_DEVICE(0x0411, 0x017f),\n\t  .driver_info = AR9280_USB },   \n\t{ USB_DEVICE(0x0411, 0x0197),\n\t  .driver_info = AR9280_USB },   \n\t{ USB_DEVICE(0x04da, 0x3904),\n\t  .driver_info = AR9280_USB },\n\t{ USB_DEVICE(0x0930, 0x0a08),\n\t  .driver_info = AR9280_USB },   \n\n\t{ USB_DEVICE(0x0cf3, 0x20ff),\n\t  .driver_info = STORAGE_DEVICE },\n\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(usb, ath9k_hif_usb_ids);\n\nstatic int __hif_usb_tx(struct hif_device_usb *hif_dev);\n\nstatic void hif_usb_regout_cb(struct urb *urb)\n{\n\tstruct cmd_buf *cmd = (struct cmd_buf *)urb->context;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ENODEV:\n\tcase -ESHUTDOWN:\n\t\tgoto free;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (cmd) {\n\t\tath9k_htc_txcompletion_cb(cmd->hif_dev->htc_handle,\n\t\t\t\t\t  cmd->skb, true);\n\t\tkfree(cmd);\n\t}\n\n\treturn;\nfree:\n\tkfree_skb(cmd->skb);\n\tkfree(cmd);\n}\n\nstatic int hif_usb_send_regout(struct hif_device_usb *hif_dev,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct urb *urb;\n\tstruct cmd_buf *cmd;\n\tint ret = 0;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (urb == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL) {\n\t\tusb_free_urb(urb);\n\t\treturn -ENOMEM;\n\t}\n\n\tcmd->skb = skb;\n\tcmd->hif_dev = hif_dev;\n\n\tusb_fill_int_urb(urb, hif_dev->udev,\n\t\t\t usb_sndintpipe(hif_dev->udev, USB_REG_OUT_PIPE),\n\t\t\t skb->data, skb->len,\n\t\t\t hif_usb_regout_cb, cmd, 1);\n\n\tusb_anchor_urb(urb, &hif_dev->regout_submitted);\n\tret = usb_submit_urb(urb, GFP_KERNEL);\n\tif (ret) {\n\t\tusb_unanchor_urb(urb);\n\t\tkfree(cmd);\n\t}\n\tusb_free_urb(urb);\n\n\treturn ret;\n}\n\nstatic void hif_usb_mgmt_cb(struct urb *urb)\n{\n\tstruct cmd_buf *cmd = (struct cmd_buf *)urb->context;\n\tstruct hif_device_usb *hif_dev;\n\tunsigned long flags;\n\tbool txok = true;\n\n\tif (!cmd || !cmd->skb || !cmd->hif_dev)\n\t\treturn;\n\n\thif_dev = cmd->hif_dev;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ENODEV:\n\tcase -ESHUTDOWN:\n\t\ttxok = false;\n\n\t\t \n\t\tspin_lock_irqsave(&hif_dev->tx.tx_lock, flags);\n\t\tif (hif_dev->tx.flags & HIF_USB_TX_FLUSH) {\n\t\t\tspin_unlock_irqrestore(&hif_dev->tx.tx_lock, flags);\n\t\t\tdev_kfree_skb_any(cmd->skb);\n\t\t\tkfree(cmd);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock_irqrestore(&hif_dev->tx.tx_lock, flags);\n\n\t\tbreak;\n\tdefault:\n\t\ttxok = false;\n\t\tbreak;\n\t}\n\n\tskb_pull(cmd->skb, 4);\n\tath9k_htc_txcompletion_cb(cmd->hif_dev->htc_handle,\n\t\t\t\t  cmd->skb, txok);\n\tkfree(cmd);\n}\n\nstatic int hif_usb_send_mgmt(struct hif_device_usb *hif_dev,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct urb *urb;\n\tstruct cmd_buf *cmd;\n\tint ret = 0;\n\t__le16 *hdr;\n\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (urb == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_ATOMIC);\n\tif (cmd == NULL) {\n\t\tusb_free_urb(urb);\n\t\treturn -ENOMEM;\n\t}\n\n\tcmd->skb = skb;\n\tcmd->hif_dev = hif_dev;\n\n\thdr = skb_push(skb, 4);\n\t*hdr++ = cpu_to_le16(skb->len - 4);\n\t*hdr++ = cpu_to_le16(ATH_USB_TX_STREAM_MODE_TAG);\n\n\tusb_fill_bulk_urb(urb, hif_dev->udev,\n\t\t\t usb_sndbulkpipe(hif_dev->udev, USB_WLAN_TX_PIPE),\n\t\t\t skb->data, skb->len,\n\t\t\t hif_usb_mgmt_cb, cmd);\n\n\tusb_anchor_urb(urb, &hif_dev->mgmt_submitted);\n\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (ret) {\n\t\tusb_unanchor_urb(urb);\n\t\tkfree(cmd);\n\t}\n\tusb_free_urb(urb);\n\n\treturn ret;\n}\n\nstatic inline void ath9k_skb_queue_purge(struct hif_device_usb *hif_dev,\n\t\t\t\t\t struct sk_buff_head *list)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = __skb_dequeue(list)) != NULL) {\n\t\tdev_kfree_skb_any(skb);\n\t}\n}\n\nstatic inline void ath9k_skb_queue_complete(struct hif_device_usb *hif_dev,\n\t\t\t\t\t    struct sk_buff_head *queue,\n\t\t\t\t\t    bool txok)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = __skb_dequeue(queue)) != NULL) {\n#ifdef CONFIG_ATH9K_HTC_DEBUGFS\n\t\tint ln = skb->len;\n#endif\n\t\tath9k_htc_txcompletion_cb(hif_dev->htc_handle,\n\t\t\t\t\t  skb, txok);\n\t\tif (txok) {\n\t\t\tTX_STAT_INC(hif_dev, skb_success);\n\t\t\tTX_STAT_ADD(hif_dev, skb_success_bytes, ln);\n\t\t}\n\t\telse\n\t\t\tTX_STAT_INC(hif_dev, skb_failed);\n\t}\n}\n\nstatic void hif_usb_tx_cb(struct urb *urb)\n{\n\tstruct tx_buf *tx_buf = (struct tx_buf *) urb->context;\n\tstruct hif_device_usb *hif_dev;\n\tbool txok = true;\n\n\tif (!tx_buf || !tx_buf->hif_dev)\n\t\treturn;\n\n\thif_dev = tx_buf->hif_dev;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ENODEV:\n\tcase -ESHUTDOWN:\n\t\ttxok = false;\n\n\t\t \n\t\tspin_lock(&hif_dev->tx.tx_lock);\n\t\tif (hif_dev->tx.flags & HIF_USB_TX_FLUSH) {\n\t\t\tspin_unlock(&hif_dev->tx.tx_lock);\n\t\t\tath9k_skb_queue_purge(hif_dev, &tx_buf->skb_queue);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&hif_dev->tx.tx_lock);\n\n\t\tbreak;\n\tdefault:\n\t\ttxok = false;\n\t\tbreak;\n\t}\n\n\tath9k_skb_queue_complete(hif_dev, &tx_buf->skb_queue, txok);\n\n\t \n\ttx_buf->len = tx_buf->offset = 0;\n\t__skb_queue_head_init(&tx_buf->skb_queue);\n\n\t \n\tspin_lock(&hif_dev->tx.tx_lock);\n\tlist_move_tail(&tx_buf->list, &hif_dev->tx.tx_buf);\n\thif_dev->tx.tx_buf_cnt++;\n\tif (!(hif_dev->tx.flags & HIF_USB_TX_STOP))\n\t\t__hif_usb_tx(hif_dev);  \n\tTX_STAT_INC(hif_dev, buf_completed);\n\tspin_unlock(&hif_dev->tx.tx_lock);\n}\n\n \nstatic int __hif_usb_tx(struct hif_device_usb *hif_dev)\n{\n\tstruct tx_buf *tx_buf = NULL;\n\tstruct sk_buff *nskb = NULL;\n\tint ret = 0, i;\n\tu16 tx_skb_cnt = 0;\n\tu8 *buf;\n\t__le16 *hdr;\n\n\tif (hif_dev->tx.tx_skb_cnt == 0)\n\t\treturn 0;\n\n\t \n\tif (list_empty(&hif_dev->tx.tx_buf))\n\t\treturn 0;\n\n\ttx_buf = list_first_entry(&hif_dev->tx.tx_buf, struct tx_buf, list);\n\tlist_move_tail(&tx_buf->list, &hif_dev->tx.tx_pending);\n\thif_dev->tx.tx_buf_cnt--;\n\n\ttx_skb_cnt = min_t(u16, hif_dev->tx.tx_skb_cnt, MAX_TX_AGGR_NUM);\n\n\tfor (i = 0; i < tx_skb_cnt; i++) {\n\t\tnskb = __skb_dequeue(&hif_dev->tx.tx_skb_queue);\n\n\t\t \n\t\tBUG_ON(!nskb);\n\n\t\thif_dev->tx.tx_skb_cnt--;\n\n\t\tbuf = tx_buf->buf;\n\t\tbuf += tx_buf->offset;\n\t\thdr = (__le16 *)buf;\n\t\t*hdr++ = cpu_to_le16(nskb->len);\n\t\t*hdr++ = cpu_to_le16(ATH_USB_TX_STREAM_MODE_TAG);\n\t\tbuf += 4;\n\t\tmemcpy(buf, nskb->data, nskb->len);\n\t\ttx_buf->len = nskb->len + 4;\n\n\t\tif (i < (tx_skb_cnt - 1))\n\t\t\ttx_buf->offset += (((tx_buf->len - 1) / 4) + 1) * 4;\n\n\t\tif (i == (tx_skb_cnt - 1))\n\t\t\ttx_buf->len += tx_buf->offset;\n\n\t\t__skb_queue_tail(&tx_buf->skb_queue, nskb);\n\t\tTX_STAT_INC(hif_dev, skb_queued);\n\t}\n\n\tusb_fill_bulk_urb(tx_buf->urb, hif_dev->udev,\n\t\t\t  usb_sndbulkpipe(hif_dev->udev, USB_WLAN_TX_PIPE),\n\t\t\t  tx_buf->buf, tx_buf->len,\n\t\t\t  hif_usb_tx_cb, tx_buf);\n\n\tret = usb_submit_urb(tx_buf->urb, GFP_ATOMIC);\n\tif (ret) {\n\t\ttx_buf->len = tx_buf->offset = 0;\n\t\tath9k_skb_queue_complete(hif_dev, &tx_buf->skb_queue, false);\n\t\t__skb_queue_head_init(&tx_buf->skb_queue);\n\t\tlist_move_tail(&tx_buf->list, &hif_dev->tx.tx_buf);\n\t\thif_dev->tx.tx_buf_cnt++;\n\t} else {\n\t\tTX_STAT_INC(hif_dev, buf_queued);\n\t}\n\n\treturn ret;\n}\n\nstatic int hif_usb_send_tx(struct hif_device_usb *hif_dev, struct sk_buff *skb)\n{\n\tstruct ath9k_htc_tx_ctl *tx_ctl;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&hif_dev->tx.tx_lock, flags);\n\n\tif (hif_dev->tx.flags & HIF_USB_TX_STOP) {\n\t\tspin_unlock_irqrestore(&hif_dev->tx.tx_lock, flags);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (hif_dev->tx.tx_skb_cnt > MAX_TX_BUF_NUM) {\n\t\tspin_unlock_irqrestore(&hif_dev->tx.tx_lock, flags);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_unlock_irqrestore(&hif_dev->tx.tx_lock, flags);\n\n\ttx_ctl = HTC_SKB_CB(skb);\n\n\t \n\tif ((tx_ctl->type == ATH9K_HTC_MGMT) ||\n\t    (tx_ctl->type == ATH9K_HTC_BEACON)) {\n\t\tret = hif_usb_send_mgmt(hif_dev, skb);\n\t}\n\n\tspin_lock_irqsave(&hif_dev->tx.tx_lock, flags);\n\n\tif ((tx_ctl->type == ATH9K_HTC_NORMAL) ||\n\t    (tx_ctl->type == ATH9K_HTC_AMPDU)) {\n\t\t__skb_queue_tail(&hif_dev->tx.tx_skb_queue, skb);\n\t\thif_dev->tx.tx_skb_cnt++;\n\t}\n\n\t \n\tif ((hif_dev->tx.tx_buf_cnt == MAX_TX_URB_NUM) &&\n\t    (hif_dev->tx.tx_skb_cnt < 2)) {\n\t\t__hif_usb_tx(hif_dev);\n\t}\n\n\tspin_unlock_irqrestore(&hif_dev->tx.tx_lock, flags);\n\n\treturn ret;\n}\n\nstatic void hif_usb_start(void *hif_handle)\n{\n\tstruct hif_device_usb *hif_dev = hif_handle;\n\tunsigned long flags;\n\n\thif_dev->flags |= HIF_USB_START;\n\n\tspin_lock_irqsave(&hif_dev->tx.tx_lock, flags);\n\thif_dev->tx.flags &= ~HIF_USB_TX_STOP;\n\tspin_unlock_irqrestore(&hif_dev->tx.tx_lock, flags);\n}\n\nstatic void hif_usb_stop(void *hif_handle)\n{\n\tstruct hif_device_usb *hif_dev = hif_handle;\n\tstruct tx_buf *tx_buf = NULL, *tx_buf_tmp = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hif_dev->tx.tx_lock, flags);\n\tath9k_skb_queue_complete(hif_dev, &hif_dev->tx.tx_skb_queue, false);\n\thif_dev->tx.tx_skb_cnt = 0;\n\thif_dev->tx.flags |= HIF_USB_TX_STOP;\n\tspin_unlock_irqrestore(&hif_dev->tx.tx_lock, flags);\n\n\t \n\tspin_lock_irqsave(&hif_dev->tx.tx_lock, flags);\n\tlist_for_each_entry_safe(tx_buf, tx_buf_tmp,\n\t\t\t\t &hif_dev->tx.tx_pending, list) {\n\t\tusb_get_urb(tx_buf->urb);\n\t\tspin_unlock_irqrestore(&hif_dev->tx.tx_lock, flags);\n\t\tusb_kill_urb(tx_buf->urb);\n\t\tlist_del(&tx_buf->list);\n\t\tusb_free_urb(tx_buf->urb);\n\t\tkfree(tx_buf->buf);\n\t\tkfree(tx_buf);\n\t\tspin_lock_irqsave(&hif_dev->tx.tx_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&hif_dev->tx.tx_lock, flags);\n\n\tusb_kill_anchored_urbs(&hif_dev->mgmt_submitted);\n}\n\nstatic int hif_usb_send(void *hif_handle, u8 pipe_id, struct sk_buff *skb)\n{\n\tstruct hif_device_usb *hif_dev = hif_handle;\n\tint ret = 0;\n\n\tswitch (pipe_id) {\n\tcase USB_WLAN_TX_PIPE:\n\t\tret = hif_usb_send_tx(hif_dev, skb);\n\t\tbreak;\n\tcase USB_REG_OUT_PIPE:\n\t\tret = hif_usb_send_regout(hif_dev, skb);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&hif_dev->udev->dev,\n\t\t\t\"ath9k_htc: Invalid TX pipe: %d\\n\", pipe_id);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic inline bool check_index(struct sk_buff *skb, u8 idx)\n{\n\tstruct ath9k_htc_tx_ctl *tx_ctl;\n\n\ttx_ctl = HTC_SKB_CB(skb);\n\n\tif ((tx_ctl->type == ATH9K_HTC_AMPDU) &&\n\t    (tx_ctl->sta_idx == idx))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void hif_usb_sta_drain(void *hif_handle, u8 idx)\n{\n\tstruct hif_device_usb *hif_dev = hif_handle;\n\tstruct sk_buff *skb, *tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hif_dev->tx.tx_lock, flags);\n\n\tskb_queue_walk_safe(&hif_dev->tx.tx_skb_queue, skb, tmp) {\n\t\tif (check_index(skb, idx)) {\n\t\t\t__skb_unlink(skb, &hif_dev->tx.tx_skb_queue);\n\t\t\tath9k_htc_txcompletion_cb(hif_dev->htc_handle,\n\t\t\t\t\t\t  skb, false);\n\t\t\thif_dev->tx.tx_skb_cnt--;\n\t\t\tTX_STAT_INC(hif_dev, skb_failed);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&hif_dev->tx.tx_lock, flags);\n}\n\nstatic struct ath9k_htc_hif hif_usb = {\n\t.transport = ATH9K_HIF_USB,\n\t.name = \"ath9k_hif_usb\",\n\n\t.control_ul_pipe = USB_REG_OUT_PIPE,\n\t.control_dl_pipe = USB_REG_IN_PIPE,\n\n\t.start = hif_usb_start,\n\t.stop = hif_usb_stop,\n\t.sta_drain = hif_usb_sta_drain,\n\t.send = hif_usb_send,\n};\n\n \nstatic void ath9k_hif_usb_free_rx_remain_skb(struct hif_device_usb *hif_dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hif_dev->rx_lock, flags);\n\tif (hif_dev->remain_skb) {\n\t\tdev_kfree_skb_any(hif_dev->remain_skb);\n\t\thif_dev->remain_skb = NULL;\n\t\thif_dev->rx_remain_len = 0;\n\t\tRX_STAT_INC(hif_dev, skb_dropped);\n\t}\n\tspin_unlock_irqrestore(&hif_dev->rx_lock, flags);\n}\n\nstatic void ath9k_hif_usb_rx_stream(struct hif_device_usb *hif_dev,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct sk_buff *nskb, *skb_pool[MAX_PKT_NUM_IN_TRANSFER];\n\tint index = 0, i, len = skb->len;\n\tint rx_remain_len, rx_pkt_len;\n\tu16 pool_index = 0;\n\tu8 *ptr;\n\n\tspin_lock(&hif_dev->rx_lock);\n\n\trx_remain_len = hif_dev->rx_remain_len;\n\trx_pkt_len = hif_dev->rx_transfer_len;\n\n\tif (rx_remain_len != 0) {\n\t\tstruct sk_buff *remain_skb = hif_dev->remain_skb;\n\n\t\tif (remain_skb) {\n\t\t\tptr = (u8 *) remain_skb->data;\n\n\t\t\tindex = rx_remain_len;\n\t\t\trx_remain_len -= hif_dev->rx_pad_len;\n\t\t\tptr += rx_pkt_len;\n\n\t\t\tmemcpy(ptr, skb->data, rx_remain_len);\n\n\t\t\trx_pkt_len += rx_remain_len;\n\t\t\tskb_put(remain_skb, rx_pkt_len);\n\n\t\t\tskb_pool[pool_index++] = remain_skb;\n\t\t\thif_dev->remain_skb = NULL;\n\t\t\thif_dev->rx_remain_len = 0;\n\t\t} else {\n\t\t\tindex = rx_remain_len;\n\t\t}\n\t}\n\n\tspin_unlock(&hif_dev->rx_lock);\n\n\twhile (index < len) {\n\t\tu16 pkt_len;\n\t\tu16 pkt_tag;\n\t\tu16 pad_len;\n\t\tint chk_idx;\n\n\t\tptr = (u8 *) skb->data;\n\n\t\tpkt_len = get_unaligned_le16(ptr + index);\n\t\tpkt_tag = get_unaligned_le16(ptr + index + 2);\n\n\t\t \n\t\tif (pkt_tag != ATH_USB_RX_STREAM_MODE_TAG) {\n\t\t\tRX_STAT_INC(hif_dev, skb_dropped);\n\t\t\tgoto invalid_pkt;\n\t\t}\n\n\t\tif (pkt_len > 2 * MAX_RX_BUF_SIZE) {\n\t\t\tdev_err(&hif_dev->udev->dev,\n\t\t\t\t\"ath9k_htc: invalid pkt_len (%x)\\n\", pkt_len);\n\t\t\tRX_STAT_INC(hif_dev, skb_dropped);\n\t\t\tgoto invalid_pkt;\n\t\t}\n\n\t\tpad_len = 4 - (pkt_len & 0x3);\n\t\tif (pad_len == 4)\n\t\t\tpad_len = 0;\n\n\t\tchk_idx = index;\n\t\tindex = index + 4 + pkt_len + pad_len;\n\n\t\tif (index > MAX_RX_BUF_SIZE) {\n\t\t\tspin_lock(&hif_dev->rx_lock);\n\t\t\tnskb = __dev_alloc_skb(pkt_len + 32, GFP_ATOMIC);\n\t\t\tif (!nskb) {\n\t\t\t\tdev_err(&hif_dev->udev->dev,\n\t\t\t\t\t\"ath9k_htc: RX memory allocation error\\n\");\n\t\t\t\tspin_unlock(&hif_dev->rx_lock);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\thif_dev->rx_remain_len = index - MAX_RX_BUF_SIZE;\n\t\t\thif_dev->rx_transfer_len =\n\t\t\t\tMAX_RX_BUF_SIZE - chk_idx - 4;\n\t\t\thif_dev->rx_pad_len = pad_len;\n\n\t\t\tskb_reserve(nskb, 32);\n\t\t\tRX_STAT_INC(hif_dev, skb_allocated);\n\n\t\t\tmemcpy(nskb->data, &(skb->data[chk_idx+4]),\n\t\t\t       hif_dev->rx_transfer_len);\n\n\t\t\t \n\t\t\thif_dev->remain_skb = nskb;\n\t\t\tspin_unlock(&hif_dev->rx_lock);\n\t\t} else {\n\t\t\tif (pool_index == MAX_PKT_NUM_IN_TRANSFER) {\n\t\t\t\tdev_err(&hif_dev->udev->dev,\n\t\t\t\t\t\"ath9k_htc: over RX MAX_PKT_NUM\\n\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tnskb = __dev_alloc_skb(pkt_len + 32, GFP_ATOMIC);\n\t\t\tif (!nskb) {\n\t\t\t\tdev_err(&hif_dev->udev->dev,\n\t\t\t\t\t\"ath9k_htc: RX memory allocation error\\n\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tskb_reserve(nskb, 32);\n\t\t\tRX_STAT_INC(hif_dev, skb_allocated);\n\n\t\t\tmemcpy(nskb->data, &(skb->data[chk_idx+4]), pkt_len);\n\t\t\tskb_put(nskb, pkt_len);\n\t\t\tskb_pool[pool_index++] = nskb;\n\t\t}\n\t}\n\nerr:\n\tfor (i = 0; i < pool_index; i++) {\n\t\tRX_STAT_ADD(hif_dev, skb_completed_bytes, skb_pool[i]->len);\n\t\tath9k_htc_rx_msg(hif_dev->htc_handle, skb_pool[i],\n\t\t\t\t skb_pool[i]->len, USB_WLAN_RX_PIPE);\n\t\tRX_STAT_INC(hif_dev, skb_completed);\n\t}\n\treturn;\ninvalid_pkt:\n\tfor (i = 0; i < pool_index; i++) {\n\t\tdev_kfree_skb_any(skb_pool[i]);\n\t\tRX_STAT_INC(hif_dev, skb_dropped);\n\t}\n\treturn;\n}\n\nstatic void ath9k_hif_usb_rx_cb(struct urb *urb)\n{\n\tstruct rx_buf *rx_buf = (struct rx_buf *)urb->context;\n\tstruct hif_device_usb *hif_dev = rx_buf->hif_dev;\n\tstruct sk_buff *skb = rx_buf->skb;\n\tint ret;\n\n\tif (!skb)\n\t\treturn;\n\n\tif (!hif_dev)\n\t\tgoto free;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ENODEV:\n\tcase -ESHUTDOWN:\n\t\tgoto free;\n\tdefault:\n\t\tgoto resubmit;\n\t}\n\n\tif (likely(urb->actual_length != 0)) {\n\t\tskb_put(skb, urb->actual_length);\n\t\tath9k_hif_usb_rx_stream(hif_dev, skb);\n\t}\n\nresubmit:\n\tskb_reset_tail_pointer(skb);\n\tskb_trim(skb, 0);\n\n\tusb_anchor_urb(urb, &hif_dev->rx_submitted);\n\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (ret) {\n\t\tusb_unanchor_urb(urb);\n\t\tgoto free;\n\t}\n\n\treturn;\nfree:\n\tkfree_skb(skb);\n\tkfree(rx_buf);\n}\n\nstatic void ath9k_hif_usb_reg_in_cb(struct urb *urb)\n{\n\tstruct rx_buf *rx_buf = (struct rx_buf *)urb->context;\n\tstruct hif_device_usb *hif_dev = rx_buf->hif_dev;\n\tstruct sk_buff *skb = rx_buf->skb;\n\tint ret;\n\n\tif (!skb)\n\t\treturn;\n\n\tif (!hif_dev)\n\t\tgoto free_skb;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ENODEV:\n\tcase -ESHUTDOWN:\n\t\tgoto free_skb;\n\tdefault:\n\t\tskb_reset_tail_pointer(skb);\n\t\tskb_trim(skb, 0);\n\n\t\tgoto resubmit;\n\t}\n\n\tif (likely(urb->actual_length != 0)) {\n\t\tskb_put(skb, urb->actual_length);\n\n\t\t \n\t\tath9k_htc_rx_msg(hif_dev->htc_handle, skb,\n\t\t\t\t skb->len, USB_REG_IN_PIPE);\n\n\t\tskb = alloc_skb(MAX_REG_IN_BUF_SIZE, GFP_ATOMIC);\n\t\tif (!skb) {\n\t\t\tdev_err(&hif_dev->udev->dev,\n\t\t\t\t\"ath9k_htc: REG_IN memory allocation failure\\n\");\n\t\t\tgoto free_rx_buf;\n\t\t}\n\n\t\trx_buf->skb = skb;\n\n\t\tusb_fill_int_urb(urb, hif_dev->udev,\n\t\t\t\t usb_rcvintpipe(hif_dev->udev,\n\t\t\t\t\t\t USB_REG_IN_PIPE),\n\t\t\t\t skb->data, MAX_REG_IN_BUF_SIZE,\n\t\t\t\t ath9k_hif_usb_reg_in_cb, rx_buf, 1);\n\t}\n\nresubmit:\n\tusb_anchor_urb(urb, &hif_dev->reg_in_submitted);\n\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (ret) {\n\t\tusb_unanchor_urb(urb);\n\t\tgoto free_skb;\n\t}\n\n\treturn;\nfree_skb:\n\tkfree_skb(skb);\nfree_rx_buf:\n\tkfree(rx_buf);\n\turb->context = NULL;\n}\n\nstatic void ath9k_hif_usb_dealloc_tx_urbs(struct hif_device_usb *hif_dev)\n{\n\tstruct tx_buf *tx_buf = NULL, *tx_buf_tmp = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hif_dev->tx.tx_lock, flags);\n\tlist_for_each_entry_safe(tx_buf, tx_buf_tmp,\n\t\t\t\t &hif_dev->tx.tx_buf, list) {\n\t\tlist_del(&tx_buf->list);\n\t\tusb_free_urb(tx_buf->urb);\n\t\tkfree(tx_buf->buf);\n\t\tkfree(tx_buf);\n\t}\n\tspin_unlock_irqrestore(&hif_dev->tx.tx_lock, flags);\n\n\tspin_lock_irqsave(&hif_dev->tx.tx_lock, flags);\n\thif_dev->tx.flags |= HIF_USB_TX_FLUSH;\n\tspin_unlock_irqrestore(&hif_dev->tx.tx_lock, flags);\n\n\tspin_lock_irqsave(&hif_dev->tx.tx_lock, flags);\n\tlist_for_each_entry_safe(tx_buf, tx_buf_tmp,\n\t\t\t\t &hif_dev->tx.tx_pending, list) {\n\t\tusb_get_urb(tx_buf->urb);\n\t\tspin_unlock_irqrestore(&hif_dev->tx.tx_lock, flags);\n\t\tusb_kill_urb(tx_buf->urb);\n\t\tlist_del(&tx_buf->list);\n\t\tusb_free_urb(tx_buf->urb);\n\t\tkfree(tx_buf->buf);\n\t\tkfree(tx_buf);\n\t\tspin_lock_irqsave(&hif_dev->tx.tx_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&hif_dev->tx.tx_lock, flags);\n\n\tusb_kill_anchored_urbs(&hif_dev->mgmt_submitted);\n}\n\nstatic int ath9k_hif_usb_alloc_tx_urbs(struct hif_device_usb *hif_dev)\n{\n\tstruct tx_buf *tx_buf;\n\tint i;\n\n\tINIT_LIST_HEAD(&hif_dev->tx.tx_buf);\n\tINIT_LIST_HEAD(&hif_dev->tx.tx_pending);\n\tspin_lock_init(&hif_dev->tx.tx_lock);\n\t__skb_queue_head_init(&hif_dev->tx.tx_skb_queue);\n\tinit_usb_anchor(&hif_dev->mgmt_submitted);\n\n\tfor (i = 0; i < MAX_TX_URB_NUM; i++) {\n\t\ttx_buf = kzalloc(sizeof(*tx_buf), GFP_KERNEL);\n\t\tif (!tx_buf)\n\t\t\tgoto err;\n\n\t\ttx_buf->buf = kzalloc(MAX_TX_BUF_SIZE, GFP_KERNEL);\n\t\tif (!tx_buf->buf)\n\t\t\tgoto err;\n\n\t\ttx_buf->urb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!tx_buf->urb)\n\t\t\tgoto err;\n\n\t\ttx_buf->hif_dev = hif_dev;\n\t\t__skb_queue_head_init(&tx_buf->skb_queue);\n\n\t\tlist_add_tail(&tx_buf->list, &hif_dev->tx.tx_buf);\n\t}\n\n\thif_dev->tx.tx_buf_cnt = MAX_TX_URB_NUM;\n\n\treturn 0;\nerr:\n\tif (tx_buf) {\n\t\tkfree(tx_buf->buf);\n\t\tkfree(tx_buf);\n\t}\n\tath9k_hif_usb_dealloc_tx_urbs(hif_dev);\n\treturn -ENOMEM;\n}\n\nstatic void ath9k_hif_usb_dealloc_rx_urbs(struct hif_device_usb *hif_dev)\n{\n\tusb_kill_anchored_urbs(&hif_dev->rx_submitted);\n\tath9k_hif_usb_free_rx_remain_skb(hif_dev);\n}\n\nstatic int ath9k_hif_usb_alloc_rx_urbs(struct hif_device_usb *hif_dev)\n{\n\tstruct rx_buf *rx_buf = NULL;\n\tstruct sk_buff *skb = NULL;\n\tstruct urb *urb = NULL;\n\tint i, ret;\n\n\tinit_usb_anchor(&hif_dev->rx_submitted);\n\tspin_lock_init(&hif_dev->rx_lock);\n\n\tfor (i = 0; i < MAX_RX_URB_NUM; i++) {\n\n\t\trx_buf = kzalloc(sizeof(*rx_buf), GFP_KERNEL);\n\t\tif (!rx_buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_rxb;\n\t\t}\n\n\t\t \n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (urb == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_urb;\n\t\t}\n\n\t\t \n\t\tskb = alloc_skb(MAX_RX_BUF_SIZE, GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_skb;\n\t\t}\n\n\t\trx_buf->hif_dev = hif_dev;\n\t\trx_buf->skb = skb;\n\n\t\tusb_fill_bulk_urb(urb, hif_dev->udev,\n\t\t\t\t  usb_rcvbulkpipe(hif_dev->udev,\n\t\t\t\t\t\t  USB_WLAN_RX_PIPE),\n\t\t\t\t  skb->data, MAX_RX_BUF_SIZE,\n\t\t\t\t  ath9k_hif_usb_rx_cb, rx_buf);\n\n\t\t \n\t\tusb_anchor_urb(urb, &hif_dev->rx_submitted);\n\n\t\t \n\t\tret = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (ret) {\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tgoto err_submit;\n\t\t}\n\n\t\t \n\t\tusb_free_urb(urb);\n\t}\n\n\treturn 0;\n\nerr_submit:\n\tkfree_skb(skb);\nerr_skb:\n\tusb_free_urb(urb);\nerr_urb:\n\tkfree(rx_buf);\nerr_rxb:\n\tath9k_hif_usb_dealloc_rx_urbs(hif_dev);\n\treturn ret;\n}\n\nstatic void ath9k_hif_usb_dealloc_reg_in_urbs(struct hif_device_usb *hif_dev)\n{\n\tusb_kill_anchored_urbs(&hif_dev->reg_in_submitted);\n}\n\nstatic int ath9k_hif_usb_alloc_reg_in_urbs(struct hif_device_usb *hif_dev)\n{\n\tstruct rx_buf *rx_buf = NULL;\n\tstruct sk_buff *skb = NULL;\n\tstruct urb *urb = NULL;\n\tint i, ret;\n\n\tinit_usb_anchor(&hif_dev->reg_in_submitted);\n\n\tfor (i = 0; i < MAX_REG_IN_URB_NUM; i++) {\n\n\t\trx_buf = kzalloc(sizeof(*rx_buf), GFP_KERNEL);\n\t\tif (!rx_buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_rxb;\n\t\t}\n\n\t\t \n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (urb == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_urb;\n\t\t}\n\n\t\t \n\t\tskb = alloc_skb(MAX_REG_IN_BUF_SIZE, GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_skb;\n\t\t}\n\n\t\trx_buf->hif_dev = hif_dev;\n\t\trx_buf->skb = skb;\n\n\t\tusb_fill_int_urb(urb, hif_dev->udev,\n\t\t\t\t  usb_rcvintpipe(hif_dev->udev,\n\t\t\t\t\t\t  USB_REG_IN_PIPE),\n\t\t\t\t  skb->data, MAX_REG_IN_BUF_SIZE,\n\t\t\t\t  ath9k_hif_usb_reg_in_cb, rx_buf, 1);\n\n\t\t \n\t\tusb_anchor_urb(urb, &hif_dev->reg_in_submitted);\n\n\t\t \n\t\tret = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (ret) {\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tgoto err_submit;\n\t\t}\n\n\t\t \n\t\tusb_free_urb(urb);\n\t}\n\n\treturn 0;\n\nerr_submit:\n\tkfree_skb(skb);\nerr_skb:\n\tusb_free_urb(urb);\nerr_urb:\n\tkfree(rx_buf);\nerr_rxb:\n\tath9k_hif_usb_dealloc_reg_in_urbs(hif_dev);\n\treturn ret;\n}\n\nstatic int ath9k_hif_usb_alloc_urbs(struct hif_device_usb *hif_dev)\n{\n\t \n\tinit_usb_anchor(&hif_dev->regout_submitted);\n\n\t \n\tif (ath9k_hif_usb_alloc_tx_urbs(hif_dev) < 0)\n\t\tgoto err;\n\n\t \n\tif (ath9k_hif_usb_alloc_rx_urbs(hif_dev) < 0)\n\t\tgoto err_rx;\n\n\t \n\tif (ath9k_hif_usb_alloc_reg_in_urbs(hif_dev) < 0)\n\t\tgoto err_reg;\n\n\treturn 0;\nerr_reg:\n\tath9k_hif_usb_dealloc_rx_urbs(hif_dev);\nerr_rx:\n\tath9k_hif_usb_dealloc_tx_urbs(hif_dev);\nerr:\n\treturn -ENOMEM;\n}\n\nvoid ath9k_hif_usb_dealloc_urbs(struct hif_device_usb *hif_dev)\n{\n\tusb_kill_anchored_urbs(&hif_dev->regout_submitted);\n\tath9k_hif_usb_dealloc_reg_in_urbs(hif_dev);\n\tath9k_hif_usb_dealloc_tx_urbs(hif_dev);\n\tath9k_hif_usb_dealloc_rx_urbs(hif_dev);\n}\n\nstatic int ath9k_hif_usb_download_fw(struct hif_device_usb *hif_dev)\n{\n\tint transfer, err;\n\tconst void *data = hif_dev->fw_data;\n\tsize_t len = hif_dev->fw_size;\n\tu32 addr = AR9271_FIRMWARE;\n\tu8 *buf = kzalloc(4096, GFP_KERNEL);\n\tu32 firm_offset;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\twhile (len) {\n\t\ttransfer = min_t(size_t, len, 4096);\n\t\tmemcpy(buf, data, transfer);\n\n\t\terr = usb_control_msg(hif_dev->udev,\n\t\t\t\t      usb_sndctrlpipe(hif_dev->udev, 0),\n\t\t\t\t      FIRMWARE_DOWNLOAD, 0x40 | USB_DIR_OUT,\n\t\t\t\t      addr >> 8, 0, buf, transfer,\n\t\t\t\t      USB_MSG_TIMEOUT);\n\t\tif (err < 0) {\n\t\t\tkfree(buf);\n\t\t\treturn err;\n\t\t}\n\n\t\tlen -= transfer;\n\t\tdata += transfer;\n\t\taddr += transfer;\n\t}\n\tkfree(buf);\n\n\tif (IS_AR7010_DEVICE(hif_dev->usb_device_id->driver_info))\n\t\tfirm_offset = AR7010_FIRMWARE_TEXT;\n\telse\n\t\tfirm_offset = AR9271_FIRMWARE_TEXT;\n\n\t \n\terr = usb_control_msg(hif_dev->udev, usb_sndctrlpipe(hif_dev->udev, 0),\n\t\t\t      FIRMWARE_DOWNLOAD_COMP,\n\t\t\t      0x40 | USB_DIR_OUT,\n\t\t\t      firm_offset >> 8, 0, NULL, 0, USB_MSG_TIMEOUT);\n\tif (err)\n\t\treturn -EIO;\n\n\tdev_info(&hif_dev->udev->dev, \"ath9k_htc: Transferred FW: %s, size: %ld\\n\",\n\t\t hif_dev->fw_name, (unsigned long) hif_dev->fw_size);\n\n\treturn 0;\n}\n\nstatic int ath9k_hif_usb_dev_init(struct hif_device_usb *hif_dev)\n{\n\tint ret;\n\n\tret = ath9k_hif_usb_download_fw(hif_dev);\n\tif (ret) {\n\t\tdev_err(&hif_dev->udev->dev,\n\t\t\t\"ath9k_htc: Firmware - %s download failed\\n\",\n\t\t\thif_dev->fw_name);\n\t\treturn ret;\n\t}\n\n\t \n\tret = ath9k_hif_usb_alloc_urbs(hif_dev);\n\tif (ret) {\n\t\tdev_err(&hif_dev->udev->dev,\n\t\t\t\"ath9k_htc: Unable to allocate URBs\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ath9k_hif_usb_dev_deinit(struct hif_device_usb *hif_dev)\n{\n\tath9k_hif_usb_dealloc_urbs(hif_dev);\n}\n\n \nstatic void ath9k_hif_usb_firmware_fail(struct hif_device_usb *hif_dev)\n{\n\tstruct device *dev = &hif_dev->udev->dev;\n\tstruct device *parent = dev->parent;\n\n\tcomplete_all(&hif_dev->fw_done);\n\n\tif (parent)\n\t\tdevice_lock(parent);\n\n\tdevice_release_driver(dev);\n\n\tif (parent)\n\t\tdevice_unlock(parent);\n}\n\nstatic void ath9k_hif_usb_firmware_cb(const struct firmware *fw, void *context);\n\n \nstatic int ath9k_hif_request_firmware(struct hif_device_usb *hif_dev,\n\t\t\t\t      bool first)\n{\n\tchar index[8], *chip;\n\tint ret;\n\n\tif (first) {\n\t\tif (htc_use_dev_fw) {\n\t\t\thif_dev->fw_minor_index = FIRMWARE_MINOR_IDX_MAX + 1;\n\t\t\tsprintf(index, \"%s\", \"dev\");\n\t\t} else {\n\t\t\thif_dev->fw_minor_index = FIRMWARE_MINOR_IDX_MAX;\n\t\t\tsprintf(index, \"%d\", hif_dev->fw_minor_index);\n\t\t}\n\t} else {\n\t\thif_dev->fw_minor_index--;\n\t\tsprintf(index, \"%d\", hif_dev->fw_minor_index);\n\t}\n\n\t \n\tif (MAJOR_VERSION_REQ == 1 && hif_dev->fw_minor_index == 3) {\n\t\tconst char *filename;\n\n\t\tif (IS_AR7010_DEVICE(hif_dev->usb_device_id->driver_info))\n\t\t\tfilename = FIRMWARE_AR7010_1_1;\n\t\telse\n\t\t\tfilename = FIRMWARE_AR9271;\n\n\t\t \n\t\tsnprintf(hif_dev->fw_name, sizeof(hif_dev->fw_name),\n\t\t\t \"%s\", filename);\n\n\t} else if (hif_dev->fw_minor_index < FIRMWARE_MINOR_IDX_MIN) {\n\t\tdev_err(&hif_dev->udev->dev, \"no suitable firmware found!\\n\");\n\n\t\treturn -ENOENT;\n\t} else {\n\t\tif (IS_AR7010_DEVICE(hif_dev->usb_device_id->driver_info))\n\t\t\tchip = \"7010\";\n\t\telse\n\t\t\tchip = \"9271\";\n\n\t\t \n\t\tsnprintf(hif_dev->fw_name, sizeof(hif_dev->fw_name),\n\t\t\t \"%s/htc_%s-%d.%s.0.fw\", HTC_FW_PATH,\n\t\t\t chip, MAJOR_VERSION_REQ, index);\n\t}\n\n\tret = request_firmware_nowait(THIS_MODULE, true, hif_dev->fw_name,\n\t\t\t\t      &hif_dev->udev->dev, GFP_KERNEL,\n\t\t\t\t      hif_dev, ath9k_hif_usb_firmware_cb);\n\tif (ret) {\n\t\tdev_err(&hif_dev->udev->dev,\n\t\t\t\"ath9k_htc: Async request for firmware %s failed\\n\",\n\t\t\thif_dev->fw_name);\n\t\treturn ret;\n\t}\n\n\tdev_info(&hif_dev->udev->dev, \"ath9k_htc: Firmware %s requested\\n\",\n\t\t hif_dev->fw_name);\n\n\treturn ret;\n}\n\nstatic void ath9k_hif_usb_firmware_cb(const struct firmware *fw, void *context)\n{\n\tstruct hif_device_usb *hif_dev = context;\n\tint ret;\n\n\tif (!fw) {\n\t\tret = ath9k_hif_request_firmware(hif_dev, false);\n\t\tif (!ret)\n\t\t\treturn;\n\n\t\tdev_err(&hif_dev->udev->dev,\n\t\t\t\"ath9k_htc: Failed to get firmware %s\\n\",\n\t\t\thif_dev->fw_name);\n\t\tgoto err_fw;\n\t}\n\n\thif_dev->htc_handle = ath9k_htc_hw_alloc(hif_dev, &hif_usb,\n\t\t\t\t\t\t &hif_dev->udev->dev);\n\tif (hif_dev->htc_handle == NULL)\n\t\tgoto err_dev_alloc;\n\n\thif_dev->fw_data = fw->data;\n\thif_dev->fw_size = fw->size;\n\n\t \n\n\tret = ath9k_hif_usb_dev_init(hif_dev);\n\tif (ret)\n\t\tgoto err_dev_init;\n\n\tret = ath9k_htc_hw_init(hif_dev->htc_handle,\n\t\t\t\t&hif_dev->interface->dev,\n\t\t\t\thif_dev->usb_device_id->idProduct,\n\t\t\t\thif_dev->udev->product,\n\t\t\t\thif_dev->usb_device_id->driver_info);\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tgoto err_htc_hw_init;\n\t}\n\n\trelease_firmware(fw);\n\thif_dev->flags |= HIF_USB_READY;\n\tcomplete_all(&hif_dev->fw_done);\n\n\treturn;\n\nerr_htc_hw_init:\n\tath9k_hif_usb_dev_deinit(hif_dev);\nerr_dev_init:\n\tath9k_htc_hw_free(hif_dev->htc_handle);\nerr_dev_alloc:\n\trelease_firmware(fw);\nerr_fw:\n\tath9k_hif_usb_firmware_fail(hif_dev);\n}\n\n \nstatic int send_eject_command(struct usb_interface *interface)\n{\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct usb_host_interface *iface_desc = interface->cur_altsetting;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tunsigned char *cmd;\n\tu8 bulk_out_ep;\n\tint r;\n\n\tif (iface_desc->desc.bNumEndpoints < 2)\n\t\treturn -ENODEV;\n\n\t \n\tfor (r = 1; r >= 0; r--) {\n\t\tendpoint = &iface_desc->endpoint[r].desc;\n\t\tif (usb_endpoint_dir_out(endpoint) &&\n\t\t    usb_endpoint_xfer_bulk(endpoint)) {\n\t\t\tbulk_out_ep = endpoint->bEndpointAddress;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (r == -1) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"ath9k_htc: Could not find bulk out endpoint\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tcmd = kzalloc(31, GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tcmd[0] = 0x55;\t \n\tcmd[1] = 0x53;\t \n\tcmd[2] = 0x42;\t \n\tcmd[3] = 0x43;\t \n\tcmd[14] = 6;\t \n\n\tcmd[15] = 0x1b;\t \n\tcmd[19] = 0x2;\t \n\n\tdev_info(&udev->dev, \"Ejecting storage device...\\n\");\n\tr = usb_bulk_msg(udev, usb_sndbulkpipe(udev, bulk_out_ep),\n\t\tcmd, 31, NULL, 2 * USB_MSG_TIMEOUT);\n\tkfree(cmd);\n\tif (r)\n\t\treturn r;\n\n\t \n\n\tusb_set_intfdata(interface, NULL);\n\treturn 0;\n}\n\nstatic int ath9k_hif_usb_probe(struct usb_interface *interface,\n\t\t\t       const struct usb_device_id *id)\n{\n\tstruct usb_endpoint_descriptor *bulk_in, *bulk_out, *int_in, *int_out;\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct usb_host_interface *alt;\n\tstruct hif_device_usb *hif_dev;\n\tint ret = 0;\n\n\t \n\talt = interface->cur_altsetting;\n\tif (usb_find_common_endpoints(alt, &bulk_in, &bulk_out, &int_in, &int_out) < 0 ||\n\t    usb_endpoint_num(bulk_in) != USB_WLAN_RX_PIPE ||\n\t    usb_endpoint_num(bulk_out) != USB_WLAN_TX_PIPE ||\n\t    usb_endpoint_num(int_in) != USB_REG_IN_PIPE ||\n\t    usb_endpoint_num(int_out) != USB_REG_OUT_PIPE) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"ath9k_htc: Device endpoint numbers are not the expected ones\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (id->driver_info == STORAGE_DEVICE)\n\t\treturn send_eject_command(interface);\n\n\thif_dev = kzalloc(sizeof(struct hif_device_usb), GFP_KERNEL);\n\tif (!hif_dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\n\tusb_get_dev(udev);\n\n\thif_dev->udev = udev;\n\thif_dev->interface = interface;\n\thif_dev->usb_device_id = id;\n#ifdef CONFIG_PM\n\tudev->reset_resume = 1;\n#endif\n\tusb_set_intfdata(interface, hif_dev);\n\n\tinit_completion(&hif_dev->fw_done);\n\n\tret = ath9k_hif_request_firmware(hif_dev, true);\n\tif (ret)\n\t\tgoto err_fw_req;\n\n\treturn ret;\n\nerr_fw_req:\n\tusb_set_intfdata(interface, NULL);\n\tkfree(hif_dev);\n\tusb_put_dev(udev);\nerr_alloc:\n\treturn ret;\n}\n\nstatic void ath9k_hif_usb_reboot(struct usb_device *udev)\n{\n\tu32 reboot_cmd = 0xffffffff;\n\tvoid *buf;\n\tint ret;\n\n\tbuf = kmemdup(&reboot_cmd, 4, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\tret = usb_interrupt_msg(udev, usb_sndintpipe(udev, USB_REG_OUT_PIPE),\n\t\t\t   buf, 4, NULL, USB_MSG_TIMEOUT);\n\tif (ret)\n\t\tdev_err(&udev->dev, \"ath9k_htc: USB reboot failed\\n\");\n\n\tkfree(buf);\n}\n\nstatic void ath9k_hif_usb_disconnect(struct usb_interface *interface)\n{\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct hif_device_usb *hif_dev = usb_get_intfdata(interface);\n\tbool unplugged = udev->state == USB_STATE_NOTATTACHED;\n\n\tif (!hif_dev)\n\t\treturn;\n\n\twait_for_completion(&hif_dev->fw_done);\n\n\tif (hif_dev->flags & HIF_USB_READY) {\n\t\tath9k_htc_hw_deinit(hif_dev->htc_handle, unplugged);\n\t\tath9k_htc_hw_free(hif_dev->htc_handle);\n\t}\n\n\tusb_set_intfdata(interface, NULL);\n\n\t \n\tif (!unplugged && (hif_dev->flags & HIF_USB_READY))\n\t\tath9k_hif_usb_reboot(udev);\n\n\tkfree(hif_dev);\n\tdev_info(&udev->dev, \"ath9k_htc: USB layer deinitialized\\n\");\n\tusb_put_dev(udev);\n}\n\n#ifdef CONFIG_PM\nstatic int ath9k_hif_usb_suspend(struct usb_interface *interface,\n\t\t\t\t pm_message_t message)\n{\n\tstruct hif_device_usb *hif_dev = usb_get_intfdata(interface);\n\n\t \n\tif (!(hif_dev->flags & HIF_USB_START))\n\t\tath9k_htc_suspend(hif_dev->htc_handle);\n\n\twait_for_completion(&hif_dev->fw_done);\n\n\tif (hif_dev->flags & HIF_USB_READY)\n\t\tath9k_hif_usb_dealloc_urbs(hif_dev);\n\n\treturn 0;\n}\n\nstatic int ath9k_hif_usb_resume(struct usb_interface *interface)\n{\n\tstruct hif_device_usb *hif_dev = usb_get_intfdata(interface);\n\tstruct htc_target *htc_handle = hif_dev->htc_handle;\n\tint ret;\n\tconst struct firmware *fw;\n\n\tret = ath9k_hif_usb_alloc_urbs(hif_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (hif_dev->flags & HIF_USB_READY) {\n\t\t \n\t\tret = request_firmware(&fw, hif_dev->fw_name,\n\t\t\t\t       &hif_dev->udev->dev);\n\t\tif (ret)\n\t\t\tgoto fail_resume;\n\n\t\thif_dev->fw_data = fw->data;\n\t\thif_dev->fw_size = fw->size;\n\t\tret = ath9k_hif_usb_download_fw(hif_dev);\n\t\trelease_firmware(fw);\n\t\tif (ret)\n\t\t\tgoto fail_resume;\n\t} else {\n\t\tath9k_hif_usb_dealloc_urbs(hif_dev);\n\t\treturn -EIO;\n\t}\n\n\tmdelay(100);\n\n\tret = ath9k_htc_resume(htc_handle);\n\n\tif (ret)\n\t\tgoto fail_resume;\n\n\treturn 0;\n\nfail_resume:\n\tath9k_hif_usb_dealloc_urbs(hif_dev);\n\n\treturn ret;\n}\n#endif\n\nstatic struct usb_driver ath9k_hif_usb_driver = {\n\t.name = KBUILD_MODNAME,\n\t.probe = ath9k_hif_usb_probe,\n\t.disconnect = ath9k_hif_usb_disconnect,\n#ifdef CONFIG_PM\n\t.suspend = ath9k_hif_usb_suspend,\n\t.resume = ath9k_hif_usb_resume,\n\t.reset_resume = ath9k_hif_usb_resume,\n#endif\n\t.id_table = ath9k_hif_usb_ids,\n\t.soft_unbind = 1,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nint ath9k_hif_usb_init(void)\n{\n\treturn usb_register(&ath9k_hif_usb_driver);\n}\n\nvoid ath9k_hif_usb_exit(void)\n{\n\tusb_deregister(&ath9k_hif_usb_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}